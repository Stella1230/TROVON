static int abx500_gpio_get_bit(struct gpio_chip *chip, u8 reg,\r\nunsigned offset, bool *bit)\r\n{\r\nstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\r\nu8 pos = offset % 8;\r\nu8 val;\r\nint ret;\r\nreg += offset / 8;\r\nret = abx500_get_register_interruptible(pct->dev,\r\nAB8500_MISC, reg, &val);\r\n*bit = !!(val & BIT(pos));\r\nif (ret < 0)\r\ndev_err(pct->dev,\r\n"%s read reg =%x, offset=%x failed (%d)\n",\r\n__func__, reg, offset, ret);\r\nreturn ret;\r\n}\r\nstatic int abx500_gpio_set_bits(struct gpio_chip *chip, u8 reg,\r\nunsigned offset, int val)\r\n{\r\nstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\r\nu8 pos = offset % 8;\r\nint ret;\r\nreg += offset / 8;\r\nret = abx500_mask_and_set_register_interruptible(pct->dev,\r\nAB8500_MISC, reg, BIT(pos), val << pos);\r\nif (ret < 0)\r\ndev_err(pct->dev, "%s write reg, %x offset %x failed (%d)\n",\r\n__func__, reg, offset, ret);\r\nreturn ret;\r\n}\r\nstatic int abx500_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\r\nbool bit;\r\nbool is_out;\r\nu8 gpio_offset = offset - 1;\r\nint ret;\r\nret = abx500_gpio_get_bit(chip, AB8500_GPIO_DIR1_REG,\r\ngpio_offset, &is_out);\r\nif (ret < 0)\r\ngoto out;\r\nif (is_out)\r\nret = abx500_gpio_get_bit(chip, AB8500_GPIO_OUT1_REG,\r\ngpio_offset, &bit);\r\nelse\r\nret = abx500_gpio_get_bit(chip, AB8500_GPIO_IN1_REG,\r\ngpio_offset, &bit);\r\nout:\r\nif (ret < 0) {\r\ndev_err(pct->dev, "%s failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nreturn bit;\r\n}\r\nstatic void abx500_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\r\nint ret;\r\nret = abx500_gpio_set_bits(chip, AB8500_GPIO_OUT1_REG, offset, val);\r\nif (ret < 0)\r\ndev_err(pct->dev, "%s write failed (%d)\n", __func__, ret);\r\n}\r\nstatic int abx500_get_pull_updown(struct abx500_pinctrl *pct, int offset,\r\nenum abx500_gpio_pull_updown *pull_updown)\r\n{\r\nu8 pos;\r\nu8 val;\r\nint ret;\r\nstruct pullud *pullud;\r\nif (!pct->soc->pullud) {\r\ndev_err(pct->dev, "%s AB chip doesn't support pull up/down feature",\r\n__func__);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\npullud = pct->soc->pullud;\r\nif ((offset < pullud->first_pin)\r\n|| (offset > pullud->last_pin)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = abx500_get_register_interruptible(pct->dev,\r\nAB8500_MISC, AB8540_GPIO_PULL_UPDOWN_REG, &val);\r\npos = (offset - pullud->first_pin) << 1;\r\n*pull_updown = (val >> pos) & AB8540_GPIO_PULL_UPDOWN_MASK;\r\nout:\r\nif (ret < 0)\r\ndev_err(pct->dev, "%s failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int abx500_set_pull_updown(struct abx500_pinctrl *pct,\r\nint offset, enum abx500_gpio_pull_updown val)\r\n{\r\nu8 pos;\r\nint ret;\r\nstruct pullud *pullud;\r\nif (!pct->soc->pullud) {\r\ndev_err(pct->dev, "%s AB chip doesn't support pull up/down feature",\r\n__func__);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\npullud = pct->soc->pullud;\r\nif ((offset < pullud->first_pin)\r\n|| (offset > pullud->last_pin)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npos = (offset - pullud->first_pin) << 1;\r\nret = abx500_mask_and_set_register_interruptible(pct->dev,\r\nAB8500_MISC, AB8540_GPIO_PULL_UPDOWN_REG,\r\nAB8540_GPIO_PULL_UPDOWN_MASK << pos, val << pos);\r\nout:\r\nif (ret < 0)\r\ndev_err(pct->dev, "%s failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic bool abx500_pullud_supported(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\r\nstruct pullud *pullud = pct->soc->pullud;\r\nreturn (pullud &&\r\ngpio >= pullud->first_pin &&\r\ngpio <= pullud->last_pin);\r\n}\r\nstatic int abx500_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset,\r\nint val)\r\n{\r\nstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\r\nunsigned gpio;\r\nint ret;\r\nret = abx500_gpio_set_bits(chip,\r\nAB8500_GPIO_DIR1_REG,\r\noffset,\r\nABX500_GPIO_OUTPUT);\r\nif (ret < 0)\r\ngoto out;\r\nret = abx500_gpio_set_bits(chip,\r\nAB8500_GPIO_PUD1_REG,\r\noffset,\r\nABX500_GPIO_PULL_NONE);\r\nif (ret < 0)\r\ngoto out;\r\ngpio = offset + 1;\r\nif (abx500_pullud_supported(chip, gpio)) {\r\nret = abx500_set_pull_updown(pct,\r\ngpio,\r\nABX500_GPIO_PULL_NONE);\r\n}\r\nout:\r\nif (ret < 0) {\r\ndev_err(pct->dev, "%s failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nreturn abx500_gpio_set_bits(chip, AB8500_GPIO_OUT1_REG, offset, val);\r\n}\r\nstatic int abx500_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn abx500_gpio_set_bits(chip,\r\nAB8500_GPIO_DIR1_REG,\r\noffset,\r\nABX500_GPIO_INPUT);\r\n}\r\nstatic int abx500_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\r\nint gpio = offset + 1;\r\nint hwirq;\r\nint i;\r\nfor (i = 0; i < pct->irq_cluster_size; i++) {\r\nstruct abx500_gpio_irq_cluster *cluster =\r\n&pct->irq_cluster[i];\r\nif (gpio >= cluster->start && gpio <= cluster->end) {\r\nhwirq = gpio - cluster->start + cluster->to_irq;\r\nreturn irq_create_mapping(pct->parent->domain, hwirq);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int abx500_set_mode(struct pinctrl_dev *pctldev, struct gpio_chip *chip,\r\nunsigned gpio, int alt_setting)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nstruct alternate_functions af = pct->soc->alternate_functions[gpio];\r\nint ret;\r\nint val;\r\nunsigned offset;\r\nconst char *modes[] = {\r\n[ABX500_DEFAULT] = "default",\r\n[ABX500_ALT_A] = "altA",\r\n[ABX500_ALT_B] = "altB",\r\n[ABX500_ALT_C] = "altC",\r\n};\r\nif (((alt_setting == ABX500_ALT_A) && (af.gpiosel_bit == UNUSED)) ||\r\n((alt_setting == ABX500_ALT_B) && (af.alt_bit1 == UNUSED)) ||\r\n((alt_setting == ABX500_ALT_C) && (af.alt_bit2 == UNUSED))) {\r\ndev_dbg(pct->dev, "pin %d doesn't support %s mode\n", gpio,\r\nmodes[alt_setting]);\r\nreturn -EINVAL;\r\n}\r\noffset = gpio - 1;\r\nswitch (alt_setting) {\r\ncase ABX500_DEFAULT:\r\nval = 0;\r\nif (af.alt_bit1 != UNUSED)\r\nval++;\r\nret = abx500_gpio_set_bits(chip, AB8500_GPIO_SEL1_REG,\r\noffset, val);\r\nbreak;\r\ncase ABX500_ALT_A:\r\nif (af.alt_bit1 != UNUSED) {\r\nret = abx500_gpio_set_bits(chip, AB8500_GPIO_SEL1_REG,\r\noffset, 0);\r\nif (ret < 0)\r\ngoto out;\r\nret = abx500_gpio_set_bits(chip,\r\nAB8500_GPIO_ALTFUN_REG,\r\naf.alt_bit1,\r\n!!(af.alta_val & BIT(0)));\r\nif (ret < 0)\r\ngoto out;\r\nif (af.alt_bit2 != UNUSED)\r\nret = abx500_gpio_set_bits(chip,\r\nAB8500_GPIO_ALTFUN_REG,\r\naf.alt_bit2,\r\n!!(af.alta_val & BIT(1)));\r\n} else\r\nret = abx500_gpio_set_bits(chip, AB8500_GPIO_SEL1_REG,\r\noffset, 1);\r\nbreak;\r\ncase ABX500_ALT_B:\r\nret = abx500_gpio_set_bits(chip, AB8500_GPIO_SEL1_REG,\r\noffset, 0);\r\nif (ret < 0)\r\ngoto out;\r\nret = abx500_gpio_set_bits(chip, AB8500_GPIO_ALTFUN_REG,\r\naf.alt_bit1, !!(af.altb_val & BIT(0)));\r\nif (ret < 0)\r\ngoto out;\r\nif (af.alt_bit2 != UNUSED)\r\nret = abx500_gpio_set_bits(chip,\r\nAB8500_GPIO_ALTFUN_REG,\r\naf.alt_bit2,\r\n!!(af.altb_val & BIT(1)));\r\nbreak;\r\ncase ABX500_ALT_C:\r\nret = abx500_gpio_set_bits(chip, AB8500_GPIO_SEL1_REG,\r\noffset, 0);\r\nif (ret < 0)\r\ngoto out;\r\nret = abx500_gpio_set_bits(chip, AB8500_GPIO_ALTFUN_REG,\r\naf.alt_bit2, !!(af.altc_val & BIT(0)));\r\nif (ret < 0)\r\ngoto out;\r\nret = abx500_gpio_set_bits(chip, AB8500_GPIO_ALTFUN_REG,\r\naf.alt_bit2, !!(af.altc_val & BIT(1)));\r\nbreak;\r\ndefault:\r\ndev_dbg(pct->dev, "unknown alt_setting %d\n", alt_setting);\r\nreturn -EINVAL;\r\n}\r\nout:\r\nif (ret < 0)\r\ndev_err(pct->dev, "%s failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int abx500_get_mode(struct pinctrl_dev *pctldev, struct gpio_chip *chip,\r\nunsigned gpio)\r\n{\r\nu8 mode;\r\nbool bit_mode;\r\nbool alt_bit1;\r\nbool alt_bit2;\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nstruct alternate_functions af = pct->soc->alternate_functions[gpio];\r\nunsigned offset = gpio - 1;\r\nint ret;\r\nif (af.gpiosel_bit == UNUSED)\r\nreturn ABX500_DEFAULT;\r\nret = abx500_gpio_get_bit(chip, AB8500_GPIO_SEL1_REG + (offset / 8),\r\naf.gpiosel_bit, &bit_mode);\r\nif (ret < 0)\r\ngoto out;\r\nmode = bit_mode;\r\nif ((af.alt_bit1 < UNUSED) || (af.alt_bit1 > 7) ||\r\n(af.alt_bit2 < UNUSED) || (af.alt_bit2 > 7)) {\r\ndev_err(pct->dev,\r\n"alt_bitX value not in correct range (-1 to 7)\n");\r\nreturn -EINVAL;\r\n}\r\nif ((af.alt_bit2 != UNUSED) && (af.alt_bit1 == UNUSED)) {\r\ndev_err(pct->dev,\r\n"if alt_bit2 is used, alt_bit1 can't be unused\n");\r\nreturn -EINVAL;\r\n}\r\nif ((af.alt_bit1 == UNUSED) && (af.alt_bit2 == UNUSED))\r\nreturn mode;\r\nif (mode)\r\nreturn ABX500_DEFAULT;\r\nret = abx500_gpio_get_bit(chip, AB8500_GPIO_ALTFUN_REG,\r\naf.alt_bit1, &alt_bit1);\r\nif (ret < 0)\r\ngoto out;\r\nif (af.alt_bit2 != UNUSED) {\r\nret = abx500_gpio_get_bit(chip, AB8500_GPIO_ALTFUN_REG,\r\naf.alt_bit2,\r\n&alt_bit2);\r\nif (ret < 0)\r\ngoto out;\r\n} else\r\nalt_bit2 = 0;\r\nmode = (alt_bit2 << 1) + alt_bit1;\r\nif (mode == af.alta_val)\r\nreturn ABX500_ALT_A;\r\nelse if (mode == af.altb_val)\r\nreturn ABX500_ALT_B;\r\nelse\r\nreturn ABX500_ALT_C;\r\nout:\r\ndev_err(pct->dev, "%s failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void abx500_gpio_dbg_show_one(struct seq_file *s,\r\nstruct pinctrl_dev *pctldev,\r\nstruct gpio_chip *chip,\r\nunsigned offset, unsigned gpio)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nconst char *label = gpiochip_is_requested(chip, offset - 1);\r\nu8 gpio_offset = offset - 1;\r\nint mode = -1;\r\nbool is_out;\r\nbool pd;\r\nenum abx500_gpio_pull_updown pud = 0;\r\nint ret;\r\nconst char *modes[] = {\r\n[ABX500_DEFAULT] = "default",\r\n[ABX500_ALT_A] = "altA",\r\n[ABX500_ALT_B] = "altB",\r\n[ABX500_ALT_C] = "altC",\r\n};\r\nconst char *pull_up_down[] = {\r\n[ABX500_GPIO_PULL_DOWN] = "pull down",\r\n[ABX500_GPIO_PULL_NONE] = "pull none",\r\n[ABX500_GPIO_PULL_NONE + 1] = "pull none",\r\n[ABX500_GPIO_PULL_UP] = "pull up",\r\n};\r\nret = abx500_gpio_get_bit(chip, AB8500_GPIO_DIR1_REG,\r\ngpio_offset, &is_out);\r\nif (ret < 0)\r\ngoto out;\r\nseq_printf(s, " gpio-%-3d (%-20.20s) %-3s",\r\ngpio, label ?: "(none)",\r\nis_out ? "out" : "in ");\r\nif (!is_out) {\r\nif (abx500_pullud_supported(chip, offset)) {\r\nret = abx500_get_pull_updown(pct, offset, &pud);\r\nif (ret < 0)\r\ngoto out;\r\nseq_printf(s, " %-9s", pull_up_down[pud]);\r\n} else {\r\nret = abx500_gpio_get_bit(chip, AB8500_GPIO_PUD1_REG,\r\ngpio_offset, &pd);\r\nif (ret < 0)\r\ngoto out;\r\nseq_printf(s, " %-9s", pull_up_down[pd]);\r\n}\r\n} else\r\nseq_printf(s, " %-9s", chip->get(chip, offset) ? "hi" : "lo");\r\nmode = abx500_get_mode(pctldev, chip, offset);\r\nseq_printf(s, " %s", (mode < 0) ? "unknown" : modes[mode]);\r\nout:\r\nif (ret < 0)\r\ndev_err(pct->dev, "%s failed (%d)\n", __func__, ret);\r\n}\r\nstatic void abx500_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nunsigned i;\r\nunsigned gpio = chip->base;\r\nstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\r\nstruct pinctrl_dev *pctldev = pct->pctldev;\r\nfor (i = 0; i < chip->ngpio; i++, gpio++) {\r\nabx500_gpio_dbg_show_one(s, pctldev, chip, i + 1, gpio);\r\nseq_printf(s, "\n");\r\n}\r\n}\r\nstatic inline void abx500_gpio_dbg_show_one(struct seq_file *s,\r\nstruct pinctrl_dev *pctldev,\r\nstruct gpio_chip *chip,\r\nunsigned offset, unsigned gpio)\r\n{\r\n}\r\nstatic int abx500_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pct->soc->nfunctions;\r\n}\r\nstatic const char *abx500_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pct->soc->functions[function].name;\r\n}\r\nstatic int abx500_pmx_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pct->soc->functions[function].groups;\r\n*num_groups = pct->soc->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int abx500_pmx_set(struct pinctrl_dev *pctldev, unsigned function,\r\nunsigned group)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nstruct gpio_chip *chip = &pct->chip;\r\nconst struct abx500_pingroup *g;\r\nint i;\r\nint ret = 0;\r\ng = &pct->soc->groups[group];\r\nif (g->altsetting < 0)\r\nreturn -EINVAL;\r\ndev_dbg(pct->dev, "enable group %s, %u pins\n", g->name, g->npins);\r\nfor (i = 0; i < g->npins; i++) {\r\ndev_dbg(pct->dev, "setting pin %d to altsetting %d\n",\r\ng->pins[i], g->altsetting);\r\nret = abx500_set_mode(pctldev, chip, g->pins[i], g->altsetting);\r\n}\r\nif (ret < 0)\r\ndev_err(pct->dev, "%s failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int abx500_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct abx500_pinrange *p;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < pct->soc->gpio_num_ranges; i++) {\r\np = &pct->soc->gpio_ranges[i];\r\nif ((offset >= p->offset) &&\r\n(offset < (p->offset + p->npins)))\r\nbreak;\r\n}\r\nif (i == pct->soc->gpio_num_ranges) {\r\ndev_err(pct->dev, "%s failed to locate range\n", __func__);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(pct->dev, "enable GPIO by altfunc %d at gpio %d\n",\r\np->altfunc, offset);\r\nret = abx500_set_mode(pct->pctldev, &pct->chip,\r\noffset, p->altfunc);\r\nif (ret < 0)\r\ndev_err(pct->dev, "%s setting altfunc failed\n", __func__);\r\nreturn ret;\r\n}\r\nstatic void abx500_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\n}\r\nstatic int abx500_get_groups_cnt(struct pinctrl_dev *pctldev)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pct->soc->ngroups;\r\n}\r\nstatic const char *abx500_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pct->soc->groups[selector].name;\r\n}\r\nstatic int abx500_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pct->soc->groups[selector].pins;\r\n*num_pins = pct->soc->groups[selector].npins;\r\nreturn 0;\r\n}\r\nstatic void abx500_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned offset)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nstruct gpio_chip *chip = &pct->chip;\r\nabx500_gpio_dbg_show_one(s, pctldev, chip, offset,\r\nchip->base + offset - 1);\r\n}\r\nstatic int abx500_dt_add_map_mux(struct pinctrl_map **map,\r\nunsigned *reserved_maps,\r\nunsigned *num_maps, const char *group,\r\nconst char *function)\r\n{\r\nif (*num_maps == *reserved_maps)\r\nreturn -ENOSPC;\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[*num_maps].data.mux.group = group;\r\n(*map)[*num_maps].data.mux.function = function;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic int abx500_dt_add_map_configs(struct pinctrl_map **map,\r\nunsigned *reserved_maps,\r\nunsigned *num_maps, const char *group,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nunsigned long *dup_configs;\r\nif (*num_maps == *reserved_maps)\r\nreturn -ENOSPC;\r\ndup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),\r\nGFP_KERNEL);\r\nif (!dup_configs)\r\nreturn -ENOMEM;\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_CONFIGS_PIN;\r\n(*map)[*num_maps].data.configs.group_or_pin = group;\r\n(*map)[*num_maps].data.configs.configs = dup_configs;\r\n(*map)[*num_maps].data.configs.num_configs = num_configs;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic const char *abx500_find_pin_name(struct pinctrl_dev *pctldev,\r\nconst char *pin_name)\r\n{\r\nint i, pin_number;\r\nstruct abx500_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nif (sscanf((char *)pin_name, "GPIO%d", &pin_number) == 1)\r\nfor (i = 0; i < npct->soc->npins; i++)\r\nif (npct->soc->pins[i].number == pin_number)\r\nreturn npct->soc->pins[i].name;\r\nreturn NULL;\r\n}\r\nstatic int abx500_dt_subnode_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *reserved_maps,\r\nunsigned *num_maps)\r\n{\r\nint ret;\r\nconst char *function = NULL;\r\nunsigned long *configs;\r\nunsigned int nconfigs = 0;\r\nstruct property *prop;\r\nret = of_property_read_string(np, "function", &function);\r\nif (ret >= 0) {\r\nconst char *group;\r\nret = of_property_count_strings(np, "groups");\r\nif (ret < 0)\r\ngoto exit;\r\nret = pinctrl_utils_reserve_map(pctldev, map, reserved_maps,\r\nnum_maps, ret);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, "groups", prop, group) {\r\nret = abx500_dt_add_map_mux(map, reserved_maps,\r\nnum_maps, group, function);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nret = pinconf_generic_parse_dt_config(np, pctldev, &configs, &nconfigs);\r\nif (nconfigs) {\r\nconst char *gpio_name;\r\nconst char *pin;\r\nret = of_property_count_strings(np, "pins");\r\nif (ret < 0)\r\ngoto exit;\r\nret = pinctrl_utils_reserve_map(pctldev, map,\r\nreserved_maps,\r\nnum_maps, ret);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, "pins", prop, pin) {\r\ngpio_name = abx500_find_pin_name(pctldev, pin);\r\nret = abx500_dt_add_map_configs(map, reserved_maps,\r\nnum_maps, gpio_name, configs, 1);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int abx500_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nunsigned reserved_maps;\r\nstruct device_node *np;\r\nint ret;\r\nreserved_maps = 0;\r\n*map = NULL;\r\n*num_maps = 0;\r\nfor_each_child_of_node(np_config, np) {\r\nret = abx500_dt_subnode_to_map(pctldev, np, map,\r\n&reserved_maps, num_maps);\r\nif (ret < 0) {\r\npinctrl_utils_free_map(pctldev, *map, *num_maps);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int abx500_pin_config_get(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *config)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int abx500_pin_config_set(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\r\nstruct gpio_chip *chip = &pct->chip;\r\nunsigned offset;\r\nint ret = -EINVAL;\r\nint i;\r\nenum pin_config_param param;\r\nenum pin_config_param argument;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\nargument = pinconf_to_config_argument(configs[i]);\r\ndev_dbg(chip->parent, "pin %d [%#lx]: %s %s\n",\r\npin, configs[i],\r\n(param == PIN_CONFIG_OUTPUT) ? "output " : "input",\r\n(param == PIN_CONFIG_OUTPUT) ?\r\n(argument ? "high" : "low") :\r\n(argument ? "pull up" : "pull down"));\r\noffset = pin - 1;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nret = abx500_gpio_direction_input(chip, offset);\r\nif (ret < 0)\r\ngoto out;\r\nif (abx500_pullud_supported(chip, pin))\r\nret = abx500_set_pull_updown(pct,\r\npin,\r\nABX500_GPIO_PULL_NONE);\r\nelse\r\nret = abx500_gpio_set_bits(chip,\r\nAB8500_GPIO_PUD1_REG, offset,\r\nABX500_GPIO_PULL_NONE);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = abx500_gpio_direction_input(chip, offset);\r\nif (ret < 0)\r\ngoto out;\r\nif (abx500_pullud_supported(chip, pin))\r\nret = abx500_set_pull_updown(pct,\r\npin,\r\nargument ? ABX500_GPIO_PULL_DOWN :\r\nABX500_GPIO_PULL_NONE);\r\nelse\r\nret = abx500_gpio_set_bits(chip,\r\nAB8500_GPIO_PUD1_REG,\r\noffset,\r\nargument ? ABX500_GPIO_PULL_DOWN :\r\nABX500_GPIO_PULL_NONE);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nret = abx500_gpio_direction_input(chip, offset);\r\nif (ret < 0)\r\ngoto out;\r\nret = abx500_gpio_direction_input(chip, offset);\r\nif (abx500_pullud_supported(chip, pin))\r\nret = abx500_set_pull_updown(pct,\r\npin,\r\nargument ? ABX500_GPIO_PULL_UP :\r\nABX500_GPIO_PULL_NONE);\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\nret = abx500_gpio_direction_output(chip, offset,\r\nargument);\r\nbreak;\r\ndefault:\r\ndev_err(chip->parent,\r\n"illegal configuration requested\n");\r\n}\r\n}\r\nout:\r\nif (ret < 0)\r\ndev_err(pct->dev, "%s failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int abx500_get_gpio_num(struct abx500_pinctrl_soc_data *soc)\r\n{\r\nunsigned int lowest = 0;\r\nunsigned int highest = 0;\r\nunsigned int npins = 0;\r\nint i;\r\nfor (i = 0; i < soc->gpio_num_ranges; i++) {\r\nunsigned gstart;\r\nunsigned gend;\r\nconst struct abx500_pinrange *p;\r\np = &soc->gpio_ranges[i];\r\ngstart = p->offset;\r\ngend = p->offset + p->npins - 1;\r\nif (i == 0) {\r\nlowest = gstart;\r\nhighest = gend;\r\n} else {\r\nif (gstart < lowest)\r\nlowest = gstart;\r\nif (gend > highest)\r\nhighest = gend;\r\n}\r\n}\r\nnpins = highest - lowest + 1;\r\nreturn npins;\r\n}\r\nstatic int abx500_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nstruct abx500_pinctrl *pct;\r\nunsigned int id = -1;\r\nint ret;\r\nint i;\r\nif (!np) {\r\ndev_err(&pdev->dev, "gpio dt node missing\n");\r\nreturn -ENODEV;\r\n}\r\npct = devm_kzalloc(&pdev->dev, sizeof(struct abx500_pinctrl),\r\nGFP_KERNEL);\r\nif (pct == NULL) {\r\ndev_err(&pdev->dev,\r\n"failed to allocate memory for pct\n");\r\nreturn -ENOMEM;\r\n}\r\npct->dev = &pdev->dev;\r\npct->parent = dev_get_drvdata(pdev->dev.parent);\r\npct->chip = abx500gpio_chip;\r\npct->chip.parent = &pdev->dev;\r\npct->chip.base = -1;\r\nmatch = of_match_device(abx500_gpio_match, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "gpio dt not matching\n");\r\nreturn -ENODEV;\r\n}\r\nid = (unsigned long)match->data;\r\nswitch (id) {\r\ncase PINCTRL_AB8500:\r\nabx500_pinctrl_ab8500_init(&pct->soc);\r\nbreak;\r\ncase PINCTRL_AB8540:\r\nabx500_pinctrl_ab8540_init(&pct->soc);\r\nbreak;\r\ncase PINCTRL_AB9540:\r\nabx500_pinctrl_ab9540_init(&pct->soc);\r\nbreak;\r\ncase PINCTRL_AB8505:\r\nabx500_pinctrl_ab8505_init(&pct->soc);\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported pinctrl sub driver (%d)\n", id);\r\nreturn -EINVAL;\r\n}\r\nif (!pct->soc) {\r\ndev_err(&pdev->dev, "Invalid SOC data\n");\r\nreturn -EINVAL;\r\n}\r\npct->chip.ngpio = abx500_get_gpio_num(pct->soc);\r\npct->irq_cluster = pct->soc->gpio_irq_cluster;\r\npct->irq_cluster_size = pct->soc->ngpio_irq_cluster;\r\nret = gpiochip_add_data(&pct->chip, pct);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to add gpiochip: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_info(&pdev->dev, "added gpiochip\n");\r\nabx500_pinctrl_desc.pins = pct->soc->pins;\r\nabx500_pinctrl_desc.npins = pct->soc->npins;\r\npct->pctldev = devm_pinctrl_register(&pdev->dev, &abx500_pinctrl_desc,\r\npct);\r\nif (IS_ERR(pct->pctldev)) {\r\ndev_err(&pdev->dev,\r\n"could not register abx500 pinctrl driver\n");\r\nret = PTR_ERR(pct->pctldev);\r\ngoto out_rem_chip;\r\n}\r\ndev_info(&pdev->dev, "registered pin controller\n");\r\nfor (i = 0; i < pct->soc->gpio_num_ranges; i++) {\r\nconst struct abx500_pinrange *p = &pct->soc->gpio_ranges[i];\r\nret = gpiochip_add_pin_range(&pct->chip,\r\ndev_name(&pdev->dev),\r\np->offset - 1, p->offset, p->npins);\r\nif (ret < 0)\r\ngoto out_rem_chip;\r\n}\r\nplatform_set_drvdata(pdev, pct);\r\ndev_info(&pdev->dev, "initialized abx500 pinctrl driver\n");\r\nreturn 0;\r\nout_rem_chip:\r\ngpiochip_remove(&pct->chip);\r\nreturn ret;\r\n}\r\nstatic int abx500_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct abx500_pinctrl *pct = platform_get_drvdata(pdev);\r\ngpiochip_remove(&pct->chip);\r\nreturn 0;\r\n}\r\nstatic int __init abx500_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&abx500_gpio_driver);\r\n}
