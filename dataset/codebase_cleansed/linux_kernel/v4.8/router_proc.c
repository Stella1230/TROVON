static int __proc_lnet_stats(void *data, int write,\r\nloff_t pos, void __user *buffer, int nob)\r\n{\r\nint rc;\r\nlnet_counters_t *ctrs;\r\nint len;\r\nchar *tmpstr;\r\nconst int tmpsiz = 256;\r\nif (write) {\r\nlnet_counters_reset();\r\nreturn 0;\r\n}\r\nLIBCFS_ALLOC(ctrs, sizeof(*ctrs));\r\nif (!ctrs)\r\nreturn -ENOMEM;\r\nLIBCFS_ALLOC(tmpstr, tmpsiz);\r\nif (!tmpstr) {\r\nLIBCFS_FREE(ctrs, sizeof(*ctrs));\r\nreturn -ENOMEM;\r\n}\r\nlnet_counters_get(ctrs);\r\nlen = snprintf(tmpstr, tmpsiz,\r\n"%u %u %u %u %u %u %u %llu %llu %llu %llu",\r\nctrs->msgs_alloc, ctrs->msgs_max,\r\nctrs->errors,\r\nctrs->send_count, ctrs->recv_count,\r\nctrs->route_count, ctrs->drop_count,\r\nctrs->send_length, ctrs->recv_length,\r\nctrs->route_length, ctrs->drop_length);\r\nif (pos >= min_t(int, len, strlen(tmpstr)))\r\nrc = 0;\r\nelse\r\nrc = cfs_trace_copyout_string(buffer, nob,\r\ntmpstr + pos, "\n");\r\nLIBCFS_FREE(tmpstr, tmpsiz);\r\nLIBCFS_FREE(ctrs, sizeof(*ctrs));\r\nreturn rc;\r\n}\r\nstatic int proc_lnet_stats(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nreturn lprocfs_call_handler(table->data, write, ppos, buffer, lenp,\r\n__proc_lnet_stats);\r\n}\r\nstatic int proc_lnet_routes(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nconst int tmpsiz = 256;\r\nchar *tmpstr;\r\nchar *s;\r\nint rc = 0;\r\nint len;\r\nint ver;\r\nint off;\r\nCLASSERT(sizeof(loff_t) >= 4);\r\noff = LNET_PROC_HOFF_GET(*ppos);\r\nver = LNET_PROC_VER_GET(*ppos);\r\nLASSERT(!write);\r\nif (!*lenp)\r\nreturn 0;\r\nLIBCFS_ALLOC(tmpstr, tmpsiz);\r\nif (!tmpstr)\r\nreturn -ENOMEM;\r\ns = tmpstr;\r\nif (!*ppos) {\r\ns += snprintf(s, tmpstr + tmpsiz - s, "Routing %s\n",\r\nthe_lnet.ln_routing ? "enabled" : "disabled");\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\ns += snprintf(s, tmpstr + tmpsiz - s, "%-8s %4s %8s %7s %s\n",\r\n"net", "hops", "priority", "state", "router");\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\nlnet_net_lock(0);\r\nver = (unsigned int)the_lnet.ln_remote_nets_version;\r\nlnet_net_unlock(0);\r\n*ppos = LNET_PROC_POS_MAKE(0, ver, 0, off);\r\n} else {\r\nstruct list_head *n;\r\nstruct list_head *r;\r\nlnet_route_t *route = NULL;\r\nlnet_remotenet_t *rnet = NULL;\r\nint skip = off - 1;\r\nstruct list_head *rn_list;\r\nint i;\r\nlnet_net_lock(0);\r\nif (ver != LNET_PROC_VERSION(the_lnet.ln_remote_nets_version)) {\r\nlnet_net_unlock(0);\r\nLIBCFS_FREE(tmpstr, tmpsiz);\r\nreturn -ESTALE;\r\n}\r\nfor (i = 0; i < LNET_REMOTE_NETS_HASH_SIZE && !route; i++) {\r\nrn_list = &the_lnet.ln_remote_nets_hash[i];\r\nn = rn_list->next;\r\nwhile (n != rn_list && !route) {\r\nrnet = list_entry(n, lnet_remotenet_t,\r\nlrn_list);\r\nr = rnet->lrn_routes.next;\r\nwhile (r != &rnet->lrn_routes) {\r\nlnet_route_t *re =\r\nlist_entry(r, lnet_route_t,\r\nlr_list);\r\nif (!skip) {\r\nroute = re;\r\nbreak;\r\n}\r\nskip--;\r\nr = r->next;\r\n}\r\nn = n->next;\r\n}\r\n}\r\nif (route) {\r\n__u32 net = rnet->lrn_net;\r\n__u32 hops = route->lr_hops;\r\nunsigned int priority = route->lr_priority;\r\nlnet_nid_t nid = route->lr_gateway->lp_nid;\r\nint alive = lnet_is_route_alive(route);\r\ns += snprintf(s, tmpstr + tmpsiz - s,\r\n"%-8s %4u %8u %7s %s\n",\r\nlibcfs_net2str(net), hops,\r\npriority,\r\nalive ? "up" : "down",\r\nlibcfs_nid2str(nid));\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\n}\r\nlnet_net_unlock(0);\r\n}\r\nlen = s - tmpstr;\r\nif (len > *lenp) {\r\nrc = -EINVAL;\r\n} else if (len > 0) {\r\nif (copy_to_user(buffer, tmpstr, len)) {\r\nrc = -EFAULT;\r\n} else {\r\noff += 1;\r\n*ppos = LNET_PROC_POS_MAKE(0, ver, 0, off);\r\n}\r\n}\r\nLIBCFS_FREE(tmpstr, tmpsiz);\r\nif (!rc)\r\n*lenp = len;\r\nreturn rc;\r\n}\r\nstatic int proc_lnet_routers(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint rc = 0;\r\nchar *tmpstr;\r\nchar *s;\r\nconst int tmpsiz = 256;\r\nint len;\r\nint ver;\r\nint off;\r\noff = LNET_PROC_HOFF_GET(*ppos);\r\nver = LNET_PROC_VER_GET(*ppos);\r\nLASSERT(!write);\r\nif (!*lenp)\r\nreturn 0;\r\nLIBCFS_ALLOC(tmpstr, tmpsiz);\r\nif (!tmpstr)\r\nreturn -ENOMEM;\r\ns = tmpstr;\r\nif (!*ppos) {\r\ns += snprintf(s, tmpstr + tmpsiz - s,\r\n"%-4s %7s %9s %6s %12s %9s %8s %7s %s\n",\r\n"ref", "rtr_ref", "alive_cnt", "state",\r\n"last_ping", "ping_sent", "deadline",\r\n"down_ni", "router");\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\nlnet_net_lock(0);\r\nver = (unsigned int)the_lnet.ln_routers_version;\r\nlnet_net_unlock(0);\r\n*ppos = LNET_PROC_POS_MAKE(0, ver, 0, off);\r\n} else {\r\nstruct list_head *r;\r\nstruct lnet_peer *peer = NULL;\r\nint skip = off - 1;\r\nlnet_net_lock(0);\r\nif (ver != LNET_PROC_VERSION(the_lnet.ln_routers_version)) {\r\nlnet_net_unlock(0);\r\nLIBCFS_FREE(tmpstr, tmpsiz);\r\nreturn -ESTALE;\r\n}\r\nr = the_lnet.ln_routers.next;\r\nwhile (r != &the_lnet.ln_routers) {\r\nlnet_peer_t *lp = list_entry(r, lnet_peer_t,\r\nlp_rtr_list);\r\nif (!skip) {\r\npeer = lp;\r\nbreak;\r\n}\r\nskip--;\r\nr = r->next;\r\n}\r\nif (peer) {\r\nlnet_nid_t nid = peer->lp_nid;\r\nunsigned long now = cfs_time_current();\r\nunsigned long deadline = peer->lp_ping_deadline;\r\nint nrefs = peer->lp_refcount;\r\nint nrtrrefs = peer->lp_rtr_refcount;\r\nint alive_cnt = peer->lp_alive_count;\r\nint alive = peer->lp_alive;\r\nint pingsent = !peer->lp_ping_notsent;\r\nint last_ping = cfs_duration_sec(cfs_time_sub(now,\r\npeer->lp_ping_timestamp));\r\nint down_ni = 0;\r\nlnet_route_t *rtr;\r\nif ((peer->lp_ping_feats &\r\nLNET_PING_FEAT_NI_STATUS)) {\r\nlist_for_each_entry(rtr, &peer->lp_routes,\r\nlr_gwlist) {\r\nif (rtr->lr_downis) {\r\ndown_ni = rtr->lr_downis;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!deadline)\r\ns += snprintf(s, tmpstr + tmpsiz - s,\r\n"%-4d %7d %9d %6s %12d %9d %8s %7d %s\n",\r\nnrefs, nrtrrefs, alive_cnt,\r\nalive ? "up" : "down", last_ping,\r\npingsent, "NA", down_ni,\r\nlibcfs_nid2str(nid));\r\nelse\r\ns += snprintf(s, tmpstr + tmpsiz - s,\r\n"%-4d %7d %9d %6s %12d %9d %8lu %7d %s\n",\r\nnrefs, nrtrrefs, alive_cnt,\r\nalive ? "up" : "down", last_ping,\r\npingsent,\r\ncfs_duration_sec(cfs_time_sub(deadline, now)),\r\ndown_ni, libcfs_nid2str(nid));\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\n}\r\nlnet_net_unlock(0);\r\n}\r\nlen = s - tmpstr;\r\nif (len > *lenp) {\r\nrc = -EINVAL;\r\n} else if (len > 0) {\r\nif (copy_to_user(buffer, tmpstr, len)) {\r\nrc = -EFAULT;\r\n} else {\r\noff += 1;\r\n*ppos = LNET_PROC_POS_MAKE(0, ver, 0, off);\r\n}\r\n}\r\nLIBCFS_FREE(tmpstr, tmpsiz);\r\nif (!rc)\r\n*lenp = len;\r\nreturn rc;\r\n}\r\nstatic int proc_lnet_peers(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nconst int tmpsiz = 256;\r\nstruct lnet_peer_table *ptable;\r\nchar *tmpstr;\r\nchar *s;\r\nint cpt = LNET_PROC_CPT_GET(*ppos);\r\nint ver = LNET_PROC_VER_GET(*ppos);\r\nint hash = LNET_PROC_HASH_GET(*ppos);\r\nint hoff = LNET_PROC_HOFF_GET(*ppos);\r\nint rc = 0;\r\nint len;\r\nCLASSERT(LNET_PROC_HASH_BITS >= LNET_PEER_HASH_BITS);\r\nLASSERT(!write);\r\nif (!*lenp)\r\nreturn 0;\r\nif (cpt >= LNET_CPT_NUMBER) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nLIBCFS_ALLOC(tmpstr, tmpsiz);\r\nif (!tmpstr)\r\nreturn -ENOMEM;\r\ns = tmpstr;\r\nif (!*ppos) {\r\ns += snprintf(s, tmpstr + tmpsiz - s,\r\n"%-24s %4s %5s %5s %5s %5s %5s %5s %5s %s\n",\r\n"nid", "refs", "state", "last", "max",\r\n"rtr", "min", "tx", "min", "queue");\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\nhoff++;\r\n} else {\r\nstruct lnet_peer *peer;\r\nstruct list_head *p;\r\nint skip;\r\nagain:\r\np = NULL;\r\npeer = NULL;\r\nskip = hoff - 1;\r\nlnet_net_lock(cpt);\r\nptable = the_lnet.ln_peer_tables[cpt];\r\nif (hoff == 1)\r\nver = LNET_PROC_VERSION(ptable->pt_version);\r\nif (ver != LNET_PROC_VERSION(ptable->pt_version)) {\r\nlnet_net_unlock(cpt);\r\nLIBCFS_FREE(tmpstr, tmpsiz);\r\nreturn -ESTALE;\r\n}\r\nwhile (hash < LNET_PEER_HASH_SIZE) {\r\nif (!p)\r\np = ptable->pt_hash[hash].next;\r\nwhile (p != &ptable->pt_hash[hash]) {\r\nlnet_peer_t *lp = list_entry(p, lnet_peer_t,\r\nlp_hashlist);\r\nif (!skip) {\r\npeer = lp;\r\nif (lp->lp_hashlist.next ==\r\n&ptable->pt_hash[hash]) {\r\nhoff = 1;\r\nhash++;\r\n} else {\r\nhoff++;\r\n}\r\nbreak;\r\n}\r\nskip--;\r\np = lp->lp_hashlist.next;\r\n}\r\nif (peer)\r\nbreak;\r\np = NULL;\r\nhoff = 1;\r\nhash++;\r\n}\r\nif (peer) {\r\nlnet_nid_t nid = peer->lp_nid;\r\nint nrefs = peer->lp_refcount;\r\nint lastalive = -1;\r\nchar *aliveness = "NA";\r\nint maxcr = peer->lp_ni->ni_peertxcredits;\r\nint txcr = peer->lp_txcredits;\r\nint mintxcr = peer->lp_mintxcredits;\r\nint rtrcr = peer->lp_rtrcredits;\r\nint minrtrcr = peer->lp_minrtrcredits;\r\nint txqnob = peer->lp_txqnob;\r\nif (lnet_isrouter(peer) ||\r\nlnet_peer_aliveness_enabled(peer))\r\naliveness = peer->lp_alive ? "up" : "down";\r\nif (lnet_peer_aliveness_enabled(peer)) {\r\nunsigned long now = cfs_time_current();\r\nlong delta;\r\ndelta = cfs_time_sub(now, peer->lp_last_alive);\r\nlastalive = cfs_duration_sec(delta);\r\nif (lastalive >= 10000)\r\nlastalive = 9999;\r\n}\r\nlnet_net_unlock(cpt);\r\ns += snprintf(s, tmpstr + tmpsiz - s,\r\n"%-24s %4d %5s %5d %5d %5d %5d %5d %5d %d\n",\r\nlibcfs_nid2str(nid), nrefs, aliveness,\r\nlastalive, maxcr, rtrcr, minrtrcr, txcr,\r\nmintxcr, txqnob);\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\n} else {\r\nlnet_net_unlock(cpt);\r\n}\r\nif (hash == LNET_PEER_HASH_SIZE) {\r\ncpt++;\r\nhash = 0;\r\nhoff = 1;\r\nif (!peer && cpt < LNET_CPT_NUMBER)\r\ngoto again;\r\n}\r\n}\r\nlen = s - tmpstr;\r\nif (len > *lenp) {\r\nrc = -EINVAL;\r\n} else if (len > 0) {\r\nif (copy_to_user(buffer, tmpstr, len))\r\nrc = -EFAULT;\r\nelse\r\n*ppos = LNET_PROC_POS_MAKE(cpt, ver, hash, hoff);\r\n}\r\nLIBCFS_FREE(tmpstr, tmpsiz);\r\nif (!rc)\r\n*lenp = len;\r\nreturn rc;\r\n}\r\nstatic int __proc_lnet_buffers(void *data, int write,\r\nloff_t pos, void __user *buffer, int nob)\r\n{\r\nchar *s;\r\nchar *tmpstr;\r\nint tmpsiz;\r\nint idx;\r\nint len;\r\nint rc;\r\nint i;\r\nLASSERT(!write);\r\ntmpsiz = 64 * (LNET_NRBPOOLS + 1) * LNET_CPT_NUMBER;\r\nLIBCFS_ALLOC(tmpstr, tmpsiz);\r\nif (!tmpstr)\r\nreturn -ENOMEM;\r\ns = tmpstr;\r\ns += snprintf(s, tmpstr + tmpsiz - s,\r\n"%5s %5s %7s %7s\n",\r\n"pages", "count", "credits", "min");\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\nif (!the_lnet.ln_rtrpools)\r\ngoto out;\r\nfor (idx = 0; idx < LNET_NRBPOOLS; idx++) {\r\nlnet_rtrbufpool_t *rbp;\r\nlnet_net_lock(LNET_LOCK_EX);\r\ncfs_percpt_for_each(rbp, i, the_lnet.ln_rtrpools) {\r\ns += snprintf(s, tmpstr + tmpsiz - s,\r\n"%5d %5d %7d %7d\n",\r\nrbp[idx].rbp_npages,\r\nrbp[idx].rbp_nbuffers,\r\nrbp[idx].rbp_credits,\r\nrbp[idx].rbp_mincredits);\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\n}\r\nlnet_net_unlock(LNET_LOCK_EX);\r\n}\r\nout:\r\nlen = s - tmpstr;\r\nif (pos >= min_t(int, len, strlen(tmpstr)))\r\nrc = 0;\r\nelse\r\nrc = cfs_trace_copyout_string(buffer, nob,\r\ntmpstr + pos, NULL);\r\nLIBCFS_FREE(tmpstr, tmpsiz);\r\nreturn rc;\r\n}\r\nstatic int proc_lnet_buffers(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nreturn lprocfs_call_handler(table->data, write, ppos, buffer, lenp,\r\n__proc_lnet_buffers);\r\n}\r\nstatic int proc_lnet_nis(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint tmpsiz = 128 * LNET_CPT_NUMBER;\r\nint rc = 0;\r\nchar *tmpstr;\r\nchar *s;\r\nint len;\r\nLASSERT(!write);\r\nif (!*lenp)\r\nreturn 0;\r\nLIBCFS_ALLOC(tmpstr, tmpsiz);\r\nif (!tmpstr)\r\nreturn -ENOMEM;\r\ns = tmpstr;\r\nif (!*ppos) {\r\ns += snprintf(s, tmpstr + tmpsiz - s,\r\n"%-24s %6s %5s %4s %4s %4s %5s %5s %5s\n",\r\n"nid", "status", "alive", "refs", "peer",\r\n"rtr", "max", "tx", "min");\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\n} else {\r\nstruct list_head *n;\r\nlnet_ni_t *ni = NULL;\r\nint skip = *ppos - 1;\r\nlnet_net_lock(0);\r\nn = the_lnet.ln_nis.next;\r\nwhile (n != &the_lnet.ln_nis) {\r\nlnet_ni_t *a_ni = list_entry(n, lnet_ni_t, ni_list);\r\nif (!skip) {\r\nni = a_ni;\r\nbreak;\r\n}\r\nskip--;\r\nn = n->next;\r\n}\r\nif (ni) {\r\nstruct lnet_tx_queue *tq;\r\nchar *stat;\r\ntime64_t now = ktime_get_real_seconds();\r\nint last_alive = -1;\r\nint i;\r\nint j;\r\nif (the_lnet.ln_routing)\r\nlast_alive = now - ni->ni_last_alive;\r\nif (ni->ni_lnd->lnd_type == LOLND)\r\nlast_alive = 0;\r\nlnet_ni_lock(ni);\r\nLASSERT(ni->ni_status);\r\nstat = (ni->ni_status->ns_status ==\r\nLNET_NI_STATUS_UP) ? "up" : "down";\r\nlnet_ni_unlock(ni);\r\ncfs_percpt_for_each(tq, i, ni->ni_tx_queues) {\r\nfor (j = 0; ni->ni_cpts &&\r\nj < ni->ni_ncpts; j++) {\r\nif (i == ni->ni_cpts[j])\r\nbreak;\r\n}\r\nif (j == ni->ni_ncpts)\r\ncontinue;\r\nif (i)\r\nlnet_net_lock(i);\r\ns += snprintf(s, tmpstr + tmpsiz - s,\r\n"%-24s %6s %5d %4d %4d %4d %5d %5d %5d\n",\r\nlibcfs_nid2str(ni->ni_nid), stat,\r\nlast_alive, *ni->ni_refs[i],\r\nni->ni_peertxcredits,\r\nni->ni_peerrtrcredits,\r\ntq->tq_credits_max,\r\ntq->tq_credits,\r\ntq->tq_credits_min);\r\nif (i)\r\nlnet_net_unlock(i);\r\n}\r\nLASSERT(tmpstr + tmpsiz - s > 0);\r\n}\r\nlnet_net_unlock(0);\r\n}\r\nlen = s - tmpstr;\r\nif (len > *lenp) {\r\nrc = -EINVAL;\r\n} else if (len > 0) {\r\nif (copy_to_user(buffer, tmpstr, len))\r\nrc = -EFAULT;\r\nelse\r\n*ppos += 1;\r\n}\r\nLIBCFS_FREE(tmpstr, tmpsiz);\r\nif (!rc)\r\n*lenp = len;\r\nreturn rc;\r\n}\r\nstatic int __proc_lnet_portal_rotor(void *data, int write,\r\nloff_t pos, void __user *buffer, int nob)\r\n{\r\nconst int buf_len = 128;\r\nchar *buf;\r\nchar *tmp;\r\nint rc;\r\nint i;\r\nLIBCFS_ALLOC(buf, buf_len);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (!write) {\r\nlnet_res_lock(0);\r\nfor (i = 0; portal_rotors[i].pr_value >= 0; i++) {\r\nif (portal_rotors[i].pr_value == portal_rotor)\r\nbreak;\r\n}\r\nLASSERT(portal_rotors[i].pr_value == portal_rotor);\r\nlnet_res_unlock(0);\r\nrc = snprintf(buf, buf_len,\r\n"{\n\tportals: all\n"\r\n"\trotor: %s\n\tdescription: %s\n}",\r\nportal_rotors[i].pr_name,\r\nportal_rotors[i].pr_desc);\r\nif (pos >= min_t(int, rc, buf_len)) {\r\nrc = 0;\r\n} else {\r\nrc = cfs_trace_copyout_string(buffer, nob,\r\nbuf + pos, "\n");\r\n}\r\ngoto out;\r\n}\r\nrc = cfs_trace_copyin_string(buf, buf_len, buffer, nob);\r\nif (rc < 0)\r\ngoto out;\r\ntmp = cfs_trimwhite(buf);\r\nrc = -EINVAL;\r\nlnet_res_lock(0);\r\nfor (i = 0; portal_rotors[i].pr_name; i++) {\r\nif (!strncasecmp(portal_rotors[i].pr_name, tmp,\r\nstrlen(portal_rotors[i].pr_name))) {\r\nportal_rotor = portal_rotors[i].pr_value;\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nlnet_res_unlock(0);\r\nout:\r\nLIBCFS_FREE(buf, buf_len);\r\nreturn rc;\r\n}\r\nstatic int proc_lnet_portal_rotor(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp,\r\nloff_t *ppos)\r\n{\r\nreturn lprocfs_call_handler(table->data, write, ppos, buffer, lenp,\r\n__proc_lnet_portal_rotor);\r\n}\r\nvoid lnet_router_debugfs_init(void)\r\n{\r\nlustre_insert_debugfs(lnet_table, NULL);\r\n}\r\nvoid lnet_router_debugfs_fini(void)\r\n{\r\n}
