static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,\r\nconst u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->config.i2c_addr,\r\n.flags = 0,\r\n.len = 3 + len,\r\n.buf = buf,\r\n}\r\n};\r\nif (3 + len > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = (reg >> 8) & 0xff;\r\nbuf[1] = (reg >> 0) & 0xff;\r\nbuf[2] = mbox;\r\nmemcpy(&buf[3], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%04x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9013_rd_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,\r\nu8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[3];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->config.i2c_addr,\r\n.flags = 0,\r\n.len = 3,\r\n.buf = buf,\r\n}, {\r\n.addr = priv->config.i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val,\r\n}\r\n};\r\nbuf[0] = (reg >> 8) & 0xff;\r\nbuf[1] = (reg >> 0) & 0xff;\r\nbuf[2] = mbox;\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%04x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9013_wr_regs(struct af9013_state *priv, u16 reg, const u8 *val,\r\nint len)\r\n{\r\nint ret, i;\r\nu8 mbox = (0 << 7)|(0 << 6)|(1 << 1)|(1 << 0);\r\nif ((priv->config.ts_mode == AF9013_TS_USB) &&\r\n((reg & 0xff00) != 0xff00) && ((reg & 0xff00) != 0xae00)) {\r\nmbox |= ((len - 1) << 2);\r\nret = af9013_wr_regs_i2c(priv, mbox, reg, val, len);\r\n} else {\r\nfor (i = 0; i < len; i++) {\r\nret = af9013_wr_regs_i2c(priv, mbox, reg+i, val+i, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\n}\r\nerr:\r\nreturn 0;\r\n}\r\nstatic int af9013_rd_regs(struct af9013_state *priv, u16 reg, u8 *val, int len)\r\n{\r\nint ret, i;\r\nu8 mbox = (0 << 7)|(0 << 6)|(1 << 1)|(0 << 0);\r\nif ((priv->config.ts_mode == AF9013_TS_USB) &&\r\n((reg & 0xff00) != 0xff00) && ((reg & 0xff00) != 0xae00)) {\r\nmbox |= ((len - 1) << 2);\r\nret = af9013_rd_regs_i2c(priv, mbox, reg, val, len);\r\n} else {\r\nfor (i = 0; i < len; i++) {\r\nret = af9013_rd_regs_i2c(priv, mbox, reg+i, val+i, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\n}\r\nerr:\r\nreturn 0;\r\n}\r\nstatic int af9013_wr_reg(struct af9013_state *priv, u16 reg, u8 val)\r\n{\r\nreturn af9013_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int af9013_rd_reg(struct af9013_state *priv, u16 reg, u8 *val)\r\n{\r\nreturn af9013_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int af9013_write_ofsm_regs(struct af9013_state *state, u16 reg, u8 *val,\r\nu8 len)\r\n{\r\nu8 mbox = (1 << 7)|(1 << 6)|((len - 1) << 2)|(1 << 1)|(1 << 0);\r\nreturn af9013_wr_regs_i2c(state, mbox, reg, val, len);\r\n}\r\nstatic int af9013_wr_reg_bits(struct af9013_state *state, u16 reg, int pos,\r\nint len, u8 val)\r\n{\r\nint ret;\r\nu8 tmp, mask;\r\nif (len != 8) {\r\nret = af9013_rd_reg(state, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\nmask = (0xff >> (8 - len)) << pos;\r\nval <<= pos;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn af9013_wr_reg(state, reg, val);\r\n}\r\nstatic int af9013_rd_reg_bits(struct af9013_state *state, u16 reg, int pos,\r\nint len, u8 *val)\r\n{\r\nint ret;\r\nu8 tmp;\r\nret = af9013_rd_reg(state, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\n*val = (tmp >> pos);\r\n*val &= (0xff >> (8 - len));\r\nreturn 0;\r\n}\r\nstatic int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)\r\n{\r\nint ret;\r\nu8 pos;\r\nu16 addr;\r\ndev_dbg(&state->i2c->dev, "%s: gpio=%d gpioval=%02x\n",\r\n__func__, gpio, gpioval);\r\nswitch (gpio) {\r\ncase 0:\r\ncase 1:\r\naddr = 0xd735;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\naddr = 0xd736;\r\nbreak;\r\ndefault:\r\ndev_err(&state->i2c->dev, "%s: invalid gpio=%d\n",\r\nKBUILD_MODNAME, gpio);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nswitch (gpio) {\r\ncase 0:\r\ncase 2:\r\npos = 0;\r\nbreak;\r\ncase 1:\r\ncase 3:\r\ndefault:\r\npos = 4;\r\nbreak;\r\n}\r\nret = af9013_wr_reg_bits(state, addr, pos, 4, gpioval);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic u32 af9013_div(struct af9013_state *state, u32 a, u32 b, u32 x)\r\n{\r\nu32 r = 0, c = 0, i;\r\ndev_dbg(&state->i2c->dev, "%s: a=%d b=%d x=%d\n", __func__, a, b, x);\r\nif (a > b) {\r\nc = a / b;\r\na = a - c * b;\r\n}\r\nfor (i = 0; i < x; i++) {\r\nif (a >= b) {\r\nr += 1;\r\na -= b;\r\n}\r\na <<= 1;\r\nr <<= 1;\r\n}\r\nr = (c << (u32)x) + r;\r\ndev_dbg(&state->i2c->dev, "%s: a=%d b=%d x=%d r=%d r=%x\n",\r\n__func__, a, b, x, r, r);\r\nreturn r;\r\n}\r\nstatic int af9013_power_ctrl(struct af9013_state *state, u8 onoff)\r\n{\r\nint ret, i;\r\nu8 tmp;\r\ndev_dbg(&state->i2c->dev, "%s: onoff=%d\n", __func__, onoff);\r\nret = af9013_wr_reg_bits(state, 0xd417, 4, 1, 1);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg(state, 0xaeff, 1);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < 150; i++) {\r\nret = af9013_rd_reg_bits(state, 0xd417, 1, 1, &tmp);\r\nif (ret)\r\ngoto err;\r\nif (tmp)\r\nbreak;\r\nusleep_range(5000, 25000);\r\n}\r\nif (!tmp)\r\nreturn -ETIMEDOUT;\r\nif (onoff) {\r\nret = af9013_wr_reg_bits(state, 0xd417, 1, 1, 0);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0xd417, 4, 1, 0);\r\nret = af9013_wr_reg_bits(state, 0xd73a, 3, 1, 0);\r\n} else {\r\nret = af9013_wr_reg_bits(state, 0xd73a, 3, 1, 1);\r\n}\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&state->i2c->dev, "%s:\n", __func__);\r\nret = af9013_wr_reg_bits(state, 0xd391, 4, 1, 1);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[5];\r\ndev_dbg(&state->i2c->dev, "%s:\n", __func__);\r\nret = af9013_rd_reg_bits(state, 0xd391, 4, 1, &buf[0]);\r\nif (ret)\r\ngoto err;\r\nif (!buf[0]) {\r\ndev_dbg(&state->i2c->dev, "%s: not ready\n", __func__);\r\nreturn 0;\r\n}\r\nret = af9013_rd_regs(state, 0xd387, buf, 5);\r\nif (ret)\r\ngoto err;\r\nstate->ber = (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nstate->ucblocks += (buf[4] << 8) | buf[3];\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_statistics_snr_start(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&state->i2c->dev, "%s:\n", __func__);\r\nret = af9013_wr_reg_bits(state, 0xd2e1, 3, 1, 1);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_statistics_snr_result(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret, i, len;\r\nu8 buf[3], tmp;\r\nu32 snr_val;\r\nconst struct af9013_snr *uninitialized_var(snr_lut);\r\ndev_dbg(&state->i2c->dev, "%s:\n", __func__);\r\nret = af9013_rd_reg_bits(state, 0xd2e1, 3, 1, &tmp);\r\nif (ret)\r\ngoto err;\r\nif (!tmp) {\r\ndev_dbg(&state->i2c->dev, "%s: not ready\n", __func__);\r\nreturn 0;\r\n}\r\nret = af9013_rd_regs(state, 0xd2e3, buf, 3);\r\nif (ret)\r\ngoto err;\r\nsnr_val = (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nret = af9013_rd_reg(state, 0xd3c1, &tmp);\r\nif (ret)\r\ngoto err;\r\nswitch ((tmp >> 6) & 3) {\r\ncase 0:\r\nlen = ARRAY_SIZE(qpsk_snr_lut);\r\nsnr_lut = qpsk_snr_lut;\r\nbreak;\r\ncase 1:\r\nlen = ARRAY_SIZE(qam16_snr_lut);\r\nsnr_lut = qam16_snr_lut;\r\nbreak;\r\ncase 2:\r\nlen = ARRAY_SIZE(qam64_snr_lut);\r\nsnr_lut = qam64_snr_lut;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nfor (i = 0; i < len; i++) {\r\ntmp = snr_lut[i].snr;\r\nif (snr_val < snr_lut[i].val)\r\nbreak;\r\n}\r\nstate->snr = tmp * 10;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_statistics_signal_strength(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret = 0;\r\nu8 buf[2], rf_gain, if_gain;\r\nint signal_strength;\r\ndev_dbg(&state->i2c->dev, "%s:\n", __func__);\r\nif (!state->signal_strength_en)\r\nreturn 0;\r\nret = af9013_rd_regs(state, 0xd07c, buf, 2);\r\nif (ret)\r\ngoto err;\r\nrf_gain = buf[0];\r\nif_gain = buf[1];\r\nsignal_strength = (0xffff / \\r\n(9 * (state->rf_50 + state->if_50) - \\r\n11 * (state->rf_80 + state->if_80))) * \\r\n(10 * (rf_gain + if_gain) - \\r\n11 * (state->rf_80 + state->if_80));\r\nif (signal_strength < 0)\r\nsignal_strength = 0;\r\nelse if (signal_strength > 0xffff)\r\nsignal_strength = 0xffff;\r\nstate->signal_strength = signal_strength;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void af9013_statistics_work(struct work_struct *work)\r\n{\r\nstruct af9013_state *state = container_of(work,\r\nstruct af9013_state, statistics_work.work);\r\nunsigned int next_msec;\r\nif (!(state->fe_status & FE_HAS_LOCK)) {\r\nstate->statistics_step = 0;\r\nstate->ber = 0;\r\nstate->snr = 0;\r\n}\r\nswitch (state->statistics_step) {\r\ndefault:\r\nstate->statistics_step = 0;\r\ncase 0:\r\naf9013_statistics_signal_strength(&state->fe);\r\nstate->statistics_step++;\r\nnext_msec = 300;\r\nbreak;\r\ncase 1:\r\naf9013_statistics_snr_start(&state->fe);\r\nstate->statistics_step++;\r\nnext_msec = 200;\r\nbreak;\r\ncase 2:\r\naf9013_statistics_ber_unc_start(&state->fe);\r\nstate->statistics_step++;\r\nnext_msec = 1000;\r\nbreak;\r\ncase 3:\r\naf9013_statistics_snr_result(&state->fe);\r\nstate->statistics_step++;\r\nnext_msec = 400;\r\nbreak;\r\ncase 4:\r\naf9013_statistics_ber_unc_result(&state->fe);\r\nstate->statistics_step++;\r\nnext_msec = 100;\r\nbreak;\r\n}\r\nschedule_delayed_work(&state->statistics_work,\r\nmsecs_to_jiffies(next_msec));\r\n}\r\nstatic int af9013_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 800;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int af9013_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, sampling_freq;\r\nbool auto_mode, spec_inv;\r\nu8 buf[6];\r\nu32 if_frequency, freq_cw;\r\ndev_dbg(&state->i2c->dev, "%s: frequency=%d bandwidth_hz=%d\n",\r\n__func__, c->frequency, c->bandwidth_hz);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (c->bandwidth_hz != state->bandwidth_hz) {\r\nfor (i = 0; i < ARRAY_SIZE(coeff_lut); i++) {\r\nif (coeff_lut[i].clock == state->config.clock &&\r\ncoeff_lut[i].bandwidth_hz == c->bandwidth_hz) {\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(coeff_lut))\r\nreturn -EINVAL;\r\nret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,\r\nsizeof(coeff_lut[i].val));\r\n}\r\nif (c->bandwidth_hz != state->bandwidth_hz || state->first_tune) {\r\nif (fe->ops.tuner_ops.get_if_frequency)\r\nfe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\r\nelse\r\nif_frequency = state->config.if_frequency;\r\ndev_dbg(&state->i2c->dev, "%s: if_frequency=%d\n",\r\n__func__, if_frequency);\r\nsampling_freq = if_frequency;\r\nwhile (sampling_freq > (state->config.clock / 2))\r\nsampling_freq -= state->config.clock;\r\nif (sampling_freq < 0) {\r\nsampling_freq *= -1;\r\nspec_inv = state->config.spec_inv;\r\n} else {\r\nspec_inv = !state->config.spec_inv;\r\n}\r\nfreq_cw = af9013_div(state, sampling_freq, state->config.clock,\r\n23);\r\nif (spec_inv)\r\nfreq_cw = 0x800000 - freq_cw;\r\nbuf[0] = (freq_cw >> 0) & 0xff;\r\nbuf[1] = (freq_cw >> 8) & 0xff;\r\nbuf[2] = (freq_cw >> 16) & 0x7f;\r\nfreq_cw = 0x800000 - freq_cw;\r\nbuf[3] = (freq_cw >> 0) & 0xff;\r\nbuf[4] = (freq_cw >> 8) & 0xff;\r\nbuf[5] = (freq_cw >> 16) & 0x7f;\r\nret = af9013_wr_regs(state, 0xd140, buf, 3);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_regs(state, 0x9be7, buf, 6);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = af9013_wr_reg_bits(state, 0xd330, 3, 1, 1);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0xd507, 6, 1, 0);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0x9bfe, 0, 1, 0);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0x9bc2, 0, 1, 0);\r\nif (ret)\r\ngoto err;\r\nauto_mode = false;\r\nmemset(buf, 0, 3);\r\nswitch (c->transmission_mode) {\r\ncase TRANSMISSION_MODE_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase TRANSMISSION_MODE_2K:\r\nbreak;\r\ncase TRANSMISSION_MODE_8K:\r\nbuf[0] |= (1 << 0);\r\nbreak;\r\ndefault:\r\ndev_dbg(&state->i2c->dev, "%s: invalid transmission_mode\n",\r\n__func__);\r\nauto_mode = true;\r\n}\r\nswitch (c->guard_interval) {\r\ncase GUARD_INTERVAL_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase GUARD_INTERVAL_1_32:\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\nbuf[0] |= (1 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\nbuf[0] |= (2 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\nbuf[0] |= (3 << 2);\r\nbreak;\r\ndefault:\r\ndev_dbg(&state->i2c->dev, "%s: invalid guard_interval\n",\r\n__func__);\r\nauto_mode = true;\r\n}\r\nswitch (c->hierarchy) {\r\ncase HIERARCHY_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase HIERARCHY_NONE:\r\nbreak;\r\ncase HIERARCHY_1:\r\nbuf[0] |= (1 << 4);\r\nbreak;\r\ncase HIERARCHY_2:\r\nbuf[0] |= (2 << 4);\r\nbreak;\r\ncase HIERARCHY_4:\r\nbuf[0] |= (3 << 4);\r\nbreak;\r\ndefault:\r\ndev_dbg(&state->i2c->dev, "%s: invalid hierarchy\n", __func__);\r\nauto_mode = true;\r\n}\r\nswitch (c->modulation) {\r\ncase QAM_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase QPSK:\r\nbreak;\r\ncase QAM_16:\r\nbuf[1] |= (1 << 6);\r\nbreak;\r\ncase QAM_64:\r\nbuf[1] |= (2 << 6);\r\nbreak;\r\ndefault:\r\ndev_dbg(&state->i2c->dev, "%s: invalid modulation\n", __func__);\r\nauto_mode = true;\r\n}\r\nbuf[1] |= (1 << 4);\r\nswitch (c->code_rate_HP) {\r\ncase FEC_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase FEC_1_2:\r\nbreak;\r\ncase FEC_2_3:\r\nbuf[2] |= (1 << 0);\r\nbreak;\r\ncase FEC_3_4:\r\nbuf[2] |= (2 << 0);\r\nbreak;\r\ncase FEC_5_6:\r\nbuf[2] |= (3 << 0);\r\nbreak;\r\ncase FEC_7_8:\r\nbuf[2] |= (4 << 0);\r\nbreak;\r\ndefault:\r\ndev_dbg(&state->i2c->dev, "%s: invalid code_rate_HP\n",\r\n__func__);\r\nauto_mode = true;\r\n}\r\nswitch (c->code_rate_LP) {\r\ncase FEC_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase FEC_1_2:\r\nbreak;\r\ncase FEC_2_3:\r\nbuf[2] |= (1 << 3);\r\nbreak;\r\ncase FEC_3_4:\r\nbuf[2] |= (2 << 3);\r\nbreak;\r\ncase FEC_5_6:\r\nbuf[2] |= (3 << 3);\r\nbreak;\r\ncase FEC_7_8:\r\nbuf[2] |= (4 << 3);\r\nbreak;\r\ncase FEC_NONE:\r\nbreak;\r\ndefault:\r\ndev_dbg(&state->i2c->dev, "%s: invalid code_rate_LP\n",\r\n__func__);\r\nauto_mode = true;\r\n}\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nbreak;\r\ncase 7000000:\r\nbuf[1] |= (1 << 2);\r\nbreak;\r\ncase 8000000:\r\nbuf[1] |= (2 << 2);\r\nbreak;\r\ndefault:\r\ndev_dbg(&state->i2c->dev, "%s: invalid bandwidth_hz\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = af9013_wr_regs(state, 0xd3c0, buf, 3);\r\nif (ret)\r\ngoto err;\r\nif (auto_mode) {\r\nret = af9013_wr_reg(state, 0xaefd, 0);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&state->i2c->dev, "%s: auto params\n", __func__);\r\n} else {\r\nret = af9013_wr_reg(state, 0xaefd, 1);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg(state, 0xaefe, 0);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&state->i2c->dev, "%s: manual params\n", __func__);\r\n}\r\nret = af9013_wr_reg(state, 0xffff, 0);\r\nif (ret)\r\ngoto err;\r\nstate->bandwidth_hz = c->bandwidth_hz;\r\nstate->set_frontend_jiffies = jiffies;\r\nstate->first_tune = false;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[3];\r\ndev_dbg(&state->i2c->dev, "%s:\n", __func__);\r\nret = af9013_rd_regs(state, 0xd3c0, buf, 3);\r\nif (ret)\r\ngoto err;\r\nswitch ((buf[1] >> 6) & 3) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 0) & 3) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\n}\r\nswitch ((buf[0] >> 2) & 3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 4) & 7) {\r\ncase 0:\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 3) & 7) {\r\ncase 0:\r\nc->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 2) & 3) {\r\ncase 0:\r\nc->bandwidth_hz = 6000000;\r\nbreak;\r\ncase 1:\r\nc->bandwidth_hz = 7000000;\r\nbreak;\r\ncase 2:\r\nc->bandwidth_hz = 8000000;\r\nbreak;\r\n}\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 tmp;\r\nif (time_is_after_jiffies(\r\nstate->read_status_jiffies + msecs_to_jiffies(2000)) &&\r\ntime_is_before_jiffies(\r\nstate->set_frontend_jiffies + msecs_to_jiffies(4000))\r\n) {\r\n*status = state->fe_status;\r\nreturn 0;\r\n} else {\r\n*status = 0;\r\n}\r\nret = af9013_rd_reg_bits(state, 0xd507, 6, 1, &tmp);\r\nif (ret)\r\ngoto err;\r\nif (tmp)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\r\nFE_HAS_SYNC | FE_HAS_LOCK;\r\nif (!*status) {\r\nret = af9013_rd_reg_bits(state, 0xd330, 3, 1, &tmp);\r\nif (ret)\r\ngoto err;\r\nif (tmp)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI;\r\n}\r\nstate->fe_status = *status;\r\nstate->read_status_jiffies = jiffies;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\n*snr = state->snr;\r\nreturn 0;\r\n}\r\nstatic int af9013_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\n*strength = state->signal_strength;\r\nreturn 0;\r\n}\r\nstatic int af9013_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\n*ber = state->ber;\r\nreturn 0;\r\n}\r\nstatic int af9013_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\n*ucblocks = state->ucblocks;\r\nreturn 0;\r\n}\r\nstatic int af9013_init(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret, i, len;\r\nu8 buf[3], tmp;\r\nu32 adc_cw;\r\nconst struct af9013_reg_bit *init;\r\ndev_dbg(&state->i2c->dev, "%s:\n", __func__);\r\nret = af9013_power_ctrl(state, 1);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg(state, 0xd73a, 0xa4);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_regs(state, 0x9bf2, state->config.api_version, 4);\r\nif (ret)\r\ngoto err;\r\nswitch (state->config.clock) {\r\ncase 28800000:\r\ntmp = 0;\r\nbreak;\r\ncase 20480000:\r\ntmp = 1;\r\nbreak;\r\ncase 28000000:\r\ntmp = 2;\r\nbreak;\r\ncase 25000000:\r\ntmp = 3;\r\nbreak;\r\ndefault:\r\ndev_err(&state->i2c->dev, "%s: invalid clock\n",\r\nKBUILD_MODNAME);\r\nreturn -EINVAL;\r\n}\r\nadc_cw = af9013_div(state, state->config.clock, 1000000ul, 19);\r\nbuf[0] = (adc_cw >> 0) & 0xff;\r\nbuf[1] = (adc_cw >> 8) & 0xff;\r\nbuf[2] = (adc_cw >> 16) & 0xff;\r\nret = af9013_wr_regs(state, 0xd180, buf, 3);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0x9bd2, 0, 4, tmp);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg(state, 0xd416, 0x14);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0xd700, 1, 1, 1);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0xd700, 2, 1, 0);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0xd371, 1, 1, 1);\r\nif (ret)\r\ngoto err;\r\nif (state->config.ts_mode == AF9013_TS_USB) {\r\nret = af9013_wr_reg_bits(state, 0xd50b, 2, 1, 1);\r\nif (ret)\r\ngoto err;\r\n} else {\r\nret = af9013_wr_reg_bits(state, 0xd500, 3, 1, 1);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0xd502, 4, 1, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = af9013_wr_reg_bits(state, 0xd520, 4, 1, 1);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&state->i2c->dev, "%s: load ofsm settings\n", __func__);\r\nlen = ARRAY_SIZE(ofsm_init);\r\ninit = ofsm_init;\r\nfor (i = 0; i < len; i++) {\r\nret = af9013_wr_reg_bits(state, init[i].addr, init[i].pos,\r\ninit[i].len, init[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev_dbg(&state->i2c->dev, "%s: load tuner specific settings\n",\r\n__func__);\r\nswitch (state->config.tuner) {\r\ncase AF9013_TUNER_MXL5003D:\r\nlen = ARRAY_SIZE(tuner_init_mxl5003d);\r\ninit = tuner_init_mxl5003d;\r\nbreak;\r\ncase AF9013_TUNER_MXL5005D:\r\ncase AF9013_TUNER_MXL5005R:\r\ncase AF9013_TUNER_MXL5007T:\r\nlen = ARRAY_SIZE(tuner_init_mxl5005);\r\ninit = tuner_init_mxl5005;\r\nbreak;\r\ncase AF9013_TUNER_ENV77H11D5:\r\nlen = ARRAY_SIZE(tuner_init_env77h11d5);\r\ninit = tuner_init_env77h11d5;\r\nbreak;\r\ncase AF9013_TUNER_MT2060:\r\nlen = ARRAY_SIZE(tuner_init_mt2060);\r\ninit = tuner_init_mt2060;\r\nbreak;\r\ncase AF9013_TUNER_MC44S803:\r\nlen = ARRAY_SIZE(tuner_init_mc44s803);\r\ninit = tuner_init_mc44s803;\r\nbreak;\r\ncase AF9013_TUNER_QT1010:\r\ncase AF9013_TUNER_QT1010A:\r\nlen = ARRAY_SIZE(tuner_init_qt1010);\r\ninit = tuner_init_qt1010;\r\nbreak;\r\ncase AF9013_TUNER_MT2060_2:\r\nlen = ARRAY_SIZE(tuner_init_mt2060_2);\r\ninit = tuner_init_mt2060_2;\r\nbreak;\r\ncase AF9013_TUNER_TDA18271:\r\ncase AF9013_TUNER_TDA18218:\r\nlen = ARRAY_SIZE(tuner_init_tda18271);\r\ninit = tuner_init_tda18271;\r\nbreak;\r\ncase AF9013_TUNER_UNKNOWN:\r\ndefault:\r\nlen = ARRAY_SIZE(tuner_init_unknown);\r\ninit = tuner_init_unknown;\r\nbreak;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nret = af9013_wr_reg_bits(state, init[i].addr, init[i].pos,\r\ninit[i].len, init[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = af9013_wr_reg_bits(state, 0xd500, 1, 2, state->config.ts_mode);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0xd730, 0, 1, 1);\r\nif (ret)\r\ngoto err;\r\nif (!state->signal_strength_en) {\r\nret = af9013_rd_reg_bits(state, 0x9bee, 0, 1,\r\n&state->signal_strength_en);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (state->signal_strength_en && !state->rf_50) {\r\nret = af9013_rd_reg(state, 0x9bbd, &state->rf_50);\r\nif (ret)\r\ngoto err;\r\nret = af9013_rd_reg(state, 0x9bd0, &state->rf_80);\r\nif (ret)\r\ngoto err;\r\nret = af9013_rd_reg(state, 0x9be2, &state->if_50);\r\nif (ret)\r\ngoto err;\r\nret = af9013_rd_reg(state, 0x9be4, &state->if_80);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = af9013_wr_reg(state, 0xd2e2, 1);\r\nif (ret)\r\ngoto err;\r\nbuf[0] = (10000 >> 0) & 0xff;\r\nbuf[1] = (10000 >> 8) & 0xff;\r\nret = af9013_wr_regs(state, 0xd385, buf, 2);\r\nif (ret)\r\ngoto err;\r\nret = af9013_wr_reg_bits(state, 0xd392, 1, 1, 1);\r\nif (ret)\r\ngoto err;\r\nstate->first_tune = true;\r\nschedule_delayed_work(&state->statistics_work, msecs_to_jiffies(400));\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&state->i2c->dev, "%s:\n", __func__);\r\ncancel_delayed_work_sync(&state->statistics_work);\r\nret = af9013_wr_reg_bits(state, 0xd730, 0, 1, 0);\r\nif (ret)\r\ngoto err;\r\nret = af9013_power_ctrl(state, 0);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nint ret;\r\nstruct af9013_state *state = fe->demodulator_priv;\r\ndev_dbg(&state->i2c->dev, "%s: enable=%d\n", __func__, enable);\r\nif (state->i2c_gate_state == enable)\r\nreturn 0;\r\nif (state->config.ts_mode == AF9013_TS_USB)\r\nret = af9013_wr_reg_bits(state, 0xd417, 3, 1, enable);\r\nelse\r\nret = af9013_wr_reg_bits(state, 0xd607, 2, 1, enable);\r\nif (ret)\r\ngoto err;\r\nstate->i2c_gate_state = enable;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void af9013_release(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\ncancel_delayed_work_sync(&state->statistics_work);\r\nkfree(state);\r\n}\r\nstatic int af9013_download_firmware(struct af9013_state *state)\r\n{\r\nint i, len, remaining, ret;\r\nconst struct firmware *fw;\r\nu16 checksum = 0;\r\nu8 val;\r\nu8 fw_params[4];\r\nu8 *fw_file = AF9013_FIRMWARE;\r\nmsleep(100);\r\nret = af9013_rd_reg(state, 0x98be, &val);\r\nif (ret)\r\ngoto err;\r\nelse\r\ndev_dbg(&state->i2c->dev, "%s: firmware status=%02x\n",\r\n__func__, val);\r\nif (val == 0x0c)\r\ngoto exit;\r\ndev_info(&state->i2c->dev, "%s: found a '%s' in cold state, will try " \\r\n"to load a firmware\n",\r\nKBUILD_MODNAME, af9013_ops.info.name);\r\nret = request_firmware(&fw, fw_file, state->i2c->dev.parent);\r\nif (ret) {\r\ndev_info(&state->i2c->dev, "%s: did not find the firmware " \\r\n"file. (%s) Please see linux/Documentation/dvb/ for " \\r\n"more details on firmware-problems. (%d)\n",\r\nKBUILD_MODNAME, fw_file, ret);\r\ngoto err;\r\n}\r\ndev_info(&state->i2c->dev, "%s: downloading firmware from file '%s'\n",\r\nKBUILD_MODNAME, fw_file);\r\nfor (i = 0; i < fw->size; i++)\r\nchecksum += fw->data[i];\r\nfw_params[0] = checksum >> 8;\r\nfw_params[1] = checksum & 0xff;\r\nfw_params[2] = fw->size >> 8;\r\nfw_params[3] = fw->size & 0xff;\r\nret = af9013_write_ofsm_regs(state, 0x50fc,\r\nfw_params, sizeof(fw_params));\r\nif (ret)\r\ngoto err_release;\r\n#define FW_ADDR 0x5100\r\n#define LEN_MAX 16\r\nfor (remaining = fw->size; remaining > 0; remaining -= LEN_MAX) {\r\nlen = remaining;\r\nif (len > LEN_MAX)\r\nlen = LEN_MAX;\r\nret = af9013_write_ofsm_regs(state,\r\nFW_ADDR + fw->size - remaining,\r\n(u8 *) &fw->data[fw->size - remaining], len);\r\nif (ret) {\r\ndev_err(&state->i2c->dev,\r\n"%s: firmware download failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ngoto err_release;\r\n}\r\n}\r\nret = af9013_wr_reg(state, 0xe205, 1);\r\nif (ret)\r\ngoto err_release;\r\nfor (i = 0; i < 15; i++) {\r\nmsleep(100);\r\nret = af9013_rd_reg(state, 0x98be, &val);\r\nif (ret)\r\ngoto err_release;\r\ndev_dbg(&state->i2c->dev, "%s: firmware status=%02x\n",\r\n__func__, val);\r\nif (val == 0x0c || val == 0x04)\r\nbreak;\r\n}\r\nif (val == 0x04) {\r\ndev_err(&state->i2c->dev, "%s: firmware did not run\n",\r\nKBUILD_MODNAME);\r\nret = -ENODEV;\r\n} else if (val != 0x0c) {\r\ndev_err(&state->i2c->dev, "%s: firmware boot timeout\n",\r\nKBUILD_MODNAME);\r\nret = -ENODEV;\r\n}\r\nerr_release:\r\nrelease_firmware(fw);\r\nerr:\r\nexit:\r\nif (!ret)\r\ndev_info(&state->i2c->dev, "%s: found a '%s' in warm state\n",\r\nKBUILD_MODNAME, af9013_ops.info.name);\r\nreturn ret;\r\n}\r\nstruct dvb_frontend *af9013_attach(const struct af9013_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nint ret;\r\nstruct af9013_state *state = NULL;\r\nu8 buf[4], i;\r\nstate = kzalloc(sizeof(struct af9013_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto err;\r\nstate->i2c = i2c;\r\nmemcpy(&state->config, config, sizeof(struct af9013_config));\r\nif (state->config.ts_mode != AF9013_TS_USB) {\r\nret = af9013_download_firmware(state);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = af9013_rd_regs(state, 0x5103, buf, 4);\r\nif (ret)\r\ngoto err;\r\ndev_info(&state->i2c->dev, "%s: firmware version %d.%d.%d.%d\n",\r\nKBUILD_MODNAME, buf[0], buf[1], buf[2], buf[3]);\r\nfor (i = 0; i < sizeof(state->config.gpio); i++) {\r\nret = af9013_set_gpio(state, i, state->config.gpio[i]);\r\nif (ret)\r\ngoto err;\r\n}\r\nmemcpy(&state->fe.ops, &af9013_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->fe.demodulator_priv = state;\r\nINIT_DELAYED_WORK(&state->statistics_work, af9013_statistics_work);\r\nreturn &state->fe;\r\nerr:\r\nkfree(state);\r\nreturn NULL;\r\n}
