int nf_ct_seqadj_init(struct nf_conn *ct, enum ip_conntrack_info ctinfo,\r\ns32 off)\r\n{\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nstruct nf_conn_seqadj *seqadj;\r\nstruct nf_ct_seqadj *this_way;\r\nif (off == 0)\r\nreturn 0;\r\nset_bit(IPS_SEQ_ADJUST_BIT, &ct->status);\r\nseqadj = nfct_seqadj(ct);\r\nthis_way = &seqadj->seq[dir];\r\nthis_way->offset_before = off;\r\nthis_way->offset_after = off;\r\nreturn 0;\r\n}\r\nint nf_ct_seqadj_set(struct nf_conn *ct, enum ip_conntrack_info ctinfo,\r\n__be32 seq, s32 off)\r\n{\r\nstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nstruct nf_ct_seqadj *this_way;\r\nif (off == 0)\r\nreturn 0;\r\nif (unlikely(!seqadj)) {\r\nWARN_ONCE(1, "Missing nfct_seqadj_ext_add() setup call\n");\r\nreturn 0;\r\n}\r\nset_bit(IPS_SEQ_ADJUST_BIT, &ct->status);\r\nspin_lock_bh(&ct->lock);\r\nthis_way = &seqadj->seq[dir];\r\nif (this_way->offset_before == this_way->offset_after ||\r\nbefore(this_way->correction_pos, ntohl(seq))) {\r\nthis_way->correction_pos = ntohl(seq);\r\nthis_way->offset_before = this_way->offset_after;\r\nthis_way->offset_after += off;\r\n}\r\nspin_unlock_bh(&ct->lock);\r\nreturn 0;\r\n}\r\nvoid nf_ct_tcp_seqadj_set(struct sk_buff *skb,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo,\r\ns32 off)\r\n{\r\nconst struct tcphdr *th;\r\nif (nf_ct_protonum(ct) != IPPROTO_TCP)\r\nreturn;\r\nth = (struct tcphdr *)(skb_network_header(skb) + ip_hdrlen(skb));\r\nnf_ct_seqadj_set(ct, ctinfo, th->seq, off);\r\n}\r\nstatic void nf_ct_sack_block_adjust(struct sk_buff *skb,\r\nstruct tcphdr *tcph,\r\nunsigned int sackoff,\r\nunsigned int sackend,\r\nstruct nf_ct_seqadj *seq)\r\n{\r\nwhile (sackoff < sackend) {\r\nstruct tcp_sack_block_wire *sack;\r\n__be32 new_start_seq, new_end_seq;\r\nsack = (void *)skb->data + sackoff;\r\nif (after(ntohl(sack->start_seq) - seq->offset_before,\r\nseq->correction_pos))\r\nnew_start_seq = htonl(ntohl(sack->start_seq) -\r\nseq->offset_after);\r\nelse\r\nnew_start_seq = htonl(ntohl(sack->start_seq) -\r\nseq->offset_before);\r\nif (after(ntohl(sack->end_seq) - seq->offset_before,\r\nseq->correction_pos))\r\nnew_end_seq = htonl(ntohl(sack->end_seq) -\r\nseq->offset_after);\r\nelse\r\nnew_end_seq = htonl(ntohl(sack->end_seq) -\r\nseq->offset_before);\r\npr_debug("sack_adjust: start_seq: %u->%u, end_seq: %u->%u\n",\r\nntohl(sack->start_seq), ntohl(new_start_seq),\r\nntohl(sack->end_seq), ntohl(new_end_seq));\r\ninet_proto_csum_replace4(&tcph->check, skb,\r\nsack->start_seq, new_start_seq, false);\r\ninet_proto_csum_replace4(&tcph->check, skb,\r\nsack->end_seq, new_end_seq, false);\r\nsack->start_seq = new_start_seq;\r\nsack->end_seq = new_end_seq;\r\nsackoff += sizeof(*sack);\r\n}\r\n}\r\nstatic unsigned int nf_ct_sack_adjust(struct sk_buff *skb,\r\nunsigned int protoff,\r\nstruct tcphdr *tcph,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nunsigned int dir, optoff, optend;\r\nstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\r\noptoff = protoff + sizeof(struct tcphdr);\r\noptend = protoff + tcph->doff * 4;\r\nif (!skb_make_writable(skb, optend))\r\nreturn 0;\r\ndir = CTINFO2DIR(ctinfo);\r\nwhile (optoff < optend) {\r\nunsigned char *op = skb->data + optoff;\r\nswitch (op[0]) {\r\ncase TCPOPT_EOL:\r\nreturn 1;\r\ncase TCPOPT_NOP:\r\noptoff++;\r\ncontinue;\r\ndefault:\r\nif (optoff + 1 == optend ||\r\noptoff + op[1] > optend ||\r\nop[1] < 2)\r\nreturn 0;\r\nif (op[0] == TCPOPT_SACK &&\r\nop[1] >= 2+TCPOLEN_SACK_PERBLOCK &&\r\n((op[1] - 2) % TCPOLEN_SACK_PERBLOCK) == 0)\r\nnf_ct_sack_block_adjust(skb, tcph, optoff + 2,\r\noptoff+op[1],\r\n&seqadj->seq[!dir]);\r\noptoff += op[1];\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint nf_ct_seq_adjust(struct sk_buff *skb,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo,\r\nunsigned int protoff)\r\n{\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nstruct tcphdr *tcph;\r\n__be32 newseq, newack;\r\ns32 seqoff, ackoff;\r\nstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\r\nstruct nf_ct_seqadj *this_way, *other_way;\r\nint res;\r\nthis_way = &seqadj->seq[dir];\r\nother_way = &seqadj->seq[!dir];\r\nif (!skb_make_writable(skb, protoff + sizeof(*tcph)))\r\nreturn 0;\r\ntcph = (void *)skb->data + protoff;\r\nspin_lock_bh(&ct->lock);\r\nif (after(ntohl(tcph->seq), this_way->correction_pos))\r\nseqoff = this_way->offset_after;\r\nelse\r\nseqoff = this_way->offset_before;\r\nif (after(ntohl(tcph->ack_seq) - other_way->offset_before,\r\nother_way->correction_pos))\r\nackoff = other_way->offset_after;\r\nelse\r\nackoff = other_way->offset_before;\r\nnewseq = htonl(ntohl(tcph->seq) + seqoff);\r\nnewack = htonl(ntohl(tcph->ack_seq) - ackoff);\r\ninet_proto_csum_replace4(&tcph->check, skb, tcph->seq, newseq, false);\r\ninet_proto_csum_replace4(&tcph->check, skb, tcph->ack_seq, newack,\r\nfalse);\r\npr_debug("Adjusting sequence number from %u->%u, ack from %u->%u\n",\r\nntohl(tcph->seq), ntohl(newseq), ntohl(tcph->ack_seq),\r\nntohl(newack));\r\ntcph->seq = newseq;\r\ntcph->ack_seq = newack;\r\nres = nf_ct_sack_adjust(skb, protoff, tcph, ct, ctinfo);\r\nspin_unlock_bh(&ct->lock);\r\nreturn res;\r\n}\r\ns32 nf_ct_seq_offset(const struct nf_conn *ct,\r\nenum ip_conntrack_dir dir,\r\nu32 seq)\r\n{\r\nstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\r\nstruct nf_ct_seqadj *this_way;\r\nif (!seqadj)\r\nreturn 0;\r\nthis_way = &seqadj->seq[dir];\r\nreturn after(seq, this_way->correction_pos) ?\r\nthis_way->offset_after : this_way->offset_before;\r\n}\r\nint nf_conntrack_seqadj_init(void)\r\n{\r\nreturn nf_ct_extend_register(&nf_ct_seqadj_extend);\r\n}\r\nvoid nf_conntrack_seqadj_fini(void)\r\n{\r\nnf_ct_extend_unregister(&nf_ct_seqadj_extend);\r\n}
