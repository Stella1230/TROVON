static bool is_supervision_frame(struct hsr_priv *hsr, struct sk_buff *skb)\r\n{\r\nstruct ethhdr *ethHdr;\r\nstruct hsr_sup_tag *hsrSupTag;\r\nstruct hsrv1_ethhdr_sp *hsrV1Hdr;\r\nWARN_ON_ONCE(!skb_mac_header_was_set(skb));\r\nethHdr = (struct ethhdr *) skb_mac_header(skb);\r\nif (!ether_addr_equal(ethHdr->h_dest,\r\nhsr->sup_multicast_addr))\r\nreturn false;\r\nif (!(ethHdr->h_proto == htons(ETH_P_PRP)\r\n|| ethHdr->h_proto == htons(ETH_P_HSR)))\r\nreturn false;\r\nif (ethHdr->h_proto == htons(ETH_P_HSR)) {\r\nhsrV1Hdr = (struct hsrv1_ethhdr_sp *) skb_mac_header(skb);\r\nif (hsrV1Hdr->hsr.encap_proto != htons(ETH_P_PRP))\r\nreturn false;\r\nhsrSupTag = &hsrV1Hdr->hsr_sup;\r\n} else {\r\nhsrSupTag = &((struct hsrv0_ethhdr_sp *) skb_mac_header(skb))->hsr_sup;\r\n}\r\nif ((hsrSupTag->HSR_TLV_Type != HSR_TLV_ANNOUNCE) &&\r\n(hsrSupTag->HSR_TLV_Type != HSR_TLV_LIFE_CHECK))\r\nreturn false;\r\nif ((hsrSupTag->HSR_TLV_Length != 12) &&\r\n(hsrSupTag->HSR_TLV_Length !=\r\nsizeof(struct hsr_sup_payload)))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct sk_buff *create_stripped_skb(struct sk_buff *skb_in,\r\nstruct hsr_frame_info *frame)\r\n{\r\nstruct sk_buff *skb;\r\nint copylen;\r\nunsigned char *dst, *src;\r\nskb_pull(skb_in, HSR_HLEN);\r\nskb = __pskb_copy(skb_in, skb_headroom(skb_in) - HSR_HLEN, GFP_ATOMIC);\r\nskb_push(skb_in, HSR_HLEN);\r\nif (skb == NULL)\r\nreturn NULL;\r\nskb_reset_mac_header(skb);\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nskb->csum_start -= HSR_HLEN;\r\ncopylen = 2*ETH_ALEN;\r\nif (frame->is_vlan)\r\ncopylen += VLAN_HLEN;\r\nsrc = skb_mac_header(skb_in);\r\ndst = skb_mac_header(skb);\r\nmemcpy(dst, src, copylen);\r\nskb->protocol = eth_hdr(skb)->h_proto;\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *frame_get_stripped_skb(struct hsr_frame_info *frame,\r\nstruct hsr_port *port)\r\n{\r\nif (!frame->skb_std)\r\nframe->skb_std = create_stripped_skb(frame->skb_hsr, frame);\r\nreturn skb_clone(frame->skb_std, GFP_ATOMIC);\r\n}\r\nstatic void hsr_fill_tag(struct sk_buff *skb, struct hsr_frame_info *frame,\r\nstruct hsr_port *port, u8 protoVersion)\r\n{\r\nstruct hsr_ethhdr *hsr_ethhdr;\r\nint lane_id;\r\nint lsdu_size;\r\nif (port->type == HSR_PT_SLAVE_A)\r\nlane_id = 0;\r\nelse\r\nlane_id = 1;\r\nlsdu_size = skb->len - 14;\r\nif (frame->is_vlan)\r\nlsdu_size -= 4;\r\nhsr_ethhdr = (struct hsr_ethhdr *) skb_mac_header(skb);\r\nset_hsr_tag_path(&hsr_ethhdr->hsr_tag, lane_id);\r\nset_hsr_tag_LSDU_size(&hsr_ethhdr->hsr_tag, lsdu_size);\r\nhsr_ethhdr->hsr_tag.sequence_nr = htons(frame->sequence_nr);\r\nhsr_ethhdr->hsr_tag.encap_proto = hsr_ethhdr->ethhdr.h_proto;\r\nhsr_ethhdr->ethhdr.h_proto = htons(protoVersion ?\r\nETH_P_HSR : ETH_P_PRP);\r\n}\r\nstatic struct sk_buff *create_tagged_skb(struct sk_buff *skb_o,\r\nstruct hsr_frame_info *frame,\r\nstruct hsr_port *port)\r\n{\r\nint movelen;\r\nunsigned char *dst, *src;\r\nstruct sk_buff *skb;\r\nskb = __pskb_copy(skb_o, skb_headroom(skb_o) + HSR_HLEN, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn NULL;\r\nskb_reset_mac_header(skb);\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nskb->csum_start += HSR_HLEN;\r\nmovelen = ETH_HLEN;\r\nif (frame->is_vlan)\r\nmovelen += VLAN_HLEN;\r\nsrc = skb_mac_header(skb);\r\ndst = skb_push(skb, HSR_HLEN);\r\nmemmove(dst, src, movelen);\r\nskb_reset_mac_header(skb);\r\nhsr_fill_tag(skb, frame, port, port->hsr->protVersion);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *frame_get_tagged_skb(struct hsr_frame_info *frame,\r\nstruct hsr_port *port)\r\n{\r\nif (frame->skb_hsr)\r\nreturn skb_clone(frame->skb_hsr, GFP_ATOMIC);\r\nif ((port->type != HSR_PT_SLAVE_A) && (port->type != HSR_PT_SLAVE_B)) {\r\nWARN_ONCE(1, "HSR: Bug: trying to create a tagged frame for a non-ring port");\r\nreturn NULL;\r\n}\r\nreturn create_tagged_skb(frame->skb_std, frame, port);\r\n}\r\nstatic void hsr_deliver_master(struct sk_buff *skb, struct net_device *dev,\r\nstruct hsr_node *node_src)\r\n{\r\nbool was_multicast_frame;\r\nint res;\r\nwas_multicast_frame = (skb->pkt_type == PACKET_MULTICAST);\r\nhsr_addr_subst_source(node_src, skb);\r\nskb_pull(skb, ETH_HLEN);\r\nres = netif_rx(skb);\r\nif (res == NET_RX_DROP) {\r\ndev->stats.rx_dropped++;\r\n} else {\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nif (was_multicast_frame)\r\ndev->stats.multicast++;\r\n}\r\n}\r\nstatic int hsr_xmit(struct sk_buff *skb, struct hsr_port *port,\r\nstruct hsr_frame_info *frame)\r\n{\r\nif (frame->port_rcv->type == HSR_PT_MASTER) {\r\nhsr_addr_subst_dest(frame->node_src, skb, port);\r\nether_addr_copy(eth_hdr(skb)->h_source, port->dev->dev_addr);\r\n}\r\nreturn dev_queue_xmit(skb);\r\n}\r\nstatic void hsr_forward_do(struct hsr_frame_info *frame)\r\n{\r\nstruct hsr_port *port;\r\nstruct sk_buff *skb;\r\nhsr_for_each_port(frame->port_rcv->hsr, port) {\r\nif (port == frame->port_rcv)\r\ncontinue;\r\nif ((port->type == HSR_PT_MASTER) && !frame->is_local_dest)\r\ncontinue;\r\nif ((port->type != HSR_PT_MASTER) && frame->is_local_exclusive)\r\ncontinue;\r\nif (hsr_register_frame_out(port, frame->node_src,\r\nframe->sequence_nr))\r\ncontinue;\r\nif (frame->is_supervision && (port->type == HSR_PT_MASTER)) {\r\nhsr_handle_sup_frame(frame->skb_hsr,\r\nframe->node_src,\r\nframe->port_rcv);\r\ncontinue;\r\n}\r\nif (port->type != HSR_PT_MASTER)\r\nskb = frame_get_tagged_skb(frame, port);\r\nelse\r\nskb = frame_get_stripped_skb(frame, port);\r\nif (skb == NULL) {\r\ncontinue;\r\n}\r\nskb->dev = port->dev;\r\nif (port->type == HSR_PT_MASTER)\r\nhsr_deliver_master(skb, port->dev, frame->node_src);\r\nelse\r\nhsr_xmit(skb, port, frame);\r\n}\r\n}\r\nstatic void check_local_dest(struct hsr_priv *hsr, struct sk_buff *skb,\r\nstruct hsr_frame_info *frame)\r\n{\r\nstruct net_device *master_dev;\r\nmaster_dev = hsr_port_get_hsr(hsr, HSR_PT_MASTER)->dev;\r\nif (hsr_addr_is_self(hsr, eth_hdr(skb)->h_dest)) {\r\nframe->is_local_exclusive = true;\r\nskb->pkt_type = PACKET_HOST;\r\n} else {\r\nframe->is_local_exclusive = false;\r\n}\r\nif ((skb->pkt_type == PACKET_HOST) ||\r\n(skb->pkt_type == PACKET_MULTICAST) ||\r\n(skb->pkt_type == PACKET_BROADCAST)) {\r\nframe->is_local_dest = true;\r\n} else {\r\nframe->is_local_dest = false;\r\n}\r\n}\r\nstatic int hsr_fill_frame_info(struct hsr_frame_info *frame,\r\nstruct sk_buff *skb, struct hsr_port *port)\r\n{\r\nstruct ethhdr *ethhdr;\r\nunsigned long irqflags;\r\nframe->is_supervision = is_supervision_frame(port->hsr, skb);\r\nframe->node_src = hsr_get_node(&port->hsr->node_db, skb,\r\nframe->is_supervision);\r\nif (frame->node_src == NULL)\r\nreturn -1;\r\nethhdr = (struct ethhdr *) skb_mac_header(skb);\r\nframe->is_vlan = false;\r\nif (ethhdr->h_proto == htons(ETH_P_8021Q)) {\r\nframe->is_vlan = true;\r\nWARN_ONCE(1, "HSR: VLAN not yet supported");\r\n}\r\nif (ethhdr->h_proto == htons(ETH_P_PRP)\r\n|| ethhdr->h_proto == htons(ETH_P_HSR)) {\r\nframe->skb_std = NULL;\r\nframe->skb_hsr = skb;\r\nframe->sequence_nr = hsr_get_skb_sequence_nr(skb);\r\n} else {\r\nframe->skb_std = skb;\r\nframe->skb_hsr = NULL;\r\nspin_lock_irqsave(&port->hsr->seqnr_lock, irqflags);\r\nframe->sequence_nr = port->hsr->sequence_nr;\r\nport->hsr->sequence_nr++;\r\nspin_unlock_irqrestore(&port->hsr->seqnr_lock, irqflags);\r\n}\r\nframe->port_rcv = port;\r\ncheck_local_dest(port->hsr, skb, frame);\r\nreturn 0;\r\n}\r\nvoid hsr_forward_skb(struct sk_buff *skb, struct hsr_port *port)\r\n{\r\nstruct hsr_frame_info frame;\r\nif (skb_mac_header(skb) != skb->data) {\r\nWARN_ONCE(1, "%s:%d: Malformed frame (port_src %s)\n",\r\n__FILE__, __LINE__, port->dev->name);\r\ngoto out_drop;\r\n}\r\nif (hsr_fill_frame_info(&frame, skb, port) < 0)\r\ngoto out_drop;\r\nhsr_register_frame_in(frame.node_src, port, frame.sequence_nr);\r\nhsr_forward_do(&frame);\r\nif (frame.skb_hsr != NULL)\r\nkfree_skb(frame.skb_hsr);\r\nif (frame.skb_std != NULL)\r\nkfree_skb(frame.skb_std);\r\nreturn;\r\nout_drop:\r\nport->dev->stats.tx_dropped++;\r\nkfree_skb(skb);\r\n}
