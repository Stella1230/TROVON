static void malformed_message(struct xilly_endpoint *endpoint, u32 *buf)\r\n{\r\nint opcode;\r\nint msg_channel, msg_bufno, msg_data, msg_dir;\r\nopcode = (buf[0] >> 24) & 0xff;\r\nmsg_dir = buf[0] & 1;\r\nmsg_channel = (buf[0] >> 1) & 0x7ff;\r\nmsg_bufno = (buf[0] >> 12) & 0x3ff;\r\nmsg_data = buf[1] & 0xfffffff;\r\ndev_warn(endpoint->dev,\r\n"Malformed message (skipping): opcode=%d, channel=%03x, dir=%d, bufno=%03x, data=%07x\n",\r\nopcode, msg_channel, msg_dir, msg_bufno, msg_data);\r\n}\r\nirqreturn_t xillybus_isr(int irq, void *data)\r\n{\r\nstruct xilly_endpoint *ep = data;\r\nu32 *buf;\r\nunsigned int buf_size;\r\nint i;\r\nint opcode;\r\nunsigned int msg_channel, msg_bufno, msg_data, msg_dir;\r\nstruct xilly_channel *channel;\r\nbuf = ep->msgbuf_addr;\r\nbuf_size = ep->msg_buf_size/sizeof(u32);\r\nep->ephw->hw_sync_sgl_for_cpu(ep,\r\nep->msgbuf_dma_addr,\r\nep->msg_buf_size,\r\nDMA_FROM_DEVICE);\r\nfor (i = 0; i < buf_size; i += 2) {\r\nif (((buf[i+1] >> 28) & 0xf) != ep->msg_counter) {\r\nmalformed_message(ep, &buf[i]);\r\ndev_warn(ep->dev,\r\n"Sending a NACK on counter %x (instead of %x) on entry %d\n",\r\n((buf[i+1] >> 28) & 0xf),\r\nep->msg_counter,\r\ni/2);\r\nif (++ep->failed_messages > 10) {\r\ndev_err(ep->dev,\r\n"Lost sync with interrupt messages. Stopping.\n");\r\n} else {\r\nep->ephw->hw_sync_sgl_for_device(\r\nep,\r\nep->msgbuf_dma_addr,\r\nep->msg_buf_size,\r\nDMA_FROM_DEVICE);\r\niowrite32(0x01,\r\nep->registers + fpga_msg_ctrl_reg);\r\n}\r\nreturn IRQ_HANDLED;\r\n} else if (buf[i] & (1 << 22))\r\nbreak;\r\n}\r\nif (i >= buf_size) {\r\ndev_err(ep->dev, "Bad interrupt message. Stopping.\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nbuf_size = i + 2;\r\nfor (i = 0; i < buf_size; i += 2) {\r\nopcode = (buf[i] >> 24) & 0xff;\r\nmsg_dir = buf[i] & 1;\r\nmsg_channel = (buf[i] >> 1) & 0x7ff;\r\nmsg_bufno = (buf[i] >> 12) & 0x3ff;\r\nmsg_data = buf[i+1] & 0xfffffff;\r\nswitch (opcode) {\r\ncase XILLYMSG_OPCODE_RELEASEBUF:\r\nif ((msg_channel > ep->num_channels) ||\r\n(msg_channel == 0)) {\r\nmalformed_message(ep, &buf[i]);\r\nbreak;\r\n}\r\nchannel = ep->channels[msg_channel];\r\nif (msg_dir) {\r\nif (msg_bufno >= channel->num_wr_buffers) {\r\nmalformed_message(ep, &buf[i]);\r\nbreak;\r\n}\r\nspin_lock(&channel->wr_spinlock);\r\nchannel->wr_buffers[msg_bufno]->end_offset =\r\nmsg_data;\r\nchannel->wr_fpga_buf_idx = msg_bufno;\r\nchannel->wr_empty = 0;\r\nchannel->wr_sleepy = 0;\r\nspin_unlock(&channel->wr_spinlock);\r\nwake_up_interruptible(&channel->wr_wait);\r\n} else {\r\nif (msg_bufno >= channel->num_rd_buffers) {\r\nmalformed_message(ep, &buf[i]);\r\nbreak;\r\n}\r\nspin_lock(&channel->rd_spinlock);\r\nchannel->rd_fpga_buf_idx = msg_bufno;\r\nchannel->rd_full = 0;\r\nspin_unlock(&channel->rd_spinlock);\r\nwake_up_interruptible(&channel->rd_wait);\r\nif (!channel->rd_synchronous)\r\nqueue_delayed_work(\r\nxillybus_wq,\r\n&channel->rd_workitem,\r\nXILLY_RX_TIMEOUT);\r\n}\r\nbreak;\r\ncase XILLYMSG_OPCODE_NONEMPTY:\r\nif ((msg_channel > ep->num_channels) ||\r\n(msg_channel == 0) || (!msg_dir) ||\r\n!ep->channels[msg_channel]->wr_supports_nonempty) {\r\nmalformed_message(ep, &buf[i]);\r\nbreak;\r\n}\r\nchannel = ep->channels[msg_channel];\r\nif (msg_bufno >= channel->num_wr_buffers) {\r\nmalformed_message(ep, &buf[i]);\r\nbreak;\r\n}\r\nspin_lock(&channel->wr_spinlock);\r\nif (msg_bufno == channel->wr_host_buf_idx)\r\nchannel->wr_ready = 1;\r\nspin_unlock(&channel->wr_spinlock);\r\nwake_up_interruptible(&channel->wr_ready_wait);\r\nbreak;\r\ncase XILLYMSG_OPCODE_QUIESCEACK:\r\nep->idtlen = msg_data;\r\nwake_up_interruptible(&ep->ep_wait);\r\nbreak;\r\ncase XILLYMSG_OPCODE_FIFOEOF:\r\nif ((msg_channel > ep->num_channels) ||\r\n(msg_channel == 0) || (!msg_dir) ||\r\n!ep->channels[msg_channel]->num_wr_buffers) {\r\nmalformed_message(ep, &buf[i]);\r\nbreak;\r\n}\r\nchannel = ep->channels[msg_channel];\r\nspin_lock(&channel->wr_spinlock);\r\nchannel->wr_eof = msg_bufno;\r\nchannel->wr_sleepy = 0;\r\nchannel->wr_hangup = channel->wr_empty &&\r\n(channel->wr_host_buf_idx == msg_bufno);\r\nspin_unlock(&channel->wr_spinlock);\r\nwake_up_interruptible(&channel->wr_wait);\r\nbreak;\r\ncase XILLYMSG_OPCODE_FATAL_ERROR:\r\nep->fatal_error = 1;\r\nwake_up_interruptible(&ep->ep_wait);\r\ndev_err(ep->dev,\r\n"FPGA reported a fatal error. This means that the low-level communication with the device has failed. This hardware problem is most likely unrelated to Xillybus (neither kernel module nor FPGA core), but reports are still welcome. All I/O is aborted.\n");\r\nbreak;\r\ndefault:\r\nmalformed_message(ep, &buf[i]);\r\nbreak;\r\n}\r\n}\r\nep->ephw->hw_sync_sgl_for_device(ep,\r\nep->msgbuf_dma_addr,\r\nep->msg_buf_size,\r\nDMA_FROM_DEVICE);\r\nep->msg_counter = (ep->msg_counter + 1) & 0xf;\r\nep->failed_messages = 0;\r\niowrite32(0x03, ep->registers + fpga_msg_ctrl_reg);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xilly_get_dma_buffers(struct xilly_endpoint *ep,\r\nstruct xilly_alloc_state *s,\r\nstruct xilly_buffer **buffers,\r\nint bufnum, int bytebufsize)\r\n{\r\nint i, rc;\r\ndma_addr_t dma_addr;\r\nstruct device *dev = ep->dev;\r\nstruct xilly_buffer *this_buffer = NULL;\r\nif (buffers) {\r\nthis_buffer = devm_kcalloc(dev, bufnum,\r\nsizeof(struct xilly_buffer),\r\nGFP_KERNEL);\r\nif (!this_buffer)\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < bufnum; i++) {\r\nif ((s->left_of_salami < bytebufsize) &&\r\n(s->left_of_salami > 0)) {\r\ndev_err(ep->dev,\r\n"Corrupt buffer allocation in IDT. Aborting.\n");\r\nreturn -ENODEV;\r\n}\r\nif (s->left_of_salami == 0) {\r\nint allocorder, allocsize;\r\nallocsize = PAGE_SIZE;\r\nallocorder = 0;\r\nwhile (bytebufsize > allocsize) {\r\nallocsize *= 2;\r\nallocorder++;\r\n}\r\ns->salami = (void *) devm_get_free_pages(\r\ndev,\r\nGFP_KERNEL | __GFP_DMA32 | __GFP_ZERO,\r\nallocorder);\r\nif (!s->salami)\r\nreturn -ENOMEM;\r\ns->left_of_salami = allocsize;\r\n}\r\nrc = ep->ephw->map_single(ep, s->salami,\r\nbytebufsize, s->direction,\r\n&dma_addr);\r\nif (rc)\r\nreturn rc;\r\niowrite32((u32) (dma_addr & 0xffffffff),\r\nep->registers + fpga_dma_bufaddr_lowaddr_reg);\r\niowrite32(((u32) ((((u64) dma_addr) >> 32) & 0xffffffff)),\r\nep->registers + fpga_dma_bufaddr_highaddr_reg);\r\nif (buffers) {\r\nthis_buffer->addr = s->salami;\r\nthis_buffer->dma_addr = dma_addr;\r\nbuffers[i] = this_buffer++;\r\niowrite32(s->regdirection | s->nbuffer++,\r\nep->registers + fpga_dma_bufno_reg);\r\n} else {\r\nep->msgbuf_addr = s->salami;\r\nep->msgbuf_dma_addr = dma_addr;\r\nep->msg_buf_size = bytebufsize;\r\niowrite32(s->regdirection,\r\nep->registers + fpga_dma_bufno_reg);\r\n}\r\ns->left_of_salami -= bytebufsize;\r\ns->salami += bytebufsize;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xilly_setupchannels(struct xilly_endpoint *ep,\r\nunsigned char *chandesc,\r\nint entries)\r\n{\r\nstruct device *dev = ep->dev;\r\nint i, entry, rc;\r\nstruct xilly_channel *channel;\r\nint channelnum, bufnum, bufsize, format, is_writebuf;\r\nint bytebufsize;\r\nint synchronous, allowpartial, exclusive_open, seekable;\r\nint supports_nonempty;\r\nint msg_buf_done = 0;\r\nstruct xilly_alloc_state rd_alloc = {\r\n.salami = NULL,\r\n.left_of_salami = 0,\r\n.nbuffer = 1,\r\n.direction = DMA_TO_DEVICE,\r\n.regdirection = 0,\r\n};\r\nstruct xilly_alloc_state wr_alloc = {\r\n.salami = NULL,\r\n.left_of_salami = 0,\r\n.nbuffer = 1,\r\n.direction = DMA_FROM_DEVICE,\r\n.regdirection = 0x80000000,\r\n};\r\nchannel = devm_kcalloc(dev, ep->num_channels,\r\nsizeof(struct xilly_channel), GFP_KERNEL);\r\nif (!channel)\r\nreturn -ENOMEM;\r\nep->channels = devm_kcalloc(dev, ep->num_channels + 1,\r\nsizeof(struct xilly_channel *),\r\nGFP_KERNEL);\r\nif (!ep->channels)\r\nreturn -ENOMEM;\r\nep->channels[0] = NULL;\r\nfor (i = 1; i <= ep->num_channels; i++) {\r\nchannel->wr_buffers = NULL;\r\nchannel->rd_buffers = NULL;\r\nchannel->num_wr_buffers = 0;\r\nchannel->num_rd_buffers = 0;\r\nchannel->wr_fpga_buf_idx = -1;\r\nchannel->wr_host_buf_idx = 0;\r\nchannel->wr_host_buf_pos = 0;\r\nchannel->wr_empty = 1;\r\nchannel->wr_ready = 0;\r\nchannel->wr_sleepy = 1;\r\nchannel->rd_fpga_buf_idx = 0;\r\nchannel->rd_host_buf_idx = 0;\r\nchannel->rd_host_buf_pos = 0;\r\nchannel->rd_full = 0;\r\nchannel->wr_ref_count = 0;\r\nchannel->rd_ref_count = 0;\r\nspin_lock_init(&channel->wr_spinlock);\r\nspin_lock_init(&channel->rd_spinlock);\r\nmutex_init(&channel->wr_mutex);\r\nmutex_init(&channel->rd_mutex);\r\ninit_waitqueue_head(&channel->rd_wait);\r\ninit_waitqueue_head(&channel->wr_wait);\r\ninit_waitqueue_head(&channel->wr_ready_wait);\r\nINIT_DELAYED_WORK(&channel->rd_workitem, xillybus_autoflush);\r\nchannel->endpoint = ep;\r\nchannel->chan_num = i;\r\nchannel->log2_element_size = 0;\r\nep->channels[i] = channel++;\r\n}\r\nfor (entry = 0; entry < entries; entry++, chandesc += 4) {\r\nstruct xilly_buffer **buffers = NULL;\r\nis_writebuf = chandesc[0] & 0x01;\r\nchannelnum = (chandesc[0] >> 1) | ((chandesc[1] & 0x0f) << 7);\r\nformat = (chandesc[1] >> 4) & 0x03;\r\nallowpartial = (chandesc[1] >> 6) & 0x01;\r\nsynchronous = (chandesc[1] >> 7) & 0x01;\r\nbufsize = 1 << (chandesc[2] & 0x1f);\r\nbufnum = 1 << (chandesc[3] & 0x0f);\r\nexclusive_open = (chandesc[2] >> 7) & 0x01;\r\nseekable = (chandesc[2] >> 6) & 0x01;\r\nsupports_nonempty = (chandesc[2] >> 5) & 0x01;\r\nif ((channelnum > ep->num_channels) ||\r\n((channelnum == 0) && !is_writebuf)) {\r\ndev_err(ep->dev,\r\n"IDT requests channel out of range. Aborting.\n");\r\nreturn -ENODEV;\r\n}\r\nchannel = ep->channels[channelnum];\r\nif (!is_writebuf || channelnum > 0) {\r\nchannel->log2_element_size = ((format > 2) ?\r\n2 : format);\r\nbytebufsize = bufsize *\r\n(1 << channel->log2_element_size);\r\nbuffers = devm_kcalloc(dev, bufnum,\r\nsizeof(struct xilly_buffer *),\r\nGFP_KERNEL);\r\nif (!buffers)\r\nreturn -ENOMEM;\r\n} else {\r\nbytebufsize = bufsize << 2;\r\n}\r\nif (!is_writebuf) {\r\nchannel->num_rd_buffers = bufnum;\r\nchannel->rd_buf_size = bytebufsize;\r\nchannel->rd_allow_partial = allowpartial;\r\nchannel->rd_synchronous = synchronous;\r\nchannel->rd_exclusive_open = exclusive_open;\r\nchannel->seekable = seekable;\r\nchannel->rd_buffers = buffers;\r\nrc = xilly_get_dma_buffers(ep, &rd_alloc, buffers,\r\nbufnum, bytebufsize);\r\n} else if (channelnum > 0) {\r\nchannel->num_wr_buffers = bufnum;\r\nchannel->wr_buf_size = bytebufsize;\r\nchannel->seekable = seekable;\r\nchannel->wr_supports_nonempty = supports_nonempty;\r\nchannel->wr_allow_partial = allowpartial;\r\nchannel->wr_synchronous = synchronous;\r\nchannel->wr_exclusive_open = exclusive_open;\r\nchannel->wr_buffers = buffers;\r\nrc = xilly_get_dma_buffers(ep, &wr_alloc, buffers,\r\nbufnum, bytebufsize);\r\n} else {\r\nrc = xilly_get_dma_buffers(ep, &wr_alloc, NULL,\r\nbufnum, bytebufsize);\r\nmsg_buf_done++;\r\n}\r\nif (rc)\r\nreturn -ENOMEM;\r\n}\r\nif (!msg_buf_done) {\r\ndev_err(ep->dev,\r\n"Corrupt IDT: No message buffer. Aborting.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xilly_scan_idt(struct xilly_endpoint *endpoint,\r\nstruct xilly_idt_handle *idt_handle)\r\n{\r\nint count = 0;\r\nunsigned char *idt = endpoint->channels[1]->wr_buffers[0]->addr;\r\nunsigned char *end_of_idt = idt + endpoint->idtlen - 4;\r\nunsigned char *scan;\r\nint len;\r\nscan = idt;\r\nidt_handle->idt = idt;\r\nscan++;\r\nwhile ((scan <= end_of_idt) && *scan) {\r\nwhile ((scan <= end_of_idt) && *scan++)\r\n;\r\ncount++;\r\n}\r\nscan++;\r\nif (scan > end_of_idt) {\r\ndev_err(endpoint->dev,\r\n"IDT device name list overflow. Aborting.\n");\r\nreturn -ENODEV;\r\n}\r\nidt_handle->chandesc = scan;\r\nlen = endpoint->idtlen - (3 + ((int) (scan - idt)));\r\nif (len & 0x03) {\r\ndev_err(endpoint->dev,\r\n"Corrupt IDT device name list. Aborting.\n");\r\nreturn -ENODEV;\r\n}\r\nidt_handle->entries = len >> 2;\r\nendpoint->num_channels = count;\r\nreturn 0;\r\n}\r\nstatic int xilly_obtain_idt(struct xilly_endpoint *endpoint)\r\n{\r\nstruct xilly_channel *channel;\r\nunsigned char *version;\r\nlong t;\r\nchannel = endpoint->channels[1];\r\nchannel->wr_sleepy = 1;\r\niowrite32(1 |\r\n(3 << 24),\r\nendpoint->registers + fpga_buf_ctrl_reg);\r\nt = wait_event_interruptible_timeout(channel->wr_wait,\r\n(!channel->wr_sleepy),\r\nXILLY_TIMEOUT);\r\nif (t <= 0) {\r\ndev_err(endpoint->dev, "Failed to obtain IDT. Aborting.\n");\r\nif (endpoint->fatal_error)\r\nreturn -EIO;\r\nreturn -ENODEV;\r\n}\r\nendpoint->ephw->hw_sync_sgl_for_cpu(\r\nchannel->endpoint,\r\nchannel->wr_buffers[0]->dma_addr,\r\nchannel->wr_buf_size,\r\nDMA_FROM_DEVICE);\r\nif (channel->wr_buffers[0]->end_offset != endpoint->idtlen) {\r\ndev_err(endpoint->dev,\r\n"IDT length mismatch (%d != %d). Aborting.\n",\r\nchannel->wr_buffers[0]->end_offset, endpoint->idtlen);\r\nreturn -ENODEV;\r\n}\r\nif (crc32_le(~0, channel->wr_buffers[0]->addr,\r\nendpoint->idtlen+1) != 0) {\r\ndev_err(endpoint->dev, "IDT failed CRC check. Aborting.\n");\r\nreturn -ENODEV;\r\n}\r\nversion = channel->wr_buffers[0]->addr;\r\nif (*version > 0x82) {\r\ndev_err(endpoint->dev,\r\n"No support for IDT version 0x%02x. Maybe the xillybus driver needs an upgarde. Aborting.\n",\r\n*version);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t xillybus_read(struct file *filp, char __user *userbuf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nssize_t rc;\r\nunsigned long flags;\r\nint bytes_done = 0;\r\nint no_time_left = 0;\r\nlong deadline, left_to_sleep;\r\nstruct xilly_channel *channel = filp->private_data;\r\nint empty, reached_eof, exhausted, ready;\r\nint howmany = 0, bufpos = 0, bufidx = 0, bufferdone = 0;\r\nint waiting_bufidx;\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\ndeadline = jiffies + 1 + XILLY_RX_TIMEOUT;\r\nrc = mutex_lock_interruptible(&channel->wr_mutex);\r\nif (rc)\r\nreturn rc;\r\nwhile (1) {\r\nint bytes_to_do = count - bytes_done;\r\nspin_lock_irqsave(&channel->wr_spinlock, flags);\r\nempty = channel->wr_empty;\r\nready = !empty || channel->wr_ready;\r\nif (!empty) {\r\nbufidx = channel->wr_host_buf_idx;\r\nbufpos = channel->wr_host_buf_pos;\r\nhowmany = ((channel->wr_buffers[bufidx]->end_offset\r\n+ 1) << channel->log2_element_size)\r\n- bufpos;\r\nif (howmany > bytes_to_do) {\r\nbufferdone = 0;\r\nhowmany = bytes_to_do;\r\nchannel->wr_host_buf_pos += howmany;\r\n} else {\r\nbufferdone = 1;\r\nchannel->wr_host_buf_pos = 0;\r\nif (bufidx == channel->wr_fpga_buf_idx) {\r\nchannel->wr_empty = 1;\r\nchannel->wr_sleepy = 1;\r\nchannel->wr_ready = 0;\r\n}\r\nif (bufidx >= (channel->num_wr_buffers - 1))\r\nchannel->wr_host_buf_idx = 0;\r\nelse\r\nchannel->wr_host_buf_idx++;\r\n}\r\n}\r\nreached_eof = channel->wr_empty &&\r\n(channel->wr_host_buf_idx == channel->wr_eof);\r\nchannel->wr_hangup = reached_eof;\r\nexhausted = channel->wr_empty;\r\nwaiting_bufidx = channel->wr_host_buf_idx;\r\nspin_unlock_irqrestore(&channel->wr_spinlock, flags);\r\nif (!empty) {\r\nif (bufpos == 0)\r\nchannel->endpoint->ephw->hw_sync_sgl_for_cpu(\r\nchannel->endpoint,\r\nchannel->wr_buffers[bufidx]->dma_addr,\r\nchannel->wr_buf_size,\r\nDMA_FROM_DEVICE);\r\nif (copy_to_user(\r\nuserbuf,\r\nchannel->wr_buffers[bufidx]->addr\r\n+ bufpos, howmany))\r\nrc = -EFAULT;\r\nuserbuf += howmany;\r\nbytes_done += howmany;\r\nif (bufferdone) {\r\nchannel->endpoint->ephw->hw_sync_sgl_for_device(\r\nchannel->endpoint,\r\nchannel->wr_buffers[bufidx]->dma_addr,\r\nchannel->wr_buf_size,\r\nDMA_FROM_DEVICE);\r\niowrite32(1 | (channel->chan_num << 1) |\r\n(bufidx << 12),\r\nchannel->endpoint->registers +\r\nfpga_buf_ctrl_reg);\r\n}\r\nif (rc) {\r\nmutex_unlock(&channel->wr_mutex);\r\nreturn rc;\r\n}\r\n}\r\nif ((bytes_done >= count) || reached_eof)\r\nbreak;\r\nif (!exhausted)\r\ncontinue;\r\nif ((bytes_done > 0) &&\r\n(no_time_left ||\r\n(channel->wr_synchronous && channel->wr_allow_partial)))\r\nbreak;\r\nif (!no_time_left && (filp->f_flags & O_NONBLOCK)) {\r\nif (bytes_done > 0)\r\nbreak;\r\nif (ready)\r\ngoto desperate;\r\nrc = -EAGAIN;\r\nbreak;\r\n}\r\nif (!no_time_left || (bytes_done > 0)) {\r\nint offsetlimit = ((count - bytes_done) - 1) >>\r\nchannel->log2_element_size;\r\nint buf_elements = channel->wr_buf_size >>\r\nchannel->log2_element_size;\r\nif (channel->wr_synchronous) {\r\nif (channel->wr_allow_partial &&\r\n(offsetlimit >= buf_elements))\r\noffsetlimit = buf_elements - 1;\r\nif (!channel->wr_allow_partial &&\r\n(offsetlimit >=\r\n(buf_elements * channel->num_wr_buffers)))\r\noffsetlimit = buf_elements *\r\nchannel->num_wr_buffers - 1;\r\n}\r\nif (channel->wr_synchronous ||\r\n(offsetlimit < (buf_elements - 1))) {\r\nmutex_lock(&channel->endpoint->register_mutex);\r\niowrite32(offsetlimit,\r\nchannel->endpoint->registers +\r\nfpga_buf_offset_reg);\r\niowrite32(1 | (channel->chan_num << 1) |\r\n(2 << 24) |\r\n(waiting_bufidx << 12),\r\nchannel->endpoint->registers +\r\nfpga_buf_ctrl_reg);\r\nmutex_unlock(&channel->endpoint->\r\nregister_mutex);\r\n}\r\n}\r\nif (!channel->wr_allow_partial ||\r\n(no_time_left && (bytes_done == 0))) {\r\ndo {\r\nmutex_unlock(&channel->wr_mutex);\r\nif (wait_event_interruptible(\r\nchannel->wr_wait,\r\n(!channel->wr_sleepy)))\r\ngoto interrupted;\r\nif (mutex_lock_interruptible(\r\n&channel->wr_mutex))\r\ngoto interrupted;\r\n} while (channel->wr_sleepy);\r\ncontinue;\r\ninterrupted:\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nif (bytes_done)\r\nreturn bytes_done;\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nreturn -EINTR;\r\n}\r\nleft_to_sleep = deadline - ((long) jiffies);\r\nif (left_to_sleep > 0) {\r\nleft_to_sleep =\r\nwait_event_interruptible_timeout(\r\nchannel->wr_wait,\r\n(!channel->wr_sleepy),\r\nleft_to_sleep);\r\nif (left_to_sleep > 0)\r\ncontinue;\r\nif (left_to_sleep < 0) {\r\nmutex_unlock(&channel->wr_mutex);\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nif (bytes_done)\r\nreturn bytes_done;\r\nreturn -EINTR;\r\n}\r\n}\r\ndesperate:\r\nno_time_left = 1;\r\nif (bytes_done == 0) {\r\niowrite32(1 | (channel->chan_num << 1) |\r\n(3 << 24) |\r\n(waiting_bufidx << 12),\r\nchannel->endpoint->registers +\r\nfpga_buf_ctrl_reg);\r\n}\r\n}\r\nmutex_unlock(&channel->wr_mutex);\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nif (rc)\r\nreturn rc;\r\nreturn bytes_done;\r\n}\r\nstatic int xillybus_myflush(struct xilly_channel *channel, long timeout)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nint end_offset_plus1;\r\nint bufidx, bufidx_minus1;\r\nint i;\r\nint empty;\r\nint new_rd_host_buf_pos;\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nrc = mutex_lock_interruptible(&channel->rd_mutex);\r\nif (rc)\r\nreturn rc;\r\nif (!channel->rd_ref_count)\r\ngoto done;\r\nbufidx = channel->rd_host_buf_idx;\r\nbufidx_minus1 = (bufidx == 0) ?\r\nchannel->num_rd_buffers - 1 :\r\nbufidx - 1;\r\nend_offset_plus1 = channel->rd_host_buf_pos >>\r\nchannel->log2_element_size;\r\nnew_rd_host_buf_pos = channel->rd_host_buf_pos -\r\n(end_offset_plus1 << channel->log2_element_size);\r\nif (end_offset_plus1) {\r\nunsigned char *tail = channel->rd_buffers[bufidx]->addr +\r\n(end_offset_plus1 << channel->log2_element_size);\r\nfor (i = 0; i < new_rd_host_buf_pos; i++)\r\nchannel->rd_leftovers[i] = *tail++;\r\nspin_lock_irqsave(&channel->rd_spinlock, flags);\r\nif ((timeout < 0) &&\r\n(channel->rd_full ||\r\n(bufidx_minus1 != channel->rd_fpga_buf_idx))) {\r\nspin_unlock_irqrestore(&channel->rd_spinlock, flags);\r\ngoto done;\r\n}\r\nchannel->rd_leftovers[3] = (new_rd_host_buf_pos != 0);\r\nif (bufidx == channel->rd_fpga_buf_idx)\r\nchannel->rd_full = 1;\r\nspin_unlock_irqrestore(&channel->rd_spinlock, flags);\r\nif (bufidx >= (channel->num_rd_buffers - 1))\r\nchannel->rd_host_buf_idx = 0;\r\nelse\r\nchannel->rd_host_buf_idx++;\r\nchannel->endpoint->ephw->hw_sync_sgl_for_device(\r\nchannel->endpoint,\r\nchannel->rd_buffers[bufidx]->dma_addr,\r\nchannel->rd_buf_size,\r\nDMA_TO_DEVICE);\r\nmutex_lock(&channel->endpoint->register_mutex);\r\niowrite32(end_offset_plus1 - 1,\r\nchannel->endpoint->registers + fpga_buf_offset_reg);\r\niowrite32((channel->chan_num << 1) |\r\n(2 << 24) |\r\n(bufidx << 12),\r\nchannel->endpoint->registers + fpga_buf_ctrl_reg);\r\nmutex_unlock(&channel->endpoint->register_mutex);\r\n} else if (bufidx == 0) {\r\nbufidx = channel->num_rd_buffers - 1;\r\n} else {\r\nbufidx--;\r\n}\r\nchannel->rd_host_buf_pos = new_rd_host_buf_pos;\r\nif (timeout < 0)\r\ngoto done;\r\nwhile (1) {\r\nspin_lock_irqsave(&channel->rd_spinlock, flags);\r\nif (bufidx != channel->rd_fpga_buf_idx)\r\nchannel->rd_full = 1;\r\nempty = !channel->rd_full;\r\nspin_unlock_irqrestore(&channel->rd_spinlock, flags);\r\nif (empty)\r\nbreak;\r\nif (timeout == 0)\r\nwait_event_interruptible(channel->rd_wait,\r\n(!channel->rd_full));\r\nelse if (wait_event_interruptible_timeout(\r\nchannel->rd_wait,\r\n(!channel->rd_full),\r\ntimeout) == 0) {\r\ndev_warn(channel->endpoint->dev,\r\n"Timed out while flushing. Output data may be lost.\n");\r\nrc = -ETIMEDOUT;\r\nbreak;\r\n}\r\nif (channel->rd_full) {\r\nrc = -EINTR;\r\nbreak;\r\n}\r\n}\r\ndone:\r\nmutex_unlock(&channel->rd_mutex);\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nreturn rc;\r\n}\r\nstatic int xillybus_flush(struct file *filp, fl_owner_t id)\r\n{\r\nif (!(filp->f_mode & FMODE_WRITE))\r\nreturn 0;\r\nreturn xillybus_myflush(filp->private_data, HZ);\r\n}\r\nstatic void xillybus_autoflush(struct work_struct *work)\r\n{\r\nstruct delayed_work *workitem = container_of(\r\nwork, struct delayed_work, work);\r\nstruct xilly_channel *channel = container_of(\r\nworkitem, struct xilly_channel, rd_workitem);\r\nint rc;\r\nrc = xillybus_myflush(channel, -1);\r\nif (rc == -EINTR)\r\ndev_warn(channel->endpoint->dev,\r\n"Autoflush failed because work queue thread got a signal.\n");\r\nelse if (rc)\r\ndev_err(channel->endpoint->dev,\r\n"Autoflush failed under weird circumstances.\n");\r\n}\r\nstatic ssize_t xillybus_write(struct file *filp, const char __user *userbuf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nssize_t rc;\r\nunsigned long flags;\r\nint bytes_done = 0;\r\nstruct xilly_channel *channel = filp->private_data;\r\nint full, exhausted;\r\nint howmany = 0, bufpos = 0, bufidx = 0, bufferdone = 0;\r\nint end_offset_plus1 = 0;\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nrc = mutex_lock_interruptible(&channel->rd_mutex);\r\nif (rc)\r\nreturn rc;\r\nwhile (1) {\r\nint bytes_to_do = count - bytes_done;\r\nspin_lock_irqsave(&channel->rd_spinlock, flags);\r\nfull = channel->rd_full;\r\nif (!full) {\r\nbufidx = channel->rd_host_buf_idx;\r\nbufpos = channel->rd_host_buf_pos;\r\nhowmany = channel->rd_buf_size - bufpos;\r\nif ((howmany > bytes_to_do) &&\r\n(count ||\r\n((bufpos >> channel->log2_element_size) == 0))) {\r\nbufferdone = 0;\r\nhowmany = bytes_to_do;\r\nchannel->rd_host_buf_pos += howmany;\r\n} else {\r\nbufferdone = 1;\r\nif (count) {\r\nend_offset_plus1 =\r\nchannel->rd_buf_size >>\r\nchannel->log2_element_size;\r\nchannel->rd_host_buf_pos = 0;\r\n} else {\r\nunsigned char *tail;\r\nint i;\r\nhowmany = 0;\r\nend_offset_plus1 = bufpos >>\r\nchannel->log2_element_size;\r\nchannel->rd_host_buf_pos -=\r\nend_offset_plus1 <<\r\nchannel->log2_element_size;\r\ntail = channel->\r\nrd_buffers[bufidx]->addr +\r\n(end_offset_plus1 <<\r\nchannel->log2_element_size);\r\nfor (i = 0;\r\ni < channel->rd_host_buf_pos;\r\ni++)\r\nchannel->rd_leftovers[i] =\r\n*tail++;\r\n}\r\nif (bufidx == channel->rd_fpga_buf_idx)\r\nchannel->rd_full = 1;\r\nif (bufidx >= (channel->num_rd_buffers - 1))\r\nchannel->rd_host_buf_idx = 0;\r\nelse\r\nchannel->rd_host_buf_idx++;\r\n}\r\n}\r\nexhausted = channel->rd_full;\r\nspin_unlock_irqrestore(&channel->rd_spinlock, flags);\r\nif (!full) {\r\nunsigned char *head =\r\nchannel->rd_buffers[bufidx]->addr;\r\nint i;\r\nif ((bufpos == 0) ||\r\n(channel->rd_leftovers[3] != 0)) {\r\nchannel->endpoint->ephw->hw_sync_sgl_for_cpu(\r\nchannel->endpoint,\r\nchannel->rd_buffers[bufidx]->dma_addr,\r\nchannel->rd_buf_size,\r\nDMA_TO_DEVICE);\r\nfor (i = 0; i < bufpos; i++)\r\n*head++ = channel->rd_leftovers[i];\r\nchannel->rd_leftovers[3] = 0;\r\n}\r\nif (copy_from_user(\r\nchannel->rd_buffers[bufidx]->addr + bufpos,\r\nuserbuf, howmany))\r\nrc = -EFAULT;\r\nuserbuf += howmany;\r\nbytes_done += howmany;\r\nif (bufferdone) {\r\nchannel->endpoint->ephw->hw_sync_sgl_for_device(\r\nchannel->endpoint,\r\nchannel->rd_buffers[bufidx]->dma_addr,\r\nchannel->rd_buf_size,\r\nDMA_TO_DEVICE);\r\nmutex_lock(&channel->endpoint->register_mutex);\r\niowrite32(end_offset_plus1 - 1,\r\nchannel->endpoint->registers +\r\nfpga_buf_offset_reg);\r\niowrite32((channel->chan_num << 1) |\r\n(2 << 24) |\r\n(bufidx << 12),\r\nchannel->endpoint->registers +\r\nfpga_buf_ctrl_reg);\r\nmutex_unlock(&channel->endpoint->\r\nregister_mutex);\r\nchannel->rd_leftovers[3] =\r\n(channel->rd_host_buf_pos != 0);\r\n}\r\nif (rc) {\r\nmutex_unlock(&channel->rd_mutex);\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nif (!channel->rd_synchronous)\r\nqueue_delayed_work(\r\nxillybus_wq,\r\n&channel->rd_workitem,\r\nXILLY_RX_TIMEOUT);\r\nreturn rc;\r\n}\r\n}\r\nif (bytes_done >= count)\r\nbreak;\r\nif (!exhausted)\r\ncontinue;\r\nif ((bytes_done > 0) && channel->rd_allow_partial)\r\nbreak;\r\nif (filp->f_flags & O_NONBLOCK) {\r\nrc = -EAGAIN;\r\nbreak;\r\n}\r\nif (wait_event_interruptible(channel->rd_wait,\r\n(!channel->rd_full))) {\r\nmutex_unlock(&channel->rd_mutex);\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nif (bytes_done)\r\nreturn bytes_done;\r\nreturn -EINTR;\r\n}\r\n}\r\nmutex_unlock(&channel->rd_mutex);\r\nif (!channel->rd_synchronous)\r\nqueue_delayed_work(xillybus_wq,\r\n&channel->rd_workitem,\r\nXILLY_RX_TIMEOUT);\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nif (rc)\r\nreturn rc;\r\nif ((channel->rd_synchronous) && (bytes_done > 0)) {\r\nrc = xillybus_myflush(filp->private_data, 0);\r\nif (rc && (rc != -EINTR))\r\nreturn rc;\r\n}\r\nreturn bytes_done;\r\n}\r\nstatic int xillybus_open(struct inode *inode, struct file *filp)\r\n{\r\nint rc = 0;\r\nunsigned long flags;\r\nint minor = iminor(inode);\r\nint major = imajor(inode);\r\nstruct xilly_endpoint *ep_iter, *endpoint = NULL;\r\nstruct xilly_channel *channel;\r\nmutex_lock(&ep_list_lock);\r\nlist_for_each_entry(ep_iter, &list_of_endpoints, ep_list) {\r\nif ((ep_iter->major == major) &&\r\n(minor >= ep_iter->lowest_minor) &&\r\n(minor < (ep_iter->lowest_minor +\r\nep_iter->num_channels))) {\r\nendpoint = ep_iter;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ep_list_lock);\r\nif (!endpoint) {\r\npr_err("xillybus: open() failed to find a device for major=%d and minor=%d\n",\r\nmajor, minor);\r\nreturn -ENODEV;\r\n}\r\nif (endpoint->fatal_error)\r\nreturn -EIO;\r\nchannel = endpoint->channels[1 + minor - endpoint->lowest_minor];\r\nfilp->private_data = channel;\r\nif ((filp->f_mode & FMODE_READ) && (!channel->num_wr_buffers))\r\nreturn -ENODEV;\r\nif ((filp->f_mode & FMODE_WRITE) && (!channel->num_rd_buffers))\r\nreturn -ENODEV;\r\nif ((filp->f_mode & FMODE_READ) && (filp->f_flags & O_NONBLOCK) &&\r\n(channel->wr_synchronous || !channel->wr_allow_partial ||\r\n!channel->wr_supports_nonempty)) {\r\ndev_err(endpoint->dev,\r\n"open() failed: O_NONBLOCK not allowed for read on this device\n");\r\nreturn -ENODEV;\r\n}\r\nif ((filp->f_mode & FMODE_WRITE) && (filp->f_flags & O_NONBLOCK) &&\r\n(channel->rd_synchronous || !channel->rd_allow_partial)) {\r\ndev_err(endpoint->dev,\r\n"open() failed: O_NONBLOCK not allowed for write on this device\n");\r\nreturn -ENODEV;\r\n}\r\nif (filp->f_mode & FMODE_READ) {\r\nrc = mutex_lock_interruptible(&channel->wr_mutex);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (filp->f_mode & FMODE_WRITE) {\r\nrc = mutex_lock_interruptible(&channel->rd_mutex);\r\nif (rc)\r\ngoto unlock_wr;\r\n}\r\nif ((filp->f_mode & FMODE_READ) &&\r\n(channel->wr_ref_count != 0) &&\r\n(channel->wr_exclusive_open)) {\r\nrc = -EBUSY;\r\ngoto unlock;\r\n}\r\nif ((filp->f_mode & FMODE_WRITE) &&\r\n(channel->rd_ref_count != 0) &&\r\n(channel->rd_exclusive_open)) {\r\nrc = -EBUSY;\r\ngoto unlock;\r\n}\r\nif (filp->f_mode & FMODE_READ) {\r\nif (channel->wr_ref_count == 0) {\r\nspin_lock_irqsave(&channel->wr_spinlock, flags);\r\nchannel->wr_host_buf_idx = 0;\r\nchannel->wr_host_buf_pos = 0;\r\nchannel->wr_fpga_buf_idx = -1;\r\nchannel->wr_empty = 1;\r\nchannel->wr_ready = 0;\r\nchannel->wr_sleepy = 1;\r\nchannel->wr_eof = -1;\r\nchannel->wr_hangup = 0;\r\nspin_unlock_irqrestore(&channel->wr_spinlock, flags);\r\niowrite32(1 | (channel->chan_num << 1) |\r\n(4 << 24) |\r\n((channel->wr_synchronous & 1) << 23),\r\nchannel->endpoint->registers +\r\nfpga_buf_ctrl_reg);\r\n}\r\nchannel->wr_ref_count++;\r\n}\r\nif (filp->f_mode & FMODE_WRITE) {\r\nif (channel->rd_ref_count == 0) {\r\nspin_lock_irqsave(&channel->rd_spinlock, flags);\r\nchannel->rd_host_buf_idx = 0;\r\nchannel->rd_host_buf_pos = 0;\r\nchannel->rd_leftovers[3] = 0;\r\nchannel->rd_fpga_buf_idx = channel->num_rd_buffers - 1;\r\nchannel->rd_full = 0;\r\nspin_unlock_irqrestore(&channel->rd_spinlock, flags);\r\niowrite32((channel->chan_num << 1) |\r\n(4 << 24),\r\nchannel->endpoint->registers +\r\nfpga_buf_ctrl_reg);\r\n}\r\nchannel->rd_ref_count++;\r\n}\r\nunlock:\r\nif (filp->f_mode & FMODE_WRITE)\r\nmutex_unlock(&channel->rd_mutex);\r\nunlock_wr:\r\nif (filp->f_mode & FMODE_READ)\r\nmutex_unlock(&channel->wr_mutex);\r\nif (!rc && (!channel->seekable))\r\nreturn nonseekable_open(inode, filp);\r\nreturn rc;\r\n}\r\nstatic int xillybus_release(struct inode *inode, struct file *filp)\r\n{\r\nunsigned long flags;\r\nstruct xilly_channel *channel = filp->private_data;\r\nint buf_idx;\r\nint eof;\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nif (filp->f_mode & FMODE_WRITE) {\r\nmutex_lock(&channel->rd_mutex);\r\nchannel->rd_ref_count--;\r\nif (channel->rd_ref_count == 0) {\r\niowrite32((channel->chan_num << 1) |\r\n(5 << 24),\r\nchannel->endpoint->registers +\r\nfpga_buf_ctrl_reg);\r\n}\r\nmutex_unlock(&channel->rd_mutex);\r\n}\r\nif (filp->f_mode & FMODE_READ) {\r\nmutex_lock(&channel->wr_mutex);\r\nchannel->wr_ref_count--;\r\nif (channel->wr_ref_count == 0) {\r\niowrite32(1 | (channel->chan_num << 1) |\r\n(5 << 24),\r\nchannel->endpoint->registers +\r\nfpga_buf_ctrl_reg);\r\nwhile (1) {\r\nspin_lock_irqsave(&channel->wr_spinlock,\r\nflags);\r\nbuf_idx = channel->wr_fpga_buf_idx;\r\neof = channel->wr_eof;\r\nchannel->wr_sleepy = 1;\r\nspin_unlock_irqrestore(&channel->wr_spinlock,\r\nflags);\r\nbuf_idx++;\r\nif (buf_idx == channel->num_wr_buffers)\r\nbuf_idx = 0;\r\nif (buf_idx == eof)\r\nbreak;\r\nif (wait_event_interruptible(\r\nchannel->wr_wait,\r\n(!channel->wr_sleepy)))\r\nmsleep(100);\r\nif (channel->wr_sleepy) {\r\nmutex_unlock(&channel->wr_mutex);\r\ndev_warn(channel->endpoint->dev,\r\n"Hardware failed to respond to close command, therefore left in messy state.\n");\r\nreturn -EINTR;\r\n}\r\n}\r\n}\r\nmutex_unlock(&channel->wr_mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic loff_t xillybus_llseek(struct file *filp, loff_t offset, int whence)\r\n{\r\nstruct xilly_channel *channel = filp->private_data;\r\nloff_t pos = filp->f_pos;\r\nint rc = 0;\r\nif (channel->endpoint->fatal_error)\r\nreturn -EIO;\r\nmutex_lock(&channel->wr_mutex);\r\nmutex_lock(&channel->rd_mutex);\r\nswitch (whence) {\r\ncase SEEK_SET:\r\npos = offset;\r\nbreak;\r\ncase SEEK_CUR:\r\npos += offset;\r\nbreak;\r\ncase SEEK_END:\r\npos = offset;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\ngoto end;\r\n}\r\nif (pos & ((1 << channel->log2_element_size) - 1)) {\r\nrc = -EINVAL;\r\ngoto end;\r\n}\r\nmutex_lock(&channel->endpoint->register_mutex);\r\niowrite32(pos >> channel->log2_element_size,\r\nchannel->endpoint->registers + fpga_buf_offset_reg);\r\niowrite32((channel->chan_num << 1) |\r\n(6 << 24),\r\nchannel->endpoint->registers + fpga_buf_ctrl_reg);\r\nmutex_unlock(&channel->endpoint->register_mutex);\r\nend:\r\nmutex_unlock(&channel->rd_mutex);\r\nmutex_unlock(&channel->wr_mutex);\r\nif (rc)\r\nreturn rc;\r\nfilp->f_pos = pos;\r\nchannel->rd_leftovers[3] = 0;\r\nreturn pos;\r\n}\r\nstatic unsigned int xillybus_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct xilly_channel *channel = filp->private_data;\r\nunsigned int mask = 0;\r\nunsigned long flags;\r\npoll_wait(filp, &channel->endpoint->ep_wait, wait);\r\nif (!channel->wr_synchronous && channel->wr_supports_nonempty) {\r\npoll_wait(filp, &channel->wr_wait, wait);\r\npoll_wait(filp, &channel->wr_ready_wait, wait);\r\nspin_lock_irqsave(&channel->wr_spinlock, flags);\r\nif (!channel->wr_empty || channel->wr_ready)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (channel->wr_hangup)\r\nmask |= POLLIN | POLLRDNORM;\r\nspin_unlock_irqrestore(&channel->wr_spinlock, flags);\r\n}\r\nif (channel->rd_allow_partial) {\r\npoll_wait(filp, &channel->rd_wait, wait);\r\nspin_lock_irqsave(&channel->rd_spinlock, flags);\r\nif (!channel->rd_full)\r\nmask |= POLLOUT | POLLWRNORM;\r\nspin_unlock_irqrestore(&channel->rd_spinlock, flags);\r\n}\r\nif (channel->endpoint->fatal_error)\r\nmask |= POLLERR;\r\nreturn mask;\r\n}\r\nstatic int xillybus_init_chrdev(struct xilly_endpoint *endpoint,\r\nconst unsigned char *idt)\r\n{\r\nint rc;\r\ndev_t dev;\r\nint devnum, i, minor, major;\r\nchar devname[48];\r\nstruct device *device;\r\nrc = alloc_chrdev_region(&dev, 0,\r\nendpoint->num_channels,\r\nxillyname);\r\nif (rc) {\r\ndev_warn(endpoint->dev, "Failed to obtain major/minors");\r\nreturn rc;\r\n}\r\nendpoint->major = major = MAJOR(dev);\r\nendpoint->lowest_minor = minor = MINOR(dev);\r\ncdev_init(&endpoint->cdev, &xillybus_fops);\r\nendpoint->cdev.owner = endpoint->ephw->owner;\r\nrc = cdev_add(&endpoint->cdev, MKDEV(major, minor),\r\nendpoint->num_channels);\r\nif (rc) {\r\ndev_warn(endpoint->dev, "Failed to add cdev. Aborting.\n");\r\ngoto unregister_chrdev;\r\n}\r\nidt++;\r\nfor (i = minor, devnum = 0;\r\ndevnum < endpoint->num_channels;\r\ndevnum++, i++) {\r\nsnprintf(devname, sizeof(devname)-1, "xillybus_%s", idt);\r\ndevname[sizeof(devname)-1] = 0;\r\nwhile (*idt++)\r\n;\r\ndevice = device_create(xillybus_class,\r\nNULL,\r\nMKDEV(major, i),\r\nNULL,\r\n"%s", devname);\r\nif (IS_ERR(device)) {\r\ndev_warn(endpoint->dev,\r\n"Failed to create %s device. Aborting.\n",\r\ndevname);\r\nrc = -ENODEV;\r\ngoto unroll_device_create;\r\n}\r\n}\r\ndev_info(endpoint->dev, "Created %d device files.\n",\r\nendpoint->num_channels);\r\nreturn 0;\r\nunroll_device_create:\r\ndevnum--; i--;\r\nfor (; devnum >= 0; devnum--, i--)\r\ndevice_destroy(xillybus_class, MKDEV(major, i));\r\ncdev_del(&endpoint->cdev);\r\nunregister_chrdev:\r\nunregister_chrdev_region(MKDEV(major, minor), endpoint->num_channels);\r\nreturn rc;\r\n}\r\nstatic void xillybus_cleanup_chrdev(struct xilly_endpoint *endpoint)\r\n{\r\nint minor;\r\nfor (minor = endpoint->lowest_minor;\r\nminor < (endpoint->lowest_minor + endpoint->num_channels);\r\nminor++)\r\ndevice_destroy(xillybus_class, MKDEV(endpoint->major, minor));\r\ncdev_del(&endpoint->cdev);\r\nunregister_chrdev_region(MKDEV(endpoint->major,\r\nendpoint->lowest_minor),\r\nendpoint->num_channels);\r\ndev_info(endpoint->dev, "Removed %d device files.\n",\r\nendpoint->num_channels);\r\n}\r\nstruct xilly_endpoint *xillybus_init_endpoint(struct pci_dev *pdev,\r\nstruct device *dev,\r\nstruct xilly_endpoint_hardware\r\n*ephw)\r\n{\r\nstruct xilly_endpoint *endpoint;\r\nendpoint = devm_kzalloc(dev, sizeof(*endpoint), GFP_KERNEL);\r\nif (!endpoint)\r\nreturn NULL;\r\nendpoint->pdev = pdev;\r\nendpoint->dev = dev;\r\nendpoint->ephw = ephw;\r\nendpoint->msg_counter = 0x0b;\r\nendpoint->failed_messages = 0;\r\nendpoint->fatal_error = 0;\r\ninit_waitqueue_head(&endpoint->ep_wait);\r\nmutex_init(&endpoint->register_mutex);\r\nreturn endpoint;\r\n}\r\nstatic int xilly_quiesce(struct xilly_endpoint *endpoint)\r\n{\r\nlong t;\r\nendpoint->idtlen = -1;\r\niowrite32((u32) (endpoint->dma_using_dac & 0x0001),\r\nendpoint->registers + fpga_dma_control_reg);\r\nt = wait_event_interruptible_timeout(endpoint->ep_wait,\r\n(endpoint->idtlen >= 0),\r\nXILLY_TIMEOUT);\r\nif (t <= 0) {\r\ndev_err(endpoint->dev,\r\n"Failed to quiesce the device on exit.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nint xillybus_endpoint_discovery(struct xilly_endpoint *endpoint)\r\n{\r\nint rc;\r\nlong t;\r\nvoid *bootstrap_resources;\r\nint idtbuffersize = (1 << PAGE_SHIFT);\r\nstruct device *dev = endpoint->dev;\r\nunsigned char bogus_idt[8] = { 1, 224, (PAGE_SHIFT)-2, 0,\r\n3, 192, PAGE_SHIFT, 0 };\r\nstruct xilly_idt_handle idt_handle;\r\niowrite32(1, endpoint->registers + fpga_endian_reg);\r\nbootstrap_resources = devres_open_group(dev, NULL, GFP_KERNEL);\r\nif (!bootstrap_resources)\r\nreturn -ENOMEM;\r\nendpoint->num_channels = 0;\r\nrc = xilly_setupchannels(endpoint, bogus_idt, 1);\r\nif (rc)\r\nreturn rc;\r\niowrite32(0x04, endpoint->registers + fpga_msg_ctrl_reg);\r\nendpoint->idtlen = -1;\r\niowrite32((u32) (endpoint->dma_using_dac & 0x0001),\r\nendpoint->registers + fpga_dma_control_reg);\r\nt = wait_event_interruptible_timeout(endpoint->ep_wait,\r\n(endpoint->idtlen >= 0),\r\nXILLY_TIMEOUT);\r\nif (t <= 0) {\r\ndev_err(endpoint->dev, "No response from FPGA. Aborting.\n");\r\nreturn -ENODEV;\r\n}\r\niowrite32((u32) (0x0002 | (endpoint->dma_using_dac & 0x0001)),\r\nendpoint->registers + fpga_dma_control_reg);\r\nwhile (endpoint->idtlen >= idtbuffersize) {\r\nidtbuffersize *= 2;\r\nbogus_idt[6]++;\r\n}\r\nendpoint->num_channels = 1;\r\nrc = xilly_setupchannels(endpoint, bogus_idt, 2);\r\nif (rc)\r\ngoto failed_idt;\r\nrc = xilly_obtain_idt(endpoint);\r\nif (rc)\r\ngoto failed_idt;\r\nrc = xilly_scan_idt(endpoint, &idt_handle);\r\nif (rc)\r\ngoto failed_idt;\r\ndevres_close_group(dev, bootstrap_resources);\r\nrc = xilly_setupchannels(endpoint,\r\nidt_handle.chandesc,\r\nidt_handle.entries);\r\nif (rc)\r\ngoto failed_idt;\r\nmutex_lock(&ep_list_lock);\r\nlist_add_tail(&endpoint->ep_list, &list_of_endpoints);\r\nmutex_unlock(&ep_list_lock);\r\nrc = xillybus_init_chrdev(endpoint, idt_handle.idt);\r\nif (rc)\r\ngoto failed_chrdevs;\r\ndevres_release_group(dev, bootstrap_resources);\r\nreturn 0;\r\nfailed_chrdevs:\r\nmutex_lock(&ep_list_lock);\r\nlist_del(&endpoint->ep_list);\r\nmutex_unlock(&ep_list_lock);\r\nfailed_idt:\r\nxilly_quiesce(endpoint);\r\nflush_workqueue(xillybus_wq);\r\nreturn rc;\r\n}\r\nvoid xillybus_endpoint_remove(struct xilly_endpoint *endpoint)\r\n{\r\nxillybus_cleanup_chrdev(endpoint);\r\nmutex_lock(&ep_list_lock);\r\nlist_del(&endpoint->ep_list);\r\nmutex_unlock(&ep_list_lock);\r\nxilly_quiesce(endpoint);\r\nflush_workqueue(xillybus_wq);\r\n}\r\nstatic int __init xillybus_init(void)\r\n{\r\nmutex_init(&ep_list_lock);\r\nxillybus_class = class_create(THIS_MODULE, xillyname);\r\nif (IS_ERR(xillybus_class))\r\nreturn PTR_ERR(xillybus_class);\r\nxillybus_wq = alloc_workqueue(xillyname, 0, 0);\r\nif (!xillybus_wq) {\r\nclass_destroy(xillybus_class);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit xillybus_exit(void)\r\n{\r\ndestroy_workqueue(xillybus_wq);\r\nclass_destroy(xillybus_class);\r\n}
