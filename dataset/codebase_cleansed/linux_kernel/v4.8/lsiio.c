static inline int check_prefix(const char *str, const char *prefix)\r\n{\r\nreturn strlen(str) > strlen(prefix) &&\r\nstrncmp(str, prefix, strlen(prefix)) == 0;\r\n}\r\nstatic inline int check_postfix(const char *str, const char *postfix)\r\n{\r\nreturn strlen(str) > strlen(postfix) &&\r\nstrcmp(str + strlen(str) - strlen(postfix), postfix) == 0;\r\n}\r\nstatic int dump_channels(const char *dev_dir_name)\r\n{\r\nDIR *dp;\r\nconst struct dirent *ent;\r\ndp = opendir(dev_dir_name);\r\nif (!dp)\r\nreturn -errno;\r\nwhile (ent = readdir(dp), ent)\r\nif (check_prefix(ent->d_name, "in_") &&\r\ncheck_postfix(ent->d_name, "_raw"))\r\nprintf(" %-10s\n", ent->d_name);\r\nreturn (closedir(dp) == -1) ? -errno : 0;\r\n}\r\nstatic int dump_one_device(const char *dev_dir_name)\r\n{\r\nchar name[IIO_MAX_NAME_LENGTH];\r\nint dev_idx;\r\nint ret;\r\nret = sscanf(dev_dir_name + strlen(iio_dir) + strlen(type_device), "%i",\r\n&dev_idx);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nret = read_sysfs_string("name", dev_dir_name, name);\r\nif (ret < 0)\r\nreturn ret;\r\nprintf("Device %03d: %s\n", dev_idx, name);\r\nif (verblevel >= VERBLEVEL_SENSORS)\r\nreturn dump_channels(dev_dir_name);\r\nreturn 0;\r\n}\r\nstatic int dump_one_trigger(const char *dev_dir_name)\r\n{\r\nchar name[IIO_MAX_NAME_LENGTH];\r\nint dev_idx;\r\nint ret;\r\nret = sscanf(dev_dir_name + strlen(iio_dir) + strlen(type_trigger),\r\n"%i", &dev_idx);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nret = read_sysfs_string("name", dev_dir_name, name);\r\nif (ret < 0)\r\nreturn ret;\r\nprintf("Trigger %03d: %s\n", dev_idx, name);\r\nreturn 0;\r\n}\r\nstatic int dump_devices(void)\r\n{\r\nconst struct dirent *ent;\r\nint ret;\r\nDIR *dp;\r\ndp = opendir(iio_dir);\r\nif (!dp) {\r\nfprintf(stderr, "No industrial I/O devices available\n");\r\nreturn -ENODEV;\r\n}\r\nwhile (ent = readdir(dp), ent) {\r\nif (check_prefix(ent->d_name, type_device)) {\r\nchar *dev_dir_name;\r\nif (asprintf(&dev_dir_name, "%s%s", iio_dir,\r\nent->d_name) < 0) {\r\nret = -ENOMEM;\r\ngoto error_close_dir;\r\n}\r\nret = dump_one_device(dev_dir_name);\r\nif (ret) {\r\nfree(dev_dir_name);\r\ngoto error_close_dir;\r\n}\r\nfree(dev_dir_name);\r\nif (verblevel >= VERBLEVEL_SENSORS)\r\nprintf("\n");\r\n}\r\n}\r\nrewinddir(dp);\r\nwhile (ent = readdir(dp), ent) {\r\nif (check_prefix(ent->d_name, type_trigger)) {\r\nchar *dev_dir_name;\r\nif (asprintf(&dev_dir_name, "%s%s", iio_dir,\r\nent->d_name) < 0) {\r\nret = -ENOMEM;\r\ngoto error_close_dir;\r\n}\r\nret = dump_one_trigger(dev_dir_name);\r\nif (ret) {\r\nfree(dev_dir_name);\r\ngoto error_close_dir;\r\n}\r\nfree(dev_dir_name);\r\n}\r\n}\r\nreturn (closedir(dp) == -1) ? -errno : 0;\r\nerror_close_dir:\r\nif (closedir(dp) == -1)\r\nperror("dump_devices(): Failed to close directory");\r\nreturn ret;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nint c, err = 0;\r\nwhile ((c = getopt(argc, argv, "v")) != EOF) {\r\nswitch (c) {\r\ncase 'v':\r\nverblevel++;\r\nbreak;\r\ncase '?':\r\ndefault:\r\nerr++;\r\nbreak;\r\n}\r\n}\r\nif (err || argc > optind) {\r\nfprintf(stderr, "Usage: lsiio [options]...\n"\r\n"List industrial I/O devices\n"\r\n" -v Increase verbosity (may be given multiple times)\n");\r\nexit(1);\r\n}\r\nreturn dump_devices();\r\n}
