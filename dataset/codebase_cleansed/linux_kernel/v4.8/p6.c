static u64 p6_pmu_event_map(int hw_event)\r\n{\r\nreturn p6_perfmon_event_map[hw_event];\r\n}\r\nstatic void p6_pmu_disable_all(void)\r\n{\r\nu64 val;\r\nrdmsrl(MSR_P6_EVNTSEL0, val);\r\nval &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\r\nwrmsrl(MSR_P6_EVNTSEL0, val);\r\n}\r\nstatic void p6_pmu_enable_all(int added)\r\n{\r\nunsigned long val;\r\nrdmsrl(MSR_P6_EVNTSEL0, val);\r\nval |= ARCH_PERFMON_EVENTSEL_ENABLE;\r\nwrmsrl(MSR_P6_EVNTSEL0, val);\r\n}\r\nstatic inline void\r\np6_pmu_disable_event(struct perf_event *event)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nu64 val = P6_NOP_EVENT;\r\n(void)wrmsrl_safe(hwc->config_base, val);\r\n}\r\nstatic void p6_pmu_enable_event(struct perf_event *event)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nu64 val;\r\nval = hwc->config;\r\n(void)wrmsrl_safe(hwc->config_base, val);\r\n}\r\nstatic __init void p6_pmu_rdpmc_quirk(void)\r\n{\r\nif (boot_cpu_data.x86_mask < 9) {\r\npr_warn("Userspace RDPMC support disabled due to a CPU erratum\n");\r\nx86_pmu.attr_rdpmc_broken = 1;\r\nx86_pmu.attr_rdpmc = 0;\r\n}\r\n}\r\n__init int p6_pmu_init(void)\r\n{\r\nx86_pmu = p6_pmu;\r\nswitch (boot_cpu_data.x86_model) {\r\ncase 1:\r\nx86_add_quirk(p6_pmu_rdpmc_quirk);\r\nbreak;\r\ncase 3:\r\ncase 5:\r\ncase 6:\r\nbreak;\r\ncase 7:\r\ncase 8:\r\ncase 10:\r\ncase 11:\r\nbreak;\r\ncase 9:\r\ncase 13:\r\nbreak;\r\ndefault:\r\npr_cont("unsupported p6 CPU model %d ", boot_cpu_data.x86_model);\r\nreturn -ENODEV;\r\n}\r\nmemcpy(hw_cache_event_ids, p6_hw_cache_event_ids,\r\nsizeof(hw_cache_event_ids));\r\nreturn 0;\r\n}
