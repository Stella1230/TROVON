static struct drm_gem_cma_object *\r\n__drm_gem_cma_create(struct drm_device *drm, size_t size)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nstruct drm_gem_object *gem_obj;\r\nint ret;\r\nif (drm->driver->gem_create_object)\r\ngem_obj = drm->driver->gem_create_object(drm, size);\r\nelse\r\ngem_obj = kzalloc(sizeof(*cma_obj), GFP_KERNEL);\r\nif (!gem_obj)\r\nreturn ERR_PTR(-ENOMEM);\r\ncma_obj = container_of(gem_obj, struct drm_gem_cma_object, base);\r\nret = drm_gem_object_init(drm, gem_obj, size);\r\nif (ret)\r\ngoto error;\r\nret = drm_gem_create_mmap_offset(gem_obj);\r\nif (ret) {\r\ndrm_gem_object_release(gem_obj);\r\ngoto error;\r\n}\r\nreturn cma_obj;\r\nerror:\r\nkfree(cma_obj);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct drm_gem_cma_object *drm_gem_cma_create(struct drm_device *drm,\r\nsize_t size)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nint ret;\r\nsize = round_up(size, PAGE_SIZE);\r\ncma_obj = __drm_gem_cma_create(drm, size);\r\nif (IS_ERR(cma_obj))\r\nreturn cma_obj;\r\ncma_obj->vaddr = dma_alloc_wc(drm->dev, size, &cma_obj->paddr,\r\nGFP_KERNEL | __GFP_NOWARN);\r\nif (!cma_obj->vaddr) {\r\ndev_err(drm->dev, "failed to allocate buffer with size %zu\n",\r\nsize);\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nreturn cma_obj;\r\nerror:\r\ndrm_gem_object_unreference_unlocked(&cma_obj->base);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct drm_gem_cma_object *\r\ndrm_gem_cma_create_with_handle(struct drm_file *file_priv,\r\nstruct drm_device *drm, size_t size,\r\nuint32_t *handle)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nstruct drm_gem_object *gem_obj;\r\nint ret;\r\ncma_obj = drm_gem_cma_create(drm, size);\r\nif (IS_ERR(cma_obj))\r\nreturn cma_obj;\r\ngem_obj = &cma_obj->base;\r\nret = drm_gem_handle_create(file_priv, gem_obj, handle);\r\ndrm_gem_object_unreference_unlocked(gem_obj);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn cma_obj;\r\n}\r\nvoid drm_gem_cma_free_object(struct drm_gem_object *gem_obj)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\ncma_obj = to_drm_gem_cma_obj(gem_obj);\r\nif (cma_obj->vaddr) {\r\ndma_free_wc(gem_obj->dev->dev, cma_obj->base.size,\r\ncma_obj->vaddr, cma_obj->paddr);\r\n} else if (gem_obj->import_attach) {\r\ndrm_prime_gem_destroy(gem_obj, cma_obj->sgt);\r\n}\r\ndrm_gem_object_release(gem_obj);\r\nkfree(cma_obj);\r\n}\r\nint drm_gem_cma_dumb_create_internal(struct drm_file *file_priv,\r\nstruct drm_device *drm,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nunsigned int min_pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\r\nstruct drm_gem_cma_object *cma_obj;\r\nif (args->pitch < min_pitch)\r\nargs->pitch = min_pitch;\r\nif (args->size < args->pitch * args->height)\r\nargs->size = args->pitch * args->height;\r\ncma_obj = drm_gem_cma_create_with_handle(file_priv, drm, args->size,\r\n&args->handle);\r\nreturn PTR_ERR_OR_ZERO(cma_obj);\r\n}\r\nint drm_gem_cma_dumb_create(struct drm_file *file_priv,\r\nstruct drm_device *drm,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nargs->pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\r\nargs->size = args->pitch * args->height;\r\ncma_obj = drm_gem_cma_create_with_handle(file_priv, drm, args->size,\r\n&args->handle);\r\nreturn PTR_ERR_OR_ZERO(cma_obj);\r\n}\r\nint drm_gem_cma_dumb_map_offset(struct drm_file *file_priv,\r\nstruct drm_device *drm, u32 handle,\r\nu64 *offset)\r\n{\r\nstruct drm_gem_object *gem_obj;\r\ngem_obj = drm_gem_object_lookup(file_priv, handle);\r\nif (!gem_obj) {\r\ndev_err(drm->dev, "failed to lookup GEM object\n");\r\nreturn -EINVAL;\r\n}\r\n*offset = drm_vma_node_offset_addr(&gem_obj->vma_node);\r\ndrm_gem_object_unreference_unlocked(gem_obj);\r\nreturn 0;\r\n}\r\nstatic int drm_gem_cma_mmap_obj(struct drm_gem_cma_object *cma_obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nint ret;\r\nvma->vm_flags &= ~VM_PFNMAP;\r\nvma->vm_pgoff = 0;\r\nret = dma_mmap_wc(cma_obj->base.dev->dev, vma, cma_obj->vaddr,\r\ncma_obj->paddr, vma->vm_end - vma->vm_start);\r\nif (ret)\r\ndrm_gem_vm_close(vma);\r\nreturn ret;\r\n}\r\nint drm_gem_cma_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nstruct drm_gem_object *gem_obj;\r\nint ret;\r\nret = drm_gem_mmap(filp, vma);\r\nif (ret)\r\nreturn ret;\r\ngem_obj = vma->vm_private_data;\r\ncma_obj = to_drm_gem_cma_obj(gem_obj);\r\nreturn drm_gem_cma_mmap_obj(cma_obj, vma);\r\n}\r\nvoid drm_gem_cma_describe(struct drm_gem_cma_object *cma_obj,\r\nstruct seq_file *m)\r\n{\r\nstruct drm_gem_object *obj = &cma_obj->base;\r\nuint64_t off;\r\noff = drm_vma_node_start(&obj->vma_node);\r\nseq_printf(m, "%2d (%2d) %08llx %pad %p %zu",\r\nobj->name, obj->refcount.refcount.counter,\r\noff, &cma_obj->paddr, cma_obj->vaddr, obj->size);\r\nseq_printf(m, "\n");\r\n}\r\nstruct sg_table *drm_gem_cma_prime_get_sg_table(struct drm_gem_object *obj)\r\n{\r\nstruct drm_gem_cma_object *cma_obj = to_drm_gem_cma_obj(obj);\r\nstruct sg_table *sgt;\r\nint ret;\r\nsgt = kzalloc(sizeof(*sgt), GFP_KERNEL);\r\nif (!sgt)\r\nreturn NULL;\r\nret = dma_get_sgtable(obj->dev->dev, sgt, cma_obj->vaddr,\r\ncma_obj->paddr, obj->size);\r\nif (ret < 0)\r\ngoto out;\r\nreturn sgt;\r\nout:\r\nkfree(sgt);\r\nreturn NULL;\r\n}\r\nstruct drm_gem_object *\r\ndrm_gem_cma_prime_import_sg_table(struct drm_device *dev,\r\nstruct dma_buf_attachment *attach,\r\nstruct sg_table *sgt)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nif (sgt->nents != 1)\r\nreturn ERR_PTR(-EINVAL);\r\ncma_obj = __drm_gem_cma_create(dev, attach->dmabuf->size);\r\nif (IS_ERR(cma_obj))\r\nreturn ERR_CAST(cma_obj);\r\ncma_obj->paddr = sg_dma_address(sgt->sgl);\r\ncma_obj->sgt = sgt;\r\nDRM_DEBUG_PRIME("dma_addr = %pad, size = %zu\n", &cma_obj->paddr, attach->dmabuf->size);\r\nreturn &cma_obj->base;\r\n}\r\nint drm_gem_cma_prime_mmap(struct drm_gem_object *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nint ret;\r\nret = drm_gem_mmap_obj(obj, obj->size, vma);\r\nif (ret < 0)\r\nreturn ret;\r\ncma_obj = to_drm_gem_cma_obj(obj);\r\nreturn drm_gem_cma_mmap_obj(cma_obj, vma);\r\n}\r\nvoid *drm_gem_cma_prime_vmap(struct drm_gem_object *obj)\r\n{\r\nstruct drm_gem_cma_object *cma_obj = to_drm_gem_cma_obj(obj);\r\nreturn cma_obj->vaddr;\r\n}\r\nvoid drm_gem_cma_prime_vunmap(struct drm_gem_object *obj, void *vaddr)\r\n{\r\n}
