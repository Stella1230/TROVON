static void ixgbe_ptp_setup_sdp_x540(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint shift = adapter->hw_cc.shift;\r\nu32 esdp, tsauxc, clktiml, clktimh, trgttiml, trgttimh, rem;\r\nu64 ns = 0, clock_edge = 0;\r\nIXGBE_WRITE_REG(hw, IXGBE_TSAUXC, 0x0);\r\nIXGBE_WRITE_FLUSH(hw);\r\nif (!(adapter->flags2 & IXGBE_FLAG2_PTP_PPS_ENABLED))\r\nreturn;\r\nesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nesdp |= IXGBE_ESDP_SDP0_DIR |\r\nIXGBE_ESDP_SDP0_NATIVE;\r\ntsauxc = IXGBE_TSAUXC_EN_CLK |\r\nIXGBE_TSAUXC_SYNCLK |\r\nIXGBE_TSAUXC_SDP0_INT;\r\nclktiml = (u32)(IXGBE_PTP_PPS_HALF_SECOND << shift);\r\nclktimh = (u32)((IXGBE_PTP_PPS_HALF_SECOND << shift) >> 32);\r\nclock_edge |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIML);\r\nclock_edge |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIMH) << 32;\r\nns = timecounter_cyc2time(&adapter->hw_tc, clock_edge);\r\ndiv_u64_rem(ns, IXGBE_PTP_PPS_HALF_SECOND, &rem);\r\nclock_edge += ((IXGBE_PTP_PPS_HALF_SECOND - (u64)rem) << shift);\r\ntrgttiml = (u32)clock_edge;\r\ntrgttimh = (u32)(clock_edge >> 32);\r\nIXGBE_WRITE_REG(hw, IXGBE_CLKTIML, clktiml);\r\nIXGBE_WRITE_REG(hw, IXGBE_CLKTIMH, clktimh);\r\nIXGBE_WRITE_REG(hw, IXGBE_TRGTTIML0, trgttiml);\r\nIXGBE_WRITE_REG(hw, IXGBE_TRGTTIMH0, trgttimh);\r\nIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\r\nIXGBE_WRITE_REG(hw, IXGBE_TSAUXC, tsauxc);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nstatic cycle_t ixgbe_ptp_read_X550(const struct cyclecounter *hw_cc)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(hw_cc, struct ixgbe_adapter, hw_cc);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct timespec64 ts;\r\nIXGBE_READ_REG(hw, IXGBE_SYSTIMR);\r\nts.tv_nsec = IXGBE_READ_REG(hw, IXGBE_SYSTIML);\r\nts.tv_sec = IXGBE_READ_REG(hw, IXGBE_SYSTIMH);\r\nreturn (u64)timespec64_to_ns(&ts);\r\n}\r\nstatic cycle_t ixgbe_ptp_read_82599(const struct cyclecounter *cc)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(cc, struct ixgbe_adapter, hw_cc);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu64 stamp = 0;\r\nstamp |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIML);\r\nstamp |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIMH) << 32;\r\nreturn stamp;\r\n}\r\nstatic void ixgbe_ptp_convert_to_hwtstamp(struct ixgbe_adapter *adapter,\r\nstruct skb_shared_hwtstamps *hwtstamp,\r\nu64 timestamp)\r\n{\r\nunsigned long flags;\r\nstruct timespec64 systime;\r\nu64 ns;\r\nmemset(hwtstamp, 0, sizeof(*hwtstamp));\r\nswitch (adapter->hw.mac.type) {\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\ncase ixgbe_mac_x550em_a:\r\nsystime.tv_sec = timestamp >> 32;\r\nsystime.tv_nsec = timestamp & 0xFFFFFFFF;\r\ntimestamp = timespec64_to_ns(&systime);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nns = timecounter_cyc2time(&adapter->hw_tc, timestamp);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nhwtstamp->hwtstamp = ns_to_ktime(ns);\r\n}\r\nstatic int ixgbe_ptp_adjfreq_82599(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu64 freq, incval;\r\nu32 diff;\r\nint neg_adj = 0;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\nsmp_mb();\r\nincval = ACCESS_ONCE(adapter->base_incval);\r\nfreq = incval;\r\nfreq *= ppb;\r\ndiff = div_u64(freq, 1000000000ULL);\r\nincval = neg_adj ? (incval - diff) : (incval + diff);\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_X540:\r\nif (incval > 0xFFFFFFFFULL)\r\ne_dev_warn("PTP ppb adjusted SYSTIME rate overflowed!\n");\r\nIXGBE_WRITE_REG(hw, IXGBE_TIMINCA, (u32)incval);\r\nbreak;\r\ncase ixgbe_mac_82599EB:\r\nif (incval > 0x00FFFFFFULL)\r\ne_dev_warn("PTP ppb adjusted SYSTIME rate overflowed!\n");\r\nIXGBE_WRITE_REG(hw, IXGBE_TIMINCA,\r\nBIT(IXGBE_INCPER_SHIFT_82599) |\r\n((u32)incval & 0x00FFFFFFUL));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_ptp_adjfreq_X550(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint neg_adj = 0;\r\nu64 rate = IXGBE_X550_BASE_PERIOD;\r\nu32 inca;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\nrate *= ppb;\r\nrate = div_u64(rate, 1000000000ULL);\r\nif (rate >= INCVALUE_MASK)\r\ne_dev_warn("PTP ppb adjusted SYSTIME rate overflowed!\n");\r\ninca = rate & INCVALUE_MASK;\r\nif (neg_adj)\r\ninca |= ISGN;\r\nIXGBE_WRITE_REG(hw, IXGBE_TIMINCA, inca);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\ntimecounter_adjtime(&adapter->hw_tc, delta);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nif (adapter->ptp_setup_sdp)\r\nadapter->ptp_setup_sdp(adapter);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nunsigned long flags;\r\nu64 ns;\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nns = timecounter_read(&adapter->hw_tc);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nunsigned long flags;\r\nu64 ns = timespec64_to_ns(ts);\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\ntimecounter_init(&adapter->hw_tc, &adapter->hw_cc, ns);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nif (adapter->ptp_setup_sdp)\r\nadapter->ptp_setup_sdp(adapter);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_ptp_feature_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nif (rq->type != PTP_CLK_REQ_PPS || !adapter->ptp_setup_sdp)\r\nreturn -ENOTSUPP;\r\nif (on)\r\nadapter->flags2 |= IXGBE_FLAG2_PTP_PPS_ENABLED;\r\nelse\r\nadapter->flags2 &= ~IXGBE_FLAG2_PTP_PPS_ENABLED;\r\nadapter->ptp_setup_sdp(adapter);\r\nreturn 0;\r\n}\r\nvoid ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct ptp_clock_event event;\r\nevent.type = PTP_CLOCK_PPS;\r\nif (!adapter->ptp_clock)\r\nreturn;\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_X540:\r\nptp_clock_event(adapter->ptp_clock, &event);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter)\r\n{\r\nbool timeout = time_is_before_jiffies(adapter->last_overflow_check +\r\nIXGBE_OVERFLOW_PERIOD);\r\nstruct timespec64 ts;\r\nif (timeout) {\r\nixgbe_ptp_gettime(&adapter->ptp_caps, &ts);\r\nadapter->last_overflow_check = jiffies;\r\n}\r\n}\r\nvoid ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 tsyncrxctl = IXGBE_READ_REG(hw, IXGBE_TSYNCRXCTL);\r\nstruct ixgbe_ring *rx_ring;\r\nunsigned long rx_event;\r\nint n;\r\nif (!(tsyncrxctl & IXGBE_TSYNCRXCTL_VALID)) {\r\nadapter->last_rx_ptp_check = jiffies;\r\nreturn;\r\n}\r\nrx_event = adapter->last_rx_ptp_check;\r\nfor (n = 0; n < adapter->num_rx_queues; n++) {\r\nrx_ring = adapter->rx_ring[n];\r\nif (time_after(rx_ring->last_rx_timestamp, rx_event))\r\nrx_event = rx_ring->last_rx_timestamp;\r\n}\r\nif (time_is_before_jiffies(rx_event + 5 * HZ)) {\r\nIXGBE_READ_REG(hw, IXGBE_RXSTMPH);\r\nadapter->last_rx_ptp_check = jiffies;\r\nadapter->rx_hwtstamp_cleared++;\r\ne_warn(drv, "clearing RX Timestamp hang\n");\r\n}\r\n}\r\nstatic void ixgbe_ptp_clear_tx_timestamp(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nIXGBE_READ_REG(hw, IXGBE_TXSTMPH);\r\nif (adapter->ptp_tx_skb) {\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\n}\r\nclear_bit_unlock(__IXGBE_PTP_TX_IN_PROGRESS, &adapter->state);\r\n}\r\nstatic void ixgbe_ptp_tx_hwtstamp(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nu64 regval = 0;\r\nregval |= (u64)IXGBE_READ_REG(hw, IXGBE_TXSTMPL);\r\nregval |= (u64)IXGBE_READ_REG(hw, IXGBE_TXSTMPH) << 32;\r\nixgbe_ptp_convert_to_hwtstamp(adapter, &shhwtstamps, regval);\r\nskb_tstamp_tx(adapter->ptp_tx_skb, &shhwtstamps);\r\nixgbe_ptp_clear_tx_timestamp(adapter);\r\n}\r\nstatic void ixgbe_ptp_tx_hwtstamp_work(struct work_struct *work)\r\n{\r\nstruct ixgbe_adapter *adapter = container_of(work, struct ixgbe_adapter,\r\nptp_tx_work);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nbool timeout = time_is_before_jiffies(adapter->ptp_tx_start +\r\nIXGBE_PTP_TX_TIMEOUT);\r\nu32 tsynctxctl;\r\nif (!adapter->ptp_tx_skb) {\r\nixgbe_ptp_clear_tx_timestamp(adapter);\r\nreturn;\r\n}\r\ntsynctxctl = IXGBE_READ_REG(hw, IXGBE_TSYNCTXCTL);\r\nif (tsynctxctl & IXGBE_TSYNCTXCTL_VALID) {\r\nixgbe_ptp_tx_hwtstamp(adapter);\r\nreturn;\r\n}\r\nif (timeout) {\r\nixgbe_ptp_clear_tx_timestamp(adapter);\r\nadapter->tx_hwtstamp_timeouts++;\r\ne_warn(drv, "clearing Tx Timestamp hang\n");\r\n} else {\r\nschedule_work(&adapter->ptp_tx_work);\r\n}\r\n}\r\nvoid ixgbe_ptp_rx_pktstamp(struct ixgbe_q_vector *q_vector,\r\nstruct sk_buff *skb)\r\n{\r\n__le64 regval;\r\nskb_copy_bits(skb, skb->len - IXGBE_TS_HDR_LEN, &regval,\r\nIXGBE_TS_HDR_LEN);\r\n__pskb_trim(skb, skb->len - IXGBE_TS_HDR_LEN);\r\nixgbe_ptp_convert_to_hwtstamp(q_vector->adapter, skb_hwtstamps(skb),\r\nle64_to_cpu(regval));\r\n}\r\nvoid ixgbe_ptp_rx_rgtstamp(struct ixgbe_q_vector *q_vector,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ixgbe_adapter *adapter;\r\nstruct ixgbe_hw *hw;\r\nu64 regval = 0;\r\nu32 tsyncrxctl;\r\nif (!q_vector || !q_vector->adapter)\r\nreturn;\r\nadapter = q_vector->adapter;\r\nhw = &adapter->hw;\r\ntsyncrxctl = IXGBE_READ_REG(hw, IXGBE_TSYNCRXCTL);\r\nif (!(tsyncrxctl & IXGBE_TSYNCRXCTL_VALID))\r\nreturn;\r\nregval |= (u64)IXGBE_READ_REG(hw, IXGBE_RXSTMPL);\r\nregval |= (u64)IXGBE_READ_REG(hw, IXGBE_RXSTMPH) << 32;\r\nixgbe_ptp_convert_to_hwtstamp(adapter, skb_hwtstamps(skb), regval);\r\n}\r\nint ixgbe_ptp_get_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config *config = &adapter->tstamp_config;\r\nreturn copy_to_user(ifr->ifr_data, config,\r\nsizeof(*config)) ? -EFAULT : 0;\r\n}\r\nstatic int ixgbe_ptp_set_timestamp_mode(struct ixgbe_adapter *adapter,\r\nstruct hwtstamp_config *config)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 tsync_tx_ctl = IXGBE_TSYNCTXCTL_ENABLED;\r\nu32 tsync_rx_ctl = IXGBE_TSYNCRXCTL_ENABLED;\r\nu32 tsync_rx_mtrl = PTP_EV_PORT << 16;\r\nbool is_l2 = false;\r\nu32 regval;\r\nif (config->flags)\r\nreturn -EINVAL;\r\nswitch (config->tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\ntsync_tx_ctl = 0;\r\ncase HWTSTAMP_TX_ON:\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nswitch (config->rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\ntsync_rx_ctl = 0;\r\ntsync_rx_mtrl = 0;\r\nadapter->flags &= ~(IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\r\nIXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ntsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_L4_V1;\r\ntsync_rx_mtrl |= IXGBE_RXMTRL_V1_SYNC_MSG;\r\nadapter->flags &= ~(IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\r\nIXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ntsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_L4_V1;\r\ntsync_rx_mtrl |= IXGBE_RXMTRL_V1_DELAY_REQ_MSG;\r\nadapter->flags &= ~(IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\r\nIXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ntsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_EVENT_V2;\r\nis_l2 = true;\r\nconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\r\nadapter->flags &= ~(IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\r\nIXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_ALL:\r\nif (hw->mac.type >= ixgbe_mac_X550) {\r\ntsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_ALL;\r\nconfig->rx_filter = HWTSTAMP_FILTER_ALL;\r\nadapter->flags |= IXGBE_FLAG_RX_HWTSTAMP_ENABLED;\r\nbreak;\r\n}\r\ndefault:\r\nadapter->flags &= ~(IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\r\nIXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\r\nconfig->rx_filter = HWTSTAMP_FILTER_NONE;\r\nreturn -ERANGE;\r\n}\r\nif (hw->mac.type == ixgbe_mac_82598EB) {\r\nadapter->flags &= ~(IXGBE_FLAG_RX_HWTSTAMP_ENABLED |\r\nIXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);\r\nif (tsync_rx_ctl | tsync_tx_ctl)\r\nreturn -ERANGE;\r\nreturn 0;\r\n}\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\ncase ixgbe_mac_x550em_a:\r\nif (config->rx_filter == HWTSTAMP_FILTER_NONE)\r\nbreak;\r\ntsync_rx_ctl = IXGBE_TSYNCRXCTL_ENABLED |\r\nIXGBE_TSYNCRXCTL_TYPE_ALL |\r\nIXGBE_TSYNCRXCTL_TSIP_UT_EN;\r\nconfig->rx_filter = HWTSTAMP_FILTER_ALL;\r\nadapter->flags |= IXGBE_FLAG_RX_HWTSTAMP_ENABLED;\r\nadapter->flags &= ~IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER;\r\nis_l2 = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (is_l2)\r\nIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_1588),\r\n(IXGBE_ETQF_FILTER_EN |\r\nIXGBE_ETQF_1588 |\r\nETH_P_1588));\r\nelse\r\nIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_1588), 0);\r\nregval = IXGBE_READ_REG(hw, IXGBE_TSYNCTXCTL);\r\nregval &= ~IXGBE_TSYNCTXCTL_ENABLED;\r\nregval |= tsync_tx_ctl;\r\nIXGBE_WRITE_REG(hw, IXGBE_TSYNCTXCTL, regval);\r\nregval = IXGBE_READ_REG(hw, IXGBE_TSYNCRXCTL);\r\nregval &= ~(IXGBE_TSYNCRXCTL_ENABLED | IXGBE_TSYNCRXCTL_TYPE_MASK);\r\nregval |= tsync_rx_ctl;\r\nIXGBE_WRITE_REG(hw, IXGBE_TSYNCRXCTL, regval);\r\nIXGBE_WRITE_REG(hw, IXGBE_RXMTRL, tsync_rx_mtrl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nixgbe_ptp_clear_tx_timestamp(adapter);\r\nIXGBE_READ_REG(hw, IXGBE_RXSTMPH);\r\nreturn 0;\r\n}\r\nint ixgbe_ptp_set_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config config;\r\nint err;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nerr = ixgbe_ptp_set_timestamp_mode(adapter, &config);\r\nif (err)\r\nreturn err;\r\nmemcpy(&adapter->tstamp_config, &config,\r\nsizeof(adapter->tstamp_config));\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic void ixgbe_ptp_link_speed_adjust(struct ixgbe_adapter *adapter,\r\nu32 *shift, u32 *incval)\r\n{\r\nswitch (adapter->link_speed) {\r\ncase IXGBE_LINK_SPEED_100_FULL:\r\n*shift = IXGBE_INCVAL_SHIFT_100;\r\n*incval = IXGBE_INCVAL_100;\r\nbreak;\r\ncase IXGBE_LINK_SPEED_1GB_FULL:\r\n*shift = IXGBE_INCVAL_SHIFT_1GB;\r\n*incval = IXGBE_INCVAL_1GB;\r\nbreak;\r\ncase IXGBE_LINK_SPEED_10GB_FULL:\r\ndefault:\r\n*shift = IXGBE_INCVAL_SHIFT_10GB;\r\n*incval = IXGBE_INCVAL_10GB;\r\nbreak;\r\n}\r\n}\r\nvoid ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct cyclecounter cc;\r\nunsigned long flags;\r\nu32 incval = 0;\r\nu32 tsauxc = 0;\r\nu32 fuse0 = 0;\r\ncc.mask = CLOCKSOURCE_MASK(64);\r\ncc.mult = 1;\r\ncc.shift = 0;\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_X550EM_x:\r\nfuse0 = IXGBE_READ_REG(hw, IXGBE_FUSES0_GROUP(0));\r\nif (!(fuse0 & IXGBE_FUSES0_300MHZ)) {\r\ncc.mult = 3;\r\ncc.shift = 2;\r\n}\r\ncase ixgbe_mac_x550em_a:\r\ncase ixgbe_mac_X550:\r\ncc.read = ixgbe_ptp_read_X550;\r\nIXGBE_WRITE_REG(hw, IXGBE_SYSTIMR, 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_SYSTIML, 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_SYSTIMH, 0);\r\ntsauxc = IXGBE_READ_REG(hw, IXGBE_TSAUXC);\r\nIXGBE_WRITE_REG(hw, IXGBE_TSAUXC,\r\ntsauxc & ~IXGBE_TSAUXC_DISABLE_SYSTIME);\r\nIXGBE_WRITE_REG(hw, IXGBE_TSIM, IXGBE_TSIM_TXTS);\r\nIXGBE_WRITE_REG(hw, IXGBE_EIMS, IXGBE_EIMS_TIMESYNC);\r\nIXGBE_WRITE_FLUSH(hw);\r\nbreak;\r\ncase ixgbe_mac_X540:\r\ncc.read = ixgbe_ptp_read_82599;\r\nixgbe_ptp_link_speed_adjust(adapter, &cc.shift, &incval);\r\nIXGBE_WRITE_REG(hw, IXGBE_TIMINCA, incval);\r\nbreak;\r\ncase ixgbe_mac_82599EB:\r\ncc.read = ixgbe_ptp_read_82599;\r\nixgbe_ptp_link_speed_adjust(adapter, &cc.shift, &incval);\r\nincval >>= IXGBE_INCVAL_SHIFT_82599;\r\ncc.shift -= IXGBE_INCVAL_SHIFT_82599;\r\nIXGBE_WRITE_REG(hw, IXGBE_TIMINCA,\r\nBIT(IXGBE_INCPER_SHIFT_82599) | incval);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nACCESS_ONCE(adapter->base_incval) = incval;\r\nsmp_mb();\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nmemcpy(&adapter->hw_cc, &cc, sizeof(adapter->hw_cc));\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\n}\r\nvoid ixgbe_ptp_reset(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nunsigned long flags;\r\nixgbe_ptp_set_timestamp_mode(adapter, &adapter->tstamp_config);\r\nif (hw->mac.type == ixgbe_mac_82598EB)\r\nreturn;\r\nixgbe_ptp_start_cyclecounter(adapter);\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\ntimecounter_init(&adapter->hw_tc, &adapter->hw_cc,\r\nktime_to_ns(ktime_get_real()));\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nadapter->last_overflow_check = jiffies;\r\nif (adapter->ptp_setup_sdp)\r\nadapter->ptp_setup_sdp(adapter);\r\n}\r\nstatic long ixgbe_ptp_create_clock(struct ixgbe_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nlong err;\r\nif (!IS_ERR_OR_NULL(adapter->ptp_clock))\r\nreturn 0;\r\nswitch (adapter->hw.mac.type) {\r\ncase ixgbe_mac_X540:\r\nsnprintf(adapter->ptp_caps.name,\r\nsizeof(adapter->ptp_caps.name),\r\n"%s", netdev->name);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 250000000;\r\nadapter->ptp_caps.n_alarm = 0;\r\nadapter->ptp_caps.n_ext_ts = 0;\r\nadapter->ptp_caps.n_per_out = 0;\r\nadapter->ptp_caps.pps = 1;\r\nadapter->ptp_caps.adjfreq = ixgbe_ptp_adjfreq_82599;\r\nadapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;\r\nadapter->ptp_caps.gettime64 = ixgbe_ptp_gettime;\r\nadapter->ptp_caps.settime64 = ixgbe_ptp_settime;\r\nadapter->ptp_caps.enable = ixgbe_ptp_feature_enable;\r\nadapter->ptp_setup_sdp = ixgbe_ptp_setup_sdp_x540;\r\nbreak;\r\ncase ixgbe_mac_82599EB:\r\nsnprintf(adapter->ptp_caps.name,\r\nsizeof(adapter->ptp_caps.name),\r\n"%s", netdev->name);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 250000000;\r\nadapter->ptp_caps.n_alarm = 0;\r\nadapter->ptp_caps.n_ext_ts = 0;\r\nadapter->ptp_caps.n_per_out = 0;\r\nadapter->ptp_caps.pps = 0;\r\nadapter->ptp_caps.adjfreq = ixgbe_ptp_adjfreq_82599;\r\nadapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;\r\nadapter->ptp_caps.gettime64 = ixgbe_ptp_gettime;\r\nadapter->ptp_caps.settime64 = ixgbe_ptp_settime;\r\nadapter->ptp_caps.enable = ixgbe_ptp_feature_enable;\r\nbreak;\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\ncase ixgbe_mac_x550em_a:\r\nsnprintf(adapter->ptp_caps.name, 16, "%s", netdev->name);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 30000000;\r\nadapter->ptp_caps.n_alarm = 0;\r\nadapter->ptp_caps.n_ext_ts = 0;\r\nadapter->ptp_caps.n_per_out = 0;\r\nadapter->ptp_caps.pps = 0;\r\nadapter->ptp_caps.adjfreq = ixgbe_ptp_adjfreq_X550;\r\nadapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;\r\nadapter->ptp_caps.gettime64 = ixgbe_ptp_gettime;\r\nadapter->ptp_caps.settime64 = ixgbe_ptp_settime;\r\nadapter->ptp_caps.enable = ixgbe_ptp_feature_enable;\r\nadapter->ptp_setup_sdp = NULL;\r\nbreak;\r\ndefault:\r\nadapter->ptp_clock = NULL;\r\nadapter->ptp_setup_sdp = NULL;\r\nreturn -EOPNOTSUPP;\r\n}\r\nadapter->ptp_clock = ptp_clock_register(&adapter->ptp_caps,\r\n&adapter->pdev->dev);\r\nif (IS_ERR(adapter->ptp_clock)) {\r\nerr = PTR_ERR(adapter->ptp_clock);\r\nadapter->ptp_clock = NULL;\r\ne_dev_err("ptp_clock_register failed\n");\r\nreturn err;\r\n} else\r\ne_dev_info("registered PHC device on %s\n", netdev->name);\r\nadapter->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\r\nadapter->tstamp_config.tx_type = HWTSTAMP_TX_OFF;\r\nreturn 0;\r\n}\r\nvoid ixgbe_ptp_init(struct ixgbe_adapter *adapter)\r\n{\r\nspin_lock_init(&adapter->tmreg_lock);\r\nif (ixgbe_ptp_create_clock(adapter))\r\nreturn;\r\nINIT_WORK(&adapter->ptp_tx_work, ixgbe_ptp_tx_hwtstamp_work);\r\nixgbe_ptp_reset(adapter);\r\nset_bit(__IXGBE_PTP_RUNNING, &adapter->state);\r\nreturn;\r\n}\r\nvoid ixgbe_ptp_suspend(struct ixgbe_adapter *adapter)\r\n{\r\nif (!test_and_clear_bit(__IXGBE_PTP_RUNNING, &adapter->state))\r\nreturn;\r\nadapter->flags2 &= ~IXGBE_FLAG2_PTP_PPS_ENABLED;\r\nif (adapter->ptp_setup_sdp)\r\nadapter->ptp_setup_sdp(adapter);\r\ncancel_work_sync(&adapter->ptp_tx_work);\r\nixgbe_ptp_clear_tx_timestamp(adapter);\r\n}\r\nvoid ixgbe_ptp_stop(struct ixgbe_adapter *adapter)\r\n{\r\nixgbe_ptp_suspend(adapter);\r\nif (adapter->ptp_clock) {\r\nptp_clock_unregister(adapter->ptp_clock);\r\nadapter->ptp_clock = NULL;\r\ne_dev_info("removed PHC on %s\n",\r\nadapter->netdev->name);\r\n}\r\n}
