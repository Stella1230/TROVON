static void __init make_pll(int idx, const char *parent, void __iomem *base)\r\n{\r\nchar name[8];\r\nu32 val, mul, div;\r\nsprintf(name, "pll%d", idx);\r\nval = readl(base + idx * 8);\r\nmul = extract_pll_n(val) + 1;\r\ndiv = (extract_pll_m(val) + 1) << extract_pll_k(val);\r\nclk_register_fixed_factor(NULL, name, parent, 0, mul, div);\r\nif (extract_pll_isel(val) != 1)\r\npanic("%s: input not set to XTAL_IN\n", name);\r\n}\r\nstatic void __init make_cd(int idx, void __iomem *base)\r\n{\r\nchar name[8];\r\nu32 val, mul, div;\r\nsprintf(name, "cd%d", idx);\r\nval = readl(base + idx * 8);\r\nmul = 1 << 27;\r\ndiv = (2 << 27) + val;\r\nclk_register_fixed_factor(NULL, name, "pll2", 0, mul, div);\r\nif (val > 0xf0000000)\r\npanic("%s: unsupported divider %x\n", name, val);\r\n}\r\nstatic void __init tango4_clkgen_setup(struct device_node *np)\r\n{\r\nstruct clk **pp = clk_data.clks;\r\nvoid __iomem *base = of_iomap(np, 0);\r\nconst char *parent = of_clk_get_parent_name(np, 0);\r\nif (!base)\r\npanic("%s: invalid address\n", np->name);\r\nif (readl(base + CPUCLK_DIV) & DIV_BYPASS)\r\npanic("%s: unsupported cpuclk setup\n", np->name);\r\nif (readl(base + SYSCLK_DIV) & DIV_BYPASS)\r\npanic("%s: unsupported sysclk setup\n", np->name);\r\nwritel(0x100, base + CPUCLK_DIV);\r\nmake_pll(0, parent, base);\r\nmake_pll(1, parent, base);\r\nmake_pll(2, parent, base);\r\nmake_cd(2, base + 0x80);\r\nmake_cd(6, base + 0x80);\r\npp[0] = clk_register_divider(NULL, "cpu_clk", "pll0", 0,\r\nbase + CPUCLK_DIV, 8, 8, CLK_DIVIDER_ONE_BASED, NULL);\r\npp[1] = clk_register_fixed_factor(NULL, "sys_clk", "pll1", 0, 1, 4);\r\npp[2] = clk_register_fixed_factor(NULL, "usb_clk", "cd2", 0, 1, 2);\r\npp[3] = clk_register_fixed_factor(NULL, "sdio_clk", "cd6", 0, 1, 2);\r\nif (IS_ERR(pp[0]) || IS_ERR(pp[1]) || IS_ERR(pp[2]) || IS_ERR(pp[3]))\r\npanic("%s: clk registration failed\n", np->name);\r\nif (of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data))\r\npanic("%s: clk provider registration failed\n", np->name);\r\n}
