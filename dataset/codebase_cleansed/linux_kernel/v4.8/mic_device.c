static int __init mic_dp_init(void)\r\n{\r\nstruct mic_driver *mdrv = g_drv;\r\nstruct mic_device *mdev = &mdrv->mdev;\r\nstruct mic_bootparam __iomem *bootparam;\r\nu64 lo, hi, dp_dma_addr;\r\nu32 magic;\r\nlo = mic_read_spad(&mdrv->mdev, MIC_DPLO_SPAD);\r\nhi = mic_read_spad(&mdrv->mdev, MIC_DPHI_SPAD);\r\ndp_dma_addr = lo | (hi << 32);\r\nmdrv->dp = mic_card_map(mdev, dp_dma_addr, MIC_DP_SIZE);\r\nif (!mdrv->dp) {\r\ndev_err(mdrv->dev, "Cannot remap Aperture BAR\n");\r\nreturn -ENOMEM;\r\n}\r\nbootparam = mdrv->dp;\r\nmagic = ioread32(&bootparam->magic);\r\nif (MIC_MAGIC != magic) {\r\ndev_err(mdrv->dev, "bootparam magic mismatch 0x%x\n", magic);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mic_dp_uninit(void)\r\n{\r\nmic_card_unmap(&g_drv->mdev, g_drv->dp);\r\n}\r\nstruct mic_irq *\r\nmic_request_card_irq(irq_handler_t handler,\r\nirq_handler_t thread_fn, const char *name,\r\nvoid *data, int index)\r\n{\r\nint rc = 0;\r\nunsigned long cookie;\r\nstruct mic_driver *mdrv = g_drv;\r\nrc = request_threaded_irq(mic_db_to_irq(mdrv, index), handler,\r\nthread_fn, 0, name, data);\r\nif (rc) {\r\ndev_err(mdrv->dev, "request_threaded_irq failed rc = %d\n", rc);\r\ngoto err;\r\n}\r\nmdrv->irq_info.irq_usage_count[index]++;\r\ncookie = index;\r\nreturn (struct mic_irq *)cookie;\r\nerr:\r\nreturn ERR_PTR(rc);\r\n}\r\nvoid mic_free_card_irq(struct mic_irq *cookie, void *data)\r\n{\r\nint index;\r\nstruct mic_driver *mdrv = g_drv;\r\nindex = (unsigned long)cookie & 0xFFFFU;\r\nfree_irq(mic_db_to_irq(mdrv, index), data);\r\nmdrv->irq_info.irq_usage_count[index]--;\r\n}\r\nint mic_next_card_db(void)\r\n{\r\nint i;\r\nint index = 0;\r\nstruct mic_driver *mdrv = g_drv;\r\nfor (i = 0; i < mdrv->intr_info.num_intr; i++) {\r\nif (mdrv->irq_info.irq_usage_count[i] <\r\nmdrv->irq_info.irq_usage_count[index])\r\nindex = i;\r\n}\r\nreturn index;\r\n}\r\nstatic int mic_init_irq(void)\r\n{\r\nstruct mic_driver *mdrv = g_drv;\r\nmdrv->irq_info.irq_usage_count = kzalloc((sizeof(u32) *\r\nmdrv->intr_info.num_intr),\r\nGFP_KERNEL);\r\nif (!mdrv->irq_info.irq_usage_count)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void mic_uninit_irq(void)\r\n{\r\nstruct mic_driver *mdrv = g_drv;\r\nkfree(mdrv->irq_info.irq_usage_count);\r\n}\r\nstatic inline struct mic_driver *scdev_to_mdrv(struct scif_hw_dev *scdev)\r\n{\r\nreturn dev_get_drvdata(scdev->dev.parent);\r\n}\r\nstatic struct mic_irq *\r\n___mic_request_irq(struct scif_hw_dev *scdev,\r\nirqreturn_t (*func)(int irq, void *data),\r\nconst char *name, void *data,\r\nint db)\r\n{\r\nreturn mic_request_card_irq(func, NULL, name, data, db);\r\n}\r\nstatic void\r\n___mic_free_irq(struct scif_hw_dev *scdev,\r\nstruct mic_irq *cookie, void *data)\r\n{\r\nreturn mic_free_card_irq(cookie, data);\r\n}\r\nstatic void ___mic_ack_interrupt(struct scif_hw_dev *scdev, int num)\r\n{\r\nstruct mic_driver *mdrv = scdev_to_mdrv(scdev);\r\nmic_ack_interrupt(&mdrv->mdev);\r\n}\r\nstatic int ___mic_next_db(struct scif_hw_dev *scdev)\r\n{\r\nreturn mic_next_card_db();\r\n}\r\nstatic void ___mic_send_intr(struct scif_hw_dev *scdev, int db)\r\n{\r\nstruct mic_driver *mdrv = scdev_to_mdrv(scdev);\r\nmic_send_intr(&mdrv->mdev, db);\r\n}\r\nstatic void ___mic_send_p2p_intr(struct scif_hw_dev *scdev, int db,\r\nstruct mic_mw *mw)\r\n{\r\nmic_send_p2p_intr(db, mw);\r\n}\r\nstatic void __iomem *\r\n___mic_ioremap(struct scif_hw_dev *scdev,\r\nphys_addr_t pa, size_t len)\r\n{\r\nstruct mic_driver *mdrv = scdev_to_mdrv(scdev);\r\nreturn mic_card_map(&mdrv->mdev, pa, len);\r\n}\r\nstatic void ___mic_iounmap(struct scif_hw_dev *scdev, void __iomem *va)\r\n{\r\nstruct mic_driver *mdrv = scdev_to_mdrv(scdev);\r\nmic_card_unmap(&mdrv->mdev, va);\r\n}\r\nstatic inline struct mic_driver *vpdev_to_mdrv(struct vop_device *vpdev)\r\n{\r\nreturn dev_get_drvdata(vpdev->dev.parent);\r\n}\r\nstatic struct mic_irq *\r\n__mic_request_irq(struct vop_device *vpdev,\r\nirqreturn_t (*func)(int irq, void *data),\r\nconst char *name, void *data, int intr_src)\r\n{\r\nreturn mic_request_card_irq(func, NULL, name, data, intr_src);\r\n}\r\nstatic void __mic_free_irq(struct vop_device *vpdev,\r\nstruct mic_irq *cookie, void *data)\r\n{\r\nreturn mic_free_card_irq(cookie, data);\r\n}\r\nstatic void __mic_ack_interrupt(struct vop_device *vpdev, int num)\r\n{\r\nstruct mic_driver *mdrv = vpdev_to_mdrv(vpdev);\r\nmic_ack_interrupt(&mdrv->mdev);\r\n}\r\nstatic int __mic_next_db(struct vop_device *vpdev)\r\n{\r\nreturn mic_next_card_db();\r\n}\r\nstatic void __iomem *__mic_get_remote_dp(struct vop_device *vpdev)\r\n{\r\nstruct mic_driver *mdrv = vpdev_to_mdrv(vpdev);\r\nreturn mdrv->dp;\r\n}\r\nstatic void __mic_send_intr(struct vop_device *vpdev, int db)\r\n{\r\nstruct mic_driver *mdrv = vpdev_to_mdrv(vpdev);\r\nmic_send_intr(&mdrv->mdev, db);\r\n}\r\nstatic void __iomem *__mic_ioremap(struct vop_device *vpdev,\r\ndma_addr_t pa, size_t len)\r\n{\r\nstruct mic_driver *mdrv = vpdev_to_mdrv(vpdev);\r\nreturn mic_card_map(&mdrv->mdev, pa, len);\r\n}\r\nstatic void __mic_iounmap(struct vop_device *vpdev, void __iomem *va)\r\n{\r\nstruct mic_driver *mdrv = vpdev_to_mdrv(vpdev);\r\nmic_card_unmap(&mdrv->mdev, va);\r\n}\r\nstatic int mic_request_dma_chans(struct mic_driver *mdrv)\r\n{\r\ndma_cap_mask_t mask;\r\nstruct dma_chan *chan;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_MEMCPY, mask);\r\ndo {\r\nchan = dma_request_channel(mask, NULL, NULL);\r\nif (chan) {\r\nmdrv->dma_ch[mdrv->num_dma_ch++] = chan;\r\nif (mdrv->num_dma_ch >= MIC_MAX_DMA_CHAN)\r\nbreak;\r\n}\r\n} while (chan);\r\ndev_info(mdrv->dev, "DMA channels # %d\n", mdrv->num_dma_ch);\r\nreturn mdrv->num_dma_ch;\r\n}\r\nstatic void mic_free_dma_chans(struct mic_driver *mdrv)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < mdrv->num_dma_ch; i++) {\r\ndma_release_channel(mdrv->dma_ch[i]);\r\nmdrv->dma_ch[i] = NULL;\r\n}\r\nmdrv->num_dma_ch = 0;\r\n}\r\nint __init mic_driver_init(struct mic_driver *mdrv)\r\n{\r\nint rc;\r\nstruct mic_bootparam __iomem *bootparam;\r\nu8 node_id;\r\ng_drv = mdrv;\r\nif (!try_module_get(mdrv->dev->driver->owner)) {\r\nrc = -ENODEV;\r\ngoto done;\r\n}\r\nrc = mic_dp_init();\r\nif (rc)\r\ngoto put;\r\nrc = mic_init_irq();\r\nif (rc)\r\ngoto dp_uninit;\r\nif (!mic_request_dma_chans(mdrv)) {\r\nrc = -ENODEV;\r\ngoto irq_uninit;\r\n}\r\nmdrv->vpdev = vop_register_device(mdrv->dev, VOP_DEV_TRNSP,\r\nNULL, &vop_hw_ops, 0,\r\nNULL, mdrv->dma_ch[0]);\r\nif (IS_ERR(mdrv->vpdev)) {\r\nrc = PTR_ERR(mdrv->vpdev);\r\ngoto dma_free;\r\n}\r\nbootparam = mdrv->dp;\r\nnode_id = ioread8(&bootparam->node_id);\r\nmdrv->scdev = scif_register_device(mdrv->dev, MIC_SCIF_DEV,\r\nNULL, &scif_hw_ops,\r\n0, node_id, &mdrv->mdev.mmio, NULL,\r\nNULL, mdrv->dp, mdrv->dma_ch,\r\nmdrv->num_dma_ch, true);\r\nif (IS_ERR(mdrv->scdev)) {\r\nrc = PTR_ERR(mdrv->scdev);\r\ngoto vop_remove;\r\n}\r\nmic_create_card_debug_dir(mdrv);\r\ndone:\r\nreturn rc;\r\nvop_remove:\r\nvop_unregister_device(mdrv->vpdev);\r\ndma_free:\r\nmic_free_dma_chans(mdrv);\r\nirq_uninit:\r\nmic_uninit_irq();\r\ndp_uninit:\r\nmic_dp_uninit();\r\nput:\r\nmodule_put(mdrv->dev->driver->owner);\r\nreturn rc;\r\n}\r\nvoid mic_driver_uninit(struct mic_driver *mdrv)\r\n{\r\nmic_delete_card_debug_dir(mdrv);\r\nscif_unregister_device(mdrv->scdev);\r\nvop_unregister_device(mdrv->vpdev);\r\nmic_free_dma_chans(mdrv);\r\nmic_uninit_irq();\r\nmic_dp_uninit();\r\nmodule_put(mdrv->dev->driver->owner);\r\n}
