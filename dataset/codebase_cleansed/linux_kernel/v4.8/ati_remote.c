static const char *get_medion_keymap(struct usb_interface *interface)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nif (udev->manufacturer && udev->product) {\r\nif (udev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_WAKEUP) {\r\nif (!strcmp(udev->manufacturer, "X10 Wireless Technology Inc")\r\n&& !strcmp(udev->product, "USB Receiver"))\r\nreturn RC_MAP_MEDION_X10_DIGITAINER;\r\nif (!strcmp(udev->manufacturer, "X10 WTI")\r\n&& !strcmp(udev->product, "RF receiver"))\r\nreturn RC_MAP_MEDION_X10_OR2X;\r\n} else {\r\nif (!strcmp(udev->manufacturer, "X10 Wireless Technology Inc")\r\n&& !strcmp(udev->product, "USB Receiver"))\r\nreturn RC_MAP_MEDION_X10;\r\n}\r\n}\r\ndev_info(&interface->dev,\r\n"Unknown Medion X10 receiver, using default ati_remote Medion keymap\n");\r\nreturn RC_MAP_MEDION_X10;\r\n}\r\nstatic void ati_remote_dump(struct device *dev, unsigned char *data,\r\nunsigned int len)\r\n{\r\nif (len == 1) {\r\nif (data[0] != (unsigned char)0xff && data[0] != 0x00)\r\ndev_warn(dev, "Weird byte 0x%02x\n", data[0]);\r\n} else if (len == 4)\r\ndev_warn(dev, "Weird key %*ph\n", 4, data);\r\nelse\r\ndev_warn(dev, "Weird data, len=%d %*ph ...\n", len, 6, data);\r\n}\r\nstatic int ati_remote_open(struct ati_remote *ati_remote)\r\n{\r\nint err = 0;\r\nmutex_lock(&ati_remote->open_mutex);\r\nif (ati_remote->users++ != 0)\r\ngoto out;\r\nati_remote->irq_urb->dev = ati_remote->udev;\r\nif (usb_submit_urb(ati_remote->irq_urb, GFP_KERNEL)) {\r\ndev_err(&ati_remote->interface->dev,\r\n"%s: usb_submit_urb failed!\n", __func__);\r\nerr = -EIO;\r\n}\r\nout: mutex_unlock(&ati_remote->open_mutex);\r\nreturn err;\r\n}\r\nstatic void ati_remote_close(struct ati_remote *ati_remote)\r\n{\r\nmutex_lock(&ati_remote->open_mutex);\r\nif (--ati_remote->users == 0)\r\nusb_kill_urb(ati_remote->irq_urb);\r\nmutex_unlock(&ati_remote->open_mutex);\r\n}\r\nstatic int ati_remote_input_open(struct input_dev *inputdev)\r\n{\r\nstruct ati_remote *ati_remote = input_get_drvdata(inputdev);\r\nreturn ati_remote_open(ati_remote);\r\n}\r\nstatic void ati_remote_input_close(struct input_dev *inputdev)\r\n{\r\nstruct ati_remote *ati_remote = input_get_drvdata(inputdev);\r\nati_remote_close(ati_remote);\r\n}\r\nstatic int ati_remote_rc_open(struct rc_dev *rdev)\r\n{\r\nstruct ati_remote *ati_remote = rdev->priv;\r\nreturn ati_remote_open(ati_remote);\r\n}\r\nstatic void ati_remote_rc_close(struct rc_dev *rdev)\r\n{\r\nstruct ati_remote *ati_remote = rdev->priv;\r\nati_remote_close(ati_remote);\r\n}\r\nstatic void ati_remote_irq_out(struct urb *urb)\r\n{\r\nstruct ati_remote *ati_remote = urb->context;\r\nif (urb->status) {\r\ndev_dbg(&ati_remote->interface->dev, "%s: status %d\n",\r\n__func__, urb->status);\r\nreturn;\r\n}\r\nati_remote->send_flags |= SEND_FLAG_COMPLETE;\r\nwmb();\r\nwake_up(&ati_remote->wait);\r\n}\r\nstatic int ati_remote_sendpacket(struct ati_remote *ati_remote, u16 cmd,\r\nunsigned char *data)\r\n{\r\nint retval = 0;\r\nmemcpy(ati_remote->out_urb->transfer_buffer + 1, data, LO(cmd));\r\n((char *) ati_remote->out_urb->transfer_buffer)[0] = HI(cmd);\r\nati_remote->out_urb->transfer_buffer_length = LO(cmd) + 1;\r\nati_remote->out_urb->dev = ati_remote->udev;\r\nati_remote->send_flags = SEND_FLAG_IN_PROGRESS;\r\nretval = usb_submit_urb(ati_remote->out_urb, GFP_ATOMIC);\r\nif (retval) {\r\ndev_dbg(&ati_remote->interface->dev,\r\n"sendpacket: usb_submit_urb failed: %d\n", retval);\r\nreturn retval;\r\n}\r\nwait_event_timeout(ati_remote->wait,\r\n((ati_remote->out_urb->status != -EINPROGRESS) ||\r\n(ati_remote->send_flags & SEND_FLAG_COMPLETE)),\r\nHZ);\r\nusb_kill_urb(ati_remote->out_urb);\r\nreturn retval;\r\n}\r\nstatic int ati_remote_compute_accel(struct ati_remote *ati_remote)\r\n{\r\nunsigned long now = jiffies, reset_time;\r\nint i;\r\nreset_time = msecs_to_jiffies(250);\r\nif (time_after(now, ati_remote->old_jiffies + reset_time)) {\r\nati_remote->acc_jiffies = now;\r\nreturn 1;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(accel) - 1; i++) {\r\nunsigned long timeout = msecs_to_jiffies(accel[i].msecs);\r\nif (time_before(now, ati_remote->acc_jiffies + timeout))\r\nreturn accel[i].value;\r\n}\r\nreturn accel[i].value;\r\n}\r\nstatic void ati_remote_input_report(struct urb *urb)\r\n{\r\nstruct ati_remote *ati_remote = urb->context;\r\nunsigned char *data= ati_remote->inbuf;\r\nstruct input_dev *dev = ati_remote->idev;\r\nint index = -1;\r\nint remote_num;\r\nunsigned char scancode;\r\nu32 wheel_keycode = KEY_RESERVED;\r\nint i;\r\nif ( urb->actual_length != 4 || data[0] != 0x14 ||\r\ndata[1] != (unsigned char)(data[2] + data[3] + 0xD5) ||\r\n(data[3] & 0x0f) != 0x00) {\r\nati_remote_dump(&urb->dev->dev, data, urb->actual_length);\r\nreturn;\r\n}\r\nif (data[1] != ((data[2] + data[3] + 0xd5) & 0xff)) {\r\ndbginfo(&ati_remote->interface->dev,\r\n"wrong checksum in input: %*ph\n", 4, data);\r\nreturn;\r\n}\r\nremote_num = (data[3] >> 4) & 0x0f;\r\nif (channel_mask & (1 << (remote_num + 1))) {\r\ndbginfo(&ati_remote->interface->dev,\r\n"Masked input from channel 0x%02x: data %02x, "\r\n"mask= 0x%02lx\n",\r\nremote_num, data[2], channel_mask);\r\nreturn;\r\n}\r\nscancode = data[2] & 0x7f;\r\ndbginfo(&ati_remote->interface->dev,\r\n"channel 0x%02x; key data %02x, scancode %02x\n",\r\nremote_num, data[2], scancode);\r\nif (scancode >= 0x70) {\r\nwheel_keycode = rc_g_keycode_from_table(ati_remote->rdev,\r\nscancode & 0x78);\r\nif (wheel_keycode == KEY_RESERVED) {\r\nfor (i = 0; ati_remote_tbl[i].kind != KIND_END; i++) {\r\nif (scancode == ati_remote_tbl[i].data) {\r\nindex = i;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (index >= 0 && ati_remote_tbl[index].kind == KIND_LITERAL) {\r\ninput_event(dev, EV_KEY, ati_remote_tbl[index].code,\r\n!(data[2] & 1));\r\nati_remote->old_jiffies = jiffies;\r\n} else if (index < 0 || ati_remote_tbl[index].kind == KIND_FILTERED) {\r\nunsigned long now = jiffies;\r\nif (ati_remote->old_data == data[2] &&\r\ntime_before(now, ati_remote->old_jiffies +\r\nmsecs_to_jiffies(repeat_filter))) {\r\nati_remote->repeat_count++;\r\n} else {\r\nati_remote->repeat_count = 0;\r\nati_remote->first_jiffies = now;\r\n}\r\nati_remote->old_jiffies = now;\r\nif (ati_remote->repeat_count > 0 &&\r\n(ati_remote->repeat_count < 5 ||\r\ntime_before(now, ati_remote->first_jiffies +\r\nmsecs_to_jiffies(repeat_delay))))\r\nreturn;\r\nif (index >= 0) {\r\ninput_event(dev, EV_KEY, ati_remote_tbl[index].code, 1);\r\ninput_event(dev, EV_KEY, ati_remote_tbl[index].code, 0);\r\n} else {\r\nint count = 1;\r\nif (wheel_keycode != KEY_RESERVED) {\r\ncount = (scancode & 0x07) + 1;\r\nscancode &= 0x78;\r\n}\r\nwhile (count--) {\r\nrc_keydown_notimeout(ati_remote->rdev, RC_TYPE_OTHER,\r\nscancode, data[2]);\r\nrc_keyup(ati_remote->rdev);\r\n}\r\ngoto nosync;\r\n}\r\n} else if (ati_remote_tbl[index].kind == KIND_ACCEL) {\r\nsigned char dx = ati_remote_tbl[index].code >> 8;\r\nsigned char dy = ati_remote_tbl[index].code & 255;\r\nint acc = ati_remote_compute_accel(ati_remote);\r\nif (dx)\r\ninput_report_rel(dev, REL_X, dx * acc);\r\nif (dy)\r\ninput_report_rel(dev, REL_Y, dy * acc);\r\nati_remote->old_jiffies = jiffies;\r\n} else {\r\ndev_dbg(&ati_remote->interface->dev, "ati_remote kind=%d\n",\r\nati_remote_tbl[index].kind);\r\nreturn;\r\n}\r\ninput_sync(dev);\r\nnosync:\r\nati_remote->old_data = data[2];\r\n}\r\nstatic void ati_remote_irq_in(struct urb *urb)\r\n{\r\nstruct ati_remote *ati_remote = urb->context;\r\nint retval;\r\nswitch (urb->status) {\r\ncase 0:\r\nati_remote_input_report(urb);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&ati_remote->interface->dev,\r\n"%s: urb error status, unlink?\n",\r\n__func__);\r\nreturn;\r\ndefault:\r\ndev_dbg(&ati_remote->interface->dev,\r\n"%s: Nonzero urb status %d\n",\r\n__func__, urb->status);\r\n}\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&ati_remote->interface->dev,\r\n"%s: usb_submit_urb()=%d\n",\r\n__func__, retval);\r\n}\r\nstatic int ati_remote_alloc_buffers(struct usb_device *udev,\r\nstruct ati_remote *ati_remote)\r\n{\r\nati_remote->inbuf = usb_alloc_coherent(udev, DATA_BUFSIZE, GFP_ATOMIC,\r\n&ati_remote->inbuf_dma);\r\nif (!ati_remote->inbuf)\r\nreturn -1;\r\nati_remote->outbuf = usb_alloc_coherent(udev, DATA_BUFSIZE, GFP_ATOMIC,\r\n&ati_remote->outbuf_dma);\r\nif (!ati_remote->outbuf)\r\nreturn -1;\r\nati_remote->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!ati_remote->irq_urb)\r\nreturn -1;\r\nati_remote->out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!ati_remote->out_urb)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void ati_remote_free_buffers(struct ati_remote *ati_remote)\r\n{\r\nusb_free_urb(ati_remote->irq_urb);\r\nusb_free_urb(ati_remote->out_urb);\r\nusb_free_coherent(ati_remote->udev, DATA_BUFSIZE,\r\nati_remote->inbuf, ati_remote->inbuf_dma);\r\nusb_free_coherent(ati_remote->udev, DATA_BUFSIZE,\r\nati_remote->outbuf, ati_remote->outbuf_dma);\r\n}\r\nstatic void ati_remote_input_init(struct ati_remote *ati_remote)\r\n{\r\nstruct input_dev *idev = ati_remote->idev;\r\nint i;\r\nidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\nidev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\r\nBIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_SIDE) | BIT_MASK(BTN_EXTRA);\r\nidev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\nfor (i = 0; ati_remote_tbl[i].kind != KIND_END; i++)\r\nif (ati_remote_tbl[i].kind == KIND_LITERAL ||\r\nati_remote_tbl[i].kind == KIND_FILTERED)\r\n__set_bit(ati_remote_tbl[i].code, idev->keybit);\r\ninput_set_drvdata(idev, ati_remote);\r\nidev->open = ati_remote_input_open;\r\nidev->close = ati_remote_input_close;\r\nidev->name = ati_remote->mouse_name;\r\nidev->phys = ati_remote->mouse_phys;\r\nusb_to_input_id(ati_remote->udev, &idev->id);\r\nidev->dev.parent = &ati_remote->interface->dev;\r\n}\r\nstatic void ati_remote_rc_init(struct ati_remote *ati_remote)\r\n{\r\nstruct rc_dev *rdev = ati_remote->rdev;\r\nrdev->priv = ati_remote;\r\nrdev->driver_type = RC_DRIVER_SCANCODE;\r\nrdev->allowed_protocols = RC_BIT_OTHER;\r\nrdev->driver_name = "ati_remote";\r\nrdev->open = ati_remote_rc_open;\r\nrdev->close = ati_remote_rc_close;\r\nrdev->input_name = ati_remote->rc_name;\r\nrdev->input_phys = ati_remote->rc_phys;\r\nusb_to_input_id(ati_remote->udev, &rdev->input_id);\r\nrdev->dev.parent = &ati_remote->interface->dev;\r\n}\r\nstatic int ati_remote_initialize(struct ati_remote *ati_remote)\r\n{\r\nstruct usb_device *udev = ati_remote->udev;\r\nint pipe, maxp;\r\ninit_waitqueue_head(&ati_remote->wait);\r\npipe = usb_rcvintpipe(udev, ati_remote->endpoint_in->bEndpointAddress);\r\nmaxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\r\nmaxp = (maxp > DATA_BUFSIZE) ? DATA_BUFSIZE : maxp;\r\nusb_fill_int_urb(ati_remote->irq_urb, udev, pipe, ati_remote->inbuf,\r\nmaxp, ati_remote_irq_in, ati_remote,\r\nati_remote->endpoint_in->bInterval);\r\nati_remote->irq_urb->transfer_dma = ati_remote->inbuf_dma;\r\nati_remote->irq_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\npipe = usb_sndintpipe(udev, ati_remote->endpoint_out->bEndpointAddress);\r\nmaxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\r\nmaxp = (maxp > DATA_BUFSIZE) ? DATA_BUFSIZE : maxp;\r\nusb_fill_int_urb(ati_remote->out_urb, udev, pipe, ati_remote->outbuf,\r\nmaxp, ati_remote_irq_out, ati_remote,\r\nati_remote->endpoint_out->bInterval);\r\nati_remote->out_urb->transfer_dma = ati_remote->outbuf_dma;\r\nati_remote->out_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif ((ati_remote_sendpacket(ati_remote, 0x8004, init1)) ||\r\n(ati_remote_sendpacket(ati_remote, 0x8007, init2))) {\r\ndev_err(&ati_remote->interface->dev,\r\n"Initializing ati_remote hardware failed.\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ati_remote_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_host_interface *iface_host = interface->cur_altsetting;\r\nstruct usb_endpoint_descriptor *endpoint_in, *endpoint_out;\r\nstruct ati_receiver_type *type = (struct ati_receiver_type *)id->driver_info;\r\nstruct ati_remote *ati_remote;\r\nstruct input_dev *input_dev;\r\nstruct rc_dev *rc_dev;\r\nint err = -ENOMEM;\r\nif (iface_host->desc.bNumEndpoints != 2) {\r\nerr("%s: Unexpected desc.bNumEndpoints\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nendpoint_in = &iface_host->endpoint[0].desc;\r\nendpoint_out = &iface_host->endpoint[1].desc;\r\nif (!usb_endpoint_is_int_in(endpoint_in)) {\r\nerr("%s: Unexpected endpoint_in\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (le16_to_cpu(endpoint_in->wMaxPacketSize) == 0) {\r\nerr("%s: endpoint_in message size==0? \n", __func__);\r\nreturn -ENODEV;\r\n}\r\nati_remote = kzalloc(sizeof (struct ati_remote), GFP_KERNEL);\r\nrc_dev = rc_allocate_device();\r\nif (!ati_remote || !rc_dev)\r\ngoto exit_free_dev_rdev;\r\nif (ati_remote_alloc_buffers(udev, ati_remote))\r\ngoto exit_free_buffers;\r\nati_remote->endpoint_in = endpoint_in;\r\nati_remote->endpoint_out = endpoint_out;\r\nati_remote->udev = udev;\r\nati_remote->rdev = rc_dev;\r\nati_remote->interface = interface;\r\nusb_make_path(udev, ati_remote->rc_phys, sizeof(ati_remote->rc_phys));\r\nstrlcpy(ati_remote->mouse_phys, ati_remote->rc_phys,\r\nsizeof(ati_remote->mouse_phys));\r\nstrlcat(ati_remote->rc_phys, "/input0", sizeof(ati_remote->rc_phys));\r\nstrlcat(ati_remote->mouse_phys, "/input1", sizeof(ati_remote->mouse_phys));\r\nsnprintf(ati_remote->rc_name, sizeof(ati_remote->rc_name), "%s%s%s",\r\nudev->manufacturer ?: "",\r\nudev->manufacturer && udev->product ? " " : "",\r\nudev->product ?: "");\r\nif (!strlen(ati_remote->rc_name))\r\nsnprintf(ati_remote->rc_name, sizeof(ati_remote->rc_name),\r\nDRIVER_DESC "(%04x,%04x)",\r\nle16_to_cpu(ati_remote->udev->descriptor.idVendor),\r\nle16_to_cpu(ati_remote->udev->descriptor.idProduct));\r\nsnprintf(ati_remote->mouse_name, sizeof(ati_remote->mouse_name),\r\n"%s mouse", ati_remote->rc_name);\r\nrc_dev->map_name = RC_MAP_ATI_X10;\r\nif (type) {\r\nif (type->default_keymap)\r\nrc_dev->map_name = type->default_keymap;\r\nelse if (type->get_default_keymap)\r\nrc_dev->map_name = type->get_default_keymap(interface);\r\n}\r\nati_remote_rc_init(ati_remote);\r\nmutex_init(&ati_remote->open_mutex);\r\nerr = ati_remote_initialize(ati_remote);\r\nif (err)\r\ngoto exit_kill_urbs;\r\nerr = rc_register_device(ati_remote->rdev);\r\nif (err)\r\ngoto exit_kill_urbs;\r\nati_remote->rdev->input_dev->rep[REP_DELAY] = repeat_delay;\r\nif (mouse) {\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\nerr = -ENOMEM;\r\ngoto exit_unregister_device;\r\n}\r\nati_remote->idev = input_dev;\r\nati_remote_input_init(ati_remote);\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto exit_free_input_device;\r\n}\r\nusb_set_intfdata(interface, ati_remote);\r\nreturn 0;\r\nexit_free_input_device:\r\ninput_free_device(input_dev);\r\nexit_unregister_device:\r\nrc_unregister_device(rc_dev);\r\nrc_dev = NULL;\r\nexit_kill_urbs:\r\nusb_kill_urb(ati_remote->irq_urb);\r\nusb_kill_urb(ati_remote->out_urb);\r\nexit_free_buffers:\r\nati_remote_free_buffers(ati_remote);\r\nexit_free_dev_rdev:\r\nrc_free_device(rc_dev);\r\nkfree(ati_remote);\r\nreturn err;\r\n}\r\nstatic void ati_remote_disconnect(struct usb_interface *interface)\r\n{\r\nstruct ati_remote *ati_remote;\r\nati_remote = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nif (!ati_remote) {\r\ndev_warn(&interface->dev, "%s - null device?\n", __func__);\r\nreturn;\r\n}\r\nusb_kill_urb(ati_remote->irq_urb);\r\nusb_kill_urb(ati_remote->out_urb);\r\nif (ati_remote->idev)\r\ninput_unregister_device(ati_remote->idev);\r\nrc_unregister_device(ati_remote->rdev);\r\nati_remote_free_buffers(ati_remote);\r\nkfree(ati_remote);\r\n}
