static int p80211knetdev_init(netdevice_t *netdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int p80211knetdev_open(netdevice_t *netdev)\r\n{\r\nint result = 0;\r\nwlandevice_t *wlandev = netdev->ml_priv;\r\nif (wlandev->msdstate != WLAN_MSD_RUNNING)\r\nreturn -ENODEV;\r\nif (wlandev->open) {\r\nresult = wlandev->open(wlandev);\r\nif (result == 0) {\r\nnetif_start_queue(wlandev->netdev);\r\nwlandev->state = WLAN_DEVICE_OPEN;\r\n}\r\n} else {\r\nresult = -EAGAIN;\r\n}\r\nreturn result;\r\n}\r\nstatic int p80211knetdev_stop(netdevice_t *netdev)\r\n{\r\nint result = 0;\r\nwlandevice_t *wlandev = netdev->ml_priv;\r\nif (wlandev->close)\r\nresult = wlandev->close(wlandev);\r\nnetif_stop_queue(wlandev->netdev);\r\nwlandev->state = WLAN_DEVICE_CLOSED;\r\nreturn result;\r\n}\r\nvoid p80211netdev_rx(wlandevice_t *wlandev, struct sk_buff *skb)\r\n{\r\nskb_queue_tail(&wlandev->nsd_rxq, skb);\r\ntasklet_schedule(&wlandev->rx_bh);\r\n}\r\nstatic int p80211_convert_to_ether(wlandevice_t *wlandev, struct sk_buff *skb)\r\n{\r\nstruct p80211_hdr_a3 *hdr;\r\nhdr = (struct p80211_hdr_a3 *) skb->data;\r\nif (p80211_rx_typedrop(wlandev, hdr->fc))\r\nreturn CONV_TO_ETHER_SKIPPED;\r\nif (wlandev->netdev->flags & IFF_ALLMULTI) {\r\nif (!ether_addr_equal_unaligned(wlandev->netdev->dev_addr,\r\nhdr->a1)) {\r\nif (!is_multicast_ether_addr(hdr->a1))\r\nreturn CONV_TO_ETHER_SKIPPED;\r\n}\r\n}\r\nif (skb_p80211_to_ether(wlandev, wlandev->ethconv, skb) == 0) {\r\nskb->dev->last_rx = jiffies;\r\nwlandev->netdev->stats.rx_packets++;\r\nwlandev->netdev->stats.rx_bytes += skb->len;\r\nnetif_rx_ni(skb);\r\nreturn 0;\r\n}\r\nnetdev_dbg(wlandev->netdev, "p80211_convert_to_ether failed.\n");\r\nreturn CONV_TO_ETHER_FAILED;\r\n}\r\nstatic void p80211netdev_rx_bh(unsigned long arg)\r\n{\r\nwlandevice_t *wlandev = (wlandevice_t *) arg;\r\nstruct sk_buff *skb = NULL;\r\nnetdevice_t *dev = wlandev->netdev;\r\nwhile ((skb = skb_dequeue(&wlandev->nsd_rxq))) {\r\nif (wlandev->state == WLAN_DEVICE_OPEN) {\r\nif (dev->type != ARPHRD_ETHER) {\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_80211_RAW);\r\ndev->last_rx = jiffies;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx_ni(skb);\r\ncontinue;\r\n} else {\r\nif (!p80211_convert_to_ether(wlandev, skb))\r\ncontinue;\r\n}\r\n}\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic int p80211knetdev_hard_start_xmit(struct sk_buff *skb,\r\nnetdevice_t *netdev)\r\n{\r\nint result = 0;\r\nint txresult = -1;\r\nwlandevice_t *wlandev = netdev->ml_priv;\r\nunion p80211_hdr p80211_hdr;\r\nstruct p80211_metawep p80211_wep;\r\np80211_wep.data = NULL;\r\nif (!skb)\r\nreturn NETDEV_TX_OK;\r\nif (wlandev->state != WLAN_DEVICE_OPEN) {\r\nresult = 1;\r\ngoto failed;\r\n}\r\nmemset(&p80211_hdr, 0, sizeof(union p80211_hdr));\r\nmemset(&p80211_wep, 0, sizeof(struct p80211_metawep));\r\nif (netif_queue_stopped(netdev)) {\r\nnetdev_dbg(netdev, "called when queue stopped.\n");\r\nresult = 1;\r\ngoto failed;\r\n}\r\nnetif_stop_queue(netdev);\r\nswitch (wlandev->macmode) {\r\ncase WLAN_MACMODE_IBSS_STA:\r\ncase WLAN_MACMODE_ESS_STA:\r\ncase WLAN_MACMODE_ESS_AP:\r\nbreak;\r\ndefault:\r\nif (be16_to_cpu(skb->protocol) != ETH_P_80211_RAW) {\r\nnetif_start_queue(wlandev->netdev);\r\nnetdev_notice(netdev, "Tx attempt prior to association, frame dropped.\n");\r\nnetdev->stats.tx_dropped++;\r\nresult = 0;\r\ngoto failed;\r\n}\r\nbreak;\r\n}\r\nif (be16_to_cpu(skb->protocol) == ETH_P_80211_RAW) {\r\nif (!capable(CAP_NET_ADMIN)) {\r\nresult = 1;\r\ngoto failed;\r\n}\r\nmemcpy(&p80211_hdr, skb->data, sizeof(union p80211_hdr));\r\nskb_pull(skb, sizeof(union p80211_hdr));\r\n} else {\r\nif (skb_ether_to_p80211\r\n(wlandev, wlandev->ethconv, skb, &p80211_hdr,\r\n&p80211_wep) != 0) {\r\nnetdev_dbg(netdev, "ether_to_80211(%d) failed.\n",\r\nwlandev->ethconv);\r\nresult = 1;\r\ngoto failed;\r\n}\r\n}\r\nif (!wlandev->txframe) {\r\nresult = 1;\r\ngoto failed;\r\n}\r\nnetif_trans_update(netdev);\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes += skb->len;\r\ntxresult = wlandev->txframe(wlandev, skb, &p80211_hdr, &p80211_wep);\r\nif (txresult == 0) {\r\nnetif_wake_queue(wlandev->netdev);\r\nresult = NETDEV_TX_OK;\r\n} else if (txresult == 1) {\r\nnetdev_dbg(netdev, "txframe success, no more bufs\n");\r\nresult = NETDEV_TX_OK;\r\n} else if (txresult == 2) {\r\nnetdev_dbg(netdev, "txframe returned alloc_fail\n");\r\nresult = NETDEV_TX_BUSY;\r\n} else {\r\nnetdev_dbg(netdev, "txframe returned full or busy\n");\r\nresult = NETDEV_TX_BUSY;\r\n}\r\nfailed:\r\nif ((p80211_wep.data) && (p80211_wep.data != skb->data))\r\nkzfree(p80211_wep.data);\r\nif (!result)\r\ndev_kfree_skb(skb);\r\nreturn result;\r\n}\r\nstatic void p80211knetdev_set_multicast_list(netdevice_t *dev)\r\n{\r\nwlandevice_t *wlandev = dev->ml_priv;\r\nif (wlandev->set_multicast_list)\r\nwlandev->set_multicast_list(wlandev, dev);\r\n}\r\nstatic int p80211netdev_ethtool(wlandevice_t *wlandev, void __user *useraddr)\r\n{\r\nu32 ethcmd;\r\nstruct ethtool_drvinfo info;\r\nstruct ethtool_value edata;\r\nmemset(&info, 0, sizeof(info));\r\nmemset(&edata, 0, sizeof(edata));\r\nif (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))\r\nreturn -EFAULT;\r\nswitch (ethcmd) {\r\ncase ETHTOOL_GDRVINFO:\r\ninfo.cmd = ethcmd;\r\nsnprintf(info.driver, sizeof(info.driver), "p80211_%s",\r\nwlandev->nsdname);\r\nsnprintf(info.version, sizeof(info.version), "%s",\r\nWLAN_RELEASE);\r\nif (copy_to_user(useraddr, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n#ifdef ETHTOOL_GLINK\r\ncase ETHTOOL_GLINK:\r\nedata.cmd = ethcmd;\r\nif (wlandev->linkstatus &&\r\n(wlandev->macmode != WLAN_MACMODE_NONE)) {\r\nedata.data = 1;\r\n} else {\r\nedata.data = 0;\r\n}\r\nif (copy_to_user(useraddr, &edata, sizeof(edata)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n#endif\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int p80211knetdev_do_ioctl(netdevice_t *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint result = 0;\r\nstruct p80211ioctl_req *req = (struct p80211ioctl_req *) ifr;\r\nwlandevice_t *wlandev = dev->ml_priv;\r\nu8 *msgbuf;\r\nnetdev_dbg(dev, "rx'd ioctl, cmd=%d, len=%d\n", cmd, req->len);\r\n#ifdef SIOCETHTOOL\r\nif (cmd == SIOCETHTOOL) {\r\nresult =\r\np80211netdev_ethtool(wlandev, (void __user *)ifr->ifr_data);\r\ngoto bail;\r\n}\r\n#endif\r\nif (req->magic != P80211_IOCTL_MAGIC) {\r\nresult = -ENOSYS;\r\ngoto bail;\r\n}\r\nif (cmd == P80211_IFTEST) {\r\nresult = 0;\r\ngoto bail;\r\n} else if (cmd != P80211_IFREQ) {\r\nresult = -ENOSYS;\r\ngoto bail;\r\n}\r\nmsgbuf = kmalloc(req->len, GFP_KERNEL);\r\nif (msgbuf) {\r\nif (copy_from_user(msgbuf, (void __user *)req->data, req->len))\r\nresult = -EFAULT;\r\nelse\r\nresult = p80211req_dorequest(wlandev, msgbuf);\r\nif (result == 0) {\r\nif (copy_to_user\r\n((void __user *)req->data, msgbuf, req->len)) {\r\nresult = -EFAULT;\r\n}\r\n}\r\nkfree(msgbuf);\r\n} else {\r\nresult = -ENOMEM;\r\n}\r\nbail:\r\nreturn result;\r\n}\r\nstatic int p80211knetdev_set_mac_address(netdevice_t *dev, void *addr)\r\n{\r\nstruct sockaddr *new_addr = addr;\r\nstruct p80211msg_dot11req_mibset dot11req;\r\np80211item_unk392_t *mibattr;\r\np80211item_pstr6_t *macaddr;\r\np80211item_uint32_t *resultcode;\r\nint result;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nmibattr = &dot11req.mibattribute;\r\nmacaddr = (p80211item_pstr6_t *) &mibattr->data;\r\nresultcode = &dot11req.resultcode;\r\nmemset(&dot11req, 0, sizeof(struct p80211msg_dot11req_mibset));\r\ndot11req.msgcode = DIDmsg_dot11req_mibset;\r\ndot11req.msglen = sizeof(struct p80211msg_dot11req_mibset);\r\nmemcpy(dot11req.devname,\r\n((wlandevice_t *) dev->ml_priv)->name, WLAN_DEVNAMELEN_MAX - 1);\r\nmibattr->did = DIDmsg_dot11req_mibset_mibattribute;\r\nmibattr->status = P80211ENUM_msgitem_status_data_ok;\r\nmibattr->len = sizeof(mibattr->data);\r\nmacaddr->did = DIDmib_dot11mac_dot11OperationTable_dot11MACAddress;\r\nmacaddr->status = P80211ENUM_msgitem_status_data_ok;\r\nmacaddr->len = sizeof(macaddr->data);\r\nmacaddr->data.len = ETH_ALEN;\r\nmemcpy(&macaddr->data.data, new_addr->sa_data, ETH_ALEN);\r\nresultcode->did = DIDmsg_dot11req_mibset_resultcode;\r\nresultcode->status = P80211ENUM_msgitem_status_no_value;\r\nresultcode->len = sizeof(resultcode->data);\r\nresultcode->data = 0;\r\nresult = p80211req_dorequest(dev->ml_priv, (u8 *) &dot11req);\r\nif (result != 0 || resultcode->data != P80211ENUM_resultcode_success) {\r\nnetdev_err(dev, "Low-level driver failed dot11req_mibset(dot11MACAddress).\n");\r\nresult = -EADDRNOTAVAIL;\r\n} else {\r\nmemcpy(dev->dev_addr, new_addr->sa_data, dev->addr_len);\r\n}\r\nreturn result;\r\n}\r\nstatic int wlan_change_mtu(netdevice_t *dev, int new_mtu)\r\n{\r\nif ((new_mtu < 68) || (new_mtu > (2312 - 20 - 8)))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nint wlan_setup(wlandevice_t *wlandev, struct device *physdev)\r\n{\r\nint result = 0;\r\nnetdevice_t *netdev;\r\nstruct wiphy *wiphy;\r\nstruct wireless_dev *wdev;\r\nwlandev->state = WLAN_DEVICE_CLOSED;\r\nwlandev->ethconv = WLAN_ETHCONV_8021h;\r\nwlandev->macmode = WLAN_MACMODE_NONE;\r\nskb_queue_head_init(&wlandev->nsd_rxq);\r\ntasklet_init(&wlandev->rx_bh,\r\np80211netdev_rx_bh, (unsigned long)wlandev);\r\nwiphy = wlan_create_wiphy(physdev, wlandev);\r\nif (!wiphy) {\r\ndev_err(physdev, "Failed to alloc wiphy.\n");\r\nreturn 1;\r\n}\r\nnetdev = alloc_netdev(sizeof(struct wireless_dev), "wlan%d",\r\nNET_NAME_UNKNOWN, ether_setup);\r\nif (!netdev) {\r\ndev_err(physdev, "Failed to alloc netdev.\n");\r\nwlan_free_wiphy(wiphy);\r\nresult = 1;\r\n} else {\r\nwlandev->netdev = netdev;\r\nnetdev->ml_priv = wlandev;\r\nnetdev->netdev_ops = &p80211_netdev_ops;\r\nwdev = netdev_priv(netdev);\r\nwdev->wiphy = wiphy;\r\nwdev->iftype = NL80211_IFTYPE_STATION;\r\nnetdev->ieee80211_ptr = wdev;\r\nnetif_stop_queue(netdev);\r\nnetif_carrier_off(netdev);\r\n}\r\nreturn result;\r\n}\r\nvoid wlan_unsetup(wlandevice_t *wlandev)\r\n{\r\nstruct wireless_dev *wdev;\r\ntasklet_kill(&wlandev->rx_bh);\r\nif (wlandev->netdev) {\r\nwdev = netdev_priv(wlandev->netdev);\r\nif (wdev->wiphy)\r\nwlan_free_wiphy(wdev->wiphy);\r\nfree_netdev(wlandev->netdev);\r\nwlandev->netdev = NULL;\r\n}\r\n}\r\nint register_wlandev(wlandevice_t *wlandev)\r\n{\r\nreturn register_netdev(wlandev->netdev);\r\n}\r\nint unregister_wlandev(wlandevice_t *wlandev)\r\n{\r\nstruct sk_buff *skb;\r\nunregister_netdev(wlandev->netdev);\r\nwhile ((skb = skb_dequeue(&wlandev->nsd_rxq)))\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nvoid p80211netdev_hwremoved(wlandevice_t *wlandev)\r\n{\r\nwlandev->hwremoved = 1;\r\nif (wlandev->state == WLAN_DEVICE_OPEN)\r\nnetif_stop_queue(wlandev->netdev);\r\nnetif_device_detach(wlandev->netdev);\r\n}\r\nstatic int p80211_rx_typedrop(wlandevice_t *wlandev, u16 fc)\r\n{\r\nu16 ftype;\r\nu16 fstype;\r\nint drop = 0;\r\nftype = WLAN_GET_FC_FTYPE(fc);\r\nfstype = WLAN_GET_FC_FSTYPE(fc);\r\n#if 0\r\nnetdev_dbg(wlandev->netdev, "rx_typedrop : ftype=%d fstype=%d.\n",\r\nftype, fstype);\r\n#endif\r\nswitch (ftype) {\r\ncase WLAN_FTYPE_MGMT:\r\nif ((wlandev->netdev->flags & IFF_PROMISC) ||\r\n(wlandev->netdev->flags & IFF_ALLMULTI)) {\r\ndrop = 1;\r\nbreak;\r\n}\r\nnetdev_dbg(wlandev->netdev, "rx'd mgmt:\n");\r\nwlandev->rx.mgmt++;\r\nswitch (fstype) {\r\ncase WLAN_FSTYPE_ASSOCREQ:\r\nwlandev->rx.assocreq++;\r\nbreak;\r\ncase WLAN_FSTYPE_ASSOCRESP:\r\nwlandev->rx.assocresp++;\r\nbreak;\r\ncase WLAN_FSTYPE_REASSOCREQ:\r\nwlandev->rx.reassocreq++;\r\nbreak;\r\ncase WLAN_FSTYPE_REASSOCRESP:\r\nwlandev->rx.reassocresp++;\r\nbreak;\r\ncase WLAN_FSTYPE_PROBEREQ:\r\nwlandev->rx.probereq++;\r\nbreak;\r\ncase WLAN_FSTYPE_PROBERESP:\r\nwlandev->rx.proberesp++;\r\nbreak;\r\ncase WLAN_FSTYPE_BEACON:\r\nwlandev->rx.beacon++;\r\nbreak;\r\ncase WLAN_FSTYPE_ATIM:\r\nwlandev->rx.atim++;\r\nbreak;\r\ncase WLAN_FSTYPE_DISASSOC:\r\nwlandev->rx.disassoc++;\r\nbreak;\r\ncase WLAN_FSTYPE_AUTHEN:\r\nwlandev->rx.authen++;\r\nbreak;\r\ncase WLAN_FSTYPE_DEAUTHEN:\r\nwlandev->rx.deauthen++;\r\nbreak;\r\ndefault:\r\nwlandev->rx.mgmt_unknown++;\r\nbreak;\r\n}\r\ndrop = 2;\r\nbreak;\r\ncase WLAN_FTYPE_CTL:\r\nif ((wlandev->netdev->flags & IFF_PROMISC) ||\r\n(wlandev->netdev->flags & IFF_ALLMULTI)) {\r\ndrop = 1;\r\nbreak;\r\n}\r\nnetdev_dbg(wlandev->netdev, "rx'd ctl:\n");\r\nwlandev->rx.ctl++;\r\nswitch (fstype) {\r\ncase WLAN_FSTYPE_PSPOLL:\r\nwlandev->rx.pspoll++;\r\nbreak;\r\ncase WLAN_FSTYPE_RTS:\r\nwlandev->rx.rts++;\r\nbreak;\r\ncase WLAN_FSTYPE_CTS:\r\nwlandev->rx.cts++;\r\nbreak;\r\ncase WLAN_FSTYPE_ACK:\r\nwlandev->rx.ack++;\r\nbreak;\r\ncase WLAN_FSTYPE_CFEND:\r\nwlandev->rx.cfend++;\r\nbreak;\r\ncase WLAN_FSTYPE_CFENDCFACK:\r\nwlandev->rx.cfendcfack++;\r\nbreak;\r\ndefault:\r\nwlandev->rx.ctl_unknown++;\r\nbreak;\r\n}\r\ndrop = 2;\r\nbreak;\r\ncase WLAN_FTYPE_DATA:\r\nwlandev->rx.data++;\r\nswitch (fstype) {\r\ncase WLAN_FSTYPE_DATAONLY:\r\nwlandev->rx.dataonly++;\r\nbreak;\r\ncase WLAN_FSTYPE_DATA_CFACK:\r\nwlandev->rx.data_cfack++;\r\nbreak;\r\ncase WLAN_FSTYPE_DATA_CFPOLL:\r\nwlandev->rx.data_cfpoll++;\r\nbreak;\r\ncase WLAN_FSTYPE_DATA_CFACK_CFPOLL:\r\nwlandev->rx.data__cfack_cfpoll++;\r\nbreak;\r\ncase WLAN_FSTYPE_NULL:\r\nnetdev_dbg(wlandev->netdev, "rx'd data:null\n");\r\nwlandev->rx.null++;\r\nbreak;\r\ncase WLAN_FSTYPE_CFACK:\r\nnetdev_dbg(wlandev->netdev, "rx'd data:cfack\n");\r\nwlandev->rx.cfack++;\r\nbreak;\r\ncase WLAN_FSTYPE_CFPOLL:\r\nnetdev_dbg(wlandev->netdev, "rx'd data:cfpoll\n");\r\nwlandev->rx.cfpoll++;\r\nbreak;\r\ncase WLAN_FSTYPE_CFACK_CFPOLL:\r\nnetdev_dbg(wlandev->netdev, "rx'd data:cfack_cfpoll\n");\r\nwlandev->rx.cfack_cfpoll++;\r\nbreak;\r\ndefault:\r\nwlandev->rx.data_unknown++;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn drop;\r\n}\r\nstatic void p80211knetdev_tx_timeout(netdevice_t *netdev)\r\n{\r\nwlandevice_t *wlandev = netdev->ml_priv;\r\nif (wlandev->tx_timeout) {\r\nwlandev->tx_timeout(wlandev);\r\n} else {\r\nnetdev_warn(netdev, "Implement tx_timeout for %s\n",\r\nwlandev->nsdname);\r\nnetif_wake_queue(wlandev->netdev);\r\n}\r\n}
