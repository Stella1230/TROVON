static void i2c_lpc2k_reset(struct lpc2k_i2c *i2c)\r\n{\r\nwritel(LPC24XX_CLEAR_ALL, i2c->base + LPC24XX_I2CONCLR);\r\nwritel(0, i2c->base + LPC24XX_I2ADDR);\r\nwritel(LPC24XX_I2EN, i2c->base + LPC24XX_I2CONSET);\r\n}\r\nstatic int i2c_lpc2k_clear_arb(struct lpc2k_i2c *i2c)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nwritel(LPC24XX_STO, i2c->base + LPC24XX_I2CONSET);\r\nwhile (readl(i2c->base + LPC24XX_I2STAT) != M_I2C_IDLE) {\r\nif (time_after(jiffies, timeout)) {\r\ni2c_lpc2k_reset(i2c);\r\nreturn -EBUSY;\r\n}\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic void i2c_lpc2k_pump_msg(struct lpc2k_i2c *i2c)\r\n{\r\nunsigned char data;\r\nu32 status;\r\nstatus = readl(i2c->base + LPC24XX_I2STAT);\r\nswitch (status) {\r\ncase M_START:\r\ncase M_REPSTART:\r\ndata = i2c_8bit_addr_from_msg(i2c->msg);\r\nwritel(data, i2c->base + LPC24XX_I2DAT);\r\nwritel(LPC24XX_STA, i2c->base + LPC24XX_I2CONCLR);\r\nbreak;\r\ncase MX_ADDR_W_ACK:\r\ncase MX_DATA_W_ACK:\r\nif (i2c->msg_idx < i2c->msg->len) {\r\nwritel(i2c->msg->buf[i2c->msg_idx],\r\ni2c->base + LPC24XX_I2DAT);\r\n} else if (i2c->is_last) {\r\nwritel(LPC24XX_STO_AA, i2c->base + LPC24XX_I2CONSET);\r\nwritel(LPC24XX_SI, i2c->base + LPC24XX_I2CONCLR);\r\ni2c->msg_status = 0;\r\ndisable_irq_nosync(i2c->irq);\r\n} else {\r\ni2c->msg_status = 0;\r\ndisable_irq_nosync(i2c->irq);\r\n}\r\ni2c->msg_idx++;\r\nbreak;\r\ncase MR_ADDR_R_ACK:\r\nif (i2c->msg->len == 1) {\r\nwritel(LPC24XX_AA, i2c->base + LPC24XX_I2CONCLR);\r\n} else {\r\nwritel(LPC24XX_AA, i2c->base + LPC24XX_I2CONSET);\r\n}\r\nwritel(LPC24XX_STA, i2c->base + LPC24XX_I2CONCLR);\r\nbreak;\r\ncase MR_DATA_R_NACK:\r\ncase MR_DATA_R_ACK:\r\nif (i2c->msg_idx < i2c->msg->len) {\r\ni2c->msg->buf[i2c->msg_idx] =\r\nreadl(i2c->base + LPC24XX_I2DAT);\r\n}\r\nif (i2c->msg_idx >= i2c->msg->len - 1 && i2c->is_last) {\r\nwritel(LPC24XX_STO_AA, i2c->base + LPC24XX_I2CONSET);\r\nwritel(LPC24XX_SI, i2c->base + LPC24XX_I2CONCLR);\r\ni2c->msg_status = 0;\r\n}\r\nif (i2c->msg_idx >= i2c->msg->len - 1) {\r\ni2c->msg_status = 0;\r\ndisable_irq_nosync(i2c->irq);\r\n}\r\nif (i2c->msg_idx >= i2c->msg->len - 2) {\r\nwritel(LPC24XX_AA, i2c->base + LPC24XX_I2CONCLR);\r\n} else {\r\nwritel(LPC24XX_AA, i2c->base + LPC24XX_I2CONSET);\r\n}\r\nwritel(LPC24XX_STA, i2c->base + LPC24XX_I2CONCLR);\r\ni2c->msg_idx++;\r\nbreak;\r\ncase MX_ADDR_W_NACK:\r\ncase MX_DATA_W_NACK:\r\ncase MR_ADDR_R_NACK:\r\nwritel(LPC24XX_STO_AA, i2c->base + LPC24XX_I2CONSET);\r\ni2c->msg_status = -ENXIO;\r\ndisable_irq_nosync(i2c->irq);\r\nbreak;\r\ncase M_DATA_ARB_LOST:\r\ni2c->msg_status = -EAGAIN;\r\nwritel(LPC24XX_STA | LPC24XX_STO, i2c->base + LPC24XX_I2CONCLR);\r\ndisable_irq_nosync(i2c->irq);\r\nbreak;\r\ndefault:\r\ni2c->msg_status = -EIO;\r\ndisable_irq_nosync(i2c->irq);\r\nbreak;\r\n}\r\nif (i2c->msg_status != -EBUSY)\r\nwake_up(&i2c->wait);\r\nif (i2c->msg_status != 0)\r\nwritel(LPC24XX_SI, i2c->base + LPC24XX_I2CONCLR);\r\n}\r\nstatic int lpc2k_process_msg(struct lpc2k_i2c *i2c, int msgidx)\r\n{\r\nif (!msgidx) {\r\nwritel(LPC24XX_STA, i2c->base + LPC24XX_I2CONSET);\r\n} else {\r\nif (unlikely(i2c->msg->flags & I2C_M_NOSTART)) {\r\nWARN_ON(i2c->msg->len == 0);\r\nif (!(i2c->msg->flags & I2C_M_RD)) {\r\nwritel(i2c->msg->buf[0],\r\ni2c->base + LPC24XX_I2DAT);\r\ni2c->msg_idx++;\r\n}\r\n} else {\r\nwritel(LPC24XX_STA, i2c->base + LPC24XX_I2CONSET);\r\n}\r\nwritel(LPC24XX_SI, i2c->base + LPC24XX_I2CONCLR);\r\n}\r\nenable_irq(i2c->irq);\r\nif (wait_event_timeout(i2c->wait, i2c->msg_status != -EBUSY,\r\nmsecs_to_jiffies(1000)) == 0) {\r\ndisable_irq_nosync(i2c->irq);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn i2c->msg_status;\r\n}\r\nstatic int i2c_lpc2k_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\r\nint msg_num)\r\n{\r\nstruct lpc2k_i2c *i2c = i2c_get_adapdata(adap);\r\nint ret, i;\r\nu32 stat;\r\nstat = readl(i2c->base + LPC24XX_I2STAT);\r\nif (stat != M_I2C_IDLE) {\r\nreturn i2c_lpc2k_clear_arb(i2c);\r\n}\r\nfor (i = 0; i < msg_num; i++) {\r\ni2c->msg = &msgs[i];\r\ni2c->msg_idx = 0;\r\ni2c->msg_status = -EBUSY;\r\ni2c->is_last = (i == (msg_num - 1));\r\nret = lpc2k_process_msg(i2c, i);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn msg_num;\r\n}\r\nstatic irqreturn_t i2c_lpc2k_handler(int irq, void *dev_id)\r\n{\r\nstruct lpc2k_i2c *i2c = dev_id;\r\nif (readl(i2c->base + LPC24XX_I2CONSET) & LPC24XX_SI) {\r\ni2c_lpc2k_pump_msg(i2c);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic u32 i2c_lpc2k_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int i2c_lpc2k_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc2k_i2c *i2c;\r\nstruct resource *res;\r\nu32 bus_clk_rate;\r\nu32 scl_high;\r\nu32 clkrate;\r\nint ret;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c->base))\r\nreturn PTR_ERR(i2c->base);\r\ni2c->irq = platform_get_irq(pdev, 0);\r\nif (i2c->irq < 0) {\r\ndev_err(&pdev->dev, "can't get interrupt resource\n");\r\nreturn i2c->irq;\r\n}\r\ninit_waitqueue_head(&i2c->wait);\r\ni2c->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2c->clk)) {\r\ndev_err(&pdev->dev, "error getting clock\n");\r\nreturn PTR_ERR(i2c->clk);\r\n}\r\nret = clk_prepare_enable(i2c->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to enable clock.\n");\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, i2c->irq, i2c_lpc2k_handler, 0,\r\ndev_name(&pdev->dev), i2c);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can't request interrupt.\n");\r\ngoto fail_clk;\r\n}\r\ndisable_irq_nosync(i2c->irq);\r\ni2c_lpc2k_reset(i2c);\r\nret = of_property_read_u32(pdev->dev.of_node, "clock-frequency",\r\n&bus_clk_rate);\r\nif (ret)\r\nbus_clk_rate = 100000;\r\nclkrate = clk_get_rate(i2c->clk);\r\nif (clkrate == 0) {\r\ndev_err(&pdev->dev, "can't get I2C base clock\n");\r\nret = -EINVAL;\r\ngoto fail_clk;\r\n}\r\nclkrate = clkrate / bus_clk_rate;\r\nif (bus_clk_rate <= 100000)\r\nscl_high = (clkrate * I2C_STD_MODE_DUTY) / 100;\r\nelse if (bus_clk_rate <= 400000)\r\nscl_high = (clkrate * I2C_FAST_MODE_DUTY) / 100;\r\nelse\r\nscl_high = (clkrate * I2C_FAST_MODE_PLUS_DUTY) / 100;\r\nwritel(scl_high, i2c->base + LPC24XX_I2SCLH);\r\nwritel(clkrate - scl_high, i2c->base + LPC24XX_I2SCLL);\r\nplatform_set_drvdata(pdev, i2c);\r\ni2c_set_adapdata(&i2c->adap, i2c);\r\ni2c->adap.owner = THIS_MODULE;\r\nstrlcpy(i2c->adap.name, "LPC2K I2C adapter", sizeof(i2c->adap.name));\r\ni2c->adap.algo = &i2c_lpc2k_algorithm;\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->adap.dev.of_node = pdev->dev.of_node;\r\nret = i2c_add_adapter(&i2c->adap);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add adapter!\n");\r\ngoto fail_clk;\r\n}\r\ndev_info(&pdev->dev, "LPC2K I2C adapter\n");\r\nreturn 0;\r\nfail_clk:\r\nclk_disable_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\nstatic int i2c_lpc2k_remove(struct platform_device *dev)\r\n{\r\nstruct lpc2k_i2c *i2c = platform_get_drvdata(dev);\r\ni2c_del_adapter(&i2c->adap);\r\nclk_disable_unprepare(i2c->clk);\r\nreturn 0;\r\n}\r\nstatic int i2c_lpc2k_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct lpc2k_i2c *i2c = platform_get_drvdata(pdev);\r\nclk_disable(i2c->clk);\r\nreturn 0;\r\n}\r\nstatic int i2c_lpc2k_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct lpc2k_i2c *i2c = platform_get_drvdata(pdev);\r\nclk_enable(i2c->clk);\r\ni2c_lpc2k_reset(i2c);\r\nreturn 0;\r\n}
