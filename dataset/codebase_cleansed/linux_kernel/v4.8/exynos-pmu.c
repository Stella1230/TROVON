void pmu_raw_writel(u32 val, u32 offset)\r\n{\r\nwritel_relaxed(val, pmu_base_addr + offset);\r\n}\r\nu32 pmu_raw_readl(u32 offset)\r\n{\r\nreturn readl_relaxed(pmu_base_addr + offset);\r\n}\r\nvoid exynos_sys_powerdown_conf(enum sys_powerdown mode)\r\n{\r\nunsigned int i;\r\nconst struct exynos_pmu_data *pmu_data;\r\nif (!pmu_context)\r\nreturn;\r\npmu_data = pmu_context->pmu_data;\r\nif (pmu_data->powerdown_conf)\r\npmu_data->powerdown_conf(mode);\r\nif (pmu_data->pmu_config) {\r\nfor (i = 0; (pmu_data->pmu_config[i].offset != PMU_TABLE_END); i++)\r\npmu_raw_writel(pmu_data->pmu_config[i].val[mode],\r\npmu_data->pmu_config[i].offset);\r\n}\r\nif (pmu_data->powerdown_conf_extra)\r\npmu_data->powerdown_conf_extra(mode);\r\nif (pmu_data->pmu_config_extra) {\r\nfor (i = 0; pmu_data->pmu_config_extra[i].offset != PMU_TABLE_END; i++)\r\npmu_raw_writel(pmu_data->pmu_config_extra[i].val[mode],\r\npmu_data->pmu_config_extra[i].offset);\r\n}\r\n}\r\nstatic int exynos_pmu_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npmu_base_addr = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pmu_base_addr))\r\nreturn PTR_ERR(pmu_base_addr);\r\npmu_context = devm_kzalloc(&pdev->dev,\r\nsizeof(struct exynos_pmu_context),\r\nGFP_KERNEL);\r\nif (!pmu_context) {\r\ndev_err(dev, "Cannot allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\npmu_context->dev = dev;\r\nmatch = of_match_node(exynos_pmu_of_device_ids, dev->of_node);\r\npmu_context->pmu_data = match->data;\r\nif (pmu_context->pmu_data->pmu_init)\r\npmu_context->pmu_data->pmu_init();\r\nplatform_set_drvdata(pdev, pmu_context);\r\ndev_dbg(dev, "Exynos PMU Driver probe done\n");\r\nreturn 0;\r\n}\r\nstatic int __init exynos_pmu_init(void)\r\n{\r\nreturn platform_driver_register(&exynos_pmu_driver);\r\n}
