void fbtft_dbg_hex(const struct device *dev, int groupsize,\r\nvoid *buf, size_t len, const char *fmt, ...)\r\n{\r\nva_list args;\r\nstatic char textbuf[512];\r\nchar *text = textbuf;\r\nsize_t text_len;\r\nva_start(args, fmt);\r\ntext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\r\nva_end(args);\r\nhex_dump_to_buffer(buf, len, 32, groupsize, text + text_len,\r\n512 - text_len, false);\r\nif (len > 32)\r\ndev_info(dev, "%s ...\n", text);\r\nelse\r\ndev_info(dev, "%s\n", text);\r\n}\r\nstatic unsigned long fbtft_request_gpios_match(struct fbtft_par *par,\r\nconst struct fbtft_gpio *gpio)\r\n{\r\nint ret;\r\nlong val;\r\nfbtft_par_dbg(DEBUG_REQUEST_GPIOS_MATCH, par, "%s('%s')\n",\r\n__func__, gpio->name);\r\nif (strcasecmp(gpio->name, "reset") == 0) {\r\npar->gpio.reset = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_HIGH;\r\n} else if (strcasecmp(gpio->name, "dc") == 0) {\r\npar->gpio.dc = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_LOW;\r\n} else if (strcasecmp(gpio->name, "cs") == 0) {\r\npar->gpio.cs = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_HIGH;\r\n} else if (strcasecmp(gpio->name, "wr") == 0) {\r\npar->gpio.wr = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_HIGH;\r\n} else if (strcasecmp(gpio->name, "rd") == 0) {\r\npar->gpio.rd = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_HIGH;\r\n} else if (strcasecmp(gpio->name, "latch") == 0) {\r\npar->gpio.latch = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_LOW;\r\n} else if (gpio->name[0] == 'd' && gpio->name[1] == 'b') {\r\nret = kstrtol(&gpio->name[2], 10, &val);\r\nif (ret == 0 && val < 16) {\r\npar->gpio.db[val] = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_LOW;\r\n}\r\n} else if (strcasecmp(gpio->name, "led") == 0) {\r\npar->gpio.led[0] = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_LOW;\r\n} else if (strcasecmp(gpio->name, "led_") == 0) {\r\npar->gpio.led[0] = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_HIGH;\r\n}\r\nreturn FBTFT_GPIO_NO_MATCH;\r\n}\r\nstatic int fbtft_request_gpios(struct fbtft_par *par)\r\n{\r\nstruct fbtft_platform_data *pdata = par->pdata;\r\nconst struct fbtft_gpio *gpio;\r\nunsigned long flags;\r\nint ret;\r\nif (!(pdata && pdata->gpios))\r\nreturn 0;\r\ngpio = pdata->gpios;\r\nwhile (gpio->name[0]) {\r\nflags = FBTFT_GPIO_NO_MATCH;\r\nif (par->fbtftops.request_gpios_match)\r\nflags = par->fbtftops.request_gpios_match(par, gpio);\r\nif (flags == FBTFT_GPIO_NO_MATCH)\r\nflags = fbtft_request_gpios_match(par, gpio);\r\nif (flags != FBTFT_GPIO_NO_MATCH) {\r\nret = devm_gpio_request_one(par->info->device,\r\ngpio->gpio, flags,\r\npar->info->device->driver->name);\r\nif (ret < 0) {\r\ndev_err(par->info->device,\r\n"%s: gpio_request_one('%s'=%d) failed with %d\n",\r\n__func__, gpio->name,\r\ngpio->gpio, ret);\r\nreturn ret;\r\n}\r\nfbtft_par_dbg(DEBUG_REQUEST_GPIOS, par,\r\n"%s: '%s' = GPIO%d\n",\r\n__func__, gpio->name, gpio->gpio);\r\n}\r\ngpio++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fbtft_request_one_gpio(struct fbtft_par *par,\r\nconst char *name, int index, int *gpiop)\r\n{\r\nstruct device *dev = par->info->device;\r\nstruct device_node *node = dev->of_node;\r\nint gpio, flags, ret = 0;\r\nenum of_gpio_flags of_flags;\r\nif (of_find_property(node, name, NULL)) {\r\ngpio = of_get_named_gpio_flags(node, name, index, &of_flags);\r\nif (gpio == -ENOENT)\r\nreturn 0;\r\nif (gpio == -EPROBE_DEFER)\r\nreturn gpio;\r\nif (gpio < 0) {\r\ndev_err(dev,\r\n"failed to get '%s' from DT\n", name);\r\nreturn gpio;\r\n}\r\nflags = (of_flags & OF_GPIO_ACTIVE_LOW) ? GPIOF_OUT_INIT_LOW :\r\nGPIOF_OUT_INIT_HIGH;\r\nret = devm_gpio_request_one(dev, gpio, flags,\r\ndev->driver->name);\r\nif (ret) {\r\ndev_err(dev,\r\n"gpio_request_one('%s'=%d) failed with %d\n",\r\nname, gpio, ret);\r\nreturn ret;\r\n}\r\nif (gpiop)\r\n*gpiop = gpio;\r\nfbtft_par_dbg(DEBUG_REQUEST_GPIOS, par, "%s: '%s' = GPIO%d\n",\r\n__func__, name, gpio);\r\n}\r\nreturn ret;\r\n}\r\nstatic int fbtft_request_gpios_dt(struct fbtft_par *par)\r\n{\r\nint i;\r\nint ret;\r\nif (!par->info->device->of_node)\r\nreturn -EINVAL;\r\nret = fbtft_request_one_gpio(par, "reset-gpios", 0, &par->gpio.reset);\r\nif (ret)\r\nreturn ret;\r\nret = fbtft_request_one_gpio(par, "dc-gpios", 0, &par->gpio.dc);\r\nif (ret)\r\nreturn ret;\r\nret = fbtft_request_one_gpio(par, "rd-gpios", 0, &par->gpio.rd);\r\nif (ret)\r\nreturn ret;\r\nret = fbtft_request_one_gpio(par, "wr-gpios", 0, &par->gpio.wr);\r\nif (ret)\r\nreturn ret;\r\nret = fbtft_request_one_gpio(par, "cs-gpios", 0, &par->gpio.cs);\r\nif (ret)\r\nreturn ret;\r\nret = fbtft_request_one_gpio(par, "latch-gpios", 0, &par->gpio.latch);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < 16; i++) {\r\nret = fbtft_request_one_gpio(par, "db-gpios", i,\r\n&par->gpio.db[i]);\r\nif (ret)\r\nreturn ret;\r\nret = fbtft_request_one_gpio(par, "led-gpios", i,\r\n&par->gpio.led[i]);\r\nif (ret)\r\nreturn ret;\r\nret = fbtft_request_one_gpio(par, "aux-gpios", i,\r\n&par->gpio.aux[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fbtft_backlight_update_status(struct backlight_device *bd)\r\n{\r\nstruct fbtft_par *par = bl_get_data(bd);\r\nbool polarity = !!(bd->props.state & BL_CORE_DRIVER1);\r\nfbtft_par_dbg(DEBUG_BACKLIGHT, par,\r\n"%s: polarity=%d, power=%d, fb_blank=%d\n",\r\n__func__, polarity, bd->props.power, bd->props.fb_blank);\r\nif ((bd->props.power == FB_BLANK_UNBLANK) && (bd->props.fb_blank == FB_BLANK_UNBLANK))\r\ngpio_set_value(par->gpio.led[0], polarity);\r\nelse\r\ngpio_set_value(par->gpio.led[0], !polarity);\r\nreturn 0;\r\n}\r\nstatic int fbtft_backlight_get_brightness(struct backlight_device *bd)\r\n{\r\nreturn bd->props.brightness;\r\n}\r\nvoid fbtft_unregister_backlight(struct fbtft_par *par)\r\n{\r\nif (par->info->bl_dev) {\r\npar->info->bl_dev->props.power = FB_BLANK_POWERDOWN;\r\nbacklight_update_status(par->info->bl_dev);\r\nbacklight_device_unregister(par->info->bl_dev);\r\npar->info->bl_dev = NULL;\r\n}\r\n}\r\nvoid fbtft_register_backlight(struct fbtft_par *par)\r\n{\r\nstruct backlight_device *bd;\r\nstruct backlight_properties bl_props = { 0, };\r\nif (par->gpio.led[0] == -1) {\r\nfbtft_par_dbg(DEBUG_BACKLIGHT, par,\r\n"%s(): led pin not set, exiting.\n", __func__);\r\nreturn;\r\n}\r\nbl_props.type = BACKLIGHT_RAW;\r\nbl_props.power = FB_BLANK_POWERDOWN;\r\nif (!gpio_get_value(par->gpio.led[0]))\r\nbl_props.state |= BL_CORE_DRIVER1;\r\nbd = backlight_device_register(dev_driver_string(par->info->device),\r\npar->info->device, par, &fbtft_bl_ops, &bl_props);\r\nif (IS_ERR(bd)) {\r\ndev_err(par->info->device,\r\n"cannot register backlight device (%ld)\n",\r\nPTR_ERR(bd));\r\nreturn;\r\n}\r\npar->info->bl_dev = bd;\r\nif (!par->fbtftops.unregister_backlight)\r\npar->fbtftops.unregister_backlight = fbtft_unregister_backlight;\r\n}\r\nvoid fbtft_register_backlight(struct fbtft_par *par) { }\r\nvoid fbtft_unregister_backlight(struct fbtft_par *par) { }\r\nstatic void fbtft_set_addr_win(struct fbtft_par *par, int xs, int ys, int xe,\r\nint ye)\r\n{\r\nwrite_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,\r\n(xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);\r\nwrite_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,\r\n(ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);\r\nwrite_reg(par, MIPI_DCS_WRITE_MEMORY_START);\r\n}\r\nstatic void fbtft_reset(struct fbtft_par *par)\r\n{\r\nif (par->gpio.reset == -1)\r\nreturn;\r\nfbtft_par_dbg(DEBUG_RESET, par, "%s()\n", __func__);\r\ngpio_set_value(par->gpio.reset, 0);\r\nudelay(20);\r\ngpio_set_value(par->gpio.reset, 1);\r\nmdelay(120);\r\n}\r\nstatic void fbtft_update_display(struct fbtft_par *par, unsigned start_line,\r\nunsigned end_line)\r\n{\r\nsize_t offset, len;\r\nktime_t ts_start, ts_end;\r\nlong fps, throughput;\r\nbool timeit = false;\r\nint ret = 0;\r\nif (unlikely(par->debug & (DEBUG_TIME_FIRST_UPDATE | DEBUG_TIME_EACH_UPDATE))) {\r\nif ((par->debug & DEBUG_TIME_EACH_UPDATE) ||\r\n((par->debug & DEBUG_TIME_FIRST_UPDATE) && !par->first_update_done)) {\r\nts_start = ktime_get();\r\ntimeit = true;\r\n}\r\n}\r\nif (start_line > end_line) {\r\ndev_warn(par->info->device,\r\n"%s: start_line=%u is larger than end_line=%u. Shouldn't happen, will do full display update\n",\r\n__func__, start_line, end_line);\r\nstart_line = 0;\r\nend_line = par->info->var.yres - 1;\r\n}\r\nif (start_line > par->info->var.yres - 1 || end_line > par->info->var.yres - 1) {\r\ndev_warn(par->info->device,\r\n"%s: start_line=%u or end_line=%u is larger than max=%d. Shouldn't happen, will do full display update\n",\r\n__func__, start_line, end_line, par->info->var.yres - 1);\r\nstart_line = 0;\r\nend_line = par->info->var.yres - 1;\r\n}\r\nfbtft_par_dbg(DEBUG_UPDATE_DISPLAY, par, "%s(start_line=%u, end_line=%u)\n",\r\n__func__, start_line, end_line);\r\nif (par->fbtftops.set_addr_win)\r\npar->fbtftops.set_addr_win(par, 0, start_line,\r\npar->info->var.xres - 1, end_line);\r\noffset = start_line * par->info->fix.line_length;\r\nlen = (end_line - start_line + 1) * par->info->fix.line_length;\r\nret = par->fbtftops.write_vmem(par, offset, len);\r\nif (ret < 0)\r\ndev_err(par->info->device,\r\n"%s: write_vmem failed to update display buffer\n",\r\n__func__);\r\nif (unlikely(timeit)) {\r\nts_end = ktime_get();\r\nif (ktime_to_ns(par->update_time))\r\npar->update_time = ts_start;\r\npar->update_time = ts_start;\r\nfps = ktime_us_delta(ts_start, par->update_time);\r\nfps = fps ? 1000000 / fps : 0;\r\nthroughput = ktime_us_delta(ts_end, ts_start);\r\nthroughput = throughput ? (len * 1000) / throughput : 0;\r\nthroughput = throughput * 1000 / 1024;\r\ndev_info(par->info->device,\r\n"Display update: %ld kB/s, fps=%ld\n",\r\nthroughput, fps);\r\npar->first_update_done = true;\r\n}\r\n}\r\nstatic void fbtft_mkdirty(struct fb_info *info, int y, int height)\r\n{\r\nstruct fbtft_par *par = info->par;\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nif (y == -1) {\r\ny = 0;\r\nheight = info->var.yres - 1;\r\n}\r\nspin_lock(&par->dirty_lock);\r\nif (y < par->dirty_lines_start)\r\npar->dirty_lines_start = y;\r\nif (y + height - 1 > par->dirty_lines_end)\r\npar->dirty_lines_end = y + height - 1;\r\nspin_unlock(&par->dirty_lock);\r\nschedule_delayed_work(&info->deferred_work, fbdefio->delay);\r\n}\r\nstatic void fbtft_deferred_io(struct fb_info *info, struct list_head *pagelist)\r\n{\r\nstruct fbtft_par *par = info->par;\r\nunsigned dirty_lines_start, dirty_lines_end;\r\nstruct page *page;\r\nunsigned long index;\r\nunsigned y_low = 0, y_high = 0;\r\nint count = 0;\r\nspin_lock(&par->dirty_lock);\r\ndirty_lines_start = par->dirty_lines_start;\r\ndirty_lines_end = par->dirty_lines_end;\r\npar->dirty_lines_start = par->info->var.yres - 1;\r\npar->dirty_lines_end = 0;\r\nspin_unlock(&par->dirty_lock);\r\nlist_for_each_entry(page, pagelist, lru) {\r\ncount++;\r\nindex = page->index << PAGE_SHIFT;\r\ny_low = index / info->fix.line_length;\r\ny_high = (index + PAGE_SIZE - 1) / info->fix.line_length;\r\ndev_dbg(info->device,\r\n"page->index=%lu y_low=%d y_high=%d\n",\r\npage->index, y_low, y_high);\r\nif (y_high > info->var.yres - 1)\r\ny_high = info->var.yres - 1;\r\nif (y_low < dirty_lines_start)\r\ndirty_lines_start = y_low;\r\nif (y_high > dirty_lines_end)\r\ndirty_lines_end = y_high;\r\n}\r\npar->fbtftops.update_display(info->par,\r\ndirty_lines_start, dirty_lines_end);\r\n}\r\nstatic void fbtft_fb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct fbtft_par *par = info->par;\r\ndev_dbg(info->dev,\r\n"%s: dx=%d, dy=%d, width=%d, height=%d\n",\r\n__func__, rect->dx, rect->dy, rect->width, rect->height);\r\nsys_fillrect(info, rect);\r\npar->fbtftops.mkdirty(info, rect->dy, rect->height);\r\n}\r\nstatic void fbtft_fb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct fbtft_par *par = info->par;\r\ndev_dbg(info->dev,\r\n"%s: dx=%d, dy=%d, width=%d, height=%d\n",\r\n__func__, area->dx, area->dy, area->width, area->height);\r\nsys_copyarea(info, area);\r\npar->fbtftops.mkdirty(info, area->dy, area->height);\r\n}\r\nstatic void fbtft_fb_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct fbtft_par *par = info->par;\r\ndev_dbg(info->dev,\r\n"%s: dx=%d, dy=%d, width=%d, height=%d\n",\r\n__func__, image->dx, image->dy, image->width, image->height);\r\nsys_imageblit(info, image);\r\npar->fbtftops.mkdirty(info, image->dy, image->height);\r\n}\r\nstatic ssize_t fbtft_fb_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct fbtft_par *par = info->par;\r\nssize_t res;\r\ndev_dbg(info->dev,\r\n"%s: count=%zd, ppos=%llu\n", __func__, count, *ppos);\r\nres = fb_sys_write(info, buf, count, ppos);\r\npar->fbtftops.mkdirty(info, -1, 0);\r\nreturn res;\r\n}\r\nstatic unsigned int chan_to_field(unsigned chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int fbtft_fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nunsigned val;\r\nint ret = 1;\r\ndev_dbg(info->dev,\r\n"%s(regno=%u, red=0x%X, green=0x%X, blue=0x%X, trans=0x%X)\n",\r\n__func__, regno, red, green, blue, transp);\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = info->pseudo_palette;\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fbtft_fb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct fbtft_par *par = info->par;\r\nint ret = -EINVAL;\r\ndev_dbg(info->dev, "%s(blank=%d)\n",\r\n__func__, blank);\r\nif (!par->fbtftops.blank)\r\nreturn ret;\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nret = par->fbtftops.blank(par, true);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nret = par->fbtftops.blank(par, false);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fbtft_merge_fbtftops(struct fbtft_ops *dst, struct fbtft_ops *src)\r\n{\r\nif (src->write)\r\ndst->write = src->write;\r\nif (src->read)\r\ndst->read = src->read;\r\nif (src->write_vmem)\r\ndst->write_vmem = src->write_vmem;\r\nif (src->write_register)\r\ndst->write_register = src->write_register;\r\nif (src->set_addr_win)\r\ndst->set_addr_win = src->set_addr_win;\r\nif (src->reset)\r\ndst->reset = src->reset;\r\nif (src->mkdirty)\r\ndst->mkdirty = src->mkdirty;\r\nif (src->update_display)\r\ndst->update_display = src->update_display;\r\nif (src->init_display)\r\ndst->init_display = src->init_display;\r\nif (src->blank)\r\ndst->blank = src->blank;\r\nif (src->request_gpios_match)\r\ndst->request_gpios_match = src->request_gpios_match;\r\nif (src->request_gpios)\r\ndst->request_gpios = src->request_gpios;\r\nif (src->verify_gpios)\r\ndst->verify_gpios = src->verify_gpios;\r\nif (src->register_backlight)\r\ndst->register_backlight = src->register_backlight;\r\nif (src->unregister_backlight)\r\ndst->unregister_backlight = src->unregister_backlight;\r\nif (src->set_var)\r\ndst->set_var = src->set_var;\r\nif (src->set_gamma)\r\ndst->set_gamma = src->set_gamma;\r\n}\r\nstruct fb_info *fbtft_framebuffer_alloc(struct fbtft_display *display,\r\nstruct device *dev,\r\nstruct fbtft_platform_data *pdata)\r\n{\r\nstruct fb_info *info;\r\nstruct fbtft_par *par;\r\nstruct fb_ops *fbops = NULL;\r\nstruct fb_deferred_io *fbdefio = NULL;\r\nu8 *vmem = NULL;\r\nvoid *txbuf = NULL;\r\nvoid *buf = NULL;\r\nunsigned width;\r\nunsigned height;\r\nint txbuflen = display->txbuflen;\r\nunsigned bpp = display->bpp;\r\nunsigned fps = display->fps;\r\nint vmem_size, i;\r\nint *init_sequence = display->init_sequence;\r\nchar *gamma = display->gamma;\r\nunsigned long *gamma_curves = NULL;\r\nif (display->gamma_num * display->gamma_len > FBTFT_GAMMA_MAX_VALUES_TOTAL) {\r\ndev_err(dev, "FBTFT_GAMMA_MAX_VALUES_TOTAL=%d is exceeded\n",\r\nFBTFT_GAMMA_MAX_VALUES_TOTAL);\r\nreturn NULL;\r\n}\r\nif (!fps)\r\nfps = 20;\r\nif (!bpp)\r\nbpp = 16;\r\nif (!pdata) {\r\ndev_err(dev, "platform data is missing\n");\r\nreturn NULL;\r\n}\r\nif (pdata->fps)\r\nfps = pdata->fps;\r\nif (pdata->txbuflen)\r\ntxbuflen = pdata->txbuflen;\r\nif (pdata->display.init_sequence)\r\ninit_sequence = pdata->display.init_sequence;\r\nif (pdata->gamma)\r\ngamma = pdata->gamma;\r\nif (pdata->display.debug)\r\ndisplay->debug = pdata->display.debug;\r\nif (pdata->display.backlight)\r\ndisplay->backlight = pdata->display.backlight;\r\nif (pdata->display.width)\r\ndisplay->width = pdata->display.width;\r\nif (pdata->display.height)\r\ndisplay->height = pdata->display.height;\r\nif (pdata->display.buswidth)\r\ndisplay->buswidth = pdata->display.buswidth;\r\nif (pdata->display.regwidth)\r\ndisplay->regwidth = pdata->display.regwidth;\r\ndisplay->debug |= debug;\r\nfbtft_expand_debug_value(&display->debug);\r\nswitch (pdata->rotate) {\r\ncase 90:\r\ncase 270:\r\nwidth = display->height;\r\nheight = display->width;\r\nbreak;\r\ndefault:\r\nwidth = display->width;\r\nheight = display->height;\r\n}\r\nvmem_size = display->width * display->height * bpp / 8;\r\nvmem = vzalloc(vmem_size);\r\nif (!vmem)\r\ngoto alloc_fail;\r\nfbops = devm_kzalloc(dev, sizeof(struct fb_ops), GFP_KERNEL);\r\nif (!fbops)\r\ngoto alloc_fail;\r\nfbdefio = devm_kzalloc(dev, sizeof(struct fb_deferred_io), GFP_KERNEL);\r\nif (!fbdefio)\r\ngoto alloc_fail;\r\nbuf = devm_kzalloc(dev, 128, GFP_KERNEL);\r\nif (!buf)\r\ngoto alloc_fail;\r\nif (display->gamma_num && display->gamma_len) {\r\ngamma_curves = devm_kcalloc(dev,\r\ndisplay->gamma_num *\r\ndisplay->gamma_len,\r\nsizeof(gamma_curves[0]),\r\nGFP_KERNEL);\r\nif (!gamma_curves)\r\ngoto alloc_fail;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct fbtft_par), dev);\r\nif (!info)\r\ngoto alloc_fail;\r\ninfo->screen_buffer = vmem;\r\ninfo->fbops = fbops;\r\ninfo->fbdefio = fbdefio;\r\nfbops->owner = dev->driver->owner;\r\nfbops->fb_read = fb_sys_read;\r\nfbops->fb_write = fbtft_fb_write;\r\nfbops->fb_fillrect = fbtft_fb_fillrect;\r\nfbops->fb_copyarea = fbtft_fb_copyarea;\r\nfbops->fb_imageblit = fbtft_fb_imageblit;\r\nfbops->fb_setcolreg = fbtft_fb_setcolreg;\r\nfbops->fb_blank = fbtft_fb_blank;\r\nfbdefio->delay = HZ/fps;\r\nfbdefio->deferred_io = fbtft_deferred_io;\r\nfb_deferred_io_init(info);\r\nstrncpy(info->fix.id, dev->driver->name, 16);\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.line_length = width * bpp / 8;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->fix.smem_len = vmem_size;\r\ninfo->var.rotate = pdata->rotate;\r\ninfo->var.xres = width;\r\ninfo->var.yres = height;\r\ninfo->var.xres_virtual = info->var.xres;\r\ninfo->var.yres_virtual = info->var.yres;\r\ninfo->var.bits_per_pixel = bpp;\r\ninfo->var.nonstd = 1;\r\ninfo->var.red.offset = 11;\r\ninfo->var.red.length = 5;\r\ninfo->var.green.offset = 5;\r\ninfo->var.green.length = 6;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.blue.length = 5;\r\ninfo->var.transp.offset = 0;\r\ninfo->var.transp.length = 0;\r\ninfo->flags = FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;\r\npar = info->par;\r\npar->info = info;\r\npar->pdata = pdata;\r\npar->debug = display->debug;\r\npar->buf = buf;\r\nspin_lock_init(&par->dirty_lock);\r\npar->bgr = pdata->bgr;\r\npar->startbyte = pdata->startbyte;\r\npar->init_sequence = init_sequence;\r\npar->gamma.curves = gamma_curves;\r\npar->gamma.num_curves = display->gamma_num;\r\npar->gamma.num_values = display->gamma_len;\r\nmutex_init(&par->gamma.lock);\r\ninfo->pseudo_palette = par->pseudo_palette;\r\nif (par->gamma.curves && gamma) {\r\nif (fbtft_gamma_parse_str(par,\r\npar->gamma.curves, gamma, strlen(gamma)))\r\ngoto alloc_fail;\r\n}\r\nif (txbuflen == -1)\r\ntxbuflen = vmem_size + 2;\r\n#ifdef __LITTLE_ENDIAN\r\nif ((!txbuflen) && (bpp > 8))\r\ntxbuflen = PAGE_SIZE;\r\n#endif\r\nif (txbuflen > 0) {\r\n#ifdef CONFIG_HAS_DMA\r\nif (dma) {\r\ndev->coherent_dma_mask = ~0;\r\ntxbuf = dmam_alloc_coherent(dev, txbuflen, &par->txbuf.dma, GFP_DMA);\r\n} else\r\n#endif\r\n{\r\ntxbuf = devm_kzalloc(par->info->device, txbuflen, GFP_KERNEL);\r\n}\r\nif (!txbuf)\r\ngoto alloc_fail;\r\npar->txbuf.buf = txbuf;\r\npar->txbuf.len = txbuflen;\r\n}\r\npar->gpio.reset = -1;\r\npar->gpio.dc = -1;\r\npar->gpio.rd = -1;\r\npar->gpio.wr = -1;\r\npar->gpio.cs = -1;\r\npar->gpio.latch = -1;\r\nfor (i = 0; i < 16; i++) {\r\npar->gpio.db[i] = -1;\r\npar->gpio.led[i] = -1;\r\npar->gpio.aux[i] = -1;\r\n}\r\npar->fbtftops.write = fbtft_write_spi;\r\npar->fbtftops.read = fbtft_read_spi;\r\npar->fbtftops.write_vmem = fbtft_write_vmem16_bus8;\r\npar->fbtftops.write_register = fbtft_write_reg8_bus8;\r\npar->fbtftops.set_addr_win = fbtft_set_addr_win;\r\npar->fbtftops.reset = fbtft_reset;\r\npar->fbtftops.mkdirty = fbtft_mkdirty;\r\npar->fbtftops.update_display = fbtft_update_display;\r\npar->fbtftops.request_gpios = fbtft_request_gpios;\r\nif (display->backlight)\r\npar->fbtftops.register_backlight = fbtft_register_backlight;\r\nfbtft_merge_fbtftops(&par->fbtftops, &display->fbtftops);\r\nreturn info;\r\nalloc_fail:\r\nvfree(vmem);\r\nreturn NULL;\r\n}\r\nvoid fbtft_framebuffer_release(struct fb_info *info)\r\n{\r\nfb_deferred_io_cleanup(info);\r\nvfree(info->screen_buffer);\r\nframebuffer_release(info);\r\n}\r\nint fbtft_register_framebuffer(struct fb_info *fb_info)\r\n{\r\nint ret;\r\nchar text1[50] = "";\r\nchar text2[50] = "";\r\nstruct fbtft_par *par = fb_info->par;\r\nstruct spi_device *spi = par->spi;\r\nif (!par->fbtftops.init_display) {\r\ndev_err(fb_info->device, "missing fbtftops.init_display()\n");\r\nreturn -EINVAL;\r\n}\r\nif (spi)\r\nspi_set_drvdata(spi, fb_info);\r\nif (par->pdev)\r\nplatform_set_drvdata(par->pdev, fb_info);\r\nret = par->fbtftops.request_gpios(par);\r\nif (ret < 0)\r\ngoto reg_fail;\r\nif (par->fbtftops.verify_gpios) {\r\nret = par->fbtftops.verify_gpios(par);\r\nif (ret < 0)\r\ngoto reg_fail;\r\n}\r\nret = par->fbtftops.init_display(par);\r\nif (ret < 0)\r\ngoto reg_fail;\r\nif (par->fbtftops.set_var) {\r\nret = par->fbtftops.set_var(par);\r\nif (ret < 0)\r\ngoto reg_fail;\r\n}\r\npar->fbtftops.update_display(par, 0, par->info->var.yres - 1);\r\nif (par->fbtftops.set_gamma && par->gamma.curves) {\r\nret = par->fbtftops.set_gamma(par, par->gamma.curves);\r\nif (ret)\r\ngoto reg_fail;\r\n}\r\nif (par->fbtftops.register_backlight)\r\npar->fbtftops.register_backlight(par);\r\nret = register_framebuffer(fb_info);\r\nif (ret < 0)\r\ngoto reg_fail;\r\nfbtft_sysfs_init(par);\r\nif (par->txbuf.buf)\r\nsprintf(text1, ", %zu KiB %sbuffer memory",\r\npar->txbuf.len >> 10, par->txbuf.dma ? "DMA " : "");\r\nif (spi)\r\nsprintf(text2, ", spi%d.%d at %d MHz", spi->master->bus_num,\r\nspi->chip_select, spi->max_speed_hz / 1000000);\r\ndev_info(fb_info->dev,\r\n"%s frame buffer, %dx%d, %d KiB video memory%s, fps=%lu%s\n",\r\nfb_info->fix.id, fb_info->var.xres, fb_info->var.yres,\r\nfb_info->fix.smem_len >> 10, text1,\r\nHZ / fb_info->fbdefio->delay, text2);\r\n#ifdef CONFIG_FB_BACKLIGHT\r\nif (fb_info->bl_dev) {\r\nfb_info->bl_dev->props.power = FB_BLANK_UNBLANK;\r\nfb_info->bl_dev->ops->update_status(fb_info->bl_dev);\r\n}\r\n#endif\r\nreturn 0;\r\nreg_fail:\r\nif (par->fbtftops.unregister_backlight)\r\npar->fbtftops.unregister_backlight(par);\r\nreturn ret;\r\n}\r\nint fbtft_unregister_framebuffer(struct fb_info *fb_info)\r\n{\r\nstruct fbtft_par *par = fb_info->par;\r\nif (par->fbtftops.unregister_backlight)\r\npar->fbtftops.unregister_backlight(par);\r\nfbtft_sysfs_exit(par);\r\nreturn unregister_framebuffer(fb_info);\r\n}\r\nstatic int fbtft_init_display_dt(struct fbtft_par *par)\r\n{\r\nstruct device_node *node = par->info->device->of_node;\r\nstruct property *prop;\r\nconst __be32 *p;\r\nu32 val;\r\nint buf[64], i, j;\r\nif (!node)\r\nreturn -EINVAL;\r\nprop = of_find_property(node, "init", NULL);\r\np = of_prop_next_u32(prop, NULL, &val);\r\nif (!p)\r\nreturn -EINVAL;\r\npar->fbtftops.reset(par);\r\nif (par->gpio.cs != -1)\r\ngpio_set_value(par->gpio.cs, 0);\r\nwhile (p) {\r\nif (val & FBTFT_OF_INIT_CMD) {\r\nval &= 0xFFFF;\r\ni = 0;\r\nwhile (p && !(val & 0xFFFF0000)) {\r\nif (i > 63) {\r\ndev_err(par->info->device,\r\n"%s: Maximum register values exceeded\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nbuf[i++] = val;\r\np = of_prop_next_u32(prop, p, &val);\r\n}\r\nfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\r\n"init: write_register:\n");\r\nfor (j = 0; j < i; j++)\r\nfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\r\n"buf[%d] = %02X\n", j, buf[j]);\r\npar->fbtftops.write_register(par, i,\r\nbuf[0], buf[1], buf[2], buf[3],\r\nbuf[4], buf[5], buf[6], buf[7],\r\nbuf[8], buf[9], buf[10], buf[11],\r\nbuf[12], buf[13], buf[14], buf[15],\r\nbuf[16], buf[17], buf[18], buf[19],\r\nbuf[20], buf[21], buf[22], buf[23],\r\nbuf[24], buf[25], buf[26], buf[27],\r\nbuf[28], buf[29], buf[30], buf[31],\r\nbuf[32], buf[33], buf[34], buf[35],\r\nbuf[36], buf[37], buf[38], buf[39],\r\nbuf[40], buf[41], buf[42], buf[43],\r\nbuf[44], buf[45], buf[46], buf[47],\r\nbuf[48], buf[49], buf[50], buf[51],\r\nbuf[52], buf[53], buf[54], buf[55],\r\nbuf[56], buf[57], buf[58], buf[59],\r\nbuf[60], buf[61], buf[62], buf[63]);\r\n} else if (val & FBTFT_OF_INIT_DELAY) {\r\nfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\r\n"init: msleep(%u)\n", val & 0xFFFF);\r\nmsleep(val & 0xFFFF);\r\np = of_prop_next_u32(prop, p, &val);\r\n} else {\r\ndev_err(par->info->device, "illegal init value 0x%X\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint fbtft_init_display(struct fbtft_par *par)\r\n{\r\nint buf[64];\r\nchar msg[128];\r\nchar str[16];\r\nint i = 0;\r\nint j;\r\nif (!par->init_sequence) {\r\ndev_err(par->info->device,\r\n"error: init_sequence is not set\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < FBTFT_MAX_INIT_SEQUENCE; i++)\r\nif (par->init_sequence[i] == -3)\r\nbreak;\r\nif (i == FBTFT_MAX_INIT_SEQUENCE) {\r\ndev_err(par->info->device,\r\n"missing stop marker at end of init sequence\n");\r\nreturn -EINVAL;\r\n}\r\npar->fbtftops.reset(par);\r\nif (par->gpio.cs != -1)\r\ngpio_set_value(par->gpio.cs, 0);\r\ni = 0;\r\nwhile (i < FBTFT_MAX_INIT_SEQUENCE) {\r\nif (par->init_sequence[i] == -3) {\r\nreturn 0;\r\n}\r\nif (par->init_sequence[i] >= 0) {\r\ndev_err(par->info->device,\r\n"missing delimiter at position %d\n", i);\r\nreturn -EINVAL;\r\n}\r\nif (par->init_sequence[i + 1] < 0) {\r\ndev_err(par->info->device,\r\n"missing value after delimiter %d at position %d\n",\r\npar->init_sequence[i], i);\r\nreturn -EINVAL;\r\n}\r\nswitch (par->init_sequence[i]) {\r\ncase -1:\r\ni++;\r\nstrcpy(msg, "");\r\nj = i + 1;\r\nwhile (par->init_sequence[j] >= 0) {\r\nsprintf(str, "0x%02X ", par->init_sequence[j]);\r\nstrcat(msg, str);\r\nj++;\r\n}\r\nfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\r\n"init: write(0x%02X) %s\n",\r\npar->init_sequence[i], msg);\r\nj = 0;\r\nwhile (par->init_sequence[i] >= 0) {\r\nif (j > 63) {\r\ndev_err(par->info->device,\r\n"%s: Maximum register values exceeded\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nbuf[j++] = par->init_sequence[i++];\r\n}\r\npar->fbtftops.write_register(par, j,\r\nbuf[0], buf[1], buf[2], buf[3],\r\nbuf[4], buf[5], buf[6], buf[7],\r\nbuf[8], buf[9], buf[10], buf[11],\r\nbuf[12], buf[13], buf[14], buf[15],\r\nbuf[16], buf[17], buf[18], buf[19],\r\nbuf[20], buf[21], buf[22], buf[23],\r\nbuf[24], buf[25], buf[26], buf[27],\r\nbuf[28], buf[29], buf[30], buf[31],\r\nbuf[32], buf[33], buf[34], buf[35],\r\nbuf[36], buf[37], buf[38], buf[39],\r\nbuf[40], buf[41], buf[42], buf[43],\r\nbuf[44], buf[45], buf[46], buf[47],\r\nbuf[48], buf[49], buf[50], buf[51],\r\nbuf[52], buf[53], buf[54], buf[55],\r\nbuf[56], buf[57], buf[58], buf[59],\r\nbuf[60], buf[61], buf[62], buf[63]);\r\nbreak;\r\ncase -2:\r\ni++;\r\nfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\r\n"init: mdelay(%d)\n", par->init_sequence[i]);\r\nmdelay(par->init_sequence[i++]);\r\nbreak;\r\ndefault:\r\ndev_err(par->info->device,\r\n"unknown delimiter %d at position %d\n",\r\npar->init_sequence[i], i);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev_err(par->info->device,\r\n"%s: something is wrong. Shouldn't get here.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstatic int fbtft_verify_gpios(struct fbtft_par *par)\r\n{\r\nstruct fbtft_platform_data *pdata = par->pdata;\r\nint i;\r\nfbtft_par_dbg(DEBUG_VERIFY_GPIOS, par, "%s()\n", __func__);\r\nif (pdata->display.buswidth != 9 && par->startbyte == 0 &&\r\npar->gpio.dc < 0) {\r\ndev_err(par->info->device,\r\n"Missing info about 'dc' gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!par->pdev)\r\nreturn 0;\r\nif (par->gpio.wr < 0) {\r\ndev_err(par->info->device, "Missing 'wr' gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < pdata->display.buswidth; i++) {\r\nif (par->gpio.db[i] < 0) {\r\ndev_err(par->info->device,\r\n"Missing 'db%02d' gpio. Aborting.\n", i);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 fbtft_of_value(struct device_node *node, const char *propname)\r\n{\r\nint ret;\r\nu32 val = 0;\r\nret = of_property_read_u32(node, propname, &val);\r\nif (ret == 0)\r\npr_info("%s: %s = %u\n", __func__, propname, val);\r\nreturn val;\r\n}\r\nstatic struct fbtft_platform_data *fbtft_probe_dt(struct device *dev)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nstruct fbtft_platform_data *pdata;\r\nif (!node) {\r\ndev_err(dev, "Missing platform data or DT\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->display.width = fbtft_of_value(node, "width");\r\npdata->display.height = fbtft_of_value(node, "height");\r\npdata->display.regwidth = fbtft_of_value(node, "regwidth");\r\npdata->display.buswidth = fbtft_of_value(node, "buswidth");\r\npdata->display.backlight = fbtft_of_value(node, "backlight");\r\npdata->display.bpp = fbtft_of_value(node, "bpp");\r\npdata->display.debug = fbtft_of_value(node, "debug");\r\npdata->rotate = fbtft_of_value(node, "rotate");\r\npdata->bgr = of_property_read_bool(node, "bgr");\r\npdata->fps = fbtft_of_value(node, "fps");\r\npdata->txbuflen = fbtft_of_value(node, "txbuflen");\r\npdata->startbyte = fbtft_of_value(node, "startbyte");\r\nof_property_read_string(node, "gamma", (const char **)&pdata->gamma);\r\nif (of_find_property(node, "led-gpios", NULL))\r\npdata->display.backlight = 1;\r\nif (of_find_property(node, "init", NULL))\r\npdata->display.fbtftops.init_display = fbtft_init_display_dt;\r\npdata->display.fbtftops.request_gpios = fbtft_request_gpios_dt;\r\nreturn pdata;\r\n}\r\nstatic struct fbtft_platform_data *fbtft_probe_dt(struct device *dev)\r\n{\r\ndev_err(dev, "Missing platform data\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nint fbtft_probe_common(struct fbtft_display *display,\r\nstruct spi_device *sdev, struct platform_device *pdev)\r\n{\r\nstruct device *dev;\r\nstruct fb_info *info;\r\nstruct fbtft_par *par;\r\nstruct fbtft_platform_data *pdata;\r\nint ret;\r\nif (sdev)\r\ndev = &sdev->dev;\r\nelse\r\ndev = &pdev->dev;\r\nif (unlikely(display->debug & DEBUG_DRIVER_INIT_FUNCTIONS))\r\ndev_info(dev, "%s()\n", __func__);\r\npdata = dev->platform_data;\r\nif (!pdata) {\r\npdata = fbtft_probe_dt(dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\ninfo = fbtft_framebuffer_alloc(display, dev, pdata);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\npar->spi = sdev;\r\npar->pdev = pdev;\r\nif (display->buswidth == 0) {\r\ndev_err(dev, "buswidth is not set\n");\r\nreturn -EINVAL;\r\n}\r\nif (display->regwidth == 8 && display->buswidth == 8) {\r\npar->fbtftops.write_register = fbtft_write_reg8_bus8;\r\n} else\r\nif (display->regwidth == 8 && display->buswidth == 9 && par->spi) {\r\npar->fbtftops.write_register = fbtft_write_reg8_bus9;\r\n} else if (display->regwidth == 16 && display->buswidth == 8) {\r\npar->fbtftops.write_register = fbtft_write_reg16_bus8;\r\n} else if (display->regwidth == 16 && display->buswidth == 16) {\r\npar->fbtftops.write_register = fbtft_write_reg16_bus16;\r\n} else {\r\ndev_warn(dev,\r\n"no default functions for regwidth=%d and buswidth=%d\n",\r\ndisplay->regwidth, display->buswidth);\r\n}\r\nif (display->buswidth == 8)\r\npar->fbtftops.write_vmem = fbtft_write_vmem16_bus8;\r\nelse if (display->buswidth == 9)\r\npar->fbtftops.write_vmem = fbtft_write_vmem16_bus9;\r\nelse if (display->buswidth == 16)\r\npar->fbtftops.write_vmem = fbtft_write_vmem16_bus16;\r\nif (par->pdev) {\r\nif (display->buswidth == 8)\r\npar->fbtftops.write = fbtft_write_gpio8_wr;\r\nelse if (display->buswidth == 16)\r\npar->fbtftops.write = fbtft_write_gpio16_wr;\r\n}\r\nif (par->spi && display->buswidth == 9) {\r\nif (par->spi->master->bits_per_word_mask & SPI_BPW_MASK(9)) {\r\npar->spi->bits_per_word = 9;\r\n} else {\r\ndev_warn(&par->spi->dev,\r\n"9-bit SPI not available, emulating using 8-bit.\n");\r\npar->extra = devm_kzalloc(par->info->device,\r\npar->txbuf.len + (par->txbuf.len / 8) + 8,\r\nGFP_KERNEL);\r\nif (!par->extra) {\r\nret = -ENOMEM;\r\ngoto out_release;\r\n}\r\npar->fbtftops.write = fbtft_write_spi_emulate_9;\r\n}\r\n}\r\nif (!par->fbtftops.verify_gpios)\r\npar->fbtftops.verify_gpios = fbtft_verify_gpios;\r\nfbtft_merge_fbtftops(&par->fbtftops, &display->fbtftops);\r\nif (par->init_sequence)\r\npar->fbtftops.init_display = fbtft_init_display;\r\nfbtft_merge_fbtftops(&par->fbtftops, &pdata->display.fbtftops);\r\nret = fbtft_register_framebuffer(info);\r\nif (ret < 0)\r\ngoto out_release;\r\nreturn 0;\r\nout_release:\r\nfbtft_framebuffer_release(info);\r\nreturn ret;\r\n}\r\nint fbtft_remove_common(struct device *dev, struct fb_info *info)\r\n{\r\nstruct fbtft_par *par;\r\nif (!info)\r\nreturn -EINVAL;\r\npar = info->par;\r\nif (par)\r\nfbtft_par_dbg(DEBUG_DRIVER_INIT_FUNCTIONS, par,\r\n"%s()\n", __func__);\r\nfbtft_unregister_framebuffer(info);\r\nfbtft_framebuffer_release(info);\r\nreturn 0;\r\n}
