static void set_dflts(struct dtsec_cfg *cfg)\r\n{\r\ncfg->halfdup_retransmit = DEFAULT_HALFDUP_RETRANSMIT;\r\ncfg->halfdup_coll_window = DEFAULT_HALFDUP_COLL_WINDOW;\r\ncfg->tx_pad_crc = true;\r\ncfg->tx_pause_time = DEFAULT_TX_PAUSE_TIME;\r\ncfg->rx_prepend = DEFAULT_RX_PREPEND;\r\ncfg->ptp_tsu_en = true;\r\ncfg->ptp_exception_en = true;\r\ncfg->preamble_len = DEFAULT_PREAMBLE_LEN;\r\ncfg->tx_pause_time_extd = DEFAULT_TX_PAUSE_TIME_EXTD;\r\ncfg->non_back_to_back_ipg1 = DEFAULT_NON_BACK_TO_BACK_IPG1;\r\ncfg->non_back_to_back_ipg2 = DEFAULT_NON_BACK_TO_BACK_IPG2;\r\ncfg->min_ifg_enforcement = DEFAULT_MIN_IFG_ENFORCEMENT;\r\ncfg->back_to_back_ipg = DEFAULT_BACK_TO_BACK_IPG;\r\ncfg->maximum_frame = DEFAULT_MAXIMUM_FRAME;\r\n}\r\nstatic int init(struct dtsec_regs __iomem *regs, struct dtsec_cfg *cfg,\r\nphy_interface_t iface, u16 iface_speed, u8 *macaddr,\r\nu32 exception_mask, u8 tbi_addr)\r\n{\r\nbool is_rgmii, is_sgmii, is_qsgmii;\r\nint i;\r\nu32 tmp;\r\niowrite32be(MACCFG1_SOFT_RESET, &regs->maccfg1);\r\niowrite32be(0, &regs->maccfg1);\r\ntmp = ioread32be(&regs->tsec_id2);\r\nif (iface == PHY_INTERFACE_MODE_RGMII ||\r\niface == PHY_INTERFACE_MODE_RMII)\r\nif (tmp & DTSEC_ID2_INT_REDUCED_OFF)\r\nreturn -EINVAL;\r\nif (iface == PHY_INTERFACE_MODE_SGMII ||\r\niface == PHY_INTERFACE_MODE_MII)\r\nif (tmp & DTSEC_ID2_INT_REDUCED_OFF)\r\nreturn -EINVAL;\r\nis_rgmii = iface == PHY_INTERFACE_MODE_RGMII;\r\nis_sgmii = iface == PHY_INTERFACE_MODE_SGMII;\r\nis_qsgmii = iface == PHY_INTERFACE_MODE_QSGMII;\r\ntmp = 0;\r\nif (is_rgmii || iface == PHY_INTERFACE_MODE_GMII)\r\ntmp |= DTSEC_ECNTRL_GMIIM;\r\nif (is_sgmii)\r\ntmp |= (DTSEC_ECNTRL_SGMIIM | DTSEC_ECNTRL_TBIM);\r\nif (is_qsgmii)\r\ntmp |= (DTSEC_ECNTRL_SGMIIM | DTSEC_ECNTRL_TBIM |\r\nDTSEC_ECNTRL_QSGMIIM);\r\nif (is_rgmii)\r\ntmp |= DTSEC_ECNTRL_RPM;\r\nif (iface_speed == SPEED_100)\r\ntmp |= DTSEC_ECNTRL_R100M;\r\niowrite32be(tmp, &regs->ecntrl);\r\ntmp = 0;\r\nif (cfg->tx_pause_time)\r\ntmp |= cfg->tx_pause_time;\r\nif (cfg->tx_pause_time_extd)\r\ntmp |= cfg->tx_pause_time_extd << PTV_PTE_SHIFT;\r\niowrite32be(tmp, &regs->ptv);\r\ntmp = 0;\r\ntmp |= (cfg->rx_prepend << RCTRL_PAL_SHIFT) & RCTRL_PAL_MASK;\r\ntmp |= RCTRL_RSF;\r\niowrite32be(tmp, &regs->rctrl);\r\niowrite32be(tbi_addr, &regs->tbipa);\r\niowrite32be(0, &regs->tmr_ctrl);\r\nif (cfg->ptp_tsu_en) {\r\ntmp = 0;\r\ntmp |= TMR_PEVENT_TSRE;\r\niowrite32be(tmp, &regs->tmr_pevent);\r\nif (cfg->ptp_exception_en) {\r\ntmp = 0;\r\ntmp |= TMR_PEMASK_TSREEN;\r\niowrite32be(tmp, &regs->tmr_pemask);\r\n}\r\n}\r\ntmp = 0;\r\ntmp |= MACCFG1_RX_FLOW;\r\ntmp |= MACCFG1_TX_FLOW;\r\niowrite32be(tmp, &regs->maccfg1);\r\ntmp = 0;\r\nif (iface_speed < SPEED_1000)\r\ntmp |= MACCFG2_NIBBLE_MODE;\r\nelse if (iface_speed == SPEED_1000)\r\ntmp |= MACCFG2_BYTE_MODE;\r\ntmp |= (cfg->preamble_len << MACCFG2_PREAMBLE_LENGTH_SHIFT) &\r\nMACCFG2_PREAMBLE_LENGTH_MASK;\r\nif (cfg->tx_pad_crc)\r\ntmp |= MACCFG2_PAD_CRC_EN;\r\ntmp |= MACCFG2_FULL_DUPLEX;\r\niowrite32be(tmp, &regs->maccfg2);\r\ntmp = (((cfg->non_back_to_back_ipg1 <<\r\nIPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT)\r\n& IPGIFG_NON_BACK_TO_BACK_IPG_1)\r\n| ((cfg->non_back_to_back_ipg2 <<\r\nIPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT)\r\n& IPGIFG_NON_BACK_TO_BACK_IPG_2)\r\n| ((cfg->min_ifg_enforcement << IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT)\r\n& IPGIFG_MIN_IFG_ENFORCEMENT)\r\n| (cfg->back_to_back_ipg & IPGIFG_BACK_TO_BACK_IPG));\r\niowrite32be(tmp, &regs->ipgifg);\r\ntmp = 0;\r\ntmp |= HAFDUP_EXCESS_DEFER;\r\ntmp |= ((cfg->halfdup_retransmit << HAFDUP_RETRANSMISSION_MAX_SHIFT)\r\n& HAFDUP_RETRANSMISSION_MAX);\r\ntmp |= (cfg->halfdup_coll_window & HAFDUP_COLLISION_WINDOW);\r\niowrite32be(tmp, &regs->hafdup);\r\niowrite32be(cfg->maximum_frame, &regs->maxfrm);\r\niowrite32be(0xffffffff, &regs->cam1);\r\niowrite32be(0xffffffff, &regs->cam2);\r\niowrite32be(exception_mask, &regs->imask);\r\niowrite32be(0xffffffff, &regs->ievent);\r\ntmp = (u32)((macaddr[5] << 24) |\r\n(macaddr[4] << 16) | (macaddr[3] << 8) | macaddr[2]);\r\niowrite32be(tmp, &regs->macstnaddr1);\r\ntmp = (u32)((macaddr[1] << 24) | (macaddr[0] << 16));\r\niowrite32be(tmp, &regs->macstnaddr2);\r\nfor (i = 0; i < NUM_OF_HASH_REGS; i++) {\r\niowrite32be(0, &regs->igaddr[i]);\r\niowrite32be(0, &regs->gaddr[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_mac_address(struct dtsec_regs __iomem *regs, u8 *adr)\r\n{\r\nu32 tmp;\r\ntmp = (u32)((adr[5] << 24) |\r\n(adr[4] << 16) | (adr[3] << 8) | adr[2]);\r\niowrite32be(tmp, &regs->macstnaddr1);\r\ntmp = (u32)((adr[1] << 24) | (adr[0] << 16));\r\niowrite32be(tmp, &regs->macstnaddr2);\r\n}\r\nstatic void set_bucket(struct dtsec_regs __iomem *regs, int bucket,\r\nbool enable)\r\n{\r\nint reg_idx = (bucket >> 5) & 0xf;\r\nint bit_idx = bucket & 0x1f;\r\nu32 bit_mask = 0x80000000 >> bit_idx;\r\nu32 __iomem *reg;\r\nif (reg_idx > 7)\r\nreg = &regs->gaddr[reg_idx - 8];\r\nelse\r\nreg = &regs->igaddr[reg_idx];\r\nif (enable)\r\niowrite32be(ioread32be(reg) | bit_mask, reg);\r\nelse\r\niowrite32be(ioread32be(reg) & (~bit_mask), reg);\r\n}\r\nstatic int check_init_parameters(struct fman_mac *dtsec)\r\n{\r\nif (dtsec->max_speed >= SPEED_10000) {\r\npr_err("1G MAC driver supports 1G or lower speeds\n");\r\nreturn -EINVAL;\r\n}\r\nif (dtsec->addr == 0) {\r\npr_err("Ethernet MAC Must have a valid MAC Address\n");\r\nreturn -EINVAL;\r\n}\r\nif ((dtsec->dtsec_drv_param)->rx_prepend >\r\nMAX_PACKET_ALIGNMENT) {\r\npr_err("packetAlignmentPadding can't be > than %d\n",\r\nMAX_PACKET_ALIGNMENT);\r\nreturn -EINVAL;\r\n}\r\nif (((dtsec->dtsec_drv_param)->non_back_to_back_ipg1 >\r\nMAX_INTER_PACKET_GAP) ||\r\n((dtsec->dtsec_drv_param)->non_back_to_back_ipg2 >\r\nMAX_INTER_PACKET_GAP) ||\r\n((dtsec->dtsec_drv_param)->back_to_back_ipg >\r\nMAX_INTER_PACKET_GAP)) {\r\npr_err("Inter packet gap can't be greater than %d\n",\r\nMAX_INTER_PACKET_GAP);\r\nreturn -EINVAL;\r\n}\r\nif ((dtsec->dtsec_drv_param)->halfdup_retransmit >\r\nMAX_RETRANSMISSION) {\r\npr_err("maxRetransmission can't be greater than %d\n",\r\nMAX_RETRANSMISSION);\r\nreturn -EINVAL;\r\n}\r\nif ((dtsec->dtsec_drv_param)->halfdup_coll_window >\r\nMAX_COLLISION_WINDOW) {\r\npr_err("collisionWindow can't be greater than %d\n",\r\nMAX_COLLISION_WINDOW);\r\nreturn -EINVAL;\r\n}\r\nif (!dtsec->exception_cb) {\r\npr_err("uninitialized exception_cb\n");\r\nreturn -EINVAL;\r\n}\r\nif (!dtsec->event_cb) {\r\npr_err("uninitialized event_cb\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_exception_flag(enum fman_mac_exceptions exception)\r\n{\r\nu32 bit_mask;\r\nswitch (exception) {\r\ncase FM_MAC_EX_1G_BAB_RX:\r\nbit_mask = DTSEC_IMASK_BREN;\r\nbreak;\r\ncase FM_MAC_EX_1G_RX_CTL:\r\nbit_mask = DTSEC_IMASK_RXCEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET:\r\nbit_mask = DTSEC_IMASK_GTSCEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_BAB_TX:\r\nbit_mask = DTSEC_IMASK_BTEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_TX_CTL:\r\nbit_mask = DTSEC_IMASK_TXCEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_TX_ERR:\r\nbit_mask = DTSEC_IMASK_TXEEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_LATE_COL:\r\nbit_mask = DTSEC_IMASK_LCEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_COL_RET_LMT:\r\nbit_mask = DTSEC_IMASK_CRLEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_TX_FIFO_UNDRN:\r\nbit_mask = DTSEC_IMASK_XFUNEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_MAG_PCKT:\r\nbit_mask = DTSEC_IMASK_MAGEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_MII_MNG_RD_COMPLET:\r\nbit_mask = DTSEC_IMASK_MMRDEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_MII_MNG_WR_COMPLET:\r\nbit_mask = DTSEC_IMASK_MMWREN;\r\nbreak;\r\ncase FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET:\r\nbit_mask = DTSEC_IMASK_GRSCEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_DATA_ERR:\r\nbit_mask = DTSEC_IMASK_TDPEEN;\r\nbreak;\r\ncase FM_MAC_EX_1G_RX_MIB_CNT_OVFL:\r\nbit_mask = DTSEC_IMASK_MSROEN;\r\nbreak;\r\ndefault:\r\nbit_mask = 0;\r\nbreak;\r\n}\r\nreturn bit_mask;\r\n}\r\nstatic bool is_init_done(struct dtsec_cfg *dtsec_drv_params)\r\n{\r\nif (!dtsec_drv_params)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic u16 dtsec_get_max_frame_length(struct fman_mac *dtsec)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nif (is_init_done(dtsec->dtsec_drv_param))\r\nreturn 0;\r\nreturn (u16)ioread32be(&regs->maxfrm);\r\n}\r\nstatic void dtsec_isr(void *handle)\r\n{\r\nstruct fman_mac *dtsec = (struct fman_mac *)handle;\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nu32 event;\r\nevent = ioread32be(&regs->ievent) &\r\n(u32)(~(DTSEC_IMASK_MMRDEN | DTSEC_IMASK_MMWREN));\r\nevent &= ioread32be(&regs->imask);\r\niowrite32be(event, &regs->ievent);\r\nif (event & DTSEC_IMASK_BREN)\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_BAB_RX);\r\nif (event & DTSEC_IMASK_RXCEN)\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_RX_CTL);\r\nif (event & DTSEC_IMASK_GTSCEN)\r\ndtsec->exception_cb(dtsec->dev_id,\r\nFM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET);\r\nif (event & DTSEC_IMASK_BTEN)\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_BAB_TX);\r\nif (event & DTSEC_IMASK_TXCEN)\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_TX_CTL);\r\nif (event & DTSEC_IMASK_TXEEN)\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_TX_ERR);\r\nif (event & DTSEC_IMASK_LCEN)\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_LATE_COL);\r\nif (event & DTSEC_IMASK_CRLEN)\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_COL_RET_LMT);\r\nif (event & DTSEC_IMASK_XFUNEN) {\r\nif (dtsec->fm_rev_info.major == 2) {\r\nu32 tpkt1, tmp_reg1, tpkt2, tmp_reg2, i;\r\ntpkt1 = ioread32be(&regs->tpkt);\r\ntmp_reg1 = ioread32be(&regs->reserved02c0[27]);\r\nif ((tmp_reg1 & 0x007F0000) !=\r\n(tmp_reg1 & 0x0000007F)) {\r\nusleep_range((u32)(min\r\n(dtsec_get_max_frame_length(dtsec) *\r\n16 / 1000, 1)), (u32)\r\n(min(dtsec_get_max_frame_length\r\n(dtsec) * 16 / 1000, 1) + 1));\r\n}\r\ntpkt2 = ioread32be(&regs->tpkt);\r\ntmp_reg2 = ioread32be(&regs->reserved02c0[27]);\r\nif ((tpkt1 == tpkt2) && ((tmp_reg1 & 0x007F0000) ==\r\n(tmp_reg2 & 0x007F0000))) {\r\niowrite32be(ioread32be(&regs->rctrl) |\r\nRCTRL_GRS, &regs->rctrl);\r\nfor (i = 0; i < 100; i++) {\r\nif (ioread32be(&regs->ievent) &\r\nDTSEC_IMASK_GRSCEN)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (ioread32be(&regs->ievent) &\r\nDTSEC_IMASK_GRSCEN)\r\niowrite32be(DTSEC_IMASK_GRSCEN,\r\n&regs->ievent);\r\nelse\r\npr_debug("Rx lockup due to Tx lockup\n");\r\nfman_reset_mac(dtsec->fm, dtsec->mac_id);\r\nudelay(1);\r\n}\r\n}\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_TX_FIFO_UNDRN);\r\n}\r\nif (event & DTSEC_IMASK_MAGEN)\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_MAG_PCKT);\r\nif (event & DTSEC_IMASK_GRSCEN)\r\ndtsec->exception_cb(dtsec->dev_id,\r\nFM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET);\r\nif (event & DTSEC_IMASK_TDPEEN)\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_DATA_ERR);\r\nif (event & DTSEC_IMASK_RDPEEN)\r\ndtsec->exception_cb(dtsec->dev_id, FM_MAC_1G_RX_DATA_ERR);\r\nWARN_ON(event & DTSEC_IMASK_ABRTEN);\r\nWARN_ON(event & DTSEC_IMASK_IFERREN);\r\n}\r\nstatic void dtsec_1588_isr(void *handle)\r\n{\r\nstruct fman_mac *dtsec = (struct fman_mac *)handle;\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nu32 event;\r\nif (dtsec->ptp_tsu_enabled) {\r\nevent = ioread32be(&regs->tmr_pevent);\r\nevent &= ioread32be(&regs->tmr_pemask);\r\nif (event) {\r\niowrite32be(event, &regs->tmr_pevent);\r\nWARN_ON(event & TMR_PEVENT_TSRE);\r\ndtsec->exception_cb(dtsec->dev_id,\r\nFM_MAC_EX_1G_1588_TS_RX_ERR);\r\n}\r\n}\r\n}\r\nstatic void free_init_resources(struct fman_mac *dtsec)\r\n{\r\nfman_unregister_intr(dtsec->fm, FMAN_MOD_MAC, dtsec->mac_id,\r\nFMAN_INTR_TYPE_ERR);\r\nfman_unregister_intr(dtsec->fm, FMAN_MOD_MAC, dtsec->mac_id,\r\nFMAN_INTR_TYPE_NORMAL);\r\nfree_hash_table(dtsec->multicast_addr_hash);\r\ndtsec->multicast_addr_hash = NULL;\r\nfree_hash_table(dtsec->unicast_addr_hash);\r\ndtsec->unicast_addr_hash = NULL;\r\n}\r\nint dtsec_cfg_max_frame_len(struct fman_mac *dtsec, u16 new_val)\r\n{\r\nif (is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\ndtsec->dtsec_drv_param->maximum_frame = new_val;\r\nreturn 0;\r\n}\r\nint dtsec_cfg_pad_and_crc(struct fman_mac *dtsec, bool new_val)\r\n{\r\nif (is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\ndtsec->dtsec_drv_param->tx_pad_crc = new_val;\r\nreturn 0;\r\n}\r\nint dtsec_enable(struct fman_mac *dtsec, enum comm_mode mode)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nu32 tmp;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->maccfg1);\r\nif (mode & COMM_MODE_RX)\r\ntmp |= MACCFG1_RX_EN;\r\nif (mode & COMM_MODE_TX)\r\ntmp |= MACCFG1_TX_EN;\r\niowrite32be(tmp, &regs->maccfg1);\r\nif (mode & COMM_MODE_TX)\r\niowrite32be(ioread32be(&regs->tctrl) & ~DTSEC_TCTRL_GTS,\r\n&regs->tctrl);\r\nif (mode & COMM_MODE_RX)\r\niowrite32be(ioread32be(&regs->rctrl) & ~RCTRL_GRS,\r\n&regs->rctrl);\r\nreturn 0;\r\n}\r\nint dtsec_disable(struct fman_mac *dtsec, enum comm_mode mode)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nu32 tmp;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\nif (mode & COMM_MODE_RX) {\r\ntmp = ioread32be(&regs->rctrl) | RCTRL_GRS;\r\niowrite32be(tmp, &regs->rctrl);\r\nif (dtsec->fm_rev_info.major == 2)\r\nusleep_range(100, 200);\r\nelse\r\nudelay(10);\r\n}\r\nif (mode & COMM_MODE_TX) {\r\nif (dtsec->fm_rev_info.major == 2)\r\npr_debug("GTS not supported due to DTSEC_A004 errata.\n");\r\nelse\r\npr_debug("GTS not supported due to DTSEC_A0014 errata.\n");\r\n}\r\ntmp = ioread32be(&regs->maccfg1);\r\nif (mode & COMM_MODE_RX)\r\ntmp &= ~MACCFG1_RX_EN;\r\nif (mode & COMM_MODE_TX)\r\ntmp &= ~MACCFG1_TX_EN;\r\niowrite32be(tmp, &regs->maccfg1);\r\nreturn 0;\r\n}\r\nint dtsec_set_tx_pause_frames(struct fman_mac *dtsec,\r\nu8 __maybe_unused priority,\r\nu16 pause_time, u16 __maybe_unused thresh_time)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nu32 ptv = 0;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\nif (pause_time) {\r\nif (dtsec->fm_rev_info.major == 2 && pause_time <= 320) {\r\npr_warn("pause-time: %d illegal.Should be > 320\n",\r\npause_time);\r\nreturn -EINVAL;\r\n}\r\nptv = ioread32be(&regs->ptv);\r\nptv &= PTV_PTE_MASK;\r\nptv |= pause_time & PTV_PT_MASK;\r\niowrite32be(ptv, &regs->ptv);\r\niowrite32be(ioread32be(&regs->maccfg1) | MACCFG1_TX_FLOW,\r\n&regs->maccfg1);\r\n} else\r\niowrite32be(ioread32be(&regs->maccfg1) & ~MACCFG1_TX_FLOW,\r\n&regs->maccfg1);\r\nreturn 0;\r\n}\r\nint dtsec_accept_rx_pause_frames(struct fman_mac *dtsec, bool en)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nu32 tmp;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->maccfg1);\r\nif (en)\r\ntmp |= MACCFG1_RX_FLOW;\r\nelse\r\ntmp &= ~MACCFG1_RX_FLOW;\r\niowrite32be(tmp, &regs->maccfg1);\r\nreturn 0;\r\n}\r\nint dtsec_modify_mac_address(struct fman_mac *dtsec, enet_addr_t *enet_addr)\r\n{\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\ndtsec->addr = ENET_ADDR_TO_UINT64(*enet_addr);\r\nset_mac_address(dtsec->regs, (u8 *)(*enet_addr));\r\nreturn 0;\r\n}\r\nint dtsec_add_hash_mac_address(struct fman_mac *dtsec, enet_addr_t *eth_addr)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nstruct eth_hash_entry *hash_entry;\r\nu64 addr;\r\ns32 bucket;\r\nu32 crc = 0xFFFFFFFF;\r\nbool mcast, ghtx;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\naddr = ENET_ADDR_TO_UINT64(*eth_addr);\r\nghtx = (bool)((ioread32be(&regs->rctrl) & RCTRL_GHTX) ? true : false);\r\nmcast = (bool)((addr & MAC_GROUP_ADDRESS) ? true : false);\r\nif (ghtx && !mcast) {\r\npr_err("Could not compute hash bucket\n");\r\nreturn -EINVAL;\r\n}\r\ncrc = crc32_le(crc, (u8 *)eth_addr, ETH_ALEN);\r\ncrc = bitrev32(crc);\r\nif (ghtx) {\r\nbucket = (s32)((crc >> 23) & 0x1ff);\r\n} else {\r\nbucket = (s32)((crc >> 24) & 0xff);\r\nif (mcast)\r\nbucket += 0x100;\r\n}\r\nset_bucket(dtsec->regs, bucket, true);\r\nhash_entry = kmalloc(sizeof(*hash_entry), GFP_KERNEL);\r\nif (!hash_entry)\r\nreturn -ENOMEM;\r\nhash_entry->addr = addr;\r\nINIT_LIST_HEAD(&hash_entry->node);\r\nif (addr & MAC_GROUP_ADDRESS)\r\nlist_add_tail(&hash_entry->node,\r\n&dtsec->multicast_addr_hash->lsts[bucket]);\r\nelse\r\nlist_add_tail(&hash_entry->node,\r\n&dtsec->unicast_addr_hash->lsts[bucket]);\r\nreturn 0;\r\n}\r\nint dtsec_del_hash_mac_address(struct fman_mac *dtsec, enet_addr_t *eth_addr)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nstruct list_head *pos;\r\nstruct eth_hash_entry *hash_entry = NULL;\r\nu64 addr;\r\ns32 bucket;\r\nu32 crc = 0xFFFFFFFF;\r\nbool mcast, ghtx;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\naddr = ENET_ADDR_TO_UINT64(*eth_addr);\r\nghtx = (bool)((ioread32be(&regs->rctrl) & RCTRL_GHTX) ? true : false);\r\nmcast = (bool)((addr & MAC_GROUP_ADDRESS) ? true : false);\r\nif (ghtx && !mcast) {\r\npr_err("Could not compute hash bucket\n");\r\nreturn -EINVAL;\r\n}\r\ncrc = crc32_le(crc, (u8 *)eth_addr, ETH_ALEN);\r\ncrc = bitrev32(crc);\r\nif (ghtx) {\r\nbucket = (s32)((crc >> 23) & 0x1ff);\r\n} else {\r\nbucket = (s32)((crc >> 24) & 0xff);\r\nif (mcast)\r\nbucket += 0x100;\r\n}\r\nif (addr & MAC_GROUP_ADDRESS) {\r\nlist_for_each(pos,\r\n&dtsec->multicast_addr_hash->lsts[bucket]) {\r\nhash_entry = ETH_HASH_ENTRY_OBJ(pos);\r\nif (hash_entry->addr == addr) {\r\nlist_del_init(&hash_entry->node);\r\nkfree(hash_entry);\r\nbreak;\r\n}\r\n}\r\nif (list_empty(&dtsec->multicast_addr_hash->lsts[bucket]))\r\nset_bucket(dtsec->regs, bucket, false);\r\n} else {\r\nlist_for_each(pos,\r\n&dtsec->unicast_addr_hash->lsts[bucket]) {\r\nhash_entry = ETH_HASH_ENTRY_OBJ(pos);\r\nif (hash_entry->addr == addr) {\r\nlist_del_init(&hash_entry->node);\r\nkfree(hash_entry);\r\nbreak;\r\n}\r\n}\r\nif (list_empty(&dtsec->unicast_addr_hash->lsts[bucket]))\r\nset_bucket(dtsec->regs, bucket, false);\r\n}\r\nWARN_ON(!hash_entry);\r\nreturn 0;\r\n}\r\nint dtsec_set_promiscuous(struct fman_mac *dtsec, bool new_val)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nu32 tmp;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->rctrl);\r\nif (new_val)\r\ntmp |= RCTRL_UPROM;\r\nelse\r\ntmp &= ~RCTRL_UPROM;\r\niowrite32be(tmp, &regs->rctrl);\r\ntmp = ioread32be(&regs->rctrl);\r\nif (new_val)\r\ntmp |= RCTRL_MPROM;\r\nelse\r\ntmp &= ~RCTRL_MPROM;\r\niowrite32be(tmp, &regs->rctrl);\r\nreturn 0;\r\n}\r\nint dtsec_adjust_link(struct fman_mac *dtsec, u16 speed)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nu32 tmp;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->maccfg2);\r\ntmp |= MACCFG2_FULL_DUPLEX;\r\ntmp &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE);\r\nif (speed < SPEED_1000)\r\ntmp |= MACCFG2_NIBBLE_MODE;\r\nelse if (speed == SPEED_1000)\r\ntmp |= MACCFG2_BYTE_MODE;\r\niowrite32be(tmp, &regs->maccfg2);\r\ntmp = ioread32be(&regs->ecntrl);\r\nif (speed == SPEED_100)\r\ntmp |= DTSEC_ECNTRL_R100M;\r\nelse\r\ntmp &= ~DTSEC_ECNTRL_R100M;\r\niowrite32be(tmp, &regs->ecntrl);\r\nreturn 0;\r\n}\r\nint dtsec_restart_autoneg(struct fman_mac *dtsec)\r\n{\r\nu16 tmp_reg16;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\ntmp_reg16 = phy_read(dtsec->tbiphy, MII_BMCR);\r\ntmp_reg16 &= ~(BMCR_SPEED100 | BMCR_SPEED1000);\r\ntmp_reg16 |= (BMCR_ANENABLE | BMCR_ANRESTART |\r\nBMCR_FULLDPLX | BMCR_SPEED1000);\r\nphy_write(dtsec->tbiphy, MII_BMCR, tmp_reg16);\r\nreturn 0;\r\n}\r\nint dtsec_get_version(struct fman_mac *dtsec, u32 *mac_version)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\n*mac_version = ioread32be(&regs->tsec_id);\r\nreturn 0;\r\n}\r\nint dtsec_set_exception(struct fman_mac *dtsec,\r\nenum fman_mac_exceptions exception, bool enable)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nu32 bit_mask = 0;\r\nif (!is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\nif (exception != FM_MAC_EX_1G_1588_TS_RX_ERR) {\r\nbit_mask = get_exception_flag(exception);\r\nif (bit_mask) {\r\nif (enable)\r\ndtsec->exceptions |= bit_mask;\r\nelse\r\ndtsec->exceptions &= ~bit_mask;\r\n} else {\r\npr_err("Undefined exception\n");\r\nreturn -EINVAL;\r\n}\r\nif (enable)\r\niowrite32be(ioread32be(&regs->imask) | bit_mask,\r\n&regs->imask);\r\nelse\r\niowrite32be(ioread32be(&regs->imask) & ~bit_mask,\r\n&regs->imask);\r\n} else {\r\nif (!dtsec->ptp_tsu_enabled) {\r\npr_err("Exception valid for 1588 only\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (exception) {\r\ncase FM_MAC_EX_1G_1588_TS_RX_ERR:\r\nif (enable) {\r\ndtsec->en_tsu_err_exeption = true;\r\niowrite32be(ioread32be(&regs->tmr_pemask) |\r\nTMR_PEMASK_TSREEN,\r\n&regs->tmr_pemask);\r\n} else {\r\ndtsec->en_tsu_err_exeption = false;\r\niowrite32be(ioread32be(&regs->tmr_pemask) &\r\n~TMR_PEMASK_TSREEN,\r\n&regs->tmr_pemask);\r\n}\r\nbreak;\r\ndefault:\r\npr_err("Undefined exception\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dtsec_init(struct fman_mac *dtsec)\r\n{\r\nstruct dtsec_regs __iomem *regs = dtsec->regs;\r\nstruct dtsec_cfg *dtsec_drv_param;\r\nint err;\r\nu16 max_frm_ln;\r\nenet_addr_t eth_addr;\r\nif (is_init_done(dtsec->dtsec_drv_param))\r\nreturn -EINVAL;\r\nif (DEFAULT_RESET_ON_INIT &&\r\n(fman_reset_mac(dtsec->fm, dtsec->mac_id) != 0)) {\r\npr_err("Can't reset MAC!\n");\r\nreturn -EINVAL;\r\n}\r\nerr = check_init_parameters(dtsec);\r\nif (err)\r\nreturn err;\r\ndtsec_drv_param = dtsec->dtsec_drv_param;\r\nMAKE_ENET_ADDR_FROM_UINT64(dtsec->addr, eth_addr);\r\nerr = init(dtsec->regs, dtsec_drv_param, dtsec->phy_if,\r\ndtsec->max_speed, (u8 *)eth_addr, dtsec->exceptions,\r\ndtsec->tbiphy->mdio.addr);\r\nif (err) {\r\nfree_init_resources(dtsec);\r\npr_err("DTSEC version doesn't support this i/f mode\n");\r\nreturn err;\r\n}\r\nif (dtsec->phy_if == PHY_INTERFACE_MODE_SGMII) {\r\nu16 tmp_reg16;\r\ntmp_reg16 = TBICON_CLK_SELECT | TBICON_SOFT_RESET;\r\nphy_write(dtsec->tbiphy, MII_TBICON, tmp_reg16);\r\ntmp_reg16 = TBICON_CLK_SELECT;\r\nphy_write(dtsec->tbiphy, MII_TBICON, tmp_reg16);\r\ntmp_reg16 = (BMCR_RESET | BMCR_ANENABLE |\r\nBMCR_FULLDPLX | BMCR_SPEED1000);\r\nphy_write(dtsec->tbiphy, MII_BMCR, tmp_reg16);\r\nif (dtsec->basex_if)\r\ntmp_reg16 = TBIANA_1000X;\r\nelse\r\ntmp_reg16 = TBIANA_SGMII;\r\nphy_write(dtsec->tbiphy, MII_ADVERTISE, tmp_reg16);\r\ntmp_reg16 = (BMCR_ANENABLE | BMCR_ANRESTART |\r\nBMCR_FULLDPLX | BMCR_SPEED1000);\r\nphy_write(dtsec->tbiphy, MII_BMCR, tmp_reg16);\r\n}\r\nmax_frm_ln = (u16)ioread32be(&regs->maxfrm);\r\nerr = fman_set_mac_max_frame(dtsec->fm, dtsec->mac_id, max_frm_ln);\r\nif (err) {\r\npr_err("Setting max frame length failed\n");\r\nfree_init_resources(dtsec);\r\nreturn -EINVAL;\r\n}\r\ndtsec->multicast_addr_hash =\r\nalloc_hash_table(EXTENDED_HASH_TABLE_SIZE);\r\nif (!dtsec->multicast_addr_hash) {\r\nfree_init_resources(dtsec);\r\npr_err("MC hash table is failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndtsec->unicast_addr_hash = alloc_hash_table(DTSEC_HASH_TABLE_SIZE);\r\nif (!dtsec->unicast_addr_hash) {\r\nfree_init_resources(dtsec);\r\npr_err("UC hash table is failed\n");\r\nreturn -ENOMEM;\r\n}\r\nfman_register_intr(dtsec->fm, FMAN_MOD_MAC, dtsec->mac_id,\r\nFMAN_INTR_TYPE_ERR, dtsec_isr, dtsec);\r\nfman_register_intr(dtsec->fm, FMAN_MOD_MAC, dtsec->mac_id,\r\nFMAN_INTR_TYPE_NORMAL, dtsec_1588_isr, dtsec);\r\nkfree(dtsec_drv_param);\r\ndtsec->dtsec_drv_param = NULL;\r\nreturn 0;\r\n}\r\nint dtsec_free(struct fman_mac *dtsec)\r\n{\r\nfree_init_resources(dtsec);\r\nkfree(dtsec->dtsec_drv_param);\r\ndtsec->dtsec_drv_param = NULL;\r\nkfree(dtsec);\r\nreturn 0;\r\n}\r\nstruct fman_mac *dtsec_config(struct fman_mac_params *params)\r\n{\r\nstruct fman_mac *dtsec;\r\nstruct dtsec_cfg *dtsec_drv_param;\r\nvoid __iomem *base_addr;\r\nbase_addr = params->base_addr;\r\ndtsec = kzalloc(sizeof(*dtsec), GFP_KERNEL);\r\nif (!dtsec)\r\nreturn NULL;\r\ndtsec_drv_param = kzalloc(sizeof(*dtsec_drv_param), GFP_KERNEL);\r\nif (!dtsec_drv_param)\r\ngoto err_dtsec;\r\ndtsec->dtsec_drv_param = dtsec_drv_param;\r\nset_dflts(dtsec_drv_param);\r\ndtsec->regs = base_addr;\r\ndtsec->addr = ENET_ADDR_TO_UINT64(params->addr);\r\ndtsec->max_speed = params->max_speed;\r\ndtsec->phy_if = params->phy_if;\r\ndtsec->mac_id = params->mac_id;\r\ndtsec->exceptions = (DTSEC_IMASK_BREN |\r\nDTSEC_IMASK_RXCEN |\r\nDTSEC_IMASK_BTEN |\r\nDTSEC_IMASK_TXCEN |\r\nDTSEC_IMASK_TXEEN |\r\nDTSEC_IMASK_ABRTEN |\r\nDTSEC_IMASK_LCEN |\r\nDTSEC_IMASK_CRLEN |\r\nDTSEC_IMASK_XFUNEN |\r\nDTSEC_IMASK_IFERREN |\r\nDTSEC_IMASK_MAGEN |\r\nDTSEC_IMASK_TDPEEN |\r\nDTSEC_IMASK_RDPEEN);\r\ndtsec->exception_cb = params->exception_cb;\r\ndtsec->event_cb = params->event_cb;\r\ndtsec->dev_id = params->dev_id;\r\ndtsec->ptp_tsu_enabled = dtsec->dtsec_drv_param->ptp_tsu_en;\r\ndtsec->en_tsu_err_exeption = dtsec->dtsec_drv_param->ptp_exception_en;\r\ndtsec->fm = params->fm;\r\ndtsec->basex_if = params->basex_if;\r\nif (!params->internal_phy_node) {\r\npr_err("TBI PHY node is not available\n");\r\ngoto err_dtsec_drv_param;\r\n}\r\ndtsec->tbiphy = of_phy_find_device(params->internal_phy_node);\r\nif (!dtsec->tbiphy) {\r\npr_err("of_phy_find_device (TBI PHY) failed\n");\r\ngoto err_dtsec_drv_param;\r\n}\r\nput_device(&dtsec->tbiphy->mdio.dev);\r\nfman_get_revision(dtsec->fm, &dtsec->fm_rev_info);\r\nreturn dtsec;\r\nerr_dtsec_drv_param:\r\nkfree(dtsec_drv_param);\r\nerr_dtsec:\r\nkfree(dtsec);\r\nreturn NULL;\r\n}
