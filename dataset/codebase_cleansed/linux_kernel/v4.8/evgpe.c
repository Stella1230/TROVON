acpi_status\r\nacpi_ev_update_gpe_enable_mask(struct acpi_gpe_event_info *gpe_event_info)\r\n{\r\nstruct acpi_gpe_register_info *gpe_register_info;\r\nu32 register_bit;\r\nACPI_FUNCTION_TRACE(ev_update_gpe_enable_mask);\r\ngpe_register_info = gpe_event_info->register_info;\r\nif (!gpe_register_info) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nregister_bit = acpi_hw_get_gpe_register_bit(gpe_event_info);\r\nACPI_CLEAR_BIT(gpe_register_info->enable_for_run, register_bit);\r\nif (gpe_event_info->runtime_count) {\r\nACPI_SET_BIT(gpe_register_info->enable_for_run,\r\n(u8)register_bit);\r\n}\r\ngpe_register_info->enable_mask = gpe_register_info->enable_for_run;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_ev_enable_gpe(struct acpi_gpe_event_info *gpe_event_info)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_enable_gpe);\r\nstatus = acpi_hw_clear_gpe(gpe_event_info);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_ENABLE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ev_add_gpe_reference(struct acpi_gpe_event_info *gpe_event_info)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(ev_add_gpe_reference);\r\nif (gpe_event_info->runtime_count == ACPI_UINT8_MAX) {\r\nreturn_ACPI_STATUS(AE_LIMIT);\r\n}\r\ngpe_event_info->runtime_count++;\r\nif (gpe_event_info->runtime_count == 1) {\r\nstatus = acpi_ev_update_gpe_enable_mask(gpe_event_info);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_ev_enable_gpe(gpe_event_info);\r\n}\r\nif (ACPI_FAILURE(status)) {\r\ngpe_event_info->runtime_count--;\r\n}\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ev_remove_gpe_reference(struct acpi_gpe_event_info *gpe_event_info)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(ev_remove_gpe_reference);\r\nif (!gpe_event_info->runtime_count) {\r\nreturn_ACPI_STATUS(AE_LIMIT);\r\n}\r\ngpe_event_info->runtime_count--;\r\nif (!gpe_event_info->runtime_count) {\r\nstatus = acpi_ev_update_gpe_enable_mask(gpe_event_info);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus =\r\nacpi_hw_low_set_gpe(gpe_event_info,\r\nACPI_GPE_DISABLE);\r\n}\r\nif (ACPI_FAILURE(status)) {\r\ngpe_event_info->runtime_count++;\r\n}\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstruct acpi_gpe_event_info *acpi_ev_low_get_gpe_info(u32 gpe_number,\r\nstruct acpi_gpe_block_info\r\n*gpe_block)\r\n{\r\nu32 gpe_index;\r\nif (!gpe_block || (gpe_number < gpe_block->block_base_number)) {\r\nreturn (NULL);\r\n}\r\ngpe_index = gpe_number - gpe_block->block_base_number;\r\nif (gpe_index >= gpe_block->gpe_count) {\r\nreturn (NULL);\r\n}\r\nreturn (&gpe_block->event_info[gpe_index]);\r\n}\r\nstruct acpi_gpe_event_info *acpi_ev_get_gpe_event_info(acpi_handle gpe_device,\r\nu32 gpe_number)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_gpe_event_info *gpe_info;\r\nu32 i;\r\nACPI_FUNCTION_ENTRY();\r\nif (!gpe_device) {\r\nfor (i = 0; i < ACPI_MAX_GPE_BLOCKS; i++) {\r\ngpe_info = acpi_ev_low_get_gpe_info(gpe_number,\r\nacpi_gbl_gpe_fadt_blocks\r\n[i]);\r\nif (gpe_info) {\r\nreturn (gpe_info);\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nobj_desc =\r\nacpi_ns_get_attached_object((struct acpi_namespace_node *)\r\ngpe_device);\r\nif (!obj_desc || !obj_desc->device.gpe_block) {\r\nreturn (NULL);\r\n}\r\nreturn (acpi_ev_low_get_gpe_info\r\n(gpe_number, obj_desc->device.gpe_block));\r\n}\r\nu32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list)\r\n{\r\nacpi_status status;\r\nstruct acpi_gpe_block_info *gpe_block;\r\nstruct acpi_namespace_node *gpe_device;\r\nstruct acpi_gpe_register_info *gpe_register_info;\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nu32 gpe_number;\r\nstruct acpi_gpe_handler_info *gpe_handler_info;\r\nu32 int_status = ACPI_INTERRUPT_NOT_HANDLED;\r\nu8 enabled_status_byte;\r\nu32 status_reg;\r\nu32 enable_reg;\r\nacpi_cpu_flags flags;\r\nu32 i;\r\nu32 j;\r\nACPI_FUNCTION_NAME(ev_gpe_detect);\r\nif (!gpe_xrupt_list) {\r\nreturn (int_status);\r\n}\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_block = gpe_xrupt_list->gpe_block_list_head;\r\nwhile (gpe_block) {\r\ngpe_device = gpe_block->node;\r\nfor (i = 0; i < gpe_block->register_count; i++) {\r\ngpe_register_info = &gpe_block->register_info[i];\r\nif (!(gpe_register_info->enable_for_run |\r\ngpe_register_info->enable_for_wake)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INTERRUPTS,\r\n"Ignore disabled registers for GPE %02X-%02X: "\r\n"RunEnable=%02X, WakeEnable=%02X\n",\r\ngpe_register_info->\r\nbase_gpe_number,\r\ngpe_register_info->\r\nbase_gpe_number +\r\n(ACPI_GPE_REGISTER_WIDTH - 1),\r\ngpe_register_info->\r\nenable_for_run,\r\ngpe_register_info->\r\nenable_for_wake));\r\ncontinue;\r\n}\r\nstatus =\r\nacpi_hw_read(&status_reg,\r\n&gpe_register_info->status_address);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\nstatus =\r\nacpi_hw_read(&enable_reg,\r\n&gpe_register_info->enable_address);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INTERRUPTS,\r\n"Read registers for GPE %02X-%02X: Status=%02X, Enable=%02X, "\r\n"RunEnable=%02X, WakeEnable=%02X\n",\r\ngpe_register_info->base_gpe_number,\r\ngpe_register_info->base_gpe_number +\r\n(ACPI_GPE_REGISTER_WIDTH - 1),\r\nstatus_reg, enable_reg,\r\ngpe_register_info->enable_for_run,\r\ngpe_register_info->enable_for_wake));\r\nenabled_status_byte = (u8)(status_reg & enable_reg);\r\nif (!enabled_status_byte) {\r\ncontinue;\r\n}\r\nfor (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {\r\ngpe_event_info =\r\n&gpe_block->\r\nevent_info[((acpi_size)i *\r\nACPI_GPE_REGISTER_WIDTH) + j];\r\ngpe_number =\r\nj + gpe_register_info->base_gpe_number;\r\nif (enabled_status_byte & (1 << j)) {\r\nacpi_gpe_count++;\r\nif (acpi_gbl_global_event_handler) {\r\nacpi_gbl_global_event_handler\r\n(ACPI_EVENT_TYPE_GPE,\r\ngpe_device, gpe_number,\r\nacpi_gbl_global_event_handler_context);\r\n}\r\nif (ACPI_GPE_DISPATCH_TYPE\r\n(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_RAW_HANDLER) {\r\ngpe_handler_info =\r\ngpe_event_info->dispatch.\r\nhandler;\r\nacpi_os_release_lock\r\n(acpi_gbl_gpe_lock, flags);\r\nint_status |=\r\ngpe_handler_info->\r\naddress(gpe_device,\r\ngpe_number,\r\ngpe_handler_info->\r\ncontext);\r\nflags =\r\nacpi_os_acquire_lock\r\n(acpi_gbl_gpe_lock);\r\n} else {\r\nint_status |=\r\nacpi_ev_gpe_dispatch\r\n(gpe_device, gpe_event_info,\r\ngpe_number);\r\n}\r\n}\r\n}\r\n}\r\ngpe_block = gpe_block->next;\r\n}\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn (int_status);\r\n}\r\nstatic void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context)\r\n{\r\nstruct acpi_gpe_event_info *gpe_event_info = context;\r\nacpi_status status = AE_OK;\r\nstruct acpi_evaluate_info *info;\r\nstruct acpi_gpe_notify_info *notify;\r\nACPI_FUNCTION_TRACE(ev_asynch_execute_gpe_method);\r\nswitch (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags)) {\r\ncase ACPI_GPE_DISPATCH_NOTIFY:\r\nnotify = gpe_event_info->dispatch.notify_list;\r\nwhile (ACPI_SUCCESS(status) && notify) {\r\nstatus =\r\nacpi_ev_queue_notify_request(notify->device_node,\r\nACPI_NOTIFY_DEVICE_WAKE);\r\nnotify = notify->next;\r\n}\r\nbreak;\r\ncase ACPI_GPE_DISPATCH_METHOD:\r\ninfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\r\nif (!info) {\r\nstatus = AE_NO_MEMORY;\r\n} else {\r\ninfo->prefix_node =\r\ngpe_event_info->dispatch.method_node;\r\ninfo->flags = ACPI_IGNORE_RETURN_VALUE;\r\nstatus = acpi_ns_evaluate(info);\r\nACPI_FREE(info);\r\n}\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"while evaluating GPE method [%4.4s]",\r\nacpi_ut_get_node_name(gpe_event_info->\r\ndispatch.\r\nmethod_node)));\r\n}\r\nbreak;\r\ndefault:\r\ngoto error_exit;\r\n}\r\nstatus = acpi_os_execute(OSL_NOTIFY_HANDLER,\r\nacpi_ev_asynch_enable_gpe, gpe_event_info);\r\nif (ACPI_SUCCESS(status)) {\r\nreturn_VOID;\r\n}\r\nerror_exit:\r\nacpi_ev_asynch_enable_gpe(gpe_event_info);\r\nreturn_VOID;\r\n}\r\nstatic void ACPI_SYSTEM_XFACE acpi_ev_asynch_enable_gpe(void *context)\r\n{\r\nstruct acpi_gpe_event_info *gpe_event_info = context;\r\nacpi_cpu_flags flags;\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\n(void)acpi_ev_finish_gpe(gpe_event_info);\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn;\r\n}\r\nacpi_status acpi_ev_finish_gpe(struct acpi_gpe_event_info *gpe_event_info)\r\n{\r\nacpi_status status;\r\nif ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) ==\r\nACPI_GPE_LEVEL_TRIGGERED) {\r\nstatus = acpi_hw_clear_gpe(gpe_event_info);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\n(void)acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_CONDITIONAL_ENABLE);\r\nreturn (AE_OK);\r\n}\r\nu32\r\nacpi_ev_gpe_dispatch(struct acpi_namespace_node *gpe_device,\r\nstruct acpi_gpe_event_info *gpe_event_info, u32 gpe_number)\r\n{\r\nacpi_status status;\r\nu32 return_value;\r\nACPI_FUNCTION_TRACE(ev_gpe_dispatch);\r\nstatus = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Unable to disable GPE %02X", gpe_number));\r\nreturn_UINT32(ACPI_INTERRUPT_NOT_HANDLED);\r\n}\r\nif ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) ==\r\nACPI_GPE_EDGE_TRIGGERED) {\r\nstatus = acpi_hw_clear_gpe(gpe_event_info);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Unable to clear GPE %02X",\r\ngpe_number));\r\n(void)acpi_hw_low_set_gpe(gpe_event_info,\r\nACPI_GPE_CONDITIONAL_ENABLE);\r\nreturn_UINT32(ACPI_INTERRUPT_NOT_HANDLED);\r\n}\r\n}\r\nswitch (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags)) {\r\ncase ACPI_GPE_DISPATCH_HANDLER:\r\nreturn_value =\r\ngpe_event_info->dispatch.handler->address(gpe_device,\r\ngpe_number,\r\ngpe_event_info->\r\ndispatch.handler->\r\ncontext);\r\nif (return_value & ACPI_REENABLE_GPE) {\r\n(void)acpi_ev_finish_gpe(gpe_event_info);\r\n}\r\nbreak;\r\ncase ACPI_GPE_DISPATCH_METHOD:\r\ncase ACPI_GPE_DISPATCH_NOTIFY:\r\nstatus = acpi_os_execute(OSL_GPE_HANDLER,\r\nacpi_ev_asynch_execute_gpe_method,\r\ngpe_event_info);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Unable to queue handler for GPE %02X - event disabled",\r\ngpe_number));\r\n}\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO,\r\n"No handler or method for GPE %02X, disabling event",\r\ngpe_number));\r\nbreak;\r\n}\r\nreturn_UINT32(ACPI_INTERRUPT_HANDLED);\r\n}
