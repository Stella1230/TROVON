static void igb_raise_eec_clk(struct e1000_hw *hw, u32 *eecd)\r\n{\r\n*eecd = *eecd | E1000_EECD_SK;\r\nwr32(E1000_EECD, *eecd);\r\nwrfl();\r\nudelay(hw->nvm.delay_usec);\r\n}\r\nstatic void igb_lower_eec_clk(struct e1000_hw *hw, u32 *eecd)\r\n{\r\n*eecd = *eecd & ~E1000_EECD_SK;\r\nwr32(E1000_EECD, *eecd);\r\nwrfl();\r\nudelay(hw->nvm.delay_usec);\r\n}\r\nstatic void igb_shift_out_eec_bits(struct e1000_hw *hw, u16 data, u16 count)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 eecd = rd32(E1000_EECD);\r\nu32 mask;\r\nmask = 1u << (count - 1);\r\nif (nvm->type == e1000_nvm_eeprom_spi)\r\neecd |= E1000_EECD_DO;\r\ndo {\r\neecd &= ~E1000_EECD_DI;\r\nif (data & mask)\r\neecd |= E1000_EECD_DI;\r\nwr32(E1000_EECD, eecd);\r\nwrfl();\r\nudelay(nvm->delay_usec);\r\nigb_raise_eec_clk(hw, &eecd);\r\nigb_lower_eec_clk(hw, &eecd);\r\nmask >>= 1;\r\n} while (mask);\r\neecd &= ~E1000_EECD_DI;\r\nwr32(E1000_EECD, eecd);\r\n}\r\nstatic u16 igb_shift_in_eec_bits(struct e1000_hw *hw, u16 count)\r\n{\r\nu32 eecd;\r\nu32 i;\r\nu16 data;\r\neecd = rd32(E1000_EECD);\r\neecd &= ~(E1000_EECD_DO | E1000_EECD_DI);\r\ndata = 0;\r\nfor (i = 0; i < count; i++) {\r\ndata <<= 1;\r\nigb_raise_eec_clk(hw, &eecd);\r\neecd = rd32(E1000_EECD);\r\neecd &= ~E1000_EECD_DI;\r\nif (eecd & E1000_EECD_DO)\r\ndata |= 1;\r\nigb_lower_eec_clk(hw, &eecd);\r\n}\r\nreturn data;\r\n}\r\nstatic s32 igb_poll_eerd_eewr_done(struct e1000_hw *hw, int ee_reg)\r\n{\r\nu32 attempts = 100000;\r\nu32 i, reg = 0;\r\ns32 ret_val = -E1000_ERR_NVM;\r\nfor (i = 0; i < attempts; i++) {\r\nif (ee_reg == E1000_NVM_POLL_READ)\r\nreg = rd32(E1000_EERD);\r\nelse\r\nreg = rd32(E1000_EEWR);\r\nif (reg & E1000_NVM_RW_REG_DONE) {\r\nret_val = 0;\r\nbreak;\r\n}\r\nudelay(5);\r\n}\r\nreturn ret_val;\r\n}\r\ns32 igb_acquire_nvm(struct e1000_hw *hw)\r\n{\r\nu32 eecd = rd32(E1000_EECD);\r\ns32 timeout = E1000_NVM_GRANT_ATTEMPTS;\r\ns32 ret_val = 0;\r\nwr32(E1000_EECD, eecd | E1000_EECD_REQ);\r\neecd = rd32(E1000_EECD);\r\nwhile (timeout) {\r\nif (eecd & E1000_EECD_GNT)\r\nbreak;\r\nudelay(5);\r\neecd = rd32(E1000_EECD);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\neecd &= ~E1000_EECD_REQ;\r\nwr32(E1000_EECD, eecd);\r\nhw_dbg("Could not acquire NVM grant\n");\r\nret_val = -E1000_ERR_NVM;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic void igb_standby_nvm(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 eecd = rd32(E1000_EECD);\r\nif (nvm->type == e1000_nvm_eeprom_spi) {\r\neecd |= E1000_EECD_CS;\r\nwr32(E1000_EECD, eecd);\r\nwrfl();\r\nudelay(nvm->delay_usec);\r\neecd &= ~E1000_EECD_CS;\r\nwr32(E1000_EECD, eecd);\r\nwrfl();\r\nudelay(nvm->delay_usec);\r\n}\r\n}\r\nstatic void e1000_stop_nvm(struct e1000_hw *hw)\r\n{\r\nu32 eecd;\r\neecd = rd32(E1000_EECD);\r\nif (hw->nvm.type == e1000_nvm_eeprom_spi) {\r\neecd |= E1000_EECD_CS;\r\nigb_lower_eec_clk(hw, &eecd);\r\n}\r\n}\r\nvoid igb_release_nvm(struct e1000_hw *hw)\r\n{\r\nu32 eecd;\r\ne1000_stop_nvm(hw);\r\neecd = rd32(E1000_EECD);\r\neecd &= ~E1000_EECD_REQ;\r\nwr32(E1000_EECD, eecd);\r\n}\r\nstatic s32 igb_ready_nvm_eeprom(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 eecd = rd32(E1000_EECD);\r\ns32 ret_val = 0;\r\nu16 timeout = 0;\r\nu8 spi_stat_reg;\r\nif (nvm->type == e1000_nvm_eeprom_spi) {\r\neecd &= ~(E1000_EECD_CS | E1000_EECD_SK);\r\nwr32(E1000_EECD, eecd);\r\nwrfl();\r\nudelay(1);\r\ntimeout = NVM_MAX_RETRY_SPI;\r\nwhile (timeout) {\r\nigb_shift_out_eec_bits(hw, NVM_RDSR_OPCODE_SPI,\r\nhw->nvm.opcode_bits);\r\nspi_stat_reg = (u8)igb_shift_in_eec_bits(hw, 8);\r\nif (!(spi_stat_reg & NVM_STATUS_RDY_SPI))\r\nbreak;\r\nudelay(5);\r\nigb_standby_nvm(hw);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\nhw_dbg("SPI NVM Status error\n");\r\nret_val = -E1000_ERR_NVM;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_read_nvm_spi(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 i = 0;\r\ns32 ret_val;\r\nu16 word_in;\r\nu8 read_opcode = NVM_READ_OPCODE_SPI;\r\nif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\r\n(words == 0)) {\r\nhw_dbg("nvm parameter(s) out of bounds\n");\r\nret_val = -E1000_ERR_NVM;\r\ngoto out;\r\n}\r\nret_val = nvm->ops.acquire(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_ready_nvm_eeprom(hw);\r\nif (ret_val)\r\ngoto release;\r\nigb_standby_nvm(hw);\r\nif ((nvm->address_bits == 8) && (offset >= 128))\r\nread_opcode |= NVM_A8_OPCODE_SPI;\r\nigb_shift_out_eec_bits(hw, read_opcode, nvm->opcode_bits);\r\nigb_shift_out_eec_bits(hw, (u16)(offset*2), nvm->address_bits);\r\nfor (i = 0; i < words; i++) {\r\nword_in = igb_shift_in_eec_bits(hw, 16);\r\ndata[i] = (word_in >> 8) | (word_in << 8);\r\n}\r\nrelease:\r\nnvm->ops.release(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_read_nvm_eerd(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 i, eerd = 0;\r\ns32 ret_val = 0;\r\nif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\r\n(words == 0)) {\r\nhw_dbg("nvm parameter(s) out of bounds\n");\r\nret_val = -E1000_ERR_NVM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < words; i++) {\r\neerd = ((offset+i) << E1000_NVM_RW_ADDR_SHIFT) +\r\nE1000_NVM_RW_REG_START;\r\nwr32(E1000_EERD, eerd);\r\nret_val = igb_poll_eerd_eewr_done(hw, E1000_NVM_POLL_READ);\r\nif (ret_val)\r\nbreak;\r\ndata[i] = (rd32(E1000_EERD) >>\r\nE1000_NVM_RW_REG_DATA);\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_write_nvm_spi(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\ns32 ret_val = -E1000_ERR_NVM;\r\nu16 widx = 0;\r\nif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\r\n(words == 0)) {\r\nhw_dbg("nvm parameter(s) out of bounds\n");\r\nreturn ret_val;\r\n}\r\nwhile (widx < words) {\r\nu8 write_opcode = NVM_WRITE_OPCODE_SPI;\r\nret_val = nvm->ops.acquire(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = igb_ready_nvm_eeprom(hw);\r\nif (ret_val) {\r\nnvm->ops.release(hw);\r\nreturn ret_val;\r\n}\r\nigb_standby_nvm(hw);\r\nigb_shift_out_eec_bits(hw, NVM_WREN_OPCODE_SPI,\r\nnvm->opcode_bits);\r\nigb_standby_nvm(hw);\r\nif ((nvm->address_bits == 8) && (offset >= 128))\r\nwrite_opcode |= NVM_A8_OPCODE_SPI;\r\nigb_shift_out_eec_bits(hw, write_opcode, nvm->opcode_bits);\r\nigb_shift_out_eec_bits(hw, (u16)((offset + widx) * 2),\r\nnvm->address_bits);\r\nwhile (widx < words) {\r\nu16 word_out = data[widx];\r\nword_out = (word_out >> 8) | (word_out << 8);\r\nigb_shift_out_eec_bits(hw, word_out, 16);\r\nwidx++;\r\nif ((((offset + widx) * 2) % nvm->page_size) == 0) {\r\nigb_standby_nvm(hw);\r\nbreak;\r\n}\r\n}\r\nusleep_range(1000, 2000);\r\nnvm->ops.release(hw);\r\n}\r\nreturn ret_val;\r\n}\r\ns32 igb_read_part_string(struct e1000_hw *hw, u8 *part_num, u32 part_num_size)\r\n{\r\ns32 ret_val;\r\nu16 nvm_data;\r\nu16 pointer;\r\nu16 offset;\r\nu16 length;\r\nif (part_num == NULL) {\r\nhw_dbg("PBA string buffer was null\n");\r\nret_val = E1000_ERR_INVALID_ARGUMENT;\r\ngoto out;\r\n}\r\nret_val = hw->nvm.ops.read(hw, NVM_PBA_OFFSET_0, 1, &nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nret_val = hw->nvm.ops.read(hw, NVM_PBA_OFFSET_1, 1, &pointer);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nif (nvm_data != NVM_PBA_PTR_GUARD) {\r\nhw_dbg("NVM PBA number is not stored as string\n");\r\nif (part_num_size < 11) {\r\nhw_dbg("PBA string buffer too small\n");\r\nreturn E1000_ERR_NO_SPACE;\r\n}\r\npart_num[0] = (nvm_data >> 12) & 0xF;\r\npart_num[1] = (nvm_data >> 8) & 0xF;\r\npart_num[2] = (nvm_data >> 4) & 0xF;\r\npart_num[3] = nvm_data & 0xF;\r\npart_num[4] = (pointer >> 12) & 0xF;\r\npart_num[5] = (pointer >> 8) & 0xF;\r\npart_num[6] = '-';\r\npart_num[7] = 0;\r\npart_num[8] = (pointer >> 4) & 0xF;\r\npart_num[9] = pointer & 0xF;\r\npart_num[10] = '\0';\r\nfor (offset = 0; offset < 10; offset++) {\r\nif (part_num[offset] < 0xA)\r\npart_num[offset] += '0';\r\nelse if (part_num[offset] < 0x10)\r\npart_num[offset] += 'A' - 0xA;\r\n}\r\ngoto out;\r\n}\r\nret_val = hw->nvm.ops.read(hw, pointer, 1, &length);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nif (length == 0xFFFF || length == 0) {\r\nhw_dbg("NVM PBA number section invalid length\n");\r\nret_val = E1000_ERR_NVM_PBA_SECTION;\r\ngoto out;\r\n}\r\nif (part_num_size < (((u32)length * 2) - 1)) {\r\nhw_dbg("PBA string buffer too small\n");\r\nret_val = E1000_ERR_NO_SPACE;\r\ngoto out;\r\n}\r\npointer++;\r\nlength--;\r\nfor (offset = 0; offset < length; offset++) {\r\nret_val = hw->nvm.ops.read(hw, pointer + offset, 1, &nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\npart_num[offset * 2] = (u8)(nvm_data >> 8);\r\npart_num[(offset * 2) + 1] = (u8)(nvm_data & 0xFF);\r\n}\r\npart_num[offset * 2] = '\0';\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_read_mac_addr(struct e1000_hw *hw)\r\n{\r\nu32 rar_high;\r\nu32 rar_low;\r\nu16 i;\r\nrar_high = rd32(E1000_RAH(0));\r\nrar_low = rd32(E1000_RAL(0));\r\nfor (i = 0; i < E1000_RAL_MAC_ADDR_LEN; i++)\r\nhw->mac.perm_addr[i] = (u8)(rar_low >> (i*8));\r\nfor (i = 0; i < E1000_RAH_MAC_ADDR_LEN; i++)\r\nhw->mac.perm_addr[i+4] = (u8)(rar_high >> (i*8));\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nhw->mac.addr[i] = hw->mac.perm_addr[i];\r\nreturn 0;\r\n}\r\ns32 igb_validate_nvm_checksum(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 checksum = 0;\r\nu16 i, nvm_data;\r\nfor (i = 0; i < (NVM_CHECKSUM_REG + 1); i++) {\r\nret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nchecksum += nvm_data;\r\n}\r\nif (checksum != (u16) NVM_SUM) {\r\nhw_dbg("NVM Checksum Invalid\n");\r\nret_val = -E1000_ERR_NVM;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_update_nvm_checksum(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 checksum = 0;\r\nu16 i, nvm_data;\r\nfor (i = 0; i < NVM_CHECKSUM_REG; i++) {\r\nret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error while updating checksum.\n");\r\ngoto out;\r\n}\r\nchecksum += nvm_data;\r\n}\r\nchecksum = (u16) NVM_SUM - checksum;\r\nret_val = hw->nvm.ops.write(hw, NVM_CHECKSUM_REG, 1, &checksum);\r\nif (ret_val)\r\nhw_dbg("NVM Write Error while updating checksum.\n");\r\nout:\r\nreturn ret_val;\r\n}\r\nvoid igb_get_fw_version(struct e1000_hw *hw, struct e1000_fw_version *fw_vers)\r\n{\r\nu16 eeprom_verh, eeprom_verl, etrack_test, fw_version;\r\nu8 q, hval, rem, result;\r\nu16 comb_verh, comb_verl, comb_offset;\r\nmemset(fw_vers, 0, sizeof(struct e1000_fw_version));\r\nhw->nvm.ops.read(hw, NVM_ETRACK_HIWORD, 1, &etrack_test);\r\nswitch (hw->mac.type) {\r\ncase e1000_i211:\r\nigb_read_invm_version(hw, fw_vers);\r\nreturn;\r\ncase e1000_82575:\r\ncase e1000_82576:\r\ncase e1000_82580:\r\nif ((etrack_test & NVM_MAJOR_MASK) != NVM_ETRACK_VALID) {\r\nhw->nvm.ops.read(hw, NVM_VERSION, 1, &fw_version);\r\nfw_vers->eep_major = (fw_version & NVM_MAJOR_MASK)\r\n>> NVM_MAJOR_SHIFT;\r\nfw_vers->eep_minor = (fw_version & NVM_MINOR_MASK)\r\n>> NVM_MINOR_SHIFT;\r\nfw_vers->eep_build = (fw_version & NVM_IMAGE_ID_MASK);\r\ngoto etrack_id;\r\n}\r\nbreak;\r\ncase e1000_i210:\r\nif (!(igb_get_flash_presence_i210(hw))) {\r\nigb_read_invm_version(hw, fw_vers);\r\nreturn;\r\n}\r\ncase e1000_i350:\r\nhw->nvm.ops.read(hw, NVM_COMB_VER_PTR, 1, &comb_offset);\r\nif ((comb_offset != 0x0) &&\r\n(comb_offset != NVM_VER_INVALID)) {\r\nhw->nvm.ops.read(hw, (NVM_COMB_VER_OFF + comb_offset\r\n+ 1), 1, &comb_verh);\r\nhw->nvm.ops.read(hw, (NVM_COMB_VER_OFF + comb_offset),\r\n1, &comb_verl);\r\nif ((comb_verh && comb_verl) &&\r\n((comb_verh != NVM_VER_INVALID) &&\r\n(comb_verl != NVM_VER_INVALID))) {\r\nfw_vers->or_valid = true;\r\nfw_vers->or_major =\r\ncomb_verl >> NVM_COMB_VER_SHFT;\r\nfw_vers->or_build =\r\n(comb_verl << NVM_COMB_VER_SHFT)\r\n| (comb_verh >> NVM_COMB_VER_SHFT);\r\nfw_vers->or_patch =\r\ncomb_verh & NVM_COMB_VER_MASK;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nhw->nvm.ops.read(hw, NVM_VERSION, 1, &fw_version);\r\nfw_vers->eep_major = (fw_version & NVM_MAJOR_MASK)\r\n>> NVM_MAJOR_SHIFT;\r\nif ((fw_version & NVM_NEW_DEC_MASK) == 0x0) {\r\neeprom_verl = (fw_version & NVM_COMB_VER_MASK);\r\n} else {\r\neeprom_verl = (fw_version & NVM_MINOR_MASK)\r\n>> NVM_MINOR_SHIFT;\r\n}\r\nq = eeprom_verl / NVM_HEX_CONV;\r\nhval = q * NVM_HEX_TENS;\r\nrem = eeprom_verl % NVM_HEX_CONV;\r\nresult = hval + rem;\r\nfw_vers->eep_minor = result;\r\netrack_id:\r\nif ((etrack_test & NVM_MAJOR_MASK) == NVM_ETRACK_VALID) {\r\nhw->nvm.ops.read(hw, NVM_ETRACK_WORD, 1, &eeprom_verl);\r\nhw->nvm.ops.read(hw, (NVM_ETRACK_WORD + 1), 1, &eeprom_verh);\r\nfw_vers->etrack_id = (eeprom_verh << NVM_ETRACK_SHIFT)\r\n| eeprom_verl;\r\n}\r\n}
