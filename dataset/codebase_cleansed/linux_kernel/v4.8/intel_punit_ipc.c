static inline u32 ipc_read_status(IPC_DEV *ipcdev, IPC_TYPE type)\r\n{\r\nreturn readl(ipcdev->base[type][BASE_IFACE]);\r\n}\r\nstatic inline void ipc_write_cmd(IPC_DEV *ipcdev, IPC_TYPE type, u32 cmd)\r\n{\r\nwritel(cmd, ipcdev->base[type][BASE_IFACE]);\r\n}\r\nstatic inline u32 ipc_read_data_low(IPC_DEV *ipcdev, IPC_TYPE type)\r\n{\r\nreturn readl(ipcdev->base[type][BASE_DATA] + OFFSET_DATA_LOW);\r\n}\r\nstatic inline u32 ipc_read_data_high(IPC_DEV *ipcdev, IPC_TYPE type)\r\n{\r\nreturn readl(ipcdev->base[type][BASE_DATA] + OFFSET_DATA_HIGH);\r\n}\r\nstatic inline void ipc_write_data_low(IPC_DEV *ipcdev, IPC_TYPE type, u32 data)\r\n{\r\nwritel(data, ipcdev->base[type][BASE_DATA] + OFFSET_DATA_LOW);\r\n}\r\nstatic inline void ipc_write_data_high(IPC_DEV *ipcdev, IPC_TYPE type, u32 data)\r\n{\r\nwritel(data, ipcdev->base[type][BASE_DATA] + OFFSET_DATA_HIGH);\r\n}\r\nstatic const char *ipc_err_string(int error)\r\n{\r\nif (error == IPC_PUNIT_ERR_SUCCESS)\r\nreturn "no error";\r\nelse if (error == IPC_PUNIT_ERR_INVALID_CMD)\r\nreturn "invalid command";\r\nelse if (error == IPC_PUNIT_ERR_INVALID_PARAMETER)\r\nreturn "invalid parameter";\r\nelse if (error == IPC_PUNIT_ERR_CMD_TIMEOUT)\r\nreturn "command timeout";\r\nelse if (error == IPC_PUNIT_ERR_CMD_LOCKED)\r\nreturn "command locked";\r\nelse if (error == IPC_PUNIT_ERR_INVALID_VR_ID)\r\nreturn "invalid vr id";\r\nelse if (error == IPC_PUNIT_ERR_VR_ERR)\r\nreturn "vr error";\r\nelse\r\nreturn "unknown error";\r\n}\r\nstatic int intel_punit_ipc_check_status(IPC_DEV *ipcdev, IPC_TYPE type)\r\n{\r\nint loops = CMD_TIMEOUT_SECONDS * USEC_PER_SEC;\r\nint errcode;\r\nint status;\r\nif (ipcdev->irq) {\r\nif (!wait_for_completion_timeout(&ipcdev->cmd_complete,\r\nCMD_TIMEOUT_SECONDS * HZ)) {\r\ndev_err(ipcdev->dev, "IPC timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n} else {\r\nwhile ((ipc_read_status(ipcdev, type) & CMD_RUN) && --loops)\r\nudelay(1);\r\nif (!loops) {\r\ndev_err(ipcdev->dev, "IPC timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nstatus = ipc_read_status(ipcdev, type);\r\nerrcode = status & CMD_ERRCODE_MASK;\r\nif (errcode) {\r\ndev_err(ipcdev->dev, "IPC failed: %s, IPC_STS=0x%x\n",\r\nipc_err_string(errcode), status);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint intel_punit_ipc_simple_command(int cmd, int para1, int para2)\r\n{\r\nIPC_DEV *ipcdev = punit_ipcdev;\r\nIPC_TYPE type;\r\nu32 val;\r\nint ret;\r\nmutex_lock(&ipcdev->lock);\r\nreinit_completion(&ipcdev->cmd_complete);\r\ntype = (cmd & IPC_PUNIT_CMD_TYPE_MASK) >> IPC_TYPE_OFFSET;\r\nval = cmd & ~IPC_PUNIT_CMD_TYPE_MASK;\r\nval |= CMD_RUN | para2 << CMD_PARA2_SHIFT | para1 << CMD_PARA1_SHIFT;\r\nipc_write_cmd(ipcdev, type, val);\r\nret = intel_punit_ipc_check_status(ipcdev, type);\r\nmutex_unlock(&ipcdev->lock);\r\nreturn ret;\r\n}\r\nint intel_punit_ipc_command(u32 cmd, u32 para1, u32 para2, u32 *in, u32 *out)\r\n{\r\nIPC_DEV *ipcdev = punit_ipcdev;\r\nIPC_TYPE type;\r\nu32 val;\r\nint ret;\r\nmutex_lock(&ipcdev->lock);\r\nreinit_completion(&ipcdev->cmd_complete);\r\ntype = (cmd & IPC_PUNIT_CMD_TYPE_MASK) >> IPC_TYPE_OFFSET;\r\nif (in) {\r\nipc_write_data_low(ipcdev, type, *in);\r\nif (type == GTDRIVER_IPC || type == ISPDRIVER_IPC)\r\nipc_write_data_high(ipcdev, type, *++in);\r\n}\r\nval = cmd & ~IPC_PUNIT_CMD_TYPE_MASK;\r\nval |= CMD_RUN | para2 << CMD_PARA2_SHIFT | para1 << CMD_PARA1_SHIFT;\r\nipc_write_cmd(ipcdev, type, val);\r\nret = intel_punit_ipc_check_status(ipcdev, type);\r\nif (ret)\r\ngoto out;\r\nif (out) {\r\n*out = ipc_read_data_low(ipcdev, type);\r\nif (type == GTDRIVER_IPC || type == ISPDRIVER_IPC)\r\n*++out = ipc_read_data_high(ipcdev, type);\r\n}\r\nout:\r\nmutex_unlock(&ipcdev->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t intel_punit_ioc(int irq, void *dev_id)\r\n{\r\nIPC_DEV *ipcdev = dev_id;\r\ncomplete(&ipcdev->cmd_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int intel_punit_get_bars(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nvoid __iomem *addr;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(addr))\r\nreturn PTR_ERR(addr);\r\npunit_ipcdev->base[BIOS_IPC][BASE_DATA] = addr;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\naddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(addr))\r\nreturn PTR_ERR(addr);\r\npunit_ipcdev->base[BIOS_IPC][BASE_IFACE] = addr;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nif (res) {\r\naddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (!IS_ERR(addr))\r\npunit_ipcdev->base[ISPDRIVER_IPC][BASE_DATA] = addr;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 3);\r\nif (res) {\r\naddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (!IS_ERR(addr))\r\npunit_ipcdev->base[ISPDRIVER_IPC][BASE_IFACE] = addr;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 4);\r\nif (res) {\r\naddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (!IS_ERR(addr))\r\npunit_ipcdev->base[GTDRIVER_IPC][BASE_DATA] = addr;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 5);\r\nif (res) {\r\naddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (!IS_ERR(addr))\r\npunit_ipcdev->base[GTDRIVER_IPC][BASE_IFACE] = addr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel_punit_ipc_probe(struct platform_device *pdev)\r\n{\r\nint irq, ret;\r\npunit_ipcdev = devm_kzalloc(&pdev->dev,\r\nsizeof(*punit_ipcdev), GFP_KERNEL);\r\nif (!punit_ipcdev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, punit_ipcdev);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\npunit_ipcdev->irq = 0;\r\ndev_warn(&pdev->dev, "Invalid IRQ, using polling mode\n");\r\n} else {\r\nret = devm_request_irq(&pdev->dev, irq, intel_punit_ioc,\r\nIRQF_NO_SUSPEND, "intel_punit_ipc",\r\n&punit_ipcdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq: %d\n", irq);\r\nreturn ret;\r\n}\r\npunit_ipcdev->irq = irq;\r\n}\r\nret = intel_punit_get_bars(pdev);\r\nif (ret)\r\ngoto out;\r\npunit_ipcdev->dev = &pdev->dev;\r\nmutex_init(&punit_ipcdev->lock);\r\ninit_completion(&punit_ipcdev->cmd_complete);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int intel_punit_ipc_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init intel_punit_ipc_init(void)\r\n{\r\nreturn platform_driver_register(&intel_punit_ipc_driver);\r\n}\r\nstatic void __exit intel_punit_ipc_exit(void)\r\n{\r\nplatform_driver_unregister(&intel_punit_ipc_driver);\r\n}
