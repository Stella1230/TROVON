static void omap_pcm_limit_supported_formats(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SNDRV_PCM_FORMAT_LAST; i++) {\r\nswitch (snd_pcm_format_physical_width(i)) {\r\ncase 8:\r\ncase 16:\r\ncase 32:\r\nomap_pcm_hardware.formats |= (1LL << i);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int omap_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct omap_pcm_dma_data *dma_data;\r\nstruct dma_slave_config config;\r\nstruct dma_chan *chan;\r\nint err = 0;\r\nmemset(&config, 0x00, sizeof(config));\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (!dma_data)\r\nreturn 0;\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nruntime->dma_bytes = params_buffer_bytes(params);\r\nchan = snd_dmaengine_pcm_get_chan(substream);\r\nif (!chan)\r\nreturn -EINVAL;\r\nerr = snd_hwparams_to_dma_slave_config(substream, params, &config);\r\nif (err)\r\nreturn err;\r\nsnd_dmaengine_pcm_set_config_from_dai_data(substream,\r\nsnd_soc_dai_get_dma_data(rtd->cpu_dai, substream),\r\n&config);\r\nreturn dmaengine_slave_config(chan, &config);\r\n}\r\nstatic int omap_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t omap_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_uframes_t offset;\r\nif (pcm_omap1510())\r\noffset = snd_dmaengine_pcm_pointer_no_residue(substream);\r\nelse\r\noffset = snd_dmaengine_pcm_pointer(substream);\r\nreturn offset;\r\n}\r\nstatic int omap_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nint ret;\r\nsnd_soc_set_runtime_hwparams(substream, &omap_pcm_hardware);\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (rtd->cpu_dai->dev->of_node) {\r\nstruct dma_chan *chan;\r\nchan = dma_request_slave_channel(rtd->cpu_dai->dev,\r\ndma_data->filter_data);\r\nret = snd_dmaengine_pcm_open(substream, chan);\r\n} else {\r\nret = snd_dmaengine_pcm_open_request_chan(substream,\r\nomap_dma_filter_fn,\r\ndma_data->filter_data);\r\n}\r\nreturn ret;\r\n}\r\nstatic int omap_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nreturn dma_mmap_wc(substream->pcm->card->dev, vma, runtime->dma_area,\r\nruntime->dma_addr, runtime->dma_bytes);\r\n}\r\nstatic int omap_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,\r\nint stream)\r\n{\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nsize_t size = omap_pcm_hardware.buffer_bytes_max;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->private_data = NULL;\r\nbuf->area = dma_alloc_wc(pcm->card->dev, size, &buf->addr, GFP_KERNEL);\r\nif (!buf->area)\r\nreturn -ENOMEM;\r\nbuf->bytes = size;\r\nreturn 0;\r\n}\r\nstatic void omap_pcm_free_dma_buffers(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nint stream;\r\nfor (stream = 0; stream < 2; stream++) {\r\nsubstream = pcm->streams[stream].substream;\r\nif (!substream)\r\ncontinue;\r\nbuf = &substream->dma_buffer;\r\nif (!buf->area)\r\ncontinue;\r\ndma_free_wc(pcm->card->dev, buf->bytes, buf->area, buf->addr);\r\nbuf->area = NULL;\r\n}\r\n}\r\nstatic int omap_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret;\r\nret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nret = omap_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nret = omap_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_CAPTURE);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\nif (ret)\r\nomap_pcm_free_dma_buffers(pcm);\r\nreturn ret;\r\n}\r\nint omap_pcm_platform_register(struct device *dev)\r\n{\r\nomap_pcm_limit_supported_formats();\r\nreturn devm_snd_soc_register_platform(dev, &omap_soc_platform);\r\n}
