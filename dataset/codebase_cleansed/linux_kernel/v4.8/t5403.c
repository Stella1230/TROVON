static int t5403_read(struct t5403_data *data, bool pressure)\r\n{\r\nint wait_time = 3;\r\nint ret = i2c_smbus_write_byte_data(data->client, T5403_COMMAND,\r\n(pressure ? (data->mode << T5403_MODE_SHIFT) : T5403_PT) |\r\nT5403_SCO);\r\nif (ret < 0)\r\nreturn ret;\r\nwait_time += pressure ? t5403_pressure_conv_ms[data->mode] : 2;\r\nmsleep(wait_time);\r\nreturn i2c_smbus_read_word_data(data->client, T5403_DATA);\r\n}\r\nstatic int t5403_comp_pressure(struct t5403_data *data, int *val, int *val2)\r\n{\r\nint ret;\r\ns16 t_r;\r\nu16 p_r;\r\ns32 S, O, X;\r\nmutex_lock(&data->lock);\r\nret = t5403_read(data, false);\r\nif (ret < 0)\r\ngoto done;\r\nt_r = ret;\r\nret = t5403_read(data, true);\r\nif (ret < 0)\r\ngoto done;\r\np_r = ret;\r\nS = T5403_C_U16(3) + (s32) T5403_C_U16(4) * t_r / 0x20000 +\r\nT5403_C(5) * t_r / 0x8000 * t_r / 0x80000 +\r\nT5403_C(9) * t_r / 0x8000 * t_r / 0x8000 * t_r / 0x10000;\r\nO = T5403_C(6) * 0x4000 + T5403_C(7) * t_r / 8 +\r\nT5403_C(8) * t_r / 0x8000 * t_r / 16 +\r\nT5403_C(9) * t_r / 0x8000 * t_r / 0x10000 * t_r;\r\nX = (S * p_r + O) / 0x4000;\r\nX += ((X - 75000) * (X - 75000) / 0x10000 - 9537) *\r\nT5403_C(10) / 0x10000;\r\n*val = X / 1000;\r\n*val2 = (X % 1000) * 1000;\r\ndone:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int t5403_comp_temp(struct t5403_data *data, int *val)\r\n{\r\nint ret;\r\ns16 t_r;\r\nmutex_lock(&data->lock);\r\nret = t5403_read(data, false);\r\nif (ret < 0)\r\ngoto done;\r\nt_r = ret;\r\n*val = ((s32) T5403_C_U16(1) * t_r / 0x100 +\r\n(s32) T5403_C_U16(2) * 0x40) * 1000 / 0x10000;\r\ndone:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int t5403_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct t5403_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (chan->type) {\r\ncase IIO_PRESSURE:\r\nret = t5403_comp_pressure(data, val, val2);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_TEMP:\r\nret = t5403_comp_temp(data, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_INT_TIME:\r\n*val = 0;\r\n*val2 = t5403_pressure_conv_ms[data->mode] * 1000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int t5403_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct t5403_data *data = iio_priv(indio_dev);\r\nint i;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nif (val != 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(t5403_pressure_conv_ms); i++)\r\nif (val2 == t5403_pressure_conv_ms[i] * 1000) {\r\nmutex_lock(&data->lock);\r\ndata->mode = i;\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int t5403_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct t5403_data *data;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -EOPNOTSUPP;\r\nret = i2c_smbus_read_byte_data(client, T5403_SLAVE_ADDR);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((ret & T5403_I2C_MASK) != T5403_I2C_ADDR)\r\nreturn -ENODEV;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ndata->client = client;\r\nmutex_init(&data->lock);\r\ni2c_set_clientdata(client, indio_dev);\r\nindio_dev->info = &t5403_info;\r\nindio_dev->name = id->name;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = t5403_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(t5403_channels);\r\ndata->mode = T5403_MODE_STANDARD;\r\nret = i2c_smbus_read_i2c_block_data(data->client, T5403_CALIB_DATA,\r\nsizeof(data->c), (u8 *) data->c);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn devm_iio_device_register(&client->dev, indio_dev);\r\n}
