static inline size_t merge_bytes(u8 high, u8 low)\r\n{\r\nreturn (high << 8) + low;\r\n}\r\nstatic void cyttsp4_pr_buf(struct device *dev, u8 *pr_buf, u8 *dptr, int size,\r\nconst char *data_name)\r\n{\r\nint i, k;\r\nconst char fmt[] = "%02X ";\r\nint max;\r\nif (!size)\r\nreturn;\r\nmax = (CY_MAX_PRBUF_SIZE - 1) - sizeof(CY_PR_TRUNCATED);\r\npr_buf[0] = 0;\r\nfor (i = k = 0; i < size && k < max; i++, k += 3)\r\nscnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, dptr[i]);\r\ndev_vdbg(dev, "%s: %s[0..%d]=%s%s\n", __func__, data_name, size - 1,\r\npr_buf, size <= max ? "" : CY_PR_TRUNCATED);\r\n}\r\nstatic int cyttsp4_load_status_regs(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nstruct device *dev = cd->dev;\r\nint rc;\r\nrc = cyttsp4_adap_read(cd, CY_REG_BASE, si->si_ofs.mode_size,\r\nsi->xy_mode);\r\nif (rc < 0)\r\ndev_err(dev, "%s: fail read mode regs r=%d\n",\r\n__func__, rc);\r\nelse\r\ncyttsp4_pr_buf(dev, cd->pr_buf, si->xy_mode,\r\nsi->si_ofs.mode_size, "xy_mode");\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_handshake(struct cyttsp4 *cd, u8 mode)\r\n{\r\nu8 cmd = mode ^ CY_HST_TOGGLE;\r\nint rc;\r\nif (mode & CY_HST_MODE_CHANGE)\r\nreturn 0;\r\nrc = cyttsp4_adap_write(cd, CY_REG_BASE, sizeof(cmd), &cmd);\r\nif (rc < 0)\r\ndev_err(cd->dev, "%s: bus write fail on handshake (ret=%d)\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_hw_soft_reset(struct cyttsp4 *cd)\r\n{\r\nu8 cmd = CY_HST_RESET;\r\nint rc = cyttsp4_adap_write(cd, CY_REG_BASE, sizeof(cmd), &cmd);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: FAILED to execute SOFT reset\n",\r\n__func__);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyttsp4_hw_hard_reset(struct cyttsp4 *cd)\r\n{\r\nif (cd->cpdata->xres) {\r\ncd->cpdata->xres(cd->cpdata, cd->dev);\r\ndev_dbg(cd->dev, "%s: execute HARD reset\n", __func__);\r\nreturn 0;\r\n}\r\ndev_err(cd->dev, "%s: FAILED to execute HARD reset\n", __func__);\r\nreturn -ENOSYS;\r\n}\r\nstatic int cyttsp4_hw_reset(struct cyttsp4 *cd)\r\n{\r\nint rc = cyttsp4_hw_hard_reset(cd);\r\nif (rc == -ENOSYS)\r\nrc = cyttsp4_hw_soft_reset(cd);\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_bits_2_bytes(unsigned int nbits, size_t *max)\r\n{\r\n*max = 1UL << nbits;\r\nreturn (nbits + 7) / 8;\r\n}\r\nstatic int cyttsp4_si_data_offsets(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nint rc = cyttsp4_adap_read(cd, CY_REG_BASE, sizeof(si->si_data),\r\n&si->si_data);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: fail read sysinfo data offsets r=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\ncyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)&si->si_data,\r\nsizeof(si->si_data), "sysinfo_data_offsets");\r\nsi->si_ofs.map_sz = merge_bytes(si->si_data.map_szh,\r\nsi->si_data.map_szl);\r\nsi->si_ofs.map_sz = merge_bytes(si->si_data.map_szh,\r\nsi->si_data.map_szl);\r\nsi->si_ofs.cydata_ofs = merge_bytes(si->si_data.cydata_ofsh,\r\nsi->si_data.cydata_ofsl);\r\nsi->si_ofs.test_ofs = merge_bytes(si->si_data.test_ofsh,\r\nsi->si_data.test_ofsl);\r\nsi->si_ofs.pcfg_ofs = merge_bytes(si->si_data.pcfg_ofsh,\r\nsi->si_data.pcfg_ofsl);\r\nsi->si_ofs.opcfg_ofs = merge_bytes(si->si_data.opcfg_ofsh,\r\nsi->si_data.opcfg_ofsl);\r\nsi->si_ofs.ddata_ofs = merge_bytes(si->si_data.ddata_ofsh,\r\nsi->si_data.ddata_ofsl);\r\nsi->si_ofs.mdata_ofs = merge_bytes(si->si_data.mdata_ofsh,\r\nsi->si_data.mdata_ofsl);\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_si_get_cydata(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nint read_offset;\r\nint mfgid_sz, calc_mfgid_sz;\r\nvoid *p;\r\nint rc;\r\nsi->si_ofs.cydata_size = si->si_ofs.test_ofs - si->si_ofs.cydata_ofs;\r\ndev_dbg(cd->dev, "%s: cydata size: %Zd\n", __func__,\r\nsi->si_ofs.cydata_size);\r\np = krealloc(si->si_ptrs.cydata, si->si_ofs.cydata_size, GFP_KERNEL);\r\nif (p == NULL) {\r\ndev_err(cd->dev, "%s: fail alloc cydata memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nsi->si_ptrs.cydata = p;\r\nread_offset = si->si_ofs.cydata_ofs;\r\nrc = cyttsp4_adap_read(cd, read_offset,\r\noffsetof(struct cyttsp4_cydata, mfgid_sz)\r\n+ sizeof(si->si_ptrs.cydata->mfgid_sz),\r\nsi->si_ptrs.cydata);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: fail read cydata r=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nmfgid_sz = si->si_ptrs.cydata->mfgid_sz;\r\ncalc_mfgid_sz = si->si_ofs.cydata_size - sizeof(struct cyttsp4_cydata);\r\nif (mfgid_sz != calc_mfgid_sz) {\r\ndev_err(cd->dev, "%s: mismatch in MFGID size, reported:%d calculated:%d\n",\r\n__func__, mfgid_sz, calc_mfgid_sz);\r\nreturn -EINVAL;\r\n}\r\nread_offset += offsetof(struct cyttsp4_cydata, mfgid_sz)\r\n+ sizeof(si->si_ptrs.cydata->mfgid_sz);\r\nrc = cyttsp4_adap_read(cd, read_offset, si->si_ptrs.cydata->mfgid_sz,\r\nsi->si_ptrs.cydata->mfg_id);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: fail read cydata r=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nread_offset += si->si_ptrs.cydata->mfgid_sz;\r\nrc = cyttsp4_adap_read(cd, read_offset,\r\nsizeof(struct cyttsp4_cydata)\r\n- offsetof(struct cyttsp4_cydata, cyito_idh),\r\n&si->si_ptrs.cydata->cyito_idh);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: fail read cydata r=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\ncyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)si->si_ptrs.cydata,\r\nsi->si_ofs.cydata_size, "sysinfo_cydata");\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_si_get_test_data(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nvoid *p;\r\nint rc;\r\nsi->si_ofs.test_size = si->si_ofs.pcfg_ofs - si->si_ofs.test_ofs;\r\np = krealloc(si->si_ptrs.test, si->si_ofs.test_size, GFP_KERNEL);\r\nif (p == NULL) {\r\ndev_err(cd->dev, "%s: fail alloc test memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nsi->si_ptrs.test = p;\r\nrc = cyttsp4_adap_read(cd, si->si_ofs.test_ofs, si->si_ofs.test_size,\r\nsi->si_ptrs.test);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: fail read test data r=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\ncyttsp4_pr_buf(cd->dev, cd->pr_buf,\r\n(u8 *)si->si_ptrs.test, si->si_ofs.test_size,\r\n"sysinfo_test_data");\r\nif (si->si_ptrs.test->post_codel &\r\nCY_POST_CODEL_WDG_RST)\r\ndev_info(cd->dev, "%s: %s codel=%02X\n",\r\n__func__, "Reset was a WATCHDOG RESET",\r\nsi->si_ptrs.test->post_codel);\r\nif (!(si->si_ptrs.test->post_codel &\r\nCY_POST_CODEL_CFG_DATA_CRC_FAIL))\r\ndev_info(cd->dev, "%s: %s codel=%02X\n", __func__,\r\n"Config Data CRC FAIL",\r\nsi->si_ptrs.test->post_codel);\r\nif (!(si->si_ptrs.test->post_codel &\r\nCY_POST_CODEL_PANEL_TEST_FAIL))\r\ndev_info(cd->dev, "%s: %s codel=%02X\n",\r\n__func__, "PANEL TEST FAIL",\r\nsi->si_ptrs.test->post_codel);\r\ndev_info(cd->dev, "%s: SCANNING is %s codel=%02X\n",\r\n__func__, si->si_ptrs.test->post_codel & 0x08 ?\r\n"ENABLED" : "DISABLED",\r\nsi->si_ptrs.test->post_codel);\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_si_get_pcfg_data(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nvoid *p;\r\nint rc;\r\nsi->si_ofs.pcfg_size = si->si_ofs.opcfg_ofs - si->si_ofs.pcfg_ofs;\r\np = krealloc(si->si_ptrs.pcfg, si->si_ofs.pcfg_size, GFP_KERNEL);\r\nif (p == NULL) {\r\nrc = -ENOMEM;\r\ndev_err(cd->dev, "%s: fail alloc pcfg memory r=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nsi->si_ptrs.pcfg = p;\r\nrc = cyttsp4_adap_read(cd, si->si_ofs.pcfg_ofs, si->si_ofs.pcfg_size,\r\nsi->si_ptrs.pcfg);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: fail read pcfg data r=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nsi->si_ofs.max_x = merge_bytes((si->si_ptrs.pcfg->res_xh\r\n& CY_PCFG_RESOLUTION_X_MASK), si->si_ptrs.pcfg->res_xl);\r\nsi->si_ofs.x_origin = !!(si->si_ptrs.pcfg->res_xh\r\n& CY_PCFG_ORIGIN_X_MASK);\r\nsi->si_ofs.max_y = merge_bytes((si->si_ptrs.pcfg->res_yh\r\n& CY_PCFG_RESOLUTION_Y_MASK), si->si_ptrs.pcfg->res_yl);\r\nsi->si_ofs.y_origin = !!(si->si_ptrs.pcfg->res_yh\r\n& CY_PCFG_ORIGIN_Y_MASK);\r\nsi->si_ofs.max_p = merge_bytes(si->si_ptrs.pcfg->max_zh,\r\nsi->si_ptrs.pcfg->max_zl);\r\ncyttsp4_pr_buf(cd->dev, cd->pr_buf,\r\n(u8 *)si->si_ptrs.pcfg,\r\nsi->si_ofs.pcfg_size, "sysinfo_pcfg_data");\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_si_get_opcfg_data(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nstruct cyttsp4_tch_abs_params *tch;\r\nstruct cyttsp4_tch_rec_params *tch_old, *tch_new;\r\nenum cyttsp4_tch_abs abs;\r\nint i;\r\nvoid *p;\r\nint rc;\r\nsi->si_ofs.opcfg_size = si->si_ofs.ddata_ofs - si->si_ofs.opcfg_ofs;\r\np = krealloc(si->si_ptrs.opcfg, si->si_ofs.opcfg_size, GFP_KERNEL);\r\nif (p == NULL) {\r\ndev_err(cd->dev, "%s: fail alloc opcfg memory\n", __func__);\r\nrc = -ENOMEM;\r\ngoto cyttsp4_si_get_opcfg_data_exit;\r\n}\r\nsi->si_ptrs.opcfg = p;\r\nrc = cyttsp4_adap_read(cd, si->si_ofs.opcfg_ofs, si->si_ofs.opcfg_size,\r\nsi->si_ptrs.opcfg);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: fail read opcfg data r=%d\n",\r\n__func__, rc);\r\ngoto cyttsp4_si_get_opcfg_data_exit;\r\n}\r\nsi->si_ofs.cmd_ofs = si->si_ptrs.opcfg->cmd_ofs;\r\nsi->si_ofs.rep_ofs = si->si_ptrs.opcfg->rep_ofs;\r\nsi->si_ofs.rep_sz = (si->si_ptrs.opcfg->rep_szh * 256) +\r\nsi->si_ptrs.opcfg->rep_szl;\r\nsi->si_ofs.num_btns = si->si_ptrs.opcfg->num_btns;\r\nsi->si_ofs.num_btn_regs = (si->si_ofs.num_btns +\r\nCY_NUM_BTN_PER_REG - 1) / CY_NUM_BTN_PER_REG;\r\nsi->si_ofs.tt_stat_ofs = si->si_ptrs.opcfg->tt_stat_ofs;\r\nsi->si_ofs.obj_cfg0 = si->si_ptrs.opcfg->obj_cfg0;\r\nsi->si_ofs.max_tchs = si->si_ptrs.opcfg->max_tchs &\r\nCY_BYTE_OFS_MASK;\r\nsi->si_ofs.tch_rec_size = si->si_ptrs.opcfg->tch_rec_size &\r\nCY_BYTE_OFS_MASK;\r\nfor (abs = CY_TCH_X; abs < CY_NUM_TCH_FIELDS; abs++) {\r\ntch = &si->si_ofs.tch_abs[abs];\r\ntch_old = &si->si_ptrs.opcfg->tch_rec_old[abs];\r\ntch->ofs = tch_old->loc & CY_BYTE_OFS_MASK;\r\ntch->size = cyttsp4_bits_2_bytes(tch_old->size,\r\n&tch->max);\r\ntch->bofs = (tch_old->loc & CY_BOFS_MASK) >> CY_BOFS_SHIFT;\r\n}\r\nsi->si_ofs.btn_rec_size = si->si_ptrs.opcfg->btn_rec_size;\r\nsi->si_ofs.btn_diff_ofs = si->si_ptrs.opcfg->btn_diff_ofs;\r\nsi->si_ofs.btn_diff_size = si->si_ptrs.opcfg->btn_diff_size;\r\nif (si->si_ofs.tch_rec_size > CY_TMA1036_TCH_REC_SIZE) {\r\nfor (i = 0; i < CY_NUM_EXT_TCH_FIELDS; abs++, i++) {\r\ntch = &si->si_ofs.tch_abs[abs];\r\ntch_new = &si->si_ptrs.opcfg->tch_rec_new[i];\r\ntch->ofs = tch_new->loc & CY_BYTE_OFS_MASK;\r\ntch->size = cyttsp4_bits_2_bytes(tch_new->size,\r\n&tch->max);\r\ntch->bofs = (tch_new->loc & CY_BOFS_MASK) >> CY_BOFS_SHIFT;\r\n}\r\n}\r\nfor (abs = 0; abs < CY_TCH_NUM_ABS; abs++) {\r\ndev_dbg(cd->dev, "%s: tch_rec_%s\n", __func__,\r\ncyttsp4_tch_abs_string[abs]);\r\ndev_dbg(cd->dev, "%s: ofs =%2Zd\n", __func__,\r\nsi->si_ofs.tch_abs[abs].ofs);\r\ndev_dbg(cd->dev, "%s: siz =%2Zd\n", __func__,\r\nsi->si_ofs.tch_abs[abs].size);\r\ndev_dbg(cd->dev, "%s: max =%2Zd\n", __func__,\r\nsi->si_ofs.tch_abs[abs].max);\r\ndev_dbg(cd->dev, "%s: bofs=%2Zd\n", __func__,\r\nsi->si_ofs.tch_abs[abs].bofs);\r\n}\r\nsi->si_ofs.mode_size = si->si_ofs.tt_stat_ofs + 1;\r\nsi->si_ofs.data_size = si->si_ofs.max_tchs *\r\nsi->si_ptrs.opcfg->tch_rec_size;\r\ncyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)si->si_ptrs.opcfg,\r\nsi->si_ofs.opcfg_size, "sysinfo_opcfg_data");\r\ncyttsp4_si_get_opcfg_data_exit:\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_si_get_ddata(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nvoid *p;\r\nint rc;\r\nsi->si_ofs.ddata_size = si->si_ofs.mdata_ofs - si->si_ofs.ddata_ofs;\r\np = krealloc(si->si_ptrs.ddata, si->si_ofs.ddata_size, GFP_KERNEL);\r\nif (p == NULL) {\r\ndev_err(cd->dev, "%s: fail alloc ddata memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nsi->si_ptrs.ddata = p;\r\nrc = cyttsp4_adap_read(cd, si->si_ofs.ddata_ofs, si->si_ofs.ddata_size,\r\nsi->si_ptrs.ddata);\r\nif (rc < 0)\r\ndev_err(cd->dev, "%s: fail read ddata data r=%d\n",\r\n__func__, rc);\r\nelse\r\ncyttsp4_pr_buf(cd->dev, cd->pr_buf,\r\n(u8 *)si->si_ptrs.ddata,\r\nsi->si_ofs.ddata_size, "sysinfo_ddata");\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_si_get_mdata(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nvoid *p;\r\nint rc;\r\nsi->si_ofs.mdata_size = si->si_ofs.map_sz - si->si_ofs.mdata_ofs;\r\np = krealloc(si->si_ptrs.mdata, si->si_ofs.mdata_size, GFP_KERNEL);\r\nif (p == NULL) {\r\ndev_err(cd->dev, "%s: fail alloc mdata memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nsi->si_ptrs.mdata = p;\r\nrc = cyttsp4_adap_read(cd, si->si_ofs.mdata_ofs, si->si_ofs.mdata_size,\r\nsi->si_ptrs.mdata);\r\nif (rc < 0)\r\ndev_err(cd->dev, "%s: fail read mdata data r=%d\n",\r\n__func__, rc);\r\nelse\r\ncyttsp4_pr_buf(cd->dev, cd->pr_buf,\r\n(u8 *)si->si_ptrs.mdata,\r\nsi->si_ofs.mdata_size, "sysinfo_mdata");\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_si_get_btn_data(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nint btn;\r\nint num_defined_keys;\r\nu16 *key_table;\r\nvoid *p;\r\nint rc = 0;\r\nif (si->si_ofs.num_btns) {\r\nsi->si_ofs.btn_keys_size = si->si_ofs.num_btns *\r\nsizeof(struct cyttsp4_btn);\r\np = krealloc(si->btn, si->si_ofs.btn_keys_size,\r\nGFP_KERNEL|__GFP_ZERO);\r\nif (p == NULL) {\r\ndev_err(cd->dev, "%s: %s\n", __func__,\r\n"fail alloc btn_keys memory");\r\nreturn -ENOMEM;\r\n}\r\nsi->btn = p;\r\nif (cd->cpdata->sett[CY_IC_GRPNUM_BTN_KEYS] == NULL)\r\nnum_defined_keys = 0;\r\nelse if (cd->cpdata->sett[CY_IC_GRPNUM_BTN_KEYS]->data == NULL)\r\nnum_defined_keys = 0;\r\nelse\r\nnum_defined_keys = cd->cpdata->sett\r\n[CY_IC_GRPNUM_BTN_KEYS]->size;\r\nfor (btn = 0; btn < si->si_ofs.num_btns &&\r\nbtn < num_defined_keys; btn++) {\r\nkey_table = (u16 *)cd->cpdata->sett\r\n[CY_IC_GRPNUM_BTN_KEYS]->data;\r\nsi->btn[btn].key_code = key_table[btn];\r\nsi->btn[btn].state = CY_BTN_RELEASED;\r\nsi->btn[btn].enabled = true;\r\n}\r\nfor (; btn < si->si_ofs.num_btns; btn++) {\r\nsi->btn[btn].key_code = KEY_RESERVED;\r\nsi->btn[btn].state = CY_BTN_RELEASED;\r\nsi->btn[btn].enabled = true;\r\n}\r\nreturn rc;\r\n}\r\nsi->si_ofs.btn_keys_size = 0;\r\nkfree(si->btn);\r\nsi->btn = NULL;\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_si_get_op_data_ptrs(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nvoid *p;\r\np = krealloc(si->xy_mode, si->si_ofs.mode_size, GFP_KERNEL|__GFP_ZERO);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nsi->xy_mode = p;\r\np = krealloc(si->xy_data, si->si_ofs.data_size, GFP_KERNEL|__GFP_ZERO);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nsi->xy_data = p;\r\np = krealloc(si->btn_rec_data,\r\nsi->si_ofs.btn_rec_size * si->si_ofs.num_btns,\r\nGFP_KERNEL|__GFP_ZERO);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nsi->btn_rec_data = p;\r\nreturn 0;\r\n}\r\nstatic void cyttsp4_si_put_log_data(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\ndev_dbg(cd->dev, "%s: cydata_ofs =%4Zd siz=%4Zd\n", __func__,\r\nsi->si_ofs.cydata_ofs, si->si_ofs.cydata_size);\r\ndev_dbg(cd->dev, "%s: test_ofs =%4Zd siz=%4Zd\n", __func__,\r\nsi->si_ofs.test_ofs, si->si_ofs.test_size);\r\ndev_dbg(cd->dev, "%s: pcfg_ofs =%4Zd siz=%4Zd\n", __func__,\r\nsi->si_ofs.pcfg_ofs, si->si_ofs.pcfg_size);\r\ndev_dbg(cd->dev, "%s: opcfg_ofs =%4Zd siz=%4Zd\n", __func__,\r\nsi->si_ofs.opcfg_ofs, si->si_ofs.opcfg_size);\r\ndev_dbg(cd->dev, "%s: ddata_ofs =%4Zd siz=%4Zd\n", __func__,\r\nsi->si_ofs.ddata_ofs, si->si_ofs.ddata_size);\r\ndev_dbg(cd->dev, "%s: mdata_ofs =%4Zd siz=%4Zd\n", __func__,\r\nsi->si_ofs.mdata_ofs, si->si_ofs.mdata_size);\r\ndev_dbg(cd->dev, "%s: cmd_ofs =%4Zd\n", __func__,\r\nsi->si_ofs.cmd_ofs);\r\ndev_dbg(cd->dev, "%s: rep_ofs =%4Zd\n", __func__,\r\nsi->si_ofs.rep_ofs);\r\ndev_dbg(cd->dev, "%s: rep_sz =%4Zd\n", __func__,\r\nsi->si_ofs.rep_sz);\r\ndev_dbg(cd->dev, "%s: num_btns =%4Zd\n", __func__,\r\nsi->si_ofs.num_btns);\r\ndev_dbg(cd->dev, "%s: num_btn_regs =%4Zd\n", __func__,\r\nsi->si_ofs.num_btn_regs);\r\ndev_dbg(cd->dev, "%s: tt_stat_ofs =%4Zd\n", __func__,\r\nsi->si_ofs.tt_stat_ofs);\r\ndev_dbg(cd->dev, "%s: tch_rec_size =%4Zd\n", __func__,\r\nsi->si_ofs.tch_rec_size);\r\ndev_dbg(cd->dev, "%s: max_tchs =%4Zd\n", __func__,\r\nsi->si_ofs.max_tchs);\r\ndev_dbg(cd->dev, "%s: mode_size =%4Zd\n", __func__,\r\nsi->si_ofs.mode_size);\r\ndev_dbg(cd->dev, "%s: data_size =%4Zd\n", __func__,\r\nsi->si_ofs.data_size);\r\ndev_dbg(cd->dev, "%s: map_sz =%4Zd\n", __func__,\r\nsi->si_ofs.map_sz);\r\ndev_dbg(cd->dev, "%s: btn_rec_size =%2Zd\n", __func__,\r\nsi->si_ofs.btn_rec_size);\r\ndev_dbg(cd->dev, "%s: btn_diff_ofs =%2Zd\n", __func__,\r\nsi->si_ofs.btn_diff_ofs);\r\ndev_dbg(cd->dev, "%s: btn_diff_size =%2Zd\n", __func__,\r\nsi->si_ofs.btn_diff_size);\r\ndev_dbg(cd->dev, "%s: max_x = 0x%04ZX (%Zd)\n", __func__,\r\nsi->si_ofs.max_x, si->si_ofs.max_x);\r\ndev_dbg(cd->dev, "%s: x_origin = %Zd (%s)\n", __func__,\r\nsi->si_ofs.x_origin,\r\nsi->si_ofs.x_origin == CY_NORMAL_ORIGIN ?\r\n"left corner" : "right corner");\r\ndev_dbg(cd->dev, "%s: max_y = 0x%04ZX (%Zd)\n", __func__,\r\nsi->si_ofs.max_y, si->si_ofs.max_y);\r\ndev_dbg(cd->dev, "%s: y_origin = %Zd (%s)\n", __func__,\r\nsi->si_ofs.y_origin,\r\nsi->si_ofs.y_origin == CY_NORMAL_ORIGIN ?\r\n"upper corner" : "lower corner");\r\ndev_dbg(cd->dev, "%s: max_p = 0x%04ZX (%Zd)\n", __func__,\r\nsi->si_ofs.max_p, si->si_ofs.max_p);\r\ndev_dbg(cd->dev, "%s: xy_mode=%p xy_data=%p\n", __func__,\r\nsi->xy_mode, si->xy_data);\r\n}\r\nstatic int cyttsp4_get_sysinfo_regs(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nint rc;\r\nrc = cyttsp4_si_data_offsets(cd);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = cyttsp4_si_get_cydata(cd);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = cyttsp4_si_get_test_data(cd);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = cyttsp4_si_get_pcfg_data(cd);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = cyttsp4_si_get_opcfg_data(cd);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = cyttsp4_si_get_ddata(cd);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = cyttsp4_si_get_mdata(cd);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = cyttsp4_si_get_btn_data(cd);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = cyttsp4_si_get_op_data_ptrs(cd);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: failed to get_op_data\n",\r\n__func__);\r\nreturn rc;\r\n}\r\ncyttsp4_si_put_log_data(cd);\r\nrc = cyttsp4_handshake(cd, si->si_data.hst_mode);\r\nif (rc < 0)\r\ndev_err(cd->dev, "%s: handshake fail on sysinfo reg\n",\r\n__func__);\r\nsi->ready = true;\r\nreturn rc;\r\n}\r\nstatic void cyttsp4_queue_startup_(struct cyttsp4 *cd)\r\n{\r\nif (cd->startup_state == STARTUP_NONE) {\r\ncd->startup_state = STARTUP_QUEUED;\r\nschedule_work(&cd->startup_work);\r\ndev_dbg(cd->dev, "%s: cyttsp4_startup queued\n", __func__);\r\n} else {\r\ndev_dbg(cd->dev, "%s: startup_state = %d\n", __func__,\r\ncd->startup_state);\r\n}\r\n}\r\nstatic void cyttsp4_report_slot_liftoff(struct cyttsp4_mt_data *md,\r\nint max_slots)\r\n{\r\nint t;\r\nif (md->num_prv_tch == 0)\r\nreturn;\r\nfor (t = 0; t < max_slots; t++) {\r\ninput_mt_slot(md->input, t);\r\ninput_mt_report_slot_state(md->input,\r\nMT_TOOL_FINGER, false);\r\n}\r\n}\r\nstatic void cyttsp4_lift_all(struct cyttsp4_mt_data *md)\r\n{\r\nif (!md->si)\r\nreturn;\r\nif (md->num_prv_tch != 0) {\r\ncyttsp4_report_slot_liftoff(md,\r\nmd->si->si_ofs.tch_abs[CY_TCH_T].max);\r\ninput_sync(md->input);\r\nmd->num_prv_tch = 0;\r\n}\r\n}\r\nstatic void cyttsp4_get_touch_axis(struct cyttsp4_mt_data *md,\r\nint *axis, int size, int max, u8 *xy_data, int bofs)\r\n{\r\nint nbyte;\r\nint next;\r\nfor (nbyte = 0, *axis = 0, next = 0; nbyte < size; nbyte++) {\r\ndev_vdbg(&md->input->dev,\r\n"%s: *axis=%02X(%d) size=%d max=%08X xy_data=%p"\r\n" xy_data[%d]=%02X(%d) bofs=%d\n",\r\n__func__, *axis, *axis, size, max, xy_data, next,\r\nxy_data[next], xy_data[next], bofs);\r\n*axis = (*axis * 256) + (xy_data[next] >> bofs);\r\nnext++;\r\n}\r\n*axis &= max - 1;\r\ndev_vdbg(&md->input->dev,\r\n"%s: *axis=%02X(%d) size=%d max=%08X xy_data=%p"\r\n" xy_data[%d]=%02X(%d)\n",\r\n__func__, *axis, *axis, size, max, xy_data, next,\r\nxy_data[next], xy_data[next]);\r\n}\r\nstatic void cyttsp4_get_touch(struct cyttsp4_mt_data *md,\r\nstruct cyttsp4_touch *touch, u8 *xy_data)\r\n{\r\nstruct device *dev = &md->input->dev;\r\nstruct cyttsp4_sysinfo *si = md->si;\r\nenum cyttsp4_tch_abs abs;\r\nbool flipped;\r\nfor (abs = CY_TCH_X; abs < CY_TCH_NUM_ABS; abs++) {\r\ncyttsp4_get_touch_axis(md, &touch->abs[abs],\r\nsi->si_ofs.tch_abs[abs].size,\r\nsi->si_ofs.tch_abs[abs].max,\r\nxy_data + si->si_ofs.tch_abs[abs].ofs,\r\nsi->si_ofs.tch_abs[abs].bofs);\r\ndev_vdbg(dev, "%s: get %s=%04X(%d)\n", __func__,\r\ncyttsp4_tch_abs_string[abs],\r\ntouch->abs[abs], touch->abs[abs]);\r\n}\r\nif (md->pdata->flags & CY_FLAG_FLIP) {\r\nswap(touch->abs[CY_TCH_X], touch->abs[CY_TCH_Y]);\r\nflipped = true;\r\n} else\r\nflipped = false;\r\nif (md->pdata->flags & CY_FLAG_INV_X) {\r\nif (flipped)\r\ntouch->abs[CY_TCH_X] = md->si->si_ofs.max_y -\r\ntouch->abs[CY_TCH_X];\r\nelse\r\ntouch->abs[CY_TCH_X] = md->si->si_ofs.max_x -\r\ntouch->abs[CY_TCH_X];\r\n}\r\nif (md->pdata->flags & CY_FLAG_INV_Y) {\r\nif (flipped)\r\ntouch->abs[CY_TCH_Y] = md->si->si_ofs.max_x -\r\ntouch->abs[CY_TCH_Y];\r\nelse\r\ntouch->abs[CY_TCH_Y] = md->si->si_ofs.max_y -\r\ntouch->abs[CY_TCH_Y];\r\n}\r\ndev_vdbg(dev, "%s: flip=%s inv-x=%s inv-y=%s x=%04X(%d) y=%04X(%d)\n",\r\n__func__, flipped ? "true" : "false",\r\nmd->pdata->flags & CY_FLAG_INV_X ? "true" : "false",\r\nmd->pdata->flags & CY_FLAG_INV_Y ? "true" : "false",\r\ntouch->abs[CY_TCH_X], touch->abs[CY_TCH_X],\r\ntouch->abs[CY_TCH_Y], touch->abs[CY_TCH_Y]);\r\n}\r\nstatic void cyttsp4_final_sync(struct input_dev *input, int max_slots, int *ids)\r\n{\r\nint t;\r\nfor (t = 0; t < max_slots; t++) {\r\nif (ids[t])\r\ncontinue;\r\ninput_mt_slot(input, t);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, false);\r\n}\r\ninput_sync(input);\r\n}\r\nstatic void cyttsp4_get_mt_touches(struct cyttsp4_mt_data *md, int num_cur_tch)\r\n{\r\nstruct device *dev = &md->input->dev;\r\nstruct cyttsp4_sysinfo *si = md->si;\r\nstruct cyttsp4_touch tch;\r\nint sig;\r\nint i, j, t = 0;\r\nint ids[max(CY_TMA1036_MAX_TCH, CY_TMA4XX_MAX_TCH)];\r\nmemset(ids, 0, si->si_ofs.tch_abs[CY_TCH_T].max * sizeof(int));\r\nfor (i = 0; i < num_cur_tch; i++) {\r\ncyttsp4_get_touch(md, &tch, si->xy_data +\r\n(i * si->si_ofs.tch_rec_size));\r\nif ((tch.abs[CY_TCH_T] < md->pdata->frmwrk->abs\r\n[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MIN_OST]) ||\r\n(tch.abs[CY_TCH_T] > md->pdata->frmwrk->abs\r\n[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MAX_OST])) {\r\ndev_err(dev, "%s: tch=%d -> bad trk_id=%d max_id=%d\n",\r\n__func__, i, tch.abs[CY_TCH_T],\r\nmd->pdata->frmwrk->abs[(CY_ABS_ID_OST *\r\nCY_NUM_ABS_SET) + CY_MAX_OST]);\r\ncontinue;\r\n}\r\nsig = md->pdata->frmwrk->abs\r\n[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + 0];\r\nif (sig != CY_IGNORE_VALUE) {\r\nt = tch.abs[CY_TCH_T] - md->pdata->frmwrk->abs\r\n[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MIN_OST];\r\nif (tch.abs[CY_TCH_E] == CY_EV_LIFTOFF) {\r\ndev_dbg(dev, "%s: t=%d e=%d lift-off\n",\r\n__func__, t, tch.abs[CY_TCH_E]);\r\ngoto cyttsp4_get_mt_touches_pr_tch;\r\n}\r\ninput_mt_slot(md->input, t);\r\ninput_mt_report_slot_state(md->input, MT_TOOL_FINGER,\r\ntrue);\r\nids[t] = true;\r\n}\r\nfor (j = 0; j <= CY_ABS_W_OST; j++) {\r\nsig = md->pdata->frmwrk->abs[((CY_ABS_X_OST + j) *\r\nCY_NUM_ABS_SET) + 0];\r\nif (sig != CY_IGNORE_VALUE)\r\ninput_report_abs(md->input, sig,\r\ntch.abs[CY_TCH_X + j]);\r\n}\r\nif (si->si_ofs.tch_rec_size > CY_TMA1036_TCH_REC_SIZE) {\r\nif (tch.abs[CY_TCH_P] > 0 && tch.abs[CY_TCH_MAJ] == 0)\r\ntch.abs[CY_TCH_MAJ] = tch.abs[CY_TCH_MIN] = 1;\r\nfor (j = 0; j < CY_NUM_EXT_TCH_FIELDS; j++) {\r\nsig = md->pdata->frmwrk->abs\r\n[((CY_ABS_MAJ_OST + j) *\r\nCY_NUM_ABS_SET) + 0];\r\nif (sig != CY_IGNORE_VALUE)\r\ninput_report_abs(md->input, sig,\r\ntch.abs[CY_TCH_MAJ + j]);\r\n}\r\n}\r\ncyttsp4_get_mt_touches_pr_tch:\r\nif (si->si_ofs.tch_rec_size > CY_TMA1036_TCH_REC_SIZE)\r\ndev_dbg(dev,\r\n"%s: t=%d x=%d y=%d z=%d M=%d m=%d o=%d e=%d\n",\r\n__func__, t,\r\ntch.abs[CY_TCH_X],\r\ntch.abs[CY_TCH_Y],\r\ntch.abs[CY_TCH_P],\r\ntch.abs[CY_TCH_MAJ],\r\ntch.abs[CY_TCH_MIN],\r\ntch.abs[CY_TCH_OR],\r\ntch.abs[CY_TCH_E]);\r\nelse\r\ndev_dbg(dev,\r\n"%s: t=%d x=%d y=%d z=%d e=%d\n", __func__,\r\nt,\r\ntch.abs[CY_TCH_X],\r\ntch.abs[CY_TCH_Y],\r\ntch.abs[CY_TCH_P],\r\ntch.abs[CY_TCH_E]);\r\n}\r\ncyttsp4_final_sync(md->input, si->si_ofs.tch_abs[CY_TCH_T].max, ids);\r\nmd->num_prv_tch = num_cur_tch;\r\nreturn;\r\n}\r\nstatic int cyttsp4_xy_worker(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_mt_data *md = &cd->md;\r\nstruct device *dev = &md->input->dev;\r\nstruct cyttsp4_sysinfo *si = md->si;\r\nu8 num_cur_tch;\r\nu8 hst_mode;\r\nu8 rep_len;\r\nu8 rep_stat;\r\nu8 tt_stat;\r\nint rc = 0;\r\nhst_mode = si->xy_mode[CY_REG_BASE];\r\nrep_len = si->xy_mode[si->si_ofs.rep_ofs];\r\nrep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];\r\ntt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];\r\ndev_vdbg(dev, "%s: %s%02X %s%d %s%02X %s%02X\n", __func__,\r\n"hst_mode=", hst_mode, "rep_len=", rep_len,\r\n"rep_stat=", rep_stat, "tt_stat=", tt_stat);\r\nnum_cur_tch = GET_NUM_TOUCHES(tt_stat);\r\ndev_vdbg(dev, "%s: num_cur_tch=%d\n", __func__, num_cur_tch);\r\nif (rep_len == 0 && num_cur_tch > 0) {\r\ndev_err(dev, "%s: report length error rep_len=%d num_tch=%d\n",\r\n__func__, rep_len, num_cur_tch);\r\ngoto cyttsp4_xy_worker_exit;\r\n}\r\nif (num_cur_tch > 0) {\r\nrc = cyttsp4_adap_read(cd, si->si_ofs.tt_stat_ofs + 1,\r\nnum_cur_tch * si->si_ofs.tch_rec_size,\r\nsi->xy_data);\r\nif (rc < 0) {\r\ndev_err(dev, "%s: read fail on touch regs r=%d\n",\r\n__func__, rc);\r\ngoto cyttsp4_xy_worker_exit;\r\n}\r\n}\r\ncyttsp4_pr_buf(dev, cd->pr_buf, si->xy_data, num_cur_tch *\r\nsi->si_ofs.tch_rec_size, "xy_data");\r\nif (IS_BAD_PKT(rep_stat)) {\r\ndev_dbg(dev, "%s: Invalid buffer detected\n", __func__);\r\nrc = 0;\r\ngoto cyttsp4_xy_worker_exit;\r\n}\r\nif (IS_LARGE_AREA(tt_stat))\r\ndev_dbg(dev, "%s: Large area detected\n", __func__);\r\nif (num_cur_tch > si->si_ofs.max_tchs) {\r\ndev_err(dev, "%s: too many tch; set to max tch (n=%d c=%Zd)\n",\r\n__func__, num_cur_tch, si->si_ofs.max_tchs);\r\nnum_cur_tch = si->si_ofs.max_tchs;\r\n}\r\ndev_vdbg(dev, "%s: extract data num_cur_tch=%d\n", __func__,\r\nnum_cur_tch);\r\nif (num_cur_tch)\r\ncyttsp4_get_mt_touches(md, num_cur_tch);\r\nelse\r\ncyttsp4_lift_all(md);\r\nrc = 0;\r\ncyttsp4_xy_worker_exit:\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_mt_attention(struct cyttsp4 *cd)\r\n{\r\nstruct device *dev = cd->dev;\r\nstruct cyttsp4_mt_data *md = &cd->md;\r\nint rc = 0;\r\nif (!md->si)\r\nreturn 0;\r\nmutex_lock(&md->report_lock);\r\nif (!md->is_suspended) {\r\nrc = cyttsp4_xy_worker(cd);\r\n} else {\r\ndev_vdbg(dev, "%s: Ignoring report while suspended\n",\r\n__func__);\r\n}\r\nmutex_unlock(&md->report_lock);\r\nif (rc < 0)\r\ndev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic irqreturn_t cyttsp4_irq(int irq, void *handle)\r\n{\r\nstruct cyttsp4 *cd = handle;\r\nstruct device *dev = cd->dev;\r\nenum cyttsp4_mode cur_mode;\r\nu8 cmd_ofs = cd->sysinfo.si_ofs.cmd_ofs;\r\nu8 mode[3];\r\nint rc;\r\nif (atomic_read(&cd->ignore_irq)) {\r\ndev_vdbg(dev, "%s: Ignoring IRQ\n", __func__);\r\nreturn IRQ_HANDLED;\r\n}\r\ndev_dbg(dev, "%s int:0x%x\n", __func__, cd->int_status);\r\nmutex_lock(&cd->system_lock);\r\nif (cd->sleep_state == SS_SLEEP_ON || cd->sleep_state == SS_SLEEPING)\r\ndev_vdbg(dev, "%s: Received IRQ while in sleep\n", __func__);\r\nrc = cyttsp4_adap_read(cd, CY_REG_BASE, sizeof(mode), mode);\r\nif (rc) {\r\ndev_err(cd->dev, "%s: Fail read adapter r=%d\n", __func__, rc);\r\ngoto cyttsp4_irq_exit;\r\n}\r\ndev_vdbg(dev, "%s mode[0-2]:0x%X 0x%X 0x%X\n", __func__,\r\nmode[0], mode[1], mode[2]);\r\nif (IS_BOOTLOADER(mode[0], mode[1])) {\r\ncur_mode = CY_MODE_BOOTLOADER;\r\ndev_vdbg(dev, "%s: bl running\n", __func__);\r\nif (cd->mode == CY_MODE_BOOTLOADER) {\r\nwake_up(&cd->wait_q);\r\ngoto cyttsp4_irq_exit;\r\n}\r\ndev_dbg(dev, "%s: restart switch to bl m=%d -> m=%d\n",\r\n__func__, cd->mode, cur_mode);\r\nif (cd->mode != CY_MODE_UNKNOWN) {\r\ncd->mode = CY_MODE_UNKNOWN;\r\ncyttsp4_queue_startup_(cd);\r\ngoto cyttsp4_irq_exit;\r\n}\r\ncd->mode = cur_mode;\r\ngoto cyttsp4_irq_exit;\r\n}\r\nswitch (mode[0] & CY_HST_MODE) {\r\ncase CY_HST_OPERATE:\r\ncur_mode = CY_MODE_OPERATIONAL;\r\ndev_vdbg(dev, "%s: operational\n", __func__);\r\nbreak;\r\ncase CY_HST_CAT:\r\ncur_mode = CY_MODE_CAT;\r\ndev_vdbg(dev, "%s: CaT\n", __func__);\r\nbreak;\r\ncase CY_HST_SYSINFO:\r\ncur_mode = CY_MODE_SYSINFO;\r\ndev_vdbg(dev, "%s: sysinfo\n", __func__);\r\nbreak;\r\ndefault:\r\ncur_mode = CY_MODE_UNKNOWN;\r\ndev_err(dev, "%s: unknown HST mode 0x%02X\n", __func__,\r\nmode[0]);\r\nbreak;\r\n}\r\nif (cd->int_status & CY_INT_IGNORE) {\r\ndev_vdbg(dev, "%s: Ignoring IRQ\n", __func__);\r\ngoto cyttsp4_irq_exit;\r\n}\r\nif (cd->int_status & CY_INT_AWAKE) {\r\ncd->int_status &= ~CY_INT_AWAKE;\r\nwake_up(&cd->wait_q);\r\ndev_vdbg(dev, "%s: Received wake up interrupt\n", __func__);\r\ngoto cyttsp4_irq_handshake;\r\n}\r\nif ((cd->int_status & CY_INT_MODE_CHANGE)\r\n&& (mode[0] & CY_HST_MODE_CHANGE) == 0) {\r\ncd->int_status &= ~CY_INT_MODE_CHANGE;\r\ndev_dbg(dev, "%s: finish mode switch m=%d -> m=%d\n",\r\n__func__, cd->mode, cur_mode);\r\ncd->mode = cur_mode;\r\nwake_up(&cd->wait_q);\r\ngoto cyttsp4_irq_handshake;\r\n}\r\ndev_vdbg(dev, "%s: cd->mode=%d cur_mode=%d\n",\r\n__func__, cd->mode, cur_mode);\r\nif ((mode[0] & CY_HST_MODE_CHANGE) == 0 && cd->mode != cur_mode) {\r\ndev_err(dev, "%s %d->%d 0x%x\n", __func__, cd->mode,\r\ncur_mode, cd->int_status);\r\ndev_dbg(dev, "%s: Unexpected mode change, startup\n",\r\n__func__);\r\ncyttsp4_queue_startup_(cd);\r\ngoto cyttsp4_irq_exit;\r\n}\r\ndev_vdbg(dev, "%s: command byte:0x%x\n", __func__, mode[cmd_ofs]);\r\nif ((cd->int_status & CY_INT_EXEC_CMD)\r\n&& mode[cmd_ofs] & CY_CMD_COMPLETE) {\r\ncd->int_status &= ~CY_INT_EXEC_CMD;\r\ndev_vdbg(dev, "%s: Received command complete interrupt\n",\r\n__func__);\r\nwake_up(&cd->wait_q);\r\n}\r\nif (cd->mode == CY_MODE_OPERATIONAL) {\r\ndev_vdbg(dev, "%s: Read status registers\n", __func__);\r\nrc = cyttsp4_load_status_regs(cd);\r\nif (rc < 0)\r\ndev_err(dev, "%s: fail read mode regs r=%d\n",\r\n__func__, rc);\r\n}\r\ncyttsp4_mt_attention(cd);\r\ncyttsp4_irq_handshake:\r\ndev_vdbg(dev, "%s: Handshake mode=0x%02X r=%d\n",\r\n__func__, mode[0], rc);\r\nrc = cyttsp4_handshake(cd, mode[0]);\r\nif (rc < 0)\r\ndev_err(dev, "%s: Fail handshake mode=0x%02X r=%d\n",\r\n__func__, mode[0], rc);\r\nudelay(cd->cpdata->level_irq_udelay);\r\ncyttsp4_irq_exit:\r\nmutex_unlock(&cd->system_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cyttsp4_start_wd_timer(struct cyttsp4 *cd)\r\n{\r\nif (!CY_WATCHDOG_TIMEOUT)\r\nreturn;\r\nmod_timer(&cd->watchdog_timer, jiffies +\r\nmsecs_to_jiffies(CY_WATCHDOG_TIMEOUT));\r\n}\r\nstatic void cyttsp4_stop_wd_timer(struct cyttsp4 *cd)\r\n{\r\nif (!CY_WATCHDOG_TIMEOUT)\r\nreturn;\r\ndel_timer_sync(&cd->watchdog_timer);\r\ncancel_work_sync(&cd->watchdog_work);\r\ndel_timer_sync(&cd->watchdog_timer);\r\n}\r\nstatic void cyttsp4_watchdog_timer(unsigned long handle)\r\n{\r\nstruct cyttsp4 *cd = (struct cyttsp4 *)handle;\r\ndev_vdbg(cd->dev, "%s: Watchdog timer triggered\n", __func__);\r\nschedule_work(&cd->watchdog_work);\r\nreturn;\r\n}\r\nstatic int cyttsp4_request_exclusive(struct cyttsp4 *cd, void *ownptr,\r\nint timeout_ms)\r\n{\r\nint t = msecs_to_jiffies(timeout_ms);\r\nbool with_timeout = (timeout_ms != 0);\r\nmutex_lock(&cd->system_lock);\r\nif (!cd->exclusive_dev && cd->exclusive_waits == 0) {\r\ncd->exclusive_dev = ownptr;\r\ngoto exit;\r\n}\r\ncd->exclusive_waits++;\r\nwait:\r\nmutex_unlock(&cd->system_lock);\r\nif (with_timeout) {\r\nt = wait_event_timeout(cd->wait_q, !cd->exclusive_dev, t);\r\nif (IS_TMO(t)) {\r\ndev_err(cd->dev, "%s: tmo waiting exclusive access\n",\r\n__func__);\r\nmutex_lock(&cd->system_lock);\r\ncd->exclusive_waits--;\r\nmutex_unlock(&cd->system_lock);\r\nreturn -ETIME;\r\n}\r\n} else {\r\nwait_event(cd->wait_q, !cd->exclusive_dev);\r\n}\r\nmutex_lock(&cd->system_lock);\r\nif (cd->exclusive_dev)\r\ngoto wait;\r\ncd->exclusive_dev = ownptr;\r\ncd->exclusive_waits--;\r\nexit:\r\nmutex_unlock(&cd->system_lock);\r\nreturn 0;\r\n}\r\nstatic int cyttsp4_release_exclusive(struct cyttsp4 *cd, void *ownptr)\r\n{\r\nmutex_lock(&cd->system_lock);\r\nif (cd->exclusive_dev != ownptr) {\r\nmutex_unlock(&cd->system_lock);\r\nreturn -EINVAL;\r\n}\r\ndev_vdbg(cd->dev, "%s: exclusive_dev %p freed\n",\r\n__func__, cd->exclusive_dev);\r\ncd->exclusive_dev = NULL;\r\nwake_up(&cd->wait_q);\r\nmutex_unlock(&cd->system_lock);\r\nreturn 0;\r\n}\r\nstatic int cyttsp4_wait_bl_heartbeat(struct cyttsp4 *cd)\r\n{\r\nlong t;\r\nint rc = 0;\r\ndev_vdbg(cd->dev, "%s: wait heartbeat...\n", __func__);\r\nt = wait_event_timeout(cd->wait_q, cd->mode == CY_MODE_BOOTLOADER,\r\nmsecs_to_jiffies(CY_CORE_RESET_AND_WAIT_TIMEOUT));\r\nif (IS_TMO(t)) {\r\ndev_err(cd->dev, "%s: tmo waiting bl heartbeat cd->mode=%d\n",\r\n__func__, cd->mode);\r\nrc = -ETIME;\r\n}\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_wait_sysinfo_mode(struct cyttsp4 *cd)\r\n{\r\nlong t;\r\ndev_vdbg(cd->dev, "%s: wait sysinfo...\n", __func__);\r\nt = wait_event_timeout(cd->wait_q, cd->mode == CY_MODE_SYSINFO,\r\nmsecs_to_jiffies(CY_CORE_MODE_CHANGE_TIMEOUT));\r\nif (IS_TMO(t)) {\r\ndev_err(cd->dev, "%s: tmo waiting exit bl cd->mode=%d\n",\r\n__func__, cd->mode);\r\nmutex_lock(&cd->system_lock);\r\ncd->int_status &= ~CY_INT_MODE_CHANGE;\r\nmutex_unlock(&cd->system_lock);\r\nreturn -ETIME;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyttsp4_reset_and_wait(struct cyttsp4 *cd)\r\n{\r\nint rc;\r\nmutex_lock(&cd->system_lock);\r\ndev_dbg(cd->dev, "%s: reset hw...\n", __func__);\r\nrc = cyttsp4_hw_reset(cd);\r\ncd->mode = CY_MODE_UNKNOWN;\r\nmutex_unlock(&cd->system_lock);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s:Fail hw reset r=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nreturn cyttsp4_wait_bl_heartbeat(cd);\r\n}\r\nstatic int cyttsp4_set_mode(struct cyttsp4 *cd, int new_mode)\r\n{\r\nu8 new_dev_mode;\r\nu8 mode;\r\nlong t;\r\nint rc;\r\nswitch (new_mode) {\r\ncase CY_MODE_OPERATIONAL:\r\nnew_dev_mode = CY_HST_OPERATE;\r\nbreak;\r\ncase CY_MODE_SYSINFO:\r\nnew_dev_mode = CY_HST_SYSINFO;\r\nbreak;\r\ncase CY_MODE_CAT:\r\nnew_dev_mode = CY_HST_CAT;\r\nbreak;\r\ndefault:\r\ndev_err(cd->dev, "%s: invalid mode: %02X(%d)\n",\r\n__func__, new_mode, new_mode);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(cd->dev, "%s: %s=%p new_dev_mode=%02X new_mode=%d\n",\r\n__func__, "have exclusive", cd->exclusive_dev,\r\nnew_dev_mode, new_mode);\r\nmutex_lock(&cd->system_lock);\r\nrc = cyttsp4_adap_read(cd, CY_REG_BASE, sizeof(mode), &mode);\r\nif (rc < 0) {\r\nmutex_unlock(&cd->system_lock);\r\ndev_err(cd->dev, "%s: Fail read mode r=%d\n",\r\n__func__, rc);\r\ngoto exit;\r\n}\r\nmode &= ~CY_HST_MODE;\r\nmode |= new_dev_mode | CY_HST_MODE_CHANGE;\r\ncd->int_status |= CY_INT_MODE_CHANGE;\r\nrc = cyttsp4_adap_write(cd, CY_REG_BASE, sizeof(mode), &mode);\r\nmutex_unlock(&cd->system_lock);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: Fail write mode change r=%d\n",\r\n__func__, rc);\r\ngoto exit;\r\n}\r\nt = wait_event_timeout(cd->wait_q,\r\n(cd->int_status & CY_INT_MODE_CHANGE) == 0,\r\nmsecs_to_jiffies(CY_CORE_MODE_CHANGE_TIMEOUT));\r\ndev_dbg(cd->dev, "%s: back from wait t=%ld cd->mode=%d\n",\r\n__func__, t, cd->mode);\r\nif (IS_TMO(t)) {\r\ndev_err(cd->dev, "%s: %s\n", __func__,\r\n"tmo waiting mode change");\r\nmutex_lock(&cd->system_lock);\r\ncd->int_status &= ~CY_INT_MODE_CHANGE;\r\nmutex_unlock(&cd->system_lock);\r\nrc = -EINVAL;\r\n}\r\nexit:\r\nreturn rc;\r\n}\r\nstatic void cyttsp4_watchdog_work(struct work_struct *work)\r\n{\r\nstruct cyttsp4 *cd =\r\ncontainer_of(work, struct cyttsp4, watchdog_work);\r\nu8 *mode;\r\nint retval;\r\nmutex_lock(&cd->system_lock);\r\nretval = cyttsp4_load_status_regs(cd);\r\nif (retval < 0) {\r\ndev_err(cd->dev,\r\n"%s: failed to access device in watchdog timer r=%d\n",\r\n__func__, retval);\r\ncyttsp4_queue_startup_(cd);\r\ngoto cyttsp4_timer_watchdog_exit_error;\r\n}\r\nmode = &cd->sysinfo.xy_mode[CY_REG_BASE];\r\nif (IS_BOOTLOADER(mode[0], mode[1])) {\r\ndev_err(cd->dev,\r\n"%s: device found in bootloader mode when operational mode\n",\r\n__func__);\r\ncyttsp4_queue_startup_(cd);\r\ngoto cyttsp4_timer_watchdog_exit_error;\r\n}\r\ncyttsp4_start_wd_timer(cd);\r\ncyttsp4_timer_watchdog_exit_error:\r\nmutex_unlock(&cd->system_lock);\r\nreturn;\r\n}\r\nstatic int cyttsp4_core_sleep_(struct cyttsp4 *cd)\r\n{\r\nenum cyttsp4_sleep_state ss = SS_SLEEP_ON;\r\nenum cyttsp4_int_state int_status = CY_INT_IGNORE;\r\nint rc = 0;\r\nu8 mode[2];\r\nmutex_lock(&cd->system_lock);\r\nif (cd->sleep_state == SS_SLEEP_ON) {\r\nmutex_unlock(&cd->system_lock);\r\nreturn 0;\r\n}\r\ncd->sleep_state = SS_SLEEPING;\r\nmutex_unlock(&cd->system_lock);\r\ncyttsp4_stop_wd_timer(cd);\r\ndisable_irq(cd->irq);\r\ndev_vdbg(cd->dev, "%s: write DEEP SLEEP...\n", __func__);\r\nmutex_lock(&cd->system_lock);\r\nrc = cyttsp4_adap_read(cd, CY_REG_BASE, sizeof(mode), &mode);\r\nif (rc) {\r\nmutex_unlock(&cd->system_lock);\r\ndev_err(cd->dev, "%s: Fail read adapter r=%d\n", __func__, rc);\r\ngoto error;\r\n}\r\nif (IS_BOOTLOADER(mode[0], mode[1])) {\r\nmutex_unlock(&cd->system_lock);\r\ndev_err(cd->dev, "%s: Device in BOOTLOADER mode.\n", __func__);\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nmode[0] |= CY_HST_SLEEP;\r\nrc = cyttsp4_adap_write(cd, CY_REG_BASE, sizeof(mode[0]), &mode[0]);\r\nmutex_unlock(&cd->system_lock);\r\nif (rc) {\r\ndev_err(cd->dev, "%s: Fail write adapter r=%d\n", __func__, rc);\r\ngoto error;\r\n}\r\ndev_vdbg(cd->dev, "%s: write DEEP SLEEP succeeded\n", __func__);\r\nif (cd->cpdata->power) {\r\ndev_dbg(cd->dev, "%s: Power down HW\n", __func__);\r\nrc = cd->cpdata->power(cd->cpdata, 0, cd->dev, &cd->ignore_irq);\r\n} else {\r\ndev_dbg(cd->dev, "%s: No power function\n", __func__);\r\nrc = 0;\r\n}\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: HW Power down fails r=%d\n",\r\n__func__, rc);\r\ngoto error;\r\n}\r\nmsleep(50);\r\ngoto exit;\r\nerror:\r\nss = SS_SLEEP_OFF;\r\nint_status = CY_INT_NONE;\r\ncyttsp4_start_wd_timer(cd);\r\nexit:\r\nmutex_lock(&cd->system_lock);\r\ncd->sleep_state = ss;\r\ncd->int_status |= int_status;\r\nmutex_unlock(&cd->system_lock);\r\nenable_irq(cd->irq);\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_startup_(struct cyttsp4 *cd)\r\n{\r\nint retry = CY_CORE_STARTUP_RETRY_COUNT;\r\nint rc;\r\ncyttsp4_stop_wd_timer(cd);\r\nreset:\r\nif (retry != CY_CORE_STARTUP_RETRY_COUNT)\r\ndev_dbg(cd->dev, "%s: Retry %d\n", __func__,\r\nCY_CORE_STARTUP_RETRY_COUNT - retry);\r\nrc = cyttsp4_reset_and_wait(cd);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: Error on h/w reset r=%d\n", __func__, rc);\r\nif (retry--)\r\ngoto reset;\r\ngoto exit;\r\n}\r\ndev_vdbg(cd->dev, "%s: write exit ldr...\n", __func__);\r\nmutex_lock(&cd->system_lock);\r\ncd->int_status &= ~CY_INT_IGNORE;\r\ncd->int_status |= CY_INT_MODE_CHANGE;\r\nrc = cyttsp4_adap_write(cd, CY_REG_BASE, sizeof(ldr_exit),\r\n(u8 *)ldr_exit);\r\nmutex_unlock(&cd->system_lock);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: Fail write r=%d\n", __func__, rc);\r\nif (retry--)\r\ngoto reset;\r\ngoto exit;\r\n}\r\nrc = cyttsp4_wait_sysinfo_mode(cd);\r\nif (rc < 0) {\r\nu8 buf[sizeof(ldr_err_app)];\r\nint rc1;\r\nrc1 = cyttsp4_adap_read(cd, CY_REG_BASE, sizeof(ldr_err_app),\r\nbuf);\r\nif (rc1) {\r\ndev_err(cd->dev, "%s: Fail read r=%d\n", __func__, rc1);\r\n} else if (!memcmp(buf, ldr_err_app, sizeof(ldr_err_app))) {\r\ndev_err(cd->dev, "%s: Error launching touch application\n",\r\n__func__);\r\nmutex_lock(&cd->system_lock);\r\ncd->invalid_touch_app = true;\r\nmutex_unlock(&cd->system_lock);\r\ngoto exit_no_wd;\r\n}\r\nif (retry--)\r\ngoto reset;\r\ngoto exit;\r\n}\r\nmutex_lock(&cd->system_lock);\r\ncd->invalid_touch_app = false;\r\nmutex_unlock(&cd->system_lock);\r\ndev_vdbg(cd->dev, "%s: get sysinfo regs..\n", __func__);\r\nrc = cyttsp4_get_sysinfo_regs(cd);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: failed to get sysinfo regs rc=%d\n",\r\n__func__, rc);\r\nif (retry--)\r\ngoto reset;\r\ngoto exit;\r\n}\r\nrc = cyttsp4_set_mode(cd, CY_MODE_OPERATIONAL);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: failed to set mode to operational rc=%d\n",\r\n__func__, rc);\r\nif (retry--)\r\ngoto reset;\r\ngoto exit;\r\n}\r\ncyttsp4_lift_all(&cd->md);\r\nmutex_lock(&cd->system_lock);\r\nif (cd->sleep_state == SS_SLEEP_ON) {\r\ncd->sleep_state = SS_SLEEP_OFF;\r\nmutex_unlock(&cd->system_lock);\r\ncyttsp4_core_sleep_(cd);\r\ngoto exit_no_wd;\r\n}\r\nmutex_unlock(&cd->system_lock);\r\nexit:\r\ncyttsp4_start_wd_timer(cd);\r\nexit_no_wd:\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_startup(struct cyttsp4 *cd)\r\n{\r\nint rc;\r\nmutex_lock(&cd->system_lock);\r\ncd->startup_state = STARTUP_RUNNING;\r\nmutex_unlock(&cd->system_lock);\r\nrc = cyttsp4_request_exclusive(cd, cd->dev,\r\nCY_CORE_REQUEST_EXCLUSIVE_TIMEOUT);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",\r\n__func__, cd->exclusive_dev, cd->dev);\r\ngoto exit;\r\n}\r\nrc = cyttsp4_startup_(cd);\r\nif (cyttsp4_release_exclusive(cd, cd->dev) < 0)\r\ndev_err(cd->dev, "%s: fail to release exclusive\n", __func__);\r\nelse\r\ndev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);\r\nexit:\r\nmutex_lock(&cd->system_lock);\r\ncd->startup_state = STARTUP_NONE;\r\nmutex_unlock(&cd->system_lock);\r\nwake_up(&cd->wait_q);\r\nreturn rc;\r\n}\r\nstatic void cyttsp4_startup_work_function(struct work_struct *work)\r\n{\r\nstruct cyttsp4 *cd = container_of(work, struct cyttsp4, startup_work);\r\nint rc;\r\nrc = cyttsp4_startup(cd);\r\nif (rc < 0)\r\ndev_err(cd->dev, "%s: Fail queued startup r=%d\n",\r\n__func__, rc);\r\n}\r\nstatic void cyttsp4_free_si_ptrs(struct cyttsp4 *cd)\r\n{\r\nstruct cyttsp4_sysinfo *si = &cd->sysinfo;\r\nif (!si)\r\nreturn;\r\nkfree(si->si_ptrs.cydata);\r\nkfree(si->si_ptrs.test);\r\nkfree(si->si_ptrs.pcfg);\r\nkfree(si->si_ptrs.opcfg);\r\nkfree(si->si_ptrs.ddata);\r\nkfree(si->si_ptrs.mdata);\r\nkfree(si->btn);\r\nkfree(si->xy_mode);\r\nkfree(si->xy_data);\r\nkfree(si->btn_rec_data);\r\n}\r\nstatic int cyttsp4_core_sleep(struct cyttsp4 *cd)\r\n{\r\nint rc;\r\nrc = cyttsp4_request_exclusive(cd, cd->dev,\r\nCY_CORE_SLEEP_REQUEST_EXCLUSIVE_TIMEOUT);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",\r\n__func__, cd->exclusive_dev, cd->dev);\r\nreturn 0;\r\n}\r\nrc = cyttsp4_core_sleep_(cd);\r\nif (cyttsp4_release_exclusive(cd, cd->dev) < 0)\r\ndev_err(cd->dev, "%s: fail to release exclusive\n", __func__);\r\nelse\r\ndev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_core_wake_(struct cyttsp4 *cd)\r\n{\r\nstruct device *dev = cd->dev;\r\nint rc;\r\nu8 mode;\r\nint t;\r\nmutex_lock(&cd->system_lock);\r\nif (cd->sleep_state == SS_SLEEP_OFF) {\r\nmutex_unlock(&cd->system_lock);\r\nreturn 0;\r\n}\r\ncd->int_status &= ~CY_INT_IGNORE;\r\ncd->int_status |= CY_INT_AWAKE;\r\ncd->sleep_state = SS_WAKING;\r\nif (cd->cpdata->power) {\r\ndev_dbg(dev, "%s: Power up HW\n", __func__);\r\nrc = cd->cpdata->power(cd->cpdata, 1, dev, &cd->ignore_irq);\r\n} else {\r\ndev_dbg(dev, "%s: No power function\n", __func__);\r\nrc = -ENOSYS;\r\n}\r\nif (rc < 0) {\r\ndev_err(dev, "%s: HW Power up fails r=%d\n",\r\n__func__, rc);\r\ncyttsp4_adap_read(cd, CY_REG_BASE, sizeof(mode), &mode);\r\n} else\r\ndev_vdbg(cd->dev, "%s: HW power up succeeds\n",\r\n__func__);\r\nmutex_unlock(&cd->system_lock);\r\nt = wait_event_timeout(cd->wait_q,\r\n(cd->int_status & CY_INT_AWAKE) == 0,\r\nmsecs_to_jiffies(CY_CORE_WAKEUP_TIMEOUT));\r\nif (IS_TMO(t)) {\r\ndev_err(dev, "%s: TMO waiting for wakeup\n", __func__);\r\nmutex_lock(&cd->system_lock);\r\ncd->int_status &= ~CY_INT_AWAKE;\r\ncyttsp4_queue_startup_(cd);\r\nmutex_unlock(&cd->system_lock);\r\n}\r\nmutex_lock(&cd->system_lock);\r\ncd->sleep_state = SS_SLEEP_OFF;\r\nmutex_unlock(&cd->system_lock);\r\ncyttsp4_start_wd_timer(cd);\r\nreturn 0;\r\n}\r\nstatic int cyttsp4_core_wake(struct cyttsp4 *cd)\r\n{\r\nint rc;\r\nrc = cyttsp4_request_exclusive(cd, cd->dev,\r\nCY_CORE_REQUEST_EXCLUSIVE_TIMEOUT);\r\nif (rc < 0) {\r\ndev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",\r\n__func__, cd->exclusive_dev, cd->dev);\r\nreturn 0;\r\n}\r\nrc = cyttsp4_core_wake_(cd);\r\nif (cyttsp4_release_exclusive(cd, cd->dev) < 0)\r\ndev_err(cd->dev, "%s: fail to release exclusive\n", __func__);\r\nelse\r\ndev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_core_suspend(struct device *dev)\r\n{\r\nstruct cyttsp4 *cd = dev_get_drvdata(dev);\r\nstruct cyttsp4_mt_data *md = &cd->md;\r\nint rc;\r\nmd->is_suspended = true;\r\nrc = cyttsp4_core_sleep(cd);\r\nif (rc < 0) {\r\ndev_err(dev, "%s: Error on sleep\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyttsp4_core_resume(struct device *dev)\r\n{\r\nstruct cyttsp4 *cd = dev_get_drvdata(dev);\r\nstruct cyttsp4_mt_data *md = &cd->md;\r\nint rc;\r\nmd->is_suspended = false;\r\nrc = cyttsp4_core_wake(cd);\r\nif (rc < 0) {\r\ndev_err(dev, "%s: Error on wake\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyttsp4_mt_open(struct input_dev *input)\r\n{\r\npm_runtime_get(input->dev.parent);\r\nreturn 0;\r\n}\r\nstatic void cyttsp4_mt_close(struct input_dev *input)\r\n{\r\nstruct cyttsp4_mt_data *md = input_get_drvdata(input);\r\nmutex_lock(&md->report_lock);\r\nif (!md->is_suspended)\r\npm_runtime_put(input->dev.parent);\r\nmutex_unlock(&md->report_lock);\r\n}\r\nstatic int cyttsp4_setup_input_device(struct cyttsp4 *cd)\r\n{\r\nstruct device *dev = cd->dev;\r\nstruct cyttsp4_mt_data *md = &cd->md;\r\nint signal = CY_IGNORE_VALUE;\r\nint max_x, max_y, max_p, min, max;\r\nint max_x_tmp, max_y_tmp;\r\nint i;\r\nint rc;\r\ndev_vdbg(dev, "%s: Initialize event signals\n", __func__);\r\n__set_bit(EV_ABS, md->input->evbit);\r\n__set_bit(EV_REL, md->input->evbit);\r\n__set_bit(EV_KEY, md->input->evbit);\r\nmax_x_tmp = md->si->si_ofs.max_x;\r\nmax_y_tmp = md->si->si_ofs.max_y;\r\nif (md->pdata->flags & CY_FLAG_FLIP) {\r\nmax_x = max_y_tmp - 1;\r\nmax_y = max_x_tmp - 1;\r\n} else {\r\nmax_x = max_x_tmp - 1;\r\nmax_y = max_y_tmp - 1;\r\n}\r\nmax_p = md->si->si_ofs.max_p;\r\nfor (i = 0; i < (md->pdata->frmwrk->size / CY_NUM_ABS_SET); i++) {\r\nsignal = md->pdata->frmwrk->abs\r\n[(i * CY_NUM_ABS_SET) + CY_SIGNAL_OST];\r\nif (signal != CY_IGNORE_VALUE) {\r\n__set_bit(signal, md->input->absbit);\r\nmin = md->pdata->frmwrk->abs\r\n[(i * CY_NUM_ABS_SET) + CY_MIN_OST];\r\nmax = md->pdata->frmwrk->abs\r\n[(i * CY_NUM_ABS_SET) + CY_MAX_OST];\r\nif (i == CY_ABS_ID_OST) {\r\nmax = max - min;\r\nmin = min - min;\r\n} else if (i == CY_ABS_X_OST)\r\nmax = max_x;\r\nelse if (i == CY_ABS_Y_OST)\r\nmax = max_y;\r\nelse if (i == CY_ABS_P_OST)\r\nmax = max_p;\r\ninput_set_abs_params(md->input, signal, min, max,\r\nmd->pdata->frmwrk->abs\r\n[(i * CY_NUM_ABS_SET) + CY_FUZZ_OST],\r\nmd->pdata->frmwrk->abs\r\n[(i * CY_NUM_ABS_SET) + CY_FLAT_OST]);\r\ndev_dbg(dev, "%s: register signal=%02X min=%d max=%d\n",\r\n__func__, signal, min, max);\r\nif ((i == CY_ABS_ID_OST) &&\r\n(md->si->si_ofs.tch_rec_size <\r\nCY_TMA4XX_TCH_REC_SIZE))\r\nbreak;\r\n}\r\n}\r\ninput_mt_init_slots(md->input, md->si->si_ofs.tch_abs[CY_TCH_T].max,\r\nINPUT_MT_DIRECT);\r\nrc = input_register_device(md->input);\r\nif (rc < 0)\r\ndev_err(dev, "%s: Error, failed register input device r=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nstatic int cyttsp4_mt_probe(struct cyttsp4 *cd)\r\n{\r\nstruct device *dev = cd->dev;\r\nstruct cyttsp4_mt_data *md = &cd->md;\r\nstruct cyttsp4_mt_platform_data *pdata = cd->pdata->mt_pdata;\r\nint rc = 0;\r\nmutex_init(&md->report_lock);\r\nmd->pdata = pdata;\r\ndev_vdbg(dev, "%s: Create the input device and register it\n",\r\n__func__);\r\nmd->input = input_allocate_device();\r\nif (md->input == NULL) {\r\ndev_err(dev, "%s: Error, failed to allocate input device\n",\r\n__func__);\r\nrc = -ENOSYS;\r\ngoto error_alloc_failed;\r\n}\r\nmd->input->name = pdata->inp_dev_name;\r\nscnprintf(md->phys, sizeof(md->phys)-1, "%s", dev_name(dev));\r\nmd->input->phys = md->phys;\r\nmd->input->id.bustype = cd->bus_ops->bustype;\r\nmd->input->dev.parent = dev;\r\nmd->input->open = cyttsp4_mt_open;\r\nmd->input->close = cyttsp4_mt_close;\r\ninput_set_drvdata(md->input, md);\r\nmd->si = &cd->sysinfo;\r\nif (!md->si) {\r\ndev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",\r\n__func__, md->si);\r\ngoto error_get_sysinfo;\r\n}\r\nrc = cyttsp4_setup_input_device(cd);\r\nif (rc)\r\ngoto error_init_input;\r\nreturn 0;\r\nerror_init_input:\r\ninput_free_device(md->input);\r\nerror_get_sysinfo:\r\ninput_set_drvdata(md->input, NULL);\r\nerror_alloc_failed:\r\ndev_err(dev, "%s failed.\n", __func__);\r\nreturn rc;\r\n}\r\nstruct cyttsp4 *cyttsp4_probe(const struct cyttsp4_bus_ops *ops,\r\nstruct device *dev, u16 irq, size_t xfer_buf_size)\r\n{\r\nstruct cyttsp4 *cd;\r\nstruct cyttsp4_platform_data *pdata = dev_get_platdata(dev);\r\nunsigned long irq_flags;\r\nint rc = 0;\r\nif (!pdata || !pdata->core_pdata || !pdata->mt_pdata) {\r\ndev_err(dev, "%s: Missing platform data\n", __func__);\r\nrc = -ENODEV;\r\ngoto error_no_pdata;\r\n}\r\ncd = kzalloc(sizeof(*cd), GFP_KERNEL);\r\nif (!cd) {\r\ndev_err(dev, "%s: Error, kzalloc\n", __func__);\r\nrc = -ENOMEM;\r\ngoto error_alloc_data;\r\n}\r\ncd->xfer_buf = kzalloc(xfer_buf_size, GFP_KERNEL);\r\nif (!cd->xfer_buf) {\r\ndev_err(dev, "%s: Error, kzalloc\n", __func__);\r\nrc = -ENOMEM;\r\ngoto error_free_cd;\r\n}\r\ncd->dev = dev;\r\ncd->pdata = pdata;\r\ncd->cpdata = pdata->core_pdata;\r\ncd->bus_ops = ops;\r\nmutex_init(&cd->system_lock);\r\nmutex_init(&cd->adap_lock);\r\ninit_waitqueue_head(&cd->wait_q);\r\nINIT_WORK(&cd->startup_work, cyttsp4_startup_work_function);\r\nINIT_WORK(&cd->watchdog_work, cyttsp4_watchdog_work);\r\ncd->irq = gpio_to_irq(cd->cpdata->irq_gpio);\r\nif (cd->irq < 0) {\r\nrc = -EINVAL;\r\ngoto error_free_xfer;\r\n}\r\ndev_set_drvdata(dev, cd);\r\nif (cd->cpdata->init) {\r\ndev_dbg(cd->dev, "%s: Init HW\n", __func__);\r\nrc = cd->cpdata->init(cd->cpdata, 1, cd->dev);\r\n} else {\r\ndev_dbg(cd->dev, "%s: No HW INIT function\n", __func__);\r\nrc = 0;\r\n}\r\nif (rc < 0)\r\ndev_err(cd->dev, "%s: HW Init fail r=%d\n", __func__, rc);\r\ndev_dbg(dev, "%s: initialize threaded irq=%d\n", __func__, cd->irq);\r\nif (cd->cpdata->level_irq_udelay > 0)\r\nirq_flags = IRQF_TRIGGER_LOW | IRQF_ONESHOT;\r\nelse\r\nirq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;\r\nrc = request_threaded_irq(cd->irq, NULL, cyttsp4_irq, irq_flags,\r\ndev_name(dev), cd);\r\nif (rc < 0) {\r\ndev_err(dev, "%s: Error, could not request irq\n", __func__);\r\ngoto error_request_irq;\r\n}\r\nsetup_timer(&cd->watchdog_timer, cyttsp4_watchdog_timer,\r\n(unsigned long)cd);\r\nrc = cyttsp4_startup(cd);\r\nif (rc < 0 && cd->mode == CY_MODE_UNKNOWN) {\r\ndev_err(cd->dev, "%s: Fail initial startup r=%d\n",\r\n__func__, rc);\r\ngoto error_startup;\r\n}\r\nrc = cyttsp4_mt_probe(cd);\r\nif (rc < 0) {\r\ndev_err(dev, "%s: Error, fail mt probe\n", __func__);\r\ngoto error_startup;\r\n}\r\npm_runtime_enable(dev);\r\nreturn cd;\r\nerror_startup:\r\ncancel_work_sync(&cd->startup_work);\r\ncyttsp4_stop_wd_timer(cd);\r\npm_runtime_disable(dev);\r\ncyttsp4_free_si_ptrs(cd);\r\nfree_irq(cd->irq, cd);\r\nerror_request_irq:\r\nif (cd->cpdata->init)\r\ncd->cpdata->init(cd->cpdata, 0, dev);\r\nerror_free_xfer:\r\nkfree(cd->xfer_buf);\r\nerror_free_cd:\r\nkfree(cd);\r\nerror_alloc_data:\r\nerror_no_pdata:\r\ndev_err(dev, "%s failed.\n", __func__);\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic void cyttsp4_mt_release(struct cyttsp4_mt_data *md)\r\n{\r\ninput_unregister_device(md->input);\r\ninput_set_drvdata(md->input, NULL);\r\n}\r\nint cyttsp4_remove(struct cyttsp4 *cd)\r\n{\r\nstruct device *dev = cd->dev;\r\ncyttsp4_mt_release(&cd->md);\r\npm_runtime_suspend(dev);\r\npm_runtime_disable(dev);\r\ncancel_work_sync(&cd->startup_work);\r\ncyttsp4_stop_wd_timer(cd);\r\nfree_irq(cd->irq, cd);\r\nif (cd->cpdata->init)\r\ncd->cpdata->init(cd->cpdata, 0, dev);\r\ncyttsp4_free_si_ptrs(cd);\r\nkfree(cd);\r\nreturn 0;\r\n}
