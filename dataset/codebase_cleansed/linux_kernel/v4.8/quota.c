static void iwl_mvm_quota_iterator(void *_data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm_quota_iterator_data *data = _data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nu16 id;\r\nif (vif == data->disabled_vif)\r\nreturn;\r\nif (!mvmvif->phy_ctxt)\r\nreturn;\r\nid = mvmvif->phy_ctxt->id;\r\nBUILD_BUG_ON(NUM_PHY_CTX > MAX_BINDINGS);\r\nif (WARN_ON_ONCE(id >= MAX_BINDINGS))\r\nreturn;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nif (vif->bss_conf.assoc)\r\nbreak;\r\nreturn;\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_ADHOC:\r\nif (mvmvif->ap_ibss_active)\r\nbreak;\r\nreturn;\r\ncase NL80211_IFTYPE_MONITOR:\r\nif (mvmvif->monitor_active)\r\nbreak;\r\nreturn;\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nreturn;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn;\r\n}\r\nif (data->colors[id] < 0)\r\ndata->colors[id] = mvmvif->phy_ctxt->color;\r\nelse\r\nWARN_ON_ONCE(data->colors[id] != mvmvif->phy_ctxt->color);\r\ndata->n_interfaces[id]++;\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\nif (mvmvif->dbgfs_quota_min)\r\ndata->dbgfs_min[id] = max(data->dbgfs_min[id],\r\nmvmvif->dbgfs_quota_min);\r\n#endif\r\nif (iwl_mvm_vif_low_latency(mvmvif) && !data->low_latency[id]) {\r\ndata->n_low_latency_bindings++;\r\ndata->low_latency[id] = true;\r\n}\r\n}\r\nstatic void iwl_mvm_adjust_quota_for_noa(struct iwl_mvm *mvm,\r\nstruct iwl_time_quota_cmd *cmd)\r\n{\r\n#ifdef CONFIG_NL80211_TESTMODE\r\nstruct iwl_mvm_vif *mvmvif;\r\nint i, phy_id = -1, beacon_int = 0;\r\nif (!mvm->noa_duration || !mvm->noa_vif)\r\nreturn;\r\nmvmvif = iwl_mvm_vif_from_mac80211(mvm->noa_vif);\r\nif (!mvmvif->ap_ibss_active)\r\nreturn;\r\nphy_id = mvmvif->phy_ctxt->id;\r\nbeacon_int = mvm->noa_vif->bss_conf.beacon_int;\r\nfor (i = 0; i < MAX_BINDINGS; i++) {\r\nu32 id_n_c = le32_to_cpu(cmd->quotas[i].id_and_color);\r\nu32 id = (id_n_c & FW_CTXT_ID_MSK) >> FW_CTXT_ID_POS;\r\nu32 quota = le32_to_cpu(cmd->quotas[i].quota);\r\nif (id != phy_id)\r\ncontinue;\r\nquota *= (beacon_int - mvm->noa_duration);\r\nquota /= beacon_int;\r\nIWL_DEBUG_QUOTA(mvm, "quota: adjust for NoA from %d to %d\n",\r\nle32_to_cpu(cmd->quotas[i].quota), quota);\r\ncmd->quotas[i].quota = cpu_to_le32(quota);\r\n}\r\n#endif\r\n}\r\nint iwl_mvm_update_quotas(struct iwl_mvm *mvm,\r\nbool force_update,\r\nstruct ieee80211_vif *disabled_vif)\r\n{\r\nstruct iwl_time_quota_cmd cmd = {};\r\nint i, idx, err, num_active_macs, quota, quota_rem, n_non_lowlat;\r\nstruct iwl_mvm_quota_iterator_data data = {\r\n.n_interfaces = {},\r\n.colors = { -1, -1, -1, -1 },\r\n.disabled_vif = disabled_vif,\r\n};\r\nstruct iwl_time_quota_cmd *last = &mvm->last_quota_cmd;\r\nbool send = false;\r\nlockdep_assert_held(&mvm->mutex);\r\nif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))\r\nreturn 0;\r\nBUILD_BUG_ON(MAX_BINDINGS != 4);\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_quota_iterator, &data);\r\nnum_active_macs = 0;\r\nfor (i = 0; i < MAX_BINDINGS; i++) {\r\ncmd.quotas[i].id_and_color = cpu_to_le32(FW_CTXT_INVALID);\r\nnum_active_macs += data.n_interfaces[i];\r\n}\r\nn_non_lowlat = num_active_macs;\r\nif (data.n_low_latency_bindings == 1) {\r\nfor (i = 0; i < MAX_BINDINGS; i++) {\r\nif (data.low_latency[i]) {\r\nn_non_lowlat -= data.n_interfaces[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nif (data.n_low_latency_bindings == 1 && n_non_lowlat) {\r\nquota = (QUOTA_100 - QUOTA_LOWLAT_MIN) / n_non_lowlat;\r\nquota_rem = QUOTA_100 - n_non_lowlat * quota -\r\nQUOTA_LOWLAT_MIN;\r\nIWL_DEBUG_QUOTA(mvm,\r\n"quota: low-latency binding active, remaining quota per other binding: %d\n",\r\nquota);\r\n} else if (num_active_macs) {\r\nquota = QUOTA_100 / num_active_macs;\r\nquota_rem = QUOTA_100 % num_active_macs;\r\nIWL_DEBUG_QUOTA(mvm,\r\n"quota: splitting evenly per binding: %d\n",\r\nquota);\r\n} else {\r\nquota = 0;\r\nquota_rem = 0;\r\n}\r\nfor (idx = 0, i = 0; i < MAX_BINDINGS; i++) {\r\nif (data.colors[i] < 0)\r\ncontinue;\r\ncmd.quotas[idx].id_and_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(i, data.colors[i]));\r\nif (data.n_interfaces[i] <= 0)\r\ncmd.quotas[idx].quota = cpu_to_le32(0);\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\nelse if (data.dbgfs_min[i])\r\ncmd.quotas[idx].quota =\r\ncpu_to_le32(data.dbgfs_min[i] * QUOTA_100 / 100);\r\n#endif\r\nelse if (data.n_low_latency_bindings == 1 && n_non_lowlat &&\r\ndata.low_latency[i])\r\ncmd.quotas[idx].quota = cpu_to_le32(QUOTA_LOWLAT_MIN);\r\nelse\r\ncmd.quotas[idx].quota =\r\ncpu_to_le32(quota * data.n_interfaces[i]);\r\nWARN_ONCE(le32_to_cpu(cmd.quotas[idx].quota) > QUOTA_100,\r\n"Binding=%d, quota=%u > max=%u\n",\r\nidx, le32_to_cpu(cmd.quotas[idx].quota), QUOTA_100);\r\ncmd.quotas[idx].max_duration = cpu_to_le32(0);\r\nidx++;\r\n}\r\nfor (i = 0; i < MAX_BINDINGS; i++) {\r\nif (le32_to_cpu(cmd.quotas[i].quota) != 0) {\r\nle32_add_cpu(&cmd.quotas[i].quota, quota_rem);\r\nIWL_DEBUG_QUOTA(mvm,\r\n"quota: giving remainder of %d to binding %d\n",\r\nquota_rem, i);\r\nbreak;\r\n}\r\n}\r\niwl_mvm_adjust_quota_for_noa(mvm, &cmd);\r\nfor (i = 0; i < MAX_BINDINGS; i++) {\r\nif (cmd.quotas[i].id_and_color != last->quotas[i].id_and_color)\r\nsend = true;\r\nif (cmd.quotas[i].max_duration != last->quotas[i].max_duration)\r\nsend = true;\r\nif (abs((int)le32_to_cpu(cmd.quotas[i].quota) -\r\n(int)le32_to_cpu(last->quotas[i].quota))\r\n> IWL_MVM_QUOTA_THRESHOLD)\r\nsend = true;\r\nif (cmd.quotas[i].id_and_color == cpu_to_le32(FW_CTXT_INVALID))\r\ncontinue;\r\nWARN_ONCE(cmd.quotas[i].quota == 0,\r\n"zero quota on binding %d\n", i);\r\n}\r\nif (!send && !force_update) {\r\nreturn 0;\r\n}\r\nerr = iwl_mvm_send_cmd_pdu(mvm, TIME_QUOTA_CMD, 0, sizeof(cmd), &cmd);\r\nif (err)\r\nIWL_ERR(mvm, "Failed to send quota: %d\n", err);\r\nelse\r\nmvm->last_quota_cmd = cmd;\r\nreturn err;\r\n}
