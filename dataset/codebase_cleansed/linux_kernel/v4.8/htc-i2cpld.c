static void htcpld_mask(struct irq_data *data)\r\n{\r\nstruct htcpld_chip *chip = irq_data_get_irq_chip_data(data);\r\nchip->irqs_enabled &= ~(1 << (data->irq - chip->irq_start));\r\npr_debug("HTCPLD mask %d %04x\n", data->irq, chip->irqs_enabled);\r\n}\r\nstatic void htcpld_unmask(struct irq_data *data)\r\n{\r\nstruct htcpld_chip *chip = irq_data_get_irq_chip_data(data);\r\nchip->irqs_enabled |= 1 << (data->irq - chip->irq_start);\r\npr_debug("HTCPLD unmask %d %04x\n", data->irq, chip->irqs_enabled);\r\n}\r\nstatic int htcpld_set_type(struct irq_data *data, unsigned int flags)\r\n{\r\nstruct htcpld_chip *chip = irq_data_get_irq_chip_data(data);\r\nif (flags & ~IRQ_TYPE_SENSE_MASK)\r\nreturn -EINVAL;\r\nif (flags & (IRQ_TYPE_LEVEL_LOW|IRQ_TYPE_LEVEL_HIGH))\r\nreturn -EINVAL;\r\nchip->flow_type = flags;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t htcpld_handler(int irq, void *dev)\r\n{\r\nstruct htcpld_data *htcpld = dev;\r\nunsigned int i;\r\nunsigned long flags;\r\nint irqpin;\r\nif (!htcpld) {\r\npr_debug("htcpld is null in ISR\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nfor (i = 0; i < htcpld->nchips; i++) {\r\nstruct htcpld_chip *chip = &htcpld->chip[i];\r\nstruct i2c_client *client;\r\nint val;\r\nunsigned long uval, old_val;\r\nif (!chip) {\r\npr_debug("chip %d is null in ISR\n", i);\r\ncontinue;\r\n}\r\nif (chip->nirqs == 0)\r\ncontinue;\r\nclient = chip->client;\r\nif (!client) {\r\npr_debug("client %d is null in ISR\n", i);\r\ncontinue;\r\n}\r\nval = i2c_smbus_read_byte_data(client, chip->cache_out);\r\nif (val < 0) {\r\ndev_warn(chip->dev, "Unable to read from chip: %d\n",\r\nval);\r\ncontinue;\r\n}\r\nuval = (unsigned long)val;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nold_val = chip->cache_in;\r\nchip->cache_in = uval;\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nfor (irqpin = 0; irqpin < chip->nirqs; irqpin++) {\r\nunsigned oldb, newb, type = chip->flow_type;\r\nirq = chip->irq_start + irqpin;\r\noldb = (old_val >> irqpin) & 1;\r\nnewb = (uval >> irqpin) & 1;\r\nif ((!oldb && newb && (type & IRQ_TYPE_EDGE_RISING)) ||\r\n(oldb && !newb && (type & IRQ_TYPE_EDGE_FALLING))) {\r\npr_debug("fire IRQ %d\n", irqpin);\r\ngeneric_handle_irq(irq);\r\n}\r\n}\r\n}\r\nif (htcpld->int_reset_gpio_hi)\r\ngpio_set_value(htcpld->int_reset_gpio_hi, 1);\r\nif (htcpld->int_reset_gpio_lo)\r\ngpio_set_value(htcpld->int_reset_gpio_lo, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void htcpld_chip_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct i2c_client *client;\r\nstruct htcpld_chip *chip_data = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nclient = chip_data->client;\r\nif (!client)\r\nreturn;\r\nspin_lock_irqsave(&chip_data->lock, flags);\r\nif (val)\r\nchip_data->cache_out |= (1 << offset);\r\nelse\r\nchip_data->cache_out &= ~(1 << offset);\r\nspin_unlock_irqrestore(&chip_data->lock, flags);\r\nschedule_work(&(chip_data->set_val_work));\r\n}\r\nstatic void htcpld_chip_set_ni(struct work_struct *work)\r\n{\r\nstruct htcpld_chip *chip_data;\r\nstruct i2c_client *client;\r\nchip_data = container_of(work, struct htcpld_chip, set_val_work);\r\nclient = chip_data->client;\r\ni2c_smbus_read_byte_data(client, chip_data->cache_out);\r\n}\r\nstatic int htcpld_chip_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct htcpld_chip *chip_data = gpiochip_get_data(chip);\r\nu8 cache;\r\nif (!strncmp(chip->label, "htcpld-out", 10)) {\r\ncache = chip_data->cache_out;\r\n} else if (!strncmp(chip->label, "htcpld-in", 9)) {\r\ncache = chip_data->cache_in;\r\n} else\r\nreturn -EINVAL;\r\nreturn (cache >> offset) & 1;\r\n}\r\nstatic int htcpld_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nhtcpld_chip_set(chip, offset, value);\r\nreturn 0;\r\n}\r\nstatic int htcpld_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nreturn (offset < chip->ngpio) ? 0 : -EINVAL;\r\n}\r\nstatic int htcpld_chip_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct htcpld_chip *chip_data = gpiochip_get_data(chip);\r\nif (offset < chip_data->nirqs)\r\nreturn chip_data->irq_start + offset;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic void htcpld_chip_reset(struct i2c_client *client)\r\n{\r\nstruct htcpld_chip *chip_data = i2c_get_clientdata(client);\r\nif (!chip_data)\r\nreturn;\r\ni2c_smbus_read_byte_data(\r\nclient, (chip_data->cache_out = chip_data->reset));\r\n}\r\nstatic int htcpld_setup_chip_irq(\r\nstruct platform_device *pdev,\r\nint chip_index)\r\n{\r\nstruct htcpld_data *htcpld;\r\nstruct htcpld_chip *chip;\r\nunsigned int irq, irq_end;\r\nhtcpld = platform_get_drvdata(pdev);\r\nchip = &htcpld->chip[chip_index];\r\nirq_end = chip->irq_start + chip->nirqs;\r\nfor (irq = chip->irq_start; irq < irq_end; irq++) {\r\nirq_set_chip_and_handler(irq, &htcpld_muxed_chip,\r\nhandle_simple_irq);\r\nirq_set_chip_data(irq, chip);\r\nirq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int htcpld_register_chip_i2c(\r\nstruct platform_device *pdev,\r\nint chip_index)\r\n{\r\nstruct htcpld_data *htcpld;\r\nstruct device *dev = &pdev->dev;\r\nstruct htcpld_core_platform_data *pdata;\r\nstruct htcpld_chip *chip;\r\nstruct htcpld_chip_platform_data *plat_chip_data;\r\nstruct i2c_adapter *adapter;\r\nstruct i2c_client *client;\r\nstruct i2c_board_info info;\r\npdata = dev_get_platdata(dev);\r\nhtcpld = platform_get_drvdata(pdev);\r\nchip = &htcpld->chip[chip_index];\r\nplat_chip_data = &pdata->chip[chip_index];\r\nadapter = i2c_get_adapter(pdata->i2c_adapter_id);\r\nif (!adapter) {\r\ndev_warn(dev, "Chip at i2c address 0x%x: Invalid i2c adapter %d\n",\r\nplat_chip_data->addr, pdata->i2c_adapter_id);\r\nreturn -ENODEV;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_BYTE_DATA)) {\r\ndev_warn(dev, "i2c adapter %d non-functional\n",\r\npdata->i2c_adapter_id);\r\nreturn -EINVAL;\r\n}\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = plat_chip_data->addr;\r\nstrlcpy(info.type, "htcpld-chip", I2C_NAME_SIZE);\r\ninfo.platform_data = chip;\r\nclient = i2c_new_device(adapter, &info);\r\nif (!client) {\r\ndev_warn(dev, "Unable to add I2C device for 0x%x\n",\r\nplat_chip_data->addr);\r\nreturn -ENODEV;\r\n}\r\ni2c_set_clientdata(client, chip);\r\nsnprintf(client->name, I2C_NAME_SIZE, "Chip_0x%x", client->addr);\r\nchip->client = client;\r\nhtcpld_chip_reset(client);\r\nchip->cache_in = i2c_smbus_read_byte_data(client, chip->cache_out);\r\nreturn 0;\r\n}\r\nstatic void htcpld_unregister_chip_i2c(\r\nstruct platform_device *pdev,\r\nint chip_index)\r\n{\r\nstruct htcpld_data *htcpld;\r\nstruct htcpld_chip *chip;\r\nhtcpld = platform_get_drvdata(pdev);\r\nchip = &htcpld->chip[chip_index];\r\nif (chip->client)\r\ni2c_unregister_device(chip->client);\r\n}\r\nstatic int htcpld_register_chip_gpio(\r\nstruct platform_device *pdev,\r\nint chip_index)\r\n{\r\nstruct htcpld_data *htcpld;\r\nstruct device *dev = &pdev->dev;\r\nstruct htcpld_core_platform_data *pdata;\r\nstruct htcpld_chip *chip;\r\nstruct htcpld_chip_platform_data *plat_chip_data;\r\nstruct gpio_chip *gpio_chip;\r\nint ret = 0;\r\npdata = dev_get_platdata(dev);\r\nhtcpld = platform_get_drvdata(pdev);\r\nchip = &htcpld->chip[chip_index];\r\nplat_chip_data = &pdata->chip[chip_index];\r\ngpio_chip = &(chip->chip_out);\r\ngpio_chip->label = "htcpld-out";\r\ngpio_chip->parent = dev;\r\ngpio_chip->owner = THIS_MODULE;\r\ngpio_chip->get = htcpld_chip_get;\r\ngpio_chip->set = htcpld_chip_set;\r\ngpio_chip->direction_input = NULL;\r\ngpio_chip->direction_output = htcpld_direction_output;\r\ngpio_chip->base = plat_chip_data->gpio_out_base;\r\ngpio_chip->ngpio = plat_chip_data->num_gpios;\r\ngpio_chip = &(chip->chip_in);\r\ngpio_chip->label = "htcpld-in";\r\ngpio_chip->parent = dev;\r\ngpio_chip->owner = THIS_MODULE;\r\ngpio_chip->get = htcpld_chip_get;\r\ngpio_chip->set = NULL;\r\ngpio_chip->direction_input = htcpld_direction_input;\r\ngpio_chip->direction_output = NULL;\r\ngpio_chip->to_irq = htcpld_chip_to_irq;\r\ngpio_chip->base = plat_chip_data->gpio_in_base;\r\ngpio_chip->ngpio = plat_chip_data->num_gpios;\r\nret = gpiochip_add_data(&(chip->chip_out), chip);\r\nif (ret) {\r\ndev_warn(dev, "Unable to register output GPIOs for 0x%x: %d\n",\r\nplat_chip_data->addr, ret);\r\nreturn ret;\r\n}\r\nret = gpiochip_add_data(&(chip->chip_in), chip);\r\nif (ret) {\r\ndev_warn(dev, "Unable to register input GPIOs for 0x%x: %d\n",\r\nplat_chip_data->addr, ret);\r\ngpiochip_remove(&(chip->chip_out));\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int htcpld_setup_chips(struct platform_device *pdev)\r\n{\r\nstruct htcpld_data *htcpld;\r\nstruct device *dev = &pdev->dev;\r\nstruct htcpld_core_platform_data *pdata;\r\nint i;\r\npdata = dev_get_platdata(dev);\r\nhtcpld = platform_get_drvdata(pdev);\r\nhtcpld->nchips = pdata->num_chip;\r\nhtcpld->chip = devm_kzalloc(dev, sizeof(struct htcpld_chip) * htcpld->nchips,\r\nGFP_KERNEL);\r\nif (!htcpld->chip) {\r\ndev_warn(dev, "Unable to allocate memory for chips\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < htcpld->nchips; i++) {\r\nint ret;\r\nhtcpld->chip[i].reset = pdata->chip[i].reset;\r\nhtcpld->chip[i].cache_out = pdata->chip[i].reset;\r\nhtcpld->chip[i].cache_in = 0;\r\nhtcpld->chip[i].dev = dev;\r\nhtcpld->chip[i].irq_start = pdata->chip[i].irq_base;\r\nhtcpld->chip[i].nirqs = pdata->chip[i].num_irqs;\r\nINIT_WORK(&(htcpld->chip[i].set_val_work), &htcpld_chip_set_ni);\r\nspin_lock_init(&(htcpld->chip[i].lock));\r\nif (htcpld->chained_irq) {\r\nret = htcpld_setup_chip_irq(pdev, i);\r\nif (ret)\r\ncontinue;\r\n}\r\nret = htcpld_register_chip_i2c(pdev, i);\r\nif (ret)\r\ncontinue;\r\nret = htcpld_register_chip_gpio(pdev, i);\r\nif (ret) {\r\nhtcpld_unregister_chip_i2c(pdev, i);\r\ncontinue;\r\n}\r\ndev_info(dev, "Registered chip at 0x%x\n", pdata->chip[i].addr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int htcpld_core_probe(struct platform_device *pdev)\r\n{\r\nstruct htcpld_data *htcpld;\r\nstruct device *dev = &pdev->dev;\r\nstruct htcpld_core_platform_data *pdata;\r\nstruct resource *res;\r\nint ret = 0;\r\nif (!dev)\r\nreturn -ENODEV;\r\npdata = dev_get_platdata(dev);\r\nif (!pdata) {\r\ndev_warn(dev, "Platform data not found for htcpld core!\n");\r\nreturn -ENXIO;\r\n}\r\nhtcpld = devm_kzalloc(dev, sizeof(struct htcpld_data), GFP_KERNEL);\r\nif (!htcpld)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res) {\r\nint flags;\r\nhtcpld->chained_irq = res->start;\r\nflags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING |\r\nIRQF_ONESHOT;\r\nret = request_threaded_irq(htcpld->chained_irq,\r\nNULL, htcpld_handler,\r\nflags, pdev->name, htcpld);\r\nif (ret) {\r\ndev_warn(dev, "Unable to setup chained irq handler: %d\n", ret);\r\nreturn ret;\r\n} else\r\ndevice_init_wakeup(dev, 0);\r\n}\r\nplatform_set_drvdata(pdev, htcpld);\r\nret = htcpld_setup_chips(pdev);\r\nif (ret)\r\nreturn ret;\r\nif (pdata->int_reset_gpio_hi) {\r\nret = gpio_request(pdata->int_reset_gpio_hi, "htcpld-core");\r\nif (ret) {\r\ndev_warn(dev, "Unable to request int_reset_gpio_hi -- interrupts may not work\n");\r\nhtcpld->int_reset_gpio_hi = 0;\r\n} else {\r\nhtcpld->int_reset_gpio_hi = pdata->int_reset_gpio_hi;\r\ngpio_set_value(htcpld->int_reset_gpio_hi, 1);\r\n}\r\n}\r\nif (pdata->int_reset_gpio_lo) {\r\nret = gpio_request(pdata->int_reset_gpio_lo, "htcpld-core");\r\nif (ret) {\r\ndev_warn(dev, "Unable to request int_reset_gpio_lo -- interrupts may not work\n");\r\nhtcpld->int_reset_gpio_lo = 0;\r\n} else {\r\nhtcpld->int_reset_gpio_lo = pdata->int_reset_gpio_lo;\r\ngpio_set_value(htcpld->int_reset_gpio_lo, 0);\r\n}\r\n}\r\ndev_info(dev, "Initialized successfully\n");\r\nreturn 0;\r\n}\r\nstatic int __init htcpld_core_init(void)\r\n{\r\nint ret;\r\nret = i2c_add_driver(&htcpld_chip_driver);\r\nif (ret)\r\nreturn ret;\r\nreturn platform_driver_probe(&htcpld_core_driver, htcpld_core_probe);\r\n}\r\nstatic void __exit htcpld_core_exit(void)\r\n{\r\ni2c_del_driver(&htcpld_chip_driver);\r\nplatform_driver_unregister(&htcpld_core_driver);\r\n}
