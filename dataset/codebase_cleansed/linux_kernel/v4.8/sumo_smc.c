static void sumo_send_msg_to_smu(struct radeon_device *rdev, u32 id)\r\n{\r\nu32 gfx_int_req;\r\nint i;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32(GFX_INT_STATUS) & INT_DONE)\r\nbreak;\r\nudelay(1);\r\n}\r\ngfx_int_req = SERV_INDEX(id) | INT_REQ;\r\nWREG32(GFX_INT_REQ, gfx_int_req);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32(GFX_INT_REQ) & INT_REQ)\r\nbreak;\r\nudelay(1);\r\n}\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32(GFX_INT_STATUS) & INT_ACK)\r\nbreak;\r\nudelay(1);\r\n}\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32(GFX_INT_STATUS) & INT_DONE)\r\nbreak;\r\nudelay(1);\r\n}\r\ngfx_int_req &= ~INT_REQ;\r\nWREG32(GFX_INT_REQ, gfx_int_req);\r\n}\r\nvoid sumo_initialize_m3_arb(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nu32 i;\r\nif (!pi->enable_dynamic_m3_arbiter)\r\nreturn;\r\nfor (i = 0; i < NUMBER_OF_M3ARB_PARAM_SETS; i++)\r\nWREG32_RCU(MCU_M3ARB_PARAMS + (i * 4),\r\npi->sys_info.csr_m3_arb_cntl_default[i]);\r\nfor (; i < NUMBER_OF_M3ARB_PARAM_SETS * 2; i++)\r\nWREG32_RCU(MCU_M3ARB_PARAMS + (i * 4),\r\npi->sys_info.csr_m3_arb_cntl_uvd[i % NUMBER_OF_M3ARB_PARAM_SETS]);\r\nfor (; i < NUMBER_OF_M3ARB_PARAM_SETS * 3; i++)\r\nWREG32_RCU(MCU_M3ARB_PARAMS + (i * 4),\r\npi->sys_info.csr_m3_arb_cntl_fs3d[i % NUMBER_OF_M3ARB_PARAM_SETS]);\r\n}\r\nstatic bool sumo_is_alt_vddnb_supported(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nbool return_code = false;\r\nif (!pi->enable_alt_vddnb)\r\nreturn return_code;\r\nif ((rdev->family == CHIP_SUMO) || (rdev->family == CHIP_SUMO2)) {\r\nif (pi->fw_version >= 0x00010C00)\r\nreturn_code = true;\r\n}\r\nreturn return_code;\r\n}\r\nvoid sumo_smu_notify_alt_vddnb_change(struct radeon_device *rdev,\r\nbool powersaving, bool force_nbps1)\r\n{\r\nu32 param = 0;\r\nif (!sumo_is_alt_vddnb_supported(rdev))\r\nreturn;\r\nif (powersaving)\r\nparam |= 1;\r\nif (force_nbps1)\r\nparam |= 2;\r\nWREG32_RCU(RCU_ALTVDDNB_NOTIFY, param);\r\nsumo_send_msg_to_smu(rdev, SUMO_SMU_SERVICE_ROUTINE_ALTVDDNB_NOTIFY);\r\n}\r\nvoid sumo_smu_pg_init(struct radeon_device *rdev)\r\n{\r\nsumo_send_msg_to_smu(rdev, SUMO_SMU_SERVICE_ROUTINE_PG_INIT);\r\n}\r\nstatic u32 sumo_power_of_4(u32 unit)\r\n{\r\nu32 ret = 1;\r\nu32 i;\r\nfor (i = 0; i < unit; i++)\r\nret *= 4;\r\nreturn ret;\r\n}\r\nvoid sumo_enable_boost_timer(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nu32 period, unit, timer_value;\r\nu32 xclk = radeon_get_xclk(rdev);\r\nunit = (RREG32_RCU(RCU_LCLK_SCALING_CNTL) & LCLK_SCALING_TIMER_PRESCALER_MASK)\r\n>> LCLK_SCALING_TIMER_PRESCALER_SHIFT;\r\nperiod = 100 * (xclk / 100 / sumo_power_of_4(unit));\r\ntimer_value = (period << 16) | (unit << 4);\r\nWREG32_RCU(RCU_GNB_PWR_REP_TIMER_CNTL, timer_value);\r\nWREG32_RCU(RCU_BOOST_MARGIN, pi->sys_info.sclk_dpm_boost_margin);\r\nWREG32_RCU(RCU_THROTTLE_MARGIN, pi->sys_info.sclk_dpm_throttle_margin);\r\nWREG32_RCU(GNB_TDP_LIMIT, pi->sys_info.gnb_tdp_limit);\r\nWREG32_RCU(RCU_SclkDpmTdpLimitPG, pi->sys_info.sclk_dpm_tdp_limit_pg);\r\nsumo_send_msg_to_smu(rdev, SUMO_SMU_SERVICE_ROUTINE_GFX_SRV_ID_20);\r\n}\r\nvoid sumo_set_tdp_limit(struct radeon_device *rdev, u32 index, u32 tdp_limit)\r\n{\r\nu32 regoffset = 0;\r\nu32 shift = 0;\r\nu32 mask = 0xFFF;\r\nu32 sclk_dpm_tdp_limit;\r\nswitch (index) {\r\ncase 0:\r\nregoffset = RCU_SclkDpmTdpLimit01;\r\nshift = 16;\r\nbreak;\r\ncase 1:\r\nregoffset = RCU_SclkDpmTdpLimit01;\r\nshift = 0;\r\nbreak;\r\ncase 2:\r\nregoffset = RCU_SclkDpmTdpLimit23;\r\nshift = 16;\r\nbreak;\r\ncase 3:\r\nregoffset = RCU_SclkDpmTdpLimit23;\r\nshift = 0;\r\nbreak;\r\ncase 4:\r\nregoffset = RCU_SclkDpmTdpLimit47;\r\nshift = 16;\r\nbreak;\r\ncase 7:\r\nregoffset = RCU_SclkDpmTdpLimit47;\r\nshift = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsclk_dpm_tdp_limit = RREG32_RCU(regoffset);\r\nsclk_dpm_tdp_limit &= ~(mask << shift);\r\nsclk_dpm_tdp_limit |= (tdp_limit << shift);\r\nWREG32_RCU(regoffset, sclk_dpm_tdp_limit);\r\n}\r\nvoid sumo_boost_state_enable(struct radeon_device *rdev, bool enable)\r\n{\r\nu32 boost_disable = RREG32_RCU(RCU_GPU_BOOST_DISABLE);\r\nboost_disable &= 0xFFFFFFFE;\r\nboost_disable |= (enable ? 0 : 1);\r\nWREG32_RCU(RCU_GPU_BOOST_DISABLE, boost_disable);\r\n}\r\nu32 sumo_get_running_fw_version(struct radeon_device *rdev)\r\n{\r\nreturn RREG32_RCU(RCU_FW_VERSION);\r\n}
