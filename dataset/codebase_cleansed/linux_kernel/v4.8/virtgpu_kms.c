static void virtio_gpu_config_changed_work_func(struct work_struct *work)\r\n{\r\nstruct virtio_gpu_device *vgdev =\r\ncontainer_of(work, struct virtio_gpu_device,\r\nconfig_changed_work);\r\nu32 events_read, events_clear = 0;\r\nvirtio_cread(vgdev->vdev, struct virtio_gpu_config,\r\nevents_read, &events_read);\r\nif (events_read & VIRTIO_GPU_EVENT_DISPLAY) {\r\nvirtio_gpu_cmd_get_display_info(vgdev);\r\ndrm_helper_hpd_irq_event(vgdev->ddev);\r\nevents_clear |= VIRTIO_GPU_EVENT_DISPLAY;\r\n}\r\nvirtio_cwrite(vgdev->vdev, struct virtio_gpu_config,\r\nevents_clear, &events_clear);\r\n}\r\nstatic void virtio_gpu_ctx_id_get(struct virtio_gpu_device *vgdev,\r\nuint32_t *resid)\r\n{\r\nint handle;\r\nidr_preload(GFP_KERNEL);\r\nspin_lock(&vgdev->ctx_id_idr_lock);\r\nhandle = idr_alloc(&vgdev->ctx_id_idr, NULL, 1, 0, 0);\r\nspin_unlock(&vgdev->ctx_id_idr_lock);\r\nidr_preload_end();\r\n*resid = handle;\r\n}\r\nstatic void virtio_gpu_ctx_id_put(struct virtio_gpu_device *vgdev, uint32_t id)\r\n{\r\nspin_lock(&vgdev->ctx_id_idr_lock);\r\nidr_remove(&vgdev->ctx_id_idr, id);\r\nspin_unlock(&vgdev->ctx_id_idr_lock);\r\n}\r\nstatic void virtio_gpu_context_create(struct virtio_gpu_device *vgdev,\r\nuint32_t nlen, const char *name,\r\nuint32_t *ctx_id)\r\n{\r\nvirtio_gpu_ctx_id_get(vgdev, ctx_id);\r\nvirtio_gpu_cmd_context_create(vgdev, *ctx_id, nlen, name);\r\n}\r\nstatic void virtio_gpu_context_destroy(struct virtio_gpu_device *vgdev,\r\nuint32_t ctx_id)\r\n{\r\nvirtio_gpu_cmd_context_destroy(vgdev, ctx_id);\r\nvirtio_gpu_ctx_id_put(vgdev, ctx_id);\r\n}\r\nstatic void virtio_gpu_init_vq(struct virtio_gpu_queue *vgvq,\r\nvoid (*work_func)(struct work_struct *work))\r\n{\r\nspin_lock_init(&vgvq->qlock);\r\ninit_waitqueue_head(&vgvq->ack_queue);\r\nINIT_WORK(&vgvq->dequeue_work, work_func);\r\n}\r\nstatic void virtio_gpu_get_capsets(struct virtio_gpu_device *vgdev,\r\nint num_capsets)\r\n{\r\nint i, ret;\r\nvgdev->capsets = kcalloc(num_capsets,\r\nsizeof(struct virtio_gpu_drv_capset),\r\nGFP_KERNEL);\r\nif (!vgdev->capsets) {\r\nDRM_ERROR("failed to allocate cap sets\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < num_capsets; i++) {\r\nvirtio_gpu_cmd_get_capset_info(vgdev, i);\r\nret = wait_event_timeout(vgdev->resp_wq,\r\nvgdev->capsets[i].id > 0, 5 * HZ);\r\nif (ret == 0) {\r\nDRM_ERROR("timed out waiting for cap set %d\n", i);\r\nkfree(vgdev->capsets);\r\nvgdev->capsets = NULL;\r\nreturn;\r\n}\r\nDRM_INFO("cap set %d: id %d, max-version %d, max-size %d\n",\r\ni, vgdev->capsets[i].id,\r\nvgdev->capsets[i].max_version,\r\nvgdev->capsets[i].max_size);\r\n}\r\nvgdev->num_capsets = num_capsets;\r\n}\r\nint virtio_gpu_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstatic vq_callback_t *callbacks[] = {\r\nvirtio_gpu_ctrl_ack, virtio_gpu_cursor_ack\r\n};\r\nstatic const char * const names[] = { "control", "cursor" };\r\nstruct virtio_gpu_device *vgdev;\r\nstruct virtqueue *vqs[2];\r\nu32 num_scanouts, num_capsets;\r\nint ret;\r\nif (!virtio_has_feature(dev->virtdev, VIRTIO_F_VERSION_1))\r\nreturn -ENODEV;\r\nvgdev = kzalloc(sizeof(struct virtio_gpu_device), GFP_KERNEL);\r\nif (!vgdev)\r\nreturn -ENOMEM;\r\nvgdev->ddev = dev;\r\ndev->dev_private = vgdev;\r\nvgdev->vdev = dev->virtdev;\r\nvgdev->dev = dev->dev;\r\nspin_lock_init(&vgdev->display_info_lock);\r\nspin_lock_init(&vgdev->ctx_id_idr_lock);\r\nidr_init(&vgdev->ctx_id_idr);\r\nspin_lock_init(&vgdev->resource_idr_lock);\r\nidr_init(&vgdev->resource_idr);\r\ninit_waitqueue_head(&vgdev->resp_wq);\r\nvirtio_gpu_init_vq(&vgdev->ctrlq, virtio_gpu_dequeue_ctrl_func);\r\nvirtio_gpu_init_vq(&vgdev->cursorq, virtio_gpu_dequeue_cursor_func);\r\nspin_lock_init(&vgdev->fence_drv.lock);\r\nINIT_LIST_HEAD(&vgdev->fence_drv.fences);\r\nINIT_LIST_HEAD(&vgdev->cap_cache);\r\nINIT_WORK(&vgdev->config_changed_work,\r\nvirtio_gpu_config_changed_work_func);\r\nif (virtio_has_feature(vgdev->vdev, VIRTIO_GPU_F_VIRGL))\r\nvgdev->has_virgl_3d = true;\r\nDRM_INFO("virgl 3d acceleration %s\n",\r\nvgdev->has_virgl_3d ? "enabled" : "not available");\r\nret = vgdev->vdev->config->find_vqs(vgdev->vdev, 2, vqs,\r\ncallbacks, names);\r\nif (ret) {\r\nDRM_ERROR("failed to find virt queues\n");\r\ngoto err_vqs;\r\n}\r\nvgdev->ctrlq.vq = vqs[0];\r\nvgdev->cursorq.vq = vqs[1];\r\nret = virtio_gpu_alloc_vbufs(vgdev);\r\nif (ret) {\r\nDRM_ERROR("failed to alloc vbufs\n");\r\ngoto err_vbufs;\r\n}\r\nret = virtio_gpu_ttm_init(vgdev);\r\nif (ret) {\r\nDRM_ERROR("failed to init ttm %d\n", ret);\r\ngoto err_ttm;\r\n}\r\nvirtio_cread(vgdev->vdev, struct virtio_gpu_config,\r\nnum_scanouts, &num_scanouts);\r\nvgdev->num_scanouts = min_t(uint32_t, num_scanouts,\r\nVIRTIO_GPU_MAX_SCANOUTS);\r\nif (!vgdev->num_scanouts) {\r\nDRM_ERROR("num_scanouts is zero\n");\r\nret = -EINVAL;\r\ngoto err_scanouts;\r\n}\r\nDRM_INFO("number of scanouts: %d\n", num_scanouts);\r\nvirtio_cread(vgdev->vdev, struct virtio_gpu_config,\r\nnum_capsets, &num_capsets);\r\nDRM_INFO("number of cap sets: %d\n", num_capsets);\r\nret = virtio_gpu_modeset_init(vgdev);\r\nif (ret)\r\ngoto err_modeset;\r\nvirtio_device_ready(vgdev->vdev);\r\nvgdev->vqs_ready = true;\r\nif (num_capsets)\r\nvirtio_gpu_get_capsets(vgdev, num_capsets);\r\nvirtio_gpu_cmd_get_display_info(vgdev);\r\nwait_event_timeout(vgdev->resp_wq, !vgdev->display_info_pending,\r\n5 * HZ);\r\nif (virtio_gpu_fbdev)\r\nvirtio_gpu_fbdev_init(vgdev);\r\nreturn 0;\r\nerr_modeset:\r\nerr_scanouts:\r\nvirtio_gpu_ttm_fini(vgdev);\r\nerr_ttm:\r\nvirtio_gpu_free_vbufs(vgdev);\r\nerr_vbufs:\r\nvgdev->vdev->config->del_vqs(vgdev->vdev);\r\nerr_vqs:\r\nkfree(vgdev);\r\nreturn ret;\r\n}\r\nstatic void virtio_gpu_cleanup_cap_cache(struct virtio_gpu_device *vgdev)\r\n{\r\nstruct virtio_gpu_drv_cap_cache *cache_ent, *tmp;\r\nlist_for_each_entry_safe(cache_ent, tmp, &vgdev->cap_cache, head) {\r\nkfree(cache_ent->caps_cache);\r\nkfree(cache_ent);\r\n}\r\n}\r\nint virtio_gpu_driver_unload(struct drm_device *dev)\r\n{\r\nstruct virtio_gpu_device *vgdev = dev->dev_private;\r\nvgdev->vqs_ready = false;\r\nflush_work(&vgdev->ctrlq.dequeue_work);\r\nflush_work(&vgdev->cursorq.dequeue_work);\r\nflush_work(&vgdev->config_changed_work);\r\nvgdev->vdev->config->del_vqs(vgdev->vdev);\r\nvirtio_gpu_modeset_fini(vgdev);\r\nvirtio_gpu_ttm_fini(vgdev);\r\nvirtio_gpu_free_vbufs(vgdev);\r\nvirtio_gpu_cleanup_cap_cache(vgdev);\r\nkfree(vgdev->capsets);\r\nkfree(vgdev);\r\nreturn 0;\r\n}\r\nint virtio_gpu_driver_open(struct drm_device *dev, struct drm_file *file)\r\n{\r\nstruct virtio_gpu_device *vgdev = dev->dev_private;\r\nstruct virtio_gpu_fpriv *vfpriv;\r\nuint32_t id;\r\nchar dbgname[64], tmpname[TASK_COMM_LEN];\r\nif (!vgdev->has_virgl_3d)\r\nreturn 0;\r\nget_task_comm(tmpname, current);\r\nsnprintf(dbgname, sizeof(dbgname), "%s", tmpname);\r\ndbgname[63] = 0;\r\nvfpriv = kzalloc(sizeof(*vfpriv), GFP_KERNEL);\r\nif (!vfpriv)\r\nreturn -ENOMEM;\r\nvirtio_gpu_context_create(vgdev, strlen(dbgname), dbgname, &id);\r\nvfpriv->ctx_id = id;\r\nfile->driver_priv = vfpriv;\r\nreturn 0;\r\n}\r\nvoid virtio_gpu_driver_postclose(struct drm_device *dev, struct drm_file *file)\r\n{\r\nstruct virtio_gpu_device *vgdev = dev->dev_private;\r\nstruct virtio_gpu_fpriv *vfpriv;\r\nif (!vgdev->has_virgl_3d)\r\nreturn;\r\nvfpriv = file->driver_priv;\r\nvirtio_gpu_context_destroy(vgdev, vfpriv->ctx_id);\r\nkfree(vfpriv);\r\nfile->driver_priv = NULL;\r\n}
