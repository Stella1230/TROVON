int pmd_huge(pmd_t pmd)\r\n{\r\nreturn pmd_val(pmd) && !(pmd_val(pmd) & PMD_TABLE_BIT);\r\n}\r\nint pud_huge(pud_t pud)\r\n{\r\n#ifndef __PAGETABLE_PMD_FOLDED\r\nreturn pud_val(pud) && !(pud_val(pud) & PUD_TABLE_BIT);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int find_num_contig(struct mm_struct *mm, unsigned long addr,\r\npte_t *ptep, pte_t pte, size_t *pgsize)\r\n{\r\npgd_t *pgd = pgd_offset(mm, addr);\r\npud_t *pud;\r\npmd_t *pmd;\r\n*pgsize = PAGE_SIZE;\r\nif (!pte_cont(pte))\r\nreturn 1;\r\nif (!pgd_present(*pgd)) {\r\nVM_BUG_ON(!pgd_present(*pgd));\r\nreturn 1;\r\n}\r\npud = pud_offset(pgd, addr);\r\nif (!pud_present(*pud)) {\r\nVM_BUG_ON(!pud_present(*pud));\r\nreturn 1;\r\n}\r\npmd = pmd_offset(pud, addr);\r\nif (!pmd_present(*pmd)) {\r\nVM_BUG_ON(!pmd_present(*pmd));\r\nreturn 1;\r\n}\r\nif ((pte_t *)pmd == ptep) {\r\n*pgsize = PMD_SIZE;\r\nreturn CONT_PMDS;\r\n}\r\nreturn CONT_PTES;\r\n}\r\nvoid set_huge_pte_at(struct mm_struct *mm, unsigned long addr,\r\npte_t *ptep, pte_t pte)\r\n{\r\nsize_t pgsize;\r\nint i;\r\nint ncontig = find_num_contig(mm, addr, ptep, pte, &pgsize);\r\nunsigned long pfn;\r\npgprot_t hugeprot;\r\nif (ncontig == 1) {\r\nset_pte_at(mm, addr, ptep, pte);\r\nreturn;\r\n}\r\npfn = pte_pfn(pte);\r\nhugeprot = __pgprot(pte_val(pfn_pte(pfn, __pgprot(0))) ^ pte_val(pte));\r\nfor (i = 0; i < ncontig; i++) {\r\npr_debug("%s: set pte %p to 0x%llx\n", __func__, ptep,\r\npte_val(pfn_pte(pfn, hugeprot)));\r\nset_pte_at(mm, addr, ptep, pfn_pte(pfn, hugeprot));\r\nptep++;\r\npfn += pgsize >> PAGE_SHIFT;\r\naddr += pgsize;\r\n}\r\n}\r\npte_t *huge_pte_alloc(struct mm_struct *mm,\r\nunsigned long addr, unsigned long sz)\r\n{\r\npgd_t *pgd;\r\npud_t *pud;\r\npte_t *pte = NULL;\r\npr_debug("%s: addr:0x%lx sz:0x%lx\n", __func__, addr, sz);\r\npgd = pgd_offset(mm, addr);\r\npud = pud_alloc(mm, pgd, addr);\r\nif (!pud)\r\nreturn NULL;\r\nif (sz == PUD_SIZE) {\r\npte = (pte_t *)pud;\r\n} else if (sz == (PAGE_SIZE * CONT_PTES)) {\r\npmd_t *pmd = pmd_alloc(mm, pud, addr);\r\nWARN_ON(addr & (sz - 1));\r\npte = pte_alloc_map(mm, pmd, addr);\r\n} else if (sz == PMD_SIZE) {\r\nif (IS_ENABLED(CONFIG_ARCH_WANT_HUGE_PMD_SHARE) &&\r\npud_none(*pud))\r\npte = huge_pmd_share(mm, addr, pud);\r\nelse\r\npte = (pte_t *)pmd_alloc(mm, pud, addr);\r\n} else if (sz == (PMD_SIZE * CONT_PMDS)) {\r\npmd_t *pmd;\r\npmd = pmd_alloc(mm, pud, addr);\r\nWARN_ON(addr & (sz - 1));\r\nreturn (pte_t *)pmd;\r\n}\r\npr_debug("%s: addr:0x%lx sz:0x%lx ret pte=%p/0x%llx\n", __func__, addr,\r\nsz, pte, pte_val(*pte));\r\nreturn pte;\r\n}\r\npte_t *huge_pte_offset(struct mm_struct *mm, unsigned long addr)\r\n{\r\npgd_t *pgd;\r\npud_t *pud;\r\npmd_t *pmd = NULL;\r\npte_t *pte = NULL;\r\npgd = pgd_offset(mm, addr);\r\npr_debug("%s: addr:0x%lx pgd:%p\n", __func__, addr, pgd);\r\nif (!pgd_present(*pgd))\r\nreturn NULL;\r\npud = pud_offset(pgd, addr);\r\nif (!pud_present(*pud))\r\nreturn NULL;\r\nif (pud_huge(*pud))\r\nreturn (pte_t *)pud;\r\npmd = pmd_offset(pud, addr);\r\nif (!pmd_present(*pmd))\r\nreturn NULL;\r\nif (pte_cont(pmd_pte(*pmd))) {\r\npmd = pmd_offset(\r\npud, (addr & CONT_PMD_MASK));\r\nreturn (pte_t *)pmd;\r\n}\r\nif (pmd_huge(*pmd))\r\nreturn (pte_t *)pmd;\r\npte = pte_offset_kernel(pmd, addr);\r\nif (pte_present(*pte) && pte_cont(*pte)) {\r\npte = pte_offset_kernel(\r\npmd, (addr & CONT_PTE_MASK));\r\nreturn pte;\r\n}\r\nreturn NULL;\r\n}\r\npte_t arch_make_huge_pte(pte_t entry, struct vm_area_struct *vma,\r\nstruct page *page, int writable)\r\n{\r\nsize_t pagesize = huge_page_size(hstate_vma(vma));\r\nif (pagesize == CONT_PTE_SIZE) {\r\nentry = pte_mkcont(entry);\r\n} else if (pagesize == CONT_PMD_SIZE) {\r\nentry = pmd_pte(pmd_mkcont(pte_pmd(entry)));\r\n} else if (pagesize != PUD_SIZE && pagesize != PMD_SIZE) {\r\npr_warn("%s: unrecognized huge page size 0x%lx\n",\r\n__func__, pagesize);\r\n}\r\nreturn entry;\r\n}\r\npte_t huge_ptep_get_and_clear(struct mm_struct *mm,\r\nunsigned long addr, pte_t *ptep)\r\n{\r\npte_t pte;\r\nif (pte_cont(*ptep)) {\r\nint ncontig, i;\r\nsize_t pgsize;\r\npte_t *cpte;\r\nbool is_dirty = false;\r\ncpte = huge_pte_offset(mm, addr);\r\nncontig = find_num_contig(mm, addr, cpte, *cpte, &pgsize);\r\npte = ptep_get_and_clear(mm, addr, cpte);\r\nfor (i = 1; i < ncontig; ++i) {\r\n++cpte;\r\nif (pte_dirty(ptep_get_and_clear(mm, addr, cpte)))\r\nis_dirty = true;\r\n}\r\nif (is_dirty)\r\nreturn pte_mkdirty(pte);\r\nelse\r\nreturn pte;\r\n} else {\r\nreturn ptep_get_and_clear(mm, addr, ptep);\r\n}\r\n}\r\nint huge_ptep_set_access_flags(struct vm_area_struct *vma,\r\nunsigned long addr, pte_t *ptep,\r\npte_t pte, int dirty)\r\n{\r\npte_t *cpte;\r\nif (pte_cont(pte)) {\r\nint ncontig, i, changed = 0;\r\nsize_t pgsize = 0;\r\nunsigned long pfn = pte_pfn(pte);\r\npgprot_t hugeprot =\r\n__pgprot(pte_val(pfn_pte(pfn, __pgprot(0))) ^\r\npte_val(pte));\r\ncpte = huge_pte_offset(vma->vm_mm, addr);\r\npfn = pte_pfn(*cpte);\r\nncontig = find_num_contig(vma->vm_mm, addr, cpte,\r\n*cpte, &pgsize);\r\nfor (i = 0; i < ncontig; ++i, ++cpte) {\r\nchanged = ptep_set_access_flags(vma, addr, cpte,\r\npfn_pte(pfn,\r\nhugeprot),\r\ndirty);\r\npfn += pgsize >> PAGE_SHIFT;\r\n}\r\nreturn changed;\r\n} else {\r\nreturn ptep_set_access_flags(vma, addr, ptep, pte, dirty);\r\n}\r\n}\r\nvoid huge_ptep_set_wrprotect(struct mm_struct *mm,\r\nunsigned long addr, pte_t *ptep)\r\n{\r\nif (pte_cont(*ptep)) {\r\nint ncontig, i;\r\npte_t *cpte;\r\nsize_t pgsize = 0;\r\ncpte = huge_pte_offset(mm, addr);\r\nncontig = find_num_contig(mm, addr, cpte, *cpte, &pgsize);\r\nfor (i = 0; i < ncontig; ++i, ++cpte)\r\nptep_set_wrprotect(mm, addr, cpte);\r\n} else {\r\nptep_set_wrprotect(mm, addr, ptep);\r\n}\r\n}\r\nvoid huge_ptep_clear_flush(struct vm_area_struct *vma,\r\nunsigned long addr, pte_t *ptep)\r\n{\r\nif (pte_cont(*ptep)) {\r\nint ncontig, i;\r\npte_t *cpte;\r\nsize_t pgsize = 0;\r\ncpte = huge_pte_offset(vma->vm_mm, addr);\r\nncontig = find_num_contig(vma->vm_mm, addr, cpte,\r\n*cpte, &pgsize);\r\nfor (i = 0; i < ncontig; ++i, ++cpte)\r\nptep_clear_flush(vma, addr, cpte);\r\n} else {\r\nptep_clear_flush(vma, addr, ptep);\r\n}\r\n}\r\nstatic __init int setup_hugepagesz(char *opt)\r\n{\r\nunsigned long ps = memparse(opt, &opt);\r\nif (ps == PMD_SIZE) {\r\nhugetlb_add_hstate(PMD_SHIFT - PAGE_SHIFT);\r\n} else if (ps == PUD_SIZE) {\r\nhugetlb_add_hstate(PUD_SHIFT - PAGE_SHIFT);\r\n} else if (ps == (PAGE_SIZE * CONT_PTES)) {\r\nhugetlb_add_hstate(CONT_PTE_SHIFT);\r\n} else if (ps == (PMD_SIZE * CONT_PMDS)) {\r\nhugetlb_add_hstate((PMD_SHIFT + CONT_PMD_SHIFT) - PAGE_SHIFT);\r\n} else {\r\nhugetlb_bad_size();\r\npr_err("hugepagesz: Unsupported page size %lu K\n", ps >> 10);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic __init int add_default_hugepagesz(void)\r\n{\r\nif (size_to_hstate(CONT_PTES * PAGE_SIZE) == NULL)\r\nhugetlb_add_hstate(CONT_PMD_SHIFT);\r\nreturn 0;\r\n}
