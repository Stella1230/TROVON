static int ptp_disable_pinfunc(struct ptp_clock_info *ops,\r\nenum ptp_pin_function func, unsigned int chan)\r\n{\r\nstruct ptp_clock_request rq;\r\nint err = 0;\r\nmemset(&rq, 0, sizeof(rq));\r\nswitch (func) {\r\ncase PTP_PF_NONE:\r\nbreak;\r\ncase PTP_PF_EXTTS:\r\nrq.type = PTP_CLK_REQ_EXTTS;\r\nrq.extts.index = chan;\r\nerr = ops->enable(ops, &rq, 0);\r\nbreak;\r\ncase PTP_PF_PEROUT:\r\nrq.type = PTP_CLK_REQ_PEROUT;\r\nrq.perout.index = chan;\r\nerr = ops->enable(ops, &rq, 0);\r\nbreak;\r\ncase PTP_PF_PHYSYNC:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nint ptp_set_pinfunc(struct ptp_clock *ptp, unsigned int pin,\r\nenum ptp_pin_function func, unsigned int chan)\r\n{\r\nstruct ptp_clock_info *info = ptp->info;\r\nstruct ptp_pin_desc *pin1 = NULL, *pin2 = &info->pin_config[pin];\r\nunsigned int i;\r\nfor (i = 0; i < info->n_pins; i++) {\r\nif (info->pin_config[i].func == func &&\r\ninfo->pin_config[i].chan == chan) {\r\npin1 = &info->pin_config[i];\r\nbreak;\r\n}\r\n}\r\nif (pin1 && i == pin)\r\nreturn 0;\r\nswitch (func) {\r\ncase PTP_PF_NONE:\r\nbreak;\r\ncase PTP_PF_EXTTS:\r\nif (chan >= info->n_ext_ts)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PTP_PF_PEROUT:\r\nif (chan >= info->n_per_out)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PTP_PF_PHYSYNC:\r\nif (chan != 0)\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (info->verify(info, pin, func, chan)) {\r\npr_err("driver cannot use function %u on pin %u\n", func, chan);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (pin1) {\r\nptp_disable_pinfunc(info, func, chan);\r\npin1->func = PTP_PF_NONE;\r\npin1->chan = 0;\r\n}\r\nptp_disable_pinfunc(info, pin2->func, pin2->chan);\r\npin2->func = func;\r\npin2->chan = chan;\r\nreturn 0;\r\n}\r\nint ptp_open(struct posix_clock *pc, fmode_t fmode)\r\n{\r\nreturn 0;\r\n}\r\nlong ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct ptp_clock_caps caps;\r\nstruct ptp_clock_request req;\r\nstruct ptp_sys_offset *sysoff = NULL;\r\nstruct ptp_sys_offset_precise precise_offset;\r\nstruct ptp_pin_desc pd;\r\nstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\r\nstruct ptp_clock_info *ops = ptp->info;\r\nstruct ptp_clock_time *pct;\r\nstruct timespec64 ts;\r\nstruct system_device_crosststamp xtstamp;\r\nint enable, err = 0;\r\nunsigned int i, pin_index;\r\nswitch (cmd) {\r\ncase PTP_CLOCK_GETCAPS:\r\nmemset(&caps, 0, sizeof(caps));\r\ncaps.max_adj = ptp->info->max_adj;\r\ncaps.n_alarm = ptp->info->n_alarm;\r\ncaps.n_ext_ts = ptp->info->n_ext_ts;\r\ncaps.n_per_out = ptp->info->n_per_out;\r\ncaps.pps = ptp->info->pps;\r\ncaps.n_pins = ptp->info->n_pins;\r\ncaps.cross_timestamping = ptp->info->getcrosststamp != NULL;\r\nif (copy_to_user((void __user *)arg, &caps, sizeof(caps)))\r\nerr = -EFAULT;\r\nbreak;\r\ncase PTP_EXTTS_REQUEST:\r\nif (copy_from_user(&req.extts, (void __user *)arg,\r\nsizeof(req.extts))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (req.extts.index >= ops->n_ext_ts) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreq.type = PTP_CLK_REQ_EXTTS;\r\nenable = req.extts.flags & PTP_ENABLE_FEATURE ? 1 : 0;\r\nerr = ops->enable(ops, &req, enable);\r\nbreak;\r\ncase PTP_PEROUT_REQUEST:\r\nif (copy_from_user(&req.perout, (void __user *)arg,\r\nsizeof(req.perout))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (req.perout.index >= ops->n_per_out) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreq.type = PTP_CLK_REQ_PEROUT;\r\nenable = req.perout.period.sec || req.perout.period.nsec;\r\nerr = ops->enable(ops, &req, enable);\r\nbreak;\r\ncase PTP_ENABLE_PPS:\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EPERM;\r\nreq.type = PTP_CLK_REQ_PPS;\r\nenable = arg ? 1 : 0;\r\nerr = ops->enable(ops, &req, enable);\r\nbreak;\r\ncase PTP_SYS_OFFSET_PRECISE:\r\nif (!ptp->info->getcrosststamp) {\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nerr = ptp->info->getcrosststamp(ptp->info, &xtstamp);\r\nif (err)\r\nbreak;\r\nts = ktime_to_timespec64(xtstamp.device);\r\nprecise_offset.device.sec = ts.tv_sec;\r\nprecise_offset.device.nsec = ts.tv_nsec;\r\nts = ktime_to_timespec64(xtstamp.sys_realtime);\r\nprecise_offset.sys_realtime.sec = ts.tv_sec;\r\nprecise_offset.sys_realtime.nsec = ts.tv_nsec;\r\nts = ktime_to_timespec64(xtstamp.sys_monoraw);\r\nprecise_offset.sys_monoraw.sec = ts.tv_sec;\r\nprecise_offset.sys_monoraw.nsec = ts.tv_nsec;\r\nif (copy_to_user((void __user *)arg, &precise_offset,\r\nsizeof(precise_offset)))\r\nerr = -EFAULT;\r\nbreak;\r\ncase PTP_SYS_OFFSET:\r\nsysoff = memdup_user((void __user *)arg, sizeof(*sysoff));\r\nif (IS_ERR(sysoff)) {\r\nerr = PTR_ERR(sysoff);\r\nsysoff = NULL;\r\nbreak;\r\n}\r\nif (sysoff->n_samples > PTP_MAX_SAMPLES) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\npct = &sysoff->ts[0];\r\nfor (i = 0; i < sysoff->n_samples; i++) {\r\ngetnstimeofday64(&ts);\r\npct->sec = ts.tv_sec;\r\npct->nsec = ts.tv_nsec;\r\npct++;\r\nptp->info->gettime64(ptp->info, &ts);\r\npct->sec = ts.tv_sec;\r\npct->nsec = ts.tv_nsec;\r\npct++;\r\n}\r\ngetnstimeofday64(&ts);\r\npct->sec = ts.tv_sec;\r\npct->nsec = ts.tv_nsec;\r\nif (copy_to_user((void __user *)arg, sysoff, sizeof(*sysoff)))\r\nerr = -EFAULT;\r\nbreak;\r\ncase PTP_PIN_GETFUNC:\r\nif (copy_from_user(&pd, (void __user *)arg, sizeof(pd))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\npin_index = pd.index;\r\nif (pin_index >= ops->n_pins) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (mutex_lock_interruptible(&ptp->pincfg_mux))\r\nreturn -ERESTARTSYS;\r\npd = ops->pin_config[pin_index];\r\nmutex_unlock(&ptp->pincfg_mux);\r\nif (!err && copy_to_user((void __user *)arg, &pd, sizeof(pd)))\r\nerr = -EFAULT;\r\nbreak;\r\ncase PTP_PIN_SETFUNC:\r\nif (copy_from_user(&pd, (void __user *)arg, sizeof(pd))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\npin_index = pd.index;\r\nif (pin_index >= ops->n_pins) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (mutex_lock_interruptible(&ptp->pincfg_mux))\r\nreturn -ERESTARTSYS;\r\nerr = ptp_set_pinfunc(ptp, pin_index, pd.func, pd.chan);\r\nmutex_unlock(&ptp->pincfg_mux);\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nkfree(sysoff);\r\nreturn err;\r\n}\r\nunsigned int ptp_poll(struct posix_clock *pc, struct file *fp, poll_table *wait)\r\n{\r\nstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\r\npoll_wait(fp, &ptp->tsev_wq, wait);\r\nreturn queue_cnt(&ptp->tsevq) ? POLLIN : 0;\r\n}\r\nssize_t ptp_read(struct posix_clock *pc,\r\nuint rdflags, char __user *buf, size_t cnt)\r\n{\r\nstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\r\nstruct timestamp_event_queue *queue = &ptp->tsevq;\r\nstruct ptp_extts_event *event;\r\nunsigned long flags;\r\nsize_t qcnt, i;\r\nint result;\r\nif (cnt % sizeof(struct ptp_extts_event) != 0)\r\nreturn -EINVAL;\r\nif (cnt > EXTTS_BUFSIZE)\r\ncnt = EXTTS_BUFSIZE;\r\ncnt = cnt / sizeof(struct ptp_extts_event);\r\nif (mutex_lock_interruptible(&ptp->tsevq_mux))\r\nreturn -ERESTARTSYS;\r\nif (wait_event_interruptible(ptp->tsev_wq,\r\nptp->defunct || queue_cnt(queue))) {\r\nmutex_unlock(&ptp->tsevq_mux);\r\nreturn -ERESTARTSYS;\r\n}\r\nif (ptp->defunct) {\r\nmutex_unlock(&ptp->tsevq_mux);\r\nreturn -ENODEV;\r\n}\r\nevent = kmalloc(EXTTS_BUFSIZE, GFP_KERNEL);\r\nif (!event) {\r\nmutex_unlock(&ptp->tsevq_mux);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&queue->lock, flags);\r\nqcnt = queue_cnt(queue);\r\nif (cnt > qcnt)\r\ncnt = qcnt;\r\nfor (i = 0; i < cnt; i++) {\r\nevent[i] = queue->buf[queue->head];\r\nqueue->head = (queue->head + 1) % PTP_MAX_TIMESTAMPS;\r\n}\r\nspin_unlock_irqrestore(&queue->lock, flags);\r\ncnt = cnt * sizeof(struct ptp_extts_event);\r\nmutex_unlock(&ptp->tsevq_mux);\r\nresult = cnt;\r\nif (copy_to_user(buf, event, cnt))\r\nresult = -EFAULT;\r\nkfree(event);\r\nreturn result;\r\n}
