int hw_sm750_map(struct sm750_dev *sm750_dev, struct pci_dev *pdev)\r\n{\r\nint ret;\r\nret = 0;\r\nsm750_dev->vidreg_start = pci_resource_start(pdev, 1);\r\nsm750_dev->vidreg_size = SZ_2M;\r\npr_info("mmio phyAddr = %lx\n", sm750_dev->vidreg_start);\r\nret = pci_request_region(pdev, 1, "sm750fb");\r\nif (ret) {\r\npr_err("Can not request PCI regions.\n");\r\ngoto exit;\r\n}\r\nsm750_dev->pvReg = ioremap_nocache(sm750_dev->vidreg_start,\r\nsm750_dev->vidreg_size);\r\nif (!sm750_dev->pvReg) {\r\npr_err("mmio failed\n");\r\nret = -EFAULT;\r\ngoto exit;\r\n} else {\r\npr_info("mmio virtual addr = %p\n", sm750_dev->pvReg);\r\n}\r\nsm750_dev->accel.dprBase = sm750_dev->pvReg + DE_BASE_ADDR_TYPE1;\r\nsm750_dev->accel.dpPortBase = sm750_dev->pvReg + DE_PORT_ADDR_TYPE1;\r\nddk750_set_mmio(sm750_dev->pvReg, sm750_dev->devid, sm750_dev->revid);\r\nsm750_dev->vidmem_start = pci_resource_start(pdev, 0);\r\nsm750_dev->vidmem_size = ddk750_getVMSize();\r\npr_info("video memory phyAddr = %lx, size = %u bytes\n",\r\nsm750_dev->vidmem_start, sm750_dev->vidmem_size);\r\nsm750_dev->pvMem = ioremap_wc(sm750_dev->vidmem_start,\r\nsm750_dev->vidmem_size);\r\nif (!sm750_dev->pvMem) {\r\npr_err("Map video memory failed\n");\r\nret = -EFAULT;\r\ngoto exit;\r\n} else {\r\npr_info("video memory vaddr = %p\n", sm750_dev->pvMem);\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nint hw_sm750_inithw(struct sm750_dev *sm750_dev, struct pci_dev *pdev)\r\n{\r\nstruct init_status *parm;\r\nparm = &sm750_dev->initParm;\r\nif (parm->chip_clk == 0)\r\nparm->chip_clk = (getChipType() == SM750LE) ?\r\nDEFAULT_SM750LE_CHIP_CLOCK :\r\nDEFAULT_SM750_CHIP_CLOCK;\r\nif (parm->mem_clk == 0)\r\nparm->mem_clk = parm->chip_clk;\r\nif (parm->master_clk == 0)\r\nparm->master_clk = parm->chip_clk/3;\r\nddk750_initHw((initchip_param_t *)&sm750_dev->initParm);\r\nif (sm750_dev->devid == 0x718) {\r\nPOKE32(SYSTEM_CTRL,\r\nPEEK32(SYSTEM_CTRL) | SYSTEM_CTRL_PCI_BURST);\r\n}\r\nif (getChipType() != SM750LE) {\r\nunsigned int val;\r\nif (sm750_dev->nocrt) {\r\nPOKE32(MISC_CTRL,\r\nPEEK32(MISC_CTRL) | MISC_CTRL_DAC_POWER_OFF);\r\nval = PEEK32(SYSTEM_CTRL) & ~SYSTEM_CTRL_DPMS_MASK;\r\nval |= SYSTEM_CTRL_DPMS_VPHN;\r\nPOKE32(SYSTEM_CTRL, val);\r\n} else {\r\nPOKE32(MISC_CTRL,\r\nPEEK32(MISC_CTRL) & ~MISC_CTRL_DAC_POWER_OFF);\r\nval = PEEK32(SYSTEM_CTRL) & ~SYSTEM_CTRL_DPMS_MASK;\r\nval |= SYSTEM_CTRL_DPMS_VPHP;\r\nPOKE32(SYSTEM_CTRL, val);\r\n}\r\nval = PEEK32(PANEL_DISPLAY_CTRL) &\r\n~(PANEL_DISPLAY_CTRL_DUAL_DISPLAY |\r\nPANEL_DISPLAY_CTRL_DOUBLE_PIXEL);\r\nswitch (sm750_dev->pnltype) {\r\ncase sm750_24TFT:\r\nbreak;\r\ncase sm750_doubleTFT:\r\nval |= PANEL_DISPLAY_CTRL_DOUBLE_PIXEL;\r\nbreak;\r\ncase sm750_dualTFT:\r\nval |= PANEL_DISPLAY_CTRL_DUAL_DISPLAY;\r\nbreak;\r\n}\r\nPOKE32(PANEL_DISPLAY_CTRL, val);\r\n} else {\r\nsm750_sw_i2c_init(0, 1);\r\nif (sm750_sw_i2c_read_reg(0xec, 0x4a) == 0x95) {\r\npr_info("yes,CH7301 DVI chip found\n");\r\nsm750_sw_i2c_write_reg(0xec, 0x1d, 0x16);\r\nsm750_sw_i2c_write_reg(0xec, 0x21, 0x9);\r\nsm750_sw_i2c_write_reg(0xec, 0x49, 0xC0);\r\npr_info("okay,CH7301 DVI chip setup done\n");\r\n}\r\n}\r\nif (!sm750_dev->accel_off)\r\nhw_sm750_initAccel(sm750_dev);\r\nreturn 0;\r\n}\r\nint hw_sm750_output_setMode(struct lynxfb_output *output,\r\nstruct fb_var_screeninfo *var, struct fb_fix_screeninfo *fix)\r\n{\r\nint ret;\r\ndisp_output_t dispSet;\r\nint channel;\r\nret = 0;\r\ndispSet = 0;\r\nchannel = *output->channel;\r\nif (getChipType() != SM750LE) {\r\nif (channel == sm750_primary) {\r\npr_info("primary channel\n");\r\nif (output->paths & sm750_panel)\r\ndispSet |= do_LCD1_PRI;\r\nif (output->paths & sm750_crt)\r\ndispSet |= do_CRT_PRI;\r\n} else {\r\npr_info("secondary channel\n");\r\nif (output->paths & sm750_panel)\r\ndispSet |= do_LCD1_SEC;\r\nif (output->paths & sm750_crt)\r\ndispSet |= do_CRT_SEC;\r\n}\r\nddk750_setLogicalDispOut(dispSet);\r\n} else {\r\nu32 reg;\r\nreg = PEEK32(DISPLAY_CONTROL_750LE);\r\nreg |= 0xf;\r\nPOKE32(DISPLAY_CONTROL_750LE, reg);\r\n}\r\npr_info("ddk setlogicdispout done\n");\r\nreturn ret;\r\n}\r\nint hw_sm750_crtc_checkMode(struct lynxfb_crtc *crtc, struct fb_var_screeninfo *var)\r\n{\r\nstruct sm750_dev *sm750_dev;\r\nstruct lynxfb_par *par = container_of(crtc, struct lynxfb_par, crtc);\r\nsm750_dev = par->dev;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\ncase 16:\r\nbreak;\r\ncase 32:\r\nif (sm750_dev->revid == SM750LE_REVISION_ID) {\r\npr_debug("750le do not support 32bpp\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint hw_sm750_crtc_setMode(struct lynxfb_crtc *crtc,\r\nstruct fb_var_screeninfo *var,\r\nstruct fb_fix_screeninfo *fix)\r\n{\r\nint ret, fmt;\r\nu32 reg;\r\nmode_parameter_t modparm;\r\nclock_type_t clock;\r\nstruct sm750_dev *sm750_dev;\r\nstruct lynxfb_par *par;\r\nret = 0;\r\npar = container_of(crtc, struct lynxfb_par, crtc);\r\nsm750_dev = par->dev;\r\nif (!sm750_dev->accel_off) {\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nfmt = 0;\r\nbreak;\r\ncase 16:\r\nfmt = 1;\r\nbreak;\r\ncase 32:\r\ndefault:\r\nfmt = 2;\r\nbreak;\r\n}\r\nhw_set2dformat(&sm750_dev->accel, fmt);\r\n}\r\nmodparm.pixel_clock = ps_to_hz(var->pixclock);\r\nmodparm.vertical_sync_polarity = (var->sync & FB_SYNC_HOR_HIGH_ACT) ? POS:NEG;\r\nmodparm.horizontal_sync_polarity = (var->sync & FB_SYNC_VERT_HIGH_ACT) ? POS:NEG;\r\nmodparm.clock_phase_polarity = (var->sync & FB_SYNC_COMP_HIGH_ACT) ? POS:NEG;\r\nmodparm.horizontal_display_end = var->xres;\r\nmodparm.horizontal_sync_width = var->hsync_len;\r\nmodparm.horizontal_sync_start = var->xres + var->right_margin;\r\nmodparm.horizontal_total = var->xres + var->left_margin + var->right_margin + var->hsync_len;\r\nmodparm.vertical_display_end = var->yres;\r\nmodparm.vertical_sync_height = var->vsync_len;\r\nmodparm.vertical_sync_start = var->yres + var->lower_margin;\r\nmodparm.vertical_total = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;\r\nif (crtc->channel != sm750_secondary)\r\nclock = PRIMARY_PLL;\r\nelse\r\nclock = SECONDARY_PLL;\r\npr_debug("Request pixel clock = %lu\n", modparm.pixel_clock);\r\nret = ddk750_setModeTiming(&modparm, clock);\r\nif (ret) {\r\npr_err("Set mode timing failed\n");\r\ngoto exit;\r\n}\r\nif (crtc->channel != sm750_secondary) {\r\nPOKE32(PANEL_FB_ADDRESS,\r\ncrtc->oScreen & PANEL_FB_ADDRESS_ADDRESS_MASK);\r\nreg = var->xres * (var->bits_per_pixel >> 3);\r\nreg = ALIGN(reg, crtc->line_pad);\r\nreg = (reg << PANEL_FB_WIDTH_WIDTH_SHIFT) &\r\nPANEL_FB_WIDTH_WIDTH_MASK;\r\nreg |= (fix->line_length & PANEL_FB_WIDTH_OFFSET_MASK);\r\nPOKE32(PANEL_FB_WIDTH, reg);\r\nreg = ((var->xres - 1) << PANEL_WINDOW_WIDTH_WIDTH_SHIFT) &\r\nPANEL_WINDOW_WIDTH_WIDTH_MASK;\r\nreg |= (var->xoffset & PANEL_WINDOW_WIDTH_X_MASK);\r\nPOKE32(PANEL_WINDOW_WIDTH, reg);\r\nreg = ((var->yres_virtual - 1) <<\r\nPANEL_WINDOW_HEIGHT_HEIGHT_SHIFT);\r\nreg &= PANEL_WINDOW_HEIGHT_HEIGHT_MASK;\r\nreg |= (var->yoffset & PANEL_WINDOW_HEIGHT_Y_MASK);\r\nPOKE32(PANEL_WINDOW_HEIGHT, reg);\r\nPOKE32(PANEL_PLANE_TL, 0);\r\nreg = ((var->yres - 1) << PANEL_PLANE_BR_BOTTOM_SHIFT) &\r\nPANEL_PLANE_BR_BOTTOM_MASK;\r\nreg |= ((var->xres - 1) & PANEL_PLANE_BR_RIGHT_MASK);\r\nPOKE32(PANEL_PLANE_BR, reg);\r\nreg = PEEK32(PANEL_DISPLAY_CTRL);\r\nPOKE32(PANEL_DISPLAY_CTRL, reg | (var->bits_per_pixel >> 4));\r\n} else {\r\nPOKE32(CRT_FB_ADDRESS, crtc->oScreen);\r\nreg = var->xres * (var->bits_per_pixel >> 3);\r\nreg = ALIGN(reg, crtc->line_pad) << CRT_FB_WIDTH_WIDTH_SHIFT;\r\nreg &= CRT_FB_WIDTH_WIDTH_MASK;\r\nreg |= (fix->line_length & CRT_FB_WIDTH_OFFSET_MASK);\r\nPOKE32(CRT_FB_WIDTH, reg);\r\nreg = PEEK32(CRT_DISPLAY_CTRL);\r\nreg |= ((var->bits_per_pixel >> 4) &\r\nCRT_DISPLAY_CTRL_FORMAT_MASK);\r\nPOKE32(CRT_DISPLAY_CTRL, reg);\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nint hw_sm750_setColReg(struct lynxfb_crtc *crtc, ushort index,\r\nushort red, ushort green, ushort blue)\r\n{\r\nstatic unsigned int add[] = {PANEL_PALETTE_RAM, CRT_PALETTE_RAM};\r\nPOKE32(add[crtc->channel] + index*4, (red<<16)|(green<<8)|blue);\r\nreturn 0;\r\n}\r\nint hw_sm750le_setBLANK(struct lynxfb_output *output, int blank)\r\n{\r\nint dpms, crtdb;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\ndpms = CRT_DISPLAY_CTRL_DPMS_0;\r\ncrtdb = 0;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ndpms = CRT_DISPLAY_CTRL_DPMS_0;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ndpms = CRT_DISPLAY_CTRL_DPMS_2;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ndpms = CRT_DISPLAY_CTRL_DPMS_1;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\ndpms = CRT_DISPLAY_CTRL_DPMS_3;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (output->paths & sm750_crt) {\r\nunsigned int val;\r\nval = PEEK32(CRT_DISPLAY_CTRL) & ~CRT_DISPLAY_CTRL_DPMS_MASK;\r\nPOKE32(CRT_DISPLAY_CTRL, val | dpms);\r\nval = PEEK32(CRT_DISPLAY_CTRL) & ~CRT_DISPLAY_CTRL_BLANK;\r\nPOKE32(CRT_DISPLAY_CTRL, val | crtdb);\r\n}\r\nreturn 0;\r\n}\r\nint hw_sm750_setBLANK(struct lynxfb_output *output, int blank)\r\n{\r\nunsigned int dpms, pps, crtdb;\r\ndpms = pps = crtdb = 0;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\npr_debug("flag = FB_BLANK_UNBLANK\n");\r\ndpms = SYSTEM_CTRL_DPMS_VPHP;\r\npps = PANEL_DISPLAY_CTRL_DATA;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\npr_debug("flag = FB_BLANK_NORMAL\n");\r\ndpms = SYSTEM_CTRL_DPMS_VPHP;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ndpms = SYSTEM_CTRL_DPMS_VNHP;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ndpms = SYSTEM_CTRL_DPMS_VPHN;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\ndpms = SYSTEM_CTRL_DPMS_VNHN;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK;\r\nbreak;\r\n}\r\nif (output->paths & sm750_crt) {\r\nunsigned int val = PEEK32(SYSTEM_CTRL) & ~SYSTEM_CTRL_DPMS_MASK;\r\nPOKE32(SYSTEM_CTRL, val | dpms);\r\nval = PEEK32(CRT_DISPLAY_CTRL) & ~CRT_DISPLAY_CTRL_BLANK;\r\nPOKE32(CRT_DISPLAY_CTRL, val | crtdb);\r\n}\r\nif (output->paths & sm750_panel) {\r\nunsigned int val = PEEK32(PANEL_DISPLAY_CTRL);\r\nval &= ~PANEL_DISPLAY_CTRL_DATA;\r\nval |= pps;\r\nPOKE32(PANEL_DISPLAY_CTRL, val);\r\n}\r\nreturn 0;\r\n}\r\nvoid hw_sm750_initAccel(struct sm750_dev *sm750_dev)\r\n{\r\nu32 reg;\r\nenable2DEngine(1);\r\nif (getChipType() == SM750LE) {\r\nreg = PEEK32(DE_STATE1);\r\nreg |= DE_STATE1_DE_ABORT;\r\nPOKE32(DE_STATE1, reg);\r\nreg = PEEK32(DE_STATE1);\r\nreg &= ~DE_STATE1_DE_ABORT;\r\nPOKE32(DE_STATE1, reg);\r\n} else {\r\nreg = PEEK32(SYSTEM_CTRL);\r\nreg |= SYSTEM_CTRL_DE_ABORT;\r\nPOKE32(SYSTEM_CTRL, reg);\r\nreg = PEEK32(SYSTEM_CTRL);\r\nreg &= ~SYSTEM_CTRL_DE_ABORT;\r\nPOKE32(SYSTEM_CTRL, reg);\r\n}\r\nsm750_dev->accel.de_init(&sm750_dev->accel);\r\n}\r\nint hw_sm750le_deWait(void)\r\n{\r\nint i = 0x10000000;\r\nunsigned int mask = DE_STATE2_DE_STATUS_BUSY | DE_STATE2_DE_FIFO_EMPTY |\r\nDE_STATE2_DE_MEM_FIFO_EMPTY;\r\nwhile (i--) {\r\nunsigned int val = PEEK32(DE_STATE2);\r\nif ((val & mask) ==\r\n(DE_STATE2_DE_FIFO_EMPTY | DE_STATE2_DE_MEM_FIFO_EMPTY))\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nint hw_sm750_deWait(void)\r\n{\r\nint i = 0x10000000;\r\nunsigned int mask = SYSTEM_CTRL_DE_STATUS_BUSY |\r\nSYSTEM_CTRL_DE_FIFO_EMPTY |\r\nSYSTEM_CTRL_DE_MEM_FIFO_EMPTY;\r\nwhile (i--) {\r\nunsigned int val = PEEK32(SYSTEM_CTRL);\r\nif ((val & mask) ==\r\n(SYSTEM_CTRL_DE_FIFO_EMPTY | SYSTEM_CTRL_DE_MEM_FIFO_EMPTY))\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nint hw_sm750_pan_display(struct lynxfb_crtc *crtc,\r\nconst struct fb_var_screeninfo *var,\r\nconst struct fb_info *info)\r\n{\r\nuint32_t total;\r\nif ((var->xoffset + var->xres > var->xres_virtual) ||\r\n(var->yoffset + var->yres > var->yres_virtual)) {\r\nreturn -EINVAL;\r\n}\r\ntotal = var->yoffset * info->fix.line_length +\r\n((var->xoffset * var->bits_per_pixel) >> 3);\r\ntotal += crtc->oScreen;\r\nif (crtc->channel == sm750_primary) {\r\nPOKE32(PANEL_FB_ADDRESS,\r\nPEEK32(PANEL_FB_ADDRESS) |\r\n(total & PANEL_FB_ADDRESS_ADDRESS_MASK));\r\n} else {\r\nPOKE32(CRT_FB_ADDRESS,\r\nPEEK32(CRT_FB_ADDRESS) |\r\n(total & CRT_FB_ADDRESS_ADDRESS_MASK));\r\n}\r\nreturn 0;\r\n}
