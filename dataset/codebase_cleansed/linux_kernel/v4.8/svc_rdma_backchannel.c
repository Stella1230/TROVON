int svc_rdma_handle_bc_reply(struct rpc_xprt *xprt, struct rpcrdma_msg *rmsgp,\r\nstruct xdr_buf *rcvbuf)\r\n{\r\nstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\r\nstruct kvec *dst, *src = &rcvbuf->head[0];\r\nstruct rpc_rqst *req;\r\nunsigned long cwnd;\r\nu32 credits;\r\nsize_t len;\r\n__be32 xid;\r\n__be32 *p;\r\nint ret;\r\np = (__be32 *)src->iov_base;\r\nlen = src->iov_len;\r\nxid = rmsgp->rm_xid;\r\n#ifdef SVCRDMA_BACKCHANNEL_DEBUG\r\npr_info("%s: xid=%08x, length=%zu\n",\r\n__func__, be32_to_cpu(xid), len);\r\npr_info("%s: RPC/RDMA: %*ph\n",\r\n__func__, (int)RPCRDMA_HDRLEN_MIN, rmsgp);\r\npr_info("%s: RPC: %*ph\n",\r\n__func__, (int)len, p);\r\n#endif\r\nret = -EAGAIN;\r\nif (src->iov_len < 24)\r\ngoto out_shortreply;\r\nspin_lock_bh(&xprt->transport_lock);\r\nreq = xprt_lookup_rqst(xprt, xid);\r\nif (!req)\r\ngoto out_notfound;\r\ndst = &req->rq_private_buf.head[0];\r\nmemcpy(&req->rq_private_buf, &req->rq_rcv_buf, sizeof(struct xdr_buf));\r\nif (dst->iov_len < len)\r\ngoto out_unlock;\r\nmemcpy(dst->iov_base, p, len);\r\ncredits = be32_to_cpu(rmsgp->rm_credit);\r\nif (credits == 0)\r\ncredits = 1;\r\nelse if (credits > r_xprt->rx_buf.rb_bc_max_requests)\r\ncredits = r_xprt->rx_buf.rb_bc_max_requests;\r\ncwnd = xprt->cwnd;\r\nxprt->cwnd = credits << RPC_CWNDSHIFT;\r\nif (xprt->cwnd > cwnd)\r\nxprt_release_rqst_cong(req->rq_task);\r\nret = 0;\r\nxprt_complete_rqst(req->rq_task, rcvbuf->len);\r\nrcvbuf->len = 0;\r\nout_unlock:\r\nspin_unlock_bh(&xprt->transport_lock);\r\nout:\r\nreturn ret;\r\nout_shortreply:\r\ndprintk("svcrdma: short bc reply: xprt=%p, len=%zu\n",\r\nxprt, src->iov_len);\r\ngoto out;\r\nout_notfound:\r\ndprintk("svcrdma: unrecognized bc reply: xprt=%p, xid=%08x\n",\r\nxprt, be32_to_cpu(xid));\r\ngoto out_unlock;\r\n}\r\nstatic int svc_rdma_bc_sendto(struct svcxprt_rdma *rdma,\r\nstruct rpc_rqst *rqst)\r\n{\r\nstruct xdr_buf *sndbuf = &rqst->rq_snd_buf;\r\nstruct svc_rdma_op_ctxt *ctxt;\r\nstruct svc_rdma_req_map *vec;\r\nstruct ib_send_wr send_wr;\r\nint ret;\r\nvec = svc_rdma_get_req_map(rdma);\r\nret = svc_rdma_map_xdr(rdma, sndbuf, vec, false);\r\nif (ret)\r\ngoto out_err;\r\nret = svc_rdma_repost_recv(rdma, GFP_NOIO);\r\nif (ret)\r\ngoto out_err;\r\nctxt = svc_rdma_get_context(rdma);\r\nctxt->pages[0] = virt_to_page(rqst->rq_buffer);\r\nctxt->count = 1;\r\nctxt->direction = DMA_TO_DEVICE;\r\nctxt->sge[0].lkey = rdma->sc_pd->local_dma_lkey;\r\nctxt->sge[0].length = sndbuf->len;\r\nctxt->sge[0].addr =\r\nib_dma_map_page(rdma->sc_cm_id->device, ctxt->pages[0], 0,\r\nsndbuf->len, DMA_TO_DEVICE);\r\nif (ib_dma_mapping_error(rdma->sc_cm_id->device, ctxt->sge[0].addr)) {\r\nret = -EIO;\r\ngoto out_unmap;\r\n}\r\natomic_inc(&rdma->sc_dma_used);\r\nmemset(&send_wr, 0, sizeof(send_wr));\r\nctxt->cqe.done = svc_rdma_wc_send;\r\nsend_wr.wr_cqe = &ctxt->cqe;\r\nsend_wr.sg_list = ctxt->sge;\r\nsend_wr.num_sge = 1;\r\nsend_wr.opcode = IB_WR_SEND;\r\nsend_wr.send_flags = IB_SEND_SIGNALED;\r\nret = svc_rdma_send(rdma, &send_wr);\r\nif (ret) {\r\nret = -EIO;\r\ngoto out_unmap;\r\n}\r\nout_err:\r\nsvc_rdma_put_req_map(rdma, vec);\r\ndprintk("svcrdma: %s returns %d\n", __func__, ret);\r\nreturn ret;\r\nout_unmap:\r\nsvc_rdma_unmap_dma(ctxt);\r\nsvc_rdma_put_context(ctxt, 1);\r\ngoto out_err;\r\n}\r\nstatic void *\r\nxprt_rdma_bc_allocate(struct rpc_task *task, size_t size)\r\n{\r\nstruct rpc_rqst *rqst = task->tk_rqstp;\r\nstruct svc_xprt *sxprt = rqst->rq_xprt->bc_xprt;\r\nstruct svcxprt_rdma *rdma;\r\nstruct page *page;\r\nrdma = container_of(sxprt, struct svcxprt_rdma, sc_xprt);\r\nif (size > PAGE_SIZE)\r\nWARN_ONCE(1, "svcrdma: large bc buffer request (size %zu)\n",\r\nsize);\r\npage = alloc_page(RPCRDMA_DEF_GFP);\r\nif (!page)\r\nreturn NULL;\r\nreturn page_address(page);\r\n}\r\nstatic void\r\nxprt_rdma_bc_free(void *buffer)\r\n{\r\n}\r\nstatic int\r\nrpcrdma_bc_send_request(struct svcxprt_rdma *rdma, struct rpc_rqst *rqst)\r\n{\r\nstruct rpc_xprt *xprt = rqst->rq_xprt;\r\nstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\r\nstruct rpcrdma_msg *headerp = (struct rpcrdma_msg *)rqst->rq_buffer;\r\nint rc;\r\nheaderp->rm_xid = rqst->rq_xid;\r\nheaderp->rm_vers = rpcrdma_version;\r\nheaderp->rm_credit = cpu_to_be32(r_xprt->rx_buf.rb_bc_max_requests);\r\nheaderp->rm_type = rdma_msg;\r\nheaderp->rm_body.rm_chunks[0] = xdr_zero;\r\nheaderp->rm_body.rm_chunks[1] = xdr_zero;\r\nheaderp->rm_body.rm_chunks[2] = xdr_zero;\r\n#ifdef SVCRDMA_BACKCHANNEL_DEBUG\r\npr_info("%s: %*ph\n", __func__, 64, rqst->rq_buffer);\r\n#endif\r\nrc = svc_rdma_bc_sendto(rdma, rqst);\r\nif (rc)\r\ngoto drop_connection;\r\nreturn rc;\r\ndrop_connection:\r\ndprintk("svcrdma: failed to send bc call\n");\r\nxprt_disconnect_done(xprt);\r\nreturn -ENOTCONN;\r\n}\r\nstatic int\r\nxprt_rdma_bc_send_request(struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *rqst = task->tk_rqstp;\r\nstruct svc_xprt *sxprt = rqst->rq_xprt->bc_xprt;\r\nstruct svcxprt_rdma *rdma;\r\nint ret;\r\ndprintk("svcrdma: sending bc call with xid: %08x\n",\r\nbe32_to_cpu(rqst->rq_xid));\r\nif (!mutex_trylock(&sxprt->xpt_mutex)) {\r\nrpc_sleep_on(&sxprt->xpt_bc_pending, task, NULL);\r\nif (!mutex_trylock(&sxprt->xpt_mutex))\r\nreturn -EAGAIN;\r\nrpc_wake_up_queued_task(&sxprt->xpt_bc_pending, task);\r\n}\r\nret = -ENOTCONN;\r\nrdma = container_of(sxprt, struct svcxprt_rdma, sc_xprt);\r\nif (!test_bit(XPT_DEAD, &sxprt->xpt_flags))\r\nret = rpcrdma_bc_send_request(rdma, rqst);\r\nmutex_unlock(&sxprt->xpt_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void\r\nxprt_rdma_bc_close(struct rpc_xprt *xprt)\r\n{\r\ndprintk("svcrdma: %s: xprt %p\n", __func__, xprt);\r\n}\r\nstatic void\r\nxprt_rdma_bc_put(struct rpc_xprt *xprt)\r\n{\r\ndprintk("svcrdma: %s: xprt %p\n", __func__, xprt);\r\nxprt_free(xprt);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic struct rpc_xprt *\r\nxprt_setup_rdma_bc(struct xprt_create *args)\r\n{\r\nstruct rpc_xprt *xprt;\r\nstruct rpcrdma_xprt *new_xprt;\r\nif (args->addrlen > sizeof(xprt->addr)) {\r\ndprintk("RPC: %s: address too large\n", __func__);\r\nreturn ERR_PTR(-EBADF);\r\n}\r\nxprt = xprt_alloc(args->net, sizeof(*new_xprt),\r\nRPCRDMA_MAX_BC_REQUESTS,\r\nRPCRDMA_MAX_BC_REQUESTS);\r\nif (!xprt) {\r\ndprintk("RPC: %s: couldn't allocate rpc_xprt\n",\r\n__func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nxprt->timeout = &xprt_rdma_bc_timeout;\r\nxprt_set_bound(xprt);\r\nxprt_set_connected(xprt);\r\nxprt->bind_timeout = RPCRDMA_BIND_TO;\r\nxprt->reestablish_timeout = RPCRDMA_INIT_REEST_TO;\r\nxprt->idle_timeout = RPCRDMA_IDLE_DISC_TO;\r\nxprt->prot = XPRT_TRANSPORT_BC_RDMA;\r\nxprt->tsh_size = RPCRDMA_HDRLEN_MIN / sizeof(__be32);\r\nxprt->ops = &xprt_rdma_bc_procs;\r\nmemcpy(&xprt->addr, args->dstaddr, args->addrlen);\r\nxprt->addrlen = args->addrlen;\r\nxprt_rdma_format_addresses(xprt, (struct sockaddr *)&xprt->addr);\r\nxprt->resvport = 0;\r\nxprt->max_payload = xprt_rdma_max_inline_read;\r\nnew_xprt = rpcx_to_rdmax(xprt);\r\nnew_xprt->rx_buf.rb_bc_max_requests = xprt->max_reqs;\r\nxprt_get(xprt);\r\nargs->bc_xprt->xpt_bc_xprt = xprt;\r\nxprt->bc_xprt = args->bc_xprt;\r\nif (!try_module_get(THIS_MODULE))\r\ngoto out_fail;\r\nxprt_get(xprt);\r\nreturn xprt;\r\nout_fail:\r\nxprt_rdma_free_addresses(xprt);\r\nargs->bc_xprt->xpt_bc_xprt = NULL;\r\nxprt_put(xprt);\r\nxprt_free(xprt);\r\nreturn ERR_PTR(-EINVAL);\r\n}
