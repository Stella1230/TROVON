static int pcie_phy_poll_ack(void __iomem *dbi_base, int exp_val)\r\n{\r\nu32 val;\r\nu32 max_iterations = 10;\r\nu32 wait_counter = 0;\r\ndo {\r\nval = readl(dbi_base + PCIE_PHY_STAT);\r\nval = (val >> PCIE_PHY_STAT_ACK_LOC) & 0x1;\r\nwait_counter++;\r\nif (val == exp_val)\r\nreturn 0;\r\nudelay(1);\r\n} while (wait_counter < max_iterations);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int pcie_phy_wait_ack(void __iomem *dbi_base, int addr)\r\n{\r\nu32 val;\r\nint ret;\r\nval = addr << PCIE_PHY_CTRL_DATA_LOC;\r\nwritel(val, dbi_base + PCIE_PHY_CTRL);\r\nval |= (0x1 << PCIE_PHY_CTRL_CAP_ADR_LOC);\r\nwritel(val, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 1);\r\nif (ret)\r\nreturn ret;\r\nval = addr << PCIE_PHY_CTRL_DATA_LOC;\r\nwritel(val, dbi_base + PCIE_PHY_CTRL);\r\nreturn pcie_phy_poll_ack(dbi_base, 0);\r\n}\r\nstatic int pcie_phy_read(void __iomem *dbi_base, int addr, int *data)\r\n{\r\nu32 val, phy_ctl;\r\nint ret;\r\nret = pcie_phy_wait_ack(dbi_base, addr);\r\nif (ret)\r\nreturn ret;\r\nphy_ctl = 0x1 << PCIE_PHY_CTRL_RD_LOC;\r\nwritel(phy_ctl, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 1);\r\nif (ret)\r\nreturn ret;\r\nval = readl(dbi_base + PCIE_PHY_STAT);\r\n*data = val & 0xffff;\r\nwritel(0x00, dbi_base + PCIE_PHY_CTRL);\r\nreturn pcie_phy_poll_ack(dbi_base, 0);\r\n}\r\nstatic int pcie_phy_write(void __iomem *dbi_base, int addr, int data)\r\n{\r\nu32 var;\r\nint ret;\r\nret = pcie_phy_wait_ack(dbi_base, addr);\r\nif (ret)\r\nreturn ret;\r\nvar = data << PCIE_PHY_CTRL_DATA_LOC;\r\nwritel(var, dbi_base + PCIE_PHY_CTRL);\r\nvar |= (0x1 << PCIE_PHY_CTRL_CAP_DAT_LOC);\r\nwritel(var, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 1);\r\nif (ret)\r\nreturn ret;\r\nvar = data << PCIE_PHY_CTRL_DATA_LOC;\r\nwritel(var, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 0);\r\nif (ret)\r\nreturn ret;\r\nvar = 0x1 << PCIE_PHY_CTRL_WR_LOC;\r\nwritel(var, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 1);\r\nif (ret)\r\nreturn ret;\r\nvar = data << PCIE_PHY_CTRL_DATA_LOC;\r\nwritel(var, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 0);\r\nif (ret)\r\nreturn ret;\r\nwritel(0x0, dbi_base + PCIE_PHY_CTRL);\r\nreturn 0;\r\n}\r\nstatic void imx6_pcie_reset_phy(struct pcie_port *pp)\r\n{\r\nu32 tmp;\r\npcie_phy_read(pp->dbi_base, PHY_RX_OVRD_IN_LO, &tmp);\r\ntmp |= (PHY_RX_OVRD_IN_LO_RX_DATA_EN |\r\nPHY_RX_OVRD_IN_LO_RX_PLL_EN);\r\npcie_phy_write(pp->dbi_base, PHY_RX_OVRD_IN_LO, tmp);\r\nusleep_range(2000, 3000);\r\npcie_phy_read(pp->dbi_base, PHY_RX_OVRD_IN_LO, &tmp);\r\ntmp &= ~(PHY_RX_OVRD_IN_LO_RX_DATA_EN |\r\nPHY_RX_OVRD_IN_LO_RX_PLL_EN);\r\npcie_phy_write(pp->dbi_base, PHY_RX_OVRD_IN_LO, tmp);\r\n}\r\nstatic int imx6q_pcie_abort_handler(unsigned long addr,\r\nunsigned int fsr, struct pt_regs *regs)\r\n{\r\nreturn 0;\r\n}\r\nstatic int imx6_pcie_assert_core_reset(struct pcie_port *pp)\r\n{\r\nstruct imx6_pcie *imx6_pcie = to_imx6_pcie(pp);\r\nu32 val, gpr1, gpr12;\r\nswitch (imx6_pcie->variant) {\r\ncase IMX6SX:\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6SX_GPR12_PCIE_TEST_POWERDOWN,\r\nIMX6SX_GPR12_PCIE_TEST_POWERDOWN);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR5,\r\nIMX6SX_GPR5_PCIE_BTNRST_RESET,\r\nIMX6SX_GPR5_PCIE_BTNRST_RESET);\r\nbreak;\r\ncase IMX6QP:\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_PCIE_SW_RST,\r\nIMX6Q_GPR1_PCIE_SW_RST);\r\nbreak;\r\ncase IMX6Q:\r\nregmap_read(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1, &gpr1);\r\nregmap_read(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12, &gpr12);\r\nif ((gpr1 & IMX6Q_GPR1_PCIE_REF_CLK_EN) &&\r\n(gpr12 & IMX6Q_GPR12_PCIE_CTL_2)) {\r\nval = readl(pp->dbi_base + PCIE_PL_PFLR);\r\nval &= ~PCIE_PL_PFLR_LINK_STATE_MASK;\r\nval |= PCIE_PL_PFLR_FORCE_LINK;\r\nwritel(val, pp->dbi_base + PCIE_PL_PFLR);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6Q_GPR12_PCIE_CTL_2, 0 << 10);\r\n}\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_PCIE_TEST_PD, 1 << 18);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_PCIE_REF_CLK_EN, 0 << 16);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx6_pcie_enable_ref_clk(struct imx6_pcie *imx6_pcie)\r\n{\r\nstruct pcie_port *pp = &imx6_pcie->pp;\r\nint ret = 0;\r\nswitch (imx6_pcie->variant) {\r\ncase IMX6SX:\r\nret = clk_prepare_enable(imx6_pcie->pcie_inbound_axi);\r\nif (ret) {\r\ndev_err(pp->dev, "unable to enable pcie_axi clock\n");\r\nbreak;\r\n}\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6SX_GPR12_PCIE_TEST_POWERDOWN, 0);\r\nbreak;\r\ncase IMX6QP:\r\ncase IMX6Q:\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_PCIE_TEST_PD, 0 << 18);\r\nudelay(10);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_PCIE_REF_CLK_EN, 1 << 16);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int imx6_pcie_deassert_core_reset(struct pcie_port *pp)\r\n{\r\nstruct imx6_pcie *imx6_pcie = to_imx6_pcie(pp);\r\nint ret;\r\nret = clk_prepare_enable(imx6_pcie->pcie_phy);\r\nif (ret) {\r\ndev_err(pp->dev, "unable to enable pcie_phy clock\n");\r\ngoto err_pcie_phy;\r\n}\r\nret = clk_prepare_enable(imx6_pcie->pcie_bus);\r\nif (ret) {\r\ndev_err(pp->dev, "unable to enable pcie_bus clock\n");\r\ngoto err_pcie_bus;\r\n}\r\nret = clk_prepare_enable(imx6_pcie->pcie);\r\nif (ret) {\r\ndev_err(pp->dev, "unable to enable pcie clock\n");\r\ngoto err_pcie;\r\n}\r\nret = imx6_pcie_enable_ref_clk(imx6_pcie);\r\nif (ret) {\r\ndev_err(pp->dev, "unable to enable pcie ref clock\n");\r\ngoto err_ref_clk;\r\n}\r\nusleep_range(200, 500);\r\nif (gpio_is_valid(imx6_pcie->reset_gpio)) {\r\ngpio_set_value_cansleep(imx6_pcie->reset_gpio,\r\nimx6_pcie->gpio_active_high);\r\nmsleep(100);\r\ngpio_set_value_cansleep(imx6_pcie->reset_gpio,\r\n!imx6_pcie->gpio_active_high);\r\n}\r\nswitch (imx6_pcie->variant) {\r\ncase IMX6SX:\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR5,\r\nIMX6SX_GPR5_PCIE_BTNRST_RESET, 0);\r\nbreak;\r\ncase IMX6QP:\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_PCIE_SW_RST, 0);\r\nusleep_range(200, 500);\r\nbreak;\r\ncase IMX6Q:\r\nbreak;\r\n}\r\nreturn 0;\r\nerr_ref_clk:\r\nclk_disable_unprepare(imx6_pcie->pcie);\r\nerr_pcie:\r\nclk_disable_unprepare(imx6_pcie->pcie_bus);\r\nerr_pcie_bus:\r\nclk_disable_unprepare(imx6_pcie->pcie_phy);\r\nerr_pcie_phy:\r\nreturn ret;\r\n}\r\nstatic void imx6_pcie_init_phy(struct pcie_port *pp)\r\n{\r\nstruct imx6_pcie *imx6_pcie = to_imx6_pcie(pp);\r\nif (imx6_pcie->variant == IMX6SX)\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6SX_GPR12_PCIE_RX_EQ_MASK,\r\nIMX6SX_GPR12_PCIE_RX_EQ_2);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6Q_GPR12_PCIE_CTL_2, 0 << 10);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6Q_GPR12_DEVICE_TYPE, PCI_EXP_TYPE_ROOT_PORT << 12);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6Q_GPR12_LOS_LEVEL, 9 << 4);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,\r\nIMX6Q_GPR8_TX_DEEMPH_GEN1,\r\nimx6_pcie->tx_deemph_gen1 << 0);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,\r\nIMX6Q_GPR8_TX_DEEMPH_GEN2_3P5DB,\r\nimx6_pcie->tx_deemph_gen2_3p5db << 6);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,\r\nIMX6Q_GPR8_TX_DEEMPH_GEN2_6DB,\r\nimx6_pcie->tx_deemph_gen2_6db << 12);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,\r\nIMX6Q_GPR8_TX_SWING_FULL,\r\nimx6_pcie->tx_swing_full << 18);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,\r\nIMX6Q_GPR8_TX_SWING_LOW,\r\nimx6_pcie->tx_swing_low << 25);\r\n}\r\nstatic int imx6_pcie_wait_for_link(struct pcie_port *pp)\r\n{\r\nif (!dw_pcie_wait_for_link(pp))\r\nreturn 0;\r\ndev_dbg(pp->dev, "DEBUG_R0: 0x%08x, DEBUG_R1: 0x%08x\n",\r\nreadl(pp->dbi_base + PCIE_PHY_DEBUG_R0),\r\nreadl(pp->dbi_base + PCIE_PHY_DEBUG_R1));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int imx6_pcie_wait_for_speed_change(struct pcie_port *pp)\r\n{\r\nu32 tmp;\r\nunsigned int retries;\r\nfor (retries = 0; retries < 200; retries++) {\r\ntmp = readl(pp->dbi_base + PCIE_LINK_WIDTH_SPEED_CONTROL);\r\nif (!(tmp & PORT_LOGIC_SPEED_CHANGE))\r\nreturn 0;\r\nusleep_range(100, 1000);\r\n}\r\ndev_err(pp->dev, "Speed change timeout\n");\r\nreturn -EINVAL;\r\n}\r\nstatic irqreturn_t imx6_pcie_msi_handler(int irq, void *arg)\r\n{\r\nstruct pcie_port *pp = arg;\r\nreturn dw_handle_msi_irq(pp);\r\n}\r\nstatic int imx6_pcie_establish_link(struct pcie_port *pp)\r\n{\r\nstruct imx6_pcie *imx6_pcie = to_imx6_pcie(pp);\r\nu32 tmp;\r\nint ret;\r\ntmp = readl(pp->dbi_base + PCIE_RC_LCR);\r\ntmp &= ~PCIE_RC_LCR_MAX_LINK_SPEEDS_MASK;\r\ntmp |= PCIE_RC_LCR_MAX_LINK_SPEEDS_GEN1;\r\nwritel(tmp, pp->dbi_base + PCIE_RC_LCR);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6Q_GPR12_PCIE_CTL_2, 1 << 10);\r\nret = imx6_pcie_wait_for_link(pp);\r\nif (ret) {\r\ndev_info(pp->dev, "Link never came up\n");\r\ngoto err_reset_phy;\r\n}\r\nif (imx6_pcie->link_gen == 2) {\r\ntmp = readl(pp->dbi_base + PCIE_RC_LCR);\r\ntmp &= ~PCIE_RC_LCR_MAX_LINK_SPEEDS_MASK;\r\ntmp |= PCIE_RC_LCR_MAX_LINK_SPEEDS_GEN2;\r\nwritel(tmp, pp->dbi_base + PCIE_RC_LCR);\r\n} else {\r\ndev_info(pp->dev, "Link: Gen2 disabled\n");\r\n}\r\ntmp = readl(pp->dbi_base + PCIE_LINK_WIDTH_SPEED_CONTROL);\r\ntmp |= PORT_LOGIC_SPEED_CHANGE;\r\nwritel(tmp, pp->dbi_base + PCIE_LINK_WIDTH_SPEED_CONTROL);\r\nret = imx6_pcie_wait_for_speed_change(pp);\r\nif (ret) {\r\ndev_err(pp->dev, "Failed to bring link up!\n");\r\ngoto err_reset_phy;\r\n}\r\nret = imx6_pcie_wait_for_link(pp);\r\nif (ret) {\r\ndev_err(pp->dev, "Failed to bring link up!\n");\r\ngoto err_reset_phy;\r\n}\r\ntmp = readl(pp->dbi_base + PCIE_RC_LCSR);\r\ndev_info(pp->dev, "Link up, Gen%i\n", (tmp >> 16) & 0xf);\r\nreturn 0;\r\nerr_reset_phy:\r\ndev_dbg(pp->dev, "PHY DEBUG_R0=0x%08x DEBUG_R1=0x%08x\n",\r\nreadl(pp->dbi_base + PCIE_PHY_DEBUG_R0),\r\nreadl(pp->dbi_base + PCIE_PHY_DEBUG_R1));\r\nimx6_pcie_reset_phy(pp);\r\nreturn ret;\r\n}\r\nstatic void imx6_pcie_host_init(struct pcie_port *pp)\r\n{\r\nimx6_pcie_assert_core_reset(pp);\r\nimx6_pcie_init_phy(pp);\r\nimx6_pcie_deassert_core_reset(pp);\r\ndw_pcie_setup_rc(pp);\r\nimx6_pcie_establish_link(pp);\r\nif (IS_ENABLED(CONFIG_PCI_MSI))\r\ndw_pcie_msi_init(pp);\r\n}\r\nstatic int imx6_pcie_link_up(struct pcie_port *pp)\r\n{\r\nreturn readl(pp->dbi_base + PCIE_PHY_DEBUG_R1) &\r\nPCIE_PHY_DEBUG_R1_XMLH_LINK_UP;\r\n}\r\nstatic int __init imx6_add_pcie_port(struct pcie_port *pp,\r\nstruct platform_device *pdev)\r\n{\r\nint ret;\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\npp->msi_irq = platform_get_irq_byname(pdev, "msi");\r\nif (pp->msi_irq <= 0) {\r\ndev_err(&pdev->dev, "failed to get MSI irq\n");\r\nreturn -ENODEV;\r\n}\r\nret = devm_request_irq(&pdev->dev, pp->msi_irq,\r\nimx6_pcie_msi_handler,\r\nIRQF_SHARED | IRQF_NO_THREAD,\r\n"mx6-pcie-msi", pp);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request MSI irq\n");\r\nreturn ret;\r\n}\r\n}\r\npp->root_bus_nr = -1;\r\npp->ops = &imx6_pcie_host_ops;\r\nret = dw_pcie_host_init(pp);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to initialize host\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init imx6_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct imx6_pcie *imx6_pcie;\r\nstruct pcie_port *pp;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *dbi_base;\r\nstruct device_node *node = pdev->dev.of_node;\r\nint ret;\r\nimx6_pcie = devm_kzalloc(&pdev->dev, sizeof(*imx6_pcie), GFP_KERNEL);\r\nif (!imx6_pcie)\r\nreturn -ENOMEM;\r\npp = &imx6_pcie->pp;\r\npp->dev = &pdev->dev;\r\nimx6_pcie->variant =\r\n(enum imx6_pcie_variants)of_device_get_match_data(&pdev->dev);\r\nhook_fault_code(16 + 6, imx6q_pcie_abort_handler, SIGBUS, 0,\r\n"imprecise external abort");\r\ndbi_base = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npp->dbi_base = devm_ioremap_resource(&pdev->dev, dbi_base);\r\nif (IS_ERR(pp->dbi_base))\r\nreturn PTR_ERR(pp->dbi_base);\r\nimx6_pcie->reset_gpio = of_get_named_gpio(np, "reset-gpio", 0);\r\nimx6_pcie->gpio_active_high = of_property_read_bool(np,\r\n"reset-gpio-active-high");\r\nif (gpio_is_valid(imx6_pcie->reset_gpio)) {\r\nret = devm_gpio_request_one(&pdev->dev, imx6_pcie->reset_gpio,\r\nimx6_pcie->gpio_active_high ?\r\nGPIOF_OUT_INIT_HIGH :\r\nGPIOF_OUT_INIT_LOW,\r\n"PCIe reset");\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to get reset gpio\n");\r\nreturn ret;\r\n}\r\n}\r\nimx6_pcie->pcie_phy = devm_clk_get(&pdev->dev, "pcie_phy");\r\nif (IS_ERR(imx6_pcie->pcie_phy)) {\r\ndev_err(&pdev->dev,\r\n"pcie_phy clock source missing or invalid\n");\r\nreturn PTR_ERR(imx6_pcie->pcie_phy);\r\n}\r\nimx6_pcie->pcie_bus = devm_clk_get(&pdev->dev, "pcie_bus");\r\nif (IS_ERR(imx6_pcie->pcie_bus)) {\r\ndev_err(&pdev->dev,\r\n"pcie_bus clock source missing or invalid\n");\r\nreturn PTR_ERR(imx6_pcie->pcie_bus);\r\n}\r\nimx6_pcie->pcie = devm_clk_get(&pdev->dev, "pcie");\r\nif (IS_ERR(imx6_pcie->pcie)) {\r\ndev_err(&pdev->dev,\r\n"pcie clock source missing or invalid\n");\r\nreturn PTR_ERR(imx6_pcie->pcie);\r\n}\r\nif (imx6_pcie->variant == IMX6SX) {\r\nimx6_pcie->pcie_inbound_axi = devm_clk_get(&pdev->dev,\r\n"pcie_inbound_axi");\r\nif (IS_ERR(imx6_pcie->pcie_inbound_axi)) {\r\ndev_err(&pdev->dev,\r\n"pcie_incbound_axi clock missing or invalid\n");\r\nreturn PTR_ERR(imx6_pcie->pcie_inbound_axi);\r\n}\r\n}\r\nimx6_pcie->iomuxc_gpr =\r\nsyscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");\r\nif (IS_ERR(imx6_pcie->iomuxc_gpr)) {\r\ndev_err(&pdev->dev, "unable to find iomuxc registers\n");\r\nreturn PTR_ERR(imx6_pcie->iomuxc_gpr);\r\n}\r\nif (of_property_read_u32(node, "fsl,tx-deemph-gen1",\r\n&imx6_pcie->tx_deemph_gen1))\r\nimx6_pcie->tx_deemph_gen1 = 0;\r\nif (of_property_read_u32(node, "fsl,tx-deemph-gen2-3p5db",\r\n&imx6_pcie->tx_deemph_gen2_3p5db))\r\nimx6_pcie->tx_deemph_gen2_3p5db = 0;\r\nif (of_property_read_u32(node, "fsl,tx-deemph-gen2-6db",\r\n&imx6_pcie->tx_deemph_gen2_6db))\r\nimx6_pcie->tx_deemph_gen2_6db = 20;\r\nif (of_property_read_u32(node, "fsl,tx-swing-full",\r\n&imx6_pcie->tx_swing_full))\r\nimx6_pcie->tx_swing_full = 127;\r\nif (of_property_read_u32(node, "fsl,tx-swing-low",\r\n&imx6_pcie->tx_swing_low))\r\nimx6_pcie->tx_swing_low = 127;\r\nret = of_property_read_u32(pp->dev->of_node, "fsl,max-link-speed",\r\n&imx6_pcie->link_gen);\r\nif (ret)\r\nimx6_pcie->link_gen = 1;\r\nret = imx6_add_pcie_port(pp, pdev);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, imx6_pcie);\r\nreturn 0;\r\n}\r\nstatic void imx6_pcie_shutdown(struct platform_device *pdev)\r\n{\r\nstruct imx6_pcie *imx6_pcie = platform_get_drvdata(pdev);\r\nimx6_pcie_assert_core_reset(&imx6_pcie->pp);\r\n}\r\nstatic int __init imx6_pcie_init(void)\r\n{\r\nreturn platform_driver_probe(&imx6_pcie_driver, imx6_pcie_probe);\r\n}
