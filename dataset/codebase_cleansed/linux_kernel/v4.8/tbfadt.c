static void\r\nacpi_tb_init_generic_address(struct acpi_generic_address *generic_address,\r\nu8 space_id,\r\nu8 byte_width,\r\nu64 address, const char *register_name, u8 flags)\r\n{\r\nu8 bit_width;\r\nbit_width = (u8)(byte_width * 8);\r\nif (byte_width > 31) {\r\nif (!(flags & ACPI_FADT_GPE_REGISTER)) {\r\nACPI_ERROR((AE_INFO,\r\n"%s - 32-bit FADT register is too long (%u bytes, %u bits) "\r\n"to convert to GAS struct - 255 bits max, truncating",\r\nregister_name, byte_width,\r\n(byte_width * 8)));\r\n}\r\nbit_width = 255;\r\n}\r\nACPI_MOVE_64_TO_64(&generic_address->address, &address);\r\ngeneric_address->space_id = space_id;\r\ngeneric_address->bit_width = bit_width;\r\ngeneric_address->bit_offset = 0;\r\ngeneric_address->access_width = 0;\r\n}\r\nstatic u64\r\nacpi_tb_select_address(char *register_name, u32 address32, u64 address64)\r\n{\r\nif (!address64) {\r\nreturn ((u64)address32);\r\n}\r\nif (address32 && (address64 != (u64)address32)) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"32/64X %s address mismatch in FADT: "\r\n"0x%8.8X/0x%8.8X%8.8X, using %u-bit address",\r\nregister_name, address32,\r\nACPI_FORMAT_UINT64(address64),\r\nacpi_gbl_use32_bit_fadt_addresses ? 32 :\r\n64));\r\nif (acpi_gbl_use32_bit_fadt_addresses) {\r\nreturn ((u64)address32);\r\n}\r\n}\r\nreturn (address64);\r\n}\r\nvoid acpi_tb_parse_fadt(void)\r\n{\r\nu32 length;\r\nstruct acpi_table_header *table;\r\nlength = acpi_gbl_root_table_list.tables[acpi_gbl_fadt_index].length;\r\ntable =\r\nacpi_os_map_memory(acpi_gbl_root_table_list.\r\ntables[acpi_gbl_fadt_index].address, length);\r\nif (!table) {\r\nreturn;\r\n}\r\n(void)acpi_tb_verify_checksum(table, length);\r\nacpi_tb_create_local_fadt(table, length);\r\nacpi_os_unmap_memory(table, length);\r\nacpi_tb_install_fixed_table((acpi_physical_address)acpi_gbl_FADT.Xdsdt,\r\nACPI_SIG_DSDT, &acpi_gbl_dsdt_index);\r\nif (!acpi_gbl_reduced_hardware) {\r\nif (acpi_gbl_FADT.facs) {\r\nacpi_tb_install_fixed_table((acpi_physical_address)\r\nacpi_gbl_FADT.facs,\r\nACPI_SIG_FACS,\r\n&acpi_gbl_facs_index);\r\n}\r\nif (acpi_gbl_FADT.Xfacs) {\r\nacpi_tb_install_fixed_table((acpi_physical_address)\r\nacpi_gbl_FADT.Xfacs,\r\nACPI_SIG_FACS,\r\n&acpi_gbl_xfacs_index);\r\n}\r\n}\r\n}\r\nvoid acpi_tb_create_local_fadt(struct acpi_table_header *table, u32 length)\r\n{\r\nif (length > sizeof(struct acpi_table_fadt)) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"FADT (revision %u) is longer than %s length, "\r\n"truncating length %u to %u",\r\ntable->revision, ACPI_FADT_CONFORMANCE,\r\nlength,\r\n(u32)sizeof(struct acpi_table_fadt)));\r\n}\r\nmemset(&acpi_gbl_FADT, 0, sizeof(struct acpi_table_fadt));\r\nmemcpy(&acpi_gbl_FADT, table,\r\nACPI_MIN(length, sizeof(struct acpi_table_fadt)));\r\nacpi_gbl_reduced_hardware = FALSE;\r\nif (acpi_gbl_FADT.flags & ACPI_FADT_HW_REDUCED) {\r\nacpi_gbl_reduced_hardware = TRUE;\r\n}\r\nacpi_tb_convert_fadt();\r\nacpi_tb_setup_fadt_registers();\r\n}\r\nstatic void acpi_tb_convert_fadt(void)\r\n{\r\nconst char *name;\r\nstruct acpi_generic_address *address64;\r\nu32 address32;\r\nu8 length;\r\nu8 flags;\r\nu32 i;\r\nif (acpi_gbl_FADT.header.length <= ACPI_FADT_V2_SIZE) {\r\nacpi_gbl_FADT.preferred_profile = 0;\r\nacpi_gbl_FADT.pstate_control = 0;\r\nacpi_gbl_FADT.cst_control = 0;\r\nacpi_gbl_FADT.boot_flags = 0;\r\n}\r\nacpi_gbl_FADT.header.length = sizeof(struct acpi_table_fadt);\r\nacpi_gbl_FADT.Xdsdt = acpi_tb_select_address("DSDT",\r\nacpi_gbl_FADT.dsdt,\r\nacpi_gbl_FADT.Xdsdt);\r\nif (acpi_gbl_reduced_hardware) {\r\nreturn;\r\n}\r\nfor (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {\r\naddress32 = *ACPI_ADD_PTR(u32,\r\n&acpi_gbl_FADT,\r\nfadt_info_table[i].address32);\r\naddress64 = ACPI_ADD_PTR(struct acpi_generic_address,\r\n&acpi_gbl_FADT,\r\nfadt_info_table[i].address64);\r\nlength = *ACPI_ADD_PTR(u8,\r\n&acpi_gbl_FADT,\r\nfadt_info_table[i].length);\r\nname = fadt_info_table[i].name;\r\nflags = fadt_info_table[i].flags;\r\nif (address32) {\r\nif (!address64->address) {\r\nacpi_tb_init_generic_address(address64,\r\nACPI_ADR_SPACE_SYSTEM_IO,\r\n*ACPI_ADD_PTR(u8,\r\n&acpi_gbl_FADT,\r\nfadt_info_table\r\n[i].\r\nlength),\r\n(u64)address32,\r\nname, flags);\r\n} else if (address64->address != (u64)address32) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"32/64X address mismatch in FADT/%s: "\r\n"0x%8.8X/0x%8.8X%8.8X, using %u-bit address",\r\nname, address32,\r\nACPI_FORMAT_UINT64\r\n(address64->address),\r\nacpi_gbl_use32_bit_fadt_addresses\r\n? 32 : 64));\r\nif (acpi_gbl_use32_bit_fadt_addresses) {\r\nacpi_tb_init_generic_address(address64,\r\nACPI_ADR_SPACE_SYSTEM_IO,\r\n*ACPI_ADD_PTR\r\n(u8,\r\n&acpi_gbl_FADT,\r\nfadt_info_table\r\n[i].\r\nlength),\r\n(u64)\r\naddress32,\r\nname,\r\nflags);\r\n}\r\n}\r\n}\r\nif (address64->address &&\r\n(ACPI_MUL_8(length) <= ACPI_UINT8_MAX) &&\r\n(address64->bit_width != ACPI_MUL_8(length))) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"32/64X length mismatch in FADT/%s: %u/%u",\r\nname, ACPI_MUL_8(length),\r\naddress64->bit_width));\r\n}\r\nif (fadt_info_table[i].flags & ACPI_FADT_REQUIRED) {\r\nif (!address64->address || !length) {\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"Required FADT field %s has zero address and/or length: "\r\n"0x%8.8X%8.8X/0x%X",\r\nname,\r\nACPI_FORMAT_UINT64(address64->\r\naddress),\r\nlength));\r\n}\r\n} else if (fadt_info_table[i].flags & ACPI_FADT_SEPARATE_LENGTH) {\r\nif ((address64->address && !length) ||\r\n(!address64->address && length)) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"Optional FADT field %s has valid %s but zero %s: "\r\n"0x%8.8X%8.8X/0x%X", name,\r\n(length ? "Length" :\r\n"Address"),\r\n(length ? "Address" :\r\n"Length"),\r\nACPI_FORMAT_UINT64\r\n(address64->address),\r\nlength));\r\n}\r\n}\r\n}\r\n}\r\nstatic void acpi_tb_setup_fadt_registers(void)\r\n{\r\nstruct acpi_generic_address *target64;\r\nstruct acpi_generic_address *source64;\r\nu8 pm1_register_byte_width;\r\nu32 i;\r\nif (acpi_gbl_use_default_register_widths) {\r\nfor (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {\r\ntarget64 =\r\nACPI_ADD_PTR(struct acpi_generic_address,\r\n&acpi_gbl_FADT,\r\nfadt_info_table[i].address64);\r\nif ((target64->address) &&\r\n(fadt_info_table[i].default_length > 0) &&\r\n(fadt_info_table[i].default_length !=\r\ntarget64->bit_width)) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"Invalid length for FADT/%s: %u, using default %u",\r\nfadt_info_table[i].name,\r\ntarget64->bit_width,\r\nfadt_info_table[i].\r\ndefault_length));\r\ntarget64->bit_width =\r\nfadt_info_table[i].default_length;\r\n}\r\n}\r\n}\r\npm1_register_byte_width = (u8)\r\nACPI_DIV_16(acpi_gbl_FADT.xpm1a_event_block.bit_width);\r\nfor (i = 0; i < ACPI_FADT_PM_INFO_ENTRIES; i++) {\r\nsource64 =\r\nACPI_ADD_PTR(struct acpi_generic_address, &acpi_gbl_FADT,\r\nfadt_pm_info_table[i].source);\r\nif (source64->address) {\r\nacpi_tb_init_generic_address(fadt_pm_info_table[i].\r\ntarget, source64->space_id,\r\npm1_register_byte_width,\r\nsource64->address +\r\n(fadt_pm_info_table[i].\r\nregister_num *\r\npm1_register_byte_width),\r\n"PmRegisters", 0);\r\n}\r\n}\r\n}
