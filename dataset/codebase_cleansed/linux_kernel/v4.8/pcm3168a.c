static int pcm3168a_reset(struct pcm3168a_priv *pcm3168a)\r\n{\r\nint ret;\r\nret = regmap_write(pcm3168a->regmap, PCM3168A_RST_SMODE, 0);\r\nif (ret)\r\nreturn ret;\r\nmsleep(DIV_ROUND_UP(3846 * 1000, pcm3168a->sysclk));\r\nreturn regmap_write(pcm3168a->regmap, PCM3168A_RST_SMODE,\r\nPCM3168A_MRST_MASK | PCM3168A_SRST_MASK);\r\n}\r\nstatic int pcm3168a_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);\r\nregmap_write(pcm3168a->regmap, PCM3168A_DAC_MUTE, mute ? 0xff : 0);\r\nreturn 0;\r\n}\r\nstatic int pcm3168a_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(dai->codec);\r\nint ret;\r\nif (freq > PCM1368A_MAX_SYSCLK)\r\nreturn -EINVAL;\r\nret = clk_set_rate(pcm3168a->scki, freq);\r\nif (ret)\r\nreturn ret;\r\npcm3168a->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai,\r\nunsigned int format, bool dac)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);\r\nu32 fmt, reg, mask, shift;\r\nbool master_mode;\r\nswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nfmt = PCM3168A_FMT_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nfmt = PCM3168A_FMT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nfmt = PCM3168A_FMT_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nfmt = PCM3168A_FMT_DSP_A;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nfmt = PCM3168A_FMT_DSP_B;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported dai format\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmaster_mode = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmaster_mode = true;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported master/slave mode\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (format & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (dac) {\r\nreg = PCM3168A_DAC_PWR_MST_FMT;\r\nmask = PCM3168A_DAC_FMT_MASK;\r\nshift = PCM3168A_DAC_FMT_SHIFT;\r\npcm3168a->dac_master_mode = master_mode;\r\npcm3168a->dac_fmt = fmt;\r\n} else {\r\nreg = PCM3168A_ADC_MST_FMT;\r\nmask = PCM3168A_ADC_FMTAD_MASK;\r\nshift = PCM3168A_ADC_FMTAD_SHIFT;\r\npcm3168a->adc_master_mode = master_mode;\r\npcm3168a->adc_fmt = fmt;\r\n}\r\nregmap_update_bits(pcm3168a->regmap, reg, mask, fmt << shift);\r\nreturn 0;\r\n}\r\nstatic int pcm3168a_set_dai_fmt_dac(struct snd_soc_dai *dai,\r\nunsigned int format)\r\n{\r\nreturn pcm3168a_set_dai_fmt(dai, format, true);\r\n}\r\nstatic int pcm3168a_set_dai_fmt_adc(struct snd_soc_dai *dai,\r\nunsigned int format)\r\n{\r\nreturn pcm3168a_set_dai_fmt(dai, format, false);\r\n}\r\nstatic int pcm3168a_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);\r\nbool tx, master_mode;\r\nu32 val, mask, shift, reg;\r\nunsigned int rate, fmt, ratio, max_ratio;\r\nint i, min_frame_size;\r\nsnd_pcm_format_t format;\r\nrate = params_rate(params);\r\nformat = params_format(params);\r\nratio = pcm3168a->sysclk / rate;\r\ntx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nif (tx) {\r\nmax_ratio = PCM3168A_NUM_SCKI_RATIOS_DAC;\r\nreg = PCM3168A_DAC_PWR_MST_FMT;\r\nmask = PCM3168A_DAC_MSDA_MASK;\r\nshift = PCM3168A_DAC_MSDA_SHIFT;\r\nmaster_mode = pcm3168a->dac_master_mode;\r\nfmt = pcm3168a->dac_fmt;\r\n} else {\r\nmax_ratio = PCM3168A_NUM_SCKI_RATIOS_ADC;\r\nreg = PCM3168A_ADC_MST_FMT;\r\nmask = PCM3168A_ADC_MSAD_MASK;\r\nshift = PCM3168A_ADC_MSAD_SHIFT;\r\nmaster_mode = pcm3168a->adc_master_mode;\r\nfmt = pcm3168a->adc_fmt;\r\n}\r\nfor (i = 0; i < max_ratio; i++) {\r\nif (pcm3168a_scki_ratios[i] == ratio)\r\nbreak;\r\n}\r\nif (i == max_ratio) {\r\ndev_err(codec->dev, "unsupported sysclk ratio\n");\r\nreturn -EINVAL;\r\n}\r\nmin_frame_size = params_width(params) * 2;\r\nswitch (min_frame_size) {\r\ncase 32:\r\nif (master_mode || (fmt != PCM3168A_FMT_RIGHT_J)) {\r\ndev_err(codec->dev, "32-bit frames are supported only for slave mode using right justified\n");\r\nreturn -EINVAL;\r\n}\r\nfmt = PCM3168A_FMT_RIGHT_J_16;\r\nbreak;\r\ncase 48:\r\nif (master_mode || (fmt & PCM3168A_FMT_DSP_MASK)) {\r\ndev_err(codec->dev, "48-bit frames not supported in master mode, or slave mode using DSP\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 64:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported frame size: %d\n", min_frame_size);\r\nreturn -EINVAL;\r\n}\r\nif (master_mode)\r\nval = ((i + 1) << shift);\r\nelse\r\nval = 0;\r\nregmap_update_bits(pcm3168a->regmap, reg, mask, val);\r\nif (tx) {\r\nmask = PCM3168A_DAC_FMT_MASK;\r\nshift = PCM3168A_DAC_FMT_SHIFT;\r\n} else {\r\nmask = PCM3168A_ADC_FMTAD_MASK;\r\nshift = PCM3168A_ADC_FMTAD_SHIFT;\r\n}\r\nregmap_update_bits(pcm3168a->regmap, reg, mask, fmt << shift);\r\nreturn 0;\r\n}\r\nstatic bool pcm3168a_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nif (reg >= PCM3168A_RST_SMODE)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic bool pcm3168a_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase PCM3168A_DAC_ZERO:\r\ncase PCM3168A_ADC_OV:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool pcm3168a_writeable_register(struct device *dev, unsigned int reg)\r\n{\r\nif (reg < PCM3168A_RST_SMODE)\r\nreturn false;\r\nswitch (reg) {\r\ncase PCM3168A_DAC_ZERO:\r\ncase PCM3168A_ADC_OV:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nint pcm3168a_probe(struct device *dev, struct regmap *regmap)\r\n{\r\nstruct pcm3168a_priv *pcm3168a;\r\nint ret, i;\r\npcm3168a = devm_kzalloc(dev, sizeof(*pcm3168a), GFP_KERNEL);\r\nif (pcm3168a == NULL)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, pcm3168a);\r\npcm3168a->scki = devm_clk_get(dev, "scki");\r\nif (IS_ERR(pcm3168a->scki)) {\r\nret = PTR_ERR(pcm3168a->scki);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "failed to acquire clock 'scki': %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(pcm3168a->scki);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable mclk: %d\n", ret);\r\nreturn ret;\r\n}\r\npcm3168a->sysclk = clk_get_rate(pcm3168a->scki);\r\nfor (i = 0; i < ARRAY_SIZE(pcm3168a->supplies); i++)\r\npcm3168a->supplies[i].supply = pcm3168a_supply_names[i];\r\nret = devm_regulator_bulk_get(dev,\r\nARRAY_SIZE(pcm3168a->supplies), pcm3168a->supplies);\r\nif (ret) {\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "failed to request supplies: %d\n", ret);\r\ngoto err_clk;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(pcm3168a->supplies),\r\npcm3168a->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to enable supplies: %d\n", ret);\r\ngoto err_clk;\r\n}\r\npcm3168a->regmap = regmap;\r\nif (IS_ERR(pcm3168a->regmap)) {\r\nret = PTR_ERR(pcm3168a->regmap);\r\ndev_err(dev, "failed to allocate regmap: %d\n", ret);\r\ngoto err_regulator;\r\n}\r\nret = pcm3168a_reset(pcm3168a);\r\nif (ret) {\r\ndev_err(dev, "Failed to reset device: %d\n", ret);\r\ngoto err_regulator;\r\n}\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\npm_runtime_idle(dev);\r\nret = snd_soc_register_codec(dev, &pcm3168a_driver, pcm3168a_dais,\r\nARRAY_SIZE(pcm3168a_dais));\r\nif (ret) {\r\ndev_err(dev, "failed to register codec: %d\n", ret);\r\ngoto err_regulator;\r\n}\r\nreturn 0;\r\nerr_regulator:\r\nregulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),\r\npcm3168a->supplies);\r\nerr_clk:\r\nclk_disable_unprepare(pcm3168a->scki);\r\nreturn ret;\r\n}\r\nvoid pcm3168a_remove(struct device *dev)\r\n{\r\nstruct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);\r\nsnd_soc_unregister_codec(dev);\r\npm_runtime_disable(dev);\r\nregulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),\r\npcm3168a->supplies);\r\nclk_disable_unprepare(pcm3168a->scki);\r\n}\r\nstatic int pcm3168a_rt_resume(struct device *dev)\r\n{\r\nstruct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(pcm3168a->scki);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable mclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(pcm3168a->supplies),\r\npcm3168a->supplies);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable supplies: %d\n", ret);\r\ngoto err_clk;\r\n}\r\nret = pcm3168a_reset(pcm3168a);\r\nif (ret) {\r\ndev_err(dev, "Failed to reset device: %d\n", ret);\r\ngoto err_regulator;\r\n}\r\nregcache_cache_only(pcm3168a->regmap, false);\r\nregcache_mark_dirty(pcm3168a->regmap);\r\nret = regcache_sync(pcm3168a->regmap);\r\nif (ret) {\r\ndev_err(dev, "Failed to sync regmap: %d\n", ret);\r\ngoto err_regulator;\r\n}\r\nreturn 0;\r\nerr_regulator:\r\nregulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),\r\npcm3168a->supplies);\r\nerr_clk:\r\nclk_disable_unprepare(pcm3168a->scki);\r\nreturn ret;\r\n}\r\nstatic int pcm3168a_rt_suspend(struct device *dev)\r\n{\r\nstruct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);\r\nregcache_cache_only(pcm3168a->regmap, true);\r\nregulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),\r\npcm3168a->supplies);\r\nclk_disable_unprepare(pcm3168a->scki);\r\nreturn 0;\r\n}
