static struct etnaviv_gem_submit *submit_create(struct drm_device *dev,\r\nstruct etnaviv_gpu *gpu, size_t nr)\r\n{\r\nstruct etnaviv_gem_submit *submit;\r\nsize_t sz = size_vstruct(nr, sizeof(submit->bos[0]), sizeof(*submit));\r\nsubmit = kmalloc(sz, GFP_TEMPORARY | __GFP_NOWARN | __GFP_NORETRY);\r\nif (submit) {\r\nsubmit->dev = dev;\r\nsubmit->gpu = gpu;\r\nsubmit->nr_bos = 0;\r\nww_acquire_init(&submit->ticket, &reservation_ww_class);\r\n}\r\nreturn submit;\r\n}\r\nstatic int submit_lookup_objects(struct etnaviv_gem_submit *submit,\r\nstruct drm_file *file, struct drm_etnaviv_gem_submit_bo *submit_bos,\r\nunsigned nr_bos)\r\n{\r\nstruct drm_etnaviv_gem_submit_bo *bo;\r\nunsigned i;\r\nint ret = 0;\r\nspin_lock(&file->table_lock);\r\nfor (i = 0, bo = submit_bos; i < nr_bos; i++, bo++) {\r\nstruct drm_gem_object *obj;\r\nif (bo->flags & BO_INVALID_FLAGS) {\r\nDRM_ERROR("invalid flags: %x\n", bo->flags);\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nsubmit->bos[i].flags = bo->flags;\r\nobj = idr_find(&file->object_idr, bo->handle);\r\nif (!obj) {\r\nDRM_ERROR("invalid handle %u at index %u\n",\r\nbo->handle, i);\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\ndrm_gem_object_reference(obj);\r\nsubmit->bos[i].obj = to_etnaviv_bo(obj);\r\n}\r\nout_unlock:\r\nsubmit->nr_bos = i;\r\nspin_unlock(&file->table_lock);\r\nreturn ret;\r\n}\r\nstatic void submit_unlock_object(struct etnaviv_gem_submit *submit, int i)\r\n{\r\nif (submit->bos[i].flags & BO_LOCKED) {\r\nstruct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;\r\nww_mutex_unlock(&etnaviv_obj->resv->lock);\r\nsubmit->bos[i].flags &= ~BO_LOCKED;\r\n}\r\n}\r\nstatic int submit_lock_objects(struct etnaviv_gem_submit *submit)\r\n{\r\nint contended, slow_locked = -1, i, ret = 0;\r\nretry:\r\nfor (i = 0; i < submit->nr_bos; i++) {\r\nstruct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;\r\nif (slow_locked == i)\r\nslow_locked = -1;\r\ncontended = i;\r\nif (!(submit->bos[i].flags & BO_LOCKED)) {\r\nret = ww_mutex_lock_interruptible(&etnaviv_obj->resv->lock,\r\n&submit->ticket);\r\nif (ret == -EALREADY)\r\nDRM_ERROR("BO at index %u already on submit list\n",\r\ni);\r\nif (ret)\r\ngoto fail;\r\nsubmit->bos[i].flags |= BO_LOCKED;\r\n}\r\n}\r\nww_acquire_done(&submit->ticket);\r\nreturn 0;\r\nfail:\r\nfor (; i >= 0; i--)\r\nsubmit_unlock_object(submit, i);\r\nif (slow_locked > 0)\r\nsubmit_unlock_object(submit, slow_locked);\r\nif (ret == -EDEADLK) {\r\nstruct etnaviv_gem_object *etnaviv_obj;\r\netnaviv_obj = submit->bos[contended].obj;\r\nret = ww_mutex_lock_slow_interruptible(&etnaviv_obj->resv->lock,\r\n&submit->ticket);\r\nif (!ret) {\r\nsubmit->bos[contended].flags |= BO_LOCKED;\r\nslow_locked = contended;\r\ngoto retry;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int submit_fence_sync(const struct etnaviv_gem_submit *submit)\r\n{\r\nunsigned int context = submit->gpu->fence_context;\r\nint i, ret = 0;\r\nfor (i = 0; i < submit->nr_bos; i++) {\r\nstruct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;\r\nbool write = submit->bos[i].flags & ETNA_SUBMIT_BO_WRITE;\r\nret = etnaviv_gpu_fence_sync_obj(etnaviv_obj, context, write);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void submit_unpin_objects(struct etnaviv_gem_submit *submit)\r\n{\r\nint i;\r\nfor (i = 0; i < submit->nr_bos; i++) {\r\nif (submit->bos[i].flags & BO_PINNED)\r\netnaviv_gem_mapping_unreference(submit->bos[i].mapping);\r\nsubmit->bos[i].mapping = NULL;\r\nsubmit->bos[i].flags &= ~BO_PINNED;\r\n}\r\n}\r\nstatic int submit_pin_objects(struct etnaviv_gem_submit *submit)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < submit->nr_bos; i++) {\r\nstruct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;\r\nstruct etnaviv_vram_mapping *mapping;\r\nmapping = etnaviv_gem_mapping_get(&etnaviv_obj->base,\r\nsubmit->gpu);\r\nif (IS_ERR(mapping)) {\r\nret = PTR_ERR(mapping);\r\nbreak;\r\n}\r\nsubmit->bos[i].flags |= BO_PINNED;\r\nsubmit->bos[i].mapping = mapping;\r\n}\r\nreturn ret;\r\n}\r\nstatic int submit_bo(struct etnaviv_gem_submit *submit, u32 idx,\r\nstruct etnaviv_gem_submit_bo **bo)\r\n{\r\nif (idx >= submit->nr_bos) {\r\nDRM_ERROR("invalid buffer index: %u (out of %u)\n",\r\nidx, submit->nr_bos);\r\nreturn -EINVAL;\r\n}\r\n*bo = &submit->bos[idx];\r\nreturn 0;\r\n}\r\nstatic int submit_reloc(struct etnaviv_gem_submit *submit, void *stream,\r\nu32 size, const struct drm_etnaviv_gem_submit_reloc *relocs,\r\nu32 nr_relocs)\r\n{\r\nu32 i, last_offset = 0;\r\nu32 *ptr = stream;\r\nint ret;\r\nfor (i = 0; i < nr_relocs; i++) {\r\nconst struct drm_etnaviv_gem_submit_reloc *r = relocs + i;\r\nstruct etnaviv_gem_submit_bo *bo;\r\nu32 off;\r\nif (unlikely(r->flags)) {\r\nDRM_ERROR("invalid reloc flags\n");\r\nreturn -EINVAL;\r\n}\r\nif (r->submit_offset % 4) {\r\nDRM_ERROR("non-aligned reloc offset: %u\n",\r\nr->submit_offset);\r\nreturn -EINVAL;\r\n}\r\noff = r->submit_offset / 4;\r\nif ((off >= size ) ||\r\n(off < last_offset)) {\r\nDRM_ERROR("invalid offset %u at reloc %u\n", off, i);\r\nreturn -EINVAL;\r\n}\r\nret = submit_bo(submit, r->reloc_idx, &bo);\r\nif (ret)\r\nreturn ret;\r\nif (r->reloc_offset >= bo->obj->base.size - sizeof(*ptr)) {\r\nDRM_ERROR("relocation %u outside object", i);\r\nreturn -EINVAL;\r\n}\r\nptr[off] = bo->mapping->iova + r->reloc_offset;\r\nlast_offset = off;\r\n}\r\nreturn 0;\r\n}\r\nstatic void submit_cleanup(struct etnaviv_gem_submit *submit)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < submit->nr_bos; i++) {\r\nstruct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;\r\nsubmit_unlock_object(submit, i);\r\ndrm_gem_object_unreference_unlocked(&etnaviv_obj->base);\r\n}\r\nww_acquire_fini(&submit->ticket);\r\nkfree(submit);\r\n}\r\nint etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct etnaviv_drm_private *priv = dev->dev_private;\r\nstruct drm_etnaviv_gem_submit *args = data;\r\nstruct drm_etnaviv_gem_submit_reloc *relocs;\r\nstruct drm_etnaviv_gem_submit_bo *bos;\r\nstruct etnaviv_gem_submit *submit;\r\nstruct etnaviv_cmdbuf *cmdbuf;\r\nstruct etnaviv_gpu *gpu;\r\nvoid *stream;\r\nint ret;\r\nif (args->pipe >= ETNA_MAX_PIPES)\r\nreturn -EINVAL;\r\ngpu = priv->gpu[args->pipe];\r\nif (!gpu)\r\nreturn -ENXIO;\r\nif (args->stream_size % 4) {\r\nDRM_ERROR("non-aligned cmdstream buffer size: %u\n",\r\nargs->stream_size);\r\nreturn -EINVAL;\r\n}\r\nif (args->exec_state != ETNA_PIPE_3D &&\r\nargs->exec_state != ETNA_PIPE_2D &&\r\nargs->exec_state != ETNA_PIPE_VG) {\r\nDRM_ERROR("invalid exec_state: 0x%x\n", args->exec_state);\r\nreturn -EINVAL;\r\n}\r\nbos = drm_malloc_ab(args->nr_bos, sizeof(*bos));\r\nrelocs = drm_malloc_ab(args->nr_relocs, sizeof(*relocs));\r\nstream = drm_malloc_ab(1, args->stream_size);\r\ncmdbuf = etnaviv_gpu_cmdbuf_new(gpu, ALIGN(args->stream_size, 8) + 8,\r\nargs->nr_bos);\r\nif (!bos || !relocs || !stream || !cmdbuf) {\r\nret = -ENOMEM;\r\ngoto err_submit_cmds;\r\n}\r\ncmdbuf->exec_state = args->exec_state;\r\ncmdbuf->ctx = file->driver_priv;\r\nret = copy_from_user(bos, u64_to_user_ptr(args->bos),\r\nargs->nr_bos * sizeof(*bos));\r\nif (ret) {\r\nret = -EFAULT;\r\ngoto err_submit_cmds;\r\n}\r\nret = copy_from_user(relocs, u64_to_user_ptr(args->relocs),\r\nargs->nr_relocs * sizeof(*relocs));\r\nif (ret) {\r\nret = -EFAULT;\r\ngoto err_submit_cmds;\r\n}\r\nret = copy_from_user(stream, u64_to_user_ptr(args->stream),\r\nargs->stream_size);\r\nif (ret) {\r\nret = -EFAULT;\r\ngoto err_submit_cmds;\r\n}\r\nsubmit = submit_create(dev, gpu, args->nr_bos);\r\nif (!submit) {\r\nret = -ENOMEM;\r\ngoto err_submit_cmds;\r\n}\r\nret = submit_lookup_objects(submit, file, bos, args->nr_bos);\r\nif (ret)\r\ngoto err_submit_objects;\r\nret = submit_lock_objects(submit);\r\nif (ret)\r\ngoto err_submit_objects;\r\nif (!etnaviv_cmd_validate_one(gpu, stream, args->stream_size / 4,\r\nrelocs, args->nr_relocs)) {\r\nret = -EINVAL;\r\ngoto err_submit_objects;\r\n}\r\nret = submit_fence_sync(submit);\r\nif (ret)\r\ngoto err_submit_objects;\r\nret = submit_pin_objects(submit);\r\nif (ret)\r\ngoto out;\r\nret = submit_reloc(submit, stream, args->stream_size / 4,\r\nrelocs, args->nr_relocs);\r\nif (ret)\r\ngoto out;\r\nmemcpy(cmdbuf->vaddr, stream, args->stream_size);\r\ncmdbuf->user_size = ALIGN(args->stream_size, 8);\r\nret = etnaviv_gpu_submit(gpu, submit, cmdbuf);\r\nif (ret == 0)\r\ncmdbuf = NULL;\r\nargs->fence = submit->fence;\r\nout:\r\nsubmit_unpin_objects(submit);\r\nif (ret == -EAGAIN)\r\nflush_workqueue(priv->wq);\r\nerr_submit_objects:\r\nsubmit_cleanup(submit);\r\nerr_submit_cmds:\r\nif (cmdbuf)\r\netnaviv_gpu_cmdbuf_free(cmdbuf);\r\nif (stream)\r\ndrm_free_large(stream);\r\nif (bos)\r\ndrm_free_large(bos);\r\nif (relocs)\r\ndrm_free_large(relocs);\r\nreturn ret;\r\n}
