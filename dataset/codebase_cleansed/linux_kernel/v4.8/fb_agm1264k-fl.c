static int init_display(struct fbtft_par *par)\r\n{\r\nu8 i;\r\npar->fbtftops.reset(par);\r\nfor (i = 0; i < 2; ++i) {\r\nwrite_reg(par, i, 0x3f);\r\nwrite_reg(par, i, 0x40);\r\nwrite_reg(par, i, 0xb0);\r\nwrite_reg(par, i, 0xc0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void reset(struct fbtft_par *par)\r\n{\r\nif (par->gpio.reset == -1)\r\nreturn;\r\ndev_dbg(par->info->device, "%s()\n", __func__);\r\ngpio_set_value(par->gpio.reset, 0);\r\nudelay(20);\r\ngpio_set_value(par->gpio.reset, 1);\r\nmdelay(120);\r\n}\r\nstatic int verify_gpios(struct fbtft_par *par)\r\n{\r\nint i;\r\ndev_dbg(par->info->device,\r\n"%s()\n", __func__);\r\nif (par->EPIN < 0) {\r\ndev_err(par->info->device,\r\n"Missing info about 'wr' (aka E) gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 8; ++i) {\r\nif (par->gpio.db[i] < 0) {\r\ndev_err(par->info->device,\r\n"Missing info about 'db[%i]' gpio. Aborting.\n",\r\ni);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (par->CS0 < 0) {\r\ndev_err(par->info->device,\r\n"Missing info about 'cs0' gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->CS1 < 0) {\r\ndev_err(par->info->device,\r\n"Missing info about 'cs1' gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->RW < 0) {\r\ndev_err(par->info->device,\r\n"Missing info about 'rw' gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\nrequest_gpios_match(struct fbtft_par *par, const struct fbtft_gpio *gpio)\r\n{\r\ndev_dbg(par->info->device,\r\n"%s('%s')\n", __func__, gpio->name);\r\nif (strcasecmp(gpio->name, "wr") == 0) {\r\npar->EPIN = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_LOW;\r\n} else if (strcasecmp(gpio->name, "cs0") == 0) {\r\npar->CS0 = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_HIGH;\r\n} else if (strcasecmp(gpio->name, "cs1") == 0) {\r\npar->CS1 = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_HIGH;\r\n}\r\nelse if (strcasecmp(gpio->name, "rw") == 0) {\r\npar->RW = gpio->gpio;\r\nreturn GPIOF_OUT_INIT_LOW;\r\n}\r\nreturn FBTFT_GPIO_NO_MATCH;\r\n}\r\nstatic void write_reg8_bus8(struct fbtft_par *par, int len, ...)\r\n{\r\nva_list args;\r\nint i, ret;\r\nu8 *buf = par->buf;\r\nif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {\r\nva_start(args, len);\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = (u8)va_arg(args, unsigned int);\r\nva_end(args);\r\nfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par,\r\npar->info->device, u8, buf, len, "%s: ", __func__);\r\n}\r\nva_start(args, len);\r\n*buf = (u8)va_arg(args, unsigned int);\r\nif (*buf > 1) {\r\nva_end(args);\r\ndev_err(par->info->device,\r\n"Incorrect chip select request (%d)\n", *buf);\r\nreturn;\r\n}\r\nif (*buf) {\r\ngpio_set_value(par->CS0, 1);\r\ngpio_set_value(par->CS1, 0);\r\n} else {\r\ngpio_set_value(par->CS0, 0);\r\ngpio_set_value(par->CS1, 1);\r\n}\r\ngpio_set_value(par->RS, 0);\r\nlen--;\r\nif (len) {\r\ni = len;\r\nwhile (i--)\r\n*buf++ = (u8)va_arg(args, unsigned int);\r\nret = par->fbtftops.write(par, par->buf, len * (sizeof(u8)));\r\nif (ret < 0) {\r\nva_end(args);\r\ndev_err(par->info->device,\r\n"write() failed and returned %d\n", ret);\r\nreturn;\r\n}\r\n}\r\nva_end(args);\r\n}\r\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\r\n{\r\naddr_win.xs = xs;\r\naddr_win.ys_page = ys / 8;\r\naddr_win.xe = xe;\r\naddr_win.ye_page = ye / 8;\r\n}\r\nstatic void\r\nconstruct_line_bitmap(struct fbtft_par *par, u8 *dest, signed short *src,\r\nint xs, int xe, int y)\r\n{\r\nint x, i;\r\nfor (x = xs; x < xe; ++x) {\r\nu8 res = 0;\r\nfor (i = 0; i < 8; i++)\r\nif (src[(y * 8 + i) * par->info->var.xres + x])\r\nres |= 1 << i;\r\n#ifdef NEGATIVE\r\n*dest++ = res;\r\n#else\r\n*dest++ = ~res;\r\n#endif\r\n}\r\n}\r\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\r\n{\r\nu16 *vmem16 = (u16 *)par->info->screen_buffer;\r\nu8 *buf = par->txbuf.buf;\r\nint x, y;\r\nint ret = 0;\r\nsigned short *convert_buf = kmalloc_array(par->info->var.xres *\r\npar->info->var.yres, sizeof(signed short), GFP_NOIO);\r\nif (!convert_buf)\r\nreturn -ENOMEM;\r\nfor (x = 0; x < par->info->var.xres; ++x)\r\nfor (y = 0; y < par->info->var.yres; ++y) {\r\nu16 pixel = vmem16[y * par->info->var.xres + x];\r\nu16 b = pixel & 0x1f;\r\nu16 g = (pixel & (0x3f << 5)) >> 5;\r\nu16 r = (pixel & (0x1f << (5 + 6))) >> (5 + 6);\r\npixel = (299 * r + 587 * g + 114 * b) / 200;\r\nif (pixel > 255)\r\npixel = 255;\r\nconvert_buf[y * par->info->var.xres + x] =\r\n(signed short)gamma_correction_table[pixel];\r\n}\r\nfor (x = 0; x < par->info->var.xres; ++x)\r\nfor (y = 0; y < par->info->var.yres; ++y) {\r\nsigned short pixel =\r\nconvert_buf[y * par->info->var.xres + x];\r\nsigned short error_b = pixel - BLACK;\r\nsigned short error_w = pixel - WHITE;\r\nsigned short error;\r\nu16 i, j;\r\nif (abs(error_b) >= abs(error_w)) {\r\nerror = error_w;\r\npixel = 0xff;\r\n} else {\r\nerror = error_b;\r\npixel = 0;\r\n}\r\nerror /= 8;\r\nfor (i = 0; i < DIFFUSING_MATRIX_WIDTH; ++i)\r\nfor (j = 0; j < DIFFUSING_MATRIX_HEIGHT; ++j) {\r\nsigned short *write_pos;\r\nsigned char coeff;\r\nif (x + i < 0 ||\r\nx + i >= par->info->var.xres\r\n|| y + j >= par->info->var.yres)\r\ncontinue;\r\nwrite_pos = &convert_buf[\r\n(y + j) * par->info->var.xres +\r\nx + i];\r\ncoeff = diffusing_matrix[i][j];\r\nif (coeff == -1)\r\n*write_pos = pixel;\r\nelse {\r\nsigned short p = *write_pos +\r\nerror * coeff;\r\nif (p > WHITE)\r\np = WHITE;\r\nif (p < BLACK)\r\np = BLACK;\r\n*write_pos = p;\r\n}\r\n}\r\n}\r\nfor (y = addr_win.ys_page; y <= addr_win.ye_page; ++y) {\r\nif (addr_win.xs < par->info->var.xres / 2) {\r\nconstruct_line_bitmap(par, buf, convert_buf,\r\naddr_win.xs, par->info->var.xres / 2, y);\r\nlen = par->info->var.xres / 2 - addr_win.xs;\r\nwrite_reg(par, 0x00, (1 << 6) | (u8)addr_win.xs);\r\nwrite_reg(par, 0x00, (0x17 << 3) | (u8)y);\r\ngpio_set_value(par->RS, 1);\r\nret = par->fbtftops.write(par, buf, len);\r\nif (ret < 0)\r\ndev_err(par->info->device,\r\n"write failed and returned: %d\n",\r\nret);\r\n}\r\nif (addr_win.xe >= par->info->var.xres / 2) {\r\nconstruct_line_bitmap(par, buf,\r\nconvert_buf, par->info->var.xres / 2,\r\naddr_win.xe + 1, y);\r\nlen = addr_win.xe + 1 - par->info->var.xres / 2;\r\nwrite_reg(par, 0x01, 1 << 6);\r\nwrite_reg(par, 0x01, (0x17 << 3) | (u8)y);\r\ngpio_set_value(par->RS, 1);\r\npar->fbtftops.write(par, buf, len);\r\nif (ret < 0)\r\ndev_err(par->info->device,\r\n"write failed and returned: %d\n",\r\nret);\r\n}\r\n}\r\nkfree(convert_buf);\r\ngpio_set_value(par->CS0, 1);\r\ngpio_set_value(par->CS1, 1);\r\nreturn ret;\r\n}\r\nstatic int write(struct fbtft_par *par, void *buf, size_t len)\r\n{\r\nfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\r\n"%s(len=%d): ", __func__, len);\r\ngpio_set_value(par->RW, 0);\r\nwhile (len--) {\r\nu8 i, data;\r\ndata = *(u8 *)buf++;\r\nfor (i = 0; i < 8; ++i)\r\ngpio_set_value(par->gpio.db[i], data & (1 << i));\r\ngpio_set_value(par->EPIN, 1);\r\nudelay(5);\r\ngpio_set_value(par->EPIN, 0);\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}
