static inline u32 ipu_cm_read(struct ipu_soc *ipu, unsigned offset)\r\n{\r\nreturn readl(ipu->cm_reg + offset);\r\n}\r\nstatic inline void ipu_cm_write(struct ipu_soc *ipu, u32 value, unsigned offset)\r\n{\r\nwritel(value, ipu->cm_reg + offset);\r\n}\r\nvoid ipu_srm_dp_sync_update(struct ipu_soc *ipu)\r\n{\r\nu32 val;\r\nval = ipu_cm_read(ipu, IPU_SRM_PRI2);\r\nval |= 0x8;\r\nipu_cm_write(ipu, val, IPU_SRM_PRI2);\r\n}\r\nenum ipu_color_space ipu_drm_fourcc_to_colorspace(u32 drm_fourcc)\r\n{\r\nswitch (drm_fourcc) {\r\ncase DRM_FORMAT_ARGB1555:\r\ncase DRM_FORMAT_ABGR1555:\r\ncase DRM_FORMAT_RGBA5551:\r\ncase DRM_FORMAT_BGRA5551:\r\ncase DRM_FORMAT_RGB565:\r\ncase DRM_FORMAT_BGR565:\r\ncase DRM_FORMAT_RGB888:\r\ncase DRM_FORMAT_BGR888:\r\ncase DRM_FORMAT_ARGB4444:\r\ncase DRM_FORMAT_XRGB8888:\r\ncase DRM_FORMAT_XBGR8888:\r\ncase DRM_FORMAT_RGBX8888:\r\ncase DRM_FORMAT_BGRX8888:\r\ncase DRM_FORMAT_ARGB8888:\r\ncase DRM_FORMAT_ABGR8888:\r\ncase DRM_FORMAT_RGBA8888:\r\ncase DRM_FORMAT_BGRA8888:\r\nreturn IPUV3_COLORSPACE_RGB;\r\ncase DRM_FORMAT_YUYV:\r\ncase DRM_FORMAT_UYVY:\r\ncase DRM_FORMAT_YUV420:\r\ncase DRM_FORMAT_YVU420:\r\ncase DRM_FORMAT_YUV422:\r\ncase DRM_FORMAT_YVU422:\r\ncase DRM_FORMAT_NV12:\r\ncase DRM_FORMAT_NV21:\r\ncase DRM_FORMAT_NV16:\r\ncase DRM_FORMAT_NV61:\r\nreturn IPUV3_COLORSPACE_YUV;\r\ndefault:\r\nreturn IPUV3_COLORSPACE_UNKNOWN;\r\n}\r\n}\r\nenum ipu_color_space ipu_pixelformat_to_colorspace(u32 pixelformat)\r\n{\r\nswitch (pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\ncase V4L2_PIX_FMT_YUV422P:\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\nreturn IPUV3_COLORSPACE_YUV;\r\ncase V4L2_PIX_FMT_RGB32:\r\ncase V4L2_PIX_FMT_BGR32:\r\ncase V4L2_PIX_FMT_RGB24:\r\ncase V4L2_PIX_FMT_BGR24:\r\ncase V4L2_PIX_FMT_RGB565:\r\nreturn IPUV3_COLORSPACE_RGB;\r\ndefault:\r\nreturn IPUV3_COLORSPACE_UNKNOWN;\r\n}\r\n}\r\nbool ipu_pixelformat_is_planar(u32 pixelformat)\r\n{\r\nswitch (pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\ncase V4L2_PIX_FMT_YUV422P:\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nenum ipu_color_space ipu_mbus_code_to_colorspace(u32 mbus_code)\r\n{\r\nswitch (mbus_code & 0xf000) {\r\ncase 0x1000:\r\nreturn IPUV3_COLORSPACE_RGB;\r\ncase 0x2000:\r\nreturn IPUV3_COLORSPACE_YUV;\r\ndefault:\r\nreturn IPUV3_COLORSPACE_UNKNOWN;\r\n}\r\n}\r\nint ipu_stride_to_bytes(u32 pixel_stride, u32 pixelformat)\r\n{\r\nswitch (pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\ncase V4L2_PIX_FMT_YUV422P:\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\nreturn (8 * pixel_stride) >> 3;\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\nreturn (16 * pixel_stride) >> 3;\r\ncase V4L2_PIX_FMT_BGR24:\r\ncase V4L2_PIX_FMT_RGB24:\r\nreturn (24 * pixel_stride) >> 3;\r\ncase V4L2_PIX_FMT_BGR32:\r\ncase V4L2_PIX_FMT_RGB32:\r\nreturn (32 * pixel_stride) >> 3;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint ipu_degrees_to_rot_mode(enum ipu_rotate_mode *mode, int degrees,\r\nbool hflip, bool vflip)\r\n{\r\nu32 r90, vf, hf;\r\nswitch (degrees) {\r\ncase 0:\r\nvf = hf = r90 = 0;\r\nbreak;\r\ncase 90:\r\nvf = hf = 0;\r\nr90 = 1;\r\nbreak;\r\ncase 180:\r\nvf = hf = 1;\r\nr90 = 0;\r\nbreak;\r\ncase 270:\r\nvf = hf = r90 = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nhf ^= (u32)hflip;\r\nvf ^= (u32)vflip;\r\n*mode = (enum ipu_rotate_mode)((r90 << 2) | (hf << 1) | vf);\r\nreturn 0;\r\n}\r\nint ipu_rot_mode_to_degrees(int *degrees, enum ipu_rotate_mode mode,\r\nbool hflip, bool vflip)\r\n{\r\nu32 r90, vf, hf;\r\nr90 = ((u32)mode >> 2) & 0x1;\r\nhf = ((u32)mode >> 1) & 0x1;\r\nvf = ((u32)mode >> 0) & 0x1;\r\nhf ^= (u32)hflip;\r\nvf ^= (u32)vflip;\r\nswitch ((enum ipu_rotate_mode)((r90 << 2) | (hf << 1) | vf)) {\r\ncase IPU_ROTATE_NONE:\r\n*degrees = 0;\r\nbreak;\r\ncase IPU_ROTATE_90_RIGHT:\r\n*degrees = 90;\r\nbreak;\r\ncase IPU_ROTATE_180:\r\n*degrees = 180;\r\nbreak;\r\ncase IPU_ROTATE_90_LEFT:\r\n*degrees = 270;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstruct ipuv3_channel *ipu_idmac_get(struct ipu_soc *ipu, unsigned num)\r\n{\r\nstruct ipuv3_channel *channel;\r\ndev_dbg(ipu->dev, "%s %d\n", __func__, num);\r\nif (num > 63)\r\nreturn ERR_PTR(-ENODEV);\r\nmutex_lock(&ipu->channel_lock);\r\nchannel = &ipu->channel[num];\r\nif (channel->busy) {\r\nchannel = ERR_PTR(-EBUSY);\r\ngoto out;\r\n}\r\nchannel->busy = true;\r\nchannel->num = num;\r\nout:\r\nmutex_unlock(&ipu->channel_lock);\r\nreturn channel;\r\n}\r\nvoid ipu_idmac_put(struct ipuv3_channel *channel)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\ndev_dbg(ipu->dev, "%s %d\n", __func__, channel->num);\r\nmutex_lock(&ipu->channel_lock);\r\nchannel->busy = false;\r\nmutex_unlock(&ipu->channel_lock);\r\n}\r\nstatic void __ipu_idmac_reset_current_buffer(struct ipuv3_channel *channel)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned int chno = channel->num;\r\nipu_cm_write(ipu, idma_mask(chno), IPU_CHA_CUR_BUF(chno));\r\n}\r\nvoid ipu_idmac_set_double_buffer(struct ipuv3_channel *channel,\r\nbool doublebuffer)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nreg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(channel->num));\r\nif (doublebuffer)\r\nreg |= idma_mask(channel->num);\r\nelse\r\nreg &= ~idma_mask(channel->num);\r\nipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(channel->num));\r\n__ipu_idmac_reset_current_buffer(channel);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\n}\r\nint ipu_idmac_lock_enable(struct ipuv3_channel *channel, int num_bursts)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned long flags;\r\nu32 bursts, regval;\r\nint i;\r\nswitch (num_bursts) {\r\ncase 0:\r\ncase 1:\r\nbursts = 0x00;\r\nbreak;\r\ncase 2:\r\nbursts = 0x01;\r\nbreak;\r\ncase 4:\r\nbursts = 0x02;\r\nbreak;\r\ncase 8:\r\nbursts = 0x03;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(idmac_lock_en_info); i++) {\r\nif (channel->num == idmac_lock_en_info[i].chnum)\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(idmac_lock_en_info))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nregval = ipu_idmac_read(ipu, idmac_lock_en_info[i].reg);\r\nregval &= ~(0x03 << idmac_lock_en_info[i].shift);\r\nregval |= (bursts << idmac_lock_en_info[i].shift);\r\nipu_idmac_write(ipu, regval, idmac_lock_en_info[i].reg);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nreturn 0;\r\n}\r\nint ipu_module_enable(struct ipu_soc *ipu, u32 mask)\r\n{\r\nunsigned long lock_flags;\r\nu32 val;\r\nspin_lock_irqsave(&ipu->lock, lock_flags);\r\nval = ipu_cm_read(ipu, IPU_DISP_GEN);\r\nif (mask & IPU_CONF_DI0_EN)\r\nval |= IPU_DI0_COUNTER_RELEASE;\r\nif (mask & IPU_CONF_DI1_EN)\r\nval |= IPU_DI1_COUNTER_RELEASE;\r\nipu_cm_write(ipu, val, IPU_DISP_GEN);\r\nval = ipu_cm_read(ipu, IPU_CONF);\r\nval |= mask;\r\nipu_cm_write(ipu, val, IPU_CONF);\r\nspin_unlock_irqrestore(&ipu->lock, lock_flags);\r\nreturn 0;\r\n}\r\nint ipu_module_disable(struct ipu_soc *ipu, u32 mask)\r\n{\r\nunsigned long lock_flags;\r\nu32 val;\r\nspin_lock_irqsave(&ipu->lock, lock_flags);\r\nval = ipu_cm_read(ipu, IPU_CONF);\r\nval &= ~mask;\r\nipu_cm_write(ipu, val, IPU_CONF);\r\nval = ipu_cm_read(ipu, IPU_DISP_GEN);\r\nif (mask & IPU_CONF_DI0_EN)\r\nval &= ~IPU_DI0_COUNTER_RELEASE;\r\nif (mask & IPU_CONF_DI1_EN)\r\nval &= ~IPU_DI1_COUNTER_RELEASE;\r\nipu_cm_write(ipu, val, IPU_DISP_GEN);\r\nspin_unlock_irqrestore(&ipu->lock, lock_flags);\r\nreturn 0;\r\n}\r\nint ipu_idmac_get_current_buffer(struct ipuv3_channel *channel)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned int chno = channel->num;\r\nreturn (ipu_cm_read(ipu, IPU_CHA_CUR_BUF(chno)) & idma_mask(chno)) ? 1 : 0;\r\n}\r\nbool ipu_idmac_buffer_is_ready(struct ipuv3_channel *channel, u32 buf_num)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned long flags;\r\nu32 reg = 0;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nswitch (buf_num) {\r\ncase 0:\r\nreg = ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(channel->num));\r\nbreak;\r\ncase 1:\r\nreg = ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(channel->num));\r\nbreak;\r\ncase 2:\r\nreg = ipu_cm_read(ipu, IPU_CHA_BUF2_RDY(channel->num));\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nreturn ((reg & idma_mask(channel->num)) != 0);\r\n}\r\nvoid ipu_idmac_select_buffer(struct ipuv3_channel *channel, u32 buf_num)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned int chno = channel->num;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nif (buf_num == 0)\r\nipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF0_RDY(chno));\r\nelse\r\nipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF1_RDY(chno));\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\n}\r\nvoid ipu_idmac_clear_buffer(struct ipuv3_channel *channel, u32 buf_num)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned int chno = channel->num;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nipu_cm_write(ipu, 0xF0300000, IPU_GPR);\r\nswitch (buf_num) {\r\ncase 0:\r\nipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF0_RDY(chno));\r\nbreak;\r\ncase 1:\r\nipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF1_RDY(chno));\r\nbreak;\r\ncase 2:\r\nipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF2_RDY(chno));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nipu_cm_write(ipu, 0x0, IPU_GPR);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\n}\r\nint ipu_idmac_enable_channel(struct ipuv3_channel *channel)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nval = ipu_idmac_read(ipu, IDMAC_CHA_EN(channel->num));\r\nval |= idma_mask(channel->num);\r\nipu_idmac_write(ipu, val, IDMAC_CHA_EN(channel->num));\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nreturn 0;\r\n}\r\nbool ipu_idmac_channel_busy(struct ipu_soc *ipu, unsigned int chno)\r\n{\r\nreturn (ipu_idmac_read(ipu, IDMAC_CHA_BUSY(chno)) & idma_mask(chno));\r\n}\r\nint ipu_idmac_wait_busy(struct ipuv3_channel *channel, int ms)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(ms);\r\nwhile (ipu_idmac_read(ipu, IDMAC_CHA_BUSY(channel->num)) &\r\nidma_mask(channel->num)) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nint ipu_wait_interrupt(struct ipu_soc *ipu, int irq, int ms)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(ms);\r\nipu_cm_write(ipu, BIT(irq % 32), IPU_INT_STAT(irq / 32));\r\nwhile (!(ipu_cm_read(ipu, IPU_INT_STAT(irq / 32) & BIT(irq % 32)))) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nint ipu_idmac_disable_channel(struct ipuv3_channel *channel)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nval = ipu_idmac_read(ipu, IDMAC_CHA_EN(channel->num));\r\nval &= ~idma_mask(channel->num);\r\nipu_idmac_write(ipu, val, IDMAC_CHA_EN(channel->num));\r\n__ipu_idmac_reset_current_buffer(channel);\r\nipu_cm_write(ipu, 0xf0000000, IPU_GPR);\r\nif (ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(channel->num)) &\r\nidma_mask(channel->num)) {\r\nipu_cm_write(ipu, idma_mask(channel->num),\r\nIPU_CHA_BUF0_RDY(channel->num));\r\n}\r\nif (ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(channel->num)) &\r\nidma_mask(channel->num)) {\r\nipu_cm_write(ipu, idma_mask(channel->num),\r\nIPU_CHA_BUF1_RDY(channel->num));\r\n}\r\nipu_cm_write(ipu, 0x0, IPU_GPR);\r\nval = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(channel->num));\r\nval &= ~idma_mask(channel->num);\r\nipu_cm_write(ipu, val, IPU_CHA_DB_MODE_SEL(channel->num));\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nreturn 0;\r\n}\r\nvoid ipu_idmac_enable_watermark(struct ipuv3_channel *channel, bool enable)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nval = ipu_idmac_read(ipu, IDMAC_WM_EN(channel->num));\r\nif (enable)\r\nval |= 1 << (channel->num % 32);\r\nelse\r\nval &= ~(1 << (channel->num % 32));\r\nipu_idmac_write(ipu, val, IDMAC_WM_EN(channel->num));\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\n}\r\nstatic int ipu_memory_reset(struct ipu_soc *ipu)\r\n{\r\nunsigned long timeout;\r\nipu_cm_write(ipu, 0x807FFFFF, IPU_MEM_RST);\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\nwhile (ipu_cm_read(ipu, IPU_MEM_RST) & 0x80000000) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIME;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nvoid ipu_set_csi_src_mux(struct ipu_soc *ipu, int csi_id, bool mipi_csi2)\r\n{\r\nunsigned long flags;\r\nu32 val, mask;\r\nmask = (csi_id == 1) ? IPU_CONF_CSI1_DATA_SOURCE :\r\nIPU_CONF_CSI0_DATA_SOURCE;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nval = ipu_cm_read(ipu, IPU_CONF);\r\nif (mipi_csi2)\r\nval |= mask;\r\nelse\r\nval &= ~mask;\r\nipu_cm_write(ipu, val, IPU_CONF);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\n}\r\nvoid ipu_set_ic_src_mux(struct ipu_soc *ipu, int csi_id, bool vdi)\r\n{\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nval = ipu_cm_read(ipu, IPU_CONF);\r\nif (vdi) {\r\nval |= IPU_CONF_IC_INPUT;\r\n} else {\r\nval &= ~IPU_CONF_IC_INPUT;\r\nif (csi_id == 1)\r\nval |= IPU_CONF_CSI_SEL;\r\nelse\r\nval &= ~IPU_CONF_CSI_SEL;\r\n}\r\nipu_cm_write(ipu, val, IPU_CONF);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\n}\r\nstatic int ipu_submodules_init(struct ipu_soc *ipu,\r\nstruct platform_device *pdev, unsigned long ipu_base,\r\nstruct clk *ipu_clk)\r\n{\r\nchar *unit;\r\nint ret;\r\nstruct device *dev = &pdev->dev;\r\nconst struct ipu_devtype *devtype = ipu->devtype;\r\nret = ipu_cpmem_init(ipu, dev, ipu_base + devtype->cpmem_ofs);\r\nif (ret) {\r\nunit = "cpmem";\r\ngoto err_cpmem;\r\n}\r\nret = ipu_csi_init(ipu, dev, 0, ipu_base + devtype->csi0_ofs,\r\nIPU_CONF_CSI0_EN, ipu_clk);\r\nif (ret) {\r\nunit = "csi0";\r\ngoto err_csi_0;\r\n}\r\nret = ipu_csi_init(ipu, dev, 1, ipu_base + devtype->csi1_ofs,\r\nIPU_CONF_CSI1_EN, ipu_clk);\r\nif (ret) {\r\nunit = "csi1";\r\ngoto err_csi_1;\r\n}\r\nret = ipu_ic_init(ipu, dev,\r\nipu_base + devtype->ic_ofs,\r\nipu_base + devtype->tpm_ofs);\r\nif (ret) {\r\nunit = "ic";\r\ngoto err_ic;\r\n}\r\nret = ipu_di_init(ipu, dev, 0, ipu_base + devtype->disp0_ofs,\r\nIPU_CONF_DI0_EN, ipu_clk);\r\nif (ret) {\r\nunit = "di0";\r\ngoto err_di_0;\r\n}\r\nret = ipu_di_init(ipu, dev, 1, ipu_base + devtype->disp1_ofs,\r\nIPU_CONF_DI1_EN, ipu_clk);\r\nif (ret) {\r\nunit = "di1";\r\ngoto err_di_1;\r\n}\r\nret = ipu_dc_init(ipu, dev, ipu_base + devtype->cm_ofs +\r\nIPU_CM_DC_REG_OFS, ipu_base + devtype->dc_tmpl_ofs);\r\nif (ret) {\r\nunit = "dc_template";\r\ngoto err_dc;\r\n}\r\nret = ipu_dmfc_init(ipu, dev, ipu_base +\r\ndevtype->cm_ofs + IPU_CM_DMFC_REG_OFS, ipu_clk);\r\nif (ret) {\r\nunit = "dmfc";\r\ngoto err_dmfc;\r\n}\r\nret = ipu_dp_init(ipu, dev, ipu_base + devtype->srm_ofs);\r\nif (ret) {\r\nunit = "dp";\r\ngoto err_dp;\r\n}\r\nret = ipu_smfc_init(ipu, dev, ipu_base +\r\ndevtype->cm_ofs + IPU_CM_SMFC_REG_OFS);\r\nif (ret) {\r\nunit = "smfc";\r\ngoto err_smfc;\r\n}\r\nreturn 0;\r\nerr_smfc:\r\nipu_dp_exit(ipu);\r\nerr_dp:\r\nipu_dmfc_exit(ipu);\r\nerr_dmfc:\r\nipu_dc_exit(ipu);\r\nerr_dc:\r\nipu_di_exit(ipu, 1);\r\nerr_di_1:\r\nipu_di_exit(ipu, 0);\r\nerr_di_0:\r\nipu_ic_exit(ipu);\r\nerr_ic:\r\nipu_csi_exit(ipu, 1);\r\nerr_csi_1:\r\nipu_csi_exit(ipu, 0);\r\nerr_csi_0:\r\nipu_cpmem_exit(ipu);\r\nerr_cpmem:\r\ndev_err(&pdev->dev, "init %s failed with %d\n", unit, ret);\r\nreturn ret;\r\n}\r\nstatic void ipu_irq_handle(struct ipu_soc *ipu, const int *regs, int num_regs)\r\n{\r\nunsigned long status;\r\nint i, bit, irq;\r\nfor (i = 0; i < num_regs; i++) {\r\nstatus = ipu_cm_read(ipu, IPU_INT_STAT(regs[i]));\r\nstatus &= ipu_cm_read(ipu, IPU_INT_CTRL(regs[i]));\r\nfor_each_set_bit(bit, &status, 32) {\r\nirq = irq_linear_revmap(ipu->domain,\r\nregs[i] * 32 + bit);\r\nif (irq)\r\ngeneric_handle_irq(irq);\r\n}\r\n}\r\n}\r\nstatic void ipu_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct ipu_soc *ipu = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nconst int int_reg[] = { 0, 1, 2, 3, 10, 11, 12, 13, 14};\r\nchained_irq_enter(chip, desc);\r\nipu_irq_handle(ipu, int_reg, ARRAY_SIZE(int_reg));\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void ipu_err_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct ipu_soc *ipu = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nconst int int_reg[] = { 4, 5, 8, 9};\r\nchained_irq_enter(chip, desc);\r\nipu_irq_handle(ipu, int_reg, ARRAY_SIZE(int_reg));\r\nchained_irq_exit(chip, desc);\r\n}\r\nint ipu_map_irq(struct ipu_soc *ipu, int irq)\r\n{\r\nint virq;\r\nvirq = irq_linear_revmap(ipu->domain, irq);\r\nif (!virq)\r\nvirq = irq_create_mapping(ipu->domain, irq);\r\nreturn virq;\r\n}\r\nint ipu_idmac_channel_irq(struct ipu_soc *ipu, struct ipuv3_channel *channel,\r\nenum ipu_channel_irq irq_type)\r\n{\r\nreturn ipu_map_irq(ipu, irq_type + channel->num);\r\n}\r\nstatic void ipu_submodules_exit(struct ipu_soc *ipu)\r\n{\r\nipu_smfc_exit(ipu);\r\nipu_dp_exit(ipu);\r\nipu_dmfc_exit(ipu);\r\nipu_dc_exit(ipu);\r\nipu_di_exit(ipu, 1);\r\nipu_di_exit(ipu, 0);\r\nipu_ic_exit(ipu);\r\nipu_csi_exit(ipu, 1);\r\nipu_csi_exit(ipu, 0);\r\nipu_cpmem_exit(ipu);\r\n}\r\nstatic int platform_remove_devices_fn(struct device *dev, void *unused)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nplatform_device_unregister(pdev);\r\nreturn 0;\r\n}\r\nstatic void platform_device_unregister_children(struct platform_device *pdev)\r\n{\r\ndevice_for_each_child(&pdev->dev, NULL, platform_remove_devices_fn);\r\n}\r\nstatic int ipu_add_client_devices(struct ipu_soc *ipu, unsigned long ipu_base)\r\n{\r\nstruct device *dev = ipu->dev;\r\nunsigned i;\r\nint id, ret;\r\nmutex_lock(&ipu_client_id_mutex);\r\nid = ipu_client_id;\r\nipu_client_id += ARRAY_SIZE(client_reg);\r\nmutex_unlock(&ipu_client_id_mutex);\r\nfor (i = 0; i < ARRAY_SIZE(client_reg); i++) {\r\nstruct ipu_platform_reg *reg = &client_reg[i];\r\nstruct platform_device *pdev;\r\nstruct device_node *of_node;\r\nof_node = of_graph_get_port_by_id(dev->of_node, i);\r\nif (!of_node) {\r\ndev_info(dev,\r\n"no port@%d node in %s, not using %s%d\n",\r\ni, dev->of_node->full_name,\r\n(i / 2) ? "DI" : "CSI", i % 2);\r\ncontinue;\r\n}\r\npdev = platform_device_alloc(reg->name, id++);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto err_register;\r\n}\r\npdev->dev.parent = dev;\r\nreg->pdata.of_node = of_node;\r\nret = platform_device_add_data(pdev, &reg->pdata,\r\nsizeof(reg->pdata));\r\nif (!ret)\r\nret = platform_device_add(pdev);\r\nif (ret) {\r\nplatform_device_put(pdev);\r\ngoto err_register;\r\n}\r\npdev->dev.of_node = of_node;\r\n}\r\nreturn 0;\r\nerr_register:\r\nplatform_device_unregister_children(to_platform_device(dev));\r\nreturn ret;\r\n}\r\nstatic int ipu_irq_init(struct ipu_soc *ipu)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nunsigned long unused[IPU_NUM_IRQS / 32] = {\r\n0x400100d0, 0xffe000fd,\r\n0x400100d0, 0xffe000fd,\r\n0x400100d0, 0xffe000fd,\r\n0x4077ffff, 0xffe7e1fd,\r\n0x23fffffe, 0x8880fff0,\r\n0xf98fe7d0, 0xfff81fff,\r\n0x400100d0, 0xffe000fd,\r\n0x00000000,\r\n};\r\nint ret, i;\r\nipu->domain = irq_domain_add_linear(ipu->dev->of_node, IPU_NUM_IRQS,\r\n&irq_generic_chip_ops, ipu);\r\nif (!ipu->domain) {\r\ndev_err(ipu->dev, "failed to add irq domain\n");\r\nreturn -ENODEV;\r\n}\r\nret = irq_alloc_domain_generic_chips(ipu->domain, 32, 1, "IPU",\r\nhandle_level_irq, 0, 0, 0);\r\nif (ret < 0) {\r\ndev_err(ipu->dev, "failed to alloc generic irq chips\n");\r\nirq_domain_remove(ipu->domain);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < IPU_NUM_IRQS; i += 32)\r\nipu_cm_write(ipu, 0, IPU_INT_CTRL(i / 32));\r\nfor (i = 0; i < IPU_NUM_IRQS; i += 32) {\r\ngc = irq_get_domain_generic_chip(ipu->domain, i);\r\ngc->reg_base = ipu->cm_reg;\r\ngc->unused = unused[i / 32];\r\nct = gc->chip_types;\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->regs.ack = IPU_INT_STAT(i / 32);\r\nct->regs.mask = IPU_INT_CTRL(i / 32);\r\n}\r\nirq_set_chained_handler_and_data(ipu->irq_sync, ipu_irq_handler, ipu);\r\nirq_set_chained_handler_and_data(ipu->irq_err, ipu_err_irq_handler,\r\nipu);\r\nreturn 0;\r\n}\r\nstatic void ipu_irq_exit(struct ipu_soc *ipu)\r\n{\r\nint i, irq;\r\nirq_set_chained_handler_and_data(ipu->irq_err, NULL, NULL);\r\nirq_set_chained_handler_and_data(ipu->irq_sync, NULL, NULL);\r\nfor (i = 0; i < IPU_NUM_IRQS; i++) {\r\nirq = irq_linear_revmap(ipu->domain, i);\r\nif (irq)\r\nirq_dispose_mapping(irq);\r\n}\r\nirq_domain_remove(ipu->domain);\r\n}\r\nvoid ipu_dump(struct ipu_soc *ipu)\r\n{\r\nint i;\r\ndev_dbg(ipu->dev, "IPU_CONF = \t0x%08X\n",\r\nipu_cm_read(ipu, IPU_CONF));\r\ndev_dbg(ipu->dev, "IDMAC_CONF = \t0x%08X\n",\r\nipu_idmac_read(ipu, IDMAC_CONF));\r\ndev_dbg(ipu->dev, "IDMAC_CHA_EN1 = \t0x%08X\n",\r\nipu_idmac_read(ipu, IDMAC_CHA_EN(0)));\r\ndev_dbg(ipu->dev, "IDMAC_CHA_EN2 = \t0x%08X\n",\r\nipu_idmac_read(ipu, IDMAC_CHA_EN(32)));\r\ndev_dbg(ipu->dev, "IDMAC_CHA_PRI1 = \t0x%08X\n",\r\nipu_idmac_read(ipu, IDMAC_CHA_PRI(0)));\r\ndev_dbg(ipu->dev, "IDMAC_CHA_PRI2 = \t0x%08X\n",\r\nipu_idmac_read(ipu, IDMAC_CHA_PRI(32)));\r\ndev_dbg(ipu->dev, "IDMAC_BAND_EN1 = \t0x%08X\n",\r\nipu_idmac_read(ipu, IDMAC_BAND_EN(0)));\r\ndev_dbg(ipu->dev, "IDMAC_BAND_EN2 = \t0x%08X\n",\r\nipu_idmac_read(ipu, IDMAC_BAND_EN(32)));\r\ndev_dbg(ipu->dev, "IPU_CHA_DB_MODE_SEL0 = \t0x%08X\n",\r\nipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(0)));\r\ndev_dbg(ipu->dev, "IPU_CHA_DB_MODE_SEL1 = \t0x%08X\n",\r\nipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(32)));\r\ndev_dbg(ipu->dev, "IPU_FS_PROC_FLOW1 = \t0x%08X\n",\r\nipu_cm_read(ipu, IPU_FS_PROC_FLOW1));\r\ndev_dbg(ipu->dev, "IPU_FS_PROC_FLOW2 = \t0x%08X\n",\r\nipu_cm_read(ipu, IPU_FS_PROC_FLOW2));\r\ndev_dbg(ipu->dev, "IPU_FS_PROC_FLOW3 = \t0x%08X\n",\r\nipu_cm_read(ipu, IPU_FS_PROC_FLOW3));\r\ndev_dbg(ipu->dev, "IPU_FS_DISP_FLOW1 = \t0x%08X\n",\r\nipu_cm_read(ipu, IPU_FS_DISP_FLOW1));\r\nfor (i = 0; i < 15; i++)\r\ndev_dbg(ipu->dev, "IPU_INT_CTRL(%d) = \t%08X\n", i,\r\nipu_cm_read(ipu, IPU_INT_CTRL(i)));\r\n}\r\nstatic int ipu_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_ipu_dt_ids, &pdev->dev);\r\nstruct ipu_soc *ipu;\r\nstruct resource *res;\r\nunsigned long ipu_base;\r\nint i, ret, irq_sync, irq_err;\r\nconst struct ipu_devtype *devtype;\r\ndevtype = of_id->data;\r\nirq_sync = platform_get_irq(pdev, 0);\r\nirq_err = platform_get_irq(pdev, 1);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev_dbg(&pdev->dev, "irq_sync: %d irq_err: %d\n",\r\nirq_sync, irq_err);\r\nif (!res || irq_sync < 0 || irq_err < 0)\r\nreturn -ENODEV;\r\nipu_base = res->start;\r\nipu = devm_kzalloc(&pdev->dev, sizeof(*ipu), GFP_KERNEL);\r\nif (!ipu)\r\nreturn -ENODEV;\r\nfor (i = 0; i < 64; i++)\r\nipu->channel[i].ipu = ipu;\r\nipu->devtype = devtype;\r\nipu->ipu_type = devtype->type;\r\nspin_lock_init(&ipu->lock);\r\nmutex_init(&ipu->channel_lock);\r\ndev_dbg(&pdev->dev, "cm_reg: 0x%08lx\n",\r\nipu_base + devtype->cm_ofs);\r\ndev_dbg(&pdev->dev, "idmac: 0x%08lx\n",\r\nipu_base + devtype->cm_ofs + IPU_CM_IDMAC_REG_OFS);\r\ndev_dbg(&pdev->dev, "cpmem: 0x%08lx\n",\r\nipu_base + devtype->cpmem_ofs);\r\ndev_dbg(&pdev->dev, "csi0: 0x%08lx\n",\r\nipu_base + devtype->csi0_ofs);\r\ndev_dbg(&pdev->dev, "csi1: 0x%08lx\n",\r\nipu_base + devtype->csi1_ofs);\r\ndev_dbg(&pdev->dev, "ic: 0x%08lx\n",\r\nipu_base + devtype->ic_ofs);\r\ndev_dbg(&pdev->dev, "disp0: 0x%08lx\n",\r\nipu_base + devtype->disp0_ofs);\r\ndev_dbg(&pdev->dev, "disp1: 0x%08lx\n",\r\nipu_base + devtype->disp1_ofs);\r\ndev_dbg(&pdev->dev, "srm: 0x%08lx\n",\r\nipu_base + devtype->srm_ofs);\r\ndev_dbg(&pdev->dev, "tpm: 0x%08lx\n",\r\nipu_base + devtype->tpm_ofs);\r\ndev_dbg(&pdev->dev, "dc: 0x%08lx\n",\r\nipu_base + devtype->cm_ofs + IPU_CM_DC_REG_OFS);\r\ndev_dbg(&pdev->dev, "ic: 0x%08lx\n",\r\nipu_base + devtype->cm_ofs + IPU_CM_IC_REG_OFS);\r\ndev_dbg(&pdev->dev, "dmfc: 0x%08lx\n",\r\nipu_base + devtype->cm_ofs + IPU_CM_DMFC_REG_OFS);\r\ndev_dbg(&pdev->dev, "vdi: 0x%08lx\n",\r\nipu_base + devtype->vdi_ofs);\r\nipu->cm_reg = devm_ioremap(&pdev->dev,\r\nipu_base + devtype->cm_ofs, PAGE_SIZE);\r\nipu->idmac_reg = devm_ioremap(&pdev->dev,\r\nipu_base + devtype->cm_ofs + IPU_CM_IDMAC_REG_OFS,\r\nPAGE_SIZE);\r\nif (!ipu->cm_reg || !ipu->idmac_reg)\r\nreturn -ENOMEM;\r\nipu->clk = devm_clk_get(&pdev->dev, "bus");\r\nif (IS_ERR(ipu->clk)) {\r\nret = PTR_ERR(ipu->clk);\r\ndev_err(&pdev->dev, "clk_get failed with %d", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, ipu);\r\nret = clk_prepare_enable(ipu->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "clk_prepare_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nipu->dev = &pdev->dev;\r\nipu->irq_sync = irq_sync;\r\nipu->irq_err = irq_err;\r\nret = device_reset(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to reset: %d\n", ret);\r\ngoto out_failed_reset;\r\n}\r\nret = ipu_memory_reset(ipu);\r\nif (ret)\r\ngoto out_failed_reset;\r\nret = ipu_irq_init(ipu);\r\nif (ret)\r\ngoto out_failed_irq;\r\nipu_cm_write(ipu, 0x00400000L | (IPU_MCU_T_DEFAULT << 18),\r\nIPU_DISP_GEN);\r\nret = ipu_submodules_init(ipu, pdev, ipu_base, ipu->clk);\r\nif (ret)\r\ngoto failed_submodules_init;\r\nret = ipu_add_client_devices(ipu, ipu_base);\r\nif (ret) {\r\ndev_err(&pdev->dev, "adding client devices failed with %d\n",\r\nret);\r\ngoto failed_add_clients;\r\n}\r\ndev_info(&pdev->dev, "%s probed\n", devtype->name);\r\nreturn 0;\r\nfailed_add_clients:\r\nipu_submodules_exit(ipu);\r\nfailed_submodules_init:\r\nipu_irq_exit(ipu);\r\nout_failed_irq:\r\nout_failed_reset:\r\nclk_disable_unprepare(ipu->clk);\r\nreturn ret;\r\n}\r\nstatic int ipu_remove(struct platform_device *pdev)\r\n{\r\nstruct ipu_soc *ipu = platform_get_drvdata(pdev);\r\nplatform_device_unregister_children(pdev);\r\nipu_submodules_exit(ipu);\r\nipu_irq_exit(ipu);\r\nclk_disable_unprepare(ipu->clk);\r\nreturn 0;\r\n}
