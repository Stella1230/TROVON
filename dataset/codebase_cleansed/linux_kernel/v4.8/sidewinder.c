static int sw_read_packet(struct gameport *gameport, unsigned char *buf, int length, int id)\r\n{\r\nunsigned long flags;\r\nint timeout, bitout, sched, i, kick, start, strobe;\r\nunsigned char pending, u, v;\r\ni = -id;\r\ntimeout = id ? gameport_time(gameport, SW_TIMEOUT * 1000) : 0;\r\nkick = id ? gameport_time(gameport, SW_KICK) : 0;\r\nstart = gameport_time(gameport, SW_START);\r\nstrobe = gameport_time(gameport, SW_STROBE);\r\nbitout = start;\r\npending = 0;\r\nsched = 0;\r\nlocal_irq_save(flags);\r\ngameport_trigger(gameport);\r\nv = gameport_read(gameport);\r\ndo {\r\nbitout--;\r\nu = v;\r\nv = gameport_read(gameport);\r\n} while (!(~v & u & 0x10) && (bitout > 0));\r\nif (bitout > 0)\r\nbitout = strobe;\r\nwhile ((timeout > 0 || bitout > 0) && (i < length)) {\r\ntimeout--;\r\nbitout--;\r\nsched--;\r\nu = v;\r\nv = gameport_read(gameport);\r\nif ((~u & v & 0x10) && (bitout > 0)) {\r\nif (i >= 0)\r\nbuf[i] = v >> 5;\r\ni++;\r\nbitout = strobe;\r\n}\r\nif (kick && (~v & u & 0x01)) {\r\nsched = kick;\r\nkick = 0;\r\npending = 1;\r\n}\r\nif (pending && sched < 0 && (i > -SW_END)) {\r\ngameport_trigger(gameport);\r\nbitout = start;\r\npending = 0;\r\ntimeout = 0;\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\n#ifdef SW_DEBUG_DATA\r\n{\r\nint j;\r\nprintk(KERN_DEBUG "sidewinder.c: Read %d triplets. [", i);\r\nfor (j = 0; j < i; j++) printk("%d", buf[j]);\r\nprintk("]\n");\r\n}\r\n#endif\r\nreturn i;\r\n}\r\nstatic __u64 sw_get_bits(unsigned char *buf, int pos, int num, char bits)\r\n{\r\n__u64 data = 0;\r\nint tri = pos % bits;\r\nint i = pos / bits;\r\nint bit = 0;\r\nwhile (num--) {\r\ndata |= (__u64)((buf[i] >> tri++) & 1) << bit++;\r\nif (tri == bits) {\r\ni++;\r\ntri = 0;\r\n}\r\n}\r\nreturn data;\r\n}\r\nstatic void sw_init_digital(struct gameport *gameport)\r\n{\r\nint seq[] = { 140, 140+725, 140+300, 0 };\r\nunsigned long flags;\r\nint i, t;\r\nlocal_irq_save(flags);\r\ni = 0;\r\ndo {\r\ngameport_trigger(gameport);\r\nt = gameport_time(gameport, SW_TIMEOUT * 1000);\r\nwhile ((gameport_read(gameport) & 1) && t) t--;\r\nudelay(seq[i]);\r\n} while (seq[++i]);\r\ngameport_trigger(gameport);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int sw_parity(__u64 t)\r\n{\r\nint x = t ^ (t >> 32);\r\nx ^= x >> 16;\r\nx ^= x >> 8;\r\nx ^= x >> 4;\r\nx ^= x >> 2;\r\nx ^= x >> 1;\r\nreturn x & 1;\r\n}\r\nstatic int sw_check(__u64 t)\r\n{\r\nunsigned char sum = 0;\r\nif ((t & 0x8080808080808080ULL) ^ 0x80)\r\nreturn -1;\r\nwhile (t) {\r\nsum += t & 0xf;\r\nt >>= 4;\r\n}\r\nreturn sum & 0xf;\r\n}\r\nstatic int sw_parse(unsigned char *buf, struct sw *sw)\r\n{\r\nint hat, i, j;\r\nstruct input_dev *dev;\r\nswitch (sw->type) {\r\ncase SW_ID_3DP:\r\nif (sw_check(GB(0,64)) || (hat = (GB(6,1) << 3) | GB(60,3)) > 8)\r\nreturn -1;\r\ndev = sw->dev[0];\r\ninput_report_abs(dev, ABS_X, (GB( 3,3) << 7) | GB(16,7));\r\ninput_report_abs(dev, ABS_Y, (GB( 0,3) << 7) | GB(24,7));\r\ninput_report_abs(dev, ABS_RZ, (GB(35,2) << 7) | GB(40,7));\r\ninput_report_abs(dev, ABS_THROTTLE, (GB(32,3) << 7) | GB(48,7));\r\ninput_report_abs(dev, ABS_HAT0X, sw_hat_to_axis[hat].x);\r\ninput_report_abs(dev, ABS_HAT0Y, sw_hat_to_axis[hat].y);\r\nfor (j = 0; j < 7; j++)\r\ninput_report_key(dev, sw_btn[SW_ID_3DP][j], !GB(j+8,1));\r\ninput_report_key(dev, BTN_BASE4, !GB(38,1));\r\ninput_report_key(dev, BTN_BASE5, !GB(37,1));\r\ninput_sync(dev);\r\nreturn 0;\r\ncase SW_ID_GP:\r\nfor (i = 0; i < sw->number; i ++) {\r\nif (sw_parity(GB(i*15,15)))\r\nreturn -1;\r\ninput_report_abs(sw->dev[i], ABS_X, GB(i*15+3,1) - GB(i*15+2,1));\r\ninput_report_abs(sw->dev[i], ABS_Y, GB(i*15+0,1) - GB(i*15+1,1));\r\nfor (j = 0; j < 10; j++)\r\ninput_report_key(sw->dev[i], sw_btn[SW_ID_GP][j], !GB(i*15+j+4,1));\r\ninput_sync(sw->dev[i]);\r\n}\r\nreturn 0;\r\ncase SW_ID_PP:\r\ncase SW_ID_FFP:\r\nif (!sw_parity(GB(0,48)) || (hat = GB(42,4)) > 8)\r\nreturn -1;\r\ndev = sw->dev[0];\r\ninput_report_abs(dev, ABS_X, GB( 9,10));\r\ninput_report_abs(dev, ABS_Y, GB(19,10));\r\ninput_report_abs(dev, ABS_RZ, GB(36, 6));\r\ninput_report_abs(dev, ABS_THROTTLE, GB(29, 7));\r\ninput_report_abs(dev, ABS_HAT0X, sw_hat_to_axis[hat].x);\r\ninput_report_abs(dev, ABS_HAT0Y, sw_hat_to_axis[hat].y);\r\nfor (j = 0; j < 9; j++)\r\ninput_report_key(dev, sw_btn[SW_ID_PP][j], !GB(j,1));\r\ninput_sync(dev);\r\nreturn 0;\r\ncase SW_ID_FSP:\r\nif (!sw_parity(GB(0,43)) || (hat = GB(28,4)) > 8)\r\nreturn -1;\r\ndev = sw->dev[0];\r\ninput_report_abs(dev, ABS_X, GB( 0,10));\r\ninput_report_abs(dev, ABS_Y, GB(16,10));\r\ninput_report_abs(dev, ABS_THROTTLE, GB(32, 6));\r\ninput_report_abs(dev, ABS_HAT0X, sw_hat_to_axis[hat].x);\r\ninput_report_abs(dev, ABS_HAT0Y, sw_hat_to_axis[hat].y);\r\nfor (j = 0; j < 6; j++)\r\ninput_report_key(dev, sw_btn[SW_ID_FSP][j], !GB(j+10,1));\r\ninput_report_key(dev, BTN_TR, !GB(26,1));\r\ninput_report_key(dev, BTN_START, !GB(27,1));\r\ninput_report_key(dev, BTN_MODE, !GB(38,1));\r\ninput_report_key(dev, BTN_SELECT, !GB(39,1));\r\ninput_sync(dev);\r\nreturn 0;\r\ncase SW_ID_FFW:\r\nif (!sw_parity(GB(0,33)))\r\nreturn -1;\r\ndev = sw->dev[0];\r\ninput_report_abs(dev, ABS_RX, GB( 0,10));\r\ninput_report_abs(dev, ABS_RUDDER, GB(10, 6));\r\ninput_report_abs(dev, ABS_THROTTLE, GB(16, 6));\r\nfor (j = 0; j < 8; j++)\r\ninput_report_key(dev, sw_btn[SW_ID_FFW][j], !GB(j+22,1));\r\ninput_sync(dev);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int sw_read(struct sw *sw)\r\n{\r\nunsigned char buf[SW_LENGTH];\r\nint i;\r\ni = sw_read_packet(sw->gameport, buf, sw->length, 0);\r\nif (sw->type == SW_ID_3DP && sw->length == 66 && i != 66) {\r\nif (i == 64 && !sw_check(sw_get_bits(buf,0,64,1))) {\r\nprintk(KERN_WARNING "sidewinder.c: Joystick in wrong mode on %s"\r\n" - going to reinitialize.\n", sw->gameport->phys);\r\nsw->fail = SW_FAIL;\r\ni = 128;\r\n}\r\nif (i < 66 && GB(0,64) == GB(i*3-66,64))\r\ni = 66;\r\nif (i < 66 && GB(0,64) == GB(66,64))\r\ni = 66;\r\nif (i < 66 && GB(i*3-132,64) == GB(i*3-66,64)) {\r\nmemmove(buf, buf + i - 22, 22);\r\ni = 66;\r\n}\r\n}\r\nif (i == sw->length && !sw_parse(buf, sw)) {\r\nsw->fail = 0;\r\nsw->ok++;\r\nif (sw->type == SW_ID_3DP && sw->length == 66\r\n&& sw->ok > SW_OK) {\r\nprintk(KERN_INFO "sidewinder.c: No more trouble on %s"\r\n" - enabling optimization again.\n", sw->gameport->phys);\r\nsw->length = 22;\r\n}\r\nreturn 0;\r\n}\r\nsw->ok = 0;\r\nsw->fail++;\r\nif (sw->type == SW_ID_3DP && sw->length == 22 && sw->fail > SW_BAD) {\r\nprintk(KERN_INFO "sidewinder.c: Many bit errors on %s"\r\n" - disabling optimization.\n", sw->gameport->phys);\r\nsw->length = 66;\r\n}\r\nif (sw->fail < SW_FAIL)\r\nreturn -1;\r\nprintk(KERN_WARNING "sidewinder.c: Too many bit errors on %s"\r\n" - reinitializing joystick.\n", sw->gameport->phys);\r\nif (!i && sw->type == SW_ID_3DP) {\r\nmdelay(3 * SW_TIMEOUT);\r\nsw_init_digital(sw->gameport);\r\n}\r\nmdelay(SW_TIMEOUT);\r\ni = sw_read_packet(sw->gameport, buf, SW_LENGTH, 0);\r\nmdelay(SW_TIMEOUT);\r\nsw_read_packet(sw->gameport, buf, SW_LENGTH, i);\r\nsw->fail = SW_FAIL;\r\nreturn -1;\r\n}\r\nstatic void sw_poll(struct gameport *gameport)\r\n{\r\nstruct sw *sw = gameport_get_drvdata(gameport);\r\nsw->reads++;\r\nif (sw_read(sw))\r\nsw->bads++;\r\n}\r\nstatic int sw_open(struct input_dev *dev)\r\n{\r\nstruct sw *sw = input_get_drvdata(dev);\r\ngameport_start_polling(sw->gameport);\r\nreturn 0;\r\n}\r\nstatic void sw_close(struct input_dev *dev)\r\n{\r\nstruct sw *sw = input_get_drvdata(dev);\r\ngameport_stop_polling(sw->gameport);\r\n}\r\nstatic void sw_print_packet(char *name, int length, unsigned char *buf, char bits)\r\n{\r\nint i;\r\nprintk(KERN_INFO "sidewinder.c: %s packet, %d bits. [", name, length);\r\nfor (i = (((length + 3) >> 2) - 1); i >= 0; i--)\r\nprintk("%x", (int)sw_get_bits(buf, i << 2, 4, bits));\r\nprintk("]\n");\r\n}\r\nstatic void sw_3dp_id(unsigned char *buf, char *comment, size_t size)\r\n{\r\nint i;\r\nchar pnp[8], rev[9];\r\nfor (i = 0; i < 7; i++)\r\npnp[i] = sw_get_bits(buf, 24+8*i, 8, 1);\r\nfor (i = 0; i < 8; i++)\r\nrev[i] = sw_get_bits(buf, 88+8*i, 8, 1);\r\npnp[7] = rev[8] = 0;\r\nsnprintf(comment, size, " [PnP %d.%02d id %s rev %s]",\r\n(int) ((sw_get_bits(buf, 8, 6, 1) << 6) |\r\nsw_get_bits(buf, 16, 6, 1)) / 100,\r\n(int) ((sw_get_bits(buf, 8, 6, 1) << 6) |\r\nsw_get_bits(buf, 16, 6, 1)) % 100,\r\npnp, rev);\r\n}\r\nstatic int sw_guess_mode(unsigned char *buf, int len)\r\n{\r\nint i;\r\nunsigned char xor = 0;\r\nfor (i = 1; i < len; i++)\r\nxor |= (buf[i - 1] ^ buf[i]) & 6;\r\nreturn !!xor * 2 + 1;\r\n}\r\nstatic int sw_connect(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nstruct sw *sw;\r\nstruct input_dev *input_dev;\r\nint i, j, k, l;\r\nint err = 0;\r\nunsigned char *buf = NULL;\r\nunsigned char *idbuf = NULL;\r\nunsigned char m = 1;\r\nchar comment[40];\r\ncomment[0] = 0;\r\nsw = kzalloc(sizeof(struct sw), GFP_KERNEL);\r\nbuf = kmalloc(SW_LENGTH, GFP_KERNEL);\r\nidbuf = kmalloc(SW_LENGTH, GFP_KERNEL);\r\nif (!sw || !buf || !idbuf) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nsw->gameport = gameport;\r\ngameport_set_drvdata(gameport, sw);\r\nerr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\r\nif (err)\r\ngoto fail1;\r\ndbg("Init 0: Opened %s, io %#x, speed %d",\r\ngameport->phys, gameport->io, gameport->speed);\r\ni = sw_read_packet(gameport, buf, SW_LENGTH, 0);\r\nmsleep(SW_TIMEOUT);\r\ndbg("Init 1: Mode %d. Length %d.", m , i);\r\nif (!i) {\r\nsw_init_digital(gameport);\r\nmsleep(SW_TIMEOUT);\r\ni = sw_read_packet(gameport, buf, SW_LENGTH, 0);\r\nmsleep(SW_TIMEOUT);\r\ndbg("Init 1b: Length %d.", i);\r\nif (!i) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\n}\r\nj = sw_read_packet(gameport, idbuf, SW_LENGTH, i);\r\nm |= sw_guess_mode(idbuf, j);\r\ndbg("Init 2: Mode %d. ID Length %d.", m, j);\r\nif (j <= 0) {\r\nmsleep(SW_TIMEOUT);\r\ni = sw_read_packet(gameport, buf, SW_LENGTH, 0);\r\nm |= sw_guess_mode(buf, i);\r\ndbg("Init 2b: Mode %d. Length %d.", m, i);\r\nif (!i) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\nmsleep(SW_TIMEOUT);\r\nj = sw_read_packet(gameport, idbuf, SW_LENGTH, i);\r\ndbg("Init 2c: ID Length %d.", j);\r\n}\r\nsw->type = -1;\r\nk = SW_FAIL;\r\nl = 0;\r\ndo {\r\nk--;\r\nmsleep(SW_TIMEOUT);\r\ni = sw_read_packet(gameport, buf, SW_LENGTH, 0);\r\ndbg("Init 3: Mode %d. Length %d. Last %d. Tries %d.", m, i, l, k);\r\nif (i > l) {\r\nl = i;\r\nsw->number = 1;\r\nsw->gameport = gameport;\r\nsw->length = i;\r\nsw->bits = m;\r\ndbg("Init 3a: Case %d.\n", i * m);\r\nswitch (i * m) {\r\ncase 60:\r\nsw->number++;\r\ncase 45:\r\nif (j <= 40) {\r\ncase 43:\r\nsw->type = SW_ID_FSP;\r\nbreak;\r\n}\r\nsw->number++;\r\ncase 30:\r\nsw->number++;\r\ncase 15:\r\nsw->type = SW_ID_GP;\r\nbreak;\r\ncase 33:\r\ncase 31:\r\nsw->type = SW_ID_FFW;\r\nbreak;\r\ncase 48:\r\nif (j == 14) {\r\nsw->type = SW_ID_FFP;\r\nsprintf(comment, " [AC %s]", sw_get_bits(idbuf,38,1,3) ? "off" : "on");\r\n} else\r\nsw->type = SW_ID_PP;\r\nbreak;\r\ncase 66:\r\nsw->bits = 3;\r\ncase 198:\r\nsw->length = 22;\r\ncase 64:\r\nsw->type = SW_ID_3DP;\r\nif (j == 160)\r\nsw_3dp_id(idbuf, comment, sizeof(comment));\r\nbreak;\r\n}\r\n}\r\n} while (k && sw->type == -1);\r\nif (sw->type == -1) {\r\nprintk(KERN_WARNING "sidewinder.c: unknown joystick device detected "\r\n"on %s, contact <vojtech@ucw.cz>\n", gameport->phys);\r\nsw_print_packet("ID", j * 3, idbuf, 3);\r\nsw_print_packet("Data", i * m, buf, m);\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\n#ifdef SW_DEBUG\r\nsw_print_packet("ID", j * 3, idbuf, 3);\r\nsw_print_packet("Data", i * m, buf, m);\r\n#endif\r\ngameport_set_poll_handler(gameport, sw_poll);\r\ngameport_set_poll_interval(gameport, 20);\r\nk = i;\r\nl = j;\r\nfor (i = 0; i < sw->number; i++) {\r\nint bits, code;\r\nsnprintf(sw->name, sizeof(sw->name),\r\n"Microsoft SideWinder %s", sw_name[sw->type]);\r\nsnprintf(sw->phys[i], sizeof(sw->phys[i]),\r\n"%s/input%d", gameport->phys, i);\r\nsw->dev[i] = input_dev = input_allocate_device();\r\nif (!input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail3;\r\n}\r\ninput_dev->name = sw->name;\r\ninput_dev->phys = sw->phys[i];\r\ninput_dev->id.bustype = BUS_GAMEPORT;\r\ninput_dev->id.vendor = GAMEPORT_ID_VENDOR_MICROSOFT;\r\ninput_dev->id.product = sw->type;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &gameport->dev;\r\ninput_set_drvdata(input_dev, sw);\r\ninput_dev->open = sw_open;\r\ninput_dev->close = sw_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (j = 0; (bits = sw_bit[sw->type][j]); j++) {\r\nint min, max, fuzz, flat;\r\ncode = sw_abs[sw->type][j];\r\nmin = bits == 1 ? -1 : 0;\r\nmax = (1 << bits) - 1;\r\nfuzz = (bits >> 1) >= 2 ? 1 << ((bits >> 1) - 2) : 0;\r\nflat = code == ABS_THROTTLE || bits < 5 ?\r\n0 : 1 << (bits - 5);\r\ninput_set_abs_params(input_dev, code,\r\nmin, max, fuzz, flat);\r\n}\r\nfor (j = 0; (code = sw_btn[sw->type][j]); j++)\r\n__set_bit(code, input_dev->keybit);\r\ndbg("%s%s [%d-bit id %d data %d]\n", sw->name, comment, m, l, k);\r\nerr = input_register_device(sw->dev[i]);\r\nif (err)\r\ngoto fail4;\r\n}\r\nout: kfree(buf);\r\nkfree(idbuf);\r\nreturn err;\r\nfail4: input_free_device(sw->dev[i]);\r\nfail3: while (--i >= 0)\r\ninput_unregister_device(sw->dev[i]);\r\nfail2: gameport_close(gameport);\r\nfail1: gameport_set_drvdata(gameport, NULL);\r\nkfree(sw);\r\ngoto out;\r\n}\r\nstatic void sw_disconnect(struct gameport *gameport)\r\n{\r\nstruct sw *sw = gameport_get_drvdata(gameport);\r\nint i;\r\nfor (i = 0; i < sw->number; i++)\r\ninput_unregister_device(sw->dev[i]);\r\ngameport_close(gameport);\r\ngameport_set_drvdata(gameport, NULL);\r\nkfree(sw);\r\n}
