static inline int is_root_hub(struct usb_device *udev)\r\n{\r\nreturn (udev->parent == NULL);\r\n}\r\nstatic unsigned\r\nascii2desc(char const *s, u8 *buf, unsigned len)\r\n{\r\nunsigned n, t = 2 + 2*strlen(s);\r\nif (t > 254)\r\nt = 254;\r\nif (len > t)\r\nlen = t;\r\nt += USB_DT_STRING << 8;\r\nn = len;\r\nwhile (n--) {\r\n*buf++ = t;\r\nif (!n--)\r\nbreak;\r\n*buf++ = t >> 8;\r\nt = (unsigned char)*s++;\r\n}\r\nreturn len;\r\n}\r\nstatic unsigned\r\nrh_string(int id, struct usb_hcd const *hcd, u8 *data, unsigned len)\r\n{\r\nchar buf[100];\r\nchar const *s;\r\nstatic char const langids[4] = {4, USB_DT_STRING, 0x09, 0x04};\r\nswitch (id) {\r\ncase 0:\r\nif (len > 4)\r\nlen = 4;\r\nmemcpy(data, langids, len);\r\nreturn len;\r\ncase 1:\r\ns = hcd->self.bus_name;\r\nbreak;\r\ncase 2:\r\ns = hcd->product_desc;\r\nbreak;\r\ncase 3:\r\nsnprintf (buf, sizeof buf, "%s %s %s", init_utsname()->sysname,\r\ninit_utsname()->release, hcd->driver->description);\r\ns = buf;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn ascii2desc(s, data, len);\r\n}\r\nstatic int rh_call_control (struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *cmd;\r\nu16 typeReq, wValue, wIndex, wLength;\r\nu8 *ubuf = urb->transfer_buffer;\r\nunsigned len = 0;\r\nint status;\r\nu8 patch_wakeup = 0;\r\nu8 patch_protocol = 0;\r\nu16 tbuf_size;\r\nu8 *tbuf = NULL;\r\nconst u8 *bufp;\r\nmight_sleep();\r\nspin_lock_irq(&hcd_root_hub_lock);\r\nstatus = usb_hcd_link_urb_to_ep(hcd, urb);\r\nspin_unlock_irq(&hcd_root_hub_lock);\r\nif (status)\r\nreturn status;\r\nurb->hcpriv = hcd;\r\ncmd = (struct usb_ctrlrequest *) urb->setup_packet;\r\ntypeReq = (cmd->bRequestType << 8) | cmd->bRequest;\r\nwValue = le16_to_cpu (cmd->wValue);\r\nwIndex = le16_to_cpu (cmd->wIndex);\r\nwLength = le16_to_cpu (cmd->wLength);\r\nif (wLength > urb->transfer_buffer_length)\r\ngoto error;\r\ntbuf_size = max_t(u16, sizeof(struct usb_hub_descriptor), wLength);\r\ntbuf = kzalloc(tbuf_size, GFP_KERNEL);\r\nif (!tbuf)\r\nreturn -ENOMEM;\r\nbufp = tbuf;\r\nurb->actual_length = 0;\r\nswitch (typeReq) {\r\ncase DeviceRequest | USB_REQ_GET_STATUS:\r\ntbuf[0] = (device_may_wakeup(&hcd->self.root_hub->dev)\r\n<< USB_DEVICE_REMOTE_WAKEUP)\r\n| (1 << USB_DEVICE_SELF_POWERED);\r\ntbuf[1] = 0;\r\nlen = 2;\r\nbreak;\r\ncase DeviceOutRequest | USB_REQ_CLEAR_FEATURE:\r\nif (wValue == USB_DEVICE_REMOTE_WAKEUP)\r\ndevice_set_wakeup_enable(&hcd->self.root_hub->dev, 0);\r\nelse\r\ngoto error;\r\nbreak;\r\ncase DeviceOutRequest | USB_REQ_SET_FEATURE:\r\nif (device_can_wakeup(&hcd->self.root_hub->dev)\r\n&& wValue == USB_DEVICE_REMOTE_WAKEUP)\r\ndevice_set_wakeup_enable(&hcd->self.root_hub->dev, 1);\r\nelse\r\ngoto error;\r\nbreak;\r\ncase DeviceRequest | USB_REQ_GET_CONFIGURATION:\r\ntbuf[0] = 1;\r\nlen = 1;\r\ncase DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\r\nbreak;\r\ncase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\r\nswitch (wValue & 0xff00) {\r\ncase USB_DT_DEVICE << 8:\r\nswitch (hcd->speed) {\r\ncase HCD_USB31:\r\nbufp = usb31_rh_dev_descriptor;\r\nbreak;\r\ncase HCD_USB3:\r\nbufp = usb3_rh_dev_descriptor;\r\nbreak;\r\ncase HCD_USB25:\r\nbufp = usb25_rh_dev_descriptor;\r\nbreak;\r\ncase HCD_USB2:\r\nbufp = usb2_rh_dev_descriptor;\r\nbreak;\r\ncase HCD_USB11:\r\nbufp = usb11_rh_dev_descriptor;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nlen = 18;\r\nif (hcd->has_tt)\r\npatch_protocol = 1;\r\nbreak;\r\ncase USB_DT_CONFIG << 8:\r\nswitch (hcd->speed) {\r\ncase HCD_USB31:\r\ncase HCD_USB3:\r\nbufp = ss_rh_config_descriptor;\r\nlen = sizeof ss_rh_config_descriptor;\r\nbreak;\r\ncase HCD_USB25:\r\ncase HCD_USB2:\r\nbufp = hs_rh_config_descriptor;\r\nlen = sizeof hs_rh_config_descriptor;\r\nbreak;\r\ncase HCD_USB11:\r\nbufp = fs_rh_config_descriptor;\r\nlen = sizeof fs_rh_config_descriptor;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nif (device_can_wakeup(&hcd->self.root_hub->dev))\r\npatch_wakeup = 1;\r\nbreak;\r\ncase USB_DT_STRING << 8:\r\nif ((wValue & 0xff) < 4)\r\nurb->actual_length = rh_string(wValue & 0xff,\r\nhcd, ubuf, wLength);\r\nelse\r\ngoto error;\r\nbreak;\r\ncase USB_DT_BOS << 8:\r\ngoto nongeneric;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase DeviceRequest | USB_REQ_GET_INTERFACE:\r\ntbuf[0] = 0;\r\nlen = 1;\r\ncase DeviceOutRequest | USB_REQ_SET_INTERFACE:\r\nbreak;\r\ncase DeviceOutRequest | USB_REQ_SET_ADDRESS:\r\ndev_dbg (hcd->self.controller, "root hub device address %d\n",\r\nwValue);\r\nbreak;\r\ncase EndpointRequest | USB_REQ_GET_STATUS:\r\ntbuf[0] = 0;\r\ntbuf[1] = 0;\r\nlen = 2;\r\ncase EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\r\ncase EndpointOutRequest | USB_REQ_SET_FEATURE:\r\ndev_dbg (hcd->self.controller, "no endpoint features yet\n");\r\nbreak;\r\ndefault:\r\nnongeneric:\r\nswitch (typeReq) {\r\ncase GetHubStatus:\r\nlen = 4;\r\nbreak;\r\ncase GetPortStatus:\r\nif (wValue == HUB_PORT_STATUS)\r\nlen = 4;\r\nelse\r\nlen = 8;\r\nbreak;\r\ncase GetHubDescriptor:\r\nlen = sizeof (struct usb_hub_descriptor);\r\nbreak;\r\ncase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\r\nbreak;\r\n}\r\nstatus = hcd->driver->hub_control (hcd,\r\ntypeReq, wValue, wIndex,\r\ntbuf, wLength);\r\nif (typeReq == GetHubDescriptor)\r\nusb_hub_adjust_deviceremovable(hcd->self.root_hub,\r\n(struct usb_hub_descriptor *)tbuf);\r\nbreak;\r\nerror:\r\nstatus = -EPIPE;\r\n}\r\nif (status < 0) {\r\nlen = 0;\r\nif (status != -EPIPE) {\r\ndev_dbg (hcd->self.controller,\r\n"CTRL: TypeReq=0x%x val=0x%x "\r\n"idx=0x%x len=%d ==> %d\n",\r\ntypeReq, wValue, wIndex,\r\nwLength, status);\r\n}\r\n} else if (status > 0) {\r\nlen = status;\r\nstatus = 0;\r\n}\r\nif (len) {\r\nif (urb->transfer_buffer_length < len)\r\nlen = urb->transfer_buffer_length;\r\nurb->actual_length = len;\r\nmemcpy (ubuf, bufp, len);\r\nif (patch_wakeup &&\r\nlen > offsetof (struct usb_config_descriptor,\r\nbmAttributes))\r\n((struct usb_config_descriptor *)ubuf)->bmAttributes\r\n|= USB_CONFIG_ATT_WAKEUP;\r\nif (patch_protocol &&\r\nlen > offsetof(struct usb_device_descriptor,\r\nbDeviceProtocol))\r\n((struct usb_device_descriptor *) ubuf)->\r\nbDeviceProtocol = USB_HUB_PR_HS_SINGLE_TT;\r\n}\r\nkfree(tbuf);\r\nspin_lock_irq(&hcd_root_hub_lock);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nusb_hcd_giveback_urb(hcd, urb, status);\r\nspin_unlock_irq(&hcd_root_hub_lock);\r\nreturn 0;\r\n}\r\nvoid usb_hcd_poll_rh_status(struct usb_hcd *hcd)\r\n{\r\nstruct urb *urb;\r\nint length;\r\nunsigned long flags;\r\nchar buffer[6];\r\nif (unlikely(!hcd->rh_pollable))\r\nreturn;\r\nif (!hcd->uses_new_polling && !hcd->status_urb)\r\nreturn;\r\nlength = hcd->driver->hub_status_data(hcd, buffer);\r\nif (length > 0) {\r\nspin_lock_irqsave(&hcd_root_hub_lock, flags);\r\nurb = hcd->status_urb;\r\nif (urb) {\r\nclear_bit(HCD_FLAG_POLL_PENDING, &hcd->flags);\r\nhcd->status_urb = NULL;\r\nurb->actual_length = length;\r\nmemcpy(urb->transfer_buffer, buffer, length);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nusb_hcd_giveback_urb(hcd, urb, 0);\r\n} else {\r\nlength = 0;\r\nset_bit(HCD_FLAG_POLL_PENDING, &hcd->flags);\r\n}\r\nspin_unlock_irqrestore(&hcd_root_hub_lock, flags);\r\n}\r\nif (hcd->uses_new_polling ? HCD_POLL_RH(hcd) :\r\n(length == 0 && hcd->status_urb != NULL))\r\nmod_timer (&hcd->rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));\r\n}\r\nstatic void rh_timer_func (unsigned long _hcd)\r\n{\r\nusb_hcd_poll_rh_status((struct usb_hcd *) _hcd);\r\n}\r\nstatic int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nint retval;\r\nunsigned long flags;\r\nunsigned len = 1 + (urb->dev->maxchild / 8);\r\nspin_lock_irqsave (&hcd_root_hub_lock, flags);\r\nif (hcd->status_urb || urb->transfer_buffer_length < len) {\r\ndev_dbg (hcd->self.controller, "not queuing rh status urb\n");\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\nretval = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (retval)\r\ngoto done;\r\nhcd->status_urb = urb;\r\nurb->hcpriv = hcd;\r\nif (!hcd->uses_new_polling)\r\nmod_timer(&hcd->rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));\r\nelse if (HCD_POLL_PENDING(hcd))\r\nmod_timer(&hcd->rh_timer, jiffies);\r\nretval = 0;\r\ndone:\r\nspin_unlock_irqrestore (&hcd_root_hub_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nif (usb_endpoint_xfer_int(&urb->ep->desc))\r\nreturn rh_queue_status (hcd, urb);\r\nif (usb_endpoint_xfer_control(&urb->ep->desc))\r\nreturn rh_call_control (hcd, urb);\r\nreturn -EINVAL;\r\n}\r\nstatic int usb_rh_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&hcd_root_hub_lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc)\r\ngoto done;\r\nif (usb_endpoint_num(&urb->ep->desc) == 0) {\r\n;\r\n} else {\r\nif (!hcd->uses_new_polling)\r\ndel_timer (&hcd->rh_timer);\r\nif (urb == hcd->status_urb) {\r\nhcd->status_urb = NULL;\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nusb_hcd_giveback_urb(hcd, urb, status);\r\n}\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&hcd_root_hub_lock, flags);\r\nreturn rc;\r\n}\r\nstatic ssize_t authorized_default_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *rh_usb_dev = to_usb_device(dev);\r\nstruct usb_bus *usb_bus = rh_usb_dev->bus;\r\nstruct usb_hcd *hcd;\r\nhcd = bus_to_hcd(usb_bus);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", !!HCD_DEV_AUTHORIZED(hcd));\r\n}\r\nstatic ssize_t authorized_default_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nssize_t result;\r\nunsigned val;\r\nstruct usb_device *rh_usb_dev = to_usb_device(dev);\r\nstruct usb_bus *usb_bus = rh_usb_dev->bus;\r\nstruct usb_hcd *hcd;\r\nhcd = bus_to_hcd(usb_bus);\r\nresult = sscanf(buf, "%u\n", &val);\r\nif (result == 1) {\r\nif (val)\r\nset_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);\r\nelse\r\nclear_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);\r\nresult = size;\r\n} else {\r\nresult = -EINVAL;\r\n}\r\nreturn result;\r\n}\r\nstatic ssize_t interface_authorized_default_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *usb_dev = to_usb_device(dev);\r\nstruct usb_hcd *hcd = bus_to_hcd(usb_dev->bus);\r\nreturn sprintf(buf, "%u\n", !!HCD_INTF_AUTHORIZED(hcd));\r\n}\r\nstatic ssize_t interface_authorized_default_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct usb_device *usb_dev = to_usb_device(dev);\r\nstruct usb_hcd *hcd = bus_to_hcd(usb_dev->bus);\r\nint rc = count;\r\nbool val;\r\nif (strtobool(buf, &val) != 0)\r\nreturn -EINVAL;\r\nif (val)\r\nset_bit(HCD_FLAG_INTF_AUTHORIZED, &hcd->flags);\r\nelse\r\nclear_bit(HCD_FLAG_INTF_AUTHORIZED, &hcd->flags);\r\nreturn rc;\r\n}\r\nstatic void usb_bus_init (struct usb_bus *bus)\r\n{\r\nmemset (&bus->devmap, 0, sizeof(struct usb_devmap));\r\nbus->devnum_next = 1;\r\nbus->root_hub = NULL;\r\nbus->busnum = -1;\r\nbus->bandwidth_allocated = 0;\r\nbus->bandwidth_int_reqs = 0;\r\nbus->bandwidth_isoc_reqs = 0;\r\nmutex_init(&bus->devnum_next_mutex);\r\n}\r\nstatic int usb_register_bus(struct usb_bus *bus)\r\n{\r\nint result = -E2BIG;\r\nint busnum;\r\nmutex_lock(&usb_bus_idr_lock);\r\nbusnum = idr_alloc(&usb_bus_idr, bus, 1, USB_MAXBUS, GFP_KERNEL);\r\nif (busnum < 0) {\r\npr_err("%s: failed to get bus number\n", usbcore_name);\r\ngoto error_find_busnum;\r\n}\r\nbus->busnum = busnum;\r\nmutex_unlock(&usb_bus_idr_lock);\r\nusb_notify_add_bus(bus);\r\ndev_info (bus->controller, "new USB bus registered, assigned bus "\r\n"number %d\n", bus->busnum);\r\nreturn 0;\r\nerror_find_busnum:\r\nmutex_unlock(&usb_bus_idr_lock);\r\nreturn result;\r\n}\r\nstatic void usb_deregister_bus (struct usb_bus *bus)\r\n{\r\ndev_info (bus->controller, "USB bus %d deregistered\n", bus->busnum);\r\nmutex_lock(&usb_bus_idr_lock);\r\nidr_remove(&usb_bus_idr, bus->busnum);\r\nmutex_unlock(&usb_bus_idr_lock);\r\nusb_notify_remove_bus(bus);\r\n}\r\nstatic int register_root_hub(struct usb_hcd *hcd)\r\n{\r\nstruct device *parent_dev = hcd->self.controller;\r\nstruct usb_device *usb_dev = hcd->self.root_hub;\r\nconst int devnum = 1;\r\nint retval;\r\nusb_dev->devnum = devnum;\r\nusb_dev->bus->devnum_next = devnum + 1;\r\nmemset (&usb_dev->bus->devmap.devicemap, 0,\r\nsizeof usb_dev->bus->devmap.devicemap);\r\nset_bit (devnum, usb_dev->bus->devmap.devicemap);\r\nusb_set_device_state(usb_dev, USB_STATE_ADDRESS);\r\nmutex_lock(&usb_bus_idr_lock);\r\nusb_dev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\r\nretval = usb_get_device_descriptor(usb_dev, USB_DT_DEVICE_SIZE);\r\nif (retval != sizeof usb_dev->descriptor) {\r\nmutex_unlock(&usb_bus_idr_lock);\r\ndev_dbg (parent_dev, "can't read %s device descriptor %d\n",\r\ndev_name(&usb_dev->dev), retval);\r\nreturn (retval < 0) ? retval : -EMSGSIZE;\r\n}\r\nif (le16_to_cpu(usb_dev->descriptor.bcdUSB) >= 0x0201) {\r\nretval = usb_get_bos_descriptor(usb_dev);\r\nif (!retval) {\r\nusb_dev->lpm_capable = usb_device_supports_lpm(usb_dev);\r\n} else if (usb_dev->speed >= USB_SPEED_SUPER) {\r\nmutex_unlock(&usb_bus_idr_lock);\r\ndev_dbg(parent_dev, "can't read %s bos descriptor %d\n",\r\ndev_name(&usb_dev->dev), retval);\r\nreturn retval;\r\n}\r\n}\r\nretval = usb_new_device (usb_dev);\r\nif (retval) {\r\ndev_err (parent_dev, "can't register root hub for %s, %d\n",\r\ndev_name(&usb_dev->dev), retval);\r\n} else {\r\nspin_lock_irq (&hcd_root_hub_lock);\r\nhcd->rh_registered = 1;\r\nspin_unlock_irq (&hcd_root_hub_lock);\r\nif (HCD_DEAD(hcd))\r\nusb_hc_died (hcd);\r\nusb_dev->dev.of_node = parent_dev->of_node;\r\n}\r\nmutex_unlock(&usb_bus_idr_lock);\r\nreturn retval;\r\n}\r\nvoid usb_hcd_start_port_resume(struct usb_bus *bus, int portnum)\r\n{\r\nunsigned bit = 1 << portnum;\r\nif (!(bus->resuming_ports & bit)) {\r\nbus->resuming_ports |= bit;\r\npm_runtime_get_noresume(&bus->root_hub->dev);\r\n}\r\n}\r\nvoid usb_hcd_end_port_resume(struct usb_bus *bus, int portnum)\r\n{\r\nunsigned bit = 1 << portnum;\r\nif (bus->resuming_ports & bit) {\r\nbus->resuming_ports &= ~bit;\r\npm_runtime_put_noidle(&bus->root_hub->dev);\r\n}\r\n}\r\nlong usb_calc_bus_time (int speed, int is_input, int isoc, int bytecount)\r\n{\r\nunsigned long tmp;\r\nswitch (speed) {\r\ncase USB_SPEED_LOW:\r\nif (is_input) {\r\ntmp = (67667L * (31L + 10L * BitTime (bytecount))) / 1000L;\r\nreturn 64060L + (2 * BW_HUB_LS_SETUP) + BW_HOST_DELAY + tmp;\r\n} else {\r\ntmp = (66700L * (31L + 10L * BitTime (bytecount))) / 1000L;\r\nreturn 64107L + (2 * BW_HUB_LS_SETUP) + BW_HOST_DELAY + tmp;\r\n}\r\ncase USB_SPEED_FULL:\r\nif (isoc) {\r\ntmp = (8354L * (31L + 10L * BitTime (bytecount))) / 1000L;\r\nreturn ((is_input) ? 7268L : 6265L) + BW_HOST_DELAY + tmp;\r\n} else {\r\ntmp = (8354L * (31L + 10L * BitTime (bytecount))) / 1000L;\r\nreturn 9107L + BW_HOST_DELAY + tmp;\r\n}\r\ncase USB_SPEED_HIGH:\r\nif (isoc)\r\ntmp = HS_NSECS_ISO (bytecount);\r\nelse\r\ntmp = HS_NSECS (bytecount);\r\nreturn tmp;\r\ndefault:\r\npr_debug ("%s: bogus device speed!\n", usbcore_name);\r\nreturn -1;\r\n}\r\n}\r\nint usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nint rc = 0;\r\nspin_lock(&hcd_urb_list_lock);\r\nif (unlikely(atomic_read(&urb->reject))) {\r\nrc = -EPERM;\r\ngoto done;\r\n}\r\nif (unlikely(!urb->ep->enabled)) {\r\nrc = -ENOENT;\r\ngoto done;\r\n}\r\nif (unlikely(!urb->dev->can_submit)) {\r\nrc = -EHOSTUNREACH;\r\ngoto done;\r\n}\r\nif (HCD_RH_RUNNING(hcd)) {\r\nurb->unlinked = 0;\r\nlist_add_tail(&urb->urb_list, &urb->ep->urb_list);\r\n} else {\r\nrc = -ESHUTDOWN;\r\ngoto done;\r\n}\r\ndone:\r\nspin_unlock(&hcd_urb_list_lock);\r\nreturn rc;\r\n}\r\nint usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,\r\nint status)\r\n{\r\nstruct list_head *tmp;\r\nlist_for_each(tmp, &urb->ep->urb_list) {\r\nif (tmp == &urb->urb_list)\r\nbreak;\r\n}\r\nif (tmp != &urb->urb_list)\r\nreturn -EIDRM;\r\nif (urb->unlinked)\r\nreturn -EBUSY;\r\nurb->unlinked = status;\r\nreturn 0;\r\n}\r\nvoid usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nspin_lock(&hcd_urb_list_lock);\r\nlist_del_init(&urb->urb_list);\r\nspin_unlock(&hcd_urb_list_lock);\r\n}\r\nstatic int hcd_alloc_coherent(struct usb_bus *bus,\r\ngfp_t mem_flags, dma_addr_t *dma_handle,\r\nvoid **vaddr_handle, size_t size,\r\nenum dma_data_direction dir)\r\n{\r\nunsigned char *vaddr;\r\nif (*vaddr_handle == NULL) {\r\nWARN_ON_ONCE(1);\r\nreturn -EFAULT;\r\n}\r\nvaddr = hcd_buffer_alloc(bus, size + sizeof(vaddr),\r\nmem_flags, dma_handle);\r\nif (!vaddr)\r\nreturn -ENOMEM;\r\nput_unaligned((unsigned long)*vaddr_handle,\r\n(unsigned long *)(vaddr + size));\r\nif (dir == DMA_TO_DEVICE)\r\nmemcpy(vaddr, *vaddr_handle, size);\r\n*vaddr_handle = vaddr;\r\nreturn 0;\r\n}\r\nstatic void hcd_free_coherent(struct usb_bus *bus, dma_addr_t *dma_handle,\r\nvoid **vaddr_handle, size_t size,\r\nenum dma_data_direction dir)\r\n{\r\nunsigned char *vaddr = *vaddr_handle;\r\nvaddr = (void *)get_unaligned((unsigned long *)(vaddr + size));\r\nif (dir == DMA_FROM_DEVICE)\r\nmemcpy(vaddr, *vaddr_handle, size);\r\nhcd_buffer_free(bus, size + sizeof(vaddr), *vaddr_handle, *dma_handle);\r\n*vaddr_handle = vaddr;\r\n*dma_handle = 0;\r\n}\r\nvoid usb_hcd_unmap_urb_setup_for_dma(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nif (IS_ENABLED(CONFIG_HAS_DMA) &&\r\n(urb->transfer_flags & URB_SETUP_MAP_SINGLE))\r\ndma_unmap_single(hcd->self.controller,\r\nurb->setup_dma,\r\nsizeof(struct usb_ctrlrequest),\r\nDMA_TO_DEVICE);\r\nelse if (urb->transfer_flags & URB_SETUP_MAP_LOCAL)\r\nhcd_free_coherent(urb->dev->bus,\r\n&urb->setup_dma,\r\n(void **) &urb->setup_packet,\r\nsizeof(struct usb_ctrlrequest),\r\nDMA_TO_DEVICE);\r\nurb->transfer_flags &= ~(URB_SETUP_MAP_SINGLE | URB_SETUP_MAP_LOCAL);\r\n}\r\nstatic void unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nif (hcd->driver->unmap_urb_for_dma)\r\nhcd->driver->unmap_urb_for_dma(hcd, urb);\r\nelse\r\nusb_hcd_unmap_urb_for_dma(hcd, urb);\r\n}\r\nvoid usb_hcd_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nenum dma_data_direction dir;\r\nusb_hcd_unmap_urb_setup_for_dma(hcd, urb);\r\ndir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nif (IS_ENABLED(CONFIG_HAS_DMA) &&\r\n(urb->transfer_flags & URB_DMA_MAP_SG))\r\ndma_unmap_sg(hcd->self.controller,\r\nurb->sg,\r\nurb->num_sgs,\r\ndir);\r\nelse if (IS_ENABLED(CONFIG_HAS_DMA) &&\r\n(urb->transfer_flags & URB_DMA_MAP_PAGE))\r\ndma_unmap_page(hcd->self.controller,\r\nurb->transfer_dma,\r\nurb->transfer_buffer_length,\r\ndir);\r\nelse if (IS_ENABLED(CONFIG_HAS_DMA) &&\r\n(urb->transfer_flags & URB_DMA_MAP_SINGLE))\r\ndma_unmap_single(hcd->self.controller,\r\nurb->transfer_dma,\r\nurb->transfer_buffer_length,\r\ndir);\r\nelse if (urb->transfer_flags & URB_MAP_LOCAL)\r\nhcd_free_coherent(urb->dev->bus,\r\n&urb->transfer_dma,\r\n&urb->transfer_buffer,\r\nurb->transfer_buffer_length,\r\ndir);\r\nurb->transfer_flags &= ~(URB_DMA_MAP_SG | URB_DMA_MAP_PAGE |\r\nURB_DMA_MAP_SINGLE | URB_MAP_LOCAL);\r\n}\r\nstatic int map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nif (hcd->driver->map_urb_for_dma)\r\nreturn hcd->driver->map_urb_for_dma(hcd, urb, mem_flags);\r\nelse\r\nreturn usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\r\n}\r\nint usb_hcd_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nenum dma_data_direction dir;\r\nint ret = 0;\r\nif (usb_endpoint_xfer_control(&urb->ep->desc)) {\r\nif (hcd->self.uses_pio_for_control)\r\nreturn ret;\r\nif (IS_ENABLED(CONFIG_HAS_DMA) && hcd->self.uses_dma) {\r\nurb->setup_dma = dma_map_single(\r\nhcd->self.controller,\r\nurb->setup_packet,\r\nsizeof(struct usb_ctrlrequest),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(hcd->self.controller,\r\nurb->setup_dma))\r\nreturn -EAGAIN;\r\nurb->transfer_flags |= URB_SETUP_MAP_SINGLE;\r\n} else if (hcd->driver->flags & HCD_LOCAL_MEM) {\r\nret = hcd_alloc_coherent(\r\nurb->dev->bus, mem_flags,\r\n&urb->setup_dma,\r\n(void **)&urb->setup_packet,\r\nsizeof(struct usb_ctrlrequest),\r\nDMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\nurb->transfer_flags |= URB_SETUP_MAP_LOCAL;\r\n}\r\n}\r\ndir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nif (urb->transfer_buffer_length != 0\r\n&& !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)) {\r\nif (IS_ENABLED(CONFIG_HAS_DMA) && hcd->self.uses_dma) {\r\nif (urb->num_sgs) {\r\nint n;\r\nif (usb_endpoint_xfer_isoc(&urb->ep->desc)) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nn = dma_map_sg(\r\nhcd->self.controller,\r\nurb->sg,\r\nurb->num_sgs,\r\ndir);\r\nif (n <= 0)\r\nret = -EAGAIN;\r\nelse\r\nurb->transfer_flags |= URB_DMA_MAP_SG;\r\nurb->num_mapped_sgs = n;\r\nif (n != urb->num_sgs)\r\nurb->transfer_flags |=\r\nURB_DMA_SG_COMBINED;\r\n} else if (urb->sg) {\r\nstruct scatterlist *sg = urb->sg;\r\nurb->transfer_dma = dma_map_page(\r\nhcd->self.controller,\r\nsg_page(sg),\r\nsg->offset,\r\nurb->transfer_buffer_length,\r\ndir);\r\nif (dma_mapping_error(hcd->self.controller,\r\nurb->transfer_dma))\r\nret = -EAGAIN;\r\nelse\r\nurb->transfer_flags |= URB_DMA_MAP_PAGE;\r\n} else if (is_vmalloc_addr(urb->transfer_buffer)) {\r\nWARN_ONCE(1, "transfer buffer not dma capable\n");\r\nret = -EAGAIN;\r\n} else {\r\nurb->transfer_dma = dma_map_single(\r\nhcd->self.controller,\r\nurb->transfer_buffer,\r\nurb->transfer_buffer_length,\r\ndir);\r\nif (dma_mapping_error(hcd->self.controller,\r\nurb->transfer_dma))\r\nret = -EAGAIN;\r\nelse\r\nurb->transfer_flags |= URB_DMA_MAP_SINGLE;\r\n}\r\n} else if (hcd->driver->flags & HCD_LOCAL_MEM) {\r\nret = hcd_alloc_coherent(\r\nurb->dev->bus, mem_flags,\r\n&urb->transfer_dma,\r\n&urb->transfer_buffer,\r\nurb->transfer_buffer_length,\r\ndir);\r\nif (ret == 0)\r\nurb->transfer_flags |= URB_MAP_LOCAL;\r\n}\r\nif (ret && (urb->transfer_flags & (URB_SETUP_MAP_SINGLE |\r\nURB_SETUP_MAP_LOCAL)))\r\nusb_hcd_unmap_urb_for_dma(hcd, urb);\r\n}\r\nreturn ret;\r\n}\r\nint usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)\r\n{\r\nint status;\r\nstruct usb_hcd *hcd = bus_to_hcd(urb->dev->bus);\r\nusb_get_urb(urb);\r\natomic_inc(&urb->use_count);\r\natomic_inc(&urb->dev->urbnum);\r\nusbmon_urb_submit(&hcd->self, urb);\r\nif (is_root_hub(urb->dev)) {\r\nstatus = rh_urb_enqueue(hcd, urb);\r\n} else {\r\nstatus = map_urb_for_dma(hcd, urb, mem_flags);\r\nif (likely(status == 0)) {\r\nstatus = hcd->driver->urb_enqueue(hcd, urb, mem_flags);\r\nif (unlikely(status))\r\nunmap_urb_for_dma(hcd, urb);\r\n}\r\n}\r\nif (unlikely(status)) {\r\nusbmon_urb_submit_error(&hcd->self, urb, status);\r\nurb->hcpriv = NULL;\r\nINIT_LIST_HEAD(&urb->urb_list);\r\natomic_dec(&urb->use_count);\r\natomic_dec(&urb->dev->urbnum);\r\nif (atomic_read(&urb->reject))\r\nwake_up(&usb_kill_urb_queue);\r\nusb_put_urb(urb);\r\n}\r\nreturn status;\r\n}\r\nstatic int unlink1(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nint value;\r\nif (is_root_hub(urb->dev))\r\nvalue = usb_rh_urb_dequeue(hcd, urb, status);\r\nelse {\r\nvalue = hcd->driver->urb_dequeue(hcd, urb, status);\r\n}\r\nreturn value;\r\n}\r\nint usb_hcd_unlink_urb (struct urb *urb, int status)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct usb_device *udev = urb->dev;\r\nint retval = -EIDRM;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hcd_urb_unlink_lock, flags);\r\nif (atomic_read(&urb->use_count) > 0) {\r\nretval = 0;\r\nusb_get_dev(udev);\r\n}\r\nspin_unlock_irqrestore(&hcd_urb_unlink_lock, flags);\r\nif (retval == 0) {\r\nhcd = bus_to_hcd(urb->dev->bus);\r\nretval = unlink1(hcd, urb, status);\r\nif (retval == 0)\r\nretval = -EINPROGRESS;\r\nelse if (retval != -EIDRM && retval != -EBUSY)\r\ndev_dbg(&udev->dev, "hcd_unlink_urb %p fail %d\n",\r\nurb, retval);\r\nusb_put_dev(udev);\r\n}\r\nreturn retval;\r\n}\r\nstatic void __usb_hcd_giveback_urb(struct urb *urb)\r\n{\r\nstruct usb_hcd *hcd = bus_to_hcd(urb->dev->bus);\r\nstruct usb_anchor *anchor = urb->anchor;\r\nint status = urb->unlinked;\r\nunsigned long flags;\r\nurb->hcpriv = NULL;\r\nif (unlikely((urb->transfer_flags & URB_SHORT_NOT_OK) &&\r\nurb->actual_length < urb->transfer_buffer_length &&\r\n!status))\r\nstatus = -EREMOTEIO;\r\nunmap_urb_for_dma(hcd, urb);\r\nusbmon_urb_complete(&hcd->self, urb, status);\r\nusb_anchor_suspend_wakeups(anchor);\r\nusb_unanchor_urb(urb);\r\nif (likely(status == 0))\r\nusb_led_activity(USB_LED_EVENT_HOST);\r\nurb->status = status;\r\nlocal_irq_save(flags);\r\nurb->complete(urb);\r\nlocal_irq_restore(flags);\r\nusb_anchor_resume_wakeups(anchor);\r\natomic_dec(&urb->use_count);\r\nif (unlikely(atomic_read(&urb->reject)))\r\nwake_up(&usb_kill_urb_queue);\r\nusb_put_urb(urb);\r\n}\r\nstatic void usb_giveback_urb_bh(unsigned long param)\r\n{\r\nstruct giveback_urb_bh *bh = (struct giveback_urb_bh *)param;\r\nstruct list_head local_list;\r\nspin_lock_irq(&bh->lock);\r\nbh->running = true;\r\nrestart:\r\nlist_replace_init(&bh->head, &local_list);\r\nspin_unlock_irq(&bh->lock);\r\nwhile (!list_empty(&local_list)) {\r\nstruct urb *urb;\r\nurb = list_entry(local_list.next, struct urb, urb_list);\r\nlist_del_init(&urb->urb_list);\r\nbh->completing_ep = urb->ep;\r\n__usb_hcd_giveback_urb(urb);\r\nbh->completing_ep = NULL;\r\n}\r\nspin_lock_irq(&bh->lock);\r\nif (!list_empty(&bh->head))\r\ngoto restart;\r\nbh->running = false;\r\nspin_unlock_irq(&bh->lock);\r\n}\r\nvoid usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct giveback_urb_bh *bh;\r\nbool running, high_prio_bh;\r\nif (likely(!urb->unlinked))\r\nurb->unlinked = status;\r\nif (!hcd_giveback_urb_in_bh(hcd) && !is_root_hub(urb->dev)) {\r\n__usb_hcd_giveback_urb(urb);\r\nreturn;\r\n}\r\nif (usb_pipeisoc(urb->pipe) || usb_pipeint(urb->pipe)) {\r\nbh = &hcd->high_prio_bh;\r\nhigh_prio_bh = true;\r\n} else {\r\nbh = &hcd->low_prio_bh;\r\nhigh_prio_bh = false;\r\n}\r\nspin_lock(&bh->lock);\r\nlist_add_tail(&urb->urb_list, &bh->head);\r\nrunning = bh->running;\r\nspin_unlock(&bh->lock);\r\nif (running)\r\n;\r\nelse if (high_prio_bh)\r\ntasklet_hi_schedule(&bh->bh);\r\nelse\r\ntasklet_schedule(&bh->bh);\r\n}\r\nvoid usb_hcd_flush_endpoint(struct usb_device *udev,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct urb *urb;\r\nif (!ep)\r\nreturn;\r\nmight_sleep();\r\nhcd = bus_to_hcd(udev->bus);\r\nspin_lock_irq(&hcd_urb_list_lock);\r\nrescan:\r\nlist_for_each_entry (urb, &ep->urb_list, urb_list) {\r\nint is_in;\r\nif (urb->unlinked)\r\ncontinue;\r\nusb_get_urb (urb);\r\nis_in = usb_urb_dir_in(urb);\r\nspin_unlock(&hcd_urb_list_lock);\r\nunlink1(hcd, urb, -ESHUTDOWN);\r\ndev_dbg (hcd->self.controller,\r\n"shutdown urb %p ep%d%s%s\n",\r\nurb, usb_endpoint_num(&ep->desc),\r\nis_in ? "in" : "out",\r\n({ char *s;\r\nswitch (usb_endpoint_type(&ep->desc)) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ns = ""; break;\r\ncase USB_ENDPOINT_XFER_BULK:\r\ns = "-bulk"; break;\r\ncase USB_ENDPOINT_XFER_INT:\r\ns = "-intr"; break;\r\ndefault:\r\ns = "-iso"; break;\r\n};\r\ns;\r\n}));\r\nusb_put_urb (urb);\r\nspin_lock(&hcd_urb_list_lock);\r\ngoto rescan;\r\n}\r\nspin_unlock_irq(&hcd_urb_list_lock);\r\nwhile (!list_empty (&ep->urb_list)) {\r\nspin_lock_irq(&hcd_urb_list_lock);\r\nurb = NULL;\r\nif (!list_empty (&ep->urb_list)) {\r\nurb = list_entry (ep->urb_list.prev, struct urb,\r\nurb_list);\r\nusb_get_urb (urb);\r\n}\r\nspin_unlock_irq(&hcd_urb_list_lock);\r\nif (urb) {\r\nusb_kill_urb (urb);\r\nusb_put_urb (urb);\r\n}\r\n}\r\n}\r\nint usb_hcd_alloc_bandwidth(struct usb_device *udev,\r\nstruct usb_host_config *new_config,\r\nstruct usb_host_interface *cur_alt,\r\nstruct usb_host_interface *new_alt)\r\n{\r\nint num_intfs, i, j;\r\nstruct usb_host_interface *alt = NULL;\r\nint ret = 0;\r\nstruct usb_hcd *hcd;\r\nstruct usb_host_endpoint *ep;\r\nhcd = bus_to_hcd(udev->bus);\r\nif (!hcd->driver->check_bandwidth)\r\nreturn 0;\r\nif (!new_config && !cur_alt) {\r\nfor (i = 1; i < 16; ++i) {\r\nep = udev->ep_out[i];\r\nif (ep)\r\nhcd->driver->drop_endpoint(hcd, udev, ep);\r\nep = udev->ep_in[i];\r\nif (ep)\r\nhcd->driver->drop_endpoint(hcd, udev, ep);\r\n}\r\nhcd->driver->check_bandwidth(hcd, udev);\r\nreturn 0;\r\n}\r\nif (new_config) {\r\nnum_intfs = new_config->desc.bNumInterfaces;\r\nfor (i = 1; i < 16; ++i) {\r\nep = udev->ep_out[i];\r\nif (ep) {\r\nret = hcd->driver->drop_endpoint(hcd, udev, ep);\r\nif (ret < 0)\r\ngoto reset;\r\n}\r\nep = udev->ep_in[i];\r\nif (ep) {\r\nret = hcd->driver->drop_endpoint(hcd, udev, ep);\r\nif (ret < 0)\r\ngoto reset;\r\n}\r\n}\r\nfor (i = 0; i < num_intfs; ++i) {\r\nstruct usb_host_interface *first_alt;\r\nint iface_num;\r\nfirst_alt = &new_config->intf_cache[i]->altsetting[0];\r\niface_num = first_alt->desc.bInterfaceNumber;\r\nalt = usb_find_alt_setting(new_config, iface_num, 0);\r\nif (!alt)\r\nalt = first_alt;\r\nfor (j = 0; j < alt->desc.bNumEndpoints; j++) {\r\nret = hcd->driver->add_endpoint(hcd, udev, &alt->endpoint[j]);\r\nif (ret < 0)\r\ngoto reset;\r\n}\r\n}\r\n}\r\nif (cur_alt && new_alt) {\r\nstruct usb_interface *iface = usb_ifnum_to_if(udev,\r\ncur_alt->desc.bInterfaceNumber);\r\nif (!iface)\r\nreturn -EINVAL;\r\nif (iface->resetting_device) {\r\ncur_alt = usb_altnum_to_altsetting(iface, 0);\r\nif (!cur_alt)\r\ncur_alt = &iface->altsetting[0];\r\n}\r\nfor (i = 0; i < cur_alt->desc.bNumEndpoints; i++) {\r\nret = hcd->driver->drop_endpoint(hcd, udev,\r\n&cur_alt->endpoint[i]);\r\nif (ret < 0)\r\ngoto reset;\r\n}\r\nfor (i = 0; i < new_alt->desc.bNumEndpoints; i++) {\r\nret = hcd->driver->add_endpoint(hcd, udev,\r\n&new_alt->endpoint[i]);\r\nif (ret < 0)\r\ngoto reset;\r\n}\r\n}\r\nret = hcd->driver->check_bandwidth(hcd, udev);\r\nreset:\r\nif (ret < 0)\r\nhcd->driver->reset_bandwidth(hcd, udev);\r\nreturn ret;\r\n}\r\nvoid usb_hcd_disable_endpoint(struct usb_device *udev,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct usb_hcd *hcd;\r\nmight_sleep();\r\nhcd = bus_to_hcd(udev->bus);\r\nif (hcd->driver->endpoint_disable)\r\nhcd->driver->endpoint_disable(hcd, ep);\r\n}\r\nvoid usb_hcd_reset_endpoint(struct usb_device *udev,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\r\nif (hcd->driver->endpoint_reset)\r\nhcd->driver->endpoint_reset(hcd, ep);\r\nelse {\r\nint epnum = usb_endpoint_num(&ep->desc);\r\nint is_out = usb_endpoint_dir_out(&ep->desc);\r\nint is_control = usb_endpoint_xfer_control(&ep->desc);\r\nusb_settoggle(udev, epnum, is_out, 0);\r\nif (is_control)\r\nusb_settoggle(udev, epnum, !is_out, 0);\r\n}\r\n}\r\nint usb_alloc_streams(struct usb_interface *interface,\r\nstruct usb_host_endpoint **eps, unsigned int num_eps,\r\nunsigned int num_streams, gfp_t mem_flags)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct usb_device *dev;\r\nint i, ret;\r\ndev = interface_to_usbdev(interface);\r\nhcd = bus_to_hcd(dev->bus);\r\nif (!hcd->driver->alloc_streams || !hcd->driver->free_streams)\r\nreturn -EINVAL;\r\nif (dev->speed < USB_SPEED_SUPER)\r\nreturn -EINVAL;\r\nif (dev->state < USB_STATE_CONFIGURED)\r\nreturn -ENODEV;\r\nfor (i = 0; i < num_eps; i++) {\r\nif (!usb_endpoint_xfer_bulk(&eps[i]->desc))\r\nreturn -EINVAL;\r\nif (eps[i]->streams)\r\nreturn -EINVAL;\r\n}\r\nret = hcd->driver->alloc_streams(hcd, dev, eps, num_eps,\r\nnum_streams, mem_flags);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < num_eps; i++)\r\neps[i]->streams = ret;\r\nreturn ret;\r\n}\r\nint usb_free_streams(struct usb_interface *interface,\r\nstruct usb_host_endpoint **eps, unsigned int num_eps,\r\ngfp_t mem_flags)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct usb_device *dev;\r\nint i, ret;\r\ndev = interface_to_usbdev(interface);\r\nhcd = bus_to_hcd(dev->bus);\r\nif (dev->speed < USB_SPEED_SUPER)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_eps; i++)\r\nif (!eps[i] || !eps[i]->streams)\r\nreturn -EINVAL;\r\nret = hcd->driver->free_streams(hcd, dev, eps, num_eps, mem_flags);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < num_eps; i++)\r\neps[i]->streams = 0;\r\nreturn ret;\r\n}\r\nvoid usb_hcd_synchronize_unlinks(struct usb_device *udev)\r\n{\r\nspin_lock_irq(&hcd_urb_unlink_lock);\r\nspin_unlock_irq(&hcd_urb_unlink_lock);\r\n}\r\nint usb_hcd_get_frame_number (struct usb_device *udev)\r\n{\r\nstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\r\nif (!HCD_RH_RUNNING(hcd))\r\nreturn -ESHUTDOWN;\r\nreturn hcd->driver->get_frame_number (hcd);\r\n}\r\nint hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)\r\n{\r\nstruct usb_hcd *hcd = bus_to_hcd(rhdev->bus);\r\nint status;\r\nint old_state = hcd->state;\r\ndev_dbg(&rhdev->dev, "bus %ssuspend, wakeup %d\n",\r\n(PMSG_IS_AUTO(msg) ? "auto-" : ""),\r\nrhdev->do_remote_wakeup);\r\nif (HCD_DEAD(hcd)) {\r\ndev_dbg(&rhdev->dev, "skipped %s of dead bus\n", "suspend");\r\nreturn 0;\r\n}\r\nif (!hcd->driver->bus_suspend) {\r\nstatus = -ENOENT;\r\n} else {\r\nclear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\r\nhcd->state = HC_STATE_QUIESCING;\r\nstatus = hcd->driver->bus_suspend(hcd);\r\n}\r\nif (status == 0) {\r\nusb_set_device_state(rhdev, USB_STATE_SUSPENDED);\r\nhcd->state = HC_STATE_SUSPENDED;\r\nif (rhdev->do_remote_wakeup) {\r\nchar buffer[6];\r\nstatus = hcd->driver->hub_status_data(hcd, buffer);\r\nif (status != 0) {\r\ndev_dbg(&rhdev->dev, "suspend raced with wakeup event\n");\r\nhcd_bus_resume(rhdev, PMSG_AUTO_RESUME);\r\nstatus = -EBUSY;\r\n}\r\n}\r\n} else {\r\nspin_lock_irq(&hcd_root_hub_lock);\r\nif (!HCD_DEAD(hcd)) {\r\nset_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\r\nhcd->state = old_state;\r\n}\r\nspin_unlock_irq(&hcd_root_hub_lock);\r\ndev_dbg(&rhdev->dev, "bus %s fail, err %d\n",\r\n"suspend", status);\r\n}\r\nreturn status;\r\n}\r\nint hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)\r\n{\r\nstruct usb_hcd *hcd = bus_to_hcd(rhdev->bus);\r\nint status;\r\nint old_state = hcd->state;\r\ndev_dbg(&rhdev->dev, "usb %sresume\n",\r\n(PMSG_IS_AUTO(msg) ? "auto-" : ""));\r\nif (HCD_DEAD(hcd)) {\r\ndev_dbg(&rhdev->dev, "skipped %s of dead bus\n", "resume");\r\nreturn 0;\r\n}\r\nif (!hcd->driver->bus_resume)\r\nreturn -ENOENT;\r\nif (HCD_RH_RUNNING(hcd))\r\nreturn 0;\r\nhcd->state = HC_STATE_RESUMING;\r\nstatus = hcd->driver->bus_resume(hcd);\r\nclear_bit(HCD_FLAG_WAKEUP_PENDING, &hcd->flags);\r\nif (status == 0) {\r\nstruct usb_device *udev;\r\nint port1;\r\nspin_lock_irq(&hcd_root_hub_lock);\r\nif (!HCD_DEAD(hcd)) {\r\nusb_set_device_state(rhdev, rhdev->actconfig\r\n? USB_STATE_CONFIGURED\r\n: USB_STATE_ADDRESS);\r\nset_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\r\nhcd->state = HC_STATE_RUNNING;\r\n}\r\nspin_unlock_irq(&hcd_root_hub_lock);\r\nusb_hub_for_each_child(rhdev, port1, udev) {\r\nif (udev->state != USB_STATE_NOTATTACHED &&\r\n!udev->port_is_suspended) {\r\nusleep_range(10000, 11000);\r\nbreak;\r\n}\r\n}\r\n} else {\r\nhcd->state = old_state;\r\ndev_dbg(&rhdev->dev, "bus %s fail, err %d\n",\r\n"resume", status);\r\nif (status != -ESHUTDOWN)\r\nusb_hc_died(hcd);\r\n}\r\nreturn status;\r\n}\r\nstatic void hcd_resume_work(struct work_struct *work)\r\n{\r\nstruct usb_hcd *hcd = container_of(work, struct usb_hcd, wakeup_work);\r\nstruct usb_device *udev = hcd->self.root_hub;\r\nusb_remote_wakeup(udev);\r\n}\r\nvoid usb_hcd_resume_root_hub (struct usb_hcd *hcd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave (&hcd_root_hub_lock, flags);\r\nif (hcd->rh_registered) {\r\nset_bit(HCD_FLAG_WAKEUP_PENDING, &hcd->flags);\r\nqueue_work(pm_wq, &hcd->wakeup_work);\r\n}\r\nspin_unlock_irqrestore (&hcd_root_hub_lock, flags);\r\n}\r\nint usb_bus_start_enum(struct usb_bus *bus, unsigned port_num)\r\n{\r\nstruct usb_hcd *hcd;\r\nint status = -EOPNOTSUPP;\r\nhcd = bus_to_hcd(bus);\r\nif (port_num && hcd->driver->start_port_reset)\r\nstatus = hcd->driver->start_port_reset(hcd, port_num);\r\nif (status == 0)\r\nmod_timer(&hcd->rh_timer, jiffies + msecs_to_jiffies(10));\r\nreturn status;\r\n}\r\nirqreturn_t usb_hcd_irq (int irq, void *__hcd)\r\n{\r\nstruct usb_hcd *hcd = __hcd;\r\nirqreturn_t rc;\r\nif (unlikely(HCD_DEAD(hcd) || !HCD_HW_ACCESSIBLE(hcd)))\r\nrc = IRQ_NONE;\r\nelse if (hcd->driver->irq(hcd) == IRQ_NONE)\r\nrc = IRQ_NONE;\r\nelse\r\nrc = IRQ_HANDLED;\r\nreturn rc;\r\n}\r\nvoid usb_hc_died (struct usb_hcd *hcd)\r\n{\r\nunsigned long flags;\r\ndev_err (hcd->self.controller, "HC died; cleaning up\n");\r\nspin_lock_irqsave (&hcd_root_hub_lock, flags);\r\nclear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\r\nset_bit(HCD_FLAG_DEAD, &hcd->flags);\r\nif (hcd->rh_registered) {\r\nclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nusb_set_device_state (hcd->self.root_hub,\r\nUSB_STATE_NOTATTACHED);\r\nusb_kick_hub_wq(hcd->self.root_hub);\r\n}\r\nif (usb_hcd_is_primary_hcd(hcd) && hcd->shared_hcd) {\r\nhcd = hcd->shared_hcd;\r\nif (hcd->rh_registered) {\r\nclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nusb_set_device_state(hcd->self.root_hub,\r\nUSB_STATE_NOTATTACHED);\r\nusb_kick_hub_wq(hcd->self.root_hub);\r\n}\r\n}\r\nspin_unlock_irqrestore (&hcd_root_hub_lock, flags);\r\n}\r\nstatic void init_giveback_urb_bh(struct giveback_urb_bh *bh)\r\n{\r\nspin_lock_init(&bh->lock);\r\nINIT_LIST_HEAD(&bh->head);\r\ntasklet_init(&bh->bh, usb_giveback_urb_bh, (unsigned long)bh);\r\n}\r\nstruct usb_hcd *usb_create_shared_hcd(const struct hc_driver *driver,\r\nstruct device *dev, const char *bus_name,\r\nstruct usb_hcd *primary_hcd)\r\n{\r\nstruct usb_hcd *hcd;\r\nhcd = kzalloc(sizeof(*hcd) + driver->hcd_priv_size, GFP_KERNEL);\r\nif (!hcd) {\r\ndev_dbg (dev, "hcd alloc failed\n");\r\nreturn NULL;\r\n}\r\nif (primary_hcd == NULL) {\r\nhcd->address0_mutex = kmalloc(sizeof(*hcd->address0_mutex),\r\nGFP_KERNEL);\r\nif (!hcd->address0_mutex) {\r\nkfree(hcd);\r\ndev_dbg(dev, "hcd address0 mutex alloc failed\n");\r\nreturn NULL;\r\n}\r\nmutex_init(hcd->address0_mutex);\r\nhcd->bandwidth_mutex = kmalloc(sizeof(*hcd->bandwidth_mutex),\r\nGFP_KERNEL);\r\nif (!hcd->bandwidth_mutex) {\r\nkfree(hcd);\r\ndev_dbg(dev, "hcd bandwidth mutex alloc failed\n");\r\nreturn NULL;\r\n}\r\nmutex_init(hcd->bandwidth_mutex);\r\ndev_set_drvdata(dev, hcd);\r\n} else {\r\nmutex_lock(&usb_port_peer_mutex);\r\nhcd->address0_mutex = primary_hcd->address0_mutex;\r\nhcd->bandwidth_mutex = primary_hcd->bandwidth_mutex;\r\nhcd->primary_hcd = primary_hcd;\r\nprimary_hcd->primary_hcd = primary_hcd;\r\nhcd->shared_hcd = primary_hcd;\r\nprimary_hcd->shared_hcd = hcd;\r\nmutex_unlock(&usb_port_peer_mutex);\r\n}\r\nkref_init(&hcd->kref);\r\nusb_bus_init(&hcd->self);\r\nhcd->self.controller = dev;\r\nhcd->self.bus_name = bus_name;\r\nhcd->self.uses_dma = (dev->dma_mask != NULL);\r\ninit_timer(&hcd->rh_timer);\r\nhcd->rh_timer.function = rh_timer_func;\r\nhcd->rh_timer.data = (unsigned long) hcd;\r\n#ifdef CONFIG_PM\r\nINIT_WORK(&hcd->wakeup_work, hcd_resume_work);\r\n#endif\r\nhcd->driver = driver;\r\nhcd->speed = driver->flags & HCD_MASK;\r\nhcd->product_desc = (driver->product_desc) ? driver->product_desc :\r\n"USB Host Controller";\r\nreturn hcd;\r\n}\r\nstruct usb_hcd *usb_create_hcd(const struct hc_driver *driver,\r\nstruct device *dev, const char *bus_name)\r\n{\r\nreturn usb_create_shared_hcd(driver, dev, bus_name, NULL);\r\n}\r\nstatic void hcd_release(struct kref *kref)\r\n{\r\nstruct usb_hcd *hcd = container_of (kref, struct usb_hcd, kref);\r\nmutex_lock(&usb_port_peer_mutex);\r\nif (hcd->shared_hcd) {\r\nstruct usb_hcd *peer = hcd->shared_hcd;\r\npeer->shared_hcd = NULL;\r\npeer->primary_hcd = NULL;\r\n} else {\r\nkfree(hcd->address0_mutex);\r\nkfree(hcd->bandwidth_mutex);\r\n}\r\nmutex_unlock(&usb_port_peer_mutex);\r\nkfree(hcd);\r\n}\r\nstruct usb_hcd *usb_get_hcd (struct usb_hcd *hcd)\r\n{\r\nif (hcd)\r\nkref_get (&hcd->kref);\r\nreturn hcd;\r\n}\r\nvoid usb_put_hcd (struct usb_hcd *hcd)\r\n{\r\nif (hcd)\r\nkref_put (&hcd->kref, hcd_release);\r\n}\r\nint usb_hcd_is_primary_hcd(struct usb_hcd *hcd)\r\n{\r\nif (!hcd->primary_hcd)\r\nreturn 1;\r\nreturn hcd == hcd->primary_hcd;\r\n}\r\nint usb_hcd_find_raw_port_number(struct usb_hcd *hcd, int port1)\r\n{\r\nif (!hcd->driver->find_raw_port_number)\r\nreturn port1;\r\nreturn hcd->driver->find_raw_port_number(hcd, port1);\r\n}\r\nstatic int usb_hcd_request_irqs(struct usb_hcd *hcd,\r\nunsigned int irqnum, unsigned long irqflags)\r\n{\r\nint retval;\r\nif (hcd->driver->irq) {\r\nsnprintf(hcd->irq_descr, sizeof(hcd->irq_descr), "%s:usb%d",\r\nhcd->driver->description, hcd->self.busnum);\r\nretval = request_irq(irqnum, &usb_hcd_irq, irqflags,\r\nhcd->irq_descr, hcd);\r\nif (retval != 0) {\r\ndev_err(hcd->self.controller,\r\n"request interrupt %d failed\n",\r\nirqnum);\r\nreturn retval;\r\n}\r\nhcd->irq = irqnum;\r\ndev_info(hcd->self.controller, "irq %d, %s 0x%08llx\n", irqnum,\r\n(hcd->driver->flags & HCD_MEMORY) ?\r\n"io mem" : "io base",\r\n(unsigned long long)hcd->rsrc_start);\r\n} else {\r\nhcd->irq = 0;\r\nif (hcd->rsrc_start)\r\ndev_info(hcd->self.controller, "%s 0x%08llx\n",\r\n(hcd->driver->flags & HCD_MEMORY) ?\r\n"io mem" : "io base",\r\n(unsigned long long)hcd->rsrc_start);\r\n}\r\nreturn 0;\r\n}\r\nstatic void usb_put_invalidate_rhdev(struct usb_hcd *hcd)\r\n{\r\nstruct usb_device *rhdev;\r\nmutex_lock(&usb_port_peer_mutex);\r\nrhdev = hcd->self.root_hub;\r\nhcd->self.root_hub = NULL;\r\nmutex_unlock(&usb_port_peer_mutex);\r\nusb_put_dev(rhdev);\r\n}\r\nint usb_add_hcd(struct usb_hcd *hcd,\r\nunsigned int irqnum, unsigned long irqflags)\r\n{\r\nint retval;\r\nstruct usb_device *rhdev;\r\nif (IS_ENABLED(CONFIG_USB_PHY) && !hcd->usb_phy) {\r\nstruct usb_phy *phy = usb_get_phy_dev(hcd->self.controller, 0);\r\nif (IS_ERR(phy)) {\r\nretval = PTR_ERR(phy);\r\nif (retval == -EPROBE_DEFER)\r\nreturn retval;\r\n} else {\r\nretval = usb_phy_init(phy);\r\nif (retval) {\r\nusb_put_phy(phy);\r\nreturn retval;\r\n}\r\nhcd->usb_phy = phy;\r\nhcd->remove_phy = 1;\r\n}\r\n}\r\nif (IS_ENABLED(CONFIG_GENERIC_PHY) && !hcd->phy) {\r\nstruct phy *phy = phy_get(hcd->self.controller, "usb");\r\nif (IS_ERR(phy)) {\r\nretval = PTR_ERR(phy);\r\nif (retval == -EPROBE_DEFER)\r\ngoto err_phy;\r\n} else {\r\nretval = phy_init(phy);\r\nif (retval) {\r\nphy_put(phy);\r\ngoto err_phy;\r\n}\r\nretval = phy_power_on(phy);\r\nif (retval) {\r\nphy_exit(phy);\r\nphy_put(phy);\r\ngoto err_phy;\r\n}\r\nhcd->phy = phy;\r\nhcd->remove_phy = 1;\r\n}\r\n}\r\ndev_info(hcd->self.controller, "%s\n", hcd->product_desc);\r\nif (authorized_default < 0 || authorized_default > 1) {\r\nif (hcd->wireless)\r\nclear_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);\r\nelse\r\nset_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);\r\n} else {\r\nif (authorized_default)\r\nset_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);\r\nelse\r\nclear_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);\r\n}\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nset_bit(HCD_FLAG_INTF_AUTHORIZED, &hcd->flags);\r\nretval = hcd_buffer_create(hcd);\r\nif (retval != 0) {\r\ndev_dbg(hcd->self.controller, "pool alloc failed\n");\r\ngoto err_create_buf;\r\n}\r\nretval = usb_register_bus(&hcd->self);\r\nif (retval < 0)\r\ngoto err_register_bus;\r\nrhdev = usb_alloc_dev(NULL, &hcd->self, 0);\r\nif (rhdev == NULL) {\r\ndev_err(hcd->self.controller, "unable to allocate root hub\n");\r\nretval = -ENOMEM;\r\ngoto err_allocate_root_hub;\r\n}\r\nmutex_lock(&usb_port_peer_mutex);\r\nhcd->self.root_hub = rhdev;\r\nmutex_unlock(&usb_port_peer_mutex);\r\nswitch (hcd->speed) {\r\ncase HCD_USB11:\r\nrhdev->speed = USB_SPEED_FULL;\r\nbreak;\r\ncase HCD_USB2:\r\nrhdev->speed = USB_SPEED_HIGH;\r\nbreak;\r\ncase HCD_USB25:\r\nrhdev->speed = USB_SPEED_WIRELESS;\r\nbreak;\r\ncase HCD_USB3:\r\nrhdev->speed = USB_SPEED_SUPER;\r\nbreak;\r\ncase HCD_USB31:\r\nrhdev->speed = USB_SPEED_SUPER_PLUS;\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\ngoto err_set_rh_speed;\r\n}\r\ndevice_set_wakeup_capable(&rhdev->dev, 1);\r\nset_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\r\nif (hcd->driver->reset) {\r\nretval = hcd->driver->reset(hcd);\r\nif (retval < 0) {\r\ndev_err(hcd->self.controller, "can't setup: %d\n",\r\nretval);\r\ngoto err_hcd_driver_setup;\r\n}\r\n}\r\nhcd->rh_pollable = 1;\r\nif (device_can_wakeup(hcd->self.controller)\r\n&& device_can_wakeup(&hcd->self.root_hub->dev))\r\ndev_dbg(hcd->self.controller, "supports USB remote wakeup\n");\r\ninit_giveback_urb_bh(&hcd->high_prio_bh);\r\ninit_giveback_urb_bh(&hcd->low_prio_bh);\r\nif (usb_hcd_is_primary_hcd(hcd) && irqnum) {\r\nretval = usb_hcd_request_irqs(hcd, irqnum, irqflags);\r\nif (retval)\r\ngoto err_request_irq;\r\n}\r\nhcd->state = HC_STATE_RUNNING;\r\nretval = hcd->driver->start(hcd);\r\nif (retval < 0) {\r\ndev_err(hcd->self.controller, "startup error %d\n", retval);\r\ngoto err_hcd_driver_start;\r\n}\r\nretval = register_root_hub(hcd);\r\nif (retval != 0)\r\ngoto err_register_root_hub;\r\nretval = sysfs_create_group(&rhdev->dev.kobj, &usb_bus_attr_group);\r\nif (retval < 0) {\r\nprintk(KERN_ERR "Cannot register USB bus sysfs attributes: %d\n",\r\nretval);\r\ngoto error_create_attr_group;\r\n}\r\nif (hcd->uses_new_polling && HCD_POLL_RH(hcd))\r\nusb_hcd_poll_rh_status(hcd);\r\nreturn retval;\r\nerror_create_attr_group:\r\nclear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\r\nif (HC_IS_RUNNING(hcd->state))\r\nhcd->state = HC_STATE_QUIESCING;\r\nspin_lock_irq(&hcd_root_hub_lock);\r\nhcd->rh_registered = 0;\r\nspin_unlock_irq(&hcd_root_hub_lock);\r\n#ifdef CONFIG_PM\r\ncancel_work_sync(&hcd->wakeup_work);\r\n#endif\r\nmutex_lock(&usb_bus_idr_lock);\r\nusb_disconnect(&rhdev);\r\nmutex_unlock(&usb_bus_idr_lock);\r\nerr_register_root_hub:\r\nhcd->rh_pollable = 0;\r\nclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\ndel_timer_sync(&hcd->rh_timer);\r\nhcd->driver->stop(hcd);\r\nhcd->state = HC_STATE_HALT;\r\nclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\ndel_timer_sync(&hcd->rh_timer);\r\nerr_hcd_driver_start:\r\nif (usb_hcd_is_primary_hcd(hcd) && hcd->irq > 0)\r\nfree_irq(irqnum, hcd);\r\nerr_request_irq:\r\nerr_hcd_driver_setup:\r\nerr_set_rh_speed:\r\nusb_put_invalidate_rhdev(hcd);\r\nerr_allocate_root_hub:\r\nusb_deregister_bus(&hcd->self);\r\nerr_register_bus:\r\nhcd_buffer_destroy(hcd);\r\nerr_create_buf:\r\nif (IS_ENABLED(CONFIG_GENERIC_PHY) && hcd->remove_phy && hcd->phy) {\r\nphy_power_off(hcd->phy);\r\nphy_exit(hcd->phy);\r\nphy_put(hcd->phy);\r\nhcd->phy = NULL;\r\n}\r\nerr_phy:\r\nif (hcd->remove_phy && hcd->usb_phy) {\r\nusb_phy_shutdown(hcd->usb_phy);\r\nusb_put_phy(hcd->usb_phy);\r\nhcd->usb_phy = NULL;\r\n}\r\nreturn retval;\r\n}\r\nvoid usb_remove_hcd(struct usb_hcd *hcd)\r\n{\r\nstruct usb_device *rhdev = hcd->self.root_hub;\r\ndev_info(hcd->self.controller, "remove, state %x\n", hcd->state);\r\nusb_get_dev(rhdev);\r\nsysfs_remove_group(&rhdev->dev.kobj, &usb_bus_attr_group);\r\nclear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\r\nif (HC_IS_RUNNING (hcd->state))\r\nhcd->state = HC_STATE_QUIESCING;\r\ndev_dbg(hcd->self.controller, "roothub graceful disconnect\n");\r\nspin_lock_irq (&hcd_root_hub_lock);\r\nhcd->rh_registered = 0;\r\nspin_unlock_irq (&hcd_root_hub_lock);\r\n#ifdef CONFIG_PM\r\ncancel_work_sync(&hcd->wakeup_work);\r\n#endif\r\nmutex_lock(&usb_bus_idr_lock);\r\nusb_disconnect(&rhdev);\r\nmutex_unlock(&usb_bus_idr_lock);\r\nhcd->rh_pollable = 0;\r\nclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\ndel_timer_sync(&hcd->rh_timer);\r\nhcd->driver->stop(hcd);\r\nhcd->state = HC_STATE_HALT;\r\nclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\ndel_timer_sync(&hcd->rh_timer);\r\nif (usb_hcd_is_primary_hcd(hcd)) {\r\nif (hcd->irq > 0)\r\nfree_irq(hcd->irq, hcd);\r\n}\r\nusb_deregister_bus(&hcd->self);\r\nhcd_buffer_destroy(hcd);\r\nif (IS_ENABLED(CONFIG_GENERIC_PHY) && hcd->remove_phy && hcd->phy) {\r\nphy_power_off(hcd->phy);\r\nphy_exit(hcd->phy);\r\nphy_put(hcd->phy);\r\nhcd->phy = NULL;\r\n}\r\nif (hcd->remove_phy && hcd->usb_phy) {\r\nusb_phy_shutdown(hcd->usb_phy);\r\nusb_put_phy(hcd->usb_phy);\r\nhcd->usb_phy = NULL;\r\n}\r\nusb_put_invalidate_rhdev(hcd);\r\n}\r\nvoid\r\nusb_hcd_platform_shutdown(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nif (hcd->driver->shutdown)\r\nhcd->driver->shutdown(hcd);\r\n}\r\nint usb_mon_register(const struct usb_mon_operations *ops)\r\n{\r\nif (mon_ops)\r\nreturn -EBUSY;\r\nmon_ops = ops;\r\nmb();\r\nreturn 0;\r\n}\r\nvoid usb_mon_deregister (void)\r\n{\r\nif (mon_ops == NULL) {\r\nprintk(KERN_ERR "USB: monitor was not registered\n");\r\nreturn;\r\n}\r\nmon_ops = NULL;\r\nmb();\r\n}
