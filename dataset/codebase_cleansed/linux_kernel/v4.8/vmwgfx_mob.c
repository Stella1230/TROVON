static int vmw_setup_otable_base(struct vmw_private *dev_priv,\r\nSVGAOTableType type,\r\nstruct ttm_buffer_object *otable_bo,\r\nunsigned long offset,\r\nstruct vmw_otable *otable)\r\n{\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdSetOTableBase64 body;\r\n} *cmd;\r\nstruct vmw_mob *mob;\r\nconst struct vmw_sg_table *vsgt;\r\nstruct vmw_piter iter;\r\nint ret;\r\nBUG_ON(otable->page_table != NULL);\r\nvsgt = vmw_bo_sg_table(otable_bo);\r\nvmw_piter_start(&iter, vsgt, offset >> PAGE_SHIFT);\r\nWARN_ON(!vmw_piter_next(&iter));\r\nmob = vmw_mob_create(otable->size >> PAGE_SHIFT);\r\nif (unlikely(mob == NULL)) {\r\nDRM_ERROR("Failed creating OTable page table.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (otable->size <= PAGE_SIZE) {\r\nmob->pt_level = VMW_MOBFMT_PTDEPTH_0;\r\nmob->pt_root_page = vmw_piter_dma_addr(&iter);\r\n} else if (vsgt->num_regions == 1) {\r\nmob->pt_level = SVGA3D_MOBFMT_RANGE;\r\nmob->pt_root_page = vmw_piter_dma_addr(&iter);\r\n} else {\r\nret = vmw_mob_pt_populate(dev_priv, mob);\r\nif (unlikely(ret != 0))\r\ngoto out_no_populate;\r\nvmw_mob_pt_setup(mob, iter, otable->size >> PAGE_SHIFT);\r\nmob->pt_level += VMW_MOBFMT_PTDEPTH_1 - SVGA3D_MOBFMT_PTDEPTH_1;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for OTable setup.\n");\r\nret = -ENOMEM;\r\ngoto out_no_fifo;\r\n}\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->header.id = SVGA_3D_CMD_SET_OTABLE_BASE64;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.type = type;\r\ncmd->body.baseAddress = mob->pt_root_page >> PAGE_SHIFT;\r\ncmd->body.sizeInBytes = otable->size;\r\ncmd->body.validSizeInBytes = 0;\r\ncmd->body.ptDepth = mob->pt_level;\r\nBUG_ON(mob->pt_level == VMW_MOBFMT_PTDEPTH_2);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\notable->page_table = mob;\r\nreturn 0;\r\nout_no_fifo:\r\nout_no_populate:\r\nvmw_mob_destroy(mob);\r\nreturn ret;\r\n}\r\nstatic void vmw_takedown_otable_base(struct vmw_private *dev_priv,\r\nSVGAOTableType type,\r\nstruct vmw_otable *otable)\r\n{\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdSetOTableBase body;\r\n} *cmd;\r\nstruct ttm_buffer_object *bo;\r\nif (otable->page_table == NULL)\r\nreturn;\r\nbo = otable->page_table->pt_bo;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for OTable "\r\n"takedown.\n");\r\nreturn;\r\n}\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->header.id = SVGA_3D_CMD_SET_OTABLE_BASE;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.type = type;\r\ncmd->body.baseAddress = 0;\r\ncmd->body.sizeInBytes = 0;\r\ncmd->body.validSizeInBytes = 0;\r\ncmd->body.ptDepth = SVGA3D_MOBFMT_INVALID;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nif (bo) {\r\nint ret;\r\nret = ttm_bo_reserve(bo, false, true, NULL);\r\nBUG_ON(ret != 0);\r\nvmw_fence_single_bo(bo, NULL);\r\nttm_bo_unreserve(bo);\r\n}\r\nvmw_mob_destroy(otable->page_table);\r\notable->page_table = NULL;\r\n}\r\nstatic int vmw_otable_batch_setup(struct vmw_private *dev_priv,\r\nstruct vmw_otable_batch *batch)\r\n{\r\nunsigned long offset;\r\nunsigned long bo_size;\r\nstruct vmw_otable *otables = batch->otables;\r\nSVGAOTableType i;\r\nint ret;\r\nbo_size = 0;\r\nfor (i = 0; i < batch->num_otables; ++i) {\r\nif (!otables[i].enabled)\r\ncontinue;\r\notables[i].size =\r\n(otables[i].size + PAGE_SIZE - 1) & PAGE_MASK;\r\nbo_size += otables[i].size;\r\n}\r\nret = ttm_bo_create(&dev_priv->bdev, bo_size,\r\nttm_bo_type_device,\r\n&vmw_sys_ne_placement,\r\n0, false, NULL,\r\n&batch->otable_bo);\r\nif (unlikely(ret != 0))\r\ngoto out_no_bo;\r\nret = ttm_bo_reserve(batch->otable_bo, false, true, NULL);\r\nBUG_ON(ret != 0);\r\nret = vmw_bo_driver.ttm_tt_populate(batch->otable_bo->ttm);\r\nif (unlikely(ret != 0))\r\ngoto out_unreserve;\r\nret = vmw_bo_map_dma(batch->otable_bo);\r\nif (unlikely(ret != 0))\r\ngoto out_unreserve;\r\nttm_bo_unreserve(batch->otable_bo);\r\noffset = 0;\r\nfor (i = 0; i < batch->num_otables; ++i) {\r\nif (!batch->otables[i].enabled)\r\ncontinue;\r\nret = vmw_setup_otable_base(dev_priv, i, batch->otable_bo,\r\noffset,\r\n&otables[i]);\r\nif (unlikely(ret != 0))\r\ngoto out_no_setup;\r\noffset += otables[i].size;\r\n}\r\nreturn 0;\r\nout_unreserve:\r\nttm_bo_unreserve(batch->otable_bo);\r\nout_no_setup:\r\nfor (i = 0; i < batch->num_otables; ++i) {\r\nif (batch->otables[i].enabled)\r\nvmw_takedown_otable_base(dev_priv, i,\r\n&batch->otables[i]);\r\n}\r\nttm_bo_unref(&batch->otable_bo);\r\nout_no_bo:\r\nreturn ret;\r\n}\r\nint vmw_otables_setup(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_otable **otables = &dev_priv->otable_batch.otables;\r\nint ret;\r\nif (dev_priv->has_dx) {\r\n*otables = kmalloc(sizeof(dx_tables), GFP_KERNEL);\r\nif (*otables == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(*otables, dx_tables, sizeof(dx_tables));\r\ndev_priv->otable_batch.num_otables = ARRAY_SIZE(dx_tables);\r\n} else {\r\n*otables = kmalloc(sizeof(pre_dx_tables), GFP_KERNEL);\r\nif (*otables == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(*otables, pre_dx_tables, sizeof(pre_dx_tables));\r\ndev_priv->otable_batch.num_otables = ARRAY_SIZE(pre_dx_tables);\r\n}\r\nret = vmw_otable_batch_setup(dev_priv, &dev_priv->otable_batch);\r\nif (unlikely(ret != 0))\r\ngoto out_setup;\r\nreturn 0;\r\nout_setup:\r\nkfree(*otables);\r\nreturn ret;\r\n}\r\nstatic void vmw_otable_batch_takedown(struct vmw_private *dev_priv,\r\nstruct vmw_otable_batch *batch)\r\n{\r\nSVGAOTableType i;\r\nstruct ttm_buffer_object *bo = batch->otable_bo;\r\nint ret;\r\nfor (i = 0; i < batch->num_otables; ++i)\r\nif (batch->otables[i].enabled)\r\nvmw_takedown_otable_base(dev_priv, i,\r\n&batch->otables[i]);\r\nret = ttm_bo_reserve(bo, false, true, NULL);\r\nBUG_ON(ret != 0);\r\nvmw_fence_single_bo(bo, NULL);\r\nttm_bo_unreserve(bo);\r\nttm_bo_unref(&batch->otable_bo);\r\n}\r\nvoid vmw_otables_takedown(struct vmw_private *dev_priv)\r\n{\r\nvmw_otable_batch_takedown(dev_priv, &dev_priv->otable_batch);\r\nkfree(dev_priv->otable_batch.otables);\r\n}\r\nstatic unsigned long vmw_mob_calculate_pt_pages(unsigned long data_pages)\r\n{\r\nunsigned long data_size = data_pages * PAGE_SIZE;\r\nunsigned long tot_size = 0;\r\nwhile (likely(data_size > PAGE_SIZE)) {\r\ndata_size = DIV_ROUND_UP(data_size, PAGE_SIZE);\r\ndata_size *= VMW_PPN_SIZE;\r\ntot_size += (data_size + PAGE_SIZE - 1) & PAGE_MASK;\r\n}\r\nreturn tot_size >> PAGE_SHIFT;\r\n}\r\nstruct vmw_mob *vmw_mob_create(unsigned long data_pages)\r\n{\r\nstruct vmw_mob *mob = kzalloc(sizeof(*mob), GFP_KERNEL);\r\nif (unlikely(mob == NULL))\r\nreturn NULL;\r\nmob->num_pages = vmw_mob_calculate_pt_pages(data_pages);\r\nreturn mob;\r\n}\r\nstatic int vmw_mob_pt_populate(struct vmw_private *dev_priv,\r\nstruct vmw_mob *mob)\r\n{\r\nint ret;\r\nBUG_ON(mob->pt_bo != NULL);\r\nret = ttm_bo_create(&dev_priv->bdev, mob->num_pages * PAGE_SIZE,\r\nttm_bo_type_device,\r\n&vmw_sys_ne_placement,\r\n0, false, NULL, &mob->pt_bo);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = ttm_bo_reserve(mob->pt_bo, false, true, NULL);\r\nBUG_ON(ret != 0);\r\nret = vmw_bo_driver.ttm_tt_populate(mob->pt_bo->ttm);\r\nif (unlikely(ret != 0))\r\ngoto out_unreserve;\r\nret = vmw_bo_map_dma(mob->pt_bo);\r\nif (unlikely(ret != 0))\r\ngoto out_unreserve;\r\nttm_bo_unreserve(mob->pt_bo);\r\nreturn 0;\r\nout_unreserve:\r\nttm_bo_unreserve(mob->pt_bo);\r\nttm_bo_unref(&mob->pt_bo);\r\nreturn ret;\r\n}\r\nstatic void vmw_mob_assign_ppn(u32 **addr, dma_addr_t val)\r\n{\r\n*((u64 *) *addr) = val >> PAGE_SHIFT;\r\n*addr += 2;\r\n}\r\nstatic void vmw_mob_assign_ppn(u32 **addr, dma_addr_t val)\r\n{\r\n*(*addr)++ = val >> PAGE_SHIFT;\r\n}\r\nstatic unsigned long vmw_mob_build_pt(struct vmw_piter *data_iter,\r\nunsigned long num_data_pages,\r\nstruct vmw_piter *pt_iter)\r\n{\r\nunsigned long pt_size = num_data_pages * VMW_PPN_SIZE;\r\nunsigned long num_pt_pages = DIV_ROUND_UP(pt_size, PAGE_SIZE);\r\nunsigned long pt_page;\r\nu32 *addr, *save_addr;\r\nunsigned long i;\r\nstruct page *page;\r\nfor (pt_page = 0; pt_page < num_pt_pages; ++pt_page) {\r\npage = vmw_piter_page(pt_iter);\r\nsave_addr = addr = kmap_atomic(page);\r\nfor (i = 0; i < PAGE_SIZE / VMW_PPN_SIZE; ++i) {\r\nvmw_mob_assign_ppn(&addr,\r\nvmw_piter_dma_addr(data_iter));\r\nif (unlikely(--num_data_pages == 0))\r\nbreak;\r\nWARN_ON(!vmw_piter_next(data_iter));\r\n}\r\nkunmap_atomic(save_addr);\r\nvmw_piter_next(pt_iter);\r\n}\r\nreturn num_pt_pages;\r\n}\r\nstatic void vmw_mob_pt_setup(struct vmw_mob *mob,\r\nstruct vmw_piter data_iter,\r\nunsigned long num_data_pages)\r\n{\r\nunsigned long num_pt_pages = 0;\r\nstruct ttm_buffer_object *bo = mob->pt_bo;\r\nstruct vmw_piter save_pt_iter;\r\nstruct vmw_piter pt_iter;\r\nconst struct vmw_sg_table *vsgt;\r\nint ret;\r\nret = ttm_bo_reserve(bo, false, true, NULL);\r\nBUG_ON(ret != 0);\r\nvsgt = vmw_bo_sg_table(bo);\r\nvmw_piter_start(&pt_iter, vsgt, 0);\r\nBUG_ON(!vmw_piter_next(&pt_iter));\r\nmob->pt_level = 0;\r\nwhile (likely(num_data_pages > 1)) {\r\n++mob->pt_level;\r\nBUG_ON(mob->pt_level > 2);\r\nsave_pt_iter = pt_iter;\r\nnum_pt_pages = vmw_mob_build_pt(&data_iter, num_data_pages,\r\n&pt_iter);\r\ndata_iter = save_pt_iter;\r\nnum_data_pages = num_pt_pages;\r\n}\r\nmob->pt_root_page = vmw_piter_dma_addr(&save_pt_iter);\r\nttm_bo_unreserve(bo);\r\n}\r\nvoid vmw_mob_destroy(struct vmw_mob *mob)\r\n{\r\nif (mob->pt_bo)\r\nttm_bo_unref(&mob->pt_bo);\r\nkfree(mob);\r\n}\r\nvoid vmw_mob_unbind(struct vmw_private *dev_priv,\r\nstruct vmw_mob *mob)\r\n{\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyGBMob body;\r\n} *cmd;\r\nint ret;\r\nstruct ttm_buffer_object *bo = mob->pt_bo;\r\nif (bo) {\r\nret = ttm_bo_reserve(bo, false, true, NULL);\r\nBUG_ON(ret != 0);\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for Memory "\r\n"Object unbinding.\n");\r\n} else {\r\ncmd->header.id = SVGA_3D_CMD_DESTROY_GB_MOB;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.mobid = mob->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n}\r\nif (bo) {\r\nvmw_fence_single_bo(bo, NULL);\r\nttm_bo_unreserve(bo);\r\n}\r\nvmw_fifo_resource_dec(dev_priv);\r\n}\r\nint vmw_mob_bind(struct vmw_private *dev_priv,\r\nstruct vmw_mob *mob,\r\nconst struct vmw_sg_table *vsgt,\r\nunsigned long num_data_pages,\r\nint32_t mob_id)\r\n{\r\nint ret;\r\nbool pt_set_up = false;\r\nstruct vmw_piter data_iter;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineGBMob64 body;\r\n} *cmd;\r\nmob->id = mob_id;\r\nvmw_piter_start(&data_iter, vsgt, 0);\r\nif (unlikely(!vmw_piter_next(&data_iter)))\r\nreturn 0;\r\nif (likely(num_data_pages == 1)) {\r\nmob->pt_level = VMW_MOBFMT_PTDEPTH_0;\r\nmob->pt_root_page = vmw_piter_dma_addr(&data_iter);\r\n} else if (vsgt->num_regions == 1) {\r\nmob->pt_level = SVGA3D_MOBFMT_RANGE;\r\nmob->pt_root_page = vmw_piter_dma_addr(&data_iter);\r\n} else if (unlikely(mob->pt_bo == NULL)) {\r\nret = vmw_mob_pt_populate(dev_priv, mob);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nvmw_mob_pt_setup(mob, data_iter, num_data_pages);\r\npt_set_up = true;\r\nmob->pt_level += VMW_MOBFMT_PTDEPTH_1 - SVGA3D_MOBFMT_PTDEPTH_1;\r\n}\r\nvmw_fifo_resource_inc(dev_priv);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for Memory "\r\n"Object binding.\n");\r\ngoto out_no_cmd_space;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DEFINE_GB_MOB64;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.mobid = mob_id;\r\ncmd->body.ptDepth = mob->pt_level;\r\ncmd->body.base = mob->pt_root_page >> PAGE_SHIFT;\r\ncmd->body.sizeInBytes = num_data_pages * PAGE_SIZE;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\nout_no_cmd_space:\r\nvmw_fifo_resource_dec(dev_priv);\r\nif (pt_set_up)\r\nttm_bo_unref(&mob->pt_bo);\r\nreturn -ENOMEM;\r\n}
