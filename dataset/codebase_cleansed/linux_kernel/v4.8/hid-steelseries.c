static void steelseries_srws1_set_leds(struct hid_device *hdev, __u16 leds)\r\n{\r\nstruct list_head *report_list = &hdev->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\n__s32 *value = report->field[0]->value;\r\nvalue[0] = 0x40;\r\nvalue[1] = leds & 0xFF;\r\nvalue[2] = leds >> 8;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nvalue[7] = 0x00;\r\nvalue[8] = 0x00;\r\nvalue[9] = 0x00;\r\nvalue[10] = 0x00;\r\nvalue[11] = 0x00;\r\nvalue[12] = 0x00;\r\nvalue[13] = 0x00;\r\nvalue[14] = 0x00;\r\nvalue[15] = 0x00;\r\nhid_hw_request(hdev, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic void steelseries_srws1_led_all_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct steelseries_srws1_data *drv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Device data not found.");\r\nreturn;\r\n}\r\nif (value == LED_OFF)\r\ndrv_data->led_state = 0;\r\nelse\r\ndrv_data->led_state = (1 << (SRWS1_NUMBER_LEDS + 1)) - 1;\r\nsteelseries_srws1_set_leds(hid, drv_data->led_state);\r\n}\r\nstatic enum led_brightness steelseries_srws1_led_all_get_brightness(struct led_classdev *led_cdev)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct steelseries_srws1_data *drv_data;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Device data not found.");\r\nreturn LED_OFF;\r\n}\r\nreturn (drv_data->led_state >> SRWS1_NUMBER_LEDS) ? LED_FULL : LED_OFF;\r\n}\r\nstatic void steelseries_srws1_led_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct steelseries_srws1_data *drv_data = hid_get_drvdata(hid);\r\nint i, state = 0;\r\nif (!drv_data) {\r\nhid_err(hid, "Device data not found.");\r\nreturn;\r\n}\r\nfor (i = 0; i < SRWS1_NUMBER_LEDS; i++) {\r\nif (led_cdev != drv_data->led[i])\r\ncontinue;\r\nstate = (drv_data->led_state >> i) & 1;\r\nif (value == LED_OFF && state) {\r\ndrv_data->led_state &= ~(1 << i);\r\nsteelseries_srws1_set_leds(hid, drv_data->led_state);\r\n} else if (value != LED_OFF && !state) {\r\ndrv_data->led_state |= 1 << i;\r\nsteelseries_srws1_set_leds(hid, drv_data->led_state);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic enum led_brightness steelseries_srws1_led_get_brightness(struct led_classdev *led_cdev)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct steelseries_srws1_data *drv_data;\r\nint i, value = 0;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Device data not found.");\r\nreturn LED_OFF;\r\n}\r\nfor (i = 0; i < SRWS1_NUMBER_LEDS; i++)\r\nif (led_cdev == drv_data->led[i]) {\r\nvalue = (drv_data->led_state >> i) & 1;\r\nbreak;\r\n}\r\nreturn value ? LED_FULL : LED_OFF;\r\n}\r\nstatic int steelseries_srws1_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nint ret, i;\r\nstruct led_classdev *led;\r\nsize_t name_sz;\r\nchar *name;\r\nstruct steelseries_srws1_data *drv_data = kzalloc(sizeof(*drv_data), GFP_KERNEL);\r\nif (drv_data == NULL) {\r\nhid_err(hdev, "can't alloc SRW-S1 memory\n");\r\nreturn -ENOMEM;\r\n}\r\nhid_set_drvdata(hdev, drv_data);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto err_free;\r\n}\r\nif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 16)) {\r\nret = -ENODEV;\r\ngoto err_free;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto err_free;\r\n}\r\ndrv_data->led_state = 0;\r\nfor (i = 0; i < SRWS1_NUMBER_LEDS + 1; i++)\r\ndrv_data->led[i] = NULL;\r\nsteelseries_srws1_set_leds(hdev, 0);\r\nname_sz = strlen(hdev->uniq) + 16;\r\nled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\r\nif (!led) {\r\nhid_err(hdev, "can't allocate memory for LED ALL\n");\r\ngoto err_led;\r\n}\r\nname = (void *)(&led[1]);\r\nsnprintf(name, name_sz, "SRWS1::%s::RPMALL", hdev->uniq);\r\nled->name = name;\r\nled->brightness = 0;\r\nled->max_brightness = 1;\r\nled->brightness_get = steelseries_srws1_led_all_get_brightness;\r\nled->brightness_set = steelseries_srws1_led_all_set_brightness;\r\ndrv_data->led[SRWS1_NUMBER_LEDS] = led;\r\nret = led_classdev_register(&hdev->dev, led);\r\nif (ret)\r\ngoto err_led;\r\nfor (i = 0; i < SRWS1_NUMBER_LEDS; i++) {\r\nled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\r\nif (!led) {\r\nhid_err(hdev, "can't allocate memory for LED %d\n", i);\r\ngoto err_led;\r\n}\r\nname = (void *)(&led[1]);\r\nsnprintf(name, name_sz, "SRWS1::%s::RPM%d", hdev->uniq, i+1);\r\nled->name = name;\r\nled->brightness = 0;\r\nled->max_brightness = 1;\r\nled->brightness_get = steelseries_srws1_led_get_brightness;\r\nled->brightness_set = steelseries_srws1_led_set_brightness;\r\ndrv_data->led[i] = led;\r\nret = led_classdev_register(&hdev->dev, led);\r\nif (ret) {\r\nhid_err(hdev, "failed to register LED %d. Aborting.\n", i);\r\nerr_led:\r\nfor (i = 0; i < SRWS1_NUMBER_LEDS + 1; i++) {\r\nled = drv_data->led[i];\r\ndrv_data->led[i] = NULL;\r\nif (!led)\r\ncontinue;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn 0;\r\nerr_free:\r\nkfree(drv_data);\r\nreturn ret;\r\n}\r\nstatic void steelseries_srws1_remove(struct hid_device *hdev)\r\n{\r\nint i;\r\nstruct led_classdev *led;\r\nstruct steelseries_srws1_data *drv_data = hid_get_drvdata(hdev);\r\nif (drv_data) {\r\nfor (i = 0; i < SRWS1_NUMBER_LEDS + 1; i++) {\r\nled = drv_data->led[i];\r\ndrv_data->led[i] = NULL;\r\nif (!led)\r\ncontinue;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\n}\r\nhid_hw_stop(hdev);\r\nkfree(drv_data);\r\nreturn;\r\n}\r\nstatic __u8 *steelseries_srws1_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nif (*rsize >= 115 && rdesc[11] == 0x02 && rdesc[13] == 0xc8\r\n&& rdesc[29] == 0xbb && rdesc[40] == 0xc5) {\r\nhid_info(hdev, "Fixing up Steelseries SRW-S1 report descriptor\n");\r\nrdesc = steelseries_srws1_rdesc_fixed;\r\n*rsize = sizeof(steelseries_srws1_rdesc_fixed);\r\n}\r\nreturn rdesc;\r\n}
