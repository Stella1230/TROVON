static inline unsigned int GI_PRESCALE_X2(enum ni_gpct_variant variant)\r\n{\r\nswitch (variant) {\r\ncase ni_gpct_variant_e_series:\r\ndefault:\r\nreturn 0;\r\ncase ni_gpct_variant_m_series:\r\nreturn GI_M_PRESCALE_X2;\r\ncase ni_gpct_variant_660x:\r\nreturn GI_660X_PRESCALE_X2;\r\n}\r\n}\r\nstatic inline unsigned int GI_PRESCALE_X8(enum ni_gpct_variant variant)\r\n{\r\nswitch (variant) {\r\ncase ni_gpct_variant_e_series:\r\ndefault:\r\nreturn 0;\r\ncase ni_gpct_variant_m_series:\r\nreturn GI_M_PRESCALE_X8;\r\ncase ni_gpct_variant_660x:\r\nreturn GI_660X_PRESCALE_X8;\r\n}\r\n}\r\nstatic bool ni_tio_has_gate2_registers(const struct ni_gpct_device *counter_dev)\r\n{\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ndefault:\r\nreturn false;\r\ncase ni_gpct_variant_m_series:\r\ncase ni_gpct_variant_660x:\r\nreturn true;\r\n}\r\n}\r\nvoid ni_tio_write(struct ni_gpct *counter, unsigned int value,\r\nenum ni_gpct_register reg)\r\n{\r\nif (reg < NITIO_NUM_REGS)\r\ncounter->counter_dev->write(counter, value, reg);\r\n}\r\nunsigned int ni_tio_read(struct ni_gpct *counter, enum ni_gpct_register reg)\r\n{\r\nif (reg < NITIO_NUM_REGS)\r\nreturn counter->counter_dev->read(counter, reg);\r\nreturn 0;\r\n}\r\nstatic void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)\r\n{\r\nunsigned int cidx = counter->counter_index;\r\nni_tio_write(counter, GI_RESET(cidx), NITIO_RESET_REG(cidx));\r\n}\r\nstatic int ni_tio_clock_period_ps(const struct ni_gpct *counter,\r\nunsigned int generic_clock_source,\r\nu64 *period_ps)\r\n{\r\nu64 clock_period_ps;\r\nswitch (generic_clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {\r\ncase NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:\r\nclock_period_ps = 50000;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:\r\nclock_period_ps = 10000000;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\r\nclock_period_ps = 12500;\r\nbreak;\r\ncase NI_GPCT_PXI10_CLOCK_SRC_BITS:\r\nclock_period_ps = 100000;\r\nbreak;\r\ndefault:\r\nreturn counter->clock_period_ps;\r\n}\r\nswitch (generic_clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {\r\ncase NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:\r\nbreak;\r\ncase NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:\r\nclock_period_ps *= 2;\r\nbreak;\r\ncase NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:\r\nclock_period_ps *= 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*period_ps = clock_period_ps;\r\nreturn 0;\r\n}\r\nstatic void ni_tio_set_bits_transient(struct ni_gpct *counter,\r\nenum ni_gpct_register reg,\r\nunsigned int mask, unsigned int value,\r\nunsigned int transient)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned long flags;\r\nif (reg < NITIO_NUM_REGS) {\r\nspin_lock_irqsave(&counter_dev->regs_lock, flags);\r\ncounter_dev->regs[reg] &= ~mask;\r\ncounter_dev->regs[reg] |= (value & mask);\r\nni_tio_write(counter, counter_dev->regs[reg] | transient, reg);\r\nmmiowb();\r\nspin_unlock_irqrestore(&counter_dev->regs_lock, flags);\r\n}\r\n}\r\nvoid ni_tio_set_bits(struct ni_gpct *counter, enum ni_gpct_register reg,\r\nunsigned int mask, unsigned int value)\r\n{\r\nni_tio_set_bits_transient(counter, reg, mask, value, 0x0);\r\n}\r\nunsigned int ni_tio_get_soft_copy(const struct ni_gpct *counter,\r\nenum ni_gpct_register reg)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int value = 0;\r\nunsigned long flags;\r\nif (reg < NITIO_NUM_REGS) {\r\nspin_lock_irqsave(&counter_dev->regs_lock, flags);\r\nvalue = counter_dev->regs[reg];\r\nspin_unlock_irqrestore(&counter_dev->regs_lock, flags);\r\n}\r\nreturn value;\r\n}\r\nstatic unsigned int ni_tio_clock_src_modifiers(const struct ni_gpct *counter)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int counting_mode_bits =\r\nni_tio_get_soft_copy(counter, NITIO_CNT_MODE_REG(cidx));\r\nunsigned int bits = 0;\r\nif (ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &\r\nGI_SRC_POL_INVERT)\r\nbits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;\r\nif (counting_mode_bits & GI_PRESCALE_X2(counter_dev->variant))\r\nbits |= NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS;\r\nif (counting_mode_bits & GI_PRESCALE_X8(counter_dev->variant))\r\nbits |= NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS;\r\nreturn bits;\r\n}\r\nstatic int ni_m_series_clock_src_select(const struct ni_gpct *counter,\r\nunsigned int *clk_src)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int second_gate_reg = NITIO_GATE2_REG(cidx);\r\nunsigned int clock_source = 0;\r\nunsigned int src;\r\nunsigned int i;\r\nsrc = GI_BITS_TO_SRC(ni_tio_get_soft_copy(counter,\r\nNITIO_INPUT_SEL_REG(cidx)));\r\nswitch (src) {\r\ncase NI_M_TIMEBASE_1_CLK:\r\nclock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_TIMEBASE_2_CLK:\r\nclock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_TIMEBASE_3_CLK:\r\nif (counter_dev->regs[second_gate_reg] & GI_SRC_SUBSEL)\r\nclock_source =\r\nNI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;\r\nelse\r\nclock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_LOGIC_LOW_CLK:\r\nclock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_NEXT_GATE_CLK:\r\nif (counter_dev->regs[second_gate_reg] & GI_SRC_SUBSEL)\r\nclock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;\r\nelse\r\nclock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_PXI10_CLK:\r\nclock_source = NI_GPCT_PXI10_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_NEXT_TC_CLK:\r\nclock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {\r\nif (src == NI_M_RTSI_CLK(i)) {\r\nclock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_M_MAX_RTSI_CHAN)\r\nbreak;\r\nfor (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {\r\nif (src == NI_M_PFI_CLK(i)) {\r\nclock_source = NI_GPCT_PFI_CLOCK_SRC_BITS(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_M_MAX_PFI_CHAN)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\nclock_source |= ni_tio_clock_src_modifiers(counter);\r\n*clk_src = clock_source;\r\nreturn 0;\r\n}\r\nstatic int ni_660x_clock_src_select(const struct ni_gpct *counter,\r\nunsigned int *clk_src)\r\n{\r\nunsigned int clock_source = 0;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int src;\r\nunsigned int i;\r\nsrc = GI_BITS_TO_SRC(ni_tio_get_soft_copy(counter,\r\nNITIO_INPUT_SEL_REG(cidx)));\r\nswitch (src) {\r\ncase NI_660X_TIMEBASE_1_CLK:\r\nclock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660X_TIMEBASE_2_CLK:\r\nclock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660X_TIMEBASE_3_CLK:\r\nclock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660X_LOGIC_LOW_CLK:\r\nclock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660X_SRC_PIN_I_CLK:\r\nclock_source = NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660X_NEXT_GATE_CLK:\r\nclock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660X_NEXT_TC_CLK:\r\nclock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\r\nif (src == NI_660X_RTSI_CLK(i)) {\r\nclock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_RTSI_CHAN)\r\nbreak;\r\nfor (i = 0; i <= NI_660X_MAX_SRC_PIN; ++i) {\r\nif (src == NI_660X_SRC_PIN_CLK(i)) {\r\nclock_source =\r\nNI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_SRC_PIN)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\nclock_source |= ni_tio_clock_src_modifiers(counter);\r\n*clk_src = clock_source;\r\nreturn 0;\r\n}\r\nstatic int ni_tio_generic_clock_src_select(const struct ni_gpct *counter,\r\nunsigned int *clk_src)\r\n{\r\nswitch (counter->counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ncase ni_gpct_variant_m_series:\r\ndefault:\r\nreturn ni_m_series_clock_src_select(counter, clk_src);\r\ncase ni_gpct_variant_660x:\r\nreturn ni_660x_clock_src_select(counter, clk_src);\r\n}\r\n}\r\nstatic void ni_tio_set_sync_mode(struct ni_gpct *counter)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nstatic const u64 min_normal_sync_period_ps = 25000;\r\nunsigned int mask = 0;\r\nunsigned int bits = 0;\r\nunsigned int reg;\r\nunsigned int mode;\r\nunsigned int clk_src;\r\nu64 ps;\r\nbool force_alt_sync;\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ndefault:\r\nreturn;\r\ncase ni_gpct_variant_m_series:\r\nmask = GI_M_ALT_SYNC;\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nmask = GI_660X_ALT_SYNC;\r\nbreak;\r\n}\r\nreg = NITIO_CNT_MODE_REG(cidx);\r\nmode = ni_tio_get_soft_copy(counter, reg);\r\nswitch (mode & GI_CNT_MODE_MASK) {\r\ncase GI_CNT_MODE_QUADX1:\r\ncase GI_CNT_MODE_QUADX2:\r\ncase GI_CNT_MODE_QUADX4:\r\ncase GI_CNT_MODE_SYNC_SRC:\r\nforce_alt_sync = true;\r\nbreak;\r\ndefault:\r\nforce_alt_sync = false;\r\nbreak;\r\n}\r\nni_tio_generic_clock_src_select(counter, &clk_src);\r\nni_tio_clock_period_ps(counter, clk_src, &ps);\r\nif (force_alt_sync || (ps && ps < min_normal_sync_period_ps))\r\nbits = mask;\r\nni_tio_set_bits(counter, reg, mask, bits);\r\n}\r\nstatic int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned int mode)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int mode_reg_mask;\r\nunsigned int mode_reg_values;\r\nunsigned int input_select_bits = 0;\r\nstatic const unsigned int mode_reg_direct_mask =\r\nNI_GPCT_GATE_ON_BOTH_EDGES_BIT | NI_GPCT_EDGE_GATE_MODE_MASK |\r\nNI_GPCT_STOP_MODE_MASK | NI_GPCT_OUTPUT_MODE_MASK |\r\nNI_GPCT_HARDWARE_DISARM_MASK | NI_GPCT_LOADING_ON_TC_BIT |\r\nNI_GPCT_LOADING_ON_GATE_BIT | NI_GPCT_LOAD_B_SELECT_BIT;\r\nmode_reg_mask = mode_reg_direct_mask | GI_RELOAD_SRC_SWITCHING;\r\nmode_reg_values = mode & mode_reg_direct_mask;\r\nswitch (mode & NI_GPCT_RELOAD_SOURCE_MASK) {\r\ncase NI_GPCT_RELOAD_SOURCE_FIXED_BITS:\r\nbreak;\r\ncase NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS:\r\nmode_reg_values |= GI_RELOAD_SRC_SWITCHING;\r\nbreak;\r\ncase NI_GPCT_RELOAD_SOURCE_GATE_SELECT_BITS:\r\ninput_select_bits |= GI_GATE_SEL_LOAD_SRC;\r\nmode_reg_mask |= GI_GATING_MODE_MASK;\r\nmode_reg_values |= GI_LEVEL_GATING;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nni_tio_set_bits(counter, NITIO_MODE_REG(cidx),\r\nmode_reg_mask, mode_reg_values);\r\nif (ni_tio_counting_mode_registers_present(counter_dev)) {\r\nunsigned int bits = 0;\r\nbits |= GI_CNT_MODE(mode >> NI_GPCT_COUNTING_MODE_SHIFT);\r\nbits |= GI_INDEX_PHASE((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT));\r\nif (mode & NI_GPCT_INDEX_ENABLE_BIT)\r\nbits |= GI_INDEX_MODE;\r\nni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),\r\nGI_CNT_MODE_MASK | GI_INDEX_PHASE_MASK |\r\nGI_INDEX_MODE, bits);\r\nni_tio_set_sync_mode(counter);\r\n}\r\nni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_CNT_DIR_MASK,\r\nGI_CNT_DIR(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT));\r\nif (mode & NI_GPCT_OR_GATE_BIT)\r\ninput_select_bits |= GI_OR_GATE;\r\nif (mode & NI_GPCT_INVERT_OUTPUT_BIT)\r\ninput_select_bits |= GI_OUTPUT_POL_INVERT;\r\nni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),\r\nGI_GATE_SEL_LOAD_SRC | GI_OR_GATE |\r\nGI_OUTPUT_POL_INVERT, input_select_bits);\r\nreturn 0;\r\n}\r\nint ni_tio_arm(struct ni_gpct *counter, bool arm, unsigned int start_trigger)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int transient_bits = 0;\r\nif (arm) {\r\nunsigned int mask = 0;\r\nunsigned int bits = 0;\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ndefault:\r\nbreak;\r\ncase ni_gpct_variant_m_series:\r\nmask = GI_M_HW_ARM_SEL_MASK;\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nmask = GI_660X_HW_ARM_SEL_MASK;\r\nbreak;\r\n}\r\nswitch (start_trigger) {\r\ncase NI_GPCT_ARM_IMMEDIATE:\r\ntransient_bits |= GI_ARM;\r\nbreak;\r\ncase NI_GPCT_ARM_PAIRED_IMMEDIATE:\r\ntransient_bits |= GI_ARM | GI_ARM_COPY;\r\nbreak;\r\ndefault:\r\nif (mask && (start_trigger & NI_GPCT_ARM_UNKNOWN)) {\r\nbits |= GI_HW_ARM_ENA |\r\n(GI_HW_ARM_SEL(start_trigger) & mask);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nif (mask)\r\nni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),\r\nGI_HW_ARM_ENA | mask, bits);\r\n} else {\r\ntransient_bits |= GI_DISARM;\r\n}\r\nni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),\r\n0, 0, transient_bits);\r\nreturn 0;\r\n}\r\nstatic int ni_660x_clk_src(unsigned int clock_source, unsigned int *bits)\r\n{\r\nunsigned int clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;\r\nunsigned int ni_660x_clock;\r\nunsigned int i;\r\nswitch (clk_src) {\r\ncase NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660X_TIMEBASE_1_CLK;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660X_TIMEBASE_2_CLK;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660X_TIMEBASE_3_CLK;\r\nbreak;\r\ncase NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660X_LOGIC_LOW_CLK;\r\nbreak;\r\ncase NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660X_SRC_PIN_I_CLK;\r\nbreak;\r\ncase NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660X_NEXT_GATE_CLK;\r\nbreak;\r\ncase NI_GPCT_NEXT_TC_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660X_NEXT_TC_CLK;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\r\nif (clk_src == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {\r\nni_660x_clock = NI_660X_RTSI_CLK(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_RTSI_CHAN)\r\nbreak;\r\nfor (i = 0; i <= NI_660X_MAX_SRC_PIN; ++i) {\r\nif (clk_src == NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {\r\nni_660x_clock = NI_660X_SRC_PIN_CLK(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_SRC_PIN)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\n*bits = GI_SRC_SEL(ni_660x_clock);\r\nreturn 0;\r\n}\r\nstatic int ni_m_clk_src(unsigned int clock_source, unsigned int *bits)\r\n{\r\nunsigned int clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;\r\nunsigned int ni_m_series_clock;\r\nunsigned int i;\r\nswitch (clk_src) {\r\ncase NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_TIMEBASE_1_CLK;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_TIMEBASE_2_CLK;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_TIMEBASE_3_CLK;\r\nbreak;\r\ncase NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_LOGIC_LOW_CLK;\r\nbreak;\r\ncase NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_NEXT_GATE_CLK;\r\nbreak;\r\ncase NI_GPCT_NEXT_TC_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_NEXT_TC_CLK;\r\nbreak;\r\ncase NI_GPCT_PXI10_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_PXI10_CLK;\r\nbreak;\r\ncase NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_PXI_STAR_TRIGGER_CLK;\r\nbreak;\r\ncase NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_ANALOG_TRIGGER_OUT_CLK;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {\r\nif (clk_src == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {\r\nni_m_series_clock = NI_M_RTSI_CLK(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_M_MAX_RTSI_CHAN)\r\nbreak;\r\nfor (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {\r\nif (clk_src == NI_GPCT_PFI_CLOCK_SRC_BITS(i)) {\r\nni_m_series_clock = NI_M_PFI_CLK(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_M_MAX_PFI_CHAN)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\n*bits = GI_SRC_SEL(ni_m_series_clock);\r\nreturn 0;\r\n}\r\nstatic void ni_tio_set_source_subselect(struct ni_gpct *counter,\r\nunsigned int clock_source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int second_gate_reg = NITIO_GATE2_REG(cidx);\r\nif (counter_dev->variant != ni_gpct_variant_m_series)\r\nreturn;\r\nswitch (clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {\r\ncase NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:\r\ncase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\r\ncounter_dev->regs[second_gate_reg] &= ~GI_SRC_SUBSEL;\r\nbreak;\r\ncase NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:\r\ncase NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:\r\ncounter_dev->regs[second_gate_reg] |= GI_SRC_SUBSEL;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nni_tio_write(counter, counter_dev->regs[second_gate_reg],\r\nsecond_gate_reg);\r\n}\r\nstatic int ni_tio_set_clock_src(struct ni_gpct *counter,\r\nunsigned int clock_source,\r\nunsigned int period_ns)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int bits = 0;\r\nint ret;\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_660x:\r\nret = ni_660x_clk_src(clock_source, &bits);\r\nbreak;\r\ncase ni_gpct_variant_e_series:\r\ncase ni_gpct_variant_m_series:\r\ndefault:\r\nret = ni_m_clk_src(clock_source, &bits);\r\nbreak;\r\n}\r\nif (ret) {\r\nstruct comedi_device *dev = counter_dev->dev;\r\ndev_err(dev->class_dev, "invalid clock source 0x%x\n",\r\nclock_source);\r\nreturn ret;\r\n}\r\nif (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)\r\nbits |= GI_SRC_POL_INVERT;\r\nni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),\r\nGI_SRC_SEL_MASK | GI_SRC_POL_INVERT, bits);\r\nni_tio_set_source_subselect(counter, clock_source);\r\nif (ni_tio_counting_mode_registers_present(counter_dev)) {\r\nbits = 0;\r\nswitch (clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {\r\ncase NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:\r\nbreak;\r\ncase NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:\r\nbits |= GI_PRESCALE_X2(counter_dev->variant);\r\nbreak;\r\ncase NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:\r\nbits |= GI_PRESCALE_X8(counter_dev->variant);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),\r\nGI_PRESCALE_X2(counter_dev->variant) |\r\nGI_PRESCALE_X8(counter_dev->variant), bits);\r\n}\r\ncounter->clock_period_ps = period_ns * 1000;\r\nni_tio_set_sync_mode(counter);\r\nreturn 0;\r\n}\r\nstatic int ni_tio_get_clock_src(struct ni_gpct *counter,\r\nunsigned int *clock_source,\r\nunsigned int *period_ns)\r\n{\r\nu64 temp64;\r\nint ret;\r\nret = ni_tio_generic_clock_src_select(counter, clock_source);\r\nif (ret)\r\nreturn ret;\r\nret = ni_tio_clock_period_ps(counter, *clock_source, &temp64);\r\nif (ret)\r\nreturn ret;\r\ndo_div(temp64, 1000);\r\n*period_ns = temp64;\r\nreturn 0;\r\n}\r\nstatic int ni_660x_set_gate(struct ni_gpct *counter, unsigned int gate_source)\r\n{\r\nunsigned int chan = CR_CHAN(gate_source);\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int gate_sel;\r\nunsigned int i;\r\nswitch (chan) {\r\ncase NI_GPCT_NEXT_SOURCE_GATE_SELECT:\r\ngate_sel = NI_660X_NEXT_SRC_GATE_SEL;\r\nbreak;\r\ncase NI_GPCT_NEXT_OUT_GATE_SELECT:\r\ncase NI_GPCT_LOGIC_LOW_GATE_SELECT:\r\ncase NI_GPCT_SOURCE_PIN_i_GATE_SELECT:\r\ncase NI_GPCT_GATE_PIN_i_GATE_SELECT:\r\ngate_sel = chan & 0x1f;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\r\nif (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {\r\ngate_sel = chan & 0x1f;\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_RTSI_CHAN)\r\nbreak;\r\nfor (i = 0; i <= NI_660X_MAX_GATE_PIN; ++i) {\r\nif (chan == NI_GPCT_GATE_PIN_GATE_SELECT(i)) {\r\ngate_sel = chan & 0x1f;\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_GATE_PIN)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\nni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),\r\nGI_GATE_SEL_MASK, GI_GATE_SEL(gate_sel));\r\nreturn 0;\r\n}\r\nstatic int ni_m_set_gate(struct ni_gpct *counter, unsigned int gate_source)\r\n{\r\nunsigned int chan = CR_CHAN(gate_source);\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int gate_sel;\r\nunsigned int i;\r\nswitch (chan) {\r\ncase NI_GPCT_TIMESTAMP_MUX_GATE_SELECT:\r\ncase NI_GPCT_AI_START2_GATE_SELECT:\r\ncase NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT:\r\ncase NI_GPCT_NEXT_OUT_GATE_SELECT:\r\ncase NI_GPCT_AI_START1_GATE_SELECT:\r\ncase NI_GPCT_NEXT_SOURCE_GATE_SELECT:\r\ncase NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT:\r\ncase NI_GPCT_LOGIC_LOW_GATE_SELECT:\r\ngate_sel = chan & 0x1f;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {\r\nif (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {\r\ngate_sel = chan & 0x1f;\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_M_MAX_RTSI_CHAN)\r\nbreak;\r\nfor (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {\r\nif (chan == NI_GPCT_PFI_GATE_SELECT(i)) {\r\ngate_sel = chan & 0x1f;\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_M_MAX_PFI_CHAN)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\nni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),\r\nGI_GATE_SEL_MASK, GI_GATE_SEL(gate_sel));\r\nreturn 0;\r\n}\r\nstatic int ni_660x_set_gate2(struct ni_gpct *counter, unsigned int gate_source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int chan = CR_CHAN(gate_source);\r\nunsigned int gate2_reg = NITIO_GATE2_REG(cidx);\r\nunsigned int gate2_sel;\r\nunsigned int i;\r\nswitch (chan) {\r\ncase NI_GPCT_SOURCE_PIN_i_GATE_SELECT:\r\ncase NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT:\r\ncase NI_GPCT_SELECTED_GATE_GATE_SELECT:\r\ncase NI_GPCT_NEXT_OUT_GATE_SELECT:\r\ncase NI_GPCT_LOGIC_LOW_GATE_SELECT:\r\ngate2_sel = chan & 0x1f;\r\nbreak;\r\ncase NI_GPCT_NEXT_SOURCE_GATE_SELECT:\r\ngate2_sel = NI_660X_NEXT_SRC_GATE2_SEL;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\r\nif (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {\r\ngate2_sel = chan & 0x1f;\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_RTSI_CHAN)\r\nbreak;\r\nfor (i = 0; i <= NI_660X_MAX_UP_DOWN_PIN; ++i) {\r\nif (chan == NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {\r\ngate2_sel = chan & 0x1f;\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_UP_DOWN_PIN)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\ncounter_dev->regs[gate2_reg] |= GI_GATE2_MODE;\r\ncounter_dev->regs[gate2_reg] &= ~GI_GATE2_SEL_MASK;\r\ncounter_dev->regs[gate2_reg] |= GI_GATE2_SEL(gate2_sel);\r\nni_tio_write(counter, counter_dev->regs[gate2_reg], gate2_reg);\r\nreturn 0;\r\n}\r\nstatic int ni_m_set_gate2(struct ni_gpct *counter, unsigned int gate_source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int chan = CR_CHAN(gate_source);\r\nunsigned int gate2_reg = NITIO_GATE2_REG(cidx);\r\nunsigned int gate2_sel;\r\nswitch (chan) {\r\ndefault:\r\ngate2_sel = chan & 0x1f;\r\nbreak;\r\n}\r\ncounter_dev->regs[gate2_reg] |= GI_GATE2_MODE;\r\ncounter_dev->regs[gate2_reg] &= ~GI_GATE2_SEL_MASK;\r\ncounter_dev->regs[gate2_reg] |= GI_GATE2_SEL(gate2_sel);\r\nni_tio_write(counter, counter_dev->regs[gate2_reg], gate2_reg);\r\nreturn 0;\r\n}\r\nint ni_tio_set_gate_src(struct ni_gpct *counter,\r\nunsigned int gate, unsigned int src)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int chan = CR_CHAN(src);\r\nunsigned int gate2_reg = NITIO_GATE2_REG(cidx);\r\nunsigned int mode = 0;\r\nswitch (gate) {\r\ncase 0:\r\nif (chan == NI_GPCT_DISABLED_GATE_SELECT) {\r\nni_tio_set_bits(counter, NITIO_MODE_REG(cidx),\r\nGI_GATING_MODE_MASK,\r\nGI_GATING_DISABLED);\r\nreturn 0;\r\n}\r\nif (src & CR_INVERT)\r\nmode |= GI_GATE_POL_INVERT;\r\nif (src & CR_EDGE)\r\nmode |= GI_RISING_EDGE_GATING;\r\nelse\r\nmode |= GI_LEVEL_GATING;\r\nni_tio_set_bits(counter, NITIO_MODE_REG(cidx),\r\nGI_GATE_POL_INVERT | GI_GATING_MODE_MASK,\r\nmode);\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ncase ni_gpct_variant_m_series:\r\ndefault:\r\nreturn ni_m_set_gate(counter, src);\r\ncase ni_gpct_variant_660x:\r\nreturn ni_660x_set_gate(counter, src);\r\n}\r\nbreak;\r\ncase 1:\r\nif (!ni_tio_has_gate2_registers(counter_dev))\r\nreturn -EINVAL;\r\nif (chan == NI_GPCT_DISABLED_GATE_SELECT) {\r\ncounter_dev->regs[gate2_reg] &= ~GI_GATE2_MODE;\r\nni_tio_write(counter, counter_dev->regs[gate2_reg],\r\ngate2_reg);\r\nreturn 0;\r\n}\r\nif (src & CR_INVERT)\r\ncounter_dev->regs[gate2_reg] |= GI_GATE2_POL_INVERT;\r\nelse\r\ncounter_dev->regs[gate2_reg] &= ~GI_GATE2_POL_INVERT;\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_m_series:\r\nreturn ni_m_set_gate2(counter, src);\r\ncase ni_gpct_variant_660x:\r\nreturn ni_660x_set_gate2(counter, src);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_tio_set_other_src(struct ni_gpct *counter, unsigned int index,\r\nunsigned int source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int abz_reg, shift, mask;\r\nif (counter_dev->variant != ni_gpct_variant_m_series)\r\nreturn -EINVAL;\r\nabz_reg = NITIO_ABZ_REG(cidx);\r\nswitch (index) {\r\ncase NI_GPCT_SOURCE_ENCODER_A:\r\nshift = 10;\r\nbreak;\r\ncase NI_GPCT_SOURCE_ENCODER_B:\r\nshift = 5;\r\nbreak;\r\ncase NI_GPCT_SOURCE_ENCODER_Z:\r\nshift = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask = 0x1f << shift;\r\nif (source > 0x1f)\r\nsource = 0x1f;\r\ncounter_dev->regs[abz_reg] &= ~mask;\r\ncounter_dev->regs[abz_reg] |= (source << shift) & mask;\r\nni_tio_write(counter, counter_dev->regs[abz_reg], abz_reg);\r\nreturn 0;\r\n}\r\nstatic int ni_660x_gate_to_generic_gate(unsigned int gate, unsigned int *src)\r\n{\r\nunsigned int source;\r\nunsigned int i;\r\nswitch (gate) {\r\ncase NI_660X_SRC_PIN_I_GATE_SEL:\r\nsource = NI_GPCT_SOURCE_PIN_i_GATE_SELECT;\r\nbreak;\r\ncase NI_660X_GATE_PIN_I_GATE_SEL:\r\nsource = NI_GPCT_GATE_PIN_i_GATE_SELECT;\r\nbreak;\r\ncase NI_660X_NEXT_SRC_GATE_SEL:\r\nsource = NI_GPCT_NEXT_SOURCE_GATE_SELECT;\r\nbreak;\r\ncase NI_660X_NEXT_OUT_GATE_SEL:\r\nsource = NI_GPCT_NEXT_OUT_GATE_SELECT;\r\nbreak;\r\ncase NI_660X_LOGIC_LOW_GATE_SEL:\r\nsource = NI_GPCT_LOGIC_LOW_GATE_SELECT;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\r\nif (gate == NI_660X_RTSI_GATE_SEL(i)) {\r\nsource = NI_GPCT_RTSI_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_RTSI_CHAN)\r\nbreak;\r\nfor (i = 0; i <= NI_660X_MAX_GATE_PIN; ++i) {\r\nif (gate == NI_660X_PIN_GATE_SEL(i)) {\r\nsource = NI_GPCT_GATE_PIN_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_GATE_PIN)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\n*src = source;\r\nreturn 0;\r\n}\r\nstatic int ni_m_gate_to_generic_gate(unsigned int gate, unsigned int *src)\r\n{\r\nunsigned int source;\r\nunsigned int i;\r\nswitch (gate) {\r\ncase NI_M_TIMESTAMP_MUX_GATE_SEL:\r\nsource = NI_GPCT_TIMESTAMP_MUX_GATE_SELECT;\r\nbreak;\r\ncase NI_M_AI_START2_GATE_SEL:\r\nsource = NI_GPCT_AI_START2_GATE_SELECT;\r\nbreak;\r\ncase NI_M_PXI_STAR_TRIGGER_GATE_SEL:\r\nsource = NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT;\r\nbreak;\r\ncase NI_M_NEXT_OUT_GATE_SEL:\r\nsource = NI_GPCT_NEXT_OUT_GATE_SELECT;\r\nbreak;\r\ncase NI_M_AI_START1_GATE_SEL:\r\nsource = NI_GPCT_AI_START1_GATE_SELECT;\r\nbreak;\r\ncase NI_M_NEXT_SRC_GATE_SEL:\r\nsource = NI_GPCT_NEXT_SOURCE_GATE_SELECT;\r\nbreak;\r\ncase NI_M_ANALOG_TRIG_OUT_GATE_SEL:\r\nsource = NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT;\r\nbreak;\r\ncase NI_M_LOGIC_LOW_GATE_SEL:\r\nsource = NI_GPCT_LOGIC_LOW_GATE_SELECT;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {\r\nif (gate == NI_M_RTSI_GATE_SEL(i)) {\r\nsource = NI_GPCT_RTSI_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_M_MAX_RTSI_CHAN)\r\nbreak;\r\nfor (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {\r\nif (gate == NI_M_PFI_GATE_SEL(i)) {\r\nsource = NI_GPCT_PFI_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_M_MAX_PFI_CHAN)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\n*src = source;\r\nreturn 0;\r\n}\r\nstatic int ni_660x_gate2_to_generic_gate(unsigned int gate, unsigned int *src)\r\n{\r\nunsigned int source;\r\nunsigned int i;\r\nswitch (gate) {\r\ncase NI_660X_SRC_PIN_I_GATE2_SEL:\r\nsource = NI_GPCT_SOURCE_PIN_i_GATE_SELECT;\r\nbreak;\r\ncase NI_660X_UD_PIN_I_GATE2_SEL:\r\nsource = NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT;\r\nbreak;\r\ncase NI_660X_NEXT_SRC_GATE2_SEL:\r\nsource = NI_GPCT_NEXT_SOURCE_GATE_SELECT;\r\nbreak;\r\ncase NI_660X_NEXT_OUT_GATE2_SEL:\r\nsource = NI_GPCT_NEXT_OUT_GATE_SELECT;\r\nbreak;\r\ncase NI_660X_SELECTED_GATE2_SEL:\r\nsource = NI_GPCT_SELECTED_GATE_GATE_SELECT;\r\nbreak;\r\ncase NI_660X_LOGIC_LOW_GATE2_SEL:\r\nsource = NI_GPCT_LOGIC_LOW_GATE_SELECT;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\r\nif (gate == NI_660X_RTSI_GATE2_SEL(i)) {\r\nsource = NI_GPCT_RTSI_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_RTSI_CHAN)\r\nbreak;\r\nfor (i = 0; i <= NI_660X_MAX_UP_DOWN_PIN; ++i) {\r\nif (gate == NI_660X_UD_PIN_GATE2_SEL(i)) {\r\nsource = NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= NI_660X_MAX_UP_DOWN_PIN)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\n*src = source;\r\nreturn 0;\r\n}\r\nstatic int ni_m_gate2_to_generic_gate(unsigned int gate, unsigned int *src)\r\n{\r\n*src = gate;\r\nreturn 0;\r\n}\r\nstatic int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,\r\nunsigned int *gate_source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int mode;\r\nunsigned int reg;\r\nunsigned int gate;\r\nint ret;\r\nmode = ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));\r\nif (((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED) ||\r\n(gate_index == 1 &&\r\n!(counter_dev->regs[NITIO_GATE2_REG(cidx)] & GI_GATE2_MODE))) {\r\n*gate_source = NI_GPCT_DISABLED_GATE_SELECT;\r\nreturn 0;\r\n}\r\nswitch (gate_index) {\r\ncase 0:\r\nreg = NITIO_INPUT_SEL_REG(cidx);\r\ngate = GI_BITS_TO_GATE(ni_tio_get_soft_copy(counter, reg));\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ncase ni_gpct_variant_m_series:\r\ndefault:\r\nret = ni_m_gate_to_generic_gate(gate, gate_source);\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nret = ni_660x_gate_to_generic_gate(gate, gate_source);\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (mode & GI_GATE_POL_INVERT)\r\n*gate_source |= CR_INVERT;\r\nif ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)\r\n*gate_source |= CR_EDGE;\r\nbreak;\r\ncase 1:\r\nreg = NITIO_GATE2_REG(cidx);\r\ngate = GI_BITS_TO_GATE2(counter_dev->regs[reg]);\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ncase ni_gpct_variant_m_series:\r\ndefault:\r\nret = ni_m_gate2_to_generic_gate(gate, gate_source);\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nret = ni_660x_gate2_to_generic_gate(gate, gate_source);\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (counter_dev->regs[reg] & GI_GATE2_POL_INVERT)\r\n*gate_source |= CR_INVERT;\r\nif ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)\r\n*gate_source |= CR_EDGE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint ni_tio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int status;\r\nint ret = 0;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_SET_COUNTER_MODE:\r\nret = ni_tio_set_counter_mode(counter, data[1]);\r\nbreak;\r\ncase INSN_CONFIG_ARM:\r\nret = ni_tio_arm(counter, true, data[1]);\r\nbreak;\r\ncase INSN_CONFIG_DISARM:\r\nret = ni_tio_arm(counter, false, 0);\r\nbreak;\r\ncase INSN_CONFIG_GET_COUNTER_STATUS:\r\ndata[1] = 0;\r\nstatus = ni_tio_read(counter, NITIO_SHARED_STATUS_REG(cidx));\r\nif (status & GI_ARMED(cidx)) {\r\ndata[1] |= COMEDI_COUNTER_ARMED;\r\nif (status & GI_COUNTING(cidx))\r\ndata[1] |= COMEDI_COUNTER_COUNTING;\r\n}\r\ndata[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;\r\nbreak;\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\nret = ni_tio_set_clock_src(counter, data[1], data[2]);\r\nbreak;\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\nret = ni_tio_get_clock_src(counter, &data[1], &data[2]);\r\nbreak;\r\ncase INSN_CONFIG_SET_GATE_SRC:\r\nret = ni_tio_set_gate_src(counter, data[1], data[2]);\r\nbreak;\r\ncase INSN_CONFIG_GET_GATE_SRC:\r\nret = ni_tio_get_gate_src(counter, data[1], &data[2]);\r\nbreak;\r\ncase INSN_CONFIG_SET_OTHER_SRC:\r\nret = ni_tio_set_other_src(counter, data[1], data[2]);\r\nbreak;\r\ncase INSN_CONFIG_RESET:\r\nni_tio_reset_count_and_disarm(counter);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic unsigned int ni_tio_read_sw_save_reg(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int val;\r\nni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_SAVE_TRACE, 0);\r\nni_tio_set_bits(counter, NITIO_CMD_REG(cidx),\r\nGI_SAVE_TRACE, GI_SAVE_TRACE);\r\nval = ni_tio_read(counter, NITIO_SW_SAVE_REG(cidx));\r\nif (val != ni_tio_read(counter, NITIO_SW_SAVE_REG(cidx)))\r\nval = ni_tio_read(counter, NITIO_SW_SAVE_REG(cidx));\r\nreturn val;\r\n}\r\nint ni_tio_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int channel = CR_CHAN(insn->chanspec);\r\nunsigned int cidx = counter->counter_index;\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nswitch (channel) {\r\ncase 0:\r\ndata[i] = ni_tio_read_sw_save_reg(dev, s);\r\nbreak;\r\ncase 1:\r\ndata[i] = counter_dev->regs[NITIO_LOADA_REG(cidx)];\r\nbreak;\r\ncase 2:\r\ndata[i] = counter_dev->regs[NITIO_LOADB_REG(cidx)];\r\nbreak;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic unsigned int ni_tio_next_load_register(struct ni_gpct *counter)\r\n{\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int bits = ni_tio_read(counter, NITIO_SHARED_STATUS_REG(cidx));\r\nreturn (bits & GI_NEXT_LOAD_SRC(cidx))\r\n? NITIO_LOADB_REG(cidx)\r\n: NITIO_LOADA_REG(cidx);\r\n}\r\nint ni_tio_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int channel = CR_CHAN(insn->chanspec);\r\nunsigned int cidx = counter->counter_index;\r\nunsigned int load_reg;\r\nif (insn->n < 1)\r\nreturn 0;\r\nswitch (channel) {\r\ncase 0:\r\nload_reg = ni_tio_next_load_register(counter);\r\nni_tio_write(counter, data[0], load_reg);\r\nni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),\r\n0, 0, GI_LOAD);\r\nni_tio_write(counter, counter_dev->regs[load_reg], load_reg);\r\nbreak;\r\ncase 1:\r\ncounter_dev->regs[NITIO_LOADA_REG(cidx)] = data[0];\r\nni_tio_write(counter, data[0], NITIO_LOADA_REG(cidx));\r\nbreak;\r\ncase 2:\r\ncounter_dev->regs[NITIO_LOADB_REG(cidx)] = data[0];\r\nni_tio_write(counter, data[0], NITIO_LOADB_REG(cidx));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid ni_tio_init_counter(struct ni_gpct *counter)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned int cidx = counter->counter_index;\r\nni_tio_reset_count_and_disarm(counter);\r\ncounter_dev->regs[NITIO_AUTO_INC_REG(cidx)] = 0x0;\r\nni_tio_write(counter, 0x0, NITIO_AUTO_INC_REG(cidx));\r\nni_tio_set_bits(counter, NITIO_CMD_REG(cidx),\r\n~0, GI_SYNC_GATE);\r\nni_tio_set_bits(counter, NITIO_MODE_REG(cidx), ~0, 0);\r\ncounter_dev->regs[NITIO_LOADA_REG(cidx)] = 0x0;\r\nni_tio_write(counter, 0x0, NITIO_LOADA_REG(cidx));\r\ncounter_dev->regs[NITIO_LOADB_REG(cidx)] = 0x0;\r\nni_tio_write(counter, 0x0, NITIO_LOADB_REG(cidx));\r\nni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx), ~0, 0);\r\nif (ni_tio_counting_mode_registers_present(counter_dev))\r\nni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx), ~0, 0);\r\nif (ni_tio_has_gate2_registers(counter_dev)) {\r\ncounter_dev->regs[NITIO_GATE2_REG(cidx)] = 0x0;\r\nni_tio_write(counter, 0x0, NITIO_GATE2_REG(cidx));\r\n}\r\nni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx), ~0, 0x0);\r\nni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx), ~0, 0x0);\r\n}\r\nvoid ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)\r\n{\r\nif (!counter_dev)\r\nreturn;\r\nkfree(counter_dev->counters);\r\nkfree(counter_dev);\r\n}\r\nstatic int __init ni_tio_init_module(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit ni_tio_cleanup_module(void)\r\n{\r\n}
