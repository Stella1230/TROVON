unsigned int\r\n_get_xid(void)\r\n{\r\nunsigned int xid;\r\nspin_lock(&GlobalMid_Lock);\r\nGlobalTotalActiveXid++;\r\nif (GlobalTotalActiveXid > GlobalMaxActiveXid)\r\nGlobalMaxActiveXid = GlobalTotalActiveXid;\r\nif (GlobalTotalActiveXid > 65000)\r\ncifs_dbg(FYI, "warning: more than 65000 requests active\n");\r\nxid = GlobalCurrentXid++;\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn xid;\r\n}\r\nvoid\r\n_free_xid(unsigned int xid)\r\n{\r\nspin_lock(&GlobalMid_Lock);\r\nGlobalTotalActiveXid--;\r\nspin_unlock(&GlobalMid_Lock);\r\n}\r\nstruct cifs_ses *\r\nsesInfoAlloc(void)\r\n{\r\nstruct cifs_ses *ret_buf;\r\nret_buf = kzalloc(sizeof(struct cifs_ses), GFP_KERNEL);\r\nif (ret_buf) {\r\natomic_inc(&sesInfoAllocCount);\r\nret_buf->status = CifsNew;\r\n++ret_buf->ses_count;\r\nINIT_LIST_HEAD(&ret_buf->smb_ses_list);\r\nINIT_LIST_HEAD(&ret_buf->tcon_list);\r\nmutex_init(&ret_buf->session_mutex);\r\n}\r\nreturn ret_buf;\r\n}\r\nvoid\r\nsesInfoFree(struct cifs_ses *buf_to_free)\r\n{\r\nif (buf_to_free == NULL) {\r\ncifs_dbg(FYI, "Null buffer passed to sesInfoFree\n");\r\nreturn;\r\n}\r\natomic_dec(&sesInfoAllocCount);\r\nkfree(buf_to_free->serverOS);\r\nkfree(buf_to_free->serverDomain);\r\nkfree(buf_to_free->serverNOS);\r\nif (buf_to_free->password) {\r\nmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\r\nkfree(buf_to_free->password);\r\n}\r\nkfree(buf_to_free->user_name);\r\nkfree(buf_to_free->domainName);\r\nkfree(buf_to_free->auth_key.response);\r\nkfree(buf_to_free);\r\n}\r\nstruct cifs_tcon *\r\ntconInfoAlloc(void)\r\n{\r\nstruct cifs_tcon *ret_buf;\r\nret_buf = kzalloc(sizeof(struct cifs_tcon), GFP_KERNEL);\r\nif (ret_buf) {\r\natomic_inc(&tconInfoAllocCount);\r\nret_buf->tidStatus = CifsNew;\r\n++ret_buf->tc_count;\r\nINIT_LIST_HEAD(&ret_buf->openFileList);\r\nINIT_LIST_HEAD(&ret_buf->tcon_list);\r\n#ifdef CONFIG_CIFS_STATS\r\nspin_lock_init(&ret_buf->stat_lock);\r\n#endif\r\n}\r\nreturn ret_buf;\r\n}\r\nvoid\r\ntconInfoFree(struct cifs_tcon *buf_to_free)\r\n{\r\nif (buf_to_free == NULL) {\r\ncifs_dbg(FYI, "Null buffer passed to tconInfoFree\n");\r\nreturn;\r\n}\r\natomic_dec(&tconInfoAllocCount);\r\nkfree(buf_to_free->nativeFileSystem);\r\nif (buf_to_free->password) {\r\nmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\r\nkfree(buf_to_free->password);\r\n}\r\nkfree(buf_to_free);\r\n}\r\nstruct smb_hdr *\r\ncifs_buf_get(void)\r\n{\r\nstruct smb_hdr *ret_buf = NULL;\r\nsize_t buf_size = sizeof(struct smb_hdr);\r\n#ifdef CONFIG_CIFS_SMB2\r\nbuf_size = sizeof(struct smb2_hdr);\r\n#endif\r\nret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\r\nif (ret_buf) {\r\nmemset(ret_buf, 0, buf_size + 3);\r\natomic_inc(&bufAllocCount);\r\n#ifdef CONFIG_CIFS_STATS2\r\natomic_inc(&totBufAllocCount);\r\n#endif\r\n}\r\nreturn ret_buf;\r\n}\r\nvoid\r\ncifs_buf_release(void *buf_to_free)\r\n{\r\nif (buf_to_free == NULL) {\r\nreturn;\r\n}\r\nmempool_free(buf_to_free, cifs_req_poolp);\r\natomic_dec(&bufAllocCount);\r\nreturn;\r\n}\r\nstruct smb_hdr *\r\ncifs_small_buf_get(void)\r\n{\r\nstruct smb_hdr *ret_buf = NULL;\r\nret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\r\nif (ret_buf) {\r\natomic_inc(&smBufAllocCount);\r\n#ifdef CONFIG_CIFS_STATS2\r\natomic_inc(&totSmBufAllocCount);\r\n#endif\r\n}\r\nreturn ret_buf;\r\n}\r\nvoid\r\ncifs_small_buf_release(void *buf_to_free)\r\n{\r\nif (buf_to_free == NULL) {\r\ncifs_dbg(FYI, "Null buffer passed to cifs_small_buf_release\n");\r\nreturn;\r\n}\r\nmempool_free(buf_to_free, cifs_sm_req_poolp);\r\natomic_dec(&smBufAllocCount);\r\nreturn;\r\n}\r\nvoid\r\nfree_rsp_buf(int resp_buftype, void *rsp)\r\n{\r\nif (resp_buftype == CIFS_SMALL_BUFFER)\r\ncifs_small_buf_release(rsp);\r\nelse if (resp_buftype == CIFS_LARGE_BUFFER)\r\ncifs_buf_release(rsp);\r\n}\r\nvoid\r\nheader_assemble(struct smb_hdr *buffer, char smb_command ,\r\nconst struct cifs_tcon *treeCon, int word_count\r\n)\r\n{\r\nchar *temp = (char *) buffer;\r\nmemset(temp, 0, 256);\r\nbuffer->smb_buf_length = cpu_to_be32(\r\n(2 * word_count) + sizeof(struct smb_hdr) -\r\n4 +\r\n2 ) ;\r\nbuffer->Protocol[0] = 0xFF;\r\nbuffer->Protocol[1] = 'S';\r\nbuffer->Protocol[2] = 'M';\r\nbuffer->Protocol[3] = 'B';\r\nbuffer->Command = smb_command;\r\nbuffer->Flags = 0x00;\r\nbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\r\nbuffer->Pid = cpu_to_le16((__u16)current->tgid);\r\nbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\r\nif (treeCon) {\r\nbuffer->Tid = treeCon->tid;\r\nif (treeCon->ses) {\r\nif (treeCon->ses->capabilities & CAP_UNICODE)\r\nbuffer->Flags2 |= SMBFLG2_UNICODE;\r\nif (treeCon->ses->capabilities & CAP_STATUS32)\r\nbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\r\nbuffer->Uid = treeCon->ses->Suid;\r\nbuffer->Mid = get_next_mid(treeCon->ses->server);\r\n}\r\nif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\r\nbuffer->Flags2 |= SMBFLG2_DFS;\r\nif (treeCon->nocase)\r\nbuffer->Flags |= SMBFLG_CASELESS;\r\nif ((treeCon->ses) && (treeCon->ses->server))\r\nif (treeCon->ses->server->sign)\r\nbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\r\n}\r\nbuffer->WordCount = (char) word_count;\r\nreturn;\r\n}\r\nstatic int\r\ncheck_smb_hdr(struct smb_hdr *smb)\r\n{\r\nif (*(__le32 *) smb->Protocol != cpu_to_le32(0x424d53ff)) {\r\ncifs_dbg(VFS, "Bad protocol string signature header 0x%x\n",\r\n*(unsigned int *)smb->Protocol);\r\nreturn 1;\r\n}\r\nif (smb->Flags & SMBFLG_RESPONSE)\r\nreturn 0;\r\nif (smb->Command == SMB_COM_LOCKING_ANDX)\r\nreturn 0;\r\ncifs_dbg(VFS, "Server sent request, not response. mid=%u\n",\r\nget_mid(smb));\r\nreturn 1;\r\n}\r\nint\r\ncheckSMB(char *buf, unsigned int total_read, struct TCP_Server_Info *server)\r\n{\r\nstruct smb_hdr *smb = (struct smb_hdr *)buf;\r\n__u32 rfclen = be32_to_cpu(smb->smb_buf_length);\r\n__u32 clc_len;\r\ncifs_dbg(FYI, "checkSMB Length: 0x%x, smb_buf_length: 0x%x\n",\r\ntotal_read, rfclen);\r\nif (total_read < 2 + sizeof(struct smb_hdr)) {\r\nif ((total_read >= sizeof(struct smb_hdr) - 1)\r\n&& (smb->Status.CifsError != 0)) {\r\nsmb->WordCount = 0;\r\nreturn 0;\r\n} else if ((total_read == sizeof(struct smb_hdr) + 1) &&\r\n(smb->WordCount == 0)) {\r\nchar *tmp = (char *)smb;\r\nif (tmp[sizeof(struct smb_hdr)] == 0) {\r\ntmp[sizeof(struct smb_hdr)+1] = 0;\r\nreturn 0;\r\n}\r\ncifs_dbg(VFS, "rcvd invalid byte count (bcc)\n");\r\n} else {\r\ncifs_dbg(VFS, "Length less than smb header size\n");\r\n}\r\nreturn -EIO;\r\n}\r\nif (check_smb_hdr(smb))\r\nreturn -EIO;\r\nclc_len = smbCalcSize(smb);\r\nif (4 + rfclen != total_read) {\r\ncifs_dbg(VFS, "Length read does not match RFC1001 length %d\n",\r\nrfclen);\r\nreturn -EIO;\r\n}\r\nif (4 + rfclen != clc_len) {\r\n__u16 mid = get_mid(smb);\r\nif ((rfclen > 64 * 1024) && (rfclen > clc_len)) {\r\nif (((4 + rfclen) & 0xFFFF) == (clc_len & 0xFFFF))\r\nreturn 0;\r\n}\r\ncifs_dbg(FYI, "Calculated size %u vs length %u mismatch for mid=%u\n",\r\nclc_len, 4 + rfclen, mid);\r\nif (4 + rfclen < clc_len) {\r\ncifs_dbg(VFS, "RFC1001 size %u smaller than SMB for mid=%u\n",\r\nrfclen, mid);\r\nreturn -EIO;\r\n} else if (rfclen > clc_len + 512) {\r\ncifs_dbg(VFS, "RFC1001 size %u more than 512 bytes larger than SMB for mid=%u\n",\r\nrfclen, mid);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nbool\r\nis_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)\r\n{\r\nstruct smb_hdr *buf = (struct smb_hdr *)buffer;\r\nstruct smb_com_lock_req *pSMB = (struct smb_com_lock_req *)buf;\r\nstruct list_head *tmp, *tmp1, *tmp2;\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon;\r\nstruct cifsInodeInfo *pCifsInode;\r\nstruct cifsFileInfo *netfile;\r\ncifs_dbg(FYI, "Checking for oplock break or dnotify response\n");\r\nif ((pSMB->hdr.Command == SMB_COM_NT_TRANSACT) &&\r\n(pSMB->hdr.Flags & SMBFLG_RESPONSE)) {\r\nstruct smb_com_transaction_change_notify_rsp *pSMBr =\r\n(struct smb_com_transaction_change_notify_rsp *)buf;\r\nstruct file_notify_information *pnotify;\r\n__u32 data_offset = 0;\r\nif (get_bcc(buf) > sizeof(struct file_notify_information)) {\r\ndata_offset = le32_to_cpu(pSMBr->DataOffset);\r\npnotify = (struct file_notify_information *)\r\n((char *)&pSMBr->hdr.Protocol + data_offset);\r\ncifs_dbg(FYI, "dnotify on %s Action: 0x%x\n",\r\npnotify->FileName, pnotify->Action);\r\nreturn true;\r\n}\r\nif (pSMBr->hdr.Status.CifsError) {\r\ncifs_dbg(FYI, "notify err 0x%x\n",\r\npSMBr->hdr.Status.CifsError);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nif (pSMB->hdr.Command != SMB_COM_LOCKING_ANDX)\r\nreturn false;\r\nif (pSMB->hdr.Flags & SMBFLG_RESPONSE) {\r\nif ((NT_STATUS_INVALID_HANDLE) ==\r\nle32_to_cpu(pSMB->hdr.Status.CifsError)) {\r\ncifs_dbg(FYI, "invalid handle on oplock break\n");\r\nreturn true;\r\n} else if (ERRbadfid ==\r\nle16_to_cpu(pSMB->hdr.Status.DosError.Error)) {\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nif (pSMB->hdr.WordCount != 8)\r\nreturn false;\r\ncifs_dbg(FYI, "oplock type 0x%x level 0x%x\n",\r\npSMB->LockType, pSMB->OplockLevel);\r\nif (!(pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE))\r\nreturn false;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each(tmp, &srv->smb_ses_list) {\r\nses = list_entry(tmp, struct cifs_ses, smb_ses_list);\r\nlist_for_each(tmp1, &ses->tcon_list) {\r\ntcon = list_entry(tmp1, struct cifs_tcon, tcon_list);\r\nif (tcon->tid != buf->Tid)\r\ncontinue;\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_oplock_brks);\r\nspin_lock(&cifs_file_list_lock);\r\nlist_for_each(tmp2, &tcon->openFileList) {\r\nnetfile = list_entry(tmp2, struct cifsFileInfo,\r\ntlist);\r\nif (pSMB->Fid != netfile->fid.netfid)\r\ncontinue;\r\ncifs_dbg(FYI, "file id match, oplock break\n");\r\npCifsInode = CIFS_I(d_inode(netfile->dentry));\r\nset_bit(CIFS_INODE_PENDING_OPLOCK_BREAK,\r\n&pCifsInode->flags);\r\nif (pSMB->OplockLevel)\r\nset_bit(\r\nCIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,\r\n&pCifsInode->flags);\r\nelse\r\nclear_bit(\r\nCIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,\r\n&pCifsInode->flags);\r\nqueue_work(cifsiod_wq,\r\n&netfile->oplock_break);\r\nnetfile->oplock_break_cancelled = false;\r\nspin_unlock(&cifs_file_list_lock);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn true;\r\n}\r\nspin_unlock(&cifs_file_list_lock);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncifs_dbg(FYI, "No matching file for oplock break\n");\r\nreturn true;\r\n}\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncifs_dbg(FYI, "Can not process oplock break for non-existent connection\n");\r\nreturn true;\r\n}\r\nvoid\r\ndump_smb(void *buf, int smb_buf_length)\r\n{\r\nif (traceSMB == 0)\r\nreturn;\r\nprint_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_NONE, 8, 2, buf,\r\nsmb_buf_length, true);\r\n}\r\nvoid\r\ncifs_autodisable_serverino(struct cifs_sb_info *cifs_sb)\r\n{\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\r\ncifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\r\ncifs_dbg(VFS, "Autodisabling the use of server inode numbers on %s. This server doesn't seem to support them properly. Hardlinks will not be recognized on this mount. Consider mounting with the \"noserverino\" option to silence this message.\n",\r\ncifs_sb_master_tcon(cifs_sb)->treeName);\r\n}\r\n}\r\nvoid cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\r\n{\r\noplock &= 0xF;\r\nif (oplock == OPLOCK_EXCLUSIVE) {\r\ncinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\r\ncifs_dbg(FYI, "Exclusive Oplock granted on inode %p\n",\r\n&cinode->vfs_inode);\r\n} else if (oplock == OPLOCK_READ) {\r\ncinode->oplock = CIFS_CACHE_READ_FLG;\r\ncifs_dbg(FYI, "Level II Oplock granted on inode %p\n",\r\n&cinode->vfs_inode);\r\n} else\r\ncinode->oplock = 0;\r\n}\r\nint cifs_get_writer(struct cifsInodeInfo *cinode)\r\n{\r\nint rc;\r\nstart:\r\nrc = wait_on_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK,\r\nTASK_KILLABLE);\r\nif (rc)\r\nreturn rc;\r\nspin_lock(&cinode->writers_lock);\r\nif (!cinode->writers)\r\nset_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\r\ncinode->writers++;\r\nif (test_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags)) {\r\ncinode->writers--;\r\nif (cinode->writers == 0) {\r\nclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\r\nwake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\r\n}\r\nspin_unlock(&cinode->writers_lock);\r\ngoto start;\r\n}\r\nspin_unlock(&cinode->writers_lock);\r\nreturn 0;\r\n}\r\nvoid cifs_put_writer(struct cifsInodeInfo *cinode)\r\n{\r\nspin_lock(&cinode->writers_lock);\r\ncinode->writers--;\r\nif (cinode->writers == 0) {\r\nclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\r\nwake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\r\n}\r\nspin_unlock(&cinode->writers_lock);\r\n}\r\nvoid cifs_done_oplock_break(struct cifsInodeInfo *cinode)\r\n{\r\nclear_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags);\r\nwake_up_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK);\r\n}\r\nbool\r\nbackup_cred(struct cifs_sb_info *cifs_sb)\r\n{\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\r\nif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\r\nreturn true;\r\n}\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\r\nif (in_group_p(cifs_sb->mnt_backupgid))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid\r\ncifs_del_pending_open(struct cifs_pending_open *open)\r\n{\r\nspin_lock(&cifs_file_list_lock);\r\nlist_del(&open->olist);\r\nspin_unlock(&cifs_file_list_lock);\r\n}\r\nvoid\r\ncifs_add_pending_open_locked(struct cifs_fid *fid, struct tcon_link *tlink,\r\nstruct cifs_pending_open *open)\r\n{\r\n#ifdef CONFIG_CIFS_SMB2\r\nmemcpy(open->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\r\n#endif\r\nopen->oplock = CIFS_OPLOCK_NO_CHANGE;\r\nopen->tlink = tlink;\r\nfid->pending_open = open;\r\nlist_add_tail(&open->olist, &tlink_tcon(tlink)->pending_opens);\r\n}\r\nvoid\r\ncifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,\r\nstruct cifs_pending_open *open)\r\n{\r\nspin_lock(&cifs_file_list_lock);\r\ncifs_add_pending_open_locked(fid, tlink, open);\r\nspin_unlock(&cifs_file_list_lock);\r\n}
