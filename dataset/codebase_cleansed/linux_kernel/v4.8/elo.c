static void elo_process_data_10(struct elo *elo, unsigned char data)\r\n{\r\nstruct input_dev *dev = elo->dev;\r\nelo->data[elo->idx] = data;\r\nswitch (elo->idx++) {\r\ncase 0:\r\nelo->csum = 0xaa;\r\nif (data != ELO10_LEAD_BYTE) {\r\ndev_dbg(&elo->serio->dev,\r\n"unsynchronized data: 0x%02x\n", data);\r\nelo->idx = 0;\r\n}\r\nbreak;\r\ncase 9:\r\nelo->idx = 0;\r\nif (data != elo->csum) {\r\ndev_dbg(&elo->serio->dev,\r\n"bad checksum: 0x%02x, expected 0x%02x\n",\r\ndata, elo->csum);\r\nbreak;\r\n}\r\nif (elo->data[1] != elo->expected_packet) {\r\nif (elo->data[1] != ELO10_TOUCH_PACKET)\r\ndev_dbg(&elo->serio->dev,\r\n"unexpected packet: 0x%02x\n",\r\nelo->data[1]);\r\nbreak;\r\n}\r\nif (likely(elo->data[1] == ELO10_TOUCH_PACKET)) {\r\ninput_report_abs(dev, ABS_X, (elo->data[4] << 8) | elo->data[3]);\r\ninput_report_abs(dev, ABS_Y, (elo->data[6] << 8) | elo->data[5]);\r\nif (elo->data[2] & ELO10_PRESSURE)\r\ninput_report_abs(dev, ABS_PRESSURE,\r\n(elo->data[8] << 8) | elo->data[7]);\r\ninput_report_key(dev, BTN_TOUCH, elo->data[2] & ELO10_TOUCH);\r\ninput_sync(dev);\r\n} else if (elo->data[1] == ELO10_ACK_PACKET) {\r\nif (elo->data[2] == '0')\r\nelo->expected_packet = ELO10_TOUCH_PACKET;\r\ncomplete(&elo->cmd_done);\r\n} else {\r\nmemcpy(elo->response, &elo->data[1], ELO10_PACKET_LEN);\r\nelo->expected_packet = ELO10_ACK_PACKET;\r\n}\r\nbreak;\r\n}\r\nelo->csum += data;\r\n}\r\nstatic void elo_process_data_6(struct elo *elo, unsigned char data)\r\n{\r\nstruct input_dev *dev = elo->dev;\r\nelo->data[elo->idx] = data;\r\nswitch (elo->idx++) {\r\ncase 0:\r\nif ((data & 0xc0) != 0xc0)\r\nelo->idx = 0;\r\nbreak;\r\ncase 1:\r\nif ((data & 0xc0) != 0x80)\r\nelo->idx = 0;\r\nbreak;\r\ncase 2:\r\nif ((data & 0xc0) != 0x40)\r\nelo->idx = 0;\r\nbreak;\r\ncase 3:\r\nif (data & 0xc0) {\r\nelo->idx = 0;\r\nbreak;\r\n}\r\ninput_report_abs(dev, ABS_X, ((elo->data[0] & 0x3f) << 6) | (elo->data[1] & 0x3f));\r\ninput_report_abs(dev, ABS_Y, ((elo->data[2] & 0x3f) << 6) | (elo->data[3] & 0x3f));\r\nif (elo->id == 2) {\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\ninput_sync(dev);\r\nelo->idx = 0;\r\n}\r\nbreak;\r\ncase 4:\r\nif (data) {\r\ninput_sync(dev);\r\nelo->idx = 0;\r\n}\r\nbreak;\r\ncase 5:\r\nif ((data & 0xf0) == 0) {\r\ninput_report_abs(dev, ABS_PRESSURE, elo->data[5]);\r\ninput_report_key(dev, BTN_TOUCH, !!elo->data[5]);\r\n}\r\ninput_sync(dev);\r\nelo->idx = 0;\r\nbreak;\r\n}\r\n}\r\nstatic void elo_process_data_3(struct elo *elo, unsigned char data)\r\n{\r\nstruct input_dev *dev = elo->dev;\r\nelo->data[elo->idx] = data;\r\nswitch (elo->idx++) {\r\ncase 0:\r\nif ((data & 0x7f) != 0x01)\r\nelo->idx = 0;\r\nbreak;\r\ncase 2:\r\ninput_report_key(dev, BTN_TOUCH, !(elo->data[1] & 0x80));\r\ninput_report_abs(dev, ABS_X, elo->data[1]);\r\ninput_report_abs(dev, ABS_Y, elo->data[2]);\r\ninput_sync(dev);\r\nelo->idx = 0;\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t elo_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct elo *elo = serio_get_drvdata(serio);\r\nswitch (elo->id) {\r\ncase 0:\r\nelo_process_data_10(elo, data);\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nelo_process_data_6(elo, data);\r\nbreak;\r\ncase 3:\r\nelo_process_data_3(elo, data);\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int elo_command_10(struct elo *elo, unsigned char *packet)\r\n{\r\nint rc = -1;\r\nint i;\r\nunsigned char csum = 0xaa + ELO10_LEAD_BYTE;\r\nmutex_lock(&elo->cmd_mutex);\r\nserio_pause_rx(elo->serio);\r\nelo->expected_packet = toupper(packet[0]);\r\ninit_completion(&elo->cmd_done);\r\nserio_continue_rx(elo->serio);\r\nif (serio_write(elo->serio, ELO10_LEAD_BYTE))\r\ngoto out;\r\nfor (i = 0; i < ELO10_PACKET_LEN; i++) {\r\ncsum += packet[i];\r\nif (serio_write(elo->serio, packet[i]))\r\ngoto out;\r\n}\r\nif (serio_write(elo->serio, csum))\r\ngoto out;\r\nwait_for_completion_timeout(&elo->cmd_done, HZ);\r\nif (elo->expected_packet == ELO10_TOUCH_PACKET) {\r\nmemcpy(packet, elo->response, ELO10_PACKET_LEN);\r\nrc = 0;\r\n}\r\nout:\r\nmutex_unlock(&elo->cmd_mutex);\r\nreturn rc;\r\n}\r\nstatic int elo_setup_10(struct elo *elo)\r\n{\r\nstatic const char *elo_types[] = { "Accu", "Dura", "Intelli", "Carroll" };\r\nstruct input_dev *dev = elo->dev;\r\nunsigned char packet[ELO10_PACKET_LEN] = { ELO10_ID_CMD };\r\nif (elo_command_10(elo, packet))\r\nreturn -1;\r\ndev->id.version = (packet[5] << 8) | packet[4];\r\ninput_set_abs_params(dev, ABS_X, 96, 4000, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, 96, 4000, 0, 0);\r\nif (packet[3] & ELO10_PRESSURE)\r\ninput_set_abs_params(dev, ABS_PRESSURE, 0, 255, 0, 0);\r\ndev_info(&elo->serio->dev,\r\n"%sTouch touchscreen, fw: %02x.%02x, features: 0x%02x, controller: 0x%02x\n",\r\nelo_types[(packet[1] -'0') & 0x03],\r\npacket[5], packet[4], packet[3], packet[7]);\r\nreturn 0;\r\n}\r\nstatic void elo_disconnect(struct serio *serio)\r\n{\r\nstruct elo *elo = serio_get_drvdata(serio);\r\ninput_get_device(elo->dev);\r\ninput_unregister_device(elo->dev);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_put_device(elo->dev);\r\nkfree(elo);\r\n}\r\nstatic int elo_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct elo *elo;\r\nstruct input_dev *input_dev;\r\nint err;\r\nelo = kzalloc(sizeof(struct elo), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!elo || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nelo->serio = serio;\r\nelo->id = serio->id.id;\r\nelo->dev = input_dev;\r\nelo->expected_packet = ELO10_TOUCH_PACKET;\r\nmutex_init(&elo->cmd_mutex);\r\ninit_completion(&elo->cmd_done);\r\nsnprintf(elo->phys, sizeof(elo->phys), "%s/input0", serio->phys);\r\ninput_dev->name = "Elo Serial TouchScreen";\r\ninput_dev->phys = elo->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_ELO;\r\ninput_dev->id.product = elo->id;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\nserio_set_drvdata(serio, elo);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nswitch (elo->id) {\r\ncase 0:\r\nif (elo_setup_10(elo))\r\ngoto fail3;\r\nbreak;\r\ncase 1:\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, 15, 0, 0);\r\ncase 2:\r\ninput_set_abs_params(input_dev, ABS_X, 96, 4000, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 96, 4000, 0, 0);\r\nbreak;\r\ncase 3:\r\ninput_set_abs_params(input_dev, ABS_X, 0, 255, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, 255, 0, 0);\r\nbreak;\r\n}\r\nerr = input_register_device(elo->dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(elo);\r\nreturn err;\r\n}
