static void twidjoy_process_packet(struct twidjoy *twidjoy)\r\n{\r\nstruct input_dev *dev = twidjoy->dev;\r\nunsigned char *data = twidjoy->data;\r\nstruct twidjoy_button_spec *bp;\r\nint button_bits, abs_x, abs_y;\r\nbutton_bits = ((data[1] & 0x7f) << 7) | (data[0] & 0x7f);\r\nfor (bp = twidjoy_buttons; bp->bitmask; bp++) {\r\nint value = (button_bits & (bp->bitmask << bp->bitshift)) >> bp->bitshift;\r\nint i;\r\nfor (i = 0; i < bp->bitmask; i++)\r\ninput_report_key(dev, bp->buttons[i], i+1 == value);\r\n}\r\nabs_x = ((data[4] & 0x07) << 5) | ((data[3] & 0x7C) >> 2);\r\nif (data[4] & 0x08) abs_x -= 256;\r\nabs_y = ((data[3] & 0x01) << 7) | ((data[2] & 0x7F) >> 0);\r\nif (data[3] & 0x02) abs_y -= 256;\r\ninput_report_abs(dev, ABS_X, -abs_x);\r\ninput_report_abs(dev, ABS_Y, +abs_y);\r\ninput_sync(dev);\r\n}\r\nstatic irqreturn_t twidjoy_interrupt(struct serio *serio, unsigned char data, unsigned int flags)\r\n{\r\nstruct twidjoy *twidjoy = serio_get_drvdata(serio);\r\nif ((data & 0x80) == 0)\r\ntwidjoy->idx = 0;\r\nelse if (twidjoy->idx == 0)\r\nreturn IRQ_HANDLED;\r\nif (twidjoy->idx < TWIDJOY_MAX_LENGTH)\r\ntwidjoy->data[twidjoy->idx++] = data;\r\nif (twidjoy->idx == TWIDJOY_MAX_LENGTH) {\r\ntwidjoy_process_packet(twidjoy);\r\ntwidjoy->idx = 0;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void twidjoy_disconnect(struct serio *serio)\r\n{\r\nstruct twidjoy *twidjoy = serio_get_drvdata(serio);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_unregister_device(twidjoy->dev);\r\nkfree(twidjoy);\r\n}\r\nstatic int twidjoy_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct twidjoy_button_spec *bp;\r\nstruct twidjoy *twidjoy;\r\nstruct input_dev *input_dev;\r\nint err = -ENOMEM;\r\nint i;\r\ntwidjoy = kzalloc(sizeof(struct twidjoy), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!twidjoy || !input_dev)\r\ngoto fail1;\r\ntwidjoy->dev = input_dev;\r\nsnprintf(twidjoy->phys, sizeof(twidjoy->phys), "%s/input0", serio->phys);\r\ninput_dev->name = "Handykey Twiddler";\r\ninput_dev->phys = twidjoy->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_TWIDJOY;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_set_abs_params(input_dev, ABS_X, -50, 50, 4, 4);\r\ninput_set_abs_params(input_dev, ABS_Y, -50, 50, 4, 4);\r\nfor (bp = twidjoy_buttons; bp->bitmask; bp++)\r\nfor (i = 0; i < bp->bitmask; i++)\r\nset_bit(bp->buttons[i], input_dev->keybit);\r\nserio_set_drvdata(serio, twidjoy);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nerr = input_register_device(twidjoy->dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(twidjoy);\r\nreturn err;\r\n}
