static void iwl_mvm_enter_ctkill(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\r\nu32 duration = tt->params.ct_kill_duration;\r\nif (test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status))\r\nreturn;\r\nIWL_ERR(mvm, "Enter CT Kill\n");\r\niwl_mvm_set_hw_ctkill_state(mvm, true);\r\nif (!iwl_mvm_is_tt_in_fw(mvm)) {\r\ntt->throttle = false;\r\ntt->dynamic_smps = false;\r\n}\r\nif (!mvm->temperature_test)\r\nschedule_delayed_work(&tt->ct_kill_exit,\r\nround_jiffies_relative(duration * HZ));\r\n}\r\nstatic void iwl_mvm_exit_ctkill(struct iwl_mvm *mvm)\r\n{\r\nif (!test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status))\r\nreturn;\r\nIWL_ERR(mvm, "Exit CT Kill\n");\r\niwl_mvm_set_hw_ctkill_state(mvm, false);\r\n}\r\nvoid iwl_mvm_tt_temp_changed(struct iwl_mvm *mvm, u32 temp)\r\n{\r\nif (mvm->temperature_test)\r\nreturn;\r\nif (mvm->temperature == temp)\r\nreturn;\r\nmvm->temperature = temp;\r\niwl_mvm_tt_handler(mvm);\r\n}\r\nstatic int iwl_mvm_temp_notif_parse(struct iwl_mvm *mvm,\r\nstruct iwl_rx_packet *pkt)\r\n{\r\nstruct iwl_dts_measurement_notif_v1 *notif_v1;\r\nint len = iwl_rx_packet_payload_len(pkt);\r\nint temp;\r\nif (WARN_ON_ONCE(len < sizeof(*notif_v1))) {\r\nIWL_ERR(mvm, "Invalid DTS_MEASUREMENT_NOTIFICATION\n");\r\nreturn -EINVAL;\r\n}\r\nnotif_v1 = (void *)pkt->data;\r\ntemp = le32_to_cpu(notif_v1->temp);\r\nif (WARN_ON_ONCE(temp < 0))\r\ntemp = 0;\r\nIWL_DEBUG_TEMP(mvm, "DTS_MEASUREMENT_NOTIFICATION - %d\n", temp);\r\nreturn temp;\r\n}\r\nstatic bool iwl_mvm_temp_notif_wait(struct iwl_notif_wait_data *notif_wait,\r\nstruct iwl_rx_packet *pkt, void *data)\r\n{\r\nstruct iwl_mvm *mvm =\r\ncontainer_of(notif_wait, struct iwl_mvm, notif_wait);\r\nint *temp = data;\r\nint ret;\r\nret = iwl_mvm_temp_notif_parse(mvm, pkt);\r\nif (ret < 0)\r\nreturn true;\r\n*temp = ret;\r\nreturn true;\r\n}\r\nvoid iwl_mvm_temp_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nstruct iwl_dts_measurement_notif_v2 *notif_v2;\r\nint len = iwl_rx_packet_payload_len(pkt);\r\nint temp;\r\nu32 ths_crossed;\r\nif (test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status))\r\nreturn;\r\ntemp = iwl_mvm_temp_notif_parse(mvm, pkt);\r\nif (!iwl_mvm_is_tt_in_fw(mvm)) {\r\nif (temp >= 0)\r\niwl_mvm_tt_temp_changed(mvm, temp);\r\nreturn;\r\n}\r\nif (WARN_ON_ONCE(len < sizeof(*notif_v2))) {\r\nIWL_ERR(mvm, "Invalid DTS_MEASUREMENT_NOTIFICATION\n");\r\nreturn;\r\n}\r\nnotif_v2 = (void *)pkt->data;\r\nths_crossed = le32_to_cpu(notif_v2->threshold_idx);\r\nif (ths_crossed == 0xFF)\r\nreturn;\r\nIWL_DEBUG_TEMP(mvm, "Temp = %d Threshold crossed = %d\n",\r\ntemp, ths_crossed);\r\n#ifdef CONFIG_THERMAL\r\nif (WARN_ON(ths_crossed >= IWL_MAX_DTS_TRIPS))\r\nreturn;\r\nif (mvm->tz_device.tzone) {\r\nstruct iwl_mvm_thermal_device *tz_dev = &mvm->tz_device;\r\nthermal_notify_framework(tz_dev->tzone,\r\ntz_dev->fw_trips_index[ths_crossed]);\r\n}\r\n#endif\r\n}\r\nvoid iwl_mvm_ct_kill_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nstruct ct_kill_notif *notif;\r\nint len = iwl_rx_packet_payload_len(pkt);\r\nif (WARN_ON_ONCE(len != sizeof(*notif))) {\r\nIWL_ERR(mvm, "Invalid CT_KILL_NOTIFICATION\n");\r\nreturn;\r\n}\r\nnotif = (struct ct_kill_notif *)pkt->data;\r\nIWL_DEBUG_TEMP(mvm, "CT Kill notification temperature = %d\n",\r\nnotif->temperature);\r\niwl_mvm_enter_ctkill(mvm);\r\n}\r\nstatic int iwl_mvm_get_temp_cmd(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_dts_measurement_cmd cmd = {\r\n.flags = cpu_to_le32(DTS_TRIGGER_CMD_FLAGS_TEMP),\r\n};\r\nstruct iwl_ext_dts_measurement_cmd extcmd = {\r\n.control_mode = cpu_to_le32(DTS_AUTOMATIC),\r\n};\r\nu32 cmdid;\r\nif (fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_WIDE_CMD_HDR))\r\ncmdid = iwl_cmd_id(CMD_DTS_MEASUREMENT_TRIGGER_WIDE,\r\nPHY_OPS_GROUP, 0);\r\nelse\r\ncmdid = CMD_DTS_MEASUREMENT_TRIGGER;\r\nif (!fw_has_capa(&mvm->fw->ucode_capa,\r\nIWL_UCODE_TLV_CAPA_EXTENDED_DTS_MEASURE))\r\nreturn iwl_mvm_send_cmd_pdu(mvm, cmdid, 0, sizeof(cmd), &cmd);\r\nreturn iwl_mvm_send_cmd_pdu(mvm, cmdid, 0, sizeof(extcmd), &extcmd);\r\n}\r\nint iwl_mvm_get_temp(struct iwl_mvm *mvm, s32 *temp)\r\n{\r\nstruct iwl_notification_wait wait_temp_notif;\r\nstatic u16 temp_notif[] = { WIDE_ID(PHY_OPS_GROUP,\r\nDTS_MEASUREMENT_NOTIF_WIDE) };\r\nint ret;\r\nif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_WIDE_CMD_HDR))\r\ntemp_notif[0] = DTS_MEASUREMENT_NOTIFICATION;\r\nlockdep_assert_held(&mvm->mutex);\r\niwl_init_notification_wait(&mvm->notif_wait, &wait_temp_notif,\r\ntemp_notif, ARRAY_SIZE(temp_notif),\r\niwl_mvm_temp_notif_wait, temp);\r\nret = iwl_mvm_get_temp_cmd(mvm);\r\nif (ret) {\r\nIWL_ERR(mvm, "Failed to get the temperature (err=%d)\n", ret);\r\niwl_remove_notification(&mvm->notif_wait, &wait_temp_notif);\r\nreturn ret;\r\n}\r\nret = iwl_wait_notification(&mvm->notif_wait, &wait_temp_notif,\r\nIWL_MVM_TEMP_NOTIF_WAIT_TIMEOUT);\r\nif (ret)\r\nIWL_ERR(mvm, "Getting the temperature timed out\n");\r\nreturn ret;\r\n}\r\nstatic void check_exit_ctkill(struct work_struct *work)\r\n{\r\nstruct iwl_mvm_tt_mgmt *tt;\r\nstruct iwl_mvm *mvm;\r\nu32 duration;\r\ns32 temp;\r\nint ret;\r\ntt = container_of(work, struct iwl_mvm_tt_mgmt, ct_kill_exit.work);\r\nmvm = container_of(tt, struct iwl_mvm, thermal_throttle);\r\nif (iwl_mvm_is_tt_in_fw(mvm)) {\r\niwl_mvm_exit_ctkill(mvm);\r\nreturn;\r\n}\r\nduration = tt->params.ct_kill_duration;\r\nmutex_lock(&mvm->mutex);\r\nif (__iwl_mvm_mac_start(mvm))\r\ngoto reschedule;\r\nif (iwl_mvm_ref_sync(mvm, IWL_MVM_REF_CHECK_CTKILL)) {\r\n__iwl_mvm_mac_stop(mvm);\r\ngoto reschedule;\r\n}\r\nret = iwl_mvm_get_temp(mvm, &temp);\r\niwl_mvm_unref(mvm, IWL_MVM_REF_CHECK_CTKILL);\r\n__iwl_mvm_mac_stop(mvm);\r\nif (ret)\r\ngoto reschedule;\r\nIWL_DEBUG_TEMP(mvm, "NIC temperature: %d\n", temp);\r\nif (temp <= tt->params.ct_kill_exit) {\r\nmutex_unlock(&mvm->mutex);\r\niwl_mvm_exit_ctkill(mvm);\r\nreturn;\r\n}\r\nreschedule:\r\nmutex_unlock(&mvm->mutex);\r\nschedule_delayed_work(&mvm->thermal_throttle.ct_kill_exit,\r\nround_jiffies(duration * HZ));\r\n}\r\nstatic void iwl_mvm_tt_smps_iterator(void *_data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm *mvm = _data;\r\nenum ieee80211_smps_mode smps_mode;\r\nlockdep_assert_held(&mvm->mutex);\r\nif (mvm->thermal_throttle.dynamic_smps)\r\nsmps_mode = IEEE80211_SMPS_DYNAMIC;\r\nelse\r\nsmps_mode = IEEE80211_SMPS_AUTOMATIC;\r\nif (vif->type != NL80211_IFTYPE_STATION)\r\nreturn;\r\niwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_TT, smps_mode);\r\n}\r\nstatic void iwl_mvm_tt_tx_protection(struct iwl_mvm *mvm, bool enable)\r\n{\r\nstruct iwl_mvm_sta *mvmsta;\r\nint i, err;\r\nfor (i = 0; i < IWL_MVM_STATION_COUNT; i++) {\r\nmvmsta = iwl_mvm_sta_from_staid_protected(mvm, i);\r\nif (!mvmsta)\r\ncontinue;\r\nif (enable == mvmsta->tt_tx_protection)\r\ncontinue;\r\nerr = iwl_mvm_tx_protection(mvm, mvmsta, enable);\r\nif (err) {\r\nIWL_ERR(mvm, "Failed to %s Tx protection\n",\r\nenable ? "enable" : "disable");\r\n} else {\r\nIWL_DEBUG_TEMP(mvm, "%s Tx protection\n",\r\nenable ? "Enable" : "Disable");\r\nmvmsta->tt_tx_protection = enable;\r\n}\r\n}\r\n}\r\nvoid iwl_mvm_tt_tx_backoff(struct iwl_mvm *mvm, u32 backoff)\r\n{\r\nstruct iwl_host_cmd cmd = {\r\n.id = REPLY_THERMAL_MNG_BACKOFF,\r\n.len = { sizeof(u32), },\r\n.data = { &backoff, },\r\n};\r\nbackoff = max(backoff, mvm->thermal_throttle.min_backoff);\r\nif (iwl_mvm_send_cmd(mvm, &cmd) == 0) {\r\nIWL_DEBUG_TEMP(mvm, "Set Thermal Tx backoff to: %u\n",\r\nbackoff);\r\nmvm->thermal_throttle.tx_backoff = backoff;\r\n} else {\r\nIWL_ERR(mvm, "Failed to change Thermal Tx backoff\n");\r\n}\r\n}\r\nvoid iwl_mvm_tt_handler(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_tt_params *params = &mvm->thermal_throttle.params;\r\nstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\r\ns32 temperature = mvm->temperature;\r\nbool throttle_enable = false;\r\nint i;\r\nu32 tx_backoff;\r\nIWL_DEBUG_TEMP(mvm, "NIC temperature: %d\n", mvm->temperature);\r\nif (params->support_ct_kill && temperature >= params->ct_kill_entry) {\r\niwl_mvm_enter_ctkill(mvm);\r\nreturn;\r\n}\r\nif (params->support_ct_kill &&\r\ntemperature <= params->ct_kill_exit) {\r\niwl_mvm_exit_ctkill(mvm);\r\nreturn;\r\n}\r\nif (params->support_dynamic_smps) {\r\nif (!tt->dynamic_smps &&\r\ntemperature >= params->dynamic_smps_entry) {\r\nIWL_DEBUG_TEMP(mvm, "Enable dynamic SMPS\n");\r\ntt->dynamic_smps = true;\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_tt_smps_iterator, mvm);\r\nthrottle_enable = true;\r\n} else if (tt->dynamic_smps &&\r\ntemperature <= params->dynamic_smps_exit) {\r\nIWL_DEBUG_TEMP(mvm, "Disable dynamic SMPS\n");\r\ntt->dynamic_smps = false;\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_tt_smps_iterator, mvm);\r\n}\r\n}\r\nif (params->support_tx_protection) {\r\nif (temperature >= params->tx_protection_entry) {\r\niwl_mvm_tt_tx_protection(mvm, true);\r\nthrottle_enable = true;\r\n} else if (temperature <= params->tx_protection_exit) {\r\niwl_mvm_tt_tx_protection(mvm, false);\r\n}\r\n}\r\nif (params->support_tx_backoff) {\r\ntx_backoff = tt->min_backoff;\r\nfor (i = 0; i < TT_TX_BACKOFF_SIZE; i++) {\r\nif (temperature < params->tx_backoff[i].temperature)\r\nbreak;\r\ntx_backoff = max(tt->min_backoff,\r\nparams->tx_backoff[i].backoff);\r\n}\r\nif (tx_backoff != tt->min_backoff)\r\nthrottle_enable = true;\r\nif (tt->tx_backoff != tx_backoff)\r\niwl_mvm_tt_tx_backoff(mvm, tx_backoff);\r\n}\r\nif (!tt->throttle && throttle_enable) {\r\nIWL_WARN(mvm,\r\n"Due to high temperature thermal throttling initiated\n");\r\ntt->throttle = true;\r\n} else if (tt->throttle && !tt->dynamic_smps &&\r\ntt->tx_backoff == tt->min_backoff &&\r\ntemperature <= params->tx_protection_exit) {\r\nIWL_WARN(mvm,\r\n"Temperature is back to normal thermal throttling stopped\n");\r\ntt->throttle = false;\r\n}\r\n}\r\nint iwl_mvm_ctdp_command(struct iwl_mvm *mvm, u32 op, u32 state)\r\n{\r\nstruct iwl_mvm_ctdp_cmd cmd = {\r\n.operation = cpu_to_le32(op),\r\n.budget = cpu_to_le32(iwl_mvm_cdev_budgets[state]),\r\n.window_size = 0,\r\n};\r\nint ret;\r\nu32 status;\r\nlockdep_assert_held(&mvm->mutex);\r\nret = iwl_mvm_send_cmd_pdu_status(mvm, WIDE_ID(PHY_OPS_GROUP,\r\nCTDP_CONFIG_CMD),\r\nsizeof(cmd), &cmd, &status);\r\nif (ret) {\r\nIWL_ERR(mvm, "cTDP command failed (err=%d)\n", ret);\r\nreturn ret;\r\n}\r\nswitch (op) {\r\ncase CTDP_CMD_OPERATION_START:\r\n#ifdef CONFIG_THERMAL\r\nmvm->cooling_dev.cur_state = state;\r\n#endif\r\nbreak;\r\ncase CTDP_CMD_OPERATION_REPORT:\r\nIWL_DEBUG_TEMP(mvm, "cTDP avg energy in mWatt = %d\n", status);\r\nreturn status;\r\ncase CTDP_CMD_OPERATION_STOP:\r\nIWL_DEBUG_TEMP(mvm, "cTDP stopped successfully\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int compare_temps(const void *a, const void *b)\r\n{\r\nreturn ((s16)le16_to_cpu(*(__le16 *)a) -\r\n(s16)le16_to_cpu(*(__le16 *)b));\r\n}\r\nint iwl_mvm_send_temp_report_ths_cmd(struct iwl_mvm *mvm)\r\n{\r\nstruct temp_report_ths_cmd cmd = {0};\r\nint ret, i, j, idx = 0;\r\nlockdep_assert_held(&mvm->mutex);\r\nif (!mvm->tz_device.tzone)\r\nreturn -EINVAL;\r\nfor (i = 0; i < IWL_MAX_DTS_TRIPS; i++) {\r\nif (mvm->tz_device.temp_trips[i] != S16_MIN) {\r\ncmd.thresholds[idx++] =\r\ncpu_to_le16(mvm->tz_device.temp_trips[i]);\r\n}\r\n}\r\ncmd.num_temps = cpu_to_le32(idx);\r\nif (!idx)\r\ngoto send;\r\nsort(cmd.thresholds, idx, sizeof(s16), compare_temps, NULL);\r\nfor (i = 0; i < idx; i++) {\r\nfor (j = 0; j < IWL_MAX_DTS_TRIPS; j++) {\r\nif (le16_to_cpu(cmd.thresholds[i]) ==\r\nmvm->tz_device.temp_trips[j])\r\nmvm->tz_device.fw_trips_index[i] = j;\r\n}\r\n}\r\nsend:\r\nret = iwl_mvm_send_cmd_pdu(mvm, WIDE_ID(PHY_OPS_GROUP,\r\nTEMP_REPORTING_THRESHOLDS_CMD),\r\n0, sizeof(cmd), &cmd);\r\nif (ret)\r\nIWL_ERR(mvm, "TEMP_REPORT_THS_CMD command failed (err=%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic int iwl_mvm_tzone_get_temp(struct thermal_zone_device *device,\r\nint *temperature)\r\n{\r\nstruct iwl_mvm *mvm = (struct iwl_mvm *)device->devdata;\r\nint ret;\r\nint temp;\r\nmutex_lock(&mvm->mutex);\r\nif (!mvm->ucode_loaded || !(mvm->cur_ucode == IWL_UCODE_REGULAR)) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret = iwl_mvm_get_temp(mvm, &temp);\r\nif (ret)\r\ngoto out;\r\n*temperature = temp * 1000;\r\nout:\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret;\r\n}\r\nstatic int iwl_mvm_tzone_get_trip_temp(struct thermal_zone_device *device,\r\nint trip, int *temp)\r\n{\r\nstruct iwl_mvm *mvm = (struct iwl_mvm *)device->devdata;\r\nif (trip < 0 || trip >= IWL_MAX_DTS_TRIPS)\r\nreturn -EINVAL;\r\n*temp = mvm->tz_device.temp_trips[trip] * 1000;\r\nreturn 0;\r\n}\r\nstatic int iwl_mvm_tzone_get_trip_type(struct thermal_zone_device *device,\r\nint trip, enum thermal_trip_type *type)\r\n{\r\nif (trip < 0 || trip >= IWL_MAX_DTS_TRIPS)\r\nreturn -EINVAL;\r\n*type = THERMAL_TRIP_PASSIVE;\r\nreturn 0;\r\n}\r\nstatic int iwl_mvm_tzone_set_trip_temp(struct thermal_zone_device *device,\r\nint trip, int temp)\r\n{\r\nstruct iwl_mvm *mvm = (struct iwl_mvm *)device->devdata;\r\nstruct iwl_mvm_thermal_device *tzone;\r\nint i, ret;\r\ns16 temperature;\r\nmutex_lock(&mvm->mutex);\r\nif (!mvm->ucode_loaded || !(mvm->cur_ucode == IWL_UCODE_REGULAR)) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (trip < 0 || trip >= IWL_MAX_DTS_TRIPS) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif ((temp / 1000) > S16_MAX) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntemperature = (s16)(temp / 1000);\r\ntzone = &mvm->tz_device;\r\nif (!tzone) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (tzone->temp_trips[trip] == temperature) {\r\nret = 0;\r\ngoto out;\r\n}\r\nfor (i = 0; i < IWL_MAX_DTS_TRIPS; i++) {\r\nif (tzone->temp_trips[i] == temperature) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\ntzone->temp_trips[trip] = temperature;\r\nret = iwl_mvm_send_temp_report_ths_cmd(mvm);\r\nout:\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret;\r\n}\r\nstatic void iwl_mvm_thermal_zone_register(struct iwl_mvm *mvm)\r\n{\r\nint i;\r\nchar name[] = "iwlwifi";\r\nif (!iwl_mvm_is_tt_in_fw(mvm)) {\r\nmvm->tz_device.tzone = NULL;\r\nreturn;\r\n}\r\nBUILD_BUG_ON(ARRAY_SIZE(name) >= THERMAL_NAME_LENGTH);\r\nmvm->tz_device.tzone = thermal_zone_device_register(name,\r\nIWL_MAX_DTS_TRIPS,\r\nIWL_WRITABLE_TRIPS_MSK,\r\nmvm, &tzone_ops,\r\nNULL, 0, 0);\r\nif (IS_ERR(mvm->tz_device.tzone)) {\r\nIWL_DEBUG_TEMP(mvm,\r\n"Failed to register to thermal zone (err = %ld)\n",\r\nPTR_ERR(mvm->tz_device.tzone));\r\nmvm->tz_device.tzone = NULL;\r\nreturn;\r\n}\r\nfor (i = 0 ; i < IWL_MAX_DTS_TRIPS; i++)\r\nmvm->tz_device.temp_trips[i] = S16_MIN;\r\n}\r\nstatic int iwl_mvm_tcool_get_max_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\n*state = ARRAY_SIZE(iwl_mvm_cdev_budgets) - 1;\r\nreturn 0;\r\n}\r\nstatic int iwl_mvm_tcool_get_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct iwl_mvm *mvm = (struct iwl_mvm *)(cdev->devdata);\r\n*state = mvm->cooling_dev.cur_state;\r\nreturn 0;\r\n}\r\nstatic int iwl_mvm_tcool_set_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long new_state)\r\n{\r\nstruct iwl_mvm *mvm = (struct iwl_mvm *)(cdev->devdata);\r\nint ret;\r\nif (!mvm->ucode_loaded || !(mvm->cur_ucode == IWL_UCODE_REGULAR))\r\nreturn -EIO;\r\nmutex_lock(&mvm->mutex);\r\nif (new_state >= ARRAY_SIZE(iwl_mvm_cdev_budgets)) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nret = iwl_mvm_ctdp_command(mvm, CTDP_CMD_OPERATION_START,\r\nnew_state);\r\nunlock:\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret;\r\n}\r\nstatic void iwl_mvm_cooling_device_register(struct iwl_mvm *mvm)\r\n{\r\nchar name[] = "iwlwifi";\r\nif (!iwl_mvm_is_ctdp_supported(mvm))\r\nreturn;\r\nBUILD_BUG_ON(ARRAY_SIZE(name) >= THERMAL_NAME_LENGTH);\r\nmvm->cooling_dev.cdev =\r\nthermal_cooling_device_register(name,\r\nmvm,\r\n&tcooling_ops);\r\nif (IS_ERR(mvm->cooling_dev.cdev)) {\r\nIWL_DEBUG_TEMP(mvm,\r\n"Failed to register to cooling device (err = %ld)\n",\r\nPTR_ERR(mvm->cooling_dev.cdev));\r\nmvm->cooling_dev.cdev = NULL;\r\nreturn;\r\n}\r\n}\r\nstatic void iwl_mvm_thermal_zone_unregister(struct iwl_mvm *mvm)\r\n{\r\nif (!iwl_mvm_is_tt_in_fw(mvm) || !mvm->tz_device.tzone)\r\nreturn;\r\nIWL_DEBUG_TEMP(mvm, "Thermal zone device unregister\n");\r\nthermal_zone_device_unregister(mvm->tz_device.tzone);\r\nmvm->tz_device.tzone = NULL;\r\n}\r\nstatic void iwl_mvm_cooling_device_unregister(struct iwl_mvm *mvm)\r\n{\r\nif (!iwl_mvm_is_ctdp_supported(mvm) || !mvm->cooling_dev.cdev)\r\nreturn;\r\nIWL_DEBUG_TEMP(mvm, "Cooling device unregister\n");\r\nthermal_cooling_device_unregister(mvm->cooling_dev.cdev);\r\nmvm->cooling_dev.cdev = NULL;\r\n}\r\nvoid iwl_mvm_thermal_initialize(struct iwl_mvm *mvm, u32 min_backoff)\r\n{\r\nstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\r\nIWL_DEBUG_TEMP(mvm, "Initialize Thermal Throttling\n");\r\nif (mvm->cfg->thermal_params)\r\ntt->params = *mvm->cfg->thermal_params;\r\nelse\r\ntt->params = iwl_mvm_default_tt_params;\r\ntt->throttle = false;\r\ntt->dynamic_smps = false;\r\ntt->min_backoff = min_backoff;\r\nINIT_DELAYED_WORK(&tt->ct_kill_exit, check_exit_ctkill);\r\n#ifdef CONFIG_THERMAL\r\niwl_mvm_cooling_device_register(mvm);\r\niwl_mvm_thermal_zone_register(mvm);\r\n#endif\r\n}\r\nvoid iwl_mvm_thermal_exit(struct iwl_mvm *mvm)\r\n{\r\ncancel_delayed_work_sync(&mvm->thermal_throttle.ct_kill_exit);\r\nIWL_DEBUG_TEMP(mvm, "Exit Thermal Throttling\n");\r\n#ifdef CONFIG_THERMAL\r\niwl_mvm_cooling_device_unregister(mvm);\r\niwl_mvm_thermal_zone_unregister(mvm);\r\n#endif\r\n}
