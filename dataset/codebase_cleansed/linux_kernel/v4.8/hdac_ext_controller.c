int snd_hdac_ext_bus_parse_capabilities(struct hdac_ext_bus *ebus)\r\n{\r\nunsigned int cur_cap;\r\nunsigned int offset;\r\nstruct hdac_bus *bus = &ebus->bus;\r\nunsigned int counter = 0;\r\noffset = snd_hdac_chip_readl(bus, LLCH);\r\ndo {\r\ncur_cap = _snd_hdac_chip_read(l, bus, offset);\r\ndev_dbg(bus->dev, "Capability version: 0x%x\n",\r\n((cur_cap & AZX_CAP_HDR_VER_MASK) >> AZX_CAP_HDR_VER_OFF));\r\ndev_dbg(bus->dev, "HDA capability ID: 0x%x\n",\r\n(cur_cap & AZX_CAP_HDR_ID_MASK) >> AZX_CAP_HDR_ID_OFF);\r\nswitch ((cur_cap & AZX_CAP_HDR_ID_MASK) >> AZX_CAP_HDR_ID_OFF) {\r\ncase AZX_ML_CAP_ID:\r\ndev_dbg(bus->dev, "Found ML capability\n");\r\nebus->mlcap = bus->remap_addr + offset;\r\nbreak;\r\ncase AZX_GTS_CAP_ID:\r\ndev_dbg(bus->dev, "Found GTS capability offset=%x\n", offset);\r\nebus->gtscap = bus->remap_addr + offset;\r\nbreak;\r\ncase AZX_PP_CAP_ID:\r\ndev_dbg(bus->dev, "Found PP capability offset=%x\n", offset);\r\nebus->ppcap = bus->remap_addr + offset;\r\nbreak;\r\ncase AZX_SPB_CAP_ID:\r\ndev_dbg(bus->dev, "Found SPB capability\n");\r\nebus->spbcap = bus->remap_addr + offset;\r\nbreak;\r\ncase AZX_DRSM_CAP_ID:\r\ndev_dbg(bus->dev, "Found DRSM capability\n");\r\nebus->drsmcap = bus->remap_addr + offset;\r\nbreak;\r\ndefault:\r\ndev_dbg(bus->dev, "Unknown capability %d\n", cur_cap);\r\nbreak;\r\n}\r\ncounter++;\r\nif (counter > HDAC_MAX_CAPS) {\r\ndev_err(bus->dev, "We exceeded HDAC Ext capablities!!!\n");\r\nbreak;\r\n}\r\noffset = cur_cap & AZX_CAP_HDR_NXT_PTR_MASK;\r\n} while (offset);\r\nreturn 0;\r\n}\r\nvoid snd_hdac_ext_bus_ppcap_enable(struct hdac_ext_bus *ebus, bool enable)\r\n{\r\nstruct hdac_bus *bus = &ebus->bus;\r\nif (!ebus->ppcap) {\r\ndev_err(bus->dev, "Address of PP capability is NULL");\r\nreturn;\r\n}\r\nif (enable)\r\nsnd_hdac_updatel(ebus->ppcap, AZX_REG_PP_PPCTL, 0, AZX_PPCTL_GPROCEN);\r\nelse\r\nsnd_hdac_updatel(ebus->ppcap, AZX_REG_PP_PPCTL, AZX_PPCTL_GPROCEN, 0);\r\n}\r\nvoid snd_hdac_ext_bus_ppcap_int_enable(struct hdac_ext_bus *ebus, bool enable)\r\n{\r\nstruct hdac_bus *bus = &ebus->bus;\r\nif (!ebus->ppcap) {\r\ndev_err(bus->dev, "Address of PP capability is NULL\n");\r\nreturn;\r\n}\r\nif (enable)\r\nsnd_hdac_updatel(ebus->ppcap, AZX_REG_PP_PPCTL, 0, AZX_PPCTL_PIE);\r\nelse\r\nsnd_hdac_updatel(ebus->ppcap, AZX_REG_PP_PPCTL, AZX_PPCTL_PIE, 0);\r\n}\r\nint snd_hdac_ext_bus_get_ml_capabilities(struct hdac_ext_bus *ebus)\r\n{\r\nint idx;\r\nu32 link_count;\r\nstruct hdac_ext_link *hlink;\r\nstruct hdac_bus *bus = &ebus->bus;\r\nlink_count = readl(ebus->mlcap + AZX_REG_ML_MLCD) + 1;\r\ndev_dbg(bus->dev, "In %s Link count: %d\n", __func__, link_count);\r\nfor (idx = 0; idx < link_count; idx++) {\r\nhlink = kzalloc(sizeof(*hlink), GFP_KERNEL);\r\nif (!hlink)\r\nreturn -ENOMEM;\r\nhlink->index = idx;\r\nhlink->bus = bus;\r\nhlink->ml_addr = ebus->mlcap + AZX_ML_BASE +\r\n(AZX_ML_INTERVAL * idx);\r\nhlink->lcaps = readl(hlink->ml_addr + AZX_REG_ML_LCAP);\r\nhlink->lsdiid = readw(hlink->ml_addr + AZX_REG_ML_LSDIID);\r\nhlink->ref_count = 1;\r\nlist_add_tail(&hlink->list, &ebus->hlink_list);\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_hdac_link_free_all(struct hdac_ext_bus *ebus)\r\n{\r\nstruct hdac_ext_link *l;\r\nwhile (!list_empty(&ebus->hlink_list)) {\r\nl = list_first_entry(&ebus->hlink_list, struct hdac_ext_link, list);\r\nlist_del(&l->list);\r\nkfree(l);\r\n}\r\n}\r\nstruct hdac_ext_link *snd_hdac_ext_bus_get_link(struct hdac_ext_bus *ebus,\r\nconst char *codec_name)\r\n{\r\nint i;\r\nstruct hdac_ext_link *hlink = NULL;\r\nint bus_idx, addr;\r\nif (sscanf(codec_name, "ehdaudio%dD%d", &bus_idx, &addr) != 2)\r\nreturn NULL;\r\nif (ebus->idx != bus_idx)\r\nreturn NULL;\r\nlist_for_each_entry(hlink, &ebus->hlink_list, list) {\r\nfor (i = 0; i < HDA_MAX_CODECS; i++) {\r\nif (hlink->lsdiid & (0x1 << addr))\r\nreturn hlink;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int check_hdac_link_power_active(struct hdac_ext_link *link, bool enable)\r\n{\r\nint timeout;\r\nu32 val;\r\nint mask = (1 << AZX_MLCTL_CPA);\r\nudelay(3);\r\ntimeout = 150;\r\ndo {\r\nval = readl(link->ml_addr + AZX_REG_ML_LCTL);\r\nif (enable) {\r\nif (((val & mask) >> AZX_MLCTL_CPA))\r\nreturn 0;\r\n} else {\r\nif (!((val & mask) >> AZX_MLCTL_CPA))\r\nreturn 0;\r\n}\r\nudelay(3);\r\n} while (--timeout);\r\nreturn -EIO;\r\n}\r\nint snd_hdac_ext_bus_link_power_up(struct hdac_ext_link *link)\r\n{\r\nsnd_hdac_updatel(link->ml_addr, AZX_REG_ML_LCTL, 0, AZX_MLCTL_SPA);\r\nreturn check_hdac_link_power_active(link, true);\r\n}\r\nint snd_hdac_ext_bus_link_power_down(struct hdac_ext_link *link)\r\n{\r\nsnd_hdac_updatel(link->ml_addr, AZX_REG_ML_LCTL, AZX_MLCTL_SPA, 0);\r\nreturn check_hdac_link_power_active(link, false);\r\n}\r\nint snd_hdac_ext_bus_link_power_up_all(struct hdac_ext_bus *ebus)\r\n{\r\nstruct hdac_ext_link *hlink = NULL;\r\nint ret;\r\nlist_for_each_entry(hlink, &ebus->hlink_list, list) {\r\nsnd_hdac_updatel(hlink->ml_addr,\r\nAZX_REG_ML_LCTL, 0, AZX_MLCTL_SPA);\r\nret = check_hdac_link_power_active(hlink, true);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint snd_hdac_ext_bus_link_power_down_all(struct hdac_ext_bus *ebus)\r\n{\r\nstruct hdac_ext_link *hlink = NULL;\r\nint ret;\r\nlist_for_each_entry(hlink, &ebus->hlink_list, list) {\r\nsnd_hdac_updatel(hlink->ml_addr, AZX_REG_ML_LCTL, AZX_MLCTL_SPA, 0);\r\nret = check_hdac_link_power_active(hlink, false);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint snd_hdac_ext_bus_link_get(struct hdac_ext_bus *ebus,\r\nstruct hdac_ext_link *link)\r\n{\r\nint ret = 0;\r\nmutex_lock(&ebus->lock);\r\nif (++link->ref_count == 1) {\r\nif (!ebus->cmd_dma_state) {\r\nsnd_hdac_bus_init_cmd_io(&ebus->bus);\r\nebus->cmd_dma_state = true;\r\n}\r\nret = snd_hdac_ext_bus_link_power_up(link);\r\n}\r\nmutex_unlock(&ebus->lock);\r\nreturn ret;\r\n}\r\nint snd_hdac_ext_bus_link_put(struct hdac_ext_bus *ebus,\r\nstruct hdac_ext_link *link)\r\n{\r\nint ret = 0;\r\nstruct hdac_ext_link *hlink;\r\nbool link_up = false;\r\nmutex_lock(&ebus->lock);\r\nif (--link->ref_count == 0) {\r\nret = snd_hdac_ext_bus_link_power_down(link);\r\nlist_for_each_entry(hlink, &ebus->hlink_list, list) {\r\nif (hlink->ref_count) {\r\nlink_up = true;\r\nbreak;\r\n}\r\n}\r\nif (!link_up) {\r\nsnd_hdac_bus_stop_cmd_io(&ebus->bus);\r\nebus->cmd_dma_state = false;\r\n}\r\n}\r\nmutex_unlock(&ebus->lock);\r\nreturn ret;\r\n}
