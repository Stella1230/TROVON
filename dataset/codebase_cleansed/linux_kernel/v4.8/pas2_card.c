unsigned char pas_read(int ioaddr)\r\n{\r\nreturn inb(ioaddr + pas_translate_code);\r\n}\r\nvoid pas_write(unsigned char data, int ioaddr)\r\n{\r\noutb((data), ioaddr + pas_translate_code);\r\n}\r\nstatic irqreturn_t pasintr(int irq, void *dev_id)\r\n{\r\nint status;\r\nstatus = pas_read(0x0B89);\r\npas_write(status, 0x0B89);\r\nif (status & 0x08)\r\n{\r\npas_pcm_interrupt(status, 1);\r\nstatus &= ~0x08;\r\n}\r\nif (status & 0x10)\r\n{\r\npas_midi_interrupt();\r\nstatus &= ~0x10;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint pas_set_intr(int mask)\r\n{\r\nif (!mask)\r\nreturn 0;\r\npas_intr_mask |= mask;\r\npas_write(pas_intr_mask, 0x0B8B);\r\nreturn 0;\r\n}\r\nint pas_remove_intr(int mask)\r\n{\r\nif (!mask)\r\nreturn 0;\r\npas_intr_mask &= ~mask;\r\npas_write(pas_intr_mask, 0x0B8B);\r\nreturn 0;\r\n}\r\nstatic int __init config_pas_hw(struct address_info *hw_config)\r\n{\r\nchar ok = 1;\r\nunsigned int_ptrs;\r\npas_irq = hw_config->irq;\r\npas_write(0x00, 0x0B8B);\r\npas_write(0x36, 0x138B);\r\npas_write(0x36, 0x1388);\r\npas_write(0, 0x1388);\r\npas_write(0x74, 0x138B);\r\npas_write(0x74, 0x1389);\r\npas_write(0, 0x1389);\r\npas_write(0x80 | 0x40 | 0x20 | 1, 0x0B8A);\r\npas_write(0x80 | 0x20 | 0x10 | 0x08 | 0x01, 0xF8A);\r\npas_write(0x01 | 0x02 | 0x04 | 0x10 , 0xB88);\r\npas_write(0x80 | (joystick ? 0x40 : 0), 0xF388);\r\nif (pas_irq < 0 || pas_irq > 15)\r\n{\r\nprintk(KERN_ERR "PAS16: Invalid IRQ %d", pas_irq);\r\nhw_config->irq=-1;\r\nok = 0;\r\n}\r\nelse\r\n{\r\nint_ptrs = pas_read(0xF38A);\r\nint_ptrs = (int_ptrs & 0xf0) | irq_bits[pas_irq];\r\npas_write(int_ptrs, 0xF38A);\r\nif (!irq_bits[pas_irq])\r\n{\r\nprintk(KERN_ERR "PAS16: Invalid IRQ %d", pas_irq);\r\nhw_config->irq=-1;\r\nok = 0;\r\n}\r\nelse\r\n{\r\nif (request_irq(pas_irq, pasintr, 0, "PAS16",hw_config) < 0) {\r\nprintk(KERN_ERR "PAS16: Cannot allocate IRQ %d\n",pas_irq);\r\nhw_config->irq=-1;\r\nok = 0;\r\n}\r\n}\r\n}\r\nif (hw_config->dma < 0 || hw_config->dma > 7)\r\n{\r\nprintk(KERN_ERR "PAS16: Invalid DMA selection %d", hw_config->dma);\r\nhw_config->dma=-1;\r\nok = 0;\r\n}\r\nelse\r\n{\r\npas_write(dma_bits[hw_config->dma], 0xF389);\r\nif (!dma_bits[hw_config->dma])\r\n{\r\nprintk(KERN_ERR "PAS16: Invalid DMA selection %d", hw_config->dma);\r\nhw_config->dma=-1;\r\nok = 0;\r\n}\r\nelse\r\n{\r\nif (sound_alloc_dma(hw_config->dma, "PAS16"))\r\n{\r\nprintk(KERN_ERR "pas2_card.c: Can't allocate DMA channel\n");\r\nhw_config->dma=-1;\r\nok = 0;\r\n}\r\n}\r\n}\r\nif(symphony)\r\n{\r\noutb((0x05), 0xa8);\r\noutb((0x60), 0xa9);\r\n}\r\nif(broken_bus_clock)\r\npas_write(0x01 | 0x10 | 0x20 | 0x04, 0x8388);\r\nelse\r\npas_write(0x01 | 0x10 | 0x20, 0x8388);\r\npas_write(0x18, 0x838A);\r\npas_write(0x20 | 0x01, 0x0B8A);\r\npas_write(8, 0xBF8A);\r\nmix_write(0x80 | 5, 0x078B);\r\nmix_write(5, 0x078B);\r\n{\r\nstruct address_info *sb_config;\r\nsb_config = &cfg2;\r\nif (sb_config->io_base)\r\n{\r\nunsigned char irq_dma;\r\npas_write(0x02, 0xF788);\r\npas_write((sb_config->io_base >> 4) & 0x0f, 0xF789);\r\npas_sb_base = sb_config->io_base;\r\nif (!sb_dma_bits[sb_config->dma])\r\nprintk(KERN_ERR "PAS16 Warning: Invalid SB DMA %d\n\n", sb_config->dma);\r\nif (!sb_irq_bits[sb_config->irq])\r\nprintk(KERN_ERR "PAS16 Warning: Invalid SB IRQ %d\n\n", sb_config->irq);\r\nirq_dma = sb_dma_bits[sb_config->dma] |\r\nsb_irq_bits[sb_config->irq];\r\npas_write(irq_dma, 0xFB8A);\r\n}\r\nelse\r\npas_write(0x00, 0xF788);\r\n}\r\nif (!ok)\r\nprintk(KERN_WARNING "PAS16: Driver not enabled\n");\r\nreturn ok;\r\n}\r\nstatic int __init detect_pas_hw(struct address_info *hw_config)\r\n{\r\nunsigned char board_id, foo;\r\noutb((0xBC), 0x9A01);\r\noutb((hw_config->io_base >> 2), 0x9A01);\r\npas_translate_code = hw_config->io_base - 0x388;\r\npas_write(1, 0xBF88);\r\nboard_id = pas_read(0x0B8B);\r\nif (board_id == 0xff)\r\nreturn 0;\r\nfoo = board_id ^ 0xe0;\r\npas_write(foo, 0x0B8B);\r\nfoo = pas_read(0x0B8B);\r\npas_write(board_id, 0x0B8B);\r\nif (board_id != foo)\r\nreturn 0;\r\npas_model = pas_read(0xFF88);\r\nreturn pas_model;\r\n}\r\nstatic void __init attach_pas_card(struct address_info *hw_config)\r\n{\r\npas_irq = hw_config->irq;\r\nif (detect_pas_hw(hw_config))\r\n{\r\nif ((pas_model = pas_read(0xFF88)))\r\n{\r\nchar temp[100];\r\nif (pas_model < 0 ||\r\npas_model >= ARRAY_SIZE(pas_model_names)) {\r\nprintk(KERN_ERR "pas2 unrecognized model.\n");\r\nreturn;\r\n}\r\nsprintf(temp,\r\n"%s rev %d", pas_model_names[(int) pas_model],\r\npas_read(0x2789));\r\nconf_printf(temp, hw_config);\r\n}\r\nif (config_pas_hw(hw_config))\r\n{\r\npas_pcm_init(hw_config);\r\npas_midi_init();\r\npas_init_mixer();\r\n}\r\n}\r\n}\r\nstatic inline int __init probe_pas(struct address_info *hw_config)\r\n{\r\nreturn detect_pas_hw(hw_config);\r\n}\r\nstatic void __exit unload_pas(struct address_info *hw_config)\r\n{\r\nextern int pas_audiodev;\r\nextern int pas2_mididev;\r\nif (hw_config->dma>0)\r\nsound_free_dma(hw_config->dma);\r\nif (hw_config->irq>0)\r\nfree_irq(hw_config->irq, hw_config);\r\nif(pas_audiodev!=-1)\r\nsound_unload_mixerdev(audio_devs[pas_audiodev]->mixer_dev);\r\nif(pas2_mididev!=-1)\r\nsound_unload_mididev(pas2_mididev);\r\nif(pas_audiodev!=-1)\r\nsound_unload_audiodev(pas_audiodev);\r\n}\r\nstatic int __init init_pas2(void)\r\n{\r\nprintk(KERN_INFO "Pro Audio Spectrum driver Copyright (C) by Hannu Savolainen 1993-1996\n");\r\ncfg.io_base = io;\r\ncfg.irq = irq;\r\ncfg.dma = dma;\r\ncfg.dma2 = dma16;\r\ncfg2.io_base = sb_io;\r\ncfg2.irq = sb_irq;\r\ncfg2.dma = sb_dma;\r\ncfg2.dma2 = sb_dma16;\r\nif (cfg.io_base == -1 || cfg.dma == -1 || cfg.irq == -1) {\r\nprintk(KERN_INFO "I/O, IRQ, DMA and type are mandatory\n");\r\nreturn -EINVAL;\r\n}\r\nif (!probe_pas(&cfg))\r\nreturn -ENODEV;\r\nattach_pas_card(&cfg);\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_pas2(void)\r\n{\r\nunload_pas(&cfg);\r\n}\r\nstatic int __init setup_pas2(char *str)\r\n{\r\nint ints[9];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nio = ints[1];\r\nirq = ints[2];\r\ndma = ints[3];\r\ndma16 = ints[4];\r\nsb_io = ints[5];\r\nsb_irq = ints[6];\r\nsb_dma = ints[7];\r\nsb_dma16 = ints[8];\r\nreturn 1;\r\n}
