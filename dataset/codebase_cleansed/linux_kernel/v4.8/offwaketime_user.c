static void print_ksym(__u64 addr)\r\n{\r\nstruct ksym *sym;\r\nif (!addr)\r\nreturn;\r\nsym = ksym_search(addr);\r\nif (PRINT_RAW_ADDR)\r\nprintf("%s/%llx;", sym->name, addr);\r\nelse\r\nprintf("%s;", sym->name);\r\n}\r\nstatic void print_stack(struct key_t *key, __u64 count)\r\n{\r\n__u64 ip[PERF_MAX_STACK_DEPTH] = {};\r\nstatic bool warned;\r\nint i;\r\nprintf("%s;", key->target);\r\nif (bpf_lookup_elem(map_fd[3], &key->tret, ip) != 0) {\r\nprintf("---;");\r\n} else {\r\nfor (i = PERF_MAX_STACK_DEPTH - 1; i >= 0; i--)\r\nprint_ksym(ip[i]);\r\n}\r\nprintf("-;");\r\nif (bpf_lookup_elem(map_fd[3], &key->wret, ip) != 0) {\r\nprintf("---;");\r\n} else {\r\nfor (i = 0; i < PERF_MAX_STACK_DEPTH; i++)\r\nprint_ksym(ip[i]);\r\n}\r\nprintf(";%s %lld\n", key->waker, count);\r\nif ((key->tret == -EEXIST || key->wret == -EEXIST) && !warned) {\r\nprintf("stackmap collisions seen. Consider increasing size\n");\r\nwarned = true;\r\n} else if (((int)(key->tret) < 0 || (int)(key->wret) < 0)) {\r\nprintf("err stackid %d %d\n", key->tret, key->wret);\r\n}\r\n}\r\nstatic void print_stacks(int fd)\r\n{\r\nstruct key_t key = {}, next_key;\r\n__u64 value;\r\nwhile (bpf_get_next_key(fd, &key, &next_key) == 0) {\r\nbpf_lookup_elem(fd, &next_key, &value);\r\nprint_stack(&next_key, value);\r\nkey = next_key;\r\n}\r\n}\r\nstatic void int_exit(int sig)\r\n{\r\nprint_stacks(map_fd[0]);\r\nexit(0);\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nstruct rlimit r = {RLIM_INFINITY, RLIM_INFINITY};\r\nchar filename[256];\r\nint delay = 1;\r\nsnprintf(filename, sizeof(filename), "%s_kern.o", argv[0]);\r\nsetrlimit(RLIMIT_MEMLOCK, &r);\r\nsignal(SIGINT, int_exit);\r\nif (load_kallsyms()) {\r\nprintf("failed to process /proc/kallsyms\n");\r\nreturn 2;\r\n}\r\nif (load_bpf_file(filename)) {\r\nprintf("%s", bpf_log_buf);\r\nreturn 1;\r\n}\r\nif (argc > 1)\r\ndelay = atoi(argv[1]);\r\nsleep(delay);\r\nprint_stacks(map_fd[0]);\r\nreturn 0;\r\n}
