static void public_key_describe(const struct key *asymmetric_key,\r\nstruct seq_file *m)\r\n{\r\nstruct public_key *key = asymmetric_key->payload.data[asym_crypto];\r\nif (key)\r\nseq_printf(m, "%s.%s", key->id_type, key->pkey_algo);\r\n}\r\nvoid public_key_free(struct public_key *key)\r\n{\r\nif (key) {\r\nkfree(key->key);\r\nkfree(key);\r\n}\r\n}\r\nstatic void public_key_destroy(void *payload0, void *payload3)\r\n{\r\npublic_key_free(payload0);\r\npublic_key_signature_free(payload3);\r\n}\r\nstatic void public_key_verify_done(struct crypto_async_request *req, int err)\r\n{\r\nstruct public_key_completion *compl = req->data;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\ncompl->err = err;\r\ncomplete(&compl->completion);\r\n}\r\nint public_key_verify_signature(const struct public_key *pkey,\r\nconst struct public_key_signature *sig)\r\n{\r\nstruct public_key_completion compl;\r\nstruct crypto_akcipher *tfm;\r\nstruct akcipher_request *req;\r\nstruct scatterlist sig_sg, digest_sg;\r\nconst char *alg_name;\r\nchar alg_name_buf[CRYPTO_MAX_ALG_NAME];\r\nvoid *output;\r\nunsigned int outlen;\r\nint ret = -ENOMEM;\r\npr_devel("==>%s()\n", __func__);\r\nBUG_ON(!pkey);\r\nBUG_ON(!sig);\r\nBUG_ON(!sig->digest);\r\nBUG_ON(!sig->s);\r\nalg_name = sig->pkey_algo;\r\nif (strcmp(sig->pkey_algo, "rsa") == 0) {\r\nif (snprintf(alg_name_buf, CRYPTO_MAX_ALG_NAME,\r\n"pkcs1pad(rsa,%s)", sig->hash_algo\r\n) >= CRYPTO_MAX_ALG_NAME)\r\nreturn -EINVAL;\r\nalg_name = alg_name_buf;\r\n}\r\ntfm = crypto_alloc_akcipher(alg_name, 0, 0);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nreq = akcipher_request_alloc(tfm, GFP_KERNEL);\r\nif (!req)\r\ngoto error_free_tfm;\r\nret = crypto_akcipher_set_pub_key(tfm, pkey->key, pkey->keylen);\r\nif (ret)\r\ngoto error_free_req;\r\noutlen = crypto_akcipher_maxsize(tfm);\r\noutput = kmalloc(outlen, GFP_KERNEL);\r\nif (!output)\r\ngoto error_free_req;\r\nsg_init_one(&sig_sg, sig->s, sig->s_size);\r\nsg_init_one(&digest_sg, output, outlen);\r\nakcipher_request_set_crypt(req, &sig_sg, &digest_sg, sig->s_size,\r\noutlen);\r\ninit_completion(&compl.completion);\r\nakcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\r\nCRYPTO_TFM_REQ_MAY_SLEEP,\r\npublic_key_verify_done, &compl);\r\nret = crypto_akcipher_verify(req);\r\nif (ret == -EINPROGRESS) {\r\nwait_for_completion(&compl.completion);\r\nret = compl.err;\r\n}\r\nif (ret < 0)\r\ngoto out_free_output;\r\nif (req->dst_len != sig->digest_size ||\r\nmemcmp(sig->digest, output, sig->digest_size) != 0)\r\nret = -EKEYREJECTED;\r\nout_free_output:\r\nkfree(output);\r\nerror_free_req:\r\nakcipher_request_free(req);\r\nerror_free_tfm:\r\ncrypto_free_akcipher(tfm);\r\npr_devel("<==%s() = %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int public_key_verify_signature_2(const struct key *key,\r\nconst struct public_key_signature *sig)\r\n{\r\nconst struct public_key *pk = key->payload.data[asym_crypto];\r\nreturn public_key_verify_signature(pk, sig);\r\n}
