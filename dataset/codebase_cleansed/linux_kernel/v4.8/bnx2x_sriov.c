static void storm_memset_vf_to_pf(struct bnx2x *bp, u16 abs_fid,\r\nu16 pf_id)\r\n{\r\nREG_WR8(bp, BAR_XSTRORM_INTMEM + XSTORM_VF_TO_PF_OFFSET(abs_fid),\r\npf_id);\r\nREG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_VF_TO_PF_OFFSET(abs_fid),\r\npf_id);\r\nREG_WR8(bp, BAR_TSTRORM_INTMEM + TSTORM_VF_TO_PF_OFFSET(abs_fid),\r\npf_id);\r\nREG_WR8(bp, BAR_USTRORM_INTMEM + USTORM_VF_TO_PF_OFFSET(abs_fid),\r\npf_id);\r\n}\r\nstatic void storm_memset_func_en(struct bnx2x *bp, u16 abs_fid,\r\nu8 enable)\r\n{\r\nREG_WR8(bp, BAR_XSTRORM_INTMEM + XSTORM_FUNC_EN_OFFSET(abs_fid),\r\nenable);\r\nREG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_FUNC_EN_OFFSET(abs_fid),\r\nenable);\r\nREG_WR8(bp, BAR_TSTRORM_INTMEM + TSTORM_FUNC_EN_OFFSET(abs_fid),\r\nenable);\r\nREG_WR8(bp, BAR_USTRORM_INTMEM + USTORM_FUNC_EN_OFFSET(abs_fid),\r\nenable);\r\n}\r\nint bnx2x_vf_idx_by_abs_fid(struct bnx2x *bp, u16 abs_vfid)\r\n{\r\nint idx;\r\nfor_each_vf(bp, idx)\r\nif (bnx2x_vf(bp, idx, abs_vfid) == abs_vfid)\r\nbreak;\r\nreturn idx;\r\n}\r\nstatic\r\nstruct bnx2x_virtf *bnx2x_vf_by_abs_fid(struct bnx2x *bp, u16 abs_vfid)\r\n{\r\nu16 idx = (u16)bnx2x_vf_idx_by_abs_fid(bp, abs_vfid);\r\nreturn (idx < BNX2X_NR_VIRTFN(bp)) ? BP_VF(bp, idx) : NULL;\r\n}\r\nstatic void bnx2x_vf_igu_ack_sb(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nu8 igu_sb_id, u8 segment, u16 index, u8 op,\r\nu8 update)\r\n{\r\nu32 ctl;\r\nu32 igu_addr_data = IGU_REG_COMMAND_REG_32LSB_DATA;\r\nu32 igu_addr_ctl = IGU_REG_COMMAND_REG_CTRL;\r\nu32 func_encode = vf->abs_vfid;\r\nu32 addr_encode = IGU_CMD_E2_PROD_UPD_BASE + igu_sb_id;\r\nstruct igu_regular cmd_data = {0};\r\ncmd_data.sb_id_and_flags =\r\n((index << IGU_REGULAR_SB_INDEX_SHIFT) |\r\n(segment << IGU_REGULAR_SEGMENT_ACCESS_SHIFT) |\r\n(update << IGU_REGULAR_BUPDATE_SHIFT) |\r\n(op << IGU_REGULAR_ENABLE_INT_SHIFT));\r\nctl = addr_encode << IGU_CTRL_REG_ADDRESS_SHIFT |\r\nfunc_encode << IGU_CTRL_REG_FID_SHIFT |\r\nIGU_CTRL_CMD_TYPE_WR << IGU_CTRL_REG_TYPE_SHIFT;\r\nDP(NETIF_MSG_HW, "write 0x%08x to IGU(via GRC) addr 0x%x\n",\r\ncmd_data.sb_id_and_flags, igu_addr_data);\r\nREG_WR(bp, igu_addr_data, cmd_data.sb_id_and_flags);\r\nmmiowb();\r\nbarrier();\r\nDP(NETIF_MSG_HW, "write 0x%08x to IGU(via GRC) addr 0x%x\n",\r\nctl, igu_addr_ctl);\r\nREG_WR(bp, igu_addr_ctl, ctl);\r\nmmiowb();\r\nbarrier();\r\n}\r\nstatic bool bnx2x_validate_vf_sp_objs(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nbool print_err)\r\n{\r\nif (!bnx2x_leading_vfq(vf, sp_initialized)) {\r\nif (print_err)\r\nBNX2X_ERR("Slowpath objects not yet initialized!\n");\r\nelse\r\nDP(BNX2X_MSG_IOV, "Slowpath objects not yet initialized!\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid bnx2x_vfop_qctor_dump_tx(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_queue_init_params *init_params,\r\nstruct bnx2x_queue_setup_params *setup_params,\r\nu16 q_idx, u16 sb_idx)\r\n{\r\nDP(BNX2X_MSG_IOV,\r\n"VF[%d] Q_SETUP: txq[%d]-- vfsb=%d, sb-index=%d, hc-rate=%d, flags=0x%lx, traffic-type=%d",\r\nvf->abs_vfid,\r\nq_idx,\r\nsb_idx,\r\ninit_params->tx.sb_cq_index,\r\ninit_params->tx.hc_rate,\r\nsetup_params->flags,\r\nsetup_params->txq_params.traffic_type);\r\n}\r\nvoid bnx2x_vfop_qctor_dump_rx(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_queue_init_params *init_params,\r\nstruct bnx2x_queue_setup_params *setup_params,\r\nu16 q_idx, u16 sb_idx)\r\n{\r\nstruct bnx2x_rxq_setup_params *rxq_params = &setup_params->rxq_params;\r\nDP(BNX2X_MSG_IOV, "VF[%d] Q_SETUP: rxq[%d]-- vfsb=%d, sb-index=%d, hc-rate=%d, mtu=%d, buf-size=%d\n"\r\n"sge-size=%d, max_sge_pkt=%d, tpa-agg-size=%d, flags=0x%lx, drop-flags=0x%x, cache-log=%d\n",\r\nvf->abs_vfid,\r\nq_idx,\r\nsb_idx,\r\ninit_params->rx.sb_cq_index,\r\ninit_params->rx.hc_rate,\r\nsetup_params->gen_params.mtu,\r\nrxq_params->buf_sz,\r\nrxq_params->sge_buf_sz,\r\nrxq_params->max_sges_pkt,\r\nrxq_params->tpa_agg_sz,\r\nsetup_params->flags,\r\nrxq_params->drop_flags,\r\nrxq_params->cache_line_log);\r\n}\r\nvoid bnx2x_vfop_qctor_prep(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_queue *q,\r\nstruct bnx2x_vf_queue_construct_params *p,\r\nunsigned long q_type)\r\n{\r\nstruct bnx2x_queue_init_params *init_p = &p->qstate.params.init;\r\nstruct bnx2x_queue_setup_params *setup_p = &p->prep_qsetup;\r\nif (test_bit(BNX2X_Q_FLG_HC, &init_p->rx.flags))\r\n__set_bit(BNX2X_Q_FLG_HC_EN, &init_p->rx.flags);\r\nif (test_bit(BNX2X_Q_FLG_HC, &init_p->tx.flags))\r\n__set_bit(BNX2X_Q_FLG_HC_EN, &init_p->tx.flags);\r\ninit_p->rx.fw_sb_id = vf_igu_sb(vf, q->sb_idx);\r\ninit_p->tx.fw_sb_id = vf_igu_sb(vf, q->sb_idx);\r\ninit_p->cxts[0] = q->cxt;\r\nsetup_p->gen_params.spcl_id = vf->sp_cl_id;\r\nsetup_p->gen_params.stat_id = vfq_stat_id(vf, q);\r\nsetup_p->gen_params.fp_hsi = vf->fp_hsi;\r\nif (test_bit(BNX2X_Q_FLG_STATS, &setup_p->flags))\r\n__set_bit(BNX2X_Q_FLG_ZERO_STATS, &setup_p->flags);\r\n__set_bit(BNX2X_Q_FLG_TX_SWITCH, &setup_p->flags);\r\n__set_bit(BNX2X_Q_FLG_TX_SEC, &setup_p->flags);\r\n__set_bit(BNX2X_Q_FLG_ANTI_SPOOF, &setup_p->flags);\r\nif (test_bit(BNX2X_Q_TYPE_HAS_RX, &q_type)) {\r\nstruct bnx2x_rxq_setup_params *rxq_p = &setup_p->rxq_params;\r\nrxq_p->cl_qzone_id = vfq_qzone_id(vf, q);\r\nrxq_p->fw_sb_id = vf_igu_sb(vf, q->sb_idx);\r\nrxq_p->rss_engine_id = FW_VF_HANDLE(vf->abs_vfid);\r\nif (test_bit(BNX2X_Q_FLG_TPA, &setup_p->flags))\r\nrxq_p->max_tpa_queues = BNX2X_VF_MAX_TPA_AGG_QUEUES;\r\n}\r\nif (test_bit(BNX2X_Q_TYPE_HAS_TX, &q_type)) {\r\nsetup_p->txq_params.tss_leading_cl_id = vf->leading_rss;\r\nsetup_p->txq_params.fw_sb_id = vf_igu_sb(vf, q->sb_idx);\r\n}\r\n}\r\nstatic int bnx2x_vf_queue_create(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf, int qid,\r\nstruct bnx2x_vf_queue_construct_params *qctor)\r\n{\r\nstruct bnx2x_queue_state_params *q_params;\r\nint rc = 0;\r\nDP(BNX2X_MSG_IOV, "vf[%d:%d]\n", vf->abs_vfid, qid);\r\nq_params = &qctor->qstate;\r\nq_params->q_obj = &bnx2x_vfq(vf, qid, sp_obj);\r\nset_bit(RAMROD_COMP_WAIT, &q_params->ramrod_flags);\r\nif (bnx2x_get_q_logical_state(bp, q_params->q_obj) ==\r\nBNX2X_Q_LOGICAL_STATE_ACTIVE) {\r\nDP(BNX2X_MSG_IOV, "queue was already up. Aborting gracefully\n");\r\ngoto out;\r\n}\r\nq_params->cmd = BNX2X_Q_CMD_INIT;\r\nrc = bnx2x_queue_state_change(bp, q_params);\r\nif (rc)\r\ngoto out;\r\nmemcpy(&q_params->params.setup, &qctor->prep_qsetup,\r\nsizeof(struct bnx2x_queue_setup_params));\r\nq_params->cmd = BNX2X_Q_CMD_SETUP;\r\nrc = bnx2x_queue_state_change(bp, q_params);\r\nif (rc)\r\ngoto out;\r\nbnx2x_vf_igu_ack_sb(bp, vf, vf_igu_sb(vf, bnx2x_vfq(vf, qid, sb_idx)),\r\nUSTORM_ID, 0, IGU_INT_ENABLE, 0);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int bnx2x_vf_queue_destroy(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nint qid)\r\n{\r\nenum bnx2x_queue_cmd cmds[] = {BNX2X_Q_CMD_HALT,\r\nBNX2X_Q_CMD_TERMINATE,\r\nBNX2X_Q_CMD_CFC_DEL};\r\nstruct bnx2x_queue_state_params q_params;\r\nint rc, i;\r\nDP(BNX2X_MSG_IOV, "vf[%d]\n", vf->abs_vfid);\r\nmemset(&q_params, 0, sizeof(struct bnx2x_queue_state_params));\r\nq_params.q_obj = &bnx2x_vfq(vf, qid, sp_obj);\r\nset_bit(RAMROD_COMP_WAIT, &q_params.ramrod_flags);\r\nif (bnx2x_get_q_logical_state(bp, q_params.q_obj) ==\r\nBNX2X_Q_LOGICAL_STATE_STOPPED) {\r\nDP(BNX2X_MSG_IOV, "queue was already stopped. Aborting gracefully\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cmds); i++) {\r\nq_params.cmd = cmds[i];\r\nrc = bnx2x_queue_state_change(bp, &q_params);\r\nif (rc) {\r\nBNX2X_ERR("Failed to run Queue command %d\n", cmds[i]);\r\nreturn rc;\r\n}\r\n}\r\nout:\r\nif (bnx2x_vfq(vf, qid, cxt)) {\r\nbnx2x_vfq(vf, qid, cxt)->ustorm_ag_context.cdu_usage = 0;\r\nbnx2x_vfq(vf, qid, cxt)->xstorm_ag_context.cdu_reserved = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2x_vf_set_igu_info(struct bnx2x *bp, u8 igu_sb_id, u8 abs_vfid)\r\n{\r\nstruct bnx2x_virtf *vf = bnx2x_vf_by_abs_fid(bp, abs_vfid);\r\nif (vf) {\r\nif (!BP_VFDB(bp)->first_vf_igu_entry)\r\nBP_VFDB(bp)->first_vf_igu_entry = igu_sb_id;\r\nif (!vf_sb_count(vf))\r\nvf->igu_base_id = igu_sb_id;\r\n++vf_sb_count(vf);\r\n++vf->sb_count;\r\n}\r\nBP_VFDB(bp)->vf_sbs_pool++;\r\n}\r\nstatic inline void bnx2x_vf_vlan_credit(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *obj,\r\natomic_t *counter)\r\n{\r\nstruct list_head *pos;\r\nint read_lock;\r\nint cnt = 0;\r\nread_lock = bnx2x_vlan_mac_h_read_lock(bp, obj);\r\nif (read_lock)\r\nDP(BNX2X_MSG_SP, "Failed to take vlan mac read head; continuing anyway\n");\r\nlist_for_each(pos, &obj->head)\r\ncnt++;\r\nif (!read_lock)\r\nbnx2x_vlan_mac_h_read_unlock(bp, obj);\r\natomic_set(counter, cnt);\r\n}\r\nstatic int bnx2x_vf_vlan_mac_clear(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nint qid, bool drv_only, int type)\r\n{\r\nstruct bnx2x_vlan_mac_ramrod_params ramrod;\r\nint rc;\r\nDP(BNX2X_MSG_IOV, "vf[%d] - deleting all %s\n", vf->abs_vfid,\r\n(type == BNX2X_VF_FILTER_VLAN_MAC) ? "VLAN-MACs" :\r\n(type == BNX2X_VF_FILTER_MAC) ? "MACs" : "VLANs");\r\nmemset(&ramrod, 0, sizeof(struct bnx2x_vlan_mac_ramrod_params));\r\nif (type == BNX2X_VF_FILTER_VLAN_MAC) {\r\nset_bit(BNX2X_ETH_MAC, &ramrod.user_req.vlan_mac_flags);\r\nramrod.vlan_mac_obj = &bnx2x_vfq(vf, qid, vlan_mac_obj);\r\n} else if (type == BNX2X_VF_FILTER_MAC) {\r\nset_bit(BNX2X_ETH_MAC, &ramrod.user_req.vlan_mac_flags);\r\nramrod.vlan_mac_obj = &bnx2x_vfq(vf, qid, mac_obj);\r\n} else {\r\nramrod.vlan_mac_obj = &bnx2x_vfq(vf, qid, vlan_obj);\r\n}\r\nramrod.user_req.cmd = BNX2X_VLAN_MAC_DEL;\r\nset_bit(RAMROD_EXEC, &ramrod.ramrod_flags);\r\nif (drv_only)\r\nset_bit(RAMROD_DRV_CLR_ONLY, &ramrod.ramrod_flags);\r\nelse\r\nset_bit(RAMROD_COMP_WAIT, &ramrod.ramrod_flags);\r\nrc = ramrod.vlan_mac_obj->delete_all(bp,\r\nramrod.vlan_mac_obj,\r\n&ramrod.user_req.vlan_mac_flags,\r\n&ramrod.ramrod_flags);\r\nif (rc) {\r\nBNX2X_ERR("Failed to delete all %s\n",\r\n(type == BNX2X_VF_FILTER_VLAN_MAC) ? "VLAN-MACs" :\r\n(type == BNX2X_VF_FILTER_MAC) ? "MACs" : "VLANs");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_vf_mac_vlan_config(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf, int qid,\r\nstruct bnx2x_vf_mac_vlan_filter *filter,\r\nbool drv_only)\r\n{\r\nstruct bnx2x_vlan_mac_ramrod_params ramrod;\r\nint rc;\r\nDP(BNX2X_MSG_IOV, "vf[%d] - %s a %s filter\n",\r\nvf->abs_vfid, filter->add ? "Adding" : "Deleting",\r\n(filter->type == BNX2X_VF_FILTER_VLAN_MAC) ? "VLAN-MAC" :\r\n(filter->type == BNX2X_VF_FILTER_MAC) ? "MAC" : "VLAN");\r\nmemset(&ramrod, 0, sizeof(struct bnx2x_vlan_mac_ramrod_params));\r\nif (filter->type == BNX2X_VF_FILTER_VLAN_MAC) {\r\nramrod.vlan_mac_obj = &bnx2x_vfq(vf, qid, vlan_mac_obj);\r\nramrod.user_req.u.vlan.vlan = filter->vid;\r\nmemcpy(&ramrod.user_req.u.mac.mac, filter->mac, ETH_ALEN);\r\nset_bit(BNX2X_ETH_MAC, &ramrod.user_req.vlan_mac_flags);\r\n} else if (filter->type == BNX2X_VF_FILTER_VLAN) {\r\nramrod.vlan_mac_obj = &bnx2x_vfq(vf, qid, vlan_obj);\r\nramrod.user_req.u.vlan.vlan = filter->vid;\r\n} else {\r\nset_bit(BNX2X_ETH_MAC, &ramrod.user_req.vlan_mac_flags);\r\nramrod.vlan_mac_obj = &bnx2x_vfq(vf, qid, mac_obj);\r\nmemcpy(&ramrod.user_req.u.mac.mac, filter->mac, ETH_ALEN);\r\n}\r\nramrod.user_req.cmd = filter->add ? BNX2X_VLAN_MAC_ADD :\r\nBNX2X_VLAN_MAC_DEL;\r\nset_bit(RAMROD_EXEC, &ramrod.ramrod_flags);\r\nif (drv_only)\r\nset_bit(RAMROD_DRV_CLR_ONLY, &ramrod.ramrod_flags);\r\nelse\r\nset_bit(RAMROD_COMP_WAIT, &ramrod.ramrod_flags);\r\nrc = bnx2x_config_vlan_mac(bp, &ramrod);\r\nif (rc && rc != -EEXIST) {\r\nBNX2X_ERR("Failed to %s %s\n",\r\nfilter->add ? "add" : "delete",\r\n(filter->type == BNX2X_VF_FILTER_VLAN_MAC) ?\r\n"VLAN-MAC" :\r\n(filter->type == BNX2X_VF_FILTER_MAC) ?\r\n"MAC" : "VLAN");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint bnx2x_vf_mac_vlan_config_list(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mac_vlan_filters *filters,\r\nint qid, bool drv_only)\r\n{\r\nint rc = 0, i;\r\nDP(BNX2X_MSG_IOV, "vf[%d]\n", vf->abs_vfid);\r\nif (!bnx2x_validate_vf_sp_objs(bp, vf, true))\r\nreturn -EINVAL;\r\nfor (i = 0; i < filters->count; i++) {\r\nrc = bnx2x_vf_mac_vlan_config(bp, vf, qid,\r\n&filters->filters[i], drv_only);\r\nif (rc)\r\nbreak;\r\n}\r\nif (i != filters->count) {\r\nBNX2X_ERR("Managed only %d/%d filters - rolling back\n",\r\ni, filters->count + 1);\r\nwhile (--i >= 0) {\r\nfilters->filters[i].add = !filters->filters[i].add;\r\nbnx2x_vf_mac_vlan_config(bp, vf, qid,\r\n&filters->filters[i],\r\ndrv_only);\r\n}\r\n}\r\nkfree(filters);\r\nreturn rc;\r\n}\r\nint bnx2x_vf_queue_setup(struct bnx2x *bp, struct bnx2x_virtf *vf, int qid,\r\nstruct bnx2x_vf_queue_construct_params *qctor)\r\n{\r\nint rc;\r\nDP(BNX2X_MSG_IOV, "vf[%d:%d]\n", vf->abs_vfid, qid);\r\nrc = bnx2x_vf_queue_create(bp, vf, qid, qctor);\r\nif (rc)\r\ngoto op_err;\r\nbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_HYPERVISOR_VLAN,\r\nBNX2X_MSG_IOV);\r\nreturn 0;\r\nop_err:\r\nBNX2X_ERR("QSETUP[%d:%d] error: rc %d\n", vf->abs_vfid, qid, rc);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_vf_queue_flr(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nint qid)\r\n{\r\nint rc;\r\nDP(BNX2X_MSG_IOV, "vf[%d:%d]\n", vf->abs_vfid, qid);\r\nif ((qid == LEADING_IDX) &&\r\nbnx2x_validate_vf_sp_objs(bp, vf, false)) {\r\nrc = bnx2x_vf_vlan_mac_clear(bp, vf, qid, true,\r\nBNX2X_VF_FILTER_VLAN_MAC);\r\nif (rc)\r\ngoto op_err;\r\nrc = bnx2x_vf_vlan_mac_clear(bp, vf, qid, true,\r\nBNX2X_VF_FILTER_VLAN);\r\nif (rc)\r\ngoto op_err;\r\nrc = bnx2x_vf_vlan_mac_clear(bp, vf, qid, true,\r\nBNX2X_VF_FILTER_MAC);\r\nif (rc)\r\ngoto op_err;\r\n}\r\nif (bnx2x_vfq(vf, qid, sp_obj).state != BNX2X_Q_STATE_RESET) {\r\nstruct bnx2x_queue_state_params qstate;\r\nmemset(&qstate, 0, sizeof(struct bnx2x_queue_state_params));\r\nqstate.q_obj = &bnx2x_vfq(vf, qid, sp_obj);\r\nqstate.q_obj->state = BNX2X_Q_STATE_STOPPED;\r\nqstate.cmd = BNX2X_Q_CMD_TERMINATE;\r\nset_bit(RAMROD_COMP_WAIT, &qstate.ramrod_flags);\r\nrc = bnx2x_queue_state_change(bp, &qstate);\r\nif (rc)\r\ngoto op_err;\r\n}\r\nreturn 0;\r\nop_err:\r\nBNX2X_ERR("vf[%d:%d] error: rc %d\n", vf->abs_vfid, qid, rc);\r\nreturn rc;\r\n}\r\nint bnx2x_vf_mcast(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nbnx2x_mac_addr_t *mcasts, int mc_num, bool drv_only)\r\n{\r\nstruct bnx2x_mcast_list_elem *mc = NULL;\r\nstruct bnx2x_mcast_ramrod_params mcast;\r\nint rc, i;\r\nDP(BNX2X_MSG_IOV, "vf[%d]\n", vf->abs_vfid);\r\nmemset(&mcast, 0, sizeof(struct bnx2x_mcast_ramrod_params));\r\nmcast.mcast_obj = &vf->mcast_obj;\r\nif (drv_only)\r\nset_bit(RAMROD_DRV_CLR_ONLY, &mcast.ramrod_flags);\r\nelse\r\nset_bit(RAMROD_COMP_WAIT, &mcast.ramrod_flags);\r\nif (mc_num) {\r\nmc = kzalloc(mc_num * sizeof(struct bnx2x_mcast_list_elem),\r\nGFP_KERNEL);\r\nif (!mc) {\r\nBNX2X_ERR("Cannot Configure multicasts due to lack of memory\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmcast.mcast_list_len = vf->mcast_list_len;\r\nvf->mcast_list_len = mc_num;\r\nrc = bnx2x_config_mcast(bp, &mcast, BNX2X_MCAST_CMD_DEL);\r\nif (rc) {\r\nBNX2X_ERR("Failed to remove multicasts\n");\r\nkfree(mc);\r\nreturn rc;\r\n}\r\nif (mc_num) {\r\nINIT_LIST_HEAD(&mcast.mcast_list);\r\nfor (i = 0; i < mc_num; i++) {\r\nmc[i].mac = mcasts[i];\r\nlist_add_tail(&mc[i].link,\r\n&mcast.mcast_list);\r\n}\r\nmcast.mcast_list_len = mc_num;\r\nrc = bnx2x_config_mcast(bp, &mcast, BNX2X_MCAST_CMD_ADD);\r\nif (rc)\r\nBNX2X_ERR("Faled to add multicasts\n");\r\nkfree(mc);\r\n}\r\nreturn rc;\r\n}\r\nstatic void bnx2x_vf_prep_rx_mode(struct bnx2x *bp, u8 qid,\r\nstruct bnx2x_rx_mode_ramrod_params *ramrod,\r\nstruct bnx2x_virtf *vf,\r\nunsigned long accept_flags)\r\n{\r\nstruct bnx2x_vf_queue *vfq = vfq_get(vf, qid);\r\nmemset(ramrod, 0, sizeof(*ramrod));\r\nramrod->cid = vfq->cid;\r\nramrod->cl_id = vfq_cl_id(vf, vfq);\r\nramrod->rx_mode_obj = &bp->rx_mode_obj;\r\nramrod->func_id = FW_VF_HANDLE(vf->abs_vfid);\r\nramrod->rx_accept_flags = accept_flags;\r\nramrod->tx_accept_flags = accept_flags;\r\nramrod->pstate = &vf->filter_state;\r\nramrod->state = BNX2X_FILTER_RX_MODE_PENDING;\r\nset_bit(BNX2X_FILTER_RX_MODE_PENDING, &vf->filter_state);\r\nset_bit(RAMROD_RX, &ramrod->ramrod_flags);\r\nset_bit(RAMROD_TX, &ramrod->ramrod_flags);\r\nramrod->rdata = bnx2x_vf_sp(bp, vf, rx_mode_rdata.e2);\r\nramrod->rdata_mapping = bnx2x_vf_sp_map(bp, vf, rx_mode_rdata.e2);\r\n}\r\nint bnx2x_vf_rxmode(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nint qid, unsigned long accept_flags)\r\n{\r\nstruct bnx2x_rx_mode_ramrod_params ramrod;\r\nDP(BNX2X_MSG_IOV, "vf[%d]\n", vf->abs_vfid);\r\nbnx2x_vf_prep_rx_mode(bp, qid, &ramrod, vf, accept_flags);\r\nset_bit(RAMROD_COMP_WAIT, &ramrod.ramrod_flags);\r\nvfq_get(vf, qid)->accept_flags = ramrod.rx_accept_flags;\r\nreturn bnx2x_config_rx_mode(bp, &ramrod);\r\n}\r\nint bnx2x_vf_queue_teardown(struct bnx2x *bp, struct bnx2x_virtf *vf, int qid)\r\n{\r\nint rc;\r\nDP(BNX2X_MSG_IOV, "vf[%d:%d]\n", vf->abs_vfid, qid);\r\nif (qid == LEADING_IDX) {\r\nrc = bnx2x_vf_rxmode(bp, vf, qid, 0);\r\nif (rc)\r\ngoto op_err;\r\nif (bnx2x_validate_vf_sp_objs(bp, vf, true)) {\r\nrc = bnx2x_vf_vlan_mac_clear(bp, vf, qid,\r\nfalse,\r\nBNX2X_VF_FILTER_VLAN_MAC);\r\nif (rc)\r\ngoto op_err;\r\nrc = bnx2x_vf_vlan_mac_clear(bp, vf, qid,\r\nfalse,\r\nBNX2X_VF_FILTER_VLAN);\r\nif (rc)\r\ngoto op_err;\r\nrc = bnx2x_vf_vlan_mac_clear(bp, vf, qid,\r\nfalse,\r\nBNX2X_VF_FILTER_MAC);\r\nif (rc)\r\ngoto op_err;\r\nrc = bnx2x_vf_mcast(bp, vf, NULL, 0, false);\r\nif (rc)\r\ngoto op_err;\r\n}\r\n}\r\nrc = bnx2x_vf_queue_destroy(bp, vf, qid);\r\nif (rc)\r\ngoto op_err;\r\nreturn rc;\r\nop_err:\r\nBNX2X_ERR("vf[%d:%d] error: rc %d\n",\r\nvf->abs_vfid, qid, rc);\r\nreturn rc;\r\n}\r\nstatic void bnx2x_vf_enable_internal(struct bnx2x *bp, u8 enable)\r\n{\r\nREG_WR(bp, PGLUE_B_REG_INTERNAL_VFID_ENABLE, enable ? 1 : 0);\r\n}\r\nstatic void bnx2x_vf_semi_clear_err(struct bnx2x *bp, u8 abs_vfid)\r\n{\r\nREG_WR(bp, TSEM_REG_VFPF_ERR_NUM, abs_vfid);\r\nREG_WR(bp, USEM_REG_VFPF_ERR_NUM, abs_vfid);\r\nREG_WR(bp, CSEM_REG_VFPF_ERR_NUM, abs_vfid);\r\nREG_WR(bp, XSEM_REG_VFPF_ERR_NUM, abs_vfid);\r\n}\r\nstatic void bnx2x_vf_pglue_clear_err(struct bnx2x *bp, u8 abs_vfid)\r\n{\r\nu32 was_err_group = (2 * BP_PATH(bp) + abs_vfid) >> 5;\r\nu32 was_err_reg = 0;\r\nswitch (was_err_group) {\r\ncase 0:\r\nwas_err_reg = PGLUE_B_REG_WAS_ERROR_VF_31_0_CLR;\r\nbreak;\r\ncase 1:\r\nwas_err_reg = PGLUE_B_REG_WAS_ERROR_VF_63_32_CLR;\r\nbreak;\r\ncase 2:\r\nwas_err_reg = PGLUE_B_REG_WAS_ERROR_VF_95_64_CLR;\r\nbreak;\r\ncase 3:\r\nwas_err_reg = PGLUE_B_REG_WAS_ERROR_VF_127_96_CLR;\r\nbreak;\r\n}\r\nREG_WR(bp, was_err_reg, 1 << (abs_vfid & 0x1f));\r\n}\r\nstatic void bnx2x_vf_igu_reset(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nint i;\r\nu32 val;\r\nbnx2x_pretend_func(bp, HW_VF_HANDLE(bp, vf->abs_vfid));\r\nREG_WR(bp, IGU_REG_SB_INT_BEFORE_MASK_LSB, 0);\r\nREG_WR(bp, IGU_REG_SB_INT_BEFORE_MASK_MSB, 0);\r\nREG_WR(bp, IGU_REG_SB_MASK_LSB, 0);\r\nREG_WR(bp, IGU_REG_SB_MASK_MSB, 0);\r\nREG_WR(bp, IGU_REG_PBA_STATUS_LSB, 0);\r\nREG_WR(bp, IGU_REG_PBA_STATUS_MSB, 0);\r\nval = REG_RD(bp, IGU_REG_VF_CONFIGURATION);\r\nval |= (IGU_VF_CONF_FUNC_EN | IGU_VF_CONF_MSI_MSIX_EN);\r\nval &= ~IGU_VF_CONF_PARENT_MASK;\r\nval |= (BP_ABS_FUNC(bp) >> 1) << IGU_VF_CONF_PARENT_SHIFT;\r\nREG_WR(bp, IGU_REG_VF_CONFIGURATION, val);\r\nDP(BNX2X_MSG_IOV,\r\n"value in IGU_REG_VF_CONFIGURATION of vf %d after write is 0x%08x\n",\r\nvf->abs_vfid, val);\r\nbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\r\nfor (i = 0; i < vf_sb_count(vf); i++) {\r\nu8 igu_sb_id = vf_igu_sb(vf, i);\r\nREG_WR(bp, IGU_REG_PROD_CONS_MEMORY + igu_sb_id * 4, 0);\r\nbnx2x_igu_clear_sb_gen(bp, vf->abs_vfid, igu_sb_id,\r\nfalse );\r\nbnx2x_vf_igu_ack_sb(bp, vf, igu_sb_id, USTORM_ID, 0,\r\nIGU_INT_DISABLE, 1);\r\n}\r\n}\r\nvoid bnx2x_vf_enable_access(struct bnx2x *bp, u8 abs_vfid)\r\n{\r\nstorm_memset_vf_to_pf(bp, FW_VF_HANDLE(abs_vfid), BP_FUNC(bp));\r\nstorm_memset_func_en(bp, FW_VF_HANDLE(abs_vfid), 1);\r\nbnx2x_vf_semi_clear_err(bp, abs_vfid);\r\nbnx2x_vf_pglue_clear_err(bp, abs_vfid);\r\nbnx2x_pretend_func(bp, HW_VF_HANDLE(bp, abs_vfid));\r\nDP(BNX2X_MSG_IOV, "enabling internal access for vf %x\n", abs_vfid);\r\nbnx2x_vf_enable_internal(bp, true);\r\nbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\r\n}\r\nstatic void bnx2x_vf_enable_traffic(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nbnx2x_vf_igu_reset(bp, vf);\r\nbnx2x_pretend_func(bp, HW_VF_HANDLE(bp, vf->abs_vfid));\r\nREG_WR(bp, PBF_REG_DISABLE_VF, 0);\r\nbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\r\n}\r\nstatic u8 bnx2x_vf_is_pcie_pending(struct bnx2x *bp, u8 abs_vfid)\r\n{\r\nstruct pci_dev *dev;\r\nstruct bnx2x_virtf *vf = bnx2x_vf_by_abs_fid(bp, abs_vfid);\r\nif (!vf)\r\nreturn false;\r\ndev = pci_get_bus_and_slot(vf->bus, vf->devfn);\r\nif (dev)\r\nreturn bnx2x_is_pcie_pending(dev);\r\nreturn false;\r\n}\r\nint bnx2x_vf_flr_clnup_epilog(struct bnx2x *bp, u8 abs_vfid)\r\n{\r\nif (bnx2x_vf_is_pcie_pending(bp, abs_vfid))\r\nBNX2X_ERR("PCIE Transactions still pending\n");\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2x_iov_static_resc(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nstruct vf_pf_resc_request *resc = &vf->alloc_resc;\r\nresc->num_rxqs = 0;\r\nresc->num_txqs = 0;\r\nresc->num_mac_filters = VF_MAC_CREDIT_CNT;\r\nresc->num_vlan_filters = VF_VLAN_CREDIT_CNT;\r\nresc->num_mc_filters = 0;\r\nresc->num_sbs = vf->sb_count;\r\n}\r\nstatic void bnx2x_vf_free_resc(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nbnx2x_iov_static_resc(bp, vf);\r\nvf->state = VF_FREE;\r\n}\r\nstatic void bnx2x_vf_flr_clnup_hw(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nu32 poll_cnt = bnx2x_flr_clnup_poll_count(bp);\r\nbnx2x_pretend_func(bp, HW_VF_HANDLE(bp, vf->abs_vfid));\r\nbnx2x_flr_clnup_poll_hw_counter(bp, DORQ_REG_VF_USAGE_CNT,\r\n"DQ VF usage counter timed out",\r\npoll_cnt);\r\nbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\r\nif (bnx2x_send_final_clnup(bp, (u8)FW_VF_HANDLE(vf->abs_vfid),\r\npoll_cnt))\r\nBNX2X_ERR("VF[%d] Final cleanup timed-out\n", vf->abs_vfid);\r\nbnx2x_tx_hw_flushed(bp, poll_cnt);\r\n}\r\nstatic void bnx2x_vf_flr(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nint rc, i;\r\nDP(BNX2X_MSG_IOV, "vf[%d]\n", vf->abs_vfid);\r\nfor (i = 0; i < vf_rxq_count(vf); i++) {\r\nrc = bnx2x_vf_queue_flr(bp, vf, i);\r\nif (rc)\r\ngoto out;\r\n}\r\nbnx2x_vf_mcast(bp, vf, NULL, 0, true);\r\nbnx2x_vf_flr_clnup_hw(bp, vf);\r\nbnx2x_vf_free_resc(bp, vf);\r\nbnx2x_vf_enable_mbx(bp, vf->abs_vfid);\r\nreturn;\r\nout:\r\nBNX2X_ERR("vf[%d:%d] failed flr: rc %d\n",\r\nvf->abs_vfid, i, rc);\r\n}\r\nstatic void bnx2x_vf_flr_clnup(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_virtf *vf;\r\nint i;\r\nfor (i = 0; i < BNX2X_NR_VIRTFN(bp); i++) {\r\nif (bnx2x_vf(bp, i, state) != VF_RESET ||\r\n!bnx2x_vf(bp, i, flr_clnup_stage))\r\ncontinue;\r\nDP(BNX2X_MSG_IOV, "next vf to cleanup: %d. Num of vfs: %d\n",\r\ni, BNX2X_NR_VIRTFN(bp));\r\nvf = BP_VF(bp, i);\r\nbnx2x_lock_vf_pf_channel(bp, vf, CHANNEL_TLV_FLR);\r\nbnx2x_vf_flr(bp, vf);\r\nvf->flr_clnup_stage = false;\r\nbnx2x_unlock_vf_pf_channel(bp, vf, CHANNEL_TLV_FLR);\r\n}\r\nDP(BNX2X_MSG_MCP, "DRV_STATUS_VF_DISABLED ACK for vfs 0x%x 0x%x\n",\r\nbp->vfdb->flrd_vfs[0], bp->vfdb->flrd_vfs[1]);\r\nfor (i = 0; i < FLRD_VFS_DWORDS; i++)\r\nSHMEM2_WR(bp, drv_ack_vf_disabled[BP_FW_MB_IDX(bp)][i],\r\nbp->vfdb->flrd_vfs[i]);\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_VF_DISABLED_DONE, 0);\r\nfor (i = 0; i < FLRD_VFS_DWORDS; i++)\r\nSHMEM2_WR(bp, drv_ack_vf_disabled[BP_FW_MB_IDX(bp)][i], 0);\r\n}\r\nvoid bnx2x_vf_handle_flr_event(struct bnx2x *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < FLRD_VFS_DWORDS; i++)\r\nbp->vfdb->flrd_vfs[i] = SHMEM2_RD(bp, mcp_vf_disabled[i]);\r\nDP(BNX2X_MSG_MCP,\r\n"DRV_STATUS_VF_DISABLED received for vfs 0x%x 0x%x\n",\r\nbp->vfdb->flrd_vfs[0], bp->vfdb->flrd_vfs[1]);\r\nfor_each_vf(bp, i) {\r\nstruct bnx2x_virtf *vf = BP_VF(bp, i);\r\nu32 reset = 0;\r\nif (vf->abs_vfid < 32)\r\nreset = bp->vfdb->flrd_vfs[0] & (1 << vf->abs_vfid);\r\nelse\r\nreset = bp->vfdb->flrd_vfs[1] &\r\n(1 << (vf->abs_vfid - 32));\r\nif (reset) {\r\nvf->state = VF_RESET;\r\nvf->flr_clnup_stage = true;\r\nDP(BNX2X_MSG_IOV,\r\n"Initiating Final cleanup for VF %d\n",\r\nvf->abs_vfid);\r\n}\r\n}\r\nbnx2x_vf_flr_clnup(bp);\r\n}\r\nvoid bnx2x_iov_init_dq(struct bnx2x *bp)\r\n{\r\nif (!IS_SRIOV(bp))\r\nreturn;\r\nREG_WR(bp, DORQ_REG_VF_NORM_VF_BASE, 0);\r\nREG_WR(bp, DORQ_REG_MAX_RVFID_SIZE, ilog2(BNX2X_MAX_NUM_OF_VFS));\r\nREG_WR(bp, DORQ_REG_VF_NORM_CID_BASE, BNX2X_FIRST_VF_CID);\r\nREG_WR(bp, DORQ_REG_VF_NORM_CID_WND_SIZE, BNX2X_VF_CID_WND);\r\nREG_WR(bp, DORQ_REG_VF_NORM_CID_OFST, 3);\r\nREG_WR(bp, DORQ_REG_VF_TYPE_MASK_0, 1);\r\nREG_WR(bp, DORQ_REG_VF_TYPE_VALUE_0, 0);\r\nREG_WR(bp, DORQ_REG_VF_TYPE_MIN_MCID_0, 0);\r\nREG_WR(bp, DORQ_REG_VF_TYPE_MAX_MCID_0, 0x1ffff);\r\nREG_WR(bp, DORQ_REG_VF_USAGE_CT_LIMIT, 64);\r\n}\r\nvoid bnx2x_iov_init_dmae(struct bnx2x *bp)\r\n{\r\nif (pci_find_ext_capability(bp->pdev, PCI_EXT_CAP_ID_SRIOV))\r\nREG_WR(bp, DMAE_REG_BACKWARD_COMP_EN, 0);\r\n}\r\nstatic int bnx2x_vf_bus(struct bnx2x *bp, int vfid)\r\n{\r\nstruct pci_dev *dev = bp->pdev;\r\nstruct bnx2x_sriov *iov = &bp->vfdb->sriov;\r\nreturn dev->bus->number + ((dev->devfn + iov->offset +\r\niov->stride * vfid) >> 8);\r\n}\r\nstatic int bnx2x_vf_devfn(struct bnx2x *bp, int vfid)\r\n{\r\nstruct pci_dev *dev = bp->pdev;\r\nstruct bnx2x_sriov *iov = &bp->vfdb->sriov;\r\nreturn (dev->devfn + iov->offset + iov->stride * vfid) & 0xff;\r\n}\r\nstatic void bnx2x_vf_set_bars(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nint i, n;\r\nstruct pci_dev *dev = bp->pdev;\r\nstruct bnx2x_sriov *iov = &bp->vfdb->sriov;\r\nfor (i = 0, n = 0; i < PCI_SRIOV_NUM_BARS; i += 2, n++) {\r\nu64 start = pci_resource_start(dev, PCI_IOV_RESOURCES + i);\r\nu32 size = pci_resource_len(dev, PCI_IOV_RESOURCES + i);\r\nsize /= iov->total;\r\nvf->bars[n].bar = start + size * vf->abs_vfid;\r\nvf->bars[n].size = size;\r\n}\r\n}\r\nstatic int bnx2x_ari_enabled(struct pci_dev *dev)\r\n{\r\nreturn dev->bus->self && dev->bus->self->ari_enabled;\r\n}\r\nstatic int\r\nbnx2x_get_vf_igu_cam_info(struct bnx2x *bp)\r\n{\r\nint sb_id;\r\nu32 val;\r\nu8 fid, current_pf = 0;\r\nfor (sb_id = 0; sb_id < IGU_REG_MAPPING_MEMORY_SIZE; sb_id++) {\r\nval = REG_RD(bp, IGU_REG_MAPPING_MEMORY + sb_id * 4);\r\nif (!(val & IGU_REG_MAPPING_MEMORY_VALID))\r\ncontinue;\r\nfid = GET_FIELD((val), IGU_REG_MAPPING_MEMORY_FID);\r\nif (fid & IGU_FID_ENCODE_IS_PF)\r\ncurrent_pf = fid & IGU_FID_PF_NUM_MASK;\r\nelse if (current_pf == BP_FUNC(bp))\r\nbnx2x_vf_set_igu_info(bp, sb_id,\r\n(fid & IGU_FID_VF_NUM_MASK));\r\nDP(BNX2X_MSG_IOV, "%s[%d], igu_sb_id=%d, msix=%d\n",\r\n((fid & IGU_FID_ENCODE_IS_PF) ? "PF" : "VF"),\r\n((fid & IGU_FID_ENCODE_IS_PF) ? (fid & IGU_FID_PF_NUM_MASK) :\r\n(fid & IGU_FID_VF_NUM_MASK)), sb_id,\r\nGET_FIELD((val), IGU_REG_MAPPING_MEMORY_VECTOR));\r\n}\r\nDP(BNX2X_MSG_IOV, "vf_sbs_pool is %d\n", BP_VFDB(bp)->vf_sbs_pool);\r\nreturn BP_VFDB(bp)->vf_sbs_pool;\r\n}\r\nstatic void __bnx2x_iov_free_vfdb(struct bnx2x *bp)\r\n{\r\nif (bp->vfdb) {\r\nkfree(bp->vfdb->vfqs);\r\nkfree(bp->vfdb->vfs);\r\nkfree(bp->vfdb);\r\n}\r\nbp->vfdb = NULL;\r\n}\r\nstatic int bnx2x_sriov_pci_cfg_info(struct bnx2x *bp, struct bnx2x_sriov *iov)\r\n{\r\nint pos;\r\nstruct pci_dev *dev = bp->pdev;\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV);\r\nif (!pos) {\r\nBNX2X_ERR("failed to find SRIOV capability in device\n");\r\nreturn -ENODEV;\r\n}\r\niov->pos = pos;\r\nDP(BNX2X_MSG_IOV, "sriov ext pos %d\n", pos);\r\npci_read_config_word(dev, pos + PCI_SRIOV_CTRL, &iov->ctrl);\r\npci_read_config_word(dev, pos + PCI_SRIOV_TOTAL_VF, &iov->total);\r\npci_read_config_word(dev, pos + PCI_SRIOV_INITIAL_VF, &iov->initial);\r\npci_read_config_word(dev, pos + PCI_SRIOV_VF_OFFSET, &iov->offset);\r\npci_read_config_word(dev, pos + PCI_SRIOV_VF_STRIDE, &iov->stride);\r\npci_read_config_dword(dev, pos + PCI_SRIOV_SUP_PGSIZE, &iov->pgsz);\r\npci_read_config_dword(dev, pos + PCI_SRIOV_CAP, &iov->cap);\r\npci_read_config_byte(dev, pos + PCI_SRIOV_FUNC_LINK, &iov->link);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_sriov_info(struct bnx2x *bp, struct bnx2x_sriov *iov)\r\n{\r\nu32 val;\r\nif (bnx2x_sriov_pci_cfg_info(bp, iov))\r\nreturn -ENODEV;\r\niov->nres = 0;\r\nval = REG_RD(bp, PCICFG_OFFSET + GRC_CONFIG_REG_PF_INIT_VF);\r\niov->first_vf_in_pf = ((val & GRC_CR_PF_INIT_VF_PF_FIRST_VF_NUM_MASK)\r\n* 8) - (BNX2X_MAX_NUM_OF_VFS * BP_PATH(bp));\r\nDP(BNX2X_MSG_IOV,\r\n"IOV info[%d]: first vf %d, nres %d, cap 0x%x, ctrl 0x%x, total %d, initial %d, num vfs %d, offset %d, stride %d, page size 0x%x\n",\r\nBP_FUNC(bp),\r\niov->first_vf_in_pf, iov->nres, iov->cap, iov->ctrl, iov->total,\r\niov->initial, iov->nr_virtfn, iov->offset, iov->stride, iov->pgsz);\r\nreturn 0;\r\n}\r\nint bnx2x_iov_init_one(struct bnx2x *bp, int int_mode_param,\r\nint num_vfs_param)\r\n{\r\nint err, i;\r\nstruct bnx2x_sriov *iov;\r\nstruct pci_dev *dev = bp->pdev;\r\nbp->vfdb = NULL;\r\nif (IS_VF(bp))\r\nreturn 0;\r\nif (!pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV))\r\nreturn 0;\r\nif (CHIP_IS_E1x(bp))\r\nreturn 0;\r\nif (!num_vfs_param)\r\nreturn 0;\r\nif (BNX2X_L2_MAX_CID(bp) >= BNX2X_FIRST_VF_CID) {\r\nBNX2X_ERR("PF cids %d are overspilling into vf space (starts at %d). Abort SRIOV\n",\r\nBNX2X_L2_MAX_CID(bp), BNX2X_FIRST_VF_CID);\r\nreturn 0;\r\n}\r\nif (int_mode_param == BNX2X_INT_MODE_MSI ||\r\nint_mode_param == BNX2X_INT_MODE_INTX) {\r\nBNX2X_ERR("Forced MSI/INTx mode is incompatible with SRIOV\n");\r\nreturn 0;\r\n}\r\nerr = -EIO;\r\nif (!bnx2x_ari_enabled(bp->pdev)) {\r\nBNX2X_ERR("ARI not supported (check pci bridge ARI forwarding), SRIOV can not be enabled\n");\r\nreturn 0;\r\n}\r\nif (CHIP_INT_MODE_IS_BC(bp)) {\r\nBNX2X_ERR("IGU not normal mode, SRIOV can not be enabled\n");\r\nreturn 0;\r\n}\r\nbp->vfdb = kzalloc(sizeof(*(bp->vfdb)), GFP_KERNEL);\r\nif (!bp->vfdb) {\r\nBNX2X_ERR("failed to allocate vf database\n");\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\niov = &(bp->vfdb->sriov);\r\nerr = bnx2x_sriov_info(bp, iov);\r\nif (err)\r\ngoto failed;\r\nif (iov->total == 0)\r\ngoto failed;\r\niov->nr_virtfn = min_t(u16, iov->total, num_vfs_param);\r\nDP(BNX2X_MSG_IOV, "num_vfs_param was %d, nr_virtfn was %d\n",\r\nnum_vfs_param, iov->nr_virtfn);\r\nbp->vfdb->vfs = kzalloc(sizeof(struct bnx2x_virtf) *\r\nBNX2X_NR_VIRTFN(bp), GFP_KERNEL);\r\nif (!bp->vfdb->vfs) {\r\nBNX2X_ERR("failed to allocate vf array\n");\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nfor_each_vf(bp, i) {\r\nbnx2x_vf(bp, i, index) = i;\r\nbnx2x_vf(bp, i, abs_vfid) = iov->first_vf_in_pf + i;\r\nbnx2x_vf(bp, i, state) = VF_FREE;\r\nmutex_init(&bnx2x_vf(bp, i, op_mutex));\r\nbnx2x_vf(bp, i, op_current) = CHANNEL_TLV_NONE;\r\n}\r\nif (!bnx2x_get_vf_igu_cam_info(bp)) {\r\nBNX2X_ERR("No entries in IGU CAM for vfs\n");\r\nerr = -EINVAL;\r\ngoto failed;\r\n}\r\nbp->vfdb->vfqs = kzalloc(\r\nBNX2X_MAX_NUM_VF_QUEUES * sizeof(struct bnx2x_vf_queue),\r\nGFP_KERNEL);\r\nif (!bp->vfdb->vfqs) {\r\nBNX2X_ERR("failed to allocate vf queue array\n");\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nmutex_init(&bp->vfdb->event_mutex);\r\nmutex_init(&bp->vfdb->bulletin_mutex);\r\nif (SHMEM2_HAS(bp, sriov_switch_mode))\r\nSHMEM2_WR(bp, sriov_switch_mode, SRIOV_SWITCH_MODE_VEB);\r\nreturn 0;\r\nfailed:\r\nDP(BNX2X_MSG_IOV, "Failed err=%d\n", err);\r\n__bnx2x_iov_free_vfdb(bp);\r\nreturn err;\r\n}\r\nvoid bnx2x_iov_remove_one(struct bnx2x *bp)\r\n{\r\nint vf_idx;\r\nif (!IS_SRIOV(bp))\r\nreturn;\r\nbnx2x_disable_sriov(bp);\r\nfor (vf_idx = 0; vf_idx < bp->vfdb->sriov.total; vf_idx++) {\r\nbnx2x_pretend_func(bp,\r\nHW_VF_HANDLE(bp,\r\nbp->vfdb->sriov.first_vf_in_pf +\r\nvf_idx));\r\nDP(BNX2X_MSG_IOV, "disabling internal access for vf %d\n",\r\nbp->vfdb->sriov.first_vf_in_pf + vf_idx);\r\nbnx2x_vf_enable_internal(bp, 0);\r\nbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\r\n}\r\n__bnx2x_iov_free_vfdb(bp);\r\n}\r\nvoid bnx2x_iov_free_mem(struct bnx2x *bp)\r\n{\r\nint i;\r\nif (!IS_SRIOV(bp))\r\nreturn;\r\nfor (i = 0; i < BNX2X_VF_CIDS/ILT_PAGE_CIDS; i++) {\r\nstruct hw_dma *cxt = &bp->vfdb->context[i];\r\nBNX2X_PCI_FREE(cxt->addr, cxt->mapping, cxt->size);\r\n}\r\nBNX2X_PCI_FREE(BP_VFDB(bp)->sp_dma.addr,\r\nBP_VFDB(bp)->sp_dma.mapping,\r\nBP_VFDB(bp)->sp_dma.size);\r\nBNX2X_PCI_FREE(BP_VF_MBX_DMA(bp)->addr,\r\nBP_VF_MBX_DMA(bp)->mapping,\r\nBP_VF_MBX_DMA(bp)->size);\r\nBNX2X_PCI_FREE(BP_VF_BULLETIN_DMA(bp)->addr,\r\nBP_VF_BULLETIN_DMA(bp)->mapping,\r\nBP_VF_BULLETIN_DMA(bp)->size);\r\n}\r\nint bnx2x_iov_alloc_mem(struct bnx2x *bp)\r\n{\r\nsize_t tot_size;\r\nint i, rc = 0;\r\nif (!IS_SRIOV(bp))\r\nreturn rc;\r\ntot_size = (BP_VFDB(bp)->sriov.first_vf_in_pf + BNX2X_NR_VIRTFN(bp)) *\r\nBNX2X_CIDS_PER_VF * sizeof(union cdu_context);\r\nfor (i = 0; i < BNX2X_VF_CIDS/ILT_PAGE_CIDS; i++) {\r\nstruct hw_dma *cxt = BP_VF_CXT_PAGE(bp, i);\r\ncxt->size = min_t(size_t, tot_size, CDU_ILT_PAGE_SZ);\r\nif (cxt->size) {\r\ncxt->addr = BNX2X_PCI_ALLOC(&cxt->mapping, cxt->size);\r\nif (!cxt->addr)\r\ngoto alloc_mem_err;\r\n} else {\r\ncxt->addr = NULL;\r\ncxt->mapping = 0;\r\n}\r\ntot_size -= cxt->size;\r\n}\r\ntot_size = BNX2X_NR_VIRTFN(bp) * sizeof(struct bnx2x_vf_sp);\r\nBP_VFDB(bp)->sp_dma.addr = BNX2X_PCI_ALLOC(&BP_VFDB(bp)->sp_dma.mapping,\r\ntot_size);\r\nif (!BP_VFDB(bp)->sp_dma.addr)\r\ngoto alloc_mem_err;\r\nBP_VFDB(bp)->sp_dma.size = tot_size;\r\ntot_size = BNX2X_NR_VIRTFN(bp) * MBX_MSG_ALIGNED_SIZE;\r\nBP_VF_MBX_DMA(bp)->addr = BNX2X_PCI_ALLOC(&BP_VF_MBX_DMA(bp)->mapping,\r\ntot_size);\r\nif (!BP_VF_MBX_DMA(bp)->addr)\r\ngoto alloc_mem_err;\r\nBP_VF_MBX_DMA(bp)->size = tot_size;\r\ntot_size = BNX2X_NR_VIRTFN(bp) * BULLETIN_CONTENT_SIZE;\r\nBP_VF_BULLETIN_DMA(bp)->addr = BNX2X_PCI_ALLOC(&BP_VF_BULLETIN_DMA(bp)->mapping,\r\ntot_size);\r\nif (!BP_VF_BULLETIN_DMA(bp)->addr)\r\ngoto alloc_mem_err;\r\nBP_VF_BULLETIN_DMA(bp)->size = tot_size;\r\nreturn 0;\r\nalloc_mem_err:\r\nreturn -ENOMEM;\r\n}\r\nstatic void bnx2x_vfq_init(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_queue *q)\r\n{\r\nu8 cl_id = vfq_cl_id(vf, q);\r\nu8 func_id = FW_VF_HANDLE(vf->abs_vfid);\r\nunsigned long q_type = 0;\r\nset_bit(BNX2X_Q_TYPE_HAS_TX, &q_type);\r\nset_bit(BNX2X_Q_TYPE_HAS_RX, &q_type);\r\nbnx2x_init_queue_obj(bp, &q->sp_obj,\r\ncl_id, &q->cid, 1, func_id,\r\nbnx2x_vf_sp(bp, vf, q_data),\r\nbnx2x_vf_sp_map(bp, vf, q_data),\r\nq_type);\r\nq->sp_initialized = false;\r\nDP(BNX2X_MSG_IOV,\r\n"initialized vf %d's queue object. func id set to %d. cid set to 0x%x\n",\r\nvf->abs_vfid, q->sp_obj.func_id, q->cid);\r\n}\r\nstatic int bnx2x_max_speed_cap(struct bnx2x *bp)\r\n{\r\nu32 supported = bp->port.supported[bnx2x_get_link_cfg_idx(bp)];\r\nif (supported &\r\n(SUPPORTED_20000baseMLD2_Full | SUPPORTED_20000baseKR2_Full))\r\nreturn 20000;\r\nreturn 10000;\r\n}\r\nint bnx2x_iov_link_update_vf(struct bnx2x *bp, int idx)\r\n{\r\nstruct bnx2x_link_report_data *state = &bp->last_reported_link;\r\nstruct pf_vf_bulletin_content *bulletin;\r\nstruct bnx2x_virtf *vf;\r\nbool update = true;\r\nint rc = 0;\r\nrc = bnx2x_vf_op_prep(bp, idx, &vf, &bulletin, false);\r\nif (rc)\r\nreturn rc;\r\nmutex_lock(&bp->vfdb->bulletin_mutex);\r\nif (vf->link_cfg == IFLA_VF_LINK_STATE_AUTO) {\r\nbulletin->valid_bitmap |= 1 << LINK_VALID;\r\nbulletin->link_speed = state->line_speed;\r\nbulletin->link_flags = 0;\r\nif (test_bit(BNX2X_LINK_REPORT_LINK_DOWN,\r\n&state->link_report_flags))\r\nbulletin->link_flags |= VFPF_LINK_REPORT_LINK_DOWN;\r\nif (test_bit(BNX2X_LINK_REPORT_FD,\r\n&state->link_report_flags))\r\nbulletin->link_flags |= VFPF_LINK_REPORT_FULL_DUPLEX;\r\nif (test_bit(BNX2X_LINK_REPORT_RX_FC_ON,\r\n&state->link_report_flags))\r\nbulletin->link_flags |= VFPF_LINK_REPORT_RX_FC_ON;\r\nif (test_bit(BNX2X_LINK_REPORT_TX_FC_ON,\r\n&state->link_report_flags))\r\nbulletin->link_flags |= VFPF_LINK_REPORT_TX_FC_ON;\r\n} else if (vf->link_cfg == IFLA_VF_LINK_STATE_DISABLE &&\r\n!(bulletin->link_flags & VFPF_LINK_REPORT_LINK_DOWN)) {\r\nbulletin->valid_bitmap |= 1 << LINK_VALID;\r\nbulletin->link_flags |= VFPF_LINK_REPORT_LINK_DOWN;\r\n} else if (vf->link_cfg == IFLA_VF_LINK_STATE_ENABLE &&\r\n(bulletin->link_flags & VFPF_LINK_REPORT_LINK_DOWN)) {\r\nbulletin->valid_bitmap |= 1 << LINK_VALID;\r\nbulletin->link_speed = bnx2x_max_speed_cap(bp);\r\nbulletin->link_flags &= ~VFPF_LINK_REPORT_LINK_DOWN;\r\n} else {\r\nupdate = false;\r\n}\r\nif (update) {\r\nDP(NETIF_MSG_LINK | BNX2X_MSG_IOV,\r\n"vf %d mode %u speed %d flags %x\n", idx,\r\nvf->link_cfg, bulletin->link_speed, bulletin->link_flags);\r\nrc = bnx2x_post_vf_bulletin(bp, idx);\r\nif (rc) {\r\nBNX2X_ERR("failed to update VF[%d] bulletin\n", idx);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&bp->vfdb->bulletin_mutex);\r\nreturn rc;\r\n}\r\nint bnx2x_set_vf_link_state(struct net_device *dev, int idx, int link_state)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct bnx2x_virtf *vf = BP_VF(bp, idx);\r\nif (!vf)\r\nreturn -EINVAL;\r\nif (vf->link_cfg == link_state)\r\nreturn 0;\r\nvf->link_cfg = link_state;\r\nreturn bnx2x_iov_link_update_vf(bp, idx);\r\n}\r\nvoid bnx2x_iov_link_update(struct bnx2x *bp)\r\n{\r\nint vfid;\r\nif (!IS_SRIOV(bp))\r\nreturn;\r\nfor_each_vf(bp, vfid)\r\nbnx2x_iov_link_update_vf(bp, vfid);\r\n}\r\nint bnx2x_iov_nic_init(struct bnx2x *bp)\r\n{\r\nint vfid;\r\nif (!IS_SRIOV(bp)) {\r\nDP(BNX2X_MSG_IOV, "vfdb was not allocated\n");\r\nreturn 0;\r\n}\r\nDP(BNX2X_MSG_IOV, "num of vfs: %d\n", (bp)->vfdb->sriov.nr_virtfn);\r\nmsleep(100);\r\nfor_each_vf(bp, vfid) {\r\nstruct bnx2x_virtf *vf = BP_VF(bp, vfid);\r\nint base_vf_cid = (BP_VFDB(bp)->sriov.first_vf_in_pf + vfid) *\r\nBNX2X_CIDS_PER_VF;\r\nunion cdu_context *base_cxt = (union cdu_context *)\r\nBP_VF_CXT_PAGE(bp, base_vf_cid/ILT_PAGE_CIDS)->addr +\r\n(base_vf_cid & (ILT_PAGE_CIDS-1));\r\nDP(BNX2X_MSG_IOV,\r\n"VF[%d] Max IGU SBs: %d, base vf cid 0x%x, base cid 0x%x, base cxt %p\n",\r\nvf->abs_vfid, vf_sb_count(vf), base_vf_cid,\r\nBNX2X_FIRST_VF_CID + base_vf_cid, base_cxt);\r\nbnx2x_iov_static_resc(bp, vf);\r\nvf->filter_state = 0;\r\nvf->sp_cl_id = bnx2x_fp(bp, 0, cl_id);\r\nbnx2x_init_credit_pool(&vf->vf_vlans_pool, 0,\r\nvf_vlan_rules_cnt(vf));\r\nbnx2x_init_credit_pool(&vf->vf_macs_pool, 0,\r\nvf_mac_rules_cnt(vf));\r\nvf->mcast_list_len = 0;\r\nbnx2x_init_mcast_obj(bp, &vf->mcast_obj, 0xFF,\r\n0xFF, 0xFF, 0xFF,\r\nbnx2x_vf_sp(bp, vf, mcast_rdata),\r\nbnx2x_vf_sp_map(bp, vf, mcast_rdata),\r\nBNX2X_FILTER_MCAST_PENDING,\r\n&vf->filter_state,\r\nBNX2X_OBJ_TYPE_RX_TX);\r\nBP_VF_MBX(bp, vfid)->msg = (struct bnx2x_vf_mbx_msg *)\r\n(((u8 *)BP_VF_MBX_DMA(bp)->addr) + vfid *\r\nMBX_MSG_ALIGNED_SIZE);\r\nBP_VF_MBX(bp, vfid)->msg_mapping = BP_VF_MBX_DMA(bp)->mapping +\r\nvfid * MBX_MSG_ALIGNED_SIZE;\r\nbnx2x_vf_enable_mbx(bp, vf->abs_vfid);\r\n}\r\nfor_each_vf(bp, vfid) {\r\nstruct bnx2x_virtf *vf = BP_VF(bp, vfid);\r\nvf->bus = bnx2x_vf_bus(bp, vfid);\r\nvf->devfn = bnx2x_vf_devfn(bp, vfid);\r\nbnx2x_vf_set_bars(bp, vf);\r\nDP(BNX2X_MSG_IOV,\r\n"VF info[%d]: bus 0x%x, devfn 0x%x, bar0 [0x%x, %d], bar1 [0x%x, %d], bar2 [0x%x, %d]\n",\r\nvf->abs_vfid, vf->bus, vf->devfn,\r\n(unsigned)vf->bars[0].bar, vf->bars[0].size,\r\n(unsigned)vf->bars[1].bar, vf->bars[1].size,\r\n(unsigned)vf->bars[2].bar, vf->bars[2].size);\r\n}\r\nreturn 0;\r\n}\r\nint bnx2x_iov_chip_cleanup(struct bnx2x *bp)\r\n{\r\nint i;\r\nif (!IS_SRIOV(bp))\r\nreturn 0;\r\nfor_each_vf(bp, i)\r\nbnx2x_vf_release(bp, BP_VF(bp, i));\r\nreturn 0;\r\n}\r\nint bnx2x_iov_init_ilt(struct bnx2x *bp, u16 line)\r\n{\r\nint i;\r\nstruct bnx2x_ilt *ilt = BP_ILT(bp);\r\nif (!IS_SRIOV(bp))\r\nreturn line;\r\nfor (i = 0; i < BNX2X_VF_CIDS/ILT_PAGE_CIDS; i++) {\r\nstruct hw_dma *hw_cxt = BP_VF_CXT_PAGE(bp, i);\r\nilt->lines[line+i].page = hw_cxt->addr;\r\nilt->lines[line+i].page_mapping = hw_cxt->mapping;\r\nilt->lines[line+i].size = hw_cxt->size;\r\n}\r\nreturn line + i;\r\n}\r\nstatic u8 bnx2x_iov_is_vf_cid(struct bnx2x *bp, u16 cid)\r\n{\r\nreturn ((cid >= BNX2X_FIRST_VF_CID) &&\r\n((cid - BNX2X_FIRST_VF_CID) < BNX2X_VF_CIDS));\r\n}\r\nstatic\r\nvoid bnx2x_vf_handle_classification_eqe(struct bnx2x *bp,\r\nstruct bnx2x_vf_queue *vfq,\r\nunion event_ring_elem *elem)\r\n{\r\nunsigned long ramrod_flags = 0;\r\nint rc = 0;\r\nu32 echo = le32_to_cpu(elem->message.data.eth_event.echo);\r\nset_bit(RAMROD_CONT, &ramrod_flags);\r\nswitch (echo >> BNX2X_SWCID_SHIFT) {\r\ncase BNX2X_FILTER_MAC_PENDING:\r\nrc = vfq->mac_obj.complete(bp, &vfq->mac_obj, elem,\r\n&ramrod_flags);\r\nbreak;\r\ncase BNX2X_FILTER_VLAN_PENDING:\r\nrc = vfq->vlan_obj.complete(bp, &vfq->vlan_obj, elem,\r\n&ramrod_flags);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unsupported classification command: 0x%x\n", echo);\r\nreturn;\r\n}\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to schedule new commands: %d\n", rc);\r\nelse if (rc > 0)\r\nDP(BNX2X_MSG_IOV, "Scheduled next pending commands...\n");\r\n}\r\nstatic\r\nvoid bnx2x_vf_handle_mcast_eqe(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf)\r\n{\r\nstruct bnx2x_mcast_ramrod_params rparam = {NULL};\r\nint rc;\r\nrparam.mcast_obj = &vf->mcast_obj;\r\nvf->mcast_obj.raw.clear_pending(&vf->mcast_obj.raw);\r\nif (vf->mcast_obj.check_pending(&vf->mcast_obj)) {\r\nrc = bnx2x_config_mcast(bp, &rparam, BNX2X_MCAST_CMD_CONT);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to send pending mcast commands: %d\n",\r\nrc);\r\n}\r\n}\r\nstatic\r\nvoid bnx2x_vf_handle_filters_eqe(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf)\r\n{\r\nsmp_mb__before_atomic();\r\nclear_bit(BNX2X_FILTER_RX_MODE_PENDING, &vf->filter_state);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic void bnx2x_vf_handle_rss_update_eqe(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf)\r\n{\r\nvf->rss_conf_obj.raw.clear_pending(&vf->rss_conf_obj.raw);\r\n}\r\nint bnx2x_iov_eq_sp_event(struct bnx2x *bp, union event_ring_elem *elem)\r\n{\r\nstruct bnx2x_virtf *vf;\r\nint qidx = 0, abs_vfid;\r\nu8 opcode;\r\nu16 cid = 0xffff;\r\nif (!IS_SRIOV(bp))\r\nreturn 1;\r\nopcode = elem->message.opcode;\r\nswitch (opcode) {\r\ncase EVENT_RING_OPCODE_CFC_DEL:\r\ncid = SW_CID(elem->message.data.cfc_del_event.cid);\r\nDP(BNX2X_MSG_IOV, "checking cfc-del comp cid=%d\n", cid);\r\nbreak;\r\ncase EVENT_RING_OPCODE_CLASSIFICATION_RULES:\r\ncase EVENT_RING_OPCODE_MULTICAST_RULES:\r\ncase EVENT_RING_OPCODE_FILTERS_RULES:\r\ncase EVENT_RING_OPCODE_RSS_UPDATE_RULES:\r\ncid = SW_CID(elem->message.data.eth_event.echo);\r\nDP(BNX2X_MSG_IOV, "checking filtering comp cid=%d\n", cid);\r\nbreak;\r\ncase EVENT_RING_OPCODE_VF_FLR:\r\nabs_vfid = elem->message.data.vf_flr_event.vf_id;\r\nDP(BNX2X_MSG_IOV, "Got VF FLR notification abs_vfid=%d\n",\r\nabs_vfid);\r\ngoto get_vf;\r\ncase EVENT_RING_OPCODE_MALICIOUS_VF:\r\nabs_vfid = elem->message.data.malicious_vf_event.vf_id;\r\nBNX2X_ERR("Got VF MALICIOUS notification abs_vfid=%d err_id=0x%x\n",\r\nabs_vfid,\r\nelem->message.data.malicious_vf_event.err_id);\r\ngoto get_vf;\r\ndefault:\r\nreturn 1;\r\n}\r\nif (!bnx2x_iov_is_vf_cid(bp, cid)) {\r\nDP(BNX2X_MSG_IOV, "cid is outside vf range: %d\n", cid);\r\nreturn 1;\r\n}\r\nqidx = cid & ((1 << BNX2X_VF_CID_WND)-1);\r\nabs_vfid = (cid >> BNX2X_VF_CID_WND) & (BNX2X_MAX_NUM_OF_VFS-1);\r\nget_vf:\r\nvf = bnx2x_vf_by_abs_fid(bp, abs_vfid);\r\nif (!vf) {\r\nBNX2X_ERR("EQ completion for unknown VF, cid %d, abs_vfid %d\n",\r\ncid, abs_vfid);\r\nreturn 0;\r\n}\r\nswitch (opcode) {\r\ncase EVENT_RING_OPCODE_CFC_DEL:\r\nDP(BNX2X_MSG_IOV, "got VF [%d:%d] cfc delete ramrod\n",\r\nvf->abs_vfid, qidx);\r\nvfq_get(vf, qidx)->sp_obj.complete_cmd(bp,\r\n&vfq_get(vf,\r\nqidx)->sp_obj,\r\nBNX2X_Q_CMD_CFC_DEL);\r\nbreak;\r\ncase EVENT_RING_OPCODE_CLASSIFICATION_RULES:\r\nDP(BNX2X_MSG_IOV, "got VF [%d:%d] set mac/vlan ramrod\n",\r\nvf->abs_vfid, qidx);\r\nbnx2x_vf_handle_classification_eqe(bp, vfq_get(vf, qidx), elem);\r\nbreak;\r\ncase EVENT_RING_OPCODE_MULTICAST_RULES:\r\nDP(BNX2X_MSG_IOV, "got VF [%d:%d] set mcast ramrod\n",\r\nvf->abs_vfid, qidx);\r\nbnx2x_vf_handle_mcast_eqe(bp, vf);\r\nbreak;\r\ncase EVENT_RING_OPCODE_FILTERS_RULES:\r\nDP(BNX2X_MSG_IOV, "got VF [%d:%d] set rx-mode ramrod\n",\r\nvf->abs_vfid, qidx);\r\nbnx2x_vf_handle_filters_eqe(bp, vf);\r\nbreak;\r\ncase EVENT_RING_OPCODE_RSS_UPDATE_RULES:\r\nDP(BNX2X_MSG_IOV, "got VF [%d:%d] RSS update ramrod\n",\r\nvf->abs_vfid, qidx);\r\nbnx2x_vf_handle_rss_update_eqe(bp, vf);\r\ncase EVENT_RING_OPCODE_VF_FLR:\r\ncase EVENT_RING_OPCODE_MALICIOUS_VF:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct bnx2x_virtf *bnx2x_vf_by_cid(struct bnx2x *bp, int vf_cid)\r\n{\r\nint abs_vfid = (vf_cid >> BNX2X_VF_CID_WND) & (BNX2X_MAX_NUM_OF_VFS-1);\r\nreturn bnx2x_vf_by_abs_fid(bp, abs_vfid);\r\n}\r\nvoid bnx2x_iov_set_queue_sp_obj(struct bnx2x *bp, int vf_cid,\r\nstruct bnx2x_queue_sp_obj **q_obj)\r\n{\r\nstruct bnx2x_virtf *vf;\r\nif (!IS_SRIOV(bp))\r\nreturn;\r\nvf = bnx2x_vf_by_cid(bp, vf_cid);\r\nif (vf) {\r\nint q_index = vf_cid & ((1 << BNX2X_VF_CID_WND)-1);\r\n*q_obj = &bnx2x_vfq(vf, q_index, sp_obj);\r\n} else {\r\nBNX2X_ERR("No vf matching cid %d\n", vf_cid);\r\n}\r\n}\r\nvoid bnx2x_iov_adjust_stats_req(struct bnx2x *bp)\r\n{\r\nint i;\r\nint first_queue_query_index, num_queues_req;\r\ndma_addr_t cur_data_offset;\r\nstruct stats_query_entry *cur_query_entry;\r\nu8 stats_count = 0;\r\nbool is_fcoe = false;\r\nif (!IS_SRIOV(bp))\r\nreturn;\r\nif (!NO_FCOE(bp))\r\nis_fcoe = true;\r\nnum_queues_req = BNX2X_NUM_ETH_QUEUES(bp) + is_fcoe;\r\nfirst_queue_query_index = BNX2X_FIRST_QUEUE_QUERY_IDX -\r\n(is_fcoe ? 0 : 1);\r\nDP_AND((BNX2X_MSG_IOV | BNX2X_MSG_STATS),\r\n"BNX2X_NUM_ETH_QUEUES %d, is_fcoe %d, first_queue_query_index %d => determined the last non virtual statistics query index is %d. Will add queries on top of that\n",\r\nBNX2X_NUM_ETH_QUEUES(bp), is_fcoe, first_queue_query_index,\r\nfirst_queue_query_index + num_queues_req);\r\ncur_data_offset = bp->fw_stats_data_mapping +\r\noffsetof(struct bnx2x_fw_stats_data, queue_stats) +\r\nnum_queues_req * sizeof(struct per_queue_stats);\r\ncur_query_entry = &bp->fw_stats_req->\r\nquery[first_queue_query_index + num_queues_req];\r\nfor_each_vf(bp, i) {\r\nint j;\r\nstruct bnx2x_virtf *vf = BP_VF(bp, i);\r\nif (vf->state != VF_ENABLED) {\r\nDP_AND((BNX2X_MSG_IOV | BNX2X_MSG_STATS),\r\n"vf %d not enabled so no stats for it\n",\r\nvf->abs_vfid);\r\ncontinue;\r\n}\r\nDP(BNX2X_MSG_IOV, "add addresses for vf %d\n", vf->abs_vfid);\r\nfor_each_vfq(vf, j) {\r\nstruct bnx2x_vf_queue *rxq = vfq_get(vf, j);\r\ndma_addr_t q_stats_addr =\r\nvf->fw_stat_map + j * vf->stats_stride;\r\nif (bnx2x_get_q_logical_state(bp, &rxq->sp_obj) ==\r\nBNX2X_Q_LOGICAL_STATE_STOPPED)\r\ncontinue;\r\ncur_query_entry->kind = STATS_TYPE_QUEUE;\r\ncur_query_entry->index = vfq_stat_id(vf, rxq);\r\ncur_query_entry->funcID =\r\ncpu_to_le16(FW_VF_HANDLE(vf->abs_vfid));\r\ncur_query_entry->address.hi =\r\ncpu_to_le32(U64_HI(q_stats_addr));\r\ncur_query_entry->address.lo =\r\ncpu_to_le32(U64_LO(q_stats_addr));\r\nDP(BNX2X_MSG_IOV,\r\n"added address %x %x for vf %d queue %d client %d\n",\r\ncur_query_entry->address.hi,\r\ncur_query_entry->address.lo, cur_query_entry->funcID,\r\nj, cur_query_entry->index);\r\ncur_query_entry++;\r\ncur_data_offset += sizeof(struct per_queue_stats);\r\nstats_count++;\r\nif (vf->cfg_flags & VF_CFG_STATS_COALESCE)\r\nbreak;\r\n}\r\n}\r\nbp->fw_stats_req->hdr.cmd_num = bp->fw_stats_num + stats_count;\r\n}\r\nstatic void bnx2x_vf_qtbl_set_q(struct bnx2x *bp, u8 abs_vfid, u8 qid,\r\nu8 enable)\r\n{\r\nu32 reg = PXP_REG_HST_ZONE_PERMISSION_TABLE + qid * 4;\r\nu32 val = enable ? (abs_vfid | (1 << 6)) : 0;\r\nREG_WR(bp, reg, val);\r\n}\r\nstatic void bnx2x_vf_clr_qtbl(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nint i;\r\nfor_each_vfq(vf, i)\r\nbnx2x_vf_qtbl_set_q(bp, vf->abs_vfid,\r\nvfq_qzone_id(vf, vfq_get(vf, i)), false);\r\n}\r\nstatic void bnx2x_vf_igu_disable(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nu32 val;\r\nbnx2x_pretend_func(bp, HW_VF_HANDLE(bp, vf->abs_vfid));\r\nval = REG_RD(bp, IGU_REG_VF_CONFIGURATION);\r\nval &= ~(IGU_VF_CONF_MSI_MSIX_EN | IGU_VF_CONF_SINGLE_ISR_EN |\r\nIGU_VF_CONF_FUNC_EN | IGU_VF_CONF_PARENT_MASK);\r\nREG_WR(bp, IGU_REG_VF_CONFIGURATION, val);\r\nbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\r\n}\r\nu8 bnx2x_vf_max_queue_cnt(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nreturn min_t(u8, min_t(u8, vf_sb_count(vf), BNX2X_CIDS_PER_VF),\r\nBNX2X_VF_MAX_QUEUES);\r\n}\r\nstatic\r\nint bnx2x_vf_chk_avail_resc(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct vf_pf_resc_request *req_resc)\r\n{\r\nu8 rxq_cnt = vf_rxq_count(vf) ? : bnx2x_vf_max_queue_cnt(bp, vf);\r\nu8 txq_cnt = vf_txq_count(vf) ? : bnx2x_vf_max_queue_cnt(bp, vf);\r\nreturn ((req_resc->num_rxqs <= rxq_cnt) &&\r\n(req_resc->num_txqs <= txq_cnt) &&\r\n(req_resc->num_sbs <= vf_sb_count(vf)) &&\r\n(req_resc->num_mac_filters <= vf_mac_rules_cnt(vf)) &&\r\n(req_resc->num_vlan_filters <= vf_vlan_rules_cnt(vf)));\r\n}\r\nint bnx2x_vf_acquire(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct vf_pf_resc_request *resc)\r\n{\r\nint base_vf_cid = (BP_VFDB(bp)->sriov.first_vf_in_pf + vf->index) *\r\nBNX2X_CIDS_PER_VF;\r\nunion cdu_context *base_cxt = (union cdu_context *)\r\nBP_VF_CXT_PAGE(bp, base_vf_cid/ILT_PAGE_CIDS)->addr +\r\n(base_vf_cid & (ILT_PAGE_CIDS-1));\r\nint i;\r\nif (vf->state == VF_ACQUIRED) {\r\nDP(BNX2X_MSG_IOV, "VF[%d] Trying to re-acquire resources (VF was not released or FLR'd)\n",\r\nvf->abs_vfid);\r\nif (!bnx2x_vf_chk_avail_resc(bp, vf, resc)) {\r\nBNX2X_ERR("VF[%d] When re-acquiring resources, requested numbers must be <= then previously acquired numbers\n",\r\nvf->abs_vfid);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nif (vf->state != VF_FREE && vf->state != VF_RESET) {\r\nBNX2X_ERR("VF[%d] Can not acquire a VF with state %d\n",\r\nvf->abs_vfid, vf->state);\r\nreturn -EINVAL;\r\n}\r\nif (!bnx2x_vf_chk_avail_resc(bp, vf, resc)) {\r\nDP(BNX2X_MSG_IOV,\r\n"cannot fulfill vf resource request. Placing maximal available values in response\n");\r\nreturn -ENOMEM;\r\n}\r\nvf_sb_count(vf) = resc->num_sbs;\r\nvf_rxq_count(vf) = resc->num_rxqs ? : bnx2x_vf_max_queue_cnt(bp, vf);\r\nvf_txq_count(vf) = resc->num_txqs ? : bnx2x_vf_max_queue_cnt(bp, vf);\r\nDP(BNX2X_MSG_IOV,\r\n"Fulfilling vf request: sb count %d, tx_count %d, rx_count %d, mac_rules_count %d, vlan_rules_count %d\n",\r\nvf_sb_count(vf), vf_rxq_count(vf),\r\nvf_txq_count(vf), vf_mac_rules_cnt(vf),\r\nvf_vlan_rules_cnt(vf));\r\nif (!vf->vfqs) {\r\nDP(BNX2X_MSG_IOV, "vf->vfqs was not allocated\n");\r\nreturn -EINVAL;\r\n}\r\nfor_each_vfq(vf, i) {\r\nstruct bnx2x_vf_queue *q = vfq_get(vf, i);\r\nif (!q) {\r\nBNX2X_ERR("q number %d was not allocated\n", i);\r\nreturn -EINVAL;\r\n}\r\nq->index = i;\r\nq->cxt = &((base_cxt + i)->eth);\r\nq->cid = BNX2X_FIRST_VF_CID + base_vf_cid + i;\r\nDP(BNX2X_MSG_IOV, "VFQ[%d:%d]: index %d, cid 0x%x, cxt %p\n",\r\nvf->abs_vfid, i, q->index, q->cid, q->cxt);\r\nbnx2x_vfq_init(bp, vf, q);\r\n}\r\nvf->state = VF_ACQUIRED;\r\nreturn 0;\r\n}\r\nint bnx2x_vf_init(struct bnx2x *bp, struct bnx2x_virtf *vf, dma_addr_t *sb_map)\r\n{\r\nstruct bnx2x_func_init_params func_init = {0};\r\nint i;\r\nfor_each_vf_sb(vf, i)\r\nbnx2x_init_sb(bp, (dma_addr_t)sb_map[i], vf->abs_vfid, true,\r\nvf_igu_sb(vf, i), vf_igu_sb(vf, i));\r\nif (vf->state != VF_ACQUIRED) {\r\nDP(BNX2X_MSG_IOV, "VF[%d] is not in VF_ACQUIRED, but %d\n",\r\nvf->abs_vfid, vf->state);\r\nreturn -EINVAL;\r\n}\r\nmsleep(100);\r\nif (bnx2x_vf_flr_clnup_epilog(bp, vf->abs_vfid))\r\nreturn -EBUSY;\r\nREG_WR(bp, IGU_REG_STATISTIC_NUM_MESSAGE_SENT + vf->abs_vfid * 4 , 0);\r\nfunc_init.pf_id = BP_FUNC(bp);\r\nfunc_init.func_id = FW_VF_HANDLE(vf->abs_vfid);\r\nbnx2x_func_init(bp, &func_init);\r\nbnx2x_vf_enable_access(bp, vf->abs_vfid);\r\nbnx2x_vf_enable_traffic(bp, vf);\r\nfor_each_vfq(vf, i)\r\nbnx2x_vf_qtbl_set_q(bp, vf->abs_vfid,\r\nvfq_qzone_id(vf, vfq_get(vf, i)), true);\r\nvf->state = VF_ENABLED;\r\nbnx2x_post_vf_bulletin(bp, vf->index);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_set_vf_state(void *cookie)\r\n{\r\nstruct set_vf_state_cookie *p = (struct set_vf_state_cookie *)cookie;\r\np->vf->state = p->state;\r\n}\r\nint bnx2x_vf_close(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nint rc = 0, i;\r\nDP(BNX2X_MSG_IOV, "vf[%d]\n", vf->abs_vfid);\r\nfor (i = 0; i < vf_rxq_count(vf); i++) {\r\nrc = bnx2x_vf_queue_teardown(bp, vf, i);\r\nif (rc)\r\ngoto op_err;\r\n}\r\nDP(BNX2X_MSG_IOV, "disabling igu\n");\r\nbnx2x_vf_igu_disable(bp, vf);\r\nDP(BNX2X_MSG_IOV, "clearing qtbl\n");\r\nbnx2x_vf_clr_qtbl(bp, vf);\r\n{\r\nstruct set_vf_state_cookie cookie;\r\ncookie.vf = vf;\r\ncookie.state = VF_ACQUIRED;\r\nrc = bnx2x_stats_safe_exec(bp, bnx2x_set_vf_state, &cookie);\r\nif (rc)\r\ngoto op_err;\r\n}\r\nDP(BNX2X_MSG_IOV, "set state to acquired\n");\r\nreturn 0;\r\nop_err:\r\nBNX2X_ERR("vf[%d] CLOSE error: rc %d\n", vf->abs_vfid, rc);\r\nreturn rc;\r\n}\r\nint bnx2x_vf_free(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nint rc;\r\nDP(BNX2X_MSG_IOV, "VF[%d] STATE: %s\n", vf->abs_vfid,\r\nvf->state == VF_FREE ? "Free" :\r\nvf->state == VF_ACQUIRED ? "Acquired" :\r\nvf->state == VF_ENABLED ? "Enabled" :\r\nvf->state == VF_RESET ? "Reset" :\r\n"Unknown");\r\nswitch (vf->state) {\r\ncase VF_ENABLED:\r\nrc = bnx2x_vf_close(bp, vf);\r\nif (rc)\r\ngoto op_err;\r\ncase VF_ACQUIRED:\r\nDP(BNX2X_MSG_IOV, "about to free resources\n");\r\nbnx2x_vf_free_resc(bp, vf);\r\nbreak;\r\ncase VF_FREE:\r\ncase VF_RESET:\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\nop_err:\r\nBNX2X_ERR("VF[%d] RELEASE error: rc %d\n", vf->abs_vfid, rc);\r\nreturn rc;\r\n}\r\nint bnx2x_vf_rss_update(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_config_rss_params *rss)\r\n{\r\nDP(BNX2X_MSG_IOV, "vf[%d]\n", vf->abs_vfid);\r\nset_bit(RAMROD_COMP_WAIT, &rss->ramrod_flags);\r\nreturn bnx2x_config_rss(bp, rss);\r\n}\r\nint bnx2x_vf_tpa_update(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct vfpf_tpa_tlv *tlv,\r\nstruct bnx2x_queue_update_tpa_params *params)\r\n{\r\naligned_u64 *sge_addr = tlv->tpa_client_info.sge_addr;\r\nstruct bnx2x_queue_state_params qstate;\r\nint qid, rc = 0;\r\nDP(BNX2X_MSG_IOV, "vf[%d]\n", vf->abs_vfid);\r\nmemset(&qstate, 0, sizeof(struct bnx2x_queue_state_params));\r\nmemcpy(&qstate.params.update_tpa, params,\r\nsizeof(struct bnx2x_queue_update_tpa_params));\r\nqstate.cmd = BNX2X_Q_CMD_UPDATE_TPA;\r\nset_bit(RAMROD_COMP_WAIT, &qstate.ramrod_flags);\r\nfor (qid = 0; qid < vf_rxq_count(vf); qid++) {\r\nqstate.q_obj = &bnx2x_vfq(vf, qid, sp_obj);\r\nqstate.params.update_tpa.sge_map = sge_addr[qid];\r\nDP(BNX2X_MSG_IOV, "sge_addr[%d:%d] %08x:%08x\n",\r\nvf->abs_vfid, qid, U64_HI(sge_addr[qid]),\r\nU64_LO(sge_addr[qid]));\r\nrc = bnx2x_queue_state_change(bp, &qstate);\r\nif (rc) {\r\nBNX2X_ERR("Failed to configure sge_addr %08x:%08x for [%d:%d]\n",\r\nU64_HI(sge_addr[qid]), U64_LO(sge_addr[qid]),\r\nvf->abs_vfid, qid);\r\nreturn rc;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint bnx2x_vf_release(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nint rc;\r\nDP(BNX2X_MSG_IOV, "PF releasing vf %d\n", vf->abs_vfid);\r\nbnx2x_lock_vf_pf_channel(bp, vf, CHANNEL_TLV_PF_RELEASE_VF);\r\nrc = bnx2x_vf_free(bp, vf);\r\nif (rc)\r\nWARN(rc,\r\n"VF[%d] Failed to allocate resources for release op- rc=%d\n",\r\nvf->abs_vfid, rc);\r\nbnx2x_unlock_vf_pf_channel(bp, vf, CHANNEL_TLV_PF_RELEASE_VF);\r\nreturn rc;\r\n}\r\nvoid bnx2x_lock_vf_pf_channel(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nenum channel_tlvs tlv)\r\n{\r\nif (!bnx2x_tlv_supported(tlv)) {\r\nBNX2X_ERR("attempting to lock with unsupported tlv. Aborting\n");\r\nreturn;\r\n}\r\nmutex_lock(&vf->op_mutex);\r\nvf->op_current = tlv;\r\nDP(BNX2X_MSG_IOV, "VF[%d]: vf pf channel locked by %d\n",\r\nvf->abs_vfid, tlv);\r\n}\r\nvoid bnx2x_unlock_vf_pf_channel(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nenum channel_tlvs expected_tlv)\r\n{\r\nenum channel_tlvs current_tlv;\r\nif (!vf) {\r\nBNX2X_ERR("VF was %p\n", vf);\r\nreturn;\r\n}\r\ncurrent_tlv = vf->op_current;\r\nif (!bnx2x_tlv_supported(expected_tlv))\r\nreturn;\r\nWARN(expected_tlv != vf->op_current,\r\n"lock mismatch: expected %d found %d", expected_tlv,\r\nvf->op_current);\r\nvf->op_current = CHANNEL_TLV_NONE;\r\nmutex_unlock(&vf->op_mutex);\r\nDP(BNX2X_MSG_IOV, "VF[%d]: vf pf channel unlocked by %d\n",\r\nvf->abs_vfid, current_tlv);\r\n}\r\nstatic int bnx2x_set_pf_tx_switching(struct bnx2x *bp, bool enable)\r\n{\r\nstruct bnx2x_queue_state_params q_params;\r\nu32 prev_flags;\r\nint i, rc;\r\nprev_flags = bp->flags;\r\nif (enable)\r\nbp->flags |= TX_SWITCHING;\r\nelse\r\nbp->flags &= ~TX_SWITCHING;\r\nif (prev_flags == bp->flags)\r\nreturn 0;\r\nif ((bp->state != BNX2X_STATE_OPEN) ||\r\n(bnx2x_get_q_logical_state(bp,\r\n&bnx2x_sp_obj(bp, &bp->fp[0]).q_obj) !=\r\nBNX2X_Q_LOGICAL_STATE_ACTIVE))\r\nreturn 0;\r\nmemset(&q_params, 0, sizeof(q_params));\r\n__set_bit(RAMROD_COMP_WAIT, &q_params.ramrod_flags);\r\nq_params.cmd = BNX2X_Q_CMD_UPDATE;\r\n__set_bit(BNX2X_Q_UPDATE_TX_SWITCHING_CHNG,\r\n&q_params.params.update.update_flags);\r\nif (enable)\r\n__set_bit(BNX2X_Q_UPDATE_TX_SWITCHING,\r\n&q_params.params.update.update_flags);\r\nelse\r\n__clear_bit(BNX2X_Q_UPDATE_TX_SWITCHING,\r\n&q_params.params.update.update_flags);\r\nfor_each_eth_queue(bp, i) {\r\nstruct bnx2x_fastpath *fp = &bp->fp[i];\r\nq_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\r\nrc = bnx2x_queue_state_change(bp, &q_params);\r\nif (rc) {\r\nBNX2X_ERR("Failed to configure Tx switching\n");\r\nreturn rc;\r\n}\r\n}\r\nDP(BNX2X_MSG_IOV, "%s Tx Switching\n", enable ? "Enabled" : "Disabled");\r\nreturn 0;\r\n}\r\nint bnx2x_sriov_configure(struct pci_dev *dev, int num_vfs_param)\r\n{\r\nstruct bnx2x *bp = netdev_priv(pci_get_drvdata(dev));\r\nif (!IS_SRIOV(bp)) {\r\nBNX2X_ERR("failed to configure SR-IOV since vfdb was not allocated. Check dmesg for errors in probe stage\n");\r\nreturn -EINVAL;\r\n}\r\nDP(BNX2X_MSG_IOV, "bnx2x_sriov_configure called with %d, BNX2X_NR_VIRTFN(bp) was %d\n",\r\nnum_vfs_param, BNX2X_NR_VIRTFN(bp));\r\nif (bp->state != BNX2X_STATE_OPEN) {\r\nBNX2X_ERR("VF num configuration via sysfs not supported while PF is down\n");\r\nreturn -EINVAL;\r\n}\r\nif (num_vfs_param > BNX2X_NR_VIRTFN(bp)) {\r\nBNX2X_ERR("truncating requested number of VFs (%d) down to maximum allowed (%d)\n",\r\nnum_vfs_param, BNX2X_NR_VIRTFN(bp));\r\nnum_vfs_param = BNX2X_NR_VIRTFN(bp);\r\n}\r\nbp->requested_nr_virtfn = num_vfs_param;\r\nif (num_vfs_param == 0) {\r\nbnx2x_set_pf_tx_switching(bp, false);\r\nbnx2x_disable_sriov(bp);\r\nreturn 0;\r\n} else {\r\nreturn bnx2x_enable_sriov(bp);\r\n}\r\n}\r\nint bnx2x_enable_sriov(struct bnx2x *bp)\r\n{\r\nint rc = 0, req_vfs = bp->requested_nr_virtfn;\r\nint vf_idx, sb_idx, vfq_idx, qcount, first_vf;\r\nu32 igu_entry, address;\r\nu16 num_vf_queues;\r\nif (req_vfs == 0)\r\nreturn 0;\r\nfirst_vf = bp->vfdb->sriov.first_vf_in_pf;\r\nnum_vf_queues = min_t(u16, BNX2X_VF_MAX_QUEUES,\r\nBP_VFDB(bp)->vf_sbs_pool / req_vfs);\r\nfor (vf_idx = 0; vf_idx < req_vfs; vf_idx++) {\r\nstruct bnx2x_virtf *vf = BP_VF(bp, vf_idx);\r\nvf->sb_count = 0;\r\nvf_sb_count(BP_VF(bp, vf_idx)) = 0;\r\n}\r\nbp->vfdb->vf_sbs_pool = 0;\r\nsb_idx = BP_VFDB(bp)->first_vf_igu_entry;\r\naddress = IGU_REG_MAPPING_MEMORY + sb_idx * IGU_ENTRY_SIZE;\r\nfor (vf_idx = first_vf; vf_idx < first_vf + req_vfs; vf_idx++) {\r\nfor (vfq_idx = 0; vfq_idx < num_vf_queues; vfq_idx++) {\r\nigu_entry = vf_idx << IGU_REG_MAPPING_MEMORY_FID_SHIFT |\r\nvfq_idx << IGU_REG_MAPPING_MEMORY_VECTOR_SHIFT |\r\nIGU_REG_MAPPING_MEMORY_VALID;\r\nDP(BNX2X_MSG_IOV, "assigning sb %d to vf %d\n",\r\nsb_idx, vf_idx);\r\nREG_WR(bp, address, igu_entry);\r\nsb_idx++;\r\naddress += IGU_ENTRY_SIZE;\r\n}\r\n}\r\nbnx2x_get_vf_igu_cam_info(bp);\r\nDP(BNX2X_MSG_IOV, "vf_sbs_pool %d, num_vf_queues %d\n",\r\nBP_VFDB(bp)->vf_sbs_pool, num_vf_queues);\r\nqcount = 0;\r\nfor_each_vf(bp, vf_idx) {\r\nstruct bnx2x_virtf *vf = BP_VF(bp, vf_idx);\r\nvf->vfqs = &bp->vfdb->vfqs[qcount];\r\nqcount += vf_sb_count(vf);\r\nbnx2x_iov_static_resc(bp, vf);\r\n}\r\nfor (vf_idx = first_vf; vf_idx < first_vf + req_vfs; vf_idx++) {\r\nbnx2x_pretend_func(bp, HW_VF_HANDLE(bp, vf_idx));\r\nREG_WR(bp, PCICFG_OFFSET + GRC_CONFIG_REG_VF_MSIX_CONTROL,\r\nnum_vf_queues - 1);\r\nDP(BNX2X_MSG_IOV, "set msix vec num in VF %d cfg space to %d\n",\r\nvf_idx, num_vf_queues - 1);\r\n}\r\nbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\r\nDP(BNX2X_MSG_IOV, "about to call enable sriov\n");\r\nbnx2x_disable_sriov(bp);\r\nrc = bnx2x_set_pf_tx_switching(bp, true);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_enable_sriov(bp->pdev, req_vfs);\r\nif (rc) {\r\nBNX2X_ERR("pci_enable_sriov failed with %d\n", rc);\r\nreturn rc;\r\n}\r\nDP(BNX2X_MSG_IOV, "sriov enabled (%d vfs)\n", req_vfs);\r\nreturn req_vfs;\r\n}\r\nvoid bnx2x_pf_set_vfs_vlan(struct bnx2x *bp)\r\n{\r\nint vfidx;\r\nstruct pf_vf_bulletin_content *bulletin;\r\nDP(BNX2X_MSG_IOV, "configuring vlan for VFs from sp-task\n");\r\nfor_each_vf(bp, vfidx) {\r\nbulletin = BP_VF_BULLETIN(bp, vfidx);\r\nif (bulletin->valid_bitmap & (1 << VLAN_VALID))\r\nbnx2x_set_vf_vlan(bp->dev, vfidx, bulletin->vlan, 0);\r\n}\r\n}\r\nvoid bnx2x_disable_sriov(struct bnx2x *bp)\r\n{\r\nif (pci_vfs_assigned(bp->pdev)) {\r\nDP(BNX2X_MSG_IOV,\r\n"Unloading driver while VFs are assigned - VFs will not be deallocated\n");\r\nreturn;\r\n}\r\npci_disable_sriov(bp->pdev);\r\n}\r\nstatic int bnx2x_vf_op_prep(struct bnx2x *bp, int vfidx,\r\nstruct bnx2x_virtf **vf,\r\nstruct pf_vf_bulletin_content **bulletin,\r\nbool test_queue)\r\n{\r\nif (bp->state != BNX2X_STATE_OPEN) {\r\nBNX2X_ERR("PF is down - can't utilize iov-related functionality\n");\r\nreturn -EINVAL;\r\n}\r\nif (!IS_SRIOV(bp)) {\r\nBNX2X_ERR("sriov is disabled - can't utilize iov-related functionality\n");\r\nreturn -EINVAL;\r\n}\r\nif (vfidx >= BNX2X_NR_VIRTFN(bp)) {\r\nBNX2X_ERR("VF is uninitialized - can't utilize iov-related functionality. vfidx was %d BNX2X_NR_VIRTFN was %d\n",\r\nvfidx, BNX2X_NR_VIRTFN(bp));\r\nreturn -EINVAL;\r\n}\r\n*vf = BP_VF(bp, vfidx);\r\n*bulletin = BP_VF_BULLETIN(bp, vfidx);\r\nif (!*vf) {\r\nBNX2X_ERR("Unable to get VF structure for vfidx %d\n", vfidx);\r\nreturn -EINVAL;\r\n}\r\nif (test_queue && !(*vf)->vfqs) {\r\nBNX2X_ERR("vfqs struct is null. Was this invoked before dynamically enabling SR-IOV? vfidx was %d\n",\r\nvfidx);\r\nreturn -EINVAL;\r\n}\r\nif (!*bulletin) {\r\nBNX2X_ERR("Bulletin Board struct is null for vfidx %d\n",\r\nvfidx);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint bnx2x_get_vf_config(struct net_device *dev, int vfidx,\r\nstruct ifla_vf_info *ivi)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct bnx2x_virtf *vf = NULL;\r\nstruct pf_vf_bulletin_content *bulletin = NULL;\r\nstruct bnx2x_vlan_mac_obj *mac_obj;\r\nstruct bnx2x_vlan_mac_obj *vlan_obj;\r\nint rc;\r\nrc = bnx2x_vf_op_prep(bp, vfidx, &vf, &bulletin, true);\r\nif (rc)\r\nreturn rc;\r\nmac_obj = &bnx2x_leading_vfq(vf, mac_obj);\r\nvlan_obj = &bnx2x_leading_vfq(vf, vlan_obj);\r\nif (!mac_obj || !vlan_obj) {\r\nBNX2X_ERR("VF partially initialized\n");\r\nreturn -EINVAL;\r\n}\r\nivi->vf = vfidx;\r\nivi->qos = 0;\r\nivi->max_tx_rate = 10000;\r\nivi->min_tx_rate = 0;\r\nivi->spoofchk = 1;\r\nif (vf->state == VF_ENABLED) {\r\nif (bnx2x_validate_vf_sp_objs(bp, vf, false)) {\r\nmac_obj->get_n_elements(bp, mac_obj, 1, (u8 *)&ivi->mac,\r\n0, ETH_ALEN);\r\nvlan_obj->get_n_elements(bp, vlan_obj, 1,\r\n(u8 *)&ivi->vlan, 0,\r\nVLAN_HLEN);\r\n}\r\n} else {\r\nmutex_lock(&bp->vfdb->bulletin_mutex);\r\nif (bulletin->valid_bitmap & (1 << MAC_ADDR_VALID))\r\nmemcpy(&ivi->mac, bulletin->mac, ETH_ALEN);\r\nelse\r\neth_zero_addr(ivi->mac);\r\nif (bulletin->valid_bitmap & (1 << VLAN_VALID))\r\nmemcpy(&ivi->vlan, &bulletin->vlan, VLAN_HLEN);\r\nelse\r\nmemset(&ivi->vlan, 0, VLAN_HLEN);\r\nmutex_unlock(&bp->vfdb->bulletin_mutex);\r\n}\r\nreturn 0;\r\n}\r\nint bnx2x_set_vf_mac(struct net_device *dev, int vfidx, u8 *mac)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint rc, q_logical_state;\r\nstruct bnx2x_virtf *vf = NULL;\r\nstruct pf_vf_bulletin_content *bulletin = NULL;\r\nif (!is_valid_ether_addr(mac)) {\r\nBNX2X_ERR("mac address invalid\n");\r\nreturn -EINVAL;\r\n}\r\nrc = bnx2x_vf_op_prep(bp, vfidx, &vf, &bulletin, true);\r\nif (rc)\r\nreturn rc;\r\nmutex_lock(&bp->vfdb->bulletin_mutex);\r\nbulletin->valid_bitmap |= 1 << MAC_ADDR_VALID;\r\nmemcpy(bulletin->mac, mac, ETH_ALEN);\r\nrc = bnx2x_post_vf_bulletin(bp, vfidx);\r\nmutex_unlock(&bp->vfdb->bulletin_mutex);\r\nif (rc) {\r\nBNX2X_ERR("failed to update VF[%d] bulletin\n", vfidx);\r\nreturn rc;\r\n}\r\nq_logical_state =\r\nbnx2x_get_q_logical_state(bp, &bnx2x_leading_vfq(vf, sp_obj));\r\nif (vf->state == VF_ENABLED &&\r\nq_logical_state == BNX2X_Q_LOGICAL_STATE_ACTIVE) {\r\nunsigned long ramrod_flags = 0;\r\nstruct bnx2x_vlan_mac_obj *mac_obj;\r\nif (!bnx2x_validate_vf_sp_objs(bp, vf, true))\r\nreturn -EINVAL;\r\nbnx2x_lock_vf_pf_channel(bp, vf, CHANNEL_TLV_PF_SET_MAC);\r\nmac_obj = &bnx2x_leading_vfq(vf, mac_obj);\r\nrc = bnx2x_del_all_macs(bp, mac_obj, BNX2X_ETH_MAC, true);\r\nif (rc) {\r\nBNX2X_ERR("failed to delete eth macs\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = bnx2x_del_all_macs(bp, mac_obj, BNX2X_UC_LIST_MAC, true);\r\nif (rc) {\r\nBNX2X_ERR("failed to delete uc_list macs\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\r\nbnx2x_set_mac_one(bp, (u8 *)&bulletin->mac, mac_obj, true,\r\nBNX2X_ETH_MAC, &ramrod_flags);\r\nout:\r\nbnx2x_unlock_vf_pf_channel(bp, vf, CHANNEL_TLV_PF_SET_MAC);\r\n}\r\nreturn rc;\r\n}\r\nstatic void bnx2x_set_vf_vlan_acceptance(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf, bool accept)\r\n{\r\nstruct bnx2x_rx_mode_ramrod_params rx_ramrod;\r\nunsigned long accept_flags;\r\naccept_flags = bnx2x_leading_vfq(vf, accept_flags);\r\nif (accept)\r\nset_bit(BNX2X_ACCEPT_ANY_VLAN, &accept_flags);\r\nelse\r\nclear_bit(BNX2X_ACCEPT_ANY_VLAN, &accept_flags);\r\nbnx2x_vf_prep_rx_mode(bp, LEADING_IDX, &rx_ramrod, vf,\r\naccept_flags);\r\nbnx2x_leading_vfq(vf, accept_flags) = accept_flags;\r\nbnx2x_config_rx_mode(bp, &rx_ramrod);\r\n}\r\nstatic int bnx2x_set_vf_vlan_filter(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nu16 vlan, bool add)\r\n{\r\nstruct bnx2x_vlan_mac_ramrod_params ramrod_param;\r\nunsigned long ramrod_flags = 0;\r\nint rc = 0;\r\nmemset(&ramrod_param, 0, sizeof(ramrod_param));\r\n__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\r\nramrod_param.vlan_mac_obj = &bnx2x_leading_vfq(vf, vlan_obj);\r\nramrod_param.ramrod_flags = ramrod_flags;\r\nramrod_param.user_req.u.vlan.vlan = vlan;\r\nramrod_param.user_req.cmd = add ? BNX2X_VLAN_MAC_ADD\r\n: BNX2X_VLAN_MAC_DEL;\r\nrc = bnx2x_config_vlan_mac(bp, &ramrod_param);\r\nif (rc) {\r\nBNX2X_ERR("failed to configure vlan\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint bnx2x_set_vf_vlan(struct net_device *dev, int vfidx, u16 vlan, u8 qos)\r\n{\r\nstruct pf_vf_bulletin_content *bulletin = NULL;\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct bnx2x_vlan_mac_obj *vlan_obj;\r\nunsigned long vlan_mac_flags = 0;\r\nunsigned long ramrod_flags = 0;\r\nstruct bnx2x_virtf *vf = NULL;\r\nint i, rc;\r\nif (vlan > 4095) {\r\nBNX2X_ERR("illegal vlan value %d\n", vlan);\r\nreturn -EINVAL;\r\n}\r\nDP(BNX2X_MSG_IOV, "configuring VF %d with VLAN %d qos %d\n",\r\nvfidx, vlan, 0);\r\nrc = bnx2x_vf_op_prep(bp, vfidx, &vf, &bulletin, true);\r\nif (rc)\r\nreturn rc;\r\nmutex_lock(&bp->vfdb->bulletin_mutex);\r\nif (vlan > 0)\r\nbulletin->valid_bitmap |= 1 << VLAN_VALID;\r\nelse\r\nbulletin->valid_bitmap &= ~(1 << VLAN_VALID);\r\nbulletin->vlan = vlan;\r\nrc = bnx2x_post_vf_bulletin(bp, vfidx);\r\nif (rc)\r\nBNX2X_ERR("failed to update VF[%d] bulletin\n", vfidx);\r\nmutex_unlock(&bp->vfdb->bulletin_mutex);\r\nif (vf->state != VF_ENABLED ||\r\nbnx2x_get_q_logical_state(bp, &bnx2x_leading_vfq(vf, sp_obj)) !=\r\nBNX2X_Q_LOGICAL_STATE_ACTIVE)\r\nreturn rc;\r\nif (!bnx2x_validate_vf_sp_objs(bp, vf, true))\r\nreturn -EINVAL;\r\nbnx2x_lock_vf_pf_channel(bp, vf, CHANNEL_TLV_PF_SET_VLAN);\r\n__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\r\nvlan_obj = &bnx2x_leading_vfq(vf, vlan_obj);\r\nrc = vlan_obj->delete_all(bp, vlan_obj, &vlan_mac_flags,\r\n&ramrod_flags);\r\nif (rc) {\r\nBNX2X_ERR("failed to delete vlans\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (vlan || !(vf->cfg_flags & VF_CFG_VLAN_FILTER))\r\nbnx2x_set_vf_vlan_acceptance(bp, vf, !vlan);\r\nrc = bnx2x_set_vf_vlan_filter(bp, vf, vlan, true);\r\nif (rc)\r\ngoto out;\r\nfor_each_vfq(vf, i) {\r\nstruct bnx2x_queue_state_params q_params = {NULL};\r\nstruct bnx2x_queue_update_params *update_params;\r\nq_params.q_obj = &bnx2x_vfq(vf, i, sp_obj);\r\nif (bnx2x_get_q_logical_state(bp, q_params.q_obj) !=\r\nBNX2X_Q_LOGICAL_STATE_ACTIVE)\r\ncontinue;\r\n__set_bit(RAMROD_COMP_WAIT, &q_params.ramrod_flags);\r\nq_params.cmd = BNX2X_Q_CMD_UPDATE;\r\nupdate_params = &q_params.params.update;\r\n__set_bit(BNX2X_Q_UPDATE_DEF_VLAN_EN_CHNG,\r\n&update_params->update_flags);\r\n__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM_CHNG,\r\n&update_params->update_flags);\r\nif (vlan == 0) {\r\n__clear_bit(BNX2X_Q_UPDATE_DEF_VLAN_EN,\r\n&update_params->update_flags);\r\n__clear_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM,\r\n&update_params->update_flags);\r\n} else {\r\n__set_bit(BNX2X_Q_UPDATE_DEF_VLAN_EN,\r\n&update_params->update_flags);\r\n__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM,\r\n&update_params->update_flags);\r\nupdate_params->def_vlan = vlan;\r\nupdate_params->silent_removal_value =\r\nvlan & VLAN_VID_MASK;\r\nupdate_params->silent_removal_mask = VLAN_VID_MASK;\r\n}\r\nrc = bnx2x_queue_state_change(bp, &q_params);\r\nif (rc) {\r\nBNX2X_ERR("Failed to configure default VLAN queue %d\n",\r\ni);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nbnx2x_unlock_vf_pf_channel(bp, vf, CHANNEL_TLV_PF_SET_VLAN);\r\nif (rc)\r\nDP(BNX2X_MSG_IOV,\r\n"updated VF[%d] vlan configuration (vlan = %d)\n",\r\nvfidx, vlan);\r\nreturn rc;\r\n}\r\nu32 bnx2x_crc_vf_bulletin(struct pf_vf_bulletin_content *bulletin)\r\n{\r\nreturn crc32(BULLETIN_CRC_SEED,\r\n((u8 *)bulletin) + sizeof(bulletin->crc),\r\nbulletin->length - sizeof(bulletin->crc));\r\n}\r\nenum sample_bulletin_result bnx2x_sample_bulletin(struct bnx2x *bp)\r\n{\r\nstruct pf_vf_bulletin_content *bulletin;\r\nint attempts;\r\nfor (attempts = 0; attempts < BULLETIN_ATTEMPTS; attempts++) {\r\nu32 crc;\r\nmemcpy(&bp->shadow_bulletin, bp->pf2vf_bulletin,\r\nsizeof(union pf_vf_bulletin));\r\ncrc = bnx2x_crc_vf_bulletin(&bp->shadow_bulletin.content);\r\nif (bp->shadow_bulletin.content.crc == crc)\r\nbreak;\r\nBNX2X_ERR("bad crc on bulletin board. Contained %x computed %x\n",\r\nbp->shadow_bulletin.content.crc, crc);\r\n}\r\nif (attempts >= BULLETIN_ATTEMPTS) {\r\nBNX2X_ERR("pf to vf bulletin board crc was wrong %d consecutive times. Aborting\n",\r\nattempts);\r\nreturn PFVF_BULLETIN_CRC_ERR;\r\n}\r\nbulletin = &bp->shadow_bulletin.content;\r\nif (bp->old_bulletin.version == bulletin->version)\r\nreturn PFVF_BULLETIN_UNCHANGED;\r\nif (bulletin->valid_bitmap & 1 << MAC_ADDR_VALID &&\r\n!ether_addr_equal(bulletin->mac, bp->old_bulletin.mac)) {\r\nmemcpy(bp->dev->dev_addr, bulletin->mac, ETH_ALEN);\r\n}\r\nif (bulletin->valid_bitmap & (1 << LINK_VALID)) {\r\nDP(BNX2X_MSG_IOV, "link update speed %d flags %x\n",\r\nbulletin->link_speed, bulletin->link_flags);\r\nbp->vf_link_vars.line_speed = bulletin->link_speed;\r\nbp->vf_link_vars.link_report_flags = 0;\r\nif (bulletin->link_flags & VFPF_LINK_REPORT_LINK_DOWN)\r\n__set_bit(BNX2X_LINK_REPORT_LINK_DOWN,\r\n&bp->vf_link_vars.link_report_flags);\r\nif (bulletin->link_flags & VFPF_LINK_REPORT_FULL_DUPLEX)\r\n__set_bit(BNX2X_LINK_REPORT_FD,\r\n&bp->vf_link_vars.link_report_flags);\r\nif (bulletin->link_flags & VFPF_LINK_REPORT_RX_FC_ON)\r\n__set_bit(BNX2X_LINK_REPORT_RX_FC_ON,\r\n&bp->vf_link_vars.link_report_flags);\r\nif (bulletin->link_flags & VFPF_LINK_REPORT_TX_FC_ON)\r\n__set_bit(BNX2X_LINK_REPORT_TX_FC_ON,\r\n&bp->vf_link_vars.link_report_flags);\r\n__bnx2x_link_report(bp);\r\n}\r\nmemcpy(&bp->old_bulletin, bulletin,\r\nsizeof(struct pf_vf_bulletin_content));\r\nreturn PFVF_BULLETIN_UPDATED;\r\n}\r\nvoid bnx2x_timer_sriov(struct bnx2x *bp)\r\n{\r\nbnx2x_sample_bulletin(bp);\r\nif (bp->old_bulletin.valid_bitmap & 1 << CHANNEL_DOWN)\r\nbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_VFPF_CHANNEL_DOWN,\r\nBNX2X_MSG_IOV);\r\n}\r\nvoid __iomem *bnx2x_vf_doorbells(struct bnx2x *bp)\r\n{\r\nreturn bp->regview + PXP_VF_ADDR_DB_START;\r\n}\r\nvoid bnx2x_vf_pci_dealloc(struct bnx2x *bp)\r\n{\r\nBNX2X_PCI_FREE(bp->vf2pf_mbox, bp->vf2pf_mbox_mapping,\r\nsizeof(struct bnx2x_vf_mbx_msg));\r\nBNX2X_PCI_FREE(bp->vf2pf_mbox, bp->pf2vf_bulletin_mapping,\r\nsizeof(union pf_vf_bulletin));\r\n}\r\nint bnx2x_vf_pci_alloc(struct bnx2x *bp)\r\n{\r\nmutex_init(&bp->vf2pf_mutex);\r\nbp->vf2pf_mbox = BNX2X_PCI_ALLOC(&bp->vf2pf_mbox_mapping,\r\nsizeof(struct bnx2x_vf_mbx_msg));\r\nif (!bp->vf2pf_mbox)\r\ngoto alloc_mem_err;\r\nbp->pf2vf_bulletin = BNX2X_PCI_ALLOC(&bp->pf2vf_bulletin_mapping,\r\nsizeof(union pf_vf_bulletin));\r\nif (!bp->pf2vf_bulletin)\r\ngoto alloc_mem_err;\r\nbnx2x_vf_bulletin_finalize(&bp->pf2vf_bulletin->content, true);\r\nreturn 0;\r\nalloc_mem_err:\r\nbnx2x_vf_pci_dealloc(bp);\r\nreturn -ENOMEM;\r\n}\r\nvoid bnx2x_iov_channel_down(struct bnx2x *bp)\r\n{\r\nint vf_idx;\r\nstruct pf_vf_bulletin_content *bulletin;\r\nif (!IS_SRIOV(bp))\r\nreturn;\r\nfor_each_vf(bp, vf_idx) {\r\nbulletin = BP_VF_BULLETIN(bp, vf_idx);\r\nbulletin->valid_bitmap |= 1 << CHANNEL_DOWN;\r\nbnx2x_post_vf_bulletin(bp, vf_idx);\r\n}\r\n}\r\nvoid bnx2x_iov_task(struct work_struct *work)\r\n{\r\nstruct bnx2x *bp = container_of(work, struct bnx2x, iov_task.work);\r\nif (!netif_running(bp->dev))\r\nreturn;\r\nif (test_and_clear_bit(BNX2X_IOV_HANDLE_FLR,\r\n&bp->iov_task_state))\r\nbnx2x_vf_handle_flr_event(bp);\r\nif (test_and_clear_bit(BNX2X_IOV_HANDLE_VF_MSG,\r\n&bp->iov_task_state))\r\nbnx2x_vf_mbx(bp);\r\n}\r\nvoid bnx2x_schedule_iov_task(struct bnx2x *bp, enum bnx2x_iov_flag flag)\r\n{\r\nsmp_mb__before_atomic();\r\nset_bit(flag, &bp->iov_task_state);\r\nsmp_mb__after_atomic();\r\nDP(BNX2X_MSG_IOV, "Scheduling iov task [Flag: %d]\n", flag);\r\nqueue_delayed_work(bnx2x_iov_wq, &bp->iov_task, 0);\r\n}
