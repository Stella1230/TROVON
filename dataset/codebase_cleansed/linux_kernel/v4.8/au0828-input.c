static int au8522_rc_write(struct au0828_rc *ir, u16 reg, u8 data)\r\n{\r\nint rc;\r\nchar buf[] = { (reg >> 8) | 0x80, reg & 0xff, data };\r\nstruct i2c_msg msg = { .addr = ir->i2c_dev_addr, .flags = 0,\r\n.buf = buf, .len = sizeof(buf) };\r\nrc = i2c_transfer(ir->dev->i2c_client.adapter, &msg, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn (rc == 1) ? 0 : -EIO;\r\n}\r\nstatic int au8522_rc_read(struct au0828_rc *ir, u16 reg, int val,\r\nchar *buf, int size)\r\n{\r\nint rc;\r\nchar obuf[3];\r\nstruct i2c_msg msg[2] = { { .addr = ir->i2c_dev_addr, .flags = 0,\r\n.buf = obuf, .len = 2 },\r\n{ .addr = ir->i2c_dev_addr, .flags = I2C_M_RD,\r\n.buf = buf, .len = size } };\r\nobuf[0] = 0x40 | reg >> 8;\r\nobuf[1] = reg & 0xff;\r\nif (val >= 0) {\r\nobuf[2] = val;\r\nmsg[0].len++;\r\n}\r\nrc = i2c_transfer(ir->dev->i2c_client.adapter, msg, 2);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn (rc == 2) ? 0 : -EIO;\r\n}\r\nstatic int au8522_rc_andor(struct au0828_rc *ir, u16 reg, u8 mask, u8 value)\r\n{\r\nint rc;\r\nchar buf, oldbuf;\r\nrc = au8522_rc_read(ir, reg, -1, &buf, 1);\r\nif (rc < 0)\r\nreturn rc;\r\noldbuf = buf;\r\nbuf = (buf & ~mask) | (value & mask);\r\nif (buf == oldbuf)\r\nreturn 0;\r\nreturn au8522_rc_write(ir, reg, buf);\r\n}\r\nstatic int au0828_get_key_au8522(struct au0828_rc *ir)\r\n{\r\nunsigned char buf[40];\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nint i, j, rc;\r\nint prv_bit, bit, width;\r\nbool first = true;\r\nif (test_bit(DEV_DISCONNECTED, &ir->dev->dev_state))\r\nreturn 0;\r\nrc = au8522_rc_read(ir, 0xe1, -1, buf, 1);\r\nif (rc < 0 || !(buf[0] & (1 << 4))) {\r\nau8522_rc_set(ir, 0xe0, 1 << 4);\r\nreturn 0;\r\n}\r\nrc = au8522_rc_read(ir, 0xe3, 0x11, buf, sizeof(buf));\r\nif (rc < 0)\r\nreturn rc;\r\nau8522_rc_clear(ir, 0xe0, 1 << 4);\r\nau8522_rc_set(ir, 0xe0, 1 << 4);\r\ndprintk(16, "RC data received: %*ph\n", 40, buf);\r\nprv_bit = (buf[0] >> 7) & 0x01;\r\nwidth = 0;\r\nfor (i = 0; i < sizeof(buf); i++) {\r\nfor (j = 7; j >= 0; j--) {\r\nbit = (buf[i] >> j) & 0x01;\r\nif (bit == prv_bit) {\r\nwidth++;\r\ncontinue;\r\n}\r\nif (first) {\r\nfirst = false;\r\ninit_ir_raw_event(&rawir);\r\nrawir.pulse = true;\r\nif (width > NEC_START_SPACE - 2 &&\r\nwidth < NEC_START_SPACE + 2) {\r\nrawir.duration = NEC_START_PULSE;\r\ndprintk(16, "Storing NEC start %s with duration %d",\r\nrawir.pulse ? "pulse" : "space",\r\nrawir.duration);\r\n} else {\r\nrawir.duration = RC5_START_PULSE;\r\ndprintk(16, "Storing RC5 start %s with duration %d",\r\nrawir.pulse ? "pulse" : "space",\r\nrawir.duration);\r\n}\r\nir_raw_event_store(ir->rc, &rawir);\r\n}\r\ninit_ir_raw_event(&rawir);\r\nrawir.pulse = prv_bit ? false : true;\r\nrawir.duration = AU8522_UNIT * width;\r\ndprintk(16, "Storing %s with duration %d",\r\nrawir.pulse ? "pulse" : "space",\r\nrawir.duration);\r\nir_raw_event_store(ir->rc, &rawir);\r\nwidth = 1;\r\nprv_bit = bit;\r\n}\r\n}\r\ninit_ir_raw_event(&rawir);\r\nrawir.pulse = prv_bit ? false : true;\r\nrawir.duration = AU8522_UNIT * width;\r\ndprintk(16, "Storing end %s with duration %d",\r\nrawir.pulse ? "pulse" : "space",\r\nrawir.duration);\r\nir_raw_event_store(ir->rc, &rawir);\r\nir_raw_event_handle(ir->rc);\r\nreturn 1;\r\n}\r\nstatic void au0828_rc_work(struct work_struct *work)\r\n{\r\nstruct au0828_rc *ir = container_of(work, struct au0828_rc, work.work);\r\nint rc;\r\nrc = ir->get_key_i2c(ir);\r\nif (rc < 0)\r\npr_info("Error while getting RC scancode\n");\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\r\n}\r\nstatic int au0828_rc_start(struct rc_dev *rc)\r\n{\r\nstruct au0828_rc *ir = rc->priv;\r\nINIT_DELAYED_WORK(&ir->work, au0828_rc_work);\r\nau8522_rc_set(ir, 0xe0, 1 << 4);\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\r\nreturn 0;\r\n}\r\nstatic void au0828_rc_stop(struct rc_dev *rc)\r\n{\r\nstruct au0828_rc *ir = rc->priv;\r\ncancel_delayed_work_sync(&ir->work);\r\nif (!test_bit(DEV_DISCONNECTED, &ir->dev->dev_state)) {\r\nau8522_rc_clear(ir, 0xe0, 1 << 4);\r\n}\r\n}\r\nstatic int au0828_probe_i2c_ir(struct au0828_dev *dev)\r\n{\r\nint i = 0;\r\nconst unsigned short addr_list[] = {\r\n0x47, I2C_CLIENT_END\r\n};\r\nwhile (addr_list[i] != I2C_CLIENT_END) {\r\nif (i2c_probe_func_quick_read(dev->i2c_client.adapter,\r\naddr_list[i]) == 1)\r\nreturn addr_list[i];\r\ni++;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint au0828_rc_register(struct au0828_dev *dev)\r\n{\r\nstruct au0828_rc *ir;\r\nstruct rc_dev *rc;\r\nint err = -ENOMEM;\r\nu16 i2c_rc_dev_addr = 0;\r\nif (!dev->board.has_ir_i2c || disable_ir)\r\nreturn 0;\r\ni2c_rc_dev_addr = au0828_probe_i2c_ir(dev);\r\nif (!i2c_rc_dev_addr)\r\nreturn -ENODEV;\r\nir = kzalloc(sizeof(*ir), GFP_KERNEL);\r\nrc = rc_allocate_device();\r\nif (!ir || !rc)\r\ngoto error;\r\nir->dev = dev;\r\ndev->ir = ir;\r\nir->rc = rc;\r\nrc->priv = ir;\r\nrc->open = au0828_rc_start;\r\nrc->close = au0828_rc_stop;\r\nif (dev->board.has_ir_i2c) {\r\nswitch (dev->boardnr) {\r\ncase AU0828_BOARD_HAUPPAUGE_HVR950Q:\r\nrc->map_name = RC_MAP_HAUPPAUGE;\r\nir->get_key_i2c = au0828_get_key_au8522;\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nir->i2c_dev_addr = i2c_rc_dev_addr;\r\n}\r\nir->polling = 100;\r\nsnprintf(ir->name, sizeof(ir->name), "au0828 IR (%s)",\r\ndev->board.name);\r\nusb_make_path(dev->usbdev, ir->phys, sizeof(ir->phys));\r\nstrlcat(ir->phys, "/input0", sizeof(ir->phys));\r\nrc->input_name = ir->name;\r\nrc->input_phys = ir->phys;\r\nrc->input_id.bustype = BUS_USB;\r\nrc->input_id.version = 1;\r\nrc->input_id.vendor = le16_to_cpu(dev->usbdev->descriptor.idVendor);\r\nrc->input_id.product = le16_to_cpu(dev->usbdev->descriptor.idProduct);\r\nrc->dev.parent = &dev->usbdev->dev;\r\nrc->driver_name = "au0828-input";\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc->allowed_protocols = RC_BIT_NEC | RC_BIT_RC5;\r\nerr = rc_register_device(rc);\r\nif (err)\r\ngoto error;\r\npr_info("Remote controller %s initalized\n", ir->name);\r\nreturn 0;\r\nerror:\r\ndev->ir = NULL;\r\nrc_free_device(rc);\r\nkfree(ir);\r\nreturn err;\r\n}\r\nvoid au0828_rc_unregister(struct au0828_dev *dev)\r\n{\r\nstruct au0828_rc *ir = dev->ir;\r\nif (!ir)\r\nreturn;\r\nrc_unregister_device(ir->rc);\r\nkfree(ir);\r\ndev->ir = NULL;\r\n}\r\nint au0828_rc_suspend(struct au0828_dev *dev)\r\n{\r\nstruct au0828_rc *ir = dev->ir;\r\nif (!ir)\r\nreturn 0;\r\npr_info("Stopping RC\n");\r\ncancel_delayed_work_sync(&ir->work);\r\nau8522_rc_clear(ir, 0xe0, 1 << 4);\r\nreturn 0;\r\n}\r\nint au0828_rc_resume(struct au0828_dev *dev)\r\n{\r\nstruct au0828_rc *ir = dev->ir;\r\nif (!ir)\r\nreturn 0;\r\npr_info("Restarting RC\n");\r\nau8522_rc_set(ir, 0xe0, 1 << 4);\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\r\nreturn 0;\r\n}
