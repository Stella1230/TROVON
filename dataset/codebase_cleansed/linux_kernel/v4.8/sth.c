static struct intel_th_channel __iomem *\r\nsth_channel(struct sth_device *sth, unsigned int master, unsigned int channel)\r\n{\r\nstruct intel_th_channel __iomem *sw_map = sth->channels;\r\nreturn &sw_map[(master - sth->stm.sw_start) * sth->stm.sw_nchannels +\r\nchannel];\r\n}\r\nstatic void sth_iowrite(void __iomem *dest, const unsigned char *payload,\r\nunsigned int size)\r\n{\r\nswitch (size) {\r\n#ifdef CONFIG_64BIT\r\ncase 8:\r\nwriteq_relaxed(*(u64 *)payload, dest);\r\nbreak;\r\n#endif\r\ncase 4:\r\nwritel_relaxed(*(u32 *)payload, dest);\r\nbreak;\r\ncase 2:\r\nwritew_relaxed(*(u16 *)payload, dest);\r\nbreak;\r\ncase 1:\r\nwriteb_relaxed(*(u8 *)payload, dest);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t sth_stm_packet(struct stm_data *stm_data, unsigned int master,\r\nunsigned int channel, unsigned int packet,\r\nunsigned int flags, unsigned int size,\r\nconst unsigned char *payload)\r\n{\r\nstruct sth_device *sth = container_of(stm_data, struct sth_device, stm);\r\nstruct intel_th_channel __iomem *out =\r\nsth_channel(sth, master, channel);\r\nu64 __iomem *outp = &out->Dn;\r\nunsigned long reg = REG_STH_TRIG;\r\n#ifndef CONFIG_64BIT\r\nif (size > 4)\r\nsize = 4;\r\n#endif\r\nsize = rounddown_pow_of_two(size);\r\nswitch (packet) {\r\ncase STP_PACKET_GERR:\r\nreg += 4;\r\ncase STP_PACKET_XSYNC:\r\nreg += 8;\r\ncase STP_PACKET_TRIG:\r\nif (flags & STP_PACKET_TIMESTAMPED)\r\nreg += 4;\r\nwriteb_relaxed(*payload, sth->base + reg);\r\nbreak;\r\ncase STP_PACKET_MERR:\r\nif (size > 4)\r\nsize = 4;\r\nsth_iowrite(&out->MERR, payload, size);\r\nbreak;\r\ncase STP_PACKET_FLAG:\r\nif (flags & STP_PACKET_TIMESTAMPED)\r\noutp = (u64 __iomem *)&out->FLAG_TS;\r\nelse\r\noutp = (u64 __iomem *)&out->FLAG;\r\nsize = 0;\r\nwriteb_relaxed(0, outp);\r\nbreak;\r\ncase STP_PACKET_USER:\r\nif (flags & STP_PACKET_TIMESTAMPED)\r\noutp = &out->USER_TS;\r\nelse\r\noutp = &out->USER;\r\nsth_iowrite(outp, payload, size);\r\nbreak;\r\ncase STP_PACKET_DATA:\r\noutp = &out->Dn;\r\nif (flags & STP_PACKET_TIMESTAMPED)\r\noutp += 2;\r\nif (flags & STP_PACKET_MARKED)\r\noutp++;\r\nsth_iowrite(outp, payload, size);\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn size;\r\n}\r\nstatic phys_addr_t\r\nsth_stm_mmio_addr(struct stm_data *stm_data, unsigned int master,\r\nunsigned int channel, unsigned int nr_chans)\r\n{\r\nstruct sth_device *sth = container_of(stm_data, struct sth_device, stm);\r\nphys_addr_t addr;\r\nmaster -= sth->stm.sw_start;\r\naddr = sth->channels_phys + (master * sth->stm.sw_nchannels + channel) *\r\nsizeof(struct intel_th_channel);\r\nif (offset_in_page(addr) ||\r\noffset_in_page(nr_chans * sizeof(struct intel_th_channel)))\r\nreturn 0;\r\nreturn addr;\r\n}\r\nstatic int sth_stm_link(struct stm_data *stm_data, unsigned int master,\r\nunsigned int channel)\r\n{\r\nstruct sth_device *sth = container_of(stm_data, struct sth_device, stm);\r\nintel_th_set_output(to_intel_th_device(sth->dev), master);\r\nreturn 0;\r\n}\r\nstatic int intel_th_sw_init(struct sth_device *sth)\r\n{\r\nu32 reg;\r\nreg = ioread32(sth->base + REG_STH_STHCAP1);\r\nsth->stm.sw_nchannels = reg & 0xff;\r\nreg = ioread32(sth->base + REG_STH_STHCAP0);\r\nsth->stm.sw_start = reg & 0xffff;\r\nsth->stm.sw_end = reg >> 16;\r\nsth->sw_nmasters = sth->stm.sw_end - sth->stm.sw_start;\r\ndev_dbg(sth->dev, "sw_start: %x sw_end: %x masters: %x nchannels: %x\n",\r\nsth->stm.sw_start, sth->stm.sw_end, sth->sw_nmasters,\r\nsth->stm.sw_nchannels);\r\nreturn 0;\r\n}\r\nstatic int intel_th_sth_probe(struct intel_th_device *thdev)\r\n{\r\nstruct device *dev = &thdev->dev;\r\nstruct sth_device *sth;\r\nstruct resource *res;\r\nvoid __iomem *base, *channels;\r\nint err;\r\nres = intel_th_device_get_resource(thdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nbase = devm_ioremap(dev, res->start, resource_size(res));\r\nif (!base)\r\nreturn -ENOMEM;\r\nres = intel_th_device_get_resource(thdev, IORESOURCE_MEM, 1);\r\nif (!res)\r\nreturn -ENODEV;\r\nchannels = devm_ioremap(dev, res->start, resource_size(res));\r\nif (!channels)\r\nreturn -ENOMEM;\r\nsth = devm_kzalloc(dev, sizeof(*sth), GFP_KERNEL);\r\nif (!sth)\r\nreturn -ENOMEM;\r\nsth->dev = dev;\r\nsth->base = base;\r\nsth->channels = channels;\r\nsth->channels_phys = res->start;\r\nsth->stm.name = dev_name(dev);\r\nsth->stm.packet = sth_stm_packet;\r\nsth->stm.mmio_addr = sth_stm_mmio_addr;\r\nsth->stm.sw_mmiosz = sizeof(struct intel_th_channel);\r\nsth->stm.link = sth_stm_link;\r\nerr = intel_th_sw_init(sth);\r\nif (err)\r\nreturn err;\r\nerr = stm_register_device(dev, &sth->stm, THIS_MODULE);\r\nif (err) {\r\ndev_err(dev, "stm_register_device failed\n");\r\nreturn err;\r\n}\r\ndev_set_drvdata(dev, sth);\r\nreturn 0;\r\n}\r\nstatic void intel_th_sth_remove(struct intel_th_device *thdev)\r\n{\r\nstruct sth_device *sth = dev_get_drvdata(&thdev->dev);\r\nstm_unregister_device(&sth->stm);\r\n}
