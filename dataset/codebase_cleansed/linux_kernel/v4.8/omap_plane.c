static inline struct omap_plane_state *\r\nto_omap_plane_state(struct drm_plane_state *state)\r\n{\r\nreturn container_of(state, struct omap_plane_state, base);\r\n}\r\nstatic int omap_plane_prepare_fb(struct drm_plane *plane,\r\nconst struct drm_plane_state *new_state)\r\n{\r\nif (!new_state->fb)\r\nreturn 0;\r\nreturn omap_framebuffer_pin(new_state->fb);\r\n}\r\nstatic void omap_plane_cleanup_fb(struct drm_plane *plane,\r\nconst struct drm_plane_state *old_state)\r\n{\r\nif (old_state->fb)\r\nomap_framebuffer_unpin(old_state->fb);\r\n}\r\nstatic void omap_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct drm_plane_state *state = plane->state;\r\nstruct omap_plane_state *omap_state = to_omap_plane_state(state);\r\nstruct omap_overlay_info info;\r\nstruct omap_drm_window win;\r\nint ret;\r\nDBG("%s, crtc=%p fb=%p", omap_plane->name, state->crtc, state->fb);\r\nmemset(&info, 0, sizeof(info));\r\ninfo.rotation_type = OMAP_DSS_ROT_DMA;\r\ninfo.rotation = OMAP_DSS_ROT_0;\r\ninfo.global_alpha = 0xff;\r\ninfo.mirror = 0;\r\ninfo.zorder = omap_state->zorder;\r\nmemset(&win, 0, sizeof(win));\r\nwin.rotation = state->rotation;\r\nwin.crtc_x = state->crtc_x;\r\nwin.crtc_y = state->crtc_y;\r\nwin.crtc_w = state->crtc_w;\r\nwin.crtc_h = state->crtc_h;\r\nwin.src_x = state->src_x >> 16;\r\nwin.src_y = state->src_y >> 16;\r\nswitch (state->rotation & DRM_ROTATE_MASK) {\r\ncase BIT(DRM_ROTATE_90):\r\ncase BIT(DRM_ROTATE_270):\r\nwin.src_w = state->src_h >> 16;\r\nwin.src_h = state->src_w >> 16;\r\nbreak;\r\ndefault:\r\nwin.src_w = state->src_w >> 16;\r\nwin.src_h = state->src_h >> 16;\r\nbreak;\r\n}\r\nomap_framebuffer_update_scanout(state->fb, &win, &info);\r\nDBG("%dx%d -> %dx%d (%d)", info.width, info.height,\r\ninfo.out_width, info.out_height,\r\ninfo.screen_width);\r\nDBG("%d,%d %pad %pad", info.pos_x, info.pos_y,\r\n&info.paddr, &info.p_uv_addr);\r\ndispc_ovl_set_channel_out(omap_plane->id,\r\nomap_crtc_channel(state->crtc));\r\nret = dispc_ovl_setup(omap_plane->id, &info, false,\r\nomap_crtc_timings(state->crtc), false);\r\nif (WARN_ON(ret)) {\r\ndispc_ovl_enable(omap_plane->id, false);\r\nreturn;\r\n}\r\ndispc_ovl_enable(omap_plane->id, true);\r\n}\r\nstatic void omap_plane_atomic_disable(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct omap_plane_state *omap_state = to_omap_plane_state(plane->state);\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nplane->state->rotation = BIT(DRM_ROTATE_0);\r\nomap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY\r\n? 0 : omap_plane->id;\r\ndispc_ovl_enable(omap_plane->id, false);\r\n}\r\nstatic int omap_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct drm_crtc_state *crtc_state;\r\nif (!state->crtc)\r\nreturn 0;\r\ncrtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);\r\nif (IS_ERR(crtc_state))\r\nreturn PTR_ERR(crtc_state);\r\nif (state->crtc_x < 0 || state->crtc_y < 0)\r\nreturn -EINVAL;\r\nif (state->crtc_x + state->crtc_w > crtc_state->adjusted_mode.hdisplay)\r\nreturn -EINVAL;\r\nif (state->crtc_y + state->crtc_h > crtc_state->adjusted_mode.vdisplay)\r\nreturn -EINVAL;\r\nif (state->fb) {\r\nif (state->rotation != BIT(DRM_ROTATE_0) &&\r\n!omap_framebuffer_supports_rotation(state->fb))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_plane_destroy(struct drm_plane *plane)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nDBG("%s", omap_plane->name);\r\nomap_irq_unregister(plane->dev, &omap_plane->error_irq);\r\ndrm_plane_cleanup(plane);\r\nkfree(omap_plane);\r\n}\r\nvoid omap_plane_install_properties(struct drm_plane *plane,\r\nstruct drm_mode_object *obj)\r\n{\r\nstruct drm_device *dev = plane->dev;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nif (priv->has_dmm) {\r\nstruct drm_property *prop = dev->mode_config.rotation_property;\r\ndrm_object_attach_property(obj, prop, 0);\r\n}\r\ndrm_object_attach_property(obj, priv->zorder_prop, 0);\r\n}\r\nstatic struct drm_plane_state *\r\nomap_plane_atomic_duplicate_state(struct drm_plane *plane)\r\n{\r\nstruct omap_plane_state *state;\r\nstruct omap_plane_state *copy;\r\nif (WARN_ON(!plane->state))\r\nreturn NULL;\r\nstate = to_omap_plane_state(plane->state);\r\ncopy = kmemdup(state, sizeof(*state), GFP_KERNEL);\r\nif (copy == NULL)\r\nreturn NULL;\r\n__drm_atomic_helper_plane_duplicate_state(plane, &copy->base);\r\nreturn &copy->base;\r\n}\r\nstatic void omap_plane_atomic_destroy_state(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\n__drm_atomic_helper_plane_destroy_state(state);\r\nkfree(to_omap_plane_state(state));\r\n}\r\nstatic void omap_plane_reset(struct drm_plane *plane)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct omap_plane_state *omap_state;\r\nif (plane->state) {\r\nomap_plane_atomic_destroy_state(plane, plane->state);\r\nplane->state = NULL;\r\n}\r\nomap_state = kzalloc(sizeof(*omap_state), GFP_KERNEL);\r\nif (omap_state == NULL)\r\nreturn;\r\nomap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY\r\n? 0 : omap_plane->id;\r\nomap_state->base.rotation = BIT(DRM_ROTATE_0);\r\nplane->state = &omap_state->base;\r\nplane->state->plane = plane;\r\n}\r\nstatic int omap_plane_atomic_set_property(struct drm_plane *plane,\r\nstruct drm_plane_state *state,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct omap_drm_private *priv = plane->dev->dev_private;\r\nstruct omap_plane_state *omap_state = to_omap_plane_state(state);\r\nif (property == priv->zorder_prop)\r\nomap_state->zorder = val;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int omap_plane_atomic_get_property(struct drm_plane *plane,\r\nconst struct drm_plane_state *state,\r\nstruct drm_property *property,\r\nuint64_t *val)\r\n{\r\nstruct omap_drm_private *priv = plane->dev->dev_private;\r\nconst struct omap_plane_state *omap_state =\r\ncontainer_of(state, const struct omap_plane_state, base);\r\nif (property == priv->zorder_prop)\r\n*val = omap_state->zorder;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void omap_plane_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct omap_plane *omap_plane =\r\ncontainer_of(irq, struct omap_plane, error_irq);\r\nDRM_ERROR_RATELIMITED("%s: errors: %08x\n", omap_plane->name,\r\nirqstatus);\r\n}\r\nstruct drm_plane *omap_plane_init(struct drm_device *dev,\r\nint id, enum drm_plane_type type)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_plane *plane;\r\nstruct omap_plane *omap_plane;\r\nint ret;\r\nDBG("%s: type=%d", plane_names[id], type);\r\nomap_plane = kzalloc(sizeof(*omap_plane), GFP_KERNEL);\r\nif (!omap_plane)\r\nreturn ERR_PTR(-ENOMEM);\r\nomap_plane->nformats = omap_framebuffer_get_formats(\r\nomap_plane->formats, ARRAY_SIZE(omap_plane->formats),\r\ndss_feat_get_supported_color_modes(id));\r\nomap_plane->id = id;\r\nomap_plane->name = plane_names[id];\r\nplane = &omap_plane->base;\r\nomap_plane->error_irq.irqmask = error_irqs[id];\r\nomap_plane->error_irq.irq = omap_plane_error_irq;\r\nomap_irq_register(dev, &omap_plane->error_irq);\r\nret = drm_universal_plane_init(dev, plane, (1 << priv->num_crtcs) - 1,\r\n&omap_plane_funcs, omap_plane->formats,\r\nomap_plane->nformats, type, NULL);\r\nif (ret < 0)\r\ngoto error;\r\ndrm_plane_helper_add(plane, &omap_plane_helper_funcs);\r\nomap_plane_install_properties(plane, &plane->base);\r\nreturn plane;\r\nerror:\r\nomap_irq_unregister(plane->dev, &omap_plane->error_irq);\r\nkfree(omap_plane);\r\nreturn NULL;\r\n}
