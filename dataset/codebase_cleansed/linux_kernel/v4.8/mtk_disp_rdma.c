static irqreturn_t mtk_disp_rdma_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct mtk_disp_rdma *priv = dev_id;\r\nstruct mtk_ddp_comp *rdma = &priv->ddp_comp;\r\nwritel(0x0, rdma->regs + DISP_REG_RDMA_INT_STATUS);\r\nif (!priv->crtc)\r\nreturn IRQ_NONE;\r\nmtk_crtc_ddp_irq(priv->crtc, rdma);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rdma_update_bits(struct mtk_ddp_comp *comp, unsigned int reg,\r\nunsigned int mask, unsigned int val)\r\n{\r\nunsigned int tmp = readl(comp->regs + reg);\r\ntmp = (tmp & ~mask) | (val & mask);\r\nwritel(tmp, comp->regs + reg);\r\n}\r\nstatic void mtk_rdma_enable_vblank(struct mtk_ddp_comp *comp,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct mtk_disp_rdma *priv = container_of(comp, struct mtk_disp_rdma,\r\nddp_comp);\r\npriv->crtc = crtc;\r\nrdma_update_bits(comp, DISP_REG_RDMA_INT_ENABLE, RDMA_FRAME_END_INT,\r\nRDMA_FRAME_END_INT);\r\n}\r\nstatic void mtk_rdma_disable_vblank(struct mtk_ddp_comp *comp)\r\n{\r\nstruct mtk_disp_rdma *priv = container_of(comp, struct mtk_disp_rdma,\r\nddp_comp);\r\npriv->crtc = NULL;\r\nrdma_update_bits(comp, DISP_REG_RDMA_INT_ENABLE, RDMA_FRAME_END_INT, 0);\r\n}\r\nstatic void mtk_rdma_start(struct mtk_ddp_comp *comp)\r\n{\r\nrdma_update_bits(comp, DISP_REG_RDMA_GLOBAL_CON, RDMA_ENGINE_EN,\r\nRDMA_ENGINE_EN);\r\n}\r\nstatic void mtk_rdma_stop(struct mtk_ddp_comp *comp)\r\n{\r\nrdma_update_bits(comp, DISP_REG_RDMA_GLOBAL_CON, RDMA_ENGINE_EN, 0);\r\n}\r\nstatic void mtk_rdma_config(struct mtk_ddp_comp *comp, unsigned int width,\r\nunsigned int height, unsigned int vrefresh)\r\n{\r\nunsigned int threshold;\r\nunsigned int reg;\r\nrdma_update_bits(comp, DISP_REG_RDMA_SIZE_CON_0, 0xfff, width);\r\nrdma_update_bits(comp, DISP_REG_RDMA_SIZE_CON_1, 0xfffff, height);\r\nthreshold = width * height * vrefresh * 4 * 7 / 1000000;\r\nreg = RDMA_FIFO_UNDERFLOW_EN |\r\nRDMA_FIFO_PSEUDO_SIZE(SZ_8K) |\r\nRDMA_OUTPUT_VALID_FIFO_THRESHOLD(threshold);\r\nwritel(reg, comp->regs + DISP_REG_RDMA_FIFO_CON);\r\n}\r\nstatic int mtk_disp_rdma_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct mtk_disp_rdma *priv = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nint ret;\r\nret = mtk_ddp_comp_register(drm_dev, &priv->ddp_comp);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to register component %s: %d\n",\r\ndev->of_node->full_name, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mtk_disp_rdma_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct mtk_disp_rdma *priv = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nmtk_ddp_comp_unregister(drm_dev, &priv->ddp_comp);\r\n}\r\nstatic int mtk_disp_rdma_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mtk_disp_rdma *priv;\r\nint comp_id;\r\nint irq;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ncomp_id = mtk_ddp_comp_get_id(dev->of_node, MTK_DISP_RDMA);\r\nif (comp_id < 0) {\r\ndev_err(dev, "Failed to identify by alias: %d\n", comp_id);\r\nreturn comp_id;\r\n}\r\nret = mtk_ddp_comp_init(dev, dev->of_node, &priv->ddp_comp, comp_id,\r\n&mtk_disp_rdma_funcs);\r\nif (ret) {\r\ndev_err(dev, "Failed to initialize component: %d\n", ret);\r\nreturn ret;\r\n}\r\nwritel(0x0, priv->ddp_comp.regs + DISP_REG_RDMA_INT_ENABLE);\r\nwritel(0x0, priv->ddp_comp.regs + DISP_REG_RDMA_INT_STATUS);\r\nret = devm_request_irq(dev, irq, mtk_disp_rdma_irq_handler,\r\nIRQF_TRIGGER_NONE, dev_name(dev), priv);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to request irq %d: %d\n", irq, ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nret = component_add(dev, &mtk_disp_rdma_component_ops);\r\nif (ret)\r\ndev_err(dev, "Failed to add component: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mtk_disp_rdma_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &mtk_disp_rdma_component_ops);\r\nreturn 0;\r\n}
