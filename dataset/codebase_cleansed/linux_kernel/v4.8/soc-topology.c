static int soc_tplg_check_elem_count(struct soc_tplg *tplg, size_t elem_size,\r\nunsigned int count, size_t bytes, const char *elem_type)\r\n{\r\nconst u8 *end = tplg->pos + elem_size * count;\r\nif (end > tplg->fw->data + tplg->fw->size) {\r\ndev_err(tplg->dev, "ASoC: %s overflow end of data\n",\r\nelem_type);\r\nreturn -EINVAL;\r\n}\r\nif (elem_size * count > bytes) {\r\ndev_err(tplg->dev,\r\n"ASoC: %s count %d of size %zu is bigger than chunk %zu\n",\r\nelem_type, count, elem_size, bytes);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int soc_tplg_is_eof(struct soc_tplg *tplg)\r\n{\r\nconst u8 *end = tplg->hdr_pos;\r\nif (end >= tplg->fw->data + tplg->fw->size)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline unsigned long soc_tplg_get_hdr_offset(struct soc_tplg *tplg)\r\n{\r\nreturn (unsigned long)(tplg->hdr_pos - tplg->fw->data);\r\n}\r\nstatic inline unsigned long soc_tplg_get_offset(struct soc_tplg *tplg)\r\n{\r\nreturn (unsigned long)(tplg->pos - tplg->fw->data);\r\n}\r\nstatic int tplc_chan_get_reg(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_channel *chan, int map)\r\n{\r\nint i;\r\nfor (i = 0; i < SND_SOC_TPLG_MAX_CHAN; i++) {\r\nif (chan[i].id == map)\r\nreturn chan[i].reg;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tplc_chan_get_shift(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_channel *chan, int map)\r\n{\r\nint i;\r\nfor (i = 0; i < SND_SOC_TPLG_MAX_CHAN; i++) {\r\nif (chan[i].id == map)\r\nreturn chan[i].shift;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int get_widget_id(int tplg_type)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dapm_map); i++) {\r\nif (tplg_type == dapm_map[i].uid)\r\nreturn dapm_map[i].kid;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline void soc_bind_err(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_ctl_hdr *hdr, int index)\r\n{\r\ndev_err(tplg->dev,\r\n"ASoC: invalid control type (g,p,i) %d:%d:%d index %d at 0x%lx\n",\r\nhdr->ops.get, hdr->ops.put, hdr->ops.info, index,\r\nsoc_tplg_get_offset(tplg));\r\n}\r\nstatic inline void soc_control_err(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_ctl_hdr *hdr, const char *name)\r\n{\r\ndev_err(tplg->dev,\r\n"ASoC: no complete mixer IO handler for %s type (g,p,i) %d:%d:%d at 0x%lx\n",\r\nname, hdr->ops.get, hdr->ops.put, hdr->ops.info,\r\nsoc_tplg_get_offset(tplg));\r\n}\r\nstatic int soc_tplg_vendor_load_(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_hdr *hdr)\r\n{\r\nint ret = 0;\r\nif (tplg->comp && tplg->ops && tplg->ops->vendor_load)\r\nret = tplg->ops->vendor_load(tplg->comp, hdr);\r\nelse {\r\ndev_err(tplg->dev, "ASoC: no vendor load callback for ID %d\n",\r\nhdr->vendor_type);\r\nreturn -EINVAL;\r\n}\r\nif (ret < 0)\r\ndev_err(tplg->dev,\r\n"ASoC: vendor load failed at hdr offset %ld/0x%lx for type %d:%d\n",\r\nsoc_tplg_get_hdr_offset(tplg),\r\nsoc_tplg_get_hdr_offset(tplg),\r\nhdr->type, hdr->vendor_type);\r\nreturn ret;\r\n}\r\nstatic int soc_tplg_vendor_load(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_hdr *hdr)\r\n{\r\nif (tplg->pass != SOC_TPLG_PASS_VENDOR)\r\nreturn 0;\r\nreturn soc_tplg_vendor_load_(tplg, hdr);\r\n}\r\nstatic int soc_tplg_widget_load(struct soc_tplg *tplg,\r\nstruct snd_soc_dapm_widget *w, struct snd_soc_tplg_dapm_widget *tplg_w)\r\n{\r\nif (tplg->comp && tplg->ops && tplg->ops->widget_load)\r\nreturn tplg->ops->widget_load(tplg->comp, w, tplg_w);\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_dai_load(struct soc_tplg *tplg,\r\nstruct snd_soc_dai_driver *dai_drv)\r\n{\r\nif (tplg->comp && tplg->ops && tplg->ops->dai_load)\r\nreturn tplg->ops->dai_load(tplg->comp, dai_drv);\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_dai_link_load(struct soc_tplg *tplg,\r\nstruct snd_soc_dai_link *link)\r\n{\r\nif (tplg->comp && tplg->ops && tplg->ops->link_load)\r\nreturn tplg->ops->link_load(tplg->comp, link);\r\nreturn 0;\r\n}\r\nstatic void soc_tplg_complete(struct soc_tplg *tplg)\r\n{\r\nif (tplg->comp && tplg->ops && tplg->ops->complete)\r\ntplg->ops->complete(tplg->comp);\r\n}\r\nstatic int soc_tplg_add_dcontrol(struct snd_card *card, struct device *dev,\r\nconst struct snd_kcontrol_new *control_new, const char *prefix,\r\nvoid *data, struct snd_kcontrol **kcontrol)\r\n{\r\nint err;\r\n*kcontrol = snd_soc_cnew(control_new, data, control_new->name, prefix);\r\nif (*kcontrol == NULL) {\r\ndev_err(dev, "ASoC: Failed to create new kcontrol %s\n",\r\ncontrol_new->name);\r\nreturn -ENOMEM;\r\n}\r\nerr = snd_ctl_add(card, *kcontrol);\r\nif (err < 0) {\r\ndev_err(dev, "ASoC: Failed to add %s: %d\n",\r\ncontrol_new->name, err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_add_kcontrol(struct soc_tplg *tplg,\r\nstruct snd_kcontrol_new *k, struct snd_kcontrol **kcontrol)\r\n{\r\nstruct snd_soc_component *comp = tplg->comp;\r\nreturn soc_tplg_add_dcontrol(comp->card->snd_card,\r\ncomp->dev, k, NULL, comp, kcontrol);\r\n}\r\nstatic void remove_mixer(struct snd_soc_component *comp,\r\nstruct snd_soc_dobj *dobj, int pass)\r\n{\r\nstruct snd_card *card = comp->card->snd_card;\r\nstruct soc_mixer_control *sm =\r\ncontainer_of(dobj, struct soc_mixer_control, dobj);\r\nconst unsigned int *p = NULL;\r\nif (pass != SOC_TPLG_PASS_MIXER)\r\nreturn;\r\nif (dobj->ops && dobj->ops->control_unload)\r\ndobj->ops->control_unload(comp, dobj);\r\nif (sm->dobj.control.kcontrol->tlv.p)\r\np = sm->dobj.control.kcontrol->tlv.p;\r\nsnd_ctl_remove(card, sm->dobj.control.kcontrol);\r\nlist_del(&sm->dobj.list);\r\nkfree(sm);\r\nkfree(p);\r\n}\r\nstatic void remove_enum(struct snd_soc_component *comp,\r\nstruct snd_soc_dobj *dobj, int pass)\r\n{\r\nstruct snd_card *card = comp->card->snd_card;\r\nstruct soc_enum *se = container_of(dobj, struct soc_enum, dobj);\r\nint i;\r\nif (pass != SOC_TPLG_PASS_MIXER)\r\nreturn;\r\nif (dobj->ops && dobj->ops->control_unload)\r\ndobj->ops->control_unload(comp, dobj);\r\nsnd_ctl_remove(card, se->dobj.control.kcontrol);\r\nlist_del(&se->dobj.list);\r\nkfree(se->dobj.control.dvalues);\r\nfor (i = 0; i < se->items; i++)\r\nkfree(se->dobj.control.dtexts[i]);\r\nkfree(se);\r\n}\r\nstatic void remove_bytes(struct snd_soc_component *comp,\r\nstruct snd_soc_dobj *dobj, int pass)\r\n{\r\nstruct snd_card *card = comp->card->snd_card;\r\nstruct soc_bytes_ext *sb =\r\ncontainer_of(dobj, struct soc_bytes_ext, dobj);\r\nif (pass != SOC_TPLG_PASS_MIXER)\r\nreturn;\r\nif (dobj->ops && dobj->ops->control_unload)\r\ndobj->ops->control_unload(comp, dobj);\r\nsnd_ctl_remove(card, sb->dobj.control.kcontrol);\r\nlist_del(&sb->dobj.list);\r\nkfree(sb);\r\n}\r\nstatic void remove_widget(struct snd_soc_component *comp,\r\nstruct snd_soc_dobj *dobj, int pass)\r\n{\r\nstruct snd_card *card = comp->card->snd_card;\r\nstruct snd_soc_dapm_widget *w =\r\ncontainer_of(dobj, struct snd_soc_dapm_widget, dobj);\r\nint i;\r\nif (pass != SOC_TPLG_PASS_WIDGET)\r\nreturn;\r\nif (dobj->ops && dobj->ops->widget_unload)\r\ndobj->ops->widget_unload(comp, dobj);\r\nif (dobj->widget.kcontrol_enum) {\r\nstruct soc_enum *se =\r\n(struct soc_enum *)w->kcontrols[0]->private_value;\r\nsnd_ctl_remove(card, w->kcontrols[0]);\r\nkfree(se->dobj.control.dvalues);\r\nfor (i = 0; i < se->items; i++)\r\nkfree(se->dobj.control.dtexts[i]);\r\nkfree(se);\r\nkfree(w->kcontrol_news);\r\n} else {\r\nfor (i = 0; i < w->num_kcontrols; i++) {\r\nstruct snd_kcontrol *kcontrol = w->kcontrols[i];\r\nstruct soc_mixer_control *sm =\r\n(struct soc_mixer_control *) kcontrol->private_value;\r\nkfree(w->kcontrols[i]->tlv.p);\r\nsnd_ctl_remove(card, w->kcontrols[i]);\r\nkfree(sm);\r\n}\r\nkfree(w->kcontrol_news);\r\n}\r\n}\r\nstatic void remove_dai(struct snd_soc_component *comp,\r\nstruct snd_soc_dobj *dobj, int pass)\r\n{\r\nstruct snd_soc_dai_driver *dai_drv =\r\ncontainer_of(dobj, struct snd_soc_dai_driver, dobj);\r\nif (pass != SOC_TPLG_PASS_PCM_DAI)\r\nreturn;\r\nif (dobj->ops && dobj->ops->dai_unload)\r\ndobj->ops->dai_unload(comp, dobj);\r\nlist_del(&dobj->list);\r\nkfree(dai_drv);\r\n}\r\nstatic void remove_link(struct snd_soc_component *comp,\r\nstruct snd_soc_dobj *dobj, int pass)\r\n{\r\nstruct snd_soc_dai_link *link =\r\ncontainer_of(dobj, struct snd_soc_dai_link, dobj);\r\nif (pass != SOC_TPLG_PASS_PCM_DAI)\r\nreturn;\r\nif (dobj->ops && dobj->ops->link_unload)\r\ndobj->ops->link_unload(comp, dobj);\r\nlist_del(&dobj->list);\r\nsnd_soc_remove_dai_link(comp->card, link);\r\nkfree(link);\r\n}\r\nstatic int soc_tplg_kcontrol_bind_io(struct snd_soc_tplg_ctl_hdr *hdr,\r\nstruct snd_kcontrol_new *k,\r\nconst struct soc_tplg *tplg)\r\n{\r\nconst struct snd_soc_tplg_kcontrol_ops *ops;\r\nconst struct snd_soc_tplg_bytes_ext_ops *ext_ops;\r\nint num_ops, i;\r\nif (hdr->ops.info == SND_SOC_TPLG_CTL_BYTES\r\n&& k->iface & SNDRV_CTL_ELEM_IFACE_MIXER\r\n&& k->access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE\r\n&& k->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\r\nstruct soc_bytes_ext *sbe;\r\nstruct snd_soc_tplg_bytes_control *be;\r\nsbe = (struct soc_bytes_ext *)k->private_value;\r\nbe = container_of(hdr, struct snd_soc_tplg_bytes_control, hdr);\r\nk->info = snd_soc_bytes_info_ext;\r\nk->tlv.c = snd_soc_bytes_tlv_callback;\r\next_ops = tplg->bytes_ext_ops;\r\nnum_ops = tplg->bytes_ext_ops_count;\r\nfor (i = 0; i < num_ops; i++) {\r\nif (!sbe->put && ext_ops[i].id == be->ext_ops.put)\r\nsbe->put = ext_ops[i].put;\r\nif (!sbe->get && ext_ops[i].id == be->ext_ops.get)\r\nsbe->get = ext_ops[i].get;\r\n}\r\nif (sbe->put && sbe->get)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nops = tplg->io_ops;\r\nnum_ops = tplg->io_ops_count;\r\nfor (i = 0; i < num_ops; i++) {\r\nif (k->put == NULL && ops[i].id == hdr->ops.put)\r\nk->put = ops[i].put;\r\nif (k->get == NULL && ops[i].id == hdr->ops.get)\r\nk->get = ops[i].get;\r\nif (k->info == NULL && ops[i].id == hdr->ops.info)\r\nk->info = ops[i].info;\r\n}\r\nif (k->put && k->get && k->info)\r\nreturn 0;\r\nops = io_ops;\r\nnum_ops = ARRAY_SIZE(io_ops);\r\nfor (i = 0; i < num_ops; i++) {\r\nif (k->put == NULL && ops[i].id == hdr->ops.put)\r\nk->put = ops[i].put;\r\nif (k->get == NULL && ops[i].id == hdr->ops.get)\r\nk->get = ops[i].get;\r\nif (k->info == NULL && ops[i].id == hdr->ops.info)\r\nk->info = ops[i].info;\r\n}\r\nif (k->put && k->get && k->info)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nint snd_soc_tplg_widget_bind_event(struct snd_soc_dapm_widget *w,\r\nconst struct snd_soc_tplg_widget_events *events,\r\nint num_events, u16 event_type)\r\n{\r\nint i;\r\nw->event = NULL;\r\nfor (i = 0; i < num_events; i++) {\r\nif (event_type == events[i].type) {\r\nw->event = events[i].event_handler;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int soc_tplg_init_kcontrol(struct soc_tplg *tplg,\r\nstruct snd_kcontrol_new *k, struct snd_soc_tplg_ctl_hdr *hdr)\r\n{\r\nif (tplg->comp && tplg->ops && tplg->ops->control_load)\r\nreturn tplg->ops->control_load(tplg->comp, k, hdr);\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_create_tlv_db_scale(struct soc_tplg *tplg,\r\nstruct snd_kcontrol_new *kc, struct snd_soc_tplg_tlv_dbscale *scale)\r\n{\r\nunsigned int item_len = 2 * sizeof(unsigned int);\r\nunsigned int *p;\r\np = kzalloc(item_len + 2 * sizeof(unsigned int), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np[0] = SNDRV_CTL_TLVT_DB_SCALE;\r\np[1] = item_len;\r\np[2] = scale->min;\r\np[3] = (scale->step & TLV_DB_SCALE_MASK)\r\n| (scale->mute ? TLV_DB_SCALE_MUTE : 0);\r\nkc->tlv.p = (void *)p;\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_create_tlv(struct soc_tplg *tplg,\r\nstruct snd_kcontrol_new *kc, struct snd_soc_tplg_ctl_hdr *tc)\r\n{\r\nstruct snd_soc_tplg_ctl_tlv *tplg_tlv;\r\nif (!(tc->access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE))\r\nreturn 0;\r\nif (!(tc->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK)) {\r\ntplg_tlv = &tc->tlv;\r\nswitch (tplg_tlv->type) {\r\ncase SNDRV_CTL_TLVT_DB_SCALE:\r\nreturn soc_tplg_create_tlv_db_scale(tplg, kc,\r\n&tplg_tlv->scale);\r\ndefault:\r\ndev_dbg(tplg->dev, "Unsupported TLV type %d\n",\r\ntplg_tlv->type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void soc_tplg_free_tlv(struct soc_tplg *tplg,\r\nstruct snd_kcontrol_new *kc)\r\n{\r\nkfree(kc->tlv.p);\r\n}\r\nstatic int soc_tplg_dbytes_create(struct soc_tplg *tplg, unsigned int count,\r\nsize_t size)\r\n{\r\nstruct snd_soc_tplg_bytes_control *be;\r\nstruct soc_bytes_ext *sbe;\r\nstruct snd_kcontrol_new kc;\r\nint i, err;\r\nif (soc_tplg_check_elem_count(tplg,\r\nsizeof(struct snd_soc_tplg_bytes_control), count,\r\nsize, "mixer bytes")) {\r\ndev_err(tplg->dev, "ASoC: Invalid count %d for byte control\n",\r\ncount);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nbe = (struct snd_soc_tplg_bytes_control *)tplg->pos;\r\nif (strnlen(be->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\nreturn -EINVAL;\r\nsbe = kzalloc(sizeof(*sbe), GFP_KERNEL);\r\nif (sbe == NULL)\r\nreturn -ENOMEM;\r\ntplg->pos += (sizeof(struct snd_soc_tplg_bytes_control) +\r\nbe->priv.size);\r\ndev_dbg(tplg->dev,\r\n"ASoC: adding bytes kcontrol %s with access 0x%x\n",\r\nbe->hdr.name, be->hdr.access);\r\nmemset(&kc, 0, sizeof(kc));\r\nkc.name = be->hdr.name;\r\nkc.private_value = (long)sbe;\r\nkc.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nkc.access = be->hdr.access;\r\nsbe->max = be->max;\r\nsbe->dobj.type = SND_SOC_DOBJ_BYTES;\r\nsbe->dobj.ops = tplg->ops;\r\nINIT_LIST_HEAD(&sbe->dobj.list);\r\nerr = soc_tplg_kcontrol_bind_io(&be->hdr, &kc, tplg);\r\nif (err) {\r\nsoc_control_err(tplg, &be->hdr, be->hdr.name);\r\nkfree(sbe);\r\ncontinue;\r\n}\r\nerr = soc_tplg_init_kcontrol(tplg, &kc,\r\n(struct snd_soc_tplg_ctl_hdr *)be);\r\nif (err < 0) {\r\ndev_err(tplg->dev, "ASoC: failed to init %s\n",\r\nbe->hdr.name);\r\nkfree(sbe);\r\ncontinue;\r\n}\r\nerr = soc_tplg_add_kcontrol(tplg, &kc,\r\n&sbe->dobj.control.kcontrol);\r\nif (err < 0) {\r\ndev_err(tplg->dev, "ASoC: failed to add %s\n",\r\nbe->hdr.name);\r\nkfree(sbe);\r\ncontinue;\r\n}\r\nlist_add(&sbe->dobj.list, &tplg->comp->dobj_list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_dmixer_create(struct soc_tplg *tplg, unsigned int count,\r\nsize_t size)\r\n{\r\nstruct snd_soc_tplg_mixer_control *mc;\r\nstruct soc_mixer_control *sm;\r\nstruct snd_kcontrol_new kc;\r\nint i, err;\r\nif (soc_tplg_check_elem_count(tplg,\r\nsizeof(struct snd_soc_tplg_mixer_control),\r\ncount, size, "mixers")) {\r\ndev_err(tplg->dev, "ASoC: invalid count %d for controls\n",\r\ncount);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nmc = (struct snd_soc_tplg_mixer_control *)tplg->pos;\r\nif (strnlen(mc->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\nreturn -EINVAL;\r\nsm = kzalloc(sizeof(*sm), GFP_KERNEL);\r\nif (sm == NULL)\r\nreturn -ENOMEM;\r\ntplg->pos += (sizeof(struct snd_soc_tplg_mixer_control) +\r\nmc->priv.size);\r\ndev_dbg(tplg->dev,\r\n"ASoC: adding mixer kcontrol %s with access 0x%x\n",\r\nmc->hdr.name, mc->hdr.access);\r\nmemset(&kc, 0, sizeof(kc));\r\nkc.name = mc->hdr.name;\r\nkc.private_value = (long)sm;\r\nkc.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nkc.access = mc->hdr.access;\r\nsm->reg = tplc_chan_get_reg(tplg, mc->channel,\r\nSNDRV_CHMAP_FL);\r\nsm->rreg = tplc_chan_get_reg(tplg, mc->channel,\r\nSNDRV_CHMAP_FR);\r\nsm->shift = tplc_chan_get_shift(tplg, mc->channel,\r\nSNDRV_CHMAP_FL);\r\nsm->rshift = tplc_chan_get_shift(tplg, mc->channel,\r\nSNDRV_CHMAP_FR);\r\nsm->max = mc->max;\r\nsm->min = mc->min;\r\nsm->invert = mc->invert;\r\nsm->platform_max = mc->platform_max;\r\nsm->dobj.index = tplg->index;\r\nsm->dobj.ops = tplg->ops;\r\nsm->dobj.type = SND_SOC_DOBJ_MIXER;\r\nINIT_LIST_HEAD(&sm->dobj.list);\r\nerr = soc_tplg_kcontrol_bind_io(&mc->hdr, &kc, tplg);\r\nif (err) {\r\nsoc_control_err(tplg, &mc->hdr, mc->hdr.name);\r\nkfree(sm);\r\ncontinue;\r\n}\r\nerr = soc_tplg_init_kcontrol(tplg, &kc,\r\n(struct snd_soc_tplg_ctl_hdr *) mc);\r\nif (err < 0) {\r\ndev_err(tplg->dev, "ASoC: failed to init %s\n",\r\nmc->hdr.name);\r\nkfree(sm);\r\ncontinue;\r\n}\r\nsoc_tplg_create_tlv(tplg, &kc, &mc->hdr);\r\nerr = soc_tplg_add_kcontrol(tplg, &kc,\r\n&sm->dobj.control.kcontrol);\r\nif (err < 0) {\r\ndev_err(tplg->dev, "ASoC: failed to add %s\n",\r\nmc->hdr.name);\r\nsoc_tplg_free_tlv(tplg, &kc);\r\nkfree(sm);\r\ncontinue;\r\n}\r\nlist_add(&sm->dobj.list, &tplg->comp->dobj_list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_denum_create_texts(struct soc_enum *se,\r\nstruct snd_soc_tplg_enum_control *ec)\r\n{\r\nint i, ret;\r\nse->dobj.control.dtexts =\r\nkzalloc(sizeof(char *) * ec->items, GFP_KERNEL);\r\nif (se->dobj.control.dtexts == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ec->items; i++) {\r\nif (strnlen(ec->texts[i], SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nse->dobj.control.dtexts[i] = kstrdup(ec->texts[i], GFP_KERNEL);\r\nif (!se->dobj.control.dtexts[i]) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nfor (--i; i >= 0; i--)\r\nkfree(se->dobj.control.dtexts[i]);\r\nkfree(se->dobj.control.dtexts);\r\nreturn ret;\r\n}\r\nstatic int soc_tplg_denum_create_values(struct soc_enum *se,\r\nstruct snd_soc_tplg_enum_control *ec)\r\n{\r\nif (ec->items > sizeof(*ec->values))\r\nreturn -EINVAL;\r\nse->dobj.control.dvalues = kmemdup(ec->values,\r\nec->items * sizeof(u32),\r\nGFP_KERNEL);\r\nif (!se->dobj.control.dvalues)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_denum_create(struct soc_tplg *tplg, unsigned int count,\r\nsize_t size)\r\n{\r\nstruct snd_soc_tplg_enum_control *ec;\r\nstruct soc_enum *se;\r\nstruct snd_kcontrol_new kc;\r\nint i, ret, err;\r\nif (soc_tplg_check_elem_count(tplg,\r\nsizeof(struct snd_soc_tplg_enum_control),\r\ncount, size, "enums")) {\r\ndev_err(tplg->dev, "ASoC: invalid count %d for enum controls\n",\r\ncount);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nec = (struct snd_soc_tplg_enum_control *)tplg->pos;\r\ntplg->pos += (sizeof(struct snd_soc_tplg_enum_control) +\r\nec->priv.size);\r\nif (strnlen(ec->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\nreturn -EINVAL;\r\nse = kzalloc((sizeof(*se)), GFP_KERNEL);\r\nif (se == NULL)\r\nreturn -ENOMEM;\r\ndev_dbg(tplg->dev, "ASoC: adding enum kcontrol %s size %d\n",\r\nec->hdr.name, ec->items);\r\nmemset(&kc, 0, sizeof(kc));\r\nkc.name = ec->hdr.name;\r\nkc.private_value = (long)se;\r\nkc.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nkc.access = ec->hdr.access;\r\nse->reg = tplc_chan_get_reg(tplg, ec->channel, SNDRV_CHMAP_FL);\r\nse->shift_l = tplc_chan_get_shift(tplg, ec->channel,\r\nSNDRV_CHMAP_FL);\r\nse->shift_r = tplc_chan_get_shift(tplg, ec->channel,\r\nSNDRV_CHMAP_FL);\r\nse->items = ec->items;\r\nse->mask = ec->mask;\r\nse->dobj.index = tplg->index;\r\nse->dobj.type = SND_SOC_DOBJ_ENUM;\r\nse->dobj.ops = tplg->ops;\r\nINIT_LIST_HEAD(&se->dobj.list);\r\nswitch (ec->hdr.ops.info) {\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:\r\ncase SND_SOC_TPLG_CTL_ENUM_VALUE:\r\nerr = soc_tplg_denum_create_values(se, ec);\r\nif (err < 0) {\r\ndev_err(tplg->dev,\r\n"ASoC: could not create values for %s\n",\r\nec->hdr.name);\r\nkfree(se);\r\ncontinue;\r\n}\r\ncase SND_SOC_TPLG_CTL_ENUM:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:\r\nerr = soc_tplg_denum_create_texts(se, ec);\r\nif (err < 0) {\r\ndev_err(tplg->dev,\r\n"ASoC: could not create texts for %s\n",\r\nec->hdr.name);\r\nkfree(se);\r\ncontinue;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(tplg->dev,\r\n"ASoC: invalid enum control type %d for %s\n",\r\nec->hdr.ops.info, ec->hdr.name);\r\nkfree(se);\r\ncontinue;\r\n}\r\nerr = soc_tplg_kcontrol_bind_io(&ec->hdr, &kc, tplg);\r\nif (err) {\r\nsoc_control_err(tplg, &ec->hdr, ec->hdr.name);\r\nkfree(se);\r\ncontinue;\r\n}\r\nerr = soc_tplg_init_kcontrol(tplg, &kc,\r\n(struct snd_soc_tplg_ctl_hdr *) ec);\r\nif (err < 0) {\r\ndev_err(tplg->dev, "ASoC: failed to init %s\n",\r\nec->hdr.name);\r\nkfree(se);\r\ncontinue;\r\n}\r\nret = soc_tplg_add_kcontrol(tplg,\r\n&kc, &se->dobj.control.kcontrol);\r\nif (ret < 0) {\r\ndev_err(tplg->dev, "ASoC: could not add kcontrol %s\n",\r\nec->hdr.name);\r\nkfree(se);\r\ncontinue;\r\n}\r\nlist_add(&se->dobj.list, &tplg->comp->dobj_list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_kcontrol_elems_load(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_hdr *hdr)\r\n{\r\nstruct snd_soc_tplg_ctl_hdr *control_hdr;\r\nint i;\r\nif (tplg->pass != SOC_TPLG_PASS_MIXER) {\r\ntplg->pos += hdr->size + hdr->payload_size;\r\nreturn 0;\r\n}\r\ndev_dbg(tplg->dev, "ASoC: adding %d kcontrols at 0x%lx\n", hdr->count,\r\nsoc_tplg_get_offset(tplg));\r\nfor (i = 0; i < hdr->count; i++) {\r\ncontrol_hdr = (struct snd_soc_tplg_ctl_hdr *)tplg->pos;\r\nif (control_hdr->size != sizeof(*control_hdr)) {\r\ndev_err(tplg->dev, "ASoC: invalid control size\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (control_hdr->ops.info) {\r\ncase SND_SOC_TPLG_CTL_VOLSW:\r\ncase SND_SOC_TPLG_CTL_STROBE:\r\ncase SND_SOC_TPLG_CTL_VOLSW_SX:\r\ncase SND_SOC_TPLG_CTL_VOLSW_XR_SX:\r\ncase SND_SOC_TPLG_CTL_RANGE:\r\ncase SND_SOC_TPLG_DAPM_CTL_VOLSW:\r\ncase SND_SOC_TPLG_DAPM_CTL_PIN:\r\nsoc_tplg_dmixer_create(tplg, 1, hdr->payload_size);\r\nbreak;\r\ncase SND_SOC_TPLG_CTL_ENUM:\r\ncase SND_SOC_TPLG_CTL_ENUM_VALUE:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:\r\nsoc_tplg_denum_create(tplg, 1, hdr->payload_size);\r\nbreak;\r\ncase SND_SOC_TPLG_CTL_BYTES:\r\nsoc_tplg_dbytes_create(tplg, 1, hdr->payload_size);\r\nbreak;\r\ndefault:\r\nsoc_bind_err(tplg, control_hdr, i);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_dapm_graph_elems_load(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_hdr *hdr)\r\n{\r\nstruct snd_soc_dapm_context *dapm = &tplg->comp->dapm;\r\nstruct snd_soc_dapm_route route;\r\nstruct snd_soc_tplg_dapm_graph_elem *elem;\r\nint count = hdr->count, i;\r\nif (tplg->pass != SOC_TPLG_PASS_GRAPH) {\r\ntplg->pos += hdr->size + hdr->payload_size;\r\nreturn 0;\r\n}\r\nif (soc_tplg_check_elem_count(tplg,\r\nsizeof(struct snd_soc_tplg_dapm_graph_elem),\r\ncount, hdr->payload_size, "graph")) {\r\ndev_err(tplg->dev, "ASoC: invalid count %d for DAPM routes\n",\r\ncount);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(tplg->dev, "ASoC: adding %d DAPM routes\n", count);\r\nfor (i = 0; i < count; i++) {\r\nelem = (struct snd_soc_tplg_dapm_graph_elem *)tplg->pos;\r\ntplg->pos += sizeof(struct snd_soc_tplg_dapm_graph_elem);\r\nif (strnlen(elem->source, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\nreturn -EINVAL;\r\nif (strnlen(elem->sink, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\nreturn -EINVAL;\r\nif (strnlen(elem->control, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\nreturn -EINVAL;\r\nroute.source = elem->source;\r\nroute.sink = elem->sink;\r\nroute.connected = NULL;\r\nif (strnlen(elem->control, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) == 0)\r\nroute.control = NULL;\r\nelse\r\nroute.control = elem->control;\r\nsnd_soc_dapm_add_routes(dapm, &route, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct snd_kcontrol_new *soc_tplg_dapm_widget_dmixer_create(\r\nstruct soc_tplg *tplg, int num_kcontrols)\r\n{\r\nstruct snd_kcontrol_new *kc;\r\nstruct soc_mixer_control *sm;\r\nstruct snd_soc_tplg_mixer_control *mc;\r\nint i, err;\r\nkc = kcalloc(num_kcontrols, sizeof(*kc), GFP_KERNEL);\r\nif (kc == NULL)\r\nreturn NULL;\r\nfor (i = 0; i < num_kcontrols; i++) {\r\nmc = (struct snd_soc_tplg_mixer_control *)tplg->pos;\r\nsm = kzalloc(sizeof(*sm), GFP_KERNEL);\r\nif (sm == NULL)\r\ngoto err;\r\ntplg->pos += (sizeof(struct snd_soc_tplg_mixer_control) +\r\nmc->priv.size);\r\nif (strnlen(mc->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\ngoto err_str;\r\ndev_dbg(tplg->dev, " adding DAPM widget mixer control %s at %d\n",\r\nmc->hdr.name, i);\r\nkc[i].name = mc->hdr.name;\r\nkc[i].private_value = (long)sm;\r\nkc[i].iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nkc[i].access = mc->hdr.access;\r\nsm->reg = tplc_chan_get_reg(tplg, mc->channel,\r\nSNDRV_CHMAP_FL);\r\nsm->rreg = tplc_chan_get_reg(tplg, mc->channel,\r\nSNDRV_CHMAP_FR);\r\nsm->shift = tplc_chan_get_shift(tplg, mc->channel,\r\nSNDRV_CHMAP_FL);\r\nsm->rshift = tplc_chan_get_shift(tplg, mc->channel,\r\nSNDRV_CHMAP_FR);\r\nsm->max = mc->max;\r\nsm->min = mc->min;\r\nsm->invert = mc->invert;\r\nsm->platform_max = mc->platform_max;\r\nsm->dobj.index = tplg->index;\r\nINIT_LIST_HEAD(&sm->dobj.list);\r\nerr = soc_tplg_kcontrol_bind_io(&mc->hdr, &kc[i], tplg);\r\nif (err) {\r\nsoc_control_err(tplg, &mc->hdr, mc->hdr.name);\r\nkfree(sm);\r\ncontinue;\r\n}\r\nerr = soc_tplg_init_kcontrol(tplg, &kc[i],\r\n(struct snd_soc_tplg_ctl_hdr *)mc);\r\nif (err < 0) {\r\ndev_err(tplg->dev, "ASoC: failed to init %s\n",\r\nmc->hdr.name);\r\nkfree(sm);\r\ncontinue;\r\n}\r\n}\r\nreturn kc;\r\nerr_str:\r\nkfree(sm);\r\nerr:\r\nfor (--i; i >= 0; i--)\r\nkfree((void *)kc[i].private_value);\r\nkfree(kc);\r\nreturn NULL;\r\n}\r\nstatic struct snd_kcontrol_new *soc_tplg_dapm_widget_denum_create(\r\nstruct soc_tplg *tplg)\r\n{\r\nstruct snd_kcontrol_new *kc;\r\nstruct snd_soc_tplg_enum_control *ec;\r\nstruct soc_enum *se;\r\nint i, err;\r\nec = (struct snd_soc_tplg_enum_control *)tplg->pos;\r\ntplg->pos += (sizeof(struct snd_soc_tplg_enum_control) +\r\nec->priv.size);\r\nif (strnlen(ec->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\nreturn NULL;\r\nkc = kzalloc(sizeof(*kc), GFP_KERNEL);\r\nif (kc == NULL)\r\nreturn NULL;\r\nse = kzalloc(sizeof(*se), GFP_KERNEL);\r\nif (se == NULL)\r\ngoto err;\r\ndev_dbg(tplg->dev, " adding DAPM widget enum control %s\n",\r\nec->hdr.name);\r\nkc->name = ec->hdr.name;\r\nkc->private_value = (long)se;\r\nkc->iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nkc->access = ec->hdr.access;\r\nse->reg = tplc_chan_get_reg(tplg, ec->channel, SNDRV_CHMAP_FL);\r\nse->shift_l = tplc_chan_get_shift(tplg, ec->channel, SNDRV_CHMAP_FL);\r\nse->shift_r = tplc_chan_get_shift(tplg, ec->channel, SNDRV_CHMAP_FR);\r\nse->items = ec->items;\r\nse->mask = ec->mask;\r\nse->dobj.index = tplg->index;\r\nswitch (ec->hdr.ops.info) {\r\ncase SND_SOC_TPLG_CTL_ENUM_VALUE:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:\r\nerr = soc_tplg_denum_create_values(se, ec);\r\nif (err < 0) {\r\ndev_err(tplg->dev, "ASoC: could not create values for %s\n",\r\nec->hdr.name);\r\ngoto err_se;\r\n}\r\ncase SND_SOC_TPLG_CTL_ENUM:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:\r\nerr = soc_tplg_denum_create_texts(se, ec);\r\nif (err < 0) {\r\ndev_err(tplg->dev, "ASoC: could not create texts for %s\n",\r\nec->hdr.name);\r\ngoto err_se;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(tplg->dev, "ASoC: invalid enum control type %d for %s\n",\r\nec->hdr.ops.info, ec->hdr.name);\r\ngoto err_se;\r\n}\r\nerr = soc_tplg_kcontrol_bind_io(&ec->hdr, kc, tplg);\r\nif (err) {\r\nsoc_control_err(tplg, &ec->hdr, ec->hdr.name);\r\ngoto err_se;\r\n}\r\nerr = soc_tplg_init_kcontrol(tplg, kc,\r\n(struct snd_soc_tplg_ctl_hdr *)ec);\r\nif (err < 0) {\r\ndev_err(tplg->dev, "ASoC: failed to init %s\n",\r\nec->hdr.name);\r\ngoto err_se;\r\n}\r\nreturn kc;\r\nerr_se:\r\nkfree(se->dobj.control.dvalues);\r\nfor (i = 0; i < ec->items; i++)\r\nkfree(se->dobj.control.dtexts[i]);\r\nkfree(se);\r\nerr:\r\nkfree(kc);\r\nreturn NULL;\r\n}\r\nstatic struct snd_kcontrol_new *soc_tplg_dapm_widget_dbytes_create(\r\nstruct soc_tplg *tplg, int count)\r\n{\r\nstruct snd_soc_tplg_bytes_control *be;\r\nstruct soc_bytes_ext *sbe;\r\nstruct snd_kcontrol_new *kc;\r\nint i, err;\r\nkc = kcalloc(count, sizeof(*kc), GFP_KERNEL);\r\nif (!kc)\r\nreturn NULL;\r\nfor (i = 0; i < count; i++) {\r\nbe = (struct snd_soc_tplg_bytes_control *)tplg->pos;\r\nif (strnlen(be->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\ngoto err;\r\nsbe = kzalloc(sizeof(*sbe), GFP_KERNEL);\r\nif (sbe == NULL)\r\ngoto err;\r\ntplg->pos += (sizeof(struct snd_soc_tplg_bytes_control) +\r\nbe->priv.size);\r\ndev_dbg(tplg->dev,\r\n"ASoC: adding bytes kcontrol %s with access 0x%x\n",\r\nbe->hdr.name, be->hdr.access);\r\nkc[i].name = be->hdr.name;\r\nkc[i].private_value = (long)sbe;\r\nkc[i].iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nkc[i].access = be->hdr.access;\r\nsbe->max = be->max;\r\nINIT_LIST_HEAD(&sbe->dobj.list);\r\nerr = soc_tplg_kcontrol_bind_io(&be->hdr, &kc[i], tplg);\r\nif (err) {\r\nsoc_control_err(tplg, &be->hdr, be->hdr.name);\r\nkfree(sbe);\r\ncontinue;\r\n}\r\nerr = soc_tplg_init_kcontrol(tplg, &kc[i],\r\n(struct snd_soc_tplg_ctl_hdr *)be);\r\nif (err < 0) {\r\ndev_err(tplg->dev, "ASoC: failed to init %s\n",\r\nbe->hdr.name);\r\nkfree(sbe);\r\ncontinue;\r\n}\r\n}\r\nreturn kc;\r\nerr:\r\nfor (--i; i >= 0; i--)\r\nkfree((void *)kc[i].private_value);\r\nkfree(kc);\r\nreturn NULL;\r\n}\r\nstatic int soc_tplg_dapm_widget_create(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_dapm_widget *w)\r\n{\r\nstruct snd_soc_dapm_context *dapm = &tplg->comp->dapm;\r\nstruct snd_soc_dapm_widget template, *widget;\r\nstruct snd_soc_tplg_ctl_hdr *control_hdr;\r\nstruct snd_soc_card *card = tplg->comp->card;\r\nint ret = 0;\r\nif (strnlen(w->name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\nreturn -EINVAL;\r\nif (strnlen(w->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\nreturn -EINVAL;\r\ndev_dbg(tplg->dev, "ASoC: creating DAPM widget %s id %d\n",\r\nw->name, w->id);\r\nmemset(&template, 0, sizeof(template));\r\ntemplate.id = get_widget_id(w->id);\r\nif (template.id < 0)\r\nreturn template.id;\r\ntemplate.name = kstrdup(w->name, GFP_KERNEL);\r\nif (!template.name)\r\nreturn -ENOMEM;\r\ntemplate.sname = kstrdup(w->sname, GFP_KERNEL);\r\nif (!template.sname) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ntemplate.reg = w->reg;\r\ntemplate.shift = w->shift;\r\ntemplate.mask = w->mask;\r\ntemplate.subseq = w->subseq;\r\ntemplate.on_val = w->invert ? 0 : 1;\r\ntemplate.off_val = w->invert ? 1 : 0;\r\ntemplate.ignore_suspend = w->ignore_suspend;\r\ntemplate.event_flags = w->event_flags;\r\ntemplate.dobj.index = tplg->index;\r\ntplg->pos +=\r\n(sizeof(struct snd_soc_tplg_dapm_widget) + w->priv.size);\r\nif (w->num_kcontrols == 0) {\r\ntemplate.num_kcontrols = 0;\r\ngoto widget;\r\n}\r\ncontrol_hdr = (struct snd_soc_tplg_ctl_hdr *)tplg->pos;\r\ndev_dbg(tplg->dev, "ASoC: template %s has %d controls of type %x\n",\r\nw->name, w->num_kcontrols, control_hdr->type);\r\nswitch (control_hdr->ops.info) {\r\ncase SND_SOC_TPLG_CTL_VOLSW:\r\ncase SND_SOC_TPLG_CTL_STROBE:\r\ncase SND_SOC_TPLG_CTL_VOLSW_SX:\r\ncase SND_SOC_TPLG_CTL_VOLSW_XR_SX:\r\ncase SND_SOC_TPLG_CTL_RANGE:\r\ncase SND_SOC_TPLG_DAPM_CTL_VOLSW:\r\ntemplate.num_kcontrols = w->num_kcontrols;\r\ntemplate.kcontrol_news =\r\nsoc_tplg_dapm_widget_dmixer_create(tplg,\r\ntemplate.num_kcontrols);\r\nif (!template.kcontrol_news) {\r\nret = -ENOMEM;\r\ngoto hdr_err;\r\n}\r\nbreak;\r\ncase SND_SOC_TPLG_CTL_ENUM:\r\ncase SND_SOC_TPLG_CTL_ENUM_VALUE:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:\r\ncase SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:\r\ntemplate.dobj.widget.kcontrol_enum = 1;\r\ntemplate.num_kcontrols = 1;\r\ntemplate.kcontrol_news =\r\nsoc_tplg_dapm_widget_denum_create(tplg);\r\nif (!template.kcontrol_news) {\r\nret = -ENOMEM;\r\ngoto hdr_err;\r\n}\r\nbreak;\r\ncase SND_SOC_TPLG_CTL_BYTES:\r\ntemplate.num_kcontrols = w->num_kcontrols;\r\ntemplate.kcontrol_news =\r\nsoc_tplg_dapm_widget_dbytes_create(tplg,\r\ntemplate.num_kcontrols);\r\nif (!template.kcontrol_news) {\r\nret = -ENOMEM;\r\ngoto hdr_err;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(tplg->dev, "ASoC: invalid widget control type %d:%d:%d\n",\r\ncontrol_hdr->ops.get, control_hdr->ops.put,\r\ncontrol_hdr->ops.info);\r\nret = -EINVAL;\r\ngoto hdr_err;\r\n}\r\nwidget:\r\nret = soc_tplg_widget_load(tplg, &template, w);\r\nif (ret < 0)\r\ngoto hdr_err;\r\nif (card->instantiated)\r\nwidget = snd_soc_dapm_new_control(dapm, &template);\r\nelse\r\nwidget = snd_soc_dapm_new_control_unlocked(dapm, &template);\r\nif (widget == NULL) {\r\ndev_err(tplg->dev, "ASoC: failed to create widget %s controls\n",\r\nw->name);\r\ngoto hdr_err;\r\n}\r\nwidget->dobj.type = SND_SOC_DOBJ_WIDGET;\r\nwidget->dobj.ops = tplg->ops;\r\nwidget->dobj.index = tplg->index;\r\nkfree(template.sname);\r\nkfree(template.name);\r\nlist_add(&widget->dobj.list, &tplg->comp->dobj_list);\r\nreturn 0;\r\nhdr_err:\r\nkfree(template.sname);\r\nerr:\r\nkfree(template.name);\r\nreturn ret;\r\n}\r\nstatic int soc_tplg_dapm_widget_elems_load(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_hdr *hdr)\r\n{\r\nstruct snd_soc_tplg_dapm_widget *widget;\r\nint ret, count = hdr->count, i;\r\nif (tplg->pass != SOC_TPLG_PASS_WIDGET)\r\nreturn 0;\r\ndev_dbg(tplg->dev, "ASoC: adding %d DAPM widgets\n", count);\r\nfor (i = 0; i < count; i++) {\r\nwidget = (struct snd_soc_tplg_dapm_widget *) tplg->pos;\r\nif (widget->size != sizeof(*widget)) {\r\ndev_err(tplg->dev, "ASoC: invalid widget size\n");\r\nreturn -EINVAL;\r\n}\r\nret = soc_tplg_dapm_widget_create(tplg, widget);\r\nif (ret < 0) {\r\ndev_err(tplg->dev, "ASoC: failed to load widget %s\n",\r\nwidget->name);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_dapm_complete(struct soc_tplg *tplg)\r\n{\r\nstruct snd_soc_card *card = tplg->comp->card;\r\nint ret;\r\nif (!card || !card->instantiated) {\r\ndev_warn(tplg->dev, "ASoC: Parent card not yet available,"\r\n"Do not add new widgets now\n");\r\nreturn 0;\r\n}\r\nret = snd_soc_dapm_new_widgets(card);\r\nif (ret < 0)\r\ndev_err(tplg->dev, "ASoC: failed to create new widgets %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nstatic void set_stream_info(struct snd_soc_pcm_stream *stream,\r\nstruct snd_soc_tplg_stream_caps *caps)\r\n{\r\nstream->stream_name = kstrdup(caps->name, GFP_KERNEL);\r\nstream->channels_min = caps->channels_min;\r\nstream->channels_max = caps->channels_max;\r\nstream->rates = caps->rates;\r\nstream->rate_min = caps->rate_min;\r\nstream->rate_max = caps->rate_max;\r\nstream->formats = caps->formats;\r\n}\r\nstatic int soc_tplg_dai_create(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_pcm *pcm)\r\n{\r\nstruct snd_soc_dai_driver *dai_drv;\r\nstruct snd_soc_pcm_stream *stream;\r\nstruct snd_soc_tplg_stream_caps *caps;\r\nint ret;\r\ndai_drv = kzalloc(sizeof(struct snd_soc_dai_driver), GFP_KERNEL);\r\nif (dai_drv == NULL)\r\nreturn -ENOMEM;\r\ndai_drv->name = pcm->dai_name;\r\ndai_drv->id = pcm->dai_id;\r\nif (pcm->playback) {\r\nstream = &dai_drv->playback;\r\ncaps = &pcm->caps[SND_SOC_TPLG_STREAM_PLAYBACK];\r\nset_stream_info(stream, caps);\r\n}\r\nif (pcm->capture) {\r\nstream = &dai_drv->capture;\r\ncaps = &pcm->caps[SND_SOC_TPLG_STREAM_CAPTURE];\r\nset_stream_info(stream, caps);\r\n}\r\nret = soc_tplg_dai_load(tplg, dai_drv);\r\nif (ret < 0) {\r\ndev_err(tplg->comp->dev, "ASoC: DAI loading failed\n");\r\nkfree(dai_drv);\r\nreturn ret;\r\n}\r\ndai_drv->dobj.index = tplg->index;\r\ndai_drv->dobj.ops = tplg->ops;\r\ndai_drv->dobj.type = SND_SOC_DOBJ_PCM;\r\nlist_add(&dai_drv->dobj.list, &tplg->comp->dobj_list);\r\nreturn snd_soc_register_dai(tplg->comp, dai_drv);\r\n}\r\nstatic int soc_tplg_link_create(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_pcm *pcm)\r\n{\r\nstruct snd_soc_dai_link *link;\r\nint ret;\r\nlink = kzalloc(sizeof(struct snd_soc_dai_link), GFP_KERNEL);\r\nif (link == NULL)\r\nreturn -ENOMEM;\r\nlink->name = pcm->pcm_name;\r\nlink->stream_name = pcm->pcm_name;\r\nlink->id = pcm->pcm_id;\r\nlink->cpu_dai_name = pcm->dai_name;\r\nlink->codec_name = "snd-soc-dummy";\r\nlink->codec_dai_name = "snd-soc-dummy-dai";\r\nlink->dynamic = 1;\r\nlink->dpcm_playback = pcm->playback;\r\nlink->dpcm_capture = pcm->capture;\r\nret = soc_tplg_dai_link_load(tplg, link);\r\nif (ret < 0) {\r\ndev_err(tplg->comp->dev, "ASoC: FE link loading failed\n");\r\nkfree(link);\r\nreturn ret;\r\n}\r\nlink->dobj.index = tplg->index;\r\nlink->dobj.ops = tplg->ops;\r\nlink->dobj.type = SND_SOC_DOBJ_DAI_LINK;\r\nlist_add(&link->dobj.list, &tplg->comp->dobj_list);\r\nsnd_soc_add_dai_link(tplg->comp->card, link);\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_pcm_create(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_pcm *pcm)\r\n{\r\nint ret;\r\nret = soc_tplg_dai_create(tplg, pcm);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn soc_tplg_link_create(tplg, pcm);\r\n}\r\nstatic int soc_tplg_pcm_elems_load(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_hdr *hdr)\r\n{\r\nstruct snd_soc_tplg_pcm *pcm;\r\nint count = hdr->count;\r\nint i;\r\nif (tplg->pass != SOC_TPLG_PASS_PCM_DAI)\r\nreturn 0;\r\nif (soc_tplg_check_elem_count(tplg,\r\nsizeof(struct snd_soc_tplg_pcm), count,\r\nhdr->payload_size, "PCM DAI")) {\r\ndev_err(tplg->dev, "ASoC: invalid count %d for PCM DAI elems\n",\r\ncount);\r\nreturn -EINVAL;\r\n}\r\npcm = (struct snd_soc_tplg_pcm *)tplg->pos;\r\nfor (i = 0; i < count; i++) {\r\nif (pcm->size != sizeof(*pcm)) {\r\ndev_err(tplg->dev, "ASoC: invalid pcm size\n");\r\nreturn -EINVAL;\r\n}\r\nsoc_tplg_pcm_create(tplg, pcm);\r\npcm++;\r\n}\r\ndev_dbg(tplg->dev, "ASoC: adding %d PCM DAIs\n", count);\r\ntplg->pos += sizeof(struct snd_soc_tplg_pcm) * count;\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_manifest_load(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_hdr *hdr)\r\n{\r\nstruct snd_soc_tplg_manifest *manifest;\r\nif (tplg->pass != SOC_TPLG_PASS_MANIFEST)\r\nreturn 0;\r\nmanifest = (struct snd_soc_tplg_manifest *)tplg->pos;\r\nif (manifest->size != sizeof(*manifest)) {\r\ndev_err(tplg->dev, "ASoC: invalid manifest size\n");\r\nreturn -EINVAL;\r\n}\r\ntplg->pos += sizeof(struct snd_soc_tplg_manifest);\r\nif (tplg->comp && tplg->ops && tplg->ops->manifest)\r\nreturn tplg->ops->manifest(tplg->comp, manifest);\r\ndev_err(tplg->dev, "ASoC: Firmware manifest not supported\n");\r\nreturn 0;\r\n}\r\nstatic int soc_valid_header(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_hdr *hdr)\r\n{\r\nif (soc_tplg_get_hdr_offset(tplg) >= tplg->fw->size)\r\nreturn 0;\r\nif (hdr->size != sizeof(*hdr)) {\r\ndev_err(tplg->dev,\r\n"ASoC: invalid header size for type %d at offset 0x%lx size 0x%zx.\n",\r\nhdr->type, soc_tplg_get_hdr_offset(tplg),\r\ntplg->fw->size);\r\nreturn -EINVAL;\r\n}\r\nif (hdr->magic == cpu_to_be32(SND_SOC_TPLG_MAGIC)) {\r\ndev_err(tplg->dev,\r\n"ASoC: pass %d big endian not supported header got %x at offset 0x%lx size 0x%zx.\n",\r\ntplg->pass, hdr->magic,\r\nsoc_tplg_get_hdr_offset(tplg), tplg->fw->size);\r\nreturn -EINVAL;\r\n}\r\nif (hdr->magic != SND_SOC_TPLG_MAGIC) {\r\ndev_err(tplg->dev,\r\n"ASoC: pass %d does not have a valid header got %x at offset 0x%lx size 0x%zx.\n",\r\ntplg->pass, hdr->magic,\r\nsoc_tplg_get_hdr_offset(tplg), tplg->fw->size);\r\nreturn -EINVAL;\r\n}\r\nif (hdr->abi != SND_SOC_TPLG_ABI_VERSION) {\r\ndev_err(tplg->dev,\r\n"ASoC: pass %d invalid ABI version got 0x%x need 0x%x at offset 0x%lx size 0x%zx.\n",\r\ntplg->pass, hdr->abi,\r\nSND_SOC_TPLG_ABI_VERSION, soc_tplg_get_hdr_offset(tplg),\r\ntplg->fw->size);\r\nreturn -EINVAL;\r\n}\r\nif (hdr->payload_size == 0) {\r\ndev_err(tplg->dev, "ASoC: header has 0 size at offset 0x%lx.\n",\r\nsoc_tplg_get_hdr_offset(tplg));\r\nreturn -EINVAL;\r\n}\r\nif (tplg->pass == hdr->type)\r\ndev_dbg(tplg->dev,\r\n"ASoC: Got 0x%x bytes of type %d version %d vendor %d at pass %d\n",\r\nhdr->payload_size, hdr->type, hdr->version,\r\nhdr->vendor_type, tplg->pass);\r\nreturn 1;\r\n}\r\nstatic int soc_tplg_load_header(struct soc_tplg *tplg,\r\nstruct snd_soc_tplg_hdr *hdr)\r\n{\r\ntplg->pos = tplg->hdr_pos + sizeof(struct snd_soc_tplg_hdr);\r\nif (hdr->index != tplg->req_index &&\r\nhdr->index != SND_SOC_TPLG_INDEX_ALL)\r\nreturn 0;\r\ntplg->index = hdr->index;\r\nswitch (hdr->type) {\r\ncase SND_SOC_TPLG_TYPE_MIXER:\r\ncase SND_SOC_TPLG_TYPE_ENUM:\r\ncase SND_SOC_TPLG_TYPE_BYTES:\r\nreturn soc_tplg_kcontrol_elems_load(tplg, hdr);\r\ncase SND_SOC_TPLG_TYPE_DAPM_GRAPH:\r\nreturn soc_tplg_dapm_graph_elems_load(tplg, hdr);\r\ncase SND_SOC_TPLG_TYPE_DAPM_WIDGET:\r\nreturn soc_tplg_dapm_widget_elems_load(tplg, hdr);\r\ncase SND_SOC_TPLG_TYPE_PCM:\r\nreturn soc_tplg_pcm_elems_load(tplg, hdr);\r\ncase SND_SOC_TPLG_TYPE_MANIFEST:\r\nreturn soc_tplg_manifest_load(tplg, hdr);\r\ndefault:\r\nreturn soc_tplg_vendor_load(tplg, hdr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_tplg_process_headers(struct soc_tplg *tplg)\r\n{\r\nstruct snd_soc_tplg_hdr *hdr;\r\nint ret;\r\ntplg->pass = SOC_TPLG_PASS_START;\r\nwhile (tplg->pass <= SOC_TPLG_PASS_END) {\r\ntplg->hdr_pos = tplg->fw->data;\r\nhdr = (struct snd_soc_tplg_hdr *)tplg->hdr_pos;\r\nwhile (!soc_tplg_is_eof(tplg)) {\r\nret = soc_valid_header(tplg, hdr);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret == 0)\r\nbreak;\r\nret = soc_tplg_load_header(tplg, hdr);\r\nif (ret < 0)\r\nreturn ret;\r\ntplg->hdr_pos += hdr->payload_size +\r\nsizeof(struct snd_soc_tplg_hdr);\r\nhdr = (struct snd_soc_tplg_hdr *)tplg->hdr_pos;\r\n}\r\ntplg->pass++;\r\n}\r\nret = soc_tplg_dapm_complete(tplg);\r\nif (ret < 0)\r\ndev_err(tplg->dev,\r\n"ASoC: failed to initialise DAPM from Firmware\n");\r\nreturn ret;\r\n}\r\nstatic int soc_tplg_load(struct soc_tplg *tplg)\r\n{\r\nint ret;\r\nret = soc_tplg_process_headers(tplg);\r\nif (ret == 0)\r\nsoc_tplg_complete(tplg);\r\nreturn ret;\r\n}\r\nint snd_soc_tplg_component_load(struct snd_soc_component *comp,\r\nstruct snd_soc_tplg_ops *ops, const struct firmware *fw, u32 id)\r\n{\r\nstruct soc_tplg tplg;\r\nmemset(&tplg, 0, sizeof(tplg));\r\ntplg.fw = fw;\r\ntplg.dev = comp->dev;\r\ntplg.comp = comp;\r\ntplg.ops = ops;\r\ntplg.req_index = id;\r\ntplg.io_ops = ops->io_ops;\r\ntplg.io_ops_count = ops->io_ops_count;\r\ntplg.bytes_ext_ops = ops->bytes_ext_ops;\r\ntplg.bytes_ext_ops_count = ops->bytes_ext_ops_count;\r\nreturn soc_tplg_load(&tplg);\r\n}\r\nvoid snd_soc_tplg_widget_remove(struct snd_soc_dapm_widget *w)\r\n{\r\nif (w->dobj.type != SND_SOC_DOBJ_WIDGET)\r\nreturn;\r\nremove_widget(w->dapm->component, &w->dobj, SOC_TPLG_PASS_WIDGET);\r\n}\r\nvoid snd_soc_tplg_widget_remove_all(struct snd_soc_dapm_context *dapm,\r\nu32 index)\r\n{\r\nstruct snd_soc_dapm_widget *w, *next_w;\r\nlist_for_each_entry_safe(w, next_w, &dapm->card->widgets, list) {\r\nif (w->dobj.type != SND_SOC_DOBJ_WIDGET || w->dapm != dapm)\r\ncontinue;\r\nif (w->dobj.index != index &&\r\nw->dobj.index != SND_SOC_TPLG_INDEX_ALL)\r\ncontinue;\r\nsnd_soc_tplg_widget_remove(w);\r\nsnd_soc_dapm_free_widget(w);\r\n}\r\nsnd_soc_dapm_reset_cache(dapm);\r\n}\r\nint snd_soc_tplg_component_remove(struct snd_soc_component *comp, u32 index)\r\n{\r\nstruct snd_soc_dobj *dobj, *next_dobj;\r\nint pass = SOC_TPLG_PASS_END;\r\nwhile (pass >= SOC_TPLG_PASS_START) {\r\nlist_for_each_entry_safe(dobj, next_dobj, &comp->dobj_list,\r\nlist) {\r\nif (dobj->index != index &&\r\ndobj->index != SND_SOC_TPLG_INDEX_ALL)\r\ncontinue;\r\nswitch (dobj->type) {\r\ncase SND_SOC_DOBJ_MIXER:\r\nremove_mixer(comp, dobj, pass);\r\nbreak;\r\ncase SND_SOC_DOBJ_ENUM:\r\nremove_enum(comp, dobj, pass);\r\nbreak;\r\ncase SND_SOC_DOBJ_BYTES:\r\nremove_bytes(comp, dobj, pass);\r\nbreak;\r\ncase SND_SOC_DOBJ_WIDGET:\r\nremove_widget(comp, dobj, pass);\r\nbreak;\r\ncase SND_SOC_DOBJ_PCM:\r\nremove_dai(comp, dobj, pass);\r\nbreak;\r\ncase SND_SOC_DOBJ_DAI_LINK:\r\nremove_link(comp, dobj, pass);\r\nbreak;\r\ndefault:\r\ndev_err(comp->dev, "ASoC: invalid component type %d for removal\n",\r\ndobj->type);\r\nbreak;\r\n}\r\n}\r\npass--;\r\n}\r\nreturn !list_empty(&comp->dobj_list);\r\n}
