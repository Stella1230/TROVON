static void mtk_color_config(struct mtk_ddp_comp *comp, unsigned int w,\r\nunsigned int h, unsigned int vrefresh)\r\n{\r\nwritel(w, comp->regs + DISP_COLOR_WIDTH);\r\nwritel(h, comp->regs + DISP_COLOR_HEIGHT);\r\n}\r\nstatic void mtk_color_start(struct mtk_ddp_comp *comp)\r\n{\r\nwritel(COLOR_BYPASS_ALL | COLOR_SEQ_SEL,\r\ncomp->regs + DISP_COLOR_CFG_MAIN);\r\nwritel(0x1, comp->regs + DISP_COLOR_START);\r\n}\r\nstatic void mtk_od_config(struct mtk_ddp_comp *comp, unsigned int w,\r\nunsigned int h, unsigned int vrefresh)\r\n{\r\nwritel(w << 16 | h, comp->regs + DISP_OD_SIZE);\r\n}\r\nstatic void mtk_od_start(struct mtk_ddp_comp *comp)\r\n{\r\nwritel(OD_RELAY_MODE, comp->regs + DISP_OD_CFG);\r\nwritel(1, comp->regs + DISP_OD_EN);\r\n}\r\nstatic void mtk_ufoe_start(struct mtk_ddp_comp *comp)\r\n{\r\nwritel(UFO_BYPASS, comp->regs + DISP_REG_UFO_START);\r\n}\r\nint mtk_ddp_comp_get_id(struct device_node *node,\r\nenum mtk_ddp_comp_type comp_type)\r\n{\r\nint id = of_alias_get_id(node, mtk_ddp_comp_stem[comp_type]);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mtk_ddp_matches); i++) {\r\nif (comp_type == mtk_ddp_matches[i].type &&\r\n(id < 0 || id == mtk_ddp_matches[i].alias_id))\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint mtk_ddp_comp_init(struct device *dev, struct device_node *node,\r\nstruct mtk_ddp_comp *comp, enum mtk_ddp_comp_id comp_id,\r\nconst struct mtk_ddp_comp_funcs *funcs)\r\n{\r\nenum mtk_ddp_comp_type type;\r\nstruct device_node *larb_node;\r\nstruct platform_device *larb_pdev;\r\nif (comp_id < 0 || comp_id >= DDP_COMPONENT_ID_MAX)\r\nreturn -EINVAL;\r\ncomp->id = comp_id;\r\ncomp->funcs = funcs ?: mtk_ddp_matches[comp_id].funcs;\r\nif (comp_id == DDP_COMPONENT_DPI0 ||\r\ncomp_id == DDP_COMPONENT_DSI0 ||\r\ncomp_id == DDP_COMPONENT_PWM0) {\r\ncomp->regs = NULL;\r\ncomp->clk = NULL;\r\ncomp->irq = 0;\r\nreturn 0;\r\n}\r\ncomp->regs = of_iomap(node, 0);\r\ncomp->irq = of_irq_get(node, 0);\r\ncomp->clk = of_clk_get(node, 0);\r\nif (IS_ERR(comp->clk))\r\ncomp->clk = NULL;\r\ntype = mtk_ddp_matches[comp_id].type;\r\ncomp->larb_dev = NULL;\r\nif (type != MTK_DISP_OVL &&\r\ntype != MTK_DISP_RDMA &&\r\ntype != MTK_DISP_WDMA)\r\nreturn 0;\r\nlarb_node = of_parse_phandle(node, "mediatek,larb", 0);\r\nif (!larb_node) {\r\ndev_err(dev,\r\n"Missing mediadek,larb phandle in %s node\n",\r\nnode->full_name);\r\nreturn -EINVAL;\r\n}\r\nlarb_pdev = of_find_device_by_node(larb_node);\r\nif (!larb_pdev) {\r\ndev_warn(dev, "Waiting for larb device %s\n",\r\nlarb_node->full_name);\r\nof_node_put(larb_node);\r\nreturn -EPROBE_DEFER;\r\n}\r\nof_node_put(larb_node);\r\ncomp->larb_dev = &larb_pdev->dev;\r\nreturn 0;\r\n}\r\nint mtk_ddp_comp_register(struct drm_device *drm, struct mtk_ddp_comp *comp)\r\n{\r\nstruct mtk_drm_private *private = drm->dev_private;\r\nif (private->ddp_comp[comp->id])\r\nreturn -EBUSY;\r\nprivate->ddp_comp[comp->id] = comp;\r\nreturn 0;\r\n}\r\nvoid mtk_ddp_comp_unregister(struct drm_device *drm, struct mtk_ddp_comp *comp)\r\n{\r\nstruct mtk_drm_private *private = drm->dev_private;\r\nprivate->ddp_comp[comp->id] = NULL;\r\n}
