static bool rockchip_pmu_domain_is_idle(struct rockchip_pm_domain *pd)\r\n{\r\nstruct rockchip_pmu *pmu = pd->pmu;\r\nconst struct rockchip_domain_info *pd_info = pd->info;\r\nunsigned int val;\r\nregmap_read(pmu->regmap, pmu->info->idle_offset, &val);\r\nreturn (val & pd_info->idle_mask) == pd_info->idle_mask;\r\n}\r\nstatic int rockchip_pmu_set_idle_request(struct rockchip_pm_domain *pd,\r\nbool idle)\r\n{\r\nconst struct rockchip_domain_info *pd_info = pd->info;\r\nstruct rockchip_pmu *pmu = pd->pmu;\r\nunsigned int val;\r\nif (pd_info->req_mask == 0)\r\nreturn 0;\r\nregmap_update_bits(pmu->regmap, pmu->info->req_offset,\r\npd_info->req_mask, idle ? -1U : 0);\r\ndsb(sy);\r\ndo {\r\nregmap_read(pmu->regmap, pmu->info->ack_offset, &val);\r\n} while ((val & pd_info->ack_mask) != (idle ? pd_info->ack_mask : 0));\r\nwhile (rockchip_pmu_domain_is_idle(pd) != idle)\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic int rockchip_pmu_save_qos(struct rockchip_pm_domain *pd)\r\n{\r\nint i;\r\nfor (i = 0; i < pd->num_qos; i++) {\r\nregmap_read(pd->qos_regmap[i],\r\nQOS_PRIORITY,\r\n&pd->qos_save_regs[0][i]);\r\nregmap_read(pd->qos_regmap[i],\r\nQOS_MODE,\r\n&pd->qos_save_regs[1][i]);\r\nregmap_read(pd->qos_regmap[i],\r\nQOS_BANDWIDTH,\r\n&pd->qos_save_regs[2][i]);\r\nregmap_read(pd->qos_regmap[i],\r\nQOS_SATURATION,\r\n&pd->qos_save_regs[3][i]);\r\nregmap_read(pd->qos_regmap[i],\r\nQOS_EXTCONTROL,\r\n&pd->qos_save_regs[4][i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_pmu_restore_qos(struct rockchip_pm_domain *pd)\r\n{\r\nint i;\r\nfor (i = 0; i < pd->num_qos; i++) {\r\nregmap_write(pd->qos_regmap[i],\r\nQOS_PRIORITY,\r\npd->qos_save_regs[0][i]);\r\nregmap_write(pd->qos_regmap[i],\r\nQOS_MODE,\r\npd->qos_save_regs[1][i]);\r\nregmap_write(pd->qos_regmap[i],\r\nQOS_BANDWIDTH,\r\npd->qos_save_regs[2][i]);\r\nregmap_write(pd->qos_regmap[i],\r\nQOS_SATURATION,\r\npd->qos_save_regs[3][i]);\r\nregmap_write(pd->qos_regmap[i],\r\nQOS_EXTCONTROL,\r\npd->qos_save_regs[4][i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool rockchip_pmu_domain_is_on(struct rockchip_pm_domain *pd)\r\n{\r\nstruct rockchip_pmu *pmu = pd->pmu;\r\nunsigned int val;\r\nif (pd->info->status_mask == 0)\r\nreturn !rockchip_pmu_domain_is_idle(pd);\r\nregmap_read(pmu->regmap, pmu->info->status_offset, &val);\r\nreturn !(val & pd->info->status_mask);\r\n}\r\nstatic void rockchip_do_pmu_set_power_domain(struct rockchip_pm_domain *pd,\r\nbool on)\r\n{\r\nstruct rockchip_pmu *pmu = pd->pmu;\r\nif (pd->info->pwr_mask == 0)\r\nreturn;\r\nregmap_update_bits(pmu->regmap, pmu->info->pwr_offset,\r\npd->info->pwr_mask, on ? 0 : -1U);\r\ndsb(sy);\r\nwhile (rockchip_pmu_domain_is_on(pd) != on)\r\ncpu_relax();\r\n}\r\nstatic int rockchip_pd_power(struct rockchip_pm_domain *pd, bool power_on)\r\n{\r\nint i;\r\nmutex_lock(&pd->pmu->mutex);\r\nif (rockchip_pmu_domain_is_on(pd) != power_on) {\r\nfor (i = 0; i < pd->num_clks; i++)\r\nclk_enable(pd->clks[i]);\r\nif (!power_on) {\r\nrockchip_pmu_save_qos(pd);\r\nrockchip_pmu_set_idle_request(pd, true);\r\n}\r\nrockchip_do_pmu_set_power_domain(pd, power_on);\r\nif (power_on) {\r\nrockchip_pmu_set_idle_request(pd, false);\r\nrockchip_pmu_restore_qos(pd);\r\n}\r\nfor (i = pd->num_clks - 1; i >= 0; i--)\r\nclk_disable(pd->clks[i]);\r\n}\r\nmutex_unlock(&pd->pmu->mutex);\r\nreturn 0;\r\n}\r\nstatic int rockchip_pd_power_on(struct generic_pm_domain *domain)\r\n{\r\nstruct rockchip_pm_domain *pd = to_rockchip_pd(domain);\r\nreturn rockchip_pd_power(pd, true);\r\n}\r\nstatic int rockchip_pd_power_off(struct generic_pm_domain *domain)\r\n{\r\nstruct rockchip_pm_domain *pd = to_rockchip_pd(domain);\r\nreturn rockchip_pd_power(pd, false);\r\n}\r\nstatic int rockchip_pd_attach_dev(struct generic_pm_domain *genpd,\r\nstruct device *dev)\r\n{\r\nstruct clk *clk;\r\nint i;\r\nint error;\r\ndev_dbg(dev, "attaching to power domain '%s'\n", genpd->name);\r\nerror = pm_clk_create(dev);\r\nif (error) {\r\ndev_err(dev, "pm_clk_create failed %d\n", error);\r\nreturn error;\r\n}\r\ni = 0;\r\nwhile ((clk = of_clk_get(dev->of_node, i++)) && !IS_ERR(clk)) {\r\ndev_dbg(dev, "adding clock '%pC' to list of PM clocks\n", clk);\r\nerror = pm_clk_add_clk(dev, clk);\r\nif (error) {\r\ndev_err(dev, "pm_clk_add_clk failed %d\n", error);\r\nclk_put(clk);\r\npm_clk_destroy(dev);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rockchip_pd_detach_dev(struct generic_pm_domain *genpd,\r\nstruct device *dev)\r\n{\r\ndev_dbg(dev, "detaching from power domain '%s'\n", genpd->name);\r\npm_clk_destroy(dev);\r\n}\r\nstatic int rockchip_pm_add_one_domain(struct rockchip_pmu *pmu,\r\nstruct device_node *node)\r\n{\r\nconst struct rockchip_domain_info *pd_info;\r\nstruct rockchip_pm_domain *pd;\r\nstruct device_node *qos_node;\r\nstruct clk *clk;\r\nint clk_cnt;\r\nint i, j;\r\nu32 id;\r\nint error;\r\nerror = of_property_read_u32(node, "reg", &id);\r\nif (error) {\r\ndev_err(pmu->dev,\r\n"%s: failed to retrieve domain id (reg): %d\n",\r\nnode->name, error);\r\nreturn -EINVAL;\r\n}\r\nif (id >= pmu->info->num_domains) {\r\ndev_err(pmu->dev, "%s: invalid domain id %d\n",\r\nnode->name, id);\r\nreturn -EINVAL;\r\n}\r\npd_info = &pmu->info->domain_info[id];\r\nif (!pd_info) {\r\ndev_err(pmu->dev, "%s: undefined domain id %d\n",\r\nnode->name, id);\r\nreturn -EINVAL;\r\n}\r\nclk_cnt = of_count_phandle_with_args(node, "clocks", "#clock-cells");\r\npd = devm_kzalloc(pmu->dev,\r\nsizeof(*pd) + clk_cnt * sizeof(pd->clks[0]),\r\nGFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\npd->info = pd_info;\r\npd->pmu = pmu;\r\nfor (i = 0; i < clk_cnt; i++) {\r\nclk = of_clk_get(node, i);\r\nif (IS_ERR(clk)) {\r\nerror = PTR_ERR(clk);\r\ndev_err(pmu->dev,\r\n"%s: failed to get clk at index %d: %d\n",\r\nnode->name, i, error);\r\ngoto err_out;\r\n}\r\nerror = clk_prepare(clk);\r\nif (error) {\r\ndev_err(pmu->dev,\r\n"%s: failed to prepare clk %pC (index %d): %d\n",\r\nnode->name, clk, i, error);\r\nclk_put(clk);\r\ngoto err_out;\r\n}\r\npd->clks[pd->num_clks++] = clk;\r\ndev_dbg(pmu->dev, "added clock '%pC' to domain '%s'\n",\r\nclk, node->name);\r\n}\r\npd->num_qos = of_count_phandle_with_args(node, "pm_qos",\r\nNULL);\r\nif (pd->num_qos > 0) {\r\npd->qos_regmap = devm_kcalloc(pmu->dev, pd->num_qos,\r\nsizeof(*pd->qos_regmap),\r\nGFP_KERNEL);\r\nif (!pd->qos_regmap) {\r\nerror = -ENOMEM;\r\ngoto err_out;\r\n}\r\nfor (j = 0; j < MAX_QOS_REGS_NUM; j++) {\r\npd->qos_save_regs[j] = devm_kcalloc(pmu->dev,\r\npd->num_qos,\r\nsizeof(u32),\r\nGFP_KERNEL);\r\nif (!pd->qos_save_regs[j]) {\r\nerror = -ENOMEM;\r\ngoto err_out;\r\n}\r\n}\r\nfor (j = 0; j < pd->num_qos; j++) {\r\nqos_node = of_parse_phandle(node, "pm_qos", j);\r\nif (!qos_node) {\r\nerror = -ENODEV;\r\ngoto err_out;\r\n}\r\npd->qos_regmap[j] = syscon_node_to_regmap(qos_node);\r\nif (IS_ERR(pd->qos_regmap[j])) {\r\nerror = -ENODEV;\r\nof_node_put(qos_node);\r\ngoto err_out;\r\n}\r\nof_node_put(qos_node);\r\n}\r\n}\r\nerror = rockchip_pd_power(pd, true);\r\nif (error) {\r\ndev_err(pmu->dev,\r\n"failed to power on domain '%s': %d\n",\r\nnode->name, error);\r\ngoto err_out;\r\n}\r\npd->genpd.name = node->name;\r\npd->genpd.power_off = rockchip_pd_power_off;\r\npd->genpd.power_on = rockchip_pd_power_on;\r\npd->genpd.attach_dev = rockchip_pd_attach_dev;\r\npd->genpd.detach_dev = rockchip_pd_detach_dev;\r\npd->genpd.flags = GENPD_FLAG_PM_CLK;\r\npm_genpd_init(&pd->genpd, NULL, false);\r\npmu->genpd_data.domains[id] = &pd->genpd;\r\nreturn 0;\r\nerr_out:\r\nwhile (--i >= 0) {\r\nclk_unprepare(pd->clks[i]);\r\nclk_put(pd->clks[i]);\r\n}\r\nreturn error;\r\n}\r\nstatic void rockchip_pm_remove_one_domain(struct rockchip_pm_domain *pd)\r\n{\r\nint i;\r\nfor (i = 0; i < pd->num_clks; i++) {\r\nclk_unprepare(pd->clks[i]);\r\nclk_put(pd->clks[i]);\r\n}\r\nmutex_lock(&pd->pmu->mutex);\r\npd->num_clks = 0;\r\nmutex_unlock(&pd->pmu->mutex);\r\n}\r\nstatic void rockchip_pm_domain_cleanup(struct rockchip_pmu *pmu)\r\n{\r\nstruct generic_pm_domain *genpd;\r\nstruct rockchip_pm_domain *pd;\r\nint i;\r\nfor (i = 0; i < pmu->genpd_data.num_domains; i++) {\r\ngenpd = pmu->genpd_data.domains[i];\r\nif (genpd) {\r\npd = to_rockchip_pd(genpd);\r\nrockchip_pm_remove_one_domain(pd);\r\n}\r\n}\r\n}\r\nstatic void rockchip_configure_pd_cnt(struct rockchip_pmu *pmu,\r\nu32 domain_reg_offset,\r\nunsigned int count)\r\n{\r\nregmap_write(pmu->regmap, domain_reg_offset, count);\r\nregmap_write(pmu->regmap, domain_reg_offset + 4, count);\r\n}\r\nstatic int rockchip_pm_add_subdomain(struct rockchip_pmu *pmu,\r\nstruct device_node *parent)\r\n{\r\nstruct device_node *np;\r\nstruct generic_pm_domain *child_domain, *parent_domain;\r\nint error;\r\nfor_each_child_of_node(parent, np) {\r\nu32 idx;\r\nerror = of_property_read_u32(parent, "reg", &idx);\r\nif (error) {\r\ndev_err(pmu->dev,\r\n"%s: failed to retrieve domain id (reg): %d\n",\r\nparent->name, error);\r\ngoto err_out;\r\n}\r\nparent_domain = pmu->genpd_data.domains[idx];\r\nerror = rockchip_pm_add_one_domain(pmu, np);\r\nif (error) {\r\ndev_err(pmu->dev, "failed to handle node %s: %d\n",\r\nnp->name, error);\r\ngoto err_out;\r\n}\r\nerror = of_property_read_u32(np, "reg", &idx);\r\nif (error) {\r\ndev_err(pmu->dev,\r\n"%s: failed to retrieve domain id (reg): %d\n",\r\nnp->name, error);\r\ngoto err_out;\r\n}\r\nchild_domain = pmu->genpd_data.domains[idx];\r\nerror = pm_genpd_add_subdomain(parent_domain, child_domain);\r\nif (error) {\r\ndev_err(pmu->dev, "%s failed to add subdomain %s: %d\n",\r\nparent_domain->name, child_domain->name, error);\r\ngoto err_out;\r\n} else {\r\ndev_dbg(pmu->dev, "%s add subdomain: %s\n",\r\nparent_domain->name, child_domain->name);\r\n}\r\nrockchip_pm_add_subdomain(pmu, np);\r\n}\r\nreturn 0;\r\nerr_out:\r\nof_node_put(np);\r\nreturn error;\r\n}\r\nstatic int rockchip_pm_domain_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *node;\r\nstruct device *parent;\r\nstruct rockchip_pmu *pmu;\r\nconst struct of_device_id *match;\r\nconst struct rockchip_pmu_info *pmu_info;\r\nint error;\r\nif (!np) {\r\ndev_err(dev, "device tree node not found\n");\r\nreturn -ENODEV;\r\n}\r\nmatch = of_match_device(dev->driver->of_match_table, dev);\r\nif (!match || !match->data) {\r\ndev_err(dev, "missing pmu data\n");\r\nreturn -EINVAL;\r\n}\r\npmu_info = match->data;\r\npmu = devm_kzalloc(dev,\r\nsizeof(*pmu) +\r\npmu_info->num_domains * sizeof(pmu->domains[0]),\r\nGFP_KERNEL);\r\nif (!pmu)\r\nreturn -ENOMEM;\r\npmu->dev = &pdev->dev;\r\nmutex_init(&pmu->mutex);\r\npmu->info = pmu_info;\r\npmu->genpd_data.domains = pmu->domains;\r\npmu->genpd_data.num_domains = pmu_info->num_domains;\r\nparent = dev->parent;\r\nif (!parent) {\r\ndev_err(dev, "no parent for syscon devices\n");\r\nreturn -ENODEV;\r\n}\r\npmu->regmap = syscon_node_to_regmap(parent->of_node);\r\nif (IS_ERR(pmu->regmap)) {\r\ndev_err(dev, "no regmap available\n");\r\nreturn PTR_ERR(pmu->regmap);\r\n}\r\nrockchip_configure_pd_cnt(pmu, pmu_info->core_pwrcnt_offset,\r\npmu_info->core_power_transition_time);\r\nrockchip_configure_pd_cnt(pmu, pmu_info->gpu_pwrcnt_offset,\r\npmu_info->gpu_power_transition_time);\r\nerror = -ENODEV;\r\nfor_each_available_child_of_node(np, node) {\r\nerror = rockchip_pm_add_one_domain(pmu, node);\r\nif (error) {\r\ndev_err(dev, "failed to handle node %s: %d\n",\r\nnode->name, error);\r\nof_node_put(node);\r\ngoto err_out;\r\n}\r\nerror = rockchip_pm_add_subdomain(pmu, node);\r\nif (error < 0) {\r\ndev_err(dev, "failed to handle subdomain node %s: %d\n",\r\nnode->name, error);\r\nof_node_put(node);\r\ngoto err_out;\r\n}\r\n}\r\nif (error) {\r\ndev_dbg(dev, "no power domains defined\n");\r\ngoto err_out;\r\n}\r\nof_genpd_add_provider_onecell(np, &pmu->genpd_data);\r\nreturn 0;\r\nerr_out:\r\nrockchip_pm_domain_cleanup(pmu);\r\nreturn error;\r\n}\r\nstatic int __init rockchip_pm_domain_drv_register(void)\r\n{\r\nreturn platform_driver_register(&rockchip_pm_domain_driver);\r\n}
