static void copy_from_cb(void *dst, const void *base, unsigned offset,\r\nunsigned len, unsigned limit)\r\n{\r\nunsigned copy = len;\r\nif ((copy + offset) > limit)\r\ncopy = limit - offset;\r\nmemcpy(dst, base + offset, copy);\r\nlen -= copy;\r\nif (len)\r\nmemcpy(dst + copy, base, len);\r\n}\r\nint dlm_process_incoming_buffer(int nodeid, const void *base,\r\nunsigned offset, unsigned len, unsigned limit)\r\n{\r\nunion {\r\nunsigned char __buf[DLM_INBUF_LEN];\r\nunion dlm_packet p;\r\n} __tmp;\r\nunion dlm_packet *p = &__tmp.p;\r\nint ret = 0;\r\nint err = 0;\r\nuint16_t msglen;\r\nuint32_t lockspace;\r\nwhile (len > sizeof(struct dlm_header)) {\r\ncopy_from_cb(p, base, offset, sizeof(struct dlm_header),\r\nlimit);\r\nmsglen = le16_to_cpu(p->header.h_length);\r\nlockspace = p->header.h_lockspace;\r\nerr = -EINVAL;\r\nif (msglen < sizeof(struct dlm_header))\r\nbreak;\r\nif (p->header.h_cmd == DLM_MSG) {\r\nif (msglen < sizeof(struct dlm_message))\r\nbreak;\r\n} else {\r\nif (msglen < sizeof(struct dlm_rcom))\r\nbreak;\r\n}\r\nerr = -E2BIG;\r\nif (msglen > dlm_config.ci_buffer_size) {\r\nlog_print("message size %d from %d too big, buf len %d",\r\nmsglen, nodeid, len);\r\nbreak;\r\n}\r\nerr = 0;\r\nif (msglen > len)\r\nbreak;\r\nif (msglen > sizeof(__tmp) && p == &__tmp.p) {\r\np = kmalloc(dlm_config.ci_buffer_size, GFP_NOFS);\r\nif (p == NULL)\r\nreturn ret;\r\n}\r\ncopy_from_cb(p, base, offset, msglen, limit);\r\nBUG_ON(lockspace != p->header.h_lockspace);\r\nret += msglen;\r\noffset += msglen;\r\noffset &= (limit - 1);\r\nlen -= msglen;\r\ndlm_receive_buffer(p, nodeid);\r\n}\r\nif (p != &__tmp.p)\r\nkfree(p);\r\nreturn err ? err : ret;\r\n}
