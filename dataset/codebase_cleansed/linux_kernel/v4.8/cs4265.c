static bool cs4265_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS4265_CHIP_ID ... CS4265_SPDIF_CTL2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs4265_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS4265_INT_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int cs4265_get_clk_index(int mclk, int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(clk_map_table); i++) {\r\nif (clk_map_table[i].rate == rate &&\r\nclk_map_table[i].mclk == mclk)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cs4265_set_sysclk(struct snd_soc_dai *codec_dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs4265_private *cs4265 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nif (clk_id != 0) {\r\ndev_err(codec->dev, "Invalid clk_id %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(clk_map_table); i++) {\r\nif (clk_map_table[i].mclk == freq) {\r\ncs4265->sysclk = freq;\r\nreturn 0;\r\n}\r\n}\r\ncs4265->sysclk = 0;\r\ndev_err(codec->dev, "Invalid freq parameter %d\n", freq);\r\nreturn -EINVAL;\r\n}\r\nstatic int cs4265_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs4265_private *cs4265 = snd_soc_codec_get_drvdata(codec);\r\nu8 iface = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nsnd_soc_update_bits(codec, CS4265_ADC_CTL,\r\nCS4265_ADC_MASTER,\r\nCS4265_ADC_MASTER);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_update_bits(codec, CS4265_ADC_CTL,\r\nCS4265_ADC_MASTER,\r\n0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= SND_SOC_DAIFMT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\niface |= SND_SOC_DAIFMT_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= SND_SOC_DAIFMT_LEFT_J;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncs4265->format = iface;\r\nreturn 0;\r\n}\r\nstatic int cs4265_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (mute) {\r\nsnd_soc_update_bits(codec, CS4265_DAC_CTL,\r\nCS4265_DAC_CTL_MUTE,\r\nCS4265_DAC_CTL_MUTE);\r\nsnd_soc_update_bits(codec, CS4265_SPDIF_CTL2,\r\nCS4265_SPDIF_CTL2_MUTE,\r\nCS4265_SPDIF_CTL2_MUTE);\r\n} else {\r\nsnd_soc_update_bits(codec, CS4265_DAC_CTL,\r\nCS4265_DAC_CTL_MUTE,\r\n0);\r\nsnd_soc_update_bits(codec, CS4265_SPDIF_CTL2,\r\nCS4265_SPDIF_CTL2_MUTE,\r\n0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs4265_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs4265_private *cs4265 = snd_soc_codec_get_drvdata(codec);\r\nint index;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&\r\n((cs4265->format & SND_SOC_DAIFMT_FORMAT_MASK)\r\n== SND_SOC_DAIFMT_RIGHT_J))\r\nreturn -EINVAL;\r\nindex = cs4265_get_clk_index(cs4265->sysclk, params_rate(params));\r\nif (index >= 0) {\r\nsnd_soc_update_bits(codec, CS4265_ADC_CTL,\r\nCS4265_ADC_FM, clk_map_table[index].fm_mode << 6);\r\nsnd_soc_update_bits(codec, CS4265_MCLK_FREQ,\r\nCS4265_MCLK_FREQ_MASK,\r\nclk_map_table[index].mclkdiv << 4);\r\n} else {\r\ndev_err(codec->dev, "can't get correct mclk\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (cs4265->format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nsnd_soc_update_bits(codec, CS4265_DAC_CTL,\r\nCS4265_DAC_CTL_DIF, (1 << 4));\r\nsnd_soc_update_bits(codec, CS4265_ADC_CTL,\r\nCS4265_ADC_DIF, (1 << 4));\r\nsnd_soc_update_bits(codec, CS4265_SPDIF_CTL2,\r\nCS4265_SPDIF_CTL2_DIF, (1 << 6));\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nif (params_width(params) == 16) {\r\nsnd_soc_update_bits(codec, CS4265_DAC_CTL,\r\nCS4265_DAC_CTL_DIF, (2 << 4));\r\nsnd_soc_update_bits(codec, CS4265_SPDIF_CTL2,\r\nCS4265_SPDIF_CTL2_DIF, (2 << 6));\r\n} else {\r\nsnd_soc_update_bits(codec, CS4265_DAC_CTL,\r\nCS4265_DAC_CTL_DIF, (3 << 4));\r\nsnd_soc_update_bits(codec, CS4265_SPDIF_CTL2,\r\nCS4265_SPDIF_CTL2_DIF, (3 << 6));\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nsnd_soc_update_bits(codec, CS4265_DAC_CTL,\r\nCS4265_DAC_CTL_DIF, 0);\r\nsnd_soc_update_bits(codec, CS4265_ADC_CTL,\r\nCS4265_ADC_DIF, 0);\r\nsnd_soc_update_bits(codec, CS4265_SPDIF_CTL2,\r\nCS4265_SPDIF_CTL2_DIF, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs4265_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, CS4265_PWRCTL,\r\nCS4265_PWRCTL_PDN, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, CS4265_PWRCTL,\r\nCS4265_PWRCTL_PDN,\r\nCS4265_PWRCTL_PDN);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, CS4265_PWRCTL,\r\nCS4265_PWRCTL_PDN,\r\nCS4265_PWRCTL_PDN);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs4265_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs4265_private *cs4265;\r\nint ret = 0;\r\nunsigned int devid = 0;\r\nunsigned int reg;\r\ncs4265 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs4265_private),\r\nGFP_KERNEL);\r\nif (cs4265 == NULL)\r\nreturn -ENOMEM;\r\ncs4265->regmap = devm_regmap_init_i2c(i2c_client, &cs4265_regmap);\r\nif (IS_ERR(cs4265->regmap)) {\r\nret = PTR_ERR(cs4265->regmap);\r\ndev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ncs4265->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev,\r\n"reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(cs4265->reset_gpio))\r\nreturn PTR_ERR(cs4265->reset_gpio);\r\nif (cs4265->reset_gpio) {\r\nmdelay(1);\r\ngpiod_set_value_cansleep(cs4265->reset_gpio, 1);\r\n}\r\ni2c_set_clientdata(i2c_client, cs4265);\r\nret = regmap_read(cs4265->regmap, CS4265_CHIP_ID, &reg);\r\ndevid = reg & CS4265_CHIP_ID_MASK;\r\nif (devid != CS4265_CHIP_ID_VAL) {\r\nret = -ENODEV;\r\ndev_err(&i2c_client->dev,\r\n"CS4265 Device ID (%X). Expected %X\n",\r\ndevid, CS4265_CHIP_ID);\r\nreturn ret;\r\n}\r\ndev_info(&i2c_client->dev,\r\n"CS4265 Version %x\n",\r\nreg & CS4265_REV_ID_MASK);\r\nregmap_write(cs4265->regmap, CS4265_PWRCTL, 0x0F);\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_cs4265, cs4265_dai,\r\nARRAY_SIZE(cs4265_dai));\r\nreturn ret;\r\n}\r\nstatic int cs4265_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
