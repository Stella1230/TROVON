static int mlx4_status_to_errno(u8 status)\r\n{\r\nstatic const int trans_table[] = {\r\n[CMD_STAT_INTERNAL_ERR] = -EIO,\r\n[CMD_STAT_BAD_OP] = -EPERM,\r\n[CMD_STAT_BAD_PARAM] = -EINVAL,\r\n[CMD_STAT_BAD_SYS_STATE] = -ENXIO,\r\n[CMD_STAT_BAD_RESOURCE] = -EBADF,\r\n[CMD_STAT_RESOURCE_BUSY] = -EBUSY,\r\n[CMD_STAT_EXCEED_LIM] = -ENOMEM,\r\n[CMD_STAT_BAD_RES_STATE] = -EBADF,\r\n[CMD_STAT_BAD_INDEX] = -EBADF,\r\n[CMD_STAT_BAD_NVMEM] = -EFAULT,\r\n[CMD_STAT_ICM_ERROR] = -ENFILE,\r\n[CMD_STAT_BAD_QP_STATE] = -EINVAL,\r\n[CMD_STAT_BAD_SEG_PARAM] = -EFAULT,\r\n[CMD_STAT_REG_BOUND] = -EBUSY,\r\n[CMD_STAT_LAM_NOT_PRE] = -EAGAIN,\r\n[CMD_STAT_BAD_PKT] = -EINVAL,\r\n[CMD_STAT_BAD_SIZE] = -ENOMEM,\r\n[CMD_STAT_MULTI_FUNC_REQ] = -EACCES,\r\n};\r\nif (status >= ARRAY_SIZE(trans_table) ||\r\n(status != CMD_STAT_OK && trans_table[status] == 0))\r\nreturn -EIO;\r\nreturn trans_table[status];\r\n}\r\nstatic u8 mlx4_errno_to_status(int errno)\r\n{\r\nswitch (errno) {\r\ncase -EPERM:\r\nreturn CMD_STAT_BAD_OP;\r\ncase -EINVAL:\r\nreturn CMD_STAT_BAD_PARAM;\r\ncase -ENXIO:\r\nreturn CMD_STAT_BAD_SYS_STATE;\r\ncase -EBUSY:\r\nreturn CMD_STAT_RESOURCE_BUSY;\r\ncase -ENOMEM:\r\nreturn CMD_STAT_EXCEED_LIM;\r\ncase -ENFILE:\r\nreturn CMD_STAT_ICM_ERROR;\r\ndefault:\r\nreturn CMD_STAT_INTERNAL_ERR;\r\n}\r\n}\r\nstatic int mlx4_internal_err_ret_value(struct mlx4_dev *dev, u16 op,\r\nu8 op_modifier)\r\n{\r\nswitch (op) {\r\ncase MLX4_CMD_UNMAP_ICM:\r\ncase MLX4_CMD_UNMAP_ICM_AUX:\r\ncase MLX4_CMD_UNMAP_FA:\r\ncase MLX4_CMD_2RST_QP:\r\ncase MLX4_CMD_HW2SW_EQ:\r\ncase MLX4_CMD_HW2SW_CQ:\r\ncase MLX4_CMD_HW2SW_SRQ:\r\ncase MLX4_CMD_HW2SW_MPT:\r\ncase MLX4_CMD_CLOSE_HCA:\r\ncase MLX4_QP_FLOW_STEERING_DETACH:\r\ncase MLX4_CMD_FREE_RES:\r\ncase MLX4_CMD_CLOSE_PORT:\r\nreturn CMD_STAT_OK;\r\ncase MLX4_CMD_QP_ATTACH:\r\nif (op_modifier == 0)\r\nreturn CMD_STAT_OK;\r\nreturn mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\r\ndefault:\r\nreturn mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\r\n}\r\n}\r\nstatic int mlx4_closing_cmd_fatal_error(u16 op, u8 fw_status)\r\n{\r\nif (op == MLX4_CMD_CLOSE_HCA ||\r\nop == MLX4_CMD_HW2SW_EQ ||\r\nop == MLX4_CMD_HW2SW_CQ ||\r\nop == MLX4_CMD_2RST_QP ||\r\nop == MLX4_CMD_HW2SW_SRQ ||\r\nop == MLX4_CMD_SYNC_TPT ||\r\nop == MLX4_CMD_UNMAP_ICM ||\r\nop == MLX4_CMD_UNMAP_ICM_AUX ||\r\nop == MLX4_CMD_UNMAP_FA)\r\nreturn 1;\r\nif (op == MLX4_CMD_HW2SW_MPT && fw_status != CMD_STAT_REG_BOUND)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int mlx4_cmd_reset_flow(struct mlx4_dev *dev, u16 op, u8 op_modifier,\r\nint err)\r\n{\r\nif (mlx4_internal_err_reset) {\r\nmlx4_enter_error_state(dev->persist);\r\nerr = mlx4_internal_err_ret_value(dev, op, op_modifier);\r\n}\r\nreturn err;\r\n}\r\nstatic int comm_pending(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nu32 status = readl(&priv->mfunc.comm->slave_read);\r\nreturn (swab32(status) >> 31) != priv->cmd.comm_toggle;\r\n}\r\nstatic int mlx4_comm_cmd_post(struct mlx4_dev *dev, u8 cmd, u16 param)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nu32 val;\r\nmutex_lock(&dev->persist->device_state_mutex);\r\nif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR) {\r\nmutex_unlock(&dev->persist->device_state_mutex);\r\nreturn -EIO;\r\n}\r\npriv->cmd.comm_toggle ^= 1;\r\nval = param | (cmd << 16) | (priv->cmd.comm_toggle << 31);\r\n__raw_writel((__force u32) cpu_to_be32(val),\r\n&priv->mfunc.comm->slave_write);\r\nmmiowb();\r\nmutex_unlock(&dev->persist->device_state_mutex);\r\nreturn 0;\r\n}\r\nstatic int mlx4_comm_cmd_poll(struct mlx4_dev *dev, u8 cmd, u16 param,\r\nunsigned long timeout)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nunsigned long end;\r\nint err = 0;\r\nint ret_from_pending = 0;\r\nif (comm_pending(dev)) {\r\nmlx4_warn(dev, "Communication channel is not idle - my toggle is %d (cmd:0x%x)\n",\r\npriv->cmd.comm_toggle, cmd);\r\nreturn -EAGAIN;\r\n}\r\ndown(&priv->cmd.poll_sem);\r\nif (mlx4_comm_cmd_post(dev, cmd, param)) {\r\nerr = mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\r\ngoto out;\r\n}\r\nend = msecs_to_jiffies(timeout) + jiffies;\r\nwhile (comm_pending(dev) && time_before(jiffies, end))\r\ncond_resched();\r\nret_from_pending = comm_pending(dev);\r\nif (ret_from_pending) {\r\nif ((MLX4_COMM_CMD_RESET == cmd)) {\r\nerr = MLX4_DELAY_RESET_SLAVE;\r\ngoto out;\r\n} else {\r\nmlx4_warn(dev, "Communication channel command 0x%x timed out\n",\r\ncmd);\r\nerr = mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\r\n}\r\n}\r\nif (err)\r\nmlx4_enter_error_state(dev->persist);\r\nout:\r\nup(&priv->cmd.poll_sem);\r\nreturn err;\r\n}\r\nstatic int mlx4_comm_cmd_wait(struct mlx4_dev *dev, u8 vhcr_cmd,\r\nu16 param, u16 op, unsigned long timeout)\r\n{\r\nstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\r\nstruct mlx4_cmd_context *context;\r\nunsigned long end;\r\nint err = 0;\r\ndown(&cmd->event_sem);\r\nspin_lock(&cmd->context_lock);\r\nBUG_ON(cmd->free_head < 0);\r\ncontext = &cmd->context[cmd->free_head];\r\ncontext->token += cmd->token_mask + 1;\r\ncmd->free_head = context->next;\r\nspin_unlock(&cmd->context_lock);\r\nreinit_completion(&context->done);\r\nif (mlx4_comm_cmd_post(dev, vhcr_cmd, param)) {\r\nerr = mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\r\ngoto out;\r\n}\r\nif (!wait_for_completion_timeout(&context->done,\r\nmsecs_to_jiffies(timeout))) {\r\nmlx4_warn(dev, "communication channel command 0x%x (op=0x%x) timed out\n",\r\nvhcr_cmd, op);\r\ngoto out_reset;\r\n}\r\nerr = context->result;\r\nif (err && context->fw_status != CMD_STAT_MULTI_FUNC_REQ) {\r\nmlx4_err(dev, "command 0x%x failed: fw status = 0x%x\n",\r\nvhcr_cmd, context->fw_status);\r\nif (mlx4_closing_cmd_fatal_error(op, context->fw_status))\r\ngoto out_reset;\r\n}\r\nif (!(dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)) {\r\nend = msecs_to_jiffies(timeout) + jiffies;\r\nwhile (comm_pending(dev) && time_before(jiffies, end))\r\ncond_resched();\r\n}\r\ngoto out;\r\nout_reset:\r\nerr = mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\r\nmlx4_enter_error_state(dev->persist);\r\nout:\r\nspin_lock(&cmd->context_lock);\r\ncontext->next = cmd->free_head;\r\ncmd->free_head = context - cmd->context;\r\nspin_unlock(&cmd->context_lock);\r\nup(&cmd->event_sem);\r\nreturn err;\r\n}\r\nint mlx4_comm_cmd(struct mlx4_dev *dev, u8 cmd, u16 param,\r\nu16 op, unsigned long timeout)\r\n{\r\nif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)\r\nreturn mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\r\nif (mlx4_priv(dev)->cmd.use_events)\r\nreturn mlx4_comm_cmd_wait(dev, cmd, param, op, timeout);\r\nreturn mlx4_comm_cmd_poll(dev, cmd, param, timeout);\r\n}\r\nstatic int cmd_pending(struct mlx4_dev *dev)\r\n{\r\nu32 status;\r\nif (pci_channel_offline(dev->persist->pdev))\r\nreturn -EIO;\r\nstatus = readl(mlx4_priv(dev)->cmd.hcr + HCR_STATUS_OFFSET);\r\nreturn (status & swab32(1 << HCR_GO_BIT)) ||\r\n(mlx4_priv(dev)->cmd.toggle ==\r\n!!(status & swab32(1 << HCR_T_BIT)));\r\n}\r\nstatic int mlx4_cmd_post(struct mlx4_dev *dev, u64 in_param, u64 out_param,\r\nu32 in_modifier, u8 op_modifier, u16 op, u16 token,\r\nint event)\r\n{\r\nstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\r\nu32 __iomem *hcr = cmd->hcr;\r\nint ret = -EIO;\r\nunsigned long end;\r\nmutex_lock(&dev->persist->device_state_mutex);\r\nif (pci_channel_offline(dev->persist->pdev) ||\r\n(dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)) {\r\ngoto out;\r\n}\r\nend = jiffies;\r\nif (event)\r\nend += msecs_to_jiffies(GO_BIT_TIMEOUT_MSECS);\r\nwhile (cmd_pending(dev)) {\r\nif (pci_channel_offline(dev->persist->pdev)) {\r\ngoto out;\r\n}\r\nif (time_after_eq(jiffies, end)) {\r\nmlx4_err(dev, "%s:cmd_pending failed\n", __func__);\r\ngoto out;\r\n}\r\ncond_resched();\r\n}\r\n__raw_writel((__force u32) cpu_to_be32(in_param >> 32), hcr + 0);\r\n__raw_writel((__force u32) cpu_to_be32(in_param & 0xfffffffful), hcr + 1);\r\n__raw_writel((__force u32) cpu_to_be32(in_modifier), hcr + 2);\r\n__raw_writel((__force u32) cpu_to_be32(out_param >> 32), hcr + 3);\r\n__raw_writel((__force u32) cpu_to_be32(out_param & 0xfffffffful), hcr + 4);\r\n__raw_writel((__force u32) cpu_to_be32(token << 16), hcr + 5);\r\nwmb();\r\n__raw_writel((__force u32) cpu_to_be32((1 << HCR_GO_BIT) |\r\n(cmd->toggle << HCR_T_BIT) |\r\n(event ? (1 << HCR_E_BIT) : 0) |\r\n(op_modifier << HCR_OPMOD_SHIFT) |\r\nop), hcr + 6);\r\nmmiowb();\r\ncmd->toggle = cmd->toggle ^ 1;\r\nret = 0;\r\nout:\r\nif (ret)\r\nmlx4_warn(dev, "Could not post command 0x%x: ret=%d, in_param=0x%llx, in_mod=0x%x, op_mod=0x%x\n",\r\nop, ret, in_param, in_modifier, op_modifier);\r\nmutex_unlock(&dev->persist->device_state_mutex);\r\nreturn ret;\r\n}\r\nstatic int mlx4_slave_cmd(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\r\nint out_is_imm, u32 in_modifier, u8 op_modifier,\r\nu16 op, unsigned long timeout)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_vhcr_cmd *vhcr = priv->mfunc.vhcr;\r\nint ret;\r\nmutex_lock(&priv->cmd.slave_cmd_mutex);\r\nvhcr->in_param = cpu_to_be64(in_param);\r\nvhcr->out_param = out_param ? cpu_to_be64(*out_param) : 0;\r\nvhcr->in_modifier = cpu_to_be32(in_modifier);\r\nvhcr->opcode = cpu_to_be16((((u16) op_modifier) << 12) | (op & 0xfff));\r\nvhcr->token = cpu_to_be16(CMD_POLL_TOKEN);\r\nvhcr->status = 0;\r\nvhcr->flags = !!(priv->cmd.use_events) << 6;\r\nif (mlx4_is_master(dev)) {\r\nret = mlx4_master_process_vhcr(dev, dev->caps.function, vhcr);\r\nif (!ret) {\r\nif (out_is_imm) {\r\nif (out_param)\r\n*out_param =\r\nbe64_to_cpu(vhcr->out_param);\r\nelse {\r\nmlx4_err(dev, "response expected while output mailbox is NULL for command 0x%x\n",\r\nop);\r\nvhcr->status = CMD_STAT_BAD_PARAM;\r\n}\r\n}\r\nret = mlx4_status_to_errno(vhcr->status);\r\n}\r\nif (ret &&\r\ndev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)\r\nret = mlx4_internal_err_ret_value(dev, op, op_modifier);\r\n} else {\r\nret = mlx4_comm_cmd(dev, MLX4_COMM_CMD_VHCR_POST, 0, op,\r\nMLX4_COMM_TIME + timeout);\r\nif (!ret) {\r\nif (out_is_imm) {\r\nif (out_param)\r\n*out_param =\r\nbe64_to_cpu(vhcr->out_param);\r\nelse {\r\nmlx4_err(dev, "response expected while output mailbox is NULL for command 0x%x\n",\r\nop);\r\nvhcr->status = CMD_STAT_BAD_PARAM;\r\n}\r\n}\r\nret = mlx4_status_to_errno(vhcr->status);\r\n} else {\r\nif (dev->persist->state &\r\nMLX4_DEVICE_STATE_INTERNAL_ERROR)\r\nret = mlx4_internal_err_ret_value(dev, op,\r\nop_modifier);\r\nelse\r\nmlx4_err(dev, "failed execution of VHCR_POST command opcode 0x%x\n", op);\r\n}\r\n}\r\nmutex_unlock(&priv->cmd.slave_cmd_mutex);\r\nreturn ret;\r\n}\r\nstatic int mlx4_cmd_poll(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\r\nint out_is_imm, u32 in_modifier, u8 op_modifier,\r\nu16 op, unsigned long timeout)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nvoid __iomem *hcr = priv->cmd.hcr;\r\nint err = 0;\r\nunsigned long end;\r\nu32 stat;\r\ndown(&priv->cmd.poll_sem);\r\nif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR) {\r\nerr = mlx4_internal_err_ret_value(dev, op, op_modifier);\r\ngoto out;\r\n}\r\nif (out_is_imm && !out_param) {\r\nmlx4_err(dev, "response expected while output mailbox is NULL for command 0x%x\n",\r\nop);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = mlx4_cmd_post(dev, in_param, out_param ? *out_param : 0,\r\nin_modifier, op_modifier, op, CMD_POLL_TOKEN, 0);\r\nif (err)\r\ngoto out_reset;\r\nend = msecs_to_jiffies(timeout) + jiffies;\r\nwhile (cmd_pending(dev) && time_before(jiffies, end)) {\r\nif (pci_channel_offline(dev->persist->pdev)) {\r\nerr = -EIO;\r\ngoto out_reset;\r\n}\r\nif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR) {\r\nerr = mlx4_internal_err_ret_value(dev, op, op_modifier);\r\ngoto out;\r\n}\r\ncond_resched();\r\n}\r\nif (cmd_pending(dev)) {\r\nmlx4_warn(dev, "command 0x%x timed out (go bit not cleared)\n",\r\nop);\r\nerr = -EIO;\r\ngoto out_reset;\r\n}\r\nif (out_is_imm)\r\n*out_param =\r\n(u64) be32_to_cpu((__force __be32)\r\n__raw_readl(hcr + HCR_OUT_PARAM_OFFSET)) << 32 |\r\n(u64) be32_to_cpu((__force __be32)\r\n__raw_readl(hcr + HCR_OUT_PARAM_OFFSET + 4));\r\nstat = be32_to_cpu((__force __be32)\r\n__raw_readl(hcr + HCR_STATUS_OFFSET)) >> 24;\r\nerr = mlx4_status_to_errno(stat);\r\nif (err) {\r\nmlx4_err(dev, "command 0x%x failed: fw status = 0x%x\n",\r\nop, stat);\r\nif (mlx4_closing_cmd_fatal_error(op, stat))\r\ngoto out_reset;\r\ngoto out;\r\n}\r\nout_reset:\r\nif (err)\r\nerr = mlx4_cmd_reset_flow(dev, op, op_modifier, err);\r\nout:\r\nup(&priv->cmd.poll_sem);\r\nreturn err;\r\n}\r\nvoid mlx4_cmd_event(struct mlx4_dev *dev, u16 token, u8 status, u64 out_param)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_cmd_context *context =\r\n&priv->cmd.context[token & priv->cmd.token_mask];\r\nif (token != context->token)\r\nreturn;\r\ncontext->fw_status = status;\r\ncontext->result = mlx4_status_to_errno(status);\r\ncontext->out_param = out_param;\r\ncomplete(&context->done);\r\n}\r\nstatic int mlx4_cmd_wait(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\r\nint out_is_imm, u32 in_modifier, u8 op_modifier,\r\nu16 op, unsigned long timeout)\r\n{\r\nstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\r\nstruct mlx4_cmd_context *context;\r\nlong ret_wait;\r\nint err = 0;\r\ndown(&cmd->event_sem);\r\nspin_lock(&cmd->context_lock);\r\nBUG_ON(cmd->free_head < 0);\r\ncontext = &cmd->context[cmd->free_head];\r\ncontext->token += cmd->token_mask + 1;\r\ncmd->free_head = context->next;\r\nspin_unlock(&cmd->context_lock);\r\nif (out_is_imm && !out_param) {\r\nmlx4_err(dev, "response expected while output mailbox is NULL for command 0x%x\n",\r\nop);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nreinit_completion(&context->done);\r\nerr = mlx4_cmd_post(dev, in_param, out_param ? *out_param : 0,\r\nin_modifier, op_modifier, op, context->token, 1);\r\nif (err)\r\ngoto out_reset;\r\nif (op == MLX4_CMD_SENSE_PORT) {\r\nret_wait =\r\nwait_for_completion_interruptible_timeout(&context->done,\r\nmsecs_to_jiffies(timeout));\r\nif (ret_wait < 0) {\r\ncontext->fw_status = 0;\r\ncontext->out_param = 0;\r\ncontext->result = 0;\r\n}\r\n} else {\r\nret_wait = (long)wait_for_completion_timeout(&context->done,\r\nmsecs_to_jiffies(timeout));\r\n}\r\nif (!ret_wait) {\r\nmlx4_warn(dev, "command 0x%x timed out (go bit not cleared)\n",\r\nop);\r\nif (op == MLX4_CMD_NOP) {\r\nerr = -EBUSY;\r\ngoto out;\r\n} else {\r\nerr = -EIO;\r\ngoto out_reset;\r\n}\r\n}\r\nerr = context->result;\r\nif (err) {\r\nif (op == MLX4_CMD_SET_PORT &&\r\n(in_modifier == 1 || in_modifier == 2) &&\r\nop_modifier == MLX4_SET_PORT_IB_OPCODE &&\r\ncontext->fw_status == CMD_STAT_BAD_SIZE)\r\nmlx4_dbg(dev, "command 0x%x failed: fw status = 0x%x\n",\r\nop, context->fw_status);\r\nelse\r\nmlx4_err(dev, "command 0x%x failed: fw status = 0x%x\n",\r\nop, context->fw_status);\r\nif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)\r\nerr = mlx4_internal_err_ret_value(dev, op, op_modifier);\r\nelse if (mlx4_closing_cmd_fatal_error(op, context->fw_status))\r\ngoto out_reset;\r\ngoto out;\r\n}\r\nif (out_is_imm)\r\n*out_param = context->out_param;\r\nout_reset:\r\nif (err)\r\nerr = mlx4_cmd_reset_flow(dev, op, op_modifier, err);\r\nout:\r\nspin_lock(&cmd->context_lock);\r\ncontext->next = cmd->free_head;\r\ncmd->free_head = context - cmd->context;\r\nspin_unlock(&cmd->context_lock);\r\nup(&cmd->event_sem);\r\nreturn err;\r\n}\r\nint __mlx4_cmd(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\r\nint out_is_imm, u32 in_modifier, u8 op_modifier,\r\nu16 op, unsigned long timeout, int native)\r\n{\r\nif (pci_channel_offline(dev->persist->pdev))\r\nreturn mlx4_cmd_reset_flow(dev, op, op_modifier, -EIO);\r\nif (!mlx4_is_mfunc(dev) || (native && mlx4_is_master(dev))) {\r\nif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)\r\nreturn mlx4_internal_err_ret_value(dev, op,\r\nop_modifier);\r\nif (mlx4_priv(dev)->cmd.use_events)\r\nreturn mlx4_cmd_wait(dev, in_param, out_param,\r\nout_is_imm, in_modifier,\r\nop_modifier, op, timeout);\r\nelse\r\nreturn mlx4_cmd_poll(dev, in_param, out_param,\r\nout_is_imm, in_modifier,\r\nop_modifier, op, timeout);\r\n}\r\nreturn mlx4_slave_cmd(dev, in_param, out_param, out_is_imm,\r\nin_modifier, op_modifier, op, timeout);\r\n}\r\nint mlx4_ARM_COMM_CHANNEL(struct mlx4_dev *dev)\r\n{\r\nreturn mlx4_cmd(dev, 0, 0, 0, MLX4_CMD_ARM_COMM_CHANNEL,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\r\n}\r\nstatic int mlx4_ACCESS_MEM(struct mlx4_dev *dev, u64 master_addr,\r\nint slave, u64 slave_addr,\r\nint size, int is_read)\r\n{\r\nu64 in_param;\r\nu64 out_param;\r\nif ((slave_addr & 0xfff) | (master_addr & 0xfff) |\r\n(slave & ~0x7f) | (size & 0xff)) {\r\nmlx4_err(dev, "Bad access mem params - slave_addr:0x%llx master_addr:0x%llx slave_id:%d size:%d\n",\r\nslave_addr, master_addr, slave, size);\r\nreturn -EINVAL;\r\n}\r\nif (is_read) {\r\nin_param = (u64) slave | slave_addr;\r\nout_param = (u64) dev->caps.function | master_addr;\r\n} else {\r\nin_param = (u64) dev->caps.function | master_addr;\r\nout_param = (u64) slave | slave_addr;\r\n}\r\nreturn mlx4_cmd_imm(dev, in_param, &out_param, size, 0,\r\nMLX4_CMD_ACCESS_MEM,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_NATIVE);\r\n}\r\nstatic int query_pkey_block(struct mlx4_dev *dev, u8 port, u16 index, u16 *pkey,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox)\r\n{\r\nstruct ib_smp *in_mad = (struct ib_smp *)(inbox->buf);\r\nstruct ib_smp *out_mad = (struct ib_smp *)(outbox->buf);\r\nint err;\r\nint i;\r\nif (index & 0x1f)\r\nreturn -EINVAL;\r\nin_mad->attr_mod = cpu_to_be32(index / 32);\r\nerr = mlx4_cmd_box(dev, inbox->dma, outbox->dma, port, 3,\r\nMLX4_CMD_MAD_IFC, MLX4_CMD_TIME_CLASS_C,\r\nMLX4_CMD_NATIVE);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < 32; ++i)\r\npkey[i] = be16_to_cpu(((__be16 *) out_mad->data)[i]);\r\nreturn err;\r\n}\r\nstatic int get_full_pkey_table(struct mlx4_dev *dev, u8 port, u16 *table,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox)\r\n{\r\nint i;\r\nint err;\r\nfor (i = 0; i < dev->caps.pkey_table_len[port]; i += 32) {\r\nerr = query_pkey_block(dev, port, i, table + i, inbox, outbox);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum ib_port_state vf_port_state(struct mlx4_dev *dev, int port, int vf)\r\n{\r\nif (mlx4_get_slave_port_state(dev, vf, port) == SLAVE_PORT_UP)\r\nreturn IB_PORT_ACTIVE;\r\nelse\r\nreturn IB_PORT_DOWN;\r\n}\r\nstatic int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nstruct ib_smp *smp = inbox->buf;\r\nu32 index;\r\nu8 port, slave_port;\r\nu8 opcode_modifier;\r\nu16 *table;\r\nint err;\r\nint vidx, pidx;\r\nint network_view;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct ib_smp *outsmp = outbox->buf;\r\n__be16 *outtab = (__be16 *)(outsmp->data);\r\n__be32 slave_cap_mask;\r\n__be64 slave_node_guid;\r\nslave_port = vhcr->in_modifier;\r\nport = mlx4_slave_convert_port(dev, slave, slave_port);\r\nopcode_modifier = vhcr->op_modifier & ~0x8;\r\nnetwork_view = !!(vhcr->op_modifier & 0x8);\r\nif (smp->base_version == 1 &&\r\nsmp->mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED &&\r\nsmp->class_version == 1) {\r\nif (!network_view && smp->method == IB_MGMT_METHOD_GET) {\r\nif (smp->attr_id == IB_SMP_ATTR_PKEY_TABLE) {\r\nindex = be32_to_cpu(smp->attr_mod);\r\nif (port < 1 || port > dev->caps.num_ports)\r\nreturn -EINVAL;\r\ntable = kcalloc((dev->caps.pkey_table_len[port] / 32) + 1,\r\nsizeof(*table) * 32, GFP_KERNEL);\r\nif (!table)\r\nreturn -ENOMEM;\r\nerr = get_full_pkey_table(dev, port, table, inbox, outbox);\r\nif (!err) {\r\nfor (vidx = index * 32; vidx < (index + 1) * 32; ++vidx) {\r\npidx = priv->virt2phys_pkey[slave][port - 1][vidx];\r\nouttab[vidx % 32] = cpu_to_be16(table[pidx]);\r\n}\r\n}\r\nkfree(table);\r\nreturn err;\r\n}\r\nif (smp->attr_id == IB_SMP_ATTR_PORT_INFO) {\r\nsmp->attr_mod = cpu_to_be32(port);\r\nerr = mlx4_cmd_box(dev, inbox->dma, outbox->dma,\r\nport, opcode_modifier,\r\nvhcr->op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\r\nif (!err && slave != mlx4_master_func_num(dev)) {\r\nu8 *state = outsmp->data + PORT_STATE_OFFSET;\r\n*state = (*state & 0xf0) | vf_port_state(dev, port, slave);\r\nslave_cap_mask = priv->mfunc.master.slave_state[slave].ib_cap_mask[port];\r\nmemcpy(outsmp->data + PORT_CAPABILITY_LOCATION_IN_SMP, &slave_cap_mask, 4);\r\n}\r\nreturn err;\r\n}\r\nif (smp->attr_id == IB_SMP_ATTR_GUID_INFO) {\r\n__be64 guid = mlx4_get_admin_guid(dev, slave,\r\nport);\r\nif (slave == 0 && guid == 0) {\r\nsmp->attr_mod = 0;\r\nerr = mlx4_cmd_box(dev,\r\ninbox->dma,\r\noutbox->dma,\r\nvhcr->in_modifier,\r\nopcode_modifier,\r\nvhcr->op,\r\nMLX4_CMD_TIME_CLASS_C,\r\nMLX4_CMD_NATIVE);\r\nif (err)\r\nreturn err;\r\nmlx4_set_admin_guid(dev,\r\n*(__be64 *)outsmp->\r\ndata, slave, port);\r\n} else {\r\nmemcpy(outsmp->data, &guid, 8);\r\n}\r\nmemset(outsmp->data + 8, 0, 56);\r\nreturn 0;\r\n}\r\nif (smp->attr_id == IB_SMP_ATTR_NODE_INFO) {\r\nerr = mlx4_cmd_box(dev, inbox->dma, outbox->dma,\r\nport, opcode_modifier,\r\nvhcr->op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\r\nif (!err) {\r\nslave_node_guid = mlx4_get_slave_node_guid(dev, slave);\r\nmemcpy(outsmp->data + 12, &slave_node_guid, 8);\r\n}\r\nreturn err;\r\n}\r\n}\r\n}\r\nif (slave != mlx4_master_func_num(dev) &&\r\n!mlx4_vf_smi_enabled(dev, slave, port)) {\r\nif (!(smp->mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED &&\r\nsmp->method == IB_MGMT_METHOD_GET) || network_view) {\r\nmlx4_err(dev, "Unprivileged slave %d is trying to execute a Subnet MGMT MAD, class 0x%x, method 0x%x, view=%s for attr 0x%x. Rejecting\n",\r\nslave, smp->mgmt_class, smp->method,\r\nnetwork_view ? "Network" : "Host",\r\nbe16_to_cpu(smp->attr_id));\r\nreturn -EPERM;\r\n}\r\n}\r\nreturn mlx4_cmd_box(dev, inbox->dma, outbox->dma,\r\nvhcr->in_modifier, opcode_modifier,\r\nvhcr->op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\r\n}\r\nstatic int mlx4_CMD_EPERM_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nreturn -EPERM;\r\n}\r\nint mlx4_DMA_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nu64 in_param;\r\nu64 out_param;\r\nint err;\r\nin_param = cmd->has_inbox ? (u64) inbox->dma : vhcr->in_param;\r\nout_param = cmd->has_outbox ? (u64) outbox->dma : vhcr->out_param;\r\nif (cmd->encode_slave_id) {\r\nin_param &= 0xffffffffffffff00ll;\r\nin_param |= slave;\r\n}\r\nerr = __mlx4_cmd(dev, in_param, &out_param, cmd->out_is_imm,\r\nvhcr->in_modifier, vhcr->op_modifier, vhcr->op,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_NATIVE);\r\nif (cmd->out_is_imm)\r\nvhcr->out_param = out_param;\r\nreturn err;\r\n}\r\nstatic int mlx4_master_process_vhcr(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr_cmd *in_vhcr)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_cmd_info *cmd = NULL;\r\nstruct mlx4_vhcr_cmd *vhcr_cmd = in_vhcr ? in_vhcr : priv->mfunc.vhcr;\r\nstruct mlx4_vhcr *vhcr;\r\nstruct mlx4_cmd_mailbox *inbox = NULL;\r\nstruct mlx4_cmd_mailbox *outbox = NULL;\r\nu64 in_param;\r\nu64 out_param;\r\nint ret = 0;\r\nint i;\r\nint err = 0;\r\nvhcr = kzalloc(sizeof(struct mlx4_vhcr), GFP_KERNEL);\r\nif (!vhcr)\r\nreturn -ENOMEM;\r\nif (!in_vhcr) {\r\nret = mlx4_ACCESS_MEM(dev, priv->mfunc.vhcr_dma, slave,\r\npriv->mfunc.master.slave_state[slave].vhcr_dma,\r\nALIGN(sizeof(struct mlx4_vhcr_cmd),\r\nMLX4_ACCESS_MEM_ALIGN), 1);\r\nif (ret) {\r\nif (!(dev->persist->state &\r\nMLX4_DEVICE_STATE_INTERNAL_ERROR))\r\nmlx4_err(dev, "%s: Failed reading vhcr ret: 0x%x\n",\r\n__func__, ret);\r\nkfree(vhcr);\r\nreturn ret;\r\n}\r\n}\r\nvhcr->in_param = be64_to_cpu(vhcr_cmd->in_param);\r\nvhcr->out_param = be64_to_cpu(vhcr_cmd->out_param);\r\nvhcr->in_modifier = be32_to_cpu(vhcr_cmd->in_modifier);\r\nvhcr->token = be16_to_cpu(vhcr_cmd->token);\r\nvhcr->op = be16_to_cpu(vhcr_cmd->opcode) & 0xfff;\r\nvhcr->op_modifier = (u8) (be16_to_cpu(vhcr_cmd->opcode) >> 12);\r\nvhcr->e_bit = vhcr_cmd->flags & (1 << 6);\r\nfor (i = 0; i < ARRAY_SIZE(cmd_info); ++i) {\r\nif (vhcr->op == cmd_info[i].opcode) {\r\ncmd = &cmd_info[i];\r\nbreak;\r\n}\r\n}\r\nif (!cmd) {\r\nmlx4_err(dev, "Unknown command:0x%x accepted from slave:%d\n",\r\nvhcr->op, slave);\r\nvhcr_cmd->status = CMD_STAT_BAD_PARAM;\r\ngoto out_status;\r\n}\r\nif (cmd->has_inbox) {\r\nvhcr->in_param &= INBOX_MASK;\r\ninbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(inbox)) {\r\nvhcr_cmd->status = CMD_STAT_BAD_SIZE;\r\ninbox = NULL;\r\ngoto out_status;\r\n}\r\nret = mlx4_ACCESS_MEM(dev, inbox->dma, slave,\r\nvhcr->in_param,\r\nMLX4_MAILBOX_SIZE, 1);\r\nif (ret) {\r\nif (!(dev->persist->state &\r\nMLX4_DEVICE_STATE_INTERNAL_ERROR))\r\nmlx4_err(dev, "%s: Failed reading inbox (cmd:0x%x)\n",\r\n__func__, cmd->opcode);\r\nvhcr_cmd->status = CMD_STAT_INTERNAL_ERR;\r\ngoto out_status;\r\n}\r\n}\r\nif (cmd->verify && cmd->verify(dev, slave, vhcr, inbox)) {\r\nmlx4_warn(dev, "Command:0x%x from slave: %d failed protection checks for resource_id:%d\n",\r\nvhcr->op, slave, vhcr->in_modifier);\r\nvhcr_cmd->status = CMD_STAT_BAD_OP;\r\ngoto out_status;\r\n}\r\nif (cmd->has_outbox) {\r\noutbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(outbox)) {\r\nvhcr_cmd->status = CMD_STAT_BAD_SIZE;\r\noutbox = NULL;\r\ngoto out_status;\r\n}\r\n}\r\nif (cmd->wrapper) {\r\nerr = cmd->wrapper(dev, slave, vhcr, inbox, outbox,\r\ncmd);\r\nif (cmd->out_is_imm)\r\nvhcr_cmd->out_param = cpu_to_be64(vhcr->out_param);\r\n} else {\r\nin_param = cmd->has_inbox ? (u64) inbox->dma :\r\nvhcr->in_param;\r\nout_param = cmd->has_outbox ? (u64) outbox->dma :\r\nvhcr->out_param;\r\nerr = __mlx4_cmd(dev, in_param, &out_param,\r\ncmd->out_is_imm, vhcr->in_modifier,\r\nvhcr->op_modifier, vhcr->op,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nif (cmd->out_is_imm) {\r\nvhcr->out_param = out_param;\r\nvhcr_cmd->out_param = cpu_to_be64(vhcr->out_param);\r\n}\r\n}\r\nif (err) {\r\nif (!(dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR))\r\nmlx4_warn(dev, "vhcr command:0x%x slave:%d failed with error:%d, status %d\n",\r\nvhcr->op, slave, vhcr->errno, err);\r\nvhcr_cmd->status = mlx4_errno_to_status(err);\r\ngoto out_status;\r\n}\r\nif (cmd->has_outbox && !vhcr_cmd->status) {\r\nret = mlx4_ACCESS_MEM(dev, outbox->dma, slave,\r\nvhcr->out_param,\r\nMLX4_MAILBOX_SIZE, MLX4_CMD_WRAPPED);\r\nif (ret) {\r\nif (!(dev->persist->state &\r\nMLX4_DEVICE_STATE_INTERNAL_ERROR))\r\nmlx4_err(dev, "%s:Failed writing outbox\n", __func__);\r\ngoto out;\r\n}\r\n}\r\nout_status:\r\nif (!in_vhcr) {\r\nret = mlx4_ACCESS_MEM(dev, priv->mfunc.vhcr_dma, slave,\r\npriv->mfunc.master.slave_state[slave].vhcr_dma,\r\nALIGN(sizeof(struct mlx4_vhcr),\r\nMLX4_ACCESS_MEM_ALIGN),\r\nMLX4_CMD_WRAPPED);\r\nif (ret)\r\nmlx4_err(dev, "%s:Failed writing vhcr result\n",\r\n__func__);\r\nelse if (vhcr->e_bit &&\r\nmlx4_GEN_EQE(dev, slave, &priv->mfunc.master.cmd_eqe))\r\nmlx4_warn(dev, "Failed to generate command completion eqe for slave %d\n",\r\nslave);\r\n}\r\nout:\r\nkfree(vhcr);\r\nmlx4_free_cmd_mailbox(dev, inbox);\r\nmlx4_free_cmd_mailbox(dev, outbox);\r\nreturn ret;\r\n}\r\nstatic int mlx4_master_immediate_activate_vlan_qos(struct mlx4_priv *priv,\r\nint slave, int port)\r\n{\r\nstruct mlx4_vport_oper_state *vp_oper;\r\nstruct mlx4_vport_state *vp_admin;\r\nstruct mlx4_vf_immed_vlan_work *work;\r\nstruct mlx4_dev *dev = &(priv->dev);\r\nint err;\r\nint admin_vlan_ix = NO_INDX;\r\nvp_oper = &priv->mfunc.master.vf_oper[slave].vport[port];\r\nvp_admin = &priv->mfunc.master.vf_admin[slave].vport[port];\r\nif (vp_oper->state.default_vlan == vp_admin->default_vlan &&\r\nvp_oper->state.default_qos == vp_admin->default_qos &&\r\nvp_oper->state.link_state == vp_admin->link_state &&\r\nvp_oper->state.qos_vport == vp_admin->qos_vport)\r\nreturn 0;\r\nif (!(priv->mfunc.master.slave_state[slave].active &&\r\ndev->caps.flags2 & MLX4_DEV_CAP_FLAG2_UPDATE_QP)) {\r\nvp_oper->state.link_state = vp_admin->link_state;\r\nreturn -1;\r\n}\r\nmlx4_dbg(dev, "updating immediately admin params slave %d port %d\n",\r\nslave, port);\r\nmlx4_dbg(dev, "vlan %d QoS %d link down %d\n",\r\nvp_admin->default_vlan, vp_admin->default_qos,\r\nvp_admin->link_state);\r\nwork = kzalloc(sizeof(*work), GFP_KERNEL);\r\nif (!work)\r\nreturn -ENOMEM;\r\nif (vp_oper->state.default_vlan != vp_admin->default_vlan) {\r\nif (MLX4_VGT != vp_admin->default_vlan) {\r\nerr = __mlx4_register_vlan(&priv->dev, port,\r\nvp_admin->default_vlan,\r\n&admin_vlan_ix);\r\nif (err) {\r\nkfree(work);\r\nmlx4_warn(&priv->dev,\r\n"No vlan resources slave %d, port %d\n",\r\nslave, port);\r\nreturn err;\r\n}\r\n} else {\r\nadmin_vlan_ix = NO_INDX;\r\n}\r\nwork->flags |= MLX4_VF_IMMED_VLAN_FLAG_VLAN;\r\nmlx4_dbg(&priv->dev,\r\n"alloc vlan %d idx %d slave %d port %d\n",\r\n(int)(vp_admin->default_vlan),\r\nadmin_vlan_ix, slave, port);\r\n}\r\nwork->orig_vlan_id = vp_oper->state.default_vlan;\r\nwork->orig_vlan_ix = vp_oper->vlan_idx;\r\nif (vp_oper->state.default_qos != vp_admin->default_qos)\r\nwork->flags |= MLX4_VF_IMMED_VLAN_FLAG_QOS;\r\nif (work->flags & MLX4_VF_IMMED_VLAN_FLAG_VLAN)\r\nvp_oper->vlan_idx = admin_vlan_ix;\r\nvp_oper->state.default_vlan = vp_admin->default_vlan;\r\nvp_oper->state.default_qos = vp_admin->default_qos;\r\nvp_oper->state.link_state = vp_admin->link_state;\r\nvp_oper->state.qos_vport = vp_admin->qos_vport;\r\nif (vp_admin->link_state == IFLA_VF_LINK_STATE_DISABLE)\r\nwork->flags |= MLX4_VF_IMMED_VLAN_FLAG_LINK_DISABLE;\r\nwork->port = port;\r\nwork->slave = slave;\r\nwork->qos = vp_oper->state.default_qos;\r\nwork->qos_vport = vp_oper->state.qos_vport;\r\nwork->vlan_id = vp_oper->state.default_vlan;\r\nwork->vlan_ix = vp_oper->vlan_idx;\r\nwork->priv = priv;\r\nINIT_WORK(&work->work, mlx4_vf_immed_vlan_work_handler);\r\nqueue_work(priv->mfunc.master.comm_wq, &work->work);\r\nreturn 0;\r\n}\r\nstatic void mlx4_set_default_port_qos(struct mlx4_dev *dev, int port)\r\n{\r\nstruct mlx4_qos_manager *port_qos_ctl;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nport_qos_ctl = &priv->mfunc.master.qos_ctl[port];\r\nbitmap_zero(port_qos_ctl->priority_bm, MLX4_NUM_UP);\r\nset_bit(MLX4_DEFAULT_QOS_PRIO, port_qos_ctl->priority_bm);\r\n}\r\nstatic void mlx4_allocate_port_vpps(struct mlx4_dev *dev, int port)\r\n{\r\nint i;\r\nint err;\r\nint num_vfs;\r\nu16 availible_vpp;\r\nu8 vpp_param[MLX4_NUM_UP];\r\nstruct mlx4_qos_manager *port_qos;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nerr = mlx4_ALLOCATE_VPP_get(dev, port, &availible_vpp, vpp_param);\r\nif (err) {\r\nmlx4_info(dev, "Failed query availible VPPs\n");\r\nreturn;\r\n}\r\nport_qos = &priv->mfunc.master.qos_ctl[port];\r\nnum_vfs = (availible_vpp /\r\nbitmap_weight(port_qos->priority_bm, MLX4_NUM_UP));\r\nfor (i = 0; i < MLX4_NUM_UP; i++) {\r\nif (test_bit(i, port_qos->priority_bm))\r\nvpp_param[i] = num_vfs;\r\n}\r\nerr = mlx4_ALLOCATE_VPP_set(dev, port, vpp_param);\r\nif (err) {\r\nmlx4_info(dev, "Failed allocating VPPs\n");\r\nreturn;\r\n}\r\nerr = mlx4_ALLOCATE_VPP_get(dev, port, &availible_vpp, vpp_param);\r\nif (err) {\r\nmlx4_info(dev, "Failed query availible VPPs\n");\r\nreturn;\r\n}\r\nport_qos->num_of_qos_vfs = num_vfs;\r\nmlx4_dbg(dev, "Port %d Availible VPPs %d\n", port, availible_vpp);\r\nfor (i = 0; i < MLX4_NUM_UP; i++)\r\nmlx4_dbg(dev, "Port %d UP %d Allocated %d VPPs\n", port, i,\r\nvpp_param[i]);\r\n}\r\nstatic int mlx4_master_activate_admin_state(struct mlx4_priv *priv, int slave)\r\n{\r\nint port, err;\r\nstruct mlx4_vport_state *vp_admin;\r\nstruct mlx4_vport_oper_state *vp_oper;\r\nstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(\r\n&priv->dev, slave);\r\nint min_port = find_first_bit(actv_ports.ports,\r\npriv->dev.caps.num_ports) + 1;\r\nint max_port = min_port - 1 +\r\nbitmap_weight(actv_ports.ports, priv->dev.caps.num_ports);\r\nfor (port = min_port; port <= max_port; port++) {\r\nif (!test_bit(port - 1, actv_ports.ports))\r\ncontinue;\r\npriv->mfunc.master.vf_oper[slave].smi_enabled[port] =\r\npriv->mfunc.master.vf_admin[slave].enable_smi[port];\r\nvp_oper = &priv->mfunc.master.vf_oper[slave].vport[port];\r\nvp_admin = &priv->mfunc.master.vf_admin[slave].vport[port];\r\nvp_oper->state = *vp_admin;\r\nif (MLX4_VGT != vp_admin->default_vlan) {\r\nerr = __mlx4_register_vlan(&priv->dev, port,\r\nvp_admin->default_vlan, &(vp_oper->vlan_idx));\r\nif (err) {\r\nvp_oper->vlan_idx = NO_INDX;\r\nmlx4_warn(&priv->dev,\r\n"No vlan resources slave %d, port %d\n",\r\nslave, port);\r\nreturn err;\r\n}\r\nmlx4_dbg(&priv->dev, "alloc vlan %d idx %d slave %d port %d\n",\r\n(int)(vp_oper->state.default_vlan),\r\nvp_oper->vlan_idx, slave, port);\r\n}\r\nif (vp_admin->spoofchk) {\r\nvp_oper->mac_idx = __mlx4_register_mac(&priv->dev,\r\nport,\r\nvp_admin->mac);\r\nif (0 > vp_oper->mac_idx) {\r\nerr = vp_oper->mac_idx;\r\nvp_oper->mac_idx = NO_INDX;\r\nmlx4_warn(&priv->dev,\r\n"No mac resources slave %d, port %d\n",\r\nslave, port);\r\nreturn err;\r\n}\r\nmlx4_dbg(&priv->dev, "alloc mac %llx idx %d slave %d port %d\n",\r\nvp_oper->state.mac, vp_oper->mac_idx, slave, port);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mlx4_master_deactivate_admin_state(struct mlx4_priv *priv, int slave)\r\n{\r\nint port;\r\nstruct mlx4_vport_oper_state *vp_oper;\r\nstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(\r\n&priv->dev, slave);\r\nint min_port = find_first_bit(actv_ports.ports,\r\npriv->dev.caps.num_ports) + 1;\r\nint max_port = min_port - 1 +\r\nbitmap_weight(actv_ports.ports, priv->dev.caps.num_ports);\r\nfor (port = min_port; port <= max_port; port++) {\r\nif (!test_bit(port - 1, actv_ports.ports))\r\ncontinue;\r\npriv->mfunc.master.vf_oper[slave].smi_enabled[port] =\r\nMLX4_VF_SMI_DISABLED;\r\nvp_oper = &priv->mfunc.master.vf_oper[slave].vport[port];\r\nif (NO_INDX != vp_oper->vlan_idx) {\r\n__mlx4_unregister_vlan(&priv->dev,\r\nport, vp_oper->state.default_vlan);\r\nvp_oper->vlan_idx = NO_INDX;\r\n}\r\nif (NO_INDX != vp_oper->mac_idx) {\r\n__mlx4_unregister_mac(&priv->dev, port, vp_oper->state.mac);\r\nvp_oper->mac_idx = NO_INDX;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void mlx4_master_do_cmd(struct mlx4_dev *dev, int slave, u8 cmd,\r\nu16 param, u8 toggle)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_state *slave_state = priv->mfunc.master.slave_state;\r\nu32 reply;\r\nu8 is_going_down = 0;\r\nint i;\r\nunsigned long flags;\r\nslave_state[slave].comm_toggle ^= 1;\r\nreply = (u32) slave_state[slave].comm_toggle << 31;\r\nif (toggle != slave_state[slave].comm_toggle) {\r\nmlx4_warn(dev, "Incorrect toggle %d from slave %d. *** MASTER STATE COMPROMISED ***\n",\r\ntoggle, slave);\r\ngoto reset_slave;\r\n}\r\nif (cmd == MLX4_COMM_CMD_RESET) {\r\nmlx4_warn(dev, "Received reset from slave:%d\n", slave);\r\nslave_state[slave].active = false;\r\nslave_state[slave].old_vlan_api = false;\r\nmlx4_master_deactivate_admin_state(priv, slave);\r\nfor (i = 0; i < MLX4_EVENT_TYPES_NUM; ++i) {\r\nslave_state[slave].event_eq[i].eqn = -1;\r\nslave_state[slave].event_eq[i].token = 0;\r\n}\r\nif (MLX4_COMM_CMD_FLR == slave_state[slave].last_cmd)\r\ngoto inform_slave_state;\r\nmlx4_dispatch_event(dev, MLX4_DEV_EVENT_SLAVE_SHUTDOWN, slave);\r\nreply |= mlx4_comm_get_version();\r\ngoto reset_slave;\r\n}\r\nif (cmd != MLX4_COMM_CMD_RESET &&\r\nMLX4_COMM_CMD_FLR == slave_state[slave].last_cmd) {\r\nmlx4_warn(dev, "slave:%d is Trying to run cmd(0x%x) in the middle of FLR\n",\r\nslave, cmd);\r\nreturn;\r\n}\r\nswitch (cmd) {\r\ncase MLX4_COMM_CMD_VHCR0:\r\nif (slave_state[slave].last_cmd != MLX4_COMM_CMD_RESET)\r\ngoto reset_slave;\r\nslave_state[slave].vhcr_dma = ((u64) param) << 48;\r\npriv->mfunc.master.slave_state[slave].cookie = 0;\r\nbreak;\r\ncase MLX4_COMM_CMD_VHCR1:\r\nif (slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR0)\r\ngoto reset_slave;\r\nslave_state[slave].vhcr_dma |= ((u64) param) << 32;\r\nbreak;\r\ncase MLX4_COMM_CMD_VHCR2:\r\nif (slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR1)\r\ngoto reset_slave;\r\nslave_state[slave].vhcr_dma |= ((u64) param) << 16;\r\nbreak;\r\ncase MLX4_COMM_CMD_VHCR_EN:\r\nif (slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR2)\r\ngoto reset_slave;\r\nslave_state[slave].vhcr_dma |= param;\r\nif (mlx4_master_activate_admin_state(priv, slave))\r\ngoto reset_slave;\r\nslave_state[slave].active = true;\r\nmlx4_dispatch_event(dev, MLX4_DEV_EVENT_SLAVE_INIT, slave);\r\nbreak;\r\ncase MLX4_COMM_CMD_VHCR_POST:\r\nif ((slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR_EN) &&\r\n(slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR_POST)) {\r\nmlx4_warn(dev, "slave:%d is out of sync, cmd=0x%x, last command=0x%x, reset is needed\n",\r\nslave, cmd, slave_state[slave].last_cmd);\r\ngoto reset_slave;\r\n}\r\nmutex_lock(&priv->cmd.slave_cmd_mutex);\r\nif (mlx4_master_process_vhcr(dev, slave, NULL)) {\r\nmlx4_err(dev, "Failed processing vhcr for slave:%d, resetting slave\n",\r\nslave);\r\nmutex_unlock(&priv->cmd.slave_cmd_mutex);\r\ngoto reset_slave;\r\n}\r\nmutex_unlock(&priv->cmd.slave_cmd_mutex);\r\nbreak;\r\ndefault:\r\nmlx4_warn(dev, "Bad comm cmd:%d from slave:%d\n", cmd, slave);\r\ngoto reset_slave;\r\n}\r\nspin_lock_irqsave(&priv->mfunc.master.slave_state_lock, flags);\r\nif (!slave_state[slave].is_slave_going_down)\r\nslave_state[slave].last_cmd = cmd;\r\nelse\r\nis_going_down = 1;\r\nspin_unlock_irqrestore(&priv->mfunc.master.slave_state_lock, flags);\r\nif (is_going_down) {\r\nmlx4_warn(dev, "Slave is going down aborting command(%d) executing from slave:%d\n",\r\ncmd, slave);\r\nreturn;\r\n}\r\n__raw_writel((__force u32) cpu_to_be32(reply),\r\n&priv->mfunc.comm[slave].slave_read);\r\nmmiowb();\r\nreturn;\r\nreset_slave:\r\nif (dev->persist->interface_state & MLX4_INTERFACE_STATE_UP)\r\nmlx4_delete_all_resources_for_slave(dev, slave);\r\nif (cmd != MLX4_COMM_CMD_RESET) {\r\nmlx4_warn(dev, "Turn on internal error to force reset, slave=%d, cmd=0x%x\n",\r\nslave, cmd);\r\nreply |= ((u32)COMM_CHAN_EVENT_INTERNAL_ERR);\r\n}\r\nspin_lock_irqsave(&priv->mfunc.master.slave_state_lock, flags);\r\nif (!slave_state[slave].is_slave_going_down)\r\nslave_state[slave].last_cmd = MLX4_COMM_CMD_RESET;\r\nspin_unlock_irqrestore(&priv->mfunc.master.slave_state_lock, flags);\r\ninform_slave_state:\r\nmemset(&slave_state[slave].event_eq, 0,\r\nsizeof(struct mlx4_slave_event_eq_info));\r\n__raw_writel((__force u32) cpu_to_be32(reply),\r\n&priv->mfunc.comm[slave].slave_read);\r\nwmb();\r\n}\r\nvoid mlx4_master_comm_channel(struct work_struct *work)\r\n{\r\nstruct mlx4_mfunc_master_ctx *master =\r\ncontainer_of(work,\r\nstruct mlx4_mfunc_master_ctx,\r\ncomm_work);\r\nstruct mlx4_mfunc *mfunc =\r\ncontainer_of(master, struct mlx4_mfunc, master);\r\nstruct mlx4_priv *priv =\r\ncontainer_of(mfunc, struct mlx4_priv, mfunc);\r\nstruct mlx4_dev *dev = &priv->dev;\r\n__be32 *bit_vec;\r\nu32 comm_cmd;\r\nu32 vec;\r\nint i, j, slave;\r\nint toggle;\r\nint served = 0;\r\nint reported = 0;\r\nu32 slt;\r\nbit_vec = master->comm_arm_bit_vector;\r\nfor (i = 0; i < COMM_CHANNEL_BIT_ARRAY_SIZE; i++) {\r\nvec = be32_to_cpu(bit_vec[i]);\r\nfor (j = 0; j < 32; j++) {\r\nif (!(vec & (1 << j)))\r\ncontinue;\r\n++reported;\r\nslave = (i * 32) + j;\r\ncomm_cmd = swab32(readl(\r\n&mfunc->comm[slave].slave_write));\r\nslt = swab32(readl(&mfunc->comm[slave].slave_read))\r\n>> 31;\r\ntoggle = comm_cmd >> 31;\r\nif (toggle != slt) {\r\nif (master->slave_state[slave].comm_toggle\r\n!= slt) {\r\npr_info("slave %d out of sync. read toggle %d, state toggle %d. Resynching.\n",\r\nslave, slt,\r\nmaster->slave_state[slave].comm_toggle);\r\nmaster->slave_state[slave].comm_toggle =\r\nslt;\r\n}\r\nmlx4_master_do_cmd(dev, slave,\r\ncomm_cmd >> 16 & 0xff,\r\ncomm_cmd & 0xffff, toggle);\r\n++served;\r\n}\r\n}\r\n}\r\nif (reported && reported != served)\r\nmlx4_warn(dev, "Got command event with bitmask from %d slaves but %d were served\n",\r\nreported, served);\r\nif (mlx4_ARM_COMM_CHANNEL(dev))\r\nmlx4_warn(dev, "Failed to arm comm channel events\n");\r\n}\r\nstatic int sync_toggles(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nu32 wr_toggle;\r\nu32 rd_toggle;\r\nunsigned long end;\r\nwr_toggle = swab32(readl(&priv->mfunc.comm->slave_write));\r\nif (wr_toggle == 0xffffffff)\r\nend = jiffies + msecs_to_jiffies(30000);\r\nelse\r\nend = jiffies + msecs_to_jiffies(5000);\r\nwhile (time_before(jiffies, end)) {\r\nrd_toggle = swab32(readl(&priv->mfunc.comm->slave_read));\r\nif (wr_toggle == 0xffffffff || rd_toggle == 0xffffffff) {\r\nmsleep(100);\r\nwr_toggle = swab32(readl(&priv->mfunc.comm->\r\nslave_write));\r\ncontinue;\r\n}\r\nif (rd_toggle >> 31 == wr_toggle >> 31) {\r\npriv->cmd.comm_toggle = rd_toggle >> 31;\r\nreturn 0;\r\n}\r\ncond_resched();\r\n}\r\nmlx4_warn(dev, "recovering from previously mis-behaved VM\n");\r\n__raw_writel((__force u32) 0, &priv->mfunc.comm->slave_read);\r\n__raw_writel((__force u32) 0, &priv->mfunc.comm->slave_write);\r\npriv->cmd.comm_toggle = 0;\r\nreturn 0;\r\n}\r\nint mlx4_multi_func_init(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_state *s_state;\r\nint i, j, err, port;\r\nif (mlx4_is_master(dev))\r\npriv->mfunc.comm =\r\nioremap(pci_resource_start(dev->persist->pdev,\r\npriv->fw.comm_bar) +\r\npriv->fw.comm_base, MLX4_COMM_PAGESIZE);\r\nelse\r\npriv->mfunc.comm =\r\nioremap(pci_resource_start(dev->persist->pdev, 2) +\r\nMLX4_SLAVE_COMM_BASE, MLX4_COMM_PAGESIZE);\r\nif (!priv->mfunc.comm) {\r\nmlx4_err(dev, "Couldn't map communication vector\n");\r\ngoto err_vhcr;\r\n}\r\nif (mlx4_is_master(dev)) {\r\nstruct mlx4_vf_oper_state *vf_oper;\r\nstruct mlx4_vf_admin_state *vf_admin;\r\npriv->mfunc.master.slave_state =\r\nkzalloc(dev->num_slaves *\r\nsizeof(struct mlx4_slave_state), GFP_KERNEL);\r\nif (!priv->mfunc.master.slave_state)\r\ngoto err_comm;\r\npriv->mfunc.master.vf_admin =\r\nkzalloc(dev->num_slaves *\r\nsizeof(struct mlx4_vf_admin_state), GFP_KERNEL);\r\nif (!priv->mfunc.master.vf_admin)\r\ngoto err_comm_admin;\r\npriv->mfunc.master.vf_oper =\r\nkzalloc(dev->num_slaves *\r\nsizeof(struct mlx4_vf_oper_state), GFP_KERNEL);\r\nif (!priv->mfunc.master.vf_oper)\r\ngoto err_comm_oper;\r\nfor (i = 0; i < dev->num_slaves; ++i) {\r\nvf_admin = &priv->mfunc.master.vf_admin[i];\r\nvf_oper = &priv->mfunc.master.vf_oper[i];\r\ns_state = &priv->mfunc.master.slave_state[i];\r\ns_state->last_cmd = MLX4_COMM_CMD_RESET;\r\nmutex_init(&priv->mfunc.master.gen_eqe_mutex[i]);\r\nfor (j = 0; j < MLX4_EVENT_TYPES_NUM; ++j)\r\ns_state->event_eq[j].eqn = -1;\r\n__raw_writel((__force u32) 0,\r\n&priv->mfunc.comm[i].slave_write);\r\n__raw_writel((__force u32) 0,\r\n&priv->mfunc.comm[i].slave_read);\r\nmmiowb();\r\nfor (port = 1; port <= MLX4_MAX_PORTS; port++) {\r\nstruct mlx4_vport_state *admin_vport;\r\nstruct mlx4_vport_state *oper_vport;\r\ns_state->vlan_filter[port] =\r\nkzalloc(sizeof(struct mlx4_vlan_fltr),\r\nGFP_KERNEL);\r\nif (!s_state->vlan_filter[port]) {\r\nif (--port)\r\nkfree(s_state->vlan_filter[port]);\r\ngoto err_slaves;\r\n}\r\nadmin_vport = &vf_admin->vport[port];\r\noper_vport = &vf_oper->vport[port].state;\r\nINIT_LIST_HEAD(&s_state->mcast_filters[port]);\r\nadmin_vport->default_vlan = MLX4_VGT;\r\noper_vport->default_vlan = MLX4_VGT;\r\nadmin_vport->qos_vport =\r\nMLX4_VPP_DEFAULT_VPORT;\r\noper_vport->qos_vport = MLX4_VPP_DEFAULT_VPORT;\r\nvf_oper->vport[port].vlan_idx = NO_INDX;\r\nvf_oper->vport[port].mac_idx = NO_INDX;\r\nmlx4_set_random_admin_guid(dev, i, port);\r\n}\r\nspin_lock_init(&s_state->lock);\r\n}\r\nif (dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QOS_VPP) {\r\nfor (port = 1; port <= dev->caps.num_ports; port++) {\r\nif (mlx4_is_eth(dev, port)) {\r\nmlx4_set_default_port_qos(dev, port);\r\nmlx4_allocate_port_vpps(dev, port);\r\n}\r\n}\r\n}\r\nmemset(&priv->mfunc.master.cmd_eqe, 0, sizeof(struct mlx4_eqe));\r\npriv->mfunc.master.cmd_eqe.type = MLX4_EVENT_TYPE_CMD;\r\nINIT_WORK(&priv->mfunc.master.comm_work,\r\nmlx4_master_comm_channel);\r\nINIT_WORK(&priv->mfunc.master.slave_event_work,\r\nmlx4_gen_slave_eqe);\r\nINIT_WORK(&priv->mfunc.master.slave_flr_event_work,\r\nmlx4_master_handle_slave_flr);\r\nspin_lock_init(&priv->mfunc.master.slave_state_lock);\r\nspin_lock_init(&priv->mfunc.master.slave_eq.event_lock);\r\npriv->mfunc.master.comm_wq =\r\ncreate_singlethread_workqueue("mlx4_comm");\r\nif (!priv->mfunc.master.comm_wq)\r\ngoto err_slaves;\r\nif (mlx4_init_resource_tracker(dev))\r\ngoto err_thread;\r\n} else {\r\nerr = sync_toggles(dev);\r\nif (err) {\r\nmlx4_err(dev, "Couldn't sync toggles\n");\r\ngoto err_comm;\r\n}\r\n}\r\nreturn 0;\r\nerr_thread:\r\nflush_workqueue(priv->mfunc.master.comm_wq);\r\ndestroy_workqueue(priv->mfunc.master.comm_wq);\r\nerr_slaves:\r\nwhile (i--) {\r\nfor (port = 1; port <= MLX4_MAX_PORTS; port++)\r\nkfree(priv->mfunc.master.slave_state[i].vlan_filter[port]);\r\n}\r\nkfree(priv->mfunc.master.vf_oper);\r\nerr_comm_oper:\r\nkfree(priv->mfunc.master.vf_admin);\r\nerr_comm_admin:\r\nkfree(priv->mfunc.master.slave_state);\r\nerr_comm:\r\niounmap(priv->mfunc.comm);\r\nerr_vhcr:\r\ndma_free_coherent(&dev->persist->pdev->dev, PAGE_SIZE,\r\npriv->mfunc.vhcr,\r\npriv->mfunc.vhcr_dma);\r\npriv->mfunc.vhcr = NULL;\r\nreturn -ENOMEM;\r\n}\r\nint mlx4_cmd_init(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint flags = 0;\r\nif (!priv->cmd.initialized) {\r\nmutex_init(&priv->cmd.slave_cmd_mutex);\r\nsema_init(&priv->cmd.poll_sem, 1);\r\npriv->cmd.use_events = 0;\r\npriv->cmd.toggle = 1;\r\npriv->cmd.initialized = 1;\r\nflags |= MLX4_CMD_CLEANUP_STRUCT;\r\n}\r\nif (!mlx4_is_slave(dev) && !priv->cmd.hcr) {\r\npriv->cmd.hcr = ioremap(pci_resource_start(dev->persist->pdev,\r\n0) + MLX4_HCR_BASE, MLX4_HCR_SIZE);\r\nif (!priv->cmd.hcr) {\r\nmlx4_err(dev, "Couldn't map command register\n");\r\ngoto err;\r\n}\r\nflags |= MLX4_CMD_CLEANUP_HCR;\r\n}\r\nif (mlx4_is_mfunc(dev) && !priv->mfunc.vhcr) {\r\npriv->mfunc.vhcr = dma_alloc_coherent(&dev->persist->pdev->dev,\r\nPAGE_SIZE,\r\n&priv->mfunc.vhcr_dma,\r\nGFP_KERNEL);\r\nif (!priv->mfunc.vhcr)\r\ngoto err;\r\nflags |= MLX4_CMD_CLEANUP_VHCR;\r\n}\r\nif (!priv->cmd.pool) {\r\npriv->cmd.pool = pci_pool_create("mlx4_cmd",\r\ndev->persist->pdev,\r\nMLX4_MAILBOX_SIZE,\r\nMLX4_MAILBOX_SIZE, 0);\r\nif (!priv->cmd.pool)\r\ngoto err;\r\nflags |= MLX4_CMD_CLEANUP_POOL;\r\n}\r\nreturn 0;\r\nerr:\r\nmlx4_cmd_cleanup(dev, flags);\r\nreturn -ENOMEM;\r\n}\r\nvoid mlx4_report_internal_err_comm_event(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint slave;\r\nu32 slave_read;\r\nfor (slave = 0; slave < dev->num_slaves; slave++) {\r\nslave_read = swab32(readl(&priv->mfunc.comm[slave].slave_read));\r\nslave_read |= (u32)COMM_CHAN_EVENT_INTERNAL_ERR;\r\n__raw_writel((__force u32)cpu_to_be32(slave_read),\r\n&priv->mfunc.comm[slave].slave_read);\r\nmmiowb();\r\n}\r\n}\r\nvoid mlx4_multi_func_cleanup(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i, port;\r\nif (mlx4_is_master(dev)) {\r\nflush_workqueue(priv->mfunc.master.comm_wq);\r\ndestroy_workqueue(priv->mfunc.master.comm_wq);\r\nfor (i = 0; i < dev->num_slaves; i++) {\r\nfor (port = 1; port <= MLX4_MAX_PORTS; port++)\r\nkfree(priv->mfunc.master.slave_state[i].vlan_filter[port]);\r\n}\r\nkfree(priv->mfunc.master.slave_state);\r\nkfree(priv->mfunc.master.vf_admin);\r\nkfree(priv->mfunc.master.vf_oper);\r\ndev->num_slaves = 0;\r\n}\r\niounmap(priv->mfunc.comm);\r\n}\r\nvoid mlx4_cmd_cleanup(struct mlx4_dev *dev, int cleanup_mask)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nif (priv->cmd.pool && (cleanup_mask & MLX4_CMD_CLEANUP_POOL)) {\r\npci_pool_destroy(priv->cmd.pool);\r\npriv->cmd.pool = NULL;\r\n}\r\nif (!mlx4_is_slave(dev) && priv->cmd.hcr &&\r\n(cleanup_mask & MLX4_CMD_CLEANUP_HCR)) {\r\niounmap(priv->cmd.hcr);\r\npriv->cmd.hcr = NULL;\r\n}\r\nif (mlx4_is_mfunc(dev) && priv->mfunc.vhcr &&\r\n(cleanup_mask & MLX4_CMD_CLEANUP_VHCR)) {\r\ndma_free_coherent(&dev->persist->pdev->dev, PAGE_SIZE,\r\npriv->mfunc.vhcr, priv->mfunc.vhcr_dma);\r\npriv->mfunc.vhcr = NULL;\r\n}\r\nif (priv->cmd.initialized && (cleanup_mask & MLX4_CMD_CLEANUP_STRUCT))\r\npriv->cmd.initialized = 0;\r\n}\r\nint mlx4_cmd_use_events(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i;\r\nint err = 0;\r\npriv->cmd.context = kmalloc(priv->cmd.max_cmds *\r\nsizeof (struct mlx4_cmd_context),\r\nGFP_KERNEL);\r\nif (!priv->cmd.context)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < priv->cmd.max_cmds; ++i) {\r\npriv->cmd.context[i].token = i;\r\npriv->cmd.context[i].next = i + 1;\r\ninit_completion(&priv->cmd.context[i].done);\r\n}\r\npriv->cmd.context[priv->cmd.max_cmds - 1].next = -1;\r\npriv->cmd.free_head = 0;\r\nsema_init(&priv->cmd.event_sem, priv->cmd.max_cmds);\r\nfor (priv->cmd.token_mask = 1;\r\npriv->cmd.token_mask < priv->cmd.max_cmds;\r\npriv->cmd.token_mask <<= 1)\r\n;\r\n--priv->cmd.token_mask;\r\ndown(&priv->cmd.poll_sem);\r\npriv->cmd.use_events = 1;\r\nreturn err;\r\n}\r\nvoid mlx4_cmd_use_polling(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i;\r\npriv->cmd.use_events = 0;\r\nfor (i = 0; i < priv->cmd.max_cmds; ++i)\r\ndown(&priv->cmd.event_sem);\r\nkfree(priv->cmd.context);\r\nup(&priv->cmd.poll_sem);\r\n}\r\nstruct mlx4_cmd_mailbox *mlx4_alloc_cmd_mailbox(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nmailbox = kmalloc(sizeof *mailbox, GFP_KERNEL);\r\nif (!mailbox)\r\nreturn ERR_PTR(-ENOMEM);\r\nmailbox->buf = pci_pool_alloc(mlx4_priv(dev)->cmd.pool, GFP_KERNEL,\r\n&mailbox->dma);\r\nif (!mailbox->buf) {\r\nkfree(mailbox);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmemset(mailbox->buf, 0, MLX4_MAILBOX_SIZE);\r\nreturn mailbox;\r\n}\r\nvoid mlx4_free_cmd_mailbox(struct mlx4_dev *dev,\r\nstruct mlx4_cmd_mailbox *mailbox)\r\n{\r\nif (!mailbox)\r\nreturn;\r\npci_pool_free(mlx4_priv(dev)->cmd.pool, mailbox->buf, mailbox->dma);\r\nkfree(mailbox);\r\n}\r\nu32 mlx4_comm_get_version(void)\r\n{\r\nreturn ((u32) CMD_CHAN_IF_REV << 8) | (u32) CMD_CHAN_VER;\r\n}\r\nstatic int mlx4_get_slave_indx(struct mlx4_dev *dev, int vf)\r\n{\r\nif ((vf < 0) || (vf >= dev->persist->num_vfs)) {\r\nmlx4_err(dev, "Bad vf number:%d (number of activated vf: %d)\n",\r\nvf, dev->persist->num_vfs);\r\nreturn -EINVAL;\r\n}\r\nreturn vf+1;\r\n}\r\nint mlx4_get_vf_indx(struct mlx4_dev *dev, int slave)\r\n{\r\nif (slave < 1 || slave > dev->persist->num_vfs) {\r\nmlx4_err(dev,\r\n"Bad slave number:%d (number of activated slaves: %lu)\n",\r\nslave, dev->num_slaves);\r\nreturn -EINVAL;\r\n}\r\nreturn slave - 1;\r\n}\r\nvoid mlx4_cmd_wake_completions(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_cmd_context *context;\r\nint i;\r\nspin_lock(&priv->cmd.context_lock);\r\nif (priv->cmd.context) {\r\nfor (i = 0; i < priv->cmd.max_cmds; ++i) {\r\ncontext = &priv->cmd.context[i];\r\ncontext->fw_status = CMD_STAT_INTERNAL_ERR;\r\ncontext->result =\r\nmlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\r\ncomplete(&context->done);\r\n}\r\n}\r\nspin_unlock(&priv->cmd.context_lock);\r\n}\r\nstruct mlx4_active_ports mlx4_get_active_ports(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_active_ports actv_ports;\r\nint vf;\r\nbitmap_zero(actv_ports.ports, MLX4_MAX_PORTS);\r\nif (slave == 0) {\r\nbitmap_fill(actv_ports.ports, dev->caps.num_ports);\r\nreturn actv_ports;\r\n}\r\nvf = mlx4_get_vf_indx(dev, slave);\r\nif (vf < 0)\r\nreturn actv_ports;\r\nbitmap_set(actv_ports.ports, dev->dev_vfs[vf].min_port - 1,\r\nmin((int)dev->dev_vfs[mlx4_get_vf_indx(dev, slave)].n_ports,\r\ndev->caps.num_ports));\r\nreturn actv_ports;\r\n}\r\nint mlx4_slave_convert_port(struct mlx4_dev *dev, int slave, int port)\r\n{\r\nunsigned n;\r\nstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\r\nunsigned m = bitmap_weight(actv_ports.ports, dev->caps.num_ports);\r\nif (port <= 0 || port > m)\r\nreturn -EINVAL;\r\nn = find_first_bit(actv_ports.ports, dev->caps.num_ports);\r\nif (port <= n)\r\nport = n + 1;\r\nreturn port;\r\n}\r\nint mlx4_phys_to_slave_port(struct mlx4_dev *dev, int slave, int port)\r\n{\r\nstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\r\nif (test_bit(port - 1, actv_ports.ports))\r\nreturn port -\r\nfind_first_bit(actv_ports.ports, dev->caps.num_ports);\r\nreturn -1;\r\n}\r\nstruct mlx4_slaves_pport mlx4_phys_to_slaves_pport(struct mlx4_dev *dev,\r\nint port)\r\n{\r\nunsigned i;\r\nstruct mlx4_slaves_pport slaves_pport;\r\nbitmap_zero(slaves_pport.slaves, MLX4_MFUNC_MAX);\r\nif (port <= 0 || port > dev->caps.num_ports)\r\nreturn slaves_pport;\r\nfor (i = 0; i < dev->persist->num_vfs + 1; i++) {\r\nstruct mlx4_active_ports actv_ports =\r\nmlx4_get_active_ports(dev, i);\r\nif (test_bit(port - 1, actv_ports.ports))\r\nset_bit(i, slaves_pport.slaves);\r\n}\r\nreturn slaves_pport;\r\n}\r\nstruct mlx4_slaves_pport mlx4_phys_to_slaves_pport_actv(\r\nstruct mlx4_dev *dev,\r\nconst struct mlx4_active_ports *crit_ports)\r\n{\r\nunsigned i;\r\nstruct mlx4_slaves_pport slaves_pport;\r\nbitmap_zero(slaves_pport.slaves, MLX4_MFUNC_MAX);\r\nfor (i = 0; i < dev->persist->num_vfs + 1; i++) {\r\nstruct mlx4_active_ports actv_ports =\r\nmlx4_get_active_ports(dev, i);\r\nif (bitmap_equal(crit_ports->ports, actv_ports.ports,\r\ndev->caps.num_ports))\r\nset_bit(i, slaves_pport.slaves);\r\n}\r\nreturn slaves_pport;\r\n}\r\nstatic int mlx4_slaves_closest_port(struct mlx4_dev *dev, int slave, int port)\r\n{\r\nstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\r\nint min_port = find_first_bit(actv_ports.ports, dev->caps.num_ports)\r\n+ 1;\r\nint max_port = min_port +\r\nbitmap_weight(actv_ports.ports, dev->caps.num_ports);\r\nif (port < min_port)\r\nport = min_port;\r\nelse if (port >= max_port)\r\nport = max_port - 1;\r\nreturn port;\r\n}\r\nstatic int mlx4_set_vport_qos(struct mlx4_priv *priv, int slave, int port,\r\nint max_tx_rate)\r\n{\r\nint i;\r\nint err;\r\nstruct mlx4_qos_manager *port_qos;\r\nstruct mlx4_dev *dev = &priv->dev;\r\nstruct mlx4_vport_qos_param vpp_qos[MLX4_NUM_UP];\r\nport_qos = &priv->mfunc.master.qos_ctl[port];\r\nmemset(vpp_qos, 0, sizeof(struct mlx4_vport_qos_param) * MLX4_NUM_UP);\r\nif (slave > port_qos->num_of_qos_vfs) {\r\nmlx4_info(dev, "No availible VPP resources for this VF\n");\r\nreturn -EINVAL;\r\n}\r\nerr = mlx4_SET_VPORT_QOS_get(dev, port, 0, vpp_qos);\r\nif (err) {\r\nmlx4_info(dev, "Failed to query Vport 0 QoS values\n");\r\nreturn err;\r\n}\r\nfor (i = 0; i < MLX4_NUM_UP; i++) {\r\nif (test_bit(i, port_qos->priority_bm) && max_tx_rate) {\r\nvpp_qos[i].max_avg_bw = max_tx_rate;\r\nvpp_qos[i].enable = 1;\r\n} else {\r\nvpp_qos[i].enable = 0;\r\n}\r\n}\r\nerr = mlx4_SET_VPORT_QOS_set(dev, port, slave, vpp_qos);\r\nif (err) {\r\nmlx4_info(dev, "Failed to set Vport %d QoS values\n", slave);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool mlx4_is_vf_vst_and_prio_qos(struct mlx4_dev *dev, int port,\r\nstruct mlx4_vport_state *vf_admin)\r\n{\r\nstruct mlx4_qos_manager *info;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nif (!mlx4_is_master(dev) ||\r\n!(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QOS_VPP))\r\nreturn false;\r\ninfo = &priv->mfunc.master.qos_ctl[port];\r\nif (vf_admin->default_vlan != MLX4_VGT &&\r\ntest_bit(vf_admin->default_qos, info->priority_bm))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool mlx4_valid_vf_state_change(struct mlx4_dev *dev, int port,\r\nstruct mlx4_vport_state *vf_admin,\r\nint vlan, int qos)\r\n{\r\nstruct mlx4_vport_state dummy_admin = {0};\r\nif (!mlx4_is_vf_vst_and_prio_qos(dev, port, vf_admin) ||\r\n!vf_admin->tx_rate)\r\nreturn true;\r\ndummy_admin.default_qos = qos;\r\ndummy_admin.default_vlan = vlan;\r\nif (mlx4_is_vf_vst_and_prio_qos(dev, port, &dummy_admin))\r\nreturn true;\r\nmlx4_info(dev, "Cannot change VF state to %s while rate is set\n",\r\n(vlan == MLX4_VGT) ? "VGT" : "VST");\r\nif (vlan != MLX4_VGT)\r\nmlx4_info(dev, "VST priority %d not supported for QoS\n", qos);\r\nmlx4_info(dev, "Please set rate to 0 prior to this VF state change\n");\r\nreturn false;\r\n}\r\nint mlx4_set_vf_mac(struct mlx4_dev *dev, int port, int vf, u64 mac)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_vport_state *s_info;\r\nint slave;\r\nif (!mlx4_is_master(dev))\r\nreturn -EPROTONOSUPPORT;\r\nslave = mlx4_get_slave_indx(dev, vf);\r\nif (slave < 0)\r\nreturn -EINVAL;\r\nport = mlx4_slaves_closest_port(dev, slave, port);\r\ns_info = &priv->mfunc.master.vf_admin[slave].vport[port];\r\ns_info->mac = mac;\r\nmlx4_info(dev, "default mac on vf %d port %d to %llX will take effect only after vf restart\n",\r\nvf, port, s_info->mac);\r\nreturn 0;\r\n}\r\nint mlx4_set_vf_vlan(struct mlx4_dev *dev, int port, int vf, u16 vlan, u8 qos)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_vport_state *vf_admin;\r\nint slave;\r\nif ((!mlx4_is_master(dev)) ||\r\n!(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_VLAN_CONTROL))\r\nreturn -EPROTONOSUPPORT;\r\nif ((vlan > 4095) || (qos > 7))\r\nreturn -EINVAL;\r\nslave = mlx4_get_slave_indx(dev, vf);\r\nif (slave < 0)\r\nreturn -EINVAL;\r\nport = mlx4_slaves_closest_port(dev, slave, port);\r\nvf_admin = &priv->mfunc.master.vf_admin[slave].vport[port];\r\nif (!mlx4_valid_vf_state_change(dev, port, vf_admin, vlan, qos))\r\nreturn -EPERM;\r\nif ((0 == vlan) && (0 == qos))\r\nvf_admin->default_vlan = MLX4_VGT;\r\nelse\r\nvf_admin->default_vlan = vlan;\r\nvf_admin->default_qos = qos;\r\nif (mlx4_is_vf_vst_and_prio_qos(dev, port, vf_admin) &&\r\nvf_admin->tx_rate)\r\nvf_admin->qos_vport = slave;\r\nif (mlx4_master_immediate_activate_vlan_qos(priv, slave, port))\r\nmlx4_info(dev,\r\n"updating vf %d port %d config will take effect on next VF restart\n",\r\nvf, port);\r\nreturn 0;\r\n}\r\nint mlx4_set_vf_rate(struct mlx4_dev *dev, int port, int vf, int min_tx_rate,\r\nint max_tx_rate)\r\n{\r\nint err;\r\nint slave;\r\nstruct mlx4_vport_state *vf_admin;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nif (!mlx4_is_master(dev) ||\r\n!(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QOS_VPP))\r\nreturn -EPROTONOSUPPORT;\r\nif (min_tx_rate) {\r\nmlx4_info(dev, "Minimum BW share not supported\n");\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nslave = mlx4_get_slave_indx(dev, vf);\r\nif (slave < 0)\r\nreturn -EINVAL;\r\nport = mlx4_slaves_closest_port(dev, slave, port);\r\nvf_admin = &priv->mfunc.master.vf_admin[slave].vport[port];\r\nerr = mlx4_set_vport_qos(priv, slave, port, max_tx_rate);\r\nif (err) {\r\nmlx4_info(dev, "vf %d failed to set rate %d\n", vf,\r\nmax_tx_rate);\r\nreturn err;\r\n}\r\nvf_admin->tx_rate = max_tx_rate;\r\nif (!mlx4_is_vf_vst_and_prio_qos(dev, port, vf_admin)) {\r\nmlx4_info(dev,\r\n"rate set for VF %d when not in valid state\n", vf);\r\nif (vf_admin->default_vlan != MLX4_VGT)\r\nmlx4_info(dev, "VST priority not supported by QoS\n");\r\nelse\r\nmlx4_info(dev, "VF in VGT mode (needed VST)\n");\r\nmlx4_info(dev,\r\n"rate %d take affect when VF moves to valid state\n",\r\nmax_tx_rate);\r\nreturn 0;\r\n}\r\nvf_admin->qos_vport = max_tx_rate ? slave : MLX4_VPP_DEFAULT_VPORT;\r\nif (priv->mfunc.master.slave_state[slave].active &&\r\ndev->caps.flags2 & MLX4_DEV_CAP_FLAG2_UPDATE_QP)\r\nmlx4_master_immediate_activate_vlan_qos(priv, slave, port);\r\nreturn 0;\r\n}\r\nbool mlx4_get_slave_default_vlan(struct mlx4_dev *dev, int port, int slave,\r\nu16 *vlan, u8 *qos)\r\n{\r\nstruct mlx4_vport_oper_state *vp_oper;\r\nstruct mlx4_priv *priv;\r\npriv = mlx4_priv(dev);\r\nport = mlx4_slaves_closest_port(dev, slave, port);\r\nvp_oper = &priv->mfunc.master.vf_oper[slave].vport[port];\r\nif (MLX4_VGT != vp_oper->state.default_vlan) {\r\nif (vlan)\r\n*vlan = vp_oper->state.default_vlan;\r\nif (qos)\r\n*qos = vp_oper->state.default_qos;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint mlx4_set_vf_spoofchk(struct mlx4_dev *dev, int port, int vf, bool setting)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_vport_state *s_info;\r\nint slave;\r\nif ((!mlx4_is_master(dev)) ||\r\n!(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_FSM))\r\nreturn -EPROTONOSUPPORT;\r\nslave = mlx4_get_slave_indx(dev, vf);\r\nif (slave < 0)\r\nreturn -EINVAL;\r\nport = mlx4_slaves_closest_port(dev, slave, port);\r\ns_info = &priv->mfunc.master.vf_admin[slave].vport[port];\r\ns_info->spoofchk = setting;\r\nreturn 0;\r\n}\r\nint mlx4_get_vf_config(struct mlx4_dev *dev, int port, int vf, struct ifla_vf_info *ivf)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_vport_state *s_info;\r\nint slave;\r\nif (!mlx4_is_master(dev))\r\nreturn -EPROTONOSUPPORT;\r\nslave = mlx4_get_slave_indx(dev, vf);\r\nif (slave < 0)\r\nreturn -EINVAL;\r\ns_info = &priv->mfunc.master.vf_admin[slave].vport[port];\r\nivf->vf = vf;\r\nivf->mac[0] = ((s_info->mac >> (5*8)) & 0xff);\r\nivf->mac[1] = ((s_info->mac >> (4*8)) & 0xff);\r\nivf->mac[2] = ((s_info->mac >> (3*8)) & 0xff);\r\nivf->mac[3] = ((s_info->mac >> (2*8)) & 0xff);\r\nivf->mac[4] = ((s_info->mac >> (1*8)) & 0xff);\r\nivf->mac[5] = ((s_info->mac) & 0xff);\r\nivf->vlan = s_info->default_vlan;\r\nivf->qos = s_info->default_qos;\r\nif (mlx4_is_vf_vst_and_prio_qos(dev, port, s_info))\r\nivf->max_tx_rate = s_info->tx_rate;\r\nelse\r\nivf->max_tx_rate = 0;\r\nivf->min_tx_rate = 0;\r\nivf->spoofchk = s_info->spoofchk;\r\nivf->linkstate = s_info->link_state;\r\nreturn 0;\r\n}\r\nint mlx4_set_vf_link_state(struct mlx4_dev *dev, int port, int vf, int link_state)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_vport_state *s_info;\r\nint slave;\r\nu8 link_stat_event;\r\nslave = mlx4_get_slave_indx(dev, vf);\r\nif (slave < 0)\r\nreturn -EINVAL;\r\nport = mlx4_slaves_closest_port(dev, slave, port);\r\nswitch (link_state) {\r\ncase IFLA_VF_LINK_STATE_AUTO:\r\nif (!priv->sense.do_sense_port[port])\r\nlink_stat_event = MLX4_PORT_CHANGE_SUBTYPE_ACTIVE;\r\nelse\r\nlink_stat_event = MLX4_PORT_CHANGE_SUBTYPE_DOWN;\r\nbreak;\r\ncase IFLA_VF_LINK_STATE_ENABLE:\r\nlink_stat_event = MLX4_PORT_CHANGE_SUBTYPE_ACTIVE;\r\nbreak;\r\ncase IFLA_VF_LINK_STATE_DISABLE:\r\nlink_stat_event = MLX4_PORT_CHANGE_SUBTYPE_DOWN;\r\nbreak;\r\ndefault:\r\nmlx4_warn(dev, "unknown value for link_state %02x on slave %d port %d\n",\r\nlink_state, slave, port);\r\nreturn -EINVAL;\r\n};\r\ns_info = &priv->mfunc.master.vf_admin[slave].vport[port];\r\ns_info->link_state = link_state;\r\nmlx4_gen_port_state_change_eqe(dev, slave, port, link_stat_event);\r\nif (mlx4_master_immediate_activate_vlan_qos(priv, slave, port))\r\nmlx4_dbg(dev,\r\n"updating vf %d port %d no link state HW enforcment\n",\r\nvf, port);\r\nreturn 0;\r\n}\r\nint mlx4_get_counter_stats(struct mlx4_dev *dev, int counter_index,\r\nstruct mlx4_counter *counter_stats, int reset)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox = NULL;\r\nstruct mlx4_counter *tmp_counter;\r\nint err;\r\nu32 if_stat_in_mod;\r\nif (!counter_stats)\r\nreturn -EINVAL;\r\nif (counter_index == MLX4_SINK_COUNTER_INDEX(dev))\r\nreturn 0;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\nmemset(mailbox->buf, 0, sizeof(struct mlx4_counter));\r\nif_stat_in_mod = counter_index;\r\nif (reset)\r\nif_stat_in_mod |= MLX4_QUERY_IF_STAT_RESET;\r\nerr = mlx4_cmd_box(dev, 0, mailbox->dma,\r\nif_stat_in_mod, 0,\r\nMLX4_CMD_QUERY_IF_STAT,\r\nMLX4_CMD_TIME_CLASS_C,\r\nMLX4_CMD_NATIVE);\r\nif (err) {\r\nmlx4_dbg(dev, "%s: failed to read statistics for counter index %d\n",\r\n__func__, counter_index);\r\ngoto if_stat_out;\r\n}\r\ntmp_counter = (struct mlx4_counter *)mailbox->buf;\r\ncounter_stats->counter_mode = tmp_counter->counter_mode;\r\nif (counter_stats->counter_mode == 0) {\r\ncounter_stats->rx_frames =\r\ncpu_to_be64(be64_to_cpu(counter_stats->rx_frames) +\r\nbe64_to_cpu(tmp_counter->rx_frames));\r\ncounter_stats->tx_frames =\r\ncpu_to_be64(be64_to_cpu(counter_stats->tx_frames) +\r\nbe64_to_cpu(tmp_counter->tx_frames));\r\ncounter_stats->rx_bytes =\r\ncpu_to_be64(be64_to_cpu(counter_stats->rx_bytes) +\r\nbe64_to_cpu(tmp_counter->rx_bytes));\r\ncounter_stats->tx_bytes =\r\ncpu_to_be64(be64_to_cpu(counter_stats->tx_bytes) +\r\nbe64_to_cpu(tmp_counter->tx_bytes));\r\n}\r\nif_stat_out:\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mlx4_get_vf_stats(struct mlx4_dev *dev, int port, int vf_idx,\r\nstruct ifla_vf_stats *vf_stats)\r\n{\r\nstruct mlx4_counter tmp_vf_stats;\r\nint slave;\r\nint err = 0;\r\nif (!vf_stats)\r\nreturn -EINVAL;\r\nif (!mlx4_is_master(dev))\r\nreturn -EPROTONOSUPPORT;\r\nslave = mlx4_get_slave_indx(dev, vf_idx);\r\nif (slave < 0)\r\nreturn -EINVAL;\r\nport = mlx4_slaves_closest_port(dev, slave, port);\r\nerr = mlx4_calc_vf_counters(dev, slave, port, &tmp_vf_stats);\r\nif (!err && tmp_vf_stats.counter_mode == 0) {\r\nvf_stats->rx_packets = be64_to_cpu(tmp_vf_stats.rx_frames);\r\nvf_stats->tx_packets = be64_to_cpu(tmp_vf_stats.tx_frames);\r\nvf_stats->rx_bytes = be64_to_cpu(tmp_vf_stats.rx_bytes);\r\nvf_stats->tx_bytes = be64_to_cpu(tmp_vf_stats.tx_bytes);\r\n}\r\nreturn err;\r\n}\r\nint mlx4_vf_smi_enabled(struct mlx4_dev *dev, int slave, int port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nif (slave < 1 || slave >= dev->num_slaves ||\r\nport < 1 || port > MLX4_MAX_PORTS)\r\nreturn 0;\r\nreturn priv->mfunc.master.vf_oper[slave].smi_enabled[port] ==\r\nMLX4_VF_SMI_ENABLED;\r\n}\r\nint mlx4_vf_get_enable_smi_admin(struct mlx4_dev *dev, int slave, int port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nif (slave == mlx4_master_func_num(dev))\r\nreturn 1;\r\nif (slave < 1 || slave >= dev->num_slaves ||\r\nport < 1 || port > MLX4_MAX_PORTS)\r\nreturn 0;\r\nreturn priv->mfunc.master.vf_admin[slave].enable_smi[port] ==\r\nMLX4_VF_SMI_ENABLED;\r\n}\r\nint mlx4_vf_set_enable_smi_admin(struct mlx4_dev *dev, int slave, int port,\r\nint enabled)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(\r\n&priv->dev, slave);\r\nint min_port = find_first_bit(actv_ports.ports,\r\npriv->dev.caps.num_ports) + 1;\r\nint max_port = min_port - 1 +\r\nbitmap_weight(actv_ports.ports, priv->dev.caps.num_ports);\r\nif (slave == mlx4_master_func_num(dev))\r\nreturn 0;\r\nif (slave < 1 || slave >= dev->num_slaves ||\r\nport < 1 || port > MLX4_MAX_PORTS ||\r\nenabled < 0 || enabled > 1)\r\nreturn -EINVAL;\r\nif (min_port == max_port && dev->caps.num_ports > 1) {\r\nmlx4_info(dev, "SMI access disallowed for single ported VFs\n");\r\nreturn -EPROTONOSUPPORT;\r\n}\r\npriv->mfunc.master.vf_admin[slave].enable_smi[port] = enabled;\r\nreturn 0;\r\n}
