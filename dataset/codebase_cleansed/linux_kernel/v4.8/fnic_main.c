static int fnic_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nif (!rport || fc_remote_port_chkready(rport))\r\nreturn -ENXIO;\r\nscsi_change_queue_depth(sdev, fnic_max_qdepth);\r\nreturn 0;\r\n}\r\nstatic void\r\nfnic_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)\r\n{\r\nif (timeout)\r\nrport->dev_loss_tmo = timeout;\r\nelse\r\nrport->dev_loss_tmo = 1;\r\n}\r\nstatic void fnic_get_host_speed(struct Scsi_Host *shost)\r\n{\r\nstruct fc_lport *lp = shost_priv(shost);\r\nstruct fnic *fnic = lport_priv(lp);\r\nu32 port_speed = vnic_dev_port_speed(fnic->vdev);\r\nswitch (port_speed) {\r\ncase 10000:\r\nfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\r\nbreak;\r\ndefault:\r\nfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\r\nbreak;\r\n}\r\n}\r\nstatic struct fc_host_statistics *fnic_get_stats(struct Scsi_Host *host)\r\n{\r\nint ret;\r\nstruct fc_lport *lp = shost_priv(host);\r\nstruct fnic *fnic = lport_priv(lp);\r\nstruct fc_host_statistics *stats = &lp->host_stats;\r\nstruct vnic_stats *vs;\r\nunsigned long flags;\r\nif (time_before(jiffies, fnic->stats_time + HZ / FNIC_STATS_RATE_LIMIT))\r\nreturn stats;\r\nfnic->stats_time = jiffies;\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nret = vnic_dev_stats_dump(fnic->vdev, &fnic->stats);\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nif (ret) {\r\nFNIC_MAIN_DBG(KERN_DEBUG, fnic->lport->host,\r\n"fnic: Get vnic stats failed"\r\n" 0x%x", ret);\r\nreturn stats;\r\n}\r\nvs = fnic->stats;\r\nstats->tx_frames = vs->tx.tx_unicast_frames_ok;\r\nstats->tx_words = vs->tx.tx_unicast_bytes_ok / 4;\r\nstats->rx_frames = vs->rx.rx_unicast_frames_ok;\r\nstats->rx_words = vs->rx.rx_unicast_bytes_ok / 4;\r\nstats->error_frames = vs->tx.tx_errors + vs->rx.rx_errors;\r\nstats->dumped_frames = vs->tx.tx_drops + vs->rx.rx_drop;\r\nstats->invalid_crc_count = vs->rx.rx_crc_errors;\r\nstats->seconds_since_last_reset =\r\n(jiffies - fnic->stats_reset_time) / HZ;\r\nstats->fcp_input_megabytes = div_u64(fnic->fcp_input_bytes, 1000000);\r\nstats->fcp_output_megabytes = div_u64(fnic->fcp_output_bytes, 1000000);\r\nreturn stats;\r\n}\r\nvoid fnic_dump_fchost_stats(struct Scsi_Host *host,\r\nstruct fc_host_statistics *stats)\r\n{\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: seconds since last reset = %llu\n",\r\nstats->seconds_since_last_reset);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: tx frames = %llu\n",\r\nstats->tx_frames);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: tx words = %llu\n",\r\nstats->tx_words);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: rx frames = %llu\n",\r\nstats->rx_frames);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: rx words = %llu\n",\r\nstats->rx_words);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: lip count = %llu\n",\r\nstats->lip_count);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: nos count = %llu\n",\r\nstats->nos_count);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: error frames = %llu\n",\r\nstats->error_frames);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: dumped frames = %llu\n",\r\nstats->dumped_frames);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: link failure count = %llu\n",\r\nstats->link_failure_count);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: loss of sync count = %llu\n",\r\nstats->loss_of_sync_count);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: loss of signal count = %llu\n",\r\nstats->loss_of_signal_count);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: prim seq protocol err count = %llu\n",\r\nstats->prim_seq_protocol_err_count);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: invalid tx word count= %llu\n",\r\nstats->invalid_tx_word_count);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: invalid crc count = %llu\n",\r\nstats->invalid_crc_count);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: fcp input requests = %llu\n",\r\nstats->fcp_input_requests);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: fcp output requests = %llu\n",\r\nstats->fcp_output_requests);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: fcp control requests = %llu\n",\r\nstats->fcp_control_requests);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: fcp input megabytes = %llu\n",\r\nstats->fcp_input_megabytes);\r\nFNIC_MAIN_NOTE(KERN_NOTICE, host,\r\n"fnic: fcp output megabytes = %llu\n",\r\nstats->fcp_output_megabytes);\r\nreturn;\r\n}\r\nstatic void fnic_reset_host_stats(struct Scsi_Host *host)\r\n{\r\nint ret;\r\nstruct fc_lport *lp = shost_priv(host);\r\nstruct fnic *fnic = lport_priv(lp);\r\nstruct fc_host_statistics *stats;\r\nunsigned long flags;\r\nstats = fnic_get_stats(host);\r\nfnic_dump_fchost_stats(host, stats);\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nret = vnic_dev_stats_clear(fnic->vdev);\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nif (ret) {\r\nFNIC_MAIN_DBG(KERN_DEBUG, fnic->lport->host,\r\n"fnic: Reset vnic stats failed"\r\n" 0x%x", ret);\r\nreturn;\r\n}\r\nfnic->stats_reset_time = jiffies;\r\nmemset(stats, 0, sizeof(*stats));\r\nreturn;\r\n}\r\nvoid fnic_log_q_error(struct fnic *fnic)\r\n{\r\nunsigned int i;\r\nu32 error_status;\r\nfor (i = 0; i < fnic->raw_wq_count; i++) {\r\nerror_status = ioread32(&fnic->wq[i].ctrl->error_status);\r\nif (error_status)\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"WQ[%d] error_status"\r\n" %d\n", i, error_status);\r\n}\r\nfor (i = 0; i < fnic->rq_count; i++) {\r\nerror_status = ioread32(&fnic->rq[i].ctrl->error_status);\r\nif (error_status)\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"RQ[%d] error_status"\r\n" %d\n", i, error_status);\r\n}\r\nfor (i = 0; i < fnic->wq_copy_count; i++) {\r\nerror_status = ioread32(&fnic->wq_copy[i].ctrl->error_status);\r\nif (error_status)\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"CWQ[%d] error_status"\r\n" %d\n", i, error_status);\r\n}\r\n}\r\nvoid fnic_handle_link_event(struct fnic *fnic)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nif (fnic->stop_rx_link_events) {\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nqueue_work(fnic_event_queue, &fnic->link_work);\r\n}\r\nstatic int fnic_notify_set(struct fnic *fnic)\r\n{\r\nint err;\r\nswitch (vnic_dev_get_intr_mode(fnic->vdev)) {\r\ncase VNIC_DEV_INTR_MODE_INTX:\r\nerr = vnic_dev_notify_set(fnic->vdev, FNIC_INTX_NOTIFY);\r\nbreak;\r\ncase VNIC_DEV_INTR_MODE_MSI:\r\nerr = vnic_dev_notify_set(fnic->vdev, -1);\r\nbreak;\r\ncase VNIC_DEV_INTR_MODE_MSIX:\r\nerr = vnic_dev_notify_set(fnic->vdev, FNIC_MSIX_ERR_NOTIFY);\r\nbreak;\r\ndefault:\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Interrupt mode should be set up"\r\n" before devcmd notify set %d\n",\r\nvnic_dev_get_intr_mode(fnic->vdev));\r\nerr = -1;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void fnic_notify_timer(unsigned long data)\r\n{\r\nstruct fnic *fnic = (struct fnic *)data;\r\nfnic_handle_link_event(fnic);\r\nmod_timer(&fnic->notify_timer,\r\nround_jiffies(jiffies + FNIC_NOTIFY_TIMER_PERIOD));\r\n}\r\nstatic void fnic_fip_notify_timer(unsigned long data)\r\n{\r\nstruct fnic *fnic = (struct fnic *)data;\r\nfnic_handle_fip_timer(fnic);\r\n}\r\nstatic void fnic_notify_timer_start(struct fnic *fnic)\r\n{\r\nswitch (vnic_dev_get_intr_mode(fnic->vdev)) {\r\ncase VNIC_DEV_INTR_MODE_MSI:\r\nmod_timer(&fnic->notify_timer, jiffies);\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\n}\r\nstatic int fnic_dev_wait(struct vnic_dev *vdev,\r\nint (*start)(struct vnic_dev *, int),\r\nint (*finished)(struct vnic_dev *, int *),\r\nint arg)\r\n{\r\nunsigned long time;\r\nint done;\r\nint err;\r\nint count;\r\ncount = 0;\r\nerr = start(vdev, arg);\r\nif (err)\r\nreturn err;\r\ntime = jiffies + (HZ * 2);\r\ndo {\r\nerr = finished(vdev, &done);\r\ncount++;\r\nif (err)\r\nreturn err;\r\nif (done)\r\nreturn 0;\r\nschedule_timeout_uninterruptible(HZ / 10);\r\n} while (time_after(time, jiffies) || (count < 3));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int fnic_cleanup(struct fnic *fnic)\r\n{\r\nunsigned int i;\r\nint err;\r\nvnic_dev_disable(fnic->vdev);\r\nfor (i = 0; i < fnic->intr_count; i++)\r\nvnic_intr_mask(&fnic->intr[i]);\r\nfor (i = 0; i < fnic->rq_count; i++) {\r\nerr = vnic_rq_disable(&fnic->rq[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = 0; i < fnic->raw_wq_count; i++) {\r\nerr = vnic_wq_disable(&fnic->wq[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = 0; i < fnic->wq_copy_count; i++) {\r\nerr = vnic_wq_copy_disable(&fnic->wq_copy[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nfnic_wq_copy_cmpl_handler(fnic, -1);\r\nfnic_wq_cmpl_handler(fnic, -1);\r\nfnic_rq_cmpl_handler(fnic, -1);\r\nfor (i = 0; i < fnic->raw_wq_count; i++)\r\nvnic_wq_clean(&fnic->wq[i], fnic_free_wq_buf);\r\nfor (i = 0; i < fnic->rq_count; i++)\r\nvnic_rq_clean(&fnic->rq[i], fnic_free_rq_buf);\r\nfor (i = 0; i < fnic->wq_copy_count; i++)\r\nvnic_wq_copy_clean(&fnic->wq_copy[i],\r\nfnic_wq_copy_cleanup_handler);\r\nfor (i = 0; i < fnic->cq_count; i++)\r\nvnic_cq_clean(&fnic->cq[i]);\r\nfor (i = 0; i < fnic->intr_count; i++)\r\nvnic_intr_clean(&fnic->intr[i]);\r\nmempool_destroy(fnic->io_req_pool);\r\nfor (i = 0; i < FNIC_SGL_NUM_CACHES; i++)\r\nmempool_destroy(fnic->io_sgl_pool[i]);\r\nreturn 0;\r\n}\r\nstatic void fnic_iounmap(struct fnic *fnic)\r\n{\r\nif (fnic->bar0.vaddr)\r\niounmap(fnic->bar0.vaddr);\r\n}\r\nstatic u8 *fnic_get_mac(struct fc_lport *lport)\r\n{\r\nstruct fnic *fnic = lport_priv(lport);\r\nreturn fnic->data_src_addr;\r\n}\r\nstatic void fnic_set_vlan(struct fnic *fnic, u16 vlan_id)\r\n{\r\nu16 old_vlan;\r\nold_vlan = vnic_dev_set_default_vlan(fnic->vdev, vlan_id);\r\n}\r\nstatic int fnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct fc_lport *lp;\r\nstruct fnic *fnic;\r\nmempool_t *pool;\r\nint err;\r\nint i;\r\nunsigned long flags;\r\nlp = libfc_host_alloc(&fnic_host_template, sizeof(struct fnic));\r\nif (!lp) {\r\nprintk(KERN_ERR PFX "Unable to alloc libfc local port\n");\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nhost = lp->host;\r\nfnic = lport_priv(lp);\r\nfnic->lport = lp;\r\nfnic->ctlr.lp = lp;\r\nsnprintf(fnic->name, sizeof(fnic->name) - 1, "%s%d", DRV_NAME,\r\nhost->host_no);\r\nhost->transportt = fnic_fc_transport;\r\nerr = fnic_stats_debugfs_init(fnic);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Failed to initialize debugfs for stats\n");\r\nfnic_stats_debugfs_remove(fnic);\r\n}\r\npci_set_drvdata(pdev, fnic);\r\nfnic->pdev = pdev;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Cannot enable PCI device, aborting.\n");\r\ngoto err_out_free_hba;\r\n}\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Cannot enable PCI resources, aborting\n");\r\ngoto err_out_disable_device;\r\n}\r\npci_set_master(pdev);\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (err) {\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"No usable DMA configuration "\r\n"aborting\n");\r\ngoto err_out_release_regions;\r\n}\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Unable to obtain 32-bit DMA "\r\n"for consistent allocations, aborting.\n");\r\ngoto err_out_release_regions;\r\n}\r\n} else {\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Unable to obtain 64-bit DMA "\r\n"for consistent allocations, aborting.\n");\r\ngoto err_out_release_regions;\r\n}\r\n}\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"BAR0 not memory-map'able, aborting.\n");\r\nerr = -ENODEV;\r\ngoto err_out_release_regions;\r\n}\r\nfnic->bar0.vaddr = pci_iomap(pdev, 0, 0);\r\nfnic->bar0.bus_addr = pci_resource_start(pdev, 0);\r\nfnic->bar0.len = pci_resource_len(pdev, 0);\r\nif (!fnic->bar0.vaddr) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Cannot memory-map BAR0 res hdr, "\r\n"aborting.\n");\r\nerr = -ENODEV;\r\ngoto err_out_release_regions;\r\n}\r\nfnic->vdev = vnic_dev_register(NULL, fnic, pdev, &fnic->bar0);\r\nif (!fnic->vdev) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"vNIC registration failed, "\r\n"aborting.\n");\r\nerr = -ENODEV;\r\ngoto err_out_iounmap;\r\n}\r\nerr = fnic_dev_wait(fnic->vdev, vnic_dev_open,\r\nvnic_dev_open_done, 0);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"vNIC dev open failed, aborting.\n");\r\ngoto err_out_vnic_unregister;\r\n}\r\nerr = vnic_dev_init(fnic->vdev, 0);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"vNIC dev init failed, aborting.\n");\r\ngoto err_out_dev_close;\r\n}\r\nerr = vnic_dev_mac_addr(fnic->vdev, fnic->ctlr.ctl_src_addr);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"vNIC get MAC addr failed \n");\r\ngoto err_out_dev_close;\r\n}\r\nmemcpy(fnic->data_src_addr, fnic->ctlr.ctl_src_addr, ETH_ALEN);\r\nerr = fnic_get_vnic_config(fnic);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Get vNIC configuration failed, "\r\n"aborting.\n");\r\ngoto err_out_dev_close;\r\n}\r\nif (fnic->config.io_throttle_count != FNIC_UCSM_DFLT_THROTTLE_CNT_BLD) {\r\nhost->can_queue = min_t(u32, FNIC_MAX_IO_REQ,\r\nmax_t(u32, FNIC_MIN_IO_REQ,\r\nfnic->config.io_throttle_count));\r\n}\r\nfnic->fnic_max_tag_id = host->can_queue;\r\nhost->max_lun = fnic->config.luns_per_tgt;\r\nhost->max_id = FNIC_MAX_FCP_TARGET;\r\nhost->max_cmd_len = FCOE_MAX_CMD_LEN;\r\nfnic_get_res_counts(fnic);\r\nerr = fnic_set_intr_mode(fnic);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Failed to set intr mode, "\r\n"aborting.\n");\r\ngoto err_out_dev_close;\r\n}\r\nerr = fnic_alloc_vnic_resources(fnic);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Failed to alloc vNIC resources, "\r\n"aborting.\n");\r\ngoto err_out_clear_intr;\r\n}\r\nspin_lock_init(&fnic->fnic_lock);\r\nfor (i = 0; i < FNIC_WQ_MAX; i++)\r\nspin_lock_init(&fnic->wq_lock[i]);\r\nfor (i = 0; i < FNIC_WQ_COPY_MAX; i++) {\r\nspin_lock_init(&fnic->wq_copy_lock[i]);\r\nfnic->wq_copy_desc_low[i] = DESC_CLEAN_LOW_WATERMARK;\r\nfnic->fw_ack_recd[i] = 0;\r\nfnic->fw_ack_index[i] = -1;\r\n}\r\nfor (i = 0; i < FNIC_IO_LOCKS; i++)\r\nspin_lock_init(&fnic->io_req_lock[i]);\r\nfnic->io_req_pool = mempool_create_slab_pool(2, fnic_io_req_cache);\r\nif (!fnic->io_req_pool)\r\ngoto err_out_free_resources;\r\npool = mempool_create_slab_pool(2, fnic_sgl_cache[FNIC_SGL_CACHE_DFLT]);\r\nif (!pool)\r\ngoto err_out_free_ioreq_pool;\r\nfnic->io_sgl_pool[FNIC_SGL_CACHE_DFLT] = pool;\r\npool = mempool_create_slab_pool(2, fnic_sgl_cache[FNIC_SGL_CACHE_MAX]);\r\nif (!pool)\r\ngoto err_out_free_dflt_pool;\r\nfnic->io_sgl_pool[FNIC_SGL_CACHE_MAX] = pool;\r\nfnic->vlan_hw_insert = 1;\r\nfnic->vlan_id = 0;\r\nfnic->ctlr.send = fnic_eth_send;\r\nfnic->ctlr.update_mac = fnic_update_mac;\r\nfnic->ctlr.get_src_addr = fnic_get_mac;\r\nif (fnic->config.flags & VFCF_FIP_CAPABLE) {\r\nshost_printk(KERN_INFO, fnic->lport->host,\r\n"firmware supports FIP\n");\r\nvnic_dev_packet_filter(fnic->vdev, 1, 1, 0, 0, 0);\r\nvnic_dev_add_addr(fnic->vdev, FIP_ALL_ENODE_MACS);\r\nvnic_dev_add_addr(fnic->vdev, fnic->ctlr.ctl_src_addr);\r\nfnic->set_vlan = fnic_set_vlan;\r\nfcoe_ctlr_init(&fnic->ctlr, FIP_MODE_AUTO);\r\nsetup_timer(&fnic->fip_timer, fnic_fip_notify_timer,\r\n(unsigned long)fnic);\r\nspin_lock_init(&fnic->vlans_lock);\r\nINIT_WORK(&fnic->fip_frame_work, fnic_handle_fip_frame);\r\nINIT_WORK(&fnic->event_work, fnic_handle_event);\r\nskb_queue_head_init(&fnic->fip_frame_queue);\r\nINIT_LIST_HEAD(&fnic->evlist);\r\nINIT_LIST_HEAD(&fnic->vlans);\r\n} else {\r\nshost_printk(KERN_INFO, fnic->lport->host,\r\n"firmware uses non-FIP mode\n");\r\nfcoe_ctlr_init(&fnic->ctlr, FIP_MODE_NON_FIP);\r\nfnic->ctlr.state = FIP_ST_NON_FIP;\r\n}\r\nfnic->state = FNIC_IN_FC_MODE;\r\natomic_set(&fnic->in_flight, 0);\r\nfnic->state_flags = FNIC_FLAGS_NONE;\r\nfnic_set_nic_config(fnic, 0, 0, 0, 0, 0, 0, 1);\r\nerr = fnic_notify_set(fnic);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Failed to alloc notify buffer, aborting.\n");\r\ngoto err_out_free_max_pool;\r\n}\r\nif (vnic_dev_get_intr_mode(fnic->vdev) == VNIC_DEV_INTR_MODE_MSI)\r\nsetup_timer(&fnic->notify_timer,\r\nfnic_notify_timer, (unsigned long)fnic);\r\nfor (i = 0; i < fnic->rq_count; i++) {\r\nerr = vnic_rq_fill(&fnic->rq[i], fnic_alloc_rq_frame);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"fnic_alloc_rq_frame can't alloc "\r\n"frame\n");\r\ngoto err_out_free_rq_buf;\r\n}\r\n}\r\nerr = scsi_add_host(lp->host, &pdev->dev);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"fnic: scsi_add_host failed...exiting\n");\r\ngoto err_out_free_rq_buf;\r\n}\r\nlp->link_up = 0;\r\nlp->max_retry_count = fnic->config.flogi_retries;\r\nlp->max_rport_retry_count = fnic->config.plogi_retries;\r\nlp->service_params = (FCP_SPPF_INIT_FCN | FCP_SPPF_RD_XRDY_DIS |\r\nFCP_SPPF_CONF_COMPL);\r\nif (fnic->config.flags & VFCF_FCP_SEQ_LVL_ERR)\r\nlp->service_params |= FCP_SPPF_RETRY;\r\nlp->boot_time = jiffies;\r\nlp->e_d_tov = fnic->config.ed_tov;\r\nlp->r_a_tov = fnic->config.ra_tov;\r\nlp->link_supported_speeds = FC_PORTSPEED_10GBIT;\r\nfc_set_wwnn(lp, fnic->config.node_wwn);\r\nfc_set_wwpn(lp, fnic->config.port_wwn);\r\nfcoe_libfc_config(lp, &fnic->ctlr, &fnic_transport_template, 0);\r\nif (!fc_exch_mgr_alloc(lp, FC_CLASS_3, FCPIO_HOST_EXCH_RANGE_START,\r\nFCPIO_HOST_EXCH_RANGE_END, NULL)) {\r\nerr = -ENOMEM;\r\ngoto err_out_remove_scsi_host;\r\n}\r\nfc_lport_init_stats(lp);\r\nfnic->stats_reset_time = jiffies;\r\nfc_lport_config(lp);\r\nif (fc_set_mfs(lp, fnic->config.maxdatafieldsize +\r\nsizeof(struct fc_frame_header))) {\r\nerr = -EINVAL;\r\ngoto err_out_free_exch_mgr;\r\n}\r\nfc_host_maxframe_size(lp->host) = lp->mfs;\r\nfc_host_dev_loss_tmo(lp->host) = fnic->config.port_down_timeout / 1000;\r\nsprintf(fc_host_symbolic_name(lp->host),\r\nDRV_NAME " v" DRV_VERSION " over %s", fnic->name);\r\nspin_lock_irqsave(&fnic_list_lock, flags);\r\nlist_add_tail(&fnic->list, &fnic_list);\r\nspin_unlock_irqrestore(&fnic_list_lock, flags);\r\nINIT_WORK(&fnic->link_work, fnic_handle_link);\r\nINIT_WORK(&fnic->frame_work, fnic_handle_frame);\r\nskb_queue_head_init(&fnic->frame_queue);\r\nskb_queue_head_init(&fnic->tx_queue);\r\nfor (i = 0; i < fnic->raw_wq_count; i++)\r\nvnic_wq_enable(&fnic->wq[i]);\r\nfor (i = 0; i < fnic->rq_count; i++)\r\nvnic_rq_enable(&fnic->rq[i]);\r\nfor (i = 0; i < fnic->wq_copy_count; i++)\r\nvnic_wq_copy_enable(&fnic->wq_copy[i]);\r\nfc_fabric_login(lp);\r\nvnic_dev_enable(fnic->vdev);\r\nerr = fnic_request_intr(fnic);\r\nif (err) {\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"Unable to request irq.\n");\r\ngoto err_out_free_exch_mgr;\r\n}\r\nfor (i = 0; i < fnic->intr_count; i++)\r\nvnic_intr_unmask(&fnic->intr[i]);\r\nfnic_notify_timer_start(fnic);\r\nreturn 0;\r\nerr_out_free_exch_mgr:\r\nfc_exch_mgr_free(lp);\r\nerr_out_remove_scsi_host:\r\nfc_remove_host(lp->host);\r\nscsi_remove_host(lp->host);\r\nerr_out_free_rq_buf:\r\nfor (i = 0; i < fnic->rq_count; i++)\r\nvnic_rq_clean(&fnic->rq[i], fnic_free_rq_buf);\r\nvnic_dev_notify_unset(fnic->vdev);\r\nerr_out_free_max_pool:\r\nmempool_destroy(fnic->io_sgl_pool[FNIC_SGL_CACHE_MAX]);\r\nerr_out_free_dflt_pool:\r\nmempool_destroy(fnic->io_sgl_pool[FNIC_SGL_CACHE_DFLT]);\r\nerr_out_free_ioreq_pool:\r\nmempool_destroy(fnic->io_req_pool);\r\nerr_out_free_resources:\r\nfnic_free_vnic_resources(fnic);\r\nerr_out_clear_intr:\r\nfnic_clear_intr_mode(fnic);\r\nerr_out_dev_close:\r\nvnic_dev_close(fnic->vdev);\r\nerr_out_vnic_unregister:\r\nvnic_dev_unregister(fnic->vdev);\r\nerr_out_iounmap:\r\nfnic_iounmap(fnic);\r\nerr_out_release_regions:\r\npci_release_regions(pdev);\r\nerr_out_disable_device:\r\npci_disable_device(pdev);\r\nerr_out_free_hba:\r\nfnic_stats_debugfs_remove(fnic);\r\nscsi_host_put(lp->host);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void fnic_remove(struct pci_dev *pdev)\r\n{\r\nstruct fnic *fnic = pci_get_drvdata(pdev);\r\nstruct fc_lport *lp = fnic->lport;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nfnic->stop_rx_link_events = 1;\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nif (vnic_dev_get_intr_mode(fnic->vdev) == VNIC_DEV_INTR_MODE_MSI)\r\ndel_timer_sync(&fnic->notify_timer);\r\nflush_workqueue(fnic_event_queue);\r\nskb_queue_purge(&fnic->frame_queue);\r\nskb_queue_purge(&fnic->tx_queue);\r\nif (fnic->config.flags & VFCF_FIP_CAPABLE) {\r\ndel_timer_sync(&fnic->fip_timer);\r\nskb_queue_purge(&fnic->fip_frame_queue);\r\nfnic_fcoe_reset_vlans(fnic);\r\nfnic_fcoe_evlist_free(fnic);\r\n}\r\nfc_fabric_logoff(fnic->lport);\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nfnic->in_remove = 1;\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nfcoe_ctlr_destroy(&fnic->ctlr);\r\nfc_lport_destroy(lp);\r\nfnic_stats_debugfs_remove(fnic);\r\nfnic_cleanup(fnic);\r\nBUG_ON(!skb_queue_empty(&fnic->frame_queue));\r\nBUG_ON(!skb_queue_empty(&fnic->tx_queue));\r\nspin_lock_irqsave(&fnic_list_lock, flags);\r\nlist_del(&fnic->list);\r\nspin_unlock_irqrestore(&fnic_list_lock, flags);\r\nfc_remove_host(fnic->lport->host);\r\nscsi_remove_host(fnic->lport->host);\r\nfc_exch_mgr_free(fnic->lport);\r\nvnic_dev_notify_unset(fnic->vdev);\r\nfnic_free_intr(fnic);\r\nfnic_free_vnic_resources(fnic);\r\nfnic_clear_intr_mode(fnic);\r\nvnic_dev_close(fnic->vdev);\r\nvnic_dev_unregister(fnic->vdev);\r\nfnic_iounmap(fnic);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nscsi_host_put(lp->host);\r\n}\r\nstatic int __init fnic_init_module(void)\r\n{\r\nsize_t len;\r\nint err = 0;\r\nprintk(KERN_INFO PFX "%s, ver %s\n", DRV_DESCRIPTION, DRV_VERSION);\r\nerr = fnic_debugfs_init();\r\nif (err < 0) {\r\nprintk(KERN_ERR PFX "Failed to create fnic directory "\r\n"for tracing and stats logging\n");\r\nfnic_debugfs_terminate();\r\n}\r\nerr = fnic_trace_buf_init();\r\nif (err < 0) {\r\nprintk(KERN_ERR PFX\r\n"Trace buffer initialization Failed. "\r\n"Fnic Tracing utility is disabled\n");\r\nfnic_trace_free();\r\n}\r\nerr = fnic_fc_trace_init();\r\nif (err < 0) {\r\nprintk(KERN_ERR PFX "FC trace buffer initialization Failed "\r\n"FC frame tracing utility is disabled\n");\r\nfnic_fc_trace_free();\r\n}\r\nlen = sizeof(struct fnic_dflt_sgl_list);\r\nfnic_sgl_cache[FNIC_SGL_CACHE_DFLT] = kmem_cache_create\r\n("fnic_sgl_dflt", len + FNIC_SG_DESC_ALIGN, FNIC_SG_DESC_ALIGN,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!fnic_sgl_cache[FNIC_SGL_CACHE_DFLT]) {\r\nprintk(KERN_ERR PFX "failed to create fnic dflt sgl slab\n");\r\nerr = -ENOMEM;\r\ngoto err_create_fnic_sgl_slab_dflt;\r\n}\r\nlen = sizeof(struct fnic_sgl_list);\r\nfnic_sgl_cache[FNIC_SGL_CACHE_MAX] = kmem_cache_create\r\n("fnic_sgl_max", len + FNIC_SG_DESC_ALIGN, FNIC_SG_DESC_ALIGN,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!fnic_sgl_cache[FNIC_SGL_CACHE_MAX]) {\r\nprintk(KERN_ERR PFX "failed to create fnic max sgl slab\n");\r\nerr = -ENOMEM;\r\ngoto err_create_fnic_sgl_slab_max;\r\n}\r\nfnic_io_req_cache = kmem_cache_create("fnic_io_req",\r\nsizeof(struct fnic_io_req),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (!fnic_io_req_cache) {\r\nprintk(KERN_ERR PFX "failed to create fnic io_req slab\n");\r\nerr = -ENOMEM;\r\ngoto err_create_fnic_ioreq_slab;\r\n}\r\nfnic_event_queue = create_singlethread_workqueue("fnic_event_wq");\r\nif (!fnic_event_queue) {\r\nprintk(KERN_ERR PFX "fnic work queue create failed\n");\r\nerr = -ENOMEM;\r\ngoto err_create_fnic_workq;\r\n}\r\nspin_lock_init(&fnic_list_lock);\r\nINIT_LIST_HEAD(&fnic_list);\r\nfnic_fip_queue = create_singlethread_workqueue("fnic_fip_q");\r\nif (!fnic_fip_queue) {\r\nprintk(KERN_ERR PFX "fnic FIP work queue create failed\n");\r\nerr = -ENOMEM;\r\ngoto err_create_fip_workq;\r\n}\r\nfnic_fc_transport = fc_attach_transport(&fnic_fc_functions);\r\nif (!fnic_fc_transport) {\r\nprintk(KERN_ERR PFX "fc_attach_transport error\n");\r\nerr = -ENOMEM;\r\ngoto err_fc_transport;\r\n}\r\nerr = pci_register_driver(&fnic_driver);\r\nif (err < 0) {\r\nprintk(KERN_ERR PFX "pci register error\n");\r\ngoto err_pci_register;\r\n}\r\nreturn err;\r\nerr_pci_register:\r\nfc_release_transport(fnic_fc_transport);\r\nerr_fc_transport:\r\ndestroy_workqueue(fnic_fip_queue);\r\nerr_create_fip_workq:\r\ndestroy_workqueue(fnic_event_queue);\r\nerr_create_fnic_workq:\r\nkmem_cache_destroy(fnic_io_req_cache);\r\nerr_create_fnic_ioreq_slab:\r\nkmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_MAX]);\r\nerr_create_fnic_sgl_slab_max:\r\nkmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_DFLT]);\r\nerr_create_fnic_sgl_slab_dflt:\r\nfnic_trace_free();\r\nfnic_fc_trace_free();\r\nfnic_debugfs_terminate();\r\nreturn err;\r\n}\r\nstatic void __exit fnic_cleanup_module(void)\r\n{\r\npci_unregister_driver(&fnic_driver);\r\ndestroy_workqueue(fnic_event_queue);\r\nif (fnic_fip_queue) {\r\nflush_workqueue(fnic_fip_queue);\r\ndestroy_workqueue(fnic_fip_queue);\r\n}\r\nkmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_MAX]);\r\nkmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_DFLT]);\r\nkmem_cache_destroy(fnic_io_req_cache);\r\nfc_release_transport(fnic_fc_transport);\r\nfnic_trace_free();\r\nfnic_fc_trace_free();\r\nfnic_debugfs_terminate();\r\n}
