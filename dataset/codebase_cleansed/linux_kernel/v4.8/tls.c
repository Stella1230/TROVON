static int get_free_idx(void)\r\n{\r\nstruct thread_struct *t = &current->thread;\r\nint idx;\r\nfor (idx = 0; idx < GDT_ENTRY_TLS_ENTRIES; idx++)\r\nif (desc_empty(&t->tls_array[idx]))\r\nreturn idx + GDT_ENTRY_TLS_MIN;\r\nreturn -ESRCH;\r\n}\r\nstatic bool tls_desc_okay(const struct user_desc *info)\r\n{\r\nif (LDT_empty(info) || LDT_zero(info))\r\nreturn true;\r\nif (!info->seg_32bit)\r\nreturn false;\r\nif (info->contents > 1)\r\nreturn false;\r\nif (info->seg_not_present)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void set_tls_desc(struct task_struct *p, int idx,\r\nconst struct user_desc *info, int n)\r\n{\r\nstruct thread_struct *t = &p->thread;\r\nstruct desc_struct *desc = &t->tls_array[idx - GDT_ENTRY_TLS_MIN];\r\nint cpu;\r\ncpu = get_cpu();\r\nwhile (n-- > 0) {\r\nif (LDT_empty(info) || LDT_zero(info))\r\ndesc->a = desc->b = 0;\r\nelse\r\nfill_ldt(desc, info);\r\n++info;\r\n++desc;\r\n}\r\nif (t == &current->thread)\r\nload_TLS(t, cpu);\r\nput_cpu();\r\n}\r\nint do_set_thread_area(struct task_struct *p, int idx,\r\nstruct user_desc __user *u_info,\r\nint can_allocate)\r\n{\r\nstruct user_desc info;\r\nunsigned short __maybe_unused sel, modified_sel;\r\nif (copy_from_user(&info, u_info, sizeof(info)))\r\nreturn -EFAULT;\r\nif (!tls_desc_okay(&info))\r\nreturn -EINVAL;\r\nif (idx == -1)\r\nidx = info.entry_number;\r\nif (idx == -1 && can_allocate) {\r\nidx = get_free_idx();\r\nif (idx < 0)\r\nreturn idx;\r\nif (put_user(idx, &u_info->entry_number))\r\nreturn -EFAULT;\r\n}\r\nif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\r\nreturn -EINVAL;\r\nset_tls_desc(p, idx, &info, 1);\r\nmodified_sel = (idx << 3) | 3;\r\nif (p == current) {\r\n#ifdef CONFIG_X86_64\r\nsavesegment(ds, sel);\r\nif (sel == modified_sel)\r\nloadsegment(ds, sel);\r\nsavesegment(es, sel);\r\nif (sel == modified_sel)\r\nloadsegment(es, sel);\r\nsavesegment(fs, sel);\r\nif (sel == modified_sel)\r\nloadsegment(fs, sel);\r\nsavesegment(gs, sel);\r\nif (sel == modified_sel)\r\nload_gs_index(sel);\r\n#endif\r\n#ifdef CONFIG_X86_32_LAZY_GS\r\nsavesegment(gs, sel);\r\nif (sel == modified_sel)\r\nloadsegment(gs, sel);\r\n#endif\r\n} else {\r\n#ifdef CONFIG_X86_64\r\nif (p->thread.fsindex == modified_sel)\r\np->thread.fsbase = info.base_addr;\r\nif (p->thread.gsindex == modified_sel)\r\np->thread.gsbase = info.base_addr;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void fill_user_desc(struct user_desc *info, int idx,\r\nconst struct desc_struct *desc)\r\n{\r\nmemset(info, 0, sizeof(*info));\r\ninfo->entry_number = idx;\r\ninfo->base_addr = get_desc_base(desc);\r\ninfo->limit = get_desc_limit(desc);\r\ninfo->seg_32bit = desc->d;\r\ninfo->contents = desc->type >> 2;\r\ninfo->read_exec_only = !(desc->type & 2);\r\ninfo->limit_in_pages = desc->g;\r\ninfo->seg_not_present = !desc->p;\r\ninfo->useable = desc->avl;\r\n#ifdef CONFIG_X86_64\r\ninfo->lm = desc->l;\r\n#endif\r\n}\r\nint do_get_thread_area(struct task_struct *p, int idx,\r\nstruct user_desc __user *u_info)\r\n{\r\nstruct user_desc info;\r\nif (idx == -1 && get_user(idx, &u_info->entry_number))\r\nreturn -EFAULT;\r\nif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\r\nreturn -EINVAL;\r\nfill_user_desc(&info, idx,\r\n&p->thread.tls_array[idx - GDT_ENTRY_TLS_MIN]);\r\nif (copy_to_user(u_info, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint regset_tls_active(struct task_struct *target,\r\nconst struct user_regset *regset)\r\n{\r\nstruct thread_struct *t = &target->thread;\r\nint n = GDT_ENTRY_TLS_ENTRIES;\r\nwhile (n > 0 && desc_empty(&t->tls_array[n - 1]))\r\n--n;\r\nreturn n;\r\n}\r\nint regset_tls_get(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nconst struct desc_struct *tls;\r\nif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\r\n(pos % sizeof(struct user_desc)) != 0 ||\r\n(count % sizeof(struct user_desc)) != 0)\r\nreturn -EINVAL;\r\npos /= sizeof(struct user_desc);\r\ncount /= sizeof(struct user_desc);\r\ntls = &target->thread.tls_array[pos];\r\nif (kbuf) {\r\nstruct user_desc *info = kbuf;\r\nwhile (count-- > 0)\r\nfill_user_desc(info++, GDT_ENTRY_TLS_MIN + pos++,\r\ntls++);\r\n} else {\r\nstruct user_desc __user *u_info = ubuf;\r\nwhile (count-- > 0) {\r\nstruct user_desc info;\r\nfill_user_desc(&info, GDT_ENTRY_TLS_MIN + pos++, tls++);\r\nif (__copy_to_user(u_info++, &info, sizeof(info)))\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint regset_tls_set(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\r\nconst struct user_desc *info;\r\nint i;\r\nif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\r\n(pos % sizeof(struct user_desc)) != 0 ||\r\n(count % sizeof(struct user_desc)) != 0)\r\nreturn -EINVAL;\r\nif (kbuf)\r\ninfo = kbuf;\r\nelse if (__copy_from_user(infobuf, ubuf, count))\r\nreturn -EFAULT;\r\nelse\r\ninfo = infobuf;\r\nfor (i = 0; i < count / sizeof(struct user_desc); i++)\r\nif (!tls_desc_okay(info + i))\r\nreturn -EINVAL;\r\nset_tls_desc(target,\r\nGDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\r\ninfo, count / sizeof(struct user_desc));\r\nreturn 0;\r\n}
