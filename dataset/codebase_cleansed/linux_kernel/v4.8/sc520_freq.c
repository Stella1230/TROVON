static unsigned int sc520_freq_get_cpu_frequency(unsigned int cpu)\r\n{\r\nu8 clockspeed_reg = *cpuctl;\r\nswitch (clockspeed_reg & 0x03) {\r\ndefault:\r\npr_err("error: cpuctl register has unexpected value %02x\n",\r\nclockspeed_reg);\r\ncase 0x01:\r\nreturn 100000;\r\ncase 0x02:\r\nreturn 133000;\r\n}\r\n}\r\nstatic int sc520_freq_target(struct cpufreq_policy *policy, unsigned int state)\r\n{\r\nu8 clockspeed_reg;\r\nlocal_irq_disable();\r\nclockspeed_reg = *cpuctl & ~0x03;\r\n*cpuctl = clockspeed_reg | sc520_freq_table[state].driver_data;\r\nlocal_irq_enable();\r\nreturn 0;\r\n}\r\nstatic int sc520_freq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nif (c->x86_vendor != X86_VENDOR_AMD ||\r\nc->x86 != 4 || c->x86_model != 9)\r\nreturn -ENODEV;\r\npolicy->cpuinfo.transition_latency = 1000000;\r\nreturn cpufreq_table_validate_and_show(policy, sc520_freq_table);\r\n}\r\nstatic int __init sc520_freq_init(void)\r\n{\r\nint err;\r\nif (!x86_match_cpu(sc520_ids))\r\nreturn -ENODEV;\r\ncpuctl = ioremap((unsigned long)(MMCR_BASE + OFFS_CPUCTL), 1);\r\nif (!cpuctl) {\r\npr_err("sc520_freq: error: failed to remap memory\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = cpufreq_register_driver(&sc520_freq_driver);\r\nif (err)\r\niounmap(cpuctl);\r\nreturn err;\r\n}\r\nstatic void __exit sc520_freq_exit(void)\r\n{\r\ncpufreq_unregister_driver(&sc520_freq_driver);\r\niounmap(cpuctl);\r\n}
