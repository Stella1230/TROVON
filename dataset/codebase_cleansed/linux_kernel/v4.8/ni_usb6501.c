static int ni6501_port_command(struct comedi_device *dev, int command,\r\nunsigned int val, u8 *bitmap)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct ni6501_private *devpriv = dev->private;\r\nint request_size, response_size;\r\nu8 *tx = devpriv->usb_tx_buf;\r\nint ret;\r\nif (command != SET_PORT_DIR && !bitmap)\r\nreturn -EINVAL;\r\nmutex_lock(&devpriv->mut);\r\nswitch (command) {\r\ncase READ_PORT:\r\nrequest_size = sizeof(READ_PORT_REQUEST);\r\nresponse_size = sizeof(READ_PORT_RESPONSE);\r\nmemcpy(tx, READ_PORT_REQUEST, request_size);\r\ntx[14] = val & 0xff;\r\nbreak;\r\ncase WRITE_PORT:\r\nrequest_size = sizeof(WRITE_PORT_REQUEST);\r\nresponse_size = sizeof(GENERIC_RESPONSE);\r\nmemcpy(tx, WRITE_PORT_REQUEST, request_size);\r\ntx[14] = val & 0xff;\r\ntx[17] = *bitmap;\r\nbreak;\r\ncase SET_PORT_DIR:\r\nrequest_size = sizeof(SET_PORT_DIR_REQUEST);\r\nresponse_size = sizeof(GENERIC_RESPONSE);\r\nmemcpy(tx, SET_PORT_DIR_REQUEST, request_size);\r\ntx[14] = val & 0xff;\r\ntx[15] = (val >> 8) & 0xff;\r\ntx[16] = (val >> 16) & 0xff;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\nret = usb_bulk_msg(usb,\r\nusb_sndbulkpipe(usb,\r\ndevpriv->ep_tx->bEndpointAddress),\r\ndevpriv->usb_tx_buf,\r\nrequest_size,\r\nNULL,\r\nNI6501_TIMEOUT);\r\nif (ret)\r\ngoto end;\r\nret = usb_bulk_msg(usb,\r\nusb_rcvbulkpipe(usb,\r\ndevpriv->ep_rx->bEndpointAddress),\r\ndevpriv->usb_rx_buf,\r\nresponse_size,\r\nNULL,\r\nNI6501_TIMEOUT);\r\nif (ret)\r\ngoto end;\r\nif (command == READ_PORT) {\r\n*bitmap = devpriv->usb_rx_buf[14];\r\ndevpriv->usb_rx_buf[14] = 0x00;\r\nif (memcmp(devpriv->usb_rx_buf, READ_PORT_RESPONSE,\r\nsizeof(READ_PORT_RESPONSE))) {\r\nret = -EINVAL;\r\n}\r\n} else if (memcmp(devpriv->usb_rx_buf, GENERIC_RESPONSE,\r\nsizeof(GENERIC_RESPONSE))) {\r\nret = -EINVAL;\r\n}\r\nend:\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\nstatic int ni6501_counter_command(struct comedi_device *dev, int command,\r\nu32 *val)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct ni6501_private *devpriv = dev->private;\r\nint request_size, response_size;\r\nu8 *tx = devpriv->usb_tx_buf;\r\nint ret;\r\nif ((command == READ_COUNTER || command == WRITE_COUNTER) && !val)\r\nreturn -EINVAL;\r\nmutex_lock(&devpriv->mut);\r\nswitch (command) {\r\ncase START_COUNTER:\r\nrequest_size = sizeof(START_COUNTER_REQUEST);\r\nresponse_size = sizeof(GENERIC_RESPONSE);\r\nmemcpy(tx, START_COUNTER_REQUEST, request_size);\r\nbreak;\r\ncase STOP_COUNTER:\r\nrequest_size = sizeof(STOP_COUNTER_REQUEST);\r\nresponse_size = sizeof(GENERIC_RESPONSE);\r\nmemcpy(tx, STOP_COUNTER_REQUEST, request_size);\r\nbreak;\r\ncase READ_COUNTER:\r\nrequest_size = sizeof(READ_COUNTER_REQUEST);\r\nresponse_size = sizeof(READ_COUNTER_RESPONSE);\r\nmemcpy(tx, READ_COUNTER_REQUEST, request_size);\r\nbreak;\r\ncase WRITE_COUNTER:\r\nrequest_size = sizeof(WRITE_COUNTER_REQUEST);\r\nresponse_size = sizeof(GENERIC_RESPONSE);\r\nmemcpy(tx, WRITE_COUNTER_REQUEST, request_size);\r\n*((__be32 *)&tx[12]) = cpu_to_be32(*val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\nret = usb_bulk_msg(usb,\r\nusb_sndbulkpipe(usb,\r\ndevpriv->ep_tx->bEndpointAddress),\r\ndevpriv->usb_tx_buf,\r\nrequest_size,\r\nNULL,\r\nNI6501_TIMEOUT);\r\nif (ret)\r\ngoto end;\r\nret = usb_bulk_msg(usb,\r\nusb_rcvbulkpipe(usb,\r\ndevpriv->ep_rx->bEndpointAddress),\r\ndevpriv->usb_rx_buf,\r\nresponse_size,\r\nNULL,\r\nNI6501_TIMEOUT);\r\nif (ret)\r\ngoto end;\r\nif (command == READ_COUNTER) {\r\nint i;\r\n*val = be32_to_cpu(*((__be32 *)&devpriv->usb_rx_buf[12]));\r\nfor (i = 12; i < sizeof(READ_COUNTER_RESPONSE); ++i)\r\ndevpriv->usb_rx_buf[i] = 0x00;\r\nif (memcmp(devpriv->usb_rx_buf, READ_COUNTER_RESPONSE,\r\nsizeof(READ_COUNTER_RESPONSE))) {\r\nret = -EINVAL;\r\n}\r\n} else if (memcmp(devpriv->usb_rx_buf, GENERIC_RESPONSE,\r\nsizeof(GENERIC_RESPONSE))) {\r\nret = -EINVAL;\r\n}\r\nend:\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\nstatic int ni6501_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nret = ni6501_port_command(dev, SET_PORT_DIR, s->io_bits, NULL);\r\nif (ret)\r\nreturn ret;\r\nreturn insn->n;\r\n}\r\nstatic int ni6501_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int mask;\r\nint ret;\r\nu8 port;\r\nu8 bitmap;\r\nmask = comedi_dio_update_state(s, data);\r\nfor (port = 0; port < 3; port++) {\r\nif (mask & (0xFF << port * 8)) {\r\nbitmap = (s->state >> port * 8) & 0xFF;\r\nret = ni6501_port_command(dev, WRITE_PORT,\r\nport, &bitmap);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\ndata[1] = 0;\r\nfor (port = 0; port < 3; port++) {\r\nret = ni6501_port_command(dev, READ_PORT, port, &bitmap);\r\nif (ret)\r\nreturn ret;\r\ndata[1] |= bitmap << port * 8;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ni6501_cnt_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nu32 val = 0;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_ARM:\r\nret = ni6501_counter_command(dev, START_COUNTER, NULL);\r\nbreak;\r\ncase INSN_CONFIG_DISARM:\r\nret = ni6501_counter_command(dev, STOP_COUNTER, NULL);\r\nbreak;\r\ncase INSN_CONFIG_RESET:\r\nret = ni6501_counter_command(dev, STOP_COUNTER, NULL);\r\nif (ret)\r\nbreak;\r\nret = ni6501_counter_command(dev, WRITE_COUNTER, &val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int ni6501_cnt_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nu32 val;\r\nunsigned int i;\r\nfor (i = 0; i < insn->n; i++) {\r\nret = ni6501_counter_command(dev, READ_COUNTER, &val);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ni6501_cnt_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nif (insn->n) {\r\nu32 val = data[insn->n - 1];\r\nret = ni6501_counter_command(dev, WRITE_COUNTER, &val);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ni6501_alloc_usb_buffers(struct comedi_device *dev)\r\n{\r\nstruct ni6501_private *devpriv = dev->private;\r\nsize_t size;\r\nsize = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);\r\ndevpriv->usb_rx_buf = kzalloc(size, GFP_KERNEL);\r\nif (!devpriv->usb_rx_buf)\r\nreturn -ENOMEM;\r\nsize = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);\r\ndevpriv->usb_tx_buf = kzalloc(size, GFP_KERNEL);\r\nif (!devpriv->usb_tx_buf) {\r\nkfree(devpriv->usb_rx_buf);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni6501_find_endpoints(struct comedi_device *dev)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct ni6501_private *devpriv = dev->private;\r\nstruct usb_host_interface *iface_desc = intf->cur_altsetting;\r\nstruct usb_endpoint_descriptor *ep_desc;\r\nint i;\r\nif (iface_desc->desc.bNumEndpoints != 2) {\r\ndev_err(dev->class_dev, "Wrong number of endpoints\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\r\nep_desc = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_bulk_in(ep_desc)) {\r\nif (!devpriv->ep_rx)\r\ndevpriv->ep_rx = ep_desc;\r\ncontinue;\r\n}\r\nif (usb_endpoint_is_bulk_out(ep_desc)) {\r\nif (!devpriv->ep_tx)\r\ndevpriv->ep_tx = ep_desc;\r\ncontinue;\r\n}\r\n}\r\nif (!devpriv->ep_rx || !devpriv->ep_tx)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int ni6501_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct ni6501_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = ni6501_find_endpoints(dev);\r\nif (ret)\r\nreturn ret;\r\nret = ni6501_alloc_usb_buffers(dev);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&devpriv->mut);\r\nusb_set_intfdata(intf, devpriv);\r\nret = comedi_alloc_subdevices(dev, 2);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 24;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = ni6501_dio_insn_bits;\r\ns->insn_config = ni6501_dio_insn_config;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;\r\ns->n_chan = 1;\r\ns->maxdata = 0xffffffff;\r\ns->insn_read = ni6501_cnt_insn_read;\r\ns->insn_write = ni6501_cnt_insn_write;\r\ns->insn_config = ni6501_cnt_insn_config;\r\nreturn 0;\r\n}\r\nstatic void ni6501_detach(struct comedi_device *dev)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct ni6501_private *devpriv = dev->private;\r\nif (!devpriv)\r\nreturn;\r\nmutex_lock(&devpriv->mut);\r\nusb_set_intfdata(intf, NULL);\r\nkfree(devpriv->usb_rx_buf);\r\nkfree(devpriv->usb_tx_buf);\r\nmutex_unlock(&devpriv->mut);\r\n}\r\nstatic int ni6501_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn comedi_usb_auto_config(intf, &ni6501_driver, id->driver_info);\r\n}
