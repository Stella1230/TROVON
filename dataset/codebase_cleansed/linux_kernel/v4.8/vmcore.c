int register_oldmem_pfn_is_ram(int (*fn)(unsigned long pfn))\r\n{\r\nif (oldmem_pfn_is_ram)\r\nreturn -EBUSY;\r\noldmem_pfn_is_ram = fn;\r\nreturn 0;\r\n}\r\nvoid unregister_oldmem_pfn_is_ram(void)\r\n{\r\noldmem_pfn_is_ram = NULL;\r\nwmb();\r\n}\r\nstatic int pfn_is_ram(unsigned long pfn)\r\n{\r\nint (*fn)(unsigned long pfn);\r\nint ret = 1;\r\nfn = oldmem_pfn_is_ram;\r\nif (fn)\r\nret = fn(pfn);\r\nreturn ret;\r\n}\r\nstatic ssize_t read_from_oldmem(char *buf, size_t count,\r\nu64 *ppos, int userbuf)\r\n{\r\nunsigned long pfn, offset;\r\nsize_t nr_bytes;\r\nssize_t read = 0, tmp;\r\nif (!count)\r\nreturn 0;\r\noffset = (unsigned long)(*ppos % PAGE_SIZE);\r\npfn = (unsigned long)(*ppos / PAGE_SIZE);\r\ndo {\r\nif (count > (PAGE_SIZE - offset))\r\nnr_bytes = PAGE_SIZE - offset;\r\nelse\r\nnr_bytes = count;\r\nif (pfn_is_ram(pfn) == 0)\r\nmemset(buf, 0, nr_bytes);\r\nelse {\r\ntmp = copy_oldmem_page(pfn, buf, nr_bytes,\r\noffset, userbuf);\r\nif (tmp < 0)\r\nreturn tmp;\r\n}\r\n*ppos += nr_bytes;\r\ncount -= nr_bytes;\r\nbuf += nr_bytes;\r\nread += nr_bytes;\r\n++pfn;\r\noffset = 0;\r\n} while (count);\r\nreturn read;\r\n}\r\nint __weak elfcorehdr_alloc(unsigned long long *addr, unsigned long long *size)\r\n{\r\nreturn 0;\r\n}\r\nvoid __weak elfcorehdr_free(unsigned long long addr)\r\n{}\r\nssize_t __weak elfcorehdr_read(char *buf, size_t count, u64 *ppos)\r\n{\r\nreturn read_from_oldmem(buf, count, ppos, 0);\r\n}\r\nssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)\r\n{\r\nreturn read_from_oldmem(buf, count, ppos, 0);\r\n}\r\nint __weak remap_oldmem_pfn_range(struct vm_area_struct *vma,\r\nunsigned long from, unsigned long pfn,\r\nunsigned long size, pgprot_t prot)\r\n{\r\nreturn remap_pfn_range(vma, from, pfn, size, prot);\r\n}\r\nstatic int copy_to(void *target, void *src, size_t size, int userbuf)\r\n{\r\nif (userbuf) {\r\nif (copy_to_user((char __user *) target, src, size))\r\nreturn -EFAULT;\r\n} else {\r\nmemcpy(target, src, size);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t __read_vmcore(char *buffer, size_t buflen, loff_t *fpos,\r\nint userbuf)\r\n{\r\nssize_t acc = 0, tmp;\r\nsize_t tsz;\r\nu64 start;\r\nstruct vmcore *m = NULL;\r\nif (buflen == 0 || *fpos >= vmcore_size)\r\nreturn 0;\r\nif (buflen > vmcore_size - *fpos)\r\nbuflen = vmcore_size - *fpos;\r\nif (*fpos < elfcorebuf_sz) {\r\ntsz = min(elfcorebuf_sz - (size_t)*fpos, buflen);\r\nif (copy_to(buffer, elfcorebuf + *fpos, tsz, userbuf))\r\nreturn -EFAULT;\r\nbuflen -= tsz;\r\n*fpos += tsz;\r\nbuffer += tsz;\r\nacc += tsz;\r\nif (buflen == 0)\r\nreturn acc;\r\n}\r\nif (*fpos < elfcorebuf_sz + elfnotes_sz) {\r\nvoid *kaddr;\r\ntsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)*fpos, buflen);\r\nkaddr = elfnotes_buf + *fpos - elfcorebuf_sz;\r\nif (copy_to(buffer, kaddr, tsz, userbuf))\r\nreturn -EFAULT;\r\nbuflen -= tsz;\r\n*fpos += tsz;\r\nbuffer += tsz;\r\nacc += tsz;\r\nif (buflen == 0)\r\nreturn acc;\r\n}\r\nlist_for_each_entry(m, &vmcore_list, list) {\r\nif (*fpos < m->offset + m->size) {\r\ntsz = (size_t)min_t(unsigned long long,\r\nm->offset + m->size - *fpos,\r\nbuflen);\r\nstart = m->paddr + *fpos - m->offset;\r\ntmp = read_from_oldmem(buffer, tsz, &start, userbuf);\r\nif (tmp < 0)\r\nreturn tmp;\r\nbuflen -= tsz;\r\n*fpos += tsz;\r\nbuffer += tsz;\r\nacc += tsz;\r\nif (buflen == 0)\r\nreturn acc;\r\n}\r\n}\r\nreturn acc;\r\n}\r\nstatic ssize_t read_vmcore(struct file *file, char __user *buffer,\r\nsize_t buflen, loff_t *fpos)\r\n{\r\nreturn __read_vmcore((__force char *) buffer, buflen, fpos, 1);\r\n}\r\nstatic int mmap_vmcore_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\n#ifdef CONFIG_S390\r\nstruct address_space *mapping = vma->vm_file->f_mapping;\r\npgoff_t index = vmf->pgoff;\r\nstruct page *page;\r\nloff_t offset;\r\nchar *buf;\r\nint rc;\r\npage = find_or_create_page(mapping, index, GFP_KERNEL);\r\nif (!page)\r\nreturn VM_FAULT_OOM;\r\nif (!PageUptodate(page)) {\r\noffset = (loff_t) index << PAGE_SHIFT;\r\nbuf = __va((page_to_pfn(page) << PAGE_SHIFT));\r\nrc = __read_vmcore(buf, PAGE_SIZE, &offset, 0);\r\nif (rc < 0) {\r\nunlock_page(page);\r\nput_page(page);\r\nreturn (rc == -ENOMEM) ? VM_FAULT_OOM : VM_FAULT_SIGBUS;\r\n}\r\nSetPageUptodate(page);\r\n}\r\nunlock_page(page);\r\nvmf->page = page;\r\nreturn 0;\r\n#else\r\nreturn VM_FAULT_SIGBUS;\r\n#endif\r\n}\r\nstatic inline char *alloc_elfnotes_buf(size_t notes_sz)\r\n{\r\n#ifdef CONFIG_MMU\r\nreturn vmalloc_user(notes_sz);\r\n#else\r\nreturn vzalloc(notes_sz);\r\n#endif\r\n}\r\nstatic int remap_oldmem_pfn_checked(struct vm_area_struct *vma,\r\nunsigned long from, unsigned long pfn,\r\nunsigned long size, pgprot_t prot)\r\n{\r\nunsigned long map_size;\r\nunsigned long pos_start, pos_end, pos;\r\nunsigned long zeropage_pfn = my_zero_pfn(0);\r\nsize_t len = 0;\r\npos_start = pfn;\r\npos_end = pfn + (size >> PAGE_SHIFT);\r\nfor (pos = pos_start; pos < pos_end; ++pos) {\r\nif (!pfn_is_ram(pos)) {\r\nif (pos > pos_start) {\r\nmap_size = (pos - pos_start) << PAGE_SHIFT;\r\nif (remap_oldmem_pfn_range(vma, from + len,\r\npos_start, map_size,\r\nprot))\r\ngoto fail;\r\nlen += map_size;\r\n}\r\nif (remap_oldmem_pfn_range(vma, from + len,\r\nzeropage_pfn,\r\nPAGE_SIZE, prot))\r\ngoto fail;\r\nlen += PAGE_SIZE;\r\npos_start = pos + 1;\r\n}\r\n}\r\nif (pos > pos_start) {\r\nmap_size = (pos - pos_start) << PAGE_SHIFT;\r\nif (remap_oldmem_pfn_range(vma, from + len, pos_start,\r\nmap_size, prot))\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\ndo_munmap(vma->vm_mm, from, len);\r\nreturn -EAGAIN;\r\n}\r\nstatic int vmcore_remap_oldmem_pfn(struct vm_area_struct *vma,\r\nunsigned long from, unsigned long pfn,\r\nunsigned long size, pgprot_t prot)\r\n{\r\nif (oldmem_pfn_is_ram)\r\nreturn remap_oldmem_pfn_checked(vma, from, pfn, size, prot);\r\nelse\r\nreturn remap_oldmem_pfn_range(vma, from, pfn, size, prot);\r\n}\r\nstatic int mmap_vmcore(struct file *file, struct vm_area_struct *vma)\r\n{\r\nsize_t size = vma->vm_end - vma->vm_start;\r\nu64 start, end, len, tsz;\r\nstruct vmcore *m;\r\nstart = (u64)vma->vm_pgoff << PAGE_SHIFT;\r\nend = start + size;\r\nif (size > vmcore_size || end > vmcore_size)\r\nreturn -EINVAL;\r\nif (vma->vm_flags & (VM_WRITE | VM_EXEC))\r\nreturn -EPERM;\r\nvma->vm_flags &= ~(VM_MAYWRITE | VM_MAYEXEC);\r\nvma->vm_flags |= VM_MIXEDMAP;\r\nvma->vm_ops = &vmcore_mmap_ops;\r\nlen = 0;\r\nif (start < elfcorebuf_sz) {\r\nu64 pfn;\r\ntsz = min(elfcorebuf_sz - (size_t)start, size);\r\npfn = __pa(elfcorebuf + start) >> PAGE_SHIFT;\r\nif (remap_pfn_range(vma, vma->vm_start, pfn, tsz,\r\nvma->vm_page_prot))\r\nreturn -EAGAIN;\r\nsize -= tsz;\r\nstart += tsz;\r\nlen += tsz;\r\nif (size == 0)\r\nreturn 0;\r\n}\r\nif (start < elfcorebuf_sz + elfnotes_sz) {\r\nvoid *kaddr;\r\ntsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)start, size);\r\nkaddr = elfnotes_buf + start - elfcorebuf_sz;\r\nif (remap_vmalloc_range_partial(vma, vma->vm_start + len,\r\nkaddr, tsz))\r\ngoto fail;\r\nsize -= tsz;\r\nstart += tsz;\r\nlen += tsz;\r\nif (size == 0)\r\nreturn 0;\r\n}\r\nlist_for_each_entry(m, &vmcore_list, list) {\r\nif (start < m->offset + m->size) {\r\nu64 paddr = 0;\r\ntsz = (size_t)min_t(unsigned long long,\r\nm->offset + m->size - start, size);\r\npaddr = m->paddr + start - m->offset;\r\nif (vmcore_remap_oldmem_pfn(vma, vma->vm_start + len,\r\npaddr >> PAGE_SHIFT, tsz,\r\nvma->vm_page_prot))\r\ngoto fail;\r\nsize -= tsz;\r\nstart += tsz;\r\nlen += tsz;\r\nif (size == 0)\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\ndo_munmap(vma->vm_mm, vma->vm_start, len);\r\nreturn -EAGAIN;\r\n}\r\nstatic int mmap_vmcore(struct file *file, struct vm_area_struct *vma)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic struct vmcore* __init get_new_element(void)\r\n{\r\nreturn kzalloc(sizeof(struct vmcore), GFP_KERNEL);\r\n}\r\nstatic u64 __init get_vmcore_size(size_t elfsz, size_t elfnotesegsz,\r\nstruct list_head *vc_list)\r\n{\r\nu64 size;\r\nstruct vmcore *m;\r\nsize = elfsz + elfnotesegsz;\r\nlist_for_each_entry(m, vc_list, list) {\r\nsize += m->size;\r\n}\r\nreturn size;\r\n}\r\nstatic int __init update_note_header_size_elf64(const Elf64_Ehdr *ehdr_ptr)\r\n{\r\nint i, rc=0;\r\nElf64_Phdr *phdr_ptr;\r\nElf64_Nhdr *nhdr_ptr;\r\nphdr_ptr = (Elf64_Phdr *)(ehdr_ptr + 1);\r\nfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\r\nvoid *notes_section;\r\nu64 offset, max_sz, sz, real_sz = 0;\r\nif (phdr_ptr->p_type != PT_NOTE)\r\ncontinue;\r\nmax_sz = phdr_ptr->p_memsz;\r\noffset = phdr_ptr->p_offset;\r\nnotes_section = kmalloc(max_sz, GFP_KERNEL);\r\nif (!notes_section)\r\nreturn -ENOMEM;\r\nrc = elfcorehdr_read_notes(notes_section, max_sz, &offset);\r\nif (rc < 0) {\r\nkfree(notes_section);\r\nreturn rc;\r\n}\r\nnhdr_ptr = notes_section;\r\nwhile (nhdr_ptr->n_namesz != 0) {\r\nsz = sizeof(Elf64_Nhdr) +\r\n(((u64)nhdr_ptr->n_namesz + 3) & ~3) +\r\n(((u64)nhdr_ptr->n_descsz + 3) & ~3);\r\nif ((real_sz + sz) > max_sz) {\r\npr_warn("Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\n",\r\nnhdr_ptr->n_namesz, nhdr_ptr->n_descsz);\r\nbreak;\r\n}\r\nreal_sz += sz;\r\nnhdr_ptr = (Elf64_Nhdr*)((char*)nhdr_ptr + sz);\r\n}\r\nkfree(notes_section);\r\nphdr_ptr->p_memsz = real_sz;\r\nif (real_sz == 0) {\r\npr_warn("Warning: Zero PT_NOTE entries found\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init get_note_number_and_size_elf64(const Elf64_Ehdr *ehdr_ptr,\r\nint *nr_ptnote, u64 *sz_ptnote)\r\n{\r\nint i;\r\nElf64_Phdr *phdr_ptr;\r\n*nr_ptnote = *sz_ptnote = 0;\r\nphdr_ptr = (Elf64_Phdr *)(ehdr_ptr + 1);\r\nfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\r\nif (phdr_ptr->p_type != PT_NOTE)\r\ncontinue;\r\n*nr_ptnote += 1;\r\n*sz_ptnote += phdr_ptr->p_memsz;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init copy_notes_elf64(const Elf64_Ehdr *ehdr_ptr, char *notes_buf)\r\n{\r\nint i, rc=0;\r\nElf64_Phdr *phdr_ptr;\r\nphdr_ptr = (Elf64_Phdr*)(ehdr_ptr + 1);\r\nfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\r\nu64 offset;\r\nif (phdr_ptr->p_type != PT_NOTE)\r\ncontinue;\r\noffset = phdr_ptr->p_offset;\r\nrc = elfcorehdr_read_notes(notes_buf, phdr_ptr->p_memsz,\r\n&offset);\r\nif (rc < 0)\r\nreturn rc;\r\nnotes_buf += phdr_ptr->p_memsz;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init merge_note_headers_elf64(char *elfptr, size_t *elfsz,\r\nchar **notes_buf, size_t *notes_sz)\r\n{\r\nint i, nr_ptnote=0, rc=0;\r\nchar *tmp;\r\nElf64_Ehdr *ehdr_ptr;\r\nElf64_Phdr phdr;\r\nu64 phdr_sz = 0, note_off;\r\nehdr_ptr = (Elf64_Ehdr *)elfptr;\r\nrc = update_note_header_size_elf64(ehdr_ptr);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = get_note_number_and_size_elf64(ehdr_ptr, &nr_ptnote, &phdr_sz);\r\nif (rc < 0)\r\nreturn rc;\r\n*notes_sz = roundup(phdr_sz, PAGE_SIZE);\r\n*notes_buf = alloc_elfnotes_buf(*notes_sz);\r\nif (!*notes_buf)\r\nreturn -ENOMEM;\r\nrc = copy_notes_elf64(ehdr_ptr, *notes_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nphdr.p_type = PT_NOTE;\r\nphdr.p_flags = 0;\r\nnote_off = sizeof(Elf64_Ehdr) +\r\n(ehdr_ptr->e_phnum - nr_ptnote +1) * sizeof(Elf64_Phdr);\r\nphdr.p_offset = roundup(note_off, PAGE_SIZE);\r\nphdr.p_vaddr = phdr.p_paddr = 0;\r\nphdr.p_filesz = phdr.p_memsz = phdr_sz;\r\nphdr.p_align = 0;\r\ntmp = elfptr + sizeof(Elf64_Ehdr);\r\nmemcpy(tmp, &phdr, sizeof(phdr));\r\ntmp += sizeof(phdr);\r\ni = (nr_ptnote - 1) * sizeof(Elf64_Phdr);\r\n*elfsz = *elfsz - i;\r\nmemmove(tmp, tmp+i, ((*elfsz)-sizeof(Elf64_Ehdr)-sizeof(Elf64_Phdr)));\r\nmemset(elfptr + *elfsz, 0, i);\r\n*elfsz = roundup(*elfsz, PAGE_SIZE);\r\nehdr_ptr->e_phnum = ehdr_ptr->e_phnum - nr_ptnote + 1;\r\nreturn 0;\r\n}\r\nstatic int __init update_note_header_size_elf32(const Elf32_Ehdr *ehdr_ptr)\r\n{\r\nint i, rc=0;\r\nElf32_Phdr *phdr_ptr;\r\nElf32_Nhdr *nhdr_ptr;\r\nphdr_ptr = (Elf32_Phdr *)(ehdr_ptr + 1);\r\nfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\r\nvoid *notes_section;\r\nu64 offset, max_sz, sz, real_sz = 0;\r\nif (phdr_ptr->p_type != PT_NOTE)\r\ncontinue;\r\nmax_sz = phdr_ptr->p_memsz;\r\noffset = phdr_ptr->p_offset;\r\nnotes_section = kmalloc(max_sz, GFP_KERNEL);\r\nif (!notes_section)\r\nreturn -ENOMEM;\r\nrc = elfcorehdr_read_notes(notes_section, max_sz, &offset);\r\nif (rc < 0) {\r\nkfree(notes_section);\r\nreturn rc;\r\n}\r\nnhdr_ptr = notes_section;\r\nwhile (nhdr_ptr->n_namesz != 0) {\r\nsz = sizeof(Elf32_Nhdr) +\r\n(((u64)nhdr_ptr->n_namesz + 3) & ~3) +\r\n(((u64)nhdr_ptr->n_descsz + 3) & ~3);\r\nif ((real_sz + sz) > max_sz) {\r\npr_warn("Warning: Exceeded p_memsz, dropping PT_NOTE entry n_namesz=0x%x, n_descsz=0x%x\n",\r\nnhdr_ptr->n_namesz, nhdr_ptr->n_descsz);\r\nbreak;\r\n}\r\nreal_sz += sz;\r\nnhdr_ptr = (Elf32_Nhdr*)((char*)nhdr_ptr + sz);\r\n}\r\nkfree(notes_section);\r\nphdr_ptr->p_memsz = real_sz;\r\nif (real_sz == 0) {\r\npr_warn("Warning: Zero PT_NOTE entries found\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init get_note_number_and_size_elf32(const Elf32_Ehdr *ehdr_ptr,\r\nint *nr_ptnote, u64 *sz_ptnote)\r\n{\r\nint i;\r\nElf32_Phdr *phdr_ptr;\r\n*nr_ptnote = *sz_ptnote = 0;\r\nphdr_ptr = (Elf32_Phdr *)(ehdr_ptr + 1);\r\nfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\r\nif (phdr_ptr->p_type != PT_NOTE)\r\ncontinue;\r\n*nr_ptnote += 1;\r\n*sz_ptnote += phdr_ptr->p_memsz;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init copy_notes_elf32(const Elf32_Ehdr *ehdr_ptr, char *notes_buf)\r\n{\r\nint i, rc=0;\r\nElf32_Phdr *phdr_ptr;\r\nphdr_ptr = (Elf32_Phdr*)(ehdr_ptr + 1);\r\nfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\r\nu64 offset;\r\nif (phdr_ptr->p_type != PT_NOTE)\r\ncontinue;\r\noffset = phdr_ptr->p_offset;\r\nrc = elfcorehdr_read_notes(notes_buf, phdr_ptr->p_memsz,\r\n&offset);\r\nif (rc < 0)\r\nreturn rc;\r\nnotes_buf += phdr_ptr->p_memsz;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init merge_note_headers_elf32(char *elfptr, size_t *elfsz,\r\nchar **notes_buf, size_t *notes_sz)\r\n{\r\nint i, nr_ptnote=0, rc=0;\r\nchar *tmp;\r\nElf32_Ehdr *ehdr_ptr;\r\nElf32_Phdr phdr;\r\nu64 phdr_sz = 0, note_off;\r\nehdr_ptr = (Elf32_Ehdr *)elfptr;\r\nrc = update_note_header_size_elf32(ehdr_ptr);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = get_note_number_and_size_elf32(ehdr_ptr, &nr_ptnote, &phdr_sz);\r\nif (rc < 0)\r\nreturn rc;\r\n*notes_sz = roundup(phdr_sz, PAGE_SIZE);\r\n*notes_buf = alloc_elfnotes_buf(*notes_sz);\r\nif (!*notes_buf)\r\nreturn -ENOMEM;\r\nrc = copy_notes_elf32(ehdr_ptr, *notes_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nphdr.p_type = PT_NOTE;\r\nphdr.p_flags = 0;\r\nnote_off = sizeof(Elf32_Ehdr) +\r\n(ehdr_ptr->e_phnum - nr_ptnote +1) * sizeof(Elf32_Phdr);\r\nphdr.p_offset = roundup(note_off, PAGE_SIZE);\r\nphdr.p_vaddr = phdr.p_paddr = 0;\r\nphdr.p_filesz = phdr.p_memsz = phdr_sz;\r\nphdr.p_align = 0;\r\ntmp = elfptr + sizeof(Elf32_Ehdr);\r\nmemcpy(tmp, &phdr, sizeof(phdr));\r\ntmp += sizeof(phdr);\r\ni = (nr_ptnote - 1) * sizeof(Elf32_Phdr);\r\n*elfsz = *elfsz - i;\r\nmemmove(tmp, tmp+i, ((*elfsz)-sizeof(Elf32_Ehdr)-sizeof(Elf32_Phdr)));\r\nmemset(elfptr + *elfsz, 0, i);\r\n*elfsz = roundup(*elfsz, PAGE_SIZE);\r\nehdr_ptr->e_phnum = ehdr_ptr->e_phnum - nr_ptnote + 1;\r\nreturn 0;\r\n}\r\nstatic int __init process_ptload_program_headers_elf64(char *elfptr,\r\nsize_t elfsz,\r\nsize_t elfnotes_sz,\r\nstruct list_head *vc_list)\r\n{\r\nint i;\r\nElf64_Ehdr *ehdr_ptr;\r\nElf64_Phdr *phdr_ptr;\r\nloff_t vmcore_off;\r\nstruct vmcore *new;\r\nehdr_ptr = (Elf64_Ehdr *)elfptr;\r\nphdr_ptr = (Elf64_Phdr*)(elfptr + sizeof(Elf64_Ehdr));\r\nvmcore_off = elfsz + elfnotes_sz;\r\nfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\r\nu64 paddr, start, end, size;\r\nif (phdr_ptr->p_type != PT_LOAD)\r\ncontinue;\r\npaddr = phdr_ptr->p_offset;\r\nstart = rounddown(paddr, PAGE_SIZE);\r\nend = roundup(paddr + phdr_ptr->p_memsz, PAGE_SIZE);\r\nsize = end - start;\r\nnew = get_new_element();\r\nif (!new)\r\nreturn -ENOMEM;\r\nnew->paddr = start;\r\nnew->size = size;\r\nlist_add_tail(&new->list, vc_list);\r\nphdr_ptr->p_offset = vmcore_off + (paddr - start);\r\nvmcore_off = vmcore_off + size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init process_ptload_program_headers_elf32(char *elfptr,\r\nsize_t elfsz,\r\nsize_t elfnotes_sz,\r\nstruct list_head *vc_list)\r\n{\r\nint i;\r\nElf32_Ehdr *ehdr_ptr;\r\nElf32_Phdr *phdr_ptr;\r\nloff_t vmcore_off;\r\nstruct vmcore *new;\r\nehdr_ptr = (Elf32_Ehdr *)elfptr;\r\nphdr_ptr = (Elf32_Phdr*)(elfptr + sizeof(Elf32_Ehdr));\r\nvmcore_off = elfsz + elfnotes_sz;\r\nfor (i = 0; i < ehdr_ptr->e_phnum; i++, phdr_ptr++) {\r\nu64 paddr, start, end, size;\r\nif (phdr_ptr->p_type != PT_LOAD)\r\ncontinue;\r\npaddr = phdr_ptr->p_offset;\r\nstart = rounddown(paddr, PAGE_SIZE);\r\nend = roundup(paddr + phdr_ptr->p_memsz, PAGE_SIZE);\r\nsize = end - start;\r\nnew = get_new_element();\r\nif (!new)\r\nreturn -ENOMEM;\r\nnew->paddr = start;\r\nnew->size = size;\r\nlist_add_tail(&new->list, vc_list);\r\nphdr_ptr->p_offset = vmcore_off + (paddr - start);\r\nvmcore_off = vmcore_off + size;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init set_vmcore_list_offsets(size_t elfsz, size_t elfnotes_sz,\r\nstruct list_head *vc_list)\r\n{\r\nloff_t vmcore_off;\r\nstruct vmcore *m;\r\nvmcore_off = elfsz + elfnotes_sz;\r\nlist_for_each_entry(m, vc_list, list) {\r\nm->offset = vmcore_off;\r\nvmcore_off += m->size;\r\n}\r\n}\r\nstatic void free_elfcorebuf(void)\r\n{\r\nfree_pages((unsigned long)elfcorebuf, get_order(elfcorebuf_sz_orig));\r\nelfcorebuf = NULL;\r\nvfree(elfnotes_buf);\r\nelfnotes_buf = NULL;\r\n}\r\nstatic int __init parse_crash_elf64_headers(void)\r\n{\r\nint rc=0;\r\nElf64_Ehdr ehdr;\r\nu64 addr;\r\naddr = elfcorehdr_addr;\r\nrc = elfcorehdr_read((char *)&ehdr, sizeof(Elf64_Ehdr), &addr);\r\nif (rc < 0)\r\nreturn rc;\r\nif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||\r\n(ehdr.e_type != ET_CORE) ||\r\n!vmcore_elf64_check_arch(&ehdr) ||\r\nehdr.e_ident[EI_CLASS] != ELFCLASS64 ||\r\nehdr.e_ident[EI_VERSION] != EV_CURRENT ||\r\nehdr.e_version != EV_CURRENT ||\r\nehdr.e_ehsize != sizeof(Elf64_Ehdr) ||\r\nehdr.e_phentsize != sizeof(Elf64_Phdr) ||\r\nehdr.e_phnum == 0) {\r\npr_warn("Warning: Core image elf header is not sane\n");\r\nreturn -EINVAL;\r\n}\r\nelfcorebuf_sz_orig = sizeof(Elf64_Ehdr) +\r\nehdr.e_phnum * sizeof(Elf64_Phdr);\r\nelfcorebuf_sz = elfcorebuf_sz_orig;\r\nelfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\r\nget_order(elfcorebuf_sz_orig));\r\nif (!elfcorebuf)\r\nreturn -ENOMEM;\r\naddr = elfcorehdr_addr;\r\nrc = elfcorehdr_read(elfcorebuf, elfcorebuf_sz_orig, &addr);\r\nif (rc < 0)\r\ngoto fail;\r\nrc = merge_note_headers_elf64(elfcorebuf, &elfcorebuf_sz,\r\n&elfnotes_buf, &elfnotes_sz);\r\nif (rc)\r\ngoto fail;\r\nrc = process_ptload_program_headers_elf64(elfcorebuf, elfcorebuf_sz,\r\nelfnotes_sz, &vmcore_list);\r\nif (rc)\r\ngoto fail;\r\nset_vmcore_list_offsets(elfcorebuf_sz, elfnotes_sz, &vmcore_list);\r\nreturn 0;\r\nfail:\r\nfree_elfcorebuf();\r\nreturn rc;\r\n}\r\nstatic int __init parse_crash_elf32_headers(void)\r\n{\r\nint rc=0;\r\nElf32_Ehdr ehdr;\r\nu64 addr;\r\naddr = elfcorehdr_addr;\r\nrc = elfcorehdr_read((char *)&ehdr, sizeof(Elf32_Ehdr), &addr);\r\nif (rc < 0)\r\nreturn rc;\r\nif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||\r\n(ehdr.e_type != ET_CORE) ||\r\n!vmcore_elf32_check_arch(&ehdr) ||\r\nehdr.e_ident[EI_CLASS] != ELFCLASS32||\r\nehdr.e_ident[EI_VERSION] != EV_CURRENT ||\r\nehdr.e_version != EV_CURRENT ||\r\nehdr.e_ehsize != sizeof(Elf32_Ehdr) ||\r\nehdr.e_phentsize != sizeof(Elf32_Phdr) ||\r\nehdr.e_phnum == 0) {\r\npr_warn("Warning: Core image elf header is not sane\n");\r\nreturn -EINVAL;\r\n}\r\nelfcorebuf_sz_orig = sizeof(Elf32_Ehdr) + ehdr.e_phnum * sizeof(Elf32_Phdr);\r\nelfcorebuf_sz = elfcorebuf_sz_orig;\r\nelfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\r\nget_order(elfcorebuf_sz_orig));\r\nif (!elfcorebuf)\r\nreturn -ENOMEM;\r\naddr = elfcorehdr_addr;\r\nrc = elfcorehdr_read(elfcorebuf, elfcorebuf_sz_orig, &addr);\r\nif (rc < 0)\r\ngoto fail;\r\nrc = merge_note_headers_elf32(elfcorebuf, &elfcorebuf_sz,\r\n&elfnotes_buf, &elfnotes_sz);\r\nif (rc)\r\ngoto fail;\r\nrc = process_ptload_program_headers_elf32(elfcorebuf, elfcorebuf_sz,\r\nelfnotes_sz, &vmcore_list);\r\nif (rc)\r\ngoto fail;\r\nset_vmcore_list_offsets(elfcorebuf_sz, elfnotes_sz, &vmcore_list);\r\nreturn 0;\r\nfail:\r\nfree_elfcorebuf();\r\nreturn rc;\r\n}\r\nstatic int __init parse_crash_elf_headers(void)\r\n{\r\nunsigned char e_ident[EI_NIDENT];\r\nu64 addr;\r\nint rc=0;\r\naddr = elfcorehdr_addr;\r\nrc = elfcorehdr_read(e_ident, EI_NIDENT, &addr);\r\nif (rc < 0)\r\nreturn rc;\r\nif (memcmp(e_ident, ELFMAG, SELFMAG) != 0) {\r\npr_warn("Warning: Core image elf header not found\n");\r\nreturn -EINVAL;\r\n}\r\nif (e_ident[EI_CLASS] == ELFCLASS64) {\r\nrc = parse_crash_elf64_headers();\r\nif (rc)\r\nreturn rc;\r\n} else if (e_ident[EI_CLASS] == ELFCLASS32) {\r\nrc = parse_crash_elf32_headers();\r\nif (rc)\r\nreturn rc;\r\n} else {\r\npr_warn("Warning: Core image elf header is not sane\n");\r\nreturn -EINVAL;\r\n}\r\nvmcore_size = get_vmcore_size(elfcorebuf_sz, elfnotes_sz,\r\n&vmcore_list);\r\nreturn 0;\r\n}\r\nstatic int __init vmcore_init(void)\r\n{\r\nint rc = 0;\r\nrc = elfcorehdr_alloc(&elfcorehdr_addr, &elfcorehdr_size);\r\nif (rc)\r\nreturn rc;\r\nif (!(is_vmcore_usable()))\r\nreturn rc;\r\nrc = parse_crash_elf_headers();\r\nif (rc) {\r\npr_warn("Kdump: vmcore not initialized\n");\r\nreturn rc;\r\n}\r\nelfcorehdr_free(elfcorehdr_addr);\r\nelfcorehdr_addr = ELFCORE_ADDR_ERR;\r\nproc_vmcore = proc_create("vmcore", S_IRUSR, NULL, &proc_vmcore_operations);\r\nif (proc_vmcore)\r\nproc_vmcore->size = vmcore_size;\r\nreturn 0;\r\n}\r\nvoid vmcore_cleanup(void)\r\n{\r\nstruct list_head *pos, *next;\r\nif (proc_vmcore) {\r\nproc_remove(proc_vmcore);\r\nproc_vmcore = NULL;\r\n}\r\nlist_for_each_safe(pos, next, &vmcore_list) {\r\nstruct vmcore *m;\r\nm = list_entry(pos, struct vmcore, list);\r\nlist_del(&m->list);\r\nkfree(m);\r\n}\r\nfree_elfcorebuf();\r\n}
