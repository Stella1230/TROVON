static void deferred_probe_work_func(struct work_struct *work)\r\n{\r\nstruct device *dev;\r\nstruct device_private *private;\r\nmutex_lock(&deferred_probe_mutex);\r\nwhile (!list_empty(&deferred_probe_active_list)) {\r\nprivate = list_first_entry(&deferred_probe_active_list,\r\ntypeof(*dev->p), deferred_probe);\r\ndev = private->device;\r\nlist_del_init(&private->deferred_probe);\r\nget_device(dev);\r\nmutex_unlock(&deferred_probe_mutex);\r\ndevice_pm_lock();\r\ndevice_pm_move_last(dev);\r\ndevice_pm_unlock();\r\ndev_dbg(dev, "Retrying from deferred list\n");\r\nbus_probe_device(dev);\r\nmutex_lock(&deferred_probe_mutex);\r\nput_device(dev);\r\n}\r\nmutex_unlock(&deferred_probe_mutex);\r\n}\r\nstatic void driver_deferred_probe_add(struct device *dev)\r\n{\r\nmutex_lock(&deferred_probe_mutex);\r\nif (list_empty(&dev->p->deferred_probe)) {\r\ndev_dbg(dev, "Added to deferred list\n");\r\nlist_add_tail(&dev->p->deferred_probe, &deferred_probe_pending_list);\r\n}\r\nmutex_unlock(&deferred_probe_mutex);\r\n}\r\nvoid driver_deferred_probe_del(struct device *dev)\r\n{\r\nmutex_lock(&deferred_probe_mutex);\r\nif (!list_empty(&dev->p->deferred_probe)) {\r\ndev_dbg(dev, "Removed from deferred list\n");\r\nlist_del_init(&dev->p->deferred_probe);\r\n}\r\nmutex_unlock(&deferred_probe_mutex);\r\n}\r\nstatic void driver_deferred_probe_trigger(void)\r\n{\r\nif (!driver_deferred_probe_enable)\r\nreturn;\r\nmutex_lock(&deferred_probe_mutex);\r\natomic_inc(&deferred_trigger_count);\r\nlist_splice_tail_init(&deferred_probe_pending_list,\r\n&deferred_probe_active_list);\r\nmutex_unlock(&deferred_probe_mutex);\r\nqueue_work(deferred_wq, &deferred_probe_work);\r\n}\r\nvoid device_block_probing(void)\r\n{\r\ndefer_all_probes = true;\r\nwait_for_device_probe();\r\n}\r\nvoid device_unblock_probing(void)\r\n{\r\ndefer_all_probes = false;\r\ndriver_deferred_probe_trigger();\r\n}\r\nstatic int deferred_probe_initcall(void)\r\n{\r\ndeferred_wq = create_singlethread_workqueue("deferwq");\r\nif (WARN_ON(!deferred_wq))\r\nreturn -ENOMEM;\r\ndriver_deferred_probe_enable = true;\r\ndriver_deferred_probe_trigger();\r\nflush_workqueue(deferred_wq);\r\nreturn 0;\r\n}\r\nbool device_is_bound(struct device *dev)\r\n{\r\nreturn dev->p && klist_node_attached(&dev->p->knode_driver);\r\n}\r\nstatic void driver_bound(struct device *dev)\r\n{\r\nif (device_is_bound(dev)) {\r\nprintk(KERN_WARNING "%s: device %s already bound\n",\r\n__func__, kobject_name(&dev->kobj));\r\nreturn;\r\n}\r\npr_debug("driver: '%s': %s: bound to device '%s'\n", dev->driver->name,\r\n__func__, dev_name(dev));\r\nklist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);\r\ndevice_pm_check_callbacks(dev);\r\ndriver_deferred_probe_del(dev);\r\ndriver_deferred_probe_trigger();\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_BOUND_DRIVER, dev);\r\n}\r\nstatic int driver_sysfs_add(struct device *dev)\r\n{\r\nint ret;\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_BIND_DRIVER, dev);\r\nret = sysfs_create_link(&dev->driver->p->kobj, &dev->kobj,\r\nkobject_name(&dev->kobj));\r\nif (ret == 0) {\r\nret = sysfs_create_link(&dev->kobj, &dev->driver->p->kobj,\r\n"driver");\r\nif (ret)\r\nsysfs_remove_link(&dev->driver->p->kobj,\r\nkobject_name(&dev->kobj));\r\n}\r\nreturn ret;\r\n}\r\nstatic void driver_sysfs_remove(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nif (drv) {\r\nsysfs_remove_link(&drv->p->kobj, kobject_name(&dev->kobj));\r\nsysfs_remove_link(&dev->kobj, "driver");\r\n}\r\n}\r\nint device_bind_driver(struct device *dev)\r\n{\r\nint ret;\r\nret = driver_sysfs_add(dev);\r\nif (!ret)\r\ndriver_bound(dev);\r\nelse if (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_DRIVER_NOT_BOUND, dev);\r\nreturn ret;\r\n}\r\nstatic int really_probe(struct device *dev, struct device_driver *drv)\r\n{\r\nint ret = -EPROBE_DEFER;\r\nint local_trigger_count = atomic_read(&deferred_trigger_count);\r\nif (defer_all_probes) {\r\ndev_dbg(dev, "Driver %s force probe deferral\n", drv->name);\r\ndriver_deferred_probe_add(dev);\r\nreturn ret;\r\n}\r\natomic_inc(&probe_count);\r\npr_debug("bus: '%s': %s: probing driver %s with device %s\n",\r\ndrv->bus->name, __func__, drv->name, dev_name(dev));\r\nWARN_ON(!list_empty(&dev->devres_head));\r\ndev->driver = drv;\r\nret = pinctrl_bind_pins(dev);\r\nif (ret)\r\ngoto pinctrl_bind_failed;\r\nif (driver_sysfs_add(dev)) {\r\nprintk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",\r\n__func__, dev_name(dev));\r\ngoto probe_failed;\r\n}\r\nif (dev->pm_domain && dev->pm_domain->activate) {\r\nret = dev->pm_domain->activate(dev);\r\nif (ret)\r\ngoto probe_failed;\r\n}\r\ndevices_kset_move_last(dev);\r\nif (dev->bus->probe) {\r\nret = dev->bus->probe(dev);\r\nif (ret)\r\ngoto probe_failed;\r\n} else if (drv->probe) {\r\nret = drv->probe(dev);\r\nif (ret)\r\ngoto probe_failed;\r\n}\r\npinctrl_init_done(dev);\r\nif (dev->pm_domain && dev->pm_domain->sync)\r\ndev->pm_domain->sync(dev);\r\ndriver_bound(dev);\r\nret = 1;\r\npr_debug("bus: '%s': %s: bound device %s to driver %s\n",\r\ndrv->bus->name, __func__, dev_name(dev), drv->name);\r\ngoto done;\r\nprobe_failed:\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_DRIVER_NOT_BOUND, dev);\r\npinctrl_bind_failed:\r\ndevres_release_all(dev);\r\ndriver_sysfs_remove(dev);\r\ndev->driver = NULL;\r\ndev_set_drvdata(dev, NULL);\r\nif (dev->pm_domain && dev->pm_domain->dismiss)\r\ndev->pm_domain->dismiss(dev);\r\npm_runtime_reinit(dev);\r\nswitch (ret) {\r\ncase -EPROBE_DEFER:\r\ndev_dbg(dev, "Driver %s requests probe deferral\n", drv->name);\r\ndriver_deferred_probe_add(dev);\r\nif (local_trigger_count != atomic_read(&deferred_trigger_count))\r\ndriver_deferred_probe_trigger();\r\nbreak;\r\ncase -ENODEV:\r\ncase -ENXIO:\r\npr_debug("%s: probe of %s rejects match %d\n",\r\ndrv->name, dev_name(dev), ret);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"%s: probe of %s failed with error %d\n",\r\ndrv->name, dev_name(dev), ret);\r\n}\r\nret = 0;\r\ndone:\r\natomic_dec(&probe_count);\r\nwake_up(&probe_waitqueue);\r\nreturn ret;\r\n}\r\nint driver_probe_done(void)\r\n{\r\npr_debug("%s: probe_count = %d\n", __func__,\r\natomic_read(&probe_count));\r\nif (atomic_read(&probe_count))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nvoid wait_for_device_probe(void)\r\n{\r\nif (driver_deferred_probe_enable)\r\nflush_workqueue(deferred_wq);\r\nwait_event(probe_waitqueue, atomic_read(&probe_count) == 0);\r\nasync_synchronize_full();\r\n}\r\nint driver_probe_device(struct device_driver *drv, struct device *dev)\r\n{\r\nint ret = 0;\r\nif (!device_is_registered(dev))\r\nreturn -ENODEV;\r\npr_debug("bus: '%s': %s: matched device %s with driver %s\n",\r\ndrv->bus->name, __func__, dev_name(dev), drv->name);\r\nif (dev->parent)\r\npm_runtime_get_sync(dev->parent);\r\npm_runtime_barrier(dev);\r\nret = really_probe(dev, drv);\r\npm_request_idle(dev);\r\nif (dev->parent)\r\npm_runtime_put(dev->parent);\r\nreturn ret;\r\n}\r\nbool driver_allows_async_probing(struct device_driver *drv)\r\n{\r\nswitch (drv->probe_type) {\r\ncase PROBE_PREFER_ASYNCHRONOUS:\r\nreturn true;\r\ncase PROBE_FORCE_SYNCHRONOUS:\r\nreturn false;\r\ndefault:\r\nif (module_requested_async_probing(drv->owner))\r\nreturn true;\r\nreturn false;\r\n}\r\n}\r\nstatic int __device_attach_driver(struct device_driver *drv, void *_data)\r\n{\r\nstruct device_attach_data *data = _data;\r\nstruct device *dev = data->dev;\r\nbool async_allowed;\r\nint ret;\r\nif (dev->driver)\r\nreturn -EBUSY;\r\nret = driver_match_device(drv, dev);\r\nif (ret == 0) {\r\nreturn 0;\r\n} else if (ret == -EPROBE_DEFER) {\r\ndev_dbg(dev, "Device match requests probe deferral\n");\r\ndriver_deferred_probe_add(dev);\r\n} else if (ret < 0) {\r\ndev_dbg(dev, "Bus failed to match device: %d", ret);\r\nreturn ret;\r\n}\r\nasync_allowed = driver_allows_async_probing(drv);\r\nif (async_allowed)\r\ndata->have_async = true;\r\nif (data->check_async && async_allowed != data->want_async)\r\nreturn 0;\r\nreturn driver_probe_device(drv, dev);\r\n}\r\nstatic void __device_attach_async_helper(void *_dev, async_cookie_t cookie)\r\n{\r\nstruct device *dev = _dev;\r\nstruct device_attach_data data = {\r\n.dev = dev,\r\n.check_async = true,\r\n.want_async = true,\r\n};\r\ndevice_lock(dev);\r\nif (dev->parent)\r\npm_runtime_get_sync(dev->parent);\r\nbus_for_each_drv(dev->bus, NULL, &data, __device_attach_driver);\r\ndev_dbg(dev, "async probe completed\n");\r\npm_request_idle(dev);\r\nif (dev->parent)\r\npm_runtime_put(dev->parent);\r\ndevice_unlock(dev);\r\nput_device(dev);\r\n}\r\nstatic int __device_attach(struct device *dev, bool allow_async)\r\n{\r\nint ret = 0;\r\ndevice_lock(dev);\r\nif (dev->driver) {\r\nif (device_is_bound(dev)) {\r\nret = 1;\r\ngoto out_unlock;\r\n}\r\nret = device_bind_driver(dev);\r\nif (ret == 0)\r\nret = 1;\r\nelse {\r\ndev->driver = NULL;\r\nret = 0;\r\n}\r\n} else {\r\nstruct device_attach_data data = {\r\n.dev = dev,\r\n.check_async = allow_async,\r\n.want_async = false,\r\n};\r\nif (dev->parent)\r\npm_runtime_get_sync(dev->parent);\r\nret = bus_for_each_drv(dev->bus, NULL, &data,\r\n__device_attach_driver);\r\nif (!ret && allow_async && data.have_async) {\r\ndev_dbg(dev, "scheduling asynchronous probe\n");\r\nget_device(dev);\r\nasync_schedule(__device_attach_async_helper, dev);\r\n} else {\r\npm_request_idle(dev);\r\n}\r\nif (dev->parent)\r\npm_runtime_put(dev->parent);\r\n}\r\nout_unlock:\r\ndevice_unlock(dev);\r\nreturn ret;\r\n}\r\nint device_attach(struct device *dev)\r\n{\r\nreturn __device_attach(dev, false);\r\n}\r\nvoid device_initial_probe(struct device *dev)\r\n{\r\n__device_attach(dev, true);\r\n}\r\nstatic int __driver_attach(struct device *dev, void *data)\r\n{\r\nstruct device_driver *drv = data;\r\nint ret;\r\nret = driver_match_device(drv, dev);\r\nif (ret == 0) {\r\nreturn 0;\r\n} else if (ret == -EPROBE_DEFER) {\r\ndev_dbg(dev, "Device match requests probe deferral\n");\r\ndriver_deferred_probe_add(dev);\r\n} else if (ret < 0) {\r\ndev_dbg(dev, "Bus failed to match device: %d", ret);\r\nreturn ret;\r\n}\r\nif (dev->parent)\r\ndevice_lock(dev->parent);\r\ndevice_lock(dev);\r\nif (!dev->driver)\r\ndriver_probe_device(drv, dev);\r\ndevice_unlock(dev);\r\nif (dev->parent)\r\ndevice_unlock(dev->parent);\r\nreturn 0;\r\n}\r\nint driver_attach(struct device_driver *drv)\r\n{\r\nreturn bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);\r\n}\r\nstatic void __device_release_driver(struct device *dev)\r\n{\r\nstruct device_driver *drv;\r\ndrv = dev->driver;\r\nif (drv) {\r\nif (driver_allows_async_probing(drv))\r\nasync_synchronize_full();\r\npm_runtime_get_sync(dev);\r\ndriver_sysfs_remove(dev);\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_UNBIND_DRIVER,\r\ndev);\r\npm_runtime_put_sync(dev);\r\nif (dev->bus && dev->bus->remove)\r\ndev->bus->remove(dev);\r\nelse if (drv->remove)\r\ndrv->remove(dev);\r\ndevres_release_all(dev);\r\ndev->driver = NULL;\r\ndev_set_drvdata(dev, NULL);\r\nif (dev->pm_domain && dev->pm_domain->dismiss)\r\ndev->pm_domain->dismiss(dev);\r\npm_runtime_reinit(dev);\r\nklist_remove(&dev->p->knode_driver);\r\ndevice_pm_check_callbacks(dev);\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_UNBOUND_DRIVER,\r\ndev);\r\n}\r\n}\r\nvoid device_release_driver(struct device *dev)\r\n{\r\ndevice_lock(dev);\r\n__device_release_driver(dev);\r\ndevice_unlock(dev);\r\n}\r\nvoid driver_detach(struct device_driver *drv)\r\n{\r\nstruct device_private *dev_prv;\r\nstruct device *dev;\r\nfor (;;) {\r\nspin_lock(&drv->p->klist_devices.k_lock);\r\nif (list_empty(&drv->p->klist_devices.k_list)) {\r\nspin_unlock(&drv->p->klist_devices.k_lock);\r\nbreak;\r\n}\r\ndev_prv = list_entry(drv->p->klist_devices.k_list.prev,\r\nstruct device_private,\r\nknode_driver.n_node);\r\ndev = dev_prv->device;\r\nget_device(dev);\r\nspin_unlock(&drv->p->klist_devices.k_lock);\r\nif (dev->parent)\r\ndevice_lock(dev->parent);\r\ndevice_lock(dev);\r\nif (dev->driver == drv)\r\n__device_release_driver(dev);\r\ndevice_unlock(dev);\r\nif (dev->parent)\r\ndevice_unlock(dev->parent);\r\nput_device(dev);\r\n}\r\n}
