static inline int aead_sndbuf(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nreturn max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -\r\nctx->used, 0);\r\n}\r\nstatic inline bool aead_writable(struct sock *sk)\r\n{\r\nreturn PAGE_SIZE <= aead_sndbuf(sk);\r\n}\r\nstatic inline bool aead_sufficient_data(struct aead_ctx *ctx)\r\n{\r\nunsigned as = crypto_aead_authsize(crypto_aead_reqtfm(&ctx->aead_req));\r\nreturn ctx->used >= ctx->aead_assoclen + as;\r\n}\r\nstatic void aead_reset_ctx(struct aead_ctx *ctx)\r\n{\r\nstruct aead_sg_list *sgl = &ctx->tsgl;\r\nsg_init_table(sgl->sg, ALG_MAX_PAGES);\r\nsgl->cur = 0;\r\nctx->used = 0;\r\nctx->more = 0;\r\nctx->merge = 0;\r\n}\r\nstatic void aead_put_sgl(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nstruct aead_sg_list *sgl = &ctx->tsgl;\r\nstruct scatterlist *sg = sgl->sg;\r\nunsigned int i;\r\nfor (i = 0; i < sgl->cur; i++) {\r\nif (!sg_page(sg + i))\r\ncontinue;\r\nput_page(sg_page(sg + i));\r\nsg_assign_page(sg + i, NULL);\r\n}\r\naead_reset_ctx(ctx);\r\n}\r\nstatic void aead_wmem_wakeup(struct sock *sk)\r\n{\r\nstruct socket_wq *wq;\r\nif (!aead_writable(sk))\r\nreturn;\r\nrcu_read_lock();\r\nwq = rcu_dereference(sk->sk_wq);\r\nif (skwq_has_sleeper(wq))\r\nwake_up_interruptible_sync_poll(&wq->wait, POLLIN |\r\nPOLLRDNORM |\r\nPOLLRDBAND);\r\nsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\r\nrcu_read_unlock();\r\n}\r\nstatic int aead_wait_for_data(struct sock *sk, unsigned flags)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nlong timeout;\r\nDEFINE_WAIT(wait);\r\nint err = -ERESTARTSYS;\r\nif (flags & MSG_DONTWAIT)\r\nreturn -EAGAIN;\r\nsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\r\nfor (;;) {\r\nif (signal_pending(current))\r\nbreak;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\nif (sk_wait_event(sk, &timeout, !ctx->more)) {\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\r\nreturn err;\r\n}\r\nstatic void aead_data_wakeup(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nstruct socket_wq *wq;\r\nif (ctx->more)\r\nreturn;\r\nif (!ctx->used)\r\nreturn;\r\nrcu_read_lock();\r\nwq = rcu_dereference(sk->sk_wq);\r\nif (skwq_has_sleeper(wq))\r\nwake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\r\nPOLLRDNORM |\r\nPOLLRDBAND);\r\nsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\r\nrcu_read_unlock();\r\n}\r\nstatic int aead_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nunsigned ivsize =\r\ncrypto_aead_ivsize(crypto_aead_reqtfm(&ctx->aead_req));\r\nstruct aead_sg_list *sgl = &ctx->tsgl;\r\nstruct af_alg_control con = {};\r\nlong copied = 0;\r\nbool enc = 0;\r\nbool init = 0;\r\nint err = -EINVAL;\r\nif (msg->msg_controllen) {\r\nerr = af_alg_cmsg_send(msg, &con);\r\nif (err)\r\nreturn err;\r\ninit = 1;\r\nswitch (con.op) {\r\ncase ALG_OP_ENCRYPT:\r\nenc = 1;\r\nbreak;\r\ncase ALG_OP_DECRYPT:\r\nenc = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (con.iv && con.iv->ivlen != ivsize)\r\nreturn -EINVAL;\r\n}\r\nlock_sock(sk);\r\nif (!ctx->more && ctx->used)\r\ngoto unlock;\r\nif (init) {\r\nctx->enc = enc;\r\nif (con.iv)\r\nmemcpy(ctx->iv, con.iv->iv, ivsize);\r\nctx->aead_assoclen = con.aead_assoclen;\r\n}\r\nwhile (size) {\r\nsize_t len = size;\r\nstruct scatterlist *sg = NULL;\r\nif (ctx->merge) {\r\nsg = sgl->sg + sgl->cur - 1;\r\nlen = min_t(unsigned long, len,\r\nPAGE_SIZE - sg->offset - sg->length);\r\nerr = memcpy_from_msg(page_address(sg_page(sg)) +\r\nsg->offset + sg->length,\r\nmsg, len);\r\nif (err)\r\ngoto unlock;\r\nsg->length += len;\r\nctx->merge = (sg->offset + sg->length) &\r\n(PAGE_SIZE - 1);\r\nctx->used += len;\r\ncopied += len;\r\nsize -= len;\r\ncontinue;\r\n}\r\nif (!aead_writable(sk)) {\r\naead_put_sgl(sk);\r\nerr = -EMSGSIZE;\r\ngoto unlock;\r\n}\r\nlen = min_t(unsigned long, size, aead_sndbuf(sk));\r\nwhile (len) {\r\nsize_t plen = 0;\r\nif (sgl->cur >= ALG_MAX_PAGES) {\r\naead_put_sgl(sk);\r\nerr = -E2BIG;\r\ngoto unlock;\r\n}\r\nsg = sgl->sg + sgl->cur;\r\nplen = min_t(size_t, len, PAGE_SIZE);\r\nsg_assign_page(sg, alloc_page(GFP_KERNEL));\r\nerr = -ENOMEM;\r\nif (!sg_page(sg))\r\ngoto unlock;\r\nerr = memcpy_from_msg(page_address(sg_page(sg)),\r\nmsg, plen);\r\nif (err) {\r\n__free_page(sg_page(sg));\r\nsg_assign_page(sg, NULL);\r\ngoto unlock;\r\n}\r\nsg->offset = 0;\r\nsg->length = plen;\r\nlen -= plen;\r\nctx->used += plen;\r\ncopied += plen;\r\nsgl->cur++;\r\nsize -= plen;\r\nctx->merge = plen & (PAGE_SIZE - 1);\r\n}\r\n}\r\nerr = 0;\r\nctx->more = msg->msg_flags & MSG_MORE;\r\nif (!ctx->more && !aead_sufficient_data(ctx)) {\r\naead_put_sgl(sk);\r\nerr = -EMSGSIZE;\r\n}\r\nunlock:\r\naead_data_wakeup(sk);\r\nrelease_sock(sk);\r\nreturn err ?: copied;\r\n}\r\nstatic ssize_t aead_sendpage(struct socket *sock, struct page *page,\r\nint offset, size_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nstruct aead_sg_list *sgl = &ctx->tsgl;\r\nint err = -EINVAL;\r\nif (flags & MSG_SENDPAGE_NOTLAST)\r\nflags |= MSG_MORE;\r\nif (sgl->cur >= ALG_MAX_PAGES)\r\nreturn -E2BIG;\r\nlock_sock(sk);\r\nif (!ctx->more && ctx->used)\r\ngoto unlock;\r\nif (!size)\r\ngoto done;\r\nif (!aead_writable(sk)) {\r\naead_put_sgl(sk);\r\nerr = -EMSGSIZE;\r\ngoto unlock;\r\n}\r\nctx->merge = 0;\r\nget_page(page);\r\nsg_set_page(sgl->sg + sgl->cur, page, size, offset);\r\nsgl->cur++;\r\nctx->used += size;\r\nerr = 0;\r\ndone:\r\nctx->more = flags & MSG_MORE;\r\nif (!ctx->more && !aead_sufficient_data(ctx)) {\r\naead_put_sgl(sk);\r\nerr = -EMSGSIZE;\r\n}\r\nunlock:\r\naead_data_wakeup(sk);\r\nrelease_sock(sk);\r\nreturn err ?: size;\r\n}\r\nstatic void aead_async_cb(struct crypto_async_request *_req, int err)\r\n{\r\nstruct sock *sk = _req->data;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(&ctx->aead_req);\r\nstruct aead_request *req = aead_request_cast(_req);\r\nstruct aead_async_req *areq = GET_ASYM_REQ(req, tfm);\r\nstruct scatterlist *sg = areq->tsgl;\r\nstruct aead_async_rsgl *rsgl;\r\nstruct kiocb *iocb = areq->iocb;\r\nunsigned int i, reqlen = GET_REQ_SIZE(tfm);\r\nlist_for_each_entry(rsgl, &areq->list, list) {\r\naf_alg_free_sg(&rsgl->sgl);\r\nif (rsgl != &areq->first_rsgl)\r\nsock_kfree_s(sk, rsgl, sizeof(*rsgl));\r\n}\r\nfor (i = 0; i < areq->tsgls; i++)\r\nput_page(sg_page(sg + i));\r\nsock_kfree_s(sk, areq->tsgl, sizeof(*areq->tsgl) * areq->tsgls);\r\nsock_kfree_s(sk, req, reqlen);\r\n__sock_put(sk);\r\niocb->ki_complete(iocb, err, err);\r\n}\r\nstatic int aead_recvmsg_async(struct socket *sock, struct msghdr *msg,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(&ctx->aead_req);\r\nstruct aead_async_req *areq;\r\nstruct aead_request *req = NULL;\r\nstruct aead_sg_list *sgl = &ctx->tsgl;\r\nstruct aead_async_rsgl *last_rsgl = NULL, *rsgl;\r\nunsigned int as = crypto_aead_authsize(tfm);\r\nunsigned int i, reqlen = GET_REQ_SIZE(tfm);\r\nint err = -ENOMEM;\r\nunsigned long used;\r\nsize_t outlen;\r\nsize_t usedpages = 0;\r\nlock_sock(sk);\r\nif (ctx->more) {\r\nerr = aead_wait_for_data(sk, flags);\r\nif (err)\r\ngoto unlock;\r\n}\r\nused = ctx->used;\r\noutlen = used;\r\nif (!aead_sufficient_data(ctx))\r\ngoto unlock;\r\nreq = sock_kmalloc(sk, reqlen, GFP_KERNEL);\r\nif (unlikely(!req))\r\ngoto unlock;\r\nareq = GET_ASYM_REQ(req, tfm);\r\nmemset(&areq->first_rsgl, '\0', sizeof(areq->first_rsgl));\r\nINIT_LIST_HEAD(&areq->list);\r\nareq->iocb = msg->msg_iocb;\r\nmemcpy(areq->iv, ctx->iv, crypto_aead_ivsize(tfm));\r\naead_request_set_tfm(req, tfm);\r\naead_request_set_ad(req, ctx->aead_assoclen);\r\naead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\r\naead_async_cb, sk);\r\nused -= ctx->aead_assoclen + (ctx->enc ? as : 0);\r\nareq->tsgl = sock_kmalloc(sk, sizeof(*areq->tsgl) * sgl->cur,\r\nGFP_KERNEL);\r\nif (unlikely(!areq->tsgl))\r\ngoto free;\r\nsg_init_table(areq->tsgl, sgl->cur);\r\nfor (i = 0; i < sgl->cur; i++)\r\nsg_set_page(&areq->tsgl[i], sg_page(&sgl->sg[i]),\r\nsgl->sg[i].length, sgl->sg[i].offset);\r\nareq->tsgls = sgl->cur;\r\nwhile (iov_iter_count(&msg->msg_iter)) {\r\nsize_t seglen = min_t(size_t, iov_iter_count(&msg->msg_iter),\r\n(outlen - usedpages));\r\nif (list_empty(&areq->list)) {\r\nrsgl = &areq->first_rsgl;\r\n} else {\r\nrsgl = sock_kmalloc(sk, sizeof(*rsgl), GFP_KERNEL);\r\nif (unlikely(!rsgl)) {\r\nerr = -ENOMEM;\r\ngoto free;\r\n}\r\n}\r\nrsgl->sgl.npages = 0;\r\nlist_add_tail(&rsgl->list, &areq->list);\r\nerr = af_alg_make_sg(&rsgl->sgl, &msg->msg_iter, seglen);\r\nif (err < 0)\r\ngoto free;\r\nusedpages += err;\r\nif (last_rsgl)\r\naf_alg_link_sg(&last_rsgl->sgl, &rsgl->sgl);\r\nlast_rsgl = rsgl;\r\nif (outlen <= usedpages)\r\nbreak;\r\niov_iter_advance(&msg->msg_iter, err);\r\n}\r\nerr = -EINVAL;\r\nif (usedpages < outlen)\r\ngoto free;\r\naead_request_set_crypt(req, areq->tsgl, areq->first_rsgl.sgl.sg, used,\r\nareq->iv);\r\nerr = ctx->enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);\r\nif (err) {\r\nif (err == -EINPROGRESS) {\r\nsock_hold(sk);\r\nerr = -EIOCBQUEUED;\r\naead_reset_ctx(ctx);\r\ngoto unlock;\r\n} else if (err == -EBADMSG) {\r\naead_put_sgl(sk);\r\n}\r\ngoto free;\r\n}\r\naead_put_sgl(sk);\r\nfree:\r\nlist_for_each_entry(rsgl, &areq->list, list) {\r\naf_alg_free_sg(&rsgl->sgl);\r\nif (rsgl != &areq->first_rsgl)\r\nsock_kfree_s(sk, rsgl, sizeof(*rsgl));\r\n}\r\nif (areq->tsgl)\r\nsock_kfree_s(sk, areq->tsgl, sizeof(*areq->tsgl) * areq->tsgls);\r\nif (req)\r\nsock_kfree_s(sk, req, reqlen);\r\nunlock:\r\naead_wmem_wakeup(sk);\r\nrelease_sock(sk);\r\nreturn err ? err : outlen;\r\n}\r\nstatic int aead_recvmsg_sync(struct socket *sock, struct msghdr *msg, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nunsigned as = crypto_aead_authsize(crypto_aead_reqtfm(&ctx->aead_req));\r\nstruct aead_sg_list *sgl = &ctx->tsgl;\r\nstruct aead_async_rsgl *last_rsgl = NULL;\r\nstruct aead_async_rsgl *rsgl, *tmp;\r\nint err = -EINVAL;\r\nunsigned long used = 0;\r\nsize_t outlen = 0;\r\nsize_t usedpages = 0;\r\nlock_sock(sk);\r\nif (ctx->more) {\r\nerr = aead_wait_for_data(sk, flags);\r\nif (err)\r\ngoto unlock;\r\n}\r\nused = ctx->used;\r\nif (!aead_sufficient_data(ctx))\r\ngoto unlock;\r\noutlen = used;\r\nused -= ctx->aead_assoclen + (ctx->enc ? as : 0);\r\nwhile (iov_iter_count(&msg->msg_iter)) {\r\nsize_t seglen = min_t(size_t, iov_iter_count(&msg->msg_iter),\r\n(outlen - usedpages));\r\nif (list_empty(&ctx->list)) {\r\nrsgl = &ctx->first_rsgl;\r\n} else {\r\nrsgl = sock_kmalloc(sk, sizeof(*rsgl), GFP_KERNEL);\r\nif (unlikely(!rsgl)) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\n}\r\nrsgl->sgl.npages = 0;\r\nlist_add_tail(&rsgl->list, &ctx->list);\r\nerr = af_alg_make_sg(&rsgl->sgl, &msg->msg_iter, seglen);\r\nif (err < 0)\r\ngoto unlock;\r\nusedpages += err;\r\nif (last_rsgl)\r\naf_alg_link_sg(&last_rsgl->sgl, &rsgl->sgl);\r\nlast_rsgl = rsgl;\r\nif (outlen <= usedpages)\r\nbreak;\r\niov_iter_advance(&msg->msg_iter, err);\r\n}\r\nerr = -EINVAL;\r\nif (usedpages < outlen)\r\ngoto unlock;\r\nsg_mark_end(sgl->sg + sgl->cur - 1);\r\naead_request_set_crypt(&ctx->aead_req, sgl->sg, ctx->first_rsgl.sgl.sg,\r\nused, ctx->iv);\r\naead_request_set_ad(&ctx->aead_req, ctx->aead_assoclen);\r\nerr = af_alg_wait_for_completion(ctx->enc ?\r\ncrypto_aead_encrypt(&ctx->aead_req) :\r\ncrypto_aead_decrypt(&ctx->aead_req),\r\n&ctx->completion);\r\nif (err) {\r\nif (err == -EBADMSG)\r\naead_put_sgl(sk);\r\ngoto unlock;\r\n}\r\naead_put_sgl(sk);\r\nerr = 0;\r\nunlock:\r\nlist_for_each_entry_safe(rsgl, tmp, &ctx->list, list) {\r\naf_alg_free_sg(&rsgl->sgl);\r\nif (rsgl != &ctx->first_rsgl)\r\nsock_kfree_s(sk, rsgl, sizeof(*rsgl));\r\nlist_del(&rsgl->list);\r\n}\r\nINIT_LIST_HEAD(&ctx->list);\r\naead_wmem_wakeup(sk);\r\nrelease_sock(sk);\r\nreturn err ? err : outlen;\r\n}\r\nstatic int aead_recvmsg(struct socket *sock, struct msghdr *msg, size_t ignored,\r\nint flags)\r\n{\r\nreturn (msg->msg_iocb && !is_sync_kiocb(msg->msg_iocb)) ?\r\naead_recvmsg_async(sock, msg, flags) :\r\naead_recvmsg_sync(sock, msg, flags);\r\n}\r\nstatic unsigned int aead_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nunsigned int mask;\r\nsock_poll_wait(file, sk_sleep(sk), wait);\r\nmask = 0;\r\nif (!ctx->more)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (aead_writable(sk))\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\nreturn mask;\r\n}\r\nstatic void *aead_bind(const char *name, u32 type, u32 mask)\r\n{\r\nreturn crypto_alloc_aead(name, type, mask);\r\n}\r\nstatic void aead_release(void *private)\r\n{\r\ncrypto_free_aead(private);\r\n}\r\nstatic int aead_setauthsize(void *private, unsigned int authsize)\r\n{\r\nreturn crypto_aead_setauthsize(private, authsize);\r\n}\r\nstatic int aead_setkey(void *private, const u8 *key, unsigned int keylen)\r\n{\r\nreturn crypto_aead_setkey(private, key, keylen);\r\n}\r\nstatic void aead_sock_destruct(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct aead_ctx *ctx = ask->private;\r\nunsigned int ivlen = crypto_aead_ivsize(\r\ncrypto_aead_reqtfm(&ctx->aead_req));\r\nWARN_ON(atomic_read(&sk->sk_refcnt) != 0);\r\naead_put_sgl(sk);\r\nsock_kzfree_s(sk, ctx->iv, ivlen);\r\nsock_kfree_s(sk, ctx, ctx->len);\r\naf_alg_release_parent(sk);\r\n}\r\nstatic int aead_accept_parent(void *private, struct sock *sk)\r\n{\r\nstruct aead_ctx *ctx;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nunsigned int len = sizeof(*ctx) + crypto_aead_reqsize(private);\r\nunsigned int ivlen = crypto_aead_ivsize(private);\r\nctx = sock_kmalloc(sk, len, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nmemset(ctx, 0, len);\r\nctx->iv = sock_kmalloc(sk, ivlen, GFP_KERNEL);\r\nif (!ctx->iv) {\r\nsock_kfree_s(sk, ctx, len);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ctx->iv, 0, ivlen);\r\nctx->len = len;\r\nctx->used = 0;\r\nctx->more = 0;\r\nctx->merge = 0;\r\nctx->enc = 0;\r\nctx->tsgl.cur = 0;\r\nctx->aead_assoclen = 0;\r\naf_alg_init_completion(&ctx->completion);\r\nsg_init_table(ctx->tsgl.sg, ALG_MAX_PAGES);\r\nINIT_LIST_HEAD(&ctx->list);\r\nask->private = ctx;\r\naead_request_set_tfm(&ctx->aead_req, private);\r\naead_request_set_callback(&ctx->aead_req, CRYPTO_TFM_REQ_MAY_BACKLOG,\r\naf_alg_complete, &ctx->completion);\r\nsk->sk_destruct = aead_sock_destruct;\r\nreturn 0;\r\n}\r\nstatic int __init algif_aead_init(void)\r\n{\r\nreturn af_alg_register_type(&algif_type_aead);\r\n}\r\nstatic void __exit algif_aead_exit(void)\r\n{\r\nint err = af_alg_unregister_type(&algif_type_aead);\r\nBUG_ON(err);\r\n}
