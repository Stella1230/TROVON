static void rspi_write8(const struct rspi_data *rspi, u8 data, u16 offset)\r\n{\r\niowrite8(data, rspi->addr + offset);\r\n}\r\nstatic void rspi_write16(const struct rspi_data *rspi, u16 data, u16 offset)\r\n{\r\niowrite16(data, rspi->addr + offset);\r\n}\r\nstatic void rspi_write32(const struct rspi_data *rspi, u32 data, u16 offset)\r\n{\r\niowrite32(data, rspi->addr + offset);\r\n}\r\nstatic u8 rspi_read8(const struct rspi_data *rspi, u16 offset)\r\n{\r\nreturn ioread8(rspi->addr + offset);\r\n}\r\nstatic u16 rspi_read16(const struct rspi_data *rspi, u16 offset)\r\n{\r\nreturn ioread16(rspi->addr + offset);\r\n}\r\nstatic void rspi_write_data(const struct rspi_data *rspi, u16 data)\r\n{\r\nif (rspi->byte_access)\r\nrspi_write8(rspi, data, RSPI_SPDR);\r\nelse\r\nrspi_write16(rspi, data, RSPI_SPDR);\r\n}\r\nstatic u16 rspi_read_data(const struct rspi_data *rspi)\r\n{\r\nif (rspi->byte_access)\r\nreturn rspi_read8(rspi, RSPI_SPDR);\r\nelse\r\nreturn rspi_read16(rspi, RSPI_SPDR);\r\n}\r\nstatic int rspi_set_config_register(struct rspi_data *rspi, int access_size)\r\n{\r\nint spbr;\r\nrspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);\r\nspbr = DIV_ROUND_UP(clk_get_rate(rspi->clk),\r\n2 * rspi->max_speed_hz) - 1;\r\nrspi_write8(rspi, clamp(spbr, 0, 255), RSPI_SPBR);\r\nrspi_write8(rspi, 0, RSPI_SPDCR);\r\nrspi->byte_access = 0;\r\nrspi_write8(rspi, 0x00, RSPI_SPCKD);\r\nrspi_write8(rspi, 0x00, RSPI_SSLND);\r\nrspi_write8(rspi, 0x00, RSPI_SPND);\r\nrspi_write8(rspi, 0x00, RSPI_SPCR2);\r\nrspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);\r\nrspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);\r\nrspi_write8(rspi, SPCR_MSTR, RSPI_SPCR);\r\nreturn 0;\r\n}\r\nstatic int rspi_rz_set_config_register(struct rspi_data *rspi, int access_size)\r\n{\r\nint spbr;\r\nrspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);\r\nspbr = DIV_ROUND_UP(clk_get_rate(rspi->clk),\r\n2 * rspi->max_speed_hz) - 1;\r\nrspi_write8(rspi, clamp(spbr, 0, 255), RSPI_SPBR);\r\nrspi_write8(rspi, SPDCR_SPLBYTE, RSPI_SPDCR);\r\nrspi->byte_access = 1;\r\nrspi_write8(rspi, 0x00, RSPI_SPCKD);\r\nrspi_write8(rspi, 0x00, RSPI_SSLND);\r\nrspi_write8(rspi, 0x00, RSPI_SPND);\r\nrspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);\r\nrspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);\r\nrspi_write8(rspi, SPCR_MSTR, RSPI_SPCR);\r\nreturn 0;\r\n}\r\nstatic int qspi_set_config_register(struct rspi_data *rspi, int access_size)\r\n{\r\nint spbr;\r\nrspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);\r\nspbr = DIV_ROUND_UP(clk_get_rate(rspi->clk), 2 * rspi->max_speed_hz);\r\nrspi_write8(rspi, clamp(spbr, 0, 255), RSPI_SPBR);\r\nrspi_write8(rspi, 0, RSPI_SPDCR);\r\nrspi->byte_access = 1;\r\nrspi_write8(rspi, 0x00, RSPI_SPCKD);\r\nrspi_write8(rspi, 0x00, RSPI_SSLND);\r\nrspi_write8(rspi, 0x00, RSPI_SPND);\r\nif (access_size == 8)\r\nrspi->spcmd |= SPCMD_SPB_8BIT;\r\nelse if (access_size == 16)\r\nrspi->spcmd |= SPCMD_SPB_16BIT;\r\nelse\r\nrspi->spcmd |= SPCMD_SPB_32BIT;\r\nrspi->spcmd |= SPCMD_SCKDEN | SPCMD_SLNDEN | SPCMD_SPNDEN;\r\nrspi_write32(rspi, 0, QSPI_SPBMUL0);\r\nrspi_write8(rspi, SPBFCR_TXRST | SPBFCR_RXRST, QSPI_SPBFCR);\r\nrspi_write8(rspi, 0x00, QSPI_SPBFCR);\r\nrspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);\r\nrspi_write8(rspi, SPCR_SPE | SPCR_MSTR, RSPI_SPCR);\r\nreturn 0;\r\n}\r\nstatic void qspi_update(const struct rspi_data *rspi, u8 mask, u8 val, u8 reg)\r\n{\r\nu8 data;\r\ndata = rspi_read8(rspi, reg);\r\ndata &= ~mask;\r\ndata |= (val & mask);\r\nrspi_write8(rspi, data, reg);\r\n}\r\nstatic unsigned int qspi_set_send_trigger(struct rspi_data *rspi,\r\nunsigned int len)\r\n{\r\nunsigned int n;\r\nn = min(len, QSPI_BUFFER_SIZE);\r\nif (len >= QSPI_BUFFER_SIZE) {\r\nqspi_update(rspi, SPBFCR_TXTRG_MASK,\r\nSPBFCR_TXTRG_32B, QSPI_SPBFCR);\r\n} else {\r\nqspi_update(rspi, SPBFCR_TXTRG_MASK,\r\nSPBFCR_TXTRG_1B, QSPI_SPBFCR);\r\n}\r\nreturn n;\r\n}\r\nstatic void qspi_set_receive_trigger(struct rspi_data *rspi, unsigned int len)\r\n{\r\nunsigned int n;\r\nn = min(len, QSPI_BUFFER_SIZE);\r\nif (len >= QSPI_BUFFER_SIZE) {\r\nqspi_update(rspi, SPBFCR_RXTRG_MASK,\r\nSPBFCR_RXTRG_32B, QSPI_SPBFCR);\r\n} else {\r\nqspi_update(rspi, SPBFCR_RXTRG_MASK,\r\nSPBFCR_RXTRG_1B, QSPI_SPBFCR);\r\n}\r\n}\r\nstatic void rspi_enable_irq(const struct rspi_data *rspi, u8 enable)\r\n{\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | enable, RSPI_SPCR);\r\n}\r\nstatic void rspi_disable_irq(const struct rspi_data *rspi, u8 disable)\r\n{\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~disable, RSPI_SPCR);\r\n}\r\nstatic int rspi_wait_for_interrupt(struct rspi_data *rspi, u8 wait_mask,\r\nu8 enable_bit)\r\n{\r\nint ret;\r\nrspi->spsr = rspi_read8(rspi, RSPI_SPSR);\r\nif (rspi->spsr & wait_mask)\r\nreturn 0;\r\nrspi_enable_irq(rspi, enable_bit);\r\nret = wait_event_timeout(rspi->wait, rspi->spsr & wait_mask, HZ);\r\nif (ret == 0 && !(rspi->spsr & wait_mask))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic inline int rspi_wait_for_tx_empty(struct rspi_data *rspi)\r\n{\r\nreturn rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE);\r\n}\r\nstatic inline int rspi_wait_for_rx_full(struct rspi_data *rspi)\r\n{\r\nreturn rspi_wait_for_interrupt(rspi, SPSR_SPRF, SPCR_SPRIE);\r\n}\r\nstatic int rspi_data_out(struct rspi_data *rspi, u8 data)\r\n{\r\nint error = rspi_wait_for_tx_empty(rspi);\r\nif (error < 0) {\r\ndev_err(&rspi->master->dev, "transmit timeout\n");\r\nreturn error;\r\n}\r\nrspi_write_data(rspi, data);\r\nreturn 0;\r\n}\r\nstatic int rspi_data_in(struct rspi_data *rspi)\r\n{\r\nint error;\r\nu8 data;\r\nerror = rspi_wait_for_rx_full(rspi);\r\nif (error < 0) {\r\ndev_err(&rspi->master->dev, "receive timeout\n");\r\nreturn error;\r\n}\r\ndata = rspi_read_data(rspi);\r\nreturn data;\r\n}\r\nstatic int rspi_pio_transfer(struct rspi_data *rspi, const u8 *tx, u8 *rx,\r\nunsigned int n)\r\n{\r\nwhile (n-- > 0) {\r\nif (tx) {\r\nint ret = rspi_data_out(rspi, *tx++);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (rx) {\r\nint ret = rspi_data_in(rspi);\r\nif (ret < 0)\r\nreturn ret;\r\n*rx++ = ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rspi_dma_complete(void *arg)\r\n{\r\nstruct rspi_data *rspi = arg;\r\nrspi->dma_callbacked = 1;\r\nwake_up_interruptible(&rspi->wait);\r\n}\r\nstatic int rspi_dma_transfer(struct rspi_data *rspi, struct sg_table *tx,\r\nstruct sg_table *rx)\r\n{\r\nstruct dma_async_tx_descriptor *desc_tx = NULL, *desc_rx = NULL;\r\nu8 irq_mask = 0;\r\nunsigned int other_irq = 0;\r\ndma_cookie_t cookie;\r\nint ret;\r\nif (rx) {\r\ndesc_rx = dmaengine_prep_slave_sg(rspi->master->dma_rx,\r\nrx->sgl, rx->nents, DMA_FROM_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc_rx) {\r\nret = -EAGAIN;\r\ngoto no_dma_rx;\r\n}\r\ndesc_rx->callback = rspi_dma_complete;\r\ndesc_rx->callback_param = rspi;\r\ncookie = dmaengine_submit(desc_rx);\r\nif (dma_submit_error(cookie)) {\r\nret = cookie;\r\ngoto no_dma_rx;\r\n}\r\nirq_mask |= SPCR_SPRIE;\r\n}\r\nif (tx) {\r\ndesc_tx = dmaengine_prep_slave_sg(rspi->master->dma_tx,\r\ntx->sgl, tx->nents, DMA_TO_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc_tx) {\r\nret = -EAGAIN;\r\ngoto no_dma_tx;\r\n}\r\nif (rx) {\r\ndesc_tx->callback = NULL;\r\n} else {\r\ndesc_tx->callback = rspi_dma_complete;\r\ndesc_tx->callback_param = rspi;\r\n}\r\ncookie = dmaengine_submit(desc_tx);\r\nif (dma_submit_error(cookie)) {\r\nret = cookie;\r\ngoto no_dma_tx;\r\n}\r\nirq_mask |= SPCR_SPTIE;\r\n}\r\nif (tx)\r\ndisable_irq(other_irq = rspi->tx_irq);\r\nif (rx && rspi->rx_irq != other_irq)\r\ndisable_irq(rspi->rx_irq);\r\nrspi_enable_irq(rspi, irq_mask);\r\nrspi->dma_callbacked = 0;\r\nif (rx)\r\ndma_async_issue_pending(rspi->master->dma_rx);\r\nif (tx)\r\ndma_async_issue_pending(rspi->master->dma_tx);\r\nret = wait_event_interruptible_timeout(rspi->wait,\r\nrspi->dma_callbacked, HZ);\r\nif (ret > 0 && rspi->dma_callbacked)\r\nret = 0;\r\nelse if (!ret) {\r\ndev_err(&rspi->master->dev, "DMA timeout\n");\r\nret = -ETIMEDOUT;\r\nif (tx)\r\ndmaengine_terminate_all(rspi->master->dma_tx);\r\nif (rx)\r\ndmaengine_terminate_all(rspi->master->dma_rx);\r\n}\r\nrspi_disable_irq(rspi, irq_mask);\r\nif (tx)\r\nenable_irq(rspi->tx_irq);\r\nif (rx && rspi->rx_irq != other_irq)\r\nenable_irq(rspi->rx_irq);\r\nreturn ret;\r\nno_dma_tx:\r\nif (rx)\r\ndmaengine_terminate_all(rspi->master->dma_rx);\r\nno_dma_rx:\r\nif (ret == -EAGAIN) {\r\npr_warn_once("%s %s: DMA not available, falling back to PIO\n",\r\ndev_driver_string(&rspi->master->dev),\r\ndev_name(&rspi->master->dev));\r\n}\r\nreturn ret;\r\n}\r\nstatic void rspi_receive_init(const struct rspi_data *rspi)\r\n{\r\nu8 spsr;\r\nspsr = rspi_read8(rspi, RSPI_SPSR);\r\nif (spsr & SPSR_SPRF)\r\nrspi_read_data(rspi);\r\nif (spsr & SPSR_OVRF)\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPSR) & ~SPSR_OVRF,\r\nRSPI_SPSR);\r\n}\r\nstatic void rspi_rz_receive_init(const struct rspi_data *rspi)\r\n{\r\nrspi_receive_init(rspi);\r\nrspi_write8(rspi, SPBFCR_TXRST | SPBFCR_RXRST, RSPI_SPBFCR);\r\nrspi_write8(rspi, 0, RSPI_SPBFCR);\r\n}\r\nstatic void qspi_receive_init(const struct rspi_data *rspi)\r\n{\r\nu8 spsr;\r\nspsr = rspi_read8(rspi, RSPI_SPSR);\r\nif (spsr & SPSR_SPRF)\r\nrspi_read_data(rspi);\r\nrspi_write8(rspi, SPBFCR_TXRST | SPBFCR_RXRST, QSPI_SPBFCR);\r\nrspi_write8(rspi, 0, QSPI_SPBFCR);\r\n}\r\nstatic bool __rspi_can_dma(const struct rspi_data *rspi,\r\nconst struct spi_transfer *xfer)\r\n{\r\nreturn xfer->len > rspi->ops->fifo_size;\r\n}\r\nstatic bool rspi_can_dma(struct spi_master *master, struct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct rspi_data *rspi = spi_master_get_devdata(master);\r\nreturn __rspi_can_dma(rspi, xfer);\r\n}\r\nstatic int rspi_dma_check_then_transfer(struct rspi_data *rspi,\r\nstruct spi_transfer *xfer)\r\n{\r\nif (!rspi->master->can_dma || !__rspi_can_dma(rspi, xfer))\r\nreturn -EAGAIN;\r\nreturn rspi_dma_transfer(rspi, &xfer->tx_sg,\r\nxfer->rx_buf ? &xfer->rx_sg : NULL);\r\n}\r\nstatic int rspi_common_transfer(struct rspi_data *rspi,\r\nstruct spi_transfer *xfer)\r\n{\r\nint ret;\r\nret = rspi_dma_check_then_transfer(rspi, xfer);\r\nif (ret != -EAGAIN)\r\nreturn ret;\r\nret = rspi_pio_transfer(rspi, xfer->tx_buf, xfer->rx_buf, xfer->len);\r\nif (ret < 0)\r\nreturn ret;\r\nrspi_wait_for_tx_empty(rspi);\r\nreturn 0;\r\n}\r\nstatic int rspi_transfer_one(struct spi_master *master, struct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct rspi_data *rspi = spi_master_get_devdata(master);\r\nu8 spcr;\r\nspcr = rspi_read8(rspi, RSPI_SPCR);\r\nif (xfer->rx_buf) {\r\nrspi_receive_init(rspi);\r\nspcr &= ~SPCR_TXMD;\r\n} else {\r\nspcr |= SPCR_TXMD;\r\n}\r\nrspi_write8(rspi, spcr, RSPI_SPCR);\r\nreturn rspi_common_transfer(rspi, xfer);\r\n}\r\nstatic int rspi_rz_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct rspi_data *rspi = spi_master_get_devdata(master);\r\nrspi_rz_receive_init(rspi);\r\nreturn rspi_common_transfer(rspi, xfer);\r\n}\r\nstatic int qspi_trigger_transfer_out_in(struct rspi_data *rspi, const u8 *tx,\r\nu8 *rx, unsigned int len)\r\n{\r\nunsigned int i, n;\r\nint ret;\r\nwhile (len > 0) {\r\nn = qspi_set_send_trigger(rspi, len);\r\nqspi_set_receive_trigger(rspi, len);\r\nif (n == QSPI_BUFFER_SIZE) {\r\nret = rspi_wait_for_tx_empty(rspi);\r\nif (ret < 0) {\r\ndev_err(&rspi->master->dev, "transmit timeout\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < n; i++)\r\nrspi_write_data(rspi, *tx++);\r\nret = rspi_wait_for_rx_full(rspi);\r\nif (ret < 0) {\r\ndev_err(&rspi->master->dev, "receive timeout\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < n; i++)\r\n*rx++ = rspi_read_data(rspi);\r\n} else {\r\nret = rspi_pio_transfer(rspi, tx, rx, n);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nlen -= n;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qspi_transfer_out_in(struct rspi_data *rspi,\r\nstruct spi_transfer *xfer)\r\n{\r\nint ret;\r\nqspi_receive_init(rspi);\r\nret = rspi_dma_check_then_transfer(rspi, xfer);\r\nif (ret != -EAGAIN)\r\nreturn ret;\r\nreturn qspi_trigger_transfer_out_in(rspi, xfer->tx_buf,\r\nxfer->rx_buf, xfer->len);\r\n}\r\nstatic int qspi_transfer_out(struct rspi_data *rspi, struct spi_transfer *xfer)\r\n{\r\nint ret;\r\nif (rspi->master->can_dma && __rspi_can_dma(rspi, xfer)) {\r\nret = rspi_dma_transfer(rspi, &xfer->tx_sg, NULL);\r\nif (ret != -EAGAIN)\r\nreturn ret;\r\n}\r\nret = rspi_pio_transfer(rspi, xfer->tx_buf, NULL, xfer->len);\r\nif (ret < 0)\r\nreturn ret;\r\nrspi_wait_for_tx_empty(rspi);\r\nreturn 0;\r\n}\r\nstatic int qspi_transfer_in(struct rspi_data *rspi, struct spi_transfer *xfer)\r\n{\r\nif (rspi->master->can_dma && __rspi_can_dma(rspi, xfer)) {\r\nint ret = rspi_dma_transfer(rspi, NULL, &xfer->rx_sg);\r\nif (ret != -EAGAIN)\r\nreturn ret;\r\n}\r\nreturn rspi_pio_transfer(rspi, NULL, xfer->rx_buf, xfer->len);\r\n}\r\nstatic int qspi_transfer_one(struct spi_master *master, struct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct rspi_data *rspi = spi_master_get_devdata(master);\r\nif (spi->mode & SPI_LOOP) {\r\nreturn qspi_transfer_out_in(rspi, xfer);\r\n} else if (xfer->tx_nbits > SPI_NBITS_SINGLE) {\r\nreturn qspi_transfer_out(rspi, xfer);\r\n} else if (xfer->rx_nbits > SPI_NBITS_SINGLE) {\r\nreturn qspi_transfer_in(rspi, xfer);\r\n} else {\r\nreturn qspi_transfer_out_in(rspi, xfer);\r\n}\r\n}\r\nstatic int rspi_setup(struct spi_device *spi)\r\n{\r\nstruct rspi_data *rspi = spi_master_get_devdata(spi->master);\r\nrspi->max_speed_hz = spi->max_speed_hz;\r\nrspi->spcmd = SPCMD_SSLKP;\r\nif (spi->mode & SPI_CPOL)\r\nrspi->spcmd |= SPCMD_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\nrspi->spcmd |= SPCMD_CPHA;\r\nrspi->sppcr = 0;\r\nif (spi->mode & SPI_LOOP)\r\nrspi->sppcr |= SPPCR_SPLP;\r\nset_config_register(rspi, 8);\r\nreturn 0;\r\n}\r\nstatic u16 qspi_transfer_mode(const struct spi_transfer *xfer)\r\n{\r\nif (xfer->tx_buf)\r\nswitch (xfer->tx_nbits) {\r\ncase SPI_NBITS_QUAD:\r\nreturn SPCMD_SPIMOD_QUAD;\r\ncase SPI_NBITS_DUAL:\r\nreturn SPCMD_SPIMOD_DUAL;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (xfer->rx_buf)\r\nswitch (xfer->rx_nbits) {\r\ncase SPI_NBITS_QUAD:\r\nreturn SPCMD_SPIMOD_QUAD | SPCMD_SPRW;\r\ncase SPI_NBITS_DUAL:\r\nreturn SPCMD_SPIMOD_DUAL | SPCMD_SPRW;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qspi_setup_sequencer(struct rspi_data *rspi,\r\nconst struct spi_message *msg)\r\n{\r\nconst struct spi_transfer *xfer;\r\nunsigned int i = 0, len = 0;\r\nu16 current_mode = 0xffff, mode;\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nmode = qspi_transfer_mode(xfer);\r\nif (mode == current_mode) {\r\nlen += xfer->len;\r\ncontinue;\r\n}\r\nif (i) {\r\nrspi_write32(rspi, len, QSPI_SPBMUL(i - 1));\r\n}\r\nif (i >= QSPI_NUM_SPCMD) {\r\ndev_err(&msg->spi->dev,\r\n"Too many different transfer modes");\r\nreturn -EINVAL;\r\n}\r\nrspi_write16(rspi, rspi->spcmd | mode, RSPI_SPCMD(i));\r\ncurrent_mode = mode;\r\nlen = xfer->len;\r\ni++;\r\n}\r\nif (i) {\r\nrspi_write32(rspi, len, QSPI_SPBMUL(i - 1));\r\nrspi_write8(rspi, i - 1, RSPI_SPSCR);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rspi_prepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct rspi_data *rspi = spi_master_get_devdata(master);\r\nint ret;\r\nif (msg->spi->mode &\r\n(SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD)) {\r\nret = qspi_setup_sequencer(rspi, msg);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_SPE, RSPI_SPCR);\r\nreturn 0;\r\n}\r\nstatic int rspi_unprepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct rspi_data *rspi = spi_master_get_devdata(master);\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_SPE, RSPI_SPCR);\r\nrspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);\r\nrspi_write8(rspi, 0, RSPI_SPSCR);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t rspi_irq_mux(int irq, void *_sr)\r\n{\r\nstruct rspi_data *rspi = _sr;\r\nu8 spsr;\r\nirqreturn_t ret = IRQ_NONE;\r\nu8 disable_irq = 0;\r\nrspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);\r\nif (spsr & SPSR_SPRF)\r\ndisable_irq |= SPCR_SPRIE;\r\nif (spsr & SPSR_SPTEF)\r\ndisable_irq |= SPCR_SPTIE;\r\nif (disable_irq) {\r\nret = IRQ_HANDLED;\r\nrspi_disable_irq(rspi, disable_irq);\r\nwake_up(&rspi->wait);\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t rspi_irq_rx(int irq, void *_sr)\r\n{\r\nstruct rspi_data *rspi = _sr;\r\nu8 spsr;\r\nrspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);\r\nif (spsr & SPSR_SPRF) {\r\nrspi_disable_irq(rspi, SPCR_SPRIE);\r\nwake_up(&rspi->wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t rspi_irq_tx(int irq, void *_sr)\r\n{\r\nstruct rspi_data *rspi = _sr;\r\nu8 spsr;\r\nrspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);\r\nif (spsr & SPSR_SPTEF) {\r\nrspi_disable_irq(rspi, SPCR_SPTIE);\r\nwake_up(&rspi->wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct dma_chan *rspi_request_dma_chan(struct device *dev,\r\nenum dma_transfer_direction dir,\r\nunsigned int id,\r\ndma_addr_t port_addr)\r\n{\r\ndma_cap_mask_t mask;\r\nstruct dma_chan *chan;\r\nstruct dma_slave_config cfg;\r\nint ret;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nchan = dma_request_slave_channel_compat(mask, shdma_chan_filter,\r\n(void *)(unsigned long)id, dev,\r\ndir == DMA_MEM_TO_DEV ? "tx" : "rx");\r\nif (!chan) {\r\ndev_warn(dev, "dma_request_slave_channel_compat failed\n");\r\nreturn NULL;\r\n}\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.direction = dir;\r\nif (dir == DMA_MEM_TO_DEV) {\r\ncfg.dst_addr = port_addr;\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\n} else {\r\ncfg.src_addr = port_addr;\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\n}\r\nret = dmaengine_slave_config(chan, &cfg);\r\nif (ret) {\r\ndev_warn(dev, "dmaengine_slave_config failed %d\n", ret);\r\ndma_release_channel(chan);\r\nreturn NULL;\r\n}\r\nreturn chan;\r\n}\r\nstatic int rspi_request_dma(struct device *dev, struct spi_master *master,\r\nconst struct resource *res)\r\n{\r\nconst struct rspi_plat_data *rspi_pd = dev_get_platdata(dev);\r\nunsigned int dma_tx_id, dma_rx_id;\r\nif (dev->of_node) {\r\ndma_tx_id = 0;\r\ndma_rx_id = 0;\r\n} else if (rspi_pd && rspi_pd->dma_tx_id && rspi_pd->dma_rx_id) {\r\ndma_tx_id = rspi_pd->dma_tx_id;\r\ndma_rx_id = rspi_pd->dma_rx_id;\r\n} else {\r\nreturn 0;\r\n}\r\nmaster->dma_tx = rspi_request_dma_chan(dev, DMA_MEM_TO_DEV, dma_tx_id,\r\nres->start + RSPI_SPDR);\r\nif (!master->dma_tx)\r\nreturn -ENODEV;\r\nmaster->dma_rx = rspi_request_dma_chan(dev, DMA_DEV_TO_MEM, dma_rx_id,\r\nres->start + RSPI_SPDR);\r\nif (!master->dma_rx) {\r\ndma_release_channel(master->dma_tx);\r\nmaster->dma_tx = NULL;\r\nreturn -ENODEV;\r\n}\r\nmaster->can_dma = rspi_can_dma;\r\ndev_info(dev, "DMA available");\r\nreturn 0;\r\n}\r\nstatic void rspi_release_dma(struct spi_master *master)\r\n{\r\nif (master->dma_tx)\r\ndma_release_channel(master->dma_tx);\r\nif (master->dma_rx)\r\ndma_release_channel(master->dma_rx);\r\n}\r\nstatic int rspi_remove(struct platform_device *pdev)\r\n{\r\nstruct rspi_data *rspi = platform_get_drvdata(pdev);\r\nrspi_release_dma(rspi->master);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int rspi_parse_dt(struct device *dev, struct spi_master *master)\r\n{\r\nu32 num_cs;\r\nint error;\r\nerror = of_property_read_u32(dev->of_node, "num-cs", &num_cs);\r\nif (error) {\r\ndev_err(dev, "of_property_read_u32 num-cs failed %d\n", error);\r\nreturn error;\r\n}\r\nmaster->num_chipselect = num_cs;\r\nreturn 0;\r\n}\r\nstatic inline int rspi_parse_dt(struct device *dev, struct spi_master *master)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int rspi_request_irq(struct device *dev, unsigned int irq,\r\nirq_handler_t handler, const char *suffix,\r\nvoid *dev_id)\r\n{\r\nconst char *name = devm_kasprintf(dev, GFP_KERNEL, "%s:%s",\r\ndev_name(dev), suffix);\r\nif (!name)\r\nreturn -ENOMEM;\r\nreturn devm_request_irq(dev, irq, handler, 0, name, dev_id);\r\n}\r\nstatic int rspi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct spi_master *master;\r\nstruct rspi_data *rspi;\r\nint ret;\r\nconst struct of_device_id *of_id;\r\nconst struct rspi_plat_data *rspi_pd;\r\nconst struct spi_ops *ops;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct rspi_data));\r\nif (master == NULL) {\r\ndev_err(&pdev->dev, "spi_alloc_master error.\n");\r\nreturn -ENOMEM;\r\n}\r\nof_id = of_match_device(rspi_of_match, &pdev->dev);\r\nif (of_id) {\r\nops = of_id->data;\r\nret = rspi_parse_dt(&pdev->dev, master);\r\nif (ret)\r\ngoto error1;\r\n} else {\r\nops = (struct spi_ops *)pdev->id_entry->driver_data;\r\nrspi_pd = dev_get_platdata(&pdev->dev);\r\nif (rspi_pd && rspi_pd->num_chipselect)\r\nmaster->num_chipselect = rspi_pd->num_chipselect;\r\nelse\r\nmaster->num_chipselect = 2;\r\n}\r\nif (!ops->set_config_register) {\r\ndev_err(&pdev->dev, "there is no set_config_register\n");\r\nret = -ENODEV;\r\ngoto error1;\r\n}\r\nrspi = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, rspi);\r\nrspi->ops = ops;\r\nrspi->master = master;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrspi->addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rspi->addr)) {\r\nret = PTR_ERR(rspi->addr);\r\ngoto error1;\r\n}\r\nrspi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(rspi->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nret = PTR_ERR(rspi->clk);\r\ngoto error1;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\ninit_waitqueue_head(&rspi->wait);\r\nmaster->bus_num = pdev->id;\r\nmaster->setup = rspi_setup;\r\nmaster->auto_runtime_pm = true;\r\nmaster->transfer_one = ops->transfer_one;\r\nmaster->prepare_message = rspi_prepare_message;\r\nmaster->unprepare_message = rspi_unprepare_message;\r\nmaster->mode_bits = ops->mode_bits;\r\nmaster->flags = ops->flags;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nret = platform_get_irq_byname(pdev, "rx");\r\nif (ret < 0) {\r\nret = platform_get_irq_byname(pdev, "mux");\r\nif (ret < 0)\r\nret = platform_get_irq(pdev, 0);\r\nif (ret >= 0)\r\nrspi->rx_irq = rspi->tx_irq = ret;\r\n} else {\r\nrspi->rx_irq = ret;\r\nret = platform_get_irq_byname(pdev, "tx");\r\nif (ret >= 0)\r\nrspi->tx_irq = ret;\r\n}\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "platform_get_irq error\n");\r\ngoto error2;\r\n}\r\nif (rspi->rx_irq == rspi->tx_irq) {\r\nret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_mux,\r\n"mux", rspi);\r\n} else {\r\nret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_rx,\r\n"rx", rspi);\r\nif (!ret)\r\nret = rspi_request_irq(&pdev->dev, rspi->tx_irq,\r\nrspi_irq_tx, "tx", rspi);\r\n}\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "request_irq error\n");\r\ngoto error2;\r\n}\r\nret = rspi_request_dma(&pdev->dev, master, res);\r\nif (ret < 0)\r\ndev_warn(&pdev->dev, "DMA not available, using PIO\n");\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "spi_register_master error.\n");\r\ngoto error3;\r\n}\r\ndev_info(&pdev->dev, "probed\n");\r\nreturn 0;\r\nerror3:\r\nrspi_release_dma(master);\r\nerror2:\r\npm_runtime_disable(&pdev->dev);\r\nerror1:\r\nspi_master_put(master);\r\nreturn ret;\r\n}
