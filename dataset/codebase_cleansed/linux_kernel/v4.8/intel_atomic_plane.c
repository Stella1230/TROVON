struct intel_plane_state *\r\nintel_create_plane_state(struct drm_plane *plane)\r\n{\r\nstruct intel_plane_state *state;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\nstate->base.plane = plane;\r\nstate->base.rotation = BIT(DRM_ROTATE_0);\r\nstate->ckey.flags = I915_SET_COLORKEY_NONE;\r\nreturn state;\r\n}\r\nstruct drm_plane_state *\r\nintel_plane_duplicate_state(struct drm_plane *plane)\r\n{\r\nstruct drm_plane_state *state;\r\nstruct intel_plane_state *intel_state;\r\nintel_state = kmemdup(plane->state, sizeof(*intel_state), GFP_KERNEL);\r\nif (!intel_state)\r\nreturn NULL;\r\nstate = &intel_state->base;\r\n__drm_atomic_helper_plane_duplicate_state(plane, state);\r\nintel_state->wait_req = NULL;\r\nreturn state;\r\n}\r\nvoid\r\nintel_plane_destroy_state(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nWARN_ON(state && to_intel_plane_state(state)->wait_req);\r\ndrm_atomic_helper_plane_destroy_state(plane, state);\r\n}\r\nstatic int intel_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct drm_crtc *crtc = state->crtc;\r\nstruct intel_crtc *intel_crtc;\r\nstruct intel_crtc_state *crtc_state;\r\nstruct intel_plane *intel_plane = to_intel_plane(plane);\r\nstruct intel_plane_state *intel_state = to_intel_plane_state(state);\r\nstruct drm_crtc_state *drm_crtc_state;\r\nint ret;\r\ncrtc = crtc ? crtc : plane->state->crtc;\r\nintel_crtc = to_intel_crtc(crtc);\r\nif (!crtc)\r\nreturn 0;\r\ndrm_crtc_state = drm_atomic_get_existing_crtc_state(state->state, crtc);\r\nif (WARN_ON(!drm_crtc_state))\r\nreturn -EINVAL;\r\ncrtc_state = to_intel_crtc_state(drm_crtc_state);\r\nintel_state->src.x1 = state->src_x;\r\nintel_state->src.y1 = state->src_y;\r\nintel_state->src.x2 = state->src_x + state->src_w;\r\nintel_state->src.y2 = state->src_y + state->src_h;\r\nintel_state->dst.x1 = state->crtc_x;\r\nintel_state->dst.y1 = state->crtc_y;\r\nintel_state->dst.x2 = state->crtc_x + state->crtc_w;\r\nintel_state->dst.y2 = state->crtc_y + state->crtc_h;\r\nintel_state->clip.x1 = 0;\r\nintel_state->clip.y1 = 0;\r\nintel_state->clip.x2 =\r\ncrtc_state->base.enable ? crtc_state->pipe_src_w : 0;\r\nintel_state->clip.y2 =\r\ncrtc_state->base.enable ? crtc_state->pipe_src_h : 0;\r\nif (state->fb && intel_rotation_90_or_270(state->rotation)) {\r\nif (!(state->fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||\r\nstate->fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED)) {\r\nDRM_DEBUG_KMS("Y/Yf tiling required for 90/270!\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (state->fb->pixel_format) {\r\ncase DRM_FORMAT_C8:\r\ncase DRM_FORMAT_RGB565:\r\nDRM_DEBUG_KMS("Unsupported pixel format %s for 90/270!\n",\r\ndrm_get_format_name(state->fb->pixel_format));\r\nreturn -EINVAL;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nintel_state->visible = false;\r\nret = intel_plane->check_plane(plane, crtc_state, intel_state);\r\nif (ret)\r\nreturn ret;\r\nreturn intel_plane_atomic_calc_changes(&crtc_state->base, state);\r\n}\r\nstatic void intel_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct intel_plane *intel_plane = to_intel_plane(plane);\r\nstruct intel_plane_state *intel_state =\r\nto_intel_plane_state(plane->state);\r\nstruct drm_crtc *crtc = plane->state->crtc ?: old_state->crtc;\r\nif (intel_state->visible)\r\nintel_plane->update_plane(plane,\r\nto_intel_crtc_state(crtc->state),\r\nintel_state);\r\nelse\r\nintel_plane->disable_plane(plane, crtc);\r\n}\r\nint\r\nintel_plane_atomic_get_property(struct drm_plane *plane,\r\nconst struct drm_plane_state *state,\r\nstruct drm_property *property,\r\nuint64_t *val)\r\n{\r\nDRM_DEBUG_KMS("Unknown plane property '%s'\n", property->name);\r\nreturn -EINVAL;\r\n}\r\nint\r\nintel_plane_atomic_set_property(struct drm_plane *plane,\r\nstruct drm_plane_state *state,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nDRM_DEBUG_KMS("Unknown plane property '%s'\n", property->name);\r\nreturn -EINVAL;\r\n}
