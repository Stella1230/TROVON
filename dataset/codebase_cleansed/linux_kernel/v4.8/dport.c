static int\r\ndp_set_link_config(struct dp_state *dp)\r\n{\r\nstruct nvkm_output_dp *outp = dp->outp;\r\nstruct nvkm_disp *disp = outp->base.disp;\r\nstruct nvkm_subdev *subdev = &disp->engine.subdev;\r\nstruct nvkm_bios *bios = subdev->device->bios;\r\nstruct nvbios_init init = {\r\n.subdev = subdev,\r\n.bios = bios,\r\n.offset = 0x0000,\r\n.outp = &outp->base.info,\r\n.crtc = -1,\r\n.execute = 1,\r\n};\r\nu32 lnkcmp;\r\nu8 sink[2];\r\nint ret;\r\nOUTP_DBG(&outp->base, "%d lanes at %d KB/s", dp->link_nr, dp->link_bw);\r\nif ((lnkcmp = dp->outp->info.lnkcmp)) {\r\nif (outp->version < 0x30) {\r\nwhile ((dp->link_bw / 10) < nvbios_rd16(bios, lnkcmp))\r\nlnkcmp += 4;\r\ninit.offset = nvbios_rd16(bios, lnkcmp + 2);\r\n} else {\r\nwhile ((dp->link_bw / 27000) < nvbios_rd08(bios, lnkcmp))\r\nlnkcmp += 3;\r\ninit.offset = nvbios_rd16(bios, lnkcmp + 1);\r\n}\r\nnvbios_exec(&init);\r\n}\r\nret = outp->func->lnk_ctl(outp, dp->link_nr, dp->link_bw / 27000,\r\noutp->dpcd[DPCD_RC02] &\r\nDPCD_RC02_ENHANCED_FRAME_CAP);\r\nif (ret) {\r\nif (ret < 0)\r\nOUTP_ERR(&outp->base, "lnk_ctl failed with %d", ret);\r\nreturn ret;\r\n}\r\noutp->func->lnk_pwr(outp, dp->link_nr);\r\nsink[0] = dp->link_bw / 27000;\r\nsink[1] = dp->link_nr;\r\nif (outp->dpcd[DPCD_RC02] & DPCD_RC02_ENHANCED_FRAME_CAP)\r\nsink[1] |= DPCD_LC01_ENHANCED_FRAME_EN;\r\nreturn nvkm_wraux(outp->aux, DPCD_LC00_LINK_BW_SET, sink, 2);\r\n}\r\nstatic void\r\ndp_set_training_pattern(struct dp_state *dp, u8 pattern)\r\n{\r\nstruct nvkm_output_dp *outp = dp->outp;\r\nu8 sink_tp;\r\nOUTP_DBG(&outp->base, "training pattern %d", pattern);\r\noutp->func->pattern(outp, pattern);\r\nnvkm_rdaux(outp->aux, DPCD_LC02, &sink_tp, 1);\r\nsink_tp &= ~DPCD_LC02_TRAINING_PATTERN_SET;\r\nsink_tp |= pattern;\r\nnvkm_wraux(outp->aux, DPCD_LC02, &sink_tp, 1);\r\n}\r\nstatic int\r\ndp_link_train_commit(struct dp_state *dp, bool pc)\r\n{\r\nstruct nvkm_output_dp *outp = dp->outp;\r\nint ret, i;\r\nfor (i = 0; i < dp->link_nr; i++) {\r\nu8 lane = (dp->stat[4 + (i >> 1)] >> ((i & 1) * 4)) & 0xf;\r\nu8 lpc2 = (dp->pc2stat >> (i * 2)) & 0x3;\r\nu8 lpre = (lane & 0x0c) >> 2;\r\nu8 lvsw = (lane & 0x03) >> 0;\r\nu8 hivs = 3 - lpre;\r\nu8 hipe = 3;\r\nu8 hipc = 3;\r\nif (lpc2 >= hipc)\r\nlpc2 = hipc | DPCD_LC0F_LANE0_MAX_POST_CURSOR2_REACHED;\r\nif (lpre >= hipe) {\r\nlpre = hipe | DPCD_LC03_MAX_SWING_REACHED;\r\nlvsw = hivs = 3 - (lpre & 3);\r\n} else\r\nif (lvsw >= hivs) {\r\nlvsw = hivs | DPCD_LC03_MAX_SWING_REACHED;\r\n}\r\ndp->conf[i] = (lpre << 3) | lvsw;\r\ndp->pc2conf[i >> 1] |= lpc2 << ((i & 1) * 4);\r\nOUTP_DBG(&outp->base, "config lane %d %02x %02x",\r\ni, dp->conf[i], lpc2);\r\noutp->func->drv_ctl(outp, i, lvsw & 3, lpre & 3, lpc2 & 3);\r\n}\r\nret = nvkm_wraux(outp->aux, DPCD_LC03(0), dp->conf, 4);\r\nif (ret)\r\nreturn ret;\r\nif (pc) {\r\nret = nvkm_wraux(outp->aux, DPCD_LC0F, dp->pc2conf, 2);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndp_link_train_update(struct dp_state *dp, bool pc, u32 delay)\r\n{\r\nstruct nvkm_output_dp *outp = dp->outp;\r\nint ret;\r\nif (outp->dpcd[DPCD_RC0E_AUX_RD_INTERVAL])\r\nmdelay(outp->dpcd[DPCD_RC0E_AUX_RD_INTERVAL] * 4);\r\nelse\r\nudelay(delay);\r\nret = nvkm_rdaux(outp->aux, DPCD_LS02, dp->stat, 6);\r\nif (ret)\r\nreturn ret;\r\nif (pc) {\r\nret = nvkm_rdaux(outp->aux, DPCD_LS0C, &dp->pc2stat, 1);\r\nif (ret)\r\ndp->pc2stat = 0x00;\r\nOUTP_DBG(&outp->base, "status %6ph pc2 %02x",\r\ndp->stat, dp->pc2stat);\r\n} else {\r\nOUTP_DBG(&outp->base, "status %6ph", dp->stat);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndp_link_train_cr(struct dp_state *dp)\r\n{\r\nbool cr_done = false, abort = false;\r\nint voltage = dp->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET;\r\nint tries = 0, i;\r\ndp_set_training_pattern(dp, 1);\r\ndo {\r\nif (dp_link_train_commit(dp, false) ||\r\ndp_link_train_update(dp, false, 100))\r\nbreak;\r\ncr_done = true;\r\nfor (i = 0; i < dp->link_nr; i++) {\r\nu8 lane = (dp->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;\r\nif (!(lane & DPCD_LS02_LANE0_CR_DONE)) {\r\ncr_done = false;\r\nif (dp->conf[i] & DPCD_LC03_MAX_SWING_REACHED)\r\nabort = true;\r\nbreak;\r\n}\r\n}\r\nif ((dp->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET) != voltage) {\r\nvoltage = dp->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET;\r\ntries = 0;\r\n}\r\n} while (!cr_done && !abort && ++tries < 5);\r\nreturn cr_done ? 0 : -1;\r\n}\r\nstatic int\r\ndp_link_train_eq(struct dp_state *dp)\r\n{\r\nstruct nvkm_output_dp *outp = dp->outp;\r\nbool eq_done = false, cr_done = true;\r\nint tries = 0, i;\r\nif (outp->dpcd[2] & DPCD_RC02_TPS3_SUPPORTED)\r\ndp_set_training_pattern(dp, 3);\r\nelse\r\ndp_set_training_pattern(dp, 2);\r\ndo {\r\nif ((tries &&\r\ndp_link_train_commit(dp, dp->pc2)) ||\r\ndp_link_train_update(dp, dp->pc2, 400))\r\nbreak;\r\neq_done = !!(dp->stat[2] & DPCD_LS04_INTERLANE_ALIGN_DONE);\r\nfor (i = 0; i < dp->link_nr && eq_done; i++) {\r\nu8 lane = (dp->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;\r\nif (!(lane & DPCD_LS02_LANE0_CR_DONE))\r\ncr_done = false;\r\nif (!(lane & DPCD_LS02_LANE0_CHANNEL_EQ_DONE) ||\r\n!(lane & DPCD_LS02_LANE0_SYMBOL_LOCKED))\r\neq_done = false;\r\n}\r\n} while (!eq_done && cr_done && ++tries <= 5);\r\nreturn eq_done ? 0 : -1;\r\n}\r\nstatic void\r\ndp_link_train_init(struct dp_state *dp, bool spread)\r\n{\r\nstruct nvkm_output_dp *outp = dp->outp;\r\nstruct nvkm_disp *disp = outp->base.disp;\r\nstruct nvkm_subdev *subdev = &disp->engine.subdev;\r\nstruct nvbios_init init = {\r\n.subdev = subdev,\r\n.bios = subdev->device->bios,\r\n.outp = &outp->base.info,\r\n.crtc = -1,\r\n.execute = 1,\r\n};\r\nif (spread)\r\ninit.offset = outp->info.script[2];\r\nelse\r\ninit.offset = outp->info.script[3];\r\nnvbios_exec(&init);\r\ninit.offset = outp->info.script[0];\r\nnvbios_exec(&init);\r\n}\r\nstatic void\r\ndp_link_train_fini(struct dp_state *dp)\r\n{\r\nstruct nvkm_output_dp *outp = dp->outp;\r\nstruct nvkm_disp *disp = outp->base.disp;\r\nstruct nvkm_subdev *subdev = &disp->engine.subdev;\r\nstruct nvbios_init init = {\r\n.subdev = subdev,\r\n.bios = subdev->device->bios,\r\n.outp = &outp->base.info,\r\n.crtc = -1,\r\n.execute = 1,\r\n};\r\ninit.offset = outp->info.script[1],\r\nnvbios_exec(&init);\r\n}\r\nvoid\r\nnvkm_dp_train(struct work_struct *w)\r\n{\r\nstruct nvkm_output_dp *outp = container_of(w, typeof(*outp), lt.work);\r\nstruct nv50_disp *disp = nv50_disp(outp->base.disp);\r\nconst struct dp_rates *cfg = nvkm_dp_rates;\r\nstruct dp_state _dp = {\r\n.outp = outp,\r\n}, *dp = &_dp;\r\nu32 datarate = 0;\r\nu8 pwr;\r\nint ret;\r\nif (!outp->base.info.location && disp->func->sor.magic)\r\ndisp->func->sor.magic(&outp->base);\r\nif (disp->base.engine.subdev.device->chipset < 0xd0)\r\noutp->dpcd[2] &= ~DPCD_RC02_TPS3_SUPPORTED;\r\nif ((outp->dpcd[2] & 0x1f) > outp->base.info.dpconf.link_nr) {\r\noutp->dpcd[2] &= ~DPCD_RC02_MAX_LANE_COUNT;\r\noutp->dpcd[2] |= outp->base.info.dpconf.link_nr;\r\n}\r\nif (outp->dpcd[1] > outp->base.info.dpconf.link_bw)\r\noutp->dpcd[1] = outp->base.info.dpconf.link_bw;\r\ndp->pc2 = outp->dpcd[2] & DPCD_RC02_TPS3_SUPPORTED;\r\nif (datarate) {\r\ndatarate = (datarate / 8) * 10;\r\nwhile (cfg[1].rate >= datarate)\r\ncfg++;\r\n}\r\ncfg--;\r\nnvkm_notify_put(&outp->irq);\r\nif (!nvkm_rdaux(outp->aux, DPCD_SC00, &pwr, 1)) {\r\nif ((pwr & DPCD_SC00_SET_POWER) != DPCD_SC00_SET_POWER_D0) {\r\npwr &= ~DPCD_SC00_SET_POWER;\r\npwr |= DPCD_SC00_SET_POWER_D0;\r\nnvkm_wraux(outp->aux, DPCD_SC00, &pwr, 1);\r\n}\r\n}\r\ndp_link_train_init(dp, outp->dpcd[3] & 0x01);\r\nwhile (ret = -EIO, (++cfg)->rate) {\r\nwhile (cfg->nr > (outp->dpcd[2] & DPCD_RC02_MAX_LANE_COUNT) ||\r\ncfg->bw > (outp->dpcd[DPCD_RC01_MAX_LINK_RATE]))\r\ncfg++;\r\ndp->link_bw = cfg->bw * 27000;\r\ndp->link_nr = cfg->nr;\r\nret = dp_set_link_config(dp);\r\nif (ret == 0) {\r\nmemset(dp->stat, 0x00, sizeof(dp->stat));\r\nif (!dp_link_train_cr(dp) &&\r\n!dp_link_train_eq(dp))\r\nbreak;\r\n} else\r\nif (ret) {\r\nbreak;\r\n}\r\n}\r\ndp_set_training_pattern(dp, 0);\r\nif (ret < 0)\r\nOUTP_ERR(&outp->base, "link training failed");\r\ndp_link_train_fini(dp);\r\nOUTP_DBG(&outp->base, "training complete");\r\natomic_set(&outp->lt.done, 1);\r\nwake_up(&outp->lt.wait);\r\nnvkm_notify_get(&outp->irq);\r\n}
