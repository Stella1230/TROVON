struct kfd2kgd_calls *amdgpu_amdkfd_gfx_7_get_functions(void)\r\n{\r\nreturn (struct kfd2kgd_calls *)&kfd2kgd;\r\n}\r\nstatic inline struct amdgpu_device *get_amdgpu_device(struct kgd_dev *kgd)\r\n{\r\nreturn (struct amdgpu_device *)kgd;\r\n}\r\nstatic void lock_srbm(struct kgd_dev *kgd, uint32_t mec, uint32_t pipe,\r\nuint32_t queue, uint32_t vmid)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t value = PIPEID(pipe) | MEID(mec) | VMID(vmid) | QUEUEID(queue);\r\nmutex_lock(&adev->srbm_mutex);\r\nWREG32(mmSRBM_GFX_CNTL, value);\r\n}\r\nstatic void unlock_srbm(struct kgd_dev *kgd)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nWREG32(mmSRBM_GFX_CNTL, 0);\r\nmutex_unlock(&adev->srbm_mutex);\r\n}\r\nstatic void acquire_queue(struct kgd_dev *kgd, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nuint32_t mec = (++pipe_id / CIK_PIPE_PER_MEC) + 1;\r\nuint32_t pipe = (pipe_id % CIK_PIPE_PER_MEC);\r\nlock_srbm(kgd, mec, pipe, queue_id, 0);\r\n}\r\nstatic void release_queue(struct kgd_dev *kgd)\r\n{\r\nunlock_srbm(kgd);\r\n}\r\nstatic void kgd_program_sh_mem_settings(struct kgd_dev *kgd, uint32_t vmid,\r\nuint32_t sh_mem_config,\r\nuint32_t sh_mem_ape1_base,\r\nuint32_t sh_mem_ape1_limit,\r\nuint32_t sh_mem_bases)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nlock_srbm(kgd, 0, 0, 0, vmid);\r\nWREG32(mmSH_MEM_CONFIG, sh_mem_config);\r\nWREG32(mmSH_MEM_APE1_BASE, sh_mem_ape1_base);\r\nWREG32(mmSH_MEM_APE1_LIMIT, sh_mem_ape1_limit);\r\nWREG32(mmSH_MEM_BASES, sh_mem_bases);\r\nunlock_srbm(kgd);\r\n}\r\nstatic int kgd_set_pasid_vmid_mapping(struct kgd_dev *kgd, unsigned int pasid,\r\nunsigned int vmid)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t pasid_mapping = (pasid == 0) ? 0 : (uint32_t)pasid |\r\nATC_VMID0_PASID_MAPPING__VALID_MASK;\r\nWREG32(mmATC_VMID0_PASID_MAPPING + vmid, pasid_mapping);\r\nwhile (!(RREG32(mmATC_VMID_PASID_MAPPING_UPDATE_STATUS) & (1U << vmid)))\r\ncpu_relax();\r\nWREG32(mmATC_VMID_PASID_MAPPING_UPDATE_STATUS, 1U << vmid);\r\nWREG32(mmIH_VMID_0_LUT + vmid, pasid_mapping);\r\nreturn 0;\r\n}\r\nstatic int kgd_init_pipeline(struct kgd_dev *kgd, uint32_t pipe_id,\r\nuint32_t hpd_size, uint64_t hpd_gpu_addr)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t mec = (++pipe_id / CIK_PIPE_PER_MEC) + 1;\r\nuint32_t pipe = (pipe_id % CIK_PIPE_PER_MEC);\r\nlock_srbm(kgd, mec, pipe, 0, 0);\r\nWREG32(mmCP_HPD_EOP_BASE_ADDR, lower_32_bits(hpd_gpu_addr >> 8));\r\nWREG32(mmCP_HPD_EOP_BASE_ADDR_HI, upper_32_bits(hpd_gpu_addr >> 8));\r\nWREG32(mmCP_HPD_EOP_VMID, 0);\r\nWREG32(mmCP_HPD_EOP_CONTROL, hpd_size);\r\nunlock_srbm(kgd);\r\nreturn 0;\r\n}\r\nstatic int kgd_init_interrupts(struct kgd_dev *kgd, uint32_t pipe_id)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t mec;\r\nuint32_t pipe;\r\nmec = (pipe_id / CIK_PIPE_PER_MEC) + 1;\r\npipe = (pipe_id % CIK_PIPE_PER_MEC);\r\nlock_srbm(kgd, mec, pipe, 0, 0);\r\nWREG32(mmCPC_INT_CNTL, CP_INT_CNTL_RING0__TIME_STAMP_INT_ENABLE_MASK |\r\nCP_INT_CNTL_RING0__OPCODE_ERROR_INT_ENABLE_MASK);\r\nunlock_srbm(kgd);\r\nreturn 0;\r\n}\r\nstatic inline uint32_t get_sdma_base_addr(struct cik_sdma_rlc_registers *m)\r\n{\r\nuint32_t retval;\r\nretval = m->sdma_engine_id * SDMA1_REGISTER_OFFSET +\r\nm->sdma_queue_id * KFD_CIK_SDMA_QUEUE_OFFSET;\r\npr_debug("kfd: sdma base address: 0x%x\n", retval);\r\nreturn retval;\r\n}\r\nstatic inline struct cik_mqd *get_mqd(void *mqd)\r\n{\r\nreturn (struct cik_mqd *)mqd;\r\n}\r\nstatic inline struct cik_sdma_rlc_registers *get_sdma_mqd(void *mqd)\r\n{\r\nreturn (struct cik_sdma_rlc_registers *)mqd;\r\n}\r\nstatic int kgd_hqd_load(struct kgd_dev *kgd, void *mqd, uint32_t pipe_id,\r\nuint32_t queue_id, uint32_t __user *wptr)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t wptr_shadow, is_wptr_shadow_valid;\r\nstruct cik_mqd *m;\r\nm = get_mqd(mqd);\r\nis_wptr_shadow_valid = !get_user(wptr_shadow, wptr);\r\nacquire_queue(kgd, pipe_id, queue_id);\r\nWREG32(mmCP_MQD_BASE_ADDR, m->cp_mqd_base_addr_lo);\r\nWREG32(mmCP_MQD_BASE_ADDR_HI, m->cp_mqd_base_addr_hi);\r\nWREG32(mmCP_MQD_CONTROL, m->cp_mqd_control);\r\nWREG32(mmCP_HQD_PQ_BASE, m->cp_hqd_pq_base_lo);\r\nWREG32(mmCP_HQD_PQ_BASE_HI, m->cp_hqd_pq_base_hi);\r\nWREG32(mmCP_HQD_PQ_CONTROL, m->cp_hqd_pq_control);\r\nWREG32(mmCP_HQD_IB_CONTROL, m->cp_hqd_ib_control);\r\nWREG32(mmCP_HQD_IB_BASE_ADDR, m->cp_hqd_ib_base_addr_lo);\r\nWREG32(mmCP_HQD_IB_BASE_ADDR_HI, m->cp_hqd_ib_base_addr_hi);\r\nWREG32(mmCP_HQD_IB_RPTR, m->cp_hqd_ib_rptr);\r\nWREG32(mmCP_HQD_PERSISTENT_STATE, m->cp_hqd_persistent_state);\r\nWREG32(mmCP_HQD_SEMA_CMD, m->cp_hqd_sema_cmd);\r\nWREG32(mmCP_HQD_MSG_TYPE, m->cp_hqd_msg_type);\r\nWREG32(mmCP_HQD_ATOMIC0_PREOP_LO, m->cp_hqd_atomic0_preop_lo);\r\nWREG32(mmCP_HQD_ATOMIC0_PREOP_HI, m->cp_hqd_atomic0_preop_hi);\r\nWREG32(mmCP_HQD_ATOMIC1_PREOP_LO, m->cp_hqd_atomic1_preop_lo);\r\nWREG32(mmCP_HQD_ATOMIC1_PREOP_HI, m->cp_hqd_atomic1_preop_hi);\r\nWREG32(mmCP_HQD_PQ_RPTR_REPORT_ADDR, m->cp_hqd_pq_rptr_report_addr_lo);\r\nWREG32(mmCP_HQD_PQ_RPTR_REPORT_ADDR_HI,\r\nm->cp_hqd_pq_rptr_report_addr_hi);\r\nWREG32(mmCP_HQD_PQ_RPTR, m->cp_hqd_pq_rptr);\r\nWREG32(mmCP_HQD_PQ_WPTR_POLL_ADDR, m->cp_hqd_pq_wptr_poll_addr_lo);\r\nWREG32(mmCP_HQD_PQ_WPTR_POLL_ADDR_HI, m->cp_hqd_pq_wptr_poll_addr_hi);\r\nWREG32(mmCP_HQD_PQ_DOORBELL_CONTROL, m->cp_hqd_pq_doorbell_control);\r\nWREG32(mmCP_HQD_VMID, m->cp_hqd_vmid);\r\nWREG32(mmCP_HQD_QUANTUM, m->cp_hqd_quantum);\r\nWREG32(mmCP_HQD_PIPE_PRIORITY, m->cp_hqd_pipe_priority);\r\nWREG32(mmCP_HQD_QUEUE_PRIORITY, m->cp_hqd_queue_priority);\r\nWREG32(mmCP_HQD_IQ_RPTR, m->cp_hqd_iq_rptr);\r\nif (is_wptr_shadow_valid)\r\nWREG32(mmCP_HQD_PQ_WPTR, wptr_shadow);\r\nWREG32(mmCP_HQD_ACTIVE, m->cp_hqd_active);\r\nrelease_queue(kgd);\r\nreturn 0;\r\n}\r\nstatic int kgd_hqd_sdma_load(struct kgd_dev *kgd, void *mqd)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nstruct cik_sdma_rlc_registers *m;\r\nuint32_t sdma_base_addr;\r\nm = get_sdma_mqd(mqd);\r\nsdma_base_addr = get_sdma_base_addr(m);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_VIRTUAL_ADDR,\r\nm->sdma_rlc_virtual_addr);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_BASE,\r\nm->sdma_rlc_rb_base);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_BASE_HI,\r\nm->sdma_rlc_rb_base_hi);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_RPTR_ADDR_LO,\r\nm->sdma_rlc_rb_rptr_addr_lo);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_RPTR_ADDR_HI,\r\nm->sdma_rlc_rb_rptr_addr_hi);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_DOORBELL,\r\nm->sdma_rlc_doorbell);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_CNTL,\r\nm->sdma_rlc_rb_cntl);\r\nreturn 0;\r\n}\r\nstatic bool kgd_hqd_is_occupied(struct kgd_dev *kgd, uint64_t queue_address,\r\nuint32_t pipe_id, uint32_t queue_id)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t act;\r\nbool retval = false;\r\nuint32_t low, high;\r\nacquire_queue(kgd, pipe_id, queue_id);\r\nact = RREG32(mmCP_HQD_ACTIVE);\r\nif (act) {\r\nlow = lower_32_bits(queue_address >> 8);\r\nhigh = upper_32_bits(queue_address >> 8);\r\nif (low == RREG32(mmCP_HQD_PQ_BASE) &&\r\nhigh == RREG32(mmCP_HQD_PQ_BASE_HI))\r\nretval = true;\r\n}\r\nrelease_queue(kgd);\r\nreturn retval;\r\n}\r\nstatic bool kgd_hqd_sdma_is_occupied(struct kgd_dev *kgd, void *mqd)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nstruct cik_sdma_rlc_registers *m;\r\nuint32_t sdma_base_addr;\r\nuint32_t sdma_rlc_rb_cntl;\r\nm = get_sdma_mqd(mqd);\r\nsdma_base_addr = get_sdma_base_addr(m);\r\nsdma_rlc_rb_cntl = RREG32(sdma_base_addr + mmSDMA0_RLC0_RB_CNTL);\r\nif (sdma_rlc_rb_cntl & SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int kgd_hqd_destroy(struct kgd_dev *kgd, uint32_t reset_type,\r\nunsigned int timeout, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t temp;\r\nacquire_queue(kgd, pipe_id, queue_id);\r\nWREG32(mmCP_HQD_PQ_DOORBELL_CONTROL, 0);\r\nWREG32(mmCP_HQD_DEQUEUE_REQUEST, reset_type);\r\nwhile (true) {\r\ntemp = RREG32(mmCP_HQD_ACTIVE);\r\nif (temp & CP_HQD_ACTIVE__ACTIVE_MASK)\r\nbreak;\r\nif (timeout == 0) {\r\npr_err("kfd: cp queue preemption time out (%dms)\n",\r\ntemp);\r\nrelease_queue(kgd);\r\nreturn -ETIME;\r\n}\r\nmsleep(20);\r\ntimeout -= 20;\r\n}\r\nrelease_queue(kgd);\r\nreturn 0;\r\n}\r\nstatic int kgd_hqd_sdma_destroy(struct kgd_dev *kgd, void *mqd,\r\nunsigned int timeout)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nstruct cik_sdma_rlc_registers *m;\r\nuint32_t sdma_base_addr;\r\nuint32_t temp;\r\nm = get_sdma_mqd(mqd);\r\nsdma_base_addr = get_sdma_base_addr(m);\r\ntemp = RREG32(sdma_base_addr + mmSDMA0_RLC0_RB_CNTL);\r\ntemp = temp & ~SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK;\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_CNTL, temp);\r\nwhile (true) {\r\ntemp = RREG32(sdma_base_addr + mmSDMA0_RLC0_CONTEXT_STATUS);\r\nif (temp & SDMA0_STATUS_REG__RB_CMD_IDLE__SHIFT)\r\nbreak;\r\nif (timeout == 0)\r\nreturn -ETIME;\r\nmsleep(20);\r\ntimeout -= 20;\r\n}\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_DOORBELL, 0);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_RPTR, 0);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_WPTR, 0);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_BASE, 0);\r\nreturn 0;\r\n}\r\nstatic int kgd_address_watch_disable(struct kgd_dev *kgd)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nunion TCP_WATCH_CNTL_BITS cntl;\r\nunsigned int i;\r\ncntl.u32All = 0;\r\ncntl.bitfields.valid = 0;\r\ncntl.bitfields.mask = ADDRESS_WATCH_REG_CNTL_DEFAULT_MASK;\r\ncntl.bitfields.atc = 1;\r\nfor (i = 0; i < MAX_WATCH_ADDRESSES; i++)\r\nWREG32(watchRegs[i * ADDRESS_WATCH_REG_MAX +\r\nADDRESS_WATCH_REG_CNTL], cntl.u32All);\r\nreturn 0;\r\n}\r\nstatic int kgd_address_watch_execute(struct kgd_dev *kgd,\r\nunsigned int watch_point_id,\r\nuint32_t cntl_val,\r\nuint32_t addr_hi,\r\nuint32_t addr_lo)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nunion TCP_WATCH_CNTL_BITS cntl;\r\ncntl.u32All = cntl_val;\r\ncntl.bitfields.valid = 0;\r\nWREG32(watchRegs[watch_point_id * ADDRESS_WATCH_REG_MAX +\r\nADDRESS_WATCH_REG_CNTL], cntl.u32All);\r\nWREG32(watchRegs[watch_point_id * ADDRESS_WATCH_REG_MAX +\r\nADDRESS_WATCH_REG_ADDR_HI], addr_hi);\r\nWREG32(watchRegs[watch_point_id * ADDRESS_WATCH_REG_MAX +\r\nADDRESS_WATCH_REG_ADDR_LO], addr_lo);\r\ncntl.bitfields.valid = 1;\r\nWREG32(watchRegs[watch_point_id * ADDRESS_WATCH_REG_MAX +\r\nADDRESS_WATCH_REG_CNTL], cntl.u32All);\r\nreturn 0;\r\n}\r\nstatic int kgd_wave_control_execute(struct kgd_dev *kgd,\r\nuint32_t gfx_index_val,\r\nuint32_t sq_cmd)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t data;\r\nmutex_lock(&adev->grbm_idx_mutex);\r\nWREG32(mmGRBM_GFX_INDEX, gfx_index_val);\r\nWREG32(mmSQ_CMD, sq_cmd);\r\ndata = GRBM_GFX_INDEX__INSTANCE_BROADCAST_WRITES_MASK |\r\nGRBM_GFX_INDEX__SH_BROADCAST_WRITES_MASK |\r\nGRBM_GFX_INDEX__SE_BROADCAST_WRITES_MASK;\r\nWREG32(mmGRBM_GFX_INDEX, data);\r\nmutex_unlock(&adev->grbm_idx_mutex);\r\nreturn 0;\r\n}\r\nstatic uint32_t kgd_address_watch_get_offset(struct kgd_dev *kgd,\r\nunsigned int watch_point_id,\r\nunsigned int reg_offset)\r\n{\r\nreturn watchRegs[watch_point_id * ADDRESS_WATCH_REG_MAX + reg_offset];\r\n}\r\nstatic bool get_atc_vmid_pasid_mapping_valid(struct kgd_dev *kgd,\r\nuint8_t vmid)\r\n{\r\nuint32_t reg;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *) kgd;\r\nreg = RREG32(mmATC_VMID0_PASID_MAPPING + vmid);\r\nreturn reg & ATC_VMID0_PASID_MAPPING__VALID_MASK;\r\n}\r\nstatic uint16_t get_atc_vmid_pasid_mapping_pasid(struct kgd_dev *kgd,\r\nuint8_t vmid)\r\n{\r\nuint32_t reg;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *) kgd;\r\nreg = RREG32(mmATC_VMID0_PASID_MAPPING + vmid);\r\nreturn reg & ATC_VMID0_PASID_MAPPING__VALID_MASK;\r\n}\r\nstatic void write_vmid_invalidate_request(struct kgd_dev *kgd, uint8_t vmid)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *) kgd;\r\nWREG32(mmVM_INVALIDATE_REQUEST, 1 << vmid);\r\n}\r\nstatic uint16_t get_fw_version(struct kgd_dev *kgd, enum kgd_engine_type type)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *) kgd;\r\nconst union amdgpu_firmware_header *hdr;\r\nBUG_ON(kgd == NULL);\r\nswitch (type) {\r\ncase KGD_ENGINE_PFP:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.pfp_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_ME:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.me_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_CE:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.ce_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_MEC1:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.mec_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_MEC2:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.mec2_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_RLC:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.rlc_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_SDMA1:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->sdma.instance[0].fw->data;\r\nbreak;\r\ncase KGD_ENGINE_SDMA2:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->sdma.instance[1].fw->data;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (hdr == NULL)\r\nreturn 0;\r\nreturn hdr->common.ucode_version;\r\n}
