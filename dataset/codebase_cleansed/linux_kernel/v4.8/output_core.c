static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\r\nconst struct in6_addr *dst,\r\nconst struct in6_addr *src)\r\n{\r\nu32 hash, id;\r\nhash = __ipv6_addr_jhash(dst, hashrnd);\r\nhash = __ipv6_addr_jhash(src, hash);\r\nhash ^= net_hash_mix(net);\r\nid = ip_idents_reserve(hash, 1);\r\nif (unlikely(!id))\r\nid = 1 << 31;\r\nreturn id;\r\n}\r\nvoid ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\r\n{\r\nstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\r\nstruct in6_addr buf[2];\r\nstruct in6_addr *addrs;\r\nu32 id;\r\naddrs = skb_header_pointer(skb,\r\nskb_network_offset(skb) +\r\noffsetof(struct ipv6hdr, saddr),\r\nsizeof(buf), buf);\r\nif (!addrs)\r\nreturn;\r\nnet_get_random_once(&ip6_proxy_idents_hashrnd,\r\nsizeof(ip6_proxy_idents_hashrnd));\r\nid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\r\n&addrs[1], &addrs[0]);\r\nskb_shinfo(skb)->ip6_frag_id = htonl(id);\r\n}\r\n__be32 ipv6_select_ident(struct net *net,\r\nconst struct in6_addr *daddr,\r\nconst struct in6_addr *saddr)\r\n{\r\nstatic u32 ip6_idents_hashrnd __read_mostly;\r\nu32 id;\r\nnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\r\nid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\r\nreturn htonl(id);\r\n}\r\nint ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\r\n{\r\nu16 offset = sizeof(struct ipv6hdr);\r\nstruct ipv6_opt_hdr *exthdr =\r\n(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\r\nunsigned int packet_len = skb_tail_pointer(skb) -\r\nskb_network_header(skb);\r\nint found_rhdr = 0;\r\n*nexthdr = &ipv6_hdr(skb)->nexthdr;\r\nwhile (offset + 1 <= packet_len) {\r\nswitch (**nexthdr) {\r\ncase NEXTHDR_HOP:\r\nbreak;\r\ncase NEXTHDR_ROUTING:\r\nfound_rhdr = 1;\r\nbreak;\r\ncase NEXTHDR_DEST:\r\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\r\nif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\r\nbreak;\r\n#endif\r\nif (found_rhdr)\r\nreturn offset;\r\nbreak;\r\ndefault:\r\nreturn offset;\r\n}\r\noffset += ipv6_optlen(exthdr);\r\n*nexthdr = &exthdr->nexthdr;\r\nexthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\r\noffset);\r\n}\r\nreturn offset;\r\n}\r\nint ip6_dst_hoplimit(struct dst_entry *dst)\r\n{\r\nint hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);\r\nif (hoplimit == 0) {\r\nstruct net_device *dev = dst->dev;\r\nstruct inet6_dev *idev;\r\nrcu_read_lock();\r\nidev = __in6_dev_get(dev);\r\nif (idev)\r\nhoplimit = idev->cnf.hop_limit;\r\nelse\r\nhoplimit = dev_net(dev)->ipv6.devconf_all->hop_limit;\r\nrcu_read_unlock();\r\n}\r\nreturn hoplimit;\r\n}\r\nint __ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nint len;\r\nlen = skb->len - sizeof(struct ipv6hdr);\r\nif (len > IPV6_MAXPLEN)\r\nlen = 0;\r\nipv6_hdr(skb)->payload_len = htons(len);\r\nIP6CB(skb)->nhoff = offsetof(struct ipv6hdr, nexthdr);\r\nreturn nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\r\nnet, sk, skb, NULL, skb_dst(skb)->dev,\r\ndst_output);\r\n}\r\nint ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nint err;\r\nerr = __ip6_local_out(net, sk, skb);\r\nif (likely(err == 1))\r\nerr = dst_output(net, sk, skb);\r\nreturn err;\r\n}
