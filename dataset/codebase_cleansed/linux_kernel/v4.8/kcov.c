void notrace __sanitizer_cov_trace_pc(void)\r\n{\r\nstruct task_struct *t;\r\nenum kcov_mode mode;\r\nt = current;\r\nif (!t || in_interrupt())\r\nreturn;\r\nmode = READ_ONCE(t->kcov_mode);\r\nif (mode == KCOV_MODE_TRACE) {\r\nunsigned long *area;\r\nunsigned long pos;\r\nbarrier();\r\narea = t->kcov_area;\r\npos = READ_ONCE(area[0]) + 1;\r\nif (likely(pos < t->kcov_size)) {\r\narea[pos] = _RET_IP_;\r\nWRITE_ONCE(area[0], pos);\r\n}\r\n}\r\n}\r\nstatic void kcov_get(struct kcov *kcov)\r\n{\r\natomic_inc(&kcov->refcount);\r\n}\r\nstatic void kcov_put(struct kcov *kcov)\r\n{\r\nif (atomic_dec_and_test(&kcov->refcount)) {\r\nvfree(kcov->area);\r\nkfree(kcov);\r\n}\r\n}\r\nvoid kcov_task_init(struct task_struct *t)\r\n{\r\nt->kcov_mode = KCOV_MODE_DISABLED;\r\nt->kcov_size = 0;\r\nt->kcov_area = NULL;\r\nt->kcov = NULL;\r\n}\r\nvoid kcov_task_exit(struct task_struct *t)\r\n{\r\nstruct kcov *kcov;\r\nkcov = t->kcov;\r\nif (kcov == NULL)\r\nreturn;\r\nspin_lock(&kcov->lock);\r\nif (WARN_ON(kcov->t != t)) {\r\nspin_unlock(&kcov->lock);\r\nreturn;\r\n}\r\nkcov_task_init(t);\r\nkcov->t = NULL;\r\nspin_unlock(&kcov->lock);\r\nkcov_put(kcov);\r\n}\r\nstatic int kcov_mmap(struct file *filep, struct vm_area_struct *vma)\r\n{\r\nint res = 0;\r\nvoid *area;\r\nstruct kcov *kcov = vma->vm_file->private_data;\r\nunsigned long size, off;\r\nstruct page *page;\r\narea = vmalloc_user(vma->vm_end - vma->vm_start);\r\nif (!area)\r\nreturn -ENOMEM;\r\nspin_lock(&kcov->lock);\r\nsize = kcov->size * sizeof(unsigned long);\r\nif (kcov->mode == KCOV_MODE_DISABLED || vma->vm_pgoff != 0 ||\r\nvma->vm_end - vma->vm_start != size) {\r\nres = -EINVAL;\r\ngoto exit;\r\n}\r\nif (!kcov->area) {\r\nkcov->area = area;\r\nvma->vm_flags |= VM_DONTEXPAND;\r\nspin_unlock(&kcov->lock);\r\nfor (off = 0; off < size; off += PAGE_SIZE) {\r\npage = vmalloc_to_page(kcov->area + off);\r\nif (vm_insert_page(vma, vma->vm_start + off, page))\r\nWARN_ONCE(1, "vm_insert_page() failed");\r\n}\r\nreturn 0;\r\n}\r\nexit:\r\nspin_unlock(&kcov->lock);\r\nvfree(area);\r\nreturn res;\r\n}\r\nstatic int kcov_open(struct inode *inode, struct file *filep)\r\n{\r\nstruct kcov *kcov;\r\nkcov = kzalloc(sizeof(*kcov), GFP_KERNEL);\r\nif (!kcov)\r\nreturn -ENOMEM;\r\natomic_set(&kcov->refcount, 1);\r\nspin_lock_init(&kcov->lock);\r\nfilep->private_data = kcov;\r\nreturn nonseekable_open(inode, filep);\r\n}\r\nstatic int kcov_close(struct inode *inode, struct file *filep)\r\n{\r\nkcov_put(filep->private_data);\r\nreturn 0;\r\n}\r\nstatic int kcov_ioctl_locked(struct kcov *kcov, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct task_struct *t;\r\nunsigned long size, unused;\r\nswitch (cmd) {\r\ncase KCOV_INIT_TRACE:\r\nif (kcov->mode != KCOV_MODE_DISABLED)\r\nreturn -EBUSY;\r\nsize = arg;\r\nif (size < 2 || size > INT_MAX / sizeof(unsigned long))\r\nreturn -EINVAL;\r\nkcov->size = size;\r\nkcov->mode = KCOV_MODE_TRACE;\r\nreturn 0;\r\ncase KCOV_ENABLE:\r\nunused = arg;\r\nif (unused != 0 || kcov->mode == KCOV_MODE_DISABLED ||\r\nkcov->area == NULL)\r\nreturn -EINVAL;\r\nif (kcov->t != NULL)\r\nreturn -EBUSY;\r\nt = current;\r\nt->kcov_size = kcov->size;\r\nt->kcov_area = kcov->area;\r\nbarrier();\r\nWRITE_ONCE(t->kcov_mode, kcov->mode);\r\nt->kcov = kcov;\r\nkcov->t = t;\r\nkcov_get(kcov);\r\nreturn 0;\r\ncase KCOV_DISABLE:\r\nunused = arg;\r\nif (unused != 0 || current->kcov != kcov)\r\nreturn -EINVAL;\r\nt = current;\r\nif (WARN_ON(kcov->t != t))\r\nreturn -EINVAL;\r\nkcov_task_init(t);\r\nkcov->t = NULL;\r\nkcov_put(kcov);\r\nreturn 0;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic long kcov_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct kcov *kcov;\r\nint res;\r\nkcov = filep->private_data;\r\nspin_lock(&kcov->lock);\r\nres = kcov_ioctl_locked(kcov, cmd, arg);\r\nspin_unlock(&kcov->lock);\r\nreturn res;\r\n}\r\nstatic int __init kcov_init(void)\r\n{\r\nif (!debugfs_create_file_unsafe("kcov", 0600, NULL, NULL, &kcov_fops)) {\r\npr_err("failed to create kcov in debugfs\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}
