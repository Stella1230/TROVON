static struct virt_dma_desc *to_virt_desc(struct dma_async_tx_descriptor *tx)\r\n{\r\nreturn container_of(tx, struct virt_dma_desc, tx);\r\n}\r\ndma_cookie_t vchan_tx_submit(struct dma_async_tx_descriptor *tx)\r\n{\r\nstruct virt_dma_chan *vc = to_virt_chan(tx->chan);\r\nstruct virt_dma_desc *vd = to_virt_desc(tx);\r\nunsigned long flags;\r\ndma_cookie_t cookie;\r\nspin_lock_irqsave(&vc->lock, flags);\r\ncookie = dma_cookie_assign(tx);\r\nlist_move_tail(&vd->node, &vc->desc_submitted);\r\nspin_unlock_irqrestore(&vc->lock, flags);\r\ndev_dbg(vc->chan.device->dev, "vchan %p: txd %p[%x]: submitted\n",\r\nvc, vd, cookie);\r\nreturn cookie;\r\n}\r\nint vchan_tx_desc_free(struct dma_async_tx_descriptor *tx)\r\n{\r\nstruct virt_dma_chan *vc = to_virt_chan(tx->chan);\r\nstruct virt_dma_desc *vd = to_virt_desc(tx);\r\nunsigned long flags;\r\nspin_lock_irqsave(&vc->lock, flags);\r\nlist_del(&vd->node);\r\nspin_unlock_irqrestore(&vc->lock, flags);\r\ndev_dbg(vc->chan.device->dev, "vchan %p: txd %p[%x]: freeing\n",\r\nvc, vd, vd->tx.cookie);\r\nvc->desc_free(vd);\r\nreturn 0;\r\n}\r\nstruct virt_dma_desc *vchan_find_desc(struct virt_dma_chan *vc,\r\ndma_cookie_t cookie)\r\n{\r\nstruct virt_dma_desc *vd;\r\nlist_for_each_entry(vd, &vc->desc_issued, node)\r\nif (vd->tx.cookie == cookie)\r\nreturn vd;\r\nreturn NULL;\r\n}\r\nstatic void vchan_complete(unsigned long arg)\r\n{\r\nstruct virt_dma_chan *vc = (struct virt_dma_chan *)arg;\r\nstruct virt_dma_desc *vd;\r\ndma_async_tx_callback cb = NULL;\r\nvoid *cb_data = NULL;\r\nLIST_HEAD(head);\r\nspin_lock_irq(&vc->lock);\r\nlist_splice_tail_init(&vc->desc_completed, &head);\r\nvd = vc->cyclic;\r\nif (vd) {\r\nvc->cyclic = NULL;\r\ncb = vd->tx.callback;\r\ncb_data = vd->tx.callback_param;\r\n}\r\nspin_unlock_irq(&vc->lock);\r\nif (cb)\r\ncb(cb_data);\r\nwhile (!list_empty(&head)) {\r\nvd = list_first_entry(&head, struct virt_dma_desc, node);\r\ncb = vd->tx.callback;\r\ncb_data = vd->tx.callback_param;\r\nlist_del(&vd->node);\r\nif (dmaengine_desc_test_reuse(&vd->tx))\r\nlist_add(&vd->node, &vc->desc_allocated);\r\nelse\r\nvc->desc_free(vd);\r\nif (cb)\r\ncb(cb_data);\r\n}\r\n}\r\nvoid vchan_dma_desc_free_list(struct virt_dma_chan *vc, struct list_head *head)\r\n{\r\nwhile (!list_empty(head)) {\r\nstruct virt_dma_desc *vd = list_first_entry(head,\r\nstruct virt_dma_desc, node);\r\nif (dmaengine_desc_test_reuse(&vd->tx)) {\r\nlist_move_tail(&vd->node, &vc->desc_allocated);\r\n} else {\r\ndev_dbg(vc->chan.device->dev, "txd %p: freeing\n", vd);\r\nlist_del(&vd->node);\r\nvc->desc_free(vd);\r\n}\r\n}\r\n}\r\nvoid vchan_init(struct virt_dma_chan *vc, struct dma_device *dmadev)\r\n{\r\ndma_cookie_init(&vc->chan);\r\nspin_lock_init(&vc->lock);\r\nINIT_LIST_HEAD(&vc->desc_allocated);\r\nINIT_LIST_HEAD(&vc->desc_submitted);\r\nINIT_LIST_HEAD(&vc->desc_issued);\r\nINIT_LIST_HEAD(&vc->desc_completed);\r\ntasklet_init(&vc->task, vchan_complete, (unsigned long)vc);\r\nvc->chan.device = dmadev;\r\nlist_add_tail(&vc->chan.device_node, &dmadev->channels);\r\n}
