void sun4i_backend_apply_color_correction(struct sun4i_backend *backend)\r\n{\r\nint i;\r\nDRM_DEBUG_DRIVER("Applying RGB to YUV color correction\n");\r\nregmap_write(backend->regs, SUN4I_BACKEND_OCCTL_REG,\r\nSUN4I_BACKEND_OCCTL_ENABLE);\r\nfor (i = 0; i < 12; i++)\r\nregmap_write(backend->regs, SUN4I_BACKEND_OCRCOEF_REG(i),\r\nsunxi_rgb2yuv_coef[i]);\r\n}\r\nvoid sun4i_backend_disable_color_correction(struct sun4i_backend *backend)\r\n{\r\nDRM_DEBUG_DRIVER("Disabling color correction\n");\r\nregmap_update_bits(backend->regs, SUN4I_BACKEND_OCCTL_REG,\r\nSUN4I_BACKEND_OCCTL_ENABLE, 0);\r\n}\r\nvoid sun4i_backend_commit(struct sun4i_backend *backend)\r\n{\r\nDRM_DEBUG_DRIVER("Committing changes\n");\r\nregmap_write(backend->regs, SUN4I_BACKEND_REGBUFFCTL_REG,\r\nSUN4I_BACKEND_REGBUFFCTL_AUTOLOAD_DIS |\r\nSUN4I_BACKEND_REGBUFFCTL_LOADCTL);\r\n}\r\nvoid sun4i_backend_layer_enable(struct sun4i_backend *backend,\r\nint layer, bool enable)\r\n{\r\nu32 val;\r\nDRM_DEBUG_DRIVER("Enabling layer %d\n", layer);\r\nif (enable)\r\nval = SUN4I_BACKEND_MODCTL_LAY_EN(layer);\r\nelse\r\nval = 0;\r\nregmap_update_bits(backend->regs, SUN4I_BACKEND_MODCTL_REG,\r\nSUN4I_BACKEND_MODCTL_LAY_EN(layer), val);\r\n}\r\nstatic int sun4i_backend_drm_format_to_layer(u32 format, u32 *mode)\r\n{\r\nswitch (format) {\r\ncase DRM_FORMAT_ARGB8888:\r\n*mode = SUN4I_BACKEND_LAY_FBFMT_ARGB8888;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\n*mode = SUN4I_BACKEND_LAY_FBFMT_XRGB8888;\r\nbreak;\r\ncase DRM_FORMAT_RGB888:\r\n*mode = SUN4I_BACKEND_LAY_FBFMT_RGB888;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint sun4i_backend_update_layer_coord(struct sun4i_backend *backend,\r\nint layer, struct drm_plane *plane)\r\n{\r\nstruct drm_plane_state *state = plane->state;\r\nstruct drm_framebuffer *fb = state->fb;\r\nDRM_DEBUG_DRIVER("Updating layer %d\n", layer);\r\nif (plane->type == DRM_PLANE_TYPE_PRIMARY) {\r\nDRM_DEBUG_DRIVER("Primary layer, updating global size W: %u H: %u\n",\r\nstate->crtc_w, state->crtc_h);\r\nregmap_write(backend->regs, SUN4I_BACKEND_DISSIZE_REG,\r\nSUN4I_BACKEND_DISSIZE(state->crtc_w,\r\nstate->crtc_h));\r\n}\r\nDRM_DEBUG_DRIVER("Layer line width: %d bits\n", fb->pitches[0] * 8);\r\nregmap_write(backend->regs, SUN4I_BACKEND_LAYLINEWIDTH_REG(layer),\r\nfb->pitches[0] * 8);\r\nDRM_DEBUG_DRIVER("Layer size W: %u H: %u\n",\r\nstate->crtc_w, state->crtc_h);\r\nregmap_write(backend->regs, SUN4I_BACKEND_LAYSIZE_REG(layer),\r\nSUN4I_BACKEND_LAYSIZE(state->crtc_w,\r\nstate->crtc_h));\r\nDRM_DEBUG_DRIVER("Layer coordinates X: %d Y: %d\n",\r\nstate->crtc_x, state->crtc_y);\r\nregmap_write(backend->regs, SUN4I_BACKEND_LAYCOOR_REG(layer),\r\nSUN4I_BACKEND_LAYCOOR(state->crtc_x,\r\nstate->crtc_y));\r\nreturn 0;\r\n}\r\nint sun4i_backend_update_layer_formats(struct sun4i_backend *backend,\r\nint layer, struct drm_plane *plane)\r\n{\r\nstruct drm_plane_state *state = plane->state;\r\nstruct drm_framebuffer *fb = state->fb;\r\nbool interlaced = false;\r\nu32 val;\r\nint ret;\r\nif (plane->state->crtc)\r\ninterlaced = plane->state->crtc->state->adjusted_mode.flags\r\n& DRM_MODE_FLAG_INTERLACE;\r\nregmap_update_bits(backend->regs, SUN4I_BACKEND_MODCTL_REG,\r\nSUN4I_BACKEND_MODCTL_ITLMOD_EN,\r\ninterlaced ? SUN4I_BACKEND_MODCTL_ITLMOD_EN : 0);\r\nDRM_DEBUG_DRIVER("Switching display backend interlaced mode %s\n",\r\ninterlaced ? "on" : "off");\r\nret = sun4i_backend_drm_format_to_layer(fb->pixel_format, &val);\r\nif (ret) {\r\nDRM_DEBUG_DRIVER("Invalid format\n");\r\nreturn val;\r\n}\r\nregmap_update_bits(backend->regs, SUN4I_BACKEND_ATTCTL_REG1(layer),\r\nSUN4I_BACKEND_ATTCTL_REG1_LAY_FBFMT, val);\r\nreturn 0;\r\n}\r\nint sun4i_backend_update_layer_buffer(struct sun4i_backend *backend,\r\nint layer, struct drm_plane *plane)\r\n{\r\nstruct drm_plane_state *state = plane->state;\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct drm_gem_cma_object *gem;\r\nu32 lo_paddr, hi_paddr;\r\ndma_addr_t paddr;\r\nint bpp;\r\ngem = drm_fb_cma_get_gem_obj(fb, 0);\r\nDRM_DEBUG_DRIVER("Using GEM @ %pad\n", &gem->paddr);\r\nbpp = drm_format_plane_cpp(fb->pixel_format, 0);\r\npaddr = gem->paddr + fb->offsets[0];\r\npaddr += (state->src_x >> 16) * bpp;\r\npaddr += (state->src_y >> 16) * fb->pitches[0];\r\nDRM_DEBUG_DRIVER("Setting buffer address to %pad\n", &paddr);\r\nlo_paddr = paddr << 3;\r\nDRM_DEBUG_DRIVER("Setting address lower bits to 0x%x\n", lo_paddr);\r\nregmap_write(backend->regs, SUN4I_BACKEND_LAYFB_L32ADD_REG(layer),\r\nlo_paddr);\r\nhi_paddr = paddr >> 29;\r\nDRM_DEBUG_DRIVER("Setting address high bits to 0x%x\n", hi_paddr);\r\nregmap_update_bits(backend->regs, SUN4I_BACKEND_LAYFB_H4ADD_REG,\r\nSUN4I_BACKEND_LAYFB_H4ADD_MSK(layer),\r\nSUN4I_BACKEND_LAYFB_H4ADD(layer, hi_paddr));\r\nreturn 0;\r\n}\r\nstatic int sun4i_backend_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = data;\r\nstruct sun4i_drv *drv = drm->dev_private;\r\nstruct sun4i_backend *backend;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nint i, ret;\r\nbackend = devm_kzalloc(dev, sizeof(*backend), GFP_KERNEL);\r\nif (!backend)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, backend);\r\ndrv->backend = backend;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(regs)) {\r\ndev_err(dev, "Couldn't map the backend registers\n");\r\nreturn PTR_ERR(regs);\r\n}\r\nbackend->regs = devm_regmap_init_mmio(dev, regs,\r\n&sun4i_backend_regmap_config);\r\nif (IS_ERR(backend->regs)) {\r\ndev_err(dev, "Couldn't create the backend0 regmap\n");\r\nreturn PTR_ERR(backend->regs);\r\n}\r\nbackend->reset = devm_reset_control_get(dev, NULL);\r\nif (IS_ERR(backend->reset)) {\r\ndev_err(dev, "Couldn't get our reset line\n");\r\nreturn PTR_ERR(backend->reset);\r\n}\r\nret = reset_control_deassert(backend->reset);\r\nif (ret) {\r\ndev_err(dev, "Couldn't deassert our reset line\n");\r\nreturn ret;\r\n}\r\nbackend->bus_clk = devm_clk_get(dev, "ahb");\r\nif (IS_ERR(backend->bus_clk)) {\r\ndev_err(dev, "Couldn't get the backend bus clock\n");\r\nret = PTR_ERR(backend->bus_clk);\r\ngoto err_assert_reset;\r\n}\r\nclk_prepare_enable(backend->bus_clk);\r\nbackend->mod_clk = devm_clk_get(dev, "mod");\r\nif (IS_ERR(backend->mod_clk)) {\r\ndev_err(dev, "Couldn't get the backend module clock\n");\r\nret = PTR_ERR(backend->mod_clk);\r\ngoto err_disable_bus_clk;\r\n}\r\nclk_prepare_enable(backend->mod_clk);\r\nbackend->ram_clk = devm_clk_get(dev, "ram");\r\nif (IS_ERR(backend->ram_clk)) {\r\ndev_err(dev, "Couldn't get the backend RAM clock\n");\r\nret = PTR_ERR(backend->ram_clk);\r\ngoto err_disable_mod_clk;\r\n}\r\nclk_prepare_enable(backend->ram_clk);\r\nfor (i = 0x800; i < 0x1000; i += 4)\r\nregmap_write(backend->regs, i, 0);\r\nregmap_write(backend->regs, SUN4I_BACKEND_REGBUFFCTL_REG,\r\nSUN4I_BACKEND_REGBUFFCTL_AUTOLOAD_DIS);\r\nregmap_write(backend->regs, SUN4I_BACKEND_MODCTL_REG,\r\nSUN4I_BACKEND_MODCTL_DEBE_EN |\r\nSUN4I_BACKEND_MODCTL_START_CTL);\r\nreturn 0;\r\nerr_disable_mod_clk:\r\nclk_disable_unprepare(backend->mod_clk);\r\nerr_disable_bus_clk:\r\nclk_disable_unprepare(backend->bus_clk);\r\nerr_assert_reset:\r\nreset_control_assert(backend->reset);\r\nreturn ret;\r\n}\r\nstatic void sun4i_backend_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct sun4i_backend *backend = dev_get_drvdata(dev);\r\nclk_disable_unprepare(backend->ram_clk);\r\nclk_disable_unprepare(backend->mod_clk);\r\nclk_disable_unprepare(backend->bus_clk);\r\nreset_control_assert(backend->reset);\r\n}\r\nstatic int sun4i_backend_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &sun4i_backend_ops);\r\n}\r\nstatic int sun4i_backend_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &sun4i_backend_ops);\r\nreturn 0;\r\n}
