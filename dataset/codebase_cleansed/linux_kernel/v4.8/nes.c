static int nes_inetaddr_event(struct notifier_block *notifier,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct in_ifaddr *ifa = ptr;\r\nstruct net_device *event_netdev = ifa->ifa_dev->dev;\r\nstruct nes_device *nesdev;\r\nstruct net_device *netdev;\r\nstruct net_device *upper_dev;\r\nstruct nes_vnic *nesvnic;\r\nunsigned int is_bonded;\r\nnes_debug(NES_DBG_NETDEV, "nes_inetaddr_event: ip address %pI4, netmask %pI4.\n",\r\n&ifa->ifa_address, &ifa->ifa_mask);\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nnes_debug(NES_DBG_NETDEV, "Nesdev list entry = 0x%p. (%s)\n",\r\nnesdev, nesdev->netdev[0]->name);\r\nnetdev = nesdev->netdev[0];\r\nnesvnic = netdev_priv(netdev);\r\nupper_dev = netdev_master_upper_dev_get(netdev);\r\nis_bonded = netif_is_bond_slave(netdev) &&\r\n(upper_dev == event_netdev);\r\nif ((netdev == event_netdev) || is_bonded) {\r\nif (nesvnic->rdma_enabled == 0) {\r\nnes_debug(NES_DBG_NETDEV, "Returning without processing event for %s since"\r\n" RDMA is not enabled.\n",\r\nnetdev->name);\r\nreturn NOTIFY_OK;\r\n}\r\nswitch (event) {\r\ncase NETDEV_DOWN:\r\nnes_debug(NES_DBG_NETDEV, "event:DOWN\n");\r\nnes_write_indexed(nesdev,\r\nNES_IDX_DST_IP_ADDR+(0x10*PCI_FUNC(nesdev->pcidev->devfn)), 0);\r\nnes_manage_arp_cache(netdev, netdev->dev_addr,\r\nntohl(nesvnic->local_ipaddr), NES_ARP_DELETE);\r\nnesvnic->local_ipaddr = 0;\r\nif (is_bonded)\r\ncontinue;\r\nelse\r\nreturn NOTIFY_OK;\r\nbreak;\r\ncase NETDEV_UP:\r\nnes_debug(NES_DBG_NETDEV, "event:UP\n");\r\nif (nesvnic->local_ipaddr != 0) {\r\nnes_debug(NES_DBG_NETDEV, "Interface already has local_ipaddr\n");\r\nreturn NOTIFY_OK;\r\n}\r\ncase NETDEV_CHANGEADDR:\r\nif (upper_dev)\r\nnesvnic->local_ipaddr =\r\n((struct in_device *)upper_dev->ip_ptr)->ifa_list->ifa_address;\r\nelse\r\nnesvnic->local_ipaddr = ifa->ifa_address;\r\nnes_write_indexed(nesdev,\r\nNES_IDX_DST_IP_ADDR+(0x10*PCI_FUNC(nesdev->pcidev->devfn)),\r\nntohl(nesvnic->local_ipaddr));\r\nnes_manage_arp_cache(netdev, netdev->dev_addr,\r\nntohl(nesvnic->local_ipaddr), NES_ARP_ADD);\r\nif (is_bonded)\r\ncontinue;\r\nelse\r\nreturn NOTIFY_OK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int nes_net_event(struct notifier_block *notifier,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct neighbour *neigh = ptr;\r\nstruct nes_device *nesdev;\r\nstruct net_device *netdev;\r\nstruct nes_vnic *nesvnic;\r\nswitch (event) {\r\ncase NETEVENT_NEIGH_UPDATE:\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nnetdev = nesdev->netdev[0];\r\nnesvnic = netdev_priv(netdev);\r\nif (netdev == neigh->dev) {\r\nif (nesvnic->rdma_enabled == 0) {\r\nnes_debug(NES_DBG_NETDEV, "Skipping device %s since no RDMA\n",\r\nnetdev->name);\r\n} else {\r\nif (neigh->nud_state & NUD_VALID) {\r\nnes_manage_arp_cache(neigh->dev, neigh->ha,\r\nntohl(*(__be32 *)neigh->primary_key), NES_ARP_ADD);\r\n} else {\r\nnes_manage_arp_cache(neigh->dev, neigh->ha,\r\nntohl(*(__be32 *)neigh->primary_key), NES_ARP_DELETE);\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nnes_debug(NES_DBG_NETDEV, "NETEVENT_ %lu undefined\n", event);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid nes_add_ref(struct ib_qp *ibqp)\r\n{\r\nstruct nes_qp *nesqp;\r\nnesqp = to_nesqp(ibqp);\r\nnes_debug(NES_DBG_QP, "Bumping refcount for QP%u. Pre-inc value = %u\n",\r\nibqp->qp_num, atomic_read(&nesqp->refcount));\r\natomic_inc(&nesqp->refcount);\r\n}\r\nstatic void nes_cqp_rem_ref_callback(struct nes_device *nesdev, struct nes_cqp_request *cqp_request)\r\n{\r\nunsigned long flags;\r\nstruct nes_qp *nesqp = cqp_request->cqp_callback_pointer;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\natomic_inc(&qps_destroyed);\r\nif (nesqp->pbl_vbase) {\r\npci_free_consistent(nesdev->pcidev, nesqp->qp_mem_size,\r\nnesqp->hwqp.q2_vbase, nesqp->hwqp.q2_pbase);\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nnesadapter->free_256pbl++;\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\npci_free_consistent(nesdev->pcidev, 256, nesqp->pbl_vbase, nesqp->pbl_pbase);\r\nnesqp->pbl_vbase = NULL;\r\n} else {\r\npci_free_consistent(nesdev->pcidev, nesqp->qp_mem_size,\r\nnesqp->hwqp.sq_vbase, nesqp->hwqp.sq_pbase);\r\n}\r\nnes_free_resource(nesadapter, nesadapter->allocated_qps, nesqp->hwqp.qp_id);\r\nnesadapter->qp_table[nesqp->hwqp.qp_id-NES_FIRST_QPN] = NULL;\r\nkfree(nesqp->allocated_buffer);\r\n}\r\nvoid nes_rem_ref(struct ib_qp *ibqp)\r\n{\r\nu64 u64temp;\r\nstruct nes_qp *nesqp;\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibqp->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_cqp_request *cqp_request;\r\nu32 opcode;\r\nnesqp = to_nesqp(ibqp);\r\nif (atomic_read(&nesqp->refcount) == 0) {\r\nprintk(KERN_INFO PFX "%s: Reference count already 0 for QP%d, last aeq = 0x%04X.\n",\r\n__func__, ibqp->qp_num, nesqp->last_aeq);\r\nBUG();\r\n}\r\nif (atomic_dec_and_test(&nesqp->refcount)) {\r\nif (nesqp->pau_mode)\r\nnes_destroy_pau_qp(nesdev, nesqp);\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_QP, "Failed to get a cqp_request.\n");\r\nreturn;\r\n}\r\ncqp_request->waiting = 0;\r\ncqp_request->callback = 1;\r\ncqp_request->cqp_callback = nes_cqp_rem_ref_callback;\r\ncqp_request->cqp_callback_pointer = nesqp;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nopcode = NES_CQP_DESTROY_QP | NES_CQP_QP_TYPE_IWARP;\r\nif (nesqp->hte_added) {\r\nopcode |= NES_CQP_QP_DEL_HTE;\r\nnesqp->hte_added = 0;\r\n}\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX, opcode);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX, nesqp->hwqp.qp_id);\r\nu64temp = (u64)nesqp->nesqp_context_pbase;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_QP_WQE_CONTEXT_LOW_IDX, u64temp);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\n}\r\n}\r\nstruct ib_qp *nes_get_qp(struct ib_device *device, int qpn)\r\n{\r\nstruct nes_vnic *nesvnic = to_nesvnic(device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nif ((qpn < NES_FIRST_QPN) || (qpn >= (NES_FIRST_QPN + nesadapter->max_qp)))\r\nreturn NULL;\r\nreturn &nesadapter->qp_table[qpn - NES_FIRST_QPN]->ibqp;\r\n}\r\nstatic void nes_print_macaddr(struct net_device *netdev)\r\n{\r\nnes_debug(NES_DBG_INIT, "%s: %pM, IRQ %u\n",\r\nnetdev->name, netdev->dev_addr, netdev->irq);\r\n}\r\nstatic irqreturn_t nes_interrupt(int irq, void *dev_id)\r\n{\r\nstruct nes_device *nesdev = (struct nes_device *)dev_id;\r\nint handled = 0;\r\nu32 int_mask;\r\nu32 int_req;\r\nu32 int_stat;\r\nu32 intf_int_stat;\r\nu32 timer_stat;\r\nif (nesdev->msi_enabled) {\r\nhandled = 1;\r\n} else {\r\nif (unlikely(nesdev->nesadapter->hw_rev == NE020_REV)) {\r\nint_mask = nes_read32(nesdev->regs + NES_INT_MASK);\r\nif (int_mask & 0x80000000) {\r\nint_stat = nes_read32(nesdev->regs + NES_INT_STAT);\r\nint_req = nesdev->int_req;\r\nif (int_stat&int_req) {\r\nif ((int_stat&int_req) & (~(NES_INT_TIMER|NES_INT_INTF))) {\r\nhandled = 1;\r\n} else {\r\nif (((int_stat & int_req) & NES_INT_TIMER) == NES_INT_TIMER) {\r\ntimer_stat = nes_read32(nesdev->regs + NES_TIMER_STAT);\r\nif ((timer_stat & nesdev->timer_int_req) != 0) {\r\nhandled = 1;\r\n}\r\n}\r\nif ((((int_stat & int_req) & NES_INT_INTF) == NES_INT_INTF) &&\r\n(handled == 0)) {\r\nintf_int_stat = nes_read32(nesdev->regs+NES_INTF_INT_STAT);\r\nif ((intf_int_stat & nesdev->intf_int_req) != 0) {\r\nhandled = 1;\r\n}\r\n}\r\n}\r\nif (handled) {\r\nnes_write32(nesdev->regs+NES_INT_MASK, int_mask & (~0x80000000));\r\nint_mask = nes_read32(nesdev->regs+NES_INT_MASK);\r\nnesdev->int_stat = int_stat;\r\nnesdev->napi_isr_ran = 1;\r\n}\r\n}\r\n}\r\n} else {\r\nhandled = nes_read32(nesdev->regs+NES_INT_PENDING);\r\n}\r\n}\r\nif (handled) {\r\nif (nes_napi_isr(nesdev) == 0) {\r\ntasklet_schedule(&nesdev->dpc_tasklet);\r\n}\r\nreturn IRQ_HANDLED;\r\n} else {\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nstatic int nes_probe(struct pci_dev *pcidev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *netdev = NULL;\r\nstruct nes_device *nesdev = NULL;\r\nint ret = 0;\r\nvoid __iomem *mmio_regs = NULL;\r\nu8 hw_rev;\r\nassert(pcidev != NULL);\r\nassert(ent != NULL);\r\nprintk(KERN_INFO PFX "NetEffect RNIC driver v%s loading. (%s)\n",\r\nDRV_VERSION, pci_name(pcidev));\r\nret = pci_enable_device(pcidev);\r\nif (ret) {\r\nprintk(KERN_ERR PFX "Unable to enable PCI device. (%s)\n", pci_name(pcidev));\r\ngoto bail0;\r\n}\r\nnes_debug(NES_DBG_INIT, "BAR0 (@0x%08lX) size = 0x%lX bytes\n",\r\n(long unsigned int)pci_resource_start(pcidev, BAR_0),\r\n(long unsigned int)pci_resource_len(pcidev, BAR_0));\r\nnes_debug(NES_DBG_INIT, "BAR1 (@0x%08lX) size = 0x%lX bytes\n",\r\n(long unsigned int)pci_resource_start(pcidev, BAR_1),\r\n(long unsigned int)pci_resource_len(pcidev, BAR_1));\r\nif (!(pci_resource_flags(pcidev, BAR_0) & IORESOURCE_MEM) ||\r\n!(pci_resource_flags(pcidev, BAR_1) & IORESOURCE_MEM)) {\r\nprintk(KERN_ERR PFX "PCI regions not an MMIO resource\n");\r\nret = -ENODEV;\r\ngoto bail1;\r\n}\r\nret = pci_request_regions(pcidev, DRV_NAME);\r\nif (ret) {\r\nprintk(KERN_ERR PFX "Unable to request regions. (%s)\n", pci_name(pcidev));\r\ngoto bail1;\r\n}\r\nif ((sizeof(dma_addr_t) > 4)) {\r\nret = pci_set_dma_mask(pcidev, DMA_BIT_MASK(64));\r\nif (ret < 0) {\r\nprintk(KERN_ERR PFX "64b DMA mask configuration failed\n");\r\ngoto bail2;\r\n}\r\nret = pci_set_consistent_dma_mask(pcidev, DMA_BIT_MASK(64));\r\nif (ret) {\r\nprintk(KERN_ERR PFX "64b DMA consistent mask configuration failed\n");\r\ngoto bail2;\r\n}\r\n} else {\r\nret = pci_set_dma_mask(pcidev, DMA_BIT_MASK(32));\r\nif (ret < 0) {\r\nprintk(KERN_ERR PFX "32b DMA mask configuration failed\n");\r\ngoto bail2;\r\n}\r\nret = pci_set_consistent_dma_mask(pcidev, DMA_BIT_MASK(32));\r\nif (ret) {\r\nprintk(KERN_ERR PFX "32b DMA consistent mask configuration failed\n");\r\ngoto bail2;\r\n}\r\n}\r\npci_set_master(pcidev);\r\nnesdev = kzalloc(sizeof(struct nes_device), GFP_KERNEL);\r\nif (!nesdev) {\r\nprintk(KERN_ERR PFX "%s: Unable to alloc hardware struct\n", pci_name(pcidev));\r\nret = -ENOMEM;\r\ngoto bail2;\r\n}\r\nnes_debug(NES_DBG_INIT, "Allocated nes device at %p\n", nesdev);\r\nnesdev->pcidev = pcidev;\r\npci_set_drvdata(pcidev, nesdev);\r\npci_read_config_byte(pcidev, 0x0008, &hw_rev);\r\nnes_debug(NES_DBG_INIT, "hw_rev=%u\n", hw_rev);\r\nspin_lock_init(&nesdev->indexed_regs_lock);\r\nmmio_regs = ioremap_nocache(pci_resource_start(pcidev, BAR_0),\r\npci_resource_len(pcidev, BAR_0));\r\nif (mmio_regs == NULL) {\r\nprintk(KERN_ERR PFX "Unable to remap BAR0\n");\r\nret = -EIO;\r\ngoto bail3;\r\n}\r\nnesdev->regs = mmio_regs;\r\nnesdev->index_reg = 0x50 + (PCI_FUNC(pcidev->devfn)*8) + mmio_regs;\r\nnes_write32(nesdev->regs+NES_INT_MASK, 0x7fffffff);\r\nif (nes_drv_opt & NES_DRV_OPT_ENABLE_MSI) {\r\nif (!pci_enable_msi(nesdev->pcidev)) {\r\nnesdev->msi_enabled = 1;\r\nnes_debug(NES_DBG_INIT, "MSI is enabled for device %s\n",\r\npci_name(pcidev));\r\n} else {\r\nnes_debug(NES_DBG_INIT, "MSI is disabled by linux for device %s\n",\r\npci_name(pcidev));\r\n}\r\n} else {\r\nnes_debug(NES_DBG_INIT, "MSI not requested due to driver options for device %s\n",\r\npci_name(pcidev));\r\n}\r\nnesdev->csr_start = pci_resource_start(nesdev->pcidev, BAR_0);\r\nnesdev->doorbell_region = pci_resource_start(nesdev->pcidev, BAR_1);\r\nnesdev->nesadapter = nes_init_adapter(nesdev, hw_rev);\r\nif (!nesdev->nesadapter) {\r\nprintk(KERN_ERR PFX "Unable to initialize adapter.\n");\r\nret = -ENOMEM;\r\ngoto bail5;\r\n}\r\nnesdev->nesadapter->et_rx_coalesce_usecs_irq = interrupt_mod_interval;\r\nnesdev->nesadapter->wqm_quanta = wqm_quanta;\r\nnesdev->base_doorbell_index = 1;\r\nnesdev->doorbell_start = nesdev->nesadapter->doorbell_start;\r\nif (nesdev->nesadapter->phy_type[0] == NES_PHY_TYPE_PUMA_1G) {\r\nswitch (PCI_FUNC(nesdev->pcidev->devfn) %\r\nnesdev->nesadapter->port_count) {\r\ncase 1:\r\nnesdev->mac_index = 2;\r\nbreak;\r\ncase 2:\r\nnesdev->mac_index = 1;\r\nbreak;\r\ncase 3:\r\nnesdev->mac_index = 3;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nnesdev->mac_index = 0;\r\n}\r\n} else {\r\nnesdev->mac_index = PCI_FUNC(nesdev->pcidev->devfn) %\r\nnesdev->nesadapter->port_count;\r\n}\r\nif ((limit_maxrdreqsz ||\r\n((nesdev->nesadapter->phy_type[0] == NES_PHY_TYPE_GLADIUS) &&\r\n(hw_rev == NE020_REV1))) &&\r\n(pcie_get_readrq(pcidev) > 256)) {\r\nif (pcie_set_readrq(pcidev, 256))\r\nprintk(KERN_ERR PFX "Unable to set max read request"\r\n" to 256 bytes\n");\r\nelse\r\nnes_debug(NES_DBG_INIT, "Max read request size set"\r\n" to 256 bytes\n");\r\n}\r\ntasklet_init(&nesdev->dpc_tasklet, nes_dpc, (unsigned long)nesdev);\r\nif (nes_init_cqp(nesdev)) {\r\nret = -ENODEV;\r\ngoto bail6;\r\n}\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC, NES_CQE_ALLOC_NOTIFY_NEXT |\r\nPCI_FUNC(nesdev->pcidev->devfn));\r\nnes_read32(nesdev->regs+NES_CQE_ALLOC);\r\nnesdev->int_req = (0x101 << PCI_FUNC(nesdev->pcidev->devfn)) |\r\n(1 << (PCI_FUNC(nesdev->pcidev->devfn)+16));\r\nif (PCI_FUNC(nesdev->pcidev->devfn) < 4) {\r\nnesdev->int_req |= (1 << (PCI_FUNC(nesdev->mac_index)+24));\r\n}\r\nif (PCI_FUNC(nesdev->pcidev->devfn) == 0) {\r\nnesdev->intf_int_req = NES_INTF_INT_PCIERR | NES_INTF_INT_CRITERR;\r\nnesdev->int_req |= NES_INT_INTF;\r\n} else {\r\nnesdev->intf_int_req = 0;\r\n}\r\nnesdev->intf_int_req |= (1 << (PCI_FUNC(nesdev->pcidev->devfn)+16));\r\nnes_write_indexed(nesdev, NES_IDX_DEBUG_ERROR_MASKS0, 0);\r\nnes_write_indexed(nesdev, NES_IDX_DEBUG_ERROR_MASKS1, 0);\r\nnes_write_indexed(nesdev, NES_IDX_DEBUG_ERROR_MASKS2, 0x00001265);\r\nnes_write_indexed(nesdev, NES_IDX_DEBUG_ERROR_MASKS4, 0x18021804);\r\nnes_write_indexed(nesdev, NES_IDX_DEBUG_ERROR_MASKS3, 0x17801790);\r\nnesdev->timer_int_req = 0x101 << PCI_FUNC(nesdev->pcidev->devfn);\r\nnesdev->nesadapter->timer_int_req |= nesdev->timer_int_req;\r\nnes_debug(NES_DBG_INIT, "setting int_req for function %u, nesdev = 0x%04X, adapter = 0x%04X\n",\r\nPCI_FUNC(nesdev->pcidev->devfn),\r\nnesdev->timer_int_req, nesdev->nesadapter->timer_int_req);\r\nnes_write32(nesdev->regs+NES_INTF_INT_MASK, ~(nesdev->intf_int_req));\r\nlist_add_tail(&nesdev->list, &nes_dev_list);\r\nret = request_irq(pcidev->irq, nes_interrupt, IRQF_SHARED, DRV_NAME, nesdev);\r\nif (ret) {\r\nprintk(KERN_ERR PFX "%s: requested IRQ %u is busy\n",\r\npci_name(pcidev), pcidev->irq);\r\ngoto bail65;\r\n}\r\nnes_write32(nesdev->regs+NES_INT_MASK, ~nesdev->int_req);\r\nif (nes_notifiers_registered == 0) {\r\nregister_inetaddr_notifier(&nes_inetaddr_notifier);\r\nregister_netevent_notifier(&nes_net_notifier);\r\n}\r\nnes_notifiers_registered++;\r\nINIT_DELAYED_WORK(&nesdev->work, nes_recheck_link_status);\r\nnetdev = nes_netdev_init(nesdev, mmio_regs);\r\nif (netdev == NULL) {\r\nret = -ENOMEM;\r\ngoto bail7;\r\n}\r\nret = register_netdev(netdev);\r\nif (ret) {\r\nprintk(KERN_ERR PFX "Unable to register netdev, ret = %d\n", ret);\r\nnes_netdev_destroy(netdev);\r\ngoto bail7;\r\n}\r\nnes_print_macaddr(netdev);\r\nnesdev->netdev_count++;\r\nnesdev->nesadapter->netdev_count++;\r\nprintk(KERN_INFO PFX "%s: NetEffect RNIC driver successfully loaded.\n",\r\npci_name(pcidev));\r\nreturn 0;\r\nbail7:\r\nprintk(KERN_ERR PFX "bail7\n");\r\nwhile (nesdev->netdev_count > 0) {\r\nnesdev->netdev_count--;\r\nnesdev->nesadapter->netdev_count--;\r\nunregister_netdev(nesdev->netdev[nesdev->netdev_count]);\r\nnes_netdev_destroy(nesdev->netdev[nesdev->netdev_count]);\r\n}\r\nnes_debug(NES_DBG_INIT, "netdev_count=%d, nesadapter->netdev_count=%d\n",\r\nnesdev->netdev_count, nesdev->nesadapter->netdev_count);\r\nnes_notifiers_registered--;\r\nif (nes_notifiers_registered == 0) {\r\nunregister_netevent_notifier(&nes_net_notifier);\r\nunregister_inetaddr_notifier(&nes_inetaddr_notifier);\r\n}\r\nlist_del(&nesdev->list);\r\nnes_destroy_cqp(nesdev);\r\nbail65:\r\nprintk(KERN_ERR PFX "bail65\n");\r\nfree_irq(pcidev->irq, nesdev);\r\nif (nesdev->msi_enabled) {\r\npci_disable_msi(pcidev);\r\n}\r\nbail6:\r\nprintk(KERN_ERR PFX "bail6\n");\r\ntasklet_kill(&nesdev->dpc_tasklet);\r\nnes_destroy_adapter(nesdev->nesadapter);\r\nbail5:\r\nprintk(KERN_ERR PFX "bail5\n");\r\niounmap(nesdev->regs);\r\nbail3:\r\nprintk(KERN_ERR PFX "bail3\n");\r\nkfree(nesdev);\r\nbail2:\r\npci_release_regions(pcidev);\r\nbail1:\r\npci_disable_device(pcidev);\r\nbail0:\r\nreturn ret;\r\n}\r\nstatic void nes_remove(struct pci_dev *pcidev)\r\n{\r\nstruct nes_device *nesdev = pci_get_drvdata(pcidev);\r\nstruct net_device *netdev;\r\nint netdev_index = 0;\r\nunsigned long flags;\r\nif (nesdev->netdev_count) {\r\nnetdev = nesdev->netdev[netdev_index];\r\nif (netdev) {\r\nnetif_stop_queue(netdev);\r\nunregister_netdev(netdev);\r\nnes_netdev_destroy(netdev);\r\nnesdev->netdev[netdev_index] = NULL;\r\nnesdev->netdev_count--;\r\nnesdev->nesadapter->netdev_count--;\r\n}\r\n}\r\nnes_notifiers_registered--;\r\nif (nes_notifiers_registered == 0) {\r\nunregister_netevent_notifier(&nes_net_notifier);\r\nunregister_inetaddr_notifier(&nes_inetaddr_notifier);\r\n}\r\nlist_del(&nesdev->list);\r\nnes_destroy_cqp(nesdev);\r\nfree_irq(pcidev->irq, nesdev);\r\ntasklet_kill(&nesdev->dpc_tasklet);\r\nspin_lock_irqsave(&nesdev->nesadapter->phy_lock, flags);\r\nif (nesdev->link_recheck) {\r\nspin_unlock_irqrestore(&nesdev->nesadapter->phy_lock, flags);\r\ncancel_delayed_work_sync(&nesdev->work);\r\n} else {\r\nspin_unlock_irqrestore(&nesdev->nesadapter->phy_lock, flags);\r\n}\r\nnes_destroy_adapter(nesdev->nesadapter);\r\nif (nesdev->msi_enabled) {\r\npci_disable_msi(pcidev);\r\n}\r\niounmap(nesdev->regs);\r\nkfree(nesdev);\r\npci_release_regions(pcidev);\r\npci_disable_device(pcidev);\r\npci_set_drvdata(pcidev, NULL);\r\n}\r\nstatic ssize_t nes_show_adapter(struct device_driver *ddp, char *buf)\r\n{\r\nunsigned int devfn = 0xffffffff;\r\nunsigned char bus_number = 0xff;\r\nunsigned int i = 0;\r\nstruct nes_device *nesdev;\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\ndevfn = nesdev->pcidev->devfn;\r\nbus_number = nesdev->pcidev->bus->number;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%x:%x\n", bus_number, devfn);\r\n}\r\nstatic ssize_t nes_store_adapter(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nchar *p = (char *)buf;\r\nee_flsh_adapter = simple_strtoul(p, &p, 10);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t nes_show_ee_cmd(struct device_driver *ddp, char *buf)\r\n{\r\nu32 eeprom_cmd = 0xdead;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\neeprom_cmd = nes_read32(nesdev->regs + NES_EEPROM_COMMAND);\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "0x%x\n", eeprom_cmd);\r\n}\r\nstatic ssize_t nes_store_ee_cmd(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nchar *p = (char *)buf;\r\nu32 val;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\r\nval = simple_strtoul(p, &p, 16);\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nnes_write32(nesdev->regs + NES_EEPROM_COMMAND, val);\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t nes_show_ee_data(struct device_driver *ddp, char *buf)\r\n{\r\nu32 eeprom_data = 0xdead;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\neeprom_data = nes_read32(nesdev->regs + NES_EEPROM_DATA);\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "0x%x\n", eeprom_data);\r\n}\r\nstatic ssize_t nes_store_ee_data(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nchar *p = (char *)buf;\r\nu32 val;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\r\nval = simple_strtoul(p, &p, 16);\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nnes_write32(nesdev->regs + NES_EEPROM_DATA, val);\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t nes_show_flash_cmd(struct device_driver *ddp, char *buf)\r\n{\r\nu32 flash_cmd = 0xdead;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nflash_cmd = nes_read32(nesdev->regs + NES_FLASH_COMMAND);\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "0x%x\n", flash_cmd);\r\n}\r\nstatic ssize_t nes_store_flash_cmd(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nchar *p = (char *)buf;\r\nu32 val;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\r\nval = simple_strtoul(p, &p, 16);\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nnes_write32(nesdev->regs + NES_FLASH_COMMAND, val);\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t nes_show_flash_data(struct device_driver *ddp, char *buf)\r\n{\r\nu32 flash_data = 0xdead;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nflash_data = nes_read32(nesdev->regs + NES_FLASH_DATA);\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "0x%x\n", flash_data);\r\n}\r\nstatic ssize_t nes_store_flash_data(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nchar *p = (char *)buf;\r\nu32 val;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\r\nval = simple_strtoul(p, &p, 16);\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nnes_write32(nesdev->regs + NES_FLASH_DATA, val);\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t nes_show_nonidx_addr(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "0x%x\n", sysfs_nonidx_addr);\r\n}\r\nstatic ssize_t nes_store_nonidx_addr(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nchar *p = (char *)buf;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X')\r\nsysfs_nonidx_addr = simple_strtoul(p, &p, 16);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t nes_show_nonidx_data(struct device_driver *ddp, char *buf)\r\n{\r\nu32 nonidx_data = 0xdead;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nnonidx_data = nes_read32(nesdev->regs + sysfs_nonidx_addr);\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "0x%x\n", nonidx_data);\r\n}\r\nstatic ssize_t nes_store_nonidx_data(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nchar *p = (char *)buf;\r\nu32 val;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\r\nval = simple_strtoul(p, &p, 16);\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nnes_write32(nesdev->regs + sysfs_nonidx_addr, val);\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t nes_show_idx_addr(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "0x%x\n", sysfs_idx_addr);\r\n}\r\nstatic ssize_t nes_store_idx_addr(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nchar *p = (char *)buf;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X')\r\nsysfs_idx_addr = simple_strtoul(p, &p, 16);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t nes_show_idx_data(struct device_driver *ddp, char *buf)\r\n{\r\nu32 idx_data = 0xdead;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nidx_data = nes_read_indexed(nesdev, sysfs_idx_addr);\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "0x%x\n", idx_data);\r\n}\r\nstatic ssize_t nes_store_idx_data(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nchar *p = (char *)buf;\r\nu32 val;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\r\nval = simple_strtoul(p, &p, 16);\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nnes_write_indexed(nesdev, sysfs_idx_addr, val);\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t nes_show_wqm_quanta(struct device_driver *ddp, char *buf)\r\n{\r\nu32 wqm_quanta_value = 0xdead;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nwqm_quanta_value = nesdev->nesadapter->wqm_quanta;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "0x%X\n", wqm_quanta_value);\r\n}\r\nstatic ssize_t nes_store_wqm_quanta(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long wqm_quanta_value;\r\nu32 wqm_config1;\r\nu32 i = 0;\r\nstruct nes_device *nesdev;\r\nif (kstrtoul(buf, 0, &wqm_quanta_value) < 0)\r\nreturn -EINVAL;\r\nlist_for_each_entry(nesdev, &nes_dev_list, list) {\r\nif (i == ee_flsh_adapter) {\r\nnesdev->nesadapter->wqm_quanta = wqm_quanta_value;\r\nwqm_config1 = nes_read_indexed(nesdev,\r\nNES_IDX_WQM_CONFIG1);\r\nnes_write_indexed(nesdev, NES_IDX_WQM_CONFIG1,\r\n((wqm_quanta_value << 1) |\r\n(wqm_config1 & 0x00000001)));\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn strnlen(buf, count);\r\n}\r\nstatic int nes_create_driver_sysfs(struct pci_driver *drv)\r\n{\r\nint error;\r\nerror = driver_create_file(&drv->driver, &driver_attr_adapter);\r\nerror |= driver_create_file(&drv->driver, &driver_attr_eeprom_cmd);\r\nerror |= driver_create_file(&drv->driver, &driver_attr_eeprom_data);\r\nerror |= driver_create_file(&drv->driver, &driver_attr_flash_cmd);\r\nerror |= driver_create_file(&drv->driver, &driver_attr_flash_data);\r\nerror |= driver_create_file(&drv->driver, &driver_attr_nonidx_addr);\r\nerror |= driver_create_file(&drv->driver, &driver_attr_nonidx_data);\r\nerror |= driver_create_file(&drv->driver, &driver_attr_idx_addr);\r\nerror |= driver_create_file(&drv->driver, &driver_attr_idx_data);\r\nerror |= driver_create_file(&drv->driver, &driver_attr_wqm_quanta);\r\nreturn error;\r\n}\r\nstatic void nes_remove_driver_sysfs(struct pci_driver *drv)\r\n{\r\ndriver_remove_file(&drv->driver, &driver_attr_adapter);\r\ndriver_remove_file(&drv->driver, &driver_attr_eeprom_cmd);\r\ndriver_remove_file(&drv->driver, &driver_attr_eeprom_data);\r\ndriver_remove_file(&drv->driver, &driver_attr_flash_cmd);\r\ndriver_remove_file(&drv->driver, &driver_attr_flash_data);\r\ndriver_remove_file(&drv->driver, &driver_attr_nonidx_addr);\r\ndriver_remove_file(&drv->driver, &driver_attr_nonidx_data);\r\ndriver_remove_file(&drv->driver, &driver_attr_idx_addr);\r\ndriver_remove_file(&drv->driver, &driver_attr_idx_data);\r\ndriver_remove_file(&drv->driver, &driver_attr_wqm_quanta);\r\n}\r\nstatic int __init nes_init_module(void)\r\n{\r\nint retval;\r\nint retval1;\r\nretval = nes_cm_start();\r\nif (retval) {\r\nprintk(KERN_ERR PFX "Unable to start NetEffect iWARP CM.\n");\r\nreturn retval;\r\n}\r\nretval = pci_register_driver(&nes_pci_driver);\r\nif (retval >= 0) {\r\nretval1 = nes_create_driver_sysfs(&nes_pci_driver);\r\nif (retval1 < 0)\r\nprintk(KERN_ERR PFX "Unable to create NetEffect sys files.\n");\r\n}\r\nreturn retval;\r\n}\r\nstatic void __exit nes_exit_module(void)\r\n{\r\nnes_cm_stop();\r\nnes_remove_driver_sysfs(&nes_pci_driver);\r\npci_unregister_driver(&nes_pci_driver);\r\n}
