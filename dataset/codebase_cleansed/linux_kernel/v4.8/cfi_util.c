void cfi_udelay(int us)\r\n{\r\nif (us >= 1000) {\r\nmsleep((us+999)/1000);\r\n} else {\r\nudelay(us);\r\ncond_resched();\r\n}\r\n}\r\nuint32_t cfi_build_cmd_addr(uint32_t cmd_ofs,\r\nstruct map_info *map, struct cfi_private *cfi)\r\n{\r\nunsigned bankwidth = map_bankwidth(map);\r\nunsigned interleave = cfi_interleave(cfi);\r\nunsigned type = cfi->device_type;\r\nuint32_t addr;\r\naddr = (cmd_ofs * type) * interleave;\r\nif (((type * interleave) > bankwidth) && ((cmd_ofs & 0xff) == 0xaa))\r\naddr |= (type >> 1)*interleave;\r\nreturn addr;\r\n}\r\nmap_word cfi_build_cmd(u_long cmd, struct map_info *map, struct cfi_private *cfi)\r\n{\r\nmap_word val = { {0} };\r\nint wordwidth, words_per_bus, chip_mode, chips_per_word;\r\nunsigned long onecmd;\r\nint i;\r\nif (map_bankwidth_is_large(map)) {\r\nwordwidth = sizeof(unsigned long);\r\nwords_per_bus = (map_bankwidth(map)) / wordwidth;\r\n} else {\r\nwordwidth = map_bankwidth(map);\r\nwords_per_bus = 1;\r\n}\r\nchip_mode = map_bankwidth(map) / cfi_interleave(cfi);\r\nchips_per_word = wordwidth * cfi_interleave(cfi) / map_bankwidth(map);\r\nswitch (chip_mode) {\r\ndefault: BUG();\r\ncase 1:\r\nonecmd = cmd;\r\nbreak;\r\ncase 2:\r\nonecmd = cpu_to_cfi16(map, cmd);\r\nbreak;\r\ncase 4:\r\nonecmd = cpu_to_cfi32(map, cmd);\r\nbreak;\r\n}\r\nswitch (chips_per_word) {\r\ndefault: BUG();\r\n#if BITS_PER_LONG >= 64\r\ncase 8:\r\nonecmd |= (onecmd << (chip_mode * 32));\r\n#endif\r\ncase 4:\r\nonecmd |= (onecmd << (chip_mode * 16));\r\ncase 2:\r\nonecmd |= (onecmd << (chip_mode * 8));\r\ncase 1:\r\n;\r\n}\r\nfor (i=0; i < words_per_bus; i++) {\r\nval.x[i] = onecmd;\r\n}\r\nreturn val;\r\n}\r\nunsigned long cfi_merge_status(map_word val, struct map_info *map,\r\nstruct cfi_private *cfi)\r\n{\r\nint wordwidth, words_per_bus, chip_mode, chips_per_word;\r\nunsigned long onestat, res = 0;\r\nint i;\r\nif (map_bankwidth_is_large(map)) {\r\nwordwidth = sizeof(unsigned long);\r\nwords_per_bus = (map_bankwidth(map)) / wordwidth;\r\n} else {\r\nwordwidth = map_bankwidth(map);\r\nwords_per_bus = 1;\r\n}\r\nchip_mode = map_bankwidth(map) / cfi_interleave(cfi);\r\nchips_per_word = wordwidth * cfi_interleave(cfi) / map_bankwidth(map);\r\nonestat = val.x[0];\r\nfor (i=1; i < words_per_bus; i++) {\r\nonestat |= val.x[i];\r\n}\r\nres = onestat;\r\nswitch(chips_per_word) {\r\ndefault: BUG();\r\n#if BITS_PER_LONG >= 64\r\ncase 8:\r\nres |= (onestat >> (chip_mode * 32));\r\n#endif\r\ncase 4:\r\nres |= (onestat >> (chip_mode * 16));\r\ncase 2:\r\nres |= (onestat >> (chip_mode * 8));\r\ncase 1:\r\n;\r\n}\r\nswitch (chip_mode) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nres = cfi16_to_cpu(map, res);\r\nbreak;\r\ncase 4:\r\nres = cfi32_to_cpu(map, res);\r\nbreak;\r\ndefault: BUG();\r\n}\r\nreturn res;\r\n}\r\nuint32_t cfi_send_gen_cmd(u_char cmd, uint32_t cmd_addr, uint32_t base,\r\nstruct map_info *map, struct cfi_private *cfi,\r\nint type, map_word *prev_val)\r\n{\r\nmap_word val;\r\nuint32_t addr = base + cfi_build_cmd_addr(cmd_addr, map, cfi);\r\nval = cfi_build_cmd(cmd, map, cfi);\r\nif (prev_val)\r\n*prev_val = map_read(map, addr);\r\nmap_write(map, val, addr);\r\nreturn addr - base;\r\n}\r\nint __xipram cfi_qry_present(struct map_info *map, __u32 base,\r\nstruct cfi_private *cfi)\r\n{\r\nint osf = cfi->interleave * cfi->device_type;\r\nmap_word val[3];\r\nmap_word qry[3];\r\nqry[0] = cfi_build_cmd('Q', map, cfi);\r\nqry[1] = cfi_build_cmd('R', map, cfi);\r\nqry[2] = cfi_build_cmd('Y', map, cfi);\r\nval[0] = map_read(map, base + osf*0x10);\r\nval[1] = map_read(map, base + osf*0x11);\r\nval[2] = map_read(map, base + osf*0x12);\r\nif (!map_word_equal(map, qry[0], val[0]))\r\nreturn 0;\r\nif (!map_word_equal(map, qry[1], val[1]))\r\nreturn 0;\r\nif (!map_word_equal(map, qry[2], val[2]))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint __xipram cfi_qry_mode_on(uint32_t base, struct map_info *map,\r\nstruct cfi_private *cfi)\r\n{\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);\r\nif (cfi_qry_present(map, base, cfi))\r\nreturn 1;\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);\r\nif (cfi_qry_present(map, base, cfi))\r\nreturn 1;\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x98, 0x555, base, map, cfi, cfi->device_type, NULL);\r\nif (cfi_qry_present(map, base, cfi))\r\nreturn 1;\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xAA, 0x5555, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, 0x2AAA, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x98, 0x5555, base, map, cfi, cfi->device_type, NULL);\r\nif (cfi_qry_present(map, base, cfi))\r\nreturn 1;\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xAA, 0x555, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, 0x2AA, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x98, 0x555, base, map, cfi, cfi->device_type, NULL);\r\nif (cfi_qry_present(map, base, cfi))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid __xipram cfi_qry_mode_off(uint32_t base, struct map_info *map,\r\nstruct cfi_private *cfi)\r\n{\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);\r\nif ((cfi->mfr == CFI_MFR_ST) && (cfi->id == 0x227E || cfi->id == 0x7E))\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\n}\r\nstruct cfi_extquery *\r\n__xipram cfi_read_pri(struct map_info *map, __u16 adr, __u16 size, const char* name)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\n__u32 base = 0;\r\nint ofs_factor = cfi->interleave * cfi->device_type;\r\nint i;\r\nstruct cfi_extquery *extp = NULL;\r\nif (!adr)\r\ngoto out;\r\nprintk(KERN_INFO "%s Extended Query Table at 0x%4.4X\n", name, adr);\r\nextp = kmalloc(size, GFP_KERNEL);\r\nif (!extp)\r\ngoto out;\r\n#ifdef CONFIG_MTD_XIP\r\nlocal_irq_disable();\r\n#endif\r\ncfi_qry_mode_on(base, map, cfi);\r\nfor (i=0; i<size; i++) {\r\n((unsigned char *)extp)[i] =\r\ncfi_read_query(map, base+((adr+i)*ofs_factor));\r\n}\r\ncfi_qry_mode_off(base, map, cfi);\r\n#ifdef CONFIG_MTD_XIP\r\n(void) map_read(map, base);\r\nxip_iprefetch();\r\nlocal_irq_enable();\r\n#endif\r\nout: return extp;\r\n}\r\nvoid cfi_fixup(struct mtd_info *mtd, struct cfi_fixup *fixups)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_fixup *f;\r\nfor (f=fixups; f->fixup; f++) {\r\nif (((f->mfr == CFI_MFR_ANY) || (f->mfr == cfi->mfr)) &&\r\n((f->id == CFI_ID_ANY) || (f->id == cfi->id))) {\r\nf->fixup(mtd);\r\n}\r\n}\r\n}\r\nint cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,\r\nloff_t ofs, size_t len, void *thunk)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long adr;\r\nint chipnum, ret = 0;\r\nint i, first;\r\nstruct mtd_erase_region_info *regions = mtd->eraseregions;\r\ni = 0;\r\nwhile (i < mtd->numeraseregions && ofs >= regions[i].offset)\r\ni++;\r\ni--;\r\nif (ofs & (regions[i].erasesize-1))\r\nreturn -EINVAL;\r\nfirst = i;\r\nwhile (i<mtd->numeraseregions && (ofs + len) >= regions[i].offset)\r\ni++;\r\ni--;\r\nif ((ofs + len) & (regions[i].erasesize-1))\r\nreturn -EINVAL;\r\nchipnum = ofs >> cfi->chipshift;\r\nadr = ofs - (chipnum << cfi->chipshift);\r\ni=first;\r\nwhile(len) {\r\nint size = regions[i].erasesize;\r\nret = (*frob)(map, &cfi->chips[chipnum], adr, size, thunk);\r\nif (ret)\r\nreturn ret;\r\nadr += size;\r\nofs += size;\r\nlen -= size;\r\nif (ofs == regions[i].offset + size * regions[i].numblocks)\r\ni++;\r\nif (adr >> cfi->chipshift) {\r\nadr = 0;\r\nchipnum++;\r\nif (chipnum >= cfi->numchips)\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
