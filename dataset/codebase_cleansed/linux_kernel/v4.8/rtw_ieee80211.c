int rtw_get_bit_value_from_ieee_value(u8 val)\r\n{\r\nunsigned char dot11_rate_table[] = {\r\n2, 4, 11, 22, 12, 18, 24, 36, 48,\r\n72, 96, 108, 0};\r\nint i = 0;\r\nwhile (dot11_rate_table[i] != 0) {\r\nif (dot11_rate_table[i] == val)\r\nreturn BIT(i);\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nuint rtw_is_cckrates_included(u8 *rate)\r\n{\r\nu32 i = 0;\r\nwhile (rate[i] != 0) {\r\nif ((((rate[i]) & 0x7f) == 2) || (((rate[i]) & 0x7f) == 4) ||\r\n(((rate[i]) & 0x7f) == 11) || (((rate[i]) & 0x7f) == 22))\r\nreturn true;\r\ni++;\r\n}\r\nreturn false;\r\n}\r\nuint rtw_is_cckratesonly_included(u8 *rate)\r\n{\r\nu32 i = 0;\r\nwhile (rate[i] != 0) {\r\nif ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&\r\n(((rate[i]) & 0x7f) != 11) && (((rate[i]) & 0x7f) != 22))\r\nreturn false;\r\ni++;\r\n}\r\nreturn true;\r\n}\r\nint rtw_check_network_type(unsigned char *rate, int ratelen, int channel)\r\n{\r\nif (channel > 14) {\r\nif ((rtw_is_cckrates_included(rate)) == true)\r\nreturn WIRELESS_INVALID;\r\nelse\r\nreturn WIRELESS_11A;\r\n} else {\r\nif ((rtw_is_cckratesonly_included(rate)) == true)\r\nreturn WIRELESS_11B;\r\nelse if ((rtw_is_cckrates_included(rate)) == true)\r\nreturn WIRELESS_11BG;\r\nelse\r\nreturn WIRELESS_11G;\r\n}\r\n}\r\nu8 *rtw_set_fixed_ie(void *pbuf, unsigned int len, void *source,\r\nunsigned int *frlen)\r\n{\r\nmemcpy(pbuf, source, len);\r\n*frlen = *frlen + len;\r\nreturn ((u8 *)pbuf) + len;\r\n}\r\nu8 *rtw_set_ie\r\n(\r\nu8 *pbuf,\r\nint index,\r\nuint len,\r\nu8 *source,\r\nuint *frlen\r\n)\r\n{\r\n*pbuf = (u8)index;\r\n*(pbuf + 1) = (u8)len;\r\nif (len > 0)\r\nmemcpy((void *)(pbuf + 2), (void *)source, len);\r\n*frlen = *frlen + (len + 2);\r\nreturn pbuf + len + 2;\r\n}\r\ninline u8 *rtw_set_ie_ch_switch(u8 *buf, u32 *buf_len, u8 ch_switch_mode,\r\nu8 new_ch, u8 ch_switch_cnt)\r\n{\r\nu8 ie_data[3];\r\nie_data[0] = ch_switch_mode;\r\nie_data[1] = new_ch;\r\nie_data[2] = ch_switch_cnt;\r\nreturn rtw_set_ie(buf, WLAN_EID_CHANNEL_SWITCH, 3, ie_data, buf_len);\r\n}\r\ninline u8 secondary_ch_offset_to_hal_ch_offset(u8 ch_offset)\r\n{\r\nif (ch_offset == SCN)\r\nreturn HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nelse if (ch_offset == SCA)\r\nreturn HAL_PRIME_CHNL_OFFSET_UPPER;\r\nelse if (ch_offset == SCB)\r\nreturn HAL_PRIME_CHNL_OFFSET_LOWER;\r\nreturn HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\n}\r\ninline u8 hal_ch_offset_to_secondary_ch_offset(u8 ch_offset)\r\n{\r\nif (ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)\r\nreturn SCN;\r\nelse if (ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)\r\nreturn SCB;\r\nelse if (ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)\r\nreturn SCA;\r\nreturn SCN;\r\n}\r\ninline u8 *rtw_set_ie_secondary_ch_offset(u8 *buf, u32 *buf_len, u8 secondary_ch_offset)\r\n{\r\nreturn rtw_set_ie(buf, WLAN_EID_SECONDARY_CHANNEL_OFFSET, 1, &secondary_ch_offset, buf_len);\r\n}\r\ninline u8 *rtw_set_ie_mesh_ch_switch_parm(u8 *buf, u32 *buf_len, u8 ttl,\r\nu8 flags, u16 reason, u16 precedence)\r\n{\r\nu8 ie_data[6];\r\nie_data[0] = ttl;\r\nie_data[1] = flags;\r\n*(u16 *)(ie_data + 2) = cpu_to_le16(reason);\r\n*(u16 *)(ie_data + 4) = cpu_to_le16(precedence);\r\nreturn rtw_set_ie(buf, 0x118, 6, ie_data, buf_len);\r\n}\r\nu8 *rtw_get_ie(u8 *pbuf, int index, int *len, int limit)\r\n{\r\nint tmp, i;\r\nu8 *p;\r\nif (limit < 1)\r\nreturn NULL;\r\np = pbuf;\r\ni = 0;\r\n*len = 0;\r\nwhile (1) {\r\nif (*p == index) {\r\n*len = *(p + 1);\r\nreturn p;\r\n} else {\r\ntmp = *(p + 1);\r\np += (tmp + 2);\r\ni += (tmp + 2);\r\n}\r\nif (i >= limit)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nu8 *rtw_get_ie_ex(u8 *in_ie, uint in_len, u8 eid, u8 *oui, u8 oui_len, u8 *ie, uint *ielen)\r\n{\r\nuint cnt;\r\nu8 *target_ie = NULL;\r\nif (ielen)\r\n*ielen = 0;\r\nif (!in_ie || in_len <= 0)\r\nreturn target_ie;\r\ncnt = 0;\r\nwhile (cnt < in_len) {\r\nif (eid == in_ie[cnt] && (!oui || !memcmp(&in_ie[cnt + 2], oui, oui_len))) {\r\ntarget_ie = &in_ie[cnt];\r\nif (ie)\r\nmemcpy(ie, &in_ie[cnt], in_ie[cnt + 1] + 2);\r\nif (ielen)\r\n*ielen = in_ie[cnt + 1] + 2;\r\nbreak;\r\n} else {\r\ncnt += in_ie[cnt + 1] + 2;\r\n}\r\n}\r\nreturn target_ie;\r\n}\r\nint rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 oui_len)\r\n{\r\nint ret = _FAIL;\r\nu8 *target_ie;\r\nu32 target_ielen;\r\nu8 *start;\r\nuint search_len;\r\nif (!ies || !ies_len || *ies_len <= offset)\r\ngoto exit;\r\nstart = ies + offset;\r\nsearch_len = *ies_len - offset;\r\nwhile (1) {\r\ntarget_ie = rtw_get_ie_ex(start, search_len, eid, oui, oui_len, NULL, &target_ielen);\r\nif (target_ie && target_ielen) {\r\nu8 buf[MAX_IE_SZ] = {0};\r\nu8 *remain_ies = target_ie + target_ielen;\r\nuint remain_len = search_len - (remain_ies - start);\r\nmemcpy(buf, remain_ies, remain_len);\r\nmemcpy(target_ie, buf, remain_len);\r\n*ies_len = *ies_len - target_ielen;\r\nret = _SUCCESS;\r\nstart = target_ie;\r\nsearch_len = remain_len;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nvoid rtw_set_supported_rate(u8 *SupportedRates, uint mode)\r\n{\r\nmemset(SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);\r\nswitch (mode) {\r\ncase WIRELESS_11B:\r\nmemcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);\r\nbreak;\r\ncase WIRELESS_11G:\r\ncase WIRELESS_11A:\r\ncase WIRELESS_11_5N:\r\ncase WIRELESS_11A_5N:\r\nmemcpy(SupportedRates, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);\r\nbreak;\r\ncase WIRELESS_11BG:\r\ncase WIRELESS_11G_24N:\r\ncase WIRELESS_11_24N:\r\ncase WIRELESS_11BG_24N:\r\nmemcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);\r\nmemcpy(SupportedRates + IEEE80211_CCK_RATE_LEN, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);\r\nbreak;\r\n}\r\n}\r\nuint rtw_get_rateset_len(u8 *rateset)\r\n{\r\nuint i = 0;\r\nwhile (1) {\r\nif ((rateset[i]) == 0)\r\nbreak;\r\nif (i > 12)\r\nbreak;\r\ni++;\r\n}\r\nreturn i;\r\n}\r\nint rtw_generate_ie(struct registry_priv *pregistrypriv)\r\n{\r\nu8 wireless_mode;\r\nint sz = 0, rateLen;\r\nstruct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;\r\nu8 *ie = pdev_network->IEs;\r\nsz += 8;\r\nie += sz;\r\n*(__le16 *)ie = cpu_to_le16((u16)pdev_network->Configuration.BeaconPeriod);\r\nsz += 2;\r\nie += 2;\r\n*(u16 *)ie = 0;\r\n*(__le16 *)ie |= cpu_to_le16(cap_IBSS);\r\nif (pregistrypriv->preamble == PREAMBLE_SHORT)\r\n*(__le16 *)ie |= cpu_to_le16(cap_ShortPremble);\r\nif (pdev_network->Privacy)\r\n*(__le16 *)ie |= cpu_to_le16(cap_Privacy);\r\nsz += 2;\r\nie += 2;\r\nie = rtw_set_ie(ie, _SSID_IE_, pdev_network->Ssid.SsidLength, pdev_network->Ssid.Ssid, &sz);\r\nif (pregistrypriv->wireless_mode == WIRELESS_11ABGN) {\r\nif (pdev_network->Configuration.DSConfig > 14)\r\nwireless_mode = WIRELESS_11A_5N;\r\nelse\r\nwireless_mode = WIRELESS_11BG_24N;\r\n} else {\r\nwireless_mode = pregistrypriv->wireless_mode;\r\n}\r\nrtw_set_supported_rate(pdev_network->SupportedRates, wireless_mode);\r\nrateLen = rtw_get_rateset_len(pdev_network->SupportedRates);\r\nif (rateLen > 8) {\r\nie = rtw_set_ie(ie, _SUPPORTEDRATES_IE_, 8, pdev_network->SupportedRates, &sz);\r\n} else {\r\nie = rtw_set_ie(ie, _SUPPORTEDRATES_IE_, rateLen, pdev_network->SupportedRates, &sz);\r\n}\r\nie = rtw_set_ie(ie, _DSSET_IE_, 1, (u8 *)&(pdev_network->Configuration.DSConfig), &sz);\r\nie = rtw_set_ie(ie, _IBSS_PARA_IE_, 2, (u8 *)&(pdev_network->Configuration.ATIMWindow), &sz);\r\nif (rateLen > 8)\r\nie = rtw_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rateLen - 8), (pdev_network->SupportedRates + 8), &sz);\r\nreturn sz;\r\n}\r\nunsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit)\r\n{\r\nint len;\r\nu16 val16;\r\n__le16 le_tmp;\r\nunsigned char wpa_oui_type[] = {0x00, 0x50, 0xf2, 0x01};\r\nu8 *pbuf = pie;\r\nint limit_new = limit;\r\nwhile (1) {\r\npbuf = rtw_get_ie(pbuf, _WPA_IE_ID_, &len, limit_new);\r\nif (pbuf) {\r\nif (!memcmp((pbuf + 2), wpa_oui_type, sizeof(wpa_oui_type)) == false)\r\ngoto check_next_ie;\r\nmemcpy((u8 *)&le_tmp, (pbuf + 6), sizeof(val16));\r\nval16 = le16_to_cpu(le_tmp);\r\nif (val16 != 0x0001)\r\ngoto check_next_ie;\r\n*wpa_ie_len = *(pbuf + 1);\r\nreturn pbuf;\r\n} else {\r\n*wpa_ie_len = 0;\r\nreturn NULL;\r\n}\r\ncheck_next_ie:\r\nlimit_new = limit - (pbuf - pie) - 2 - len;\r\nif (limit_new <= 0)\r\nbreak;\r\npbuf += (2 + len);\r\n}\r\n*wpa_ie_len = 0;\r\nreturn NULL;\r\n}\r\nunsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit)\r\n{\r\nreturn rtw_get_ie(pie, _WPA2_IE_ID_, rsn_ie_len, limit);\r\n}\r\nint rtw_get_wpa_cipher_suite(u8 *s)\r\n{\r\nif (!memcmp(s, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN))\r\nreturn WPA_CIPHER_NONE;\r\nif (!memcmp(s, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN))\r\nreturn WPA_CIPHER_WEP40;\r\nif (!memcmp(s, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN))\r\nreturn WPA_CIPHER_TKIP;\r\nif (!memcmp(s, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN))\r\nreturn WPA_CIPHER_CCMP;\r\nif (!memcmp(s, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN))\r\nreturn WPA_CIPHER_WEP104;\r\nreturn 0;\r\n}\r\nint rtw_get_wpa2_cipher_suite(u8 *s)\r\n{\r\nif (!memcmp(s, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN))\r\nreturn WPA_CIPHER_NONE;\r\nif (!memcmp(s, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN))\r\nreturn WPA_CIPHER_WEP40;\r\nif (!memcmp(s, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN))\r\nreturn WPA_CIPHER_TKIP;\r\nif (!memcmp(s, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN))\r\nreturn WPA_CIPHER_CCMP;\r\nif (!memcmp(s, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN))\r\nreturn WPA_CIPHER_WEP104;\r\nreturn 0;\r\n}\r\nint rtw_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x)\r\n{\r\nint i, ret = _SUCCESS;\r\nint left, count;\r\nu8 *pos;\r\nu8 SUITE_1X[4] = {0x00, 0x50, 0xf2, 1};\r\nif (wpa_ie_len <= 0) {\r\nreturn _FAIL;\r\n}\r\nif ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie + 1) != (u8)(wpa_ie_len - 2)) ||\r\n(memcmp(wpa_ie + 2, RTW_WPA_OUI_TYPE, WPA_SELECTOR_LEN)))\r\nreturn _FAIL;\r\npos = wpa_ie;\r\npos += 8;\r\nleft = wpa_ie_len - 8;\r\nif (left >= WPA_SELECTOR_LEN) {\r\n*group_cipher = rtw_get_wpa_cipher_suite(pos);\r\npos += WPA_SELECTOR_LEN;\r\nleft -= WPA_SELECTOR_LEN;\r\n} else if (left > 0) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie length mismatch, %u too much", __func__, left));\r\nreturn _FAIL;\r\n}\r\nif (left >= 2) {\r\ncount = get_unaligned_le16(pos);\r\npos += 2;\r\nleft -= 2;\r\nif (count == 0 || left < count * WPA_SELECTOR_LEN) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie count botch (pairwise), "\r\n"count %u left %u", __func__, count, left));\r\nreturn _FAIL;\r\n}\r\nfor (i = 0; i < count; i++) {\r\n*pairwise_cipher |= rtw_get_wpa_cipher_suite(pos);\r\npos += WPA_SELECTOR_LEN;\r\nleft -= WPA_SELECTOR_LEN;\r\n}\r\n} else if (left == 1) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie too short (for key mgmt)", __func__));\r\nreturn _FAIL;\r\n}\r\nif (is_8021x) {\r\nif (left >= 6) {\r\npos += 2;\r\nif (!memcmp(pos, SUITE_1X, 4)) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("%s : there has 802.1x auth\n", __func__));\r\n*is_8021x = 1;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint rtw_parse_wpa2_ie(u8 *rsn_ie, int rsn_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x)\r\n{\r\nint i, ret = _SUCCESS;\r\nint left, count;\r\nu8 *pos;\r\nu8 SUITE_1X[4] = {0x00, 0x0f, 0xac, 0x01};\r\nif (rsn_ie_len <= 0) {\r\nreturn _FAIL;\r\n}\r\nif ((*rsn_ie != _WPA2_IE_ID_) || (*(rsn_ie + 1) != (u8)(rsn_ie_len - 2)))\r\nreturn _FAIL;\r\npos = rsn_ie;\r\npos += 4;\r\nleft = rsn_ie_len - 4;\r\nif (left >= RSN_SELECTOR_LEN) {\r\n*group_cipher = rtw_get_wpa2_cipher_suite(pos);\r\npos += RSN_SELECTOR_LEN;\r\nleft -= RSN_SELECTOR_LEN;\r\n} else if (left > 0) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie length mismatch, %u too much", __func__, left));\r\nreturn _FAIL;\r\n}\r\nif (left >= 2) {\r\ncount = get_unaligned_le16(pos);\r\npos += 2;\r\nleft -= 2;\r\nif (count == 0 || left < count * RSN_SELECTOR_LEN) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie count botch (pairwise), "\r\n"count %u left %u", __func__, count, left));\r\nreturn _FAIL;\r\n}\r\nfor (i = 0; i < count; i++) {\r\n*pairwise_cipher |= rtw_get_wpa2_cipher_suite(pos);\r\npos += RSN_SELECTOR_LEN;\r\nleft -= RSN_SELECTOR_LEN;\r\n}\r\n} else if (left == 1) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie too short (for key mgmt)", __func__));\r\nreturn _FAIL;\r\n}\r\nif (is_8021x) {\r\nif (left >= 6) {\r\npos += 2;\r\nif (!memcmp(pos, SUITE_1X, 4)) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("%s (): there has 802.1x auth\n", __func__));\r\n*is_8021x = 1;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint rtw_get_sec_ie(u8 *in_ie, uint in_len, u8 *rsn_ie, u16 *rsn_len, u8 *wpa_ie, u16 *wpa_len)\r\n{\r\nu8 authmode, sec_idx, i;\r\nu8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};\r\nuint cnt;\r\ncnt = _TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_;\r\nsec_idx = 0;\r\nwhile (cnt < in_len) {\r\nauthmode = in_ie[cnt];\r\nif ((authmode == _WPA_IE_ID_) && (!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("\n rtw_get_wpa_ie: sec_idx =%d in_ie[cnt+1]+2 =%d\n",\r\nsec_idx, in_ie[cnt + 1] + 2));\r\nif (wpa_ie) {\r\nmemcpy(wpa_ie, &in_ie[cnt], in_ie[cnt + 1] + 2);\r\nfor (i = 0; i < (in_ie[cnt + 1] + 2); i += 8) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n",\r\nwpa_ie[i], wpa_ie[i + 1], wpa_ie[i + 2], wpa_ie[i + 3], wpa_ie[i + 4],\r\nwpa_ie[i + 5], wpa_ie[i + 6], wpa_ie[i + 7]));\r\n}\r\n}\r\n*wpa_len = in_ie[cnt + 1] + 2;\r\ncnt += in_ie[cnt + 1] + 2;\r\n} else {\r\nif (authmode == _WPA2_IE_ID_) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("\n get_rsn_ie: sec_idx =%d in_ie[cnt+1]+2 =%d\n",\r\nsec_idx, in_ie[cnt + 1] + 2));\r\nif (rsn_ie) {\r\nmemcpy(rsn_ie, &in_ie[cnt], in_ie[cnt + 1] + 2);\r\nfor (i = 0; i < (in_ie[cnt + 1] + 2); i += 8) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n",\r\nrsn_ie[i], rsn_ie[i + 1], rsn_ie[i + 2], rsn_ie[i + 3], rsn_ie[i + 4],\r\nrsn_ie[i + 5], rsn_ie[i + 6], rsn_ie[i + 7]));\r\n}\r\n}\r\n*rsn_len = in_ie[cnt + 1] + 2;\r\ncnt += in_ie[cnt + 1] + 2;\r\n} else {\r\ncnt += in_ie[cnt + 1] + 2;\r\n}\r\n}\r\n}\r\nreturn *rsn_len + *wpa_len;\r\n}\r\nu8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen)\r\n{\r\nu8 match = false;\r\nu8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\r\nif (ie_ptr == NULL)\r\nreturn match;\r\neid = ie_ptr[0];\r\nif ((eid == _WPA_IE_ID_) && (!memcmp(&ie_ptr[2], wps_oui, 4))) {\r\n*wps_ielen = ie_ptr[1] + 2;\r\nmatch = true;\r\n}\r\nreturn match;\r\n}\r\nu8 *rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen)\r\n{\r\nuint cnt;\r\nu8 *wpsie_ptr = NULL;\r\nu8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\r\nif (wps_ielen)\r\n*wps_ielen = 0;\r\nif (!in_ie || in_len <= 0)\r\nreturn wpsie_ptr;\r\ncnt = 0;\r\nwhile (cnt < in_len) {\r\neid = in_ie[cnt];\r\nif ((eid == _WPA_IE_ID_) && (!memcmp(&in_ie[cnt + 2], wps_oui, 4))) {\r\nwpsie_ptr = &in_ie[cnt];\r\nif (wps_ie)\r\nmemcpy(wps_ie, &in_ie[cnt], in_ie[cnt + 1] + 2);\r\nif (wps_ielen)\r\n*wps_ielen = in_ie[cnt + 1] + 2;\r\ncnt += in_ie[cnt + 1] + 2;\r\nbreak;\r\n} else {\r\ncnt += in_ie[cnt + 1] + 2;\r\n}\r\n}\r\nreturn wpsie_ptr;\r\n}\r\nu8 *rtw_get_wps_attr(u8 *wps_ie, uint wps_ielen, u16 target_attr_id, u8 *buf_attr, u32 *len_attr)\r\n{\r\nu8 *attr_ptr = NULL;\r\nu8 *target_attr_ptr = NULL;\r\nu8 wps_oui[4] = {0x00, 0x50, 0xF2, 0x04};\r\nif (len_attr)\r\n*len_attr = 0;\r\nif ((wps_ie[0] != _VENDOR_SPECIFIC_IE_) ||\r\n(memcmp(wps_ie + 2, wps_oui, 4)))\r\nreturn attr_ptr;\r\nattr_ptr = wps_ie + 6;\r\nwhile (attr_ptr - wps_ie < wps_ielen) {\r\nu16 attr_id = get_unaligned_be16(attr_ptr);\r\nu16 attr_data_len = get_unaligned_be16(attr_ptr + 2);\r\nu16 attr_len = attr_data_len + 4;\r\nif (attr_id == target_attr_id) {\r\ntarget_attr_ptr = attr_ptr;\r\nif (buf_attr)\r\nmemcpy(buf_attr, attr_ptr, attr_len);\r\nif (len_attr)\r\n*len_attr = attr_len;\r\nbreak;\r\n} else {\r\nattr_ptr += attr_len;\r\n}\r\n}\r\nreturn target_attr_ptr;\r\n}\r\nu8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id, u8 *buf_content, uint *len_content)\r\n{\r\nu8 *attr_ptr;\r\nu32 attr_len;\r\nif (len_content)\r\n*len_content = 0;\r\nattr_ptr = rtw_get_wps_attr(wps_ie, wps_ielen, target_attr_id, NULL, &attr_len);\r\nif (attr_ptr && attr_len) {\r\nif (buf_content)\r\nmemcpy(buf_content, attr_ptr + 4, attr_len - 4);\r\nif (len_content)\r\n*len_content = attr_len - 4;\r\nreturn attr_ptr + 4;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int rtw_ieee802_11_parse_vendor_specific(u8 *pos, uint elen,\r\nstruct rtw_ieee802_11_elems *elems,\r\nint show_errors)\r\n{\r\nunsigned int oui;\r\nif (elen < 4) {\r\nif (show_errors) {\r\nDBG_88E("short vendor specific information element ignored (len=%lu)\n",\r\n(unsigned long)elen);\r\n}\r\nreturn -1;\r\n}\r\noui = RTW_GET_BE24(pos);\r\nswitch (oui) {\r\ncase OUI_MICROSOFT:\r\nswitch (pos[3]) {\r\ncase 1:\r\nelems->wpa_ie = pos;\r\nelems->wpa_ie_len = elen;\r\nbreak;\r\ncase WME_OUI_TYPE:\r\nif (elen < 5) {\r\nDBG_88E("short WME information element ignored (len=%lu)\n",\r\n(unsigned long)elen);\r\nreturn -1;\r\n}\r\nswitch (pos[4]) {\r\ncase WME_OUI_SUBTYPE_INFORMATION_ELEMENT:\r\ncase WME_OUI_SUBTYPE_PARAMETER_ELEMENT:\r\nelems->wme = pos;\r\nelems->wme_len = elen;\r\nbreak;\r\ncase WME_OUI_SUBTYPE_TSPEC_ELEMENT:\r\nelems->wme_tspec = pos;\r\nelems->wme_tspec_len = elen;\r\nbreak;\r\ndefault:\r\nDBG_88E("unknown WME information element ignored (subtype=%d len=%lu)\n",\r\npos[4], (unsigned long)elen);\r\nreturn -1;\r\n}\r\nbreak;\r\ncase 4:\r\nelems->wps_ie = pos;\r\nelems->wps_ie_len = elen;\r\nbreak;\r\ndefault:\r\nDBG_88E("Unknown Microsoft information element ignored (type=%d len=%lu)\n",\r\npos[3], (unsigned long)elen);\r\nreturn -1;\r\n}\r\nbreak;\r\ncase OUI_BROADCOM:\r\nswitch (pos[3]) {\r\ncase VENDOR_HT_CAPAB_OUI_TYPE:\r\nelems->vendor_ht_cap = pos;\r\nelems->vendor_ht_cap_len = elen;\r\nbreak;\r\ndefault:\r\nDBG_88E("Unknown Broadcom information element ignored (type=%d len=%lu)\n",\r\npos[3], (unsigned long)elen);\r\nreturn -1;\r\n}\r\nbreak;\r\ndefault:\r\nDBG_88E("unknown vendor specific information element ignored (vendor OUI %3phC len=%lu)\n",\r\npos, (unsigned long)elen);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nenum parse_res rtw_ieee802_11_parse_elems(u8 *start, uint len,\r\nstruct rtw_ieee802_11_elems *elems,\r\nint show_errors)\r\n{\r\nuint left = len;\r\nu8 *pos = start;\r\nint unknown = 0;\r\nmemset(elems, 0, sizeof(*elems));\r\nwhile (left >= 2) {\r\nu8 id, elen;\r\nid = *pos++;\r\nelen = *pos++;\r\nleft -= 2;\r\nif (elen > left) {\r\nif (show_errors) {\r\nDBG_88E("IEEE 802.11 element parse failed (id=%d elen=%d left=%lu)\n",\r\nid, elen, (unsigned long)left);\r\n}\r\nreturn ParseFailed;\r\n}\r\nswitch (id) {\r\ncase WLAN_EID_SSID:\r\nelems->ssid = pos;\r\nelems->ssid_len = elen;\r\nbreak;\r\ncase WLAN_EID_SUPP_RATES:\r\nelems->supp_rates = pos;\r\nelems->supp_rates_len = elen;\r\nbreak;\r\ncase WLAN_EID_FH_PARAMS:\r\nelems->fh_params = pos;\r\nelems->fh_params_len = elen;\r\nbreak;\r\ncase WLAN_EID_DS_PARAMS:\r\nelems->ds_params = pos;\r\nelems->ds_params_len = elen;\r\nbreak;\r\ncase WLAN_EID_CF_PARAMS:\r\nelems->cf_params = pos;\r\nelems->cf_params_len = elen;\r\nbreak;\r\ncase WLAN_EID_TIM:\r\nelems->tim = pos;\r\nelems->tim_len = elen;\r\nbreak;\r\ncase WLAN_EID_IBSS_PARAMS:\r\nelems->ibss_params = pos;\r\nelems->ibss_params_len = elen;\r\nbreak;\r\ncase WLAN_EID_CHALLENGE:\r\nelems->challenge = pos;\r\nelems->challenge_len = elen;\r\nbreak;\r\ncase WLAN_EID_ERP_INFO:\r\nelems->erp_info = pos;\r\nelems->erp_info_len = elen;\r\nbreak;\r\ncase WLAN_EID_EXT_SUPP_RATES:\r\nelems->ext_supp_rates = pos;\r\nelems->ext_supp_rates_len = elen;\r\nbreak;\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nif (rtw_ieee802_11_parse_vendor_specific(pos, elen, elems, show_errors))\r\nunknown++;\r\nbreak;\r\ncase WLAN_EID_RSN:\r\nelems->rsn_ie = pos;\r\nelems->rsn_ie_len = elen;\r\nbreak;\r\ncase WLAN_EID_PWR_CAPABILITY:\r\nelems->power_cap = pos;\r\nelems->power_cap_len = elen;\r\nbreak;\r\ncase WLAN_EID_SUPPORTED_CHANNELS:\r\nelems->supp_channels = pos;\r\nelems->supp_channels_len = elen;\r\nbreak;\r\ncase WLAN_EID_MOBILITY_DOMAIN:\r\nelems->mdie = pos;\r\nelems->mdie_len = elen;\r\nbreak;\r\ncase WLAN_EID_FAST_BSS_TRANSITION:\r\nelems->ftie = pos;\r\nelems->ftie_len = elen;\r\nbreak;\r\ncase WLAN_EID_TIMEOUT_INTERVAL:\r\nelems->timeout_int = pos;\r\nelems->timeout_int_len = elen;\r\nbreak;\r\ncase WLAN_EID_HT_CAPABILITY:\r\nelems->ht_capabilities = pos;\r\nelems->ht_capabilities_len = elen;\r\nbreak;\r\ncase WLAN_EID_HT_OPERATION:\r\nelems->ht_operation = pos;\r\nelems->ht_operation_len = elen;\r\nbreak;\r\ndefault:\r\nunknown++;\r\nif (!show_errors)\r\nbreak;\r\nDBG_88E("IEEE 802.11 element parse ignored unknown element (id=%d elen=%d)\n",\r\nid, elen);\r\nbreak;\r\n}\r\nleft -= elen;\r\npos += elen;\r\n}\r\nif (left)\r\nreturn ParseFailed;\r\nreturn unknown ? ParseUnknown : ParseOK;\r\n}\r\nvoid rtw_macaddr_cfg(u8 *mac_addr)\r\n{\r\nu8 mac[ETH_ALEN];\r\nif (mac_addr == NULL)\r\nreturn;\r\nif (rtw_initmac && mac_pton(rtw_initmac, mac)) {\r\nmemcpy(mac_addr, mac, ETH_ALEN);\r\n} else {\r\nmemcpy(mac, mac_addr, ETH_ALEN);\r\n}\r\nif (((mac[0] == 0xff) && (mac[1] == 0xff) && (mac[2] == 0xff) &&\r\n(mac[3] == 0xff) && (mac[4] == 0xff) && (mac[5] == 0xff)) ||\r\n((mac[0] == 0x0) && (mac[1] == 0x0) && (mac[2] == 0x0) &&\r\n(mac[3] == 0x0) && (mac[4] == 0x0) && (mac[5] == 0x0))) {\r\nmac[0] = 0x00;\r\nmac[1] = 0xe0;\r\nmac[2] = 0x4c;\r\nmac[3] = 0x87;\r\nmac[4] = 0x00;\r\nmac[5] = 0x00;\r\nmemcpy(mac_addr, mac, ETH_ALEN);\r\nDBG_88E("MAC Address from efuse error, assign default one !!!\n");\r\n}\r\nDBG_88E("rtw_macaddr_cfg MAC Address = %pM\n", (mac_addr));\r\n}\r\nvoid dump_ies(u8 *buf, u32 buf_len)\r\n{\r\nu8 *pos = buf;\r\nu8 id, len;\r\nwhile (pos - buf <= buf_len) {\r\nid = *pos;\r\nlen = *(pos + 1);\r\nDBG_88E("%s ID:%u, LEN:%u\n", __func__, id, len);\r\ndump_wps_ie(pos, len);\r\npos += (2 + len);\r\n}\r\n}\r\nvoid dump_wps_ie(u8 *ie, u32 ie_len)\r\n{\r\nu8 *pos = ie;\r\nu16 id;\r\nu16 len;\r\nu8 *wps_ie;\r\nuint wps_ielen;\r\nwps_ie = rtw_get_wps_ie(ie, ie_len, NULL, &wps_ielen);\r\nif (wps_ie != ie || wps_ielen == 0)\r\nreturn;\r\npos += 6;\r\nwhile (pos - ie < ie_len) {\r\nid = get_unaligned_be16(pos);\r\nlen = get_unaligned_be16(pos + 2);\r\nDBG_88E("%s ID:0x%04x, LEN:%u\n", __func__, id, len);\r\npos += (4 + len);\r\n}\r\n}\r\nint ieee80211_is_empty_essid(const char *essid, int essid_len)\r\n{\r\nif (essid_len == 1 && essid[0] == ' ')\r\nreturn 1;\r\nwhile (essid_len) {\r\nessid_len--;\r\nif (essid[essid_len] != '\0')\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint ieee80211_get_hdrlen(u16 fc)\r\n{\r\nint hdrlen = 24;\r\nswitch (WLAN_FC_GET_TYPE(fc)) {\r\ncase RTW_IEEE80211_FTYPE_DATA:\r\nif (fc & RTW_IEEE80211_STYPE_QOS_DATA)\r\nhdrlen += 2;\r\nif ((fc & RTW_IEEE80211_FCTL_FROMDS) && (fc & RTW_IEEE80211_FCTL_TODS))\r\nhdrlen += 6;\r\nbreak;\r\ncase RTW_IEEE80211_FTYPE_CTL:\r\nswitch (WLAN_FC_GET_STYPE(fc)) {\r\ncase RTW_IEEE80211_STYPE_CTS:\r\ncase RTW_IEEE80211_STYPE_ACK:\r\nhdrlen = 10;\r\nbreak;\r\ndefault:\r\nhdrlen = 16;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn hdrlen;\r\n}\r\nstatic int rtw_get_cipher_info(struct wlan_network *pnetwork)\r\n{\r\nu32 wpa_ielen;\r\nunsigned char *pbuf;\r\nint group_cipher = 0, pairwise_cipher = 0, is8021x = 0;\r\nint ret = _FAIL;\r\npbuf = rtw_get_wpa_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength - 12);\r\nif (pbuf && (wpa_ielen > 0)) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_get_cipher_info: wpa_ielen: %d", wpa_ielen));\r\nif (_SUCCESS == rtw_parse_wpa_ie(pbuf, wpa_ielen + 2, &group_cipher, &pairwise_cipher, &is8021x)) {\r\npnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;\r\npnetwork->BcnInfo.group_cipher = group_cipher;\r\npnetwork->BcnInfo.is_8021x = is8021x;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("%s: pnetwork->pairwise_cipher: %d, is_8021x is %d",\r\n__func__, pnetwork->BcnInfo.pairwise_cipher, pnetwork->BcnInfo.is_8021x));\r\nret = _SUCCESS;\r\n}\r\n} else {\r\npbuf = rtw_get_wpa2_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength - 12);\r\nif (pbuf && (wpa_ielen > 0)) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("get RSN IE\n"));\r\nif (_SUCCESS == rtw_parse_wpa2_ie(pbuf, wpa_ielen + 2, &group_cipher, &pairwise_cipher, &is8021x)) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("get RSN IE OK!!!\n"));\r\npnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;\r\npnetwork->BcnInfo.group_cipher = group_cipher;\r\npnetwork->BcnInfo.is_8021x = is8021x;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("%s: pnetwork->pairwise_cipher: %d,"\r\n"pnetwork->group_cipher is %d, is_8021x is %d", __func__, pnetwork->BcnInfo.pairwise_cipher,\r\npnetwork->BcnInfo.group_cipher, pnetwork->BcnInfo.is_8021x));\r\nret = _SUCCESS;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid rtw_get_bcn_info(struct wlan_network *pnetwork)\r\n{\r\nunsigned short cap = 0;\r\nu8 bencrypt = 0;\r\n__le16 le_tmp;\r\nu16 wpa_len = 0, rsn_len = 0;\r\nstruct HT_info_element *pht_info = NULL;\r\nstruct rtw_ieee80211_ht_cap *pht_cap = NULL;\r\nunsigned int len;\r\nunsigned char *p;\r\nmemcpy(&le_tmp, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);\r\ncap = le16_to_cpu(le_tmp);\r\nif (cap & WLAN_CAPABILITY_PRIVACY) {\r\nbencrypt = 1;\r\npnetwork->network.Privacy = 1;\r\n} else {\r\npnetwork->BcnInfo.encryp_protocol = ENCRYP_PROTOCOL_OPENSYS;\r\n}\r\nrtw_get_sec_ie(pnetwork->network.IEs, pnetwork->network.IELength, NULL, &rsn_len, NULL, &wpa_len);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_get_bcn_info: ssid =%s\n", pnetwork->network.Ssid.Ssid));\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_get_bcn_info: wpa_len =%d rsn_len =%d\n", wpa_len, rsn_len));\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_get_bcn_info: ssid =%s\n", pnetwork->network.Ssid.Ssid));\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_get_bcn_info: wpa_len =%d rsn_len =%d\n", wpa_len, rsn_len));\r\nif (rsn_len > 0) {\r\npnetwork->BcnInfo.encryp_protocol = ENCRYP_PROTOCOL_WPA2;\r\n} else if (wpa_len > 0) {\r\npnetwork->BcnInfo.encryp_protocol = ENCRYP_PROTOCOL_WPA;\r\n} else {\r\nif (bencrypt)\r\npnetwork->BcnInfo.encryp_protocol = ENCRYP_PROTOCOL_WEP;\r\n}\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_get_bcn_info: pnetwork->encryp_protocol is %x\n",\r\npnetwork->BcnInfo.encryp_protocol));\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_get_bcn_info: pnetwork->encryp_protocol is %x\n",\r\npnetwork->BcnInfo.encryp_protocol));\r\nrtw_get_cipher_info(pnetwork);\r\np = rtw_get_ie(pnetwork->network.IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, pnetwork->network.IELength - _FIXED_IE_LENGTH_);\r\nif (p && len > 0) {\r\npht_cap = (struct rtw_ieee80211_ht_cap *)(p + 2);\r\npnetwork->BcnInfo.ht_cap_info = pht_cap->cap_info;\r\n} else {\r\npnetwork->BcnInfo.ht_cap_info = 0;\r\n}\r\np = rtw_get_ie(pnetwork->network.IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_, &len, pnetwork->network.IELength - _FIXED_IE_LENGTH_);\r\nif (p && len > 0) {\r\npht_info = (struct HT_info_element *)(p + 2);\r\npnetwork->BcnInfo.ht_info_infos_0 = pht_info->infos[0];\r\n} else {\r\npnetwork->BcnInfo.ht_info_infos_0 = 0;\r\n}\r\n}\r\nu16 rtw_mcs_rate(u8 rf_type, u8 bw_40MHz, u8 short_GI_20, u8 short_GI_40, unsigned char *MCS_rate)\r\n{\r\nu16 max_rate = 0;\r\nif (rf_type == RF_1T1R) {\r\nif (MCS_rate[0] & BIT(7))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 1500 : 1350) : ((short_GI_20) ? 722 : 650);\r\nelse if (MCS_rate[0] & BIT(6))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 1350 : 1215) : ((short_GI_20) ? 650 : 585);\r\nelse if (MCS_rate[0] & BIT(5))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 1200 : 1080) : ((short_GI_20) ? 578 : 520);\r\nelse if (MCS_rate[0] & BIT(4))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 900 : 810) : ((short_GI_20) ? 433 : 390);\r\nelse if (MCS_rate[0] & BIT(3))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 600 : 540) : ((short_GI_20) ? 289 : 260);\r\nelse if (MCS_rate[0] & BIT(2))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 450 : 405) : ((short_GI_20) ? 217 : 195);\r\nelse if (MCS_rate[0] & BIT(1))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 300 : 270) : ((short_GI_20) ? 144 : 130);\r\nelse if (MCS_rate[0] & BIT(0))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 150 : 135) : ((short_GI_20) ? 72 : 65);\r\n} else {\r\nif (MCS_rate[1]) {\r\nif (MCS_rate[1] & BIT(7))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 3000 : 2700) : ((short_GI_20) ? 1444 : 1300);\r\nelse if (MCS_rate[1] & BIT(6))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 2700 : 2430) : ((short_GI_20) ? 1300 : 1170);\r\nelse if (MCS_rate[1] & BIT(5))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 2400 : 2160) : ((short_GI_20) ? 1156 : 1040);\r\nelse if (MCS_rate[1] & BIT(4))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 1800 : 1620) : ((short_GI_20) ? 867 : 780);\r\nelse if (MCS_rate[1] & BIT(3))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 1200 : 1080) : ((short_GI_20) ? 578 : 520);\r\nelse if (MCS_rate[1] & BIT(2))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 900 : 810) : ((short_GI_20) ? 433 : 390);\r\nelse if (MCS_rate[1] & BIT(1))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 600 : 540) : ((short_GI_20) ? 289 : 260);\r\nelse if (MCS_rate[1] & BIT(0))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 300 : 270) : ((short_GI_20) ? 144 : 130);\r\n} else {\r\nif (MCS_rate[0] & BIT(7))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 1500 : 1350) : ((short_GI_20) ? 722 : 650);\r\nelse if (MCS_rate[0] & BIT(6))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 1350 : 1215) : ((short_GI_20) ? 650 : 585);\r\nelse if (MCS_rate[0] & BIT(5))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 1200 : 1080) : ((short_GI_20) ? 578 : 520);\r\nelse if (MCS_rate[0] & BIT(4))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 900 : 810) : ((short_GI_20) ? 433 : 390);\r\nelse if (MCS_rate[0] & BIT(3))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 600 : 540) : ((short_GI_20) ? 289 : 260);\r\nelse if (MCS_rate[0] & BIT(2))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 450 : 405) : ((short_GI_20) ? 217 : 195);\r\nelse if (MCS_rate[0] & BIT(1))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 300 : 270) : ((short_GI_20) ? 144 : 130);\r\nelse if (MCS_rate[0] & BIT(0))\r\nmax_rate = (bw_40MHz) ? ((short_GI_40) ? 150 : 135) : ((short_GI_20) ? 72 : 65);\r\n}\r\n}\r\nreturn max_rate;\r\n}\r\nint rtw_action_frame_parse(const u8 *frame, u32 frame_len, u8 *category, u8 *action)\r\n{\r\nconst u8 *frame_body = frame + sizeof(struct rtw_ieee80211_hdr_3addr);\r\nu16 fc;\r\nu8 c, a = 0;\r\nfc = le16_to_cpu(((struct rtw_ieee80211_hdr_3addr *)frame)->frame_ctl);\r\nif ((fc & (RTW_IEEE80211_FCTL_FTYPE | RTW_IEEE80211_FCTL_STYPE)) !=\r\n(RTW_IEEE80211_FTYPE_MGMT | RTW_IEEE80211_STYPE_ACTION))\r\nreturn false;\r\nc = frame_body[0];\r\nswitch (c) {\r\ncase RTW_WLAN_CATEGORY_P2P:\r\nbreak;\r\ndefault:\r\na = frame_body[1];\r\n}\r\nif (category)\r\n*category = c;\r\nif (action)\r\n*action = a;\r\nreturn true;\r\n}\r\nconst char *action_public_str(u8 action)\r\n{\r\naction = min_t(u8, action, ACT_PUBLIC_MAX);\r\nreturn _action_public_str[action];\r\n}
