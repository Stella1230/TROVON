static int technisat_usb2_i2c_access(struct usb_device *udev,\r\nu8 device_addr, u8 *tx, u8 txlen, u8 *rx, u8 rxlen)\r\n{\r\nu8 b[64];\r\nint ret, actual_length;\r\ndeb_i2c("i2c-access: %02x, tx: ", device_addr);\r\ndebug_dump(tx, txlen, deb_i2c);\r\ndeb_i2c(" ");\r\nif (txlen > 62) {\r\nerr("i2c TX buffer can't exceed 62 bytes (dev 0x%02x)",\r\ndevice_addr);\r\ntxlen = 62;\r\n}\r\nif (rxlen > 62) {\r\nerr("i2c RX buffer can't exceed 62 bytes (dev 0x%02x)",\r\ndevice_addr);\r\nrxlen = 62;\r\n}\r\nb[0] = I2C_SPEED_100KHZ_BIT;\r\nb[1] = device_addr << 1;\r\nif (rx != NULL) {\r\nb[0] |= rxlen;\r\nb[1] |= 1;\r\n}\r\nmemcpy(&b[2], tx, txlen);\r\nret = usb_bulk_msg(udev,\r\nusb_sndbulkpipe(udev, 0x01),\r\nb, 2 + txlen,\r\nNULL, 1000);\r\nif (ret < 0) {\r\nerr("i2c-error: out failed %02x = %d", device_addr, ret);\r\nreturn -ENODEV;\r\n}\r\nret = usb_bulk_msg(udev,\r\nusb_rcvbulkpipe(udev, 0x01),\r\nb, 64, &actual_length, 1000);\r\nif (ret < 0) {\r\nerr("i2c-error: in failed %02x = %d", device_addr, ret);\r\nreturn -ENODEV;\r\n}\r\nif (b[0] != I2C_STATUS_OK) {\r\nerr("i2c-error: %02x = %d", device_addr, b[0]);\r\nif (!(b[0] == I2C_STATUS_NAK &&\r\ndevice_addr == 0x60\r\n))\r\nreturn -ENODEV;\r\n}\r\ndeb_i2c("status: %d, ", b[0]);\r\nif (rx != NULL) {\r\nmemcpy(rx, &b[2], rxlen);\r\ndeb_i2c("rx (%d): ", rxlen);\r\ndebug_dump(rx, rxlen, deb_i2c);\r\n}\r\ndeb_i2c("\n");\r\nreturn 0;\r\n}\r\nstatic int technisat_usb2_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\r\nint num)\r\n{\r\nint ret = 0, i;\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num; i++) {\r\nif (i+1 < num && msg[i+1].flags & I2C_M_RD) {\r\nret = technisat_usb2_i2c_access(d->udev, msg[i+1].addr,\r\nmsg[i].buf, msg[i].len,\r\nmsg[i+1].buf, msg[i+1].len);\r\nif (ret != 0)\r\nbreak;\r\ni++;\r\n} else {\r\nret = technisat_usb2_i2c_access(d->udev, msg[i].addr,\r\nmsg[i].buf, msg[i].len,\r\nNULL, 0);\r\nif (ret != 0)\r\nbreak;\r\n}\r\n}\r\nif (ret == 0)\r\nret = i;\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic u32 technisat_usb2_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int technisat_usb2_set_led(struct dvb_usb_device *d, int red,\r\nenum technisat_usb2_led_state st)\r\n{\r\nstruct technisat_usb2_state *state = d->priv;\r\nu8 *led = state->buf;\r\nint ret;\r\nled[0] = red ? SET_RED_LED_VENDOR_REQUEST : SET_GREEN_LED_VENDOR_REQUEST;\r\nif (disable_led_control && st != TECH_LED_OFF)\r\nreturn 0;\r\nswitch (st) {\r\ncase TECH_LED_ON:\r\nled[1] = 0x82;\r\nbreak;\r\ncase TECH_LED_BLINK:\r\nled[1] = 0x82;\r\nif (red) {\r\nled[2] = 0x02;\r\nled[3] = 10;\r\nled[4] = 10;\r\n} else {\r\nled[2] = 0xff;\r\nled[3] = 50;\r\nled[4] = 50;\r\n}\r\nled[5] = 1;\r\nbreak;\r\ndefault:\r\ncase TECH_LED_OFF:\r\nled[1] = 0x80;\r\nbreak;\r\n}\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\r\nred ? SET_RED_LED_VENDOR_REQUEST : SET_GREEN_LED_VENDOR_REQUEST,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\n0, 0,\r\nled, 8, 500);\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int technisat_usb2_set_led_timer(struct dvb_usb_device *d, u8 red, u8 green)\r\n{\r\nstruct technisat_usb2_state *state = d->priv;\r\nu8 *b = state->buf;\r\nint ret;\r\nb[0] = 0;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\r\nSET_LED_TIMER_DIVIDER_VENDOR_REQUEST,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\n(red << 8) | green, 0,\r\nb, 1, 500);\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic void technisat_usb2_green_led_control(struct work_struct *work)\r\n{\r\nstruct technisat_usb2_state *state =\r\ncontainer_of(work, struct technisat_usb2_state, green_led_work.work);\r\nstruct dvb_frontend *fe = state->dev->adapter[0].fe_adap[0].fe;\r\nif (state->power_state == 0)\r\ngoto schedule;\r\nif (fe != NULL) {\r\nenum fe_status status;\r\nif (fe->ops.read_status(fe, &status) != 0)\r\ngoto schedule;\r\nif (status & FE_HAS_LOCK) {\r\nu32 ber;\r\nif (fe->ops.read_ber(fe, &ber) != 0)\r\ngoto schedule;\r\nif (ber > 1000)\r\ntechnisat_usb2_set_led(state->dev, 0, TECH_LED_BLINK);\r\nelse\r\ntechnisat_usb2_set_led(state->dev, 0, TECH_LED_ON);\r\n} else\r\ntechnisat_usb2_set_led(state->dev, 0, TECH_LED_OFF);\r\n}\r\nschedule:\r\nschedule_delayed_work(&state->green_led_work,\r\nmsecs_to_jiffies(500));\r\n}\r\nstatic int technisat_usb2_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc, int *cold)\r\n{\r\nint ret;\r\nu8 *version;\r\nversion = kmalloc(3, GFP_KERNEL);\r\nif (!version)\r\nreturn -ENOMEM;\r\nif (usb_set_interface(udev, 0, 1) != 0)\r\nerr("could not set alternate setting to 0");\r\nelse\r\ninfo("set alternate setting");\r\n*cold = 0;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nGET_VERSION_INFO_VENDOR_REQUEST,\r\nUSB_TYPE_VENDOR | USB_DIR_IN,\r\n0, 0,\r\nversion, 3, 500);\r\nif (ret < 0)\r\n*cold = 1;\r\nelse {\r\ninfo("firmware version: %d.%d", version[1], version[2]);\r\n*cold = 0;\r\n}\r\nkfree(version);\r\nreturn 0;\r\n}\r\nstatic int technisat_usb2_power_ctrl(struct dvb_usb_device *d, int level)\r\n{\r\nstruct technisat_usb2_state *state = d->priv;\r\nstate->power_state = level;\r\nif (disable_led_control)\r\nreturn 0;\r\ntechnisat_usb2_set_led(d, 0, TECH_LED_OFF);\r\ntechnisat_usb2_set_led(d, 1, TECH_LED_ON);\r\nreturn 0;\r\n}\r\nstatic u8 technisat_usb2_calc_lrc(const u8 *b, u16 length)\r\n{\r\nu8 lrc = 0;\r\nwhile (--length)\r\nlrc ^= *b++;\r\nreturn lrc;\r\n}\r\nstatic int technisat_usb2_eeprom_lrc_read(struct dvb_usb_device *d,\r\nu16 offset, u8 *b, u16 length, u8 tries)\r\n{\r\nu8 bo = offset & 0xff;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = 0x50 | ((offset >> 8) & 0x3),\r\n.buf = &bo,\r\n.len = 1\r\n}, {\r\n.addr = 0x50 | ((offset >> 8) & 0x3),\r\n.flags = I2C_M_RD,\r\n.buf = b,\r\n.len = length\r\n}\r\n};\r\nwhile (tries--) {\r\nint status;\r\nif (i2c_transfer(&d->i2c_adap, msg, 2) != 2)\r\nbreak;\r\nstatus =\r\ntechnisat_usb2_calc_lrc(b, length - 1) == b[length - 1];\r\nif (status)\r\nreturn 0;\r\n}\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int technisat_usb2_read_mac_address(struct dvb_usb_device *d,\r\nu8 mac[])\r\n{\r\nu8 buf[EEPROM_MAC_TOTAL];\r\nif (technisat_usb2_eeprom_lrc_read(d, EEPROM_MAC_START,\r\nbuf, EEPROM_MAC_TOTAL, 4) != 0)\r\nreturn -ENODEV;\r\nmemcpy(mac, buf, 6);\r\nreturn 0;\r\n}\r\nstatic int technisat_usb2_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nint i;\r\nu8 gpio[3] = { 0 };\r\ngpio[2] = 1;\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\ngpio[0] = 1;\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\ngpio[0] = 1;\r\ngpio[1] = 1;\r\nbreak;\r\ndefault:\r\ncase SEC_VOLTAGE_OFF:\r\nbreak;\r\n}\r\nfor (i = 0; i < 3; i++)\r\nif (technisat_usb2_stv090x_config.set_gpio(fe, i+2, 0,\r\ngpio[i], 0) != 0)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int technisat_usb2_frontend_attach(struct dvb_usb_adapter *a)\r\n{\r\nstruct usb_device *udev = a->dev->udev;\r\nint ret;\r\na->fe_adap[0].fe = dvb_attach(stv090x_attach, &technisat_usb2_stv090x_config,\r\n&a->dev->i2c_adap, STV090x_DEMODULATOR_0);\r\nif (a->fe_adap[0].fe) {\r\nconst struct stv6110x_devctl *ctl;\r\nctl = dvb_attach(stv6110x_attach,\r\na->fe_adap[0].fe,\r\n&technisat_usb2_stv6110x_config,\r\n&a->dev->i2c_adap);\r\nif (ctl) {\r\ntechnisat_usb2_stv090x_config.tuner_init = ctl->tuner_init;\r\ntechnisat_usb2_stv090x_config.tuner_sleep = ctl->tuner_sleep;\r\ntechnisat_usb2_stv090x_config.tuner_set_mode = ctl->tuner_set_mode;\r\ntechnisat_usb2_stv090x_config.tuner_set_frequency = ctl->tuner_set_frequency;\r\ntechnisat_usb2_stv090x_config.tuner_get_frequency = ctl->tuner_get_frequency;\r\ntechnisat_usb2_stv090x_config.tuner_set_bandwidth = ctl->tuner_set_bandwidth;\r\ntechnisat_usb2_stv090x_config.tuner_get_bandwidth = ctl->tuner_get_bandwidth;\r\ntechnisat_usb2_stv090x_config.tuner_set_bbgain = ctl->tuner_set_bbgain;\r\ntechnisat_usb2_stv090x_config.tuner_get_bbgain = ctl->tuner_get_bbgain;\r\ntechnisat_usb2_stv090x_config.tuner_set_refclk = ctl->tuner_set_refclk;\r\ntechnisat_usb2_stv090x_config.tuner_get_status = ctl->tuner_get_status;\r\nif (a->fe_adap[0].fe->ops.init)\r\na->fe_adap[0].fe->ops.init(a->fe_adap[0].fe);\r\nif (mutex_lock_interruptible(&a->dev->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nSET_IFCLK_TO_EXTERNAL_TSCLK_VENDOR_REQUEST,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\n0, 0,\r\nNULL, 0, 500);\r\nmutex_unlock(&a->dev->i2c_mutex);\r\nif (ret != 0)\r\nerr("could not set IF_CLK to external");\r\na->fe_adap[0].fe->ops.set_voltage = technisat_usb2_set_voltage;\r\nstrlcpy(a->fe_adap[0].fe->ops.info.name, a->dev->desc->name,\r\nsizeof(a->fe_adap[0].fe->ops.info.name));\r\n} else {\r\ndvb_frontend_detach(a->fe_adap[0].fe);\r\na->fe_adap[0].fe = NULL;\r\n}\r\n}\r\ntechnisat_usb2_set_led_timer(a->dev, 1, 1);\r\nreturn a->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int technisat_usb2_get_ir(struct dvb_usb_device *d)\r\n{\r\nstruct technisat_usb2_state *state = d->priv;\r\nu8 *buf = state->buf;\r\nu8 *b;\r\nint ret;\r\nstruct ir_raw_event ev;\r\nbuf[0] = GET_IR_DATA_VENDOR_REQUEST;\r\nbuf[1] = 0x08;\r\nbuf[2] = 0x8f;\r\nbuf[3] = MINIMUM_IR_BIT_TRANSITION_TICK_COUNT;\r\nbuf[4] = MAXIMUM_IR_BIT_TIME_TICK_COUNT;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\r\nGET_IR_DATA_VENDOR_REQUEST,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\n0, 0,\r\nbuf, 5, 500);\r\nif (ret < 0)\r\ngoto unlock;\r\nbuf[1] = 0;\r\nbuf[2] = 0;\r\nret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\r\nGET_IR_DATA_VENDOR_REQUEST,\r\nUSB_TYPE_VENDOR | USB_DIR_IN,\r\n0x8080, 0,\r\nbuf, 62, 500);\r\nunlock:\r\nmutex_unlock(&d->i2c_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 1)\r\nreturn 0;\r\nb = buf+1;\r\n#if 0\r\ndeb_rc("RC: %d ", ret);\r\ndebug_dump(b, ret, deb_rc);\r\n#endif\r\nev.pulse = 0;\r\nwhile (1) {\r\nev.pulse = !ev.pulse;\r\nev.duration = (*b * FIRMWARE_CLOCK_DIVISOR * FIRMWARE_CLOCK_TICK) / 1000;\r\nir_raw_event_store(d->rc_dev, &ev);\r\nb++;\r\nif (*b == 0xff) {\r\nev.pulse = 0;\r\nev.duration = 888888*2;\r\nir_raw_event_store(d->rc_dev, &ev);\r\nbreak;\r\n}\r\n}\r\nir_raw_event_handle(d->rc_dev);\r\nreturn 1;\r\n}\r\nstatic int technisat_usb2_rc_query(struct dvb_usb_device *d)\r\n{\r\nint ret = technisat_usb2_get_ir(d);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0)\r\nreturn 0;\r\nif (!disable_led_control)\r\ntechnisat_usb2_set_led(d, 1, TECH_LED_BLINK);\r\nreturn 0;\r\n}\r\nstatic int technisat_usb2_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct dvb_usb_device *dev;\r\nif (dvb_usb_device_init(intf, &technisat_usb2_devices, THIS_MODULE,\r\n&dev, adapter_nr) != 0)\r\nreturn -ENODEV;\r\nif (dev) {\r\nstruct technisat_usb2_state *state = dev->priv;\r\nstate->dev = dev;\r\nif (!disable_led_control) {\r\nINIT_DELAYED_WORK(&state->green_led_work,\r\ntechnisat_usb2_green_led_control);\r\nschedule_delayed_work(&state->green_led_work,\r\nmsecs_to_jiffies(500));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void technisat_usb2_disconnect(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *dev = usb_get_intfdata(intf);\r\nif (dev != NULL) {\r\nstruct technisat_usb2_state *state = dev->priv;\r\nif (state != NULL)\r\ncancel_delayed_work_sync(&state->green_led_work);\r\n}\r\ndvb_usb_device_exit(intf);\r\n}
