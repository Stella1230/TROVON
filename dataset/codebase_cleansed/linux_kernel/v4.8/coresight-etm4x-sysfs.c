static int etm4_set_mode_exclude(struct etmv4_drvdata *drvdata, bool exclude)\r\n{\r\nu8 idx;\r\nstruct etmv4_config *config = &drvdata->config;\r\nidx = config->addr_idx;\r\nif (BMVAL(config->addr_acc[idx], 0, 1) == ETM_INSTR_ADDR) {\r\nif (idx % 2 != 0)\r\nreturn -EINVAL;\r\nif (config->addr_type[idx] != ETM_ADDR_TYPE_RANGE ||\r\nconfig->addr_type[idx + 1] != ETM_ADDR_TYPE_RANGE)\r\nreturn -EINVAL;\r\nif (exclude == true) {\r\nconfig->viiectlr |= BIT(idx / 2 + 16);\r\nconfig->viiectlr &= ~BIT(idx / 2);\r\n} else {\r\nconfig->viiectlr |= BIT(idx / 2);\r\nconfig->viiectlr &= ~BIT(idx / 2 + 16);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t nr_pe_cmp_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_pe_cmp;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_addr_cmp_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_addr_cmp;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_cntr_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_cntr;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_ext_inp_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_ext_inp;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t numcidc_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->numcidc;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t numvmidc_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->numvmidc;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nrseqstate_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nrseqstate;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_resource_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_resource;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_ss_cmp_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_ss_cmp;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t reset_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint i;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nif (val)\r\nconfig->mode = 0x0;\r\nconfig->mode &= ~(ETM_MODE_LOAD | ETM_MODE_STORE);\r\nconfig->cfg &= ~(BIT(1) | BIT(2));\r\nconfig->mode &= ~(ETM_MODE_DATA_TRACE_ADDR |\r\nETM_MODE_DATA_TRACE_VAL);\r\nconfig->cfg &= ~(BIT(16) | BIT(17));\r\nconfig->eventctrl0 = 0x0;\r\nconfig->eventctrl1 = 0x0;\r\nconfig->ts_ctrl = 0x0;\r\nconfig->stall_ctrl = 0x0;\r\nif (drvdata->syncpr == false)\r\nconfig->syncfreq = 0x8;\r\nconfig->vinst_ctrl |= BIT(0);\r\nif (drvdata->nr_addr_cmp == true) {\r\nconfig->mode |= ETM_MODE_VIEWINST_STARTSTOP;\r\nconfig->vinst_ctrl |= BIT(9);\r\n}\r\nconfig->viiectlr = 0x0;\r\nconfig->vissctlr = 0x0;\r\nfor (i = 0; i < drvdata->nrseqstate-1; i++)\r\nconfig->seq_ctrl[i] = 0x0;\r\nconfig->seq_rst = 0x0;\r\nconfig->seq_state = 0x0;\r\nconfig->ext_inp = 0x0;\r\nconfig->cntr_idx = 0x0;\r\nfor (i = 0; i < drvdata->nr_cntr; i++) {\r\nconfig->cntrldvr[i] = 0x0;\r\nconfig->cntr_ctrl[i] = 0x0;\r\nconfig->cntr_val[i] = 0x0;\r\n}\r\nconfig->res_idx = 0x0;\r\nfor (i = 0; i < drvdata->nr_resource; i++)\r\nconfig->res_ctrl[i] = 0x0;\r\nfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\r\nconfig->ss_ctrl[i] = 0x0;\r\nconfig->ss_pe_cmp[i] = 0x0;\r\n}\r\nconfig->addr_idx = 0x0;\r\nfor (i = 0; i < drvdata->nr_addr_cmp * 2; i++) {\r\nconfig->addr_val[i] = 0x0;\r\nconfig->addr_acc[i] = 0x0;\r\nconfig->addr_type[i] = ETM_ADDR_TYPE_NONE;\r\n}\r\nconfig->ctxid_idx = 0x0;\r\nfor (i = 0; i < drvdata->numcidc; i++) {\r\nconfig->ctxid_pid[i] = 0x0;\r\nconfig->ctxid_vpid[i] = 0x0;\r\n}\r\nconfig->ctxid_mask0 = 0x0;\r\nconfig->ctxid_mask1 = 0x0;\r\nconfig->vmid_idx = 0x0;\r\nfor (i = 0; i < drvdata->numvmidc; i++)\r\nconfig->vmid_val[i] = 0x0;\r\nconfig->vmid_mask0 = 0x0;\r\nconfig->vmid_mask1 = 0x0;\r\ndrvdata->trcid = drvdata->cpu + 1;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t mode_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->mode;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val, mode;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->mode = val & ETMv4_MODE_ALL;\r\nif (config->mode & ETM_MODE_EXCLUDE)\r\netm4_set_mode_exclude(drvdata, true);\r\nelse\r\netm4_set_mode_exclude(drvdata, false);\r\nif (drvdata->instrp0 == true) {\r\nconfig->cfg &= ~(BIT(1) | BIT(2));\r\nif (config->mode & ETM_MODE_LOAD)\r\nconfig->cfg |= BIT(1);\r\nif (config->mode & ETM_MODE_STORE)\r\nconfig->cfg |= BIT(2);\r\nif (config->mode & ETM_MODE_LOAD_STORE)\r\nconfig->cfg |= BIT(1) | BIT(2);\r\n}\r\nif ((config->mode & ETM_MODE_BB) && (drvdata->trcbb == true))\r\nconfig->cfg |= BIT(3);\r\nelse\r\nconfig->cfg &= ~BIT(3);\r\nif ((config->mode & ETMv4_MODE_CYCACC) &&\r\n(drvdata->trccci == true))\r\nconfig->cfg |= BIT(4);\r\nelse\r\nconfig->cfg &= ~BIT(4);\r\nif ((config->mode & ETMv4_MODE_CTXID) && (drvdata->ctxid_size))\r\nconfig->cfg |= BIT(6);\r\nelse\r\nconfig->cfg &= ~BIT(6);\r\nif ((config->mode & ETM_MODE_VMID) && (drvdata->vmid_size))\r\nconfig->cfg |= BIT(7);\r\nelse\r\nconfig->cfg &= ~BIT(7);\r\nmode = ETM_MODE_COND(config->mode);\r\nif (drvdata->trccond == true) {\r\nconfig->cfg &= ~(BIT(8) | BIT(9) | BIT(10));\r\nconfig->cfg |= mode << 8;\r\n}\r\nif ((config->mode & ETMv4_MODE_TIMESTAMP) && (drvdata->ts_size))\r\nconfig->cfg |= BIT(11);\r\nelse\r\nconfig->cfg &= ~BIT(11);\r\nif ((config->mode & ETM_MODE_RETURNSTACK) &&\r\n(drvdata->retstack == true))\r\nconfig->cfg |= BIT(12);\r\nelse\r\nconfig->cfg &= ~BIT(12);\r\nmode = ETM_MODE_QELEM(config->mode);\r\nconfig->cfg &= ~(BIT(13) | BIT(14));\r\nif ((mode & BIT(0)) && (drvdata->q_support & BIT(0)))\r\nconfig->cfg |= BIT(13);\r\nif ((mode & BIT(1)) && (drvdata->q_support & BIT(1)))\r\nconfig->cfg |= BIT(14);\r\nif ((config->mode & ETM_MODE_ATB_TRIGGER) &&\r\n(drvdata->atbtrig == true))\r\nconfig->eventctrl1 |= BIT(11);\r\nelse\r\nconfig->eventctrl1 &= ~BIT(11);\r\nif ((config->mode & ETM_MODE_LPOVERRIDE) &&\r\n(drvdata->lpoverride == true))\r\nconfig->eventctrl1 |= BIT(12);\r\nelse\r\nconfig->eventctrl1 &= ~BIT(12);\r\nif (config->mode & ETM_MODE_ISTALL_EN)\r\nconfig->stall_ctrl |= BIT(8);\r\nelse\r\nconfig->stall_ctrl &= ~BIT(8);\r\nif (config->mode & ETM_MODE_INSTPRIO)\r\nconfig->stall_ctrl |= BIT(10);\r\nelse\r\nconfig->stall_ctrl &= ~BIT(10);\r\nif ((config->mode & ETM_MODE_NOOVERFLOW) &&\r\n(drvdata->nooverflow == true))\r\nconfig->stall_ctrl |= BIT(13);\r\nelse\r\nconfig->stall_ctrl &= ~BIT(13);\r\nif (config->mode & ETM_MODE_VIEWINST_STARTSTOP)\r\nconfig->vinst_ctrl |= BIT(9);\r\nelse\r\nconfig->vinst_ctrl &= ~BIT(9);\r\nif (config->mode & ETM_MODE_TRACE_RESET)\r\nconfig->vinst_ctrl |= BIT(10);\r\nelse\r\nconfig->vinst_ctrl &= ~BIT(10);\r\nif ((config->mode & ETM_MODE_TRACE_ERR) &&\r\n(drvdata->trc_error == true))\r\nconfig->vinst_ctrl |= BIT(11);\r\nelse\r\nconfig->vinst_ctrl &= ~BIT(11);\r\nif (config->mode & (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER))\r\netm4_config_trace_mode(config);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t pe_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->pe_sel;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t pe_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nif (val > drvdata->nr_pe) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EINVAL;\r\n}\r\nconfig->pe_sel = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t event_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->eventctrl0;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nswitch (drvdata->nr_event) {\r\ncase 0x0:\r\nconfig->eventctrl0 = val & 0xFF;\r\nbreak;\r\ncase 0x1:\r\nconfig->eventctrl0 = val & 0xFFFF;\r\nbreak;\r\ncase 0x2:\r\nconfig->eventctrl0 = val & 0xFFFFFF;\r\nbreak;\r\ncase 0x3:\r\nconfig->eventctrl0 = val;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t event_instren_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = BMVAL(config->eventctrl1, 0, 3);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t event_instren_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->eventctrl1 &= ~(BIT(0) | BIT(1) | BIT(2) | BIT(3));\r\nswitch (drvdata->nr_event) {\r\ncase 0x0:\r\nconfig->eventctrl1 |= val & BIT(1);\r\nbreak;\r\ncase 0x1:\r\nconfig->eventctrl1 |= val & (BIT(0) | BIT(1));\r\nbreak;\r\ncase 0x2:\r\nconfig->eventctrl1 |= val & (BIT(0) | BIT(1) | BIT(2));\r\nbreak;\r\ncase 0x3:\r\nconfig->eventctrl1 |= val & 0xF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t event_ts_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->ts_ctrl;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t event_ts_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (!drvdata->ts_size)\r\nreturn -EINVAL;\r\nconfig->ts_ctrl = val & ETMv4_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t syncfreq_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->syncfreq;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t syncfreq_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (drvdata->syncpr == true)\r\nreturn -EINVAL;\r\nconfig->syncfreq = val & ETMv4_SYNC_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t cyc_threshold_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->ccctlr;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t cyc_threshold_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val < drvdata->ccitmin)\r\nreturn -EINVAL;\r\nconfig->ccctlr = val & ETM_CYC_THRESHOLD_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t bb_ctrl_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->bb_ctrl;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t bb_ctrl_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (drvdata->trcbb == false)\r\nreturn -EINVAL;\r\nif (!drvdata->nr_addr_cmp)\r\nreturn -EINVAL;\r\nif (BMVAL(val, 0, 7) > drvdata->nr_addr_cmp)\r\nreturn -EINVAL;\r\nconfig->bb_ctrl = val;\r\nreturn size;\r\n}\r\nstatic ssize_t event_vinst_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->vinst_ctrl & ETMv4_EVENT_MASK;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t event_vinst_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nval &= ETMv4_EVENT_MASK;\r\nconfig->vinst_ctrl &= ~ETMv4_EVENT_MASK;\r\nconfig->vinst_ctrl |= val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t s_exlevel_vinst_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = BMVAL(config->vinst_ctrl, 16, 19);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t s_exlevel_vinst_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->vinst_ctrl &= ~(BIT(16) | BIT(17) | BIT(19));\r\nval &= drvdata->s_ex_level;\r\nconfig->vinst_ctrl |= (val << 16);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t ns_exlevel_vinst_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = BMVAL(config->vinst_ctrl, 20, 23);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t ns_exlevel_vinst_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->vinst_ctrl &= ~(BIT(20) | BIT(21) | BIT(22));\r\nval &= drvdata->ns_ex_level;\r\nconfig->vinst_ctrl |= (val << 20);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->addr_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->nr_addr_cmp * 2)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->addr_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_instdatatype_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t len;\r\nu8 val, idx;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nval = BMVAL(config->addr_acc[idx], 0, 1);\r\nlen = scnprintf(buf, PAGE_SIZE, "%s\n",\r\nval == ETM_INSTR_ADDR ? "instr" :\r\n(val == ETM_DATA_LOAD_ADDR ? "data_load" :\r\n(val == ETM_DATA_STORE_ADDR ? "data_store" :\r\n"data_load_store")));\r\nspin_unlock(&drvdata->spinlock);\r\nreturn len;\r\n}\r\nstatic ssize_t addr_instdatatype_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nchar str[20] = "";\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (strlen(buf) >= 20)\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%s", str) != 1)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nif (!strcmp(str, "instr"))\r\nconfig->addr_acc[idx] &= ~(BIT(0) | BIT(1));\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_single_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nidx = config->addr_idx;\r\nspin_lock(&drvdata->spinlock);\r\nif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\nconfig->addr_type[idx] == ETM_ADDR_TYPE_SINGLE)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval = (unsigned long)config->addr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_single_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\nconfig->addr_type[idx] == ETM_ADDR_TYPE_SINGLE)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nconfig->addr_val[idx] = (u64)val;\r\nconfig->addr_type[idx] = ETM_ADDR_TYPE_SINGLE;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_range_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val1, val2;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nif (idx % 2 != 0) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nif (!((config->addr_type[idx] == ETM_ADDR_TYPE_NONE &&\r\nconfig->addr_type[idx + 1] == ETM_ADDR_TYPE_NONE) ||\r\n(config->addr_type[idx] == ETM_ADDR_TYPE_RANGE &&\r\nconfig->addr_type[idx + 1] == ETM_ADDR_TYPE_RANGE))) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval1 = (unsigned long)config->addr_val[idx];\r\nval2 = (unsigned long)config->addr_val[idx + 1];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx %#lx\n", val1, val2);\r\n}\r\nstatic ssize_t addr_range_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val1, val2;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (sscanf(buf, "%lx %lx", &val1, &val2) != 2)\r\nreturn -EINVAL;\r\nif (val1 > val2)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nif (idx % 2 != 0) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nif (!((config->addr_type[idx] == ETM_ADDR_TYPE_NONE &&\r\nconfig->addr_type[idx + 1] == ETM_ADDR_TYPE_NONE) ||\r\n(config->addr_type[idx] == ETM_ADDR_TYPE_RANGE &&\r\nconfig->addr_type[idx + 1] == ETM_ADDR_TYPE_RANGE))) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nconfig->addr_val[idx] = (u64)val1;\r\nconfig->addr_type[idx] = ETM_ADDR_TYPE_RANGE;\r\nconfig->addr_val[idx + 1] = (u64)val2;\r\nconfig->addr_type[idx + 1] = ETM_ADDR_TYPE_RANGE;\r\nif (config->mode & ETM_MODE_EXCLUDE)\r\netm4_set_mode_exclude(drvdata, true);\r\nelse\r\netm4_set_mode_exclude(drvdata, false);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_start_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\nconfig->addr_type[idx] == ETM_ADDR_TYPE_START)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval = (unsigned long)config->addr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_start_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nif (!drvdata->nr_addr_cmp) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EINVAL;\r\n}\r\nif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\nconfig->addr_type[idx] == ETM_ADDR_TYPE_START)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nconfig->addr_val[idx] = (u64)val;\r\nconfig->addr_type[idx] = ETM_ADDR_TYPE_START;\r\nconfig->vissctlr |= BIT(idx);\r\nconfig->vinst_ctrl |= BIT(9);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_stop_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\nconfig->addr_type[idx] == ETM_ADDR_TYPE_STOP)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval = (unsigned long)config->addr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_stop_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nif (!drvdata->nr_addr_cmp) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EINVAL;\r\n}\r\nif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\nconfig->addr_type[idx] == ETM_ADDR_TYPE_STOP)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nconfig->addr_val[idx] = (u64)val;\r\nconfig->addr_type[idx] = ETM_ADDR_TYPE_STOP;\r\nconfig->vissctlr |= BIT(idx + 16);\r\nconfig->vinst_ctrl |= BIT(9);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_ctxtype_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t len;\r\nu8 idx, val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nval = BMVAL(config->addr_acc[idx], 2, 3);\r\nlen = scnprintf(buf, PAGE_SIZE, "%s\n", val == ETM_CTX_NONE ? "none" :\r\n(val == ETM_CTX_CTXID ? "ctxid" :\r\n(val == ETM_CTX_VMID ? "vmid" : "all")));\r\nspin_unlock(&drvdata->spinlock);\r\nreturn len;\r\n}\r\nstatic ssize_t addr_ctxtype_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nchar str[10] = "";\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (strlen(buf) >= 10)\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%s", str) != 1)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nif (!strcmp(str, "none"))\r\nconfig->addr_acc[idx] &= ~(BIT(2) | BIT(3));\r\nelse if (!strcmp(str, "ctxid")) {\r\nif (drvdata->numcidc) {\r\nconfig->addr_acc[idx] |= BIT(2);\r\nconfig->addr_acc[idx] &= ~BIT(3);\r\n}\r\n} else if (!strcmp(str, "vmid")) {\r\nif (drvdata->numvmidc) {\r\nconfig->addr_acc[idx] &= ~BIT(2);\r\nconfig->addr_acc[idx] |= BIT(3);\r\n}\r\n} else if (!strcmp(str, "all")) {\r\nif (drvdata->numcidc)\r\nconfig->addr_acc[idx] |= BIT(2);\r\nif (drvdata->numvmidc)\r\nconfig->addr_acc[idx] |= BIT(3);\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_context_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nval = BMVAL(config->addr_acc[idx], 4, 6);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_context_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif ((drvdata->numcidc <= 1) && (drvdata->numvmidc <= 1))\r\nreturn -EINVAL;\r\nif (val >= (drvdata->numcidc >= drvdata->numvmidc ?\r\ndrvdata->numcidc : drvdata->numvmidc))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->addr_idx;\r\nconfig->addr_acc[idx] &= ~(BIT(4) | BIT(5) | BIT(6));\r\nconfig->addr_acc[idx] |= (val << 4);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t seq_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->seq_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->nrseqstate - 1)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->seq_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t seq_state_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->seq_state;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->nrseqstate)\r\nreturn -EINVAL;\r\nconfig->seq_state = val;\r\nreturn size;\r\n}\r\nstatic ssize_t seq_event_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->seq_idx;\r\nval = config->seq_ctrl[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->seq_idx;\r\nconfig->seq_ctrl[idx] = val & 0xFF;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t seq_reset_event_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->seq_rst;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_reset_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (!(drvdata->nrseqstate))\r\nreturn -EINVAL;\r\nconfig->seq_rst = val & ETMv4_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->cntr_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntr_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->nr_cntr)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->cntr_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntrldvr_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->cntr_idx;\r\nval = config->cntrldvr[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntrldvr_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val > ETM_CNTR_MAX_VAL)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->cntr_idx;\r\nconfig->cntrldvr[idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_val_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->cntr_idx;\r\nval = config->cntr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntr_val_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val > ETM_CNTR_MAX_VAL)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->cntr_idx;\r\nconfig->cntr_val[idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_ctrl_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->cntr_idx;\r\nval = config->cntr_ctrl[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntr_ctrl_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->cntr_idx;\r\nconfig->cntr_ctrl[idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t res_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->res_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t res_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif ((val == 0) || (val >= drvdata->nr_resource))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->res_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t res_ctrl_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->res_idx;\r\nval = config->res_ctrl[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t res_ctrl_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->res_idx;\r\nif (idx % 2 != 0)\r\nval &= ~BIT(21);\r\nconfig->res_ctrl[idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t ctxid_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->ctxid_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t ctxid_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->numcidc)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->ctxid_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t ctxid_pid_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->ctxid_idx;\r\nval = (unsigned long)config->ctxid_vpid[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t ctxid_pid_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long vpid, pid;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (!drvdata->ctxid_size || !drvdata->numcidc)\r\nreturn -EINVAL;\r\nif (kstrtoul(buf, 16, &vpid))\r\nreturn -EINVAL;\r\npid = coresight_vpid_to_pid(vpid);\r\nspin_lock(&drvdata->spinlock);\r\nidx = config->ctxid_idx;\r\nconfig->ctxid_pid[idx] = (u64)pid;\r\nconfig->ctxid_vpid[idx] = (u64)vpid;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t ctxid_masks_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val1, val2;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nval1 = config->ctxid_mask0;\r\nval2 = config->ctxid_mask1;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx %#lx\n", val1, val2);\r\n}\r\nstatic ssize_t ctxid_masks_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 i, j, maskbyte;\r\nunsigned long val1, val2, mask;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (!drvdata->ctxid_size || !drvdata->numcidc)\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%lx %lx", &val1, &val2) != 2)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nswitch (drvdata->numcidc) {\r\ncase 0x1:\r\nconfig->ctxid_mask0 = val1 & 0xFF;\r\nbreak;\r\ncase 0x2:\r\nconfig->ctxid_mask0 = val1 & 0xFFFF;\r\nbreak;\r\ncase 0x3:\r\nconfig->ctxid_mask0 = val1 & 0xFFFFFF;\r\nbreak;\r\ncase 0x4:\r\nconfig->ctxid_mask0 = val1;\r\nbreak;\r\ncase 0x5:\r\nconfig->ctxid_mask0 = val1;\r\nconfig->ctxid_mask1 = val2 & 0xFF;\r\nbreak;\r\ncase 0x6:\r\nconfig->ctxid_mask0 = val1;\r\nconfig->ctxid_mask1 = val2 & 0xFFFF;\r\nbreak;\r\ncase 0x7:\r\nconfig->ctxid_mask0 = val1;\r\nconfig->ctxid_mask1 = val2 & 0xFFFFFF;\r\nbreak;\r\ncase 0x8:\r\nconfig->ctxid_mask0 = val1;\r\nconfig->ctxid_mask1 = val2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmask = config->ctxid_mask0;\r\nfor (i = 0; i < drvdata->numcidc; i++) {\r\nmaskbyte = mask & ETMv4_EVENT_MASK;\r\nfor (j = 0; j < 8; j++) {\r\nif (maskbyte & 1)\r\nconfig->ctxid_pid[i] &= ~(0xFF << (j * 8));\r\nmaskbyte >>= 1;\r\n}\r\nif (i == 3)\r\nmask = config->ctxid_mask1;\r\nelse\r\nmask >>= 0x8;\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t vmid_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = config->vmid_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t vmid_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->numvmidc)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->vmid_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t vmid_val_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nval = (unsigned long)config->vmid_val[config->vmid_idx];\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t vmid_val_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (!drvdata->vmid_size || !drvdata->numvmidc)\r\nreturn -EINVAL;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nconfig->vmid_val[config->vmid_idx] = (u64)val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t vmid_masks_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val1, val2;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nspin_lock(&drvdata->spinlock);\r\nval1 = config->vmid_mask0;\r\nval2 = config->vmid_mask1;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx %#lx\n", val1, val2);\r\n}\r\nstatic ssize_t vmid_masks_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 i, j, maskbyte;\r\nunsigned long val1, val2, mask;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nstruct etmv4_config *config = &drvdata->config;\r\nif (!drvdata->vmid_size || !drvdata->numvmidc)\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%lx %lx", &val1, &val2) != 2)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nswitch (drvdata->numvmidc) {\r\ncase 0x1:\r\nconfig->vmid_mask0 = val1 & 0xFF;\r\nbreak;\r\ncase 0x2:\r\nconfig->vmid_mask0 = val1 & 0xFFFF;\r\nbreak;\r\ncase 0x3:\r\nconfig->vmid_mask0 = val1 & 0xFFFFFF;\r\nbreak;\r\ncase 0x4:\r\nconfig->vmid_mask0 = val1;\r\nbreak;\r\ncase 0x5:\r\nconfig->vmid_mask0 = val1;\r\nconfig->vmid_mask1 = val2 & 0xFF;\r\nbreak;\r\ncase 0x6:\r\nconfig->vmid_mask0 = val1;\r\nconfig->vmid_mask1 = val2 & 0xFFFF;\r\nbreak;\r\ncase 0x7:\r\nconfig->vmid_mask0 = val1;\r\nconfig->vmid_mask1 = val2 & 0xFFFFFF;\r\nbreak;\r\ncase 0x8:\r\nconfig->vmid_mask0 = val1;\r\nconfig->vmid_mask1 = val2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmask = config->vmid_mask0;\r\nfor (i = 0; i < drvdata->numvmidc; i++) {\r\nmaskbyte = mask & ETMv4_EVENT_MASK;\r\nfor (j = 0; j < 8; j++) {\r\nif (maskbyte & 1)\r\nconfig->vmid_val[i] &= ~(0xFF << (j * 8));\r\nmaskbyte >>= 1;\r\n}\r\nif (i == 3)\r\nmask = config->vmid_mask1;\r\nelse\r\nmask >>= 0x8;\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cpu_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->cpu;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", val);\r\n}
