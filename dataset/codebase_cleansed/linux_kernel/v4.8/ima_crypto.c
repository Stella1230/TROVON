static int param_set_bufsize(const char *val, const struct kernel_param *kp)\r\n{\r\nunsigned long long size;\r\nint order;\r\nsize = memparse(val, NULL);\r\norder = get_order(size);\r\nif (order >= MAX_ORDER)\r\nreturn -EINVAL;\r\nima_maxorder = order;\r\nima_bufsize = PAGE_SIZE << order;\r\nreturn 0;\r\n}\r\nint __init ima_init_crypto(void)\r\n{\r\nlong rc;\r\nima_shash_tfm = crypto_alloc_shash(hash_algo_name[ima_hash_algo], 0, 0);\r\nif (IS_ERR(ima_shash_tfm)) {\r\nrc = PTR_ERR(ima_shash_tfm);\r\npr_err("Can not allocate %s (reason: %ld)\n",\r\nhash_algo_name[ima_hash_algo], rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\r\n{\r\nstruct crypto_shash *tfm = ima_shash_tfm;\r\nint rc;\r\nif (algo < 0 || algo >= HASH_ALGO__LAST)\r\nalgo = ima_hash_algo;\r\nif (algo != ima_hash_algo) {\r\ntfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\r\nif (IS_ERR(tfm)) {\r\nrc = PTR_ERR(tfm);\r\npr_err("Can not allocate %s (reason: %d)\n",\r\nhash_algo_name[algo], rc);\r\n}\r\n}\r\nreturn tfm;\r\n}\r\nstatic void ima_free_tfm(struct crypto_shash *tfm)\r\n{\r\nif (tfm != ima_shash_tfm)\r\ncrypto_free_shash(tfm);\r\n}\r\nstatic void *ima_alloc_pages(loff_t max_size, size_t *allocated_size,\r\nint last_warn)\r\n{\r\nvoid *ptr;\r\nint order = ima_maxorder;\r\ngfp_t gfp_mask = __GFP_RECLAIM | __GFP_NOWARN | __GFP_NORETRY;\r\nif (order)\r\norder = min(get_order(max_size), order);\r\nfor (; order; order--) {\r\nptr = (void *)__get_free_pages(gfp_mask, order);\r\nif (ptr) {\r\n*allocated_size = PAGE_SIZE << order;\r\nreturn ptr;\r\n}\r\n}\r\ngfp_mask = GFP_KERNEL;\r\nif (!last_warn)\r\ngfp_mask |= __GFP_NOWARN;\r\nptr = (void *)__get_free_pages(gfp_mask, 0);\r\nif (ptr) {\r\n*allocated_size = PAGE_SIZE;\r\nreturn ptr;\r\n}\r\n*allocated_size = 0;\r\nreturn NULL;\r\n}\r\nstatic void ima_free_pages(void *ptr, size_t size)\r\n{\r\nif (!ptr)\r\nreturn;\r\nfree_pages((unsigned long)ptr, get_order(size));\r\n}\r\nstatic struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)\r\n{\r\nstruct crypto_ahash *tfm = ima_ahash_tfm;\r\nint rc;\r\nif (algo < 0 || algo >= HASH_ALGO__LAST)\r\nalgo = ima_hash_algo;\r\nif (algo != ima_hash_algo || !tfm) {\r\ntfm = crypto_alloc_ahash(hash_algo_name[algo], 0, 0);\r\nif (!IS_ERR(tfm)) {\r\nif (algo == ima_hash_algo)\r\nima_ahash_tfm = tfm;\r\n} else {\r\nrc = PTR_ERR(tfm);\r\npr_err("Can not allocate %s (reason: %d)\n",\r\nhash_algo_name[algo], rc);\r\n}\r\n}\r\nreturn tfm;\r\n}\r\nstatic void ima_free_atfm(struct crypto_ahash *tfm)\r\n{\r\nif (tfm != ima_ahash_tfm)\r\ncrypto_free_ahash(tfm);\r\n}\r\nstatic void ahash_complete(struct crypto_async_request *req, int err)\r\n{\r\nstruct ahash_completion *res = req->data;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nres->err = err;\r\ncomplete(&res->completion);\r\n}\r\nstatic int ahash_wait(int err, struct ahash_completion *res)\r\n{\r\nswitch (err) {\r\ncase 0:\r\nbreak;\r\ncase -EINPROGRESS:\r\ncase -EBUSY:\r\nwait_for_completion(&res->completion);\r\nreinit_completion(&res->completion);\r\nerr = res->err;\r\ndefault:\r\npr_crit_ratelimited("ahash calculation failed: err: %d\n", err);\r\n}\r\nreturn err;\r\n}\r\nstatic int ima_calc_file_hash_atfm(struct file *file,\r\nstruct ima_digest_data *hash,\r\nstruct crypto_ahash *tfm)\r\n{\r\nloff_t i_size, offset;\r\nchar *rbuf[2] = { NULL, };\r\nint rc, read = 0, rbuf_len, active = 0, ahash_rc = 0;\r\nstruct ahash_request *req;\r\nstruct scatterlist sg[1];\r\nstruct ahash_completion res;\r\nsize_t rbuf_size[2];\r\nhash->length = crypto_ahash_digestsize(tfm);\r\nreq = ahash_request_alloc(tfm, GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\ninit_completion(&res.completion);\r\nahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\r\nCRYPTO_TFM_REQ_MAY_SLEEP,\r\nahash_complete, &res);\r\nrc = ahash_wait(crypto_ahash_init(req), &res);\r\nif (rc)\r\ngoto out1;\r\ni_size = i_size_read(file_inode(file));\r\nif (i_size == 0)\r\ngoto out2;\r\nrbuf[0] = ima_alloc_pages(i_size, &rbuf_size[0], 1);\r\nif (!rbuf[0]) {\r\nrc = -ENOMEM;\r\ngoto out1;\r\n}\r\nif (i_size > rbuf_size[0]) {\r\nrbuf[1] = ima_alloc_pages(i_size - rbuf_size[0],\r\n&rbuf_size[1], 0);\r\n}\r\nif (!(file->f_mode & FMODE_READ)) {\r\nfile->f_mode |= FMODE_READ;\r\nread = 1;\r\n}\r\nfor (offset = 0; offset < i_size; offset += rbuf_len) {\r\nif (!rbuf[1] && offset) {\r\nrc = ahash_wait(ahash_rc, &res);\r\nif (rc)\r\ngoto out3;\r\n}\r\nrbuf_len = min_t(loff_t, i_size - offset, rbuf_size[active]);\r\nrc = integrity_kernel_read(file, offset, rbuf[active],\r\nrbuf_len);\r\nif (rc != rbuf_len)\r\ngoto out3;\r\nif (rbuf[1] && offset) {\r\nrc = ahash_wait(ahash_rc, &res);\r\nif (rc)\r\ngoto out3;\r\n}\r\nsg_init_one(&sg[0], rbuf[active], rbuf_len);\r\nahash_request_set_crypt(req, sg, NULL, rbuf_len);\r\nahash_rc = crypto_ahash_update(req);\r\nif (rbuf[1])\r\nactive = !active;\r\n}\r\nrc = ahash_wait(ahash_rc, &res);\r\nout3:\r\nif (read)\r\nfile->f_mode &= ~FMODE_READ;\r\nima_free_pages(rbuf[0], rbuf_size[0]);\r\nima_free_pages(rbuf[1], rbuf_size[1]);\r\nout2:\r\nif (!rc) {\r\nahash_request_set_crypt(req, NULL, hash->digest, 0);\r\nrc = ahash_wait(crypto_ahash_final(req), &res);\r\n}\r\nout1:\r\nahash_request_free(req);\r\nreturn rc;\r\n}\r\nstatic int ima_calc_file_ahash(struct file *file, struct ima_digest_data *hash)\r\n{\r\nstruct crypto_ahash *tfm;\r\nint rc;\r\ntfm = ima_alloc_atfm(hash->algo);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nrc = ima_calc_file_hash_atfm(file, hash, tfm);\r\nima_free_atfm(tfm);\r\nreturn rc;\r\n}\r\nstatic int ima_calc_file_hash_tfm(struct file *file,\r\nstruct ima_digest_data *hash,\r\nstruct crypto_shash *tfm)\r\n{\r\nloff_t i_size, offset = 0;\r\nchar *rbuf;\r\nint rc, read = 0;\r\nSHASH_DESC_ON_STACK(shash, tfm);\r\nshash->tfm = tfm;\r\nshash->flags = 0;\r\nhash->length = crypto_shash_digestsize(tfm);\r\nrc = crypto_shash_init(shash);\r\nif (rc != 0)\r\nreturn rc;\r\ni_size = i_size_read(file_inode(file));\r\nif (i_size == 0)\r\ngoto out;\r\nrbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!rbuf)\r\nreturn -ENOMEM;\r\nif (!(file->f_mode & FMODE_READ)) {\r\nfile->f_mode |= FMODE_READ;\r\nread = 1;\r\n}\r\nwhile (offset < i_size) {\r\nint rbuf_len;\r\nrbuf_len = integrity_kernel_read(file, offset, rbuf, PAGE_SIZE);\r\nif (rbuf_len < 0) {\r\nrc = rbuf_len;\r\nbreak;\r\n}\r\nif (rbuf_len == 0)\r\nbreak;\r\noffset += rbuf_len;\r\nrc = crypto_shash_update(shash, rbuf, rbuf_len);\r\nif (rc)\r\nbreak;\r\n}\r\nif (read)\r\nfile->f_mode &= ~FMODE_READ;\r\nkfree(rbuf);\r\nout:\r\nif (!rc)\r\nrc = crypto_shash_final(shash, hash->digest);\r\nreturn rc;\r\n}\r\nstatic int ima_calc_file_shash(struct file *file, struct ima_digest_data *hash)\r\n{\r\nstruct crypto_shash *tfm;\r\nint rc;\r\ntfm = ima_alloc_tfm(hash->algo);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nrc = ima_calc_file_hash_tfm(file, hash, tfm);\r\nima_free_tfm(tfm);\r\nreturn rc;\r\n}\r\nint ima_calc_file_hash(struct file *file, struct ima_digest_data *hash)\r\n{\r\nloff_t i_size;\r\nint rc;\r\ni_size = i_size_read(file_inode(file));\r\nif (ima_ahash_minsize && i_size >= ima_ahash_minsize) {\r\nrc = ima_calc_file_ahash(file, hash);\r\nif (!rc)\r\nreturn 0;\r\n}\r\nreturn ima_calc_file_shash(file, hash);\r\n}\r\nstatic int ima_calc_field_array_hash_tfm(struct ima_field_data *field_data,\r\nstruct ima_template_desc *td,\r\nint num_fields,\r\nstruct ima_digest_data *hash,\r\nstruct crypto_shash *tfm)\r\n{\r\nSHASH_DESC_ON_STACK(shash, tfm);\r\nint rc, i;\r\nshash->tfm = tfm;\r\nshash->flags = 0;\r\nhash->length = crypto_shash_digestsize(tfm);\r\nrc = crypto_shash_init(shash);\r\nif (rc != 0)\r\nreturn rc;\r\nfor (i = 0; i < num_fields; i++) {\r\nu8 buffer[IMA_EVENT_NAME_LEN_MAX + 1] = { 0 };\r\nu8 *data_to_hash = field_data[i].data;\r\nu32 datalen = field_data[i].len;\r\nif (strcmp(td->name, IMA_TEMPLATE_IMA_NAME) != 0) {\r\nrc = crypto_shash_update(shash,\r\n(const u8 *) &field_data[i].len,\r\nsizeof(field_data[i].len));\r\nif (rc)\r\nbreak;\r\n} else if (strcmp(td->fields[i]->field_id, "n") == 0) {\r\nmemcpy(buffer, data_to_hash, datalen);\r\ndata_to_hash = buffer;\r\ndatalen = IMA_EVENT_NAME_LEN_MAX + 1;\r\n}\r\nrc = crypto_shash_update(shash, data_to_hash, datalen);\r\nif (rc)\r\nbreak;\r\n}\r\nif (!rc)\r\nrc = crypto_shash_final(shash, hash->digest);\r\nreturn rc;\r\n}\r\nint ima_calc_field_array_hash(struct ima_field_data *field_data,\r\nstruct ima_template_desc *desc, int num_fields,\r\nstruct ima_digest_data *hash)\r\n{\r\nstruct crypto_shash *tfm;\r\nint rc;\r\ntfm = ima_alloc_tfm(hash->algo);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nrc = ima_calc_field_array_hash_tfm(field_data, desc, num_fields,\r\nhash, tfm);\r\nima_free_tfm(tfm);\r\nreturn rc;\r\n}\r\nstatic int calc_buffer_ahash_atfm(const void *buf, loff_t len,\r\nstruct ima_digest_data *hash,\r\nstruct crypto_ahash *tfm)\r\n{\r\nstruct ahash_request *req;\r\nstruct scatterlist sg;\r\nstruct ahash_completion res;\r\nint rc, ahash_rc = 0;\r\nhash->length = crypto_ahash_digestsize(tfm);\r\nreq = ahash_request_alloc(tfm, GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\ninit_completion(&res.completion);\r\nahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\r\nCRYPTO_TFM_REQ_MAY_SLEEP,\r\nahash_complete, &res);\r\nrc = ahash_wait(crypto_ahash_init(req), &res);\r\nif (rc)\r\ngoto out;\r\nsg_init_one(&sg, buf, len);\r\nahash_request_set_crypt(req, &sg, NULL, len);\r\nahash_rc = crypto_ahash_update(req);\r\nrc = ahash_wait(ahash_rc, &res);\r\nif (!rc) {\r\nahash_request_set_crypt(req, NULL, hash->digest, 0);\r\nrc = ahash_wait(crypto_ahash_final(req), &res);\r\n}\r\nout:\r\nahash_request_free(req);\r\nreturn rc;\r\n}\r\nstatic int calc_buffer_ahash(const void *buf, loff_t len,\r\nstruct ima_digest_data *hash)\r\n{\r\nstruct crypto_ahash *tfm;\r\nint rc;\r\ntfm = ima_alloc_atfm(hash->algo);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nrc = calc_buffer_ahash_atfm(buf, len, hash, tfm);\r\nima_free_atfm(tfm);\r\nreturn rc;\r\n}\r\nstatic int calc_buffer_shash_tfm(const void *buf, loff_t size,\r\nstruct ima_digest_data *hash,\r\nstruct crypto_shash *tfm)\r\n{\r\nSHASH_DESC_ON_STACK(shash, tfm);\r\nunsigned int len;\r\nint rc;\r\nshash->tfm = tfm;\r\nshash->flags = 0;\r\nhash->length = crypto_shash_digestsize(tfm);\r\nrc = crypto_shash_init(shash);\r\nif (rc != 0)\r\nreturn rc;\r\nwhile (size) {\r\nlen = size < PAGE_SIZE ? size : PAGE_SIZE;\r\nrc = crypto_shash_update(shash, buf, len);\r\nif (rc)\r\nbreak;\r\nbuf += len;\r\nsize -= len;\r\n}\r\nif (!rc)\r\nrc = crypto_shash_final(shash, hash->digest);\r\nreturn rc;\r\n}\r\nstatic int calc_buffer_shash(const void *buf, loff_t len,\r\nstruct ima_digest_data *hash)\r\n{\r\nstruct crypto_shash *tfm;\r\nint rc;\r\ntfm = ima_alloc_tfm(hash->algo);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nrc = calc_buffer_shash_tfm(buf, len, hash, tfm);\r\nima_free_tfm(tfm);\r\nreturn rc;\r\n}\r\nint ima_calc_buffer_hash(const void *buf, loff_t len,\r\nstruct ima_digest_data *hash)\r\n{\r\nint rc;\r\nif (ima_ahash_minsize && len >= ima_ahash_minsize) {\r\nrc = calc_buffer_ahash(buf, len, hash);\r\nif (!rc)\r\nreturn 0;\r\n}\r\nreturn calc_buffer_shash(buf, len, hash);\r\n}\r\nstatic void __init ima_pcrread(int idx, u8 *pcr)\r\n{\r\nif (!ima_used_chip)\r\nreturn;\r\nif (tpm_pcr_read(TPM_ANY_NUM, idx, pcr) != 0)\r\npr_err("Error Communicating to TPM chip\n");\r\n}\r\nstatic int __init ima_calc_boot_aggregate_tfm(char *digest,\r\nstruct crypto_shash *tfm)\r\n{\r\nu8 pcr_i[TPM_DIGEST_SIZE];\r\nint rc, i;\r\nSHASH_DESC_ON_STACK(shash, tfm);\r\nshash->tfm = tfm;\r\nshash->flags = 0;\r\nrc = crypto_shash_init(shash);\r\nif (rc != 0)\r\nreturn rc;\r\nfor (i = TPM_PCR0; i < TPM_PCR8; i++) {\r\nima_pcrread(i, pcr_i);\r\nrc = crypto_shash_update(shash, pcr_i, TPM_DIGEST_SIZE);\r\n}\r\nif (!rc)\r\ncrypto_shash_final(shash, digest);\r\nreturn rc;\r\n}\r\nint __init ima_calc_boot_aggregate(struct ima_digest_data *hash)\r\n{\r\nstruct crypto_shash *tfm;\r\nint rc;\r\ntfm = ima_alloc_tfm(hash->algo);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nhash->length = crypto_shash_digestsize(tfm);\r\nrc = ima_calc_boot_aggregate_tfm(hash->digest, tfm);\r\nima_free_tfm(tfm);\r\nreturn rc;\r\n}
