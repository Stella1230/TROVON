static struct visorchannel *\r\nvisorchannel_create_guts(u64 physaddr, unsigned long channel_bytes,\r\ngfp_t gfp, unsigned long off,\r\nuuid_le guid, bool needs_lock)\r\n{\r\nstruct visorchannel *channel;\r\nint err;\r\nsize_t size = sizeof(struct channel_header);\r\nif (physaddr == 0)\r\nreturn NULL;\r\nchannel = kzalloc(sizeof(*channel), gfp);\r\nif (!channel)\r\nreturn NULL;\r\nchannel->needs_lock = needs_lock;\r\nspin_lock_init(&channel->insert_lock);\r\nspin_lock_init(&channel->remove_lock);\r\nchannel->requested = request_mem_region(physaddr, size, MYDRVNAME);\r\nif (!channel->requested) {\r\nif (uuid_le_cmp(guid, spar_video_guid)) {\r\ngoto err_destroy_channel;\r\n}\r\n}\r\nchannel->mapped = memremap(physaddr, size, MEMREMAP_WB);\r\nif (!channel->mapped) {\r\nrelease_mem_region(physaddr, size);\r\ngoto err_destroy_channel;\r\n}\r\nchannel->physaddr = physaddr;\r\nchannel->nbytes = size;\r\nerr = visorchannel_read(channel, 0, &channel->chan_hdr,\r\nsizeof(struct channel_header));\r\nif (err)\r\ngoto err_destroy_channel;\r\nif (channel_bytes == 0)\r\nchannel_bytes = (ulong)channel->chan_hdr.size;\r\nif (uuid_le_cmp(guid, NULL_UUID_LE) == 0)\r\nguid = channel->chan_hdr.chtype;\r\nmemunmap(channel->mapped);\r\nif (channel->requested)\r\nrelease_mem_region(channel->physaddr, channel->nbytes);\r\nchannel->mapped = NULL;\r\nchannel->requested = request_mem_region(channel->physaddr,\r\nchannel_bytes, MYDRVNAME);\r\nif (!channel->requested) {\r\nif (uuid_le_cmp(guid, spar_video_guid)) {\r\ngoto err_destroy_channel;\r\n}\r\n}\r\nchannel->mapped = memremap(channel->physaddr, channel_bytes,\r\nMEMREMAP_WB);\r\nif (!channel->mapped) {\r\nrelease_mem_region(channel->physaddr, channel_bytes);\r\ngoto err_destroy_channel;\r\n}\r\nchannel->nbytes = channel_bytes;\r\nchannel->guid = guid;\r\nreturn channel;\r\nerr_destroy_channel:\r\nvisorchannel_destroy(channel);\r\nreturn NULL;\r\n}\r\nstruct visorchannel *\r\nvisorchannel_create(u64 physaddr, unsigned long channel_bytes,\r\ngfp_t gfp, uuid_le guid)\r\n{\r\nreturn visorchannel_create_guts(physaddr, channel_bytes, gfp, 0, guid,\r\nfalse);\r\n}\r\nstruct visorchannel *\r\nvisorchannel_create_with_lock(u64 physaddr, unsigned long channel_bytes,\r\ngfp_t gfp, uuid_le guid)\r\n{\r\nreturn visorchannel_create_guts(physaddr, channel_bytes, gfp, 0, guid,\r\ntrue);\r\n}\r\nvoid\r\nvisorchannel_destroy(struct visorchannel *channel)\r\n{\r\nif (!channel)\r\nreturn;\r\nif (channel->mapped) {\r\nmemunmap(channel->mapped);\r\nif (channel->requested)\r\nrelease_mem_region(channel->physaddr, channel->nbytes);\r\n}\r\nkfree(channel);\r\n}\r\nu64\r\nvisorchannel_get_physaddr(struct visorchannel *channel)\r\n{\r\nreturn channel->physaddr;\r\n}\r\nulong\r\nvisorchannel_get_nbytes(struct visorchannel *channel)\r\n{\r\nreturn channel->nbytes;\r\n}\r\nchar *\r\nvisorchannel_uuid_id(uuid_le *guid, char *s)\r\n{\r\nsprintf(s, "%pUL", guid);\r\nreturn s;\r\n}\r\nchar *\r\nvisorchannel_id(struct visorchannel *channel, char *s)\r\n{\r\nreturn visorchannel_uuid_id(&channel->guid, s);\r\n}\r\nchar *\r\nvisorchannel_zoneid(struct visorchannel *channel, char *s)\r\n{\r\nreturn visorchannel_uuid_id(&channel->chan_hdr.zone_uuid, s);\r\n}\r\nu64\r\nvisorchannel_get_clientpartition(struct visorchannel *channel)\r\n{\r\nreturn channel->chan_hdr.partition_handle;\r\n}\r\nint\r\nvisorchannel_set_clientpartition(struct visorchannel *channel,\r\nu64 partition_handle)\r\n{\r\nchannel->chan_hdr.partition_handle = partition_handle;\r\nreturn 0;\r\n}\r\nuuid_le\r\nvisorchannel_get_uuid(struct visorchannel *channel)\r\n{\r\nreturn channel->guid;\r\n}\r\nint\r\nvisorchannel_read(struct visorchannel *channel, ulong offset,\r\nvoid *local, ulong nbytes)\r\n{\r\nif (offset + nbytes > channel->nbytes)\r\nreturn -EIO;\r\nmemcpy(local, channel->mapped + offset, nbytes);\r\nreturn 0;\r\n}\r\nint\r\nvisorchannel_write(struct visorchannel *channel, ulong offset,\r\nvoid *local, ulong nbytes)\r\n{\r\nsize_t chdr_size = sizeof(struct channel_header);\r\nsize_t copy_size;\r\nif (offset + nbytes > channel->nbytes)\r\nreturn -EIO;\r\nif (offset < chdr_size) {\r\ncopy_size = min(chdr_size - offset, nbytes);\r\nmemcpy(((char *)(&channel->chan_hdr)) + offset,\r\nlocal, copy_size);\r\n}\r\nmemcpy(channel->mapped + offset, local, nbytes);\r\nreturn 0;\r\n}\r\nint\r\nvisorchannel_clear(struct visorchannel *channel, ulong offset, u8 ch,\r\nulong nbytes)\r\n{\r\nint err;\r\nint bufsize = PAGE_SIZE;\r\nint written = 0;\r\nu8 *buf;\r\nbuf = (u8 *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nmemset(buf, ch, bufsize);\r\nwhile (nbytes > 0) {\r\nint thisbytes = bufsize;\r\nif (nbytes < thisbytes)\r\nthisbytes = nbytes;\r\nerr = visorchannel_write(channel, offset + written,\r\nbuf, thisbytes);\r\nif (err)\r\ngoto out_free_page;\r\nwritten += thisbytes;\r\nnbytes -= thisbytes;\r\n}\r\nerr = 0;\r\nout_free_page:\r\nfree_page((unsigned long)buf);\r\nreturn err;\r\n}\r\nvoid __iomem *\r\nvisorchannel_get_header(struct visorchannel *channel)\r\n{\r\nreturn (void __iomem *)&channel->chan_hdr;\r\n}\r\nstatic bool\r\nsig_read_header(struct visorchannel *channel, u32 queue,\r\nstruct signal_queue_header *sig_hdr)\r\n{\r\nint err;\r\nif (channel->chan_hdr.ch_space_offset < sizeof(struct channel_header))\r\nreturn false;\r\nerr = visorchannel_read(channel,\r\nSIG_QUEUE_OFFSET(&channel->chan_hdr, queue),\r\nsig_hdr, sizeof(struct signal_queue_header));\r\nif (err)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline bool\r\nsig_read_data(struct visorchannel *channel, u32 queue,\r\nstruct signal_queue_header *sig_hdr, u32 slot, void *data)\r\n{\r\nint err;\r\nint signal_data_offset = SIG_DATA_OFFSET(&channel->chan_hdr, queue,\r\nsig_hdr, slot);\r\nerr = visorchannel_read(channel, signal_data_offset,\r\ndata, sig_hdr->signal_size);\r\nif (err)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline bool\r\nsig_write_data(struct visorchannel *channel, u32 queue,\r\nstruct signal_queue_header *sig_hdr, u32 slot, void *data)\r\n{\r\nint err;\r\nint signal_data_offset = SIG_DATA_OFFSET(&channel->chan_hdr, queue,\r\nsig_hdr, slot);\r\nerr = visorchannel_write(channel, signal_data_offset,\r\ndata, sig_hdr->signal_size);\r\nif (err)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nsignalremove_inner(struct visorchannel *channel, u32 queue, void *msg)\r\n{\r\nstruct signal_queue_header sig_hdr;\r\nif (!sig_read_header(channel, queue, &sig_hdr))\r\nreturn false;\r\nif (sig_hdr.head == sig_hdr.tail)\r\nreturn false;\r\nsig_hdr.tail = (sig_hdr.tail + 1) % sig_hdr.max_slots;\r\nif (!sig_read_data(channel, queue, &sig_hdr, sig_hdr.tail, msg))\r\nreturn false;\r\nsig_hdr.num_received++;\r\nmb();\r\nif (!SIG_WRITE_FIELD(channel, queue, &sig_hdr, tail))\r\nreturn false;\r\nif (!SIG_WRITE_FIELD(channel, queue, &sig_hdr, num_received))\r\nreturn false;\r\nreturn true;\r\n}\r\nbool\r\nvisorchannel_signalremove(struct visorchannel *channel, u32 queue, void *msg)\r\n{\r\nbool rc;\r\nunsigned long flags;\r\nif (channel->needs_lock) {\r\nspin_lock_irqsave(&channel->remove_lock, flags);\r\nrc = signalremove_inner(channel, queue, msg);\r\nspin_unlock_irqrestore(&channel->remove_lock, flags);\r\n} else {\r\nrc = signalremove_inner(channel, queue, msg);\r\n}\r\nreturn rc;\r\n}\r\nbool\r\nvisorchannel_signalempty(struct visorchannel *channel, u32 queue)\r\n{\r\nunsigned long flags = 0;\r\nstruct signal_queue_header sig_hdr;\r\nbool rc = false;\r\nif (channel->needs_lock)\r\nspin_lock_irqsave(&channel->remove_lock, flags);\r\nif (!sig_read_header(channel, queue, &sig_hdr))\r\nrc = true;\r\nif (sig_hdr.head == sig_hdr.tail)\r\nrc = true;\r\nif (channel->needs_lock)\r\nspin_unlock_irqrestore(&channel->remove_lock, flags);\r\nreturn rc;\r\n}\r\nstatic bool\r\nsignalinsert_inner(struct visorchannel *channel, u32 queue, void *msg)\r\n{\r\nstruct signal_queue_header sig_hdr;\r\nif (!sig_read_header(channel, queue, &sig_hdr))\r\nreturn false;\r\nsig_hdr.head = (sig_hdr.head + 1) % sig_hdr.max_slots;\r\nif (sig_hdr.head == sig_hdr.tail) {\r\nsig_hdr.num_overflows++;\r\nvisorchannel_write(channel,\r\nSIG_QUEUE_OFFSET(&channel->chan_hdr, queue) +\r\noffsetof(struct signal_queue_header,\r\nnum_overflows),\r\n&sig_hdr.num_overflows,\r\nsizeof(sig_hdr.num_overflows));\r\nreturn false;\r\n}\r\nif (!sig_write_data(channel, queue, &sig_hdr, sig_hdr.head, msg))\r\nreturn false;\r\nsig_hdr.num_sent++;\r\nmb();\r\nif (!SIG_WRITE_FIELD(channel, queue, &sig_hdr, head))\r\nreturn false;\r\nif (!SIG_WRITE_FIELD(channel, queue, &sig_hdr, num_sent))\r\nreturn false;\r\nreturn true;\r\n}\r\nbool\r\nvisorchannel_signalinsert(struct visorchannel *channel, u32 queue, void *msg)\r\n{\r\nbool rc;\r\nunsigned long flags;\r\nif (channel->needs_lock) {\r\nspin_lock_irqsave(&channel->insert_lock, flags);\r\nrc = signalinsert_inner(channel, queue, msg);\r\nspin_unlock_irqrestore(&channel->insert_lock, flags);\r\n} else {\r\nrc = signalinsert_inner(channel, queue, msg);\r\n}\r\nreturn rc;\r\n}\r\nint\r\nvisorchannel_signalqueue_slots_avail(struct visorchannel *channel, u32 queue)\r\n{\r\nstruct signal_queue_header sig_hdr;\r\nu32 slots_avail, slots_used;\r\nu32 head, tail;\r\nif (!sig_read_header(channel, queue, &sig_hdr))\r\nreturn 0;\r\nhead = sig_hdr.head;\r\ntail = sig_hdr.tail;\r\nif (head < tail)\r\nhead = head + sig_hdr.max_slots;\r\nslots_used = head - tail;\r\nslots_avail = sig_hdr.max_signals - slots_used;\r\nreturn (int)slots_avail;\r\n}\r\nint\r\nvisorchannel_signalqueue_max_slots(struct visorchannel *channel, u32 queue)\r\n{\r\nstruct signal_queue_header sig_hdr;\r\nif (!sig_read_header(channel, queue, &sig_hdr))\r\nreturn 0;\r\nreturn (int)sig_hdr.max_signals;\r\n}\r\nstatic void\r\nsigqueue_debug(struct signal_queue_header *q, int which, struct seq_file *seq)\r\n{\r\nseq_printf(seq, "Signal Queue #%d\n", which);\r\nseq_printf(seq, " VersionId = %lu\n", (ulong)q->version);\r\nseq_printf(seq, " Type = %lu\n", (ulong)q->chtype);\r\nseq_printf(seq, " oSignalBase = %llu\n",\r\n(long long)q->sig_base_offset);\r\nseq_printf(seq, " SignalSize = %lu\n", (ulong)q->signal_size);\r\nseq_printf(seq, " MaxSignalSlots = %lu\n",\r\n(ulong)q->max_slots);\r\nseq_printf(seq, " MaxSignals = %lu\n", (ulong)q->max_signals);\r\nseq_printf(seq, " FeatureFlags = %-16.16Lx\n",\r\n(long long)q->features);\r\nseq_printf(seq, " NumSignalsSent = %llu\n",\r\n(long long)q->num_sent);\r\nseq_printf(seq, " NumSignalsReceived = %llu\n",\r\n(long long)q->num_received);\r\nseq_printf(seq, " NumOverflows = %llu\n",\r\n(long long)q->num_overflows);\r\nseq_printf(seq, " Head = %lu\n", (ulong)q->head);\r\nseq_printf(seq, " Tail = %lu\n", (ulong)q->tail);\r\n}\r\nvoid\r\nvisorchannel_debug(struct visorchannel *channel, int num_queues,\r\nstruct seq_file *seq, u32 off)\r\n{\r\nu64 addr = 0;\r\nulong nbytes = 0, nbytes_region = 0;\r\nstruct channel_header hdr;\r\nstruct channel_header *phdr = &hdr;\r\nint i = 0;\r\nint errcode = 0;\r\nif (!channel)\r\nreturn;\r\naddr = visorchannel_get_physaddr(channel);\r\nnbytes_region = visorchannel_get_nbytes(channel);\r\nerrcode = visorchannel_read(channel, off,\r\nphdr, sizeof(struct channel_header));\r\nif (errcode < 0) {\r\nseq_printf(seq,\r\n"Read of channel header failed with errcode=%d)\n",\r\nerrcode);\r\nif (off == 0) {\r\nphdr = &channel->chan_hdr;\r\nseq_puts(seq, "(following data may be stale)\n");\r\n} else {\r\nreturn;\r\n}\r\n}\r\nnbytes = (ulong)(phdr->size);\r\nseq_printf(seq, "--- Begin channel @0x%-16.16Lx for 0x%lx bytes (region=0x%lx bytes) ---\n",\r\naddr + off, nbytes, nbytes_region);\r\nseq_printf(seq, "Type = %pUL\n", &phdr->chtype);\r\nseq_printf(seq, "ZoneGuid = %pUL\n", &phdr->zone_uuid);\r\nseq_printf(seq, "Signature = 0x%-16.16Lx\n",\r\n(long long)phdr->signature);\r\nseq_printf(seq, "LegacyState = %lu\n", (ulong)phdr->legacy_state);\r\nseq_printf(seq, "SrvState = %lu\n", (ulong)phdr->srv_state);\r\nseq_printf(seq, "CliStateBoot = %lu\n", (ulong)phdr->cli_state_boot);\r\nseq_printf(seq, "CliStateOS = %lu\n", (ulong)phdr->cli_state_os);\r\nseq_printf(seq, "HeaderSize = %lu\n", (ulong)phdr->header_size);\r\nseq_printf(seq, "Size = %llu\n", (long long)phdr->size);\r\nseq_printf(seq, "Features = 0x%-16.16llx\n",\r\n(long long)phdr->features);\r\nseq_printf(seq, "PartitionHandle = 0x%-16.16llx\n",\r\n(long long)phdr->partition_handle);\r\nseq_printf(seq, "Handle = 0x%-16.16llx\n",\r\n(long long)phdr->handle);\r\nseq_printf(seq, "VersionId = %lu\n", (ulong)phdr->version_id);\r\nseq_printf(seq, "oChannelSpace = %llu\n",\r\n(long long)phdr->ch_space_offset);\r\nif ((phdr->ch_space_offset == 0) || (errcode < 0))\r\n;\r\nelse\r\nfor (i = 0; i < num_queues; i++) {\r\nstruct signal_queue_header q;\r\nerrcode = visorchannel_read(channel,\r\noff +\r\nphdr->ch_space_offset +\r\n(i * sizeof(q)),\r\n&q, sizeof(q));\r\nif (errcode < 0) {\r\nseq_printf(seq,\r\n"failed to read signal queue #%d from channel @0x%-16.16Lx errcode=%d\n",\r\ni, addr, errcode);\r\ncontinue;\r\n}\r\nsigqueue_debug(&q, i, seq);\r\n}\r\nseq_printf(seq, "--- End channel @0x%-16.16Lx for 0x%lx bytes ---\n",\r\naddr + off, nbytes);\r\n}
