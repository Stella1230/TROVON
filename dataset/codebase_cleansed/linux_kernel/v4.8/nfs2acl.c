static __be32\r\nnfsacld_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\r\n{\r\nreturn nfs_ok;\r\n}\r\nstatic __be32 nfsacld_proc_getacl(struct svc_rqst * rqstp,\r\nstruct nfsd3_getaclargs *argp, struct nfsd3_getaclres *resp)\r\n{\r\nstruct posix_acl *acl;\r\nstruct inode *inode;\r\nsvc_fh *fh;\r\n__be32 nfserr = 0;\r\ndprintk("nfsd: GETACL(2acl) %s\n", SVCFH_fmt(&argp->fh));\r\nfh = fh_copy(&resp->fh, &argp->fh);\r\nnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\r\nif (nfserr)\r\nRETURN_STATUS(nfserr);\r\ninode = d_inode(fh->fh_dentry);\r\nif (argp->mask & ~NFS_ACL_MASK)\r\nRETURN_STATUS(nfserr_inval);\r\nresp->mask = argp->mask;\r\nnfserr = fh_getattr(fh, &resp->stat);\r\nif (nfserr)\r\nRETURN_STATUS(nfserr);\r\nif (resp->mask & (NFS_ACL|NFS_ACLCNT)) {\r\nacl = get_acl(inode, ACL_TYPE_ACCESS);\r\nif (acl == NULL) {\r\nacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\r\n}\r\nif (IS_ERR(acl)) {\r\nnfserr = nfserrno(PTR_ERR(acl));\r\ngoto fail;\r\n}\r\nresp->acl_access = acl;\r\n}\r\nif (resp->mask & (NFS_DFACL|NFS_DFACLCNT)) {\r\nacl = get_acl(inode, ACL_TYPE_DEFAULT);\r\nif (IS_ERR(acl)) {\r\nnfserr = nfserrno(PTR_ERR(acl));\r\ngoto fail;\r\n}\r\nresp->acl_default = acl;\r\n}\r\nRETURN_STATUS(0);\r\nfail:\r\nposix_acl_release(resp->acl_access);\r\nposix_acl_release(resp->acl_default);\r\nRETURN_STATUS(nfserr);\r\n}\r\nstatic __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\r\nstruct nfsd3_setaclargs *argp,\r\nstruct nfsd_attrstat *resp)\r\n{\r\nstruct inode *inode;\r\nsvc_fh *fh;\r\n__be32 nfserr = 0;\r\nint error;\r\ndprintk("nfsd: SETACL(2acl) %s\n", SVCFH_fmt(&argp->fh));\r\nfh = fh_copy(&resp->fh, &argp->fh);\r\nnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\r\nif (nfserr)\r\ngoto out;\r\ninode = d_inode(fh->fh_dentry);\r\nerror = fh_want_write(fh);\r\nif (error)\r\ngoto out_errno;\r\nfh_lock(fh);\r\nerror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\r\nif (error)\r\ngoto out_drop_lock;\r\nerror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\r\nif (error)\r\ngoto out_drop_lock;\r\nfh_unlock(fh);\r\nfh_drop_write(fh);\r\nnfserr = fh_getattr(fh, &resp->stat);\r\nout:\r\nposix_acl_release(argp->acl_access);\r\nposix_acl_release(argp->acl_default);\r\nreturn nfserr;\r\nout_drop_lock:\r\nfh_unlock(fh);\r\nfh_drop_write(fh);\r\nout_errno:\r\nnfserr = nfserrno(error);\r\ngoto out;\r\n}\r\nstatic __be32 nfsacld_proc_getattr(struct svc_rqst * rqstp,\r\nstruct nfsd_fhandle *argp, struct nfsd_attrstat *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: GETATTR %s\n", SVCFH_fmt(&argp->fh));\r\nfh_copy(&resp->fh, &argp->fh);\r\nnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\r\nif (nfserr)\r\nreturn nfserr;\r\nnfserr = fh_getattr(&resp->fh, &resp->stat);\r\nreturn nfserr;\r\n}\r\nstatic __be32 nfsacld_proc_access(struct svc_rqst *rqstp, struct nfsd3_accessargs *argp,\r\nstruct nfsd3_accessres *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: ACCESS(2acl) %s 0x%x\n",\r\nSVCFH_fmt(&argp->fh),\r\nargp->access);\r\nfh_copy(&resp->fh, &argp->fh);\r\nresp->access = argp->access;\r\nnfserr = nfsd_access(rqstp, &resp->fh, &resp->access, NULL);\r\nif (nfserr)\r\nreturn nfserr;\r\nnfserr = fh_getattr(&resp->fh, &resp->stat);\r\nreturn nfserr;\r\n}\r\nstatic int nfsaclsvc_decode_getaclargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclargs *argp)\r\n{\r\np = nfs2svc_decode_fh(p, &argp->fh);\r\nif (!p)\r\nreturn 0;\r\nargp->mask = ntohl(*p); p++;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_decode_setaclargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_setaclargs *argp)\r\n{\r\nstruct kvec *head = rqstp->rq_arg.head;\r\nunsigned int base;\r\nint n;\r\np = nfs2svc_decode_fh(p, &argp->fh);\r\nif (!p)\r\nreturn 0;\r\nargp->mask = ntohl(*p++);\r\nif (argp->mask & ~NFS_ACL_MASK ||\r\n!xdr_argsize_check(rqstp, p))\r\nreturn 0;\r\nbase = (char *)p - (char *)head->iov_base;\r\nn = nfsacl_decode(&rqstp->rq_arg, base, NULL,\r\n(argp->mask & NFS_ACL) ?\r\n&argp->acl_access : NULL);\r\nif (n > 0)\r\nn = nfsacl_decode(&rqstp->rq_arg, base + n, NULL,\r\n(argp->mask & NFS_DFACL) ?\r\n&argp->acl_default : NULL);\r\nreturn (n > 0);\r\n}\r\nstatic int nfsaclsvc_decode_fhandleargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_fhandle *argp)\r\n{\r\np = nfs2svc_decode_fh(p, &argp->fh);\r\nif (!p)\r\nreturn 0;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_accessargs *argp)\r\n{\r\np = nfs2svc_decode_fh(p, &argp->fh);\r\nif (!p)\r\nreturn 0;\r\nargp->access = ntohl(*p++);\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\r\n{\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_encode_getaclres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclres *resp)\r\n{\r\nstruct dentry *dentry = resp->fh.fh_dentry;\r\nstruct inode *inode;\r\nstruct kvec *head = rqstp->rq_res.head;\r\nunsigned int base;\r\nint n;\r\nint w;\r\nif (dentry == NULL || d_really_is_negative(dentry))\r\nreturn 0;\r\ninode = d_inode(dentry);\r\np = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);\r\n*p++ = htonl(resp->mask);\r\nif (!xdr_ressize_check(rqstp, p))\r\nreturn 0;\r\nbase = (char *)p - (char *)head->iov_base;\r\nrqstp->rq_res.page_len = w = nfsacl_size(\r\n(resp->mask & NFS_ACL) ? resp->acl_access : NULL,\r\n(resp->mask & NFS_DFACL) ? resp->acl_default : NULL);\r\nwhile (w > 0) {\r\nif (!*(rqstp->rq_next_page++))\r\nreturn 0;\r\nw -= PAGE_SIZE;\r\n}\r\nn = nfsacl_encode(&rqstp->rq_res, base, inode,\r\nresp->acl_access,\r\nresp->mask & NFS_ACL, 0);\r\nif (n > 0)\r\nn = nfsacl_encode(&rqstp->rq_res, base + n, inode,\r\nresp->acl_default,\r\nresp->mask & NFS_DFACL,\r\nNFS_ACL_DEFAULT);\r\nreturn (n > 0);\r\n}\r\nstatic int nfsaclsvc_encode_attrstatres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_attrstat *resp)\r\n{\r\np = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_encode_accessres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_accessres *resp)\r\n{\r\np = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);\r\n*p++ = htonl(resp->access);\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_release_getacl(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclres *resp)\r\n{\r\nfh_put(&resp->fh);\r\nposix_acl_release(resp->acl_access);\r\nposix_acl_release(resp->acl_default);\r\nreturn 1;\r\n}\r\nstatic int nfsaclsvc_release_attrstat(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_attrstat *resp)\r\n{\r\nfh_put(&resp->fh);\r\nreturn 1;\r\n}\r\nstatic int nfsaclsvc_release_access(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_accessres *resp)\r\n{\r\nfh_put(&resp->fh);\r\nreturn 1;\r\n}
