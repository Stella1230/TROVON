static int dwmac4_wrback_get_tx_status(void *data, struct stmmac_extra_stats *x,\r\nstruct dma_desc *p,\r\nvoid __iomem *ioaddr)\r\n{\r\nstruct net_device_stats *stats = (struct net_device_stats *)data;\r\nunsigned int tdes3;\r\nint ret = tx_done;\r\ntdes3 = p->des3;\r\nif (unlikely(tdes3 & TDES3_OWN))\r\nreturn tx_dma_own;\r\nif (likely(!(tdes3 & TDES3_LAST_DESCRIPTOR)))\r\nreturn tx_not_ls;\r\nif (unlikely(tdes3 & TDES3_ERROR_SUMMARY)) {\r\nif (unlikely(tdes3 & TDES3_JABBER_TIMEOUT))\r\nx->tx_jabber++;\r\nif (unlikely(tdes3 & TDES3_PACKET_FLUSHED))\r\nx->tx_frame_flushed++;\r\nif (unlikely(tdes3 & TDES3_LOSS_CARRIER)) {\r\nx->tx_losscarrier++;\r\nstats->tx_carrier_errors++;\r\n}\r\nif (unlikely(tdes3 & TDES3_NO_CARRIER)) {\r\nx->tx_carrier++;\r\nstats->tx_carrier_errors++;\r\n}\r\nif (unlikely((tdes3 & TDES3_LATE_COLLISION) ||\r\n(tdes3 & TDES3_EXCESSIVE_COLLISION)))\r\nstats->collisions +=\r\n(tdes3 & TDES3_COLLISION_COUNT_MASK)\r\n>> TDES3_COLLISION_COUNT_SHIFT;\r\nif (unlikely(tdes3 & TDES3_EXCESSIVE_DEFERRAL))\r\nx->tx_deferred++;\r\nif (unlikely(tdes3 & TDES3_UNDERFLOW_ERROR))\r\nx->tx_underflow++;\r\nif (unlikely(tdes3 & TDES3_IP_HDR_ERROR))\r\nx->tx_ip_header_error++;\r\nif (unlikely(tdes3 & TDES3_PAYLOAD_ERROR))\r\nx->tx_payload_error++;\r\nret = tx_err;\r\n}\r\nif (unlikely(tdes3 & TDES3_DEFERRED))\r\nx->tx_deferred++;\r\nreturn ret;\r\n}\r\nstatic int dwmac4_wrback_get_rx_status(void *data, struct stmmac_extra_stats *x,\r\nstruct dma_desc *p)\r\n{\r\nstruct net_device_stats *stats = (struct net_device_stats *)data;\r\nunsigned int rdes1 = p->des1;\r\nunsigned int rdes2 = p->des2;\r\nunsigned int rdes3 = p->des3;\r\nint message_type;\r\nint ret = good_frame;\r\nif (unlikely(rdes3 & RDES3_OWN))\r\nreturn dma_own;\r\nif (likely(!(rdes3 & RDES3_LAST_DESCRIPTOR)))\r\nreturn discard_frame;\r\nif (unlikely(rdes3 & RDES3_ERROR_SUMMARY)) {\r\nif (unlikely(rdes3 & RDES3_GIANT_PACKET))\r\nstats->rx_length_errors++;\r\nif (unlikely(rdes3 & RDES3_OVERFLOW_ERROR))\r\nx->rx_gmac_overflow++;\r\nif (unlikely(rdes3 & RDES3_RECEIVE_WATCHDOG))\r\nx->rx_watchdog++;\r\nif (unlikely(rdes3 & RDES3_RECEIVE_ERROR))\r\nx->rx_mii++;\r\nif (unlikely(rdes3 & RDES3_CRC_ERROR)) {\r\nx->rx_crc++;\r\nstats->rx_crc_errors++;\r\n}\r\nif (unlikely(rdes3 & RDES3_DRIBBLE_ERROR))\r\nx->dribbling_bit++;\r\nret = discard_frame;\r\n}\r\nmessage_type = (rdes1 & ERDES4_MSG_TYPE_MASK) >> 8;\r\nif (rdes1 & RDES1_IP_HDR_ERROR)\r\nx->ip_hdr_err++;\r\nif (rdes1 & RDES1_IP_CSUM_BYPASSED)\r\nx->ip_csum_bypassed++;\r\nif (rdes1 & RDES1_IPV4_HEADER)\r\nx->ipv4_pkt_rcvd++;\r\nif (rdes1 & RDES1_IPV6_HEADER)\r\nx->ipv6_pkt_rcvd++;\r\nif (message_type == RDES_EXT_SYNC)\r\nx->rx_msg_type_sync++;\r\nelse if (message_type == RDES_EXT_FOLLOW_UP)\r\nx->rx_msg_type_follow_up++;\r\nelse if (message_type == RDES_EXT_DELAY_REQ)\r\nx->rx_msg_type_delay_req++;\r\nelse if (message_type == RDES_EXT_DELAY_RESP)\r\nx->rx_msg_type_delay_resp++;\r\nelse if (message_type == RDES_EXT_PDELAY_REQ)\r\nx->rx_msg_type_pdelay_req++;\r\nelse if (message_type == RDES_EXT_PDELAY_RESP)\r\nx->rx_msg_type_pdelay_resp++;\r\nelse if (message_type == RDES_EXT_PDELAY_FOLLOW_UP)\r\nx->rx_msg_type_pdelay_follow_up++;\r\nelse\r\nx->rx_msg_type_ext_no_ptp++;\r\nif (rdes1 & RDES1_PTP_PACKET_TYPE)\r\nx->ptp_frame_type++;\r\nif (rdes1 & RDES1_PTP_VER)\r\nx->ptp_ver++;\r\nif (rdes1 & RDES1_TIMESTAMP_DROPPED)\r\nx->timestamp_dropped++;\r\nif (unlikely(rdes2 & RDES2_SA_FILTER_FAIL)) {\r\nx->sa_rx_filter_fail++;\r\nret = discard_frame;\r\n}\r\nif (unlikely(rdes2 & RDES2_DA_FILTER_FAIL)) {\r\nx->da_rx_filter_fail++;\r\nret = discard_frame;\r\n}\r\nif (rdes2 & RDES2_L3_FILTER_MATCH)\r\nx->l3_filter_match++;\r\nif (rdes2 & RDES2_L4_FILTER_MATCH)\r\nx->l4_filter_match++;\r\nif ((rdes2 & RDES2_L3_L4_FILT_NB_MATCH_MASK)\r\n>> RDES2_L3_L4_FILT_NB_MATCH_SHIFT)\r\nx->l3_l4_filter_no_match++;\r\nreturn ret;\r\n}\r\nstatic int dwmac4_rd_get_tx_len(struct dma_desc *p)\r\n{\r\nreturn (p->des2 & TDES2_BUFFER1_SIZE_MASK);\r\n}\r\nstatic int dwmac4_get_tx_owner(struct dma_desc *p)\r\n{\r\nreturn (p->des3 & TDES3_OWN) >> TDES3_OWN_SHIFT;\r\n}\r\nstatic void dwmac4_set_tx_owner(struct dma_desc *p)\r\n{\r\np->des3 |= TDES3_OWN;\r\n}\r\nstatic void dwmac4_set_rx_owner(struct dma_desc *p)\r\n{\r\np->des3 |= RDES3_OWN;\r\n}\r\nstatic int dwmac4_get_tx_ls(struct dma_desc *p)\r\n{\r\nreturn (p->des3 & TDES3_LAST_DESCRIPTOR) >> TDES3_LAST_DESCRIPTOR_SHIFT;\r\n}\r\nstatic int dwmac4_wrback_get_rx_frame_len(struct dma_desc *p, int rx_coe)\r\n{\r\nreturn (p->des3 & RDES3_PACKET_SIZE_MASK);\r\n}\r\nstatic void dwmac4_rd_enable_tx_timestamp(struct dma_desc *p)\r\n{\r\np->des2 |= TDES2_TIMESTAMP_ENABLE;\r\n}\r\nstatic int dwmac4_wrback_get_tx_timestamp_status(struct dma_desc *p)\r\n{\r\nreturn (p->des3 & TDES3_TIMESTAMP_STATUS)\r\n>> TDES3_TIMESTAMP_STATUS_SHIFT;\r\n}\r\nstatic u64 dwmac4_wrback_get_timestamp(void *desc, u32 ats)\r\n{\r\nstruct dma_desc *p = (struct dma_desc *)desc;\r\nu64 ns;\r\nns = p->des0;\r\nns += p->des1 * 1000000000ULL;\r\nreturn ns;\r\n}\r\nstatic int dwmac4_context_get_rx_timestamp_status(void *desc, u32 ats)\r\n{\r\nstruct dma_desc *p = (struct dma_desc *)desc;\r\nreturn (p->des1 & RDES1_TIMESTAMP_AVAILABLE)\r\n>> RDES1_TIMESTAMP_AVAILABLE_SHIFT;\r\n}\r\nstatic void dwmac4_rd_init_rx_desc(struct dma_desc *p, int disable_rx_ic,\r\nint mode, int end)\r\n{\r\np->des3 = RDES3_OWN | RDES3_BUFFER1_VALID_ADDR;\r\nif (!disable_rx_ic)\r\np->des3 |= RDES3_INT_ON_COMPLETION_EN;\r\n}\r\nstatic void dwmac4_rd_init_tx_desc(struct dma_desc *p, int mode, int end)\r\n{\r\np->des0 = 0;\r\np->des1 = 0;\r\np->des2 = 0;\r\np->des3 = 0;\r\n}\r\nstatic void dwmac4_rd_prepare_tx_desc(struct dma_desc *p, int is_fs, int len,\r\nbool csum_flag, int mode, bool tx_own,\r\nbool ls)\r\n{\r\nunsigned int tdes3 = p->des3;\r\np->des2 |= (len & TDES2_BUFFER1_SIZE_MASK);\r\nif (is_fs)\r\ntdes3 |= TDES3_FIRST_DESCRIPTOR;\r\nelse\r\ntdes3 &= ~TDES3_FIRST_DESCRIPTOR;\r\nif (likely(csum_flag))\r\ntdes3 |= (TX_CIC_FULL << TDES3_CHECKSUM_INSERTION_SHIFT);\r\nelse\r\ntdes3 &= ~(TX_CIC_FULL << TDES3_CHECKSUM_INSERTION_SHIFT);\r\nif (ls)\r\ntdes3 |= TDES3_LAST_DESCRIPTOR;\r\nelse\r\ntdes3 &= ~TDES3_LAST_DESCRIPTOR;\r\nif (tx_own)\r\ntdes3 |= TDES3_OWN;\r\nif (is_fs & tx_own)\r\nwmb();\r\np->des3 = tdes3;\r\n}\r\nstatic void dwmac4_rd_prepare_tso_tx_desc(struct dma_desc *p, int is_fs,\r\nint len1, int len2, bool tx_own,\r\nbool ls, unsigned int tcphdrlen,\r\nunsigned int tcppayloadlen)\r\n{\r\nunsigned int tdes3 = p->des3;\r\nif (len1)\r\np->des2 |= (len1 & TDES2_BUFFER1_SIZE_MASK);\r\nif (len2)\r\np->des2 |= (len2 << TDES2_BUFFER2_SIZE_MASK_SHIFT)\r\n& TDES2_BUFFER2_SIZE_MASK;\r\nif (is_fs) {\r\ntdes3 |= TDES3_FIRST_DESCRIPTOR |\r\nTDES3_TCP_SEGMENTATION_ENABLE |\r\n((tcphdrlen << TDES3_HDR_LEN_SHIFT) &\r\nTDES3_SLOT_NUMBER_MASK) |\r\n((tcppayloadlen & TDES3_TCP_PKT_PAYLOAD_MASK));\r\n} else {\r\ntdes3 &= ~TDES3_FIRST_DESCRIPTOR;\r\n}\r\nif (ls)\r\ntdes3 |= TDES3_LAST_DESCRIPTOR;\r\nelse\r\ntdes3 &= ~TDES3_LAST_DESCRIPTOR;\r\nif (tx_own)\r\ntdes3 |= TDES3_OWN;\r\nif (is_fs & tx_own)\r\nwmb();\r\np->des3 = tdes3;\r\n}\r\nstatic void dwmac4_release_tx_desc(struct dma_desc *p, int mode)\r\n{\r\np->des2 = 0;\r\np->des3 = 0;\r\n}\r\nstatic void dwmac4_rd_set_tx_ic(struct dma_desc *p)\r\n{\r\np->des2 |= TDES2_INTERRUPT_ON_COMPLETION;\r\n}\r\nstatic void dwmac4_display_ring(void *head, unsigned int size, bool rx)\r\n{\r\nstruct dma_desc *p = (struct dma_desc *)head;\r\nint i;\r\npr_info("%s descriptor ring:\n", rx ? "RX" : "TX");\r\nfor (i = 0; i < size; i++) {\r\nif (p->des0)\r\npr_info("%d [0x%x]: 0x%x 0x%x 0x%x 0x%x\n",\r\ni, (unsigned int)virt_to_phys(p),\r\np->des0, p->des1, p->des2, p->des3);\r\np++;\r\n}\r\n}\r\nstatic void dwmac4_set_mss_ctxt(struct dma_desc *p, unsigned int mss)\r\n{\r\np->des0 = 0;\r\np->des1 = 0;\r\np->des2 = mss;\r\np->des3 = TDES3_CONTEXT_TYPE | TDES3_CTXT_TCMSSV;\r\n}
