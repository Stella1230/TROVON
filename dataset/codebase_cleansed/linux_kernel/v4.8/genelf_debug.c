static void\r\nbuffer_ext_dump(struct buffer_ext *be, const char *msg)\r\n{\r\nsize_t i;\r\nwarnx("DUMP for %s", msg);\r\nfor (i = 0 ; i < be->cur_pos; i++)\r\nwarnx("%4zu 0x%02x", i, (((char *)be->data)[i]) & 0xff);\r\n}\r\nstatic inline int\r\nbuffer_ext_add(struct buffer_ext *be, void *addr, size_t sz)\r\n{\r\nvoid *tmp;\r\nsize_t be_sz = be->max_sz;\r\nretry:\r\nif ((be->cur_pos + sz) < be_sz) {\r\nmemcpy(be->data + be->cur_pos, addr, sz);\r\nbe->cur_pos += sz;\r\nreturn 0;\r\n}\r\nif (!be_sz)\r\nbe_sz = BUFFER_EXT_DFL_SIZE;\r\nelse\r\nbe_sz <<= 1;\r\ntmp = realloc(be->data, be_sz);\r\nif (!tmp)\r\nreturn -1;\r\nbe->data = tmp;\r\nbe->max_sz = be_sz;\r\ngoto retry;\r\n}\r\nstatic void\r\nbuffer_ext_init(struct buffer_ext *be)\r\n{\r\nbe->data = NULL;\r\nbe->cur_pos = 0;\r\nbe->max_sz = 0;\r\n}\r\nstatic inline size_t\r\nbuffer_ext_size(struct buffer_ext *be)\r\n{\r\nreturn be->cur_pos;\r\n}\r\nstatic inline void *\r\nbuffer_ext_addr(struct buffer_ext *be)\r\n{\r\nreturn be->data;\r\n}\r\nstatic void emit_uword(struct buffer_ext *be, uword data)\r\n{\r\nbuffer_ext_add(be, &data, sizeof(uword));\r\n}\r\nstatic void emit_string(struct buffer_ext *be, const char *s)\r\n{\r\nbuffer_ext_add(be, (void *)s, strlen(s) + 1);\r\n}\r\nstatic void emit_unsigned_LEB128(struct buffer_ext *be,\r\nunsigned long data)\r\n{\r\ndo {\r\nubyte cur = data & 0x7F;\r\ndata >>= 7;\r\nif (data)\r\ncur |= 0x80;\r\nbuffer_ext_add(be, &cur, 1);\r\n} while (data);\r\n}\r\nstatic void emit_signed_LEB128(struct buffer_ext *be, long data)\r\n{\r\nint more = 1;\r\nint negative = data < 0;\r\nint size = sizeof(long) * CHAR_BIT;\r\nwhile (more) {\r\nubyte cur = data & 0x7F;\r\ndata >>= 7;\r\nif (negative)\r\ndata |= - (1 << (size - 7));\r\nif ((data == 0 && !(cur & 0x40)) ||\r\n(data == -1l && (cur & 0x40)))\r\nmore = 0;\r\nelse\r\ncur |= 0x80;\r\nbuffer_ext_add(be, &cur, 1);\r\n}\r\n}\r\nstatic void emit_extended_opcode(struct buffer_ext *be, ubyte opcode,\r\nvoid *data, size_t data_len)\r\n{\r\nbuffer_ext_add(be, (char *)"", 1);\r\nemit_unsigned_LEB128(be, data_len + 1);\r\nbuffer_ext_add(be, &opcode, 1);\r\nbuffer_ext_add(be, data, data_len);\r\n}\r\nstatic void emit_opcode(struct buffer_ext *be, ubyte opcode)\r\n{\r\nbuffer_ext_add(be, &opcode, 1);\r\n}\r\nstatic void emit_opcode_signed(struct buffer_ext *be,\r\nubyte opcode, long data)\r\n{\r\nbuffer_ext_add(be, &opcode, 1);\r\nemit_signed_LEB128(be, data);\r\n}\r\nstatic void emit_opcode_unsigned(struct buffer_ext *be, ubyte opcode,\r\nunsigned long data)\r\n{\r\nbuffer_ext_add(be, &opcode, 1);\r\nemit_unsigned_LEB128(be, data);\r\n}\r\nstatic void emit_advance_pc(struct buffer_ext *be, unsigned long delta_pc)\r\n{\r\nemit_opcode_unsigned(be, DW_LNS_advance_pc, delta_pc);\r\n}\r\nstatic void emit_advance_lineno(struct buffer_ext *be, long delta_lineno)\r\n{\r\nemit_opcode_signed(be, DW_LNS_advance_line, delta_lineno);\r\n}\r\nstatic void emit_lne_end_of_sequence(struct buffer_ext *be)\r\n{\r\nemit_extended_opcode(be, DW_LNE_end_sequence, NULL, 0);\r\n}\r\nstatic void emit_set_file(struct buffer_ext *be, unsigned long idx)\r\n{\r\nemit_opcode_unsigned(be, DW_LNS_set_file, idx);\r\n}\r\nstatic void emit_lne_define_filename(struct buffer_ext *be,\r\nconst char *filename)\r\n{\r\nbuffer_ext_add(be, (void *)"", 1);\r\nemit_unsigned_LEB128(be, strlen(filename) + 5);\r\nemit_opcode(be, DW_LNE_define_file);\r\nemit_string(be, filename);\r\nemit_unsigned_LEB128(be, 0);\r\nemit_unsigned_LEB128(be, 0);\r\nemit_unsigned_LEB128(be, 0);\r\n}\r\nstatic void emit_lne_set_address(struct buffer_ext *be,\r\nvoid *address)\r\n{\r\nemit_extended_opcode(be, DW_LNE_set_address, &address, sizeof(unsigned long));\r\n}\r\nstatic ubyte get_special_opcode(struct debug_entry *ent,\r\nunsigned int last_line,\r\nunsigned long last_vma)\r\n{\r\nunsigned int temp;\r\nunsigned long delta_addr;\r\ntemp = (ent->lineno - last_line) - default_debug_line_header.line_base;\r\nif (temp >= default_debug_line_header.line_range)\r\nreturn 0;\r\ndelta_addr = (ent->addr - last_vma) / default_debug_line_header.minimum_instruction_length;\r\nif (delta_addr <= 256 / default_debug_line_header.line_range) {\r\nunsigned long opcode = temp +\r\n(delta_addr * default_debug_line_header.line_range) +\r\ndefault_debug_line_header.opcode_base;\r\nreturn opcode <= 255 ? opcode : 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void emit_lineno_info(struct buffer_ext *be,\r\nstruct debug_entry *ent, size_t nr_entry,\r\nunsigned long code_addr)\r\n{\r\nsize_t i;\r\nunsigned long last_vma = code_addr;\r\nchar const *cur_filename = NULL;\r\nunsigned long cur_file_idx = 0;\r\nint last_line = 1;\r\nemit_lne_set_address(be, (void *)code_addr);\r\nfor (i = 0; i < nr_entry; i++, ent = debug_entry_next(ent)) {\r\nint need_copy = 0;\r\nubyte special_opcode;\r\nif (!cur_filename || strcmp(cur_filename, ent->name)) {\r\nemit_lne_define_filename(be, ent->name);\r\ncur_filename = ent->name;\r\nemit_set_file(be, ++cur_file_idx);\r\nneed_copy = 1;\r\n}\r\nspecial_opcode = get_special_opcode(ent, last_line, last_vma);\r\nif (special_opcode != 0) {\r\nlast_line = ent->lineno;\r\nlast_vma = ent->addr;\r\nemit_opcode(be, special_opcode);\r\n} else {\r\nif (last_line != ent->lineno) {\r\nemit_advance_lineno(be, ent->lineno - last_line);\r\nlast_line = ent->lineno;\r\nneed_copy = 1;\r\n}\r\nif (last_vma != ent->addr) {\r\nemit_advance_pc(be, ent->addr - last_vma);\r\nlast_vma = ent->addr;\r\nneed_copy = 1;\r\n}\r\nif (need_copy)\r\nemit_opcode(be, DW_LNS_copy);\r\n}\r\n}\r\n}\r\nstatic void add_debug_line(struct buffer_ext *be,\r\nstruct debug_entry *ent, size_t nr_entry,\r\nunsigned long code_addr)\r\n{\r\nstruct debug_line_header * dbg_header;\r\nsize_t old_size;\r\nold_size = buffer_ext_size(be);\r\nbuffer_ext_add(be, (void *)&default_debug_line_header,\r\nsizeof(default_debug_line_header));\r\nbuffer_ext_add(be, &standard_opcode_length, sizeof(standard_opcode_length));\r\nbuffer_ext_add(be, (void *)"", 1);\r\nbuffer_ext_add(be, (void *)"", 1);\r\ndbg_header = buffer_ext_addr(be) + old_size;\r\ndbg_header->prolog_length = (buffer_ext_size(be) - old_size) -\r\noffsetof(struct debug_line_header, minimum_instruction_length);\r\nemit_lineno_info(be, ent, nr_entry, code_addr);\r\nemit_lne_end_of_sequence(be);\r\ndbg_header = buffer_ext_addr(be) + old_size;\r\ndbg_header->total_length = (buffer_ext_size(be) - old_size) -\r\noffsetof(struct debug_line_header, version);\r\n}\r\nstatic void\r\nadd_debug_abbrev(struct buffer_ext *be)\r\n{\r\nemit_unsigned_LEB128(be, 1);\r\nemit_unsigned_LEB128(be, DW_TAG_compile_unit);\r\nemit_unsigned_LEB128(be, DW_CHILDREN_yes);\r\nemit_unsigned_LEB128(be, DW_AT_stmt_list);\r\nemit_unsigned_LEB128(be, DW_FORM_data4);\r\nemit_unsigned_LEB128(be, 0);\r\nemit_unsigned_LEB128(be, 0);\r\nemit_unsigned_LEB128(be, 0);\r\n}\r\nstatic void\r\nadd_compilation_unit(struct buffer_ext *be,\r\nsize_t offset_debug_line)\r\n{\r\nstruct compilation_unit_header *comp_unit_header;\r\nsize_t old_size = buffer_ext_size(be);\r\nbuffer_ext_add(be, &default_comp_unit_header,\r\nsizeof(default_comp_unit_header));\r\nemit_unsigned_LEB128(be, 1);\r\nemit_uword(be, offset_debug_line);\r\ncomp_unit_header = buffer_ext_addr(be) + old_size;\r\ncomp_unit_header->total_length = (buffer_ext_size(be) - old_size) -\r\noffsetof(struct compilation_unit_header, version);\r\n}\r\nstatic int\r\njit_process_debug_info(uint64_t code_addr,\r\nvoid *debug, int nr_debug_entries,\r\nstruct buffer_ext *dl,\r\nstruct buffer_ext *da,\r\nstruct buffer_ext *di)\r\n{\r\nstruct debug_entry *ent = debug;\r\nint i;\r\nfor (i = 0; i < nr_debug_entries; i++) {\r\nent->addr = ent->addr - code_addr;\r\nent = debug_entry_next(ent);\r\n}\r\nadd_compilation_unit(di, buffer_ext_size(dl));\r\nadd_debug_line(dl, debug, nr_debug_entries, 0);\r\nadd_debug_abbrev(da);\r\nif (0) buffer_ext_dump(da, "abbrev");\r\nreturn 0;\r\n}\r\nint\r\njit_add_debug_info(Elf *e, uint64_t code_addr, void *debug, int nr_debug_entries)\r\n{\r\nElf_Data *d;\r\nElf_Scn *scn;\r\nElf_Shdr *shdr;\r\nstruct buffer_ext dl, di, da;\r\nint ret;\r\nbuffer_ext_init(&dl);\r\nbuffer_ext_init(&di);\r\nbuffer_ext_init(&da);\r\nret = jit_process_debug_info(code_addr, debug, nr_debug_entries, &dl, &da, &di);\r\nif (ret)\r\nreturn -1;\r\nscn = elf_newscn(e);\r\nif (!scn) {\r\nwarnx("cannot create section");\r\nreturn -1;\r\n}\r\nd = elf_newdata(scn);\r\nif (!d) {\r\nwarnx("cannot get new data");\r\nreturn -1;\r\n}\r\nd->d_align = 1;\r\nd->d_off = 0LL;\r\nd->d_buf = buffer_ext_addr(&dl);\r\nd->d_type = ELF_T_BYTE;\r\nd->d_size = buffer_ext_size(&dl);\r\nd->d_version = EV_CURRENT;\r\nshdr = elf_getshdr(scn);\r\nif (!shdr) {\r\nwarnx("cannot get section header");\r\nreturn -1;\r\n}\r\nshdr->sh_name = 52;\r\nshdr->sh_type = SHT_PROGBITS;\r\nshdr->sh_addr = 0;\r\nshdr->sh_flags = 0;\r\nshdr->sh_entsize = 0;\r\nscn = elf_newscn(e);\r\nif (!scn) {\r\nwarnx("cannot create section");\r\nreturn -1;\r\n}\r\nd = elf_newdata(scn);\r\nif (!d) {\r\nwarnx("cannot get new data");\r\nreturn -1;\r\n}\r\nd->d_align = 1;\r\nd->d_off = 0LL;\r\nd->d_buf = buffer_ext_addr(&di);\r\nd->d_type = ELF_T_BYTE;\r\nd->d_size = buffer_ext_size(&di);\r\nd->d_version = EV_CURRENT;\r\nshdr = elf_getshdr(scn);\r\nif (!shdr) {\r\nwarnx("cannot get section header");\r\nreturn -1;\r\n}\r\nshdr->sh_name = 64;\r\nshdr->sh_type = SHT_PROGBITS;\r\nshdr->sh_addr = 0;\r\nshdr->sh_flags = 0;\r\nshdr->sh_entsize = 0;\r\nscn = elf_newscn(e);\r\nif (!scn) {\r\nwarnx("cannot create section");\r\nreturn -1;\r\n}\r\nd = elf_newdata(scn);\r\nif (!d) {\r\nwarnx("cannot get new data");\r\nreturn -1;\r\n}\r\nd->d_align = 1;\r\nd->d_off = 0LL;\r\nd->d_buf = buffer_ext_addr(&da);\r\nd->d_type = ELF_T_BYTE;\r\nd->d_size = buffer_ext_size(&da);\r\nd->d_version = EV_CURRENT;\r\nshdr = elf_getshdr(scn);\r\nif (!shdr) {\r\nwarnx("cannot get section header");\r\nreturn -1;\r\n}\r\nshdr->sh_name = 76;\r\nshdr->sh_type = SHT_PROGBITS;\r\nshdr->sh_addr = 0;\r\nshdr->sh_flags = 0;\r\nshdr->sh_entsize = 0;\r\nif (elf_update(e, ELF_C_WRITE) < 0) {\r\nwarnx("elf_update debug failed");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}
