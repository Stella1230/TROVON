static void sirf_usp_tx_enable(struct sirf_usp *usp)\r\n{\r\nregmap_update_bits(usp->regmap, USP_TX_FIFO_OP,\r\nUSP_TX_FIFO_RESET, USP_TX_FIFO_RESET);\r\nregmap_write(usp->regmap, USP_TX_FIFO_OP, 0);\r\nregmap_update_bits(usp->regmap, USP_TX_FIFO_OP,\r\nUSP_TX_FIFO_START, USP_TX_FIFO_START);\r\nregmap_update_bits(usp->regmap, USP_TX_RX_ENABLE,\r\nUSP_TX_ENA, USP_TX_ENA);\r\n}\r\nstatic void sirf_usp_tx_disable(struct sirf_usp *usp)\r\n{\r\nregmap_update_bits(usp->regmap, USP_TX_RX_ENABLE,\r\nUSP_TX_ENA, ~USP_TX_ENA);\r\nregmap_write(usp->regmap, USP_TX_FIFO_OP, 0);\r\n}\r\nstatic void sirf_usp_rx_enable(struct sirf_usp *usp)\r\n{\r\nregmap_update_bits(usp->regmap, USP_RX_FIFO_OP,\r\nUSP_RX_FIFO_RESET, USP_RX_FIFO_RESET);\r\nregmap_write(usp->regmap, USP_RX_FIFO_OP, 0);\r\nregmap_update_bits(usp->regmap, USP_RX_FIFO_OP,\r\nUSP_RX_FIFO_START, USP_RX_FIFO_START);\r\nregmap_update_bits(usp->regmap, USP_TX_RX_ENABLE,\r\nUSP_RX_ENA, USP_RX_ENA);\r\n}\r\nstatic void sirf_usp_rx_disable(struct sirf_usp *usp)\r\n{\r\nregmap_update_bits(usp->regmap, USP_TX_RX_ENABLE,\r\nUSP_RX_ENA, ~USP_RX_ENA);\r\nregmap_write(usp->regmap, USP_RX_FIFO_OP, 0);\r\n}\r\nstatic int sirf_usp_pcm_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct sirf_usp *usp = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_init_dma_data(dai, &usp->playback_dma_data,\r\n&usp->capture_dma_data);\r\nreturn 0;\r\n}\r\nstatic int sirf_usp_pcm_set_dai_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct sirf_usp *usp = snd_soc_dai_get_drvdata(dai);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Only CBM and CFM supported\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nusp->daifmt_format = (fmt & SND_SOC_DAIFMT_FORMAT_MASK);\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Only I2S and DSP_A format supported\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nusp->daifmt_format |= (fmt & SND_SOC_DAIFMT_INV_MASK);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sirf_usp_i2s_init(struct sirf_usp *usp)\r\n{\r\nregmap_update_bits(usp->regmap, USP_RISC_DSP_MODE,\r\nUSP_RISC_DSP_SEL, ~USP_RISC_DSP_SEL);\r\nregmap_write(usp->regmap, USP_TX_DMA_IO_LEN, 0);\r\nregmap_write(usp->regmap, USP_RX_DMA_IO_LEN, 0);\r\nregmap_write(usp->regmap, USP_MODE2, (1 << USP_RXD_DELAY_LEN_OFFSET) |\r\n(0 << USP_TXD_DELAY_LEN_OFFSET) |\r\nUSP_TFS_CLK_SLAVE_MODE | USP_RFS_CLK_SLAVE_MODE);\r\nregmap_write(usp->regmap, USP_MODE1,\r\nUSP_SYNC_MODE | USP_EN | USP_TXD_ACT_EDGE_FALLING |\r\nUSP_RFS_ACT_LEVEL_LOGIC1 | USP_TFS_ACT_LEVEL_LOGIC1 |\r\nUSP_TX_UFLOW_REPEAT_ZERO | USP_CLOCK_MODE_SLAVE);\r\nregmap_write(usp->regmap, USP_RX_DMA_IO_CTRL, 0);\r\nregmap_write(usp->regmap, USP_RX_FIFO_CTRL,\r\n(USP_RX_FIFO_THRESHOLD << USP_RX_FIFO_THD_OFFSET) |\r\n(USP_TX_RX_FIFO_WIDTH_DWORD << USP_RX_FIFO_WIDTH_OFFSET));\r\nregmap_write(usp->regmap, USP_RX_FIFO_LEVEL_CHK,\r\nRX_FIFO_SC(0x04) | RX_FIFO_LC(0x0E) | RX_FIFO_HC(0x1B));\r\nregmap_write(usp->regmap, USP_TX_DMA_IO_CTRL, 0);\r\nregmap_write(usp->regmap, USP_TX_FIFO_CTRL,\r\n(USP_TX_FIFO_THRESHOLD << USP_TX_FIFO_THD_OFFSET) |\r\n(USP_TX_RX_FIFO_WIDTH_DWORD << USP_TX_FIFO_WIDTH_OFFSET));\r\nregmap_write(usp->regmap, USP_TX_FIFO_LEVEL_CHK,\r\nTX_FIFO_SC(0x1B) | TX_FIFO_LC(0x0E) | TX_FIFO_HC(0x04));\r\n}\r\nstatic int sirf_usp_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct sirf_usp *usp = snd_soc_dai_get_drvdata(dai);\r\nu32 data_len, frame_len, shifter_len;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ndata_len = 16;\r\nframe_len = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ndata_len = 24;\r\nframe_len = 32;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_3LE:\r\ndata_len = 24;\r\nframe_len = 24;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Format unsupported\n");\r\nreturn -EINVAL;\r\n}\r\nshifter_len = data_len;\r\nswitch (usp->daifmt_format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nregmap_update_bits(usp->regmap, USP_RX_FRAME_CTRL,\r\nUSP_I2S_SYNC_CHG, USP_I2S_SYNC_CHG);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nregmap_update_bits(usp->regmap, USP_RX_FRAME_CTRL,\r\nUSP_I2S_SYNC_CHG, 0);\r\nframe_len = data_len * params_channels(params);\r\ndata_len = frame_len;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Only support I2S and DSP_A mode\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (usp->daifmt_format & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nregmap_update_bits(usp->regmap, USP_MODE1,\r\nUSP_RXD_ACT_EDGE_FALLING | USP_TXD_ACT_EDGE_FALLING,\r\nUSP_RXD_ACT_EDGE_FALLING);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nregmap_update_bits(usp->regmap, USP_TX_FRAME_CTRL,\r\nUSP_TXC_DATA_LEN_MASK | USP_TXC_FRAME_LEN_MASK\r\n| USP_TXC_SHIFTER_LEN_MASK | USP_TXC_SLAVE_CLK_SAMPLE,\r\n((data_len - 1) << USP_TXC_DATA_LEN_OFFSET)\r\n| ((frame_len - 1) << USP_TXC_FRAME_LEN_OFFSET)\r\n| ((shifter_len - 1) << USP_TXC_SHIFTER_LEN_OFFSET)\r\n| USP_TXC_SLAVE_CLK_SAMPLE);\r\nelse\r\nregmap_update_bits(usp->regmap, USP_RX_FRAME_CTRL,\r\nUSP_RXC_DATA_LEN_MASK | USP_RXC_FRAME_LEN_MASK\r\n| USP_RXC_SHIFTER_LEN_MASK | USP_SINGLE_SYNC_MODE,\r\n((data_len - 1) << USP_RXC_DATA_LEN_OFFSET)\r\n| ((frame_len - 1) << USP_RXC_FRAME_LEN_OFFSET)\r\n| ((shifter_len - 1) << USP_RXC_SHIFTER_LEN_OFFSET)\r\n| USP_SINGLE_SYNC_MODE);\r\nreturn 0;\r\n}\r\nstatic int sirf_usp_pcm_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sirf_usp *usp = snd_soc_dai_get_drvdata(dai);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsirf_usp_tx_enable(usp);\r\nelse\r\nsirf_usp_rx_enable(usp);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsirf_usp_tx_disable(usp);\r\nelse\r\nsirf_usp_rx_disable(usp);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sirf_usp_pcm_runtime_suspend(struct device *dev)\r\n{\r\nstruct sirf_usp *usp = dev_get_drvdata(dev);\r\nclk_disable_unprepare(usp->clk);\r\nreturn 0;\r\n}\r\nstatic int sirf_usp_pcm_runtime_resume(struct device *dev)\r\n{\r\nstruct sirf_usp *usp = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(usp->clk);\r\nif (ret) {\r\ndev_err(dev, "clk_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nsirf_usp_i2s_init(usp);\r\nreturn 0;\r\n}\r\nstatic int sirf_usp_pcm_suspend(struct device *dev)\r\n{\r\nstruct sirf_usp *usp = dev_get_drvdata(dev);\r\nif (!pm_runtime_status_suspended(dev)) {\r\nregmap_read(usp->regmap, USP_MODE1, &usp->mode1_reg);\r\nregmap_read(usp->regmap, USP_MODE2, &usp->mode2_reg);\r\nsirf_usp_pcm_runtime_suspend(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sirf_usp_pcm_resume(struct device *dev)\r\n{\r\nstruct sirf_usp *usp = dev_get_drvdata(dev);\r\nint ret;\r\nif (!pm_runtime_status_suspended(dev)) {\r\nret = sirf_usp_pcm_runtime_resume(dev);\r\nif (ret)\r\nreturn ret;\r\nregmap_write(usp->regmap, USP_MODE1, usp->mode1_reg);\r\nregmap_write(usp->regmap, USP_MODE2, usp->mode2_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sirf_usp_pcm_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct sirf_usp *usp;\r\nvoid __iomem *base;\r\nstruct resource *mem_res;\r\nusp = devm_kzalloc(&pdev->dev, sizeof(struct sirf_usp),\r\nGFP_KERNEL);\r\nif (!usp)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, usp);\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap(&pdev->dev, mem_res->start,\r\nresource_size(mem_res));\r\nif (base == NULL)\r\nreturn -ENOMEM;\r\nusp->regmap = devm_regmap_init_mmio(&pdev->dev, base,\r\n&sirf_usp_regmap_config);\r\nif (IS_ERR(usp->regmap))\r\nreturn PTR_ERR(usp->regmap);\r\nusp->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(usp->clk)) {\r\ndev_err(&pdev->dev, "Get clock failed.\n");\r\nreturn PTR_ERR(usp->clk);\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = sirf_usp_pcm_runtime_resume(&pdev->dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = devm_snd_soc_register_component(&pdev->dev, &sirf_usp_component,\r\n&sirf_usp_pcm_dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Register Audio SoC dai failed.\n");\r\nreturn ret;\r\n}\r\nreturn devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\n}\r\nstatic int sirf_usp_pcm_remove(struct platform_device *pdev)\r\n{\r\nif (!pm_runtime_enabled(&pdev->dev))\r\nsirf_usp_pcm_runtime_suspend(&pdev->dev);\r\nelse\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
