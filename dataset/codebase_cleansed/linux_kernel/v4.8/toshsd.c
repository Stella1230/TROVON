static void toshsd_init(struct toshsd_host *host)\r\n{\r\npci_write_config_byte(host->pdev, SD_PCICFG_CLKSTOP,\r\nSD_PCICFG_CLKSTOP_ENABLE_ALL);\r\npci_write_config_byte(host->pdev, SD_PCICFG_CARDDETECT, 2);\r\niowrite16(0, host->ioaddr + SD_SOFTWARERESET);\r\nmdelay(2);\r\niowrite16(1, host->ioaddr + SD_SOFTWARERESET);\r\nmdelay(2);\r\niowrite16(0, host->ioaddr + SD_CARDCLOCKCTRL);\r\niowrite32(0, host->ioaddr + SD_CARDSTATUS);\r\niowrite32(0, host->ioaddr + SD_ERRORSTATUS0);\r\niowrite16(0, host->ioaddr + SD_STOPINTERNAL);\r\niowrite16(0x100, host->ioaddr + SDIO_BASE + SDIO_CLOCKNWAITCTRL);\r\npci_write_config_byte(host->pdev, SD_PCICFG_SDLED_ENABLE1,\r\nSD_PCICFG_LED_ENABLE1_START);\r\npci_write_config_byte(host->pdev, SD_PCICFG_SDLED_ENABLE2,\r\nSD_PCICFG_LED_ENABLE2_START);\r\niowrite32(~(u32)(SD_CARD_RESP_END | SD_CARD_RW_END\r\n| SD_CARD_CARD_REMOVED_0 | SD_CARD_CARD_INSERTED_0\r\n| SD_BUF_READ_ENABLE | SD_BUF_WRITE_ENABLE\r\n| SD_BUF_CMD_TIMEOUT),\r\nhost->ioaddr + SD_INTMASKCARD);\r\niowrite16(0x1000, host->ioaddr + SD_TRANSACTIONCTRL);\r\n}\r\nstatic void __toshsd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct toshsd_host *host = mmc_priv(mmc);\r\nif (ios->clock) {\r\nu16 clk;\r\nint div = 1;\r\nwhile (ios->clock < HCLK / div)\r\ndiv *= 2;\r\nclk = div >> 2;\r\nif (div == 1) {\r\npci_write_config_byte(host->pdev, SD_PCICFG_CLKMODE,\r\nSD_PCICFG_CLKMODE_DIV_DISABLE);\r\nclk |= SD_CARDCLK_DIV_DISABLE;\r\n} else\r\npci_write_config_byte(host->pdev, SD_PCICFG_CLKMODE, 0);\r\nclk |= SD_CARDCLK_ENABLE_CLOCK;\r\niowrite16(clk, host->ioaddr + SD_CARDCLOCKCTRL);\r\nmdelay(10);\r\n} else\r\niowrite16(0, host->ioaddr + SD_CARDCLOCKCTRL);\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\npci_write_config_byte(host->pdev, SD_PCICFG_POWER1,\r\nSD_PCICFG_PWR1_OFF);\r\nmdelay(1);\r\nbreak;\r\ncase MMC_POWER_UP:\r\nbreak;\r\ncase MMC_POWER_ON:\r\npci_write_config_byte(host->pdev, SD_PCICFG_POWER1,\r\nSD_PCICFG_PWR1_33V);\r\npci_write_config_byte(host->pdev, SD_PCICFG_POWER2,\r\nSD_PCICFG_PWR2_AUTO);\r\nmdelay(20);\r\nbreak;\r\n}\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_1:\r\niowrite16(SD_CARDOPT_REQUIRED | SD_CARDOPT_DATA_RESP_TIMEOUT(14)\r\n| SD_CARDOPT_C2_MODULE_ABSENT\r\n| SD_CARDOPT_DATA_XFR_WIDTH_1,\r\nhost->ioaddr + SD_CARDOPTIONSETUP);\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\niowrite16(SD_CARDOPT_REQUIRED | SD_CARDOPT_DATA_RESP_TIMEOUT(14)\r\n| SD_CARDOPT_C2_MODULE_ABSENT\r\n| SD_CARDOPT_DATA_XFR_WIDTH_4,\r\nhost->ioaddr + SD_CARDOPTIONSETUP);\r\nbreak;\r\n}\r\n}\r\nstatic void toshsd_set_led(struct toshsd_host *host, unsigned char state)\r\n{\r\niowrite16(state, host->ioaddr + SDIO_BASE + SDIO_LEDCTRL);\r\n}\r\nstatic void toshsd_finish_request(struct toshsd_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nhost->mrq = NULL;\r\nhost->cmd = NULL;\r\nhost->data = NULL;\r\ntoshsd_set_led(host, 0);\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic irqreturn_t toshsd_thread_irq(int irq, void *dev_id)\r\n{\r\nstruct toshsd_host *host = dev_id;\r\nstruct mmc_data *data = host->data;\r\nstruct sg_mapping_iter *sg_miter = &host->sg_miter;\r\nunsigned short *buf;\r\nint count;\r\nunsigned long flags;\r\nif (!data) {\r\ndev_warn(&host->pdev->dev, "Spurious Data IRQ\n");\r\nif (host->cmd) {\r\nhost->cmd->error = -EIO;\r\ntoshsd_finish_request(host);\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (!sg_miter_next(sg_miter))\r\ngoto done;\r\nbuf = sg_miter->addr;\r\ncount = sg_miter->length;\r\nif (count > data->blksz)\r\ncount = data->blksz;\r\ndev_dbg(&host->pdev->dev, "count: %08x, flags %08x\n", count,\r\ndata->flags);\r\nif (data->flags & MMC_DATA_READ)\r\nioread32_rep(host->ioaddr + SD_DATAPORT, buf, count >> 2);\r\nelse\r\niowrite32_rep(host->ioaddr + SD_DATAPORT, buf, count >> 2);\r\nsg_miter->consumed = count;\r\nsg_miter_stop(sg_miter);\r\ndone:\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void toshsd_cmd_irq(struct toshsd_host *host)\r\n{\r\nstruct mmc_command *cmd = host->cmd;\r\nu8 *buf;\r\nu16 data;\r\nif (!host->cmd) {\r\ndev_warn(&host->pdev->dev, "Spurious CMD irq\n");\r\nreturn;\r\n}\r\nbuf = (u8 *)cmd->resp;\r\nhost->cmd = NULL;\r\nif (cmd->flags & MMC_RSP_PRESENT && cmd->flags & MMC_RSP_136) {\r\nbuf[12] = 0xff;\r\ndata = ioread16(host->ioaddr + SD_RESPONSE0);\r\nbuf[13] = data & 0xff;\r\nbuf[14] = data >> 8;\r\ndata = ioread16(host->ioaddr + SD_RESPONSE1);\r\nbuf[15] = data & 0xff;\r\nbuf[8] = data >> 8;\r\ndata = ioread16(host->ioaddr + SD_RESPONSE2);\r\nbuf[9] = data & 0xff;\r\nbuf[10] = data >> 8;\r\ndata = ioread16(host->ioaddr + SD_RESPONSE3);\r\nbuf[11] = data & 0xff;\r\nbuf[4] = data >> 8;\r\ndata = ioread16(host->ioaddr + SD_RESPONSE4);\r\nbuf[5] = data & 0xff;\r\nbuf[6] = data >> 8;\r\ndata = ioread16(host->ioaddr + SD_RESPONSE5);\r\nbuf[7] = data & 0xff;\r\nbuf[0] = data >> 8;\r\ndata = ioread16(host->ioaddr + SD_RESPONSE6);\r\nbuf[1] = data & 0xff;\r\nbuf[2] = data >> 8;\r\ndata = ioread16(host->ioaddr + SD_RESPONSE7);\r\nbuf[3] = data & 0xff;\r\n} else if (cmd->flags & MMC_RSP_PRESENT) {\r\ndata = ioread16(host->ioaddr + SD_RESPONSE0);\r\nbuf[0] = data & 0xff;\r\nbuf[1] = data >> 8;\r\ndata = ioread16(host->ioaddr + SD_RESPONSE1);\r\nbuf[2] = data & 0xff;\r\nbuf[3] = data >> 8;\r\n}\r\ndev_dbg(&host->pdev->dev, "Command IRQ complete %d %d %x\n",\r\ncmd->opcode, cmd->error, cmd->flags);\r\nif (host->data)\r\nreturn;\r\ntoshsd_finish_request(host);\r\n}\r\nstatic void toshsd_data_end_irq(struct toshsd_host *host)\r\n{\r\nstruct mmc_data *data = host->data;\r\nhost->data = NULL;\r\nif (!data) {\r\ndev_warn(&host->pdev->dev, "Spurious data end IRQ\n");\r\nreturn;\r\n}\r\nif (data->error == 0)\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\nelse\r\ndata->bytes_xfered = 0;\r\ndev_dbg(&host->pdev->dev, "Completed data request xfr=%d\n",\r\ndata->bytes_xfered);\r\niowrite16(0, host->ioaddr + SD_STOPINTERNAL);\r\ntoshsd_finish_request(host);\r\n}\r\nstatic irqreturn_t toshsd_irq(int irq, void *dev_id)\r\n{\r\nstruct toshsd_host *host = dev_id;\r\nu32 int_reg, int_mask, int_status, detail;\r\nint error = 0, ret = IRQ_HANDLED;\r\nspin_lock(&host->lock);\r\nint_status = ioread32(host->ioaddr + SD_CARDSTATUS);\r\nint_mask = ioread32(host->ioaddr + SD_INTMASKCARD);\r\nint_reg = int_status & ~int_mask & ~IRQ_DONT_CARE_BITS;\r\ndev_dbg(&host->pdev->dev, "IRQ status:%x mask:%x\n",\r\nint_status, int_mask);\r\nif (!int_reg) {\r\nret = IRQ_NONE;\r\ngoto irq_end;\r\n}\r\nif (int_reg & SD_BUF_CMD_TIMEOUT) {\r\nerror = -ETIMEDOUT;\r\ndev_dbg(&host->pdev->dev, "Timeout\n");\r\n} else if (int_reg & SD_BUF_CRC_ERR) {\r\nerror = -EILSEQ;\r\ndev_err(&host->pdev->dev, "BadCRC\n");\r\n} else if (int_reg & (SD_BUF_ILLEGAL_ACCESS\r\n| SD_BUF_CMD_INDEX_ERR\r\n| SD_BUF_STOP_BIT_END_ERR\r\n| SD_BUF_OVERFLOW\r\n| SD_BUF_UNDERFLOW\r\n| SD_BUF_DATA_TIMEOUT)) {\r\ndev_err(&host->pdev->dev, "Buffer status error: { %s%s%s%s%s%s}\n",\r\nint_reg & SD_BUF_ILLEGAL_ACCESS ? "ILLEGAL_ACC " : "",\r\nint_reg & SD_BUF_CMD_INDEX_ERR ? "CMD_INDEX " : "",\r\nint_reg & SD_BUF_STOP_BIT_END_ERR ? "STOPBIT_END " : "",\r\nint_reg & SD_BUF_OVERFLOW ? "OVERFLOW " : "",\r\nint_reg & SD_BUF_UNDERFLOW ? "UNDERFLOW " : "",\r\nint_reg & SD_BUF_DATA_TIMEOUT ? "DATA_TIMEOUT " : "");\r\ndetail = ioread32(host->ioaddr + SD_ERRORSTATUS0);\r\ndev_err(&host->pdev->dev, "detail error status { %s%s%s%s%s%s%s%s%s%s%s%s%s}\n",\r\ndetail & SD_ERR0_RESP_CMD_ERR ? "RESP_CMD " : "",\r\ndetail & SD_ERR0_RESP_NON_CMD12_END_BIT_ERR ? "RESP_END_BIT " : "",\r\ndetail & SD_ERR0_RESP_CMD12_END_BIT_ERR ? "RESP_END_BIT " : "",\r\ndetail & SD_ERR0_READ_DATA_END_BIT_ERR ? "READ_DATA_END_BIT " : "",\r\ndetail & SD_ERR0_WRITE_CRC_STATUS_END_BIT_ERR ? "WRITE_CMD_END_BIT " : "",\r\ndetail & SD_ERR0_RESP_NON_CMD12_CRC_ERR ? "RESP_CRC " : "",\r\ndetail & SD_ERR0_RESP_CMD12_CRC_ERR ? "RESP_CRC " : "",\r\ndetail & SD_ERR0_READ_DATA_CRC_ERR ? "READ_DATA_CRC " : "",\r\ndetail & SD_ERR0_WRITE_CMD_CRC_ERR ? "WRITE_CMD_CRC " : "",\r\ndetail & SD_ERR1_NO_CMD_RESP ? "NO_CMD_RESP " : "",\r\ndetail & SD_ERR1_TIMEOUT_READ_DATA ? "READ_DATA_TIMEOUT " : "",\r\ndetail & SD_ERR1_TIMEOUT_CRS_STATUS ? "CRS_STATUS_TIMEOUT " : "",\r\ndetail & SD_ERR1_TIMEOUT_CRC_BUSY ? "CRC_BUSY_TIMEOUT " : "");\r\nerror = -EIO;\r\n}\r\nif (error) {\r\nif (host->cmd)\r\nhost->cmd->error = error;\r\nif (error == -ETIMEDOUT) {\r\niowrite32(int_status &\r\n~(SD_BUF_CMD_TIMEOUT | SD_CARD_RESP_END),\r\nhost->ioaddr + SD_CARDSTATUS);\r\n} else {\r\ntoshsd_init(host);\r\n__toshsd_set_ios(host->mmc, &host->mmc->ios);\r\ngoto irq_end;\r\n}\r\n}\r\nif (int_reg & (SD_CARD_CARD_INSERTED_0 | SD_CARD_CARD_REMOVED_0)) {\r\niowrite32(int_status &\r\n~(SD_CARD_CARD_REMOVED_0 | SD_CARD_CARD_INSERTED_0),\r\nhost->ioaddr + SD_CARDSTATUS);\r\nif (int_reg & SD_CARD_CARD_INSERTED_0)\r\ntoshsd_init(host);\r\nmmc_detect_change(host->mmc, 1);\r\n}\r\nif (int_reg & (SD_BUF_READ_ENABLE | SD_BUF_WRITE_ENABLE)) {\r\niowrite32(int_status &\r\n~(SD_BUF_WRITE_ENABLE | SD_BUF_READ_ENABLE),\r\nhost->ioaddr + SD_CARDSTATUS);\r\nret = IRQ_WAKE_THREAD;\r\ngoto irq_end;\r\n}\r\nif (int_reg & SD_CARD_RESP_END) {\r\niowrite32(int_status & ~(SD_CARD_RESP_END),\r\nhost->ioaddr + SD_CARDSTATUS);\r\ntoshsd_cmd_irq(host);\r\n}\r\nif (int_reg & SD_CARD_RW_END) {\r\niowrite32(int_status & ~(SD_CARD_RW_END),\r\nhost->ioaddr + SD_CARDSTATUS);\r\ntoshsd_data_end_irq(host);\r\n}\r\nirq_end:\r\nspin_unlock(&host->lock);\r\nreturn ret;\r\n}\r\nstatic void toshsd_start_cmd(struct toshsd_host *host, struct mmc_command *cmd)\r\n{\r\nstruct mmc_data *data = host->data;\r\nint c = cmd->opcode;\r\ndev_dbg(&host->pdev->dev, "Command opcode: %d\n", cmd->opcode);\r\nif (cmd->opcode == MMC_STOP_TRANSMISSION) {\r\niowrite16(SD_STOPINT_ISSUE_CMD12,\r\nhost->ioaddr + SD_STOPINTERNAL);\r\ncmd->resp[0] = cmd->opcode;\r\ncmd->resp[1] = 0;\r\ncmd->resp[2] = 0;\r\ncmd->resp[3] = 0;\r\ntoshsd_finish_request(host);\r\nreturn;\r\n}\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_NONE:\r\nc |= SD_CMD_RESP_TYPE_NONE;\r\nbreak;\r\ncase MMC_RSP_R1:\r\nc |= SD_CMD_RESP_TYPE_EXT_R1;\r\nbreak;\r\ncase MMC_RSP_R1B:\r\nc |= SD_CMD_RESP_TYPE_EXT_R1B;\r\nbreak;\r\ncase MMC_RSP_R2:\r\nc |= SD_CMD_RESP_TYPE_EXT_R2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\nc |= SD_CMD_RESP_TYPE_EXT_R3;\r\nbreak;\r\ndefault:\r\ndev_err(&host->pdev->dev, "Unknown response type %d\n",\r\nmmc_resp_type(cmd));\r\nbreak;\r\n}\r\nhost->cmd = cmd;\r\nif (cmd->opcode == MMC_APP_CMD)\r\nc |= SD_CMD_TYPE_ACMD;\r\nif (cmd->opcode == MMC_GO_IDLE_STATE)\r\nc |= (3 << 8);\r\nif (data) {\r\nc |= SD_CMD_DATA_PRESENT;\r\nif (data->blocks > 1) {\r\niowrite16(SD_STOPINT_AUTO_ISSUE_CMD12,\r\nhost->ioaddr + SD_STOPINTERNAL);\r\nc |= SD_CMD_MULTI_BLOCK;\r\n}\r\nif (data->flags & MMC_DATA_READ)\r\nc |= SD_CMD_TRANSFER_READ;\r\n}\r\niowrite32(cmd->arg, host->ioaddr + SD_ARG0);\r\niowrite16(c, host->ioaddr + SD_CMD);\r\n}\r\nstatic void toshsd_start_data(struct toshsd_host *host, struct mmc_data *data)\r\n{\r\nunsigned int flags = SG_MITER_ATOMIC;\r\ndev_dbg(&host->pdev->dev, "setup data transfer: blocksize %08x nr_blocks %d, offset: %08x\n",\r\ndata->blksz, data->blocks, data->sg->offset);\r\nhost->data = data;\r\nif (data->flags & MMC_DATA_READ)\r\nflags |= SG_MITER_TO_SG;\r\nelse\r\nflags |= SG_MITER_FROM_SG;\r\nsg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);\r\niowrite16(data->blocks, host->ioaddr + SD_BLOCKCOUNT);\r\niowrite16(data->blksz, host->ioaddr + SD_CARDXFERDATALEN);\r\n}\r\nstatic void toshsd_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct toshsd_host *host = mmc_priv(mmc);\r\nunsigned long flags;\r\nif (!(ioread16(host->ioaddr + SD_CARDSTATUS) & SD_CARD_PRESENT_0)) {\r\nmrq->cmd->error = -ENOMEDIUM;\r\nmmc_request_done(mmc, mrq);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&host->lock, flags);\r\nWARN_ON(host->mrq != NULL);\r\nhost->mrq = mrq;\r\nif (mrq->data)\r\ntoshsd_start_data(host, mrq->data);\r\ntoshsd_set_led(host, 1);\r\ntoshsd_start_cmd(host, mrq->cmd);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void toshsd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct toshsd_host *host = mmc_priv(mmc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\n__toshsd_set_ios(mmc, ios);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic int toshsd_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct toshsd_host *host = mmc_priv(mmc);\r\nreturn !(ioread16(host->ioaddr + SD_CARDSTATUS) & SD_CARD_WRITE_PROTECT);\r\n}\r\nstatic int toshsd_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct toshsd_host *host = mmc_priv(mmc);\r\nreturn !!(ioread16(host->ioaddr + SD_CARDSTATUS) & SD_CARD_PRESENT_0);\r\n}\r\nstatic void toshsd_powerdown(struct toshsd_host *host)\r\n{\r\niowrite32(0xffffffff, host->ioaddr + SD_INTMASKCARD);\r\niowrite16(0x000, host->ioaddr + SDIO_BASE + SDIO_CLOCKNWAITCTRL);\r\niowrite16(0, host->ioaddr + SD_CARDCLOCKCTRL);\r\npci_write_config_byte(host->pdev, SD_PCICFG_POWER1, SD_PCICFG_PWR1_OFF);\r\npci_write_config_byte(host->pdev, SD_PCICFG_CLKSTOP, 0);\r\n}\r\nstatic int toshsd_pm_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct toshsd_host *host = pci_get_drvdata(pdev);\r\ntoshsd_powerdown(host);\r\npci_save_state(pdev);\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int toshsd_pm_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct toshsd_host *host = pci_get_drvdata(pdev);\r\nint ret;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\ntoshsd_init(host);\r\nreturn 0;\r\n}\r\nstatic int toshsd_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint ret;\r\nstruct toshsd_host *host;\r\nstruct mmc_host *mmc;\r\nresource_size_t base;\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\nmmc = mmc_alloc_host(sizeof(struct toshsd_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->pdev = pdev;\r\npci_set_drvdata(pdev, host);\r\nret = pci_request_regions(pdev, DRIVER_NAME);\r\nif (ret)\r\ngoto free;\r\nhost->ioaddr = pci_iomap(pdev, 0, 0);\r\nif (!host->ioaddr) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nmmc->ops = &toshsd_ops;\r\nmmc->caps = MMC_CAP_4_BIT_DATA;\r\nmmc->ocr_avail = MMC_VDD_32_33;\r\nmmc->f_min = HCLK / 512;\r\nmmc->f_max = HCLK;\r\nspin_lock_init(&host->lock);\r\ntoshsd_init(host);\r\nret = request_threaded_irq(pdev->irq, toshsd_irq, toshsd_thread_irq,\r\nIRQF_SHARED, DRIVER_NAME, host);\r\nif (ret)\r\ngoto unmap;\r\nmmc_add_host(mmc);\r\nbase = pci_resource_start(pdev, 0);\r\ndev_dbg(&pdev->dev, "MMIO %pa, IRQ %d\n", &base, pdev->irq);\r\npm_suspend_ignore_children(&pdev->dev, 1);\r\nreturn 0;\r\nunmap:\r\npci_iounmap(pdev, host->ioaddr);\r\nrelease:\r\npci_release_regions(pdev);\r\nfree:\r\nmmc_free_host(mmc);\r\npci_set_drvdata(pdev, NULL);\r\nerr:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void toshsd_remove(struct pci_dev *pdev)\r\n{\r\nstruct toshsd_host *host = pci_get_drvdata(pdev);\r\nmmc_remove_host(host->mmc);\r\ntoshsd_powerdown(host);\r\nfree_irq(pdev->irq, host);\r\npci_iounmap(pdev, host->ioaddr);\r\npci_release_regions(pdev);\r\nmmc_free_host(host->mmc);\r\npci_set_drvdata(pdev, NULL);\r\npci_disable_device(pdev);\r\n}
