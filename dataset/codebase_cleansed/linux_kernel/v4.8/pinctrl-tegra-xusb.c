static inline void padctl_writel(struct tegra_xusb_padctl *padctl, u32 value,\r\nunsigned long offset)\r\n{\r\nwritel(value, padctl->regs + offset);\r\n}\r\nstatic inline u32 padctl_readl(struct tegra_xusb_padctl *padctl,\r\nunsigned long offset)\r\n{\r\nreturn readl(padctl->regs + offset);\r\n}\r\nstatic int tegra_xusb_padctl_get_groups_count(struct pinctrl_dev *pinctrl)\r\n{\r\nstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\r\nreturn padctl->soc->num_pins;\r\n}\r\nstatic const char *tegra_xusb_padctl_get_group_name(struct pinctrl_dev *pinctrl,\r\nunsigned int group)\r\n{\r\nstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\r\nreturn padctl->soc->pins[group].name;\r\n}\r\nstatic int tegra_xusb_padctl_get_group_pins(struct pinctrl_dev *pinctrl,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\n*pins = &pinctrl->desc->pins[group].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_padctl_parse_subnode(struct tegra_xusb_padctl *padctl,\r\nstruct device_node *np,\r\nstruct pinctrl_map **maps,\r\nunsigned int *reserved_maps,\r\nunsigned int *num_maps)\r\n{\r\nunsigned int i, reserve = 0, num_configs = 0;\r\nunsigned long config, *configs = NULL;\r\nconst char *function, *group;\r\nstruct property *prop;\r\nint err = 0;\r\nu32 value;\r\nerr = of_property_read_string(np, "nvidia,function", &function);\r\nif (err < 0) {\r\nif (err != -EINVAL)\r\nreturn err;\r\nfunction = NULL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(properties); i++) {\r\nerr = of_property_read_u32(np, properties[i].name, &value);\r\nif (err < 0) {\r\nif (err == -EINVAL)\r\ncontinue;\r\ngoto out;\r\n}\r\nconfig = TEGRA_XUSB_PADCTL_PACK(properties[i].param, value);\r\nerr = pinctrl_utils_add_config(padctl->pinctrl, &configs,\r\n&num_configs, config);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nif (function)\r\nreserve++;\r\nif (num_configs)\r\nreserve++;\r\nerr = of_property_count_strings(np, "nvidia,lanes");\r\nif (err < 0)\r\ngoto out;\r\nreserve *= err;\r\nerr = pinctrl_utils_reserve_map(padctl->pinctrl, maps, reserved_maps,\r\nnum_maps, reserve);\r\nif (err < 0)\r\ngoto out;\r\nof_property_for_each_string(np, "nvidia,lanes", prop, group) {\r\nif (function) {\r\nerr = pinctrl_utils_add_map_mux(padctl->pinctrl, maps,\r\nreserved_maps, num_maps, group,\r\nfunction);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nif (num_configs) {\r\nerr = pinctrl_utils_add_map_configs(padctl->pinctrl,\r\nmaps, reserved_maps, num_maps, group,\r\nconfigs, num_configs,\r\nPIN_MAP_TYPE_CONFIGS_GROUP);\r\nif (err < 0)\r\ngoto out;\r\n}\r\n}\r\nerr = 0;\r\nout:\r\nkfree(configs);\r\nreturn err;\r\n}\r\nstatic int tegra_xusb_padctl_dt_node_to_map(struct pinctrl_dev *pinctrl,\r\nstruct device_node *parent,\r\nstruct pinctrl_map **maps,\r\nunsigned int *num_maps)\r\n{\r\nstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\r\nunsigned int reserved_maps = 0;\r\nstruct device_node *np;\r\nint err;\r\n*num_maps = 0;\r\n*maps = NULL;\r\nfor_each_child_of_node(parent, np) {\r\nerr = tegra_xusb_padctl_parse_subnode(padctl, np, maps,\r\n&reserved_maps,\r\nnum_maps);\r\nif (err < 0) {\r\nof_node_put(np);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_padctl_get_functions_count(struct pinctrl_dev *pinctrl)\r\n{\r\nstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\r\nreturn padctl->soc->num_functions;\r\n}\r\nstatic const char *\r\ntegra_xusb_padctl_get_function_name(struct pinctrl_dev *pinctrl,\r\nunsigned int function)\r\n{\r\nstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\r\nreturn padctl->soc->functions[function].name;\r\n}\r\nstatic int tegra_xusb_padctl_get_function_groups(struct pinctrl_dev *pinctrl,\r\nunsigned int function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\r\n*num_groups = padctl->soc->functions[function].num_groups;\r\n*groups = padctl->soc->functions[function].groups;\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_padctl_pinmux_set(struct pinctrl_dev *pinctrl,\r\nunsigned int function,\r\nunsigned int group)\r\n{\r\nstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\r\nconst struct tegra_xusb_padctl_lane *lane;\r\nunsigned int i;\r\nu32 value;\r\nlane = &padctl->soc->lanes[group];\r\nfor (i = 0; i < lane->num_funcs; i++)\r\nif (lane->funcs[i] == function)\r\nbreak;\r\nif (i >= lane->num_funcs)\r\nreturn -EINVAL;\r\nvalue = padctl_readl(padctl, lane->offset);\r\nvalue &= ~(lane->mask << lane->shift);\r\nvalue |= i << lane->shift;\r\npadctl_writel(padctl, value, lane->offset);\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_padctl_pinconf_group_get(struct pinctrl_dev *pinctrl,\r\nunsigned int group,\r\nunsigned long *config)\r\n{\r\nstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\r\nconst struct tegra_xusb_padctl_lane *lane;\r\nenum tegra_xusb_padctl_param param;\r\nu32 value;\r\nparam = TEGRA_XUSB_PADCTL_UNPACK_PARAM(*config);\r\nlane = &padctl->soc->lanes[group];\r\nswitch (param) {\r\ncase TEGRA_XUSB_PADCTL_IDDQ:\r\nif (lane->iddq == 0)\r\nreturn -EINVAL;\r\nvalue = padctl_readl(padctl, lane->offset);\r\nif (value & BIT(lane->iddq))\r\nvalue = 0;\r\nelse\r\nvalue = 1;\r\n*config = TEGRA_XUSB_PADCTL_PACK(param, value);\r\nbreak;\r\ndefault:\r\ndev_err(padctl->dev, "invalid configuration parameter: %04x\n",\r\nparam);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_padctl_pinconf_group_set(struct pinctrl_dev *pinctrl,\r\nunsigned int group,\r\nunsigned long *configs,\r\nunsigned int num_configs)\r\n{\r\nstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\r\nconst struct tegra_xusb_padctl_lane *lane;\r\nenum tegra_xusb_padctl_param param;\r\nunsigned long value;\r\nunsigned int i;\r\nu32 regval;\r\nlane = &padctl->soc->lanes[group];\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = TEGRA_XUSB_PADCTL_UNPACK_PARAM(configs[i]);\r\nvalue = TEGRA_XUSB_PADCTL_UNPACK_VALUE(configs[i]);\r\nswitch (param) {\r\ncase TEGRA_XUSB_PADCTL_IDDQ:\r\nif (lane->iddq == 0)\r\nreturn -EINVAL;\r\nregval = padctl_readl(padctl, lane->offset);\r\nif (value)\r\nregval &= ~BIT(lane->iddq);\r\nelse\r\nregval |= BIT(lane->iddq);\r\npadctl_writel(padctl, regval, lane->offset);\r\nbreak;\r\ndefault:\r\ndev_err(padctl->dev,\r\n"invalid configuration parameter: %04x\n",\r\nparam);\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *strip_prefix(const char *s)\r\n{\r\nconst char *comma = strchr(s, ',');\r\nif (!comma)\r\nreturn s;\r\nreturn comma + 1;\r\n}\r\nstatic void\r\ntegra_xusb_padctl_pinconf_group_dbg_show(struct pinctrl_dev *pinctrl,\r\nstruct seq_file *s,\r\nunsigned int group)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(properties); i++) {\r\nunsigned long config, value;\r\nint err;\r\nconfig = TEGRA_XUSB_PADCTL_PACK(properties[i].param, 0);\r\nerr = tegra_xusb_padctl_pinconf_group_get(pinctrl, group,\r\n&config);\r\nif (err < 0)\r\ncontinue;\r\nvalue = TEGRA_XUSB_PADCTL_UNPACK_VALUE(config);\r\nseq_printf(s, "\n\t%s=%lu\n", strip_prefix(properties[i].name),\r\nvalue);\r\n}\r\n}\r\nstatic void\r\ntegra_xusb_padctl_pinconf_config_dbg_show(struct pinctrl_dev *pinctrl,\r\nstruct seq_file *s,\r\nunsigned long config)\r\n{\r\nenum tegra_xusb_padctl_param param;\r\nconst char *name = "unknown";\r\nunsigned long value;\r\nunsigned int i;\r\nparam = TEGRA_XUSB_PADCTL_UNPACK_PARAM(config);\r\nvalue = TEGRA_XUSB_PADCTL_UNPACK_VALUE(config);\r\nfor (i = 0; i < ARRAY_SIZE(properties); i++) {\r\nif (properties[i].param == param) {\r\nname = properties[i].name;\r\nbreak;\r\n}\r\n}\r\nseq_printf(s, "%s=%lu", strip_prefix(name), value);\r\n}\r\nstatic int tegra_xusb_padctl_enable(struct tegra_xusb_padctl *padctl)\r\n{\r\nu32 value;\r\nmutex_lock(&padctl->lock);\r\nif (padctl->enable++ > 0)\r\ngoto out;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nout:\r\nmutex_unlock(&padctl->lock);\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_padctl_disable(struct tegra_xusb_padctl *padctl)\r\n{\r\nu32 value;\r\nmutex_lock(&padctl->lock);\r\nif (WARN_ON(padctl->enable == 0))\r\ngoto out;\r\nif (--padctl->enable > 0)\r\ngoto out;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nout:\r\nmutex_unlock(&padctl->lock);\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_phy_init(struct phy *phy)\r\n{\r\nstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\r\nreturn tegra_xusb_padctl_enable(padctl);\r\n}\r\nstatic int tegra_xusb_phy_exit(struct phy *phy)\r\n{\r\nstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\r\nreturn tegra_xusb_padctl_disable(padctl);\r\n}\r\nstatic int pcie_phy_power_on(struct phy *phy)\r\n{\r\nstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\r\nunsigned long timeout;\r\nint err = -ETIMEDOUT;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_P0_CTL1_REFCLK_SEL_MASK;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL2);\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_P0_CTL2_REFCLKBUF_EN |\r\nXUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_EN |\r\nXUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_SEL;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL2);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL_RST;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\ntimeout = jiffies + msecs_to_jiffies(50);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nif (value & XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL0_LOCKDET) {\r\nerr = 0;\r\nbreak;\r\n}\r\nusleep_range(100, 200);\r\n}\r\nreturn err;\r\n}\r\nstatic int pcie_phy_power_off(struct phy *phy)\r\n{\r\nstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL_RST;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nreturn 0;\r\n}\r\nstatic int sata_phy_power_on(struct phy *phy)\r\n{\r\nstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\r\nunsigned long timeout;\r\nint err = -ETIMEDOUT;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD;\r\nvalue &= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD;\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_IDDQ;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_MODE;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_RST;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\ntimeout = jiffies + msecs_to_jiffies(50);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nif (value & XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_LOCKDET) {\r\nerr = 0;\r\nbreak;\r\n}\r\nusleep_range(100, 200);\r\n}\r\nreturn err;\r\n}\r\nstatic int sata_phy_power_off(struct phy *phy)\r\n{\r\nstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_RST;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_MODE;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD;\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_IDDQ;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\r\nvalue |= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD;\r\nvalue |= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\r\nreturn 0;\r\n}\r\nstatic struct phy *tegra_xusb_padctl_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct tegra_xusb_padctl *padctl = dev_get_drvdata(dev);\r\nunsigned int index = args->args[0];\r\nif (args->args_count <= 0)\r\nreturn ERR_PTR(-EINVAL);\r\nif (index >= ARRAY_SIZE(padctl->phys))\r\nreturn ERR_PTR(-EINVAL);\r\nreturn padctl->phys[index];\r\n}\r\nint tegra_xusb_padctl_legacy_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_xusb_padctl *padctl;\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nstruct phy *phy;\r\nint err;\r\npadctl = devm_kzalloc(&pdev->dev, sizeof(*padctl), GFP_KERNEL);\r\nif (!padctl)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, padctl);\r\nmutex_init(&padctl->lock);\r\npadctl->dev = &pdev->dev;\r\nmatch = of_match_node(tegra_xusb_padctl_of_match, pdev->dev.of_node);\r\npadctl->soc = match->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npadctl->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(padctl->regs))\r\nreturn PTR_ERR(padctl->regs);\r\npadctl->rst = devm_reset_control_get(&pdev->dev, NULL);\r\nif (IS_ERR(padctl->rst))\r\nreturn PTR_ERR(padctl->rst);\r\nerr = reset_control_deassert(padctl->rst);\r\nif (err < 0)\r\nreturn err;\r\nmemset(&padctl->desc, 0, sizeof(padctl->desc));\r\npadctl->desc.name = dev_name(padctl->dev);\r\npadctl->desc.pins = tegra124_pins;\r\npadctl->desc.npins = ARRAY_SIZE(tegra124_pins);\r\npadctl->desc.pctlops = &tegra_xusb_padctl_pinctrl_ops;\r\npadctl->desc.pmxops = &tegra_xusb_padctl_pinmux_ops;\r\npadctl->desc.confops = &tegra_xusb_padctl_pinconf_ops;\r\npadctl->desc.owner = THIS_MODULE;\r\npadctl->pinctrl = devm_pinctrl_register(&pdev->dev, &padctl->desc,\r\npadctl);\r\nif (IS_ERR(padctl->pinctrl)) {\r\ndev_err(&pdev->dev, "failed to register pincontrol\n");\r\nerr = PTR_ERR(padctl->pinctrl);\r\ngoto reset;\r\n}\r\nphy = devm_phy_create(&pdev->dev, NULL, &pcie_phy_ops);\r\nif (IS_ERR(phy)) {\r\nerr = PTR_ERR(phy);\r\ngoto reset;\r\n}\r\npadctl->phys[TEGRA_XUSB_PADCTL_PCIE] = phy;\r\nphy_set_drvdata(phy, padctl);\r\nphy = devm_phy_create(&pdev->dev, NULL, &sata_phy_ops);\r\nif (IS_ERR(phy)) {\r\nerr = PTR_ERR(phy);\r\ngoto reset;\r\n}\r\npadctl->phys[TEGRA_XUSB_PADCTL_SATA] = phy;\r\nphy_set_drvdata(phy, padctl);\r\npadctl->provider = devm_of_phy_provider_register(&pdev->dev,\r\ntegra_xusb_padctl_xlate);\r\nif (IS_ERR(padctl->provider)) {\r\nerr = PTR_ERR(padctl->provider);\r\ndev_err(&pdev->dev, "failed to register PHYs: %d\n", err);\r\ngoto reset;\r\n}\r\nreturn 0;\r\nreset:\r\nreset_control_assert(padctl->rst);\r\nreturn err;\r\n}\r\nint tegra_xusb_padctl_legacy_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_xusb_padctl *padctl = platform_get_drvdata(pdev);\r\nint err;\r\nerr = reset_control_assert(padctl->rst);\r\nif (err < 0)\r\ndev_err(&pdev->dev, "failed to assert reset: %d\n", err);\r\nreturn err;\r\n}
