static inline u32 st_dwc3_readl(void __iomem *base, u32 offset)\r\n{\r\nreturn readl_relaxed(base + offset);\r\n}\r\nstatic inline void st_dwc3_writel(void __iomem *base, u32 offset, u32 value)\r\n{\r\nwritel_relaxed(value, base + offset);\r\n}\r\nstatic int st_dwc3_drd_init(struct st_dwc3 *dwc3_data)\r\n{\r\nu32 val;\r\nint err;\r\nerr = regmap_read(dwc3_data->regmap, dwc3_data->syscfg_reg_off, &val);\r\nif (err)\r\nreturn err;\r\nval &= USB3_CONTROL_MASK;\r\nswitch (dwc3_data->dr_mode) {\r\ncase USB_DR_MODE_PERIPHERAL:\r\nval &= ~(USB3_DELAY_VBUSVALID\r\n| USB3_SEL_FORCE_OPMODE | USB3_FORCE_OPMODE(0x3)\r\n| USB3_SEL_FORCE_DPPULLDOWN2 | USB3_FORCE_DPPULLDOWN2\r\n| USB3_SEL_FORCE_DMPULLDOWN2 | USB3_FORCE_DMPULLDOWN2);\r\nval |= USB3_DEVICE_NOT_HOST | USB3_FORCE_VBUSVALID;\r\nbreak;\r\ncase USB_DR_MODE_HOST:\r\nval &= ~(USB3_DEVICE_NOT_HOST | USB3_FORCE_VBUSVALID\r\n| USB3_SEL_FORCE_OPMODE | USB3_FORCE_OPMODE(0x3)\r\n| USB3_SEL_FORCE_DPPULLDOWN2 | USB3_FORCE_DPPULLDOWN2\r\n| USB3_SEL_FORCE_DMPULLDOWN2 | USB3_FORCE_DMPULLDOWN2);\r\nval |= USB3_DELAY_VBUSVALID;\r\nbreak;\r\ndefault:\r\ndev_err(dwc3_data->dev, "Unsupported mode of operation %d\n",\r\ndwc3_data->dr_mode);\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_write(dwc3_data->regmap, dwc3_data->syscfg_reg_off, val);\r\n}\r\nstatic void st_dwc3_init(struct st_dwc3 *dwc3_data)\r\n{\r\nu32 reg = st_dwc3_readl(dwc3_data->glue_base, CLKRST_CTRL);\r\nreg |= AUX_CLK_EN | EXT_CFG_RESET_N | XHCI_REVISION;\r\nreg &= ~SW_PIPEW_RESET_N;\r\nst_dwc3_writel(dwc3_data->glue_base, CLKRST_CTRL, reg);\r\nreg = st_dwc3_readl(dwc3_data->glue_base, USB2_VBUS_MNGMNT_SEL1);\r\nreg |= SEL_OVERRIDE_VBUSVALID(USB2_VBUS_UTMIOTG) |\r\nSEL_OVERRIDE_POWERPRESENT(USB2_VBUS_UTMIOTG) |\r\nSEL_OVERRIDE_BVALID(USB2_VBUS_UTMIOTG);\r\nst_dwc3_writel(dwc3_data->glue_base, USB2_VBUS_MNGMNT_SEL1, reg);\r\nreg = st_dwc3_readl(dwc3_data->glue_base, CLKRST_CTRL);\r\nreg |= SW_PIPEW_RESET_N;\r\nst_dwc3_writel(dwc3_data->glue_base, CLKRST_CTRL, reg);\r\n}\r\nstatic int st_dwc3_probe(struct platform_device *pdev)\r\n{\r\nstruct st_dwc3 *dwc3_data;\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node, *child;\r\nstruct platform_device *child_pdev;\r\nstruct regmap *regmap;\r\nint ret;\r\ndwc3_data = devm_kzalloc(dev, sizeof(*dwc3_data), GFP_KERNEL);\r\nif (!dwc3_data)\r\nreturn -ENOMEM;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "reg-glue");\r\ndwc3_data->glue_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(dwc3_data->glue_base))\r\nreturn PTR_ERR(dwc3_data->glue_base);\r\nregmap = syscon_regmap_lookup_by_phandle(node, "st,syscfg");\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\ndma_set_coherent_mask(dev, dev->coherent_dma_mask);\r\ndwc3_data->dev = dev;\r\ndwc3_data->regmap = regmap;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "syscfg-reg");\r\nif (!res) {\r\nret = -ENXIO;\r\ngoto undo_platform_dev_alloc;\r\n}\r\ndwc3_data->syscfg_reg_off = res->start;\r\ndev_vdbg(&pdev->dev, "glue-logic addr 0x%p, syscfg-reg offset 0x%x\n",\r\ndwc3_data->glue_base, dwc3_data->syscfg_reg_off);\r\ndwc3_data->rstc_pwrdn =\r\ndevm_reset_control_get_exclusive(dev, "powerdown");\r\nif (IS_ERR(dwc3_data->rstc_pwrdn)) {\r\ndev_err(&pdev->dev, "could not get power controller\n");\r\nret = PTR_ERR(dwc3_data->rstc_pwrdn);\r\ngoto undo_platform_dev_alloc;\r\n}\r\nreset_control_deassert(dwc3_data->rstc_pwrdn);\r\ndwc3_data->rstc_rst =\r\ndevm_reset_control_get_shared(dev, "softreset");\r\nif (IS_ERR(dwc3_data->rstc_rst)) {\r\ndev_err(&pdev->dev, "could not get reset controller\n");\r\nret = PTR_ERR(dwc3_data->rstc_rst);\r\ngoto undo_powerdown;\r\n}\r\nreset_control_deassert(dwc3_data->rstc_rst);\r\nchild = of_get_child_by_name(node, "dwc3");\r\nif (!child) {\r\ndev_err(&pdev->dev, "failed to find dwc3 core node\n");\r\nret = -ENODEV;\r\ngoto undo_softreset;\r\n}\r\nret = of_platform_populate(node, NULL, NULL, dev);\r\nif (ret) {\r\ndev_err(dev, "failed to add dwc3 core\n");\r\ngoto undo_softreset;\r\n}\r\nchild_pdev = of_find_device_by_node(child);\r\nif (!child_pdev) {\r\ndev_err(dev, "failed to find dwc3 core device\n");\r\nret = -ENODEV;\r\ngoto undo_softreset;\r\n}\r\ndwc3_data->dr_mode = usb_get_dr_mode(&child_pdev->dev);\r\nret = st_dwc3_drd_init(dwc3_data);\r\nif (ret) {\r\ndev_err(dev, "drd initialisation failed\n");\r\ngoto undo_softreset;\r\n}\r\nst_dwc3_init(dwc3_data);\r\nplatform_set_drvdata(pdev, dwc3_data);\r\nreturn 0;\r\nundo_softreset:\r\nreset_control_assert(dwc3_data->rstc_rst);\r\nundo_powerdown:\r\nreset_control_assert(dwc3_data->rstc_pwrdn);\r\nundo_platform_dev_alloc:\r\nplatform_device_put(pdev);\r\nreturn ret;\r\n}\r\nstatic int st_dwc3_remove(struct platform_device *pdev)\r\n{\r\nstruct st_dwc3 *dwc3_data = platform_get_drvdata(pdev);\r\nof_platform_depopulate(&pdev->dev);\r\nreset_control_assert(dwc3_data->rstc_pwrdn);\r\nreset_control_assert(dwc3_data->rstc_rst);\r\nreturn 0;\r\n}\r\nstatic int st_dwc3_suspend(struct device *dev)\r\n{\r\nstruct st_dwc3 *dwc3_data = dev_get_drvdata(dev);\r\nreset_control_assert(dwc3_data->rstc_pwrdn);\r\nreset_control_assert(dwc3_data->rstc_rst);\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int st_dwc3_resume(struct device *dev)\r\n{\r\nstruct st_dwc3 *dwc3_data = dev_get_drvdata(dev);\r\nint ret;\r\npinctrl_pm_select_default_state(dev);\r\nreset_control_deassert(dwc3_data->rstc_pwrdn);\r\nreset_control_deassert(dwc3_data->rstc_rst);\r\nret = st_dwc3_drd_init(dwc3_data);\r\nif (ret) {\r\ndev_err(dev, "drd initialisation failed\n");\r\nreturn ret;\r\n}\r\nst_dwc3_init(dwc3_data);\r\nreturn 0;\r\n}
