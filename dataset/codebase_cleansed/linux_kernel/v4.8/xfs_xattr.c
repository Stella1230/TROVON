static int\r\nxfs_xattr_get(const struct xattr_handler *handler, struct dentry *unused,\r\nstruct inode *inode, const char *name, void *value, size_t size)\r\n{\r\nint xflags = handler->flags;\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nint error, asize = size;\r\nif (!size) {\r\nxflags |= ATTR_KERNOVAL;\r\nvalue = NULL;\r\n}\r\nerror = xfs_attr_get(ip, (unsigned char *)name, value, &asize, xflags);\r\nif (error)\r\nreturn error;\r\nreturn asize;\r\n}\r\nvoid\r\nxfs_forget_acl(\r\nstruct inode *inode,\r\nconst char *name,\r\nint xflags)\r\n{\r\nif (xflags & ATTR_ROOT) {\r\n#ifdef CONFIG_XFS_POSIX_ACL\r\nif (!strcmp(name, SGI_ACL_FILE))\r\nforget_cached_acl(inode, ACL_TYPE_ACCESS);\r\nelse if (!strcmp(name, SGI_ACL_DEFAULT))\r\nforget_cached_acl(inode, ACL_TYPE_DEFAULT);\r\n#endif\r\n}\r\n}\r\nstatic int\r\nxfs_xattr_set(const struct xattr_handler *handler, struct dentry *unused,\r\nstruct inode *inode, const char *name, const void *value,\r\nsize_t size, int flags)\r\n{\r\nint xflags = handler->flags;\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nint error;\r\nif (flags & XATTR_CREATE)\r\nxflags |= ATTR_CREATE;\r\nif (flags & XATTR_REPLACE)\r\nxflags |= ATTR_REPLACE;\r\nif (!value)\r\nreturn xfs_attr_remove(ip, (unsigned char *)name, xflags);\r\nerror = xfs_attr_set(ip, (unsigned char *)name,\r\n(void *)value, size, xflags);\r\nif (!error)\r\nxfs_forget_acl(inode, name, xflags);\r\nreturn error;\r\n}\r\nstatic int\r\n__xfs_xattr_put_listent(\r\nstruct xfs_attr_list_context *context,\r\nchar *prefix,\r\nint prefix_len,\r\nunsigned char *name,\r\nint namelen)\r\n{\r\nchar *offset;\r\nint arraytop;\r\nif (!context->alist)\r\ngoto compute_size;\r\narraytop = context->count + prefix_len + namelen + 1;\r\nif (arraytop > context->firstu) {\r\ncontext->count = -1;\r\nreturn 0;\r\n}\r\noffset = (char *)context->alist + context->count;\r\nstrncpy(offset, prefix, prefix_len);\r\noffset += prefix_len;\r\nstrncpy(offset, (char *)name, namelen);\r\noffset += namelen;\r\n*offset = '\0';\r\ncompute_size:\r\ncontext->count += prefix_len + namelen + 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nxfs_xattr_put_listent(\r\nstruct xfs_attr_list_context *context,\r\nint flags,\r\nunsigned char *name,\r\nint namelen,\r\nint valuelen)\r\n{\r\nchar *prefix;\r\nint prefix_len;\r\nASSERT(context->count >= 0);\r\nif (flags & XFS_ATTR_ROOT) {\r\n#ifdef CONFIG_XFS_POSIX_ACL\r\nif (namelen == SGI_ACL_FILE_SIZE &&\r\nstrncmp(name, SGI_ACL_FILE,\r\nSGI_ACL_FILE_SIZE) == 0) {\r\nint ret = __xfs_xattr_put_listent(\r\ncontext, XATTR_SYSTEM_PREFIX,\r\nXATTR_SYSTEM_PREFIX_LEN,\r\nXATTR_POSIX_ACL_ACCESS,\r\nstrlen(XATTR_POSIX_ACL_ACCESS));\r\nif (ret)\r\nreturn ret;\r\n} else if (namelen == SGI_ACL_DEFAULT_SIZE &&\r\nstrncmp(name, SGI_ACL_DEFAULT,\r\nSGI_ACL_DEFAULT_SIZE) == 0) {\r\nint ret = __xfs_xattr_put_listent(\r\ncontext, XATTR_SYSTEM_PREFIX,\r\nXATTR_SYSTEM_PREFIX_LEN,\r\nXATTR_POSIX_ACL_DEFAULT,\r\nstrlen(XATTR_POSIX_ACL_DEFAULT));\r\nif (ret)\r\nreturn ret;\r\n}\r\n#endif\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn 0;\r\nprefix = XATTR_TRUSTED_PREFIX;\r\nprefix_len = XATTR_TRUSTED_PREFIX_LEN;\r\n} else if (flags & XFS_ATTR_SECURE) {\r\nprefix = XATTR_SECURITY_PREFIX;\r\nprefix_len = XATTR_SECURITY_PREFIX_LEN;\r\n} else {\r\nprefix = XATTR_USER_PREFIX;\r\nprefix_len = XATTR_USER_PREFIX_LEN;\r\n}\r\nreturn __xfs_xattr_put_listent(context, prefix, prefix_len, name,\r\nnamelen);\r\n}\r\nssize_t\r\nxfs_vn_listxattr(\r\nstruct dentry *dentry,\r\nchar *data,\r\nsize_t size)\r\n{\r\nstruct xfs_attr_list_context context;\r\nstruct attrlist_cursor_kern cursor = { 0 };\r\nstruct inode *inode = d_inode(dentry);\r\nint error;\r\nmemset(&context, 0, sizeof(context));\r\ncontext.dp = XFS_I(inode);\r\ncontext.cursor = &cursor;\r\ncontext.resynch = 1;\r\ncontext.alist = size ? data : NULL;\r\ncontext.bufsize = size;\r\ncontext.firstu = context.bufsize;\r\ncontext.put_listent = xfs_xattr_put_listent;\r\nerror = xfs_attr_list_int(&context);\r\nif (error)\r\nreturn error;\r\nif (context.count < 0)\r\nreturn -ERANGE;\r\nreturn context.count;\r\n}
