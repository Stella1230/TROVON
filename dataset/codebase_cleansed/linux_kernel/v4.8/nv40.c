static enum nvkm_memory_target\r\nnv40_instobj_target(struct nvkm_memory *memory)\r\n{\r\nreturn NVKM_MEM_TARGET_INST;\r\n}\r\nstatic u64\r\nnv40_instobj_addr(struct nvkm_memory *memory)\r\n{\r\nreturn nv40_instobj(memory)->node->offset;\r\n}\r\nstatic u64\r\nnv40_instobj_size(struct nvkm_memory *memory)\r\n{\r\nreturn nv40_instobj(memory)->node->length;\r\n}\r\nstatic void __iomem *\r\nnv40_instobj_acquire(struct nvkm_memory *memory)\r\n{\r\nstruct nv40_instobj *iobj = nv40_instobj(memory);\r\nreturn iobj->imem->iomem + iobj->node->offset;\r\n}\r\nstatic void\r\nnv40_instobj_release(struct nvkm_memory *memory)\r\n{\r\n}\r\nstatic u32\r\nnv40_instobj_rd32(struct nvkm_memory *memory, u64 offset)\r\n{\r\nstruct nv40_instobj *iobj = nv40_instobj(memory);\r\nreturn ioread32_native(iobj->imem->iomem + iobj->node->offset + offset);\r\n}\r\nstatic void\r\nnv40_instobj_wr32(struct nvkm_memory *memory, u64 offset, u32 data)\r\n{\r\nstruct nv40_instobj *iobj = nv40_instobj(memory);\r\niowrite32_native(data, iobj->imem->iomem + iobj->node->offset + offset);\r\n}\r\nstatic void *\r\nnv40_instobj_dtor(struct nvkm_memory *memory)\r\n{\r\nstruct nv40_instobj *iobj = nv40_instobj(memory);\r\nmutex_lock(&iobj->imem->base.subdev.mutex);\r\nnvkm_mm_free(&iobj->imem->heap, &iobj->node);\r\nmutex_unlock(&iobj->imem->base.subdev.mutex);\r\nreturn iobj;\r\n}\r\nstatic int\r\nnv40_instobj_new(struct nvkm_instmem *base, u32 size, u32 align, bool zero,\r\nstruct nvkm_memory **pmemory)\r\n{\r\nstruct nv40_instmem *imem = nv40_instmem(base);\r\nstruct nv40_instobj *iobj;\r\nint ret;\r\nif (!(iobj = kzalloc(sizeof(*iobj), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pmemory = &iobj->memory;\r\nnvkm_memory_ctor(&nv40_instobj_func, &iobj->memory);\r\niobj->imem = imem;\r\nmutex_lock(&imem->base.subdev.mutex);\r\nret = nvkm_mm_head(&imem->heap, 0, 1, size, size,\r\nalign ? align : 1, &iobj->node);\r\nmutex_unlock(&imem->base.subdev.mutex);\r\nreturn ret;\r\n}\r\nstatic u32\r\nnv40_instmem_rd32(struct nvkm_instmem *base, u32 addr)\r\n{\r\nreturn ioread32_native(nv40_instmem(base)->iomem + addr);\r\n}\r\nstatic void\r\nnv40_instmem_wr32(struct nvkm_instmem *base, u32 addr, u32 data)\r\n{\r\niowrite32_native(data, nv40_instmem(base)->iomem + addr);\r\n}\r\nstatic int\r\nnv40_instmem_oneinit(struct nvkm_instmem *base)\r\n{\r\nstruct nv40_instmem *imem = nv40_instmem(base);\r\nstruct nvkm_device *device = imem->base.subdev.device;\r\nint ret, vs;\r\nvs = hweight8((nvkm_rd32(device, 0x001540) & 0x0000ff00) >> 8);\r\nif (device->chipset == 0x40) imem->base.reserved = 0x6aa0 * vs;\r\nelse if (device->chipset < 0x43) imem->base.reserved = 0x4f00 * vs;\r\nelse if (nv44_gr_class(device)) imem->base.reserved = 0x4980 * vs;\r\nelse imem->base.reserved = 0x4a40 * vs;\r\nimem->base.reserved += 16 * 1024;\r\nimem->base.reserved *= 32;\r\nimem->base.reserved += 512 * 1024;\r\nimem->base.reserved += 512 * 1024;\r\nimem->base.reserved = round_up(imem->base.reserved, 4096);\r\nret = nvkm_mm_init(&imem->heap, 0, imem->base.reserved, 1);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, 0x10000, 0, false,\r\n&imem->base.vbios);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_ramht_new(device, 0x08000, 0, NULL, &imem->base.ramht);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, 0x08000, 0, false,\r\n&imem->base.ramro);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, 0x20000, 0, true,\r\n&imem->base.ramfc);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void *\r\nnv40_instmem_dtor(struct nvkm_instmem *base)\r\n{\r\nstruct nv40_instmem *imem = nv40_instmem(base);\r\nnvkm_memory_del(&imem->base.ramfc);\r\nnvkm_memory_del(&imem->base.ramro);\r\nnvkm_ramht_del(&imem->base.ramht);\r\nnvkm_memory_del(&imem->base.vbios);\r\nnvkm_mm_fini(&imem->heap);\r\nif (imem->iomem)\r\niounmap(imem->iomem);\r\nreturn imem;\r\n}\r\nint\r\nnv40_instmem_new(struct nvkm_device *device, int index,\r\nstruct nvkm_instmem **pimem)\r\n{\r\nstruct nv40_instmem *imem;\r\nint bar;\r\nif (!(imem = kzalloc(sizeof(*imem), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nnvkm_instmem_ctor(&nv40_instmem, device, index, &imem->base);\r\n*pimem = &imem->base;\r\nif (device->func->resource_size(device, 2))\r\nbar = 2;\r\nelse\r\nbar = 3;\r\nimem->iomem = ioremap(device->func->resource_addr(device, bar),\r\ndevice->func->resource_size(device, bar));\r\nif (!imem->iomem) {\r\nnvkm_error(&imem->base.subdev, "unable to map PRAMIN BAR\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}
