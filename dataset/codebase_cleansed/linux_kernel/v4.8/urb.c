static void urb_destroy(struct kref *kref)\r\n{\r\nstruct urb *urb = to_urb(kref);\r\nif (urb->transfer_flags & URB_FREE_BUFFER)\r\nkfree(urb->transfer_buffer);\r\nkfree(urb);\r\n}\r\nvoid usb_init_urb(struct urb *urb)\r\n{\r\nif (urb) {\r\nmemset(urb, 0, sizeof(*urb));\r\nkref_init(&urb->kref);\r\nINIT_LIST_HEAD(&urb->anchor_list);\r\n}\r\n}\r\nstruct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)\r\n{\r\nstruct urb *urb;\r\nurb = kmalloc(sizeof(struct urb) +\r\niso_packets * sizeof(struct usb_iso_packet_descriptor),\r\nmem_flags);\r\nif (!urb) {\r\nprintk(KERN_ERR "alloc_urb: kmalloc failed\n");\r\nreturn NULL;\r\n}\r\nusb_init_urb(urb);\r\nreturn urb;\r\n}\r\nvoid usb_free_urb(struct urb *urb)\r\n{\r\nif (urb)\r\nkref_put(&urb->kref, urb_destroy);\r\n}\r\nstruct urb *usb_get_urb(struct urb *urb)\r\n{\r\nif (urb)\r\nkref_get(&urb->kref);\r\nreturn urb;\r\n}\r\nvoid usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&anchor->lock, flags);\r\nusb_get_urb(urb);\r\nlist_add_tail(&urb->anchor_list, &anchor->urb_list);\r\nurb->anchor = anchor;\r\nif (unlikely(anchor->poisoned))\r\natomic_inc(&urb->reject);\r\nspin_unlock_irqrestore(&anchor->lock, flags);\r\n}\r\nstatic int usb_anchor_check_wakeup(struct usb_anchor *anchor)\r\n{\r\nreturn atomic_read(&anchor->suspend_wakeups) == 0 &&\r\nlist_empty(&anchor->urb_list);\r\n}\r\nstatic void __usb_unanchor_urb(struct urb *urb, struct usb_anchor *anchor)\r\n{\r\nurb->anchor = NULL;\r\nlist_del(&urb->anchor_list);\r\nusb_put_urb(urb);\r\nif (usb_anchor_check_wakeup(anchor))\r\nwake_up(&anchor->wait);\r\n}\r\nvoid usb_unanchor_urb(struct urb *urb)\r\n{\r\nunsigned long flags;\r\nstruct usb_anchor *anchor;\r\nif (!urb)\r\nreturn;\r\nanchor = urb->anchor;\r\nif (!anchor)\r\nreturn;\r\nspin_lock_irqsave(&anchor->lock, flags);\r\nif (likely(anchor == urb->anchor))\r\n__usb_unanchor_urb(urb, anchor);\r\nspin_unlock_irqrestore(&anchor->lock, flags);\r\n}\r\nint usb_submit_urb(struct urb *urb, gfp_t mem_flags)\r\n{\r\nstatic int pipetypes[4] = {\r\nPIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT\r\n};\r\nint xfertype, max;\r\nstruct usb_device *dev;\r\nstruct usb_host_endpoint *ep;\r\nint is_out;\r\nunsigned int allowed;\r\nif (!urb || !urb->complete)\r\nreturn -EINVAL;\r\nif (urb->hcpriv) {\r\nWARN_ONCE(1, "URB %p submitted while active\n", urb);\r\nreturn -EBUSY;\r\n}\r\ndev = urb->dev;\r\nif ((!dev) || (dev->state < USB_STATE_UNAUTHENTICATED))\r\nreturn -ENODEV;\r\nep = usb_pipe_endpoint(dev, urb->pipe);\r\nif (!ep)\r\nreturn -ENOENT;\r\nurb->ep = ep;\r\nurb->status = -EINPROGRESS;\r\nurb->actual_length = 0;\r\nxfertype = usb_endpoint_type(&ep->desc);\r\nif (xfertype == USB_ENDPOINT_XFER_CONTROL) {\r\nstruct usb_ctrlrequest *setup =\r\n(struct usb_ctrlrequest *) urb->setup_packet;\r\nif (!setup)\r\nreturn -ENOEXEC;\r\nis_out = !(setup->bRequestType & USB_DIR_IN) ||\r\n!setup->wLength;\r\n} else {\r\nis_out = usb_endpoint_dir_out(&ep->desc);\r\n}\r\nurb->transfer_flags &= ~(URB_DIR_MASK | URB_DMA_MAP_SINGLE |\r\nURB_DMA_MAP_PAGE | URB_DMA_MAP_SG | URB_MAP_LOCAL |\r\nURB_SETUP_MAP_SINGLE | URB_SETUP_MAP_LOCAL |\r\nURB_DMA_SG_COMBINED);\r\nurb->transfer_flags |= (is_out ? URB_DIR_OUT : URB_DIR_IN);\r\nif (xfertype != USB_ENDPOINT_XFER_CONTROL &&\r\ndev->state < USB_STATE_CONFIGURED)\r\nreturn -ENODEV;\r\nmax = usb_endpoint_maxp(&ep->desc);\r\nif (max <= 0) {\r\ndev_dbg(&dev->dev,\r\n"bogus endpoint ep%d%s in %s (bad maxpacket %d)\n",\r\nusb_endpoint_num(&ep->desc), is_out ? "out" : "in",\r\n__func__, max);\r\nreturn -EMSGSIZE;\r\n}\r\nif (xfertype == USB_ENDPOINT_XFER_ISOC) {\r\nint n, len;\r\nif (dev->speed >= USB_SPEED_SUPER) {\r\nint burst = 1 + ep->ss_ep_comp.bMaxBurst;\r\nint mult = USB_SS_MULT(ep->ss_ep_comp.bmAttributes);\r\nmax *= burst;\r\nmax *= mult;\r\n}\r\nif (dev->speed == USB_SPEED_HIGH) {\r\nint mult = 1 + ((max >> 11) & 0x03);\r\nmax &= 0x07ff;\r\nmax *= mult;\r\n}\r\nif (urb->number_of_packets <= 0)\r\nreturn -EINVAL;\r\nfor (n = 0; n < urb->number_of_packets; n++) {\r\nlen = urb->iso_frame_desc[n].length;\r\nif (len < 0 || len > max)\r\nreturn -EMSGSIZE;\r\nurb->iso_frame_desc[n].status = -EXDEV;\r\nurb->iso_frame_desc[n].actual_length = 0;\r\n}\r\n} else if (urb->num_sgs && !urb->dev->bus->no_sg_constraint &&\r\ndev->speed != USB_SPEED_WIRELESS) {\r\nstruct scatterlist *sg;\r\nint i;\r\nfor_each_sg(urb->sg, sg, urb->num_sgs - 1, i)\r\nif (sg->length % max)\r\nreturn -EINVAL;\r\n}\r\nif (urb->transfer_buffer_length > INT_MAX)\r\nreturn -EMSGSIZE;\r\nif (usb_pipetype(urb->pipe) != pipetypes[xfertype])\r\ndev_WARN(&dev->dev, "BOGUS urb xfer, pipe %x != type %x\n",\r\nusb_pipetype(urb->pipe), pipetypes[xfertype]);\r\nallowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT | URB_DIR_MASK |\r\nURB_FREE_BUFFER);\r\nswitch (xfertype) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (is_out)\r\nallowed |= URB_ZERO_PACKET;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nallowed |= URB_NO_FSBR;\r\ndefault:\r\nif (!is_out)\r\nallowed |= URB_SHORT_NOT_OK;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nallowed |= URB_ISO_ASAP;\r\nbreak;\r\n}\r\nallowed &= urb->transfer_flags;\r\nif (allowed != urb->transfer_flags)\r\ndev_WARN(&dev->dev, "BOGUS urb flags, %x --> %x\n",\r\nurb->transfer_flags, allowed);\r\nswitch (xfertype) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ncase USB_ENDPOINT_XFER_INT:\r\nswitch (dev->speed) {\r\ncase USB_SPEED_WIRELESS:\r\nif ((urb->interval < 6)\r\n&& (xfertype == USB_ENDPOINT_XFER_INT))\r\nreturn -EINVAL;\r\ndefault:\r\nif (urb->interval <= 0)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nswitch (dev->speed) {\r\ncase USB_SPEED_SUPER_PLUS:\r\ncase USB_SPEED_SUPER:\r\nif (urb->interval > (1 << 15))\r\nreturn -EINVAL;\r\nmax = 1 << 15;\r\nbreak;\r\ncase USB_SPEED_WIRELESS:\r\nif (urb->interval > 16)\r\nreturn -EINVAL;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nif (urb->interval > (1024 * 8))\r\nurb->interval = 1024 * 8;\r\nmax = 1024 * 8;\r\nbreak;\r\ncase USB_SPEED_FULL:\r\ncase USB_SPEED_LOW:\r\nif (xfertype == USB_ENDPOINT_XFER_INT) {\r\nif (urb->interval > 255)\r\nreturn -EINVAL;\r\nmax = 128;\r\n} else {\r\nif (urb->interval > 1024)\r\nurb->interval = 1024;\r\nmax = 1024;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (dev->speed != USB_SPEED_WIRELESS) {\r\nurb->interval = min(max, 1 << ilog2(urb->interval));\r\n}\r\n}\r\nreturn usb_hcd_submit_urb(urb, mem_flags);\r\n}\r\nint usb_unlink_urb(struct urb *urb)\r\n{\r\nif (!urb)\r\nreturn -EINVAL;\r\nif (!urb->dev)\r\nreturn -ENODEV;\r\nif (!urb->ep)\r\nreturn -EIDRM;\r\nreturn usb_hcd_unlink_urb(urb, -ECONNRESET);\r\n}\r\nvoid usb_kill_urb(struct urb *urb)\r\n{\r\nmight_sleep();\r\nif (!(urb && urb->dev && urb->ep))\r\nreturn;\r\natomic_inc(&urb->reject);\r\nusb_hcd_unlink_urb(urb, -ENOENT);\r\nwait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);\r\natomic_dec(&urb->reject);\r\n}\r\nvoid usb_poison_urb(struct urb *urb)\r\n{\r\nmight_sleep();\r\nif (!urb)\r\nreturn;\r\natomic_inc(&urb->reject);\r\nif (!urb->dev || !urb->ep)\r\nreturn;\r\nusb_hcd_unlink_urb(urb, -ENOENT);\r\nwait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);\r\n}\r\nvoid usb_unpoison_urb(struct urb *urb)\r\n{\r\nif (!urb)\r\nreturn;\r\natomic_dec(&urb->reject);\r\n}\r\nvoid usb_block_urb(struct urb *urb)\r\n{\r\nif (!urb)\r\nreturn;\r\natomic_inc(&urb->reject);\r\n}\r\nvoid usb_kill_anchored_urbs(struct usb_anchor *anchor)\r\n{\r\nstruct urb *victim;\r\nspin_lock_irq(&anchor->lock);\r\nwhile (!list_empty(&anchor->urb_list)) {\r\nvictim = list_entry(anchor->urb_list.prev, struct urb,\r\nanchor_list);\r\nusb_get_urb(victim);\r\nspin_unlock_irq(&anchor->lock);\r\nusb_kill_urb(victim);\r\nusb_put_urb(victim);\r\nspin_lock_irq(&anchor->lock);\r\n}\r\nspin_unlock_irq(&anchor->lock);\r\n}\r\nvoid usb_poison_anchored_urbs(struct usb_anchor *anchor)\r\n{\r\nstruct urb *victim;\r\nspin_lock_irq(&anchor->lock);\r\nanchor->poisoned = 1;\r\nwhile (!list_empty(&anchor->urb_list)) {\r\nvictim = list_entry(anchor->urb_list.prev, struct urb,\r\nanchor_list);\r\nusb_get_urb(victim);\r\nspin_unlock_irq(&anchor->lock);\r\nusb_poison_urb(victim);\r\nusb_put_urb(victim);\r\nspin_lock_irq(&anchor->lock);\r\n}\r\nspin_unlock_irq(&anchor->lock);\r\n}\r\nvoid usb_unpoison_anchored_urbs(struct usb_anchor *anchor)\r\n{\r\nunsigned long flags;\r\nstruct urb *lazarus;\r\nspin_lock_irqsave(&anchor->lock, flags);\r\nlist_for_each_entry(lazarus, &anchor->urb_list, anchor_list) {\r\nusb_unpoison_urb(lazarus);\r\n}\r\nanchor->poisoned = 0;\r\nspin_unlock_irqrestore(&anchor->lock, flags);\r\n}\r\nvoid usb_unlink_anchored_urbs(struct usb_anchor *anchor)\r\n{\r\nstruct urb *victim;\r\nwhile ((victim = usb_get_from_anchor(anchor)) != NULL) {\r\nusb_unlink_urb(victim);\r\nusb_put_urb(victim);\r\n}\r\n}\r\nvoid usb_anchor_suspend_wakeups(struct usb_anchor *anchor)\r\n{\r\nif (anchor)\r\natomic_inc(&anchor->suspend_wakeups);\r\n}\r\nvoid usb_anchor_resume_wakeups(struct usb_anchor *anchor)\r\n{\r\nif (!anchor)\r\nreturn;\r\natomic_dec(&anchor->suspend_wakeups);\r\nif (usb_anchor_check_wakeup(anchor))\r\nwake_up(&anchor->wait);\r\n}\r\nint usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,\r\nunsigned int timeout)\r\n{\r\nreturn wait_event_timeout(anchor->wait,\r\nusb_anchor_check_wakeup(anchor),\r\nmsecs_to_jiffies(timeout));\r\n}\r\nstruct urb *usb_get_from_anchor(struct usb_anchor *anchor)\r\n{\r\nstruct urb *victim;\r\nunsigned long flags;\r\nspin_lock_irqsave(&anchor->lock, flags);\r\nif (!list_empty(&anchor->urb_list)) {\r\nvictim = list_entry(anchor->urb_list.next, struct urb,\r\nanchor_list);\r\nusb_get_urb(victim);\r\n__usb_unanchor_urb(victim, anchor);\r\n} else {\r\nvictim = NULL;\r\n}\r\nspin_unlock_irqrestore(&anchor->lock, flags);\r\nreturn victim;\r\n}\r\nvoid usb_scuttle_anchored_urbs(struct usb_anchor *anchor)\r\n{\r\nstruct urb *victim;\r\nunsigned long flags;\r\nspin_lock_irqsave(&anchor->lock, flags);\r\nwhile (!list_empty(&anchor->urb_list)) {\r\nvictim = list_entry(anchor->urb_list.prev, struct urb,\r\nanchor_list);\r\n__usb_unanchor_urb(victim, anchor);\r\n}\r\nspin_unlock_irqrestore(&anchor->lock, flags);\r\n}\r\nint usb_anchor_empty(struct usb_anchor *anchor)\r\n{\r\nreturn list_empty(&anchor->urb_list);\r\n}
