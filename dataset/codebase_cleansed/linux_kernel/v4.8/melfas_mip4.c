static int mip4_i2c_xfer(struct mip4_ts *ts,\r\nchar *write_buf, unsigned int write_len,\r\nchar *read_buf, unsigned int read_len)\r\n{\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = ts->client->addr,\r\n.flags = 0,\r\n.buf = write_buf,\r\n.len = write_len,\r\n}, {\r\n.addr = ts->client->addr,\r\n.flags = I2C_M_RD,\r\n.buf = read_buf,\r\n.len = read_len,\r\n},\r\n};\r\nint retry = I2C_RETRY_COUNT;\r\nint res;\r\nint error;\r\ndo {\r\nres = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\r\nif (res == ARRAY_SIZE(msg))\r\nreturn 0;\r\nerror = res < 0 ? res : -EIO;\r\ndev_err(&ts->client->dev,\r\n"%s - i2c_transfer failed: %d (%d)\n",\r\n__func__, error, res);\r\n} while (--retry);\r\nreturn error;\r\n}\r\nstatic void mip4_parse_fw_version(const u8 *buf, struct mip4_fw_version *v)\r\n{\r\nv->boot = get_unaligned_le16(buf + 0);\r\nv->core = get_unaligned_le16(buf + 2);\r\nv->app = get_unaligned_le16(buf + 4);\r\nv->param = get_unaligned_le16(buf + 6);\r\n}\r\nstatic int mip4_get_fw_version(struct mip4_ts *ts)\r\n{\r\nu8 cmd[] = { MIP4_R0_INFO, MIP4_R1_INFO_VERSION_BOOT };\r\nu8 buf[sizeof(ts->fw_version)];\r\nint error;\r\nerror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), buf, sizeof(buf));\r\nif (error) {\r\nmemset(&ts->fw_version, 0xff, sizeof(ts->fw_version));\r\nreturn error;\r\n}\r\nmip4_parse_fw_version(buf, &ts->fw_version);\r\nreturn 0;\r\n}\r\nstatic int mip4_query_device(struct mip4_ts *ts)\r\n{\r\nint error;\r\nu8 cmd[2];\r\nu8 buf[14];\r\ncmd[0] = MIP4_R0_INFO;\r\ncmd[1] = MIP4_R1_INFO_PRODUCT_NAME;\r\nerror = mip4_i2c_xfer(ts, cmd, sizeof(cmd),\r\nts->product_name, sizeof(ts->product_name));\r\nif (error)\r\ndev_warn(&ts->client->dev,\r\n"Failed to retrieve product name: %d\n", error);\r\nelse\r\ndev_dbg(&ts->client->dev, "product name: %.*s\n",\r\n(int)sizeof(ts->product_name), ts->product_name);\r\nerror = mip4_get_fw_version(ts);\r\nif (error)\r\ndev_warn(&ts->client->dev,\r\n"Failed to retrieve FW version: %d\n", error);\r\nelse\r\ndev_dbg(&ts->client->dev, "F/W Version: %04X %04X %04X %04X\n",\r\nts->fw_version.boot, ts->fw_version.core,\r\nts->fw_version.app, ts->fw_version.param);\r\ncmd[0] = MIP4_R0_INFO;\r\ncmd[1] = MIP4_R1_INFO_RESOLUTION_X;\r\nerror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), buf, 14);\r\nif (error) {\r\ndev_warn(&ts->client->dev,\r\n"Failed to retrieve touchscreen parameters: %d\n",\r\nerror);\r\n} else {\r\nts->max_x = get_unaligned_le16(&buf[0]);\r\nts->max_y = get_unaligned_le16(&buf[2]);\r\ndev_dbg(&ts->client->dev, "max_x: %d, max_y: %d\n",\r\nts->max_x, ts->max_y);\r\nts->node_x = buf[4];\r\nts->node_y = buf[5];\r\nts->node_key = buf[6];\r\ndev_dbg(&ts->client->dev,\r\n"node_x: %d, node_y: %d, node_key: %d\n",\r\nts->node_x, ts->node_y, ts->node_key);\r\nts->ppm_x = buf[12];\r\nts->ppm_y = buf[13];\r\ndev_dbg(&ts->client->dev, "ppm_x: %d, ppm_y: %d\n",\r\nts->ppm_x, ts->ppm_y);\r\nif (ts->node_key > 0)\r\nts->key_num = ts->node_key;\r\n}\r\ncmd[0] = MIP4_R0_EVENT;\r\ncmd[1] = MIP4_R1_EVENT_SUPPORTED_FUNC;\r\nerror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), buf, 7);\r\nif (error) {\r\ndev_warn(&ts->client->dev,\r\n"Failed to retrieve device type: %d\n", error);\r\nts->event_format = 0xff;\r\n} else {\r\nts->event_format = get_unaligned_le16(&buf[4]);\r\nts->event_size = buf[6];\r\ndev_dbg(&ts->client->dev, "event_format: %d, event_size: %d\n",\r\nts->event_format, ts->event_size);\r\nif (ts->event_format == 2 || ts->event_format > 3)\r\ndev_warn(&ts->client->dev,\r\n"Unknown event format %d\n", ts->event_format);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mip4_power_on(struct mip4_ts *ts)\r\n{\r\nif (ts->gpio_ce) {\r\ngpiod_set_value_cansleep(ts->gpio_ce, 1);\r\nusleep_range(200 * 1000, 300 * 1000);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mip4_power_off(struct mip4_ts *ts)\r\n{\r\nif (ts->gpio_ce)\r\ngpiod_set_value_cansleep(ts->gpio_ce, 0);\r\n}\r\nstatic void mip4_clear_input(struct mip4_ts *ts)\r\n{\r\nint i;\r\nfor (i = 0; i < MIP4_MAX_FINGERS; i++) {\r\ninput_mt_slot(ts->input, i);\r\ninput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, 0);\r\n}\r\nfor (i = 0; i < ts->key_num; i++)\r\ninput_report_key(ts->input, ts->key_code[i], 0);\r\ninput_sync(ts->input);\r\n}\r\nstatic int mip4_enable(struct mip4_ts *ts)\r\n{\r\nint error;\r\nerror = mip4_power_on(ts);\r\nif (error)\r\nreturn error;\r\nenable_irq(ts->client->irq);\r\nreturn 0;\r\n}\r\nstatic void mip4_disable(struct mip4_ts *ts)\r\n{\r\ndisable_irq(ts->client->irq);\r\nmip4_power_off(ts);\r\nmip4_clear_input(ts);\r\n}\r\nstatic void mip4_report_keys(struct mip4_ts *ts, u8 *packet)\r\n{\r\nu8 key;\r\nbool down;\r\nswitch (ts->event_format) {\r\ncase 0:\r\ncase 1:\r\nkey = packet[0] & 0x0F;\r\ndown = packet[0] & 0x80;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nkey = packet[0] & 0x0F;\r\ndown = packet[1] & 0x01;\r\nbreak;\r\n}\r\nif (key >= 1 && key <= ts->key_num) {\r\nunsigned short keycode = ts->key_code[key - 1];\r\ndev_dbg(&ts->client->dev,\r\n"Key - ID: %d, keycode: %d, state: %d\n",\r\nkey, keycode, down);\r\ninput_event(ts->input, EV_MSC, MSC_SCAN, keycode);\r\ninput_report_key(ts->input, keycode, down);\r\n} else {\r\ndev_err(&ts->client->dev, "Unknown key: %d\n", key);\r\n}\r\n}\r\nstatic void mip4_report_touch(struct mip4_ts *ts, u8 *packet)\r\n{\r\nint id;\r\nbool hover;\r\nbool palm;\r\nbool state;\r\nu16 x, y;\r\nu8 pressure_stage = 0;\r\nu8 pressure;\r\nu8 size;\r\nu8 touch_major;\r\nu8 touch_minor;\r\nswitch (ts->event_format) {\r\ncase 0:\r\ncase 1:\r\nstate = packet[0] & BIT(7);\r\nhover = packet[0] & BIT(5);\r\npalm = packet[0] & BIT(4);\r\nid = (packet[0] & 0x0F) - 1;\r\nx = ((packet[1] & 0x0F) << 8) | packet[2];\r\ny = (((packet[1] >> 4) & 0x0F) << 8) |\r\npacket[3];\r\npressure = packet[4];\r\nsize = packet[5];\r\nif (ts->event_format == 0) {\r\ntouch_major = packet[5];\r\ntouch_minor = packet[5];\r\n} else {\r\ntouch_major = packet[6];\r\ntouch_minor = packet[7];\r\n}\r\nbreak;\r\ncase 3:\r\ndefault:\r\nid = (packet[0] & 0x0F) - 1;\r\nhover = packet[1] & BIT(2);\r\npalm = packet[1] & BIT(1);\r\nstate = packet[1] & BIT(0);\r\nx = ((packet[2] & 0x0F) << 8) | packet[3];\r\ny = (((packet[2] >> 4) & 0x0F) << 8) |\r\npacket[4];\r\nsize = packet[6];\r\npressure_stage = (packet[7] & 0xF0) >> 4;\r\npressure = ((packet[7] & 0x0F) << 8) |\r\npacket[8];\r\ntouch_major = packet[9];\r\ntouch_minor = packet[10];\r\nbreak;\r\n}\r\ndev_dbg(&ts->client->dev,\r\n"Screen - Slot: %d State: %d X: %04d Y: %04d Z: %d\n",\r\nid, state, x, y, pressure);\r\nif (unlikely(id < 0 || id >= MIP4_MAX_FINGERS)) {\r\ndev_err(&ts->client->dev, "Screen - invalid slot ID: %d\n", id);\r\n} else if (state) {\r\ninput_mt_slot(ts->input, id);\r\ninput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);\r\ninput_report_abs(ts->input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(ts->input, ABS_MT_POSITION_Y, y);\r\ninput_report_abs(ts->input, ABS_MT_PRESSURE, pressure);\r\ninput_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, touch_major);\r\ninput_report_abs(ts->input, ABS_MT_TOUCH_MINOR, touch_minor);\r\n} else {\r\ninput_mt_slot(ts->input, id);\r\ninput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, 0);\r\n}\r\ninput_mt_sync_frame(ts->input);\r\n}\r\nstatic int mip4_handle_packet(struct mip4_ts *ts, u8 *packet)\r\n{\r\nu8 type;\r\nswitch (ts->event_format) {\r\ncase 0:\r\ncase 1:\r\ntype = (packet[0] & 0x40) >> 6;\r\nbreak;\r\ncase 3:\r\ntype = (packet[0] & 0xF0) >> 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&ts->client->dev, "Type: %d\n", type);\r\nswitch (type) {\r\ncase MIP4_EVENT_INPUT_TYPE_KEY:\r\nmip4_report_keys(ts, packet);\r\nbreak;\r\ncase MIP4_EVENT_INPUT_TYPE_SCREEN:\r\nmip4_report_touch(ts, packet);\r\nbreak;\r\ndefault:\r\ndev_err(&ts->client->dev, "Unknown event type: %d\n", type);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mip4_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mip4_ts *ts = dev_id;\r\nstruct i2c_client *client = ts->client;\r\nunsigned int i;\r\nint error;\r\nu8 cmd[2];\r\nu8 size;\r\nbool alert;\r\ncmd[0] = MIP4_R0_EVENT;\r\ncmd[1] = MIP4_R1_EVENT_PACKET_INFO;\r\nerror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), ts->buf, 1);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to read packet info: %d\n", error);\r\ngoto out;\r\n}\r\nsize = ts->buf[0] & 0x7F;\r\nalert = ts->buf[0] & BIT(7);\r\ndev_dbg(&client->dev, "packet size: %d, alert: %d\n", size, alert);\r\nif (!size) {\r\ndev_err(&client->dev, "Empty packet\n");\r\ngoto out;\r\n}\r\ncmd[0] = MIP4_R0_EVENT;\r\ncmd[1] = MIP4_R1_EVENT_PACKET_DATA;\r\nerror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), ts->buf, size);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to read packet data: %d\n", error);\r\ngoto out;\r\n}\r\nif (alert) {\r\ndev_dbg(&client->dev, "Alert: %d\n", ts->buf[0]);\r\n} else {\r\nfor (i = 0; i < size; i += ts->event_size) {\r\nerror = mip4_handle_packet(ts, &ts->buf[i]);\r\nif (error)\r\nbreak;\r\n}\r\ninput_sync(ts->input);\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mip4_input_open(struct input_dev *dev)\r\n{\r\nstruct mip4_ts *ts = input_get_drvdata(dev);\r\nreturn mip4_enable(ts);\r\n}\r\nstatic void mip4_input_close(struct input_dev *dev)\r\n{\r\nstruct mip4_ts *ts = input_get_drvdata(dev);\r\nmip4_disable(ts);\r\n}\r\nstatic int mip4_bl_read_status(struct mip4_ts *ts)\r\n{\r\nu8 cmd[] = { MIP4_R0_BOOT, MIP4_R1_BOOT_STATUS };\r\nu8 result;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = ts->client->addr,\r\n.flags = 0,\r\n.buf = cmd,\r\n.len = sizeof(cmd),\r\n}, {\r\n.addr = ts->client->addr,\r\n.flags = I2C_M_RD,\r\n.buf = &result,\r\n.len = sizeof(result),\r\n},\r\n};\r\nint ret;\r\nint error;\r\nint retry = 1000;\r\ndo {\r\nret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\r\nif (ret != ARRAY_SIZE(msg)) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to read bootloader status: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nswitch (result) {\r\ncase MIP4_BOOT_STATUS_DONE:\r\ndev_dbg(&ts->client->dev, "%s - done\n", __func__);\r\nreturn 0;\r\ncase MIP4_BOOT_STATUS_ERROR:\r\ndev_err(&ts->client->dev, "Bootloader failure\n");\r\nreturn -EIO;\r\ncase MIP4_BOOT_STATUS_BUSY:\r\ndev_dbg(&ts->client->dev, "%s - Busy\n", __func__);\r\nerror = -EBUSY;\r\nbreak;\r\ndefault:\r\ndev_err(&ts->client->dev,\r\n"Unexpected bootloader status: %#02x\n",\r\nresult);\r\nerror = -EINVAL;\r\nbreak;\r\n}\r\nusleep_range(1000, 2000);\r\n} while (--retry);\r\nreturn error;\r\n}\r\nstatic int mip4_bl_change_mode(struct mip4_ts *ts, u8 mode)\r\n{\r\nu8 mode_chg_cmd[] = { MIP4_R0_BOOT, MIP4_R1_BOOT_MODE, mode };\r\nu8 mode_read_cmd[] = { MIP4_R0_BOOT, MIP4_R1_BOOT_MODE };\r\nu8 result;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = ts->client->addr,\r\n.flags = 0,\r\n.buf = mode_read_cmd,\r\n.len = sizeof(mode_read_cmd),\r\n}, {\r\n.addr = ts->client->addr,\r\n.flags = I2C_M_RD,\r\n.buf = &result,\r\n.len = sizeof(result),\r\n},\r\n};\r\nint retry = 10;\r\nint ret;\r\nint error;\r\ndo {\r\nret = i2c_master_send(ts->client,\r\nmode_chg_cmd, sizeof(mode_chg_cmd));\r\nif (ret != sizeof(mode_chg_cmd)) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to send %d mode change: %d (%d)\n",\r\nmode, error, ret);\r\nreturn error;\r\n}\r\ndev_dbg(&ts->client->dev,\r\n"Sent mode change request (mode: %d)\n", mode);\r\nmsleep(1000);\r\nret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\r\nif (ret != ARRAY_SIZE(msg)) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to read device mode: %d\n", error);\r\nreturn error;\r\n}\r\ndev_dbg(&ts->client->dev,\r\n"Current device mode: %d, want: %d\n", result, mode);\r\nif (result == mode)\r\nreturn 0;\r\n} while (--retry);\r\nreturn -EIO;\r\n}\r\nstatic int mip4_bl_enter(struct mip4_ts *ts)\r\n{\r\nreturn mip4_bl_change_mode(ts, MIP4_BOOT_MODE_BOOT);\r\n}\r\nstatic int mip4_bl_exit(struct mip4_ts *ts)\r\n{\r\nreturn mip4_bl_change_mode(ts, MIP4_BOOT_MODE_APP);\r\n}\r\nstatic int mip4_bl_get_address(struct mip4_ts *ts, u16 *buf_addr)\r\n{\r\nu8 cmd[] = { MIP4_R0_BOOT, MIP4_R1_BOOT_BUF_ADDR };\r\nu8 result[sizeof(u16)];\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = ts->client->addr,\r\n.flags = 0,\r\n.buf = cmd,\r\n.len = sizeof(cmd),\r\n}, {\r\n.addr = ts->client->addr,\r\n.flags = I2C_M_RD,\r\n.buf = result,\r\n.len = sizeof(result),\r\n},\r\n};\r\nint ret;\r\nint error;\r\nret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\r\nif (ret != ARRAY_SIZE(msg)) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to retrieve bootloader buffer address: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n*buf_addr = get_unaligned_le16(result);\r\ndev_dbg(&ts->client->dev,\r\n"Bootloader buffer address %#04x\n", *buf_addr);\r\nreturn 0;\r\n}\r\nstatic int mip4_bl_program_page(struct mip4_ts *ts, int offset,\r\nconst u8 *data, int length, u16 buf_addr)\r\n{\r\nu8 cmd[6];\r\nu8 *data_buf;\r\nu16 buf_offset;\r\nint ret;\r\nint error;\r\ndev_dbg(&ts->client->dev, "Writing page @%#06x (%d)\n",\r\noffset, length);\r\nif (length > MIP4_BL_PAGE_SIZE || length % MIP4_BL_PACKET_SIZE) {\r\ndev_err(&ts->client->dev,\r\n"Invalid page length: %d\n", length);\r\nreturn -EINVAL;\r\n}\r\ndata_buf = kmalloc(2 + MIP4_BL_PACKET_SIZE, GFP_KERNEL);\r\nif (!data_buf)\r\nreturn -ENOMEM;\r\ncmd[0] = MIP4_R0_BOOT;\r\ncmd[1] = MIP4_R1_BOOT_TARGET_ADDR;\r\nput_unaligned_le32(offset, &cmd[2]);\r\nret = i2c_master_send(ts->client, cmd, 6);\r\nif (ret != 6) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to send write page address: %d\n", error);\r\ngoto out;\r\n}\r\ncmd[0] = MIP4_R0_BOOT;\r\ncmd[1] = MIP4_R1_BOOT_SIZE;\r\nput_unaligned_le32(length, &cmd[2]);\r\nret = i2c_master_send(ts->client, cmd, 6);\r\nif (ret != 6) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to send write page size: %d\n", error);\r\ngoto out;\r\n}\r\nfor (buf_offset = 0;\r\nbuf_offset < length;\r\nbuf_offset += MIP4_BL_PACKET_SIZE) {\r\ndev_dbg(&ts->client->dev,\r\n"writing chunk at %#04x (size %d)\n",\r\nbuf_offset, MIP4_BL_PACKET_SIZE);\r\nput_unaligned_be16(buf_addr + buf_offset, data_buf);\r\nmemcpy(&data_buf[2], &data[buf_offset], MIP4_BL_PACKET_SIZE);\r\nret = i2c_master_send(ts->client,\r\ndata_buf, 2 + MIP4_BL_PACKET_SIZE);\r\nif (ret != 2 + MIP4_BL_PACKET_SIZE) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to read chunk at %#04x (size %d): %d\n",\r\nbuf_offset, MIP4_BL_PACKET_SIZE, error);\r\ngoto out;\r\n}\r\n}\r\ncmd[0] = MIP4_R0_BOOT;\r\ncmd[1] = MIP4_R1_BOOT_CMD;\r\ncmd[2] = MIP4_BOOT_CMD_PROGRAM;\r\nret = i2c_master_send(ts->client, cmd, 3);\r\nif (ret != 3) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to send 'write' command: %d\n", error);\r\ngoto out;\r\n}\r\nerror = mip4_bl_read_status(ts);\r\nout:\r\nkfree(data_buf);\r\nreturn error ? error : 0;\r\n}\r\nstatic int mip4_bl_verify_page(struct mip4_ts *ts, int offset,\r\nconst u8 *data, int length, int buf_addr)\r\n{\r\nu8 cmd[8];\r\nu8 *read_buf;\r\nint buf_offset;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = ts->client->addr,\r\n.flags = 0,\r\n.buf = cmd,\r\n.len = 2,\r\n}, {\r\n.addr = ts->client->addr,\r\n.flags = I2C_M_RD,\r\n.len = MIP4_BL_PACKET_SIZE,\r\n},\r\n};\r\nint ret;\r\nint error;\r\ndev_dbg(&ts->client->dev, "Validating page @%#06x (%d)\n",\r\noffset, length);\r\ncmd[0] = MIP4_R0_BOOT;\r\ncmd[1] = MIP4_R1_BOOT_TARGET_ADDR;\r\nput_unaligned_le32(offset, &cmd[2]);\r\nret = i2c_master_send(ts->client, cmd, 6);\r\nif (ret != 6) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to send read page address: %d\n", error);\r\nreturn error;\r\n}\r\ncmd[0] = MIP4_R0_BOOT;\r\ncmd[1] = MIP4_R1_BOOT_SIZE;\r\nput_unaligned_le32(length, &cmd[2]);\r\nret = i2c_master_send(ts->client, cmd, 6);\r\nif (ret != 6) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to send read page size: %d\n", error);\r\nreturn error;\r\n}\r\ncmd[0] = MIP4_R0_BOOT;\r\ncmd[1] = MIP4_R1_BOOT_CMD;\r\ncmd[2] = MIP4_BOOT_CMD_READ;\r\nret = i2c_master_send(ts->client, cmd, 3);\r\nif (ret != 3) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to send 'read' command: %d\n", error);\r\nreturn error;\r\n}\r\nerror = mip4_bl_read_status(ts);\r\nif (error)\r\nreturn error;\r\nmsg[1].buf = read_buf = kmalloc(MIP4_BL_PACKET_SIZE, GFP_KERNEL);\r\nif (!read_buf)\r\nreturn -ENOMEM;\r\nfor (buf_offset = 0;\r\nbuf_offset < length;\r\nbuf_offset += MIP4_BL_PACKET_SIZE) {\r\ndev_dbg(&ts->client->dev,\r\n"reading chunk at %#04x (size %d)\n",\r\nbuf_offset, MIP4_BL_PACKET_SIZE);\r\nput_unaligned_be16(buf_addr + buf_offset, cmd);\r\nret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\r\nif (ret != ARRAY_SIZE(msg)) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&ts->client->dev,\r\n"Failed to read chunk at %#04x (size %d): %d\n",\r\nbuf_offset, MIP4_BL_PACKET_SIZE, error);\r\nbreak;\r\n}\r\nif (memcmp(&data[buf_offset], read_buf, MIP4_BL_PACKET_SIZE)) {\r\ndev_err(&ts->client->dev,\r\n"Failed to validate chunk at %#04x (size %d)\n",\r\nbuf_offset, MIP4_BL_PACKET_SIZE);\r\n#if MIP4_FW_UPDATE_DEBUG\r\nprint_hex_dump(KERN_DEBUG,\r\nMIP4_DEVICE_NAME " F/W File: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\ndata + offset, MIP4_BL_PACKET_SIZE,\r\nfalse);\r\nprint_hex_dump(KERN_DEBUG,\r\nMIP4_DEVICE_NAME " F/W Chip: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nread_buf, MIP4_BL_PAGE_SIZE, false);\r\n#endif\r\nerror = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nkfree(read_buf);\r\nreturn error ? error : 0;\r\n}\r\nstatic int mip4_flash_fw(struct mip4_ts *ts,\r\nconst u8 *fw_data, u32 fw_size, u32 fw_offset)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint offset;\r\nu16 buf_addr;\r\nint error, error2;\r\ndev_dbg(&client->dev, "Entering bootloader mode\n");\r\nerror = mip4_bl_enter(ts);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to enter bootloader mode: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = mip4_bl_get_address(ts, &buf_addr);\r\nif (error)\r\ngoto exit_bl;\r\ndev_dbg(&client->dev,\r\n"Program & Verify, page size: %d, packet size: %d\n",\r\nMIP4_BL_PAGE_SIZE, MIP4_BL_PACKET_SIZE);\r\nfor (offset = fw_offset;\r\noffset < fw_offset + fw_size;\r\noffset += MIP4_BL_PAGE_SIZE) {\r\nerror = mip4_bl_program_page(ts, offset, fw_data + offset,\r\nMIP4_BL_PAGE_SIZE, buf_addr);\r\nif (error)\r\nbreak;\r\nerror = mip4_bl_verify_page(ts, offset, fw_data + offset,\r\nMIP4_BL_PAGE_SIZE, buf_addr);\r\nif (error)\r\nbreak;\r\n}\r\nexit_bl:\r\ndev_dbg(&client->dev, "Exiting bootloader mode\n");\r\nerror2 = mip4_bl_exit(ts);\r\nif (error2) {\r\ndev_err(&client->dev,\r\n"Failed to exit bootloader mode: %d\n", error2);\r\nif (!error)\r\nerror = error2;\r\n}\r\nmip4_power_off(ts);\r\nmip4_power_on(ts);\r\nmip4_query_device(ts);\r\ninput_set_abs_params(ts->input, ABS_MT_POSITION_X, 0, ts->max_x, 0, 0);\r\ninput_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0, ts->max_y, 0, 0);\r\ninput_set_abs_params(ts->input, ABS_X, 0, ts->max_x, 0, 0);\r\ninput_set_abs_params(ts->input, ABS_Y, 0, ts->max_y, 0, 0);\r\ninput_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->ppm_x);\r\ninput_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->ppm_y);\r\ninput_abs_set_res(ts->input, ABS_X, ts->ppm_x);\r\ninput_abs_set_res(ts->input, ABS_Y, ts->ppm_y);\r\nreturn error ? error : 0;\r\n}\r\nstatic int mip4_parse_firmware(struct mip4_ts *ts, const struct firmware *fw,\r\nu32 *fw_offset_start, u32 *fw_size,\r\nconst struct mip4_bin_tail **pfw_info)\r\n{\r\nconst struct mip4_bin_tail *fw_info;\r\nstruct mip4_fw_version fw_version;\r\nu16 tail_size;\r\nif (fw->size < MIP4_BIN_TAIL_SIZE) {\r\ndev_err(&ts->client->dev,\r\n"Invalid firmware, size mismatch (tail %zd vs %zd)\n",\r\nMIP4_BIN_TAIL_SIZE, fw->size);\r\nreturn -EINVAL;\r\n}\r\nfw_info = (const void *)&fw->data[fw->size - MIP4_BIN_TAIL_SIZE];\r\n#if MIP4_FW_UPDATE_DEBUG\r\nprint_hex_dump(KERN_ERR, MIP4_DEVICE_NAME " Bin Info: ",\r\nDUMP_PREFIX_OFFSET, 16, 1, *fw_info, tail_size, false);\r\n#endif\r\ntail_size = get_unaligned_le16(&fw_info->tail_size);\r\nif (tail_size != MIP4_BIN_TAIL_SIZE) {\r\ndev_err(&ts->client->dev,\r\n"wrong tail size: %d (expected %zd)\n",\r\ntail_size, MIP4_BIN_TAIL_SIZE);\r\nreturn -EINVAL;\r\n}\r\nif (memcmp(fw_info->tail_mark, MIP4_BIN_TAIL_MARK,\r\nsizeof(fw_info->tail_mark))) {\r\ndev_err(&ts->client->dev,\r\n"unable to locate tail marker (%*ph vs %*ph)\n",\r\n(int)sizeof(fw_info->tail_mark), fw_info->tail_mark,\r\n(int)sizeof(fw_info->tail_mark), MIP4_BIN_TAIL_MARK);\r\nreturn -EINVAL;\r\n}\r\n*fw_offset_start = get_unaligned_le32(&fw_info->bin_start_addr);\r\n*fw_size = get_unaligned_le32(&fw_info->bin_length);\r\ndev_dbg(&ts->client->dev,\r\n"F/W Data offset: %#08x, size: %d\n",\r\n*fw_offset_start, *fw_size);\r\nif (*fw_size % MIP4_BL_PAGE_SIZE) {\r\ndev_err(&ts->client->dev,\r\n"encoded fw length %d is not multiple of pages (%d)\n",\r\n*fw_size, MIP4_BL_PAGE_SIZE);\r\nreturn -EINVAL;\r\n}\r\nif (fw->size != *fw_offset_start + *fw_size) {\r\ndev_err(&ts->client->dev,\r\n"Wrong firmware size, expected %d bytes, got %zd\n",\r\n*fw_offset_start + *fw_size, fw->size);\r\nreturn -EINVAL;\r\n}\r\nmip4_parse_fw_version((const u8 *)&fw_info->ver_boot, &fw_version);\r\ndev_dbg(&ts->client->dev,\r\n"F/W file version %04X %04X %04X %04X\n",\r\nfw_version.boot, fw_version.core,\r\nfw_version.app, fw_version.param);\r\ndev_dbg(&ts->client->dev, "F/W chip version: %04X %04X %04X %04X\n",\r\nts->fw_version.boot, ts->fw_version.core,\r\nts->fw_version.app, ts->fw_version.param);\r\nif (fw_version.boot != 0xEEEE && fw_version.boot != 0xFFFF &&\r\nfw_version.core == 0xEEEE &&\r\nfw_version.app == 0xEEEE &&\r\nfw_version.param == 0xEEEE) {\r\ndev_dbg(&ts->client->dev, "F/W type: Bootloader\n");\r\n} else if (fw_version.boot == 0xEEEE &&\r\nfw_version.core != 0xEEEE && fw_version.core != 0xFFFF &&\r\nfw_version.app != 0xEEEE && fw_version.app != 0xFFFF &&\r\nfw_version.param != 0xEEEE && fw_version.param != 0xFFFF) {\r\ndev_dbg(&ts->client->dev, "F/W type: Main\n");\r\n} else {\r\ndev_err(&ts->client->dev, "Wrong firmware type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mip4_execute_fw_update(struct mip4_ts *ts, const struct firmware *fw)\r\n{\r\nconst struct mip4_bin_tail *fw_info;\r\nu32 fw_start_offset;\r\nu32 fw_size;\r\nint retires = 3;\r\nint error;\r\nerror = mip4_parse_firmware(ts, fw,\r\n&fw_start_offset, &fw_size, &fw_info);\r\nif (error)\r\nreturn error;\r\nif (ts->input->users) {\r\ndisable_irq(ts->client->irq);\r\n} else {\r\nerror = mip4_power_on(ts);\r\nif (error)\r\nreturn error;\r\n}\r\ndo {\r\nerror = mip4_flash_fw(ts, fw->data, fw_size, fw_start_offset);\r\nif (!error)\r\nbreak;\r\n} while (--retires);\r\nif (error)\r\ndev_err(&ts->client->dev,\r\n"Failed to flash firmware: %d\n", error);\r\nif (ts->input->users)\r\nenable_irq(ts->client->irq);\r\nelse\r\nmip4_power_off(ts);\r\nreturn error ? error : 0;\r\n}\r\nstatic ssize_t mip4_sysfs_fw_update(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mip4_ts *ts = i2c_get_clientdata(client);\r\nconst struct firmware *fw;\r\nint error;\r\nerror = request_firmware(&fw, MIP4_FW_NAME, dev);\r\nif (error) {\r\ndev_err(&ts->client->dev,\r\n"Failed to retrieve firmware %s: %d\n",\r\nMIP4_FW_NAME, error);\r\nreturn error;\r\n}\r\nmutex_lock(&ts->input->mutex);\r\nerror = mip4_execute_fw_update(ts, fw);\r\nmutex_unlock(&ts->input->mutex);\r\nrelease_firmware(fw);\r\nif (error) {\r\ndev_err(&ts->client->dev,\r\n"Firmware update failed: %d\n", error);\r\nreturn error;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t mip4_sysfs_read_fw_version(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mip4_ts *ts = i2c_get_clientdata(client);\r\nsize_t count;\r\nmutex_lock(&ts->input->mutex);\r\ncount = snprintf(buf, PAGE_SIZE, "%04X %04X %04X %04X\n",\r\nts->fw_version.boot, ts->fw_version.core,\r\nts->fw_version.app, ts->fw_version.param);\r\nmutex_unlock(&ts->input->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t mip4_sysfs_read_hw_version(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mip4_ts *ts = i2c_get_clientdata(client);\r\nsize_t count;\r\nmutex_lock(&ts->input->mutex);\r\ncount = snprintf(buf, PAGE_SIZE, "%.*s\n",\r\n(int)sizeof(ts->product_name), ts->product_name);\r\nmutex_unlock(&ts->input->mutex);\r\nreturn count;\r\n}\r\nstatic void mip4_sysfs_remove(void *_data)\r\n{\r\nstruct mip4_ts *ts = _data;\r\nsysfs_remove_group(&ts->client->dev.kobj, &mip4_attr_group);\r\n}\r\nstatic int mip4_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct mip4_ts *ts;\r\nstruct input_dev *input;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "Not supported I2C adapter\n");\r\nreturn -ENXIO;\r\n}\r\nts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\ninput = devm_input_allocate_device(&client->dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\nts->client = client;\r\nts->input = input;\r\nsnprintf(ts->phys, sizeof(ts->phys),\r\n"%s/input0", dev_name(&client->dev));\r\nts->gpio_ce = devm_gpiod_get_optional(&client->dev,\r\n"ce", GPIOD_OUT_LOW);\r\nif (IS_ERR(ts->gpio_ce)) {\r\nerror = PTR_ERR(ts->gpio_ce);\r\nif (error != EPROBE_DEFER)\r\ndev_err(&client->dev,\r\n"Failed to get gpio: %d\n", error);\r\nreturn error;\r\n}\r\nerror = mip4_power_on(ts);\r\nif (error)\r\nreturn error;\r\nerror = mip4_query_device(ts);\r\nmip4_power_off(ts);\r\nif (error)\r\nreturn error;\r\ninput->name = "MELFAS MIP4 Touchscreen";\r\ninput->phys = ts->phys;\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.vendor = 0x13c5;\r\ninput->open = mip4_input_open;\r\ninput->close = mip4_input_close;\r\ninput_set_drvdata(input, ts);\r\ninput->keycode = ts->key_code;\r\ninput->keycodesize = sizeof(*ts->key_code);\r\ninput->keycodemax = ts->key_num;\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, ts->max_x, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, ts->max_y, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_PRESSURE,\r\nMIP4_PRESSURE_MIN, MIP4_PRESSURE_MAX, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MAJOR,\r\nMIP4_TOUCH_MAJOR_MIN, MIP4_TOUCH_MAJOR_MAX, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MINOR,\r\nMIP4_TOUCH_MINOR_MIN, MIP4_TOUCH_MINOR_MAX, 0, 0);\r\ninput_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->ppm_x);\r\ninput_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->ppm_y);\r\nerror = input_mt_init_slots(input, MIP4_MAX_FINGERS, INPUT_MT_DIRECT);\r\nif (error)\r\nreturn error;\r\ni2c_set_clientdata(client, ts);\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, mip4_interrupt,\r\nIRQF_ONESHOT, MIP4_DEVICE_NAME, ts);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to request interrupt %d: %d\n",\r\nclient->irq, error);\r\nreturn error;\r\n}\r\ndisable_irq(client->irq);\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nerror = sysfs_create_group(&client->dev.kobj, &mip4_attr_group);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to create sysfs attribute group: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_add_action(&client->dev, mip4_sysfs_remove, ts);\r\nif (error) {\r\nmip4_sysfs_remove(ts);\r\ndev_err(&client->dev,\r\n"Failed to install sysfs remoce action: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mip4_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mip4_ts *ts = i2c_get_clientdata(client);\r\nstruct input_dev *input = ts->input;\r\nmutex_lock(&input->mutex);\r\nif (device_may_wakeup(dev))\r\nts->wake_irq_enabled = enable_irq_wake(client->irq) == 0;\r\nelse if (input->users)\r\nmip4_disable(ts);\r\nmutex_unlock(&input->mutex);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mip4_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mip4_ts *ts = i2c_get_clientdata(client);\r\nstruct input_dev *input = ts->input;\r\nmutex_lock(&input->mutex);\r\nif (ts->wake_irq_enabled)\r\ndisable_irq_wake(client->irq);\r\nelse if (input->users)\r\nmip4_enable(ts);\r\nmutex_unlock(&input->mutex);\r\nreturn 0;\r\n}
