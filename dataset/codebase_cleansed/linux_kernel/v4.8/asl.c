static void qset_get_next_prev(struct whc *whc, struct whc_qset *qset,\r\nstruct whc_qset **next, struct whc_qset **prev)\r\n{\r\nstruct list_head *n, *p;\r\nBUG_ON(list_empty(&whc->async_list));\r\nn = qset->list_node.next;\r\nif (n == &whc->async_list)\r\nn = n->next;\r\np = qset->list_node.prev;\r\nif (p == &whc->async_list)\r\np = p->prev;\r\n*next = container_of(n, struct whc_qset, list_node);\r\n*prev = container_of(p, struct whc_qset, list_node);\r\n}\r\nstatic void asl_qset_insert_begin(struct whc *whc, struct whc_qset *qset)\r\n{\r\nlist_move(&qset->list_node, &whc->async_list);\r\nqset->in_sw_list = true;\r\n}\r\nstatic void asl_qset_insert(struct whc *whc, struct whc_qset *qset)\r\n{\r\nstruct whc_qset *next, *prev;\r\nqset_clear(whc, qset);\r\nqset_get_next_prev(whc, qset, &next, &prev);\r\nwhc_qset_set_link_ptr(&qset->qh.link, next->qset_dma);\r\nwhc_qset_set_link_ptr(&prev->qh.link, qset->qset_dma);\r\nqset->in_hw_list = true;\r\n}\r\nstatic void asl_qset_remove(struct whc *whc, struct whc_qset *qset)\r\n{\r\nstruct whc_qset *prev, *next;\r\nqset_get_next_prev(whc, qset, &next, &prev);\r\nlist_move(&qset->list_node, &whc->async_removed_list);\r\nqset->in_sw_list = false;\r\nif (list_empty(&whc->async_list))\r\nreturn;\r\nwhc_qset_set_link_ptr(&prev->qh.link, next->qset_dma);\r\nqset->in_hw_list = false;\r\n}\r\nstatic uint32_t process_qset(struct whc *whc, struct whc_qset *qset)\r\n{\r\nenum whc_update update = 0;\r\nuint32_t status = 0;\r\nwhile (qset->ntds) {\r\nstruct whc_qtd *td;\r\nint t;\r\nt = qset->td_start;\r\ntd = &qset->qtd[qset->td_start];\r\nstatus = le32_to_cpu(td->status);\r\nif (status & QTD_STS_ACTIVE)\r\nbreak;\r\nif (status & QTD_STS_HALTED) {\r\nprocess_halted_qtd(whc, qset, td);\r\nupdate |= WHC_UPDATE_UPDATED;\r\ngoto done;\r\n}\r\nprocess_inactive_qtd(whc, qset, td);\r\n}\r\nif (!qset->remove)\r\nupdate |= qset_add_qtds(whc, qset);\r\ndone:\r\nif (qset->remove && qset->ntds == 0) {\r\nasl_qset_remove(whc, qset);\r\nupdate |= WHC_UPDATE_REMOVED;\r\n}\r\nreturn update;\r\n}\r\nvoid asl_start(struct whc *whc)\r\n{\r\nstruct whc_qset *qset;\r\nqset = list_first_entry(&whc->async_list, struct whc_qset, list_node);\r\nle_writeq(qset->qset_dma | QH_LINK_NTDS(8), whc->base + WUSBASYNCLISTADDR);\r\nwhc_write_wusbcmd(whc, WUSBCMD_ASYNC_EN, WUSBCMD_ASYNC_EN);\r\nwhci_wait_for(&whc->umc->dev, whc->base + WUSBSTS,\r\nWUSBSTS_ASYNC_SCHED, WUSBSTS_ASYNC_SCHED,\r\n1000, "start ASL");\r\n}\r\nvoid asl_stop(struct whc *whc)\r\n{\r\nwhc_write_wusbcmd(whc, WUSBCMD_ASYNC_EN, 0);\r\nwhci_wait_for(&whc->umc->dev, whc->base + WUSBSTS,\r\nWUSBSTS_ASYNC_SCHED, 0,\r\n1000, "stop ASL");\r\n}\r\nvoid asl_update(struct whc *whc, uint32_t wusbcmd)\r\n{\r\nstruct wusbhc *wusbhc = &whc->wusbhc;\r\nlong t;\r\nmutex_lock(&wusbhc->mutex);\r\nif (wusbhc->active) {\r\nwhc_write_wusbcmd(whc, wusbcmd, wusbcmd);\r\nt = wait_event_timeout(\r\nwhc->async_list_wq,\r\n(le_readl(whc->base + WUSBCMD) & WUSBCMD_ASYNC_UPDATED) == 0,\r\nmsecs_to_jiffies(1000));\r\nif (t == 0)\r\nwhc_hw_error(whc, "ASL update timeout");\r\n}\r\nmutex_unlock(&wusbhc->mutex);\r\n}\r\nvoid scan_async_work(struct work_struct *work)\r\n{\r\nstruct whc *whc = container_of(work, struct whc, async_work);\r\nstruct whc_qset *qset, *t;\r\nenum whc_update update = 0;\r\nspin_lock_irq(&whc->lock);\r\nlist_for_each_entry_safe_reverse(qset, t, &whc->async_list, list_node) {\r\nif (!qset->in_hw_list) {\r\nasl_qset_insert(whc, qset);\r\nupdate |= WHC_UPDATE_ADDED;\r\n}\r\nupdate |= process_qset(whc, qset);\r\n}\r\nspin_unlock_irq(&whc->lock);\r\nif (update) {\r\nuint32_t wusbcmd = WUSBCMD_ASYNC_UPDATED | WUSBCMD_ASYNC_SYNCED_DB;\r\nif (update & WHC_UPDATE_REMOVED)\r\nwusbcmd |= WUSBCMD_ASYNC_QSET_RM;\r\nasl_update(whc, wusbcmd);\r\n}\r\nspin_lock_irq(&whc->lock);\r\nlist_for_each_entry_safe(qset, t, &whc->async_removed_list, list_node) {\r\nqset_remove_complete(whc, qset);\r\nif (qset->reset) {\r\nqset_reset(whc, qset);\r\nif (!list_empty(&qset->stds)) {\r\nasl_qset_insert_begin(whc, qset);\r\nqueue_work(whc->workqueue, &whc->async_work);\r\n}\r\n}\r\n}\r\nspin_unlock_irq(&whc->lock);\r\n}\r\nint asl_urb_enqueue(struct whc *whc, struct urb *urb, gfp_t mem_flags)\r\n{\r\nstruct whc_qset *qset;\r\nint err;\r\nunsigned long flags;\r\nspin_lock_irqsave(&whc->lock, flags);\r\nerr = usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);\r\nif (err < 0) {\r\nspin_unlock_irqrestore(&whc->lock, flags);\r\nreturn err;\r\n}\r\nqset = get_qset(whc, urb, GFP_ATOMIC);\r\nif (qset == NULL)\r\nerr = -ENOMEM;\r\nelse\r\nerr = qset_add_urb(whc, qset, urb, GFP_ATOMIC);\r\nif (!err) {\r\nif (!qset->in_sw_list && !qset->remove)\r\nasl_qset_insert_begin(whc, qset);\r\n} else\r\nusb_hcd_unlink_urb_from_ep(&whc->wusbhc.usb_hcd, urb);\r\nspin_unlock_irqrestore(&whc->lock, flags);\r\nif (!err)\r\nqueue_work(whc->workqueue, &whc->async_work);\r\nreturn err;\r\n}\r\nint asl_urb_dequeue(struct whc *whc, struct urb *urb, int status)\r\n{\r\nstruct whc_urb *wurb = urb->hcpriv;\r\nstruct whc_qset *qset = wurb->qset;\r\nstruct whc_std *std, *t;\r\nbool has_qtd = false;\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&whc->lock, flags);\r\nret = usb_hcd_check_unlink_urb(&whc->wusbhc.usb_hcd, urb, status);\r\nif (ret < 0)\r\ngoto out;\r\nlist_for_each_entry_safe(std, t, &qset->stds, list_node) {\r\nif (std->urb == urb) {\r\nif (std->qtd)\r\nhas_qtd = true;\r\nqset_free_std(whc, std);\r\n} else\r\nstd->qtd = NULL;\r\n}\r\nif (has_qtd) {\r\nasl_qset_remove(whc, qset);\r\nwurb->status = status;\r\nwurb->is_async = true;\r\nqueue_work(whc->workqueue, &wurb->dequeue_work);\r\n} else\r\nqset_remove_urb(whc, qset, urb, status);\r\nout:\r\nspin_unlock_irqrestore(&whc->lock, flags);\r\nreturn ret;\r\n}\r\nvoid asl_qset_delete(struct whc *whc, struct whc_qset *qset)\r\n{\r\nqset->remove = 1;\r\nqueue_work(whc->workqueue, &whc->async_work);\r\nqset_delete(whc, qset);\r\n}\r\nint asl_init(struct whc *whc)\r\n{\r\nstruct whc_qset *qset;\r\nqset = qset_alloc(whc, GFP_KERNEL);\r\nif (qset == NULL)\r\nreturn -ENOMEM;\r\nasl_qset_insert_begin(whc, qset);\r\nasl_qset_insert(whc, qset);\r\nreturn 0;\r\n}\r\nvoid asl_clean_up(struct whc *whc)\r\n{\r\nstruct whc_qset *qset;\r\nif (!list_empty(&whc->async_list)) {\r\nqset = list_first_entry(&whc->async_list, struct whc_qset, list_node);\r\nlist_del(&qset->list_node);\r\nqset_free(whc, qset);\r\n}\r\n}
