static void trace_block(struct slgt_info *info, const char *data, int count, const char *label)\r\n{\r\nint i;\r\nint linecount;\r\nprintk("%s %s data:\n",info->device_name, label);\r\nwhile(count) {\r\nlinecount = (count > 16) ? 16 : count;\r\nfor(i=0; i < linecount; i++)\r\nprintk("%02X ",(unsigned char)data[i]);\r\nfor(;i<17;i++)\r\nprintk(" ");\r\nfor(i=0;i<linecount;i++) {\r\nif (data[i]>=040 && data[i]<=0176)\r\nprintk("%c",data[i]);\r\nelse\r\nprintk(".");\r\n}\r\nprintk("\n");\r\ndata += linecount;\r\ncount -= linecount;\r\n}\r\n}\r\nstatic void dump_tbufs(struct slgt_info *info)\r\n{\r\nint i;\r\nprintk("tbuf_current=%d\n", info->tbuf_current);\r\nfor (i=0 ; i < info->tbuf_count ; i++) {\r\nprintk("%d: count=%04X status=%04X\n",\r\ni, le16_to_cpu(info->tbufs[i].count), le16_to_cpu(info->tbufs[i].status));\r\n}\r\n}\r\nstatic void dump_rbufs(struct slgt_info *info)\r\n{\r\nint i;\r\nprintk("rbuf_current=%d\n", info->rbuf_current);\r\nfor (i=0 ; i < info->rbuf_count ; i++) {\r\nprintk("%d: count=%04X status=%04X\n",\r\ni, le16_to_cpu(info->rbufs[i].count), le16_to_cpu(info->rbufs[i].status));\r\n}\r\n}\r\nstatic inline int sanity_check(struct slgt_info *info, char *devname, const char *name)\r\n{\r\n#ifdef SANITY_CHECK\r\nif (!info) {\r\nprintk("null struct slgt_info for (%s) in %s\n", devname, name);\r\nreturn 1;\r\n}\r\nif (info->magic != MGSL_MAGIC) {\r\nprintk("bad magic number struct slgt_info (%s) in %s\n", devname, name);\r\nreturn 1;\r\n}\r\n#else\r\nif (!info)\r\nreturn 1;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void ldisc_receive_buf(struct tty_struct *tty,\r\nconst __u8 *data, char *flags, int count)\r\n{\r\nstruct tty_ldisc *ld;\r\nif (!tty)\r\nreturn;\r\nld = tty_ldisc_ref(tty);\r\nif (ld) {\r\nif (ld->ops->receive_buf)\r\nld->ops->receive_buf(tty, data, flags, count);\r\ntty_ldisc_deref(ld);\r\n}\r\n}\r\nstatic int open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct slgt_info *info;\r\nint retval, line;\r\nunsigned long flags;\r\nline = tty->index;\r\nif (line >= slgt_device_count) {\r\nDBGERR(("%s: open with invalid line #%d.\n", driver_name, line));\r\nreturn -ENODEV;\r\n}\r\ninfo = slgt_device_list;\r\nwhile(info && info->line != line)\r\ninfo = info->next_device;\r\nif (sanity_check(info, tty->name, "open"))\r\nreturn -ENODEV;\r\nif (info->init_error) {\r\nDBGERR(("%s init error=%d\n", info->device_name, info->init_error));\r\nreturn -ENODEV;\r\n}\r\ntty->driver_data = info;\r\ninfo->port.tty = tty;\r\nDBGINFO(("%s open, old ref count = %d\n", info->device_name, info->port.count));\r\nmutex_lock(&info->port.mutex);\r\ninfo->port.low_latency = (info->port.flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\nspin_lock_irqsave(&info->netlock, flags);\r\nif (info->netcount) {\r\nretval = -EBUSY;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nmutex_unlock(&info->port.mutex);\r\ngoto cleanup;\r\n}\r\ninfo->port.count++;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nif (info->port.count == 1) {\r\nretval = startup(info);\r\nif (retval < 0) {\r\nmutex_unlock(&info->port.mutex);\r\ngoto cleanup;\r\n}\r\n}\r\nmutex_unlock(&info->port.mutex);\r\nretval = block_til_ready(tty, filp, info);\r\nif (retval) {\r\nDBGINFO(("%s block_til_ready rc=%d\n", info->device_name, retval));\r\ngoto cleanup;\r\n}\r\nretval = 0;\r\ncleanup:\r\nif (retval) {\r\nif (tty->count == 1)\r\ninfo->port.tty = NULL;\r\nif(info->port.count)\r\ninfo->port.count--;\r\n}\r\nDBGINFO(("%s open rc=%d\n", info->device_name, retval));\r\nreturn retval;\r\n}\r\nstatic void close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nif (sanity_check(info, tty->name, "close"))\r\nreturn;\r\nDBGINFO(("%s close entry, count=%d\n", info->device_name, info->port.count));\r\nif (tty_port_close_start(&info->port, tty, filp) == 0)\r\ngoto cleanup;\r\nmutex_lock(&info->port.mutex);\r\nif (tty_port_initialized(&info->port))\r\nwait_until_sent(tty, info->timeout);\r\nflush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\nshutdown(info);\r\nmutex_unlock(&info->port.mutex);\r\ntty_port_close_end(&info->port, tty);\r\ninfo->port.tty = NULL;\r\ncleanup:\r\nDBGINFO(("%s close exit, count=%d\n", tty->driver->name, info->port.count));\r\n}\r\nstatic void hangup(struct tty_struct *tty)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "hangup"))\r\nreturn;\r\nDBGINFO(("%s hangup\n", info->device_name));\r\nflush_buffer(tty);\r\nmutex_lock(&info->port.mutex);\r\nshutdown(info);\r\nspin_lock_irqsave(&info->port.lock, flags);\r\ninfo->port.count = 0;\r\ninfo->port.tty = NULL;\r\nspin_unlock_irqrestore(&info->port.lock, flags);\r\ntty_port_set_active(&info->port, 0);\r\nmutex_unlock(&info->port.mutex);\r\nwake_up_interruptible(&info->port.open_wait);\r\n}\r\nstatic void set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nDBGINFO(("%s set_termios\n", tty->driver->name));\r\nchange_params(info);\r\nif ((old_termios->c_cflag & CBAUD) && !C_BAUD(tty)) {\r\ninfo->signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nspin_lock_irqsave(&info->lock,flags);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nif (!(old_termios->c_cflag & CBAUD) && C_BAUD(tty)) {\r\ninfo->signals |= SerialSignal_DTR;\r\nif (!C_CRTSCTS(tty) || !tty_throttled(tty))\r\ninfo->signals |= SerialSignal_RTS;\r\nspin_lock_irqsave(&info->lock,flags);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nif ((old_termios->c_cflag & CRTSCTS) && !C_CRTSCTS(tty)) {\r\ntty->hw_stopped = 0;\r\ntx_release(tty);\r\n}\r\n}\r\nstatic void update_tx_timer(struct slgt_info *info)\r\n{\r\nif (info->params.mode == MGSL_MODE_HDLC) {\r\nint timeout = (tbuf_bytes(info) * 7) + 1000;\r\nmod_timer(&info->tx_timer, jiffies + msecs_to_jiffies(timeout));\r\n}\r\n}\r\nstatic int write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nint ret = 0;\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "write"))\r\nreturn -EIO;\r\nDBGINFO(("%s write count=%d\n", info->device_name, count));\r\nif (!info->tx_buf || (count > info->max_frame_size))\r\nreturn -EIO;\r\nif (!count || tty->stopped || tty->hw_stopped)\r\nreturn 0;\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (info->tx_count) {\r\nif (!tx_load(info, info->tx_buf, info->tx_count))\r\ngoto cleanup;\r\ninfo->tx_count = 0;\r\n}\r\nif (tx_load(info, buf, count))\r\nret = count;\r\ncleanup:\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nDBGINFO(("%s write rc=%d\n", info->device_name, ret));\r\nreturn ret;\r\n}\r\nstatic int put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (sanity_check(info, tty->name, "put_char"))\r\nreturn 0;\r\nDBGINFO(("%s put_char(%d)\n", info->device_name, ch));\r\nif (!info->tx_buf)\r\nreturn 0;\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (info->tx_count < info->max_frame_size) {\r\ninfo->tx_buf[info->tx_count++] = ch;\r\nret = 1;\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn ret;\r\n}\r\nstatic void send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "send_xchar"))\r\nreturn;\r\nDBGINFO(("%s send_xchar(%d)\n", info->device_name, ch));\r\ninfo->x_char = ch;\r\nif (ch) {\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (!info->tx_enabled)\r\ntx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\n}\r\nstatic void wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long orig_jiffies, char_time;\r\nif (!info )\r\nreturn;\r\nif (sanity_check(info, tty->name, "wait_until_sent"))\r\nreturn;\r\nDBGINFO(("%s wait_until_sent entry\n", info->device_name));\r\nif (!tty_port_initialized(&info->port))\r\ngoto exit;\r\norig_jiffies = jiffies;\r\nif (info->params.data_rate) {\r\nchar_time = info->timeout/(32 * 5);\r\nif (!char_time)\r\nchar_time++;\r\n} else\r\nchar_time = 1;\r\nif (timeout)\r\nchar_time = min_t(unsigned long, char_time, timeout);\r\nwhile (info->tx_active) {\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\nexit:\r\nDBGINFO(("%s wait_until_sent exit\n", info->device_name));\r\n}\r\nstatic int write_room(struct tty_struct *tty)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nint ret;\r\nif (sanity_check(info, tty->name, "write_room"))\r\nreturn 0;\r\nret = (info->tx_active) ? 0 : HDLC_MAX_FRAME_SIZE;\r\nDBGINFO(("%s write_room=%d\n", info->device_name, ret));\r\nreturn ret;\r\n}\r\nstatic void flush_chars(struct tty_struct *tty)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "flush_chars"))\r\nreturn;\r\nDBGINFO(("%s flush_chars entry tx_count=%d\n", info->device_name, info->tx_count));\r\nif (info->tx_count <= 0 || tty->stopped ||\r\ntty->hw_stopped || !info->tx_buf)\r\nreturn;\r\nDBGINFO(("%s flush_chars start transmit\n", info->device_name));\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (info->tx_count && tx_load(info, info->tx_buf, info->tx_count))\r\ninfo->tx_count = 0;\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nstatic void flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "flush_buffer"))\r\nreturn;\r\nDBGINFO(("%s flush_buffer\n", info->device_name));\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->tx_count = 0;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void tx_hold(struct tty_struct *tty)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "tx_hold"))\r\nreturn;\r\nDBGINFO(("%s tx_hold\n", info->device_name));\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (info->tx_enabled && info->params.mode == MGSL_MODE_ASYNC)\r\ntx_stop(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nstatic void tx_release(struct tty_struct *tty)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "tx_release"))\r\nreturn;\r\nDBGINFO(("%s tx_release\n", info->device_name));\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (info->tx_count && tx_load(info, info->tx_buf, info->tx_count))\r\ninfo->tx_count = 0;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nstatic int ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint ret;\r\nif (sanity_check(info, tty->name, "ioctl"))\r\nreturn -ENODEV;\r\nDBGINFO(("%s ioctl() cmd=%08X\n", info->device_name, cmd));\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCMIWAIT)) {\r\nif (tty_io_error(tty))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase MGSL_IOCWAITEVENT:\r\nreturn wait_mgsl_event(info, argp);\r\ncase TIOCMIWAIT:\r\nreturn modem_input_wait(info,(int)arg);\r\ncase MGSL_IOCSGPIO:\r\nreturn set_gpio(info, argp);\r\ncase MGSL_IOCGGPIO:\r\nreturn get_gpio(info, argp);\r\ncase MGSL_IOCWAITGPIO:\r\nreturn wait_gpio(info, argp);\r\ncase MGSL_IOCGXSYNC:\r\nreturn get_xsync(info, argp);\r\ncase MGSL_IOCSXSYNC:\r\nreturn set_xsync(info, (int)arg);\r\ncase MGSL_IOCGXCTRL:\r\nreturn get_xctrl(info, argp);\r\ncase MGSL_IOCSXCTRL:\r\nreturn set_xctrl(info, (int)arg);\r\n}\r\nmutex_lock(&info->port.mutex);\r\nswitch (cmd) {\r\ncase MGSL_IOCGPARAMS:\r\nret = get_params(info, argp);\r\nbreak;\r\ncase MGSL_IOCSPARAMS:\r\nret = set_params(info, argp);\r\nbreak;\r\ncase MGSL_IOCGTXIDLE:\r\nret = get_txidle(info, argp);\r\nbreak;\r\ncase MGSL_IOCSTXIDLE:\r\nret = set_txidle(info, (int)arg);\r\nbreak;\r\ncase MGSL_IOCTXENABLE:\r\nret = tx_enable(info, (int)arg);\r\nbreak;\r\ncase MGSL_IOCRXENABLE:\r\nret = rx_enable(info, (int)arg);\r\nbreak;\r\ncase MGSL_IOCTXABORT:\r\nret = tx_abort(info);\r\nbreak;\r\ncase MGSL_IOCGSTATS:\r\nret = get_stats(info, argp);\r\nbreak;\r\ncase MGSL_IOCGIF:\r\nret = get_interface(info, argp);\r\nbreak;\r\ncase MGSL_IOCSIF:\r\nret = set_interface(info,(int)arg);\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\n}\r\nmutex_unlock(&info->port.mutex);\r\nreturn ret;\r\n}\r\nstatic int get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nstruct mgsl_icount cnow;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock,flags);\r\ncnow = info->icount;\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic long get_params32(struct slgt_info *info, struct MGSL_PARAMS32 __user *user_params)\r\n{\r\nstruct MGSL_PARAMS32 tmp_params;\r\nDBGINFO(("%s get_params32\n", info->device_name));\r\nmemset(&tmp_params, 0, sizeof(tmp_params));\r\ntmp_params.mode = (compat_ulong_t)info->params.mode;\r\ntmp_params.loopback = info->params.loopback;\r\ntmp_params.flags = info->params.flags;\r\ntmp_params.encoding = info->params.encoding;\r\ntmp_params.clock_speed = (compat_ulong_t)info->params.clock_speed;\r\ntmp_params.addr_filter = info->params.addr_filter;\r\ntmp_params.crc_type = info->params.crc_type;\r\ntmp_params.preamble_length = info->params.preamble_length;\r\ntmp_params.preamble = info->params.preamble;\r\ntmp_params.data_rate = (compat_ulong_t)info->params.data_rate;\r\ntmp_params.data_bits = info->params.data_bits;\r\ntmp_params.stop_bits = info->params.stop_bits;\r\ntmp_params.parity = info->params.parity;\r\nif (copy_to_user(user_params, &tmp_params, sizeof(struct MGSL_PARAMS32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long set_params32(struct slgt_info *info, struct MGSL_PARAMS32 __user *new_params)\r\n{\r\nstruct MGSL_PARAMS32 tmp_params;\r\nDBGINFO(("%s set_params32\n", info->device_name));\r\nif (copy_from_user(&tmp_params, new_params, sizeof(struct MGSL_PARAMS32)))\r\nreturn -EFAULT;\r\nspin_lock(&info->lock);\r\nif (tmp_params.mode == MGSL_MODE_BASE_CLOCK) {\r\ninfo->base_clock = tmp_params.clock_speed;\r\n} else {\r\ninfo->params.mode = tmp_params.mode;\r\ninfo->params.loopback = tmp_params.loopback;\r\ninfo->params.flags = tmp_params.flags;\r\ninfo->params.encoding = tmp_params.encoding;\r\ninfo->params.clock_speed = tmp_params.clock_speed;\r\ninfo->params.addr_filter = tmp_params.addr_filter;\r\ninfo->params.crc_type = tmp_params.crc_type;\r\ninfo->params.preamble_length = tmp_params.preamble_length;\r\ninfo->params.preamble = tmp_params.preamble;\r\ninfo->params.data_rate = tmp_params.data_rate;\r\ninfo->params.data_bits = tmp_params.data_bits;\r\ninfo->params.stop_bits = tmp_params.stop_bits;\r\ninfo->params.parity = tmp_params.parity;\r\n}\r\nspin_unlock(&info->lock);\r\nprogram_hw(info);\r\nreturn 0;\r\n}\r\nstatic long slgt_compat_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nint rc = -ENOIOCTLCMD;\r\nif (sanity_check(info, tty->name, "compat_ioctl"))\r\nreturn -ENODEV;\r\nDBGINFO(("%s compat_ioctl() cmd=%08X\n", info->device_name, cmd));\r\nswitch (cmd) {\r\ncase MGSL_IOCSPARAMS32:\r\nrc = set_params32(info, compat_ptr(arg));\r\nbreak;\r\ncase MGSL_IOCGPARAMS32:\r\nrc = get_params32(info, compat_ptr(arg));\r\nbreak;\r\ncase MGSL_IOCGPARAMS:\r\ncase MGSL_IOCSPARAMS:\r\ncase MGSL_IOCGTXIDLE:\r\ncase MGSL_IOCGSTATS:\r\ncase MGSL_IOCWAITEVENT:\r\ncase MGSL_IOCGIF:\r\ncase MGSL_IOCSGPIO:\r\ncase MGSL_IOCGGPIO:\r\ncase MGSL_IOCWAITGPIO:\r\ncase MGSL_IOCGXSYNC:\r\ncase MGSL_IOCGXCTRL:\r\ncase MGSL_IOCSTXIDLE:\r\ncase MGSL_IOCTXENABLE:\r\ncase MGSL_IOCRXENABLE:\r\ncase MGSL_IOCTXABORT:\r\ncase TIOCMIWAIT:\r\ncase MGSL_IOCSIF:\r\ncase MGSL_IOCSXSYNC:\r\ncase MGSL_IOCSXCTRL:\r\nrc = ioctl(tty, cmd, arg);\r\nbreak;\r\n}\r\nDBGINFO(("%s compat_ioctl() cmd=%08X rc=%d\n", info->device_name, cmd, rc));\r\nreturn rc;\r\n}\r\nstatic inline void line_info(struct seq_file *m, struct slgt_info *info)\r\n{\r\nchar stat_buf[30];\r\nunsigned long flags;\r\nseq_printf(m, "%s: IO=%08X IRQ=%d MaxFrameSize=%u\n",\r\ninfo->device_name, info->phys_reg_addr,\r\ninfo->irq_level, info->max_frame_size);\r\nspin_lock_irqsave(&info->lock,flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nstat_buf[0] = 0;\r\nstat_buf[1] = 0;\r\nif (info->signals & SerialSignal_RTS)\r\nstrcat(stat_buf, "|RTS");\r\nif (info->signals & SerialSignal_CTS)\r\nstrcat(stat_buf, "|CTS");\r\nif (info->signals & SerialSignal_DTR)\r\nstrcat(stat_buf, "|DTR");\r\nif (info->signals & SerialSignal_DSR)\r\nstrcat(stat_buf, "|DSR");\r\nif (info->signals & SerialSignal_DCD)\r\nstrcat(stat_buf, "|CD");\r\nif (info->signals & SerialSignal_RI)\r\nstrcat(stat_buf, "|RI");\r\nif (info->params.mode != MGSL_MODE_ASYNC) {\r\nseq_printf(m, "\tHDLC txok:%d rxok:%d",\r\ninfo->icount.txok, info->icount.rxok);\r\nif (info->icount.txunder)\r\nseq_printf(m, " txunder:%d", info->icount.txunder);\r\nif (info->icount.txabort)\r\nseq_printf(m, " txabort:%d", info->icount.txabort);\r\nif (info->icount.rxshort)\r\nseq_printf(m, " rxshort:%d", info->icount.rxshort);\r\nif (info->icount.rxlong)\r\nseq_printf(m, " rxlong:%d", info->icount.rxlong);\r\nif (info->icount.rxover)\r\nseq_printf(m, " rxover:%d", info->icount.rxover);\r\nif (info->icount.rxcrc)\r\nseq_printf(m, " rxcrc:%d", info->icount.rxcrc);\r\n} else {\r\nseq_printf(m, "\tASYNC tx:%d rx:%d",\r\ninfo->icount.tx, info->icount.rx);\r\nif (info->icount.frame)\r\nseq_printf(m, " fe:%d", info->icount.frame);\r\nif (info->icount.parity)\r\nseq_printf(m, " pe:%d", info->icount.parity);\r\nif (info->icount.brk)\r\nseq_printf(m, " brk:%d", info->icount.brk);\r\nif (info->icount.overrun)\r\nseq_printf(m, " oe:%d", info->icount.overrun);\r\n}\r\nseq_printf(m, " %s\n", stat_buf+1);\r\nseq_printf(m, "\ttxactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",\r\ninfo->tx_active,info->bh_requested,info->bh_running,\r\ninfo->pending_bh);\r\n}\r\nstatic int synclink_gt_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct slgt_info *info;\r\nseq_puts(m, "synclink_gt driver\n");\r\ninfo = slgt_device_list;\r\nwhile( info ) {\r\nline_info(m, info);\r\ninfo = info->next_device;\r\n}\r\nreturn 0;\r\n}\r\nstatic int synclink_gt_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, synclink_gt_proc_show, NULL);\r\n}\r\nstatic int chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nint count;\r\nif (sanity_check(info, tty->name, "chars_in_buffer"))\r\nreturn 0;\r\ncount = tbuf_bytes(info);\r\nDBGINFO(("%s chars_in_buffer()=%d\n", info->device_name, count));\r\nreturn count;\r\n}\r\nstatic void throttle(struct tty_struct * tty)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "throttle"))\r\nreturn;\r\nDBGINFO(("%s throttle\n", info->device_name));\r\nif (I_IXOFF(tty))\r\nsend_xchar(tty, STOP_CHAR(tty));\r\nif (C_CRTSCTS(tty)) {\r\nspin_lock_irqsave(&info->lock,flags);\r\ninfo->signals &= ~SerialSignal_RTS;\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\n}\r\nstatic void unthrottle(struct tty_struct * tty)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "unthrottle"))\r\nreturn;\r\nDBGINFO(("%s unthrottle\n", info->device_name));\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\nsend_xchar(tty, START_CHAR(tty));\r\n}\r\nif (C_CRTSCTS(tty)) {\r\nspin_lock_irqsave(&info->lock,flags);\r\ninfo->signals |= SerialSignal_RTS;\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\n}\r\nstatic int set_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned short value;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "set_break"))\r\nreturn -EINVAL;\r\nDBGINFO(("%s set_break(%d)\n", info->device_name, break_state));\r\nspin_lock_irqsave(&info->lock,flags);\r\nvalue = rd_reg16(info, TCR);\r\nif (break_state == -1)\r\nvalue |= BIT6;\r\nelse\r\nvalue &= ~BIT6;\r\nwr_reg16(info, TCR, value);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int hdlcdev_attach(struct net_device *dev, unsigned short encoding,\r\nunsigned short parity)\r\n{\r\nstruct slgt_info *info = dev_to_port(dev);\r\nunsigned char new_encoding;\r\nunsigned short new_crctype;\r\nif (info->port.count)\r\nreturn -EBUSY;\r\nDBGINFO(("%s hdlcdev_attach\n", info->device_name));\r\nswitch (encoding)\r\n{\r\ncase ENCODING_NRZ: new_encoding = HDLC_ENCODING_NRZ; break;\r\ncase ENCODING_NRZI: new_encoding = HDLC_ENCODING_NRZI_SPACE; break;\r\ncase ENCODING_FM_MARK: new_encoding = HDLC_ENCODING_BIPHASE_MARK; break;\r\ncase ENCODING_FM_SPACE: new_encoding = HDLC_ENCODING_BIPHASE_SPACE; break;\r\ncase ENCODING_MANCHESTER: new_encoding = HDLC_ENCODING_BIPHASE_LEVEL; break;\r\ndefault: return -EINVAL;\r\n}\r\nswitch (parity)\r\n{\r\ncase PARITY_NONE: new_crctype = HDLC_CRC_NONE; break;\r\ncase PARITY_CRC16_PR1_CCITT: new_crctype = HDLC_CRC_16_CCITT; break;\r\ncase PARITY_CRC32_PR1_CCITT: new_crctype = HDLC_CRC_32_CCITT; break;\r\ndefault: return -EINVAL;\r\n}\r\ninfo->params.encoding = new_encoding;\r\ninfo->params.crc_type = new_crctype;\r\nif (info->netcount)\r\nprogram_hw(info);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t hdlcdev_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct slgt_info *info = dev_to_port(dev);\r\nunsigned long flags;\r\nDBGINFO(("%s hdlc_xmit\n", dev->name));\r\nif (!skb->len)\r\nreturn NETDEV_TX_OK;\r\nnetif_stop_queue(dev);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nnetif_trans_update(dev);\r\nspin_lock_irqsave(&info->lock, flags);\r\ntx_load(info, skb->data, skb->len);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int hdlcdev_open(struct net_device *dev)\r\n{\r\nstruct slgt_info *info = dev_to_port(dev);\r\nint rc;\r\nunsigned long flags;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -EBUSY;\r\nDBGINFO(("%s hdlcdev_open\n", dev->name));\r\nrc = hdlc_open(dev);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&info->netlock, flags);\r\nif (info->port.count != 0 || info->netcount != 0) {\r\nDBGINFO(("%s hdlc_open busy\n", dev->name));\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn -EBUSY;\r\n}\r\ninfo->netcount=1;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nif ((rc = startup(info)) != 0) {\r\nspin_lock_irqsave(&info->netlock, flags);\r\ninfo->netcount=0;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn rc;\r\n}\r\ninfo->signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nprogram_hw(info);\r\nnetif_trans_update(dev);\r\nnetif_start_queue(dev);\r\nspin_lock_irqsave(&info->lock, flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nif (info->signals & SerialSignal_DCD)\r\nnetif_carrier_on(dev);\r\nelse\r\nnetif_carrier_off(dev);\r\nreturn 0;\r\n}\r\nstatic int hdlcdev_close(struct net_device *dev)\r\n{\r\nstruct slgt_info *info = dev_to_port(dev);\r\nunsigned long flags;\r\nDBGINFO(("%s hdlcdev_close\n", dev->name));\r\nnetif_stop_queue(dev);\r\nshutdown(info);\r\nhdlc_close(dev);\r\nspin_lock_irqsave(&info->netlock, flags);\r\ninfo->netcount=0;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nstatic int hdlcdev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nsync_serial_settings new_line;\r\nsync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;\r\nstruct slgt_info *info = dev_to_port(dev);\r\nunsigned int flags;\r\nDBGINFO(("%s hdlcdev_ioctl\n", dev->name));\r\nif (info->port.count)\r\nreturn -EBUSY;\r\nif (cmd != SIOCWANDEV)\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\nmemset(&new_line, 0, sizeof(new_line));\r\nswitch(ifr->ifr_settings.type) {\r\ncase IF_GET_IFACE:\r\nifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nflags = info->params.flags & (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN);\r\nswitch (flags){\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN): new_line.clock_type = CLOCK_EXT; break;\r\ncase (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG): new_line.clock_type = CLOCK_INT; break;\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG): new_line.clock_type = CLOCK_TXINT; break;\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN): new_line.clock_type = CLOCK_TXFROMRX; break;\r\ndefault: new_line.clock_type = CLOCK_DEFAULT;\r\n}\r\nnew_line.clock_rate = info->params.clock_speed;\r\nnew_line.loopback = info->params.loopback ? 1:0;\r\nif (copy_to_user(line, &new_line, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_IFACE_SYNC_SERIAL:\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&new_line, line, size))\r\nreturn -EFAULT;\r\nswitch (new_line.clock_type)\r\n{\r\ncase CLOCK_EXT: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN; break;\r\ncase CLOCK_TXFROMRX: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN; break;\r\ncase CLOCK_INT: flags = HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG; break;\r\ncase CLOCK_TXINT: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG; break;\r\ncase CLOCK_DEFAULT: flags = info->params.flags &\r\n(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN); break;\r\ndefault: return -EINVAL;\r\n}\r\nif (new_line.loopback != 0 && new_line.loopback != 1)\r\nreturn -EINVAL;\r\ninfo->params.flags &= ~(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN);\r\ninfo->params.flags |= flags;\r\ninfo->params.loopback = new_line.loopback;\r\nif (flags & (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG))\r\ninfo->params.clock_speed = new_line.clock_rate;\r\nelse\r\ninfo->params.clock_speed = 0;\r\nif (info->netcount)\r\nprogram_hw(info);\r\nreturn 0;\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\n}\r\nstatic void hdlcdev_tx_timeout(struct net_device *dev)\r\n{\r\nstruct slgt_info *info = dev_to_port(dev);\r\nunsigned long flags;\r\nDBGINFO(("%s hdlcdev_tx_timeout\n", dev->name));\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\nspin_lock_irqsave(&info->lock,flags);\r\ntx_stop(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void hdlcdev_tx_done(struct slgt_info *info)\r\n{\r\nif (netif_queue_stopped(info->netdev))\r\nnetif_wake_queue(info->netdev);\r\n}\r\nstatic void hdlcdev_rx(struct slgt_info *info, char *buf, int size)\r\n{\r\nstruct sk_buff *skb = dev_alloc_skb(size);\r\nstruct net_device *dev = info->netdev;\r\nDBGINFO(("%s hdlcdev_rx\n", dev->name));\r\nif (skb == NULL) {\r\nDBGERR(("%s: can't alloc skb, drop packet\n", dev->name));\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, size), buf, size);\r\nskb->protocol = hdlc_type_trans(skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += size;\r\nnetif_rx(skb);\r\n}\r\nstatic int hdlcdev_init(struct slgt_info *info)\r\n{\r\nint rc;\r\nstruct net_device *dev;\r\nhdlc_device *hdlc;\r\ndev = alloc_hdlcdev(info);\r\nif (!dev) {\r\nprintk(KERN_ERR "%s hdlc device alloc failure\n", info->device_name);\r\nreturn -ENOMEM;\r\n}\r\ndev->mem_start = info->phys_reg_addr;\r\ndev->mem_end = info->phys_reg_addr + SLGT_REG_SIZE - 1;\r\ndev->irq = info->irq_level;\r\ndev->netdev_ops = &hdlcdev_ops;\r\ndev->watchdog_timeo = 10 * HZ;\r\ndev->tx_queue_len = 50;\r\nhdlc = dev_to_hdlc(dev);\r\nhdlc->attach = hdlcdev_attach;\r\nhdlc->xmit = hdlcdev_xmit;\r\nrc = register_hdlc_device(dev);\r\nif (rc) {\r\nprintk(KERN_WARNING "%s:unable to register hdlc device\n",__FILE__);\r\nfree_netdev(dev);\r\nreturn rc;\r\n}\r\ninfo->netdev = dev;\r\nreturn 0;\r\n}\r\nstatic void hdlcdev_exit(struct slgt_info *info)\r\n{\r\nunregister_hdlc_device(info->netdev);\r\nfree_netdev(info->netdev);\r\ninfo->netdev = NULL;\r\n}\r\nstatic void rx_async(struct slgt_info *info)\r\n{\r\nstruct mgsl_icount *icount = &info->icount;\r\nunsigned int start, end;\r\nunsigned char *p;\r\nunsigned char status;\r\nstruct slgt_desc *bufs = info->rbufs;\r\nint i, count;\r\nint chars = 0;\r\nint stat;\r\nunsigned char ch;\r\nstart = end = info->rbuf_current;\r\nwhile(desc_complete(bufs[end])) {\r\ncount = desc_count(bufs[end]) - info->rbuf_index;\r\np = bufs[end].buf + info->rbuf_index;\r\nDBGISR(("%s rx_async count=%d\n", info->device_name, count));\r\nDBGDATA(info, p, count, "rx");\r\nfor(i=0 ; i < count; i+=2, p+=2) {\r\nch = *p;\r\nicount->rx++;\r\nstat = 0;\r\nstatus = *(p + 1) & (BIT1 + BIT0);\r\nif (status) {\r\nif (status & BIT1)\r\nicount->parity++;\r\nelse if (status & BIT0)\r\nicount->frame++;\r\nif (status & info->ignore_status_mask)\r\ncontinue;\r\nif (status & BIT1)\r\nstat = TTY_PARITY;\r\nelse if (status & BIT0)\r\nstat = TTY_FRAME;\r\n}\r\ntty_insert_flip_char(&info->port, ch, stat);\r\nchars++;\r\n}\r\nif (i < count) {\r\ninfo->rbuf_index += i;\r\nmod_timer(&info->rx_timer, jiffies + 1);\r\nbreak;\r\n}\r\ninfo->rbuf_index = 0;\r\nfree_rbufs(info, end, end);\r\nif (++end == info->rbuf_count)\r\nend = 0;\r\nif (end == start)\r\nbreak;\r\n}\r\nif (chars)\r\ntty_flip_buffer_push(&info->port);\r\n}\r\nstatic int bh_action(struct slgt_info *info)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (info->pending_bh & BH_RECEIVE) {\r\ninfo->pending_bh &= ~BH_RECEIVE;\r\nrc = BH_RECEIVE;\r\n} else if (info->pending_bh & BH_TRANSMIT) {\r\ninfo->pending_bh &= ~BH_TRANSMIT;\r\nrc = BH_TRANSMIT;\r\n} else if (info->pending_bh & BH_STATUS) {\r\ninfo->pending_bh &= ~BH_STATUS;\r\nrc = BH_STATUS;\r\n} else {\r\ninfo->bh_running = false;\r\ninfo->bh_requested = false;\r\nrc = 0;\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn rc;\r\n}\r\nstatic void bh_handler(struct work_struct *work)\r\n{\r\nstruct slgt_info *info = container_of(work, struct slgt_info, task);\r\nint action;\r\ninfo->bh_running = true;\r\nwhile((action = bh_action(info))) {\r\nswitch (action) {\r\ncase BH_RECEIVE:\r\nDBGBH(("%s bh receive\n", info->device_name));\r\nswitch(info->params.mode) {\r\ncase MGSL_MODE_ASYNC:\r\nrx_async(info);\r\nbreak;\r\ncase MGSL_MODE_HDLC:\r\nwhile(rx_get_frame(info));\r\nbreak;\r\ncase MGSL_MODE_RAW:\r\ncase MGSL_MODE_MONOSYNC:\r\ncase MGSL_MODE_BISYNC:\r\ncase MGSL_MODE_XSYNC:\r\nwhile(rx_get_buf(info));\r\nbreak;\r\n}\r\nif (info->rx_restart)\r\nrx_start(info);\r\nbreak;\r\ncase BH_TRANSMIT:\r\nbh_transmit(info);\r\nbreak;\r\ncase BH_STATUS:\r\nDBGBH(("%s bh status\n", info->device_name));\r\ninfo->ri_chkcount = 0;\r\ninfo->dsr_chkcount = 0;\r\ninfo->dcd_chkcount = 0;\r\ninfo->cts_chkcount = 0;\r\nbreak;\r\ndefault:\r\nDBGBH(("%s unknown action\n", info->device_name));\r\nbreak;\r\n}\r\n}\r\nDBGBH(("%s bh_handler exit\n", info->device_name));\r\n}\r\nstatic void bh_transmit(struct slgt_info *info)\r\n{\r\nstruct tty_struct *tty = info->port.tty;\r\nDBGBH(("%s bh_transmit\n", info->device_name));\r\nif (tty)\r\ntty_wakeup(tty);\r\n}\r\nstatic void dsr_change(struct slgt_info *info, unsigned short status)\r\n{\r\nif (status & BIT3) {\r\ninfo->signals |= SerialSignal_DSR;\r\ninfo->input_signal_events.dsr_up++;\r\n} else {\r\ninfo->signals &= ~SerialSignal_DSR;\r\ninfo->input_signal_events.dsr_down++;\r\n}\r\nDBGISR(("dsr_change %s signals=%04X\n", info->device_name, info->signals));\r\nif ((info->dsr_chkcount)++ == IO_PIN_SHUTDOWN_LIMIT) {\r\nslgt_irq_off(info, IRQ_DSR);\r\nreturn;\r\n}\r\ninfo->icount.dsr++;\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\ninfo->pending_bh |= BH_STATUS;\r\n}\r\nstatic void cts_change(struct slgt_info *info, unsigned short status)\r\n{\r\nif (status & BIT2) {\r\ninfo->signals |= SerialSignal_CTS;\r\ninfo->input_signal_events.cts_up++;\r\n} else {\r\ninfo->signals &= ~SerialSignal_CTS;\r\ninfo->input_signal_events.cts_down++;\r\n}\r\nDBGISR(("cts_change %s signals=%04X\n", info->device_name, info->signals));\r\nif ((info->cts_chkcount)++ == IO_PIN_SHUTDOWN_LIMIT) {\r\nslgt_irq_off(info, IRQ_CTS);\r\nreturn;\r\n}\r\ninfo->icount.cts++;\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\ninfo->pending_bh |= BH_STATUS;\r\nif (tty_port_cts_enabled(&info->port)) {\r\nif (info->port.tty) {\r\nif (info->port.tty->hw_stopped) {\r\nif (info->signals & SerialSignal_CTS) {\r\ninfo->port.tty->hw_stopped = 0;\r\ninfo->pending_bh |= BH_TRANSMIT;\r\nreturn;\r\n}\r\n} else {\r\nif (!(info->signals & SerialSignal_CTS))\r\ninfo->port.tty->hw_stopped = 1;\r\n}\r\n}\r\n}\r\n}\r\nstatic void dcd_change(struct slgt_info *info, unsigned short status)\r\n{\r\nif (status & BIT1) {\r\ninfo->signals |= SerialSignal_DCD;\r\ninfo->input_signal_events.dcd_up++;\r\n} else {\r\ninfo->signals &= ~SerialSignal_DCD;\r\ninfo->input_signal_events.dcd_down++;\r\n}\r\nDBGISR(("dcd_change %s signals=%04X\n", info->device_name, info->signals));\r\nif ((info->dcd_chkcount)++ == IO_PIN_SHUTDOWN_LIMIT) {\r\nslgt_irq_off(info, IRQ_DCD);\r\nreturn;\r\n}\r\ninfo->icount.dcd++;\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount) {\r\nif (info->signals & SerialSignal_DCD)\r\nnetif_carrier_on(info->netdev);\r\nelse\r\nnetif_carrier_off(info->netdev);\r\n}\r\n#endif\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\ninfo->pending_bh |= BH_STATUS;\r\nif (tty_port_check_carrier(&info->port)) {\r\nif (info->signals & SerialSignal_DCD)\r\nwake_up_interruptible(&info->port.open_wait);\r\nelse {\r\nif (info->port.tty)\r\ntty_hangup(info->port.tty);\r\n}\r\n}\r\n}\r\nstatic void ri_change(struct slgt_info *info, unsigned short status)\r\n{\r\nif (status & BIT0) {\r\ninfo->signals |= SerialSignal_RI;\r\ninfo->input_signal_events.ri_up++;\r\n} else {\r\ninfo->signals &= ~SerialSignal_RI;\r\ninfo->input_signal_events.ri_down++;\r\n}\r\nDBGISR(("ri_change %s signals=%04X\n", info->device_name, info->signals));\r\nif ((info->ri_chkcount)++ == IO_PIN_SHUTDOWN_LIMIT) {\r\nslgt_irq_off(info, IRQ_RI);\r\nreturn;\r\n}\r\ninfo->icount.rng++;\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\ninfo->pending_bh |= BH_STATUS;\r\n}\r\nstatic void isr_rxdata(struct slgt_info *info)\r\n{\r\nunsigned int count = info->rbuf_fill_count;\r\nunsigned int i = info->rbuf_fill_index;\r\nunsigned short reg;\r\nwhile (rd_reg16(info, SSR) & IRQ_RXDATA) {\r\nreg = rd_reg16(info, RDR);\r\nDBGISR(("isr_rxdata %s RDR=%04X\n", info->device_name, reg));\r\nif (desc_complete(info->rbufs[i])) {\r\nrx_stop(info);\r\ninfo->rx_restart = 1;\r\ncontinue;\r\n}\r\ninfo->rbufs[i].buf[count++] = (unsigned char)reg;\r\nif (info->params.mode == MGSL_MODE_ASYNC)\r\ninfo->rbufs[i].buf[count++] = (unsigned char)(reg >> 8);\r\nif (count == info->rbuf_fill_level || (reg & BIT10)) {\r\nset_desc_count(info->rbufs[i], count);\r\nset_desc_status(info->rbufs[i], BIT15 | (reg >> 8));\r\ninfo->rbuf_fill_count = count = 0;\r\nif (++i == info->rbuf_count)\r\ni = 0;\r\ninfo->pending_bh |= BH_RECEIVE;\r\n}\r\n}\r\ninfo->rbuf_fill_index = i;\r\ninfo->rbuf_fill_count = count;\r\n}\r\nstatic void isr_serial(struct slgt_info *info)\r\n{\r\nunsigned short status = rd_reg16(info, SSR);\r\nDBGISR(("%s isr_serial status=%04X\n", info->device_name, status));\r\nwr_reg16(info, SSR, status);\r\ninfo->irq_occurred = true;\r\nif (info->params.mode == MGSL_MODE_ASYNC) {\r\nif (status & IRQ_TXIDLE) {\r\nif (info->tx_active)\r\nisr_txeom(info, status);\r\n}\r\nif (info->rx_pio && (status & IRQ_RXDATA))\r\nisr_rxdata(info);\r\nif ((status & IRQ_RXBREAK) && (status & RXBREAK)) {\r\ninfo->icount.brk++;\r\nif (info->port.tty) {\r\nif (!(status & info->ignore_status_mask)) {\r\nif (info->read_status_mask & MASK_BREAK) {\r\ntty_insert_flip_char(&info->port, 0, TTY_BREAK);\r\nif (info->port.flags & ASYNC_SAK)\r\ndo_SAK(info->port.tty);\r\n}\r\n}\r\n}\r\n}\r\n} else {\r\nif (status & (IRQ_TXIDLE + IRQ_TXUNDER))\r\nisr_txeom(info, status);\r\nif (info->rx_pio && (status & IRQ_RXDATA))\r\nisr_rxdata(info);\r\nif (status & IRQ_RXIDLE) {\r\nif (status & RXIDLE)\r\ninfo->icount.rxidle++;\r\nelse\r\ninfo->icount.exithunt++;\r\nwake_up_interruptible(&info->event_wait_q);\r\n}\r\nif (status & IRQ_RXOVER)\r\nrx_start(info);\r\n}\r\nif (status & IRQ_DSR)\r\ndsr_change(info, status);\r\nif (status & IRQ_CTS)\r\ncts_change(info, status);\r\nif (status & IRQ_DCD)\r\ndcd_change(info, status);\r\nif (status & IRQ_RI)\r\nri_change(info, status);\r\n}\r\nstatic void isr_rdma(struct slgt_info *info)\r\n{\r\nunsigned int status = rd_reg32(info, RDCSR);\r\nDBGISR(("%s isr_rdma status=%08x\n", info->device_name, status));\r\nwr_reg32(info, RDCSR, status);\r\nif (status & (BIT5 + BIT4)) {\r\nDBGISR(("%s isr_rdma rx_restart=1\n", info->device_name));\r\ninfo->rx_restart = true;\r\n}\r\ninfo->pending_bh |= BH_RECEIVE;\r\n}\r\nstatic void isr_tdma(struct slgt_info *info)\r\n{\r\nunsigned int status = rd_reg32(info, TDCSR);\r\nDBGISR(("%s isr_tdma status=%08x\n", info->device_name, status));\r\nwr_reg32(info, TDCSR, status);\r\nif (status & (BIT5 + BIT4 + BIT3)) {\r\ninfo->pending_bh |= BH_TRANSMIT;\r\n}\r\n}\r\nstatic bool unsent_tbufs(struct slgt_info *info)\r\n{\r\nunsigned int i = info->tbuf_current;\r\nbool rc = false;\r\ndo {\r\nif (i)\r\ni--;\r\nelse\r\ni = info->tbuf_count - 1;\r\nif (!desc_count(info->tbufs[i]))\r\nbreak;\r\ninfo->tbuf_start = i;\r\nrc = true;\r\n} while (i != info->tbuf_current);\r\nreturn rc;\r\n}\r\nstatic void isr_txeom(struct slgt_info *info, unsigned short status)\r\n{\r\nDBGISR(("%s txeom status=%04x\n", info->device_name, status));\r\nslgt_irq_off(info, IRQ_TXDATA + IRQ_TXIDLE + IRQ_TXUNDER);\r\ntdma_reset(info);\r\nif (status & IRQ_TXUNDER) {\r\nunsigned short val = rd_reg16(info, TCR);\r\nwr_reg16(info, TCR, (unsigned short)(val | BIT2));\r\nwr_reg16(info, TCR, val);\r\n}\r\nif (info->tx_active) {\r\nif (info->params.mode != MGSL_MODE_ASYNC) {\r\nif (status & IRQ_TXUNDER)\r\ninfo->icount.txunder++;\r\nelse if (status & IRQ_TXIDLE)\r\ninfo->icount.txok++;\r\n}\r\nif (unsent_tbufs(info)) {\r\ntx_start(info);\r\nupdate_tx_timer(info);\r\nreturn;\r\n}\r\ninfo->tx_active = false;\r\ndel_timer(&info->tx_timer);\r\nif (info->params.mode != MGSL_MODE_ASYNC && info->drop_rts_on_tx_done) {\r\ninfo->signals &= ~SerialSignal_RTS;\r\ninfo->drop_rts_on_tx_done = false;\r\nset_signals(info);\r\n}\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_tx_done(info);\r\nelse\r\n#endif\r\n{\r\nif (info->port.tty && (info->port.tty->stopped || info->port.tty->hw_stopped)) {\r\ntx_stop(info);\r\nreturn;\r\n}\r\ninfo->pending_bh |= BH_TRANSMIT;\r\n}\r\n}\r\n}\r\nstatic void isr_gpio(struct slgt_info *info, unsigned int changed, unsigned int state)\r\n{\r\nstruct cond_wait *w, *prev;\r\nfor (w = info->gpio_wait_q, prev = NULL ; w != NULL ; w = w->next) {\r\nif (w->data & changed) {\r\nw->data = state;\r\nwake_up_interruptible(&w->q);\r\nif (prev != NULL)\r\nprev->next = w->next;\r\nelse\r\ninfo->gpio_wait_q = w->next;\r\n} else\r\nprev = w;\r\n}\r\n}\r\nstatic irqreturn_t slgt_interrupt(int dummy, void *dev_id)\r\n{\r\nstruct slgt_info *info = dev_id;\r\nunsigned int gsr;\r\nunsigned int i;\r\nDBGISR(("slgt_interrupt irq=%d entry\n", info->irq_level));\r\nwhile((gsr = rd_reg32(info, GSR) & 0xffffff00)) {\r\nDBGISR(("%s gsr=%08x\n", info->device_name, gsr));\r\ninfo->irq_occurred = true;\r\nfor(i=0; i < info->port_count ; i++) {\r\nif (info->port_array[i] == NULL)\r\ncontinue;\r\nspin_lock(&info->port_array[i]->lock);\r\nif (gsr & (BIT8 << i))\r\nisr_serial(info->port_array[i]);\r\nif (gsr & (BIT16 << (i*2)))\r\nisr_rdma(info->port_array[i]);\r\nif (gsr & (BIT17 << (i*2)))\r\nisr_tdma(info->port_array[i]);\r\nspin_unlock(&info->port_array[i]->lock);\r\n}\r\n}\r\nif (info->gpio_present) {\r\nunsigned int state;\r\nunsigned int changed;\r\nspin_lock(&info->lock);\r\nwhile ((changed = rd_reg32(info, IOSR)) != 0) {\r\nDBGISR(("%s iosr=%08x\n", info->device_name, changed));\r\nstate = rd_reg32(info, IOVR);\r\nwr_reg32(info, IOSR, changed);\r\nfor (i=0 ; i < info->port_count ; i++) {\r\nif (info->port_array[i] != NULL)\r\nisr_gpio(info->port_array[i], changed, state);\r\n}\r\n}\r\nspin_unlock(&info->lock);\r\n}\r\nfor(i=0; i < info->port_count ; i++) {\r\nstruct slgt_info *port = info->port_array[i];\r\nif (port == NULL)\r\ncontinue;\r\nspin_lock(&port->lock);\r\nif ((port->port.count || port->netcount) &&\r\nport->pending_bh && !port->bh_running &&\r\n!port->bh_requested) {\r\nDBGISR(("%s bh queued\n", port->device_name));\r\nschedule_work(&port->task);\r\nport->bh_requested = true;\r\n}\r\nspin_unlock(&port->lock);\r\n}\r\nDBGISR(("slgt_interrupt irq=%d exit\n", info->irq_level));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int startup(struct slgt_info *info)\r\n{\r\nDBGINFO(("%s startup\n", info->device_name));\r\nif (tty_port_initialized(&info->port))\r\nreturn 0;\r\nif (!info->tx_buf) {\r\ninfo->tx_buf = kmalloc(info->max_frame_size, GFP_KERNEL);\r\nif (!info->tx_buf) {\r\nDBGERR(("%s can't allocate tx buffer\n", info->device_name));\r\nreturn -ENOMEM;\r\n}\r\n}\r\ninfo->pending_bh = 0;\r\nmemset(&info->icount, 0, sizeof(info->icount));\r\nchange_params(info);\r\nif (info->port.tty)\r\nclear_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ntty_port_set_initialized(&info->port, 1);\r\nreturn 0;\r\n}\r\nstatic void shutdown(struct slgt_info *info)\r\n{\r\nunsigned long flags;\r\nif (!tty_port_initialized(&info->port))\r\nreturn;\r\nDBGINFO(("%s shutdown\n", info->device_name));\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\ndel_timer_sync(&info->tx_timer);\r\ndel_timer_sync(&info->rx_timer);\r\nkfree(info->tx_buf);\r\ninfo->tx_buf = NULL;\r\nspin_lock_irqsave(&info->lock,flags);\r\ntx_stop(info);\r\nrx_stop(info);\r\nslgt_irq_off(info, IRQ_ALL | IRQ_MASTER);\r\nif (!info->port.tty || info->port.tty->termios.c_cflag & HUPCL) {\r\ninfo->signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nset_signals(info);\r\n}\r\nflush_cond_wait(&info->gpio_wait_q);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nif (info->port.tty)\r\nset_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ntty_port_set_initialized(&info->port, 0);\r\n}\r\nstatic void program_hw(struct slgt_info *info)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock,flags);\r\nrx_stop(info);\r\ntx_stop(info);\r\nif (info->params.mode != MGSL_MODE_ASYNC ||\r\ninfo->netcount)\r\nsync_mode(info);\r\nelse\r\nasync_mode(info);\r\nset_signals(info);\r\ninfo->dcd_chkcount = 0;\r\ninfo->cts_chkcount = 0;\r\ninfo->ri_chkcount = 0;\r\ninfo->dsr_chkcount = 0;\r\nslgt_irq_on(info, IRQ_DCD | IRQ_CTS | IRQ_DSR | IRQ_RI);\r\nget_signals(info);\r\nif (info->netcount ||\r\n(info->port.tty && info->port.tty->termios.c_cflag & CREAD))\r\nrx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nstatic void change_params(struct slgt_info *info)\r\n{\r\nunsigned cflag;\r\nint bits_per_char;\r\nif (!info->port.tty)\r\nreturn;\r\nDBGINFO(("%s change_params\n", info->device_name));\r\ncflag = info->port.tty->termios.c_cflag;\r\nif (cflag & CBAUD)\r\ninfo->signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nelse\r\ninfo->signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nswitch (cflag & CSIZE) {\r\ncase CS5: info->params.data_bits = 5; break;\r\ncase CS6: info->params.data_bits = 6; break;\r\ncase CS7: info->params.data_bits = 7; break;\r\ncase CS8: info->params.data_bits = 8; break;\r\ndefault: info->params.data_bits = 7; break;\r\n}\r\ninfo->params.stop_bits = (cflag & CSTOPB) ? 2 : 1;\r\nif (cflag & PARENB)\r\ninfo->params.parity = (cflag & PARODD) ? ASYNC_PARITY_ODD : ASYNC_PARITY_EVEN;\r\nelse\r\ninfo->params.parity = ASYNC_PARITY_NONE;\r\nbits_per_char = info->params.data_bits +\r\ninfo->params.stop_bits + 1;\r\ninfo->params.data_rate = tty_get_baud_rate(info->port.tty);\r\nif (info->params.data_rate) {\r\ninfo->timeout = (32*HZ*bits_per_char) /\r\ninfo->params.data_rate;\r\n}\r\ninfo->timeout += HZ/50;\r\ntty_port_set_cts_flow(&info->port, cflag & CRTSCTS);\r\ntty_port_set_check_carrier(&info->port, ~cflag & CLOCAL);\r\ninfo->read_status_mask = IRQ_RXOVER;\r\nif (I_INPCK(info->port.tty))\r\ninfo->read_status_mask |= MASK_PARITY | MASK_FRAMING;\r\nif (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))\r\ninfo->read_status_mask |= MASK_BREAK;\r\nif (I_IGNPAR(info->port.tty))\r\ninfo->ignore_status_mask |= MASK_PARITY | MASK_FRAMING;\r\nif (I_IGNBRK(info->port.tty)) {\r\ninfo->ignore_status_mask |= MASK_BREAK;\r\nif (I_IGNPAR(info->port.tty))\r\ninfo->ignore_status_mask |= MASK_OVERRUN;\r\n}\r\nprogram_hw(info);\r\n}\r\nstatic int get_stats(struct slgt_info *info, struct mgsl_icount __user *user_icount)\r\n{\r\nDBGINFO(("%s get_stats\n", info->device_name));\r\nif (!user_icount) {\r\nmemset(&info->icount, 0, sizeof(info->icount));\r\n} else {\r\nif (copy_to_user(user_icount, &info->icount, sizeof(struct mgsl_icount)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_params(struct slgt_info *info, MGSL_PARAMS __user *user_params)\r\n{\r\nDBGINFO(("%s get_params\n", info->device_name));\r\nif (copy_to_user(user_params, &info->params, sizeof(MGSL_PARAMS)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_params(struct slgt_info *info, MGSL_PARAMS __user *new_params)\r\n{\r\nunsigned long flags;\r\nMGSL_PARAMS tmp_params;\r\nDBGINFO(("%s set_params\n", info->device_name));\r\nif (copy_from_user(&tmp_params, new_params, sizeof(MGSL_PARAMS)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (tmp_params.mode == MGSL_MODE_BASE_CLOCK)\r\ninfo->base_clock = tmp_params.clock_speed;\r\nelse\r\nmemcpy(&info->params, &tmp_params, sizeof(MGSL_PARAMS));\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nprogram_hw(info);\r\nreturn 0;\r\n}\r\nstatic int get_txidle(struct slgt_info *info, int __user *idle_mode)\r\n{\r\nDBGINFO(("%s get_txidle=%d\n", info->device_name, info->idle_mode));\r\nif (put_user(info->idle_mode, idle_mode))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_txidle(struct slgt_info *info, int idle_mode)\r\n{\r\nunsigned long flags;\r\nDBGINFO(("%s set_txidle(%d)\n", info->device_name, idle_mode));\r\nspin_lock_irqsave(&info->lock,flags);\r\ninfo->idle_mode = idle_mode;\r\nif (info->params.mode != MGSL_MODE_ASYNC)\r\ntx_set_idle(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int tx_enable(struct slgt_info *info, int enable)\r\n{\r\nunsigned long flags;\r\nDBGINFO(("%s tx_enable(%d)\n", info->device_name, enable));\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (enable) {\r\nif (!info->tx_enabled)\r\ntx_start(info);\r\n} else {\r\nif (info->tx_enabled)\r\ntx_stop(info);\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int tx_abort(struct slgt_info *info)\r\n{\r\nunsigned long flags;\r\nDBGINFO(("%s tx_abort\n", info->device_name));\r\nspin_lock_irqsave(&info->lock,flags);\r\ntdma_reset(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int rx_enable(struct slgt_info *info, int enable)\r\n{\r\nunsigned long flags;\r\nunsigned int rbuf_fill_level;\r\nDBGINFO(("%s rx_enable(%08x)\n", info->device_name, enable));\r\nspin_lock_irqsave(&info->lock,flags);\r\nrbuf_fill_level = ((unsigned int)enable) >> 16;\r\nif (rbuf_fill_level) {\r\nif ((rbuf_fill_level > DMABUFSIZE) || (rbuf_fill_level % 4)) {\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn -EINVAL;\r\n}\r\ninfo->rbuf_fill_level = rbuf_fill_level;\r\nif (rbuf_fill_level < 128)\r\ninfo->rx_pio = 1;\r\nelse\r\ninfo->rx_pio = 0;\r\nrx_stop(info);\r\n}\r\nenable &= 3;\r\nif (enable) {\r\nif (!info->rx_enabled)\r\nrx_start(info);\r\nelse if (enable == 2) {\r\nwr_reg16(info, RCR, rd_reg16(info, RCR) | BIT3);\r\n}\r\n} else {\r\nif (info->rx_enabled)\r\nrx_stop(info);\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int wait_mgsl_event(struct slgt_info *info, int __user *mask_ptr)\r\n{\r\nunsigned long flags;\r\nint s;\r\nint rc=0;\r\nstruct mgsl_icount cprev, cnow;\r\nint events;\r\nint mask;\r\nstruct _input_signal_events oldsigs, newsigs;\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (get_user(mask, mask_ptr))\r\nreturn -EFAULT;\r\nDBGINFO(("%s wait_mgsl_event(%d)\n", info->device_name, mask));\r\nspin_lock_irqsave(&info->lock,flags);\r\nget_signals(info);\r\ns = info->signals;\r\nevents = mask &\r\n( ((s & SerialSignal_DSR) ? MgslEvent_DsrActive:MgslEvent_DsrInactive) +\r\n((s & SerialSignal_DCD) ? MgslEvent_DcdActive:MgslEvent_DcdInactive) +\r\n((s & SerialSignal_CTS) ? MgslEvent_CtsActive:MgslEvent_CtsInactive) +\r\n((s & SerialSignal_RI) ? MgslEvent_RiActive :MgslEvent_RiInactive) );\r\nif (events) {\r\nspin_unlock_irqrestore(&info->lock,flags);\r\ngoto exit;\r\n}\r\ncprev = info->icount;\r\noldsigs = info->input_signal_events;\r\nif (mask & (MgslEvent_ExitHuntMode+MgslEvent_IdleReceived)) {\r\nunsigned short val = rd_reg16(info, SCR);\r\nif (!(val & IRQ_RXIDLE))\r\nwr_reg16(info, SCR, (unsigned short)(val | IRQ_RXIDLE));\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&info->event_wait_q, &wait);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nfor(;;) {\r\nschedule();\r\nif (signal_pending(current)) {\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->lock,flags);\r\ncnow = info->icount;\r\nnewsigs = info->input_signal_events;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nif (newsigs.dsr_up == oldsigs.dsr_up &&\r\nnewsigs.dsr_down == oldsigs.dsr_down &&\r\nnewsigs.dcd_up == oldsigs.dcd_up &&\r\nnewsigs.dcd_down == oldsigs.dcd_down &&\r\nnewsigs.cts_up == oldsigs.cts_up &&\r\nnewsigs.cts_down == oldsigs.cts_down &&\r\nnewsigs.ri_up == oldsigs.ri_up &&\r\nnewsigs.ri_down == oldsigs.ri_down &&\r\ncnow.exithunt == cprev.exithunt &&\r\ncnow.rxidle == cprev.rxidle) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nevents = mask &\r\n( (newsigs.dsr_up != oldsigs.dsr_up ? MgslEvent_DsrActive:0) +\r\n(newsigs.dsr_down != oldsigs.dsr_down ? MgslEvent_DsrInactive:0) +\r\n(newsigs.dcd_up != oldsigs.dcd_up ? MgslEvent_DcdActive:0) +\r\n(newsigs.dcd_down != oldsigs.dcd_down ? MgslEvent_DcdInactive:0) +\r\n(newsigs.cts_up != oldsigs.cts_up ? MgslEvent_CtsActive:0) +\r\n(newsigs.cts_down != oldsigs.cts_down ? MgslEvent_CtsInactive:0) +\r\n(newsigs.ri_up != oldsigs.ri_up ? MgslEvent_RiActive:0) +\r\n(newsigs.ri_down != oldsigs.ri_down ? MgslEvent_RiInactive:0) +\r\n(cnow.exithunt != cprev.exithunt ? MgslEvent_ExitHuntMode:0) +\r\n(cnow.rxidle != cprev.rxidle ? MgslEvent_IdleReceived:0) );\r\nif (events)\r\nbreak;\r\ncprev = cnow;\r\noldsigs = newsigs;\r\n}\r\nremove_wait_queue(&info->event_wait_q, &wait);\r\nset_current_state(TASK_RUNNING);\r\nif (mask & (MgslEvent_ExitHuntMode + MgslEvent_IdleReceived)) {\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (!waitqueue_active(&info->event_wait_q)) {\r\nwr_reg16(info, SCR,\r\n(unsigned short)(rd_reg16(info, SCR) & ~IRQ_RXIDLE));\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nexit:\r\nif (rc == 0)\r\nrc = put_user(events, mask_ptr);\r\nreturn rc;\r\n}\r\nstatic int get_interface(struct slgt_info *info, int __user *if_mode)\r\n{\r\nDBGINFO(("%s get_interface=%x\n", info->device_name, info->if_mode));\r\nif (put_user(info->if_mode, if_mode))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_interface(struct slgt_info *info, int if_mode)\r\n{\r\nunsigned long flags;\r\nunsigned short val;\r\nDBGINFO(("%s set_interface=%x)\n", info->device_name, if_mode));\r\nspin_lock_irqsave(&info->lock,flags);\r\ninfo->if_mode = if_mode;\r\nmsc_set_vcr(info);\r\nval = rd_reg16(info, TCR);\r\nif (info->if_mode & MGSL_INTERFACE_RTS_EN)\r\nval |= BIT7;\r\nelse\r\nval &= ~BIT7;\r\nwr_reg16(info, TCR, val);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int get_xsync(struct slgt_info *info, int __user *xsync)\r\n{\r\nDBGINFO(("%s get_xsync=%x\n", info->device_name, info->xsync));\r\nif (put_user(info->xsync, xsync))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_xsync(struct slgt_info *info, int xsync)\r\n{\r\nunsigned long flags;\r\nDBGINFO(("%s set_xsync=%x)\n", info->device_name, xsync));\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->xsync = xsync;\r\nwr_reg32(info, XSR, xsync);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int get_xctrl(struct slgt_info *info, int __user *xctrl)\r\n{\r\nDBGINFO(("%s get_xctrl=%x\n", info->device_name, info->xctrl));\r\nif (put_user(info->xctrl, xctrl))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_xctrl(struct slgt_info *info, int xctrl)\r\n{\r\nunsigned long flags;\r\nDBGINFO(("%s set_xctrl=%x)\n", info->device_name, xctrl));\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->xctrl = xctrl;\r\nwr_reg32(info, XCR, xctrl);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int set_gpio(struct slgt_info *info, struct gpio_desc __user *user_gpio)\r\n{\r\nunsigned long flags;\r\nstruct gpio_desc gpio;\r\n__u32 data;\r\nif (!info->gpio_present)\r\nreturn -EINVAL;\r\nif (copy_from_user(&gpio, user_gpio, sizeof(gpio)))\r\nreturn -EFAULT;\r\nDBGINFO(("%s set_gpio state=%08x smask=%08x dir=%08x dmask=%08x\n",\r\ninfo->device_name, gpio.state, gpio.smask,\r\ngpio.dir, gpio.dmask));\r\nspin_lock_irqsave(&info->port_array[0]->lock, flags);\r\nif (gpio.dmask) {\r\ndata = rd_reg32(info, IODR);\r\ndata |= gpio.dmask & gpio.dir;\r\ndata &= ~(gpio.dmask & ~gpio.dir);\r\nwr_reg32(info, IODR, data);\r\n}\r\nif (gpio.smask) {\r\ndata = rd_reg32(info, IOVR);\r\ndata |= gpio.smask & gpio.state;\r\ndata &= ~(gpio.smask & ~gpio.state);\r\nwr_reg32(info, IOVR, data);\r\n}\r\nspin_unlock_irqrestore(&info->port_array[0]->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int get_gpio(struct slgt_info *info, struct gpio_desc __user *user_gpio)\r\n{\r\nstruct gpio_desc gpio;\r\nif (!info->gpio_present)\r\nreturn -EINVAL;\r\ngpio.state = rd_reg32(info, IOVR);\r\ngpio.smask = 0xffffffff;\r\ngpio.dir = rd_reg32(info, IODR);\r\ngpio.dmask = 0xffffffff;\r\nif (copy_to_user(user_gpio, &gpio, sizeof(gpio)))\r\nreturn -EFAULT;\r\nDBGINFO(("%s get_gpio state=%08x dir=%08x\n",\r\ninfo->device_name, gpio.state, gpio.dir));\r\nreturn 0;\r\n}\r\nstatic void init_cond_wait(struct cond_wait *w, unsigned int data)\r\n{\r\ninit_waitqueue_head(&w->q);\r\ninit_waitqueue_entry(&w->wait, current);\r\nw->data = data;\r\n}\r\nstatic void add_cond_wait(struct cond_wait **head, struct cond_wait *w)\r\n{\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&w->q, &w->wait);\r\nw->next = *head;\r\n*head = w;\r\n}\r\nstatic void remove_cond_wait(struct cond_wait **head, struct cond_wait *cw)\r\n{\r\nstruct cond_wait *w, *prev;\r\nremove_wait_queue(&cw->q, &cw->wait);\r\nset_current_state(TASK_RUNNING);\r\nfor (w = *head, prev = NULL ; w != NULL ; prev = w, w = w->next) {\r\nif (w == cw) {\r\nif (prev != NULL)\r\nprev->next = w->next;\r\nelse\r\n*head = w->next;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void flush_cond_wait(struct cond_wait **head)\r\n{\r\nwhile (*head != NULL) {\r\nwake_up_interruptible(&(*head)->q);\r\n*head = (*head)->next;\r\n}\r\n}\r\nstatic int wait_gpio(struct slgt_info *info, struct gpio_desc __user *user_gpio)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nstruct gpio_desc gpio;\r\nstruct cond_wait wait;\r\nu32 state;\r\nif (!info->gpio_present)\r\nreturn -EINVAL;\r\nif (copy_from_user(&gpio, user_gpio, sizeof(gpio)))\r\nreturn -EFAULT;\r\nDBGINFO(("%s wait_gpio() state=%08x smask=%08x\n",\r\ninfo->device_name, gpio.state, gpio.smask));\r\nif ((gpio.smask &= ~rd_reg32(info, IODR)) == 0)\r\nreturn -EINVAL;\r\ninit_cond_wait(&wait, gpio.smask);\r\nspin_lock_irqsave(&info->port_array[0]->lock, flags);\r\nwr_reg32(info, IOER, rd_reg32(info, IOER) | gpio.smask);\r\nstate = rd_reg32(info, IOVR);\r\nif (gpio.smask & ~(state ^ gpio.state)) {\r\ngpio.state = state;\r\n} else {\r\nadd_cond_wait(&info->gpio_wait_q, &wait);\r\nspin_unlock_irqrestore(&info->port_array[0]->lock, flags);\r\nschedule();\r\nif (signal_pending(current))\r\nrc = -ERESTARTSYS;\r\nelse\r\ngpio.state = wait.data;\r\nspin_lock_irqsave(&info->port_array[0]->lock, flags);\r\nremove_cond_wait(&info->gpio_wait_q, &wait);\r\n}\r\nif (info->gpio_wait_q == NULL)\r\nwr_reg32(info, IOER, 0);\r\nspin_unlock_irqrestore(&info->port_array[0]->lock, flags);\r\nif ((rc == 0) && copy_to_user(user_gpio, &gpio, sizeof(gpio)))\r\nrc = -EFAULT;\r\nreturn rc;\r\n}\r\nstatic int modem_input_wait(struct slgt_info *info,int arg)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nstruct mgsl_icount cprev, cnow;\r\nDECLARE_WAITQUEUE(wait, current);\r\nspin_lock_irqsave(&info->lock,flags);\r\ncprev = info->icount;\r\nadd_wait_queue(&info->status_event_wait_q, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nfor(;;) {\r\nschedule();\r\nif (signal_pending(current)) {\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->lock,flags);\r\ncnow = info->icount;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\r\ncnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nif ((arg & TIOCM_RNG && cnow.rng != cprev.rng) ||\r\n(arg & TIOCM_DSR && cnow.dsr != cprev.dsr) ||\r\n(arg & TIOCM_CD && cnow.dcd != cprev.dcd) ||\r\n(arg & TIOCM_CTS && cnow.cts != cprev.cts)) {\r\nrc = 0;\r\nbreak;\r\n}\r\ncprev = cnow;\r\n}\r\nremove_wait_queue(&info->status_event_wait_q, &wait);\r\nset_current_state(TASK_RUNNING);\r\nreturn rc;\r\n}\r\nstatic int tiocmget(struct tty_struct *tty)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned int result;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock,flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nresult = ((info->signals & SerialSignal_RTS) ? TIOCM_RTS:0) +\r\n((info->signals & SerialSignal_DTR) ? TIOCM_DTR:0) +\r\n((info->signals & SerialSignal_DCD) ? TIOCM_CAR:0) +\r\n((info->signals & SerialSignal_RI) ? TIOCM_RNG:0) +\r\n((info->signals & SerialSignal_DSR) ? TIOCM_DSR:0) +\r\n((info->signals & SerialSignal_CTS) ? TIOCM_CTS:0);\r\nDBGINFO(("%s tiocmget value=%08X\n", info->device_name, result));\r\nreturn result;\r\n}\r\nstatic int tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct slgt_info *info = tty->driver_data;\r\nunsigned long flags;\r\nDBGINFO(("%s tiocmset(%x,%x)\n", info->device_name, set, clear));\r\nif (set & TIOCM_RTS)\r\ninfo->signals |= SerialSignal_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->signals |= SerialSignal_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->signals &= ~SerialSignal_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->signals &= ~SerialSignal_DTR;\r\nspin_lock_irqsave(&info->lock,flags);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int carrier_raised(struct tty_port *port)\r\n{\r\nunsigned long flags;\r\nstruct slgt_info *info = container_of(port, struct slgt_info, port);\r\nspin_lock_irqsave(&info->lock,flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn (info->signals & SerialSignal_DCD) ? 1 : 0;\r\n}\r\nstatic void dtr_rts(struct tty_port *port, int on)\r\n{\r\nunsigned long flags;\r\nstruct slgt_info *info = container_of(port, struct slgt_info, port);\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (on)\r\ninfo->signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nelse\r\ninfo->signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nstatic int block_til_ready(struct tty_struct *tty, struct file *filp,\r\nstruct slgt_info *info)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nint retval;\r\nbool do_clocal = false;\r\nunsigned long flags;\r\nint cd;\r\nstruct tty_port *port = &info->port;\r\nDBGINFO(("%s block_til_ready\n", tty->driver->name));\r\nif (filp->f_flags & O_NONBLOCK || tty_io_error(tty)) {\r\ntty_port_set_active(port, 1);\r\nreturn 0;\r\n}\r\nif (C_CLOCAL(tty))\r\ndo_clocal = true;\r\nretval = 0;\r\nadd_wait_queue(&port->open_wait, &wait);\r\nspin_lock_irqsave(&info->lock, flags);\r\nport->count--;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nport->blocked_open++;\r\nwhile (1) {\r\nif (C_BAUD(tty) && tty_port_initialized(port))\r\ntty_port_raise_dtr_rts(port);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (tty_hung_up_p(filp) || !tty_port_initialized(port)) {\r\nretval = (port->flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS;\r\nbreak;\r\n}\r\ncd = tty_port_carrier_raised(port);\r\nif (do_clocal || cd)\r\nbreak;\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nDBGINFO(("%s block_til_ready wait\n", tty->driver->name));\r\ntty_unlock(tty);\r\nschedule();\r\ntty_lock(tty);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&port->open_wait, &wait);\r\nif (!tty_hung_up_p(filp))\r\nport->count++;\r\nport->blocked_open--;\r\nif (!retval)\r\ntty_port_set_active(port, 1);\r\nDBGINFO(("%s block_til_ready ready, rc=%d\n", tty->driver->name, retval));\r\nreturn retval;\r\n}\r\nstatic int alloc_tmp_rbuf(struct slgt_info *info)\r\n{\r\ninfo->tmp_rbuf = kmalloc(info->max_frame_size + 5, GFP_KERNEL);\r\nif (info->tmp_rbuf == NULL)\r\nreturn -ENOMEM;\r\ninfo->flag_buf = kzalloc(info->max_frame_size + 5, GFP_KERNEL);\r\nif (!info->flag_buf) {\r\nkfree(info->tmp_rbuf);\r\ninfo->tmp_rbuf = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_tmp_rbuf(struct slgt_info *info)\r\n{\r\nkfree(info->tmp_rbuf);\r\ninfo->tmp_rbuf = NULL;\r\nkfree(info->flag_buf);\r\ninfo->flag_buf = NULL;\r\n}\r\nstatic int alloc_desc(struct slgt_info *info)\r\n{\r\nunsigned int i;\r\nunsigned int pbufs;\r\ninfo->bufs = pci_zalloc_consistent(info->pdev, DESC_LIST_SIZE,\r\n&info->bufs_dma_addr);\r\nif (info->bufs == NULL)\r\nreturn -ENOMEM;\r\ninfo->rbufs = (struct slgt_desc*)info->bufs;\r\ninfo->tbufs = ((struct slgt_desc*)info->bufs) + info->rbuf_count;\r\npbufs = (unsigned int)info->bufs_dma_addr;\r\nfor (i=0; i < info->rbuf_count; i++) {\r\ninfo->rbufs[i].pdesc = pbufs + (i * sizeof(struct slgt_desc));\r\nif (i == info->rbuf_count - 1)\r\ninfo->rbufs[i].next = cpu_to_le32(pbufs);\r\nelse\r\ninfo->rbufs[i].next = cpu_to_le32(pbufs + ((i+1) * sizeof(struct slgt_desc)));\r\nset_desc_count(info->rbufs[i], DMABUFSIZE);\r\n}\r\nfor (i=0; i < info->tbuf_count; i++) {\r\ninfo->tbufs[i].pdesc = pbufs + ((info->rbuf_count + i) * sizeof(struct slgt_desc));\r\nif (i == info->tbuf_count - 1)\r\ninfo->tbufs[i].next = cpu_to_le32(pbufs + info->rbuf_count * sizeof(struct slgt_desc));\r\nelse\r\ninfo->tbufs[i].next = cpu_to_le32(pbufs + ((info->rbuf_count + i + 1) * sizeof(struct slgt_desc)));\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_desc(struct slgt_info *info)\r\n{\r\nif (info->bufs != NULL) {\r\npci_free_consistent(info->pdev, DESC_LIST_SIZE, info->bufs, info->bufs_dma_addr);\r\ninfo->bufs = NULL;\r\ninfo->rbufs = NULL;\r\ninfo->tbufs = NULL;\r\n}\r\n}\r\nstatic int alloc_bufs(struct slgt_info *info, struct slgt_desc *bufs, int count)\r\n{\r\nint i;\r\nfor (i=0; i < count; i++) {\r\nif ((bufs[i].buf = pci_alloc_consistent(info->pdev, DMABUFSIZE, &bufs[i].buf_dma_addr)) == NULL)\r\nreturn -ENOMEM;\r\nbufs[i].pbuf = cpu_to_le32((unsigned int)bufs[i].buf_dma_addr);\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_bufs(struct slgt_info *info, struct slgt_desc *bufs, int count)\r\n{\r\nint i;\r\nfor (i=0; i < count; i++) {\r\nif (bufs[i].buf == NULL)\r\ncontinue;\r\npci_free_consistent(info->pdev, DMABUFSIZE, bufs[i].buf, bufs[i].buf_dma_addr);\r\nbufs[i].buf = NULL;\r\n}\r\n}\r\nstatic int alloc_dma_bufs(struct slgt_info *info)\r\n{\r\ninfo->rbuf_count = 32;\r\ninfo->tbuf_count = 32;\r\nif (alloc_desc(info) < 0 ||\r\nalloc_bufs(info, info->rbufs, info->rbuf_count) < 0 ||\r\nalloc_bufs(info, info->tbufs, info->tbuf_count) < 0 ||\r\nalloc_tmp_rbuf(info) < 0) {\r\nDBGERR(("%s DMA buffer alloc fail\n", info->device_name));\r\nreturn -ENOMEM;\r\n}\r\nreset_rbufs(info);\r\nreturn 0;\r\n}\r\nstatic void free_dma_bufs(struct slgt_info *info)\r\n{\r\nif (info->bufs) {\r\nfree_bufs(info, info->rbufs, info->rbuf_count);\r\nfree_bufs(info, info->tbufs, info->tbuf_count);\r\nfree_desc(info);\r\n}\r\nfree_tmp_rbuf(info);\r\n}\r\nstatic int claim_resources(struct slgt_info *info)\r\n{\r\nif (request_mem_region(info->phys_reg_addr, SLGT_REG_SIZE, "synclink_gt") == NULL) {\r\nDBGERR(("%s reg addr conflict, addr=%08X\n",\r\ninfo->device_name, info->phys_reg_addr));\r\ninfo->init_error = DiagStatus_AddressConflict;\r\ngoto errout;\r\n}\r\nelse\r\ninfo->reg_addr_requested = true;\r\ninfo->reg_addr = ioremap_nocache(info->phys_reg_addr, SLGT_REG_SIZE);\r\nif (!info->reg_addr) {\r\nDBGERR(("%s can't map device registers, addr=%08X\n",\r\ninfo->device_name, info->phys_reg_addr));\r\ninfo->init_error = DiagStatus_CantAssignPciResources;\r\ngoto errout;\r\n}\r\nreturn 0;\r\nerrout:\r\nrelease_resources(info);\r\nreturn -ENODEV;\r\n}\r\nstatic void release_resources(struct slgt_info *info)\r\n{\r\nif (info->irq_requested) {\r\nfree_irq(info->irq_level, info);\r\ninfo->irq_requested = false;\r\n}\r\nif (info->reg_addr_requested) {\r\nrelease_mem_region(info->phys_reg_addr, SLGT_REG_SIZE);\r\ninfo->reg_addr_requested = false;\r\n}\r\nif (info->reg_addr) {\r\niounmap(info->reg_addr);\r\ninfo->reg_addr = NULL;\r\n}\r\n}\r\nstatic void add_device(struct slgt_info *info)\r\n{\r\nchar *devstr;\r\ninfo->next_device = NULL;\r\ninfo->line = slgt_device_count;\r\nsprintf(info->device_name, "%s%d", tty_dev_prefix, info->line);\r\nif (info->line < MAX_DEVICES) {\r\nif (maxframe[info->line])\r\ninfo->max_frame_size = maxframe[info->line];\r\n}\r\nslgt_device_count++;\r\nif (!slgt_device_list)\r\nslgt_device_list = info;\r\nelse {\r\nstruct slgt_info *current_dev = slgt_device_list;\r\nwhile(current_dev->next_device)\r\ncurrent_dev = current_dev->next_device;\r\ncurrent_dev->next_device = info;\r\n}\r\nif (info->max_frame_size < 4096)\r\ninfo->max_frame_size = 4096;\r\nelse if (info->max_frame_size > 65535)\r\ninfo->max_frame_size = 65535;\r\nswitch(info->pdev->device) {\r\ncase SYNCLINK_GT_DEVICE_ID:\r\ndevstr = "GT";\r\nbreak;\r\ncase SYNCLINK_GT2_DEVICE_ID:\r\ndevstr = "GT2";\r\nbreak;\r\ncase SYNCLINK_GT4_DEVICE_ID:\r\ndevstr = "GT4";\r\nbreak;\r\ncase SYNCLINK_AC_DEVICE_ID:\r\ndevstr = "AC";\r\ninfo->params.mode = MGSL_MODE_ASYNC;\r\nbreak;\r\ndefault:\r\ndevstr = "(unknown model)";\r\n}\r\nprintk("SyncLink %s %s IO=%08x IRQ=%d MaxFrameSize=%u\n",\r\ndevstr, info->device_name, info->phys_reg_addr,\r\ninfo->irq_level, info->max_frame_size);\r\n#if SYNCLINK_GENERIC_HDLC\r\nhdlcdev_init(info);\r\n#endif\r\n}\r\nstatic struct slgt_info *alloc_dev(int adapter_num, int port_num, struct pci_dev *pdev)\r\n{\r\nstruct slgt_info *info;\r\ninfo = kzalloc(sizeof(struct slgt_info), GFP_KERNEL);\r\nif (!info) {\r\nDBGERR(("%s device alloc failed adapter=%d port=%d\n",\r\ndriver_name, adapter_num, port_num));\r\n} else {\r\ntty_port_init(&info->port);\r\ninfo->port.ops = &slgt_port_ops;\r\ninfo->magic = MGSL_MAGIC;\r\nINIT_WORK(&info->task, bh_handler);\r\ninfo->max_frame_size = 4096;\r\ninfo->base_clock = 14745600;\r\ninfo->rbuf_fill_level = DMABUFSIZE;\r\ninfo->port.close_delay = 5*HZ/10;\r\ninfo->port.closing_wait = 30*HZ;\r\ninit_waitqueue_head(&info->status_event_wait_q);\r\ninit_waitqueue_head(&info->event_wait_q);\r\nspin_lock_init(&info->netlock);\r\nmemcpy(&info->params,&default_params,sizeof(MGSL_PARAMS));\r\ninfo->idle_mode = HDLC_TXIDLE_FLAGS;\r\ninfo->adapter_num = adapter_num;\r\ninfo->port_num = port_num;\r\nsetup_timer(&info->tx_timer, tx_timeout, (unsigned long)info);\r\nsetup_timer(&info->rx_timer, rx_timeout, (unsigned long)info);\r\ninfo->pdev = pdev;\r\ninfo->irq_level = pdev->irq;\r\ninfo->phys_reg_addr = pci_resource_start(pdev,0);\r\ninfo->bus_type = MGSL_BUS_TYPE_PCI;\r\ninfo->irq_flags = IRQF_SHARED;\r\ninfo->init_error = -1;\r\n}\r\nreturn info;\r\n}\r\nstatic void device_init(int adapter_num, struct pci_dev *pdev)\r\n{\r\nstruct slgt_info *port_array[SLGT_MAX_PORTS];\r\nint i;\r\nint port_count = 1;\r\nif (pdev->device == SYNCLINK_GT2_DEVICE_ID)\r\nport_count = 2;\r\nelse if (pdev->device == SYNCLINK_GT4_DEVICE_ID)\r\nport_count = 4;\r\nfor (i=0; i < port_count; ++i) {\r\nport_array[i] = alloc_dev(adapter_num, i, pdev);\r\nif (port_array[i] == NULL) {\r\nfor (--i; i >= 0; --i) {\r\ntty_port_destroy(&port_array[i]->port);\r\nkfree(port_array[i]);\r\n}\r\nreturn;\r\n}\r\n}\r\nfor (i=0; i < port_count; ++i) {\r\nmemcpy(port_array[i]->port_array, port_array, sizeof(port_array));\r\nadd_device(port_array[i]);\r\nport_array[i]->port_count = port_count;\r\nspin_lock_init(&port_array[i]->lock);\r\n}\r\nif (!claim_resources(port_array[0])) {\r\nalloc_dma_bufs(port_array[0]);\r\nfor (i = 1; i < port_count; ++i) {\r\nport_array[i]->irq_level = port_array[0]->irq_level;\r\nport_array[i]->reg_addr = port_array[0]->reg_addr;\r\nalloc_dma_bufs(port_array[i]);\r\n}\r\nif (request_irq(port_array[0]->irq_level,\r\nslgt_interrupt,\r\nport_array[0]->irq_flags,\r\nport_array[0]->device_name,\r\nport_array[0]) < 0) {\r\nDBGERR(("%s request_irq failed IRQ=%d\n",\r\nport_array[0]->device_name,\r\nport_array[0]->irq_level));\r\n} else {\r\nport_array[0]->irq_requested = true;\r\nadapter_test(port_array[0]);\r\nfor (i=1 ; i < port_count ; i++) {\r\nport_array[i]->init_error = port_array[0]->init_error;\r\nport_array[i]->gpio_present = port_array[0]->gpio_present;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < port_count; ++i) {\r\nstruct slgt_info *info = port_array[i];\r\ntty_port_register_device(&info->port, serial_driver, info->line,\r\n&info->pdev->dev);\r\n}\r\n}\r\nstatic int init_one(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nif (pci_enable_device(dev)) {\r\nprintk("error enabling pci device %p\n", dev);\r\nreturn -EIO;\r\n}\r\npci_set_master(dev);\r\ndevice_init(slgt_device_count, dev);\r\nreturn 0;\r\n}\r\nstatic void remove_one(struct pci_dev *dev)\r\n{\r\n}\r\nstatic void slgt_cleanup(void)\r\n{\r\nint rc;\r\nstruct slgt_info *info;\r\nstruct slgt_info *tmp;\r\nprintk(KERN_INFO "unload %s\n", driver_name);\r\nif (serial_driver) {\r\nfor (info=slgt_device_list ; info != NULL ; info=info->next_device)\r\ntty_unregister_device(serial_driver, info->line);\r\nrc = tty_unregister_driver(serial_driver);\r\nif (rc)\r\nDBGERR(("tty_unregister_driver error=%d\n", rc));\r\nput_tty_driver(serial_driver);\r\n}\r\ninfo = slgt_device_list;\r\nwhile(info) {\r\nreset_port(info);\r\ninfo = info->next_device;\r\n}\r\ninfo = slgt_device_list;\r\nwhile(info) {\r\n#if SYNCLINK_GENERIC_HDLC\r\nhdlcdev_exit(info);\r\n#endif\r\nfree_dma_bufs(info);\r\nfree_tmp_rbuf(info);\r\nif (info->port_num == 0)\r\nrelease_resources(info);\r\ntmp = info;\r\ninfo = info->next_device;\r\ntty_port_destroy(&tmp->port);\r\nkfree(tmp);\r\n}\r\nif (pci_registered)\r\npci_unregister_driver(&pci_driver);\r\n}\r\nstatic int __init slgt_init(void)\r\n{\r\nint rc;\r\nprintk(KERN_INFO "%s\n", driver_name);\r\nserial_driver = alloc_tty_driver(MAX_DEVICES);\r\nif (!serial_driver) {\r\nprintk("%s can't allocate tty driver\n", driver_name);\r\nreturn -ENOMEM;\r\n}\r\nserial_driver->driver_name = slgt_driver_name;\r\nserial_driver->name = tty_dev_prefix;\r\nserial_driver->major = ttymajor;\r\nserial_driver->minor_start = 64;\r\nserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nserial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nserial_driver->init_termios = tty_std_termios;\r\nserial_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\nserial_driver->init_termios.c_ispeed = 9600;\r\nserial_driver->init_termios.c_ospeed = 9600;\r\nserial_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ntty_set_operations(serial_driver, &ops);\r\nif ((rc = tty_register_driver(serial_driver)) < 0) {\r\nDBGERR(("%s can't register serial driver\n", driver_name));\r\nput_tty_driver(serial_driver);\r\nserial_driver = NULL;\r\ngoto error;\r\n}\r\nprintk(KERN_INFO "%s, tty major#%d\n",\r\ndriver_name, serial_driver->major);\r\nslgt_device_count = 0;\r\nif ((rc = pci_register_driver(&pci_driver)) < 0) {\r\nprintk("%s pci_register_driver error=%d\n", driver_name, rc);\r\ngoto error;\r\n}\r\npci_registered = true;\r\nif (!slgt_device_list)\r\nprintk("%s no devices found\n",driver_name);\r\nreturn 0;\r\nerror:\r\nslgt_cleanup();\r\nreturn rc;\r\n}\r\nstatic void __exit slgt_exit(void)\r\n{\r\nslgt_cleanup();\r\n}\r\nstatic __u8 rd_reg8(struct slgt_info *info, unsigned int addr)\r\n{\r\nCALC_REGADDR();\r\nreturn readb((void __iomem *)reg_addr);\r\n}\r\nstatic void wr_reg8(struct slgt_info *info, unsigned int addr, __u8 value)\r\n{\r\nCALC_REGADDR();\r\nwriteb(value, (void __iomem *)reg_addr);\r\n}\r\nstatic __u16 rd_reg16(struct slgt_info *info, unsigned int addr)\r\n{\r\nCALC_REGADDR();\r\nreturn readw((void __iomem *)reg_addr);\r\n}\r\nstatic void wr_reg16(struct slgt_info *info, unsigned int addr, __u16 value)\r\n{\r\nCALC_REGADDR();\r\nwritew(value, (void __iomem *)reg_addr);\r\n}\r\nstatic __u32 rd_reg32(struct slgt_info *info, unsigned int addr)\r\n{\r\nCALC_REGADDR();\r\nreturn readl((void __iomem *)reg_addr);\r\n}\r\nstatic void wr_reg32(struct slgt_info *info, unsigned int addr, __u32 value)\r\n{\r\nCALC_REGADDR();\r\nwritel(value, (void __iomem *)reg_addr);\r\n}\r\nstatic void rdma_reset(struct slgt_info *info)\r\n{\r\nunsigned int i;\r\nwr_reg32(info, RDCSR, BIT1);\r\nfor(i=0 ; i < 1000 ; i++)\r\nif (!(rd_reg32(info, RDCSR) & BIT0))\r\nbreak;\r\n}\r\nstatic void tdma_reset(struct slgt_info *info)\r\n{\r\nunsigned int i;\r\nwr_reg32(info, TDCSR, BIT1);\r\nfor(i=0 ; i < 1000 ; i++)\r\nif (!(rd_reg32(info, TDCSR) & BIT0))\r\nbreak;\r\n}\r\nstatic void enable_loopback(struct slgt_info *info)\r\n{\r\nwr_reg16(info, SCR, (unsigned short)(rd_reg16(info, SCR) | BIT2));\r\nif (info->params.mode != MGSL_MODE_ASYNC) {\r\nwr_reg8(info, CCR, 0x49);\r\nif (info->params.clock_speed)\r\nset_rate(info, info->params.clock_speed);\r\nelse\r\nset_rate(info, 3686400);\r\n}\r\n}\r\nstatic void set_rate(struct slgt_info *info, u32 rate)\r\n{\r\nunsigned int div;\r\nunsigned int osc = info->base_clock;\r\nif (rate) {\r\ndiv = osc/rate;\r\nif (!(osc % rate) && div)\r\ndiv--;\r\nwr_reg16(info, BDR, (unsigned short)div);\r\n}\r\n}\r\nstatic void rx_stop(struct slgt_info *info)\r\n{\r\nunsigned short val;\r\nval = rd_reg16(info, RCR) & ~BIT1;\r\nwr_reg16(info, RCR, (unsigned short)(val | BIT2));\r\nwr_reg16(info, RCR, val);\r\nslgt_irq_off(info, IRQ_RXOVER + IRQ_RXDATA + IRQ_RXIDLE);\r\nwr_reg16(info, SSR, IRQ_RXIDLE + IRQ_RXOVER);\r\nrdma_reset(info);\r\ninfo->rx_enabled = false;\r\ninfo->rx_restart = false;\r\n}\r\nstatic void rx_start(struct slgt_info *info)\r\n{\r\nunsigned short val;\r\nslgt_irq_off(info, IRQ_RXOVER + IRQ_RXDATA);\r\nwr_reg16(info, SSR, IRQ_RXOVER);\r\nval = rd_reg16(info, RCR) & ~BIT1;\r\nwr_reg16(info, RCR, (unsigned short)(val | BIT2));\r\nwr_reg16(info, RCR, val);\r\nrdma_reset(info);\r\nreset_rbufs(info);\r\nif (info->rx_pio) {\r\nwr_reg16(info, SCR, (unsigned short)(rd_reg16(info, SCR) & ~BIT14));\r\nslgt_irq_on(info, IRQ_RXDATA);\r\nif (info->params.mode == MGSL_MODE_ASYNC) {\r\nwr_reg32(info, RDCSR, BIT6);\r\n}\r\n} else {\r\nwr_reg16(info, SCR, (unsigned short)(rd_reg16(info, SCR) | BIT14));\r\nwr_reg32(info, RDDAR, info->rbufs[0].pdesc);\r\nif (info->params.mode != MGSL_MODE_ASYNC) {\r\nwr_reg32(info, RDCSR, (BIT2 + BIT0));\r\n} else {\r\nwr_reg32(info, RDCSR, (BIT6 + BIT2 + BIT0));\r\n}\r\n}\r\nslgt_irq_on(info, IRQ_RXOVER);\r\nwr_reg16(info, RCR, (unsigned short)(rd_reg16(info, RCR) | BIT1));\r\ninfo->rx_restart = false;\r\ninfo->rx_enabled = true;\r\n}\r\nstatic void tx_start(struct slgt_info *info)\r\n{\r\nif (!info->tx_enabled) {\r\nwr_reg16(info, TCR,\r\n(unsigned short)((rd_reg16(info, TCR) | BIT1) & ~BIT2));\r\ninfo->tx_enabled = true;\r\n}\r\nif (desc_count(info->tbufs[info->tbuf_start])) {\r\ninfo->drop_rts_on_tx_done = false;\r\nif (info->params.mode != MGSL_MODE_ASYNC) {\r\nif (info->params.flags & HDLC_FLAG_AUTO_RTS) {\r\nget_signals(info);\r\nif (!(info->signals & SerialSignal_RTS)) {\r\ninfo->signals |= SerialSignal_RTS;\r\nset_signals(info);\r\ninfo->drop_rts_on_tx_done = true;\r\n}\r\n}\r\nslgt_irq_off(info, IRQ_TXDATA);\r\nslgt_irq_on(info, IRQ_TXUNDER + IRQ_TXIDLE);\r\nwr_reg16(info, SSR, (unsigned short)(IRQ_TXIDLE + IRQ_TXUNDER));\r\n} else {\r\nslgt_irq_off(info, IRQ_TXDATA);\r\nslgt_irq_on(info, IRQ_TXIDLE);\r\nwr_reg16(info, SSR, IRQ_TXIDLE);\r\n}\r\nwr_reg32(info, TDDAR, info->tbufs[info->tbuf_start].pdesc);\r\nwr_reg32(info, TDCSR, BIT2 + BIT0);\r\ninfo->tx_active = true;\r\n}\r\n}\r\nstatic void tx_stop(struct slgt_info *info)\r\n{\r\nunsigned short val;\r\ndel_timer(&info->tx_timer);\r\ntdma_reset(info);\r\nval = rd_reg16(info, TCR) & ~BIT1;\r\nwr_reg16(info, TCR, (unsigned short)(val | BIT2));\r\nslgt_irq_off(info, IRQ_TXDATA + IRQ_TXIDLE + IRQ_TXUNDER);\r\nwr_reg16(info, SSR, (unsigned short)(IRQ_TXIDLE + IRQ_TXUNDER));\r\nreset_tbufs(info);\r\ninfo->tx_enabled = false;\r\ninfo->tx_active = false;\r\n}\r\nstatic void reset_port(struct slgt_info *info)\r\n{\r\nif (!info->reg_addr)\r\nreturn;\r\ntx_stop(info);\r\nrx_stop(info);\r\ninfo->signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nset_signals(info);\r\nslgt_irq_off(info, IRQ_ALL | IRQ_MASTER);\r\n}\r\nstatic void reset_adapter(struct slgt_info *info)\r\n{\r\nint i;\r\nfor (i=0; i < info->port_count; ++i) {\r\nif (info->port_array[i])\r\nreset_port(info->port_array[i]);\r\n}\r\n}\r\nstatic void async_mode(struct slgt_info *info)\r\n{\r\nunsigned short val;\r\nslgt_irq_off(info, IRQ_ALL | IRQ_MASTER);\r\ntx_stop(info);\r\nrx_stop(info);\r\nval = 0x4000;\r\nif (info->if_mode & MGSL_INTERFACE_RTS_EN)\r\nval |= BIT7;\r\nif (info->params.parity != ASYNC_PARITY_NONE) {\r\nval |= BIT9;\r\nif (info->params.parity == ASYNC_PARITY_ODD)\r\nval |= BIT8;\r\n}\r\nswitch (info->params.data_bits)\r\n{\r\ncase 6: val |= BIT4; break;\r\ncase 7: val |= BIT5; break;\r\ncase 8: val |= BIT5 + BIT4; break;\r\n}\r\nif (info->params.stop_bits != 1)\r\nval |= BIT3;\r\nif (info->params.flags & HDLC_FLAG_AUTO_CTS)\r\nval |= BIT0;\r\nwr_reg16(info, TCR, val);\r\nval = 0x4000;\r\nif (info->params.parity != ASYNC_PARITY_NONE) {\r\nval |= BIT9;\r\nif (info->params.parity == ASYNC_PARITY_ODD)\r\nval |= BIT8;\r\n}\r\nswitch (info->params.data_bits)\r\n{\r\ncase 6: val |= BIT4; break;\r\ncase 7: val |= BIT5; break;\r\ncase 8: val |= BIT5 + BIT4; break;\r\n}\r\nif (info->params.flags & HDLC_FLAG_AUTO_DCD)\r\nval |= BIT0;\r\nwr_reg16(info, RCR, val);\r\nwr_reg8(info, CCR, 0x69);\r\nmsc_set_vcr(info);\r\nval = BIT15 + BIT14 + BIT0;\r\nif ((rd_reg32(info, JCR) & BIT8) && info->params.data_rate &&\r\n((info->base_clock < (info->params.data_rate * 16)) ||\r\n(info->base_clock % (info->params.data_rate * 16)))) {\r\nval |= BIT3;\r\nset_rate(info, info->params.data_rate * 8);\r\n} else {\r\nset_rate(info, info->params.data_rate * 16);\r\n}\r\nwr_reg16(info, SCR, val);\r\nslgt_irq_on(info, IRQ_RXBREAK | IRQ_RXOVER);\r\nif (info->params.loopback)\r\nenable_loopback(info);\r\n}\r\nstatic void sync_mode(struct slgt_info *info)\r\n{\r\nunsigned short val;\r\nslgt_irq_off(info, IRQ_ALL | IRQ_MASTER);\r\ntx_stop(info);\r\nrx_stop(info);\r\nval = BIT2;\r\nswitch(info->params.mode) {\r\ncase MGSL_MODE_XSYNC:\r\nval |= BIT15 + BIT13;\r\nbreak;\r\ncase MGSL_MODE_MONOSYNC: val |= BIT14 + BIT13; break;\r\ncase MGSL_MODE_BISYNC: val |= BIT15; break;\r\ncase MGSL_MODE_RAW: val |= BIT13; break;\r\n}\r\nif (info->if_mode & MGSL_INTERFACE_RTS_EN)\r\nval |= BIT7;\r\nswitch(info->params.encoding)\r\n{\r\ncase HDLC_ENCODING_NRZB: val |= BIT10; break;\r\ncase HDLC_ENCODING_NRZI_MARK: val |= BIT11; break;\r\ncase HDLC_ENCODING_NRZI: val |= BIT11 + BIT10; break;\r\ncase HDLC_ENCODING_BIPHASE_MARK: val |= BIT12; break;\r\ncase HDLC_ENCODING_BIPHASE_SPACE: val |= BIT12 + BIT10; break;\r\ncase HDLC_ENCODING_BIPHASE_LEVEL: val |= BIT12 + BIT11; break;\r\ncase HDLC_ENCODING_DIFF_BIPHASE_LEVEL: val |= BIT12 + BIT11 + BIT10; break;\r\n}\r\nswitch (info->params.crc_type & HDLC_CRC_MASK)\r\n{\r\ncase HDLC_CRC_16_CCITT: val |= BIT9; break;\r\ncase HDLC_CRC_32_CCITT: val |= BIT9 + BIT8; break;\r\n}\r\nif (info->params.preamble != HDLC_PREAMBLE_PATTERN_NONE)\r\nval |= BIT6;\r\nswitch (info->params.preamble_length)\r\n{\r\ncase HDLC_PREAMBLE_LENGTH_16BITS: val |= BIT5; break;\r\ncase HDLC_PREAMBLE_LENGTH_32BITS: val |= BIT4; break;\r\ncase HDLC_PREAMBLE_LENGTH_64BITS: val |= BIT5 + BIT4; break;\r\n}\r\nif (info->params.flags & HDLC_FLAG_AUTO_CTS)\r\nval |= BIT0;\r\nwr_reg16(info, TCR, val);\r\nswitch (info->params.preamble)\r\n{\r\ncase HDLC_PREAMBLE_PATTERN_FLAGS: val = 0x7e; break;\r\ncase HDLC_PREAMBLE_PATTERN_ONES: val = 0xff; break;\r\ncase HDLC_PREAMBLE_PATTERN_ZEROS: val = 0x00; break;\r\ncase HDLC_PREAMBLE_PATTERN_10: val = 0x55; break;\r\ncase HDLC_PREAMBLE_PATTERN_01: val = 0xaa; break;\r\ndefault: val = 0x7e; break;\r\n}\r\nwr_reg8(info, TPR, (unsigned char)val);\r\nval = 0;\r\nswitch(info->params.mode) {\r\ncase MGSL_MODE_XSYNC:\r\nval |= BIT15 + BIT13;\r\nbreak;\r\ncase MGSL_MODE_MONOSYNC: val |= BIT14 + BIT13; break;\r\ncase MGSL_MODE_BISYNC: val |= BIT15; break;\r\ncase MGSL_MODE_RAW: val |= BIT13; break;\r\n}\r\nswitch(info->params.encoding)\r\n{\r\ncase HDLC_ENCODING_NRZB: val |= BIT10; break;\r\ncase HDLC_ENCODING_NRZI_MARK: val |= BIT11; break;\r\ncase HDLC_ENCODING_NRZI: val |= BIT11 + BIT10; break;\r\ncase HDLC_ENCODING_BIPHASE_MARK: val |= BIT12; break;\r\ncase HDLC_ENCODING_BIPHASE_SPACE: val |= BIT12 + BIT10; break;\r\ncase HDLC_ENCODING_BIPHASE_LEVEL: val |= BIT12 + BIT11; break;\r\ncase HDLC_ENCODING_DIFF_BIPHASE_LEVEL: val |= BIT12 + BIT11 + BIT10; break;\r\n}\r\nswitch (info->params.crc_type & HDLC_CRC_MASK)\r\n{\r\ncase HDLC_CRC_16_CCITT: val |= BIT9; break;\r\ncase HDLC_CRC_32_CCITT: val |= BIT9 + BIT8; break;\r\n}\r\nif (info->params.flags & HDLC_FLAG_AUTO_DCD)\r\nval |= BIT0;\r\nwr_reg16(info, RCR, val);\r\nval = 0;\r\nif (info->params.flags & HDLC_FLAG_TXC_BRG)\r\n{\r\nif (info->params.flags & HDLC_FLAG_RXC_DPLL)\r\nval |= BIT6 + BIT5;\r\nelse\r\nval |= BIT6;\r\n}\r\nelse if (info->params.flags & HDLC_FLAG_TXC_DPLL)\r\nval |= BIT7;\r\nelse if (info->params.flags & HDLC_FLAG_TXC_RXCPIN)\r\nval |= BIT5;\r\nif (info->params.flags & HDLC_FLAG_RXC_BRG)\r\nval |= BIT3;\r\nelse if (info->params.flags & HDLC_FLAG_RXC_DPLL)\r\nval |= BIT4;\r\nelse if (info->params.flags & HDLC_FLAG_RXC_TXCPIN)\r\nval |= BIT2;\r\nif (info->params.clock_speed)\r\nval |= BIT1 + BIT0;\r\nwr_reg8(info, CCR, (unsigned char)val);\r\nif (info->params.flags & (HDLC_FLAG_TXC_DPLL + HDLC_FLAG_RXC_DPLL))\r\n{\r\nswitch(info->params.encoding)\r\n{\r\ncase HDLC_ENCODING_BIPHASE_MARK:\r\ncase HDLC_ENCODING_BIPHASE_SPACE:\r\nval = BIT7; break;\r\ncase HDLC_ENCODING_BIPHASE_LEVEL:\r\ncase HDLC_ENCODING_DIFF_BIPHASE_LEVEL:\r\nval = BIT7 + BIT6; break;\r\ndefault: val = BIT6;\r\n}\r\nwr_reg16(info, RCR, (unsigned short)(rd_reg16(info, RCR) | val));\r\nset_rate(info, info->params.clock_speed * 16);\r\n}\r\nelse\r\nset_rate(info, info->params.clock_speed);\r\ntx_set_idle(info);\r\nmsc_set_vcr(info);\r\nwr_reg16(info, SCR, BIT15 + BIT14 + BIT0);\r\nif (info->params.loopback)\r\nenable_loopback(info);\r\n}\r\nstatic void tx_set_idle(struct slgt_info *info)\r\n{\r\nunsigned char val;\r\nunsigned short tcr;\r\ntcr = rd_reg16(info, TCR);\r\nif (info->idle_mode & HDLC_TXIDLE_CUSTOM_16) {\r\ntcr = (tcr & ~(BIT6 + BIT5)) | BIT4;\r\nwr_reg8(info, TPR, (unsigned char)((info->idle_mode >> 8) & 0xff));\r\n} else if (!(tcr & BIT6)) {\r\ntcr &= ~(BIT5 + BIT4);\r\n}\r\nwr_reg16(info, TCR, tcr);\r\nif (info->idle_mode & (HDLC_TXIDLE_CUSTOM_8 | HDLC_TXIDLE_CUSTOM_16)) {\r\nval = (unsigned char)(info->idle_mode & 0xff);\r\n} else {\r\nswitch(info->idle_mode)\r\n{\r\ncase HDLC_TXIDLE_FLAGS: val = 0x7e; break;\r\ncase HDLC_TXIDLE_ALT_ZEROS_ONES:\r\ncase HDLC_TXIDLE_ALT_MARK_SPACE: val = 0xaa; break;\r\ncase HDLC_TXIDLE_ZEROS:\r\ncase HDLC_TXIDLE_SPACE: val = 0x00; break;\r\ndefault: val = 0xff;\r\n}\r\n}\r\nwr_reg8(info, TIR, val);\r\n}\r\nstatic void get_signals(struct slgt_info *info)\r\n{\r\nunsigned short status = rd_reg16(info, SSR);\r\ninfo->signals &= SerialSignal_RTS | SerialSignal_DTR;\r\nif (status & BIT3)\r\ninfo->signals |= SerialSignal_DSR;\r\nif (status & BIT2)\r\ninfo->signals |= SerialSignal_CTS;\r\nif (status & BIT1)\r\ninfo->signals |= SerialSignal_DCD;\r\nif (status & BIT0)\r\ninfo->signals |= SerialSignal_RI;\r\n}\r\nstatic void msc_set_vcr(struct slgt_info *info)\r\n{\r\nunsigned char val = 0;\r\nswitch(info->if_mode & MGSL_INTERFACE_MASK)\r\n{\r\ncase MGSL_INTERFACE_RS232:\r\nval |= BIT5;\r\nbreak;\r\ncase MGSL_INTERFACE_V35:\r\nval |= BIT7 + BIT6 + BIT5;\r\nbreak;\r\ncase MGSL_INTERFACE_RS422:\r\nval |= BIT6;\r\nbreak;\r\n}\r\nif (info->if_mode & MGSL_INTERFACE_MSB_FIRST)\r\nval |= BIT4;\r\nif (info->signals & SerialSignal_DTR)\r\nval |= BIT3;\r\nif (info->signals & SerialSignal_RTS)\r\nval |= BIT2;\r\nif (info->if_mode & MGSL_INTERFACE_LL)\r\nval |= BIT1;\r\nif (info->if_mode & MGSL_INTERFACE_RL)\r\nval |= BIT0;\r\nwr_reg8(info, VCR, val);\r\n}\r\nstatic void set_signals(struct slgt_info *info)\r\n{\r\nunsigned char val = rd_reg8(info, VCR);\r\nif (info->signals & SerialSignal_DTR)\r\nval |= BIT3;\r\nelse\r\nval &= ~BIT3;\r\nif (info->signals & SerialSignal_RTS)\r\nval |= BIT2;\r\nelse\r\nval &= ~BIT2;\r\nwr_reg8(info, VCR, val);\r\n}\r\nstatic void free_rbufs(struct slgt_info *info, unsigned int i, unsigned int last)\r\n{\r\nint done = 0;\r\nwhile(!done) {\r\ninfo->rbufs[i].status = 0;\r\nset_desc_count(info->rbufs[i], info->rbuf_fill_level);\r\nif (i == last)\r\ndone = 1;\r\nif (++i == info->rbuf_count)\r\ni = 0;\r\n}\r\ninfo->rbuf_current = i;\r\n}\r\nstatic void reset_rbufs(struct slgt_info *info)\r\n{\r\nfree_rbufs(info, 0, info->rbuf_count - 1);\r\ninfo->rbuf_fill_index = 0;\r\ninfo->rbuf_fill_count = 0;\r\n}\r\nstatic bool rx_get_frame(struct slgt_info *info)\r\n{\r\nunsigned int start, end;\r\nunsigned short status;\r\nunsigned int framesize = 0;\r\nunsigned long flags;\r\nstruct tty_struct *tty = info->port.tty;\r\nunsigned char addr_field = 0xff;\r\nunsigned int crc_size = 0;\r\nswitch (info->params.crc_type & HDLC_CRC_MASK) {\r\ncase HDLC_CRC_16_CCITT: crc_size = 2; break;\r\ncase HDLC_CRC_32_CCITT: crc_size = 4; break;\r\n}\r\ncheck_again:\r\nframesize = 0;\r\naddr_field = 0xff;\r\nstart = end = info->rbuf_current;\r\nfor (;;) {\r\nif (!desc_complete(info->rbufs[end]))\r\ngoto cleanup;\r\nif (framesize == 0 && info->params.addr_filter != 0xff)\r\naddr_field = info->rbufs[end].buf[0];\r\nframesize += desc_count(info->rbufs[end]);\r\nif (desc_eof(info->rbufs[end]))\r\nbreak;\r\nif (++end == info->rbuf_count)\r\nend = 0;\r\nif (end == info->rbuf_current) {\r\nif (info->rx_enabled){\r\nspin_lock_irqsave(&info->lock,flags);\r\nrx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\ngoto cleanup;\r\n}\r\n}\r\nstatus = desc_status(info->rbufs[end]);\r\nif ((info->params.crc_type & HDLC_CRC_MASK) == HDLC_CRC_NONE)\r\nstatus &= ~BIT1;\r\nif (framesize == 0 ||\r\n(addr_field != 0xff && addr_field != info->params.addr_filter)) {\r\nfree_rbufs(info, start, end);\r\ngoto check_again;\r\n}\r\nif (framesize < (2 + crc_size) || status & BIT0) {\r\ninfo->icount.rxshort++;\r\nframesize = 0;\r\n} else if (status & BIT1) {\r\ninfo->icount.rxcrc++;\r\nif (!(info->params.crc_type & HDLC_CRC_RETURN_EX))\r\nframesize = 0;\r\n}\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (framesize == 0) {\r\ninfo->netdev->stats.rx_errors++;\r\ninfo->netdev->stats.rx_frame_errors++;\r\n}\r\n#endif\r\nDBGBH(("%s rx frame status=%04X size=%d\n",\r\ninfo->device_name, status, framesize));\r\nDBGDATA(info, info->rbufs[start].buf, min_t(int, framesize, info->rbuf_fill_level), "rx");\r\nif (framesize) {\r\nif (!(info->params.crc_type & HDLC_CRC_RETURN_EX)) {\r\nframesize -= crc_size;\r\ncrc_size = 0;\r\n}\r\nif (framesize > info->max_frame_size + crc_size)\r\ninfo->icount.rxlong++;\r\nelse {\r\nint copy_count = framesize;\r\nint i = start;\r\nunsigned char *p = info->tmp_rbuf;\r\ninfo->tmp_rbuf_count = framesize;\r\ninfo->icount.rxok++;\r\nwhile(copy_count) {\r\nint partial_count = min_t(int, copy_count, info->rbuf_fill_level);\r\nmemcpy(p, info->rbufs[i].buf, partial_count);\r\np += partial_count;\r\ncopy_count -= partial_count;\r\nif (++i == info->rbuf_count)\r\ni = 0;\r\n}\r\nif (info->params.crc_type & HDLC_CRC_RETURN_EX) {\r\n*p = (status & BIT1) ? RX_CRC_ERROR : RX_OK;\r\nframesize++;\r\n}\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_rx(info,info->tmp_rbuf, framesize);\r\nelse\r\n#endif\r\nldisc_receive_buf(tty, info->tmp_rbuf, info->flag_buf, framesize);\r\n}\r\n}\r\nfree_rbufs(info, start, end);\r\nreturn true;\r\ncleanup:\r\nreturn false;\r\n}\r\nstatic bool rx_get_buf(struct slgt_info *info)\r\n{\r\nunsigned int i = info->rbuf_current;\r\nunsigned int count;\r\nif (!desc_complete(info->rbufs[i]))\r\nreturn false;\r\ncount = desc_count(info->rbufs[i]);\r\nswitch(info->params.mode) {\r\ncase MGSL_MODE_MONOSYNC:\r\ncase MGSL_MODE_BISYNC:\r\ncase MGSL_MODE_XSYNC:\r\nif (desc_residue(info->rbufs[i]))\r\ncount--;\r\nbreak;\r\n}\r\nDBGDATA(info, info->rbufs[i].buf, count, "rx");\r\nDBGINFO(("rx_get_buf size=%d\n", count));\r\nif (count)\r\nldisc_receive_buf(info->port.tty, info->rbufs[i].buf,\r\ninfo->flag_buf, count);\r\nfree_rbufs(info, i, i);\r\nreturn true;\r\n}\r\nstatic void reset_tbufs(struct slgt_info *info)\r\n{\r\nunsigned int i;\r\ninfo->tbuf_current = 0;\r\nfor (i=0 ; i < info->tbuf_count ; i++) {\r\ninfo->tbufs[i].status = 0;\r\ninfo->tbufs[i].count = 0;\r\n}\r\n}\r\nstatic unsigned int free_tbuf_count(struct slgt_info *info)\r\n{\r\nunsigned int count = 0;\r\nunsigned int i = info->tbuf_current;\r\ndo\r\n{\r\nif (desc_count(info->tbufs[i]))\r\nbreak;\r\n++count;\r\nif (++i == info->tbuf_count)\r\ni=0;\r\n} while (i != info->tbuf_current);\r\nif (count && (rd_reg32(info, TDCSR) & BIT0))\r\n--count;\r\nreturn count;\r\n}\r\nstatic unsigned int tbuf_bytes(struct slgt_info *info)\r\n{\r\nunsigned int total_count = 0;\r\nunsigned int i = info->tbuf_current;\r\nunsigned int reg_value;\r\nunsigned int count;\r\nunsigned int active_buf_count = 0;\r\ndo {\r\ncount = desc_count(info->tbufs[i]);\r\nif (count)\r\ntotal_count += count;\r\nelse if (!total_count)\r\nactive_buf_count = info->tbufs[i].buf_count;\r\nif (++i == info->tbuf_count)\r\ni = 0;\r\n} while (i != info->tbuf_current);\r\nreg_value = rd_reg32(info, TDCSR);\r\nif (reg_value & BIT0)\r\ntotal_count += active_buf_count;\r\ntotal_count += (reg_value >> 8) & 0xff;\r\nif (info->tx_active)\r\ntotal_count++;\r\nreturn total_count;\r\n}\r\nstatic bool tx_load(struct slgt_info *info, const char *buf, unsigned int size)\r\n{\r\nunsigned short count;\r\nunsigned int i;\r\nstruct slgt_desc *d;\r\nif (DIV_ROUND_UP(size, DMABUFSIZE) > free_tbuf_count(info))\r\nreturn false;\r\nDBGDATA(info, buf, size, "tx");\r\ninfo->tbuf_start = i = info->tbuf_current;\r\nwhile (size) {\r\nd = &info->tbufs[i];\r\ncount = (unsigned short)((size > DMABUFSIZE) ? DMABUFSIZE : size);\r\nmemcpy(d->buf, buf, count);\r\nsize -= count;\r\nbuf += count;\r\nif ((!size && info->params.mode == MGSL_MODE_HDLC) ||\r\ninfo->params.mode == MGSL_MODE_RAW)\r\nset_desc_eof(*d, 1);\r\nelse\r\nset_desc_eof(*d, 0);\r\nif (i != info->tbuf_start)\r\nset_desc_count(*d, count);\r\nd->buf_count = count;\r\nif (++i == info->tbuf_count)\r\ni = 0;\r\n}\r\ninfo->tbuf_current = i;\r\nd = &info->tbufs[info->tbuf_start];\r\nset_desc_count(*d, d->buf_count);\r\nif (!info->tx_active)\r\ntx_start(info);\r\nupdate_tx_timer(info);\r\nreturn true;\r\n}\r\nstatic int register_test(struct slgt_info *info)\r\n{\r\nstatic unsigned short patterns[] =\r\n{0x0000, 0xffff, 0xaaaa, 0x5555, 0x6969, 0x9696};\r\nstatic unsigned int count = ARRAY_SIZE(patterns);\r\nunsigned int i;\r\nint rc = 0;\r\nfor (i=0 ; i < count ; i++) {\r\nwr_reg16(info, TIR, patterns[i]);\r\nwr_reg16(info, BDR, patterns[(i+1)%count]);\r\nif ((rd_reg16(info, TIR) != patterns[i]) ||\r\n(rd_reg16(info, BDR) != patterns[(i+1)%count])) {\r\nrc = -ENODEV;\r\nbreak;\r\n}\r\n}\r\ninfo->gpio_present = (rd_reg32(info, JCR) & BIT5) ? 1 : 0;\r\ninfo->init_error = rc ? 0 : DiagStatus_AddressFailure;\r\nreturn rc;\r\n}\r\nstatic int irq_test(struct slgt_info *info)\r\n{\r\nunsigned long timeout;\r\nunsigned long flags;\r\nstruct tty_struct *oldtty = info->port.tty;\r\nu32 speed = info->params.data_rate;\r\ninfo->params.data_rate = 921600;\r\ninfo->port.tty = NULL;\r\nspin_lock_irqsave(&info->lock, flags);\r\nasync_mode(info);\r\nslgt_irq_on(info, IRQ_TXIDLE);\r\nwr_reg16(info, TCR,\r\n(unsigned short)(rd_reg16(info, TCR) | BIT1));\r\nwr_reg16(info, TDR, 0);\r\ninfo->init_error = DiagStatus_IrqFailure;\r\ninfo->irq_occurred = false;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\ntimeout=100;\r\nwhile(timeout-- && !info->irq_occurred)\r\nmsleep_interruptible(10);\r\nspin_lock_irqsave(&info->lock,flags);\r\nreset_port(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\ninfo->params.data_rate = speed;\r\ninfo->port.tty = oldtty;\r\ninfo->init_error = info->irq_occurred ? 0 : DiagStatus_IrqFailure;\r\nreturn info->irq_occurred ? 0 : -ENODEV;\r\n}\r\nstatic int loopback_test_rx(struct slgt_info *info)\r\n{\r\nunsigned char *src, *dest;\r\nint count;\r\nif (desc_complete(info->rbufs[0])) {\r\ncount = desc_count(info->rbufs[0]);\r\nsrc = info->rbufs[0].buf;\r\ndest = info->tmp_rbuf;\r\nfor( ; count ; count-=2, src+=2) {\r\nif (!(*(src+1) & (BIT9 + BIT8))) {\r\n*dest = *src;\r\ndest++;\r\ninfo->tmp_rbuf_count++;\r\n}\r\n}\r\nDBGDATA(info, info->tmp_rbuf, info->tmp_rbuf_count, "rx");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int loopback_test(struct slgt_info *info)\r\n{\r\n#define TESTFRAMESIZE 20\r\nunsigned long timeout;\r\nu16 count = TESTFRAMESIZE;\r\nunsigned char buf[TESTFRAMESIZE];\r\nint rc = -ENODEV;\r\nunsigned long flags;\r\nstruct tty_struct *oldtty = info->port.tty;\r\nMGSL_PARAMS params;\r\nmemcpy(&params, &info->params, sizeof(params));\r\ninfo->params.mode = MGSL_MODE_ASYNC;\r\ninfo->params.data_rate = 921600;\r\ninfo->params.loopback = 1;\r\ninfo->port.tty = NULL;\r\nfor (count = 0; count < TESTFRAMESIZE; ++count)\r\nbuf[count] = (unsigned char)count;\r\ninfo->tmp_rbuf_count = 0;\r\nmemset(info->tmp_rbuf, 0, TESTFRAMESIZE);\r\nspin_lock_irqsave(&info->lock,flags);\r\nasync_mode(info);\r\nrx_start(info);\r\ntx_load(info, buf, count);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nfor (timeout = 100; timeout; --timeout) {\r\nmsleep_interruptible(10);\r\nif (loopback_test_rx(info)) {\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nif (!rc && (info->tmp_rbuf_count != count ||\r\nmemcmp(buf, info->tmp_rbuf, count))) {\r\nrc = -ENODEV;\r\n}\r\nspin_lock_irqsave(&info->lock,flags);\r\nreset_adapter(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nmemcpy(&info->params, &params, sizeof(info->params));\r\ninfo->port.tty = oldtty;\r\ninfo->init_error = rc ? DiagStatus_DmaFailure : 0;\r\nreturn rc;\r\n}\r\nstatic int adapter_test(struct slgt_info *info)\r\n{\r\nDBGINFO(("testing %s\n", info->device_name));\r\nif (register_test(info) < 0) {\r\nprintk("register test failure %s addr=%08X\n",\r\ninfo->device_name, info->phys_reg_addr);\r\n} else if (irq_test(info) < 0) {\r\nprintk("IRQ test failure %s IRQ=%d\n",\r\ninfo->device_name, info->irq_level);\r\n} else if (loopback_test(info) < 0) {\r\nprintk("loopback test failure %s\n", info->device_name);\r\n}\r\nreturn info->init_error;\r\n}\r\nstatic void tx_timeout(unsigned long context)\r\n{\r\nstruct slgt_info *info = (struct slgt_info*)context;\r\nunsigned long flags;\r\nDBGINFO(("%s tx_timeout\n", info->device_name));\r\nif(info->tx_active && info->params.mode == MGSL_MODE_HDLC) {\r\ninfo->icount.txtimeout++;\r\n}\r\nspin_lock_irqsave(&info->lock,flags);\r\ntx_stop(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_tx_done(info);\r\nelse\r\n#endif\r\nbh_transmit(info);\r\n}\r\nstatic void rx_timeout(unsigned long context)\r\n{\r\nstruct slgt_info *info = (struct slgt_info*)context;\r\nunsigned long flags;\r\nDBGINFO(("%s rx_timeout\n", info->device_name));\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->pending_bh |= BH_RECEIVE;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nbh_handler(&info->task);\r\n}
