static inline u32\r\npsb_pipestat(int pipe)\r\n{\r\nif (pipe == 0)\r\nreturn PIPEASTAT;\r\nif (pipe == 1)\r\nreturn PIPEBSTAT;\r\nif (pipe == 2)\r\nreturn PIPECSTAT;\r\nBUG();\r\n}\r\nstatic inline u32\r\nmid_pipe_event(int pipe)\r\n{\r\nif (pipe == 0)\r\nreturn _PSB_PIPEA_EVENT_FLAG;\r\nif (pipe == 1)\r\nreturn _MDFLD_PIPEB_EVENT_FLAG;\r\nif (pipe == 2)\r\nreturn _MDFLD_PIPEC_EVENT_FLAG;\r\nBUG();\r\n}\r\nstatic inline u32\r\nmid_pipe_vsync(int pipe)\r\n{\r\nif (pipe == 0)\r\nreturn _PSB_VSYNC_PIPEA_FLAG;\r\nif (pipe == 1)\r\nreturn _PSB_VSYNC_PIPEB_FLAG;\r\nif (pipe == 2)\r\nreturn _MDFLD_PIPEC_VBLANK_FLAG;\r\nBUG();\r\n}\r\nstatic inline u32\r\nmid_pipeconf(int pipe)\r\n{\r\nif (pipe == 0)\r\nreturn PIPEACONF;\r\nif (pipe == 1)\r\nreturn PIPEBCONF;\r\nif (pipe == 2)\r\nreturn PIPECCONF;\r\nBUG();\r\n}\r\nvoid\r\npsb_enable_pipestat(struct drm_psb_private *dev_priv, int pipe, u32 mask)\r\n{\r\nif ((dev_priv->pipestat[pipe] & mask) != mask) {\r\nu32 reg = psb_pipestat(pipe);\r\ndev_priv->pipestat[pipe] |= mask;\r\nif (gma_power_begin(dev_priv->dev, false)) {\r\nu32 writeVal = PSB_RVDC32(reg);\r\nwriteVal |= (mask | (mask >> 16));\r\nPSB_WVDC32(writeVal, reg);\r\n(void) PSB_RVDC32(reg);\r\ngma_power_end(dev_priv->dev);\r\n}\r\n}\r\n}\r\nvoid\r\npsb_disable_pipestat(struct drm_psb_private *dev_priv, int pipe, u32 mask)\r\n{\r\nif ((dev_priv->pipestat[pipe] & mask) != 0) {\r\nu32 reg = psb_pipestat(pipe);\r\ndev_priv->pipestat[pipe] &= ~mask;\r\nif (gma_power_begin(dev_priv->dev, false)) {\r\nu32 writeVal = PSB_RVDC32(reg);\r\nwriteVal &= ~mask;\r\nPSB_WVDC32(writeVal, reg);\r\n(void) PSB_RVDC32(reg);\r\ngma_power_end(dev_priv->dev);\r\n}\r\n}\r\n}\r\nstatic void mid_enable_pipe_event(struct drm_psb_private *dev_priv, int pipe)\r\n{\r\nif (gma_power_begin(dev_priv->dev, false)) {\r\nu32 pipe_event = mid_pipe_event(pipe);\r\ndev_priv->vdc_irq_mask |= pipe_event;\r\nPSB_WVDC32(~dev_priv->vdc_irq_mask, PSB_INT_MASK_R);\r\nPSB_WVDC32(dev_priv->vdc_irq_mask, PSB_INT_ENABLE_R);\r\ngma_power_end(dev_priv->dev);\r\n}\r\n}\r\nstatic void mid_disable_pipe_event(struct drm_psb_private *dev_priv, int pipe)\r\n{\r\nif (dev_priv->pipestat[pipe] == 0) {\r\nif (gma_power_begin(dev_priv->dev, false)) {\r\nu32 pipe_event = mid_pipe_event(pipe);\r\ndev_priv->vdc_irq_mask &= ~pipe_event;\r\nPSB_WVDC32(~dev_priv->vdc_irq_mask, PSB_INT_MASK_R);\r\nPSB_WVDC32(dev_priv->vdc_irq_mask, PSB_INT_ENABLE_R);\r\ngma_power_end(dev_priv->dev);\r\n}\r\n}\r\n}\r\nstatic void mid_pipe_event_handler(struct drm_device *dev, int pipe)\r\n{\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *) dev->dev_private;\r\nuint32_t pipe_stat_val = 0;\r\nuint32_t pipe_stat_reg = psb_pipestat(pipe);\r\nuint32_t pipe_enable = dev_priv->pipestat[pipe];\r\nuint32_t pipe_status = dev_priv->pipestat[pipe] >> 16;\r\nuint32_t pipe_clear;\r\nuint32_t i = 0;\r\nspin_lock(&dev_priv->irqmask_lock);\r\npipe_stat_val = PSB_RVDC32(pipe_stat_reg);\r\npipe_stat_val &= pipe_enable | pipe_status;\r\npipe_stat_val &= pipe_stat_val >> 16;\r\nspin_unlock(&dev_priv->irqmask_lock);\r\nfor (i = 0; i < 0xffff; i++) {\r\nPSB_WVDC32(PSB_RVDC32(pipe_stat_reg), pipe_stat_reg);\r\npipe_clear = PSB_RVDC32(pipe_stat_reg) & pipe_status;\r\nif (pipe_clear == 0)\r\nbreak;\r\n}\r\nif (pipe_clear)\r\ndev_err(dev->dev,\r\n"%s, can't clear status bits for pipe %d, its value = 0x%x.\n",\r\n__func__, pipe, PSB_RVDC32(pipe_stat_reg));\r\nif (pipe_stat_val & PIPE_VBLANK_STATUS)\r\ndrm_handle_vblank(dev, pipe);\r\nif (pipe_stat_val & PIPE_TE_STATUS)\r\ndrm_handle_vblank(dev, pipe);\r\n}\r\nstatic void psb_vdc_interrupt(struct drm_device *dev, uint32_t vdc_stat)\r\n{\r\nif (vdc_stat & _PSB_IRQ_ASLE)\r\npsb_intel_opregion_asle_intr(dev);\r\nif (vdc_stat & _PSB_VSYNC_PIPEA_FLAG)\r\nmid_pipe_event_handler(dev, 0);\r\nif (vdc_stat & _PSB_VSYNC_PIPEB_FLAG)\r\nmid_pipe_event_handler(dev, 1);\r\n}\r\nstatic void psb_sgx_interrupt(struct drm_device *dev, u32 stat_1, u32 stat_2)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 val, addr;\r\nint error = false;\r\nif (stat_1 & _PSB_CE_TWOD_COMPLETE)\r\nval = PSB_RSGX32(PSB_CR_2D_BLIT_STATUS);\r\nif (stat_2 & _PSB_CE2_BIF_REQUESTER_FAULT) {\r\nval = PSB_RSGX32(PSB_CR_BIF_INT_STAT);\r\naddr = PSB_RSGX32(PSB_CR_BIF_FAULT);\r\nif (val) {\r\nif (val & _PSB_CBI_STAT_PF_N_RW)\r\nDRM_ERROR("SGX MMU page fault:");\r\nelse\r\nDRM_ERROR("SGX MMU read / write protection fault:");\r\nif (val & _PSB_CBI_STAT_FAULT_CACHE)\r\nDRM_ERROR("\tCache requestor");\r\nif (val & _PSB_CBI_STAT_FAULT_TA)\r\nDRM_ERROR("\tTA requestor");\r\nif (val & _PSB_CBI_STAT_FAULT_VDM)\r\nDRM_ERROR("\tVDM requestor");\r\nif (val & _PSB_CBI_STAT_FAULT_2D)\r\nDRM_ERROR("\t2D requestor");\r\nif (val & _PSB_CBI_STAT_FAULT_PBE)\r\nDRM_ERROR("\tPBE requestor");\r\nif (val & _PSB_CBI_STAT_FAULT_TSP)\r\nDRM_ERROR("\tTSP requestor");\r\nif (val & _PSB_CBI_STAT_FAULT_ISP)\r\nDRM_ERROR("\tISP requestor");\r\nif (val & _PSB_CBI_STAT_FAULT_USSEPDS)\r\nDRM_ERROR("\tUSSEPDS requestor");\r\nif (val & _PSB_CBI_STAT_FAULT_HOST)\r\nDRM_ERROR("\tHost requestor");\r\nDRM_ERROR("\tMMU failing address is 0x%08x.\n",\r\n(unsigned int)addr);\r\nerror = true;\r\n}\r\n}\r\nPSB_WSGX32(stat_1, PSB_CR_EVENT_HOST_CLEAR);\r\nPSB_WSGX32(stat_2, PSB_CR_EVENT_HOST_CLEAR2);\r\nPSB_RSGX32(PSB_CR_EVENT_HOST_CLEAR2);\r\n}\r\nirqreturn_t psb_irq_handler(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = arg;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nuint32_t vdc_stat, dsp_int = 0, sgx_int = 0, hotplug_int = 0;\r\nu32 sgx_stat_1, sgx_stat_2;\r\nint handled = 0;\r\nspin_lock(&dev_priv->irqmask_lock);\r\nvdc_stat = PSB_RVDC32(PSB_INT_IDENTITY_R);\r\nif (vdc_stat & (_PSB_PIPE_EVENT_FLAG|_PSB_IRQ_ASLE))\r\ndsp_int = 1;\r\nif (vdc_stat & _PSB_IRQ_SGX_FLAG)\r\nsgx_int = 1;\r\nif (vdc_stat & _PSB_IRQ_DISP_HOTSYNC)\r\nhotplug_int = 1;\r\nvdc_stat &= dev_priv->vdc_irq_mask;\r\nspin_unlock(&dev_priv->irqmask_lock);\r\nif (dsp_int && gma_power_is_on(dev)) {\r\npsb_vdc_interrupt(dev, vdc_stat);\r\nhandled = 1;\r\n}\r\nif (sgx_int) {\r\nsgx_stat_1 = PSB_RSGX32(PSB_CR_EVENT_STATUS);\r\nsgx_stat_2 = PSB_RSGX32(PSB_CR_EVENT_STATUS2);\r\npsb_sgx_interrupt(dev, sgx_stat_1, sgx_stat_2);\r\nhandled = 1;\r\n}\r\nif (hotplug_int && dev_priv->ops->hotplug) {\r\nhandled = dev_priv->ops->hotplug(dev);\r\nREG_WRITE(PORT_HOTPLUG_STAT, REG_READ(PORT_HOTPLUG_STAT));\r\n}\r\nPSB_WVDC32(vdc_stat, PSB_INT_IDENTITY_R);\r\n(void) PSB_RVDC32(PSB_INT_IDENTITY_R);\r\nrmb();\r\nif (!handled)\r\nreturn IRQ_NONE;\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid psb_irq_preinstall(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *) dev->dev_private;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nif (gma_power_is_on(dev)) {\r\nPSB_WVDC32(0xFFFFFFFF, PSB_HWSTAM);\r\nPSB_WVDC32(0x00000000, PSB_INT_MASK_R);\r\nPSB_WVDC32(0x00000000, PSB_INT_ENABLE_R);\r\nPSB_WSGX32(0x00000000, PSB_CR_EVENT_HOST_ENABLE);\r\nPSB_RSGX32(PSB_CR_EVENT_HOST_ENABLE);\r\n}\r\nif (dev->vblank[0].enabled)\r\ndev_priv->vdc_irq_mask |= _PSB_VSYNC_PIPEA_FLAG;\r\nif (dev->vblank[1].enabled)\r\ndev_priv->vdc_irq_mask |= _PSB_VSYNC_PIPEB_FLAG;\r\nif (dev_priv->ops->hotplug)\r\ndev_priv->vdc_irq_mask |= _PSB_IRQ_DISP_HOTSYNC;\r\ndev_priv->vdc_irq_mask |= _PSB_IRQ_ASLE | _PSB_IRQ_SGX_FLAG;\r\nPSB_WVDC32(~dev_priv->vdc_irq_mask, PSB_INT_MASK_R);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\n}\r\nint psb_irq_postinstall(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nPSB_WSGX32(_PSB_CE2_BIF_REQUESTER_FAULT, PSB_CR_EVENT_HOST_ENABLE2);\r\nPSB_WSGX32(_PSB_CE_TWOD_COMPLETE, PSB_CR_EVENT_HOST_ENABLE);\r\nPSB_RSGX32(PSB_CR_EVENT_HOST_ENABLE);\r\nPSB_WVDC32(dev_priv->vdc_irq_mask, PSB_INT_ENABLE_R);\r\nPSB_WVDC32(0xFFFFFFFF, PSB_HWSTAM);\r\nif (dev->vblank[0].enabled)\r\npsb_enable_pipestat(dev_priv, 0, PIPE_VBLANK_INTERRUPT_ENABLE);\r\nelse\r\npsb_disable_pipestat(dev_priv, 0, PIPE_VBLANK_INTERRUPT_ENABLE);\r\nif (dev->vblank[1].enabled)\r\npsb_enable_pipestat(dev_priv, 1, PIPE_VBLANK_INTERRUPT_ENABLE);\r\nelse\r\npsb_disable_pipestat(dev_priv, 1, PIPE_VBLANK_INTERRUPT_ENABLE);\r\nif (dev->vblank[2].enabled)\r\npsb_enable_pipestat(dev_priv, 2, PIPE_VBLANK_INTERRUPT_ENABLE);\r\nelse\r\npsb_disable_pipestat(dev_priv, 2, PIPE_VBLANK_INTERRUPT_ENABLE);\r\nif (dev_priv->ops->hotplug_enable)\r\ndev_priv->ops->hotplug_enable(dev, true);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\nreturn 0;\r\n}\r\nvoid psb_irq_uninstall(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nif (dev_priv->ops->hotplug_enable)\r\ndev_priv->ops->hotplug_enable(dev, false);\r\nPSB_WVDC32(0xFFFFFFFF, PSB_HWSTAM);\r\nif (dev->vblank[0].enabled)\r\npsb_disable_pipestat(dev_priv, 0, PIPE_VBLANK_INTERRUPT_ENABLE);\r\nif (dev->vblank[1].enabled)\r\npsb_disable_pipestat(dev_priv, 1, PIPE_VBLANK_INTERRUPT_ENABLE);\r\nif (dev->vblank[2].enabled)\r\npsb_disable_pipestat(dev_priv, 2, PIPE_VBLANK_INTERRUPT_ENABLE);\r\ndev_priv->vdc_irq_mask &= _PSB_IRQ_SGX_FLAG |\r\n_PSB_IRQ_MSVDX_FLAG |\r\n_LNC_IRQ_TOPAZ_FLAG;\r\nPSB_WVDC32(~dev_priv->vdc_irq_mask, PSB_INT_MASK_R);\r\nPSB_WVDC32(dev_priv->vdc_irq_mask, PSB_INT_ENABLE_R);\r\nwmb();\r\nPSB_WVDC32(PSB_RVDC32(PSB_INT_IDENTITY_R), PSB_INT_IDENTITY_R);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\n}\r\nvoid psb_irq_turn_on_dpst(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *) dev->dev_private;\r\nu32 hist_reg;\r\nu32 pwm_reg;\r\nif (gma_power_begin(dev, false)) {\r\nPSB_WVDC32(1 << 31, HISTOGRAM_LOGIC_CONTROL);\r\nhist_reg = PSB_RVDC32(HISTOGRAM_LOGIC_CONTROL);\r\nPSB_WVDC32(1 << 31, HISTOGRAM_INT_CONTROL);\r\nhist_reg = PSB_RVDC32(HISTOGRAM_INT_CONTROL);\r\nPSB_WVDC32(0x80010100, PWM_CONTROL_LOGIC);\r\npwm_reg = PSB_RVDC32(PWM_CONTROL_LOGIC);\r\nPSB_WVDC32(pwm_reg | PWM_PHASEIN_ENABLE\r\n| PWM_PHASEIN_INT_ENABLE,\r\nPWM_CONTROL_LOGIC);\r\npwm_reg = PSB_RVDC32(PWM_CONTROL_LOGIC);\r\npsb_enable_pipestat(dev_priv, 0, PIPE_DPST_EVENT_ENABLE);\r\nhist_reg = PSB_RVDC32(HISTOGRAM_INT_CONTROL);\r\nPSB_WVDC32(hist_reg | HISTOGRAM_INT_CTRL_CLEAR,\r\nHISTOGRAM_INT_CONTROL);\r\npwm_reg = PSB_RVDC32(PWM_CONTROL_LOGIC);\r\nPSB_WVDC32(pwm_reg | 0x80010100 | PWM_PHASEIN_ENABLE,\r\nPWM_CONTROL_LOGIC);\r\ngma_power_end(dev);\r\n}\r\n}\r\nint psb_irq_enable_dpst(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *) dev->dev_private;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nmid_enable_pipe_event(dev_priv, 0);\r\npsb_irq_turn_on_dpst(dev);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\nreturn 0;\r\n}\r\nvoid psb_irq_turn_off_dpst(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *) dev->dev_private;\r\nu32 hist_reg;\r\nu32 pwm_reg;\r\nif (gma_power_begin(dev, false)) {\r\nPSB_WVDC32(0x00000000, HISTOGRAM_INT_CONTROL);\r\nhist_reg = PSB_RVDC32(HISTOGRAM_INT_CONTROL);\r\npsb_disable_pipestat(dev_priv, 0, PIPE_DPST_EVENT_ENABLE);\r\npwm_reg = PSB_RVDC32(PWM_CONTROL_LOGIC);\r\nPSB_WVDC32(pwm_reg & ~PWM_PHASEIN_INT_ENABLE,\r\nPWM_CONTROL_LOGIC);\r\npwm_reg = PSB_RVDC32(PWM_CONTROL_LOGIC);\r\ngma_power_end(dev);\r\n}\r\n}\r\nint psb_irq_disable_dpst(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *) dev->dev_private;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nmid_disable_pipe_event(dev_priv, 0);\r\npsb_irq_turn_off_dpst(dev);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\nreturn 0;\r\n}\r\nint psb_enable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nunsigned long irqflags;\r\nuint32_t reg_val = 0;\r\nuint32_t pipeconf_reg = mid_pipeconf(pipe);\r\nif (IS_MFLD(dev))\r\nreturn mdfld_enable_te(dev, pipe);\r\nif (gma_power_begin(dev, false)) {\r\nreg_val = REG_READ(pipeconf_reg);\r\ngma_power_end(dev);\r\n}\r\nif (!(reg_val & PIPEACONF_ENABLE))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nif (pipe == 0)\r\ndev_priv->vdc_irq_mask |= _PSB_VSYNC_PIPEA_FLAG;\r\nelse if (pipe == 1)\r\ndev_priv->vdc_irq_mask |= _PSB_VSYNC_PIPEB_FLAG;\r\nPSB_WVDC32(~dev_priv->vdc_irq_mask, PSB_INT_MASK_R);\r\nPSB_WVDC32(dev_priv->vdc_irq_mask, PSB_INT_ENABLE_R);\r\npsb_enable_pipestat(dev_priv, pipe, PIPE_VBLANK_INTERRUPT_ENABLE);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\nreturn 0;\r\n}\r\nvoid psb_disable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nunsigned long irqflags;\r\nif (IS_MFLD(dev))\r\nmdfld_disable_te(dev, pipe);\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nif (pipe == 0)\r\ndev_priv->vdc_irq_mask &= ~_PSB_VSYNC_PIPEA_FLAG;\r\nelse if (pipe == 1)\r\ndev_priv->vdc_irq_mask &= ~_PSB_VSYNC_PIPEB_FLAG;\r\nPSB_WVDC32(~dev_priv->vdc_irq_mask, PSB_INT_MASK_R);\r\nPSB_WVDC32(dev_priv->vdc_irq_mask, PSB_INT_ENABLE_R);\r\npsb_disable_pipestat(dev_priv, pipe, PIPE_VBLANK_INTERRUPT_ENABLE);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\n}\r\nint mdfld_enable_te(struct drm_device *dev, int pipe)\r\n{\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *) dev->dev_private;\r\nunsigned long irqflags;\r\nuint32_t reg_val = 0;\r\nuint32_t pipeconf_reg = mid_pipeconf(pipe);\r\nif (gma_power_begin(dev, false)) {\r\nreg_val = REG_READ(pipeconf_reg);\r\ngma_power_end(dev);\r\n}\r\nif (!(reg_val & PIPEACONF_ENABLE))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nmid_enable_pipe_event(dev_priv, pipe);\r\npsb_enable_pipestat(dev_priv, pipe, PIPE_TE_ENABLE);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\nreturn 0;\r\n}\r\nvoid mdfld_disable_te(struct drm_device *dev, int pipe)\r\n{\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *) dev->dev_private;\r\nunsigned long irqflags;\r\nif (!dev_priv->dsr_enable)\r\nreturn;\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nmid_disable_pipe_event(dev_priv, pipe);\r\npsb_disable_pipestat(dev_priv, pipe, PIPE_TE_ENABLE);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\n}\r\nu32 psb_get_vblank_counter(struct drm_device *dev, unsigned int pipe)\r\n{\r\nuint32_t high_frame = PIPEAFRAMEHIGH;\r\nuint32_t low_frame = PIPEAFRAMEPIXEL;\r\nuint32_t pipeconf_reg = PIPEACONF;\r\nuint32_t reg_val = 0;\r\nuint32_t high1 = 0, high2 = 0, low = 0, count = 0;\r\nswitch (pipe) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nhigh_frame = PIPEBFRAMEHIGH;\r\nlow_frame = PIPEBFRAMEPIXEL;\r\npipeconf_reg = PIPEBCONF;\r\nbreak;\r\ncase 2:\r\nhigh_frame = PIPECFRAMEHIGH;\r\nlow_frame = PIPECFRAMEPIXEL;\r\npipeconf_reg = PIPECCONF;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "%s, invalid pipe.\n", __func__);\r\nreturn 0;\r\n}\r\nif (!gma_power_begin(dev, false))\r\nreturn 0;\r\nreg_val = REG_READ(pipeconf_reg);\r\nif (!(reg_val & PIPEACONF_ENABLE)) {\r\ndev_err(dev->dev, "trying to get vblank count for disabled pipe %u\n",\r\npipe);\r\ngoto psb_get_vblank_counter_exit;\r\n}\r\ndo {\r\nhigh1 = ((REG_READ(high_frame) & PIPE_FRAME_HIGH_MASK) >>\r\nPIPE_FRAME_HIGH_SHIFT);\r\nlow = ((REG_READ(low_frame) & PIPE_FRAME_LOW_MASK) >>\r\nPIPE_FRAME_LOW_SHIFT);\r\nhigh2 = ((REG_READ(high_frame) & PIPE_FRAME_HIGH_MASK) >>\r\nPIPE_FRAME_HIGH_SHIFT);\r\n} while (high1 != high2);\r\ncount = (high1 << 8) | low;\r\npsb_get_vblank_counter_exit:\r\ngma_power_end(dev);\r\nreturn count;\r\n}
