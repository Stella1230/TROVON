static void queue_event(struct ordered_events *oe, struct ordered_event *new)\r\n{\r\nstruct ordered_event *last = oe->last;\r\nu64 timestamp = new->timestamp;\r\nstruct list_head *p;\r\n++oe->nr_events;\r\noe->last = new;\r\npr_oe_time2(timestamp, "queue_event nr_events %u\n", oe->nr_events);\r\nif (!last) {\r\nlist_add(&new->list, &oe->events);\r\noe->max_timestamp = timestamp;\r\nreturn;\r\n}\r\nif (last->timestamp <= timestamp) {\r\nwhile (last->timestamp <= timestamp) {\r\np = last->list.next;\r\nif (p == &oe->events) {\r\nlist_add_tail(&new->list, &oe->events);\r\noe->max_timestamp = timestamp;\r\nreturn;\r\n}\r\nlast = list_entry(p, struct ordered_event, list);\r\n}\r\nlist_add_tail(&new->list, &last->list);\r\n} else {\r\nwhile (last->timestamp > timestamp) {\r\np = last->list.prev;\r\nif (p == &oe->events) {\r\nlist_add(&new->list, &oe->events);\r\nreturn;\r\n}\r\nlast = list_entry(p, struct ordered_event, list);\r\n}\r\nlist_add(&new->list, &last->list);\r\n}\r\n}\r\nstatic union perf_event *__dup_event(struct ordered_events *oe,\r\nunion perf_event *event)\r\n{\r\nunion perf_event *new_event = NULL;\r\nif (oe->cur_alloc_size < oe->max_alloc_size) {\r\nnew_event = memdup(event, event->header.size);\r\nif (new_event)\r\noe->cur_alloc_size += event->header.size;\r\n}\r\nreturn new_event;\r\n}\r\nstatic union perf_event *dup_event(struct ordered_events *oe,\r\nunion perf_event *event)\r\n{\r\nreturn oe->copy_on_queue ? __dup_event(oe, event) : event;\r\n}\r\nstatic void free_dup_event(struct ordered_events *oe, union perf_event *event)\r\n{\r\nif (oe->copy_on_queue) {\r\noe->cur_alloc_size -= event->header.size;\r\nfree(event);\r\n}\r\n}\r\nstatic struct ordered_event *alloc_event(struct ordered_events *oe,\r\nunion perf_event *event)\r\n{\r\nstruct list_head *cache = &oe->cache;\r\nstruct ordered_event *new = NULL;\r\nunion perf_event *new_event;\r\nnew_event = dup_event(oe, event);\r\nif (!new_event)\r\nreturn NULL;\r\nif (!list_empty(cache)) {\r\nnew = list_entry(cache->next, struct ordered_event, list);\r\nlist_del(&new->list);\r\n} else if (oe->buffer) {\r\nnew = oe->buffer + oe->buffer_idx;\r\nif (++oe->buffer_idx == MAX_SAMPLE_BUFFER)\r\noe->buffer = NULL;\r\n} else if (oe->cur_alloc_size < oe->max_alloc_size) {\r\nsize_t size = MAX_SAMPLE_BUFFER * sizeof(*new);\r\noe->buffer = malloc(size);\r\nif (!oe->buffer) {\r\nfree_dup_event(oe, new_event);\r\nreturn NULL;\r\n}\r\npr("alloc size %" PRIu64 "B (+%zu), max %" PRIu64 "B\n",\r\noe->cur_alloc_size, size, oe->max_alloc_size);\r\noe->cur_alloc_size += size;\r\nlist_add(&oe->buffer->list, &oe->to_free);\r\noe->buffer_idx = 2;\r\nnew = oe->buffer + 1;\r\n} else {\r\npr("allocation limit reached %" PRIu64 "B\n", oe->max_alloc_size);\r\n}\r\nnew->event = new_event;\r\nreturn new;\r\n}\r\nstatic struct ordered_event *\r\nordered_events__new_event(struct ordered_events *oe, u64 timestamp,\r\nunion perf_event *event)\r\n{\r\nstruct ordered_event *new;\r\nnew = alloc_event(oe, event);\r\nif (new) {\r\nnew->timestamp = timestamp;\r\nqueue_event(oe, new);\r\n}\r\nreturn new;\r\n}\r\nvoid ordered_events__delete(struct ordered_events *oe, struct ordered_event *event)\r\n{\r\nlist_move(&event->list, &oe->cache);\r\noe->nr_events--;\r\nfree_dup_event(oe, event->event);\r\n}\r\nint ordered_events__queue(struct ordered_events *oe, union perf_event *event,\r\nstruct perf_sample *sample, u64 file_offset)\r\n{\r\nu64 timestamp = sample->time;\r\nstruct ordered_event *oevent;\r\nif (!timestamp || timestamp == ~0ULL)\r\nreturn -ETIME;\r\nif (timestamp < oe->last_flush) {\r\npr_oe_time(timestamp, "out of order event\n");\r\npr_oe_time(oe->last_flush, "last flush, last_flush_type %d\n",\r\noe->last_flush_type);\r\noe->nr_unordered_events++;\r\n}\r\noevent = ordered_events__new_event(oe, timestamp, event);\r\nif (!oevent) {\r\nordered_events__flush(oe, OE_FLUSH__HALF);\r\noevent = ordered_events__new_event(oe, timestamp, event);\r\n}\r\nif (!oevent)\r\nreturn -ENOMEM;\r\noevent->file_offset = file_offset;\r\nreturn 0;\r\n}\r\nstatic int __ordered_events__flush(struct ordered_events *oe)\r\n{\r\nstruct list_head *head = &oe->events;\r\nstruct ordered_event *tmp, *iter;\r\nu64 limit = oe->next_flush;\r\nu64 last_ts = oe->last ? oe->last->timestamp : 0ULL;\r\nbool show_progress = limit == ULLONG_MAX;\r\nstruct ui_progress prog;\r\nint ret;\r\nif (!limit)\r\nreturn 0;\r\nif (show_progress)\r\nui_progress__init(&prog, oe->nr_events, "Processing time ordered events...");\r\nlist_for_each_entry_safe(iter, tmp, head, list) {\r\nif (session_done())\r\nreturn 0;\r\nif (iter->timestamp > limit)\r\nbreak;\r\nret = oe->deliver(oe, iter);\r\nif (ret)\r\nreturn ret;\r\nordered_events__delete(oe, iter);\r\noe->last_flush = iter->timestamp;\r\nif (show_progress)\r\nui_progress__update(&prog, 1);\r\n}\r\nif (list_empty(head))\r\noe->last = NULL;\r\nelse if (last_ts <= limit)\r\noe->last = list_entry(head->prev, struct ordered_event, list);\r\nif (show_progress)\r\nui_progress__finish();\r\nreturn 0;\r\n}\r\nint ordered_events__flush(struct ordered_events *oe, enum oe_flush how)\r\n{\r\nstatic const char * const str[] = {\r\n"NONE",\r\n"FINAL",\r\n"ROUND",\r\n"HALF ",\r\n};\r\nint err;\r\nif (oe->nr_events == 0)\r\nreturn 0;\r\nswitch (how) {\r\ncase OE_FLUSH__FINAL:\r\noe->next_flush = ULLONG_MAX;\r\nbreak;\r\ncase OE_FLUSH__HALF:\r\n{\r\nstruct ordered_event *first, *last;\r\nstruct list_head *head = &oe->events;\r\nfirst = list_entry(head->next, struct ordered_event, list);\r\nlast = oe->last;\r\nif (WARN_ONCE(!last || list_empty(head), "empty queue"))\r\nreturn 0;\r\noe->next_flush = first->timestamp;\r\noe->next_flush += (last->timestamp - first->timestamp) / 2;\r\nbreak;\r\n}\r\ncase OE_FLUSH__ROUND:\r\ncase OE_FLUSH__NONE:\r\ndefault:\r\nbreak;\r\n};\r\npr_oe_time(oe->next_flush, "next_flush - ordered_events__flush PRE %s, nr_events %u\n",\r\nstr[how], oe->nr_events);\r\npr_oe_time(oe->max_timestamp, "max_timestamp\n");\r\nerr = __ordered_events__flush(oe);\r\nif (!err) {\r\nif (how == OE_FLUSH__ROUND)\r\noe->next_flush = oe->max_timestamp;\r\noe->last_flush_type = how;\r\n}\r\npr_oe_time(oe->next_flush, "next_flush - ordered_events__flush POST %s, nr_events %u\n",\r\nstr[how], oe->nr_events);\r\npr_oe_time(oe->last_flush, "last_flush\n");\r\nreturn err;\r\n}\r\nvoid ordered_events__init(struct ordered_events *oe, ordered_events__deliver_t deliver)\r\n{\r\nINIT_LIST_HEAD(&oe->events);\r\nINIT_LIST_HEAD(&oe->cache);\r\nINIT_LIST_HEAD(&oe->to_free);\r\noe->max_alloc_size = (u64) -1;\r\noe->cur_alloc_size = 0;\r\noe->deliver = deliver;\r\n}\r\nvoid ordered_events__free(struct ordered_events *oe)\r\n{\r\nwhile (!list_empty(&oe->to_free)) {\r\nstruct ordered_event *event;\r\nevent = list_entry(oe->to_free.next, struct ordered_event, list);\r\nlist_del(&event->list);\r\nfree_dup_event(oe, event->event);\r\nfree(event);\r\n}\r\n}\r\nvoid ordered_events__reinit(struct ordered_events *oe)\r\n{\r\nordered_events__deliver_t old_deliver = oe->deliver;\r\nordered_events__free(oe);\r\nmemset(oe, '\0', sizeof(*oe));\r\nordered_events__init(oe, old_deliver);\r\n}
