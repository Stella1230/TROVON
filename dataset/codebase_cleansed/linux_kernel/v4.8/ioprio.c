int set_task_ioprio(struct task_struct *task, int ioprio)\r\n{\r\nint err;\r\nstruct io_context *ioc;\r\nconst struct cred *cred = current_cred(), *tcred;\r\nrcu_read_lock();\r\ntcred = __task_cred(task);\r\nif (!uid_eq(tcred->uid, cred->euid) &&\r\n!uid_eq(tcred->uid, cred->uid) && !capable(CAP_SYS_NICE)) {\r\nrcu_read_unlock();\r\nreturn -EPERM;\r\n}\r\nrcu_read_unlock();\r\nerr = security_task_setioprio(task, ioprio);\r\nif (err)\r\nreturn err;\r\nioc = get_task_io_context(task, GFP_ATOMIC, NUMA_NO_NODE);\r\nif (ioc) {\r\nioc->ioprio = ioprio;\r\nput_io_context(ioc);\r\n}\r\nreturn err;\r\n}\r\nstatic int get_task_ioprio(struct task_struct *p)\r\n{\r\nint ret;\r\nret = security_task_getioprio(p);\r\nif (ret)\r\ngoto out;\r\nret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\r\ntask_lock(p);\r\nif (p->io_context)\r\nret = p->io_context->ioprio;\r\ntask_unlock(p);\r\nout:\r\nreturn ret;\r\n}\r\nint ioprio_best(unsigned short aprio, unsigned short bprio)\r\n{\r\nunsigned short aclass;\r\nunsigned short bclass;\r\nif (!ioprio_valid(aprio))\r\naprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, IOPRIO_NORM);\r\nif (!ioprio_valid(bprio))\r\nbprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, IOPRIO_NORM);\r\naclass = IOPRIO_PRIO_CLASS(aprio);\r\nbclass = IOPRIO_PRIO_CLASS(bprio);\r\nif (aclass == bclass)\r\nreturn min(aprio, bprio);\r\nif (aclass > bclass)\r\nreturn bprio;\r\nelse\r\nreturn aprio;\r\n}
