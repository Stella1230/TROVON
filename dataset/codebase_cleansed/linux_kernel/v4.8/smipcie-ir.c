static void smi_ir_enableInterrupt(struct smi_rc *ir)\r\n{\r\nstruct smi_dev *dev = ir->dev;\r\nsmi_write(MSI_INT_ENA_SET, IR_X_INT);\r\n}\r\nstatic void smi_ir_disableInterrupt(struct smi_rc *ir)\r\n{\r\nstruct smi_dev *dev = ir->dev;\r\nsmi_write(MSI_INT_ENA_CLR, IR_X_INT);\r\n}\r\nstatic void smi_ir_clearInterrupt(struct smi_rc *ir)\r\n{\r\nstruct smi_dev *dev = ir->dev;\r\nsmi_write(MSI_INT_STATUS_CLR, IR_X_INT);\r\n}\r\nstatic void smi_ir_stop(struct smi_rc *ir)\r\n{\r\nstruct smi_dev *dev = ir->dev;\r\nsmi_ir_disableInterrupt(ir);\r\nsmi_clear(IR_Init_Reg, 0x80);\r\n}\r\nstatic u32 smi_decode_rc5(u8 *pData, u8 size)\r\n{\r\nu8 index, current_bit, bit_count;\r\nu8 group_array[BITS_PER_COMMAND * GROUPS_PER_BIT + 4];\r\nu8 group_index = 0;\r\nu32 command = 0xFFFFFFFF;\r\ngroup_array[group_index++] = 1;\r\nfor (index = 0; index < size; index++) {\r\ncurrent_bit = (pData[index] & 0x80) ? 1 : 0;\r\nbit_count = pData[index] & 0x7f;\r\nif ((current_bit == 1) && (bit_count >= 2*IR_RC5_MAX_BIT + 1)) {\r\ngoto process_code;\r\n} else if ((bit_count >= IR_RC5_MIN_BIT) &&\r\n(bit_count <= IR_RC5_MAX_BIT)) {\r\ngroup_array[group_index++] = current_bit;\r\n} else if ((bit_count > IR_RC5_MAX_BIT) &&\r\n(bit_count <= 2*IR_RC5_MAX_BIT)) {\r\ngroup_array[group_index++] = current_bit;\r\ngroup_array[group_index++] = current_bit;\r\n} else {\r\ngoto invalid_timing;\r\n}\r\nif (group_index >= BITS_PER_COMMAND*GROUPS_PER_BIT)\r\ngoto process_code;\r\nif ((group_index == BITS_PER_COMMAND*GROUPS_PER_BIT - 1)\r\n&& (group_array[group_index-1] == 0)) {\r\ngroup_array[group_index++] = 1;\r\ngoto process_code;\r\n}\r\n}\r\nprocess_code:\r\nif (group_index == (BITS_PER_COMMAND*GROUPS_PER_BIT-1))\r\ngroup_array[group_index++] = 1;\r\nif (group_index == BITS_PER_COMMAND*GROUPS_PER_BIT) {\r\ncommand = 0;\r\nfor (index = 0; index < (BITS_PER_COMMAND*GROUPS_PER_BIT);\r\nindex = index + 2) {\r\nif ((group_array[index] == 1) &&\r\n(group_array[index+1] == 0)) {\r\ncommand |= (1 << (BITS_PER_COMMAND -\r\n(index/2) - 1));\r\n} else if ((group_array[index] == 0) &&\r\n(group_array[index+1] == 1)) {\r\n} else {\r\ncommand = 0xFFFFFFFF;\r\ngoto invalid_timing;\r\n}\r\n}\r\n}\r\ninvalid_timing:\r\nreturn command;\r\n}\r\nstatic void smi_ir_decode(struct work_struct *work)\r\n{\r\nstruct smi_rc *ir = container_of(work, struct smi_rc, work);\r\nstruct smi_dev *dev = ir->dev;\r\nstruct rc_dev *rc_dev = ir->rc_dev;\r\nu32 dwIRControl, dwIRData, dwIRCode, scancode;\r\nu8 index, ucIRCount, readLoop, rc5_command, rc5_system, toggle;\r\ndwIRControl = smi_read(IR_Init_Reg);\r\nif (dwIRControl & rbIRVld) {\r\nucIRCount = (u8) smi_read(IR_Data_Cnt);\r\nif (ucIRCount < 4)\r\ngoto end_ir_decode;\r\nreadLoop = ucIRCount/4;\r\nif (ucIRCount % 4)\r\nreadLoop += 1;\r\nfor (index = 0; index < readLoop; index++) {\r\ndwIRData = smi_read(IR_DATA_BUFFER_BASE + (index*4));\r\nir->irData[index*4 + 0] = (u8)(dwIRData);\r\nir->irData[index*4 + 1] = (u8)(dwIRData >> 8);\r\nir->irData[index*4 + 2] = (u8)(dwIRData >> 16);\r\nir->irData[index*4 + 3] = (u8)(dwIRData >> 24);\r\n}\r\ndwIRCode = smi_decode_rc5(ir->irData, ucIRCount);\r\nif (dwIRCode != 0xFFFFFFFF) {\r\nrc5_command = dwIRCode & 0x3F;\r\nrc5_system = (dwIRCode & 0x7C0) >> 6;\r\ntoggle = (dwIRCode & 0x800) ? 1 : 0;\r\nscancode = rc5_system << 8 | rc5_command;\r\nrc_keydown(rc_dev, RC_TYPE_RC5, scancode, toggle);\r\n}\r\n}\r\nend_ir_decode:\r\nsmi_set(IR_Init_Reg, 0x04);\r\nsmi_ir_enableInterrupt(ir);\r\n}\r\nint smi_ir_irq(struct smi_rc *ir, u32 int_status)\r\n{\r\nint handled = 0;\r\nif (int_status & IR_X_INT) {\r\nsmi_ir_disableInterrupt(ir);\r\nsmi_ir_clearInterrupt(ir);\r\nschedule_work(&ir->work);\r\nhandled = 1;\r\n}\r\nreturn handled;\r\n}\r\nvoid smi_ir_start(struct smi_rc *ir)\r\n{\r\nstruct smi_dev *dev = ir->dev;\r\nsmi_write(IR_Idle_Cnt_Low, 0x00140070);\r\nmsleep(20);\r\nsmi_set(IR_Init_Reg, 0x90);\r\nsmi_ir_enableInterrupt(ir);\r\n}\r\nint smi_ir_init(struct smi_dev *dev)\r\n{\r\nint ret;\r\nstruct rc_dev *rc_dev;\r\nstruct smi_rc *ir = &dev->ir;\r\nrc_dev = rc_allocate_device();\r\nif (!rc_dev)\r\nreturn -ENOMEM;\r\nsnprintf(ir->input_name, sizeof(ir->input_name), "IR (%s)",\r\ndev->info->name);\r\nsnprintf(ir->input_phys, sizeof(ir->input_phys), "pci-%s/ir0",\r\npci_name(dev->pci_dev));\r\nrc_dev->driver_name = "SMI_PCIe";\r\nrc_dev->input_phys = ir->input_phys;\r\nrc_dev->input_name = ir->input_name;\r\nrc_dev->input_id.bustype = BUS_PCI;\r\nrc_dev->input_id.version = 1;\r\nrc_dev->input_id.vendor = dev->pci_dev->subsystem_vendor;\r\nrc_dev->input_id.product = dev->pci_dev->subsystem_device;\r\nrc_dev->dev.parent = &dev->pci_dev->dev;\r\nrc_dev->driver_type = RC_DRIVER_SCANCODE;\r\nrc_dev->map_name = dev->info->rc_map;\r\nir->rc_dev = rc_dev;\r\nir->dev = dev;\r\nINIT_WORK(&ir->work, smi_ir_decode);\r\nsmi_ir_disableInterrupt(ir);\r\nret = rc_register_device(rc_dev);\r\nif (ret)\r\ngoto ir_err;\r\nreturn 0;\r\nir_err:\r\nrc_free_device(rc_dev);\r\nreturn ret;\r\n}\r\nvoid smi_ir_exit(struct smi_dev *dev)\r\n{\r\nstruct smi_rc *ir = &dev->ir;\r\nstruct rc_dev *rc_dev = ir->rc_dev;\r\nsmi_ir_stop(ir);\r\nrc_unregister_device(rc_dev);\r\nir->rc_dev = NULL;\r\n}
