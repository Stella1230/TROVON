static int bcm87xx_of_reg_init(struct phy_device *phydev)\r\n{\r\nconst __be32 *paddr;\r\nconst __be32 *paddr_end;\r\nint len, ret;\r\nif (!phydev->mdio.dev.of_node)\r\nreturn 0;\r\npaddr = of_get_property(phydev->mdio.dev.of_node,\r\n"broadcom,c45-reg-init", &len);\r\nif (!paddr)\r\nreturn 0;\r\npaddr_end = paddr + (len /= sizeof(*paddr));\r\nret = 0;\r\nwhile (paddr + 3 < paddr_end) {\r\nu16 devid = be32_to_cpup(paddr++);\r\nu16 reg = be32_to_cpup(paddr++);\r\nu16 mask = be32_to_cpup(paddr++);\r\nu16 val_bits = be32_to_cpup(paddr++);\r\nint val;\r\nu32 regnum = MII_ADDR_C45 | (devid << 16) | reg;\r\nval = 0;\r\nif (mask) {\r\nval = phy_read(phydev, regnum);\r\nif (val < 0) {\r\nret = val;\r\ngoto err;\r\n}\r\nval &= mask;\r\n}\r\nval |= val_bits;\r\nret = phy_write(phydev, regnum, val);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int bcm87xx_of_reg_init(struct phy_device *phydev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bcm87xx_config_init(struct phy_device *phydev)\r\n{\r\nphydev->supported = SUPPORTED_10000baseR_FEC;\r\nphydev->advertising = ADVERTISED_10000baseR_FEC;\r\nphydev->state = PHY_NOLINK;\r\nphydev->autoneg = AUTONEG_DISABLE;\r\nbcm87xx_of_reg_init(phydev);\r\nreturn 0;\r\n}\r\nstatic int bcm87xx_config_aneg(struct phy_device *phydev)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int bcm87xx_read_status(struct phy_device *phydev)\r\n{\r\nint rx_signal_detect;\r\nint pcs_status;\r\nint xgxs_lane_status;\r\nrx_signal_detect = phy_read(phydev, BCM87XX_PMD_RX_SIGNAL_DETECT);\r\nif (rx_signal_detect < 0)\r\nreturn rx_signal_detect;\r\nif ((rx_signal_detect & 1) == 0)\r\ngoto no_link;\r\npcs_status = phy_read(phydev, BCM87XX_10GBASER_PCS_STATUS);\r\nif (pcs_status < 0)\r\nreturn pcs_status;\r\nif ((pcs_status & 1) == 0)\r\ngoto no_link;\r\nxgxs_lane_status = phy_read(phydev, BCM87XX_XGXS_LANE_STATUS);\r\nif (xgxs_lane_status < 0)\r\nreturn xgxs_lane_status;\r\nif ((xgxs_lane_status & 0x1000) == 0)\r\ngoto no_link;\r\nphydev->speed = 10000;\r\nphydev->link = 1;\r\nphydev->duplex = 1;\r\nreturn 0;\r\nno_link:\r\nphydev->link = 0;\r\nreturn 0;\r\n}\r\nstatic int bcm87xx_config_intr(struct phy_device *phydev)\r\n{\r\nint reg, err;\r\nreg = phy_read(phydev, BCM87XX_LASI_CONTROL);\r\nif (reg < 0)\r\nreturn reg;\r\nif (phydev->interrupts == PHY_INTERRUPT_ENABLED)\r\nreg |= 1;\r\nelse\r\nreg &= ~1;\r\nerr = phy_write(phydev, BCM87XX_LASI_CONTROL, reg);\r\nreturn err;\r\n}\r\nstatic int bcm87xx_did_interrupt(struct phy_device *phydev)\r\n{\r\nint reg;\r\nreg = phy_read(phydev, BCM87XX_LASI_STATUS);\r\nif (reg < 0) {\r\nphydev_err(phydev,\r\n"Error: Read of BCM87XX_LASI_STATUS failed: %d\n",\r\nreg);\r\nreturn 0;\r\n}\r\nreturn (reg & 1) != 0;\r\n}\r\nstatic int bcm87xx_ack_interrupt(struct phy_device *phydev)\r\n{\r\nbcm87xx_did_interrupt(phydev);\r\nreturn 0;\r\n}\r\nstatic int bcm8706_match_phy_device(struct phy_device *phydev)\r\n{\r\nreturn phydev->c45_ids.device_ids[4] == PHY_ID_BCM8706;\r\n}\r\nstatic int bcm8727_match_phy_device(struct phy_device *phydev)\r\n{\r\nreturn phydev->c45_ids.device_ids[4] == PHY_ID_BCM8727;\r\n}
