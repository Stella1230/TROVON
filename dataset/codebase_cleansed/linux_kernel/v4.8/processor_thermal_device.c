static int get_tjmax(void)\r\n{\r\nu32 eax, edx;\r\nu32 val;\r\nint err;\r\nerr = rdmsr_safe(MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);\r\nif (err)\r\nreturn err;\r\nval = (eax >> 16) & 0xff;\r\nif (val)\r\nreturn val;\r\nreturn -EINVAL;\r\n}\r\nstatic int read_temp_msr(int *temp)\r\n{\r\nint cpu;\r\nu32 eax, edx;\r\nint err;\r\nunsigned long curr_temp_off = 0;\r\n*temp = 0;\r\nfor_each_online_cpu(cpu) {\r\nerr = rdmsr_safe_on_cpu(cpu, MSR_IA32_THERM_STATUS, &eax,\r\n&edx);\r\nif (err)\r\ngoto err_ret;\r\nelse {\r\nif (eax & 0x80000000) {\r\ncurr_temp_off = (eax >> 16) & 0x7f;\r\nif (!*temp || curr_temp_off < *temp)\r\n*temp = curr_temp_off;\r\n} else {\r\nerr = -EINVAL;\r\ngoto err_ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nerr_ret:\r\nreturn err;\r\n}\r\nstatic int proc_thermal_get_zone_temp(struct thermal_zone_device *zone,\r\nint *temp)\r\n{\r\nint ret;\r\nret = read_temp_msr(temp);\r\nif (!ret)\r\n*temp = (stored_tjmax - *temp) * 1000;\r\nreturn ret;\r\n}\r\nstatic int proc_thermal_read_ppcc(struct proc_thermal_device *proc_priv)\r\n{\r\nint i;\r\nacpi_status status;\r\nstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *elements, *ppcc;\r\nunion acpi_object *p;\r\nint ret = 0;\r\nstatus = acpi_evaluate_object(proc_priv->adev->handle, "PPCC",\r\nNULL, &buf);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\np = buf.pointer;\r\nif (!p || (p->type != ACPI_TYPE_PACKAGE)) {\r\ndev_err(proc_priv->dev, "Invalid PPCC data\n");\r\nret = -EFAULT;\r\ngoto free_buffer;\r\n}\r\nif (!p->package.count) {\r\ndev_err(proc_priv->dev, "Invalid PPCC package size\n");\r\nret = -EFAULT;\r\ngoto free_buffer;\r\n}\r\nfor (i = 0; i < min((int)p->package.count - 1, 2); ++i) {\r\nelements = &(p->package.elements[i+1]);\r\nif (elements->type != ACPI_TYPE_PACKAGE ||\r\nelements->package.count != 6) {\r\nret = -EFAULT;\r\ngoto free_buffer;\r\n}\r\nppcc = elements->package.elements;\r\nproc_priv->power_limits[i].index = ppcc[0].integer.value;\r\nproc_priv->power_limits[i].min_uw = ppcc[1].integer.value;\r\nproc_priv->power_limits[i].max_uw = ppcc[2].integer.value;\r\nproc_priv->power_limits[i].tmin_us = ppcc[3].integer.value;\r\nproc_priv->power_limits[i].tmax_us = ppcc[4].integer.value;\r\nproc_priv->power_limits[i].step_uw = ppcc[5].integer.value;\r\n}\r\nfree_buffer:\r\nkfree(buf.pointer);\r\nreturn ret;\r\n}\r\nstatic void proc_thermal_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct proc_thermal_device *proc_priv = data;\r\nif (!proc_priv)\r\nreturn;\r\nswitch (event) {\r\ncase PROC_POWER_CAPABILITY_CHANGED:\r\nproc_thermal_read_ppcc(proc_priv);\r\nint340x_thermal_zone_device_update(proc_priv->int340x_zone);\r\nbreak;\r\ndefault:\r\ndev_err(proc_priv->dev, "Unsupported event [0x%x]\n", event);\r\nbreak;\r\n}\r\n}\r\nstatic int proc_thermal_add(struct device *dev,\r\nstruct proc_thermal_device **priv)\r\n{\r\nstruct proc_thermal_device *proc_priv;\r\nstruct acpi_device *adev;\r\nacpi_status status;\r\nunsigned long long tmp;\r\nstruct thermal_zone_device_ops *ops = NULL;\r\nint ret;\r\nadev = ACPI_COMPANION(dev);\r\nif (!adev)\r\nreturn -ENODEV;\r\nproc_priv = devm_kzalloc(dev, sizeof(*proc_priv), GFP_KERNEL);\r\nif (!proc_priv)\r\nreturn -ENOMEM;\r\nproc_priv->dev = dev;\r\nproc_priv->adev = adev;\r\n*priv = proc_priv;\r\nret = proc_thermal_read_ppcc(proc_priv);\r\nif (!ret) {\r\nret = sysfs_create_group(&dev->kobj,\r\n&power_limit_attribute_group);\r\n}\r\nif (ret)\r\nreturn ret;\r\nstatus = acpi_evaluate_integer(adev->handle, "_TMP", NULL, &tmp);\r\nif (ACPI_FAILURE(status)) {\r\nstored_tjmax = get_tjmax();\r\nif (stored_tjmax > 0)\r\nops = &proc_thermal_local_ops;\r\n}\r\nproc_priv->int340x_zone = int340x_thermal_zone_add(adev, ops);\r\nif (IS_ERR(proc_priv->int340x_zone)) {\r\nret = PTR_ERR(proc_priv->int340x_zone);\r\ngoto remove_group;\r\n} else\r\nret = 0;\r\nret = acpi_install_notify_handler(adev->handle, ACPI_DEVICE_NOTIFY,\r\nproc_thermal_notify,\r\n(void *)proc_priv);\r\nif (ret)\r\ngoto remove_zone;\r\nreturn 0;\r\nremove_zone:\r\nint340x_thermal_zone_remove(proc_priv->int340x_zone);\r\nremove_group:\r\nsysfs_remove_group(&proc_priv->dev->kobj,\r\n&power_limit_attribute_group);\r\nreturn ret;\r\n}\r\nstatic void proc_thermal_remove(struct proc_thermal_device *proc_priv)\r\n{\r\nacpi_remove_notify_handler(proc_priv->adev->handle,\r\nACPI_DEVICE_NOTIFY, proc_thermal_notify);\r\nint340x_thermal_zone_remove(proc_priv->int340x_zone);\r\nsysfs_remove_group(&proc_priv->dev->kobj,\r\n&power_limit_attribute_group);\r\n}\r\nstatic int int3401_add(struct platform_device *pdev)\r\n{\r\nstruct proc_thermal_device *proc_priv;\r\nint ret;\r\nif (proc_thermal_emum_mode == PROC_THERMAL_PCI) {\r\ndev_err(&pdev->dev, "error: enumerated as PCI dev\n");\r\nreturn -ENODEV;\r\n}\r\nret = proc_thermal_add(&pdev->dev, &proc_priv);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, proc_priv);\r\nproc_thermal_emum_mode = PROC_THERMAL_PLATFORM_DEV;\r\nreturn 0;\r\n}\r\nstatic int int3401_remove(struct platform_device *pdev)\r\n{\r\nproc_thermal_remove(platform_get_drvdata(pdev));\r\nreturn 0;\r\n}\r\nstatic irqreturn_t proc_thermal_pci_msi_irq(int irq, void *devid)\r\n{\r\nstruct proc_thermal_device *proc_priv;\r\nstruct pci_dev *pdev = devid;\r\nproc_priv = pci_get_drvdata(pdev);\r\nintel_soc_dts_iosf_interrupt_handler(proc_priv->soc_dts);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int proc_thermal_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *unused)\r\n{\r\nstruct proc_thermal_device *proc_priv;\r\nint ret;\r\nif (proc_thermal_emum_mode == PROC_THERMAL_PLATFORM_DEV) {\r\ndev_err(&pdev->dev, "error: enumerated as platform dev\n");\r\nreturn -ENODEV;\r\n}\r\nret = pci_enable_device(pdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "error: could not enable device\n");\r\nreturn ret;\r\n}\r\nret = proc_thermal_add(&pdev->dev, &proc_priv);\r\nif (ret) {\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\npci_set_drvdata(pdev, proc_priv);\r\nproc_thermal_emum_mode = PROC_THERMAL_PCI;\r\nif (pdev->device == PCI_DEVICE_ID_PROC_BSW_THERMAL) {\r\nproc_priv->soc_dts = intel_soc_dts_iosf_init(\r\nINTEL_SOC_DTS_INTERRUPT_MSI, 2, 0);\r\nif (proc_priv->soc_dts && pdev->irq) {\r\nret = pci_enable_msi(pdev);\r\nif (!ret) {\r\nret = request_threaded_irq(pdev->irq, NULL,\r\nproc_thermal_pci_msi_irq,\r\nIRQF_ONESHOT, "proc_thermal",\r\npdev);\r\nif (ret) {\r\nintel_soc_dts_iosf_exit(\r\nproc_priv->soc_dts);\r\npci_disable_msi(pdev);\r\nproc_priv->soc_dts = NULL;\r\n}\r\n}\r\n} else\r\ndev_err(&pdev->dev, "No auxiliary DTSs enabled\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void proc_thermal_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct proc_thermal_device *proc_priv = pci_get_drvdata(pdev);\r\nif (proc_priv->soc_dts) {\r\nintel_soc_dts_iosf_exit(proc_priv->soc_dts);\r\nif (pdev->irq) {\r\nfree_irq(pdev->irq, pdev);\r\npci_disable_msi(pdev);\r\n}\r\n}\r\nproc_thermal_remove(proc_priv);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init proc_thermal_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&int3401_driver);\r\nif (ret)\r\nreturn ret;\r\nret = pci_register_driver(&proc_thermal_pci_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit proc_thermal_exit(void)\r\n{\r\nplatform_driver_unregister(&int3401_driver);\r\npci_unregister_driver(&proc_thermal_pci_driver);\r\n}
