static int sunxi_sram_show(struct seq_file *s, void *data)\r\n{\r\nstruct device_node *sram_node, *section_node;\r\nconst struct sunxi_sram_data *sram_data;\r\nconst struct of_device_id *match;\r\nstruct sunxi_sram_func *func;\r\nconst __be32 *sram_addr_p, *section_addr_p;\r\nu32 val;\r\nseq_puts(s, "Allwinner sunXi SRAM\n");\r\nseq_puts(s, "--------------------\n\n");\r\nfor_each_child_of_node(sram_dev->of_node, sram_node) {\r\nsram_addr_p = of_get_address(sram_node, 0, NULL, NULL);\r\nseq_printf(s, "sram@%08x\n",\r\nbe32_to_cpu(*sram_addr_p));\r\nfor_each_child_of_node(sram_node, section_node) {\r\nmatch = of_match_node(sunxi_sram_dt_ids, section_node);\r\nif (!match)\r\ncontinue;\r\nsram_data = match->data;\r\nsection_addr_p = of_get_address(section_node, 0,\r\nNULL, NULL);\r\nseq_printf(s, "\tsection@%04x\t(%s)\n",\r\nbe32_to_cpu(*section_addr_p),\r\nsram_data->name);\r\nval = readl(base + sram_data->reg);\r\nval >>= sram_data->offset;\r\nval &= GENMASK(sram_data->width - 1, 0);\r\nfor (func = sram_data->func; func->func; func++) {\r\nseq_printf(s, "\t\t%s%c\n", func->func,\r\nfunc->val == val ? '*' : ' ');\r\n}\r\n}\r\nseq_puts(s, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int sunxi_sram_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sunxi_sram_show, inode->i_private);\r\n}\r\nstatic inline struct sunxi_sram_desc *to_sram_desc(const struct sunxi_sram_data *data)\r\n{\r\nreturn container_of(data, struct sunxi_sram_desc, data);\r\n}\r\nstatic const struct sunxi_sram_data *sunxi_sram_of_parse(struct device_node *node,\r\nunsigned int *value)\r\n{\r\nconst struct of_device_id *match;\r\nstruct of_phandle_args args;\r\nint ret;\r\nret = of_parse_phandle_with_fixed_args(node, "allwinner,sram", 1, 0,\r\n&args);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nif (!of_device_is_available(args.np)) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nif (value)\r\n*value = args.args[0];\r\nmatch = of_match_node(sunxi_sram_dt_ids, args.np);\r\nif (!match) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nof_node_put(args.np);\r\nreturn match->data;\r\nerr:\r\nof_node_put(args.np);\r\nreturn ERR_PTR(ret);\r\n}\r\nint sunxi_sram_claim(struct device *dev)\r\n{\r\nconst struct sunxi_sram_data *sram_data;\r\nstruct sunxi_sram_desc *sram_desc;\r\nunsigned int device;\r\nu32 val, mask;\r\nif (IS_ERR(base))\r\nreturn -EPROBE_DEFER;\r\nif (!dev || !dev->of_node)\r\nreturn -EINVAL;\r\nsram_data = sunxi_sram_of_parse(dev->of_node, &device);\r\nif (IS_ERR(sram_data))\r\nreturn PTR_ERR(sram_data);\r\nsram_desc = to_sram_desc(sram_data);\r\nspin_lock(&sram_lock);\r\nif (sram_desc->claimed) {\r\nspin_unlock(&sram_lock);\r\nreturn -EBUSY;\r\n}\r\nmask = GENMASK(sram_data->offset + sram_data->width - 1,\r\nsram_data->offset);\r\nval = readl(base + sram_data->reg);\r\nval &= ~mask;\r\nwritel(val | ((device << sram_data->offset) & mask),\r\nbase + sram_data->reg);\r\nspin_unlock(&sram_lock);\r\nreturn 0;\r\n}\r\nint sunxi_sram_release(struct device *dev)\r\n{\r\nconst struct sunxi_sram_data *sram_data;\r\nstruct sunxi_sram_desc *sram_desc;\r\nif (!dev || !dev->of_node)\r\nreturn -EINVAL;\r\nsram_data = sunxi_sram_of_parse(dev->of_node, NULL);\r\nif (IS_ERR(sram_data))\r\nreturn -EINVAL;\r\nsram_desc = to_sram_desc(sram_data);\r\nspin_lock(&sram_lock);\r\nsram_desc->claimed = false;\r\nspin_unlock(&sram_lock);\r\nreturn 0;\r\n}\r\nstatic int sunxi_sram_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct dentry *d;\r\nsram_dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nof_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);\r\nd = debugfs_create_file("sram", S_IRUGO, NULL, NULL,\r\n&sunxi_sram_fops);\r\nif (!d)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
