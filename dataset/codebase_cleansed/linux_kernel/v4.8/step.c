unsigned long convert_ip_to_linear(struct task_struct *child, struct pt_regs *regs)\r\n{\r\nunsigned long addr, seg;\r\naddr = regs->ip;\r\nseg = regs->cs & 0xffff;\r\nif (v8086_mode(regs)) {\r\naddr = (addr & 0xffff) + (seg << 4);\r\nreturn addr;\r\n}\r\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\r\nif ((seg & SEGMENT_TI_MASK) == SEGMENT_LDT) {\r\nstruct desc_struct *desc;\r\nunsigned long base;\r\nseg >>= 3;\r\nmutex_lock(&child->mm->context.lock);\r\nif (unlikely(!child->mm->context.ldt ||\r\nseg >= child->mm->context.ldt->size))\r\naddr = -1L;\r\nelse {\r\ndesc = &child->mm->context.ldt->entries[seg];\r\nbase = get_desc_base(desc);\r\nif (!desc->d)\r\naddr &= 0xffff;\r\naddr += base;\r\n}\r\nmutex_unlock(&child->mm->context.lock);\r\n}\r\n#endif\r\nreturn addr;\r\n}\r\nstatic int is_setting_trap_flag(struct task_struct *child, struct pt_regs *regs)\r\n{\r\nint i, copied;\r\nunsigned char opcode[15];\r\nunsigned long addr = convert_ip_to_linear(child, regs);\r\ncopied = access_process_vm(child, addr, opcode, sizeof(opcode), 0);\r\nfor (i = 0; i < copied; i++) {\r\nswitch (opcode[i]) {\r\ncase 0x9d: case 0xcf:\r\nreturn 1;\r\ncase 0x66: case 0x67:\r\ncontinue;\r\ncase 0x26: case 0x2e:\r\ncase 0x36: case 0x3e:\r\ncase 0x64: case 0x65:\r\ncase 0xf0: case 0xf2: case 0xf3:\r\ncontinue;\r\n#ifdef CONFIG_X86_64\r\ncase 0x40 ... 0x4f:\r\nif (!user_64bit_mode(regs))\r\nreturn 0;\r\ncontinue;\r\n#endif\r\ncase 0x9c:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int enable_single_step(struct task_struct *child)\r\n{\r\nstruct pt_regs *regs = task_pt_regs(child);\r\nunsigned long oflags;\r\nif (unlikely(test_tsk_thread_flag(child, TIF_SINGLESTEP)))\r\nregs->flags |= X86_EFLAGS_TF;\r\nset_tsk_thread_flag(child, TIF_SINGLESTEP);\r\noflags = regs->flags;\r\nregs->flags |= X86_EFLAGS_TF;\r\nif (is_setting_trap_flag(child, regs)) {\r\nclear_tsk_thread_flag(child, TIF_FORCED_TF);\r\nreturn 0;\r\n}\r\nif (oflags & X86_EFLAGS_TF)\r\nreturn test_tsk_thread_flag(child, TIF_FORCED_TF);\r\nset_tsk_thread_flag(child, TIF_FORCED_TF);\r\nreturn 1;\r\n}\r\nvoid set_task_blockstep(struct task_struct *task, bool on)\r\n{\r\nunsigned long debugctl;\r\nlocal_irq_disable();\r\ndebugctl = get_debugctlmsr();\r\nif (on) {\r\ndebugctl |= DEBUGCTLMSR_BTF;\r\nset_tsk_thread_flag(task, TIF_BLOCKSTEP);\r\n} else {\r\ndebugctl &= ~DEBUGCTLMSR_BTF;\r\nclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\r\n}\r\nif (task == current)\r\nupdate_debugctlmsr(debugctl);\r\nlocal_irq_enable();\r\n}\r\nstatic void enable_step(struct task_struct *child, bool block)\r\n{\r\nif (enable_single_step(child) && block)\r\nset_task_blockstep(child, true);\r\nelse if (test_tsk_thread_flag(child, TIF_BLOCKSTEP))\r\nset_task_blockstep(child, false);\r\n}\r\nvoid user_enable_single_step(struct task_struct *child)\r\n{\r\nenable_step(child, 0);\r\n}\r\nvoid user_enable_block_step(struct task_struct *child)\r\n{\r\nenable_step(child, 1);\r\n}\r\nvoid user_disable_single_step(struct task_struct *child)\r\n{\r\nif (test_tsk_thread_flag(child, TIF_BLOCKSTEP))\r\nset_task_blockstep(child, false);\r\nclear_tsk_thread_flag(child, TIF_SINGLESTEP);\r\nif (test_and_clear_tsk_thread_flag(child, TIF_FORCED_TF))\r\ntask_pt_regs(child)->flags &= ~X86_EFLAGS_TF;\r\n}
