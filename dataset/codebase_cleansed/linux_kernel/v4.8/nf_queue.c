void nf_register_queue_handler(struct net *net, const struct nf_queue_handler *qh)\r\n{\r\nWARN_ON(rcu_access_pointer(net->nf.queue_handler));\r\nrcu_assign_pointer(net->nf.queue_handler, qh);\r\n}\r\nvoid nf_unregister_queue_handler(struct net *net)\r\n{\r\nRCU_INIT_POINTER(net->nf.queue_handler, NULL);\r\n}\r\nvoid nf_queue_entry_release_refs(struct nf_queue_entry *entry)\r\n{\r\nstruct nf_hook_state *state = &entry->state;\r\nif (state->in)\r\ndev_put(state->in);\r\nif (state->out)\r\ndev_put(state->out);\r\nif (state->sk)\r\nsock_put(state->sk);\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (entry->skb->nf_bridge) {\r\nstruct net_device *physdev;\r\nphysdev = nf_bridge_get_physindev(entry->skb);\r\nif (physdev)\r\ndev_put(physdev);\r\nphysdev = nf_bridge_get_physoutdev(entry->skb);\r\nif (physdev)\r\ndev_put(physdev);\r\n}\r\n#endif\r\n}\r\nvoid nf_queue_entry_get_refs(struct nf_queue_entry *entry)\r\n{\r\nstruct nf_hook_state *state = &entry->state;\r\nif (state->in)\r\ndev_hold(state->in);\r\nif (state->out)\r\ndev_hold(state->out);\r\nif (state->sk)\r\nsock_hold(state->sk);\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (entry->skb->nf_bridge) {\r\nstruct net_device *physdev;\r\nphysdev = nf_bridge_get_physindev(entry->skb);\r\nif (physdev)\r\ndev_hold(physdev);\r\nphysdev = nf_bridge_get_physoutdev(entry->skb);\r\nif (physdev)\r\ndev_hold(physdev);\r\n}\r\n#endif\r\n}\r\nvoid nf_queue_nf_hook_drop(struct net *net, struct nf_hook_ops *ops)\r\n{\r\nconst struct nf_queue_handler *qh;\r\nrcu_read_lock();\r\nqh = rcu_dereference(net->nf.queue_handler);\r\nif (qh)\r\nqh->nf_hook_drop(net, ops);\r\nrcu_read_unlock();\r\n}\r\nint nf_queue(struct sk_buff *skb,\r\nstruct nf_hook_ops *elem,\r\nstruct nf_hook_state *state,\r\nunsigned int queuenum)\r\n{\r\nint status = -ENOENT;\r\nstruct nf_queue_entry *entry = NULL;\r\nconst struct nf_afinfo *afinfo;\r\nconst struct nf_queue_handler *qh;\r\nstruct net *net = state->net;\r\nqh = rcu_dereference(net->nf.queue_handler);\r\nif (!qh) {\r\nstatus = -ESRCH;\r\ngoto err;\r\n}\r\nafinfo = nf_get_afinfo(state->pf);\r\nif (!afinfo)\r\ngoto err;\r\nentry = kmalloc(sizeof(*entry) + afinfo->route_key_size, GFP_ATOMIC);\r\nif (!entry) {\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\n*entry = (struct nf_queue_entry) {\r\n.skb = skb,\r\n.elem = elem,\r\n.state = *state,\r\n.size = sizeof(*entry) + afinfo->route_key_size,\r\n};\r\nnf_queue_entry_get_refs(entry);\r\nskb_dst_force(skb);\r\nafinfo->saveroute(skb, entry);\r\nstatus = qh->outfn(entry, queuenum);\r\nif (status < 0) {\r\nnf_queue_entry_release_refs(entry);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nkfree(entry);\r\nreturn status;\r\n}\r\nvoid nf_reinject(struct nf_queue_entry *entry, unsigned int verdict)\r\n{\r\nstruct sk_buff *skb = entry->skb;\r\nstruct nf_hook_ops *elem = entry->elem;\r\nconst struct nf_afinfo *afinfo;\r\nint err;\r\nnf_queue_entry_release_refs(entry);\r\nif (verdict == NF_REPEAT)\r\nverdict = elem->hook(elem->priv, skb, &entry->state);\r\nif (verdict == NF_ACCEPT) {\r\nafinfo = nf_get_afinfo(entry->state.pf);\r\nif (!afinfo || afinfo->reroute(entry->state.net, skb, entry) < 0)\r\nverdict = NF_DROP;\r\n}\r\nentry->state.thresh = INT_MIN;\r\nif (verdict == NF_ACCEPT) {\r\nnext_hook:\r\nverdict = nf_iterate(entry->state.hook_list,\r\nskb, &entry->state, &elem);\r\n}\r\nswitch (verdict & NF_VERDICT_MASK) {\r\ncase NF_ACCEPT:\r\ncase NF_STOP:\r\nlocal_bh_disable();\r\nentry->state.okfn(entry->state.net, entry->state.sk, skb);\r\nlocal_bh_enable();\r\nbreak;\r\ncase NF_QUEUE:\r\nerr = nf_queue(skb, elem, &entry->state,\r\nverdict >> NF_VERDICT_QBITS);\r\nif (err < 0) {\r\nif (err == -ESRCH &&\r\n(verdict & NF_VERDICT_FLAG_QUEUE_BYPASS))\r\ngoto next_hook;\r\nkfree_skb(skb);\r\n}\r\nbreak;\r\ncase NF_STOLEN:\r\nbreak;\r\ndefault:\r\nkfree_skb(skb);\r\n}\r\nkfree(entry);\r\n}
