static int ia32_restore_sigcontext(struct pt_regs *regs,\r\nstruct sigcontext_32 __user *sc)\r\n{\r\nunsigned int tmpflags, err = 0;\r\nvoid __user *buf;\r\nu32 tmp;\r\ncurrent->restart_block.fn = do_no_restart_syscall;\r\nget_user_try {\r\nRELOAD_SEG(gs);\r\nRELOAD_SEG(fs);\r\nRELOAD_SEG(ds);\r\nRELOAD_SEG(es);\r\nCOPY(di); COPY(si); COPY(bp); COPY(sp); COPY(bx);\r\nCOPY(dx); COPY(cx); COPY(ip); COPY(ax);\r\nCOPY_SEG_CPL3(cs);\r\nCOPY_SEG_CPL3(ss);\r\nget_user_ex(tmpflags, &sc->flags);\r\nregs->flags = (regs->flags & ~FIX_EFLAGS) | (tmpflags & FIX_EFLAGS);\r\nregs->orig_ax = -1;\r\nget_user_ex(tmp, &sc->fpstate);\r\nbuf = compat_ptr(tmp);\r\n} get_user_catch(err);\r\nerr |= fpu__restore_sig(buf, 1);\r\nforce_iret();\r\nreturn err;\r\n}\r\nasmlinkage long sys32_sigreturn(void)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nstruct sigframe_ia32 __user *frame = (struct sigframe_ia32 __user *)(regs->sp-8);\r\nsigset_t set;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__get_user(set.sig[0], &frame->sc.oldmask)\r\n|| (_COMPAT_NSIG_WORDS > 1\r\n&& __copy_from_user((((char *) &set.sig) + 4),\r\n&frame->extramask,\r\nsizeof(frame->extramask))))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nif (ia32_restore_sigcontext(regs, &frame->sc))\r\ngoto badframe;\r\nreturn regs->ax;\r\nbadframe:\r\nsignal_fault(regs, frame, "32bit sigreturn");\r\nreturn 0;\r\n}\r\nasmlinkage long sys32_rt_sigreturn(void)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nstruct rt_sigframe_ia32 __user *frame;\r\nsigset_t set;\r\nframe = (struct rt_sigframe_ia32 __user *)(regs->sp - 4);\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nif (ia32_restore_sigcontext(regs, &frame->uc.uc_mcontext))\r\ngoto badframe;\r\nif (compat_restore_altstack(&frame->uc.uc_stack))\r\ngoto badframe;\r\nreturn regs->ax;\r\nbadframe:\r\nsignal_fault(regs, frame, "32bit rt sigreturn");\r\nreturn 0;\r\n}\r\nstatic int ia32_setup_sigcontext(struct sigcontext_32 __user *sc,\r\nvoid __user *fpstate,\r\nstruct pt_regs *regs, unsigned int mask)\r\n{\r\nint err = 0;\r\nput_user_try {\r\nput_user_ex(get_user_seg(gs), (unsigned int __user *)&sc->gs);\r\nput_user_ex(get_user_seg(fs), (unsigned int __user *)&sc->fs);\r\nput_user_ex(get_user_seg(ds), (unsigned int __user *)&sc->ds);\r\nput_user_ex(get_user_seg(es), (unsigned int __user *)&sc->es);\r\nput_user_ex(regs->di, &sc->di);\r\nput_user_ex(regs->si, &sc->si);\r\nput_user_ex(regs->bp, &sc->bp);\r\nput_user_ex(regs->sp, &sc->sp);\r\nput_user_ex(regs->bx, &sc->bx);\r\nput_user_ex(regs->dx, &sc->dx);\r\nput_user_ex(regs->cx, &sc->cx);\r\nput_user_ex(regs->ax, &sc->ax);\r\nput_user_ex(current->thread.trap_nr, &sc->trapno);\r\nput_user_ex(current->thread.error_code, &sc->err);\r\nput_user_ex(regs->ip, &sc->ip);\r\nput_user_ex(regs->cs, (unsigned int __user *)&sc->cs);\r\nput_user_ex(regs->flags, &sc->flags);\r\nput_user_ex(regs->sp, &sc->sp_at_signal);\r\nput_user_ex(regs->ss, (unsigned int __user *)&sc->ss);\r\nput_user_ex(ptr_to_compat(fpstate), &sc->fpstate);\r\nput_user_ex(mask, &sc->oldmask);\r\nput_user_ex(current->thread.cr2, &sc->cr2);\r\n} put_user_catch(err);\r\nreturn err;\r\n}\r\nstatic void __user *get_sigframe(struct ksignal *ksig, struct pt_regs *regs,\r\nsize_t frame_size,\r\nvoid __user **fpstate)\r\n{\r\nstruct fpu *fpu = &current->thread.fpu;\r\nunsigned long sp;\r\nsp = regs->sp;\r\nif (ksig->ka.sa.sa_flags & SA_ONSTACK)\r\nsp = sigsp(sp, ksig);\r\nelse if ((regs->ss & 0xffff) != __USER32_DS &&\r\n!(ksig->ka.sa.sa_flags & SA_RESTORER) &&\r\nksig->ka.sa.sa_restorer)\r\nsp = (unsigned long) ksig->ka.sa.sa_restorer;\r\nif (fpu->fpstate_active) {\r\nunsigned long fx_aligned, math_size;\r\nsp = fpu__alloc_mathframe(sp, 1, &fx_aligned, &math_size);\r\n*fpstate = (struct _fpstate_32 __user *) sp;\r\nif (copy_fpstate_to_sigframe(*fpstate, (void __user *)fx_aligned,\r\nmath_size) < 0)\r\nreturn (void __user *) -1L;\r\n}\r\nsp -= frame_size;\r\nsp = ((sp + 4) & -16ul) - 4;\r\nreturn (void __user *) sp;\r\n}\r\nint ia32_setup_frame(int sig, struct ksignal *ksig,\r\ncompat_sigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct sigframe_ia32 __user *frame;\r\nvoid __user *restorer;\r\nint err = 0;\r\nvoid __user *fpstate = NULL;\r\nstatic const struct {\r\nu16 poplmovl;\r\nu32 val;\r\nu16 int80;\r\n} __attribute__((packed)) code = {\r\n0xb858,\r\n__NR_ia32_sigreturn,\r\n0x80cd,\r\n};\r\nframe = get_sigframe(ksig, regs, sizeof(*frame), &fpstate);\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\nreturn -EFAULT;\r\nif (__put_user(sig, &frame->sig))\r\nreturn -EFAULT;\r\nif (ia32_setup_sigcontext(&frame->sc, fpstate, regs, set->sig[0]))\r\nreturn -EFAULT;\r\nif (_COMPAT_NSIG_WORDS > 1) {\r\nif (__copy_to_user(frame->extramask, &set->sig[1],\r\nsizeof(frame->extramask)))\r\nreturn -EFAULT;\r\n}\r\nif (ksig->ka.sa.sa_flags & SA_RESTORER) {\r\nrestorer = ksig->ka.sa.sa_restorer;\r\n} else {\r\nif (current->mm->context.vdso)\r\nrestorer = current->mm->context.vdso +\r\nvdso_image_32.sym___kernel_sigreturn;\r\nelse\r\nrestorer = &frame->retcode;\r\n}\r\nput_user_try {\r\nput_user_ex(ptr_to_compat(restorer), &frame->pretcode);\r\nput_user_ex(*((u64 *)&code), (u64 __user *)frame->retcode);\r\n} put_user_catch(err);\r\nif (err)\r\nreturn -EFAULT;\r\nregs->sp = (unsigned long) frame;\r\nregs->ip = (unsigned long) ksig->ka.sa.sa_handler;\r\nregs->ax = sig;\r\nregs->dx = 0;\r\nregs->cx = 0;\r\nloadsegment(ds, __USER32_DS);\r\nloadsegment(es, __USER32_DS);\r\nregs->cs = __USER32_CS;\r\nregs->ss = __USER32_DS;\r\nreturn 0;\r\n}\r\nint ia32_setup_rt_frame(int sig, struct ksignal *ksig,\r\ncompat_sigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct rt_sigframe_ia32 __user *frame;\r\nvoid __user *restorer;\r\nint err = 0;\r\nvoid __user *fpstate = NULL;\r\nstatic const struct {\r\nu8 movl;\r\nu32 val;\r\nu16 int80;\r\nu8 pad;\r\n} __attribute__((packed)) code = {\r\n0xb8,\r\n__NR_ia32_rt_sigreturn,\r\n0x80cd,\r\n0,\r\n};\r\nframe = get_sigframe(ksig, regs, sizeof(*frame), &fpstate);\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\nreturn -EFAULT;\r\nput_user_try {\r\nput_user_ex(sig, &frame->sig);\r\nput_user_ex(ptr_to_compat(&frame->info), &frame->pinfo);\r\nput_user_ex(ptr_to_compat(&frame->uc), &frame->puc);\r\nif (boot_cpu_has(X86_FEATURE_XSAVE))\r\nput_user_ex(UC_FP_XSTATE, &frame->uc.uc_flags);\r\nelse\r\nput_user_ex(0, &frame->uc.uc_flags);\r\nput_user_ex(0, &frame->uc.uc_link);\r\ncompat_save_altstack_ex(&frame->uc.uc_stack, regs->sp);\r\nif (ksig->ka.sa.sa_flags & SA_RESTORER)\r\nrestorer = ksig->ka.sa.sa_restorer;\r\nelse\r\nrestorer = current->mm->context.vdso +\r\nvdso_image_32.sym___kernel_rt_sigreturn;\r\nput_user_ex(ptr_to_compat(restorer), &frame->pretcode);\r\nput_user_ex(*((u64 *)&code), (u64 __user *)frame->retcode);\r\n} put_user_catch(err);\r\nerr |= copy_siginfo_to_user32(&frame->info, &ksig->info);\r\nerr |= ia32_setup_sigcontext(&frame->uc.uc_mcontext, fpstate,\r\nregs, set->sig[0]);\r\nerr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\r\nif (err)\r\nreturn -EFAULT;\r\nregs->sp = (unsigned long) frame;\r\nregs->ip = (unsigned long) ksig->ka.sa.sa_handler;\r\nregs->ax = sig;\r\nregs->dx = (unsigned long) &frame->info;\r\nregs->cx = (unsigned long) &frame->uc;\r\nloadsegment(ds, __USER32_DS);\r\nloadsegment(es, __USER32_DS);\r\nregs->cs = __USER32_CS;\r\nregs->ss = __USER32_DS;\r\nreturn 0;\r\n}
