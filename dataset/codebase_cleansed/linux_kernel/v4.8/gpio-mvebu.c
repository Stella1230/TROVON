static inline void __iomem *mvebu_gpioreg_out(struct mvebu_gpio_chip *mvchip)\r\n{\r\nreturn mvchip->membase + GPIO_OUT_OFF;\r\n}\r\nstatic inline void __iomem *mvebu_gpioreg_blink(struct mvebu_gpio_chip *mvchip)\r\n{\r\nreturn mvchip->membase + GPIO_BLINK_EN_OFF;\r\n}\r\nstatic inline void __iomem *\r\nmvebu_gpioreg_io_conf(struct mvebu_gpio_chip *mvchip)\r\n{\r\nreturn mvchip->membase + GPIO_IO_CONF_OFF;\r\n}\r\nstatic inline void __iomem *mvebu_gpioreg_in_pol(struct mvebu_gpio_chip *mvchip)\r\n{\r\nreturn mvchip->membase + GPIO_IN_POL_OFF;\r\n}\r\nstatic inline void __iomem *\r\nmvebu_gpioreg_data_in(struct mvebu_gpio_chip *mvchip)\r\n{\r\nreturn mvchip->membase + GPIO_DATA_IN_OFF;\r\n}\r\nstatic inline void __iomem *\r\nmvebu_gpioreg_edge_cause(struct mvebu_gpio_chip *mvchip)\r\n{\r\nint cpu;\r\nswitch (mvchip->soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\nreturn mvchip->membase + GPIO_EDGE_CAUSE_OFF;\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\ncpu = smp_processor_id();\r\nreturn mvchip->percpu_membase +\r\nGPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu);\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic inline void __iomem *\r\nmvebu_gpioreg_edge_mask(struct mvebu_gpio_chip *mvchip)\r\n{\r\nint cpu;\r\nswitch (mvchip->soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\nreturn mvchip->membase + GPIO_EDGE_MASK_OFF;\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\ncpu = smp_processor_id();\r\nreturn mvchip->membase + GPIO_EDGE_MASK_MV78200_OFF(cpu);\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\ncpu = smp_processor_id();\r\nreturn mvchip->percpu_membase +\r\nGPIO_EDGE_MASK_ARMADAXP_OFF(cpu);\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void __iomem *mvebu_gpioreg_level_mask(struct mvebu_gpio_chip *mvchip)\r\n{\r\nint cpu;\r\nswitch (mvchip->soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\nreturn mvchip->membase + GPIO_LEVEL_MASK_OFF;\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\ncpu = smp_processor_id();\r\nreturn mvchip->membase + GPIO_LEVEL_MASK_MV78200_OFF(cpu);\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\ncpu = smp_processor_id();\r\nreturn mvchip->percpu_membase +\r\nGPIO_LEVEL_MASK_ARMADAXP_OFF(cpu);\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void mvebu_gpio_set(struct gpio_chip *chip, unsigned pin, int value)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nu32 u;\r\nspin_lock_irqsave(&mvchip->lock, flags);\r\nu = readl_relaxed(mvebu_gpioreg_out(mvchip));\r\nif (value)\r\nu |= 1 << pin;\r\nelse\r\nu &= ~(1 << pin);\r\nwritel_relaxed(u, mvebu_gpioreg_out(mvchip));\r\nspin_unlock_irqrestore(&mvchip->lock, flags);\r\n}\r\nstatic int mvebu_gpio_get(struct gpio_chip *chip, unsigned pin)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nu32 u;\r\nif (readl_relaxed(mvebu_gpioreg_io_conf(mvchip)) & (1 << pin)) {\r\nu = readl_relaxed(mvebu_gpioreg_data_in(mvchip)) ^\r\nreadl_relaxed(mvebu_gpioreg_in_pol(mvchip));\r\n} else {\r\nu = readl_relaxed(mvebu_gpioreg_out(mvchip));\r\n}\r\nreturn (u >> pin) & 1;\r\n}\r\nstatic void mvebu_gpio_blink(struct gpio_chip *chip, unsigned pin, int value)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nu32 u;\r\nspin_lock_irqsave(&mvchip->lock, flags);\r\nu = readl_relaxed(mvebu_gpioreg_blink(mvchip));\r\nif (value)\r\nu |= 1 << pin;\r\nelse\r\nu &= ~(1 << pin);\r\nwritel_relaxed(u, mvebu_gpioreg_blink(mvchip));\r\nspin_unlock_irqrestore(&mvchip->lock, flags);\r\n}\r\nstatic int mvebu_gpio_direction_input(struct gpio_chip *chip, unsigned pin)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nint ret;\r\nu32 u;\r\nret = pinctrl_gpio_direction_input(chip->base + pin);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&mvchip->lock, flags);\r\nu = readl_relaxed(mvebu_gpioreg_io_conf(mvchip));\r\nu |= 1 << pin;\r\nwritel_relaxed(u, mvebu_gpioreg_io_conf(mvchip));\r\nspin_unlock_irqrestore(&mvchip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mvebu_gpio_direction_output(struct gpio_chip *chip, unsigned pin,\r\nint value)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nint ret;\r\nu32 u;\r\nret = pinctrl_gpio_direction_output(chip->base + pin);\r\nif (ret)\r\nreturn ret;\r\nmvebu_gpio_blink(chip, pin, 0);\r\nmvebu_gpio_set(chip, pin, value);\r\nspin_lock_irqsave(&mvchip->lock, flags);\r\nu = readl_relaxed(mvebu_gpioreg_io_conf(mvchip));\r\nu &= ~(1 << pin);\r\nwritel_relaxed(u, mvebu_gpioreg_io_conf(mvchip));\r\nspin_unlock_irqrestore(&mvchip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mvebu_gpio_to_irq(struct gpio_chip *chip, unsigned pin)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nreturn irq_create_mapping(mvchip->domain, pin);\r\n}\r\nstatic void mvebu_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nu32 mask = ~(1 << (d->irq - gc->irq_base));\r\nirq_gc_lock(gc);\r\nwritel_relaxed(mask, mvebu_gpioreg_edge_cause(mvchip));\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void mvebu_gpio_edge_irq_mask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\nct->mask_cache_priv &= ~mask;\r\nwritel_relaxed(ct->mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void mvebu_gpio_edge_irq_unmask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\nct->mask_cache_priv |= mask;\r\nwritel_relaxed(ct->mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void mvebu_gpio_level_irq_mask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\nct->mask_cache_priv &= ~mask;\r\nwritel_relaxed(ct->mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void mvebu_gpio_level_irq_unmask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\nct->mask_cache_priv |= mask;\r\nwritel_relaxed(ct->mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));\r\nirq_gc_unlock(gc);\r\n}\r\nstatic int mvebu_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nint pin;\r\nu32 u;\r\npin = d->hwirq;\r\nu = readl_relaxed(mvebu_gpioreg_io_conf(mvchip)) & (1 << pin);\r\nif (!u)\r\nreturn -EINVAL;\r\ntype &= IRQ_TYPE_SENSE_MASK;\r\nif (type == IRQ_TYPE_NONE)\r\nreturn -EINVAL;\r\nif (!(ct->type & type))\r\nif (irq_setup_alt_chip(d, type))\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nu = readl_relaxed(mvebu_gpioreg_in_pol(mvchip));\r\nu &= ~(1 << pin);\r\nwritel_relaxed(u, mvebu_gpioreg_in_pol(mvchip));\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nu = readl_relaxed(mvebu_gpioreg_in_pol(mvchip));\r\nu |= 1 << pin;\r\nwritel_relaxed(u, mvebu_gpioreg_in_pol(mvchip));\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH: {\r\nu32 v;\r\nv = readl_relaxed(mvebu_gpioreg_in_pol(mvchip)) ^\r\nreadl_relaxed(mvebu_gpioreg_data_in(mvchip));\r\nu = readl_relaxed(mvebu_gpioreg_in_pol(mvchip));\r\nif (v & (1 << pin))\r\nu |= 1 << pin;\r\nelse\r\nu &= ~(1 << pin);\r\nwritel_relaxed(u, mvebu_gpioreg_in_pol(mvchip));\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvebu_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nu32 cause, type;\r\nint i;\r\nif (mvchip == NULL)\r\nreturn;\r\nchained_irq_enter(chip, desc);\r\ncause = readl_relaxed(mvebu_gpioreg_data_in(mvchip)) &\r\nreadl_relaxed(mvebu_gpioreg_level_mask(mvchip));\r\ncause |= readl_relaxed(mvebu_gpioreg_edge_cause(mvchip)) &\r\nreadl_relaxed(mvebu_gpioreg_edge_mask(mvchip));\r\nfor (i = 0; i < mvchip->chip.ngpio; i++) {\r\nint irq;\r\nirq = mvchip->irqbase + i;\r\nif (!(cause & (1 << i)))\r\ncontinue;\r\ntype = irq_get_trigger_type(irq);\r\nif ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {\r\nu32 polarity;\r\npolarity = readl_relaxed(mvebu_gpioreg_in_pol(mvchip));\r\npolarity ^= 1 << i;\r\nwritel_relaxed(polarity, mvebu_gpioreg_in_pol(mvchip));\r\n}\r\ngeneric_handle_irq(irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void mvebu_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nu32 out, io_conf, blink, in_pol, data_in, cause, edg_msk, lvl_msk;\r\nint i;\r\nout = readl_relaxed(mvebu_gpioreg_out(mvchip));\r\nio_conf = readl_relaxed(mvebu_gpioreg_io_conf(mvchip));\r\nblink = readl_relaxed(mvebu_gpioreg_blink(mvchip));\r\nin_pol = readl_relaxed(mvebu_gpioreg_in_pol(mvchip));\r\ndata_in = readl_relaxed(mvebu_gpioreg_data_in(mvchip));\r\ncause = readl_relaxed(mvebu_gpioreg_edge_cause(mvchip));\r\nedg_msk = readl_relaxed(mvebu_gpioreg_edge_mask(mvchip));\r\nlvl_msk = readl_relaxed(mvebu_gpioreg_level_mask(mvchip));\r\nfor (i = 0; i < chip->ngpio; i++) {\r\nconst char *label;\r\nu32 msk;\r\nbool is_out;\r\nlabel = gpiochip_is_requested(chip, i);\r\nif (!label)\r\ncontinue;\r\nmsk = 1 << i;\r\nis_out = !(io_conf & msk);\r\nseq_printf(s, " gpio-%-3d (%-20.20s)", chip->base + i, label);\r\nif (is_out) {\r\nseq_printf(s, " out %s %s\n",\r\nout & msk ? "hi" : "lo",\r\nblink & msk ? "(blink )" : "");\r\ncontinue;\r\n}\r\nseq_printf(s, " in %s (act %s) - IRQ",\r\n(data_in ^ in_pol) & msk ? "hi" : "lo",\r\nin_pol & msk ? "lo" : "hi");\r\nif (!((edg_msk | lvl_msk) & msk)) {\r\nseq_puts(s, " disabled\n");\r\ncontinue;\r\n}\r\nif (edg_msk & msk)\r\nseq_puts(s, " edge ");\r\nif (lvl_msk & msk)\r\nseq_puts(s, " level");\r\nseq_printf(s, " (%s)\n", cause & msk ? "pending" : "clear ");\r\n}\r\n}\r\nstatic int mvebu_gpio_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);\r\nint i;\r\nmvchip->out_reg = readl(mvebu_gpioreg_out(mvchip));\r\nmvchip->io_conf_reg = readl(mvebu_gpioreg_io_conf(mvchip));\r\nmvchip->blink_en_reg = readl(mvebu_gpioreg_blink(mvchip));\r\nmvchip->in_pol_reg = readl(mvebu_gpioreg_in_pol(mvchip));\r\nswitch (mvchip->soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\nmvchip->edge_mask_regs[0] =\r\nreadl(mvchip->membase + GPIO_EDGE_MASK_OFF);\r\nmvchip->level_mask_regs[0] =\r\nreadl(mvchip->membase + GPIO_LEVEL_MASK_OFF);\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\nfor (i = 0; i < 2; i++) {\r\nmvchip->edge_mask_regs[i] =\r\nreadl(mvchip->membase +\r\nGPIO_EDGE_MASK_MV78200_OFF(i));\r\nmvchip->level_mask_regs[i] =\r\nreadl(mvchip->membase +\r\nGPIO_LEVEL_MASK_MV78200_OFF(i));\r\n}\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\nfor (i = 0; i < 4; i++) {\r\nmvchip->edge_mask_regs[i] =\r\nreadl(mvchip->membase +\r\nGPIO_EDGE_MASK_ARMADAXP_OFF(i));\r\nmvchip->level_mask_regs[i] =\r\nreadl(mvchip->membase +\r\nGPIO_LEVEL_MASK_ARMADAXP_OFF(i));\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvebu_gpio_resume(struct platform_device *pdev)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);\r\nint i;\r\nwritel(mvchip->out_reg, mvebu_gpioreg_out(mvchip));\r\nwritel(mvchip->io_conf_reg, mvebu_gpioreg_io_conf(mvchip));\r\nwritel(mvchip->blink_en_reg, mvebu_gpioreg_blink(mvchip));\r\nwritel(mvchip->in_pol_reg, mvebu_gpioreg_in_pol(mvchip));\r\nswitch (mvchip->soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\nwritel(mvchip->edge_mask_regs[0],\r\nmvchip->membase + GPIO_EDGE_MASK_OFF);\r\nwritel(mvchip->level_mask_regs[0],\r\nmvchip->membase + GPIO_LEVEL_MASK_OFF);\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\nfor (i = 0; i < 2; i++) {\r\nwritel(mvchip->edge_mask_regs[i],\r\nmvchip->membase + GPIO_EDGE_MASK_MV78200_OFF(i));\r\nwritel(mvchip->level_mask_regs[i],\r\nmvchip->membase +\r\nGPIO_LEVEL_MASK_MV78200_OFF(i));\r\n}\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\nfor (i = 0; i < 4; i++) {\r\nwritel(mvchip->edge_mask_regs[i],\r\nmvchip->membase +\r\nGPIO_EDGE_MASK_ARMADAXP_OFF(i));\r\nwritel(mvchip->level_mask_regs[i],\r\nmvchip->membase +\r\nGPIO_LEVEL_MASK_ARMADAXP_OFF(i));\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvebu_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct mvebu_gpio_chip *mvchip;\r\nconst struct of_device_id *match;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *res;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nstruct clk *clk;\r\nunsigned int ngpios;\r\nint soc_variant;\r\nint i, cpu, id;\r\nint err;\r\nmatch = of_match_device(mvebu_gpio_of_match, &pdev->dev);\r\nif (match)\r\nsoc_variant = (int) match->data;\r\nelse\r\nsoc_variant = MVEBU_GPIO_SOC_VARIANT_ORION;\r\nmvchip = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_gpio_chip),\r\nGFP_KERNEL);\r\nif (!mvchip)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mvchip);\r\nif (of_property_read_u32(pdev->dev.of_node, "ngpios", &ngpios)) {\r\ndev_err(&pdev->dev, "Missing ngpios OF property\n");\r\nreturn -ENODEV;\r\n}\r\nid = of_alias_get_id(pdev->dev.of_node, "gpio");\r\nif (id < 0) {\r\ndev_err(&pdev->dev, "Couldn't get OF id\n");\r\nreturn id;\r\n}\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(clk))\r\nclk_prepare_enable(clk);\r\nmvchip->soc_variant = soc_variant;\r\nmvchip->chip.label = dev_name(&pdev->dev);\r\nmvchip->chip.parent = &pdev->dev;\r\nmvchip->chip.request = gpiochip_generic_request;\r\nmvchip->chip.free = gpiochip_generic_free;\r\nmvchip->chip.direction_input = mvebu_gpio_direction_input;\r\nmvchip->chip.get = mvebu_gpio_get;\r\nmvchip->chip.direction_output = mvebu_gpio_direction_output;\r\nmvchip->chip.set = mvebu_gpio_set;\r\nmvchip->chip.to_irq = mvebu_gpio_to_irq;\r\nmvchip->chip.base = id * MVEBU_MAX_GPIO_PER_BANK;\r\nmvchip->chip.ngpio = ngpios;\r\nmvchip->chip.can_sleep = false;\r\nmvchip->chip.of_node = np;\r\nmvchip->chip.dbg_show = mvebu_gpio_dbg_show;\r\nspin_lock_init(&mvchip->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmvchip->membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mvchip->membase))\r\nreturn PTR_ERR(mvchip->membase);\r\nif (soc_variant == MVEBU_GPIO_SOC_VARIANT_ARMADAXP) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nmvchip->percpu_membase = devm_ioremap_resource(&pdev->dev,\r\nres);\r\nif (IS_ERR(mvchip->percpu_membase))\r\nreturn PTR_ERR(mvchip->percpu_membase);\r\n}\r\nswitch (soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\nwritel_relaxed(0, mvchip->membase + GPIO_EDGE_CAUSE_OFF);\r\nwritel_relaxed(0, mvchip->membase + GPIO_EDGE_MASK_OFF);\r\nwritel_relaxed(0, mvchip->membase + GPIO_LEVEL_MASK_OFF);\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\nwritel_relaxed(0, mvchip->membase + GPIO_EDGE_CAUSE_OFF);\r\nfor (cpu = 0; cpu < 2; cpu++) {\r\nwritel_relaxed(0, mvchip->membase +\r\nGPIO_EDGE_MASK_MV78200_OFF(cpu));\r\nwritel_relaxed(0, mvchip->membase +\r\nGPIO_LEVEL_MASK_MV78200_OFF(cpu));\r\n}\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\nwritel_relaxed(0, mvchip->membase + GPIO_EDGE_CAUSE_OFF);\r\nwritel_relaxed(0, mvchip->membase + GPIO_EDGE_MASK_OFF);\r\nwritel_relaxed(0, mvchip->membase + GPIO_LEVEL_MASK_OFF);\r\nfor (cpu = 0; cpu < 4; cpu++) {\r\nwritel_relaxed(0, mvchip->percpu_membase +\r\nGPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu));\r\nwritel_relaxed(0, mvchip->percpu_membase +\r\nGPIO_EDGE_MASK_ARMADAXP_OFF(cpu));\r\nwritel_relaxed(0, mvchip->percpu_membase +\r\nGPIO_LEVEL_MASK_ARMADAXP_OFF(cpu));\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ndevm_gpiochip_add_data(&pdev->dev, &mvchip->chip, mvchip);\r\nif (!of_irq_count(np))\r\nreturn 0;\r\nfor (i = 0; i < 4; i++) {\r\nint irq = platform_get_irq(pdev, i);\r\nif (irq < 0)\r\ncontinue;\r\nirq_set_chained_handler_and_data(irq, mvebu_gpio_irq_handler,\r\nmvchip);\r\n}\r\nmvchip->irqbase = irq_alloc_descs(-1, 0, ngpios, -1);\r\nif (mvchip->irqbase < 0) {\r\ndev_err(&pdev->dev, "no irqs\n");\r\nreturn mvchip->irqbase;\r\n}\r\ngc = irq_alloc_generic_chip("mvebu_gpio_irq", 2, mvchip->irqbase,\r\nmvchip->membase, handle_level_irq);\r\nif (!gc) {\r\ndev_err(&pdev->dev, "Cannot allocate generic irq_chip\n");\r\nreturn -ENOMEM;\r\n}\r\ngc->private = mvchip;\r\nct = &gc->chip_types[0];\r\nct->type = IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW;\r\nct->chip.irq_mask = mvebu_gpio_level_irq_mask;\r\nct->chip.irq_unmask = mvebu_gpio_level_irq_unmask;\r\nct->chip.irq_set_type = mvebu_gpio_irq_set_type;\r\nct->chip.name = mvchip->chip.label;\r\nct = &gc->chip_types[1];\r\nct->type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\r\nct->chip.irq_ack = mvebu_gpio_irq_ack;\r\nct->chip.irq_mask = mvebu_gpio_edge_irq_mask;\r\nct->chip.irq_unmask = mvebu_gpio_edge_irq_unmask;\r\nct->chip.irq_set_type = mvebu_gpio_irq_set_type;\r\nct->handler = handle_edge_irq;\r\nct->chip.name = mvchip->chip.label;\r\nirq_setup_generic_chip(gc, IRQ_MSK(ngpios), 0,\r\nIRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);\r\nmvchip->domain = irq_domain_add_simple(np, mvchip->chip.ngpio,\r\nmvchip->irqbase,\r\n&irq_domain_simple_ops,\r\nmvchip);\r\nif (!mvchip->domain) {\r\ndev_err(&pdev->dev, "couldn't allocate irq domain %s (DT).\n",\r\nmvchip->chip.label);\r\nerr = -ENODEV;\r\ngoto err_generic_chip;\r\n}\r\nreturn 0;\r\nerr_generic_chip:\r\nirq_remove_generic_chip(gc, IRQ_MSK(ngpios), IRQ_NOREQUEST,\r\nIRQ_LEVEL | IRQ_NOPROBE);\r\nkfree(gc);\r\nreturn err;\r\n}
