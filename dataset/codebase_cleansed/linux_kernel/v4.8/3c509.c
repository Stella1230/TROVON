static int el3_isa_id_sequence(__be16 *phys_addr)\r\n{\r\nshort lrs_state = 0xff;\r\nint i;\r\noutb(0x00, id_port);\r\noutb(0x00, id_port);\r\nfor (i = 0; i < 255; i++) {\r\noutb(lrs_state, id_port);\r\nlrs_state <<= 1;\r\nlrs_state = lrs_state & 0x100 ? lrs_state ^ 0xcf : lrs_state;\r\n}\r\nif (current_tag == 0)\r\noutb(0xd0, id_port);\r\nelse\r\noutb(0xd8, id_port);\r\nif (id_read_eeprom(7) != 0x6d50)\r\nreturn 1;\r\nfor (i = 0; i < 3; i++)\r\nphys_addr[i] = htons(id_read_eeprom(i));\r\n#ifdef CONFIG_PNP\r\nif (!nopnp) {\r\nfor (i = 0; i < el3_cards; i++) {\r\nstruct el3_private *lp = netdev_priv(el3_devs[i]);\r\nif (lp->type == EL3_PNP &&\r\nether_addr_equal((u8 *)phys_addr, el3_devs[i]->dev_addr)) {\r\nif (el3_debug > 3)\r\npr_debug("3c509 with address %02x %02x %02x %02x %02x %02x was found by ISAPnP\n",\r\nphys_addr[0] & 0xff, phys_addr[0] >> 8,\r\nphys_addr[1] & 0xff, phys_addr[1] >> 8,\r\nphys_addr[2] & 0xff, phys_addr[2] >> 8);\r\noutb(0xd0 + ++current_tag, id_port);\r\nreturn 2;\r\n}\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void el3_dev_fill(struct net_device *dev, __be16 *phys_addr, int ioaddr,\r\nint irq, int if_port, enum el3_cardtype type)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nmemcpy(dev->dev_addr, phys_addr, ETH_ALEN);\r\ndev->base_addr = ioaddr;\r\ndev->irq = irq;\r\ndev->if_port = if_port;\r\nlp->type = type;\r\n}\r\nstatic int el3_isa_match(struct device *pdev, unsigned int ndev)\r\n{\r\nstruct net_device *dev;\r\nint ioaddr, isa_irq, if_port, err;\r\nunsigned int iobase;\r\n__be16 phys_addr[3];\r\nwhile ((err = el3_isa_id_sequence(phys_addr)) == 2)\r\n;\r\nif (err == 1)\r\nreturn 0;\r\niobase = id_read_eeprom(8);\r\nif_port = iobase >> 14;\r\nioaddr = 0x200 + ((iobase & 0x1f) << 4);\r\nif (irq[el3_cards] > 1 && irq[el3_cards] < 16)\r\nisa_irq = irq[el3_cards];\r\nelse\r\nisa_irq = id_read_eeprom(9) >> 12;\r\ndev = alloc_etherdev(sizeof(struct el3_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(dev, pdev);\r\nnetdev_boot_setup_check(dev);\r\nif (!request_region(ioaddr, EL3_IO_EXTENT, "3c509-isa")) {\r\nfree_netdev(dev);\r\nreturn 0;\r\n}\r\noutb(0xd0 + ++current_tag, id_port);\r\noutb((ioaddr >> 4) | 0xe0, id_port);\r\nEL3WINDOW(0);\r\nif (inw(ioaddr) != 0x6d50) {\r\nfree_netdev(dev);\r\nreturn 0;\r\n}\r\noutw(0x0f00, ioaddr + WN0_IRQ);\r\nel3_dev_fill(dev, phys_addr, ioaddr, isa_irq, if_port, EL3_ISA);\r\ndev_set_drvdata(pdev, dev);\r\nif (el3_common_init(dev)) {\r\nfree_netdev(dev);\r\nreturn 0;\r\n}\r\nel3_devs[el3_cards++] = dev;\r\nreturn 1;\r\n}\r\nstatic int el3_isa_remove(struct device *pdev,\r\nunsigned int ndev)\r\n{\r\nel3_device_remove(pdev);\r\ndev_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int el3_isa_suspend(struct device *dev, unsigned int n,\r\npm_message_t state)\r\n{\r\ncurrent_tag = 0;\r\nreturn el3_suspend(dev, state);\r\n}\r\nstatic int el3_isa_resume(struct device *dev, unsigned int n)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nint ioaddr = ndev->base_addr, err;\r\n__be16 phys_addr[3];\r\nwhile ((err = el3_isa_id_sequence(phys_addr)) == 2)\r\n;\r\nif (err == 1)\r\nreturn 0;\r\noutb(0xd0 + ++current_tag, id_port);\r\noutb((ioaddr >> 4) | 0xe0, id_port);\r\nEL3WINDOW(0);\r\nif (inw(ioaddr) != 0x6d50)\r\nreturn 1;\r\noutw(0x0f00, ioaddr + WN0_IRQ);\r\nreturn el3_resume(dev);\r\n}\r\nstatic int el3_pnp_probe(struct pnp_dev *pdev, const struct pnp_device_id *id)\r\n{\r\nshort i;\r\nint ioaddr, irq, if_port;\r\n__be16 phys_addr[3];\r\nstruct net_device *dev = NULL;\r\nint err;\r\nioaddr = pnp_port_start(pdev, 0);\r\nif (!request_region(ioaddr, EL3_IO_EXTENT, "3c509-pnp"))\r\nreturn -EBUSY;\r\nirq = pnp_irq(pdev, 0);\r\nEL3WINDOW(0);\r\nfor (i = 0; i < 3; i++)\r\nphys_addr[i] = htons(read_eeprom(ioaddr, i));\r\nif_port = read_eeprom(ioaddr, 8) >> 14;\r\ndev = alloc_etherdev(sizeof(struct el3_private));\r\nif (!dev) {\r\nrelease_region(ioaddr, EL3_IO_EXTENT);\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nnetdev_boot_setup_check(dev);\r\nel3_dev_fill(dev, phys_addr, ioaddr, irq, if_port, EL3_PNP);\r\npnp_set_drvdata(pdev, dev);\r\nerr = el3_common_init(dev);\r\nif (err) {\r\npnp_set_drvdata(pdev, NULL);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nel3_devs[el3_cards++] = dev;\r\nreturn 0;\r\n}\r\nstatic void el3_pnp_remove(struct pnp_dev *pdev)\r\n{\r\nel3_common_remove(pnp_get_drvdata(pdev));\r\npnp_set_drvdata(pdev, NULL);\r\n}\r\nstatic int el3_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)\r\n{\r\nreturn el3_suspend(&pdev->dev, state);\r\n}\r\nstatic int el3_pnp_resume(struct pnp_dev *pdev)\r\n{\r\nreturn el3_resume(&pdev->dev);\r\n}\r\nstatic int el3_common_init(struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nint err;\r\nconst char *if_names[] = {"10baseT", "AUI", "undefined", "BNC"};\r\nspin_lock_init(&lp->lock);\r\nif (dev->mem_start & 0x05) {\r\ndev->if_port = (dev->mem_start & 0x0f);\r\n} else {\r\ndev->if_port |= (dev->mem_start & 0x08);\r\n}\r\ndev->netdev_ops = &netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->ethtool_ops = &ethtool_ops;\r\nerr = register_netdev(dev);\r\nif (err) {\r\npr_err("Failed to register 3c5x9 at %#3.3lx, IRQ %d.\n",\r\ndev->base_addr, dev->irq);\r\nrelease_region(dev->base_addr, EL3_IO_EXTENT);\r\nreturn err;\r\n}\r\npr_info("%s: 3c5x9 found at %#3.3lx, %s port, address %pM, IRQ %d.\n",\r\ndev->name, dev->base_addr, if_names[(dev->if_port & 0x03)],\r\ndev->dev_addr, dev->irq);\r\nif (el3_debug > 0)\r\npr_info("%s", version);\r\nreturn 0;\r\n}\r\nstatic void el3_common_remove (struct net_device *dev)\r\n{\r\nunregister_netdev (dev);\r\nrelease_region(dev->base_addr, EL3_IO_EXTENT);\r\nfree_netdev (dev);\r\n}\r\nstatic int el3_eisa_probe(struct device *device)\r\n{\r\nshort i;\r\nint ioaddr, irq, if_port;\r\n__be16 phys_addr[3];\r\nstruct net_device *dev = NULL;\r\nstruct eisa_device *edev;\r\nint err;\r\nedev = to_eisa_device (device);\r\nioaddr = edev->base_addr;\r\nif (!request_region(ioaddr, EL3_IO_EXTENT, "3c579-eisa"))\r\nreturn -EBUSY;\r\noutw(SelectWindow | 0, ioaddr + 0xC80 + EL3_CMD);\r\nirq = inw(ioaddr + WN0_IRQ) >> 12;\r\nif_port = inw(ioaddr + 6)>>14;\r\nfor (i = 0; i < 3; i++)\r\nphys_addr[i] = htons(read_eeprom(ioaddr, i));\r\nread_eeprom(ioaddr, 3);\r\ndev = alloc_etherdev(sizeof (struct el3_private));\r\nif (dev == NULL) {\r\nrelease_region(ioaddr, EL3_IO_EXTENT);\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(dev, device);\r\nnetdev_boot_setup_check(dev);\r\nel3_dev_fill(dev, phys_addr, ioaddr, irq, if_port, EL3_EISA);\r\neisa_set_drvdata (edev, dev);\r\nerr = el3_common_init(dev);\r\nif (err) {\r\neisa_set_drvdata (edev, NULL);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nel3_devs[el3_cards++] = dev;\r\nreturn 0;\r\n}\r\nstatic int el3_device_remove(struct device *device)\r\n{\r\nstruct net_device *dev;\r\ndev = dev_get_drvdata(device);\r\nel3_common_remove (dev);\r\nreturn 0;\r\n}\r\nstatic ushort read_eeprom(int ioaddr, int index)\r\n{\r\noutw(EEPROM_READ + index, ioaddr + 10);\r\nmdelay(2);\r\nreturn inw(ioaddr + 12);\r\n}\r\nstatic ushort id_read_eeprom(int index)\r\n{\r\nint bit, word = 0;\r\noutb(EEPROM_READ + index, id_port);\r\nmdelay(4);\r\nfor (bit = 15; bit >= 0; bit--)\r\nword = (word << 1) + (inb(id_port) & 0x01);\r\nif (el3_debug > 3)\r\npr_debug(" 3c509 EEPROM word %d %#4.4x.\n", index, word);\r\nreturn word;\r\n}\r\nstatic int\r\nel3_open(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nint i;\r\noutw(TxReset, ioaddr + EL3_CMD);\r\noutw(RxReset, ioaddr + EL3_CMD);\r\noutw(SetStatusEnb | 0x00, ioaddr + EL3_CMD);\r\ni = request_irq(dev->irq, el3_interrupt, 0, dev->name, dev);\r\nif (i)\r\nreturn i;\r\nEL3WINDOW(0);\r\nif (el3_debug > 3)\r\npr_debug("%s: Opening, IRQ %d status@%x %4.4x.\n", dev->name,\r\ndev->irq, ioaddr + EL3_STATUS, inw(ioaddr + EL3_STATUS));\r\nel3_up(dev);\r\nif (el3_debug > 3)\r\npr_debug("%s: Opened 3c509 IRQ %d status %4.4x.\n",\r\ndev->name, dev->irq, inw(ioaddr + EL3_STATUS));\r\nreturn 0;\r\n}\r\nstatic void\r\nel3_tx_timeout (struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\npr_warn("%s: transmit timed out, Tx_status %2.2x status %4.4x Tx FIFO room %d\n",\r\ndev->name, inb(ioaddr + TX_STATUS), inw(ioaddr + EL3_STATUS),\r\ninw(ioaddr + TX_FREE));\r\ndev->stats.tx_errors++;\r\nnetif_trans_update(dev);\r\noutw(TxReset, ioaddr + EL3_CMD);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t\r\nel3_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nnetif_stop_queue (dev);\r\ndev->stats.tx_bytes += skb->len;\r\nif (el3_debug > 4) {\r\npr_debug("%s: el3_start_xmit(length = %u) called, status %4.4x.\n",\r\ndev->name, skb->len, inw(ioaddr + EL3_STATUS));\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\noutw(skb->len, ioaddr + TX_FIFO);\r\noutw(0x00, ioaddr + TX_FIFO);\r\noutsl(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);\r\nif (inw(ioaddr + TX_FREE) > 1536)\r\nnetif_start_queue(dev);\r\nelse\r\noutw(SetTxThreshold + 1536, ioaddr + EL3_CMD);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndev_consume_skb_any (skb);\r\n{\r\nshort tx_status;\r\nint i = 4;\r\nwhile (--i > 0 && (tx_status = inb(ioaddr + TX_STATUS)) > 0) {\r\nif (tx_status & 0x38) dev->stats.tx_aborted_errors++;\r\nif (tx_status & 0x30) outw(TxReset, ioaddr + EL3_CMD);\r\nif (tx_status & 0x3C) outw(TxEnable, ioaddr + EL3_CMD);\r\noutb(0x00, ioaddr + TX_STATUS);\r\n}\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t\r\nel3_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct el3_private *lp;\r\nint ioaddr, status;\r\nint i = max_interrupt_work;\r\nlp = netdev_priv(dev);\r\nspin_lock(&lp->lock);\r\nioaddr = dev->base_addr;\r\nif (el3_debug > 4) {\r\nstatus = inw(ioaddr + EL3_STATUS);\r\npr_debug("%s: interrupt, status %4.4x.\n", dev->name, status);\r\n}\r\nwhile ((status = inw(ioaddr + EL3_STATUS)) &\r\n(IntLatch | RxComplete | StatsFull)) {\r\nif (status & RxComplete)\r\nel3_rx(dev);\r\nif (status & TxAvailable) {\r\nif (el3_debug > 5)\r\npr_debug(" TX room bit was handled.\n");\r\noutw(AckIntr | TxAvailable, ioaddr + EL3_CMD);\r\nnetif_wake_queue (dev);\r\n}\r\nif (status & (AdapterFailure | RxEarly | StatsFull | TxComplete)) {\r\nif (status & StatsFull)\r\nupdate_stats(dev);\r\nif (status & RxEarly) {\r\nel3_rx(dev);\r\noutw(AckIntr | RxEarly, ioaddr + EL3_CMD);\r\n}\r\nif (status & TxComplete) {\r\nshort tx_status;\r\nint i = 4;\r\nwhile (--i>0 && (tx_status = inb(ioaddr + TX_STATUS)) > 0) {\r\nif (tx_status & 0x38) dev->stats.tx_aborted_errors++;\r\nif (tx_status & 0x30) outw(TxReset, ioaddr + EL3_CMD);\r\nif (tx_status & 0x3C) outw(TxEnable, ioaddr + EL3_CMD);\r\noutb(0x00, ioaddr + TX_STATUS);\r\n}\r\n}\r\nif (status & AdapterFailure) {\r\noutw(RxReset, ioaddr + EL3_CMD);\r\noutw(SetRxFilter | RxStation | RxBroadcast\r\n| (dev->flags & IFF_ALLMULTI ? RxMulticast : 0)\r\n| (dev->flags & IFF_PROMISC ? RxProm : 0),\r\nioaddr + EL3_CMD);\r\noutw(RxEnable, ioaddr + EL3_CMD);\r\noutw(AckIntr | AdapterFailure, ioaddr + EL3_CMD);\r\n}\r\n}\r\nif (--i < 0) {\r\npr_err("%s: Infinite loop in interrupt, status %4.4x.\n",\r\ndev->name, status);\r\noutw(AckIntr | 0xFF, ioaddr + EL3_CMD);\r\nbreak;\r\n}\r\noutw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);\r\n}\r\nif (el3_debug > 4) {\r\npr_debug("%s: exiting interrupt, status %4.4x.\n", dev->name,\r\ninw(ioaddr + EL3_STATUS));\r\n}\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void el3_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nel3_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic struct net_device_stats *\r\nel3_get_stats(struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nupdate_stats(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn &dev->stats;\r\n}\r\nstatic void update_stats(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nif (el3_debug > 5)\r\npr_debug(" Updating the statistics.\n");\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\nEL3WINDOW(6);\r\ndev->stats.tx_carrier_errors += inb(ioaddr + 0);\r\ndev->stats.tx_heartbeat_errors += inb(ioaddr + 1);\r\ninb(ioaddr + 2);\r\ndev->stats.collisions += inb(ioaddr + 3);\r\ndev->stats.tx_window_errors += inb(ioaddr + 4);\r\ndev->stats.rx_fifo_errors += inb(ioaddr + 5);\r\ndev->stats.tx_packets += inb(ioaddr + 6);\r\ninb(ioaddr + 7);\r\ninb(ioaddr + 8);\r\ninw(ioaddr + 10);\r\ninw(ioaddr + 12);\r\nEL3WINDOW(1);\r\noutw(StatsEnable, ioaddr + EL3_CMD);\r\n}\r\nstatic int\r\nel3_rx(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nshort rx_status;\r\nif (el3_debug > 5)\r\npr_debug(" In rx_packet(), status %4.4x, rx_status %4.4x.\n",\r\ninw(ioaddr+EL3_STATUS), inw(ioaddr+RX_STATUS));\r\nwhile ((rx_status = inw(ioaddr + RX_STATUS)) > 0) {\r\nif (rx_status & 0x4000) {\r\nshort error = rx_status & 0x3800;\r\noutw(RxDiscard, ioaddr + EL3_CMD);\r\ndev->stats.rx_errors++;\r\nswitch (error) {\r\ncase 0x0000: dev->stats.rx_over_errors++; break;\r\ncase 0x0800: dev->stats.rx_length_errors++; break;\r\ncase 0x1000: dev->stats.rx_frame_errors++; break;\r\ncase 0x1800: dev->stats.rx_length_errors++; break;\r\ncase 0x2000: dev->stats.rx_frame_errors++; break;\r\ncase 0x2800: dev->stats.rx_crc_errors++; break;\r\n}\r\n} else {\r\nshort pkt_len = rx_status & 0x7ff;\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(dev, pkt_len + 5);\r\nif (el3_debug > 4)\r\npr_debug("Receiving packet size %d status %4.4x.\n",\r\npkt_len, rx_status);\r\nif (skb != NULL) {\r\nskb_reserve(skb, 2);\r\ninsl(ioaddr + RX_FIFO, skb_put(skb,pkt_len),\r\n(pkt_len + 3) >> 2);\r\noutw(RxDiscard, ioaddr + EL3_CMD);\r\nskb->protocol = eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_bytes += pkt_len;\r\ndev->stats.rx_packets++;\r\ncontinue;\r\n}\r\noutw(RxDiscard, ioaddr + EL3_CMD);\r\ndev->stats.rx_dropped++;\r\nif (el3_debug)\r\npr_debug("%s: Couldn't allocate a sk_buff of size %d.\n",\r\ndev->name, pkt_len);\r\n}\r\ninw(ioaddr + EL3_STATUS);\r\nwhile (inw(ioaddr + EL3_STATUS) & 0x1000)\r\npr_debug(" Waiting for 3c509 to discard packet, status %x.\n",\r\ninw(ioaddr + EL3_STATUS) );\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nset_multicast_list(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct el3_private *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nint mc_count = netdev_mc_count(dev);\r\nif (el3_debug > 1) {\r\nstatic int old;\r\nif (old != mc_count) {\r\nold = mc_count;\r\npr_debug("%s: Setting Rx mode to %d addresses.\n",\r\ndev->name, mc_count);\r\n}\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (dev->flags&IFF_PROMISC) {\r\noutw(SetRxFilter | RxStation | RxMulticast | RxBroadcast | RxProm,\r\nioaddr + EL3_CMD);\r\n}\r\nelse if (mc_count || (dev->flags&IFF_ALLMULTI)) {\r\noutw(SetRxFilter | RxStation | RxMulticast | RxBroadcast, ioaddr + EL3_CMD);\r\n}\r\nelse\r\noutw(SetRxFilter | RxStation | RxBroadcast, ioaddr + EL3_CMD);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic int\r\nel3_close(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct el3_private *lp = netdev_priv(dev);\r\nif (el3_debug > 2)\r\npr_debug("%s: Shutting down ethercard.\n", dev->name);\r\nel3_down(dev);\r\nfree_irq(dev->irq, dev);\r\nEL3WINDOW(0);\r\nif (lp->type != EL3_EISA) {\r\noutw(0x0f00, ioaddr + WN0_IRQ);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nel3_link_ok(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nu16 tmp;\r\nEL3WINDOW(4);\r\ntmp = inw(ioaddr + WN4_MEDIA);\r\nEL3WINDOW(1);\r\nreturn tmp & (1<<11);\r\n}\r\nstatic int\r\nel3_netdev_get_ecmd(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nu16 tmp;\r\nint ioaddr = dev->base_addr;\r\nEL3WINDOW(0);\r\ntmp = inw(ioaddr + WN0_ADDR_CONF);\r\necmd->transceiver = XCVR_INTERNAL;\r\nswitch (tmp >> 14) {\r\ncase 0:\r\necmd->port = PORT_TP;\r\nbreak;\r\ncase 1:\r\necmd->port = PORT_AUI;\r\necmd->transceiver = XCVR_EXTERNAL;\r\nbreak;\r\ncase 3:\r\necmd->port = PORT_BNC;\r\ndefault:\r\nbreak;\r\n}\r\necmd->duplex = DUPLEX_HALF;\r\necmd->supported = 0;\r\ntmp = inw(ioaddr + WN0_CONF_CTRL);\r\nif (tmp & (1<<13))\r\necmd->supported |= SUPPORTED_AUI;\r\nif (tmp & (1<<12))\r\necmd->supported |= SUPPORTED_BNC;\r\nif (tmp & (1<<9)) {\r\necmd->supported |= SUPPORTED_TP | SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full;\r\nEL3WINDOW(4);\r\ntmp = inw(ioaddr + WN4_NETDIAG);\r\nif (tmp & FD_ENABLE)\r\necmd->duplex = DUPLEX_FULL;\r\n}\r\nethtool_cmd_speed_set(ecmd, SPEED_10);\r\nEL3WINDOW(1);\r\nreturn 0;\r\n}\r\nstatic int\r\nel3_netdev_set_ecmd(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nu16 tmp;\r\nint ioaddr = dev->base_addr;\r\nif (ecmd->speed != SPEED_10)\r\nreturn -EINVAL;\r\nif ((ecmd->duplex != DUPLEX_HALF) && (ecmd->duplex != DUPLEX_FULL))\r\nreturn -EINVAL;\r\nif ((ecmd->transceiver != XCVR_INTERNAL) && (ecmd->transceiver != XCVR_EXTERNAL))\r\nreturn -EINVAL;\r\nEL3WINDOW(0);\r\ntmp = inw(ioaddr + WN0_ADDR_CONF);\r\nswitch (ecmd->port) {\r\ncase PORT_TP:\r\ntmp &= ~(3<<14);\r\ndev->if_port = 0;\r\nbreak;\r\ncase PORT_AUI:\r\ntmp |= (1<<14);\r\ndev->if_port = 1;\r\nbreak;\r\ncase PORT_BNC:\r\ntmp |= (3<<14);\r\ndev->if_port = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\noutw(tmp, ioaddr + WN0_ADDR_CONF);\r\nif (dev->if_port == 3) {\r\ntmp = inw(ioaddr + WN0_ADDR_CONF);\r\nif (tmp & (3 << 14)) {\r\noutw(StartCoax, ioaddr + EL3_CMD);\r\nudelay(800);\r\n} else\r\nreturn -EIO;\r\n}\r\nEL3WINDOW(4);\r\ntmp = inw(ioaddr + WN4_NETDIAG);\r\nif (ecmd->duplex == DUPLEX_FULL)\r\ntmp |= FD_ENABLE;\r\nelse\r\ntmp &= ~FD_ENABLE;\r\noutw(tmp, ioaddr + WN4_NETDIAG);\r\nEL3WINDOW(1);\r\nreturn 0;\r\n}\r\nstatic void el3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\n}\r\nstatic int el3_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nint ret;\r\nspin_lock_irq(&lp->lock);\r\nret = el3_netdev_get_ecmd(dev, ecmd);\r\nspin_unlock_irq(&lp->lock);\r\nreturn ret;\r\n}\r\nstatic int el3_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nint ret;\r\nspin_lock_irq(&lp->lock);\r\nret = el3_netdev_set_ecmd(dev, ecmd);\r\nspin_unlock_irq(&lp->lock);\r\nreturn ret;\r\n}\r\nstatic u32 el3_get_link(struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nu32 ret;\r\nspin_lock_irq(&lp->lock);\r\nret = el3_link_ok(dev);\r\nspin_unlock_irq(&lp->lock);\r\nreturn ret;\r\n}\r\nstatic u32 el3_get_msglevel(struct net_device *dev)\r\n{\r\nreturn el3_debug;\r\n}\r\nstatic void el3_set_msglevel(struct net_device *dev, u32 v)\r\n{\r\nel3_debug = v;\r\n}\r\nstatic void\r\nel3_down(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nnetif_stop_queue(dev);\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\noutw(RxDisable, ioaddr + EL3_CMD);\r\noutw(TxDisable, ioaddr + EL3_CMD);\r\nif (dev->if_port == 3)\r\noutw(StopCoax, ioaddr + EL3_CMD);\r\nelse if (dev->if_port == 0) {\r\nEL3WINDOW(4);\r\noutw(inw(ioaddr + WN4_MEDIA) & ~MEDIA_TP, ioaddr + WN4_MEDIA);\r\n}\r\noutw(SetIntrEnb | 0x0000, ioaddr + EL3_CMD);\r\nupdate_stats(dev);\r\n}\r\nstatic void\r\nel3_up(struct net_device *dev)\r\n{\r\nint i, sw_info, net_diag;\r\nint ioaddr = dev->base_addr;\r\noutw(0x0001, ioaddr + 4);\r\noutw((dev->irq << 12) | 0x0f00, ioaddr + WN0_IRQ);\r\nEL3WINDOW(2);\r\nfor (i = 0; i < 6; i++)\r\noutb(dev->dev_addr[i], ioaddr + i);\r\nif ((dev->if_port & 0x03) == 3)\r\noutw(StartCoax, ioaddr + EL3_CMD);\r\nelse if ((dev->if_port & 0x03) == 0) {\r\nEL3WINDOW(0);\r\nsw_info = (read_eeprom(ioaddr, 0x14) & 0x400f) |\r\n(read_eeprom(ioaddr, 0x0d) & 0xBff0);\r\nEL3WINDOW(4);\r\nnet_diag = inw(ioaddr + WN4_NETDIAG);\r\nnet_diag = (net_diag | FD_ENABLE);\r\npr_info("%s: ", dev->name);\r\nswitch (dev->if_port & 0x0c) {\r\ncase 12:\r\nif (sw_info & 0x000f) {\r\npr_cont("Forcing 3c5x9b full-duplex mode");\r\nbreak;\r\n}\r\ncase 8:\r\nif ((sw_info & 0x000f) && (sw_info & 0x8000)) {\r\npr_cont("Setting 3c5x9b full-duplex mode (from EEPROM configuration bit)");\r\nbreak;\r\n}\r\ndefault:\r\npr_cont("Setting 3c5x9/3c5x9B half-duplex mode");\r\nnet_diag = (net_diag & ~FD_ENABLE);\r\n}\r\noutw(net_diag, ioaddr + WN4_NETDIAG);\r\npr_cont(" if_port: %d, sw_info: %4.4x\n", dev->if_port, sw_info);\r\nif (el3_debug > 3)\r\npr_debug("%s: 3c5x9 net diag word is now: %4.4x.\n", dev->name, net_diag);\r\noutw(inw(ioaddr + WN4_MEDIA) | MEDIA_TP, ioaddr + WN4_MEDIA);\r\n}\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\nEL3WINDOW(6);\r\nfor (i = 0; i < 9; i++)\r\ninb(ioaddr + i);\r\ninw(ioaddr + 10);\r\ninw(ioaddr + 12);\r\nEL3WINDOW(1);\r\noutw(SetRxFilter | RxStation | RxBroadcast, ioaddr + EL3_CMD);\r\noutw(StatsEnable, ioaddr + EL3_CMD);\r\noutw(RxEnable, ioaddr + EL3_CMD);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\noutw(SetStatusEnb | 0xff, ioaddr + EL3_CMD);\r\noutw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,\r\nioaddr + EL3_CMD);\r\noutw(SetIntrEnb | IntLatch|TxAvailable|TxComplete|RxComplete|StatsFull,\r\nioaddr + EL3_CMD);\r\nnetif_start_queue(dev);\r\n}\r\nstatic int\r\nel3_suspend(struct device *pdev, pm_message_t state)\r\n{\r\nunsigned long flags;\r\nstruct net_device *dev;\r\nstruct el3_private *lp;\r\nint ioaddr;\r\ndev = dev_get_drvdata(pdev);\r\nlp = netdev_priv(dev);\r\nioaddr = dev->base_addr;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (netif_running(dev))\r\nnetif_device_detach(dev);\r\nel3_down(dev);\r\noutw(PowerDown, ioaddr + EL3_CMD);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nel3_resume(struct device *pdev)\r\n{\r\nunsigned long flags;\r\nstruct net_device *dev;\r\nstruct el3_private *lp;\r\nint ioaddr;\r\ndev = dev_get_drvdata(pdev);\r\nlp = netdev_priv(dev);\r\nioaddr = dev->base_addr;\r\nspin_lock_irqsave(&lp->lock, flags);\r\noutw(PowerUp, ioaddr + EL3_CMD);\r\nEL3WINDOW(0);\r\nel3_up(dev);\r\nif (netif_running(dev))\r\nnetif_device_attach(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init el3_init_module(void)\r\n{\r\nint ret = 0;\r\nif (debug >= 0)\r\nel3_debug = debug;\r\n#ifdef CONFIG_PNP\r\nif (!nopnp) {\r\nret = pnp_register_driver(&el3_pnp_driver);\r\nif (!ret)\r\npnp_registered = 1;\r\n}\r\n#endif\r\nfor (id_port = 0x110 ; id_port < 0x200; id_port += 0x10) {\r\nif (!request_region(id_port, 1, "3c509-control"))\r\ncontinue;\r\noutb(0x00, id_port);\r\noutb(0xff, id_port);\r\nif (inb(id_port) & 0x01)\r\nbreak;\r\nelse\r\nrelease_region(id_port, 1);\r\n}\r\nif (id_port >= 0x200) {\r\nid_port = 0;\r\npr_err("No I/O port available for 3c509 activation.\n");\r\n} else {\r\nret = isa_register_driver(&el3_isa_driver, EL3_MAX_CARDS);\r\nif (!ret)\r\nisa_registered = 1;\r\n}\r\n#ifdef CONFIG_EISA\r\nret = eisa_driver_register(&el3_eisa_driver);\r\nif (!ret)\r\neisa_registered = 1;\r\n#endif\r\n#ifdef CONFIG_PNP\r\nif (pnp_registered)\r\nret = 0;\r\n#endif\r\nif (isa_registered)\r\nret = 0;\r\n#ifdef CONFIG_EISA\r\nif (eisa_registered)\r\nret = 0;\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit el3_cleanup_module(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnp_registered)\r\npnp_unregister_driver(&el3_pnp_driver);\r\n#endif\r\nif (isa_registered)\r\nisa_unregister_driver(&el3_isa_driver);\r\nif (id_port)\r\nrelease_region(id_port, 1);\r\n#ifdef CONFIG_EISA\r\nif (eisa_registered)\r\neisa_driver_unregister(&el3_eisa_driver);\r\n#endif\r\n}
