static void reg_r(struct gspca_dev *gspca_dev,\r\nu16 value, int len)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0x0c,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, 0, gspca_dev->usb_buf, len,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_r %04x failed %d\n", value, ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev, u16 value, u16 index)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_USBO, "reg_w v: %04x i: %04x", value, index);\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x0c,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, NULL, 0,\r\n500);\r\nmsleep(30);\r\nif (ret < 0) {\r\npr_err("reg_w %04x %04x failed %d\n", value, index, ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_wb(struct gspca_dev *gspca_dev, u16 value, u16 index,\r\nconst u8 *data, int len)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_USBO, "reg_wb v: %04x i: %04x %02x...%02x",\r\nvalue, index, *data, data[len - 1]);\r\nmemcpy(gspca_dev->usb_buf, data, len);\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x0c,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, gspca_dev->usb_buf, len,\r\n1000);\r\nmsleep(30);\r\nif (ret < 0) {\r\npr_err("reg_wb %04x %04x failed %d\n", value, index, ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void i2c_write(struct sd *sd,\r\nconst struct i2c_write_cmd *cmd,\r\nint ncmds)\r\n{\r\nstruct gspca_dev *gspca_dev = &sd->gspca_dev;\r\nconst struct sensor_s *sensor;\r\nu16 val, idx;\r\nu8 *buf;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nsensor = &sensor_tb[sd->sensor];\r\nval = (sensor->i2c_addr << 8) | SQ930_CTRL_I2C_IO;\r\nidx = (cmd->val & 0xff00) | cmd->reg;\r\nbuf = gspca_dev->usb_buf;\r\n*buf++ = sensor->i2c_dum;\r\n*buf++ = cmd->val;\r\nwhile (--ncmds > 0) {\r\ncmd++;\r\n*buf++ = cmd->reg;\r\n*buf++ = cmd->val >> 8;\r\n*buf++ = sensor->i2c_dum;\r\n*buf++ = cmd->val;\r\n}\r\nPDEBUG(D_USBO, "i2c_w v: %04x i: %04x %02x...%02x",\r\nval, idx, gspca_dev->usb_buf[0], buf[-1]);\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x0c,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nval, idx,\r\ngspca_dev->usb_buf, buf - gspca_dev->usb_buf,\r\n500);\r\nif (ret < 0) {\r\npr_err("i2c_write failed %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void ucbus_write(struct gspca_dev *gspca_dev,\r\nconst struct ucbus_write_cmd *cmd,\r\nint ncmds,\r\nint batchsize)\r\n{\r\nu8 *buf;\r\nu16 val, idx;\r\nint len, ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif ((batchsize - 1) * 3 > USB_BUF_SZ) {\r\nPERR("Bug: usb_buf overflow\n");\r\ngspca_dev->usb_err = -ENOMEM;\r\nreturn;\r\n}\r\nfor (;;) {\r\nlen = ncmds;\r\nif (len > batchsize)\r\nlen = batchsize;\r\nncmds -= len;\r\nval = (cmd->bw_addr << 8) | SQ930_CTRL_UCBUS_IO;\r\nidx = (cmd->bw_data << 8) | (cmd->bw_addr >> 8);\r\nbuf = gspca_dev->usb_buf;\r\nwhile (--len > 0) {\r\ncmd++;\r\n*buf++ = cmd->bw_addr;\r\n*buf++ = cmd->bw_addr >> 8;\r\n*buf++ = cmd->bw_data;\r\n}\r\nif (buf != gspca_dev->usb_buf)\r\nPDEBUG(D_USBO, "ucbus v: %04x i: %04x %02x...%02x",\r\nval, idx,\r\ngspca_dev->usb_buf[0], buf[-1]);\r\nelse\r\nPDEBUG(D_USBO, "ucbus v: %04x i: %04x",\r\nval, idx);\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x0c,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nval, idx,\r\ngspca_dev->usb_buf, buf - gspca_dev->usb_buf,\r\n500);\r\nif (ret < 0) {\r\npr_err("ucbus_write failed %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\nreturn;\r\n}\r\nmsleep(30);\r\nif (ncmds <= 0)\r\nbreak;\r\ncmd++;\r\n}\r\n}\r\nstatic void gpio_set(struct sd *sd, u16 val, u16 mask)\r\n{\r\nstruct gspca_dev *gspca_dev = &sd->gspca_dev;\r\nif (mask & 0x00ff) {\r\nsd->gpio[0] &= ~mask;\r\nsd->gpio[0] |= val;\r\nreg_w(gspca_dev, 0x0100 | SQ930_CTRL_GPIO,\r\n~sd->gpio[0] << 8);\r\n}\r\nmask >>= 8;\r\nval >>= 8;\r\nif (mask) {\r\nsd->gpio[1] &= ~mask;\r\nsd->gpio[1] |= val;\r\nreg_w(gspca_dev, 0x0300 | SQ930_CTRL_GPIO,\r\n~sd->gpio[1] << 8);\r\n}\r\n}\r\nstatic void gpio_init(struct sd *sd,\r\nconst u8 *gpio)\r\n{\r\ngpio_set(sd, *gpio++, 0x000f);\r\ngpio_set(sd, *gpio++, 0x000f);\r\ngpio_set(sd, *gpio++, 0x000f);\r\ngpio_set(sd, *gpio++, 0x000f);\r\ngpio_set(sd, *gpio, 0x000f);\r\n}\r\nstatic void bridge_init(struct sd *sd)\r\n{\r\nstatic const struct ucbus_write_cmd clkfreq_cmd = {\r\n0xf031, 0\r\n};\r\nucbus_write(&sd->gspca_dev, &clkfreq_cmd, 1, 1);\r\ngpio_set(sd, SQ930_GPIO_POWER, 0xff00);\r\n}\r\nstatic void cmos_probe(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nconst struct sensor_s *sensor;\r\nstatic const u8 probe_order[] = {\r\nSENSOR_OV9630,\r\nSENSOR_MI0360,\r\nSENSOR_OV7660,\r\nSENSOR_MT9V111,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(probe_order); i++) {\r\nsensor = &sensor_tb[probe_order[i]];\r\nucbus_write(&sd->gspca_dev, sensor->cmd, sensor->cmd_len, 8);\r\ngpio_init(sd, sensor->gpio);\r\nmsleep(100);\r\nreg_r(gspca_dev, (sensor->i2c_addr << 8) | 0x001c, 1);\r\nmsleep(100);\r\nif (gspca_dev->usb_buf[0] != 0)\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(probe_order)) {\r\npr_err("Unknown sensor\n");\r\ngspca_dev->usb_err = -EINVAL;\r\nreturn;\r\n}\r\nsd->sensor = probe_order[i];\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7660:\r\ncase SENSOR_OV9630:\r\npr_err("Sensor %s not yet treated\n",\r\nsensor_tb[sd->sensor].name);\r\ngspca_dev->usb_err = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nstatic void mt9v111_init(struct gspca_dev *gspca_dev)\r\n{\r\nint i, nwait;\r\nstatic const u8 cmd_001b[] = {\r\n0x00, 0x3b, 0xf6, 0x01, 0x03, 0x02, 0x00, 0x00,\r\n0x00, 0x00, 0x00\r\n};\r\nstatic const u8 cmd_011b[][7] = {\r\n{0x10, 0x01, 0x66, 0x08, 0x00, 0x00, 0x00},\r\n{0x01, 0x00, 0x1a, 0x04, 0x00, 0x00, 0x00},\r\n{0x20, 0x00, 0x10, 0x04, 0x00, 0x00, 0x00},\r\n{0x02, 0x01, 0xae, 0x01, 0x00, 0x00, 0x00},\r\n};\r\nreg_wb(gspca_dev, 0x001b, 0x0000, cmd_001b, sizeof cmd_001b);\r\nfor (i = 0; i < ARRAY_SIZE(cmd_011b); i++) {\r\nreg_wb(gspca_dev, 0x001b, 0x0000, cmd_011b[i],\r\nARRAY_SIZE(cmd_011b[0]));\r\nmsleep(400);\r\nnwait = 20;\r\nfor (;;) {\r\nreg_r(gspca_dev, 0x031b, 1);\r\nif (gspca_dev->usb_buf[0] == 0\r\n|| gspca_dev->usb_err != 0)\r\nbreak;\r\nif (--nwait < 0) {\r\nPDEBUG(D_PROBE, "mt9v111_init timeout");\r\ngspca_dev->usb_err = -ETIME;\r\nreturn;\r\n}\r\nmsleep(50);\r\n}\r\n}\r\n}\r\nstatic void global_init(struct sd *sd, int first_time)\r\n{\r\nswitch (sd->sensor) {\r\ncase SENSOR_ICX098BQ:\r\nif (first_time)\r\nucbus_write(&sd->gspca_dev,\r\nicx098bq_start_0,\r\n8, 8);\r\ngpio_init(sd, sensor_tb[sd->sensor].gpio);\r\nbreak;\r\ncase SENSOR_LZ24BP:\r\nif (sd->type != Creative_live_motion)\r\ngpio_set(sd, SQ930_GPIO_EXTRA1, 0x00ff);\r\nelse\r\ngpio_set(sd, 0, 0x00ff);\r\nmsleep(50);\r\nif (first_time)\r\nucbus_write(&sd->gspca_dev,\r\nlz24bp_start_0,\r\n8, 8);\r\ngpio_init(sd, sensor_tb[sd->sensor].gpio);\r\nbreak;\r\ncase SENSOR_MI0360:\r\nif (first_time)\r\nucbus_write(&sd->gspca_dev,\r\nmi0360_start_0,\r\nARRAY_SIZE(mi0360_start_0),\r\n8);\r\ngpio_init(sd, sensor_tb[sd->sensor].gpio);\r\ngpio_set(sd, SQ930_GPIO_EXTRA2, SQ930_GPIO_EXTRA2);\r\nbreak;\r\ndefault:\r\nif (first_time)\r\nmt9v111_init(&sd->gspca_dev);\r\nelse\r\ngpio_init(sd, sensor_tb[sd->sensor].gpio);\r\nbreak;\r\n}\r\n}\r\nstatic void lz24bp_ppl(struct sd *sd, u16 ppl)\r\n{\r\nstruct ucbus_write_cmd cmds[2] = {\r\n{0xf810, ppl >> 8},\r\n{0xf811, ppl}\r\n};\r\nucbus_write(&sd->gspca_dev, cmds, ARRAY_SIZE(cmds), 2);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 expo, s32 gain)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, integclks, intstartclk, frameclks, min_frclk;\r\nconst struct sensor_s *sensor;\r\nu16 cmd;\r\nu8 buf[15];\r\nintegclks = expo;\r\ni = 0;\r\ncmd = SQ930_CTRL_SET_EXPOSURE;\r\nswitch (sd->sensor) {\r\ncase SENSOR_ICX098BQ:\r\ncase SENSOR_LZ24BP:\r\nmin_frclk = sd->sensor == SENSOR_ICX098BQ ? 0x210 : 0x26f;\r\nif (integclks >= min_frclk) {\r\nintstartclk = 0;\r\nframeclks = integclks;\r\n} else {\r\nintstartclk = min_frclk - integclks;\r\nframeclks = min_frclk;\r\n}\r\nbuf[i++] = intstartclk >> 8;\r\nbuf[i++] = intstartclk;\r\nbuf[i++] = frameclks >> 8;\r\nbuf[i++] = frameclks;\r\nbuf[i++] = gain;\r\nbreak;\r\ndefault:\r\ncmd |= 0x0100;\r\nsensor = &sensor_tb[sd->sensor];\r\nbuf[i++] = sensor->i2c_addr;\r\nbuf[i++] = 0x08;\r\nbuf[i++] = 0x09;\r\nbuf[i++] = integclks >> 8;\r\nbuf[i++] = sensor->i2c_dum;\r\nbuf[i++] = integclks;\r\nbuf[i++] = 0x35;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = sensor->i2c_dum;\r\nbuf[i++] = 0x80 + gain / 2;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x83;\r\nbreak;\r\n}\r\nreg_wb(gspca_dev, cmd, 0, buf, i);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam = &gspca_dev->cam;\r\nsd->sensor = id->driver_info >> 8;\r\nsd->type = id->driver_info;\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\ncam->bulk = 1;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->gpio[0] = sd->gpio[1] = 0xff;\r\nreg_r(gspca_dev, SQ930_CTRL_GET_DEV_INFO, 8);\r\nif (gspca_dev->usb_err < 0)\r\nreturn gspca_dev->usb_err;\r\nPDEBUG(D_PROBE, "info: %*ph", 8, gspca_dev->usb_buf);\r\nbridge_init(sd);\r\nif (sd->sensor == SENSOR_MI0360) {\r\nif (gspca_dev->usb_buf[5] == 0xf6)\r\nsd->sensor = SENSOR_ICX098BQ;\r\nelse\r\ncmos_probe(gspca_dev);\r\n}\r\nif (gspca_dev->usb_err >= 0) {\r\nPDEBUG(D_PROBE, "Sensor %s", sensor_tb[sd->sensor].name);\r\nglobal_init(sd, 1);\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void send_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst struct cap_s *cap;\r\nint mode;\r\nmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\ncap = &capconfig[sd->sensor][mode];\r\nreg_wb(gspca_dev, 0x0900 | SQ930_CTRL_CAP_START,\r\n0x0a00 | cap->cc_sizeid,\r\ncap->cc_bytes, 32);\r\n}\r\nstatic void send_stop(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w(gspca_dev, SQ930_CTRL_CAP_STOP, 0);\r\n}\r\nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_dev->cam.bulk_nurbs = 1;\r\nsd->do_ctrl = 0;\r\ngspca_dev->cam.bulk_size = gspca_dev->pixfmt.width *\r\ngspca_dev->pixfmt.height + 8;\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint mode;\r\nbridge_init(sd);\r\nglobal_init(sd, 0);\r\nmsleep(100);\r\nswitch (sd->sensor) {\r\ncase SENSOR_ICX098BQ:\r\nucbus_write(gspca_dev, icx098bq_start_0,\r\nARRAY_SIZE(icx098bq_start_0),\r\n8);\r\nucbus_write(gspca_dev, icx098bq_start_1,\r\nARRAY_SIZE(icx098bq_start_1),\r\n5);\r\nucbus_write(gspca_dev, icx098bq_start_2,\r\nARRAY_SIZE(icx098bq_start_2),\r\n6);\r\nmsleep(50);\r\nsend_start(gspca_dev);\r\ngpio_set(sd, SQ930_GPIO_EXTRA2 | SQ930_GPIO_RSTBAR, 0x00ff);\r\nmsleep(70);\r\nreg_w(gspca_dev, SQ930_CTRL_CAP_STOP, 0x0000);\r\ngpio_set(sd, 0x7f, 0x00ff);\r\nsend_start(gspca_dev);\r\ngpio_set(sd, SQ930_GPIO_EXTRA2 | SQ930_GPIO_RSTBAR, 0x00ff);\r\ngoto out;\r\ncase SENSOR_LZ24BP:\r\nucbus_write(gspca_dev, lz24bp_start_0,\r\nARRAY_SIZE(lz24bp_start_0),\r\n8);\r\nif (sd->type != Creative_live_motion)\r\nucbus_write(gspca_dev, lz24bp_start_1_gen,\r\nARRAY_SIZE(lz24bp_start_1_gen),\r\n5);\r\nelse\r\nucbus_write(gspca_dev, lz24bp_start_1_clm,\r\nARRAY_SIZE(lz24bp_start_1_clm),\r\n5);\r\nucbus_write(gspca_dev, lz24bp_start_2,\r\nARRAY_SIZE(lz24bp_start_2),\r\n6);\r\nmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nlz24bp_ppl(sd, mode == 1 ? 0x0564 : 0x0310);\r\nmsleep(10);\r\nbreak;\r\ncase SENSOR_MI0360:\r\nucbus_write(gspca_dev, mi0360_start_0,\r\nARRAY_SIZE(mi0360_start_0),\r\n8);\r\ni2c_write(sd, mi0360_init_23,\r\nARRAY_SIZE(mi0360_init_23));\r\ni2c_write(sd, mi0360_init_24,\r\nARRAY_SIZE(mi0360_init_24));\r\ni2c_write(sd, mi0360_init_25,\r\nARRAY_SIZE(mi0360_init_25));\r\nucbus_write(gspca_dev, mi0360_start_1,\r\nARRAY_SIZE(mi0360_start_1),\r\n5);\r\ni2c_write(sd, mi0360_start_2,\r\nARRAY_SIZE(mi0360_start_2));\r\ni2c_write(sd, mi0360_start_3,\r\nARRAY_SIZE(mi0360_start_3));\r\nsend_start(gspca_dev);\r\nmsleep(60);\r\nsend_stop(gspca_dev);\r\ni2c_write(sd,\r\nmi0360_start_4, ARRAY_SIZE(mi0360_start_4));\r\nbreak;\r\ndefault:\r\nucbus_write(gspca_dev, mi0360_start_0,\r\nARRAY_SIZE(mi0360_start_0),\r\n8);\r\ni2c_write(sd, mt9v111_init_0,\r\nARRAY_SIZE(mt9v111_init_0));\r\ni2c_write(sd, mt9v111_init_1,\r\nARRAY_SIZE(mt9v111_init_1));\r\ni2c_write(sd, mt9v111_init_2,\r\nARRAY_SIZE(mt9v111_init_2));\r\nucbus_write(gspca_dev, mt9v111_start_1,\r\nARRAY_SIZE(mt9v111_start_1),\r\n5);\r\ni2c_write(sd, mt9v111_init_3,\r\nARRAY_SIZE(mt9v111_init_3));\r\ni2c_write(sd, mt9v111_init_4,\r\nARRAY_SIZE(mt9v111_init_4));\r\nbreak;\r\n}\r\nsend_start(gspca_dev);\r\nout:\r\nmsleep(1000);\r\nif (sd->sensor == SENSOR_MT9V111)\r\ngpio_set(sd, SQ930_GPIO_DFL_LED, SQ930_GPIO_DFL_LED);\r\nsd->do_ctrl = 1;\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_MT9V111)\r\ngpio_set(sd, 0, SQ930_GPIO_DFL_LED);\r\nsend_stop(gspca_dev);\r\n}\r\nstatic void sd_dq_callback(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint ret;\r\nif (!sd->do_ctrl || gspca_dev->cam.bulk_nurbs != 0)\r\nreturn;\r\nsd->do_ctrl = 0;\r\nsetexposure(gspca_dev, v4l2_ctrl_g_ctrl(sd->exposure),\r\nv4l2_ctrl_g_ctrl(sd->gain));\r\ngspca_dev->cam.bulk_nurbs = 1;\r\nret = usb_submit_urb(gspca_dev->urb[0], GFP_ATOMIC);\r\nif (ret < 0)\r\npr_err("sd_dq_callback() err %d\n", ret);\r\nmsleep(100);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->do_ctrl)\r\ngspca_dev->cam.bulk_nurbs = 0;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len - 8);\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_EXPOSURE:\r\nsetexposure(gspca_dev, ctrl->val, sd->gain->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 2);\r\nsd->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 1, 0xfff, 1, 0x356);\r\nsd->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 1, 255, 1, 0x8d);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nv4l2_ctrl_cluster(2, &sd->exposure);\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
