static int elan_i2c_read_block(struct i2c_client *client,\r\nu16 reg, u8 *val, u16 len)\r\n{\r\n__le16 buf[] = {\r\ncpu_to_le16(reg),\r\n};\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = client->flags & I2C_M_TEN,\r\n.len = sizeof(buf),\r\n.buf = (u8 *)buf,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = (client->flags & I2C_M_TEN) | I2C_M_RD,\r\n.len = len,\r\n.buf = val,\r\n}\r\n};\r\nint ret;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nreturn ret == ARRAY_SIZE(msgs) ? 0 : (ret < 0 ? ret : -EIO);\r\n}\r\nstatic int elan_i2c_read_cmd(struct i2c_client *client, u16 reg, u8 *val)\r\n{\r\nint retval;\r\nretval = elan_i2c_read_block(client, reg, val, ETP_I2C_INF_LENGTH);\r\nif (retval < 0) {\r\ndev_err(&client->dev, "reading cmd (0x%04x) fail.\n", reg);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_write_cmd(struct i2c_client *client, u16 reg, u16 cmd)\r\n{\r\n__le16 buf[] = {\r\ncpu_to_le16(reg),\r\ncpu_to_le16(cmd),\r\n};\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = client->flags & I2C_M_TEN,\r\n.len = sizeof(buf),\r\n.buf = (u8 *)buf,\r\n};\r\nint ret;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret != 1) {\r\nif (ret >= 0)\r\nret = -EIO;\r\ndev_err(&client->dev, "writing cmd (0x%04x) failed: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_initialize(struct i2c_client *client)\r\n{\r\nstruct device *dev = &client->dev;\r\nint error;\r\nu8 val[256];\r\nerror = elan_i2c_write_cmd(client, ETP_I2C_STAND_CMD, ETP_I2C_RESET);\r\nif (error) {\r\ndev_err(dev, "device reset failed: %d\n", error);\r\nreturn error;\r\n}\r\nmsleep(100);\r\nerror = i2c_master_recv(client, val, ETP_I2C_INF_LENGTH);\r\nif (error < 0) {\r\ndev_err(dev, "failed to read reset response: %d\n", error);\r\nreturn error;\r\n}\r\nerror = elan_i2c_read_block(client, ETP_I2C_DESC_CMD,\r\nval, ETP_I2C_DESC_LENGTH);\r\nif (error) {\r\ndev_err(dev, "cannot get device descriptor: %d\n", error);\r\nreturn error;\r\n}\r\nerror = elan_i2c_read_block(client, ETP_I2C_REPORT_DESC_CMD,\r\nval, ETP_I2C_REPORT_DESC_LENGTH);\r\nif (error) {\r\ndev_err(dev, "fetching report descriptor failed.: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_sleep_control(struct i2c_client *client, bool sleep)\r\n{\r\nreturn elan_i2c_write_cmd(client, ETP_I2C_STAND_CMD,\r\nsleep ? ETP_I2C_SLEEP : ETP_I2C_WAKE_UP);\r\n}\r\nstatic int elan_i2c_power_control(struct i2c_client *client, bool enable)\r\n{\r\nu8 val[2];\r\nu16 reg;\r\nint error;\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_POWER_CMD, val);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to read current power state: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreg = le16_to_cpup((__le16 *)val);\r\nif (enable)\r\nreg &= ~ETP_DISABLE_POWER;\r\nelse\r\nreg |= ETP_DISABLE_POWER;\r\nerror = elan_i2c_write_cmd(client, ETP_I2C_POWER_CMD, reg);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to write current power state: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_set_mode(struct i2c_client *client, u8 mode)\r\n{\r\nreturn elan_i2c_write_cmd(client, ETP_I2C_SET_CMD, mode);\r\n}\r\nstatic int elan_i2c_calibrate(struct i2c_client *client)\r\n{\r\nreturn elan_i2c_write_cmd(client, ETP_I2C_CALIBRATE_CMD, 1);\r\n}\r\nstatic int elan_i2c_calibrate_result(struct i2c_client *client, u8 *val)\r\n{\r\nreturn elan_i2c_read_block(client, ETP_I2C_CALIBRATE_CMD, val, 1);\r\n}\r\nstatic int elan_i2c_get_baseline_data(struct i2c_client *client,\r\nbool max_baseline, u8 *value)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = elan_i2c_read_cmd(client,\r\nmax_baseline ? ETP_I2C_MAX_BASELINE_CMD :\r\nETP_I2C_MIN_BASELINE_CMD,\r\nval);\r\nif (error)\r\nreturn error;\r\n*value = le16_to_cpup((__le16 *)val);\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_get_version(struct i2c_client *client,\r\nbool iap, u8 *version)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = elan_i2c_read_cmd(client,\r\niap ? ETP_I2C_IAP_VERSION_CMD :\r\nETP_I2C_FW_VERSION_CMD,\r\nval);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get %s version: %d\n",\r\niap ? "IAP" : "FW", error);\r\nreturn error;\r\n}\r\n*version = val[0];\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_get_sm_version(struct i2c_client *client,\r\nu8 *ic_type, u8 *version)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_SM_VERSION_CMD, val);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get SM version: %d\n", error);\r\nreturn error;\r\n}\r\n*version = val[0];\r\n*ic_type = val[1];\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_get_product_id(struct i2c_client *client, u16 *id)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_UNIQUEID_CMD, val);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get product ID: %d\n", error);\r\nreturn error;\r\n}\r\n*id = le16_to_cpup((__le16 *)val);\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_get_checksum(struct i2c_client *client,\r\nbool iap, u16 *csum)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = elan_i2c_read_cmd(client,\r\niap ? ETP_I2C_IAP_CHECKSUM_CMD :\r\nETP_I2C_FW_CHECKSUM_CMD,\r\nval);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get %s checksum: %d\n",\r\niap ? "IAP" : "FW", error);\r\nreturn error;\r\n}\r\n*csum = le16_to_cpup((__le16 *)val);\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_get_max(struct i2c_client *client,\r\nunsigned int *max_x, unsigned int *max_y)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_MAX_X_AXIS_CMD, val);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get X dimension: %d\n", error);\r\nreturn error;\r\n}\r\n*max_x = le16_to_cpup((__le16 *)val) & 0x0fff;\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_MAX_Y_AXIS_CMD, val);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get Y dimension: %d\n", error);\r\nreturn error;\r\n}\r\n*max_y = le16_to_cpup((__le16 *)val) & 0x0fff;\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_get_resolution(struct i2c_client *client,\r\nu8 *hw_res_x, u8 *hw_res_y)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_RESOLUTION_CMD, val);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get resolution: %d\n", error);\r\nreturn error;\r\n}\r\n*hw_res_x = val[0];\r\n*hw_res_y = val[1];\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_get_num_traces(struct i2c_client *client,\r\nunsigned int *x_traces,\r\nunsigned int *y_traces)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_XY_TRACENUM_CMD, val);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get trace info: %d\n", error);\r\nreturn error;\r\n}\r\n*x_traces = val[0];\r\n*y_traces = val[1];\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_get_pressure_adjustment(struct i2c_client *client,\r\nint *adjustment)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_PRESSURE_CMD, val);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get pressure format: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif ((val[0] >> 4) & 0x1)\r\n*adjustment = 0;\r\nelse\r\n*adjustment = ETP_PRESSURE_OFFSET;\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_iap_get_mode(struct i2c_client *client, enum tp_mode *mode)\r\n{\r\nint error;\r\nu16 constant;\r\nu8 val[3];\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_IAP_CTRL_CMD, val);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to read iap control register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nconstant = le16_to_cpup((__le16 *)val);\r\ndev_dbg(&client->dev, "iap control reg: 0x%04x.\n", constant);\r\n*mode = (constant & ETP_I2C_MAIN_MODE_ON) ? MAIN_MODE : IAP_MODE;\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_iap_reset(struct i2c_client *client)\r\n{\r\nint error;\r\nerror = elan_i2c_write_cmd(client, ETP_I2C_IAP_RESET_CMD,\r\nETP_I2C_IAP_RESET);\r\nif (error) {\r\ndev_err(&client->dev, "cannot reset IC: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_set_flash_key(struct i2c_client *client)\r\n{\r\nint error;\r\nerror = elan_i2c_write_cmd(client, ETP_I2C_IAP_CMD,\r\nETP_I2C_IAP_PASSWORD);\r\nif (error) {\r\ndev_err(&client->dev, "cannot set flash key: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_prepare_fw_update(struct i2c_client *client)\r\n{\r\nstruct device *dev = &client->dev;\r\nint error;\r\nenum tp_mode mode;\r\nu8 val[3];\r\nu16 password;\r\nerror = elan_i2c_iap_get_mode(client, &mode);\r\nif (error)\r\nreturn error;\r\nif (mode == IAP_MODE) {\r\nerror = elan_i2c_iap_reset(client);\r\nif (error)\r\nreturn error;\r\nmsleep(30);\r\n}\r\nerror = elan_i2c_set_flash_key(client);\r\nif (error)\r\nreturn error;\r\nmsleep(mode == MAIN_MODE ? 100 : 30);\r\nerror = elan_i2c_iap_get_mode(client, &mode);\r\nif (error)\r\nreturn error;\r\nif (mode == MAIN_MODE) {\r\ndev_err(dev, "wrong mode: %d\n", mode);\r\nreturn -EIO;\r\n}\r\nerror = elan_i2c_set_flash_key(client);\r\nif (error)\r\nreturn error;\r\nmsleep(30);\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_IAP_CMD, val);\r\nif (error) {\r\ndev_err(dev, "cannot read iap password: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\npassword = le16_to_cpup((__le16 *)val);\r\nif (password != ETP_I2C_IAP_PASSWORD) {\r\ndev_err(dev, "wrong iap password: 0x%X\n", password);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_write_fw_block(struct i2c_client *client,\r\nconst u8 *page, u16 checksum, int idx)\r\n{\r\nstruct device *dev = &client->dev;\r\nu8 page_store[ETP_FW_PAGE_SIZE + 4];\r\nu8 val[3];\r\nu16 result;\r\nint ret, error;\r\npage_store[0] = ETP_I2C_IAP_REG_L;\r\npage_store[1] = ETP_I2C_IAP_REG_H;\r\nmemcpy(&page_store[2], page, ETP_FW_PAGE_SIZE);\r\nput_unaligned_le16(checksum, &page_store[ETP_FW_PAGE_SIZE + 2]);\r\nret = i2c_master_send(client, page_store, sizeof(page_store));\r\nif (ret != sizeof(page_store)) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(dev, "Failed to write page %d: %d\n", idx, error);\r\nreturn error;\r\n}\r\nmsleep(20);\r\nerror = elan_i2c_read_cmd(client, ETP_I2C_IAP_CTRL_CMD, val);\r\nif (error) {\r\ndev_err(dev, "Failed to read IAP write result: %d\n", error);\r\nreturn error;\r\n}\r\nresult = le16_to_cpup((__le16 *)val);\r\nif (result & (ETP_FW_IAP_PAGE_ERR | ETP_FW_IAP_INTF_ERR)) {\r\ndev_err(dev, "IAP reports failed write: %04hx\n",\r\nresult);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_finish_fw_update(struct i2c_client *client,\r\nstruct completion *completion)\r\n{\r\nstruct device *dev = &client->dev;\r\nlong ret;\r\nint error;\r\nint len;\r\nu8 buffer[ETP_I2C_INF_LENGTH];\r\nreinit_completion(completion);\r\nenable_irq(client->irq);\r\nerror = elan_i2c_write_cmd(client, ETP_I2C_STAND_CMD, ETP_I2C_RESET);\r\nif (!error)\r\nret = wait_for_completion_interruptible_timeout(completion,\r\nmsecs_to_jiffies(300));\r\ndisable_irq(client->irq);\r\nif (error) {\r\ndev_err(dev, "device reset failed: %d\n", error);\r\nreturn error;\r\n} else if (ret == 0) {\r\ndev_err(dev, "timeout waiting for device reset\n");\r\nreturn -ETIMEDOUT;\r\n} else if (ret < 0) {\r\nerror = ret;\r\ndev_err(dev, "error waiting for device reset: %d\n", error);\r\nreturn error;\r\n}\r\nlen = i2c_master_recv(client, buffer, ETP_I2C_INF_LENGTH);\r\nif (len != ETP_I2C_INF_LENGTH) {\r\nerror = len < 0 ? len : -EIO;\r\ndev_err(dev, "failed to read INT signal: %d (%d)\n",\r\nerror, len);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_i2c_get_report(struct i2c_client *client, u8 *report)\r\n{\r\nint len;\r\nlen = i2c_master_recv(client, report, ETP_I2C_REPORT_LEN);\r\nif (len < 0) {\r\ndev_err(&client->dev, "failed to read report data: %d\n", len);\r\nreturn len;\r\n}\r\nif (len != ETP_I2C_REPORT_LEN) {\r\ndev_err(&client->dev,\r\n"wrong report length (%d vs %d expected)\n",\r\nlen, ETP_I2C_REPORT_LEN);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}
