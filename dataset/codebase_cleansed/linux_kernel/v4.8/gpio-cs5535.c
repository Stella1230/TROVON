static void errata_outl(struct cs5535_gpio_chip *chip, u32 val,\r\nunsigned int reg)\r\n{\r\nunsigned long addr = chip->base + 0x80 + reg;\r\nif (reg != GPIO_POSITIVE_EDGE_STS && reg != GPIO_NEGATIVE_EDGE_STS) {\r\nif (val & 0xffff)\r\nval |= (inl(addr) & 0xffff);\r\nelse\r\nval |= (inl(addr) ^ (val >> 16));\r\n}\r\noutl(val, addr);\r\n}\r\nstatic void __cs5535_gpio_set(struct cs5535_gpio_chip *chip, unsigned offset,\r\nunsigned int reg)\r\n{\r\nif (offset < 16)\r\noutl(1 << offset, chip->base + reg);\r\nelse\r\nerrata_outl(chip, 1 << (offset - 16), reg);\r\n}\r\nvoid cs5535_gpio_set(unsigned offset, unsigned int reg)\r\n{\r\nstruct cs5535_gpio_chip *chip = &cs5535_gpio_chip;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\n__cs5535_gpio_set(chip, offset, reg);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic void __cs5535_gpio_clear(struct cs5535_gpio_chip *chip, unsigned offset,\r\nunsigned int reg)\r\n{\r\nif (offset < 16)\r\noutl(1 << (offset + 16), chip->base + reg);\r\nelse\r\nerrata_outl(chip, 1 << offset, reg);\r\n}\r\nvoid cs5535_gpio_clear(unsigned offset, unsigned int reg)\r\n{\r\nstruct cs5535_gpio_chip *chip = &cs5535_gpio_chip;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\n__cs5535_gpio_clear(chip, offset, reg);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nint cs5535_gpio_isset(unsigned offset, unsigned int reg)\r\n{\r\nstruct cs5535_gpio_chip *chip = &cs5535_gpio_chip;\r\nunsigned long flags;\r\nlong val;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nif (offset < 16)\r\nval = inl(chip->base + reg);\r\nelse {\r\nval = inl(chip->base + 0x80 + reg);\r\noffset -= 16;\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn (val & (1 << offset)) ? 1 : 0;\r\n}\r\nint cs5535_gpio_set_irq(unsigned group, unsigned irq)\r\n{\r\nuint32_t lo, hi;\r\nif (group > 7 || irq > 15)\r\nreturn -EINVAL;\r\nrdmsr(MSR_PIC_ZSEL_HIGH, lo, hi);\r\nlo &= ~(0xF << (group * 4));\r\nlo |= (irq & 0xF) << (group * 4);\r\nwrmsr(MSR_PIC_ZSEL_HIGH, lo, hi);\r\nreturn 0;\r\n}\r\nvoid cs5535_gpio_setup_event(unsigned offset, int pair, int pme)\r\n{\r\nstruct cs5535_gpio_chip *chip = &cs5535_gpio_chip;\r\nuint32_t shift = (offset % 8) * 4;\r\nunsigned long flags;\r\nuint32_t val;\r\nif (offset >= 24)\r\noffset = GPIO_MAP_W;\r\nelse if (offset >= 16)\r\noffset = GPIO_MAP_Z;\r\nelse if (offset >= 8)\r\noffset = GPIO_MAP_Y;\r\nelse\r\noffset = GPIO_MAP_X;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nval = inl(chip->base + offset);\r\nval &= ~(0xF << shift);\r\nval |= ((pair & 7) << shift);\r\nif (pme)\r\nval |= (1 << (shift + 3));\r\noutl(val, chip->base + offset);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int chip_gpio_request(struct gpio_chip *c, unsigned offset)\r\n{\r\nstruct cs5535_gpio_chip *chip = gpiochip_get_data(c);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nif ((mask & (1 << offset)) == 0) {\r\ndev_info(&chip->pdev->dev,\r\n"pin %u is not available (check mask)\n", offset);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn -EINVAL;\r\n}\r\n__cs5535_gpio_clear(chip, offset, GPIO_OUTPUT_AUX1);\r\n__cs5535_gpio_clear(chip, offset, GPIO_OUTPUT_AUX2);\r\n__cs5535_gpio_clear(chip, offset, GPIO_INPUT_AUX1);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int chip_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn cs5535_gpio_isset(offset, GPIO_READ_BACK);\r\n}\r\nstatic void chip_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nif (val)\r\ncs5535_gpio_set(offset, GPIO_OUTPUT_VAL);\r\nelse\r\ncs5535_gpio_clear(offset, GPIO_OUTPUT_VAL);\r\n}\r\nstatic int chip_direction_input(struct gpio_chip *c, unsigned offset)\r\n{\r\nstruct cs5535_gpio_chip *chip = gpiochip_get_data(c);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\n__cs5535_gpio_set(chip, offset, GPIO_INPUT_ENABLE);\r\n__cs5535_gpio_clear(chip, offset, GPIO_OUTPUT_ENABLE);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int chip_direction_output(struct gpio_chip *c, unsigned offset, int val)\r\n{\r\nstruct cs5535_gpio_chip *chip = gpiochip_get_data(c);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\n__cs5535_gpio_set(chip, offset, GPIO_INPUT_ENABLE);\r\n__cs5535_gpio_set(chip, offset, GPIO_OUTPUT_ENABLE);\r\nif (val)\r\n__cs5535_gpio_set(chip, offset, GPIO_OUTPUT_VAL);\r\nelse\r\n__cs5535_gpio_clear(chip, offset, GPIO_OUTPUT_VAL);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cs5535_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint err = -EIO;\r\nulong mask_orig = mask;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "can't fetch device resource info\n");\r\nreturn err;\r\n}\r\nif (!devm_request_region(&pdev->dev, res->start, resource_size(res),\r\npdev->name)) {\r\ndev_err(&pdev->dev, "can't request region\n");\r\nreturn err;\r\n}\r\ncs5535_gpio_chip.base = res->start;\r\ncs5535_gpio_chip.pdev = pdev;\r\nspin_lock_init(&cs5535_gpio_chip.lock);\r\ndev_info(&pdev->dev, "reserved resource region %pR\n", res);\r\nmask &= 0x1F7FFFFF;\r\nmask &= ~(1 << 28);\r\nif (mask_orig != mask)\r\ndev_info(&pdev->dev, "mask changed from 0x%08lX to 0x%08lX\n",\r\nmask_orig, mask);\r\nerr = devm_gpiochip_add_data(&pdev->dev, &cs5535_gpio_chip.chip,\r\n&cs5535_gpio_chip);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}
