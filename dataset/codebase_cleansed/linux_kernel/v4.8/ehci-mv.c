static void ehci_clock_enable(struct ehci_hcd_mv *ehci_mv)\r\n{\r\nclk_prepare_enable(ehci_mv->clk);\r\n}\r\nstatic void ehci_clock_disable(struct ehci_hcd_mv *ehci_mv)\r\n{\r\nclk_disable_unprepare(ehci_mv->clk);\r\n}\r\nstatic int mv_ehci_enable(struct ehci_hcd_mv *ehci_mv)\r\n{\r\nint retval;\r\nehci_clock_enable(ehci_mv);\r\nif (ehci_mv->pdata->phy_init) {\r\nretval = ehci_mv->pdata->phy_init(ehci_mv->phy_regs);\r\nif (retval)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mv_ehci_disable(struct ehci_hcd_mv *ehci_mv)\r\n{\r\nif (ehci_mv->pdata->phy_deinit)\r\nehci_mv->pdata->phy_deinit(ehci_mv->phy_regs);\r\nehci_clock_disable(ehci_mv);\r\n}\r\nstatic int mv_ehci_reset(struct usb_hcd *hcd)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nstruct ehci_hcd_mv *ehci_mv = dev_get_drvdata(dev);\r\nint retval;\r\nif (ehci_mv == NULL) {\r\ndev_err(dev, "Can not find private ehci data\n");\r\nreturn -ENODEV;\r\n}\r\nhcd->has_tt = 1;\r\nretval = ehci_setup(hcd);\r\nif (retval)\r\ndev_err(dev, "ehci_setup failed %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic int mv_ehci_probe(struct platform_device *pdev)\r\n{\r\nstruct mv_usb_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci;\r\nstruct ehci_hcd_mv *ehci_mv;\r\nstruct resource *r;\r\nint retval = -ENODEV;\r\nu32 offset;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "missing platform_data\n");\r\nreturn -ENODEV;\r\n}\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nhcd = usb_create_hcd(&mv_ehci_hc_driver, &pdev->dev, "mv ehci");\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nehci_mv = devm_kzalloc(&pdev->dev, sizeof(*ehci_mv), GFP_KERNEL);\r\nif (ehci_mv == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_put_hcd;\r\n}\r\nplatform_set_drvdata(pdev, ehci_mv);\r\nehci_mv->pdata = pdata;\r\nehci_mv->hcd = hcd;\r\nehci_mv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ehci_mv->clk)) {\r\ndev_err(&pdev->dev, "error getting clock\n");\r\nretval = PTR_ERR(ehci_mv->clk);\r\ngoto err_put_hcd;\r\n}\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phyregs");\r\nehci_mv->phy_regs = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(ehci_mv->phy_regs)) {\r\nretval = PTR_ERR(ehci_mv->phy_regs);\r\ngoto err_put_hcd;\r\n}\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "capregs");\r\nehci_mv->cap_regs = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(ehci_mv->cap_regs)) {\r\nretval = PTR_ERR(ehci_mv->cap_regs);\r\ngoto err_put_hcd;\r\n}\r\nretval = mv_ehci_enable(ehci_mv);\r\nif (retval) {\r\ndev_err(&pdev->dev, "init phy error %d\n", retval);\r\ngoto err_put_hcd;\r\n}\r\noffset = readl(ehci_mv->cap_regs) & CAPLENGTH_MASK;\r\nehci_mv->op_regs =\r\n(void __iomem *) ((unsigned long) ehci_mv->cap_regs + offset);\r\nhcd->rsrc_start = r->start;\r\nhcd->rsrc_len = resource_size(r);\r\nhcd->regs = ehci_mv->op_regs;\r\nhcd->irq = platform_get_irq(pdev, 0);\r\nif (!hcd->irq) {\r\ndev_err(&pdev->dev, "Cannot get irq.");\r\nretval = -ENODEV;\r\ngoto err_disable_clk;\r\n}\r\nehci = hcd_to_ehci(hcd);\r\nehci->caps = (struct ehci_caps *) ehci_mv->cap_regs;\r\nehci_mv->mode = pdata->mode;\r\nif (ehci_mv->mode == MV_USB_MODE_OTG) {\r\nehci_mv->otg = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);\r\nif (IS_ERR(ehci_mv->otg)) {\r\nretval = PTR_ERR(ehci_mv->otg);\r\nif (retval == -ENXIO)\r\ndev_info(&pdev->dev, "MV_USB_MODE_OTG "\r\n"must have CONFIG_USB_PHY enabled\n");\r\nelse\r\ndev_err(&pdev->dev,\r\n"unable to find transceiver\n");\r\ngoto err_disable_clk;\r\n}\r\nretval = otg_set_host(ehci_mv->otg->otg, &hcd->self);\r\nif (retval < 0) {\r\ndev_err(&pdev->dev,\r\n"unable to register with transceiver\n");\r\nretval = -ENODEV;\r\ngoto err_disable_clk;\r\n}\r\nmv_ehci_disable(ehci_mv);\r\n} else {\r\nif (pdata->set_vbus)\r\npdata->set_vbus(1);\r\nretval = usb_add_hcd(hcd, hcd->irq, IRQF_SHARED);\r\nif (retval) {\r\ndev_err(&pdev->dev,\r\n"failed to add hcd with err %d\n", retval);\r\ngoto err_set_vbus;\r\n}\r\ndevice_wakeup_enable(hcd->self.controller);\r\n}\r\nif (pdata->private_init)\r\npdata->private_init(ehci_mv->op_regs, ehci_mv->phy_regs);\r\ndev_info(&pdev->dev,\r\n"successful find EHCI device with regs 0x%p irq %d"\r\n" working in %s mode\n", hcd->regs, hcd->irq,\r\nehci_mv->mode == MV_USB_MODE_OTG ? "OTG" : "Host");\r\nreturn 0;\r\nerr_set_vbus:\r\nif (pdata->set_vbus)\r\npdata->set_vbus(0);\r\nerr_disable_clk:\r\nmv_ehci_disable(ehci_mv);\r\nerr_put_hcd:\r\nusb_put_hcd(hcd);\r\nreturn retval;\r\n}\r\nstatic int mv_ehci_remove(struct platform_device *pdev)\r\n{\r\nstruct ehci_hcd_mv *ehci_mv = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = ehci_mv->hcd;\r\nif (hcd->rh_registered)\r\nusb_remove_hcd(hcd);\r\nif (!IS_ERR_OR_NULL(ehci_mv->otg))\r\notg_set_host(ehci_mv->otg->otg, NULL);\r\nif (ehci_mv->mode == MV_USB_MODE_HOST) {\r\nif (ehci_mv->pdata->set_vbus)\r\nehci_mv->pdata->set_vbus(0);\r\nmv_ehci_disable(ehci_mv);\r\n}\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic void mv_ehci_shutdown(struct platform_device *pdev)\r\n{\r\nstruct ehci_hcd_mv *ehci_mv = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = ehci_mv->hcd;\r\nif (!hcd->rh_registered)\r\nreturn;\r\nif (hcd->driver->shutdown)\r\nhcd->driver->shutdown(hcd);\r\n}
