static inline int not_useful(void *p, int map)\r\n{\r\nunsigned long pv=(unsigned long)p;\r\npv &= 3;\r\nif(map & (1<<pv))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic unsigned long nubus_get_rom(unsigned char **ptr, int len, int map)\r\n{\r\nunsigned long v = 0;\r\nunsigned char *p = *ptr;\r\nwhile(len)\r\n{\r\nv <<= 8;\r\nwhile(not_useful(p,map))\r\np++;\r\nv |= *p++;\r\nlen--;\r\n}\r\n*ptr = p;\r\nreturn v;\r\n}\r\nstatic void nubus_rewind(unsigned char **ptr, int len, int map)\r\n{\r\nunsigned char *p=*ptr;\r\nif(len > 65536)\r\nprintk(KERN_ERR "rewind of 0x%08x!\n", len);\r\nwhile(len)\r\n{\r\ndo\r\n{\r\np--;\r\n}\r\nwhile(not_useful(p, map));\r\nlen--;\r\n}\r\n*ptr=p;\r\n}\r\nstatic void nubus_advance(unsigned char **ptr, int len, int map)\r\n{\r\nunsigned char *p = *ptr;\r\nif(len>65536)\r\nprintk(KERN_ERR "advance of 0x%08x!\n", len);\r\nwhile(len)\r\n{\r\nwhile(not_useful(p,map))\r\np++;\r\np++;\r\nlen--;\r\n}\r\n*ptr = p;\r\n}\r\nstatic void nubus_move(unsigned char **ptr, int len, int map)\r\n{\r\nif(len > 0)\r\nnubus_advance(ptr, len, map);\r\nelse if(len < 0)\r\nnubus_rewind(ptr, -len, map);\r\n}\r\nstatic inline long nubus_expand32(long foo)\r\n{\r\nif(foo & 0x00800000)\r\nfoo |= 0xFF000000;\r\nreturn foo;\r\n}\r\nstatic inline void *nubus_rom_addr(int slot)\r\n{\r\nreturn (void *)(0xF1000000+(slot<<24));\r\n}\r\nstatic unsigned char *nubus_dirptr(const struct nubus_dirent *nd)\r\n{\r\nunsigned char *p = nd->base;\r\nnubus_move(&p, nubus_expand32(nd->data), nd->mask);\r\nreturn p;\r\n}\r\nvoid nubus_get_rsrc_mem(void *dest, const struct nubus_dirent* dirent,\r\nint len)\r\n{\r\nunsigned char *t = (unsigned char *)dest;\r\nunsigned char *p = nubus_dirptr(dirent);\r\nwhile(len)\r\n{\r\n*t++ = nubus_get_rom(&p, 1, dirent->mask);\r\nlen--;\r\n}\r\n}\r\nvoid nubus_get_rsrc_str(void *dest, const struct nubus_dirent* dirent,\r\nint len)\r\n{\r\nunsigned char *t=(unsigned char *)dest;\r\nunsigned char *p = nubus_dirptr(dirent);\r\nwhile(len)\r\n{\r\n*t = nubus_get_rom(&p, 1, dirent->mask);\r\nif(!*t++)\r\nbreak;\r\nlen--;\r\n}\r\n}\r\nint nubus_get_root_dir(const struct nubus_board* board,\r\nstruct nubus_dir* dir)\r\n{\r\ndir->ptr = dir->base = board->directory;\r\ndir->done = 0;\r\ndir->mask = board->lanes;\r\nreturn 0;\r\n}\r\nint nubus_get_func_dir(const struct nubus_dev* dev,\r\nstruct nubus_dir* dir)\r\n{\r\ndir->ptr = dir->base = dev->directory;\r\ndir->done = 0;\r\ndir->mask = dev->board->lanes;\r\nreturn 0;\r\n}\r\nint nubus_get_board_dir(const struct nubus_board* board,\r\nstruct nubus_dir* dir)\r\n{\r\nstruct nubus_dirent ent;\r\ndir->ptr = dir->base = board->directory;\r\ndir->done = 0;\r\ndir->mask = board->lanes;\r\nif (nubus_readdir(dir, &ent) == -1)\r\nreturn -1;\r\nif (nubus_get_subdir(&ent, dir) == -1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint nubus_get_subdir(const struct nubus_dirent *ent,\r\nstruct nubus_dir *dir)\r\n{\r\ndir->ptr = dir->base = nubus_dirptr(ent);\r\ndir->done = 0;\r\ndir->mask = ent->mask;\r\nreturn 0;\r\n}\r\nint nubus_readdir(struct nubus_dir *nd, struct nubus_dirent *ent)\r\n{\r\nu32 resid;\r\nif (nd->done)\r\nreturn -1;\r\nent->base = nd->ptr;\r\nresid = nubus_get_rom(&nd->ptr, 4, nd->mask);\r\nif((resid&0xff000000) == 0xff000000)\r\n{\r\nnd->done = 1;\r\nreturn -1;\r\n}\r\nent->type = resid >> 24;\r\nent->data = resid & 0xffffff;\r\nent->mask = nd->mask;\r\nreturn 0;\r\n}\r\nint nubus_rewinddir(struct nubus_dir* dir)\r\n{\r\ndir->ptr = dir->base;\r\nreturn 0;\r\n}\r\nstruct nubus_dev*\r\nnubus_find_device(unsigned short category,\r\nunsigned short type,\r\nunsigned short dr_hw,\r\nunsigned short dr_sw,\r\nconst struct nubus_dev* from)\r\n{\r\nstruct nubus_dev* itor =\r\nfrom ? from->next : nubus_devices;\r\nwhile (itor) {\r\nif (itor->category == category\r\n&& itor->type == type\r\n&& itor->dr_hw == dr_hw\r\n&& itor->dr_sw == dr_sw)\r\nreturn itor;\r\nitor = itor->next;\r\n}\r\nreturn NULL;\r\n}\r\nstruct nubus_dev*\r\nnubus_find_type(unsigned short category,\r\nunsigned short type,\r\nconst struct nubus_dev* from)\r\n{\r\nstruct nubus_dev* itor =\r\nfrom ? from->next : nubus_devices;\r\nwhile (itor) {\r\nif (itor->category == category\r\n&& itor->type == type)\r\nreturn itor;\r\nitor = itor->next;\r\n}\r\nreturn NULL;\r\n}\r\nstruct nubus_dev*\r\nnubus_find_slot(unsigned int slot,\r\nconst struct nubus_dev* from)\r\n{\r\nstruct nubus_dev* itor =\r\nfrom ? from->next : nubus_devices;\r\nwhile (itor) {\r\nif (itor->board->slot == slot)\r\nreturn itor;\r\nitor = itor->next;\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nnubus_find_rsrc(struct nubus_dir* dir, unsigned char rsrc_type,\r\nstruct nubus_dirent* ent)\r\n{\r\nwhile (nubus_readdir(dir, ent) != -1) {\r\nif (ent->type == rsrc_type)\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int __init nubus_show_display_resource(struct nubus_dev* dev,\r\nconst struct nubus_dirent* ent)\r\n{\r\nswitch (ent->type) {\r\ncase NUBUS_RESID_GAMMADIR:\r\nprintk(KERN_INFO " gamma directory offset: 0x%06x\n", ent->data);\r\nbreak;\r\ncase 0x0080 ... 0x0085:\r\nprintk(KERN_INFO " mode %02X info offset: 0x%06x\n",\r\nent->type, ent->data);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO " unknown resource %02X, data 0x%06x\n",\r\nent->type, ent->data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init nubus_show_network_resource(struct nubus_dev* dev,\r\nconst struct nubus_dirent* ent)\r\n{\r\nswitch (ent->type) {\r\ncase NUBUS_RESID_MAC_ADDRESS:\r\n{\r\nchar addr[6];\r\nint i;\r\nnubus_get_rsrc_mem(addr, ent, 6);\r\nprintk(KERN_INFO " MAC address: ");\r\nfor (i = 0; i < 6; i++)\r\nprintk("%02x%s", addr[i] & 0xff,\r\ni == 5 ? "" : ":");\r\nprintk("\n");\r\nbreak;\r\n}\r\ndefault:\r\nprintk(KERN_INFO " unknown resource %02X, data 0x%06x\n",\r\nent->type, ent->data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init nubus_show_cpu_resource(struct nubus_dev* dev,\r\nconst struct nubus_dirent* ent)\r\n{\r\nswitch (ent->type) {\r\ncase NUBUS_RESID_MEMINFO:\r\n{\r\nunsigned long meminfo[2];\r\nnubus_get_rsrc_mem(&meminfo, ent, 8);\r\nprintk(KERN_INFO " memory: [ 0x%08lx 0x%08lx ]\n",\r\nmeminfo[0], meminfo[1]);\r\nbreak;\r\n}\r\ncase NUBUS_RESID_ROMINFO:\r\n{\r\nunsigned long rominfo[2];\r\nnubus_get_rsrc_mem(&rominfo, ent, 8);\r\nprintk(KERN_INFO " ROM: [ 0x%08lx 0x%08lx ]\n",\r\nrominfo[0], rominfo[1]);\r\nbreak;\r\n}\r\ndefault:\r\nprintk(KERN_INFO " unknown resource %02X, data 0x%06x\n",\r\nent->type, ent->data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init nubus_show_private_resource(struct nubus_dev* dev,\r\nconst struct nubus_dirent* ent)\r\n{\r\nswitch (dev->category) {\r\ncase NUBUS_CAT_DISPLAY:\r\nnubus_show_display_resource(dev, ent);\r\nbreak;\r\ncase NUBUS_CAT_NETWORK:\r\nnubus_show_network_resource(dev, ent);\r\nbreak;\r\ncase NUBUS_CAT_CPU:\r\nnubus_show_cpu_resource(dev, ent);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO " unknown resource %02X, data 0x%06x\n",\r\nent->type, ent->data);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct nubus_dev* __init\r\nnubus_get_functional_resource(struct nubus_board* board,\r\nint slot,\r\nconst struct nubus_dirent* parent)\r\n{\r\nstruct nubus_dir dir;\r\nstruct nubus_dirent ent;\r\nstruct nubus_dev* dev;\r\nprintk(KERN_INFO " Function 0x%02x:\n", parent->type);\r\nnubus_get_subdir(parent, &dir);\r\nif (slot == 0 && (unsigned long)dir.base % 2)\r\ndir.base += 1;\r\nif (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)\r\nprintk(KERN_DEBUG "nubus_get_functional_resource: parent is 0x%p, dir is 0x%p\n",\r\nparent->base, dir.base);\r\nif ((dev = kzalloc(sizeof(*dev), GFP_ATOMIC)) == NULL)\r\nreturn NULL;\r\ndev->resid = parent->type;\r\ndev->directory = dir.base;\r\ndev->board = board;\r\nwhile (nubus_readdir(&dir, &ent) != -1)\r\n{\r\nswitch(ent.type)\r\n{\r\ncase NUBUS_RESID_TYPE:\r\n{\r\nunsigned short nbtdata[4];\r\nnubus_get_rsrc_mem(nbtdata, &ent, 8);\r\ndev->category = nbtdata[0];\r\ndev->type = nbtdata[1];\r\ndev->dr_sw = nbtdata[2];\r\ndev->dr_hw = nbtdata[3];\r\nprintk(KERN_INFO " type: [cat 0x%x type 0x%x hw 0x%x sw 0x%x]\n",\r\nnbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);\r\nbreak;\r\n}\r\ncase NUBUS_RESID_NAME:\r\n{\r\nnubus_get_rsrc_str(dev->name, &ent, 64);\r\nprintk(KERN_INFO " name: %s\n", dev->name);\r\nbreak;\r\n}\r\ncase NUBUS_RESID_DRVRDIR:\r\n{\r\nstruct nubus_dir drvr_dir;\r\nstruct nubus_dirent drvr_ent;\r\nnubus_get_subdir(&ent, &drvr_dir);\r\nnubus_readdir(&drvr_dir, &drvr_ent);\r\ndev->driver = nubus_dirptr(&drvr_ent);\r\nprintk(KERN_INFO " driver at: 0x%p\n",\r\ndev->driver);\r\nbreak;\r\n}\r\ncase NUBUS_RESID_MINOR_BASEOS:\r\nnubus_get_rsrc_mem(&dev->iobase, &ent, 4);\r\nprintk(KERN_INFO " memory offset: 0x%08lx\n",\r\ndev->iobase);\r\nbreak;\r\ncase NUBUS_RESID_MINOR_LENGTH:\r\nnubus_get_rsrc_mem(&dev->iosize, &ent, 4);\r\nprintk(KERN_INFO " memory length: 0x%08lx\n",\r\ndev->iosize);\r\nbreak;\r\ncase NUBUS_RESID_FLAGS:\r\ndev->flags = ent.data;\r\nprintk(KERN_INFO " flags: 0x%06x\n", dev->flags);\r\nbreak;\r\ncase NUBUS_RESID_HWDEVID:\r\ndev->hwdevid = ent.data;\r\nprintk(KERN_INFO " hwdevid: 0x%06x\n", dev->hwdevid);\r\nbreak;\r\ndefault:\r\nnubus_show_private_resource(dev, &ent);\r\n}\r\n}\r\nreturn dev;\r\n}\r\nstatic int __init nubus_get_vidnames(struct nubus_board* board,\r\nconst struct nubus_dirent* parent)\r\n{\r\nstruct nubus_dir dir;\r\nstruct nubus_dirent ent;\r\nstruct vidmode {\r\nu32 size;\r\nu16 id;\r\nchar name[32];\r\n};\r\nprintk(KERN_INFO " video modes supported:\n");\r\nnubus_get_subdir(parent, &dir);\r\nif (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)\r\nprintk(KERN_DEBUG "nubus_get_vidnames: parent is 0x%p, dir is 0x%p\n",\r\nparent->base, dir.base);\r\nwhile(nubus_readdir(&dir, &ent) != -1)\r\n{\r\nstruct vidmode mode;\r\nu32 size;\r\nnubus_get_rsrc_mem(&size, &ent, 4);\r\nif (size > sizeof(mode) - 1)\r\nsize = sizeof(mode) - 1;\r\nmemset(&mode, 0, sizeof(mode));\r\nnubus_get_rsrc_mem(&mode, &ent, size);\r\nprintk (KERN_INFO " %02X: (%02X) %s\n", ent.type,\r\nmode.id, mode.name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init nubus_get_icon(struct nubus_board* board,\r\nconst struct nubus_dirent* ent)\r\n{\r\nunsigned char icon[128];\r\nint x, y;\r\nnubus_get_rsrc_mem(&icon, ent, 128);\r\nprintk(KERN_INFO " icon:\n");\r\nfor (y = 0; y < 32; y++) {\r\nprintk(KERN_INFO " ");\r\nfor (x = 0; x < 32; x++) {\r\nif (icon[y*4 + x/8]\r\n& (0x80 >> (x%8)))\r\nprintk("*");\r\nelse\r\nprintk(" ");\r\n}\r\nprintk("\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init nubus_get_vendorinfo(struct nubus_board* board,\r\nconst struct nubus_dirent* parent)\r\n{\r\nstruct nubus_dir dir;\r\nstruct nubus_dirent ent;\r\nstatic char* vendor_fields[6] = {"ID", "serial", "revision",\r\n"part", "date", "unknown field"};\r\nprintk(KERN_INFO " vendor info:\n");\r\nnubus_get_subdir(parent, &dir);\r\nif (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)\r\nprintk(KERN_DEBUG "nubus_get_vendorinfo: parent is 0x%p, dir is 0x%p\n",\r\nparent->base, dir.base);\r\nwhile(nubus_readdir(&dir, &ent) != -1)\r\n{\r\nchar name[64];\r\nnubus_get_rsrc_str(name, &ent, 64);\r\nif (ent.type > 5)\r\nent.type = 5;\r\nprintk(KERN_INFO " %s: %s\n",\r\nvendor_fields[ent.type-1], name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init nubus_get_board_resource(struct nubus_board* board, int slot,\r\nconst struct nubus_dirent* parent)\r\n{\r\nstruct nubus_dir dir;\r\nstruct nubus_dirent ent;\r\nnubus_get_subdir(parent, &dir);\r\nif (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)\r\nprintk(KERN_DEBUG "nubus_get_board_resource: parent is 0x%p, dir is 0x%p\n",\r\nparent->base, dir.base);\r\nwhile(nubus_readdir(&dir, &ent) != -1)\r\n{\r\nswitch (ent.type) {\r\ncase NUBUS_RESID_TYPE:\r\n{\r\nunsigned short nbtdata[4];\r\nnubus_get_rsrc_mem(nbtdata, &ent, 8);\r\nprintk(KERN_INFO " type: [cat 0x%x type 0x%x hw 0x%x sw 0x%x]\n",\r\nnbtdata[0], nbtdata[1], nbtdata[2],\r\nnbtdata[3]);\r\nif (nbtdata[0] != 1 || nbtdata[1] != 0 ||\r\nnbtdata[2] != 0 || nbtdata[3] != 0)\r\nprintk(KERN_ERR "this sResource is not a board resource!\n");\r\nbreak;\r\n}\r\ncase NUBUS_RESID_NAME:\r\nnubus_get_rsrc_str(board->name, &ent, 64);\r\nprintk(KERN_INFO " name: %s\n", board->name);\r\nbreak;\r\ncase NUBUS_RESID_ICON:\r\nnubus_get_icon(board, &ent);\r\nbreak;\r\ncase NUBUS_RESID_BOARDID:\r\nprintk(KERN_INFO " board id: 0x%x\n", ent.data);\r\nbreak;\r\ncase NUBUS_RESID_PRIMARYINIT:\r\nprintk(KERN_INFO " primary init offset: 0x%06x\n", ent.data);\r\nbreak;\r\ncase NUBUS_RESID_VENDORINFO:\r\nnubus_get_vendorinfo(board, &ent);\r\nbreak;\r\ncase NUBUS_RESID_FLAGS:\r\nprintk(KERN_INFO " flags: 0x%06x\n", ent.data);\r\nbreak;\r\ncase NUBUS_RESID_HWDEVID:\r\nprintk(KERN_INFO " hwdevid: 0x%06x\n", ent.data);\r\nbreak;\r\ncase NUBUS_RESID_SECONDINIT:\r\nprintk(KERN_INFO " secondary init offset: 0x%06x\n", ent.data);\r\nbreak;\r\ncase NUBUS_RESID_VIDNAMES:\r\nnubus_get_vidnames(board, &ent);\r\nbreak;\r\ncase NUBUS_RESID_VIDMODES:\r\nprintk(KERN_INFO " video mode parameter directory offset: 0x%06x\n",\r\nent.data);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO " unknown resource %02X, data 0x%06x\n",\r\nent.type, ent.data);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init nubus_find_rom_dir(struct nubus_board* board)\r\n{\r\nunsigned char* rp;\r\nunsigned char* romdir;\r\nstruct nubus_dir dir;\r\nstruct nubus_dirent ent;\r\nrp = board->fblock;\r\nnubus_rewind(&rp, 4, board->lanes);\r\nif (nubus_get_rom(&rp, 4, board->lanes) != NUBUS_TEST_PATTERN) {\r\nboard->directory = board->fblock;\r\nnubus_move(&board->directory,\r\nnubus_expand32(board->doffset),\r\nboard->lanes);\r\nreturn;\r\n}\r\nromdir = nubus_rom_addr(board->slot);\r\nnubus_rewind(&romdir, ROM_DIR_OFFSET, board->lanes);\r\ndir.base = dir.ptr = romdir;\r\ndir.done = 0;\r\ndir.mask = board->lanes;\r\nif (nubus_readdir(&dir, &ent) == -1)\r\ngoto badrom;\r\nif (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)\r\nprintk(KERN_INFO "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);\r\nif (nubus_readdir(&dir, &ent) == -1)\r\ngoto badrom;\r\nif (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)\r\nprintk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);\r\nnubus_get_subdir(&ent, &dir);\r\nif (nubus_readdir(&dir, &ent) == -1)\r\ngoto badrom;\r\nif (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)\r\nprintk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);\r\nif (nubus_readdir(&dir, &ent) == -1)\r\ngoto badrom;\r\nif (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)\r\nprintk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);\r\nnubus_get_subdir(&ent, &dir);\r\nboard->directory = dir.base;\r\nreturn;\r\nbadrom:\r\nboard->directory = board->fblock;\r\nnubus_move(&board->directory, nubus_expand32(board->doffset), board->lanes);\r\nprintk(KERN_ERR "nubus_get_rom_dir: ROM weirdness! Notify the developers...\n");\r\n}\r\nstatic struct nubus_board* __init nubus_add_board(int slot, int bytelanes)\r\n{\r\nstruct nubus_board* board;\r\nstruct nubus_board** boardp;\r\nunsigned char *rp;\r\nunsigned long dpat;\r\nstruct nubus_dir dir;\r\nstruct nubus_dirent ent;\r\nrp = nubus_rom_addr(slot);\r\nnubus_rewind(&rp, FORMAT_BLOCK_SIZE, bytelanes);\r\nif ((board = kzalloc(sizeof(*board), GFP_ATOMIC)) == NULL)\r\nreturn NULL;\r\nboard->fblock = rp;\r\nif (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG) {\r\nint i;\r\nprintk(KERN_DEBUG "Slot %X, format block at 0x%p\n",\r\nslot, rp);\r\nprintk(KERN_DEBUG "Format block: ");\r\nfor (i = 0; i < FORMAT_BLOCK_SIZE; i += 4) {\r\nunsigned short foo, bar;\r\nfoo = nubus_get_rom(&rp, 2, bytelanes);\r\nbar = nubus_get_rom(&rp, 2, bytelanes);\r\nprintk("%04x %04x ", foo, bar);\r\n}\r\nprintk("\n");\r\nrp = board->fblock;\r\n}\r\nboard->slot = slot;\r\nboard->slot_addr = (unsigned long) nubus_slot_addr(slot);\r\nboard->doffset = nubus_get_rom(&rp, 4, bytelanes);\r\nboard->rom_length = nubus_get_rom(&rp, 4, bytelanes);\r\nboard->crc = nubus_get_rom(&rp, 4, bytelanes);\r\nboard->rev = nubus_get_rom(&rp, 1, bytelanes);\r\nboard->format = nubus_get_rom(&rp,1, bytelanes);\r\nboard->lanes = bytelanes;\r\nif(!(board->doffset & 0x00FF0000))\r\nprintk(KERN_WARNING "Dodgy doffset!\n");\r\ndpat = nubus_get_rom(&rp, 4, bytelanes);\r\nif(dpat != NUBUS_TEST_PATTERN)\r\nprintk(KERN_WARNING "Wrong test pattern %08lx!\n", dpat);\r\nnubus_find_rom_dir(board);\r\nnubus_get_root_dir(board, &dir);\r\nprintk(KERN_INFO "Slot %X:\n", slot);\r\nif (nubus_readdir(&dir, &ent) == -1) {\r\nprintk(KERN_ERR "Board resource not found!\n");\r\nreturn NULL;\r\n} else {\r\nprintk(KERN_INFO " Board resource:\n");\r\nnubus_get_board_resource(board, slot, &ent);\r\n}\r\nwhile (nubus_readdir(&dir, &ent) != -1) {\r\nstruct nubus_dev* dev;\r\nstruct nubus_dev** devp;\r\ndev = nubus_get_functional_resource(board, slot, &ent);\r\nif (dev == NULL)\r\ncontinue;\r\nif (board->first_dev == NULL)\r\nboard->first_dev = dev;\r\nfor (devp=&nubus_devices; *devp!=NULL; devp=&((*devp)->next))\r\n;\r\n*devp = dev;\r\ndev->next = NULL;\r\n}\r\nfor (boardp=&nubus_boards; *boardp!=NULL; boardp=&((*boardp)->next))\r\n;\r\n*boardp = board;\r\nboard->next = NULL;\r\nreturn board;\r\n}\r\nvoid __init nubus_probe_slot(int slot)\r\n{\r\nunsigned char dp;\r\nunsigned char* rp;\r\nint i;\r\nrp = nubus_rom_addr(slot);\r\nfor(i = 4; i; i--)\r\n{\r\nint card_present;\r\nrp--;\r\ncard_present = hwreg_present(rp);\r\nif (!card_present)\r\ncontinue;\r\nprintk(KERN_DEBUG "Now probing slot %X at %p\n", slot, rp);\r\ndp = *rp;\r\nif(dp == 0)\r\ncontinue;\r\nif ((((dp>>4) ^ dp) & 0x0F) != 0x0F)\r\ncontinue;\r\nif ((dp & 0x0F) >= (1<<i))\r\ncontinue;\r\nnubus_add_board(slot, dp);\r\nreturn;\r\n}\r\n}\r\nvoid __init nubus_scan_bus(void)\r\n{\r\nint slot;\r\n#ifdef I_WANT_TO_PROBE_SLOT_ZERO\r\nnubus_probe_slot(0);\r\n#endif\r\nfor(slot = 9; slot < 15; slot++)\r\n{\r\nnubus_probe_slot(slot);\r\n}\r\n}\r\nstatic int __init nubus_init(void)\r\n{\r\nif (!MACH_IS_MAC)\r\nreturn 0;\r\nif (oss_present) {\r\noss_nubus_init();\r\n} else {\r\nvia_nubus_init();\r\n}\r\n#ifdef TRY_TO_DODGE_WSOD\r\nmdelay(1000);\r\n#endif\r\nprintk("NuBus: Scanning NuBus slots.\n");\r\nnubus_devices = NULL;\r\nnubus_boards = NULL;\r\nnubus_scan_bus();\r\nnubus_proc_init();\r\nreturn 0;\r\n}
