static int\r\nixgb_validate_option(unsigned int *value, const struct ixgb_option *opt)\r\n{\r\nif (*value == OPTION_UNSET) {\r\n*value = opt->def;\r\nreturn 0;\r\n}\r\nswitch (opt->type) {\r\ncase enable_option:\r\nswitch (*value) {\r\ncase OPTION_ENABLED:\r\npr_info("%s Enabled\n", opt->name);\r\nreturn 0;\r\ncase OPTION_DISABLED:\r\npr_info("%s Disabled\n", opt->name);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase range_option:\r\nif (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {\r\npr_info("%s set to %i\n", opt->name, *value);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase list_option: {\r\nint i;\r\nconst struct ixgb_opt_list *ent;\r\nfor (i = 0; i < opt->arg.l.nr; i++) {\r\nent = &opt->arg.l.p[i];\r\nif (*value == ent->i) {\r\nif (ent->str[0] != '\0')\r\npr_info("%s\n", ent->str);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\npr_info("Invalid %s specified (%i) %s\n", opt->name, *value, opt->err);\r\n*value = opt->def;\r\nreturn -1;\r\n}\r\nvoid\r\nixgb_check_options(struct ixgb_adapter *adapter)\r\n{\r\nint bd = adapter->bd_number;\r\nif (bd >= IXGB_MAX_NIC) {\r\npr_notice("Warning: no configuration for board #%i\n", bd);\r\npr_notice("Using defaults for all values\n");\r\n}\r\n{\r\nstatic const struct ixgb_option opt = {\r\n.type = range_option,\r\n.name = "Transmit Descriptors",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_TXD),\r\n.def = DEFAULT_TXD,\r\n.arg = { .r = { .min = MIN_TXD,\r\n.max = MAX_TXD}}\r\n};\r\nstruct ixgb_desc_ring *tx_ring = &adapter->tx_ring;\r\nif (num_TxDescriptors > bd) {\r\ntx_ring->count = TxDescriptors[bd];\r\nixgb_validate_option(&tx_ring->count, &opt);\r\n} else {\r\ntx_ring->count = opt.def;\r\n}\r\ntx_ring->count = ALIGN(tx_ring->count, IXGB_REQ_TX_DESCRIPTOR_MULTIPLE);\r\n}\r\n{\r\nstatic const struct ixgb_option opt = {\r\n.type = range_option,\r\n.name = "Receive Descriptors",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_RXD),\r\n.def = DEFAULT_RXD,\r\n.arg = { .r = { .min = MIN_RXD,\r\n.max = MAX_RXD}}\r\n};\r\nstruct ixgb_desc_ring *rx_ring = &adapter->rx_ring;\r\nif (num_RxDescriptors > bd) {\r\nrx_ring->count = RxDescriptors[bd];\r\nixgb_validate_option(&rx_ring->count, &opt);\r\n} else {\r\nrx_ring->count = opt.def;\r\n}\r\nrx_ring->count = ALIGN(rx_ring->count, IXGB_REQ_RX_DESCRIPTOR_MULTIPLE);\r\n}\r\n{\r\nstatic const struct ixgb_option opt = {\r\n.type = enable_option,\r\n.name = "Receive Checksum Offload",\r\n.err = "defaulting to Enabled",\r\n.def = OPTION_ENABLED\r\n};\r\nif (num_XsumRX > bd) {\r\nunsigned int rx_csum = XsumRX[bd];\r\nixgb_validate_option(&rx_csum, &opt);\r\nadapter->rx_csum = rx_csum;\r\n} else {\r\nadapter->rx_csum = opt.def;\r\n}\r\n}\r\n{\r\nstatic const struct ixgb_opt_list fc_list[] = {\r\n{ ixgb_fc_none, "Flow Control Disabled" },\r\n{ ixgb_fc_rx_pause, "Flow Control Receive Only" },\r\n{ ixgb_fc_tx_pause, "Flow Control Transmit Only" },\r\n{ ixgb_fc_full, "Flow Control Enabled" },\r\n{ ixgb_fc_default, "Flow Control Hardware Default" }\r\n};\r\nstatic const struct ixgb_option opt = {\r\n.type = list_option,\r\n.name = "Flow Control",\r\n.err = "reading default settings from EEPROM",\r\n.def = ixgb_fc_tx_pause,\r\n.arg = { .l = { .nr = ARRAY_SIZE(fc_list),\r\n.p = fc_list }}\r\n};\r\nif (num_FlowControl > bd) {\r\nunsigned int fc = FlowControl[bd];\r\nixgb_validate_option(&fc, &opt);\r\nadapter->hw.fc.type = fc;\r\n} else {\r\nadapter->hw.fc.type = opt.def;\r\n}\r\n}\r\n{\r\nstatic const struct ixgb_option opt = {\r\n.type = range_option,\r\n.name = "Rx Flow Control High Threshold",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_FCRTH),\r\n.def = DEFAULT_FCRTH,\r\n.arg = { .r = { .min = MIN_FCRTH,\r\n.max = MAX_FCRTH}}\r\n};\r\nif (num_RxFCHighThresh > bd) {\r\nadapter->hw.fc.high_water = RxFCHighThresh[bd];\r\nixgb_validate_option(&adapter->hw.fc.high_water, &opt);\r\n} else {\r\nadapter->hw.fc.high_water = opt.def;\r\n}\r\nif (!(adapter->hw.fc.type & ixgb_fc_tx_pause) )\r\npr_info("Ignoring RxFCHighThresh when no RxFC\n");\r\n}\r\n{\r\nstatic const struct ixgb_option opt = {\r\n.type = range_option,\r\n.name = "Rx Flow Control Low Threshold",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_FCRTL),\r\n.def = DEFAULT_FCRTL,\r\n.arg = { .r = { .min = MIN_FCRTL,\r\n.max = MAX_FCRTL}}\r\n};\r\nif (num_RxFCLowThresh > bd) {\r\nadapter->hw.fc.low_water = RxFCLowThresh[bd];\r\nixgb_validate_option(&adapter->hw.fc.low_water, &opt);\r\n} else {\r\nadapter->hw.fc.low_water = opt.def;\r\n}\r\nif (!(adapter->hw.fc.type & ixgb_fc_tx_pause) )\r\npr_info("Ignoring RxFCLowThresh when no RxFC\n");\r\n}\r\n{\r\nstatic const struct ixgb_option opt = {\r\n.type = range_option,\r\n.name = "Flow Control Pause Time Request",\r\n.err = "using default of "__MODULE_STRING(DEFAULT_FCPAUSE),\r\n.def = DEFAULT_FCPAUSE,\r\n.arg = { .r = { .min = MIN_FCPAUSE,\r\n.max = MAX_FCPAUSE}}\r\n};\r\nif (num_FCReqTimeout > bd) {\r\nunsigned int pause_time = FCReqTimeout[bd];\r\nixgb_validate_option(&pause_time, &opt);\r\nadapter->hw.fc.pause_time = pause_time;\r\n} else {\r\nadapter->hw.fc.pause_time = opt.def;\r\n}\r\nif (!(adapter->hw.fc.type & ixgb_fc_tx_pause) )\r\npr_info("Ignoring FCReqTimeout when no RxFC\n");\r\n}\r\nif (adapter->hw.fc.type & ixgb_fc_tx_pause) {\r\nif (adapter->hw.fc.high_water < (adapter->hw.fc.low_water + 8)) {\r\npr_info("RxFCHighThresh must be >= (RxFCLowThresh + 8), Using Defaults\n");\r\nadapter->hw.fc.high_water = DEFAULT_FCRTH;\r\nadapter->hw.fc.low_water = DEFAULT_FCRTL;\r\n}\r\n}\r\n{\r\nstatic const struct ixgb_option opt = {\r\n.type = range_option,\r\n.name = "Receive Interrupt Delay",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_RDTR),\r\n.def = DEFAULT_RDTR,\r\n.arg = { .r = { .min = MIN_RDTR,\r\n.max = MAX_RDTR}}\r\n};\r\nif (num_RxIntDelay > bd) {\r\nadapter->rx_int_delay = RxIntDelay[bd];\r\nixgb_validate_option(&adapter->rx_int_delay, &opt);\r\n} else {\r\nadapter->rx_int_delay = opt.def;\r\n}\r\n}\r\n{\r\nstatic const struct ixgb_option opt = {\r\n.type = range_option,\r\n.name = "Transmit Interrupt Delay",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_TIDV),\r\n.def = DEFAULT_TIDV,\r\n.arg = { .r = { .min = MIN_TIDV,\r\n.max = MAX_TIDV}}\r\n};\r\nif (num_TxIntDelay > bd) {\r\nadapter->tx_int_delay = TxIntDelay[bd];\r\nixgb_validate_option(&adapter->tx_int_delay, &opt);\r\n} else {\r\nadapter->tx_int_delay = opt.def;\r\n}\r\n}\r\n{\r\nstatic const struct ixgb_option opt = {\r\n.type = enable_option,\r\n.name = "Tx Interrupt Delay Enable",\r\n.err = "defaulting to Enabled",\r\n.def = OPTION_ENABLED\r\n};\r\nif (num_IntDelayEnable > bd) {\r\nunsigned int ide = IntDelayEnable[bd];\r\nixgb_validate_option(&ide, &opt);\r\nadapter->tx_int_delay_enable = ide;\r\n} else {\r\nadapter->tx_int_delay_enable = opt.def;\r\n}\r\n}\r\n}
