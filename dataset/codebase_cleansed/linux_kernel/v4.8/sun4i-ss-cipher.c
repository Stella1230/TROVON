static int sun4i_ss_opti_poll(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_ss_ctx *ss = op->ss;\r\nunsigned int ivsize = crypto_ablkcipher_ivsize(tfm);\r\nstruct sun4i_cipher_req_ctx *ctx = ablkcipher_request_ctx(areq);\r\nu32 mode = ctx->mode;\r\nu32 rx_cnt = SS_RX_DEFAULT;\r\nu32 tx_cnt = 0;\r\nu32 spaces;\r\nu32 v;\r\nint i, err = 0;\r\nunsigned int ileft = areq->nbytes;\r\nunsigned int oleft = areq->nbytes;\r\nunsigned int todo;\r\nstruct sg_mapping_iter mi, mo;\r\nunsigned int oi, oo;\r\nunsigned long flags;\r\nif (areq->nbytes == 0)\r\nreturn 0;\r\nif (!areq->info) {\r\ndev_err_ratelimited(ss->dev, "ERROR: Empty IV\n");\r\nreturn -EINVAL;\r\n}\r\nif (!areq->src || !areq->dst) {\r\ndev_err_ratelimited(ss->dev, "ERROR: Some SGs are NULL\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&ss->slock, flags);\r\nfor (i = 0; i < op->keylen; i += 4)\r\nwritel(*(op->key + i / 4), ss->base + SS_KEY0 + i);\r\nif (areq->info) {\r\nfor (i = 0; i < 4 && i < ivsize / 4; i++) {\r\nv = *(u32 *)(areq->info + i * 4);\r\nwritel(v, ss->base + SS_IV0 + i * 4);\r\n}\r\n}\r\nwritel(mode, ss->base + SS_CTL);\r\nsg_miter_start(&mi, areq->src, sg_nents(areq->src),\r\nSG_MITER_FROM_SG | SG_MITER_ATOMIC);\r\nsg_miter_start(&mo, areq->dst, sg_nents(areq->dst),\r\nSG_MITER_TO_SG | SG_MITER_ATOMIC);\r\nsg_miter_next(&mi);\r\nsg_miter_next(&mo);\r\nif (!mi.addr || !mo.addr) {\r\ndev_err_ratelimited(ss->dev, "ERROR: sg_miter return null\n");\r\nerr = -EINVAL;\r\ngoto release_ss;\r\n}\r\nileft = areq->nbytes / 4;\r\noleft = areq->nbytes / 4;\r\noi = 0;\r\noo = 0;\r\ndo {\r\ntodo = min3(rx_cnt, ileft, (mi.length - oi) / 4);\r\nif (todo > 0) {\r\nileft -= todo;\r\nwritesl(ss->base + SS_RXFIFO, mi.addr + oi, todo);\r\noi += todo * 4;\r\n}\r\nif (oi == mi.length) {\r\nsg_miter_next(&mi);\r\noi = 0;\r\n}\r\nspaces = readl(ss->base + SS_FCSR);\r\nrx_cnt = SS_RXFIFO_SPACES(spaces);\r\ntx_cnt = SS_TXFIFO_SPACES(spaces);\r\ntodo = min3(tx_cnt, oleft, (mo.length - oo) / 4);\r\nif (todo > 0) {\r\noleft -= todo;\r\nreadsl(ss->base + SS_TXFIFO, mo.addr + oo, todo);\r\noo += todo * 4;\r\n}\r\nif (oo == mo.length) {\r\nsg_miter_next(&mo);\r\noo = 0;\r\n}\r\n} while (oleft > 0);\r\nif (areq->info) {\r\nfor (i = 0; i < 4 && i < ivsize / 4; i++) {\r\nv = readl(ss->base + SS_IV0 + i * 4);\r\n*(u32 *)(areq->info + i * 4) = v;\r\n}\r\n}\r\nrelease_ss:\r\nsg_miter_stop(&mi);\r\nsg_miter_stop(&mo);\r\nwritel(0, ss->base + SS_CTL);\r\nspin_unlock_irqrestore(&ss->slock, flags);\r\nreturn err;\r\n}\r\nstatic int sun4i_ss_cipher_poll(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_ss_ctx *ss = op->ss;\r\nint no_chunk = 1;\r\nstruct scatterlist *in_sg = areq->src;\r\nstruct scatterlist *out_sg = areq->dst;\r\nunsigned int ivsize = crypto_ablkcipher_ivsize(tfm);\r\nstruct sun4i_cipher_req_ctx *ctx = ablkcipher_request_ctx(areq);\r\nu32 mode = ctx->mode;\r\nu32 rx_cnt = SS_RX_DEFAULT;\r\nu32 tx_cnt = 0;\r\nu32 v;\r\nu32 spaces;\r\nint i, err = 0;\r\nunsigned int ileft = areq->nbytes;\r\nunsigned int oleft = areq->nbytes;\r\nunsigned int todo;\r\nstruct sg_mapping_iter mi, mo;\r\nunsigned int oi, oo;\r\nchar buf[4 * SS_RX_MAX];\r\nchar bufo[4 * SS_TX_MAX];\r\nunsigned int ob = 0;\r\nunsigned int obo = 0;\r\nunsigned int obl = 0;\r\nunsigned long flags;\r\nif (areq->nbytes == 0)\r\nreturn 0;\r\nif (!areq->info) {\r\ndev_err_ratelimited(ss->dev, "ERROR: Empty IV\n");\r\nreturn -EINVAL;\r\n}\r\nif (!areq->src || !areq->dst) {\r\ndev_err_ratelimited(ss->dev, "ERROR: Some SGs are NULL\n");\r\nreturn -EINVAL;\r\n}\r\nwhile (in_sg && no_chunk == 1) {\r\nif ((in_sg->length % 4) != 0)\r\nno_chunk = 0;\r\nin_sg = sg_next(in_sg);\r\n}\r\nwhile (out_sg && no_chunk == 1) {\r\nif ((out_sg->length % 4) != 0)\r\nno_chunk = 0;\r\nout_sg = sg_next(out_sg);\r\n}\r\nif (no_chunk == 1)\r\nreturn sun4i_ss_opti_poll(areq);\r\nspin_lock_irqsave(&ss->slock, flags);\r\nfor (i = 0; i < op->keylen; i += 4)\r\nwritel(*(op->key + i / 4), ss->base + SS_KEY0 + i);\r\nif (areq->info) {\r\nfor (i = 0; i < 4 && i < ivsize / 4; i++) {\r\nv = *(u32 *)(areq->info + i * 4);\r\nwritel(v, ss->base + SS_IV0 + i * 4);\r\n}\r\n}\r\nwritel(mode, ss->base + SS_CTL);\r\nsg_miter_start(&mi, areq->src, sg_nents(areq->src),\r\nSG_MITER_FROM_SG | SG_MITER_ATOMIC);\r\nsg_miter_start(&mo, areq->dst, sg_nents(areq->dst),\r\nSG_MITER_TO_SG | SG_MITER_ATOMIC);\r\nsg_miter_next(&mi);\r\nsg_miter_next(&mo);\r\nif (!mi.addr || !mo.addr) {\r\ndev_err_ratelimited(ss->dev, "ERROR: sg_miter return null\n");\r\nerr = -EINVAL;\r\ngoto release_ss;\r\n}\r\nileft = areq->nbytes;\r\noleft = areq->nbytes;\r\noi = 0;\r\noo = 0;\r\nwhile (oleft > 0) {\r\nif (ileft > 0) {\r\ntodo = min3(rx_cnt, ileft / 4, (mi.length - oi) / 4);\r\nif (todo > 0 && ob == 0) {\r\nwritesl(ss->base + SS_RXFIFO, mi.addr + oi,\r\ntodo);\r\nileft -= todo * 4;\r\noi += todo * 4;\r\n} else {\r\ntodo = min3(rx_cnt * 4 - ob, ileft,\r\nmi.length - oi);\r\nmemcpy(buf + ob, mi.addr + oi, todo);\r\nileft -= todo;\r\noi += todo;\r\nob += todo;\r\nif (ob % 4 == 0) {\r\nwritesl(ss->base + SS_RXFIFO, buf,\r\nob / 4);\r\nob = 0;\r\n}\r\n}\r\nif (oi == mi.length) {\r\nsg_miter_next(&mi);\r\noi = 0;\r\n}\r\n}\r\nspaces = readl(ss->base + SS_FCSR);\r\nrx_cnt = SS_RXFIFO_SPACES(spaces);\r\ntx_cnt = SS_TXFIFO_SPACES(spaces);\r\ndev_dbg(ss->dev, "%x %u/%u %u/%u cnt=%u %u/%u %u/%u cnt=%u %u\n",\r\nmode,\r\noi, mi.length, ileft, areq->nbytes, rx_cnt,\r\noo, mo.length, oleft, areq->nbytes, tx_cnt, ob);\r\nif (tx_cnt == 0)\r\ncontinue;\r\ntodo = min3(tx_cnt, oleft / 4, (mo.length - oo) / 4);\r\nif (todo > 0) {\r\nreadsl(ss->base + SS_TXFIFO, mo.addr + oo, todo);\r\noleft -= todo * 4;\r\noo += todo * 4;\r\nif (oo == mo.length) {\r\nsg_miter_next(&mo);\r\noo = 0;\r\n}\r\n} else {\r\nreadsl(ss->base + SS_TXFIFO, bufo, tx_cnt);\r\nobl = tx_cnt * 4;\r\nobo = 0;\r\ndo {\r\ntodo = min(mo.length - oo, obl - obo);\r\nmemcpy(mo.addr + oo, bufo + obo, todo);\r\noleft -= todo;\r\nobo += todo;\r\noo += todo;\r\nif (oo == mo.length) {\r\nsg_miter_next(&mo);\r\noo = 0;\r\n}\r\n} while (obo < obl);\r\n}\r\n}\r\nif (areq->info) {\r\nfor (i = 0; i < 4 && i < ivsize / 4; i++) {\r\nv = readl(ss->base + SS_IV0 + i * 4);\r\n*(u32 *)(areq->info + i * 4) = v;\r\n}\r\n}\r\nrelease_ss:\r\nsg_miter_stop(&mi);\r\nsg_miter_stop(&mo);\r\nwritel(0, ss->base + SS_CTL);\r\nspin_unlock_irqrestore(&ss->slock, flags);\r\nreturn err;\r\n}\r\nint sun4i_ss_cbc_aes_encrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_AES | SS_CBC | SS_ENABLED | SS_ENCRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_cbc_aes_decrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_AES | SS_CBC | SS_ENABLED | SS_DECRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_ecb_aes_encrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_AES | SS_ECB | SS_ENABLED | SS_ENCRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_ecb_aes_decrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_AES | SS_ECB | SS_ENABLED | SS_DECRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_cbc_des_encrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_DES | SS_CBC | SS_ENABLED | SS_ENCRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_cbc_des_decrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_DES | SS_CBC | SS_ENABLED | SS_DECRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_ecb_des_encrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_DES | SS_ECB | SS_ENABLED | SS_ENCRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_ecb_des_decrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_DES | SS_ECB | SS_ENABLED | SS_DECRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_cbc_des3_encrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_3DES | SS_CBC | SS_ENABLED | SS_ENCRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_cbc_des3_decrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_3DES | SS_CBC | SS_ENABLED | SS_DECRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_ecb_des3_encrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_3DES | SS_ECB | SS_ENABLED | SS_ENCRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_ecb_des3_decrypt(struct ablkcipher_request *areq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_cipher_req_ctx *rctx = ablkcipher_request_ctx(areq);\r\nrctx->mode = SS_OP_3DES | SS_ECB | SS_ENABLED | SS_DECRYPTION |\r\nop->keymode;\r\nreturn sun4i_ss_cipher_poll(areq);\r\n}\r\nint sun4i_ss_cipher_init(struct crypto_tfm *tfm)\r\n{\r\nstruct sun4i_tfm_ctx *op = crypto_tfm_ctx(tfm);\r\nstruct crypto_alg *alg = tfm->__crt_alg;\r\nstruct sun4i_ss_alg_template *algt;\r\nmemset(op, 0, sizeof(struct sun4i_tfm_ctx));\r\nalgt = container_of(alg, struct sun4i_ss_alg_template, alg.crypto);\r\nop->ss = algt->ss;\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct sun4i_cipher_req_ctx);\r\nreturn 0;\r\n}\r\nint sun4i_ss_aes_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_ss_ctx *ss = op->ss;\r\nswitch (keylen) {\r\ncase 128 / 8:\r\nop->keymode = SS_AES_128BITS;\r\nbreak;\r\ncase 192 / 8:\r\nop->keymode = SS_AES_192BITS;\r\nbreak;\r\ncase 256 / 8:\r\nop->keymode = SS_AES_256BITS;\r\nbreak;\r\ndefault:\r\ndev_err(ss->dev, "ERROR: Invalid keylen %u\n", keylen);\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nop->keylen = keylen;\r\nmemcpy(op->key, key, keylen);\r\nreturn 0;\r\n}\r\nint sun4i_ss_des_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_ss_ctx *ss = op->ss;\r\nu32 flags;\r\nu32 tmp[DES_EXPKEY_WORDS];\r\nint ret;\r\nif (unlikely(keylen != DES_KEY_SIZE)) {\r\ndev_err(ss->dev, "Invalid keylen %u\n", keylen);\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nflags = crypto_ablkcipher_get_flags(tfm);\r\nret = des_ekey(tmp, key);\r\nif (unlikely(ret == 0) && (flags & CRYPTO_TFM_REQ_WEAK_KEY)) {\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_WEAK_KEY);\r\ndev_dbg(ss->dev, "Weak key %u\n", keylen);\r\nreturn -EINVAL;\r\n}\r\nop->keylen = keylen;\r\nmemcpy(op->key, key, keylen);\r\nreturn 0;\r\n}\r\nint sun4i_ss_des3_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct sun4i_tfm_ctx *op = crypto_ablkcipher_ctx(tfm);\r\nstruct sun4i_ss_ctx *ss = op->ss;\r\nif (unlikely(keylen != 3 * DES_KEY_SIZE)) {\r\ndev_err(ss->dev, "Invalid keylen %u\n", keylen);\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nop->keylen = keylen;\r\nmemcpy(op->key, key, keylen);\r\nreturn 0;\r\n}
