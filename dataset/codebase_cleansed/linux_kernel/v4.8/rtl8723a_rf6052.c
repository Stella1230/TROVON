void rtl8723a_phy_rf6052set_bw(struct rtw_adapter *Adapter,\r\nenum ht_channel_width Bandwidth)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(Adapter);\r\nswitch (Bandwidth) {\r\ncase HT_CHANNEL_WIDTH_20:\r\npHalData->RfRegChnlVal[0] =\r\n(pHalData->RfRegChnlVal[0] & 0xfffff3ff) | 0x0400;\r\nPHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask,\r\npHalData->RfRegChnlVal[0]);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_40:\r\npHalData->RfRegChnlVal[0] =\r\n(pHalData->RfRegChnlVal[0] & 0xfffff3ff);\r\nPHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask,\r\npHalData->RfRegChnlVal[0]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid rtl823a_phy_rf6052setccktxpower(struct rtw_adapter *Adapter,\r\nu8 *pPowerlevel)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(Adapter);\r\nstruct dm_priv *pdmpriv = &pHalData->dmpriv;\r\nstruct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;\r\nu32 TxAGC[2] = {0, 0}, tmpval = 0;\r\nu8 idx1, idx2;\r\nu8 *ptr;\r\nif (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {\r\nTxAGC[RF_PATH_A] = 0x3f3f3f3f;\r\nTxAGC[RF_PATH_B] = 0x3f3f3f3f;\r\nfor (idx1 = RF_PATH_A; idx1 <= RF_PATH_B; idx1++) {\r\nTxAGC[idx1] = pPowerlevel[idx1] |\r\n(pPowerlevel[idx1] << 8) |\r\n(pPowerlevel[idx1] << 16) |\r\n(pPowerlevel[idx1] << 24);\r\nif (TxAGC[idx1] > 0x20 && pHalData->ExternalPA)\r\nTxAGC[idx1] = 0x20;\r\n}\r\n} else {\r\nif (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1) {\r\nTxAGC[RF_PATH_A] = 0x10101010;\r\nTxAGC[RF_PATH_B] = 0x10101010;\r\n} else if (pdmpriv->DynamicTxHighPowerLvl ==\r\nTxHighPwrLevel_Level2) {\r\nTxAGC[RF_PATH_A] = 0x00000000;\r\nTxAGC[RF_PATH_B] = 0x00000000;\r\n} else {\r\nfor (idx1 = RF_PATH_A; idx1 <= RF_PATH_B; idx1++) {\r\nTxAGC[idx1] = pPowerlevel[idx1] |\r\n(pPowerlevel[idx1] << 8) |\r\n(pPowerlevel[idx1] << 16) |\r\n(pPowerlevel[idx1] << 24);\r\n}\r\nif (pHalData->EEPROMRegulatory == 0) {\r\ntmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][6]) +\r\n(pHalData->MCSTxPowerLevelOriginalOffset[0][7]<<8);\r\nTxAGC[RF_PATH_A] += tmpval;\r\ntmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][14]) +\r\n(pHalData->MCSTxPowerLevelOriginalOffset[0][15]<<24);\r\nTxAGC[RF_PATH_B] += tmpval;\r\n}\r\n}\r\n}\r\nfor (idx1 = RF_PATH_A; idx1 <= RF_PATH_B; idx1++) {\r\nptr = (u8 *)(&TxAGC[idx1]);\r\nfor (idx2 = 0; idx2 < 4; idx2++) {\r\nif (*ptr > RF6052_MAX_TX_PWR)\r\n*ptr = RF6052_MAX_TX_PWR;\r\nptr++;\r\n}\r\n}\r\ntmpval = TxAGC[RF_PATH_A] & 0xff;\r\nPHY_SetBBReg(Adapter, rTxAGC_A_CCK1_Mcs32, bMaskByte1, tmpval);\r\ntmpval = TxAGC[RF_PATH_A] >> 8;\r\nPHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval);\r\ntmpval = TxAGC[RF_PATH_B] >> 24;\r\nPHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskByte0, tmpval);\r\ntmpval = TxAGC[RF_PATH_B] & 0x00ffffff;\r\nPHY_SetBBReg(Adapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);\r\n}\r\nstatic void getPowerBase(struct rtw_adapter *Adapter, u8 *pPowerLevel,\r\nu8 Channel, u32 *OfdmBase, u32 *MCSBase)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(Adapter);\r\nu32 ofdm, mcs;\r\nu8 Legacy_pwrdiff = 0;\r\ns8 HT20_pwrdiff = 0;\r\nu8 i, powerlevel[2];\r\nfor (i = 0; i < 2; i++) {\r\npowerlevel[i] = pPowerLevel[i];\r\nLegacy_pwrdiff = pHalData->TxPwrLegacyHtDiff[i][Channel-1];\r\nofdm = powerlevel[i] + Legacy_pwrdiff;\r\nofdm = ofdm << 24 | ofdm << 16 | ofdm << 8 | ofdm;\r\n*(OfdmBase + i) = ofdm;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nif (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20) {\r\nHT20_pwrdiff = pHalData->TxPwrHt20Diff[i][Channel-1];\r\npowerlevel[i] += HT20_pwrdiff;\r\n}\r\nmcs = powerlevel[i];\r\nmcs = mcs << 24 | mcs << 16 | mcs << 8 | mcs;\r\n*(MCSBase + i) = mcs;\r\n}\r\n}\r\nstatic void\r\ngetTxPowerWriteValByRegulatory(struct rtw_adapter *Adapter, u8 Channel,\r\nu8 index, u32 *powerBase0, u32 *powerBase1,\r\nu32 *pOutWriteVal)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(Adapter);\r\nstruct dm_priv *pdmpriv = &pHalData->dmpriv;\r\nu8 i, chnlGroup = 0, pwr_diff_limit[4];\r\nu32 writeVal, customer_limit, rf;\r\nfor (rf = 0; rf < 2; rf++) {\r\nswitch (pHalData->EEPROMRegulatory) {\r\ncase 0:\r\nchnlGroup = 0;\r\nwriteVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +\r\n((index < 2) ? powerBase0[rf] : powerBase1[rf]);\r\nbreak;\r\ncase 1:\r\nif (pHalData->pwrGroupCnt == 1)\r\nchnlGroup = 0;\r\nif (pHalData->pwrGroupCnt >= 3) {\r\nif (Channel <= 3)\r\nchnlGroup = 0;\r\nelse if (Channel >= 4 && Channel <= 9)\r\nchnlGroup = 1;\r\nelse if (Channel > 9)\r\nchnlGroup = 2;\r\nif (pHalData->CurrentChannelBW ==\r\nHT_CHANNEL_WIDTH_20)\r\nchnlGroup++;\r\nelse\r\nchnlGroup += 4;\r\n}\r\nwriteVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +\r\n((index < 2) ? powerBase0[rf] :\r\npowerBase1[rf]);\r\nbreak;\r\ncase 2:\r\nwriteVal = (index < 2) ? powerBase0[rf] :\r\npowerBase1[rf];\r\nbreak;\r\ncase 3:\r\nchnlGroup = 0;\r\nfor (i = 0; i < 4; i++) {\r\npwr_diff_limit[i] = (u8)((pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index +\r\n(rf ? 8 : 0)]&(0x7f << (i*8))) >> (i*8));\r\nif (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_40) {\r\nif (pwr_diff_limit[i] > pHalData->PwrGroupHT40[rf][Channel-1])\r\npwr_diff_limit[i] = pHalData->PwrGroupHT40[rf][Channel-1];\r\n} else {\r\nif (pwr_diff_limit[i] > pHalData->PwrGroupHT20[rf][Channel-1])\r\npwr_diff_limit[i] = pHalData->PwrGroupHT20[rf][Channel-1];\r\n}\r\n}\r\ncustomer_limit = (pwr_diff_limit[3]<<24) | (pwr_diff_limit[2]<<16) |\r\n(pwr_diff_limit[1]<<8) | (pwr_diff_limit[0]);\r\nwriteVal = customer_limit + ((index<2)?powerBase0[rf]:powerBase1[rf]);\r\nbreak;\r\ndefault:\r\nchnlGroup = 0;\r\nwriteVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +\r\n((index < 2) ? powerBase0[rf] : powerBase1[rf]);\r\nbreak;\r\n}\r\nif (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)\r\nwriteVal = 0x14141414;\r\nelse if (pdmpriv->DynamicTxHighPowerLvl ==\r\nTxHighPwrLevel_Level2)\r\nwriteVal = 0x00000000;\r\nif (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT1)\r\nwriteVal = writeVal - 0x06060606;\r\nelse if (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT2)\r\nwriteVal = writeVal;\r\n*(pOutWriteVal + rf) = writeVal;\r\n}\r\n}\r\nstatic void writeOFDMPowerReg(struct rtw_adapter *Adapter, u8 index,\r\nu32 *pValue)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(Adapter);\r\nu16 RegOffset_A[6] = {\r\nrTxAGC_A_Rate18_06, rTxAGC_A_Rate54_24,\r\nrTxAGC_A_Mcs03_Mcs00, rTxAGC_A_Mcs07_Mcs04,\r\nrTxAGC_A_Mcs11_Mcs08, rTxAGC_A_Mcs15_Mcs12\r\n};\r\nu16 RegOffset_B[6] = {\r\nrTxAGC_B_Rate18_06, rTxAGC_B_Rate54_24,\r\nrTxAGC_B_Mcs03_Mcs00, rTxAGC_B_Mcs07_Mcs04,\r\nrTxAGC_B_Mcs11_Mcs08, rTxAGC_B_Mcs15_Mcs12\r\n};\r\nu8 i, rf, pwr_val[4];\r\nu32 writeVal;\r\nu16 RegOffset;\r\nfor (rf = 0; rf < 2; rf++) {\r\nwriteVal = pValue[rf];\r\nfor (i = 0; i < 4; i++) {\r\npwr_val[i] = (u8)((writeVal &\r\n(0x7f << (i * 8))) >> (i * 8));\r\nif (pwr_val[i] > RF6052_MAX_TX_PWR)\r\npwr_val[i] = RF6052_MAX_TX_PWR;\r\n}\r\nwriteVal = pwr_val[3] << 24 | pwr_val[2] << 16 |\r\npwr_val[1] << 8 | pwr_val[0];\r\nif (rf == 0)\r\nRegOffset = RegOffset_A[index];\r\nelse\r\nRegOffset = RegOffset_B[index];\r\nrtl8723au_write32(Adapter, RegOffset, writeVal);\r\nif (((pHalData->rf_type == RF_2T2R) &&\r\n(RegOffset == rTxAGC_A_Mcs15_Mcs12 ||\r\nRegOffset == rTxAGC_B_Mcs15_Mcs12)) ||\r\n((pHalData->rf_type != RF_2T2R) &&\r\n(RegOffset == rTxAGC_A_Mcs07_Mcs04 ||\r\nRegOffset == rTxAGC_B_Mcs07_Mcs04))) {\r\nwriteVal = pwr_val[3];\r\nif (RegOffset == rTxAGC_A_Mcs15_Mcs12 ||\r\nRegOffset == rTxAGC_A_Mcs07_Mcs04)\r\nRegOffset = 0xc90;\r\nif (RegOffset == rTxAGC_B_Mcs15_Mcs12 ||\r\nRegOffset == rTxAGC_B_Mcs07_Mcs04)\r\nRegOffset = 0xc98;\r\nfor (i = 0; i < 3; i++) {\r\nif (i != 2)\r\nwriteVal = (writeVal > 8) ?\r\n(writeVal - 8) : 0;\r\nelse\r\nwriteVal = (writeVal > 6) ?\r\n(writeVal - 6) : 0;\r\nrtl8723au_write8(Adapter, RegOffset + i,\r\n(u8)writeVal);\r\n}\r\n}\r\n}\r\n}\r\nvoid rtl8723a_PHY_RF6052SetOFDMTxPower(struct rtw_adapter *Adapter,\r\nu8 *pPowerLevel, u8 Channel)\r\n{\r\nu32 writeVal[2], powerBase0[2], powerBase1[2];\r\nu8 index = 0;\r\ngetPowerBase(Adapter, pPowerLevel, Channel,\r\n&powerBase0[0], &powerBase1[0]);\r\nfor (index = 0; index < 6; index++) {\r\ngetTxPowerWriteValByRegulatory(Adapter, Channel, index,\r\n&powerBase0[0], &powerBase1[0], &writeVal[0]);\r\nwriteOFDMPowerReg(Adapter, index, &writeVal[0]);\r\n}\r\n}\r\nstatic int phy_RF6052_Config_ParaFile(struct rtw_adapter *Adapter)\r\n{\r\nu32 u4RegValue = 0;\r\nu8 eRFPath;\r\nstruct bb_reg_define *pPhyReg;\r\nint rtStatus = _SUCCESS;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(Adapter);\r\nfor (eRFPath = 0; eRFPath < pHalData->NumTotalRFPath; eRFPath++) {\r\npPhyReg = &pHalData->PHYRegDef[eRFPath];\r\nswitch (eRFPath) {\r\ncase RF_PATH_A:\r\nu4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs,\r\nbRFSI_RFENV);\r\nbreak;\r\ncase RF_PATH_B:\r\nu4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs,\r\nbRFSI_RFENV << 16);\r\nbreak;\r\n}\r\nPHY_SetBBReg(Adapter, pPhyReg->rfintfe, bRFSI_RFENV << 16, 0x1);\r\nudelay(1);\r\nPHY_SetBBReg(Adapter, pPhyReg->rfintfo, bRFSI_RFENV, 0x1);\r\nudelay(1);\r\nPHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, b3WireAddressLength,\r\n0x0);\r\nudelay(1);\r\nPHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, b3WireDataLength,\r\n0x0);\r\nudelay(1);\r\nswitch (eRFPath) {\r\ncase RF_PATH_A:\r\nODM_ReadAndConfig_RadioA_1T_8723A(&pHalData->odmpriv);\r\nbreak;\r\ncase RF_PATH_B:\r\nbreak;\r\n}\r\nswitch (eRFPath) {\r\ncase RF_PATH_A:\r\nPHY_SetBBReg(Adapter, pPhyReg->rfintfs,\r\nbRFSI_RFENV, u4RegValue);\r\nbreak;\r\ncase RF_PATH_B:\r\nPHY_SetBBReg(Adapter, pPhyReg->rfintfs,\r\nbRFSI_RFENV << 16, u4RegValue);\r\nbreak;\r\n}\r\nif (rtStatus != _SUCCESS) {\r\ngoto phy_RF6052_Config_ParaFile_Fail;\r\n}\r\n}\r\nphy_RF6052_Config_ParaFile_Fail:\r\nreturn rtStatus;\r\n}\r\nint PHY_RF6052_Config8723A(struct rtw_adapter *Adapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(Adapter);\r\nif (pHalData->rf_type == RF_1T1R)\r\npHalData->NumTotalRFPath = 1;\r\nelse\r\npHalData->NumTotalRFPath = 2;\r\nreturn phy_RF6052_Config_ParaFile(Adapter);\r\n}
