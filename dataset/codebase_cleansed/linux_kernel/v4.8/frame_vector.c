int get_vaddr_frames(unsigned long start, unsigned int nr_frames,\r\nbool write, bool force, struct frame_vector *vec)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nint ret = 0;\r\nint err;\r\nint locked;\r\nif (nr_frames == 0)\r\nreturn 0;\r\nif (WARN_ON_ONCE(nr_frames > vec->nr_allocated))\r\nnr_frames = vec->nr_allocated;\r\ndown_read(&mm->mmap_sem);\r\nlocked = 1;\r\nvma = find_vma_intersection(mm, start, start + 1);\r\nif (!vma) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (!(vma->vm_flags & (VM_IO | VM_PFNMAP))) {\r\nvec->got_ref = true;\r\nvec->is_pfns = false;\r\nret = get_user_pages_locked(start, nr_frames,\r\nwrite, force, (struct page **)(vec->ptrs), &locked);\r\ngoto out;\r\n}\r\nvec->got_ref = false;\r\nvec->is_pfns = true;\r\ndo {\r\nunsigned long *nums = frame_vector_pfns(vec);\r\nwhile (ret < nr_frames && start + PAGE_SIZE <= vma->vm_end) {\r\nerr = follow_pfn(vma, start, &nums[ret]);\r\nif (err) {\r\nif (ret == 0)\r\nret = err;\r\ngoto out;\r\n}\r\nstart += PAGE_SIZE;\r\nret++;\r\n}\r\nif (ret >= nr_frames || start < vma->vm_end)\r\nbreak;\r\nvma = find_vma_intersection(mm, start, start + 1);\r\n} while (vma && vma->vm_flags & (VM_IO | VM_PFNMAP));\r\nout:\r\nif (locked)\r\nup_read(&mm->mmap_sem);\r\nif (!ret)\r\nret = -EFAULT;\r\nif (ret > 0)\r\nvec->nr_frames = ret;\r\nreturn ret;\r\n}\r\nvoid put_vaddr_frames(struct frame_vector *vec)\r\n{\r\nint i;\r\nstruct page **pages;\r\nif (!vec->got_ref)\r\ngoto out;\r\npages = frame_vector_pages(vec);\r\nif (WARN_ON(IS_ERR(pages)))\r\ngoto out;\r\nfor (i = 0; i < vec->nr_frames; i++)\r\nput_page(pages[i]);\r\nvec->got_ref = false;\r\nout:\r\nvec->nr_frames = 0;\r\n}\r\nint frame_vector_to_pages(struct frame_vector *vec)\r\n{\r\nint i;\r\nunsigned long *nums;\r\nstruct page **pages;\r\nif (!vec->is_pfns)\r\nreturn 0;\r\nnums = frame_vector_pfns(vec);\r\nfor (i = 0; i < vec->nr_frames; i++)\r\nif (!pfn_valid(nums[i]))\r\nreturn -EINVAL;\r\npages = (struct page **)nums;\r\nfor (i = 0; i < vec->nr_frames; i++)\r\npages[i] = pfn_to_page(nums[i]);\r\nvec->is_pfns = false;\r\nreturn 0;\r\n}\r\nvoid frame_vector_to_pfns(struct frame_vector *vec)\r\n{\r\nint i;\r\nunsigned long *nums;\r\nstruct page **pages;\r\nif (vec->is_pfns)\r\nreturn;\r\npages = (struct page **)(vec->ptrs);\r\nnums = (unsigned long *)pages;\r\nfor (i = 0; i < vec->nr_frames; i++)\r\nnums[i] = page_to_pfn(pages[i]);\r\nvec->is_pfns = true;\r\n}\r\nstruct frame_vector *frame_vector_create(unsigned int nr_frames)\r\n{\r\nstruct frame_vector *vec;\r\nint size = sizeof(struct frame_vector) + sizeof(void *) * nr_frames;\r\nif (WARN_ON_ONCE(nr_frames == 0))\r\nreturn NULL;\r\nif (WARN_ON_ONCE(nr_frames > INT_MAX / sizeof(void *) / 2))\r\nreturn NULL;\r\nif (size <= PAGE_SIZE)\r\nvec = kmalloc(size, GFP_KERNEL);\r\nelse\r\nvec = vmalloc(size);\r\nif (!vec)\r\nreturn NULL;\r\nvec->nr_allocated = nr_frames;\r\nvec->nr_frames = 0;\r\nreturn vec;\r\n}\r\nvoid frame_vector_destroy(struct frame_vector *vec)\r\n{\r\nVM_BUG_ON(vec->nr_frames > 0);\r\nkvfree(vec);\r\n}
