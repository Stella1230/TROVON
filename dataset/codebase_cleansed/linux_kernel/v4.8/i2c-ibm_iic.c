static void dump_iic_regs(const char* header, struct ibm_iic_private* dev)\r\n{\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nprintk(KERN_DEBUG "ibm-iic%d: %s\n", dev->idx, header);\r\nprintk(KERN_DEBUG\r\n" cntl = 0x%02x, mdcntl = 0x%02x\n"\r\n" sts = 0x%02x, extsts = 0x%02x\n"\r\n" clkdiv = 0x%02x, xfrcnt = 0x%02x\n"\r\n" xtcntlss = 0x%02x, directcntl = 0x%02x\n",\r\nin_8(&iic->cntl), in_8(&iic->mdcntl), in_8(&iic->sts),\r\nin_8(&iic->extsts), in_8(&iic->clkdiv), in_8(&iic->xfrcnt),\r\nin_8(&iic->xtcntlss), in_8(&iic->directcntl));\r\n}\r\nstatic inline void iic_interrupt_mode(struct ibm_iic_private* dev, int enable)\r\n{\r\nout_8(&dev->vaddr->intmsk, enable ? INTRMSK_EIMTC : 0);\r\n}\r\nstatic void iic_dev_init(struct ibm_iic_private* dev)\r\n{\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nDBG("%d: init\n", dev->idx);\r\nout_8(&iic->lmadr, 0);\r\nout_8(&iic->hmadr, 0);\r\nout_8(&iic->lsadr, 0);\r\nout_8(&iic->hsadr, 0);\r\nout_8(&iic->sts, STS_SCMP | STS_IRQA);\r\nout_8(&iic->extsts, EXTSTS_IRQP | EXTSTS_IRQD | EXTSTS_LA\r\n| EXTSTS_ICT | EXTSTS_XFRA);\r\nout_8(&iic->clkdiv, dev->clckdiv);\r\nout_8(&iic->xfrcnt, 0);\r\nout_8(&iic->xtcntlss, XTCNTLSS_SRC | XTCNTLSS_SRS | XTCNTLSS_SWC\r\n| XTCNTLSS_SWS);\r\nout_8(&iic->cntl, 0);\r\niic_interrupt_mode(dev, dev->irq >= 0);\r\nout_8(&iic->mdcntl, MDCNTL_FMDB | MDCNTL_EINT | MDCNTL_EUBS\r\n| (dev->fast_mode ? MDCNTL_FSM : 0));\r\nDUMP_REGS("iic_init", dev);\r\n}\r\nstatic void iic_dev_reset(struct ibm_iic_private* dev)\r\n{\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nint i;\r\nu8 dc;\r\nDBG("%d: soft reset\n", dev->idx);\r\nDUMP_REGS("reset", dev);\r\nout_8(&iic->xtcntlss, XTCNTLSS_SRST);\r\ndc = in_8(&iic->directcntl);\r\nif (!DIRCTNL_FREE(dc)){\r\nDBG("%d: trying to regain bus control\n", dev->idx);\r\nout_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);\r\nfor (i = 0; i < 100; ++i){\r\ndc = in_8(&iic->directcntl);\r\nif (DIRCTNL_FREE(dc))\r\nbreak;\r\ndc ^= DIRCNTL_SCC;\r\nout_8(&iic->directcntl, dc);\r\nudelay(10);\r\ndc ^= DIRCNTL_SCC;\r\nout_8(&iic->directcntl, dc);\r\ncond_resched();\r\n}\r\n}\r\nout_8(&iic->xtcntlss, 0);\r\niic_dev_init(dev);\r\n}\r\nstatic int iic_dc_wait(volatile struct iic_regs __iomem *iic, u8 mask)\r\n{\r\nunsigned long x = jiffies + HZ / 28 + 2;\r\nwhile ((in_8(&iic->directcntl) & mask) != mask){\r\nif (unlikely(time_after(jiffies, x)))\r\nreturn -1;\r\ncond_resched();\r\n}\r\nreturn 0;\r\n}\r\nstatic int iic_smbus_quick(struct ibm_iic_private* dev, const struct i2c_msg* p)\r\n{\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nconst struct ibm_iic_timings *t = &timings[dev->fast_mode ? 1 : 0];\r\nu8 mask, v, sda;\r\nint i, res;\r\nif (unlikely(p->flags & I2C_M_TEN)){\r\nDBG("%d: smbus_quick - 10 bit addresses are not supported\n",\r\ndev->idx);\r\nreturn -EINVAL;\r\n}\r\nDBG("%d: smbus_quick(0x%02x)\n", dev->idx, p->addr);\r\nout_8(&iic->xtcntlss, XTCNTLSS_SRST);\r\nout_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);\r\nif (unlikely(iic_dc_wait(iic, DIRCNTL_MSDA | DIRCNTL_MSC)))\r\ngoto err;\r\nndelay(t->buf);\r\nout_8(&iic->directcntl, DIRCNTL_SCC);\r\nsda = 0;\r\nndelay(t->hd_sta);\r\nv = i2c_8bit_addr_from_msg(p);\r\nfor (i = 0, mask = 0x80; i < 8; ++i, mask >>= 1){\r\nout_8(&iic->directcntl, sda);\r\nndelay(t->low / 2);\r\nsda = (v & mask) ? DIRCNTL_SDAC : 0;\r\nout_8(&iic->directcntl, sda);\r\nndelay(t->low / 2);\r\nout_8(&iic->directcntl, DIRCNTL_SCC | sda);\r\nif (unlikely(iic_dc_wait(iic, DIRCNTL_MSC)))\r\ngoto err;\r\nndelay(t->high);\r\n}\r\nout_8(&iic->directcntl, sda);\r\nndelay(t->low / 2);\r\nout_8(&iic->directcntl, DIRCNTL_SDAC);\r\nndelay(t->low / 2);\r\nout_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);\r\nif (unlikely(iic_dc_wait(iic, DIRCNTL_MSC)))\r\ngoto err;\r\nres = (in_8(&iic->directcntl) & DIRCNTL_MSDA) ? -EREMOTEIO : 1;\r\nndelay(t->high);\r\nout_8(&iic->directcntl, 0);\r\nndelay(t->low);\r\nout_8(&iic->directcntl, DIRCNTL_SCC);\r\nif (unlikely(iic_dc_wait(iic, DIRCNTL_MSC)))\r\ngoto err;\r\nndelay(t->su_sto);\r\nout_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);\r\nndelay(t->buf);\r\nDBG("%d: smbus_quick -> %s\n", dev->idx, res ? "NACK" : "ACK");\r\nout:\r\nout_8(&iic->xtcntlss, 0);\r\niic_dev_init(dev);\r\nreturn res;\r\nerr:\r\nDBG("%d: smbus_quick - bus is stuck\n", dev->idx);\r\nres = -EREMOTEIO;\r\ngoto out;\r\n}\r\nstatic irqreturn_t iic_handler(int irq, void *dev_id)\r\n{\r\nstruct ibm_iic_private* dev = (struct ibm_iic_private*)dev_id;\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nDBG2("%d: irq handler, STS = 0x%02x, EXTSTS = 0x%02x\n",\r\ndev->idx, in_8(&iic->sts), in_8(&iic->extsts));\r\nout_8(&iic->sts, STS_IRQA | STS_SCMP);\r\nwake_up_interruptible(&dev->wq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int iic_xfer_result(struct ibm_iic_private* dev)\r\n{\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nif (unlikely(in_8(&iic->sts) & STS_ERR)){\r\nDBG("%d: xfer error, EXTSTS = 0x%02x\n", dev->idx,\r\nin_8(&iic->extsts));\r\nout_8(&iic->extsts, EXTSTS_IRQP | EXTSTS_IRQD |\r\nEXTSTS_LA | EXTSTS_ICT | EXTSTS_XFRA);\r\nout_8(&iic->mdcntl, in_8(&iic->mdcntl) | MDCNTL_FMDB);\r\nif ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){\r\nDBG("%d: bus is stuck, resetting\n", dev->idx);\r\niic_dev_reset(dev);\r\n}\r\nreturn -EREMOTEIO;\r\n}\r\nelse\r\nreturn in_8(&iic->xfrcnt) & XFRCNT_MTC_MASK;\r\n}\r\nstatic void iic_abort_xfer(struct ibm_iic_private* dev)\r\n{\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nunsigned long x;\r\nDBG("%d: iic_abort_xfer\n", dev->idx);\r\nout_8(&iic->cntl, CNTL_HMT);\r\nx = jiffies + 2;\r\nwhile ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){\r\nif (time_after(jiffies, x)){\r\nDBG("%d: abort timeout, resetting...\n", dev->idx);\r\niic_dev_reset(dev);\r\nreturn;\r\n}\r\nschedule();\r\n}\r\niic_xfer_result(dev);\r\n}\r\nstatic int iic_wait_for_tc(struct ibm_iic_private* dev){\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nint ret = 0;\r\nif (dev->irq >= 0){\r\nret = wait_event_interruptible_timeout(dev->wq,\r\n!(in_8(&iic->sts) & STS_PT), dev->adap.timeout);\r\nif (unlikely(ret < 0))\r\nDBG("%d: wait interrupted\n", dev->idx);\r\nelse if (unlikely(in_8(&iic->sts) & STS_PT)){\r\nDBG("%d: wait timeout\n", dev->idx);\r\nret = -ETIMEDOUT;\r\n}\r\n}\r\nelse {\r\nunsigned long x = jiffies + dev->adap.timeout;\r\nwhile (in_8(&iic->sts) & STS_PT){\r\nif (unlikely(time_after(jiffies, x))){\r\nDBG("%d: poll timeout\n", dev->idx);\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\nif (unlikely(signal_pending(current))){\r\nDBG("%d: poll interrupted\n", dev->idx);\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\n}\r\n}\r\nif (unlikely(ret < 0))\r\niic_abort_xfer(dev);\r\nelse\r\nret = iic_xfer_result(dev);\r\nDBG2("%d: iic_wait_for_tc -> %d\n", dev->idx, ret);\r\nreturn ret;\r\n}\r\nstatic int iic_xfer_bytes(struct ibm_iic_private* dev, struct i2c_msg* pm,\r\nint combined_xfer)\r\n{\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nchar* buf = pm->buf;\r\nint i, j, loops, ret = 0;\r\nint len = pm->len;\r\nu8 cntl = (in_8(&iic->cntl) & CNTL_AMD) | CNTL_PT;\r\nif (pm->flags & I2C_M_RD)\r\ncntl |= CNTL_RW;\r\nloops = (len + 3) / 4;\r\nfor (i = 0; i < loops; ++i, len -= 4){\r\nint count = len > 4 ? 4 : len;\r\nu8 cmd = cntl | ((count - 1) << CNTL_TCT_SHIFT);\r\nif (!(cntl & CNTL_RW))\r\nfor (j = 0; j < count; ++j)\r\nout_8((void __iomem *)&iic->mdbuf, *buf++);\r\nif (i < loops - 1)\r\ncmd |= CNTL_CHT;\r\nelse if (combined_xfer)\r\ncmd |= CNTL_RPST;\r\nDBG2("%d: xfer_bytes, %d, CNTL = 0x%02x\n", dev->idx, count, cmd);\r\nout_8(&iic->cntl, cmd);\r\nret = iic_wait_for_tc(dev);\r\nif (unlikely(ret < 0))\r\nbreak;\r\nelse if (unlikely(ret != count)){\r\nDBG("%d: xfer_bytes, requested %d, transferred %d\n",\r\ndev->idx, count, ret);\r\nif (combined_xfer || (i < loops - 1))\r\niic_abort_xfer(dev);\r\nret = -EREMOTEIO;\r\nbreak;\r\n}\r\nif (cntl & CNTL_RW)\r\nfor (j = 0; j < count; ++j)\r\n*buf++ = in_8((void __iomem *)&iic->mdbuf);\r\n}\r\nreturn ret > 0 ? 0 : ret;\r\n}\r\nstatic inline void iic_address(struct ibm_iic_private* dev, struct i2c_msg* msg)\r\n{\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nu16 addr = msg->addr;\r\nDBG2("%d: iic_address, 0x%03x (%d-bit)\n", dev->idx,\r\naddr, msg->flags & I2C_M_TEN ? 10 : 7);\r\nif (msg->flags & I2C_M_TEN){\r\nout_8(&iic->cntl, CNTL_AMD);\r\nout_8(&iic->lmadr, addr);\r\nout_8(&iic->hmadr, 0xf0 | ((addr >> 7) & 0x06));\r\n}\r\nelse {\r\nout_8(&iic->cntl, 0);\r\nout_8(&iic->lmadr, addr << 1);\r\n}\r\n}\r\nstatic inline int iic_invalid_address(const struct i2c_msg* p)\r\n{\r\nreturn (p->addr > 0x3ff) || (!(p->flags & I2C_M_TEN) && (p->addr > 0x7f));\r\n}\r\nstatic inline int iic_address_neq(const struct i2c_msg* p1,\r\nconst struct i2c_msg* p2)\r\n{\r\nreturn (p1->addr != p2->addr)\r\n|| ((p1->flags & I2C_M_TEN) != (p2->flags & I2C_M_TEN));\r\n}\r\nstatic int iic_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct ibm_iic_private* dev = (struct ibm_iic_private*)(i2c_get_adapdata(adap));\r\nvolatile struct iic_regs __iomem *iic = dev->vaddr;\r\nint i, ret = 0;\r\nDBG2("%d: iic_xfer, %d msg(s)\n", dev->idx, num);\r\nif (!num)\r\nreturn 0;\r\nif (unlikely(iic_invalid_address(&msgs[0]))){\r\nDBG("%d: invalid address 0x%03x (%d-bit)\n", dev->idx,\r\nmsgs[0].addr, msgs[0].flags & I2C_M_TEN ? 10 : 7);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num; ++i){\r\nif (unlikely(msgs[i].len <= 0)){\r\nif (num == 1 && !msgs[0].len){\r\nreturn iic_smbus_quick(dev, &msgs[0]);\r\n}\r\nDBG("%d: invalid len %d in msg[%d]\n", dev->idx,\r\nmsgs[i].len, i);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(iic_address_neq(&msgs[0], &msgs[i]))){\r\nDBG("%d: invalid addr in msg[%d]\n", dev->idx, i);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (unlikely((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE)){\r\nDBG("%d: iic_xfer, bus is not free\n", dev->idx);\r\niic_dev_reset(dev);\r\nif ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){\r\nDBG("%d: iic_xfer, bus is still not free\n", dev->idx);\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nelse {\r\nout_8(&iic->mdcntl, in_8(&iic->mdcntl) | MDCNTL_FMDB);\r\n}\r\niic_address(dev, &msgs[0]);\r\nfor (i = 0; i < num && !ret; ++i)\r\nret = iic_xfer_bytes(dev, &msgs[i], i < num - 1);\r\nreturn ret < 0 ? ret : num;\r\n}\r\nstatic u32 iic_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;\r\n}\r\nstatic inline u8 iic_clckdiv(unsigned int opb)\r\n{\r\nif (!opb){\r\nprintk(KERN_WARNING "ibm-iic: using compatibility value for OPB freq,"\r\n" fix your board specific setup\n");\r\nopb = 50000000;\r\n}\r\nopb /= 1000000;\r\nif (opb < 20 || opb > 150){\r\nprintk(KERN_WARNING "ibm-iic: invalid OPB clock frequency %u MHz\n",\r\nopb);\r\nopb = opb < 20 ? 20 : 150;\r\n}\r\nreturn (u8)((opb + 9) / 10 - 1);\r\n}\r\nstatic int iic_request_irq(struct platform_device *ofdev,\r\nstruct ibm_iic_private *dev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nint irq;\r\nif (iic_force_poll)\r\nreturn 0;\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\ndev_err(&ofdev->dev, "irq_of_parse_and_map failed\n");\r\nreturn 0;\r\n}\r\niic_interrupt_mode(dev, 0);\r\nif (request_irq(irq, iic_handler, 0, "IBM IIC", dev)) {\r\ndev_err(&ofdev->dev, "request_irq %d failed\n", irq);\r\nreturn 0;\r\n}\r\nreturn irq;\r\n}\r\nstatic int iic_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct ibm_iic_private *dev;\r\nstruct i2c_adapter *adap;\r\nconst u32 *freq;\r\nint ret;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(&ofdev->dev, "failed to allocate device data\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(ofdev, dev);\r\ndev->vaddr = of_iomap(np, 0);\r\nif (dev->vaddr == NULL) {\r\ndev_err(&ofdev->dev, "failed to iomap device\n");\r\nret = -ENXIO;\r\ngoto error_cleanup;\r\n}\r\ninit_waitqueue_head(&dev->wq);\r\ndev->irq = iic_request_irq(ofdev, dev);\r\nif (!dev->irq)\r\ndev_warn(&ofdev->dev, "using polling mode\n");\r\nif (iic_force_fast || of_get_property(np, "fast-mode", NULL))\r\ndev->fast_mode = 1;\r\nfreq = of_get_property(np, "clock-frequency", NULL);\r\nif (freq == NULL) {\r\nfreq = of_get_property(np->parent, "clock-frequency", NULL);\r\nif (freq == NULL) {\r\ndev_err(&ofdev->dev, "Unable to get bus frequency\n");\r\nret = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\n}\r\ndev->clckdiv = iic_clckdiv(*freq);\r\ndev_dbg(&ofdev->dev, "clckdiv = %d\n", dev->clckdiv);\r\niic_dev_init(dev);\r\nadap = &dev->adap;\r\nadap->dev.parent = &ofdev->dev;\r\nadap->dev.of_node = of_node_get(np);\r\nstrlcpy(adap->name, "IBM IIC", sizeof(adap->name));\r\ni2c_set_adapdata(adap, dev);\r\nadap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nadap->algo = &iic_algo;\r\nadap->timeout = HZ;\r\nret = i2c_add_adapter(adap);\r\nif (ret < 0) {\r\ndev_err(&ofdev->dev, "failed to register i2c adapter\n");\r\ngoto error_cleanup;\r\n}\r\ndev_info(&ofdev->dev, "using %s mode\n",\r\ndev->fast_mode ? "fast (400 kHz)" : "standard (100 kHz)");\r\nreturn 0;\r\nerror_cleanup:\r\nif (dev->irq) {\r\niic_interrupt_mode(dev, 0);\r\nfree_irq(dev->irq, dev);\r\n}\r\nif (dev->vaddr)\r\niounmap(dev->vaddr);\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nstatic int iic_remove(struct platform_device *ofdev)\r\n{\r\nstruct ibm_iic_private *dev = platform_get_drvdata(ofdev);\r\ni2c_del_adapter(&dev->adap);\r\nif (dev->irq) {\r\niic_interrupt_mode(dev, 0);\r\nfree_irq(dev->irq, dev);\r\n}\r\niounmap(dev->vaddr);\r\nkfree(dev);\r\nreturn 0;\r\n}
