static inline struct mtk_drm_crtc *to_mtk_crtc(struct drm_crtc *c)\r\n{\r\nreturn container_of(c, struct mtk_drm_crtc, base);\r\n}\r\nstatic inline struct mtk_crtc_state *to_mtk_crtc_state(struct drm_crtc_state *s)\r\n{\r\nreturn container_of(s, struct mtk_crtc_state, base);\r\n}\r\nstatic void mtk_drm_crtc_finish_page_flip(struct mtk_drm_crtc *mtk_crtc)\r\n{\r\nstruct drm_crtc *crtc = &mtk_crtc->base;\r\nunsigned long flags;\r\nspin_lock_irqsave(&crtc->dev->event_lock, flags);\r\ndrm_crtc_send_vblank_event(crtc, mtk_crtc->event);\r\ndrm_crtc_vblank_put(crtc);\r\nmtk_crtc->event = NULL;\r\nspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\r\n}\r\nstatic void mtk_drm_finish_page_flip(struct mtk_drm_crtc *mtk_crtc)\r\n{\r\ndrm_crtc_handle_vblank(&mtk_crtc->base);\r\nif (mtk_crtc->pending_needs_vblank) {\r\nmtk_drm_crtc_finish_page_flip(mtk_crtc);\r\nmtk_crtc->pending_needs_vblank = false;\r\n}\r\n}\r\nstatic void mtk_drm_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\r\nint i;\r\nfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++)\r\nclk_unprepare(mtk_crtc->ddp_comp[i]->clk);\r\nmtk_disp_mutex_put(mtk_crtc->mutex);\r\ndrm_crtc_cleanup(crtc);\r\n}\r\nstatic void mtk_drm_crtc_reset(struct drm_crtc *crtc)\r\n{\r\nstruct mtk_crtc_state *state;\r\nif (crtc->state) {\r\nif (crtc->state->mode_blob)\r\ndrm_property_unreference_blob(crtc->state->mode_blob);\r\nstate = to_mtk_crtc_state(crtc->state);\r\nmemset(state, 0, sizeof(*state));\r\n} else {\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn;\r\ncrtc->state = &state->base;\r\n}\r\nstate->base.crtc = crtc;\r\n}\r\nstatic struct drm_crtc_state *mtk_drm_crtc_duplicate_state(struct drm_crtc *crtc)\r\n{\r\nstruct mtk_crtc_state *state;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\n__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\r\nWARN_ON(state->base.crtc != crtc);\r\nstate->base.crtc = crtc;\r\nreturn &state->base;\r\n}\r\nstatic void mtk_drm_crtc_destroy_state(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\n__drm_atomic_helper_crtc_destroy_state(state);\r\nkfree(to_mtk_crtc_state(state));\r\n}\r\nstatic bool mtk_drm_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void mtk_drm_crtc_mode_set_nofb(struct drm_crtc *crtc)\r\n{\r\nstruct mtk_crtc_state *state = to_mtk_crtc_state(crtc->state);\r\nstate->pending_width = crtc->mode.hdisplay;\r\nstate->pending_height = crtc->mode.vdisplay;\r\nstate->pending_vrefresh = crtc->mode.vrefresh;\r\nwmb();\r\nstate->pending_config = true;\r\n}\r\nint mtk_drm_crtc_enable_vblank(struct drm_device *drm, unsigned int pipe)\r\n{\r\nstruct mtk_drm_private *priv = drm->dev_private;\r\nstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(priv->crtc[pipe]);\r\nstruct mtk_ddp_comp *ovl = mtk_crtc->ddp_comp[0];\r\nmtk_ddp_comp_enable_vblank(ovl, &mtk_crtc->base);\r\nreturn 0;\r\n}\r\nvoid mtk_drm_crtc_disable_vblank(struct drm_device *drm, unsigned int pipe)\r\n{\r\nstruct mtk_drm_private *priv = drm->dev_private;\r\nstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(priv->crtc[pipe]);\r\nstruct mtk_ddp_comp *ovl = mtk_crtc->ddp_comp[0];\r\nmtk_ddp_comp_disable_vblank(ovl);\r\n}\r\nstatic int mtk_crtc_ddp_clk_enable(struct mtk_drm_crtc *mtk_crtc)\r\n{\r\nint ret;\r\nint i;\r\nDRM_DEBUG_DRIVER("%s\n", __func__);\r\nfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\r\nret = clk_enable(mtk_crtc->ddp_comp[i]->clk);\r\nif (ret) {\r\nDRM_ERROR("Failed to enable clock %d: %d\n", i, ret);\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nwhile (--i >= 0)\r\nclk_disable(mtk_crtc->ddp_comp[i]->clk);\r\nreturn ret;\r\n}\r\nstatic void mtk_crtc_ddp_clk_disable(struct mtk_drm_crtc *mtk_crtc)\r\n{\r\nint i;\r\nDRM_DEBUG_DRIVER("%s\n", __func__);\r\nfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++)\r\nclk_disable(mtk_crtc->ddp_comp[i]->clk);\r\n}\r\nstatic int mtk_crtc_ddp_hw_init(struct mtk_drm_crtc *mtk_crtc)\r\n{\r\nstruct drm_crtc *crtc = &mtk_crtc->base;\r\nunsigned int width, height, vrefresh;\r\nint ret;\r\nint i;\r\nDRM_DEBUG_DRIVER("%s\n", __func__);\r\nif (WARN_ON(!crtc->state))\r\nreturn -EINVAL;\r\nwidth = crtc->state->adjusted_mode.hdisplay;\r\nheight = crtc->state->adjusted_mode.vdisplay;\r\nvrefresh = crtc->state->adjusted_mode.vrefresh;\r\nret = pm_runtime_get_sync(crtc->dev->dev);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to enable power domain: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = mtk_disp_mutex_prepare(mtk_crtc->mutex);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to enable mutex clock: %d\n", ret);\r\ngoto err_pm_runtime_put;\r\n}\r\nret = mtk_crtc_ddp_clk_enable(mtk_crtc);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to enable component clocks: %d\n", ret);\r\ngoto err_mutex_unprepare;\r\n}\r\nDRM_DEBUG_DRIVER("mediatek_ddp_ddp_path_setup\n");\r\nfor (i = 0; i < mtk_crtc->ddp_comp_nr - 1; i++) {\r\nmtk_ddp_add_comp_to_path(mtk_crtc->config_regs,\r\nmtk_crtc->ddp_comp[i]->id,\r\nmtk_crtc->ddp_comp[i + 1]->id);\r\nmtk_disp_mutex_add_comp(mtk_crtc->mutex,\r\nmtk_crtc->ddp_comp[i]->id);\r\n}\r\nmtk_disp_mutex_add_comp(mtk_crtc->mutex, mtk_crtc->ddp_comp[i]->id);\r\nmtk_disp_mutex_enable(mtk_crtc->mutex);\r\nfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\r\nstruct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[i];\r\nmtk_ddp_comp_config(comp, width, height, vrefresh);\r\nmtk_ddp_comp_start(comp);\r\n}\r\nfor (i = 0; i < OVL_LAYER_NR; i++) {\r\nstruct drm_plane *plane = &mtk_crtc->planes[i].base;\r\nstruct mtk_plane_state *plane_state;\r\nplane_state = to_mtk_plane_state(plane->state);\r\nmtk_ddp_comp_layer_config(mtk_crtc->ddp_comp[0], i,\r\nplane_state);\r\n}\r\nreturn 0;\r\nerr_mutex_unprepare:\r\nmtk_disp_mutex_unprepare(mtk_crtc->mutex);\r\nerr_pm_runtime_put:\r\npm_runtime_put(crtc->dev->dev);\r\nreturn ret;\r\n}\r\nstatic void mtk_crtc_ddp_hw_fini(struct mtk_drm_crtc *mtk_crtc)\r\n{\r\nstruct drm_device *drm = mtk_crtc->base.dev;\r\nint i;\r\nDRM_DEBUG_DRIVER("%s\n", __func__);\r\nfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++)\r\nmtk_ddp_comp_stop(mtk_crtc->ddp_comp[i]);\r\nfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++)\r\nmtk_disp_mutex_remove_comp(mtk_crtc->mutex,\r\nmtk_crtc->ddp_comp[i]->id);\r\nmtk_disp_mutex_disable(mtk_crtc->mutex);\r\nfor (i = 0; i < mtk_crtc->ddp_comp_nr - 1; i++) {\r\nmtk_ddp_remove_comp_from_path(mtk_crtc->config_regs,\r\nmtk_crtc->ddp_comp[i]->id,\r\nmtk_crtc->ddp_comp[i + 1]->id);\r\nmtk_disp_mutex_remove_comp(mtk_crtc->mutex,\r\nmtk_crtc->ddp_comp[i]->id);\r\n}\r\nmtk_disp_mutex_remove_comp(mtk_crtc->mutex, mtk_crtc->ddp_comp[i]->id);\r\nmtk_crtc_ddp_clk_disable(mtk_crtc);\r\nmtk_disp_mutex_unprepare(mtk_crtc->mutex);\r\npm_runtime_put(drm->dev);\r\n}\r\nstatic void mtk_drm_crtc_enable(struct drm_crtc *crtc)\r\n{\r\nstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\r\nstruct mtk_ddp_comp *ovl = mtk_crtc->ddp_comp[0];\r\nint ret;\r\nDRM_DEBUG_DRIVER("%s %d\n", __func__, crtc->base.id);\r\nret = mtk_smi_larb_get(ovl->larb_dev);\r\nif (ret) {\r\nDRM_ERROR("Failed to get larb: %d\n", ret);\r\nreturn;\r\n}\r\nret = mtk_crtc_ddp_hw_init(mtk_crtc);\r\nif (ret) {\r\nmtk_smi_larb_put(ovl->larb_dev);\r\nreturn;\r\n}\r\ndrm_crtc_vblank_on(crtc);\r\nmtk_crtc->enabled = true;\r\n}\r\nstatic void mtk_drm_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\r\nstruct mtk_ddp_comp *ovl = mtk_crtc->ddp_comp[0];\r\nint i;\r\nDRM_DEBUG_DRIVER("%s %d\n", __func__, crtc->base.id);\r\nif (!mtk_crtc->enabled)\r\nreturn;\r\nfor (i = 0; i < OVL_LAYER_NR; i++) {\r\nstruct drm_plane *plane = &mtk_crtc->planes[i].base;\r\nstruct mtk_plane_state *plane_state;\r\nplane_state = to_mtk_plane_state(plane->state);\r\nplane_state->pending.enable = false;\r\nplane_state->pending.config = true;\r\n}\r\nmtk_crtc->pending_planes = true;\r\ndrm_crtc_wait_one_vblank(crtc);\r\ndrm_crtc_vblank_off(crtc);\r\nmtk_crtc_ddp_hw_fini(mtk_crtc);\r\nmtk_smi_larb_put(ovl->larb_dev);\r\nmtk_crtc->enabled = false;\r\n}\r\nstatic void mtk_drm_crtc_atomic_begin(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct mtk_crtc_state *state = to_mtk_crtc_state(crtc->state);\r\nstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\r\nif (mtk_crtc->event && state->base.event)\r\nDRM_ERROR("new event while there is still a pending event\n");\r\nif (state->base.event) {\r\nstate->base.event->pipe = drm_crtc_index(crtc);\r\nWARN_ON(drm_crtc_vblank_get(crtc) != 0);\r\nmtk_crtc->event = state->base.event;\r\nstate->base.event = NULL;\r\n}\r\n}\r\nstatic void mtk_drm_crtc_atomic_flush(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\r\nunsigned int pending_planes = 0;\r\nint i;\r\nif (mtk_crtc->event)\r\nmtk_crtc->pending_needs_vblank = true;\r\nfor (i = 0; i < OVL_LAYER_NR; i++) {\r\nstruct drm_plane *plane = &mtk_crtc->planes[i].base;\r\nstruct mtk_plane_state *plane_state;\r\nplane_state = to_mtk_plane_state(plane->state);\r\nif (plane_state->pending.dirty) {\r\nplane_state->pending.config = true;\r\nplane_state->pending.dirty = false;\r\npending_planes |= BIT(i);\r\n}\r\n}\r\nif (pending_planes)\r\nmtk_crtc->pending_planes = true;\r\n}\r\nstatic int mtk_drm_crtc_init(struct drm_device *drm,\r\nstruct mtk_drm_crtc *mtk_crtc,\r\nstruct drm_plane *primary,\r\nstruct drm_plane *cursor, unsigned int pipe)\r\n{\r\nint ret;\r\nret = drm_crtc_init_with_planes(drm, &mtk_crtc->base, primary, cursor,\r\n&mtk_crtc_funcs, NULL);\r\nif (ret)\r\ngoto err_cleanup_crtc;\r\ndrm_crtc_helper_add(&mtk_crtc->base, &mtk_crtc_helper_funcs);\r\nreturn 0;\r\nerr_cleanup_crtc:\r\ndrm_crtc_cleanup(&mtk_crtc->base);\r\nreturn ret;\r\n}\r\nvoid mtk_crtc_ddp_irq(struct drm_crtc *crtc, struct mtk_ddp_comp *ovl)\r\n{\r\nstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\r\nstruct mtk_crtc_state *state = to_mtk_crtc_state(mtk_crtc->base.state);\r\nunsigned int i;\r\nif (state->pending_config) {\r\nmtk_ddp_comp_config(ovl, state->pending_width,\r\nstate->pending_height,\r\nstate->pending_vrefresh);\r\nstate->pending_config = false;\r\n}\r\nif (mtk_crtc->pending_planes) {\r\nfor (i = 0; i < OVL_LAYER_NR; i++) {\r\nstruct drm_plane *plane = &mtk_crtc->planes[i].base;\r\nstruct mtk_plane_state *plane_state;\r\nplane_state = to_mtk_plane_state(plane->state);\r\nif (plane_state->pending.config) {\r\nmtk_ddp_comp_layer_config(ovl, i, plane_state);\r\nplane_state->pending.config = false;\r\n}\r\n}\r\nmtk_crtc->pending_planes = false;\r\n}\r\nmtk_drm_finish_page_flip(mtk_crtc);\r\n}\r\nint mtk_drm_crtc_create(struct drm_device *drm_dev,\r\nconst enum mtk_ddp_comp_id *path, unsigned int path_len)\r\n{\r\nstruct mtk_drm_private *priv = drm_dev->dev_private;\r\nstruct device *dev = drm_dev->dev;\r\nstruct mtk_drm_crtc *mtk_crtc;\r\nenum drm_plane_type type;\r\nunsigned int zpos;\r\nint pipe = priv->num_pipes;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < path_len; i++) {\r\nenum mtk_ddp_comp_id comp_id = path[i];\r\nstruct device_node *node;\r\nnode = priv->comp_node[comp_id];\r\nif (!node) {\r\ndev_info(dev,\r\n"Not creating crtc %d because component %d is disabled or missing\n",\r\npipe, comp_id);\r\nreturn 0;\r\n}\r\n}\r\nmtk_crtc = devm_kzalloc(dev, sizeof(*mtk_crtc), GFP_KERNEL);\r\nif (!mtk_crtc)\r\nreturn -ENOMEM;\r\nmtk_crtc->config_regs = priv->config_regs;\r\nmtk_crtc->ddp_comp_nr = path_len;\r\nmtk_crtc->ddp_comp = devm_kmalloc_array(dev, mtk_crtc->ddp_comp_nr,\r\nsizeof(*mtk_crtc->ddp_comp),\r\nGFP_KERNEL);\r\nmtk_crtc->mutex = mtk_disp_mutex_get(priv->mutex_dev, pipe);\r\nif (IS_ERR(mtk_crtc->mutex)) {\r\nret = PTR_ERR(mtk_crtc->mutex);\r\ndev_err(dev, "Failed to get mutex: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\r\nenum mtk_ddp_comp_id comp_id = path[i];\r\nstruct mtk_ddp_comp *comp;\r\nstruct device_node *node;\r\nnode = priv->comp_node[comp_id];\r\ncomp = priv->ddp_comp[comp_id];\r\nif (!comp) {\r\ndev_err(dev, "Component %s not initialized\n",\r\nnode->full_name);\r\nret = -ENODEV;\r\ngoto unprepare;\r\n}\r\nret = clk_prepare(comp->clk);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to prepare clock for component %s: %d\n",\r\nnode->full_name, ret);\r\ngoto unprepare;\r\n}\r\nmtk_crtc->ddp_comp[i] = comp;\r\n}\r\nfor (zpos = 0; zpos < OVL_LAYER_NR; zpos++) {\r\ntype = (zpos == 0) ? DRM_PLANE_TYPE_PRIMARY :\r\n(zpos == 1) ? DRM_PLANE_TYPE_CURSOR :\r\nDRM_PLANE_TYPE_OVERLAY;\r\nret = mtk_plane_init(drm_dev, &mtk_crtc->planes[zpos],\r\nBIT(pipe), type, zpos);\r\nif (ret)\r\ngoto unprepare;\r\n}\r\nret = mtk_drm_crtc_init(drm_dev, mtk_crtc, &mtk_crtc->planes[0].base,\r\n&mtk_crtc->planes[1].base, pipe);\r\nif (ret < 0)\r\ngoto unprepare;\r\npriv->crtc[pipe] = &mtk_crtc->base;\r\npriv->num_pipes++;\r\nreturn 0;\r\nunprepare:\r\nwhile (--i >= 0)\r\nclk_unprepare(mtk_crtc->ddp_comp[i]->clk);\r\nreturn ret;\r\n}
