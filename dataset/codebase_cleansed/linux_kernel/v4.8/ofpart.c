static bool node_has_compatible(struct device_node *pp)\r\n{\r\nreturn of_get_property(pp, "compatible", NULL);\r\n}\r\nstatic int parse_ofpart_partitions(struct mtd_info *master,\r\nconst struct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct mtd_partition *parts;\r\nstruct device_node *mtd_node;\r\nstruct device_node *ofpart_node;\r\nconst char *partname;\r\nstruct device_node *pp;\r\nint nr_parts, i, ret = 0;\r\nbool dedicated = true;\r\nmtd_node = mtd_get_of_node(master);\r\nif (!mtd_node)\r\nreturn 0;\r\nofpart_node = of_get_child_by_name(mtd_node, "partitions");\r\nif (!ofpart_node) {\r\npr_debug("%s: 'partitions' subnode not found on %s. Trying to parse direct subnodes as partitions.\n",\r\nmaster->name, mtd_node->full_name);\r\nofpart_node = mtd_node;\r\ndedicated = false;\r\n} else if (!of_device_is_compatible(ofpart_node, "fixed-partitions")) {\r\nreturn 0;\r\n}\r\nnr_parts = 0;\r\nfor_each_child_of_node(ofpart_node, pp) {\r\nif (!dedicated && node_has_compatible(pp))\r\ncontinue;\r\nnr_parts++;\r\n}\r\nif (nr_parts == 0)\r\nreturn 0;\r\nparts = kzalloc(nr_parts * sizeof(*parts), GFP_KERNEL);\r\nif (!parts)\r\nreturn -ENOMEM;\r\ni = 0;\r\nfor_each_child_of_node(ofpart_node, pp) {\r\nconst __be32 *reg;\r\nint len;\r\nint a_cells, s_cells;\r\nif (!dedicated && node_has_compatible(pp))\r\ncontinue;\r\nreg = of_get_property(pp, "reg", &len);\r\nif (!reg) {\r\nif (dedicated) {\r\npr_debug("%s: ofpart partition %s (%s) missing reg property.\n",\r\nmaster->name, pp->full_name,\r\nmtd_node->full_name);\r\ngoto ofpart_fail;\r\n} else {\r\nnr_parts--;\r\ncontinue;\r\n}\r\n}\r\na_cells = of_n_addr_cells(pp);\r\ns_cells = of_n_size_cells(pp);\r\nif (len / 4 != a_cells + s_cells) {\r\npr_debug("%s: ofpart partition %s (%s) error parsing reg property.\n",\r\nmaster->name, pp->full_name,\r\nmtd_node->full_name);\r\ngoto ofpart_fail;\r\n}\r\nparts[i].offset = of_read_number(reg, a_cells);\r\nparts[i].size = of_read_number(reg + a_cells, s_cells);\r\npartname = of_get_property(pp, "label", &len);\r\nif (!partname)\r\npartname = of_get_property(pp, "name", &len);\r\nparts[i].name = partname;\r\nif (of_get_property(pp, "read-only", &len))\r\nparts[i].mask_flags |= MTD_WRITEABLE;\r\nif (of_get_property(pp, "lock", &len))\r\nparts[i].mask_flags |= MTD_POWERUP_LOCK;\r\ni++;\r\n}\r\nif (!nr_parts)\r\ngoto ofpart_none;\r\n*pparts = parts;\r\nreturn nr_parts;\r\nofpart_fail:\r\npr_err("%s: error parsing ofpart partition %s (%s)\n",\r\nmaster->name, pp->full_name, mtd_node->full_name);\r\nret = -EINVAL;\r\nofpart_none:\r\nof_node_put(pp);\r\nkfree(parts);\r\nreturn ret;\r\n}\r\nstatic int parse_ofoldpart_partitions(struct mtd_info *master,\r\nconst struct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct mtd_partition *parts;\r\nstruct device_node *dp;\r\nint i, plen, nr_parts;\r\nconst struct {\r\n__be32 offset, len;\r\n} *part;\r\nconst char *names;\r\ndp = mtd_get_of_node(master);\r\nif (!dp)\r\nreturn 0;\r\npart = of_get_property(dp, "partitions", &plen);\r\nif (!part)\r\nreturn 0;\r\npr_warning("Device tree uses obsolete partition map binding: %s\n",\r\ndp->full_name);\r\nnr_parts = plen / sizeof(part[0]);\r\nparts = kzalloc(nr_parts * sizeof(*parts), GFP_KERNEL);\r\nif (!parts)\r\nreturn -ENOMEM;\r\nnames = of_get_property(dp, "partition-names", &plen);\r\nfor (i = 0; i < nr_parts; i++) {\r\nparts[i].offset = be32_to_cpu(part->offset);\r\nparts[i].size = be32_to_cpu(part->len) & ~1;\r\nif (be32_to_cpu(part->len) & 1)\r\nparts[i].mask_flags = MTD_WRITEABLE;\r\nif (names && (plen > 0)) {\r\nint len = strlen(names) + 1;\r\nparts[i].name = names;\r\nplen -= len;\r\nnames += len;\r\n} else {\r\nparts[i].name = "unnamed";\r\n}\r\npart++;\r\n}\r\n*pparts = parts;\r\nreturn nr_parts;\r\n}\r\nstatic int __init ofpart_parser_init(void)\r\n{\r\nregister_mtd_parser(&ofpart_parser);\r\nregister_mtd_parser(&ofoldpart_parser);\r\nreturn 0;\r\n}\r\nstatic void __exit ofpart_parser_exit(void)\r\n{\r\nderegister_mtd_parser(&ofpart_parser);\r\nderegister_mtd_parser(&ofoldpart_parser);\r\n}
