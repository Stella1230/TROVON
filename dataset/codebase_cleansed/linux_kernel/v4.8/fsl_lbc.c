u32 fsl_lbc_addr(phys_addr_t addr_base)\r\n{\r\nstruct device_node *np = fsl_lbc_ctrl_dev->dev->of_node;\r\nu32 addr = addr_base & 0xffff8000;\r\nif (of_device_is_compatible(np, "fsl,elbc"))\r\nreturn addr;\r\nreturn addr | ((addr_base & 0x300000000ull) >> 19);\r\n}\r\nint fsl_lbc_find(phys_addr_t addr_base)\r\n{\r\nint i;\r\nstruct fsl_lbc_regs __iomem *lbc;\r\nif (!fsl_lbc_ctrl_dev || !fsl_lbc_ctrl_dev->regs)\r\nreturn -ENODEV;\r\nlbc = fsl_lbc_ctrl_dev->regs;\r\nfor (i = 0; i < ARRAY_SIZE(lbc->bank); i++) {\r\nu32 br = in_be32(&lbc->bank[i].br);\r\nu32 or = in_be32(&lbc->bank[i].or);\r\nif (br & BR_V && (br & or & BR_BA) == fsl_lbc_addr(addr_base))\r\nreturn i;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint fsl_upm_find(phys_addr_t addr_base, struct fsl_upm *upm)\r\n{\r\nint bank;\r\nu32 br;\r\nstruct fsl_lbc_regs __iomem *lbc;\r\nbank = fsl_lbc_find(addr_base);\r\nif (bank < 0)\r\nreturn bank;\r\nif (!fsl_lbc_ctrl_dev || !fsl_lbc_ctrl_dev->regs)\r\nreturn -ENODEV;\r\nlbc = fsl_lbc_ctrl_dev->regs;\r\nbr = in_be32(&lbc->bank[bank].br);\r\nswitch (br & BR_MSEL) {\r\ncase BR_MS_UPMA:\r\nupm->mxmr = &lbc->mamr;\r\nbreak;\r\ncase BR_MS_UPMB:\r\nupm->mxmr = &lbc->mbmr;\r\nbreak;\r\ncase BR_MS_UPMC:\r\nupm->mxmr = &lbc->mcmr;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (br & BR_PS) {\r\ncase BR_PS_8:\r\nupm->width = 8;\r\nbreak;\r\ncase BR_PS_16:\r\nupm->width = 16;\r\nbreak;\r\ncase BR_PS_32:\r\nupm->width = 32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint fsl_upm_run_pattern(struct fsl_upm *upm, void __iomem *io_base, u32 mar)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nif (!fsl_lbc_ctrl_dev || !fsl_lbc_ctrl_dev->regs)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&fsl_lbc_lock, flags);\r\nout_be32(&fsl_lbc_ctrl_dev->regs->mar, mar);\r\nswitch (upm->width) {\r\ncase 8:\r\nout_8(io_base, 0x0);\r\nbreak;\r\ncase 16:\r\nout_be16(io_base, 0x0);\r\nbreak;\r\ncase 32:\r\nout_be32(io_base, 0x0);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&fsl_lbc_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fsl_lbc_ctrl_init(struct fsl_lbc_ctrl *ctrl,\r\nstruct device_node *node)\r\n{\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nsetbits32(&lbc->ltesr, LTESR_CLEAR);\r\nout_be32(&lbc->lteatr, 0);\r\nout_be32(&lbc->ltear, 0);\r\nout_be32(&lbc->lteccr, LTECCR_CLEAR);\r\nout_be32(&lbc->ltedr, LTEDR_ENABLE);\r\nif (of_device_is_compatible(node, "fsl,elbc"))\r\nclrsetbits_be32(&lbc->lbcr, LBCR_BMT, LBCR_BMTPS);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t fsl_lbc_ctrl_irq(int irqno, void *data)\r\n{\r\nstruct fsl_lbc_ctrl *ctrl = data;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nu32 status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fsl_lbc_lock, flags);\r\nstatus = in_be32(&lbc->ltesr);\r\nif (!status) {\r\nspin_unlock_irqrestore(&fsl_lbc_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nout_be32(&lbc->ltesr, LTESR_CLEAR);\r\nout_be32(&lbc->lteatr, 0);\r\nout_be32(&lbc->ltear, 0);\r\nctrl->irq_status = status;\r\nif (status & LTESR_BM)\r\ndev_err(ctrl->dev, "Local bus monitor time-out: "\r\n"LTESR 0x%08X\n", status);\r\nif (status & LTESR_WP)\r\ndev_err(ctrl->dev, "Write protect error: "\r\n"LTESR 0x%08X\n", status);\r\nif (status & LTESR_ATMW)\r\ndev_err(ctrl->dev, "Atomic write error: "\r\n"LTESR 0x%08X\n", status);\r\nif (status & LTESR_ATMR)\r\ndev_err(ctrl->dev, "Atomic read error: "\r\n"LTESR 0x%08X\n", status);\r\nif (status & LTESR_CS)\r\ndev_err(ctrl->dev, "Chip select error: "\r\n"LTESR 0x%08X\n", status);\r\nif (status & LTESR_FCT) {\r\ndev_err(ctrl->dev, "FCM command time-out: "\r\n"LTESR 0x%08X\n", status);\r\nsmp_wmb();\r\nwake_up(&ctrl->irq_wait);\r\n}\r\nif (status & LTESR_PAR) {\r\ndev_err(ctrl->dev, "Parity or Uncorrectable ECC error: "\r\n"LTESR 0x%08X\n", status);\r\nsmp_wmb();\r\nwake_up(&ctrl->irq_wait);\r\n}\r\nif (status & LTESR_CC) {\r\nsmp_wmb();\r\nwake_up(&ctrl->irq_wait);\r\n}\r\nif (status & ~LTESR_MASK)\r\ndev_err(ctrl->dev, "Unknown error: "\r\n"LTESR 0x%08X\n", status);\r\nspin_unlock_irqrestore(&fsl_lbc_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fsl_lbc_ctrl_probe(struct platform_device *dev)\r\n{\r\nint ret;\r\nif (!dev->dev.of_node) {\r\ndev_err(&dev->dev, "Device OF-Node is NULL");\r\nreturn -EFAULT;\r\n}\r\nfsl_lbc_ctrl_dev = kzalloc(sizeof(*fsl_lbc_ctrl_dev), GFP_KERNEL);\r\nif (!fsl_lbc_ctrl_dev)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&dev->dev, fsl_lbc_ctrl_dev);\r\nspin_lock_init(&fsl_lbc_ctrl_dev->lock);\r\ninit_waitqueue_head(&fsl_lbc_ctrl_dev->irq_wait);\r\nfsl_lbc_ctrl_dev->regs = of_iomap(dev->dev.of_node, 0);\r\nif (!fsl_lbc_ctrl_dev->regs) {\r\ndev_err(&dev->dev, "failed to get memory region\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nfsl_lbc_ctrl_dev->irq[0] = irq_of_parse_and_map(dev->dev.of_node, 0);\r\nif (!fsl_lbc_ctrl_dev->irq[0]) {\r\ndev_err(&dev->dev, "failed to get irq resource\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nfsl_lbc_ctrl_dev->dev = &dev->dev;\r\nret = fsl_lbc_ctrl_init(fsl_lbc_ctrl_dev, dev->dev.of_node);\r\nif (ret < 0)\r\ngoto err;\r\nret = request_irq(fsl_lbc_ctrl_dev->irq[0], fsl_lbc_ctrl_irq, 0,\r\n"fsl-lbc", fsl_lbc_ctrl_dev);\r\nif (ret != 0) {\r\ndev_err(&dev->dev, "failed to install irq (%d)\n",\r\nfsl_lbc_ctrl_dev->irq[0]);\r\nret = fsl_lbc_ctrl_dev->irq[0];\r\ngoto err;\r\n}\r\nfsl_lbc_ctrl_dev->irq[1] = irq_of_parse_and_map(dev->dev.of_node, 1);\r\nif (fsl_lbc_ctrl_dev->irq[1]) {\r\nret = request_irq(fsl_lbc_ctrl_dev->irq[1], fsl_lbc_ctrl_irq,\r\nIRQF_SHARED, "fsl-lbc-err", fsl_lbc_ctrl_dev);\r\nif (ret) {\r\ndev_err(&dev->dev, "failed to install irq (%d)\n",\r\nfsl_lbc_ctrl_dev->irq[1]);\r\nret = fsl_lbc_ctrl_dev->irq[1];\r\ngoto err1;\r\n}\r\n}\r\nout_be32(&fsl_lbc_ctrl_dev->regs->lteir, LTEIR_ENABLE);\r\nreturn 0;\r\nerr1:\r\nfree_irq(fsl_lbc_ctrl_dev->irq[0], fsl_lbc_ctrl_dev);\r\nerr:\r\niounmap(fsl_lbc_ctrl_dev->regs);\r\nkfree(fsl_lbc_ctrl_dev);\r\nfsl_lbc_ctrl_dev = NULL;\r\nreturn ret;\r\n}\r\nstatic int fsl_lbc_syscore_suspend(void)\r\n{\r\nstruct fsl_lbc_ctrl *ctrl;\r\nstruct fsl_lbc_regs __iomem *lbc;\r\nctrl = fsl_lbc_ctrl_dev;\r\nif (!ctrl)\r\ngoto out;\r\nlbc = ctrl->regs;\r\nif (!lbc)\r\ngoto out;\r\nctrl->saved_regs = kmalloc(sizeof(struct fsl_lbc_regs), GFP_KERNEL);\r\nif (!ctrl->saved_regs)\r\nreturn -ENOMEM;\r\n_memcpy_fromio(ctrl->saved_regs, lbc, sizeof(struct fsl_lbc_regs));\r\nout:\r\nreturn 0;\r\n}\r\nstatic void fsl_lbc_syscore_resume(void)\r\n{\r\nstruct fsl_lbc_ctrl *ctrl;\r\nstruct fsl_lbc_regs __iomem *lbc;\r\nctrl = fsl_lbc_ctrl_dev;\r\nif (!ctrl)\r\ngoto out;\r\nlbc = ctrl->regs;\r\nif (!lbc)\r\ngoto out;\r\nif (ctrl->saved_regs) {\r\n_memcpy_toio(lbc, ctrl->saved_regs,\r\nsizeof(struct fsl_lbc_regs));\r\nkfree(ctrl->saved_regs);\r\nctrl->saved_regs = NULL;\r\n}\r\nout:\r\nreturn;\r\n}\r\nstatic int __init fsl_lbc_init(void)\r\n{\r\n#ifdef CONFIG_SUSPEND\r\nregister_syscore_ops(&lbc_syscore_pm_ops);\r\n#endif\r\nreturn platform_driver_register(&fsl_lbc_ctrl_driver);\r\n}
