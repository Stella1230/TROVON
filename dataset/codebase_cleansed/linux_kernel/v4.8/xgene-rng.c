static void xgene_rng_expired_timer(unsigned long arg)\r\n{\r\nstruct xgene_rng_dev *ctx = (struct xgene_rng_dev *) arg;\r\ndisable_irq(ctx->irq);\r\nctx->failure_cnt = 0;\r\ndel_timer(&ctx->failure_timer);\r\nenable_irq(ctx->irq);\r\n}\r\nstatic void xgene_rng_start_timer(struct xgene_rng_dev *ctx)\r\n{\r\nctx->failure_timer.data = (unsigned long) ctx;\r\nctx->failure_timer.function = xgene_rng_expired_timer;\r\nctx->failure_timer.expires = jiffies + 120 * HZ;\r\nadd_timer(&ctx->failure_timer);\r\n}\r\nstatic void xgene_rng_init_fro(struct xgene_rng_dev *ctx, u32 fro_val)\r\n{\r\nwritel(fro_val, ctx->csr_base + RNG_FRODETUNE);\r\nwritel(0x00000000, ctx->csr_base + RNG_ALARMMASK);\r\nwritel(0x00000000, ctx->csr_base + RNG_ALARMSTOP);\r\nwritel(0xFFFFFFFF, ctx->csr_base + RNG_FROENABLE);\r\n}\r\nstatic void xgene_rng_chk_overflow(struct xgene_rng_dev *ctx)\r\n{\r\nu32 val;\r\nval = readl(ctx->csr_base + RNG_INTR_STS_ACK);\r\nif (val & MONOBIT_FAIL_MASK)\r\ndev_err(ctx->dev, "test monobit failure error 0x%08X\n", val);\r\nif (val & POKER_FAIL_MASK)\r\ndev_err(ctx->dev, "test poker failure error 0x%08X\n", val);\r\nif (val & LONG_RUN_FAIL_MASK)\r\ndev_err(ctx->dev, "test long run failure error 0x%08X\n", val);\r\nif (val & RUN_FAIL_MASK)\r\ndev_err(ctx->dev, "test run failure error 0x%08X\n", val);\r\nif (val & NOISE_FAIL_MASK)\r\ndev_err(ctx->dev, "noise failure error 0x%08X\n", val);\r\nif (val & STUCK_OUT_MASK)\r\ndev_err(ctx->dev, "stuck out failure error 0x%08X\n", val);\r\nif (val & SHUTDOWN_OFLO_MASK) {\r\nu32 frostopped;\r\nif (++ctx->failure_cnt == 1) {\r\nctx->failure_ts = jiffies;\r\nfrostopped = readl(ctx->csr_base + RNG_ALARMSTOP);\r\nxgene_rng_init_fro(ctx, frostopped);\r\nxgene_rng_start_timer(ctx);\r\n} else {\r\nif (time_after(ctx->failure_ts + 60 * HZ, jiffies)) {\r\ndev_err(ctx->dev,\r\n"FRO shutdown failure error 0x%08X\n",\r\nval);\r\n} else {\r\nctx->failure_ts = jiffies;\r\nctx->failure_cnt = 1;\r\nxgene_rng_start_timer(ctx);\r\n}\r\nfrostopped = readl(ctx->csr_base + RNG_ALARMSTOP);\r\nxgene_rng_init_fro(ctx, frostopped);\r\n}\r\n}\r\nwritel(val, ctx->csr_base + RNG_INTR_STS_ACK);\r\n}\r\nstatic irqreturn_t xgene_rng_irq_handler(int irq, void *id)\r\n{\r\nstruct xgene_rng_dev *ctx = (struct xgene_rng_dev *) id;\r\nxgene_rng_chk_overflow(ctx);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xgene_rng_data_present(struct hwrng *rng, int wait)\r\n{\r\nstruct xgene_rng_dev *ctx = (struct xgene_rng_dev *) rng->priv;\r\nu32 i, val = 0;\r\nfor (i = 0; i < XGENE_RNG_RETRY_COUNT; i++) {\r\nval = readl(ctx->csr_base + RNG_INTR_STS_ACK);\r\nif ((val & READY_MASK) || !wait)\r\nbreak;\r\nudelay(XGENE_RNG_RETRY_INTERVAL);\r\n}\r\nreturn (val & READY_MASK);\r\n}\r\nstatic int xgene_rng_data_read(struct hwrng *rng, u32 *data)\r\n{\r\nstruct xgene_rng_dev *ctx = (struct xgene_rng_dev *) rng->priv;\r\nint i;\r\nfor (i = 0; i < ctx->datum_size; i++)\r\ndata[i] = readl(ctx->csr_base + RNG_INOUT_0 + i * 4);\r\nwritel(READY_MASK, ctx->csr_base + RNG_INTR_STS_ACK);\r\nreturn ctx->datum_size << 2;\r\n}\r\nstatic void xgene_rng_init_internal(struct xgene_rng_dev *ctx)\r\n{\r\nu32 val;\r\nwritel(0x00000000, ctx->csr_base + RNG_CONTROL);\r\nval = MAX_REFILL_CYCLES_SET(0, 10);\r\nval = MIN_REFILL_CYCLES_SET(val, 10);\r\nwritel(val, ctx->csr_base + RNG_CONFIG);\r\nval = ALARM_THRESHOLD_SET(0, 0xFF);\r\nwritel(val, ctx->csr_base + RNG_ALARMCNT);\r\nxgene_rng_init_fro(ctx, 0);\r\nwritel(MONOBIT_FAIL_MASK |\r\nPOKER_FAIL_MASK |\r\nLONG_RUN_FAIL_MASK |\r\nRUN_FAIL_MASK |\r\nNOISE_FAIL_MASK |\r\nSTUCK_OUT_MASK |\r\nSHUTDOWN_OFLO_MASK |\r\nREADY_MASK, ctx->csr_base + RNG_INTR_STS_ACK);\r\nval = ENABLE_RNG_SET(0, 1);\r\nval = MONOBIT_FAIL_MASK_SET(val, 1);\r\nval = POKER_FAIL_MASK_SET(val, 1);\r\nval = LONG_RUN_FAIL_MASK_SET(val, 1);\r\nval = RUN_FAIL_MASK_SET(val, 1);\r\nval = NOISE_FAIL_MASK_SET(val, 1);\r\nval = STUCK_OUT_MASK_SET(val, 1);\r\nval = SHUTDOWN_OFLO_MASK_SET(val, 1);\r\nwritel(val, ctx->csr_base + RNG_CONTROL);\r\n}\r\nstatic int xgene_rng_init(struct hwrng *rng)\r\n{\r\nstruct xgene_rng_dev *ctx = (struct xgene_rng_dev *) rng->priv;\r\nctx->failure_cnt = 0;\r\ninit_timer(&ctx->failure_timer);\r\nctx->revision = readl(ctx->csr_base + RNG_EIP_REV);\r\ndev_dbg(ctx->dev, "Rev %d.%d.%d\n",\r\nMAJOR_HW_REV_RD(ctx->revision),\r\nMINOR_HW_REV_RD(ctx->revision),\r\nHW_PATCH_LEVEL_RD(ctx->revision));\r\ndev_dbg(ctx->dev, "Options 0x%08X",\r\nreadl(ctx->csr_base + RNG_OPTIONS));\r\nxgene_rng_init_internal(ctx);\r\nctx->datum_size = RNG_MAX_DATUM;\r\nreturn 0;\r\n}\r\nstatic int xgene_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct xgene_rng_dev *ctx;\r\nint rc = 0;\r\nctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, ctx);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nctx->csr_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ctx->csr_base))\r\nreturn PTR_ERR(ctx->csr_base);\r\nrc = platform_get_irq(pdev, 0);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\nreturn rc;\r\n}\r\nctx->irq = rc;\r\ndev_dbg(&pdev->dev, "APM X-Gene RNG BASE %p ALARM IRQ %d",\r\nctx->csr_base, ctx->irq);\r\nrc = devm_request_irq(&pdev->dev, ctx->irq, xgene_rng_irq_handler, 0,\r\ndev_name(&pdev->dev), ctx);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Could not request RNG alarm IRQ\n");\r\nreturn rc;\r\n}\r\nctx->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ctx->clk)) {\r\ndev_warn(&pdev->dev, "Couldn't get the clock for RNG\n");\r\n} else {\r\nrc = clk_prepare_enable(ctx->clk);\r\nif (rc) {\r\ndev_warn(&pdev->dev,\r\n"clock prepare enable failed for RNG");\r\nreturn rc;\r\n}\r\n}\r\nxgene_rng_func.priv = (unsigned long) ctx;\r\nrc = hwrng_register(&xgene_rng_func);\r\nif (rc) {\r\ndev_err(&pdev->dev, "RNG registering failed error %d\n", rc);\r\nif (!IS_ERR(ctx->clk))\r\nclk_disable_unprepare(ctx->clk);\r\nreturn rc;\r\n}\r\nrc = device_init_wakeup(&pdev->dev, 1);\r\nif (rc) {\r\ndev_err(&pdev->dev, "RNG device_init_wakeup failed error %d\n",\r\nrc);\r\nif (!IS_ERR(ctx->clk))\r\nclk_disable_unprepare(ctx->clk);\r\nhwrng_unregister(&xgene_rng_func);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgene_rng_remove(struct platform_device *pdev)\r\n{\r\nstruct xgene_rng_dev *ctx = platform_get_drvdata(pdev);\r\nint rc;\r\nrc = device_init_wakeup(&pdev->dev, 0);\r\nif (rc)\r\ndev_err(&pdev->dev, "RNG init wakeup failed error %d\n", rc);\r\nif (!IS_ERR(ctx->clk))\r\nclk_disable_unprepare(ctx->clk);\r\nhwrng_unregister(&xgene_rng_func);\r\nreturn rc;\r\n}
