static int qsfp_read(struct qib_pportdata *ppd, int addr, void *bp, int len)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu32 out, mask;\r\nint ret, cnt, pass = 0;\r\nint stuck = 0;\r\nu8 *buff = bp;\r\nret = mutex_lock_interruptible(&dd->eep_lock);\r\nif (ret)\r\ngoto no_unlock;\r\nif (dd->twsi_eeprom_dev == QIB_TWSI_NO_DEV) {\r\nret = -ENXIO;\r\ngoto bail;\r\n}\r\nmask = QSFP_GPIO_MOD_SEL_N | QSFP_GPIO_MOD_RST_N | QSFP_GPIO_LP_MODE;\r\nout = QSFP_GPIO_MOD_RST_N | QSFP_GPIO_LP_MODE;\r\nif (ppd->hw_pidx) {\r\nmask <<= QSFP_GPIO_PORT2_SHIFT;\r\nout <<= QSFP_GPIO_PORT2_SHIFT;\r\n}\r\ndd->f_gpio_mod(dd, out, mask, mask);\r\nmsleep(20);\r\nret = qib_twsi_reset(dd);\r\nif (ret) {\r\nqib_dev_porterr(dd, ppd->port,\r\n"QSFP interface Reset for read failed\n");\r\nret = -EIO;\r\nstuck = 1;\r\ngoto deselect;\r\n}\r\ncnt = 0;\r\nwhile (cnt < len) {\r\nunsigned in_page;\r\nint wlen = len - cnt;\r\nin_page = addr % QSFP_PAGESIZE;\r\nif ((in_page + wlen) > QSFP_PAGESIZE)\r\nwlen = QSFP_PAGESIZE - in_page;\r\nret = qib_twsi_blk_rd(dd, QSFP_DEV, addr, buff + cnt, wlen);\r\nif (ret && cnt == 0 && ++pass < QSFP_MAX_RETRY)\r\ncontinue;\r\nif (ret) {\r\nret = -EIO;\r\ngoto deselect;\r\n}\r\naddr += wlen;\r\ncnt += wlen;\r\n}\r\nret = cnt;\r\ndeselect:\r\nudelay(10);\r\ndd->f_gpio_mod(dd, mask, mask, mask);\r\nif (stuck)\r\nqib_dev_err(dd, "QSFP interface bus stuck non-idle\n");\r\nif (pass >= QSFP_MAX_RETRY && ret)\r\nqib_dev_porterr(dd, ppd->port, "QSFP failed even retrying\n");\r\nelse if (pass)\r\nqib_dev_porterr(dd, ppd->port, "QSFP retries: %d\n", pass);\r\nmsleep(20);\r\nbail:\r\nmutex_unlock(&dd->eep_lock);\r\nno_unlock:\r\nreturn ret;\r\n}\r\nstatic int qib_qsfp_write(struct qib_pportdata *ppd, int addr, void *bp,\r\nint len)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu32 out, mask;\r\nint ret, cnt;\r\nu8 *buff = bp;\r\nret = mutex_lock_interruptible(&dd->eep_lock);\r\nif (ret)\r\ngoto no_unlock;\r\nif (dd->twsi_eeprom_dev == QIB_TWSI_NO_DEV) {\r\nret = -ENXIO;\r\ngoto bail;\r\n}\r\nmask = QSFP_GPIO_MOD_SEL_N | QSFP_GPIO_MOD_RST_N | QSFP_GPIO_LP_MODE;\r\nout = QSFP_GPIO_MOD_RST_N | QSFP_GPIO_LP_MODE;\r\nif (ppd->hw_pidx) {\r\nmask <<= QSFP_GPIO_PORT2_SHIFT;\r\nout <<= QSFP_GPIO_PORT2_SHIFT;\r\n}\r\ndd->f_gpio_mod(dd, out, mask, mask);\r\nmsleep(20);\r\nret = qib_twsi_reset(dd);\r\nif (ret) {\r\nqib_dev_porterr(dd, ppd->port,\r\n"QSFP interface Reset for write failed\n");\r\nret = -EIO;\r\ngoto deselect;\r\n}\r\ncnt = 0;\r\nwhile (cnt < len) {\r\nunsigned in_page;\r\nint wlen = len - cnt;\r\nin_page = addr % QSFP_PAGESIZE;\r\nif ((in_page + wlen) > QSFP_PAGESIZE)\r\nwlen = QSFP_PAGESIZE - in_page;\r\nret = qib_twsi_blk_wr(dd, QSFP_DEV, addr, buff + cnt, wlen);\r\nif (ret) {\r\nret = -EIO;\r\ngoto deselect;\r\n}\r\naddr += wlen;\r\ncnt += wlen;\r\n}\r\nret = cnt;\r\ndeselect:\r\nudelay(10);\r\ndd->f_gpio_mod(dd, mask, mask, mask);\r\nmsleep(20);\r\nbail:\r\nmutex_unlock(&dd->eep_lock);\r\nno_unlock:\r\nreturn ret;\r\n}\r\nstatic int qsfp_cks(struct qib_pportdata *ppd, int first, int next)\r\n{\r\nint ret;\r\nu16 cks;\r\nu8 bval;\r\ncks = 0;\r\nwhile (first < next) {\r\nret = qsfp_read(ppd, first, &bval, 1);\r\nif (ret < 0)\r\ngoto bail;\r\ncks += bval;\r\n++first;\r\n}\r\nret = cks & 0xFF;\r\nbail:\r\nreturn ret;\r\n}\r\nint qib_refresh_qsfp_cache(struct qib_pportdata *ppd, struct qib_qsfp_cache *cp)\r\n{\r\nint ret;\r\nint idx;\r\nu16 cks;\r\nu8 peek[4];\r\nmemset(cp, 0, sizeof(*cp));\r\nif (!qib_qsfp_mod_present(ppd)) {\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\nret = qsfp_read(ppd, 0, peek, 3);\r\nif (ret < 0)\r\ngoto bail;\r\nif ((peek[0] & 0xFE) != 0x0C)\r\nqib_dev_porterr(ppd->dd, ppd->port,\r\n"QSFP byte0 is 0x%02X, S/B 0x0C/D\n", peek[0]);\r\nif ((peek[2] & 4) == 0) {\r\nu8 poke = 0;\r\nret = qib_qsfp_write(ppd, 127, &poke, 1);\r\nudelay(50);\r\nif (ret != 1) {\r\nqib_dev_porterr(ppd->dd, ppd->port,\r\n"Failed QSFP Page set\n");\r\ngoto bail;\r\n}\r\n}\r\nret = qsfp_read(ppd, QSFP_MOD_ID_OFFS, &cp->id, 1);\r\nif (ret < 0)\r\ngoto bail;\r\nif ((cp->id & 0xFE) != 0x0C)\r\nqib_dev_porterr(ppd->dd, ppd->port,\r\n"QSFP ID byte is 0x%02X, S/B 0x0C/D\n", cp->id);\r\ncks = cp->id;\r\nret = qsfp_read(ppd, QSFP_MOD_PWR_OFFS, &cp->pwr, 1);\r\nif (ret < 0)\r\ngoto bail;\r\ncks += cp->pwr;\r\nret = qsfp_cks(ppd, QSFP_MOD_PWR_OFFS + 1, QSFP_MOD_LEN_OFFS);\r\nif (ret < 0)\r\ngoto bail;\r\ncks += ret;\r\nret = qsfp_read(ppd, QSFP_MOD_LEN_OFFS, &cp->len, 1);\r\nif (ret < 0)\r\ngoto bail;\r\ncks += cp->len;\r\nret = qsfp_read(ppd, QSFP_MOD_TECH_OFFS, &cp->tech, 1);\r\nif (ret < 0)\r\ngoto bail;\r\ncks += cp->tech;\r\nret = qsfp_read(ppd, QSFP_VEND_OFFS, &cp->vendor, QSFP_VEND_LEN);\r\nif (ret < 0)\r\ngoto bail;\r\nfor (idx = 0; idx < QSFP_VEND_LEN; ++idx)\r\ncks += cp->vendor[idx];\r\nret = qsfp_read(ppd, QSFP_IBXCV_OFFS, &cp->xt_xcv, 1);\r\nif (ret < 0)\r\ngoto bail;\r\ncks += cp->xt_xcv;\r\nret = qsfp_read(ppd, QSFP_VOUI_OFFS, &cp->oui, QSFP_VOUI_LEN);\r\nif (ret < 0)\r\ngoto bail;\r\nfor (idx = 0; idx < QSFP_VOUI_LEN; ++idx)\r\ncks += cp->oui[idx];\r\nret = qsfp_read(ppd, QSFP_PN_OFFS, &cp->partnum, QSFP_PN_LEN);\r\nif (ret < 0)\r\ngoto bail;\r\nfor (idx = 0; idx < QSFP_PN_LEN; ++idx)\r\ncks += cp->partnum[idx];\r\nret = qsfp_read(ppd, QSFP_REV_OFFS, &cp->rev, QSFP_REV_LEN);\r\nif (ret < 0)\r\ngoto bail;\r\nfor (idx = 0; idx < QSFP_REV_LEN; ++idx)\r\ncks += cp->rev[idx];\r\nret = qsfp_read(ppd, QSFP_ATTEN_OFFS, &cp->atten, QSFP_ATTEN_LEN);\r\nif (ret < 0)\r\ngoto bail;\r\nfor (idx = 0; idx < QSFP_ATTEN_LEN; ++idx)\r\ncks += cp->atten[idx];\r\nret = qsfp_cks(ppd, QSFP_ATTEN_OFFS + QSFP_ATTEN_LEN, QSFP_CC_OFFS);\r\nif (ret < 0)\r\ngoto bail;\r\ncks += ret;\r\ncks &= 0xFF;\r\nret = qsfp_read(ppd, QSFP_CC_OFFS, &cp->cks1, 1);\r\nif (ret < 0)\r\ngoto bail;\r\nif (cks != cp->cks1)\r\nqib_dev_porterr(ppd->dd, ppd->port,\r\n"QSFP cks1 is %02X, computed %02X\n", cp->cks1,\r\ncks);\r\nret = qsfp_cks(ppd, QSFP_CC_OFFS + 1, QSFP_SN_OFFS);\r\nif (ret < 0)\r\ngoto bail;\r\ncks = ret;\r\nret = qsfp_read(ppd, QSFP_SN_OFFS, &cp->serial, QSFP_SN_LEN);\r\nif (ret < 0)\r\ngoto bail;\r\nfor (idx = 0; idx < QSFP_SN_LEN; ++idx)\r\ncks += cp->serial[idx];\r\nret = qsfp_read(ppd, QSFP_DATE_OFFS, &cp->date, QSFP_DATE_LEN);\r\nif (ret < 0)\r\ngoto bail;\r\nfor (idx = 0; idx < QSFP_DATE_LEN; ++idx)\r\ncks += cp->date[idx];\r\nret = qsfp_read(ppd, QSFP_LOT_OFFS, &cp->lot, QSFP_LOT_LEN);\r\nif (ret < 0)\r\ngoto bail;\r\nfor (idx = 0; idx < QSFP_LOT_LEN; ++idx)\r\ncks += cp->lot[idx];\r\nret = qsfp_cks(ppd, QSFP_LOT_OFFS + QSFP_LOT_LEN, QSFP_CC_EXT_OFFS);\r\nif (ret < 0)\r\ngoto bail;\r\ncks += ret;\r\nret = qsfp_read(ppd, QSFP_CC_EXT_OFFS, &cp->cks2, 1);\r\nif (ret < 0)\r\ngoto bail;\r\ncks &= 0xFF;\r\nif (cks != cp->cks2)\r\nqib_dev_porterr(ppd->dd, ppd->port,\r\n"QSFP cks2 is %02X, computed %02X\n", cp->cks2,\r\ncks);\r\nreturn 0;\r\nbail:\r\ncp->id = 0;\r\nreturn ret;\r\n}\r\nint qib_qsfp_mod_present(struct qib_pportdata *ppd)\r\n{\r\nu32 mask;\r\nint ret;\r\nmask = QSFP_GPIO_MOD_PRS_N <<\r\n(ppd->hw_pidx * QSFP_GPIO_PORT2_SHIFT);\r\nret = ppd->dd->f_gpio_mod(ppd->dd, 0, 0, 0);\r\nreturn !((ret & mask) >>\r\n((ppd->hw_pidx * QSFP_GPIO_PORT2_SHIFT) + 3));\r\n}\r\nvoid qib_qsfp_init(struct qib_qsfp_data *qd,\r\nvoid (*fevent)(struct work_struct *))\r\n{\r\nu32 mask, highs;\r\nstruct qib_devdata *dd = qd->ppd->dd;\r\nINIT_WORK(&qd->work, fevent);\r\nmask = QSFP_GPIO_MOD_SEL_N | QSFP_GPIO_MOD_RST_N | QSFP_GPIO_LP_MODE;\r\nhighs = mask - QSFP_GPIO_MOD_RST_N;\r\nif (qd->ppd->hw_pidx) {\r\nmask <<= QSFP_GPIO_PORT2_SHIFT;\r\nhighs <<= QSFP_GPIO_PORT2_SHIFT;\r\n}\r\ndd->f_gpio_mod(dd, highs, mask, mask);\r\nudelay(20);\r\ndd->f_gpio_mod(dd, mask, mask, mask);\r\n}\r\nvoid qib_qsfp_deinit(struct qib_qsfp_data *qd)\r\n{\r\n}\r\nint qib_qsfp_dump(struct qib_pportdata *ppd, char *buf, int len)\r\n{\r\nstruct qib_qsfp_cache cd;\r\nu8 bin_buff[QSFP_DUMP_CHUNK];\r\nchar lenstr[6];\r\nint sofar, ret;\r\nint bidx = 0;\r\nsofar = 0;\r\nret = qib_refresh_qsfp_cache(ppd, &cd);\r\nif (ret < 0)\r\ngoto bail;\r\nlenstr[0] = ' ';\r\nlenstr[1] = '\0';\r\nif (QSFP_IS_CU(cd.tech))\r\nsprintf(lenstr, "%dM ", cd.len);\r\nsofar += scnprintf(buf + sofar, len - sofar, "PWR:%.3sW\n", pwr_codes +\r\n(QSFP_PWR(cd.pwr) * 4));\r\nsofar += scnprintf(buf + sofar, len - sofar, "TECH:%s%s\n", lenstr,\r\nqib_qsfp_devtech[cd.tech >> 4]);\r\nsofar += scnprintf(buf + sofar, len - sofar, "Vendor:%.*s\n",\r\nQSFP_VEND_LEN, cd.vendor);\r\nsofar += scnprintf(buf + sofar, len - sofar, "OUI:%06X\n",\r\nQSFP_OUI(cd.oui));\r\nsofar += scnprintf(buf + sofar, len - sofar, "Part#:%.*s\n",\r\nQSFP_PN_LEN, cd.partnum);\r\nsofar += scnprintf(buf + sofar, len - sofar, "Rev:%.*s\n",\r\nQSFP_REV_LEN, cd.rev);\r\nif (QSFP_IS_CU(cd.tech))\r\nsofar += scnprintf(buf + sofar, len - sofar, "Atten:%d, %d\n",\r\nQSFP_ATTEN_SDR(cd.atten),\r\nQSFP_ATTEN_DDR(cd.atten));\r\nsofar += scnprintf(buf + sofar, len - sofar, "Serial:%.*s\n",\r\nQSFP_SN_LEN, cd.serial);\r\nsofar += scnprintf(buf + sofar, len - sofar, "Date:%.*s\n",\r\nQSFP_DATE_LEN, cd.date);\r\nsofar += scnprintf(buf + sofar, len - sofar, "Lot:%.*s\n",\r\nQSFP_LOT_LEN, cd.lot);\r\nwhile (bidx < QSFP_DEFAULT_HDR_CNT) {\r\nint iidx;\r\nret = qsfp_read(ppd, bidx, bin_buff, QSFP_DUMP_CHUNK);\r\nif (ret < 0)\r\ngoto bail;\r\nfor (iidx = 0; iidx < ret; ++iidx) {\r\nsofar += scnprintf(buf + sofar, len-sofar, " %02X",\r\nbin_buff[iidx]);\r\n}\r\nsofar += scnprintf(buf + sofar, len - sofar, "\n");\r\nbidx += QSFP_DUMP_CHUNK;\r\n}\r\nret = sofar;\r\nbail:\r\nreturn ret;\r\n}
