static inline int vnic_wq_get_ctrl(struct vnic_dev *vdev, struct vnic_wq *wq,\r\nunsigned int index, enum vnic_res_type res_type)\r\n{\r\nwq->ctrl = svnic_dev_get_res(vdev, res_type, index);\r\nif (!wq->ctrl)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline int vnic_wq_alloc_ring(struct vnic_dev *vdev, struct vnic_wq *wq,\r\nunsigned int index, unsigned int desc_count, unsigned int desc_size)\r\n{\r\nreturn svnic_dev_alloc_desc_ring(vdev, &wq->ring, desc_count,\r\ndesc_size);\r\n}\r\nstatic int vnic_wq_alloc_bufs(struct vnic_wq *wq)\r\n{\r\nstruct vnic_wq_buf *buf;\r\nunsigned int i, j, count = wq->ring.desc_count;\r\nunsigned int blks = VNIC_WQ_BUF_BLKS_NEEDED(count);\r\nfor (i = 0; i < blks; i++) {\r\nwq->bufs[i] = kzalloc(VNIC_WQ_BUF_BLK_SZ, GFP_ATOMIC);\r\nif (!wq->bufs[i]) {\r\npr_err("Failed to alloc wq_bufs\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (i = 0; i < blks; i++) {\r\nbuf = wq->bufs[i];\r\nfor (j = 0; j < VNIC_WQ_BUF_DFLT_BLK_ENTRIES; j++) {\r\nbuf->index = i * VNIC_WQ_BUF_DFLT_BLK_ENTRIES + j;\r\nbuf->desc = (u8 *)wq->ring.descs +\r\nwq->ring.desc_size * buf->index;\r\nif (buf->index + 1 == count) {\r\nbuf->next = wq->bufs[0];\r\nbreak;\r\n} else if (j + 1 == VNIC_WQ_BUF_DFLT_BLK_ENTRIES) {\r\nbuf->next = wq->bufs[i + 1];\r\n} else {\r\nbuf->next = buf + 1;\r\nbuf++;\r\n}\r\n}\r\n}\r\nwq->to_use = wq->to_clean = wq->bufs[0];\r\nreturn 0;\r\n}\r\nvoid svnic_wq_free(struct vnic_wq *wq)\r\n{\r\nstruct vnic_dev *vdev;\r\nunsigned int i;\r\nvdev = wq->vdev;\r\nsvnic_dev_free_desc_ring(vdev, &wq->ring);\r\nfor (i = 0; i < VNIC_WQ_BUF_BLKS_MAX; i++) {\r\nkfree(wq->bufs[i]);\r\nwq->bufs[i] = NULL;\r\n}\r\nwq->ctrl = NULL;\r\n}\r\nint vnic_wq_devcmd2_alloc(struct vnic_dev *vdev, struct vnic_wq *wq,\r\nunsigned int desc_count, unsigned int desc_size)\r\n{\r\nint err;\r\nwq->index = 0;\r\nwq->vdev = vdev;\r\nerr = vnic_wq_get_ctrl(vdev, wq, 0, RES_TYPE_DEVCMD2);\r\nif (err) {\r\npr_err("Failed to get devcmd2 resource\n");\r\nreturn err;\r\n}\r\nsvnic_wq_disable(wq);\r\nerr = vnic_wq_alloc_ring(vdev, wq, 0, desc_count, desc_size);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint svnic_wq_alloc(struct vnic_dev *vdev, struct vnic_wq *wq,\r\nunsigned int index, unsigned int desc_count, unsigned int desc_size)\r\n{\r\nint err;\r\nwq->index = index;\r\nwq->vdev = vdev;\r\nerr = vnic_wq_get_ctrl(vdev, wq, index, RES_TYPE_WQ);\r\nif (err) {\r\npr_err("Failed to hook WQ[%d] resource\n", index);\r\nreturn err;\r\n}\r\nsvnic_wq_disable(wq);\r\nerr = vnic_wq_alloc_ring(vdev, wq, index, desc_count, desc_size);\r\nif (err)\r\nreturn err;\r\nerr = vnic_wq_alloc_bufs(wq);\r\nif (err) {\r\nsvnic_wq_free(wq);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid vnic_wq_init_start(struct vnic_wq *wq, unsigned int cq_index,\r\nunsigned int fetch_index, unsigned int posted_index,\r\nunsigned int error_interrupt_enable,\r\nunsigned int error_interrupt_offset)\r\n{\r\nu64 paddr;\r\nunsigned int count = wq->ring.desc_count;\r\npaddr = (u64)wq->ring.base_addr | VNIC_PADDR_TARGET;\r\nwriteq(paddr, &wq->ctrl->ring_base);\r\niowrite32(count, &wq->ctrl->ring_size);\r\niowrite32(fetch_index, &wq->ctrl->fetch_index);\r\niowrite32(posted_index, &wq->ctrl->posted_index);\r\niowrite32(cq_index, &wq->ctrl->cq_index);\r\niowrite32(error_interrupt_enable, &wq->ctrl->error_interrupt_enable);\r\niowrite32(error_interrupt_offset, &wq->ctrl->error_interrupt_offset);\r\niowrite32(0, &wq->ctrl->error_status);\r\nwq->to_use = wq->to_clean =\r\n&wq->bufs[fetch_index / VNIC_WQ_BUF_BLK_ENTRIES(count)]\r\n[fetch_index % VNIC_WQ_BUF_BLK_ENTRIES(count)];\r\n}\r\nvoid svnic_wq_init(struct vnic_wq *wq, unsigned int cq_index,\r\nunsigned int error_interrupt_enable,\r\nunsigned int error_interrupt_offset)\r\n{\r\nvnic_wq_init_start(wq, cq_index, 0, 0, error_interrupt_enable,\r\nerror_interrupt_offset);\r\n}\r\nunsigned int svnic_wq_error_status(struct vnic_wq *wq)\r\n{\r\nreturn ioread32(&wq->ctrl->error_status);\r\n}\r\nvoid svnic_wq_enable(struct vnic_wq *wq)\r\n{\r\niowrite32(1, &wq->ctrl->enable);\r\n}\r\nint svnic_wq_disable(struct vnic_wq *wq)\r\n{\r\nunsigned int wait;\r\niowrite32(0, &wq->ctrl->enable);\r\nfor (wait = 0; wait < 100; wait++) {\r\nif (!(ioread32(&wq->ctrl->running)))\r\nreturn 0;\r\nudelay(1);\r\n}\r\npr_err("Failed to disable WQ[%d]\n", wq->index);\r\nreturn -ETIMEDOUT;\r\n}\r\nvoid svnic_wq_clean(struct vnic_wq *wq,\r\nvoid (*buf_clean)(struct vnic_wq *wq, struct vnic_wq_buf *buf))\r\n{\r\nstruct vnic_wq_buf *buf;\r\nBUG_ON(ioread32(&wq->ctrl->enable));\r\nbuf = wq->to_clean;\r\nwhile (svnic_wq_desc_used(wq) > 0) {\r\n(*buf_clean)(wq, buf);\r\nbuf = wq->to_clean = buf->next;\r\nwq->ring.desc_avail++;\r\n}\r\nwq->to_use = wq->to_clean = wq->bufs[0];\r\niowrite32(0, &wq->ctrl->fetch_index);\r\niowrite32(0, &wq->ctrl->posted_index);\r\niowrite32(0, &wq->ctrl->error_status);\r\nsvnic_dev_clear_desc_ring(&wq->ring);\r\n}
