acpi_status\r\nacpi_ns_check_package(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nconst union acpi_predefined_info *package;\r\nunion acpi_operand_object **elements;\r\nacpi_status status = AE_OK;\r\nu32 expected_count;\r\nu32 count;\r\nu32 i;\r\nACPI_FUNCTION_NAME(ns_check_package);\r\npackage = info->predefined + 1;\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"%s Validating return Package of Type %X, Count %X\n",\r\ninfo->full_pathname, package->ret_info.type,\r\nreturn_object->package.count));\r\nacpi_ns_remove_null_elements(info, package->ret_info.type,\r\nreturn_object);\r\nelements = return_object->package.elements;\r\ncount = return_object->package.count;\r\nif (!count) {\r\nif (package->ret_info.type == ACPI_PTYPE1_VAR) {\r\nreturn (AE_OK);\r\n}\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,\r\ninfo->node_flags,\r\n"Return Package has no elements (empty)"));\r\nreturn (AE_AML_OPERAND_VALUE);\r\n}\r\nswitch (package->ret_info.type) {\r\ncase ACPI_PTYPE_CUSTOM:\r\nstatus = acpi_ns_custom_package(info, elements, count);\r\nbreak;\r\ncase ACPI_PTYPE1_FIXED:\r\nexpected_count =\r\npackage->ret_info.count1 + package->ret_info.count2;\r\nif (count < expected_count) {\r\ngoto package_too_small;\r\n} else if (count > expected_count) {\r\nACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\r\n"%s: Return Package is larger than needed - "\r\n"found %u, expected %u\n",\r\ninfo->full_pathname, count,\r\nexpected_count));\r\n}\r\nstatus = acpi_ns_check_package_elements(info, elements,\r\npackage->ret_info.\r\nobject_type1,\r\npackage->ret_info.\r\ncount1,\r\npackage->ret_info.\r\nobject_type2,\r\npackage->ret_info.\r\ncount2, 0);\r\nbreak;\r\ncase ACPI_PTYPE1_VAR:\r\nfor (i = 0; i < count; i++) {\r\nstatus = acpi_ns_check_object_type(info, elements,\r\npackage->ret_info.\r\nobject_type1, i);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nelements++;\r\n}\r\nbreak;\r\ncase ACPI_PTYPE1_OPTION:\r\nexpected_count = package->ret_info3.count;\r\nif (count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (i < package->ret_info3.count) {\r\nstatus =\r\nacpi_ns_check_object_type(info, elements,\r\npackage->\r\nret_info3.\r\nobject_type[i],\r\ni);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n} else {\r\nstatus =\r\nacpi_ns_check_object_type(info, elements,\r\npackage->\r\nret_info3.\r\ntail_object_type,\r\ni);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nelements++;\r\n}\r\nbreak;\r\ncase ACPI_PTYPE2_REV_FIXED:\r\nstatus =\r\nacpi_ns_check_object_type(info, elements,\r\nACPI_RTYPE_INTEGER, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nelements++;\r\ncount--;\r\nstatus =\r\nacpi_ns_check_package_list(info, package, elements, count);\r\nbreak;\r\ncase ACPI_PTYPE2_PKG_COUNT:\r\nstatus =\r\nacpi_ns_check_object_type(info, elements,\r\nACPI_RTYPE_INTEGER, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nexpected_count = (u32)(*elements)->integer.value;\r\nif (expected_count >= count) {\r\ngoto package_too_small;\r\n}\r\ncount = expected_count;\r\nelements++;\r\nstatus =\r\nacpi_ns_check_package_list(info, package, elements, count);\r\nbreak;\r\ncase ACPI_PTYPE2:\r\ncase ACPI_PTYPE2_FIXED:\r\ncase ACPI_PTYPE2_MIN:\r\ncase ACPI_PTYPE2_COUNT:\r\ncase ACPI_PTYPE2_FIX_VAR:\r\nif (*elements\r\n&& ((*elements)->common.type != ACPI_TYPE_PACKAGE)) {\r\nstatus =\r\nacpi_ns_wrap_with_package(info, return_object,\r\nreturn_object_ptr);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nreturn_object = *return_object_ptr;\r\nelements = return_object->package.elements;\r\ncount = 1;\r\n}\r\nstatus =\r\nacpi_ns_check_package_list(info, package, elements, count);\r\nbreak;\r\ncase ACPI_PTYPE2_VAR_VAR:\r\nbreak;\r\ncase ACPI_PTYPE2_UUID_PAIR:\r\nif (count & 1) {\r\nexpected_count = count + 1;\r\ngoto package_too_small;\r\n}\r\nwhile (count > 0) {\r\nstatus = acpi_ns_check_object_type(info, elements,\r\npackage->ret_info.\r\nobject_type1, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif ((*elements)->buffer.length != 16) {\r\nACPI_WARN_PREDEFINED((AE_INFO,\r\ninfo->full_pathname,\r\ninfo->node_flags,\r\n"Invalid length for UUID Buffer"));\r\nreturn (AE_AML_OPERAND_VALUE);\r\n}\r\nstatus = acpi_ns_check_object_type(info, elements + 1,\r\npackage->ret_info.\r\nobject_type2, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nelements += 2;\r\ncount -= 2;\r\n}\r\nbreak;\r\ndefault:\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,\r\ninfo->node_flags,\r\n"Invalid internal return type in table entry: %X",\r\npackage->ret_info.type));\r\nreturn (AE_AML_INTERNAL);\r\n}\r\nreturn (status);\r\npackage_too_small:\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname, info->node_flags,\r\n"Return Package is too small - found %u elements, expected %u",\r\ncount, expected_count));\r\nreturn (AE_AML_OPERAND_VALUE);\r\n}\r\nstatic acpi_status\r\nacpi_ns_check_package_list(struct acpi_evaluate_info *info,\r\nconst union acpi_predefined_info *package,\r\nunion acpi_operand_object **elements, u32 count)\r\n{\r\nunion acpi_operand_object *sub_package;\r\nunion acpi_operand_object **sub_elements;\r\nacpi_status status;\r\nu32 expected_count;\r\nu32 i;\r\nu32 j;\r\nfor (i = 0; i < count; i++) {\r\nsub_package = *elements;\r\nsub_elements = sub_package->package.elements;\r\ninfo->parent_package = sub_package;\r\nstatus = acpi_ns_check_object_type(info, &sub_package,\r\nACPI_RTYPE_PACKAGE, i);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\ninfo->parent_package = sub_package;\r\nswitch (package->ret_info.type) {\r\ncase ACPI_PTYPE2:\r\ncase ACPI_PTYPE2_PKG_COUNT:\r\ncase ACPI_PTYPE2_REV_FIXED:\r\nexpected_count =\r\npackage->ret_info.count1 + package->ret_info.count2;\r\nif (sub_package->package.count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nstatus =\r\nacpi_ns_check_package_elements(info, sub_elements,\r\npackage->ret_info.\r\nobject_type1,\r\npackage->ret_info.\r\ncount1,\r\npackage->ret_info.\r\nobject_type2,\r\npackage->ret_info.\r\ncount2, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nbreak;\r\ncase ACPI_PTYPE2_FIX_VAR:\r\nexpected_count =\r\npackage->ret_info.count1 + package->ret_info.count2;\r\nif (sub_package->package.count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nstatus =\r\nacpi_ns_check_package_elements(info, sub_elements,\r\npackage->ret_info.\r\nobject_type1,\r\npackage->ret_info.\r\ncount1,\r\npackage->ret_info.\r\nobject_type2,\r\nsub_package->package.\r\ncount -\r\npackage->ret_info.\r\ncount1, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nbreak;\r\ncase ACPI_PTYPE2_VAR_VAR:\r\nbreak;\r\ncase ACPI_PTYPE2_FIXED:\r\nexpected_count = package->ret_info2.count;\r\nif (sub_package->package.count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nfor (j = 0; j < expected_count; j++) {\r\nstatus =\r\nacpi_ns_check_object_type(info,\r\n&sub_elements[j],\r\npackage->\r\nret_info2.\r\nobject_type[j],\r\nj);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nbreak;\r\ncase ACPI_PTYPE2_MIN:\r\nexpected_count = package->ret_info.count1;\r\nif (sub_package->package.count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nstatus =\r\nacpi_ns_check_package_elements(info, sub_elements,\r\npackage->ret_info.\r\nobject_type1,\r\nsub_package->package.\r\ncount, 0, 0, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nbreak;\r\ncase ACPI_PTYPE2_COUNT:\r\nstatus = acpi_ns_check_object_type(info, sub_elements,\r\nACPI_RTYPE_INTEGER,\r\n0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nexpected_count = (u32)(*sub_elements)->integer.value;\r\nif (sub_package->package.count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nif (sub_package->package.count <\r\npackage->ret_info.count1) {\r\nexpected_count = package->ret_info.count1;\r\ngoto package_too_small;\r\n}\r\nif (expected_count == 0) {\r\nexpected_count = sub_package->package.count;\r\n(*sub_elements)->integer.value = expected_count;\r\n}\r\nstatus =\r\nacpi_ns_check_package_elements(info,\r\n(sub_elements + 1),\r\npackage->ret_info.\r\nobject_type1,\r\n(expected_count - 1),\r\n0, 0, 1);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nbreak;\r\ndefault:\r\nreturn (AE_AML_INTERNAL);\r\n}\r\nelements++;\r\n}\r\nreturn (AE_OK);\r\npackage_too_small:\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname, info->node_flags,\r\n"Return SubPackage[%u] is too small - found %u elements, expected %u",\r\ni, sub_package->package.count, expected_count));\r\nreturn (AE_AML_OPERAND_VALUE);\r\n}\r\nstatic acpi_status\r\nacpi_ns_custom_package(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **elements, u32 count)\r\n{\r\nu32 expected_count;\r\nu32 version;\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_NAME(ns_custom_package);\r\nif ((*elements)->common.type != ACPI_TYPE_INTEGER) {\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,\r\ninfo->node_flags,\r\n"Return Package has invalid object type for version number"));\r\nreturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\r\n}\r\nversion = (u32)(*elements)->integer.value;\r\nexpected_count = 21;\r\nif (version == 0) {\r\nexpected_count = 20;\r\n}\r\nif (count < expected_count) {\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,\r\ninfo->node_flags,\r\n"Return Package is too small - found %u elements, expected %u",\r\ncount, expected_count));\r\nreturn_ACPI_STATUS(AE_AML_OPERAND_VALUE);\r\n} else if (count > expected_count) {\r\nACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\r\n"%s: Return Package is larger than needed - "\r\n"found %u, expected %u\n",\r\ninfo->full_pathname, count, expected_count));\r\n}\r\nstatus = acpi_ns_check_package_elements(info, elements,\r\nACPI_RTYPE_INTEGER, 16,\r\nACPI_RTYPE_STRING, 4, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (version > 0) {\r\nstatus = acpi_ns_check_package_elements(info, elements + 20,\r\nACPI_RTYPE_INTEGER, 1,\r\n0, 0, 20);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_ns_check_package_elements(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **elements,\r\nu8 type1,\r\nu32 count1,\r\nu8 type2, u32 count2, u32 start_index)\r\n{\r\nunion acpi_operand_object **this_element = elements;\r\nacpi_status status;\r\nu32 i;\r\nfor (i = 0; i < count1; i++) {\r\nstatus = acpi_ns_check_object_type(info, this_element,\r\ntype1, i + start_index);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nthis_element++;\r\n}\r\nfor (i = 0; i < count2; i++) {\r\nstatus = acpi_ns_check_object_type(info, this_element,\r\ntype2,\r\n(i + count1 + start_index));\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nthis_element++;\r\n}\r\nreturn (AE_OK);\r\n}
