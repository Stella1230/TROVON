static notrace cycle_t bfin_read_cycles(struct clocksource *cs)\r\n{\r\n#ifdef CONFIG_CPU_FREQ\r\nreturn __bfin_cycles_off + (get_cycles() << __bfin_cycles_mod);\r\n#else\r\nreturn get_cycles();\r\n#endif\r\n}\r\nstatic inline unsigned long long bfin_cs_cycles_sched_clock(void)\r\n{\r\nreturn clocksource_cyc2ns(bfin_read_cycles(&bfin_cs_cycles),\r\nbfin_cs_cycles.mult, bfin_cs_cycles.shift);\r\n}\r\nstatic int __init bfin_cs_cycles_init(void)\r\n{\r\nif (clocksource_register_hz(&bfin_cs_cycles, get_cclk()))\r\npanic("failed to register clocksource");\r\nreturn 0;\r\n}\r\nvoid __init setup_gptimer0(void)\r\n{\r\ndisable_gptimers(TIMER0bit);\r\n#ifdef CONFIG_BF60x\r\nbfin_write16(TIMER_DATA_IMSK, 0);\r\nset_gptimer_config(TIMER0_id, TIMER_OUT_DIS\r\n| TIMER_MODE_PWM_CONT | TIMER_PULSE_HI | TIMER_IRQ_PER);\r\n#else\r\nset_gptimer_config(TIMER0_id, \\r\nTIMER_OUT_DIS | TIMER_PERIOD_CNT | TIMER_MODE_PWM);\r\n#endif\r\nset_gptimer_period(TIMER0_id, -1);\r\nset_gptimer_pwidth(TIMER0_id, -2);\r\nSSYNC();\r\nenable_gptimers(TIMER0bit);\r\n}\r\nstatic cycle_t bfin_read_gptimer0(struct clocksource *cs)\r\n{\r\nreturn bfin_read_TIMER0_COUNTER();\r\n}\r\nstatic inline unsigned long long bfin_cs_gptimer0_sched_clock(void)\r\n{\r\nreturn clocksource_cyc2ns(bfin_read_TIMER0_COUNTER(),\r\nbfin_cs_gptimer0.mult, bfin_cs_gptimer0.shift);\r\n}\r\nstatic int __init bfin_cs_gptimer0_init(void)\r\n{\r\nsetup_gptimer0();\r\nif (clocksource_register_hz(&bfin_cs_gptimer0, get_sclk()))\r\npanic("failed to register clocksource");\r\nreturn 0;\r\n}\r\nnotrace unsigned long long sched_clock(void)\r\n{\r\n#if defined(CONFIG_CYCLES_CLOCKSOURCE)\r\nreturn bfin_cs_cycles_sched_clock();\r\n#else\r\nreturn bfin_cs_gptimer0_sched_clock();\r\n#endif\r\n}\r\nstatic int bfin_gptmr0_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *evt)\r\n{\r\ndisable_gptimers(TIMER0bit);\r\nset_gptimer_pwidth(TIMER0_id, cycles - 3);\r\nenable_gptimers(TIMER0bit);\r\nreturn 0;\r\n}\r\nstatic int bfin_gptmr0_set_periodic(struct clock_event_device *evt)\r\n{\r\n#ifndef CONFIG_BF60x\r\nset_gptimer_config(TIMER0_id,\r\nTIMER_OUT_DIS | TIMER_IRQ_ENA |\r\nTIMER_PERIOD_CNT | TIMER_MODE_PWM);\r\n#else\r\nset_gptimer_config(TIMER0_id,\r\nTIMER_OUT_DIS | TIMER_MODE_PWM_CONT |\r\nTIMER_PULSE_HI | TIMER_IRQ_PER);\r\n#endif\r\nset_gptimer_period(TIMER0_id, get_sclk() / HZ);\r\nset_gptimer_pwidth(TIMER0_id, get_sclk() / HZ - 1);\r\nenable_gptimers(TIMER0bit);\r\nreturn 0;\r\n}\r\nstatic int bfin_gptmr0_set_oneshot(struct clock_event_device *evt)\r\n{\r\ndisable_gptimers(TIMER0bit);\r\n#ifndef CONFIG_BF60x\r\nset_gptimer_config(TIMER0_id,\r\nTIMER_OUT_DIS | TIMER_IRQ_ENA | TIMER_MODE_PWM);\r\n#else\r\nset_gptimer_config(TIMER0_id,\r\nTIMER_OUT_DIS | TIMER_MODE_PWM | TIMER_PULSE_HI |\r\nTIMER_IRQ_WID_DLY);\r\n#endif\r\nset_gptimer_period(TIMER0_id, 0);\r\nreturn 0;\r\n}\r\nstatic int bfin_gptmr0_shutdown(struct clock_event_device *evt)\r\n{\r\ndisable_gptimers(TIMER0bit);\r\nreturn 0;\r\n}\r\nstatic void bfin_gptmr0_ack(void)\r\n{\r\nclear_gptimer_intr(TIMER0_id);\r\n}\r\nstatic void __init bfin_gptmr0_init(void)\r\n{\r\ndisable_gptimers(TIMER0bit);\r\n}\r\nirqreturn_t bfin_gptmr0_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nsmp_mb();\r\nbfin_gptmr0_ack();\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init bfin_gptmr0_clockevent_init(struct clock_event_device *evt)\r\n{\r\nunsigned long clock_tick;\r\nclock_tick = get_sclk();\r\nevt->mult = div_sc(clock_tick, NSEC_PER_SEC, evt->shift);\r\nevt->max_delta_ns = clockevent_delta2ns(-1, evt);\r\nevt->min_delta_ns = clockevent_delta2ns(100, evt);\r\nevt->cpumask = cpumask_of(0);\r\nclockevents_register_device(evt);\r\n}\r\nstatic int bfin_coretmr_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *evt)\r\n{\r\nbfin_write_TCNTL(TMPWR);\r\nCSYNC();\r\nbfin_write_TCOUNT(cycles);\r\nCSYNC();\r\nbfin_write_TCNTL(TMPWR | TMREN);\r\nreturn 0;\r\n}\r\nstatic int bfin_coretmr_set_periodic(struct clock_event_device *evt)\r\n{\r\nunsigned long tcount = ((get_cclk() / (HZ * TIME_SCALE)) - 1);\r\nbfin_write_TCNTL(TMPWR);\r\nCSYNC();\r\nbfin_write_TSCALE(TIME_SCALE - 1);\r\nbfin_write_TPERIOD(tcount);\r\nbfin_write_TCOUNT(tcount);\r\nCSYNC();\r\nbfin_write_TCNTL(TMPWR | TMREN | TAUTORLD);\r\nreturn 0;\r\n}\r\nstatic int bfin_coretmr_set_oneshot(struct clock_event_device *evt)\r\n{\r\nbfin_write_TCNTL(TMPWR);\r\nCSYNC();\r\nbfin_write_TSCALE(TIME_SCALE - 1);\r\nbfin_write_TPERIOD(0);\r\nbfin_write_TCOUNT(0);\r\nreturn 0;\r\n}\r\nstatic int bfin_coretmr_shutdown(struct clock_event_device *evt)\r\n{\r\nbfin_write_TCNTL(0);\r\nCSYNC();\r\nreturn 0;\r\n}\r\nvoid bfin_coretmr_init(void)\r\n{\r\nbfin_write_TCNTL(TMPWR);\r\nCSYNC();\r\nbfin_write_TSCALE(TIME_SCALE - 1);\r\nbfin_write_TPERIOD(0);\r\nbfin_write_TCOUNT(0);\r\nCSYNC();\r\n}\r\nirqreturn_t bfin_coretmr_interrupt(int irq, void *dev_id)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct clock_event_device *evt = &per_cpu(coretmr_events, cpu);\r\nsmp_mb();\r\nevt->event_handler(evt);\r\ntouch_nmi_watchdog();\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid bfin_coretmr_clockevent_init(void)\r\n{\r\nunsigned long clock_tick;\r\nunsigned int cpu = smp_processor_id();\r\nstruct clock_event_device *evt = &per_cpu(coretmr_events, cpu);\r\n#ifdef CONFIG_SMP\r\nevt->broadcast = smp_timer_broadcast;\r\n#endif\r\nevt->name = "bfin_core_timer";\r\nevt->rating = 350;\r\nevt->irq = -1;\r\nevt->shift = 32;\r\nevt->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\r\nevt->set_next_event = bfin_coretmr_set_next_event;\r\nevt->set_state_shutdown = bfin_coretmr_shutdown;\r\nevt->set_state_periodic = bfin_coretmr_set_periodic;\r\nevt->set_state_oneshot = bfin_coretmr_set_oneshot;\r\nclock_tick = get_cclk() / TIME_SCALE;\r\nevt->mult = div_sc(clock_tick, NSEC_PER_SEC, evt->shift);\r\nevt->max_delta_ns = clockevent_delta2ns(-1, evt);\r\nevt->min_delta_ns = clockevent_delta2ns(100, evt);\r\nevt->cpumask = cpumask_of(cpu);\r\nclockevents_register_device(evt);\r\n}\r\nvoid read_persistent_clock(struct timespec *ts)\r\n{\r\ntime_t secs_since_1970 = (365 * 37 + 9) * 24 * 60 * 60;\r\nts->tv_sec = secs_since_1970;\r\nts->tv_nsec = 0;\r\n}\r\nvoid __init time_init(void)\r\n{\r\n#ifdef CONFIG_RTC_DRV_BFIN\r\nif ((bfin_read_RTC_STAT() & 0xC0000000) == 0xC0000000) {\r\nprintk(KERN_NOTICE "bfin-rtc: invalid date; resetting\n");\r\nbfin_write_RTC_STAT(0);\r\n}\r\n#endif\r\nbfin_cs_cycles_init();\r\nbfin_cs_gptimer0_init();\r\n#if defined(CONFIG_TICKSOURCE_CORETMR)\r\nbfin_coretmr_init();\r\nsetup_irq(IRQ_CORETMR, &coretmr_irq);\r\nbfin_coretmr_clockevent_init();\r\n#endif\r\n#if defined(CONFIG_TICKSOURCE_GPTMR0)\r\nbfin_gptmr0_init();\r\nsetup_irq(IRQ_TIMER0, &gptmr0_irq);\r\ngptmr0_irq.dev_id = &clockevent_gptmr0;\r\nbfin_gptmr0_clockevent_init(&clockevent_gptmr0);\r\n#endif\r\n#if !defined(CONFIG_TICKSOURCE_CORETMR) && !defined(CONFIG_TICKSOURCE_GPTMR0)\r\n# error at least one clock event device is required\r\n#endif\r\n}
