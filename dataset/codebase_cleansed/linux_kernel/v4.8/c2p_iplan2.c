static void c2p_16x8(u32 d[4])\r\n{\r\ntransp4(d, 8, 2);\r\ntransp4(d, 1, 2);\r\ntransp4x(d, 16, 2);\r\ntransp4x(d, 2, 2);\r\ntransp4(d, 4, 1);\r\n}\r\nstatic inline void store_iplan2(void *dst, u32 bpp, u32 d[4])\r\n{\r\nint i;\r\nfor (i = 0; i < bpp/2; i++, dst += 4)\r\nput_unaligned_be32(d[perm_c2p_16x8[i]], dst);\r\n}\r\nstatic inline void store_iplan2_masked(void *dst, u32 bpp, u32 d[4], u32 mask)\r\n{\r\nint i;\r\nfor (i = 0; i < bpp/2; i++, dst += 4)\r\nput_unaligned_be32(comp(d[perm_c2p_16x8[i]],\r\nget_unaligned_be32(dst), mask),\r\ndst);\r\n}\r\nvoid c2p_iplan2(void *dst, const void *src, u32 dx, u32 dy, u32 width,\r\nu32 height, u32 dst_nextline, u32 src_nextline, u32 bpp)\r\n{\r\nunion {\r\nu8 pixels[16];\r\nu32 words[4];\r\n} d;\r\nu32 dst_idx, first, last, w;\r\nconst u8 *c;\r\nvoid *p;\r\ndst += dy*dst_nextline+(dx & ~15)*bpp;\r\ndst_idx = dx % 16;\r\nfirst = 0xffffU >> dst_idx;\r\nfirst |= first << 16;\r\nlast = 0xffffU ^ (0xffffU >> ((dst_idx+width) % 16));\r\nlast |= last << 16;\r\nwhile (height--) {\r\nc = src;\r\np = dst;\r\nw = width;\r\nif (dst_idx+width <= 16) {\r\nfirst &= last;\r\nmemset(d.pixels, 0, sizeof(d));\r\nmemcpy(d.pixels+dst_idx, c, width);\r\nc += width;\r\nc2p_16x8(d.words);\r\nstore_iplan2_masked(p, bpp, d.words, first);\r\np += bpp*2;\r\n} else {\r\nw = width;\r\nif (dst_idx) {\r\nw = 16 - dst_idx;\r\nmemset(d.pixels, 0, dst_idx);\r\nmemcpy(d.pixels+dst_idx, c, w);\r\nc += w;\r\nc2p_16x8(d.words);\r\nstore_iplan2_masked(p, bpp, d.words, first);\r\np += bpp*2;\r\nw = width-w;\r\n}\r\nwhile (w >= 16) {\r\nmemcpy(d.pixels, c, 16);\r\nc += 16;\r\nc2p_16x8(d.words);\r\nstore_iplan2(p, bpp, d.words);\r\np += bpp*2;\r\nw -= 16;\r\n}\r\nw %= 16;\r\nif (w > 0) {\r\nmemcpy(d.pixels, c, w);\r\nmemset(d.pixels+w, 0, 16-w);\r\nc2p_16x8(d.words);\r\nstore_iplan2_masked(p, bpp, d.words, last);\r\n}\r\n}\r\nsrc += src_nextline;\r\ndst += dst_nextline;\r\n}\r\n}
