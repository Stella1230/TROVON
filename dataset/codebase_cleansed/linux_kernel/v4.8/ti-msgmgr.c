static inline int ti_msgmgr_queue_get_num_messages(struct ti_queue_inst *qinst)\r\n{\r\nu32 val;\r\nval = readl(qinst->queue_state) & Q_STATE_ENTRY_COUNT_MASK;\r\nval >>= __ffs(Q_STATE_ENTRY_COUNT_MASK);\r\nreturn val;\r\n}\r\nstatic irqreturn_t ti_msgmgr_queue_rx_interrupt(int irq, void *p)\r\n{\r\nstruct mbox_chan *chan = p;\r\nstruct device *dev = chan->mbox->dev;\r\nstruct ti_msgmgr_inst *inst = dev_get_drvdata(dev);\r\nstruct ti_queue_inst *qinst = chan->con_priv;\r\nconst struct ti_msgmgr_desc *desc;\r\nint msg_count, num_words;\r\nstruct ti_msgmgr_message message;\r\nvoid __iomem *data_reg;\r\nu32 *word_data;\r\nif (WARN_ON(!inst)) {\r\ndev_err(dev, "no platform drv data??\n");\r\nreturn -EINVAL;\r\n}\r\nif (qinst->is_tx) {\r\ndev_err(dev, "Cannot handle rx interrupt on tx channel %s\n",\r\nqinst->name);\r\nreturn IRQ_NONE;\r\n}\r\nmsg_count = ti_msgmgr_queue_get_num_messages(qinst);\r\nif (!msg_count) {\r\ndev_dbg(dev, "Spurious event - 0 pending data!\n");\r\nreturn IRQ_NONE;\r\n}\r\ndesc = inst->desc;\r\nmessage.len = desc->max_message_size;\r\nmessage.buf = (u8 *)qinst->rx_buff;\r\nfor (data_reg = qinst->queue_buff_start, word_data = qinst->rx_buff,\r\nnum_words = (desc->max_message_size / sizeof(u32));\r\nnum_words; num_words--, data_reg += sizeof(u32), word_data++)\r\n*word_data = readl(data_reg);\r\nmbox_chan_received_data(chan, (void *)&message);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool ti_msgmgr_queue_peek_data(struct mbox_chan *chan)\r\n{\r\nstruct ti_queue_inst *qinst = chan->con_priv;\r\nint msg_count;\r\nif (qinst->is_tx)\r\nreturn false;\r\nmsg_count = ti_msgmgr_queue_get_num_messages(qinst);\r\nreturn msg_count ? true : false;\r\n}\r\nstatic bool ti_msgmgr_last_tx_done(struct mbox_chan *chan)\r\n{\r\nstruct ti_queue_inst *qinst = chan->con_priv;\r\nint msg_count;\r\nif (!qinst->is_tx)\r\nreturn false;\r\nmsg_count = ti_msgmgr_queue_get_num_messages(qinst);\r\nreturn msg_count ? false : true;\r\n}\r\nstatic int ti_msgmgr_send_data(struct mbox_chan *chan, void *data)\r\n{\r\nstruct device *dev = chan->mbox->dev;\r\nstruct ti_msgmgr_inst *inst = dev_get_drvdata(dev);\r\nconst struct ti_msgmgr_desc *desc;\r\nstruct ti_queue_inst *qinst = chan->con_priv;\r\nint num_words, trail_bytes;\r\nstruct ti_msgmgr_message *message = data;\r\nvoid __iomem *data_reg;\r\nu32 *word_data;\r\nif (WARN_ON(!inst)) {\r\ndev_err(dev, "no platform drv data??\n");\r\nreturn -EINVAL;\r\n}\r\ndesc = inst->desc;\r\nif (desc->max_message_size < message->len) {\r\ndev_err(dev, "Queue %s message length %d > max %d\n",\r\nqinst->name, message->len, desc->max_message_size);\r\nreturn -EINVAL;\r\n}\r\nfor (data_reg = qinst->queue_buff_start,\r\nnum_words = message->len / sizeof(u32),\r\nword_data = (u32 *)message->buf;\r\nnum_words; num_words--, data_reg += sizeof(u32), word_data++)\r\nwritel(*word_data, data_reg);\r\ntrail_bytes = message->len % sizeof(u32);\r\nif (trail_bytes) {\r\nu32 data_trail = *word_data;\r\ndata_trail &= 0xFFFFFFFF >> (8 * (sizeof(u32) - trail_bytes));\r\nwritel(data_trail, data_reg);\r\ndata_reg++;\r\n}\r\nif (data_reg <= qinst->queue_buff_end)\r\nwritel(0, qinst->queue_buff_end);\r\nreturn 0;\r\n}\r\nstatic int ti_msgmgr_queue_startup(struct mbox_chan *chan)\r\n{\r\nstruct ti_queue_inst *qinst = chan->con_priv;\r\nstruct device *dev = chan->mbox->dev;\r\nint ret;\r\nif (!qinst->is_tx) {\r\nret = request_irq(qinst->irq, ti_msgmgr_queue_rx_interrupt,\r\nIRQF_SHARED, qinst->name, chan);\r\nif (ret) {\r\ndev_err(dev, "Unable to get IRQ %d on %s(res=%d)\n",\r\nqinst->irq, qinst->name, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ti_msgmgr_queue_shutdown(struct mbox_chan *chan)\r\n{\r\nstruct ti_queue_inst *qinst = chan->con_priv;\r\nif (!qinst->is_tx)\r\nfree_irq(qinst->irq, chan);\r\n}\r\nstatic struct mbox_chan *ti_msgmgr_of_xlate(struct mbox_controller *mbox,\r\nconst struct of_phandle_args *p)\r\n{\r\nstruct ti_msgmgr_inst *inst;\r\nint req_qid, req_pid;\r\nstruct ti_queue_inst *qinst;\r\nint i;\r\ninst = container_of(mbox, struct ti_msgmgr_inst, mbox);\r\nif (WARN_ON(!inst))\r\nreturn ERR_PTR(-EINVAL);\r\nif (p->args_count != 2) {\r\ndev_err(inst->dev, "Invalid arguments in dt[%d] instead of 2\n",\r\np->args_count);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreq_qid = p->args[0];\r\nreq_pid = p->args[1];\r\nfor (qinst = inst->qinsts, i = 0; i < inst->num_valid_queues;\r\ni++, qinst++) {\r\nif (req_qid == qinst->queue_id && req_pid == qinst->proxy_id)\r\nreturn qinst->chan;\r\n}\r\ndev_err(inst->dev, "Queue ID %d, Proxy ID %d is wrong on %s\n",\r\nreq_qid, req_pid, p->np->name);\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic int ti_msgmgr_queue_setup(int idx, struct device *dev,\r\nstruct device_node *np,\r\nstruct ti_msgmgr_inst *inst,\r\nconst struct ti_msgmgr_desc *d,\r\nconst struct ti_msgmgr_valid_queue_desc *qd,\r\nstruct ti_queue_inst *qinst,\r\nstruct mbox_chan *chan)\r\n{\r\nqinst->proxy_id = qd->proxy_id;\r\nqinst->queue_id = qd->queue_id;\r\nif (qinst->queue_id > d->queue_count) {\r\ndev_err(dev, "Queue Data [idx=%d] queuid %d > %d\n",\r\nidx, qinst->queue_id, d->queue_count);\r\nreturn -ERANGE;\r\n}\r\nqinst->is_tx = qd->is_tx;\r\nsnprintf(qinst->name, sizeof(qinst->name), "%s %s_%03d_%03d",\r\ndev_name(dev), qinst->is_tx ? "tx" : "rx", qinst->queue_id,\r\nqinst->proxy_id);\r\nif (!qinst->is_tx) {\r\nchar of_rx_irq_name[7];\r\nsnprintf(of_rx_irq_name, sizeof(of_rx_irq_name),\r\n"rx_%03d", qinst->queue_id);\r\nqinst->irq = of_irq_get_byname(np, of_rx_irq_name);\r\nif (qinst->irq < 0) {\r\ndev_crit(dev,\r\n"[%d]QID %d PID %d:No IRQ[%s]: %d\n",\r\nidx, qinst->queue_id, qinst->proxy_id,\r\nof_rx_irq_name, qinst->irq);\r\nreturn qinst->irq;\r\n}\r\nqinst->rx_buff = devm_kzalloc(dev,\r\nd->max_message_size, GFP_KERNEL);\r\nif (!qinst->rx_buff)\r\nreturn -ENOMEM;\r\n}\r\nqinst->queue_buff_start = inst->queue_proxy_region +\r\nQ_DATA_OFFSET(qinst->proxy_id, qinst->queue_id, d->data_first_reg);\r\nqinst->queue_buff_end = inst->queue_proxy_region +\r\nQ_DATA_OFFSET(qinst->proxy_id, qinst->queue_id, d->data_last_reg);\r\nqinst->queue_state = inst->queue_state_debug_region +\r\nQ_STATE_OFFSET(qinst->queue_id);\r\nqinst->chan = chan;\r\nchan->con_priv = qinst;\r\ndev_dbg(dev, "[%d] qidx=%d pidx=%d irq=%d q_s=%p q_e = %p\n",\r\nidx, qinst->queue_id, qinst->proxy_id, qinst->irq,\r\nqinst->queue_buff_start, qinst->queue_buff_end);\r\nreturn 0;\r\n}\r\nstatic int ti_msgmgr_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *of_id;\r\nstruct device_node *np;\r\nstruct resource *res;\r\nconst struct ti_msgmgr_desc *desc;\r\nstruct ti_msgmgr_inst *inst;\r\nstruct ti_queue_inst *qinst;\r\nstruct mbox_controller *mbox;\r\nstruct mbox_chan *chans;\r\nint queue_count;\r\nint i;\r\nint ret = -EINVAL;\r\nconst struct ti_msgmgr_valid_queue_desc *queue_desc;\r\nif (!dev->of_node) {\r\ndev_err(dev, "no OF information\n");\r\nreturn -EINVAL;\r\n}\r\nnp = dev->of_node;\r\nof_id = of_match_device(ti_msgmgr_of_match, dev);\r\nif (!of_id) {\r\ndev_err(dev, "OF data missing\n");\r\nreturn -EINVAL;\r\n}\r\ndesc = of_id->data;\r\ninst = devm_kzalloc(dev, sizeof(*inst), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\ninst->dev = dev;\r\ninst->desc = desc;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"queue_proxy_region");\r\ninst->queue_proxy_region = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(inst->queue_proxy_region))\r\nreturn PTR_ERR(inst->queue_proxy_region);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"queue_state_debug_region");\r\ninst->queue_state_debug_region = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(inst->queue_state_debug_region))\r\nreturn PTR_ERR(inst->queue_state_debug_region);\r\ndev_dbg(dev, "proxy region=%p, queue_state=%p\n",\r\ninst->queue_proxy_region, inst->queue_state_debug_region);\r\nqueue_count = desc->num_valid_queues;\r\nif (!queue_count || queue_count > desc->queue_count) {\r\ndev_crit(dev, "Invalid Number of queues %d. Max %d\n",\r\nqueue_count, desc->queue_count);\r\nreturn -ERANGE;\r\n}\r\ninst->num_valid_queues = queue_count;\r\nqinst = devm_kzalloc(dev, sizeof(*qinst) * queue_count, GFP_KERNEL);\r\nif (!qinst)\r\nreturn -ENOMEM;\r\ninst->qinsts = qinst;\r\nchans = devm_kzalloc(dev, sizeof(*chans) * queue_count, GFP_KERNEL);\r\nif (!chans)\r\nreturn -ENOMEM;\r\ninst->chans = chans;\r\nfor (i = 0, queue_desc = desc->valid_queues;\r\ni < queue_count; i++, qinst++, chans++, queue_desc++) {\r\nret = ti_msgmgr_queue_setup(i, dev, np, inst,\r\ndesc, queue_desc, qinst, chans);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmbox = &inst->mbox;\r\nmbox->dev = dev;\r\nmbox->ops = &ti_msgmgr_chan_ops;\r\nmbox->chans = inst->chans;\r\nmbox->num_chans = inst->num_valid_queues;\r\nmbox->txdone_irq = false;\r\nmbox->txdone_poll = desc->tx_polled;\r\nif (desc->tx_polled)\r\nmbox->txpoll_period = desc->tx_poll_timeout_ms;\r\nmbox->of_xlate = ti_msgmgr_of_xlate;\r\nplatform_set_drvdata(pdev, inst);\r\nret = mbox_controller_register(mbox);\r\nif (ret)\r\ndev_err(dev, "Failed to register mbox_controller(%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int ti_msgmgr_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_msgmgr_inst *inst;\r\ninst = platform_get_drvdata(pdev);\r\nmbox_controller_unregister(&inst->mbox);\r\nreturn 0;\r\n}
