static struct per_pid *find_create_pid(struct timechart *tchart, int pid)\r\n{\r\nstruct per_pid *cursor = tchart->all_data;\r\nwhile (cursor) {\r\nif (cursor->pid == pid)\r\nreturn cursor;\r\ncursor = cursor->next;\r\n}\r\ncursor = zalloc(sizeof(*cursor));\r\nassert(cursor != NULL);\r\ncursor->pid = pid;\r\ncursor->next = tchart->all_data;\r\ntchart->all_data = cursor;\r\nreturn cursor;\r\n}\r\nstatic void pid_set_comm(struct timechart *tchart, int pid, char *comm)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\np = find_create_pid(tchart, pid);\r\nc = p->all;\r\nwhile (c) {\r\nif (c->comm && strcmp(c->comm, comm) == 0) {\r\np->current = c;\r\nreturn;\r\n}\r\nif (!c->comm) {\r\nc->comm = strdup(comm);\r\np->current = c;\r\nreturn;\r\n}\r\nc = c->next;\r\n}\r\nc = zalloc(sizeof(*c));\r\nassert(c != NULL);\r\nc->comm = strdup(comm);\r\np->current = c;\r\nc->next = p->all;\r\np->all = c;\r\n}\r\nstatic void pid_fork(struct timechart *tchart, int pid, int ppid, u64 timestamp)\r\n{\r\nstruct per_pid *p, *pp;\r\np = find_create_pid(tchart, pid);\r\npp = find_create_pid(tchart, ppid);\r\np->ppid = ppid;\r\nif (pp->current && pp->current->comm && !p->current)\r\npid_set_comm(tchart, pid, pp->current->comm);\r\np->start_time = timestamp;\r\nif (p->current && !p->current->start_time) {\r\np->current->start_time = timestamp;\r\np->current->state_since = timestamp;\r\n}\r\n}\r\nstatic void pid_exit(struct timechart *tchart, int pid, u64 timestamp)\r\n{\r\nstruct per_pid *p;\r\np = find_create_pid(tchart, pid);\r\np->end_time = timestamp;\r\nif (p->current)\r\np->current->end_time = timestamp;\r\n}\r\nstatic void pid_put_sample(struct timechart *tchart, int pid, int type,\r\nunsigned int cpu, u64 start, u64 end,\r\nconst char *backtrace)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nstruct cpu_sample *sample;\r\np = find_create_pid(tchart, pid);\r\nc = p->current;\r\nif (!c) {\r\nc = zalloc(sizeof(*c));\r\nassert(c != NULL);\r\np->current = c;\r\nc->next = p->all;\r\np->all = c;\r\n}\r\nsample = zalloc(sizeof(*sample));\r\nassert(sample != NULL);\r\nsample->start_time = start;\r\nsample->end_time = end;\r\nsample->type = type;\r\nsample->next = c->samples;\r\nsample->cpu = cpu;\r\nsample->backtrace = backtrace;\r\nc->samples = sample;\r\nif (sample->type == TYPE_RUNNING && end > start && start > 0) {\r\nc->total_time += (end-start);\r\np->total_time += (end-start);\r\n}\r\nif (c->start_time == 0 || c->start_time > start)\r\nc->start_time = start;\r\nif (p->start_time == 0 || p->start_time > start)\r\np->start_time = start;\r\n}\r\nstatic int process_comm_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct timechart *tchart = container_of(tool, struct timechart, tool);\r\npid_set_comm(tchart, event->comm.tid, event->comm.comm);\r\nreturn 0;\r\n}\r\nstatic int process_fork_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct timechart *tchart = container_of(tool, struct timechart, tool);\r\npid_fork(tchart, event->fork.pid, event->fork.ppid, event->fork.time);\r\nreturn 0;\r\n}\r\nstatic int process_exit_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct timechart *tchart = container_of(tool, struct timechart, tool);\r\npid_exit(tchart, event->fork.pid, event->fork.time);\r\nreturn 0;\r\n}\r\nstatic void c_state_start(int cpu, u64 timestamp, int state)\r\n{\r\ncpus_cstate_start_times[cpu] = timestamp;\r\ncpus_cstate_state[cpu] = state;\r\n}\r\nstatic void c_state_end(struct timechart *tchart, int cpu, u64 timestamp)\r\n{\r\nstruct power_event *pwr = zalloc(sizeof(*pwr));\r\nif (!pwr)\r\nreturn;\r\npwr->state = cpus_cstate_state[cpu];\r\npwr->start_time = cpus_cstate_start_times[cpu];\r\npwr->end_time = timestamp;\r\npwr->cpu = cpu;\r\npwr->type = CSTATE;\r\npwr->next = tchart->power_events;\r\ntchart->power_events = pwr;\r\n}\r\nstatic void p_state_change(struct timechart *tchart, int cpu, u64 timestamp, u64 new_freq)\r\n{\r\nstruct power_event *pwr;\r\nif (new_freq > 8000000)\r\nreturn;\r\npwr = zalloc(sizeof(*pwr));\r\nif (!pwr)\r\nreturn;\r\npwr->state = cpus_pstate_state[cpu];\r\npwr->start_time = cpus_pstate_start_times[cpu];\r\npwr->end_time = timestamp;\r\npwr->cpu = cpu;\r\npwr->type = PSTATE;\r\npwr->next = tchart->power_events;\r\nif (!pwr->start_time)\r\npwr->start_time = tchart->first_time;\r\ntchart->power_events = pwr;\r\ncpus_pstate_state[cpu] = new_freq;\r\ncpus_pstate_start_times[cpu] = timestamp;\r\nif ((u64)new_freq > tchart->max_freq)\r\ntchart->max_freq = new_freq;\r\nif (new_freq < tchart->min_freq || tchart->min_freq == 0)\r\ntchart->min_freq = new_freq;\r\nif (new_freq == tchart->max_freq - 1000)\r\ntchart->turbo_frequency = tchart->max_freq;\r\n}\r\nstatic void sched_wakeup(struct timechart *tchart, int cpu, u64 timestamp,\r\nint waker, int wakee, u8 flags, const char *backtrace)\r\n{\r\nstruct per_pid *p;\r\nstruct wake_event *we = zalloc(sizeof(*we));\r\nif (!we)\r\nreturn;\r\nwe->time = timestamp;\r\nwe->waker = waker;\r\nwe->backtrace = backtrace;\r\nif ((flags & TRACE_FLAG_HARDIRQ) || (flags & TRACE_FLAG_SOFTIRQ))\r\nwe->waker = -1;\r\nwe->wakee = wakee;\r\nwe->next = tchart->wake_events;\r\ntchart->wake_events = we;\r\np = find_create_pid(tchart, we->wakee);\r\nif (p && p->current && p->current->state == TYPE_NONE) {\r\np->current->state_since = timestamp;\r\np->current->state = TYPE_WAITING;\r\n}\r\nif (p && p->current && p->current->state == TYPE_BLOCKED) {\r\npid_put_sample(tchart, p->pid, p->current->state, cpu,\r\np->current->state_since, timestamp, NULL);\r\np->current->state_since = timestamp;\r\np->current->state = TYPE_WAITING;\r\n}\r\n}\r\nstatic void sched_switch(struct timechart *tchart, int cpu, u64 timestamp,\r\nint prev_pid, int next_pid, u64 prev_state,\r\nconst char *backtrace)\r\n{\r\nstruct per_pid *p = NULL, *prev_p;\r\nprev_p = find_create_pid(tchart, prev_pid);\r\np = find_create_pid(tchart, next_pid);\r\nif (prev_p->current && prev_p->current->state != TYPE_NONE)\r\npid_put_sample(tchart, prev_pid, TYPE_RUNNING, cpu,\r\nprev_p->current->state_since, timestamp,\r\nbacktrace);\r\nif (p && p->current) {\r\nif (p->current->state != TYPE_NONE)\r\npid_put_sample(tchart, next_pid, p->current->state, cpu,\r\np->current->state_since, timestamp,\r\nbacktrace);\r\np->current->state_since = timestamp;\r\np->current->state = TYPE_RUNNING;\r\n}\r\nif (prev_p->current) {\r\nprev_p->current->state = TYPE_NONE;\r\nprev_p->current->state_since = timestamp;\r\nif (prev_state & 2)\r\nprev_p->current->state = TYPE_BLOCKED;\r\nif (prev_state == 0)\r\nprev_p->current->state = TYPE_WAITING;\r\n}\r\n}\r\nstatic const char *cat_backtrace(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct addr_location al;\r\nunsigned int i;\r\nchar *p = NULL;\r\nsize_t p_len;\r\nu8 cpumode = PERF_RECORD_MISC_USER;\r\nstruct addr_location tal;\r\nstruct ip_callchain *chain = sample->callchain;\r\nFILE *f = open_memstream(&p, &p_len);\r\nif (!f) {\r\nperror("open_memstream error");\r\nreturn NULL;\r\n}\r\nif (!chain)\r\ngoto exit;\r\nif (machine__resolve(machine, &al, sample) < 0) {\r\nfprintf(stderr, "problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\ngoto exit;\r\n}\r\nfor (i = 0; i < chain->nr; i++) {\r\nu64 ip;\r\nif (callchain_param.order == ORDER_CALLEE)\r\nip = chain->ips[i];\r\nelse\r\nip = chain->ips[chain->nr - i - 1];\r\nif (ip >= PERF_CONTEXT_MAX) {\r\nswitch (ip) {\r\ncase PERF_CONTEXT_HV:\r\ncpumode = PERF_RECORD_MISC_HYPERVISOR;\r\nbreak;\r\ncase PERF_CONTEXT_KERNEL:\r\ncpumode = PERF_RECORD_MISC_KERNEL;\r\nbreak;\r\ncase PERF_CONTEXT_USER:\r\ncpumode = PERF_RECORD_MISC_USER;\r\nbreak;\r\ndefault:\r\npr_debug("invalid callchain context: "\r\n"%"PRId64"\n", (s64) ip);\r\nzfree(&p);\r\ngoto exit_put;\r\n}\r\ncontinue;\r\n}\r\ntal.filtered = 0;\r\nthread__find_addr_location(al.thread, cpumode,\r\nMAP__FUNCTION, ip, &tal);\r\nif (tal.sym)\r\nfprintf(f, "..... %016" PRIx64 " %s\n", ip,\r\ntal.sym->name);\r\nelse\r\nfprintf(f, "..... %016" PRIx64 "\n", ip);\r\n}\r\nexit_put:\r\naddr_location__put(&al);\r\nexit:\r\nfclose(f);\r\nreturn p;\r\n}\r\nstatic int process_sample_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct timechart *tchart = container_of(tool, struct timechart, tool);\r\nif (evsel->attr.sample_type & PERF_SAMPLE_TIME) {\r\nif (!tchart->first_time || tchart->first_time > sample->time)\r\ntchart->first_time = sample->time;\r\nif (tchart->last_time < sample->time)\r\ntchart->last_time = sample->time;\r\n}\r\nif (evsel->handler != NULL) {\r\ntracepoint_handler f = evsel->handler;\r\nreturn f(tchart, evsel, sample,\r\ncat_backtrace(event, sample, machine));\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nprocess_sample_cpu_idle(struct timechart *tchart __maybe_unused,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nconst char *backtrace __maybe_unused)\r\n{\r\nu32 state = perf_evsel__intval(evsel, sample, "state");\r\nu32 cpu_id = perf_evsel__intval(evsel, sample, "cpu_id");\r\nif (state == (u32)PWR_EVENT_EXIT)\r\nc_state_end(tchart, cpu_id, sample->time);\r\nelse\r\nc_state_start(cpu_id, sample->time, state);\r\nreturn 0;\r\n}\r\nstatic int\r\nprocess_sample_cpu_frequency(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nconst char *backtrace __maybe_unused)\r\n{\r\nu32 state = perf_evsel__intval(evsel, sample, "state");\r\nu32 cpu_id = perf_evsel__intval(evsel, sample, "cpu_id");\r\np_state_change(tchart, cpu_id, sample->time, state);\r\nreturn 0;\r\n}\r\nstatic int\r\nprocess_sample_sched_wakeup(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nconst char *backtrace)\r\n{\r\nu8 flags = perf_evsel__intval(evsel, sample, "common_flags");\r\nint waker = perf_evsel__intval(evsel, sample, "common_pid");\r\nint wakee = perf_evsel__intval(evsel, sample, "pid");\r\nsched_wakeup(tchart, sample->cpu, sample->time, waker, wakee, flags, backtrace);\r\nreturn 0;\r\n}\r\nstatic int\r\nprocess_sample_sched_switch(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nconst char *backtrace)\r\n{\r\nint prev_pid = perf_evsel__intval(evsel, sample, "prev_pid");\r\nint next_pid = perf_evsel__intval(evsel, sample, "next_pid");\r\nu64 prev_state = perf_evsel__intval(evsel, sample, "prev_state");\r\nsched_switch(tchart, sample->cpu, sample->time, prev_pid, next_pid,\r\nprev_state, backtrace);\r\nreturn 0;\r\n}\r\nstatic int\r\nprocess_sample_power_start(struct timechart *tchart __maybe_unused,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nconst char *backtrace __maybe_unused)\r\n{\r\nu64 cpu_id = perf_evsel__intval(evsel, sample, "cpu_id");\r\nu64 value = perf_evsel__intval(evsel, sample, "value");\r\nc_state_start(cpu_id, sample->time, value);\r\nreturn 0;\r\n}\r\nstatic int\r\nprocess_sample_power_end(struct timechart *tchart,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct perf_sample *sample,\r\nconst char *backtrace __maybe_unused)\r\n{\r\nc_state_end(tchart, sample->cpu, sample->time);\r\nreturn 0;\r\n}\r\nstatic int\r\nprocess_sample_power_frequency(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nconst char *backtrace __maybe_unused)\r\n{\r\nu64 cpu_id = perf_evsel__intval(evsel, sample, "cpu_id");\r\nu64 value = perf_evsel__intval(evsel, sample, "value");\r\np_state_change(tchart, cpu_id, sample->time, value);\r\nreturn 0;\r\n}\r\nstatic void end_sample_processing(struct timechart *tchart)\r\n{\r\nu64 cpu;\r\nstruct power_event *pwr;\r\nfor (cpu = 0; cpu <= tchart->numcpus; cpu++) {\r\n#if 0\r\npwr = zalloc(sizeof(*pwr));\r\nif (!pwr)\r\nreturn;\r\npwr->state = cpus_cstate_state[cpu];\r\npwr->start_time = cpus_cstate_start_times[cpu];\r\npwr->end_time = tchart->last_time;\r\npwr->cpu = cpu;\r\npwr->type = CSTATE;\r\npwr->next = tchart->power_events;\r\ntchart->power_events = pwr;\r\n#endif\r\npwr = zalloc(sizeof(*pwr));\r\nif (!pwr)\r\nreturn;\r\npwr->state = cpus_pstate_state[cpu];\r\npwr->start_time = cpus_pstate_start_times[cpu];\r\npwr->end_time = tchart->last_time;\r\npwr->cpu = cpu;\r\npwr->type = PSTATE;\r\npwr->next = tchart->power_events;\r\nif (!pwr->start_time)\r\npwr->start_time = tchart->first_time;\r\nif (!pwr->state)\r\npwr->state = tchart->min_freq;\r\ntchart->power_events = pwr;\r\n}\r\n}\r\nstatic int pid_begin_io_sample(struct timechart *tchart, int pid, int type,\r\nu64 start, int fd)\r\n{\r\nstruct per_pid *p = find_create_pid(tchart, pid);\r\nstruct per_pidcomm *c = p->current;\r\nstruct io_sample *sample;\r\nstruct io_sample *prev;\r\nif (!c) {\r\nc = zalloc(sizeof(*c));\r\nif (!c)\r\nreturn -ENOMEM;\r\np->current = c;\r\nc->next = p->all;\r\np->all = c;\r\n}\r\nprev = c->io_samples;\r\nif (prev && prev->start_time && !prev->end_time) {\r\npr_warning("Skip invalid start event: "\r\n"previous event already started!\n");\r\nc->io_samples = prev->next;\r\nfree(prev);\r\nreturn 0;\r\n}\r\nsample = zalloc(sizeof(*sample));\r\nif (!sample)\r\nreturn -ENOMEM;\r\nsample->start_time = start;\r\nsample->type = type;\r\nsample->fd = fd;\r\nsample->next = c->io_samples;\r\nc->io_samples = sample;\r\nif (c->start_time == 0 || c->start_time > start)\r\nc->start_time = start;\r\nreturn 0;\r\n}\r\nstatic int pid_end_io_sample(struct timechart *tchart, int pid, int type,\r\nu64 end, long ret)\r\n{\r\nstruct per_pid *p = find_create_pid(tchart, pid);\r\nstruct per_pidcomm *c = p->current;\r\nstruct io_sample *sample, *prev;\r\nif (!c) {\r\npr_warning("Invalid pidcomm!\n");\r\nreturn -1;\r\n}\r\nsample = c->io_samples;\r\nif (!sample)\r\nreturn 0;\r\nif (sample->end_time) {\r\npr_warning("Skip invalid end event: "\r\n"previous event already ended!\n");\r\nreturn 0;\r\n}\r\nif (sample->type != type) {\r\npr_warning("Skip invalid end event: invalid event type!\n");\r\nreturn 0;\r\n}\r\nsample->end_time = end;\r\nprev = sample->next;\r\nif (sample->end_time - sample->start_time < tchart->min_time)\r\nsample->end_time = sample->start_time + tchart->min_time;\r\nif (prev && sample->start_time < prev->end_time) {\r\nif (prev->err)\r\nsample->start_time = prev->end_time;\r\nelse\r\nprev->end_time = sample->start_time;\r\n}\r\nif (ret < 0) {\r\nsample->err = ret;\r\n} else if (type == IOTYPE_READ || type == IOTYPE_WRITE ||\r\ntype == IOTYPE_TX || type == IOTYPE_RX) {\r\nif ((u64)ret > c->max_bytes)\r\nc->max_bytes = ret;\r\nc->total_bytes += ret;\r\np->total_bytes += ret;\r\nsample->bytes = ret;\r\n}\r\nif (prev &&\r\nprev->type == sample->type &&\r\nprev->err == sample->err &&\r\nprev->fd == sample->fd &&\r\nprev->end_time + tchart->merge_dist >= sample->start_time) {\r\nsample->bytes += prev->bytes;\r\nsample->merges += prev->merges + 1;\r\nsample->start_time = prev->start_time;\r\nsample->next = prev->next;\r\nfree(prev);\r\nif (!sample->err && sample->bytes > c->max_bytes)\r\nc->max_bytes = sample->bytes;\r\n}\r\ntchart->io_events++;\r\nreturn 0;\r\n}\r\nstatic int\r\nprocess_enter_read(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong fd = perf_evsel__intval(evsel, sample, "fd");\r\nreturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_READ,\r\nsample->time, fd);\r\n}\r\nstatic int\r\nprocess_exit_read(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong ret = perf_evsel__intval(evsel, sample, "ret");\r\nreturn pid_end_io_sample(tchart, sample->tid, IOTYPE_READ,\r\nsample->time, ret);\r\n}\r\nstatic int\r\nprocess_enter_write(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong fd = perf_evsel__intval(evsel, sample, "fd");\r\nreturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_WRITE,\r\nsample->time, fd);\r\n}\r\nstatic int\r\nprocess_exit_write(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong ret = perf_evsel__intval(evsel, sample, "ret");\r\nreturn pid_end_io_sample(tchart, sample->tid, IOTYPE_WRITE,\r\nsample->time, ret);\r\n}\r\nstatic int\r\nprocess_enter_sync(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong fd = perf_evsel__intval(evsel, sample, "fd");\r\nreturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_SYNC,\r\nsample->time, fd);\r\n}\r\nstatic int\r\nprocess_exit_sync(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong ret = perf_evsel__intval(evsel, sample, "ret");\r\nreturn pid_end_io_sample(tchart, sample->tid, IOTYPE_SYNC,\r\nsample->time, ret);\r\n}\r\nstatic int\r\nprocess_enter_tx(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong fd = perf_evsel__intval(evsel, sample, "fd");\r\nreturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_TX,\r\nsample->time, fd);\r\n}\r\nstatic int\r\nprocess_exit_tx(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong ret = perf_evsel__intval(evsel, sample, "ret");\r\nreturn pid_end_io_sample(tchart, sample->tid, IOTYPE_TX,\r\nsample->time, ret);\r\n}\r\nstatic int\r\nprocess_enter_rx(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong fd = perf_evsel__intval(evsel, sample, "fd");\r\nreturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_RX,\r\nsample->time, fd);\r\n}\r\nstatic int\r\nprocess_exit_rx(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong ret = perf_evsel__intval(evsel, sample, "ret");\r\nreturn pid_end_io_sample(tchart, sample->tid, IOTYPE_RX,\r\nsample->time, ret);\r\n}\r\nstatic int\r\nprocess_enter_poll(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong fd = perf_evsel__intval(evsel, sample, "fd");\r\nreturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_POLL,\r\nsample->time, fd);\r\n}\r\nstatic int\r\nprocess_exit_poll(struct timechart *tchart,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nlong ret = perf_evsel__intval(evsel, sample, "ret");\r\nreturn pid_end_io_sample(tchart, sample->tid, IOTYPE_POLL,\r\nsample->time, ret);\r\n}\r\nstatic void sort_pids(struct timechart *tchart)\r\n{\r\nstruct per_pid *new_list, *p, *cursor, *prev;\r\nnew_list = NULL;\r\nwhile (tchart->all_data) {\r\np = tchart->all_data;\r\ntchart->all_data = p->next;\r\np->next = NULL;\r\nif (new_list == NULL) {\r\nnew_list = p;\r\np->next = NULL;\r\ncontinue;\r\n}\r\nprev = NULL;\r\ncursor = new_list;\r\nwhile (cursor) {\r\nif (cursor->ppid > p->ppid ||\r\n(cursor->ppid == p->ppid && cursor->pid > p->pid)) {\r\nif (prev) {\r\np->next = prev->next;\r\nprev->next = p;\r\ncursor = NULL;\r\ncontinue;\r\n} else {\r\np->next = new_list;\r\nnew_list = p;\r\ncursor = NULL;\r\ncontinue;\r\n}\r\n}\r\nprev = cursor;\r\ncursor = cursor->next;\r\nif (!cursor)\r\nprev->next = p;\r\n}\r\n}\r\ntchart->all_data = new_list;\r\n}\r\nstatic void draw_c_p_states(struct timechart *tchart)\r\n{\r\nstruct power_event *pwr;\r\npwr = tchart->power_events;\r\nwhile (pwr) {\r\nif (pwr->type == CSTATE)\r\nsvg_cstate(pwr->cpu, pwr->start_time, pwr->end_time, pwr->state);\r\npwr = pwr->next;\r\n}\r\npwr = tchart->power_events;\r\nwhile (pwr) {\r\nif (pwr->type == PSTATE) {\r\nif (!pwr->state)\r\npwr->state = tchart->min_freq;\r\nsvg_pstate(pwr->cpu, pwr->start_time, pwr->end_time, pwr->state);\r\n}\r\npwr = pwr->next;\r\n}\r\n}\r\nstatic void draw_wakeups(struct timechart *tchart)\r\n{\r\nstruct wake_event *we;\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nwe = tchart->wake_events;\r\nwhile (we) {\r\nint from = 0, to = 0;\r\nchar *task_from = NULL, *task_to = NULL;\r\np = tchart->all_data;\r\nwhile (p) {\r\nif (p->pid == we->waker || p->pid == we->wakee) {\r\nc = p->all;\r\nwhile (c) {\r\nif (c->Y && c->start_time <= we->time && c->end_time >= we->time) {\r\nif (p->pid == we->waker && !from) {\r\nfrom = c->Y;\r\ntask_from = strdup(c->comm);\r\n}\r\nif (p->pid == we->wakee && !to) {\r\nto = c->Y;\r\ntask_to = strdup(c->comm);\r\n}\r\n}\r\nc = c->next;\r\n}\r\nc = p->all;\r\nwhile (c) {\r\nif (p->pid == we->waker && !from) {\r\nfrom = c->Y;\r\ntask_from = strdup(c->comm);\r\n}\r\nif (p->pid == we->wakee && !to) {\r\nto = c->Y;\r\ntask_to = strdup(c->comm);\r\n}\r\nc = c->next;\r\n}\r\n}\r\np = p->next;\r\n}\r\nif (!task_from) {\r\ntask_from = malloc(40);\r\nsprintf(task_from, "[%i]", we->waker);\r\n}\r\nif (!task_to) {\r\ntask_to = malloc(40);\r\nsprintf(task_to, "[%i]", we->wakee);\r\n}\r\nif (we->waker == -1)\r\nsvg_interrupt(we->time, to, we->backtrace);\r\nelse if (from && to && abs(from - to) == 1)\r\nsvg_wakeline(we->time, from, to, we->backtrace);\r\nelse\r\nsvg_partial_wakeline(we->time, from, task_from, to,\r\ntask_to, we->backtrace);\r\nwe = we->next;\r\nfree(task_from);\r\nfree(task_to);\r\n}\r\n}\r\nstatic void draw_cpu_usage(struct timechart *tchart)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nstruct cpu_sample *sample;\r\np = tchart->all_data;\r\nwhile (p) {\r\nc = p->all;\r\nwhile (c) {\r\nsample = c->samples;\r\nwhile (sample) {\r\nif (sample->type == TYPE_RUNNING) {\r\nsvg_process(sample->cpu,\r\nsample->start_time,\r\nsample->end_time,\r\np->pid,\r\nc->comm,\r\nsample->backtrace);\r\n}\r\nsample = sample->next;\r\n}\r\nc = c->next;\r\n}\r\np = p->next;\r\n}\r\n}\r\nstatic void draw_io_bars(struct timechart *tchart)\r\n{\r\nconst char *suf;\r\ndouble bytes;\r\nchar comm[256];\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nstruct io_sample *sample;\r\nint Y = 1;\r\np = tchart->all_data;\r\nwhile (p) {\r\nc = p->all;\r\nwhile (c) {\r\nif (!c->display) {\r\nc->Y = 0;\r\nc = c->next;\r\ncontinue;\r\n}\r\nsvg_box(Y, c->start_time, c->end_time, "process3");\r\nsample = c->io_samples;\r\nfor (sample = c->io_samples; sample; sample = sample->next) {\r\ndouble h = (double)sample->bytes / c->max_bytes;\r\nif (tchart->skip_eagain &&\r\nsample->err == -EAGAIN)\r\ncontinue;\r\nif (sample->err)\r\nh = 1;\r\nif (sample->type == IOTYPE_SYNC)\r\nsvg_fbox(Y,\r\nsample->start_time,\r\nsample->end_time,\r\n1,\r\nsample->err ? "error" : "sync",\r\nsample->fd,\r\nsample->err,\r\nsample->merges);\r\nelse if (sample->type == IOTYPE_POLL)\r\nsvg_fbox(Y,\r\nsample->start_time,\r\nsample->end_time,\r\n1,\r\nsample->err ? "error" : "poll",\r\nsample->fd,\r\nsample->err,\r\nsample->merges);\r\nelse if (sample->type == IOTYPE_READ)\r\nsvg_ubox(Y,\r\nsample->start_time,\r\nsample->end_time,\r\nh,\r\nsample->err ? "error" : "disk",\r\nsample->fd,\r\nsample->err,\r\nsample->merges);\r\nelse if (sample->type == IOTYPE_WRITE)\r\nsvg_lbox(Y,\r\nsample->start_time,\r\nsample->end_time,\r\nh,\r\nsample->err ? "error" : "disk",\r\nsample->fd,\r\nsample->err,\r\nsample->merges);\r\nelse if (sample->type == IOTYPE_RX)\r\nsvg_ubox(Y,\r\nsample->start_time,\r\nsample->end_time,\r\nh,\r\nsample->err ? "error" : "net",\r\nsample->fd,\r\nsample->err,\r\nsample->merges);\r\nelse if (sample->type == IOTYPE_TX)\r\nsvg_lbox(Y,\r\nsample->start_time,\r\nsample->end_time,\r\nh,\r\nsample->err ? "error" : "net",\r\nsample->fd,\r\nsample->err,\r\nsample->merges);\r\n}\r\nsuf = "";\r\nbytes = c->total_bytes;\r\nif (bytes > 1024) {\r\nbytes = bytes / 1024;\r\nsuf = "K";\r\n}\r\nif (bytes > 1024) {\r\nbytes = bytes / 1024;\r\nsuf = "M";\r\n}\r\nif (bytes > 1024) {\r\nbytes = bytes / 1024;\r\nsuf = "G";\r\n}\r\nsprintf(comm, "%s:%i (%3.1f %sbytes)", c->comm ?: "", p->pid, bytes, suf);\r\nsvg_text(Y, c->start_time, comm);\r\nc->Y = Y;\r\nY++;\r\nc = c->next;\r\n}\r\np = p->next;\r\n}\r\n}\r\nstatic void draw_process_bars(struct timechart *tchart)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nstruct cpu_sample *sample;\r\nint Y = 0;\r\nY = 2 * tchart->numcpus + 2;\r\np = tchart->all_data;\r\nwhile (p) {\r\nc = p->all;\r\nwhile (c) {\r\nif (!c->display) {\r\nc->Y = 0;\r\nc = c->next;\r\ncontinue;\r\n}\r\nsvg_box(Y, c->start_time, c->end_time, "process");\r\nsample = c->samples;\r\nwhile (sample) {\r\nif (sample->type == TYPE_RUNNING)\r\nsvg_running(Y, sample->cpu,\r\nsample->start_time,\r\nsample->end_time,\r\nsample->backtrace);\r\nif (sample->type == TYPE_BLOCKED)\r\nsvg_blocked(Y, sample->cpu,\r\nsample->start_time,\r\nsample->end_time,\r\nsample->backtrace);\r\nif (sample->type == TYPE_WAITING)\r\nsvg_waiting(Y, sample->cpu,\r\nsample->start_time,\r\nsample->end_time,\r\nsample->backtrace);\r\nsample = sample->next;\r\n}\r\nif (c->comm) {\r\nchar comm[256];\r\nif (c->total_time > 5000000000)\r\nsprintf(comm, "%s:%i (%2.2fs)", c->comm, p->pid, c->total_time / 1000000000.0);\r\nelse\r\nsprintf(comm, "%s:%i (%3.1fms)", c->comm, p->pid, c->total_time / 1000000.0);\r\nsvg_text(Y, c->start_time, comm);\r\n}\r\nc->Y = Y;\r\nY++;\r\nc = c->next;\r\n}\r\np = p->next;\r\n}\r\n}\r\nstatic void add_process_filter(const char *string)\r\n{\r\nint pid = strtoull(string, NULL, 10);\r\nstruct process_filter *filt = malloc(sizeof(*filt));\r\nif (!filt)\r\nreturn;\r\nfilt->name = strdup(string);\r\nfilt->pid = pid;\r\nfilt->next = process_filter;\r\nprocess_filter = filt;\r\n}\r\nstatic int passes_filter(struct per_pid *p, struct per_pidcomm *c)\r\n{\r\nstruct process_filter *filt;\r\nif (!process_filter)\r\nreturn 1;\r\nfilt = process_filter;\r\nwhile (filt) {\r\nif (filt->pid && p->pid == filt->pid)\r\nreturn 1;\r\nif (strcmp(filt->name, c->comm) == 0)\r\nreturn 1;\r\nfilt = filt->next;\r\n}\r\nreturn 0;\r\n}\r\nstatic int determine_display_tasks_filtered(struct timechart *tchart)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nint count = 0;\r\np = tchart->all_data;\r\nwhile (p) {\r\np->display = 0;\r\nif (p->start_time == 1)\r\np->start_time = tchart->first_time;\r\nif (p->end_time == 0)\r\np->end_time = tchart->last_time;\r\nc = p->all;\r\nwhile (c) {\r\nc->display = 0;\r\nif (c->start_time == 1)\r\nc->start_time = tchart->first_time;\r\nif (passes_filter(p, c)) {\r\nc->display = 1;\r\np->display = 1;\r\ncount++;\r\n}\r\nif (c->end_time == 0)\r\nc->end_time = tchart->last_time;\r\nc = c->next;\r\n}\r\np = p->next;\r\n}\r\nreturn count;\r\n}\r\nstatic int determine_display_tasks(struct timechart *tchart, u64 threshold)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nint count = 0;\r\np = tchart->all_data;\r\nwhile (p) {\r\np->display = 0;\r\nif (p->start_time == 1)\r\np->start_time = tchart->first_time;\r\nif (p->end_time == 0)\r\np->end_time = tchart->last_time;\r\nif (p->total_time >= threshold)\r\np->display = 1;\r\nc = p->all;\r\nwhile (c) {\r\nc->display = 0;\r\nif (c->start_time == 1)\r\nc->start_time = tchart->first_time;\r\nif (c->total_time >= threshold) {\r\nc->display = 1;\r\ncount++;\r\n}\r\nif (c->end_time == 0)\r\nc->end_time = tchart->last_time;\r\nc = c->next;\r\n}\r\np = p->next;\r\n}\r\nreturn count;\r\n}\r\nstatic int determine_display_io_tasks(struct timechart *timechart, u64 threshold)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nint count = 0;\r\np = timechart->all_data;\r\nwhile (p) {\r\nif (p->end_time == 0)\r\np->end_time = timechart->last_time;\r\nc = p->all;\r\nwhile (c) {\r\nc->display = 0;\r\nif (c->total_bytes >= threshold) {\r\nc->display = 1;\r\ncount++;\r\n}\r\nif (c->end_time == 0)\r\nc->end_time = timechart->last_time;\r\nc = c->next;\r\n}\r\np = p->next;\r\n}\r\nreturn count;\r\n}\r\nstatic void write_svg_file(struct timechart *tchart, const char *filename)\r\n{\r\nu64 i;\r\nint count;\r\nint thresh = tchart->io_events ? BYTES_THRESH : TIME_THRESH;\r\nif (tchart->power_only)\r\ntchart->proc_num = 0;\r\ndo {\r\nif (process_filter)\r\ncount = determine_display_tasks_filtered(tchart);\r\nelse if (tchart->io_events)\r\ncount = determine_display_io_tasks(tchart, thresh);\r\nelse\r\ncount = determine_display_tasks(tchart, thresh);\r\nthresh /= 10;\r\n} while (!process_filter && thresh && count < tchart->proc_num);\r\nif (!tchart->proc_num)\r\ncount = 0;\r\nif (tchart->io_events) {\r\nopen_svg(filename, 0, count, tchart->first_time, tchart->last_time);\r\nsvg_time_grid(0.5);\r\nsvg_io_legenda();\r\ndraw_io_bars(tchart);\r\n} else {\r\nopen_svg(filename, tchart->numcpus, count, tchart->first_time, tchart->last_time);\r\nsvg_time_grid(0);\r\nsvg_legenda();\r\nfor (i = 0; i < tchart->numcpus; i++)\r\nsvg_cpu_box(i, tchart->max_freq, tchart->turbo_frequency);\r\ndraw_cpu_usage(tchart);\r\nif (tchart->proc_num)\r\ndraw_process_bars(tchart);\r\nif (!tchart->tasks_only)\r\ndraw_c_p_states(tchart);\r\nif (tchart->proc_num)\r\ndraw_wakeups(tchart);\r\n}\r\nsvg_close();\r\n}\r\nstatic int process_header(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph,\r\nint feat,\r\nint fd __maybe_unused,\r\nvoid *data)\r\n{\r\nstruct timechart *tchart = data;\r\nswitch (feat) {\r\ncase HEADER_NRCPUS:\r\ntchart->numcpus = ph->env.nr_cpus_avail;\r\nbreak;\r\ncase HEADER_CPU_TOPOLOGY:\r\nif (!tchart->topology)\r\nbreak;\r\nif (svg_build_topology_map(ph->env.sibling_cores,\r\nph->env.nr_sibling_cores,\r\nph->env.sibling_threads,\r\nph->env.nr_sibling_threads))\r\nfprintf(stderr, "problem building topology\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __cmd_timechart(struct timechart *tchart, const char *output_name)\r\n{\r\nconst struct perf_evsel_str_handler power_tracepoints[] = {\r\n{ "power:cpu_idle", process_sample_cpu_idle },\r\n{ "power:cpu_frequency", process_sample_cpu_frequency },\r\n{ "sched:sched_wakeup", process_sample_sched_wakeup },\r\n{ "sched:sched_switch", process_sample_sched_switch },\r\n#ifdef SUPPORT_OLD_POWER_EVENTS\r\n{ "power:power_start", process_sample_power_start },\r\n{ "power:power_end", process_sample_power_end },\r\n{ "power:power_frequency", process_sample_power_frequency },\r\n#endif\r\n{ "syscalls:sys_enter_read", process_enter_read },\r\n{ "syscalls:sys_enter_pread64", process_enter_read },\r\n{ "syscalls:sys_enter_readv", process_enter_read },\r\n{ "syscalls:sys_enter_preadv", process_enter_read },\r\n{ "syscalls:sys_enter_write", process_enter_write },\r\n{ "syscalls:sys_enter_pwrite64", process_enter_write },\r\n{ "syscalls:sys_enter_writev", process_enter_write },\r\n{ "syscalls:sys_enter_pwritev", process_enter_write },\r\n{ "syscalls:sys_enter_sync", process_enter_sync },\r\n{ "syscalls:sys_enter_sync_file_range", process_enter_sync },\r\n{ "syscalls:sys_enter_fsync", process_enter_sync },\r\n{ "syscalls:sys_enter_msync", process_enter_sync },\r\n{ "syscalls:sys_enter_recvfrom", process_enter_rx },\r\n{ "syscalls:sys_enter_recvmmsg", process_enter_rx },\r\n{ "syscalls:sys_enter_recvmsg", process_enter_rx },\r\n{ "syscalls:sys_enter_sendto", process_enter_tx },\r\n{ "syscalls:sys_enter_sendmsg", process_enter_tx },\r\n{ "syscalls:sys_enter_sendmmsg", process_enter_tx },\r\n{ "syscalls:sys_enter_epoll_pwait", process_enter_poll },\r\n{ "syscalls:sys_enter_epoll_wait", process_enter_poll },\r\n{ "syscalls:sys_enter_poll", process_enter_poll },\r\n{ "syscalls:sys_enter_ppoll", process_enter_poll },\r\n{ "syscalls:sys_enter_pselect6", process_enter_poll },\r\n{ "syscalls:sys_enter_select", process_enter_poll },\r\n{ "syscalls:sys_exit_read", process_exit_read },\r\n{ "syscalls:sys_exit_pread64", process_exit_read },\r\n{ "syscalls:sys_exit_readv", process_exit_read },\r\n{ "syscalls:sys_exit_preadv", process_exit_read },\r\n{ "syscalls:sys_exit_write", process_exit_write },\r\n{ "syscalls:sys_exit_pwrite64", process_exit_write },\r\n{ "syscalls:sys_exit_writev", process_exit_write },\r\n{ "syscalls:sys_exit_pwritev", process_exit_write },\r\n{ "syscalls:sys_exit_sync", process_exit_sync },\r\n{ "syscalls:sys_exit_sync_file_range", process_exit_sync },\r\n{ "syscalls:sys_exit_fsync", process_exit_sync },\r\n{ "syscalls:sys_exit_msync", process_exit_sync },\r\n{ "syscalls:sys_exit_recvfrom", process_exit_rx },\r\n{ "syscalls:sys_exit_recvmmsg", process_exit_rx },\r\n{ "syscalls:sys_exit_recvmsg", process_exit_rx },\r\n{ "syscalls:sys_exit_sendto", process_exit_tx },\r\n{ "syscalls:sys_exit_sendmsg", process_exit_tx },\r\n{ "syscalls:sys_exit_sendmmsg", process_exit_tx },\r\n{ "syscalls:sys_exit_epoll_pwait", process_exit_poll },\r\n{ "syscalls:sys_exit_epoll_wait", process_exit_poll },\r\n{ "syscalls:sys_exit_poll", process_exit_poll },\r\n{ "syscalls:sys_exit_ppoll", process_exit_poll },\r\n{ "syscalls:sys_exit_pselect6", process_exit_poll },\r\n{ "syscalls:sys_exit_select", process_exit_poll },\r\n};\r\nstruct perf_data_file file = {\r\n.path = input_name,\r\n.mode = PERF_DATA_MODE_READ,\r\n.force = tchart->force,\r\n};\r\nstruct perf_session *session = perf_session__new(&file, false,\r\n&tchart->tool);\r\nint ret = -EINVAL;\r\nif (session == NULL)\r\nreturn -1;\r\nsymbol__init(&session->header.env);\r\n(void)perf_header__process_sections(&session->header,\r\nperf_data_file__fd(session->file),\r\ntchart,\r\nprocess_header);\r\nif (!perf_session__has_traces(session, "timechart record"))\r\ngoto out_delete;\r\nif (perf_session__set_tracepoints_handlers(session,\r\npower_tracepoints)) {\r\npr_err("Initializing session tracepoint handlers failed\n");\r\ngoto out_delete;\r\n}\r\nret = perf_session__process_events(session);\r\nif (ret)\r\ngoto out_delete;\r\nend_sample_processing(tchart);\r\nsort_pids(tchart);\r\nwrite_svg_file(tchart, output_name);\r\npr_info("Written %2.1f seconds of trace to %s.\n",\r\n(tchart->last_time - tchart->first_time) / 1000000000.0, output_name);\r\nout_delete:\r\nperf_session__delete(session);\r\nreturn ret;\r\n}\r\nstatic int timechart__io_record(int argc, const char **argv)\r\n{\r\nunsigned int rec_argc, i;\r\nconst char **rec_argv;\r\nconst char **p;\r\nchar *filter = NULL;\r\nconst char * const common_args[] = {\r\n"record", "-a", "-R", "-c", "1",\r\n};\r\nunsigned int common_args_nr = ARRAY_SIZE(common_args);\r\nconst char * const disk_events[] = {\r\n"syscalls:sys_enter_read",\r\n"syscalls:sys_enter_pread64",\r\n"syscalls:sys_enter_readv",\r\n"syscalls:sys_enter_preadv",\r\n"syscalls:sys_enter_write",\r\n"syscalls:sys_enter_pwrite64",\r\n"syscalls:sys_enter_writev",\r\n"syscalls:sys_enter_pwritev",\r\n"syscalls:sys_enter_sync",\r\n"syscalls:sys_enter_sync_file_range",\r\n"syscalls:sys_enter_fsync",\r\n"syscalls:sys_enter_msync",\r\n"syscalls:sys_exit_read",\r\n"syscalls:sys_exit_pread64",\r\n"syscalls:sys_exit_readv",\r\n"syscalls:sys_exit_preadv",\r\n"syscalls:sys_exit_write",\r\n"syscalls:sys_exit_pwrite64",\r\n"syscalls:sys_exit_writev",\r\n"syscalls:sys_exit_pwritev",\r\n"syscalls:sys_exit_sync",\r\n"syscalls:sys_exit_sync_file_range",\r\n"syscalls:sys_exit_fsync",\r\n"syscalls:sys_exit_msync",\r\n};\r\nunsigned int disk_events_nr = ARRAY_SIZE(disk_events);\r\nconst char * const net_events[] = {\r\n"syscalls:sys_enter_recvfrom",\r\n"syscalls:sys_enter_recvmmsg",\r\n"syscalls:sys_enter_recvmsg",\r\n"syscalls:sys_enter_sendto",\r\n"syscalls:sys_enter_sendmsg",\r\n"syscalls:sys_enter_sendmmsg",\r\n"syscalls:sys_exit_recvfrom",\r\n"syscalls:sys_exit_recvmmsg",\r\n"syscalls:sys_exit_recvmsg",\r\n"syscalls:sys_exit_sendto",\r\n"syscalls:sys_exit_sendmsg",\r\n"syscalls:sys_exit_sendmmsg",\r\n};\r\nunsigned int net_events_nr = ARRAY_SIZE(net_events);\r\nconst char * const poll_events[] = {\r\n"syscalls:sys_enter_epoll_pwait",\r\n"syscalls:sys_enter_epoll_wait",\r\n"syscalls:sys_enter_poll",\r\n"syscalls:sys_enter_ppoll",\r\n"syscalls:sys_enter_pselect6",\r\n"syscalls:sys_enter_select",\r\n"syscalls:sys_exit_epoll_pwait",\r\n"syscalls:sys_exit_epoll_wait",\r\n"syscalls:sys_exit_poll",\r\n"syscalls:sys_exit_ppoll",\r\n"syscalls:sys_exit_pselect6",\r\n"syscalls:sys_exit_select",\r\n};\r\nunsigned int poll_events_nr = ARRAY_SIZE(poll_events);\r\nrec_argc = common_args_nr +\r\ndisk_events_nr * 4 +\r\nnet_events_nr * 4 +\r\npoll_events_nr * 4 +\r\nargc;\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nif (rec_argv == NULL)\r\nreturn -ENOMEM;\r\nif (asprintf(&filter, "common_pid != %d", getpid()) < 0)\r\nreturn -ENOMEM;\r\np = rec_argv;\r\nfor (i = 0; i < common_args_nr; i++)\r\n*p++ = strdup(common_args[i]);\r\nfor (i = 0; i < disk_events_nr; i++) {\r\nif (!is_valid_tracepoint(disk_events[i])) {\r\nrec_argc -= 4;\r\ncontinue;\r\n}\r\n*p++ = "-e";\r\n*p++ = strdup(disk_events[i]);\r\n*p++ = "--filter";\r\n*p++ = filter;\r\n}\r\nfor (i = 0; i < net_events_nr; i++) {\r\nif (!is_valid_tracepoint(net_events[i])) {\r\nrec_argc -= 4;\r\ncontinue;\r\n}\r\n*p++ = "-e";\r\n*p++ = strdup(net_events[i]);\r\n*p++ = "--filter";\r\n*p++ = filter;\r\n}\r\nfor (i = 0; i < poll_events_nr; i++) {\r\nif (!is_valid_tracepoint(poll_events[i])) {\r\nrec_argc -= 4;\r\ncontinue;\r\n}\r\n*p++ = "-e";\r\n*p++ = strdup(poll_events[i]);\r\n*p++ = "--filter";\r\n*p++ = filter;\r\n}\r\nfor (i = 0; i < (unsigned int)argc; i++)\r\n*p++ = argv[i];\r\nreturn cmd_record(rec_argc, rec_argv, NULL);\r\n}\r\nstatic int timechart__record(struct timechart *tchart, int argc, const char **argv)\r\n{\r\nunsigned int rec_argc, i, j;\r\nconst char **rec_argv;\r\nconst char **p;\r\nunsigned int record_elems;\r\nconst char * const common_args[] = {\r\n"record", "-a", "-R", "-c", "1",\r\n};\r\nunsigned int common_args_nr = ARRAY_SIZE(common_args);\r\nconst char * const backtrace_args[] = {\r\n"-g",\r\n};\r\nunsigned int backtrace_args_no = ARRAY_SIZE(backtrace_args);\r\nconst char * const power_args[] = {\r\n"-e", "power:cpu_frequency",\r\n"-e", "power:cpu_idle",\r\n};\r\nunsigned int power_args_nr = ARRAY_SIZE(power_args);\r\nconst char * const old_power_args[] = {\r\n#ifdef SUPPORT_OLD_POWER_EVENTS\r\n"-e", "power:power_start",\r\n"-e", "power:power_end",\r\n"-e", "power:power_frequency",\r\n#endif\r\n};\r\nunsigned int old_power_args_nr = ARRAY_SIZE(old_power_args);\r\nconst char * const tasks_args[] = {\r\n"-e", "sched:sched_wakeup",\r\n"-e", "sched:sched_switch",\r\n};\r\nunsigned int tasks_args_nr = ARRAY_SIZE(tasks_args);\r\n#ifdef SUPPORT_OLD_POWER_EVENTS\r\nif (!is_valid_tracepoint("power:cpu_idle") &&\r\nis_valid_tracepoint("power:power_start")) {\r\nuse_old_power_events = 1;\r\npower_args_nr = 0;\r\n} else {\r\nold_power_args_nr = 0;\r\n}\r\n#endif\r\nif (tchart->power_only)\r\ntasks_args_nr = 0;\r\nif (tchart->tasks_only) {\r\npower_args_nr = 0;\r\nold_power_args_nr = 0;\r\n}\r\nif (!tchart->with_backtrace)\r\nbacktrace_args_no = 0;\r\nrecord_elems = common_args_nr + tasks_args_nr +\r\npower_args_nr + old_power_args_nr + backtrace_args_no;\r\nrec_argc = record_elems + argc;\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nif (rec_argv == NULL)\r\nreturn -ENOMEM;\r\np = rec_argv;\r\nfor (i = 0; i < common_args_nr; i++)\r\n*p++ = strdup(common_args[i]);\r\nfor (i = 0; i < backtrace_args_no; i++)\r\n*p++ = strdup(backtrace_args[i]);\r\nfor (i = 0; i < tasks_args_nr; i++)\r\n*p++ = strdup(tasks_args[i]);\r\nfor (i = 0; i < power_args_nr; i++)\r\n*p++ = strdup(power_args[i]);\r\nfor (i = 0; i < old_power_args_nr; i++)\r\n*p++ = strdup(old_power_args[i]);\r\nfor (j = 0; j < (unsigned int)argc; j++)\r\n*p++ = argv[j];\r\nreturn cmd_record(rec_argc, rec_argv, NULL);\r\n}\r\nstatic int\r\nparse_process(const struct option *opt __maybe_unused, const char *arg,\r\nint __maybe_unused unset)\r\n{\r\nif (arg)\r\nadd_process_filter(arg);\r\nreturn 0;\r\n}\r\nstatic int\r\nparse_highlight(const struct option *opt __maybe_unused, const char *arg,\r\nint __maybe_unused unset)\r\n{\r\nunsigned long duration = strtoul(arg, NULL, 0);\r\nif (svg_highlight || svg_highlight_name)\r\nreturn -1;\r\nif (duration)\r\nsvg_highlight = duration;\r\nelse\r\nsvg_highlight_name = strdup(arg);\r\nreturn 0;\r\n}\r\nstatic int\r\nparse_time(const struct option *opt, const char *arg, int __maybe_unused unset)\r\n{\r\nchar unit = 'n';\r\nu64 *value = opt->value;\r\nif (sscanf(arg, "%" PRIu64 "%cs", value, &unit) > 0) {\r\nswitch (unit) {\r\ncase 'm':\r\n*value *= 1000000;\r\nbreak;\r\ncase 'u':\r\n*value *= 1000;\r\nbreak;\r\ncase 'n':\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cmd_timechart(int argc, const char **argv,\r\nconst char *prefix __maybe_unused)\r\n{\r\nstruct timechart tchart = {\r\n.tool = {\r\n.comm = process_comm_event,\r\n.fork = process_fork_event,\r\n.exit = process_exit_event,\r\n.sample = process_sample_event,\r\n.ordered_events = true,\r\n},\r\n.proc_num = 15,\r\n.min_time = 1000000,\r\n.merge_dist = 1000,\r\n};\r\nconst char *output_name = "output.svg";\r\nconst struct option timechart_options[] = {\r\nOPT_STRING('i', "input", &input_name, "file", "input file name"),\r\nOPT_STRING('o', "output", &output_name, "file", "output file name"),\r\nOPT_INTEGER('w', "width", &svg_page_width, "page width"),\r\nOPT_CALLBACK(0, "highlight", NULL, "duration or task name",\r\n"highlight tasks. Pass duration in ns or process name.",\r\nparse_highlight),\r\nOPT_BOOLEAN('P', "power-only", &tchart.power_only, "output power data only"),\r\nOPT_BOOLEAN('T', "tasks-only", &tchart.tasks_only,\r\n"output processes data only"),\r\nOPT_CALLBACK('p', "process", NULL, "process",\r\n"process selector. Pass a pid or process name.",\r\nparse_process),\r\nOPT_CALLBACK(0, "symfs", NULL, "directory",\r\n"Look for files with symbols relative to this directory",\r\nsymbol__config_symfs),\r\nOPT_INTEGER('n', "proc-num", &tchart.proc_num,\r\n"min. number of tasks to print"),\r\nOPT_BOOLEAN('t', "topology", &tchart.topology,\r\n"sort CPUs according to topology"),\r\nOPT_BOOLEAN(0, "io-skip-eagain", &tchart.skip_eagain,\r\n"skip EAGAIN errors"),\r\nOPT_CALLBACK(0, "io-min-time", &tchart.min_time, "time",\r\n"all IO faster than min-time will visually appear longer",\r\nparse_time),\r\nOPT_CALLBACK(0, "io-merge-dist", &tchart.merge_dist, "time",\r\n"merge events that are merge-dist us apart",\r\nparse_time),\r\nOPT_BOOLEAN('f', "force", &tchart.force, "don't complain, do it"),\r\nOPT_END()\r\n};\r\nconst char * const timechart_subcommands[] = { "record", NULL };\r\nconst char *timechart_usage[] = {\r\n"perf timechart [<options>] {record}",\r\nNULL\r\n};\r\nconst struct option timechart_record_options[] = {\r\nOPT_BOOLEAN('P', "power-only", &tchart.power_only, "output power data only"),\r\nOPT_BOOLEAN('T', "tasks-only", &tchart.tasks_only,\r\n"output processes data only"),\r\nOPT_BOOLEAN('I', "io-only", &tchart.io_only,\r\n"record only IO data"),\r\nOPT_BOOLEAN('g', "callchain", &tchart.with_backtrace, "record callchain"),\r\nOPT_END()\r\n};\r\nconst char * const timechart_record_usage[] = {\r\n"perf timechart record [<options>]",\r\nNULL\r\n};\r\nargc = parse_options_subcommand(argc, argv, timechart_options, timechart_subcommands,\r\ntimechart_usage, PARSE_OPT_STOP_AT_NON_OPTION);\r\nif (tchart.power_only && tchart.tasks_only) {\r\npr_err("-P and -T options cannot be used at the same time.\n");\r\nreturn -1;\r\n}\r\nif (argc && !strncmp(argv[0], "rec", 3)) {\r\nargc = parse_options(argc, argv, timechart_record_options,\r\ntimechart_record_usage,\r\nPARSE_OPT_STOP_AT_NON_OPTION);\r\nif (tchart.power_only && tchart.tasks_only) {\r\npr_err("-P and -T options cannot be used at the same time.\n");\r\nreturn -1;\r\n}\r\nif (tchart.io_only)\r\nreturn timechart__io_record(argc, argv);\r\nelse\r\nreturn timechart__record(&tchart, argc, argv);\r\n} else if (argc)\r\nusage_with_options(timechart_usage, timechart_options);\r\nsetup_pager();\r\nreturn __cmd_timechart(&tchart, output_name);\r\n}
