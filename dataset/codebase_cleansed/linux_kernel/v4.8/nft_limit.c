static inline bool nft_limit_eval(struct nft_limit *limit, u64 cost)\r\n{\r\nu64 now, tokens;\r\ns64 delta;\r\nspin_lock_bh(&limit_lock);\r\nnow = ktime_get_ns();\r\ntokens = limit->tokens + now - limit->last;\r\nif (tokens > limit->tokens_max)\r\ntokens = limit->tokens_max;\r\nlimit->last = now;\r\ndelta = tokens - cost;\r\nif (delta >= 0) {\r\nlimit->tokens = delta;\r\nspin_unlock_bh(&limit_lock);\r\nreturn limit->invert;\r\n}\r\nlimit->tokens = tokens;\r\nspin_unlock_bh(&limit_lock);\r\nreturn !limit->invert;\r\n}\r\nstatic int nft_limit_init(struct nft_limit *limit,\r\nconst struct nlattr * const tb[])\r\n{\r\nu64 unit;\r\nif (tb[NFTA_LIMIT_RATE] == NULL ||\r\ntb[NFTA_LIMIT_UNIT] == NULL)\r\nreturn -EINVAL;\r\nlimit->rate = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_RATE]));\r\nunit = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_UNIT]));\r\nlimit->nsecs = unit * NSEC_PER_SEC;\r\nif (limit->rate == 0 || limit->nsecs < unit)\r\nreturn -EOVERFLOW;\r\nlimit->tokens = limit->tokens_max = limit->nsecs;\r\nif (tb[NFTA_LIMIT_BURST]) {\r\nu64 rate;\r\nlimit->burst = ntohl(nla_get_be32(tb[NFTA_LIMIT_BURST]));\r\nrate = limit->rate + limit->burst;\r\nif (rate < limit->rate)\r\nreturn -EOVERFLOW;\r\nlimit->rate = rate;\r\n}\r\nif (tb[NFTA_LIMIT_FLAGS]) {\r\nu32 flags = ntohl(nla_get_be32(tb[NFTA_LIMIT_FLAGS]));\r\nif (flags & NFT_LIMIT_F_INV)\r\nlimit->invert = true;\r\n}\r\nlimit->last = ktime_get_ns();\r\nreturn 0;\r\n}\r\nstatic int nft_limit_dump(struct sk_buff *skb, const struct nft_limit *limit,\r\nenum nft_limit_type type)\r\n{\r\nu32 flags = limit->invert ? NFT_LIMIT_F_INV : 0;\r\nu64 secs = div_u64(limit->nsecs, NSEC_PER_SEC);\r\nu64 rate = limit->rate - limit->burst;\r\nif (nla_put_be64(skb, NFTA_LIMIT_RATE, cpu_to_be64(rate),\r\nNFTA_LIMIT_PAD) ||\r\nnla_put_be64(skb, NFTA_LIMIT_UNIT, cpu_to_be64(secs),\r\nNFTA_LIMIT_PAD) ||\r\nnla_put_be32(skb, NFTA_LIMIT_BURST, htonl(limit->burst)) ||\r\nnla_put_be32(skb, NFTA_LIMIT_TYPE, htonl(type)) ||\r\nnla_put_be32(skb, NFTA_LIMIT_FLAGS, htonl(flags)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic void nft_limit_pkts_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_limit_pkts *priv = nft_expr_priv(expr);\r\nif (nft_limit_eval(&priv->limit, priv->cost))\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic int nft_limit_pkts_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_limit_pkts *priv = nft_expr_priv(expr);\r\nint err;\r\nerr = nft_limit_init(&priv->limit, tb);\r\nif (err < 0)\r\nreturn err;\r\npriv->cost = div_u64(priv->limit.nsecs, priv->limit.rate);\r\nreturn 0;\r\n}\r\nstatic int nft_limit_pkts_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_limit_pkts *priv = nft_expr_priv(expr);\r\nreturn nft_limit_dump(skb, &priv->limit, NFT_LIMIT_PKTS);\r\n}\r\nstatic void nft_limit_pkt_bytes_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_limit *priv = nft_expr_priv(expr);\r\nu64 cost = div_u64(priv->nsecs * pkt->skb->len, priv->rate);\r\nif (nft_limit_eval(priv, cost))\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic int nft_limit_pkt_bytes_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_limit *priv = nft_expr_priv(expr);\r\nreturn nft_limit_init(priv, tb);\r\n}\r\nstatic int nft_limit_pkt_bytes_dump(struct sk_buff *skb,\r\nconst struct nft_expr *expr)\r\n{\r\nconst struct nft_limit *priv = nft_expr_priv(expr);\r\nreturn nft_limit_dump(skb, priv, NFT_LIMIT_PKT_BYTES);\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_limit_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nif (tb[NFTA_LIMIT_TYPE] == NULL)\r\nreturn &nft_limit_pkts_ops;\r\nswitch (ntohl(nla_get_be32(tb[NFTA_LIMIT_TYPE]))) {\r\ncase NFT_LIMIT_PKTS:\r\nreturn &nft_limit_pkts_ops;\r\ncase NFT_LIMIT_PKT_BYTES:\r\nreturn &nft_limit_pkt_bytes_ops;\r\n}\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nstatic int __init nft_limit_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_limit_type);\r\n}\r\nstatic void __exit nft_limit_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_limit_type);\r\n}
