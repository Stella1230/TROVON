static inline unsigned int u32_hash_fold(__be32 key,\r\nconst struct tc_u32_sel *sel,\r\nu8 fshift)\r\n{\r\nunsigned int h = ntohl(key & sel->hmask) >> fshift;\r\nreturn h;\r\n}\r\nstatic int u32_classify(struct sk_buff *skb, const struct tcf_proto *tp, struct tcf_result *res)\r\n{\r\nstruct {\r\nstruct tc_u_knode *knode;\r\nunsigned int off;\r\n} stack[TC_U32_MAXDEPTH];\r\nstruct tc_u_hnode *ht = rcu_dereference_bh(tp->root);\r\nunsigned int off = skb_network_offset(skb);\r\nstruct tc_u_knode *n;\r\nint sdepth = 0;\r\nint off2 = 0;\r\nint sel = 0;\r\n#ifdef CONFIG_CLS_U32_PERF\r\nint j;\r\n#endif\r\nint i, r;\r\nnext_ht:\r\nn = rcu_dereference_bh(ht->ht[sel]);\r\nnext_knode:\r\nif (n) {\r\nstruct tc_u32_key *key = n->sel.keys;\r\n#ifdef CONFIG_CLS_U32_PERF\r\n__this_cpu_inc(n->pf->rcnt);\r\nj = 0;\r\n#endif\r\nif (tc_skip_sw(n->flags)) {\r\nn = rcu_dereference_bh(n->next);\r\ngoto next_knode;\r\n}\r\n#ifdef CONFIG_CLS_U32_MARK\r\nif ((skb->mark & n->mask) != n->val) {\r\nn = rcu_dereference_bh(n->next);\r\ngoto next_knode;\r\n} else {\r\n__this_cpu_inc(*n->pcpu_success);\r\n}\r\n#endif\r\nfor (i = n->sel.nkeys; i > 0; i--, key++) {\r\nint toff = off + key->off + (off2 & key->offmask);\r\n__be32 *data, hdata;\r\nif (skb_headroom(skb) + toff > INT_MAX)\r\ngoto out;\r\ndata = skb_header_pointer(skb, toff, 4, &hdata);\r\nif (!data)\r\ngoto out;\r\nif ((*data ^ key->val) & key->mask) {\r\nn = rcu_dereference_bh(n->next);\r\ngoto next_knode;\r\n}\r\n#ifdef CONFIG_CLS_U32_PERF\r\n__this_cpu_inc(n->pf->kcnts[j]);\r\nj++;\r\n#endif\r\n}\r\nht = rcu_dereference_bh(n->ht_down);\r\nif (!ht) {\r\ncheck_terminal:\r\nif (n->sel.flags & TC_U32_TERMINAL) {\r\n*res = n->res;\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (!tcf_match_indev(skb, n->ifindex)) {\r\nn = rcu_dereference_bh(n->next);\r\ngoto next_knode;\r\n}\r\n#endif\r\n#ifdef CONFIG_CLS_U32_PERF\r\n__this_cpu_inc(n->pf->rhit);\r\n#endif\r\nr = tcf_exts_exec(skb, &n->exts, res);\r\nif (r < 0) {\r\nn = rcu_dereference_bh(n->next);\r\ngoto next_knode;\r\n}\r\nreturn r;\r\n}\r\nn = rcu_dereference_bh(n->next);\r\ngoto next_knode;\r\n}\r\nif (sdepth >= TC_U32_MAXDEPTH)\r\ngoto deadloop;\r\nstack[sdepth].knode = n;\r\nstack[sdepth].off = off;\r\nsdepth++;\r\nht = rcu_dereference_bh(n->ht_down);\r\nsel = 0;\r\nif (ht->divisor) {\r\n__be32 *data, hdata;\r\ndata = skb_header_pointer(skb, off + n->sel.hoff, 4,\r\n&hdata);\r\nif (!data)\r\ngoto out;\r\nsel = ht->divisor & u32_hash_fold(*data, &n->sel,\r\nn->fshift);\r\n}\r\nif (!(n->sel.flags & (TC_U32_VAROFFSET | TC_U32_OFFSET | TC_U32_EAT)))\r\ngoto next_ht;\r\nif (n->sel.flags & (TC_U32_OFFSET | TC_U32_VAROFFSET)) {\r\noff2 = n->sel.off + 3;\r\nif (n->sel.flags & TC_U32_VAROFFSET) {\r\n__be16 *data, hdata;\r\ndata = skb_header_pointer(skb,\r\noff + n->sel.offoff,\r\n2, &hdata);\r\nif (!data)\r\ngoto out;\r\noff2 += ntohs(n->sel.offmask & *data) >>\r\nn->sel.offshift;\r\n}\r\noff2 &= ~3;\r\n}\r\nif (n->sel.flags & TC_U32_EAT) {\r\noff += off2;\r\noff2 = 0;\r\n}\r\nif (off < skb->len)\r\ngoto next_ht;\r\n}\r\nif (sdepth--) {\r\nn = stack[sdepth].knode;\r\nht = rcu_dereference_bh(n->ht_up);\r\noff = stack[sdepth].off;\r\ngoto check_terminal;\r\n}\r\nout:\r\nreturn -1;\r\ndeadloop:\r\nnet_warn_ratelimited("cls_u32: dead loop\n");\r\nreturn -1;\r\n}\r\nstatic struct tc_u_hnode *\r\nu32_lookup_ht(struct tc_u_common *tp_c, u32 handle)\r\n{\r\nstruct tc_u_hnode *ht;\r\nfor (ht = rtnl_dereference(tp_c->hlist);\r\nht;\r\nht = rtnl_dereference(ht->next))\r\nif (ht->handle == handle)\r\nbreak;\r\nreturn ht;\r\n}\r\nstatic struct tc_u_knode *\r\nu32_lookup_key(struct tc_u_hnode *ht, u32 handle)\r\n{\r\nunsigned int sel;\r\nstruct tc_u_knode *n = NULL;\r\nsel = TC_U32_HASH(handle);\r\nif (sel > ht->divisor)\r\ngoto out;\r\nfor (n = rtnl_dereference(ht->ht[sel]);\r\nn;\r\nn = rtnl_dereference(n->next))\r\nif (n->handle == handle)\r\nbreak;\r\nout:\r\nreturn n;\r\n}\r\nstatic unsigned long u32_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nstruct tc_u_hnode *ht;\r\nstruct tc_u_common *tp_c = tp->data;\r\nif (TC_U32_HTID(handle) == TC_U32_ROOT)\r\nht = rtnl_dereference(tp->root);\r\nelse\r\nht = u32_lookup_ht(tp_c, TC_U32_HTID(handle));\r\nif (!ht)\r\nreturn 0;\r\nif (TC_U32_KEY(handle) == 0)\r\nreturn (unsigned long)ht;\r\nreturn (unsigned long)u32_lookup_key(ht, handle);\r\n}\r\nstatic u32 gen_new_htid(struct tc_u_common *tp_c)\r\n{\r\nint i = 0x800;\r\ndo {\r\nif (++tp_c->hgenerator == 0x7FF)\r\ntp_c->hgenerator = 1;\r\n} while (--i > 0 && u32_lookup_ht(tp_c, (tp_c->hgenerator|0x800)<<20));\r\nreturn i > 0 ? (tp_c->hgenerator|0x800)<<20 : 0;\r\n}\r\nstatic int u32_init(struct tcf_proto *tp)\r\n{\r\nstruct tc_u_hnode *root_ht;\r\nstruct tc_u_common *tp_c;\r\ntp_c = tp->q->u32_node;\r\nroot_ht = kzalloc(sizeof(*root_ht), GFP_KERNEL);\r\nif (root_ht == NULL)\r\nreturn -ENOBUFS;\r\nroot_ht->divisor = 0;\r\nroot_ht->refcnt++;\r\nroot_ht->handle = tp_c ? gen_new_htid(tp_c) : 0x80000000;\r\nroot_ht->prio = tp->prio;\r\nif (tp_c == NULL) {\r\ntp_c = kzalloc(sizeof(*tp_c), GFP_KERNEL);\r\nif (tp_c == NULL) {\r\nkfree(root_ht);\r\nreturn -ENOBUFS;\r\n}\r\ntp_c->q = tp->q;\r\ntp->q->u32_node = tp_c;\r\n}\r\ntp_c->refcnt++;\r\nRCU_INIT_POINTER(root_ht->next, tp_c->hlist);\r\nrcu_assign_pointer(tp_c->hlist, root_ht);\r\nroot_ht->tp_c = tp_c;\r\nrcu_assign_pointer(tp->root, root_ht);\r\ntp->data = tp_c;\r\nreturn 0;\r\n}\r\nstatic int u32_destroy_key(struct tcf_proto *tp,\r\nstruct tc_u_knode *n,\r\nbool free_pf)\r\n{\r\ntcf_exts_destroy(&n->exts);\r\nif (n->ht_down)\r\nn->ht_down->refcnt--;\r\n#ifdef CONFIG_CLS_U32_PERF\r\nif (free_pf)\r\nfree_percpu(n->pf);\r\n#endif\r\n#ifdef CONFIG_CLS_U32_MARK\r\nif (free_pf)\r\nfree_percpu(n->pcpu_success);\r\n#endif\r\nkfree(n);\r\nreturn 0;\r\n}\r\nstatic void u32_delete_key_rcu(struct rcu_head *rcu)\r\n{\r\nstruct tc_u_knode *key = container_of(rcu, struct tc_u_knode, rcu);\r\nu32_destroy_key(key->tp, key, false);\r\n}\r\nstatic void u32_delete_key_freepf_rcu(struct rcu_head *rcu)\r\n{\r\nstruct tc_u_knode *key = container_of(rcu, struct tc_u_knode, rcu);\r\nu32_destroy_key(key->tp, key, true);\r\n}\r\nstatic int u32_delete_key(struct tcf_proto *tp, struct tc_u_knode *key)\r\n{\r\nstruct tc_u_knode __rcu **kp;\r\nstruct tc_u_knode *pkp;\r\nstruct tc_u_hnode *ht = rtnl_dereference(key->ht_up);\r\nif (ht) {\r\nkp = &ht->ht[TC_U32_HASH(key->handle)];\r\nfor (pkp = rtnl_dereference(*kp); pkp;\r\nkp = &pkp->next, pkp = rtnl_dereference(*kp)) {\r\nif (pkp == key) {\r\nRCU_INIT_POINTER(*kp, key->next);\r\ntcf_unbind_filter(tp, &key->res);\r\ncall_rcu(&key->rcu, u32_delete_key_freepf_rcu);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nstatic void u32_remove_hw_knode(struct tcf_proto *tp, u32 handle)\r\n{\r\nstruct net_device *dev = tp->q->dev_queue->dev;\r\nstruct tc_cls_u32_offload u32_offload = {0};\r\nstruct tc_to_netdev offload;\r\noffload.type = TC_SETUP_CLSU32;\r\noffload.cls_u32 = &u32_offload;\r\nif (tc_should_offload(dev, tp, 0)) {\r\noffload.cls_u32->command = TC_CLSU32_DELETE_KNODE;\r\noffload.cls_u32->knode.handle = handle;\r\ndev->netdev_ops->ndo_setup_tc(dev, tp->q->handle,\r\ntp->protocol, &offload);\r\n}\r\n}\r\nstatic int u32_replace_hw_hnode(struct tcf_proto *tp,\r\nstruct tc_u_hnode *h,\r\nu32 flags)\r\n{\r\nstruct net_device *dev = tp->q->dev_queue->dev;\r\nstruct tc_cls_u32_offload u32_offload = {0};\r\nstruct tc_to_netdev offload;\r\nint err;\r\nif (!tc_should_offload(dev, tp, flags))\r\nreturn tc_skip_sw(flags) ? -EINVAL : 0;\r\noffload.type = TC_SETUP_CLSU32;\r\noffload.cls_u32 = &u32_offload;\r\noffload.cls_u32->command = TC_CLSU32_NEW_HNODE;\r\noffload.cls_u32->hnode.divisor = h->divisor;\r\noffload.cls_u32->hnode.handle = h->handle;\r\noffload.cls_u32->hnode.prio = h->prio;\r\nerr = dev->netdev_ops->ndo_setup_tc(dev, tp->q->handle,\r\ntp->protocol, &offload);\r\nif (tc_skip_sw(flags))\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void u32_clear_hw_hnode(struct tcf_proto *tp, struct tc_u_hnode *h)\r\n{\r\nstruct net_device *dev = tp->q->dev_queue->dev;\r\nstruct tc_cls_u32_offload u32_offload = {0};\r\nstruct tc_to_netdev offload;\r\noffload.type = TC_SETUP_CLSU32;\r\noffload.cls_u32 = &u32_offload;\r\nif (tc_should_offload(dev, tp, 0)) {\r\noffload.cls_u32->command = TC_CLSU32_DELETE_HNODE;\r\noffload.cls_u32->hnode.divisor = h->divisor;\r\noffload.cls_u32->hnode.handle = h->handle;\r\noffload.cls_u32->hnode.prio = h->prio;\r\ndev->netdev_ops->ndo_setup_tc(dev, tp->q->handle,\r\ntp->protocol, &offload);\r\n}\r\n}\r\nstatic int u32_replace_hw_knode(struct tcf_proto *tp,\r\nstruct tc_u_knode *n,\r\nu32 flags)\r\n{\r\nstruct net_device *dev = tp->q->dev_queue->dev;\r\nstruct tc_cls_u32_offload u32_offload = {0};\r\nstruct tc_to_netdev offload;\r\nint err;\r\noffload.type = TC_SETUP_CLSU32;\r\noffload.cls_u32 = &u32_offload;\r\nif (!tc_should_offload(dev, tp, flags))\r\nreturn tc_skip_sw(flags) ? -EINVAL : 0;\r\noffload.cls_u32->command = TC_CLSU32_REPLACE_KNODE;\r\noffload.cls_u32->knode.handle = n->handle;\r\noffload.cls_u32->knode.fshift = n->fshift;\r\n#ifdef CONFIG_CLS_U32_MARK\r\noffload.cls_u32->knode.val = n->val;\r\noffload.cls_u32->knode.mask = n->mask;\r\n#else\r\noffload.cls_u32->knode.val = 0;\r\noffload.cls_u32->knode.mask = 0;\r\n#endif\r\noffload.cls_u32->knode.sel = &n->sel;\r\noffload.cls_u32->knode.exts = &n->exts;\r\nif (n->ht_down)\r\noffload.cls_u32->knode.link_handle = n->ht_down->handle;\r\nerr = dev->netdev_ops->ndo_setup_tc(dev, tp->q->handle,\r\ntp->protocol, &offload);\r\nif (tc_skip_sw(flags))\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void u32_clear_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht)\r\n{\r\nstruct tc_u_knode *n;\r\nunsigned int h;\r\nfor (h = 0; h <= ht->divisor; h++) {\r\nwhile ((n = rtnl_dereference(ht->ht[h])) != NULL) {\r\nRCU_INIT_POINTER(ht->ht[h],\r\nrtnl_dereference(n->next));\r\ntcf_unbind_filter(tp, &n->res);\r\nu32_remove_hw_knode(tp, n->handle);\r\ncall_rcu(&n->rcu, u32_delete_key_freepf_rcu);\r\n}\r\n}\r\n}\r\nstatic int u32_destroy_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht)\r\n{\r\nstruct tc_u_common *tp_c = tp->data;\r\nstruct tc_u_hnode __rcu **hn;\r\nstruct tc_u_hnode *phn;\r\nWARN_ON(ht->refcnt);\r\nu32_clear_hnode(tp, ht);\r\nhn = &tp_c->hlist;\r\nfor (phn = rtnl_dereference(*hn);\r\nphn;\r\nhn = &phn->next, phn = rtnl_dereference(*hn)) {\r\nif (phn == ht) {\r\nu32_clear_hw_hnode(tp, ht);\r\nRCU_INIT_POINTER(*hn, ht->next);\r\nkfree_rcu(ht, rcu);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic bool ht_empty(struct tc_u_hnode *ht)\r\n{\r\nunsigned int h;\r\nfor (h = 0; h <= ht->divisor; h++)\r\nif (rcu_access_pointer(ht->ht[h]))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool u32_destroy(struct tcf_proto *tp, bool force)\r\n{\r\nstruct tc_u_common *tp_c = tp->data;\r\nstruct tc_u_hnode *root_ht = rtnl_dereference(tp->root);\r\nWARN_ON(root_ht == NULL);\r\nif (!force) {\r\nif (root_ht) {\r\nif (root_ht->refcnt > 1)\r\nreturn false;\r\nif (root_ht->refcnt == 1) {\r\nif (!ht_empty(root_ht))\r\nreturn false;\r\n}\r\n}\r\nif (tp_c->refcnt > 1)\r\nreturn false;\r\nif (tp_c->refcnt == 1) {\r\nstruct tc_u_hnode *ht;\r\nfor (ht = rtnl_dereference(tp_c->hlist);\r\nht;\r\nht = rtnl_dereference(ht->next))\r\nif (!ht_empty(ht))\r\nreturn false;\r\n}\r\n}\r\nif (root_ht && --root_ht->refcnt == 0)\r\nu32_destroy_hnode(tp, root_ht);\r\nif (--tp_c->refcnt == 0) {\r\nstruct tc_u_hnode *ht;\r\ntp->q->u32_node = NULL;\r\nfor (ht = rtnl_dereference(tp_c->hlist);\r\nht;\r\nht = rtnl_dereference(ht->next)) {\r\nht->refcnt--;\r\nu32_clear_hnode(tp, ht);\r\n}\r\nwhile ((ht = rtnl_dereference(tp_c->hlist)) != NULL) {\r\nRCU_INIT_POINTER(tp_c->hlist, ht->next);\r\nkfree_rcu(ht, rcu);\r\n}\r\nkfree(tp_c);\r\n}\r\ntp->data = NULL;\r\nreturn true;\r\n}\r\nstatic int u32_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nstruct tc_u_hnode *ht = (struct tc_u_hnode *)arg;\r\nstruct tc_u_hnode *root_ht = rtnl_dereference(tp->root);\r\nif (ht == NULL)\r\nreturn 0;\r\nif (TC_U32_KEY(ht->handle)) {\r\nu32_remove_hw_knode(tp, ht->handle);\r\nreturn u32_delete_key(tp, (struct tc_u_knode *)ht);\r\n}\r\nif (root_ht == ht)\r\nreturn -EINVAL;\r\nif (ht->refcnt == 1) {\r\nht->refcnt--;\r\nu32_destroy_hnode(tp, ht);\r\n} else {\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 gen_new_kid(struct tc_u_hnode *ht, u32 handle)\r\n{\r\nstruct tc_u_knode *n;\r\nunsigned long i;\r\nunsigned long *bitmap = kzalloc(BITS_TO_LONGS(NR_U32_NODE) * sizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!bitmap)\r\nreturn handle | 0xFFF;\r\nfor (n = rtnl_dereference(ht->ht[TC_U32_HASH(handle)]);\r\nn;\r\nn = rtnl_dereference(n->next))\r\nset_bit(TC_U32_NODE(n->handle), bitmap);\r\ni = find_next_zero_bit(bitmap, NR_U32_NODE, 0x800);\r\nif (i >= NR_U32_NODE)\r\ni = find_next_zero_bit(bitmap, NR_U32_NODE, 1);\r\nkfree(bitmap);\r\nreturn handle | (i >= NR_U32_NODE ? 0xFFF : i);\r\n}\r\nstatic int u32_set_parms(struct net *net, struct tcf_proto *tp,\r\nunsigned long base, struct tc_u_hnode *ht,\r\nstruct tc_u_knode *n, struct nlattr **tb,\r\nstruct nlattr *est, bool ovr)\r\n{\r\nint err;\r\nstruct tcf_exts e;\r\ntcf_exts_init(&e, TCA_U32_ACT, TCA_U32_POLICE);\r\nerr = tcf_exts_validate(net, tp, tb, est, &e, ovr);\r\nif (err < 0)\r\nreturn err;\r\nerr = -EINVAL;\r\nif (tb[TCA_U32_LINK]) {\r\nu32 handle = nla_get_u32(tb[TCA_U32_LINK]);\r\nstruct tc_u_hnode *ht_down = NULL, *ht_old;\r\nif (TC_U32_KEY(handle))\r\ngoto errout;\r\nif (handle) {\r\nht_down = u32_lookup_ht(ht->tp_c, handle);\r\nif (ht_down == NULL)\r\ngoto errout;\r\nht_down->refcnt++;\r\n}\r\nht_old = rtnl_dereference(n->ht_down);\r\nrcu_assign_pointer(n->ht_down, ht_down);\r\nif (ht_old)\r\nht_old->refcnt--;\r\n}\r\nif (tb[TCA_U32_CLASSID]) {\r\nn->res.classid = nla_get_u32(tb[TCA_U32_CLASSID]);\r\ntcf_bind_filter(tp, &n->res, base);\r\n}\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (tb[TCA_U32_INDEV]) {\r\nint ret;\r\nret = tcf_change_indev(net, tb[TCA_U32_INDEV]);\r\nif (ret < 0)\r\ngoto errout;\r\nn->ifindex = ret;\r\n}\r\n#endif\r\ntcf_exts_change(tp, &n->exts, &e);\r\nreturn 0;\r\nerrout:\r\ntcf_exts_destroy(&e);\r\nreturn err;\r\n}\r\nstatic void u32_replace_knode(struct tcf_proto *tp,\r\nstruct tc_u_common *tp_c,\r\nstruct tc_u_knode *n)\r\n{\r\nstruct tc_u_knode __rcu **ins;\r\nstruct tc_u_knode *pins;\r\nstruct tc_u_hnode *ht;\r\nif (TC_U32_HTID(n->handle) == TC_U32_ROOT)\r\nht = rtnl_dereference(tp->root);\r\nelse\r\nht = u32_lookup_ht(tp_c, TC_U32_HTID(n->handle));\r\nins = &ht->ht[TC_U32_HASH(n->handle)];\r\nfor (pins = rtnl_dereference(*ins); ;\r\nins = &pins->next, pins = rtnl_dereference(*ins))\r\nif (pins->handle == n->handle)\r\nbreak;\r\nRCU_INIT_POINTER(n->next, pins->next);\r\nrcu_assign_pointer(*ins, n);\r\n}\r\nstatic struct tc_u_knode *u32_init_knode(struct tcf_proto *tp,\r\nstruct tc_u_knode *n)\r\n{\r\nstruct tc_u_knode *new;\r\nstruct tc_u32_sel *s = &n->sel;\r\nnew = kzalloc(sizeof(*n) + s->nkeys*sizeof(struct tc_u32_key),\r\nGFP_KERNEL);\r\nif (!new)\r\nreturn NULL;\r\nRCU_INIT_POINTER(new->next, n->next);\r\nnew->handle = n->handle;\r\nRCU_INIT_POINTER(new->ht_up, n->ht_up);\r\n#ifdef CONFIG_NET_CLS_IND\r\nnew->ifindex = n->ifindex;\r\n#endif\r\nnew->fshift = n->fshift;\r\nnew->res = n->res;\r\nnew->flags = n->flags;\r\nRCU_INIT_POINTER(new->ht_down, n->ht_down);\r\nif (new->ht_down)\r\nnew->ht_down->refcnt++;\r\n#ifdef CONFIG_CLS_U32_PERF\r\nnew->pf = n->pf;\r\n#endif\r\n#ifdef CONFIG_CLS_U32_MARK\r\nnew->val = n->val;\r\nnew->mask = n->mask;\r\nnew->pcpu_success = n->pcpu_success;\r\n#endif\r\nnew->tp = tp;\r\nmemcpy(&new->sel, s, sizeof(*s) + s->nkeys*sizeof(struct tc_u32_key));\r\ntcf_exts_init(&new->exts, TCA_U32_ACT, TCA_U32_POLICE);\r\nreturn new;\r\n}\r\nstatic int u32_change(struct net *net, struct sk_buff *in_skb,\r\nstruct tcf_proto *tp, unsigned long base, u32 handle,\r\nstruct nlattr **tca,\r\nunsigned long *arg, bool ovr)\r\n{\r\nstruct tc_u_common *tp_c = tp->data;\r\nstruct tc_u_hnode *ht;\r\nstruct tc_u_knode *n;\r\nstruct tc_u32_sel *s;\r\nstruct nlattr *opt = tca[TCA_OPTIONS];\r\nstruct nlattr *tb[TCA_U32_MAX + 1];\r\nu32 htid, flags = 0;\r\nint err;\r\n#ifdef CONFIG_CLS_U32_PERF\r\nsize_t size;\r\n#endif\r\nif (opt == NULL)\r\nreturn handle ? -EINVAL : 0;\r\nerr = nla_parse_nested(tb, TCA_U32_MAX, opt, u32_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_U32_FLAGS]) {\r\nflags = nla_get_u32(tb[TCA_U32_FLAGS]);\r\nif (!tc_flags_valid(flags))\r\nreturn -EINVAL;\r\n}\r\nn = (struct tc_u_knode *)*arg;\r\nif (n) {\r\nstruct tc_u_knode *new;\r\nif (TC_U32_KEY(n->handle) == 0)\r\nreturn -EINVAL;\r\nif (n->flags != flags)\r\nreturn -EINVAL;\r\nnew = u32_init_knode(tp, n);\r\nif (!new)\r\nreturn -ENOMEM;\r\nerr = u32_set_parms(net, tp, base,\r\nrtnl_dereference(n->ht_up), new, tb,\r\ntca[TCA_RATE], ovr);\r\nif (err) {\r\nu32_destroy_key(tp, new, false);\r\nreturn err;\r\n}\r\nerr = u32_replace_hw_knode(tp, new, flags);\r\nif (err) {\r\nu32_destroy_key(tp, new, false);\r\nreturn err;\r\n}\r\nu32_replace_knode(tp, tp_c, new);\r\ntcf_unbind_filter(tp, &n->res);\r\ncall_rcu(&n->rcu, u32_delete_key_rcu);\r\nreturn 0;\r\n}\r\nif (tb[TCA_U32_DIVISOR]) {\r\nunsigned int divisor = nla_get_u32(tb[TCA_U32_DIVISOR]);\r\nif (--divisor > 0x100)\r\nreturn -EINVAL;\r\nif (TC_U32_KEY(handle))\r\nreturn -EINVAL;\r\nif (handle == 0) {\r\nhandle = gen_new_htid(tp->data);\r\nif (handle == 0)\r\nreturn -ENOMEM;\r\n}\r\nht = kzalloc(sizeof(*ht) + divisor*sizeof(void *), GFP_KERNEL);\r\nif (ht == NULL)\r\nreturn -ENOBUFS;\r\nht->tp_c = tp_c;\r\nht->refcnt = 1;\r\nht->divisor = divisor;\r\nht->handle = handle;\r\nht->prio = tp->prio;\r\nerr = u32_replace_hw_hnode(tp, ht, flags);\r\nif (err) {\r\nkfree(ht);\r\nreturn err;\r\n}\r\nRCU_INIT_POINTER(ht->next, tp_c->hlist);\r\nrcu_assign_pointer(tp_c->hlist, ht);\r\n*arg = (unsigned long)ht;\r\nreturn 0;\r\n}\r\nif (tb[TCA_U32_HASH]) {\r\nhtid = nla_get_u32(tb[TCA_U32_HASH]);\r\nif (TC_U32_HTID(htid) == TC_U32_ROOT) {\r\nht = rtnl_dereference(tp->root);\r\nhtid = ht->handle;\r\n} else {\r\nht = u32_lookup_ht(tp->data, TC_U32_HTID(htid));\r\nif (ht == NULL)\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nht = rtnl_dereference(tp->root);\r\nhtid = ht->handle;\r\n}\r\nif (ht->divisor < TC_U32_HASH(htid))\r\nreturn -EINVAL;\r\nif (handle) {\r\nif (TC_U32_HTID(handle) && TC_U32_HTID(handle^htid))\r\nreturn -EINVAL;\r\nhandle = htid | TC_U32_NODE(handle);\r\n} else\r\nhandle = gen_new_kid(ht, htid);\r\nif (tb[TCA_U32_SEL] == NULL)\r\nreturn -EINVAL;\r\ns = nla_data(tb[TCA_U32_SEL]);\r\nn = kzalloc(sizeof(*n) + s->nkeys*sizeof(struct tc_u32_key), GFP_KERNEL);\r\nif (n == NULL)\r\nreturn -ENOBUFS;\r\n#ifdef CONFIG_CLS_U32_PERF\r\nsize = sizeof(struct tc_u32_pcnt) + s->nkeys * sizeof(u64);\r\nn->pf = __alloc_percpu(size, __alignof__(struct tc_u32_pcnt));\r\nif (!n->pf) {\r\nkfree(n);\r\nreturn -ENOBUFS;\r\n}\r\n#endif\r\nmemcpy(&n->sel, s, sizeof(*s) + s->nkeys*sizeof(struct tc_u32_key));\r\nRCU_INIT_POINTER(n->ht_up, ht);\r\nn->handle = handle;\r\nn->fshift = s->hmask ? ffs(ntohl(s->hmask)) - 1 : 0;\r\nn->flags = flags;\r\ntcf_exts_init(&n->exts, TCA_U32_ACT, TCA_U32_POLICE);\r\nn->tp = tp;\r\n#ifdef CONFIG_CLS_U32_MARK\r\nn->pcpu_success = alloc_percpu(u32);\r\nif (!n->pcpu_success) {\r\nerr = -ENOMEM;\r\ngoto errout;\r\n}\r\nif (tb[TCA_U32_MARK]) {\r\nstruct tc_u32_mark *mark;\r\nmark = nla_data(tb[TCA_U32_MARK]);\r\nn->val = mark->val;\r\nn->mask = mark->mask;\r\n}\r\n#endif\r\nerr = u32_set_parms(net, tp, base, ht, n, tb, tca[TCA_RATE], ovr);\r\nif (err == 0) {\r\nstruct tc_u_knode __rcu **ins;\r\nstruct tc_u_knode *pins;\r\nerr = u32_replace_hw_knode(tp, n, flags);\r\nif (err)\r\ngoto errhw;\r\nins = &ht->ht[TC_U32_HASH(handle)];\r\nfor (pins = rtnl_dereference(*ins); pins;\r\nins = &pins->next, pins = rtnl_dereference(*ins))\r\nif (TC_U32_NODE(handle) < TC_U32_NODE(pins->handle))\r\nbreak;\r\nRCU_INIT_POINTER(n->next, pins);\r\nrcu_assign_pointer(*ins, n);\r\n*arg = (unsigned long)n;\r\nreturn 0;\r\n}\r\nerrhw:\r\n#ifdef CONFIG_CLS_U32_MARK\r\nfree_percpu(n->pcpu_success);\r\nerrout:\r\n#endif\r\n#ifdef CONFIG_CLS_U32_PERF\r\nfree_percpu(n->pf);\r\n#endif\r\nkfree(n);\r\nreturn err;\r\n}\r\nstatic void u32_walk(struct tcf_proto *tp, struct tcf_walker *arg)\r\n{\r\nstruct tc_u_common *tp_c = tp->data;\r\nstruct tc_u_hnode *ht;\r\nstruct tc_u_knode *n;\r\nunsigned int h;\r\nif (arg->stop)\r\nreturn;\r\nfor (ht = rtnl_dereference(tp_c->hlist);\r\nht;\r\nht = rtnl_dereference(ht->next)) {\r\nif (ht->prio != tp->prio)\r\ncontinue;\r\nif (arg->count >= arg->skip) {\r\nif (arg->fn(tp, (unsigned long)ht, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\n}\r\narg->count++;\r\nfor (h = 0; h <= ht->divisor; h++) {\r\nfor (n = rtnl_dereference(ht->ht[h]);\r\nn;\r\nn = rtnl_dereference(n->next)) {\r\nif (arg->count < arg->skip) {\r\narg->count++;\r\ncontinue;\r\n}\r\nif (arg->fn(tp, (unsigned long)n, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\narg->count++;\r\n}\r\n}\r\n}\r\n}\r\nstatic int u32_dump(struct net *net, struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct tc_u_knode *n = (struct tc_u_knode *)fh;\r\nstruct tc_u_hnode *ht_up, *ht_down;\r\nstruct nlattr *nest;\r\nif (n == NULL)\r\nreturn skb->len;\r\nt->tcm_handle = n->handle;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (TC_U32_KEY(n->handle) == 0) {\r\nstruct tc_u_hnode *ht = (struct tc_u_hnode *)fh;\r\nu32 divisor = ht->divisor + 1;\r\nif (nla_put_u32(skb, TCA_U32_DIVISOR, divisor))\r\ngoto nla_put_failure;\r\n} else {\r\n#ifdef CONFIG_CLS_U32_PERF\r\nstruct tc_u32_pcnt *gpf;\r\nint cpu;\r\n#endif\r\nif (nla_put(skb, TCA_U32_SEL,\r\nsizeof(n->sel) + n->sel.nkeys*sizeof(struct tc_u32_key),\r\n&n->sel))\r\ngoto nla_put_failure;\r\nht_up = rtnl_dereference(n->ht_up);\r\nif (ht_up) {\r\nu32 htid = n->handle & 0xFFFFF000;\r\nif (nla_put_u32(skb, TCA_U32_HASH, htid))\r\ngoto nla_put_failure;\r\n}\r\nif (n->res.classid &&\r\nnla_put_u32(skb, TCA_U32_CLASSID, n->res.classid))\r\ngoto nla_put_failure;\r\nht_down = rtnl_dereference(n->ht_down);\r\nif (ht_down &&\r\nnla_put_u32(skb, TCA_U32_LINK, ht_down->handle))\r\ngoto nla_put_failure;\r\nif (n->flags && nla_put_u32(skb, TCA_U32_FLAGS, n->flags))\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_CLS_U32_MARK\r\nif ((n->val || n->mask)) {\r\nstruct tc_u32_mark mark = {.val = n->val,\r\n.mask = n->mask,\r\n.success = 0};\r\nint cpum;\r\nfor_each_possible_cpu(cpum) {\r\n__u32 cnt = *per_cpu_ptr(n->pcpu_success, cpum);\r\nmark.success += cnt;\r\n}\r\nif (nla_put(skb, TCA_U32_MARK, sizeof(mark), &mark))\r\ngoto nla_put_failure;\r\n}\r\n#endif\r\nif (tcf_exts_dump(skb, &n->exts) < 0)\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (n->ifindex) {\r\nstruct net_device *dev;\r\ndev = __dev_get_by_index(net, n->ifindex);\r\nif (dev && nla_put_string(skb, TCA_U32_INDEV, dev->name))\r\ngoto nla_put_failure;\r\n}\r\n#endif\r\n#ifdef CONFIG_CLS_U32_PERF\r\ngpf = kzalloc(sizeof(struct tc_u32_pcnt) +\r\nn->sel.nkeys * sizeof(u64),\r\nGFP_KERNEL);\r\nif (!gpf)\r\ngoto nla_put_failure;\r\nfor_each_possible_cpu(cpu) {\r\nint i;\r\nstruct tc_u32_pcnt *pf = per_cpu_ptr(n->pf, cpu);\r\ngpf->rcnt += pf->rcnt;\r\ngpf->rhit += pf->rhit;\r\nfor (i = 0; i < n->sel.nkeys; i++)\r\ngpf->kcnts[i] += pf->kcnts[i];\r\n}\r\nif (nla_put_64bit(skb, TCA_U32_PCNT,\r\nsizeof(struct tc_u32_pcnt) +\r\nn->sel.nkeys * sizeof(u64),\r\ngpf, TCA_U32_PAD)) {\r\nkfree(gpf);\r\ngoto nla_put_failure;\r\n}\r\nkfree(gpf);\r\n#endif\r\n}\r\nnla_nest_end(skb, nest);\r\nif (TC_U32_KEY(n->handle))\r\nif (tcf_exts_dump_stats(skb, &n->exts) < 0)\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n}\r\nstatic int __init init_u32(void)\r\n{\r\npr_info("u32 classifier\n");\r\n#ifdef CONFIG_CLS_U32_PERF\r\npr_info(" Performance counters on\n");\r\n#endif\r\n#ifdef CONFIG_NET_CLS_IND\r\npr_info(" input device check on\n");\r\n#endif\r\n#ifdef CONFIG_NET_CLS_ACT\r\npr_info(" Actions configured\n");\r\n#endif\r\nreturn register_tcf_proto_ops(&cls_u32_ops);\r\n}\r\nstatic void __exit exit_u32(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_u32_ops);\r\n}
