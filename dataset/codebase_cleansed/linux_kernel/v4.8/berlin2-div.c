static int berlin2_div_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct berlin2_div *div = to_berlin2_div(hw);\r\nstruct berlin2_div_map *map = &div->map;\r\nu32 reg;\r\nif (div->lock)\r\nspin_lock(div->lock);\r\nreg = readl_relaxed(div->base + map->gate_offs);\r\nreg >>= map->gate_shift;\r\nif (div->lock)\r\nspin_unlock(div->lock);\r\nreturn (reg & 0x1);\r\n}\r\nstatic int berlin2_div_enable(struct clk_hw *hw)\r\n{\r\nstruct berlin2_div *div = to_berlin2_div(hw);\r\nstruct berlin2_div_map *map = &div->map;\r\nu32 reg;\r\nif (div->lock)\r\nspin_lock(div->lock);\r\nreg = readl_relaxed(div->base + map->gate_offs);\r\nreg |= BIT(map->gate_shift);\r\nwritel_relaxed(reg, div->base + map->gate_offs);\r\nif (div->lock)\r\nspin_unlock(div->lock);\r\nreturn 0;\r\n}\r\nstatic void berlin2_div_disable(struct clk_hw *hw)\r\n{\r\nstruct berlin2_div *div = to_berlin2_div(hw);\r\nstruct berlin2_div_map *map = &div->map;\r\nu32 reg;\r\nif (div->lock)\r\nspin_lock(div->lock);\r\nreg = readl_relaxed(div->base + map->gate_offs);\r\nreg &= ~BIT(map->gate_shift);\r\nwritel_relaxed(reg, div->base + map->gate_offs);\r\nif (div->lock)\r\nspin_unlock(div->lock);\r\n}\r\nstatic int berlin2_div_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct berlin2_div *div = to_berlin2_div(hw);\r\nstruct berlin2_div_map *map = &div->map;\r\nu32 reg;\r\nif (div->lock)\r\nspin_lock(div->lock);\r\nreg = readl_relaxed(div->base + map->pll_switch_offs);\r\nif (index == 0)\r\nreg &= ~BIT(map->pll_switch_shift);\r\nelse\r\nreg |= BIT(map->pll_switch_shift);\r\nwritel_relaxed(reg, div->base + map->pll_switch_offs);\r\nif (index > 0) {\r\nreg = readl_relaxed(div->base + map->pll_select_offs);\r\nreg &= ~(PLL_SELECT_MASK << map->pll_select_shift);\r\nreg |= (index - 1) << map->pll_select_shift;\r\nwritel_relaxed(reg, div->base + map->pll_select_offs);\r\n}\r\nif (div->lock)\r\nspin_unlock(div->lock);\r\nreturn 0;\r\n}\r\nstatic u8 berlin2_div_get_parent(struct clk_hw *hw)\r\n{\r\nstruct berlin2_div *div = to_berlin2_div(hw);\r\nstruct berlin2_div_map *map = &div->map;\r\nu32 reg;\r\nu8 index = 0;\r\nif (div->lock)\r\nspin_lock(div->lock);\r\nreg = readl_relaxed(div->base + map->pll_switch_offs);\r\nreg &= BIT(map->pll_switch_shift);\r\nif (reg) {\r\nreg = readl_relaxed(div->base + map->pll_select_offs);\r\nreg >>= map->pll_select_shift;\r\nreg &= PLL_SELECT_MASK;\r\nindex = 1 + reg;\r\n}\r\nif (div->lock)\r\nspin_unlock(div->lock);\r\nreturn index;\r\n}\r\nstatic unsigned long berlin2_div_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct berlin2_div *div = to_berlin2_div(hw);\r\nstruct berlin2_div_map *map = &div->map;\r\nu32 divsw, div3sw, divider = 1;\r\nif (div->lock)\r\nspin_lock(div->lock);\r\ndivsw = readl_relaxed(div->base + map->div_switch_offs) &\r\n(1 << map->div_switch_shift);\r\ndiv3sw = readl_relaxed(div->base + map->div3_switch_offs) &\r\n(1 << map->div3_switch_shift);\r\nif (div3sw != 0) {\r\ndivider = 3;\r\n} else if (divsw == 0) {\r\ndivider = 1;\r\n} else {\r\nu32 reg;\r\nreg = readl_relaxed(div->base + map->div_select_offs);\r\nreg >>= map->div_select_shift;\r\nreg &= DIV_SELECT_MASK;\r\ndivider = clk_div[reg];\r\n}\r\nif (div->lock)\r\nspin_unlock(div->lock);\r\nreturn parent_rate / divider;\r\n}\r\nstruct clk * __init\r\nberlin2_div_register(const struct berlin2_div_map *map,\r\nvoid __iomem *base, const char *name, u8 div_flags,\r\nconst char **parent_names, int num_parents,\r\nunsigned long flags, spinlock_t *lock)\r\n{\r\nconst struct clk_ops *mux_ops = &berlin2_div_mux_ops;\r\nconst struct clk_ops *rate_ops = &berlin2_div_rate_ops;\r\nconst struct clk_ops *gate_ops = &berlin2_div_gate_ops;\r\nstruct berlin2_div *div;\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(&div->map, map, sizeof(*map));\r\ndiv->base = base;\r\ndiv->lock = lock;\r\nif ((div_flags & BERLIN2_DIV_HAS_GATE) == 0)\r\ngate_ops = NULL;\r\nif ((div_flags & BERLIN2_DIV_HAS_MUX) == 0)\r\nmux_ops = NULL;\r\nreturn clk_register_composite(NULL, name, parent_names, num_parents,\r\n&div->hw, mux_ops, &div->hw, rate_ops,\r\n&div->hw, gate_ops, flags);\r\n}
