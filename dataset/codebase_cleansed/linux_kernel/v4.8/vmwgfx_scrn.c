static void vmw_sou_destroy(struct vmw_screen_object_unit *sou)\r\n{\r\nvmw_du_cleanup(&sou->base);\r\nkfree(sou);\r\n}\r\nstatic void vmw_sou_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nvmw_sou_destroy(vmw_crtc_to_sou(crtc));\r\n}\r\nstatic int vmw_sou_fifo_create(struct vmw_private *dev_priv,\r\nstruct vmw_screen_object_unit *sou,\r\nuint32_t x, uint32_t y,\r\nstruct drm_display_mode *mode)\r\n{\r\nsize_t fifo_size;\r\nstruct {\r\nstruct {\r\nuint32_t cmdType;\r\n} header;\r\nSVGAScreenObject obj;\r\n} *cmd;\r\nBUG_ON(!sou->buffer);\r\nfifo_size = sizeof(*cmd);\r\ncmd = vmw_fifo_reserve(dev_priv, fifo_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, fifo_size);\r\ncmd->header.cmdType = SVGA_CMD_DEFINE_SCREEN;\r\ncmd->obj.structSize = sizeof(SVGAScreenObject);\r\ncmd->obj.id = sou->base.unit;\r\ncmd->obj.flags = SVGA_SCREEN_HAS_ROOT |\r\n(sou->base.unit == 0 ? SVGA_SCREEN_IS_PRIMARY : 0);\r\ncmd->obj.size.width = mode->hdisplay;\r\ncmd->obj.size.height = mode->vdisplay;\r\nif (sou->base.is_implicit) {\r\ncmd->obj.root.x = x;\r\ncmd->obj.root.y = y;\r\n} else {\r\ncmd->obj.root.x = sou->base.gui_x;\r\ncmd->obj.root.y = sou->base.gui_y;\r\n}\r\nsou->base.set_gui_x = cmd->obj.root.x;\r\nsou->base.set_gui_y = cmd->obj.root.y;\r\nvmw_bo_get_guest_ptr(&sou->buffer->base, &cmd->obj.backingStore.ptr);\r\ncmd->obj.backingStore.pitch = mode->hdisplay * 4;\r\nvmw_fifo_commit(dev_priv, fifo_size);\r\nsou->defined = true;\r\nreturn 0;\r\n}\r\nstatic int vmw_sou_fifo_destroy(struct vmw_private *dev_priv,\r\nstruct vmw_screen_object_unit *sou)\r\n{\r\nsize_t fifo_size;\r\nint ret;\r\nstruct {\r\nstruct {\r\nuint32_t cmdType;\r\n} header;\r\nSVGAFifoCmdDestroyScreen body;\r\n} *cmd;\r\nif (unlikely(!sou->defined))\r\nreturn 0;\r\nfifo_size = sizeof(*cmd);\r\ncmd = vmw_fifo_reserve(dev_priv, fifo_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, fifo_size);\r\ncmd->header.cmdType = SVGA_CMD_DESTROY_SCREEN;\r\ncmd->body.screenId = sou->base.unit;\r\nvmw_fifo_commit(dev_priv, fifo_size);\r\nret = vmw_fallback_wait(dev_priv, false, true, 0, false, 3*HZ);\r\nif (unlikely(ret != 0))\r\nDRM_ERROR("Failed to sync with HW");\r\nelse\r\nsou->defined = false;\r\nreturn ret;\r\n}\r\nstatic void vmw_sou_backing_free(struct vmw_private *dev_priv,\r\nstruct vmw_screen_object_unit *sou)\r\n{\r\nvmw_dmabuf_unreference(&sou->buffer);\r\nsou->buffer_size = 0;\r\n}\r\nstatic int vmw_sou_backing_alloc(struct vmw_private *dev_priv,\r\nstruct vmw_screen_object_unit *sou,\r\nunsigned long size)\r\n{\r\nint ret;\r\nif (sou->buffer_size == size)\r\nreturn 0;\r\nif (sou->buffer)\r\nvmw_sou_backing_free(dev_priv, sou);\r\nsou->buffer = kzalloc(sizeof(*sou->buffer), GFP_KERNEL);\r\nif (unlikely(sou->buffer == NULL))\r\nreturn -ENOMEM;\r\nvmw_overlay_pause_all(dev_priv);\r\nret = vmw_dmabuf_init(dev_priv, sou->buffer, size,\r\n&vmw_vram_ne_placement,\r\nfalse, &vmw_dmabuf_bo_free);\r\nvmw_overlay_resume_all(dev_priv);\r\nif (unlikely(ret != 0))\r\nsou->buffer = NULL;\r\nelse\r\nsou->buffer_size = size;\r\nreturn ret;\r\n}\r\nstatic int vmw_sou_crtc_set_config(struct drm_mode_set *set)\r\n{\r\nstruct vmw_private *dev_priv;\r\nstruct vmw_screen_object_unit *sou;\r\nstruct drm_connector *connector;\r\nstruct drm_display_mode *mode;\r\nstruct drm_encoder *encoder;\r\nstruct vmw_framebuffer *vfb;\r\nstruct drm_framebuffer *fb;\r\nstruct drm_crtc *crtc;\r\nint ret = 0;\r\nif (!set)\r\nreturn -EINVAL;\r\nif (!set->crtc)\r\nreturn -EINVAL;\r\ncrtc = set->crtc;\r\nsou = vmw_crtc_to_sou(crtc);\r\nvfb = set->fb ? vmw_framebuffer_to_vfb(set->fb) : NULL;\r\ndev_priv = vmw_priv(crtc->dev);\r\nif (set->num_connectors > 1) {\r\nDRM_ERROR("Too many connectors\n");\r\nreturn -EINVAL;\r\n}\r\nif (set->num_connectors == 1 &&\r\nset->connectors[0] != &sou->base.connector) {\r\nDRM_ERROR("Connector doesn't match %p %p\n",\r\nset->connectors[0], &sou->base.connector);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&dev_priv->global_kms_state_mutex);\r\nif (sou->base.is_implicit &&\r\ndev_priv->implicit_fb && vfb &&\r\n!(dev_priv->num_implicit == 1 &&\r\nsou->base.active_implicit) &&\r\ndev_priv->implicit_fb != vfb) {\r\nmutex_unlock(&dev_priv->global_kms_state_mutex);\r\nDRM_ERROR("Multiple implicit framebuffers not supported.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&dev_priv->global_kms_state_mutex);\r\nconnector = &sou->base.connector;\r\nencoder = &sou->base.encoder;\r\nif (set->num_connectors == 0 || !set->mode || !set->fb) {\r\nret = vmw_sou_fifo_destroy(dev_priv, sou);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nconnector->encoder = NULL;\r\nencoder->crtc = NULL;\r\ncrtc->primary->fb = NULL;\r\ncrtc->x = 0;\r\ncrtc->y = 0;\r\ncrtc->enabled = false;\r\nvmw_kms_del_active(dev_priv, &sou->base);\r\nvmw_sou_backing_free(dev_priv, sou);\r\nreturn 0;\r\n}\r\nmode = set->mode;\r\nfb = set->fb;\r\nif (set->x + mode->hdisplay > fb->width ||\r\nset->y + mode->vdisplay > fb->height) {\r\nDRM_ERROR("set outside of framebuffer\n");\r\nreturn -EINVAL;\r\n}\r\nvmw_svga_enable(dev_priv);\r\nif (mode->hdisplay != crtc->mode.hdisplay ||\r\nmode->vdisplay != crtc->mode.vdisplay) {\r\nret = vmw_sou_fifo_destroy(dev_priv, sou);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nvmw_sou_backing_free(dev_priv, sou);\r\n}\r\nif (!sou->buffer) {\r\nsize_t size = mode->hdisplay * mode->vdisplay * 4;\r\nret = vmw_sou_backing_alloc(dev_priv, sou, size);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\n}\r\nret = vmw_sou_fifo_create(dev_priv, sou, set->x, set->y, mode);\r\nif (unlikely(ret != 0)) {\r\nif (sou->defined)\r\nreturn ret;\r\nconnector->encoder = NULL;\r\nencoder->crtc = NULL;\r\ncrtc->primary->fb = NULL;\r\ncrtc->x = 0;\r\ncrtc->y = 0;\r\ncrtc->enabled = false;\r\nreturn ret;\r\n}\r\nvmw_kms_add_active(dev_priv, &sou->base, vfb);\r\nconnector->encoder = encoder;\r\nencoder->crtc = crtc;\r\ncrtc->mode = *mode;\r\ncrtc->primary->fb = fb;\r\ncrtc->x = set->x;\r\ncrtc->y = set->y;\r\ncrtc->enabled = true;\r\nreturn 0;\r\n}\r\nstatic int vmw_sou_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t flags)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nstruct drm_framebuffer *old_fb = crtc->primary->fb;\r\nstruct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(fb);\r\nstruct vmw_fence_obj *fence = NULL;\r\nstruct drm_vmw_rect vclips;\r\nint ret;\r\nif (!vmw_kms_crtc_flippable(dev_priv, crtc))\r\nreturn -EINVAL;\r\ncrtc->primary->fb = fb;\r\nvclips.x = crtc->x;\r\nvclips.y = crtc->y;\r\nvclips.w = crtc->mode.hdisplay;\r\nvclips.h = crtc->mode.vdisplay;\r\nif (vfb->dmabuf)\r\nret = vmw_kms_sou_do_dmabuf_dirty(dev_priv, vfb,\r\nNULL, &vclips, 1, 1,\r\ntrue, &fence);\r\nelse\r\nret = vmw_kms_sou_do_surface_dirty(dev_priv, vfb,\r\nNULL, &vclips, NULL,\r\n0, 0, 1, 1, &fence);\r\nif (ret != 0)\r\ngoto out_no_fence;\r\nif (!fence) {\r\nret = -EINVAL;\r\ngoto out_no_fence;\r\n}\r\nif (event) {\r\nstruct drm_file *file_priv = event->base.file_priv;\r\nret = vmw_event_fence_action_queue(file_priv, fence,\r\n&event->base,\r\n&event->event.tv_sec,\r\n&event->event.tv_usec,\r\ntrue);\r\n}\r\nvmw_fence_obj_unreference(&fence);\r\nif (vmw_crtc_to_du(crtc)->is_implicit)\r\nvmw_kms_update_implicit_fb(dev_priv, crtc);\r\nreturn ret;\r\nout_no_fence:\r\ncrtc->primary->fb = old_fb;\r\nreturn ret;\r\n}\r\nstatic void vmw_sou_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nvmw_sou_destroy(vmw_encoder_to_sou(encoder));\r\n}\r\nstatic void vmw_sou_connector_destroy(struct drm_connector *connector)\r\n{\r\nvmw_sou_destroy(vmw_connector_to_sou(connector));\r\n}\r\nstatic int vmw_sou_init(struct vmw_private *dev_priv, unsigned unit)\r\n{\r\nstruct vmw_screen_object_unit *sou;\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\nsou = kzalloc(sizeof(*sou), GFP_KERNEL);\r\nif (!sou)\r\nreturn -ENOMEM;\r\nsou->base.unit = unit;\r\ncrtc = &sou->base.crtc;\r\nencoder = &sou->base.encoder;\r\nconnector = &sou->base.connector;\r\nsou->base.active_implicit = false;\r\nsou->base.pref_active = (unit == 0);\r\nsou->base.pref_width = dev_priv->initial_width;\r\nsou->base.pref_height = dev_priv->initial_height;\r\nsou->base.pref_mode = NULL;\r\nsou->base.is_implicit = false;\r\ndrm_connector_init(dev, connector, &vmw_sou_connector_funcs,\r\nDRM_MODE_CONNECTOR_VIRTUAL);\r\nconnector->status = vmw_du_connector_detect(connector, true);\r\ndrm_encoder_init(dev, encoder, &vmw_screen_object_encoder_funcs,\r\nDRM_MODE_ENCODER_VIRTUAL, NULL);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nencoder->possible_crtcs = (1 << unit);\r\nencoder->possible_clones = 0;\r\n(void) drm_connector_register(connector);\r\ndrm_crtc_init(dev, crtc, &vmw_screen_object_crtc_funcs);\r\ndrm_mode_crtc_set_gamma_size(crtc, 256);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.dirty_info_property,\r\n1);\r\ndrm_object_attach_property(&connector->base,\r\ndev_priv->hotplug_mode_update_property, 1);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.suggested_x_property, 0);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.suggested_y_property, 0);\r\nif (dev_priv->implicit_placement_property)\r\ndrm_object_attach_property\r\n(&connector->base,\r\ndev_priv->implicit_placement_property,\r\nsou->base.is_implicit);\r\nreturn 0;\r\n}\r\nint vmw_kms_sou_init_display(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nint i, ret;\r\nif (!(dev_priv->capabilities & SVGA_CAP_SCREEN_OBJECT_2)) {\r\nDRM_INFO("Not using screen objects,"\r\n" missing cap SCREEN_OBJECT_2\n");\r\nreturn -ENOSYS;\r\n}\r\nret = -ENOMEM;\r\ndev_priv->num_implicit = 0;\r\ndev_priv->implicit_fb = NULL;\r\nret = drm_vblank_init(dev, VMWGFX_NUM_DISPLAY_UNITS);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = drm_mode_create_dirty_info_property(dev);\r\nif (unlikely(ret != 0))\r\ngoto err_vblank_cleanup;\r\nvmw_kms_create_implicit_placement_property(dev_priv, false);\r\nfor (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i)\r\nvmw_sou_init(dev_priv, i);\r\ndev_priv->active_display_unit = vmw_du_screen_object;\r\nDRM_INFO("Screen Objects Display Unit initialized\n");\r\nreturn 0;\r\nerr_vblank_cleanup:\r\ndrm_vblank_cleanup(dev);\r\nreturn ret;\r\n}\r\nint vmw_kms_sou_close_display(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\ndrm_vblank_cleanup(dev);\r\nreturn 0;\r\n}\r\nstatic int do_dmabuf_define_gmrfb(struct vmw_private *dev_priv,\r\nstruct vmw_framebuffer *framebuffer)\r\n{\r\nstruct vmw_dma_buffer *buf =\r\ncontainer_of(framebuffer, struct vmw_framebuffer_dmabuf,\r\nbase)->buffer;\r\nint depth = framebuffer->base.depth;\r\nstruct {\r\nuint32_t header;\r\nSVGAFifoCmdDefineGMRFB body;\r\n} *cmd;\r\nif (depth == 32)\r\ndepth = 24;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (!cmd) {\r\nDRM_ERROR("Out of fifo space for dirty framebuffer command.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header = SVGA_CMD_DEFINE_GMRFB;\r\ncmd->body.format.bitsPerPixel = framebuffer->base.bits_per_pixel;\r\ncmd->body.format.colorDepth = depth;\r\ncmd->body.format.reserved = 0;\r\ncmd->body.bytesPerLine = framebuffer->base.pitches[0];\r\nvmw_bo_get_guest_ptr(&buf->base, &cmd->body.ptr);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic void vmw_sou_surface_fifo_commit(struct vmw_kms_dirty *dirty)\r\n{\r\nstruct vmw_kms_sou_surface_dirty *sdirty =\r\ncontainer_of(dirty, typeof(*sdirty), base);\r\nstruct vmw_kms_sou_dirty_cmd *cmd = dirty->cmd;\r\ns32 trans_x = dirty->unit->crtc.x - sdirty->dst_x;\r\ns32 trans_y = dirty->unit->crtc.y - sdirty->dst_y;\r\nsize_t region_size = dirty->num_hits * sizeof(SVGASignedRect);\r\nSVGASignedRect *blit = (SVGASignedRect *) &cmd[1];\r\nint i;\r\nif (!dirty->num_hits) {\r\nvmw_fifo_commit(dirty->dev_priv, 0);\r\nreturn;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN;\r\ncmd->header.size = sizeof(cmd->body) + region_size;\r\ncmd->body.destRect.left = sdirty->left;\r\ncmd->body.destRect.right = sdirty->right;\r\ncmd->body.destRect.top = sdirty->top;\r\ncmd->body.destRect.bottom = sdirty->bottom;\r\ncmd->body.srcRect.left = sdirty->left + trans_x;\r\ncmd->body.srcRect.right = sdirty->right + trans_x;\r\ncmd->body.srcRect.top = sdirty->top + trans_y;\r\ncmd->body.srcRect.bottom = sdirty->bottom + trans_y;\r\ncmd->body.srcImage.sid = sdirty->sid;\r\ncmd->body.destScreenId = dirty->unit->unit;\r\nfor (i = 0; i < dirty->num_hits; ++i, ++blit) {\r\nblit->left -= sdirty->left;\r\nblit->right -= sdirty->left;\r\nblit->top -= sdirty->top;\r\nblit->bottom -= sdirty->top;\r\n}\r\nvmw_fifo_commit(dirty->dev_priv, region_size + sizeof(*cmd));\r\nsdirty->left = sdirty->top = S32_MAX;\r\nsdirty->right = sdirty->bottom = S32_MIN;\r\n}\r\nstatic void vmw_sou_surface_clip(struct vmw_kms_dirty *dirty)\r\n{\r\nstruct vmw_kms_sou_surface_dirty *sdirty =\r\ncontainer_of(dirty, typeof(*sdirty), base);\r\nstruct vmw_kms_sou_dirty_cmd *cmd = dirty->cmd;\r\nSVGASignedRect *blit = (SVGASignedRect *) &cmd[1];\r\nblit += dirty->num_hits;\r\nblit->left = dirty->unit_x1;\r\nblit->top = dirty->unit_y1;\r\nblit->right = dirty->unit_x2;\r\nblit->bottom = dirty->unit_y2;\r\nsdirty->left = min_t(s32, sdirty->left, dirty->unit_x1);\r\nsdirty->top = min_t(s32, sdirty->top, dirty->unit_y1);\r\nsdirty->right = max_t(s32, sdirty->right, dirty->unit_x2);\r\nsdirty->bottom = max_t(s32, sdirty->bottom, dirty->unit_y2);\r\ndirty->num_hits++;\r\n}\r\nint vmw_kms_sou_do_surface_dirty(struct vmw_private *dev_priv,\r\nstruct vmw_framebuffer *framebuffer,\r\nstruct drm_clip_rect *clips,\r\nstruct drm_vmw_rect *vclips,\r\nstruct vmw_resource *srf,\r\ns32 dest_x,\r\ns32 dest_y,\r\nunsigned num_clips, int inc,\r\nstruct vmw_fence_obj **out_fence)\r\n{\r\nstruct vmw_framebuffer_surface *vfbs =\r\ncontainer_of(framebuffer, typeof(*vfbs), base);\r\nstruct vmw_kms_sou_surface_dirty sdirty;\r\nint ret;\r\nif (!srf)\r\nsrf = &vfbs->surface->res;\r\nret = vmw_kms_helper_resource_prepare(srf, true);\r\nif (ret)\r\nreturn ret;\r\nsdirty.base.fifo_commit = vmw_sou_surface_fifo_commit;\r\nsdirty.base.clip = vmw_sou_surface_clip;\r\nsdirty.base.dev_priv = dev_priv;\r\nsdirty.base.fifo_reserve_size = sizeof(struct vmw_kms_sou_dirty_cmd) +\r\nsizeof(SVGASignedRect) * num_clips;\r\nsdirty.sid = srf->id;\r\nsdirty.left = sdirty.top = S32_MAX;\r\nsdirty.right = sdirty.bottom = S32_MIN;\r\nsdirty.dst_x = dest_x;\r\nsdirty.dst_y = dest_y;\r\nret = vmw_kms_helper_dirty(dev_priv, framebuffer, clips, vclips,\r\ndest_x, dest_y, num_clips, inc,\r\n&sdirty.base);\r\nvmw_kms_helper_resource_finish(srf, out_fence);\r\nreturn ret;\r\n}\r\nstatic void vmw_sou_dmabuf_fifo_commit(struct vmw_kms_dirty *dirty)\r\n{\r\nif (!dirty->num_hits) {\r\nvmw_fifo_commit(dirty->dev_priv, 0);\r\nreturn;\r\n}\r\nvmw_fifo_commit(dirty->dev_priv,\r\nsizeof(struct vmw_kms_sou_dmabuf_blit) *\r\ndirty->num_hits);\r\n}\r\nstatic void vmw_sou_dmabuf_clip(struct vmw_kms_dirty *dirty)\r\n{\r\nstruct vmw_kms_sou_dmabuf_blit *blit = dirty->cmd;\r\nblit += dirty->num_hits;\r\nblit->header = SVGA_CMD_BLIT_GMRFB_TO_SCREEN;\r\nblit->body.destScreenId = dirty->unit->unit;\r\nblit->body.srcOrigin.x = dirty->fb_x;\r\nblit->body.srcOrigin.y = dirty->fb_y;\r\nblit->body.destRect.left = dirty->unit_x1;\r\nblit->body.destRect.top = dirty->unit_y1;\r\nblit->body.destRect.right = dirty->unit_x2;\r\nblit->body.destRect.bottom = dirty->unit_y2;\r\ndirty->num_hits++;\r\n}\r\nint vmw_kms_sou_do_dmabuf_dirty(struct vmw_private *dev_priv,\r\nstruct vmw_framebuffer *framebuffer,\r\nstruct drm_clip_rect *clips,\r\nstruct drm_vmw_rect *vclips,\r\nunsigned num_clips, int increment,\r\nbool interruptible,\r\nstruct vmw_fence_obj **out_fence)\r\n{\r\nstruct vmw_dma_buffer *buf =\r\ncontainer_of(framebuffer, struct vmw_framebuffer_dmabuf,\r\nbase)->buffer;\r\nstruct vmw_kms_dirty dirty;\r\nint ret;\r\nret = vmw_kms_helper_buffer_prepare(dev_priv, buf, interruptible,\r\nfalse);\r\nif (ret)\r\nreturn ret;\r\nret = do_dmabuf_define_gmrfb(dev_priv, framebuffer);\r\nif (unlikely(ret != 0))\r\ngoto out_revert;\r\ndirty.fifo_commit = vmw_sou_dmabuf_fifo_commit;\r\ndirty.clip = vmw_sou_dmabuf_clip;\r\ndirty.fifo_reserve_size = sizeof(struct vmw_kms_sou_dmabuf_blit) *\r\nnum_clips;\r\nret = vmw_kms_helper_dirty(dev_priv, framebuffer, clips, vclips,\r\n0, 0, num_clips, increment, &dirty);\r\nvmw_kms_helper_buffer_finish(dev_priv, NULL, buf, out_fence, NULL);\r\nreturn ret;\r\nout_revert:\r\nvmw_kms_helper_buffer_revert(buf);\r\nreturn ret;\r\n}\r\nstatic void vmw_sou_readback_fifo_commit(struct vmw_kms_dirty *dirty)\r\n{\r\nif (!dirty->num_hits) {\r\nvmw_fifo_commit(dirty->dev_priv, 0);\r\nreturn;\r\n}\r\nvmw_fifo_commit(dirty->dev_priv,\r\nsizeof(struct vmw_kms_sou_readback_blit) *\r\ndirty->num_hits);\r\n}\r\nstatic void vmw_sou_readback_clip(struct vmw_kms_dirty *dirty)\r\n{\r\nstruct vmw_kms_sou_readback_blit *blit = dirty->cmd;\r\nblit += dirty->num_hits;\r\nblit->header = SVGA_CMD_BLIT_SCREEN_TO_GMRFB;\r\nblit->body.srcScreenId = dirty->unit->unit;\r\nblit->body.destOrigin.x = dirty->fb_x;\r\nblit->body.destOrigin.y = dirty->fb_y;\r\nblit->body.srcRect.left = dirty->unit_x1;\r\nblit->body.srcRect.top = dirty->unit_y1;\r\nblit->body.srcRect.right = dirty->unit_x2;\r\nblit->body.srcRect.bottom = dirty->unit_y2;\r\ndirty->num_hits++;\r\n}\r\nint vmw_kms_sou_readback(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_framebuffer *vfb,\r\nstruct drm_vmw_fence_rep __user *user_fence_rep,\r\nstruct drm_vmw_rect *vclips,\r\nuint32_t num_clips)\r\n{\r\nstruct vmw_dma_buffer *buf =\r\ncontainer_of(vfb, struct vmw_framebuffer_dmabuf, base)->buffer;\r\nstruct vmw_kms_dirty dirty;\r\nint ret;\r\nret = vmw_kms_helper_buffer_prepare(dev_priv, buf, true, false);\r\nif (ret)\r\nreturn ret;\r\nret = do_dmabuf_define_gmrfb(dev_priv, vfb);\r\nif (unlikely(ret != 0))\r\ngoto out_revert;\r\ndirty.fifo_commit = vmw_sou_readback_fifo_commit;\r\ndirty.clip = vmw_sou_readback_clip;\r\ndirty.fifo_reserve_size = sizeof(struct vmw_kms_sou_readback_blit) *\r\nnum_clips;\r\nret = vmw_kms_helper_dirty(dev_priv, vfb, NULL, vclips,\r\n0, 0, num_clips, 1, &dirty);\r\nvmw_kms_helper_buffer_finish(dev_priv, file_priv, buf, NULL,\r\nuser_fence_rep);\r\nreturn ret;\r\nout_revert:\r\nvmw_kms_helper_buffer_revert(buf);\r\nreturn ret;\r\n}
