static void altera_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct altera_gpio_chip *altera_gc;\r\nstruct of_mm_gpio_chip *mm_gc;\r\nunsigned long flags;\r\nu32 intmask;\r\naltera_gc = gpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nmm_gc = &altera_gc->mmchip;\r\nspin_lock_irqsave(&altera_gc->gpio_lock, flags);\r\nintmask = readl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK);\r\nintmask |= BIT(irqd_to_hwirq(d));\r\nwritel(intmask, mm_gc->regs + ALTERA_GPIO_IRQ_MASK);\r\nspin_unlock_irqrestore(&altera_gc->gpio_lock, flags);\r\n}\r\nstatic void altera_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct altera_gpio_chip *altera_gc;\r\nstruct of_mm_gpio_chip *mm_gc;\r\nunsigned long flags;\r\nu32 intmask;\r\naltera_gc = gpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nmm_gc = &altera_gc->mmchip;\r\nspin_lock_irqsave(&altera_gc->gpio_lock, flags);\r\nintmask = readl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK);\r\nintmask &= ~BIT(irqd_to_hwirq(d));\r\nwritel(intmask, mm_gc->regs + ALTERA_GPIO_IRQ_MASK);\r\nspin_unlock_irqrestore(&altera_gc->gpio_lock, flags);\r\n}\r\nstatic int altera_gpio_irq_set_type(struct irq_data *d,\r\nunsigned int type)\r\n{\r\nstruct altera_gpio_chip *altera_gc;\r\naltera_gc = gpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nif (type == IRQ_TYPE_NONE)\r\nreturn 0;\r\nif (type == IRQ_TYPE_LEVEL_HIGH &&\r\naltera_gc->interrupt_trigger == IRQ_TYPE_LEVEL_HIGH)\r\nreturn 0;\r\nif (type == IRQ_TYPE_EDGE_RISING &&\r\naltera_gc->interrupt_trigger == IRQ_TYPE_EDGE_RISING)\r\nreturn 0;\r\nif (type == IRQ_TYPE_EDGE_FALLING &&\r\naltera_gc->interrupt_trigger == IRQ_TYPE_EDGE_FALLING)\r\nreturn 0;\r\nif (type == IRQ_TYPE_EDGE_BOTH &&\r\naltera_gc->interrupt_trigger == IRQ_TYPE_EDGE_BOTH)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned int altera_gpio_irq_startup(struct irq_data *d)\r\n{\r\naltera_gpio_irq_unmask(d);\r\nreturn 0;\r\n}\r\nstatic int altera_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc;\r\nmm_gc = to_of_mm_gpio_chip(gc);\r\nreturn !!(readl(mm_gc->regs + ALTERA_GPIO_DATA) & BIT(offset));\r\n}\r\nstatic void altera_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct altera_gpio_chip *chip;\r\nunsigned long flags;\r\nunsigned int data_reg;\r\nmm_gc = to_of_mm_gpio_chip(gc);\r\nchip = gpiochip_get_data(gc);\r\nspin_lock_irqsave(&chip->gpio_lock, flags);\r\ndata_reg = readl(mm_gc->regs + ALTERA_GPIO_DATA);\r\nif (value)\r\ndata_reg |= BIT(offset);\r\nelse\r\ndata_reg &= ~BIT(offset);\r\nwritel(data_reg, mm_gc->regs + ALTERA_GPIO_DATA);\r\nspin_unlock_irqrestore(&chip->gpio_lock, flags);\r\n}\r\nstatic int altera_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct altera_gpio_chip *chip;\r\nunsigned long flags;\r\nunsigned int gpio_ddr;\r\nmm_gc = to_of_mm_gpio_chip(gc);\r\nchip = gpiochip_get_data(gc);\r\nspin_lock_irqsave(&chip->gpio_lock, flags);\r\ngpio_ddr = readl(mm_gc->regs + ALTERA_GPIO_DIR);\r\ngpio_ddr &= ~BIT(offset);\r\nwritel(gpio_ddr, mm_gc->regs + ALTERA_GPIO_DIR);\r\nspin_unlock_irqrestore(&chip->gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int altera_gpio_direction_output(struct gpio_chip *gc,\r\nunsigned offset, int value)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct altera_gpio_chip *chip;\r\nunsigned long flags;\r\nunsigned int data_reg, gpio_ddr;\r\nmm_gc = to_of_mm_gpio_chip(gc);\r\nchip = gpiochip_get_data(gc);\r\nspin_lock_irqsave(&chip->gpio_lock, flags);\r\ndata_reg = readl(mm_gc->regs + ALTERA_GPIO_DATA);\r\nif (value)\r\ndata_reg |= BIT(offset);\r\nelse\r\ndata_reg &= ~BIT(offset);\r\nwritel(data_reg, mm_gc->regs + ALTERA_GPIO_DATA);\r\ngpio_ddr = readl(mm_gc->regs + ALTERA_GPIO_DIR);\r\ngpio_ddr |= BIT(offset);\r\nwritel(gpio_ddr, mm_gc->regs + ALTERA_GPIO_DIR);\r\nspin_unlock_irqrestore(&chip->gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void altera_gpio_irq_edge_handler(struct irq_desc *desc)\r\n{\r\nstruct altera_gpio_chip *altera_gc;\r\nstruct irq_chip *chip;\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct irq_domain *irqdomain;\r\nunsigned long status;\r\nint i;\r\naltera_gc = gpiochip_get_data(irq_desc_get_handler_data(desc));\r\nchip = irq_desc_get_chip(desc);\r\nmm_gc = &altera_gc->mmchip;\r\nirqdomain = altera_gc->mmchip.gc.irqdomain;\r\nchained_irq_enter(chip, desc);\r\nwhile ((status =\r\n(readl(mm_gc->regs + ALTERA_GPIO_EDGE_CAP) &\r\nreadl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK)))) {\r\nwritel(status, mm_gc->regs + ALTERA_GPIO_EDGE_CAP);\r\nfor_each_set_bit(i, &status, mm_gc->gc.ngpio) {\r\ngeneric_handle_irq(irq_find_mapping(irqdomain, i));\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void altera_gpio_irq_leveL_high_handler(struct irq_desc *desc)\r\n{\r\nstruct altera_gpio_chip *altera_gc;\r\nstruct irq_chip *chip;\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct irq_domain *irqdomain;\r\nunsigned long status;\r\nint i;\r\naltera_gc = gpiochip_get_data(irq_desc_get_handler_data(desc));\r\nchip = irq_desc_get_chip(desc);\r\nmm_gc = &altera_gc->mmchip;\r\nirqdomain = altera_gc->mmchip.gc.irqdomain;\r\nchained_irq_enter(chip, desc);\r\nstatus = readl(mm_gc->regs + ALTERA_GPIO_DATA);\r\nstatus &= readl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK);\r\nfor_each_set_bit(i, &status, mm_gc->gc.ngpio) {\r\ngeneric_handle_irq(irq_find_mapping(irqdomain, i));\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int altera_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nint reg, ret;\r\nstruct altera_gpio_chip *altera_gc;\r\naltera_gc = devm_kzalloc(&pdev->dev, sizeof(*altera_gc), GFP_KERNEL);\r\nif (!altera_gc)\r\nreturn -ENOMEM;\r\nspin_lock_init(&altera_gc->gpio_lock);\r\nif (of_property_read_u32(node, "altr,ngpio", &reg))\r\naltera_gc->mmchip.gc.ngpio = ALTERA_GPIO_MAX_NGPIO;\r\nelse\r\naltera_gc->mmchip.gc.ngpio = reg;\r\nif (altera_gc->mmchip.gc.ngpio > ALTERA_GPIO_MAX_NGPIO) {\r\ndev_warn(&pdev->dev,\r\n"ngpio is greater than %d, defaulting to %d\n",\r\nALTERA_GPIO_MAX_NGPIO, ALTERA_GPIO_MAX_NGPIO);\r\naltera_gc->mmchip.gc.ngpio = ALTERA_GPIO_MAX_NGPIO;\r\n}\r\naltera_gc->mmchip.gc.direction_input = altera_gpio_direction_input;\r\naltera_gc->mmchip.gc.direction_output = altera_gpio_direction_output;\r\naltera_gc->mmchip.gc.get = altera_gpio_get;\r\naltera_gc->mmchip.gc.set = altera_gpio_set;\r\naltera_gc->mmchip.gc.owner = THIS_MODULE;\r\naltera_gc->mmchip.gc.parent = &pdev->dev;\r\nret = of_mm_gpiochip_add_data(node, &altera_gc->mmchip, altera_gc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed adding memory mapped gpiochip\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, altera_gc);\r\naltera_gc->mapped_irq = platform_get_irq(pdev, 0);\r\nif (altera_gc->mapped_irq < 0)\r\ngoto skip_irq;\r\nif (of_property_read_u32(node, "altr,interrupt-type", &reg)) {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev,\r\n"altr,interrupt-type value not set in device tree\n");\r\ngoto teardown;\r\n}\r\naltera_gc->interrupt_trigger = reg;\r\nret = gpiochip_irqchip_add(&altera_gc->mmchip.gc, &altera_irq_chip, 0,\r\nhandle_simple_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not add irqchip\n");\r\ngoto teardown;\r\n}\r\ngpiochip_set_chained_irqchip(&altera_gc->mmchip.gc,\r\n&altera_irq_chip,\r\naltera_gc->mapped_irq,\r\naltera_gc->interrupt_trigger == IRQ_TYPE_LEVEL_HIGH ?\r\naltera_gpio_irq_leveL_high_handler :\r\naltera_gpio_irq_edge_handler);\r\nskip_irq:\r\nreturn 0;\r\nteardown:\r\nof_mm_gpiochip_remove(&altera_gc->mmchip);\r\npr_err("%s: registration failed with status %d\n",\r\nnode->full_name, ret);\r\nreturn ret;\r\n}\r\nstatic int altera_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct altera_gpio_chip *altera_gc = platform_get_drvdata(pdev);\r\nof_mm_gpiochip_remove(&altera_gc->mmchip);\r\nreturn 0;\r\n}\r\nstatic int __init altera_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&altera_gpio_driver);\r\n}\r\nstatic void __exit altera_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&altera_gpio_driver);\r\n}
