static int serio_raw_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct serio_raw_client *client = file->private_data;\r\nreturn fasync_helper(fd, file, on, &client->fasync);\r\n}\r\nstatic struct serio_raw *serio_raw_locate(int minor)\r\n{\r\nstruct serio_raw *serio_raw;\r\nlist_for_each_entry(serio_raw, &serio_raw_list, node) {\r\nif (serio_raw->dev.minor == minor)\r\nreturn serio_raw;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int serio_raw_open(struct inode *inode, struct file *file)\r\n{\r\nstruct serio_raw *serio_raw;\r\nstruct serio_raw_client *client;\r\nint retval;\r\nretval = mutex_lock_interruptible(&serio_raw_mutex);\r\nif (retval)\r\nreturn retval;\r\nserio_raw = serio_raw_locate(iminor(inode));\r\nif (!serio_raw) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (serio_raw->dead) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nclient = kzalloc(sizeof(struct serio_raw_client), GFP_KERNEL);\r\nif (!client) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nclient->serio_raw = serio_raw;\r\nfile->private_data = client;\r\nkref_get(&serio_raw->kref);\r\nserio_pause_rx(serio_raw->serio);\r\nlist_add_tail(&client->node, &serio_raw->client_list);\r\nserio_continue_rx(serio_raw->serio);\r\nout:\r\nmutex_unlock(&serio_raw_mutex);\r\nreturn retval;\r\n}\r\nstatic void serio_raw_free(struct kref *kref)\r\n{\r\nstruct serio_raw *serio_raw =\r\ncontainer_of(kref, struct serio_raw, kref);\r\nput_device(&serio_raw->serio->dev);\r\nkfree(serio_raw);\r\n}\r\nstatic int serio_raw_release(struct inode *inode, struct file *file)\r\n{\r\nstruct serio_raw_client *client = file->private_data;\r\nstruct serio_raw *serio_raw = client->serio_raw;\r\nserio_pause_rx(serio_raw->serio);\r\nlist_del(&client->node);\r\nserio_continue_rx(serio_raw->serio);\r\nkfree(client);\r\nkref_put(&serio_raw->kref, serio_raw_free);\r\nreturn 0;\r\n}\r\nstatic bool serio_raw_fetch_byte(struct serio_raw *serio_raw, char *c)\r\n{\r\nbool empty;\r\nserio_pause_rx(serio_raw->serio);\r\nempty = serio_raw->head == serio_raw->tail;\r\nif (!empty) {\r\n*c = serio_raw->queue[serio_raw->tail];\r\nserio_raw->tail = (serio_raw->tail + 1) % SERIO_RAW_QUEUE_LEN;\r\n}\r\nserio_continue_rx(serio_raw->serio);\r\nreturn !empty;\r\n}\r\nstatic ssize_t serio_raw_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct serio_raw_client *client = file->private_data;\r\nstruct serio_raw *serio_raw = client->serio_raw;\r\nchar uninitialized_var(c);\r\nssize_t read = 0;\r\nint error;\r\nfor (;;) {\r\nif (serio_raw->dead)\r\nreturn -ENODEV;\r\nif (serio_raw->head == serio_raw->tail &&\r\n(file->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\nif (count == 0)\r\nbreak;\r\nwhile (read < count && serio_raw_fetch_byte(serio_raw, &c)) {\r\nif (put_user(c, buffer++))\r\nreturn -EFAULT;\r\nread++;\r\n}\r\nif (read)\r\nbreak;\r\nif (!(file->f_flags & O_NONBLOCK)) {\r\nerror = wait_event_interruptible(serio_raw->wait,\r\nserio_raw->head != serio_raw->tail ||\r\nserio_raw->dead);\r\nif (error)\r\nreturn error;\r\n}\r\n}\r\nreturn read;\r\n}\r\nstatic ssize_t serio_raw_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct serio_raw_client *client = file->private_data;\r\nstruct serio_raw *serio_raw = client->serio_raw;\r\nint retval = 0;\r\nunsigned char c;\r\nretval = mutex_lock_interruptible(&serio_raw_mutex);\r\nif (retval)\r\nreturn retval;\r\nif (serio_raw->dead) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (count > 32)\r\ncount = 32;\r\nwhile (count--) {\r\nif (get_user(c, buffer++)) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nif (serio_write(serio_raw->serio, c)) {\r\nif (retval == 0)\r\nretval = -EIO;\r\ngoto out;\r\n}\r\nretval++;\r\n}\r\nout:\r\nmutex_unlock(&serio_raw_mutex);\r\nreturn retval;\r\n}\r\nstatic unsigned int serio_raw_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct serio_raw_client *client = file->private_data;\r\nstruct serio_raw *serio_raw = client->serio_raw;\r\nunsigned int mask;\r\npoll_wait(file, &serio_raw->wait, wait);\r\nmask = serio_raw->dead ? POLLHUP | POLLERR : POLLOUT | POLLWRNORM;\r\nif (serio_raw->head != serio_raw->tail)\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic irqreturn_t serio_raw_interrupt(struct serio *serio, unsigned char data,\r\nunsigned int dfl)\r\n{\r\nstruct serio_raw *serio_raw = serio_get_drvdata(serio);\r\nstruct serio_raw_client *client;\r\nunsigned int head = serio_raw->head;\r\nserio_raw->queue[head] = data;\r\nhead = (head + 1) % SERIO_RAW_QUEUE_LEN;\r\nif (likely(head != serio_raw->tail)) {\r\nserio_raw->head = head;\r\nlist_for_each_entry(client, &serio_raw->client_list, node)\r\nkill_fasync(&client->fasync, SIGIO, POLL_IN);\r\nwake_up_interruptible(&serio_raw->wait);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int serio_raw_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstatic atomic_t serio_raw_no = ATOMIC_INIT(-1);\r\nstruct serio_raw *serio_raw;\r\nint err;\r\nserio_raw = kzalloc(sizeof(struct serio_raw), GFP_KERNEL);\r\nif (!serio_raw) {\r\ndev_dbg(&serio->dev, "can't allocate memory for a device\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(serio_raw->name, sizeof(serio_raw->name),\r\n"serio_raw%ld", (long)atomic_inc_return(&serio_raw_no));\r\nkref_init(&serio_raw->kref);\r\nINIT_LIST_HEAD(&serio_raw->client_list);\r\ninit_waitqueue_head(&serio_raw->wait);\r\nserio_raw->serio = serio;\r\nget_device(&serio->dev);\r\nserio_set_drvdata(serio, serio_raw);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto err_free;\r\nerr = mutex_lock_killable(&serio_raw_mutex);\r\nif (err)\r\ngoto err_close;\r\nlist_add_tail(&serio_raw->node, &serio_raw_list);\r\nmutex_unlock(&serio_raw_mutex);\r\nserio_raw->dev.minor = PSMOUSE_MINOR;\r\nserio_raw->dev.name = serio_raw->name;\r\nserio_raw->dev.parent = &serio->dev;\r\nserio_raw->dev.fops = &serio_raw_fops;\r\nerr = misc_register(&serio_raw->dev);\r\nif (err) {\r\nserio_raw->dev.minor = MISC_DYNAMIC_MINOR;\r\nerr = misc_register(&serio_raw->dev);\r\n}\r\nif (err) {\r\ndev_err(&serio->dev,\r\n"failed to register raw access device for %s\n",\r\nserio->phys);\r\ngoto err_unlink;\r\n}\r\ndev_info(&serio->dev, "raw access enabled on %s (%s, minor %d)\n",\r\nserio->phys, serio_raw->name, serio_raw->dev.minor);\r\nreturn 0;\r\nerr_unlink:\r\nlist_del_init(&serio_raw->node);\r\nerr_close:\r\nserio_close(serio);\r\nerr_free:\r\nserio_set_drvdata(serio, NULL);\r\nkref_put(&serio_raw->kref, serio_raw_free);\r\nreturn err;\r\n}\r\nstatic int serio_raw_reconnect(struct serio *serio)\r\n{\r\nstruct serio_raw *serio_raw = serio_get_drvdata(serio);\r\nstruct serio_driver *drv = serio->drv;\r\nif (!drv || !serio_raw) {\r\ndev_dbg(&serio->dev,\r\n"reconnect request, but serio is disconnected, ignoring...\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void serio_raw_hangup(struct serio_raw *serio_raw)\r\n{\r\nstruct serio_raw_client *client;\r\nserio_pause_rx(serio_raw->serio);\r\nlist_for_each_entry(client, &serio_raw->client_list, node)\r\nkill_fasync(&client->fasync, SIGIO, POLL_HUP);\r\nserio_continue_rx(serio_raw->serio);\r\nwake_up_interruptible(&serio_raw->wait);\r\n}\r\nstatic void serio_raw_disconnect(struct serio *serio)\r\n{\r\nstruct serio_raw *serio_raw = serio_get_drvdata(serio);\r\nmisc_deregister(&serio_raw->dev);\r\nmutex_lock(&serio_raw_mutex);\r\nserio_raw->dead = true;\r\nlist_del_init(&serio_raw->node);\r\nmutex_unlock(&serio_raw_mutex);\r\nserio_raw_hangup(serio_raw);\r\nserio_close(serio);\r\nkref_put(&serio_raw->kref, serio_raw_free);\r\nserio_set_drvdata(serio, NULL);\r\n}
