static int regmap_mmio_regbits_check(size_t reg_bits)\r\n{\r\nswitch (reg_bits) {\r\ncase 8:\r\ncase 16:\r\ncase 32:\r\n#ifdef CONFIG_64BIT\r\ncase 64:\r\n#endif\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int regmap_mmio_get_min_stride(size_t val_bits)\r\n{\r\nint min_stride;\r\nswitch (val_bits) {\r\ncase 8:\r\nmin_stride = 0;\r\nreturn 0;\r\ncase 16:\r\nmin_stride = 2;\r\nbreak;\r\ncase 32:\r\nmin_stride = 4;\r\nbreak;\r\n#ifdef CONFIG_64BIT\r\ncase 64:\r\nmin_stride = 8;\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn min_stride;\r\n}\r\nstatic void regmap_mmio_write8(struct regmap_mmio_context *ctx,\r\nunsigned int reg,\r\nunsigned int val)\r\n{\r\nwriteb(val, ctx->regs + reg);\r\n}\r\nstatic void regmap_mmio_write16le(struct regmap_mmio_context *ctx,\r\nunsigned int reg,\r\nunsigned int val)\r\n{\r\nwritew(val, ctx->regs + reg);\r\n}\r\nstatic void regmap_mmio_write16be(struct regmap_mmio_context *ctx,\r\nunsigned int reg,\r\nunsigned int val)\r\n{\r\niowrite16be(val, ctx->regs + reg);\r\n}\r\nstatic void regmap_mmio_write32le(struct regmap_mmio_context *ctx,\r\nunsigned int reg,\r\nunsigned int val)\r\n{\r\nwritel(val, ctx->regs + reg);\r\n}\r\nstatic void regmap_mmio_write32be(struct regmap_mmio_context *ctx,\r\nunsigned int reg,\r\nunsigned int val)\r\n{\r\niowrite32be(val, ctx->regs + reg);\r\n}\r\nstatic void regmap_mmio_write64le(struct regmap_mmio_context *ctx,\r\nunsigned int reg,\r\nunsigned int val)\r\n{\r\nwriteq(val, ctx->regs + reg);\r\n}\r\nstatic int regmap_mmio_write(void *context, unsigned int reg, unsigned int val)\r\n{\r\nstruct regmap_mmio_context *ctx = context;\r\nint ret;\r\nif (!IS_ERR(ctx->clk)) {\r\nret = clk_enable(ctx->clk);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nctx->reg_write(ctx, reg, val);\r\nif (!IS_ERR(ctx->clk))\r\nclk_disable(ctx->clk);\r\nreturn 0;\r\n}\r\nstatic unsigned int regmap_mmio_read8(struct regmap_mmio_context *ctx,\r\nunsigned int reg)\r\n{\r\nreturn readb(ctx->regs + reg);\r\n}\r\nstatic unsigned int regmap_mmio_read16le(struct regmap_mmio_context *ctx,\r\nunsigned int reg)\r\n{\r\nreturn readw(ctx->regs + reg);\r\n}\r\nstatic unsigned int regmap_mmio_read16be(struct regmap_mmio_context *ctx,\r\nunsigned int reg)\r\n{\r\nreturn ioread16be(ctx->regs + reg);\r\n}\r\nstatic unsigned int regmap_mmio_read32le(struct regmap_mmio_context *ctx,\r\nunsigned int reg)\r\n{\r\nreturn readl(ctx->regs + reg);\r\n}\r\nstatic unsigned int regmap_mmio_read32be(struct regmap_mmio_context *ctx,\r\nunsigned int reg)\r\n{\r\nreturn ioread32be(ctx->regs + reg);\r\n}\r\nstatic unsigned int regmap_mmio_read64le(struct regmap_mmio_context *ctx,\r\nunsigned int reg)\r\n{\r\nreturn readq(ctx->regs + reg);\r\n}\r\nstatic int regmap_mmio_read(void *context, unsigned int reg, unsigned int *val)\r\n{\r\nstruct regmap_mmio_context *ctx = context;\r\nint ret;\r\nif (!IS_ERR(ctx->clk)) {\r\nret = clk_enable(ctx->clk);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n*val = ctx->reg_read(ctx, reg);\r\nif (!IS_ERR(ctx->clk))\r\nclk_disable(ctx->clk);\r\nreturn 0;\r\n}\r\nstatic void regmap_mmio_free_context(void *context)\r\n{\r\nstruct regmap_mmio_context *ctx = context;\r\nif (!IS_ERR(ctx->clk)) {\r\nclk_unprepare(ctx->clk);\r\nclk_put(ctx->clk);\r\n}\r\nkfree(context);\r\n}\r\nstatic struct regmap_mmio_context *regmap_mmio_gen_context(struct device *dev,\r\nconst char *clk_id,\r\nvoid __iomem *regs,\r\nconst struct regmap_config *config)\r\n{\r\nstruct regmap_mmio_context *ctx;\r\nint min_stride;\r\nint ret;\r\nret = regmap_mmio_regbits_check(config->reg_bits);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nif (config->pad_bits)\r\nreturn ERR_PTR(-EINVAL);\r\nmin_stride = regmap_mmio_get_min_stride(config->val_bits);\r\nif (min_stride < 0)\r\nreturn ERR_PTR(min_stride);\r\nif (config->reg_stride < min_stride)\r\nreturn ERR_PTR(-EINVAL);\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn ERR_PTR(-ENOMEM);\r\nctx->regs = regs;\r\nctx->val_bytes = config->val_bits / 8;\r\nctx->clk = ERR_PTR(-ENODEV);\r\nswitch (regmap_get_val_endian(dev, &regmap_mmio, config)) {\r\ncase REGMAP_ENDIAN_DEFAULT:\r\ncase REGMAP_ENDIAN_LITTLE:\r\n#ifdef __LITTLE_ENDIAN\r\ncase REGMAP_ENDIAN_NATIVE:\r\n#endif\r\nswitch (config->val_bits) {\r\ncase 8:\r\nctx->reg_read = regmap_mmio_read8;\r\nctx->reg_write = regmap_mmio_write8;\r\nbreak;\r\ncase 16:\r\nctx->reg_read = regmap_mmio_read16le;\r\nctx->reg_write = regmap_mmio_write16le;\r\nbreak;\r\ncase 32:\r\nctx->reg_read = regmap_mmio_read32le;\r\nctx->reg_write = regmap_mmio_write32le;\r\nbreak;\r\n#ifdef CONFIG_64BIT\r\ncase 64:\r\nctx->reg_read = regmap_mmio_read64le;\r\nctx->reg_write = regmap_mmio_write64le;\r\nbreak;\r\n#endif\r\ndefault:\r\nret = -EINVAL;\r\ngoto err_free;\r\n}\r\nbreak;\r\ncase REGMAP_ENDIAN_BIG:\r\n#ifdef __BIG_ENDIAN\r\ncase REGMAP_ENDIAN_NATIVE:\r\n#endif\r\nswitch (config->val_bits) {\r\ncase 8:\r\nctx->reg_read = regmap_mmio_read8;\r\nctx->reg_write = regmap_mmio_write8;\r\nbreak;\r\ncase 16:\r\nctx->reg_read = regmap_mmio_read16be;\r\nctx->reg_write = regmap_mmio_write16be;\r\nbreak;\r\ncase 32:\r\nctx->reg_read = regmap_mmio_read32be;\r\nctx->reg_write = regmap_mmio_write32be;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err_free;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err_free;\r\n}\r\nif (clk_id == NULL)\r\nreturn ctx;\r\nctx->clk = clk_get(dev, clk_id);\r\nif (IS_ERR(ctx->clk)) {\r\nret = PTR_ERR(ctx->clk);\r\ngoto err_free;\r\n}\r\nret = clk_prepare(ctx->clk);\r\nif (ret < 0) {\r\nclk_put(ctx->clk);\r\ngoto err_free;\r\n}\r\nreturn ctx;\r\nerr_free:\r\nkfree(ctx);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct regmap *__regmap_init_mmio_clk(struct device *dev, const char *clk_id,\r\nvoid __iomem *regs,\r\nconst struct regmap_config *config,\r\nstruct lock_class_key *lock_key,\r\nconst char *lock_name)\r\n{\r\nstruct regmap_mmio_context *ctx;\r\nctx = regmap_mmio_gen_context(dev, clk_id, regs, config);\r\nif (IS_ERR(ctx))\r\nreturn ERR_CAST(ctx);\r\nreturn __regmap_init(dev, &regmap_mmio, ctx, config,\r\nlock_key, lock_name);\r\n}\r\nstruct regmap *__devm_regmap_init_mmio_clk(struct device *dev,\r\nconst char *clk_id,\r\nvoid __iomem *regs,\r\nconst struct regmap_config *config,\r\nstruct lock_class_key *lock_key,\r\nconst char *lock_name)\r\n{\r\nstruct regmap_mmio_context *ctx;\r\nctx = regmap_mmio_gen_context(dev, clk_id, regs, config);\r\nif (IS_ERR(ctx))\r\nreturn ERR_CAST(ctx);\r\nreturn __devm_regmap_init(dev, &regmap_mmio, ctx, config,\r\nlock_key, lock_name);\r\n}
