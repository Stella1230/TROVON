static inline int fft_max_index(u8 *bins)\r\n{\r\nreturn (bins[2] & 0xfc) >> 2;\r\n}\r\nstatic inline int fft_max_magnitude(u8 *bins)\r\n{\r\nreturn (bins[0] & 0xc0) >> 6 | bins[1] << 2 | (bins[2] & 0x03) << 10;\r\n}\r\nstatic inline u8 fft_bitmap_weight(u8 *bins)\r\n{\r\nreturn bins[0] & 0x3f;\r\n}\r\nstatic int ath9k_get_max_index_ht40(struct ath9k_dfs_fft_40 *fft,\r\nbool is_ctl, bool is_ext)\r\n{\r\nconst int DFS_UPPER_BIN_OFFSET = 64;\r\nif (is_ctl && is_ext) {\r\nis_ctl = fft_bitmap_weight(fft->lower_bins) != 0;\r\nis_ext = fft_bitmap_weight(fft->upper_bins) != 0;\r\nif (is_ctl && is_ext) {\r\nint mag_lower = fft_max_magnitude(fft->lower_bins);\r\nint mag_upper = fft_max_magnitude(fft->upper_bins);\r\nif (mag_upper > mag_lower)\r\nis_ctl = false;\r\nelse\r\nis_ext = false;\r\n}\r\n}\r\nif (is_ctl)\r\nreturn fft_max_index(fft->lower_bins);\r\nreturn fft_max_index(fft->upper_bins) + DFS_UPPER_BIN_OFFSET;\r\n}\r\nstatic bool ath9k_check_chirping(struct ath_softc *sc, u8 *data,\r\nint datalen, bool is_ctl, bool is_ext)\r\n{\r\nint i;\r\nint max_bin[FFT_NUM_SAMPLES];\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint prev_delta;\r\nif (IS_CHAN_HT40(ah->curchan)) {\r\nstruct ath9k_dfs_fft_40 *fft = (struct ath9k_dfs_fft_40 *) data;\r\nint num_fft_packets = datalen / sizeof(*fft);\r\nif (num_fft_packets == 0)\r\nreturn false;\r\nath_dbg(common, DFS, "HT40: datalen=%d, num_fft_packets=%d\n",\r\ndatalen, num_fft_packets);\r\nif (num_fft_packets < (FFT_NUM_SAMPLES)) {\r\nath_dbg(common, DFS, "not enough packets for chirp\n");\r\nreturn false;\r\n}\r\nif ((datalen % sizeof(*fft)) == 2) {\r\nfft = (struct ath9k_dfs_fft_40 *) (data + 2);\r\nath_dbg(common, DFS, "fixing datalen by 2\n");\r\n}\r\nif (IS_CHAN_HT40MINUS(ah->curchan)) {\r\nint temp = is_ctl;\r\nis_ctl = is_ext;\r\nis_ext = temp;\r\n}\r\nfor (i = 0; i < FFT_NUM_SAMPLES; i++)\r\nmax_bin[i] = ath9k_get_max_index_ht40(fft + i, is_ctl,\r\nis_ext);\r\n} else {\r\nstruct ath9k_dfs_fft_20 *fft = (struct ath9k_dfs_fft_20 *) data;\r\nint num_fft_packets = datalen / sizeof(*fft);\r\nif (num_fft_packets == 0)\r\nreturn false;\r\nath_dbg(common, DFS, "HT20: datalen=%d, num_fft_packets=%d\n",\r\ndatalen, num_fft_packets);\r\nif (num_fft_packets < (FFT_NUM_SAMPLES)) {\r\nath_dbg(common, DFS, "not enough packets for chirp\n");\r\nreturn false;\r\n}\r\nfor (i = 0; i < FFT_NUM_SAMPLES; i++)\r\nmax_bin[i] = fft_max_index(fft[i].lower_bins) ^ 0x20;\r\n}\r\nath_dbg(common, DFS, "bin_max = [%d, %d, %d, %d]\n",\r\nmax_bin[0], max_bin[1], max_bin[2], max_bin[3]);\r\nprev_delta = 0;\r\nfor (i = 0; i < NUM_DIFFS; i++) {\r\nint ddelta = -1;\r\nint delta = max_bin[i + 1] - max_bin[i];\r\nif (abs(delta) < BIN_DELTA_MIN || abs(delta) > BIN_DELTA_MAX) {\r\nath_dbg(common, DFS, "CHIRP: invalid delta %d "\r\n"in sample %d\n", delta, i);\r\nreturn false;\r\n}\r\nif (i == 0)\r\ngoto done;\r\nddelta = delta - prev_delta;\r\nif (abs(ddelta) > MAX_DIFF) {\r\nath_dbg(common, DFS, "CHIRP: ddelta %d too high\n",\r\nddelta);\r\nreturn false;\r\n}\r\ndone:\r\nath_dbg(common, DFS, "CHIRP - %d: delta=%d, ddelta=%d\n",\r\ni, delta, ddelta);\r\nprev_delta = delta;\r\n}\r\nreturn true;\r\n}\r\nstatic u32 dur_to_usecs(struct ath_hw *ah, u32 dur)\r\n{\r\nconst u32 AR93X_NSECS_PER_DUR = 800;\r\nconst u32 AR93X_NSECS_PER_DUR_FAST = (8000 / 11);\r\nu32 nsecs;\r\nif (IS_CHAN_A_FAST_CLOCK(ah, ah->curchan))\r\nnsecs = dur * AR93X_NSECS_PER_DUR_FAST;\r\nelse\r\nnsecs = dur * AR93X_NSECS_PER_DUR;\r\nreturn (nsecs + 500) / 1000;\r\n}\r\nstatic bool\r\nath9k_postprocess_radar_event(struct ath_softc *sc,\r\nstruct ath_radar_data *ard,\r\nstruct pulse_event *pe)\r\n{\r\nu8 rssi;\r\nu16 dur;\r\nard->pulse_bw_info &= 0x03;\r\nswitch (ard->pulse_bw_info) {\r\ncase PRI_CH_RADAR_FOUND:\r\ndur = ard->pulse_length_pri;\r\nDFS_STAT_INC(sc, pri_phy_errors);\r\nrssi = (ard->ext_rssi >= (ard->rssi + 3)) ? 0 : ard->rssi;\r\nbreak;\r\ncase EXT_CH_RADAR_FOUND:\r\ndur = ard->pulse_length_ext;\r\nDFS_STAT_INC(sc, ext_phy_errors);\r\nrssi = (ard->rssi >= (ard->ext_rssi + 12)) ? 0 : ard->ext_rssi;\r\nbreak;\r\ncase (PRI_CH_RADAR_FOUND | EXT_CH_RADAR_FOUND):\r\nif (ard->pulse_length_ext >= ard->pulse_length_pri)\r\ndur = ard->pulse_length_ext;\r\nelse\r\ndur = ard->pulse_length_pri;\r\nDFS_STAT_INC(sc, dc_phy_errors);\r\nrssi = (ard->rssi < ard->ext_rssi) ? ard->ext_rssi : ard->rssi;\r\nbreak;\r\ndefault:\r\nDFS_STAT_INC(sc, bwinfo_discards);\r\nreturn false;\r\n}\r\nif (rssi == 0) {\r\nDFS_STAT_INC(sc, rssi_discards);\r\nreturn false;\r\n}\r\npe->width = dur_to_usecs(sc->sc_ah, dur);\r\npe->rssi = rssi;\r\nDFS_STAT_INC(sc, pulses_detected);\r\nreturn true;\r\n}\r\nstatic void\r\nath9k_dfs_process_radar_pulse(struct ath_softc *sc, struct pulse_event *pe)\r\n{\r\nstruct dfs_pattern_detector *pd = sc->dfs_detector;\r\nDFS_STAT_INC(sc, pulses_processed);\r\nif (pd == NULL)\r\nreturn;\r\nif (!pd->add_pulse(pd, pe))\r\nreturn;\r\nDFS_STAT_INC(sc, radar_detected);\r\nieee80211_radar_detected(sc->hw);\r\n}\r\nvoid ath9k_dfs_process_phyerr(struct ath_softc *sc, void *data,\r\nstruct ath_rx_status *rs, u64 mactime)\r\n{\r\nstruct ath_radar_data ard;\r\nu16 datalen;\r\nchar *vdata_end;\r\nstruct pulse_event pe;\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nDFS_STAT_INC(sc, pulses_total);\r\nif ((rs->rs_phyerr != ATH9K_PHYERR_RADAR) &&\r\n(rs->rs_phyerr != ATH9K_PHYERR_FALSE_RADAR_EXT)) {\r\nath_dbg(common, DFS,\r\n"Error: rs_phyer=0x%x not a radar error\n",\r\nrs->rs_phyerr);\r\nDFS_STAT_INC(sc, pulses_no_dfs);\r\nreturn;\r\n}\r\ndatalen = rs->rs_datalen;\r\nif (datalen == 0) {\r\nDFS_STAT_INC(sc, datalen_discards);\r\nreturn;\r\n}\r\nard.rssi = rs->rs_rssi_ctl[0];\r\nard.ext_rssi = rs->rs_rssi_ext[0];\r\nif (ard.rssi & 0x80)\r\nard.rssi = 0;\r\nif (ard.ext_rssi & 0x80)\r\nard.ext_rssi = 0;\r\nvdata_end = (char *)data + datalen;\r\nard.pulse_bw_info = vdata_end[-1];\r\nard.pulse_length_ext = vdata_end[-2];\r\nard.pulse_length_pri = vdata_end[-3];\r\npe.freq = ah->curchan->channel;\r\npe.ts = mactime;\r\nif (!ath9k_postprocess_radar_event(sc, &ard, &pe))\r\nreturn;\r\nif (pe.width > MIN_CHIRP_PULSE_WIDTH &&\r\npe.width < MAX_CHIRP_PULSE_WIDTH) {\r\nbool is_ctl = !!(ard.pulse_bw_info & PRI_CH_RADAR_FOUND);\r\nbool is_ext = !!(ard.pulse_bw_info & EXT_CH_RADAR_FOUND);\r\nint clen = datalen - 3;\r\npe.chirp = ath9k_check_chirping(sc, data, clen, is_ctl, is_ext);\r\n} else {\r\npe.chirp = false;\r\n}\r\nath_dbg(common, DFS,\r\n"ath9k_dfs_process_phyerr: type=%d, freq=%d, ts=%llu, "\r\n"width=%d, rssi=%d, delta_ts=%llu\n",\r\nard.pulse_bw_info, pe.freq, pe.ts, pe.width, pe.rssi,\r\npe.ts - sc->dfs_prev_pulse_ts);\r\nsc->dfs_prev_pulse_ts = pe.ts;\r\nif (ard.pulse_bw_info & PRI_CH_RADAR_FOUND)\r\nath9k_dfs_process_radar_pulse(sc, &pe);\r\nif (IS_CHAN_HT40(ah->curchan) &&\r\nard.pulse_bw_info & EXT_CH_RADAR_FOUND) {\r\npe.freq += IS_CHAN_HT40PLUS(ah->curchan) ? 20 : -20;\r\nath9k_dfs_process_radar_pulse(sc, &pe);\r\n}\r\n}
