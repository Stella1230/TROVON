static void uniphier_fi2c_fill_txfifo(struct uniphier_fi2c_priv *priv,\r\nbool first)\r\n{\r\nint fifo_space = UNIPHIER_FI2C_FIFO_SIZE;\r\nif (first)\r\nfifo_space--;\r\nwhile (priv->len) {\r\nif (fifo_space-- <= 0)\r\nbreak;\r\ndev_dbg(&priv->adap.dev, "write data: %02x\n", *priv->buf);\r\nwritel(*priv->buf++, priv->membase + UNIPHIER_FI2C_DTTX);\r\npriv->len--;\r\n}\r\n}\r\nstatic void uniphier_fi2c_drain_rxfifo(struct uniphier_fi2c_priv *priv)\r\n{\r\nint fifo_left = priv->flags & UNIPHIER_FI2C_BYTE_WISE ?\r\n1 : UNIPHIER_FI2C_FIFO_SIZE;\r\nwhile (priv->len) {\r\nif (fifo_left-- <= 0)\r\nbreak;\r\n*priv->buf++ = readl(priv->membase + UNIPHIER_FI2C_DTRX);\r\ndev_dbg(&priv->adap.dev, "read data: %02x\n", priv->buf[-1]);\r\npriv->len--;\r\n}\r\n}\r\nstatic void uniphier_fi2c_set_irqs(struct uniphier_fi2c_priv *priv)\r\n{\r\nwritel(priv->enabled_irqs, priv->membase + UNIPHIER_FI2C_IE);\r\n}\r\nstatic void uniphier_fi2c_clear_irqs(struct uniphier_fi2c_priv *priv)\r\n{\r\nwritel(-1, priv->membase + UNIPHIER_FI2C_IC);\r\n}\r\nstatic void uniphier_fi2c_stop(struct uniphier_fi2c_priv *priv)\r\n{\r\ndev_dbg(&priv->adap.dev, "stop condition\n");\r\npriv->enabled_irqs |= UNIPHIER_FI2C_INT_STOP;\r\nuniphier_fi2c_set_irqs(priv);\r\nwritel(UNIPHIER_FI2C_CR_MST | UNIPHIER_FI2C_CR_STO,\r\npriv->membase + UNIPHIER_FI2C_CR);\r\n}\r\nstatic irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uniphier_fi2c_priv *priv = dev_id;\r\nu32 irq_status;\r\nirq_status = readl(priv->membase + UNIPHIER_FI2C_INT);\r\ndev_dbg(&priv->adap.dev,\r\n"interrupt: enabled_irqs=%04x, irq_status=%04x\n",\r\npriv->enabled_irqs, irq_status);\r\nif (irq_status & UNIPHIER_FI2C_INT_STOP)\r\ngoto complete;\r\nif (unlikely(irq_status & UNIPHIER_FI2C_INT_AL)) {\r\ndev_dbg(&priv->adap.dev, "arbitration lost\n");\r\npriv->error = -EAGAIN;\r\ngoto complete;\r\n}\r\nif (unlikely(irq_status & UNIPHIER_FI2C_INT_NA)) {\r\ndev_dbg(&priv->adap.dev, "could not get ACK\n");\r\npriv->error = -ENXIO;\r\nif (priv->flags & UNIPHIER_FI2C_RD) {\r\nuniphier_fi2c_stop(priv);\r\npriv->flags |= UNIPHIER_FI2C_DEFER_STOP_COMP;\r\ngoto complete;\r\n}\r\ngoto stop;\r\n}\r\nif (irq_status & UNIPHIER_FI2C_INT_TE) {\r\nif (!priv->len)\r\ngoto data_done;\r\nuniphier_fi2c_fill_txfifo(priv, false);\r\ngoto handled;\r\n}\r\nif (irq_status & (UNIPHIER_FI2C_INT_RF | UNIPHIER_FI2C_INT_RB)) {\r\nuniphier_fi2c_drain_rxfifo(priv);\r\nif (!priv->len)\r\ngoto data_done;\r\nif (unlikely(priv->flags & UNIPHIER_FI2C_MANUAL_NACK)) {\r\nif (priv->len <= UNIPHIER_FI2C_FIFO_SIZE &&\r\n!(priv->flags & UNIPHIER_FI2C_BYTE_WISE)) {\r\ndev_dbg(&priv->adap.dev,\r\n"enable read byte count IRQ\n");\r\npriv->enabled_irqs |= UNIPHIER_FI2C_INT_RB;\r\nuniphier_fi2c_set_irqs(priv);\r\npriv->flags |= UNIPHIER_FI2C_BYTE_WISE;\r\n}\r\nif (priv->len <= 1) {\r\ndev_dbg(&priv->adap.dev, "set NACK\n");\r\nwritel(UNIPHIER_FI2C_CR_MST |\r\nUNIPHIER_FI2C_CR_NACK,\r\npriv->membase + UNIPHIER_FI2C_CR);\r\n}\r\n}\r\ngoto handled;\r\n}\r\nreturn IRQ_NONE;\r\ndata_done:\r\nif (priv->flags & UNIPHIER_FI2C_STOP) {\r\nstop:\r\nuniphier_fi2c_stop(priv);\r\n} else {\r\ncomplete:\r\npriv->enabled_irqs = 0;\r\nuniphier_fi2c_set_irqs(priv);\r\ncomplete(&priv->comp);\r\n}\r\nhandled:\r\nuniphier_fi2c_clear_irqs(priv);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void uniphier_fi2c_tx_init(struct uniphier_fi2c_priv *priv, u16 addr)\r\n{\r\npriv->enabled_irqs |= UNIPHIER_FI2C_INT_TE;\r\nwritel(0, priv->membase + UNIPHIER_FI2C_TBC);\r\nwritel(UNIPHIER_FI2C_DTTX_CMD | addr << 1,\r\npriv->membase + UNIPHIER_FI2C_DTTX);\r\nuniphier_fi2c_fill_txfifo(priv, true);\r\n}\r\nstatic void uniphier_fi2c_rx_init(struct uniphier_fi2c_priv *priv, u16 addr)\r\n{\r\npriv->flags |= UNIPHIER_FI2C_RD;\r\nif (likely(priv->len < 256)) {\r\nwritel(priv->len, priv->membase + UNIPHIER_FI2C_RBC);\r\npriv->enabled_irqs |= UNIPHIER_FI2C_INT_RF |\r\nUNIPHIER_FI2C_INT_RB;\r\n} else {\r\nwritel(0, priv->membase + UNIPHIER_FI2C_RBC);\r\npriv->flags |= UNIPHIER_FI2C_MANUAL_NACK;\r\npriv->enabled_irqs |= UNIPHIER_FI2C_INT_RF;\r\n}\r\nwritel(UNIPHIER_FI2C_DTTX_CMD | UNIPHIER_FI2C_DTTX_RD | addr << 1,\r\npriv->membase + UNIPHIER_FI2C_DTTX);\r\n}\r\nstatic void uniphier_fi2c_reset(struct uniphier_fi2c_priv *priv)\r\n{\r\nwritel(UNIPHIER_FI2C_RST_RST, priv->membase + UNIPHIER_FI2C_RST);\r\n}\r\nstatic void uniphier_fi2c_prepare_operation(struct uniphier_fi2c_priv *priv)\r\n{\r\nwritel(UNIPHIER_FI2C_BRST_FOEN | UNIPHIER_FI2C_BRST_RSCL,\r\npriv->membase + UNIPHIER_FI2C_BRST);\r\n}\r\nstatic void uniphier_fi2c_recover(struct uniphier_fi2c_priv *priv)\r\n{\r\nuniphier_fi2c_reset(priv);\r\ni2c_recover_bus(&priv->adap);\r\n}\r\nstatic int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,\r\nstruct i2c_msg *msg, bool stop)\r\n{\r\nstruct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);\r\nbool is_read = msg->flags & I2C_M_RD;\r\nunsigned long time_left;\r\ndev_dbg(&adap->dev, "%s: addr=0x%02x, len=%d, stop=%d\n",\r\nis_read ? "receive" : "transmit", msg->addr, msg->len, stop);\r\npriv->len = msg->len;\r\npriv->buf = msg->buf;\r\npriv->enabled_irqs = UNIPHIER_FI2C_INT_FAULTS;\r\npriv->error = 0;\r\npriv->flags = 0;\r\nif (stop)\r\npriv->flags |= UNIPHIER_FI2C_STOP;\r\nreinit_completion(&priv->comp);\r\nuniphier_fi2c_clear_irqs(priv);\r\nwritel(UNIPHIER_FI2C_RST_TBRST | UNIPHIER_FI2C_RST_RBRST,\r\npriv->membase + UNIPHIER_FI2C_RST);\r\nif (is_read)\r\nuniphier_fi2c_rx_init(priv, msg->addr);\r\nelse\r\nuniphier_fi2c_tx_init(priv, msg->addr);\r\nuniphier_fi2c_set_irqs(priv);\r\ndev_dbg(&adap->dev, "start condition\n");\r\nwritel(UNIPHIER_FI2C_CR_MST | UNIPHIER_FI2C_CR_STA,\r\npriv->membase + UNIPHIER_FI2C_CR);\r\ntime_left = wait_for_completion_timeout(&priv->comp, adap->timeout);\r\nif (!time_left) {\r\ndev_err(&adap->dev, "transaction timeout.\n");\r\nuniphier_fi2c_recover(priv);\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_dbg(&adap->dev, "complete\n");\r\nif (unlikely(priv->flags & UNIPHIER_FI2C_DEFER_STOP_COMP)) {\r\nu32 status = readl(priv->membase + UNIPHIER_FI2C_SR);\r\nif (!(status & UNIPHIER_FI2C_SR_STS) ||\r\nstatus & UNIPHIER_FI2C_SR_BB) {\r\ndev_err(&adap->dev,\r\n"stop condition was not completed.\n");\r\nuniphier_fi2c_recover(priv);\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn priv->error;\r\n}\r\nstatic int uniphier_fi2c_check_bus_busy(struct i2c_adapter *adap)\r\n{\r\nstruct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);\r\nif (readl(priv->membase + UNIPHIER_FI2C_SR) & UNIPHIER_FI2C_SR_DB) {\r\nif (priv->busy_cnt++ > 3) {\r\nuniphier_fi2c_recover(priv);\r\npriv->busy_cnt = 0;\r\n}\r\nreturn -EAGAIN;\r\n}\r\npriv->busy_cnt = 0;\r\nreturn 0;\r\n}\r\nstatic int uniphier_fi2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct i2c_msg *msg, *emsg = msgs + num;\r\nint ret;\r\nret = uniphier_fi2c_check_bus_busy(adap);\r\nif (ret)\r\nreturn ret;\r\nfor (msg = msgs; msg < emsg; msg++) {\r\nbool stop = !(msg + 1 < emsg && msg[1].flags & I2C_M_RD);\r\nif (msg->flags & I2C_M_STOP)\r\nstop = true;\r\nret = uniphier_fi2c_master_xfer_one(adap, msg, stop);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn num;\r\n}\r\nstatic u32 uniphier_fi2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int uniphier_fi2c_get_scl(struct i2c_adapter *adap)\r\n{\r\nstruct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);\r\nreturn !!(readl(priv->membase + UNIPHIER_FI2C_BM) &\r\nUNIPHIER_FI2C_BM_SCLS);\r\n}\r\nstatic void uniphier_fi2c_set_scl(struct i2c_adapter *adap, int val)\r\n{\r\nstruct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);\r\nwritel(val ? UNIPHIER_FI2C_BRST_RSCL : 0,\r\npriv->membase + UNIPHIER_FI2C_BRST);\r\n}\r\nstatic int uniphier_fi2c_get_sda(struct i2c_adapter *adap)\r\n{\r\nstruct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);\r\nreturn !!(readl(priv->membase + UNIPHIER_FI2C_BM) &\r\nUNIPHIER_FI2C_BM_SDAS);\r\n}\r\nstatic void uniphier_fi2c_unprepare_recovery(struct i2c_adapter *adap)\r\n{\r\nuniphier_fi2c_prepare_operation(i2c_get_adapdata(adap));\r\n}\r\nstatic int uniphier_fi2c_clk_init(struct device *dev,\r\nstruct uniphier_fi2c_priv *priv)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nunsigned long clk_rate;\r\nu32 bus_speed, clk_count;\r\nint ret;\r\nif (of_property_read_u32(np, "clock-frequency", &bus_speed))\r\nbus_speed = UNIPHIER_FI2C_DEFAULT_SPEED;\r\nif (!bus_speed) {\r\ndev_err(dev, "clock-frequency should not be zero\n");\r\nreturn -EINVAL;\r\n}\r\nif (bus_speed > UNIPHIER_FI2C_MAX_SPEED)\r\nbus_speed = UNIPHIER_FI2C_MAX_SPEED;\r\npriv->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(dev, "failed to get clock\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret)\r\nreturn ret;\r\nclk_rate = clk_get_rate(priv->clk);\r\nif (!clk_rate) {\r\ndev_err(dev, "input clock rate should not be zero\n");\r\nreturn -EINVAL;\r\n}\r\nuniphier_fi2c_reset(priv);\r\nclk_count = clk_rate / bus_speed;\r\nwritel(clk_count, priv->membase + UNIPHIER_FI2C_CYC);\r\nwritel(clk_count / 2, priv->membase + UNIPHIER_FI2C_LCTL);\r\nwritel(clk_count / 2, priv->membase + UNIPHIER_FI2C_SSUT);\r\nwritel(clk_count / 16, priv->membase + UNIPHIER_FI2C_DSUT);\r\nuniphier_fi2c_prepare_operation(priv);\r\nreturn 0;\r\n}\r\nstatic int uniphier_fi2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct uniphier_fi2c_priv *priv;\r\nstruct resource *regs;\r\nint irq;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->membase = devm_ioremap_resource(dev, regs);\r\nif (IS_ERR(priv->membase))\r\nreturn PTR_ERR(priv->membase);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "failed to get IRQ number\n");\r\nreturn irq;\r\n}\r\ninit_completion(&priv->comp);\r\npriv->adap.owner = THIS_MODULE;\r\npriv->adap.algo = &uniphier_fi2c_algo;\r\npriv->adap.dev.parent = dev;\r\npriv->adap.dev.of_node = dev->of_node;\r\nstrlcpy(priv->adap.name, "UniPhier FI2C", sizeof(priv->adap.name));\r\npriv->adap.bus_recovery_info = &uniphier_fi2c_bus_recovery_info;\r\ni2c_set_adapdata(&priv->adap, priv);\r\nplatform_set_drvdata(pdev, priv);\r\nret = uniphier_fi2c_clk_init(dev, priv);\r\nif (ret)\r\ngoto err;\r\nret = devm_request_irq(dev, irq, uniphier_fi2c_interrupt, 0,\r\npdev->name, priv);\r\nif (ret) {\r\ndev_err(dev, "failed to request irq %d\n", irq);\r\ngoto err;\r\n}\r\nret = i2c_add_adapter(&priv->adap);\r\nif (ret) {\r\ndev_err(dev, "failed to add I2C adapter\n");\r\ngoto err;\r\n}\r\nerr:\r\nif (ret)\r\nclk_disable_unprepare(priv->clk);\r\nreturn ret;\r\n}\r\nstatic int uniphier_fi2c_remove(struct platform_device *pdev)\r\n{\r\nstruct uniphier_fi2c_priv *priv = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&priv->adap);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}
