static inline unsigned int sio_in(struct uart_txx9_port *up, int offset)\r\n{\r\nswitch (up->port.iotype) {\r\ndefault:\r\nreturn __raw_readl(up->port.membase + offset);\r\ncase UPIO_PORT:\r\nreturn inl(up->port.iobase + offset);\r\n}\r\n}\r\nstatic inline void\r\nsio_out(struct uart_txx9_port *up, int offset, int value)\r\n{\r\nswitch (up->port.iotype) {\r\ndefault:\r\n__raw_writel(value, up->port.membase + offset);\r\nbreak;\r\ncase UPIO_PORT:\r\noutl(value, up->port.iobase + offset);\r\nbreak;\r\n}\r\n}\r\nstatic inline void\r\nsio_mask(struct uart_txx9_port *up, int offset, unsigned int value)\r\n{\r\nsio_out(up, offset, sio_in(up, offset) & ~value);\r\n}\r\nstatic inline void\r\nsio_set(struct uart_txx9_port *up, int offset, unsigned int value)\r\n{\r\nsio_out(up, offset, sio_in(up, offset) | value);\r\n}\r\nstatic inline void\r\nsio_quot_set(struct uart_txx9_port *up, int quot)\r\n{\r\nquot >>= 1;\r\nif (quot < 256)\r\nsio_out(up, TXX9_SIBGR, quot | TXX9_SIBGR_BCLK_T0);\r\nelse if (quot < (256 << 2))\r\nsio_out(up, TXX9_SIBGR, (quot >> 2) | TXX9_SIBGR_BCLK_T2);\r\nelse if (quot < (256 << 4))\r\nsio_out(up, TXX9_SIBGR, (quot >> 4) | TXX9_SIBGR_BCLK_T4);\r\nelse if (quot < (256 << 6))\r\nsio_out(up, TXX9_SIBGR, (quot >> 6) | TXX9_SIBGR_BCLK_T6);\r\nelse\r\nsio_out(up, TXX9_SIBGR, 0xff | TXX9_SIBGR_BCLK_T6);\r\n}\r\nstatic struct uart_txx9_port *to_uart_txx9_port(struct uart_port *port)\r\n{\r\nreturn container_of(port, struct uart_txx9_port, port);\r\n}\r\nstatic void serial_txx9_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nsio_mask(up, TXX9_SIDICR, TXX9_SIDICR_TIE);\r\n}\r\nstatic void serial_txx9_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nsio_set(up, TXX9_SIDICR, TXX9_SIDICR_TIE);\r\n}\r\nstatic void serial_txx9_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nup->port.read_status_mask &= ~TXX9_SIDISR_RDIS;\r\n}\r\nstatic void serial_txx9_initialize(struct uart_port *port)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nunsigned int tmout = 10000;\r\nsio_out(up, TXX9_SIFCR, TXX9_SIFCR_SWRST);\r\nmmiowb();\r\nudelay(1);\r\nwhile ((sio_in(up, TXX9_SIFCR) & TXX9_SIFCR_SWRST) && --tmout)\r\nudelay(1);\r\nsio_set(up, TXX9_SIFCR,\r\nTXX9_SIFCR_TDIL_MAX | TXX9_SIFCR_RDIL_1);\r\nsio_out(up, TXX9_SILCR,\r\nTXX9_SILCR_UMODE_8BIT | TXX9_SILCR_USBL_1BIT |\r\n((up->port.flags & UPF_TXX9_USE_SCLK) ?\r\nTXX9_SILCR_SCS_SCLK_BG : TXX9_SILCR_SCS_IMCLK_BG));\r\nsio_quot_set(up, uart_get_divisor(port, 9600));\r\nsio_out(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSTL_MAX );\r\nsio_out(up, TXX9_SIDICR, 0);\r\n}\r\nstatic inline void\r\nreceive_chars(struct uart_txx9_port *up, unsigned int *status)\r\n{\r\nunsigned char ch;\r\nunsigned int disr = *status;\r\nint max_count = 256;\r\nchar flag;\r\nunsigned int next_ignore_status_mask;\r\ndo {\r\nch = sio_in(up, TXX9_SIRFIFO);\r\nflag = TTY_NORMAL;\r\nup->port.icount.rx++;\r\nnext_ignore_status_mask =\r\nup->port.ignore_status_mask & ~TXX9_SIDISR_RFDN_MASK;\r\nif (unlikely(disr & (TXX9_SIDISR_UBRK | TXX9_SIDISR_UPER |\r\nTXX9_SIDISR_UFER | TXX9_SIDISR_UOER))) {\r\nif (disr & TXX9_SIDISR_UBRK) {\r\ndisr &= ~(TXX9_SIDISR_UFER | TXX9_SIDISR_UPER);\r\nup->port.icount.brk++;\r\nif (uart_handle_break(&up->port))\r\ngoto ignore_char;\r\n} else if (disr & TXX9_SIDISR_UPER)\r\nup->port.icount.parity++;\r\nelse if (disr & TXX9_SIDISR_UFER)\r\nup->port.icount.frame++;\r\nif (disr & TXX9_SIDISR_UOER) {\r\nup->port.icount.overrun++;\r\nnext_ignore_status_mask |=\r\nTXX9_SIDISR_RFDN_MASK;\r\n}\r\ndisr &= up->port.read_status_mask;\r\nif (disr & TXX9_SIDISR_UBRK) {\r\nflag = TTY_BREAK;\r\n} else if (disr & TXX9_SIDISR_UPER)\r\nflag = TTY_PARITY;\r\nelse if (disr & TXX9_SIDISR_UFER)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&up->port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(&up->port, disr, TXX9_SIDISR_UOER, ch, flag);\r\nignore_char:\r\nup->port.ignore_status_mask = next_ignore_status_mask;\r\ndisr = sio_in(up, TXX9_SIDISR);\r\n} while (!(disr & TXX9_SIDISR_UVALID) && (max_count-- > 0));\r\nspin_unlock(&up->port.lock);\r\ntty_flip_buffer_push(&up->port.state->port);\r\nspin_lock(&up->port.lock);\r\n*status = disr;\r\n}\r\nstatic inline void transmit_chars(struct uart_txx9_port *up)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nint count;\r\nif (up->port.x_char) {\r\nsio_out(up, TXX9_SITFIFO, up->port.x_char);\r\nup->port.icount.tx++;\r\nup->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {\r\nserial_txx9_stop_tx(&up->port);\r\nreturn;\r\n}\r\ncount = TXX9_SIO_TX_FIFO;\r\ndo {\r\nsio_out(up, TXX9_SITFIFO, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nif (uart_circ_empty(xmit))\r\nserial_txx9_stop_tx(&up->port);\r\n}\r\nstatic irqreturn_t serial_txx9_interrupt(int irq, void *dev_id)\r\n{\r\nint pass_counter = 0;\r\nstruct uart_txx9_port *up = dev_id;\r\nunsigned int status;\r\nwhile (1) {\r\nspin_lock(&up->port.lock);\r\nstatus = sio_in(up, TXX9_SIDISR);\r\nif (!(sio_in(up, TXX9_SIDICR) & TXX9_SIDICR_TIE))\r\nstatus &= ~TXX9_SIDISR_TDIS;\r\nif (!(status & (TXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS |\r\nTXX9_SIDISR_TOUT))) {\r\nspin_unlock(&up->port.lock);\r\nbreak;\r\n}\r\nif (status & TXX9_SIDISR_RDIS)\r\nreceive_chars(up, &status);\r\nif (status & TXX9_SIDISR_TDIS)\r\ntransmit_chars(up);\r\nsio_mask(up, TXX9_SIDISR,\r\nTXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS |\r\nTXX9_SIDISR_TOUT);\r\nspin_unlock(&up->port.lock);\r\nif (pass_counter++ > PASS_LIMIT)\r\nbreak;\r\n}\r\nreturn pass_counter ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic unsigned int serial_txx9_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nunsigned long flags;\r\nunsigned int ret;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nret = (sio_in(up, TXX9_SICISR) & TXX9_SICISR_TXALS) ? TIOCSER_TEMT : 0;\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn ret;\r\n}\r\nstatic unsigned int serial_txx9_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nunsigned int ret;\r\nret = TIOCM_CAR | TIOCM_DSR;\r\nret |= (sio_in(up, TXX9_SIFLCR) & TXX9_SIFLCR_RTSSC) ? 0 : TIOCM_RTS;\r\nret |= (sio_in(up, TXX9_SICISR) & TXX9_SICISR_CTSS) ? 0 : TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void serial_txx9_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nif (mctrl & TIOCM_RTS)\r\nsio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSSC);\r\nelse\r\nsio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSSC);\r\n}\r\nstatic void serial_txx9_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (break_state == -1)\r\nsio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);\r\nelse\r\nsio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic void wait_for_xmitr(struct uart_txx9_port *up)\r\n{\r\nunsigned int tmout = 10000;\r\nwhile (--tmout &&\r\n!(sio_in(up, TXX9_SICISR) & TXX9_SICISR_TXALS))\r\nudelay(1);\r\nif (up->port.flags & UPF_CONS_FLOW) {\r\ntmout = 1000000;\r\nwhile (--tmout &&\r\n(sio_in(up, TXX9_SICISR) & TXX9_SICISR_CTSS))\r\nudelay(1);\r\n}\r\n}\r\nstatic int serial_txx9_get_poll_char(struct uart_port *port)\r\n{\r\nunsigned int ier;\r\nunsigned char c;\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nier = sio_in(up, TXX9_SIDICR);\r\nsio_out(up, TXX9_SIDICR, 0);\r\nwhile (sio_in(up, TXX9_SIDISR) & TXX9_SIDISR_UVALID)\r\n;\r\nc = sio_in(up, TXX9_SIRFIFO);\r\nsio_mask(up, TXX9_SIDISR, TXX9_SIDISR_RDIS);\r\nsio_out(up, TXX9_SIDICR, ier);\r\nreturn c;\r\n}\r\nstatic void serial_txx9_put_poll_char(struct uart_port *port, unsigned char c)\r\n{\r\nunsigned int ier;\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nier = sio_in(up, TXX9_SIDICR);\r\nsio_out(up, TXX9_SIDICR, 0);\r\nwait_for_xmitr(up);\r\nsio_out(up, TXX9_SITFIFO, c);\r\nwait_for_xmitr(up);\r\nsio_out(up, TXX9_SIDICR, ier);\r\n}\r\nstatic int serial_txx9_startup(struct uart_port *port)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nunsigned long flags;\r\nint retval;\r\nsio_set(up, TXX9_SIFCR,\r\nTXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);\r\nsio_mask(up, TXX9_SIFCR,\r\nTXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);\r\nsio_out(up, TXX9_SIDICR, 0);\r\nsio_out(up, TXX9_SIDISR, 0);\r\nretval = request_irq(up->port.irq, serial_txx9_interrupt,\r\nIRQF_SHARED, "serial_txx9", up);\r\nif (retval)\r\nreturn retval;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nserial_txx9_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nsio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_RSDE | TXX9_SIFLCR_TSDE);\r\nsio_set(up, TXX9_SIDICR, TXX9_SIDICR_RIE);\r\nreturn 0;\r\n}\r\nstatic void serial_txx9_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nunsigned long flags;\r\nsio_out(up, TXX9_SIDICR, 0);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nserial_txx9_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nsio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);\r\n#ifdef CONFIG_SERIAL_TXX9_CONSOLE\r\nif (up->port.cons && up->port.line == up->port.cons->index) {\r\nfree_irq(up->port.irq, up);\r\nreturn;\r\n}\r\n#endif\r\nsio_set(up, TXX9_SIFCR,\r\nTXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);\r\nsio_mask(up, TXX9_SIFCR,\r\nTXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);\r\nsio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_RSDE | TXX9_SIFLCR_TSDE);\r\nfree_irq(up->port.irq, up);\r\n}\r\nstatic void\r\nserial_txx9_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nunsigned int cval, fcr = 0;\r\nunsigned long flags;\r\nunsigned int baud, quot;\r\ntermios->c_cflag &= ~(HUPCL | CMSPAR);\r\ntermios->c_cflag |= CLOCAL;\r\ncval = sio_in(up, TXX9_SILCR);\r\ncval &= ~TXX9_SILCR_UMODE_MASK;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS7:\r\ncval |= TXX9_SILCR_UMODE_7BIT;\r\nbreak;\r\ndefault:\r\ncase CS5:\r\ncase CS6:\r\ncase CS8:\r\ncval |= TXX9_SILCR_UMODE_8BIT;\r\nbreak;\r\n}\r\ncval &= ~TXX9_SILCR_USBL_MASK;\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= TXX9_SILCR_USBL_2BIT;\r\nelse\r\ncval |= TXX9_SILCR_USBL_1BIT;\r\ncval &= ~(TXX9_SILCR_UPEN | TXX9_SILCR_UEPS);\r\nif (termios->c_cflag & PARENB)\r\ncval |= TXX9_SILCR_UPEN;\r\nif (!(termios->c_cflag & PARODD))\r\ncval |= TXX9_SILCR_UEPS;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16/2);\r\nquot = uart_get_divisor(port, baud);\r\nfcr = TXX9_SIFCR_TDIL_MAX | TXX9_SIFCR_RDIL_1;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nup->port.read_status_mask = TXX9_SIDISR_UOER |\r\nTXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS;\r\nif (termios->c_iflag & INPCK)\r\nup->port.read_status_mask |= TXX9_SIDISR_UFER | TXX9_SIDISR_UPER;\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nup->port.read_status_mask |= TXX9_SIDISR_UBRK;\r\nup->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= TXX9_SIDISR_UPER | TXX9_SIDISR_UFER;\r\nif (termios->c_iflag & IGNBRK) {\r\nup->port.ignore_status_mask |= TXX9_SIDISR_UBRK;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= TXX9_SIDISR_UOER;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nup->port.ignore_status_mask |= TXX9_SIDISR_RDIS;\r\nif ((termios->c_cflag & CRTSCTS) &&\r\n(up->port.flags & UPF_TXX9_HAVE_CTS_LINE)) {\r\nsio_set(up, TXX9_SIFLCR,\r\nTXX9_SIFLCR_RCS | TXX9_SIFLCR_TES);\r\n} else {\r\nsio_mask(up, TXX9_SIFLCR,\r\nTXX9_SIFLCR_RCS | TXX9_SIFLCR_TES);\r\n}\r\nsio_out(up, TXX9_SILCR, cval);\r\nsio_quot_set(up, quot);\r\nsio_out(up, TXX9_SIFCR, fcr);\r\nserial_txx9_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic void\r\nserial_txx9_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nif (state == 0 && oldstate != -1)\r\nserial_txx9_initialize(port);\r\n}\r\nstatic int serial_txx9_request_resource(struct uart_txx9_port *up)\r\n{\r\nunsigned int size = TXX9_REGION_SIZE;\r\nint ret = 0;\r\nswitch (up->port.iotype) {\r\ndefault:\r\nif (!up->port.mapbase)\r\nbreak;\r\nif (!request_mem_region(up->port.mapbase, size, "serial_txx9")) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nif (up->port.flags & UPF_IOREMAP) {\r\nup->port.membase = ioremap(up->port.mapbase, size);\r\nif (!up->port.membase) {\r\nrelease_mem_region(up->port.mapbase, size);\r\nret = -ENOMEM;\r\n}\r\n}\r\nbreak;\r\ncase UPIO_PORT:\r\nif (!request_region(up->port.iobase, size, "serial_txx9"))\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void serial_txx9_release_resource(struct uart_txx9_port *up)\r\n{\r\nunsigned int size = TXX9_REGION_SIZE;\r\nswitch (up->port.iotype) {\r\ndefault:\r\nif (!up->port.mapbase)\r\nbreak;\r\nif (up->port.flags & UPF_IOREMAP) {\r\niounmap(up->port.membase);\r\nup->port.membase = NULL;\r\n}\r\nrelease_mem_region(up->port.mapbase, size);\r\nbreak;\r\ncase UPIO_PORT:\r\nrelease_region(up->port.iobase, size);\r\nbreak;\r\n}\r\n}\r\nstatic void serial_txx9_release_port(struct uart_port *port)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nserial_txx9_release_resource(up);\r\n}\r\nstatic int serial_txx9_request_port(struct uart_port *port)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nreturn serial_txx9_request_resource(up);\r\n}\r\nstatic void serial_txx9_config_port(struct uart_port *port, int uflags)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nint ret;\r\nret = serial_txx9_request_resource(up);\r\nif (ret < 0)\r\nreturn;\r\nport->type = PORT_TXX9;\r\nup->port.fifosize = TXX9_SIO_TX_FIFO;\r\n#ifdef CONFIG_SERIAL_TXX9_CONSOLE\r\nif (up->port.line == up->port.cons->index)\r\nreturn;\r\n#endif\r\nserial_txx9_initialize(port);\r\n}\r\nstatic const char *\r\nserial_txx9_type(struct uart_port *port)\r\n{\r\nreturn "txx9";\r\n}\r\nstatic void __init serial_txx9_register_ports(struct uart_driver *drv,\r\nstruct device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < UART_NR; i++) {\r\nstruct uart_txx9_port *up = &serial_txx9_ports[i];\r\nup->port.line = i;\r\nup->port.ops = &serial_txx9_pops;\r\nup->port.dev = dev;\r\nif (up->port.iobase || up->port.mapbase)\r\nuart_add_one_port(drv, &up->port);\r\n}\r\n}\r\nstatic void serial_txx9_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_txx9_port *up = to_uart_txx9_port(port);\r\nwait_for_xmitr(up);\r\nsio_out(up, TXX9_SITFIFO, ch);\r\n}\r\nstatic void\r\nserial_txx9_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_txx9_port *up = &serial_txx9_ports[co->index];\r\nunsigned int ier, flcr;\r\nier = sio_in(up, TXX9_SIDICR);\r\nsio_out(up, TXX9_SIDICR, 0);\r\nflcr = sio_in(up, TXX9_SIFLCR);\r\nif (!(up->port.flags & UPF_CONS_FLOW) && (flcr & TXX9_SIFLCR_TES))\r\nsio_out(up, TXX9_SIFLCR, flcr & ~TXX9_SIFLCR_TES);\r\nuart_console_write(&up->port, s, count, serial_txx9_console_putchar);\r\nwait_for_xmitr(up);\r\nsio_out(up, TXX9_SIFLCR, flcr);\r\nsio_out(up, TXX9_SIDICR, ier);\r\n}\r\nstatic int __init serial_txx9_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nstruct uart_txx9_port *up;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index >= UART_NR)\r\nco->index = 0;\r\nup = &serial_txx9_ports[co->index];\r\nport = &up->port;\r\nif (!port->ops)\r\nreturn -ENODEV;\r\nserial_txx9_initialize(&up->port);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init serial_txx9_console_init(void)\r\n{\r\nregister_console(&serial_txx9_console);\r\nreturn 0;\r\n}\r\nint __init early_serial_txx9_setup(struct uart_port *port)\r\n{\r\nif (port->line >= ARRAY_SIZE(serial_txx9_ports))\r\nreturn -ENODEV;\r\nserial_txx9_ports[port->line].port = *port;\r\nserial_txx9_ports[port->line].port.ops = &serial_txx9_pops;\r\nserial_txx9_ports[port->line].port.flags |=\r\nUPF_BOOT_AUTOCONF | UPF_FIXED_PORT;\r\nreturn 0;\r\n}\r\nstatic int serial_txx9_register_port(struct uart_port *port)\r\n{\r\nint i;\r\nstruct uart_txx9_port *uart;\r\nint ret = -ENOSPC;\r\nmutex_lock(&serial_txx9_mutex);\r\nfor (i = 0; i < UART_NR; i++) {\r\nuart = &serial_txx9_ports[i];\r\nif (uart_match_port(&uart->port, port)) {\r\nuart_remove_one_port(&serial_txx9_reg, &uart->port);\r\nbreak;\r\n}\r\n}\r\nif (i == UART_NR) {\r\nfor (i = 0; i < UART_NR; i++) {\r\nuart = &serial_txx9_ports[i];\r\nif (!(uart->port.iobase || uart->port.mapbase))\r\nbreak;\r\n}\r\n}\r\nif (i < UART_NR) {\r\nuart->port.iobase = port->iobase;\r\nuart->port.membase = port->membase;\r\nuart->port.irq = port->irq;\r\nuart->port.uartclk = port->uartclk;\r\nuart->port.iotype = port->iotype;\r\nuart->port.flags = port->flags\r\n| UPF_BOOT_AUTOCONF | UPF_FIXED_PORT;\r\nuart->port.mapbase = port->mapbase;\r\nif (port->dev)\r\nuart->port.dev = port->dev;\r\nret = uart_add_one_port(&serial_txx9_reg, &uart->port);\r\nif (ret == 0)\r\nret = uart->port.line;\r\n}\r\nmutex_unlock(&serial_txx9_mutex);\r\nreturn ret;\r\n}\r\nstatic void serial_txx9_unregister_port(int line)\r\n{\r\nstruct uart_txx9_port *uart = &serial_txx9_ports[line];\r\nmutex_lock(&serial_txx9_mutex);\r\nuart_remove_one_port(&serial_txx9_reg, &uart->port);\r\nuart->port.flags = 0;\r\nuart->port.type = PORT_UNKNOWN;\r\nuart->port.iobase = 0;\r\nuart->port.mapbase = 0;\r\nuart->port.membase = NULL;\r\nuart->port.dev = NULL;\r\nmutex_unlock(&serial_txx9_mutex);\r\n}\r\nstatic int serial_txx9_probe(struct platform_device *dev)\r\n{\r\nstruct uart_port *p = dev_get_platdata(&dev->dev);\r\nstruct uart_port port;\r\nint ret, i;\r\nmemset(&port, 0, sizeof(struct uart_port));\r\nfor (i = 0; p && p->uartclk != 0; p++, i++) {\r\nport.iobase = p->iobase;\r\nport.membase = p->membase;\r\nport.irq = p->irq;\r\nport.uartclk = p->uartclk;\r\nport.iotype = p->iotype;\r\nport.flags = p->flags;\r\nport.mapbase = p->mapbase;\r\nport.dev = &dev->dev;\r\nret = serial_txx9_register_port(&port);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "unable to register port at index %d "\r\n"(IO%lx MEM%llx IRQ%d): %d\n", i,\r\np->iobase, (unsigned long long)p->mapbase,\r\np->irq, ret);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial_txx9_remove(struct platform_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < UART_NR; i++) {\r\nstruct uart_txx9_port *up = &serial_txx9_ports[i];\r\nif (up->port.dev == &dev->dev)\r\nserial_txx9_unregister_port(i);\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial_txx9_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nint i;\r\nfor (i = 0; i < UART_NR; i++) {\r\nstruct uart_txx9_port *up = &serial_txx9_ports[i];\r\nif (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)\r\nuart_suspend_port(&serial_txx9_reg, &up->port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial_txx9_resume(struct platform_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < UART_NR; i++) {\r\nstruct uart_txx9_port *up = &serial_txx9_ports[i];\r\nif (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)\r\nuart_resume_port(&serial_txx9_reg, &up->port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npciserial_txx9_init_one(struct pci_dev *dev, const struct pci_device_id *ent)\r\n{\r\nstruct uart_port port;\r\nint line;\r\nint rc;\r\nrc = pci_enable_device(dev);\r\nif (rc)\r\nreturn rc;\r\nmemset(&port, 0, sizeof(port));\r\nport.ops = &serial_txx9_pops;\r\nport.flags |= UPF_TXX9_HAVE_CTS_LINE;\r\nport.uartclk = 66670000;\r\nport.irq = dev->irq;\r\nport.iotype = UPIO_PORT;\r\nport.iobase = pci_resource_start(dev, 1);\r\nport.dev = &dev->dev;\r\nline = serial_txx9_register_port(&port);\r\nif (line < 0) {\r\nprintk(KERN_WARNING "Couldn't register serial port %s: %d\n", pci_name(dev), line);\r\npci_disable_device(dev);\r\nreturn line;\r\n}\r\npci_set_drvdata(dev, &serial_txx9_ports[line]);\r\nreturn 0;\r\n}\r\nstatic void pciserial_txx9_remove_one(struct pci_dev *dev)\r\n{\r\nstruct uart_txx9_port *up = pci_get_drvdata(dev);\r\nif (up) {\r\nserial_txx9_unregister_port(up->port.line);\r\npci_disable_device(dev);\r\n}\r\n}\r\nstatic int pciserial_txx9_suspend_one(struct pci_dev *dev, pm_message_t state)\r\n{\r\nstruct uart_txx9_port *up = pci_get_drvdata(dev);\r\nif (up)\r\nuart_suspend_port(&serial_txx9_reg, &up->port);\r\npci_save_state(dev);\r\npci_set_power_state(dev, pci_choose_state(dev, state));\r\nreturn 0;\r\n}\r\nstatic int pciserial_txx9_resume_one(struct pci_dev *dev)\r\n{\r\nstruct uart_txx9_port *up = pci_get_drvdata(dev);\r\npci_set_power_state(dev, PCI_D0);\r\npci_restore_state(dev);\r\nif (up)\r\nuart_resume_port(&serial_txx9_reg, &up->port);\r\nreturn 0;\r\n}\r\nstatic int __init serial_txx9_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "%s version %s\n", serial_name, serial_version);\r\nret = uart_register_driver(&serial_txx9_reg);\r\nif (ret)\r\ngoto out;\r\nserial_txx9_plat_devs = platform_device_alloc("serial_txx9", -1);\r\nif (!serial_txx9_plat_devs) {\r\nret = -ENOMEM;\r\ngoto unreg_uart_drv;\r\n}\r\nret = platform_device_add(serial_txx9_plat_devs);\r\nif (ret)\r\ngoto put_dev;\r\nserial_txx9_register_ports(&serial_txx9_reg,\r\n&serial_txx9_plat_devs->dev);\r\nret = platform_driver_register(&serial_txx9_plat_driver);\r\nif (ret)\r\ngoto del_dev;\r\n#ifdef ENABLE_SERIAL_TXX9_PCI\r\nret = pci_register_driver(&serial_txx9_pci_driver);\r\n#endif\r\nif (ret == 0)\r\ngoto out;\r\ndel_dev:\r\nplatform_device_del(serial_txx9_plat_devs);\r\nput_dev:\r\nplatform_device_put(serial_txx9_plat_devs);\r\nunreg_uart_drv:\r\nuart_unregister_driver(&serial_txx9_reg);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit serial_txx9_exit(void)\r\n{\r\nint i;\r\n#ifdef ENABLE_SERIAL_TXX9_PCI\r\npci_unregister_driver(&serial_txx9_pci_driver);\r\n#endif\r\nplatform_driver_unregister(&serial_txx9_plat_driver);\r\nplatform_device_unregister(serial_txx9_plat_devs);\r\nfor (i = 0; i < UART_NR; i++) {\r\nstruct uart_txx9_port *up = &serial_txx9_ports[i];\r\nif (up->port.iobase || up->port.mapbase)\r\nuart_remove_one_port(&serial_txx9_reg, &up->port);\r\n}\r\nuart_unregister_driver(&serial_txx9_reg);\r\n}
