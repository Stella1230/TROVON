static int v9fs_cached_dentry_delete(const struct dentry *dentry)\r\n{\r\np9_debug(P9_DEBUG_VFS, " dentry: %pd (%p)\n",\r\ndentry, dentry);\r\nif (d_really_is_negative(dentry))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void v9fs_dentry_release(struct dentry *dentry)\r\n{\r\nstruct hlist_node *p, *n;\r\np9_debug(P9_DEBUG_VFS, " dentry: %pd (%p)\n",\r\ndentry, dentry);\r\nhlist_for_each_safe(p, n, (struct hlist_head *)&dentry->d_fsdata)\r\np9_client_clunk(hlist_entry(p, struct p9_fid, dlist));\r\ndentry->d_fsdata = NULL;\r\n}\r\nstatic int v9fs_lookup_revalidate(struct dentry *dentry, unsigned int flags)\r\n{\r\nstruct p9_fid *fid;\r\nstruct inode *inode;\r\nstruct v9fs_inode *v9inode;\r\nif (flags & LOOKUP_RCU)\r\nreturn -ECHILD;\r\ninode = d_inode(dentry);\r\nif (!inode)\r\ngoto out_valid;\r\nv9inode = V9FS_I(inode);\r\nif (v9inode->cache_validity & V9FS_INO_INVALID_ATTR) {\r\nint retval;\r\nstruct v9fs_session_info *v9ses;\r\nfid = v9fs_fid_lookup(dentry);\r\nif (IS_ERR(fid))\r\nreturn PTR_ERR(fid);\r\nv9ses = v9fs_inode2v9ses(inode);\r\nif (v9fs_proto_dotl(v9ses))\r\nretval = v9fs_refresh_inode_dotl(fid, inode);\r\nelse\r\nretval = v9fs_refresh_inode(fid, inode);\r\nif (retval == -ENOENT)\r\nreturn 0;\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nout_valid:\r\nreturn 1;\r\n}
