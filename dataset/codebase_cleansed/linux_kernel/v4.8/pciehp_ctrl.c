void pciehp_queue_interrupt_event(struct slot *p_slot, u32 event_type)\r\n{\r\nstruct event_info *info;\r\ninfo = kmalloc(sizeof(*info), GFP_ATOMIC);\r\nif (!info) {\r\nctrl_err(p_slot->ctrl, "dropped event %d (ENOMEM)\n", event_type);\r\nreturn;\r\n}\r\nINIT_WORK(&info->work, interrupt_event_handler);\r\ninfo->event_type = event_type;\r\ninfo->p_slot = p_slot;\r\nqueue_work(p_slot->wq, &info->work);\r\n}\r\nstatic void set_slot_off(struct controller *ctrl, struct slot *pslot)\r\n{\r\nif (POWER_CTRL(ctrl)) {\r\npciehp_power_off_slot(pslot);\r\nmsleep(1000);\r\n}\r\npciehp_green_led_off(pslot);\r\npciehp_set_attention_status(pslot, 1);\r\n}\r\nstatic int board_added(struct slot *p_slot)\r\n{\r\nint retval = 0;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nstruct pci_bus *parent = ctrl->pcie->port->subordinate;\r\nif (POWER_CTRL(ctrl)) {\r\nretval = pciehp_power_on_slot(p_slot);\r\nif (retval)\r\nreturn retval;\r\n}\r\npciehp_green_led_blink(p_slot);\r\nretval = pciehp_check_link_status(ctrl);\r\nif (retval) {\r\nctrl_err(ctrl, "Failed to check link status\n");\r\ngoto err_exit;\r\n}\r\nif (ctrl->power_fault_detected || pciehp_query_power_fault(p_slot)) {\r\nctrl_err(ctrl, "Power fault on slot %s\n", slot_name(p_slot));\r\nretval = -EIO;\r\ngoto err_exit;\r\n}\r\nretval = pciehp_configure_device(p_slot);\r\nif (retval) {\r\nctrl_err(ctrl, "Cannot add device at %04x:%02x:00\n",\r\npci_domain_nr(parent), parent->number);\r\nif (retval != -EEXIST)\r\ngoto err_exit;\r\n}\r\npciehp_green_led_on(p_slot);\r\nreturn 0;\r\nerr_exit:\r\nset_slot_off(ctrl, p_slot);\r\nreturn retval;\r\n}\r\nstatic int remove_board(struct slot *p_slot)\r\n{\r\nint retval;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nretval = pciehp_unconfigure_device(p_slot);\r\nif (retval)\r\nreturn retval;\r\nif (POWER_CTRL(ctrl)) {\r\npciehp_power_off_slot(p_slot);\r\nmsleep(1000);\r\n}\r\npciehp_green_led_off(p_slot);\r\nreturn 0;\r\n}\r\nstatic void pciehp_power_thread(struct work_struct *work)\r\n{\r\nstruct power_work_info *info =\r\ncontainer_of(work, struct power_work_info, work);\r\nstruct slot *p_slot = info->p_slot;\r\nint ret;\r\nswitch (info->req) {\r\ncase DISABLE_REQ:\r\nmutex_lock(&p_slot->hotplug_lock);\r\npciehp_disable_slot(p_slot);\r\nmutex_unlock(&p_slot->hotplug_lock);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nmutex_unlock(&p_slot->lock);\r\nbreak;\r\ncase ENABLE_REQ:\r\nmutex_lock(&p_slot->hotplug_lock);\r\nret = pciehp_enable_slot(p_slot);\r\nmutex_unlock(&p_slot->hotplug_lock);\r\nif (ret)\r\npciehp_green_led_off(p_slot);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nmutex_unlock(&p_slot->lock);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nkfree(info);\r\n}\r\nstatic void pciehp_queue_power_work(struct slot *p_slot, int req)\r\n{\r\nstruct power_work_info *info;\r\np_slot->state = (req == ENABLE_REQ) ? POWERON_STATE : POWEROFF_STATE;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nctrl_err(p_slot->ctrl, "no memory to queue %s request\n",\r\n(req == ENABLE_REQ) ? "poweron" : "poweroff");\r\nreturn;\r\n}\r\ninfo->p_slot = p_slot;\r\nINIT_WORK(&info->work, pciehp_power_thread);\r\ninfo->req = req;\r\nqueue_work(p_slot->wq, &info->work);\r\n}\r\nvoid pciehp_queue_pushbutton_work(struct work_struct *work)\r\n{\r\nstruct slot *p_slot = container_of(work, struct slot, work.work);\r\nmutex_lock(&p_slot->lock);\r\nswitch (p_slot->state) {\r\ncase BLINKINGOFF_STATE:\r\npciehp_queue_power_work(p_slot, DISABLE_REQ);\r\nbreak;\r\ncase BLINKINGON_STATE:\r\npciehp_queue_power_work(p_slot, ENABLE_REQ);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\n}\r\nstatic void handle_button_press_event(struct slot *p_slot)\r\n{\r\nstruct controller *ctrl = p_slot->ctrl;\r\nu8 getstatus;\r\nswitch (p_slot->state) {\r\ncase STATIC_STATE:\r\npciehp_get_power_status(p_slot, &getstatus);\r\nif (getstatus) {\r\np_slot->state = BLINKINGOFF_STATE;\r\nctrl_info(ctrl, "PCI slot #%s - powering off due to button press\n",\r\nslot_name(p_slot));\r\n} else {\r\np_slot->state = BLINKINGON_STATE;\r\nctrl_info(ctrl, "PCI slot #%s - powering on due to button press\n",\r\nslot_name(p_slot));\r\n}\r\npciehp_green_led_blink(p_slot);\r\npciehp_set_attention_status(p_slot, 0);\r\nqueue_delayed_work(p_slot->wq, &p_slot->work, 5*HZ);\r\nbreak;\r\ncase BLINKINGOFF_STATE:\r\ncase BLINKINGON_STATE:\r\nctrl_info(ctrl, "Button cancel on Slot(%s)\n", slot_name(p_slot));\r\ncancel_delayed_work(&p_slot->work);\r\nif (p_slot->state == BLINKINGOFF_STATE)\r\npciehp_green_led_on(p_slot);\r\nelse\r\npciehp_green_led_off(p_slot);\r\npciehp_set_attention_status(p_slot, 0);\r\nctrl_info(ctrl, "PCI slot #%s - action canceled due to button press\n",\r\nslot_name(p_slot));\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ncase POWEROFF_STATE:\r\ncase POWERON_STATE:\r\nctrl_info(ctrl, "Button ignore on Slot(%s)\n", slot_name(p_slot));\r\nbreak;\r\ndefault:\r\nctrl_warn(ctrl, "ignoring invalid state %#x\n", p_slot->state);\r\nbreak;\r\n}\r\n}\r\nstatic void handle_surprise_event(struct slot *p_slot)\r\n{\r\nu8 getstatus;\r\npciehp_get_adapter_status(p_slot, &getstatus);\r\nif (!getstatus)\r\npciehp_queue_power_work(p_slot, DISABLE_REQ);\r\nelse\r\npciehp_queue_power_work(p_slot, ENABLE_REQ);\r\n}\r\nstatic void handle_link_event(struct slot *p_slot, u32 event)\r\n{\r\nstruct controller *ctrl = p_slot->ctrl;\r\nswitch (p_slot->state) {\r\ncase BLINKINGON_STATE:\r\ncase BLINKINGOFF_STATE:\r\ncancel_delayed_work(&p_slot->work);\r\ncase STATIC_STATE:\r\npciehp_queue_power_work(p_slot, event == INT_LINK_UP ?\r\nENABLE_REQ : DISABLE_REQ);\r\nbreak;\r\ncase POWERON_STATE:\r\nif (event == INT_LINK_UP) {\r\nctrl_info(ctrl,\r\n"Link Up event ignored on slot(%s): already powering on\n",\r\nslot_name(p_slot));\r\n} else {\r\nctrl_info(ctrl,\r\n"Link Down event queued on slot(%s): currently getting powered on\n",\r\nslot_name(p_slot));\r\npciehp_queue_power_work(p_slot, DISABLE_REQ);\r\n}\r\nbreak;\r\ncase POWEROFF_STATE:\r\nif (event == INT_LINK_UP) {\r\nctrl_info(ctrl,\r\n"Link Up event queued on slot(%s): currently getting powered off\n",\r\nslot_name(p_slot));\r\npciehp_queue_power_work(p_slot, ENABLE_REQ);\r\n} else {\r\nctrl_info(ctrl,\r\n"Link Down event ignored on slot(%s): already powering off\n",\r\nslot_name(p_slot));\r\n}\r\nbreak;\r\ndefault:\r\nctrl_err(ctrl, "ignoring invalid state %#x on slot(%s)\n",\r\np_slot->state, slot_name(p_slot));\r\nbreak;\r\n}\r\n}\r\nstatic void interrupt_event_handler(struct work_struct *work)\r\n{\r\nstruct event_info *info = container_of(work, struct event_info, work);\r\nstruct slot *p_slot = info->p_slot;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nmutex_lock(&p_slot->lock);\r\nswitch (info->event_type) {\r\ncase INT_BUTTON_PRESS:\r\nhandle_button_press_event(p_slot);\r\nbreak;\r\ncase INT_POWER_FAULT:\r\nif (!POWER_CTRL(ctrl))\r\nbreak;\r\npciehp_set_attention_status(p_slot, 1);\r\npciehp_green_led_off(p_slot);\r\nbreak;\r\ncase INT_PRESENCE_ON:\r\nhandle_surprise_event(p_slot);\r\nbreak;\r\ncase INT_PRESENCE_OFF:\r\nhandle_surprise_event(p_slot);\r\nbreak;\r\ncase INT_LINK_UP:\r\ncase INT_LINK_DOWN:\r\nhandle_link_event(p_slot, info->event_type);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\nkfree(info);\r\n}\r\nint pciehp_enable_slot(struct slot *p_slot)\r\n{\r\nu8 getstatus = 0;\r\nint rc;\r\nstruct controller *ctrl = p_slot->ctrl;\r\npciehp_get_adapter_status(p_slot, &getstatus);\r\nif (!getstatus) {\r\nctrl_info(ctrl, "No adapter on slot(%s)\n", slot_name(p_slot));\r\nreturn -ENODEV;\r\n}\r\nif (MRL_SENS(p_slot->ctrl)) {\r\npciehp_get_latch_status(p_slot, &getstatus);\r\nif (getstatus) {\r\nctrl_info(ctrl, "Latch open on slot(%s)\n",\r\nslot_name(p_slot));\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (POWER_CTRL(p_slot->ctrl)) {\r\npciehp_get_power_status(p_slot, &getstatus);\r\nif (getstatus) {\r\nctrl_info(ctrl, "Already enabled on slot(%s)\n",\r\nslot_name(p_slot));\r\nreturn -EINVAL;\r\n}\r\n}\r\npciehp_get_latch_status(p_slot, &getstatus);\r\nrc = board_added(p_slot);\r\nif (rc)\r\npciehp_get_latch_status(p_slot, &getstatus);\r\nreturn rc;\r\n}\r\nint pciehp_disable_slot(struct slot *p_slot)\r\n{\r\nu8 getstatus = 0;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nif (!p_slot->ctrl)\r\nreturn 1;\r\nif (POWER_CTRL(p_slot->ctrl)) {\r\npciehp_get_power_status(p_slot, &getstatus);\r\nif (!getstatus) {\r\nctrl_info(ctrl, "Already disabled on slot(%s)\n",\r\nslot_name(p_slot));\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn remove_board(p_slot);\r\n}\r\nint pciehp_sysfs_enable_slot(struct slot *p_slot)\r\n{\r\nint retval = -ENODEV;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nmutex_lock(&p_slot->lock);\r\nswitch (p_slot->state) {\r\ncase BLINKINGON_STATE:\r\ncancel_delayed_work(&p_slot->work);\r\ncase STATIC_STATE:\r\np_slot->state = POWERON_STATE;\r\nmutex_unlock(&p_slot->lock);\r\nmutex_lock(&p_slot->hotplug_lock);\r\nretval = pciehp_enable_slot(p_slot);\r\nmutex_unlock(&p_slot->hotplug_lock);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ncase POWERON_STATE:\r\nctrl_info(ctrl, "Slot %s is already in powering on state\n",\r\nslot_name(p_slot));\r\nbreak;\r\ncase BLINKINGOFF_STATE:\r\ncase POWEROFF_STATE:\r\nctrl_info(ctrl, "Already enabled on slot %s\n",\r\nslot_name(p_slot));\r\nbreak;\r\ndefault:\r\nctrl_err(ctrl, "invalid state %#x on slot %s\n",\r\np_slot->state, slot_name(p_slot));\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\nreturn retval;\r\n}\r\nint pciehp_sysfs_disable_slot(struct slot *p_slot)\r\n{\r\nint retval = -ENODEV;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nmutex_lock(&p_slot->lock);\r\nswitch (p_slot->state) {\r\ncase BLINKINGOFF_STATE:\r\ncancel_delayed_work(&p_slot->work);\r\ncase STATIC_STATE:\r\np_slot->state = POWEROFF_STATE;\r\nmutex_unlock(&p_slot->lock);\r\nmutex_lock(&p_slot->hotplug_lock);\r\nretval = pciehp_disable_slot(p_slot);\r\nmutex_unlock(&p_slot->hotplug_lock);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ncase POWEROFF_STATE:\r\nctrl_info(ctrl, "Slot %s is already in powering off state\n",\r\nslot_name(p_slot));\r\nbreak;\r\ncase BLINKINGON_STATE:\r\ncase POWERON_STATE:\r\nctrl_info(ctrl, "Already disabled on slot %s\n",\r\nslot_name(p_slot));\r\nbreak;\r\ndefault:\r\nctrl_err(ctrl, "invalid state %#x on slot %s\n",\r\np_slot->state, slot_name(p_slot));\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\nreturn retval;\r\n}
