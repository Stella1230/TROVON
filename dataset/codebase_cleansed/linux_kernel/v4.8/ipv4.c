int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\r\n{\r\nconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\n__be16 orig_sport, orig_dport;\r\n__be32 daddr, nexthop;\r\nstruct flowi4 *fl4;\r\nstruct rtable *rt;\r\nint err;\r\nstruct ip_options_rcu *inet_opt;\r\ndp->dccps_role = DCCP_ROLE_CLIENT;\r\nif (addr_len < sizeof(struct sockaddr_in))\r\nreturn -EINVAL;\r\nif (usin->sin_family != AF_INET)\r\nreturn -EAFNOSUPPORT;\r\nnexthop = daddr = usin->sin_addr.s_addr;\r\ninet_opt = rcu_dereference_protected(inet->inet_opt,\r\nlockdep_sock_is_held(sk));\r\nif (inet_opt != NULL && inet_opt->opt.srr) {\r\nif (daddr == 0)\r\nreturn -EINVAL;\r\nnexthop = inet_opt->opt.faddr;\r\n}\r\norig_sport = inet->inet_sport;\r\norig_dport = usin->sin_port;\r\nfl4 = &inet->cork.fl.u.ip4;\r\nrt = ip_route_connect(fl4, nexthop, inet->inet_saddr,\r\nRT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\r\nIPPROTO_DCCP,\r\norig_sport, orig_dport, sk);\r\nif (IS_ERR(rt))\r\nreturn PTR_ERR(rt);\r\nif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\r\nip_rt_put(rt);\r\nreturn -ENETUNREACH;\r\n}\r\nif (inet_opt == NULL || !inet_opt->opt.srr)\r\ndaddr = fl4->daddr;\r\nif (inet->inet_saddr == 0)\r\ninet->inet_saddr = fl4->saddr;\r\nsk_rcv_saddr_set(sk, inet->inet_saddr);\r\ninet->inet_dport = usin->sin_port;\r\nsk_daddr_set(sk, daddr);\r\ninet_csk(sk)->icsk_ext_hdr_len = 0;\r\nif (inet_opt)\r\ninet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\r\ndccp_set_state(sk, DCCP_REQUESTING);\r\nerr = inet_hash_connect(&dccp_death_row, sk);\r\nif (err != 0)\r\ngoto failure;\r\nrt = ip_route_newports(fl4, rt, orig_sport, orig_dport,\r\ninet->inet_sport, inet->inet_dport, sk);\r\nif (IS_ERR(rt)) {\r\nerr = PTR_ERR(rt);\r\nrt = NULL;\r\ngoto failure;\r\n}\r\nsk_setup_caps(sk, &rt->dst);\r\ndp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr,\r\ninet->inet_daddr,\r\ninet->inet_sport,\r\ninet->inet_dport);\r\ninet->inet_id = dp->dccps_iss ^ jiffies;\r\nerr = dccp_connect(sk);\r\nrt = NULL;\r\nif (err != 0)\r\ngoto failure;\r\nout:\r\nreturn err;\r\nfailure:\r\ndccp_set_state(sk, DCCP_CLOSED);\r\nip_rt_put(rt);\r\nsk->sk_route_caps = 0;\r\ninet->inet_dport = 0;\r\ngoto out;\r\n}\r\nstatic inline void dccp_do_pmtu_discovery(struct sock *sk,\r\nconst struct iphdr *iph,\r\nu32 mtu)\r\n{\r\nstruct dst_entry *dst;\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nconst struct dccp_sock *dp = dccp_sk(sk);\r\nif (sk->sk_state == DCCP_LISTEN)\r\nreturn;\r\ndst = inet_csk_update_pmtu(sk, mtu);\r\nif (!dst)\r\nreturn;\r\nif (mtu < dst_mtu(dst) && ip_dont_fragment(sk, dst))\r\nsk->sk_err_soft = EMSGSIZE;\r\nmtu = dst_mtu(dst);\r\nif (inet->pmtudisc != IP_PMTUDISC_DONT &&\r\nip_sk_accept_pmtu(sk) &&\r\ninet_csk(sk)->icsk_pmtu_cookie > mtu) {\r\ndccp_sync_mss(sk, mtu);\r\ndccp_send_sync(sk, dp->dccps_gsr, DCCP_PKT_SYNC);\r\n}\r\n}\r\nstatic void dccp_do_redirect(struct sk_buff *skb, struct sock *sk)\r\n{\r\nstruct dst_entry *dst = __sk_dst_check(sk, 0);\r\nif (dst)\r\ndst->ops->redirect(dst, sk, skb);\r\n}\r\nvoid dccp_req_err(struct sock *sk, u64 seq)\r\n{\r\nstruct request_sock *req = inet_reqsk(sk);\r\nstruct net *net = sock_net(sk);\r\nif (!between48(seq, dccp_rsk(req)->dreq_iss, dccp_rsk(req)->dreq_gss)) {\r\n__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\r\n} else {\r\ninet_csk_reqsk_queue_drop(req->rsk_listener, req);\r\n}\r\nreqsk_put(req);\r\n}\r\nstatic void dccp_v4_err(struct sk_buff *skb, u32 info)\r\n{\r\nconst struct iphdr *iph = (struct iphdr *)skb->data;\r\nconst u8 offset = iph->ihl << 2;\r\nconst struct dccp_hdr *dh = (struct dccp_hdr *)(skb->data + offset);\r\nstruct dccp_sock *dp;\r\nstruct inet_sock *inet;\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nstruct sock *sk;\r\n__u64 seq;\r\nint err;\r\nstruct net *net = dev_net(skb->dev);\r\nif (skb->len < offset + sizeof(*dh) ||\r\nskb->len < offset + __dccp_basic_hdr_len(dh)) {\r\n__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);\r\nreturn;\r\n}\r\nsk = __inet_lookup_established(net, &dccp_hashinfo,\r\niph->daddr, dh->dccph_dport,\r\niph->saddr, ntohs(dh->dccph_sport),\r\ninet_iif(skb));\r\nif (!sk) {\r\n__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);\r\nreturn;\r\n}\r\nif (sk->sk_state == DCCP_TIME_WAIT) {\r\ninet_twsk_put(inet_twsk(sk));\r\nreturn;\r\n}\r\nseq = dccp_hdr_seq(dh);\r\nif (sk->sk_state == DCCP_NEW_SYN_RECV)\r\nreturn dccp_req_err(sk, seq);\r\nbh_lock_sock(sk);\r\nif (sock_owned_by_user(sk))\r\n__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\r\nif (sk->sk_state == DCCP_CLOSED)\r\ngoto out;\r\ndp = dccp_sk(sk);\r\nif ((1 << sk->sk_state) & ~(DCCPF_REQUESTING | DCCPF_LISTEN) &&\r\n!between48(seq, dp->dccps_awl, dp->dccps_awh)) {\r\n__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\r\ngoto out;\r\n}\r\nswitch (type) {\r\ncase ICMP_REDIRECT:\r\ndccp_do_redirect(skb, sk);\r\ngoto out;\r\ncase ICMP_SOURCE_QUENCH:\r\ngoto out;\r\ncase ICMP_PARAMETERPROB:\r\nerr = EPROTO;\r\nbreak;\r\ncase ICMP_DEST_UNREACH:\r\nif (code > NR_ICMP_UNREACH)\r\ngoto out;\r\nif (code == ICMP_FRAG_NEEDED) {\r\nif (!sock_owned_by_user(sk))\r\ndccp_do_pmtu_discovery(sk, iph, info);\r\ngoto out;\r\n}\r\nerr = icmp_err_convert[code].errno;\r\nbreak;\r\ncase ICMP_TIME_EXCEEDED:\r\nerr = EHOSTUNREACH;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nswitch (sk->sk_state) {\r\ncase DCCP_REQUESTING:\r\ncase DCCP_RESPOND:\r\nif (!sock_owned_by_user(sk)) {\r\n__DCCP_INC_STATS(DCCP_MIB_ATTEMPTFAILS);\r\nsk->sk_err = err;\r\nsk->sk_error_report(sk);\r\ndccp_done(sk);\r\n} else\r\nsk->sk_err_soft = err;\r\ngoto out;\r\n}\r\ninet = inet_sk(sk);\r\nif (!sock_owned_by_user(sk) && inet->recverr) {\r\nsk->sk_err = err;\r\nsk->sk_error_report(sk);\r\n} else\r\nsk->sk_err_soft = err;\r\nout:\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\n}\r\nstatic inline __sum16 dccp_v4_csum_finish(struct sk_buff *skb,\r\n__be32 src, __be32 dst)\r\n{\r\nreturn csum_tcpudp_magic(src, dst, skb->len, IPPROTO_DCCP, skb->csum);\r\n}\r\nvoid dccp_v4_send_check(struct sock *sk, struct sk_buff *skb)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nstruct dccp_hdr *dh = dccp_hdr(skb);\r\ndccp_csum_outgoing(skb);\r\ndh->dccph_checksum = dccp_v4_csum_finish(skb,\r\ninet->inet_saddr,\r\ninet->inet_daddr);\r\n}\r\nstatic inline u64 dccp_v4_init_sequence(const struct sk_buff *skb)\r\n{\r\nreturn secure_dccp_sequence_number(ip_hdr(skb)->daddr,\r\nip_hdr(skb)->saddr,\r\ndccp_hdr(skb)->dccph_dport,\r\ndccp_hdr(skb)->dccph_sport);\r\n}\r\nstruct sock *dccp_v4_request_recv_sock(const struct sock *sk,\r\nstruct sk_buff *skb,\r\nstruct request_sock *req,\r\nstruct dst_entry *dst,\r\nstruct request_sock *req_unhash,\r\nbool *own_req)\r\n{\r\nstruct inet_request_sock *ireq;\r\nstruct inet_sock *newinet;\r\nstruct sock *newsk;\r\nif (sk_acceptq_is_full(sk))\r\ngoto exit_overflow;\r\nnewsk = dccp_create_openreq_child(sk, req, skb);\r\nif (newsk == NULL)\r\ngoto exit_nonewsk;\r\nnewinet = inet_sk(newsk);\r\nireq = inet_rsk(req);\r\nsk_daddr_set(newsk, ireq->ir_rmt_addr);\r\nsk_rcv_saddr_set(newsk, ireq->ir_loc_addr);\r\nnewinet->inet_saddr = ireq->ir_loc_addr;\r\nnewinet->inet_opt = ireq->opt;\r\nireq->opt = NULL;\r\nnewinet->mc_index = inet_iif(skb);\r\nnewinet->mc_ttl = ip_hdr(skb)->ttl;\r\nnewinet->inet_id = jiffies;\r\nif (dst == NULL && (dst = inet_csk_route_child_sock(sk, newsk, req)) == NULL)\r\ngoto put_and_exit;\r\nsk_setup_caps(newsk, dst);\r\ndccp_sync_mss(newsk, dst_mtu(dst));\r\nif (__inet_inherit_port(sk, newsk) < 0)\r\ngoto put_and_exit;\r\n*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\r\nreturn newsk;\r\nexit_overflow:\r\n__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\r\nexit_nonewsk:\r\ndst_release(dst);\r\nexit:\r\n__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\r\nreturn NULL;\r\nput_and_exit:\r\ninet_csk_prepare_forced_close(newsk);\r\ndccp_done(newsk);\r\ngoto exit;\r\n}\r\nstatic struct dst_entry* dccp_v4_route_skb(struct net *net, struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rtable *rt;\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct flowi4 fl4 = {\r\n.flowi4_oif = inet_iif(skb),\r\n.daddr = iph->saddr,\r\n.saddr = iph->daddr,\r\n.flowi4_tos = RT_CONN_FLAGS(sk),\r\n.flowi4_proto = sk->sk_protocol,\r\n.fl4_sport = dccp_hdr(skb)->dccph_dport,\r\n.fl4_dport = dccp_hdr(skb)->dccph_sport,\r\n};\r\nsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\r\nrt = ip_route_output_flow(net, &fl4, sk);\r\nif (IS_ERR(rt)) {\r\nIP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);\r\nreturn NULL;\r\n}\r\nreturn &rt->dst;\r\n}\r\nstatic int dccp_v4_send_response(const struct sock *sk, struct request_sock *req)\r\n{\r\nint err = -1;\r\nstruct sk_buff *skb;\r\nstruct dst_entry *dst;\r\nstruct flowi4 fl4;\r\ndst = inet_csk_route_req(sk, &fl4, req);\r\nif (dst == NULL)\r\ngoto out;\r\nskb = dccp_make_response(sk, dst, req);\r\nif (skb != NULL) {\r\nconst struct inet_request_sock *ireq = inet_rsk(req);\r\nstruct dccp_hdr *dh = dccp_hdr(skb);\r\ndh->dccph_checksum = dccp_v4_csum_finish(skb, ireq->ir_loc_addr,\r\nireq->ir_rmt_addr);\r\nerr = ip_build_and_send_pkt(skb, sk, ireq->ir_loc_addr,\r\nireq->ir_rmt_addr,\r\nireq->opt);\r\nerr = net_xmit_eval(err);\r\n}\r\nout:\r\ndst_release(dst);\r\nreturn err;\r\n}\r\nstatic void dccp_v4_ctl_send_reset(const struct sock *sk, struct sk_buff *rxskb)\r\n{\r\nint err;\r\nconst struct iphdr *rxiph;\r\nstruct sk_buff *skb;\r\nstruct dst_entry *dst;\r\nstruct net *net = dev_net(skb_dst(rxskb)->dev);\r\nstruct sock *ctl_sk = net->dccp.v4_ctl_sk;\r\nif (dccp_hdr(rxskb)->dccph_type == DCCP_PKT_RESET)\r\nreturn;\r\nif (skb_rtable(rxskb)->rt_type != RTN_LOCAL)\r\nreturn;\r\ndst = dccp_v4_route_skb(net, ctl_sk, rxskb);\r\nif (dst == NULL)\r\nreturn;\r\nskb = dccp_ctl_make_reset(ctl_sk, rxskb);\r\nif (skb == NULL)\r\ngoto out;\r\nrxiph = ip_hdr(rxskb);\r\ndccp_hdr(skb)->dccph_checksum = dccp_v4_csum_finish(skb, rxiph->saddr,\r\nrxiph->daddr);\r\nskb_dst_set(skb, dst_clone(dst));\r\nlocal_bh_disable();\r\nbh_lock_sock(ctl_sk);\r\nerr = ip_build_and_send_pkt(skb, ctl_sk,\r\nrxiph->daddr, rxiph->saddr, NULL);\r\nbh_unlock_sock(ctl_sk);\r\nif (net_xmit_eval(err) == 0) {\r\n__DCCP_INC_STATS(DCCP_MIB_OUTSEGS);\r\n__DCCP_INC_STATS(DCCP_MIB_OUTRSTS);\r\n}\r\nlocal_bh_enable();\r\nout:\r\ndst_release(dst);\r\n}\r\nstatic void dccp_v4_reqsk_destructor(struct request_sock *req)\r\n{\r\ndccp_feat_list_purge(&dccp_rsk(req)->dreq_featneg);\r\nkfree(inet_rsk(req)->opt);\r\n}\r\nvoid dccp_syn_ack_timeout(const struct request_sock *req)\r\n{\r\n}\r\nint dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct inet_request_sock *ireq;\r\nstruct request_sock *req;\r\nstruct dccp_request_sock *dreq;\r\nconst __be32 service = dccp_hdr_request(skb)->dccph_req_service;\r\nstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\r\nif (skb_rtable(skb)->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\r\nreturn 0;\r\nif (dccp_bad_service_code(sk, service)) {\r\ndcb->dccpd_reset_code = DCCP_RESET_CODE_BAD_SERVICE_CODE;\r\ngoto drop;\r\n}\r\ndcb->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\r\nif (inet_csk_reqsk_queue_is_full(sk))\r\ngoto drop;\r\nif (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) > 1)\r\ngoto drop;\r\nreq = inet_reqsk_alloc(&dccp_request_sock_ops, sk, true);\r\nif (req == NULL)\r\ngoto drop;\r\nif (dccp_reqsk_init(req, dccp_sk(sk), skb))\r\ngoto drop_and_free;\r\ndreq = dccp_rsk(req);\r\nif (dccp_parse_options(sk, dreq, skb))\r\ngoto drop_and_free;\r\nif (security_inet_conn_request(sk, skb, req))\r\ngoto drop_and_free;\r\nireq = inet_rsk(req);\r\nsk_rcv_saddr_set(req_to_sk(req), ip_hdr(skb)->daddr);\r\nsk_daddr_set(req_to_sk(req), ip_hdr(skb)->saddr);\r\nireq->ireq_family = AF_INET;\r\nireq->ir_iif = sk->sk_bound_dev_if;\r\ndreq->dreq_isr = dcb->dccpd_seq;\r\ndreq->dreq_gsr = dreq->dreq_isr;\r\ndreq->dreq_iss = dccp_v4_init_sequence(skb);\r\ndreq->dreq_gss = dreq->dreq_iss;\r\ndreq->dreq_service = service;\r\nif (dccp_v4_send_response(sk, req))\r\ngoto drop_and_free;\r\ninet_csk_reqsk_queue_hash_add(sk, req, DCCP_TIMEOUT_INIT);\r\nreturn 0;\r\ndrop_and_free:\r\nreqsk_free(req);\r\ndrop:\r\n__DCCP_INC_STATS(DCCP_MIB_ATTEMPTFAILS);\r\nreturn -1;\r\n}\r\nint dccp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dccp_hdr *dh = dccp_hdr(skb);\r\nif (sk->sk_state == DCCP_OPEN) {\r\nif (dccp_rcv_established(sk, skb, dh, skb->len))\r\ngoto reset;\r\nreturn 0;\r\n}\r\nif (dccp_rcv_state_process(sk, skb, dh, skb->len))\r\ngoto reset;\r\nreturn 0;\r\nreset:\r\ndccp_v4_ctl_send_reset(sk, skb);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint dccp_invalid_packet(struct sk_buff *skb)\r\n{\r\nconst struct dccp_hdr *dh;\r\nunsigned int cscov;\r\nif (skb->pkt_type != PACKET_HOST)\r\nreturn 1;\r\nif (!pskb_may_pull(skb, sizeof(struct dccp_hdr))) {\r\nDCCP_WARN("pskb_may_pull failed\n");\r\nreturn 1;\r\n}\r\ndh = dccp_hdr(skb);\r\nif (dh->dccph_type >= DCCP_PKT_INVALID) {\r\nDCCP_WARN("invalid packet type\n");\r\nreturn 1;\r\n}\r\nif (dh->dccph_doff < dccp_hdr_len(skb) / sizeof(u32)) {\r\nDCCP_WARN("P.Data Offset(%u) too small\n", dh->dccph_doff);\r\nreturn 1;\r\n}\r\nif (!pskb_may_pull(skb, dh->dccph_doff * sizeof(u32))) {\r\nDCCP_WARN("P.Data Offset(%u) too large\n", dh->dccph_doff);\r\nreturn 1;\r\n}\r\nif ((dh->dccph_type < DCCP_PKT_DATA ||\r\ndh->dccph_type > DCCP_PKT_DATAACK) && dh->dccph_x == 0) {\r\nDCCP_WARN("P.type (%s) not Data || [Data]Ack, while P.X == 0\n",\r\ndccp_packet_name(dh->dccph_type));\r\nreturn 1;\r\n}\r\ncscov = dccp_csum_coverage(skb);\r\nif (cscov > skb->len) {\r\nDCCP_WARN("P.CsCov %u exceeds packet length %d\n",\r\ndh->dccph_cscov, skb->len);\r\nreturn 1;\r\n}\r\nskb->csum = skb_checksum(skb, 0, cscov, 0);\r\nreturn 0;\r\n}\r\nstatic int dccp_v4_rcv(struct sk_buff *skb)\r\n{\r\nconst struct dccp_hdr *dh;\r\nconst struct iphdr *iph;\r\nbool refcounted;\r\nstruct sock *sk;\r\nint min_cov;\r\nif (dccp_invalid_packet(skb))\r\ngoto discard_it;\r\niph = ip_hdr(skb);\r\nif (dccp_v4_csum_finish(skb, iph->saddr, iph->daddr)) {\r\nDCCP_WARN("dropped packet with invalid checksum\n");\r\ngoto discard_it;\r\n}\r\ndh = dccp_hdr(skb);\r\nDCCP_SKB_CB(skb)->dccpd_seq = dccp_hdr_seq(dh);\r\nDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\r\ndccp_pr_debug("%8.8s src=%pI4@%-5d dst=%pI4@%-5d seq=%llu",\r\ndccp_packet_name(dh->dccph_type),\r\n&iph->saddr, ntohs(dh->dccph_sport),\r\n&iph->daddr, ntohs(dh->dccph_dport),\r\n(unsigned long long) DCCP_SKB_CB(skb)->dccpd_seq);\r\nif (dccp_packet_without_ack(skb)) {\r\nDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\r\ndccp_pr_debug_cat("\n");\r\n} else {\r\nDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\r\ndccp_pr_debug_cat(", ack=%llu\n", (unsigned long long)\r\nDCCP_SKB_CB(skb)->dccpd_ack_seq);\r\n}\r\nlookup:\r\nsk = __inet_lookup_skb(&dccp_hashinfo, skb, __dccp_hdr_len(dh),\r\ndh->dccph_sport, dh->dccph_dport, &refcounted);\r\nif (!sk) {\r\ndccp_pr_debug("failed to look up flow ID in table and "\r\n"get corresponding socket\n");\r\ngoto no_dccp_socket;\r\n}\r\nif (sk->sk_state == DCCP_TIME_WAIT) {\r\ndccp_pr_debug("sk->sk_state == DCCP_TIME_WAIT: do_time_wait\n");\r\ninet_twsk_put(inet_twsk(sk));\r\ngoto no_dccp_socket;\r\n}\r\nif (sk->sk_state == DCCP_NEW_SYN_RECV) {\r\nstruct request_sock *req = inet_reqsk(sk);\r\nstruct sock *nsk;\r\nsk = req->rsk_listener;\r\nif (unlikely(sk->sk_state != DCCP_LISTEN)) {\r\ninet_csk_reqsk_queue_drop_and_put(sk, req);\r\ngoto lookup;\r\n}\r\nsock_hold(sk);\r\nrefcounted = true;\r\nnsk = dccp_check_req(sk, skb, req);\r\nif (!nsk) {\r\nreqsk_put(req);\r\ngoto discard_and_relse;\r\n}\r\nif (nsk == sk) {\r\nreqsk_put(req);\r\n} else if (dccp_child_process(sk, nsk, skb)) {\r\ndccp_v4_ctl_send_reset(sk, skb);\r\ngoto discard_and_relse;\r\n} else {\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\n}\r\nmin_cov = dccp_sk(sk)->dccps_pcrlen;\r\nif (dh->dccph_cscov && (min_cov == 0 || dh->dccph_cscov < min_cov)) {\r\ndccp_pr_debug("Packet CsCov %d does not satisfy MinCsCov %d\n",\r\ndh->dccph_cscov, min_cov);\r\ngoto discard_and_relse;\r\n}\r\nif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\r\ngoto discard_and_relse;\r\nnf_reset(skb);\r\nreturn __sk_receive_skb(sk, skb, 1, dh->dccph_doff * 4);\r\nno_dccp_socket:\r\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\r\ngoto discard_it;\r\nif (dh->dccph_type != DCCP_PKT_RESET) {\r\nDCCP_SKB_CB(skb)->dccpd_reset_code =\r\nDCCP_RESET_CODE_NO_CONNECTION;\r\ndccp_v4_ctl_send_reset(sk, skb);\r\n}\r\ndiscard_it:\r\nkfree_skb(skb);\r\nreturn 0;\r\ndiscard_and_relse:\r\nif (refcounted)\r\nsock_put(sk);\r\ngoto discard_it;\r\n}\r\nstatic int dccp_v4_init_sock(struct sock *sk)\r\n{\r\nstatic __u8 dccp_v4_ctl_sock_initialized;\r\nint err = dccp_init_sock(sk, dccp_v4_ctl_sock_initialized);\r\nif (err == 0) {\r\nif (unlikely(!dccp_v4_ctl_sock_initialized))\r\ndccp_v4_ctl_sock_initialized = 1;\r\ninet_csk(sk)->icsk_af_ops = &dccp_ipv4_af_ops;\r\n}\r\nreturn err;\r\n}\r\nstatic int __net_init dccp_v4_init_net(struct net *net)\r\n{\r\nif (dccp_hashinfo.bhash == NULL)\r\nreturn -ESOCKTNOSUPPORT;\r\nreturn inet_ctl_sock_create(&net->dccp.v4_ctl_sk, PF_INET,\r\nSOCK_DCCP, IPPROTO_DCCP, net);\r\n}\r\nstatic void __net_exit dccp_v4_exit_net(struct net *net)\r\n{\r\ninet_ctl_sock_destroy(net->dccp.v4_ctl_sk);\r\n}\r\nstatic int __init dccp_v4_init(void)\r\n{\r\nint err = proto_register(&dccp_v4_prot, 1);\r\nif (err != 0)\r\ngoto out;\r\nerr = inet_add_protocol(&dccp_v4_protocol, IPPROTO_DCCP);\r\nif (err != 0)\r\ngoto out_proto_unregister;\r\ninet_register_protosw(&dccp_v4_protosw);\r\nerr = register_pernet_subsys(&dccp_v4_ops);\r\nif (err)\r\ngoto out_destroy_ctl_sock;\r\nout:\r\nreturn err;\r\nout_destroy_ctl_sock:\r\ninet_unregister_protosw(&dccp_v4_protosw);\r\ninet_del_protocol(&dccp_v4_protocol, IPPROTO_DCCP);\r\nout_proto_unregister:\r\nproto_unregister(&dccp_v4_prot);\r\ngoto out;\r\n}\r\nstatic void __exit dccp_v4_exit(void)\r\n{\r\nunregister_pernet_subsys(&dccp_v4_ops);\r\ninet_unregister_protosw(&dccp_v4_protosw);\r\ninet_del_protocol(&dccp_v4_protocol, IPPROTO_DCCP);\r\nproto_unregister(&dccp_v4_prot);\r\n}
