static void of_artpec6_clkctrl_setup(struct device_node *np)\r\n{\r\nint i;\r\nconst char *sys_refclk_name;\r\nu32 pll_mode, pll_m, pll_n;\r\nstruct clk **clks;\r\ni = of_property_match_string(np, "clock-names", "sys_refclk");\r\nif (i < 0)\r\nreturn;\r\nsys_refclk_name = of_clk_get_parent_name(np, i);\r\nclkdata = kzalloc(sizeof(*clkdata), GFP_KERNEL);\r\nif (!clkdata)\r\nreturn;\r\nclks = clkdata->clk_table;\r\nfor (i = 0; i < ARTPEC6_CLK_NUMCLOCKS; ++i)\r\nclks[i] = ERR_PTR(-EPROBE_DEFER);\r\nclkdata->syscon_base = of_iomap(np, 0);\r\nBUG_ON(clkdata->syscon_base == NULL);\r\npll_mode = (readl(clkdata->syscon_base) >> 6) & 3;\r\nswitch (pll_mode) {\r\ncase 0:\r\npll_m = 4;\r\npll_n = 85;\r\nbreak;\r\ncase 1:\r\npll_m = 6;\r\npll_n = 112;\r\nbreak;\r\ncase 2:\r\npll_m = 4;\r\npll_n = 64;\r\nbreak;\r\ncase 3:\r\npll_m = 8;\r\npll_n = 106;\r\nbreak;\r\n}\r\nclks[ARTPEC6_CLK_CPU] =\r\nclk_register_fixed_factor(NULL, "cpu", sys_refclk_name, 0, pll_n,\r\npll_m);\r\nclks[ARTPEC6_CLK_CPU_PERIPH] =\r\nclk_register_fixed_factor(NULL, "cpu_periph", "cpu", 0, 1, 2);\r\nclks[ARTPEC6_CLK_UART_PCLK] =\r\nclk_register_fixed_factor(NULL, "uart_pclk", "cpu", 0, 1, 8);\r\nclks[ARTPEC6_CLK_UART_REFCLK] =\r\nclk_register_fixed_rate(NULL, "uart_ref", sys_refclk_name, 0,\r\n50000000);\r\nclks[ARTPEC6_CLK_SPI_PCLK] =\r\nclk_register_fixed_factor(NULL, "spi_pclk", "cpu", 0, 1, 8);\r\nclks[ARTPEC6_CLK_SPI_SSPCLK] =\r\nclk_register_fixed_rate(NULL, "spi_sspclk", sys_refclk_name, 0,\r\n50000000);\r\nclks[ARTPEC6_CLK_DBG_PCLK] =\r\nclk_register_fixed_factor(NULL, "dbg_pclk", "cpu", 0, 1, 8);\r\nclkdata->clk_data.clks = clkdata->clk_table;\r\nclkdata->clk_data.clk_num = ARTPEC6_CLK_NUMCLOCKS;\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &clkdata->clk_data);\r\n}\r\nstatic int artpec6_clkctrl_probe(struct platform_device *pdev)\r\n{\r\nint propidx;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nstruct clk **clks = clkdata->clk_table;\r\nconst char *sys_refclk_name;\r\nconst char *i2s_refclk_name = NULL;\r\nconst char *frac_clk_name[2] = { NULL, NULL };\r\nconst char *i2s_mux_parents[2];\r\nu32 muxreg;\r\nint i;\r\nint err = 0;\r\npropidx = of_property_match_string(np, "clock-names", "sys_refclk");\r\nif (propidx < 0)\r\nreturn -EINVAL;\r\nsys_refclk_name = of_clk_get_parent_name(np, propidx);\r\npropidx = of_property_match_string(np, "clock-names", "i2s_refclk");\r\nif (propidx >= 0)\r\ni2s_refclk_name = of_clk_get_parent_name(np, propidx);\r\npropidx = of_property_match_string(np, "clock-names", "frac_clk0");\r\nif (propidx >= 0)\r\nfrac_clk_name[0] = of_clk_get_parent_name(np, propidx);\r\npropidx = of_property_match_string(np, "clock-names", "frac_clk1");\r\nif (propidx >= 0)\r\nfrac_clk_name[1] = of_clk_get_parent_name(np, propidx);\r\nspin_lock_init(&clkdata->i2scfg_lock);\r\nclks[ARTPEC6_CLK_NAND_CLKA] =\r\nclk_register_fixed_factor(dev, "nand_clka", "cpu", 0, 1, 8);\r\nclks[ARTPEC6_CLK_NAND_CLKB] =\r\nclk_register_fixed_rate(dev, "nand_clkb", sys_refclk_name, 0,\r\n100000000);\r\nclks[ARTPEC6_CLK_ETH_ACLK] =\r\nclk_register_fixed_factor(dev, "eth_aclk", "cpu", 0, 1, 4);\r\nclks[ARTPEC6_CLK_DMA_ACLK] =\r\nclk_register_fixed_factor(dev, "dma_aclk", "cpu", 0, 1, 4);\r\nclks[ARTPEC6_CLK_PTP_REF] =\r\nclk_register_fixed_rate(dev, "ptp_ref", sys_refclk_name, 0,\r\n100000000);\r\nclks[ARTPEC6_CLK_SD_PCLK] =\r\nclk_register_fixed_rate(dev, "sd_pclk", sys_refclk_name, 0,\r\n100000000);\r\nclks[ARTPEC6_CLK_SD_IMCLK] =\r\nclk_register_fixed_rate(dev, "sd_imclk", sys_refclk_name, 0,\r\n100000000);\r\nclks[ARTPEC6_CLK_I2S_HST] =\r\nclk_register_fixed_factor(dev, "i2s_hst", "cpu", 0, 1, 8);\r\nfor (i = 0; i < NUM_I2S_CLOCKS; ++i) {\r\nif (i2s_refclk_name && frac_clk_name[i]) {\r\ni2s_mux_parents[0] = frac_clk_name[i];\r\ni2s_mux_parents[1] = i2s_refclk_name;\r\nclks[i2s_clk_indexes[i]] =\r\nclk_register_mux(dev, i2s_clk_names[i],\r\ni2s_mux_parents, 2,\r\nCLK_SET_RATE_NO_REPARENT |\r\nCLK_SET_RATE_PARENT,\r\nclkdata->syscon_base + 0x14, i, 1,\r\n0, &clkdata->i2scfg_lock);\r\n} else if (frac_clk_name[i]) {\r\nmuxreg = readl(clkdata->syscon_base + 0x14);\r\nmuxreg &= ~BIT(i);\r\nwritel(muxreg, clkdata->syscon_base + 0x14);\r\nclks[i2s_clk_indexes[i]] =\r\nclk_register_fixed_factor(dev, i2s_clk_names[i],\r\nfrac_clk_name[i], 0, 1,\r\n1);\r\n} else if (i2s_refclk_name) {\r\nmuxreg = readl(clkdata->syscon_base + 0x14);\r\nmuxreg |= BIT(i);\r\nwritel(muxreg, clkdata->syscon_base + 0x14);\r\nclks[i2s_clk_indexes[i]] =\r\nclk_register_fixed_factor(dev, i2s_clk_names[i],\r\ni2s_refclk_name, 0, 1, 1);\r\n}\r\n}\r\nclks[ARTPEC6_CLK_I2C] =\r\nclk_register_fixed_rate(dev, "i2c", sys_refclk_name, 0, 100000000);\r\nclks[ARTPEC6_CLK_SYS_TIMER] =\r\nclk_register_fixed_rate(dev, "timer", sys_refclk_name, 0,\r\n100000000);\r\nclks[ARTPEC6_CLK_FRACDIV_IN] =\r\nclk_register_fixed_rate(dev, "fracdiv_in", sys_refclk_name, 0,\r\n600000000);\r\nfor (i = 0; i < ARTPEC6_CLK_NUMCLOCKS; ++i) {\r\nif (IS_ERR(clks[i]) && PTR_ERR(clks[i]) != -EPROBE_DEFER) {\r\ndev_err(dev,\r\n"Failed to register clock at index %d err=%ld\n",\r\ni, PTR_ERR(clks[i]));\r\nerr = PTR_ERR(clks[i]);\r\n}\r\n}\r\nreturn err;\r\n}
