static int init_display(struct fbtft_par *par)\r\n{\r\nint ret;\r\npar->spi->mode |= SPI_CS_HIGH;\r\nret = spi_setup(par->spi);\r\nif (ret) {\r\ndev_err(par->info->device, "Could not set SPI_CS_HIGH\n");\r\nreturn ret;\r\n}\r\nwrite_reg(par, 0xE2);\r\nwrite_reg(par, 0xE8 | (ratio & 0x03));\r\nwrite_reg(par, 0x81);\r\nwrite_reg(par, (gain & 0x03) << 6 | (pot & 0x3F));\r\nwrite_reg(par, 0x24 | (temp & 0x03));\r\nwrite_reg(par, 0x28 | (load & 0x03));\r\nwrite_reg(par, 0x2C | (pump & 0x03));\r\nwrite_reg(par, 0xA6 | (0x01 & 0x01));\r\nwrite_reg(par, 0xD0 | (0x02 & 0x03));\r\nwrite_reg(par, 0xA8 | 0x07);\r\nreturn 0;\r\n}\r\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\r\n{\r\nswitch (par->info->var.rotate) {\r\ncase 90:\r\ncase 270:\r\nwrite_reg(par, ys & 0x0F);\r\nwrite_reg(par, 0x10 | (ys >> 4));\r\nwrite_reg(par, 0x60 | ((xs >> 1) & 0x0F));\r\nwrite_reg(par, 0x70 | (xs >> 5));\r\nbreak;\r\ndefault:\r\nwrite_reg(par, xs & 0x0F);\r\nwrite_reg(par, 0x10 | (xs >> 4));\r\nwrite_reg(par, 0x60 | ((ys >> 1) & 0x0F));\r\nwrite_reg(par, 0x70 | (ys >> 5));\r\nbreak;\r\n}\r\n}\r\nstatic int blank(struct fbtft_par *par, bool on)\r\n{\r\nfbtft_par_dbg(DEBUG_BLANK, par, "%s(blank=%s)\n",\r\n__func__, on ? "true" : "false");\r\nif (on)\r\nwrite_reg(par, 0xA8 | 0x00);\r\nelse\r\nwrite_reg(par, 0xA8 | 0x07);\r\nreturn 0;\r\n}\r\nstatic int set_var(struct fbtft_par *par)\r\n{\r\npar->info->var.grayscale = 1;\r\npar->info->var.red.offset = 0;\r\npar->info->var.red.length = 8;\r\npar->info->var.green.offset = 0;\r\npar->info->var.green.length = 8;\r\npar->info->var.blue.offset = 0;\r\npar->info->var.blue.length = 8;\r\npar->info->var.transp.offset = 0;\r\npar->info->var.transp.length = 0;\r\nswitch (par->info->var.rotate) {\r\ncase 90:\r\nwrite_reg(par, 0x88\r\n| (0x0 & 0x1) << 2\r\n| (0x1 & 0x1) << 1\r\n| (0x1 & 0x1));\r\nwrite_reg(par, 0xC0\r\n| (0x0 & 0x1) << 2\r\n| (0x0 & 0x1) << 1\r\n| (0x0 & 0x1));\r\nbreak;\r\ncase 180:\r\nwrite_reg(par, 0x88\r\n| (0x0 & 0x1) << 2\r\n| (0x0 & 0x1) << 1\r\n| (0x1 & 0x1));\r\nwrite_reg(par, 0xC0\r\n| (0x1 & 0x1) << 2\r\n| (0x0 & 0x1) << 1\r\n| (0x0 & 0x1));\r\nbreak;\r\ncase 270:\r\nwrite_reg(par, 0x88\r\n| (0x0 & 0x1) << 2\r\n| (0x1 & 0x1) << 1\r\n| (0x1 & 0x1));\r\nwrite_reg(par, 0xC0\r\n| (0x1 & 0x1) << 2\r\n| (0x1 & 0x1) << 1\r\n| (0x0 & 0x1));\r\nbreak;\r\ndefault:\r\nwrite_reg(par, 0x88\r\n| (0x0 & 0x1) << 2\r\n| (0x0 & 0x1) << 1\r\n| (0x1 & 0x1));\r\nwrite_reg(par, 0xC0\r\n| (0x0 & 0x1) << 2\r\n| (0x1 & 0x1) << 1\r\n| (0x0 & 0x1));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\r\n{\r\nu8 *vmem8 = (u8 *)(par->info->screen_buffer);\r\nu8 *buf8 = par->txbuf.buf;\r\nu16 *buf16 = par->txbuf.buf;\r\nint line_length = par->info->fix.line_length;\r\nint y_start = (offset / line_length);\r\nint y_end = (offset + len - 1) / line_length;\r\nint x, y, i;\r\nint ret = 0;\r\nswitch (par->pdata->display.buswidth) {\r\ncase 8:\r\nswitch (par->info->var.rotate) {\r\ncase 90:\r\ncase 270:\r\ni = y_start * line_length;\r\nfor (y = y_start; y <= y_end; y++) {\r\nfor (x = 0; x < line_length; x += 2) {\r\n*buf8 = vmem8[i] >> 4;\r\n*buf8 |= vmem8[i + 1] & 0xF0;\r\nbuf8++;\r\ni += 2;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\ny_start &= 0xFE;\r\ni = y_start * line_length;\r\nfor (y = y_start; y <= y_end; y += 2) {\r\nfor (x = 0; x < line_length; x++) {\r\n*buf8 = vmem8[i] >> 4;\r\n*buf8 |= vmem8[i + line_length] & 0xF0;\r\nbuf8++;\r\ni++;\r\n}\r\ni += line_length;\r\n}\r\nbreak;\r\n}\r\ngpio_set_value(par->gpio.dc, 1);\r\nret = par->fbtftops.write(par, par->txbuf.buf, len / 2);\r\nbreak;\r\ncase 9:\r\nswitch (par->info->var.rotate) {\r\ncase 90:\r\ncase 270:\r\ni = y_start * line_length;\r\nfor (y = y_start; y <= y_end; y++) {\r\nfor (x = 0; x < line_length; x += 2) {\r\n*buf16 = 0x100;\r\n*buf16 |= vmem8[i] >> 4;\r\n*buf16 |= vmem8[i + 1] & 0xF0;\r\nbuf16++;\r\ni += 2;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\ny_start &= 0xFE;\r\ni = y_start * line_length;\r\nfor (y = y_start; y <= y_end; y += 2) {\r\nfor (x = 0; x < line_length; x++) {\r\n*buf16 = 0x100;\r\n*buf16 |= vmem8[i] >> 4;\r\n*buf16 |= vmem8[i + line_length] & 0xF0;\r\nbuf16++;\r\ni++;\r\n}\r\ni += line_length;\r\n}\r\nbreak;\r\n}\r\nret = par->fbtftops.write(par, par->txbuf.buf, len);\r\nbreak;\r\ndefault:\r\ndev_err(par->info->device, "unsupported buswidth %d\n",\r\npar->pdata->display.buswidth);\r\n}\r\nif (ret < 0)\r\ndev_err(par->info->device, "write failed and returned: %d\n",\r\nret);\r\nreturn ret;\r\n}
