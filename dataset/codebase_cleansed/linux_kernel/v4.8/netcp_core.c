static void get_pkt_info(dma_addr_t *buff, u32 *buff_len, dma_addr_t *ndesc,\r\nstruct knav_dma_desc *desc)\r\n{\r\n*buff_len = le32_to_cpu(desc->buff_len);\r\n*buff = le32_to_cpu(desc->buff);\r\n*ndesc = le32_to_cpu(desc->next_desc);\r\n}\r\nstatic u32 get_sw_data(int index, struct knav_dma_desc *desc)\r\n{\r\nreturn desc->sw_data[index];\r\n}\r\nstatic void get_org_pkt_info(dma_addr_t *buff, u32 *buff_len,\r\nstruct knav_dma_desc *desc)\r\n{\r\n*buff = le32_to_cpu(desc->orig_buff);\r\n*buff_len = le32_to_cpu(desc->orig_len);\r\n}\r\nstatic void get_words(dma_addr_t *words, int num_words, __le32 *desc)\r\n{\r\nint i;\r\nfor (i = 0; i < num_words; i++)\r\nwords[i] = le32_to_cpu(desc[i]);\r\n}\r\nstatic void set_pkt_info(dma_addr_t buff, u32 buff_len, u32 ndesc,\r\nstruct knav_dma_desc *desc)\r\n{\r\ndesc->buff_len = cpu_to_le32(buff_len);\r\ndesc->buff = cpu_to_le32(buff);\r\ndesc->next_desc = cpu_to_le32(ndesc);\r\n}\r\nstatic void set_desc_info(u32 desc_info, u32 pkt_info,\r\nstruct knav_dma_desc *desc)\r\n{\r\ndesc->desc_info = cpu_to_le32(desc_info);\r\ndesc->packet_info = cpu_to_le32(pkt_info);\r\n}\r\nstatic void set_sw_data(int index, u32 data, struct knav_dma_desc *desc)\r\n{\r\ndesc->sw_data[index] = data;\r\n}\r\nstatic void set_org_pkt_info(dma_addr_t buff, u32 buff_len,\r\nstruct knav_dma_desc *desc)\r\n{\r\ndesc->orig_buff = cpu_to_le32(buff);\r\ndesc->orig_len = cpu_to_le32(buff_len);\r\n}\r\nstatic void set_words(u32 *words, int num_words, __le32 *desc)\r\n{\r\nint i;\r\nfor (i = 0; i < num_words; i++)\r\ndesc[i] = cpu_to_le32(words[i]);\r\n}\r\nstatic int emac_arch_get_mac_addr(char *x, void __iomem *efuse_mac, u32 swap)\r\n{\r\nunsigned int addr0, addr1;\r\naddr1 = readl(efuse_mac + 4);\r\naddr0 = readl(efuse_mac);\r\nswitch (swap) {\r\ncase NETCP_EFUSE_ADDR_SWAP:\r\naddr0 = addr1;\r\naddr1 = readl(efuse_mac);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nx[0] = (addr1 & 0x0000ff00) >> 8;\r\nx[1] = addr1 & 0x000000ff;\r\nx[2] = (addr0 & 0xff000000) >> 24;\r\nx[3] = (addr0 & 0x00ff0000) >> 16;\r\nx[4] = (addr0 & 0x0000ff00) >> 8;\r\nx[5] = addr0 & 0x000000ff;\r\nreturn 0;\r\n}\r\nstatic const char *netcp_node_name(struct device_node *node)\r\n{\r\nconst char *name;\r\nif (of_property_read_string(node, "label", &name) < 0)\r\nname = node->name;\r\nif (!name)\r\nname = "unknown";\r\nreturn name;\r\n}\r\nstatic int netcp_register_interface(struct netcp_intf *netcp)\r\n{\r\nint ret;\r\nret = register_netdev(netcp->ndev);\r\nif (!ret)\r\nnetcp->netdev_registered = true;\r\nreturn ret;\r\n}\r\nstatic int netcp_module_probe(struct netcp_device *netcp_device,\r\nstruct netcp_module *module)\r\n{\r\nstruct device *dev = netcp_device->device;\r\nstruct device_node *devices, *interface, *node = dev->of_node;\r\nstruct device_node *child;\r\nstruct netcp_inst_modpriv *inst_modpriv;\r\nstruct netcp_intf *netcp_intf;\r\nstruct netcp_module *tmp;\r\nbool primary_module_registered = false;\r\nint ret;\r\ndevices = of_get_child_by_name(node, "netcp-devices");\r\nif (!devices) {\r\ndev_err(dev, "could not find netcp-devices node\n");\r\nreturn NETCP_MOD_PROBE_SKIPPED;\r\n}\r\nfor_each_available_child_of_node(devices, child) {\r\nconst char *name = netcp_node_name(child);\r\nif (!strcasecmp(module->name, name))\r\nbreak;\r\n}\r\nof_node_put(devices);\r\nif (!child) {\r\ndev_warn(dev, "module(%s) not used for device\n", module->name);\r\nreturn NETCP_MOD_PROBE_SKIPPED;\r\n}\r\ninst_modpriv = devm_kzalloc(dev, sizeof(*inst_modpriv), GFP_KERNEL);\r\nif (!inst_modpriv) {\r\nof_node_put(child);\r\nreturn -ENOMEM;\r\n}\r\ninst_modpriv->netcp_device = netcp_device;\r\ninst_modpriv->netcp_module = module;\r\nlist_add_tail(&inst_modpriv->inst_list, &netcp_device->modpriv_head);\r\nret = module->probe(netcp_device, dev, child,\r\n&inst_modpriv->module_priv);\r\nof_node_put(child);\r\nif (ret) {\r\ndev_err(dev, "Probe of module(%s) failed with %d\n",\r\nmodule->name, ret);\r\nlist_del(&inst_modpriv->inst_list);\r\ndevm_kfree(dev, inst_modpriv);\r\nreturn NETCP_MOD_PROBE_FAILED;\r\n}\r\nfor_each_netcp_module(tmp) {\r\nif (tmp->primary)\r\nprimary_module_registered = true;\r\n}\r\nif (!primary_module_registered)\r\nreturn 0;\r\nlist_for_each_entry(netcp_intf, &netcp_device->interface_head,\r\ninterface_list) {\r\nstruct netcp_intf_modpriv *intf_modpriv;\r\nintf_modpriv = devm_kzalloc(dev, sizeof(*intf_modpriv),\r\nGFP_KERNEL);\r\nif (!intf_modpriv)\r\nreturn -ENOMEM;\r\ninterface = of_parse_phandle(netcp_intf->node_interface,\r\nmodule->name, 0);\r\nif (!interface) {\r\ndevm_kfree(dev, intf_modpriv);\r\ncontinue;\r\n}\r\nintf_modpriv->netcp_priv = netcp_intf;\r\nintf_modpriv->netcp_module = module;\r\nlist_add_tail(&intf_modpriv->intf_list,\r\n&netcp_intf->module_head);\r\nret = module->attach(inst_modpriv->module_priv,\r\nnetcp_intf->ndev, interface,\r\n&intf_modpriv->module_priv);\r\nof_node_put(interface);\r\nif (ret) {\r\ndev_dbg(dev, "Attach of module %s declined with %d\n",\r\nmodule->name, ret);\r\nlist_del(&intf_modpriv->intf_list);\r\ndevm_kfree(dev, intf_modpriv);\r\ncontinue;\r\n}\r\n}\r\nlist_for_each_entry(netcp_intf,\r\n&netcp_device->interface_head,\r\ninterface_list) {\r\nif (!netcp_intf->netdev_registered) {\r\nret = netcp_register_interface(netcp_intf);\r\nif (ret)\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint netcp_register_module(struct netcp_module *module)\r\n{\r\nstruct netcp_device *netcp_device;\r\nstruct netcp_module *tmp;\r\nint ret;\r\nif (!module->name) {\r\nWARN(1, "error registering netcp module: no name\n");\r\nreturn -EINVAL;\r\n}\r\nif (!module->probe) {\r\nWARN(1, "error registering netcp module: no probe\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&netcp_modules_lock);\r\nfor_each_netcp_module(tmp) {\r\nif (!strcasecmp(tmp->name, module->name)) {\r\nmutex_unlock(&netcp_modules_lock);\r\nreturn -EEXIST;\r\n}\r\n}\r\nlist_add_tail(&module->module_list, &netcp_modules);\r\nlist_for_each_entry(netcp_device, &netcp_devices, device_list) {\r\nret = netcp_module_probe(netcp_device, module);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\nmutex_unlock(&netcp_modules_lock);\r\nreturn 0;\r\nfail:\r\nmutex_unlock(&netcp_modules_lock);\r\nnetcp_unregister_module(module);\r\nreturn ret;\r\n}\r\nstatic void netcp_release_module(struct netcp_device *netcp_device,\r\nstruct netcp_module *module)\r\n{\r\nstruct netcp_inst_modpriv *inst_modpriv, *inst_tmp;\r\nstruct netcp_intf *netcp_intf, *netcp_tmp;\r\nstruct device *dev = netcp_device->device;\r\nlist_for_each_entry_safe(netcp_intf, netcp_tmp,\r\n&netcp_device->interface_head,\r\ninterface_list) {\r\nstruct netcp_intf_modpriv *intf_modpriv, *intf_tmp;\r\nlist_for_each_entry_safe(intf_modpriv, intf_tmp,\r\n&netcp_intf->module_head,\r\nintf_list) {\r\nif (intf_modpriv->netcp_module == module) {\r\nmodule->release(intf_modpriv->module_priv);\r\nlist_del(&intf_modpriv->intf_list);\r\ndevm_kfree(dev, intf_modpriv);\r\nbreak;\r\n}\r\n}\r\n}\r\nlist_for_each_entry_safe(inst_modpriv, inst_tmp,\r\n&netcp_device->modpriv_head, inst_list) {\r\nif (inst_modpriv->netcp_module == module) {\r\nmodule->remove(netcp_device,\r\ninst_modpriv->module_priv);\r\nlist_del(&inst_modpriv->inst_list);\r\ndevm_kfree(dev, inst_modpriv);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid netcp_unregister_module(struct netcp_module *module)\r\n{\r\nstruct netcp_device *netcp_device;\r\nstruct netcp_module *module_tmp;\r\nmutex_lock(&netcp_modules_lock);\r\nlist_for_each_entry(netcp_device, &netcp_devices, device_list) {\r\nnetcp_release_module(netcp_device, module);\r\n}\r\nfor_each_netcp_module(module_tmp) {\r\nif (module == module_tmp) {\r\nlist_del(&module->module_list);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&netcp_modules_lock);\r\n}\r\nvoid *netcp_module_get_intf_data(struct netcp_module *module,\r\nstruct netcp_intf *intf)\r\n{\r\nstruct netcp_intf_modpriv *intf_modpriv;\r\nlist_for_each_entry(intf_modpriv, &intf->module_head, intf_list)\r\nif (intf_modpriv->netcp_module == module)\r\nreturn intf_modpriv->module_priv;\r\nreturn NULL;\r\n}\r\nint netcp_register_txhook(struct netcp_intf *netcp_priv, int order,\r\nnetcp_hook_rtn *hook_rtn, void *hook_data)\r\n{\r\nstruct netcp_hook_list *entry;\r\nstruct netcp_hook_list *next;\r\nunsigned long flags;\r\nentry = devm_kzalloc(netcp_priv->dev, sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->hook_rtn = hook_rtn;\r\nentry->hook_data = hook_data;\r\nentry->order = order;\r\nspin_lock_irqsave(&netcp_priv->lock, flags);\r\nlist_for_each_entry(next, &netcp_priv->txhook_list_head, list) {\r\nif (next->order > order)\r\nbreak;\r\n}\r\n__list_add(&entry->list, next->list.prev, &next->list);\r\nspin_unlock_irqrestore(&netcp_priv->lock, flags);\r\nreturn 0;\r\n}\r\nint netcp_unregister_txhook(struct netcp_intf *netcp_priv, int order,\r\nnetcp_hook_rtn *hook_rtn, void *hook_data)\r\n{\r\nstruct netcp_hook_list *next, *n;\r\nunsigned long flags;\r\nspin_lock_irqsave(&netcp_priv->lock, flags);\r\nlist_for_each_entry_safe(next, n, &netcp_priv->txhook_list_head, list) {\r\nif ((next->order == order) &&\r\n(next->hook_rtn == hook_rtn) &&\r\n(next->hook_data == hook_data)) {\r\nlist_del(&next->list);\r\nspin_unlock_irqrestore(&netcp_priv->lock, flags);\r\ndevm_kfree(netcp_priv->dev, next);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&netcp_priv->lock, flags);\r\nreturn -ENOENT;\r\n}\r\nint netcp_register_rxhook(struct netcp_intf *netcp_priv, int order,\r\nnetcp_hook_rtn *hook_rtn, void *hook_data)\r\n{\r\nstruct netcp_hook_list *entry;\r\nstruct netcp_hook_list *next;\r\nunsigned long flags;\r\nentry = devm_kzalloc(netcp_priv->dev, sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->hook_rtn = hook_rtn;\r\nentry->hook_data = hook_data;\r\nentry->order = order;\r\nspin_lock_irqsave(&netcp_priv->lock, flags);\r\nlist_for_each_entry(next, &netcp_priv->rxhook_list_head, list) {\r\nif (next->order > order)\r\nbreak;\r\n}\r\n__list_add(&entry->list, next->list.prev, &next->list);\r\nspin_unlock_irqrestore(&netcp_priv->lock, flags);\r\nreturn 0;\r\n}\r\nint netcp_unregister_rxhook(struct netcp_intf *netcp_priv, int order,\r\nnetcp_hook_rtn *hook_rtn, void *hook_data)\r\n{\r\nstruct netcp_hook_list *next, *n;\r\nunsigned long flags;\r\nspin_lock_irqsave(&netcp_priv->lock, flags);\r\nlist_for_each_entry_safe(next, n, &netcp_priv->rxhook_list_head, list) {\r\nif ((next->order == order) &&\r\n(next->hook_rtn == hook_rtn) &&\r\n(next->hook_data == hook_data)) {\r\nlist_del(&next->list);\r\nspin_unlock_irqrestore(&netcp_priv->lock, flags);\r\ndevm_kfree(netcp_priv->dev, next);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&netcp_priv->lock, flags);\r\nreturn -ENOENT;\r\n}\r\nstatic void netcp_frag_free(bool is_frag, void *ptr)\r\n{\r\nif (is_frag)\r\nskb_free_frag(ptr);\r\nelse\r\nkfree(ptr);\r\n}\r\nstatic void netcp_free_rx_desc_chain(struct netcp_intf *netcp,\r\nstruct knav_dma_desc *desc)\r\n{\r\nstruct knav_dma_desc *ndesc;\r\ndma_addr_t dma_desc, dma_buf;\r\nunsigned int buf_len, dma_sz = sizeof(*ndesc);\r\nvoid *buf_ptr;\r\nu32 tmp;\r\nget_words(&dma_desc, 1, &desc->next_desc);\r\nwhile (dma_desc) {\r\nndesc = knav_pool_desc_unmap(netcp->rx_pool, dma_desc, dma_sz);\r\nif (unlikely(!ndesc)) {\r\ndev_err(netcp->ndev_dev, "failed to unmap Rx desc\n");\r\nbreak;\r\n}\r\nget_pkt_info(&dma_buf, &tmp, &dma_desc, ndesc);\r\nbuf_ptr = (void *)GET_SW_DATA0(ndesc);\r\nbuf_len = (int)GET_SW_DATA1(desc);\r\ndma_unmap_page(netcp->dev, dma_buf, PAGE_SIZE, DMA_FROM_DEVICE);\r\n__free_page(buf_ptr);\r\nknav_pool_desc_put(netcp->rx_pool, desc);\r\n}\r\nbuf_ptr = (void *)GET_SW_DATA0(desc);\r\nbuf_len = (int)GET_SW_DATA1(desc);\r\nif (buf_ptr)\r\nnetcp_frag_free(buf_len <= PAGE_SIZE, buf_ptr);\r\nknav_pool_desc_put(netcp->rx_pool, desc);\r\n}\r\nstatic void netcp_empty_rx_queue(struct netcp_intf *netcp)\r\n{\r\nstruct knav_dma_desc *desc;\r\nunsigned int dma_sz;\r\ndma_addr_t dma;\r\nfor (; ;) {\r\ndma = knav_queue_pop(netcp->rx_queue, &dma_sz);\r\nif (!dma)\r\nbreak;\r\ndesc = knav_pool_desc_unmap(netcp->rx_pool, dma, dma_sz);\r\nif (unlikely(!desc)) {\r\ndev_err(netcp->ndev_dev, "%s: failed to unmap Rx desc\n",\r\n__func__);\r\nnetcp->ndev->stats.rx_errors++;\r\ncontinue;\r\n}\r\nnetcp_free_rx_desc_chain(netcp, desc);\r\nnetcp->ndev->stats.rx_dropped++;\r\n}\r\n}\r\nstatic int netcp_process_one_rx_packet(struct netcp_intf *netcp)\r\n{\r\nunsigned int dma_sz, buf_len, org_buf_len;\r\nstruct knav_dma_desc *desc, *ndesc;\r\nunsigned int pkt_sz = 0, accum_sz;\r\nstruct netcp_hook_list *rx_hook;\r\ndma_addr_t dma_desc, dma_buff;\r\nstruct netcp_packet p_info;\r\nstruct sk_buff *skb;\r\nvoid *org_buf_ptr;\r\ndma_desc = knav_queue_pop(netcp->rx_queue, &dma_sz);\r\nif (!dma_desc)\r\nreturn -1;\r\ndesc = knav_pool_desc_unmap(netcp->rx_pool, dma_desc, dma_sz);\r\nif (unlikely(!desc)) {\r\ndev_err(netcp->ndev_dev, "failed to unmap Rx desc\n");\r\nreturn 0;\r\n}\r\nget_pkt_info(&dma_buff, &buf_len, &dma_desc, desc);\r\norg_buf_ptr = (void *)GET_SW_DATA0(desc);\r\norg_buf_len = (int)GET_SW_DATA1(desc);\r\nif (unlikely(!org_buf_ptr)) {\r\ndev_err(netcp->ndev_dev, "NULL bufptr in desc\n");\r\ngoto free_desc;\r\n}\r\npkt_sz &= KNAV_DMA_DESC_PKT_LEN_MASK;\r\naccum_sz = buf_len;\r\ndma_unmap_single(netcp->dev, dma_buff, buf_len, DMA_FROM_DEVICE);\r\nskb = build_skb(org_buf_ptr, org_buf_len);\r\nif (unlikely(!skb)) {\r\ndev_err(netcp->ndev_dev, "build_skb() failed\n");\r\ngoto free_desc;\r\n}\r\nskb_reserve(skb, NETCP_SOP_OFFSET);\r\n__skb_put(skb, buf_len);\r\nwhile (dma_desc) {\r\nstruct page *page;\r\nndesc = knav_pool_desc_unmap(netcp->rx_pool, dma_desc, dma_sz);\r\nif (unlikely(!ndesc)) {\r\ndev_err(netcp->ndev_dev, "failed to unmap Rx desc\n");\r\ngoto free_desc;\r\n}\r\nget_pkt_info(&dma_buff, &buf_len, &dma_desc, ndesc);\r\npage = (struct page *)GET_SW_DATA0(desc);\r\nif (likely(dma_buff && buf_len && page)) {\r\ndma_unmap_page(netcp->dev, dma_buff, PAGE_SIZE,\r\nDMA_FROM_DEVICE);\r\n} else {\r\ndev_err(netcp->ndev_dev, "Bad Rx desc dma_buff(%pad), len(%d), page(%p)\n",\r\n&dma_buff, buf_len, page);\r\ngoto free_desc;\r\n}\r\nskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\r\noffset_in_page(dma_buff), buf_len, PAGE_SIZE);\r\naccum_sz += buf_len;\r\nknav_pool_desc_put(netcp->rx_pool, ndesc);\r\n}\r\nknav_pool_desc_put(netcp->rx_pool, desc);\r\nif (unlikely(pkt_sz != accum_sz))\r\ndev_dbg(netcp->ndev_dev, "mismatch in packet size(%d) & sum of fragments(%d)\n",\r\npkt_sz, accum_sz);\r\n__pskb_trim(skb, skb->len - ETH_FCS_LEN);\r\np_info.skb = skb;\r\np_info.rxtstamp_complete = false;\r\nlist_for_each_entry(rx_hook, &netcp->rxhook_list_head, list) {\r\nint ret;\r\nret = rx_hook->hook_rtn(rx_hook->order, rx_hook->hook_data,\r\n&p_info);\r\nif (unlikely(ret)) {\r\ndev_err(netcp->ndev_dev, "RX hook %d failed: %d\n",\r\nrx_hook->order, ret);\r\nnetcp->ndev->stats.rx_errors++;\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\n}\r\nnetcp->ndev->stats.rx_packets++;\r\nnetcp->ndev->stats.rx_bytes += skb->len;\r\nskb->protocol = eth_type_trans(skb, netcp->ndev);\r\nnetif_receive_skb(skb);\r\nreturn 0;\r\nfree_desc:\r\nnetcp_free_rx_desc_chain(netcp, desc);\r\nnetcp->ndev->stats.rx_errors++;\r\nreturn 0;\r\n}\r\nstatic int netcp_process_rx_packets(struct netcp_intf *netcp,\r\nunsigned int budget)\r\n{\r\nint i;\r\nfor (i = 0; (i < budget) && !netcp_process_one_rx_packet(netcp); i++)\r\n;\r\nreturn i;\r\n}\r\nstatic void netcp_free_rx_buf(struct netcp_intf *netcp, int fdq)\r\n{\r\nstruct knav_dma_desc *desc;\r\nunsigned int buf_len, dma_sz;\r\ndma_addr_t dma;\r\nvoid *buf_ptr;\r\nwhile ((dma = knav_queue_pop(netcp->rx_fdq[fdq], &dma_sz))) {\r\ndesc = knav_pool_desc_unmap(netcp->rx_pool, dma, dma_sz);\r\nif (unlikely(!desc)) {\r\ndev_err(netcp->ndev_dev, "failed to unmap Rx desc\n");\r\ncontinue;\r\n}\r\nget_org_pkt_info(&dma, &buf_len, desc);\r\nbuf_ptr = (void *)GET_SW_DATA0(desc);\r\nif (unlikely(!dma)) {\r\ndev_err(netcp->ndev_dev, "NULL orig_buff in desc\n");\r\nknav_pool_desc_put(netcp->rx_pool, desc);\r\ncontinue;\r\n}\r\nif (unlikely(!buf_ptr)) {\r\ndev_err(netcp->ndev_dev, "NULL bufptr in desc\n");\r\nknav_pool_desc_put(netcp->rx_pool, desc);\r\ncontinue;\r\n}\r\nif (fdq == 0) {\r\ndma_unmap_single(netcp->dev, dma, buf_len,\r\nDMA_FROM_DEVICE);\r\nnetcp_frag_free((buf_len <= PAGE_SIZE), buf_ptr);\r\n} else {\r\ndma_unmap_page(netcp->dev, dma, buf_len,\r\nDMA_FROM_DEVICE);\r\n__free_page(buf_ptr);\r\n}\r\nknav_pool_desc_put(netcp->rx_pool, desc);\r\n}\r\n}\r\nstatic void netcp_rxpool_free(struct netcp_intf *netcp)\r\n{\r\nint i;\r\nfor (i = 0; i < KNAV_DMA_FDQ_PER_CHAN &&\r\n!IS_ERR_OR_NULL(netcp->rx_fdq[i]); i++)\r\nnetcp_free_rx_buf(netcp, i);\r\nif (knav_pool_count(netcp->rx_pool) != netcp->rx_pool_size)\r\ndev_err(netcp->ndev_dev, "Lost Rx (%d) descriptors\n",\r\nnetcp->rx_pool_size - knav_pool_count(netcp->rx_pool));\r\nknav_pool_destroy(netcp->rx_pool);\r\nnetcp->rx_pool = NULL;\r\n}\r\nstatic int netcp_allocate_rx_buf(struct netcp_intf *netcp, int fdq)\r\n{\r\nstruct knav_dma_desc *hwdesc;\r\nunsigned int buf_len, dma_sz;\r\nu32 desc_info, pkt_info;\r\nstruct page *page;\r\ndma_addr_t dma;\r\nvoid *bufptr;\r\nu32 sw_data[2];\r\nhwdesc = knav_pool_desc_get(netcp->rx_pool);\r\nif (IS_ERR_OR_NULL(hwdesc)) {\r\ndev_dbg(netcp->ndev_dev, "out of rx pool desc\n");\r\nreturn -ENOMEM;\r\n}\r\nif (likely(fdq == 0)) {\r\nunsigned int primary_buf_len;\r\nbuf_len = NETCP_PACKET_SIZE + NETCP_SOP_OFFSET;\r\nprimary_buf_len = SKB_DATA_ALIGN(buf_len) +\r\nSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\r\nbufptr = netdev_alloc_frag(primary_buf_len);\r\nsw_data[1] = primary_buf_len;\r\nif (unlikely(!bufptr)) {\r\ndev_warn_ratelimited(netcp->ndev_dev,\r\n"Primary RX buffer alloc failed\n");\r\ngoto fail;\r\n}\r\ndma = dma_map_single(netcp->dev, bufptr, buf_len,\r\nDMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(netcp->dev, dma)))\r\ngoto fail;\r\nsw_data[0] = (u32)bufptr;\r\n} else {\r\npage = alloc_page(GFP_ATOMIC | GFP_DMA | __GFP_COLD);\r\nif (unlikely(!page)) {\r\ndev_warn_ratelimited(netcp->ndev_dev, "Secondary page alloc failed\n");\r\ngoto fail;\r\n}\r\nbuf_len = PAGE_SIZE;\r\ndma = dma_map_page(netcp->dev, page, 0, buf_len, DMA_TO_DEVICE);\r\nsw_data[0] = (u32)page;\r\nsw_data[1] = 0;\r\n}\r\ndesc_info = KNAV_DMA_DESC_PS_INFO_IN_DESC;\r\ndesc_info |= buf_len & KNAV_DMA_DESC_PKT_LEN_MASK;\r\npkt_info = KNAV_DMA_DESC_HAS_EPIB;\r\npkt_info |= KNAV_DMA_NUM_PS_WORDS << KNAV_DMA_DESC_PSLEN_SHIFT;\r\npkt_info |= (netcp->rx_queue_id & KNAV_DMA_DESC_RETQ_MASK) <<\r\nKNAV_DMA_DESC_RETQ_SHIFT;\r\nset_org_pkt_info(dma, buf_len, hwdesc);\r\nSET_SW_DATA0(sw_data[0], hwdesc);\r\nSET_SW_DATA1(sw_data[1], hwdesc);\r\nset_desc_info(desc_info, pkt_info, hwdesc);\r\nknav_pool_desc_map(netcp->rx_pool, hwdesc, sizeof(*hwdesc), &dma,\r\n&dma_sz);\r\nknav_queue_push(netcp->rx_fdq[fdq], dma, sizeof(*hwdesc), 0);\r\nreturn 0;\r\nfail:\r\nknav_pool_desc_put(netcp->rx_pool, hwdesc);\r\nreturn -ENOMEM;\r\n}\r\nstatic void netcp_rxpool_refill(struct netcp_intf *netcp)\r\n{\r\nu32 fdq_deficit[KNAV_DMA_FDQ_PER_CHAN] = {0};\r\nint i, ret = 0;\r\nfor (i = 0; i < KNAV_DMA_FDQ_PER_CHAN && netcp->rx_fdq[i]; i++) {\r\nfdq_deficit[i] = netcp->rx_queue_depths[i] -\r\nknav_queue_get_count(netcp->rx_fdq[i]);\r\nwhile (fdq_deficit[i]-- && !ret)\r\nret = netcp_allocate_rx_buf(netcp, i);\r\n}\r\n}\r\nstatic int netcp_rx_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct netcp_intf *netcp = container_of(napi, struct netcp_intf,\r\nrx_napi);\r\nunsigned int packets;\r\npackets = netcp_process_rx_packets(netcp, budget);\r\nnetcp_rxpool_refill(netcp);\r\nif (packets < budget) {\r\nnapi_complete(&netcp->rx_napi);\r\nknav_queue_enable_notify(netcp->rx_queue);\r\n}\r\nreturn packets;\r\n}\r\nstatic void netcp_rx_notify(void *arg)\r\n{\r\nstruct netcp_intf *netcp = arg;\r\nknav_queue_disable_notify(netcp->rx_queue);\r\nnapi_schedule(&netcp->rx_napi);\r\n}\r\nstatic void netcp_free_tx_desc_chain(struct netcp_intf *netcp,\r\nstruct knav_dma_desc *desc,\r\nunsigned int desc_sz)\r\n{\r\nstruct knav_dma_desc *ndesc = desc;\r\ndma_addr_t dma_desc, dma_buf;\r\nunsigned int buf_len;\r\nwhile (ndesc) {\r\nget_pkt_info(&dma_buf, &buf_len, &dma_desc, ndesc);\r\nif (dma_buf && buf_len)\r\ndma_unmap_single(netcp->dev, dma_buf, buf_len,\r\nDMA_TO_DEVICE);\r\nelse\r\ndev_warn(netcp->ndev_dev, "bad Tx desc buf(%pad), len(%d)\n",\r\n&dma_buf, buf_len);\r\nknav_pool_desc_put(netcp->tx_pool, ndesc);\r\nndesc = NULL;\r\nif (dma_desc) {\r\nndesc = knav_pool_desc_unmap(netcp->tx_pool, dma_desc,\r\ndesc_sz);\r\nif (!ndesc)\r\ndev_err(netcp->ndev_dev, "failed to unmap Tx desc\n");\r\n}\r\n}\r\n}\r\nstatic int netcp_process_tx_compl_packets(struct netcp_intf *netcp,\r\nunsigned int budget)\r\n{\r\nstruct knav_dma_desc *desc;\r\nstruct sk_buff *skb;\r\nunsigned int dma_sz;\r\ndma_addr_t dma;\r\nint pkts = 0;\r\nwhile (budget--) {\r\ndma = knav_queue_pop(netcp->tx_compl_q, &dma_sz);\r\nif (!dma)\r\nbreak;\r\ndesc = knav_pool_desc_unmap(netcp->tx_pool, dma, dma_sz);\r\nif (unlikely(!desc)) {\r\ndev_err(netcp->ndev_dev, "failed to unmap Tx desc\n");\r\nnetcp->ndev->stats.tx_errors++;\r\ncontinue;\r\n}\r\nskb = (struct sk_buff *)GET_SW_DATA0(desc);\r\nnetcp_free_tx_desc_chain(netcp, desc, dma_sz);\r\nif (!skb) {\r\ndev_err(netcp->ndev_dev, "No skb in Tx desc\n");\r\nnetcp->ndev->stats.tx_errors++;\r\ncontinue;\r\n}\r\nif (netif_subqueue_stopped(netcp->ndev, skb) &&\r\nnetif_running(netcp->ndev) &&\r\n(knav_pool_count(netcp->tx_pool) >\r\nnetcp->tx_resume_threshold)) {\r\nu16 subqueue = skb_get_queue_mapping(skb);\r\nnetif_wake_subqueue(netcp->ndev, subqueue);\r\n}\r\nnetcp->ndev->stats.tx_packets++;\r\nnetcp->ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb(skb);\r\npkts++;\r\n}\r\nreturn pkts;\r\n}\r\nstatic int netcp_tx_poll(struct napi_struct *napi, int budget)\r\n{\r\nint packets;\r\nstruct netcp_intf *netcp = container_of(napi, struct netcp_intf,\r\ntx_napi);\r\npackets = netcp_process_tx_compl_packets(netcp, budget);\r\nif (packets < budget) {\r\nnapi_complete(&netcp->tx_napi);\r\nknav_queue_enable_notify(netcp->tx_compl_q);\r\n}\r\nreturn packets;\r\n}\r\nstatic void netcp_tx_notify(void *arg)\r\n{\r\nstruct netcp_intf *netcp = arg;\r\nknav_queue_disable_notify(netcp->tx_compl_q);\r\nnapi_schedule(&netcp->tx_napi);\r\n}\r\nstatic struct knav_dma_desc*\r\nnetcp_tx_map_skb(struct sk_buff *skb, struct netcp_intf *netcp)\r\n{\r\nstruct knav_dma_desc *desc, *ndesc, *pdesc;\r\nunsigned int pkt_len = skb_headlen(skb);\r\nstruct device *dev = netcp->dev;\r\ndma_addr_t dma_addr;\r\nunsigned int dma_sz;\r\nint i;\r\ndma_addr = dma_map_single(dev, skb->data, pkt_len, DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(dev, dma_addr))) {\r\ndev_err(netcp->ndev_dev, "Failed to map skb buffer\n");\r\nreturn NULL;\r\n}\r\ndesc = knav_pool_desc_get(netcp->tx_pool);\r\nif (IS_ERR_OR_NULL(desc)) {\r\ndev_err(netcp->ndev_dev, "out of TX desc\n");\r\ndma_unmap_single(dev, dma_addr, pkt_len, DMA_TO_DEVICE);\r\nreturn NULL;\r\n}\r\nset_pkt_info(dma_addr, pkt_len, 0, desc);\r\nif (skb_is_nonlinear(skb)) {\r\nprefetchw(skb_shinfo(skb));\r\n} else {\r\ndesc->next_desc = 0;\r\ngoto upd_pkt_len;\r\n}\r\npdesc = desc;\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nstruct page *page = skb_frag_page(frag);\r\nu32 page_offset = frag->page_offset;\r\nu32 buf_len = skb_frag_size(frag);\r\ndma_addr_t desc_dma;\r\nu32 desc_dma_32;\r\nu32 pkt_info;\r\ndma_addr = dma_map_page(dev, page, page_offset, buf_len,\r\nDMA_TO_DEVICE);\r\nif (unlikely(!dma_addr)) {\r\ndev_err(netcp->ndev_dev, "Failed to map skb page\n");\r\ngoto free_descs;\r\n}\r\nndesc = knav_pool_desc_get(netcp->tx_pool);\r\nif (IS_ERR_OR_NULL(ndesc)) {\r\ndev_err(netcp->ndev_dev, "out of TX desc for frags\n");\r\ndma_unmap_page(dev, dma_addr, buf_len, DMA_TO_DEVICE);\r\ngoto free_descs;\r\n}\r\ndesc_dma = knav_pool_desc_virt_to_dma(netcp->tx_pool, ndesc);\r\npkt_info =\r\n(netcp->tx_compl_qid & KNAV_DMA_DESC_RETQ_MASK) <<\r\nKNAV_DMA_DESC_RETQ_SHIFT;\r\nset_pkt_info(dma_addr, buf_len, 0, ndesc);\r\ndesc_dma_32 = (u32)desc_dma;\r\nset_words(&desc_dma_32, 1, &pdesc->next_desc);\r\npkt_len += buf_len;\r\nif (pdesc != desc)\r\nknav_pool_desc_map(netcp->tx_pool, pdesc,\r\nsizeof(*pdesc), &desc_dma, &dma_sz);\r\npdesc = ndesc;\r\n}\r\nif (pdesc != desc)\r\nknav_pool_desc_map(netcp->tx_pool, pdesc, sizeof(*pdesc),\r\n&dma_addr, &dma_sz);\r\nif (skb_shinfo(skb)->frag_list) {\r\ndev_err_ratelimited(netcp->ndev_dev, "NETIF_F_FRAGLIST not supported\n");\r\ngoto free_descs;\r\n}\r\nupd_pkt_len:\r\nWARN_ON(pkt_len != skb->len);\r\npkt_len &= KNAV_DMA_DESC_PKT_LEN_MASK;\r\nset_words(&pkt_len, 1, &desc->desc_info);\r\nreturn desc;\r\nfree_descs:\r\nnetcp_free_tx_desc_chain(netcp, desc, sizeof(*desc));\r\nreturn NULL;\r\n}\r\nstatic int netcp_tx_submit_skb(struct netcp_intf *netcp,\r\nstruct sk_buff *skb,\r\nstruct knav_dma_desc *desc)\r\n{\r\nstruct netcp_tx_pipe *tx_pipe = NULL;\r\nstruct netcp_hook_list *tx_hook;\r\nstruct netcp_packet p_info;\r\nunsigned int dma_sz;\r\ndma_addr_t dma;\r\nu32 tmp = 0;\r\nint ret = 0;\r\np_info.netcp = netcp;\r\np_info.skb = skb;\r\np_info.tx_pipe = NULL;\r\np_info.psdata_len = 0;\r\np_info.ts_context = NULL;\r\np_info.txtstamp_complete = NULL;\r\np_info.epib = desc->epib;\r\np_info.psdata = (u32 __force *)desc->psdata;\r\nmemset(p_info.epib, 0, KNAV_DMA_NUM_EPIB_WORDS * sizeof(__le32));\r\nlist_for_each_entry(tx_hook, &netcp->txhook_list_head, list) {\r\nret = tx_hook->hook_rtn(tx_hook->order, tx_hook->hook_data,\r\n&p_info);\r\nif (unlikely(ret != 0)) {\r\ndev_err(netcp->ndev_dev, "TX hook %d rejected the packet with reason(%d)\n",\r\ntx_hook->order, ret);\r\nret = (ret < 0) ? ret : NETDEV_TX_OK;\r\ngoto out;\r\n}\r\n}\r\ntx_pipe = p_info.tx_pipe;\r\nif (!tx_pipe) {\r\ndev_err(netcp->ndev_dev, "No TX hook claimed the packet!\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif (p_info.psdata_len) {\r\n__le32 *psdata = (void __force *)p_info.psdata;\r\nmemmove(p_info.psdata, p_info.psdata + p_info.psdata_len,\r\np_info.psdata_len);\r\nset_words(p_info.psdata, p_info.psdata_len, psdata);\r\ntmp |= (p_info.psdata_len & KNAV_DMA_DESC_PSLEN_MASK) <<\r\nKNAV_DMA_DESC_PSLEN_SHIFT;\r\n}\r\ntmp |= KNAV_DMA_DESC_HAS_EPIB |\r\n((netcp->tx_compl_qid & KNAV_DMA_DESC_RETQ_MASK) <<\r\nKNAV_DMA_DESC_RETQ_SHIFT);\r\nif (!(tx_pipe->flags & SWITCH_TO_PORT_IN_TAGINFO)) {\r\ntmp |= ((tx_pipe->switch_to_port & KNAV_DMA_DESC_PSFLAG_MASK) <<\r\nKNAV_DMA_DESC_PSFLAG_SHIFT);\r\n}\r\nset_words(&tmp, 1, &desc->packet_info);\r\nSET_SW_DATA0((u32)skb, desc);\r\nif (tx_pipe->flags & SWITCH_TO_PORT_IN_TAGINFO) {\r\ntmp = tx_pipe->switch_to_port;\r\nset_words(&tmp, 1, &desc->tag_info);\r\n}\r\nret = knav_pool_desc_map(netcp->tx_pool, desc, sizeof(*desc), &dma,\r\n&dma_sz);\r\nif (unlikely(ret)) {\r\ndev_err(netcp->ndev_dev, "%s() failed to map desc\n", __func__);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nskb_tx_timestamp(skb);\r\nknav_queue_push(tx_pipe->dma_queue, dma, dma_sz, 0);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int netcp_ndo_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nint subqueue = skb_get_queue_mapping(skb);\r\nstruct knav_dma_desc *desc;\r\nint desc_count, ret = 0;\r\nif (unlikely(skb->len <= 0)) {\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (unlikely(skb->len < NETCP_MIN_PACKET_SIZE)) {\r\nret = skb_padto(skb, NETCP_MIN_PACKET_SIZE);\r\nif (ret < 0) {\r\ndev_warn(netcp->ndev_dev, "padding failed (%d), packet dropped\n",\r\nret);\r\nndev->stats.tx_dropped++;\r\nreturn ret;\r\n}\r\nskb->len = NETCP_MIN_PACKET_SIZE;\r\n}\r\ndesc = netcp_tx_map_skb(skb, netcp);\r\nif (unlikely(!desc)) {\r\nnetif_stop_subqueue(ndev, subqueue);\r\nret = -ENOBUFS;\r\ngoto drop;\r\n}\r\nret = netcp_tx_submit_skb(netcp, skb, desc);\r\nif (ret)\r\ngoto drop;\r\nnetif_trans_update(ndev);\r\ndesc_count = knav_pool_count(netcp->tx_pool);\r\nif (desc_count < netcp->tx_pause_threshold) {\r\ndev_dbg(netcp->ndev_dev, "pausing tx, count(%d)\n", desc_count);\r\nnetif_stop_subqueue(ndev, subqueue);\r\n}\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\nndev->stats.tx_dropped++;\r\nif (desc)\r\nnetcp_free_tx_desc_chain(netcp, desc, sizeof(*desc));\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nint netcp_txpipe_close(struct netcp_tx_pipe *tx_pipe)\r\n{\r\nif (tx_pipe->dma_channel) {\r\nknav_dma_close_channel(tx_pipe->dma_channel);\r\ntx_pipe->dma_channel = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint netcp_txpipe_open(struct netcp_tx_pipe *tx_pipe)\r\n{\r\nstruct device *dev = tx_pipe->netcp_device->device;\r\nstruct knav_dma_cfg config;\r\nint ret = 0;\r\nu8 name[16];\r\nmemset(&config, 0, sizeof(config));\r\nconfig.direction = DMA_MEM_TO_DEV;\r\nconfig.u.tx.filt_einfo = false;\r\nconfig.u.tx.filt_pswords = false;\r\nconfig.u.tx.priority = DMA_PRIO_MED_L;\r\ntx_pipe->dma_channel = knav_dma_open_channel(dev,\r\ntx_pipe->dma_chan_name, &config);\r\nif (IS_ERR_OR_NULL(tx_pipe->dma_channel)) {\r\ndev_err(dev, "failed opening tx chan(%s)\n",\r\ntx_pipe->dma_chan_name);\r\ngoto err;\r\n}\r\nsnprintf(name, sizeof(name), "tx-pipe-%s", dev_name(dev));\r\ntx_pipe->dma_queue = knav_queue_open(name, tx_pipe->dma_queue_id,\r\nKNAV_QUEUE_SHARED);\r\nif (IS_ERR(tx_pipe->dma_queue)) {\r\ndev_err(dev, "Could not open DMA queue for channel \"%s\": %d\n",\r\nname, ret);\r\nret = PTR_ERR(tx_pipe->dma_queue);\r\ngoto err;\r\n}\r\ndev_dbg(dev, "opened tx pipe %s\n", name);\r\nreturn 0;\r\nerr:\r\nif (!IS_ERR_OR_NULL(tx_pipe->dma_channel))\r\nknav_dma_close_channel(tx_pipe->dma_channel);\r\ntx_pipe->dma_channel = NULL;\r\nreturn ret;\r\n}\r\nint netcp_txpipe_init(struct netcp_tx_pipe *tx_pipe,\r\nstruct netcp_device *netcp_device,\r\nconst char *dma_chan_name, unsigned int dma_queue_id)\r\n{\r\nmemset(tx_pipe, 0, sizeof(*tx_pipe));\r\ntx_pipe->netcp_device = netcp_device;\r\ntx_pipe->dma_chan_name = dma_chan_name;\r\ntx_pipe->dma_queue_id = dma_queue_id;\r\nreturn 0;\r\n}\r\nstatic struct netcp_addr *netcp_addr_find(struct netcp_intf *netcp,\r\nconst u8 *addr,\r\nenum netcp_addr_type type)\r\n{\r\nstruct netcp_addr *naddr;\r\nlist_for_each_entry(naddr, &netcp->addr_list, node) {\r\nif (naddr->type != type)\r\ncontinue;\r\nif (addr && memcmp(addr, naddr->addr, ETH_ALEN))\r\ncontinue;\r\nreturn naddr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct netcp_addr *netcp_addr_add(struct netcp_intf *netcp,\r\nconst u8 *addr,\r\nenum netcp_addr_type type)\r\n{\r\nstruct netcp_addr *naddr;\r\nnaddr = devm_kmalloc(netcp->dev, sizeof(*naddr), GFP_ATOMIC);\r\nif (!naddr)\r\nreturn NULL;\r\nnaddr->type = type;\r\nnaddr->flags = 0;\r\nnaddr->netcp = netcp;\r\nif (addr)\r\nether_addr_copy(naddr->addr, addr);\r\nelse\r\neth_zero_addr(naddr->addr);\r\nlist_add_tail(&naddr->node, &netcp->addr_list);\r\nreturn naddr;\r\n}\r\nstatic void netcp_addr_del(struct netcp_intf *netcp, struct netcp_addr *naddr)\r\n{\r\nlist_del(&naddr->node);\r\ndevm_kfree(netcp->dev, naddr);\r\n}\r\nstatic void netcp_addr_clear_mark(struct netcp_intf *netcp)\r\n{\r\nstruct netcp_addr *naddr;\r\nlist_for_each_entry(naddr, &netcp->addr_list, node)\r\nnaddr->flags = 0;\r\n}\r\nstatic void netcp_addr_add_mark(struct netcp_intf *netcp, const u8 *addr,\r\nenum netcp_addr_type type)\r\n{\r\nstruct netcp_addr *naddr;\r\nnaddr = netcp_addr_find(netcp, addr, type);\r\nif (naddr) {\r\nnaddr->flags |= ADDR_VALID;\r\nreturn;\r\n}\r\nnaddr = netcp_addr_add(netcp, addr, type);\r\nif (!WARN_ON(!naddr))\r\nnaddr->flags |= ADDR_NEW;\r\n}\r\nstatic void netcp_addr_sweep_del(struct netcp_intf *netcp)\r\n{\r\nstruct netcp_addr *naddr, *tmp;\r\nstruct netcp_intf_modpriv *priv;\r\nstruct netcp_module *module;\r\nint error;\r\nlist_for_each_entry_safe(naddr, tmp, &netcp->addr_list, node) {\r\nif (naddr->flags & (ADDR_VALID | ADDR_NEW))\r\ncontinue;\r\ndev_dbg(netcp->ndev_dev, "deleting address %pM, type %x\n",\r\nnaddr->addr, naddr->type);\r\nfor_each_module(netcp, priv) {\r\nmodule = priv->netcp_module;\r\nif (!module->del_addr)\r\ncontinue;\r\nerror = module->del_addr(priv->module_priv,\r\nnaddr);\r\nWARN_ON(error);\r\n}\r\nnetcp_addr_del(netcp, naddr);\r\n}\r\n}\r\nstatic void netcp_addr_sweep_add(struct netcp_intf *netcp)\r\n{\r\nstruct netcp_addr *naddr, *tmp;\r\nstruct netcp_intf_modpriv *priv;\r\nstruct netcp_module *module;\r\nint error;\r\nlist_for_each_entry_safe(naddr, tmp, &netcp->addr_list, node) {\r\nif (!(naddr->flags & ADDR_NEW))\r\ncontinue;\r\ndev_dbg(netcp->ndev_dev, "adding address %pM, type %x\n",\r\nnaddr->addr, naddr->type);\r\nfor_each_module(netcp, priv) {\r\nmodule = priv->netcp_module;\r\nif (!module->add_addr)\r\ncontinue;\r\nerror = module->add_addr(priv->module_priv, naddr);\r\nWARN_ON(error);\r\n}\r\n}\r\n}\r\nstatic void netcp_set_rx_mode(struct net_device *ndev)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct netdev_hw_addr *ndev_addr;\r\nbool promisc;\r\npromisc = (ndev->flags & IFF_PROMISC ||\r\nndev->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(ndev) > NETCP_MAX_MCAST_ADDR);\r\nspin_lock(&netcp->lock);\r\nnetcp_addr_clear_mark(netcp);\r\nnetcp_addr_add_mark(netcp, ndev->broadcast, ADDR_BCAST);\r\nfor_each_dev_addr(ndev, ndev_addr)\r\nnetcp_addr_add_mark(netcp, ndev_addr->addr, ADDR_DEV);\r\nnetdev_for_each_uc_addr(ndev_addr, ndev)\r\nnetcp_addr_add_mark(netcp, ndev_addr->addr, ADDR_UCAST);\r\nnetdev_for_each_mc_addr(ndev_addr, ndev)\r\nnetcp_addr_add_mark(netcp, ndev_addr->addr, ADDR_MCAST);\r\nif (promisc)\r\nnetcp_addr_add_mark(netcp, NULL, ADDR_ANY);\r\nnetcp_addr_sweep_del(netcp);\r\nnetcp_addr_sweep_add(netcp);\r\nspin_unlock(&netcp->lock);\r\n}\r\nstatic void netcp_free_navigator_resources(struct netcp_intf *netcp)\r\n{\r\nint i;\r\nif (netcp->rx_channel) {\r\nknav_dma_close_channel(netcp->rx_channel);\r\nnetcp->rx_channel = NULL;\r\n}\r\nif (!IS_ERR_OR_NULL(netcp->rx_pool))\r\nnetcp_rxpool_free(netcp);\r\nif (!IS_ERR_OR_NULL(netcp->rx_queue)) {\r\nknav_queue_close(netcp->rx_queue);\r\nnetcp->rx_queue = NULL;\r\n}\r\nfor (i = 0; i < KNAV_DMA_FDQ_PER_CHAN &&\r\n!IS_ERR_OR_NULL(netcp->rx_fdq[i]) ; ++i) {\r\nknav_queue_close(netcp->rx_fdq[i]);\r\nnetcp->rx_fdq[i] = NULL;\r\n}\r\nif (!IS_ERR_OR_NULL(netcp->tx_compl_q)) {\r\nknav_queue_close(netcp->tx_compl_q);\r\nnetcp->tx_compl_q = NULL;\r\n}\r\nif (!IS_ERR_OR_NULL(netcp->tx_pool)) {\r\nknav_pool_destroy(netcp->tx_pool);\r\nnetcp->tx_pool = NULL;\r\n}\r\n}\r\nstatic int netcp_setup_navigator_resources(struct net_device *ndev)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct knav_queue_notify_config notify_cfg;\r\nstruct knav_dma_cfg config;\r\nu32 last_fdq = 0;\r\nu8 name[16];\r\nint ret;\r\nint i;\r\nsnprintf(name, sizeof(name), "rx-pool-%s", ndev->name);\r\nnetcp->rx_pool = knav_pool_create(name, netcp->rx_pool_size,\r\nnetcp->rx_pool_region_id);\r\nif (IS_ERR_OR_NULL(netcp->rx_pool)) {\r\ndev_err(netcp->ndev_dev, "Couldn't create rx pool\n");\r\nret = PTR_ERR(netcp->rx_pool);\r\ngoto fail;\r\n}\r\nsnprintf(name, sizeof(name), "tx-pool-%s", ndev->name);\r\nnetcp->tx_pool = knav_pool_create(name, netcp->tx_pool_size,\r\nnetcp->tx_pool_region_id);\r\nif (IS_ERR_OR_NULL(netcp->tx_pool)) {\r\ndev_err(netcp->ndev_dev, "Couldn't create tx pool\n");\r\nret = PTR_ERR(netcp->tx_pool);\r\ngoto fail;\r\n}\r\nsnprintf(name, sizeof(name), "tx-compl-%s", ndev->name);\r\nnetcp->tx_compl_q = knav_queue_open(name, netcp->tx_compl_qid, 0);\r\nif (IS_ERR_OR_NULL(netcp->tx_compl_q)) {\r\nret = PTR_ERR(netcp->tx_compl_q);\r\ngoto fail;\r\n}\r\nnetcp->tx_compl_qid = knav_queue_get_id(netcp->tx_compl_q);\r\nnotify_cfg.fn = netcp_tx_notify;\r\nnotify_cfg.fn_arg = netcp;\r\nret = knav_queue_device_control(netcp->tx_compl_q,\r\nKNAV_QUEUE_SET_NOTIFIER,\r\n(unsigned long)&notify_cfg);\r\nif (ret)\r\ngoto fail;\r\nknav_queue_disable_notify(netcp->tx_compl_q);\r\nsnprintf(name, sizeof(name), "rx-compl-%s", ndev->name);\r\nnetcp->rx_queue = knav_queue_open(name, netcp->rx_queue_id, 0);\r\nif (IS_ERR_OR_NULL(netcp->rx_queue)) {\r\nret = PTR_ERR(netcp->rx_queue);\r\ngoto fail;\r\n}\r\nnetcp->rx_queue_id = knav_queue_get_id(netcp->rx_queue);\r\nnotify_cfg.fn = netcp_rx_notify;\r\nnotify_cfg.fn_arg = netcp;\r\nret = knav_queue_device_control(netcp->rx_queue,\r\nKNAV_QUEUE_SET_NOTIFIER,\r\n(unsigned long)&notify_cfg);\r\nif (ret)\r\ngoto fail;\r\nknav_queue_disable_notify(netcp->rx_queue);\r\nfor (i = 0; i < KNAV_DMA_FDQ_PER_CHAN && netcp->rx_queue_depths[i];\r\n++i) {\r\nsnprintf(name, sizeof(name), "rx-fdq-%s-%d", ndev->name, i);\r\nnetcp->rx_fdq[i] = knav_queue_open(name, KNAV_QUEUE_GP, 0);\r\nif (IS_ERR_OR_NULL(netcp->rx_fdq[i])) {\r\nret = PTR_ERR(netcp->rx_fdq[i]);\r\ngoto fail;\r\n}\r\n}\r\nmemset(&config, 0, sizeof(config));\r\nconfig.direction = DMA_DEV_TO_MEM;\r\nconfig.u.rx.einfo_present = true;\r\nconfig.u.rx.psinfo_present = true;\r\nconfig.u.rx.err_mode = DMA_DROP;\r\nconfig.u.rx.desc_type = DMA_DESC_HOST;\r\nconfig.u.rx.psinfo_at_sop = false;\r\nconfig.u.rx.sop_offset = NETCP_SOP_OFFSET;\r\nconfig.u.rx.dst_q = netcp->rx_queue_id;\r\nconfig.u.rx.thresh = DMA_THRESH_NONE;\r\nfor (i = 0; i < KNAV_DMA_FDQ_PER_CHAN; ++i) {\r\nif (netcp->rx_fdq[i])\r\nlast_fdq = knav_queue_get_id(netcp->rx_fdq[i]);\r\nconfig.u.rx.fdq[i] = last_fdq;\r\n}\r\nnetcp->rx_channel = knav_dma_open_channel(netcp->netcp_device->device,\r\nnetcp->dma_chan_name, &config);\r\nif (IS_ERR_OR_NULL(netcp->rx_channel)) {\r\ndev_err(netcp->ndev_dev, "failed opening rx chan(%s\n",\r\nnetcp->dma_chan_name);\r\ngoto fail;\r\n}\r\ndev_dbg(netcp->ndev_dev, "opened RX channel: %p\n", netcp->rx_channel);\r\nreturn 0;\r\nfail:\r\nnetcp_free_navigator_resources(netcp);\r\nreturn ret;\r\n}\r\nstatic int netcp_ndo_open(struct net_device *ndev)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct netcp_intf_modpriv *intf_modpriv;\r\nstruct netcp_module *module;\r\nint ret;\r\nnetif_carrier_off(ndev);\r\nret = netcp_setup_navigator_resources(ndev);\r\nif (ret) {\r\ndev_err(netcp->ndev_dev, "Failed to setup navigator resources\n");\r\ngoto fail;\r\n}\r\nfor_each_module(netcp, intf_modpriv) {\r\nmodule = intf_modpriv->netcp_module;\r\nif (module->open) {\r\nret = module->open(intf_modpriv->module_priv, ndev);\r\nif (ret != 0) {\r\ndev_err(netcp->ndev_dev, "module open failed\n");\r\ngoto fail_open;\r\n}\r\n}\r\n}\r\nnapi_enable(&netcp->rx_napi);\r\nnapi_enable(&netcp->tx_napi);\r\nknav_queue_enable_notify(netcp->tx_compl_q);\r\nknav_queue_enable_notify(netcp->rx_queue);\r\nnetcp_rxpool_refill(netcp);\r\nnetif_tx_wake_all_queues(ndev);\r\ndev_dbg(netcp->ndev_dev, "netcp device %s opened\n", ndev->name);\r\nreturn 0;\r\nfail_open:\r\nfor_each_module(netcp, intf_modpriv) {\r\nmodule = intf_modpriv->netcp_module;\r\nif (module->close)\r\nmodule->close(intf_modpriv->module_priv, ndev);\r\n}\r\nfail:\r\nnetcp_free_navigator_resources(netcp);\r\nreturn ret;\r\n}\r\nstatic int netcp_ndo_stop(struct net_device *ndev)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct netcp_intf_modpriv *intf_modpriv;\r\nstruct netcp_module *module;\r\nint err = 0;\r\nnetif_tx_stop_all_queues(ndev);\r\nnetif_carrier_off(ndev);\r\nnetcp_addr_clear_mark(netcp);\r\nnetcp_addr_sweep_del(netcp);\r\nknav_queue_disable_notify(netcp->rx_queue);\r\nknav_queue_disable_notify(netcp->tx_compl_q);\r\nnapi_disable(&netcp->rx_napi);\r\nnapi_disable(&netcp->tx_napi);\r\nfor_each_module(netcp, intf_modpriv) {\r\nmodule = intf_modpriv->netcp_module;\r\nif (module->close) {\r\nerr = module->close(intf_modpriv->module_priv, ndev);\r\nif (err != 0)\r\ndev_err(netcp->ndev_dev, "Close failed\n");\r\n}\r\n}\r\nnetcp_empty_rx_queue(netcp);\r\nnetcp_process_tx_compl_packets(netcp, netcp->tx_pool_size);\r\nif (knav_pool_count(netcp->tx_pool) != netcp->tx_pool_size)\r\ndev_err(netcp->ndev_dev, "Lost (%d) Tx descs\n",\r\nnetcp->tx_pool_size - knav_pool_count(netcp->tx_pool));\r\nnetcp_free_navigator_resources(netcp);\r\ndev_dbg(netcp->ndev_dev, "netcp device %s stopped\n", ndev->name);\r\nreturn 0;\r\n}\r\nstatic int netcp_ndo_ioctl(struct net_device *ndev,\r\nstruct ifreq *req, int cmd)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct netcp_intf_modpriv *intf_modpriv;\r\nstruct netcp_module *module;\r\nint ret = -1, err = -EOPNOTSUPP;\r\nif (!netif_running(ndev))\r\nreturn -EINVAL;\r\nfor_each_module(netcp, intf_modpriv) {\r\nmodule = intf_modpriv->netcp_module;\r\nif (!module->ioctl)\r\ncontinue;\r\nerr = module->ioctl(intf_modpriv->module_priv, req, cmd);\r\nif ((err < 0) && (err != -EOPNOTSUPP)) {\r\nret = err;\r\ngoto out;\r\n}\r\nif (err == 0)\r\nret = err;\r\n}\r\nout:\r\nreturn (ret == 0) ? 0 : err;\r\n}\r\nstatic int netcp_ndo_change_mtu(struct net_device *ndev, int new_mtu)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nif ((new_mtu < 68) ||\r\n(new_mtu > (NETCP_MAX_FRAME_SIZE - ETH_HLEN - ETH_FCS_LEN))) {\r\ndev_err(netcp->ndev_dev, "Invalid mtu size = %d\n", new_mtu);\r\nreturn -EINVAL;\r\n}\r\nndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void netcp_ndo_tx_timeout(struct net_device *ndev)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nunsigned int descs = knav_pool_count(netcp->tx_pool);\r\ndev_err(netcp->ndev_dev, "transmit timed out tx descs(%d)\n", descs);\r\nnetcp_process_tx_compl_packets(netcp, netcp->tx_pool_size);\r\nnetif_trans_update(ndev);\r\nnetif_tx_wake_all_queues(ndev);\r\n}\r\nstatic int netcp_rx_add_vid(struct net_device *ndev, __be16 proto, u16 vid)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct netcp_intf_modpriv *intf_modpriv;\r\nstruct netcp_module *module;\r\nunsigned long flags;\r\nint err = 0;\r\ndev_dbg(netcp->ndev_dev, "adding rx vlan id: %d\n", vid);\r\nspin_lock_irqsave(&netcp->lock, flags);\r\nfor_each_module(netcp, intf_modpriv) {\r\nmodule = intf_modpriv->netcp_module;\r\nif ((module->add_vid) && (vid != 0)) {\r\nerr = module->add_vid(intf_modpriv->module_priv, vid);\r\nif (err != 0) {\r\ndev_err(netcp->ndev_dev, "Could not add vlan id = %d\n",\r\nvid);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&netcp->lock, flags);\r\nreturn err;\r\n}\r\nstatic int netcp_rx_kill_vid(struct net_device *ndev, __be16 proto, u16 vid)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct netcp_intf_modpriv *intf_modpriv;\r\nstruct netcp_module *module;\r\nunsigned long flags;\r\nint err = 0;\r\ndev_dbg(netcp->ndev_dev, "removing rx vlan id: %d\n", vid);\r\nspin_lock_irqsave(&netcp->lock, flags);\r\nfor_each_module(netcp, intf_modpriv) {\r\nmodule = intf_modpriv->netcp_module;\r\nif (module->del_vid) {\r\nerr = module->del_vid(intf_modpriv->module_priv, vid);\r\nif (err != 0) {\r\ndev_err(netcp->ndev_dev, "Could not delete vlan id = %d\n",\r\nvid);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&netcp->lock, flags);\r\nreturn err;\r\n}\r\nstatic u16 netcp_select_queue(struct net_device *dev, struct sk_buff *skb,\r\nvoid *accel_priv,\r\nselect_queue_fallback_t fallback)\r\n{\r\nreturn 0;\r\n}\r\nstatic int netcp_setup_tc(struct net_device *dev, u32 handle, __be16 proto,\r\nstruct tc_to_netdev *tc)\r\n{\r\nint i;\r\nASSERT_RTNL();\r\nif (tc->type != TC_SETUP_MQPRIO)\r\nreturn -EINVAL;\r\nif ((dev->real_num_tx_queues <= 1) ||\r\n(dev->real_num_tx_queues < tc->tc))\r\nreturn -EINVAL;\r\nif (tc->tc) {\r\nnetdev_set_num_tc(dev, tc->tc);\r\nfor (i = 0; i < tc->tc; i++)\r\nnetdev_set_tc_queue(dev, i, 1, i);\r\n} else {\r\nnetdev_reset_tc(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int netcp_create_interface(struct netcp_device *netcp_device,\r\nstruct device_node *node_interface)\r\n{\r\nstruct device *dev = netcp_device->device;\r\nstruct device_node *node = dev->of_node;\r\nstruct netcp_intf *netcp;\r\nstruct net_device *ndev;\r\nresource_size_t size;\r\nstruct resource res;\r\nvoid __iomem *efuse = NULL;\r\nu32 efuse_mac = 0;\r\nconst void *mac_addr;\r\nu8 efuse_mac_addr[6];\r\nu32 temp[2];\r\nint ret = 0;\r\nndev = alloc_etherdev_mqs(sizeof(*netcp), 1, 1);\r\nif (!ndev) {\r\ndev_err(dev, "Error allocating netdev\n");\r\nreturn -ENOMEM;\r\n}\r\nndev->features |= NETIF_F_SG;\r\nndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\nndev->hw_features = ndev->features;\r\nndev->vlan_features |= NETIF_F_SG;\r\nnetcp = netdev_priv(ndev);\r\nspin_lock_init(&netcp->lock);\r\nINIT_LIST_HEAD(&netcp->module_head);\r\nINIT_LIST_HEAD(&netcp->txhook_list_head);\r\nINIT_LIST_HEAD(&netcp->rxhook_list_head);\r\nINIT_LIST_HEAD(&netcp->addr_list);\r\nnetcp->netcp_device = netcp_device;\r\nnetcp->dev = netcp_device->device;\r\nnetcp->ndev = ndev;\r\nnetcp->ndev_dev = &ndev->dev;\r\nnetcp->msg_enable = netif_msg_init(netcp_debug_level, NETCP_DEBUG);\r\nnetcp->tx_pause_threshold = MAX_SKB_FRAGS;\r\nnetcp->tx_resume_threshold = netcp->tx_pause_threshold;\r\nnetcp->node_interface = node_interface;\r\nret = of_property_read_u32(node_interface, "efuse-mac", &efuse_mac);\r\nif (efuse_mac) {\r\nif (of_address_to_resource(node, NETCP_EFUSE_REG_INDEX, &res)) {\r\ndev_err(dev, "could not find efuse-mac reg resource\n");\r\nret = -ENODEV;\r\ngoto quit;\r\n}\r\nsize = resource_size(&res);\r\nif (!devm_request_mem_region(dev, res.start, size,\r\ndev_name(dev))) {\r\ndev_err(dev, "could not reserve resource\n");\r\nret = -ENOMEM;\r\ngoto quit;\r\n}\r\nefuse = devm_ioremap_nocache(dev, res.start, size);\r\nif (!efuse) {\r\ndev_err(dev, "could not map resource\n");\r\ndevm_release_mem_region(dev, res.start, size);\r\nret = -ENOMEM;\r\ngoto quit;\r\n}\r\nemac_arch_get_mac_addr(efuse_mac_addr, efuse, efuse_mac);\r\nif (is_valid_ether_addr(efuse_mac_addr))\r\nether_addr_copy(ndev->dev_addr, efuse_mac_addr);\r\nelse\r\nrandom_ether_addr(ndev->dev_addr);\r\ndevm_iounmap(dev, efuse);\r\ndevm_release_mem_region(dev, res.start, size);\r\n} else {\r\nmac_addr = of_get_mac_address(node_interface);\r\nif (mac_addr)\r\nether_addr_copy(ndev->dev_addr, mac_addr);\r\nelse\r\nrandom_ether_addr(ndev->dev_addr);\r\n}\r\nret = of_property_read_string(node_interface, "rx-channel",\r\n&netcp->dma_chan_name);\r\nif (ret < 0) {\r\ndev_err(dev, "missing \"rx-channel\" parameter\n");\r\nret = -ENODEV;\r\ngoto quit;\r\n}\r\nret = of_property_read_u32(node_interface, "rx-queue",\r\n&netcp->rx_queue_id);\r\nif (ret < 0) {\r\ndev_warn(dev, "missing \"rx-queue\" parameter\n");\r\nnetcp->rx_queue_id = KNAV_QUEUE_QPEND;\r\n}\r\nret = of_property_read_u32_array(node_interface, "rx-queue-depth",\r\nnetcp->rx_queue_depths,\r\nKNAV_DMA_FDQ_PER_CHAN);\r\nif (ret < 0) {\r\ndev_err(dev, "missing \"rx-queue-depth\" parameter\n");\r\nnetcp->rx_queue_depths[0] = 128;\r\n}\r\nret = of_property_read_u32_array(node_interface, "rx-pool", temp, 2);\r\nif (ret < 0) {\r\ndev_err(dev, "missing \"rx-pool\" parameter\n");\r\nret = -ENODEV;\r\ngoto quit;\r\n}\r\nnetcp->rx_pool_size = temp[0];\r\nnetcp->rx_pool_region_id = temp[1];\r\nret = of_property_read_u32_array(node_interface, "tx-pool", temp, 2);\r\nif (ret < 0) {\r\ndev_err(dev, "missing \"tx-pool\" parameter\n");\r\nret = -ENODEV;\r\ngoto quit;\r\n}\r\nnetcp->tx_pool_size = temp[0];\r\nnetcp->tx_pool_region_id = temp[1];\r\nif (netcp->tx_pool_size < MAX_SKB_FRAGS) {\r\ndev_err(dev, "tx-pool size too small, must be atleast(%ld)\n",\r\nMAX_SKB_FRAGS);\r\nret = -ENODEV;\r\ngoto quit;\r\n}\r\nret = of_property_read_u32(node_interface, "tx-completion-queue",\r\n&netcp->tx_compl_qid);\r\nif (ret < 0) {\r\ndev_warn(dev, "missing \"tx-completion-queue\" parameter\n");\r\nnetcp->tx_compl_qid = KNAV_QUEUE_QPEND;\r\n}\r\nnetif_napi_add(ndev, &netcp->rx_napi, netcp_rx_poll, NETCP_NAPI_WEIGHT);\r\nnetif_tx_napi_add(ndev, &netcp->tx_napi, netcp_tx_poll, NETCP_NAPI_WEIGHT);\r\nndev->dev_id = 0;\r\nndev->watchdog_timeo = NETCP_TX_TIMEOUT;\r\nndev->netdev_ops = &netcp_netdev_ops;\r\nSET_NETDEV_DEV(ndev, dev);\r\nlist_add_tail(&netcp->interface_list, &netcp_device->interface_head);\r\nreturn 0;\r\nquit:\r\nfree_netdev(ndev);\r\nreturn ret;\r\n}\r\nstatic void netcp_delete_interface(struct netcp_device *netcp_device,\r\nstruct net_device *ndev)\r\n{\r\nstruct netcp_intf_modpriv *intf_modpriv, *tmp;\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct netcp_module *module;\r\ndev_dbg(netcp_device->device, "Removing interface \"%s\"\n",\r\nndev->name);\r\nlist_for_each_entry_safe(intf_modpriv, tmp, &netcp->module_head,\r\nintf_list) {\r\nmodule = intf_modpriv->netcp_module;\r\ndev_dbg(netcp_device->device, "Releasing module \"%s\"\n",\r\nmodule->name);\r\nif (module->release)\r\nmodule->release(intf_modpriv->module_priv);\r\nlist_del(&intf_modpriv->intf_list);\r\nkfree(intf_modpriv);\r\n}\r\nWARN(!list_empty(&netcp->module_head), "%s interface module list is not empty!\n",\r\nndev->name);\r\nlist_del(&netcp->interface_list);\r\nof_node_put(netcp->node_interface);\r\nunregister_netdev(ndev);\r\nnetif_napi_del(&netcp->rx_napi);\r\nfree_netdev(ndev);\r\n}\r\nstatic int netcp_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct netcp_intf *netcp_intf, *netcp_tmp;\r\nstruct device_node *child, *interfaces;\r\nstruct netcp_device *netcp_device;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nif (!node) {\r\ndev_err(dev, "could not find device info\n");\r\nreturn -ENODEV;\r\n}\r\nnetcp_device = devm_kzalloc(dev, sizeof(*netcp_device), GFP_KERNEL);\r\nif (!netcp_device)\r\nreturn -ENOMEM;\r\npm_runtime_enable(&pdev->dev);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to enable NETCP power-domain\n");\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&netcp_device->interface_head);\r\nINIT_LIST_HEAD(&netcp_device->modpriv_head);\r\nnetcp_device->device = dev;\r\nplatform_set_drvdata(pdev, netcp_device);\r\ninterfaces = of_get_child_by_name(node, "netcp-interfaces");\r\nif (!interfaces) {\r\ndev_err(dev, "could not find netcp-interfaces node\n");\r\nret = -ENODEV;\r\ngoto probe_quit;\r\n}\r\nfor_each_available_child_of_node(interfaces, child) {\r\nret = netcp_create_interface(netcp_device, child);\r\nif (ret) {\r\ndev_err(dev, "could not create interface(%s)\n",\r\nchild->name);\r\ngoto probe_quit_interface;\r\n}\r\n}\r\nlist_add_tail(&netcp_device->device_list, &netcp_devices);\r\nreturn 0;\r\nprobe_quit_interface:\r\nlist_for_each_entry_safe(netcp_intf, netcp_tmp,\r\n&netcp_device->interface_head,\r\ninterface_list) {\r\nnetcp_delete_interface(netcp_device, netcp_intf->ndev);\r\n}\r\nprobe_quit:\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int netcp_remove(struct platform_device *pdev)\r\n{\r\nstruct netcp_device *netcp_device = platform_get_drvdata(pdev);\r\nstruct netcp_intf *netcp_intf, *netcp_tmp;\r\nstruct netcp_inst_modpriv *inst_modpriv, *tmp;\r\nstruct netcp_module *module;\r\nlist_for_each_entry_safe(inst_modpriv, tmp, &netcp_device->modpriv_head,\r\ninst_list) {\r\nmodule = inst_modpriv->netcp_module;\r\ndev_dbg(&pdev->dev, "Removing module \"%s\"\n", module->name);\r\nmodule->remove(netcp_device, inst_modpriv->module_priv);\r\nlist_del(&inst_modpriv->inst_list);\r\nkfree(inst_modpriv);\r\n}\r\nlist_for_each_entry_safe(netcp_intf, netcp_tmp,\r\n&netcp_device->interface_head,\r\ninterface_list) {\r\nnetcp_delete_interface(netcp_device, netcp_intf->ndev);\r\n}\r\nWARN(!list_empty(&netcp_device->interface_head),\r\n"%s interface list not empty!\n", pdev->name);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
