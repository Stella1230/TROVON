static void enable_tsensor(struct tegra_soctherm *tegra, unsigned int i)\r\n{\r\nconst struct tegra_tsensor *sensor = &tegra->soc->tsensors[i];\r\nvoid __iomem *base = tegra->regs + sensor->base;\r\nunsigned int val;\r\nval = sensor->config->tall << SENSOR_CONFIG0_TALL_SHIFT;\r\nwritel(val, base + SENSOR_CONFIG0);\r\nval = (sensor->config->tsample - 1) << SENSOR_CONFIG1_TSAMPLE_SHIFT;\r\nval |= sensor->config->tiddq_en << SENSOR_CONFIG1_TIDDQ_EN_SHIFT;\r\nval |= sensor->config->ten_count << SENSOR_CONFIG1_TEN_COUNT_SHIFT;\r\nval |= SENSOR_CONFIG1_TEMP_ENABLE;\r\nwritel(val, base + SENSOR_CONFIG1);\r\nwritel(tegra->calib[i], base + SENSOR_CONFIG2);\r\n}\r\nstatic int translate_temp(u16 val)\r\n{\r\nint t;\r\nt = ((val & READBACK_VALUE_MASK) >> READBACK_VALUE_SHIFT) * 1000;\r\nif (val & READBACK_ADD_HALF)\r\nt += 500;\r\nif (val & READBACK_NEGATE)\r\nt *= -1;\r\nreturn t;\r\n}\r\nstatic int tegra_thermctl_get_temp(void *data, int *out_temp)\r\n{\r\nstruct tegra_thermctl_zone *zone = data;\r\nu32 val;\r\nval = readl(zone->reg);\r\nval = REG_GET_MASK(val, zone->sg->sensor_temp_mask);\r\n*out_temp = translate_temp(val);\r\nreturn 0;\r\n}\r\nstatic int tegra_thermctl_set_trip_temp(void *data, int trip, int temp)\r\n{\r\nstruct tegra_thermctl_zone *zone = data;\r\nstruct thermal_zone_device *tz = zone->tz;\r\nconst struct tegra_tsensor_group *sg = zone->sg;\r\nstruct device *dev = zone->dev;\r\nenum thermal_trip_type type;\r\nint ret;\r\nif (!tz)\r\nreturn -EINVAL;\r\nret = tz->ops->get_trip_type(tz, trip, &type);\r\nif (ret)\r\nreturn ret;\r\nif (type != THERMAL_TRIP_CRITICAL)\r\nreturn 0;\r\nreturn thermtrip_program(dev, sg, temp);\r\n}\r\nstatic int enforce_temp_range(struct device *dev, int trip_temp)\r\n{\r\nint temp;\r\ntemp = clamp_val(trip_temp, min_low_temp, max_high_temp);\r\nif (temp != trip_temp)\r\ndev_info(dev, "soctherm: trip temperature %d forced to %d\n",\r\ntrip_temp, temp);\r\nreturn temp;\r\n}\r\nstatic int thermtrip_program(struct device *dev,\r\nconst struct tegra_tsensor_group *sg,\r\nint trip_temp)\r\n{\r\nstruct tegra_soctherm *ts = dev_get_drvdata(dev);\r\nint temp;\r\nu32 r;\r\nif (!sg || !sg->thermtrip_threshold_mask)\r\nreturn -EINVAL;\r\ntemp = enforce_temp_range(dev, trip_temp) / ts->soc->thresh_grain;\r\nr = readl(ts->regs + THERMCTL_THERMTRIP_CTL);\r\nr = REG_SET_MASK(r, sg->thermtrip_threshold_mask, temp);\r\nr = REG_SET_MASK(r, sg->thermtrip_enable_mask, 1);\r\nr = REG_SET_MASK(r, sg->thermtrip_any_en_mask, 0);\r\nwritel(r, ts->regs + THERMCTL_THERMTRIP_CTL);\r\nreturn 0;\r\n}\r\nstatic int tegra_soctherm_set_hwtrips(struct device *dev,\r\nconst struct tegra_tsensor_group *sg,\r\nstruct thermal_zone_device *tz)\r\n{\r\nint temperature;\r\nint ret;\r\nret = tz->ops->get_crit_temp(tz, &temperature);\r\nif (ret) {\r\ndev_warn(dev, "thermtrip: %s: missing critical temperature\n",\r\nsg->name);\r\nreturn ret;\r\n}\r\nret = thermtrip_program(dev, sg, temperature);\r\nif (ret) {\r\ndev_err(dev, "thermtrip: %s: error during enable\n",\r\nsg->name);\r\nreturn ret;\r\n}\r\ndev_info(dev,\r\n"thermtrip: will shut down when %s reaches %d mC\n",\r\nsg->name, temperature);\r\nreturn 0;\r\n}\r\nstatic int regs_show(struct seq_file *s, void *data)\r\n{\r\nstruct platform_device *pdev = s->private;\r\nstruct tegra_soctherm *ts = platform_get_drvdata(pdev);\r\nconst struct tegra_tsensor *tsensors = ts->soc->tsensors;\r\nconst struct tegra_tsensor_group **ttgs = ts->soc->ttgs;\r\nu32 r, state;\r\nint i;\r\nseq_puts(s, "-----TSENSE (convert HW)-----\n");\r\nfor (i = 0; i < ts->soc->num_tsensors; i++) {\r\nr = readl(ts->regs + tsensors[i].base + SENSOR_CONFIG1);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG1_TEMP_ENABLE);\r\nseq_printf(s, "%s: ", tsensors[i].name);\r\nseq_printf(s, "En(%d) ", state);\r\nif (!state) {\r\nseq_puts(s, "\n");\r\ncontinue;\r\n}\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG1_TIDDQ_EN_MASK);\r\nseq_printf(s, "tiddq(%d) ", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG1_TEN_COUNT_MASK);\r\nseq_printf(s, "ten_count(%d) ", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG1_TSAMPLE_MASK);\r\nseq_printf(s, "tsample(%d) ", state + 1);\r\nr = readl(ts->regs + tsensors[i].base + SENSOR_STATUS1);\r\nstate = REG_GET_MASK(r, SENSOR_STATUS1_TEMP_VALID_MASK);\r\nseq_printf(s, "Temp(%d/", state);\r\nstate = REG_GET_MASK(r, SENSOR_STATUS1_TEMP_MASK);\r\nseq_printf(s, "%d) ", translate_temp(state));\r\nr = readl(ts->regs + tsensors[i].base + SENSOR_STATUS0);\r\nstate = REG_GET_MASK(r, SENSOR_STATUS0_VALID_MASK);\r\nseq_printf(s, "Capture(%d/", state);\r\nstate = REG_GET_MASK(r, SENSOR_STATUS0_CAPTURE_MASK);\r\nseq_printf(s, "%d) ", state);\r\nr = readl(ts->regs + tsensors[i].base + SENSOR_CONFIG0);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG0_STOP);\r\nseq_printf(s, "Stop(%d) ", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG0_TALL_MASK);\r\nseq_printf(s, "Tall(%d) ", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG0_TCALC_OVER);\r\nseq_printf(s, "Over(%d/", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG0_OVER);\r\nseq_printf(s, "%d/", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG0_CPTR_OVER);\r\nseq_printf(s, "%d) ", state);\r\nr = readl(ts->regs + tsensors[i].base + SENSOR_CONFIG2);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG2_THERMA_MASK);\r\nseq_printf(s, "Therm_A/B(%d/", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG2_THERMB_MASK);\r\nseq_printf(s, "%d)\n", (s16)state);\r\n}\r\nr = readl(ts->regs + SENSOR_PDIV);\r\nseq_printf(s, "PDIV: 0x%x\n", r);\r\nr = readl(ts->regs + SENSOR_HOTSPOT_OFF);\r\nseq_printf(s, "HOTSPOT: 0x%x\n", r);\r\nseq_puts(s, "\n");\r\nseq_puts(s, "-----SOC_THERM-----\n");\r\nr = readl(ts->regs + SENSOR_TEMP1);\r\nstate = REG_GET_MASK(r, SENSOR_TEMP1_CPU_TEMP_MASK);\r\nseq_printf(s, "Temperatures: CPU(%d) ", translate_temp(state));\r\nstate = REG_GET_MASK(r, SENSOR_TEMP1_GPU_TEMP_MASK);\r\nseq_printf(s, " GPU(%d) ", translate_temp(state));\r\nr = readl(ts->regs + SENSOR_TEMP2);\r\nstate = REG_GET_MASK(r, SENSOR_TEMP2_PLLX_TEMP_MASK);\r\nseq_printf(s, " PLLX(%d) ", translate_temp(state));\r\nstate = REG_GET_MASK(r, SENSOR_TEMP2_MEM_TEMP_MASK);\r\nseq_printf(s, " MEM(%d)\n", translate_temp(state));\r\nr = readl(ts->regs + THERMCTL_THERMTRIP_CTL);\r\nstate = REG_GET_MASK(r, ttgs[0]->thermtrip_any_en_mask);\r\nseq_printf(s, "Thermtrip Any En(%d)\n", state);\r\nfor (i = 0; i < ts->soc->num_ttgs; i++) {\r\nstate = REG_GET_MASK(r, ttgs[i]->thermtrip_enable_mask);\r\nseq_printf(s, " %s En(%d) ", ttgs[i]->name, state);\r\nstate = REG_GET_MASK(r, ttgs[i]->thermtrip_threshold_mask);\r\nstate *= ts->soc->thresh_grain;\r\nseq_printf(s, "Thresh(%d)\n", state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int regs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, regs_show, inode->i_private);\r\n}\r\nstatic void soctherm_debug_init(struct platform_device *pdev)\r\n{\r\nstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\r\nstruct dentry *root, *file;\r\nroot = debugfs_create_dir("soctherm", NULL);\r\nif (!root) {\r\ndev_err(&pdev->dev, "failed to create debugfs directory\n");\r\nreturn;\r\n}\r\ntegra->debugfs_dir = root;\r\nfile = debugfs_create_file("reg_contents", 0644, root,\r\npdev, &regs_fops);\r\nif (!file) {\r\ndev_err(&pdev->dev, "failed to create debugfs file\n");\r\ndebugfs_remove_recursive(tegra->debugfs_dir);\r\ntegra->debugfs_dir = NULL;\r\n}\r\n}\r\nstatic inline void soctherm_debug_init(struct platform_device *pdev) {}\r\nstatic int soctherm_clk_enable(struct platform_device *pdev, bool enable)\r\n{\r\nstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\r\nint err;\r\nif (!tegra->clock_soctherm || !tegra->clock_tsensor)\r\nreturn -EINVAL;\r\nreset_control_assert(tegra->reset);\r\nif (enable) {\r\nerr = clk_prepare_enable(tegra->clock_soctherm);\r\nif (err) {\r\nreset_control_deassert(tegra->reset);\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(tegra->clock_tsensor);\r\nif (err) {\r\nclk_disable_unprepare(tegra->clock_soctherm);\r\nreset_control_deassert(tegra->reset);\r\nreturn err;\r\n}\r\n} else {\r\nclk_disable_unprepare(tegra->clock_tsensor);\r\nclk_disable_unprepare(tegra->clock_soctherm);\r\n}\r\nreset_control_deassert(tegra->reset);\r\nreturn 0;\r\n}\r\nstatic void soctherm_init(struct platform_device *pdev)\r\n{\r\nstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\r\nconst struct tegra_tsensor_group **ttgs = tegra->soc->ttgs;\r\nint i;\r\nu32 pdiv, hotspot;\r\nfor (i = 0; i < tegra->soc->num_tsensors; ++i)\r\nenable_tsensor(tegra, i);\r\npdiv = readl(tegra->regs + SENSOR_PDIV);\r\nhotspot = readl(tegra->regs + SENSOR_HOTSPOT_OFF);\r\nfor (i = 0; i < tegra->soc->num_ttgs; ++i) {\r\npdiv = REG_SET_MASK(pdiv, ttgs[i]->pdiv_mask,\r\nttgs[i]->pdiv);\r\nif (ttgs[i]->id == TEGRA124_SOCTHERM_SENSOR_PLLX)\r\ncontinue;\r\nhotspot = REG_SET_MASK(hotspot,\r\nttgs[i]->pllx_hotspot_mask,\r\nttgs[i]->pllx_hotspot_diff);\r\n}\r\nwritel(pdiv, tegra->regs + SENSOR_PDIV);\r\nwritel(hotspot, tegra->regs + SENSOR_HOTSPOT_OFF);\r\n}\r\nstatic int tegra_soctherm_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct tegra_soctherm *tegra;\r\nstruct thermal_zone_device *z;\r\nstruct tsensor_shared_calib shared_calib;\r\nstruct resource *res;\r\nstruct tegra_soctherm_soc *soc;\r\nunsigned int i;\r\nint err;\r\nmatch = of_match_node(tegra_soctherm_of_match, pdev->dev.of_node);\r\nif (!match)\r\nreturn -ENODEV;\r\nsoc = (struct tegra_soctherm_soc *)match->data;\r\nif (soc->num_ttgs > TEGRA124_SOCTHERM_SENSOR_NUM)\r\nreturn -EINVAL;\r\ntegra = devm_kzalloc(&pdev->dev, sizeof(*tegra), GFP_KERNEL);\r\nif (!tegra)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&pdev->dev, tegra);\r\ntegra->soc = soc;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntegra->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(tegra->regs))\r\nreturn PTR_ERR(tegra->regs);\r\ntegra->reset = devm_reset_control_get(&pdev->dev, "soctherm");\r\nif (IS_ERR(tegra->reset)) {\r\ndev_err(&pdev->dev, "can't get soctherm reset\n");\r\nreturn PTR_ERR(tegra->reset);\r\n}\r\ntegra->clock_tsensor = devm_clk_get(&pdev->dev, "tsensor");\r\nif (IS_ERR(tegra->clock_tsensor)) {\r\ndev_err(&pdev->dev, "can't get tsensor clock\n");\r\nreturn PTR_ERR(tegra->clock_tsensor);\r\n}\r\ntegra->clock_soctherm = devm_clk_get(&pdev->dev, "soctherm");\r\nif (IS_ERR(tegra->clock_soctherm)) {\r\ndev_err(&pdev->dev, "can't get soctherm clock\n");\r\nreturn PTR_ERR(tegra->clock_soctherm);\r\n}\r\ntegra->calib = devm_kzalloc(&pdev->dev,\r\nsizeof(u32) * soc->num_tsensors,\r\nGFP_KERNEL);\r\nif (!tegra->calib)\r\nreturn -ENOMEM;\r\nerr = tegra_calc_shared_calib(soc->tfuse, &shared_calib);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < soc->num_tsensors; ++i) {\r\nerr = tegra_calc_tsensor_calib(&soc->tsensors[i],\r\n&shared_calib,\r\n&tegra->calib[i]);\r\nif (err)\r\nreturn err;\r\n}\r\ntegra->thermctl_tzs = devm_kzalloc(&pdev->dev,\r\nsizeof(*z) * soc->num_ttgs,\r\nGFP_KERNEL);\r\nif (!tegra->thermctl_tzs)\r\nreturn -ENOMEM;\r\nerr = soctherm_clk_enable(pdev, true);\r\nif (err)\r\nreturn err;\r\nsoctherm_init(pdev);\r\nfor (i = 0; i < soc->num_ttgs; ++i) {\r\nstruct tegra_thermctl_zone *zone =\r\ndevm_kzalloc(&pdev->dev, sizeof(*zone), GFP_KERNEL);\r\nif (!zone) {\r\nerr = -ENOMEM;\r\ngoto disable_clocks;\r\n}\r\nzone->reg = tegra->regs + soc->ttgs[i]->sensor_temp_offset;\r\nzone->dev = &pdev->dev;\r\nzone->sg = soc->ttgs[i];\r\nz = devm_thermal_zone_of_sensor_register(&pdev->dev,\r\nsoc->ttgs[i]->id, zone,\r\n&tegra_of_thermal_ops);\r\nif (IS_ERR(z)) {\r\nerr = PTR_ERR(z);\r\ndev_err(&pdev->dev, "failed to register sensor: %d\n",\r\nerr);\r\ngoto disable_clocks;\r\n}\r\nzone->tz = z;\r\ntegra->thermctl_tzs[soc->ttgs[i]->id] = z;\r\ntegra_soctherm_set_hwtrips(&pdev->dev, soc->ttgs[i], z);\r\n}\r\nsoctherm_debug_init(pdev);\r\nreturn 0;\r\ndisable_clocks:\r\nsoctherm_clk_enable(pdev, false);\r\nreturn err;\r\n}\r\nstatic int tegra_soctherm_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\r\ndebugfs_remove_recursive(tegra->debugfs_dir);\r\nsoctherm_clk_enable(pdev, false);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused soctherm_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nsoctherm_clk_enable(pdev, false);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused soctherm_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\r\nstruct tegra_soctherm_soc *soc = tegra->soc;\r\nint err, i;\r\nerr = soctherm_clk_enable(pdev, true);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Resume failed: enable clocks failed\n");\r\nreturn err;\r\n}\r\nsoctherm_init(pdev);\r\nfor (i = 0; i < soc->num_ttgs; ++i) {\r\nstruct thermal_zone_device *tz;\r\ntz = tegra->thermctl_tzs[soc->ttgs[i]->id];\r\ntegra_soctherm_set_hwtrips(dev, soc->ttgs[i], tz);\r\n}\r\nreturn 0;\r\n}
