static bool nv_cksum(const uint8_t *data, unsigned int length)\r\n{\r\nint i;\r\nuint8_t sum = 0;\r\nfor (i = 0; i < length; i++)\r\nsum += data[i];\r\nif (sum)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic uint16_t clkcmptable(struct nvbios *bios, uint16_t clktable, int pxclk)\r\n{\r\nint compare_record_len, i = 0;\r\nuint16_t compareclk, scriptptr = 0;\r\nif (bios->major_version < 5)\r\ncompare_record_len = 3;\r\nelse\r\ncompare_record_len = 4;\r\ndo {\r\ncompareclk = ROM16(bios->data[clktable + compare_record_len * i]);\r\nif (pxclk >= compareclk * 10) {\r\nif (bios->major_version < 5) {\r\nuint8_t tmdssub = bios->data[clktable + 2 + compare_record_len * i];\r\nscriptptr = ROM16(bios->data[bios->init_script_tbls_ptr + tmdssub * 2]);\r\n} else\r\nscriptptr = ROM16(bios->data[clktable + 2 + compare_record_len * i]);\r\nbreak;\r\n}\r\ni++;\r\n} while (compareclk);\r\nreturn scriptptr;\r\n}\r\nstatic void\r\nrun_digital_op_script(struct drm_device *dev, uint16_t scriptptr,\r\nstruct dcb_output *dcbent, int head, bool dl)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nNV_INFO(drm, "0x%04X: Parsing digital output script table\n",\r\nscriptptr);\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_44, head ? NV_CIO_CRE_44_HEADB :\r\nNV_CIO_CRE_44_HEADA);\r\nnouveau_bios_run_init_table(dev, scriptptr, dcbent, head);\r\nnv04_dfp_bind_head(dev, dcbent, head, dl);\r\n}\r\nstatic int call_lvds_manufacturer_script(struct drm_device *dev, struct dcb_output *dcbent, int head, enum LVDS_script script)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvbios *bios = &drm->vbios;\r\nuint8_t sub = bios->data[bios->fp.xlated_entry + script] + (bios->fp.link_c_increment && dcbent->or & DCB_OUTPUT_C ? 1 : 0);\r\nuint16_t scriptofs = ROM16(bios->data[bios->init_script_tbls_ptr + sub * 2]);\r\nif (!bios->fp.xlated_entry || !sub || !scriptofs)\r\nreturn -EINVAL;\r\nrun_digital_op_script(dev, scriptofs, dcbent, head, bios->fp.dual_link);\r\nif (script == LVDS_PANEL_OFF) {\r\nmdelay(ROM16(bios->data[bios->fp.xlated_entry + 7]));\r\n}\r\n#ifdef __powerpc__\r\nif (script == LVDS_RESET &&\r\n(dev->pdev->device == 0x0179 || dev->pdev->device == 0x0189 ||\r\ndev->pdev->device == 0x0329))\r\nnv_write_tmds(dev, dcbent->or, 0, 0x02, 0x72);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int run_lvds_table(struct drm_device *dev, struct dcb_output *dcbent, int head, enum LVDS_script script, int pxclk)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvbios *bios = &drm->vbios;\r\nunsigned int outputset = (dcbent->or == 4) ? 1 : 0;\r\nuint16_t scriptptr = 0, clktable;\r\nswitch (script) {\r\ncase LVDS_INIT:\r\nreturn -ENOSYS;\r\ncase LVDS_BACKLIGHT_ON:\r\ncase LVDS_PANEL_ON:\r\nscriptptr = ROM16(bios->data[bios->fp.lvdsmanufacturerpointer + 7 + outputset * 2]);\r\nbreak;\r\ncase LVDS_BACKLIGHT_OFF:\r\ncase LVDS_PANEL_OFF:\r\nscriptptr = ROM16(bios->data[bios->fp.lvdsmanufacturerpointer + 11 + outputset * 2]);\r\nbreak;\r\ncase LVDS_RESET:\r\nclktable = bios->fp.lvdsmanufacturerpointer + 15;\r\nif (dcbent->or == 4)\r\nclktable += 8;\r\nif (dcbent->lvdsconf.use_straps_for_mode) {\r\nif (bios->fp.dual_link)\r\nclktable += 4;\r\nif (bios->fp.if_is_24bit)\r\nclktable += 2;\r\n} else {\r\nint cmpval_24bit = (dcbent->or == 4) ? 4 : 1;\r\nif (bios->fp.dual_link) {\r\nclktable += 4;\r\ncmpval_24bit <<= 1;\r\n}\r\nif (bios->fp.strapless_is_24bit & cmpval_24bit)\r\nclktable += 2;\r\n}\r\nclktable = ROM16(bios->data[clktable]);\r\nif (!clktable) {\r\nNV_ERROR(drm, "Pixel clock comparison table not found\n");\r\nreturn -ENOENT;\r\n}\r\nscriptptr = clkcmptable(bios, clktable, pxclk);\r\n}\r\nif (!scriptptr) {\r\nNV_ERROR(drm, "LVDS output init script not found\n");\r\nreturn -ENOENT;\r\n}\r\nrun_digital_op_script(dev, scriptptr, dcbent, head, bios->fp.dual_link);\r\nreturn 0;\r\n}\r\nint call_lvds_script(struct drm_device *dev, struct dcb_output *dcbent, int head, enum LVDS_script script, int pxclk)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvif_object *device = &drm->device.object;\r\nstruct nvbios *bios = &drm->vbios;\r\nuint8_t lvds_ver = bios->data[bios->fp.lvdsmanufacturerpointer];\r\nuint32_t sel_clk_binding, sel_clk;\r\nint ret;\r\nif (bios->fp.last_script_invoc == (script << 1 | head) || !lvds_ver ||\r\n(lvds_ver >= 0x30 && script == LVDS_INIT))\r\nreturn 0;\r\nif (!bios->fp.lvds_init_run) {\r\nbios->fp.lvds_init_run = true;\r\ncall_lvds_script(dev, dcbent, head, LVDS_INIT, pxclk);\r\n}\r\nif (script == LVDS_PANEL_ON && bios->fp.reset_after_pclk_change)\r\ncall_lvds_script(dev, dcbent, head, LVDS_RESET, pxclk);\r\nif (script == LVDS_RESET && bios->fp.power_off_for_reset)\r\ncall_lvds_script(dev, dcbent, head, LVDS_PANEL_OFF, pxclk);\r\nNV_INFO(drm, "Calling LVDS script %d:\n", script);\r\nsel_clk_binding = nvif_rd32(device, NV_PRAMDAC_SEL_CLK) & 0x50000;\r\nif (lvds_ver < 0x30)\r\nret = call_lvds_manufacturer_script(dev, dcbent, head, script);\r\nelse\r\nret = run_lvds_table(dev, dcbent, head, script, pxclk);\r\nbios->fp.last_script_invoc = (script << 1 | head);\r\nsel_clk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK) & ~0x50000;\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, sel_clk | sel_clk_binding);\r\nnvif_wr32(device, NV_PBUS_POWERCTRL_2, 0);\r\nreturn ret;\r\n}\r\nstatic int parse_lvds_manufacturer_table_header(struct drm_device *dev, struct nvbios *bios, struct lvdstableheader *lth)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nuint8_t lvds_ver, headerlen, recordlen;\r\nmemset(lth, 0, sizeof(struct lvdstableheader));\r\nif (bios->fp.lvdsmanufacturerpointer == 0x0) {\r\nNV_ERROR(drm, "Pointer to LVDS manufacturer table invalid\n");\r\nreturn -EINVAL;\r\n}\r\nlvds_ver = bios->data[bios->fp.lvdsmanufacturerpointer];\r\nswitch (lvds_ver) {\r\ncase 0x0a:\r\nheaderlen = 2;\r\nrecordlen = bios->data[bios->fp.lvdsmanufacturerpointer + 1];\r\nbreak;\r\ncase 0x30:\r\nheaderlen = bios->data[bios->fp.lvdsmanufacturerpointer + 1];\r\nif (headerlen < 0x1f) {\r\nNV_ERROR(drm, "LVDS table header not understood\n");\r\nreturn -EINVAL;\r\n}\r\nrecordlen = bios->data[bios->fp.lvdsmanufacturerpointer + 2];\r\nbreak;\r\ncase 0x40:\r\nheaderlen = bios->data[bios->fp.lvdsmanufacturerpointer + 1];\r\nif (headerlen < 0x7) {\r\nNV_ERROR(drm, "LVDS table header not understood\n");\r\nreturn -EINVAL;\r\n}\r\nrecordlen = bios->data[bios->fp.lvdsmanufacturerpointer + 2];\r\nbreak;\r\ndefault:\r\nNV_ERROR(drm,\r\n"LVDS table revision %d.%d not currently supported\n",\r\nlvds_ver >> 4, lvds_ver & 0xf);\r\nreturn -ENOSYS;\r\n}\r\nlth->lvds_ver = lvds_ver;\r\nlth->headerlen = headerlen;\r\nlth->recordlen = recordlen;\r\nreturn 0;\r\n}\r\nstatic int\r\nget_fp_strap(struct drm_device *dev, struct nvbios *bios)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvif_object *device = &drm->device.object;\r\nif (bios->major_version < 5 && bios->data[0x48] & 0x4)\r\nreturn NVReadVgaCrtc5758(dev, 0, 0xf) & 0xf;\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_TESLA)\r\nreturn (nvif_rd32(device, NV_PEXTDEV_BOOT_0) >> 24) & 0xf;\r\nelse\r\nreturn (nvif_rd32(device, NV_PEXTDEV_BOOT_0) >> 16) & 0xf;\r\n}\r\nstatic int parse_fp_mode_table(struct drm_device *dev, struct nvbios *bios)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nuint8_t *fptable;\r\nuint8_t fptable_ver, headerlen = 0, recordlen, fpentries = 0xf, fpindex;\r\nint ret, ofs, fpstrapping;\r\nstruct lvdstableheader lth;\r\nif (bios->fp.fptablepointer == 0x0) {\r\n#ifndef __powerpc__\r\nNV_ERROR(drm, "Pointer to flat panel table invalid\n");\r\n#endif\r\nbios->digital_min_front_porch = 0x4b;\r\nreturn 0;\r\n}\r\nfptable = &bios->data[bios->fp.fptablepointer];\r\nfptable_ver = fptable[0];\r\nswitch (fptable_ver) {\r\ncase 0x05:\r\nrecordlen = 42;\r\nofs = -1;\r\nbreak;\r\ncase 0x10:\r\nrecordlen = 44;\r\nofs = 0;\r\nbreak;\r\ncase 0x20:\r\nheaderlen = fptable[1];\r\nrecordlen = fptable[2];\r\nfpentries = fptable[3];\r\nbios->digital_min_front_porch = fptable[4];\r\nofs = -7;\r\nbreak;\r\ndefault:\r\nNV_ERROR(drm,\r\n"FP table revision %d.%d not currently supported\n",\r\nfptable_ver >> 4, fptable_ver & 0xf);\r\nreturn -ENOSYS;\r\n}\r\nif (!bios->is_mobile)\r\nreturn 0;\r\nret = parse_lvds_manufacturer_table_header(dev, bios, &lth);\r\nif (ret)\r\nreturn ret;\r\nif (lth.lvds_ver == 0x30 || lth.lvds_ver == 0x40) {\r\nbios->fp.fpxlatetableptr = bios->fp.lvdsmanufacturerpointer +\r\nlth.headerlen + 1;\r\nbios->fp.xlatwidth = lth.recordlen;\r\n}\r\nif (bios->fp.fpxlatetableptr == 0x0) {\r\nNV_ERROR(drm, "Pointer to flat panel xlat table invalid\n");\r\nreturn -EINVAL;\r\n}\r\nfpstrapping = get_fp_strap(dev, bios);\r\nfpindex = bios->data[bios->fp.fpxlatetableptr +\r\nfpstrapping * bios->fp.xlatwidth];\r\nif (fpindex > fpentries) {\r\nNV_ERROR(drm, "Bad flat panel table index\n");\r\nreturn -ENOENT;\r\n}\r\nif (lth.lvds_ver > 0x10)\r\nbios->fp_no_ddc = fpstrapping != 0xf || fpindex != 0xf;\r\nif (fpstrapping == 0xf || fpindex == 0xf)\r\nreturn 0;\r\nbios->fp.mode_ptr = bios->fp.fptablepointer + headerlen +\r\nrecordlen * fpindex + ofs;\r\nNV_INFO(drm, "BIOS FP mode: %dx%d (%dkHz pixel clock)\n",\r\nROM16(bios->data[bios->fp.mode_ptr + 11]) + 1,\r\nROM16(bios->data[bios->fp.mode_ptr + 25]) + 1,\r\nROM16(bios->data[bios->fp.mode_ptr + 7]) * 10);\r\nreturn 0;\r\n}\r\nbool nouveau_bios_fp_mode(struct drm_device *dev, struct drm_display_mode *mode)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvbios *bios = &drm->vbios;\r\nuint8_t *mode_entry = &bios->data[bios->fp.mode_ptr];\r\nif (!mode)\r\nreturn bios->fp.mode_ptr;\r\nmemset(mode, 0, sizeof(struct drm_display_mode));\r\nmode->clock = ROM16(mode_entry[7]) * 10;\r\nmode->hdisplay = ROM16(mode_entry[11]) + 1;\r\nmode->hsync_start = ROM16(mode_entry[17]) + 1;\r\nmode->hsync_end = ROM16(mode_entry[19]) + 1;\r\nmode->htotal = ROM16(mode_entry[21]) + 1;\r\nmode->vdisplay = ROM16(mode_entry[25]) + 1;\r\nmode->vsync_start = ROM16(mode_entry[31]) + 1;\r\nmode->vsync_end = ROM16(mode_entry[33]) + 1;\r\nmode->vtotal = ROM16(mode_entry[35]) + 1;\r\nmode->flags |= (mode_entry[37] & 0x10) ?\r\nDRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;\r\nmode->flags |= (mode_entry[37] & 0x1) ?\r\nDRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;\r\nmode->status = MODE_OK;\r\nmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_set_name(mode);\r\nreturn bios->fp.mode_ptr;\r\n}\r\nint nouveau_bios_parse_lvds_table(struct drm_device *dev, int pxclk, bool *dl, bool *if_is_24bit)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvbios *bios = &drm->vbios;\r\nint fpstrapping = get_fp_strap(dev, bios), lvdsmanufacturerindex = 0;\r\nstruct lvdstableheader lth;\r\nuint16_t lvdsofs;\r\nint ret, chip_version = bios->chip_version;\r\nret = parse_lvds_manufacturer_table_header(dev, bios, &lth);\r\nif (ret)\r\nreturn ret;\r\nswitch (lth.lvds_ver) {\r\ncase 0x0a:\r\nlvdsmanufacturerindex = bios->data[\r\nbios->fp.fpxlatemanufacturertableptr +\r\nfpstrapping];\r\nif (!pxclk)\r\nbreak;\r\nif (chip_version < 0x25) {\r\nlvdsmanufacturerindex =\r\n(bios->legacy.lvds_single_a_script_ptr & 1) ?\r\n2 : 0;\r\nif (pxclk >= bios->fp.duallink_transition_clk)\r\nlvdsmanufacturerindex++;\r\n} else if (chip_version < 0x30) {\r\nlvdsmanufacturerindex = 0;\r\n} else {\r\nlvdsmanufacturerindex = 0;\r\nif (pxclk >= bios->fp.duallink_transition_clk)\r\nlvdsmanufacturerindex = 2;\r\nif (pxclk >= 140000)\r\nlvdsmanufacturerindex = 3;\r\n}\r\nbreak;\r\ncase 0x30:\r\ncase 0x40:\r\nlvdsmanufacturerindex = fpstrapping;\r\nbreak;\r\ndefault:\r\nNV_ERROR(drm, "LVDS table revision not currently supported\n");\r\nreturn -ENOSYS;\r\n}\r\nlvdsofs = bios->fp.xlated_entry = bios->fp.lvdsmanufacturerpointer + lth.headerlen + lth.recordlen * lvdsmanufacturerindex;\r\nswitch (lth.lvds_ver) {\r\ncase 0x0a:\r\nbios->fp.power_off_for_reset = bios->data[lvdsofs] & 1;\r\nbios->fp.reset_after_pclk_change = bios->data[lvdsofs] & 2;\r\nbios->fp.dual_link = bios->data[lvdsofs] & 4;\r\nbios->fp.link_c_increment = bios->data[lvdsofs] & 8;\r\n*if_is_24bit = bios->data[lvdsofs] & 16;\r\nbreak;\r\ncase 0x30:\r\ncase 0x40:\r\nbios->fp.power_off_for_reset = true;\r\nbios->fp.reset_after_pclk_change = true;\r\nbios->fp.dual_link = bios->data[lvdsofs] & 1;\r\nbios->fp.if_is_24bit = bios->data[lvdsofs] & 2;\r\nbios->fp.strapless_is_24bit = bios->data[bios->fp.lvdsmanufacturerpointer + 4];\r\nbios->fp.duallink_transition_clk = ROM16(bios->data[bios->fp.lvdsmanufacturerpointer + 5]) * 10;\r\nbreak;\r\n}\r\nif (pxclk && (chip_version < 0x25 || chip_version > 0x28))\r\nbios->fp.dual_link = (pxclk >= bios->fp.duallink_transition_clk);\r\n*dl = bios->fp.dual_link;\r\nreturn 0;\r\n}\r\nint run_tmds_table(struct drm_device *dev, struct dcb_output *dcbent, int head, int pxclk)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvif_object *device = &drm->device.object;\r\nstruct nvbios *bios = &drm->vbios;\r\nint cv = bios->chip_version;\r\nuint16_t clktable = 0, scriptptr;\r\nuint32_t sel_clk_binding, sel_clk;\r\nif (cv >= 0x17 && cv != 0x1a && cv != 0x20 &&\r\ndcbent->location != DCB_LOC_ON_CHIP)\r\nreturn 0;\r\nswitch (ffs(dcbent->or)) {\r\ncase 1:\r\nclktable = bios->tmds.output0_script_ptr;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\nclktable = bios->tmds.output1_script_ptr;\r\nbreak;\r\n}\r\nif (!clktable) {\r\nNV_ERROR(drm, "Pixel clock comparison table not found\n");\r\nreturn -EINVAL;\r\n}\r\nscriptptr = clkcmptable(bios, clktable, pxclk);\r\nif (!scriptptr) {\r\nNV_ERROR(drm, "TMDS output init script not found\n");\r\nreturn -ENOENT;\r\n}\r\nsel_clk_binding = nvif_rd32(device, NV_PRAMDAC_SEL_CLK) & 0x50000;\r\nrun_digital_op_script(dev, scriptptr, dcbent, head, pxclk >= 165000);\r\nsel_clk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK) & ~0x50000;\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, sel_clk | sel_clk_binding);\r\nreturn 0;\r\n}\r\nstatic void parse_script_table_pointers(struct nvbios *bios, uint16_t offset)\r\n{\r\nbios->init_script_tbls_ptr = ROM16(bios->data[offset]);\r\n}\r\nstatic int parse_bit_A_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nuint16_t load_table_ptr;\r\nuint8_t version, headerlen, entrylen, num_entries;\r\nif (bitentry->length != 3) {\r\nNV_ERROR(drm, "Do not understand BIT A table\n");\r\nreturn -EINVAL;\r\n}\r\nload_table_ptr = ROM16(bios->data[bitentry->offset]);\r\nif (load_table_ptr == 0x0) {\r\nNV_DEBUG(drm, "Pointer to BIT loadval table invalid\n");\r\nreturn -EINVAL;\r\n}\r\nversion = bios->data[load_table_ptr];\r\nif (version != 0x10) {\r\nNV_ERROR(drm, "BIT loadval table version %d.%d not supported\n",\r\nversion >> 4, version & 0xF);\r\nreturn -ENOSYS;\r\n}\r\nheaderlen = bios->data[load_table_ptr + 1];\r\nentrylen = bios->data[load_table_ptr + 2];\r\nnum_entries = bios->data[load_table_ptr + 3];\r\nif (headerlen != 4 || entrylen != 4 || num_entries != 2) {\r\nNV_ERROR(drm, "Do not understand BIT loadval table\n");\r\nreturn -EINVAL;\r\n}\r\nbios->dactestval = ROM32(bios->data[load_table_ptr + headerlen]) & 0x3ff;\r\nreturn 0;\r\n}\r\nstatic int parse_bit_display_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (bitentry->length != 4) {\r\nNV_ERROR(drm, "Do not understand BIT display table\n");\r\nreturn -EINVAL;\r\n}\r\nbios->fp.fptablepointer = ROM16(bios->data[bitentry->offset + 2]);\r\nreturn 0;\r\n}\r\nstatic int parse_bit_init_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (bitentry->length < 14) {\r\nNV_ERROR(drm, "Do not understand init table\n");\r\nreturn -EINVAL;\r\n}\r\nparse_script_table_pointers(bios, bitentry->offset);\r\nreturn 0;\r\n}\r\nstatic int parse_bit_i_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nuint16_t daccmpoffset;\r\nuint8_t dacver, dacheaderlen;\r\nif (bitentry->length < 6) {\r\nNV_ERROR(drm, "BIT i table too short for needed information\n");\r\nreturn -EINVAL;\r\n}\r\nbios->feature_byte = bios->data[bitentry->offset + 5];\r\nbios->is_mobile = bios->feature_byte & FEATURE_MOBILE;\r\nif (bitentry->length < 15) {\r\nNV_WARN(drm, "BIT i table not long enough for DAC load "\r\n"detection comparison table\n");\r\nreturn -EINVAL;\r\n}\r\ndaccmpoffset = ROM16(bios->data[bitentry->offset + 13]);\r\nif (!daccmpoffset)\r\nreturn 0;\r\ndacver = bios->data[daccmpoffset];\r\ndacheaderlen = bios->data[daccmpoffset + 1];\r\nif (dacver != 0x00 && dacver != 0x10) {\r\nNV_WARN(drm, "DAC load detection comparison table version "\r\n"%d.%d not known\n", dacver >> 4, dacver & 0xf);\r\nreturn -ENOSYS;\r\n}\r\nbios->dactestval = ROM32(bios->data[daccmpoffset + dacheaderlen]);\r\nbios->tvdactestval = ROM32(bios->data[daccmpoffset + dacheaderlen + 4]);\r\nreturn 0;\r\n}\r\nstatic int parse_bit_lvds_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (bitentry->length != 2) {\r\nNV_ERROR(drm, "Do not understand BIT LVDS table\n");\r\nreturn -EINVAL;\r\n}\r\nbios->fp.lvdsmanufacturerpointer = ROM16(bios->data[bitentry->offset]);\r\nreturn 0;\r\n}\r\nstatic int\r\nparse_bit_M_tbl_entry(struct drm_device *dev, struct nvbios *bios,\r\nstruct bit_entry *bitentry)\r\n{\r\nif (bitentry->length < 0x5)\r\nreturn 0;\r\nif (bitentry->version < 2) {\r\nbios->ram_restrict_group_count = bios->data[bitentry->offset + 2];\r\nbios->ram_restrict_tbl_ptr = ROM16(bios->data[bitentry->offset + 3]);\r\n} else {\r\nbios->ram_restrict_group_count = bios->data[bitentry->offset + 0];\r\nbios->ram_restrict_tbl_ptr = ROM16(bios->data[bitentry->offset + 1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_bit_tmds_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nuint16_t tmdstableptr, script1, script2;\r\nif (bitentry->length != 2) {\r\nNV_ERROR(drm, "Do not understand BIT TMDS table\n");\r\nreturn -EINVAL;\r\n}\r\ntmdstableptr = ROM16(bios->data[bitentry->offset]);\r\nif (!tmdstableptr) {\r\nNV_ERROR(drm, "Pointer to TMDS table invalid\n");\r\nreturn -EINVAL;\r\n}\r\nNV_INFO(drm, "TMDS table version %d.%d\n",\r\nbios->data[tmdstableptr] >> 4, bios->data[tmdstableptr] & 0xf);\r\nif (bios->data[tmdstableptr] != 0x11)\r\nreturn -ENOSYS;\r\nscript1 = ROM16(bios->data[tmdstableptr + 7]);\r\nscript2 = ROM16(bios->data[tmdstableptr + 9]);\r\nif (bios->data[script1] != 'q' || bios->data[script2] != 'q')\r\nNV_WARN(drm, "TMDS table script pointers not stubbed\n");\r\nbios->tmds.output0_script_ptr = ROM16(bios->data[tmdstableptr + 11]);\r\nbios->tmds.output1_script_ptr = ROM16(bios->data[tmdstableptr + 13]);\r\nreturn 0;\r\n}\r\nint\r\nbit_table(struct drm_device *dev, u8 id, struct bit_entry *bit)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvbios *bios = &drm->vbios;\r\nu8 entries, *entry;\r\nif (bios->type != NVBIOS_BIT)\r\nreturn -ENODEV;\r\nentries = bios->data[bios->offset + 10];\r\nentry = &bios->data[bios->offset + 12];\r\nwhile (entries--) {\r\nif (entry[0] == id) {\r\nbit->id = entry[0];\r\nbit->version = entry[1];\r\nbit->length = ROM16(entry[2]);\r\nbit->offset = ROM16(entry[4]);\r\nbit->data = ROMPTR(dev, entry[4]);\r\nreturn 0;\r\n}\r\nentry += bios->data[bios->offset + 9];\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int\r\nparse_bit_table(struct nvbios *bios, const uint16_t bitoffset,\r\nstruct bit_table *table)\r\n{\r\nstruct drm_device *dev = bios->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct bit_entry bitentry;\r\nif (bit_table(dev, table->id, &bitentry) == 0)\r\nreturn table->parse_fn(dev, bios, &bitentry);\r\nNV_INFO(drm, "BIT table '%c' not found\n", table->id);\r\nreturn -ENOSYS;\r\n}\r\nstatic int\r\nparse_bit_structure(struct nvbios *bios, const uint16_t bitoffset)\r\n{\r\nint ret;\r\nret = parse_bit_table(bios, bitoffset, &BIT_TABLE('i', i));\r\nif (ret)\r\nreturn ret;\r\nif (bios->major_version >= 0x60)\r\nparse_bit_table(bios, bitoffset, &BIT_TABLE('A', A));\r\nparse_bit_table(bios, bitoffset, &BIT_TABLE('D', display));\r\nret = parse_bit_table(bios, bitoffset, &BIT_TABLE('I', init));\r\nif (ret)\r\nreturn ret;\r\nparse_bit_table(bios, bitoffset, &BIT_TABLE('M', M));\r\nparse_bit_table(bios, bitoffset, &BIT_TABLE('L', lvds));\r\nparse_bit_table(bios, bitoffset, &BIT_TABLE('T', tmds));\r\nreturn 0;\r\n}\r\nstatic int parse_bmp_structure(struct drm_device *dev, struct nvbios *bios, unsigned int offset)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nuint8_t *bmp = &bios->data[offset], bmp_version_major, bmp_version_minor;\r\nuint16_t bmplength;\r\nuint16_t legacy_scripts_offset, legacy_i2c_offset;\r\nbios->digital_min_front_porch = 0x4b;\r\nbios->fmaxvco = 256000;\r\nbios->fminvco = 128000;\r\nbios->fp.duallink_transition_clk = 90000;\r\nbmp_version_major = bmp[5];\r\nbmp_version_minor = bmp[6];\r\nNV_INFO(drm, "BMP version %d.%d\n",\r\nbmp_version_major, bmp_version_minor);\r\nif (bmp_version_major < 5)\r\n*(uint16_t *)&bios->data[0x36] = 0;\r\nif ((bmp_version_major < 5 && bmp_version_minor != 1) || bmp_version_major > 5) {\r\nNV_ERROR(drm, "You have an unsupported BMP version. "\r\n"Please send in your bios\n");\r\nreturn -ENOSYS;\r\n}\r\nif (bmp_version_major == 0)\r\nreturn 0;\r\nelse if (bmp_version_major == 1)\r\nbmplength = 44;\r\nelse if (bmp_version_major == 2)\r\nbmplength = 48;\r\nelse if (bmp_version_major == 3)\r\nbmplength = 54;\r\nelse if (bmp_version_major == 4 || bmp_version_minor < 0x1)\r\nbmplength = 62;\r\nelse if (bmp_version_minor < 0x6)\r\nbmplength = 67;\r\nelse if (bmp_version_minor < 0x10)\r\nbmplength = 75;\r\nelse if (bmp_version_minor == 0x10)\r\nbmplength = 89;\r\nelse if (bmp_version_minor < 0x14)\r\nbmplength = 118;\r\nelse if (bmp_version_minor < 0x24)\r\nbmplength = 123;\r\nelse if (bmp_version_minor < 0x27)\r\nbmplength = 144;\r\nelse\r\nbmplength = 158;\r\nif (nv_cksum(bmp, 8)) {\r\nNV_ERROR(drm, "Bad BMP checksum\n");\r\nreturn -EINVAL;\r\n}\r\nbios->feature_byte = bmp[9];\r\nif (bmp_version_major < 5 || bmp_version_minor < 0x10)\r\nbios->old_style_init = true;\r\nlegacy_scripts_offset = 18;\r\nif (bmp_version_major < 2)\r\nlegacy_scripts_offset -= 4;\r\nbios->init_script_tbls_ptr = ROM16(bmp[legacy_scripts_offset]);\r\nbios->extra_init_script_tbl_ptr = ROM16(bmp[legacy_scripts_offset + 2]);\r\nif (bmp_version_major > 2) {\r\nbios->legacy.mem_init_tbl_ptr = ROM16(bmp[24]);\r\nbios->legacy.sdr_seq_tbl_ptr = ROM16(bmp[26]);\r\nbios->legacy.ddr_seq_tbl_ptr = ROM16(bmp[28]);\r\n}\r\nlegacy_i2c_offset = 0x48;\r\nif (bmplength > 61)\r\nlegacy_i2c_offset = offset + 54;\r\nbios->legacy.i2c_indices.crt = bios->data[legacy_i2c_offset];\r\nbios->legacy.i2c_indices.tv = bios->data[legacy_i2c_offset + 1];\r\nbios->legacy.i2c_indices.panel = bios->data[legacy_i2c_offset + 2];\r\nif (bmplength > 74) {\r\nbios->fmaxvco = ROM32(bmp[67]);\r\nbios->fminvco = ROM32(bmp[71]);\r\n}\r\nif (bmplength > 88)\r\nparse_script_table_pointers(bios, offset + 75);\r\nif (bmplength > 94) {\r\nbios->tmds.output0_script_ptr = ROM16(bmp[89]);\r\nbios->tmds.output1_script_ptr = ROM16(bmp[91]);\r\nbios->legacy.lvds_single_a_script_ptr = ROM16(bmp[95]);\r\n}\r\nif (bmplength > 108) {\r\nbios->fp.fptablepointer = ROM16(bmp[105]);\r\nbios->fp.fpxlatetableptr = ROM16(bmp[107]);\r\nbios->fp.xlatwidth = 1;\r\n}\r\nif (bmplength > 120) {\r\nbios->fp.lvdsmanufacturerpointer = ROM16(bmp[117]);\r\nbios->fp.fpxlatemanufacturertableptr = ROM16(bmp[119]);\r\n}\r\n#if 0\r\nif (bmplength > 143)\r\nbios->pll_limit_tbl_ptr = ROM16(bmp[142]);\r\n#endif\r\nif (bmplength > 157)\r\nbios->fp.duallink_transition_clk = ROM16(bmp[156]) * 10;\r\nreturn 0;\r\n}\r\nstatic uint16_t findstr(uint8_t *data, int n, const uint8_t *str, int len)\r\n{\r\nint i, j;\r\nfor (i = 0; i <= (n - len); i++) {\r\nfor (j = 0; j < len; j++)\r\nif (data[i + j] != str[j])\r\nbreak;\r\nif (j == len)\r\nreturn i;\r\n}\r\nreturn 0;\r\n}\r\nvoid *\r\nolddcb_table(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nu8 *dcb = NULL;\r\nif (drm->device.info.family > NV_DEVICE_INFO_V0_TNT)\r\ndcb = ROMPTR(dev, drm->vbios.data[0x36]);\r\nif (!dcb) {\r\nNV_WARN(drm, "No DCB data found in VBIOS\n");\r\nreturn NULL;\r\n}\r\nif (dcb[0] >= 0x42) {\r\nNV_WARN(drm, "DCB version 0x%02x unknown\n", dcb[0]);\r\nreturn NULL;\r\n} else\r\nif (dcb[0] >= 0x30) {\r\nif (ROM32(dcb[6]) == 0x4edcbdcb)\r\nreturn dcb;\r\n} else\r\nif (dcb[0] >= 0x20) {\r\nif (ROM32(dcb[4]) == 0x4edcbdcb)\r\nreturn dcb;\r\n} else\r\nif (dcb[0] >= 0x15) {\r\nif (!memcmp(&dcb[-7], "DEV_REC", 7))\r\nreturn dcb;\r\n} else {\r\nNV_WARN(drm, "No useful DCB data in VBIOS\n");\r\nreturn NULL;\r\n}\r\nNV_WARN(drm, "DCB header validation failed\n");\r\nreturn NULL;\r\n}\r\nvoid *\r\nolddcb_outp(struct drm_device *dev, u8 idx)\r\n{\r\nu8 *dcb = olddcb_table(dev);\r\nif (dcb && dcb[0] >= 0x30) {\r\nif (idx < dcb[2])\r\nreturn dcb + dcb[1] + (idx * dcb[3]);\r\n} else\r\nif (dcb && dcb[0] >= 0x20) {\r\nu8 *i2c = ROMPTR(dev, dcb[2]);\r\nu8 *ent = dcb + 8 + (idx * 8);\r\nif (i2c && ent < i2c)\r\nreturn ent;\r\n} else\r\nif (dcb && dcb[0] >= 0x15) {\r\nu8 *i2c = ROMPTR(dev, dcb[2]);\r\nu8 *ent = dcb + 4 + (idx * 10);\r\nif (i2c && ent < i2c)\r\nreturn ent;\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nolddcb_outp_foreach(struct drm_device *dev, void *data,\r\nint (*exec)(struct drm_device *, void *, int idx, u8 *outp))\r\n{\r\nint ret, idx = -1;\r\nu8 *outp = NULL;\r\nwhile ((outp = olddcb_outp(dev, ++idx))) {\r\nif (ROM32(outp[0]) == 0x00000000)\r\nbreak;\r\nif (ROM32(outp[0]) == 0xffffffff)\r\nbreak;\r\nif ((outp[0] & 0x0f) == DCB_OUTPUT_UNUSED)\r\ncontinue;\r\nif ((outp[0] & 0x0f) == DCB_OUTPUT_EOL)\r\nbreak;\r\nret = exec(dev, data, idx, outp);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nu8 *\r\nolddcb_conntab(struct drm_device *dev)\r\n{\r\nu8 *dcb = olddcb_table(dev);\r\nif (dcb && dcb[0] >= 0x30 && dcb[1] >= 0x16) {\r\nu8 *conntab = ROMPTR(dev, dcb[0x14]);\r\nif (conntab && conntab[0] >= 0x30 && conntab[0] <= 0x40)\r\nreturn conntab;\r\n}\r\nreturn NULL;\r\n}\r\nu8 *\r\nolddcb_conn(struct drm_device *dev, u8 idx)\r\n{\r\nu8 *conntab = olddcb_conntab(dev);\r\nif (conntab && idx < conntab[2])\r\nreturn conntab + conntab[1] + (idx * conntab[3]);\r\nreturn NULL;\r\n}\r\nstatic struct dcb_output *new_dcb_entry(struct dcb_table *dcb)\r\n{\r\nstruct dcb_output *entry = &dcb->entry[dcb->entries];\r\nmemset(entry, 0, sizeof(struct dcb_output));\r\nentry->index = dcb->entries++;\r\nreturn entry;\r\n}\r\nstatic void fabricate_dcb_output(struct dcb_table *dcb, int type, int i2c,\r\nint heads, int or)\r\n{\r\nstruct dcb_output *entry = new_dcb_entry(dcb);\r\nentry->type = type;\r\nentry->i2c_index = i2c;\r\nentry->heads = heads;\r\nif (type != DCB_OUTPUT_ANALOG)\r\nentry->location = !DCB_LOC_ON_CHIP;\r\nentry->or = or;\r\n}\r\nstatic bool\r\nparse_dcb20_entry(struct drm_device *dev, struct dcb_table *dcb,\r\nuint32_t conn, uint32_t conf, struct dcb_output *entry)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nint link = 0;\r\nentry->type = conn & 0xf;\r\nentry->i2c_index = (conn >> 4) & 0xf;\r\nentry->heads = (conn >> 8) & 0xf;\r\nentry->connector = (conn >> 12) & 0xf;\r\nentry->bus = (conn >> 16) & 0xf;\r\nentry->location = (conn >> 20) & 0x3;\r\nentry->or = (conn >> 24) & 0xf;\r\nswitch (entry->type) {\r\ncase DCB_OUTPUT_ANALOG:\r\nentry->crtconf.maxfreq = (dcb->version < 0x30) ?\r\n(conf & 0xffff) * 10 :\r\n(conf & 0xff) * 10000;\r\nbreak;\r\ncase DCB_OUTPUT_LVDS:\r\n{\r\nuint32_t mask;\r\nif (conf & 0x1)\r\nentry->lvdsconf.use_straps_for_mode = true;\r\nif (dcb->version < 0x22) {\r\nmask = ~0xd;\r\nentry->lvdsconf.use_straps_for_mode = true;\r\nif (conf & 0x4 || conf & 0x8)\r\nentry->lvdsconf.use_power_scripts = true;\r\n} else {\r\nmask = ~0x7;\r\nif (conf & 0x2)\r\nentry->lvdsconf.use_acpi_for_edid = true;\r\nif (conf & 0x4)\r\nentry->lvdsconf.use_power_scripts = true;\r\nentry->lvdsconf.sor.link = (conf & 0x00000030) >> 4;\r\nlink = entry->lvdsconf.sor.link;\r\n}\r\nif (conf & mask) {\r\nif (dcb->version >= 0x40)\r\nbreak;\r\nNV_ERROR(drm, "Unknown LVDS configuration bits, "\r\n"please report\n");\r\n}\r\nbreak;\r\n}\r\ncase DCB_OUTPUT_TV:\r\n{\r\nif (dcb->version >= 0x30)\r\nentry->tvconf.has_component_output = conf & (0x8 << 4);\r\nelse\r\nentry->tvconf.has_component_output = false;\r\nbreak;\r\n}\r\ncase DCB_OUTPUT_DP:\r\nentry->dpconf.sor.link = (conf & 0x00000030) >> 4;\r\nentry->extdev = (conf & 0x0000ff00) >> 8;\r\nswitch ((conf & 0x00e00000) >> 21) {\r\ncase 0:\r\nentry->dpconf.link_bw = 162000;\r\nbreak;\r\ncase 1:\r\nentry->dpconf.link_bw = 270000;\r\nbreak;\r\ndefault:\r\nentry->dpconf.link_bw = 540000;\r\nbreak;\r\n}\r\nswitch ((conf & 0x0f000000) >> 24) {\r\ncase 0xf:\r\ncase 0x4:\r\nentry->dpconf.link_nr = 4;\r\nbreak;\r\ncase 0x3:\r\ncase 0x2:\r\nentry->dpconf.link_nr = 2;\r\nbreak;\r\ndefault:\r\nentry->dpconf.link_nr = 1;\r\nbreak;\r\n}\r\nlink = entry->dpconf.sor.link;\r\nbreak;\r\ncase DCB_OUTPUT_TMDS:\r\nif (dcb->version >= 0x40) {\r\nentry->tmdsconf.sor.link = (conf & 0x00000030) >> 4;\r\nentry->extdev = (conf & 0x0000ff00) >> 8;\r\nlink = entry->tmdsconf.sor.link;\r\n}\r\nelse if (dcb->version >= 0x30)\r\nentry->tmdsconf.slave_addr = (conf & 0x00000700) >> 8;\r\nelse if (dcb->version >= 0x22)\r\nentry->tmdsconf.slave_addr = (conf & 0x00000070) >> 4;\r\nbreak;\r\ncase DCB_OUTPUT_EOL:\r\ndcb->entries--;\r\nreturn false;\r\ndefault:\r\nbreak;\r\n}\r\nif (dcb->version < 0x40) {\r\nentry->duallink_possible =\r\n((1 << (ffs(entry->or) - 1)) * 3 == entry->or);\r\n} else {\r\nentry->duallink_possible = (entry->sorconf.link == 3);\r\n}\r\nif (conf & 0x100000)\r\nentry->i2c_upper_default = true;\r\nentry->hasht = (entry->location << 4) | entry->type;\r\nentry->hashm = (entry->heads << 8) | (link << 6) | entry->or;\r\nreturn true;\r\n}\r\nstatic bool\r\nparse_dcb15_entry(struct drm_device *dev, struct dcb_table *dcb,\r\nuint32_t conn, uint32_t conf, struct dcb_output *entry)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nswitch (conn & 0x0000000f) {\r\ncase 0:\r\nentry->type = DCB_OUTPUT_ANALOG;\r\nbreak;\r\ncase 1:\r\nentry->type = DCB_OUTPUT_TV;\r\nbreak;\r\ncase 2:\r\ncase 4:\r\nif (conn & 0x10)\r\nentry->type = DCB_OUTPUT_LVDS;\r\nelse\r\nentry->type = DCB_OUTPUT_TMDS;\r\nbreak;\r\ncase 3:\r\nentry->type = DCB_OUTPUT_LVDS;\r\nbreak;\r\ndefault:\r\nNV_ERROR(drm, "Unknown DCB type %d\n", conn & 0x0000000f);\r\nreturn false;\r\n}\r\nentry->i2c_index = (conn & 0x0003c000) >> 14;\r\nentry->heads = ((conn & 0x001c0000) >> 18) + 1;\r\nentry->or = entry->heads;\r\nentry->location = (conn & 0x01e00000) >> 21;\r\nentry->bus = (conn & 0x0e000000) >> 25;\r\nentry->duallink_possible = false;\r\nswitch (entry->type) {\r\ncase DCB_OUTPUT_ANALOG:\r\nentry->crtconf.maxfreq = (conf & 0xffff) * 10;\r\nbreak;\r\ncase DCB_OUTPUT_TV:\r\nentry->tvconf.has_component_output = false;\r\nbreak;\r\ncase DCB_OUTPUT_LVDS:\r\nif ((conn & 0x00003f00) >> 8 != 0x10)\r\nentry->lvdsconf.use_straps_for_mode = true;\r\nentry->lvdsconf.use_power_scripts = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nstatic\r\nvoid merge_like_dcb_entries(struct drm_device *dev, struct dcb_table *dcb)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nint i, newentries = 0;\r\nfor (i = 0; i < dcb->entries; i++) {\r\nstruct dcb_output *ient = &dcb->entry[i];\r\nint j;\r\nfor (j = i + 1; j < dcb->entries; j++) {\r\nstruct dcb_output *jent = &dcb->entry[j];\r\nif (jent->type == 100)\r\ncontinue;\r\nif (jent->i2c_index == ient->i2c_index &&\r\njent->type == ient->type &&\r\njent->location == ient->location &&\r\njent->or == ient->or) {\r\nNV_INFO(drm, "Merging DCB entries %d and %d\n",\r\ni, j);\r\nient->heads |= jent->heads;\r\njent->type = 100;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < dcb->entries; i++) {\r\nif (dcb->entry[i].type == 100)\r\ncontinue;\r\nif (newentries != i) {\r\ndcb->entry[newentries] = dcb->entry[i];\r\ndcb->entry[newentries].index = newentries;\r\n}\r\nnewentries++;\r\n}\r\ndcb->entries = newentries;\r\n}\r\nstatic bool\r\napply_dcb_encoder_quirks(struct drm_device *dev, int idx, u32 *conn, u32 *conf)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct dcb_table *dcb = &drm->vbios.dcb;\r\nif (nv_match_device(dev, 0x040d, 0x1028, 0x019b)) {\r\nif (*conn == 0x02026312 && *conf == 0x00000020)\r\nreturn false;\r\n}\r\nif (nv_match_device(dev, 0x0201, 0x1462, 0x8851)) {\r\nif (*conn == 0xf2005014 && *conf == 0xffffffff) {\r\nfabricate_dcb_output(dcb, DCB_OUTPUT_TMDS, 1, 1, 1);\r\nreturn false;\r\n}\r\n}\r\nif (nv_match_device(dev, 0x0ca3, 0x1682, 0x3003)) {\r\nif (idx == 0) {\r\n*conn = 0x02001300;\r\n*conf = 0x00000028;\r\n} else\r\nif (idx == 1) {\r\n*conn = 0x01010312;\r\n*conf = 0x00020030;\r\n} else\r\nif (idx == 2) {\r\n*conn = 0x01010310;\r\n*conf = 0x00000028;\r\n} else\r\nif (idx == 3) {\r\n*conn = 0x02022362;\r\n*conf = 0x00020010;\r\n} else {\r\n*conn = 0x0000000e;\r\n*conf = 0x00000000;\r\n}\r\n}\r\nif (nv_match_device(dev, 0x0615, 0x1682, 0x2605)) {\r\nif (idx == 0) {\r\n*conn = 0x02002300;\r\n*conf = 0x00000028;\r\n} else\r\nif (idx == 1) {\r\n*conn = 0x01010312;\r\n*conf = 0x00020030;\r\n} else\r\nif (idx == 2) {\r\n*conn = 0x04020310;\r\n*conf = 0x00000028;\r\n} else\r\nif (idx == 3) {\r\n*conn = 0x02021322;\r\n*conf = 0x00020010;\r\n} else {\r\n*conn = 0x0000000e;\r\n*conf = 0x00000000;\r\n}\r\n}\r\nif (nv_match_device(dev, 0x0421, 0x3842, 0xc793)) {\r\nif (idx == 0 && *conn == 0x02000300)\r\n*conn = 0x02011300;\r\nelse\r\nif (idx == 1 && *conn == 0x04011310)\r\n*conn = 0x04000310;\r\nelse\r\nif (idx == 2 && *conn == 0x02011312)\r\n*conn = 0x02000312;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\nfabricate_dcb_encoder_table(struct drm_device *dev, struct nvbios *bios)\r\n{\r\nstruct dcb_table *dcb = &bios->dcb;\r\nint all_heads = (nv_two_heads(dev) ? 3 : 1);\r\n#ifdef __powerpc__\r\nif (of_machine_is_compatible("PowerMac4,5")) {\r\nfabricate_dcb_output(dcb, DCB_OUTPUT_TMDS, 0, all_heads, 1);\r\nfabricate_dcb_output(dcb, DCB_OUTPUT_ANALOG, 1, all_heads, 2);\r\nreturn;\r\n}\r\n#endif\r\nfabricate_dcb_output(dcb, DCB_OUTPUT_ANALOG,\r\nbios->legacy.i2c_indices.crt, 1, 1);\r\nif (nv04_tv_identify(dev, bios->legacy.i2c_indices.tv) >= 0)\r\nfabricate_dcb_output(dcb, DCB_OUTPUT_TV,\r\nbios->legacy.i2c_indices.tv,\r\nall_heads, 0);\r\nelse if (bios->tmds.output0_script_ptr ||\r\nbios->tmds.output1_script_ptr)\r\nfabricate_dcb_output(dcb, DCB_OUTPUT_TMDS,\r\nbios->legacy.i2c_indices.panel,\r\nall_heads, 1);\r\n}\r\nstatic int\r\nparse_dcb_entry(struct drm_device *dev, void *data, int idx, u8 *outp)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct dcb_table *dcb = &drm->vbios.dcb;\r\nu32 conf = (dcb->version >= 0x20) ? ROM32(outp[4]) : ROM32(outp[6]);\r\nu32 conn = ROM32(outp[0]);\r\nbool ret;\r\nif (apply_dcb_encoder_quirks(dev, idx, &conn, &conf)) {\r\nstruct dcb_output *entry = new_dcb_entry(dcb);\r\nNV_INFO(drm, "DCB outp %02d: %08x %08x\n", idx, conn, conf);\r\nif (dcb->version >= 0x20)\r\nret = parse_dcb20_entry(dev, dcb, conn, conf, entry);\r\nelse\r\nret = parse_dcb15_entry(dev, dcb, conn, conf, entry);\r\nif (!ret)\r\nreturn 1;\r\nif (entry->type == DCB_OUTPUT_TV &&\r\nentry->location == DCB_LOC_ON_CHIP)\r\nentry->i2c_index = 0x0f;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ndcb_fake_connectors(struct nvbios *bios)\r\n{\r\nstruct dcb_table *dcbt = &bios->dcb;\r\nu8 map[16] = { };\r\nint i, idx = 0;\r\nif (!nv_match_device(bios->dev, 0x0392, 0x107d, 0x20a2)) {\r\nfor (i = 0; i < dcbt->entries; i++) {\r\nif (dcbt->entry[i].connector)\r\nreturn;\r\n}\r\n}\r\nfor (i = 0; i < dcbt->entries; i++) {\r\nu8 i2c = dcbt->entry[i].i2c_index;\r\nif (i2c == 0x0f) {\r\ndcbt->entry[i].connector = idx++;\r\n} else {\r\nif (!map[i2c])\r\nmap[i2c] = ++idx;\r\ndcbt->entry[i].connector = map[i2c] - 1;\r\n}\r\n}\r\nif (i > 1) {\r\nu8 *conntab = olddcb_conntab(bios->dev);\r\nif (conntab)\r\nconntab[0] = 0x00;\r\n}\r\n}\r\nstatic int\r\nparse_dcb_table(struct drm_device *dev, struct nvbios *bios)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct dcb_table *dcb = &bios->dcb;\r\nu8 *dcbt, *conn;\r\nint idx;\r\ndcbt = olddcb_table(dev);\r\nif (!dcbt) {\r\nif (bios->type == NVBIOS_BMP) {\r\nfabricate_dcb_encoder_table(dev, bios);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nNV_INFO(drm, "DCB version %d.%d\n", dcbt[0] >> 4, dcbt[0] & 0xf);\r\ndcb->version = dcbt[0];\r\nolddcb_outp_foreach(dev, NULL, parse_dcb_entry);\r\nif (dcb->version < 0x21)\r\nmerge_like_dcb_entries(dev, dcb);\r\nidx = -1;\r\nwhile ((conn = olddcb_conn(dev, ++idx))) {\r\nif (conn[0] != 0xff) {\r\nif (olddcb_conntab(dev)[3] < 4)\r\nNV_INFO(drm, "DCB conn %02d: %04x\n",\r\nidx, ROM16(conn[0]));\r\nelse\r\nNV_INFO(drm, "DCB conn %02d: %08x\n",\r\nidx, ROM32(conn[0]));\r\n}\r\n}\r\ndcb_fake_connectors(bios);\r\nreturn 0;\r\n}\r\nstatic int load_nv17_hwsq_ucode_entry(struct drm_device *dev, struct nvbios *bios, uint16_t hwsq_offset, int entry)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvif_object *device = &drm->device.object;\r\nuint8_t bytes_to_write;\r\nuint16_t hwsq_entry_offset;\r\nint i;\r\nif (bios->data[hwsq_offset] <= entry) {\r\nNV_ERROR(drm, "Too few entries in HW sequencer table for "\r\n"requested entry\n");\r\nreturn -ENOENT;\r\n}\r\nbytes_to_write = bios->data[hwsq_offset + 1];\r\nif (bytes_to_write != 36) {\r\nNV_ERROR(drm, "Unknown HW sequencer entry size\n");\r\nreturn -EINVAL;\r\n}\r\nNV_INFO(drm, "Loading NV17 power sequencing microcode\n");\r\nhwsq_entry_offset = hwsq_offset + 2 + entry * bytes_to_write;\r\nnvif_wr32(device, 0x00001304, ROM32(bios->data[hwsq_entry_offset]));\r\nbytes_to_write -= 4;\r\nfor (i = 0; i < bytes_to_write; i += 4)\r\nnvif_wr32(device, 0x00001400 + i, ROM32(bios->data[hwsq_entry_offset + i + 4]));\r\nnvif_wr32(device, NV_PBUS_DEBUG_4, nvif_rd32(device, NV_PBUS_DEBUG_4) | 0x18);\r\nreturn 0;\r\n}\r\nstatic int load_nv17_hw_sequencer_ucode(struct drm_device *dev,\r\nstruct nvbios *bios)\r\n{\r\nconst uint8_t hwsq_signature[] = { 'H', 'W', 'S', 'Q' };\r\nconst int sz = sizeof(hwsq_signature);\r\nint hwsq_offset;\r\nhwsq_offset = findstr(bios->data, bios->length, hwsq_signature, sz);\r\nif (!hwsq_offset)\r\nreturn 0;\r\nreturn load_nv17_hwsq_ucode_entry(dev, bios, hwsq_offset + sz, 0);\r\n}\r\nuint8_t *nouveau_bios_embedded_edid(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvbios *bios = &drm->vbios;\r\nconst uint8_t edid_sig[] = {\r\n0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 };\r\nuint16_t offset = 0;\r\nuint16_t newoffset;\r\nint searchlen = NV_PROM_SIZE;\r\nif (bios->fp.edid)\r\nreturn bios->fp.edid;\r\nwhile (searchlen) {\r\nnewoffset = findstr(&bios->data[offset], searchlen,\r\nedid_sig, 8);\r\nif (!newoffset)\r\nreturn NULL;\r\noffset += newoffset;\r\nif (!nv_cksum(&bios->data[offset], EDID1_LEN))\r\nbreak;\r\nsearchlen -= offset;\r\noffset++;\r\n}\r\nNV_INFO(drm, "Found EDID in BIOS\n");\r\nreturn bios->fp.edid = &bios->data[offset];\r\n}\r\nstatic bool NVInitVBIOS(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvkm_bios *bios = nvxx_bios(&drm->device);\r\nstruct nvbios *legacy = &drm->vbios;\r\nmemset(legacy, 0, sizeof(struct nvbios));\r\nspin_lock_init(&legacy->lock);\r\nlegacy->dev = dev;\r\nlegacy->data = bios->data;\r\nlegacy->length = bios->size;\r\nlegacy->major_version = bios->version.major;\r\nlegacy->chip_version = bios->version.chip;\r\nif (bios->bit_offset) {\r\nlegacy->type = NVBIOS_BIT;\r\nlegacy->offset = bios->bit_offset;\r\nreturn !parse_bit_structure(legacy, legacy->offset + 6);\r\n} else\r\nif (bios->bmp_offset) {\r\nlegacy->type = NVBIOS_BMP;\r\nlegacy->offset = bios->bmp_offset;\r\nreturn !parse_bmp_structure(dev, legacy, legacy->offset);\r\n}\r\nreturn false;\r\n}\r\nint\r\nnouveau_run_vbios_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvbios *bios = &drm->vbios;\r\nint ret = 0;\r\nbios->state.crtchead = 0;\r\nif (bios->major_version < 5)\r\nload_nv17_hw_sequencer_ucode(dev, bios);\r\nif (bios->execute) {\r\nbios->fp.last_script_invoc = 0;\r\nbios->fp.lvds_init_run = false;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool\r\nnouveau_bios_posted(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nunsigned htotal;\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_TESLA)\r\nreturn true;\r\nhtotal = NVReadVgaCrtc(dev, 0, 0x06);\r\nhtotal |= (NVReadVgaCrtc(dev, 0, 0x07) & 0x01) << 8;\r\nhtotal |= (NVReadVgaCrtc(dev, 0, 0x07) & 0x20) << 4;\r\nhtotal |= (NVReadVgaCrtc(dev, 0, 0x25) & 0x01) << 10;\r\nhtotal |= (NVReadVgaCrtc(dev, 0, 0x41) & 0x01) << 11;\r\nreturn (htotal != 0);\r\n}\r\nint\r\nnouveau_bios_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvbios *bios = &drm->vbios;\r\nint ret;\r\nif (!dev->pdev)\r\nreturn 0;\r\nif (!NVInitVBIOS(dev))\r\nreturn -ENODEV;\r\nret = parse_dcb_table(dev, bios);\r\nif (ret)\r\nreturn ret;\r\nif (!bios->major_version)\r\nreturn 0;\r\nbios->execute = false;\r\nif (!nouveau_bios_posted(dev)) {\r\nNV_INFO(drm, "Adaptor not initialised, "\r\n"running VBIOS init tables.\n");\r\nbios->execute = true;\r\n}\r\nret = nouveau_run_vbios_init(dev);\r\nif (ret)\r\nreturn ret;\r\nif (bios->major_version < 5)\r\nbios->is_mobile = NVReadVgaCrtc(dev, 0, NV_CIO_CRE_4B) & 0x40;\r\nif (bios->is_mobile || bios->major_version >= 5)\r\nret = parse_fp_mode_table(dev, bios);\r\nbios->execute = true;\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_bios_takedown(struct drm_device *dev)\r\n{\r\n}
