const struct old_serial_port *spk_serial_init(int index)\r\n{\r\nint baud = 9600, quot = 0;\r\nunsigned int cval = 0;\r\nint cflag = CREAD | HUPCL | CLOCAL | B9600 | CS8;\r\nconst struct old_serial_port *ser;\r\nint err;\r\nif (index >= ARRAY_SIZE(rs_table)) {\r\npr_info("no port info for ttyS%d\n", index);\r\nreturn NULL;\r\n}\r\nser = rs_table + index;\r\nquot = ser->baud_base / baud;\r\ncval = cflag & (CSIZE | CSTOPB);\r\n#if defined(__powerpc__) || defined(__alpha__)\r\ncval >>= 8;\r\n#else\r\ncval >>= 4;\r\n#endif\r\nif (cflag & PARENB)\r\ncval |= UART_LCR_PARITY;\r\nif (!(cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\nif (synth_request_region(ser->port, 8)) {\r\npr_info("Ports not available, trying to steal them\n");\r\n__release_region(&ioport_resource, ser->port, 8);\r\nerr = synth_request_region(ser->port, 8);\r\nif (err) {\r\npr_warn("Unable to allocate port at %x, errno %i",\r\nser->port, err);\r\nreturn NULL;\r\n}\r\n}\r\noutb(cval | UART_LCR_DLAB, ser->port + UART_LCR);\r\noutb(quot & 0xff, ser->port + UART_DLL);\r\noutb(quot >> 8, ser->port + UART_DLM);\r\noutb(cval, ser->port + UART_LCR);\r\noutb(0, ser->port + UART_IER);\r\noutb(UART_MCR_DTR | UART_MCR_RTS, ser->port + UART_MCR);\r\nif (inb(ser->port + UART_LSR) == 0xff) {\r\nsynth_release_region(ser->port, 8);\r\nserstate = NULL;\r\nreturn NULL;\r\n}\r\nmdelay(1);\r\nspeakup_info.port_tts = ser->port;\r\nserstate = ser;\r\nstart_serial_interrupt(ser->irq);\r\nreturn ser;\r\n}\r\nstatic irqreturn_t synth_readbuf_handler(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nint c;\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nwhile (inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR) {\r\nc = inb_p(speakup_info.port_tts+UART_RX);\r\nsynth->read_buff_add((u_char) c);\r\n}\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void start_serial_interrupt(int irq)\r\n{\r\nint rv;\r\nif (!synth->read_buff_add)\r\nreturn;\r\nrv = request_irq(irq, synth_readbuf_handler, IRQF_SHARED,\r\n"serial", (void *) synth_readbuf_handler);\r\nif (rv)\r\npr_err("Unable to request Speakup serial I R Q\n");\r\noutb(UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2,\r\nspeakup_info.port_tts + UART_MCR);\r\noutb(UART_IER_MSI|UART_IER_RLSI|UART_IER_RDI,\r\nspeakup_info.port_tts + UART_IER);\r\ninb(speakup_info.port_tts+UART_LSR);\r\ninb(speakup_info.port_tts+UART_RX);\r\ninb(speakup_info.port_tts+UART_IIR);\r\ninb(speakup_info.port_tts+UART_MSR);\r\noutb(1, speakup_info.port_tts + UART_FCR);\r\n}\r\nvoid spk_stop_serial_interrupt(void)\r\n{\r\nif (speakup_info.port_tts == 0)\r\nreturn;\r\nif (!synth->read_buff_add)\r\nreturn;\r\noutb(0, speakup_info.port_tts+UART_IER);\r\nfree_irq(serstate->irq, (void *) synth_readbuf_handler);\r\n}\r\nint spk_wait_for_xmitr(void)\r\n{\r\nint tmout = SPK_XMITR_TIMEOUT;\r\nif ((synth->alive) && (timeouts >= NUM_DISABLE_TIMEOUTS)) {\r\npr_warn("%s: too many timeouts, deactivating speakup\n",\r\nsynth->long_name);\r\nsynth->alive = 0;\r\nspeakup_start_ttys();\r\ntimeouts = 0;\r\nreturn 0;\r\n}\r\nwhile (spk_serial_tx_busy()) {\r\nif (--tmout == 0) {\r\npr_warn("%s: timed out (tx busy)\n", synth->long_name);\r\ntimeouts++;\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\ntmout = SPK_CTS_TIMEOUT;\r\nwhile (!((inb_p(speakup_info.port_tts + UART_MSR)) & UART_MSR_CTS)) {\r\nif (--tmout == 0) {\r\ntimeouts++;\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\ntimeouts = 0;\r\nreturn 1;\r\n}\r\nunsigned char spk_serial_in(void)\r\n{\r\nint tmout = SPK_SERIAL_TIMEOUT;\r\nwhile (!(inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR)) {\r\nif (--tmout == 0) {\r\npr_warn("time out while waiting for input.\n");\r\nreturn 0xff;\r\n}\r\nudelay(1);\r\n}\r\nreturn inb_p(speakup_info.port_tts + UART_RX);\r\n}\r\nunsigned char spk_serial_in_nowait(void)\r\n{\r\nunsigned char lsr;\r\nlsr = inb_p(speakup_info.port_tts + UART_LSR);\r\nif (!(lsr & UART_LSR_DR))\r\nreturn 0;\r\nreturn inb_p(speakup_info.port_tts + UART_RX);\r\n}\r\nint spk_serial_out(const char ch)\r\n{\r\nif (synth->alive && spk_wait_for_xmitr()) {\r\noutb_p(ch, speakup_info.port_tts);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid spk_serial_release(void)\r\n{\r\nif (speakup_info.port_tts == 0)\r\nreturn;\r\nsynth_release_region(speakup_info.port_tts, 8);\r\nspeakup_info.port_tts = 0;\r\n}
