static void *seq_tab_get_idx(struct seq_tab *tb, loff_t pos)\r\n{\r\npos -= tb->skip_first;\r\nreturn pos >= tb->rows ? NULL : &tb->data[pos * tb->width];\r\n}\r\nstatic void *seq_tab_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct seq_tab *tb = seq->private;\r\nif (tb->skip_first && *pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nreturn seq_tab_get_idx(tb, *pos);\r\n}\r\nstatic void *seq_tab_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nv = seq_tab_get_idx(seq->private, *pos + 1);\r\nif (v)\r\n++*pos;\r\nreturn v;\r\n}\r\nstatic void seq_tab_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int seq_tab_show(struct seq_file *seq, void *v)\r\n{\r\nconst struct seq_tab *tb = seq->private;\r\nreturn tb->show(seq, v, ((char *)v - tb->data) / tb->width);\r\n}\r\nstruct seq_tab *seq_open_tab(struct file *f, unsigned int rows,\r\nunsigned int width, unsigned int have_header,\r\nint (*show)(struct seq_file *seq, void *v, int i))\r\n{\r\nstruct seq_tab *p;\r\np = __seq_open_private(f, &seq_tab_ops, sizeof(*p) + rows * width);\r\nif (p) {\r\np->show = show;\r\np->rows = rows;\r\np->width = width;\r\np->skip_first = have_header != 0;\r\n}\r\nreturn p;\r\n}\r\nstatic int seq_tab_trim(struct seq_tab *p, unsigned int new_rows)\r\n{\r\nif (new_rows > p->rows)\r\nreturn -EINVAL;\r\np->rows = new_rows;\r\nreturn 0;\r\n}\r\nstatic int cim_la_show(struct seq_file *seq, void *v, int idx)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, "Status Data PC LS0Stat LS0Addr "\r\n" LS0Data\n");\r\nelse {\r\nconst u32 *p = v;\r\nseq_printf(seq,\r\n" %02x %x%07x %x%07x %08x %08x %08x%08x%08x%08x\n",\r\n(p[0] >> 4) & 0xff, p[0] & 0xf, p[1] >> 4,\r\np[1] & 0xf, p[2] >> 4, p[2] & 0xf, p[3], p[4], p[5],\r\np[6], p[7]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cim_la_show_3in1(struct seq_file *seq, void *v, int idx)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "Status Data PC\n");\r\n} else {\r\nconst u32 *p = v;\r\nseq_printf(seq, " %02x %08x %08x\n", p[5] & 0xff, p[6],\r\np[7]);\r\nseq_printf(seq, " %02x %02x%06x %02x%06x\n",\r\n(p[3] >> 8) & 0xff, p[3] & 0xff, p[4] >> 8,\r\np[4] & 0xff, p[5] >> 8);\r\nseq_printf(seq, " %02x %x%07x %x%07x\n", (p[0] >> 4) & 0xff,\r\np[0] & 0xf, p[1] >> 4, p[1] & 0xf, p[2] >> 4);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cim_la_show_t6(struct seq_file *seq, void *v, int idx)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "Status Inst Data PC LS0Stat "\r\n"LS0Addr LS0Data LS1Stat LS1Addr LS1Data\n");\r\n} else {\r\nconst u32 *p = v;\r\nseq_printf(seq, " %02x %04x%04x %04x%04x %04x%04x %08x %08x %08x %08x %08x %08x\n",\r\n(p[9] >> 16) & 0xff,\r\np[9] & 0xffff, p[8] >> 16,\r\np[8] & 0xffff, p[7] >> 16,\r\np[7] & 0xffff, p[6] >> 16,\r\np[2], p[1], p[0],\r\np[5], p[4], p[3]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cim_la_show_pc_t6(struct seq_file *seq, void *v, int idx)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "Status Inst Data PC\n");\r\n} else {\r\nconst u32 *p = v;\r\nseq_printf(seq, " %02x %08x %08x %08x\n",\r\np[3] & 0xff, p[2], p[1], p[0]);\r\nseq_printf(seq, " %02x %02x%06x %02x%06x %02x%06x\n",\r\n(p[6] >> 8) & 0xff, p[6] & 0xff, p[5] >> 8,\r\np[5] & 0xff, p[4] >> 8, p[4] & 0xff, p[3] >> 8);\r\nseq_printf(seq, " %02x %04x%04x %04x%04x %04x%04x\n",\r\n(p[9] >> 16) & 0xff, p[9] & 0xffff, p[8] >> 16,\r\np[8] & 0xffff, p[7] >> 16, p[7] & 0xffff,\r\np[6] >> 16);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cim_la_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nunsigned int cfg;\r\nstruct seq_tab *p;\r\nstruct adapter *adap = inode->i_private;\r\nret = t4_cim_read(adap, UP_UP_DBG_LA_CFG_A, 1, &cfg);\r\nif (ret)\r\nreturn ret;\r\nif (is_t6(adap->params.chip)) {\r\np = seq_open_tab(file, (adap->params.cim_la_size / 10) + 1,\r\n10 * sizeof(u32), 1,\r\ncfg & UPDBGLACAPTPCONLY_F ?\r\ncim_la_show_pc_t6 : cim_la_show_t6);\r\n} else {\r\np = seq_open_tab(file, adap->params.cim_la_size / 8,\r\n8 * sizeof(u32), 1,\r\ncfg & UPDBGLACAPTPCONLY_F ? cim_la_show_3in1 :\r\ncim_la_show);\r\n}\r\nif (!p)\r\nreturn -ENOMEM;\r\nret = t4_cim_read_la(adap, (u32 *)p->data, NULL);\r\nif (ret)\r\nseq_release_private(inode, file);\r\nreturn ret;\r\n}\r\nstatic int cim_pif_la_show(struct seq_file *seq, void *v, int idx)\r\n{\r\nconst u32 *p = v;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "Cntl ID DataBE Addr Data\n");\r\n} else if (idx < CIM_PIFLA_SIZE) {\r\nseq_printf(seq, " %02x %02x %04x %08x %08x%08x%08x%08x\n",\r\n(p[5] >> 22) & 0xff, (p[5] >> 16) & 0x3f,\r\np[5] & 0xffff, p[4], p[3], p[2], p[1], p[0]);\r\n} else {\r\nif (idx == CIM_PIFLA_SIZE)\r\nseq_puts(seq, "\nCntl ID Data\n");\r\nseq_printf(seq, " %02x %02x %08x%08x%08x%08x\n",\r\n(p[4] >> 6) & 0xff, p[4] & 0x3f,\r\np[3], p[2], p[1], p[0]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cim_pif_la_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_tab *p;\r\nstruct adapter *adap = inode->i_private;\r\np = seq_open_tab(file, 2 * CIM_PIFLA_SIZE, 6 * sizeof(u32), 1,\r\ncim_pif_la_show);\r\nif (!p)\r\nreturn -ENOMEM;\r\nt4_cim_read_pif_la(adap, (u32 *)p->data,\r\n(u32 *)p->data + 6 * CIM_PIFLA_SIZE, NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic int cim_ma_la_show(struct seq_file *seq, void *v, int idx)\r\n{\r\nconst u32 *p = v;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "\n");\r\n} else if (idx < CIM_MALA_SIZE) {\r\nseq_printf(seq, "%02x%08x%08x%08x%08x\n",\r\np[4], p[3], p[2], p[1], p[0]);\r\n} else {\r\nif (idx == CIM_MALA_SIZE)\r\nseq_puts(seq,\r\n"\nCnt ID Tag UE Data RDY VLD\n");\r\nseq_printf(seq, "%3u %2u %x %u %08x%08x %u %u\n",\r\n(p[2] >> 10) & 0xff, (p[2] >> 7) & 7,\r\n(p[2] >> 3) & 0xf, (p[2] >> 2) & 1,\r\n(p[1] >> 2) | ((p[2] & 3) << 30),\r\n(p[0] >> 2) | ((p[1] & 3) << 30), (p[0] >> 1) & 1,\r\np[0] & 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cim_ma_la_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_tab *p;\r\nstruct adapter *adap = inode->i_private;\r\np = seq_open_tab(file, 2 * CIM_MALA_SIZE, 5 * sizeof(u32), 1,\r\ncim_ma_la_show);\r\nif (!p)\r\nreturn -ENOMEM;\r\nt4_cim_read_ma_la(adap, (u32 *)p->data,\r\n(u32 *)p->data + 5 * CIM_MALA_SIZE);\r\nreturn 0;\r\n}\r\nstatic int cim_qcfg_show(struct seq_file *seq, void *v)\r\n{\r\nstatic const char * const qname[] = {\r\n"TP0", "TP1", "ULP", "SGE0", "SGE1", "NC-SI",\r\n"ULP0", "ULP1", "ULP2", "ULP3", "SGE", "NC-SI",\r\n"SGE0-RX", "SGE1-RX"\r\n};\r\nint i;\r\nstruct adapter *adap = seq->private;\r\nu16 base[CIM_NUM_IBQ + CIM_NUM_OBQ_T5];\r\nu16 size[CIM_NUM_IBQ + CIM_NUM_OBQ_T5];\r\nu32 stat[(4 * (CIM_NUM_IBQ + CIM_NUM_OBQ_T5))];\r\nu16 thres[CIM_NUM_IBQ];\r\nu32 obq_wr_t4[2 * CIM_NUM_OBQ], *wr;\r\nu32 obq_wr_t5[2 * CIM_NUM_OBQ_T5];\r\nu32 *p = stat;\r\nint cim_num_obq = is_t4(adap->params.chip) ?\r\nCIM_NUM_OBQ : CIM_NUM_OBQ_T5;\r\ni = t4_cim_read(adap, is_t4(adap->params.chip) ? UP_IBQ_0_RDADDR_A :\r\nUP_IBQ_0_SHADOW_RDADDR_A,\r\nARRAY_SIZE(stat), stat);\r\nif (!i) {\r\nif (is_t4(adap->params.chip)) {\r\ni = t4_cim_read(adap, UP_OBQ_0_REALADDR_A,\r\nARRAY_SIZE(obq_wr_t4), obq_wr_t4);\r\nwr = obq_wr_t4;\r\n} else {\r\ni = t4_cim_read(adap, UP_OBQ_0_SHADOW_REALADDR_A,\r\nARRAY_SIZE(obq_wr_t5), obq_wr_t5);\r\nwr = obq_wr_t5;\r\n}\r\n}\r\nif (i)\r\nreturn i;\r\nt4_read_cimq_cfg(adap, base, size, thres);\r\nseq_printf(seq,\r\n" Queue Base Size Thres RdPtr WrPtr SOP EOP Avail\n");\r\nfor (i = 0; i < CIM_NUM_IBQ; i++, p += 4)\r\nseq_printf(seq, "%7s %5x %5u %5u %6x %4x %4u %4u %5u\n",\r\nqname[i], base[i], size[i], thres[i],\r\nIBQRDADDR_G(p[0]), IBQWRADDR_G(p[1]),\r\nQUESOPCNT_G(p[3]), QUEEOPCNT_G(p[3]),\r\nQUEREMFLITS_G(p[2]) * 16);\r\nfor ( ; i < CIM_NUM_IBQ + cim_num_obq; i++, p += 4, wr += 2)\r\nseq_printf(seq, "%7s %5x %5u %12x %4x %4u %4u %5u\n",\r\nqname[i], base[i], size[i],\r\nQUERDADDR_G(p[0]) & 0x3fff, wr[0] - base[i],\r\nQUESOPCNT_G(p[3]), QUEEOPCNT_G(p[3]),\r\nQUEREMFLITS_G(p[2]) * 16);\r\nreturn 0;\r\n}\r\nstatic int cim_qcfg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, cim_qcfg_show, inode->i_private);\r\n}\r\nstatic int cimq_show(struct seq_file *seq, void *v, int idx)\r\n{\r\nconst u32 *p = v;\r\nseq_printf(seq, "%#06x: %08x %08x %08x %08x\n", idx * 16, p[0], p[1],\r\np[2], p[3]);\r\nreturn 0;\r\n}\r\nstatic int cim_ibq_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nstruct seq_tab *p;\r\nunsigned int qid = (uintptr_t)inode->i_private & 7;\r\nstruct adapter *adap = inode->i_private - qid;\r\np = seq_open_tab(file, CIM_IBQ_SIZE, 4 * sizeof(u32), 0, cimq_show);\r\nif (!p)\r\nreturn -ENOMEM;\r\nret = t4_read_cim_ibq(adap, qid, (u32 *)p->data, CIM_IBQ_SIZE * 4);\r\nif (ret < 0)\r\nseq_release_private(inode, file);\r\nelse\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int cim_obq_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nstruct seq_tab *p;\r\nunsigned int qid = (uintptr_t)inode->i_private & 7;\r\nstruct adapter *adap = inode->i_private - qid;\r\np = seq_open_tab(file, 6 * CIM_OBQ_SIZE, 4 * sizeof(u32), 0, cimq_show);\r\nif (!p)\r\nreturn -ENOMEM;\r\nret = t4_read_cim_obq(adap, qid, (u32 *)p->data, 6 * CIM_OBQ_SIZE * 4);\r\nif (ret < 0) {\r\nseq_release_private(inode, file);\r\n} else {\r\nseq_tab_trim(p, ret / 4);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void field_desc_show(struct seq_file *seq, u64 v,\r\nconst struct field_desc *p)\r\n{\r\nchar buf[32];\r\nint line_size = 0;\r\nwhile (p->name) {\r\nu64 mask = (1ULL << p->width) - 1;\r\nint len = scnprintf(buf, sizeof(buf), "%s: %llu", p->name,\r\n((unsigned long long)v >> p->start) & mask);\r\nif (line_size + len >= 79) {\r\nline_size = 8;\r\nseq_puts(seq, "\n ");\r\n}\r\nseq_printf(seq, "%s ", buf);\r\nline_size += len + 1;\r\np++;\r\n}\r\nseq_putc(seq, '\n');\r\n}\r\nstatic int tp_la_show(struct seq_file *seq, void *v, int idx)\r\n{\r\nconst u64 *p = v;\r\nfield_desc_show(seq, *p, tp_la0);\r\nreturn 0;\r\n}\r\nstatic int tp_la_show2(struct seq_file *seq, void *v, int idx)\r\n{\r\nconst u64 *p = v;\r\nif (idx)\r\nseq_putc(seq, '\n');\r\nfield_desc_show(seq, p[0], tp_la0);\r\nif (idx < (TPLA_SIZE / 2 - 1) || p[1] != ~0ULL)\r\nfield_desc_show(seq, p[1], tp_la0);\r\nreturn 0;\r\n}\r\nstatic int tp_la_show3(struct seq_file *seq, void *v, int idx)\r\n{\r\nstatic struct field_desc tp_la1[] = {\r\n{ "CplCmdIn", 56, 8 },\r\n{ "CplCmdOut", 48, 8 },\r\n{ "ESynOut", 47, 1 },\r\n{ "EAckOut", 46, 1 },\r\n{ "EFinOut", 45, 1 },\r\n{ "ERstOut", 44, 1 },\r\n{ "SynIn", 43, 1 },\r\n{ "AckIn", 42, 1 },\r\n{ "FinIn", 41, 1 },\r\n{ "RstIn", 40, 1 },\r\n{ "DataIn", 39, 1 },\r\n{ "DataInVld", 38, 1 },\r\n{ "PadIn", 37, 1 },\r\n{ "RxBufEmpty", 36, 1 },\r\n{ "RxDdp", 35, 1 },\r\n{ "RxFbCongestion", 34, 1 },\r\n{ "TxFbCongestion", 33, 1 },\r\n{ "TxPktSumSrdy", 32, 1 },\r\n{ "RcfUlpType", 28, 4 },\r\n{ "Eread", 27, 1 },\r\n{ "Ebypass", 26, 1 },\r\n{ "Esave", 25, 1 },\r\n{ "Static0", 24, 1 },\r\n{ "Cread", 23, 1 },\r\n{ "Cbypass", 22, 1 },\r\n{ "Csave", 21, 1 },\r\n{ "CPktOut", 20, 1 },\r\n{ "RxPagePoolFull", 18, 2 },\r\n{ "RxLpbkPkt", 17, 1 },\r\n{ "TxLpbkPkt", 16, 1 },\r\n{ "RxVfValid", 15, 1 },\r\n{ "SynLearned", 14, 1 },\r\n{ "SetDelEntry", 13, 1 },\r\n{ "SetInvEntry", 12, 1 },\r\n{ "CpcmdDvld", 11, 1 },\r\n{ "CpcmdSave", 10, 1 },\r\n{ "RxPstructsFull", 8, 2 },\r\n{ "EpcmdDvld", 7, 1 },\r\n{ "EpcmdFlush", 6, 1 },\r\n{ "EpcmdTrimPrefix", 5, 1 },\r\n{ "EpcmdTrimPostfix", 4, 1 },\r\n{ "ERssIp4Pkt", 3, 1 },\r\n{ "ERssIp6Pkt", 2, 1 },\r\n{ "ERssTcpUdpPkt", 1, 1 },\r\n{ "ERssFceFipPkt", 0, 1 },\r\n{ NULL }\r\n};\r\nstatic struct field_desc tp_la2[] = {\r\n{ "CplCmdIn", 56, 8 },\r\n{ "MpsVfVld", 55, 1 },\r\n{ "MpsPf", 52, 3 },\r\n{ "MpsVf", 44, 8 },\r\n{ "SynIn", 43, 1 },\r\n{ "AckIn", 42, 1 },\r\n{ "FinIn", 41, 1 },\r\n{ "RstIn", 40, 1 },\r\n{ "DataIn", 39, 1 },\r\n{ "DataInVld", 38, 1 },\r\n{ "PadIn", 37, 1 },\r\n{ "RxBufEmpty", 36, 1 },\r\n{ "RxDdp", 35, 1 },\r\n{ "RxFbCongestion", 34, 1 },\r\n{ "TxFbCongestion", 33, 1 },\r\n{ "TxPktSumSrdy", 32, 1 },\r\n{ "RcfUlpType", 28, 4 },\r\n{ "Eread", 27, 1 },\r\n{ "Ebypass", 26, 1 },\r\n{ "Esave", 25, 1 },\r\n{ "Static0", 24, 1 },\r\n{ "Cread", 23, 1 },\r\n{ "Cbypass", 22, 1 },\r\n{ "Csave", 21, 1 },\r\n{ "CPktOut", 20, 1 },\r\n{ "RxPagePoolFull", 18, 2 },\r\n{ "RxLpbkPkt", 17, 1 },\r\n{ "TxLpbkPkt", 16, 1 },\r\n{ "RxVfValid", 15, 1 },\r\n{ "SynLearned", 14, 1 },\r\n{ "SetDelEntry", 13, 1 },\r\n{ "SetInvEntry", 12, 1 },\r\n{ "CpcmdDvld", 11, 1 },\r\n{ "CpcmdSave", 10, 1 },\r\n{ "RxPstructsFull", 8, 2 },\r\n{ "EpcmdDvld", 7, 1 },\r\n{ "EpcmdFlush", 6, 1 },\r\n{ "EpcmdTrimPrefix", 5, 1 },\r\n{ "EpcmdTrimPostfix", 4, 1 },\r\n{ "ERssIp4Pkt", 3, 1 },\r\n{ "ERssIp6Pkt", 2, 1 },\r\n{ "ERssTcpUdpPkt", 1, 1 },\r\n{ "ERssFceFipPkt", 0, 1 },\r\n{ NULL }\r\n};\r\nconst u64 *p = v;\r\nif (idx)\r\nseq_putc(seq, '\n');\r\nfield_desc_show(seq, p[0], tp_la0);\r\nif (idx < (TPLA_SIZE / 2 - 1) || p[1] != ~0ULL)\r\nfield_desc_show(seq, p[1], (p[0] & BIT(17)) ? tp_la2 : tp_la1);\r\nreturn 0;\r\n}\r\nstatic int tp_la_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_tab *p;\r\nstruct adapter *adap = inode->i_private;\r\nswitch (DBGLAMODE_G(t4_read_reg(adap, TP_DBG_LA_CONFIG_A))) {\r\ncase 2:\r\np = seq_open_tab(file, TPLA_SIZE / 2, 2 * sizeof(u64), 0,\r\ntp_la_show2);\r\nbreak;\r\ncase 3:\r\np = seq_open_tab(file, TPLA_SIZE / 2, 2 * sizeof(u64), 0,\r\ntp_la_show3);\r\nbreak;\r\ndefault:\r\np = seq_open_tab(file, TPLA_SIZE, sizeof(u64), 0, tp_la_show);\r\n}\r\nif (!p)\r\nreturn -ENOMEM;\r\nt4_tp_read_la(adap, (u64 *)p->data, NULL);\r\nreturn 0;\r\n}\r\nstatic ssize_t tp_la_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nint err;\r\nchar s[32];\r\nunsigned long val;\r\nsize_t size = min(sizeof(s) - 1, count);\r\nstruct adapter *adap = file_inode(file)->i_private;\r\nif (copy_from_user(s, buf, size))\r\nreturn -EFAULT;\r\ns[size] = '\0';\r\nerr = kstrtoul(s, 0, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 0xffff)\r\nreturn -EINVAL;\r\nadap->params.tp.la_mask = val << 16;\r\nt4_set_reg_field(adap, TP_DBG_LA_CONFIG_A, 0xffff0000U,\r\nadap->params.tp.la_mask);\r\nreturn count;\r\n}\r\nstatic int ulprx_la_show(struct seq_file *seq, void *v, int idx)\r\n{\r\nconst u32 *p = v;\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, " Pcmd Type Message"\r\n" Data\n");\r\nelse\r\nseq_printf(seq, "%08x%08x %4x %08x %08x%08x%08x%08x\n",\r\np[1], p[0], p[2], p[3], p[7], p[6], p[5], p[4]);\r\nreturn 0;\r\n}\r\nstatic int ulprx_la_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_tab *p;\r\nstruct adapter *adap = inode->i_private;\r\np = seq_open_tab(file, ULPRX_LA_SIZE, 8 * sizeof(u32), 1,\r\nulprx_la_show);\r\nif (!p)\r\nreturn -ENOMEM;\r\nt4_ulprx_read_la(adap, (u32 *)p->data);\r\nreturn 0;\r\n}\r\nstatic int pm_stats_show(struct seq_file *seq, void *v)\r\n{\r\nstatic const char * const tx_pm_stats[] = {\r\n"Read:", "Write bypass:", "Write mem:", "Bypass + mem:"\r\n};\r\nstatic const char * const rx_pm_stats[] = {\r\n"Read:", "Write bypass:", "Write mem:", "Flush:"\r\n};\r\nint i;\r\nu32 tx_cnt[T6_PM_NSTATS], rx_cnt[T6_PM_NSTATS];\r\nu64 tx_cyc[T6_PM_NSTATS], rx_cyc[T6_PM_NSTATS];\r\nstruct adapter *adap = seq->private;\r\nt4_pmtx_get_stats(adap, tx_cnt, tx_cyc);\r\nt4_pmrx_get_stats(adap, rx_cnt, rx_cyc);\r\nseq_printf(seq, "%13s %10s %20s\n", " ", "Tx pcmds", "Tx bytes");\r\nfor (i = 0; i < PM_NSTATS - 1; i++)\r\nseq_printf(seq, "%-13s %10u %20llu\n",\r\ntx_pm_stats[i], tx_cnt[i], tx_cyc[i]);\r\nseq_printf(seq, "%13s %10s %20s\n", " ", "Rx pcmds", "Rx bytes");\r\nfor (i = 0; i < PM_NSTATS - 1; i++)\r\nseq_printf(seq, "%-13s %10u %20llu\n",\r\nrx_pm_stats[i], rx_cnt[i], rx_cyc[i]);\r\nif (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) {\r\nseq_printf(seq, "%13s %10s %20s\n",\r\n" ", "Total wait", "Total Occupancy");\r\nseq_printf(seq, "Tx FIFO wait %10u %20llu\n",\r\ntx_cnt[i], tx_cyc[i]);\r\nseq_printf(seq, "Rx FIFO wait %10u %20llu\n",\r\nrx_cnt[i], rx_cyc[i]);\r\ni += 2;\r\nseq_printf(seq, "%13s %10s %20s\n",\r\n" ", "Reads", "Total wait");\r\nseq_printf(seq, "Tx latency %10u %20llu\n",\r\ntx_cnt[i], tx_cyc[i]);\r\nseq_printf(seq, "Rx latency %10u %20llu\n",\r\nrx_cnt[i], rx_cyc[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm_stats_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pm_stats_show, inode->i_private);\r\n}\r\nstatic ssize_t pm_stats_clear(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct adapter *adap = file_inode(file)->i_private;\r\nt4_write_reg(adap, PM_RX_STAT_CONFIG_A, 0);\r\nt4_write_reg(adap, PM_TX_STAT_CONFIG_A, 0);\r\nreturn count;\r\n}\r\nstatic int tx_rate_show(struct seq_file *seq, void *v)\r\n{\r\nu64 nrate[NCHAN], orate[NCHAN];\r\nstruct adapter *adap = seq->private;\r\nt4_get_chan_txrate(adap, nrate, orate);\r\nif (adap->params.arch.nchan == NCHAN) {\r\nseq_puts(seq, " channel 0 channel 1 "\r\n"channel 2 channel 3\n");\r\nseq_printf(seq, "NIC B/s: %10llu %10llu %10llu %10llu\n",\r\n(unsigned long long)nrate[0],\r\n(unsigned long long)nrate[1],\r\n(unsigned long long)nrate[2],\r\n(unsigned long long)nrate[3]);\r\nseq_printf(seq, "Offload B/s: %10llu %10llu %10llu %10llu\n",\r\n(unsigned long long)orate[0],\r\n(unsigned long long)orate[1],\r\n(unsigned long long)orate[2],\r\n(unsigned long long)orate[3]);\r\n} else {\r\nseq_puts(seq, " channel 0 channel 1\n");\r\nseq_printf(seq, "NIC B/s: %10llu %10llu\n",\r\n(unsigned long long)nrate[0],\r\n(unsigned long long)nrate[1]);\r\nseq_printf(seq, "Offload B/s: %10llu %10llu\n",\r\n(unsigned long long)orate[0],\r\n(unsigned long long)orate[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cctrl_tbl_show(struct seq_file *seq, void *v)\r\n{\r\nstatic const char * const dec_fac[] = {\r\n"0.5", "0.5625", "0.625", "0.6875", "0.75", "0.8125", "0.875",\r\n"0.9375" };\r\nint i;\r\nu16 (*incr)[NCCTRL_WIN];\r\nstruct adapter *adap = seq->private;\r\nincr = kmalloc(sizeof(*incr) * NMTUS, GFP_KERNEL);\r\nif (!incr)\r\nreturn -ENOMEM;\r\nt4_read_cong_tbl(adap, incr);\r\nfor (i = 0; i < NCCTRL_WIN; ++i) {\r\nseq_printf(seq, "%2d: %4u %4u %4u %4u %4u %4u %4u %4u\n", i,\r\nincr[0][i], incr[1][i], incr[2][i], incr[3][i],\r\nincr[4][i], incr[5][i], incr[6][i], incr[7][i]);\r\nseq_printf(seq, "%8u %4u %4u %4u %4u %4u %4u %4u %5u %s\n",\r\nincr[8][i], incr[9][i], incr[10][i], incr[11][i],\r\nincr[12][i], incr[13][i], incr[14][i], incr[15][i],\r\nadap->params.a_wnd[i],\r\ndec_fac[adap->params.b_wnd[i]]);\r\n}\r\nkfree(incr);\r\nreturn 0;\r\n}\r\nstatic char *unit_conv(char *buf, size_t len, unsigned int val,\r\nunsigned int factor)\r\n{\r\nunsigned int rem = val % factor;\r\nif (rem == 0) {\r\nsnprintf(buf, len, "%u", val / factor);\r\n} else {\r\nwhile (rem % 10 == 0)\r\nrem /= 10;\r\nsnprintf(buf, len, "%u.%u", val / factor, rem);\r\n}\r\nreturn buf;\r\n}\r\nstatic int clk_show(struct seq_file *seq, void *v)\r\n{\r\nchar buf[32];\r\nstruct adapter *adap = seq->private;\r\nunsigned int cclk_ps = 1000000000 / adap->params.vpd.cclk;\r\nu32 res = t4_read_reg(adap, TP_TIMER_RESOLUTION_A);\r\nunsigned int tre = TIMERRESOLUTION_G(res);\r\nunsigned int dack_re = DELAYEDACKRESOLUTION_G(res);\r\nunsigned long long tp_tick_us = (cclk_ps << tre) / 1000000;\r\nseq_printf(seq, "Core clock period: %s ns\n",\r\nunit_conv(buf, sizeof(buf), cclk_ps, 1000));\r\nseq_printf(seq, "TP timer tick: %s us\n",\r\nunit_conv(buf, sizeof(buf), (cclk_ps << tre), 1000000));\r\nseq_printf(seq, "TCP timestamp tick: %s us\n",\r\nunit_conv(buf, sizeof(buf),\r\n(cclk_ps << TIMESTAMPRESOLUTION_G(res)), 1000000));\r\nseq_printf(seq, "DACK tick: %s us\n",\r\nunit_conv(buf, sizeof(buf), (cclk_ps << dack_re), 1000000));\r\nseq_printf(seq, "DACK timer: %u us\n",\r\n((cclk_ps << dack_re) / 1000000) *\r\nt4_read_reg(adap, TP_DACK_TIMER_A));\r\nseq_printf(seq, "Retransmit min: %llu us\n",\r\ntp_tick_us * t4_read_reg(adap, TP_RXT_MIN_A));\r\nseq_printf(seq, "Retransmit max: %llu us\n",\r\ntp_tick_us * t4_read_reg(adap, TP_RXT_MAX_A));\r\nseq_printf(seq, "Persist timer min: %llu us\n",\r\ntp_tick_us * t4_read_reg(adap, TP_PERS_MIN_A));\r\nseq_printf(seq, "Persist timer max: %llu us\n",\r\ntp_tick_us * t4_read_reg(adap, TP_PERS_MAX_A));\r\nseq_printf(seq, "Keepalive idle timer: %llu us\n",\r\ntp_tick_us * t4_read_reg(adap, TP_KEEP_IDLE_A));\r\nseq_printf(seq, "Keepalive interval: %llu us\n",\r\ntp_tick_us * t4_read_reg(adap, TP_KEEP_INTVL_A));\r\nseq_printf(seq, "Initial SRTT: %llu us\n",\r\ntp_tick_us * INITSRTT_G(t4_read_reg(adap, TP_INIT_SRTT_A)));\r\nseq_printf(seq, "FINWAIT2 timer: %llu us\n",\r\ntp_tick_us * t4_read_reg(adap, TP_FINWAIT2_TIMER_A));\r\nreturn 0;\r\n}\r\nstatic int devlog_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_printf(seq, "%10s %15s %8s %8s %s\n",\r\n"Seq#", "Tstamp", "Level", "Facility", "Message");\r\nelse {\r\nstruct devlog_info *dinfo = seq->private;\r\nint fidx = (uintptr_t)v - 2;\r\nunsigned long index;\r\nstruct fw_devlog_e *e;\r\nindex = dinfo->first + fidx;\r\nif (index >= dinfo->nentries)\r\nindex -= dinfo->nentries;\r\ne = &dinfo->log[index];\r\nif (e->timestamp == 0)\r\nreturn 0;\r\nseq_printf(seq, "%10d %15llu %8s %8s ",\r\nbe32_to_cpu(e->seqno),\r\nbe64_to_cpu(e->timestamp),\r\n(e->level < ARRAY_SIZE(devlog_level_strings)\r\n? devlog_level_strings[e->level]\r\n: "UNKNOWN"),\r\n(e->facility < ARRAY_SIZE(devlog_facility_strings)\r\n? devlog_facility_strings[e->facility]\r\n: "UNKNOWN"));\r\nseq_printf(seq, e->fmt,\r\nbe32_to_cpu(e->params[0]),\r\nbe32_to_cpu(e->params[1]),\r\nbe32_to_cpu(e->params[2]),\r\nbe32_to_cpu(e->params[3]),\r\nbe32_to_cpu(e->params[4]),\r\nbe32_to_cpu(e->params[5]),\r\nbe32_to_cpu(e->params[6]),\r\nbe32_to_cpu(e->params[7]));\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void *devlog_get_idx(struct devlog_info *dinfo, loff_t pos)\r\n{\r\nif (pos > dinfo->nentries)\r\nreturn NULL;\r\nreturn (void *)(uintptr_t)(pos + 1);\r\n}\r\nstatic void *devlog_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct devlog_info *dinfo = seq->private;\r\nreturn (*pos\r\n? devlog_get_idx(dinfo, *pos)\r\n: SEQ_START_TOKEN);\r\n}\r\nstatic void *devlog_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct devlog_info *dinfo = seq->private;\r\n(*pos)++;\r\nreturn devlog_get_idx(dinfo, *pos);\r\n}\r\nstatic void devlog_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int devlog_open(struct inode *inode, struct file *file)\r\n{\r\nstruct adapter *adap = inode->i_private;\r\nstruct devlog_params *dparams = &adap->params.devlog;\r\nstruct devlog_info *dinfo;\r\nunsigned int index;\r\nu32 fseqno;\r\nint ret;\r\nif (dparams->start == 0)\r\nreturn -ENXIO;\r\ndinfo = __seq_open_private(file, &devlog_seq_ops,\r\nsizeof(*dinfo) + dparams->size);\r\nif (!dinfo)\r\nreturn -ENOMEM;\r\ndinfo->nentries = (dparams->size / sizeof(struct fw_devlog_e));\r\ndinfo->first = 0;\r\nspin_lock(&adap->win0_lock);\r\nret = t4_memory_rw(adap, adap->params.drv_memwin, dparams->memtype,\r\ndparams->start, dparams->size, (__be32 *)dinfo->log,\r\nT4_MEMORY_READ);\r\nspin_unlock(&adap->win0_lock);\r\nif (ret) {\r\nseq_release_private(inode, file);\r\nreturn ret;\r\n}\r\nfor (fseqno = ~((u32)0), index = 0; index < dinfo->nentries; index++) {\r\nstruct fw_devlog_e *e = &dinfo->log[index];\r\n__u32 seqno;\r\nif (e->timestamp == 0)\r\ncontinue;\r\nseqno = be32_to_cpu(e->seqno);\r\nif (seqno < fseqno) {\r\nfseqno = seqno;\r\ndinfo->first = index;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mboxlog_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adapter = seq->private;\r\nstruct mbox_cmd_log *log = adapter->mbox_log;\r\nstruct mbox_cmd *entry;\r\nint entry_idx, i;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq,\r\n"%10s %15s %5s %5s %s\n",\r\n"Seq#", "Tstamp", "Atime", "Etime",\r\n"Command/Reply");\r\nreturn 0;\r\n}\r\nentry_idx = log->cursor + ((uintptr_t)v - 2);\r\nif (entry_idx >= log->size)\r\nentry_idx -= log->size;\r\nentry = mbox_cmd_log_entry(log, entry_idx);\r\nif (entry->timestamp == 0)\r\nreturn 0;\r\nseq_printf(seq, "%10u %15llu %5d %5d",\r\nentry->seqno, entry->timestamp,\r\nentry->access, entry->execute);\r\nfor (i = 0; i < MBOX_LEN / 8; i++) {\r\nu64 flit = entry->cmd[i];\r\nu32 hi = (u32)(flit >> 32);\r\nu32 lo = (u32)flit;\r\nseq_printf(seq, " %08x %08x", hi, lo);\r\n}\r\nseq_puts(seq, "\n");\r\nreturn 0;\r\n}\r\nstatic inline void *mboxlog_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct adapter *adapter = seq->private;\r\nstruct mbox_cmd_log *log = adapter->mbox_log;\r\nreturn ((pos <= log->size) ? (void *)(uintptr_t)(pos + 1) : NULL);\r\n}\r\nstatic void *mboxlog_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn *pos ? mboxlog_get_idx(seq, *pos) : SEQ_START_TOKEN;\r\n}\r\nstatic void *mboxlog_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn mboxlog_get_idx(seq, *pos);\r\n}\r\nstatic void mboxlog_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int mboxlog_open(struct inode *inode, struct file *file)\r\n{\r\nint res = seq_open(file, &mboxlog_seq_ops);\r\nif (!res) {\r\nstruct seq_file *seq = file->private_data;\r\nseq->private = inode->i_private;\r\n}\r\nreturn res;\r\n}\r\nstatic int mbox_show(struct seq_file *seq, void *v)\r\n{\r\nstatic const char * const owner[] = { "none", "FW", "driver",\r\n"unknown", "<unread>" };\r\nint i;\r\nunsigned int mbox = (uintptr_t)seq->private & 7;\r\nstruct adapter *adap = seq->private - mbox;\r\nvoid __iomem *addr = adap->regs + PF_REG(mbox, CIM_PF_MAILBOX_DATA_A);\r\nif (is_t4(adap->params.chip)) {\r\ni = 4;\r\n} else {\r\nunsigned int ctrl_reg = CIM_PF_MAILBOX_CTRL_SHADOW_COPY_A;\r\nvoid __iomem *ctrl = adap->regs + PF_REG(mbox, ctrl_reg);\r\ni = MBOWNER_G(readl(ctrl));\r\n}\r\nseq_printf(seq, "mailbox owned by %s\n\n", owner[i]);\r\nfor (i = 0; i < MBOX_LEN; i += 8)\r\nseq_printf(seq, "%016llx\n",\r\n(unsigned long long)readq(addr + i));\r\nreturn 0;\r\n}\r\nstatic int mbox_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mbox_show, inode->i_private);\r\n}\r\nstatic ssize_t mbox_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nint i;\r\nchar c = '\n', s[256];\r\nunsigned long long data[8];\r\nconst struct inode *ino;\r\nunsigned int mbox;\r\nstruct adapter *adap;\r\nvoid __iomem *addr;\r\nvoid __iomem *ctrl;\r\nif (count > sizeof(s) - 1 || !count)\r\nreturn -EINVAL;\r\nif (copy_from_user(s, buf, count))\r\nreturn -EFAULT;\r\ns[count] = '\0';\r\nif (sscanf(s, "%llx %llx %llx %llx %llx %llx %llx %llx%c", &data[0],\r\n&data[1], &data[2], &data[3], &data[4], &data[5], &data[6],\r\n&data[7], &c) < 8 || c != '\n')\r\nreturn -EINVAL;\r\nino = file_inode(file);\r\nmbox = (uintptr_t)ino->i_private & 7;\r\nadap = ino->i_private - mbox;\r\naddr = adap->regs + PF_REG(mbox, CIM_PF_MAILBOX_DATA_A);\r\nctrl = addr + MBOX_LEN;\r\nif (MBOWNER_G(readl(ctrl)) != X_MBOWNER_PL)\r\nreturn -EBUSY;\r\nfor (i = 0; i < 8; i++)\r\nwriteq(data[i], addr + 8 * i);\r\nwritel(MBMSGVALID_F | MBOWNER_V(X_MBOWNER_FW), ctrl);\r\nreturn count;\r\n}\r\nstatic int mps_trc_show(struct seq_file *seq, void *v)\r\n{\r\nint enabled, i;\r\nstruct trace_params tp;\r\nunsigned int trcidx = (uintptr_t)seq->private & 3;\r\nstruct adapter *adap = seq->private - trcidx;\r\nt4_get_trace_filter(adap, &tp, trcidx, &enabled);\r\nif (!enabled) {\r\nseq_puts(seq, "tracer is disabled\n");\r\nreturn 0;\r\n}\r\nif (tp.skip_ofst * 8 >= TRACE_LEN) {\r\ndev_err(adap->pdev_dev, "illegal trace pattern skip offset\n");\r\nreturn -EINVAL;\r\n}\r\nif (tp.port < 8) {\r\ni = adap->chan_map[tp.port & 3];\r\nif (i >= MAX_NPORTS) {\r\ndev_err(adap->pdev_dev, "tracer %u is assigned "\r\n"to non-existing port\n", trcidx);\r\nreturn -EINVAL;\r\n}\r\nseq_printf(seq, "tracer is capturing %s %s, ",\r\nadap->port[i]->name, tp.port < 4 ? "Rx" : "Tx");\r\n} else\r\nseq_printf(seq, "tracer is capturing loopback %d, ",\r\ntp.port - 8);\r\nseq_printf(seq, "snap length: %u, min length: %u\n", tp.snap_len,\r\ntp.min_len);\r\nseq_printf(seq, "packets captured %smatch filter\n",\r\ntp.invert ? "do not " : "");\r\nif (tp.skip_ofst) {\r\nseq_puts(seq, "filter pattern: ");\r\nfor (i = 0; i < tp.skip_ofst * 2; i += 2)\r\nseq_printf(seq, "%08x%08x", tp.data[i], tp.data[i + 1]);\r\nseq_putc(seq, '/');\r\nfor (i = 0; i < tp.skip_ofst * 2; i += 2)\r\nseq_printf(seq, "%08x%08x", tp.mask[i], tp.mask[i + 1]);\r\nseq_puts(seq, "@0\n");\r\n}\r\nseq_puts(seq, "filter pattern: ");\r\nfor (i = tp.skip_ofst * 2; i < TRACE_LEN / 4; i += 2)\r\nseq_printf(seq, "%08x%08x", tp.data[i], tp.data[i + 1]);\r\nseq_putc(seq, '/');\r\nfor (i = tp.skip_ofst * 2; i < TRACE_LEN / 4; i += 2)\r\nseq_printf(seq, "%08x%08x", tp.mask[i], tp.mask[i + 1]);\r\nseq_printf(seq, "@%u\n", (tp.skip_ofst + tp.skip_len) * 8);\r\nreturn 0;\r\n}\r\nstatic int mps_trc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mps_trc_show, inode->i_private);\r\n}\r\nstatic unsigned int xdigit2int(unsigned char c)\r\n{\r\nreturn isdigit(c) ? c - '0' : tolower(c) - 'a' + 10;\r\n}\r\nstatic ssize_t mps_trc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nint i, enable, ret;\r\nu32 *data, *mask;\r\nstruct trace_params tp;\r\nconst struct inode *ino;\r\nunsigned int trcidx;\r\nchar *s, *p, *word, *end;\r\nstruct adapter *adap;\r\nu32 j;\r\nino = file_inode(file);\r\ntrcidx = (uintptr_t)ino->i_private & 3;\r\nadap = ino->i_private - trcidx;\r\nif (count > 1024)\r\nreturn -EFBIG;\r\np = s = kzalloc(count + 1, GFP_USER);\r\nif (!s)\r\nreturn -ENOMEM;\r\nif (copy_from_user(s, buf, count)) {\r\ncount = -EFAULT;\r\ngoto out;\r\n}\r\nif (s[count - 1] == '\n')\r\ns[count - 1] = '\0';\r\nenable = strcmp("disable", s) != 0;\r\nif (!enable)\r\ngoto apply;\r\nif (adap->trace_rss)\r\nt4_write_reg(adap, MPS_TRC_CFG_A, TRC_RSS_ENABLE);\r\nelse\r\nt4_write_reg(adap, MPS_TRC_CFG_A, TRC_RSS_DISABLE);\r\nmemset(&tp, 0, sizeof(tp));\r\ntp.port = TRC_PORT_NONE;\r\ni = 0;\r\nwhile (p) {\r\nwhile (isspace(*p))\r\np++;\r\nword = strsep(&p, " ");\r\nif (!*word)\r\nbreak;\r\nif (!strncmp(word, "qid=", 4)) {\r\nend = (char *)word + 4;\r\nret = kstrtouint(end, 10, &j);\r\nif (ret)\r\ngoto out;\r\nif (!adap->trace_rss) {\r\nt4_write_reg(adap, MPS_T5_TRC_RSS_CONTROL_A, j);\r\ncontinue;\r\n}\r\nswitch (trcidx) {\r\ncase 0:\r\nt4_write_reg(adap, MPS_TRC_RSS_CONTROL_A, j);\r\nbreak;\r\ncase 1:\r\nt4_write_reg(adap,\r\nMPS_TRC_FILTER1_RSS_CONTROL_A, j);\r\nbreak;\r\ncase 2:\r\nt4_write_reg(adap,\r\nMPS_TRC_FILTER2_RSS_CONTROL_A, j);\r\nbreak;\r\ncase 3:\r\nt4_write_reg(adap,\r\nMPS_TRC_FILTER3_RSS_CONTROL_A, j);\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nif (!strncmp(word, "snaplen=", 8)) {\r\nend = (char *)word + 8;\r\nret = kstrtouint(end, 10, &j);\r\nif (ret || j > 9600) {\r\ninval: count = -EINVAL;\r\ngoto out;\r\n}\r\ntp.snap_len = j;\r\ncontinue;\r\n}\r\nif (!strncmp(word, "minlen=", 7)) {\r\nend = (char *)word + 7;\r\nret = kstrtouint(end, 10, &j);\r\nif (ret || j > TFMINPKTSIZE_M)\r\ngoto inval;\r\ntp.min_len = j;\r\ncontinue;\r\n}\r\nif (!strcmp(word, "not")) {\r\ntp.invert = !tp.invert;\r\ncontinue;\r\n}\r\nif (!strncmp(word, "loopback", 8) && tp.port == TRC_PORT_NONE) {\r\nif (word[8] < '0' || word[8] > '3' || word[9])\r\ngoto inval;\r\ntp.port = word[8] - '0' + 8;\r\ncontinue;\r\n}\r\nif (!strncmp(word, "tx", 2) && tp.port == TRC_PORT_NONE) {\r\nif (word[2] < '0' || word[2] > '3' || word[3])\r\ngoto inval;\r\ntp.port = word[2] - '0' + 4;\r\nif (adap->chan_map[tp.port & 3] >= MAX_NPORTS)\r\ngoto inval;\r\ncontinue;\r\n}\r\nif (!strncmp(word, "rx", 2) && tp.port == TRC_PORT_NONE) {\r\nif (word[2] < '0' || word[2] > '3' || word[3])\r\ngoto inval;\r\ntp.port = word[2] - '0';\r\nif (adap->chan_map[tp.port] >= MAX_NPORTS)\r\ngoto inval;\r\ncontinue;\r\n}\r\nif (!isxdigit(*word))\r\ngoto inval;\r\nif (i) {\r\nif (tp.skip_len)\r\ngoto inval;\r\ntp.skip_ofst = i / 16;\r\n}\r\ndata = &tp.data[i / 8];\r\nmask = &tp.mask[i / 8];\r\nj = i;\r\nwhile (isxdigit(*word)) {\r\nif (i >= TRACE_LEN * 2) {\r\ncount = -EFBIG;\r\ngoto out;\r\n}\r\n*data = (*data << 4) + xdigit2int(*word++);\r\nif (++i % 8 == 0)\r\ndata++;\r\n}\r\nif (*word == '/') {\r\nword++;\r\nwhile (isxdigit(*word)) {\r\nif (j >= i)\r\ngoto inval;\r\n*mask = (*mask << 4) + xdigit2int(*word++);\r\nif (++j % 8 == 0)\r\nmask++;\r\n}\r\nif (i != j)\r\ngoto inval;\r\n} else {\r\nfor ( ; i - j >= 8; j += 8)\r\n*mask++ = 0xffffffff;\r\nif (i % 8)\r\n*mask = (1 << (i % 8) * 4) - 1;\r\n}\r\nif (*word == '@') {\r\nend = (char *)word + 1;\r\nret = kstrtouint(end, 10, &j);\r\nif (*end && *end != '\n')\r\ngoto inval;\r\nif (j & 7)\r\ngoto inval;\r\nj /= 8;\r\nif (j < tp.skip_ofst)\r\ngoto inval;\r\nif (j - tp.skip_ofst > 31)\r\ngoto inval;\r\ntp.skip_len = j - tp.skip_ofst;\r\n}\r\nif (i % 8) {\r\n*data <<= (8 - i % 8) * 4;\r\n*mask <<= (8 - i % 8) * 4;\r\ni = (i + 15) & ~15;\r\n}\r\n}\r\nif (tp.port == TRC_PORT_NONE)\r\ngoto inval;\r\napply:\r\ni = t4_set_trace_filter(adap, &tp, trcidx, enable);\r\nif (i)\r\ncount = i;\r\nout:\r\nkfree(s);\r\nreturn count;\r\n}\r\nstatic ssize_t flash_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nloff_t pos = *ppos;\r\nloff_t avail = file_inode(file)->i_size;\r\nstruct adapter *adap = file->private_data;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nif (pos >= avail)\r\nreturn 0;\r\nif (count > avail - pos)\r\ncount = avail - pos;\r\nwhile (count) {\r\nsize_t len;\r\nint ret, ofst;\r\nu8 data[256];\r\nofst = pos & 3;\r\nlen = min(count + ofst, sizeof(data));\r\nret = t4_read_flash(adap, pos - ofst, (len + 3) / 4,\r\n(u32 *)data, 1);\r\nif (ret)\r\nreturn ret;\r\nlen -= ofst;\r\nif (copy_to_user(buf, data + ofst, len))\r\nreturn -EFAULT;\r\nbuf += len;\r\npos += len;\r\ncount -= len;\r\n}\r\ncount = pos - *ppos;\r\n*ppos = pos;\r\nreturn count;\r\n}\r\nstatic inline void tcamxy2valmask(u64 x, u64 y, u8 *addr, u64 *mask)\r\n{\r\n*mask = x | y;\r\ny = (__force u64)cpu_to_be64(y);\r\nmemcpy(addr, (char *)&y + 2, ETH_ALEN);\r\n}\r\nstatic int mps_tcam_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adap = seq->private;\r\nunsigned int chip_ver = CHELSIO_CHIP_VERSION(adap->params.chip);\r\nif (v == SEQ_START_TOKEN) {\r\nif (chip_ver > CHELSIO_T5) {\r\nseq_puts(seq, "Idx Ethernet address Mask "\r\n" VNI Mask IVLAN Vld "\r\n"DIP_Hit Lookup Port "\r\n"Vld Ports PF VF "\r\n"Replication "\r\n" P0 P1 P2 P3 ML\n");\r\n} else {\r\nif (adap->params.arch.mps_rplc_size > 128)\r\nseq_puts(seq, "Idx Ethernet address Mask "\r\n"Vld Ports PF VF "\r\n"Replication "\r\n" P0 P1 P2 P3 ML\n");\r\nelse\r\nseq_puts(seq, "Idx Ethernet address Mask "\r\n"Vld Ports PF VF Replication"\r\n" P0 P1 P2 P3 ML\n");\r\n}\r\n} else {\r\nu64 mask;\r\nu8 addr[ETH_ALEN];\r\nbool replicate, dip_hit = false, vlan_vld = false;\r\nunsigned int idx = (uintptr_t)v - 2;\r\nu64 tcamy, tcamx, val;\r\nu32 cls_lo, cls_hi, ctl, data2, vnix = 0, vniy = 0;\r\nu32 rplc[8] = {0};\r\nu8 lookup_type = 0, port_num = 0;\r\nu16 ivlan = 0;\r\nif (chip_ver > CHELSIO_T5) {\r\nctl = CTLCMDTYPE_V(0) | CTLXYBITSEL_V(0);\r\nif (idx < 256)\r\nctl |= CTLTCAMINDEX_V(idx) | CTLTCAMSEL_V(0);\r\nelse\r\nctl |= CTLTCAMINDEX_V(idx - 256) |\r\nCTLTCAMSEL_V(1);\r\nt4_write_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A, ctl);\r\nval = t4_read_reg(adap, MPS_CLS_TCAM_DATA1_A);\r\ntcamy = DMACH_G(val) << 32;\r\ntcamy |= t4_read_reg(adap, MPS_CLS_TCAM_DATA0_A);\r\ndata2 = t4_read_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A);\r\nlookup_type = DATALKPTYPE_G(data2);\r\nif (lookup_type && (lookup_type != DATALKPTYPE_M)) {\r\nvniy = ((data2 & DATAVIDH2_F) << 23) |\r\n(DATAVIDH1_G(data2) << 16) | VIDL_G(val);\r\ndip_hit = data2 & DATADIPHIT_F;\r\n} else {\r\nvlan_vld = data2 & DATAVIDH2_F;\r\nivlan = VIDL_G(val);\r\n}\r\nport_num = DATAPORTNUM_G(data2);\r\nctl |= CTLXYBITSEL_V(1);\r\nt4_write_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A, ctl);\r\nval = t4_read_reg(adap, MPS_CLS_TCAM_DATA1_A);\r\ntcamx = DMACH_G(val) << 32;\r\ntcamx |= t4_read_reg(adap, MPS_CLS_TCAM_DATA0_A);\r\ndata2 = t4_read_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A);\r\nif (lookup_type && (lookup_type != DATALKPTYPE_M)) {\r\nvnix = ((data2 & DATAVIDH2_F) << 23) |\r\n(DATAVIDH1_G(data2) << 16) | VIDL_G(val);\r\n}\r\n} else {\r\ntcamy = t4_read_reg64(adap, MPS_CLS_TCAM_Y_L(idx));\r\ntcamx = t4_read_reg64(adap, MPS_CLS_TCAM_X_L(idx));\r\n}\r\ncls_lo = t4_read_reg(adap, MPS_CLS_SRAM_L(idx));\r\ncls_hi = t4_read_reg(adap, MPS_CLS_SRAM_H(idx));\r\nif (tcamx & tcamy) {\r\nseq_printf(seq, "%3u -\n", idx);\r\ngoto out;\r\n}\r\nrplc[0] = rplc[1] = rplc[2] = rplc[3] = 0;\r\nif (chip_ver > CHELSIO_T5)\r\nreplicate = (cls_lo & T6_REPLICATE_F);\r\nelse\r\nreplicate = (cls_lo & REPLICATE_F);\r\nif (replicate) {\r\nstruct fw_ldst_cmd ldst_cmd;\r\nint ret;\r\nstruct fw_ldst_mps_rplc mps_rplc;\r\nu32 ldst_addrspc;\r\nmemset(&ldst_cmd, 0, sizeof(ldst_cmd));\r\nldst_addrspc =\r\nFW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_MPS);\r\nldst_cmd.op_to_addrspace =\r\nhtonl(FW_CMD_OP_V(FW_LDST_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_READ_F |\r\nldst_addrspc);\r\nldst_cmd.cycles_to_len16 = htonl(FW_LEN16(ldst_cmd));\r\nldst_cmd.u.mps.rplc.fid_idx =\r\nhtons(FW_LDST_CMD_FID_V(FW_LDST_MPS_RPLC) |\r\nFW_LDST_CMD_IDX_V(idx));\r\nret = t4_wr_mbox(adap, adap->mbox, &ldst_cmd,\r\nsizeof(ldst_cmd), &ldst_cmd);\r\nif (ret)\r\ndev_warn(adap->pdev_dev, "Can't read MPS "\r\n"replication map for idx %d: %d\n",\r\nidx, -ret);\r\nelse {\r\nmps_rplc = ldst_cmd.u.mps.rplc;\r\nrplc[0] = ntohl(mps_rplc.rplc31_0);\r\nrplc[1] = ntohl(mps_rplc.rplc63_32);\r\nrplc[2] = ntohl(mps_rplc.rplc95_64);\r\nrplc[3] = ntohl(mps_rplc.rplc127_96);\r\nif (adap->params.arch.mps_rplc_size > 128) {\r\nrplc[4] = ntohl(mps_rplc.rplc159_128);\r\nrplc[5] = ntohl(mps_rplc.rplc191_160);\r\nrplc[6] = ntohl(mps_rplc.rplc223_192);\r\nrplc[7] = ntohl(mps_rplc.rplc255_224);\r\n}\r\n}\r\n}\r\ntcamxy2valmask(tcamx, tcamy, addr, &mask);\r\nif (chip_ver > CHELSIO_T5) {\r\nif (lookup_type && (lookup_type != DATALKPTYPE_M)) {\r\nseq_printf(seq,\r\n"%3u %02x:%02x:%02x:%02x:%02x:%02x "\r\n"%012llx %06x %06x - - %3c"\r\n" 'I' %4x "\r\n"%3c %#x%4u%4d", idx, addr[0],\r\naddr[1], addr[2], addr[3],\r\naddr[4], addr[5],\r\n(unsigned long long)mask,\r\nvniy, vnix, dip_hit ? 'Y' : 'N',\r\nport_num,\r\n(cls_lo & T6_SRAM_VLD_F) ? 'Y' : 'N',\r\nPORTMAP_G(cls_hi),\r\nT6_PF_G(cls_lo),\r\n(cls_lo & T6_VF_VALID_F) ?\r\nT6_VF_G(cls_lo) : -1);\r\n} else {\r\nseq_printf(seq,\r\n"%3u %02x:%02x:%02x:%02x:%02x:%02x "\r\n"%012llx - - ",\r\nidx, addr[0], addr[1], addr[2],\r\naddr[3], addr[4], addr[5],\r\n(unsigned long long)mask);\r\nif (vlan_vld)\r\nseq_printf(seq, "%4u Y ", ivlan);\r\nelse\r\nseq_puts(seq, " - N ");\r\nseq_printf(seq,\r\n"- %3c %4x %3c %#x%4u%4d",\r\nlookup_type ? 'I' : 'O', port_num,\r\n(cls_lo & T6_SRAM_VLD_F) ? 'Y' : 'N',\r\nPORTMAP_G(cls_hi),\r\nT6_PF_G(cls_lo),\r\n(cls_lo & T6_VF_VALID_F) ?\r\nT6_VF_G(cls_lo) : -1);\r\n}\r\n} else\r\nseq_printf(seq, "%3u %02x:%02x:%02x:%02x:%02x:%02x "\r\n"%012llx%3c %#x%4u%4d",\r\nidx, addr[0], addr[1], addr[2], addr[3],\r\naddr[4], addr[5], (unsigned long long)mask,\r\n(cls_lo & SRAM_VLD_F) ? 'Y' : 'N',\r\nPORTMAP_G(cls_hi),\r\nPF_G(cls_lo),\r\n(cls_lo & VF_VALID_F) ? VF_G(cls_lo) : -1);\r\nif (replicate) {\r\nif (adap->params.arch.mps_rplc_size > 128)\r\nseq_printf(seq, " %08x %08x %08x %08x "\r\n"%08x %08x %08x %08x",\r\nrplc[7], rplc[6], rplc[5], rplc[4],\r\nrplc[3], rplc[2], rplc[1], rplc[0]);\r\nelse\r\nseq_printf(seq, " %08x %08x %08x %08x",\r\nrplc[3], rplc[2], rplc[1], rplc[0]);\r\n} else {\r\nif (adap->params.arch.mps_rplc_size > 128)\r\nseq_printf(seq, "%72c", ' ');\r\nelse\r\nseq_printf(seq, "%36c", ' ');\r\n}\r\nif (chip_ver > CHELSIO_T5)\r\nseq_printf(seq, "%4u%3u%3u%3u %#x\n",\r\nT6_SRAM_PRIO0_G(cls_lo),\r\nT6_SRAM_PRIO1_G(cls_lo),\r\nT6_SRAM_PRIO2_G(cls_lo),\r\nT6_SRAM_PRIO3_G(cls_lo),\r\n(cls_lo >> T6_MULTILISTEN0_S) & 0xf);\r\nelse\r\nseq_printf(seq, "%4u%3u%3u%3u %#x\n",\r\nSRAM_PRIO0_G(cls_lo), SRAM_PRIO1_G(cls_lo),\r\nSRAM_PRIO2_G(cls_lo), SRAM_PRIO3_G(cls_lo),\r\n(cls_lo >> MULTILISTEN0_S) & 0xf);\r\n}\r\nout: return 0;\r\n}\r\nstatic inline void *mps_tcam_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct adapter *adap = seq->private;\r\nint max_mac_addr = is_t4(adap->params.chip) ?\r\nNUM_MPS_CLS_SRAM_L_INSTANCES :\r\nNUM_MPS_T5_CLS_SRAM_L_INSTANCES;\r\nreturn ((pos <= max_mac_addr) ? (void *)(uintptr_t)(pos + 1) : NULL);\r\n}\r\nstatic void *mps_tcam_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn *pos ? mps_tcam_get_idx(seq, *pos) : SEQ_START_TOKEN;\r\n}\r\nstatic void *mps_tcam_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn mps_tcam_get_idx(seq, *pos);\r\n}\r\nstatic void mps_tcam_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int mps_tcam_open(struct inode *inode, struct file *file)\r\n{\r\nint res = seq_open(file, &mps_tcam_seq_ops);\r\nif (!res) {\r\nstruct seq_file *seq = file->private_data;\r\nseq->private = inode->i_private;\r\n}\r\nreturn res;\r\n}\r\nstatic int sensors_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adap = seq->private;\r\nu32 param[7], val[7];\r\nint ret;\r\nparam[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\r\nFW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_DIAG) |\r\nFW_PARAMS_PARAM_Y_V(FW_PARAM_DEV_DIAG_TMP));\r\nparam[1] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\r\nFW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_DIAG) |\r\nFW_PARAMS_PARAM_Y_V(FW_PARAM_DEV_DIAG_VDD));\r\nret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\r\nparam, val);\r\nif (ret < 0 || val[0] == 0)\r\nseq_puts(seq, "Temperature: <unknown>\n");\r\nelse\r\nseq_printf(seq, "Temperature: %dC\n", val[0]);\r\nif (ret < 0 || val[1] == 0)\r\nseq_puts(seq, "Core VDD: <unknown>\n");\r\nelse\r\nseq_printf(seq, "Core VDD: %dmV\n", val[1]);\r\nreturn 0;\r\n}\r\nstatic int clip_tbl_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, clip_tbl_show, inode->i_private);\r\n}\r\nstatic int rss_show(struct seq_file *seq, void *v, int idx)\r\n{\r\nu16 *entry = v;\r\nseq_printf(seq, "%4d: %4u %4u %4u %4u %4u %4u %4u %4u\n",\r\nidx * 8, entry[0], entry[1], entry[2], entry[3], entry[4],\r\nentry[5], entry[6], entry[7]);\r\nreturn 0;\r\n}\r\nstatic int rss_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nstruct seq_tab *p;\r\nstruct adapter *adap = inode->i_private;\r\np = seq_open_tab(file, RSS_NENTRIES / 8, 8 * sizeof(u16), 0, rss_show);\r\nif (!p)\r\nreturn -ENOMEM;\r\nret = t4_read_rss(adap, (u16 *)p->data);\r\nif (ret)\r\nseq_release_private(inode, file);\r\nreturn ret;\r\n}\r\nstatic const char *yesno(int x)\r\n{\r\nstatic const char *yes = "yes";\r\nstatic const char *no = "no";\r\nreturn x ? yes : no;\r\n}\r\nstatic int rss_config_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adapter = seq->private;\r\nstatic const char * const keymode[] = {\r\n"global",\r\n"global and per-VF scramble",\r\n"per-PF and per-VF scramble",\r\n"per-VF and per-VF scramble",\r\n};\r\nu32 rssconf;\r\nrssconf = t4_read_reg(adapter, TP_RSS_CONFIG_A);\r\nseq_printf(seq, "TP_RSS_CONFIG: %#x\n", rssconf);\r\nseq_printf(seq, " Tnl4TupEnIpv6: %3s\n", yesno(rssconf &\r\nTNL4TUPENIPV6_F));\r\nseq_printf(seq, " Tnl2TupEnIpv6: %3s\n", yesno(rssconf &\r\nTNL2TUPENIPV6_F));\r\nseq_printf(seq, " Tnl4TupEnIpv4: %3s\n", yesno(rssconf &\r\nTNL4TUPENIPV4_F));\r\nseq_printf(seq, " Tnl2TupEnIpv4: %3s\n", yesno(rssconf &\r\nTNL2TUPENIPV4_F));\r\nseq_printf(seq, " TnlTcpSel: %3s\n", yesno(rssconf & TNLTCPSEL_F));\r\nseq_printf(seq, " TnlIp6Sel: %3s\n", yesno(rssconf & TNLIP6SEL_F));\r\nseq_printf(seq, " TnlVrtSel: %3s\n", yesno(rssconf & TNLVRTSEL_F));\r\nseq_printf(seq, " TnlMapEn: %3s\n", yesno(rssconf & TNLMAPEN_F));\r\nseq_printf(seq, " OfdHashSave: %3s\n", yesno(rssconf &\r\nOFDHASHSAVE_F));\r\nseq_printf(seq, " OfdVrtSel: %3s\n", yesno(rssconf & OFDVRTSEL_F));\r\nseq_printf(seq, " OfdMapEn: %3s\n", yesno(rssconf & OFDMAPEN_F));\r\nseq_printf(seq, " OfdLkpEn: %3s\n", yesno(rssconf & OFDLKPEN_F));\r\nseq_printf(seq, " Syn4TupEnIpv6: %3s\n", yesno(rssconf &\r\nSYN4TUPENIPV6_F));\r\nseq_printf(seq, " Syn2TupEnIpv6: %3s\n", yesno(rssconf &\r\nSYN2TUPENIPV6_F));\r\nseq_printf(seq, " Syn4TupEnIpv4: %3s\n", yesno(rssconf &\r\nSYN4TUPENIPV4_F));\r\nseq_printf(seq, " Syn2TupEnIpv4: %3s\n", yesno(rssconf &\r\nSYN2TUPENIPV4_F));\r\nseq_printf(seq, " Syn4TupEnIpv6: %3s\n", yesno(rssconf &\r\nSYN4TUPENIPV6_F));\r\nseq_printf(seq, " SynIp6Sel: %3s\n", yesno(rssconf & SYNIP6SEL_F));\r\nseq_printf(seq, " SynVrt6Sel: %3s\n", yesno(rssconf & SYNVRTSEL_F));\r\nseq_printf(seq, " SynMapEn: %3s\n", yesno(rssconf & SYNMAPEN_F));\r\nseq_printf(seq, " SynLkpEn: %3s\n", yesno(rssconf & SYNLKPEN_F));\r\nseq_printf(seq, " ChnEn: %3s\n", yesno(rssconf &\r\nCHANNELENABLE_F));\r\nseq_printf(seq, " PrtEn: %3s\n", yesno(rssconf &\r\nPORTENABLE_F));\r\nseq_printf(seq, " TnlAllLkp: %3s\n", yesno(rssconf &\r\nTNLALLLOOKUP_F));\r\nseq_printf(seq, " VrtEn: %3s\n", yesno(rssconf &\r\nVIRTENABLE_F));\r\nseq_printf(seq, " CngEn: %3s\n", yesno(rssconf &\r\nCONGESTIONENABLE_F));\r\nseq_printf(seq, " HashToeplitz: %3s\n", yesno(rssconf &\r\nHASHTOEPLITZ_F));\r\nseq_printf(seq, " Udp4En: %3s\n", yesno(rssconf & UDPENABLE_F));\r\nseq_printf(seq, " Disable: %3s\n", yesno(rssconf & DISABLE_F));\r\nseq_puts(seq, "\n");\r\nrssconf = t4_read_reg(adapter, TP_RSS_CONFIG_TNL_A);\r\nseq_printf(seq, "TP_RSS_CONFIG_TNL: %#x\n", rssconf);\r\nseq_printf(seq, " MaskSize: %3d\n", MASKSIZE_G(rssconf));\r\nseq_printf(seq, " MaskFilter: %3d\n", MASKFILTER_G(rssconf));\r\nif (CHELSIO_CHIP_VERSION(adapter->params.chip) > CHELSIO_T5) {\r\nseq_printf(seq, " HashAll: %3s\n",\r\nyesno(rssconf & HASHALL_F));\r\nseq_printf(seq, " HashEth: %3s\n",\r\nyesno(rssconf & HASHETH_F));\r\n}\r\nseq_printf(seq, " UseWireCh: %3s\n", yesno(rssconf & USEWIRECH_F));\r\nseq_puts(seq, "\n");\r\nrssconf = t4_read_reg(adapter, TP_RSS_CONFIG_OFD_A);\r\nseq_printf(seq, "TP_RSS_CONFIG_OFD: %#x\n", rssconf);\r\nseq_printf(seq, " MaskSize: %3d\n", MASKSIZE_G(rssconf));\r\nseq_printf(seq, " RRCplMapEn: %3s\n", yesno(rssconf &\r\nRRCPLMAPEN_F));\r\nseq_printf(seq, " RRCplQueWidth: %3d\n", RRCPLQUEWIDTH_G(rssconf));\r\nseq_puts(seq, "\n");\r\nrssconf = t4_read_reg(adapter, TP_RSS_CONFIG_SYN_A);\r\nseq_printf(seq, "TP_RSS_CONFIG_SYN: %#x\n", rssconf);\r\nseq_printf(seq, " MaskSize: %3d\n", MASKSIZE_G(rssconf));\r\nseq_printf(seq, " UseWireCh: %3s\n", yesno(rssconf & USEWIRECH_F));\r\nseq_puts(seq, "\n");\r\nrssconf = t4_read_reg(adapter, TP_RSS_CONFIG_VRT_A);\r\nseq_printf(seq, "TP_RSS_CONFIG_VRT: %#x\n", rssconf);\r\nif (CHELSIO_CHIP_VERSION(adapter->params.chip) > CHELSIO_T5) {\r\nseq_printf(seq, " KeyWrAddrX: %3d\n",\r\nKEYWRADDRX_G(rssconf));\r\nseq_printf(seq, " KeyExtend: %3s\n",\r\nyesno(rssconf & KEYEXTEND_F));\r\n}\r\nseq_printf(seq, " VfRdRg: %3s\n", yesno(rssconf & VFRDRG_F));\r\nseq_printf(seq, " VfRdEn: %3s\n", yesno(rssconf & VFRDEN_F));\r\nseq_printf(seq, " VfPerrEn: %3s\n", yesno(rssconf & VFPERREN_F));\r\nseq_printf(seq, " KeyPerrEn: %3s\n", yesno(rssconf & KEYPERREN_F));\r\nseq_printf(seq, " DisVfVlan: %3s\n", yesno(rssconf &\r\nDISABLEVLAN_F));\r\nseq_printf(seq, " EnUpSwt: %3s\n", yesno(rssconf & ENABLEUP0_F));\r\nseq_printf(seq, " HashDelay: %3d\n", HASHDELAY_G(rssconf));\r\nif (CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5)\r\nseq_printf(seq, " VfWrAddr: %3d\n", VFWRADDR_G(rssconf));\r\nelse\r\nseq_printf(seq, " VfWrAddr: %3d\n",\r\nT6_VFWRADDR_G(rssconf));\r\nseq_printf(seq, " KeyMode: %s\n", keymode[KEYMODE_G(rssconf)]);\r\nseq_printf(seq, " VfWrEn: %3s\n", yesno(rssconf & VFWREN_F));\r\nseq_printf(seq, " KeyWrEn: %3s\n", yesno(rssconf & KEYWREN_F));\r\nseq_printf(seq, " KeyWrAddr: %3d\n", KEYWRADDR_G(rssconf));\r\nseq_puts(seq, "\n");\r\nrssconf = t4_read_reg(adapter, TP_RSS_CONFIG_CNG_A);\r\nseq_printf(seq, "TP_RSS_CONFIG_CNG: %#x\n", rssconf);\r\nseq_printf(seq, " ChnCount3: %3s\n", yesno(rssconf & CHNCOUNT3_F));\r\nseq_printf(seq, " ChnCount2: %3s\n", yesno(rssconf & CHNCOUNT2_F));\r\nseq_printf(seq, " ChnCount1: %3s\n", yesno(rssconf & CHNCOUNT1_F));\r\nseq_printf(seq, " ChnCount0: %3s\n", yesno(rssconf & CHNCOUNT0_F));\r\nseq_printf(seq, " ChnUndFlow3: %3s\n", yesno(rssconf &\r\nCHNUNDFLOW3_F));\r\nseq_printf(seq, " ChnUndFlow2: %3s\n", yesno(rssconf &\r\nCHNUNDFLOW2_F));\r\nseq_printf(seq, " ChnUndFlow1: %3s\n", yesno(rssconf &\r\nCHNUNDFLOW1_F));\r\nseq_printf(seq, " ChnUndFlow0: %3s\n", yesno(rssconf &\r\nCHNUNDFLOW0_F));\r\nseq_printf(seq, " RstChn3: %3s\n", yesno(rssconf & RSTCHN3_F));\r\nseq_printf(seq, " RstChn2: %3s\n", yesno(rssconf & RSTCHN2_F));\r\nseq_printf(seq, " RstChn1: %3s\n", yesno(rssconf & RSTCHN1_F));\r\nseq_printf(seq, " RstChn0: %3s\n", yesno(rssconf & RSTCHN0_F));\r\nseq_printf(seq, " UpdVld: %3s\n", yesno(rssconf & UPDVLD_F));\r\nseq_printf(seq, " Xoff: %3s\n", yesno(rssconf & XOFF_F));\r\nseq_printf(seq, " UpdChn3: %3s\n", yesno(rssconf & UPDCHN3_F));\r\nseq_printf(seq, " UpdChn2: %3s\n", yesno(rssconf & UPDCHN2_F));\r\nseq_printf(seq, " UpdChn1: %3s\n", yesno(rssconf & UPDCHN1_F));\r\nseq_printf(seq, " UpdChn0: %3s\n", yesno(rssconf & UPDCHN0_F));\r\nseq_printf(seq, " Queue: %3d\n", QUEUE_G(rssconf));\r\nreturn 0;\r\n}\r\nstatic int rss_key_show(struct seq_file *seq, void *v)\r\n{\r\nu32 key[10];\r\nt4_read_rss_key(seq->private, key);\r\nseq_printf(seq, "%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x\n",\r\nkey[9], key[8], key[7], key[6], key[5], key[4], key[3],\r\nkey[2], key[1], key[0]);\r\nreturn 0;\r\n}\r\nstatic int rss_key_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, rss_key_show, inode->i_private);\r\n}\r\nstatic ssize_t rss_key_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nint i, j;\r\nu32 key[10];\r\nchar s[100], *p;\r\nstruct adapter *adap = file_inode(file)->i_private;\r\nif (count > sizeof(s) - 1)\r\nreturn -EINVAL;\r\nif (copy_from_user(s, buf, count))\r\nreturn -EFAULT;\r\nfor (i = count; i > 0 && isspace(s[i - 1]); i--)\r\n;\r\ns[i] = '\0';\r\nfor (p = s, i = 9; i >= 0; i--) {\r\nkey[i] = 0;\r\nfor (j = 0; j < 8; j++, p++) {\r\nif (!isxdigit(*p))\r\nreturn -EINVAL;\r\nkey[i] = (key[i] << 4) | hex2val(*p);\r\n}\r\n}\r\nt4_write_rss_key(adap, key, -1);\r\nreturn count;\r\n}\r\nstatic int rss_pf_config_show(struct seq_file *seq, void *v, int idx)\r\n{\r\nstruct rss_pf_conf *pfconf;\r\nif (v == SEQ_START_TOKEN) {\r\npfconf = seq->private + offsetof(struct seq_tab, data);\r\nseq_printf(seq, "PF Map Index Size = %d\n\n",\r\nLKPIDXSIZE_G(pfconf->rss_pf_map));\r\nseq_puts(seq, " RSS PF VF Hash Tuple Enable Default\n");\r\nseq_puts(seq, " Enable IPF Mask Mask IPv6 IPv4 UDP Queue\n");\r\nseq_puts(seq, " PF Map Chn Prt Map Size Size Four Two Four Two Four Ch1 Ch0\n");\r\n} else {\r\n#define G_PFnLKPIDX(map, n) \\r\n(((map) >> PF1LKPIDX_S*(n)) & PF0LKPIDX_M)\r\n#define G_PFnMSKSIZE(mask, n) \\r\n(((mask) >> PF1MSKSIZE_S*(n)) & PF1MSKSIZE_M)\r\npfconf = v;\r\nseq_printf(seq, "%3d %3s %3s %3s %3d %3d %3d %3s %3s %3s %3s %3s %3d %3d\n",\r\nidx,\r\nyesno(pfconf->rss_pf_config & MAPENABLE_F),\r\nyesno(pfconf->rss_pf_config & CHNENABLE_F),\r\nyesno(pfconf->rss_pf_config & PRTENABLE_F),\r\nG_PFnLKPIDX(pfconf->rss_pf_map, idx),\r\nG_PFnMSKSIZE(pfconf->rss_pf_mask, idx),\r\nIVFWIDTH_G(pfconf->rss_pf_config),\r\nyesno(pfconf->rss_pf_config & IP6FOURTUPEN_F),\r\nyesno(pfconf->rss_pf_config & IP6TWOTUPEN_F),\r\nyesno(pfconf->rss_pf_config & IP4FOURTUPEN_F),\r\nyesno(pfconf->rss_pf_config & IP4TWOTUPEN_F),\r\nyesno(pfconf->rss_pf_config & UDPFOURTUPEN_F),\r\nCH1DEFAULTQUEUE_G(pfconf->rss_pf_config),\r\nCH0DEFAULTQUEUE_G(pfconf->rss_pf_config));\r\n#undef G_PFnLKPIDX\r\n#undef G_PFnMSKSIZE\r\n}\r\nreturn 0;\r\n}\r\nstatic int rss_pf_config_open(struct inode *inode, struct file *file)\r\n{\r\nstruct adapter *adapter = inode->i_private;\r\nstruct seq_tab *p;\r\nu32 rss_pf_map, rss_pf_mask;\r\nstruct rss_pf_conf *pfconf;\r\nint pf;\r\np = seq_open_tab(file, 8, sizeof(*pfconf), 1, rss_pf_config_show);\r\nif (!p)\r\nreturn -ENOMEM;\r\npfconf = (struct rss_pf_conf *)p->data;\r\nrss_pf_map = t4_read_rss_pf_map(adapter);\r\nrss_pf_mask = t4_read_rss_pf_mask(adapter);\r\nfor (pf = 0; pf < 8; pf++) {\r\npfconf[pf].rss_pf_map = rss_pf_map;\r\npfconf[pf].rss_pf_mask = rss_pf_mask;\r\nt4_read_rss_pf_config(adapter, pf, &pfconf[pf].rss_pf_config);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rss_vf_config_show(struct seq_file *seq, void *v, int idx)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, " RSS Hash Tuple Enable\n");\r\nseq_puts(seq, " Enable IVF Dis Enb IPv6 IPv4 UDP Def Secret Key\n");\r\nseq_puts(seq, " VF Chn Prt Map VLAN uP Four Two Four Two Four Que Idx Hash\n");\r\n} else {\r\nstruct rss_vf_conf *vfconf = v;\r\nseq_printf(seq, "%3d %3s %3s %3d %3s %3s %3s %3s %3s %3s %3s %4d %3d %#10x\n",\r\nidx,\r\nyesno(vfconf->rss_vf_vfh & VFCHNEN_F),\r\nyesno(vfconf->rss_vf_vfh & VFPRTEN_F),\r\nVFLKPIDX_G(vfconf->rss_vf_vfh),\r\nyesno(vfconf->rss_vf_vfh & VFVLNEX_F),\r\nyesno(vfconf->rss_vf_vfh & VFUPEN_F),\r\nyesno(vfconf->rss_vf_vfh & VFIP4FOURTUPEN_F),\r\nyesno(vfconf->rss_vf_vfh & VFIP6TWOTUPEN_F),\r\nyesno(vfconf->rss_vf_vfh & VFIP4FOURTUPEN_F),\r\nyesno(vfconf->rss_vf_vfh & VFIP4TWOTUPEN_F),\r\nyesno(vfconf->rss_vf_vfh & ENABLEUDPHASH_F),\r\nDEFAULTQUEUE_G(vfconf->rss_vf_vfh),\r\nKEYINDEX_G(vfconf->rss_vf_vfh),\r\nvfconf->rss_vf_vfl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rss_vf_config_open(struct inode *inode, struct file *file)\r\n{\r\nstruct adapter *adapter = inode->i_private;\r\nstruct seq_tab *p;\r\nstruct rss_vf_conf *vfconf;\r\nint vf, vfcount = adapter->params.arch.vfcount;\r\np = seq_open_tab(file, vfcount, sizeof(*vfconf), 1, rss_vf_config_show);\r\nif (!p)\r\nreturn -ENOMEM;\r\nvfconf = (struct rss_vf_conf *)p->data;\r\nfor (vf = 0; vf < vfcount; vf++) {\r\nt4_read_rss_vf_config(adapter, vf, &vfconf[vf].rss_vf_vfl,\r\n&vfconf[vf].rss_vf_vfh);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct port_info *ethqset2pinfo(struct adapter *adap, int qset)\r\n{\r\nint pidx;\r\nfor_each_port(adap, pidx) {\r\nstruct port_info *pi = adap2pinfo(adap, pidx);\r\nif (qset >= pi->first_qset &&\r\nqset < pi->first_qset + pi->nqsets)\r\nreturn pi;\r\n}\r\nBUG_ON(1);\r\nreturn NULL;\r\n}\r\nstatic int sge_qinfo_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adap = seq->private;\r\nint eth_entries = DIV_ROUND_UP(adap->sge.ethqsets, 4);\r\nint iscsi_entries = DIV_ROUND_UP(adap->sge.iscsiqsets, 4);\r\nint iscsit_entries = DIV_ROUND_UP(adap->sge.niscsitq, 4);\r\nint rdma_entries = DIV_ROUND_UP(adap->sge.rdmaqs, 4);\r\nint ciq_entries = DIV_ROUND_UP(adap->sge.rdmaciqs, 4);\r\nint ctrl_entries = DIV_ROUND_UP(MAX_CTRL_QUEUES, 4);\r\nint i, r = (uintptr_t)v - 1;\r\nint iscsi_idx = r - eth_entries;\r\nint iscsit_idx = iscsi_idx - iscsi_entries;\r\nint rdma_idx = iscsit_idx - iscsit_entries;\r\nint ciq_idx = rdma_idx - rdma_entries;\r\nint ctrl_idx = ciq_idx - ciq_entries;\r\nint fq_idx = ctrl_idx - ctrl_entries;\r\nif (r)\r\nseq_putc(seq, '\n');\r\n#define S3(fmt_spec, s, v) \\r\ndo { \\r\nseq_printf(seq, "%-12s", s); \\r\nfor (i = 0; i < n; ++i) \\r\nseq_printf(seq, " %16" fmt_spec, v); \\r\nseq_putc(seq, '\n'); \\r\n} while (0)\r\n#define S(s, v) S3("s", s, v)\r\n#define T3(fmt_spec, s, v) S3(fmt_spec, s, tx[i].v)\r\n#define T(s, v) S3("u", s, tx[i].v)\r\n#define TL(s, v) T3("lu", s, v)\r\n#define R3(fmt_spec, s, v) S3(fmt_spec, s, rx[i].v)\r\n#define R(s, v) S3("u", s, rx[i].v)\r\n#define RL(s, v) R3("lu", s, v)\r\nif (r < eth_entries) {\r\nint base_qset = r * 4;\r\nconst struct sge_eth_rxq *rx = &adap->sge.ethrxq[base_qset];\r\nconst struct sge_eth_txq *tx = &adap->sge.ethtxq[base_qset];\r\nint n = min(4, adap->sge.ethqsets - 4 * r);\r\nS("QType:", "Ethernet");\r\nS("Interface:",\r\nrx[i].rspq.netdev ? rx[i].rspq.netdev->name : "N/A");\r\nT("TxQ ID:", q.cntxt_id);\r\nT("TxQ size:", q.size);\r\nT("TxQ inuse:", q.in_use);\r\nT("TxQ CIDX:", q.cidx);\r\nT("TxQ PIDX:", q.pidx);\r\n#ifdef CONFIG_CHELSIO_T4_DCB\r\nT("DCB Prio:", dcb_prio);\r\nS3("u", "DCB PGID:",\r\n(ethqset2pinfo(adap, base_qset + i)->dcb.pgid >>\r\n4*(7-tx[i].dcb_prio)) & 0xf);\r\nS3("u", "DCB PFC:",\r\n(ethqset2pinfo(adap, base_qset + i)->dcb.pfcen >>\r\n1*(7-tx[i].dcb_prio)) & 0x1);\r\n#endif\r\nR("RspQ ID:", rspq.abs_id);\r\nR("RspQ size:", rspq.size);\r\nR("RspQE size:", rspq.iqe_len);\r\nR("RspQ CIDX:", rspq.cidx);\r\nR("RspQ Gen:", rspq.gen);\r\nS3("u", "Intr delay:", qtimer_val(adap, &rx[i].rspq));\r\nS3("u", "Intr pktcnt:",\r\nadap->sge.counter_val[rx[i].rspq.pktcnt_idx]);\r\nR("FL ID:", fl.cntxt_id);\r\nR("FL size:", fl.size - 8);\r\nR("FL pend:", fl.pend_cred);\r\nR("FL avail:", fl.avail);\r\nR("FL PIDX:", fl.pidx);\r\nR("FL CIDX:", fl.cidx);\r\nRL("RxPackets:", stats.pkts);\r\nRL("RxCSO:", stats.rx_cso);\r\nRL("VLANxtract:", stats.vlan_ex);\r\nRL("LROmerged:", stats.lro_merged);\r\nRL("LROpackets:", stats.lro_pkts);\r\nRL("RxDrops:", stats.rx_drops);\r\nTL("TSO:", tso);\r\nTL("TxCSO:", tx_cso);\r\nTL("VLANins:", vlan_ins);\r\nTL("TxQFull:", q.stops);\r\nTL("TxQRestarts:", q.restarts);\r\nTL("TxMapErr:", mapping_err);\r\nRL("FLAllocErr:", fl.alloc_failed);\r\nRL("FLLrgAlcErr:", fl.large_alloc_failed);\r\nRL("FLMapErr:", fl.mapping_err);\r\nRL("FLLow:", fl.low);\r\nRL("FLStarving:", fl.starving);\r\n} else if (iscsi_idx < iscsi_entries) {\r\nconst struct sge_ofld_rxq *rx =\r\n&adap->sge.iscsirxq[iscsi_idx * 4];\r\nconst struct sge_ofld_txq *tx =\r\n&adap->sge.ofldtxq[iscsi_idx * 4];\r\nint n = min(4, adap->sge.iscsiqsets - 4 * iscsi_idx);\r\nS("QType:", "iSCSI");\r\nT("TxQ ID:", q.cntxt_id);\r\nT("TxQ size:", q.size);\r\nT("TxQ inuse:", q.in_use);\r\nT("TxQ CIDX:", q.cidx);\r\nT("TxQ PIDX:", q.pidx);\r\nR("RspQ ID:", rspq.abs_id);\r\nR("RspQ size:", rspq.size);\r\nR("RspQE size:", rspq.iqe_len);\r\nR("RspQ CIDX:", rspq.cidx);\r\nR("RspQ Gen:", rspq.gen);\r\nS3("u", "Intr delay:", qtimer_val(adap, &rx[i].rspq));\r\nS3("u", "Intr pktcnt:",\r\nadap->sge.counter_val[rx[i].rspq.pktcnt_idx]);\r\nR("FL ID:", fl.cntxt_id);\r\nR("FL size:", fl.size - 8);\r\nR("FL pend:", fl.pend_cred);\r\nR("FL avail:", fl.avail);\r\nR("FL PIDX:", fl.pidx);\r\nR("FL CIDX:", fl.cidx);\r\nRL("RxPackets:", stats.pkts);\r\nRL("RxImmPkts:", stats.imm);\r\nRL("RxNoMem:", stats.nomem);\r\nRL("FLAllocErr:", fl.alloc_failed);\r\nRL("FLLrgAlcErr:", fl.large_alloc_failed);\r\nRL("FLMapErr:", fl.mapping_err);\r\nRL("FLLow:", fl.low);\r\nRL("FLStarving:", fl.starving);\r\n} else if (iscsit_idx < iscsit_entries) {\r\nconst struct sge_ofld_rxq *rx =\r\n&adap->sge.iscsitrxq[iscsit_idx * 4];\r\nint n = min(4, adap->sge.niscsitq - 4 * iscsit_idx);\r\nS("QType:", "iSCSIT");\r\nR("RspQ ID:", rspq.abs_id);\r\nR("RspQ size:", rspq.size);\r\nR("RspQE size:", rspq.iqe_len);\r\nR("RspQ CIDX:", rspq.cidx);\r\nR("RspQ Gen:", rspq.gen);\r\nS3("u", "Intr delay:", qtimer_val(adap, &rx[i].rspq));\r\nS3("u", "Intr pktcnt:",\r\nadap->sge.counter_val[rx[i].rspq.pktcnt_idx]);\r\nR("FL ID:", fl.cntxt_id);\r\nR("FL size:", fl.size - 8);\r\nR("FL pend:", fl.pend_cred);\r\nR("FL avail:", fl.avail);\r\nR("FL PIDX:", fl.pidx);\r\nR("FL CIDX:", fl.cidx);\r\nRL("RxPackets:", stats.pkts);\r\nRL("RxImmPkts:", stats.imm);\r\nRL("RxNoMem:", stats.nomem);\r\nRL("FLAllocErr:", fl.alloc_failed);\r\nRL("FLLrgAlcErr:", fl.large_alloc_failed);\r\nRL("FLMapErr:", fl.mapping_err);\r\nRL("FLLow:", fl.low);\r\nRL("FLStarving:", fl.starving);\r\n} else if (rdma_idx < rdma_entries) {\r\nconst struct sge_ofld_rxq *rx =\r\n&adap->sge.rdmarxq[rdma_idx * 4];\r\nint n = min(4, adap->sge.rdmaqs - 4 * rdma_idx);\r\nS("QType:", "RDMA-CPL");\r\nS("Interface:",\r\nrx[i].rspq.netdev ? rx[i].rspq.netdev->name : "N/A");\r\nR("RspQ ID:", rspq.abs_id);\r\nR("RspQ size:", rspq.size);\r\nR("RspQE size:", rspq.iqe_len);\r\nR("RspQ CIDX:", rspq.cidx);\r\nR("RspQ Gen:", rspq.gen);\r\nS3("u", "Intr delay:", qtimer_val(adap, &rx[i].rspq));\r\nS3("u", "Intr pktcnt:",\r\nadap->sge.counter_val[rx[i].rspq.pktcnt_idx]);\r\nR("FL ID:", fl.cntxt_id);\r\nR("FL size:", fl.size - 8);\r\nR("FL pend:", fl.pend_cred);\r\nR("FL avail:", fl.avail);\r\nR("FL PIDX:", fl.pidx);\r\nR("FL CIDX:", fl.cidx);\r\nRL("RxPackets:", stats.pkts);\r\nRL("RxImmPkts:", stats.imm);\r\nRL("RxNoMem:", stats.nomem);\r\nRL("FLAllocErr:", fl.alloc_failed);\r\nRL("FLLrgAlcErr:", fl.large_alloc_failed);\r\nRL("FLMapErr:", fl.mapping_err);\r\nRL("FLLow:", fl.low);\r\nRL("FLStarving:", fl.starving);\r\n} else if (ciq_idx < ciq_entries) {\r\nconst struct sge_ofld_rxq *rx = &adap->sge.rdmaciq[ciq_idx * 4];\r\nint n = min(4, adap->sge.rdmaciqs - 4 * ciq_idx);\r\nS("QType:", "RDMA-CIQ");\r\nS("Interface:",\r\nrx[i].rspq.netdev ? rx[i].rspq.netdev->name : "N/A");\r\nR("RspQ ID:", rspq.abs_id);\r\nR("RspQ size:", rspq.size);\r\nR("RspQE size:", rspq.iqe_len);\r\nR("RspQ CIDX:", rspq.cidx);\r\nR("RspQ Gen:", rspq.gen);\r\nS3("u", "Intr delay:", qtimer_val(adap, &rx[i].rspq));\r\nS3("u", "Intr pktcnt:",\r\nadap->sge.counter_val[rx[i].rspq.pktcnt_idx]);\r\nRL("RxAN:", stats.an);\r\nRL("RxNoMem:", stats.nomem);\r\n} else if (ctrl_idx < ctrl_entries) {\r\nconst struct sge_ctrl_txq *tx = &adap->sge.ctrlq[ctrl_idx * 4];\r\nint n = min(4, adap->params.nports - 4 * ctrl_idx);\r\nS("QType:", "Control");\r\nT("TxQ ID:", q.cntxt_id);\r\nT("TxQ size:", q.size);\r\nT("TxQ inuse:", q.in_use);\r\nT("TxQ CIDX:", q.cidx);\r\nT("TxQ PIDX:", q.pidx);\r\nTL("TxQFull:", q.stops);\r\nTL("TxQRestarts:", q.restarts);\r\n} else if (fq_idx == 0) {\r\nconst struct sge_rspq *evtq = &adap->sge.fw_evtq;\r\nseq_printf(seq, "%-12s %16s\n", "QType:", "FW event queue");\r\nseq_printf(seq, "%-12s %16u\n", "RspQ ID:", evtq->abs_id);\r\nseq_printf(seq, "%-12s %16u\n", "RspQ size:", evtq->size);\r\nseq_printf(seq, "%-12s %16u\n", "RspQE size:", evtq->iqe_len);\r\nseq_printf(seq, "%-12s %16u\n", "RspQ CIDX:", evtq->cidx);\r\nseq_printf(seq, "%-12s %16u\n", "RspQ Gen:", evtq->gen);\r\nseq_printf(seq, "%-12s %16u\n", "Intr delay:",\r\nqtimer_val(adap, evtq));\r\nseq_printf(seq, "%-12s %16u\n", "Intr pktcnt:",\r\nadap->sge.counter_val[evtq->pktcnt_idx]);\r\n}\r\n#undef R\r\n#undef RL\r\n#undef T\r\n#undef TL\r\n#undef S\r\n#undef R3\r\n#undef T3\r\n#undef S3\r\nreturn 0;\r\n}\r\nstatic int sge_queue_entries(const struct adapter *adap)\r\n{\r\nreturn DIV_ROUND_UP(adap->sge.ethqsets, 4) +\r\nDIV_ROUND_UP(adap->sge.iscsiqsets, 4) +\r\nDIV_ROUND_UP(adap->sge.niscsitq, 4) +\r\nDIV_ROUND_UP(adap->sge.rdmaqs, 4) +\r\nDIV_ROUND_UP(adap->sge.rdmaciqs, 4) +\r\nDIV_ROUND_UP(MAX_CTRL_QUEUES, 4) + 1;\r\n}\r\nstatic void *sge_queue_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nint entries = sge_queue_entries(seq->private);\r\nreturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\r\n}\r\nstatic void sge_queue_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic void *sge_queue_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nint entries = sge_queue_entries(seq->private);\r\n++*pos;\r\nreturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\r\n}\r\nstatic int sge_qinfo_open(struct inode *inode, struct file *file)\r\n{\r\nint res = seq_open(file, &sge_qinfo_seq_ops);\r\nif (!res) {\r\nstruct seq_file *seq = file->private_data;\r\nseq->private = inode->i_private;\r\n}\r\nreturn res;\r\n}\r\nint mem_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int mem;\r\nstruct adapter *adap;\r\nfile->private_data = inode->i_private;\r\nmem = (uintptr_t)file->private_data & 0x3;\r\nadap = file->private_data - mem;\r\n(void)t4_fwcache(adap, FW_PARAM_DEV_FWCACHE_FLUSH);\r\nreturn 0;\r\n}\r\nstatic ssize_t mem_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nloff_t pos = *ppos;\r\nloff_t avail = file_inode(file)->i_size;\r\nunsigned int mem = (uintptr_t)file->private_data & 3;\r\nstruct adapter *adap = file->private_data - mem;\r\n__be32 *data;\r\nint ret;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nif (pos >= avail)\r\nreturn 0;\r\nif (count > avail - pos)\r\ncount = avail - pos;\r\ndata = t4_alloc_mem(count);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspin_lock(&adap->win0_lock);\r\nret = t4_memory_rw(adap, 0, mem, pos, count, data, T4_MEMORY_READ);\r\nspin_unlock(&adap->win0_lock);\r\nif (ret) {\r\nt4_free_mem(data);\r\nreturn ret;\r\n}\r\nret = copy_to_user(buf, data, count);\r\nt4_free_mem(data);\r\nif (ret)\r\nreturn -EFAULT;\r\n*ppos = pos + count;\r\nreturn count;\r\n}\r\nstatic int tid_info_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adap = seq->private;\r\nconst struct tid_info *t = &adap->tids;\r\nenum chip_type chip = CHELSIO_CHIP_VERSION(adap->params.chip);\r\nif (t4_read_reg(adap, LE_DB_CONFIG_A) & HASHEN_F) {\r\nunsigned int sb;\r\nif (chip <= CHELSIO_T5)\r\nsb = t4_read_reg(adap, LE_DB_SERVER_INDEX_A) / 4;\r\nelse\r\nsb = t4_read_reg(adap, LE_DB_SRVR_START_INDEX_A);\r\nif (sb) {\r\nseq_printf(seq, "TID range: 0..%u/%u..%u", sb - 1,\r\nadap->tids.hash_base,\r\nt->ntids - 1);\r\nseq_printf(seq, ", in use: %u/%u\n",\r\natomic_read(&t->tids_in_use),\r\natomic_read(&t->hash_tids_in_use));\r\n} else if (adap->flags & FW_OFLD_CONN) {\r\nseq_printf(seq, "TID range: %u..%u/%u..%u",\r\nt->aftid_base,\r\nt->aftid_end,\r\nadap->tids.hash_base,\r\nt->ntids - 1);\r\nseq_printf(seq, ", in use: %u/%u\n",\r\natomic_read(&t->tids_in_use),\r\natomic_read(&t->hash_tids_in_use));\r\n} else {\r\nseq_printf(seq, "TID range: %u..%u",\r\nadap->tids.hash_base,\r\nt->ntids - 1);\r\nseq_printf(seq, ", in use: %u\n",\r\natomic_read(&t->hash_tids_in_use));\r\n}\r\n} else if (t->ntids) {\r\nseq_printf(seq, "TID range: 0..%u", t->ntids - 1);\r\nseq_printf(seq, ", in use: %u\n",\r\natomic_read(&t->tids_in_use));\r\n}\r\nif (t->nstids)\r\nseq_printf(seq, "STID range: %u..%u, in use: %u\n",\r\n(!t->stid_base &&\r\n(chip <= CHELSIO_T5)) ?\r\nt->stid_base + 1 : t->stid_base,\r\nt->stid_base + t->nstids - 1, t->stids_in_use);\r\nif (t->natids)\r\nseq_printf(seq, "ATID range: 0..%u, in use: %u\n",\r\nt->natids - 1, t->atids_in_use);\r\nseq_printf(seq, "FTID range: %u..%u\n", t->ftid_base,\r\nt->ftid_base + t->nftids - 1);\r\nif (t->nsftids)\r\nseq_printf(seq, "SFTID range: %u..%u in use: %u\n",\r\nt->sftid_base, t->sftid_base + t->nsftids - 2,\r\nt->sftids_in_use);\r\nif (t->ntids)\r\nseq_printf(seq, "HW TID usage: %u IP users, %u IPv6 users\n",\r\nt4_read_reg(adap, LE_DB_ACT_CNT_IPV4_A),\r\nt4_read_reg(adap, LE_DB_ACT_CNT_IPV6_A));\r\nreturn 0;\r\n}\r\nstatic void add_debugfs_mem(struct adapter *adap, const char *name,\r\nunsigned int idx, unsigned int size_mb)\r\n{\r\ndebugfs_create_file_size(name, S_IRUSR, adap->debugfs_root,\r\n(void *)adap + idx, &mem_debugfs_fops,\r\nsize_mb << 20);\r\n}\r\nstatic int blocked_fl_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic ssize_t blocked_fl_read(struct file *filp, char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint len;\r\nconst struct adapter *adap = filp->private_data;\r\nchar *buf;\r\nssize_t size = (adap->sge.egr_sz + 3) / 4 +\r\nadap->sge.egr_sz / 32 + 2;\r\nbuf = kzalloc(size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nlen = snprintf(buf, size - 1, "%*pb\n",\r\nadap->sge.egr_sz, adap->sge.blocked_fl);\r\nlen += sprintf(buf + len, "\n");\r\nsize = simple_read_from_buffer(ubuf, count, ppos, buf, len);\r\nt4_free_mem(buf);\r\nreturn size;\r\n}\r\nstatic ssize_t blocked_fl_write(struct file *filp, const char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint err;\r\nunsigned long *t;\r\nstruct adapter *adap = filp->private_data;\r\nt = kcalloc(BITS_TO_LONGS(adap->sge.egr_sz), sizeof(long), GFP_KERNEL);\r\nif (!t)\r\nreturn -ENOMEM;\r\nerr = bitmap_parse_user(ubuf, count, t, adap->sge.egr_sz);\r\nif (err)\r\nreturn err;\r\nbitmap_copy(adap->sge.blocked_fl, t, adap->sge.egr_sz);\r\nt4_free_mem(t);\r\nreturn count;\r\n}\r\nstatic int mem_desc_cmp(const void *a, const void *b)\r\n{\r\nreturn ((const struct mem_desc *)a)->base -\r\n((const struct mem_desc *)b)->base;\r\n}\r\nstatic void mem_region_show(struct seq_file *seq, const char *name,\r\nunsigned int from, unsigned int to)\r\n{\r\nchar buf[40];\r\nstring_get_size((u64)to - from + 1, 1, STRING_UNITS_2, buf,\r\nsizeof(buf));\r\nseq_printf(seq, "%-15s %#x-%#x [%s]\n", name, from, to, buf);\r\n}\r\nstatic int meminfo_show(struct seq_file *seq, void *v)\r\n{\r\nstatic const char * const memory[] = { "EDC0:", "EDC1:", "MC:",\r\n"MC0:", "MC1:"};\r\nstatic const char * const region[] = {\r\n"DBQ contexts:", "IMSG contexts:", "FLM cache:", "TCBs:",\r\n"Pstructs:", "Timers:", "Rx FL:", "Tx FL:", "Pstruct FL:",\r\n"Tx payload:", "Rx payload:", "LE hash:", "iSCSI region:",\r\n"TDDP region:", "TPT region:", "STAG region:", "RQ region:",\r\n"RQUDP region:", "PBL region:", "TXPBL region:",\r\n"DBVFIFO region:", "ULPRX state:", "ULPTX state:",\r\n"On-chip queues:"\r\n};\r\nint i, n;\r\nu32 lo, hi, used, alloc;\r\nstruct mem_desc avail[4];\r\nstruct mem_desc mem[ARRAY_SIZE(region) + 3];\r\nstruct mem_desc *md = mem;\r\nstruct adapter *adap = seq->private;\r\nfor (i = 0; i < ARRAY_SIZE(mem); i++) {\r\nmem[i].limit = 0;\r\nmem[i].idx = i;\r\n}\r\ni = 0;\r\nlo = t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A);\r\nif (lo & EDRAM0_ENABLE_F) {\r\nhi = t4_read_reg(adap, MA_EDRAM0_BAR_A);\r\navail[i].base = EDRAM0_BASE_G(hi) << 20;\r\navail[i].limit = avail[i].base + (EDRAM0_SIZE_G(hi) << 20);\r\navail[i].idx = 0;\r\ni++;\r\n}\r\nif (lo & EDRAM1_ENABLE_F) {\r\nhi = t4_read_reg(adap, MA_EDRAM1_BAR_A);\r\navail[i].base = EDRAM1_BASE_G(hi) << 20;\r\navail[i].limit = avail[i].base + (EDRAM1_SIZE_G(hi) << 20);\r\navail[i].idx = 1;\r\ni++;\r\n}\r\nif (is_t5(adap->params.chip)) {\r\nif (lo & EXT_MEM0_ENABLE_F) {\r\nhi = t4_read_reg(adap, MA_EXT_MEMORY0_BAR_A);\r\navail[i].base = EXT_MEM0_BASE_G(hi) << 20;\r\navail[i].limit =\r\navail[i].base + (EXT_MEM0_SIZE_G(hi) << 20);\r\navail[i].idx = 3;\r\ni++;\r\n}\r\nif (lo & EXT_MEM1_ENABLE_F) {\r\nhi = t4_read_reg(adap, MA_EXT_MEMORY1_BAR_A);\r\navail[i].base = EXT_MEM1_BASE_G(hi) << 20;\r\navail[i].limit =\r\navail[i].base + (EXT_MEM1_SIZE_G(hi) << 20);\r\navail[i].idx = 4;\r\ni++;\r\n}\r\n} else {\r\nif (lo & EXT_MEM_ENABLE_F) {\r\nhi = t4_read_reg(adap, MA_EXT_MEMORY_BAR_A);\r\navail[i].base = EXT_MEM_BASE_G(hi) << 20;\r\navail[i].limit =\r\navail[i].base + (EXT_MEM_SIZE_G(hi) << 20);\r\navail[i].idx = 2;\r\ni++;\r\n}\r\n}\r\nif (!i)\r\nreturn 0;\r\nsort(avail, i, sizeof(struct mem_desc), mem_desc_cmp, NULL);\r\n(md++)->base = t4_read_reg(adap, SGE_DBQ_CTXT_BADDR_A);\r\n(md++)->base = t4_read_reg(adap, SGE_IMSG_CTXT_BADDR_A);\r\n(md++)->base = t4_read_reg(adap, SGE_FLM_CACHE_BADDR_A);\r\n(md++)->base = t4_read_reg(adap, TP_CMM_TCB_BASE_A);\r\n(md++)->base = t4_read_reg(adap, TP_CMM_MM_BASE_A);\r\n(md++)->base = t4_read_reg(adap, TP_CMM_TIMER_BASE_A);\r\n(md++)->base = t4_read_reg(adap, TP_CMM_MM_RX_FLST_BASE_A);\r\n(md++)->base = t4_read_reg(adap, TP_CMM_MM_TX_FLST_BASE_A);\r\n(md++)->base = t4_read_reg(adap, TP_CMM_MM_PS_FLST_BASE_A);\r\nmd->base = t4_read_reg(adap, TP_PMM_TX_BASE_A);\r\nmd->limit = md->base - 1 +\r\nt4_read_reg(adap, TP_PMM_TX_PAGE_SIZE_A) *\r\nPMTXMAXPAGE_G(t4_read_reg(adap, TP_PMM_TX_MAX_PAGE_A));\r\nmd++;\r\nmd->base = t4_read_reg(adap, TP_PMM_RX_BASE_A);\r\nmd->limit = md->base - 1 +\r\nt4_read_reg(adap, TP_PMM_RX_PAGE_SIZE_A) *\r\nPMRXMAXPAGE_G(t4_read_reg(adap, TP_PMM_RX_MAX_PAGE_A));\r\nmd++;\r\nif (t4_read_reg(adap, LE_DB_CONFIG_A) & HASHEN_F) {\r\nif (CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5) {\r\nhi = t4_read_reg(adap, LE_DB_TID_HASHBASE_A) / 4;\r\nmd->base = t4_read_reg(adap, LE_DB_HASH_TID_BASE_A);\r\n} else {\r\nhi = t4_read_reg(adap, LE_DB_HASH_TID_BASE_A);\r\nmd->base = t4_read_reg(adap,\r\nLE_DB_HASH_TBL_BASE_ADDR_A);\r\n}\r\nmd->limit = 0;\r\n} else {\r\nmd->base = 0;\r\nmd->idx = ARRAY_SIZE(region);\r\n}\r\nmd++;\r\n#define ulp_region(reg) do { \\r\nmd->base = t4_read_reg(adap, ULP_ ## reg ## _LLIMIT_A);\\r\n(md++)->limit = t4_read_reg(adap, ULP_ ## reg ## _ULIMIT_A); \\r\n} while (0)\r\nulp_region(RX_ISCSI);\r\nulp_region(RX_TDDP);\r\nulp_region(TX_TPT);\r\nulp_region(RX_STAG);\r\nulp_region(RX_RQ);\r\nulp_region(RX_RQUDP);\r\nulp_region(RX_PBL);\r\nulp_region(TX_PBL);\r\n#undef ulp_region\r\nmd->base = 0;\r\nmd->idx = ARRAY_SIZE(region);\r\nif (!is_t4(adap->params.chip)) {\r\nu32 size = 0;\r\nu32 sge_ctrl = t4_read_reg(adap, SGE_CONTROL2_A);\r\nu32 fifo_size = t4_read_reg(adap, SGE_DBVFIFO_SIZE_A);\r\nif (is_t5(adap->params.chip)) {\r\nif (sge_ctrl & VFIFO_ENABLE_F)\r\nsize = DBVFIFO_SIZE_G(fifo_size);\r\n} else {\r\nsize = T6_DBVFIFO_SIZE_G(fifo_size);\r\n}\r\nif (size) {\r\nmd->base = BASEADDR_G(t4_read_reg(adap,\r\nSGE_DBVFIFO_BADDR_A));\r\nmd->limit = md->base + (size << 2) - 1;\r\n}\r\n}\r\nmd++;\r\nmd->base = t4_read_reg(adap, ULP_RX_CTX_BASE_A);\r\nmd->limit = 0;\r\nmd++;\r\nmd->base = t4_read_reg(adap, ULP_TX_ERR_TABLE_BASE_A);\r\nmd->limit = 0;\r\nmd++;\r\nmd->base = adap->vres.ocq.start;\r\nif (adap->vres.ocq.size)\r\nmd->limit = md->base + adap->vres.ocq.size - 1;\r\nelse\r\nmd->idx = ARRAY_SIZE(region);\r\nmd++;\r\nfor (n = 0; n < i - 1; n++)\r\nif (avail[n].limit < avail[n + 1].base)\r\n(md++)->base = avail[n].limit;\r\nif (avail[n].limit)\r\n(md++)->base = avail[n].limit;\r\nn = md - mem;\r\nsort(mem, n, sizeof(struct mem_desc), mem_desc_cmp, NULL);\r\nfor (lo = 0; lo < i; lo++)\r\nmem_region_show(seq, memory[avail[lo].idx], avail[lo].base,\r\navail[lo].limit - 1);\r\nseq_putc(seq, '\n');\r\nfor (i = 0; i < n; i++) {\r\nif (mem[i].idx >= ARRAY_SIZE(region))\r\ncontinue;\r\nif (!mem[i].limit)\r\nmem[i].limit = i < n - 1 ? mem[i + 1].base - 1 : ~0;\r\nmem_region_show(seq, region[mem[i].idx], mem[i].base,\r\nmem[i].limit);\r\n}\r\nseq_putc(seq, '\n');\r\nlo = t4_read_reg(adap, CIM_SDRAM_BASE_ADDR_A);\r\nhi = t4_read_reg(adap, CIM_SDRAM_ADDR_SIZE_A) + lo - 1;\r\nmem_region_show(seq, "uP RAM:", lo, hi);\r\nlo = t4_read_reg(adap, CIM_EXTMEM2_BASE_ADDR_A);\r\nhi = t4_read_reg(adap, CIM_EXTMEM2_ADDR_SIZE_A) + lo - 1;\r\nmem_region_show(seq, "uP Extmem2:", lo, hi);\r\nlo = t4_read_reg(adap, TP_PMM_RX_MAX_PAGE_A);\r\nseq_printf(seq, "\n%u Rx pages of size %uKiB for %u channels\n",\r\nPMRXMAXPAGE_G(lo),\r\nt4_read_reg(adap, TP_PMM_RX_PAGE_SIZE_A) >> 10,\r\n(lo & PMRXNUMCHN_F) ? 2 : 1);\r\nlo = t4_read_reg(adap, TP_PMM_TX_MAX_PAGE_A);\r\nhi = t4_read_reg(adap, TP_PMM_TX_PAGE_SIZE_A);\r\nseq_printf(seq, "%u Tx pages of size %u%ciB for %u channels\n",\r\nPMTXMAXPAGE_G(lo),\r\nhi >= (1 << 20) ? (hi >> 20) : (hi >> 10),\r\nhi >= (1 << 20) ? 'M' : 'K', 1 << PMTXNUMCHN_G(lo));\r\nseq_printf(seq, "%u p-structs\n\n",\r\nt4_read_reg(adap, TP_CMM_MM_MAX_PSTRUCT_A));\r\nfor (i = 0; i < 4; i++) {\r\nif (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5)\r\nlo = t4_read_reg(adap, MPS_RX_MAC_BG_PG_CNT0_A + i * 4);\r\nelse\r\nlo = t4_read_reg(adap, MPS_RX_PG_RSV0_A + i * 4);\r\nif (is_t5(adap->params.chip)) {\r\nused = T5_USED_G(lo);\r\nalloc = T5_ALLOC_G(lo);\r\n} else {\r\nused = USED_G(lo);\r\nalloc = ALLOC_G(lo);\r\n}\r\nseq_printf(seq, "Port %d using %u pages out of %u allocated\n",\r\ni, used, alloc);\r\n}\r\nfor (i = 0; i < adap->params.arch.nchan; i++) {\r\nif (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5)\r\nlo = t4_read_reg(adap,\r\nMPS_RX_LPBK_BG_PG_CNT0_A + i * 4);\r\nelse\r\nlo = t4_read_reg(adap, MPS_RX_PG_RSV4_A + i * 4);\r\nif (is_t5(adap->params.chip)) {\r\nused = T5_USED_G(lo);\r\nalloc = T5_ALLOC_G(lo);\r\n} else {\r\nused = USED_G(lo);\r\nalloc = ALLOC_G(lo);\r\n}\r\nseq_printf(seq,\r\n"Loopback %d using %u pages out of %u allocated\n",\r\ni, used, alloc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int meminfo_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, meminfo_show, inode->i_private);\r\n}\r\nvoid add_debugfs_files(struct adapter *adap,\r\nstruct t4_debugfs_entry *files,\r\nunsigned int nfiles)\r\n{\r\nint i;\r\nfor (i = 0; i < nfiles; i++)\r\ndebugfs_create_file(files[i].name, files[i].mode,\r\nadap->debugfs_root,\r\n(void *)adap + files[i].data,\r\nfiles[i].ops);\r\n}\r\nint t4_setup_debugfs(struct adapter *adap)\r\n{\r\nint i;\r\nu32 size = 0;\r\nstruct dentry *de;\r\nstatic struct t4_debugfs_entry t4_debugfs_files[] = {\r\n{ "cim_la", &cim_la_fops, S_IRUSR, 0 },\r\n{ "cim_pif_la", &cim_pif_la_fops, S_IRUSR, 0 },\r\n{ "cim_ma_la", &cim_ma_la_fops, S_IRUSR, 0 },\r\n{ "cim_qcfg", &cim_qcfg_fops, S_IRUSR, 0 },\r\n{ "clk", &clk_debugfs_fops, S_IRUSR, 0 },\r\n{ "devlog", &devlog_fops, S_IRUSR, 0 },\r\n{ "mboxlog", &mboxlog_fops, S_IRUSR, 0 },\r\n{ "mbox0", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 0 },\r\n{ "mbox1", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 1 },\r\n{ "mbox2", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 2 },\r\n{ "mbox3", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 3 },\r\n{ "mbox4", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 4 },\r\n{ "mbox5", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 5 },\r\n{ "mbox6", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 6 },\r\n{ "mbox7", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 7 },\r\n{ "trace0", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 0 },\r\n{ "trace1", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 1 },\r\n{ "trace2", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 2 },\r\n{ "trace3", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 3 },\r\n{ "l2t", &t4_l2t_fops, S_IRUSR, 0},\r\n{ "mps_tcam", &mps_tcam_debugfs_fops, S_IRUSR, 0 },\r\n{ "rss", &rss_debugfs_fops, S_IRUSR, 0 },\r\n{ "rss_config", &rss_config_debugfs_fops, S_IRUSR, 0 },\r\n{ "rss_key", &rss_key_debugfs_fops, S_IRUSR, 0 },\r\n{ "rss_pf_config", &rss_pf_config_debugfs_fops, S_IRUSR, 0 },\r\n{ "rss_vf_config", &rss_vf_config_debugfs_fops, S_IRUSR, 0 },\r\n{ "sge_qinfo", &sge_qinfo_debugfs_fops, S_IRUSR, 0 },\r\n{ "ibq_tp0", &cim_ibq_fops, S_IRUSR, 0 },\r\n{ "ibq_tp1", &cim_ibq_fops, S_IRUSR, 1 },\r\n{ "ibq_ulp", &cim_ibq_fops, S_IRUSR, 2 },\r\n{ "ibq_sge0", &cim_ibq_fops, S_IRUSR, 3 },\r\n{ "ibq_sge1", &cim_ibq_fops, S_IRUSR, 4 },\r\n{ "ibq_ncsi", &cim_ibq_fops, S_IRUSR, 5 },\r\n{ "obq_ulp0", &cim_obq_fops, S_IRUSR, 0 },\r\n{ "obq_ulp1", &cim_obq_fops, S_IRUSR, 1 },\r\n{ "obq_ulp2", &cim_obq_fops, S_IRUSR, 2 },\r\n{ "obq_ulp3", &cim_obq_fops, S_IRUSR, 3 },\r\n{ "obq_sge", &cim_obq_fops, S_IRUSR, 4 },\r\n{ "obq_ncsi", &cim_obq_fops, S_IRUSR, 5 },\r\n{ "tp_la", &tp_la_fops, S_IRUSR, 0 },\r\n{ "ulprx_la", &ulprx_la_fops, S_IRUSR, 0 },\r\n{ "sensors", &sensors_debugfs_fops, S_IRUSR, 0 },\r\n{ "pm_stats", &pm_stats_debugfs_fops, S_IRUSR, 0 },\r\n{ "tx_rate", &tx_rate_debugfs_fops, S_IRUSR, 0 },\r\n{ "cctrl", &cctrl_tbl_debugfs_fops, S_IRUSR, 0 },\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n{ "clip_tbl", &clip_tbl_debugfs_fops, S_IRUSR, 0 },\r\n#endif\r\n{ "tids", &tid_info_debugfs_fops, S_IRUSR, 0},\r\n{ "blocked_fl", &blocked_fl_fops, S_IRUSR | S_IWUSR, 0 },\r\n{ "meminfo", &meminfo_fops, S_IRUSR, 0 },\r\n};\r\nstatic struct t4_debugfs_entry t5_debugfs_files[] = {\r\n{ "obq_sge_rx_q0", &cim_obq_fops, S_IRUSR, 6 },\r\n{ "obq_sge_rx_q1", &cim_obq_fops, S_IRUSR, 7 },\r\n};\r\nadd_debugfs_files(adap,\r\nt4_debugfs_files,\r\nARRAY_SIZE(t4_debugfs_files));\r\nif (!is_t4(adap->params.chip))\r\nadd_debugfs_files(adap,\r\nt5_debugfs_files,\r\nARRAY_SIZE(t5_debugfs_files));\r\ni = t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A);\r\nif (i & EDRAM0_ENABLE_F) {\r\nsize = t4_read_reg(adap, MA_EDRAM0_BAR_A);\r\nadd_debugfs_mem(adap, "edc0", MEM_EDC0, EDRAM0_SIZE_G(size));\r\n}\r\nif (i & EDRAM1_ENABLE_F) {\r\nsize = t4_read_reg(adap, MA_EDRAM1_BAR_A);\r\nadd_debugfs_mem(adap, "edc1", MEM_EDC1, EDRAM1_SIZE_G(size));\r\n}\r\nif (is_t5(adap->params.chip)) {\r\nif (i & EXT_MEM0_ENABLE_F) {\r\nsize = t4_read_reg(adap, MA_EXT_MEMORY0_BAR_A);\r\nadd_debugfs_mem(adap, "mc0", MEM_MC0,\r\nEXT_MEM0_SIZE_G(size));\r\n}\r\nif (i & EXT_MEM1_ENABLE_F) {\r\nsize = t4_read_reg(adap, MA_EXT_MEMORY1_BAR_A);\r\nadd_debugfs_mem(adap, "mc1", MEM_MC1,\r\nEXT_MEM1_SIZE_G(size));\r\n}\r\n} else {\r\nif (i & EXT_MEM_ENABLE_F) {\r\nsize = t4_read_reg(adap, MA_EXT_MEMORY_BAR_A);\r\nadd_debugfs_mem(adap, "mc", MEM_MC,\r\nEXT_MEM_SIZE_G(size));\r\n}\r\n}\r\nde = debugfs_create_file_size("flash", S_IRUSR, adap->debugfs_root, adap,\r\n&flash_debugfs_fops, adap->params.sf_size);\r\ndebugfs_create_bool("use_backdoor", S_IWUSR | S_IRUSR,\r\nadap->debugfs_root, &adap->use_bd);\r\ndebugfs_create_bool("trace_rss", S_IWUSR | S_IRUSR,\r\nadap->debugfs_root, &adap->trace_rss);\r\nreturn 0;\r\n}
