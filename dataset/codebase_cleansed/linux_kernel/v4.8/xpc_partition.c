void *\r\nxpc_kmalloc_cacheline_aligned(size_t size, gfp_t flags, void **base)\r\n{\r\n*base = kmalloc(size, flags);\r\nif (*base == NULL)\r\nreturn NULL;\r\nif ((u64)*base == L1_CACHE_ALIGN((u64)*base))\r\nreturn *base;\r\nkfree(*base);\r\n*base = kmalloc(size + L1_CACHE_BYTES, flags);\r\nif (*base == NULL)\r\nreturn NULL;\r\nreturn (void *)L1_CACHE_ALIGN((u64)*base);\r\n}\r\nstatic unsigned long\r\nxpc_get_rsvd_page_pa(int nasid)\r\n{\r\nenum xp_retval ret;\r\nu64 cookie = 0;\r\nunsigned long rp_pa = nasid;\r\nsize_t len = 0;\r\nsize_t buf_len = 0;\r\nvoid *buf = buf;\r\nvoid *buf_base = NULL;\r\nenum xp_retval (*get_partition_rsvd_page_pa)\r\n(void *, u64 *, unsigned long *, size_t *) =\r\nxpc_arch_ops.get_partition_rsvd_page_pa;\r\nwhile (1) {\r\nret = get_partition_rsvd_page_pa(buf, &cookie, &rp_pa, &len);\r\ndev_dbg(xpc_part, "SAL returned with ret=%d, cookie=0x%016lx, "\r\n"address=0x%016lx, len=0x%016lx\n", ret,\r\n(unsigned long)cookie, rp_pa, len);\r\nif (ret != xpNeedMoreInfo)\r\nbreak;\r\nif (is_shub())\r\nlen = L1_CACHE_ALIGN(len);\r\nif (len > buf_len) {\r\nif (buf_base != NULL)\r\nkfree(buf_base);\r\nbuf_len = L1_CACHE_ALIGN(len);\r\nbuf = xpc_kmalloc_cacheline_aligned(buf_len, GFP_KERNEL,\r\n&buf_base);\r\nif (buf_base == NULL) {\r\ndev_err(xpc_part, "unable to kmalloc "\r\n"len=0x%016lx\n", buf_len);\r\nret = xpNoMemory;\r\nbreak;\r\n}\r\n}\r\nret = xp_remote_memcpy(xp_pa(buf), rp_pa, len);\r\nif (ret != xpSuccess) {\r\ndev_dbg(xpc_part, "xp_remote_memcpy failed %d\n", ret);\r\nbreak;\r\n}\r\n}\r\nkfree(buf_base);\r\nif (ret != xpSuccess)\r\nrp_pa = 0;\r\ndev_dbg(xpc_part, "reserved page at phys address 0x%016lx\n", rp_pa);\r\nreturn rp_pa;\r\n}\r\nint\r\nxpc_setup_rsvd_page(void)\r\n{\r\nint ret;\r\nstruct xpc_rsvd_page *rp;\r\nunsigned long rp_pa;\r\nunsigned long new_ts_jiffies;\r\npreempt_disable();\r\nrp_pa = xpc_get_rsvd_page_pa(xp_cpu_to_nasid(smp_processor_id()));\r\npreempt_enable();\r\nif (rp_pa == 0) {\r\ndev_err(xpc_part, "SAL failed to locate the reserved page\n");\r\nreturn -ESRCH;\r\n}\r\nrp = (struct xpc_rsvd_page *)__va(xp_socket_pa(rp_pa));\r\nif (rp->SAL_version < 3) {\r\nrp->SAL_partid &= 0xff;\r\n}\r\nBUG_ON(rp->SAL_partid != xp_partition_id);\r\nif (rp->SAL_partid < 0 || rp->SAL_partid >= xp_max_npartitions) {\r\ndev_err(xpc_part, "the reserved page's partid of %d is outside "\r\n"supported range (< 0 || >= %d)\n", rp->SAL_partid,\r\nxp_max_npartitions);\r\nreturn -EINVAL;\r\n}\r\nrp->version = XPC_RP_VERSION;\r\nrp->max_npartitions = xp_max_npartitions;\r\nif (rp->SAL_version == 1) {\r\nrp->SAL_nasids_size = 128;\r\n}\r\nxpc_nasid_mask_nbytes = rp->SAL_nasids_size;\r\nxpc_nasid_mask_nlongs = BITS_TO_LONGS(rp->SAL_nasids_size *\r\nBITS_PER_BYTE);\r\nxpc_part_nasids = XPC_RP_PART_NASIDS(rp);\r\nxpc_mach_nasids = XPC_RP_MACH_NASIDS(rp);\r\nret = xpc_arch_ops.setup_rsvd_page(rp);\r\nif (ret != 0)\r\nreturn ret;\r\nnew_ts_jiffies = jiffies;\r\nif (new_ts_jiffies == 0 || new_ts_jiffies == rp->ts_jiffies)\r\nnew_ts_jiffies++;\r\nrp->ts_jiffies = new_ts_jiffies;\r\nxpc_rsvd_page = rp;\r\nreturn 0;\r\n}\r\nvoid\r\nxpc_teardown_rsvd_page(void)\r\n{\r\nxpc_rsvd_page->ts_jiffies = 0;\r\n}\r\nenum xp_retval\r\nxpc_get_remote_rp(int nasid, unsigned long *discovered_nasids,\r\nstruct xpc_rsvd_page *remote_rp, unsigned long *remote_rp_pa)\r\n{\r\nint l;\r\nenum xp_retval ret;\r\n*remote_rp_pa = xpc_get_rsvd_page_pa(nasid);\r\nif (*remote_rp_pa == 0)\r\nreturn xpNoRsvdPageAddr;\r\nret = xp_remote_memcpy(xp_pa(remote_rp), *remote_rp_pa,\r\nXPC_RP_HEADER_SIZE + xpc_nasid_mask_nbytes);\r\nif (ret != xpSuccess)\r\nreturn ret;\r\nif (discovered_nasids != NULL) {\r\nunsigned long *remote_part_nasids =\r\nXPC_RP_PART_NASIDS(remote_rp);\r\nfor (l = 0; l < xpc_nasid_mask_nlongs; l++)\r\ndiscovered_nasids[l] |= remote_part_nasids[l];\r\n}\r\nif (remote_rp->ts_jiffies == 0)\r\nreturn xpRsvdPageNotSet;\r\nif (XPC_VERSION_MAJOR(remote_rp->version) !=\r\nXPC_VERSION_MAJOR(XPC_RP_VERSION)) {\r\nreturn xpBadVersion;\r\n}\r\nif (remote_rp->SAL_partid < 0 ||\r\nremote_rp->SAL_partid >= xp_max_npartitions ||\r\nremote_rp->max_npartitions <= xp_partition_id) {\r\nreturn xpInvalidPartid;\r\n}\r\nif (remote_rp->SAL_partid == xp_partition_id)\r\nreturn xpLocalPartid;\r\nreturn xpSuccess;\r\n}\r\nint\r\nxpc_partition_disengaged(struct xpc_partition *part)\r\n{\r\nshort partid = XPC_PARTID(part);\r\nint disengaged;\r\ndisengaged = !xpc_arch_ops.partition_engaged(partid);\r\nif (part->disengage_timeout) {\r\nif (!disengaged) {\r\nif (time_is_after_jiffies(part->disengage_timeout)) {\r\nreturn 0;\r\n}\r\ndev_info(xpc_part, "deactivate request to remote "\r\n"partition %d timed out\n", partid);\r\nxpc_disengage_timedout = 1;\r\nxpc_arch_ops.assume_partition_disengaged(partid);\r\ndisengaged = 1;\r\n}\r\npart->disengage_timeout = 0;\r\nif (!in_interrupt())\r\ndel_singleshot_timer_sync(&part->disengage_timer);\r\nDBUG_ON(part->act_state != XPC_P_AS_DEACTIVATING &&\r\npart->act_state != XPC_P_AS_INACTIVE);\r\nif (part->act_state != XPC_P_AS_INACTIVE)\r\nxpc_wakeup_channel_mgr(part);\r\nxpc_arch_ops.cancel_partition_deactivation_request(part);\r\n}\r\nreturn disengaged;\r\n}\r\nenum xp_retval\r\nxpc_mark_partition_active(struct xpc_partition *part)\r\n{\r\nunsigned long irq_flags;\r\nenum xp_retval ret;\r\ndev_dbg(xpc_part, "setting partition %d to ACTIVE\n", XPC_PARTID(part));\r\nspin_lock_irqsave(&part->act_lock, irq_flags);\r\nif (part->act_state == XPC_P_AS_ACTIVATING) {\r\npart->act_state = XPC_P_AS_ACTIVE;\r\nret = xpSuccess;\r\n} else {\r\nDBUG_ON(part->reason == xpSuccess);\r\nret = part->reason;\r\n}\r\nspin_unlock_irqrestore(&part->act_lock, irq_flags);\r\nreturn ret;\r\n}\r\nvoid\r\nxpc_deactivate_partition(const int line, struct xpc_partition *part,\r\nenum xp_retval reason)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&part->act_lock, irq_flags);\r\nif (part->act_state == XPC_P_AS_INACTIVE) {\r\nXPC_SET_REASON(part, reason, line);\r\nspin_unlock_irqrestore(&part->act_lock, irq_flags);\r\nif (reason == xpReactivating) {\r\nxpc_arch_ops.request_partition_reactivation(part);\r\n}\r\nreturn;\r\n}\r\nif (part->act_state == XPC_P_AS_DEACTIVATING) {\r\nif ((part->reason == xpUnloading && reason != xpUnloading) ||\r\nreason == xpReactivating) {\r\nXPC_SET_REASON(part, reason, line);\r\n}\r\nspin_unlock_irqrestore(&part->act_lock, irq_flags);\r\nreturn;\r\n}\r\npart->act_state = XPC_P_AS_DEACTIVATING;\r\nXPC_SET_REASON(part, reason, line);\r\nspin_unlock_irqrestore(&part->act_lock, irq_flags);\r\nxpc_arch_ops.request_partition_deactivation(part);\r\npart->disengage_timeout = jiffies + (xpc_disengage_timelimit * HZ);\r\npart->disengage_timer.expires = part->disengage_timeout;\r\nadd_timer(&part->disengage_timer);\r\ndev_dbg(xpc_part, "bringing partition %d down, reason = %d\n",\r\nXPC_PARTID(part), reason);\r\nxpc_partition_going_down(part, reason);\r\n}\r\nvoid\r\nxpc_mark_partition_inactive(struct xpc_partition *part)\r\n{\r\nunsigned long irq_flags;\r\ndev_dbg(xpc_part, "setting partition %d to INACTIVE\n",\r\nXPC_PARTID(part));\r\nspin_lock_irqsave(&part->act_lock, irq_flags);\r\npart->act_state = XPC_P_AS_INACTIVE;\r\nspin_unlock_irqrestore(&part->act_lock, irq_flags);\r\npart->remote_rp_pa = 0;\r\n}\r\nvoid\r\nxpc_discovery(void)\r\n{\r\nvoid *remote_rp_base;\r\nstruct xpc_rsvd_page *remote_rp;\r\nunsigned long remote_rp_pa;\r\nint region;\r\nint region_size;\r\nint max_regions;\r\nint nasid;\r\nstruct xpc_rsvd_page *rp;\r\nunsigned long *discovered_nasids;\r\nenum xp_retval ret;\r\nremote_rp = xpc_kmalloc_cacheline_aligned(XPC_RP_HEADER_SIZE +\r\nxpc_nasid_mask_nbytes,\r\nGFP_KERNEL, &remote_rp_base);\r\nif (remote_rp == NULL)\r\nreturn;\r\ndiscovered_nasids = kzalloc(sizeof(long) * xpc_nasid_mask_nlongs,\r\nGFP_KERNEL);\r\nif (discovered_nasids == NULL) {\r\nkfree(remote_rp_base);\r\nreturn;\r\n}\r\nrp = (struct xpc_rsvd_page *)xpc_rsvd_page;\r\nregion_size = xp_region_size;\r\nif (is_uv())\r\nmax_regions = 256;\r\nelse {\r\nmax_regions = 64;\r\nswitch (region_size) {\r\ncase 128:\r\nmax_regions *= 2;\r\ncase 64:\r\nmax_regions *= 2;\r\ncase 32:\r\nmax_regions *= 2;\r\nregion_size = 16;\r\nDBUG_ON(!is_shub2());\r\n}\r\n}\r\nfor (region = 0; region < max_regions; region++) {\r\nif (xpc_exiting)\r\nbreak;\r\ndev_dbg(xpc_part, "searching region %d\n", region);\r\nfor (nasid = (region * region_size * 2);\r\nnasid < ((region + 1) * region_size * 2); nasid += 2) {\r\nif (xpc_exiting)\r\nbreak;\r\ndev_dbg(xpc_part, "checking nasid %d\n", nasid);\r\nif (test_bit(nasid / 2, xpc_part_nasids)) {\r\ndev_dbg(xpc_part, "PROM indicates Nasid %d is "\r\n"part of the local partition; skipping "\r\n"region\n", nasid);\r\nbreak;\r\n}\r\nif (!(test_bit(nasid / 2, xpc_mach_nasids))) {\r\ndev_dbg(xpc_part, "PROM indicates Nasid %d was "\r\n"not on Numa-Link network at reset\n",\r\nnasid);\r\ncontinue;\r\n}\r\nif (test_bit(nasid / 2, discovered_nasids)) {\r\ndev_dbg(xpc_part, "Nasid %d is part of a "\r\n"partition which was previously "\r\n"discovered\n", nasid);\r\ncontinue;\r\n}\r\nret = xpc_get_remote_rp(nasid, discovered_nasids,\r\nremote_rp, &remote_rp_pa);\r\nif (ret != xpSuccess) {\r\ndev_dbg(xpc_part, "unable to get reserved page "\r\n"from nasid %d, reason=%d\n", nasid,\r\nret);\r\nif (ret == xpLocalPartid)\r\nbreak;\r\ncontinue;\r\n}\r\nxpc_arch_ops.request_partition_activation(remote_rp,\r\nremote_rp_pa, nasid);\r\n}\r\n}\r\nkfree(discovered_nasids);\r\nkfree(remote_rp_base);\r\n}\r\nenum xp_retval\r\nxpc_initiate_partid_to_nasids(short partid, void *nasid_mask)\r\n{\r\nstruct xpc_partition *part;\r\nunsigned long part_nasid_pa;\r\npart = &xpc_partitions[partid];\r\nif (part->remote_rp_pa == 0)\r\nreturn xpPartitionDown;\r\nmemset(nasid_mask, 0, xpc_nasid_mask_nbytes);\r\npart_nasid_pa = (unsigned long)XPC_RP_PART_NASIDS(part->remote_rp_pa);\r\nreturn xp_remote_memcpy(xp_pa(nasid_mask), part_nasid_pa,\r\nxpc_nasid_mask_nbytes);\r\n}
