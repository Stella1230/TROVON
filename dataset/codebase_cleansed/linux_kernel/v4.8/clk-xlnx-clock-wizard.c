static int clk_wzrd_clk_notifier(struct notifier_block *nb, unsigned long event,\r\nvoid *data)\r\n{\r\nunsigned long max;\r\nstruct clk_notifier_data *ndata = data;\r\nstruct clk_wzrd *clk_wzrd = to_clk_wzrd(nb);\r\nif (clk_wzrd->suspended)\r\nreturn NOTIFY_OK;\r\nif (ndata->clk == clk_wzrd->clk_in1)\r\nmax = clk_wzrd_max_freq[clk_wzrd->speed_grade - 1];\r\nelse if (ndata->clk == clk_wzrd->axi_clk)\r\nmax = WZRD_ACLK_MAX_FREQ;\r\nelse\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase PRE_RATE_CHANGE:\r\nif (ndata->new_rate > max)\r\nreturn NOTIFY_BAD;\r\nreturn NOTIFY_OK;\r\ncase POST_RATE_CHANGE:\r\ncase ABORT_RATE_CHANGE:\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nstatic int __maybe_unused clk_wzrd_suspend(struct device *dev)\r\n{\r\nstruct clk_wzrd *clk_wzrd = dev_get_drvdata(dev);\r\nclk_disable_unprepare(clk_wzrd->axi_clk);\r\nclk_wzrd->suspended = true;\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused clk_wzrd_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct clk_wzrd *clk_wzrd = dev_get_drvdata(dev);\r\nret = clk_prepare_enable(clk_wzrd->axi_clk);\r\nif (ret) {\r\ndev_err(dev, "unable to enable s_axi_aclk\n");\r\nreturn ret;\r\n}\r\nclk_wzrd->suspended = false;\r\nreturn 0;\r\n}\r\nstatic int clk_wzrd_probe(struct platform_device *pdev)\r\n{\r\nint i, ret;\r\nu32 reg;\r\nunsigned long rate;\r\nconst char *clk_name;\r\nstruct clk_wzrd *clk_wzrd;\r\nstruct resource *mem;\r\nstruct device_node *np = pdev->dev.of_node;\r\nclk_wzrd = devm_kzalloc(&pdev->dev, sizeof(*clk_wzrd), GFP_KERNEL);\r\nif (!clk_wzrd)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, clk_wzrd);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nclk_wzrd->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(clk_wzrd->base))\r\nreturn PTR_ERR(clk_wzrd->base);\r\nret = of_property_read_u32(np, "speed-grade", &clk_wzrd->speed_grade);\r\nif (!ret) {\r\nif (clk_wzrd->speed_grade < 1 || clk_wzrd->speed_grade > 3) {\r\ndev_warn(&pdev->dev, "invalid speed grade '%d'\n",\r\nclk_wzrd->speed_grade);\r\nclk_wzrd->speed_grade = 0;\r\n}\r\n}\r\nclk_wzrd->clk_in1 = devm_clk_get(&pdev->dev, "clk_in1");\r\nif (IS_ERR(clk_wzrd->clk_in1)) {\r\nif (clk_wzrd->clk_in1 != ERR_PTR(-EPROBE_DEFER))\r\ndev_err(&pdev->dev, "clk_in1 not found\n");\r\nreturn PTR_ERR(clk_wzrd->clk_in1);\r\n}\r\nclk_wzrd->axi_clk = devm_clk_get(&pdev->dev, "s_axi_aclk");\r\nif (IS_ERR(clk_wzrd->axi_clk)) {\r\nif (clk_wzrd->axi_clk != ERR_PTR(-EPROBE_DEFER))\r\ndev_err(&pdev->dev, "s_axi_aclk not found\n");\r\nreturn PTR_ERR(clk_wzrd->axi_clk);\r\n}\r\nret = clk_prepare_enable(clk_wzrd->axi_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "enabling s_axi_aclk failed\n");\r\nreturn ret;\r\n}\r\nrate = clk_get_rate(clk_wzrd->axi_clk);\r\nif (rate > WZRD_ACLK_MAX_FREQ) {\r\ndev_err(&pdev->dev, "s_axi_aclk frequency (%lu) too high\n",\r\nrate);\r\nret = -EINVAL;\r\ngoto err_disable_clk;\r\n}\r\nreg = readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0)) &\r\nWZRD_CLKFBOUT_FRAC_EN;\r\nreg |= readl(clk_wzrd->base + WZRD_CLK_CFG_REG(2)) &\r\nWZRD_CLKOUT0_FRAC_EN;\r\nif (reg)\r\ndev_warn(&pdev->dev, "fractional div/mul not supported\n");\r\nreg = (readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0)) &\r\nWZRD_CLKFBOUT_MULT_MASK) >> WZRD_CLKFBOUT_MULT_SHIFT;\r\nclk_name = kasprintf(GFP_KERNEL, "%s_mul", dev_name(&pdev->dev));\r\nif (!clk_name) {\r\nret = -ENOMEM;\r\ngoto err_disable_clk;\r\n}\r\nclk_wzrd->clks_internal[wzrd_clk_mul] = clk_register_fixed_factor(\r\n&pdev->dev, clk_name,\r\n__clk_get_name(clk_wzrd->clk_in1),\r\n0, reg, 1);\r\nkfree(clk_name);\r\nif (IS_ERR(clk_wzrd->clks_internal[wzrd_clk_mul])) {\r\ndev_err(&pdev->dev, "unable to register fixed-factor clock\n");\r\nret = PTR_ERR(clk_wzrd->clks_internal[wzrd_clk_mul]);\r\ngoto err_disable_clk;\r\n}\r\nreg = (readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0)) &\r\nWZRD_DIVCLK_DIVIDE_MASK) >> WZRD_DIVCLK_DIVIDE_SHIFT;\r\nclk_name = kasprintf(GFP_KERNEL, "%s_mul_div", dev_name(&pdev->dev));\r\nif (!clk_name) {\r\nret = -ENOMEM;\r\ngoto err_rm_int_clk;\r\n}\r\nclk_wzrd->clks_internal[wzrd_clk_mul_div] = clk_register_fixed_factor(\r\n&pdev->dev, clk_name,\r\n__clk_get_name(clk_wzrd->clks_internal[wzrd_clk_mul]),\r\n0, 1, reg);\r\nif (IS_ERR(clk_wzrd->clks_internal[wzrd_clk_mul_div])) {\r\ndev_err(&pdev->dev, "unable to register divider clock\n");\r\nret = PTR_ERR(clk_wzrd->clks_internal[wzrd_clk_mul_div]);\r\ngoto err_rm_int_clk;\r\n}\r\nfor (i = WZRD_NUM_OUTPUTS - 1; i >= 0 ; i--) {\r\nconst char *clkout_name;\r\nif (of_property_read_string_index(np, "clock-output-names", i,\r\n&clkout_name)) {\r\ndev_err(&pdev->dev,\r\n"clock output name not specified\n");\r\nret = -EINVAL;\r\ngoto err_rm_int_clks;\r\n}\r\nreg = readl(clk_wzrd->base + WZRD_CLK_CFG_REG(2) + i * 12);\r\nreg &= WZRD_CLKOUT_DIVIDE_MASK;\r\nreg >>= WZRD_CLKOUT_DIVIDE_SHIFT;\r\nclk_wzrd->clkout[i] = clk_register_fixed_factor(&pdev->dev,\r\nclkout_name, clk_name, 0, 1, reg);\r\nif (IS_ERR(clk_wzrd->clkout[i])) {\r\nint j;\r\nfor (j = i + 1; j < WZRD_NUM_OUTPUTS; j++)\r\nclk_unregister(clk_wzrd->clkout[j]);\r\ndev_err(&pdev->dev,\r\n"unable to register divider clock\n");\r\nret = PTR_ERR(clk_wzrd->clkout[i]);\r\ngoto err_rm_int_clks;\r\n}\r\n}\r\nkfree(clk_name);\r\nclk_wzrd->clk_data.clks = clk_wzrd->clkout;\r\nclk_wzrd->clk_data.clk_num = ARRAY_SIZE(clk_wzrd->clkout);\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &clk_wzrd->clk_data);\r\nif (clk_wzrd->speed_grade) {\r\nclk_wzrd->nb.notifier_call = clk_wzrd_clk_notifier;\r\nret = clk_notifier_register(clk_wzrd->clk_in1,\r\n&clk_wzrd->nb);\r\nif (ret)\r\ndev_warn(&pdev->dev,\r\n"unable to register clock notifier\n");\r\nret = clk_notifier_register(clk_wzrd->axi_clk, &clk_wzrd->nb);\r\nif (ret)\r\ndev_warn(&pdev->dev,\r\n"unable to register clock notifier\n");\r\n}\r\nreturn 0;\r\nerr_rm_int_clks:\r\nclk_unregister(clk_wzrd->clks_internal[1]);\r\nerr_rm_int_clk:\r\nkfree(clk_name);\r\nclk_unregister(clk_wzrd->clks_internal[0]);\r\nerr_disable_clk:\r\nclk_disable_unprepare(clk_wzrd->axi_clk);\r\nreturn ret;\r\n}\r\nstatic int clk_wzrd_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct clk_wzrd *clk_wzrd = platform_get_drvdata(pdev);\r\nof_clk_del_provider(pdev->dev.of_node);\r\nfor (i = 0; i < WZRD_NUM_OUTPUTS; i++)\r\nclk_unregister(clk_wzrd->clkout[i]);\r\nfor (i = 0; i < wzrd_clk_int_max; i++)\r\nclk_unregister(clk_wzrd->clks_internal[i]);\r\nif (clk_wzrd->speed_grade) {\r\nclk_notifier_unregister(clk_wzrd->axi_clk, &clk_wzrd->nb);\r\nclk_notifier_unregister(clk_wzrd->clk_in1, &clk_wzrd->nb);\r\n}\r\nclk_disable_unprepare(clk_wzrd->axi_clk);\r\nreturn 0;\r\n}
