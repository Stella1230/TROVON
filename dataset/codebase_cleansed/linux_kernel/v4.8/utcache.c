acpi_status\r\nacpi_os_create_cache(char *cache_name,\r\nu16 object_size,\r\nu16 max_depth, struct acpi_memory_list **return_cache)\r\n{\r\nstruct acpi_memory_list *cache;\r\nACPI_FUNCTION_ENTRY();\r\nif (!cache_name || !return_cache || (object_size < 16)) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\ncache = acpi_os_allocate(sizeof(struct acpi_memory_list));\r\nif (!cache) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nmemset(cache, 0, sizeof(struct acpi_memory_list));\r\ncache->list_name = cache_name;\r\ncache->object_size = object_size;\r\ncache->max_depth = max_depth;\r\n*return_cache = cache;\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_purge_cache(struct acpi_memory_list *cache)\r\n{\r\nvoid *next;\r\nacpi_status status;\r\nACPI_FUNCTION_ENTRY();\r\nif (!cache) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nwhile (cache->list_head) {\r\nnext = ACPI_GET_DESCRIPTOR_PTR(cache->list_head);\r\nACPI_FREE(cache->list_head);\r\ncache->list_head = next;\r\ncache->current_depth--;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_delete_cache(struct acpi_memory_list *cache)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_ENTRY();\r\nstatus = acpi_os_purge_cache(cache);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nacpi_os_free(cache);\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_release_object(struct acpi_memory_list *cache, void *object)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_ENTRY();\r\nif (!cache || !object) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nif (cache->current_depth >= cache->max_depth) {\r\nACPI_FREE(object);\r\nACPI_MEM_TRACKING(cache->total_freed++);\r\n}\r\nelse {\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nmemset(object, 0xCA, cache->object_size);\r\nACPI_SET_DESCRIPTOR_TYPE(object, ACPI_DESC_TYPE_CACHED);\r\nACPI_SET_DESCRIPTOR_PTR(object, cache->list_head);\r\ncache->list_head = object;\r\ncache->current_depth++;\r\n(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);\r\n}\r\nreturn (AE_OK);\r\n}\r\nvoid *acpi_os_acquire_object(struct acpi_memory_list *cache)\r\n{\r\nacpi_status status;\r\nvoid *object;\r\nACPI_FUNCTION_TRACE(os_acquire_object);\r\nif (!cache) {\r\nreturn_PTR(NULL);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_PTR(NULL);\r\n}\r\nACPI_MEM_TRACKING(cache->requests++);\r\nif (cache->list_head) {\r\nobject = cache->list_head;\r\ncache->list_head = ACPI_GET_DESCRIPTOR_PTR(object);\r\ncache->current_depth--;\r\nACPI_MEM_TRACKING(cache->hits++);\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Object %p from %s cache\n", object,\r\ncache->list_name));\r\nstatus = acpi_ut_release_mutex(ACPI_MTX_CACHES);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_PTR(NULL);\r\n}\r\nmemset(object, 0, cache->object_size);\r\n} else {\r\nACPI_MEM_TRACKING(cache->total_allocated++);\r\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\r\nif ((cache->total_allocated - cache->total_freed) >\r\ncache->max_occupied) {\r\ncache->max_occupied =\r\ncache->total_allocated - cache->total_freed;\r\n}\r\n#endif\r\nstatus = acpi_ut_release_mutex(ACPI_MTX_CACHES);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_PTR(NULL);\r\n}\r\nobject = ACPI_ALLOCATE_ZEROED(cache->object_size);\r\nif (!object) {\r\nreturn_PTR(NULL);\r\n}\r\n}\r\nreturn_PTR(object);\r\n}
