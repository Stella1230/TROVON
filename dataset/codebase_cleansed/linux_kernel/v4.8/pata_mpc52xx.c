static int\r\nmpc52xx_ata_compute_pio_timings(struct mpc52xx_ata_priv *priv, int dev, int pio)\r\n{\r\nstruct mpc52xx_ata_timings *timing = &priv->timings[dev];\r\nunsigned int ipb_period = priv->ipb_period;\r\nu32 t0, t1, t2_8, t2_16, t2i, t4, ta;\r\nif ((pio < 0) || (pio > 4))\r\nreturn -EINVAL;\r\nt0 = CALC_CLKCYC(ipb_period, 1000 * ataspec_t0[pio]);\r\nt1 = CALC_CLKCYC(ipb_period, 1000 * ataspec_t1[pio]);\r\nt2_8 = CALC_CLKCYC(ipb_period, 1000 * ataspec_t2_8[pio]);\r\nt2_16 = CALC_CLKCYC(ipb_period, 1000 * ataspec_t2_16[pio]);\r\nt2i = CALC_CLKCYC(ipb_period, 1000 * ataspec_t2i[pio]);\r\nt4 = CALC_CLKCYC(ipb_period, 1000 * ataspec_t4[pio]);\r\nta = CALC_CLKCYC(ipb_period, 1000 * ataspec_ta[pio]);\r\ntiming->pio1 = (t0 << 24) | (t2_8 << 16) | (t2_16 << 8) | (t2i);\r\ntiming->pio2 = (t4 << 24) | (t1 << 16) | (ta << 8);\r\nreturn 0;\r\n}\r\nstatic int\r\nmpc52xx_ata_compute_mdma_timings(struct mpc52xx_ata_priv *priv, int dev,\r\nint speed)\r\n{\r\nstruct mpc52xx_ata_timings *t = &priv->timings[dev];\r\nconst struct mdmaspec *s = &priv->mdmaspec[speed];\r\nif (speed < 0 || speed > 2)\r\nreturn -EINVAL;\r\nt->mdma1 = ((u32)s->t0M << 24) | ((u32)s->td << 16) | ((u32)s->tkw << 8) | s->tm;\r\nt->mdma2 = ((u32)s->th << 24) | ((u32)s->tj << 16) | ((u32)s->tn << 8);\r\nt->using_udma = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nmpc52xx_ata_compute_udma_timings(struct mpc52xx_ata_priv *priv, int dev,\r\nint speed)\r\n{\r\nstruct mpc52xx_ata_timings *t = &priv->timings[dev];\r\nconst struct udmaspec *s = &priv->udmaspec[speed];\r\nif (speed < 0 || speed > 2)\r\nreturn -EINVAL;\r\nt->udma1 = ((u32)s->t2cyc << 24) | ((u32)s->tcyc << 16) | ((u32)s->tds << 8) | s->tdh;\r\nt->udma2 = ((u32)s->tdvs << 24) | ((u32)s->tdvh << 16) | ((u32)s->tfs << 8) | s->tli;\r\nt->udma3 = ((u32)s->tmli << 24) | ((u32)s->taz << 16) | ((u32)s->tenv << 8) | s->tsr;\r\nt->udma4 = ((u32)s->tss << 24) | ((u32)s->trfs << 16) | ((u32)s->trp << 8) | s->tack;\r\nt->udma5 = (u32)s->tzah << 24;\r\nt->using_udma = 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nmpc52xx_ata_apply_timings(struct mpc52xx_ata_priv *priv, int device)\r\n{\r\nstruct mpc52xx_ata __iomem *regs = priv->ata_regs;\r\nstruct mpc52xx_ata_timings *timing = &priv->timings[device];\r\nout_be32(&regs->pio1, timing->pio1);\r\nout_be32(&regs->pio2, timing->pio2);\r\nout_be32(&regs->mdma1, timing->mdma1);\r\nout_be32(&regs->mdma2, timing->mdma2);\r\nout_be32(&regs->udma1, timing->udma1);\r\nout_be32(&regs->udma2, timing->udma2);\r\nout_be32(&regs->udma3, timing->udma3);\r\nout_be32(&regs->udma4, timing->udma4);\r\nout_be32(&regs->udma5, timing->udma5);\r\npriv->csel = device;\r\n}\r\nstatic int\r\nmpc52xx_ata_hw_init(struct mpc52xx_ata_priv *priv)\r\n{\r\nstruct mpc52xx_ata __iomem *regs = priv->ata_regs;\r\nint tslot;\r\nout_be32(&regs->share_cnt, 0);\r\nout_be32(&regs->config,\r\nMPC52xx_ATA_HOSTCONF_IE |\r\nMPC52xx_ATA_HOSTCONF_IORDY |\r\nMPC52xx_ATA_HOSTCONF_SMR |\r\nMPC52xx_ATA_HOSTCONF_FR);\r\nudelay(10);\r\nout_be32(&regs->config,\r\nMPC52xx_ATA_HOSTCONF_IE |\r\nMPC52xx_ATA_HOSTCONF_IORDY);\r\ntslot = CALC_CLKCYC(priv->ipb_period, 1000000);\r\nout_be32(&regs->share_cnt, tslot << 16);\r\nmemset(priv->timings, 0x00, 2*sizeof(struct mpc52xx_ata_timings));\r\nmpc52xx_ata_compute_pio_timings(priv, 0, 0);\r\nmpc52xx_ata_compute_pio_timings(priv, 1, 0);\r\nmpc52xx_ata_apply_timings(priv, 0);\r\nreturn 0;\r\n}\r\nstatic void\r\nmpc52xx_ata_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct mpc52xx_ata_priv *priv = ap->host->private_data;\r\nint pio, rv;\r\npio = adev->pio_mode - XFER_PIO_0;\r\nrv = mpc52xx_ata_compute_pio_timings(priv, adev->devno, pio);\r\nif (rv) {\r\ndev_err(ap->dev, "error: invalid PIO mode: %d\n", pio);\r\nreturn;\r\n}\r\nmpc52xx_ata_apply_timings(priv, adev->devno);\r\n}\r\nstatic void\r\nmpc52xx_ata_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct mpc52xx_ata_priv *priv = ap->host->private_data;\r\nint rv;\r\nif (adev->dma_mode >= XFER_UDMA_0) {\r\nint dma = adev->dma_mode - XFER_UDMA_0;\r\nrv = mpc52xx_ata_compute_udma_timings(priv, adev->devno, dma);\r\n} else {\r\nint dma = adev->dma_mode - XFER_MW_DMA_0;\r\nrv = mpc52xx_ata_compute_mdma_timings(priv, adev->devno, dma);\r\n}\r\nif (rv) {\r\ndev_alert(ap->dev,\r\n"Trying to select invalid DMA mode %d\n",\r\nadev->dma_mode);\r\nreturn;\r\n}\r\nmpc52xx_ata_apply_timings(priv, adev->devno);\r\n}\r\nstatic void\r\nmpc52xx_ata_dev_select(struct ata_port *ap, unsigned int device)\r\n{\r\nstruct mpc52xx_ata_priv *priv = ap->host->private_data;\r\nif (device != priv->csel)\r\nmpc52xx_ata_apply_timings(priv, device);\r\nata_sff_dev_select(ap, device);\r\n}\r\nstatic int\r\nmpc52xx_ata_build_dmatable(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct mpc52xx_ata_priv *priv = ap->host->private_data;\r\nstruct bcom_ata_bd *bd;\r\nunsigned int read = !(qc->tf.flags & ATA_TFLAG_WRITE), si;\r\nstruct scatterlist *sg;\r\nint count = 0;\r\nif (read)\r\nbcom_ata_rx_prepare(priv->dmatsk);\r\nelse\r\nbcom_ata_tx_prepare(priv->dmatsk);\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si) {\r\ndma_addr_t cur_addr = sg_dma_address(sg);\r\nu32 cur_len = sg_dma_len(sg);\r\nwhile (cur_len) {\r\nunsigned int tc = min(cur_len, MAX_DMA_BUFFER_SIZE);\r\nbd = (struct bcom_ata_bd *)\r\nbcom_prepare_next_buffer(priv->dmatsk);\r\nif (read) {\r\nbd->status = tc;\r\nbd->src_pa = (__force u32) priv->ata_regs_pa +\r\noffsetof(struct mpc52xx_ata, fifo_data);\r\nbd->dst_pa = (__force u32) cur_addr;\r\n} else {\r\nbd->status = tc;\r\nbd->src_pa = (__force u32) cur_addr;\r\nbd->dst_pa = (__force u32) priv->ata_regs_pa +\r\noffsetof(struct mpc52xx_ata, fifo_data);\r\n}\r\nbcom_submit_next_buffer(priv->dmatsk, NULL);\r\ncur_addr += tc;\r\ncur_len -= tc;\r\ncount++;\r\nif (count > MAX_DMA_BUFFERS) {\r\ndev_alert(ap->dev, "dma table"\r\n"too small\n");\r\ngoto use_pio_instead;\r\n}\r\n}\r\n}\r\nreturn 1;\r\nuse_pio_instead:\r\nbcom_ata_reset_bd(priv->dmatsk);\r\nreturn 0;\r\n}\r\nstatic void\r\nmpc52xx_bmdma_setup(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct mpc52xx_ata_priv *priv = ap->host->private_data;\r\nstruct mpc52xx_ata __iomem *regs = priv->ata_regs;\r\nunsigned int read = !(qc->tf.flags & ATA_TFLAG_WRITE);\r\nu8 dma_mode;\r\nif (!mpc52xx_ata_build_dmatable(qc))\r\ndev_alert(ap->dev, "%s: %i, return 1?\n",\r\n__func__, __LINE__);\r\nif (in_8(&priv->ata_regs->fifo_status) & MPC52xx_ATA_FIFOSTAT_ERROR)\r\ndev_alert(ap->dev, "%s: FIFO error detected: 0x%02x!\n",\r\n__func__, in_8(&priv->ata_regs->fifo_status));\r\nif (read) {\r\ndma_mode = MPC52xx_ATA_DMAMODE_IE | MPC52xx_ATA_DMAMODE_READ |\r\nMPC52xx_ATA_DMAMODE_FE;\r\nif (priv->mpc52xx_ata_dma_last_write != 0) {\r\npriv->mpc52xx_ata_dma_last_write = 0;\r\nout_8(&regs->fifo_control, 7);\r\nout_be16(&regs->fifo_alarm, 128);\r\nout_8(&regs->dma_mode, MPC52xx_ATA_DMAMODE_FR);\r\n}\r\n} else {\r\ndma_mode = MPC52xx_ATA_DMAMODE_IE | MPC52xx_ATA_DMAMODE_WRITE;\r\nif (priv->mpc52xx_ata_dma_last_write != 1) {\r\npriv->mpc52xx_ata_dma_last_write = 1;\r\nout_8(&regs->fifo_control, 4);\r\nout_be16(&regs->fifo_alarm, 128);\r\n}\r\n}\r\nif (priv->timings[qc->dev->devno].using_udma)\r\ndma_mode |= MPC52xx_ATA_DMAMODE_UDMA;\r\nout_8(&regs->dma_mode, dma_mode);\r\npriv->waiting_for_dma = ATA_DMA_ACTIVE;\r\nata_wait_idle(ap);\r\nap->ops->sff_exec_command(ap, &qc->tf);\r\n}\r\nstatic void\r\nmpc52xx_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct mpc52xx_ata_priv *priv = ap->host->private_data;\r\nbcom_set_task_auto_start(priv->dmatsk->tasknum, priv->dmatsk->tasknum);\r\nbcom_enable(priv->dmatsk);\r\n}\r\nstatic void\r\nmpc52xx_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct mpc52xx_ata_priv *priv = ap->host->private_data;\r\nbcom_disable(priv->dmatsk);\r\nbcom_ata_reset_bd(priv->dmatsk);\r\npriv->waiting_for_dma = 0;\r\nif (in_8(&priv->ata_regs->fifo_status) & MPC52xx_ATA_FIFOSTAT_ERROR)\r\ndev_alert(ap->dev, "%s: FIFO error detected: 0x%02x!\n",\r\n__func__, in_8(&priv->ata_regs->fifo_status));\r\n}\r\nstatic u8\r\nmpc52xx_bmdma_status(struct ata_port *ap)\r\n{\r\nstruct mpc52xx_ata_priv *priv = ap->host->private_data;\r\nif (in_8(&priv->ata_regs->fifo_status) & MPC52xx_ATA_FIFOSTAT_ERROR) {\r\ndev_alert(ap->dev, "%s: FIFO error detected: 0x%02x!\n",\r\n__func__, in_8(&priv->ata_regs->fifo_status));\r\nreturn priv->waiting_for_dma | ATA_DMA_ERR;\r\n}\r\nreturn priv->waiting_for_dma;\r\n}\r\nstatic irqreturn_t\r\nmpc52xx_ata_task_irq(int irq, void *vpriv)\r\n{\r\nstruct mpc52xx_ata_priv *priv = vpriv;\r\nwhile (bcom_buffer_done(priv->dmatsk))\r\nbcom_retrieve_buffer(priv->dmatsk, NULL, NULL);\r\npriv->waiting_for_dma |= ATA_DMA_INTR;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mpc52xx_ata_init_one(struct device *dev,\r\nstruct mpc52xx_ata_priv *priv,\r\nunsigned long raw_ata_regs,\r\nint mwdma_mask, int udma_mask)\r\n{\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nstruct ata_ioports *aio;\r\nhost = ata_host_alloc(dev, 1);\r\nif (!host)\r\nreturn -ENOMEM;\r\nap = host->ports[0];\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\nap->pio_mask = ATA_PIO4;\r\nap->mwdma_mask = mwdma_mask;\r\nap->udma_mask = udma_mask;\r\nap->ops = &mpc52xx_ata_port_ops;\r\nhost->private_data = priv;\r\naio = &ap->ioaddr;\r\naio->cmd_addr = NULL;\r\naio->altstatus_addr = &priv->ata_regs->tf_control;\r\naio->ctl_addr = &priv->ata_regs->tf_control;\r\naio->data_addr = &priv->ata_regs->tf_data;\r\naio->error_addr = &priv->ata_regs->tf_features;\r\naio->feature_addr = &priv->ata_regs->tf_features;\r\naio->nsect_addr = &priv->ata_regs->tf_sec_count;\r\naio->lbal_addr = &priv->ata_regs->tf_sec_num;\r\naio->lbam_addr = &priv->ata_regs->tf_cyl_low;\r\naio->lbah_addr = &priv->ata_regs->tf_cyl_high;\r\naio->device_addr = &priv->ata_regs->tf_dev_head;\r\naio->status_addr = &priv->ata_regs->tf_command;\r\naio->command_addr = &priv->ata_regs->tf_command;\r\nata_port_desc(ap, "ata_regs 0x%lx", raw_ata_regs);\r\nreturn ata_host_activate(host, priv->ata_irq, ata_bmdma_interrupt, 0,\r\n&mpc52xx_ata_sht);\r\n}\r\nstatic int mpc52xx_ata_probe(struct platform_device *op)\r\n{\r\nunsigned int ipb_freq;\r\nstruct resource res_mem;\r\nint ata_irq = 0;\r\nstruct mpc52xx_ata __iomem *ata_regs;\r\nstruct mpc52xx_ata_priv *priv = NULL;\r\nint rv, task_irq;\r\nint mwdma_mask = 0, udma_mask = 0;\r\nconst __be32 *prop;\r\nint proplen;\r\nstruct bcom_task *dmatsk;\r\nipb_freq = mpc5xxx_get_bus_frequency(op->dev.of_node);\r\nif (!ipb_freq) {\r\ndev_err(&op->dev, "could not determine IPB bus frequency\n");\r\nreturn -ENODEV;\r\n}\r\nrv = of_address_to_resource(op->dev.of_node, 0, &res_mem);\r\nif (rv) {\r\ndev_err(&op->dev, "could not determine device base address\n");\r\nreturn rv;\r\n}\r\nif (!devm_request_mem_region(&op->dev, res_mem.start,\r\nsizeof(*ata_regs), DRV_NAME)) {\r\ndev_err(&op->dev, "error requesting register region\n");\r\nreturn -EBUSY;\r\n}\r\nata_regs = devm_ioremap(&op->dev, res_mem.start, sizeof(*ata_regs));\r\nif (!ata_regs) {\r\ndev_err(&op->dev, "error mapping device registers\n");\r\nreturn -ENOMEM;\r\n}\r\nprop = of_get_property(op->dev.of_node, "mwdma-mode", &proplen);\r\nif ((prop) && (proplen >= 4))\r\nmwdma_mask = ATA_MWDMA2 & ((1 << (*prop + 1)) - 1);\r\nprop = of_get_property(op->dev.of_node, "udma-mode", &proplen);\r\nif ((prop) && (proplen >= 4))\r\nudma_mask = ATA_UDMA2 & ((1 << (*prop + 1)) - 1);\r\nata_irq = irq_of_parse_and_map(op->dev.of_node, 0);\r\nif (ata_irq == NO_IRQ) {\r\ndev_err(&op->dev, "error mapping irq\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(&op->dev, sizeof(*priv), GFP_ATOMIC);\r\nif (!priv) {\r\ndev_err(&op->dev, "error allocating private structure\n");\r\nrv = -ENOMEM;\r\ngoto err1;\r\n}\r\npriv->ipb_period = 1000000000 / (ipb_freq / 1000);\r\npriv->ata_regs = ata_regs;\r\npriv->ata_regs_pa = res_mem.start;\r\npriv->ata_irq = ata_irq;\r\npriv->csel = -1;\r\npriv->mpc52xx_ata_dma_last_write = -1;\r\nif (ipb_freq/1000000 == 66) {\r\npriv->mdmaspec = mdmaspec66;\r\npriv->udmaspec = udmaspec66;\r\n} else {\r\npriv->mdmaspec = mdmaspec132;\r\npriv->udmaspec = udmaspec132;\r\n}\r\ndmatsk = bcom_ata_init(MAX_DMA_BUFFERS, MAX_DMA_BUFFER_SIZE);\r\nif (!dmatsk) {\r\ndev_err(&op->dev, "bestcomm initialization failed\n");\r\nrv = -ENOMEM;\r\ngoto err1;\r\n}\r\ntask_irq = bcom_get_task_irq(dmatsk);\r\nrv = devm_request_irq(&op->dev, task_irq, &mpc52xx_ata_task_irq, 0,\r\n"ATA task", priv);\r\nif (rv) {\r\ndev_err(&op->dev, "error requesting DMA IRQ\n");\r\ngoto err2;\r\n}\r\npriv->dmatsk = dmatsk;\r\nrv = mpc52xx_ata_hw_init(priv);\r\nif (rv) {\r\ndev_err(&op->dev, "error initializing hardware\n");\r\ngoto err2;\r\n}\r\nrv = mpc52xx_ata_init_one(&op->dev, priv, res_mem.start,\r\nmwdma_mask, udma_mask);\r\nif (rv) {\r\ndev_err(&op->dev, "error registering with ATA layer\n");\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nirq_dispose_mapping(task_irq);\r\nbcom_ata_release(dmatsk);\r\nerr1:\r\nirq_dispose_mapping(ata_irq);\r\nreturn rv;\r\n}\r\nstatic int\r\nmpc52xx_ata_remove(struct platform_device *op)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(op);\r\nstruct mpc52xx_ata_priv *priv = host->private_data;\r\nint task_irq;\r\nata_platform_remove_one(op);\r\ntask_irq = bcom_get_task_irq(priv->dmatsk);\r\nirq_dispose_mapping(task_irq);\r\nbcom_ata_release(priv->dmatsk);\r\nirq_dispose_mapping(priv->ata_irq);\r\nreturn 0;\r\n}\r\nstatic int\r\nmpc52xx_ata_suspend(struct platform_device *op, pm_message_t state)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(op);\r\nreturn ata_host_suspend(host, state);\r\n}\r\nstatic int\r\nmpc52xx_ata_resume(struct platform_device *op)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(op);\r\nstruct mpc52xx_ata_priv *priv = host->private_data;\r\nint rv;\r\nrv = mpc52xx_ata_hw_init(priv);\r\nif (rv) {\r\ndev_err(host->dev, "error initializing hardware\n");\r\nreturn rv;\r\n}\r\nata_host_resume(host);\r\nreturn 0;\r\n}
