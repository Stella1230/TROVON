static int is_fs_or_ls(enum usb_device_speed speed)\r\n{\r\nreturn speed == USB_SPEED_FULL || speed == USB_SPEED_LOW;\r\n}\r\nstatic int get_bw_index(struct xhci_hcd *xhci, struct usb_device *udev,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct xhci_virt_device *virt_dev;\r\nint bw_index;\r\nvirt_dev = xhci->devs[udev->slot_id];\r\nif (udev->speed == USB_SPEED_SUPER) {\r\nif (usb_endpoint_dir_out(&ep->desc))\r\nbw_index = (virt_dev->real_port - 1) * 2;\r\nelse\r\nbw_index = (virt_dev->real_port - 1) * 2 + 1;\r\n} else {\r\nbw_index = virt_dev->real_port + xhci->num_usb3_ports - 1;\r\n}\r\nreturn bw_index;\r\n}\r\nstatic void setup_sch_info(struct usb_device *udev,\r\nstruct xhci_ep_ctx *ep_ctx, struct mu3h_sch_ep_info *sch_ep)\r\n{\r\nu32 ep_type;\r\nu32 ep_interval;\r\nu32 max_packet_size;\r\nu32 max_burst;\r\nu32 mult;\r\nu32 esit_pkts;\r\nep_type = CTX_TO_EP_TYPE(le32_to_cpu(ep_ctx->ep_info2));\r\nep_interval = CTX_TO_EP_INTERVAL(le32_to_cpu(ep_ctx->ep_info));\r\nmax_packet_size = MAX_PACKET_DECODED(le32_to_cpu(ep_ctx->ep_info2));\r\nmax_burst = CTX_TO_MAX_BURST(le32_to_cpu(ep_ctx->ep_info2));\r\nmult = CTX_TO_EP_MULT(le32_to_cpu(ep_ctx->ep_info));\r\nsch_ep->esit = 1 << ep_interval;\r\nsch_ep->offset = 0;\r\nsch_ep->burst_mode = 0;\r\nif (udev->speed == USB_SPEED_HIGH) {\r\nsch_ep->cs_count = 0;\r\nsch_ep->num_budget_microframes = 1;\r\nsch_ep->repeat = 0;\r\nsch_ep->pkts = max_burst + 1;\r\nsch_ep->bw_cost_per_microframe = max_packet_size * sch_ep->pkts;\r\n} else if (udev->speed == USB_SPEED_SUPER) {\r\nsch_ep->cs_count = 0;\r\nesit_pkts = (mult + 1) * (max_burst + 1);\r\nif (ep_type == INT_IN_EP || ep_type == INT_OUT_EP) {\r\nsch_ep->pkts = esit_pkts;\r\nsch_ep->num_budget_microframes = 1;\r\nsch_ep->repeat = 0;\r\n}\r\nif (ep_type == ISOC_IN_EP || ep_type == ISOC_OUT_EP) {\r\nif (esit_pkts <= sch_ep->esit)\r\nsch_ep->pkts = 1;\r\nelse\r\nsch_ep->pkts = roundup_pow_of_two(esit_pkts)\r\n/ sch_ep->esit;\r\nsch_ep->num_budget_microframes =\r\nDIV_ROUND_UP(esit_pkts, sch_ep->pkts);\r\nif (sch_ep->num_budget_microframes > 1)\r\nsch_ep->repeat = 1;\r\nelse\r\nsch_ep->repeat = 0;\r\n}\r\nsch_ep->bw_cost_per_microframe = max_packet_size * sch_ep->pkts;\r\n} else if (is_fs_or_ls(udev->speed)) {\r\nsch_ep->repeat = 0;\r\nsch_ep->pkts = 1;\r\nif (ep_type == INT_IN_EP || ep_type == INT_OUT_EP) {\r\nsch_ep->cs_count = 3;\r\nsch_ep->num_budget_microframes = sch_ep->cs_count + 2;\r\nsch_ep->bw_cost_per_microframe = max_packet_size;\r\n}\r\nif (ep_type == ISOC_OUT_EP) {\r\nsch_ep->num_budget_microframes = DIV_ROUND_UP(\r\nmax_packet_size, FS_PAYLOAD_MAX);\r\nsch_ep->bw_cost_per_microframe = FS_PAYLOAD_MAX;\r\nsch_ep->cs_count = sch_ep->num_budget_microframes;\r\n}\r\nif (ep_type == ISOC_IN_EP) {\r\nsch_ep->cs_count = DIV_ROUND_UP(\r\nmax_packet_size, FS_PAYLOAD_MAX) + 2;\r\nsch_ep->num_budget_microframes = sch_ep->cs_count + 2;\r\nsch_ep->bw_cost_per_microframe = FS_PAYLOAD_MAX;\r\n}\r\n}\r\n}\r\nstatic u32 get_max_bw(struct mu3h_sch_bw_info *sch_bw,\r\nstruct mu3h_sch_ep_info *sch_ep, u32 offset)\r\n{\r\nu32 num_esit;\r\nu32 max_bw = 0;\r\nint i;\r\nint j;\r\nnum_esit = XHCI_MTK_MAX_ESIT / sch_ep->esit;\r\nfor (i = 0; i < num_esit; i++) {\r\nu32 base = offset + i * sch_ep->esit;\r\nfor (j = 0; j < sch_ep->num_budget_microframes; j++) {\r\nif (sch_bw->bus_bw[base + j] > max_bw)\r\nmax_bw = sch_bw->bus_bw[base + j];\r\n}\r\n}\r\nreturn max_bw;\r\n}\r\nstatic void update_bus_bw(struct mu3h_sch_bw_info *sch_bw,\r\nstruct mu3h_sch_ep_info *sch_ep, int bw_cost)\r\n{\r\nu32 num_esit;\r\nu32 base;\r\nint i;\r\nint j;\r\nnum_esit = XHCI_MTK_MAX_ESIT / sch_ep->esit;\r\nfor (i = 0; i < num_esit; i++) {\r\nbase = sch_ep->offset + i * sch_ep->esit;\r\nfor (j = 0; j < sch_ep->num_budget_microframes; j++)\r\nsch_bw->bus_bw[base + j] += bw_cost;\r\n}\r\n}\r\nstatic int check_sch_bw(struct usb_device *udev,\r\nstruct mu3h_sch_bw_info *sch_bw, struct mu3h_sch_ep_info *sch_ep)\r\n{\r\nu32 offset;\r\nu32 esit;\r\nu32 num_budget_microframes;\r\nu32 min_bw;\r\nu32 min_index;\r\nu32 worst_bw;\r\nu32 bw_boundary;\r\nif (sch_ep->esit > XHCI_MTK_MAX_ESIT)\r\nsch_ep->esit = XHCI_MTK_MAX_ESIT;\r\nesit = sch_ep->esit;\r\nnum_budget_microframes = sch_ep->num_budget_microframes;\r\nmin_bw = ~0;\r\nmin_index = 0;\r\nfor (offset = 0; offset < esit; offset++) {\r\nif ((offset + num_budget_microframes) > sch_ep->esit)\r\nbreak;\r\nif (is_fs_or_ls(udev->speed) && (offset % 8 == 6))\r\ncontinue;\r\nworst_bw = get_max_bw(sch_bw, sch_ep, offset);\r\nif (min_bw > worst_bw) {\r\nmin_bw = worst_bw;\r\nmin_index = offset;\r\n}\r\nif (min_bw == 0)\r\nbreak;\r\n}\r\nsch_ep->offset = min_index;\r\nbw_boundary = (udev->speed == USB_SPEED_SUPER)\r\n? SS_BW_BOUNDARY : HS_BW_BOUNDARY;\r\nif (min_bw + sch_ep->bw_cost_per_microframe > bw_boundary)\r\nreturn -ERANGE;\r\nupdate_bus_bw(sch_bw, sch_ep, sch_ep->bw_cost_per_microframe);\r\nreturn 0;\r\n}\r\nstatic bool need_bw_sch(struct usb_host_endpoint *ep,\r\nenum usb_device_speed speed, int has_tt)\r\n{\r\nif (usb_endpoint_xfer_control(&ep->desc)\r\n|| usb_endpoint_xfer_bulk(&ep->desc))\r\nreturn false;\r\nif (is_fs_or_ls(speed) && !has_tt)\r\nreturn false;\r\nreturn true;\r\n}\r\nint xhci_mtk_sch_init(struct xhci_hcd_mtk *mtk)\r\n{\r\nstruct mu3h_sch_bw_info *sch_array;\r\nint num_usb_bus;\r\nint i;\r\nnum_usb_bus = mtk->num_u3_ports * 2 + mtk->num_u2_ports;\r\nsch_array = kcalloc(num_usb_bus, sizeof(*sch_array), GFP_KERNEL);\r\nif (sch_array == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_usb_bus; i++)\r\nINIT_LIST_HEAD(&sch_array[i].bw_ep_list);\r\nmtk->sch_array = sch_array;\r\nreturn 0;\r\n}\r\nvoid xhci_mtk_sch_exit(struct xhci_hcd_mtk *mtk)\r\n{\r\nkfree(mtk->sch_array);\r\n}\r\nint xhci_mtk_add_ep_quirk(struct usb_hcd *hcd, struct usb_device *udev,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct xhci_hcd_mtk *mtk = hcd_to_mtk(hcd);\r\nstruct xhci_hcd *xhci;\r\nstruct xhci_ep_ctx *ep_ctx;\r\nstruct xhci_slot_ctx *slot_ctx;\r\nstruct xhci_virt_device *virt_dev;\r\nstruct mu3h_sch_bw_info *sch_bw;\r\nstruct mu3h_sch_ep_info *sch_ep;\r\nstruct mu3h_sch_bw_info *sch_array;\r\nunsigned int ep_index;\r\nint bw_index;\r\nint ret = 0;\r\nxhci = hcd_to_xhci(hcd);\r\nvirt_dev = xhci->devs[udev->slot_id];\r\nep_index = xhci_get_endpoint_index(&ep->desc);\r\nslot_ctx = xhci_get_slot_ctx(xhci, virt_dev->in_ctx);\r\nep_ctx = xhci_get_ep_ctx(xhci, virt_dev->in_ctx, ep_index);\r\nsch_array = mtk->sch_array;\r\nxhci_dbg(xhci, "%s() type:%d, speed:%d, mpkt:%d, dir:%d, ep:%p\n",\r\n__func__, usb_endpoint_type(&ep->desc), udev->speed,\r\nGET_MAX_PACKET(usb_endpoint_maxp(&ep->desc)),\r\nusb_endpoint_dir_in(&ep->desc), ep);\r\nif (!need_bw_sch(ep, udev->speed, slot_ctx->tt_info & TT_SLOT)) {\r\nif (usb_endpoint_xfer_int(&ep->desc)\r\n|| usb_endpoint_xfer_isoc(&ep->desc))\r\nep_ctx->reserved[0] |= cpu_to_le32(EP_BPKTS(1));\r\nreturn 0;\r\n}\r\nbw_index = get_bw_index(xhci, udev, ep);\r\nsch_bw = &sch_array[bw_index];\r\nsch_ep = kzalloc(sizeof(struct mu3h_sch_ep_info), GFP_NOIO);\r\nif (!sch_ep)\r\nreturn -ENOMEM;\r\nsetup_sch_info(udev, ep_ctx, sch_ep);\r\nret = check_sch_bw(udev, sch_bw, sch_ep);\r\nif (ret) {\r\nxhci_err(xhci, "Not enough bandwidth!\n");\r\nkfree(sch_ep);\r\nreturn -ENOSPC;\r\n}\r\nlist_add_tail(&sch_ep->endpoint, &sch_bw->bw_ep_list);\r\nsch_ep->ep = ep;\r\nep_ctx->reserved[0] |= cpu_to_le32(EP_BPKTS(sch_ep->pkts)\r\n| EP_BCSCOUNT(sch_ep->cs_count) | EP_BBM(sch_ep->burst_mode));\r\nep_ctx->reserved[1] |= cpu_to_le32(EP_BOFFSET(sch_ep->offset)\r\n| EP_BREPEAT(sch_ep->repeat));\r\nxhci_dbg(xhci, " PKTS:%x, CSCOUNT:%x, BM:%x, OFFSET:%x, REPEAT:%x\n",\r\nsch_ep->pkts, sch_ep->cs_count, sch_ep->burst_mode,\r\nsch_ep->offset, sch_ep->repeat);\r\nreturn 0;\r\n}\r\nvoid xhci_mtk_drop_ep_quirk(struct usb_hcd *hcd, struct usb_device *udev,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct xhci_hcd_mtk *mtk = hcd_to_mtk(hcd);\r\nstruct xhci_hcd *xhci;\r\nstruct xhci_slot_ctx *slot_ctx;\r\nstruct xhci_virt_device *virt_dev;\r\nstruct mu3h_sch_bw_info *sch_array;\r\nstruct mu3h_sch_bw_info *sch_bw;\r\nstruct mu3h_sch_ep_info *sch_ep;\r\nint bw_index;\r\nxhci = hcd_to_xhci(hcd);\r\nvirt_dev = xhci->devs[udev->slot_id];\r\nslot_ctx = xhci_get_slot_ctx(xhci, virt_dev->in_ctx);\r\nsch_array = mtk->sch_array;\r\nxhci_dbg(xhci, "%s() type:%d, speed:%d, mpks:%d, dir:%d, ep:%p\n",\r\n__func__, usb_endpoint_type(&ep->desc), udev->speed,\r\nGET_MAX_PACKET(usb_endpoint_maxp(&ep->desc)),\r\nusb_endpoint_dir_in(&ep->desc), ep);\r\nif (!need_bw_sch(ep, udev->speed, slot_ctx->tt_info & TT_SLOT))\r\nreturn;\r\nbw_index = get_bw_index(xhci, udev, ep);\r\nsch_bw = &sch_array[bw_index];\r\nlist_for_each_entry(sch_ep, &sch_bw->bw_ep_list, endpoint) {\r\nif (sch_ep->ep == ep) {\r\nupdate_bus_bw(sch_bw, sch_ep,\r\n-sch_ep->bw_cost_per_microframe);\r\nlist_del(&sch_ep->endpoint);\r\nkfree(sch_ep);\r\nbreak;\r\n}\r\n}\r\n}
