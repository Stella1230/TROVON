u8 hal_com_get_channel_plan23a(struct rtw_adapter *padapter, u8 hw_channel_plan,\r\nu8 sw_channel_plan, u8 def_channel_plan,\r\nbool AutoLoadFail)\r\n{\r\nu8 swConfig;\r\nu8 chnlPlan;\r\nswConfig = true;\r\nif (!AutoLoadFail) {\r\nif (!rtw_is_channel_plan_valid(sw_channel_plan))\r\nswConfig = false;\r\nif (hw_channel_plan & EEPROM_CHANNEL_PLAN_BY_HW_MASK)\r\nswConfig = false;\r\n}\r\nif (swConfig == true)\r\nchnlPlan = sw_channel_plan;\r\nelse\r\nchnlPlan = hw_channel_plan & (~EEPROM_CHANNEL_PLAN_BY_HW_MASK);\r\nif (!rtw_is_channel_plan_valid(chnlPlan))\r\nchnlPlan = def_channel_plan;\r\nreturn chnlPlan;\r\n}\r\nu8 MRateToHwRate23a(u8 rate)\r\n{\r\nu8 ret = DESC_RATE1M;\r\nswitch (rate) {\r\ncase IEEE80211_CCK_RATE_1MB:\r\nret = DESC_RATE1M;\r\nbreak;\r\ncase IEEE80211_CCK_RATE_2MB:\r\nret = DESC_RATE2M;\r\nbreak;\r\ncase IEEE80211_CCK_RATE_5MB:\r\nret = DESC_RATE5_5M;\r\nbreak;\r\ncase IEEE80211_CCK_RATE_11MB:\r\nret = DESC_RATE11M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_6MB:\r\nret = DESC_RATE6M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_9MB:\r\nret = DESC_RATE9M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_12MB:\r\nret = DESC_RATE12M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_18MB:\r\nret = DESC_RATE18M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_24MB:\r\nret = DESC_RATE24M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_36MB:\r\nret = DESC_RATE36M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_48MB:\r\nret = DESC_RATE48M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_54MB:\r\nret = DESC_RATE54M;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid HalSetBrateCfg23a(struct rtw_adapter *padapter, u8 *mBratesOS)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 i, is_brate, brate;\r\nu16 brate_cfg = 0;\r\nu8 rate_index;\r\nfor (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {\r\nis_brate = mBratesOS[i] & IEEE80211_BASIC_RATE_MASK;\r\nbrate = mBratesOS[i] & 0x7f;\r\nif (is_brate) {\r\nswitch (brate) {\r\ncase IEEE80211_CCK_RATE_1MB:\r\nbrate_cfg |= RATE_1M;\r\nbreak;\r\ncase IEEE80211_CCK_RATE_2MB:\r\nbrate_cfg |= RATE_2M;\r\nbreak;\r\ncase IEEE80211_CCK_RATE_5MB:\r\nbrate_cfg |= RATE_5_5M;\r\nbreak;\r\ncase IEEE80211_CCK_RATE_11MB:\r\nbrate_cfg |= RATE_11M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_6MB:\r\nbrate_cfg |= RATE_6M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_9MB:\r\nbrate_cfg |= RATE_9M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_12MB:\r\nbrate_cfg |= RATE_12M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_18MB:\r\nbrate_cfg |= RATE_18M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_24MB:\r\nbrate_cfg |= RATE_24M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_36MB:\r\nbrate_cfg |= RATE_36M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_48MB:\r\nbrate_cfg |= RATE_48M;\r\nbreak;\r\ncase IEEE80211_OFDM_RATE_54MB:\r\nbrate_cfg |= RATE_54M;\r\nbreak;\r\n}\r\n}\r\n}\r\nbrate_cfg = (brate_cfg | 0xd) & 0x15d;\r\npHalData->BasicRateSet = brate_cfg;\r\nbrate_cfg |= 0x01;\r\nDBG_8723A("HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", brate_cfg);\r\nrtl8723au_write8(padapter, REG_RRSR, brate_cfg & 0xff);\r\nrtl8723au_write8(padapter, REG_RRSR + 1, (brate_cfg >> 8) & 0xff);\r\nrtl8723au_write8(padapter, REG_RRSR + 2,\r\nrtl8723au_read8(padapter, REG_RRSR + 2) & 0xf0);\r\nrate_index = 0;\r\nwhile (brate_cfg > 0x1) {\r\nbrate_cfg >>= 1;\r\nrate_index++;\r\n}\r\nrtl8723au_write8(padapter, REG_INIRTS_RATE_SEL, rate_index);\r\n}\r\nstatic void _OneOutPipeMapping(struct rtw_adapter *pAdapter)\r\n{\r\nstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(pAdapter);\r\npdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0];\r\n}\r\nstatic void _TwoOutPipeMapping(struct rtw_adapter *pAdapter, bool bWIFICfg)\r\n{\r\nstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(pAdapter);\r\nif (bWIFICfg) {\r\npdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[1];\r\npdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[1];\r\npdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0];\r\n} else {\r\npdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[1];\r\npdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[1];\r\npdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0];\r\n}\r\n}\r\nstatic void _ThreeOutPipeMapping(struct rtw_adapter *pAdapter, bool bWIFICfg)\r\n{\r\nstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(pAdapter);\r\nif (bWIFICfg) {\r\npdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[1];\r\npdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[2];\r\npdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[1];\r\npdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0];\r\n} else {\r\npdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[1];\r\npdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[2];\r\npdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[2];\r\npdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0];\r\npdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0];\r\n}\r\n}\r\nbool Hal_MappingOutPipe23a(struct rtw_adapter *pAdapter, u8 NumOutPipe)\r\n{\r\nstruct registry_priv *pregistrypriv = &pAdapter->registrypriv;\r\nbool bWIFICfg = (pregistrypriv->wifi_spec) ? true : false;\r\nbool result = true;\r\nswitch (NumOutPipe) {\r\ncase 2:\r\n_TwoOutPipeMapping(pAdapter, bWIFICfg);\r\nbreak;\r\ncase 3:\r\n_ThreeOutPipeMapping(pAdapter, bWIFICfg);\r\nbreak;\r\ncase 1:\r\n_OneOutPipeMapping(pAdapter);\r\nbreak;\r\ndefault:\r\nresult = false;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nvoid c2h_evt_clear23a(struct rtw_adapter *adapter)\r\n{\r\nrtl8723au_write8(adapter, REG_C2HEVT_CLEAR, C2H_EVT_HOST_CLOSE);\r\n}\r\nint c2h_evt_read23a(struct rtw_adapter *adapter, u8 *buf)\r\n{\r\nint ret = _FAIL;\r\nstruct c2h_evt_hdr *c2h_evt;\r\nint i;\r\nu8 trigger;\r\nif (buf == NULL)\r\ngoto exit;\r\ntrigger = rtl8723au_read8(adapter, REG_C2HEVT_CLEAR);\r\nif (trigger == C2H_EVT_HOST_CLOSE)\r\ngoto exit;\r\nif (trigger != C2H_EVT_FW_CLOSE)\r\ngoto clear_evt;\r\nc2h_evt = (struct c2h_evt_hdr *)buf;\r\nmemset(c2h_evt, 0, 16);\r\n*buf = rtl8723au_read8(adapter, REG_C2HEVT_MSG_NORMAL);\r\n*(buf + 1) = rtl8723au_read8(adapter, REG_C2HEVT_MSG_NORMAL + 1);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_info_, "c2h_evt_read23a(): ",\r\n&c2h_evt, sizeof(c2h_evt));\r\nif (0) {\r\nDBG_8723A("%s id:%u, len:%u, seq:%u, trigger:0x%02x\n",\r\n__func__, c2h_evt->id, c2h_evt->plen, c2h_evt->seq,\r\ntrigger);\r\n}\r\nfor (i = 0; i < c2h_evt->plen; i++)\r\nc2h_evt->payload[i] = rtl8723au_read8(adapter,\r\nREG_C2HEVT_MSG_NORMAL +\r\nsizeof(*c2h_evt) + i);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_info_,\r\n"c2h_evt_read23a(): Command Content:\n", c2h_evt->payload,\r\nc2h_evt->plen);\r\nret = _SUCCESS;\r\nclear_evt:\r\nc2h_evt_clear23a(adapter);\r\nexit:\r\nreturn ret;\r\n}\r\nvoid\r\nrtl8723a_set_ampdu_min_space(struct rtw_adapter *padapter, u8 MinSpacingToSet)\r\n{\r\nu8 SecMinSpace;\r\nif (MinSpacingToSet <= 7) {\r\nswitch (padapter->securitypriv.dot11PrivacyAlgrthm) {\r\ncase 0:\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nSecMinSpace = 0;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nSecMinSpace = 6;\r\nbreak;\r\ndefault:\r\nSecMinSpace = 7;\r\nbreak;\r\n}\r\nif (MinSpacingToSet < SecMinSpace)\r\nMinSpacingToSet = SecMinSpace;\r\nMinSpacingToSet |=\r\nrtl8723au_read8(padapter, REG_AMPDU_MIN_SPACE) & 0xf8;\r\nrtl8723au_write8(padapter, REG_AMPDU_MIN_SPACE,\r\nMinSpacingToSet);\r\n}\r\n}\r\nvoid rtl8723a_set_ampdu_factor(struct rtw_adapter *padapter, u8 FactorToSet)\r\n{\r\nu8 RegToSet_Normal[4] = { 0x41, 0xa8, 0x72, 0xb9 };\r\nu8 MaxAggNum;\r\nu8 *pRegToSet;\r\nu8 index = 0;\r\npRegToSet = RegToSet_Normal;\r\nif (rtl8723a_BT_enabled(padapter) &&\r\nrtl8723a_BT_using_antenna_1(padapter))\r\nMaxAggNum = 0x8;\r\nelse\r\nMaxAggNum = 0xF;\r\nif (FactorToSet <= 3) {\r\nFactorToSet = 1 << (FactorToSet + 2);\r\nif (FactorToSet > MaxAggNum)\r\nFactorToSet = MaxAggNum;\r\nfor (index = 0; index < 4; index++) {\r\nif ((pRegToSet[index] & 0xf0) > (FactorToSet << 4))\r\npRegToSet[index] = (pRegToSet[index] & 0x0f) |\r\n(FactorToSet << 4);\r\nif ((pRegToSet[index] & 0x0f) > FactorToSet)\r\npRegToSet[index] = (pRegToSet[index] & 0xf0) |\r\nFactorToSet;\r\nrtl8723au_write8(padapter, REG_AGGLEN_LMT + index,\r\npRegToSet[index]);\r\n}\r\n}\r\n}\r\nvoid rtl8723a_set_acm_ctrl(struct rtw_adapter *padapter, u8 ctrl)\r\n{\r\nu8 hwctrl = 0;\r\nif (ctrl != 0) {\r\nhwctrl |= AcmHw_HwEn;\r\nif (ctrl & BIT(1))\r\nhwctrl |= AcmHw_BeqEn;\r\nif (ctrl & BIT(2))\r\nhwctrl |= AcmHw_ViqEn;\r\nif (ctrl & BIT(3))\r\nhwctrl |= AcmHw_VoqEn;\r\n}\r\nDBG_8723A("[HW_VAR_ACM_CTRL] Write 0x%02X\n", hwctrl);\r\nrtl8723au_write8(padapter, REG_ACMHWCTRL, hwctrl);\r\n}\r\nvoid rtl8723a_set_media_status(struct rtw_adapter *padapter, u8 status)\r\n{\r\nu8 val8;\r\nval8 = rtl8723au_read8(padapter, MSR) & 0x0c;\r\nval8 |= status;\r\nrtl8723au_write8(padapter, MSR, val8);\r\n}\r\nvoid rtl8723a_set_media_status1(struct rtw_adapter *padapter, u8 status)\r\n{\r\nu8 val8;\r\nval8 = rtl8723au_read8(padapter, MSR) & 0x03;\r\nval8 |= status << 2;\r\nrtl8723au_write8(padapter, MSR, val8);\r\n}\r\nvoid rtl8723a_set_bcn_func(struct rtw_adapter *padapter, u8 val)\r\n{\r\nif (val)\r\nSetBcnCtrlReg23a(padapter, EN_BCN_FUNCTION | EN_TXBCN_RPT, 0);\r\nelse\r\nSetBcnCtrlReg23a(padapter, 0, EN_BCN_FUNCTION | EN_TXBCN_RPT);\r\n}\r\nvoid rtl8723a_check_bssid(struct rtw_adapter *padapter, u8 val)\r\n{\r\nu32 val32;\r\nval32 = rtl8723au_read32(padapter, REG_RCR);\r\nif (val)\r\nval32 |= RCR_CBSSID_DATA | RCR_CBSSID_BCN;\r\nelse\r\nval32 &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);\r\nrtl8723au_write32(padapter, REG_RCR, val32);\r\n}\r\nvoid rtl8723a_mlme_sitesurvey(struct rtw_adapter *padapter, u8 flag)\r\n{\r\nif (flag) {\r\nu32 v32;\r\nv32 = rtl8723au_read32(padapter, REG_RCR);\r\nv32 &= ~(RCR_CBSSID_BCN);\r\nrtl8723au_write32(padapter, REG_RCR, v32);\r\nrtl8723au_write16(padapter, REG_RXFLTMAP2, 0);\r\nSetBcnCtrlReg23a(padapter, DIS_TSF_UDT, 0);\r\n} else {\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nu32 v32;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\nif ((is_client_associated_to_ap23a(padapter) == true) ||\r\n((pmlmeinfo->state & 0x03) == MSR_ADHOC) ||\r\n((pmlmeinfo->state & 0x03) == MSR_AP)) {\r\nrtl8723au_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\r\nSetBcnCtrlReg23a(padapter, 0, DIS_TSF_UDT);\r\n}\r\nv32 = rtl8723au_read32(padapter, REG_RCR);\r\nv32 |= RCR_CBSSID_BCN;\r\nrtl8723au_write32(padapter, REG_RCR, v32);\r\n}\r\nrtl8723a_BT_wifiscan_notify(padapter, flag ? true : false);\r\n}\r\nvoid rtl8723a_on_rcr_am(struct rtw_adapter *padapter)\r\n{\r\nrtl8723au_write32(padapter, REG_RCR,\r\nrtl8723au_read32(padapter, REG_RCR) | RCR_AM);\r\nDBG_8723A("%s, %d, RCR = %x\n", __func__, __LINE__,\r\nrtl8723au_read32(padapter, REG_RCR));\r\n}\r\nvoid rtl8723a_off_rcr_am(struct rtw_adapter *padapter)\r\n{\r\nrtl8723au_write32(padapter, REG_RCR,\r\nrtl8723au_read32(padapter, REG_RCR) & (~RCR_AM));\r\nDBG_8723A("%s, %d, RCR = %x\n", __func__, __LINE__,\r\nrtl8723au_read32(padapter, REG_RCR));\r\n}\r\nvoid rtl8723a_set_slot_time(struct rtw_adapter *padapter, u8 slottime)\r\n{\r\nu8 u1bAIFS, aSifsTime;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nrtl8723au_write8(padapter, REG_SLOT, slottime);\r\nif (pmlmeinfo->WMM_enable == 0) {\r\nif (pmlmeext->cur_wireless_mode == WIRELESS_11B)\r\naSifsTime = 10;\r\nelse\r\naSifsTime = 16;\r\nu1bAIFS = aSifsTime + (2 * pmlmeinfo->slotTime);\r\nrtl8723au_write8(padapter, REG_EDCA_VO_PARAM, u1bAIFS);\r\nrtl8723au_write8(padapter, REG_EDCA_VI_PARAM, u1bAIFS);\r\nrtl8723au_write8(padapter, REG_EDCA_BE_PARAM, u1bAIFS);\r\nrtl8723au_write8(padapter, REG_EDCA_BK_PARAM, u1bAIFS);\r\n}\r\n}\r\nvoid rtl8723a_ack_preamble(struct rtw_adapter *padapter, u8 bShortPreamble)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 regTmp;\r\nregTmp = (pHalData->nCur40MhzPrimeSC) << 5;\r\nif (bShortPreamble)\r\nregTmp |= 0x80;\r\nrtl8723au_write8(padapter, REG_RRSR + 2, regTmp);\r\n}\r\nvoid rtl8723a_set_sec_cfg(struct rtw_adapter *padapter, u8 sec)\r\n{\r\nrtl8723au_write8(padapter, REG_SECCFG, sec);\r\n}\r\nvoid rtl8723a_cam_empty_entry(struct rtw_adapter *padapter, u8 ucIndex)\r\n{\r\nu8 i;\r\nu32 ulCommand = 0;\r\nu32 ulContent = 0;\r\nu32 ulEncAlgo = CAM_AES;\r\nfor (i = 0; i < CAM_CONTENT_COUNT; i++) {\r\nif (i == 0) {\r\nulContent |= (ucIndex & 0x03) |\r\n((u16) (ulEncAlgo) << 2);\r\n} else {\r\nulContent = 0;\r\n}\r\nulCommand = CAM_CONTENT_COUNT * ucIndex + i;\r\nulCommand = ulCommand | CAM_POLLINIG | CAM_WRITE;\r\nrtl8723au_write32(padapter, WCAMI, ulContent);\r\nrtl8723au_write32(padapter, REG_CAMCMD, ulCommand);\r\n}\r\n}\r\nvoid rtl8723a_cam_invalidate_all(struct rtw_adapter *padapter)\r\n{\r\nrtl8723au_write32(padapter, REG_CAMCMD, CAM_POLLINIG | BIT(30));\r\n}\r\nvoid rtl8723a_cam_write(struct rtw_adapter *padapter,\r\nu8 entry, u16 ctrl, const u8 *mac, const u8 *key)\r\n{\r\nu32 cmd;\r\nunsigned int i, val, addr;\r\nint j;\r\naddr = entry << 3;\r\nfor (j = 5; j >= 0; j--) {\r\nswitch (j) {\r\ncase 0:\r\nval = ctrl | (mac[0] << 16) | (mac[1] << 24);\r\nbreak;\r\ncase 1:\r\nval = mac[2] | (mac[3] << 8) |\r\n(mac[4] << 16) | (mac[5] << 24);\r\nbreak;\r\ndefault:\r\ni = (j - 2) << 2;\r\nval = key[i] | (key[i+1] << 8) |\r\n(key[i+2] << 16) | (key[i+3] << 24);\r\nbreak;\r\n}\r\nrtl8723au_write32(padapter, WCAMI, val);\r\ncmd = CAM_POLLINIG | CAM_WRITE | (addr + j);\r\nrtl8723au_write32(padapter, REG_CAMCMD, cmd);\r\n}\r\n}\r\nvoid rtl8723a_fifo_cleanup(struct rtw_adapter *padapter)\r\n{\r\n#define RW_RELEASE_EN BIT(18)\r\n#define RXDMA_IDLE BIT(17)\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nu8 trycnt = 100;\r\nrtl8723au_write8(padapter, REG_TXPAUSE, 0xff);\r\npadapter->xmitpriv.nqos_ssn = rtl8723au_read8(padapter, REG_NQOS_SEQ);\r\nif (pwrpriv->bkeepfwalive != true) {\r\nu32 v32;\r\nv32 = rtl8723au_read32(padapter, REG_RXPKT_NUM);\r\nv32 |= RW_RELEASE_EN;\r\nrtl8723au_write32(padapter, REG_RXPKT_NUM, v32);\r\ndo {\r\nv32 = rtl8723au_read32(padapter,\r\nREG_RXPKT_NUM) & RXDMA_IDLE;\r\nif (!v32)\r\nbreak;\r\n} while (trycnt--);\r\nif (trycnt == 0)\r\nDBG_8723A("Stop RX DMA failed......\n");\r\nrtl8723au_write16(padapter, REG_RQPN_NPQ, 0);\r\nrtl8723au_write32(padapter, REG_RQPN, 0x80000000);\r\nmdelay(10);\r\n}\r\n}\r\nvoid rtl8723a_bcn_valid(struct rtw_adapter *padapter)\r\n{\r\nrtl8723au_write8(padapter, REG_TDECTRL + 2,\r\nrtl8723au_read8(padapter, REG_TDECTRL + 2) | BIT(0));\r\n}\r\nbool rtl8723a_get_bcn_valid(struct rtw_adapter *padapter)\r\n{\r\nbool retval;\r\nretval = (rtl8723au_read8(padapter, REG_TDECTRL + 2) & BIT(0)) ? true : false;\r\nreturn retval;\r\n}\r\nvoid rtl8723a_set_beacon_interval(struct rtw_adapter *padapter, u16 interval)\r\n{\r\nrtl8723au_write16(padapter, REG_BCN_INTERVAL, interval);\r\n}\r\nvoid rtl8723a_set_resp_sifs(struct rtw_adapter *padapter,\r\nu8 r2t1, u8 r2t2, u8 t2t1, u8 t2t2)\r\n{\r\nrtl8723au_write8(padapter, REG_R2T_SIFS, r2t1);\r\nrtl8723au_write8(padapter, REG_R2T_SIFS + 1, r2t2);\r\nrtl8723au_write8(padapter, REG_T2T_SIFS, t2t1);\r\nrtl8723au_write8(padapter, REG_T2T_SIFS + 1, t2t2);\r\n}\r\nvoid rtl8723a_set_ac_param_vo(struct rtw_adapter *padapter, u32 vo)\r\n{\r\nrtl8723au_write32(padapter, REG_EDCA_VO_PARAM, vo);\r\n}\r\nvoid rtl8723a_set_ac_param_vi(struct rtw_adapter *padapter, u32 vi)\r\n{\r\nrtl8723au_write32(padapter, REG_EDCA_VI_PARAM, vi);\r\n}\r\nvoid rtl8723a_set_ac_param_be(struct rtw_adapter *padapter, u32 be)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\npHalData->AcParam_BE = be;\r\nrtl8723au_write32(padapter, REG_EDCA_BE_PARAM, be);\r\n}\r\nvoid rtl8723a_set_ac_param_bk(struct rtw_adapter *padapter, u32 bk)\r\n{\r\nrtl8723au_write32(padapter, REG_EDCA_BK_PARAM, bk);\r\n}\r\nvoid rtl8723a_set_rxdma_agg_pg_th(struct rtw_adapter *padapter, u8 val)\r\n{\r\nrtl8723au_write8(padapter, REG_RXDMA_AGG_PG_TH, val);\r\n}\r\nvoid rtl8723a_set_initial_gain(struct rtw_adapter *padapter, u32 rx_gain)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct dig_t *pDigTable = &pHalData->odmpriv.DM_DigTable;\r\nif (rx_gain == 0xff)\r\nODM_Write_DIG23a(&pHalData->odmpriv, pDigTable->BackupIGValue);\r\nelse {\r\npDigTable->BackupIGValue = pDigTable->CurIGValue;\r\nODM_Write_DIG23a(&pHalData->odmpriv, rx_gain);\r\n}\r\n}\r\nvoid rtl8723a_odm_support_ability_restore(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\npHalData->odmpriv.SupportAbility = pHalData->odmpriv.BK_SupportAbility;\r\n}\r\nvoid rtl8723a_odm_support_ability_backup(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\npHalData->odmpriv.BK_SupportAbility = pHalData->odmpriv.SupportAbility;\r\n}\r\nvoid rtl8723a_odm_support_ability_set(struct rtw_adapter *padapter, u32 val)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (val == DYNAMIC_ALL_FUNC_ENABLE)\r\npHalData->odmpriv.SupportAbility = pHalData->dmpriv.InitODMFlag;\r\nelse\r\npHalData->odmpriv.SupportAbility |= val;\r\n}\r\nvoid rtl8723a_odm_support_ability_clr(struct rtw_adapter *padapter, u32 val)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\npHalData->odmpriv.SupportAbility &= val;\r\n}\r\nvoid rtl8723a_set_rpwm(struct rtw_adapter *padapter, u8 val)\r\n{\r\nrtl8723au_write8(padapter, REG_USB_HRPWM, val);\r\n}\r\nu8 rtl8723a_get_rf_type(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nreturn pHalData->rf_type;\r\n}\r\nbool rtl8723a_get_fwlps_rf_on(struct rtw_adapter *padapter)\r\n{\r\nbool retval;\r\nu32 valRCR;\r\nif ((padapter->bSurpriseRemoved == true) ||\r\n(padapter->pwrctrlpriv.rf_pwrstate == rf_off)) {\r\nretval = true;\r\n} else {\r\nvalRCR = rtl8723au_read32(padapter, REG_RCR);\r\nif (valRCR & 0x00070000)\r\nretval = false;\r\nelse\r\nretval = true;\r\n}\r\nreturn retval;\r\n}\r\nbool rtl8723a_chk_hi_queue_empty(struct rtw_adapter *padapter)\r\n{\r\nu32 hgq;\r\nhgq = rtl8723au_read32(padapter, REG_HGQ_INFORMATION);\r\nreturn ((hgq & 0x0000ff00) == 0) ? true : false;\r\n}
