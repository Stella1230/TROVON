static short rtllib_is_54g(struct rtllib_network *net)\r\n{\r\nreturn (net->rates_ex_len > 0) || (net->rates_len > 4);\r\n}\r\nstatic unsigned int rtllib_MFIE_rate_len(struct rtllib_device *ieee)\r\n{\r\nunsigned int rate_len = 0;\r\nif (ieee->modulation & RTLLIB_CCK_MODULATION)\r\nrate_len = RTLLIB_CCK_RATE_LEN + 2;\r\nif (ieee->modulation & RTLLIB_OFDM_MODULATION)\r\nrate_len += RTLLIB_OFDM_RATE_LEN + 2;\r\nreturn rate_len;\r\n}\r\nstatic void rtllib_MFIE_Brate(struct rtllib_device *ieee, u8 **tag_p)\r\n{\r\nu8 *tag = *tag_p;\r\nif (ieee->modulation & RTLLIB_CCK_MODULATION) {\r\n*tag++ = MFIE_TYPE_RATES;\r\n*tag++ = 4;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_1MB;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_2MB;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_5MB;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_11MB;\r\n}\r\n*tag_p = tag;\r\n}\r\nstatic void rtllib_MFIE_Grate(struct rtllib_device *ieee, u8 **tag_p)\r\n{\r\nu8 *tag = *tag_p;\r\nif (ieee->modulation & RTLLIB_OFDM_MODULATION) {\r\n*tag++ = MFIE_TYPE_RATES_EX;\r\n*tag++ = 8;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_6MB;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_9MB;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_12MB;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_18MB;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_24MB;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_36MB;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_48MB;\r\n*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_54MB;\r\n}\r\n*tag_p = tag;\r\n}\r\nstatic void rtllib_WMM_Info(struct rtllib_device *ieee, u8 **tag_p)\r\n{\r\nu8 *tag = *tag_p;\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = 7;\r\n*tag++ = 0x00;\r\n*tag++ = 0x50;\r\n*tag++ = 0xf2;\r\n*tag++ = 0x02;\r\n*tag++ = 0x00;\r\n*tag++ = 0x01;\r\n*tag++ = MAX_SP_Len;\r\n*tag_p = tag;\r\n}\r\nstatic void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p)\r\n{\r\nu8 *tag = *tag_p;\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = 7;\r\n*tag++ = 0x00;\r\n*tag++ = 0xe0;\r\n*tag++ = 0x4c;\r\n*tag++ = 0x01;\r\n*tag++ = 0x02;\r\n*tag++ = 0x11;\r\n*tag++ = 0x00;\r\n*tag_p = tag;\r\nnetdev_alert(ieee->dev, "This is enable turbo mode IE process\n");\r\n}\r\nstatic void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)\r\n{\r\nint nh;\r\nnh = (ieee->mgmt_queue_head + 1) % MGMT_QUEUE_NUM;\r\nieee->mgmt_queue_head = nh;\r\nieee->mgmt_queue_ring[nh] = skb;\r\n}\r\nstatic void init_mgmt_queue(struct rtllib_device *ieee)\r\n{\r\nieee->mgmt_queue_tail = ieee->mgmt_queue_head = 0;\r\n}\r\nu8\r\nMgntQuery_TxRateExcludeCCKRates(struct rtllib_device *ieee)\r\n{\r\nu16 i;\r\nu8 QueryRate = 0;\r\nu8 BasicRate;\r\nfor (i = 0; i < ieee->current_network.rates_len; i++) {\r\nBasicRate = ieee->current_network.rates[i]&0x7F;\r\nif (!rtllib_is_cck_rate(BasicRate)) {\r\nif (QueryRate == 0) {\r\nQueryRate = BasicRate;\r\n} else {\r\nif (BasicRate < QueryRate)\r\nQueryRate = BasicRate;\r\n}\r\n}\r\n}\r\nif (QueryRate == 0) {\r\nQueryRate = 12;\r\nnetdev_info(ieee->dev, "No BasicRate found!!\n");\r\n}\r\nreturn QueryRate;\r\n}\r\nstatic u8 MgntQuery_MgntFrameTxRate(struct rtllib_device *ieee)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nu8 rate;\r\nif (pHTInfo->IOTAction & HT_IOT_ACT_MGNT_USE_CCK_6M)\r\nrate = 0x0c;\r\nelse\r\nrate = ieee->basic_rate & 0x7f;\r\nif (rate == 0) {\r\nif (ieee->mode == IEEE_A ||\r\nieee->mode == IEEE_N_5G ||\r\n(ieee->mode == IEEE_N_24G && !pHTInfo->bCurSuppCCK))\r\nrate = 0x0c;\r\nelse\r\nrate = 0x02;\r\n}\r\nreturn rate;\r\n}\r\ninline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)\r\n{\r\nunsigned long flags;\r\nshort single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;\r\nstruct rtllib_hdr_3addr *header =\r\n(struct rtllib_hdr_3addr *) skb->data;\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + 8);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nrtllib_sta_wakeup(ieee, 0);\r\nif (le16_to_cpu(header->frame_ctl) == RTLLIB_STYPE_BEACON)\r\ntcb_desc->queue_index = BEACON_QUEUE;\r\nelse\r\ntcb_desc->queue_index = MGNT_QUEUE;\r\nif (ieee->disable_mgnt_queue)\r\ntcb_desc->queue_index = HIGH_QUEUE;\r\ntcb_desc->data_rate = MgntQuery_MgntFrameTxRate(ieee);\r\ntcb_desc->RATRIndex = 7;\r\ntcb_desc->bTxDisableRateFallBack = 1;\r\ntcb_desc->bTxUseDriverAssingedRate = 1;\r\nif (single) {\r\nif (ieee->queue_stop) {\r\nenqueue_mgmt(ieee, skb);\r\n} else {\r\nheader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0]<<4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nieee->softmac_data_hard_start_xmit(skb, ieee->dev,\r\nieee->basic_rate);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n} else {\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags);\r\nheader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nif (!ieee->check_nic_enough_desc(ieee->dev,\r\ntcb_desc->queue_index) ||\r\nskb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) ||\r\nieee->queue_stop) {\r\nnetdev_info(ieee->dev,\r\n"%s():insert to waitqueue, queue_index:%d!\n",\r\n__func__, tcb_desc->queue_index);\r\nskb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index],\r\nskb);\r\n} else {\r\nieee->softmac_hard_start_xmit(skb, ieee->dev);\r\n}\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags);\r\n}\r\n}\r\ninline void softmac_ps_mgmt_xmit(struct sk_buff *skb,\r\nstruct rtllib_device *ieee)\r\n{\r\nshort single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;\r\nstruct rtllib_hdr_3addr *header =\r\n(struct rtllib_hdr_3addr *) skb->data;\r\nu16 fc, type, stype;\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + 8);\r\nfc = le16_to_cpu(header->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nstype = WLAN_FC_GET_STYPE(fc);\r\nif (stype != RTLLIB_STYPE_PSPOLL)\r\ntcb_desc->queue_index = MGNT_QUEUE;\r\nelse\r\ntcb_desc->queue_index = HIGH_QUEUE;\r\nif (ieee->disable_mgnt_queue)\r\ntcb_desc->queue_index = HIGH_QUEUE;\r\ntcb_desc->data_rate = MgntQuery_MgntFrameTxRate(ieee);\r\ntcb_desc->RATRIndex = 7;\r\ntcb_desc->bTxDisableRateFallBack = 1;\r\ntcb_desc->bTxUseDriverAssingedRate = 1;\r\nif (single) {\r\nif (type != RTLLIB_FTYPE_CTL) {\r\nheader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\n}\r\nieee->softmac_data_hard_start_xmit(skb, ieee->dev,\r\nieee->basic_rate);\r\n} else {\r\nif (type != RTLLIB_FTYPE_CTL) {\r\nheader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\n}\r\nieee->softmac_hard_start_xmit(skb, ieee->dev);\r\n}\r\n}\r\nstatic inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)\r\n{\r\nunsigned int len, rate_len;\r\nu8 *tag;\r\nstruct sk_buff *skb;\r\nstruct rtllib_probe_request *req;\r\nlen = ieee->current_network.ssid_len;\r\nrate_len = rtllib_MFIE_rate_len(ieee);\r\nskb = dev_alloc_skb(sizeof(struct rtllib_probe_request) +\r\n2 + len + rate_len + ieee->tx_headroom);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nreq = (struct rtllib_probe_request *) skb_put(skb,\r\nsizeof(struct rtllib_probe_request));\r\nreq->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_PROBE_REQ);\r\nreq->header.duration_id = 0;\r\neth_broadcast_addr(req->header.addr1);\r\nether_addr_copy(req->header.addr2, ieee->dev->dev_addr);\r\neth_broadcast_addr(req->header.addr3);\r\ntag = (u8 *) skb_put(skb, len + 2 + rate_len);\r\n*tag++ = MFIE_TYPE_SSID;\r\n*tag++ = len;\r\nmemcpy(tag, ieee->current_network.ssid, len);\r\ntag += len;\r\nrtllib_MFIE_Brate(ieee, &tag);\r\nrtllib_MFIE_Grate(ieee, &tag);\r\nreturn skb;\r\n}\r\nstatic void rtllib_send_beacon(struct rtllib_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nif (!ieee->ieee_up)\r\nreturn;\r\nskb = rtllib_get_beacon_(ieee);\r\nif (skb) {\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nieee->softmac_stats.tx_beacons++;\r\n}\r\nif (ieee->beacon_txing && ieee->ieee_up)\r\nmod_timer(&ieee->beacon_timer, jiffies +\r\n(msecs_to_jiffies(ieee->current_network.beacon_interval - 5)));\r\n}\r\nstatic void rtllib_send_beacon_cb(unsigned long _ieee)\r\n{\r\nstruct rtllib_device *ieee =\r\n(struct rtllib_device *) _ieee;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->beacon_lock, flags);\r\nrtllib_send_beacon(ieee);\r\nspin_unlock_irqrestore(&ieee->beacon_lock, flags);\r\n}\r\nvoid rtllib_EnableNetMonitorMode(struct net_device *dev,\r\nbool bInitState)\r\n{\r\nstruct rtllib_device *ieee = netdev_priv_rsl(dev);\r\nnetdev_info(dev, "========>Enter Monitor Mode\n");\r\nieee->AllowAllDestAddrHandler(dev, true, !bInitState);\r\n}\r\nvoid rtllib_DisableNetMonitorMode(struct net_device *dev,\r\nbool bInitState)\r\n{\r\nstruct rtllib_device *ieee = netdev_priv_rsl(dev);\r\nnetdev_info(dev, "========>Exit Monitor Mode\n");\r\nieee->AllowAllDestAddrHandler(dev, false, !bInitState);\r\n}\r\nvoid rtllib_EnableIntelPromiscuousMode(struct net_device *dev,\r\nbool bInitState)\r\n{\r\nbool bFilterOutNonAssociatedBSSID = false;\r\nstruct rtllib_device *ieee = netdev_priv_rsl(dev);\r\nnetdev_info(dev, "========>Enter Intel Promiscuous Mode\n");\r\nieee->AllowAllDestAddrHandler(dev, true, !bInitState);\r\nieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID,\r\n(u8 *)&bFilterOutNonAssociatedBSSID);\r\nieee->bNetPromiscuousMode = true;\r\n}\r\nvoid rtllib_DisableIntelPromiscuousMode(struct net_device *dev,\r\nbool bInitState)\r\n{\r\nbool bFilterOutNonAssociatedBSSID = true;\r\nstruct rtllib_device *ieee = netdev_priv_rsl(dev);\r\nnetdev_info(dev, "========>Exit Intel Promiscuous Mode\n");\r\nieee->AllowAllDestAddrHandler(dev, false, !bInitState);\r\nieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID,\r\n(u8 *)&bFilterOutNonAssociatedBSSID);\r\nieee->bNetPromiscuousMode = false;\r\n}\r\nstatic void rtllib_send_probe(struct rtllib_device *ieee, u8 is_mesh)\r\n{\r\nstruct sk_buff *skb;\r\nskb = rtllib_probe_req(ieee);\r\nif (skb) {\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nieee->softmac_stats.tx_probe_rq++;\r\n}\r\n}\r\nstatic void rtllib_send_probe_requests(struct rtllib_device *ieee, u8 is_mesh)\r\n{\r\nif (ieee->active_scan && (ieee->softmac_features &\r\nIEEE_SOFTMAC_PROBERQ)) {\r\nrtllib_send_probe(ieee, 0);\r\nrtllib_send_probe(ieee, 0);\r\n}\r\n}\r\nstatic void rtllib_update_active_chan_map(struct rtllib_device *ieee)\r\n{\r\nmemcpy(ieee->active_channel_map, GET_DOT11D_INFO(ieee)->channel_map,\r\nMAX_CHANNEL_NUMBER+1);\r\n}\r\nstatic void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)\r\n{\r\nunion iwreq_data wrqu;\r\nshort ch = 0;\r\nrtllib_update_active_chan_map(ieee);\r\nieee->be_scan_inprogress = true;\r\ndown(&ieee->scan_sem);\r\nwhile (1) {\r\ndo {\r\nch++;\r\nif (ch > MAX_CHANNEL_NUMBER)\r\ngoto out;\r\n} while (!ieee->active_channel_map[ch]);\r\nif (ieee->state == RTLLIB_LINKED)\r\ngoto out;\r\nif (ieee->sync_scan_hurryup) {\r\nnetdev_info(ieee->dev,\r\n"============>sync_scan_hurryup out\n");\r\ngoto out;\r\n}\r\nieee->set_chan(ieee->dev, ch);\r\nif (ieee->active_channel_map[ch] == 1)\r\nrtllib_send_probe_requests(ieee, 0);\r\nmsleep_interruptible_rsl(RTLLIB_SOFTMAC_SCAN_TIME);\r\n}\r\nout:\r\nieee->actscanning = false;\r\nieee->sync_scan_hurryup = 0;\r\nif (ieee->state >= RTLLIB_LINKED) {\r\nif (IS_DOT11D_ENABLE(ieee))\r\nDOT11D_ScanComplete(ieee);\r\n}\r\nup(&ieee->scan_sem);\r\nieee->be_scan_inprogress = false;\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwireless_send_event(ieee->dev, SIOCGIWSCAN, &wrqu, NULL);\r\n}\r\nstatic void rtllib_softmac_scan_wq(void *data)\r\n{\r\nstruct rtllib_device *ieee = container_of_dwork_rsl(data,\r\nstruct rtllib_device, softmac_scan_wq);\r\nu8 last_channel = ieee->current_network.channel;\r\nrtllib_update_active_chan_map(ieee);\r\nif (!ieee->ieee_up)\r\nreturn;\r\nif (rtllib_act_scanning(ieee, true))\r\nreturn;\r\ndown(&ieee->scan_sem);\r\nif (ieee->eRFPowerState == eRfOff) {\r\nnetdev_info(ieee->dev,\r\n"======>%s():rf state is eRfOff, return\n",\r\n__func__);\r\ngoto out1;\r\n}\r\ndo {\r\nieee->current_network.channel =\r\n(ieee->current_network.channel + 1) %\r\nMAX_CHANNEL_NUMBER;\r\nif (ieee->scan_watch_dog++ > MAX_CHANNEL_NUMBER) {\r\nif (!ieee->active_channel_map[ieee->current_network.channel])\r\nieee->current_network.channel = 6;\r\ngoto out;\r\n}\r\n} while (!ieee->active_channel_map[ieee->current_network.channel]);\r\nif (ieee->scanning_continue == 0)\r\ngoto out;\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nif (ieee->active_channel_map[ieee->current_network.channel] == 1)\r\nrtllib_send_probe_requests(ieee, 0);\r\nschedule_delayed_work(&ieee->softmac_scan_wq,\r\nmsecs_to_jiffies(RTLLIB_SOFTMAC_SCAN_TIME));\r\nup(&ieee->scan_sem);\r\nreturn;\r\nout:\r\nif (IS_DOT11D_ENABLE(ieee))\r\nDOT11D_ScanComplete(ieee);\r\nieee->current_network.channel = last_channel;\r\nout1:\r\nieee->actscanning = false;\r\nieee->scan_watch_dog = 0;\r\nieee->scanning_continue = 0;\r\nup(&ieee->scan_sem);\r\n}\r\nstatic void rtllib_beacons_start(struct rtllib_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->beacon_lock, flags);\r\nieee->beacon_txing = 1;\r\nrtllib_send_beacon(ieee);\r\nspin_unlock_irqrestore(&ieee->beacon_lock, flags);\r\n}\r\nstatic void rtllib_beacons_stop(struct rtllib_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->beacon_lock, flags);\r\nieee->beacon_txing = 0;\r\ndel_timer_sync(&ieee->beacon_timer);\r\nspin_unlock_irqrestore(&ieee->beacon_lock, flags);\r\n}\r\nvoid rtllib_stop_send_beacons(struct rtllib_device *ieee)\r\n{\r\nif (ieee->stop_send_beacons)\r\nieee->stop_send_beacons(ieee->dev);\r\nif (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)\r\nrtllib_beacons_stop(ieee);\r\n}\r\nvoid rtllib_start_send_beacons(struct rtllib_device *ieee)\r\n{\r\nif (ieee->start_send_beacons)\r\nieee->start_send_beacons(ieee->dev);\r\nif (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)\r\nrtllib_beacons_start(ieee);\r\n}\r\nstatic void rtllib_softmac_stop_scan(struct rtllib_device *ieee)\r\n{\r\ndown(&ieee->scan_sem);\r\nieee->scan_watch_dog = 0;\r\nif (ieee->scanning_continue == 1) {\r\nieee->scanning_continue = 0;\r\nieee->actscanning = false;\r\ncancel_delayed_work_sync(&ieee->softmac_scan_wq);\r\n}\r\nup(&ieee->scan_sem);\r\n}\r\nvoid rtllib_stop_scan(struct rtllib_device *ieee)\r\n{\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {\r\nrtllib_softmac_stop_scan(ieee);\r\n} else {\r\nif (ieee->rtllib_stop_hw_scan)\r\nieee->rtllib_stop_hw_scan(ieee->dev);\r\n}\r\n}\r\nvoid rtllib_stop_scan_syncro(struct rtllib_device *ieee)\r\n{\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {\r\nieee->sync_scan_hurryup = 1;\r\n} else {\r\nif (ieee->rtllib_stop_hw_scan)\r\nieee->rtllib_stop_hw_scan(ieee->dev);\r\n}\r\n}\r\nbool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan)\r\n{\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {\r\nif (sync_scan)\r\nreturn ieee->be_scan_inprogress;\r\nelse\r\nreturn ieee->actscanning || ieee->be_scan_inprogress;\r\n} else {\r\nreturn test_bit(STATUS_SCANNING, &ieee->status);\r\n}\r\n}\r\nstatic void rtllib_start_scan(struct rtllib_device *ieee)\r\n{\r\nRT_TRACE(COMP_DBG, "===>%s()\n", __func__);\r\nif (ieee->rtllib_ips_leave_wq != NULL)\r\nieee->rtllib_ips_leave_wq(ieee->dev);\r\nif (IS_DOT11D_ENABLE(ieee)) {\r\nif (IS_COUNTRY_IE_VALID(ieee))\r\nRESET_CIE_WATCHDOG(ieee);\r\n}\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {\r\nif (ieee->scanning_continue == 0) {\r\nieee->actscanning = true;\r\nieee->scanning_continue = 1;\r\nschedule_delayed_work(&ieee->softmac_scan_wq, 0);\r\n}\r\n} else {\r\nif (ieee->rtllib_start_hw_scan)\r\nieee->rtllib_start_hw_scan(ieee->dev);\r\n}\r\n}\r\nvoid rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)\r\n{\r\nif (IS_DOT11D_ENABLE(ieee)) {\r\nif (IS_COUNTRY_IE_VALID(ieee))\r\nRESET_CIE_WATCHDOG(ieee);\r\n}\r\nieee->sync_scan_hurryup = 0;\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {\r\nrtllib_softmac_scan_syncro(ieee, is_mesh);\r\n} else {\r\nif (ieee->rtllib_start_hw_scan)\r\nieee->rtllib_start_hw_scan(ieee->dev);\r\n}\r\n}\r\ninline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,\r\nstruct rtllib_device *ieee, int challengelen, u8 *daddr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rtllib_authentication *auth;\r\nint len;\r\nlen = sizeof(struct rtllib_authentication) + challengelen +\r\nieee->tx_headroom + 4;\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nauth = (struct rtllib_authentication *)\r\nskb_put(skb, sizeof(struct rtllib_authentication));\r\nauth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_AUTH);\r\nif (challengelen)\r\nauth->header.frame_ctl |= cpu_to_le16(RTLLIB_FCTL_WEP);\r\nauth->header.duration_id = cpu_to_le16(0x013a);\r\nether_addr_copy(auth->header.addr1, beacon->bssid);\r\nether_addr_copy(auth->header.addr2, ieee->dev->dev_addr);\r\nether_addr_copy(auth->header.addr3, beacon->bssid);\r\nif (ieee->auth_mode == 0)\r\nauth->algorithm = WLAN_AUTH_OPEN;\r\nelse if (ieee->auth_mode == 1)\r\nauth->algorithm = cpu_to_le16(WLAN_AUTH_SHARED_KEY);\r\nelse if (ieee->auth_mode == 2)\r\nauth->algorithm = WLAN_AUTH_OPEN;\r\nauth->transaction = cpu_to_le16(ieee->associate_seq);\r\nieee->associate_seq++;\r\nauth->status = cpu_to_le16(WLAN_STATUS_SUCCESS);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee,\r\nconst u8 *dest)\r\n{\r\nu8 *tag;\r\nint beacon_size;\r\nstruct rtllib_probe_response *beacon_buf;\r\nstruct sk_buff *skb = NULL;\r\nint encrypt;\r\nint atim_len, erp_len;\r\nstruct lib80211_crypt_data *crypt;\r\nchar *ssid = ieee->current_network.ssid;\r\nint ssid_len = ieee->current_network.ssid_len;\r\nint rate_len = ieee->current_network.rates_len+2;\r\nint rate_ex_len = ieee->current_network.rates_ex_len;\r\nint wpa_ie_len = ieee->wpa_ie_len;\r\nu8 erpinfo_content = 0;\r\nu8 *tmp_ht_cap_buf = NULL;\r\nu8 tmp_ht_cap_len = 0;\r\nu8 *tmp_ht_info_buf = NULL;\r\nu8 tmp_ht_info_len = 0;\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nu8 *tmp_generic_ie_buf = NULL;\r\nu8 tmp_generic_ie_len = 0;\r\nif (rate_ex_len > 0)\r\nrate_ex_len += 2;\r\nif (ieee->current_network.capability & WLAN_CAPABILITY_IBSS)\r\natim_len = 4;\r\nelse\r\natim_len = 0;\r\nif ((ieee->current_network.mode == IEEE_G) ||\r\n(ieee->current_network.mode == IEEE_N_24G &&\r\nieee->pHTInfo->bCurSuppCCK)) {\r\nerp_len = 3;\r\nerpinfo_content = 0;\r\nif (ieee->current_network.buseprotection)\r\nerpinfo_content |= ERP_UseProtection;\r\n} else\r\nerp_len = 0;\r\ncrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\r\nencrypt = ieee->host_encrypt && crypt && crypt->ops &&\r\n((strcmp(crypt->ops->name, "R-WEP") == 0 || wpa_ie_len));\r\nif (ieee->pHTInfo->bCurrentHTSupport) {\r\ntmp_ht_cap_buf = (u8 *) &(ieee->pHTInfo->SelfHTCap);\r\ntmp_ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);\r\ntmp_ht_info_buf = (u8 *) &(ieee->pHTInfo->SelfHTInfo);\r\ntmp_ht_info_len = sizeof(ieee->pHTInfo->SelfHTInfo);\r\nHTConstructCapabilityElement(ieee, tmp_ht_cap_buf,\r\n&tmp_ht_cap_len, encrypt, false);\r\nHTConstructInfoElement(ieee, tmp_ht_info_buf, &tmp_ht_info_len,\r\nencrypt);\r\nif (pHTInfo->bRegRT2RTAggregation) {\r\ntmp_generic_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;\r\ntmp_generic_ie_len =\r\nsizeof(ieee->pHTInfo->szRT2RTAggBuffer);\r\nHTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf,\r\n&tmp_generic_ie_len);\r\n}\r\n}\r\nbeacon_size = sizeof(struct rtllib_probe_response)+2+\r\nssid_len + 3 + rate_len + rate_ex_len + atim_len + erp_len\r\n+ wpa_ie_len + ieee->tx_headroom;\r\nskb = dev_alloc_skb(beacon_size);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nbeacon_buf = (struct rtllib_probe_response *) skb_put(skb,\r\n(beacon_size - ieee->tx_headroom));\r\nether_addr_copy(beacon_buf->header.addr1, dest);\r\nether_addr_copy(beacon_buf->header.addr2, ieee->dev->dev_addr);\r\nether_addr_copy(beacon_buf->header.addr3, ieee->current_network.bssid);\r\nbeacon_buf->header.duration_id = 0;\r\nbeacon_buf->beacon_interval =\r\ncpu_to_le16(ieee->current_network.beacon_interval);\r\nbeacon_buf->capability =\r\ncpu_to_le16(ieee->current_network.capability &\r\nWLAN_CAPABILITY_IBSS);\r\nbeacon_buf->capability |=\r\ncpu_to_le16(ieee->current_network.capability &\r\nWLAN_CAPABILITY_SHORT_PREAMBLE);\r\nif (ieee->short_slot && (ieee->current_network.capability &\r\nWLAN_CAPABILITY_SHORT_SLOT_TIME))\r\nbeacon_buf->capability |=\r\ncpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);\r\ncrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\r\nif (encrypt)\r\nbeacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\r\nbeacon_buf->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_PROBE_RESP);\r\nbeacon_buf->info_element[0].id = MFIE_TYPE_SSID;\r\nbeacon_buf->info_element[0].len = ssid_len;\r\ntag = (u8 *) beacon_buf->info_element[0].data;\r\nmemcpy(tag, ssid, ssid_len);\r\ntag += ssid_len;\r\n*(tag++) = MFIE_TYPE_RATES;\r\n*(tag++) = rate_len-2;\r\nmemcpy(tag, ieee->current_network.rates, rate_len-2);\r\ntag += rate_len-2;\r\n*(tag++) = MFIE_TYPE_DS_SET;\r\n*(tag++) = 1;\r\n*(tag++) = ieee->current_network.channel;\r\nif (atim_len) {\r\nu16 val16;\r\n*(tag++) = MFIE_TYPE_IBSS_SET;\r\n*(tag++) = 2;\r\nval16 = ieee->current_network.atim_window;\r\nmemcpy((u8 *)tag, (u8 *)&val16, 2);\r\ntag += 2;\r\n}\r\nif (erp_len) {\r\n*(tag++) = MFIE_TYPE_ERP;\r\n*(tag++) = 1;\r\n*(tag++) = erpinfo_content;\r\n}\r\nif (rate_ex_len) {\r\n*(tag++) = MFIE_TYPE_RATES_EX;\r\n*(tag++) = rate_ex_len-2;\r\nmemcpy(tag, ieee->current_network.rates_ex, rate_ex_len-2);\r\ntag += rate_ex_len-2;\r\n}\r\nif (wpa_ie_len) {\r\nif (ieee->iw_mode == IW_MODE_ADHOC)\r\nmemcpy(&ieee->wpa_ie[14], &ieee->wpa_ie[8], 4);\r\nmemcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);\r\ntag += ieee->wpa_ie_len;\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)\r\n{\r\nstruct sk_buff *skb;\r\nu8 *tag;\r\nstruct lib80211_crypt_data *crypt;\r\nstruct rtllib_assoc_response_frame *assoc;\r\nshort encrypt;\r\nunsigned int rate_len = rtllib_MFIE_rate_len(ieee);\r\nint len = sizeof(struct rtllib_assoc_response_frame) + rate_len +\r\nieee->tx_headroom;\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nassoc = (struct rtllib_assoc_response_frame *)\r\nskb_put(skb, sizeof(struct rtllib_assoc_response_frame));\r\nassoc->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_ASSOC_RESP);\r\nether_addr_copy(assoc->header.addr1, dest);\r\nether_addr_copy(assoc->header.addr3, ieee->dev->dev_addr);\r\nether_addr_copy(assoc->header.addr2, ieee->dev->dev_addr);\r\nassoc->capability = cpu_to_le16(ieee->iw_mode == IW_MODE_MASTER ?\r\nWLAN_CAPABILITY_ESS : WLAN_CAPABILITY_IBSS);\r\nif (ieee->short_slot)\r\nassoc->capability |=\r\ncpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);\r\nif (ieee->host_encrypt)\r\ncrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\r\nelse\r\ncrypt = NULL;\r\nencrypt = (crypt && crypt->ops);\r\nif (encrypt)\r\nassoc->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\r\nassoc->status = 0;\r\nassoc->aid = cpu_to_le16(ieee->assoc_id);\r\nif (ieee->assoc_id == 0x2007)\r\nieee->assoc_id = 0;\r\nelse\r\nieee->assoc_id++;\r\ntag = (u8 *) skb_put(skb, rate_len);\r\nrtllib_MFIE_Brate(ieee, &tag);\r\nrtllib_MFIE_Grate(ieee, &tag);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *rtllib_auth_resp(struct rtllib_device *ieee, int status,\r\nu8 *dest)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct rtllib_authentication *auth;\r\nint len = ieee->tx_headroom + sizeof(struct rtllib_authentication) + 1;\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nskb->len = sizeof(struct rtllib_authentication);\r\nskb_reserve(skb, ieee->tx_headroom);\r\nauth = (struct rtllib_authentication *)\r\nskb_put(skb, sizeof(struct rtllib_authentication));\r\nauth->status = cpu_to_le16(status);\r\nauth->transaction = cpu_to_le16(2);\r\nauth->algorithm = cpu_to_le16(WLAN_AUTH_OPEN);\r\nether_addr_copy(auth->header.addr3, ieee->dev->dev_addr);\r\nether_addr_copy(auth->header.addr2, ieee->dev->dev_addr);\r\nether_addr_copy(auth->header.addr1, dest);\r\nauth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_AUTH);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *rtllib_null_func(struct rtllib_device *ieee, short pwr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rtllib_hdr_3addr *hdr;\r\nskb = dev_alloc_skb(sizeof(struct rtllib_hdr_3addr)+ieee->tx_headroom);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nhdr = (struct rtllib_hdr_3addr *)skb_put(skb,\r\nsizeof(struct rtllib_hdr_3addr));\r\nether_addr_copy(hdr->addr1, ieee->current_network.bssid);\r\nether_addr_copy(hdr->addr2, ieee->dev->dev_addr);\r\nether_addr_copy(hdr->addr3, ieee->current_network.bssid);\r\nhdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_DATA |\r\nRTLLIB_STYPE_NULLFUNC | RTLLIB_FCTL_TODS |\r\n(pwr ? RTLLIB_FCTL_PM : 0));\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *rtllib_pspoll_func(struct rtllib_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rtllib_pspoll_hdr *hdr;\r\nskb = dev_alloc_skb(sizeof(struct rtllib_pspoll_hdr)+ieee->tx_headroom);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nhdr = (struct rtllib_pspoll_hdr *)skb_put(skb,\r\nsizeof(struct rtllib_pspoll_hdr));\r\nether_addr_copy(hdr->bssid, ieee->current_network.bssid);\r\nether_addr_copy(hdr->ta, ieee->dev->dev_addr);\r\nhdr->aid = cpu_to_le16(ieee->assoc_id | 0xc000);\r\nhdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_CTL | RTLLIB_STYPE_PSPOLL |\r\nRTLLIB_FCTL_PM);\r\nreturn skb;\r\n}\r\nstatic void rtllib_resp_to_assoc_rq(struct rtllib_device *ieee, u8 *dest)\r\n{\r\nstruct sk_buff *buf = rtllib_assoc_resp(ieee, dest);\r\nif (buf)\r\nsoftmac_mgmt_xmit(buf, ieee);\r\n}\r\nstatic void rtllib_resp_to_auth(struct rtllib_device *ieee, int s, u8 *dest)\r\n{\r\nstruct sk_buff *buf = rtllib_auth_resp(ieee, s, dest);\r\nif (buf)\r\nsoftmac_mgmt_xmit(buf, ieee);\r\n}\r\nstatic void rtllib_resp_to_probe(struct rtllib_device *ieee, u8 *dest)\r\n{\r\nstruct sk_buff *buf = rtllib_probe_resp(ieee, dest);\r\nif (buf)\r\nsoftmac_mgmt_xmit(buf, ieee);\r\n}\r\ninline int SecIsInPMKIDList(struct rtllib_device *ieee, u8 *bssid)\r\n{\r\nint i = 0;\r\ndo {\r\nif ((ieee->PMKIDList[i].bUsed) &&\r\n(memcmp(ieee->PMKIDList[i].Bssid, bssid, ETH_ALEN) == 0))\r\nbreak;\r\ni++;\r\n} while (i < NUM_PMKID_CACHE);\r\nif (i == NUM_PMKID_CACHE)\r\ni = -1;\r\nreturn i;\r\n}\r\ninline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,\r\nstruct rtllib_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rtllib_assoc_request_frame *hdr;\r\nu8 *tag, *ies;\r\nint i;\r\nu8 *ht_cap_buf = NULL;\r\nu8 ht_cap_len = 0;\r\nu8 *realtek_ie_buf = NULL;\r\nu8 realtek_ie_len = 0;\r\nint wpa_ie_len = ieee->wpa_ie_len;\r\nint wps_ie_len = ieee->wps_ie_len;\r\nunsigned int ckip_ie_len = 0;\r\nunsigned int ccxrm_ie_len = 0;\r\nunsigned int cxvernum_ie_len = 0;\r\nstruct lib80211_crypt_data *crypt;\r\nint encrypt;\r\nint PMKCacheIdx;\r\nunsigned int rate_len = (beacon->rates_len ?\r\n(beacon->rates_len + 2) : 0) +\r\n(beacon->rates_ex_len ? (beacon->rates_ex_len) +\r\n2 : 0);\r\nunsigned int wmm_info_len = beacon->qos_data.supported ? 9 : 0;\r\nunsigned int turbo_info_len = beacon->Turbo_Enable ? 9 : 0;\r\nint len = 0;\r\ncrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\r\nif (crypt != NULL)\r\nencrypt = ieee->host_encrypt && crypt && crypt->ops &&\r\n((strcmp(crypt->ops->name, "R-WEP") == 0 ||\r\nwpa_ie_len));\r\nelse\r\nencrypt = 0;\r\nif ((ieee->rtllib_ap_sec_type &&\r\n(ieee->rtllib_ap_sec_type(ieee) & SEC_ALG_TKIP)) ||\r\nieee->bForcedBgMode) {\r\nieee->pHTInfo->bEnableHT = 0;\r\nieee->mode = WIRELESS_MODE_G;\r\n}\r\nif (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {\r\nht_cap_buf = (u8 *)&(ieee->pHTInfo->SelfHTCap);\r\nht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);\r\nHTConstructCapabilityElement(ieee, ht_cap_buf, &ht_cap_len,\r\nencrypt, true);\r\nif (ieee->pHTInfo->bCurrentRT2RTAggregation) {\r\nrealtek_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;\r\nrealtek_ie_len =\r\nsizeof(ieee->pHTInfo->szRT2RTAggBuffer);\r\nHTConstructRT2RTAggElement(ieee, realtek_ie_buf,\r\n&realtek_ie_len);\r\n}\r\n}\r\nif (beacon->bCkipSupported)\r\nckip_ie_len = 30+2;\r\nif (beacon->bCcxRmEnable)\r\nccxrm_ie_len = 6+2;\r\nif (beacon->BssCcxVerNumber >= 2)\r\ncxvernum_ie_len = 5+2;\r\nPMKCacheIdx = SecIsInPMKIDList(ieee, ieee->current_network.bssid);\r\nif (PMKCacheIdx >= 0) {\r\nwpa_ie_len += 18;\r\nnetdev_info(ieee->dev, "[PMK cache]: WPA2 IE length: %x\n",\r\nwpa_ie_len);\r\n}\r\nlen = sizeof(struct rtllib_assoc_request_frame) + 2\r\n+ beacon->ssid_len\r\n+ rate_len\r\n+ wpa_ie_len\r\n+ wps_ie_len\r\n+ wmm_info_len\r\n+ turbo_info_len\r\n+ ht_cap_len\r\n+ realtek_ie_len\r\n+ ckip_ie_len\r\n+ ccxrm_ie_len\r\n+ cxvernum_ie_len\r\n+ ieee->tx_headroom;\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nhdr = (struct rtllib_assoc_request_frame *)\r\nskb_put(skb, sizeof(struct rtllib_assoc_request_frame) + 2);\r\nhdr->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_ASSOC_REQ);\r\nhdr->header.duration_id = cpu_to_le16(37);\r\nether_addr_copy(hdr->header.addr1, beacon->bssid);\r\nether_addr_copy(hdr->header.addr2, ieee->dev->dev_addr);\r\nether_addr_copy(hdr->header.addr3, beacon->bssid);\r\nether_addr_copy(ieee->ap_mac_addr, beacon->bssid);\r\nhdr->capability = cpu_to_le16(WLAN_CAPABILITY_ESS);\r\nif (beacon->capability & WLAN_CAPABILITY_PRIVACY)\r\nhdr->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\r\nif (beacon->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\r\nhdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);\r\nif (ieee->short_slot &&\r\n(beacon->capability&WLAN_CAPABILITY_SHORT_SLOT_TIME))\r\nhdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);\r\nhdr->listen_interval = cpu_to_le16(beacon->listen_interval);\r\nhdr->info_element[0].id = MFIE_TYPE_SSID;\r\nhdr->info_element[0].len = beacon->ssid_len;\r\ntag = skb_put(skb, beacon->ssid_len);\r\nmemcpy(tag, beacon->ssid, beacon->ssid_len);\r\ntag = skb_put(skb, rate_len);\r\nif (beacon->rates_len) {\r\n*tag++ = MFIE_TYPE_RATES;\r\n*tag++ = beacon->rates_len;\r\nfor (i = 0; i < beacon->rates_len; i++)\r\n*tag++ = beacon->rates[i];\r\n}\r\nif (beacon->rates_ex_len) {\r\n*tag++ = MFIE_TYPE_RATES_EX;\r\n*tag++ = beacon->rates_ex_len;\r\nfor (i = 0; i < beacon->rates_ex_len; i++)\r\n*tag++ = beacon->rates_ex[i];\r\n}\r\nif (beacon->bCkipSupported) {\r\nstatic const u8 AironetIeOui[] = {0x00, 0x01, 0x66};\r\nu8 CcxAironetBuf[30];\r\nstruct octet_string osCcxAironetIE;\r\nmemset(CcxAironetBuf, 0, 30);\r\nosCcxAironetIE.Octet = CcxAironetBuf;\r\nosCcxAironetIE.Length = sizeof(CcxAironetBuf);\r\nmemcpy(osCcxAironetIE.Octet, AironetIeOui,\r\nsizeof(AironetIeOui));\r\nosCcxAironetIE.Octet[IE_CISCO_FLAG_POSITION] |=\r\n(SUPPORT_CKIP_PK|SUPPORT_CKIP_MIC);\r\ntag = skb_put(skb, ckip_ie_len);\r\n*tag++ = MFIE_TYPE_AIRONET;\r\n*tag++ = osCcxAironetIE.Length;\r\nmemcpy(tag, osCcxAironetIE.Octet, osCcxAironetIE.Length);\r\ntag += osCcxAironetIE.Length;\r\n}\r\nif (beacon->bCcxRmEnable) {\r\nstatic const u8 CcxRmCapBuf[] = {0x00, 0x40, 0x96, 0x01, 0x01,\r\n0x00};\r\nstruct octet_string osCcxRmCap;\r\nosCcxRmCap.Octet = (u8 *) CcxRmCapBuf;\r\nosCcxRmCap.Length = sizeof(CcxRmCapBuf);\r\ntag = skb_put(skb, ccxrm_ie_len);\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = osCcxRmCap.Length;\r\nmemcpy(tag, osCcxRmCap.Octet, osCcxRmCap.Length);\r\ntag += osCcxRmCap.Length;\r\n}\r\nif (beacon->BssCcxVerNumber >= 2) {\r\nu8 CcxVerNumBuf[] = {0x00, 0x40, 0x96, 0x03, 0x00};\r\nstruct octet_string osCcxVerNum;\r\nCcxVerNumBuf[4] = beacon->BssCcxVerNumber;\r\nosCcxVerNum.Octet = CcxVerNumBuf;\r\nosCcxVerNum.Length = sizeof(CcxVerNumBuf);\r\ntag = skb_put(skb, cxvernum_ie_len);\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = osCcxVerNum.Length;\r\nmemcpy(tag, osCcxVerNum.Octet, osCcxVerNum.Length);\r\ntag += osCcxVerNum.Length;\r\n}\r\nif (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {\r\nif (ieee->pHTInfo->ePeerHTSpecVer != HT_SPEC_VER_EWC) {\r\ntag = skb_put(skb, ht_cap_len);\r\n*tag++ = MFIE_TYPE_HT_CAP;\r\n*tag++ = ht_cap_len - 2;\r\nmemcpy(tag, ht_cap_buf, ht_cap_len - 2);\r\ntag += ht_cap_len - 2;\r\n}\r\n}\r\nif (wpa_ie_len) {\r\ntag = skb_put(skb, ieee->wpa_ie_len);\r\nmemcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);\r\nif (PMKCacheIdx >= 0) {\r\ntag = skb_put(skb, 18);\r\n*tag = 1;\r\n*(tag + 1) = 0;\r\nmemcpy((tag + 2), &ieee->PMKIDList[PMKCacheIdx].PMKID,\r\n16);\r\n}\r\n}\r\nif (wmm_info_len) {\r\ntag = skb_put(skb, wmm_info_len);\r\nrtllib_WMM_Info(ieee, &tag);\r\n}\r\nif (wps_ie_len && ieee->wps_ie) {\r\ntag = skb_put(skb, wps_ie_len);\r\nmemcpy(tag, ieee->wps_ie, wps_ie_len);\r\n}\r\ntag = skb_put(skb, turbo_info_len);\r\nif (turbo_info_len)\r\nrtllib_TURBO_Info(ieee, &tag);\r\nif (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {\r\nif (ieee->pHTInfo->ePeerHTSpecVer == HT_SPEC_VER_EWC) {\r\ntag = skb_put(skb, ht_cap_len);\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = ht_cap_len - 2;\r\nmemcpy(tag, ht_cap_buf, ht_cap_len - 2);\r\ntag += ht_cap_len - 2;\r\n}\r\nif (ieee->pHTInfo->bCurrentRT2RTAggregation) {\r\ntag = skb_put(skb, realtek_ie_len);\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = realtek_ie_len - 2;\r\nmemcpy(tag, realtek_ie_buf, realtek_ie_len - 2);\r\n}\r\n}\r\nkfree(ieee->assocreq_ies);\r\nieee->assocreq_ies = NULL;\r\nies = &(hdr->info_element[0].id);\r\nieee->assocreq_ies_len = (skb->data + skb->len) - ies;\r\nieee->assocreq_ies = kmalloc(ieee->assocreq_ies_len, GFP_ATOMIC);\r\nif (ieee->assocreq_ies)\r\nmemcpy(ieee->assocreq_ies, ies, ieee->assocreq_ies_len);\r\nelse {\r\nnetdev_info(ieee->dev,\r\n"%s()Warning: can't alloc memory for assocreq_ies\n",\r\n__func__);\r\nieee->assocreq_ies_len = 0;\r\n}\r\nreturn skb;\r\n}\r\nstatic void rtllib_associate_abort(struct rtllib_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nieee->associate_seq++;\r\nif (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING) {\r\nnetdev_dbg(ieee->dev, "Authentication failed\n");\r\nieee->softmac_stats.no_auth_rs++;\r\n} else {\r\nnetdev_dbg(ieee->dev, "Association failed\n");\r\nieee->softmac_stats.no_ass_rs++;\r\n}\r\nieee->state = RTLLIB_ASSOCIATING_RETRY;\r\nschedule_delayed_work(&ieee->associate_retry_wq,\r\nRTLLIB_SOFTMAC_ASSOC_RETRY_TIME);\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic void rtllib_associate_abort_cb(unsigned long dev)\r\n{\r\nrtllib_associate_abort((struct rtllib_device *) dev);\r\n}\r\nstatic void rtllib_associate_step1(struct rtllib_device *ieee, u8 *daddr)\r\n{\r\nstruct rtllib_network *beacon = &ieee->current_network;\r\nstruct sk_buff *skb;\r\nnetdev_dbg(ieee->dev, "Stopping scan\n");\r\nieee->softmac_stats.tx_auth_rq++;\r\nskb = rtllib_authentication_req(beacon, ieee, 0, daddr);\r\nif (!skb)\r\nrtllib_associate_abort(ieee);\r\nelse {\r\nieee->state = RTLLIB_ASSOCIATING_AUTHENTICATING;\r\nnetdev_dbg(ieee->dev, "Sending authentication request\n");\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nif (!timer_pending(&ieee->associate_timer)) {\r\nieee->associate_timer.expires = jiffies + (HZ / 2);\r\nadd_timer(&ieee->associate_timer);\r\n}\r\n}\r\n}\r\nstatic void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge,\r\nint chlen)\r\n{\r\nu8 *c;\r\nstruct sk_buff *skb;\r\nstruct rtllib_network *beacon = &ieee->current_network;\r\nieee->associate_seq++;\r\nieee->softmac_stats.tx_auth_rq++;\r\nskb = rtllib_authentication_req(beacon, ieee, chlen + 2, beacon->bssid);\r\nif (!skb)\r\nrtllib_associate_abort(ieee);\r\nelse {\r\nc = skb_put(skb, chlen+2);\r\n*(c++) = MFIE_TYPE_CHALLENGE;\r\n*(c++) = chlen;\r\nmemcpy(c, challenge, chlen);\r\nnetdev_dbg(ieee->dev,\r\n"Sending authentication challenge response\n");\r\nrtllib_encrypt_fragment(ieee, skb,\r\nsizeof(struct rtllib_hdr_3addr));\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nmod_timer(&ieee->associate_timer, jiffies + (HZ/2));\r\n}\r\nkfree(challenge);\r\n}\r\nstatic void rtllib_associate_step2(struct rtllib_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rtllib_network *beacon = &ieee->current_network;\r\ndel_timer_sync(&ieee->associate_timer);\r\nnetdev_dbg(ieee->dev, "Sending association request\n");\r\nieee->softmac_stats.tx_ass_rq++;\r\nskb = rtllib_association_req(beacon, ieee);\r\nif (!skb)\r\nrtllib_associate_abort(ieee);\r\nelse {\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nmod_timer(&ieee->associate_timer, jiffies + (HZ/2));\r\n}\r\n}\r\nstatic void rtllib_associate_complete_wq(void *data)\r\n{\r\nstruct rtllib_device *ieee = (struct rtllib_device *)\r\ncontainer_of_work_rsl(data,\r\nstruct rtllib_device,\r\nassociate_complete_wq);\r\nstruct rt_pwr_save_ctrl *pPSC = &(ieee->PowerSaveControl);\r\nnetdev_info(ieee->dev, "Associated successfully\n");\r\nif (!ieee->is_silent_reset) {\r\nnetdev_info(ieee->dev, "normal associate\n");\r\nnotify_wx_assoc_event(ieee);\r\n}\r\nnetif_carrier_on(ieee->dev);\r\nieee->is_roaming = false;\r\nif (rtllib_is_54g(&ieee->current_network) &&\r\n(ieee->modulation & RTLLIB_OFDM_MODULATION)) {\r\nieee->rate = 108;\r\nnetdev_info(ieee->dev, "Using G rates:%d\n", ieee->rate);\r\n} else {\r\nieee->rate = 22;\r\nieee->SetWirelessMode(ieee->dev, IEEE_B);\r\nnetdev_info(ieee->dev, "Using B rates:%d\n", ieee->rate);\r\n}\r\nif (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {\r\nnetdev_info(ieee->dev, "Successfully associated, ht enabled\n");\r\nHTOnAssocRsp(ieee);\r\n} else {\r\nnetdev_info(ieee->dev,\r\n"Successfully associated, ht not enabled(%d, %d)\n",\r\nieee->pHTInfo->bCurrentHTSupport,\r\nieee->pHTInfo->bEnableHT);\r\nmemset(ieee->dot11HTOperationalRateSet, 0, 16);\r\n}\r\nieee->LinkDetectInfo.SlotNum = 2 * (1 +\r\nieee->current_network.beacon_interval /\r\n500);\r\nif (ieee->LinkDetectInfo.NumRecvBcnInPeriod == 0 ||\r\nieee->LinkDetectInfo.NumRecvDataInPeriod == 0) {\r\nieee->LinkDetectInfo.NumRecvBcnInPeriod = 1;\r\nieee->LinkDetectInfo.NumRecvDataInPeriod = 1;\r\n}\r\npPSC->LpsIdleCount = 0;\r\nieee->link_change(ieee->dev);\r\nif (ieee->is_silent_reset) {\r\nnetdev_info(ieee->dev, "silent reset associate\n");\r\nieee->is_silent_reset = false;\r\n}\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\n}\r\nstatic void rtllib_sta_send_associnfo(struct rtllib_device *ieee)\r\n{\r\n}\r\nstatic void rtllib_associate_complete(struct rtllib_device *ieee)\r\n{\r\ndel_timer_sync(&ieee->associate_timer);\r\nieee->state = RTLLIB_LINKED;\r\nrtllib_sta_send_associnfo(ieee);\r\nschedule_work(&ieee->associate_complete_wq);\r\n}\r\nstatic void rtllib_associate_procedure_wq(void *data)\r\n{\r\nstruct rtllib_device *ieee = container_of_dwork_rsl(data,\r\nstruct rtllib_device,\r\nassociate_procedure_wq);\r\nrtllib_stop_scan_syncro(ieee);\r\nif (ieee->rtllib_ips_leave != NULL)\r\nieee->rtllib_ips_leave(ieee->dev);\r\ndown(&ieee->wx_sem);\r\nif (ieee->data_hard_stop)\r\nieee->data_hard_stop(ieee->dev);\r\nrtllib_stop_scan(ieee);\r\nRT_TRACE(COMP_DBG, "===>%s(), chan:%d\n", __func__,\r\nieee->current_network.channel);\r\nHTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);\r\nif (ieee->eRFPowerState == eRfOff) {\r\nRT_TRACE(COMP_DBG,\r\n"=============>%s():Rf state is eRfOff, schedule ipsleave wq again,return\n",\r\n__func__);\r\nif (ieee->rtllib_ips_leave_wq != NULL)\r\nieee->rtllib_ips_leave_wq(ieee->dev);\r\nup(&ieee->wx_sem);\r\nreturn;\r\n}\r\nieee->associate_seq = 1;\r\nrtllib_associate_step1(ieee, ieee->current_network.bssid);\r\nup(&ieee->wx_sem);\r\n}\r\ninline void rtllib_softmac_new_net(struct rtllib_device *ieee,\r\nstruct rtllib_network *net)\r\n{\r\nu8 tmp_ssid[IW_ESSID_MAX_SIZE + 1];\r\nint tmp_ssid_len = 0;\r\nshort apset, ssidset, ssidbroad, apmatch, ssidmatch;\r\nif (ieee->state != RTLLIB_NOLINK)\r\nreturn;\r\nif ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability &\r\nWLAN_CAPABILITY_ESS))\r\nreturn;\r\nif ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability &\r\nWLAN_CAPABILITY_IBSS))\r\nreturn;\r\nif ((ieee->iw_mode == IW_MODE_ADHOC) &&\r\n(net->channel > ieee->ibss_maxjoin_chal))\r\nreturn;\r\nif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC) {\r\napset = ieee->wap_set;\r\nssidset = ieee->ssid_set;\r\nssidbroad = !(net->ssid_len == 0 || net->ssid[0] == '\0');\r\napmatch = (memcmp(ieee->current_network.bssid, net->bssid,\r\nETH_ALEN) == 0);\r\nif (!ssidbroad) {\r\nssidmatch = (ieee->current_network.ssid_len ==\r\nnet->hidden_ssid_len) &&\r\n(!strncmp(ieee->current_network.ssid,\r\nnet->hidden_ssid, net->hidden_ssid_len));\r\nif (net->hidden_ssid_len > 0) {\r\nstrncpy(net->ssid, net->hidden_ssid,\r\nnet->hidden_ssid_len);\r\nnet->ssid_len = net->hidden_ssid_len;\r\nssidbroad = 1;\r\n}\r\n} else\r\nssidmatch =\r\n(ieee->current_network.ssid_len == net->ssid_len) &&\r\n(!strncmp(ieee->current_network.ssid, net->ssid,\r\nnet->ssid_len));\r\nif ((apset && apmatch &&\r\n((ssidset && ssidbroad && ssidmatch) ||\r\n(ssidbroad && !ssidset) || (!ssidbroad && ssidset))) ||\r\n(!apset && ssidset && ssidbroad && ssidmatch) ||\r\n(ieee->is_roaming && ssidset && ssidbroad && ssidmatch)) {\r\nif (!ssidbroad) {\r\nstrncpy(tmp_ssid, ieee->current_network.ssid,\r\nIW_ESSID_MAX_SIZE);\r\ntmp_ssid_len = ieee->current_network.ssid_len;\r\n}\r\nmemcpy(&ieee->current_network, net,\r\nsizeof(struct rtllib_network));\r\nif (!ssidbroad) {\r\nstrncpy(ieee->current_network.ssid, tmp_ssid,\r\nIW_ESSID_MAX_SIZE);\r\nieee->current_network.ssid_len = tmp_ssid_len;\r\n}\r\nnetdev_info(ieee->dev,\r\n"Linking with %s,channel:%d, qos:%d, myHT:%d, networkHT:%d, mode:%x cur_net.flags:0x%x\n",\r\nieee->current_network.ssid,\r\nieee->current_network.channel,\r\nieee->current_network.qos_data.supported,\r\nieee->pHTInfo->bEnableHT,\r\nieee->current_network.bssht.bdSupportHT,\r\nieee->current_network.mode,\r\nieee->current_network.flags);\r\nif ((rtllib_act_scanning(ieee, false)) &&\r\n!(ieee->softmac_features & IEEE_SOFTMAC_SCAN))\r\nrtllib_stop_scan_syncro(ieee);\r\nHTResetIOTSetting(ieee->pHTInfo);\r\nieee->wmm_acm = 0;\r\nif (ieee->iw_mode == IW_MODE_INFRA) {\r\nieee->AsocRetryCount = 0;\r\nif ((ieee->current_network.qos_data.supported == 1) &&\r\nieee->current_network.bssht.bdSupportHT)\r\nHTResetSelfAndSavePeerSetting(ieee,\r\n&(ieee->current_network));\r\nelse\r\nieee->pHTInfo->bCurrentHTSupport =\r\nfalse;\r\nieee->state = RTLLIB_ASSOCIATING;\r\nif (ieee->LedControlHandler != NULL)\r\nieee->LedControlHandler(ieee->dev,\r\nLED_CTL_START_TO_LINK);\r\nschedule_delayed_work(\r\n&ieee->associate_procedure_wq, 0);\r\n} else {\r\nif (rtllib_is_54g(&ieee->current_network) &&\r\n(ieee->modulation &\r\nRTLLIB_OFDM_MODULATION)) {\r\nieee->rate = 108;\r\nieee->SetWirelessMode(ieee->dev,\r\nIEEE_G);\r\nnetdev_info(ieee->dev,\r\n"Using G rates\n");\r\n} else {\r\nieee->rate = 22;\r\nieee->SetWirelessMode(ieee->dev,\r\nIEEE_B);\r\nnetdev_info(ieee->dev,\r\n"Using B rates\n");\r\n}\r\nmemset(ieee->dot11HTOperationalRateSet, 0, 16);\r\nieee->state = RTLLIB_LINKED;\r\n}\r\n}\r\n}\r\n}\r\nstatic void rtllib_softmac_check_all_nets(struct rtllib_device *ieee)\r\n{\r\nunsigned long flags;\r\nstruct rtllib_network *target;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nlist_for_each_entry(target, &ieee->network_list, list) {\r\nif (ieee->state != RTLLIB_NOLINK)\r\nbreak;\r\nif (ieee->scan_age == 0 || time_after(target->last_scanned +\r\nieee->scan_age, jiffies))\r\nrtllib_softmac_new_net(ieee, target);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic inline u16 auth_parse(struct net_device *dev, struct sk_buff *skb,\r\nu8 **challenge, int *chlen)\r\n{\r\nstruct rtllib_authentication *a;\r\nu8 *t;\r\nif (skb->len < (sizeof(struct rtllib_authentication) -\r\nsizeof(struct rtllib_info_element))) {\r\nnetdev_dbg(dev, "invalid len in auth resp: %d\n", skb->len);\r\nreturn 0xcafe;\r\n}\r\n*challenge = NULL;\r\na = (struct rtllib_authentication *) skb->data;\r\nif (skb->len > (sizeof(struct rtllib_authentication) + 3)) {\r\nt = skb->data + sizeof(struct rtllib_authentication);\r\nif (*(t++) == MFIE_TYPE_CHALLENGE) {\r\n*chlen = *(t++);\r\n*challenge = kmemdup(t, *chlen, GFP_ATOMIC);\r\nif (!*challenge)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn le16_to_cpu(a->status);\r\n}\r\nstatic int auth_rq_parse(struct net_device *dev, struct sk_buff *skb, u8 *dest)\r\n{\r\nstruct rtllib_authentication *a;\r\nif (skb->len < (sizeof(struct rtllib_authentication) -\r\nsizeof(struct rtllib_info_element))) {\r\nnetdev_dbg(dev, "invalid len in auth request: %d\n", skb->len);\r\nreturn -1;\r\n}\r\na = (struct rtllib_authentication *) skb->data;\r\nether_addr_copy(dest, a->header.addr2);\r\nif (le16_to_cpu(a->algorithm) != WLAN_AUTH_OPEN)\r\nreturn WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;\r\nreturn WLAN_STATUS_SUCCESS;\r\n}\r\nstatic short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb,\r\nu8 *src)\r\n{\r\nu8 *tag;\r\nu8 *skbend;\r\nu8 *ssid = NULL;\r\nu8 ssidlen = 0;\r\nstruct rtllib_hdr_3addr *header =\r\n(struct rtllib_hdr_3addr *) skb->data;\r\nbool bssid_match;\r\nif (skb->len < sizeof(struct rtllib_hdr_3addr))\r\nreturn -1;\r\nbssid_match =\r\n(!ether_addr_equal(header->addr3, ieee->current_network.bssid)) &&\r\n(!is_broadcast_ether_addr(header->addr3));\r\nif (bssid_match)\r\nreturn -1;\r\nether_addr_copy(src, header->addr2);\r\nskbend = (u8 *)skb->data + skb->len;\r\ntag = skb->data + sizeof(struct rtllib_hdr_3addr);\r\nwhile (tag + 1 < skbend) {\r\nif (*tag == 0) {\r\nssid = tag + 2;\r\nssidlen = *(tag + 1);\r\nbreak;\r\n}\r\ntag++;\r\ntag = tag + *(tag);\r\ntag++;\r\n}\r\nif (ssidlen == 0)\r\nreturn 1;\r\nif (!ssid)\r\nreturn 1;\r\nreturn !strncmp(ssid, ieee->current_network.ssid, ssidlen);\r\n}\r\nstatic int assoc_rq_parse(struct net_device *dev, struct sk_buff *skb, u8 *dest)\r\n{\r\nstruct rtllib_assoc_request_frame *a;\r\nif (skb->len < (sizeof(struct rtllib_assoc_request_frame) -\r\nsizeof(struct rtllib_info_element))) {\r\nnetdev_dbg(dev, "invalid len in auth request:%d\n", skb->len);\r\nreturn -1;\r\n}\r\na = (struct rtllib_assoc_request_frame *) skb->data;\r\nether_addr_copy(dest, a->header.addr2);\r\nreturn 0;\r\n}\r\nstatic inline u16 assoc_parse(struct rtllib_device *ieee, struct sk_buff *skb,\r\nint *aid)\r\n{\r\nstruct rtllib_assoc_response_frame *response_head;\r\nu16 status_code;\r\nif (skb->len < sizeof(struct rtllib_assoc_response_frame)) {\r\nnetdev_dbg(ieee->dev, "Invalid len in auth resp: %d\n",\r\nskb->len);\r\nreturn 0xcafe;\r\n}\r\nresponse_head = (struct rtllib_assoc_response_frame *) skb->data;\r\n*aid = le16_to_cpu(response_head->aid) & 0x3fff;\r\nstatus_code = le16_to_cpu(response_head->status);\r\nif ((status_code == WLAN_STATUS_ASSOC_DENIED_RATES ||\r\nstatus_code == WLAN_STATUS_CAPS_UNSUPPORTED) &&\r\n((ieee->mode == IEEE_G) &&\r\n(ieee->current_network.mode == IEEE_N_24G) &&\r\n(ieee->AsocRetryCount++ < (RT_ASOC_RETRY_LIMIT-1)))) {\r\nieee->pHTInfo->IOTAction |= HT_IOT_ACT_PURE_N_MODE;\r\n} else {\r\nieee->AsocRetryCount = 0;\r\n}\r\nreturn le16_to_cpu(response_head->status);\r\n}\r\nvoid rtllib_rx_probe_rq(struct rtllib_device *ieee, struct sk_buff *skb)\r\n{\r\nu8 dest[ETH_ALEN];\r\nieee->softmac_stats.rx_probe_rq++;\r\nif (probe_rq_parse(ieee, skb, dest) > 0) {\r\nieee->softmac_stats.tx_probe_rs++;\r\nrtllib_resp_to_probe(ieee, dest);\r\n}\r\n}\r\nstatic inline void rtllib_rx_auth_rq(struct rtllib_device *ieee,\r\nstruct sk_buff *skb)\r\n{\r\nu8 dest[ETH_ALEN];\r\nint status;\r\nieee->softmac_stats.rx_auth_rq++;\r\nstatus = auth_rq_parse(ieee->dev, skb, dest);\r\nif (status != -1)\r\nrtllib_resp_to_auth(ieee, status, dest);\r\n}\r\nstatic inline void rtllib_rx_assoc_rq(struct rtllib_device *ieee,\r\nstruct sk_buff *skb)\r\n{\r\nu8 dest[ETH_ALEN];\r\nieee->softmac_stats.rx_ass_rq++;\r\nif (assoc_rq_parse(ieee->dev, skb, dest) != -1)\r\nrtllib_resp_to_assoc_rq(ieee, dest);\r\nnetdev_info(ieee->dev, "New client associated: %pM\n", dest);\r\n}\r\nvoid rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee, short pwr)\r\n{\r\nstruct sk_buff *buf = rtllib_null_func(ieee, pwr);\r\nif (buf)\r\nsoftmac_ps_mgmt_xmit(buf, ieee);\r\n}\r\nvoid rtllib_sta_ps_send_pspoll_frame(struct rtllib_device *ieee)\r\n{\r\nstruct sk_buff *buf = rtllib_pspoll_func(ieee);\r\nif (buf)\r\nsoftmac_ps_mgmt_xmit(buf, ieee);\r\n}\r\nstatic short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)\r\n{\r\nint timeout = ieee->ps_timeout;\r\nu8 dtim;\r\nstruct rt_pwr_save_ctrl *pPSC = &(ieee->PowerSaveControl);\r\nif (ieee->LPSDelayCnt) {\r\nieee->LPSDelayCnt--;\r\nreturn 0;\r\n}\r\ndtim = ieee->current_network.dtim_data;\r\nif (!(dtim & RTLLIB_DTIM_VALID))\r\nreturn 0;\r\ntimeout = ieee->current_network.beacon_interval;\r\nieee->current_network.dtim_data = RTLLIB_DTIM_INVALID;\r\nif (dtim & (RTLLIB_DTIM_UCAST & ieee->ps))\r\nreturn 2;\r\nif (!time_after(jiffies,\r\ndev_trans_start(ieee->dev) + msecs_to_jiffies(timeout)))\r\nreturn 0;\r\nif (!time_after(jiffies,\r\nieee->last_rx_ps_time + msecs_to_jiffies(timeout)))\r\nreturn 0;\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE) &&\r\n(ieee->mgmt_queue_tail != ieee->mgmt_queue_head))\r\nreturn 0;\r\nif (time) {\r\nif (ieee->bAwakePktSent) {\r\npPSC->LPSAwakeIntvl = 1;\r\n} else {\r\nu8 MaxPeriod = 1;\r\nif (pPSC->LPSAwakeIntvl == 0)\r\npPSC->LPSAwakeIntvl = 1;\r\nif (pPSC->RegMaxLPSAwakeIntvl == 0)\r\nMaxPeriod = 1;\r\nelse if (pPSC->RegMaxLPSAwakeIntvl == 0xFF)\r\nMaxPeriod = ieee->current_network.dtim_period;\r\nelse\r\nMaxPeriod = pPSC->RegMaxLPSAwakeIntvl;\r\npPSC->LPSAwakeIntvl = (pPSC->LPSAwakeIntvl >=\r\nMaxPeriod) ? MaxPeriod :\r\n(pPSC->LPSAwakeIntvl + 1);\r\n}\r\n{\r\nu8 LPSAwakeIntvl_tmp = 0;\r\nu8 period = ieee->current_network.dtim_period;\r\nu8 count = ieee->current_network.tim.tim_count;\r\nif (count == 0) {\r\nif (pPSC->LPSAwakeIntvl > period)\r\nLPSAwakeIntvl_tmp = period +\r\n(pPSC->LPSAwakeIntvl -\r\nperiod) -\r\n((pPSC->LPSAwakeIntvl-period) %\r\nperiod);\r\nelse\r\nLPSAwakeIntvl_tmp = pPSC->LPSAwakeIntvl;\r\n} else {\r\nif (pPSC->LPSAwakeIntvl >\r\nieee->current_network.tim.tim_count)\r\nLPSAwakeIntvl_tmp = count +\r\n(pPSC->LPSAwakeIntvl - count) -\r\n((pPSC->LPSAwakeIntvl-count)%period);\r\nelse\r\nLPSAwakeIntvl_tmp = pPSC->LPSAwakeIntvl;\r\n}\r\n*time = ieee->current_network.last_dtim_sta_time\r\n+ msecs_to_jiffies(ieee->current_network.beacon_interval *\r\nLPSAwakeIntvl_tmp);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic inline void rtllib_sta_ps(struct rtllib_device *ieee)\r\n{\r\nu64 time;\r\nshort sleep;\r\nunsigned long flags, flags2;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif ((ieee->ps == RTLLIB_PS_DISABLED ||\r\nieee->iw_mode != IW_MODE_INFRA ||\r\nieee->state != RTLLIB_LINKED)) {\r\nRT_TRACE(COMP_DBG,\r\n"=====>%s(): no need to ps,wake up!! ieee->ps is %d, ieee->iw_mode is %d, ieee->state is %d\n",\r\n__func__, ieee->ps, ieee->iw_mode, ieee->state);\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nrtllib_sta_wakeup(ieee, 1);\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\nsleep = rtllib_sta_ps_sleep(ieee, &time);\r\nif (sleep == 0)\r\ngoto out;\r\nif (sleep == 1) {\r\nif (ieee->sta_sleep == LPS_IS_SLEEP) {\r\nieee->enter_sleep_state(ieee->dev, time);\r\n} else if (ieee->sta_sleep == LPS_IS_WAKE) {\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nif (ieee->ps_is_queue_empty(ieee->dev)) {\r\nieee->sta_sleep = LPS_WAIT_NULL_DATA_SEND;\r\nieee->ack_tx_to_ieee = 1;\r\nrtllib_sta_ps_send_null_frame(ieee, 1);\r\nieee->ps_time = time;\r\n}\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\nieee->bAwakePktSent = false;\r\n} else if (sleep == 2) {\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nrtllib_sta_wakeup(ieee, 1);\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl)\r\n{\r\nif (ieee->sta_sleep == LPS_IS_WAKE) {\r\nif (nl) {\r\nif (ieee->pHTInfo->IOTAction &\r\nHT_IOT_ACT_NULL_DATA_POWER_SAVING) {\r\nieee->ack_tx_to_ieee = 1;\r\nrtllib_sta_ps_send_null_frame(ieee, 0);\r\n} else {\r\nieee->ack_tx_to_ieee = 1;\r\nrtllib_sta_ps_send_pspoll_frame(ieee);\r\n}\r\n}\r\nreturn;\r\n}\r\nif (ieee->sta_sleep == LPS_IS_SLEEP)\r\nieee->sta_wake_up(ieee->dev);\r\nif (nl) {\r\nif (ieee->pHTInfo->IOTAction &\r\nHT_IOT_ACT_NULL_DATA_POWER_SAVING) {\r\nieee->ack_tx_to_ieee = 1;\r\nrtllib_sta_ps_send_null_frame(ieee, 0);\r\n} else {\r\nieee->ack_tx_to_ieee = 1;\r\nieee->polling = true;\r\nrtllib_sta_ps_send_pspoll_frame(ieee);\r\n}\r\n} else {\r\nieee->sta_sleep = LPS_IS_WAKE;\r\nieee->polling = false;\r\n}\r\n}\r\nvoid rtllib_ps_tx_ack(struct rtllib_device *ieee, short success)\r\n{\r\nunsigned long flags, flags2;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (ieee->sta_sleep == LPS_WAIT_NULL_DATA_SEND) {\r\nif (success) {\r\nieee->sta_sleep = LPS_IS_SLEEP;\r\nieee->enter_sleep_state(ieee->dev, ieee->ps_time);\r\n}\r\n} else {\r\nif ((ieee->sta_sleep == LPS_IS_WAKE) && !success) {\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nif (ieee->pHTInfo->IOTAction &\r\nHT_IOT_ACT_NULL_DATA_POWER_SAVING)\r\nrtllib_sta_ps_send_null_frame(ieee, 0);\r\nelse\r\nrtllib_sta_ps_send_pspoll_frame(ieee);\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic void rtllib_process_action(struct rtllib_device *ieee,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;\r\nu8 *act = rtllib_get_payload((struct rtllib_hdr *)header);\r\nu8 category = 0;\r\nif (act == NULL) {\r\nnetdev_warn(ieee->dev,\r\n"Error getting payload of action frame\n");\r\nreturn;\r\n}\r\ncategory = *act;\r\nact++;\r\nswitch (category) {\r\ncase ACT_CAT_BA:\r\nswitch (*act) {\r\ncase ACT_ADDBAREQ:\r\nrtllib_rx_ADDBAReq(ieee, skb);\r\nbreak;\r\ncase ACT_ADDBARSP:\r\nrtllib_rx_ADDBARsp(ieee, skb);\r\nbreak;\r\ncase ACT_DELBA:\r\nrtllib_rx_DELBA(ieee, skb);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ninline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats)\r\n{\r\nu16 errcode;\r\nint aid;\r\nu8 *ies;\r\nstruct rtllib_assoc_response_frame *assoc_resp;\r\nstruct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;\r\nu16 frame_ctl = le16_to_cpu(header->frame_ctl);\r\nnetdev_dbg(ieee->dev, "received [RE]ASSOCIATION RESPONSE (%d)\n",\r\nWLAN_FC_GET_STYPE(frame_ctl));\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\r\nieee->state == RTLLIB_ASSOCIATING_AUTHENTICATED &&\r\n(ieee->iw_mode == IW_MODE_INFRA)) {\r\nerrcode = assoc_parse(ieee, skb, &aid);\r\nif (!errcode) {\r\nstruct rtllib_network *network =\r\nkzalloc(sizeof(struct rtllib_network),\r\nGFP_ATOMIC);\r\nif (!network)\r\nreturn 1;\r\nieee->state = RTLLIB_LINKED;\r\nieee->assoc_id = aid;\r\nieee->softmac_stats.rx_ass_ok++;\r\nassoc_resp = (struct rtllib_assoc_response_frame *)skb->data;\r\nif (ieee->current_network.qos_data.supported == 1) {\r\nif (rtllib_parse_info_param(ieee, assoc_resp->info_element,\r\nrx_stats->len - sizeof(*assoc_resp),\r\nnetwork, rx_stats)) {\r\nkfree(network);\r\nreturn 1;\r\n}\r\nmemcpy(ieee->pHTInfo->PeerHTCapBuf,\r\nnetwork->bssht.bdHTCapBuf,\r\nnetwork->bssht.bdHTCapLen);\r\nmemcpy(ieee->pHTInfo->PeerHTInfoBuf,\r\nnetwork->bssht.bdHTInfoBuf,\r\nnetwork->bssht.bdHTInfoLen);\r\nif (ieee->handle_assoc_response != NULL)\r\nieee->handle_assoc_response(ieee->dev,\r\n(struct rtllib_assoc_response_frame *)header,\r\nnetwork);\r\n}\r\nkfree(network);\r\nkfree(ieee->assocresp_ies);\r\nieee->assocresp_ies = NULL;\r\nies = &(assoc_resp->info_element[0].id);\r\nieee->assocresp_ies_len = (skb->data + skb->len) - ies;\r\nieee->assocresp_ies = kmalloc(ieee->assocresp_ies_len,\r\nGFP_ATOMIC);\r\nif (ieee->assocresp_ies)\r\nmemcpy(ieee->assocresp_ies, ies,\r\nieee->assocresp_ies_len);\r\nelse {\r\nnetdev_info(ieee->dev,\r\n"%s()Warning: can't alloc memory for assocresp_ies\n",\r\n__func__);\r\nieee->assocresp_ies_len = 0;\r\n}\r\nrtllib_associate_complete(ieee);\r\n} else {\r\nieee->softmac_stats.rx_ass_err++;\r\nnetdev_info(ieee->dev,\r\n"Association response status code 0x%x\n",\r\nerrcode);\r\nif (ieee->AsocRetryCount < RT_ASOC_RETRY_LIMIT)\r\nschedule_delayed_work(\r\n&ieee->associate_procedure_wq, 0);\r\nelse\r\nrtllib_associate_abort(ieee);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)\r\n{\r\nu16 errcode;\r\nu8 *challenge;\r\nint chlen = 0;\r\nbool bSupportNmode = true, bHalfSupportNmode = false;\r\nerrcode = auth_parse(ieee->dev, skb, &challenge, &chlen);\r\nif (errcode) {\r\nieee->softmac_stats.rx_auth_rs_err++;\r\nnetdev_info(ieee->dev,\r\n"Authentication respose status code 0x%x", errcode);\r\nrtllib_associate_abort(ieee);\r\nreturn;\r\n}\r\nif (ieee->open_wep || !challenge) {\r\nieee->state = RTLLIB_ASSOCIATING_AUTHENTICATED;\r\nieee->softmac_stats.rx_auth_rs_ok++;\r\nif (!(ieee->pHTInfo->IOTAction & HT_IOT_ACT_PURE_N_MODE)) {\r\nif (!ieee->GetNmodeSupportBySecCfg(ieee->dev)) {\r\nif (IsHTHalfNmodeAPs(ieee)) {\r\nbSupportNmode = true;\r\nbHalfSupportNmode = true;\r\n} else {\r\nbSupportNmode = false;\r\nbHalfSupportNmode = false;\r\n}\r\n}\r\n}\r\nif (bSupportNmode) {\r\nieee->SetWirelessMode(ieee->dev,\r\nieee->current_network.mode);\r\n} else {\r\nieee->SetWirelessMode(ieee->dev, IEEE_G);\r\n}\r\nif ((ieee->current_network.mode == IEEE_N_24G) &&\r\nbHalfSupportNmode) {\r\nnetdev_info(ieee->dev, "======>enter half N mode\n");\r\nieee->bHalfWirelessN24GMode = true;\r\n} else {\r\nieee->bHalfWirelessN24GMode = false;\r\n}\r\nrtllib_associate_step2(ieee);\r\n} else {\r\nrtllib_auth_challenge(ieee, challenge, chlen);\r\n}\r\n}\r\ninline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats)\r\n{\r\nif (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) {\r\nif (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING &&\r\n(ieee->iw_mode == IW_MODE_INFRA)) {\r\nnetdev_dbg(ieee->dev,\r\n"Received authentication response");\r\nrtllib_rx_auth_resp(ieee, skb);\r\n} else if (ieee->iw_mode == IW_MODE_MASTER) {\r\nrtllib_rx_auth_rq(ieee, skb);\r\n}\r\n}\r\nreturn 0;\r\n}\r\ninline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)\r\n{\r\nstruct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;\r\nu16 frame_ctl;\r\nif (memcmp(header->addr3, ieee->current_network.bssid, ETH_ALEN) != 0)\r\nreturn 0;\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\r\nieee->state == RTLLIB_LINKED &&\r\n(ieee->iw_mode == IW_MODE_INFRA)) {\r\nframe_ctl = le16_to_cpu(header->frame_ctl);\r\nnetdev_info(ieee->dev,\r\n"==========>received disassoc/deauth(%x) frame, reason code:%x\n",\r\nWLAN_FC_GET_STYPE(frame_ctl),\r\n((struct rtllib_disassoc *)skb->data)->reason);\r\nieee->state = RTLLIB_ASSOCIATING;\r\nieee->softmac_stats.reassoc++;\r\nieee->is_roaming = true;\r\nieee->LinkDetectInfo.bBusyTraffic = false;\r\nrtllib_disassociate(ieee);\r\nRemovePeerTS(ieee, header->addr2);\r\nif (ieee->LedControlHandler != NULL)\r\nieee->LedControlHandler(ieee->dev,\r\nLED_CTL_START_TO_LINK);\r\nif (!(ieee->rtllib_ap_sec_type(ieee) &\r\n(SEC_ALG_CCMP|SEC_ALG_TKIP)))\r\nschedule_delayed_work(\r\n&ieee->associate_procedure_wq, 5);\r\n}\r\nreturn 0;\r\n}\r\ninline int rtllib_rx_frame_softmac(struct rtllib_device *ieee,\r\nstruct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats, u16 type,\r\nu16 stype)\r\n{\r\nstruct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;\r\nu16 frame_ctl;\r\nif (!ieee->proto_started)\r\nreturn 0;\r\nframe_ctl = le16_to_cpu(header->frame_ctl);\r\nswitch (WLAN_FC_GET_STYPE(frame_ctl)) {\r\ncase RTLLIB_STYPE_ASSOC_RESP:\r\ncase RTLLIB_STYPE_REASSOC_RESP:\r\nif (rtllib_rx_assoc_resp(ieee, skb, rx_stats) == 1)\r\nreturn 1;\r\nbreak;\r\ncase RTLLIB_STYPE_ASSOC_REQ:\r\ncase RTLLIB_STYPE_REASSOC_REQ:\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\r\nieee->iw_mode == IW_MODE_MASTER)\r\nrtllib_rx_assoc_rq(ieee, skb);\r\nbreak;\r\ncase RTLLIB_STYPE_AUTH:\r\nrtllib_rx_auth(ieee, skb, rx_stats);\r\nbreak;\r\ncase RTLLIB_STYPE_DISASSOC:\r\ncase RTLLIB_STYPE_DEAUTH:\r\nrtllib_rx_deauth(ieee, skb);\r\nbreak;\r\ncase RTLLIB_STYPE_MANAGE_ACT:\r\nrtllib_process_action(ieee, skb);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)\r\n{\r\nunsigned int queue_index = txb->queue_index;\r\nunsigned long flags;\r\nint i;\r\nstruct cb_desc *tcb_desc = NULL;\r\nunsigned long queue_len = 0;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nrtllib_sta_wakeup(ieee, 0);\r\ntcb_desc = (struct cb_desc *)(txb->fragments[0]->cb +\r\nMAX_DEV_ADDR_SIZE);\r\nif (tcb_desc->bMulticast)\r\nieee->stats.multicast++;\r\nfor (i = 0; i < txb->nr_frags; i++) {\r\nqueue_len = skb_queue_len(&ieee->skb_waitQ[queue_index]);\r\nif ((queue_len != 0) ||\r\n(!ieee->check_nic_enough_desc(ieee->dev, queue_index)) ||\r\n(ieee->queue_stop)) {\r\nif (queue_len < 200)\r\nskb_queue_tail(&ieee->skb_waitQ[queue_index],\r\ntxb->fragments[i]);\r\nelse\r\nkfree_skb(txb->fragments[i]);\r\n} else {\r\nieee->softmac_data_hard_start_xmit(\r\ntxb->fragments[i],\r\nieee->dev, ieee->rate);\r\n}\r\n}\r\nrtllib_txb_free(txb);\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nvoid rtllib_reset_queue(struct rtllib_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\ninit_mgmt_queue(ieee);\r\nif (ieee->tx_pending.txb) {\r\nrtllib_txb_free(ieee->tx_pending.txb);\r\nieee->tx_pending.txb = NULL;\r\n}\r\nieee->queue_stop = 0;\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nvoid rtllib_stop_all_queues(struct rtllib_device *ieee)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ieee->dev->num_tx_queues; i++)\r\nnetdev_get_tx_queue(ieee->dev, i)->trans_start = jiffies;\r\nnetif_tx_stop_all_queues(ieee->dev);\r\n}\r\nvoid rtllib_wake_all_queues(struct rtllib_device *ieee)\r\n{\r\nnetif_tx_wake_all_queues(ieee->dev);\r\n}\r\nstatic void rtllib_start_master_bss(struct rtllib_device *ieee)\r\n{\r\nieee->assoc_id = 1;\r\nif (ieee->current_network.ssid_len == 0) {\r\nstrncpy(ieee->current_network.ssid,\r\nRTLLIB_DEFAULT_TX_ESSID,\r\nIW_ESSID_MAX_SIZE);\r\nieee->current_network.ssid_len =\r\nstrlen(RTLLIB_DEFAULT_TX_ESSID);\r\nieee->ssid_set = 1;\r\n}\r\nether_addr_copy(ieee->current_network.bssid, ieee->dev->dev_addr);\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nieee->state = RTLLIB_LINKED;\r\nieee->link_change(ieee->dev);\r\nnotify_wx_assoc_event(ieee);\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\nstatic void rtllib_start_monitor_mode(struct rtllib_device *ieee)\r\n{\r\nif (ieee->raw_tx) {\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\n}\r\nstatic void rtllib_start_ibss_wq(void *data)\r\n{\r\nstruct rtllib_device *ieee = container_of_dwork_rsl(data,\r\nstruct rtllib_device, start_ibss_wq);\r\nif (!ieee->proto_started) {\r\nnetdev_info(ieee->dev, "==========oh driver down return\n");\r\nreturn;\r\n}\r\ndown(&ieee->wx_sem);\r\nif (ieee->current_network.ssid_len == 0) {\r\nstrcpy(ieee->current_network.ssid, RTLLIB_DEFAULT_TX_ESSID);\r\nieee->current_network.ssid_len = strlen(RTLLIB_DEFAULT_TX_ESSID);\r\nieee->ssid_set = 1;\r\n}\r\nieee->state = RTLLIB_NOLINK;\r\nieee->mode = IEEE_G;\r\nrtllib_softmac_check_all_nets(ieee);\r\nif (ieee->state == RTLLIB_NOLINK)\r\nrtllib_start_scan_syncro(ieee, 0);\r\nif (ieee->state == RTLLIB_NOLINK) {\r\nnetdev_info(ieee->dev, "creating new IBSS cell\n");\r\nieee->current_network.channel = ieee->IbssStartChnl;\r\nif (!ieee->wap_set)\r\neth_random_addr(ieee->current_network.bssid);\r\nif (ieee->modulation & RTLLIB_CCK_MODULATION) {\r\nieee->current_network.rates_len = 4;\r\nieee->current_network.rates[0] =\r\nRTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_1MB;\r\nieee->current_network.rates[1] =\r\nRTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_2MB;\r\nieee->current_network.rates[2] =\r\nRTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_5MB;\r\nieee->current_network.rates[3] =\r\nRTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_11MB;\r\n} else\r\nieee->current_network.rates_len = 0;\r\nif (ieee->modulation & RTLLIB_OFDM_MODULATION) {\r\nieee->current_network.rates_ex_len = 8;\r\nieee->current_network.rates_ex[0] =\r\nRTLLIB_OFDM_RATE_6MB;\r\nieee->current_network.rates_ex[1] =\r\nRTLLIB_OFDM_RATE_9MB;\r\nieee->current_network.rates_ex[2] =\r\nRTLLIB_OFDM_RATE_12MB;\r\nieee->current_network.rates_ex[3] =\r\nRTLLIB_OFDM_RATE_18MB;\r\nieee->current_network.rates_ex[4] =\r\nRTLLIB_OFDM_RATE_24MB;\r\nieee->current_network.rates_ex[5] =\r\nRTLLIB_OFDM_RATE_36MB;\r\nieee->current_network.rates_ex[6] =\r\nRTLLIB_OFDM_RATE_48MB;\r\nieee->current_network.rates_ex[7] =\r\nRTLLIB_OFDM_RATE_54MB;\r\nieee->rate = 108;\r\n} else {\r\nieee->current_network.rates_ex_len = 0;\r\nieee->rate = 22;\r\n}\r\nieee->current_network.qos_data.supported = 0;\r\nieee->SetWirelessMode(ieee->dev, IEEE_G);\r\nieee->current_network.mode = ieee->mode;\r\nieee->current_network.atim_window = 0;\r\nieee->current_network.capability = WLAN_CAPABILITY_IBSS;\r\n}\r\nnetdev_info(ieee->dev, "%s(): ieee->mode = %d\n", __func__, ieee->mode);\r\nif ((ieee->mode == IEEE_N_24G) || (ieee->mode == IEEE_N_5G))\r\nHTUseDefaultSetting(ieee);\r\nelse\r\nieee->pHTInfo->bCurrentHTSupport = false;\r\nieee->SetHwRegHandler(ieee->dev, HW_VAR_MEDIA_STATUS,\r\n(u8 *)(&ieee->state));\r\nieee->state = RTLLIB_LINKED;\r\nieee->link_change(ieee->dev);\r\nHTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);\r\nif (ieee->LedControlHandler != NULL)\r\nieee->LedControlHandler(ieee->dev, LED_CTL_LINK);\r\nrtllib_start_send_beacons(ieee);\r\nnotify_wx_assoc_event(ieee);\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\nup(&ieee->wx_sem);\r\n}\r\ninline void rtllib_start_ibss(struct rtllib_device *ieee)\r\n{\r\nschedule_delayed_work(&ieee->start_ibss_wq, msecs_to_jiffies(150));\r\n}\r\nstatic void rtllib_start_bss(struct rtllib_device *ieee)\r\n{\r\nunsigned long flags;\r\nif (IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee)) {\r\nif (!ieee->bGlobalDomain)\r\nreturn;\r\n}\r\nrtllib_softmac_check_all_nets(ieee);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (ieee->state == RTLLIB_NOLINK)\r\nrtllib_start_scan(ieee);\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic void rtllib_link_change_wq(void *data)\r\n{\r\nstruct rtllib_device *ieee = container_of_dwork_rsl(data,\r\nstruct rtllib_device, link_change_wq);\r\nieee->link_change(ieee->dev);\r\n}\r\nvoid rtllib_disassociate(struct rtllib_device *ieee)\r\n{\r\nnetif_carrier_off(ieee->dev);\r\nif (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)\r\nrtllib_reset_queue(ieee);\r\nif (ieee->data_hard_stop)\r\nieee->data_hard_stop(ieee->dev);\r\nif (IS_DOT11D_ENABLE(ieee))\r\nDot11d_Reset(ieee);\r\nieee->state = RTLLIB_NOLINK;\r\nieee->is_set_key = false;\r\nieee->wap_set = 0;\r\nschedule_delayed_work(&ieee->link_change_wq, 0);\r\nnotify_wx_assoc_event(ieee);\r\n}\r\nstatic void rtllib_associate_retry_wq(void *data)\r\n{\r\nstruct rtllib_device *ieee = container_of_dwork_rsl(data,\r\nstruct rtllib_device, associate_retry_wq);\r\nunsigned long flags;\r\ndown(&ieee->wx_sem);\r\nif (!ieee->proto_started)\r\ngoto exit;\r\nif (ieee->state != RTLLIB_ASSOCIATING_RETRY)\r\ngoto exit;\r\nieee->beinretry = true;\r\nieee->state = RTLLIB_NOLINK;\r\nrtllib_softmac_check_all_nets(ieee);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (ieee->state == RTLLIB_NOLINK)\r\nrtllib_start_scan(ieee);\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nieee->beinretry = false;\r\nexit:\r\nup(&ieee->wx_sem);\r\n}\r\nstatic struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee)\r\n{\r\nconst u8 broadcast_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct sk_buff *skb;\r\nstruct rtllib_probe_response *b;\r\nskb = rtllib_probe_resp(ieee, broadcast_addr);\r\nif (!skb)\r\nreturn NULL;\r\nb = (struct rtllib_probe_response *) skb->data;\r\nb->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_BEACON);\r\nreturn skb;\r\n}\r\nstruct sk_buff *rtllib_get_beacon(struct rtllib_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rtllib_probe_response *b;\r\nskb = rtllib_get_beacon_(ieee);\r\nif (!skb)\r\nreturn NULL;\r\nb = (struct rtllib_probe_response *) skb->data;\r\nb->header.seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nreturn skb;\r\n}\r\nvoid rtllib_softmac_stop_protocol(struct rtllib_device *ieee, u8 mesh_flag,\r\nu8 shutdown)\r\n{\r\nrtllib_stop_scan_syncro(ieee);\r\ndown(&ieee->wx_sem);\r\nrtllib_stop_protocol(ieee, shutdown);\r\nup(&ieee->wx_sem);\r\n}\r\nvoid rtllib_stop_protocol(struct rtllib_device *ieee, u8 shutdown)\r\n{\r\nif (!ieee->proto_started)\r\nreturn;\r\nif (shutdown) {\r\nieee->proto_started = 0;\r\nieee->proto_stoppping = 1;\r\nif (ieee->rtllib_ips_leave != NULL)\r\nieee->rtllib_ips_leave(ieee->dev);\r\n}\r\nrtllib_stop_send_beacons(ieee);\r\ndel_timer_sync(&ieee->associate_timer);\r\ncancel_delayed_work_sync(&ieee->associate_retry_wq);\r\ncancel_delayed_work_sync(&ieee->start_ibss_wq);\r\ncancel_delayed_work_sync(&ieee->link_change_wq);\r\nrtllib_stop_scan(ieee);\r\nif (ieee->state <= RTLLIB_ASSOCIATING_AUTHENTICATED)\r\nieee->state = RTLLIB_NOLINK;\r\nif (ieee->state == RTLLIB_LINKED) {\r\nif (ieee->iw_mode == IW_MODE_INFRA)\r\nSendDisassociation(ieee, 1, WLAN_REASON_DEAUTH_LEAVING);\r\nrtllib_disassociate(ieee);\r\n}\r\nif (shutdown) {\r\nRemoveAllTS(ieee);\r\nieee->proto_stoppping = 0;\r\n}\r\nkfree(ieee->assocreq_ies);\r\nieee->assocreq_ies = NULL;\r\nieee->assocreq_ies_len = 0;\r\nkfree(ieee->assocresp_ies);\r\nieee->assocresp_ies = NULL;\r\nieee->assocresp_ies_len = 0;\r\n}\r\nvoid rtllib_softmac_start_protocol(struct rtllib_device *ieee, u8 mesh_flag)\r\n{\r\ndown(&ieee->wx_sem);\r\nrtllib_start_protocol(ieee);\r\nup(&ieee->wx_sem);\r\n}\r\nvoid rtllib_start_protocol(struct rtllib_device *ieee)\r\n{\r\nshort ch = 0;\r\nint i = 0;\r\nrtllib_update_active_chan_map(ieee);\r\nif (ieee->proto_started)\r\nreturn;\r\nieee->proto_started = 1;\r\nif (ieee->current_network.channel == 0) {\r\ndo {\r\nch++;\r\nif (ch > MAX_CHANNEL_NUMBER)\r\nreturn;\r\n} while (!ieee->active_channel_map[ch]);\r\nieee->current_network.channel = ch;\r\n}\r\nif (ieee->current_network.beacon_interval == 0)\r\nieee->current_network.beacon_interval = 100;\r\nfor (i = 0; i < 17; i++) {\r\nieee->last_rxseq_num[i] = -1;\r\nieee->last_rxfrag_num[i] = -1;\r\nieee->last_packet_time[i] = 0;\r\n}\r\nif (ieee->UpdateBeaconInterruptHandler)\r\nieee->UpdateBeaconInterruptHandler(ieee->dev, false);\r\nieee->wmm_acm = 0;\r\nif (ieee->iw_mode == IW_MODE_INFRA) {\r\nrtllib_start_bss(ieee);\r\n} else if (ieee->iw_mode == IW_MODE_ADHOC) {\r\nif (ieee->UpdateBeaconInterruptHandler)\r\nieee->UpdateBeaconInterruptHandler(ieee->dev, true);\r\nrtllib_start_ibss(ieee);\r\n} else if (ieee->iw_mode == IW_MODE_MASTER) {\r\nrtllib_start_master_bss(ieee);\r\n} else if (ieee->iw_mode == IW_MODE_MONITOR) {\r\nrtllib_start_monitor_mode(ieee);\r\n}\r\n}\r\nvoid rtllib_softmac_init(struct rtllib_device *ieee)\r\n{\r\nint i;\r\nmemset(&ieee->current_network, 0, sizeof(struct rtllib_network));\r\nieee->state = RTLLIB_NOLINK;\r\nfor (i = 0; i < 5; i++)\r\nieee->seq_ctrl[i] = 0;\r\nieee->pDot11dInfo = kzalloc(sizeof(struct rt_dot11d_info), GFP_ATOMIC);\r\nif (!ieee->pDot11dInfo)\r\nnetdev_err(ieee->dev, "Can't alloc memory for DOT11D\n");\r\nieee->LinkDetectInfo.SlotIndex = 0;\r\nieee->LinkDetectInfo.SlotNum = 2;\r\nieee->LinkDetectInfo.NumRecvBcnInPeriod = 0;\r\nieee->LinkDetectInfo.NumRecvDataInPeriod = 0;\r\nieee->LinkDetectInfo.NumTxOkInPeriod = 0;\r\nieee->LinkDetectInfo.NumRxOkInPeriod = 0;\r\nieee->LinkDetectInfo.NumRxUnicastOkInPeriod = 0;\r\nieee->bIsAggregateFrame = false;\r\nieee->assoc_id = 0;\r\nieee->queue_stop = 0;\r\nieee->scanning_continue = 0;\r\nieee->softmac_features = 0;\r\nieee->wap_set = 0;\r\nieee->ssid_set = 0;\r\nieee->proto_started = 0;\r\nieee->proto_stoppping = 0;\r\nieee->basic_rate = RTLLIB_DEFAULT_BASIC_RATE;\r\nieee->rate = 22;\r\nieee->ps = RTLLIB_PS_DISABLED;\r\nieee->sta_sleep = LPS_IS_WAKE;\r\nieee->Regdot11HTOperationalRateSet[0] = 0xff;\r\nieee->Regdot11HTOperationalRateSet[1] = 0xff;\r\nieee->Regdot11HTOperationalRateSet[4] = 0x01;\r\nieee->Regdot11TxHTOperationalRateSet[0] = 0xff;\r\nieee->Regdot11TxHTOperationalRateSet[1] = 0xff;\r\nieee->Regdot11TxHTOperationalRateSet[4] = 0x01;\r\nieee->FirstIe_InScan = false;\r\nieee->actscanning = false;\r\nieee->beinretry = false;\r\nieee->is_set_key = false;\r\ninit_mgmt_queue(ieee);\r\nieee->tx_pending.txb = NULL;\r\nsetup_timer(&ieee->associate_timer,\r\nrtllib_associate_abort_cb,\r\n(unsigned long) ieee);\r\nsetup_timer(&ieee->beacon_timer,\r\nrtllib_send_beacon_cb,\r\n(unsigned long) ieee);\r\nINIT_DELAYED_WORK_RSL(&ieee->link_change_wq,\r\n(void *)rtllib_link_change_wq, ieee);\r\nINIT_DELAYED_WORK_RSL(&ieee->start_ibss_wq,\r\n(void *)rtllib_start_ibss_wq, ieee);\r\nINIT_WORK_RSL(&ieee->associate_complete_wq,\r\n(void *)rtllib_associate_complete_wq, ieee);\r\nINIT_DELAYED_WORK_RSL(&ieee->associate_procedure_wq,\r\n(void *)rtllib_associate_procedure_wq, ieee);\r\nINIT_DELAYED_WORK_RSL(&ieee->softmac_scan_wq,\r\n(void *)rtllib_softmac_scan_wq, ieee);\r\nINIT_DELAYED_WORK_RSL(&ieee->associate_retry_wq,\r\n(void *)rtllib_associate_retry_wq, ieee);\r\nINIT_WORK_RSL(&ieee->wx_sync_scan_wq, (void *)rtllib_wx_sync_scan_wq,\r\nieee);\r\nsema_init(&ieee->wx_sem, 1);\r\nsema_init(&ieee->scan_sem, 1);\r\nsema_init(&ieee->ips_sem, 1);\r\nspin_lock_init(&ieee->mgmt_tx_lock);\r\nspin_lock_init(&ieee->beacon_lock);\r\ntasklet_init(&ieee->ps_task,\r\n(void(*)(unsigned long)) rtllib_sta_ps,\r\n(unsigned long)ieee);\r\n}\r\nvoid rtllib_softmac_free(struct rtllib_device *ieee)\r\n{\r\ndown(&ieee->wx_sem);\r\nkfree(ieee->pDot11dInfo);\r\nieee->pDot11dInfo = NULL;\r\ndel_timer_sync(&ieee->associate_timer);\r\ncancel_delayed_work_sync(&ieee->associate_retry_wq);\r\ncancel_delayed_work_sync(&ieee->associate_procedure_wq);\r\ncancel_delayed_work_sync(&ieee->softmac_scan_wq);\r\ncancel_delayed_work_sync(&ieee->start_ibss_wq);\r\ncancel_delayed_work_sync(&ieee->hw_wakeup_wq);\r\ncancel_delayed_work_sync(&ieee->hw_sleep_wq);\r\ncancel_delayed_work_sync(&ieee->link_change_wq);\r\ncancel_work_sync(&ieee->associate_complete_wq);\r\ncancel_work_sync(&ieee->ips_leave_wq);\r\ncancel_work_sync(&ieee->wx_sync_scan_wq);\r\nup(&ieee->wx_sem);\r\ntasklet_kill(&ieee->ps_task);\r\n}\r\nstatic int rtllib_wpa_enable(struct rtllib_device *ieee, int value)\r\n{\r\nnetdev_info(ieee->dev, "%s WPA\n", value ? "enabling" : "disabling");\r\nieee->wpa_enabled = value;\r\neth_zero_addr(ieee->ap_mac_addr);\r\nreturn 0;\r\n}\r\nstatic void rtllib_wpa_assoc_frame(struct rtllib_device *ieee, char *wpa_ie,\r\nint wpa_ie_len)\r\n{\r\nrtllib_wpa_enable(ieee, 1);\r\nrtllib_disassociate(ieee);\r\n}\r\nstatic int rtllib_wpa_mlme(struct rtllib_device *ieee, int command, int reason)\r\n{\r\nint ret = 0;\r\nswitch (command) {\r\ncase IEEE_MLME_STA_DEAUTH:\r\nbreak;\r\ncase IEEE_MLME_STA_DISASSOC:\r\nrtllib_disassociate(ieee);\r\nbreak;\r\ndefault:\r\nnetdev_info(ieee->dev, "Unknown MLME request: %d\n", command);\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtllib_wpa_set_wpa_ie(struct rtllib_device *ieee,\r\nstruct ieee_param *param, int plen)\r\n{\r\nu8 *buf;\r\nif (param->u.wpa_ie.len > MAX_WPA_IE_LEN ||\r\n(param->u.wpa_ie.len && param->u.wpa_ie.data == NULL))\r\nreturn -EINVAL;\r\nif (param->u.wpa_ie.len) {\r\nbuf = kmemdup(param->u.wpa_ie.data, param->u.wpa_ie.len,\r\nGFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = buf;\r\nieee->wpa_ie_len = param->u.wpa_ie.len;\r\n} else {\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = NULL;\r\nieee->wpa_ie_len = 0;\r\n}\r\nrtllib_wpa_assoc_frame(ieee, ieee->wpa_ie, ieee->wpa_ie_len);\r\nreturn 0;\r\n}\r\nstatic int rtllib_wpa_set_auth_algs(struct rtllib_device *ieee, int value)\r\n{\r\nstruct rtllib_security sec = {\r\n.flags = SEC_AUTH_MODE,\r\n};\r\nif (value & AUTH_ALG_SHARED_KEY) {\r\nsec.auth_mode = WLAN_AUTH_SHARED_KEY;\r\nieee->open_wep = 0;\r\nieee->auth_mode = 1;\r\n} else if (value & AUTH_ALG_OPEN_SYSTEM) {\r\nsec.auth_mode = WLAN_AUTH_OPEN;\r\nieee->open_wep = 1;\r\nieee->auth_mode = 0;\r\n} else if (value & AUTH_ALG_LEAP) {\r\nsec.auth_mode = WLAN_AUTH_LEAP >> 6;\r\nieee->open_wep = 1;\r\nieee->auth_mode = 2;\r\n}\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nreturn 0;\r\n}\r\nstatic int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nswitch (name) {\r\ncase IEEE_PARAM_WPA_ENABLED:\r\nret = rtllib_wpa_enable(ieee, value);\r\nbreak;\r\ncase IEEE_PARAM_TKIP_COUNTERMEASURES:\r\nieee->tkip_countermeasures = value;\r\nbreak;\r\ncase IEEE_PARAM_DROP_UNENCRYPTED:\r\n{\r\nstruct rtllib_security sec = {\r\n.flags = SEC_ENABLED,\r\n.enabled = value,\r\n};\r\nieee->drop_unencrypted = value;\r\nif (!value) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_0;\r\n} else {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n}\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nbreak;\r\n}\r\ncase IEEE_PARAM_PRIVACY_INVOKED:\r\nieee->privacy_invoked = value;\r\nbreak;\r\ncase IEEE_PARAM_AUTH_ALGS:\r\nret = rtllib_wpa_set_auth_algs(ieee, value);\r\nbreak;\r\ncase IEEE_PARAM_IEEE_802_1X:\r\nieee->ieee802_1x = value;\r\nbreak;\r\ncase IEEE_PARAM_WPAX_SELECT:\r\nspin_lock_irqsave(&ieee->wpax_suitlist_lock, flags);\r\nspin_unlock_irqrestore(&ieee->wpax_suitlist_lock, flags);\r\nbreak;\r\ndefault:\r\nnetdev_info(ieee->dev, "Unknown WPA param: %d\n", name);\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtllib_wpa_set_encryption(struct rtllib_device *ieee,\r\nstruct ieee_param *param, int param_len,\r\nu8 is_mesh)\r\n{\r\nint ret = 0;\r\nstruct lib80211_crypto_ops *ops;\r\nstruct lib80211_crypt_data **crypt;\r\nstruct rtllib_security sec = {\r\n.flags = 0,\r\n};\r\nparam->u.crypt.err = 0;\r\nparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';\r\nif (param_len !=\r\n(int) ((char *) param->u.crypt.key - (char *) param) +\r\nparam->u.crypt.key_len) {\r\nnetdev_info(ieee->dev, "Len mismatch %d, %d\n", param_len,\r\nparam->u.crypt.key_len);\r\nreturn -EINVAL;\r\n}\r\nif (is_broadcast_ether_addr(param->sta_addr)) {\r\nif (param->u.crypt.idx >= NUM_WEP_KEYS)\r\nreturn -EINVAL;\r\ncrypt = &ieee->crypt_info.crypt[param->u.crypt.idx];\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (strcmp(param->u.crypt.alg, "none") == 0) {\r\nif (crypt) {\r\nsec.enabled = 0;\r\nsec.level = SEC_LEVEL_0;\r\nsec.flags |= SEC_ENABLED | SEC_LEVEL;\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\r\n}\r\ngoto done;\r\n}\r\nsec.enabled = 1;\r\nsec.flags |= SEC_ENABLED;\r\nif (!(ieee->host_encrypt || ieee->host_decrypt) &&\r\nstrcmp(param->u.crypt.alg, "R-TKIP"))\r\ngoto skip_host_crypt;\r\nops = lib80211_get_crypto_ops(param->u.crypt.alg);\r\nif (ops == NULL && strcmp(param->u.crypt.alg, "R-WEP") == 0) {\r\nrequest_module("rtllib_crypt_wep");\r\nops = lib80211_get_crypto_ops(param->u.crypt.alg);\r\n} else if (ops == NULL && strcmp(param->u.crypt.alg, "R-TKIP") == 0) {\r\nrequest_module("rtllib_crypt_tkip");\r\nops = lib80211_get_crypto_ops(param->u.crypt.alg);\r\n} else if (ops == NULL && strcmp(param->u.crypt.alg, "R-CCMP") == 0) {\r\nrequest_module("rtllib_crypt_ccmp");\r\nops = lib80211_get_crypto_ops(param->u.crypt.alg);\r\n}\r\nif (ops == NULL) {\r\nnetdev_info(ieee->dev, "unknown crypto alg '%s'\n",\r\nparam->u.crypt.alg);\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_UNKNOWN_ALG;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (*crypt == NULL || (*crypt)->ops != ops) {\r\nstruct lib80211_crypt_data *new_crypt;\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\r\nnew_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);\r\nif (new_crypt == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nnew_crypt->ops = ops;\r\nif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\r\nnew_crypt->priv =\r\nnew_crypt->ops->init(param->u.crypt.idx);\r\nif (new_crypt->priv == NULL) {\r\nkfree(new_crypt);\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_CRYPT_INIT_FAILED;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif (param->u.crypt.key_len > 0 && (*crypt)->ops->set_key &&\r\n(*crypt)->ops->set_key(param->u.crypt.key,\r\nparam->u.crypt.key_len, param->u.crypt.seq,\r\n(*crypt)->priv) < 0) {\r\nnetdev_info(ieee->dev, "key setting failed\n");\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_KEY_SET_FAILED;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nskip_host_crypt:\r\nif (param->u.crypt.set_tx) {\r\nieee->crypt_info.tx_keyidx = param->u.crypt.idx;\r\nsec.active_key = param->u.crypt.idx;\r\nsec.flags |= SEC_ACTIVE_KEY;\r\n} else\r\nsec.flags &= ~SEC_ACTIVE_KEY;\r\nif (param->u.crypt.alg != NULL) {\r\nmemcpy(sec.keys[param->u.crypt.idx],\r\nparam->u.crypt.key,\r\nparam->u.crypt.key_len);\r\nsec.key_sizes[param->u.crypt.idx] = param->u.crypt.key_len;\r\nsec.flags |= (1 << param->u.crypt.idx);\r\nif (strcmp(param->u.crypt.alg, "R-WEP") == 0) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n} else if (strcmp(param->u.crypt.alg, "R-TKIP") == 0) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_2;\r\n} else if (strcmp(param->u.crypt.alg, "R-CCMP") == 0) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_3;\r\n}\r\n}\r\ndone:\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nif (ieee->reset_on_keychange &&\r\nieee->iw_mode != IW_MODE_INFRA &&\r\nieee->reset_port &&\r\nieee->reset_port(ieee->dev)) {\r\nnetdev_info(ieee->dev, "reset_port failed\n");\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_CARD_CONF_FAILED;\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\ninline struct sk_buff *rtllib_disauth_skb(struct rtllib_network *beacon,\r\nstruct rtllib_device *ieee, u16 asRsn)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rtllib_disauth *disauth;\r\nint len = sizeof(struct rtllib_disauth) + ieee->tx_headroom;\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\ndisauth = (struct rtllib_disauth *) skb_put(skb,\r\nsizeof(struct rtllib_disauth));\r\ndisauth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DEAUTH);\r\ndisauth->header.duration_id = 0;\r\nether_addr_copy(disauth->header.addr1, beacon->bssid);\r\nether_addr_copy(disauth->header.addr2, ieee->dev->dev_addr);\r\nether_addr_copy(disauth->header.addr3, beacon->bssid);\r\ndisauth->reason = cpu_to_le16(asRsn);\r\nreturn skb;\r\n}\r\ninline struct sk_buff *rtllib_disassociate_skb(struct rtllib_network *beacon,\r\nstruct rtllib_device *ieee, u16 asRsn)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rtllib_disassoc *disass;\r\nint len = sizeof(struct rtllib_disassoc) + ieee->tx_headroom;\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\ndisass = (struct rtllib_disassoc *) skb_put(skb,\r\nsizeof(struct rtllib_disassoc));\r\ndisass->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DISASSOC);\r\ndisass->header.duration_id = 0;\r\nether_addr_copy(disass->header.addr1, beacon->bssid);\r\nether_addr_copy(disass->header.addr2, ieee->dev->dev_addr);\r\nether_addr_copy(disass->header.addr3, beacon->bssid);\r\ndisass->reason = cpu_to_le16(asRsn);\r\nreturn skb;\r\n}\r\nvoid SendDisassociation(struct rtllib_device *ieee, bool deauth, u16 asRsn)\r\n{\r\nstruct rtllib_network *beacon = &ieee->current_network;\r\nstruct sk_buff *skb;\r\nif (deauth)\r\nskb = rtllib_disauth_skb(beacon, ieee, asRsn);\r\nelse\r\nskb = rtllib_disassociate_skb(beacon, ieee, asRsn);\r\nif (skb)\r\nsoftmac_mgmt_xmit(skb, ieee);\r\n}\r\nu8 rtllib_ap_sec_type(struct rtllib_device *ieee)\r\n{\r\nstatic u8 ccmp_ie[4] = {0x00, 0x50, 0xf2, 0x04};\r\nstatic u8 ccmp_rsn_ie[4] = {0x00, 0x0f, 0xac, 0x04};\r\nint wpa_ie_len = ieee->wpa_ie_len;\r\nstruct lib80211_crypt_data *crypt;\r\nint encrypt;\r\ncrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\r\nencrypt = (ieee->current_network.capability & WLAN_CAPABILITY_PRIVACY)\r\n|| (ieee->host_encrypt && crypt && crypt->ops &&\r\n(strcmp(crypt->ops->name, "R-WEP") == 0));\r\nif (encrypt && (wpa_ie_len == 0)) {\r\nreturn SEC_ALG_WEP;\r\n} else if ((wpa_ie_len != 0)) {\r\nif (((ieee->wpa_ie[0] == 0xdd) &&\r\n(!memcmp(&(ieee->wpa_ie[14]), ccmp_ie, 4))) ||\r\n((ieee->wpa_ie[0] == 0x30) &&\r\n(!memcmp(&ieee->wpa_ie[10], ccmp_rsn_ie, 4))))\r\nreturn SEC_ALG_CCMP;\r\nelse\r\nreturn SEC_ALG_TKIP;\r\n} else {\r\nreturn SEC_ALG_NONE;\r\n}\r\n}\r\nint rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,\r\nu8 is_mesh)\r\n{\r\nstruct ieee_param *param;\r\nint ret = 0;\r\ndown(&ieee->wx_sem);\r\nif (p->length < sizeof(struct ieee_param) || !p->pointer) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nparam = memdup_user(p->pointer, p->length);\r\nif (IS_ERR(param)) {\r\nret = PTR_ERR(param);\r\ngoto out;\r\n}\r\nswitch (param->cmd) {\r\ncase IEEE_CMD_SET_WPA_PARAM:\r\nret = rtllib_wpa_set_param(ieee, param->u.wpa_param.name,\r\nparam->u.wpa_param.value);\r\nbreak;\r\ncase IEEE_CMD_SET_WPA_IE:\r\nret = rtllib_wpa_set_wpa_ie(ieee, param, p->length);\r\nbreak;\r\ncase IEEE_CMD_SET_ENCRYPTION:\r\nret = rtllib_wpa_set_encryption(ieee, param, p->length, 0);\r\nbreak;\r\ncase IEEE_CMD_MLME:\r\nret = rtllib_wpa_mlme(ieee, param->u.mlme.command,\r\nparam->u.mlme.reason_code);\r\nbreak;\r\ndefault:\r\nnetdev_info(ieee->dev, "Unknown WPA supplicant request: %d\n",\r\nparam->cmd);\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (ret == 0 && copy_to_user(p->pointer, param, p->length))\r\nret = -EFAULT;\r\nkfree(param);\r\nout:\r\nup(&ieee->wx_sem);\r\nreturn ret;\r\n}\r\nstatic void rtllib_MgntDisconnectIBSS(struct rtllib_device *rtllib)\r\n{\r\nu8 OpMode;\r\nu8 i;\r\nbool bFilterOutNonAssociatedBSSID = false;\r\nrtllib->state = RTLLIB_NOLINK;\r\nfor (i = 0; i < 6; i++)\r\nrtllib->current_network.bssid[i] = 0x55;\r\nrtllib->OpMode = RT_OP_MODE_NO_LINK;\r\nrtllib->SetHwRegHandler(rtllib->dev, HW_VAR_BSSID,\r\nrtllib->current_network.bssid);\r\nOpMode = RT_OP_MODE_NO_LINK;\r\nrtllib->SetHwRegHandler(rtllib->dev, HW_VAR_MEDIA_STATUS, &OpMode);\r\nrtllib_stop_send_beacons(rtllib);\r\nbFilterOutNonAssociatedBSSID = false;\r\nrtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID,\r\n(u8 *)(&bFilterOutNonAssociatedBSSID));\r\nnotify_wx_assoc_event(rtllib);\r\n}\r\nstatic void rtllib_MlmeDisassociateRequest(struct rtllib_device *rtllib,\r\nu8 *asSta, u8 asRsn)\r\n{\r\nu8 i;\r\nu8 OpMode;\r\nRemovePeerTS(rtllib, asSta);\r\nif (memcmp(rtllib->current_network.bssid, asSta, 6) == 0) {\r\nrtllib->state = RTLLIB_NOLINK;\r\nfor (i = 0; i < 6; i++)\r\nrtllib->current_network.bssid[i] = 0x22;\r\nOpMode = RT_OP_MODE_NO_LINK;\r\nrtllib->OpMode = RT_OP_MODE_NO_LINK;\r\nrtllib->SetHwRegHandler(rtllib->dev, HW_VAR_MEDIA_STATUS,\r\n(u8 *)(&OpMode));\r\nrtllib_disassociate(rtllib);\r\nrtllib->SetHwRegHandler(rtllib->dev, HW_VAR_BSSID,\r\nrtllib->current_network.bssid);\r\n}\r\n}\r\nstatic void\r\nrtllib_MgntDisconnectAP(\r\nstruct rtllib_device *rtllib,\r\nu8 asRsn\r\n)\r\n{\r\nbool bFilterOutNonAssociatedBSSID = false;\r\nbFilterOutNonAssociatedBSSID = false;\r\nrtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID,\r\n(u8 *)(&bFilterOutNonAssociatedBSSID));\r\nrtllib_MlmeDisassociateRequest(rtllib, rtllib->current_network.bssid,\r\nasRsn);\r\nrtllib->state = RTLLIB_NOLINK;\r\n}\r\nbool rtllib_MgntDisconnect(struct rtllib_device *rtllib, u8 asRsn)\r\n{\r\nif (rtllib->ps != RTLLIB_PS_DISABLED)\r\nrtllib->sta_wake_up(rtllib->dev);\r\nif (rtllib->state == RTLLIB_LINKED) {\r\nif (rtllib->iw_mode == IW_MODE_ADHOC)\r\nrtllib_MgntDisconnectIBSS(rtllib);\r\nif (rtllib->iw_mode == IW_MODE_INFRA)\r\nrtllib_MgntDisconnectAP(rtllib, asRsn);\r\n}\r\nreturn true;\r\n}\r\nvoid notify_wx_assoc_event(struct rtllib_device *ieee)\r\n{\r\nunion iwreq_data wrqu;\r\nif (ieee->cannot_notify)\r\nreturn;\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nif (ieee->state == RTLLIB_LINKED)\r\nmemcpy(wrqu.ap_addr.sa_data, ieee->current_network.bssid,\r\nETH_ALEN);\r\nelse {\r\nnetdev_info(ieee->dev, "%s(): Tell user space disconnected\n",\r\n__func__);\r\neth_zero_addr(wrqu.ap_addr.sa_data);\r\n}\r\nwireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);\r\n}
