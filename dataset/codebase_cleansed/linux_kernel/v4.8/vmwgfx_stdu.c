static void vmw_stdu_unpin_display(struct vmw_screen_target_display_unit *stdu)\r\n{\r\nif (stdu->display_srf) {\r\nstruct vmw_resource *res = &stdu->display_srf->res;\r\nvmw_resource_unpin(res);\r\nvmw_surface_unreference(&stdu->display_srf);\r\n}\r\n}\r\nstatic void vmw_stdu_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nvmw_stdu_destroy(vmw_crtc_to_stdu(crtc));\r\n}\r\nstatic int vmw_stdu_define_st(struct vmw_private *dev_priv,\r\nstruct vmw_screen_target_display_unit *stdu,\r\nstruct drm_display_mode *mode,\r\nint crtc_x, int crtc_y)\r\n{\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineGBScreenTarget body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Out of FIFO space defining Screen Target\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DEFINE_GB_SCREENTARGET;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.stid = stdu->base.unit;\r\ncmd->body.width = mode->hdisplay;\r\ncmd->body.height = mode->vdisplay;\r\ncmd->body.flags = (0 == cmd->body.stid) ? SVGA_STFLAG_PRIMARY : 0;\r\ncmd->body.dpi = 0;\r\nif (stdu->base.is_implicit) {\r\ncmd->body.xRoot = crtc_x;\r\ncmd->body.yRoot = crtc_y;\r\n} else {\r\ncmd->body.xRoot = stdu->base.gui_x;\r\ncmd->body.yRoot = stdu->base.gui_y;\r\n}\r\nstdu->base.set_gui_x = cmd->body.xRoot;\r\nstdu->base.set_gui_y = cmd->body.yRoot;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nstdu->defined = true;\r\nreturn 0;\r\n}\r\nstatic int vmw_stdu_bind_st(struct vmw_private *dev_priv,\r\nstruct vmw_screen_target_display_unit *stdu,\r\nstruct vmw_resource *res)\r\n{\r\nSVGA3dSurfaceImageId image;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBScreenTarget body;\r\n} *cmd;\r\nif (!stdu->defined) {\r\nDRM_ERROR("No screen target defined\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(&image, 0, sizeof(image));\r\nimage.sid = res ? res->id : SVGA3D_INVALID_ID;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Out of FIFO space binding a screen target\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_BIND_GB_SCREENTARGET;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.stid = stdu->base.unit;\r\ncmd->body.image = image;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic void vmw_stdu_populate_update(void *cmd, int unit,\r\ns32 left, s32 right, s32 top, s32 bottom)\r\n{\r\nstruct vmw_stdu_update *update = cmd;\r\nupdate->header.id = SVGA_3D_CMD_UPDATE_GB_SCREENTARGET;\r\nupdate->header.size = sizeof(update->body);\r\nupdate->body.stid = unit;\r\nupdate->body.rect.x = left;\r\nupdate->body.rect.y = top;\r\nupdate->body.rect.w = right - left;\r\nupdate->body.rect.h = bottom - top;\r\n}\r\nstatic int vmw_stdu_update_st(struct vmw_private *dev_priv,\r\nstruct vmw_screen_target_display_unit *stdu)\r\n{\r\nstruct vmw_stdu_update *cmd;\r\nstruct drm_crtc *crtc = &stdu->base.crtc;\r\nif (!stdu->defined) {\r\nDRM_ERROR("No screen target defined");\r\nreturn -EINVAL;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Out of FIFO space updating a Screen Target\n");\r\nreturn -ENOMEM;\r\n}\r\nvmw_stdu_populate_update(cmd, stdu->base.unit, 0, crtc->mode.hdisplay,\r\n0, crtc->mode.vdisplay);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_stdu_destroy_st(struct vmw_private *dev_priv,\r\nstruct vmw_screen_target_display_unit *stdu)\r\n{\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyGBScreenTarget body;\r\n} *cmd;\r\nif (unlikely(!stdu->defined))\r\nreturn 0;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Out of FIFO space, screen target not destroyed\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DESTROY_GB_SCREENTARGET;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.stid = stdu->base.unit;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nret = vmw_fallback_wait(dev_priv, false, true, 0, false, 3*HZ);\r\nif (unlikely(ret != 0))\r\nDRM_ERROR("Failed to sync with HW");\r\nstdu->defined = false;\r\nreturn ret;\r\n}\r\nstatic int vmw_stdu_bind_fb(struct vmw_private *dev_priv,\r\nstruct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_framebuffer *new_fb)\r\n{\r\nstruct vmw_screen_target_display_unit *stdu = vmw_crtc_to_stdu(crtc);\r\nstruct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(new_fb);\r\nstruct vmw_surface *new_display_srf = NULL;\r\nenum stdu_content_type new_content_type;\r\nstruct vmw_framebuffer_surface *new_vfbs;\r\nint ret;\r\nWARN_ON_ONCE(!stdu->defined);\r\nnew_vfbs = (vfb->dmabuf) ? NULL : vmw_framebuffer_to_vfbs(new_fb);\r\nif (new_vfbs && new_vfbs->surface->base_size.width == mode->hdisplay &&\r\nnew_vfbs->surface->base_size.height == mode->vdisplay)\r\nnew_content_type = SAME_AS_DISPLAY;\r\nelse if (vfb->dmabuf)\r\nnew_content_type = SEPARATE_DMA;\r\nelse\r\nnew_content_type = SEPARATE_SURFACE;\r\nif (new_content_type != SAME_AS_DISPLAY &&\r\n!stdu->display_srf) {\r\nstruct vmw_surface content_srf;\r\nstruct drm_vmw_size display_base_size = {0};\r\ndisplay_base_size.width = mode->hdisplay;\r\ndisplay_base_size.height = mode->vdisplay;\r\ndisplay_base_size.depth = 1;\r\nif (new_content_type == SEPARATE_DMA) {\r\nswitch (new_fb->bits_per_pixel) {\r\ncase 32:\r\ncontent_srf.format = SVGA3D_X8R8G8B8;\r\nbreak;\r\ncase 16:\r\ncontent_srf.format = SVGA3D_R5G6B5;\r\nbreak;\r\ncase 8:\r\ncontent_srf.format = SVGA3D_P8;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid format\n");\r\nreturn -EINVAL;\r\n}\r\ncontent_srf.flags = 0;\r\ncontent_srf.mip_levels[0] = 1;\r\ncontent_srf.multisample_count = 0;\r\n} else {\r\ncontent_srf = *new_vfbs->surface;\r\n}\r\nret = vmw_surface_gb_priv_define(crtc->dev,\r\n0,\r\ncontent_srf.flags,\r\ncontent_srf.format,\r\ntrue,\r\ncontent_srf.mip_levels[0],\r\ncontent_srf.multisample_count,\r\n0,\r\ndisplay_base_size,\r\n&new_display_srf);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Could not allocate screen target surface.\n");\r\nreturn ret;\r\n}\r\n} else if (new_content_type == SAME_AS_DISPLAY) {\r\nnew_display_srf = vmw_surface_reference(new_vfbs->surface);\r\n}\r\nif (new_display_srf) {\r\nret = vmw_resource_pin(&new_display_srf->res, false);\r\nif (ret)\r\ngoto out_srf_unref;\r\nret = vmw_stdu_bind_st(dev_priv, stdu, &new_display_srf->res);\r\nif (ret)\r\ngoto out_srf_unpin;\r\nvmw_stdu_unpin_display(stdu);\r\nstdu->display_srf = new_display_srf;\r\nnew_display_srf = NULL;\r\n}\r\ncrtc->primary->fb = new_fb;\r\nstdu->content_fb_type = new_content_type;\r\nreturn 0;\r\nout_srf_unpin:\r\nvmw_resource_unpin(&new_display_srf->res);\r\nout_srf_unref:\r\nvmw_surface_unreference(&new_display_srf);\r\nreturn ret;\r\n}\r\nstatic int vmw_stdu_crtc_set_config(struct drm_mode_set *set)\r\n{\r\nstruct vmw_private *dev_priv;\r\nstruct vmw_framebuffer *vfb;\r\nstruct vmw_screen_target_display_unit *stdu;\r\nstruct drm_display_mode *mode;\r\nstruct drm_framebuffer *new_fb;\r\nstruct drm_crtc *crtc;\r\nstruct drm_encoder *encoder;\r\nstruct drm_connector *connector;\r\nbool turning_off;\r\nint ret;\r\nif (!set || !set->crtc)\r\nreturn -EINVAL;\r\ncrtc = set->crtc;\r\nstdu = vmw_crtc_to_stdu(crtc);\r\nmode = set->mode;\r\nnew_fb = set->fb;\r\ndev_priv = vmw_priv(crtc->dev);\r\nturning_off = set->num_connectors == 0 || !mode || !new_fb;\r\nvfb = (new_fb) ? vmw_framebuffer_to_vfb(new_fb) : NULL;\r\nif (set->num_connectors > 1) {\r\nDRM_ERROR("Too many connectors\n");\r\nreturn -EINVAL;\r\n}\r\nif (set->num_connectors == 1 &&\r\nset->connectors[0] != &stdu->base.connector) {\r\nDRM_ERROR("Connectors don't match %p %p\n",\r\nset->connectors[0], &stdu->base.connector);\r\nreturn -EINVAL;\r\n}\r\nif (!turning_off && (set->x + mode->hdisplay > new_fb->width ||\r\nset->y + mode->vdisplay > new_fb->height)) {\r\nDRM_ERROR("Set outside of framebuffer\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&dev_priv->global_kms_state_mutex);\r\nif (!turning_off && stdu->base.is_implicit && dev_priv->implicit_fb &&\r\n!(dev_priv->num_implicit == 1 && stdu->base.active_implicit)\r\n&& dev_priv->implicit_fb != vfb) {\r\nmutex_unlock(&dev_priv->global_kms_state_mutex);\r\nDRM_ERROR("Multiple implicit framebuffers not supported.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&dev_priv->global_kms_state_mutex);\r\nconnector = &stdu->base.connector;\r\nencoder = &stdu->base.encoder;\r\nif (stdu->defined) {\r\nret = vmw_stdu_bind_st(dev_priv, stdu, NULL);\r\nif (ret)\r\nreturn ret;\r\nvmw_stdu_unpin_display(stdu);\r\n(void) vmw_stdu_update_st(dev_priv, stdu);\r\nvmw_kms_del_active(dev_priv, &stdu->base);\r\nret = vmw_stdu_destroy_st(dev_priv, stdu);\r\nif (ret)\r\nreturn ret;\r\ncrtc->primary->fb = NULL;\r\ncrtc->enabled = false;\r\nencoder->crtc = NULL;\r\nconnector->encoder = NULL;\r\nstdu->content_fb_type = SAME_AS_DISPLAY;\r\ncrtc->x = set->x;\r\ncrtc->y = set->y;\r\n}\r\nif (turning_off)\r\nreturn 0;\r\nvmw_svga_enable(dev_priv);\r\nret = vmw_stdu_define_st(dev_priv, stdu, mode, set->x, set->y);\r\nif (ret)\r\nreturn ret;\r\ncrtc->x = set->x;\r\ncrtc->y = set->y;\r\ncrtc->mode = *mode;\r\nret = vmw_stdu_bind_fb(dev_priv, crtc, mode, new_fb);\r\nif (ret)\r\nreturn ret;\r\nvmw_kms_add_active(dev_priv, &stdu->base, vfb);\r\ncrtc->enabled = true;\r\nconnector->encoder = encoder;\r\nencoder->crtc = crtc;\r\nreturn 0;\r\n}\r\nstatic int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *new_fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t flags)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nstruct vmw_screen_target_display_unit *stdu;\r\nstruct drm_vmw_rect vclips;\r\nstruct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(new_fb);\r\nint ret;\r\ndev_priv = vmw_priv(crtc->dev);\r\nstdu = vmw_crtc_to_stdu(crtc);\r\nif (!stdu->defined || !vmw_kms_crtc_flippable(dev_priv, crtc))\r\nreturn -EINVAL;\r\nret = vmw_stdu_bind_fb(dev_priv, crtc, &crtc->mode, new_fb);\r\nif (ret)\r\nreturn ret;\r\nif (stdu->base.is_implicit)\r\nvmw_kms_update_implicit_fb(dev_priv, crtc);\r\nvclips.x = crtc->x;\r\nvclips.y = crtc->y;\r\nvclips.w = crtc->mode.hdisplay;\r\nvclips.h = crtc->mode.vdisplay;\r\nif (vfb->dmabuf)\r\nret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL, &vclips,\r\n1, 1, true, false);\r\nelse\r\nret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL, &vclips,\r\nNULL, 0, 0, 1, 1, NULL);\r\nif (ret)\r\nreturn ret;\r\nif (event) {\r\nstruct vmw_fence_obj *fence = NULL;\r\nstruct drm_file *file_priv = event->base.file_priv;\r\nvmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);\r\nif (!fence)\r\nreturn -ENOMEM;\r\nret = vmw_event_fence_action_queue(file_priv, fence,\r\n&event->base,\r\n&event->event.tv_sec,\r\n&event->event.tv_usec,\r\ntrue);\r\nvmw_fence_obj_unreference(&fence);\r\n} else {\r\nvmw_fifo_flush(dev_priv, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vmw_stdu_dmabuf_clip(struct vmw_kms_dirty *dirty)\r\n{\r\nstruct vmw_stdu_dirty *ddirty =\r\ncontainer_of(dirty, struct vmw_stdu_dirty, base);\r\nstruct vmw_stdu_dma *cmd = dirty->cmd;\r\nstruct SVGA3dCopyBox *blit = (struct SVGA3dCopyBox *) &cmd[1];\r\nblit += dirty->num_hits;\r\nblit->srcx = dirty->fb_x;\r\nblit->srcy = dirty->fb_y;\r\nblit->x = dirty->unit_x1;\r\nblit->y = dirty->unit_y1;\r\nblit->d = 1;\r\nblit->w = dirty->unit_x2 - dirty->unit_x1;\r\nblit->h = dirty->unit_y2 - dirty->unit_y1;\r\ndirty->num_hits++;\r\nif (ddirty->transfer != SVGA3D_WRITE_HOST_VRAM)\r\nreturn;\r\nddirty->left = min_t(s32, ddirty->left, dirty->unit_x1);\r\nddirty->top = min_t(s32, ddirty->top, dirty->unit_y1);\r\nddirty->right = max_t(s32, ddirty->right, dirty->unit_x2);\r\nddirty->bottom = max_t(s32, ddirty->bottom, dirty->unit_y2);\r\n}\r\nstatic void vmw_stdu_dmabuf_fifo_commit(struct vmw_kms_dirty *dirty)\r\n{\r\nstruct vmw_stdu_dirty *ddirty =\r\ncontainer_of(dirty, struct vmw_stdu_dirty, base);\r\nstruct vmw_screen_target_display_unit *stdu =\r\ncontainer_of(dirty->unit, typeof(*stdu), base);\r\nstruct vmw_stdu_dma *cmd = dirty->cmd;\r\nstruct SVGA3dCopyBox *blit = (struct SVGA3dCopyBox *) &cmd[1];\r\nSVGA3dCmdSurfaceDMASuffix *suffix =\r\n(SVGA3dCmdSurfaceDMASuffix *) &blit[dirty->num_hits];\r\nsize_t blit_size = sizeof(*blit) * dirty->num_hits + sizeof(*suffix);\r\nif (!dirty->num_hits) {\r\nvmw_fifo_commit(dirty->dev_priv, 0);\r\nreturn;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_SURFACE_DMA;\r\ncmd->header.size = sizeof(cmd->body) + blit_size;\r\nvmw_bo_get_guest_ptr(&ddirty->buf->base, &cmd->body.guest.ptr);\r\ncmd->body.guest.pitch = ddirty->pitch;\r\ncmd->body.host.sid = stdu->display_srf->res.id;\r\ncmd->body.host.face = 0;\r\ncmd->body.host.mipmap = 0;\r\ncmd->body.transfer = ddirty->transfer;\r\nsuffix->suffixSize = sizeof(*suffix);\r\nsuffix->maximumOffset = ddirty->buf->base.num_pages * PAGE_SIZE;\r\nif (ddirty->transfer == SVGA3D_WRITE_HOST_VRAM) {\r\nblit_size += sizeof(struct vmw_stdu_update);\r\nvmw_stdu_populate_update(&suffix[1], stdu->base.unit,\r\nddirty->left, ddirty->right,\r\nddirty->top, ddirty->bottom);\r\n}\r\nvmw_fifo_commit(dirty->dev_priv, sizeof(*cmd) + blit_size);\r\nddirty->left = ddirty->top = S32_MAX;\r\nddirty->right = ddirty->bottom = S32_MIN;\r\n}\r\nint vmw_kms_stdu_dma(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_framebuffer *vfb,\r\nstruct drm_vmw_fence_rep __user *user_fence_rep,\r\nstruct drm_clip_rect *clips,\r\nstruct drm_vmw_rect *vclips,\r\nuint32_t num_clips,\r\nint increment,\r\nbool to_surface,\r\nbool interruptible)\r\n{\r\nstruct vmw_dma_buffer *buf =\r\ncontainer_of(vfb, struct vmw_framebuffer_dmabuf, base)->buffer;\r\nstruct vmw_stdu_dirty ddirty;\r\nint ret;\r\nret = vmw_kms_helper_buffer_prepare(dev_priv, buf, interruptible,\r\nfalse);\r\nif (ret)\r\nreturn ret;\r\nddirty.transfer = (to_surface) ? SVGA3D_WRITE_HOST_VRAM :\r\nSVGA3D_READ_HOST_VRAM;\r\nddirty.left = ddirty.top = S32_MAX;\r\nddirty.right = ddirty.bottom = S32_MIN;\r\nddirty.pitch = vfb->base.pitches[0];\r\nddirty.buf = buf;\r\nddirty.base.fifo_commit = vmw_stdu_dmabuf_fifo_commit;\r\nddirty.base.clip = vmw_stdu_dmabuf_clip;\r\nddirty.base.fifo_reserve_size = sizeof(struct vmw_stdu_dma) +\r\nnum_clips * sizeof(SVGA3dCopyBox) +\r\nsizeof(SVGA3dCmdSurfaceDMASuffix);\r\nif (to_surface)\r\nddirty.base.fifo_reserve_size += sizeof(struct vmw_stdu_update);\r\nret = vmw_kms_helper_dirty(dev_priv, vfb, clips, vclips,\r\n0, 0, num_clips, increment, &ddirty.base);\r\nvmw_kms_helper_buffer_finish(dev_priv, file_priv, buf, NULL,\r\nuser_fence_rep);\r\nreturn ret;\r\n}\r\nstatic void vmw_kms_stdu_surface_clip(struct vmw_kms_dirty *dirty)\r\n{\r\nstruct vmw_stdu_dirty *sdirty =\r\ncontainer_of(dirty, struct vmw_stdu_dirty, base);\r\nstruct vmw_stdu_surface_copy *cmd = dirty->cmd;\r\nstruct vmw_screen_target_display_unit *stdu =\r\ncontainer_of(dirty->unit, typeof(*stdu), base);\r\nif (sdirty->sid != stdu->display_srf->res.id) {\r\nstruct SVGA3dCopyBox *blit = (struct SVGA3dCopyBox *) &cmd[1];\r\nblit += dirty->num_hits;\r\nblit->srcx = dirty->fb_x;\r\nblit->srcy = dirty->fb_y;\r\nblit->x = dirty->unit_x1;\r\nblit->y = dirty->unit_y1;\r\nblit->d = 1;\r\nblit->w = dirty->unit_x2 - dirty->unit_x1;\r\nblit->h = dirty->unit_y2 - dirty->unit_y1;\r\n}\r\ndirty->num_hits++;\r\nsdirty->left = min_t(s32, sdirty->left, dirty->unit_x1);\r\nsdirty->top = min_t(s32, sdirty->top, dirty->unit_y1);\r\nsdirty->right = max_t(s32, sdirty->right, dirty->unit_x2);\r\nsdirty->bottom = max_t(s32, sdirty->bottom, dirty->unit_y2);\r\n}\r\nstatic void vmw_kms_stdu_surface_fifo_commit(struct vmw_kms_dirty *dirty)\r\n{\r\nstruct vmw_stdu_dirty *sdirty =\r\ncontainer_of(dirty, struct vmw_stdu_dirty, base);\r\nstruct vmw_screen_target_display_unit *stdu =\r\ncontainer_of(dirty->unit, typeof(*stdu), base);\r\nstruct vmw_stdu_surface_copy *cmd = dirty->cmd;\r\nstruct vmw_stdu_update *update;\r\nsize_t blit_size = sizeof(SVGA3dCopyBox) * dirty->num_hits;\r\nsize_t commit_size;\r\nif (!dirty->num_hits) {\r\nvmw_fifo_commit(dirty->dev_priv, 0);\r\nreturn;\r\n}\r\nif (sdirty->sid != stdu->display_srf->res.id) {\r\nstruct SVGA3dCopyBox *blit = (struct SVGA3dCopyBox *) &cmd[1];\r\ncmd->header.id = SVGA_3D_CMD_SURFACE_COPY;\r\ncmd->header.size = sizeof(cmd->body) + blit_size;\r\ncmd->body.src.sid = sdirty->sid;\r\ncmd->body.dest.sid = stdu->display_srf->res.id;\r\nupdate = (struct vmw_stdu_update *) &blit[dirty->num_hits];\r\ncommit_size = sizeof(*cmd) + blit_size + sizeof(*update);\r\n} else {\r\nupdate = dirty->cmd;\r\ncommit_size = sizeof(*update);\r\n}\r\nvmw_stdu_populate_update(update, stdu->base.unit, sdirty->left,\r\nsdirty->right, sdirty->top, sdirty->bottom);\r\nvmw_fifo_commit(dirty->dev_priv, commit_size);\r\nsdirty->left = sdirty->top = S32_MAX;\r\nsdirty->right = sdirty->bottom = S32_MIN;\r\n}\r\nint vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,\r\nstruct vmw_framebuffer *framebuffer,\r\nstruct drm_clip_rect *clips,\r\nstruct drm_vmw_rect *vclips,\r\nstruct vmw_resource *srf,\r\ns32 dest_x,\r\ns32 dest_y,\r\nunsigned num_clips, int inc,\r\nstruct vmw_fence_obj **out_fence)\r\n{\r\nstruct vmw_framebuffer_surface *vfbs =\r\ncontainer_of(framebuffer, typeof(*vfbs), base);\r\nstruct vmw_stdu_dirty sdirty;\r\nint ret;\r\nif (!srf)\r\nsrf = &vfbs->surface->res;\r\nret = vmw_kms_helper_resource_prepare(srf, true);\r\nif (ret)\r\nreturn ret;\r\nif (vfbs->is_dmabuf_proxy) {\r\nret = vmw_kms_update_proxy(srf, clips, num_clips, inc);\r\nif (ret)\r\ngoto out_finish;\r\n}\r\nsdirty.base.fifo_commit = vmw_kms_stdu_surface_fifo_commit;\r\nsdirty.base.clip = vmw_kms_stdu_surface_clip;\r\nsdirty.base.fifo_reserve_size = sizeof(struct vmw_stdu_surface_copy) +\r\nsizeof(SVGA3dCopyBox) * num_clips +\r\nsizeof(struct vmw_stdu_update);\r\nsdirty.sid = srf->id;\r\nsdirty.left = sdirty.top = S32_MAX;\r\nsdirty.right = sdirty.bottom = S32_MIN;\r\nret = vmw_kms_helper_dirty(dev_priv, framebuffer, clips, vclips,\r\ndest_x, dest_y, num_clips, inc,\r\n&sdirty.base);\r\nout_finish:\r\nvmw_kms_helper_resource_finish(srf, out_fence);\r\nreturn ret;\r\n}\r\nstatic void vmw_stdu_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nvmw_stdu_destroy(vmw_encoder_to_stdu(encoder));\r\n}\r\nstatic void vmw_stdu_connector_destroy(struct drm_connector *connector)\r\n{\r\nvmw_stdu_destroy(vmw_connector_to_stdu(connector));\r\n}\r\nstatic int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)\r\n{\r\nstruct vmw_screen_target_display_unit *stdu;\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\nstdu = kzalloc(sizeof(*stdu), GFP_KERNEL);\r\nif (!stdu)\r\nreturn -ENOMEM;\r\nstdu->base.unit = unit;\r\ncrtc = &stdu->base.crtc;\r\nencoder = &stdu->base.encoder;\r\nconnector = &stdu->base.connector;\r\nstdu->base.pref_active = (unit == 0);\r\nstdu->base.pref_width = dev_priv->initial_width;\r\nstdu->base.pref_height = dev_priv->initial_height;\r\nstdu->base.is_implicit = false;\r\ndrm_connector_init(dev, connector, &vmw_stdu_connector_funcs,\r\nDRM_MODE_CONNECTOR_VIRTUAL);\r\nconnector->status = vmw_du_connector_detect(connector, false);\r\ndrm_encoder_init(dev, encoder, &vmw_stdu_encoder_funcs,\r\nDRM_MODE_ENCODER_VIRTUAL, NULL);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nencoder->possible_crtcs = (1 << unit);\r\nencoder->possible_clones = 0;\r\n(void) drm_connector_register(connector);\r\ndrm_crtc_init(dev, crtc, &vmw_stdu_crtc_funcs);\r\ndrm_mode_crtc_set_gamma_size(crtc, 256);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.dirty_info_property,\r\n1);\r\ndrm_object_attach_property(&connector->base,\r\ndev_priv->hotplug_mode_update_property, 1);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.suggested_x_property, 0);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.suggested_y_property, 0);\r\nif (dev_priv->implicit_placement_property)\r\ndrm_object_attach_property\r\n(&connector->base,\r\ndev_priv->implicit_placement_property,\r\nstdu->base.is_implicit);\r\nreturn 0;\r\n}\r\nstatic void vmw_stdu_destroy(struct vmw_screen_target_display_unit *stdu)\r\n{\r\nvmw_stdu_unpin_display(stdu);\r\nvmw_du_cleanup(&stdu->base);\r\nkfree(stdu);\r\n}\r\nint vmw_kms_stdu_init_display(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nint i, ret;\r\nif (!VMWGFX_ENABLE_SCREEN_TARGET_OTABLE)\r\nreturn -ENOSYS;\r\nif (!(dev_priv->capabilities & SVGA_CAP_GBOBJECTS))\r\nreturn -ENOSYS;\r\nret = drm_vblank_init(dev, VMWGFX_NUM_DISPLAY_UNITS);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = drm_mode_create_dirty_info_property(dev);\r\nif (unlikely(ret != 0))\r\ngoto err_vblank_cleanup;\r\ndev_priv->active_display_unit = vmw_du_screen_target;\r\nvmw_kms_create_implicit_placement_property(dev_priv, false);\r\nfor (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i) {\r\nret = vmw_stdu_init(dev_priv, i);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to initialize STDU %d", i);\r\ngoto err_vblank_cleanup;\r\n}\r\n}\r\nDRM_INFO("Screen Target Display device initialized\n");\r\nreturn 0;\r\nerr_vblank_cleanup:\r\ndrm_vblank_cleanup(dev);\r\nreturn ret;\r\n}\r\nint vmw_kms_stdu_close_display(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\ndrm_vblank_cleanup(dev);\r\nreturn 0;\r\n}
