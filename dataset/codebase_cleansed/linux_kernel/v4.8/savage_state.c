void savage_emit_clip_rect_s3d(drm_savage_private_t * dev_priv,\r\nconst struct drm_clip_rect * pbox)\r\n{\r\nuint32_t scstart = dev_priv->state.s3d.new_scstart;\r\nuint32_t scend = dev_priv->state.s3d.new_scend;\r\nscstart = (scstart & ~SAVAGE_SCISSOR_MASK_S3D) |\r\n((uint32_t) pbox->x1 & 0x000007ff) |\r\n(((uint32_t) pbox->y1 << 16) & 0x07ff0000);\r\nscend = (scend & ~SAVAGE_SCISSOR_MASK_S3D) |\r\n(((uint32_t) pbox->x2 - 1) & 0x000007ff) |\r\n((((uint32_t) pbox->y2 - 1) << 16) & 0x07ff0000);\r\nif (scstart != dev_priv->state.s3d.scstart ||\r\nscend != dev_priv->state.s3d.scend) {\r\nDMA_LOCALS;\r\nBEGIN_DMA(4);\r\nDMA_WRITE(BCI_CMD_WAIT | BCI_CMD_WAIT_3D);\r\nDMA_SET_REGISTERS(SAVAGE_SCSTART_S3D, 2);\r\nDMA_WRITE(scstart);\r\nDMA_WRITE(scend);\r\ndev_priv->state.s3d.scstart = scstart;\r\ndev_priv->state.s3d.scend = scend;\r\ndev_priv->waiting = 1;\r\nDMA_COMMIT();\r\n}\r\n}\r\nvoid savage_emit_clip_rect_s4(drm_savage_private_t * dev_priv,\r\nconst struct drm_clip_rect * pbox)\r\n{\r\nuint32_t drawctrl0 = dev_priv->state.s4.new_drawctrl0;\r\nuint32_t drawctrl1 = dev_priv->state.s4.new_drawctrl1;\r\ndrawctrl0 = (drawctrl0 & ~SAVAGE_SCISSOR_MASK_S4) |\r\n((uint32_t) pbox->x1 & 0x000007ff) |\r\n(((uint32_t) pbox->y1 << 12) & 0x00fff000);\r\ndrawctrl1 = (drawctrl1 & ~SAVAGE_SCISSOR_MASK_S4) |\r\n(((uint32_t) pbox->x2 - 1) & 0x000007ff) |\r\n((((uint32_t) pbox->y2 - 1) << 12) & 0x00fff000);\r\nif (drawctrl0 != dev_priv->state.s4.drawctrl0 ||\r\ndrawctrl1 != dev_priv->state.s4.drawctrl1) {\r\nDMA_LOCALS;\r\nBEGIN_DMA(4);\r\nDMA_WRITE(BCI_CMD_WAIT | BCI_CMD_WAIT_3D);\r\nDMA_SET_REGISTERS(SAVAGE_DRAWCTRL0_S4, 2);\r\nDMA_WRITE(drawctrl0);\r\nDMA_WRITE(drawctrl1);\r\ndev_priv->state.s4.drawctrl0 = drawctrl0;\r\ndev_priv->state.s4.drawctrl1 = drawctrl1;\r\ndev_priv->waiting = 1;\r\nDMA_COMMIT();\r\n}\r\n}\r\nstatic int savage_verify_texaddr(drm_savage_private_t * dev_priv, int unit,\r\nuint32_t addr)\r\n{\r\nif ((addr & 6) != 2) {\r\nDRM_ERROR("bad texAddr%d %08x (reserved bits)\n", unit, addr);\r\nreturn -EINVAL;\r\n}\r\nif (!(addr & 1)) {\r\naddr &= ~7;\r\nif (addr < dev_priv->texture_offset ||\r\naddr >= dev_priv->texture_offset + dev_priv->texture_size) {\r\nDRM_ERROR\r\n("bad texAddr%d %08x (local addr out of range)\n",\r\nunit, addr);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (!dev_priv->agp_textures) {\r\nDRM_ERROR("bad texAddr%d %08x (AGP not available)\n",\r\nunit, addr);\r\nreturn -EINVAL;\r\n}\r\naddr &= ~7;\r\nif (addr < dev_priv->agp_textures->offset ||\r\naddr >= (dev_priv->agp_textures->offset +\r\ndev_priv->agp_textures->size)) {\r\nDRM_ERROR\r\n("bad texAddr%d %08x (AGP addr out of range)\n",\r\nunit, addr);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int savage_verify_state_s3d(drm_savage_private_t * dev_priv,\r\nunsigned int start, unsigned int count,\r\nconst uint32_t *regs)\r\n{\r\nif (start < SAVAGE_TEXPALADDR_S3D ||\r\nstart + count - 1 > SAVAGE_DESTTEXRWWATERMARK_S3D) {\r\nDRM_ERROR("invalid register range (0x%04x-0x%04x)\n",\r\nstart, start + count - 1);\r\nreturn -EINVAL;\r\n}\r\nSAVE_STATE_MASK(SAVAGE_SCSTART_S3D, s3d.new_scstart,\r\n~SAVAGE_SCISSOR_MASK_S3D);\r\nSAVE_STATE_MASK(SAVAGE_SCEND_S3D, s3d.new_scend,\r\n~SAVAGE_SCISSOR_MASK_S3D);\r\nif (start <= SAVAGE_TEXCTRL_S3D &&\r\nstart + count > SAVAGE_TEXPALADDR_S3D) {\r\nSAVE_STATE(SAVAGE_TEXCTRL_S3D, s3d.texctrl);\r\nSAVE_STATE(SAVAGE_TEXADDR_S3D, s3d.texaddr);\r\nif (dev_priv->state.s3d.texctrl & SAVAGE_TEXCTRL_TEXEN_MASK)\r\nreturn savage_verify_texaddr(dev_priv, 0,\r\ndev_priv->state.s3d.texaddr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int savage_verify_state_s4(drm_savage_private_t * dev_priv,\r\nunsigned int start, unsigned int count,\r\nconst uint32_t *regs)\r\n{\r\nint ret = 0;\r\nif (start < SAVAGE_DRAWLOCALCTRL_S4 ||\r\nstart + count - 1 > SAVAGE_TEXBLENDCOLOR_S4) {\r\nDRM_ERROR("invalid register range (0x%04x-0x%04x)\n",\r\nstart, start + count - 1);\r\nreturn -EINVAL;\r\n}\r\nSAVE_STATE_MASK(SAVAGE_DRAWCTRL0_S4, s4.new_drawctrl0,\r\n~SAVAGE_SCISSOR_MASK_S4);\r\nSAVE_STATE_MASK(SAVAGE_DRAWCTRL1_S4, s4.new_drawctrl1,\r\n~SAVAGE_SCISSOR_MASK_S4);\r\nif (start <= SAVAGE_TEXDESCR_S4 &&\r\nstart + count > SAVAGE_TEXPALADDR_S4) {\r\nSAVE_STATE(SAVAGE_TEXDESCR_S4, s4.texdescr);\r\nSAVE_STATE(SAVAGE_TEXADDR0_S4, s4.texaddr0);\r\nSAVE_STATE(SAVAGE_TEXADDR1_S4, s4.texaddr1);\r\nif (dev_priv->state.s4.texdescr & SAVAGE_TEXDESCR_TEX0EN_MASK)\r\nret |= savage_verify_texaddr(dev_priv, 0,\r\ndev_priv->state.s4.texaddr0);\r\nif (dev_priv->state.s4.texdescr & SAVAGE_TEXDESCR_TEX1EN_MASK)\r\nret |= savage_verify_texaddr(dev_priv, 1,\r\ndev_priv->state.s4.texaddr1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int savage_dispatch_state(drm_savage_private_t * dev_priv,\r\nconst drm_savage_cmd_header_t * cmd_header,\r\nconst uint32_t *regs)\r\n{\r\nunsigned int count = cmd_header->state.count;\r\nunsigned int start = cmd_header->state.start;\r\nunsigned int count2 = 0;\r\nunsigned int bci_size;\r\nint ret;\r\nDMA_LOCALS;\r\nif (!count)\r\nreturn 0;\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\nret = savage_verify_state_s3d(dev_priv, start, count, regs);\r\nif (ret != 0)\r\nreturn ret;\r\nif (start < SAVAGE_SCSTART_S3D) {\r\nif (start + count > SAVAGE_SCEND_S3D + 1)\r\ncount2 = count - (SAVAGE_SCEND_S3D + 1 - start);\r\nif (start + count > SAVAGE_SCSTART_S3D)\r\ncount = SAVAGE_SCSTART_S3D - start;\r\n} else if (start <= SAVAGE_SCEND_S3D) {\r\nif (start + count > SAVAGE_SCEND_S3D + 1) {\r\ncount -= SAVAGE_SCEND_S3D + 1 - start;\r\nstart = SAVAGE_SCEND_S3D + 1;\r\n} else\r\nreturn 0;\r\n}\r\n} else {\r\nret = savage_verify_state_s4(dev_priv, start, count, regs);\r\nif (ret != 0)\r\nreturn ret;\r\nif (start < SAVAGE_DRAWCTRL0_S4) {\r\nif (start + count > SAVAGE_DRAWCTRL1_S4 + 1)\r\ncount2 = count -\r\n(SAVAGE_DRAWCTRL1_S4 + 1 - start);\r\nif (start + count > SAVAGE_DRAWCTRL0_S4)\r\ncount = SAVAGE_DRAWCTRL0_S4 - start;\r\n} else if (start <= SAVAGE_DRAWCTRL1_S4) {\r\nif (start + count > SAVAGE_DRAWCTRL1_S4 + 1) {\r\ncount -= SAVAGE_DRAWCTRL1_S4 + 1 - start;\r\nstart = SAVAGE_DRAWCTRL1_S4 + 1;\r\n} else\r\nreturn 0;\r\n}\r\n}\r\nbci_size = count + (count + 254) / 255 + count2 + (count2 + 254) / 255;\r\nif (cmd_header->state.global) {\r\nBEGIN_DMA(bci_size + 1);\r\nDMA_WRITE(BCI_CMD_WAIT | BCI_CMD_WAIT_3D);\r\ndev_priv->waiting = 1;\r\n} else {\r\nBEGIN_DMA(bci_size);\r\n}\r\ndo {\r\nwhile (count > 0) {\r\nunsigned int n = count < 255 ? count : 255;\r\nDMA_SET_REGISTERS(start, n);\r\nDMA_COPY(regs, n);\r\ncount -= n;\r\nstart += n;\r\nregs += n;\r\n}\r\nstart += 2;\r\nregs += 2;\r\ncount = count2;\r\ncount2 = 0;\r\n} while (count);\r\nDMA_COMMIT();\r\nreturn 0;\r\n}\r\nstatic int savage_dispatch_dma_prim(drm_savage_private_t * dev_priv,\r\nconst drm_savage_cmd_header_t * cmd_header,\r\nconst struct drm_buf * dmabuf)\r\n{\r\nunsigned char reorder = 0;\r\nunsigned int prim = cmd_header->prim.prim;\r\nunsigned int skip = cmd_header->prim.skip;\r\nunsigned int n = cmd_header->prim.count;\r\nunsigned int start = cmd_header->prim.start;\r\nunsigned int i;\r\nBCI_LOCALS;\r\nif (!dmabuf) {\r\nDRM_ERROR("called without dma buffers!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!n)\r\nreturn 0;\r\nswitch (prim) {\r\ncase SAVAGE_PRIM_TRILIST_201:\r\nreorder = 1;\r\nprim = SAVAGE_PRIM_TRILIST;\r\ncase SAVAGE_PRIM_TRILIST:\r\nif (n % 3 != 0) {\r\nDRM_ERROR("wrong number of vertices %u in TRILIST\n",\r\nn);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SAVAGE_PRIM_TRISTRIP:\r\ncase SAVAGE_PRIM_TRIFAN:\r\nif (n < 3) {\r\nDRM_ERROR\r\n("wrong number of vertices %u in TRIFAN/STRIP\n",\r\nn);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid primitive type %u\n", prim);\r\nreturn -EINVAL;\r\n}\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\nif (skip != 0) {\r\nDRM_ERROR("invalid skip flags 0x%04x for DMA\n", skip);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nunsigned int size = 10 - (skip & 1) - (skip >> 1 & 1) -\r\n(skip >> 2 & 1) - (skip >> 3 & 1) - (skip >> 4 & 1) -\r\n(skip >> 5 & 1) - (skip >> 6 & 1) - (skip >> 7 & 1);\r\nif (skip > SAVAGE_SKIP_ALL_S4 || size != 8) {\r\nDRM_ERROR("invalid skip flags 0x%04x for DMA\n", skip);\r\nreturn -EINVAL;\r\n}\r\nif (reorder) {\r\nDRM_ERROR("TRILIST_201 used on Savage4 hardware\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (start + n > dmabuf->total / 32) {\r\nDRM_ERROR("vertex indices (%u-%u) out of range (0-%u)\n",\r\nstart, start + n - 1, dmabuf->total / 32);\r\nreturn -EINVAL;\r\n}\r\nDMA_FLUSH();\r\nif (dmabuf->bus_address != dev_priv->state.common.vbaddr) {\r\nBEGIN_BCI(2);\r\nBCI_SET_REGISTERS(SAVAGE_VERTBUFADDR, 1);\r\nBCI_WRITE(dmabuf->bus_address | dev_priv->dma_type);\r\ndev_priv->state.common.vbaddr = dmabuf->bus_address;\r\n}\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset) && dev_priv->waiting) {\r\nBEGIN_BCI(63);\r\nfor (i = 0; i < 63; ++i)\r\nBCI_WRITE(BCI_CMD_WAIT);\r\ndev_priv->waiting = 0;\r\n}\r\nprim <<= 25;\r\nwhile (n != 0) {\r\nunsigned int count = n > 255 ? 255 : n;\r\nif (reorder) {\r\nint reorder[3] = { -1, -1, -1 };\r\nreorder[start % 3] = 2;\r\nBEGIN_BCI((count + 1 + 1) / 2);\r\nBCI_DRAW_INDICES_S3D(count, prim, start + 2);\r\nfor (i = start + 1; i + 1 < start + count; i += 2)\r\nBCI_WRITE((i + reorder[i % 3]) |\r\n((i + 1 +\r\nreorder[(i + 1) % 3]) << 16));\r\nif (i < start + count)\r\nBCI_WRITE(i + reorder[i % 3]);\r\n} else if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\nBEGIN_BCI((count + 1 + 1) / 2);\r\nBCI_DRAW_INDICES_S3D(count, prim, start);\r\nfor (i = start + 1; i + 1 < start + count; i += 2)\r\nBCI_WRITE(i | ((i + 1) << 16));\r\nif (i < start + count)\r\nBCI_WRITE(i);\r\n} else {\r\nBEGIN_BCI((count + 2 + 1) / 2);\r\nBCI_DRAW_INDICES_S4(count, prim, skip);\r\nfor (i = start; i + 1 < start + count; i += 2)\r\nBCI_WRITE(i | ((i + 1) << 16));\r\nif (i < start + count)\r\nBCI_WRITE(i);\r\n}\r\nstart += count;\r\nn -= count;\r\nprim |= BCI_CMD_DRAW_CONT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int savage_dispatch_vb_prim(drm_savage_private_t * dev_priv,\r\nconst drm_savage_cmd_header_t * cmd_header,\r\nconst uint32_t *vtxbuf, unsigned int vb_size,\r\nunsigned int vb_stride)\r\n{\r\nunsigned char reorder = 0;\r\nunsigned int prim = cmd_header->prim.prim;\r\nunsigned int skip = cmd_header->prim.skip;\r\nunsigned int n = cmd_header->prim.count;\r\nunsigned int start = cmd_header->prim.start;\r\nunsigned int vtx_size;\r\nunsigned int i;\r\nDMA_LOCALS;\r\nif (!n)\r\nreturn 0;\r\nswitch (prim) {\r\ncase SAVAGE_PRIM_TRILIST_201:\r\nreorder = 1;\r\nprim = SAVAGE_PRIM_TRILIST;\r\ncase SAVAGE_PRIM_TRILIST:\r\nif (n % 3 != 0) {\r\nDRM_ERROR("wrong number of vertices %u in TRILIST\n",\r\nn);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SAVAGE_PRIM_TRISTRIP:\r\ncase SAVAGE_PRIM_TRIFAN:\r\nif (n < 3) {\r\nDRM_ERROR\r\n("wrong number of vertices %u in TRIFAN/STRIP\n",\r\nn);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid primitive type %u\n", prim);\r\nreturn -EINVAL;\r\n}\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\nif (skip > SAVAGE_SKIP_ALL_S3D) {\r\nDRM_ERROR("invalid skip flags 0x%04x\n", skip);\r\nreturn -EINVAL;\r\n}\r\nvtx_size = 8;\r\n} else {\r\nif (skip > SAVAGE_SKIP_ALL_S4) {\r\nDRM_ERROR("invalid skip flags 0x%04x\n", skip);\r\nreturn -EINVAL;\r\n}\r\nvtx_size = 10;\r\n}\r\nvtx_size -= (skip & 1) + (skip >> 1 & 1) +\r\n(skip >> 2 & 1) + (skip >> 3 & 1) + (skip >> 4 & 1) +\r\n(skip >> 5 & 1) + (skip >> 6 & 1) + (skip >> 7 & 1);\r\nif (vtx_size > vb_stride) {\r\nDRM_ERROR("vertex size greater than vb stride (%u > %u)\n",\r\nvtx_size, vb_stride);\r\nreturn -EINVAL;\r\n}\r\nif (start + n > vb_size / (vb_stride * 4)) {\r\nDRM_ERROR("vertex indices (%u-%u) out of range (0-%u)\n",\r\nstart, start + n - 1, vb_size / (vb_stride * 4));\r\nreturn -EINVAL;\r\n}\r\nprim <<= 25;\r\nwhile (n != 0) {\r\nunsigned int count = n > 255 ? 255 : n;\r\nif (reorder) {\r\nint reorder[3] = { -1, -1, -1 };\r\nreorder[start % 3] = 2;\r\nBEGIN_DMA(count * vtx_size + 1);\r\nDMA_DRAW_PRIMITIVE(count, prim, skip);\r\nfor (i = start; i < start + count; ++i) {\r\nunsigned int j = i + reorder[i % 3];\r\nDMA_COPY(&vtxbuf[vb_stride * j], vtx_size);\r\n}\r\nDMA_COMMIT();\r\n} else {\r\nBEGIN_DMA(count * vtx_size + 1);\r\nDMA_DRAW_PRIMITIVE(count, prim, skip);\r\nif (vb_stride == vtx_size) {\r\nDMA_COPY(&vtxbuf[vb_stride * start],\r\nvtx_size * count);\r\n} else {\r\nfor (i = start; i < start + count; ++i) {\r\nDMA_COPY(&vtxbuf [vb_stride * i],\r\nvtx_size);\r\n}\r\n}\r\nDMA_COMMIT();\r\n}\r\nstart += count;\r\nn -= count;\r\nprim |= BCI_CMD_DRAW_CONT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int savage_dispatch_dma_idx(drm_savage_private_t * dev_priv,\r\nconst drm_savage_cmd_header_t * cmd_header,\r\nconst uint16_t *idx,\r\nconst struct drm_buf * dmabuf)\r\n{\r\nunsigned char reorder = 0;\r\nunsigned int prim = cmd_header->idx.prim;\r\nunsigned int skip = cmd_header->idx.skip;\r\nunsigned int n = cmd_header->idx.count;\r\nunsigned int i;\r\nBCI_LOCALS;\r\nif (!dmabuf) {\r\nDRM_ERROR("called without dma buffers!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!n)\r\nreturn 0;\r\nswitch (prim) {\r\ncase SAVAGE_PRIM_TRILIST_201:\r\nreorder = 1;\r\nprim = SAVAGE_PRIM_TRILIST;\r\ncase SAVAGE_PRIM_TRILIST:\r\nif (n % 3 != 0) {\r\nDRM_ERROR("wrong number of indices %u in TRILIST\n", n);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SAVAGE_PRIM_TRISTRIP:\r\ncase SAVAGE_PRIM_TRIFAN:\r\nif (n < 3) {\r\nDRM_ERROR\r\n("wrong number of indices %u in TRIFAN/STRIP\n", n);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid primitive type %u\n", prim);\r\nreturn -EINVAL;\r\n}\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\nif (skip != 0) {\r\nDRM_ERROR("invalid skip flags 0x%04x for DMA\n", skip);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nunsigned int size = 10 - (skip & 1) - (skip >> 1 & 1) -\r\n(skip >> 2 & 1) - (skip >> 3 & 1) - (skip >> 4 & 1) -\r\n(skip >> 5 & 1) - (skip >> 6 & 1) - (skip >> 7 & 1);\r\nif (skip > SAVAGE_SKIP_ALL_S4 || size != 8) {\r\nDRM_ERROR("invalid skip flags 0x%04x for DMA\n", skip);\r\nreturn -EINVAL;\r\n}\r\nif (reorder) {\r\nDRM_ERROR("TRILIST_201 used on Savage4 hardware\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nDMA_FLUSH();\r\nif (dmabuf->bus_address != dev_priv->state.common.vbaddr) {\r\nBEGIN_BCI(2);\r\nBCI_SET_REGISTERS(SAVAGE_VERTBUFADDR, 1);\r\nBCI_WRITE(dmabuf->bus_address | dev_priv->dma_type);\r\ndev_priv->state.common.vbaddr = dmabuf->bus_address;\r\n}\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset) && dev_priv->waiting) {\r\nBEGIN_BCI(63);\r\nfor (i = 0; i < 63; ++i)\r\nBCI_WRITE(BCI_CMD_WAIT);\r\ndev_priv->waiting = 0;\r\n}\r\nprim <<= 25;\r\nwhile (n != 0) {\r\nunsigned int count = n > 255 ? 255 : n;\r\nfor (i = 0; i < count; ++i) {\r\nif (idx[i] > dmabuf->total / 32) {\r\nDRM_ERROR("idx[%u]=%u out of range (0-%u)\n",\r\ni, idx[i], dmabuf->total / 32);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (reorder) {\r\nint reorder[3] = { 2, -1, -1 };\r\nBEGIN_BCI((count + 1 + 1) / 2);\r\nBCI_DRAW_INDICES_S3D(count, prim, idx[2]);\r\nfor (i = 1; i + 1 < count; i += 2)\r\nBCI_WRITE(idx[i + reorder[i % 3]] |\r\n(idx[i + 1 +\r\nreorder[(i + 1) % 3]] << 16));\r\nif (i < count)\r\nBCI_WRITE(idx[i + reorder[i % 3]]);\r\n} else if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\nBEGIN_BCI((count + 1 + 1) / 2);\r\nBCI_DRAW_INDICES_S3D(count, prim, idx[0]);\r\nfor (i = 1; i + 1 < count; i += 2)\r\nBCI_WRITE(idx[i] | (idx[i + 1] << 16));\r\nif (i < count)\r\nBCI_WRITE(idx[i]);\r\n} else {\r\nBEGIN_BCI((count + 2 + 1) / 2);\r\nBCI_DRAW_INDICES_S4(count, prim, skip);\r\nfor (i = 0; i + 1 < count; i += 2)\r\nBCI_WRITE(idx[i] | (idx[i + 1] << 16));\r\nif (i < count)\r\nBCI_WRITE(idx[i]);\r\n}\r\nidx += count;\r\nn -= count;\r\nprim |= BCI_CMD_DRAW_CONT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int savage_dispatch_vb_idx(drm_savage_private_t * dev_priv,\r\nconst drm_savage_cmd_header_t * cmd_header,\r\nconst uint16_t *idx,\r\nconst uint32_t *vtxbuf,\r\nunsigned int vb_size, unsigned int vb_stride)\r\n{\r\nunsigned char reorder = 0;\r\nunsigned int prim = cmd_header->idx.prim;\r\nunsigned int skip = cmd_header->idx.skip;\r\nunsigned int n = cmd_header->idx.count;\r\nunsigned int vtx_size;\r\nunsigned int i;\r\nDMA_LOCALS;\r\nif (!n)\r\nreturn 0;\r\nswitch (prim) {\r\ncase SAVAGE_PRIM_TRILIST_201:\r\nreorder = 1;\r\nprim = SAVAGE_PRIM_TRILIST;\r\ncase SAVAGE_PRIM_TRILIST:\r\nif (n % 3 != 0) {\r\nDRM_ERROR("wrong number of indices %u in TRILIST\n", n);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SAVAGE_PRIM_TRISTRIP:\r\ncase SAVAGE_PRIM_TRIFAN:\r\nif (n < 3) {\r\nDRM_ERROR\r\n("wrong number of indices %u in TRIFAN/STRIP\n", n);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid primitive type %u\n", prim);\r\nreturn -EINVAL;\r\n}\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\nif (skip > SAVAGE_SKIP_ALL_S3D) {\r\nDRM_ERROR("invalid skip flags 0x%04x\n", skip);\r\nreturn -EINVAL;\r\n}\r\nvtx_size = 8;\r\n} else {\r\nif (skip > SAVAGE_SKIP_ALL_S4) {\r\nDRM_ERROR("invalid skip flags 0x%04x\n", skip);\r\nreturn -EINVAL;\r\n}\r\nvtx_size = 10;\r\n}\r\nvtx_size -= (skip & 1) + (skip >> 1 & 1) +\r\n(skip >> 2 & 1) + (skip >> 3 & 1) + (skip >> 4 & 1) +\r\n(skip >> 5 & 1) + (skip >> 6 & 1) + (skip >> 7 & 1);\r\nif (vtx_size > vb_stride) {\r\nDRM_ERROR("vertex size greater than vb stride (%u > %u)\n",\r\nvtx_size, vb_stride);\r\nreturn -EINVAL;\r\n}\r\nprim <<= 25;\r\nwhile (n != 0) {\r\nunsigned int count = n > 255 ? 255 : n;\r\nfor (i = 0; i < count; ++i) {\r\nif (idx[i] > vb_size / (vb_stride * 4)) {\r\nDRM_ERROR("idx[%u]=%u out of range (0-%u)\n",\r\ni, idx[i], vb_size / (vb_stride * 4));\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (reorder) {\r\nint reorder[3] = { 2, -1, -1 };\r\nBEGIN_DMA(count * vtx_size + 1);\r\nDMA_DRAW_PRIMITIVE(count, prim, skip);\r\nfor (i = 0; i < count; ++i) {\r\nunsigned int j = idx[i + reorder[i % 3]];\r\nDMA_COPY(&vtxbuf[vb_stride * j], vtx_size);\r\n}\r\nDMA_COMMIT();\r\n} else {\r\nBEGIN_DMA(count * vtx_size + 1);\r\nDMA_DRAW_PRIMITIVE(count, prim, skip);\r\nfor (i = 0; i < count; ++i) {\r\nunsigned int j = idx[i];\r\nDMA_COPY(&vtxbuf[vb_stride * j], vtx_size);\r\n}\r\nDMA_COMMIT();\r\n}\r\nidx += count;\r\nn -= count;\r\nprim |= BCI_CMD_DRAW_CONT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int savage_dispatch_clear(drm_savage_private_t * dev_priv,\r\nconst drm_savage_cmd_header_t * cmd_header,\r\nconst drm_savage_cmd_header_t *data,\r\nunsigned int nbox,\r\nconst struct drm_clip_rect *boxes)\r\n{\r\nunsigned int flags = cmd_header->clear0.flags;\r\nunsigned int clear_cmd;\r\nunsigned int i, nbufs;\r\nDMA_LOCALS;\r\nif (nbox == 0)\r\nreturn 0;\r\nclear_cmd = BCI_CMD_RECT | BCI_CMD_RECT_XP | BCI_CMD_RECT_YP |\r\nBCI_CMD_SEND_COLOR | BCI_CMD_DEST_PBD_NEW;\r\nBCI_CMD_SET_ROP(clear_cmd, 0xCC);\r\nnbufs = ((flags & SAVAGE_FRONT) ? 1 : 0) +\r\n((flags & SAVAGE_BACK) ? 1 : 0) + ((flags & SAVAGE_DEPTH) ? 1 : 0);\r\nif (nbufs == 0)\r\nreturn 0;\r\nif (data->clear1.mask != 0xffffffff) {\r\nBEGIN_DMA(2);\r\nDMA_SET_REGISTERS(SAVAGE_BITPLANEWTMASK, 1);\r\nDMA_WRITE(data->clear1.mask);\r\nDMA_COMMIT();\r\n}\r\nfor (i = 0; i < nbox; ++i) {\r\nunsigned int x, y, w, h;\r\nunsigned int buf;\r\nx = boxes[i].x1, y = boxes[i].y1;\r\nw = boxes[i].x2 - boxes[i].x1;\r\nh = boxes[i].y2 - boxes[i].y1;\r\nBEGIN_DMA(nbufs * 6);\r\nfor (buf = SAVAGE_FRONT; buf <= SAVAGE_DEPTH; buf <<= 1) {\r\nif (!(flags & buf))\r\ncontinue;\r\nDMA_WRITE(clear_cmd);\r\nswitch (buf) {\r\ncase SAVAGE_FRONT:\r\nDMA_WRITE(dev_priv->front_offset);\r\nDMA_WRITE(dev_priv->front_bd);\r\nbreak;\r\ncase SAVAGE_BACK:\r\nDMA_WRITE(dev_priv->back_offset);\r\nDMA_WRITE(dev_priv->back_bd);\r\nbreak;\r\ncase SAVAGE_DEPTH:\r\nDMA_WRITE(dev_priv->depth_offset);\r\nDMA_WRITE(dev_priv->depth_bd);\r\nbreak;\r\n}\r\nDMA_WRITE(data->clear1.value);\r\nDMA_WRITE(BCI_X_Y(x, y));\r\nDMA_WRITE(BCI_W_H(w, h));\r\n}\r\nDMA_COMMIT();\r\n}\r\nif (data->clear1.mask != 0xffffffff) {\r\nBEGIN_DMA(2);\r\nDMA_SET_REGISTERS(SAVAGE_BITPLANEWTMASK, 1);\r\nDMA_WRITE(0xffffffff);\r\nDMA_COMMIT();\r\n}\r\nreturn 0;\r\n}\r\nstatic int savage_dispatch_swap(drm_savage_private_t * dev_priv,\r\nunsigned int nbox, const struct drm_clip_rect *boxes)\r\n{\r\nunsigned int swap_cmd;\r\nunsigned int i;\r\nDMA_LOCALS;\r\nif (nbox == 0)\r\nreturn 0;\r\nswap_cmd = BCI_CMD_RECT | BCI_CMD_RECT_XP | BCI_CMD_RECT_YP |\r\nBCI_CMD_SRC_PBD_COLOR_NEW | BCI_CMD_DEST_GBD;\r\nBCI_CMD_SET_ROP(swap_cmd, 0xCC);\r\nfor (i = 0; i < nbox; ++i) {\r\nBEGIN_DMA(6);\r\nDMA_WRITE(swap_cmd);\r\nDMA_WRITE(dev_priv->back_offset);\r\nDMA_WRITE(dev_priv->back_bd);\r\nDMA_WRITE(BCI_X_Y(boxes[i].x1, boxes[i].y1));\r\nDMA_WRITE(BCI_X_Y(boxes[i].x1, boxes[i].y1));\r\nDMA_WRITE(BCI_W_H(boxes[i].x2 - boxes[i].x1,\r\nboxes[i].y2 - boxes[i].y1));\r\nDMA_COMMIT();\r\n}\r\nreturn 0;\r\n}\r\nstatic int savage_dispatch_draw(drm_savage_private_t * dev_priv,\r\nconst drm_savage_cmd_header_t *start,\r\nconst drm_savage_cmd_header_t *end,\r\nconst struct drm_buf * dmabuf,\r\nconst unsigned int *vtxbuf,\r\nunsigned int vb_size, unsigned int vb_stride,\r\nunsigned int nbox,\r\nconst struct drm_clip_rect *boxes)\r\n{\r\nunsigned int i, j;\r\nint ret;\r\nfor (i = 0; i < nbox; ++i) {\r\nconst drm_savage_cmd_header_t *cmdbuf;\r\ndev_priv->emit_clip_rect(dev_priv, &boxes[i]);\r\ncmdbuf = start;\r\nwhile (cmdbuf < end) {\r\ndrm_savage_cmd_header_t cmd_header;\r\ncmd_header = *cmdbuf;\r\ncmdbuf++;\r\nswitch (cmd_header.cmd.cmd) {\r\ncase SAVAGE_CMD_DMA_PRIM:\r\nret = savage_dispatch_dma_prim(\r\ndev_priv, &cmd_header, dmabuf);\r\nbreak;\r\ncase SAVAGE_CMD_VB_PRIM:\r\nret = savage_dispatch_vb_prim(\r\ndev_priv, &cmd_header,\r\nvtxbuf, vb_size, vb_stride);\r\nbreak;\r\ncase SAVAGE_CMD_DMA_IDX:\r\nj = (cmd_header.idx.count + 3) / 4;\r\nret = savage_dispatch_dma_idx(dev_priv,\r\n&cmd_header, (const uint16_t *)cmdbuf,\r\ndmabuf);\r\ncmdbuf += j;\r\nbreak;\r\ncase SAVAGE_CMD_VB_IDX:\r\nj = (cmd_header.idx.count + 3) / 4;\r\nret = savage_dispatch_vb_idx(dev_priv,\r\n&cmd_header, (const uint16_t *)cmdbuf,\r\n(const uint32_t *)vtxbuf, vb_size,\r\nvb_stride);\r\ncmdbuf += j;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("IMPLEMENTATION ERROR: "\r\n"non-drawing-command %d\n",\r\ncmd_header.cmd.cmd);\r\nreturn -EINVAL;\r\n}\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint savage_bci_cmdbuf(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *dmabuf;\r\ndrm_savage_cmdbuf_t *cmdbuf = data;\r\ndrm_savage_cmd_header_t *kcmd_addr = NULL;\r\ndrm_savage_cmd_header_t *first_draw_cmd;\r\nunsigned int *kvb_addr = NULL;\r\nstruct drm_clip_rect *kbox_addr = NULL;\r\nunsigned int i, j;\r\nint ret = 0;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (dma && dma->buflist) {\r\nif (cmdbuf->dma_idx > dma->buf_count) {\r\nDRM_ERROR\r\n("vertex buffer index %u out of range (0-%u)\n",\r\ncmdbuf->dma_idx, dma->buf_count - 1);\r\nreturn -EINVAL;\r\n}\r\ndmabuf = dma->buflist[cmdbuf->dma_idx];\r\n} else {\r\ndmabuf = NULL;\r\n}\r\nif (cmdbuf->size) {\r\nkcmd_addr = kmalloc_array(cmdbuf->size, 8, GFP_KERNEL);\r\nif (kcmd_addr == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(kcmd_addr, cmdbuf->cmd_addr,\r\ncmdbuf->size * 8))\r\n{\r\nkfree(kcmd_addr);\r\nreturn -EFAULT;\r\n}\r\ncmdbuf->cmd_addr = kcmd_addr;\r\n}\r\nif (cmdbuf->vb_size) {\r\nkvb_addr = kmalloc(cmdbuf->vb_size, GFP_KERNEL);\r\nif (kvb_addr == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nif (copy_from_user(kvb_addr, cmdbuf->vb_addr,\r\ncmdbuf->vb_size)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\ncmdbuf->vb_addr = kvb_addr;\r\n}\r\nif (cmdbuf->nbox) {\r\nkbox_addr = kmalloc_array(cmdbuf->nbox, sizeof(struct drm_clip_rect),\r\nGFP_KERNEL);\r\nif (kbox_addr == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nif (copy_from_user(kbox_addr, cmdbuf->box_addr,\r\ncmdbuf->nbox * sizeof(struct drm_clip_rect))) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\ncmdbuf->box_addr = kbox_addr;\r\n}\r\nmb();\r\ndev_priv->waiting = 1;\r\ni = 0;\r\nfirst_draw_cmd = NULL;\r\nwhile (i < cmdbuf->size) {\r\ndrm_savage_cmd_header_t cmd_header;\r\ncmd_header = *(drm_savage_cmd_header_t *)cmdbuf->cmd_addr;\r\ncmdbuf->cmd_addr++;\r\ni++;\r\nj = 0;\r\nswitch (cmd_header.cmd.cmd) {\r\ncase SAVAGE_CMD_DMA_IDX:\r\ncase SAVAGE_CMD_VB_IDX:\r\nj = (cmd_header.idx.count + 3) / 4;\r\nif (i + j > cmdbuf->size) {\r\nDRM_ERROR("indexed drawing command extends "\r\n"beyond end of command buffer\n");\r\nDMA_FLUSH();\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\ncase SAVAGE_CMD_DMA_PRIM:\r\ncase SAVAGE_CMD_VB_PRIM:\r\nif (!first_draw_cmd)\r\nfirst_draw_cmd = cmdbuf->cmd_addr - 1;\r\ncmdbuf->cmd_addr += j;\r\ni += j;\r\nbreak;\r\ndefault:\r\nif (first_draw_cmd) {\r\nret = savage_dispatch_draw(\r\ndev_priv, first_draw_cmd,\r\ncmdbuf->cmd_addr - 1,\r\ndmabuf, cmdbuf->vb_addr, cmdbuf->vb_size,\r\ncmdbuf->vb_stride,\r\ncmdbuf->nbox, cmdbuf->box_addr);\r\nif (ret != 0)\r\ngoto done;\r\nfirst_draw_cmd = NULL;\r\n}\r\n}\r\nif (first_draw_cmd)\r\ncontinue;\r\nswitch (cmd_header.cmd.cmd) {\r\ncase SAVAGE_CMD_STATE:\r\nj = (cmd_header.state.count + 1) / 2;\r\nif (i + j > cmdbuf->size) {\r\nDRM_ERROR("command SAVAGE_CMD_STATE extends "\r\n"beyond end of command buffer\n");\r\nDMA_FLUSH();\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = savage_dispatch_state(dev_priv, &cmd_header,\r\n(const uint32_t *)cmdbuf->cmd_addr);\r\ncmdbuf->cmd_addr += j;\r\ni += j;\r\nbreak;\r\ncase SAVAGE_CMD_CLEAR:\r\nif (i + 1 > cmdbuf->size) {\r\nDRM_ERROR("command SAVAGE_CMD_CLEAR extends "\r\n"beyond end of command buffer\n");\r\nDMA_FLUSH();\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = savage_dispatch_clear(dev_priv, &cmd_header,\r\ncmdbuf->cmd_addr,\r\ncmdbuf->nbox,\r\ncmdbuf->box_addr);\r\ncmdbuf->cmd_addr++;\r\ni++;\r\nbreak;\r\ncase SAVAGE_CMD_SWAP:\r\nret = savage_dispatch_swap(dev_priv, cmdbuf->nbox,\r\ncmdbuf->box_addr);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid command 0x%x\n",\r\ncmd_header.cmd.cmd);\r\nDMA_FLUSH();\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (ret != 0) {\r\nDMA_FLUSH();\r\ngoto done;\r\n}\r\n}\r\nif (first_draw_cmd) {\r\nret = savage_dispatch_draw (\r\ndev_priv, first_draw_cmd, cmdbuf->cmd_addr, dmabuf,\r\ncmdbuf->vb_addr, cmdbuf->vb_size, cmdbuf->vb_stride,\r\ncmdbuf->nbox, cmdbuf->box_addr);\r\nif (ret != 0) {\r\nDMA_FLUSH();\r\ngoto done;\r\n}\r\n}\r\nDMA_FLUSH();\r\nif (dmabuf && cmdbuf->discard) {\r\ndrm_savage_buf_priv_t *buf_priv = dmabuf->dev_private;\r\nuint16_t event;\r\nevent = savage_bci_emit_event(dev_priv, SAVAGE_WAIT_3D);\r\nSET_AGE(&buf_priv->age, event, dev_priv->event_wrap);\r\nsavage_freelist_put(dev, dmabuf);\r\n}\r\ndone:\r\nkfree(kcmd_addr);\r\nkfree(kvb_addr);\r\nkfree(kbox_addr);\r\nreturn ret;\r\n}
