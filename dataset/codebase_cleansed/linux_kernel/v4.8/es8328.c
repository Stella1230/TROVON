static int es8328_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nint val, i, best;\r\nif (es8328->deemph) {\r\nbest = 0;\r\nfor (i = 1; i < ARRAY_SIZE(deemph_settings); i++) {\r\nif (abs(deemph_settings[i].rate - es8328->playback_fs) <\r\nabs(deemph_settings[best].rate - es8328->playback_fs))\r\nbest = i;\r\n}\r\nval = deemph_settings[best].val;\r\n} else {\r\nval = ES8328_DACCONTROL6_DEEMPH_OFF;\r\n}\r\ndev_dbg(codec->dev, "Set deemphasis %d\n", val);\r\nreturn snd_soc_update_bits(codec, ES8328_DACCONTROL6,\r\nES8328_DACCONTROL6_DEEMPH_MASK, val);\r\n}\r\nstatic int es8328_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = es8328->deemph;\r\nreturn 0;\r\n}\r\nstatic int es8328_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int deemph = ucontrol->value.integer.value[0];\r\nint ret;\r\nif (deemph > 1)\r\nreturn -EINVAL;\r\nret = es8328_set_deemph(codec);\r\nif (ret < 0)\r\nreturn ret;\r\nes8328->deemph = deemph;\r\nreturn 0;\r\n}\r\nstatic int es8328_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nreturn snd_soc_update_bits(dai->codec, ES8328_DACCONTROL3,\r\nES8328_DACCONTROL3_DACMUTE,\r\nmute ? ES8328_DACCONTROL3_DACMUTE : 0);\r\n}\r\nstatic int es8328_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nif (es8328->sysclk_constraints)\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nes8328->sysclk_constraints);\r\nreturn 0;\r\n}\r\nstatic int es8328_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nint reg;\r\nint wl;\r\nint ratio;\r\nif (!es8328->sysclk_constraints) {\r\ndev_err(codec->dev, "No MCLK configured\n");\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreg = ES8328_DACCONTROL2;\r\nelse\r\nreg = ES8328_ADCCONTROL5;\r\nfor (i = 0; i < es8328->sysclk_constraints->count; i++)\r\nif (es8328->sysclk_constraints->list[i] == params_rate(params))\r\nbreak;\r\nif (i == es8328->sysclk_constraints->count) {\r\ndev_err(codec->dev, "LRCLK %d unsupported with current clock\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nratio = es8328->mclk_ratios[i];\r\nsnd_soc_update_bits(codec, ES8328_MASTERMODE,\r\nES8328_MASTERMODE_MCLKDIV2,\r\nes8328->mclkdiv2 ? ES8328_MASTERMODE_MCLKDIV2 : 0);\r\nswitch (params_width(params)) {\r\ncase 16:\r\nwl = 3;\r\nbreak;\r\ncase 18:\r\nwl = 2;\r\nbreak;\r\ncase 20:\r\nwl = 1;\r\nbreak;\r\ncase 24:\r\nwl = 0;\r\nbreak;\r\ncase 32:\r\nwl = 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsnd_soc_update_bits(codec, ES8328_DACCONTROL1,\r\nES8328_DACCONTROL1_DACWL_MASK,\r\nwl << ES8328_DACCONTROL1_DACWL_SHIFT);\r\nes8328->playback_fs = params_rate(params);\r\nes8328_set_deemph(codec);\r\n} else\r\nsnd_soc_update_bits(codec, ES8328_ADCCONTROL4,\r\nES8328_ADCCONTROL4_ADCWL_MASK,\r\nwl << ES8328_ADCCONTROL4_ADCWL_SHIFT);\r\nreturn snd_soc_update_bits(codec, reg, ES8328_RATEMASK, ratio);\r\n}\r\nstatic int es8328_set_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nint mclkdiv2 = 0;\r\nswitch (freq) {\r\ncase 0:\r\nes8328->sysclk_constraints = NULL;\r\nes8328->mclk_ratios = NULL;\r\nbreak;\r\ncase 22579200:\r\nmclkdiv2 = 1;\r\ncase 11289600:\r\nes8328->sysclk_constraints = &constraints_11289;\r\nes8328->mclk_ratios = ratios_11289;\r\nbreak;\r\ncase 24576000:\r\nmclkdiv2 = 1;\r\ncase 12288000:\r\nes8328->sysclk_constraints = &constraints_12288;\r\nes8328->mclk_ratios = ratios_12288;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nes8328->mclkdiv2 = mclkdiv2;\r\nreturn 0;\r\n}\r\nstatic int es8328_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu8 dac_mode = 0;\r\nu8 adc_mode = 0;\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBM_CFM)\r\nreturn -EINVAL;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ndac_mode |= ES8328_DACCONTROL1_DACFORMAT_I2S;\r\nadc_mode |= ES8328_ADCCONTROL4_ADCFORMAT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ndac_mode |= ES8328_DACCONTROL1_DACFORMAT_RJUST;\r\nadc_mode |= ES8328_ADCCONTROL4_ADCFORMAT_RJUST;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ndac_mode |= ES8328_DACCONTROL1_DACFORMAT_LJUST;\r\nadc_mode |= ES8328_ADCCONTROL4_ADCFORMAT_LJUST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, ES8328_DACCONTROL1,\r\nES8328_DACCONTROL1_DACFORMAT_MASK, dac_mode);\r\nsnd_soc_update_bits(codec, ES8328_ADCCONTROL4,\r\nES8328_ADCCONTROL4_ADCFORMAT_MASK, adc_mode);\r\nsnd_soc_update_bits(codec, ES8328_MASTERMODE,\r\nES8328_MASTERMODE_MSC, ES8328_MASTERMODE_MSC);\r\nreturn 0;\r\n}\r\nstatic int es8328_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_write(codec, ES8328_CHIPPOWER, 0);\r\nsnd_soc_update_bits(codec, ES8328_CONTROL1,\r\nES8328_CONTROL1_VMIDSEL_MASK |\r\nES8328_CONTROL1_ENREF,\r\nES8328_CONTROL1_VMIDSEL_50k |\r\nES8328_CONTROL1_ENREF);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nsnd_soc_update_bits(codec, ES8328_CONTROL1,\r\nES8328_CONTROL1_VMIDSEL_MASK |\r\nES8328_CONTROL1_ENREF,\r\nES8328_CONTROL1_VMIDSEL_5k |\r\nES8328_CONTROL1_ENREF);\r\nmsleep(100);\r\n}\r\nsnd_soc_write(codec, ES8328_CONTROL2,\r\nES8328_CONTROL2_OVERCURRENT_ON |\r\nES8328_CONTROL2_THERMAL_SHUTDOWN_ON);\r\nsnd_soc_update_bits(codec, ES8328_CONTROL1,\r\nES8328_CONTROL1_VMIDSEL_MASK |\r\nES8328_CONTROL1_ENREF,\r\nES8328_CONTROL1_VMIDSEL_500k |\r\nES8328_CONTROL1_ENREF);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, ES8328_CONTROL1,\r\nES8328_CONTROL1_VMIDSEL_MASK |\r\nES8328_CONTROL1_ENREF,\r\n0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int es8328_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct es8328_priv *es8328;\r\nint ret;\r\nes8328 = snd_soc_codec_get_drvdata(codec);\r\nclk_disable_unprepare(es8328->clk);\r\nret = regulator_bulk_disable(ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to disable regulators\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int es8328_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct regmap *regmap = dev_get_regmap(codec->dev, NULL);\r\nstruct es8328_priv *es8328;\r\nint ret;\r\nes8328 = snd_soc_codec_get_drvdata(codec);\r\nret = clk_prepare_enable(es8328->clk);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to enable clock\n");\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to enable regulators\n");\r\nreturn ret;\r\n}\r\nregcache_mark_dirty(regmap);\r\nret = regcache_sync(regmap);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to sync regcache\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int es8328_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct es8328_priv *es8328;\r\nint ret;\r\nes8328 = snd_soc_codec_get_drvdata(codec);\r\nret = regulator_bulk_enable(ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to enable regulators\n");\r\nreturn ret;\r\n}\r\nes8328->clk = devm_clk_get(codec->dev, NULL);\r\nif (IS_ERR(es8328->clk)) {\r\ndev_err(codec->dev, "codec clock missing or invalid\n");\r\nret = PTR_ERR(es8328->clk);\r\ngoto clk_fail;\r\n}\r\nret = clk_prepare_enable(es8328->clk);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to prepare codec clk\n");\r\ngoto clk_fail;\r\n}\r\nreturn 0;\r\nclk_fail:\r\nregulator_bulk_disable(ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nreturn ret;\r\n}\r\nstatic int es8328_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct es8328_priv *es8328;\r\nes8328 = snd_soc_codec_get_drvdata(codec);\r\nif (es8328->clk)\r\nclk_disable_unprepare(es8328->clk);\r\nregulator_bulk_disable(ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nreturn 0;\r\n}\r\nint es8328_probe(struct device *dev, struct regmap *regmap)\r\n{\r\nstruct es8328_priv *es8328;\r\nint ret;\r\nint i;\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nes8328 = devm_kzalloc(dev, sizeof(*es8328), GFP_KERNEL);\r\nif (es8328 == NULL)\r\nreturn -ENOMEM;\r\nes8328->regmap = regmap;\r\nfor (i = 0; i < ARRAY_SIZE(es8328->supplies); i++)\r\nes8328->supplies[i].supply = supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nif (ret) {\r\ndev_err(dev, "unable to get regulators\n");\r\nreturn ret;\r\n}\r\ndev_set_drvdata(dev, es8328);\r\nreturn snd_soc_register_codec(dev,\r\n&es8328_codec_driver, &es8328_dai, 1);\r\n}
