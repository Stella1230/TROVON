int drm_agp_info(struct drm_device *dev, struct drm_agp_info *info)\r\n{\r\nstruct agp_kern_info *kern;\r\nif (!dev->agp || !dev->agp->acquired)\r\nreturn -EINVAL;\r\nkern = &dev->agp->agp_info;\r\ninfo->agp_version_major = kern->version.major;\r\ninfo->agp_version_minor = kern->version.minor;\r\ninfo->mode = kern->mode;\r\ninfo->aperture_base = kern->aper_base;\r\ninfo->aperture_size = kern->aper_size * 1024 * 1024;\r\ninfo->memory_allowed = kern->max_memory << PAGE_SHIFT;\r\ninfo->memory_used = kern->current_memory << PAGE_SHIFT;\r\ninfo->id_vendor = kern->device->vendor;\r\ninfo->id_device = kern->device->device;\r\nreturn 0;\r\n}\r\nint drm_agp_info_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_agp_info *info = data;\r\nint err;\r\nerr = drm_agp_info(dev, info);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint drm_agp_acquire(struct drm_device * dev)\r\n{\r\nif (!dev->agp)\r\nreturn -ENODEV;\r\nif (dev->agp->acquired)\r\nreturn -EBUSY;\r\nif (!(dev->agp->bridge = agp_backend_acquire(dev->pdev)))\r\nreturn -ENODEV;\r\ndev->agp->acquired = 1;\r\nreturn 0;\r\n}\r\nint drm_agp_acquire_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn drm_agp_acquire((struct drm_device *) file_priv->minor->dev);\r\n}\r\nint drm_agp_release(struct drm_device * dev)\r\n{\r\nif (!dev->agp || !dev->agp->acquired)\r\nreturn -EINVAL;\r\nagp_backend_release(dev->agp->bridge);\r\ndev->agp->acquired = 0;\r\nreturn 0;\r\n}\r\nint drm_agp_release_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn drm_agp_release(dev);\r\n}\r\nint drm_agp_enable(struct drm_device * dev, struct drm_agp_mode mode)\r\n{\r\nif (!dev->agp || !dev->agp->acquired)\r\nreturn -EINVAL;\r\ndev->agp->mode = mode.mode;\r\nagp_enable(dev->agp->bridge, mode.mode);\r\ndev->agp->enabled = 1;\r\nreturn 0;\r\n}\r\nint drm_agp_enable_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_agp_mode *mode = data;\r\nreturn drm_agp_enable(dev, *mode);\r\n}\r\nint drm_agp_alloc(struct drm_device *dev, struct drm_agp_buffer *request)\r\n{\r\nstruct drm_agp_mem *entry;\r\nstruct agp_memory *memory;\r\nunsigned long pages;\r\nu32 type;\r\nif (!dev->agp || !dev->agp->acquired)\r\nreturn -EINVAL;\r\nif (!(entry = kzalloc(sizeof(*entry), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\npages = (request->size + PAGE_SIZE - 1) / PAGE_SIZE;\r\ntype = (u32) request->type;\r\nif (!(memory = agp_allocate_memory(dev->agp->bridge, pages, type))) {\r\nkfree(entry);\r\nreturn -ENOMEM;\r\n}\r\nentry->handle = (unsigned long)memory->key + 1;\r\nentry->memory = memory;\r\nentry->bound = 0;\r\nentry->pages = pages;\r\nlist_add(&entry->head, &dev->agp->memory);\r\nrequest->handle = entry->handle;\r\nrequest->physical = memory->physical;\r\nreturn 0;\r\n}\r\nint drm_agp_alloc_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_agp_buffer *request = data;\r\nreturn drm_agp_alloc(dev, request);\r\n}\r\nstatic struct drm_agp_mem *drm_agp_lookup_entry(struct drm_device * dev,\r\nunsigned long handle)\r\n{\r\nstruct drm_agp_mem *entry;\r\nlist_for_each_entry(entry, &dev->agp->memory, head) {\r\nif (entry->handle == handle)\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nint drm_agp_unbind(struct drm_device *dev, struct drm_agp_binding *request)\r\n{\r\nstruct drm_agp_mem *entry;\r\nint ret;\r\nif (!dev->agp || !dev->agp->acquired)\r\nreturn -EINVAL;\r\nif (!(entry = drm_agp_lookup_entry(dev, request->handle)))\r\nreturn -EINVAL;\r\nif (!entry->bound)\r\nreturn -EINVAL;\r\nret = drm_unbind_agp(entry->memory);\r\nif (ret == 0)\r\nentry->bound = 0;\r\nreturn ret;\r\n}\r\nint drm_agp_unbind_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_agp_binding *request = data;\r\nreturn drm_agp_unbind(dev, request);\r\n}\r\nint drm_agp_bind(struct drm_device *dev, struct drm_agp_binding *request)\r\n{\r\nstruct drm_agp_mem *entry;\r\nint retcode;\r\nint page;\r\nif (!dev->agp || !dev->agp->acquired)\r\nreturn -EINVAL;\r\nif (!(entry = drm_agp_lookup_entry(dev, request->handle)))\r\nreturn -EINVAL;\r\nif (entry->bound)\r\nreturn -EINVAL;\r\npage = (request->offset + PAGE_SIZE - 1) / PAGE_SIZE;\r\nif ((retcode = drm_bind_agp(entry->memory, page)))\r\nreturn retcode;\r\nentry->bound = dev->agp->base + (page << PAGE_SHIFT);\r\nDRM_DEBUG("base = 0x%lx entry->bound = 0x%lx\n",\r\ndev->agp->base, entry->bound);\r\nreturn 0;\r\n}\r\nint drm_agp_bind_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_agp_binding *request = data;\r\nreturn drm_agp_bind(dev, request);\r\n}\r\nint drm_agp_free(struct drm_device *dev, struct drm_agp_buffer *request)\r\n{\r\nstruct drm_agp_mem *entry;\r\nif (!dev->agp || !dev->agp->acquired)\r\nreturn -EINVAL;\r\nif (!(entry = drm_agp_lookup_entry(dev, request->handle)))\r\nreturn -EINVAL;\r\nif (entry->bound)\r\ndrm_unbind_agp(entry->memory);\r\nlist_del(&entry->head);\r\ndrm_free_agp(entry->memory, entry->pages);\r\nkfree(entry);\r\nreturn 0;\r\n}\r\nint drm_agp_free_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_agp_buffer *request = data;\r\nreturn drm_agp_free(dev, request);\r\n}\r\nstruct drm_agp_head *drm_agp_init(struct drm_device *dev)\r\n{\r\nstruct drm_agp_head *head = NULL;\r\nif (!(head = kzalloc(sizeof(*head), GFP_KERNEL)))\r\nreturn NULL;\r\nhead->bridge = agp_find_bridge(dev->pdev);\r\nif (!head->bridge) {\r\nif (!(head->bridge = agp_backend_acquire(dev->pdev))) {\r\nkfree(head);\r\nreturn NULL;\r\n}\r\nagp_copy_info(head->bridge, &head->agp_info);\r\nagp_backend_release(head->bridge);\r\n} else {\r\nagp_copy_info(head->bridge, &head->agp_info);\r\n}\r\nif (head->agp_info.chipset == NOT_SUPPORTED) {\r\nkfree(head);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&head->memory);\r\nhead->cant_use_aperture = head->agp_info.cant_use_aperture;\r\nhead->page_mask = head->agp_info.page_mask;\r\nhead->base = head->agp_info.aper_base;\r\nreturn head;\r\n}\r\nvoid drm_legacy_agp_clear(struct drm_device *dev)\r\n{\r\nstruct drm_agp_mem *entry, *tempe;\r\nif (!dev->agp)\r\nreturn;\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn;\r\nlist_for_each_entry_safe(entry, tempe, &dev->agp->memory, head) {\r\nif (entry->bound)\r\ndrm_unbind_agp(entry->memory);\r\ndrm_free_agp(entry->memory, entry->pages);\r\nkfree(entry);\r\n}\r\nINIT_LIST_HEAD(&dev->agp->memory);\r\nif (dev->agp->acquired)\r\ndrm_agp_release(dev);\r\ndev->agp->acquired = 0;\r\ndev->agp->enabled = 0;\r\n}\r\nstruct agp_memory *\r\ndrm_agp_bind_pages(struct drm_device *dev,\r\nstruct page **pages,\r\nunsigned long num_pages,\r\nuint32_t gtt_offset,\r\nu32 type)\r\n{\r\nstruct agp_memory *mem;\r\nint ret, i;\r\nDRM_DEBUG("\n");\r\nmem = agp_allocate_memory(dev->agp->bridge, num_pages,\r\ntype);\r\nif (mem == NULL) {\r\nDRM_ERROR("Failed to allocate memory for %ld pages\n",\r\nnum_pages);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < num_pages; i++)\r\nmem->pages[i] = pages[i];\r\nmem->page_count = num_pages;\r\nmem->is_flushed = true;\r\nret = agp_bind_memory(mem, gtt_offset / PAGE_SIZE);\r\nif (ret != 0) {\r\nDRM_ERROR("Failed to bind AGP memory: %d\n", ret);\r\nagp_free_memory(mem);\r\nreturn NULL;\r\n}\r\nreturn mem;\r\n}
