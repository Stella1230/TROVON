static void flexfb_set_addr_win_1(struct fbtft_par *par,\r\nint xs, int ys, int xe, int ye)\r\n{\r\nswitch (par->info->var.rotate) {\r\ncase 0:\r\nwrite_reg(par, 0x0020, xs);\r\nwrite_reg(par, 0x0021, ys);\r\nbreak;\r\ncase 180:\r\nwrite_reg(par, 0x0020, width - 1 - xs);\r\nwrite_reg(par, 0x0021, height - 1 - ys);\r\nbreak;\r\ncase 270:\r\nwrite_reg(par, 0x0020, width - 1 - ys);\r\nwrite_reg(par, 0x0021, xs);\r\nbreak;\r\ncase 90:\r\nwrite_reg(par, 0x0020, ys);\r\nwrite_reg(par, 0x0021, height - 1 - xs);\r\nbreak;\r\n}\r\nwrite_reg(par, 0x0022);\r\n}\r\nstatic void flexfb_set_addr_win_2(struct fbtft_par *par,\r\nint xs, int ys, int xe, int ye)\r\n{\r\nswitch (par->info->var.rotate) {\r\ncase 0:\r\nwrite_reg(par, 0x4e, xs);\r\nwrite_reg(par, 0x4f, ys);\r\nbreak;\r\ncase 180:\r\nwrite_reg(par, 0x4e, par->info->var.xres - 1 - xs);\r\nwrite_reg(par, 0x4f, par->info->var.yres - 1 - ys);\r\nbreak;\r\ncase 270:\r\nwrite_reg(par, 0x4e, par->info->var.yres - 1 - ys);\r\nwrite_reg(par, 0x4f, xs);\r\nbreak;\r\ncase 90:\r\nwrite_reg(par, 0x4e, ys);\r\nwrite_reg(par, 0x4f, par->info->var.xres - 1 - xs);\r\nbreak;\r\n}\r\nwrite_reg(par, 0x22, 0);\r\n}\r\nstatic void set_addr_win_3(struct fbtft_par *par,\r\nint xs, int ys, int xe, int ye)\r\n{\r\nwrite_reg(par, 0x15, xs, xe);\r\nwrite_reg(par, 0x75, ys, ye);\r\nwrite_reg(par, 0x5C);\r\n}\r\nstatic int flexfb_verify_gpios_dc(struct fbtft_par *par)\r\n{\r\nfbtft_par_dbg(DEBUG_VERIFY_GPIOS, par, "%s()\n", __func__);\r\nif (par->gpio.dc < 0) {\r\ndev_err(par->info->device,\r\n"Missing info about 'dc' gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int flexfb_verify_gpios_db(struct fbtft_par *par)\r\n{\r\nint i;\r\nint num_db = buswidth;\r\nfbtft_par_dbg(DEBUG_VERIFY_GPIOS, par, "%s()\n", __func__);\r\nif (par->gpio.dc < 0) {\r\ndev_err(par->info->device, "Missing info about 'dc' gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->gpio.wr < 0) {\r\ndev_err(par->info->device, "Missing info about 'wr' gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nif (latched && (par->gpio.latch < 0)) {\r\ndev_err(par->info->device, "Missing info about 'latch' gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nif (latched)\r\nnum_db = buswidth / 2;\r\nfor (i = 0; i < num_db; i++) {\r\nif (par->gpio.db[i] < 0) {\r\ndev_err(par->info->device,\r\n"Missing info about 'db%02d' gpio. Aborting.\n",\r\ni);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void flexfb_chip_load_param(const struct flexfb_lcd_controller *chip)\r\n{\r\nif (!width)\r\nwidth = chip->width;\r\nif (!height)\r\nheight = chip->height;\r\nsetaddrwin = chip->setaddrwin;\r\nif (chip->regwidth)\r\nregwidth = chip->regwidth;\r\nif (!init_num) {\r\ninitp = chip->init_seq;\r\ninitp_num = chip->init_seq_sz;\r\n}\r\n}\r\nstatic int flexfb_chip_init(const struct device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(flexfb_chip_table); i++)\r\nif (!strcmp(chip, flexfb_chip_table[i].name)) {\r\nflexfb_chip_load_param(&flexfb_chip_table[i]);\r\nreturn 0;\r\n}\r\ndev_err(dev, "chip=%s is not supported\n", chip);\r\nreturn -EINVAL;\r\n}\r\nstatic int flexfb_probe_common(struct spi_device *sdev,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device *dev;\r\nstruct fb_info *info;\r\nstruct fbtft_par *par;\r\nint ret;\r\ninitp = init;\r\ninitp_num = init_num;\r\nif (sdev)\r\ndev = &sdev->dev;\r\nelse\r\ndev = &pdev->dev;\r\nfbtft_init_dbg(dev, "%s(%s)\n", __func__,\r\nsdev ? "'SPI device'" : "'Platform device'");\r\nif (chip) {\r\nret = flexfb_chip_init(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (width == 0 || height == 0) {\r\ndev_err(dev, "argument(s) missing: width and height has to be set.\n");\r\nreturn -EINVAL;\r\n}\r\nflex_display.width = width;\r\nflex_display.height = height;\r\nfbtft_init_dbg(dev, "Display resolution: %dx%d\n", width, height);\r\nfbtft_init_dbg(dev, "chip = %s\n", chip ? chip : "not set");\r\nfbtft_init_dbg(dev, "setaddrwin = %d\n", setaddrwin);\r\nfbtft_init_dbg(dev, "regwidth = %d\n", regwidth);\r\nfbtft_init_dbg(dev, "buswidth = %d\n", buswidth);\r\ninfo = fbtft_framebuffer_alloc(&flex_display, dev, dev->platform_data);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\nif (sdev)\r\npar->spi = sdev;\r\nelse\r\npar->pdev = pdev;\r\nif (!par->init_sequence)\r\npar->init_sequence = initp;\r\npar->fbtftops.init_display = fbtft_init_display;\r\nswitch (regwidth) {\r\ncase 8:\r\npar->fbtftops.write_register = fbtft_write_reg8_bus8;\r\nbreak;\r\ncase 16:\r\npar->fbtftops.write_register = fbtft_write_reg16_bus8;\r\nbreak;\r\ndefault:\r\ndev_err(dev,\r\n"argument 'regwidth': %d is not supported.\n",\r\nregwidth);\r\nreturn -EINVAL;\r\n}\r\nif (sdev) {\r\npar->fbtftops.write = fbtft_write_spi;\r\nswitch (buswidth) {\r\ncase 8:\r\npar->fbtftops.write_vmem = fbtft_write_vmem16_bus8;\r\nif (!par->startbyte)\r\npar->fbtftops.verify_gpios = flexfb_verify_gpios_dc;\r\nbreak;\r\ncase 9:\r\nif (regwidth == 16) {\r\ndev_err(dev, "argument 'regwidth': %d is not supported with buswidth=%d and SPI.\n", regwidth, buswidth);\r\nreturn -EINVAL;\r\n}\r\npar->fbtftops.write_register = fbtft_write_reg8_bus9;\r\npar->fbtftops.write_vmem = fbtft_write_vmem16_bus9;\r\nif (par->spi->master->bits_per_word_mask\r\n& SPI_BPW_MASK(9)) {\r\npar->spi->bits_per_word = 9;\r\n} else {\r\ndev_warn(dev,\r\n"9-bit SPI not available, emulating using 8-bit.\n");\r\npar->extra = devm_kzalloc(par->info->device,\r\npar->txbuf.len + (par->txbuf.len / 8) + 8,\r\nGFP_KERNEL);\r\nif (!par->extra) {\r\nret = -ENOMEM;\r\ngoto out_release;\r\n}\r\npar->fbtftops.write = fbtft_write_spi_emulate_9;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(dev, "argument 'buswidth': %d is not supported with SPI.\n", buswidth);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\npar->fbtftops.verify_gpios = flexfb_verify_gpios_db;\r\nswitch (buswidth) {\r\ncase 8:\r\npar->fbtftops.write = fbtft_write_gpio8_wr;\r\npar->fbtftops.write_vmem = fbtft_write_vmem16_bus8;\r\nbreak;\r\ncase 16:\r\npar->fbtftops.write_register = fbtft_write_reg16_bus16;\r\nif (latched)\r\npar->fbtftops.write = fbtft_write_gpio16_wr_latched;\r\nelse\r\npar->fbtftops.write = fbtft_write_gpio16_wr;\r\npar->fbtftops.write_vmem = fbtft_write_vmem16_bus16;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "argument 'buswidth': %d is not supported with parallel.\n", buswidth);\r\nreturn -EINVAL;\r\n}\r\n}\r\nswitch (setaddrwin) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\npar->fbtftops.set_addr_win = flexfb_set_addr_win_1;\r\nbreak;\r\ncase 2:\r\npar->fbtftops.set_addr_win = flexfb_set_addr_win_2;\r\nbreak;\r\ncase 3:\r\npar->fbtftops.set_addr_win = set_addr_win_3;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "argument 'setaddrwin': unknown value %d.\n",\r\nsetaddrwin);\r\nreturn -EINVAL;\r\n}\r\nif (!nobacklight)\r\npar->fbtftops.register_backlight = fbtft_register_backlight;\r\nret = fbtft_register_framebuffer(info);\r\nif (ret < 0)\r\ngoto out_release;\r\nreturn 0;\r\nout_release:\r\nfbtft_framebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic int flexfb_remove_common(struct device *dev, struct fb_info *info)\r\n{\r\nstruct fbtft_par *par;\r\nif (!info)\r\nreturn -EINVAL;\r\npar = info->par;\r\nif (par)\r\nfbtft_par_dbg(DEBUG_DRIVER_INIT_FUNCTIONS, par, "%s()\n",\r\n__func__);\r\nfbtft_unregister_framebuffer(info);\r\nfbtft_framebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic int flexfb_probe_spi(struct spi_device *spi)\r\n{\r\nreturn flexfb_probe_common(spi, NULL);\r\n}\r\nstatic int flexfb_remove_spi(struct spi_device *spi)\r\n{\r\nstruct fb_info *info = spi_get_drvdata(spi);\r\nreturn flexfb_remove_common(&spi->dev, info);\r\n}\r\nstatic int flexfb_probe_pdev(struct platform_device *pdev)\r\n{\r\nreturn flexfb_probe_common(NULL, pdev);\r\n}\r\nstatic int flexfb_remove_pdev(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nreturn flexfb_remove_common(&pdev->dev, info);\r\n}\r\nstatic int __init flexfb_init(void)\r\n{\r\nint ret, ret2;\r\nret = spi_register_driver(&flexfb_spi_driver);\r\nret2 = platform_driver_register(&flexfb_platform_driver);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret2;\r\n}\r\nstatic void __exit flexfb_exit(void)\r\n{\r\nspi_unregister_driver(&flexfb_spi_driver);\r\nplatform_driver_unregister(&flexfb_platform_driver);\r\n}
