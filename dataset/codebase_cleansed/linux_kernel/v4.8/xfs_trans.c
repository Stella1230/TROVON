void\r\nxfs_trans_init(\r\nstruct xfs_mount *mp)\r\n{\r\nxfs_trans_resv_calc(mp, M_RES(mp));\r\n}\r\nSTATIC void\r\nxfs_trans_free(\r\nstruct xfs_trans *tp)\r\n{\r\nxfs_extent_busy_sort(&tp->t_busy);\r\nxfs_extent_busy_clear(tp->t_mountp, &tp->t_busy, false);\r\natomic_dec(&tp->t_mountp->m_active_trans);\r\nif (!(tp->t_flags & XFS_TRANS_NO_WRITECOUNT))\r\nsb_end_intwrite(tp->t_mountp->m_super);\r\nxfs_trans_free_dqinfo(tp);\r\nkmem_zone_free(xfs_trans_zone, tp);\r\n}\r\nSTATIC xfs_trans_t *\r\nxfs_trans_dup(\r\nxfs_trans_t *tp)\r\n{\r\nxfs_trans_t *ntp;\r\nntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\r\nntp->t_magic = XFS_TRANS_HEADER_MAGIC;\r\nntp->t_mountp = tp->t_mountp;\r\nINIT_LIST_HEAD(&ntp->t_items);\r\nINIT_LIST_HEAD(&ntp->t_busy);\r\nASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\r\nASSERT(tp->t_ticket != NULL);\r\nntp->t_flags = XFS_TRANS_PERM_LOG_RES |\r\n(tp->t_flags & XFS_TRANS_RESERVE) |\r\n(tp->t_flags & XFS_TRANS_NO_WRITECOUNT);\r\ntp->t_flags |= XFS_TRANS_NO_WRITECOUNT;\r\nntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\r\nntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\r\ntp->t_blk_res = tp->t_blk_res_used;\r\nntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\r\ntp->t_rtx_res = tp->t_rtx_res_used;\r\nntp->t_pflags = tp->t_pflags;\r\nxfs_trans_dup_dqinfo(tp, ntp);\r\natomic_inc(&tp->t_mountp->m_active_trans);\r\nreturn ntp;\r\n}\r\nstatic int\r\nxfs_trans_reserve(\r\nstruct xfs_trans *tp,\r\nstruct xfs_trans_res *resp,\r\nuint blocks,\r\nuint rtextents)\r\n{\r\nint error = 0;\r\nbool rsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\r\ncurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\r\nif (blocks > 0) {\r\nerror = xfs_mod_fdblocks(tp->t_mountp, -((int64_t)blocks), rsvd);\r\nif (error != 0) {\r\ncurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\r\nreturn -ENOSPC;\r\n}\r\ntp->t_blk_res += blocks;\r\n}\r\nif (resp->tr_logres > 0) {\r\nbool permanent = false;\r\nASSERT(tp->t_log_res == 0 ||\r\ntp->t_log_res == resp->tr_logres);\r\nASSERT(tp->t_log_count == 0 ||\r\ntp->t_log_count == resp->tr_logcount);\r\nif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\r\ntp->t_flags |= XFS_TRANS_PERM_LOG_RES;\r\npermanent = true;\r\n} else {\r\nASSERT(tp->t_ticket == NULL);\r\nASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\r\n}\r\nif (tp->t_ticket != NULL) {\r\nASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\r\nerror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\r\n} else {\r\nerror = xfs_log_reserve(tp->t_mountp,\r\nresp->tr_logres,\r\nresp->tr_logcount,\r\n&tp->t_ticket, XFS_TRANSACTION,\r\npermanent);\r\n}\r\nif (error)\r\ngoto undo_blocks;\r\ntp->t_log_res = resp->tr_logres;\r\ntp->t_log_count = resp->tr_logcount;\r\n}\r\nif (rtextents > 0) {\r\nerror = xfs_mod_frextents(tp->t_mountp, -((int64_t)rtextents));\r\nif (error) {\r\nerror = -ENOSPC;\r\ngoto undo_log;\r\n}\r\ntp->t_rtx_res += rtextents;\r\n}\r\nreturn 0;\r\nundo_log:\r\nif (resp->tr_logres > 0) {\r\nxfs_log_done(tp->t_mountp, tp->t_ticket, NULL, false);\r\ntp->t_ticket = NULL;\r\ntp->t_log_res = 0;\r\ntp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\r\n}\r\nundo_blocks:\r\nif (blocks > 0) {\r\nxfs_mod_fdblocks(tp->t_mountp, -((int64_t)blocks), rsvd);\r\ntp->t_blk_res = 0;\r\n}\r\ncurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\r\nreturn error;\r\n}\r\nint\r\nxfs_trans_alloc(\r\nstruct xfs_mount *mp,\r\nstruct xfs_trans_res *resp,\r\nuint blocks,\r\nuint rtextents,\r\nuint flags,\r\nstruct xfs_trans **tpp)\r\n{\r\nstruct xfs_trans *tp;\r\nint error;\r\nif (!(flags & XFS_TRANS_NO_WRITECOUNT))\r\nsb_start_intwrite(mp->m_super);\r\nWARN_ON(mp->m_super->s_writers.frozen == SB_FREEZE_COMPLETE);\r\natomic_inc(&mp->m_active_trans);\r\ntp = kmem_zone_zalloc(xfs_trans_zone,\r\n(flags & XFS_TRANS_NOFS) ? KM_NOFS : KM_SLEEP);\r\ntp->t_magic = XFS_TRANS_HEADER_MAGIC;\r\ntp->t_flags = flags;\r\ntp->t_mountp = mp;\r\nINIT_LIST_HEAD(&tp->t_items);\r\nINIT_LIST_HEAD(&tp->t_busy);\r\nerror = xfs_trans_reserve(tp, resp, blocks, rtextents);\r\nif (error) {\r\nxfs_trans_cancel(tp);\r\nreturn error;\r\n}\r\n*tpp = tp;\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_trans_mod_sb(\r\nxfs_trans_t *tp,\r\nuint field,\r\nint64_t delta)\r\n{\r\nuint32_t flags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\r\nxfs_mount_t *mp = tp->t_mountp;\r\nswitch (field) {\r\ncase XFS_TRANS_SB_ICOUNT:\r\ntp->t_icount_delta += delta;\r\nif (xfs_sb_version_haslazysbcount(&mp->m_sb))\r\nflags &= ~XFS_TRANS_SB_DIRTY;\r\nbreak;\r\ncase XFS_TRANS_SB_IFREE:\r\ntp->t_ifree_delta += delta;\r\nif (xfs_sb_version_haslazysbcount(&mp->m_sb))\r\nflags &= ~XFS_TRANS_SB_DIRTY;\r\nbreak;\r\ncase XFS_TRANS_SB_FDBLOCKS:\r\nif (delta < 0) {\r\ntp->t_blk_res_used += (uint)-delta;\r\nASSERT(tp->t_blk_res_used <= tp->t_blk_res);\r\n}\r\ntp->t_fdblocks_delta += delta;\r\nif (xfs_sb_version_haslazysbcount(&mp->m_sb))\r\nflags &= ~XFS_TRANS_SB_DIRTY;\r\nbreak;\r\ncase XFS_TRANS_SB_RES_FDBLOCKS:\r\nASSERT(delta < 0);\r\ntp->t_res_fdblocks_delta += delta;\r\nif (xfs_sb_version_haslazysbcount(&mp->m_sb))\r\nflags &= ~XFS_TRANS_SB_DIRTY;\r\nbreak;\r\ncase XFS_TRANS_SB_FREXTENTS:\r\nif (delta < 0) {\r\ntp->t_rtx_res_used += (uint)-delta;\r\nASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\r\n}\r\ntp->t_frextents_delta += delta;\r\nbreak;\r\ncase XFS_TRANS_SB_RES_FREXTENTS:\r\nASSERT(delta < 0);\r\ntp->t_res_frextents_delta += delta;\r\nbreak;\r\ncase XFS_TRANS_SB_DBLOCKS:\r\nASSERT(delta > 0);\r\ntp->t_dblocks_delta += delta;\r\nbreak;\r\ncase XFS_TRANS_SB_AGCOUNT:\r\nASSERT(delta > 0);\r\ntp->t_agcount_delta += delta;\r\nbreak;\r\ncase XFS_TRANS_SB_IMAXPCT:\r\ntp->t_imaxpct_delta += delta;\r\nbreak;\r\ncase XFS_TRANS_SB_REXTSIZE:\r\ntp->t_rextsize_delta += delta;\r\nbreak;\r\ncase XFS_TRANS_SB_RBMBLOCKS:\r\ntp->t_rbmblocks_delta += delta;\r\nbreak;\r\ncase XFS_TRANS_SB_RBLOCKS:\r\ntp->t_rblocks_delta += delta;\r\nbreak;\r\ncase XFS_TRANS_SB_REXTENTS:\r\ntp->t_rextents_delta += delta;\r\nbreak;\r\ncase XFS_TRANS_SB_REXTSLOG:\r\ntp->t_rextslog_delta += delta;\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nreturn;\r\n}\r\ntp->t_flags |= flags;\r\n}\r\nSTATIC void\r\nxfs_trans_apply_sb_deltas(\r\nxfs_trans_t *tp)\r\n{\r\nxfs_dsb_t *sbp;\r\nxfs_buf_t *bp;\r\nint whole = 0;\r\nbp = xfs_trans_getsb(tp, tp->t_mountp, 0);\r\nsbp = XFS_BUF_TO_SBP(bp);\r\nASSERT((tp->t_fdblocks_delta + tp->t_res_fdblocks_delta) ==\r\n(tp->t_ag_freeblks_delta + tp->t_ag_flist_delta +\r\ntp->t_ag_btree_delta));\r\nif (!xfs_sb_version_haslazysbcount(&(tp->t_mountp->m_sb))) {\r\nif (tp->t_icount_delta)\r\nbe64_add_cpu(&sbp->sb_icount, tp->t_icount_delta);\r\nif (tp->t_ifree_delta)\r\nbe64_add_cpu(&sbp->sb_ifree, tp->t_ifree_delta);\r\nif (tp->t_fdblocks_delta)\r\nbe64_add_cpu(&sbp->sb_fdblocks, tp->t_fdblocks_delta);\r\nif (tp->t_res_fdblocks_delta)\r\nbe64_add_cpu(&sbp->sb_fdblocks, tp->t_res_fdblocks_delta);\r\n}\r\nif (tp->t_frextents_delta)\r\nbe64_add_cpu(&sbp->sb_frextents, tp->t_frextents_delta);\r\nif (tp->t_res_frextents_delta)\r\nbe64_add_cpu(&sbp->sb_frextents, tp->t_res_frextents_delta);\r\nif (tp->t_dblocks_delta) {\r\nbe64_add_cpu(&sbp->sb_dblocks, tp->t_dblocks_delta);\r\nwhole = 1;\r\n}\r\nif (tp->t_agcount_delta) {\r\nbe32_add_cpu(&sbp->sb_agcount, tp->t_agcount_delta);\r\nwhole = 1;\r\n}\r\nif (tp->t_imaxpct_delta) {\r\nsbp->sb_imax_pct += tp->t_imaxpct_delta;\r\nwhole = 1;\r\n}\r\nif (tp->t_rextsize_delta) {\r\nbe32_add_cpu(&sbp->sb_rextsize, tp->t_rextsize_delta);\r\nwhole = 1;\r\n}\r\nif (tp->t_rbmblocks_delta) {\r\nbe32_add_cpu(&sbp->sb_rbmblocks, tp->t_rbmblocks_delta);\r\nwhole = 1;\r\n}\r\nif (tp->t_rblocks_delta) {\r\nbe64_add_cpu(&sbp->sb_rblocks, tp->t_rblocks_delta);\r\nwhole = 1;\r\n}\r\nif (tp->t_rextents_delta) {\r\nbe64_add_cpu(&sbp->sb_rextents, tp->t_rextents_delta);\r\nwhole = 1;\r\n}\r\nif (tp->t_rextslog_delta) {\r\nsbp->sb_rextslog += tp->t_rextslog_delta;\r\nwhole = 1;\r\n}\r\nxfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\r\nif (whole)\r\nxfs_trans_log_buf(tp, bp, 0, sizeof(xfs_dsb_t) - 1);\r\nelse\r\nxfs_trans_log_buf(tp, bp, offsetof(xfs_dsb_t, sb_icount),\r\noffsetof(xfs_dsb_t, sb_frextents) +\r\nsizeof(sbp->sb_frextents) - 1);\r\n}\r\nSTATIC int\r\nxfs_sb_mod8(\r\nuint8_t *field,\r\nint8_t delta)\r\n{\r\nint8_t counter = *field;\r\ncounter += delta;\r\nif (counter < 0) {\r\nASSERT(0);\r\nreturn -EINVAL;\r\n}\r\n*field = counter;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_sb_mod32(\r\nuint32_t *field,\r\nint32_t delta)\r\n{\r\nint32_t counter = *field;\r\ncounter += delta;\r\nif (counter < 0) {\r\nASSERT(0);\r\nreturn -EINVAL;\r\n}\r\n*field = counter;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_sb_mod64(\r\nuint64_t *field,\r\nint64_t delta)\r\n{\r\nint64_t counter = *field;\r\ncounter += delta;\r\nif (counter < 0) {\r\nASSERT(0);\r\nreturn -EINVAL;\r\n}\r\n*field = counter;\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_trans_unreserve_and_mod_sb(\r\nstruct xfs_trans *tp)\r\n{\r\nstruct xfs_mount *mp = tp->t_mountp;\r\nbool rsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\r\nint64_t blkdelta = 0;\r\nint64_t rtxdelta = 0;\r\nint64_t idelta = 0;\r\nint64_t ifreedelta = 0;\r\nint error;\r\nif (tp->t_blk_res > 0)\r\nblkdelta = tp->t_blk_res;\r\nif ((tp->t_fdblocks_delta != 0) &&\r\n(xfs_sb_version_haslazysbcount(&mp->m_sb) ||\r\n(tp->t_flags & XFS_TRANS_SB_DIRTY)))\r\nblkdelta += tp->t_fdblocks_delta;\r\nif (tp->t_rtx_res > 0)\r\nrtxdelta = tp->t_rtx_res;\r\nif ((tp->t_frextents_delta != 0) &&\r\n(tp->t_flags & XFS_TRANS_SB_DIRTY))\r\nrtxdelta += tp->t_frextents_delta;\r\nif (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\r\n(tp->t_flags & XFS_TRANS_SB_DIRTY)) {\r\nidelta = tp->t_icount_delta;\r\nifreedelta = tp->t_ifree_delta;\r\n}\r\nif (blkdelta) {\r\nerror = xfs_mod_fdblocks(mp, blkdelta, rsvd);\r\nif (error)\r\ngoto out;\r\n}\r\nif (idelta) {\r\nerror = xfs_mod_icount(mp, idelta);\r\nif (error)\r\ngoto out_undo_fdblocks;\r\n}\r\nif (ifreedelta) {\r\nerror = xfs_mod_ifree(mp, ifreedelta);\r\nif (error)\r\ngoto out_undo_icount;\r\n}\r\nif (rtxdelta == 0 && !(tp->t_flags & XFS_TRANS_SB_DIRTY))\r\nreturn;\r\nspin_lock(&mp->m_sb_lock);\r\nif (rtxdelta) {\r\nerror = xfs_sb_mod64(&mp->m_sb.sb_frextents, rtxdelta);\r\nif (error)\r\ngoto out_undo_ifree;\r\n}\r\nif (tp->t_dblocks_delta != 0) {\r\nerror = xfs_sb_mod64(&mp->m_sb.sb_dblocks, tp->t_dblocks_delta);\r\nif (error)\r\ngoto out_undo_frextents;\r\n}\r\nif (tp->t_agcount_delta != 0) {\r\nerror = xfs_sb_mod32(&mp->m_sb.sb_agcount, tp->t_agcount_delta);\r\nif (error)\r\ngoto out_undo_dblocks;\r\n}\r\nif (tp->t_imaxpct_delta != 0) {\r\nerror = xfs_sb_mod8(&mp->m_sb.sb_imax_pct, tp->t_imaxpct_delta);\r\nif (error)\r\ngoto out_undo_agcount;\r\n}\r\nif (tp->t_rextsize_delta != 0) {\r\nerror = xfs_sb_mod32(&mp->m_sb.sb_rextsize,\r\ntp->t_rextsize_delta);\r\nif (error)\r\ngoto out_undo_imaxpct;\r\n}\r\nif (tp->t_rbmblocks_delta != 0) {\r\nerror = xfs_sb_mod32(&mp->m_sb.sb_rbmblocks,\r\ntp->t_rbmblocks_delta);\r\nif (error)\r\ngoto out_undo_rextsize;\r\n}\r\nif (tp->t_rblocks_delta != 0) {\r\nerror = xfs_sb_mod64(&mp->m_sb.sb_rblocks, tp->t_rblocks_delta);\r\nif (error)\r\ngoto out_undo_rbmblocks;\r\n}\r\nif (tp->t_rextents_delta != 0) {\r\nerror = xfs_sb_mod64(&mp->m_sb.sb_rextents,\r\ntp->t_rextents_delta);\r\nif (error)\r\ngoto out_undo_rblocks;\r\n}\r\nif (tp->t_rextslog_delta != 0) {\r\nerror = xfs_sb_mod8(&mp->m_sb.sb_rextslog,\r\ntp->t_rextslog_delta);\r\nif (error)\r\ngoto out_undo_rextents;\r\n}\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn;\r\nout_undo_rextents:\r\nif (tp->t_rextents_delta)\r\nxfs_sb_mod64(&mp->m_sb.sb_rextents, -tp->t_rextents_delta);\r\nout_undo_rblocks:\r\nif (tp->t_rblocks_delta)\r\nxfs_sb_mod64(&mp->m_sb.sb_rblocks, -tp->t_rblocks_delta);\r\nout_undo_rbmblocks:\r\nif (tp->t_rbmblocks_delta)\r\nxfs_sb_mod32(&mp->m_sb.sb_rbmblocks, -tp->t_rbmblocks_delta);\r\nout_undo_rextsize:\r\nif (tp->t_rextsize_delta)\r\nxfs_sb_mod32(&mp->m_sb.sb_rextsize, -tp->t_rextsize_delta);\r\nout_undo_imaxpct:\r\nif (tp->t_rextsize_delta)\r\nxfs_sb_mod8(&mp->m_sb.sb_imax_pct, -tp->t_imaxpct_delta);\r\nout_undo_agcount:\r\nif (tp->t_agcount_delta)\r\nxfs_sb_mod32(&mp->m_sb.sb_agcount, -tp->t_agcount_delta);\r\nout_undo_dblocks:\r\nif (tp->t_dblocks_delta)\r\nxfs_sb_mod64(&mp->m_sb.sb_dblocks, -tp->t_dblocks_delta);\r\nout_undo_frextents:\r\nif (rtxdelta)\r\nxfs_sb_mod64(&mp->m_sb.sb_frextents, -rtxdelta);\r\nout_undo_ifree:\r\nspin_unlock(&mp->m_sb_lock);\r\nif (ifreedelta)\r\nxfs_mod_ifree(mp, -ifreedelta);\r\nout_undo_icount:\r\nif (idelta)\r\nxfs_mod_icount(mp, -idelta);\r\nout_undo_fdblocks:\r\nif (blkdelta)\r\nxfs_mod_fdblocks(mp, -blkdelta, rsvd);\r\nout:\r\nASSERT(error == 0);\r\nreturn;\r\n}\r\nvoid\r\nxfs_trans_add_item(\r\nstruct xfs_trans *tp,\r\nstruct xfs_log_item *lip)\r\n{\r\nstruct xfs_log_item_desc *lidp;\r\nASSERT(lip->li_mountp == tp->t_mountp);\r\nASSERT(lip->li_ailp == tp->t_mountp->m_ail);\r\nlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\r\nlidp->lid_item = lip;\r\nlidp->lid_flags = 0;\r\nlist_add_tail(&lidp->lid_trans, &tp->t_items);\r\nlip->li_desc = lidp;\r\n}\r\nSTATIC void\r\nxfs_trans_free_item_desc(\r\nstruct xfs_log_item_desc *lidp)\r\n{\r\nlist_del_init(&lidp->lid_trans);\r\nkmem_zone_free(xfs_log_item_desc_zone, lidp);\r\n}\r\nvoid\r\nxfs_trans_del_item(\r\nstruct xfs_log_item *lip)\r\n{\r\nxfs_trans_free_item_desc(lip->li_desc);\r\nlip->li_desc = NULL;\r\n}\r\nvoid\r\nxfs_trans_free_items(\r\nstruct xfs_trans *tp,\r\nxfs_lsn_t commit_lsn,\r\nbool abort)\r\n{\r\nstruct xfs_log_item_desc *lidp, *next;\r\nlist_for_each_entry_safe(lidp, next, &tp->t_items, lid_trans) {\r\nstruct xfs_log_item *lip = lidp->lid_item;\r\nlip->li_desc = NULL;\r\nif (commit_lsn != NULLCOMMITLSN)\r\nlip->li_ops->iop_committing(lip, commit_lsn);\r\nif (abort)\r\nlip->li_flags |= XFS_LI_ABORTED;\r\nlip->li_ops->iop_unlock(lip);\r\nxfs_trans_free_item_desc(lidp);\r\n}\r\n}\r\nstatic inline void\r\nxfs_log_item_batch_insert(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur,\r\nstruct xfs_log_item **log_items,\r\nint nr_items,\r\nxfs_lsn_t commit_lsn)\r\n{\r\nint i;\r\nspin_lock(&ailp->xa_lock);\r\nxfs_trans_ail_update_bulk(ailp, cur, log_items, nr_items, commit_lsn);\r\nfor (i = 0; i < nr_items; i++) {\r\nstruct xfs_log_item *lip = log_items[i];\r\nlip->li_ops->iop_unpin(lip, 0);\r\n}\r\n}\r\nvoid\r\nxfs_trans_committed_bulk(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_log_vec *log_vector,\r\nxfs_lsn_t commit_lsn,\r\nint aborted)\r\n{\r\n#define LOG_ITEM_BATCH_SIZE 32\r\nstruct xfs_log_item *log_items[LOG_ITEM_BATCH_SIZE];\r\nstruct xfs_log_vec *lv;\r\nstruct xfs_ail_cursor cur;\r\nint i = 0;\r\nspin_lock(&ailp->xa_lock);\r\nxfs_trans_ail_cursor_last(ailp, &cur, commit_lsn);\r\nspin_unlock(&ailp->xa_lock);\r\nfor (lv = log_vector; lv; lv = lv->lv_next ) {\r\nstruct xfs_log_item *lip = lv->lv_item;\r\nxfs_lsn_t item_lsn;\r\nif (aborted)\r\nlip->li_flags |= XFS_LI_ABORTED;\r\nitem_lsn = lip->li_ops->iop_committed(lip, commit_lsn);\r\nif (XFS_LSN_CMP(item_lsn, (xfs_lsn_t)-1) == 0)\r\ncontinue;\r\nif (aborted) {\r\nASSERT(XFS_FORCED_SHUTDOWN(ailp->xa_mount));\r\nlip->li_ops->iop_unpin(lip, 1);\r\ncontinue;\r\n}\r\nif (item_lsn != commit_lsn) {\r\nspin_lock(&ailp->xa_lock);\r\nif (XFS_LSN_CMP(item_lsn, lip->li_lsn) > 0)\r\nxfs_trans_ail_update(ailp, lip, item_lsn);\r\nelse\r\nspin_unlock(&ailp->xa_lock);\r\nlip->li_ops->iop_unpin(lip, 0);\r\ncontinue;\r\n}\r\nlog_items[i++] = lv->lv_item;\r\nif (i >= LOG_ITEM_BATCH_SIZE) {\r\nxfs_log_item_batch_insert(ailp, &cur, log_items,\r\nLOG_ITEM_BATCH_SIZE, commit_lsn);\r\ni = 0;\r\n}\r\n}\r\nif (i)\r\nxfs_log_item_batch_insert(ailp, &cur, log_items, i, commit_lsn);\r\nspin_lock(&ailp->xa_lock);\r\nxfs_trans_ail_cursor_done(&cur);\r\nspin_unlock(&ailp->xa_lock);\r\n}\r\nstatic int\r\n__xfs_trans_commit(\r\nstruct xfs_trans *tp,\r\nbool regrant)\r\n{\r\nstruct xfs_mount *mp = tp->t_mountp;\r\nxfs_lsn_t commit_lsn = -1;\r\nint error = 0;\r\nint sync = tp->t_flags & XFS_TRANS_SYNC;\r\nif (!(tp->t_flags & XFS_TRANS_DIRTY))\r\ngoto out_unreserve;\r\nif (XFS_FORCED_SHUTDOWN(mp)) {\r\nerror = -EIO;\r\ngoto out_unreserve;\r\n}\r\nASSERT(tp->t_ticket != NULL);\r\nif (tp->t_flags & XFS_TRANS_SB_DIRTY)\r\nxfs_trans_apply_sb_deltas(tp);\r\nxfs_trans_apply_dquot_deltas(tp);\r\nxfs_log_commit_cil(mp, tp, &commit_lsn, regrant);\r\ncurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\r\nxfs_trans_free(tp);\r\nif (sync) {\r\nerror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\r\nXFS_STATS_INC(mp, xs_trans_sync);\r\n} else {\r\nXFS_STATS_INC(mp, xs_trans_async);\r\n}\r\nreturn error;\r\nout_unreserve:\r\nxfs_trans_unreserve_and_mod_sb(tp);\r\nxfs_trans_unreserve_and_mod_dquots(tp);\r\nif (tp->t_ticket) {\r\ncommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, regrant);\r\nif (commit_lsn == -1 && !error)\r\nerror = -EIO;\r\n}\r\ncurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\r\nxfs_trans_free_items(tp, NULLCOMMITLSN, !!error);\r\nxfs_trans_free(tp);\r\nXFS_STATS_INC(mp, xs_trans_empty);\r\nreturn error;\r\n}\r\nint\r\nxfs_trans_commit(\r\nstruct xfs_trans *tp)\r\n{\r\nreturn __xfs_trans_commit(tp, false);\r\n}\r\nvoid\r\nxfs_trans_cancel(\r\nstruct xfs_trans *tp)\r\n{\r\nstruct xfs_mount *mp = tp->t_mountp;\r\nbool dirty = (tp->t_flags & XFS_TRANS_DIRTY);\r\nif (dirty && !XFS_FORCED_SHUTDOWN(mp)) {\r\nXFS_ERROR_REPORT("xfs_trans_cancel", XFS_ERRLEVEL_LOW, mp);\r\nxfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\r\n}\r\n#ifdef DEBUG\r\nif (!dirty && !XFS_FORCED_SHUTDOWN(mp)) {\r\nstruct xfs_log_item_desc *lidp;\r\nlist_for_each_entry(lidp, &tp->t_items, lid_trans)\r\nASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\r\n}\r\n#endif\r\nxfs_trans_unreserve_and_mod_sb(tp);\r\nxfs_trans_unreserve_and_mod_dquots(tp);\r\nif (tp->t_ticket)\r\nxfs_log_done(mp, tp->t_ticket, NULL, false);\r\ncurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\r\nxfs_trans_free_items(tp, NULLCOMMITLSN, dirty);\r\nxfs_trans_free(tp);\r\n}\r\nint\r\n__xfs_trans_roll(\r\nstruct xfs_trans **tpp,\r\nstruct xfs_inode *dp,\r\nint *committed)\r\n{\r\nstruct xfs_trans *trans;\r\nstruct xfs_trans_res tres;\r\nint error;\r\n*committed = 0;\r\ntrans = *tpp;\r\nif (dp)\r\nxfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\r\ntres.tr_logres = trans->t_log_res;\r\ntres.tr_logcount = trans->t_log_count;\r\n*tpp = xfs_trans_dup(trans);\r\nerror = __xfs_trans_commit(trans, true);\r\nif (error)\r\nreturn error;\r\n*committed = 1;\r\ntrans = *tpp;\r\ntres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\r\nerror = xfs_trans_reserve(trans, &tres, 0, 0);\r\nif (error)\r\nreturn error;\r\nif (dp)\r\nxfs_trans_ijoin(trans, dp, 0);\r\nreturn 0;\r\n}\r\nint\r\nxfs_trans_roll(\r\nstruct xfs_trans **tpp,\r\nstruct xfs_inode *dp)\r\n{\r\nint committed;\r\nreturn __xfs_trans_roll(tpp, dp, &committed);\r\n}
