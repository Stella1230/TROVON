static int dio48e_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct dio48e_gpio *const dio48egpio = gpiochip_get_data(chip);\r\nconst unsigned port = offset / 8;\r\nconst unsigned mask = BIT(offset % 8);\r\nreturn !!(dio48egpio->io_state[port] & mask);\r\n}\r\nstatic int dio48e_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct dio48e_gpio *const dio48egpio = gpiochip_get_data(chip);\r\nconst unsigned io_port = offset / 8;\r\nconst unsigned int control_port = io_port / 3;\r\nconst unsigned control_addr = dio48egpio->base + 3 + control_port*4;\r\nunsigned long flags;\r\nunsigned control;\r\nspin_lock_irqsave(&dio48egpio->lock, flags);\r\nif (io_port == 2 || io_port == 5) {\r\nif (offset % 8 > 3) {\r\ndio48egpio->io_state[io_port] |= 0xF0;\r\ndio48egpio->control[control_port] |= BIT(3);\r\n} else {\r\ndio48egpio->io_state[io_port] |= 0x0F;\r\ndio48egpio->control[control_port] |= BIT(0);\r\n}\r\n} else {\r\ndio48egpio->io_state[io_port] |= 0xFF;\r\nif (io_port == 0 || io_port == 3)\r\ndio48egpio->control[control_port] |= BIT(4);\r\nelse\r\ndio48egpio->control[control_port] |= BIT(1);\r\n}\r\ncontrol = BIT(7) | dio48egpio->control[control_port];\r\noutb(control, control_addr);\r\ncontrol &= ~BIT(7);\r\noutb(control, control_addr);\r\nspin_unlock_irqrestore(&dio48egpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dio48e_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct dio48e_gpio *const dio48egpio = gpiochip_get_data(chip);\r\nconst unsigned io_port = offset / 8;\r\nconst unsigned int control_port = io_port / 3;\r\nconst unsigned mask = BIT(offset % 8);\r\nconst unsigned control_addr = dio48egpio->base + 3 + control_port*4;\r\nconst unsigned out_port = (io_port > 2) ? io_port + 1 : io_port;\r\nunsigned long flags;\r\nunsigned control;\r\nspin_lock_irqsave(&dio48egpio->lock, flags);\r\nif (io_port == 2 || io_port == 5) {\r\nif (offset % 8 > 3) {\r\ndio48egpio->io_state[io_port] &= 0x0F;\r\ndio48egpio->control[control_port] &= ~BIT(3);\r\n} else {\r\ndio48egpio->io_state[io_port] &= 0xF0;\r\ndio48egpio->control[control_port] &= ~BIT(0);\r\n}\r\n} else {\r\ndio48egpio->io_state[io_port] &= 0x00;\r\nif (io_port == 0 || io_port == 3)\r\ndio48egpio->control[control_port] &= ~BIT(4);\r\nelse\r\ndio48egpio->control[control_port] &= ~BIT(1);\r\n}\r\nif (value)\r\ndio48egpio->out_state[io_port] |= mask;\r\nelse\r\ndio48egpio->out_state[io_port] &= ~mask;\r\ncontrol = BIT(7) | dio48egpio->control[control_port];\r\noutb(control, control_addr);\r\noutb(dio48egpio->out_state[io_port], dio48egpio->base + out_port);\r\ncontrol &= ~BIT(7);\r\noutb(control, control_addr);\r\nspin_unlock_irqrestore(&dio48egpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dio48e_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct dio48e_gpio *const dio48egpio = gpiochip_get_data(chip);\r\nconst unsigned port = offset / 8;\r\nconst unsigned mask = BIT(offset % 8);\r\nconst unsigned in_port = (port > 2) ? port + 1 : port;\r\nunsigned long flags;\r\nunsigned port_state;\r\nspin_lock_irqsave(&dio48egpio->lock, flags);\r\nif (!(dio48egpio->io_state[port] & mask)) {\r\nspin_unlock_irqrestore(&dio48egpio->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nport_state = inb(dio48egpio->base + in_port);\r\nspin_unlock_irqrestore(&dio48egpio->lock, flags);\r\nreturn !!(port_state & mask);\r\n}\r\nstatic void dio48e_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct dio48e_gpio *const dio48egpio = gpiochip_get_data(chip);\r\nconst unsigned port = offset / 8;\r\nconst unsigned mask = BIT(offset % 8);\r\nconst unsigned out_port = (port > 2) ? port + 1 : port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dio48egpio->lock, flags);\r\nif (value)\r\ndio48egpio->out_state[port] |= mask;\r\nelse\r\ndio48egpio->out_state[port] &= ~mask;\r\noutb(dio48egpio->out_state[port], dio48egpio->base + out_port);\r\nspin_unlock_irqrestore(&dio48egpio->lock, flags);\r\n}\r\nstatic void dio48e_irq_ack(struct irq_data *data)\r\n{\r\n}\r\nstatic void dio48e_irq_mask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct dio48e_gpio *const dio48egpio = gpiochip_get_data(chip);\r\nconst unsigned long offset = irqd_to_hwirq(data);\r\nunsigned long flags;\r\nif (offset != 19 && offset != 43)\r\nreturn;\r\nspin_lock_irqsave(&dio48egpio->lock, flags);\r\nif (offset == 19)\r\ndio48egpio->irq_mask &= ~BIT(0);\r\nelse\r\ndio48egpio->irq_mask &= ~BIT(1);\r\nif (!dio48egpio->irq_mask)\r\ninb(dio48egpio->base + 0xB);\r\nspin_unlock_irqrestore(&dio48egpio->lock, flags);\r\n}\r\nstatic void dio48e_irq_unmask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct dio48e_gpio *const dio48egpio = gpiochip_get_data(chip);\r\nconst unsigned long offset = irqd_to_hwirq(data);\r\nunsigned long flags;\r\nif (offset != 19 && offset != 43)\r\nreturn;\r\nspin_lock_irqsave(&dio48egpio->lock, flags);\r\nif (!dio48egpio->irq_mask) {\r\noutb(0x00, dio48egpio->base + 0xF);\r\noutb(0x00, dio48egpio->base + 0xB);\r\n}\r\nif (offset == 19)\r\ndio48egpio->irq_mask |= BIT(0);\r\nelse\r\ndio48egpio->irq_mask |= BIT(1);\r\nspin_unlock_irqrestore(&dio48egpio->lock, flags);\r\n}\r\nstatic int dio48e_irq_set_type(struct irq_data *data, unsigned flow_type)\r\n{\r\nconst unsigned long offset = irqd_to_hwirq(data);\r\nif (offset != 19 && offset != 43)\r\nreturn -EINVAL;\r\nif (flow_type != IRQ_TYPE_NONE && flow_type != IRQ_TYPE_EDGE_RISING)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dio48e_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct dio48e_gpio *const dio48egpio = dev_id;\r\nstruct gpio_chip *const chip = &dio48egpio->chip;\r\nconst unsigned long irq_mask = dio48egpio->irq_mask;\r\nunsigned long gpio;\r\nfor_each_set_bit(gpio, &irq_mask, 2)\r\ngeneric_handle_irq(irq_find_mapping(chip->irqdomain,\r\n19 + gpio*24));\r\nspin_lock(&dio48egpio->lock);\r\noutb(0x00, dio48egpio->base + 0xF);\r\nspin_unlock(&dio48egpio->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dio48e_probe(struct device *dev, unsigned int id)\r\n{\r\nstruct dio48e_gpio *dio48egpio;\r\nconst char *const name = dev_name(dev);\r\nint err;\r\ndio48egpio = devm_kzalloc(dev, sizeof(*dio48egpio), GFP_KERNEL);\r\nif (!dio48egpio)\r\nreturn -ENOMEM;\r\nif (!devm_request_region(dev, base[id], DIO48E_EXTENT, name)) {\r\ndev_err(dev, "Unable to lock port addresses (0x%X-0x%X)\n",\r\nbase[id], base[id] + DIO48E_EXTENT);\r\nreturn -EBUSY;\r\n}\r\ndio48egpio->chip.label = name;\r\ndio48egpio->chip.parent = dev;\r\ndio48egpio->chip.owner = THIS_MODULE;\r\ndio48egpio->chip.base = -1;\r\ndio48egpio->chip.ngpio = 48;\r\ndio48egpio->chip.get_direction = dio48e_gpio_get_direction;\r\ndio48egpio->chip.direction_input = dio48e_gpio_direction_input;\r\ndio48egpio->chip.direction_output = dio48e_gpio_direction_output;\r\ndio48egpio->chip.get = dio48e_gpio_get;\r\ndio48egpio->chip.set = dio48e_gpio_set;\r\ndio48egpio->base = base[id];\r\ndio48egpio->irq = irq[id];\r\nspin_lock_init(&dio48egpio->lock);\r\ndev_set_drvdata(dev, dio48egpio);\r\nerr = gpiochip_add_data(&dio48egpio->chip, dio48egpio);\r\nif (err) {\r\ndev_err(dev, "GPIO registering failed (%d)\n", err);\r\nreturn err;\r\n}\r\noutb(0x80, base[id] + 3);\r\noutb(0x00, base[id]);\r\noutb(0x00, base[id] + 1);\r\noutb(0x00, base[id] + 2);\r\noutb(0x00, base[id] + 3);\r\noutb(0x80, base[id] + 7);\r\noutb(0x00, base[id] + 4);\r\noutb(0x00, base[id] + 5);\r\noutb(0x00, base[id] + 6);\r\noutb(0x00, base[id] + 7);\r\ninb(base[id] + 0xB);\r\nerr = gpiochip_irqchip_add(&dio48egpio->chip, &dio48e_irqchip, 0,\r\nhandle_edge_irq, IRQ_TYPE_NONE);\r\nif (err) {\r\ndev_err(dev, "Could not add irqchip (%d)\n", err);\r\ngoto err_gpiochip_remove;\r\n}\r\nerr = request_irq(irq[id], dio48e_irq_handler, 0, name, dio48egpio);\r\nif (err) {\r\ndev_err(dev, "IRQ handler registering failed (%d)\n", err);\r\ngoto err_gpiochip_remove;\r\n}\r\nreturn 0;\r\nerr_gpiochip_remove:\r\ngpiochip_remove(&dio48egpio->chip);\r\nreturn err;\r\n}\r\nstatic int dio48e_remove(struct device *dev, unsigned int id)\r\n{\r\nstruct dio48e_gpio *const dio48egpio = dev_get_drvdata(dev);\r\nfree_irq(dio48egpio->irq, dio48egpio);\r\ngpiochip_remove(&dio48egpio->chip);\r\nreturn 0;\r\n}
