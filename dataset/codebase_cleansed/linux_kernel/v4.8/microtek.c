static inline void mts_debug_dump(struct mts_desc* desc) {\r\nMTS_DEBUG("desc at 0x%x: toggle = %02x%02x\n",\r\n(int)desc,\r\n(int)desc->usb_dev->toggle[1],(int)desc->usb_dev->toggle[0]\r\n);\r\nMTS_DEBUG("ep_out=%x ep_response=%x ep_image=%x\n",\r\nusb_sndbulkpipe(desc->usb_dev,desc->ep_out),\r\nusb_rcvbulkpipe(desc->usb_dev,desc->ep_response),\r\nusb_rcvbulkpipe(desc->usb_dev,desc->ep_image)\r\n);\r\n}\r\nstatic inline void mts_show_command(struct scsi_cmnd *srb)\r\n{\r\nchar *what = NULL;\r\nswitch (srb->cmnd[0]) {\r\ncase TEST_UNIT_READY: what = "TEST_UNIT_READY"; break;\r\ncase REZERO_UNIT: what = "REZERO_UNIT"; break;\r\ncase REQUEST_SENSE: what = "REQUEST_SENSE"; break;\r\ncase FORMAT_UNIT: what = "FORMAT_UNIT"; break;\r\ncase READ_BLOCK_LIMITS: what = "READ_BLOCK_LIMITS"; break;\r\ncase REASSIGN_BLOCKS: what = "REASSIGN_BLOCKS"; break;\r\ncase READ_6: what = "READ_6"; break;\r\ncase WRITE_6: what = "WRITE_6"; break;\r\ncase SEEK_6: what = "SEEK_6"; break;\r\ncase READ_REVERSE: what = "READ_REVERSE"; break;\r\ncase WRITE_FILEMARKS: what = "WRITE_FILEMARKS"; break;\r\ncase SPACE: what = "SPACE"; break;\r\ncase INQUIRY: what = "INQUIRY"; break;\r\ncase RECOVER_BUFFERED_DATA: what = "RECOVER_BUFFERED_DATA"; break;\r\ncase MODE_SELECT: what = "MODE_SELECT"; break;\r\ncase RESERVE: what = "RESERVE"; break;\r\ncase RELEASE: what = "RELEASE"; break;\r\ncase COPY: what = "COPY"; break;\r\ncase ERASE: what = "ERASE"; break;\r\ncase MODE_SENSE: what = "MODE_SENSE"; break;\r\ncase START_STOP: what = "START_STOP"; break;\r\ncase RECEIVE_DIAGNOSTIC: what = "RECEIVE_DIAGNOSTIC"; break;\r\ncase SEND_DIAGNOSTIC: what = "SEND_DIAGNOSTIC"; break;\r\ncase ALLOW_MEDIUM_REMOVAL: what = "ALLOW_MEDIUM_REMOVAL"; break;\r\ncase SET_WINDOW: what = "SET_WINDOW"; break;\r\ncase READ_CAPACITY: what = "READ_CAPACITY"; break;\r\ncase READ_10: what = "READ_10"; break;\r\ncase WRITE_10: what = "WRITE_10"; break;\r\ncase SEEK_10: what = "SEEK_10"; break;\r\ncase WRITE_VERIFY: what = "WRITE_VERIFY"; break;\r\ncase VERIFY: what = "VERIFY"; break;\r\ncase SEARCH_HIGH: what = "SEARCH_HIGH"; break;\r\ncase SEARCH_EQUAL: what = "SEARCH_EQUAL"; break;\r\ncase SEARCH_LOW: what = "SEARCH_LOW"; break;\r\ncase SET_LIMITS: what = "SET_LIMITS"; break;\r\ncase READ_POSITION: what = "READ_POSITION"; break;\r\ncase SYNCHRONIZE_CACHE: what = "SYNCHRONIZE_CACHE"; break;\r\ncase LOCK_UNLOCK_CACHE: what = "LOCK_UNLOCK_CACHE"; break;\r\ncase READ_DEFECT_DATA: what = "READ_DEFECT_DATA"; break;\r\ncase MEDIUM_SCAN: what = "MEDIUM_SCAN"; break;\r\ncase COMPARE: what = "COMPARE"; break;\r\ncase COPY_VERIFY: what = "COPY_VERIFY"; break;\r\ncase WRITE_BUFFER: what = "WRITE_BUFFER"; break;\r\ncase READ_BUFFER: what = "READ_BUFFER"; break;\r\ncase UPDATE_BLOCK: what = "UPDATE_BLOCK"; break;\r\ncase READ_LONG: what = "READ_LONG"; break;\r\ncase WRITE_LONG: what = "WRITE_LONG"; break;\r\ncase CHANGE_DEFINITION: what = "CHANGE_DEFINITION"; break;\r\ncase WRITE_SAME: what = "WRITE_SAME"; break;\r\ncase READ_TOC: what = "READ_TOC"; break;\r\ncase LOG_SELECT: what = "LOG_SELECT"; break;\r\ncase LOG_SENSE: what = "LOG_SENSE"; break;\r\ncase MODE_SELECT_10: what = "MODE_SELECT_10"; break;\r\ncase MODE_SENSE_10: what = "MODE_SENSE_10"; break;\r\ncase MOVE_MEDIUM: what = "MOVE_MEDIUM"; break;\r\ncase READ_12: what = "READ_12"; break;\r\ncase WRITE_12: what = "WRITE_12"; break;\r\ncase WRITE_VERIFY_12: what = "WRITE_VERIFY_12"; break;\r\ncase SEARCH_HIGH_12: what = "SEARCH_HIGH_12"; break;\r\ncase SEARCH_EQUAL_12: what = "SEARCH_EQUAL_12"; break;\r\ncase SEARCH_LOW_12: what = "SEARCH_LOW_12"; break;\r\ncase READ_ELEMENT_STATUS: what = "READ_ELEMENT_STATUS"; break;\r\ncase SEND_VOLUME_TAG: what = "SEND_VOLUME_TAG"; break;\r\ncase WRITE_LONG_2: what = "WRITE_LONG_2"; break;\r\ndefault:\r\nMTS_DEBUG("can't decode command\n");\r\ngoto out;\r\nbreak;\r\n}\r\nMTS_DEBUG( "Command %s (%d bytes)\n", what, srb->cmd_len);\r\nout:\r\nMTS_DEBUG( " %10ph\n", srb->cmnd);\r\n}\r\nstatic inline void mts_show_command(struct scsi_cmnd * dummy)\r\n{\r\n}\r\nstatic inline void mts_debug_dump(struct mts_desc* dummy)\r\n{\r\n}\r\nstatic inline void mts_urb_abort(struct mts_desc* desc) {\r\nMTS_DEBUG_GOT_HERE();\r\nmts_debug_dump(desc);\r\nusb_kill_urb( desc->urb );\r\n}\r\nstatic int mts_slave_alloc (struct scsi_device *s)\r\n{\r\ns->inquiry_len = 0x24;\r\nreturn 0;\r\n}\r\nstatic int mts_slave_configure (struct scsi_device *s)\r\n{\r\nblk_queue_dma_alignment(s->request_queue, (512 - 1));\r\nreturn 0;\r\n}\r\nstatic int mts_scsi_abort(struct scsi_cmnd *srb)\r\n{\r\nstruct mts_desc* desc = (struct mts_desc*)(srb->device->host->hostdata[0]);\r\nMTS_DEBUG_GOT_HERE();\r\nmts_urb_abort(desc);\r\nreturn FAILED;\r\n}\r\nstatic int mts_scsi_host_reset(struct scsi_cmnd *srb)\r\n{\r\nstruct mts_desc* desc = (struct mts_desc*)(srb->device->host->hostdata[0]);\r\nint result;\r\nMTS_DEBUG_GOT_HERE();\r\nmts_debug_dump(desc);\r\nresult = usb_lock_device_for_reset(desc->usb_dev, desc->usb_intf);\r\nif (result == 0) {\r\nresult = usb_reset_device(desc->usb_dev);\r\nusb_unlock_device(desc->usb_dev);\r\n}\r\nreturn result ? FAILED : SUCCESS;\r\n}\r\nstatic inline\r\nvoid mts_int_submit_urb (struct urb* transfer,\r\nint pipe,\r\nvoid* data,\r\nunsigned length,\r\nusb_complete_t callback )\r\n{\r\nint res;\r\nMTS_INT_INIT();\r\nusb_fill_bulk_urb(transfer,\r\ncontext->instance->usb_dev,\r\npipe,\r\ndata,\r\nlength,\r\ncallback,\r\ncontext\r\n);\r\nres = usb_submit_urb( transfer, GFP_ATOMIC );\r\nif ( unlikely(res) ) {\r\nMTS_INT_ERROR( "could not submit URB! Error was %d\n",(int)res );\r\ncontext->srb->result = DID_ERROR << 16;\r\nmts_transfer_cleanup(transfer);\r\n}\r\n}\r\nstatic void mts_transfer_cleanup( struct urb *transfer )\r\n{\r\nMTS_INT_INIT();\r\nif ( likely(context->final_callback != NULL) )\r\ncontext->final_callback(context->srb);\r\n}\r\nstatic void mts_transfer_done( struct urb *transfer )\r\n{\r\nMTS_INT_INIT();\r\ncontext->srb->result &= MTS_SCSI_ERR_MASK;\r\ncontext->srb->result |= (unsigned)(*context->scsi_status)<<1;\r\nmts_transfer_cleanup(transfer);\r\n}\r\nstatic void mts_get_status( struct urb *transfer )\r\n{\r\nMTS_INT_INIT();\r\nmts_int_submit_urb(transfer,\r\nusb_rcvbulkpipe(context->instance->usb_dev,\r\ncontext->instance->ep_response),\r\ncontext->scsi_status,\r\n1,\r\nmts_transfer_done );\r\n}\r\nstatic void mts_data_done( struct urb* transfer )\r\n{\r\nint status = transfer->status;\r\nMTS_INT_INIT();\r\nif ( context->data_length != transfer->actual_length ) {\r\nscsi_set_resid(context->srb, context->data_length -\r\ntransfer->actual_length);\r\n} else if ( unlikely(status) ) {\r\ncontext->srb->result = (status == -ENOENT ? DID_ABORT : DID_ERROR)<<16;\r\n}\r\nmts_get_status(transfer);\r\n}\r\nstatic void mts_command_done( struct urb *transfer )\r\n{\r\nint status = transfer->status;\r\nMTS_INT_INIT();\r\nif ( unlikely(status) ) {\r\nif (status == -ENOENT) {\r\nMTS_DEBUG_GOT_HERE();\r\ncontext->srb->result = DID_ABORT<<16;\r\n} else {\r\nMTS_DEBUG_GOT_HERE();\r\ncontext->srb->result = DID_ERROR<<16;\r\n}\r\nmts_transfer_cleanup(transfer);\r\nreturn;\r\n}\r\nif (context->srb->cmnd[0] == REQUEST_SENSE) {\r\nmts_int_submit_urb(transfer,\r\ncontext->data_pipe,\r\ncontext->srb->sense_buffer,\r\ncontext->data_length,\r\nmts_data_done);\r\n} else { if ( context->data ) {\r\nmts_int_submit_urb(transfer,\r\ncontext->data_pipe,\r\ncontext->data,\r\ncontext->data_length,\r\nscsi_sg_count(context->srb) > 1 ?\r\nmts_do_sg : mts_data_done);\r\n} else {\r\nmts_get_status(transfer);\r\n}\r\n}\r\n}\r\nstatic void mts_do_sg (struct urb* transfer)\r\n{\r\nstruct scatterlist * sg;\r\nint status = transfer->status;\r\nMTS_INT_INIT();\r\nMTS_DEBUG("Processing fragment %d of %d\n", context->fragment,\r\nscsi_sg_count(context->srb));\r\nif (unlikely(status)) {\r\ncontext->srb->result = (status == -ENOENT ? DID_ABORT : DID_ERROR)<<16;\r\nmts_transfer_cleanup(transfer);\r\n}\r\nsg = scsi_sglist(context->srb);\r\ncontext->fragment++;\r\nmts_int_submit_urb(transfer,\r\ncontext->data_pipe,\r\nsg_virt(&sg[context->fragment]),\r\nsg[context->fragment].length,\r\ncontext->fragment + 1 == scsi_sg_count(context->srb) ?\r\nmts_data_done : mts_do_sg);\r\n}\r\nstatic void\r\nmts_build_transfer_context(struct scsi_cmnd *srb, struct mts_desc* desc)\r\n{\r\nint pipe;\r\nstruct scatterlist * sg;\r\nMTS_DEBUG_GOT_HERE();\r\ndesc->context.instance = desc;\r\ndesc->context.srb = srb;\r\ndesc->context.fragment = 0;\r\nif (!scsi_bufflen(srb)) {\r\ndesc->context.data = NULL;\r\ndesc->context.data_length = 0;\r\nreturn;\r\n} else {\r\nsg = scsi_sglist(srb);\r\ndesc->context.data = sg_virt(&sg[0]);\r\ndesc->context.data_length = sg[0].length;\r\n}\r\nif ( !memcmp( srb->cmnd, mts_read_image_sig, mts_read_image_sig_len )\r\n) { pipe = usb_rcvbulkpipe(desc->usb_dev,desc->ep_image);\r\nMTS_DEBUG( "transferring from desc->ep_image == %d\n",\r\n(int)desc->ep_image );\r\n} else if ( MTS_DIRECTION_IS_IN(srb->cmnd[0]) ) {\r\npipe = usb_rcvbulkpipe(desc->usb_dev,desc->ep_response);\r\nMTS_DEBUG( "transferring from desc->ep_response == %d\n",\r\n(int)desc->ep_response);\r\n} else {\r\nMTS_DEBUG("transferring to desc->ep_out == %d\n",\r\n(int)desc->ep_out);\r\npipe = usb_sndbulkpipe(desc->usb_dev,desc->ep_out);\r\n}\r\ndesc->context.data_pipe = pipe;\r\n}\r\nstatic int\r\nmts_scsi_queuecommand_lck(struct scsi_cmnd *srb, mts_scsi_cmnd_callback callback)\r\n{\r\nstruct mts_desc* desc = (struct mts_desc*)(srb->device->host->hostdata[0]);\r\nint err = 0;\r\nint res;\r\nMTS_DEBUG_GOT_HERE();\r\nmts_show_command(srb);\r\nmts_debug_dump(desc);\r\nif ( srb->device->lun || srb->device->id || srb->device->channel ) {\r\nMTS_DEBUG("Command to LUN=%d ID=%d CHANNEL=%d from SCSI layer\n",(int)srb->device->lun,(int)srb->device->id, (int)srb->device->channel );\r\nMTS_DEBUG("this device doesn't exist\n");\r\nsrb->result = DID_BAD_TARGET << 16;\r\nif(likely(callback != NULL))\r\ncallback(srb);\r\ngoto out;\r\n}\r\nusb_fill_bulk_urb(desc->urb,\r\ndesc->usb_dev,\r\nusb_sndbulkpipe(desc->usb_dev,desc->ep_out),\r\nsrb->cmnd,\r\nsrb->cmd_len,\r\nmts_command_done,\r\n&desc->context\r\n);\r\nmts_build_transfer_context( srb, desc );\r\ndesc->context.final_callback = callback;\r\nres=usb_submit_urb(desc->urb, GFP_ATOMIC);\r\nif(unlikely(res)){\r\nMTS_ERROR("error %d submitting URB\n",(int)res);\r\nsrb->result = DID_ERROR << 16;\r\nif(likely(callback != NULL))\r\ncallback(srb);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int mts_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint i;\r\nint ep_out = -1;\r\nint ep_in_set[3];\r\nint *ep_in_current = ep_in_set;\r\nint err_retval = -ENOMEM;\r\nstruct mts_desc * new_desc;\r\nstruct usb_device *dev = interface_to_usbdev (intf);\r\nstruct usb_host_interface *altsetting;\r\nMTS_DEBUG_GOT_HERE();\r\nMTS_DEBUG( "usb-device descriptor at %x\n", (int)dev );\r\nMTS_DEBUG( "product id = 0x%x, vendor id = 0x%x\n",\r\nle16_to_cpu(dev->descriptor.idProduct),\r\nle16_to_cpu(dev->descriptor.idVendor) );\r\nMTS_DEBUG_GOT_HERE();\r\naltsetting = intf->cur_altsetting;\r\nif ( altsetting->desc.bNumEndpoints != MTS_EP_TOTAL ) {\r\nMTS_WARNING( "expecting %d got %d endpoints! Bailing out.\n",\r\n(int)MTS_EP_TOTAL, (int)altsetting->desc.bNumEndpoints );\r\nreturn -ENODEV;\r\n}\r\nfor( i = 0; i < altsetting->desc.bNumEndpoints; i++ ) {\r\nif ((altsetting->endpoint[i].desc.bmAttributes &\r\nUSB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_BULK) {\r\nMTS_WARNING( "can only deal with bulk endpoints; endpoint %d is not bulk.\n",\r\n(int)altsetting->endpoint[i].desc.bEndpointAddress );\r\n} else {\r\nif (altsetting->endpoint[i].desc.bEndpointAddress &\r\nUSB_DIR_IN)\r\n*ep_in_current++\r\n= altsetting->endpoint[i].desc.bEndpointAddress &\r\nUSB_ENDPOINT_NUMBER_MASK;\r\nelse {\r\nif ( ep_out != -1 ) {\r\nMTS_WARNING( "can only deal with one output endpoints. Bailing out." );\r\nreturn -ENODEV;\r\n}\r\nep_out = altsetting->endpoint[i].desc.bEndpointAddress &\r\nUSB_ENDPOINT_NUMBER_MASK;\r\n}\r\n}\r\n}\r\nif ( ep_out == -1 ) {\r\nMTS_WARNING( "couldn't find an output bulk endpoint. Bailing out.\n" );\r\nreturn -ENODEV;\r\n}\r\nnew_desc = kzalloc(sizeof(struct mts_desc), GFP_KERNEL);\r\nif (!new_desc)\r\ngoto out;\r\nnew_desc->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!new_desc->urb)\r\ngoto out_kfree;\r\nnew_desc->context.scsi_status = kmalloc(1, GFP_KERNEL);\r\nif (!new_desc->context.scsi_status)\r\ngoto out_free_urb;\r\nnew_desc->usb_dev = dev;\r\nnew_desc->usb_intf = intf;\r\nnew_desc->ep_out = ep_out;\r\nnew_desc->ep_response = ep_in_set[0];\r\nnew_desc->ep_image = ep_in_set[1];\r\nif ( new_desc->ep_out != MTS_EP_OUT )\r\nMTS_WARNING( "will this work? Command EP is not usually %d\n",\r\n(int)new_desc->ep_out );\r\nif ( new_desc->ep_response != MTS_EP_RESPONSE )\r\nMTS_WARNING( "will this work? Response EP is not usually %d\n",\r\n(int)new_desc->ep_response );\r\nif ( new_desc->ep_image != MTS_EP_IMAGE )\r\nMTS_WARNING( "will this work? Image data EP is not usually %d\n",\r\n(int)new_desc->ep_image );\r\nnew_desc->host = scsi_host_alloc(&mts_scsi_host_template,\r\nsizeof(new_desc));\r\nif (!new_desc->host)\r\ngoto out_kfree2;\r\nnew_desc->host->hostdata[0] = (unsigned long)new_desc;\r\nif (scsi_add_host(new_desc->host, &dev->dev)) {\r\nerr_retval = -EIO;\r\ngoto out_host_put;\r\n}\r\nscsi_scan_host(new_desc->host);\r\nusb_set_intfdata(intf, new_desc);\r\nreturn 0;\r\nout_host_put:\r\nscsi_host_put(new_desc->host);\r\nout_kfree2:\r\nkfree(new_desc->context.scsi_status);\r\nout_free_urb:\r\nusb_free_urb(new_desc->urb);\r\nout_kfree:\r\nkfree(new_desc);\r\nout:\r\nreturn err_retval;\r\n}\r\nstatic void mts_usb_disconnect (struct usb_interface *intf)\r\n{\r\nstruct mts_desc *desc = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nusb_kill_urb(desc->urb);\r\nscsi_remove_host(desc->host);\r\nscsi_host_put(desc->host);\r\nusb_free_urb(desc->urb);\r\nkfree(desc->context.scsi_status);\r\nkfree(desc);\r\n}
