static int fsl_ehci_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct fsl_usb2_platform_data *pdata;\r\nstruct usb_hcd *hcd;\r\nstruct resource *res;\r\nint irq;\r\nint retval;\r\npr_debug("initializing FSL-SOC USB Controller\n");\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev,\r\n"No platform data for %s.\n", dev_name(&pdev->dev));\r\nreturn -ENODEV;\r\n}\r\nif (!((pdata->operating_mode == FSL_USB2_DR_HOST) ||\r\n(pdata->operating_mode == FSL_USB2_MPH_HOST) ||\r\n(pdata->operating_mode == FSL_USB2_DR_OTG))) {\r\ndev_err(&pdev->dev,\r\n"Non Host Mode configured for %s. Wrong driver linked.\n",\r\ndev_name(&pdev->dev));\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev,\r\n"Found HC with no IRQ. Check %s setup!\n",\r\ndev_name(&pdev->dev));\r\nreturn -ENODEV;\r\n}\r\nirq = res->start;\r\nhcd = usb_create_hcd(&fsl_ehci_hc_driver, &pdev->dev,\r\ndev_name(&pdev->dev));\r\nif (!hcd) {\r\nretval = -ENOMEM;\r\ngoto err1;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hcd->regs)) {\r\nretval = PTR_ERR(hcd->regs);\r\ngoto err2;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\npdata->regs = hcd->regs;\r\nif (pdata->power_budget)\r\nhcd->power_budget = pdata->power_budget;\r\nif (pdata->init && pdata->init(pdev)) {\r\nretval = -ENODEV;\r\ngoto err2;\r\n}\r\nif (pdata->have_sysif_regs && pdata->controller_ver < FSL_USB_VER_1_6)\r\nclrsetbits_be32(hcd->regs + FSL_SOC_USB_CTRL,\r\nCONTROL_REGISTER_W1C_MASK, 0x4);\r\nif (pdata->has_fsl_erratum_a007792) {\r\nclrsetbits_be32(hcd->regs + FSL_SOC_USB_CTRL,\r\nCONTROL_REGISTER_W1C_MASK, CTRL_UTMI_PHY_EN);\r\nwritel(PORT_PTS_UTMI, hcd->regs + FSL_SOC_USB_PORTSC1);\r\n}\r\nretval = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (retval != 0)\r\ngoto err2;\r\ndevice_wakeup_enable(hcd->self.controller);\r\n#ifdef CONFIG_USB_OTG\r\nif (pdata->operating_mode == FSL_USB2_DR_OTG) {\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nhcd->usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);\r\ndev_dbg(&pdev->dev, "hcd=0x%p ehci=0x%p, phy=0x%p\n",\r\nhcd, ehci, hcd->usb_phy);\r\nif (!IS_ERR_OR_NULL(hcd->usb_phy)) {\r\nretval = otg_set_host(hcd->usb_phy->otg,\r\n&ehci_to_hcd(ehci)->self);\r\nif (retval) {\r\nusb_put_phy(hcd->usb_phy);\r\ngoto err2;\r\n}\r\n} else {\r\ndev_err(&pdev->dev, "can't find phy\n");\r\nretval = -ENODEV;\r\ngoto err2;\r\n}\r\n}\r\n#endif\r\nreturn retval;\r\nerr2:\r\nusb_put_hcd(hcd);\r\nerr1:\r\ndev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);\r\nif (pdata->exit)\r\npdata->exit(pdev);\r\nreturn retval;\r\n}\r\nstatic int ehci_fsl_setup_phy(struct usb_hcd *hcd,\r\nenum fsl_usb2_phy_modes phy_mode,\r\nunsigned int port_offset)\r\n{\r\nu32 portsc;\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nvoid __iomem *non_ehci = hcd->regs;\r\nstruct device *dev = hcd->self.controller;\r\nstruct fsl_usb2_platform_data *pdata = dev_get_platdata(dev);\r\nif (pdata->controller_ver < 0) {\r\ndev_warn(hcd->self.controller, "Could not get controller version\n");\r\nreturn -ENODEV;\r\n}\r\nportsc = ehci_readl(ehci, &ehci->regs->port_status[port_offset]);\r\nportsc &= ~(PORT_PTS_MSK | PORT_PTS_PTW);\r\nswitch (phy_mode) {\r\ncase FSL_USB2_PHY_ULPI:\r\nif (pdata->have_sysif_regs && pdata->controller_ver) {\r\nclrbits32(non_ehci + FSL_SOC_USB_CTRL,\r\nCONTROL_REGISTER_W1C_MASK | UTMI_PHY_EN);\r\nclrsetbits_be32(non_ehci + FSL_SOC_USB_CTRL,\r\nCONTROL_REGISTER_W1C_MASK,\r\nULPI_PHY_CLK_SEL | USB_CTRL_USB_EN);\r\n}\r\nportsc |= PORT_PTS_ULPI;\r\nbreak;\r\ncase FSL_USB2_PHY_SERIAL:\r\nportsc |= PORT_PTS_SERIAL;\r\nbreak;\r\ncase FSL_USB2_PHY_UTMI_WIDE:\r\nportsc |= PORT_PTS_PTW;\r\ncase FSL_USB2_PHY_UTMI:\r\ncase FSL_USB2_PHY_UTMI_DUAL:\r\nif (pdata->have_sysif_regs && pdata->controller_ver) {\r\nclrsetbits_be32(non_ehci + FSL_SOC_USB_CTRL,\r\nCONTROL_REGISTER_W1C_MASK, UTMI_PHY_EN);\r\nmdelay(FSL_UTMI_PHY_DLY);\r\n}\r\nif (pdata->have_sysif_regs)\r\nclrsetbits_be32(non_ehci + FSL_SOC_USB_CTRL,\r\nCONTROL_REGISTER_W1C_MASK,\r\nCTRL_UTMI_PHY_EN);\r\nportsc |= PORT_PTS_UTMI;\r\nbreak;\r\ncase FSL_USB2_PHY_NONE:\r\nbreak;\r\n}\r\nif (pdata->check_phy_clk_valid) {\r\nif (!(ioread32be(non_ehci + FSL_SOC_USB_CTRL) &\r\nPHY_CLK_VALID)) {\r\ndev_warn(hcd->self.controller,\r\n"USB PHY clock invalid\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nehci_writel(ehci, portsc, &ehci->regs->port_status[port_offset]);\r\nif (phy_mode != FSL_USB2_PHY_ULPI && pdata->have_sysif_regs)\r\nclrsetbits_be32(non_ehci + FSL_SOC_USB_CTRL,\r\nCONTROL_REGISTER_W1C_MASK, USB_CTRL_USB_EN);\r\nreturn 0;\r\n}\r\nstatic int ehci_fsl_usb_setup(struct ehci_hcd *ehci)\r\n{\r\nstruct usb_hcd *hcd = ehci_to_hcd(ehci);\r\nstruct fsl_usb2_platform_data *pdata;\r\nvoid __iomem *non_ehci = hcd->regs;\r\npdata = dev_get_platdata(hcd->self.controller);\r\nif (pdata->have_sysif_regs) {\r\niowrite32be(0x0 | SNOOP_SIZE_2GB,\r\nnon_ehci + FSL_SOC_USB_SNOOP1);\r\niowrite32be(0x80000000 | SNOOP_SIZE_2GB,\r\nnon_ehci + FSL_SOC_USB_SNOOP2);\r\n}\r\nif (pdata->has_fsl_erratum_a005275 == 1)\r\nehci->has_fsl_hs_errata = 1;\r\nif ((pdata->operating_mode == FSL_USB2_DR_HOST) ||\r\n(pdata->operating_mode == FSL_USB2_DR_OTG))\r\nif (ehci_fsl_setup_phy(hcd, pdata->phy_mode, 0))\r\nreturn -EINVAL;\r\nif (pdata->operating_mode == FSL_USB2_MPH_HOST) {\r\nunsigned int chip, rev, svr;\r\nsvr = mfspr(SPRN_SVR);\r\nchip = svr >> 16;\r\nrev = (svr >> 4) & 0xf;\r\nif ((rev == 1) && (chip >= 0x8050) && (chip <= 0x8055))\r\nehci->has_fsl_port_bug = 1;\r\nif (pdata->port_enables & FSL_USB2_PORT0_ENABLED)\r\nif (ehci_fsl_setup_phy(hcd, pdata->phy_mode, 0))\r\nreturn -EINVAL;\r\nif (pdata->port_enables & FSL_USB2_PORT1_ENABLED)\r\nif (ehci_fsl_setup_phy(hcd, pdata->phy_mode, 1))\r\nreturn -EINVAL;\r\n}\r\nif (pdata->have_sysif_regs) {\r\n#ifdef CONFIG_FSL_SOC_BOOKE\r\niowrite32be(0x00000008, non_ehci + FSL_SOC_USB_PRICTRL);\r\niowrite32be(0x00000080, non_ehci + FSL_SOC_USB_AGECNTTHRSH);\r\n#else\r\niowrite32be(0x0000000c, non_ehci + FSL_SOC_USB_PRICTRL);\r\niowrite32be(0x00000040, non_ehci + FSL_SOC_USB_AGECNTTHRSH);\r\n#endif\r\niowrite32be(0x00000001, non_ehci + FSL_SOC_USB_SICTRL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ehci_fsl_reinit(struct ehci_hcd *ehci)\r\n{\r\nif (ehci_fsl_usb_setup(ehci))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ehci_fsl_setup(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint retval;\r\nstruct fsl_usb2_platform_data *pdata;\r\nstruct device *dev;\r\ndev = hcd->self.controller;\r\npdata = dev_get_platdata(hcd->self.controller);\r\nehci->big_endian_desc = pdata->big_endian_desc;\r\nehci->big_endian_mmio = pdata->big_endian_mmio;\r\nehci->caps = hcd->regs + 0x100;\r\n#ifdef CONFIG_PPC_83xx\r\nehci->need_oc_pp_cycle = 1;\r\n#endif\r\nhcd->has_tt = 1;\r\nretval = ehci_setup(hcd);\r\nif (retval)\r\nreturn retval;\r\nif (of_device_is_compatible(dev->parent->of_node,\r\n"fsl,mpc5121-usb2-dr")) {\r\nehci_writel(ehci, SBUSCFG_INCR8,\r\nhcd->regs + FSL_SOC_USB_SBUSCFG);\r\n}\r\nretval = ehci_fsl_reinit(ehci);\r\nreturn retval;\r\n}\r\nstatic int ehci_fsl_mpc512x_drv_suspend(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct fsl_usb2_platform_data *pdata = dev_get_platdata(dev);\r\nu32 tmp;\r\n#ifdef CONFIG_DYNAMIC_DEBUG\r\nu32 mode = ehci_readl(ehci, hcd->regs + FSL_SOC_USB_USBMODE);\r\nmode &= USBMODE_CM_MASK;\r\ntmp = ehci_readl(ehci, hcd->regs + 0x140);\r\ndev_dbg(dev, "suspend=%d already_suspended=%d "\r\n"mode=%d usbcmd %08x\n", pdata->suspended,\r\npdata->already_suspended, mode, tmp);\r\n#endif\r\nif (pdata->suspended) {\r\ndev_dbg(dev, "already suspended, leaving early\n");\r\npdata->already_suspended = 1;\r\nreturn 0;\r\n}\r\ndev_dbg(dev, "suspending...\n");\r\nehci->rh_state = EHCI_RH_SUSPENDED;\r\ndev->power.power_state = PMSG_SUSPEND;\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\ntmp = ehci_readl(ehci, &ehci->regs->command);\r\ntmp &= ~CMD_RUN;\r\nehci_writel(ehci, tmp, &ehci->regs->command);\r\npdata->pm_command = ehci_readl(ehci, &ehci->regs->command);\r\npdata->pm_command &= ~CMD_RUN;\r\npdata->pm_status = ehci_readl(ehci, &ehci->regs->status);\r\npdata->pm_intr_enable = ehci_readl(ehci, &ehci->regs->intr_enable);\r\npdata->pm_frame_index = ehci_readl(ehci, &ehci->regs->frame_index);\r\npdata->pm_segment = ehci_readl(ehci, &ehci->regs->segment);\r\npdata->pm_frame_list = ehci_readl(ehci, &ehci->regs->frame_list);\r\npdata->pm_async_next = ehci_readl(ehci, &ehci->regs->async_next);\r\npdata->pm_configured_flag =\r\nehci_readl(ehci, &ehci->regs->configured_flag);\r\npdata->pm_portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);\r\npdata->pm_usbgenctrl = ehci_readl(ehci,\r\nhcd->regs + FSL_SOC_USB_USBGENCTRL);\r\npdata->pm_portsc &= cpu_to_hc32(ehci, ~PORT_RWC_BITS);\r\npdata->suspended = 1;\r\ntmp = ehci_readl(ehci, &ehci->regs->port_status[0]);\r\ntmp &= ~PORT_POWER;\r\nehci_writel(ehci, tmp, &ehci->regs->port_status[0]);\r\nreturn 0;\r\n}\r\nstatic int ehci_fsl_mpc512x_drv_resume(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct fsl_usb2_platform_data *pdata = dev_get_platdata(dev);\r\nu32 tmp;\r\ndev_dbg(dev, "suspend=%d already_suspended=%d\n",\r\npdata->suspended, pdata->already_suspended);\r\nif (pdata->already_suspended) {\r\ndev_dbg(dev, "already suspended, leaving early\n");\r\npdata->already_suspended = 0;\r\nreturn 0;\r\n}\r\nif (!pdata->suspended) {\r\ndev_dbg(dev, "not suspended, leaving early\n");\r\nreturn 0;\r\n}\r\npdata->suspended = 0;\r\ndev_dbg(dev, "resuming...\n");\r\ntmp = USBMODE_CM_HOST | (pdata->es ? USBMODE_ES : 0);\r\nehci_writel(ehci, tmp, hcd->regs + FSL_SOC_USB_USBMODE);\r\nehci_writel(ehci, pdata->pm_usbgenctrl,\r\nhcd->regs + FSL_SOC_USB_USBGENCTRL);\r\nehci_writel(ehci, ISIPHYCTRL_PXE | ISIPHYCTRL_PHYE,\r\nhcd->regs + FSL_SOC_USB_ISIPHYCTRL);\r\nehci_writel(ehci, SBUSCFG_INCR8, hcd->regs + FSL_SOC_USB_SBUSCFG);\r\nehci_writel(ehci, pdata->pm_command, &ehci->regs->command);\r\nehci_writel(ehci, pdata->pm_intr_enable, &ehci->regs->intr_enable);\r\nehci_writel(ehci, pdata->pm_frame_index, &ehci->regs->frame_index);\r\nehci_writel(ehci, pdata->pm_segment, &ehci->regs->segment);\r\nehci_writel(ehci, pdata->pm_frame_list, &ehci->regs->frame_list);\r\nehci_writel(ehci, pdata->pm_async_next, &ehci->regs->async_next);\r\nehci_writel(ehci, pdata->pm_configured_flag,\r\n&ehci->regs->configured_flag);\r\nehci_writel(ehci, pdata->pm_portsc, &ehci->regs->port_status[0]);\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nehci->rh_state = EHCI_RH_RUNNING;\r\ndev->power.power_state = PMSG_ON;\r\ntmp = ehci_readl(ehci, &ehci->regs->command);\r\ntmp |= CMD_RUN;\r\nehci_writel(ehci, tmp, &ehci->regs->command);\r\nusb_hcd_resume_root_hub(hcd);\r\nreturn 0;\r\n}\r\nstatic inline int ehci_fsl_mpc512x_drv_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int ehci_fsl_mpc512x_drv_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct ehci_fsl *hcd_to_ehci_fsl(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nreturn container_of(ehci, struct ehci_fsl, ehci);\r\n}\r\nstatic int ehci_fsl_drv_suspend(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct ehci_fsl *ehci_fsl = hcd_to_ehci_fsl(hcd);\r\nvoid __iomem *non_ehci = hcd->regs;\r\nif (of_device_is_compatible(dev->parent->of_node,\r\n"fsl,mpc5121-usb2-dr")) {\r\nreturn ehci_fsl_mpc512x_drv_suspend(dev);\r\n}\r\nehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd),\r\ndevice_may_wakeup(dev));\r\nif (!fsl_deep_sleep())\r\nreturn 0;\r\nehci_fsl->usb_ctrl = ioread32be(non_ehci + FSL_SOC_USB_CTRL);\r\nreturn 0;\r\n}\r\nstatic int ehci_fsl_drv_resume(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct ehci_fsl *ehci_fsl = hcd_to_ehci_fsl(hcd);\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nvoid __iomem *non_ehci = hcd->regs;\r\nif (of_device_is_compatible(dev->parent->of_node,\r\n"fsl,mpc5121-usb2-dr")) {\r\nreturn ehci_fsl_mpc512x_drv_resume(dev);\r\n}\r\nehci_prepare_ports_for_controller_resume(ehci);\r\nif (!fsl_deep_sleep())\r\nreturn 0;\r\nusb_root_hub_lost_power(hcd->self.root_hub);\r\niowrite32be(ehci_fsl->usb_ctrl, non_ehci + FSL_SOC_USB_CTRL);\r\nehci_reset(ehci);\r\nehci_fsl_reinit(ehci);\r\nreturn 0;\r\n}\r\nstatic int ehci_fsl_drv_restore(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nusb_root_hub_lost_power(hcd->self.root_hub);\r\nreturn 0;\r\n}\r\nstatic int ehci_start_port_reset(struct usb_hcd *hcd, unsigned port)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nu32 status;\r\nif (!port)\r\nreturn -EINVAL;\r\nport--;\r\nstatus = readl(&ehci->regs->port_status[port]);\r\nif (!(status & PORT_CONNECT))\r\nreturn -ENODEV;\r\nif (ehci_is_TDI(ehci)) {\r\nwritel(PORT_RESET |\r\n(status & ~(PORT_CSC | PORT_PEC | PORT_OCC)),\r\n&ehci->regs->port_status[port]);\r\n} else {\r\nwritel(PORT_RESET, &ehci->regs->port_status[port]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_ehci_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_usb2_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nif (!IS_ERR_OR_NULL(hcd->usb_phy)) {\r\notg_set_host(hcd->usb_phy->otg, NULL);\r\nusb_put_phy(hcd->usb_phy);\r\n}\r\nusb_remove_hcd(hcd);\r\nif (pdata->exit)\r\npdata->exit(pdev);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int __init ehci_fsl_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info(DRV_NAME ": " DRIVER_DESC "\n");\r\nehci_init_driver(&fsl_ehci_hc_driver, &ehci_fsl_overrides);\r\nfsl_ehci_hc_driver.product_desc =\r\n"Freescale On-Chip EHCI Host Controller";\r\nfsl_ehci_hc_driver.start_port_reset = ehci_start_port_reset;\r\nreturn platform_driver_register(&ehci_fsl_driver);\r\n}\r\nstatic void __exit ehci_fsl_cleanup(void)\r\n{\r\nplatform_driver_unregister(&ehci_fsl_driver);\r\n}
