int\r\nreiserfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\r\n{\r\nint error, error2;\r\nstruct reiserfs_transaction_handle th;\r\nsize_t jcreate_blocks;\r\nint size = acl ? posix_acl_xattr_size(acl->a_count) : 0;\r\njcreate_blocks = reiserfs_xattr_jcreate_nblocks(inode) +\r\nreiserfs_xattr_nblocks(inode, size) * 2;\r\nreiserfs_write_lock(inode->i_sb);\r\nerror = journal_begin(&th, inode->i_sb, jcreate_blocks);\r\nreiserfs_write_unlock(inode->i_sb);\r\nif (error == 0) {\r\nerror = __reiserfs_set_acl(&th, inode, type, acl);\r\nreiserfs_write_lock(inode->i_sb);\r\nerror2 = journal_end(&th);\r\nreiserfs_write_unlock(inode->i_sb);\r\nif (error2)\r\nerror = error2;\r\n}\r\nreturn error;\r\n}\r\nstatic struct posix_acl *reiserfs_posix_acl_from_disk(const void *value, size_t size)\r\n{\r\nconst char *end = (char *)value + size;\r\nint n, count;\r\nstruct posix_acl *acl;\r\nif (!value)\r\nreturn NULL;\r\nif (size < sizeof(reiserfs_acl_header))\r\nreturn ERR_PTR(-EINVAL);\r\nif (((reiserfs_acl_header *) value)->a_version !=\r\ncpu_to_le32(REISERFS_ACL_VERSION))\r\nreturn ERR_PTR(-EINVAL);\r\nvalue = (char *)value + sizeof(reiserfs_acl_header);\r\ncount = reiserfs_acl_count(size);\r\nif (count < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nif (count == 0)\r\nreturn NULL;\r\nacl = posix_acl_alloc(count, GFP_NOFS);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (n = 0; n < count; n++) {\r\nreiserfs_acl_entry *entry = (reiserfs_acl_entry *) value;\r\nif ((char *)value + sizeof(reiserfs_acl_entry_short) > end)\r\ngoto fail;\r\nacl->a_entries[n].e_tag = le16_to_cpu(entry->e_tag);\r\nacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\r\nswitch (acl->a_entries[n].e_tag) {\r\ncase ACL_USER_OBJ:\r\ncase ACL_GROUP_OBJ:\r\ncase ACL_MASK:\r\ncase ACL_OTHER:\r\nvalue = (char *)value +\r\nsizeof(reiserfs_acl_entry_short);\r\nbreak;\r\ncase ACL_USER:\r\nvalue = (char *)value + sizeof(reiserfs_acl_entry);\r\nif ((char *)value > end)\r\ngoto fail;\r\nacl->a_entries[n].e_uid =\r\nmake_kuid(&init_user_ns,\r\nle32_to_cpu(entry->e_id));\r\nbreak;\r\ncase ACL_GROUP:\r\nvalue = (char *)value + sizeof(reiserfs_acl_entry);\r\nif ((char *)value > end)\r\ngoto fail;\r\nacl->a_entries[n].e_gid =\r\nmake_kgid(&init_user_ns,\r\nle32_to_cpu(entry->e_id));\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nif (value != end)\r\ngoto fail;\r\nreturn acl;\r\nfail:\r\nposix_acl_release(acl);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic void *reiserfs_posix_acl_to_disk(const struct posix_acl *acl, size_t * size)\r\n{\r\nreiserfs_acl_header *ext_acl;\r\nchar *e;\r\nint n;\r\n*size = reiserfs_acl_size(acl->a_count);\r\next_acl = kmalloc(sizeof(reiserfs_acl_header) +\r\nacl->a_count *\r\nsizeof(reiserfs_acl_entry),\r\nGFP_NOFS);\r\nif (!ext_acl)\r\nreturn ERR_PTR(-ENOMEM);\r\next_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);\r\ne = (char *)ext_acl + sizeof(reiserfs_acl_header);\r\nfor (n = 0; n < acl->a_count; n++) {\r\nconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\r\nreiserfs_acl_entry *entry = (reiserfs_acl_entry *) e;\r\nentry->e_tag = cpu_to_le16(acl->a_entries[n].e_tag);\r\nentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\r\nswitch (acl->a_entries[n].e_tag) {\r\ncase ACL_USER:\r\nentry->e_id = cpu_to_le32(\r\nfrom_kuid(&init_user_ns, acl_e->e_uid));\r\ne += sizeof(reiserfs_acl_entry);\r\nbreak;\r\ncase ACL_GROUP:\r\nentry->e_id = cpu_to_le32(\r\nfrom_kgid(&init_user_ns, acl_e->e_gid));\r\ne += sizeof(reiserfs_acl_entry);\r\nbreak;\r\ncase ACL_USER_OBJ:\r\ncase ACL_GROUP_OBJ:\r\ncase ACL_MASK:\r\ncase ACL_OTHER:\r\ne += sizeof(reiserfs_acl_entry_short);\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nreturn (char *)ext_acl;\r\nfail:\r\nkfree(ext_acl);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstruct posix_acl *reiserfs_get_acl(struct inode *inode, int type)\r\n{\r\nchar *name, *value;\r\nstruct posix_acl *acl;\r\nint size;\r\nint retval;\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nname = XATTR_NAME_POSIX_ACL_ACCESS;\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nname = XATTR_NAME_POSIX_ACL_DEFAULT;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nsize = reiserfs_xattr_get(inode, name, NULL, 0);\r\nif (size < 0) {\r\nif (size == -ENODATA || size == -ENOSYS)\r\nreturn NULL;\r\nreturn ERR_PTR(size);\r\n}\r\nvalue = kmalloc(size, GFP_NOFS);\r\nif (!value)\r\nreturn ERR_PTR(-ENOMEM);\r\nretval = reiserfs_xattr_get(inode, name, value, size);\r\nif (retval == -ENODATA || retval == -ENOSYS) {\r\nacl = NULL;\r\n} else if (retval < 0) {\r\nacl = ERR_PTR(retval);\r\n} else {\r\nacl = reiserfs_posix_acl_from_disk(value, retval);\r\n}\r\nkfree(value);\r\nreturn acl;\r\n}\r\nstatic int\r\n__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\r\nint type, struct posix_acl *acl)\r\n{\r\nchar *name;\r\nvoid *value = NULL;\r\nsize_t size = 0;\r\nint error;\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nname = XATTR_NAME_POSIX_ACL_ACCESS;\r\nif (acl) {\r\nerror = posix_acl_equiv_mode(acl, &inode->i_mode);\r\nif (error < 0)\r\nreturn error;\r\nelse {\r\nif (error == 0)\r\nacl = NULL;\r\n}\r\n}\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nname = XATTR_NAME_POSIX_ACL_DEFAULT;\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn acl ? -EACCES : 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (acl) {\r\nvalue = reiserfs_posix_acl_to_disk(acl, &size);\r\nif (IS_ERR(value))\r\nreturn (int)PTR_ERR(value);\r\n}\r\nerror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\r\nif (error == -ENODATA) {\r\nerror = 0;\r\nif (type == ACL_TYPE_ACCESS) {\r\ninode->i_ctime = CURRENT_TIME_SEC;\r\nmark_inode_dirty(inode);\r\n}\r\n}\r\nkfree(value);\r\nif (!error)\r\nset_cached_acl(inode, type, acl);\r\nreturn error;\r\n}\r\nint\r\nreiserfs_inherit_default_acl(struct reiserfs_transaction_handle *th,\r\nstruct inode *dir, struct dentry *dentry,\r\nstruct inode *inode)\r\n{\r\nstruct posix_acl *default_acl, *acl;\r\nint err = 0;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn 0;\r\nif (get_inode_sd_version(dir) == STAT_DATA_V1)\r\ngoto apply_umask;\r\nif (IS_PRIVATE(dir)) {\r\ninode->i_flags |= S_PRIVATE;\r\ngoto apply_umask;\r\n}\r\nerr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\r\nif (err)\r\nreturn err;\r\nif (default_acl) {\r\nerr = __reiserfs_set_acl(th, inode, ACL_TYPE_DEFAULT,\r\ndefault_acl);\r\nposix_acl_release(default_acl);\r\n}\r\nif (acl) {\r\nif (!err)\r\nerr = __reiserfs_set_acl(th, inode, ACL_TYPE_ACCESS,\r\nacl);\r\nposix_acl_release(acl);\r\n}\r\nreturn err;\r\napply_umask:\r\ninode->i_mode &= ~current_umask();\r\nreturn err;\r\n}\r\nint reiserfs_cache_default_acl(struct inode *inode)\r\n{\r\nstruct posix_acl *acl;\r\nint nblocks = 0;\r\nif (IS_PRIVATE(inode))\r\nreturn 0;\r\nacl = get_acl(inode, ACL_TYPE_DEFAULT);\r\nif (acl && !IS_ERR(acl)) {\r\nint size = reiserfs_acl_size(acl->a_count);\r\nnblocks = reiserfs_xattr_jcreate_nblocks(inode);\r\nnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\r\nREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\r\nnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\r\nposix_acl_release(acl);\r\n}\r\nreturn nblocks;\r\n}\r\nint reiserfs_acl_chmod(struct inode *inode)\r\n{\r\nif (IS_PRIVATE(inode))\r\nreturn 0;\r\nif (get_inode_sd_version(inode) == STAT_DATA_V1 ||\r\n!reiserfs_posixacl(inode->i_sb))\r\nreturn 0;\r\nreturn posix_acl_chmod(inode, inode->i_mode);\r\n}
