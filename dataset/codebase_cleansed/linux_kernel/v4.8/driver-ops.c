int drv_start(struct ieee80211_local *local)\r\n{\r\nint ret;\r\nmight_sleep();\r\nif (WARN_ON(local->started))\r\nreturn -EALREADY;\r\ntrace_drv_start(local);\r\nlocal->started = true;\r\nsmp_mb();\r\nret = local->ops->start(&local->hw);\r\ntrace_drv_return_int(local, ret);\r\nif (ret)\r\nlocal->started = false;\r\nreturn ret;\r\n}\r\nvoid drv_stop(struct ieee80211_local *local)\r\n{\r\nmight_sleep();\r\nif (WARN_ON(!local->started))\r\nreturn;\r\ntrace_drv_stop(local);\r\nlocal->ops->stop(&local->hw);\r\ntrace_drv_return_void(local);\r\ntasklet_disable(&local->tasklet);\r\ntasklet_enable(&local->tasklet);\r\nbarrier();\r\nlocal->started = false;\r\n}\r\nint drv_add_interface(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata)\r\n{\r\nint ret;\r\nmight_sleep();\r\nif (WARN_ON(sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\r\n(sdata->vif.type == NL80211_IFTYPE_MONITOR &&\r\n!ieee80211_hw_check(&local->hw, WANT_MONITOR_VIF) &&\r\n!(sdata->u.mntr_flags & MONITOR_FLAG_ACTIVE))))\r\nreturn -EINVAL;\r\ntrace_drv_add_interface(local, sdata);\r\nret = local->ops->add_interface(&local->hw, &sdata->vif);\r\ntrace_drv_return_int(local, ret);\r\nif (ret == 0)\r\nsdata->flags |= IEEE80211_SDATA_IN_DRIVER;\r\nreturn ret;\r\n}\r\nint drv_change_interface(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata,\r\nenum nl80211_iftype type, bool p2p)\r\n{\r\nint ret;\r\nmight_sleep();\r\nif (!check_sdata_in_driver(sdata))\r\nreturn -EIO;\r\ntrace_drv_change_interface(local, sdata, type, p2p);\r\nret = local->ops->change_interface(&local->hw, &sdata->vif, type, p2p);\r\ntrace_drv_return_int(local, ret);\r\nreturn ret;\r\n}\r\nvoid drv_remove_interface(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata)\r\n{\r\nmight_sleep();\r\nif (!check_sdata_in_driver(sdata))\r\nreturn;\r\ntrace_drv_remove_interface(local, sdata);\r\nlocal->ops->remove_interface(&local->hw, &sdata->vif);\r\nsdata->flags &= ~IEEE80211_SDATA_IN_DRIVER;\r\ntrace_drv_return_void(local);\r\n}\r\n__must_check\r\nint drv_sta_state(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta,\r\nenum ieee80211_sta_state old_state,\r\nenum ieee80211_sta_state new_state)\r\n{\r\nint ret = 0;\r\nmight_sleep();\r\nsdata = get_bss_sdata(sdata);\r\nif (!check_sdata_in_driver(sdata))\r\nreturn -EIO;\r\ntrace_drv_sta_state(local, sdata, &sta->sta, old_state, new_state);\r\nif (local->ops->sta_state) {\r\nret = local->ops->sta_state(&local->hw, &sdata->vif, &sta->sta,\r\nold_state, new_state);\r\n} else if (old_state == IEEE80211_STA_AUTH &&\r\nnew_state == IEEE80211_STA_ASSOC) {\r\nret = drv_sta_add(local, sdata, &sta->sta);\r\nif (ret == 0)\r\nsta->uploaded = true;\r\n} else if (old_state == IEEE80211_STA_ASSOC &&\r\nnew_state == IEEE80211_STA_AUTH) {\r\ndrv_sta_remove(local, sdata, &sta->sta);\r\n}\r\ntrace_drv_return_int(local, ret);\r\nreturn ret;\r\n}\r\nvoid drv_sta_rc_update(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_sta *sta, u32 changed)\r\n{\r\nsdata = get_bss_sdata(sdata);\r\nif (!check_sdata_in_driver(sdata))\r\nreturn;\r\nWARN_ON(changed & IEEE80211_RC_SUPP_RATES_CHANGED &&\r\n(sdata->vif.type != NL80211_IFTYPE_ADHOC &&\r\nsdata->vif.type != NL80211_IFTYPE_MESH_POINT));\r\ntrace_drv_sta_rc_update(local, sdata, sta, changed);\r\nif (local->ops->sta_rc_update)\r\nlocal->ops->sta_rc_update(&local->hw, &sdata->vif,\r\nsta, changed);\r\ntrace_drv_return_void(local);\r\n}\r\nint drv_conf_tx(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata, u16 ac,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nint ret = -EOPNOTSUPP;\r\nmight_sleep();\r\nif (!check_sdata_in_driver(sdata))\r\nreturn -EIO;\r\nif (WARN_ONCE(params->cw_min == 0 ||\r\nparams->cw_min > params->cw_max,\r\n"%s: invalid CW_min/CW_max: %d/%d\n",\r\nsdata->name, params->cw_min, params->cw_max))\r\nreturn -EINVAL;\r\ntrace_drv_conf_tx(local, sdata, ac, params);\r\nif (local->ops->conf_tx)\r\nret = local->ops->conf_tx(&local->hw, &sdata->vif,\r\nac, params);\r\ntrace_drv_return_int(local, ret);\r\nreturn ret;\r\n}\r\nu64 drv_get_tsf(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata)\r\n{\r\nu64 ret = -1ULL;\r\nmight_sleep();\r\nif (!check_sdata_in_driver(sdata))\r\nreturn ret;\r\ntrace_drv_get_tsf(local, sdata);\r\nif (local->ops->get_tsf)\r\nret = local->ops->get_tsf(&local->hw, &sdata->vif);\r\ntrace_drv_return_u64(local, ret);\r\nreturn ret;\r\n}\r\nvoid drv_set_tsf(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata,\r\nu64 tsf)\r\n{\r\nmight_sleep();\r\nif (!check_sdata_in_driver(sdata))\r\nreturn;\r\ntrace_drv_set_tsf(local, sdata, tsf);\r\nif (local->ops->set_tsf)\r\nlocal->ops->set_tsf(&local->hw, &sdata->vif, tsf);\r\ntrace_drv_return_void(local);\r\n}\r\nvoid drv_reset_tsf(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata)\r\n{\r\nmight_sleep();\r\nif (!check_sdata_in_driver(sdata))\r\nreturn;\r\ntrace_drv_reset_tsf(local, sdata);\r\nif (local->ops->reset_tsf)\r\nlocal->ops->reset_tsf(&local->hw, &sdata->vif);\r\ntrace_drv_return_void(local);\r\n}\r\nint drv_switch_vif_chanctx(struct ieee80211_local *local,\r\nstruct ieee80211_vif_chanctx_switch *vifs,\r\nint n_vifs, enum ieee80211_chanctx_switch_mode mode)\r\n{\r\nint ret = 0;\r\nint i;\r\nmight_sleep();\r\nif (!local->ops->switch_vif_chanctx)\r\nreturn -EOPNOTSUPP;\r\nfor (i = 0; i < n_vifs; i++) {\r\nstruct ieee80211_chanctx *new_ctx =\r\ncontainer_of(vifs[i].new_ctx,\r\nstruct ieee80211_chanctx,\r\nconf);\r\nstruct ieee80211_chanctx *old_ctx =\r\ncontainer_of(vifs[i].old_ctx,\r\nstruct ieee80211_chanctx,\r\nconf);\r\nWARN_ON_ONCE(!old_ctx->driver_present);\r\nWARN_ON_ONCE((mode == CHANCTX_SWMODE_SWAP_CONTEXTS &&\r\nnew_ctx->driver_present) ||\r\n(mode == CHANCTX_SWMODE_REASSIGN_VIF &&\r\n!new_ctx->driver_present));\r\n}\r\ntrace_drv_switch_vif_chanctx(local, vifs, n_vifs, mode);\r\nret = local->ops->switch_vif_chanctx(&local->hw,\r\nvifs, n_vifs, mode);\r\ntrace_drv_return_int(local, ret);\r\nif (!ret && mode == CHANCTX_SWMODE_SWAP_CONTEXTS) {\r\nfor (i = 0; i < n_vifs; i++) {\r\nstruct ieee80211_chanctx *new_ctx =\r\ncontainer_of(vifs[i].new_ctx,\r\nstruct ieee80211_chanctx,\r\nconf);\r\nstruct ieee80211_chanctx *old_ctx =\r\ncontainer_of(vifs[i].old_ctx,\r\nstruct ieee80211_chanctx,\r\nconf);\r\nnew_ctx->driver_present = true;\r\nold_ctx->driver_present = false;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint drv_ampdu_action(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_ampdu_params *params)\r\n{\r\nint ret = -EOPNOTSUPP;\r\nmight_sleep();\r\nsdata = get_bss_sdata(sdata);\r\nif (!check_sdata_in_driver(sdata))\r\nreturn -EIO;\r\ntrace_drv_ampdu_action(local, sdata, params);\r\nif (local->ops->ampdu_action)\r\nret = local->ops->ampdu_action(&local->hw, &sdata->vif, params);\r\ntrace_drv_return_int(local, ret);\r\nreturn ret;\r\n}
