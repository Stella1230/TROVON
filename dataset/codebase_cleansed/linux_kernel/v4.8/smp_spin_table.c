static void write_pen_release(u64 val)\r\n{\r\nvoid *start = (void *)&secondary_holding_pen_release;\r\nunsigned long size = sizeof(secondary_holding_pen_release);\r\nsecondary_holding_pen_release = val;\r\n__flush_dcache_area(start, size);\r\n}\r\nstatic int smp_spin_table_cpu_init(unsigned int cpu)\r\n{\r\nstruct device_node *dn;\r\nint ret;\r\ndn = of_get_cpu_node(cpu, NULL);\r\nif (!dn)\r\nreturn -ENODEV;\r\nret = of_property_read_u64(dn, "cpu-release-addr",\r\n&cpu_release_addr[cpu]);\r\nif (ret)\r\npr_err("CPU %d: missing or invalid cpu-release-addr property\n",\r\ncpu);\r\nof_node_put(dn);\r\nreturn ret;\r\n}\r\nstatic int smp_spin_table_cpu_prepare(unsigned int cpu)\r\n{\r\n__le64 __iomem *release_addr;\r\nif (!cpu_release_addr[cpu])\r\nreturn -ENODEV;\r\nrelease_addr = ioremap_cache(cpu_release_addr[cpu],\r\nsizeof(*release_addr));\r\nif (!release_addr)\r\nreturn -ENOMEM;\r\nwriteq_relaxed(__pa(secondary_holding_pen), release_addr);\r\n__flush_dcache_area((__force void *)release_addr,\r\nsizeof(*release_addr));\r\nsev();\r\niounmap(release_addr);\r\nreturn 0;\r\n}\r\nstatic int smp_spin_table_cpu_boot(unsigned int cpu)\r\n{\r\nwrite_pen_release(cpu_logical_map(cpu));\r\nsev();\r\nreturn 0;\r\n}
