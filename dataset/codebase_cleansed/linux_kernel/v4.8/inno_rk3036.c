static int rk3036_codec_antipop_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int rk3036_codec_antipop_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nint val, ret, regval;\r\nret = snd_soc_component_read(component, INNO_R09, &regval);\r\nif (ret)\r\nreturn ret;\r\nval = ((regval >> INNO_R09_HPL_ANITPOP_SHIFT) &\r\nINNO_R09_HP_ANTIPOP_MSK) == INNO_R09_HP_ANTIPOP_ON;\r\nucontrol->value.integer.value[0] = val;\r\nval = ((regval >> INNO_R09_HPR_ANITPOP_SHIFT) &\r\nINNO_R09_HP_ANTIPOP_MSK) == INNO_R09_HP_ANTIPOP_ON;\r\nucontrol->value.integer.value[1] = val;\r\nreturn 0;\r\n}\r\nstatic int rk3036_codec_antipop_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nint val, ret, regmsk;\r\nval = (ucontrol->value.integer.value[0] ?\r\nINNO_R09_HP_ANTIPOP_ON : INNO_R09_HP_ANTIPOP_OFF) <<\r\nINNO_R09_HPL_ANITPOP_SHIFT;\r\nval |= (ucontrol->value.integer.value[1] ?\r\nINNO_R09_HP_ANTIPOP_ON : INNO_R09_HP_ANTIPOP_OFF) <<\r\nINNO_R09_HPR_ANITPOP_SHIFT;\r\nregmsk = INNO_R09_HP_ANTIPOP_MSK << INNO_R09_HPL_ANITPOP_SHIFT |\r\nINNO_R09_HP_ANTIPOP_MSK << INNO_R09_HPR_ANITPOP_SHIFT;\r\nret = snd_soc_component_update_bits(component, INNO_R09,\r\nregmsk, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rk3036_codec_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int reg01_val = 0, reg02_val = 0, reg03_val = 0;\r\ndev_dbg(codec->dev, "rk3036_codec dai set fmt : %08x\n", fmt);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nreg01_val |= INNO_R01_PINDIR_IN_SLAVE |\r\nINNO_R01_I2SMODE_SLAVE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nreg01_val |= INNO_R01_PINDIR_OUT_MASTER |\r\nINNO_R01_I2SMODE_MASTER;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "invalid fmt\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nreg02_val |= INNO_R02_DACM_PCM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nreg02_val |= INNO_R02_DACM_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nreg02_val |= INNO_R02_DACM_RJM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nreg02_val |= INNO_R02_DACM_LJM;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "set dai format failed\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nreg02_val |= INNO_R02_LRCP_NORMAL;\r\nreg03_val |= INNO_R03_BCP_NORMAL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nreg02_val |= INNO_R02_LRCP_REVERSAL;\r\nreg03_val |= INNO_R03_BCP_REVERSAL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nreg02_val |= INNO_R02_LRCP_REVERSAL;\r\nreg03_val |= INNO_R03_BCP_NORMAL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nreg02_val |= INNO_R02_LRCP_NORMAL;\r\nreg03_val |= INNO_R03_BCP_REVERSAL;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "set dai format failed\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, INNO_R01, INNO_R01_I2SMODE_MSK |\r\nINNO_R01_PINDIR_MSK, reg01_val);\r\nsnd_soc_update_bits(codec, INNO_R02, INNO_R02_LRCP_MSK |\r\nINNO_R02_DACM_MSK, reg02_val);\r\nsnd_soc_update_bits(codec, INNO_R03, INNO_R03_BCP_MSK, reg03_val);\r\nreturn 0;\r\n}\r\nstatic int rk3036_codec_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int reg02_val = 0, reg03_val = 0;\r\nswitch (params_format(hw_params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nreg02_val |= INNO_R02_VWL_16BIT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nreg02_val |= INNO_R02_VWL_20BIT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nreg02_val |= INNO_R02_VWL_24BIT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nreg02_val |= INNO_R02_VWL_32BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreg02_val |= INNO_R02_LRCP_NORMAL;\r\nreg03_val |= INNO_R03_FWL_32BIT | INNO_R03_DACR_WORK;\r\nsnd_soc_update_bits(codec, INNO_R02, INNO_R02_LRCP_MSK |\r\nINNO_R02_VWL_MSK, reg02_val);\r\nsnd_soc_update_bits(codec, INNO_R03, INNO_R03_DACR_MSK |\r\nINNO_R03_FWL_MSK, reg03_val);\r\nreturn 0;\r\n}\r\nstatic void rk3036_codec_reset(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_write(codec, INNO_R00,\r\nINNO_R00_CSR_RESET | INNO_R00_CDCR_RESET);\r\nsnd_soc_write(codec, INNO_R00,\r\nINNO_R00_CSR_WORK | INNO_R00_CDCR_WORK);\r\n}\r\nstatic int rk3036_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nrk3036_codec_reset(codec);\r\nreturn 0;\r\n}\r\nstatic int rk3036_codec_remove(struct snd_soc_codec *codec)\r\n{\r\nrk3036_codec_reset(codec);\r\nreturn 0;\r\n}\r\nstatic int rk3036_codec_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_write(codec, INNO_R10, INNO_R10_MAX_CUR);\r\nsnd_soc_write(codec, INNO_R06, INNO_R06_DAC_PRECHARGE);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, INNO_R10, INNO_R10_MAX_CUR);\r\nsnd_soc_write(codec, INNO_R06, INNO_R06_DAC_DISCHARGE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rk3036_codec_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct rk3036_codec_priv *priv;\r\nstruct device_node *of_node = pdev->dev.of_node;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nstruct regmap *grf;\r\nint ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\npriv->base = base;\r\npriv->regmap = devm_regmap_init_mmio(&pdev->dev, priv->base,\r\n&rk3036_codec_regmap_config);\r\nif (IS_ERR(priv->regmap)) {\r\ndev_err(&pdev->dev, "init regmap failed\n");\r\nreturn PTR_ERR(priv->regmap);\r\n}\r\ngrf = syscon_regmap_lookup_by_phandle(of_node, "rockchip,grf");\r\nif (IS_ERR(grf)) {\r\ndev_err(&pdev->dev, "needs 'rockchip,grf' property\n");\r\nreturn PTR_ERR(grf);\r\n}\r\nret = regmap_write(grf, GRF_SOC_CON0, GRF_ACODEC_SEL);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not write to GRF: %d\n", ret);\r\nreturn ret;\r\n}\r\npriv->pclk = devm_clk_get(&pdev->dev, "acodec_pclk");\r\nif (IS_ERR(priv->pclk))\r\nreturn PTR_ERR(priv->pclk);\r\nret = clk_prepare_enable(priv->pclk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to enable clk\n");\r\nreturn ret;\r\n}\r\npriv->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, priv);\r\nret = snd_soc_register_codec(&pdev->dev, &rk3036_codec_driver,\r\nrk3036_codec_dai_driver,\r\nARRAY_SIZE(rk3036_codec_dai_driver));\r\nif (ret) {\r\nclk_disable_unprepare(priv->pclk);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rk3036_codec_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct rk3036_codec_priv *priv = dev_get_drvdata(&pdev->dev);\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nclk_disable_unprepare(priv->pclk);\r\nreturn 0;\r\n}
