static void nft_byteorder_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_byteorder *priv = nft_expr_priv(expr);\r\nu32 *src = &regs->data[priv->sreg];\r\nu32 *dst = &regs->data[priv->dreg];\r\nunion { u32 u32; u16 u16; } *s, *d;\r\nunsigned int i;\r\ns = (void *)src;\r\nd = (void *)dst;\r\nswitch (priv->size) {\r\ncase 8: {\r\nu64 src64;\r\nswitch (priv->op) {\r\ncase NFT_BYTEORDER_NTOH:\r\nfor (i = 0; i < priv->len / 8; i++) {\r\nsrc64 = get_unaligned((u64 *)&src[i]);\r\nput_unaligned_be64(src64, &dst[i]);\r\n}\r\nbreak;\r\ncase NFT_BYTEORDER_HTON:\r\nfor (i = 0; i < priv->len / 8; i++) {\r\nsrc64 = get_unaligned_be64(&src[i]);\r\nput_unaligned(src64, (u64 *)&dst[i]);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase 4:\r\nswitch (priv->op) {\r\ncase NFT_BYTEORDER_NTOH:\r\nfor (i = 0; i < priv->len / 4; i++)\r\nd[i].u32 = ntohl((__force __be32)s[i].u32);\r\nbreak;\r\ncase NFT_BYTEORDER_HTON:\r\nfor (i = 0; i < priv->len / 4; i++)\r\nd[i].u32 = (__force __u32)htonl(s[i].u32);\r\nbreak;\r\n}\r\nbreak;\r\ncase 2:\r\nswitch (priv->op) {\r\ncase NFT_BYTEORDER_NTOH:\r\nfor (i = 0; i < priv->len / 2; i++)\r\nd[i].u16 = ntohs((__force __be16)s[i].u16);\r\nbreak;\r\ncase NFT_BYTEORDER_HTON:\r\nfor (i = 0; i < priv->len / 2; i++)\r\nd[i].u16 = (__force __u16)htons(s[i].u16);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int nft_byteorder_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_byteorder *priv = nft_expr_priv(expr);\r\nint err;\r\nif (tb[NFTA_BYTEORDER_SREG] == NULL ||\r\ntb[NFTA_BYTEORDER_DREG] == NULL ||\r\ntb[NFTA_BYTEORDER_LEN] == NULL ||\r\ntb[NFTA_BYTEORDER_SIZE] == NULL ||\r\ntb[NFTA_BYTEORDER_OP] == NULL)\r\nreturn -EINVAL;\r\npriv->op = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_OP]));\r\nswitch (priv->op) {\r\ncase NFT_BYTEORDER_NTOH:\r\ncase NFT_BYTEORDER_HTON:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npriv->size = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_SIZE]));\r\nswitch (priv->size) {\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npriv->sreg = nft_parse_register(tb[NFTA_BYTEORDER_SREG]);\r\npriv->len = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_LEN]));\r\nerr = nft_validate_register_load(priv->sreg, priv->len);\r\nif (err < 0)\r\nreturn err;\r\npriv->dreg = nft_parse_register(tb[NFTA_BYTEORDER_DREG]);\r\nreturn nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, priv->len);\r\n}\r\nstatic int nft_byteorder_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_byteorder *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_BYTEORDER_SREG, priv->sreg))\r\ngoto nla_put_failure;\r\nif (nft_dump_register(skb, NFTA_BYTEORDER_DREG, priv->dreg))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_BYTEORDER_OP, htonl(priv->op)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_BYTEORDER_LEN, htonl(priv->len)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_BYTEORDER_SIZE, htonl(priv->size)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nint __init nft_byteorder_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_byteorder_type);\r\n}\r\nvoid nft_byteorder_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_byteorder_type);\r\n}
