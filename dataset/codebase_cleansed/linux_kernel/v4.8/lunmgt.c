static struct llun_info *create_local(struct scsi_device *sdev, u8 *wwid)\r\n{\r\nstruct llun_info *lli = NULL;\r\nlli = kzalloc(sizeof(*lli), GFP_KERNEL);\r\nif (unlikely(!lli)) {\r\npr_err("%s: could not allocate lli\n", __func__);\r\ngoto out;\r\n}\r\nlli->sdev = sdev;\r\nlli->host_no = sdev->host->host_no;\r\nlli->in_table = false;\r\nmemcpy(lli->wwid, wwid, DK_CXLFLASH_MANAGE_LUN_WWID_LEN);\r\nout:\r\nreturn lli;\r\n}\r\nstatic struct glun_info *create_global(struct scsi_device *sdev, u8 *wwid)\r\n{\r\nstruct glun_info *gli = NULL;\r\ngli = kzalloc(sizeof(*gli), GFP_KERNEL);\r\nif (unlikely(!gli)) {\r\npr_err("%s: could not allocate gli\n", __func__);\r\ngoto out;\r\n}\r\nmutex_init(&gli->mutex);\r\nmemcpy(gli->wwid, wwid, DK_CXLFLASH_MANAGE_LUN_WWID_LEN);\r\nout:\r\nreturn gli;\r\n}\r\nstatic struct llun_info *lookup_local(struct cxlflash_cfg *cfg, u8 *wwid)\r\n{\r\nstruct llun_info *lli, *temp;\r\nlist_for_each_entry_safe(lli, temp, &cfg->lluns, list)\r\nif (!memcmp(lli->wwid, wwid, DK_CXLFLASH_MANAGE_LUN_WWID_LEN))\r\nreturn lli;\r\nreturn NULL;\r\n}\r\nstatic struct glun_info *lookup_global(u8 *wwid)\r\n{\r\nstruct glun_info *gli, *temp;\r\nlist_for_each_entry_safe(gli, temp, &global.gluns, list)\r\nif (!memcmp(gli->wwid, wwid, DK_CXLFLASH_MANAGE_LUN_WWID_LEN))\r\nreturn gli;\r\nreturn NULL;\r\n}\r\nstatic struct llun_info *find_and_create_lun(struct scsi_device *sdev, u8 *wwid)\r\n{\r\nstruct llun_info *lli = NULL;\r\nstruct glun_info *gli = NULL;\r\nstruct Scsi_Host *shost = sdev->host;\r\nstruct cxlflash_cfg *cfg = shost_priv(shost);\r\nif (unlikely(!wwid))\r\ngoto out;\r\nlli = lookup_local(cfg, wwid);\r\nif (lli)\r\ngoto out;\r\nlli = create_local(sdev, wwid);\r\nif (unlikely(!lli))\r\ngoto out;\r\ngli = lookup_global(wwid);\r\nif (gli) {\r\nlli->parent = gli;\r\nlist_add(&lli->list, &cfg->lluns);\r\ngoto out;\r\n}\r\ngli = create_global(sdev, wwid);\r\nif (unlikely(!gli)) {\r\nkfree(lli);\r\nlli = NULL;\r\ngoto out;\r\n}\r\nlli->parent = gli;\r\nlist_add(&lli->list, &cfg->lluns);\r\nlist_add(&gli->list, &global.gluns);\r\nout:\r\npr_debug("%s: returning %p\n", __func__, lli);\r\nreturn lli;\r\n}\r\nvoid cxlflash_term_local_luns(struct cxlflash_cfg *cfg)\r\n{\r\nstruct llun_info *lli, *temp;\r\nmutex_lock(&global.mutex);\r\nlist_for_each_entry_safe(lli, temp, &cfg->lluns, list) {\r\nlist_del(&lli->list);\r\nkfree(lli);\r\n}\r\nmutex_unlock(&global.mutex);\r\n}\r\nvoid cxlflash_list_init(void)\r\n{\r\nINIT_LIST_HEAD(&global.gluns);\r\nmutex_init(&global.mutex);\r\nglobal.err_page = NULL;\r\n}\r\nvoid cxlflash_term_global_luns(void)\r\n{\r\nstruct glun_info *gli, *temp;\r\nmutex_lock(&global.mutex);\r\nlist_for_each_entry_safe(gli, temp, &global.gluns, list) {\r\nlist_del(&gli->list);\r\ncxlflash_ba_terminate(&gli->blka.ba_lun);\r\nkfree(gli);\r\n}\r\nmutex_unlock(&global.mutex);\r\n}\r\nint cxlflash_manage_lun(struct scsi_device *sdev,\r\nstruct dk_cxlflash_manage_lun *manage)\r\n{\r\nint rc = 0;\r\nstruct llun_info *lli = NULL;\r\nu64 flags = manage->hdr.flags;\r\nu32 chan = sdev->channel;\r\nmutex_lock(&global.mutex);\r\nlli = find_and_create_lun(sdev, manage->wwid);\r\npr_debug("%s: ENTER: WWID = %016llX%016llX, flags = %016llX li = %p\n",\r\n__func__, get_unaligned_be64(&manage->wwid[0]),\r\nget_unaligned_be64(&manage->wwid[8]),\r\nmanage->hdr.flags, lli);\r\nif (unlikely(!lli)) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif (flags & DK_CXLFLASH_MANAGE_LUN_ENABLE_SUPERPIPE) {\r\nlli->port_sel |= CHAN2PORT(chan);\r\nlli->lun_id[chan] = lun_to_lunid(sdev->lun);\r\nsdev->hostdata = lli;\r\n} else if (flags & DK_CXLFLASH_MANAGE_LUN_DISABLE_SUPERPIPE) {\r\nif (lli->parent->mode != MODE_NONE)\r\nrc = -EBUSY;\r\nelse {\r\nsdev->hostdata = NULL;\r\nlli->port_sel &= ~CHAN2PORT(chan);\r\n}\r\n}\r\npr_debug("%s: port_sel = %08X chan = %u lun_id = %016llX\n", __func__,\r\nlli->port_sel, chan, lli->lun_id[chan]);\r\nout:\r\nmutex_unlock(&global.mutex);\r\npr_debug("%s: returning rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}
