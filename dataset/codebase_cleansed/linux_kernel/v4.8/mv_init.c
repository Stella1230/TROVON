static void mvs_phy_init(struct mvs_info *mvi, int phy_id)\r\n{\r\nstruct mvs_phy *phy = &mvi->phy[phy_id];\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nphy->mvi = mvi;\r\nphy->port = NULL;\r\ninit_timer(&phy->timer);\r\nsas_phy->enabled = (phy_id < mvi->chip->n_phy) ? 1 : 0;\r\nsas_phy->class = SAS;\r\nsas_phy->iproto = SAS_PROTOCOL_ALL;\r\nsas_phy->tproto = 0;\r\nsas_phy->type = PHY_TYPE_PHYSICAL;\r\nsas_phy->role = PHY_ROLE_INITIATOR;\r\nsas_phy->oob_mode = OOB_NOT_CONNECTED;\r\nsas_phy->linkrate = SAS_LINK_RATE_UNKNOWN;\r\nsas_phy->id = phy_id;\r\nsas_phy->sas_addr = &mvi->sas_addr[0];\r\nsas_phy->frame_rcvd = &phy->frame_rcvd[0];\r\nsas_phy->ha = (struct sas_ha_struct *)mvi->shost->hostdata;\r\nsas_phy->lldd_phy = phy;\r\n}\r\nstatic void mvs_free(struct mvs_info *mvi)\r\n{\r\nstruct mvs_wq *mwq;\r\nint slot_nr;\r\nif (!mvi)\r\nreturn;\r\nif (mvi->flags & MVF_FLAG_SOC)\r\nslot_nr = MVS_SOC_SLOTS;\r\nelse\r\nslot_nr = MVS_CHIP_SLOT_SZ;\r\nif (mvi->dma_pool)\r\npci_pool_destroy(mvi->dma_pool);\r\nif (mvi->tx)\r\ndma_free_coherent(mvi->dev,\r\nsizeof(*mvi->tx) * MVS_CHIP_SLOT_SZ,\r\nmvi->tx, mvi->tx_dma);\r\nif (mvi->rx_fis)\r\ndma_free_coherent(mvi->dev, MVS_RX_FISL_SZ,\r\nmvi->rx_fis, mvi->rx_fis_dma);\r\nif (mvi->rx)\r\ndma_free_coherent(mvi->dev,\r\nsizeof(*mvi->rx) * (MVS_RX_RING_SZ + 1),\r\nmvi->rx, mvi->rx_dma);\r\nif (mvi->slot)\r\ndma_free_coherent(mvi->dev,\r\nsizeof(*mvi->slot) * slot_nr,\r\nmvi->slot, mvi->slot_dma);\r\nif (mvi->bulk_buffer)\r\ndma_free_coherent(mvi->dev, TRASH_BUCKET_SIZE,\r\nmvi->bulk_buffer, mvi->bulk_buffer_dma);\r\nif (mvi->bulk_buffer1)\r\ndma_free_coherent(mvi->dev, TRASH_BUCKET_SIZE,\r\nmvi->bulk_buffer1, mvi->bulk_buffer_dma1);\r\nMVS_CHIP_DISP->chip_iounmap(mvi);\r\nif (mvi->shost)\r\nscsi_host_put(mvi->shost);\r\nlist_for_each_entry(mwq, &mvi->wq_list, entry)\r\ncancel_delayed_work(&mwq->work_q);\r\nkfree(mvi->tags);\r\nkfree(mvi);\r\n}\r\nstatic void mvs_tasklet(unsigned long opaque)\r\n{\r\nu32 stat;\r\nu16 core_nr, i = 0;\r\nstruct mvs_info *mvi;\r\nstruct sas_ha_struct *sha = (struct sas_ha_struct *)opaque;\r\ncore_nr = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[0];\r\nif (unlikely(!mvi))\r\nBUG_ON(1);\r\nstat = MVS_CHIP_DISP->isr_status(mvi, mvi->pdev->irq);\r\nif (!stat)\r\ngoto out;\r\nfor (i = 0; i < core_nr; i++) {\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[i];\r\nMVS_CHIP_DISP->isr(mvi, mvi->pdev->irq, stat);\r\n}\r\nout:\r\nMVS_CHIP_DISP->interrupt_enable(mvi);\r\n}\r\nstatic irqreturn_t mvs_interrupt(int irq, void *opaque)\r\n{\r\nu32 core_nr;\r\nu32 stat;\r\nstruct mvs_info *mvi;\r\nstruct sas_ha_struct *sha = opaque;\r\n#ifndef CONFIG_SCSI_MVSAS_TASKLET\r\nu32 i;\r\n#endif\r\ncore_nr = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[0];\r\nif (unlikely(!mvi))\r\nreturn IRQ_NONE;\r\n#ifdef CONFIG_SCSI_MVSAS_TASKLET\r\nMVS_CHIP_DISP->interrupt_disable(mvi);\r\n#endif\r\nstat = MVS_CHIP_DISP->isr_status(mvi, irq);\r\nif (!stat) {\r\n#ifdef CONFIG_SCSI_MVSAS_TASKLET\r\nMVS_CHIP_DISP->interrupt_enable(mvi);\r\n#endif\r\nreturn IRQ_NONE;\r\n}\r\n#ifdef CONFIG_SCSI_MVSAS_TASKLET\r\ntasklet_schedule(&((struct mvs_prv_info *)sha->lldd_ha)->mv_tasklet);\r\n#else\r\nfor (i = 0; i < core_nr; i++) {\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[i];\r\nMVS_CHIP_DISP->isr(mvi, irq, stat);\r\n}\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mvs_alloc(struct mvs_info *mvi, struct Scsi_Host *shost)\r\n{\r\nint i = 0, slot_nr;\r\nchar pool_name[32];\r\nif (mvi->flags & MVF_FLAG_SOC)\r\nslot_nr = MVS_SOC_SLOTS;\r\nelse\r\nslot_nr = MVS_CHIP_SLOT_SZ;\r\nspin_lock_init(&mvi->lock);\r\nfor (i = 0; i < mvi->chip->n_phy; i++) {\r\nmvs_phy_init(mvi, i);\r\nmvi->port[i].wide_port_phymap = 0;\r\nmvi->port[i].port_attached = 0;\r\nINIT_LIST_HEAD(&mvi->port[i].list);\r\n}\r\nfor (i = 0; i < MVS_MAX_DEVICES; i++) {\r\nmvi->devices[i].taskfileset = MVS_ID_NOT_MAPPED;\r\nmvi->devices[i].dev_type = SAS_PHY_UNUSED;\r\nmvi->devices[i].device_id = i;\r\nmvi->devices[i].dev_status = MVS_DEV_NORMAL;\r\ninit_timer(&mvi->devices[i].timer);\r\n}\r\nmvi->tx = dma_alloc_coherent(mvi->dev,\r\nsizeof(*mvi->tx) * MVS_CHIP_SLOT_SZ,\r\n&mvi->tx_dma, GFP_KERNEL);\r\nif (!mvi->tx)\r\ngoto err_out;\r\nmemset(mvi->tx, 0, sizeof(*mvi->tx) * MVS_CHIP_SLOT_SZ);\r\nmvi->rx_fis = dma_alloc_coherent(mvi->dev, MVS_RX_FISL_SZ,\r\n&mvi->rx_fis_dma, GFP_KERNEL);\r\nif (!mvi->rx_fis)\r\ngoto err_out;\r\nmemset(mvi->rx_fis, 0, MVS_RX_FISL_SZ);\r\nmvi->rx = dma_alloc_coherent(mvi->dev,\r\nsizeof(*mvi->rx) * (MVS_RX_RING_SZ + 1),\r\n&mvi->rx_dma, GFP_KERNEL);\r\nif (!mvi->rx)\r\ngoto err_out;\r\nmemset(mvi->rx, 0, sizeof(*mvi->rx) * (MVS_RX_RING_SZ + 1));\r\nmvi->rx[0] = cpu_to_le32(0xfff);\r\nmvi->rx_cons = 0xfff;\r\nmvi->slot = dma_alloc_coherent(mvi->dev,\r\nsizeof(*mvi->slot) * slot_nr,\r\n&mvi->slot_dma, GFP_KERNEL);\r\nif (!mvi->slot)\r\ngoto err_out;\r\nmemset(mvi->slot, 0, sizeof(*mvi->slot) * slot_nr);\r\nmvi->bulk_buffer = dma_alloc_coherent(mvi->dev,\r\nTRASH_BUCKET_SIZE,\r\n&mvi->bulk_buffer_dma, GFP_KERNEL);\r\nif (!mvi->bulk_buffer)\r\ngoto err_out;\r\nmvi->bulk_buffer1 = dma_alloc_coherent(mvi->dev,\r\nTRASH_BUCKET_SIZE,\r\n&mvi->bulk_buffer_dma1, GFP_KERNEL);\r\nif (!mvi->bulk_buffer1)\r\ngoto err_out;\r\nsprintf(pool_name, "%s%d", "mvs_dma_pool", mvi->id);\r\nmvi->dma_pool = pci_pool_create(pool_name, mvi->pdev, MVS_SLOT_BUF_SZ, 16, 0);\r\nif (!mvi->dma_pool) {\r\nprintk(KERN_DEBUG "failed to create dma pool %s.\n", pool_name);\r\ngoto err_out;\r\n}\r\nmvi->tags_num = slot_nr;\r\nmvs_tag_init(mvi);\r\nreturn 0;\r\nerr_out:\r\nreturn 1;\r\n}\r\nint mvs_ioremap(struct mvs_info *mvi, int bar, int bar_ex)\r\n{\r\nunsigned long res_start, res_len, res_flag, res_flag_ex = 0;\r\nstruct pci_dev *pdev = mvi->pdev;\r\nif (bar_ex != -1) {\r\nres_start = pci_resource_start(pdev, bar_ex);\r\nres_len = pci_resource_len(pdev, bar_ex);\r\nif (!res_start || !res_len)\r\ngoto err_out;\r\nres_flag_ex = pci_resource_flags(pdev, bar_ex);\r\nif (res_flag_ex & IORESOURCE_MEM)\r\nmvi->regs_ex = ioremap(res_start, res_len);\r\nelse\r\nmvi->regs_ex = (void *)res_start;\r\nif (!mvi->regs_ex)\r\ngoto err_out;\r\n}\r\nres_start = pci_resource_start(pdev, bar);\r\nres_len = pci_resource_len(pdev, bar);\r\nif (!res_start || !res_len) {\r\niounmap(mvi->regs_ex);\r\nmvi->regs_ex = NULL;\r\ngoto err_out;\r\n}\r\nres_flag = pci_resource_flags(pdev, bar);\r\nmvi->regs = ioremap(res_start, res_len);\r\nif (!mvi->regs) {\r\nif (mvi->regs_ex && (res_flag_ex & IORESOURCE_MEM))\r\niounmap(mvi->regs_ex);\r\nmvi->regs_ex = NULL;\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nreturn -1;\r\n}\r\nvoid mvs_iounmap(void __iomem *regs)\r\n{\r\niounmap(regs);\r\n}\r\nstatic struct mvs_info *mvs_pci_alloc(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent,\r\nstruct Scsi_Host *shost, unsigned int id)\r\n{\r\nstruct mvs_info *mvi = NULL;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nmvi = kzalloc(sizeof(*mvi) +\r\n(1L << mvs_chips[ent->driver_data].slot_width) *\r\nsizeof(struct mvs_slot_info), GFP_KERNEL);\r\nif (!mvi)\r\nreturn NULL;\r\nmvi->pdev = pdev;\r\nmvi->dev = &pdev->dev;\r\nmvi->chip_id = ent->driver_data;\r\nmvi->chip = &mvs_chips[mvi->chip_id];\r\nINIT_LIST_HEAD(&mvi->wq_list);\r\n((struct mvs_prv_info *)sha->lldd_ha)->mvi[id] = mvi;\r\n((struct mvs_prv_info *)sha->lldd_ha)->n_phy = mvi->chip->n_phy;\r\nmvi->id = id;\r\nmvi->sas = sha;\r\nmvi->shost = shost;\r\nmvi->tags = kzalloc(MVS_CHIP_SLOT_SZ>>3, GFP_KERNEL);\r\nif (!mvi->tags)\r\ngoto err_out;\r\nif (MVS_CHIP_DISP->chip_ioremap(mvi))\r\ngoto err_out;\r\nif (!mvs_alloc(mvi, shost))\r\nreturn mvi;\r\nerr_out:\r\nmvs_free(mvi);\r\nreturn NULL;\r\n}\r\nstatic int pci_go_64(struct pci_dev *pdev)\r\n{\r\nint rc;\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (rc) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"64-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\n} else {\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"32-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"32-bit consistent DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int mvs_prep_sas_ha_init(struct Scsi_Host *shost,\r\nconst struct mvs_chip_info *chip_info)\r\n{\r\nint phy_nr, port_nr; unsigned short core_nr;\r\nstruct asd_sas_phy **arr_phy;\r\nstruct asd_sas_port **arr_port;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\ncore_nr = chip_info->n_host;\r\nphy_nr = core_nr * chip_info->n_phy;\r\nport_nr = phy_nr;\r\nmemset(sha, 0x00, sizeof(struct sas_ha_struct));\r\narr_phy = kcalloc(phy_nr, sizeof(void *), GFP_KERNEL);\r\narr_port = kcalloc(port_nr, sizeof(void *), GFP_KERNEL);\r\nif (!arr_phy || !arr_port)\r\ngoto exit_free;\r\nsha->sas_phy = arr_phy;\r\nsha->sas_port = arr_port;\r\nsha->core.shost = shost;\r\nsha->lldd_ha = kzalloc(sizeof(struct mvs_prv_info), GFP_KERNEL);\r\nif (!sha->lldd_ha)\r\ngoto exit_free;\r\n((struct mvs_prv_info *)sha->lldd_ha)->n_host = core_nr;\r\nshost->transportt = mvs_stt;\r\nshost->max_id = MVS_MAX_DEVICES;\r\nshost->max_lun = ~0;\r\nshost->max_channel = 1;\r\nshost->max_cmd_len = 16;\r\nreturn 0;\r\nexit_free:\r\nkfree(arr_phy);\r\nkfree(arr_port);\r\nreturn -1;\r\n}\r\nstatic void mvs_post_sas_ha_init(struct Scsi_Host *shost,\r\nconst struct mvs_chip_info *chip_info)\r\n{\r\nint can_queue, i = 0, j = 0;\r\nstruct mvs_info *mvi = NULL;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nunsigned short nr_core = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\r\nfor (j = 0; j < nr_core; j++) {\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[j];\r\nfor (i = 0; i < chip_info->n_phy; i++) {\r\nsha->sas_phy[j * chip_info->n_phy + i] =\r\n&mvi->phy[i].sas_phy;\r\nsha->sas_port[j * chip_info->n_phy + i] =\r\n&mvi->port[i].sas_port;\r\n}\r\n}\r\nsha->sas_ha_name = DRV_NAME;\r\nsha->dev = mvi->dev;\r\nsha->lldd_module = THIS_MODULE;\r\nsha->sas_addr = &mvi->sas_addr[0];\r\nsha->num_phys = nr_core * chip_info->n_phy;\r\nif (mvi->flags & MVF_FLAG_SOC)\r\ncan_queue = MVS_SOC_CAN_QUEUE;\r\nelse\r\ncan_queue = MVS_CHIP_SLOT_SZ;\r\nshost->sg_tablesize = min_t(u16, SG_ALL, MVS_MAX_SG);\r\nshost->can_queue = can_queue;\r\nmvi->shost->cmd_per_lun = MVS_QUEUE_SIZE;\r\nsha->core.shost = mvi->shost;\r\n}\r\nstatic void mvs_init_sas_add(struct mvs_info *mvi)\r\n{\r\nu8 i;\r\nfor (i = 0; i < mvi->chip->n_phy; i++) {\r\nmvi->phy[i].dev_sas_addr = 0x5005043011ab0000ULL;\r\nmvi->phy[i].dev_sas_addr =\r\ncpu_to_be64((u64)(*(u64 *)&mvi->phy[i].dev_sas_addr));\r\n}\r\nmemcpy(mvi->sas_addr, &mvi->phy[0].dev_sas_addr, SAS_ADDR_SIZE);\r\n}\r\nstatic int mvs_pci_init(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned int rc, nhost = 0;\r\nstruct mvs_info *mvi;\r\nstruct mvs_prv_info *mpi;\r\nirq_handler_t irq_handler = mvs_interrupt;\r\nstruct Scsi_Host *shost = NULL;\r\nconst struct mvs_chip_info *chip;\r\ndev_printk(KERN_INFO, &pdev->dev,\r\n"mvsas: driver version %s\n", DRV_VERSION);\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\ngoto err_out_enable;\r\npci_set_master(pdev);\r\nrc = pci_request_regions(pdev, DRV_NAME);\r\nif (rc)\r\ngoto err_out_disable;\r\nrc = pci_go_64(pdev);\r\nif (rc)\r\ngoto err_out_regions;\r\nshost = scsi_host_alloc(&mvs_sht, sizeof(void *));\r\nif (!shost) {\r\nrc = -ENOMEM;\r\ngoto err_out_regions;\r\n}\r\nchip = &mvs_chips[ent->driver_data];\r\nSHOST_TO_SAS_HA(shost) =\r\nkcalloc(1, sizeof(struct sas_ha_struct), GFP_KERNEL);\r\nif (!SHOST_TO_SAS_HA(shost)) {\r\nkfree(shost);\r\nrc = -ENOMEM;\r\ngoto err_out_regions;\r\n}\r\nrc = mvs_prep_sas_ha_init(shost, chip);\r\nif (rc) {\r\nkfree(shost);\r\nrc = -ENOMEM;\r\ngoto err_out_regions;\r\n}\r\npci_set_drvdata(pdev, SHOST_TO_SAS_HA(shost));\r\ndo {\r\nmvi = mvs_pci_alloc(pdev, ent, shost, nhost);\r\nif (!mvi) {\r\nrc = -ENOMEM;\r\ngoto err_out_regions;\r\n}\r\nmemset(&mvi->hba_info_param, 0xFF,\r\nsizeof(struct hba_info_page));\r\nmvs_init_sas_add(mvi);\r\nmvi->instance = nhost;\r\nrc = MVS_CHIP_DISP->chip_init(mvi);\r\nif (rc) {\r\nmvs_free(mvi);\r\ngoto err_out_regions;\r\n}\r\nnhost++;\r\n} while (nhost < chip->n_host);\r\nmpi = (struct mvs_prv_info *)(SHOST_TO_SAS_HA(shost)->lldd_ha);\r\n#ifdef CONFIG_SCSI_MVSAS_TASKLET\r\ntasklet_init(&(mpi->mv_tasklet), mvs_tasklet,\r\n(unsigned long)SHOST_TO_SAS_HA(shost));\r\n#endif\r\nmvs_post_sas_ha_init(shost, chip);\r\nrc = scsi_add_host(shost, &pdev->dev);\r\nif (rc)\r\ngoto err_out_shost;\r\nrc = sas_register_ha(SHOST_TO_SAS_HA(shost));\r\nif (rc)\r\ngoto err_out_shost;\r\nrc = request_irq(pdev->irq, irq_handler, IRQF_SHARED,\r\nDRV_NAME, SHOST_TO_SAS_HA(shost));\r\nif (rc)\r\ngoto err_not_sas;\r\nMVS_CHIP_DISP->interrupt_enable(mvi);\r\nscsi_scan_host(mvi->shost);\r\nreturn 0;\r\nerr_not_sas:\r\nsas_unregister_ha(SHOST_TO_SAS_HA(shost));\r\nerr_out_shost:\r\nscsi_remove_host(mvi->shost);\r\nerr_out_regions:\r\npci_release_regions(pdev);\r\nerr_out_disable:\r\npci_disable_device(pdev);\r\nerr_out_enable:\r\nreturn rc;\r\n}\r\nstatic void mvs_pci_remove(struct pci_dev *pdev)\r\n{\r\nunsigned short core_nr, i = 0;\r\nstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\r\nstruct mvs_info *mvi = NULL;\r\ncore_nr = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[0];\r\n#ifdef CONFIG_SCSI_MVSAS_TASKLET\r\ntasklet_kill(&((struct mvs_prv_info *)sha->lldd_ha)->mv_tasklet);\r\n#endif\r\nscsi_remove_host(mvi->shost);\r\nsas_unregister_ha(sha);\r\nsas_remove_host(mvi->shost);\r\nMVS_CHIP_DISP->interrupt_disable(mvi);\r\nfree_irq(mvi->pdev->irq, sha);\r\nfor (i = 0; i < core_nr; i++) {\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[i];\r\nmvs_free(mvi);\r\n}\r\nkfree(sha->sas_phy);\r\nkfree(sha->sas_port);\r\nkfree(sha);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nreturn;\r\n}\r\nstatic ssize_t\r\nmvs_show_driver_version(struct device *cdev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nreturn snprintf(buffer, PAGE_SIZE, "%s\n", DRV_VERSION);\r\n}\r\nstatic ssize_t\r\nmvs_store_interrupt_coalescing(struct device *cdev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t size)\r\n{\r\nunsigned int val = 0;\r\nstruct mvs_info *mvi = NULL;\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nu8 i, core_nr;\r\nif (buffer == NULL)\r\nreturn size;\r\nif (sscanf(buffer, "%u", &val) != 1)\r\nreturn -EINVAL;\r\nif (val >= 0x10000) {\r\nmv_dprintk("interrupt coalescing timer %d us is"\r\n"too long\n", val);\r\nreturn strlen(buffer);\r\n}\r\ninterrupt_coalescing = val;\r\ncore_nr = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[0];\r\nif (unlikely(!mvi))\r\nreturn -EINVAL;\r\nfor (i = 0; i < core_nr; i++) {\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[i];\r\nif (MVS_CHIP_DISP->tune_interrupt)\r\nMVS_CHIP_DISP->tune_interrupt(mvi,\r\ninterrupt_coalescing);\r\n}\r\nmv_dprintk("set interrupt coalescing time to %d us\n",\r\ninterrupt_coalescing);\r\nreturn strlen(buffer);\r\n}\r\nstatic ssize_t mvs_show_interrupt_coalescing(struct device *cdev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", interrupt_coalescing);\r\n}\r\nstatic int __init mvs_init(void)\r\n{\r\nint rc;\r\nmvs_stt = sas_domain_attach_transport(&mvs_transport_ops);\r\nif (!mvs_stt)\r\nreturn -ENOMEM;\r\nrc = pci_register_driver(&mvs_pci_driver);\r\nif (rc)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\nsas_release_transport(mvs_stt);\r\nreturn rc;\r\n}\r\nstatic void __exit mvs_exit(void)\r\n{\r\npci_unregister_driver(&mvs_pci_driver);\r\nsas_release_transport(mvs_stt);\r\n}
