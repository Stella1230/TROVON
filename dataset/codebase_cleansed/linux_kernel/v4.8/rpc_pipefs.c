static void\r\nnfs4_encode_simple(__be32 *p, struct pnfs_block_volume *b)\r\n{\r\nint i;\r\n*p++ = cpu_to_be32(1);\r\n*p++ = cpu_to_be32(b->type);\r\n*p++ = cpu_to_be32(b->simple.nr_sigs);\r\nfor (i = 0; i < b->simple.nr_sigs; i++) {\r\np = xdr_encode_hyper(p, b->simple.sigs[i].offset);\r\np = xdr_encode_opaque(p, b->simple.sigs[i].sig,\r\nb->simple.sigs[i].sig_len);\r\n}\r\n}\r\ndev_t\r\nbl_resolve_deviceid(struct nfs_server *server, struct pnfs_block_volume *b,\r\ngfp_t gfp_mask)\r\n{\r\nstruct net *net = server->nfs_client->cl_net;\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nstruct bl_dev_msg *reply = &nn->bl_mount_reply;\r\nstruct bl_pipe_msg bl_pipe_msg;\r\nstruct rpc_pipe_msg *msg = &bl_pipe_msg.msg;\r\nstruct bl_msg_hdr *bl_msg;\r\nDECLARE_WAITQUEUE(wq, current);\r\ndev_t dev = 0;\r\nint rc;\r\ndprintk("%s CREATING PIPEFS MESSAGE\n", __func__);\r\nmutex_lock(&nn->bl_mutex);\r\nbl_pipe_msg.bl_wq = &nn->bl_wq;\r\nb->simple.len += 4;\r\nif (b->simple.len > PAGE_SIZE)\r\ngoto out_unlock;\r\nmemset(msg, 0, sizeof(*msg));\r\nmsg->len = sizeof(*bl_msg) + b->simple.len;\r\nmsg->data = kzalloc(msg->len, gfp_mask);\r\nif (!msg->data)\r\ngoto out_free_data;\r\nbl_msg = msg->data;\r\nbl_msg->type = BL_DEVICE_MOUNT,\r\nbl_msg->totallen = b->simple.len;\r\nnfs4_encode_simple(msg->data + sizeof(*bl_msg), b);\r\ndprintk("%s CALLING USERSPACE DAEMON\n", __func__);\r\nadd_wait_queue(&nn->bl_wq, &wq);\r\nrc = rpc_queue_upcall(nn->bl_device_pipe, msg);\r\nif (rc < 0) {\r\nremove_wait_queue(&nn->bl_wq, &wq);\r\ngoto out_free_data;\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule();\r\nremove_wait_queue(&nn->bl_wq, &wq);\r\nif (reply->status != BL_DEVICE_REQUEST_PROC) {\r\nprintk(KERN_WARNING "%s failed to decode device: %d\n",\r\n__func__, reply->status);\r\ngoto out_free_data;\r\n}\r\ndev = MKDEV(reply->major, reply->minor);\r\nout_free_data:\r\nkfree(msg->data);\r\nout_unlock:\r\nmutex_unlock(&nn->bl_mutex);\r\nreturn dev;\r\n}\r\nstatic ssize_t bl_pipe_downcall(struct file *filp, const char __user *src,\r\nsize_t mlen)\r\n{\r\nstruct nfs_net *nn = net_generic(file_inode(filp)->i_sb->s_fs_info,\r\nnfs_net_id);\r\nif (mlen != sizeof (struct bl_dev_msg))\r\nreturn -EINVAL;\r\nif (copy_from_user(&nn->bl_mount_reply, src, mlen) != 0)\r\nreturn -EFAULT;\r\nwake_up(&nn->bl_wq);\r\nreturn mlen;\r\n}\r\nstatic void bl_pipe_destroy_msg(struct rpc_pipe_msg *msg)\r\n{\r\nstruct bl_pipe_msg *bl_pipe_msg =\r\ncontainer_of(msg, struct bl_pipe_msg, msg);\r\nif (msg->errno >= 0)\r\nreturn;\r\nwake_up(bl_pipe_msg->bl_wq);\r\n}\r\nstatic struct dentry *nfs4blocklayout_register_sb(struct super_block *sb,\r\nstruct rpc_pipe *pipe)\r\n{\r\nstruct dentry *dir, *dentry;\r\ndir = rpc_d_lookup_sb(sb, NFS_PIPE_DIRNAME);\r\nif (dir == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\ndentry = rpc_mkpipe_dentry(dir, "blocklayout", NULL, pipe);\r\ndput(dir);\r\nreturn dentry;\r\n}\r\nstatic void nfs4blocklayout_unregister_sb(struct super_block *sb,\r\nstruct rpc_pipe *pipe)\r\n{\r\nif (pipe->dentry)\r\nrpc_unlink(pipe->dentry);\r\n}\r\nstatic int rpc_pipefs_event(struct notifier_block *nb, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct super_block *sb = ptr;\r\nstruct net *net = sb->s_fs_info;\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nstruct dentry *dentry;\r\nint ret = 0;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn 0;\r\nif (nn->bl_device_pipe == NULL) {\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nswitch (event) {\r\ncase RPC_PIPEFS_MOUNT:\r\ndentry = nfs4blocklayout_register_sb(sb, nn->bl_device_pipe);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\nbreak;\r\n}\r\nnn->bl_device_pipe->dentry = dentry;\r\nbreak;\r\ncase RPC_PIPEFS_UMOUNT:\r\nif (nn->bl_device_pipe->dentry)\r\nnfs4blocklayout_unregister_sb(sb, nn->bl_device_pipe);\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\nbreak;\r\n}\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nstatic struct dentry *nfs4blocklayout_register_net(struct net *net,\r\nstruct rpc_pipe *pipe)\r\n{\r\nstruct super_block *pipefs_sb;\r\nstruct dentry *dentry;\r\npipefs_sb = rpc_get_sb_net(net);\r\nif (!pipefs_sb)\r\nreturn NULL;\r\ndentry = nfs4blocklayout_register_sb(pipefs_sb, pipe);\r\nrpc_put_sb_net(net);\r\nreturn dentry;\r\n}\r\nstatic void nfs4blocklayout_unregister_net(struct net *net,\r\nstruct rpc_pipe *pipe)\r\n{\r\nstruct super_block *pipefs_sb;\r\npipefs_sb = rpc_get_sb_net(net);\r\nif (pipefs_sb) {\r\nnfs4blocklayout_unregister_sb(pipefs_sb, pipe);\r\nrpc_put_sb_net(net);\r\n}\r\n}\r\nstatic int nfs4blocklayout_net_init(struct net *net)\r\n{\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nstruct dentry *dentry;\r\nmutex_init(&nn->bl_mutex);\r\ninit_waitqueue_head(&nn->bl_wq);\r\nnn->bl_device_pipe = rpc_mkpipe_data(&bl_upcall_ops, 0);\r\nif (IS_ERR(nn->bl_device_pipe))\r\nreturn PTR_ERR(nn->bl_device_pipe);\r\ndentry = nfs4blocklayout_register_net(net, nn->bl_device_pipe);\r\nif (IS_ERR(dentry)) {\r\nrpc_destroy_pipe_data(nn->bl_device_pipe);\r\nreturn PTR_ERR(dentry);\r\n}\r\nnn->bl_device_pipe->dentry = dentry;\r\nreturn 0;\r\n}\r\nstatic void nfs4blocklayout_net_exit(struct net *net)\r\n{\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nnfs4blocklayout_unregister_net(net, nn->bl_device_pipe);\r\nrpc_destroy_pipe_data(nn->bl_device_pipe);\r\nnn->bl_device_pipe = NULL;\r\n}\r\nint __init bl_init_pipefs(void)\r\n{\r\nint ret;\r\nret = rpc_pipefs_notifier_register(&nfs4blocklayout_block);\r\nif (ret)\r\ngoto out;\r\nret = register_pernet_subsys(&nfs4blocklayout_net_ops);\r\nif (ret)\r\ngoto out_unregister_notifier;\r\nreturn 0;\r\nout_unregister_notifier:\r\nrpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\r\nout:\r\nreturn ret;\r\n}\r\nvoid bl_cleanup_pipefs(void)\r\n{\r\nrpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\r\nunregister_pernet_subsys(&nfs4blocklayout_net_ops);\r\n}
