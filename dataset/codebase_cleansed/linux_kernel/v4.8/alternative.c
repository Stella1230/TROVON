static int __init debug_alt(char *str)\r\n{\r\ndebug_alternative = 1;\r\nreturn 1;\r\n}\r\nstatic int __init setup_noreplace_smp(char *str)\r\n{\r\nnoreplace_smp = 1;\r\nreturn 1;\r\n}\r\nstatic int __init setup_noreplace_paravirt(char *str)\r\n{\r\nnoreplace_paravirt = 1;\r\nreturn 1;\r\n}\r\nvoid __init arch_init_ideal_nops(void)\r\n{\r\nswitch (boot_cpu_data.x86_vendor) {\r\ncase X86_VENDOR_INTEL:\r\nif (boot_cpu_data.x86 == 6 &&\r\nboot_cpu_data.x86_model >= 0x0f &&\r\nboot_cpu_data.x86_model != 0x1c &&\r\nboot_cpu_data.x86_model != 0x26 &&\r\nboot_cpu_data.x86_model != 0x27 &&\r\nboot_cpu_data.x86_model < 0x30) {\r\nideal_nops = k8_nops;\r\n} else if (boot_cpu_has(X86_FEATURE_NOPL)) {\r\nideal_nops = p6_nops;\r\n} else {\r\n#ifdef CONFIG_X86_64\r\nideal_nops = k8_nops;\r\n#else\r\nideal_nops = intel_nops;\r\n#endif\r\n}\r\nbreak;\r\ncase X86_VENDOR_AMD:\r\nif (boot_cpu_data.x86 > 0xf) {\r\nideal_nops = p6_nops;\r\nreturn;\r\n}\r\ndefault:\r\n#ifdef CONFIG_X86_64\r\nideal_nops = k8_nops;\r\n#else\r\nif (boot_cpu_has(X86_FEATURE_K8))\r\nideal_nops = k8_nops;\r\nelse if (boot_cpu_has(X86_FEATURE_K7))\r\nideal_nops = k7_nops;\r\nelse\r\nideal_nops = intel_nops;\r\n#endif\r\n}\r\n}\r\nstatic void __init_or_module add_nops(void *insns, unsigned int len)\r\n{\r\nwhile (len > 0) {\r\nunsigned int noplen = len;\r\nif (noplen > ASM_NOP_MAX)\r\nnoplen = ASM_NOP_MAX;\r\nmemcpy(insns, ideal_nops[noplen], noplen);\r\ninsns += noplen;\r\nlen -= noplen;\r\n}\r\n}\r\nstatic inline bool is_jmp(const u8 opcode)\r\n{\r\nreturn opcode == 0xeb || opcode == 0xe9;\r\n}\r\nstatic void __init_or_module\r\nrecompute_jump(struct alt_instr *a, u8 *orig_insn, u8 *repl_insn, u8 *insnbuf)\r\n{\r\nu8 *next_rip, *tgt_rip;\r\ns32 n_dspl, o_dspl;\r\nint repl_len;\r\nif (a->replacementlen != 5)\r\nreturn;\r\no_dspl = *(s32 *)(insnbuf + 1);\r\nnext_rip = repl_insn + a->replacementlen;\r\ntgt_rip = next_rip + o_dspl;\r\nn_dspl = tgt_rip - orig_insn;\r\nDPRINTK("target RIP: %p, new_displ: 0x%x", tgt_rip, n_dspl);\r\nif (tgt_rip - orig_insn >= 0) {\r\nif (n_dspl - 2 <= 127)\r\ngoto two_byte_jmp;\r\nelse\r\ngoto five_byte_jmp;\r\n} else {\r\nif (((n_dspl - 2) & 0xff) == (n_dspl - 2))\r\ngoto two_byte_jmp;\r\nelse\r\ngoto five_byte_jmp;\r\n}\r\ntwo_byte_jmp:\r\nn_dspl -= 2;\r\ninsnbuf[0] = 0xeb;\r\ninsnbuf[1] = (s8)n_dspl;\r\nadd_nops(insnbuf + 2, 3);\r\nrepl_len = 2;\r\ngoto done;\r\nfive_byte_jmp:\r\nn_dspl -= 5;\r\ninsnbuf[0] = 0xe9;\r\n*(s32 *)&insnbuf[1] = n_dspl;\r\nrepl_len = 5;\r\ndone:\r\nDPRINTK("final displ: 0x%08x, JMP 0x%lx",\r\nn_dspl, (unsigned long)orig_insn + n_dspl + repl_len);\r\n}\r\nstatic void __init_or_module optimize_nops(struct alt_instr *a, u8 *instr)\r\n{\r\nunsigned long flags;\r\nif (instr[0] != 0x90)\r\nreturn;\r\nlocal_irq_save(flags);\r\nadd_nops(instr + (a->instrlen - a->padlen), a->padlen);\r\nsync_core();\r\nlocal_irq_restore(flags);\r\nDUMP_BYTES(instr, a->instrlen, "%p: [%d:%d) optimized NOPs: ",\r\ninstr, a->instrlen - a->padlen, a->padlen);\r\n}\r\nvoid __init_or_module apply_alternatives(struct alt_instr *start,\r\nstruct alt_instr *end)\r\n{\r\nstruct alt_instr *a;\r\nu8 *instr, *replacement;\r\nu8 insnbuf[MAX_PATCH_LEN];\r\nDPRINTK("alt table %p -> %p", start, end);\r\nfor (a = start; a < end; a++) {\r\nint insnbuf_sz = 0;\r\ninstr = (u8 *)&a->instr_offset + a->instr_offset;\r\nreplacement = (u8 *)&a->repl_offset + a->repl_offset;\r\nBUG_ON(a->instrlen > sizeof(insnbuf));\r\nBUG_ON(a->cpuid >= (NCAPINTS + NBUGINTS) * 32);\r\nif (!boot_cpu_has(a->cpuid)) {\r\nif (a->padlen > 1)\r\noptimize_nops(a, instr);\r\ncontinue;\r\n}\r\nDPRINTK("feat: %d*32+%d, old: (%p, len: %d), repl: (%p, len: %d), pad: %d",\r\na->cpuid >> 5,\r\na->cpuid & 0x1f,\r\ninstr, a->instrlen,\r\nreplacement, a->replacementlen, a->padlen);\r\nDUMP_BYTES(instr, a->instrlen, "%p: old_insn: ", instr);\r\nDUMP_BYTES(replacement, a->replacementlen, "%p: rpl_insn: ", replacement);\r\nmemcpy(insnbuf, replacement, a->replacementlen);\r\ninsnbuf_sz = a->replacementlen;\r\nif (*insnbuf == 0xe8 && a->replacementlen == 5) {\r\n*(s32 *)(insnbuf + 1) += replacement - instr;\r\nDPRINTK("Fix CALL offset: 0x%x, CALL 0x%lx",\r\n*(s32 *)(insnbuf + 1),\r\n(unsigned long)instr + *(s32 *)(insnbuf + 1) + 5);\r\n}\r\nif (a->replacementlen && is_jmp(replacement[0]))\r\nrecompute_jump(a, instr, replacement, insnbuf);\r\nif (a->instrlen > a->replacementlen) {\r\nadd_nops(insnbuf + a->replacementlen,\r\na->instrlen - a->replacementlen);\r\ninsnbuf_sz += a->instrlen - a->replacementlen;\r\n}\r\nDUMP_BYTES(insnbuf, insnbuf_sz, "%p: final_insn: ", instr);\r\ntext_poke_early(instr, insnbuf, insnbuf_sz);\r\n}\r\n}\r\nstatic void alternatives_smp_lock(const s32 *start, const s32 *end,\r\nu8 *text, u8 *text_end)\r\n{\r\nconst s32 *poff;\r\nmutex_lock(&text_mutex);\r\nfor (poff = start; poff < end; poff++) {\r\nu8 *ptr = (u8 *)poff + *poff;\r\nif (!*poff || ptr < text || ptr >= text_end)\r\ncontinue;\r\nif (*ptr == 0x3e)\r\ntext_poke(ptr, ((unsigned char []){0xf0}), 1);\r\n}\r\nmutex_unlock(&text_mutex);\r\n}\r\nstatic void alternatives_smp_unlock(const s32 *start, const s32 *end,\r\nu8 *text, u8 *text_end)\r\n{\r\nconst s32 *poff;\r\nmutex_lock(&text_mutex);\r\nfor (poff = start; poff < end; poff++) {\r\nu8 *ptr = (u8 *)poff + *poff;\r\nif (!*poff || ptr < text || ptr >= text_end)\r\ncontinue;\r\nif (*ptr == 0xf0)\r\ntext_poke(ptr, ((unsigned char []){0x3E}), 1);\r\n}\r\nmutex_unlock(&text_mutex);\r\n}\r\nvoid __init_or_module alternatives_smp_module_add(struct module *mod,\r\nchar *name,\r\nvoid *locks, void *locks_end,\r\nvoid *text, void *text_end)\r\n{\r\nstruct smp_alt_module *smp;\r\nmutex_lock(&smp_alt);\r\nif (!uniproc_patched)\r\ngoto unlock;\r\nif (num_possible_cpus() == 1)\r\ngoto smp_unlock;\r\nsmp = kzalloc(sizeof(*smp), GFP_KERNEL);\r\nif (NULL == smp)\r\ngoto unlock;\r\nsmp->mod = mod;\r\nsmp->name = name;\r\nsmp->locks = locks;\r\nsmp->locks_end = locks_end;\r\nsmp->text = text;\r\nsmp->text_end = text_end;\r\nDPRINTK("locks %p -> %p, text %p -> %p, name %s\n",\r\nsmp->locks, smp->locks_end,\r\nsmp->text, smp->text_end, smp->name);\r\nlist_add_tail(&smp->next, &smp_alt_modules);\r\nsmp_unlock:\r\nalternatives_smp_unlock(locks, locks_end, text, text_end);\r\nunlock:\r\nmutex_unlock(&smp_alt);\r\n}\r\nvoid __init_or_module alternatives_smp_module_del(struct module *mod)\r\n{\r\nstruct smp_alt_module *item;\r\nmutex_lock(&smp_alt);\r\nlist_for_each_entry(item, &smp_alt_modules, next) {\r\nif (mod != item->mod)\r\ncontinue;\r\nlist_del(&item->next);\r\nkfree(item);\r\nbreak;\r\n}\r\nmutex_unlock(&smp_alt);\r\n}\r\nvoid alternatives_enable_smp(void)\r\n{\r\nstruct smp_alt_module *mod;\r\nBUG_ON(num_possible_cpus() == 1);\r\nmutex_lock(&smp_alt);\r\nif (uniproc_patched) {\r\npr_info("switching to SMP code\n");\r\nBUG_ON(num_online_cpus() != 1);\r\nclear_cpu_cap(&boot_cpu_data, X86_FEATURE_UP);\r\nclear_cpu_cap(&cpu_data(0), X86_FEATURE_UP);\r\nlist_for_each_entry(mod, &smp_alt_modules, next)\r\nalternatives_smp_lock(mod->locks, mod->locks_end,\r\nmod->text, mod->text_end);\r\nuniproc_patched = false;\r\n}\r\nmutex_unlock(&smp_alt);\r\n}\r\nint alternatives_text_reserved(void *start, void *end)\r\n{\r\nstruct smp_alt_module *mod;\r\nconst s32 *poff;\r\nu8 *text_start = start;\r\nu8 *text_end = end;\r\nlist_for_each_entry(mod, &smp_alt_modules, next) {\r\nif (mod->text > text_end || mod->text_end < text_start)\r\ncontinue;\r\nfor (poff = mod->locks; poff < mod->locks_end; poff++) {\r\nconst u8 *ptr = (const u8 *)poff + *poff;\r\nif (text_start <= ptr && text_end > ptr)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid __init_or_module apply_paravirt(struct paravirt_patch_site *start,\r\nstruct paravirt_patch_site *end)\r\n{\r\nstruct paravirt_patch_site *p;\r\nchar insnbuf[MAX_PATCH_LEN];\r\nif (noreplace_paravirt)\r\nreturn;\r\nfor (p = start; p < end; p++) {\r\nunsigned int used;\r\nBUG_ON(p->len > MAX_PATCH_LEN);\r\nmemcpy(insnbuf, p->instr, p->len);\r\nused = pv_init_ops.patch(p->instrtype, p->clobbers, insnbuf,\r\n(unsigned long)p->instr, p->len);\r\nBUG_ON(used > p->len);\r\nadd_nops(insnbuf + used, p->len - used);\r\ntext_poke_early(p->instr, insnbuf, p->len);\r\n}\r\n}\r\nvoid __init alternative_instructions(void)\r\n{\r\nstop_nmi();\r\napply_alternatives(__alt_instructions, __alt_instructions_end);\r\n#ifdef CONFIG_SMP\r\nif (!noreplace_smp && (num_present_cpus() == 1 || setup_max_cpus <= 1)) {\r\nuniproc_patched = true;\r\nalternatives_smp_module_add(NULL, "core kernel",\r\n__smp_locks, __smp_locks_end,\r\n_text, _etext);\r\n}\r\nif (!uniproc_patched || num_possible_cpus() == 1)\r\nfree_init_pages("SMP alternatives",\r\n(unsigned long)__smp_locks,\r\n(unsigned long)__smp_locks_end);\r\n#endif\r\napply_paravirt(__parainstructions, __parainstructions_end);\r\nrestart_nmi();\r\nalternatives_patched = 1;\r\n}\r\nvoid *__init_or_module text_poke_early(void *addr, const void *opcode,\r\nsize_t len)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nmemcpy(addr, opcode, len);\r\nsync_core();\r\nlocal_irq_restore(flags);\r\nreturn addr;\r\n}\r\nvoid *text_poke(void *addr, const void *opcode, size_t len)\r\n{\r\nunsigned long flags;\r\nchar *vaddr;\r\nstruct page *pages[2];\r\nint i;\r\nif (!core_kernel_text((unsigned long)addr)) {\r\npages[0] = vmalloc_to_page(addr);\r\npages[1] = vmalloc_to_page(addr + PAGE_SIZE);\r\n} else {\r\npages[0] = virt_to_page(addr);\r\nWARN_ON(!PageReserved(pages[0]));\r\npages[1] = virt_to_page(addr + PAGE_SIZE);\r\n}\r\nBUG_ON(!pages[0]);\r\nlocal_irq_save(flags);\r\nset_fixmap(FIX_TEXT_POKE0, page_to_phys(pages[0]));\r\nif (pages[1])\r\nset_fixmap(FIX_TEXT_POKE1, page_to_phys(pages[1]));\r\nvaddr = (char *)fix_to_virt(FIX_TEXT_POKE0);\r\nmemcpy(&vaddr[(unsigned long)addr & ~PAGE_MASK], opcode, len);\r\nclear_fixmap(FIX_TEXT_POKE0);\r\nif (pages[1])\r\nclear_fixmap(FIX_TEXT_POKE1);\r\nlocal_flush_tlb();\r\nsync_core();\r\nfor (i = 0; i < len; i++)\r\nBUG_ON(((char *)addr)[i] != ((char *)opcode)[i]);\r\nlocal_irq_restore(flags);\r\nreturn addr;\r\n}\r\nstatic void do_sync_core(void *info)\r\n{\r\nsync_core();\r\n}\r\nint poke_int3_handler(struct pt_regs *regs)\r\n{\r\nsmp_rmb();\r\nif (likely(!bp_patching_in_progress))\r\nreturn 0;\r\nif (user_mode(regs) || regs->ip != (unsigned long)bp_int3_addr)\r\nreturn 0;\r\nregs->ip = (unsigned long) bp_int3_handler;\r\nreturn 1;\r\n}\r\nvoid *text_poke_bp(void *addr, const void *opcode, size_t len, void *handler)\r\n{\r\nunsigned char int3 = 0xcc;\r\nbp_int3_handler = handler;\r\nbp_int3_addr = (u8 *)addr + sizeof(int3);\r\nbp_patching_in_progress = true;\r\nsmp_wmb();\r\ntext_poke(addr, &int3, sizeof(int3));\r\non_each_cpu(do_sync_core, NULL, 1);\r\nif (len - sizeof(int3) > 0) {\r\ntext_poke((char *)addr + sizeof(int3),\r\n(const char *) opcode + sizeof(int3),\r\nlen - sizeof(int3));\r\non_each_cpu(do_sync_core, NULL, 1);\r\n}\r\ntext_poke(addr, opcode, sizeof(int3));\r\non_each_cpu(do_sync_core, NULL, 1);\r\nbp_patching_in_progress = false;\r\nsmp_wmb();\r\nreturn addr;\r\n}
