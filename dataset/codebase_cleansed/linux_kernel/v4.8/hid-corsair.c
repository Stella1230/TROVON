static int corsair_usage_to_gkey(unsigned int usage)\r\n{\r\nif (usage >= 0xd0 && usage <= 0xdf)\r\nreturn usage - 0xd0 + 1;\r\nif (usage >= 0xe8 && usage <= 0xe9)\r\nreturn usage - 0xe8 + 17;\r\nreturn 0;\r\n}\r\nstatic enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\r\n{\r\nint ret;\r\nstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\r\nstruct device *dev = led->cdev.dev->parent;\r\nstruct usb_interface *usbif = to_usb_interface(dev->parent);\r\nstruct usb_device *usbdev = interface_to_usbdev(usbif);\r\nint brightness;\r\nchar data[8];\r\nret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\r\nK90_REQUEST_STATUS,\r\nUSB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, 0, 0, data, 8,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (ret < 0) {\r\ndev_warn(dev, "Failed to get K90 initial state (error %d).\n",\r\nret);\r\nreturn -EIO;\r\n}\r\nbrightness = data[4];\r\nif (brightness < 0 || brightness > 3) {\r\ndev_warn(dev,\r\n"Read invalid backlight brightness: %02hhx.\n",\r\ndata[4]);\r\nreturn -EIO;\r\n}\r\nreturn brightness;\r\n}\r\nstatic enum led_brightness k90_record_led_get(struct led_classdev *led_cdev)\r\n{\r\nstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\r\nreturn led->brightness;\r\n}\r\nstatic void k90_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\r\nled->brightness = brightness;\r\nschedule_work(&led->work);\r\n}\r\nstatic void k90_backlight_work(struct work_struct *work)\r\n{\r\nint ret;\r\nstruct k90_led *led = container_of(work, struct k90_led, work);\r\nstruct device *dev;\r\nstruct usb_interface *usbif;\r\nstruct usb_device *usbdev;\r\nif (led->removed)\r\nreturn;\r\ndev = led->cdev.dev->parent;\r\nusbif = to_usb_interface(dev->parent);\r\nusbdev = interface_to_usbdev(usbif);\r\nret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\r\nK90_REQUEST_BRIGHTNESS,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, led->brightness, 0,\r\nNULL, 0, USB_CTRL_SET_TIMEOUT);\r\nif (ret != 0)\r\ndev_warn(dev, "Failed to set backlight brightness (error: %d).\n",\r\nret);\r\n}\r\nstatic void k90_record_led_work(struct work_struct *work)\r\n{\r\nint ret;\r\nstruct k90_led *led = container_of(work, struct k90_led, work);\r\nstruct device *dev;\r\nstruct usb_interface *usbif;\r\nstruct usb_device *usbdev;\r\nint value;\r\nif (led->removed)\r\nreturn;\r\ndev = led->cdev.dev->parent;\r\nusbif = to_usb_interface(dev->parent);\r\nusbdev = interface_to_usbdev(usbif);\r\nif (led->brightness > 0)\r\nvalue = K90_MACRO_LED_ON;\r\nelse\r\nvalue = K90_MACRO_LED_OFF;\r\nret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\r\nK90_REQUEST_MACRO_MODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, value, 0, NULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (ret != 0)\r\ndev_warn(dev, "Failed to set record LED state (error: %d).\n",\r\nret);\r\n}\r\nstatic ssize_t k90_show_macro_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nstruct usb_interface *usbif = to_usb_interface(dev->parent);\r\nstruct usb_device *usbdev = interface_to_usbdev(usbif);\r\nconst char *macro_mode;\r\nchar data[8];\r\nret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\r\nK90_REQUEST_GET_MODE,\r\nUSB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, 0, 0, data, 2,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (ret < 0) {\r\ndev_warn(dev, "Failed to get K90 initial mode (error %d).\n",\r\nret);\r\nreturn -EIO;\r\n}\r\nswitch (data[0]) {\r\ncase K90_MACRO_MODE_HW:\r\nmacro_mode = "HW";\r\nbreak;\r\ncase K90_MACRO_MODE_SW:\r\nmacro_mode = "SW";\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "K90 in unknown mode: %02hhx.\n",\r\ndata[0]);\r\nreturn -EIO;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", macro_mode);\r\n}\r\nstatic ssize_t k90_store_macro_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nstruct usb_interface *usbif = to_usb_interface(dev->parent);\r\nstruct usb_device *usbdev = interface_to_usbdev(usbif);\r\n__u16 value;\r\nif (strncmp(buf, "SW", 2) == 0)\r\nvalue = K90_MACRO_MODE_SW;\r\nelse if (strncmp(buf, "HW", 2) == 0)\r\nvalue = K90_MACRO_MODE_HW;\r\nelse\r\nreturn -EINVAL;\r\nret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\r\nK90_REQUEST_MACRO_MODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, value, 0, NULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (ret != 0) {\r\ndev_warn(dev, "Failed to set macro mode.\n");\r\nreturn ret;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t k90_show_current_profile(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nstruct usb_interface *usbif = to_usb_interface(dev->parent);\r\nstruct usb_device *usbdev = interface_to_usbdev(usbif);\r\nint current_profile;\r\nchar data[8];\r\nret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\r\nK90_REQUEST_STATUS,\r\nUSB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, 0, 0, data, 8,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (ret < 0) {\r\ndev_warn(dev, "Failed to get K90 initial state (error %d).\n",\r\nret);\r\nreturn -EIO;\r\n}\r\ncurrent_profile = data[7];\r\nif (current_profile < 1 || current_profile > 3) {\r\ndev_warn(dev, "Read invalid current profile: %02hhx.\n",\r\ndata[7]);\r\nreturn -EIO;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", current_profile);\r\n}\r\nstatic ssize_t k90_store_current_profile(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nstruct usb_interface *usbif = to_usb_interface(dev->parent);\r\nstruct usb_device *usbdev = interface_to_usbdev(usbif);\r\nint profile;\r\nif (kstrtoint(buf, 10, &profile))\r\nreturn -EINVAL;\r\nif (profile < 1 || profile > 3)\r\nreturn -EINVAL;\r\nret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\r\nK90_REQUEST_PROFILE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, profile, 0, NULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (ret != 0) {\r\ndev_warn(dev, "Failed to change current profile (error %d).\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn count;\r\n}\r\nstatic int k90_init_backlight(struct hid_device *dev)\r\n{\r\nint ret;\r\nstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\r\nsize_t name_sz;\r\nchar *name;\r\ndrvdata->backlight = kzalloc(sizeof(struct k90_led), GFP_KERNEL);\r\nif (!drvdata->backlight) {\r\nret = -ENOMEM;\r\ngoto fail_backlight_alloc;\r\n}\r\nname_sz =\r\nstrlen(dev_name(&dev->dev)) + sizeof(K90_BACKLIGHT_LED_SUFFIX);\r\nname = kzalloc(name_sz, GFP_KERNEL);\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto fail_name_alloc;\r\n}\r\nsnprintf(name, name_sz, "%s" K90_BACKLIGHT_LED_SUFFIX,\r\ndev_name(&dev->dev));\r\ndrvdata->backlight->removed = false;\r\ndrvdata->backlight->cdev.name = name;\r\ndrvdata->backlight->cdev.max_brightness = 3;\r\ndrvdata->backlight->cdev.brightness_set = k90_brightness_set;\r\ndrvdata->backlight->cdev.brightness_get = k90_backlight_get;\r\nINIT_WORK(&drvdata->backlight->work, k90_backlight_work);\r\nret = led_classdev_register(&dev->dev, &drvdata->backlight->cdev);\r\nif (ret != 0)\r\ngoto fail_register_cdev;\r\nreturn 0;\r\nfail_register_cdev:\r\nkfree(drvdata->backlight->cdev.name);\r\nfail_name_alloc:\r\nkfree(drvdata->backlight);\r\ndrvdata->backlight = NULL;\r\nfail_backlight_alloc:\r\nreturn ret;\r\n}\r\nstatic int k90_init_macro_functions(struct hid_device *dev)\r\n{\r\nint ret;\r\nstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\r\nstruct k90_drvdata *k90;\r\nsize_t name_sz;\r\nchar *name;\r\nk90 = kzalloc(sizeof(struct k90_drvdata), GFP_KERNEL);\r\nif (!k90) {\r\nret = -ENOMEM;\r\ngoto fail_drvdata;\r\n}\r\ndrvdata->k90 = k90;\r\nname_sz = strlen(dev_name(&dev->dev)) + sizeof(K90_RECORD_LED_SUFFIX);\r\nname = kzalloc(name_sz, GFP_KERNEL);\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto fail_record_led_alloc;\r\n}\r\nsnprintf(name, name_sz, "%s" K90_RECORD_LED_SUFFIX,\r\ndev_name(&dev->dev));\r\nk90->record_led.removed = false;\r\nk90->record_led.cdev.name = name;\r\nk90->record_led.cdev.max_brightness = 1;\r\nk90->record_led.cdev.brightness_set = k90_brightness_set;\r\nk90->record_led.cdev.brightness_get = k90_record_led_get;\r\nINIT_WORK(&k90->record_led.work, k90_record_led_work);\r\nk90->record_led.brightness = 0;\r\nret = led_classdev_register(&dev->dev, &k90->record_led.cdev);\r\nif (ret != 0)\r\ngoto fail_record_led;\r\nret = sysfs_create_group(&dev->dev.kobj, &k90_attr_group);\r\nif (ret != 0)\r\ngoto fail_sysfs;\r\nreturn 0;\r\nfail_sysfs:\r\nk90->record_led.removed = true;\r\nled_classdev_unregister(&k90->record_led.cdev);\r\ncancel_work_sync(&k90->record_led.work);\r\nfail_record_led:\r\nkfree(k90->record_led.cdev.name);\r\nfail_record_led_alloc:\r\nkfree(k90);\r\nfail_drvdata:\r\ndrvdata->k90 = NULL;\r\nreturn ret;\r\n}\r\nstatic void k90_cleanup_backlight(struct hid_device *dev)\r\n{\r\nstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\r\nif (drvdata->backlight) {\r\ndrvdata->backlight->removed = true;\r\nled_classdev_unregister(&drvdata->backlight->cdev);\r\ncancel_work_sync(&drvdata->backlight->work);\r\nkfree(drvdata->backlight->cdev.name);\r\nkfree(drvdata->backlight);\r\n}\r\n}\r\nstatic void k90_cleanup_macro_functions(struct hid_device *dev)\r\n{\r\nstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\r\nstruct k90_drvdata *k90 = drvdata->k90;\r\nif (k90) {\r\nsysfs_remove_group(&dev->dev.kobj, &k90_attr_group);\r\nk90->record_led.removed = true;\r\nled_classdev_unregister(&k90->record_led.cdev);\r\ncancel_work_sync(&k90->record_led.work);\r\nkfree(k90->record_led.cdev.name);\r\nkfree(k90);\r\n}\r\n}\r\nstatic int corsair_probe(struct hid_device *dev, const struct hid_device_id *id)\r\n{\r\nint ret;\r\nunsigned long quirks = id->driver_data;\r\nstruct corsair_drvdata *drvdata;\r\nstruct usb_interface *usbif = to_usb_interface(dev->dev.parent);\r\ndrvdata = devm_kzalloc(&dev->dev, sizeof(struct corsair_drvdata),\r\nGFP_KERNEL);\r\nif (drvdata == NULL)\r\nreturn -ENOMEM;\r\ndrvdata->quirks = quirks;\r\nhid_set_drvdata(dev, drvdata);\r\nret = hid_parse(dev);\r\nif (ret != 0) {\r\nhid_err(dev, "parse failed\n");\r\nreturn ret;\r\n}\r\nret = hid_hw_start(dev, HID_CONNECT_DEFAULT);\r\nif (ret != 0) {\r\nhid_err(dev, "hw start failed\n");\r\nreturn ret;\r\n}\r\nif (usbif->cur_altsetting->desc.bInterfaceNumber == 0) {\r\nif (quirks & CORSAIR_USE_K90_MACRO) {\r\nret = k90_init_macro_functions(dev);\r\nif (ret != 0)\r\nhid_warn(dev, "Failed to initialize K90 macro functions.\n");\r\n}\r\nif (quirks & CORSAIR_USE_K90_BACKLIGHT) {\r\nret = k90_init_backlight(dev);\r\nif (ret != 0)\r\nhid_warn(dev, "Failed to initialize K90 backlight.\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void corsair_remove(struct hid_device *dev)\r\n{\r\nk90_cleanup_macro_functions(dev);\r\nk90_cleanup_backlight(dev);\r\nhid_hw_stop(dev);\r\n}\r\nstatic int corsair_event(struct hid_device *dev, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\r\nif (!drvdata->k90)\r\nreturn 0;\r\nswitch (usage->hid & HID_USAGE) {\r\ncase CORSAIR_USAGE_MACRO_RECORD_START:\r\ndrvdata->k90->record_led.brightness = 1;\r\nbreak;\r\ncase CORSAIR_USAGE_MACRO_RECORD_STOP:\r\ndrvdata->k90->record_led.brightness = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int corsair_input_mapping(struct hid_device *dev,\r\nstruct hid_input *input,\r\nstruct hid_field *field,\r\nstruct hid_usage *usage, unsigned long **bit,\r\nint *max)\r\n{\r\nint gkey;\r\nif ((usage->hid & HID_USAGE_PAGE) != HID_UP_KEYBOARD)\r\nreturn 0;\r\ngkey = corsair_usage_to_gkey(usage->hid & HID_USAGE);\r\nif (gkey != 0) {\r\nhid_map_usage_clear(input, usage, bit, max, EV_KEY,\r\ncorsair_gkey_map[gkey - 1]);\r\nreturn 1;\r\n}\r\nif ((usage->hid & HID_USAGE) >= CORSAIR_USAGE_SPECIAL_MIN &&\r\n(usage->hid & HID_USAGE) <= CORSAIR_USAGE_SPECIAL_MAX) {\r\nswitch (usage->hid & HID_USAGE) {\r\ncase CORSAIR_USAGE_MACRO_RECORD_START:\r\nhid_map_usage_clear(input, usage, bit, max, EV_KEY,\r\ncorsair_record_keycodes[0]);\r\nreturn 1;\r\ncase CORSAIR_USAGE_MACRO_RECORD_STOP:\r\nhid_map_usage_clear(input, usage, bit, max, EV_KEY,\r\ncorsair_record_keycodes[1]);\r\nreturn 1;\r\ncase CORSAIR_USAGE_M1:\r\nhid_map_usage_clear(input, usage, bit, max, EV_KEY,\r\ncorsair_profile_keycodes[0]);\r\nreturn 1;\r\ncase CORSAIR_USAGE_M2:\r\nhid_map_usage_clear(input, usage, bit, max, EV_KEY,\r\ncorsair_profile_keycodes[1]);\r\nreturn 1;\r\ncase CORSAIR_USAGE_M3:\r\nhid_map_usage_clear(input, usage, bit, max, EV_KEY,\r\ncorsair_profile_keycodes[2]);\r\nreturn 1;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}
