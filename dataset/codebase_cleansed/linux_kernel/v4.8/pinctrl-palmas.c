static int palmas_pinctrl_get_pin_mux(struct palmas_pctrl_chip_info *pci)\r\n{\r\nconst struct palmas_pingroup *g;\r\nunsigned int val;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < pci->num_pin_groups; ++i) {\r\ng = &pci->pin_groups[i];\r\nif (g->mux_reg_base == PALMAS_NONE_BASE) {\r\npci->pins_current_opt[i] = 0;\r\ncontinue;\r\n}\r\nret = palmas_read(pci->palmas, g->mux_reg_base,\r\ng->mux_reg_add, &val);\r\nif (ret < 0) {\r\ndev_err(pci->dev, "mux_reg 0x%02x read failed: %d\n",\r\ng->mux_reg_add, ret);\r\nreturn ret;\r\n}\r\nval &= g->mux_reg_mask;\r\npci->pins_current_opt[i] = val >> g->mux_bit_shift;\r\n}\r\nreturn 0;\r\n}\r\nstatic int palmas_pinctrl_set_dvfs1(struct palmas_pctrl_chip_info *pci,\r\nbool enable)\r\n{\r\nint ret;\r\nint val;\r\nval = enable ? PALMAS_PRIMARY_SECONDARY_PAD3_DVFS1 : 0;\r\nret = palmas_update_bits(pci->palmas, PALMAS_PU_PD_OD_BASE,\r\nPALMAS_PRIMARY_SECONDARY_PAD3,\r\nPALMAS_PRIMARY_SECONDARY_PAD3_DVFS1, val);\r\nif (ret < 0)\r\ndev_err(pci->dev, "SECONDARY_PAD3 update failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int palmas_pinctrl_set_dvfs2(struct palmas_pctrl_chip_info *pci,\r\nbool enable)\r\n{\r\nint ret;\r\nint val;\r\nval = enable ? PALMAS_PRIMARY_SECONDARY_PAD3_DVFS2 : 0;\r\nret = palmas_update_bits(pci->palmas, PALMAS_PU_PD_OD_BASE,\r\nPALMAS_PRIMARY_SECONDARY_PAD3,\r\nPALMAS_PRIMARY_SECONDARY_PAD3_DVFS2, val);\r\nif (ret < 0)\r\ndev_err(pci->dev, "SECONDARY_PAD3 update failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int palmas_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pci->num_pin_groups;\r\n}\r\nstatic const char *palmas_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pci->pin_groups[group].name;\r\n}\r\nstatic int palmas_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group, const unsigned **pins, unsigned *num_pins)\r\n{\r\nstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pci->pin_groups[group].pins;\r\n*num_pins = pci->pin_groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic int palmas_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pci->num_functions;\r\n}\r\nstatic const char *palmas_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pci->functions[function].name;\r\n}\r\nstatic int palmas_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function, const char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pci->functions[function].groups;\r\n*num_groups = pci->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int palmas_pinctrl_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nunsigned group)\r\n{\r\nstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct palmas_pingroup *g;\r\nint i;\r\nint ret;\r\ng = &pci->pin_groups[group];\r\nif (function <= PALMAS_PINMUX_OPTION3) {\r\nif (!g->opt[function]) {\r\ndev_err(pci->dev, "Pin %s does not support option %d\n",\r\ng->name, function);\r\nreturn -EINVAL;\r\n}\r\ni = function;\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(g->opt); i++) {\r\nif (!g->opt[i])\r\ncontinue;\r\nif (g->opt[i]->mux_opt == function)\r\nbreak;\r\n}\r\nif (WARN_ON(i == ARRAY_SIZE(g->opt))) {\r\ndev_err(pci->dev, "Pin %s does not support option %d\n",\r\ng->name, function);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (g->mux_reg_base == PALMAS_NONE_BASE) {\r\nif (WARN_ON(i != 0))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\ndev_dbg(pci->dev, "%s(): Base0x%02x:0x%02x:0x%02x:0x%02x\n",\r\n__func__, g->mux_reg_base, g->mux_reg_add,\r\ng->mux_reg_mask, i << g->mux_bit_shift);\r\nret = palmas_update_bits(pci->palmas, g->mux_reg_base, g->mux_reg_add,\r\ng->mux_reg_mask, i << g->mux_bit_shift);\r\nif (ret < 0) {\r\ndev_err(pci->dev, "Reg 0x%02x update failed: %d\n",\r\ng->mux_reg_add, ret);\r\nreturn ret;\r\n}\r\npci->pins_current_opt[group] = i;\r\nreturn 0;\r\n}\r\nstatic int palmas_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *config)\r\n{\r\nstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nconst struct palmas_pingroup *g;\r\nconst struct palmas_pin_info *opt;\r\nunsigned int val;\r\nint ret;\r\nint base, add;\r\nint rval;\r\nint arg;\r\nint group_nr;\r\nfor (group_nr = 0; group_nr < pci->num_pin_groups; ++group_nr) {\r\nif (pci->pin_groups[group_nr].pins[0] == pin)\r\nbreak;\r\n}\r\nif (group_nr == pci->num_pin_groups) {\r\ndev_err(pci->dev,\r\n"Pinconf is not supported for pin-id %d\n", pin);\r\nreturn -ENOTSUPP;\r\n}\r\ng = &pci->pin_groups[group_nr];\r\nopt = g->opt[pci->pins_current_opt[group_nr]];\r\nif (!opt) {\r\ndev_err(pci->dev,\r\n"Pinconf is not supported for pin %s\n", g->name);\r\nreturn -ENOTSUPP;\r\n}\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (!opt->pud_info) {\r\ndev_err(pci->dev,\r\n"PULL control not supported for pin %s\n",\r\ng->name);\r\nreturn -ENOTSUPP;\r\n}\r\nbase = opt->pud_info->pullup_dn_reg_base;\r\nadd = opt->pud_info->pullup_dn_reg_add;\r\nret = palmas_read(pci->palmas, base, add, &val);\r\nif (ret < 0) {\r\ndev_err(pci->dev, "Reg 0x%02x read failed: %d\n",\r\nadd, ret);\r\nreturn ret;\r\n}\r\nrval = val & opt->pud_info->pullup_dn_mask;\r\narg = 0;\r\nif ((opt->pud_info->normal_val >= 0) &&\r\n(opt->pud_info->normal_val == rval) &&\r\n(param == PIN_CONFIG_BIAS_DISABLE))\r\narg = 1;\r\nelse if ((opt->pud_info->pull_up_val >= 0) &&\r\n(opt->pud_info->pull_up_val == rval) &&\r\n(param == PIN_CONFIG_BIAS_PULL_UP))\r\narg = 1;\r\nelse if ((opt->pud_info->pull_dn_val >= 0) &&\r\n(opt->pud_info->pull_dn_val == rval) &&\r\n(param == PIN_CONFIG_BIAS_PULL_DOWN))\r\narg = 1;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nif (!opt->od_info) {\r\ndev_err(pci->dev,\r\n"OD control not supported for pin %s\n",\r\ng->name);\r\nreturn -ENOTSUPP;\r\n}\r\nbase = opt->od_info->od_reg_base;\r\nadd = opt->od_info->od_reg_add;\r\nret = palmas_read(pci->palmas, base, add, &val);\r\nif (ret < 0) {\r\ndev_err(pci->dev, "Reg 0x%02x read failed: %d\n",\r\nadd, ret);\r\nreturn ret;\r\n}\r\nrval = val & opt->od_info->od_mask;\r\narg = -1;\r\nif ((opt->od_info->od_disable >= 0) &&\r\n(opt->od_info->od_disable == rval))\r\narg = 0;\r\nelse if ((opt->od_info->od_enable >= 0) &&\r\n(opt->od_info->od_enable == rval))\r\narg = 1;\r\nif (arg < 0) {\r\ndev_err(pci->dev,\r\n"OD control not supported for pin %s\n",\r\ng->name);\r\nreturn -ENOTSUPP;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(pci->dev, "Properties not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, (u16)arg);\r\nreturn 0;\r\n}\r\nstatic int palmas_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param;\r\nu16 param_val;\r\nconst struct palmas_pingroup *g;\r\nconst struct palmas_pin_info *opt;\r\nint ret;\r\nint base, add, mask;\r\nint rval;\r\nint group_nr;\r\nint i;\r\nfor (group_nr = 0; group_nr < pci->num_pin_groups; ++group_nr) {\r\nif (pci->pin_groups[group_nr].pins[0] == pin)\r\nbreak;\r\n}\r\nif (group_nr == pci->num_pin_groups) {\r\ndev_err(pci->dev,\r\n"Pinconf is not supported for pin-id %d\n", pin);\r\nreturn -ENOTSUPP;\r\n}\r\ng = &pci->pin_groups[group_nr];\r\nopt = g->opt[pci->pins_current_opt[group_nr]];\r\nif (!opt) {\r\ndev_err(pci->dev,\r\n"Pinconf is not supported for pin %s\n", g->name);\r\nreturn -ENOTSUPP;\r\n}\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\nparam_val = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (!opt->pud_info) {\r\ndev_err(pci->dev,\r\n"PULL control not supported for pin %s\n",\r\ng->name);\r\nreturn -ENOTSUPP;\r\n}\r\nbase = opt->pud_info->pullup_dn_reg_base;\r\nadd = opt->pud_info->pullup_dn_reg_add;\r\nmask = opt->pud_info->pullup_dn_mask;\r\nif (param == PIN_CONFIG_BIAS_DISABLE)\r\nrval = opt->pud_info->normal_val;\r\nelse if (param == PIN_CONFIG_BIAS_PULL_UP)\r\nrval = opt->pud_info->pull_up_val;\r\nelse\r\nrval = opt->pud_info->pull_dn_val;\r\nif (rval < 0) {\r\ndev_err(pci->dev,\r\n"PULL control not supported for pin %s\n",\r\ng->name);\r\nreturn -ENOTSUPP;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nif (!opt->od_info) {\r\ndev_err(pci->dev,\r\n"OD control not supported for pin %s\n",\r\ng->name);\r\nreturn -ENOTSUPP;\r\n}\r\nbase = opt->od_info->od_reg_base;\r\nadd = opt->od_info->od_reg_add;\r\nmask = opt->od_info->od_mask;\r\nif (param_val == 0)\r\nrval = opt->od_info->od_disable;\r\nelse\r\nrval = opt->od_info->od_enable;\r\nif (rval < 0) {\r\ndev_err(pci->dev,\r\n"OD control not supported for pin %s\n",\r\ng->name);\r\nreturn -ENOTSUPP;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(pci->dev, "Properties not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\ndev_dbg(pci->dev, "%s(): Add0x%02x:0x%02x:0x%02x:0x%02x\n",\r\n__func__, base, add, mask, rval);\r\nret = palmas_update_bits(pci->palmas, base, add, mask, rval);\r\nif (ret < 0) {\r\ndev_err(pci->dev, "Reg 0x%02x update failed: %d\n",\r\nadd, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int palmas_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct palmas_pctrl_chip_info *pci;\r\nconst struct palmas_pinctrl_data *pinctrl_data = &tps65913_pinctrl_data;\r\nint ret;\r\nbool enable_dvfs1 = false;\r\nbool enable_dvfs2 = false;\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(palmas_pinctrl_of_match, &pdev->dev);\r\npinctrl_data = match->data;\r\nenable_dvfs1 = of_property_read_bool(pdev->dev.of_node,\r\n"ti,palmas-enable-dvfs1");\r\nenable_dvfs2 = of_property_read_bool(pdev->dev.of_node,\r\n"ti,palmas-enable-dvfs2");\r\n}\r\npci = devm_kzalloc(&pdev->dev, sizeof(*pci), GFP_KERNEL);\r\nif (!pci) {\r\ndev_err(&pdev->dev, "Malloc for pci failed\n");\r\nreturn -ENOMEM;\r\n}\r\npci->dev = &pdev->dev;\r\npci->palmas = dev_get_drvdata(pdev->dev.parent);\r\npci->pins = palmas_pins_desc;\r\npci->num_pins = ARRAY_SIZE(palmas_pins_desc);\r\npci->functions = palmas_pin_function;\r\npci->num_functions = ARRAY_SIZE(palmas_pin_function);\r\npci->pin_groups = pinctrl_data->pin_groups;\r\npci->num_pin_groups = pinctrl_data->num_pin_groups;\r\nplatform_set_drvdata(pdev, pci);\r\npalmas_pinctrl_set_dvfs1(pci, enable_dvfs1);\r\npalmas_pinctrl_set_dvfs2(pci, enable_dvfs2);\r\nret = palmas_pinctrl_get_pin_mux(pci);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"Reading pinctrol option register failed: %d\n", ret);\r\nreturn ret;\r\n}\r\npalmas_pinctrl_desc.name = dev_name(&pdev->dev);\r\npalmas_pinctrl_desc.pins = palmas_pins_desc;\r\npalmas_pinctrl_desc.npins = ARRAY_SIZE(palmas_pins_desc);\r\npci->pctl = devm_pinctrl_register(&pdev->dev, &palmas_pinctrl_desc,\r\npci);\r\nif (IS_ERR(pci->pctl)) {\r\ndev_err(&pdev->dev, "Couldn't register pinctrl driver\n");\r\nreturn PTR_ERR(pci->pctl);\r\n}\r\nreturn 0;\r\n}
