unsigned int ccp_increment_unit_ordinal(void)\r\n{\r\nreturn atomic_inc_return(&ccp_unit_ordinal);\r\n}\r\nvoid ccp_add_device(struct ccp_device *ccp)\r\n{\r\nunsigned long flags;\r\nwrite_lock_irqsave(&ccp_unit_lock, flags);\r\nlist_add_tail(&ccp->entry, &ccp_units);\r\nif (!ccp_rr)\r\nccp_rr = ccp;\r\nwrite_unlock_irqrestore(&ccp_unit_lock, flags);\r\n}\r\nvoid ccp_del_device(struct ccp_device *ccp)\r\n{\r\nunsigned long flags;\r\nwrite_lock_irqsave(&ccp_unit_lock, flags);\r\nif (ccp_rr == ccp) {\r\nif (list_is_last(&ccp_rr->entry, &ccp_units))\r\nccp_rr = list_first_entry(&ccp_units, struct ccp_device,\r\nentry);\r\nelse\r\nccp_rr = list_next_entry(ccp_rr, entry);\r\n}\r\nlist_del(&ccp->entry);\r\nif (list_empty(&ccp_units))\r\nccp_rr = NULL;\r\nwrite_unlock_irqrestore(&ccp_unit_lock, flags);\r\n}\r\nstatic struct ccp_device *ccp_get_device(void)\r\n{\r\nunsigned long flags;\r\nstruct ccp_device *dp = NULL;\r\nread_lock_irqsave(&ccp_unit_lock, flags);\r\nif (!list_empty(&ccp_units)) {\r\nspin_lock(&ccp_rr_lock);\r\ndp = ccp_rr;\r\nif (list_is_last(&ccp_rr->entry, &ccp_units))\r\nccp_rr = list_first_entry(&ccp_units, struct ccp_device,\r\nentry);\r\nelse\r\nccp_rr = list_next_entry(ccp_rr, entry);\r\nspin_unlock(&ccp_rr_lock);\r\n}\r\nread_unlock_irqrestore(&ccp_unit_lock, flags);\r\nreturn dp;\r\n}\r\nint ccp_present(void)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nread_lock_irqsave(&ccp_unit_lock, flags);\r\nret = list_empty(&ccp_units);\r\nread_unlock_irqrestore(&ccp_unit_lock, flags);\r\nreturn ret ? -ENODEV : 0;\r\n}\r\nunsigned int ccp_version(void)\r\n{\r\nstruct ccp_device *dp;\r\nunsigned long flags;\r\nint ret = 0;\r\nread_lock_irqsave(&ccp_unit_lock, flags);\r\nif (!list_empty(&ccp_units)) {\r\ndp = list_first_entry(&ccp_units, struct ccp_device, entry);\r\nret = dp->vdata->version;\r\n}\r\nread_unlock_irqrestore(&ccp_unit_lock, flags);\r\nreturn ret;\r\n}\r\nint ccp_enqueue_cmd(struct ccp_cmd *cmd)\r\n{\r\nstruct ccp_device *ccp = ccp_get_device();\r\nunsigned long flags;\r\nunsigned int i;\r\nint ret;\r\nif (!ccp)\r\nreturn -ENODEV;\r\nif (!cmd->callback)\r\nreturn -EINVAL;\r\ncmd->ccp = ccp;\r\nspin_lock_irqsave(&ccp->cmd_lock, flags);\r\ni = ccp->cmd_q_count;\r\nif (ccp->cmd_count >= MAX_CMD_QLEN) {\r\nret = -EBUSY;\r\nif (cmd->flags & CCP_CMD_MAY_BACKLOG)\r\nlist_add_tail(&cmd->entry, &ccp->backlog);\r\n} else {\r\nret = -EINPROGRESS;\r\nccp->cmd_count++;\r\nlist_add_tail(&cmd->entry, &ccp->cmd);\r\nif (!ccp->suspending) {\r\nfor (i = 0; i < ccp->cmd_q_count; i++) {\r\nif (ccp->cmd_q[i].active)\r\ncontinue;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&ccp->cmd_lock, flags);\r\nif (i < ccp->cmd_q_count)\r\nwake_up_process(ccp->cmd_q[i].kthread);\r\nreturn ret;\r\n}\r\nstatic void ccp_do_cmd_backlog(struct work_struct *work)\r\n{\r\nstruct ccp_cmd *cmd = container_of(work, struct ccp_cmd, work);\r\nstruct ccp_device *ccp = cmd->ccp;\r\nunsigned long flags;\r\nunsigned int i;\r\ncmd->callback(cmd->data, -EINPROGRESS);\r\nspin_lock_irqsave(&ccp->cmd_lock, flags);\r\nccp->cmd_count++;\r\nlist_add_tail(&cmd->entry, &ccp->cmd);\r\nfor (i = 0; i < ccp->cmd_q_count; i++) {\r\nif (ccp->cmd_q[i].active)\r\ncontinue;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ccp->cmd_lock, flags);\r\nif (i < ccp->cmd_q_count)\r\nwake_up_process(ccp->cmd_q[i].kthread);\r\n}\r\nstatic struct ccp_cmd *ccp_dequeue_cmd(struct ccp_cmd_queue *cmd_q)\r\n{\r\nstruct ccp_device *ccp = cmd_q->ccp;\r\nstruct ccp_cmd *cmd = NULL;\r\nstruct ccp_cmd *backlog = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ccp->cmd_lock, flags);\r\ncmd_q->active = 0;\r\nif (ccp->suspending) {\r\ncmd_q->suspended = 1;\r\nspin_unlock_irqrestore(&ccp->cmd_lock, flags);\r\nwake_up_interruptible(&ccp->suspend_queue);\r\nreturn NULL;\r\n}\r\nif (ccp->cmd_count) {\r\ncmd_q->active = 1;\r\ncmd = list_first_entry(&ccp->cmd, struct ccp_cmd, entry);\r\nlist_del(&cmd->entry);\r\nccp->cmd_count--;\r\n}\r\nif (!list_empty(&ccp->backlog)) {\r\nbacklog = list_first_entry(&ccp->backlog, struct ccp_cmd,\r\nentry);\r\nlist_del(&backlog->entry);\r\n}\r\nspin_unlock_irqrestore(&ccp->cmd_lock, flags);\r\nif (backlog) {\r\nINIT_WORK(&backlog->work, ccp_do_cmd_backlog);\r\nschedule_work(&backlog->work);\r\n}\r\nreturn cmd;\r\n}\r\nstatic void ccp_do_cmd_complete(unsigned long data)\r\n{\r\nstruct ccp_tasklet_data *tdata = (struct ccp_tasklet_data *)data;\r\nstruct ccp_cmd *cmd = tdata->cmd;\r\ncmd->callback(cmd->data, cmd->ret);\r\ncomplete(&tdata->completion);\r\n}\r\nint ccp_cmd_queue_thread(void *data)\r\n{\r\nstruct ccp_cmd_queue *cmd_q = (struct ccp_cmd_queue *)data;\r\nstruct ccp_cmd *cmd;\r\nstruct ccp_tasklet_data tdata;\r\nstruct tasklet_struct tasklet;\r\ntasklet_init(&tasklet, ccp_do_cmd_complete, (unsigned long)&tdata);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (!kthread_should_stop()) {\r\nschedule();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\ncmd = ccp_dequeue_cmd(cmd_q);\r\nif (!cmd)\r\ncontinue;\r\n__set_current_state(TASK_RUNNING);\r\ncmd->ret = ccp_run_cmd(cmd_q, cmd);\r\ntdata.cmd = cmd;\r\ninit_completion(&tdata.completion);\r\ntasklet_schedule(&tasklet);\r\nwait_for_completion(&tdata.completion);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nreturn 0;\r\n}\r\nstruct ccp_device *ccp_alloc_struct(struct device *dev)\r\n{\r\nstruct ccp_device *ccp;\r\nccp = devm_kzalloc(dev, sizeof(*ccp), GFP_KERNEL);\r\nif (!ccp)\r\nreturn NULL;\r\nccp->dev = dev;\r\nINIT_LIST_HEAD(&ccp->cmd);\r\nINIT_LIST_HEAD(&ccp->backlog);\r\nspin_lock_init(&ccp->cmd_lock);\r\nmutex_init(&ccp->req_mutex);\r\nmutex_init(&ccp->ksb_mutex);\r\nccp->ksb_count = KSB_COUNT;\r\nccp->ksb_start = 0;\r\nccp->ord = ccp_increment_unit_ordinal();\r\nsnprintf(ccp->name, MAX_CCP_NAME_LEN, "ccp-%u", ccp->ord);\r\nsnprintf(ccp->rngname, MAX_CCP_NAME_LEN, "ccp-%u-rng", ccp->ord);\r\nreturn ccp;\r\n}\r\nbool ccp_queues_suspended(struct ccp_device *ccp)\r\n{\r\nunsigned int suspended = 0;\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&ccp->cmd_lock, flags);\r\nfor (i = 0; i < ccp->cmd_q_count; i++)\r\nif (ccp->cmd_q[i].suspended)\r\nsuspended++;\r\nspin_unlock_irqrestore(&ccp->cmd_lock, flags);\r\nreturn ccp->cmd_q_count == suspended;\r\n}\r\nstatic int __init ccp_mod_init(void)\r\n{\r\n#ifdef CONFIG_X86\r\nint ret;\r\nret = ccp_pci_init();\r\nif (ret)\r\nreturn ret;\r\nif (ccp_present() != 0) {\r\nccp_pci_exit();\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n#endif\r\n#ifdef CONFIG_ARM64\r\nint ret;\r\nret = ccp_platform_init();\r\nif (ret)\r\nreturn ret;\r\nif (ccp_present() != 0) {\r\nccp_platform_exit();\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n#endif\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit ccp_mod_exit(void)\r\n{\r\n#ifdef CONFIG_X86\r\nccp_pci_exit();\r\n#endif\r\n#ifdef CONFIG_ARM64\r\nccp_platform_exit();\r\n#endif\r\n}
