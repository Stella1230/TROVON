static int intel_lpss_request_dma_module(const char *name)\r\n{\r\nstatic bool intel_lpss_dma_requested;\r\nif (intel_lpss_dma_requested)\r\nreturn 0;\r\nintel_lpss_dma_requested = true;\r\nreturn request_module("%s", name);\r\n}\r\nstatic void intel_lpss_cache_ltr(struct intel_lpss *lpss)\r\n{\r\nlpss->active_ltr = readl(lpss->priv + LPSS_PRIV_ACTIVELTR);\r\nlpss->idle_ltr = readl(lpss->priv + LPSS_PRIV_IDLELTR);\r\n}\r\nstatic int intel_lpss_debugfs_add(struct intel_lpss *lpss)\r\n{\r\nstruct dentry *dir;\r\ndir = debugfs_create_dir(dev_name(lpss->dev), intel_lpss_debugfs);\r\nif (IS_ERR(dir))\r\nreturn PTR_ERR(dir);\r\nintel_lpss_cache_ltr(lpss);\r\ndebugfs_create_x32("capabilities", S_IRUGO, dir, &lpss->caps);\r\ndebugfs_create_x32("active_ltr", S_IRUGO, dir, &lpss->active_ltr);\r\ndebugfs_create_x32("idle_ltr", S_IRUGO, dir, &lpss->idle_ltr);\r\nlpss->debugfs = dir;\r\nreturn 0;\r\n}\r\nstatic void intel_lpss_debugfs_remove(struct intel_lpss *lpss)\r\n{\r\ndebugfs_remove_recursive(lpss->debugfs);\r\n}\r\nstatic void intel_lpss_ltr_set(struct device *dev, s32 val)\r\n{\r\nstruct intel_lpss *lpss = dev_get_drvdata(dev);\r\nu32 ltr;\r\nltr = readl(lpss->priv + LPSS_PRIV_ACTIVELTR);\r\nif (val == PM_QOS_LATENCY_ANY || val < 0) {\r\nltr &= ~LPSS_PRIV_LTR_REQ;\r\n} else {\r\nltr |= LPSS_PRIV_LTR_REQ;\r\nltr &= ~LPSS_PRIV_LTR_SCALE_MASK;\r\nltr &= ~LPSS_PRIV_LTR_VALUE_MASK;\r\nif (val > LPSS_PRIV_LTR_VALUE_MASK)\r\nltr |= LPSS_PRIV_LTR_SCALE_32US | val >> 5;\r\nelse\r\nltr |= LPSS_PRIV_LTR_SCALE_1US | val;\r\n}\r\nif (ltr == lpss->active_ltr)\r\nreturn;\r\nwritel(ltr, lpss->priv + LPSS_PRIV_ACTIVELTR);\r\nwritel(ltr, lpss->priv + LPSS_PRIV_IDLELTR);\r\nintel_lpss_cache_ltr(lpss);\r\n}\r\nstatic void intel_lpss_ltr_expose(struct intel_lpss *lpss)\r\n{\r\nlpss->dev->power.set_latency_tolerance = intel_lpss_ltr_set;\r\ndev_pm_qos_expose_latency_tolerance(lpss->dev);\r\n}\r\nstatic void intel_lpss_ltr_hide(struct intel_lpss *lpss)\r\n{\r\ndev_pm_qos_hide_latency_tolerance(lpss->dev);\r\nlpss->dev->power.set_latency_tolerance = NULL;\r\n}\r\nstatic int intel_lpss_assign_devs(struct intel_lpss *lpss)\r\n{\r\nconst struct mfd_cell *cell;\r\nunsigned int type;\r\ntype = lpss->caps & LPSS_PRIV_CAPS_TYPE_MASK;\r\ntype >>= LPSS_PRIV_CAPS_TYPE_SHIFT;\r\nswitch (type) {\r\ncase LPSS_DEV_I2C:\r\ncell = &intel_lpss_i2c_cell;\r\nbreak;\r\ncase LPSS_DEV_UART:\r\ncell = &intel_lpss_uart_cell;\r\nbreak;\r\ncase LPSS_DEV_SPI:\r\ncell = &intel_lpss_spi_cell;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nlpss->cell = devm_kmemdup(lpss->dev, cell, sizeof(*cell), GFP_KERNEL);\r\nif (!lpss->cell)\r\nreturn -ENOMEM;\r\nlpss->type = type;\r\nreturn 0;\r\n}\r\nstatic bool intel_lpss_has_idma(const struct intel_lpss *lpss)\r\n{\r\nreturn (lpss->caps & LPSS_PRIV_CAPS_NO_IDMA) == 0;\r\n}\r\nstatic void intel_lpss_set_remap_addr(const struct intel_lpss *lpss)\r\n{\r\nresource_size_t addr = lpss->info->mem->start;\r\nlo_hi_writeq(addr, lpss->priv + LPSS_PRIV_REMAP_ADDR);\r\n}\r\nstatic void intel_lpss_deassert_reset(const struct intel_lpss *lpss)\r\n{\r\nu32 value = LPSS_PRIV_RESETS_FUNC | LPSS_PRIV_RESETS_IDMA;\r\nwritel(value, lpss->priv + LPSS_PRIV_RESETS);\r\n}\r\nstatic void intel_lpss_init_dev(const struct intel_lpss *lpss)\r\n{\r\nu32 value = LPSS_PRIV_SSP_REG_DIS_DMA_FIN;\r\nintel_lpss_deassert_reset(lpss);\r\nif (!intel_lpss_has_idma(lpss))\r\nreturn;\r\nintel_lpss_set_remap_addr(lpss);\r\nif (lpss->type == LPSS_DEV_SPI)\r\nwritel(value, lpss->priv + LPSS_PRIV_SSP_REG);\r\n}\r\nstatic void intel_lpss_unregister_clock_tree(struct clk *clk)\r\n{\r\nstruct clk *parent;\r\nwhile (clk) {\r\nparent = clk_get_parent(clk);\r\nclk_unregister(clk);\r\nclk = parent;\r\n}\r\n}\r\nstatic int intel_lpss_register_clock_divider(struct intel_lpss *lpss,\r\nconst char *devname,\r\nstruct clk **clk)\r\n{\r\nchar name[32];\r\nstruct clk *tmp = *clk;\r\nsnprintf(name, sizeof(name), "%s-enable", devname);\r\ntmp = clk_register_gate(NULL, name, __clk_get_name(tmp), 0,\r\nlpss->priv, 0, 0, NULL);\r\nif (IS_ERR(tmp))\r\nreturn PTR_ERR(tmp);\r\nsnprintf(name, sizeof(name), "%s-div", devname);\r\ntmp = clk_register_fractional_divider(NULL, name, __clk_get_name(tmp),\r\n0, lpss->priv, 1, 15, 16, 15, 0,\r\nNULL);\r\nif (IS_ERR(tmp))\r\nreturn PTR_ERR(tmp);\r\n*clk = tmp;\r\nsnprintf(name, sizeof(name), "%s-update", devname);\r\ntmp = clk_register_gate(NULL, name, __clk_get_name(tmp),\r\nCLK_SET_RATE_PARENT, lpss->priv, 31, 0, NULL);\r\nif (IS_ERR(tmp))\r\nreturn PTR_ERR(tmp);\r\n*clk = tmp;\r\nreturn 0;\r\n}\r\nstatic int intel_lpss_register_clock(struct intel_lpss *lpss)\r\n{\r\nconst struct mfd_cell *cell = lpss->cell;\r\nstruct clk *clk;\r\nchar devname[24];\r\nint ret;\r\nif (!lpss->info->clk_rate)\r\nreturn 0;\r\nclk = clk_register_fixed_rate(NULL, dev_name(lpss->dev), NULL, 0,\r\nlpss->info->clk_rate);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nsnprintf(devname, sizeof(devname), "%s.%d", cell->name, lpss->devid);\r\nif (lpss->type != LPSS_DEV_I2C) {\r\nret = intel_lpss_register_clock_divider(lpss, devname, &clk);\r\nif (ret)\r\ngoto err_clk_register;\r\n}\r\nret = -ENOMEM;\r\nlpss->clock = clkdev_create(clk, lpss->info->clk_con_id, "%s", devname);\r\nif (!lpss->clock)\r\ngoto err_clk_register;\r\nlpss->clk = clk;\r\nreturn 0;\r\nerr_clk_register:\r\nintel_lpss_unregister_clock_tree(clk);\r\nreturn ret;\r\n}\r\nstatic void intel_lpss_unregister_clock(struct intel_lpss *lpss)\r\n{\r\nif (IS_ERR_OR_NULL(lpss->clk))\r\nreturn;\r\nclkdev_drop(lpss->clock);\r\nintel_lpss_unregister_clock_tree(lpss->clk);\r\n}\r\nint intel_lpss_probe(struct device *dev,\r\nconst struct intel_lpss_platform_info *info)\r\n{\r\nstruct intel_lpss *lpss;\r\nint ret;\r\nif (!info || !info->mem || info->irq <= 0)\r\nreturn -EINVAL;\r\nlpss = devm_kzalloc(dev, sizeof(*lpss), GFP_KERNEL);\r\nif (!lpss)\r\nreturn -ENOMEM;\r\nlpss->priv = devm_ioremap(dev, info->mem->start + LPSS_PRIV_OFFSET,\r\nLPSS_PRIV_SIZE);\r\nif (!lpss->priv)\r\nreturn -ENOMEM;\r\nlpss->info = info;\r\nlpss->dev = dev;\r\nlpss->caps = readl(lpss->priv + LPSS_PRIV_CAPS);\r\ndev_set_drvdata(dev, lpss);\r\nret = intel_lpss_assign_devs(lpss);\r\nif (ret)\r\nreturn ret;\r\nlpss->cell->properties = info->properties;\r\nintel_lpss_init_dev(lpss);\r\nlpss->devid = ida_simple_get(&intel_lpss_devid_ida, 0, 0, GFP_KERNEL);\r\nif (lpss->devid < 0)\r\nreturn lpss->devid;\r\nret = intel_lpss_register_clock(lpss);\r\nif (ret)\r\ngoto err_clk_register;\r\nintel_lpss_ltr_expose(lpss);\r\nret = intel_lpss_debugfs_add(lpss);\r\nif (ret)\r\ndev_warn(dev, "Failed to create debugfs entries\n");\r\nif (intel_lpss_has_idma(lpss)) {\r\nintel_lpss_request_dma_module(LPSS_IDMA64_DRIVER_NAME);\r\nret = mfd_add_devices(dev, lpss->devid, &intel_lpss_idma64_cell,\r\n1, info->mem, info->irq, NULL);\r\nif (ret)\r\ndev_warn(dev, "Failed to add %s, fallback to PIO\n",\r\nLPSS_IDMA64_DRIVER_NAME);\r\n}\r\nret = mfd_add_devices(dev, lpss->devid, lpss->cell,\r\n1, info->mem, info->irq, NULL);\r\nif (ret)\r\ngoto err_remove_ltr;\r\nreturn 0;\r\nerr_remove_ltr:\r\nintel_lpss_debugfs_remove(lpss);\r\nintel_lpss_ltr_hide(lpss);\r\nintel_lpss_unregister_clock(lpss);\r\nerr_clk_register:\r\nida_simple_remove(&intel_lpss_devid_ida, lpss->devid);\r\nreturn ret;\r\n}\r\nvoid intel_lpss_remove(struct device *dev)\r\n{\r\nstruct intel_lpss *lpss = dev_get_drvdata(dev);\r\nmfd_remove_devices(dev);\r\nintel_lpss_debugfs_remove(lpss);\r\nintel_lpss_ltr_hide(lpss);\r\nintel_lpss_unregister_clock(lpss);\r\nida_simple_remove(&intel_lpss_devid_ida, lpss->devid);\r\n}\r\nstatic int resume_lpss_device(struct device *dev, void *data)\r\n{\r\npm_runtime_resume(dev);\r\nreturn 0;\r\n}\r\nint intel_lpss_prepare(struct device *dev)\r\n{\r\ndevice_for_each_child_reverse(dev, NULL, resume_lpss_device);\r\nreturn 0;\r\n}\r\nint intel_lpss_suspend(struct device *dev)\r\n{\r\nstruct intel_lpss *lpss = dev_get_drvdata(dev);\r\nunsigned int i;\r\nfor (i = 0; i < LPSS_PRIV_REG_COUNT; i++)\r\nlpss->priv_ctx[i] = readl(lpss->priv + i * 4);\r\nwritel(0, lpss->priv + LPSS_PRIV_RESETS);\r\nreturn 0;\r\n}\r\nint intel_lpss_resume(struct device *dev)\r\n{\r\nstruct intel_lpss *lpss = dev_get_drvdata(dev);\r\nunsigned int i;\r\nintel_lpss_deassert_reset(lpss);\r\nfor (i = 0; i < LPSS_PRIV_REG_COUNT; i++)\r\nwritel(lpss->priv_ctx[i], lpss->priv + i * 4);\r\nreturn 0;\r\n}\r\nstatic int __init intel_lpss_init(void)\r\n{\r\nintel_lpss_debugfs = debugfs_create_dir("intel_lpss", NULL);\r\nreturn 0;\r\n}\r\nstatic void __exit intel_lpss_exit(void)\r\n{\r\ndebugfs_remove(intel_lpss_debugfs);\r\n}
