static int bcm590xx_get_vsel_register(int id)\r\n{\r\nif (BCM590XX_REG_IS_LDO(id))\r\nreturn BCM590XX_RFLDOCTRL + id;\r\nelse if (BCM590XX_REG_IS_GPLDO(id))\r\nreturn BCM590XX_GPLDO1CTRL + id;\r\nelse\r\nreturn BCM590XX_CSRVOUT1 + (id - BCM590XX_REG_CSR) * 3;\r\n}\r\nstatic int bcm590xx_get_enable_register(int id)\r\n{\r\nint reg = 0;\r\nif (BCM590XX_REG_IS_LDO(id))\r\nreg = BCM590XX_RFLDOPMCTRL1 + id * 2;\r\nelse if (BCM590XX_REG_IS_GPLDO(id))\r\nreg = BCM590XX_GPLDO1PMCTRL1 + id * 2;\r\nelse\r\nswitch (id) {\r\ncase BCM590XX_REG_CSR:\r\nreg = BCM590XX_CSRPMCTRL1;\r\nbreak;\r\ncase BCM590XX_REG_IOSR1:\r\nreg = BCM590XX_IOSR1PMCTRL1;\r\nbreak;\r\ncase BCM590XX_REG_IOSR2:\r\nreg = BCM590XX_IOSR2PMCTRL1;\r\nbreak;\r\ncase BCM590XX_REG_MSR:\r\nreg = BCM590XX_MSRPMCTRL1;\r\nbreak;\r\ncase BCM590XX_REG_SDSR1:\r\nreg = BCM590XX_SDSR1PMCTRL1;\r\nbreak;\r\ncase BCM590XX_REG_SDSR2:\r\nreg = BCM590XX_SDSR2PMCTRL1;\r\nbreak;\r\ncase BCM590XX_REG_VBUS:\r\nreg = BCM590XX_OTG_CTRL;\r\n}\r\nreturn reg;\r\n}\r\nstatic struct bcm590xx_board *bcm590xx_parse_dt_reg_data(\r\nstruct platform_device *pdev,\r\nstruct of_regulator_match **bcm590xx_reg_matches)\r\n{\r\nstruct bcm590xx_board *data;\r\nstruct device_node *np = pdev->dev.parent->of_node;\r\nstruct device_node *regulators;\r\nstruct of_regulator_match *matches = bcm590xx_matches;\r\nint count = ARRAY_SIZE(bcm590xx_matches);\r\nint idx = 0;\r\nint ret;\r\nif (!np) {\r\ndev_err(&pdev->dev, "of node not found\n");\r\nreturn NULL;\r\n}\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn NULL;\r\nnp = of_node_get(np);\r\nregulators = of_get_child_by_name(np, "regulators");\r\nif (!regulators) {\r\ndev_warn(&pdev->dev, "regulator node not found\n");\r\nreturn NULL;\r\n}\r\nret = of_regulator_match(&pdev->dev, regulators, matches, count);\r\nof_node_put(regulators);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error parsing regulator init data: %d\n",\r\nret);\r\nreturn NULL;\r\n}\r\n*bcm590xx_reg_matches = matches;\r\nfor (idx = 0; idx < count; idx++) {\r\nif (!matches[idx].init_data || !matches[idx].of_node)\r\ncontinue;\r\ndata->bcm590xx_pmu_init_data[idx] = matches[idx].init_data;\r\n}\r\nreturn data;\r\n}\r\nstatic int bcm590xx_probe(struct platform_device *pdev)\r\n{\r\nstruct bcm590xx *bcm590xx = dev_get_drvdata(pdev->dev.parent);\r\nstruct bcm590xx_board *pmu_data = NULL;\r\nstruct bcm590xx_reg *pmu;\r\nstruct regulator_config config = { };\r\nstruct bcm590xx_info *info;\r\nstruct regulator_init_data *reg_data;\r\nstruct regulator_dev *rdev;\r\nstruct of_regulator_match *bcm590xx_reg_matches = NULL;\r\nint i;\r\npmu_data = bcm590xx_parse_dt_reg_data(pdev,\r\n&bcm590xx_reg_matches);\r\npmu = devm_kzalloc(&pdev->dev, sizeof(*pmu), GFP_KERNEL);\r\nif (!pmu)\r\nreturn -ENOMEM;\r\npmu->mfd = bcm590xx;\r\nplatform_set_drvdata(pdev, pmu);\r\npmu->desc = devm_kzalloc(&pdev->dev, BCM590XX_NUM_REGS *\r\nsizeof(struct regulator_desc), GFP_KERNEL);\r\nif (!pmu->desc)\r\nreturn -ENOMEM;\r\ninfo = bcm590xx_regs;\r\nfor (i = 0; i < BCM590XX_NUM_REGS; i++, info++) {\r\nif (pmu_data)\r\nreg_data = pmu_data->bcm590xx_pmu_init_data[i];\r\nelse\r\nreg_data = NULL;\r\npmu->desc[i].name = info->name;\r\npmu->desc[i].supply_name = info->vin_name;\r\npmu->desc[i].id = i;\r\npmu->desc[i].volt_table = info->volt_table;\r\npmu->desc[i].n_voltages = info->n_voltages;\r\npmu->desc[i].linear_ranges = info->linear_ranges;\r\npmu->desc[i].n_linear_ranges = info->n_linear_ranges;\r\nif ((BCM590XX_REG_IS_LDO(i)) || (BCM590XX_REG_IS_GPLDO(i))) {\r\npmu->desc[i].ops = &bcm590xx_ops_ldo;\r\npmu->desc[i].vsel_mask = BCM590XX_LDO_VSEL_MASK;\r\n} else if (BCM590XX_REG_IS_VBUS(i))\r\npmu->desc[i].ops = &bcm590xx_ops_vbus;\r\nelse {\r\npmu->desc[i].ops = &bcm590xx_ops_dcdc;\r\npmu->desc[i].vsel_mask = BCM590XX_SR_VSEL_MASK;\r\n}\r\nif (BCM590XX_REG_IS_VBUS(i))\r\npmu->desc[i].enable_mask = BCM590XX_VBUS_ENABLE;\r\nelse {\r\npmu->desc[i].vsel_reg = bcm590xx_get_vsel_register(i);\r\npmu->desc[i].enable_is_inverted = true;\r\npmu->desc[i].enable_mask = BCM590XX_REG_ENABLE;\r\n}\r\npmu->desc[i].enable_reg = bcm590xx_get_enable_register(i);\r\npmu->desc[i].type = REGULATOR_VOLTAGE;\r\npmu->desc[i].owner = THIS_MODULE;\r\nconfig.dev = bcm590xx->dev;\r\nconfig.init_data = reg_data;\r\nconfig.driver_data = pmu;\r\nif (BCM590XX_REG_IS_GPLDO(i) || BCM590XX_REG_IS_VBUS(i))\r\nconfig.regmap = bcm590xx->regmap_sec;\r\nelse\r\nconfig.regmap = bcm590xx->regmap_pri;\r\nif (bcm590xx_reg_matches)\r\nconfig.of_node = bcm590xx_reg_matches[i].of_node;\r\nrdev = devm_regulator_register(&pdev->dev, &pmu->desc[i],\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(bcm590xx->dev,\r\n"failed to register %s regulator\n",\r\npdev->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\nreturn 0;\r\n}
