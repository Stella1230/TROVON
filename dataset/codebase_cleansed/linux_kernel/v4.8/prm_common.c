static void omap_prcm_events_filter_priority(unsigned long *events,\r\nunsigned long *priority_events)\r\n{\r\nint i;\r\nfor (i = 0; i < prcm_irq_setup->nr_regs; i++) {\r\npriority_events[i] =\r\nevents[i] & prcm_irq_setup->priority_mask[i];\r\nevents[i] ^= priority_events[i];\r\n}\r\n}\r\nstatic void omap_prcm_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned long pending[OMAP_PRCM_MAX_NR_PENDING_REG];\r\nunsigned long priority_pending[OMAP_PRCM_MAX_NR_PENDING_REG];\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int virtirq;\r\nint nr_irq = prcm_irq_setup->nr_regs * 32;\r\nif (prcm_irq_setup->suspended) {\r\nprcm_irq_setup->save_and_clear_irqen(prcm_irq_setup->saved_mask);\r\nprcm_irq_setup->suspend_save_flag = true;\r\n}\r\nwhile (!prcm_irq_setup->suspended) {\r\nprcm_irq_setup->read_pending_irqs(pending);\r\nif (find_first_bit(pending, nr_irq) >= nr_irq)\r\nbreak;\r\nomap_prcm_events_filter_priority(pending, priority_pending);\r\nfor_each_set_bit(virtirq, priority_pending, nr_irq)\r\ngeneric_handle_irq(prcm_irq_setup->base_irq + virtirq);\r\nfor_each_set_bit(virtirq, pending, nr_irq)\r\ngeneric_handle_irq(prcm_irq_setup->base_irq + virtirq);\r\n}\r\nif (chip->irq_ack)\r\nchip->irq_ack(&desc->irq_data);\r\nif (chip->irq_eoi)\r\nchip->irq_eoi(&desc->irq_data);\r\nchip->irq_unmask(&desc->irq_data);\r\nprcm_irq_setup->ocp_barrier();\r\n}\r\nint omap_prcm_event_to_irq(const char *name)\r\n{\r\nint i;\r\nif (!prcm_irq_setup || !name)\r\nreturn -ENOENT;\r\nfor (i = 0; i < prcm_irq_setup->nr_irqs; i++)\r\nif (!strcmp(prcm_irq_setup->irqs[i].name, name))\r\nreturn prcm_irq_setup->base_irq +\r\nprcm_irq_setup->irqs[i].offset;\r\nreturn -ENOENT;\r\n}\r\nvoid omap_prcm_irq_cleanup(void)\r\n{\r\nunsigned int irq;\r\nint i;\r\nif (!prcm_irq_setup) {\r\npr_err("PRCM: IRQ handler not initialized; cannot cleanup\n");\r\nreturn;\r\n}\r\nif (prcm_irq_chips) {\r\nfor (i = 0; i < prcm_irq_setup->nr_regs; i++) {\r\nif (prcm_irq_chips[i])\r\nirq_remove_generic_chip(prcm_irq_chips[i],\r\n0xffffffff, 0, 0);\r\nprcm_irq_chips[i] = NULL;\r\n}\r\nkfree(prcm_irq_chips);\r\nprcm_irq_chips = NULL;\r\n}\r\nkfree(prcm_irq_setup->saved_mask);\r\nprcm_irq_setup->saved_mask = NULL;\r\nkfree(prcm_irq_setup->priority_mask);\r\nprcm_irq_setup->priority_mask = NULL;\r\nif (prcm_irq_setup->xlate_irq)\r\nirq = prcm_irq_setup->xlate_irq(prcm_irq_setup->irq);\r\nelse\r\nirq = prcm_irq_setup->irq;\r\nirq_set_chained_handler(irq, NULL);\r\nif (prcm_irq_setup->base_irq > 0)\r\nirq_free_descs(prcm_irq_setup->base_irq,\r\nprcm_irq_setup->nr_regs * 32);\r\nprcm_irq_setup->base_irq = 0;\r\n}\r\nvoid omap_prcm_irq_prepare(void)\r\n{\r\nprcm_irq_setup->suspended = true;\r\n}\r\nvoid omap_prcm_irq_complete(void)\r\n{\r\nprcm_irq_setup->suspended = false;\r\nif (!prcm_irq_setup->suspend_save_flag)\r\nreturn;\r\nprcm_irq_setup->suspend_save_flag = false;\r\nprcm_irq_setup->restore_irqen(prcm_irq_setup->saved_mask);\r\n}\r\nint omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)\r\n{\r\nint nr_regs;\r\nu32 mask[OMAP_PRCM_MAX_NR_PENDING_REG];\r\nint offset, i;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nunsigned int irq;\r\nif (!irq_setup)\r\nreturn -EINVAL;\r\nnr_regs = irq_setup->nr_regs;\r\nif (prcm_irq_setup) {\r\npr_err("PRCM: already initialized; won't reinitialize\n");\r\nreturn -EINVAL;\r\n}\r\nif (nr_regs > OMAP_PRCM_MAX_NR_PENDING_REG) {\r\npr_err("PRCM: nr_regs too large\n");\r\nreturn -EINVAL;\r\n}\r\nprcm_irq_setup = irq_setup;\r\nprcm_irq_chips = kzalloc(sizeof(void *) * nr_regs, GFP_KERNEL);\r\nprcm_irq_setup->saved_mask = kzalloc(sizeof(u32) * nr_regs, GFP_KERNEL);\r\nprcm_irq_setup->priority_mask = kzalloc(sizeof(u32) * nr_regs,\r\nGFP_KERNEL);\r\nif (!prcm_irq_chips || !prcm_irq_setup->saved_mask ||\r\n!prcm_irq_setup->priority_mask) {\r\npr_err("PRCM: kzalloc failed\n");\r\ngoto err;\r\n}\r\nmemset(mask, 0, sizeof(mask));\r\nfor (i = 0; i < irq_setup->nr_irqs; i++) {\r\noffset = irq_setup->irqs[i].offset;\r\nmask[offset >> 5] |= 1 << (offset & 0x1f);\r\nif (irq_setup->irqs[i].priority)\r\nirq_setup->priority_mask[offset >> 5] |=\r\n1 << (offset & 0x1f);\r\n}\r\nif (irq_setup->xlate_irq)\r\nirq = irq_setup->xlate_irq(irq_setup->irq);\r\nelse\r\nirq = irq_setup->irq;\r\nirq_set_chained_handler(irq, omap_prcm_irq_handler);\r\nirq_setup->base_irq = irq_alloc_descs(-1, 0, irq_setup->nr_regs * 32,\r\n0);\r\nif (irq_setup->base_irq < 0) {\r\npr_err("PRCM: failed to allocate irq descs: %d\n",\r\nirq_setup->base_irq);\r\ngoto err;\r\n}\r\nfor (i = 0; i < irq_setup->nr_regs; i++) {\r\ngc = irq_alloc_generic_chip("PRCM", 1,\r\nirq_setup->base_irq + i * 32, prm_base,\r\nhandle_level_irq);\r\nif (!gc) {\r\npr_err("PRCM: failed to allocate generic chip\n");\r\ngoto err;\r\n}\r\nct = gc->chip_types;\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->regs.ack = irq_setup->ack + i * 4;\r\nct->regs.mask = irq_setup->mask + i * 4;\r\nirq_setup_generic_chip(gc, mask[i], 0, IRQ_NOREQUEST, 0);\r\nprcm_irq_chips[i] = gc;\r\n}\r\nif (of_have_populated_dt()) {\r\nint irq = omap_prcm_event_to_irq("io");\r\nomap_pcs_legacy_init(irq, irq_setup->reconfigure_io_chain);\r\n}\r\nreturn 0;\r\nerr:\r\nomap_prcm_irq_cleanup();\r\nreturn -ENOMEM;\r\n}\r\nvoid __init omap2_set_globals_prm(void __iomem *prm)\r\n{\r\nprm_base = prm;\r\n}\r\nu32 prm_read_reset_sources(void)\r\n{\r\nu32 ret = 1 << OMAP_UNKNOWN_RST_SRC_ID_SHIFT;\r\nif (prm_ll_data->read_reset_sources)\r\nret = prm_ll_data->read_reset_sources();\r\nelse\r\nWARN_ONCE(1, "prm: %s: no mapping function defined for reset sources\n", __func__);\r\nreturn ret;\r\n}\r\nbool prm_was_any_context_lost_old(u8 part, s16 inst, u16 idx)\r\n{\r\nbool ret = true;\r\nif (prm_ll_data->was_any_context_lost_old)\r\nret = prm_ll_data->was_any_context_lost_old(part, inst, idx);\r\nelse\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nvoid prm_clear_context_loss_flags_old(u8 part, s16 inst, u16 idx)\r\n{\r\nif (prm_ll_data->clear_context_loss_flags_old)\r\nprm_ll_data->clear_context_loss_flags_old(part, inst, idx);\r\nelse\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\n}\r\nint omap_prm_assert_hardreset(u8 shift, u8 part, s16 prm_mod, u16 offset)\r\n{\r\nif (!prm_ll_data->assert_hardreset) {\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nreturn prm_ll_data->assert_hardreset(shift, part, prm_mod, offset);\r\n}\r\nint omap_prm_deassert_hardreset(u8 shift, u8 st_shift, u8 part, s16 prm_mod,\r\nu16 offset, u16 st_offset)\r\n{\r\nif (!prm_ll_data->deassert_hardreset) {\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nreturn prm_ll_data->deassert_hardreset(shift, st_shift, part, prm_mod,\r\noffset, st_offset);\r\n}\r\nint omap_prm_is_hardreset_asserted(u8 shift, u8 part, s16 prm_mod, u16 offset)\r\n{\r\nif (!prm_ll_data->is_hardreset_asserted) {\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nreturn prm_ll_data->is_hardreset_asserted(shift, part, prm_mod, offset);\r\n}\r\nvoid omap_prm_reconfigure_io_chain(void)\r\n{\r\nif (!prcm_irq_setup || !prcm_irq_setup->reconfigure_io_chain)\r\nreturn;\r\nprcm_irq_setup->reconfigure_io_chain();\r\n}\r\nvoid omap_prm_reset_system(void)\r\n{\r\nif (!prm_ll_data->reset_system) {\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\nreturn;\r\n}\r\nprm_ll_data->reset_system();\r\nwhile (1)\r\ncpu_relax();\r\n}\r\nint omap_prm_clear_mod_irqs(s16 module, u8 regs, u32 wkst_mask)\r\n{\r\nif (!prm_ll_data->clear_mod_irqs) {\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nreturn prm_ll_data->clear_mod_irqs(module, regs, wkst_mask);\r\n}\r\nu32 omap_prm_vp_check_txdone(u8 vp_id)\r\n{\r\nif (!prm_ll_data->vp_check_txdone) {\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nreturn prm_ll_data->vp_check_txdone(vp_id);\r\n}\r\nvoid omap_prm_vp_clear_txdone(u8 vp_id)\r\n{\r\nif (!prm_ll_data->vp_clear_txdone) {\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\nreturn;\r\n}\r\nprm_ll_data->vp_clear_txdone(vp_id);\r\n}\r\nint prm_register(struct prm_ll_data *pld)\r\n{\r\nif (!pld)\r\nreturn -EINVAL;\r\nif (prm_ll_data != &null_prm_ll_data)\r\nreturn -EEXIST;\r\nprm_ll_data = pld;\r\nreturn 0;\r\n}\r\nint prm_unregister(struct prm_ll_data *pld)\r\n{\r\nif (!pld || prm_ll_data != pld)\r\nreturn -EINVAL;\r\nprm_ll_data = &null_prm_ll_data;\r\nreturn 0;\r\n}\r\nint __init omap2_prm_base_init(void)\r\n{\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nstruct omap_prcm_init_data *data;\r\nvoid __iomem *mem;\r\nfor_each_matching_node_and_match(np, omap_prcm_dt_match_table, &match) {\r\ndata = (struct omap_prcm_init_data *)match->data;\r\nmem = of_iomap(np, 0);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nif (data->index == TI_CLKM_PRM)\r\nprm_base = mem + data->offset;\r\ndata->mem = mem;\r\ndata->np = np;\r\nif (data->init)\r\ndata->init(data);\r\n}\r\nreturn 0;\r\n}\r\nint __init omap2_prcm_base_init(void)\r\n{\r\nint ret;\r\nret = omap2_prm_base_init();\r\nif (ret)\r\nreturn ret;\r\nreturn omap2_cm_base_init();\r\n}\r\nint __init omap_prcm_init(void)\r\n{\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nconst struct omap_prcm_init_data *data;\r\nint ret;\r\nfor_each_matching_node_and_match(np, omap_prcm_dt_match_table, &match) {\r\ndata = match->data;\r\nret = omap2_clk_provider_init(np, data->index, NULL, data->mem);\r\nif (ret)\r\nreturn ret;\r\n}\r\nomap_cm_init();\r\nreturn 0;\r\n}\r\nstatic int __init prm_late_init(void)\r\n{\r\nif (prm_ll_data->late_init)\r\nreturn prm_ll_data->late_init();\r\nreturn 0;\r\n}
