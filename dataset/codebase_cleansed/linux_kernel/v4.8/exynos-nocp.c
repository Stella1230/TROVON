static int exynos_nocp_set_event(struct devfreq_event_dev *edev)\r\n{\r\nstruct exynos_nocp *nocp = devfreq_event_get_drvdata(edev);\r\nint ret;\r\nret = regmap_update_bits(nocp->regmap, NOCP_MAIN_CTL,\r\nNOCP_MAIN_CTL_STATEN_MASK, 0);\r\nif (ret < 0) {\r\ndev_err(nocp->dev, "failed to disable the NoC probe device\n");\r\nreturn ret;\r\n}\r\nret = regmap_write(nocp->regmap, NOCP_STAT_PERIOD, 0x0);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_COUNTERS_0_SRC,\r\nNOCP_CNT_SRC_INTEVENT_MASK,\r\nNOCP_CNT_SRC_INTEVENT_BYTE_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_COUNTERS_1_SRC,\r\nNOCP_CNT_SRC_INTEVENT_MASK,\r\nNOCP_CNT_SRC_INTEVENT_CHAIN_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_COUNTERS_2_SRC,\r\nNOCP_CNT_SRC_INTEVENT_MASK,\r\nNOCP_CNT_SRC_INTEVENT_CYCLE_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_COUNTERS_3_SRC,\r\nNOCP_CNT_SRC_INTEVENT_MASK,\r\nNOCP_CNT_SRC_INTEVENT_CHAIN_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_write(nocp->regmap, NOCP_STAT_ALARM_MIN, 0x0);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_write(nocp->regmap, NOCP_STAT_ALARM_MAX, 0x0);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_COUNTERS_0_ALARM_MODE,\r\nNOCP_CNT_ALARM_MODE_MASK,\r\nNOCP_CNT_ALARM_MODE_MIN_MAX_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_COUNTERS_1_ALARM_MODE,\r\nNOCP_CNT_ALARM_MODE_MASK,\r\nNOCP_CNT_ALARM_MODE_MIN_MAX_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_COUNTERS_2_ALARM_MODE,\r\nNOCP_CNT_ALARM_MODE_MASK,\r\nNOCP_CNT_ALARM_MODE_MIN_MAX_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_COUNTERS_3_ALARM_MODE,\r\nNOCP_CNT_ALARM_MODE_MASK,\r\nNOCP_CNT_ALARM_MODE_MIN_MAX_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_MAIN_CTL,\r\nNOCP_MAIN_CTL_STATEN_MASK | NOCP_MAIN_CTL_ALARMEN_MASK,\r\nNOCP_MAIN_CTL_STATEN_MASK | NOCP_MAIN_CTL_ALARMEN_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_CFG_CTL,\r\nNOCP_CFG_CTL_GLOBALEN_MASK,\r\nNOCP_CFG_CTL_GLOBALEN_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(nocp->regmap, NOCP_MAIN_CTL,\r\nNOCP_MAIN_CTL_STATEN_MASK,\r\nNOCP_MAIN_CTL_STATEN_MASK);\r\nif (ret < 0)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nif (regmap_update_bits(nocp->regmap, NOCP_MAIN_CTL,\r\nNOCP_MAIN_CTL_STATEN_MASK, 0)) {\r\ndev_err(nocp->dev, "Failed to reset NoC probe device\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int exynos_nocp_get_event(struct devfreq_event_dev *edev,\r\nstruct devfreq_event_data *edata)\r\n{\r\nstruct exynos_nocp *nocp = devfreq_event_get_drvdata(edev);\r\nunsigned int counter[4];\r\nint ret;\r\nret = regmap_read(nocp->regmap, NOCP_COUNTERS_0_VAL, &counter[0]);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_read(nocp->regmap, NOCP_COUNTERS_1_VAL, &counter[1]);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_read(nocp->regmap, NOCP_COUNTERS_2_VAL, &counter[2]);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_read(nocp->regmap, NOCP_COUNTERS_3_VAL, &counter[3]);\r\nif (ret < 0)\r\ngoto out;\r\nedata->load_count = ((counter[1] << 16) | counter[0]);\r\nedata->total_count = ((counter[3] << 16) | counter[2]);\r\ndev_dbg(&edev->dev, "%s (event: %ld/%ld)\n", edev->desc->name,\r\nedata->load_count, edata->total_count);\r\nreturn 0;\r\nout:\r\nedata->load_count = 0;\r\nedata->total_count = 0;\r\ndev_err(nocp->dev, "Failed to read the counter of NoC probe device\n");\r\nreturn ret;\r\n}\r\nstatic int exynos_nocp_parse_dt(struct platform_device *pdev,\r\nstruct exynos_nocp *nocp)\r\n{\r\nstruct device *dev = nocp->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nif (!np) {\r\ndev_err(dev, "failed to find devicetree node\n");\r\nreturn -EINVAL;\r\n}\r\nnocp->clk = devm_clk_get(dev, "nocp");\r\nif (IS_ERR(nocp->clk))\r\nnocp->clk = NULL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nexynos_nocp_regmap_config.max_register = resource_size(res) - 4;\r\nnocp->regmap = devm_regmap_init_mmio(dev, base,\r\n&exynos_nocp_regmap_config);\r\nif (IS_ERR(nocp->regmap)) {\r\ndev_err(dev, "failed to initialize regmap\n");\r\nreturn PTR_ERR(nocp->regmap);\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_nocp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct exynos_nocp *nocp;\r\nint ret;\r\nnocp = devm_kzalloc(&pdev->dev, sizeof(*nocp), GFP_KERNEL);\r\nif (!nocp)\r\nreturn -ENOMEM;\r\nnocp->dev = &pdev->dev;\r\nret = exynos_nocp_parse_dt(pdev, nocp);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to parse devicetree for resource\n");\r\nreturn ret;\r\n}\r\nnocp->desc.ops = &exynos_nocp_ops;\r\nnocp->desc.driver_data = nocp;\r\nnocp->desc.name = np->full_name;\r\nnocp->edev = devm_devfreq_event_add_edev(&pdev->dev, &nocp->desc);\r\nif (IS_ERR(nocp->edev)) {\r\ndev_err(&pdev->dev,\r\n"failed to add devfreq-event device\n");\r\nreturn PTR_ERR(nocp->edev);\r\n}\r\nplatform_set_drvdata(pdev, nocp);\r\nclk_prepare_enable(nocp->clk);\r\npr_info("exynos-nocp: new NoC Probe device registered: %s\n",\r\ndev_name(dev));\r\nreturn 0;\r\n}\r\nstatic int exynos_nocp_remove(struct platform_device *pdev)\r\n{\r\nstruct exynos_nocp *nocp = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(nocp->clk);\r\nreturn 0;\r\n}
