static irqreturn_t mcs_touchkey_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mcs_touchkey_data *data = dev_id;\r\nstruct mcs_touchkey_chip *chip = &data->chip;\r\nstruct i2c_client *client = data->client;\r\nstruct input_dev *input = data->input_dev;\r\nunsigned int key_val;\r\nunsigned int pressed;\r\nint val;\r\nval = i2c_smbus_read_byte_data(client, chip->status_reg);\r\nif (val < 0) {\r\ndev_err(&client->dev, "i2c read error [%d]\n", val);\r\ngoto out;\r\n}\r\npressed = (val & (1 << chip->pressbit)) >> chip->pressbit;\r\nif (chip->press_invert)\r\npressed ^= chip->press_invert;\r\nif (pressed) {\r\nkey_val = val & (0xff >> (8 - chip->pressbit));\r\nif (!key_val)\r\ngoto out;\r\nkey_val -= chip->baseval;\r\ndata->key_code = data->keycodes[key_val];\r\ndata->key_val = key_val;\r\n}\r\ninput_event(input, EV_MSC, MSC_SCAN, data->key_val);\r\ninput_report_key(input, data->key_code, pressed);\r\ninput_sync(input);\r\ndev_dbg(&client->dev, "key %d %d %s\n", data->key_val, data->key_code,\r\npressed ? "pressed" : "released");\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mcs_touchkey_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct mcs_platform_data *pdata;\r\nstruct mcs_touchkey_data *data;\r\nstruct input_dev *input_dev;\r\nunsigned int fw_reg;\r\nint fw_ver;\r\nint error;\r\nint i;\r\npdata = dev_get_platdata(&client->dev);\r\nif (!pdata) {\r\ndev_err(&client->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\ndata = kzalloc(sizeof(struct mcs_touchkey_data) +\r\nsizeof(data->keycodes[0]) * (pdata->key_maxval + 1),\r\nGFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!data || !input_dev) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ndata->client = client;\r\ndata->input_dev = input_dev;\r\nif (id->driver_data == MCS5000_TOUCHKEY) {\r\ndata->chip.status_reg = MCS5000_TOUCHKEY_STATUS;\r\ndata->chip.pressbit = MCS5000_TOUCHKEY_STATUS_PRESS;\r\ndata->chip.baseval = MCS5000_TOUCHKEY_BASE_VAL;\r\nfw_reg = MCS5000_TOUCHKEY_FW;\r\n} else {\r\ndata->chip.status_reg = MCS5080_TOUCHKEY_STATUS;\r\ndata->chip.pressbit = MCS5080_TOUCHKEY_STATUS_PRESS;\r\ndata->chip.press_invert = 1;\r\ndata->chip.baseval = MCS5080_TOUCHKEY_BASE_VAL;\r\nfw_reg = MCS5080_TOUCHKEY_FW;\r\n}\r\nfw_ver = i2c_smbus_read_byte_data(client, fw_reg);\r\nif (fw_ver < 0) {\r\nerror = fw_ver;\r\ndev_err(&client->dev, "i2c read error[%d]\n", error);\r\ngoto err_free_mem;\r\n}\r\ndev_info(&client->dev, "Firmware version: %d\n", fw_ver);\r\ninput_dev->name = "MELFAS MCS Touchkey";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY);\r\nif (!pdata->no_autorepeat)\r\ninput_dev->evbit[0] |= BIT_MASK(EV_REP);\r\ninput_dev->keycode = data->keycodes;\r\ninput_dev->keycodesize = sizeof(data->keycodes[0]);\r\ninput_dev->keycodemax = pdata->key_maxval + 1;\r\nfor (i = 0; i < pdata->keymap_size; i++) {\r\nunsigned int val = MCS_KEY_VAL(pdata->keymap[i]);\r\nunsigned int code = MCS_KEY_CODE(pdata->keymap[i]);\r\ndata->keycodes[val] = code;\r\n__set_bit(code, input_dev->keybit);\r\n}\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(input_dev, data);\r\nif (pdata->cfg_pin)\r\npdata->cfg_pin();\r\nif (pdata->poweron) {\r\ndata->poweron = pdata->poweron;\r\ndata->poweron(true);\r\n}\r\nerror = request_threaded_irq(client->irq, NULL, mcs_touchkey_interrupt,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nclient->dev.driver->name, data);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\ngoto err_free_mem;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error)\r\ngoto err_free_irq;\r\ni2c_set_clientdata(client, data);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, data);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(data);\r\nreturn error;\r\n}\r\nstatic int mcs_touchkey_remove(struct i2c_client *client)\r\n{\r\nstruct mcs_touchkey_data *data = i2c_get_clientdata(client);\r\nfree_irq(client->irq, data);\r\nif (data->poweron)\r\ndata->poweron(false);\r\ninput_unregister_device(data->input_dev);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic void mcs_touchkey_shutdown(struct i2c_client *client)\r\n{\r\nstruct mcs_touchkey_data *data = i2c_get_clientdata(client);\r\nif (data->poweron)\r\ndata->poweron(false);\r\n}\r\nstatic int mcs_touchkey_suspend(struct device *dev)\r\n{\r\nstruct mcs_touchkey_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\ndisable_irq(client->irq);\r\nif (data->poweron)\r\ndata->poweron(false);\r\nreturn 0;\r\n}\r\nstatic int mcs_touchkey_resume(struct device *dev)\r\n{\r\nstruct mcs_touchkey_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nif (data->poweron)\r\ndata->poweron(true);\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}
