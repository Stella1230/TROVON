static inline struct pic32_gpio_bank *irqd_to_bank(struct irq_data *d)\r\n{\r\nreturn gpiochip_get_data(irq_data_get_irq_chip_data(d));\r\n}\r\nstatic inline struct pic32_gpio_bank *pctl_to_bank(struct pic32_pinctrl *pctl,\r\nunsigned pin)\r\n{\r\nreturn &pctl->gpio_banks[pin / PINS_PER_BANK];\r\n}\r\nstatic int pic32_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct pic32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->ngroups;\r\n}\r\nstatic const char *pic32_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct pic32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->groups[group].name;\r\n}\r\nstatic int pic32_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct pic32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = &pctl->groups[group].pin;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int pic32_pinmux_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct pic32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->nfunctions;\r\n}\r\nstatic const char *\r\npic32_pinmux_get_function_name(struct pinctrl_dev *pctldev, unsigned func)\r\n{\r\nstruct pic32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->functions[func].name;\r\n}\r\nstatic int pic32_pinmux_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned func,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct pic32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pctl->functions[func].groups;\r\n*num_groups = pctl->functions[func].ngroups;\r\nreturn 0;\r\n}\r\nstatic int pic32_pinmux_enable(struct pinctrl_dev *pctldev,\r\nunsigned func, unsigned group)\r\n{\r\nstruct pic32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct pic32_pin_group *pg = &pctl->groups[group];\r\nconst struct pic32_function *pf = &pctl->functions[func];\r\nconst char *fname = pf->name;\r\nstruct pic32_desc_function *functions = pg->functions;\r\nwhile (functions->name) {\r\nif (!strcmp(functions->name, fname)) {\r\ndev_dbg(pctl->dev,\r\n"setting function %s reg 0x%x = %d\n",\r\nfname, functions->muxreg, functions->muxval);\r\nwritel(functions->muxval, pctl->reg_base + functions->muxreg);\r\nreturn 0;\r\n}\r\nfunctions++;\r\n}\r\ndev_err(pctl->dev, "cannot mux pin %u to function %u\n", group, func);\r\nreturn -EINVAL;\r\n}\r\nstatic int pic32_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct pic32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pic32_gpio_bank *bank = gpiochip_get_data(range->gc);\r\nu32 mask = BIT(offset - bank->gpio_chip.base);\r\ndev_dbg(pctl->dev, "requesting gpio %d in bank %d with mask 0x%x\n",\r\noffset, bank->gpio_chip.base, mask);\r\nwritel(mask, bank->reg_base + PIC32_CLR(ANSEL_REG));\r\nreturn 0;\r\n}\r\nstatic int pic32_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct pic32_gpio_bank *bank = gpiochip_get_data(chip);\r\nu32 mask = BIT(offset);\r\nwritel(mask, bank->reg_base + PIC32_SET(TRIS_REG));\r\nreturn 0;\r\n}\r\nstatic int pic32_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pic32_gpio_bank *bank = gpiochip_get_data(chip);\r\nreturn !!(readl(bank->reg_base + PORT_REG) & BIT(offset));\r\n}\r\nstatic void pic32_gpio_set(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct pic32_gpio_bank *bank = gpiochip_get_data(chip);\r\nu32 mask = BIT(offset);\r\nif (value)\r\nwritel(mask, bank->reg_base + PIC32_SET(PORT_REG));\r\nelse\r\nwritel(mask, bank->reg_base + PIC32_CLR(PORT_REG));\r\n}\r\nstatic int pic32_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct pic32_gpio_bank *bank = gpiochip_get_data(chip);\r\nu32 mask = BIT(offset);\r\npic32_gpio_set(chip, offset, value);\r\nwritel(mask, bank->reg_base + PIC32_CLR(TRIS_REG));\r\nreturn 0;\r\n}\r\nstatic int pic32_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset, bool input)\r\n{\r\nstruct gpio_chip *chip = range->gc;\r\nif (input)\r\npic32_gpio_direction_input(chip, offset);\r\nelse\r\npic32_gpio_direction_output(chip, offset, 0);\r\nreturn 0;\r\n}\r\nstatic int pic32_pinconf_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nstruct pic32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pic32_gpio_bank *bank = pctl_to_bank(pctl, pin);\r\nunsigned param = pinconf_to_config_param(*config);\r\nu32 mask = BIT(pin - bank->gpio_chip.base);\r\nu32 arg;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\narg = !!(readl(bank->reg_base + CNPU_REG) & mask);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\narg = !!(readl(bank->reg_base + CNPD_REG) & mask);\r\nbreak;\r\ncase PIN_CONFIG_MICROCHIP_DIGITAL:\r\narg = !(readl(bank->reg_base + ANSEL_REG) & mask);\r\nbreak;\r\ncase PIN_CONFIG_MICROCHIP_ANALOG:\r\narg = !!(readl(bank->reg_base + ANSEL_REG) & mask);\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\narg = !!(readl(bank->reg_base + ODCU_REG) & mask);\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\narg = !!(readl(bank->reg_base + TRIS_REG) & mask);\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\narg = !(readl(bank->reg_base + TRIS_REG) & mask);\r\nbreak;\r\ndefault:\r\ndev_err(pctl->dev, "Property %u not supported\n", param);\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int pic32_pinconf_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct pic32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pic32_gpio_bank *bank = pctl_to_bank(pctl, pin);\r\nunsigned param;\r\nu32 arg;\r\nunsigned int i;\r\nu32 offset = pin - bank->gpio_chip.base;\r\nu32 mask = BIT(offset);\r\ndev_dbg(pctl->dev, "setting pin %d bank %d mask 0x%x\n",\r\npin, bank->gpio_chip.base, mask);\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ndev_dbg(pctl->dev, " pullup\n");\r\nwritel(mask, bank->reg_base +PIC32_SET(CNPU_REG));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ndev_dbg(pctl->dev, " pulldown\n");\r\nwritel(mask, bank->reg_base + PIC32_SET(CNPD_REG));\r\nbreak;\r\ncase PIN_CONFIG_MICROCHIP_DIGITAL:\r\ndev_dbg(pctl->dev, " digital\n");\r\nwritel(mask, bank->reg_base + PIC32_CLR(ANSEL_REG));\r\nbreak;\r\ncase PIN_CONFIG_MICROCHIP_ANALOG:\r\ndev_dbg(pctl->dev, " analog\n");\r\nwritel(mask, bank->reg_base + PIC32_SET(ANSEL_REG));\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\ndev_dbg(pctl->dev, " opendrain\n");\r\nwritel(mask, bank->reg_base + PIC32_SET(ODCU_REG));\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\npic32_gpio_direction_input(&bank->gpio_chip, offset);\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\npic32_gpio_direction_output(&bank->gpio_chip,\r\noffset, arg);\r\nbreak;\r\ndefault:\r\ndev_err(pctl->dev, "Property %u not supported\n",\r\nparam);\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pic32_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pic32_gpio_bank *bank = gpiochip_get_data(chip);\r\nreturn !!(readl(bank->reg_base + TRIS_REG) & BIT(offset));\r\n}\r\nstatic void pic32_gpio_irq_ack(struct irq_data *data)\r\n{\r\nstruct pic32_gpio_bank *bank = irqd_to_bank(data);\r\nwritel(0, bank->reg_base + CNF_REG);\r\n}\r\nstatic void pic32_gpio_irq_mask(struct irq_data *data)\r\n{\r\nstruct pic32_gpio_bank *bank = irqd_to_bank(data);\r\nwritel(BIT(PIC32_CNCON_ON), bank->reg_base + PIC32_CLR(CNCON_REG));\r\n}\r\nstatic void pic32_gpio_irq_unmask(struct irq_data *data)\r\n{\r\nstruct pic32_gpio_bank *bank = irqd_to_bank(data);\r\nwritel(BIT(PIC32_CNCON_ON), bank->reg_base + PIC32_SET(CNCON_REG));\r\n}\r\nstatic unsigned int pic32_gpio_irq_startup(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\npic32_gpio_direction_input(chip, data->hwirq);\r\npic32_gpio_irq_unmask(data);\r\nreturn 0;\r\n}\r\nstatic int pic32_gpio_irq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nstruct pic32_gpio_bank *bank = irqd_to_bank(data);\r\nu32 mask = BIT(data->hwirq);\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nwritel(mask, bank->reg_base + PIC32_SET(CNEN_REG));\r\nwritel(mask, bank->reg_base + PIC32_CLR(CNNE_REG));\r\nwritel(BIT(PIC32_CNCON_EDGE), bank->reg_base + PIC32_SET(CNCON_REG));\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nwritel(mask, bank->reg_base + PIC32_CLR(CNEN_REG));\r\nwritel(mask, bank->reg_base + PIC32_SET(CNNE_REG));\r\nwritel(BIT(PIC32_CNCON_EDGE), bank->reg_base + PIC32_SET(CNCON_REG));\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nwritel(mask, bank->reg_base + PIC32_SET(CNEN_REG));\r\nwritel(mask, bank->reg_base + PIC32_SET(CNNE_REG));\r\nwritel(BIT(PIC32_CNCON_EDGE), bank->reg_base + PIC32_SET(CNCON_REG));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nirq_set_handler_locked(data, handle_edge_irq);\r\nreturn 0;\r\n}\r\nstatic u32 pic32_gpio_get_pending(struct gpio_chip *gc, unsigned long status)\r\n{\r\nstruct pic32_gpio_bank *bank = gpiochip_get_data(gc);\r\nu32 pending = 0;\r\nu32 cnen_rise, cnne_fall;\r\nu32 pin;\r\ncnen_rise = readl(bank->reg_base + CNEN_REG);\r\ncnne_fall = readl(bank->reg_base + CNNE_REG);\r\nfor_each_set_bit(pin, &status, BITS_PER_LONG) {\r\nu32 mask = BIT(pin);\r\nif ((mask & cnen_rise) || (mask && cnne_fall))\r\npending |= mask;\r\n}\r\nreturn pending;\r\n}\r\nstatic void pic32_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct pic32_gpio_bank *bank = gpiochip_get_data(gc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned long pending;\r\nunsigned int pin;\r\nu32 stat;\r\nchained_irq_enter(chip, desc);\r\nstat = readl(bank->reg_base + CNF_REG);\r\npending = pic32_gpio_get_pending(gc, stat);\r\nfor_each_set_bit(pin, &pending, BITS_PER_LONG)\r\ngeneric_handle_irq(irq_linear_revmap(gc->irqdomain, pin));\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int pic32_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct pic32_pinctrl *pctl;\r\nstruct resource *res;\r\nint ret;\r\npctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\r\nif (!pctl)\r\nreturn -ENOMEM;\r\npctl->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, pctl);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npctl->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pctl->reg_base))\r\nreturn PTR_ERR(pctl->reg_base);\r\npctl->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pctl->clk)) {\r\nret = PTR_ERR(pctl->clk);\r\ndev_err(&pdev->dev, "clk get failed\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(pctl->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "clk enable failed\n");\r\nreturn ret;\r\n}\r\npctl->pins = pic32_pins;\r\npctl->npins = ARRAY_SIZE(pic32_pins);\r\npctl->functions = pic32_functions;\r\npctl->nfunctions = ARRAY_SIZE(pic32_functions);\r\npctl->groups = pic32_groups;\r\npctl->ngroups = ARRAY_SIZE(pic32_groups);\r\npctl->gpio_banks = pic32_gpio_banks;\r\npctl->nbanks = ARRAY_SIZE(pic32_gpio_banks);\r\npic32_pinctrl_desc.pins = pctl->pins;\r\npic32_pinctrl_desc.npins = pctl->npins;\r\npic32_pinctrl_desc.custom_params = pic32_mpp_bindings;\r\npic32_pinctrl_desc.num_custom_params = ARRAY_SIZE(pic32_mpp_bindings);\r\npctl->pctldev = devm_pinctrl_register(&pdev->dev, &pic32_pinctrl_desc,\r\npctl);\r\nif (IS_ERR(pctl->pctldev)) {\r\ndev_err(&pdev->dev, "Failed to register pinctrl device\n");\r\nreturn PTR_ERR(pctl->pctldev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pic32_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct pic32_gpio_bank *bank;\r\nu32 id;\r\nint irq, ret;\r\nstruct resource *res;\r\nif (of_property_read_u32(np, "microchip,gpio-bank", &id)) {\r\ndev_err(&pdev->dev, "microchip,gpio-bank property not found\n");\r\nreturn -EINVAL;\r\n}\r\nif (id >= ARRAY_SIZE(pic32_gpio_banks)) {\r\ndev_err(&pdev->dev, "invalid microchip,gpio-bank property\n");\r\nreturn -EINVAL;\r\n}\r\nbank = &pic32_gpio_banks[id];\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbank->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(bank->reg_base))\r\nreturn PTR_ERR(bank->reg_base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "irq get failed\n");\r\nreturn irq;\r\n}\r\nbank->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(bank->clk)) {\r\nret = PTR_ERR(bank->clk);\r\ndev_err(&pdev->dev, "clk get failed\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(bank->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "clk enable failed\n");\r\nreturn ret;\r\n}\r\nbank->gpio_chip.parent = &pdev->dev;\r\nbank->gpio_chip.of_node = np;\r\nret = gpiochip_add_data(&bank->gpio_chip, bank);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to add GPIO chip %u: %d\n",\r\nid, ret);\r\nreturn ret;\r\n}\r\nret = gpiochip_irqchip_add(&bank->gpio_chip, &bank->irq_chip,\r\n0, handle_level_irq, IRQ_TYPE_NONE);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to add IRQ chip %u: %d\n",\r\nid, ret);\r\ngpiochip_remove(&bank->gpio_chip);\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(&bank->gpio_chip, &bank->irq_chip,\r\nirq, pic32_gpio_irq_handler);\r\nreturn 0;\r\n}\r\nstatic int __init pic32_gpio_register(void)\r\n{\r\nreturn platform_driver_register(&pic32_gpio_driver);\r\n}\r\nstatic int __init pic32_pinctrl_register(void)\r\n{\r\nreturn platform_driver_register(&pic32_pinctrl_driver);\r\n}
