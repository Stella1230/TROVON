void mlx5e_fill_hwstamp(struct mlx5e_tstamp *tstamp, u64 timestamp,\r\nstruct skb_shared_hwtstamps *hwts)\r\n{\r\nu64 nsec;\r\nread_lock(&tstamp->lock);\r\nnsec = timecounter_cyc2time(&tstamp->clock, timestamp);\r\nread_unlock(&tstamp->lock);\r\nhwts->hwtstamp = ns_to_ktime(nsec);\r\n}\r\nstatic cycle_t mlx5e_read_internal_timer(const struct cyclecounter *cc)\r\n{\r\nstruct mlx5e_tstamp *tstamp = container_of(cc, struct mlx5e_tstamp,\r\ncycles);\r\nreturn mlx5_read_internal_timer(tstamp->mdev) & cc->mask;\r\n}\r\nstatic void mlx5e_timestamp_overflow(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct mlx5e_tstamp *tstamp = container_of(dwork, struct mlx5e_tstamp,\r\noverflow_work);\r\nunsigned long flags;\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\ntimecounter_read(&tstamp->clock);\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\nschedule_delayed_work(&tstamp->overflow_work, tstamp->overflow_period);\r\n}\r\nint mlx5e_hwstamp_set(struct net_device *dev, struct ifreq *ifr)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(dev);\r\nstruct hwtstamp_config config;\r\nif (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz))\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nswitch (config.tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\ncase HWTSTAMP_TX_ON:\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nswitch (config.rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\nmlx5e_modify_rx_cqe_compression(priv, priv->params.rx_cqe_compress_admin);\r\nbreak;\r\ncase HWTSTAMP_FILTER_ALL:\r\ncase HWTSTAMP_FILTER_SOME:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\nmlx5e_modify_rx_cqe_compression(priv, false);\r\nconfig.rx_filter = HWTSTAMP_FILTER_ALL;\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nmemcpy(&priv->tstamp.hwtstamp_config, &config, sizeof(config));\r\nreturn copy_to_user(ifr->ifr_data, &config,\r\nsizeof(config)) ? -EFAULT : 0;\r\n}\r\nint mlx5e_hwstamp_get(struct net_device *dev, struct ifreq *ifr)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(dev);\r\nstruct hwtstamp_config *cfg = &priv->tstamp.hwtstamp_config;\r\nif (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz))\r\nreturn -EOPNOTSUPP;\r\nreturn copy_to_user(ifr->ifr_data, cfg, sizeof(*cfg)) ? -EFAULT : 0;\r\n}\r\nstatic int mlx5e_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct mlx5e_tstamp *tstamp = container_of(ptp, struct mlx5e_tstamp,\r\nptp_info);\r\nu64 ns = timespec64_to_ns(ts);\r\nunsigned long flags;\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\ntimecounter_init(&tstamp->clock, &tstamp->cycles, ns);\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx5e_ptp_gettime(struct ptp_clock_info *ptp,\r\nstruct timespec64 *ts)\r\n{\r\nstruct mlx5e_tstamp *tstamp = container_of(ptp, struct mlx5e_tstamp,\r\nptp_info);\r\nu64 ns;\r\nunsigned long flags;\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\nns = timecounter_read(&tstamp->clock);\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int mlx5e_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct mlx5e_tstamp *tstamp = container_of(ptp, struct mlx5e_tstamp,\r\nptp_info);\r\nunsigned long flags;\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\ntimecounter_adjtime(&tstamp->clock, delta);\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx5e_ptp_adjfreq(struct ptp_clock_info *ptp, s32 delta)\r\n{\r\nu64 adj;\r\nu32 diff;\r\nunsigned long flags;\r\nint neg_adj = 0;\r\nstruct mlx5e_tstamp *tstamp = container_of(ptp, struct mlx5e_tstamp,\r\nptp_info);\r\nif (delta < 0) {\r\nneg_adj = 1;\r\ndelta = -delta;\r\n}\r\nadj = tstamp->nominal_c_mult;\r\nadj *= delta;\r\ndiff = div_u64(adj, 1000000000ULL);\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\ntimecounter_read(&tstamp->clock);\r\ntstamp->cycles.mult = neg_adj ? tstamp->nominal_c_mult - diff :\r\ntstamp->nominal_c_mult + diff;\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void mlx5e_timestamp_init_config(struct mlx5e_tstamp *tstamp)\r\n{\r\ntstamp->hwtstamp_config.tx_type = HWTSTAMP_TX_OFF;\r\ntstamp->hwtstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\r\n}\r\nvoid mlx5e_timestamp_init(struct mlx5e_priv *priv)\r\n{\r\nstruct mlx5e_tstamp *tstamp = &priv->tstamp;\r\nu64 ns;\r\nu64 frac = 0;\r\nu32 dev_freq;\r\nmlx5e_timestamp_init_config(tstamp);\r\ndev_freq = MLX5_CAP_GEN(priv->mdev, device_frequency_khz);\r\nif (!dev_freq) {\r\nmlx5_core_warn(priv->mdev, "invalid device_frequency_khz, aborting HW clock init\n");\r\nreturn;\r\n}\r\nrwlock_init(&tstamp->lock);\r\ntstamp->cycles.read = mlx5e_read_internal_timer;\r\ntstamp->cycles.shift = MLX5E_CYCLES_SHIFT;\r\ntstamp->cycles.mult = clocksource_khz2mult(dev_freq,\r\ntstamp->cycles.shift);\r\ntstamp->nominal_c_mult = tstamp->cycles.mult;\r\ntstamp->cycles.mask = CLOCKSOURCE_MASK(41);\r\ntstamp->mdev = priv->mdev;\r\ntimecounter_init(&tstamp->clock, &tstamp->cycles,\r\nktime_to_ns(ktime_get_real()));\r\nns = cyclecounter_cyc2ns(&tstamp->cycles, tstamp->cycles.mask,\r\nfrac, &frac);\r\ndo_div(ns, NSEC_PER_SEC / 2 / HZ);\r\ntstamp->overflow_period = ns;\r\nINIT_DELAYED_WORK(&tstamp->overflow_work, mlx5e_timestamp_overflow);\r\nif (tstamp->overflow_period)\r\nschedule_delayed_work(&tstamp->overflow_work, 0);\r\nelse\r\nmlx5_core_warn(priv->mdev, "invalid overflow period, overflow_work is not scheduled\n");\r\ntstamp->ptp_info = mlx5e_ptp_clock_info;\r\nsnprintf(tstamp->ptp_info.name, 16, "mlx5 ptp");\r\ntstamp->ptp = ptp_clock_register(&tstamp->ptp_info,\r\n&priv->mdev->pdev->dev);\r\nif (IS_ERR_OR_NULL(tstamp->ptp)) {\r\nmlx5_core_warn(priv->mdev, "ptp_clock_register failed %ld\n",\r\nPTR_ERR(tstamp->ptp));\r\ntstamp->ptp = NULL;\r\n}\r\n}\r\nvoid mlx5e_timestamp_cleanup(struct mlx5e_priv *priv)\r\n{\r\nstruct mlx5e_tstamp *tstamp = &priv->tstamp;\r\nif (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz))\r\nreturn;\r\nif (priv->tstamp.ptp) {\r\nptp_clock_unregister(priv->tstamp.ptp);\r\npriv->tstamp.ptp = NULL;\r\n}\r\ncancel_delayed_work_sync(&tstamp->overflow_work);\r\n}
