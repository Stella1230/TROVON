static void dwmac4_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)\r\n{\r\nu32 value = readl(ioaddr + DMA_SYS_BUS_MODE);\r\nint i;\r\npr_info("dwmac4: Master AXI performs %s burst length\n",\r\n(value & DMA_SYS_BUS_FB) ? "fixed" : "any");\r\nif (axi->axi_lpi_en)\r\nvalue |= DMA_AXI_EN_LPI;\r\nif (axi->axi_xit_frm)\r\nvalue |= DMA_AXI_LPI_XIT_FRM;\r\nvalue |= (axi->axi_wr_osr_lmt & DMA_AXI_OSR_MAX) <<\r\nDMA_AXI_WR_OSR_LMT_SHIFT;\r\nvalue |= (axi->axi_rd_osr_lmt & DMA_AXI_OSR_MAX) <<\r\nDMA_AXI_RD_OSR_LMT_SHIFT;\r\nfor (i = 0; i < AXI_BLEN; i++) {\r\nswitch (axi->axi_blen[i]) {\r\ncase 256:\r\nvalue |= DMA_AXI_BLEN256;\r\nbreak;\r\ncase 128:\r\nvalue |= DMA_AXI_BLEN128;\r\nbreak;\r\ncase 64:\r\nvalue |= DMA_AXI_BLEN64;\r\nbreak;\r\ncase 32:\r\nvalue |= DMA_AXI_BLEN32;\r\nbreak;\r\ncase 16:\r\nvalue |= DMA_AXI_BLEN16;\r\nbreak;\r\ncase 8:\r\nvalue |= DMA_AXI_BLEN8;\r\nbreak;\r\ncase 4:\r\nvalue |= DMA_AXI_BLEN4;\r\nbreak;\r\n}\r\n}\r\nwritel(value, ioaddr + DMA_SYS_BUS_MODE);\r\n}\r\nstatic void dwmac4_dma_init_channel(void __iomem *ioaddr, int pbl,\r\nu32 dma_tx_phy, u32 dma_rx_phy,\r\nu32 channel)\r\n{\r\nu32 value;\r\nvalue = readl(ioaddr + DMA_CHAN_CONTROL(channel));\r\nvalue = value | DMA_BUS_MODE_PBL;\r\nwritel(value, ioaddr + DMA_CHAN_CONTROL(channel));\r\nvalue = readl(ioaddr + DMA_CHAN_TX_CONTROL(channel));\r\nvalue = value | (pbl << DMA_BUS_MODE_PBL_SHIFT);\r\nwritel(value, ioaddr + DMA_CHAN_TX_CONTROL(channel));\r\nvalue = readl(ioaddr + DMA_CHAN_RX_CONTROL(channel));\r\nvalue = value | (pbl << DMA_BUS_MODE_RPBL_SHIFT);\r\nwritel(value, ioaddr + DMA_CHAN_RX_CONTROL(channel));\r\nwritel(DMA_CHAN_INTR_DEFAULT_MASK, ioaddr + DMA_CHAN_INTR_ENA(channel));\r\nwritel(dma_tx_phy, ioaddr + DMA_CHAN_TX_BASE_ADDR(channel));\r\nwritel(dma_rx_phy, ioaddr + DMA_CHAN_RX_BASE_ADDR(channel));\r\n}\r\nstatic void dwmac4_dma_init(void __iomem *ioaddr, int pbl, int fb, int mb,\r\nint aal, u32 dma_tx, u32 dma_rx, int atds)\r\n{\r\nu32 value = readl(ioaddr + DMA_SYS_BUS_MODE);\r\nint i;\r\nif (fb)\r\nvalue |= DMA_SYS_BUS_FB;\r\nif (mb)\r\nvalue |= DMA_SYS_BUS_MB;\r\nif (aal)\r\nvalue |= DMA_SYS_BUS_AAL;\r\nwritel(value, ioaddr + DMA_SYS_BUS_MODE);\r\nfor (i = 0; i < DMA_CHANNEL_NB_MAX; i++)\r\ndwmac4_dma_init_channel(ioaddr, pbl, dma_tx, dma_rx, i);\r\n}\r\nstatic void _dwmac4_dump_dma_regs(void __iomem *ioaddr, u32 channel)\r\n{\r\npr_debug(" Channel %d\n", channel);\r\npr_debug("\tDMA_CHAN_CONTROL, offset: 0x%x, val: 0x%x\n", 0,\r\nreadl(ioaddr + DMA_CHAN_CONTROL(channel)));\r\npr_debug("\tDMA_CHAN_TX_CONTROL, offset: 0x%x, val: 0x%x\n", 0x4,\r\nreadl(ioaddr + DMA_CHAN_TX_CONTROL(channel)));\r\npr_debug("\tDMA_CHAN_RX_CONTROL, offset: 0x%x, val: 0x%x\n", 0x8,\r\nreadl(ioaddr + DMA_CHAN_RX_CONTROL(channel)));\r\npr_debug("\tDMA_CHAN_TX_BASE_ADDR, offset: 0x%x, val: 0x%x\n", 0x14,\r\nreadl(ioaddr + DMA_CHAN_TX_BASE_ADDR(channel)));\r\npr_debug("\tDMA_CHAN_RX_BASE_ADDR, offset: 0x%x, val: 0x%x\n", 0x1c,\r\nreadl(ioaddr + DMA_CHAN_RX_BASE_ADDR(channel)));\r\npr_debug("\tDMA_CHAN_TX_END_ADDR, offset: 0x%x, val: 0x%x\n", 0x20,\r\nreadl(ioaddr + DMA_CHAN_TX_END_ADDR(channel)));\r\npr_debug("\tDMA_CHAN_RX_END_ADDR, offset: 0x%x, val: 0x%x\n", 0x28,\r\nreadl(ioaddr + DMA_CHAN_RX_END_ADDR(channel)));\r\npr_debug("\tDMA_CHAN_TX_RING_LEN, offset: 0x%x, val: 0x%x\n", 0x2c,\r\nreadl(ioaddr + DMA_CHAN_TX_RING_LEN(channel)));\r\npr_debug("\tDMA_CHAN_RX_RING_LEN, offset: 0x%x, val: 0x%x\n", 0x30,\r\nreadl(ioaddr + DMA_CHAN_RX_RING_LEN(channel)));\r\npr_debug("\tDMA_CHAN_INTR_ENA, offset: 0x%x, val: 0x%x\n", 0x34,\r\nreadl(ioaddr + DMA_CHAN_INTR_ENA(channel)));\r\npr_debug("\tDMA_CHAN_RX_WATCHDOG, offset: 0x%x, val: 0x%x\n", 0x38,\r\nreadl(ioaddr + DMA_CHAN_RX_WATCHDOG(channel)));\r\npr_debug("\tDMA_CHAN_SLOT_CTRL_STATUS, offset: 0x%x, val: 0x%x\n", 0x3c,\r\nreadl(ioaddr + DMA_CHAN_SLOT_CTRL_STATUS(channel)));\r\npr_debug("\tDMA_CHAN_CUR_TX_DESC, offset: 0x%x, val: 0x%x\n", 0x44,\r\nreadl(ioaddr + DMA_CHAN_CUR_TX_DESC(channel)));\r\npr_debug("\tDMA_CHAN_CUR_RX_DESC, offset: 0x%x, val: 0x%x\n", 0x4c,\r\nreadl(ioaddr + DMA_CHAN_CUR_RX_DESC(channel)));\r\npr_debug("\tDMA_CHAN_CUR_TX_BUF_ADDR, offset: 0x%x, val: 0x%x\n", 0x54,\r\nreadl(ioaddr + DMA_CHAN_CUR_TX_BUF_ADDR(channel)));\r\npr_debug("\tDMA_CHAN_CUR_RX_BUF_ADDR, offset: 0x%x, val: 0x%x\n", 0x5c,\r\nreadl(ioaddr + DMA_CHAN_CUR_RX_BUF_ADDR(channel)));\r\npr_debug("\tDMA_CHAN_STATUS, offset: 0x%x, val: 0x%x\n", 0x60,\r\nreadl(ioaddr + DMA_CHAN_STATUS(channel)));\r\n}\r\nstatic void dwmac4_dump_dma_regs(void __iomem *ioaddr)\r\n{\r\nint i;\r\npr_debug(" GMAC4 DMA registers\n");\r\nfor (i = 0; i < DMA_CHANNEL_NB_MAX; i++)\r\n_dwmac4_dump_dma_regs(ioaddr, i);\r\n}\r\nstatic void dwmac4_rx_watchdog(void __iomem *ioaddr, u32 riwt)\r\n{\r\nint i;\r\nfor (i = 0; i < DMA_CHANNEL_NB_MAX; i++)\r\nwritel(riwt, ioaddr + DMA_CHAN_RX_WATCHDOG(i));\r\n}\r\nstatic void dwmac4_dma_chan_op_mode(void __iomem *ioaddr, int txmode,\r\nint rxmode, u32 channel)\r\n{\r\nu32 mtl_tx_op, mtl_rx_op, mtl_rx_int;\r\nmtl_tx_op = readl(ioaddr + MTL_CHAN_TX_OP_MODE(channel));\r\nif (txmode == SF_DMA_MODE) {\r\npr_debug("GMAC: enable TX store and forward mode\n");\r\nmtl_tx_op |= MTL_OP_MODE_TSF;\r\n} else {\r\npr_debug("GMAC: disabling TX SF (threshold %d)\n", txmode);\r\nmtl_tx_op &= ~MTL_OP_MODE_TSF;\r\nmtl_tx_op &= MTL_OP_MODE_TTC_MASK;\r\nif (txmode <= 32)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_32;\r\nelse if (txmode <= 64)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_64;\r\nelse if (txmode <= 96)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_96;\r\nelse if (txmode <= 128)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_128;\r\nelse if (txmode <= 192)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_192;\r\nelse if (txmode <= 256)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_256;\r\nelse if (txmode <= 384)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_384;\r\nelse\r\nmtl_tx_op |= MTL_OP_MODE_TTC_512;\r\n}\r\nwritel(mtl_tx_op, ioaddr + MTL_CHAN_TX_OP_MODE(channel));\r\nmtl_rx_op = readl(ioaddr + MTL_CHAN_RX_OP_MODE(channel));\r\nif (rxmode == SF_DMA_MODE) {\r\npr_debug("GMAC: enable RX store and forward mode\n");\r\nmtl_rx_op |= MTL_OP_MODE_RSF;\r\n} else {\r\npr_debug("GMAC: disable RX SF mode (threshold %d)\n", rxmode);\r\nmtl_rx_op &= ~MTL_OP_MODE_RSF;\r\nmtl_rx_op &= MTL_OP_MODE_RTC_MASK;\r\nif (rxmode <= 32)\r\nmtl_rx_op |= MTL_OP_MODE_RTC_32;\r\nelse if (rxmode <= 64)\r\nmtl_rx_op |= MTL_OP_MODE_RTC_64;\r\nelse if (rxmode <= 96)\r\nmtl_rx_op |= MTL_OP_MODE_RTC_96;\r\nelse\r\nmtl_rx_op |= MTL_OP_MODE_RTC_128;\r\n}\r\nwritel(mtl_rx_op, ioaddr + MTL_CHAN_RX_OP_MODE(channel));\r\nmtl_rx_int = readl(ioaddr + MTL_CHAN_INT_CTRL(channel));\r\nwritel(mtl_rx_int | MTL_RX_OVERFLOW_INT_EN,\r\nioaddr + MTL_CHAN_INT_CTRL(channel));\r\n}\r\nstatic void dwmac4_dma_operation_mode(void __iomem *ioaddr, int txmode,\r\nint rxmode, int rxfifosz)\r\n{\r\ndwmac4_dma_chan_op_mode(ioaddr, txmode, rxmode, 0);\r\n}\r\nstatic void dwmac4_get_hw_feature(void __iomem *ioaddr,\r\nstruct dma_features *dma_cap)\r\n{\r\nu32 hw_cap = readl(ioaddr + GMAC_HW_FEATURE0);\r\ndma_cap->mbps_10_100 = (hw_cap & GMAC_HW_FEAT_MIISEL);\r\ndma_cap->mbps_1000 = (hw_cap & GMAC_HW_FEAT_GMIISEL) >> 1;\r\ndma_cap->half_duplex = (hw_cap & GMAC_HW_FEAT_HDSEL) >> 2;\r\ndma_cap->hash_filter = (hw_cap & GMAC_HW_FEAT_VLHASH) >> 4;\r\ndma_cap->multi_addr = (hw_cap & GMAC_HW_FEAT_ADDMAC) >> 18;\r\ndma_cap->pcs = (hw_cap & GMAC_HW_FEAT_PCSSEL) >> 3;\r\ndma_cap->sma_mdio = (hw_cap & GMAC_HW_FEAT_SMASEL) >> 5;\r\ndma_cap->pmt_remote_wake_up = (hw_cap & GMAC_HW_FEAT_RWKSEL) >> 6;\r\ndma_cap->pmt_magic_frame = (hw_cap & GMAC_HW_FEAT_MGKSEL) >> 7;\r\ndma_cap->rmon = (hw_cap & GMAC_HW_FEAT_MMCSEL) >> 8;\r\ndma_cap->atime_stamp = (hw_cap & GMAC_HW_FEAT_TSSEL) >> 12;\r\ndma_cap->eee = (hw_cap & GMAC_HW_FEAT_EEESEL) >> 13;\r\ndma_cap->tx_coe = (hw_cap & GMAC_HW_FEAT_TXCOSEL) >> 14;\r\ndma_cap->rx_coe = (hw_cap & GMAC_HW_FEAT_RXCOESEL) >> 16;\r\nhw_cap = readl(ioaddr + GMAC_HW_FEATURE1);\r\ndma_cap->av = (hw_cap & GMAC_HW_FEAT_AVSEL) >> 20;\r\ndma_cap->tsoen = (hw_cap & GMAC_HW_TSOEN) >> 18;\r\nhw_cap = readl(ioaddr + GMAC_HW_FEATURE2);\r\ndma_cap->number_rx_channel =\r\n((hw_cap & GMAC_HW_FEAT_RXCHCNT) >> 12) + 1;\r\ndma_cap->number_tx_channel =\r\n((hw_cap & GMAC_HW_FEAT_TXCHCNT) >> 18) + 1;\r\ndma_cap->time_stamp = 0;\r\n}\r\nstatic void dwmac4_enable_tso(void __iomem *ioaddr, bool en, u32 chan)\r\n{\r\nu32 value;\r\nif (en) {\r\nvalue = readl(ioaddr + DMA_CHAN_TX_CONTROL(chan));\r\nwritel(value | DMA_CONTROL_TSE,\r\nioaddr + DMA_CHAN_TX_CONTROL(chan));\r\n} else {\r\nvalue = readl(ioaddr + DMA_CHAN_TX_CONTROL(chan));\r\nwritel(value & ~DMA_CONTROL_TSE,\r\nioaddr + DMA_CHAN_TX_CONTROL(chan));\r\n}\r\n}
