static void _init_txservq(struct tx_servq *ptxservq)\r\n{\r\nINIT_LIST_HEAD(&ptxservq->tx_pending);\r\n_rtw_init_queue23a(&ptxservq->sta_pending);\r\nptxservq->qcnt = 0;\r\n}\r\nvoid _rtw_init_sta_xmit_priv23a(struct sta_xmit_priv *psta_xmitpriv)\r\n{\r\nspin_lock_init(&psta_xmitpriv->lock);\r\n_init_txservq(&psta_xmitpriv->be_q);\r\n_init_txservq(&psta_xmitpriv->bk_q);\r\n_init_txservq(&psta_xmitpriv->vi_q);\r\n_init_txservq(&psta_xmitpriv->vo_q);\r\nINIT_LIST_HEAD(&psta_xmitpriv->legacy_dz);\r\nINIT_LIST_HEAD(&psta_xmitpriv->apsd);\r\n}\r\nint _rtw_init_xmit_priv23a(struct xmit_priv *pxmitpriv,\r\nstruct rtw_adapter *padapter)\r\n{\r\nint i;\r\nstruct xmit_buf *pxmitbuf;\r\nstruct xmit_frame *pxframe;\r\nint res = _SUCCESS;\r\nu32 max_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ;\r\nu32 num_xmit_extbuf = NR_XMIT_EXTBUFF;\r\nspin_lock_init(&pxmitpriv->lock);\r\nspin_lock_init(&pxmitpriv->lock_sctx);\r\nsema_init(&pxmitpriv->xmit_sema, 0);\r\nsema_init(&pxmitpriv->terminate_xmitthread_sema, 0);\r\npxmitpriv->adapter = padapter;\r\n_rtw_init_queue23a(&pxmitpriv->be_pending);\r\n_rtw_init_queue23a(&pxmitpriv->bk_pending);\r\n_rtw_init_queue23a(&pxmitpriv->vi_pending);\r\n_rtw_init_queue23a(&pxmitpriv->vo_pending);\r\n_rtw_init_queue23a(&pxmitpriv->bm_pending);\r\n_rtw_init_queue23a(&pxmitpriv->free_xmit_queue);\r\nfor (i = 0; i < NR_XMITFRAME; i++) {\r\npxframe = kzalloc(sizeof(struct xmit_frame), GFP_KERNEL);\r\nif (!pxframe)\r\nbreak;\r\nINIT_LIST_HEAD(&pxframe->list);\r\npxframe->padapter = padapter;\r\npxframe->frame_tag = NULL_FRAMETAG;\r\nlist_add_tail(&pxframe->list,\r\n&pxmitpriv->free_xmit_queue.queue);\r\n}\r\npxmitpriv->free_xmitframe_cnt = i;\r\npxmitpriv->frag_len = MAX_FRAG_THRESHOLD;\r\n_rtw_init_queue23a(&pxmitpriv->free_xmitbuf_queue);\r\nINIT_LIST_HEAD(&pxmitpriv->xmitbuf_list);\r\n_rtw_init_queue23a(&pxmitpriv->pending_xmitbuf_queue);\r\nfor (i = 0; i < NR_XMITBUFF; i++) {\r\npxmitbuf = kzalloc(sizeof(struct xmit_buf), GFP_KERNEL);\r\nif (!pxmitbuf)\r\ngoto fail;\r\nINIT_LIST_HEAD(&pxmitbuf->list);\r\nINIT_LIST_HEAD(&pxmitbuf->list2);\r\npxmitbuf->padapter = padapter;\r\nres = rtw_os_xmit_resource_alloc23a(padapter, pxmitbuf,\r\n(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ));\r\nif (res == _FAIL) {\r\ngoto fail;\r\n}\r\nlist_add_tail(&pxmitbuf->list,\r\n&pxmitpriv->free_xmitbuf_queue.queue);\r\nlist_add_tail(&pxmitbuf->list2,\r\n&pxmitpriv->xmitbuf_list);\r\n}\r\npxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;\r\n_rtw_init_queue23a(&pxmitpriv->free_xframe_ext_queue);\r\nfor (i = 0; i < num_xmit_extbuf; i++) {\r\npxframe = kzalloc(sizeof(struct xmit_frame), GFP_KERNEL);\r\nif (!pxframe)\r\nbreak;\r\nINIT_LIST_HEAD(&pxframe->list);\r\npxframe->padapter = padapter;\r\npxframe->frame_tag = NULL_FRAMETAG;\r\npxframe->pkt = NULL;\r\npxframe->buf_addr = NULL;\r\npxframe->pxmitbuf = NULL;\r\npxframe->ext_tag = 1;\r\nlist_add_tail(&pxframe->list,\r\n&pxmitpriv->free_xframe_ext_queue.queue);\r\n}\r\npxmitpriv->free_xframe_ext_cnt = i;\r\n_rtw_init_queue23a(&pxmitpriv->free_xmit_extbuf_queue);\r\nINIT_LIST_HEAD(&pxmitpriv->xmitextbuf_list);\r\nfor (i = 0; i < num_xmit_extbuf; i++) {\r\npxmitbuf = kzalloc(sizeof(struct xmit_buf), GFP_KERNEL);\r\nif (!pxmitbuf)\r\ngoto fail;\r\nINIT_LIST_HEAD(&pxmitbuf->list);\r\nINIT_LIST_HEAD(&pxmitbuf->list2);\r\npxmitbuf->padapter = padapter;\r\nres = rtw_os_xmit_resource_alloc23a(padapter, pxmitbuf,\r\nmax_xmit_extbuf_size + XMITBUF_ALIGN_SZ);\r\nif (res == _FAIL) {\r\ngoto exit;\r\n}\r\nlist_add_tail(&pxmitbuf->list,\r\n&pxmitpriv->free_xmit_extbuf_queue.queue);\r\nlist_add_tail(&pxmitbuf->list2,\r\n&pxmitpriv->xmitextbuf_list);\r\n}\r\npxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf;\r\nrtw_alloc_hwxmits23a(padapter);\r\nrtw_init_hwxmits23a(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);\r\nfor (i = 0; i < 4; i ++)\r\npxmitpriv->wmm_para_seq[i] = i;\r\nsema_init(&pxmitpriv->tx_retevt, 0);\r\npxmitpriv->ack_tx = false;\r\nmutex_init(&pxmitpriv->ack_tx_mutex);\r\nrtw_sctx_init23a(&pxmitpriv->ack_tx_ops, 0);\r\ntasklet_init(&padapter->xmitpriv.xmit_tasklet,\r\n(void(*)(unsigned long))rtl8723au_xmit_tasklet,\r\n(unsigned long)padapter);\r\nexit:\r\nreturn res;\r\nfail:\r\ngoto exit;\r\n}\r\nvoid _rtw_free_xmit_priv23a(struct xmit_priv *pxmitpriv)\r\n{\r\nstruct rtw_adapter *padapter = pxmitpriv->adapter;\r\nstruct xmit_frame *pxframe, *ptmp;\r\nstruct xmit_buf *pxmitbuf, *ptmp2;\r\nlist_for_each_entry_safe(pxframe, ptmp,\r\n&pxmitpriv->free_xmit_queue.queue, list) {\r\nlist_del_init(&pxframe->list);\r\nrtw_os_xmit_complete23a(padapter, pxframe);\r\nkfree(pxframe);\r\n}\r\nlist_for_each_entry_safe(pxmitbuf, ptmp2,\r\n&pxmitpriv->xmitbuf_list, list2) {\r\nlist_del_init(&pxmitbuf->list2);\r\nrtw_os_xmit_resource_free23a(padapter, pxmitbuf);\r\nkfree(pxmitbuf);\r\n}\r\nlist_for_each_entry_safe(pxframe, ptmp,\r\n&pxmitpriv->free_xframe_ext_queue.queue,\r\nlist) {\r\nlist_del_init(&pxframe->list);\r\nrtw_os_xmit_complete23a(padapter, pxframe);\r\nkfree(pxframe);\r\n}\r\nlist_for_each_entry_safe(pxmitbuf, ptmp2,\r\n&pxmitpriv->xmitextbuf_list, list2) {\r\nlist_del_init(&pxmitbuf->list2);\r\nrtw_os_xmit_resource_free23a(padapter, pxmitbuf);\r\nkfree(pxmitbuf);\r\n}\r\nrtw_free_hwxmits23a(padapter);\r\nmutex_destroy(&pxmitpriv->ack_tx_mutex);\r\n}\r\nstatic void update_attrib_vcs_info(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nu32 sz;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct sta_info *psta = pattrib->psta;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nif (pattrib->psta) {\r\npsta = pattrib->psta;\r\n} else {\r\nDBG_8723A("%s, call rtw_get_stainfo23a()\n", __func__);\r\npsta = rtw_get_stainfo23a(&padapter->stapriv, &pattrib->ra[0]);\r\n}\r\nif (psta == NULL) {\r\nDBG_8723A("%s, psta == NUL\n", __func__);\r\nreturn;\r\n}\r\nif (!(psta->state &_FW_LINKED)) {\r\nDBG_8723A("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);\r\nreturn;\r\n}\r\nif (pattrib->nr_frags != 1)\r\nsz = padapter->xmitpriv.frag_len;\r\nelse\r\nsz = pattrib->last_txcmdsz;\r\nif (pmlmeext->cur_wireless_mode < WIRELESS_11_24N || padapter->registrypriv.wifi_spec) {\r\nif (sz > padapter->registrypriv.rts_thresh) {\r\npattrib->vcs_mode = RTS_CTS;\r\n} else {\r\nif (psta->rtsen)\r\npattrib->vcs_mode = RTS_CTS;\r\nelse if (psta->cts2self)\r\npattrib->vcs_mode = CTS_TO_SELF;\r\nelse\r\npattrib->vcs_mode = NONE_VCS;\r\n}\r\n} else {\r\nwhile (true) {\r\nif (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_ATHEROS &&\r\npattrib->ampdu_en &&\r\npadapter->securitypriv.dot11PrivacyAlgrthm ==\r\nWLAN_CIPHER_SUITE_CCMP) {\r\npattrib->vcs_mode = CTS_TO_SELF;\r\nbreak;\r\n}\r\nif (psta->rtsen || psta->cts2self) {\r\nif (psta->rtsen)\r\npattrib->vcs_mode = RTS_CTS;\r\nelse if (psta->cts2self)\r\npattrib->vcs_mode = CTS_TO_SELF;\r\nbreak;\r\n}\r\nif (pattrib->ht_en) {\r\nu8 HTOpMode = pmlmeinfo->HT_protection;\r\nif ((pmlmeext->cur_bwmode && (HTOpMode == 2 || HTOpMode == 3)) ||\r\n(!pmlmeext->cur_bwmode && HTOpMode == 3)) {\r\npattrib->vcs_mode = RTS_CTS;\r\nbreak;\r\n}\r\n}\r\nif (sz > padapter->registrypriv.rts_thresh) {\r\npattrib->vcs_mode = RTS_CTS;\r\nbreak;\r\n}\r\nif (pattrib->ampdu_en) {\r\npattrib->vcs_mode = RTS_CTS;\r\nbreak;\r\n}\r\npattrib->vcs_mode = NONE_VCS;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *psta)\r\n{\r\npattrib->mdata = 0;\r\npattrib->eosp = 0;\r\npattrib->triggered = 0;\r\npattrib->qos_en = psta->qos_option;\r\npattrib->raid = psta->raid;\r\npattrib->ht_en = psta->htpriv.ht_option;\r\npattrib->bwmode = psta->htpriv.bwmode;\r\npattrib->ch_offset = psta->htpriv.ch_offset;\r\npattrib->sgi = psta->htpriv.sgi;\r\npattrib->ampdu_en = false;\r\npattrib->retry_ctrl = false;\r\n}\r\nu8 qos_acm23a(u8 acm_mask, u8 priority)\r\n{\r\nu8 change_priority = priority;\r\nswitch (priority) {\r\ncase 0:\r\ncase 3:\r\nif (acm_mask & BIT(1))\r\nchange_priority = 1;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nif (acm_mask & BIT(2))\r\nchange_priority = 0;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nif (acm_mask & BIT(3))\r\nchange_priority = 5;\r\nbreak;\r\ndefault:\r\nDBG_8723A("qos_acm23a(): invalid pattrib->priority: %d!!!\n",\r\npriority);\r\nchange_priority = 0;\r\nbreak;\r\n}\r\nreturn change_priority;\r\n}\r\nstatic void set_qos(struct sk_buff *skb, struct pkt_attrib *pattrib)\r\n{\r\nu8 *pframe = skb->data;\r\nstruct iphdr *ip_hdr;\r\nu8 UserPriority = 0;\r\nif (pattrib->ether_type == ETH_P_IP) {\r\nip_hdr = (struct iphdr *)(pframe + ETH_HLEN);\r\nUserPriority = ip_hdr->tos >> 5;\r\n} else if (pattrib->ether_type == ETH_P_PAE) {\r\nUserPriority = 7;\r\n}\r\npattrib->priority = UserPriority;\r\npattrib->hdrlen = sizeof(struct ieee80211_qos_hdr);\r\npattrib->type = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_DATA;\r\n}\r\nstatic int update_attrib(struct rtw_adapter *padapter,\r\nstruct sk_buff *skb, struct pkt_attrib *pattrib)\r\n{\r\nstruct sta_info *psta = NULL;\r\nint bmcast;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nint res = _SUCCESS;\r\nstruct ethhdr *ehdr = (struct ethhdr *) skb->data;\r\npattrib->ether_type = ntohs(ehdr->h_proto);\r\nether_addr_copy(pattrib->dst, ehdr->h_dest);\r\nether_addr_copy(pattrib->src, ehdr->h_source);\r\npattrib->pctrl = 0;\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\r\nether_addr_copy(pattrib->ra, pattrib->dst);\r\nether_addr_copy(pattrib->ta, pattrib->src);\r\n} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\nether_addr_copy(pattrib->ra, get_bssid(pmlmepriv));\r\nether_addr_copy(pattrib->ta, pattrib->src);\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nether_addr_copy(pattrib->ra, pattrib->dst);\r\nether_addr_copy(pattrib->ta, get_bssid(pmlmepriv));\r\n}\r\npattrib->pktlen = skb->len - ETH_HLEN;\r\nif (pattrib->ether_type == ETH_P_IP) {\r\npattrib->dhcp_pkt = 0;\r\nif (pattrib->pktlen > 282 + 24) {\r\nif (pattrib->ether_type == ETH_P_IP) {\r\nu8 *pframe = skb->data;\r\npframe += ETH_HLEN;\r\nif ((pframe[21] == 68 && pframe[23] == 67) ||\r\n(pframe[21] == 67 && pframe[23] == 68)) {\r\nRT_TRACE(_module_rtl871x_xmit_c_,\r\n_drv_err_,\r\n"======================update_attrib: get DHCP Packet\n");\r\npattrib->dhcp_pkt = 1;\r\n}\r\n}\r\n}\r\n} else if (pattrib->ether_type == ETH_P_PAE) {\r\nDBG_8723A_LEVEL(_drv_always_, "send eapol packet\n");\r\n}\r\nif ((pattrib->ether_type == ETH_P_PAE) || (pattrib->dhcp_pkt == 1)) {\r\nrtw_set_scan_deny(padapter, 3000);\r\n}\r\nif ((pattrib->ether_type == ETH_P_ARP) ||\r\n(pattrib->ether_type == ETH_P_PAE) || (pattrib->dhcp_pkt == 1)) {\r\nrtw_lps_ctrl_wk_cmd23a(padapter, LPS_CTRL_SPECIAL_PACKET, 1);\r\n}\r\nbmcast = is_multicast_ether_addr(pattrib->ra);\r\nif (bmcast) {\r\npsta = rtw_get_bcmc_stainfo23a(padapter);\r\n} else {\r\npsta = rtw_get_stainfo23a(pstapriv, pattrib->ra);\r\nif (psta == NULL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,\r\n"update_attrib => get sta_info fail, ra:%pM\n",\r\npattrib->ra);\r\nres = _FAIL;\r\ngoto exit;\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) &&\r\n(!(psta->state & _FW_LINKED))) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\n}\r\nif (psta) {\r\npattrib->mac_id = psta->mac_id;\r\npattrib->psta = psta;\r\n} else {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,\r\n"update_attrib => get sta_info fail, ra:%pM\n",\r\npattrib->ra);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npattrib->ack_policy = 0;\r\npattrib->pkt_hdrlen = ETH_HLEN;\r\npattrib->hdrlen = sizeof(struct ieee80211_hdr_3addr);\r\npattrib->type = IEEE80211_FTYPE_DATA;\r\npattrib->priority = 0;\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE | WIFI_ADHOC_STATE |\r\nWIFI_ADHOC_MASTER_STATE)) {\r\nif (psta->qos_option)\r\nset_qos(skb, pattrib);\r\n} else {\r\nif (pmlmepriv->qos_option) {\r\nset_qos(skb, pattrib);\r\nif (pmlmepriv->acm_mask != 0) {\r\npattrib->priority = qos_acm23a(pmlmepriv->acm_mask,\r\npattrib->priority);\r\n}\r\n}\r\n}\r\nif (psta->ieee8021x_blocked == true) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"psta->ieee8021x_blocked == true\n");\r\npattrib->encrypt = 0;\r\nif ((pattrib->ether_type != ETH_P_PAE) &&\r\n!check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"psta->ieee8021x_blocked == true, pattrib->ether_type(%.4x) != 0x888e\n",\r\npattrib->ether_type);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\n} else {\r\nGET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);\r\nswitch (psecuritypriv->dot11AuthAlgrthm) {\r\ncase dot11AuthAlgrthm_Open:\r\ncase dot11AuthAlgrthm_Shared:\r\ncase dot11AuthAlgrthm_Auto:\r\npattrib->key_idx =\r\n(u8)psecuritypriv->dot11PrivacyKeyIndex;\r\nbreak;\r\ncase dot11AuthAlgrthm_8021X:\r\nif (bmcast)\r\npattrib->key_idx =\r\n(u8)psecuritypriv->dot118021XGrpKeyid;\r\nelse\r\npattrib->key_idx = 0;\r\nbreak;\r\ndefault:\r\npattrib->key_idx = 0;\r\nbreak;\r\n}\r\n}\r\nswitch (pattrib->encrypt) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\npattrib->iv_len = IEEE80211_WEP_IV_LEN;\r\npattrib->icv_len = IEEE80211_WEP_ICV_LEN;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\npattrib->iv_len = IEEE80211_TKIP_IV_LEN;\r\npattrib->icv_len = IEEE80211_TKIP_ICV_LEN;\r\nif (!padapter->securitypriv.busetkipkey) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"padapter->securitypriv.busetkipkey(%d) == false drop packet\n",\r\npadapter->securitypriv.busetkipkey);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"pattrib->encrypt =%d (WLAN_CIPHER_SUITE_CCMP)\n",\r\npattrib->encrypt);\r\npattrib->iv_len = IEEE80211_CCMP_HDR_LEN;\r\npattrib->icv_len = IEEE80211_CCMP_MIC_LEN;\r\nbreak;\r\ndefault:\r\npattrib->iv_len = 0;\r\npattrib->icv_len = 0;\r\nbreak;\r\n}\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"update_attrib: encrypt =%d\n", pattrib->encrypt);\r\nif (pattrib->encrypt && !psecuritypriv->hw_decrypted) {\r\npattrib->bswenc = true;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"update_attrib: encrypt =%d bswenc = true\n",\r\npattrib->encrypt);\r\n} else {\r\npattrib->bswenc = false;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"update_attrib: bswenc = false\n");\r\n}\r\nupdate_attrib_phy_info(pattrib, psta);\r\nexit:\r\nreturn res;\r\n}\r\nstatic int xmitframe_addmic(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe) {\r\nstruct mic_data micdata;\r\nstruct sta_info *stainfo;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nint curfragnum, length;\r\nu8 *pframe, *payload, mic[8];\r\nu8 priority[4]= {0x0, 0x0, 0x0, 0x0};\r\nu8 hw_hdr_offset = 0;\r\nint bmcst = is_multicast_ether_addr(pattrib->ra);\r\nif (pattrib->psta) {\r\nstainfo = pattrib->psta;\r\n} else {\r\nDBG_8723A("%s, call rtw_get_stainfo23a()\n", __func__);\r\nstainfo = rtw_get_stainfo23a(&padapter->stapriv, &pattrib->ra[0]);\r\n}\r\nif (!stainfo) {\r\nDBG_8723A("%s, psta == NUL\n", __func__);\r\nreturn _FAIL;\r\n}\r\nif (!(stainfo->state &_FW_LINKED)) {\r\nDBG_8723A("%s, psta->state(0x%x) != _FW_LINKED\n",\r\n__func__, stainfo->state);\r\nreturn _FAIL;\r\n}\r\nhw_hdr_offset = TXDESC_OFFSET;\r\nif (pattrib->encrypt == WLAN_CIPHER_SUITE_TKIP) {\r\nif (stainfo) {\r\nu8 null_key[16]={0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0};\r\npframe = pxmitframe->buf_addr + hw_hdr_offset;\r\nif (bmcst) {\r\nif (!memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)) {\r\nreturn _FAIL;\r\n}\r\nrtw_secmicsetkey23a(&micdata, psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey);\r\n} else {\r\nif (!memcmp(&stainfo->dot11tkiptxmickey.skey[0],\r\nnull_key, 16)) {\r\nreturn _FAIL;\r\n}\r\nrtw_secmicsetkey23a(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);\r\n}\r\nif (pframe[1] & 1) {\r\nrtw_secmicappend23a(&micdata, &pframe[16], 6);\r\nif (pframe[1] & 2)\r\nrtw_secmicappend23a(&micdata,\r\n&pframe[24], 6);\r\nelse\r\nrtw_secmicappend23a(&micdata,\r\n&pframe[10], 6);\r\n} else {\r\nrtw_secmicappend23a(&micdata, &pframe[4], 6);\r\nif (pframe[1] & 2)\r\nrtw_secmicappend23a(&micdata,\r\n&pframe[16], 6);\r\nelse\r\nrtw_secmicappend23a(&micdata,\r\n&pframe[10], 6);\r\n}\r\nif (pattrib->qos_en)\r\npriority[0] = (u8)pxmitframe->attrib.priority;\r\nrtw_secmicappend23a(&micdata, &priority[0], 4);\r\npayload = pframe;\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags;\r\ncurfragnum++) {\r\npayload = PTR_ALIGN(payload, 4);\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"=== curfragnum =%d, pframe = 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",\r\ncurfragnum, *payload, *(payload + 1),\r\n*(payload + 2), *(payload + 3),\r\n*(payload + 4), *(payload + 5),\r\n*(payload + 6), *(payload + 7));\r\npayload = payload + pattrib->hdrlen +\r\npattrib->iv_len;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"curfragnum =%d pattrib->hdrlen =%d pattrib->iv_len =%d\n",\r\ncurfragnum,\r\npattrib->hdrlen, pattrib->iv_len);\r\nif ((curfragnum + 1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz -\r\npattrib->hdrlen -\r\npattrib->iv_len -\r\n((pattrib->bswenc) ?\r\npattrib->icv_len : 0);\r\nrtw_secmicappend23a(&micdata, payload,\r\nlength);\r\npayload = payload + length;\r\n} else {\r\nlength = pxmitpriv->frag_len -\r\npattrib->hdrlen -\r\npattrib->iv_len -\r\n((pattrib->bswenc) ?\r\npattrib->icv_len : 0);\r\nrtw_secmicappend23a(&micdata, payload,\r\nlength);\r\npayload = payload + length +\r\npattrib->icv_len;\r\nRT_TRACE(_module_rtl871x_xmit_c_,\r\n_drv_err_,\r\n"curfragnum =%d length =%d pattrib->icv_len =%d\n",\r\ncurfragnum, length,\r\npattrib->icv_len);\r\n}\r\n}\r\nrtw_secgetmic23a(&micdata, &mic[0]);\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"xmitframe_addmic: before add mic code!!\n");\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"xmitframe_addmic: pattrib->last_txcmdsz =%d!!!\n",\r\npattrib->last_txcmdsz);\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"xmitframe_addmic: mic[0]= 0x%.2x , mic[1]=0x%.2x , mic[2]= 0x%.2x , mic[3]= 0x%.2x\nmic[4]= 0x%.2x , mic[5]= 0x%.2x , mic[6]= 0x%.2x , mic[7]= 0x%.2x !!!!\n",\r\nmic[0], mic[1], mic[2], mic[3],\r\nmic[4], mic[5], mic[6], mic[7]);\r\nmemcpy(payload, &mic[0], 8);\r\npattrib->last_txcmdsz += 8;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"======== last pkt ========\n");\r\npayload = payload - pattrib->last_txcmdsz + 8;\r\nfor (curfragnum = 0; curfragnum < pattrib->last_txcmdsz;\r\ncurfragnum = curfragnum + 8) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"%.2x, %.2x, %.2x, %.2x, %.2x, %.2x, %.2x, %.2x\n",\r\n*(payload + curfragnum),\r\n*(payload + curfragnum + 1),\r\n*(payload + curfragnum + 2),\r\n*(payload + curfragnum + 3),\r\n*(payload + curfragnum + 4),\r\n*(payload + curfragnum + 5),\r\n*(payload + curfragnum + 6),\r\n*(payload + curfragnum + 7));\r\n}\r\n} else {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"xmitframe_addmic: rtw_get_stainfo23a ==NULL!!!\n");\r\n}\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic int xmitframe_swencrypt(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nif (pattrib->bswenc) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,\r\n"### xmitframe_swencrypt\n");\r\nswitch (pattrib->encrypt) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nrtw_wep_encrypt23a(padapter, pxmitframe);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nrtw_tkip_encrypt23a(padapter, pxmitframe);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nrtw_aes_encrypt23a(padapter, pxmitframe);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_,\r\n"### xmitframe_hwencrypt\n");\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic int rtw_make_wlanhdr(struct rtw_adapter *padapter, u8 *hdr,\r\nstruct pkt_attrib *pattrib)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr = (struct ieee80211_hdr *)hdr;\r\nstruct ieee80211_qos_hdr *qoshdr;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nu8 qos_option = false;\r\nint res = _SUCCESS;\r\nstruct sta_info *psta;\r\nint bmcst = is_multicast_ether_addr(pattrib->ra);\r\nif (pattrib->psta) {\r\npsta = pattrib->psta;\r\n} else {\r\nDBG_8723A("%s, call rtw_get_stainfo23a()\n", __func__);\r\nif (bmcst) {\r\npsta = rtw_get_bcmc_stainfo23a(padapter);\r\n} else {\r\npsta = rtw_get_stainfo23a(&padapter->stapriv, pattrib->ra);\r\n}\r\n}\r\nif (psta == NULL) {\r\nDBG_8723A("%s, psta == NUL\n", __func__);\r\nreturn _FAIL;\r\n}\r\nif (!(psta->state &_FW_LINKED)) {\r\nDBG_8723A("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);\r\nreturn _FAIL;\r\n}\r\nmemset(hdr, 0, WLANHDR_OFFSET);\r\npwlanhdr->frame_control = cpu_to_le16(pattrib->type);\r\nif (pattrib->type & IEEE80211_FTYPE_DATA) {\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\npwlanhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_TODS);\r\nether_addr_copy(pwlanhdr->addr1, get_bssid(pmlmepriv));\r\nether_addr_copy(pwlanhdr->addr2, pattrib->src);\r\nether_addr_copy(pwlanhdr->addr3, pattrib->dst);\r\nif (pmlmepriv->qos_option)\r\nqos_option = true;\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\npwlanhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_FROMDS);\r\nether_addr_copy(pwlanhdr->addr1, pattrib->dst);\r\nether_addr_copy(pwlanhdr->addr2, get_bssid(pmlmepriv));\r\nether_addr_copy(pwlanhdr->addr3, pattrib->src);\r\nif (psta->qos_option)\r\nqos_option = true;\r\n} else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\r\nether_addr_copy(pwlanhdr->addr1, pattrib->dst);\r\nether_addr_copy(pwlanhdr->addr2, pattrib->src);\r\nether_addr_copy(pwlanhdr->addr3, get_bssid(pmlmepriv));\r\nif (psta->qos_option)\r\nqos_option = true;\r\n}\r\nelse {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"fw_state:%x is not allowed to xmit frame\n",\r\nget_fwstate(pmlmepriv));\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nif (pattrib->mdata)\r\npwlanhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\nif (pattrib->encrypt)\r\npwlanhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_PROTECTED);\r\nif (qos_option) {\r\nqoshdr = (struct ieee80211_qos_hdr *)hdr;\r\nqoshdr->qos_ctrl = cpu_to_le16(\r\npattrib->priority & IEEE80211_QOS_CTL_TID_MASK);\r\nqoshdr->qos_ctrl |= cpu_to_le16(\r\n(pattrib->ack_policy << 5) &\r\nIEEE80211_QOS_CTL_ACK_POLICY_MASK);\r\nif (pattrib->eosp)\r\nqoshdr->qos_ctrl |=\r\ncpu_to_le16(IEEE80211_QOS_CTL_EOSP);\r\n}\r\nif (psta) {\r\npsta->sta_xmitpriv.txseq_tid[pattrib->priority]++;\r\npsta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;\r\npattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];\r\npwlanhdr->seq_ctrl = cpu_to_le16(IEEE80211_SN_TO_SEQ(\r\npattrib->seqnum));\r\nif (pattrib->ht_en && psta->htpriv.ampdu_enable) {\r\nif (pattrib->priority >= 16)\r\nprintk(KERN_WARNING "%s: Invalid "\r\n"pattrib->priority %i\n",\r\n__func__, pattrib->priority);\r\nif (psta->htpriv.agg_enable_bitmap &\r\nBIT(pattrib->priority))\r\npattrib->ampdu_en = true;\r\n}\r\nif (pattrib->ampdu_en) {\r\nu16 tx_seq;\r\ntx_seq = psta->BA_starting_seqctrl[pattrib->priority & 0x0f];\r\nif (SN_LESS(pattrib->seqnum, tx_seq)) {\r\npattrib->ampdu_en = false;\r\n} else if (SN_EQUAL(pattrib->seqnum, tx_seq)) {\r\npsta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (tx_seq+1)&0xfff;\r\npattrib->ampdu_en = true;\r\n} else {\r\npsta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (pattrib->seqnum+1)&0xfff;\r\npattrib->ampdu_en = true;\r\n}\r\n}\r\n}\r\n}\r\nexit:\r\nreturn res;\r\n}\r\ns32 rtw_txframes_pending23a(struct rtw_adapter *padapter)\r\n{\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nreturn (!list_empty(&pxmitpriv->be_pending.queue)) ||\r\n(!list_empty(&pxmitpriv->bk_pending.queue)) ||\r\n(!list_empty(&pxmitpriv->vi_pending.queue)) ||\r\n(!list_empty(&pxmitpriv->vo_pending.queue));\r\n}\r\ns32 rtw_txframes_sta_ac_pending23a(struct rtw_adapter *padapter,\r\nstruct pkt_attrib *pattrib)\r\n{\r\nstruct sta_info *psta;\r\nstruct tx_servq *ptxservq;\r\nint priority = pattrib->priority;\r\nif (pattrib->psta) {\r\npsta = pattrib->psta;\r\n} else {\r\nDBG_8723A("%s, call rtw_get_stainfo23a()\n", __func__);\r\npsta = rtw_get_stainfo23a(&padapter->stapriv, &pattrib->ra[0]);\r\n}\r\nif (psta == NULL) {\r\nDBG_8723A("%s, psta == NUL\n", __func__);\r\nreturn 0;\r\n}\r\nif (!(psta->state &_FW_LINKED)) {\r\nDBG_8723A("%s, psta->state(0x%x) != _FW_LINKED\n", __func__,\r\npsta->state);\r\nreturn 0;\r\n}\r\nswitch (priority) {\r\ncase 1:\r\ncase 2:\r\nptxservq = &psta->sta_xmitpriv.bk_q;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nptxservq = &psta->sta_xmitpriv.vi_q;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nptxservq = &psta->sta_xmitpriv.vo_q;\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nptxservq = &psta->sta_xmitpriv.be_q;\r\nbreak;\r\n}\r\nreturn ptxservq->qcnt;\r\n}\r\nstatic int rtw_put_snap(u8 *data, u16 h_proto)\r\n{\r\nif (h_proto == ETH_P_IPX || h_proto == ETH_P_AARP)\r\nether_addr_copy(data, bridge_tunnel_header);\r\nelse\r\nether_addr_copy(data, rfc1042_header);\r\ndata += ETH_ALEN;\r\nput_unaligned_be16(h_proto, data);\r\nreturn ETH_ALEN + sizeof(u16);\r\n}\r\nint rtw_xmitframe_coalesce23a(struct rtw_adapter *padapter, struct sk_buff *skb,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nstruct sta_info *psta;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct ieee80211_hdr *hdr;\r\ns32 frg_inx, frg_len, mpdu_len, llc_sz, mem_sz;\r\nu8 *pframe, *mem_start;\r\nu8 hw_hdr_offset;\r\nu8 *pbuf_start;\r\nu8 *pdata = skb->data;\r\nint data_len = skb->len;\r\ns32 bmcst = is_multicast_ether_addr(pattrib->ra);\r\nint res = _SUCCESS;\r\nif (pattrib->psta)\r\npsta = pattrib->psta;\r\nelse {\r\nDBG_8723A("%s, call rtw_get_stainfo23a()\n", __func__);\r\npsta = rtw_get_stainfo23a(&padapter->stapriv, pattrib->ra);\r\n}\r\nif (!psta) {\r\nDBG_8723A("%s, psta == NUL\n", __func__);\r\nreturn _FAIL;\r\n}\r\nif (!(psta->state &_FW_LINKED)) {\r\nDBG_8723A("%s, psta->state(0x%x) != _FW_LINKED\n",\r\n__func__, psta->state);\r\nreturn _FAIL;\r\n}\r\nif (!pxmitframe->buf_addr) {\r\nDBG_8723A("==> %s buf_addr == NULL\n", __func__);\r\nreturn _FAIL;\r\n}\r\npbuf_start = pxmitframe->buf_addr;\r\nhw_hdr_offset = TXDESC_OFFSET;\r\nmem_start = pbuf_start + hw_hdr_offset;\r\nif (rtw_make_wlanhdr(padapter, mem_start, pattrib) == _FAIL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"%s: rtw_make_wlanhdr fail; drop pkt\n", __func__);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdata += pattrib->pkt_hdrlen;\r\ndata_len -= pattrib->pkt_hdrlen;\r\nfrg_inx = 0;\r\nfrg_len = pxmitpriv->frag_len - 4;\r\nwhile (1) {\r\nllc_sz = 0;\r\nmpdu_len = frg_len;\r\npframe = mem_start;\r\nhdr = (struct ieee80211_hdr *)mem_start;\r\npframe += pattrib->hdrlen;\r\nmpdu_len -= pattrib->hdrlen;\r\nif (pattrib->iv_len) {\r\nif (psta) {\r\nswitch (pattrib->encrypt) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nWEP_IV(pattrib->iv, psta->dot11txpn,\r\npattrib->key_idx);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nif (bmcst)\r\nTKIP_IV(pattrib->iv,\r\npsta->dot11txpn,\r\npattrib->key_idx);\r\nelse\r\nTKIP_IV(pattrib->iv,\r\npsta->dot11txpn, 0);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nif (bmcst)\r\nAES_IV(pattrib->iv,\r\npsta->dot11txpn,\r\npattrib->key_idx);\r\nelse\r\nAES_IV(pattrib->iv,\r\npsta->dot11txpn, 0);\r\nbreak;\r\n}\r\n}\r\nmemcpy(pframe, pattrib->iv, pattrib->iv_len);\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_,\r\n"rtw_xmiaframe_coalesce23a: keyid =%d pattrib->iv[3]=%.2x pframe =%.2x %.2x %.2x %.2x\n",\r\npadapter->securitypriv.dot11PrivacyKeyIndex,\r\npattrib->iv[3], *pframe, *(pframe+1),\r\n*(pframe+2), *(pframe+3));\r\npframe += pattrib->iv_len;\r\nmpdu_len -= pattrib->iv_len;\r\n}\r\nif (frg_inx == 0) {\r\nllc_sz = rtw_put_snap(pframe, pattrib->ether_type);\r\npframe += llc_sz;\r\nmpdu_len -= llc_sz;\r\n}\r\nif (pattrib->icv_len > 0 && pattrib->bswenc)\r\nmpdu_len -= pattrib->icv_len;\r\nif (bmcst)\r\nmem_sz = min_t(s32, data_len, pattrib->pktlen);\r\nelse\r\nmem_sz = min_t(s32, data_len, mpdu_len);\r\nmemcpy(pframe, pdata, mem_sz);\r\npframe += mem_sz;\r\npdata += mem_sz;\r\ndata_len -= mem_sz;\r\nif ((pattrib->icv_len >0) && (pattrib->bswenc)) {\r\nmemcpy(pframe, pattrib->icv, pattrib->icv_len);\r\npframe += pattrib->icv_len;\r\n}\r\nfrg_inx++;\r\nif (bmcst || data_len <= 0) {\r\npattrib->nr_frags = frg_inx;\r\npattrib->last_txcmdsz = pattrib->hdrlen +\r\npattrib->iv_len +\r\n((pattrib->nr_frags == 1) ?\r\nllc_sz : 0) +\r\n((pattrib->bswenc) ?\r\npattrib->icv_len : 0) + mem_sz;\r\nhdr->frame_control &=\r\n~cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);\r\nbreak;\r\n} else {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"%s: There're still something in packet!\n",\r\n__func__);\r\n}\r\nhdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);\r\nmem_start = PTR_ALIGN(pframe, 4) + hw_hdr_offset;\r\nmemcpy(mem_start, pbuf_start + hw_hdr_offset, pattrib->hdrlen);\r\n}\r\nif (xmitframe_addmic(padapter, pxmitframe) == _FAIL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");\r\nDBG_8723A("xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nxmitframe_swencrypt(padapter, pxmitframe);\r\nif (bmcst == false)\r\nupdate_attrib_vcs_info(padapter, pxmitframe);\r\nelse\r\npattrib->vcs_mode = NONE_VCS;\r\nexit:\r\nreturn res;\r\n}\r\nvoid rtw_update_protection23a(struct rtw_adapter *padapter, u8 *ie, uint ie_len)\r\n{\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nuint protection;\r\nconst u8 *p;\r\nswitch (pregistrypriv->vrtl_carrier_sense) {\r\ncase DISABLE_VCS:\r\npxmitpriv->vcs = NONE_VCS;\r\nbreak;\r\ncase ENABLE_VCS:\r\nbreak;\r\ncase AUTO_VCS:\r\ndefault:\r\np = cfg80211_find_ie(WLAN_EID_ERP_INFO, ie, ie_len);\r\nif (!p)\r\npxmitpriv->vcs = NONE_VCS;\r\nelse {\r\nprotection = (*(p + 2)) & BIT(1);\r\nif (protection) {\r\nif (pregistrypriv->vcs_type == RTS_CTS)\r\npxmitpriv->vcs = RTS_CTS;\r\nelse\r\npxmitpriv->vcs = CTS_TO_SELF;\r\n} else {\r\npxmitpriv->vcs = NONE_VCS;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nvoid rtw_count_tx_stats23a(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, int sz)\r\n{\r\nstruct sta_info *psta = NULL;\r\nstruct stainfo_stats *pstats = NULL;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (pxmitframe->frame_tag == DATA_FRAMETAG) {\r\npxmitpriv->tx_bytes += sz;\r\npmlmepriv->LinkDetectInfo.NumTxOkInPeriod++;\r\npsta = pxmitframe->attrib.psta;\r\nif (psta) {\r\npstats = &psta->sta_stats;\r\npstats->tx_pkts++;\r\npstats->tx_bytes += sz;\r\n}\r\n}\r\n}\r\nstruct xmit_buf *rtw_alloc_xmitbuf23a_ext(struct xmit_priv *pxmitpriv)\r\n{\r\nunsigned long irqL;\r\nstruct xmit_buf *pxmitbuf = NULL;\r\nstruct list_head *phead;\r\nstruct rtw_queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;\r\nspin_lock_irqsave(&pfree_queue->lock, irqL);\r\nphead = get_list_head(pfree_queue);\r\nif (!list_empty(phead)) {\r\npxmitbuf = list_first_entry(phead, struct xmit_buf, list);\r\nlist_del_init(&pxmitbuf->list);\r\npxmitpriv->free_xmit_extbuf_cnt--;\r\npxmitbuf->priv_data = NULL;\r\npxmitbuf->ext_tag = true;\r\nif (pxmitbuf->sctx) {\r\nDBG_8723A("%s pxmitbuf->sctx is not NULL\n", __func__);\r\nrtw23a_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pfree_queue->lock, irqL);\r\nreturn pxmitbuf;\r\n}\r\nint rtw_free_xmitbuf_ext23a(struct xmit_priv *pxmitpriv,\r\nstruct xmit_buf *pxmitbuf)\r\n{\r\nunsigned long irqL;\r\nstruct rtw_queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;\r\nif (pxmitbuf == NULL)\r\nreturn _FAIL;\r\nspin_lock_irqsave(&pfree_queue->lock, irqL);\r\nlist_del_init(&pxmitbuf->list);\r\nlist_add_tail(&pxmitbuf->list, get_list_head(pfree_queue));\r\npxmitpriv->free_xmit_extbuf_cnt++;\r\nspin_unlock_irqrestore(&pfree_queue->lock, irqL);\r\nreturn _SUCCESS;\r\n}\r\nstruct xmit_buf *rtw_alloc_xmitbuf23a(struct xmit_priv *pxmitpriv)\r\n{\r\nunsigned long irqL;\r\nstruct xmit_buf *pxmitbuf = NULL;\r\nstruct list_head *phead;\r\nstruct rtw_queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;\r\nspin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);\r\nphead = get_list_head(pfree_xmitbuf_queue);\r\nif (!list_empty(phead)) {\r\npxmitbuf = list_first_entry(phead, struct xmit_buf, list);\r\nlist_del_init(&pxmitbuf->list);\r\npxmitpriv->free_xmitbuf_cnt--;\r\npxmitbuf->priv_data = NULL;\r\npxmitbuf->ext_tag = false;\r\npxmitbuf->flags = XMIT_VO_QUEUE;\r\nif (pxmitbuf->sctx) {\r\nDBG_8723A("%s pxmitbuf->sctx is not NULL\n", __func__);\r\nrtw23a_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);\r\nreturn pxmitbuf;\r\n}\r\nint rtw_free_xmitbuf23a(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)\r\n{\r\nunsigned long irqL;\r\nstruct rtw_queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;\r\nif (pxmitbuf == NULL)\r\nreturn _FAIL;\r\nif (pxmitbuf->sctx) {\r\nDBG_8723A("%s pxmitbuf->sctx is not NULL\n", __func__);\r\nrtw23a_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_FREE);\r\n}\r\nif (pxmitbuf->ext_tag) {\r\nrtw_free_xmitbuf_ext23a(pxmitpriv, pxmitbuf);\r\n} else {\r\nspin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);\r\nlist_del_init(&pxmitbuf->list);\r\nlist_add_tail(&pxmitbuf->list,\r\nget_list_head(pfree_xmitbuf_queue));\r\npxmitpriv->free_xmitbuf_cnt++;\r\nspin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic void rtw_init_xmitframe(struct xmit_frame *pxframe)\r\n{\r\nif (pxframe != NULL) {\r\npxframe->buf_addr = NULL;\r\npxframe->pxmitbuf = NULL;\r\nmemset(&pxframe->attrib, 0, sizeof(struct pkt_attrib));\r\npxframe->frame_tag = DATA_FRAMETAG;\r\npxframe->pkt = NULL;\r\npxframe->pkt_offset = 1;\r\npxframe->ack_report = 0;\r\n}\r\n}\r\nstatic struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv)\r\n{\r\nstruct xmit_frame *pxframe;\r\nstruct rtw_queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;\r\nspin_lock_bh(&pfree_xmit_queue->lock);\r\npxframe = list_first_entry_or_null(&pfree_xmit_queue->queue,\r\nstruct xmit_frame, list);\r\nif (!pxframe) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"rtw_alloc_xmitframe:%d\n",\r\npxmitpriv->free_xmitframe_cnt);\r\n} else {\r\nlist_del_init(&pxframe->list);\r\npxmitpriv->free_xmitframe_cnt--;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"rtw_alloc_xmitframe():free_xmitframe_cnt =%d\n",\r\npxmitpriv->free_xmitframe_cnt);\r\n}\r\nspin_unlock_bh(&pfree_xmit_queue->lock);\r\nrtw_init_xmitframe(pxframe);\r\nreturn pxframe;\r\n}\r\nstruct xmit_frame *rtw_alloc_xmitframe23a_ext(struct xmit_priv *pxmitpriv)\r\n{\r\nstruct xmit_frame *pxframe;\r\nstruct rtw_queue *queue = &pxmitpriv->free_xframe_ext_queue;\r\nspin_lock_bh(&queue->lock);\r\npxframe = list_first_entry_or_null(&queue->queue,\r\nstruct xmit_frame, list);\r\nif (!pxframe) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"rtw_alloc_xmitframe23a_ext:%d\n",\r\npxmitpriv->free_xframe_ext_cnt);\r\n} else {\r\nlist_del_init(&pxframe->list);\r\npxmitpriv->free_xframe_ext_cnt--;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"rtw_alloc_xmitframe23a_ext():free_xmitframe_cnt =%d\n",\r\npxmitpriv->free_xframe_ext_cnt);\r\n}\r\nspin_unlock_bh(&queue->lock);\r\nrtw_init_xmitframe(pxframe);\r\nreturn pxframe;\r\n}\r\ns32 rtw_free_xmitframe23a(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)\r\n{\r\nstruct rtw_queue *queue = NULL;\r\nstruct rtw_adapter *padapter = pxmitpriv->adapter;\r\nstruct sk_buff *pndis_pkt = NULL;\r\nif (pxmitframe == NULL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"====== rtw_free_xmitframe23a():pxmitframe == NULL!!!!!!!!!!\n");\r\ngoto exit;\r\n}\r\nif (pxmitframe->pkt) {\r\npndis_pkt = pxmitframe->pkt;\r\npxmitframe->pkt = NULL;\r\n}\r\nif (pxmitframe->ext_tag == 0)\r\nqueue = &pxmitpriv->free_xmit_queue;\r\nelse if (pxmitframe->ext_tag == 1)\r\nqueue = &pxmitpriv->free_xframe_ext_queue;\r\nif (!queue)\r\ngoto check_pkt_complete;\r\nspin_lock_bh(&queue->lock);\r\nlist_del_init(&pxmitframe->list);\r\nlist_add_tail(&pxmitframe->list, get_list_head(queue));\r\nif (pxmitframe->ext_tag == 0) {\r\npxmitpriv->free_xmitframe_cnt++;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_,\r\n"rtw_free_xmitframe23a():free_xmitframe_cnt =%d\n",\r\npxmitpriv->free_xmitframe_cnt);\r\n} else if (pxmitframe->ext_tag == 1) {\r\npxmitpriv->free_xframe_ext_cnt++;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_,\r\n"rtw_free_xmitframe23a():free_xframe_ext_cnt =%d\n",\r\npxmitpriv->free_xframe_ext_cnt);\r\n}\r\nspin_unlock_bh(&queue->lock);\r\ncheck_pkt_complete:\r\nif (pndis_pkt)\r\nrtw_os_pkt_complete23a(padapter, pndis_pkt);\r\nexit:\r\nreturn _SUCCESS;\r\n}\r\nvoid rtw_free_xmitframe_queue23a(struct xmit_priv *pxmitpriv,\r\nstruct rtw_queue *pframequeue)\r\n{\r\nstruct list_head *phead;\r\nstruct xmit_frame *pxmitframe, *ptmp;\r\nspin_lock_bh(&pframequeue->lock);\r\nphead = get_list_head(pframequeue);\r\nlist_for_each_entry_safe(pxmitframe, ptmp, phead, list)\r\nrtw_free_xmitframe23a(pxmitpriv, pxmitframe);\r\nspin_unlock_bh(&pframequeue->lock);\r\n}\r\nint rtw_xmitframe_enqueue23a(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nif (rtw_xmit23a_classifier(padapter, pxmitframe) == _FAIL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"rtw_xmitframe_enqueue23a: drop xmit pkt for classifier fail\n");\r\nreturn _FAIL;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic struct xmit_frame *\r\ndequeue_one_xmitframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit,\r\nstruct tx_servq *ptxservq, struct rtw_queue *pframe_queue)\r\n{\r\nstruct list_head *phead;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nphead = get_list_head(pframe_queue);\r\nif (!list_empty(phead)) {\r\npxmitframe = list_first_entry(phead, struct xmit_frame, list);\r\nlist_del_init(&pxmitframe->list);\r\nptxservq->qcnt--;\r\n}\r\nreturn pxmitframe;\r\n}\r\nstruct xmit_frame *\r\nrtw_dequeue_xframe23a(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i,\r\nint entry)\r\n{\r\nstruct list_head *sta_phead;\r\nstruct hw_xmit *phwxmit;\r\nstruct tx_servq *ptxservq = NULL, *ptmp;\r\nstruct rtw_queue *pframe_queue = NULL;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nstruct rtw_adapter *padapter = pxmitpriv->adapter;\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nint i, inx[4];\r\ninx[0] = 0;\r\ninx[1] = 1;\r\ninx[2] = 2;\r\ninx[3] = 3;\r\nif (pregpriv->wifi_spec == 1) {\r\nint j;\r\nfor (j = 0; j < 4; j++)\r\ninx[j] = pxmitpriv->wmm_para_seq[j];\r\n}\r\nspin_lock_bh(&pxmitpriv->lock);\r\nfor (i = 0; i < entry; i++) {\r\nphwxmit = phwxmit_i + inx[i];\r\nsta_phead = get_list_head(phwxmit->sta_queue);\r\nlist_for_each_entry_safe(ptxservq, ptmp, sta_phead,\r\ntx_pending) {\r\npframe_queue = &ptxservq->sta_pending;\r\npxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);\r\nif (pxmitframe) {\r\nphwxmit->accnt--;\r\nif (list_empty(&pframe_queue->queue))\r\nlist_del_init(&ptxservq->tx_pending);\r\ngoto exit;\r\n}\r\n}\r\n}\r\nexit:\r\nspin_unlock_bh(&pxmitpriv->lock);\r\nreturn pxmitframe;\r\n}\r\nstruct tx_servq *rtw_get_sta_pending23a(struct rtw_adapter *padapter, struct sta_info *psta, int up, u8 *ac)\r\n{\r\nstruct tx_servq *ptxservq = NULL;\r\nswitch (up) {\r\ncase 1:\r\ncase 2:\r\nptxservq = &psta->sta_xmitpriv.bk_q;\r\n*(ac) = 3;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"rtw_get_sta_pending23a : BK\n");\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nptxservq = &psta->sta_xmitpriv.vi_q;\r\n*(ac) = 1;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"rtw_get_sta_pending23a : VI\n");\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nptxservq = &psta->sta_xmitpriv.vo_q;\r\n*(ac) = 0;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"rtw_get_sta_pending23a : VO\n");\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nptxservq = &psta->sta_xmitpriv.be_q;\r\n*(ac) = 2;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n"rtw_get_sta_pending23a : BE\n");\r\nbreak;\r\n}\r\nreturn ptxservq;\r\n}\r\nint rtw_xmit23a_classifier(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nstruct sta_info *psta;\r\nstruct tx_servq *ptxservq;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct hw_xmit *phwxmits = padapter->xmitpriv.hwxmits;\r\nu8 ac_index;\r\nint res = _SUCCESS;\r\nif (pattrib->psta) {\r\npsta = pattrib->psta;\r\n} else {\r\nDBG_8723A("%s, call rtw_get_stainfo23a()\n", __func__);\r\npsta = rtw_get_stainfo23a(pstapriv, pattrib->ra);\r\n}\r\nif (psta == NULL) {\r\nres = _FAIL;\r\nDBG_8723A("rtw_xmit23a_classifier: psta == NULL\n");\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n"rtw_xmit23a_classifier: psta == NULL\n");\r\ngoto exit;\r\n}\r\nif (!(psta->state & _FW_LINKED)) {\r\nDBG_8723A("%s, psta->state(0x%x) != _FW_LINKED\n", __func__,\r\npsta->state);\r\nreturn _FAIL;\r\n}\r\nptxservq = rtw_get_sta_pending23a(padapter, psta, pattrib->priority,\r\n(u8 *)(&ac_index));\r\nif (list_empty(&ptxservq->tx_pending)) {\r\nlist_add_tail(&ptxservq->tx_pending,\r\nget_list_head(phwxmits[ac_index].sta_queue));\r\n}\r\nlist_add_tail(&pxmitframe->list, get_list_head(&ptxservq->sta_pending));\r\nptxservq->qcnt++;\r\nphwxmits[ac_index].accnt++;\r\nexit:\r\nreturn res;\r\n}\r\nvoid rtw_alloc_hwxmits23a(struct rtw_adapter *padapter)\r\n{\r\nstruct hw_xmit *hwxmits;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nint size;\r\npxmitpriv->hwxmit_entry = HWXMIT_ENTRY;\r\nsize = sizeof(struct hw_xmit) * (pxmitpriv->hwxmit_entry + 1);\r\npxmitpriv->hwxmits = kzalloc(size, GFP_KERNEL);\r\nhwxmits = pxmitpriv->hwxmits;\r\nif (pxmitpriv->hwxmit_entry == 5) {\r\nhwxmits[0] .sta_queue = &pxmitpriv->bm_pending;\r\nhwxmits[1] .sta_queue = &pxmitpriv->vo_pending;\r\nhwxmits[2] .sta_queue = &pxmitpriv->vi_pending;\r\nhwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\r\nhwxmits[4] .sta_queue = &pxmitpriv->be_pending;\r\n} else if (pxmitpriv->hwxmit_entry == 4) {\r\nhwxmits[0] .sta_queue = &pxmitpriv->vo_pending;\r\nhwxmits[1] .sta_queue = &pxmitpriv->vi_pending;\r\nhwxmits[2] .sta_queue = &pxmitpriv->be_pending;\r\nhwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\r\n} else {\r\n}\r\n}\r\nvoid rtw_free_hwxmits23a(struct rtw_adapter *padapter)\r\n{\r\nstruct hw_xmit *hwxmits;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nhwxmits = pxmitpriv->hwxmits;\r\nkfree(hwxmits);\r\n}\r\nvoid rtw_init_hwxmits23a(struct hw_xmit *phwxmit, int entry)\r\n{\r\nint i;\r\nfor (i = 0; i < entry; i++, phwxmit++)\r\nphwxmit->accnt = 0;\r\n}\r\nu32 rtw_get_ff_hwaddr23a(struct xmit_frame *pxmitframe)\r\n{\r\nu32 addr;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nswitch (pattrib->qsel) {\r\ncase 0:\r\ncase 3:\r\naddr = BE_QUEUE_INX;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\naddr = BK_QUEUE_INX;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\naddr = VI_QUEUE_INX;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\naddr = VO_QUEUE_INX;\r\nbreak;\r\ncase 0x10:\r\naddr = BCN_QUEUE_INX;\r\nbreak;\r\ncase 0x11:\r\naddr = HIGH_QUEUE_INX;\r\nbreak;\r\ncase 0x12:\r\ndefault:\r\naddr = MGT_QUEUE_INX;\r\nbreak;\r\n}\r\nreturn addr;\r\n}\r\nint rtw_xmit23a(struct rtw_adapter *padapter, struct sk_buff *skb)\r\n{\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nint res;\r\npxmitframe = rtw_alloc_xmitframe(pxmitpriv);\r\nif (pxmitframe == NULL) {\r\nRT_TRACE(_module_xmit_osdep_c_, _drv_err_,\r\n"rtw_xmit23a: no more pxmitframe\n");\r\nreturn -1;\r\n}\r\nres = update_attrib(padapter, skb, &pxmitframe->attrib);\r\nif (res == _FAIL) {\r\nRT_TRACE(_module_xmit_osdep_c_, _drv_err_,\r\n"rtw_xmit23a: update attrib fail\n");\r\nrtw_free_xmitframe23a(pxmitpriv, pxmitframe);\r\nreturn -1;\r\n}\r\npxmitframe->pkt = skb;\r\npxmitframe->attrib.qsel = pxmitframe->attrib.priority;\r\n#ifdef CONFIG_8723AU_AP_MODE\r\nspin_lock_bh(&pxmitpriv->lock);\r\nif (xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe)) {\r\nspin_unlock_bh(&pxmitpriv->lock);\r\nreturn 1;\r\n}\r\nspin_unlock_bh(&pxmitpriv->lock);\r\n#endif\r\nif (rtl8723au_hal_xmit(padapter, pxmitframe) == false)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint xmitframe_enqueue_for_sleeping_sta23a(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nint ret = false;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nint bmcst = is_multicast_ether_addr(pattrib->ra);\r\nif (!check_fwstate(pmlmepriv, WIFI_AP_STATE))\r\nreturn ret;\r\nif (pattrib->psta) {\r\npsta = pattrib->psta;\r\n} else {\r\nDBG_8723A("%s, call rtw_get_stainfo23a()\n", __func__);\r\npsta = rtw_get_stainfo23a(pstapriv, pattrib->ra);\r\n}\r\nif (psta == NULL) {\r\nDBG_8723A("%s, psta == NUL\n", __func__);\r\nreturn false;\r\n}\r\nif (!(psta->state & _FW_LINKED)) {\r\nDBG_8723A("%s, psta->state(0x%x) != _FW_LINKED\n", __func__,\r\npsta->state);\r\nreturn false;\r\n}\r\nif (pattrib->triggered == 1) {\r\nif (bmcst)\r\npattrib->qsel = 0x11;\r\nreturn ret;\r\n}\r\nif (bmcst) {\r\nspin_lock_bh(&psta->sleep_q.lock);\r\nif (pstapriv->sta_dz_bitmap) {\r\nlist_del_init(&pxmitframe->list);\r\nlist_add_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));\r\npsta->sleepq_len++;\r\npstapriv->tim_bitmap |= BIT(0);\r\npstapriv->sta_dz_bitmap |= BIT(0);\r\nupdate_beacon23a(padapter, WLAN_EID_TIM, NULL, false);\r\nret = true;\r\n}\r\nspin_unlock_bh(&psta->sleep_q.lock);\r\nreturn ret;\r\n}\r\nspin_lock_bh(&psta->sleep_q.lock);\r\nif (psta->state&WIFI_SLEEP_STATE) {\r\nu8 wmmps_ac = 0;\r\nif (pstapriv->sta_dz_bitmap & CHKBIT(psta->aid)) {\r\nlist_del_init(&pxmitframe->list);\r\nlist_add_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));\r\npsta->sleepq_len++;\r\nswitch (pattrib->priority) {\r\ncase 1:\r\ncase 2:\r\nwmmps_ac = psta->uapsd_bk & BIT(0);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nwmmps_ac = psta->uapsd_vi & BIT(0);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nwmmps_ac = psta->uapsd_vo & BIT(0);\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nwmmps_ac = psta->uapsd_be & BIT(0);\r\nbreak;\r\n}\r\nif (wmmps_ac)\r\npsta->sleepq_ac_len++;\r\nif (((psta->has_legacy_ac) && (!wmmps_ac)) ||\r\n((!psta->has_legacy_ac) && (wmmps_ac))) {\r\npstapriv->tim_bitmap |= CHKBIT(psta->aid);\r\nif (psta->sleepq_len == 1) {\r\nupdate_beacon23a(padapter, WLAN_EID_TIM,\r\nNULL, false);\r\n}\r\n}\r\nret = true;\r\n}\r\n}\r\nspin_unlock_bh(&psta->sleep_q.lock);\r\nreturn ret;\r\n}\r\nstatic void\r\ndequeue_xmitframes_to_sleeping_queue(struct rtw_adapter *padapter,\r\nstruct sta_info *psta,\r\nstruct rtw_queue *pframequeue)\r\n{\r\nint ret;\r\nstruct list_head *phead;\r\nu8 ac_index;\r\nstruct tx_servq *ptxservq;\r\nstruct pkt_attrib *pattrib;\r\nstruct xmit_frame *pxmitframe, *ptmp;\r\nstruct hw_xmit *phwxmits = padapter->xmitpriv.hwxmits;\r\nphead = get_list_head(pframequeue);\r\nlist_for_each_entry_safe(pxmitframe, ptmp, phead, list) {\r\nret = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);\r\nif (ret == true) {\r\npattrib = &pxmitframe->attrib;\r\nptxservq = rtw_get_sta_pending23a(padapter, psta, pattrib->priority, (u8 *)(&ac_index));\r\nptxservq->qcnt--;\r\nphwxmits[ac_index].accnt--;\r\n} else {\r\n}\r\n}\r\n}\r\nvoid stop_sta_xmit23a(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct sta_info *psta_bmc;\r\nstruct sta_xmit_priv *pstaxmitpriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\npstaxmitpriv = &psta->sta_xmitpriv;\r\npsta_bmc = rtw_get_bcmc_stainfo23a(padapter);\r\nspin_lock_bh(&pxmitpriv->lock);\r\npsta->state |= WIFI_SLEEP_STATE;\r\npstapriv->sta_dz_bitmap |= CHKBIT(psta->aid);\r\ndequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vo_q.sta_pending);\r\nlist_del_init(&pstaxmitpriv->vo_q.tx_pending);\r\ndequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vi_q.sta_pending);\r\nlist_del_init(&pstaxmitpriv->vi_q.tx_pending);\r\ndequeue_xmitframes_to_sleeping_queue(padapter, psta,\r\n&pstaxmitpriv->be_q.sta_pending);\r\nlist_del_init(&pstaxmitpriv->be_q.tx_pending);\r\ndequeue_xmitframes_to_sleeping_queue(padapter, psta,\r\n&pstaxmitpriv->bk_q.sta_pending);\r\nlist_del_init(&pstaxmitpriv->bk_q.tx_pending);\r\npstaxmitpriv = &psta_bmc->sta_xmitpriv;\r\ndequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc,\r\n&pstaxmitpriv->be_q.sta_pending);\r\nlist_del_init(&pstaxmitpriv->be_q.tx_pending);\r\nspin_unlock_bh(&pxmitpriv->lock);\r\n}\r\nvoid wakeup_sta_to_xmit23a(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nu8 update_mask = 0, wmmps_ac = 0;\r\nstruct sta_info *psta_bmc;\r\nstruct list_head *phead;\r\nstruct xmit_frame *pxmitframe = NULL, *ptmp;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nspin_lock_bh(&pxmitpriv->lock);\r\nphead = get_list_head(&psta->sleep_q);\r\nlist_for_each_entry_safe(pxmitframe, ptmp, phead, list) {\r\nlist_del_init(&pxmitframe->list);\r\nswitch (pxmitframe->attrib.priority) {\r\ncase 1:\r\ncase 2:\r\nwmmps_ac = psta->uapsd_bk & BIT(1);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nwmmps_ac = psta->uapsd_vi & BIT(1);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nwmmps_ac = psta->uapsd_vo & BIT(1);\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nwmmps_ac = psta->uapsd_be & BIT(1);\r\nbreak;\r\n}\r\npsta->sleepq_len--;\r\nif (psta->sleepq_len > 0)\r\npxmitframe->attrib.mdata = 1;\r\nelse\r\npxmitframe->attrib.mdata = 0;\r\nif (wmmps_ac) {\r\npsta->sleepq_ac_len--;\r\nif (psta->sleepq_ac_len > 0) {\r\npxmitframe->attrib.mdata = 1;\r\npxmitframe->attrib.eosp = 0;\r\n} else {\r\npxmitframe->attrib.mdata = 0;\r\npxmitframe->attrib.eosp = 1;\r\n}\r\n}\r\npxmitframe->attrib.triggered = 1;\r\nrtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);\r\n}\r\nif (psta->sleepq_len == 0) {\r\npstapriv->tim_bitmap &= ~CHKBIT(psta->aid);\r\nupdate_mask = BIT(0);\r\nif (psta->state&WIFI_SLEEP_STATE)\r\npsta->state ^= WIFI_SLEEP_STATE;\r\nif (psta->state & WIFI_STA_ALIVE_CHK_STATE) {\r\npsta->expire_to = pstapriv->expire_to;\r\npsta->state ^= WIFI_STA_ALIVE_CHK_STATE;\r\n}\r\npstapriv->sta_dz_bitmap &= ~CHKBIT(psta->aid);\r\n}\r\nspin_unlock_bh(&pxmitpriv->lock);\r\npsta_bmc = rtw_get_bcmc_stainfo23a(padapter);\r\nif (!psta_bmc)\r\nreturn;\r\nif ((pstapriv->sta_dz_bitmap&0xfffe) == 0x0) {\r\nspin_lock_bh(&pxmitpriv->lock);\r\nphead = get_list_head(&psta_bmc->sleep_q);\r\nlist_for_each_entry_safe(pxmitframe, ptmp, phead, list) {\r\nlist_del_init(&pxmitframe->list);\r\npsta_bmc->sleepq_len--;\r\nif (psta_bmc->sleepq_len > 0)\r\npxmitframe->attrib.mdata = 1;\r\nelse\r\npxmitframe->attrib.mdata = 0;\r\npxmitframe->attrib.triggered = 1;\r\nrtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);\r\n}\r\nif (psta_bmc->sleepq_len == 0) {\r\npstapriv->tim_bitmap &= ~BIT(0);\r\npstapriv->sta_dz_bitmap &= ~BIT(0);\r\nupdate_mask |= BIT(1);\r\n}\r\nspin_unlock_bh(&pxmitpriv->lock);\r\n}\r\nif (update_mask)\r\nupdate_beacon23a(padapter, WLAN_EID_TIM, NULL, false);\r\n}\r\nvoid xmit_delivery_enabled_frames23a(struct rtw_adapter *padapter,\r\nstruct sta_info *psta)\r\n{\r\nu8 wmmps_ac = 0;\r\nstruct list_head *phead;\r\nstruct xmit_frame *pxmitframe, *ptmp;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nspin_lock_bh(&pxmitpriv->lock);\r\nphead = get_list_head(&psta->sleep_q);\r\nlist_for_each_entry_safe(pxmitframe, ptmp, phead, list) {\r\nswitch (pxmitframe->attrib.priority) {\r\ncase 1:\r\ncase 2:\r\nwmmps_ac = psta->uapsd_bk & BIT(1);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nwmmps_ac = psta->uapsd_vi & BIT(1);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nwmmps_ac = psta->uapsd_vo & BIT(1);\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nwmmps_ac = psta->uapsd_be & BIT(1);\r\nbreak;\r\n}\r\nif (!wmmps_ac)\r\ncontinue;\r\nlist_del_init(&pxmitframe->list);\r\npsta->sleepq_len--;\r\npsta->sleepq_ac_len--;\r\nif (psta->sleepq_ac_len > 0) {\r\npxmitframe->attrib.mdata = 1;\r\npxmitframe->attrib.eosp = 0;\r\n} else {\r\npxmitframe->attrib.mdata = 0;\r\npxmitframe->attrib.eosp = 1;\r\n}\r\npxmitframe->attrib.triggered = 1;\r\nrtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);\r\nif ((psta->sleepq_ac_len == 0) && (!psta->has_legacy_ac) &&\r\n(wmmps_ac)) {\r\npstapriv->tim_bitmap &= ~CHKBIT(psta->aid);\r\nupdate_beacon23a(padapter, WLAN_EID_TIM, NULL, false);\r\n}\r\n}\r\nspin_unlock_bh(&pxmitpriv->lock);\r\n}\r\nvoid rtw_sctx_init23a(struct submit_ctx *sctx, int timeout_ms)\r\n{\r\nsctx->timeout_ms = timeout_ms;\r\ninit_completion(&sctx->done);\r\nsctx->status = RTW_SCTX_SUBMITTED;\r\n}\r\nint rtw_sctx_wait23a(struct submit_ctx *sctx)\r\n{\r\nint ret = _FAIL;\r\nunsigned long expire;\r\nint status = 0;\r\nexpire = sctx->timeout_ms ? msecs_to_jiffies(sctx->timeout_ms) :\r\nMAX_SCHEDULE_TIMEOUT;\r\nif (!wait_for_completion_timeout(&sctx->done, expire)) {\r\nstatus = RTW_SCTX_DONE_TIMEOUT;\r\nDBG_8723A("%s timeout\n", __func__);\r\n} else {\r\nstatus = sctx->status;\r\n}\r\nif (status == RTW_SCTX_DONE_SUCCESS)\r\nret = _SUCCESS;\r\nreturn ret;\r\n}\r\nstatic bool rtw_sctx_chk_waring_status(int status)\r\n{\r\nswitch (status) {\r\ncase RTW_SCTX_DONE_UNKNOWN:\r\ncase RTW_SCTX_DONE_BUF_ALLOC:\r\ncase RTW_SCTX_DONE_BUF_FREE:\r\ncase RTW_SCTX_DONE_DRV_STOP:\r\ncase RTW_SCTX_DONE_DEV_REMOVE:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nvoid rtw23a_sctx_done_err(struct submit_ctx **sctx, int status)\r\n{\r\nif (*sctx) {\r\nif (rtw_sctx_chk_waring_status(status))\r\nDBG_8723A("%s status:%d\n", __func__, status);\r\n(*sctx)->status = status;\r\ncomplete(&(*sctx)->done);\r\n*sctx = NULL;\r\n}\r\n}\r\nint rtw_ack_tx_wait23a(struct xmit_priv *pxmitpriv, u32 timeout_ms)\r\n{\r\nstruct submit_ctx *pack_tx_ops = &pxmitpriv->ack_tx_ops;\r\npack_tx_ops->timeout_ms = timeout_ms;\r\npack_tx_ops->status = RTW_SCTX_SUBMITTED;\r\nreturn rtw_sctx_wait23a(pack_tx_ops);\r\n}
