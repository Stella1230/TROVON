static void as102_stop_stream(struct as102_dev_t *dev)\r\n{\r\nstruct as10x_bus_adapter_t *bus_adap;\r\nif (dev != NULL)\r\nbus_adap = &dev->bus_adap;\r\nelse\r\nreturn;\r\nif (bus_adap->ops->stop_stream != NULL)\r\nbus_adap->ops->stop_stream(dev);\r\nif (ts_auto_disable) {\r\nif (mutex_lock_interruptible(&dev->bus_adap.lock))\r\nreturn;\r\nif (as10x_cmd_stop_streaming(bus_adap) < 0)\r\ndev_dbg(&dev->bus_adap.usb_dev->dev,\r\n"as10x_cmd_stop_streaming failed\n");\r\nmutex_unlock(&dev->bus_adap.lock);\r\n}\r\n}\r\nstatic int as102_start_stream(struct as102_dev_t *dev)\r\n{\r\nstruct as10x_bus_adapter_t *bus_adap;\r\nint ret = -EFAULT;\r\nif (dev != NULL)\r\nbus_adap = &dev->bus_adap;\r\nelse\r\nreturn ret;\r\nif (bus_adap->ops->start_stream != NULL)\r\nret = bus_adap->ops->start_stream(dev);\r\nif (ts_auto_disable) {\r\nif (mutex_lock_interruptible(&dev->bus_adap.lock))\r\nreturn -EFAULT;\r\nret = as10x_cmd_start_streaming(bus_adap);\r\nmutex_unlock(&dev->bus_adap.lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int as10x_pid_filter(struct as102_dev_t *dev,\r\nint index, u16 pid, int onoff) {\r\nstruct as10x_bus_adapter_t *bus_adap = &dev->bus_adap;\r\nint ret = -EFAULT;\r\nif (mutex_lock_interruptible(&dev->bus_adap.lock)) {\r\ndev_dbg(&dev->bus_adap.usb_dev->dev,\r\n"amutex_lock_interruptible(lock) failed !\n");\r\nreturn -EBUSY;\r\n}\r\nswitch (onoff) {\r\ncase 0:\r\nret = as10x_cmd_del_PID_filter(bus_adap, (uint16_t) pid);\r\ndev_dbg(&dev->bus_adap.usb_dev->dev,\r\n"DEL_PID_FILTER([%02d] 0x%04x) ret = %d\n",\r\nindex, pid, ret);\r\nbreak;\r\ncase 1:\r\n{\r\nstruct as10x_ts_filter filter;\r\nfilter.type = TS_PID_TYPE_TS;\r\nfilter.idx = 0xFF;\r\nfilter.pid = pid;\r\nret = as10x_cmd_add_PID_filter(bus_adap, &filter);\r\ndev_dbg(&dev->bus_adap.usb_dev->dev,\r\n"ADD_PID_FILTER([%02d -> %02d], 0x%04x) ret = %d\n",\r\nindex, filter.idx, filter.pid, ret);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&dev->bus_adap.lock);\r\nreturn ret;\r\n}\r\nstatic int as102_dvb_dmx_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nint ret = 0;\r\nstruct dvb_demux *demux = dvbdmxfeed->demux;\r\nstruct as102_dev_t *as102_dev = demux->priv;\r\nif (mutex_lock_interruptible(&as102_dev->sem))\r\nreturn -ERESTARTSYS;\r\nif (pid_filtering)\r\nas10x_pid_filter(as102_dev, dvbdmxfeed->index,\r\ndvbdmxfeed->pid, 1);\r\nif (as102_dev->streaming++ == 0)\r\nret = as102_start_stream(as102_dev);\r\nmutex_unlock(&as102_dev->sem);\r\nreturn ret;\r\n}\r\nstatic int as102_dvb_dmx_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *demux = dvbdmxfeed->demux;\r\nstruct as102_dev_t *as102_dev = demux->priv;\r\nif (mutex_lock_interruptible(&as102_dev->sem))\r\nreturn -ERESTARTSYS;\r\nif (--as102_dev->streaming == 0)\r\nas102_stop_stream(as102_dev);\r\nif (pid_filtering)\r\nas10x_pid_filter(as102_dev, dvbdmxfeed->index,\r\ndvbdmxfeed->pid, 0);\r\nmutex_unlock(&as102_dev->sem);\r\nreturn 0;\r\n}\r\nstatic int as102_set_tune(void *priv, struct as10x_tune_args *tune_args)\r\n{\r\nstruct as10x_bus_adapter_t *bus_adap = priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&bus_adap->lock))\r\nreturn -EBUSY;\r\nret = as10x_cmd_set_tune(bus_adap, tune_args);\r\nif (ret != 0)\r\ndev_dbg(&bus_adap->usb_dev->dev,\r\n"as10x_cmd_set_tune failed. (err = %d)\n", ret);\r\nmutex_unlock(&bus_adap->lock);\r\nreturn ret;\r\n}\r\nstatic int as102_get_tps(void *priv, struct as10x_tps *tps)\r\n{\r\nstruct as10x_bus_adapter_t *bus_adap = priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&bus_adap->lock))\r\nreturn -EBUSY;\r\nret = as10x_cmd_get_tps(bus_adap, tps);\r\nmutex_unlock(&bus_adap->lock);\r\nreturn ret;\r\n}\r\nstatic int as102_get_status(void *priv, struct as10x_tune_status *tstate)\r\n{\r\nstruct as10x_bus_adapter_t *bus_adap = priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&bus_adap->lock))\r\nreturn -EBUSY;\r\nret = as10x_cmd_get_tune_status(bus_adap, tstate);\r\nif (ret < 0) {\r\ndev_dbg(&bus_adap->usb_dev->dev,\r\n"as10x_cmd_get_tune_status failed (err = %d)\n",\r\nret);\r\n}\r\nmutex_unlock(&bus_adap->lock);\r\nreturn ret;\r\n}\r\nstatic int as102_get_stats(void *priv, struct as10x_demod_stats *demod_stats)\r\n{\r\nstruct as10x_bus_adapter_t *bus_adap = priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&bus_adap->lock))\r\nreturn -EBUSY;\r\nret = as10x_cmd_get_demod_stats(bus_adap, demod_stats);\r\nif (ret < 0) {\r\ndev_dbg(&bus_adap->usb_dev->dev,\r\n"as10x_cmd_get_demod_stats failed (probably not tuned)\n");\r\n} else {\r\ndev_dbg(&bus_adap->usb_dev->dev,\r\n"demod status: fc: 0x%08x, bad fc: 0x%08x, bytes corrected: 0x%08x , MER: 0x%04x\n",\r\ndemod_stats->frame_count,\r\ndemod_stats->bad_frame_count,\r\ndemod_stats->bytes_fixed_by_rs,\r\ndemod_stats->mer);\r\n}\r\nmutex_unlock(&bus_adap->lock);\r\nreturn ret;\r\n}\r\nstatic int as102_stream_ctrl(void *priv, int acquire, uint32_t elna_cfg)\r\n{\r\nstruct as10x_bus_adapter_t *bus_adap = priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&bus_adap->lock))\r\nreturn -EBUSY;\r\nif (acquire) {\r\nif (elna_enable)\r\nas10x_cmd_set_context(bus_adap,\r\nCONTEXT_LNA, elna_cfg);\r\nret = as10x_cmd_turn_on(bus_adap);\r\n} else {\r\nret = as10x_cmd_turn_off(bus_adap);\r\n}\r\nmutex_unlock(&bus_adap->lock);\r\nreturn ret;\r\n}\r\nint as102_dvb_register(struct as102_dev_t *as102_dev)\r\n{\r\nstruct device *dev = &as102_dev->bus_adap.usb_dev->dev;\r\nint ret;\r\nret = dvb_register_adapter(&as102_dev->dvb_adap,\r\nas102_dev->name, THIS_MODULE,\r\ndev, adapter_nr);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: dvb_register_adapter() failed: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nas102_dev->dvb_dmx.priv = as102_dev;\r\nas102_dev->dvb_dmx.filternum = pid_filtering ? 16 : 256;\r\nas102_dev->dvb_dmx.feednum = 256;\r\nas102_dev->dvb_dmx.start_feed = as102_dvb_dmx_start_feed;\r\nas102_dev->dvb_dmx.stop_feed = as102_dvb_dmx_stop_feed;\r\nas102_dev->dvb_dmx.dmx.capabilities = DMX_TS_FILTERING |\r\nDMX_SECTION_FILTERING;\r\nas102_dev->dvb_dmxdev.filternum = as102_dev->dvb_dmx.filternum;\r\nas102_dev->dvb_dmxdev.demux = &as102_dev->dvb_dmx.dmx;\r\nas102_dev->dvb_dmxdev.capabilities = 0;\r\nret = dvb_dmx_init(&as102_dev->dvb_dmx);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: dvb_dmx_init() failed: %d\n", __func__, ret);\r\ngoto edmxinit;\r\n}\r\nret = dvb_dmxdev_init(&as102_dev->dvb_dmxdev, &as102_dev->dvb_adap);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: dvb_dmxdev_init() failed: %d\n",\r\n__func__, ret);\r\ngoto edmxdinit;\r\n}\r\nas102_dev->dvb_fe = dvb_attach(as102_attach, as102_dev->name,\r\n&as102_fe_ops,\r\n&as102_dev->bus_adap,\r\nas102_dev->elna_cfg);\r\nif (!as102_dev->dvb_fe) {\r\nret = -ENODEV;\r\ndev_err(dev, "%s: as102_attach() failed: %d",\r\n__func__, ret);\r\ngoto efereg;\r\n}\r\nret = dvb_register_frontend(&as102_dev->dvb_adap, as102_dev->dvb_fe);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: as102_dvb_register_frontend() failed: %d",\r\n__func__, ret);\r\ngoto efereg;\r\n}\r\nmutex_init(&as102_dev->bus_adap.lock);\r\nmutex_init(&as102_dev->sem);\r\nif (fw_upload)\r\ntry_then_request_module(as102_fw_upload(&as102_dev->bus_adap),\r\n"firmware_class");\r\npr_info("Registered device %s", as102_dev->name);\r\nreturn 0;\r\nefereg:\r\ndvb_dmxdev_release(&as102_dev->dvb_dmxdev);\r\nedmxdinit:\r\ndvb_dmx_release(&as102_dev->dvb_dmx);\r\nedmxinit:\r\ndvb_unregister_adapter(&as102_dev->dvb_adap);\r\nreturn ret;\r\n}\r\nvoid as102_dvb_unregister(struct as102_dev_t *as102_dev)\r\n{\r\ndvb_unregister_frontend(as102_dev->dvb_fe);\r\ndvb_frontend_detach(as102_dev->dvb_fe);\r\ndvb_dmxdev_release(&as102_dev->dvb_dmxdev);\r\ndvb_dmx_release(&as102_dev->dvb_dmx);\r\ndvb_unregister_adapter(&as102_dev->dvb_adap);\r\npr_info("Unregistered device %s", as102_dev->name);\r\n}
