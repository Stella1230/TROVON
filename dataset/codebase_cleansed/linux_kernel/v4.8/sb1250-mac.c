static void sbmac_mii_sync(void __iomem *sbm_mdio)\r\n{\r\nint cnt;\r\nuint64_t bits;\r\nint mac_mdio_genc;\r\nmac_mdio_genc = __raw_readq(sbm_mdio) & M_MAC_GENC;\r\nbits = M_MAC_MDIO_DIR_OUTPUT | M_MAC_MDIO_OUT;\r\n__raw_writeq(bits | mac_mdio_genc, sbm_mdio);\r\nfor (cnt = 0; cnt < 32; cnt++) {\r\n__raw_writeq(bits | M_MAC_MDC | mac_mdio_genc, sbm_mdio);\r\n__raw_writeq(bits | mac_mdio_genc, sbm_mdio);\r\n}\r\n}\r\nstatic void sbmac_mii_senddata(void __iomem *sbm_mdio, unsigned int data,\r\nint bitcnt)\r\n{\r\nint i;\r\nuint64_t bits;\r\nunsigned int curmask;\r\nint mac_mdio_genc;\r\nmac_mdio_genc = __raw_readq(sbm_mdio) & M_MAC_GENC;\r\nbits = M_MAC_MDIO_DIR_OUTPUT;\r\n__raw_writeq(bits | mac_mdio_genc, sbm_mdio);\r\ncurmask = 1 << (bitcnt - 1);\r\nfor (i = 0; i < bitcnt; i++) {\r\nif (data & curmask)\r\nbits |= M_MAC_MDIO_OUT;\r\nelse bits &= ~M_MAC_MDIO_OUT;\r\n__raw_writeq(bits | mac_mdio_genc, sbm_mdio);\r\n__raw_writeq(bits | M_MAC_MDC | mac_mdio_genc, sbm_mdio);\r\n__raw_writeq(bits | mac_mdio_genc, sbm_mdio);\r\ncurmask >>= 1;\r\n}\r\n}\r\nstatic int sbmac_mii_read(struct mii_bus *bus, int phyaddr, int regidx)\r\n{\r\nstruct sbmac_softc *sc = (struct sbmac_softc *)bus->priv;\r\nvoid __iomem *sbm_mdio = sc->sbm_mdio;\r\nint idx;\r\nint error;\r\nint regval;\r\nint mac_mdio_genc;\r\nsbmac_mii_sync(sbm_mdio);\r\nsbmac_mii_senddata(sbm_mdio, MII_COMMAND_START, 2);\r\nsbmac_mii_senddata(sbm_mdio, MII_COMMAND_READ, 2);\r\nsbmac_mii_senddata(sbm_mdio, phyaddr, 5);\r\nsbmac_mii_senddata(sbm_mdio, regidx, 5);\r\nmac_mdio_genc = __raw_readq(sbm_mdio) & M_MAC_GENC;\r\n__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, sbm_mdio);\r\n__raw_writeq(M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc,\r\nsbm_mdio);\r\n__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, sbm_mdio);\r\nerror = __raw_readq(sbm_mdio) & M_MAC_MDIO_IN;\r\n__raw_writeq(M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc,\r\nsbm_mdio);\r\n__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, sbm_mdio);\r\nregval = 0;\r\nfor (idx = 0; idx < 16; idx++) {\r\nregval <<= 1;\r\nif (error == 0) {\r\nif (__raw_readq(sbm_mdio) & M_MAC_MDIO_IN)\r\nregval |= 1;\r\n}\r\n__raw_writeq(M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc,\r\nsbm_mdio);\r\n__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, sbm_mdio);\r\n}\r\n__raw_writeq(M_MAC_MDIO_DIR_OUTPUT | mac_mdio_genc, sbm_mdio);\r\nif (error == 0)\r\nreturn regval;\r\nreturn 0xffff;\r\n}\r\nstatic int sbmac_mii_write(struct mii_bus *bus, int phyaddr, int regidx,\r\nu16 regval)\r\n{\r\nstruct sbmac_softc *sc = (struct sbmac_softc *)bus->priv;\r\nvoid __iomem *sbm_mdio = sc->sbm_mdio;\r\nint mac_mdio_genc;\r\nsbmac_mii_sync(sbm_mdio);\r\nsbmac_mii_senddata(sbm_mdio, MII_COMMAND_START, 2);\r\nsbmac_mii_senddata(sbm_mdio, MII_COMMAND_WRITE, 2);\r\nsbmac_mii_senddata(sbm_mdio, phyaddr, 5);\r\nsbmac_mii_senddata(sbm_mdio, regidx, 5);\r\nsbmac_mii_senddata(sbm_mdio, MII_COMMAND_ACK, 2);\r\nsbmac_mii_senddata(sbm_mdio, regval, 16);\r\nmac_mdio_genc = __raw_readq(sbm_mdio) & M_MAC_GENC;\r\n__raw_writeq(M_MAC_MDIO_DIR_OUTPUT | mac_mdio_genc, sbm_mdio);\r\nreturn 0;\r\n}\r\nstatic void sbdma_initctx(struct sbmacdma *d, struct sbmac_softc *s, int chan,\r\nint txrx, int maxdescr)\r\n{\r\n#ifdef CONFIG_SBMAC_COALESCE\r\nint int_pktcnt, int_timeout;\r\n#endif\r\nd->sbdma_eth = s;\r\nd->sbdma_channel = chan;\r\nd->sbdma_txdir = txrx;\r\n#if 0\r\ns->sbe_idx =(s->sbm_base - A_MAC_BASE_0)/MAC_SPACING;\r\n#endif\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_BYTES);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_COLLISIONS);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_LATE_COL);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_EX_COL);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_FCS_ERROR);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_ABORT);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_BAD);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_GOOD);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_RUNT);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_OVERSIZE);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_BYTES);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_MCAST);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_BCAST);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_BAD);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_GOOD);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_RUNT);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_OVERSIZE);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_FCS_ERROR);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_LENGTH_ERROR);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_CODE_ERROR);\r\n__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_ALIGN_ERROR);\r\nd->sbdma_config0 =\r\ns->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CONFIG0);\r\nd->sbdma_config1 =\r\ns->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CONFIG1);\r\nd->sbdma_dscrbase =\r\ns->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_DSCR_BASE);\r\nd->sbdma_dscrcnt =\r\ns->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_DSCR_CNT);\r\nd->sbdma_curdscr =\r\ns->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CUR_DSCRADDR);\r\nif (d->sbdma_txdir)\r\nd->sbdma_oodpktlost = NULL;\r\nelse\r\nd->sbdma_oodpktlost =\r\ns->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_OODPKTLOST_RX);\r\nd->sbdma_maxdescr = maxdescr;\r\nd->sbdma_dscrtable_unaligned = kcalloc(d->sbdma_maxdescr + 1,\r\nsizeof(*d->sbdma_dscrtable),\r\nGFP_KERNEL);\r\nd->sbdma_dscrtable = (struct sbdmadscr *)\r\nALIGN((unsigned long)d->sbdma_dscrtable_unaligned,\r\nsizeof(*d->sbdma_dscrtable));\r\nd->sbdma_dscrtable_end = d->sbdma_dscrtable + d->sbdma_maxdescr;\r\nd->sbdma_dscrtable_phys = virt_to_phys(d->sbdma_dscrtable);\r\nd->sbdma_ctxtable = kcalloc(d->sbdma_maxdescr,\r\nsizeof(*d->sbdma_ctxtable), GFP_KERNEL);\r\n#ifdef CONFIG_SBMAC_COALESCE\r\nint_pktcnt = (txrx == DMA_TX) ? int_pktcnt_tx : int_pktcnt_rx;\r\nif ( int_pktcnt ) {\r\nd->sbdma_int_pktcnt = int_pktcnt;\r\n} else {\r\nd->sbdma_int_pktcnt = 1;\r\n}\r\nint_timeout = (txrx == DMA_TX) ? int_timeout_tx : int_timeout_rx;\r\nif ( int_timeout ) {\r\nd->sbdma_int_timeout = int_timeout;\r\n} else {\r\nd->sbdma_int_timeout = 0;\r\n}\r\n#endif\r\n}\r\nstatic void sbdma_channel_start(struct sbmacdma *d, int rxtx)\r\n{\r\n#ifdef CONFIG_SBMAC_COALESCE\r\n__raw_writeq(V_DMA_INT_TIMEOUT(d->sbdma_int_timeout) |\r\n0, d->sbdma_config1);\r\n__raw_writeq(M_DMA_EOP_INT_EN |\r\nV_DMA_RINGSZ(d->sbdma_maxdescr) |\r\nV_DMA_INT_PKTCNT(d->sbdma_int_pktcnt) |\r\n0, d->sbdma_config0);\r\n#else\r\n__raw_writeq(0, d->sbdma_config1);\r\n__raw_writeq(V_DMA_RINGSZ(d->sbdma_maxdescr) |\r\n0, d->sbdma_config0);\r\n#endif\r\n__raw_writeq(d->sbdma_dscrtable_phys, d->sbdma_dscrbase);\r\nd->sbdma_addptr = d->sbdma_dscrtable;\r\nd->sbdma_remptr = d->sbdma_dscrtable;\r\n}\r\nstatic void sbdma_channel_stop(struct sbmacdma *d)\r\n{\r\n__raw_writeq(0, d->sbdma_config1);\r\n__raw_writeq(0, d->sbdma_dscrbase);\r\n__raw_writeq(0, d->sbdma_config0);\r\nd->sbdma_addptr = NULL;\r\nd->sbdma_remptr = NULL;\r\n}\r\nstatic inline void sbdma_align_skb(struct sk_buff *skb,\r\nunsigned int power2, unsigned int offset)\r\n{\r\nunsigned char *addr = skb->data;\r\nunsigned char *newaddr = PTR_ALIGN(addr, power2);\r\nskb_reserve(skb, newaddr - addr + offset);\r\n}\r\nstatic int sbdma_add_rcvbuffer(struct sbmac_softc *sc, struct sbmacdma *d,\r\nstruct sk_buff *sb)\r\n{\r\nstruct net_device *dev = sc->sbm_dev;\r\nstruct sbdmadscr *dsc;\r\nstruct sbdmadscr *nextdsc;\r\nstruct sk_buff *sb_new = NULL;\r\nint pktsize = ENET_PACKET_SIZE;\r\ndsc = d->sbdma_addptr;\r\nnextdsc = SBDMA_NEXTBUF(d,sbdma_addptr);\r\nif (nextdsc == d->sbdma_remptr) {\r\nreturn -ENOSPC;\r\n}\r\nif (sb == NULL) {\r\nsb_new = netdev_alloc_skb(dev, ENET_PACKET_SIZE +\r\nSMP_CACHE_BYTES * 2 +\r\nNET_IP_ALIGN);\r\nif (sb_new == NULL)\r\nreturn -ENOBUFS;\r\nsbdma_align_skb(sb_new, SMP_CACHE_BYTES, NET_IP_ALIGN);\r\n}\r\nelse {\r\nsb_new = sb;\r\n}\r\n#ifdef CONFIG_SBMAC_COALESCE\r\ndsc->dscr_a = virt_to_phys(sb_new->data) |\r\nV_DMA_DSCRA_A_SIZE(NUMCACHEBLKS(pktsize + NET_IP_ALIGN)) | 0;\r\n#else\r\ndsc->dscr_a = virt_to_phys(sb_new->data) |\r\nV_DMA_DSCRA_A_SIZE(NUMCACHEBLKS(pktsize + NET_IP_ALIGN)) |\r\nM_DMA_DSCRA_INTERRUPT;\r\n#endif\r\ndsc->dscr_b = 0;\r\nd->sbdma_ctxtable[dsc-d->sbdma_dscrtable] = sb_new;\r\nd->sbdma_addptr = nextdsc;\r\n__raw_writeq(1, d->sbdma_dscrcnt);\r\nreturn 0;\r\n}\r\nstatic int sbdma_add_txbuffer(struct sbmacdma *d, struct sk_buff *sb)\r\n{\r\nstruct sbdmadscr *dsc;\r\nstruct sbdmadscr *nextdsc;\r\nuint64_t phys;\r\nuint64_t ncb;\r\nint length;\r\ndsc = d->sbdma_addptr;\r\nnextdsc = SBDMA_NEXTBUF(d,sbdma_addptr);\r\nif (nextdsc == d->sbdma_remptr) {\r\nreturn -ENOSPC;\r\n}\r\nlength = sb->len;\r\nphys = virt_to_phys(sb->data);\r\nncb = NUMCACHEBLKS(length+(phys & (SMP_CACHE_BYTES - 1)));\r\ndsc->dscr_a = phys |\r\nV_DMA_DSCRA_A_SIZE(ncb) |\r\n#ifndef CONFIG_SBMAC_COALESCE\r\nM_DMA_DSCRA_INTERRUPT |\r\n#endif\r\nM_DMA_ETHTX_SOP;\r\ndsc->dscr_b = V_DMA_DSCRB_OPTIONS(K_DMA_ETHTX_APPENDCRC_APPENDPAD) |\r\nV_DMA_DSCRB_PKT_SIZE(length);\r\nd->sbdma_ctxtable[dsc-d->sbdma_dscrtable] = sb;\r\nd->sbdma_addptr = nextdsc;\r\n__raw_writeq(1, d->sbdma_dscrcnt);\r\nreturn 0;\r\n}\r\nstatic void sbdma_emptyring(struct sbmacdma *d)\r\n{\r\nint idx;\r\nstruct sk_buff *sb;\r\nfor (idx = 0; idx < d->sbdma_maxdescr; idx++) {\r\nsb = d->sbdma_ctxtable[idx];\r\nif (sb) {\r\ndev_kfree_skb(sb);\r\nd->sbdma_ctxtable[idx] = NULL;\r\n}\r\n}\r\n}\r\nstatic void sbdma_fillring(struct sbmac_softc *sc, struct sbmacdma *d)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < SBMAC_MAX_RXDESCR - 1; idx++) {\r\nif (sbdma_add_rcvbuffer(sc, d, NULL) != 0)\r\nbreak;\r\n}\r\n}\r\nstatic void sbmac_netpoll(struct net_device *netdev)\r\n{\r\nstruct sbmac_softc *sc = netdev_priv(netdev);\r\nint irq = sc->sbm_dev->irq;\r\n__raw_writeq(0, sc->sbm_imr);\r\nsbmac_intr(irq, netdev);\r\n#ifdef CONFIG_SBMAC_COALESCE\r\n__raw_writeq(((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |\r\n((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_RX_CH0),\r\nsc->sbm_imr);\r\n#else\r\n__raw_writeq((M_MAC_INT_CHANNEL << S_MAC_TX_CH0) |\r\n(M_MAC_INT_CHANNEL << S_MAC_RX_CH0), sc->sbm_imr);\r\n#endif\r\n}\r\nstatic int sbdma_rx_process(struct sbmac_softc *sc, struct sbmacdma *d,\r\nint work_to_do, int poll)\r\n{\r\nstruct net_device *dev = sc->sbm_dev;\r\nint curidx;\r\nint hwidx;\r\nstruct sbdmadscr *dsc;\r\nstruct sk_buff *sb;\r\nint len;\r\nint work_done = 0;\r\nint dropped = 0;\r\nprefetch(d);\r\nagain:\r\ndev->stats.rx_fifo_errors\r\n+= __raw_readq(sc->sbm_rxdma.sbdma_oodpktlost) & 0xffff;\r\n__raw_writeq(0, sc->sbm_rxdma.sbdma_oodpktlost);\r\nwhile (work_to_do-- > 0) {\r\ndsc = d->sbdma_remptr;\r\ncuridx = dsc - d->sbdma_dscrtable;\r\nprefetch(dsc);\r\nprefetch(&d->sbdma_ctxtable[curidx]);\r\nhwidx = ((__raw_readq(d->sbdma_curdscr) & M_DMA_CURDSCR_ADDR) -\r\nd->sbdma_dscrtable_phys) /\r\nsizeof(*d->sbdma_dscrtable);\r\nif (curidx == hwidx)\r\ngoto done;\r\nsb = d->sbdma_ctxtable[curidx];\r\nd->sbdma_ctxtable[curidx] = NULL;\r\nlen = (int)G_DMA_DSCRB_PKT_SIZE(dsc->dscr_b) - 4;\r\nif (likely (!(dsc->dscr_a & M_DMA_ETHRX_BAD))) {\r\nif (unlikely(sbdma_add_rcvbuffer(sc, d, NULL) ==\r\n-ENOBUFS)) {\r\ndev->stats.rx_dropped++;\r\nsbdma_add_rcvbuffer(sc, d, sb);\r\nprintk(KERN_ERR "dropped packet (1)\n");\r\nd->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);\r\ngoto done;\r\n} else {\r\nskb_put(sb,len);\r\nsb->protocol = eth_type_trans(sb,d->sbdma_eth->sbm_dev);\r\nif (sc->rx_hw_checksum == ENABLE) {\r\nif (!((dsc->dscr_a) & M_DMA_ETHRX_BADIP4CS) &&\r\n!((dsc->dscr_a) & M_DMA_ETHRX_BADTCPCS)) {\r\nsb->ip_summed = CHECKSUM_UNNECESSARY;\r\n} else {\r\nskb_checksum_none_assert(sb);\r\n}\r\n}\r\nprefetch(sb->data);\r\nprefetch((const void *)(((char *)sb->data)+32));\r\nif (poll)\r\ndropped = netif_receive_skb(sb);\r\nelse\r\ndropped = netif_rx(sb);\r\nif (dropped == NET_RX_DROP) {\r\ndev->stats.rx_dropped++;\r\nd->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);\r\ngoto done;\r\n}\r\nelse {\r\ndev->stats.rx_bytes += len;\r\ndev->stats.rx_packets++;\r\n}\r\n}\r\n} else {\r\ndev->stats.rx_errors++;\r\nsbdma_add_rcvbuffer(sc, d, sb);\r\n}\r\nd->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);\r\nwork_done++;\r\n}\r\nif (!poll) {\r\nwork_to_do = 32;\r\ngoto again;\r\n}\r\ndone:\r\nreturn work_done;\r\n}\r\nstatic void sbdma_tx_process(struct sbmac_softc *sc, struct sbmacdma *d,\r\nint poll)\r\n{\r\nstruct net_device *dev = sc->sbm_dev;\r\nint curidx;\r\nint hwidx;\r\nstruct sbdmadscr *dsc;\r\nstruct sk_buff *sb;\r\nunsigned long flags;\r\nint packets_handled = 0;\r\nspin_lock_irqsave(&(sc->sbm_lock), flags);\r\nif (d->sbdma_remptr == d->sbdma_addptr)\r\ngoto end_unlock;\r\nhwidx = ((__raw_readq(d->sbdma_curdscr) & M_DMA_CURDSCR_ADDR) -\r\nd->sbdma_dscrtable_phys) / sizeof(*d->sbdma_dscrtable);\r\nfor (;;) {\r\ncuridx = d->sbdma_remptr - d->sbdma_dscrtable;\r\nif (curidx == hwidx)\r\nbreak;\r\ndsc = &(d->sbdma_dscrtable[curidx]);\r\nsb = d->sbdma_ctxtable[curidx];\r\nd->sbdma_ctxtable[curidx] = NULL;\r\ndev->stats.tx_bytes += sb->len;\r\ndev->stats.tx_packets++;\r\ndev_kfree_skb_irq(sb);\r\nd->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);\r\npackets_handled++;\r\n}\r\nif (packets_handled)\r\nnetif_wake_queue(d->sbdma_eth->sbm_dev);\r\nend_unlock:\r\nspin_unlock_irqrestore(&(sc->sbm_lock), flags);\r\n}\r\nstatic int sbmac_initctx(struct sbmac_softc *s)\r\n{\r\ns->sbm_macenable = s->sbm_base + R_MAC_ENABLE;\r\ns->sbm_maccfg = s->sbm_base + R_MAC_CFG;\r\ns->sbm_fifocfg = s->sbm_base + R_MAC_THRSH_CFG;\r\ns->sbm_framecfg = s->sbm_base + R_MAC_FRAMECFG;\r\ns->sbm_rxfilter = s->sbm_base + R_MAC_ADFILTER_CFG;\r\ns->sbm_isr = s->sbm_base + R_MAC_STATUS;\r\ns->sbm_imr = s->sbm_base + R_MAC_INT_MASK;\r\ns->sbm_mdio = s->sbm_base + R_MAC_MDIO;\r\nsbdma_initctx(&(s->sbm_txdma),s,0,DMA_TX,SBMAC_MAX_TXDESCR);\r\nsbdma_initctx(&(s->sbm_rxdma),s,0,DMA_RX,SBMAC_MAX_RXDESCR);\r\ns->sbm_state = sbmac_state_off;\r\nreturn 0;\r\n}\r\nstatic void sbdma_uninitctx(struct sbmacdma *d)\r\n{\r\nif (d->sbdma_dscrtable_unaligned) {\r\nkfree(d->sbdma_dscrtable_unaligned);\r\nd->sbdma_dscrtable_unaligned = d->sbdma_dscrtable = NULL;\r\n}\r\nif (d->sbdma_ctxtable) {\r\nkfree(d->sbdma_ctxtable);\r\nd->sbdma_ctxtable = NULL;\r\n}\r\n}\r\nstatic void sbmac_uninitctx(struct sbmac_softc *sc)\r\n{\r\nsbdma_uninitctx(&(sc->sbm_txdma));\r\nsbdma_uninitctx(&(sc->sbm_rxdma));\r\n}\r\nstatic void sbmac_channel_start(struct sbmac_softc *s)\r\n{\r\nuint64_t reg;\r\nvoid __iomem *port;\r\nuint64_t cfg,fifo,framecfg;\r\nint idx, th_value;\r\nif (s->sbm_state == sbmac_state_on)\r\nreturn;\r\n__raw_writeq(0, s->sbm_macenable);\r\n__raw_writeq(0, s->sbm_rxfilter);\r\ncfg = M_MAC_RETRY_EN |\r\nM_MAC_TX_HOLD_SOP_EN |\r\nV_MAC_TX_PAUSE_CNT_16K |\r\nM_MAC_AP_STAT_EN |\r\nM_MAC_FAST_SYNC |\r\nM_MAC_SS_EN |\r\n0;\r\nif (soc_type == K_SYS_SOC_TYPE_BCM1250 && periph_rev < 2)\r\nth_value = 28;\r\nelse\r\nth_value = 64;\r\nfifo = V_MAC_TX_WR_THRSH(4) |\r\n((s->sbm_speed == sbmac_speed_1000)\r\n? V_MAC_TX_RD_THRSH(th_value) : V_MAC_TX_RD_THRSH(4)) |\r\nV_MAC_TX_RL_THRSH(4) |\r\nV_MAC_RX_PL_THRSH(4) |\r\nV_MAC_RX_RD_THRSH(4) |\r\nV_MAC_RX_RL_THRSH(8) |\r\n0;\r\nframecfg = V_MAC_MIN_FRAMESZ_DEFAULT |\r\nV_MAC_MAX_FRAMESZ_DEFAULT |\r\nV_MAC_BACKOFF_SEL(1);\r\nport = s->sbm_base + R_MAC_HASH_BASE;\r\nfor (idx = 0; idx < MAC_HASH_COUNT; idx++) {\r\n__raw_writeq(0, port);\r\nport += sizeof(uint64_t);\r\n}\r\nport = s->sbm_base + R_MAC_ADDR_BASE;\r\nfor (idx = 0; idx < MAC_ADDR_COUNT; idx++) {\r\n__raw_writeq(0, port);\r\nport += sizeof(uint64_t);\r\n}\r\nport = s->sbm_base + R_MAC_CHUP0_BASE;\r\nfor (idx = 0; idx < MAC_CHMAP_COUNT; idx++) {\r\n__raw_writeq(0, port);\r\nport += sizeof(uint64_t);\r\n}\r\nport = s->sbm_base + R_MAC_CHLO0_BASE;\r\nfor (idx = 0; idx < MAC_CHMAP_COUNT; idx++) {\r\n__raw_writeq(0, port);\r\nport += sizeof(uint64_t);\r\n}\r\nreg = sbmac_addr2reg(s->sbm_hwaddr);\r\nport = s->sbm_base + R_MAC_ADDR_BASE;\r\n__raw_writeq(reg, port);\r\nport = s->sbm_base + R_MAC_ETHERNET_ADDR;\r\n__raw_writeq(reg, port);\r\n__raw_writeq(0, s->sbm_rxfilter);\r\n__raw_writeq(0, s->sbm_imr);\r\n__raw_writeq(framecfg, s->sbm_framecfg);\r\n__raw_writeq(fifo, s->sbm_fifocfg);\r\n__raw_writeq(cfg, s->sbm_maccfg);\r\nsbdma_channel_start(&(s->sbm_rxdma), DMA_RX);\r\nsbdma_channel_start(&(s->sbm_txdma), DMA_TX);\r\nsbmac_set_speed(s,s->sbm_speed);\r\nsbmac_set_duplex(s,s->sbm_duplex,s->sbm_fc);\r\nsbdma_fillring(s, &(s->sbm_rxdma));\r\n#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)\r\n__raw_writeq(M_MAC_RXDMA_EN0 |\r\nM_MAC_TXDMA_EN0, s->sbm_macenable);\r\n#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)\r\n__raw_writeq(M_MAC_RXDMA_EN0 |\r\nM_MAC_TXDMA_EN0 |\r\nM_MAC_RX_ENABLE |\r\nM_MAC_TX_ENABLE, s->sbm_macenable);\r\n#else\r\n#error invalid SiByte MAC configuration\r\n#endif\r\n#ifdef CONFIG_SBMAC_COALESCE\r\n__raw_writeq(((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |\r\n((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_RX_CH0), s->sbm_imr);\r\n#else\r\n__raw_writeq((M_MAC_INT_CHANNEL << S_MAC_TX_CH0) |\r\n(M_MAC_INT_CHANNEL << S_MAC_RX_CH0), s->sbm_imr);\r\n#endif\r\n__raw_writeq(M_MAC_UCAST_EN | M_MAC_BCAST_EN, s->sbm_rxfilter);\r\ns->sbm_state = sbmac_state_on;\r\nsbmac_setmulti(s);\r\nif (s->sbm_devflags & IFF_PROMISC) {\r\nsbmac_promiscuous_mode(s,1);\r\n}\r\n}\r\nstatic void sbmac_channel_stop(struct sbmac_softc *s)\r\n{\r\nif (s->sbm_state == sbmac_state_off)\r\nreturn;\r\n__raw_writeq(0, s->sbm_rxfilter);\r\n__raw_writeq(0, s->sbm_imr);\r\n__raw_writeq(0, s->sbm_macenable);\r\ns->sbm_state = sbmac_state_off;\r\nsbdma_channel_stop(&(s->sbm_rxdma));\r\nsbdma_channel_stop(&(s->sbm_txdma));\r\nsbdma_emptyring(&(s->sbm_rxdma));\r\nsbdma_emptyring(&(s->sbm_txdma));\r\n}\r\nstatic enum sbmac_state sbmac_set_channel_state(struct sbmac_softc *sc,\r\nenum sbmac_state state)\r\n{\r\nenum sbmac_state oldstate = sc->sbm_state;\r\nif (state == oldstate) {\r\nreturn oldstate;\r\n}\r\nif (state == sbmac_state_on) {\r\nsbmac_channel_start(sc);\r\n}\r\nelse {\r\nsbmac_channel_stop(sc);\r\n}\r\nreturn oldstate;\r\n}\r\nstatic void sbmac_promiscuous_mode(struct sbmac_softc *sc,int onoff)\r\n{\r\nuint64_t reg;\r\nif (sc->sbm_state != sbmac_state_on)\r\nreturn;\r\nif (onoff) {\r\nreg = __raw_readq(sc->sbm_rxfilter);\r\nreg |= M_MAC_ALLPKT_EN;\r\n__raw_writeq(reg, sc->sbm_rxfilter);\r\n}\r\nelse {\r\nreg = __raw_readq(sc->sbm_rxfilter);\r\nreg &= ~M_MAC_ALLPKT_EN;\r\n__raw_writeq(reg, sc->sbm_rxfilter);\r\n}\r\n}\r\nstatic void sbmac_set_iphdr_offset(struct sbmac_softc *sc)\r\n{\r\nuint64_t reg;\r\nreg = __raw_readq(sc->sbm_rxfilter);\r\nreg &= ~M_MAC_IPHDR_OFFSET | V_MAC_IPHDR_OFFSET(15);\r\n__raw_writeq(reg, sc->sbm_rxfilter);\r\nif (soc_type == K_SYS_SOC_TYPE_BCM1250 && periph_rev < 2) {\r\nsc->rx_hw_checksum = DISABLE;\r\n} else {\r\nsc->rx_hw_checksum = ENABLE;\r\n}\r\n}\r\nstatic uint64_t sbmac_addr2reg(unsigned char *ptr)\r\n{\r\nuint64_t reg = 0;\r\nptr += 6;\r\nreg |= (uint64_t) *(--ptr);\r\nreg <<= 8;\r\nreg |= (uint64_t) *(--ptr);\r\nreg <<= 8;\r\nreg |= (uint64_t) *(--ptr);\r\nreg <<= 8;\r\nreg |= (uint64_t) *(--ptr);\r\nreg <<= 8;\r\nreg |= (uint64_t) *(--ptr);\r\nreg <<= 8;\r\nreg |= (uint64_t) *(--ptr);\r\nreturn reg;\r\n}\r\nstatic int sbmac_set_speed(struct sbmac_softc *s, enum sbmac_speed speed)\r\n{\r\nuint64_t cfg;\r\nuint64_t framecfg;\r\ns->sbm_speed = speed;\r\nif (s->sbm_state == sbmac_state_on)\r\nreturn 0;\r\ncfg = __raw_readq(s->sbm_maccfg);\r\nframecfg = __raw_readq(s->sbm_framecfg);\r\ncfg &= ~(M_MAC_BURST_EN | M_MAC_SPEED_SEL);\r\nframecfg &= ~(M_MAC_IFG_RX | M_MAC_IFG_TX | M_MAC_IFG_THRSH |\r\nM_MAC_SLOT_SIZE);\r\nswitch (speed) {\r\ncase sbmac_speed_10:\r\nframecfg |= V_MAC_IFG_RX_10 |\r\nV_MAC_IFG_TX_10 |\r\nK_MAC_IFG_THRSH_10 |\r\nV_MAC_SLOT_SIZE_10;\r\ncfg |= V_MAC_SPEED_SEL_10MBPS;\r\nbreak;\r\ncase sbmac_speed_100:\r\nframecfg |= V_MAC_IFG_RX_100 |\r\nV_MAC_IFG_TX_100 |\r\nV_MAC_IFG_THRSH_100 |\r\nV_MAC_SLOT_SIZE_100;\r\ncfg |= V_MAC_SPEED_SEL_100MBPS ;\r\nbreak;\r\ncase sbmac_speed_1000:\r\nframecfg |= V_MAC_IFG_RX_1000 |\r\nV_MAC_IFG_TX_1000 |\r\nV_MAC_IFG_THRSH_1000 |\r\nV_MAC_SLOT_SIZE_1000;\r\ncfg |= V_MAC_SPEED_SEL_1000MBPS | M_MAC_BURST_EN;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n__raw_writeq(framecfg, s->sbm_framecfg);\r\n__raw_writeq(cfg, s->sbm_maccfg);\r\nreturn 1;\r\n}\r\nstatic int sbmac_set_duplex(struct sbmac_softc *s, enum sbmac_duplex duplex,\r\nenum sbmac_fc fc)\r\n{\r\nuint64_t cfg;\r\ns->sbm_duplex = duplex;\r\ns->sbm_fc = fc;\r\nif (s->sbm_state == sbmac_state_on)\r\nreturn 0;\r\ncfg = __raw_readq(s->sbm_maccfg);\r\ncfg &= ~(M_MAC_FC_SEL | M_MAC_FC_CMD | M_MAC_HDX_EN);\r\nswitch (duplex) {\r\ncase sbmac_duplex_half:\r\nswitch (fc) {\r\ncase sbmac_fc_disabled:\r\ncfg |= M_MAC_HDX_EN | V_MAC_FC_CMD_DISABLED;\r\nbreak;\r\ncase sbmac_fc_collision:\r\ncfg |= M_MAC_HDX_EN | V_MAC_FC_CMD_ENABLED;\r\nbreak;\r\ncase sbmac_fc_carrier:\r\ncfg |= M_MAC_HDX_EN | V_MAC_FC_CMD_ENAB_FALSECARR;\r\nbreak;\r\ncase sbmac_fc_frame:\r\ndefault:\r\nreturn 0;\r\n}\r\nbreak;\r\ncase sbmac_duplex_full:\r\nswitch (fc) {\r\ncase sbmac_fc_disabled:\r\ncfg |= V_MAC_FC_CMD_DISABLED;\r\nbreak;\r\ncase sbmac_fc_frame:\r\ncfg |= V_MAC_FC_CMD_ENABLED;\r\nbreak;\r\ncase sbmac_fc_collision:\r\ncase sbmac_fc_carrier:\r\ndefault:\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n__raw_writeq(cfg, s->sbm_maccfg);\r\nreturn 1;\r\n}\r\nstatic irqreturn_t sbmac_intr(int irq,void *dev_instance)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_instance;\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nuint64_t isr;\r\nint handled = 0;\r\nisr = __raw_readq(sc->sbm_isr) & ~M_MAC_COUNTER_ADDR;\r\nif (isr == 0)\r\nreturn IRQ_RETVAL(0);\r\nhandled = 1;\r\nif (isr & (M_MAC_INT_CHANNEL << S_MAC_TX_CH0))\r\nsbdma_tx_process(sc,&(sc->sbm_txdma), 0);\r\nif (isr & (M_MAC_INT_CHANNEL << S_MAC_RX_CH0)) {\r\nif (napi_schedule_prep(&sc->napi)) {\r\n__raw_writeq(0, sc->sbm_imr);\r\n__napi_schedule(&sc->napi);\r\n}\r\nelse {\r\nsbdma_rx_process(sc,&(sc->sbm_rxdma),\r\nSBMAC_MAX_RXDESCR * 2, 0);\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int sbmac_start_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&sc->sbm_lock, flags);\r\nif (sbdma_add_txbuffer(&(sc->sbm_txdma),skb)) {\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&sc->sbm_lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nspin_unlock_irqrestore(&sc->sbm_lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void sbmac_setmulti(struct sbmac_softc *sc)\r\n{\r\nuint64_t reg;\r\nvoid __iomem *port;\r\nint idx;\r\nstruct netdev_hw_addr *ha;\r\nstruct net_device *dev = sc->sbm_dev;\r\nfor (idx = 1; idx < MAC_ADDR_COUNT; idx++) {\r\nport = sc->sbm_base + R_MAC_ADDR_BASE+(idx*sizeof(uint64_t));\r\n__raw_writeq(0, port);\r\n}\r\nfor (idx = 0; idx < MAC_HASH_COUNT; idx++) {\r\nport = sc->sbm_base + R_MAC_HASH_BASE+(idx*sizeof(uint64_t));\r\n__raw_writeq(0, port);\r\n}\r\nreg = __raw_readq(sc->sbm_rxfilter);\r\nreg &= ~(M_MAC_MCAST_INV | M_MAC_MCAST_EN);\r\n__raw_writeq(reg, sc->sbm_rxfilter);\r\nif (dev->flags & IFF_ALLMULTI) {\r\nreg = __raw_readq(sc->sbm_rxfilter);\r\nreg |= (M_MAC_MCAST_INV | M_MAC_MCAST_EN);\r\n__raw_writeq(reg, sc->sbm_rxfilter);\r\nreturn;\r\n}\r\nidx = 1;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nif (idx == MAC_ADDR_COUNT)\r\nbreak;\r\nreg = sbmac_addr2reg(ha->addr);\r\nport = sc->sbm_base + R_MAC_ADDR_BASE+(idx * sizeof(uint64_t));\r\n__raw_writeq(reg, port);\r\nidx++;\r\n}\r\nif (idx > 1) {\r\nreg = __raw_readq(sc->sbm_rxfilter);\r\nreg |= M_MAC_MCAST_EN;\r\n__raw_writeq(reg, sc->sbm_rxfilter);\r\n}\r\n}\r\nstatic int sb1250_change_mtu(struct net_device *_dev, int new_mtu)\r\n{\r\nif (new_mtu > ENET_PACKET_SIZE)\r\nreturn -EINVAL;\r\n_dev->mtu = new_mtu;\r\npr_info("changing the mtu to %d\n", new_mtu);\r\nreturn 0;\r\n}\r\nstatic int sbmac_init(struct platform_device *pldev, long long base)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pldev);\r\nint idx = pldev->id;\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nunsigned char *eaddr;\r\nuint64_t ea_reg;\r\nint i;\r\nint err;\r\nsc->sbm_dev = dev;\r\nsc->sbe_idx = idx;\r\neaddr = sc->sbm_hwaddr;\r\nea_reg = __raw_readq(sc->sbm_base + R_MAC_ETHERNET_ADDR);\r\n__raw_writeq(0, sc->sbm_base + R_MAC_ETHERNET_ADDR);\r\nfor (i = 0; i < 6; i++) {\r\neaddr[i] = (uint8_t) (ea_reg & 0xFF);\r\nea_reg >>= 8;\r\n}\r\nfor (i = 0; i < 6; i++) {\r\ndev->dev_addr[i] = eaddr[i];\r\n}\r\nsbmac_initctx(sc);\r\nspin_lock_init(&(sc->sbm_lock));\r\ndev->netdev_ops = &sbmac_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nnetif_napi_add(dev, &sc->napi, sbmac_poll, 16);\r\ndev->irq = UNIT_INT(idx);\r\nsbmac_set_iphdr_offset(sc);\r\nsc->mii_bus = mdiobus_alloc();\r\nif (sc->mii_bus == NULL) {\r\nerr = -ENOMEM;\r\ngoto uninit_ctx;\r\n}\r\nsc->mii_bus->name = sbmac_mdio_string;\r\nsnprintf(sc->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\npldev->name, idx);\r\nsc->mii_bus->priv = sc;\r\nsc->mii_bus->read = sbmac_mii_read;\r\nsc->mii_bus->write = sbmac_mii_write;\r\nsc->mii_bus->parent = &pldev->dev;\r\nerr = mdiobus_register(sc->mii_bus);\r\nif (err) {\r\nprintk(KERN_ERR "%s: unable to register MDIO bus\n",\r\ndev->name);\r\ngoto free_mdio;\r\n}\r\nplatform_set_drvdata(pldev, sc->mii_bus);\r\nerr = register_netdev(dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s.%d: unable to register netdev\n",\r\nsbmac_string, idx);\r\ngoto unreg_mdio;\r\n}\r\npr_info("%s.%d: registered as %s\n", sbmac_string, idx, dev->name);\r\nif (sc->rx_hw_checksum == ENABLE)\r\npr_info("%s: enabling TCP rcv checksum\n", dev->name);\r\npr_info("%s: SiByte Ethernet at 0x%08Lx, address: %pM\n",\r\ndev->name, base, eaddr);\r\nreturn 0;\r\nunreg_mdio:\r\nmdiobus_unregister(sc->mii_bus);\r\nfree_mdio:\r\nmdiobus_free(sc->mii_bus);\r\nuninit_ctx:\r\nsbmac_uninitctx(sc);\r\nreturn err;\r\n}\r\nstatic int sbmac_open(struct net_device *dev)\r\n{\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nint err;\r\nif (debug > 1)\r\npr_debug("%s: sbmac_open() irq %d.\n", dev->name, dev->irq);\r\n__raw_readq(sc->sbm_isr);\r\nerr = request_irq(dev->irq, sbmac_intr, IRQF_SHARED, dev->name, dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s: unable to get IRQ %d\n", dev->name,\r\ndev->irq);\r\ngoto out_err;\r\n}\r\nsc->sbm_speed = sbmac_speed_none;\r\nsc->sbm_duplex = sbmac_duplex_none;\r\nsc->sbm_fc = sbmac_fc_none;\r\nsc->sbm_pause = -1;\r\nsc->sbm_link = 0;\r\nerr = sbmac_mii_probe(dev);\r\nif (err)\r\ngoto out_unregister;\r\nsbmac_set_channel_state(sc,sbmac_state_on);\r\nnetif_start_queue(dev);\r\nsbmac_set_rx_mode(dev);\r\nphy_start(sc->phy_dev);\r\nnapi_enable(&sc->napi);\r\nreturn 0;\r\nout_unregister:\r\nfree_irq(dev->irq, dev);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int sbmac_mii_probe(struct net_device *dev)\r\n{\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nstruct phy_device *phy_dev;\r\nphy_dev = phy_find_first(sc->mii_bus);\r\nif (!phy_dev) {\r\nprintk(KERN_ERR "%s: no PHY found\n", dev->name);\r\nreturn -ENXIO;\r\n}\r\nphy_dev = phy_connect(dev, dev_name(&phy_dev->mdio.dev),\r\n&sbmac_mii_poll, PHY_INTERFACE_MODE_GMII);\r\nif (IS_ERR(phy_dev)) {\r\nprintk(KERN_ERR "%s: could not attach to PHY\n", dev->name);\r\nreturn PTR_ERR(phy_dev);\r\n}\r\nphy_dev->supported &= SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_MII |\r\nSUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause;\r\nphy_attached_info(phy_dev);\r\nphy_dev->advertising = phy_dev->supported;\r\nsc->phy_dev = phy_dev;\r\nreturn 0;\r\n}\r\nstatic void sbmac_mii_poll(struct net_device *dev)\r\n{\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nstruct phy_device *phy_dev = sc->phy_dev;\r\nunsigned long flags;\r\nenum sbmac_fc fc;\r\nint link_chg, speed_chg, duplex_chg, pause_chg, fc_chg;\r\nlink_chg = (sc->sbm_link != phy_dev->link);\r\nspeed_chg = (sc->sbm_speed != phy_dev->speed);\r\nduplex_chg = (sc->sbm_duplex != phy_dev->duplex);\r\npause_chg = (sc->sbm_pause != phy_dev->pause);\r\nif (!link_chg && !speed_chg && !duplex_chg && !pause_chg)\r\nreturn;\r\nif (!phy_dev->link) {\r\nif (link_chg) {\r\nsc->sbm_link = phy_dev->link;\r\nsc->sbm_speed = sbmac_speed_none;\r\nsc->sbm_duplex = sbmac_duplex_none;\r\nsc->sbm_fc = sbmac_fc_disabled;\r\nsc->sbm_pause = -1;\r\npr_info("%s: link unavailable\n", dev->name);\r\n}\r\nreturn;\r\n}\r\nif (phy_dev->duplex == DUPLEX_FULL) {\r\nif (phy_dev->pause)\r\nfc = sbmac_fc_frame;\r\nelse\r\nfc = sbmac_fc_disabled;\r\n} else\r\nfc = sbmac_fc_collision;\r\nfc_chg = (sc->sbm_fc != fc);\r\npr_info("%s: link available: %dbase-%cD\n", dev->name, phy_dev->speed,\r\nphy_dev->duplex == DUPLEX_FULL ? 'F' : 'H');\r\nspin_lock_irqsave(&sc->sbm_lock, flags);\r\nsc->sbm_speed = phy_dev->speed;\r\nsc->sbm_duplex = phy_dev->duplex;\r\nsc->sbm_fc = fc;\r\nsc->sbm_pause = phy_dev->pause;\r\nsc->sbm_link = phy_dev->link;\r\nif ((speed_chg || duplex_chg || fc_chg) &&\r\nsc->sbm_state != sbmac_state_off) {\r\nif (debug > 1)\r\npr_debug("%s: restarting channel "\r\n"because PHY state changed\n", dev->name);\r\nsbmac_channel_stop(sc);\r\nsbmac_channel_start(sc);\r\n}\r\nspin_unlock_irqrestore(&sc->sbm_lock, flags);\r\n}\r\nstatic void sbmac_tx_timeout (struct net_device *dev)\r\n{\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&sc->sbm_lock, flags);\r\nnetif_trans_update(dev);\r\ndev->stats.tx_errors++;\r\nspin_unlock_irqrestore(&sc->sbm_lock, flags);\r\nprintk (KERN_WARNING "%s: Transmit timed out\n",dev->name);\r\n}\r\nstatic void sbmac_set_rx_mode(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nspin_lock_irqsave(&sc->sbm_lock, flags);\r\nif ((dev->flags ^ sc->sbm_devflags) & IFF_PROMISC) {\r\nif (dev->flags & IFF_PROMISC) {\r\nsbmac_promiscuous_mode(sc,1);\r\n}\r\nelse {\r\nsbmac_promiscuous_mode(sc,0);\r\n}\r\n}\r\nspin_unlock_irqrestore(&sc->sbm_lock, flags);\r\nsbmac_setmulti(sc);\r\n}\r\nstatic int sbmac_mii_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nif (!netif_running(dev) || !sc->phy_dev)\r\nreturn -EINVAL;\r\nreturn phy_mii_ioctl(sc->phy_dev, rq, cmd);\r\n}\r\nstatic int sbmac_close(struct net_device *dev)\r\n{\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nnapi_disable(&sc->napi);\r\nphy_stop(sc->phy_dev);\r\nsbmac_set_channel_state(sc, sbmac_state_off);\r\nnetif_stop_queue(dev);\r\nif (debug > 1)\r\npr_debug("%s: Shutting down ethercard\n", dev->name);\r\nphy_disconnect(sc->phy_dev);\r\nsc->phy_dev = NULL;\r\nfree_irq(dev->irq, dev);\r\nsbdma_emptyring(&(sc->sbm_txdma));\r\nsbdma_emptyring(&(sc->sbm_rxdma));\r\nreturn 0;\r\n}\r\nstatic int sbmac_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct sbmac_softc *sc = container_of(napi, struct sbmac_softc, napi);\r\nint work_done;\r\nwork_done = sbdma_rx_process(sc, &(sc->sbm_rxdma), budget, 1);\r\nsbdma_tx_process(sc, &(sc->sbm_txdma), 1);\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\n#ifdef CONFIG_SBMAC_COALESCE\r\n__raw_writeq(((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |\r\n((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_RX_CH0),\r\nsc->sbm_imr);\r\n#else\r\n__raw_writeq((M_MAC_INT_CHANNEL << S_MAC_TX_CH0) |\r\n(M_MAC_INT_CHANNEL << S_MAC_RX_CH0), sc->sbm_imr);\r\n#endif\r\n}\r\nreturn work_done;\r\n}\r\nstatic int sbmac_probe(struct platform_device *pldev)\r\n{\r\nstruct net_device *dev;\r\nstruct sbmac_softc *sc;\r\nvoid __iomem *sbm_base;\r\nstruct resource *res;\r\nu64 sbmac_orig_hwaddr;\r\nint err;\r\nres = platform_get_resource(pldev, IORESOURCE_MEM, 0);\r\nBUG_ON(!res);\r\nsbm_base = ioremap_nocache(res->start, resource_size(res));\r\nif (!sbm_base) {\r\nprintk(KERN_ERR "%s: unable to map device registers\n",\r\ndev_name(&pldev->dev));\r\nerr = -ENOMEM;\r\ngoto out_out;\r\n}\r\nsbmac_orig_hwaddr = __raw_readq(sbm_base + R_MAC_ETHERNET_ADDR);\r\npr_debug("%s: %sconfiguring MAC at 0x%08Lx\n", dev_name(&pldev->dev),\r\nsbmac_orig_hwaddr ? "" : "not ", (long long)res->start);\r\nif (sbmac_orig_hwaddr == 0) {\r\nerr = 0;\r\ngoto out_unmap;\r\n}\r\ndev = alloc_etherdev(sizeof(struct sbmac_softc));\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nplatform_set_drvdata(pldev, dev);\r\nSET_NETDEV_DEV(dev, &pldev->dev);\r\nsc = netdev_priv(dev);\r\nsc->sbm_base = sbm_base;\r\nerr = sbmac_init(pldev, res->start);\r\nif (err)\r\ngoto out_kfree;\r\nreturn 0;\r\nout_kfree:\r\nfree_netdev(dev);\r\n__raw_writeq(sbmac_orig_hwaddr, sbm_base + R_MAC_ETHERNET_ADDR);\r\nout_unmap:\r\niounmap(sbm_base);\r\nout_out:\r\nreturn err;\r\n}\r\nstatic int __exit sbmac_remove(struct platform_device *pldev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pldev);\r\nstruct sbmac_softc *sc = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nsbmac_uninitctx(sc);\r\nmdiobus_unregister(sc->mii_bus);\r\nmdiobus_free(sc->mii_bus);\r\niounmap(sc->sbm_base);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}
