static void threshold_init(struct threshold *t)\r\n{\r\nt->threshold_set = false;\r\nt->value_set = false;\r\n}\r\nstatic void set_threshold(struct threshold *t, dm_block_t value,\r\ndm_sm_threshold_fn fn, void *context)\r\n{\r\nt->threshold_set = true;\r\nt->threshold = value;\r\nt->fn = fn;\r\nt->context = context;\r\n}\r\nstatic bool below_threshold(struct threshold *t, dm_block_t value)\r\n{\r\nreturn t->threshold_set && value <= t->threshold;\r\n}\r\nstatic bool threshold_already_triggered(struct threshold *t)\r\n{\r\nreturn t->value_set && below_threshold(t, t->current_value);\r\n}\r\nstatic void check_threshold(struct threshold *t, dm_block_t value)\r\n{\r\nif (below_threshold(t, value) &&\r\n!threshold_already_triggered(t))\r\nt->fn(t->context);\r\nt->value_set = true;\r\nt->current_value = value;\r\n}\r\nstatic void brb_init(struct bop_ring_buffer *brb)\r\n{\r\nbrb->begin = 0;\r\nbrb->end = 0;\r\n}\r\nstatic bool brb_empty(struct bop_ring_buffer *brb)\r\n{\r\nreturn brb->begin == brb->end;\r\n}\r\nstatic unsigned brb_next(struct bop_ring_buffer *brb, unsigned old)\r\n{\r\nunsigned r = old + 1;\r\nreturn (r >= (sizeof(brb->bops) / sizeof(*brb->bops))) ? 0 : r;\r\n}\r\nstatic int brb_push(struct bop_ring_buffer *brb,\r\nenum block_op_type type, dm_block_t b)\r\n{\r\nstruct block_op *bop;\r\nunsigned next = brb_next(brb, brb->end);\r\nif (next == brb->begin)\r\nreturn -ENOMEM;\r\nbop = brb->bops + brb->end;\r\nbop->type = type;\r\nbop->block = b;\r\nbrb->end = next;\r\nreturn 0;\r\n}\r\nstatic int brb_peek(struct bop_ring_buffer *brb, struct block_op *result)\r\n{\r\nstruct block_op *bop;\r\nif (brb_empty(brb))\r\nreturn -ENODATA;\r\nbop = brb->bops + brb->begin;\r\nresult->type = bop->type;\r\nresult->block = bop->block;\r\nreturn 0;\r\n}\r\nstatic int brb_pop(struct bop_ring_buffer *brb)\r\n{\r\nif (brb_empty(brb))\r\nreturn -ENODATA;\r\nbrb->begin = brb_next(brb, brb->begin);\r\nreturn 0;\r\n}\r\nstatic int add_bop(struct sm_metadata *smm, enum block_op_type type, dm_block_t b)\r\n{\r\nint r = brb_push(&smm->uncommitted, type, b);\r\nif (r) {\r\nDMERR("too many recursive allocations");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int commit_bop(struct sm_metadata *smm, struct block_op *op)\r\n{\r\nint r = 0;\r\nenum allocation_event ev;\r\nswitch (op->type) {\r\ncase BOP_INC:\r\nr = sm_ll_inc(&smm->ll, op->block, &ev);\r\nbreak;\r\ncase BOP_DEC:\r\nr = sm_ll_dec(&smm->ll, op->block, &ev);\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic void in(struct sm_metadata *smm)\r\n{\r\nsmm->recursion_count++;\r\n}\r\nstatic int apply_bops(struct sm_metadata *smm)\r\n{\r\nint r = 0;\r\nwhile (!brb_empty(&smm->uncommitted)) {\r\nstruct block_op bop;\r\nr = brb_peek(&smm->uncommitted, &bop);\r\nif (r) {\r\nDMERR("bug in bop ring buffer");\r\nbreak;\r\n}\r\nr = commit_bop(smm, &bop);\r\nif (r)\r\nbreak;\r\nbrb_pop(&smm->uncommitted);\r\n}\r\nreturn r;\r\n}\r\nstatic int out(struct sm_metadata *smm)\r\n{\r\nint r = 0;\r\nif (!smm->recursion_count) {\r\nDMERR("lost track of recursion depth");\r\nreturn -ENOMEM;\r\n}\r\nif (smm->recursion_count == 1)\r\napply_bops(smm);\r\nsmm->recursion_count--;\r\nreturn r;\r\n}\r\nstatic int combine_errors(int r1, int r2)\r\n{\r\nreturn r1 ? r1 : r2;\r\n}\r\nstatic int recursing(struct sm_metadata *smm)\r\n{\r\nreturn smm->recursion_count;\r\n}\r\nstatic void sm_metadata_destroy(struct dm_space_map *sm)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nkfree(smm);\r\n}\r\nstatic int sm_metadata_get_nr_blocks(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\n*count = smm->ll.nr_blocks;\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_get_nr_free(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\n*count = smm->old_ll.nr_blocks - smm->old_ll.nr_allocated -\r\nsmm->allocated_this_transaction;\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_get_count(struct dm_space_map *sm, dm_block_t b,\r\nuint32_t *result)\r\n{\r\nint r;\r\nunsigned i;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nunsigned adjustment = 0;\r\nfor (i = smm->uncommitted.begin;\r\ni != smm->uncommitted.end;\r\ni = brb_next(&smm->uncommitted, i)) {\r\nstruct block_op *op = smm->uncommitted.bops + i;\r\nif (op->block != b)\r\ncontinue;\r\nswitch (op->type) {\r\ncase BOP_INC:\r\nadjustment++;\r\nbreak;\r\ncase BOP_DEC:\r\nadjustment--;\r\nbreak;\r\n}\r\n}\r\nr = sm_ll_lookup(&smm->ll, b, result);\r\nif (r)\r\nreturn r;\r\n*result += adjustment;\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_count_is_more_than_one(struct dm_space_map *sm,\r\ndm_block_t b, int *result)\r\n{\r\nint r, adjustment = 0;\r\nunsigned i;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nuint32_t rc;\r\nfor (i = smm->uncommitted.begin;\r\ni != smm->uncommitted.end;\r\ni = brb_next(&smm->uncommitted, i)) {\r\nstruct block_op *op = smm->uncommitted.bops + i;\r\nif (op->block != b)\r\ncontinue;\r\nswitch (op->type) {\r\ncase BOP_INC:\r\nadjustment++;\r\nbreak;\r\ncase BOP_DEC:\r\nadjustment--;\r\nbreak;\r\n}\r\n}\r\nif (adjustment > 1) {\r\n*result = 1;\r\nreturn 0;\r\n}\r\nr = sm_ll_lookup_bitmap(&smm->ll, b, &rc);\r\nif (r)\r\nreturn r;\r\nif (rc == 3)\r\n*result = 1;\r\nelse\r\n*result = rc + adjustment > 1;\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_set_count(struct dm_space_map *sm, dm_block_t b,\r\nuint32_t count)\r\n{\r\nint r, r2;\r\nenum allocation_event ev;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nif (smm->recursion_count) {\r\nDMERR("cannot recurse set_count()");\r\nreturn -EINVAL;\r\n}\r\nin(smm);\r\nr = sm_ll_insert(&smm->ll, b, count, &ev);\r\nr2 = out(smm);\r\nreturn combine_errors(r, r2);\r\n}\r\nstatic int sm_metadata_inc_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nint r, r2 = 0;\r\nenum allocation_event ev;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nif (recursing(smm))\r\nr = add_bop(smm, BOP_INC, b);\r\nelse {\r\nin(smm);\r\nr = sm_ll_inc(&smm->ll, b, &ev);\r\nr2 = out(smm);\r\n}\r\nreturn combine_errors(r, r2);\r\n}\r\nstatic int sm_metadata_dec_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nint r, r2 = 0;\r\nenum allocation_event ev;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nif (recursing(smm))\r\nr = add_bop(smm, BOP_DEC, b);\r\nelse {\r\nin(smm);\r\nr = sm_ll_dec(&smm->ll, b, &ev);\r\nr2 = out(smm);\r\n}\r\nreturn combine_errors(r, r2);\r\n}\r\nstatic int sm_metadata_new_block_(struct dm_space_map *sm, dm_block_t *b)\r\n{\r\nint r, r2 = 0;\r\nenum allocation_event ev;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nr = sm_ll_find_free_block(&smm->old_ll, smm->begin, smm->old_ll.nr_blocks, b);\r\nif (r)\r\nreturn r;\r\nsmm->begin = *b + 1;\r\nif (recursing(smm))\r\nr = add_bop(smm, BOP_INC, *b);\r\nelse {\r\nin(smm);\r\nr = sm_ll_inc(&smm->ll, *b, &ev);\r\nr2 = out(smm);\r\n}\r\nif (!r)\r\nsmm->allocated_this_transaction++;\r\nreturn combine_errors(r, r2);\r\n}\r\nstatic int sm_metadata_new_block(struct dm_space_map *sm, dm_block_t *b)\r\n{\r\ndm_block_t count;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nint r = sm_metadata_new_block_(sm, b);\r\nif (r) {\r\nDMERR_LIMIT("unable to allocate new metadata block");\r\nreturn r;\r\n}\r\nr = sm_metadata_get_nr_free(sm, &count);\r\nif (r) {\r\nDMERR_LIMIT("couldn't get free block count");\r\nreturn r;\r\n}\r\ncheck_threshold(&smm->threshold, count);\r\nreturn r;\r\n}\r\nstatic int sm_metadata_commit(struct dm_space_map *sm)\r\n{\r\nint r;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nr = sm_ll_commit(&smm->ll);\r\nif (r)\r\nreturn r;\r\nmemcpy(&smm->old_ll, &smm->ll, sizeof(smm->old_ll));\r\nsmm->begin = 0;\r\nsmm->allocated_this_transaction = 0;\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_register_threshold_callback(struct dm_space_map *sm,\r\ndm_block_t threshold,\r\ndm_sm_threshold_fn fn,\r\nvoid *context)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nset_threshold(&smm->threshold, threshold, fn, context);\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_root_size(struct dm_space_map *sm, size_t *result)\r\n{\r\n*result = sizeof(struct disk_sm_root);\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_copy_root(struct dm_space_map *sm, void *where_le, size_t max)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nstruct disk_sm_root root_le;\r\nroot_le.nr_blocks = cpu_to_le64(smm->ll.nr_blocks);\r\nroot_le.nr_allocated = cpu_to_le64(smm->ll.nr_allocated);\r\nroot_le.bitmap_root = cpu_to_le64(smm->ll.bitmap_root);\r\nroot_le.ref_count_root = cpu_to_le64(smm->ll.ref_count_root);\r\nif (max < sizeof(root_le))\r\nreturn -ENOSPC;\r\nmemcpy(where_le, &root_le, sizeof(root_le));\r\nreturn 0;\r\n}\r\nstatic void sm_bootstrap_destroy(struct dm_space_map *sm)\r\n{\r\n}\r\nstatic int sm_bootstrap_extend(struct dm_space_map *sm, dm_block_t extra_blocks)\r\n{\r\nDMERR("bootstrap doesn't support extend");\r\nreturn -EINVAL;\r\n}\r\nstatic int sm_bootstrap_get_nr_blocks(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\n*count = smm->ll.nr_blocks;\r\nreturn 0;\r\n}\r\nstatic int sm_bootstrap_get_nr_free(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\n*count = smm->ll.nr_blocks - smm->begin;\r\nreturn 0;\r\n}\r\nstatic int sm_bootstrap_get_count(struct dm_space_map *sm, dm_block_t b,\r\nuint32_t *result)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\n*result = (b < smm->begin) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int sm_bootstrap_count_is_more_than_one(struct dm_space_map *sm,\r\ndm_block_t b, int *result)\r\n{\r\n*result = 0;\r\nreturn 0;\r\n}\r\nstatic int sm_bootstrap_set_count(struct dm_space_map *sm, dm_block_t b,\r\nuint32_t count)\r\n{\r\nDMERR("bootstrap doesn't support set_count");\r\nreturn -EINVAL;\r\n}\r\nstatic int sm_bootstrap_new_block(struct dm_space_map *sm, dm_block_t *b)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nif (smm->begin == smm->ll.nr_blocks)\r\nreturn -ENOSPC;\r\n*b = smm->begin++;\r\nreturn 0;\r\n}\r\nstatic int sm_bootstrap_inc_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nreturn add_bop(smm, BOP_INC, b);\r\n}\r\nstatic int sm_bootstrap_dec_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nreturn add_bop(smm, BOP_DEC, b);\r\n}\r\nstatic int sm_bootstrap_commit(struct dm_space_map *sm)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sm_bootstrap_root_size(struct dm_space_map *sm, size_t *result)\r\n{\r\nDMERR("bootstrap doesn't support root_size");\r\nreturn -EINVAL;\r\n}\r\nstatic int sm_bootstrap_copy_root(struct dm_space_map *sm, void *where,\r\nsize_t max)\r\n{\r\nDMERR("bootstrap doesn't support copy_root");\r\nreturn -EINVAL;\r\n}\r\nstatic int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)\r\n{\r\nint r, i;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\ndm_block_t old_len = smm->ll.nr_blocks;\r\nsmm->begin = old_len;\r\nmemcpy(sm, &bootstrap_ops, sizeof(*sm));\r\nr = sm_ll_extend(&smm->ll, extra_blocks);\r\nif (r)\r\ngoto out;\r\ndo {\r\nfor (i = old_len; !r && i < smm->begin; i++)\r\nr = add_bop(smm, BOP_INC, i);\r\nif (r)\r\ngoto out;\r\nold_len = smm->begin;\r\nr = apply_bops(smm);\r\nif (r) {\r\nDMERR("%s: apply_bops failed", __func__);\r\ngoto out;\r\n}\r\nr = sm_ll_commit(&smm->ll);\r\nif (r)\r\ngoto out;\r\n} while (old_len != smm->begin);\r\nout:\r\nmemcpy(sm, &ops, sizeof(*sm));\r\nreturn r;\r\n}\r\nstruct dm_space_map *dm_sm_metadata_init(void)\r\n{\r\nstruct sm_metadata *smm;\r\nsmm = kmalloc(sizeof(*smm), GFP_KERNEL);\r\nif (!smm)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(&smm->sm, &ops, sizeof(smm->sm));\r\nreturn &smm->sm;\r\n}\r\nint dm_sm_metadata_create(struct dm_space_map *sm,\r\nstruct dm_transaction_manager *tm,\r\ndm_block_t nr_blocks,\r\ndm_block_t superblock)\r\n{\r\nint r;\r\ndm_block_t i;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nsmm->begin = superblock + 1;\r\nsmm->recursion_count = 0;\r\nsmm->allocated_this_transaction = 0;\r\nbrb_init(&smm->uncommitted);\r\nthreshold_init(&smm->threshold);\r\nmemcpy(&smm->sm, &bootstrap_ops, sizeof(smm->sm));\r\nr = sm_ll_new_metadata(&smm->ll, tm);\r\nif (r)\r\nreturn r;\r\nif (nr_blocks > DM_SM_METADATA_MAX_BLOCKS)\r\nnr_blocks = DM_SM_METADATA_MAX_BLOCKS;\r\nr = sm_ll_extend(&smm->ll, nr_blocks);\r\nif (r)\r\nreturn r;\r\nmemcpy(&smm->sm, &ops, sizeof(smm->sm));\r\nfor (i = superblock; !r && i < smm->begin; i++)\r\nr = add_bop(smm, BOP_INC, i);\r\nif (r)\r\nreturn r;\r\nr = apply_bops(smm);\r\nif (r) {\r\nDMERR("%s: apply_bops failed", __func__);\r\nreturn r;\r\n}\r\nreturn sm_metadata_commit(sm);\r\n}\r\nint dm_sm_metadata_open(struct dm_space_map *sm,\r\nstruct dm_transaction_manager *tm,\r\nvoid *root_le, size_t len)\r\n{\r\nint r;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nr = sm_ll_open_metadata(&smm->ll, tm, root_le, len);\r\nif (r)\r\nreturn r;\r\nsmm->begin = 0;\r\nsmm->recursion_count = 0;\r\nsmm->allocated_this_transaction = 0;\r\nbrb_init(&smm->uncommitted);\r\nthreshold_init(&smm->threshold);\r\nmemcpy(&smm->old_ll, &smm->ll, sizeof(smm->old_ll));\r\nreturn 0;\r\n}
