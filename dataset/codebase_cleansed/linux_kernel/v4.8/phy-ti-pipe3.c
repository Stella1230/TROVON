static inline u32 ti_pipe3_readl(void __iomem *addr, unsigned offset)\r\n{\r\nreturn __raw_readl(addr + offset);\r\n}\r\nstatic inline void ti_pipe3_writel(void __iomem *addr, unsigned offset,\r\nu32 data)\r\n{\r\n__raw_writel(data, addr + offset);\r\n}\r\nstatic struct pipe3_dpll_params *ti_pipe3_get_dpll_params(struct ti_pipe3 *phy)\r\n{\r\nunsigned long rate;\r\nstruct pipe3_dpll_map *dpll_map = phy->dpll_map;\r\nrate = clk_get_rate(phy->sys_clk);\r\nfor (; dpll_map->rate; dpll_map++) {\r\nif (rate == dpll_map->rate)\r\nreturn &dpll_map->params;\r\n}\r\ndev_err(phy->dev, "No DPLL configuration for %lu Hz SYS CLK\n", rate);\r\nreturn NULL;\r\n}\r\nstatic int ti_pipe3_power_off(struct phy *x)\r\n{\r\nu32 val;\r\nint ret;\r\nstruct ti_pipe3 *phy = phy_get_drvdata(x);\r\nif (!phy->phy_power_syscon) {\r\nomap_control_phy_power(phy->control_dev, 0);\r\nreturn 0;\r\n}\r\nval = PIPE3_PHY_TX_RX_POWEROFF << PIPE3_PHY_PWRCTL_CLK_CMD_SHIFT;\r\nret = regmap_update_bits(phy->phy_power_syscon, phy->power_reg,\r\nPIPE3_PHY_PWRCTL_CLK_CMD_MASK, val);\r\nreturn ret;\r\n}\r\nstatic int ti_pipe3_power_on(struct phy *x)\r\n{\r\nu32 val;\r\nu32 mask;\r\nint ret;\r\nunsigned long rate;\r\nstruct ti_pipe3 *phy = phy_get_drvdata(x);\r\nif (!phy->phy_power_syscon) {\r\nomap_control_phy_power(phy->control_dev, 1);\r\nreturn 0;\r\n}\r\nrate = clk_get_rate(phy->sys_clk);\r\nif (!rate) {\r\ndev_err(phy->dev, "Invalid clock rate\n");\r\nreturn -EINVAL;\r\n}\r\nrate = rate / 1000000;\r\nmask = OMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_CMD_MASK |\r\nOMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_FREQ_MASK;\r\nval = PIPE3_PHY_TX_RX_POWERON << PIPE3_PHY_PWRCTL_CLK_CMD_SHIFT;\r\nval |= rate << OMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_FREQ_SHIFT;\r\nret = regmap_update_bits(phy->phy_power_syscon, phy->power_reg,\r\nmask, val);\r\nreturn ret;\r\n}\r\nstatic int ti_pipe3_dpll_wait_lock(struct ti_pipe3 *phy)\r\n{\r\nu32 val;\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(PLL_LOCK_TIME);\r\ndo {\r\ncpu_relax();\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);\r\nif (val & PLL_LOCK)\r\nreturn 0;\r\n} while (!time_after(jiffies, timeout));\r\ndev_err(phy->dev, "DPLL failed to lock\n");\r\nreturn -EBUSY;\r\n}\r\nstatic int ti_pipe3_dpll_program(struct ti_pipe3 *phy)\r\n{\r\nu32 val;\r\nstruct pipe3_dpll_params *dpll_params;\r\ndpll_params = ti_pipe3_get_dpll_params(phy);\r\nif (!dpll_params)\r\nreturn -EINVAL;\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION1);\r\nval &= ~PLL_REGN_MASK;\r\nval |= dpll_params->n << PLL_REGN_SHIFT;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION1, val);\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\r\nval &= ~PLL_SELFREQDCO_MASK;\r\nval |= dpll_params->freq << PLL_SELFREQDCO_SHIFT;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION1);\r\nval &= ~PLL_REGM_MASK;\r\nval |= dpll_params->m << PLL_REGM_SHIFT;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION1, val);\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION4);\r\nval &= ~PLL_REGM_F_MASK;\r\nval |= dpll_params->mf << PLL_REGM_F_SHIFT;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION4, val);\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION3);\r\nval &= ~PLL_SD_MASK;\r\nval |= dpll_params->sd << PLL_SD_SHIFT;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION3, val);\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_GO, SET_PLL_GO);\r\nreturn ti_pipe3_dpll_wait_lock(phy);\r\n}\r\nstatic int ti_pipe3_init(struct phy *x)\r\n{\r\nstruct ti_pipe3 *phy = phy_get_drvdata(x);\r\nu32 val;\r\nint ret = 0;\r\nti_pipe3_enable_clocks(phy);\r\nif (of_device_is_compatible(phy->dev->of_node, "ti,phy-pipe3-pcie")) {\r\nif (!phy->pcs_syscon) {\r\nomap_control_pcie_pcs(phy->control_dev, 0x96);\r\nreturn 0;\r\n}\r\nval = 0x96 << OMAP_CTRL_PCIE_PCS_DELAY_COUNT_SHIFT;\r\nret = regmap_update_bits(phy->pcs_syscon, phy->pcie_pcs_reg,\r\nPCIE_PCS_MASK, val);\r\nreturn ret;\r\n}\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\r\nif (val & PLL_IDLE) {\r\nval &= ~PLL_IDLE;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\r\nret = ti_pipe3_dpll_wait_lock(phy);\r\n}\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);\r\nif ((val & PLL_LOCK) && of_device_is_compatible(phy->dev->of_node,\r\n"ti,phy-pipe3-sata"))\r\nreturn ret;\r\nret = ti_pipe3_dpll_program(phy);\r\nif (ret) {\r\nti_pipe3_disable_clocks(phy);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ti_pipe3_exit(struct phy *x)\r\n{\r\nstruct ti_pipe3 *phy = phy_get_drvdata(x);\r\nu32 val;\r\nunsigned long timeout;\r\nif (of_device_is_compatible(phy->dev->of_node, "ti,phy-pipe3-sata") &&\r\n!phy->dpll_reset_syscon)\r\nreturn 0;\r\nif (!of_device_is_compatible(phy->dev->of_node, "ti,phy-pipe3-pcie")) {\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\r\nval |= PLL_IDLE;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\r\ntimeout = jiffies + msecs_to_jiffies(PLL_IDLE_TIME);\r\ndo {\r\ncpu_relax();\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);\r\nif ((val & PLL_TICOPWDN) && (val & PLL_LDOPWDN))\r\nbreak;\r\n} while (!time_after(jiffies, timeout));\r\nif (!(val & PLL_TICOPWDN) || !(val & PLL_LDOPWDN)) {\r\ndev_err(phy->dev, "Failed to power down: PLL_STATUS 0x%x\n",\r\nval);\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (of_device_is_compatible(phy->dev->of_node, "ti,phy-pipe3-sata")) {\r\nregmap_update_bits(phy->dpll_reset_syscon, phy->dpll_reset_reg,\r\nSATA_PLL_SOFT_RESET, SATA_PLL_SOFT_RESET);\r\nregmap_update_bits(phy->dpll_reset_syscon, phy->dpll_reset_reg,\r\nSATA_PLL_SOFT_RESET, 0);\r\n}\r\nti_pipe3_disable_clocks(phy);\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_get_clk(struct ti_pipe3 *phy)\r\n{\r\nstruct clk *clk;\r\nstruct device *dev = phy->dev;\r\nstruct device_node *node = dev->of_node;\r\nphy->refclk = devm_clk_get(dev, "refclk");\r\nif (IS_ERR(phy->refclk)) {\r\ndev_err(dev, "unable to get refclk\n");\r\nif (!of_device_is_compatible(node, "ti,phy-pipe3-sata"))\r\nreturn PTR_ERR(phy->refclk);\r\n}\r\nif (!of_device_is_compatible(node, "ti,phy-pipe3-sata")) {\r\nphy->wkupclk = devm_clk_get(dev, "wkupclk");\r\nif (IS_ERR(phy->wkupclk)) {\r\ndev_err(dev, "unable to get wkupclk\n");\r\nreturn PTR_ERR(phy->wkupclk);\r\n}\r\n} else {\r\nphy->wkupclk = ERR_PTR(-ENODEV);\r\n}\r\nif (!of_device_is_compatible(node, "ti,phy-pipe3-pcie") ||\r\nphy->phy_power_syscon) {\r\nphy->sys_clk = devm_clk_get(dev, "sysclk");\r\nif (IS_ERR(phy->sys_clk)) {\r\ndev_err(dev, "unable to get sysclk\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (of_device_is_compatible(node, "ti,phy-pipe3-pcie")) {\r\nclk = devm_clk_get(dev, "dpll_ref");\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "unable to get dpll ref clk\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nclk_set_rate(clk, 1500000000);\r\nclk = devm_clk_get(dev, "dpll_ref_m2");\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "unable to get dpll ref m2 clk\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nclk_set_rate(clk, 100000000);\r\nclk = devm_clk_get(dev, "phy-div");\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "unable to get phy-div clk\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nclk_set_rate(clk, 100000000);\r\nphy->div_clk = devm_clk_get(dev, "div-clk");\r\nif (IS_ERR(phy->div_clk)) {\r\ndev_err(dev, "unable to get div-clk\n");\r\nreturn PTR_ERR(phy->div_clk);\r\n}\r\n} else {\r\nphy->div_clk = ERR_PTR(-ENODEV);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_get_sysctrl(struct ti_pipe3 *phy)\r\n{\r\nstruct device *dev = phy->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct device_node *control_node;\r\nstruct platform_device *control_pdev;\r\nphy->phy_power_syscon = syscon_regmap_lookup_by_phandle(node,\r\n"syscon-phy-power");\r\nif (IS_ERR(phy->phy_power_syscon)) {\r\ndev_dbg(dev,\r\n"can't get syscon-phy-power, using control device\n");\r\nphy->phy_power_syscon = NULL;\r\n} else {\r\nif (of_property_read_u32_index(node,\r\n"syscon-phy-power", 1,\r\n&phy->power_reg)) {\r\ndev_err(dev, "couldn't get power reg. offset\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!phy->phy_power_syscon) {\r\ncontrol_node = of_parse_phandle(node, "ctrl-module", 0);\r\nif (!control_node) {\r\ndev_err(dev, "Failed to get control device phandle\n");\r\nreturn -EINVAL;\r\n}\r\ncontrol_pdev = of_find_device_by_node(control_node);\r\nif (!control_pdev) {\r\ndev_err(dev, "Failed to get control device\n");\r\nreturn -EINVAL;\r\n}\r\nphy->control_dev = &control_pdev->dev;\r\n}\r\nif (of_device_is_compatible(node, "ti,phy-pipe3-pcie")) {\r\nphy->pcs_syscon = syscon_regmap_lookup_by_phandle(node,\r\n"syscon-pcs");\r\nif (IS_ERR(phy->pcs_syscon)) {\r\ndev_dbg(dev,\r\n"can't get syscon-pcs, using omap control\n");\r\nphy->pcs_syscon = NULL;\r\n} else {\r\nif (of_property_read_u32_index(node,\r\n"syscon-pcs", 1,\r\n&phy->pcie_pcs_reg)) {\r\ndev_err(dev,\r\n"couldn't get pcie pcs reg. offset\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nif (of_device_is_compatible(node, "ti,phy-pipe3-sata")) {\r\nphy->dpll_reset_syscon = syscon_regmap_lookup_by_phandle(node,\r\n"syscon-pllreset");\r\nif (IS_ERR(phy->dpll_reset_syscon)) {\r\ndev_info(dev,\r\n"can't get syscon-pllreset, sata dpll won't idle\n");\r\nphy->dpll_reset_syscon = NULL;\r\n} else {\r\nif (of_property_read_u32_index(node,\r\n"syscon-pllreset", 1,\r\n&phy->dpll_reset_reg)) {\r\ndev_err(dev,\r\n"couldn't get pllreset reg. offset\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_get_pll_base(struct ti_pipe3 *phy)\r\n{\r\nstruct resource *res;\r\nconst struct of_device_id *match;\r\nstruct device *dev = phy->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nif (of_device_is_compatible(node, "ti,phy-pipe3-pcie"))\r\nreturn 0;\r\nmatch = of_match_device(ti_pipe3_id_table, dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nphy->dpll_map = (struct pipe3_dpll_map *)match->data;\r\nif (!phy->dpll_map) {\r\ndev_err(dev, "no DPLL data\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"pll_ctrl");\r\nphy->pll_ctrl_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(phy->pll_ctrl_base))\r\nreturn PTR_ERR(phy->pll_ctrl_base);\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_probe(struct platform_device *pdev)\r\n{\r\nstruct ti_pipe3 *phy;\r\nstruct phy *generic_phy;\r\nstruct phy_provider *phy_provider;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn -ENOMEM;\r\nphy->dev = dev;\r\nret = ti_pipe3_get_pll_base(phy);\r\nif (ret)\r\nreturn ret;\r\nret = ti_pipe3_get_sysctrl(phy);\r\nif (ret)\r\nreturn ret;\r\nret = ti_pipe3_get_clk(phy);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, phy);\r\npm_runtime_enable(dev);\r\nif (of_device_is_compatible(node, "ti,phy-pipe3-sata")) {\r\nif (!IS_ERR(phy->refclk)) {\r\nclk_prepare_enable(phy->refclk);\r\nphy->sata_refclk_enabled = true;\r\n}\r\n}\r\ngeneric_phy = devm_phy_create(dev, NULL, &ops);\r\nif (IS_ERR(generic_phy))\r\nreturn PTR_ERR(generic_phy);\r\nphy_set_drvdata(generic_phy, phy);\r\nti_pipe3_power_off(generic_phy);\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (IS_ERR(phy_provider))\r\nreturn PTR_ERR(phy_provider);\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_enable_clocks(struct ti_pipe3 *phy)\r\n{\r\nint ret = 0;\r\nif (!IS_ERR(phy->refclk)) {\r\nret = clk_prepare_enable(phy->refclk);\r\nif (ret) {\r\ndev_err(phy->dev, "Failed to enable refclk %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (!IS_ERR(phy->wkupclk)) {\r\nret = clk_prepare_enable(phy->wkupclk);\r\nif (ret) {\r\ndev_err(phy->dev, "Failed to enable wkupclk %d\n", ret);\r\ngoto disable_refclk;\r\n}\r\n}\r\nif (!IS_ERR(phy->div_clk)) {\r\nret = clk_prepare_enable(phy->div_clk);\r\nif (ret) {\r\ndev_err(phy->dev, "Failed to enable div_clk %d\n", ret);\r\ngoto disable_wkupclk;\r\n}\r\n}\r\nreturn 0;\r\ndisable_wkupclk:\r\nif (!IS_ERR(phy->wkupclk))\r\nclk_disable_unprepare(phy->wkupclk);\r\ndisable_refclk:\r\nif (!IS_ERR(phy->refclk))\r\nclk_disable_unprepare(phy->refclk);\r\nreturn ret;\r\n}\r\nstatic void ti_pipe3_disable_clocks(struct ti_pipe3 *phy)\r\n{\r\nif (!IS_ERR(phy->wkupclk))\r\nclk_disable_unprepare(phy->wkupclk);\r\nif (!IS_ERR(phy->refclk)) {\r\nclk_disable_unprepare(phy->refclk);\r\nif (phy->sata_refclk_enabled) {\r\nclk_disable_unprepare(phy->refclk);\r\nphy->sata_refclk_enabled = false;\r\n}\r\n}\r\nif (!IS_ERR(phy->div_clk))\r\nclk_disable_unprepare(phy->div_clk);\r\n}
