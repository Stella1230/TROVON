static void tcon_ch1_disable(struct clk_hw *hw)\r\n{\r\nstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&tclk->lock, flags);\r\nreg = readl(tclk->reg);\r\nreg &= ~(TCON_CH1_SCLK2_GATE_BIT | TCON_CH1_SCLK1_GATE_BIT);\r\nwritel(reg, tclk->reg);\r\nspin_unlock_irqrestore(&tclk->lock, flags);\r\n}\r\nstatic int tcon_ch1_enable(struct clk_hw *hw)\r\n{\r\nstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&tclk->lock, flags);\r\nreg = readl(tclk->reg);\r\nreg |= TCON_CH1_SCLK2_GATE_BIT | TCON_CH1_SCLK1_GATE_BIT;\r\nwritel(reg, tclk->reg);\r\nspin_unlock_irqrestore(&tclk->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int tcon_ch1_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\r\nu32 reg;\r\nreg = readl(tclk->reg);\r\nreturn reg & (TCON_CH1_SCLK2_GATE_BIT | TCON_CH1_SCLK1_GATE_BIT);\r\n}\r\nstatic u8 tcon_ch1_get_parent(struct clk_hw *hw)\r\n{\r\nstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\r\nu32 reg;\r\nreg = readl(tclk->reg) >> TCON_CH1_SCLK2_MUX_SHIFT;\r\nreg &= reg >> TCON_CH1_SCLK2_MUX_MASK;\r\nreturn reg;\r\n}\r\nstatic int tcon_ch1_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&tclk->lock, flags);\r\nreg = readl(tclk->reg);\r\nreg &= ~(TCON_CH1_SCLK2_MUX_MASK << TCON_CH1_SCLK2_MUX_SHIFT);\r\nreg |= index << TCON_CH1_SCLK2_MUX_SHIFT;\r\nwritel(reg, tclk->reg);\r\nspin_unlock_irqrestore(&tclk->lock, flags);\r\nreturn 0;\r\n}\r\nstatic unsigned long tcon_ch1_calc_divider(unsigned long rate,\r\nunsigned long parent_rate,\r\nu8 *div,\r\nbool *half)\r\n{\r\nunsigned long best_rate = 0;\r\nu8 best_m = 0, m;\r\nbool is_double;\r\nfor (m = 1; m < 16; m++) {\r\nu8 d;\r\nfor (d = 1; d < 3; d++) {\r\nunsigned long tmp_rate;\r\ntmp_rate = parent_rate / m / d;\r\nif (tmp_rate > rate)\r\ncontinue;\r\nif (!best_rate ||\r\n(rate - tmp_rate) < (rate - best_rate)) {\r\nbest_rate = tmp_rate;\r\nbest_m = m;\r\nis_double = d;\r\n}\r\n}\r\n}\r\nif (div && half) {\r\n*div = best_m;\r\n*half = is_double;\r\n}\r\nreturn best_rate;\r\n}\r\nstatic int tcon_ch1_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nlong best_rate = -EINVAL;\r\nint i;\r\nfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\r\nunsigned long parent_rate;\r\nunsigned long tmp_rate;\r\nstruct clk_hw *parent;\r\nparent = clk_hw_get_parent_by_index(hw, i);\r\nif (!parent)\r\ncontinue;\r\nparent_rate = clk_hw_get_rate(parent);\r\ntmp_rate = tcon_ch1_calc_divider(req->rate, parent_rate,\r\nNULL, NULL);\r\nif (best_rate < 0 ||\r\n(req->rate - tmp_rate) < (req->rate - best_rate)) {\r\nbest_rate = tmp_rate;\r\nreq->best_parent_rate = parent_rate;\r\nreq->best_parent_hw = parent;\r\n}\r\n}\r\nif (best_rate < 0)\r\nreturn best_rate;\r\nreq->rate = best_rate;\r\nreturn 0;\r\n}\r\nstatic unsigned long tcon_ch1_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\r\nu32 reg;\r\nreg = readl(tclk->reg);\r\nparent_rate /= (reg & TCON_CH1_SCLK2_DIV_MASK) + 1;\r\nif (reg & TCON_CH1_SCLK1_HALF_BIT)\r\nparent_rate /= 2;\r\nreturn parent_rate;\r\n}\r\nstatic int tcon_ch1_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\r\nunsigned long flags;\r\nbool half;\r\nu8 div_m;\r\nu32 reg;\r\ntcon_ch1_calc_divider(rate, parent_rate, &div_m, &half);\r\nspin_lock_irqsave(&tclk->lock, flags);\r\nreg = readl(tclk->reg);\r\nreg &= ~(TCON_CH1_SCLK2_DIV_MASK | TCON_CH1_SCLK1_HALF_BIT);\r\nreg |= (div_m - 1) & TCON_CH1_SCLK2_DIV_MASK;\r\nif (half)\r\nreg |= TCON_CH1_SCLK1_HALF_BIT;\r\nwritel(reg, tclk->reg);\r\nspin_unlock_irqrestore(&tclk->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void __init tcon_ch1_setup(struct device_node *node)\r\n{\r\nconst char *parents[TCON_CH1_SCLK2_PARENTS];\r\nconst char *clk_name = node->name;\r\nstruct clk_init_data init;\r\nstruct tcon_ch1_clk *tclk;\r\nstruct resource res;\r\nstruct clk *clk;\r\nvoid __iomem *reg;\r\nint ret;\r\nof_property_read_string(node, "clock-output-names", &clk_name);\r\nreg = of_io_request_and_map(node, 0, of_node_full_name(node));\r\nif (IS_ERR(reg)) {\r\npr_err("%s: Could not map the clock registers\n", clk_name);\r\nreturn;\r\n}\r\nret = of_clk_parent_fill(node, parents, TCON_CH1_SCLK2_PARENTS);\r\nif (ret != TCON_CH1_SCLK2_PARENTS) {\r\npr_err("%s Could not retrieve the parents\n", clk_name);\r\ngoto err_unmap;\r\n}\r\ntclk = kzalloc(sizeof(*tclk), GFP_KERNEL);\r\nif (!tclk)\r\ngoto err_unmap;\r\ninit.name = clk_name;\r\ninit.ops = &tcon_ch1_ops;\r\ninit.parent_names = parents;\r\ninit.num_parents = TCON_CH1_SCLK2_PARENTS;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ntclk->reg = reg;\r\ntclk->hw.init = &init;\r\nspin_lock_init(&tclk->lock);\r\nclk = clk_register(NULL, &tclk->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: Couldn't register the clock\n", clk_name);\r\ngoto err_free_data;\r\n}\r\nret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nif (ret) {\r\npr_err("%s: Couldn't register our clock provider\n", clk_name);\r\ngoto err_unregister_clk;\r\n}\r\nreturn;\r\nerr_unregister_clk:\r\nclk_unregister(clk);\r\nerr_free_data:\r\nkfree(tclk);\r\nerr_unmap:\r\niounmap(reg);\r\nof_address_to_resource(node, 0, &res);\r\nrelease_mem_region(res.start, resource_size(&res));\r\n}
