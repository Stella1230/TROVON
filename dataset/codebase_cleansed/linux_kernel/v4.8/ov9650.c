static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct ov965x, ctrls.handler)->sd;\r\n}\r\nstatic inline struct ov965x *to_ov965x(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct ov965x, sd);\r\n}\r\nstatic int ov965x_read(struct i2c_client *client, u8 addr, u8 *val)\r\n{\r\nu8 buf = addr;\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &buf\r\n};\r\nint ret;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret == 1) {\r\nmsg.flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret == 1)\r\n*val = buf;\r\n}\r\nv4l2_dbg(2, debug, client, "%s: 0x%02x @ 0x%02x. (%d)\n",\r\n__func__, *val, addr, ret);\r\nreturn ret == 1 ? 0 : ret;\r\n}\r\nstatic int ov965x_write(struct i2c_client *client, u8 addr, u8 val)\r\n{\r\nu8 buf[2] = { addr, val };\r\nint ret = i2c_master_send(client, buf, 2);\r\nv4l2_dbg(2, debug, client, "%s: 0x%02x @ 0x%02X (%d)\n",\r\n__func__, val, addr, ret);\r\nreturn ret == 2 ? 0 : ret;\r\n}\r\nstatic int ov965x_write_array(struct i2c_client *client,\r\nconst struct i2c_rv *regs)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; ret == 0 && regs[i].addr != REG_NULL; i++)\r\nret = ov965x_write(client, regs[i].addr, regs[i].value);\r\nreturn ret;\r\n}\r\nstatic int ov965x_set_default_gamma_curve(struct ov965x *ov965x)\r\n{\r\nstatic const u8 gamma_curve[] = {\r\n0x40, 0x30, 0x4b, 0x60, 0x70, 0x70, 0x70, 0x70,\r\n0x60, 0x60, 0x50, 0x48, 0x3a, 0x2e, 0x28, 0x22,\r\n0x04, 0x07, 0x10, 0x28, 0x36, 0x44, 0x52, 0x60,\r\n0x6c, 0x78, 0x8c, 0x9e, 0xbb, 0xd2, 0xe6\r\n};\r\nu8 addr = REG_GSP;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(gamma_curve); i++) {\r\nint ret = ov965x_write(ov965x->client, addr, gamma_curve[i]);\r\nif (ret < 0)\r\nreturn ret;\r\naddr++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov965x_set_color_matrix(struct ov965x *ov965x)\r\n{\r\nstatic const u8 mtx[] = {\r\n0x3a, 0x3d, 0x03, 0x12, 0x26, 0x38, 0x40, 0x40, 0x40, 0x0d\r\n};\r\nu8 addr = REG_MTX(1);\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(mtx); i++) {\r\nint ret = ov965x_write(ov965x->client, addr, mtx[i]);\r\nif (ret < 0)\r\nreturn ret;\r\naddr++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ov965x_gpio_set(int gpio, int val)\r\n{\r\nif (gpio_is_valid(gpio))\r\ngpio_set_value(gpio, val);\r\n}\r\nstatic void __ov965x_set_power(struct ov965x *ov965x, int on)\r\n{\r\nif (on) {\r\nov965x_gpio_set(ov965x->gpios[GPIO_PWDN], 0);\r\nov965x_gpio_set(ov965x->gpios[GPIO_RST], 0);\r\nusleep_range(25000, 26000);\r\n} else {\r\nov965x_gpio_set(ov965x->gpios[GPIO_RST], 1);\r\nov965x_gpio_set(ov965x->gpios[GPIO_PWDN], 1);\r\n}\r\nov965x->streaming = 0;\r\n}\r\nstatic int ov965x_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct ov965x *ov965x = to_ov965x(sd);\r\nstruct i2c_client *client = ov965x->client;\r\nint ret = 0;\r\nv4l2_dbg(1, debug, client, "%s: on: %d\n", __func__, on);\r\nmutex_lock(&ov965x->lock);\r\nif (ov965x->power == !on) {\r\n__ov965x_set_power(ov965x, on);\r\nif (on) {\r\nret = ov965x_write_array(client,\r\nov965x_init_regs);\r\nov965x->apply_frame_fmt = 1;\r\nov965x->ctrls.update = 1;\r\n}\r\n}\r\nif (!ret)\r\nov965x->power += on ? 1 : -1;\r\nWARN_ON(ov965x->power < 0);\r\nmutex_unlock(&ov965x->lock);\r\nreturn ret;\r\n}\r\nstatic void ov965x_update_exposure_ctrl(struct ov965x *ov965x)\r\n{\r\nstruct v4l2_ctrl *ctrl = ov965x->ctrls.exposure;\r\nunsigned long fint, trow;\r\nint min, max, def;\r\nu8 clkrc;\r\nmutex_lock(&ov965x->lock);\r\nif (WARN_ON(!ctrl || !ov965x->frame_size)) {\r\nmutex_unlock(&ov965x->lock);\r\nreturn;\r\n}\r\nclkrc = DEF_CLKRC + ov965x->fiv->clkrc_div;\r\nfint = ov965x->mclk_frequency * ((clkrc >> 7) + 1) /\r\n((2 * ((clkrc & 0x3f) + 1)));\r\ntrow = (2 * 1520 * 1000000UL) / fint;\r\nmax = ov965x->frame_size->max_exp_lines * trow;\r\nov965x->exp_row_interval = trow;\r\nmutex_unlock(&ov965x->lock);\r\nv4l2_dbg(1, debug, &ov965x->sd, "clkrc: %#x, fi: %lu, tr: %lu, %d\n",\r\nclkrc, fint, trow, max);\r\nmin = (trow + 100) / 100;\r\nmax = (max - 100) / 100;\r\ndef = min + (max - min) / 2;\r\nif (v4l2_ctrl_modify_range(ctrl, min, max, 1, def))\r\nv4l2_err(&ov965x->sd, "Exposure ctrl range update failed\n");\r\n}\r\nstatic int ov965x_set_banding_filter(struct ov965x *ov965x, int value)\r\n{\r\nunsigned long mbd, light_freq;\r\nint ret;\r\nu8 reg;\r\nret = ov965x_read(ov965x->client, REG_COM8, &reg);\r\nif (!ret) {\r\nif (value == V4L2_CID_POWER_LINE_FREQUENCY_DISABLED)\r\nreg &= ~COM8_BFILT;\r\nelse\r\nreg |= COM8_BFILT;\r\nret = ov965x_write(ov965x->client, REG_COM8, reg);\r\n}\r\nif (value == V4L2_CID_POWER_LINE_FREQUENCY_DISABLED)\r\nreturn 0;\r\nif (WARN_ON(ov965x->fiv == NULL))\r\nreturn -EINVAL;\r\nif (value == V4L2_CID_POWER_LINE_FREQUENCY_50HZ)\r\nlight_freq = 50;\r\nelse\r\nlight_freq = 60;\r\nmbd = (1000UL * ov965x->fiv->interval.denominator *\r\nov965x->frame_size->max_exp_lines) /\r\nov965x->fiv->interval.numerator;\r\nmbd = ((mbd / (light_freq * 2)) + 500) / 1000UL;\r\nreturn ov965x_write(ov965x->client, REG_MBD, mbd);\r\n}\r\nstatic int ov965x_set_white_balance(struct ov965x *ov965x, int awb)\r\n{\r\nint ret;\r\nu8 reg;\r\nret = ov965x_read(ov965x->client, REG_COM8, &reg);\r\nif (!ret) {\r\nreg = awb ? reg | REG_COM8 : reg & ~REG_COM8;\r\nret = ov965x_write(ov965x->client, REG_COM8, reg);\r\n}\r\nif (!ret && !awb) {\r\nret = ov965x_write(ov965x->client, REG_BLUE,\r\nov965x->ctrls.blue_balance->val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov965x_write(ov965x->client, REG_RED,\r\nov965x->ctrls.red_balance->val);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov965x_set_brightness(struct ov965x *ov965x, int val)\r\n{\r\nstatic const u8 regs[NUM_BR_LEVELS + 1][NUM_BR_REGS] = {\r\n{ REG_AEW, REG_AEB, REG_VPT },\r\n{ 0x1c, 0x12, 0x50 },\r\n{ 0x3d, 0x30, 0x71 },\r\n{ 0x50, 0x44, 0x92 },\r\n{ 0x70, 0x64, 0xc3 },\r\n{ 0x90, 0x84, 0xd4 },\r\n{ 0xc4, 0xbf, 0xf9 },\r\n{ 0xd8, 0xd0, 0xfa },\r\n};\r\nint i, ret = 0;\r\nval += (NUM_BR_LEVELS / 2 + 1);\r\nif (val > NUM_BR_LEVELS)\r\nreturn -EINVAL;\r\nfor (i = 0; i < NUM_BR_REGS && !ret; i++)\r\nret = ov965x_write(ov965x->client, regs[0][i],\r\nregs[val][i]);\r\nreturn ret;\r\n}\r\nstatic int ov965x_set_gain(struct ov965x *ov965x, int auto_gain)\r\n{\r\nstruct i2c_client *client = ov965x->client;\r\nstruct ov965x_ctrls *ctrls = &ov965x->ctrls;\r\nint ret = 0;\r\nu8 reg;\r\nif (ctrls->auto_gain->is_new) {\r\nret = ov965x_read(client, REG_COM8, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ctrls->auto_gain->val)\r\nreg |= COM8_AGC;\r\nelse\r\nreg &= ~COM8_AGC;\r\nret = ov965x_write(client, REG_COM8, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (ctrls->gain->is_new && !auto_gain) {\r\nunsigned int gain = ctrls->gain->val;\r\nunsigned int rgain;\r\nint m;\r\nfor (m = 6; m >= 0; m--)\r\nif (gain >= (1 << m) * 16)\r\nbreak;\r\nrgain = (gain - ((1 << m) * 16)) / (1 << m);\r\nrgain |= (((1 << m) - 1) << 4);\r\nret = ov965x_write(client, REG_GAIN, rgain & 0xff);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov965x_read(client, REG_VREF, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg &= ~VREF_GAIN_MASK;\r\nreg |= (((rgain >> 8) & 0x3) << 6);\r\nret = ov965x_write(client, REG_VREF, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nctrls->gain->val = (1 << m) * (16 + (rgain & 0xf));\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov965x_set_sharpness(struct ov965x *ov965x, unsigned int value)\r\n{\r\nu8 com14, edge;\r\nint ret;\r\nret = ov965x_read(ov965x->client, REG_COM14, &com14);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov965x_read(ov965x->client, REG_EDGE, &edge);\r\nif (ret < 0)\r\nreturn ret;\r\ncom14 = value ? com14 | COM14_EDGE_EN : com14 & ~COM14_EDGE_EN;\r\nvalue--;\r\nif (value > 0x0f) {\r\ncom14 |= COM14_EEF_X2;\r\nvalue >>= 1;\r\n} else {\r\ncom14 &= ~COM14_EEF_X2;\r\n}\r\nret = ov965x_write(ov965x->client, REG_COM14, com14);\r\nif (ret < 0)\r\nreturn ret;\r\nedge &= ~EDGE_FACTOR_MASK;\r\nedge |= ((u8)value & 0x0f);\r\nreturn ov965x_write(ov965x->client, REG_EDGE, edge);\r\n}\r\nstatic int ov965x_set_exposure(struct ov965x *ov965x, int exp)\r\n{\r\nstruct i2c_client *client = ov965x->client;\r\nstruct ov965x_ctrls *ctrls = &ov965x->ctrls;\r\nbool auto_exposure = (exp == V4L2_EXPOSURE_AUTO);\r\nint ret;\r\nu8 reg;\r\nif (ctrls->auto_exp->is_new) {\r\nret = ov965x_read(client, REG_COM8, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (auto_exposure)\r\nreg |= (COM8_AEC | COM8_AGC);\r\nelse\r\nreg &= ~(COM8_AEC | COM8_AGC);\r\nret = ov965x_write(client, REG_COM8, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!auto_exposure && ctrls->exposure->is_new) {\r\nunsigned int exposure = (ctrls->exposure->val * 100)\r\n/ ov965x->exp_row_interval;\r\nret = ov965x_write(client, REG_COM1, exposure & 0x3);\r\nif (!ret)\r\nret = ov965x_write(client, REG_AECH,\r\n(exposure >> 2) & 0xff);\r\nif (!ret)\r\nret = ov965x_write(client, REG_AECHM,\r\n(exposure >> 10) & 0x3f);\r\nctrls->exposure->val = ((exposure * ov965x->exp_row_interval)\r\n+ 50) / 100;\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nv4l2_ctrl_activate(ov965x->ctrls.brightness, !exp);\r\nreturn 0;\r\n}\r\nstatic int ov965x_set_flip(struct ov965x *ov965x)\r\n{\r\nu8 mvfp = 0;\r\nif (ov965x->ctrls.hflip->val)\r\nmvfp |= MVFP_MIRROR;\r\nif (ov965x->ctrls.vflip->val)\r\nmvfp |= MVFP_FLIP;\r\nreturn ov965x_write(ov965x->client, REG_MVFP, mvfp);\r\n}\r\nstatic int ov965x_set_saturation(struct ov965x *ov965x, int val)\r\n{\r\nstatic const u8 regs[NUM_SAT_LEVELS][NUM_SAT_REGS] = {\r\n{ 0x1d, 0x1f, 0x02, 0x09, 0x13, 0x1c },\r\n{ 0x2e, 0x31, 0x02, 0x0e, 0x1e, 0x2d },\r\n{ 0x3a, 0x3d, 0x03, 0x12, 0x26, 0x38 },\r\n{ 0x46, 0x49, 0x04, 0x16, 0x2e, 0x43 },\r\n{ 0x57, 0x5c, 0x05, 0x1b, 0x39, 0x54 },\r\n};\r\nu8 addr = REG_MTX(1);\r\nint i, ret = 0;\r\nval += (NUM_SAT_LEVELS / 2);\r\nif (val >= NUM_SAT_LEVELS)\r\nreturn -EINVAL;\r\nfor (i = 0; i < NUM_SAT_REGS && !ret; i++)\r\nret = ov965x_write(ov965x->client, addr + i, regs[val][i]);\r\nreturn ret;\r\n}\r\nstatic int ov965x_set_test_pattern(struct ov965x *ov965x, int value)\r\n{\r\nint ret;\r\nu8 reg;\r\nret = ov965x_read(ov965x->client, REG_COM23, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg = value ? reg | COM23_TEST_MODE : reg & ~COM23_TEST_MODE;\r\nreturn ov965x_write(ov965x->client, REG_COM23, reg);\r\n}\r\nstatic int __g_volatile_ctrl(struct ov965x *ov965x, struct v4l2_ctrl *ctrl)\r\n{\r\nstruct i2c_client *client = ov965x->client;\r\nunsigned int exposure, gain, m;\r\nu8 reg0, reg1, reg2;\r\nint ret;\r\nif (!ov965x->power)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\nif (!ctrl->val)\r\nreturn 0;\r\nret = ov965x_read(client, REG_GAIN, &reg0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov965x_read(client, REG_VREF, &reg1);\r\nif (ret < 0)\r\nreturn ret;\r\ngain = ((reg1 >> 6) << 8) | reg0;\r\nm = 0x01 << fls(gain >> 4);\r\nov965x->ctrls.gain->val = m * (16 + (gain & 0xf));\r\nbreak;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nif (ctrl->val == V4L2_EXPOSURE_MANUAL)\r\nreturn 0;\r\nret = ov965x_read(client, REG_COM1, &reg0);\r\nif (!ret)\r\nret = ov965x_read(client, REG_AECH, &reg1);\r\nif (!ret)\r\nret = ov965x_read(client, REG_AECHM, &reg2);\r\nif (ret < 0)\r\nreturn ret;\r\nexposure = ((reg2 & 0x3f) << 10) | (reg1 << 2) |\r\n(reg0 & 0x3);\r\nov965x->ctrls.exposure->val = ((exposure *\r\nov965x->exp_row_interval) + 50) / 100;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov965x_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\r\nstruct ov965x *ov965x = to_ov965x(sd);\r\nint ret;\r\nv4l2_dbg(1, debug, sd, "g_ctrl: %s\n", ctrl->name);\r\nmutex_lock(&ov965x->lock);\r\nret = __g_volatile_ctrl(ov965x, ctrl);\r\nmutex_unlock(&ov965x->lock);\r\nreturn ret;\r\n}\r\nstatic int ov965x_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\r\nstruct ov965x *ov965x = to_ov965x(sd);\r\nint ret = -EINVAL;\r\nv4l2_dbg(1, debug, sd, "s_ctrl: %s, value: %d. power: %d\n",\r\nctrl->name, ctrl->val, ov965x->power);\r\nmutex_lock(&ov965x->lock);\r\nif (ov965x->power == 0) {\r\nmutex_unlock(&ov965x->lock);\r\nreturn 0;\r\n}\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nret = ov965x_set_white_balance(ov965x, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_BRIGHTNESS:\r\nret = ov965x_set_brightness(ov965x, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nret = ov965x_set_exposure(ov965x, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nret = ov965x_set_gain(ov965x, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nret = ov965x_set_flip(ov965x);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nret = ov965x_set_banding_filter(ov965x, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nret = ov965x_set_saturation(ov965x, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nret = ov965x_set_sharpness(ov965x, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_TEST_PATTERN:\r\nret = ov965x_set_test_pattern(ov965x, ctrl->val);\r\nbreak;\r\n}\r\nmutex_unlock(&ov965x->lock);\r\nreturn ret;\r\n}\r\nstatic int ov965x_initialize_controls(struct ov965x *ov965x)\r\n{\r\nconst struct v4l2_ctrl_ops *ops = &ov965x_ctrl_ops;\r\nstruct ov965x_ctrls *ctrls = &ov965x->ctrls;\r\nstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\r\nint ret;\r\nret = v4l2_ctrl_handler_init(hdl, 16);\r\nif (ret < 0)\r\nreturn ret;\r\nctrls->auto_wb = v4l2_ctrl_new_std(hdl, ops,\r\nV4L2_CID_AUTO_WHITE_BALANCE,\r\n0, 1, 1, 1);\r\nctrls->blue_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,\r\n0, 0xff, 1, 0x80);\r\nctrls->red_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,\r\n0, 0xff, 1, 0x80);\r\nctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,\r\nV4L2_CID_EXPOSURE_AUTO,\r\nV4L2_EXPOSURE_MANUAL, 0, V4L2_EXPOSURE_AUTO);\r\nctrls->exposure = v4l2_ctrl_new_std(hdl, ops,\r\nV4L2_CID_EXPOSURE_ABSOLUTE,\r\n2, 1500, 1, 500);\r\nctrls->auto_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTOGAIN,\r\n0, 1, 1, 1);\r\nctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,\r\n16, 64 * (16 + 15), 1, 64 * 16);\r\nctrls->saturation = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION,\r\n-2, 2, 1, 0);\r\nctrls->brightness = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BRIGHTNESS,\r\n-3, 3, 1, 0);\r\nctrls->sharpness = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SHARPNESS,\r\n0, 32, 1, 6);\r\nctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\r\nctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\r\nctrls->light_freq = v4l2_ctrl_new_std_menu(hdl, ops,\r\nV4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_60HZ, ~0x7,\r\nV4L2_CID_POWER_LINE_FREQUENCY_50HZ);\r\nv4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(test_pattern_menu) - 1, 0, 0,\r\ntest_pattern_menu);\r\nif (hdl->error) {\r\nret = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn ret;\r\n}\r\nctrls->gain->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nv4l2_ctrl_auto_cluster(3, &ctrls->auto_wb, 0, false);\r\nv4l2_ctrl_auto_cluster(2, &ctrls->auto_gain, 0, true);\r\nv4l2_ctrl_auto_cluster(2, &ctrls->auto_exp, 1, true);\r\nv4l2_ctrl_cluster(2, &ctrls->hflip);\r\nov965x->sd.ctrl_handler = hdl;\r\nreturn 0;\r\n}\r\nstatic void ov965x_get_default_format(struct v4l2_mbus_framefmt *mf)\r\n{\r\nmf->width = ov965x_framesizes[0].width;\r\nmf->height = ov965x_framesizes[0].height;\r\nmf->colorspace = ov965x_formats[0].colorspace;\r\nmf->code = ov965x_formats[0].code;\r\nmf->field = V4L2_FIELD_NONE;\r\n}\r\nstatic int ov965x_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index >= ARRAY_SIZE(ov965x_formats))\r\nreturn -EINVAL;\r\ncode->code = ov965x_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic int ov965x_enum_frame_sizes(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nint i = ARRAY_SIZE(ov965x_formats);\r\nif (fse->index >= ARRAY_SIZE(ov965x_framesizes))\r\nreturn -EINVAL;\r\nwhile (--i)\r\nif (fse->code == ov965x_formats[i].code)\r\nbreak;\r\nfse->code = ov965x_formats[i].code;\r\nfse->min_width = ov965x_framesizes[fse->index].width;\r\nfse->max_width = fse->min_width;\r\nfse->max_height = ov965x_framesizes[fse->index].height;\r\nfse->min_height = fse->max_height;\r\nreturn 0;\r\n}\r\nstatic int ov965x_g_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct ov965x *ov965x = to_ov965x(sd);\r\nmutex_lock(&ov965x->lock);\r\nfi->interval = ov965x->fiv->interval;\r\nmutex_unlock(&ov965x->lock);\r\nreturn 0;\r\n}\r\nstatic int __ov965x_set_frame_interval(struct ov965x *ov965x,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct v4l2_mbus_framefmt *mbus_fmt = &ov965x->format;\r\nconst struct ov965x_interval *fiv = &ov965x_intervals[0];\r\nu64 req_int, err, min_err = ~0ULL;\r\nunsigned int i;\r\nif (fi->interval.denominator == 0)\r\nreturn -EINVAL;\r\nreq_int = (u64)(fi->interval.numerator * 10000) /\r\nfi->interval.denominator;\r\nfor (i = 0; i < ARRAY_SIZE(ov965x_intervals); i++) {\r\nconst struct ov965x_interval *iv = &ov965x_intervals[i];\r\nif (mbus_fmt->width != iv->size.width ||\r\nmbus_fmt->height != iv->size.height)\r\ncontinue;\r\nerr = abs((u64)(iv->interval.numerator * 10000) /\r\niv->interval.denominator - req_int);\r\nif (err < min_err) {\r\nfiv = iv;\r\nmin_err = err;\r\n}\r\n}\r\nov965x->fiv = fiv;\r\nv4l2_dbg(1, debug, &ov965x->sd, "Changed frame interval to %u us\n",\r\nfiv->interval.numerator * 1000000 / fiv->interval.denominator);\r\nreturn 0;\r\n}\r\nstatic int ov965x_s_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct ov965x *ov965x = to_ov965x(sd);\r\nint ret;\r\nv4l2_dbg(1, debug, sd, "Setting %d/%d frame interval\n",\r\nfi->interval.numerator, fi->interval.denominator);\r\nmutex_lock(&ov965x->lock);\r\nret = __ov965x_set_frame_interval(ov965x, fi);\r\nov965x->apply_frame_fmt = 1;\r\nmutex_unlock(&ov965x->lock);\r\nreturn ret;\r\n}\r\nstatic int ov965x_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct ov965x *ov965x = to_ov965x(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = v4l2_subdev_get_try_format(sd, cfg, 0);\r\nfmt->format = *mf;\r\nreturn 0;\r\n}\r\nmutex_lock(&ov965x->lock);\r\nfmt->format = ov965x->format;\r\nmutex_unlock(&ov965x->lock);\r\nreturn 0;\r\n}\r\nstatic void __ov965x_try_frame_size(struct v4l2_mbus_framefmt *mf,\r\nconst struct ov965x_framesize **size)\r\n{\r\nconst struct ov965x_framesize *fsize = &ov965x_framesizes[0],\r\n*match = NULL;\r\nint i = ARRAY_SIZE(ov965x_framesizes);\r\nunsigned int min_err = UINT_MAX;\r\nwhile (i--) {\r\nint err = abs(fsize->width - mf->width)\r\n+ abs(fsize->height - mf->height);\r\nif (err < min_err) {\r\nmin_err = err;\r\nmatch = fsize;\r\n}\r\nfsize++;\r\n}\r\nif (!match)\r\nmatch = &ov965x_framesizes[0];\r\nmf->width = match->width;\r\nmf->height = match->height;\r\nif (size)\r\n*size = match;\r\n}\r\nstatic int ov965x_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nunsigned int index = ARRAY_SIZE(ov965x_formats);\r\nstruct v4l2_mbus_framefmt *mf = &fmt->format;\r\nstruct ov965x *ov965x = to_ov965x(sd);\r\nconst struct ov965x_framesize *size = NULL;\r\nint ret = 0;\r\n__ov965x_try_frame_size(mf, &size);\r\nwhile (--index)\r\nif (ov965x_formats[index].code == mf->code)\r\nbreak;\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nmf->code = ov965x_formats[index].code;\r\nmf->field = V4L2_FIELD_NONE;\r\nmutex_lock(&ov965x->lock);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nif (cfg != NULL) {\r\nmf = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);\r\n*mf = fmt->format;\r\n}\r\n} else {\r\nif (ov965x->streaming) {\r\nret = -EBUSY;\r\n} else {\r\nov965x->frame_size = size;\r\nov965x->format = fmt->format;\r\nov965x->tslb_reg = ov965x_formats[index].tslb_reg;\r\nov965x->apply_frame_fmt = 1;\r\n}\r\n}\r\nif (!ret && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nstruct v4l2_subdev_frame_interval fiv = {\r\n.interval = { 0, 1 }\r\n};\r\n__ov965x_set_frame_interval(ov965x, &fiv);\r\n}\r\nmutex_unlock(&ov965x->lock);\r\nif (!ret)\r\nov965x_update_exposure_ctrl(ov965x);\r\nreturn ret;\r\n}\r\nstatic int ov965x_set_frame_size(struct ov965x *ov965x)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; ret == 0 && i < NUM_FMT_REGS; i++)\r\nret = ov965x_write(ov965x->client, frame_size_reg_addr[i],\r\nov965x->frame_size->regs[i]);\r\nreturn ret;\r\n}\r\nstatic int __ov965x_set_params(struct ov965x *ov965x)\r\n{\r\nstruct i2c_client *client = ov965x->client;\r\nstruct ov965x_ctrls *ctrls = &ov965x->ctrls;\r\nint ret = 0;\r\nu8 reg;\r\nif (ov965x->apply_frame_fmt) {\r\nreg = DEF_CLKRC + ov965x->fiv->clkrc_div;\r\nret = ov965x_write(client, REG_CLKRC, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov965x_set_frame_size(ov965x);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov965x_read(client, REG_TSLB, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg &= ~TSLB_YUYV_MASK;\r\nreg |= ov965x->tslb_reg;\r\nret = ov965x_write(client, REG_TSLB, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = ov965x_set_default_gamma_curve(ov965x);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov965x_set_color_matrix(ov965x);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov965x_read(client, REG_COM11, &reg);\r\nif (!ret)\r\nreg |= COM11_BANDING;\r\nret = ov965x_write(client, REG_COM11, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ov965x_set_banding_filter(ov965x, ctrls->light_freq->val);\r\n}\r\nstatic int ov965x_s_stream(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov965x *ov965x = to_ov965x(sd);\r\nstruct ov965x_ctrls *ctrls = &ov965x->ctrls;\r\nint ret = 0;\r\nv4l2_dbg(1, debug, client, "%s: on: %d\n", __func__, on);\r\nmutex_lock(&ov965x->lock);\r\nif (ov965x->streaming == !on) {\r\nif (on)\r\nret = __ov965x_set_params(ov965x);\r\nif (!ret && ctrls->update) {\r\nmutex_unlock(&ov965x->lock);\r\nret = v4l2_ctrl_handler_setup(&ctrls->handler);\r\nmutex_lock(&ov965x->lock);\r\nif (!ret)\r\nctrls->update = 0;\r\n}\r\nif (!ret)\r\nret = ov965x_write(client, REG_COM2,\r\non ? 0x01 : 0x11);\r\n}\r\nif (!ret)\r\nov965x->streaming += on ? 1 : -1;\r\nWARN_ON(ov965x->streaming < 0);\r\nmutex_unlock(&ov965x->lock);\r\nreturn ret;\r\n}\r\nstatic int ov965x_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = v4l2_subdev_get_try_format(sd, fh->pad, 0);\r\nov965x_get_default_format(mf);\r\nreturn 0;\r\n}\r\nstatic int ov965x_configure_gpios(struct ov965x *ov965x,\r\nconst struct ov9650_platform_data *pdata)\r\n{\r\nint ret, i;\r\nov965x->gpios[GPIO_PWDN] = pdata->gpio_pwdn;\r\nov965x->gpios[GPIO_RST] = pdata->gpio_reset;\r\nfor (i = 0; i < ARRAY_SIZE(ov965x->gpios); i++) {\r\nint gpio = ov965x->gpios[i];\r\nif (!gpio_is_valid(gpio))\r\ncontinue;\r\nret = devm_gpio_request_one(&ov965x->client->dev, gpio,\r\nGPIOF_OUT_INIT_HIGH, "OV965X");\r\nif (ret < 0)\r\nreturn ret;\r\nv4l2_dbg(1, debug, &ov965x->sd, "set gpio %d to 1\n", gpio);\r\ngpio_set_value(gpio, 1);\r\ngpio_export(gpio, 0);\r\nov965x->gpios[i] = gpio;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov965x_detect_sensor(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov965x *ov965x = to_ov965x(sd);\r\nu8 pid, ver;\r\nint ret;\r\nmutex_lock(&ov965x->lock);\r\n__ov965x_set_power(ov965x, 1);\r\nusleep_range(25000, 26000);\r\nret = ov965x_read(client, REG_PID, &pid);\r\nif (!ret)\r\nret = ov965x_read(client, REG_VER, &ver);\r\n__ov965x_set_power(ov965x, 0);\r\nif (!ret) {\r\nov965x->id = OV965X_ID(pid, ver);\r\nif (ov965x->id == OV9650_ID || ov965x->id == OV9652_ID) {\r\nv4l2_info(sd, "Found OV%04X sensor\n", ov965x->id);\r\n} else {\r\nv4l2_err(sd, "Sensor detection failed (%04X, %d)\n",\r\nov965x->id, ret);\r\nret = -ENODEV;\r\n}\r\n}\r\nmutex_unlock(&ov965x->lock);\r\nreturn ret;\r\n}\r\nstatic int ov965x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct ov9650_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_subdev *sd;\r\nstruct ov965x *ov965x;\r\nint ret;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "platform data not specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->mclk_frequency == 0) {\r\ndev_err(&client->dev, "MCLK frequency not specified\n");\r\nreturn -EINVAL;\r\n}\r\nov965x = devm_kzalloc(&client->dev, sizeof(*ov965x), GFP_KERNEL);\r\nif (!ov965x)\r\nreturn -ENOMEM;\r\nmutex_init(&ov965x->lock);\r\nov965x->client = client;\r\nov965x->mclk_frequency = pdata->mclk_frequency;\r\nsd = &ov965x->sd;\r\nv4l2_i2c_subdev_init(sd, client, &ov965x_subdev_ops);\r\nstrlcpy(sd->name, DRIVER_NAME, sizeof(sd->name));\r\nsd->internal_ops = &ov965x_sd_internal_ops;\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\r\nV4L2_SUBDEV_FL_HAS_EVENTS;\r\nret = ov965x_configure_gpios(ov965x, pdata);\r\nif (ret < 0)\r\nreturn ret;\r\nov965x->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\r\nret = media_entity_pads_init(&sd->entity, 1, &ov965x->pad);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov965x_initialize_controls(ov965x);\r\nif (ret < 0)\r\ngoto err_me;\r\nov965x_get_default_format(&ov965x->format);\r\nov965x->frame_size = &ov965x_framesizes[0];\r\nov965x->fiv = &ov965x_intervals[0];\r\nret = ov965x_detect_sensor(sd);\r\nif (ret < 0)\r\ngoto err_ctrls;\r\nov965x_update_exposure_ctrl(ov965x);\r\nreturn 0;\r\nerr_ctrls:\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nerr_me:\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn ret;\r\n}\r\nstatic int ov965x_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn 0;\r\n}
