static int dm_read(struct usbnet *dev, u8 reg, u16 length, void *data)\r\n{\r\nint err;\r\nerr = usbnet_read_cmd(dev, DM_READ_REGS,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, reg, data, length);\r\nif(err != length && err >= 0)\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nstatic int dm_read_reg(struct usbnet *dev, u8 reg, u8 *value)\r\n{\r\nreturn dm_read(dev, reg, 1, value);\r\n}\r\nstatic int dm_write(struct usbnet *dev, u8 reg, u16 length, void *data)\r\n{\r\nint err;\r\nerr = usbnet_write_cmd(dev, DM_WRITE_REGS,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, reg, data, length);\r\nif (err >= 0 && err < length)\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nstatic int dm_write_reg(struct usbnet *dev, u8 reg, u8 value)\r\n{\r\nreturn usbnet_write_cmd(dev, DM_WRITE_REG,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, reg, NULL, 0);\r\n}\r\nstatic void dm_write_async(struct usbnet *dev, u8 reg, u16 length, void *data)\r\n{\r\nusbnet_write_cmd_async(dev, DM_WRITE_REGS,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, reg, data, length);\r\n}\r\nstatic void dm_write_reg_async(struct usbnet *dev, u8 reg, u8 value)\r\n{\r\nusbnet_write_cmd_async(dev, DM_WRITE_REG,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, reg, NULL, 0);\r\n}\r\nstatic int dm_read_shared_word(struct usbnet *dev, int phy, u8 reg, __le16 *value)\r\n{\r\nint ret, i;\r\nmutex_lock(&dev->phy_mutex);\r\ndm_write_reg(dev, DM_SHARED_ADDR, phy ? (reg | 0x40) : reg);\r\ndm_write_reg(dev, DM_SHARED_CTRL, phy ? 0xc : 0x4);\r\nfor (i = 0; i < DM_TIMEOUT; i++) {\r\nu8 tmp = 0;\r\nudelay(1);\r\nret = dm_read_reg(dev, DM_SHARED_CTRL, &tmp);\r\nif (ret < 0)\r\ngoto out;\r\nif ((tmp & 1) == 0)\r\nbreak;\r\n}\r\nif (i == DM_TIMEOUT) {\r\nnetdev_err(dev->net, "%s read timed out!\n", phy ? "phy" : "eeprom");\r\nret = -EIO;\r\ngoto out;\r\n}\r\ndm_write_reg(dev, DM_SHARED_CTRL, 0x0);\r\nret = dm_read(dev, DM_SHARED_DATA, 2, value);\r\nnetdev_dbg(dev->net, "read shared %d 0x%02x returned 0x%04x, %d\n",\r\nphy, reg, *value, ret);\r\nout:\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic int dm_write_shared_word(struct usbnet *dev, int phy, u8 reg, __le16 value)\r\n{\r\nint ret, i;\r\nmutex_lock(&dev->phy_mutex);\r\nret = dm_write(dev, DM_SHARED_DATA, 2, &value);\r\nif (ret < 0)\r\ngoto out;\r\ndm_write_reg(dev, DM_SHARED_ADDR, phy ? (reg | 0x40) : reg);\r\ndm_write_reg(dev, DM_SHARED_CTRL, phy ? 0x1a : 0x12);\r\nfor (i = 0; i < DM_TIMEOUT; i++) {\r\nu8 tmp = 0;\r\nudelay(1);\r\nret = dm_read_reg(dev, DM_SHARED_CTRL, &tmp);\r\nif (ret < 0)\r\ngoto out;\r\nif ((tmp & 1) == 0)\r\nbreak;\r\n}\r\nif (i == DM_TIMEOUT) {\r\nnetdev_err(dev->net, "%s write timed out!\n", phy ? "phy" : "eeprom");\r\nret = -EIO;\r\ngoto out;\r\n}\r\ndm_write_reg(dev, DM_SHARED_CTRL, 0x0);\r\nout:\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic int dm_read_eeprom_word(struct usbnet *dev, u8 offset, void *value)\r\n{\r\nreturn dm_read_shared_word(dev, 0, offset, value);\r\n}\r\nstatic int dm9601_get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn DM_EEPROM_LEN;\r\n}\r\nstatic int dm9601_get_eeprom(struct net_device *net,\r\nstruct ethtool_eeprom *eeprom, u8 * data)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\n__le16 *ebuf = (__le16 *) data;\r\nint i;\r\nif ((eeprom->offset % 2) || (eeprom->len % 2))\r\nreturn -EINVAL;\r\nfor (i = 0; i < eeprom->len / 2; i++) {\r\nif (dm_read_eeprom_word(dev, eeprom->offset / 2 + i,\r\n&ebuf[i]) < 0)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dm9601_mdio_read(struct net_device *netdev, int phy_id, int loc)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\n__le16 res;\r\nif (phy_id) {\r\nnetdev_dbg(dev->net, "Only internal phy supported\n");\r\nreturn 0;\r\n}\r\ndm_read_shared_word(dev, 1, loc, &res);\r\nnetdev_dbg(dev->net,\r\n"dm9601_mdio_read() phy_id=0x%02x, loc=0x%02x, returns=0x%04x\n",\r\nphy_id, loc, le16_to_cpu(res));\r\nreturn le16_to_cpu(res);\r\n}\r\nstatic void dm9601_mdio_write(struct net_device *netdev, int phy_id, int loc,\r\nint val)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\n__le16 res = cpu_to_le16(val);\r\nif (phy_id) {\r\nnetdev_dbg(dev->net, "Only internal phy supported\n");\r\nreturn;\r\n}\r\nnetdev_dbg(dev->net, "dm9601_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\n",\r\nphy_id, loc, val);\r\ndm_write_shared_word(dev, 1, loc, res);\r\n}\r\nstatic void dm9601_get_drvinfo(struct net_device *net,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nusbnet_get_drvinfo(net, info);\r\n}\r\nstatic u32 dm9601_get_link(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn mii_link_ok(&dev->mii);\r\n}\r\nstatic int dm9601_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\r\n}\r\nstatic void dm9601_set_multicast(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu8 *hashes = (u8 *) & dev->data;\r\nu8 rx_ctl = 0x31;\r\nmemset(hashes, 0x00, DM_MCAST_SIZE);\r\nhashes[DM_MCAST_SIZE - 1] |= 0x80;\r\nif (net->flags & IFF_PROMISC) {\r\nrx_ctl |= 0x02;\r\n} else if (net->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(net) > DM_MAX_MCAST) {\r\nrx_ctl |= 0x08;\r\n} else if (!netdev_mc_empty(net)) {\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, net) {\r\nu32 crc = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nhashes[crc >> 3] |= 1 << (crc & 0x7);\r\n}\r\n}\r\ndm_write_async(dev, DM_MCAST_ADDR, DM_MCAST_SIZE, hashes);\r\ndm_write_reg_async(dev, DM_RX_CTRL, rx_ctl);\r\n}\r\nstatic void __dm9601_set_mac_address(struct usbnet *dev)\r\n{\r\ndm_write_async(dev, DM_PHY_ADDR, ETH_ALEN, dev->net->dev_addr);\r\n}\r\nstatic int dm9601_set_mac_address(struct net_device *net, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nstruct usbnet *dev = netdev_priv(net);\r\nif (!is_valid_ether_addr(addr->sa_data)) {\r\ndev_err(&net->dev, "not setting invalid mac address %pM\n",\r\naddr->sa_data);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(net->dev_addr, addr->sa_data, net->addr_len);\r\n__dm9601_set_mac_address(dev);\r\nreturn 0;\r\n}\r\nstatic int dm9601_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint ret;\r\nu8 mac[ETH_ALEN], id;\r\nret = usbnet_get_endpoints(dev, intf);\r\nif (ret)\r\ngoto out;\r\ndev->net->netdev_ops = &dm9601_netdev_ops;\r\ndev->net->ethtool_ops = &dm9601_ethtool_ops;\r\ndev->net->hard_header_len += DM_TX_OVERHEAD;\r\ndev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\r\ndev->rx_urb_size = dev->net->mtu + ETH_HLEN + DM_RX_OVERHEAD + 1;\r\ndev->mii.dev = dev->net;\r\ndev->mii.mdio_read = dm9601_mdio_read;\r\ndev->mii.mdio_write = dm9601_mdio_write;\r\ndev->mii.phy_id_mask = 0x1f;\r\ndev->mii.reg_num_mask = 0x1f;\r\ndm_write_reg(dev, DM_NET_CTRL, 1);\r\nudelay(20);\r\nif (dm_read(dev, DM_PHY_ADDR, ETH_ALEN, mac) < 0) {\r\nprintk(KERN_ERR "Error reading MAC address\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (is_valid_ether_addr(mac))\r\nmemcpy(dev->net->dev_addr, mac, ETH_ALEN);\r\nelse {\r\nprintk(KERN_WARNING\r\n"dm9601: No valid MAC address in EEPROM, using %pM\n",\r\ndev->net->dev_addr);\r\n__dm9601_set_mac_address(dev);\r\n}\r\nif (dm_read_reg(dev, DM_CHIP_ID, &id) < 0) {\r\nnetdev_err(dev->net, "Error reading chip ID\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (id == ID_DM9620) {\r\nu8 mode;\r\nif (dm_read_reg(dev, DM_MODE_CTRL, &mode) < 0) {\r\nnetdev_err(dev->net, "Error reading MODE_CTRL\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ndm_write_reg(dev, DM_MODE_CTRL, mode & 0x7f);\r\n}\r\ndm_write_reg(dev, DM_GPR_CTRL, 1);\r\ndm_write_reg(dev, DM_GPR_DATA, 0);\r\ndm9601_set_multicast(dev->net);\r\ndm9601_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);\r\ndm9601_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\r\nADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);\r\nmii_nway_restart(&dev->mii);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int dm9601_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nu8 status;\r\nint len;\r\nif (unlikely(skb->len < DM_RX_OVERHEAD)) {\r\ndev_err(&dev->udev->dev, "unexpected tiny rx frame\n");\r\nreturn 0;\r\n}\r\nstatus = skb->data[0];\r\nlen = (skb->data[1] | (skb->data[2] << 8)) - 4;\r\nif (unlikely(status & 0xbf)) {\r\nif (status & 0x01) dev->net->stats.rx_fifo_errors++;\r\nif (status & 0x02) dev->net->stats.rx_crc_errors++;\r\nif (status & 0x04) dev->net->stats.rx_frame_errors++;\r\nif (status & 0x20) dev->net->stats.rx_missed_errors++;\r\nif (status & 0x90) dev->net->stats.rx_length_errors++;\r\nreturn 0;\r\n}\r\nskb_pull(skb, 3);\r\nskb_trim(skb, len);\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *dm9601_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\r\ngfp_t flags)\r\n{\r\nint len, pad;\r\nlen = skb->len + DM_TX_OVERHEAD;\r\nwhile ((len & 1) || !(len % dev->maxpacket))\r\nlen++;\r\nlen -= DM_TX_OVERHEAD;\r\npad = len - skb->len;\r\nif (skb_headroom(skb) < DM_TX_OVERHEAD || skb_tailroom(skb) < pad) {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_copy_expand(skb, DM_TX_OVERHEAD, pad, flags);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (!skb)\r\nreturn NULL;\r\n}\r\n__skb_push(skb, DM_TX_OVERHEAD);\r\nif (pad) {\r\nmemset(skb->data + skb->len, 0, pad);\r\n__skb_put(skb, pad);\r\n}\r\nskb->data[0] = len;\r\nskb->data[1] = len >> 8;\r\nreturn skb;\r\n}\r\nstatic void dm9601_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nint link;\r\nu8 *buf;\r\nif (urb->actual_length < 8)\r\nreturn;\r\nbuf = urb->transfer_buffer;\r\nlink = !!(buf[0] & 0x40);\r\nif (netif_carrier_ok(dev->net) != link) {\r\nusbnet_link_change(dev, link, 1);\r\nnetdev_dbg(dev->net, "Link Status is: %d\n", link);\r\n}\r\n}\r\nstatic int dm9601_link_reset(struct usbnet *dev)\r\n{\r\nstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\r\nmii_check_media(&dev->mii, 1, 1);\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nnetdev_dbg(dev->net, "link_reset() speed: %u duplex: %d\n",\r\nethtool_cmd_speed(&ecmd), ecmd.duplex);\r\nreturn 0;\r\n}
