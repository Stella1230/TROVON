static long ioctl_restart(struct fsl_hv_ioctl_restart __user *p)\r\n{\r\nstruct fsl_hv_ioctl_restart param;\r\nif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_restart)))\r\nreturn -EFAULT;\r\nparam.ret = fh_partition_restart(param.partition);\r\nif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long ioctl_status(struct fsl_hv_ioctl_status __user *p)\r\n{\r\nstruct fsl_hv_ioctl_status param;\r\nu32 status;\r\nif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_status)))\r\nreturn -EFAULT;\r\nparam.ret = fh_partition_get_status(param.partition, &status);\r\nif (!param.ret)\r\nparam.status = status;\r\nif (copy_to_user(p, &param, sizeof(struct fsl_hv_ioctl_status)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long ioctl_start(struct fsl_hv_ioctl_start __user *p)\r\n{\r\nstruct fsl_hv_ioctl_start param;\r\nif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_start)))\r\nreturn -EFAULT;\r\nparam.ret = fh_partition_start(param.partition, param.entry_point,\r\nparam.load);\r\nif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long ioctl_stop(struct fsl_hv_ioctl_stop __user *p)\r\n{\r\nstruct fsl_hv_ioctl_stop param;\r\nif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_stop)))\r\nreturn -EFAULT;\r\nparam.ret = fh_partition_stop(param.partition);\r\nif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long ioctl_memcpy(struct fsl_hv_ioctl_memcpy __user *p)\r\n{\r\nstruct fsl_hv_ioctl_memcpy param;\r\nstruct page **pages = NULL;\r\nvoid *sg_list_unaligned = NULL;\r\nstruct fh_sg_list *sg_list = NULL;\r\nunsigned int num_pages;\r\nunsigned long lb_offset;\r\nunsigned int i;\r\nlong ret = 0;\r\nint num_pinned;\r\nphys_addr_t remote_paddr;\r\nuint32_t count;\r\nif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_memcpy)))\r\nreturn -EFAULT;\r\nif ((param.source == -1) == (param.target == -1))\r\nreturn -EINVAL;\r\nlb_offset = param.local_vaddr & (PAGE_SIZE - 1);\r\nnum_pages = (param.count + lb_offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\npages = kzalloc(num_pages * sizeof(struct page *), GFP_KERNEL);\r\nif (!pages) {\r\npr_debug("fsl-hv: could not allocate page list\n");\r\nreturn -ENOMEM;\r\n}\r\nsg_list_unaligned = kmalloc(num_pages * sizeof(struct fh_sg_list) +\r\nsizeof(struct fh_sg_list) - 1, GFP_KERNEL);\r\nif (!sg_list_unaligned) {\r\npr_debug("fsl-hv: could not allocate S/G list\n");\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nsg_list = PTR_ALIGN(sg_list_unaligned, sizeof(struct fh_sg_list));\r\ndown_read(&current->mm->mmap_sem);\r\nnum_pinned = get_user_pages(param.local_vaddr - lb_offset,\r\nnum_pages, (param.source == -1) ? READ : WRITE,\r\n0, pages, NULL);\r\nup_read(&current->mm->mmap_sem);\r\nif (num_pinned != num_pages) {\r\npr_debug("fsl-hv: could not lock source buffer\n");\r\nret = (num_pinned < 0) ? num_pinned : -EFAULT;\r\ngoto exit;\r\n}\r\nif (param.source == -1) {\r\nsg_list[0].source = page_to_phys(pages[0]) + lb_offset;\r\nsg_list[0].target = param.remote_paddr;\r\n} else {\r\nsg_list[0].source = param.remote_paddr;\r\nsg_list[0].target = page_to_phys(pages[0]) + lb_offset;\r\n}\r\nsg_list[0].size = min_t(uint64_t, param.count, PAGE_SIZE - lb_offset);\r\nremote_paddr = param.remote_paddr + sg_list[0].size;\r\ncount = param.count - sg_list[0].size;\r\nfor (i = 1; i < num_pages; i++) {\r\nif (param.source == -1) {\r\nsg_list[i].source = page_to_phys(pages[i]);\r\nsg_list[i].target = remote_paddr;\r\n} else {\r\nsg_list[i].source = remote_paddr;\r\nsg_list[i].target = page_to_phys(pages[i]);\r\n}\r\nsg_list[i].size = min_t(uint64_t, count, PAGE_SIZE);\r\nremote_paddr += sg_list[i].size;\r\ncount -= sg_list[i].size;\r\n}\r\nparam.ret = fh_partition_memcpy(param.source, param.target,\r\nvirt_to_phys(sg_list), num_pages);\r\nexit:\r\nif (pages) {\r\nfor (i = 0; i < num_pages; i++)\r\nif (pages[i])\r\nput_page(pages[i]);\r\n}\r\nkfree(sg_list_unaligned);\r\nkfree(pages);\r\nif (!ret)\r\nif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic long ioctl_doorbell(struct fsl_hv_ioctl_doorbell __user *p)\r\n{\r\nstruct fsl_hv_ioctl_doorbell param;\r\nif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_doorbell)))\r\nreturn -EFAULT;\r\nparam.ret = ev_doorbell_send(param.doorbell);\r\nif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long ioctl_dtprop(struct fsl_hv_ioctl_prop __user *p, int set)\r\n{\r\nstruct fsl_hv_ioctl_prop param;\r\nchar __user *upath, *upropname;\r\nvoid __user *upropval;\r\nchar *path = NULL, *propname = NULL;\r\nvoid *propval = NULL;\r\nint ret = 0;\r\nif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_prop)))\r\nreturn -EFAULT;\r\nupath = (char __user *)(uintptr_t)param.path;\r\nupropname = (char __user *)(uintptr_t)param.propname;\r\nupropval = (void __user *)(uintptr_t)param.propval;\r\npath = strndup_user(upath, FH_DTPROP_MAX_PATHLEN);\r\nif (IS_ERR(path)) {\r\nret = PTR_ERR(path);\r\ngoto out;\r\n}\r\npropname = strndup_user(upropname, FH_DTPROP_MAX_PATHLEN);\r\nif (IS_ERR(propname)) {\r\nret = PTR_ERR(propname);\r\ngoto out;\r\n}\r\nif (param.proplen > FH_DTPROP_MAX_PROPLEN) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npropval = kmalloc(param.proplen, GFP_KERNEL);\r\nif (!propval) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (set) {\r\nif (copy_from_user(propval, upropval, param.proplen)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nparam.ret = fh_partition_set_dtprop(param.handle,\r\nvirt_to_phys(path),\r\nvirt_to_phys(propname),\r\nvirt_to_phys(propval),\r\nparam.proplen);\r\n} else {\r\nparam.ret = fh_partition_get_dtprop(param.handle,\r\nvirt_to_phys(path),\r\nvirt_to_phys(propname),\r\nvirt_to_phys(propval),\r\n&param.proplen);\r\nif (param.ret == 0) {\r\nif (copy_to_user(upropval, propval, param.proplen) ||\r\nput_user(param.proplen, &p->proplen)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (put_user(param.ret, &p->ret))\r\nret = -EFAULT;\r\nout:\r\nkfree(path);\r\nkfree(propval);\r\nkfree(propname);\r\nreturn ret;\r\n}\r\nstatic long fsl_hv_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long argaddr)\r\n{\r\nvoid __user *arg = (void __user *)argaddr;\r\nlong ret;\r\nswitch (cmd) {\r\ncase FSL_HV_IOCTL_PARTITION_RESTART:\r\nret = ioctl_restart(arg);\r\nbreak;\r\ncase FSL_HV_IOCTL_PARTITION_GET_STATUS:\r\nret = ioctl_status(arg);\r\nbreak;\r\ncase FSL_HV_IOCTL_PARTITION_START:\r\nret = ioctl_start(arg);\r\nbreak;\r\ncase FSL_HV_IOCTL_PARTITION_STOP:\r\nret = ioctl_stop(arg);\r\nbreak;\r\ncase FSL_HV_IOCTL_MEMCPY:\r\nret = ioctl_memcpy(arg);\r\nbreak;\r\ncase FSL_HV_IOCTL_DOORBELL:\r\nret = ioctl_doorbell(arg);\r\nbreak;\r\ncase FSL_HV_IOCTL_GETPROP:\r\nret = ioctl_dtprop(arg, 0);\r\nbreak;\r\ncase FSL_HV_IOCTL_SETPROP:\r\nret = ioctl_dtprop(arg, 1);\r\nbreak;\r\ndefault:\r\npr_debug("fsl-hv: bad ioctl dir=%u type=%u cmd=%u size=%u\n",\r\n_IOC_DIR(cmd), _IOC_TYPE(cmd), _IOC_NR(cmd),\r\n_IOC_SIZE(cmd));\r\nreturn -ENOTTY;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fsl_hv_queue_doorbell(uint32_t doorbell)\r\n{\r\nstruct doorbell_queue *dbq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&db_list_lock, flags);\r\nlist_for_each_entry(dbq, &db_list, list) {\r\nif (dbq->head != nextp(dbq->tail)) {\r\ndbq->q[dbq->tail] = doorbell;\r\nsmp_wmb();\r\ndbq->tail = nextp(dbq->tail);\r\nwake_up_interruptible(&dbq->wait);\r\n}\r\n}\r\nspin_unlock_irqrestore(&db_list_lock, flags);\r\n}\r\nstatic irqreturn_t fsl_hv_isr(int irq, void *data)\r\n{\r\nfsl_hv_queue_doorbell((uintptr_t) data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t fsl_hv_state_change_thread(int irq, void *data)\r\n{\r\nstruct doorbell_isr *dbisr = data;\r\nblocking_notifier_call_chain(&failover_subscribers, dbisr->partition,\r\nNULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t fsl_hv_state_change_isr(int irq, void *data)\r\n{\r\nunsigned int status;\r\nstruct doorbell_isr *dbisr = data;\r\nint ret;\r\nfsl_hv_queue_doorbell(dbisr->doorbell);\r\nret = fh_partition_get_status(dbisr->partition, &status);\r\nif (!ret && (status == FH_PARTITION_STOPPED))\r\nreturn IRQ_WAKE_THREAD;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int fsl_hv_poll(struct file *filp, struct poll_table_struct *p)\r\n{\r\nstruct doorbell_queue *dbq = filp->private_data;\r\nunsigned long flags;\r\nunsigned int mask;\r\nspin_lock_irqsave(&dbq->lock, flags);\r\npoll_wait(filp, &dbq->wait, p);\r\nmask = (dbq->head == dbq->tail) ? 0 : (POLLIN | POLLRDNORM);\r\nspin_unlock_irqrestore(&dbq->lock, flags);\r\nreturn mask;\r\n}\r\nstatic ssize_t fsl_hv_read(struct file *filp, char __user *buf, size_t len,\r\nloff_t *off)\r\n{\r\nstruct doorbell_queue *dbq = filp->private_data;\r\nuint32_t __user *p = (uint32_t __user *) buf;\r\nunsigned long flags;\r\nssize_t count = 0;\r\nwhile (len >= sizeof(uint32_t)) {\r\nuint32_t dbell;\r\nspin_lock_irqsave(&dbq->lock, flags);\r\nif (dbq->head == dbq->tail) {\r\nspin_unlock_irqrestore(&dbq->lock, flags);\r\nif (count)\r\nbreak;\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(dbq->wait,\r\ndbq->head != dbq->tail))\r\nreturn -ERESTARTSYS;\r\ncontinue;\r\n}\r\nsmp_rmb();\r\ndbell = dbq->q[dbq->head];\r\ndbq->head = nextp(dbq->head);\r\nspin_unlock_irqrestore(&dbq->lock, flags);\r\nif (put_user(dbell, p))\r\nreturn -EFAULT;\r\np++;\r\ncount += sizeof(uint32_t);\r\nlen -= sizeof(uint32_t);\r\n}\r\nreturn count;\r\n}\r\nstatic int fsl_hv_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct doorbell_queue *dbq;\r\nunsigned long flags;\r\nint ret = 0;\r\ndbq = kzalloc(sizeof(struct doorbell_queue), GFP_KERNEL);\r\nif (!dbq) {\r\npr_err("fsl-hv: out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&dbq->lock);\r\ninit_waitqueue_head(&dbq->wait);\r\nspin_lock_irqsave(&db_list_lock, flags);\r\nlist_add(&dbq->list, &db_list);\r\nspin_unlock_irqrestore(&db_list_lock, flags);\r\nfilp->private_data = dbq;\r\nreturn ret;\r\n}\r\nstatic int fsl_hv_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct doorbell_queue *dbq = filp->private_data;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&db_list_lock, flags);\r\nlist_del(&dbq->list);\r\nspin_unlock_irqrestore(&db_list_lock, flags);\r\nkfree(dbq);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t fsl_hv_shutdown_isr(int irq, void *data)\r\n{\r\norderly_poweroff(false);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int get_parent_handle(struct device_node *np)\r\n{\r\nstruct device_node *parent;\r\nconst uint32_t *prop;\r\nuint32_t handle;\r\nint len;\r\nparent = of_get_parent(np);\r\nif (!parent)\r\nreturn -ENODEV;\r\nprop = of_get_property(parent, "hv-handle", &len);\r\nif (!prop)\r\nprop = of_get_property(parent, "reg", &len);\r\nif (!prop || (len != sizeof(uint32_t))) {\r\nof_node_put(parent);\r\nreturn -ENODEV;\r\n}\r\nhandle = be32_to_cpup(prop);\r\nof_node_put(parent);\r\nreturn handle;\r\n}\r\nint fsl_hv_failover_register(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&failover_subscribers, nb);\r\n}\r\nint fsl_hv_failover_unregister(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&failover_subscribers, nb);\r\n}\r\nstatic int has_fsl_hypervisor(void)\r\n{\r\nstruct device_node *node;\r\nint ret;\r\nnode = of_find_node_by_path("/hypervisor");\r\nif (!node)\r\nreturn 0;\r\nret = of_find_property(node, "fsl,hv-version", NULL) != NULL;\r\nof_node_put(node);\r\nreturn ret;\r\n}\r\nstatic int __init fsl_hypervisor_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct doorbell_isr *dbisr, *n;\r\nint ret;\r\npr_info("Freescale hypervisor management driver\n");\r\nif (!has_fsl_hypervisor()) {\r\npr_info("fsl-hv: no hypervisor found\n");\r\nreturn -ENODEV;\r\n}\r\nret = misc_register(&fsl_hv_misc_dev);\r\nif (ret) {\r\npr_err("fsl-hv: cannot register device\n");\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&db_list);\r\nINIT_LIST_HEAD(&isr_list);\r\nfor_each_compatible_node(np, NULL, "epapr,hv-receive-doorbell") {\r\nunsigned int irq;\r\nconst uint32_t *handle;\r\nhandle = of_get_property(np, "interrupts", NULL);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!handle || (irq == NO_IRQ)) {\r\npr_err("fsl-hv: no 'interrupts' property in %s node\n",\r\nnp->full_name);\r\ncontinue;\r\n}\r\ndbisr = kzalloc(sizeof(*dbisr), GFP_KERNEL);\r\nif (!dbisr)\r\ngoto out_of_memory;\r\ndbisr->irq = irq;\r\ndbisr->doorbell = be32_to_cpup(handle);\r\nif (of_device_is_compatible(np, "fsl,hv-shutdown-doorbell")) {\r\nret = request_irq(irq, fsl_hv_shutdown_isr, 0,\r\nnp->name, NULL);\r\n} else if (of_device_is_compatible(np,\r\n"fsl,hv-state-change-doorbell")) {\r\ndbisr->partition = ret = get_parent_handle(np);\r\nif (ret < 0) {\r\npr_err("fsl-hv: node %s has missing or "\r\n"malformed parent\n", np->full_name);\r\nkfree(dbisr);\r\ncontinue;\r\n}\r\nret = request_threaded_irq(irq, fsl_hv_state_change_isr,\r\nfsl_hv_state_change_thread,\r\n0, np->name, dbisr);\r\n} else\r\nret = request_irq(irq, fsl_hv_isr, 0, np->name, dbisr);\r\nif (ret < 0) {\r\npr_err("fsl-hv: could not request irq %u for node %s\n",\r\nirq, np->full_name);\r\nkfree(dbisr);\r\ncontinue;\r\n}\r\nlist_add(&dbisr->list, &isr_list);\r\npr_info("fsl-hv: registered handler for doorbell %u\n",\r\ndbisr->doorbell);\r\n}\r\nreturn 0;\r\nout_of_memory:\r\nlist_for_each_entry_safe(dbisr, n, &isr_list, list) {\r\nfree_irq(dbisr->irq, dbisr);\r\nlist_del(&dbisr->list);\r\nkfree(dbisr);\r\n}\r\nmisc_deregister(&fsl_hv_misc_dev);\r\nreturn -ENOMEM;\r\n}\r\nstatic void __exit fsl_hypervisor_exit(void)\r\n{\r\nstruct doorbell_isr *dbisr, *n;\r\nlist_for_each_entry_safe(dbisr, n, &isr_list, list) {\r\nfree_irq(dbisr->irq, dbisr);\r\nlist_del(&dbisr->list);\r\nkfree(dbisr);\r\n}\r\nmisc_deregister(&fsl_hv_misc_dev);\r\n}
