struct acpi_namespace_node *acpi_ns_get_next_node(struct acpi_namespace_node\r\n*parent_node,\r\nstruct acpi_namespace_node\r\n*child_node)\r\n{\r\nACPI_FUNCTION_ENTRY();\r\nif (!child_node) {\r\nreturn (parent_node->child);\r\n}\r\nreturn (child_node->peer);\r\n}\r\nstruct acpi_namespace_node *acpi_ns_get_next_node_typed(acpi_object_type type,\r\nstruct\r\nacpi_namespace_node\r\n*parent_node,\r\nstruct\r\nacpi_namespace_node\r\n*child_node)\r\n{\r\nstruct acpi_namespace_node *next_node = NULL;\r\nACPI_FUNCTION_ENTRY();\r\nnext_node = acpi_ns_get_next_node(parent_node, child_node);\r\nif (type == ACPI_TYPE_ANY) {\r\nreturn (next_node);\r\n}\r\nwhile (next_node) {\r\nif (next_node->type == type) {\r\nreturn (next_node);\r\n}\r\nnext_node = next_node->peer;\r\n}\r\nreturn (NULL);\r\n}\r\nacpi_status\r\nacpi_ns_walk_namespace(acpi_object_type type,\r\nacpi_handle start_node,\r\nu32 max_depth,\r\nu32 flags,\r\nacpi_walk_callback descending_callback,\r\nacpi_walk_callback ascending_callback,\r\nvoid *context, void **return_value)\r\n{\r\nacpi_status status;\r\nacpi_status mutex_status;\r\nstruct acpi_namespace_node *child_node;\r\nstruct acpi_namespace_node *parent_node;\r\nacpi_object_type child_type;\r\nu32 level;\r\nu8 node_previously_visited = FALSE;\r\nACPI_FUNCTION_TRACE(ns_walk_namespace);\r\nif (start_node == ACPI_ROOT_OBJECT) {\r\nstart_node = acpi_gbl_root_node;\r\n}\r\nparent_node = start_node;\r\nchild_node = acpi_ns_get_next_node(parent_node, NULL);\r\nchild_type = ACPI_TYPE_ANY;\r\nlevel = 1;\r\nwhile (level > 0 && child_node) {\r\nstatus = AE_OK;\r\nif (type != ACPI_TYPE_ANY) {\r\nchild_type = child_node->type;\r\n}\r\nif ((child_node->flags & ANOBJ_TEMPORARY) &&\r\n!(flags & ACPI_NS_WALK_TEMP_NODES)) {\r\nstatus = AE_CTRL_DEPTH;\r\n}\r\nelse if (child_type == type) {\r\nif (flags & ACPI_NS_WALK_UNLOCK) {\r\nmutex_status =\r\nacpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(mutex_status)) {\r\nreturn_ACPI_STATUS(mutex_status);\r\n}\r\n}\r\nif (!node_previously_visited) {\r\nif (descending_callback) {\r\nstatus =\r\ndescending_callback(child_node,\r\nlevel, context,\r\nreturn_value);\r\n}\r\n} else {\r\nif (ascending_callback) {\r\nstatus =\r\nascending_callback(child_node,\r\nlevel, context,\r\nreturn_value);\r\n}\r\n}\r\nif (flags & ACPI_NS_WALK_UNLOCK) {\r\nmutex_status =\r\nacpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(mutex_status)) {\r\nreturn_ACPI_STATUS(mutex_status);\r\n}\r\n}\r\nswitch (status) {\r\ncase AE_OK:\r\ncase AE_CTRL_DEPTH:\r\nbreak;\r\ncase AE_CTRL_TERMINATE:\r\nreturn_ACPI_STATUS(AE_OK);\r\ndefault:\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif (!node_previously_visited &&\r\n(level < max_depth) && (status != AE_CTRL_DEPTH)) {\r\nif (child_node->child) {\r\nlevel++;\r\nparent_node = child_node;\r\nchild_node =\r\nacpi_ns_get_next_node(parent_node, NULL);\r\ncontinue;\r\n}\r\n}\r\nif (!node_previously_visited) {\r\nnode_previously_visited = TRUE;\r\ncontinue;\r\n}\r\nchild_node = acpi_ns_get_next_node(parent_node, child_node);\r\nif (child_node) {\r\nnode_previously_visited = FALSE;\r\n}\r\nelse {\r\nlevel--;\r\nchild_node = parent_node;\r\nparent_node = parent_node->parent;\r\nnode_previously_visited = TRUE;\r\n}\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
