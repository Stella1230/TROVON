int raw_hash_sk(struct sock *sk)\r\n{\r\nstruct raw_hashinfo *h = sk->sk_prot->h.raw_hash;\r\nstruct hlist_head *head;\r\nhead = &h->ht[inet_sk(sk)->inet_num & (RAW_HTABLE_SIZE - 1)];\r\nwrite_lock_bh(&h->lock);\r\nsk_add_node(sk, head);\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\nwrite_unlock_bh(&h->lock);\r\nreturn 0;\r\n}\r\nvoid raw_unhash_sk(struct sock *sk)\r\n{\r\nstruct raw_hashinfo *h = sk->sk_prot->h.raw_hash;\r\nwrite_lock_bh(&h->lock);\r\nif (sk_del_node_init(sk))\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\r\nwrite_unlock_bh(&h->lock);\r\n}\r\nstatic struct sock *__raw_v4_lookup(struct net *net, struct sock *sk,\r\nunsigned short num, __be32 raddr, __be32 laddr, int dif)\r\n{\r\nsk_for_each_from(sk) {\r\nstruct inet_sock *inet = inet_sk(sk);\r\nif (net_eq(sock_net(sk), net) && inet->inet_num == num &&\r\n!(inet->inet_daddr && inet->inet_daddr != raddr) &&\r\n!(inet->inet_rcv_saddr && inet->inet_rcv_saddr != laddr) &&\r\n!(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))\r\ngoto found;\r\n}\r\nsk = NULL;\r\nfound:\r\nreturn sk;\r\n}\r\nstatic int icmp_filter(const struct sock *sk, const struct sk_buff *skb)\r\n{\r\nstruct icmphdr _hdr;\r\nconst struct icmphdr *hdr;\r\nhdr = skb_header_pointer(skb, skb_transport_offset(skb),\r\nsizeof(_hdr), &_hdr);\r\nif (!hdr)\r\nreturn 1;\r\nif (hdr->type < 32) {\r\n__u32 data = raw_sk(sk)->filter.data;\r\nreturn ((1U << hdr->type) & data) != 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int raw_v4_input(struct sk_buff *skb, const struct iphdr *iph, int hash)\r\n{\r\nstruct sock *sk;\r\nstruct hlist_head *head;\r\nint delivered = 0;\r\nstruct net *net;\r\nread_lock(&raw_v4_hashinfo.lock);\r\nhead = &raw_v4_hashinfo.ht[hash];\r\nif (hlist_empty(head))\r\ngoto out;\r\nnet = dev_net(skb->dev);\r\nsk = __raw_v4_lookup(net, __sk_head(head), iph->protocol,\r\niph->saddr, iph->daddr,\r\nskb->dev->ifindex);\r\nwhile (sk) {\r\ndelivered = 1;\r\nif ((iph->protocol != IPPROTO_ICMP || !icmp_filter(sk, skb)) &&\r\nip_mc_sf_allow(sk, iph->daddr, iph->saddr,\r\nskb->dev->ifindex)) {\r\nstruct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);\r\nif (clone)\r\nraw_rcv(sk, clone);\r\n}\r\nsk = __raw_v4_lookup(net, sk_next(sk), iph->protocol,\r\niph->saddr, iph->daddr,\r\nskb->dev->ifindex);\r\n}\r\nout:\r\nread_unlock(&raw_v4_hashinfo.lock);\r\nreturn delivered;\r\n}\r\nint raw_local_deliver(struct sk_buff *skb, int protocol)\r\n{\r\nint hash;\r\nstruct sock *raw_sk;\r\nhash = protocol & (RAW_HTABLE_SIZE - 1);\r\nraw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);\r\nif (raw_sk && !raw_v4_input(skb, ip_hdr(skb), hash))\r\nraw_sk = NULL;\r\nreturn raw_sk != NULL;\r\n}\r\nstatic void raw_err(struct sock *sk, struct sk_buff *skb, u32 info)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nint err = 0;\r\nint harderr = 0;\r\nif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\r\nipv4_sk_update_pmtu(skb, sk, info);\r\nelse if (type == ICMP_REDIRECT) {\r\nipv4_sk_redirect(skb, sk);\r\nreturn;\r\n}\r\nif (!inet->recverr && sk->sk_state != TCP_ESTABLISHED)\r\nreturn;\r\nswitch (type) {\r\ndefault:\r\ncase ICMP_TIME_EXCEEDED:\r\nerr = EHOSTUNREACH;\r\nbreak;\r\ncase ICMP_SOURCE_QUENCH:\r\nreturn;\r\ncase ICMP_PARAMETERPROB:\r\nerr = EPROTO;\r\nharderr = 1;\r\nbreak;\r\ncase ICMP_DEST_UNREACH:\r\nerr = EHOSTUNREACH;\r\nif (code > NR_ICMP_UNREACH)\r\nbreak;\r\nerr = icmp_err_convert[code].errno;\r\nharderr = icmp_err_convert[code].fatal;\r\nif (code == ICMP_FRAG_NEEDED) {\r\nharderr = inet->pmtudisc != IP_PMTUDISC_DONT;\r\nerr = EMSGSIZE;\r\n}\r\n}\r\nif (inet->recverr) {\r\nconst struct iphdr *iph = (const struct iphdr *)skb->data;\r\nu8 *payload = skb->data + (iph->ihl << 2);\r\nif (inet->hdrincl)\r\npayload = skb->data;\r\nip_icmp_error(sk, skb, err, 0, info, payload);\r\n}\r\nif (inet->recverr || harderr) {\r\nsk->sk_err = err;\r\nsk->sk_error_report(sk);\r\n}\r\n}\r\nvoid raw_icmp_error(struct sk_buff *skb, int protocol, u32 info)\r\n{\r\nint hash;\r\nstruct sock *raw_sk;\r\nconst struct iphdr *iph;\r\nstruct net *net;\r\nhash = protocol & (RAW_HTABLE_SIZE - 1);\r\nread_lock(&raw_v4_hashinfo.lock);\r\nraw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);\r\nif (raw_sk) {\r\niph = (const struct iphdr *)skb->data;\r\nnet = dev_net(skb->dev);\r\nwhile ((raw_sk = __raw_v4_lookup(net, raw_sk, protocol,\r\niph->daddr, iph->saddr,\r\nskb->dev->ifindex)) != NULL) {\r\nraw_err(raw_sk, skb, info);\r\nraw_sk = sk_next(raw_sk);\r\niph = (const struct iphdr *)skb->data;\r\n}\r\n}\r\nread_unlock(&raw_v4_hashinfo.lock);\r\n}\r\nstatic int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)\r\n{\r\nipv4_pktinfo_prepare(sk, skb);\r\nif (sock_queue_rcv_skb(sk, skb) < 0) {\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nreturn NET_RX_SUCCESS;\r\n}\r\nint raw_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb)) {\r\natomic_inc(&sk->sk_drops);\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nnf_reset(skb);\r\nskb_push(skb, skb->data - skb_network_header(skb));\r\nraw_rcv_skb(sk, skb);\r\nreturn 0;\r\n}\r\nstatic int raw_send_hdrinc(struct sock *sk, struct flowi4 *fl4,\r\nstruct msghdr *msg, size_t length,\r\nstruct rtable **rtp, unsigned int flags,\r\nconst struct sockcm_cookie *sockc)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct net *net = sock_net(sk);\r\nstruct iphdr *iph;\r\nstruct sk_buff *skb;\r\nunsigned int iphlen;\r\nint err;\r\nstruct rtable *rt = *rtp;\r\nint hlen, tlen;\r\nif (length > rt->dst.dev->mtu) {\r\nip_local_error(sk, EMSGSIZE, fl4->daddr, inet->inet_dport,\r\nrt->dst.dev->mtu);\r\nreturn -EMSGSIZE;\r\n}\r\nif (flags&MSG_PROBE)\r\ngoto out;\r\nhlen = LL_RESERVED_SPACE(rt->dst.dev);\r\ntlen = rt->dst.dev->needed_tailroom;\r\nskb = sock_alloc_send_skb(sk,\r\nlength + hlen + tlen + 15,\r\nflags & MSG_DONTWAIT, &err);\r\nif (!skb)\r\ngoto error;\r\nskb_reserve(skb, hlen);\r\nskb->priority = sk->sk_priority;\r\nskb->mark = sk->sk_mark;\r\nskb_dst_set(skb, &rt->dst);\r\n*rtp = NULL;\r\nskb_reset_network_header(skb);\r\niph = ip_hdr(skb);\r\nskb_put(skb, length);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nsock_tx_timestamp(sk, sockc->tsflags, &skb_shinfo(skb)->tx_flags);\r\nskb->transport_header = skb->network_header;\r\nerr = -EFAULT;\r\nif (memcpy_from_msg(iph, msg, length))\r\ngoto error_free;\r\niphlen = iph->ihl * 4;\r\nerr = -EINVAL;\r\nif (iphlen > length)\r\ngoto error_free;\r\nif (iphlen >= sizeof(*iph)) {\r\nif (!iph->saddr)\r\niph->saddr = fl4->saddr;\r\niph->check = 0;\r\niph->tot_len = htons(length);\r\nif (!iph->id)\r\nip_select_ident(net, skb, NULL);\r\niph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\r\nskb->transport_header += iphlen;\r\nif (iph->protocol == IPPROTO_ICMP &&\r\nlength >= iphlen + sizeof(struct icmphdr))\r\nicmp_out_count(net, ((struct icmphdr *)\r\nskb_transport_header(skb))->type);\r\n}\r\nerr = NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT,\r\nnet, sk, skb, NULL, rt->dst.dev,\r\ndst_output);\r\nif (err > 0)\r\nerr = net_xmit_errno(err);\r\nif (err)\r\ngoto error;\r\nout:\r\nreturn 0;\r\nerror_free:\r\nkfree_skb(skb);\r\nerror:\r\nIP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);\r\nif (err == -ENOBUFS && !inet->recverr)\r\nerr = 0;\r\nreturn err;\r\n}\r\nstatic int raw_probe_proto_opt(struct raw_frag_vec *rfv, struct flowi4 *fl4)\r\n{\r\nint err;\r\nif (fl4->flowi4_proto != IPPROTO_ICMP)\r\nreturn 0;\r\nrfv->hlen = 2;\r\nerr = memcpy_from_msg(rfv->hdr.c, rfv->msg, rfv->hlen);\r\nif (err)\r\nreturn err;\r\nfl4->fl4_icmp_type = rfv->hdr.icmph.type;\r\nfl4->fl4_icmp_code = rfv->hdr.icmph.code;\r\nreturn 0;\r\n}\r\nstatic int raw_getfrag(void *from, char *to, int offset, int len, int odd,\r\nstruct sk_buff *skb)\r\n{\r\nstruct raw_frag_vec *rfv = from;\r\nif (offset < rfv->hlen) {\r\nint copy = min(rfv->hlen - offset, len);\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nmemcpy(to, rfv->hdr.c + offset, copy);\r\nelse\r\nskb->csum = csum_block_add(\r\nskb->csum,\r\ncsum_partial_copy_nocheck(rfv->hdr.c + offset,\r\nto, copy, 0),\r\nodd);\r\nodd = 0;\r\noffset += copy;\r\nto += copy;\r\nlen -= copy;\r\nif (!len)\r\nreturn 0;\r\n}\r\noffset -= rfv->hlen;\r\nreturn ip_generic_getfrag(rfv->msg, to, offset, len, odd, skb);\r\n}\r\nstatic int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct net *net = sock_net(sk);\r\nstruct ipcm_cookie ipc;\r\nstruct rtable *rt = NULL;\r\nstruct flowi4 fl4;\r\nint free = 0;\r\n__be32 daddr;\r\n__be32 saddr;\r\nu8 tos;\r\nint err;\r\nstruct ip_options_data opt_copy;\r\nstruct raw_frag_vec rfv;\r\nerr = -EMSGSIZE;\r\nif (len > 0xFFFF)\r\ngoto out;\r\nerr = -EOPNOTSUPP;\r\nif (msg->msg_flags & MSG_OOB)\r\ngoto out;\r\nif (msg->msg_namelen) {\r\nDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\r\nerr = -EINVAL;\r\nif (msg->msg_namelen < sizeof(*usin))\r\ngoto out;\r\nif (usin->sin_family != AF_INET) {\r\npr_info_once("%s: %s forgot to set AF_INET. Fix it!\n",\r\n__func__, current->comm);\r\nerr = -EAFNOSUPPORT;\r\nif (usin->sin_family)\r\ngoto out;\r\n}\r\ndaddr = usin->sin_addr.s_addr;\r\n} else {\r\nerr = -EDESTADDRREQ;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\ndaddr = inet->inet_daddr;\r\n}\r\nipc.sockc.tsflags = sk->sk_tsflags;\r\nipc.addr = inet->inet_saddr;\r\nipc.opt = NULL;\r\nipc.tx_flags = 0;\r\nipc.ttl = 0;\r\nipc.tos = -1;\r\nipc.oif = sk->sk_bound_dev_if;\r\nif (msg->msg_controllen) {\r\nerr = ip_cmsg_send(sk, msg, &ipc, false);\r\nif (unlikely(err)) {\r\nkfree(ipc.opt);\r\ngoto out;\r\n}\r\nif (ipc.opt)\r\nfree = 1;\r\n}\r\nsaddr = ipc.addr;\r\nipc.addr = daddr;\r\nif (!ipc.opt) {\r\nstruct ip_options_rcu *inet_opt;\r\nrcu_read_lock();\r\ninet_opt = rcu_dereference(inet->inet_opt);\r\nif (inet_opt) {\r\nmemcpy(&opt_copy, inet_opt,\r\nsizeof(*inet_opt) + inet_opt->opt.optlen);\r\nipc.opt = &opt_copy.opt;\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (ipc.opt) {\r\nerr = -EINVAL;\r\nif (inet->hdrincl)\r\ngoto done;\r\nif (ipc.opt->opt.srr) {\r\nif (!daddr)\r\ngoto done;\r\ndaddr = ipc.opt->opt.faddr;\r\n}\r\n}\r\ntos = get_rtconn_flags(&ipc, sk);\r\nif (msg->msg_flags & MSG_DONTROUTE)\r\ntos |= RTO_ONLINK;\r\nif (ipv4_is_multicast(daddr)) {\r\nif (!ipc.oif)\r\nipc.oif = inet->mc_index;\r\nif (!saddr)\r\nsaddr = inet->mc_addr;\r\n} else if (!ipc.oif)\r\nipc.oif = inet->uc_index;\r\nflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\r\nRT_SCOPE_UNIVERSE,\r\ninet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\r\ninet_sk_flowi_flags(sk) |\r\n(inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\r\ndaddr, saddr, 0, 0);\r\nif (!saddr && ipc.oif) {\r\nerr = l3mdev_get_saddr(net, ipc.oif, &fl4);\r\nif (err < 0)\r\ngoto done;\r\n}\r\nif (!inet->hdrincl) {\r\nrfv.msg = msg;\r\nrfv.hlen = 0;\r\nerr = raw_probe_proto_opt(&rfv, &fl4);\r\nif (err)\r\ngoto done;\r\n}\r\nsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\r\nrt = ip_route_output_flow(net, &fl4, sk);\r\nif (IS_ERR(rt)) {\r\nerr = PTR_ERR(rt);\r\nrt = NULL;\r\ngoto done;\r\n}\r\nerr = -EACCES;\r\nif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\r\ngoto done;\r\nif (msg->msg_flags & MSG_CONFIRM)\r\ngoto do_confirm;\r\nback_from_confirm:\r\nif (inet->hdrincl)\r\nerr = raw_send_hdrinc(sk, &fl4, msg, len,\r\n&rt, msg->msg_flags, &ipc.sockc);\r\nelse {\r\nsock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);\r\nif (!ipc.addr)\r\nipc.addr = fl4.daddr;\r\nlock_sock(sk);\r\nerr = ip_append_data(sk, &fl4, raw_getfrag,\r\n&rfv, len, 0,\r\n&ipc, &rt, msg->msg_flags);\r\nif (err)\r\nip_flush_pending_frames(sk);\r\nelse if (!(msg->msg_flags & MSG_MORE)) {\r\nerr = ip_push_pending_frames(sk, &fl4);\r\nif (err == -ENOBUFS && !inet->recverr)\r\nerr = 0;\r\n}\r\nrelease_sock(sk);\r\n}\r\ndone:\r\nif (free)\r\nkfree(ipc.opt);\r\nip_rt_put(rt);\r\nout:\r\nif (err < 0)\r\nreturn err;\r\nreturn len;\r\ndo_confirm:\r\ndst_confirm(&rt->dst);\r\nif (!(msg->msg_flags & MSG_PROBE) || len)\r\ngoto back_from_confirm;\r\nerr = 0;\r\ngoto done;\r\n}\r\nstatic void raw_close(struct sock *sk, long timeout)\r\n{\r\nip_ra_control(sk, 0, NULL);\r\nsk_common_release(sk);\r\n}\r\nstatic void raw_destroy(struct sock *sk)\r\n{\r\nlock_sock(sk);\r\nip_flush_pending_frames(sk);\r\nrelease_sock(sk);\r\n}\r\nstatic int raw_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct sockaddr_in *addr = (struct sockaddr_in *) uaddr;\r\nint ret = -EINVAL;\r\nint chk_addr_ret;\r\nif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_in))\r\ngoto out;\r\nchk_addr_ret = inet_addr_type(sock_net(sk), addr->sin_addr.s_addr);\r\nret = -EADDRNOTAVAIL;\r\nif (addr->sin_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\r\nchk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\r\ngoto out;\r\ninet->inet_rcv_saddr = inet->inet_saddr = addr->sin_addr.s_addr;\r\nif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\r\ninet->inet_saddr = 0;\r\nsk_dst_reset(sk);\r\nret = 0;\r\nout: return ret;\r\n}\r\nstatic int raw_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\r\nint noblock, int flags, int *addr_len)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nsize_t copied = 0;\r\nint err = -EOPNOTSUPP;\r\nDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\r\nstruct sk_buff *skb;\r\nif (flags & MSG_OOB)\r\ngoto out;\r\nif (flags & MSG_ERRQUEUE) {\r\nerr = ip_recv_error(sk, msg, len, addr_len);\r\ngoto out;\r\n}\r\nskb = skb_recv_datagram(sk, flags, noblock, &err);\r\nif (!skb)\r\ngoto out;\r\ncopied = skb->len;\r\nif (len < copied) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_msg(skb, 0, msg, copied);\r\nif (err)\r\ngoto done;\r\nsock_recv_ts_and_drops(msg, sk, skb);\r\nif (sin) {\r\nsin->sin_family = AF_INET;\r\nsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\r\nsin->sin_port = 0;\r\nmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\r\n*addr_len = sizeof(*sin);\r\n}\r\nif (inet->cmsg_flags)\r\nip_cmsg_recv(msg, skb);\r\nif (flags & MSG_TRUNC)\r\ncopied = skb->len;\r\ndone:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nif (err)\r\nreturn err;\r\nreturn copied;\r\n}\r\nstatic int raw_init(struct sock *sk)\r\n{\r\nstruct raw_sock *rp = raw_sk(sk);\r\nif (inet_sk(sk)->inet_num == IPPROTO_ICMP)\r\nmemset(&rp->filter, 0, sizeof(rp->filter));\r\nreturn 0;\r\n}\r\nstatic int raw_seticmpfilter(struct sock *sk, char __user *optval, int optlen)\r\n{\r\nif (optlen > sizeof(struct icmp_filter))\r\noptlen = sizeof(struct icmp_filter);\r\nif (copy_from_user(&raw_sk(sk)->filter, optval, optlen))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int raw_geticmpfilter(struct sock *sk, char __user *optval, int __user *optlen)\r\n{\r\nint len, ret = -EFAULT;\r\nif (get_user(len, optlen))\r\ngoto out;\r\nret = -EINVAL;\r\nif (len < 0)\r\ngoto out;\r\nif (len > sizeof(struct icmp_filter))\r\nlen = sizeof(struct icmp_filter);\r\nret = -EFAULT;\r\nif (put_user(len, optlen) ||\r\ncopy_to_user(optval, &raw_sk(sk)->filter, len))\r\ngoto out;\r\nret = 0;\r\nout: return ret;\r\n}\r\nstatic int do_raw_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nif (optname == ICMP_FILTER) {\r\nif (inet_sk(sk)->inet_num != IPPROTO_ICMP)\r\nreturn -EOPNOTSUPP;\r\nelse\r\nreturn raw_seticmpfilter(sk, optval, optlen);\r\n}\r\nreturn -ENOPROTOOPT;\r\n}\r\nstatic int raw_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nif (level != SOL_RAW)\r\nreturn ip_setsockopt(sk, level, optname, optval, optlen);\r\nreturn do_raw_setsockopt(sk, level, optname, optval, optlen);\r\n}\r\nstatic int compat_raw_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nif (level != SOL_RAW)\r\nreturn compat_ip_setsockopt(sk, level, optname, optval, optlen);\r\nreturn do_raw_setsockopt(sk, level, optname, optval, optlen);\r\n}\r\nstatic int do_raw_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nif (optname == ICMP_FILTER) {\r\nif (inet_sk(sk)->inet_num != IPPROTO_ICMP)\r\nreturn -EOPNOTSUPP;\r\nelse\r\nreturn raw_geticmpfilter(sk, optval, optlen);\r\n}\r\nreturn -ENOPROTOOPT;\r\n}\r\nstatic int raw_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nif (level != SOL_RAW)\r\nreturn ip_getsockopt(sk, level, optname, optval, optlen);\r\nreturn do_raw_getsockopt(sk, level, optname, optval, optlen);\r\n}\r\nstatic int compat_raw_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nif (level != SOL_RAW)\r\nreturn compat_ip_getsockopt(sk, level, optname, optval, optlen);\r\nreturn do_raw_getsockopt(sk, level, optname, optval, optlen);\r\n}\r\nstatic int raw_ioctl(struct sock *sk, int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase SIOCOUTQ: {\r\nint amount = sk_wmem_alloc_get(sk);\r\nreturn put_user(amount, (int __user *)arg);\r\n}\r\ncase SIOCINQ: {\r\nstruct sk_buff *skb;\r\nint amount = 0;\r\nspin_lock_bh(&sk->sk_receive_queue.lock);\r\nskb = skb_peek(&sk->sk_receive_queue);\r\nif (skb)\r\namount = skb->len;\r\nspin_unlock_bh(&sk->sk_receive_queue.lock);\r\nreturn put_user(amount, (int __user *)arg);\r\n}\r\ndefault:\r\n#ifdef CONFIG_IP_MROUTE\r\nreturn ipmr_ioctl(sk, cmd, (void __user *)arg);\r\n#else\r\nreturn -ENOIOCTLCMD;\r\n#endif\r\n}\r\n}\r\nstatic int compat_raw_ioctl(struct sock *sk, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase SIOCOUTQ:\r\ncase SIOCINQ:\r\nreturn -ENOIOCTLCMD;\r\ndefault:\r\n#ifdef CONFIG_IP_MROUTE\r\nreturn ipmr_compat_ioctl(sk, cmd, compat_ptr(arg));\r\n#else\r\nreturn -ENOIOCTLCMD;\r\n#endif\r\n}\r\n}\r\nstatic struct sock *raw_get_first(struct seq_file *seq)\r\n{\r\nstruct sock *sk;\r\nstruct raw_iter_state *state = raw_seq_private(seq);\r\nfor (state->bucket = 0; state->bucket < RAW_HTABLE_SIZE;\r\n++state->bucket) {\r\nsk_for_each(sk, &state->h->ht[state->bucket])\r\nif (sock_net(sk) == seq_file_net(seq))\r\ngoto found;\r\n}\r\nsk = NULL;\r\nfound:\r\nreturn sk;\r\n}\r\nstatic struct sock *raw_get_next(struct seq_file *seq, struct sock *sk)\r\n{\r\nstruct raw_iter_state *state = raw_seq_private(seq);\r\ndo {\r\nsk = sk_next(sk);\r\ntry_again:\r\n;\r\n} while (sk && sock_net(sk) != seq_file_net(seq));\r\nif (!sk && ++state->bucket < RAW_HTABLE_SIZE) {\r\nsk = sk_head(&state->h->ht[state->bucket]);\r\ngoto try_again;\r\n}\r\nreturn sk;\r\n}\r\nstatic struct sock *raw_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct sock *sk = raw_get_first(seq);\r\nif (sk)\r\nwhile (pos && (sk = raw_get_next(seq, sk)) != NULL)\r\n--pos;\r\nreturn pos ? NULL : sk;\r\n}\r\nvoid *raw_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct raw_iter_state *state = raw_seq_private(seq);\r\nread_lock(&state->h->lock);\r\nreturn *pos ? raw_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\r\n}\r\nvoid *raw_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct sock *sk;\r\nif (v == SEQ_START_TOKEN)\r\nsk = raw_get_first(seq);\r\nelse\r\nsk = raw_get_next(seq, v);\r\n++*pos;\r\nreturn sk;\r\n}\r\nvoid raw_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nstruct raw_iter_state *state = raw_seq_private(seq);\r\nread_unlock(&state->h->lock);\r\n}\r\nstatic void raw_sock_seq_show(struct seq_file *seq, struct sock *sp, int i)\r\n{\r\nstruct inet_sock *inet = inet_sk(sp);\r\n__be32 dest = inet->inet_daddr,\r\nsrc = inet->inet_rcv_saddr;\r\n__u16 destp = 0,\r\nsrcp = inet->inet_num;\r\nseq_printf(seq, "%4d: %08X:%04X %08X:%04X"\r\n" %02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %d\n",\r\ni, src, srcp, dest, destp, sp->sk_state,\r\nsk_wmem_alloc_get(sp),\r\nsk_rmem_alloc_get(sp),\r\n0, 0L, 0,\r\nfrom_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\r\n0, sock_i_ino(sp),\r\natomic_read(&sp->sk_refcnt), sp, atomic_read(&sp->sk_drops));\r\n}\r\nstatic int raw_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_printf(seq, " sl local_address rem_address st tx_queue "\r\n"rx_queue tr tm->when retrnsmt uid timeout "\r\n"inode ref pointer drops\n");\r\nelse\r\nraw_sock_seq_show(seq, v, raw_seq_private(seq)->bucket);\r\nreturn 0;\r\n}\r\nint raw_seq_open(struct inode *ino, struct file *file,\r\nstruct raw_hashinfo *h, const struct seq_operations *ops)\r\n{\r\nint err;\r\nstruct raw_iter_state *i;\r\nerr = seq_open_net(ino, file, ops, sizeof(struct raw_iter_state));\r\nif (err < 0)\r\nreturn err;\r\ni = raw_seq_private((struct seq_file *)file->private_data);\r\ni->h = h;\r\nreturn 0;\r\n}\r\nstatic int raw_v4_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn raw_seq_open(inode, file, &raw_v4_hashinfo, &raw_seq_ops);\r\n}\r\nstatic __net_init int raw_init_net(struct net *net)\r\n{\r\nif (!proc_create("raw", S_IRUGO, net->proc_net, &raw_seq_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic __net_exit void raw_exit_net(struct net *net)\r\n{\r\nremove_proc_entry("raw", net->proc_net);\r\n}\r\nint __init raw_proc_init(void)\r\n{\r\nreturn register_pernet_subsys(&raw_net_ops);\r\n}\r\nvoid __init raw_proc_exit(void)\r\n{\r\nunregister_pernet_subsys(&raw_net_ops);\r\n}
