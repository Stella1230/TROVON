static int xen_acpi_processor_enable(struct acpi_device *device)\r\n{\r\nacpi_status status = 0;\r\nunsigned long long value;\r\nunion acpi_object object = { 0 };\r\nstruct acpi_buffer buffer = { sizeof(union acpi_object), &object };\r\nstruct acpi_processor *pr = acpi_driver_data(device);\r\nif (!strcmp(acpi_device_hid(device), ACPI_PROCESSOR_OBJECT_HID)) {\r\nstatus = acpi_evaluate_object(pr->handle, NULL, NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\npr_err(PREFIX "Evaluating processor object\n");\r\nreturn -ENODEV;\r\n}\r\npr->acpi_id = object.processor.proc_id;\r\n} else {\r\nstatus = acpi_evaluate_integer(pr->handle, METHOD_NAME__UID,\r\nNULL, &value);\r\nif (ACPI_FAILURE(status)) {\r\npr_err(PREFIX "Evaluating processor _UID\n");\r\nreturn -ENODEV;\r\n}\r\npr->acpi_id = value;\r\n}\r\npr->id = xen_pcpu_id(pr->acpi_id);\r\nif (invalid_logical_cpuid(pr->id))\r\nif (ACPI_FAILURE(xen_acpi_cpu_hotadd(pr))) {\r\npr_err(PREFIX "Hotadd CPU (acpi_id = %d) failed.\n",\r\npr->acpi_id);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xen_acpi_processor_add(struct acpi_device *device)\r\n{\r\nint ret;\r\nstruct acpi_processor *pr;\r\nif (!device)\r\nreturn -EINVAL;\r\npr = kzalloc(sizeof(struct acpi_processor), GFP_KERNEL);\r\nif (!pr)\r\nreturn -ENOMEM;\r\npr->handle = device->handle;\r\nstrcpy(acpi_device_name(device), ACPI_PROCESSOR_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_PROCESSOR_CLASS);\r\ndevice->driver_data = pr;\r\nret = xen_acpi_processor_enable(device);\r\nif (ret)\r\npr_err(PREFIX "Error when enabling Xen processor\n");\r\nreturn ret;\r\n}\r\nstatic int xen_acpi_processor_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_processor *pr;\r\nif (!device)\r\nreturn -EINVAL;\r\npr = acpi_driver_data(device);\r\nif (!pr)\r\nreturn -EINVAL;\r\nkfree(pr);\r\nreturn 0;\r\n}\r\nstatic int is_processor_present(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nunsigned long long sta = 0;\r\nstatus = acpi_evaluate_integer(handle, "_STA", NULL, &sta);\r\nif (ACPI_SUCCESS(status) && (sta & ACPI_STA_DEVICE_PRESENT))\r\nreturn 1;\r\nif (status == AE_NOT_FOUND)\r\npr_info(PREFIX "Processor does not support hot plug\n");\r\nelse\r\npr_info(PREFIX "Processor Device is not present");\r\nreturn 0;\r\n}\r\nstatic int xen_apic_id(acpi_handle handle)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nstruct acpi_madt_local_apic *lapic;\r\nint apic_id;\r\nif (ACPI_FAILURE(acpi_evaluate_object(handle, "_MAT", NULL, &buffer)))\r\nreturn -EINVAL;\r\nif (!buffer.length || !buffer.pointer)\r\nreturn -EINVAL;\r\nobj = buffer.pointer;\r\nif (obj->type != ACPI_TYPE_BUFFER ||\r\nobj->buffer.length < sizeof(*lapic)) {\r\nkfree(buffer.pointer);\r\nreturn -EINVAL;\r\n}\r\nlapic = (struct acpi_madt_local_apic *)obj->buffer.pointer;\r\nif (lapic->header.type != ACPI_MADT_TYPE_LOCAL_APIC ||\r\n!(lapic->lapic_flags & ACPI_MADT_ENABLED)) {\r\nkfree(buffer.pointer);\r\nreturn -EINVAL;\r\n}\r\napic_id = (uint32_t)lapic->id;\r\nkfree(buffer.pointer);\r\nbuffer.length = ACPI_ALLOCATE_BUFFER;\r\nbuffer.pointer = NULL;\r\nreturn apic_id;\r\n}\r\nstatic int xen_hotadd_cpu(struct acpi_processor *pr)\r\n{\r\nint cpu_id, apic_id, pxm;\r\nstruct xen_platform_op op;\r\napic_id = xen_apic_id(pr->handle);\r\nif (apic_id < 0) {\r\npr_err(PREFIX "Failed to get apic_id for acpi_id %d\n",\r\npr->acpi_id);\r\nreturn -ENODEV;\r\n}\r\npxm = xen_acpi_get_pxm(pr->handle);\r\nif (pxm < 0) {\r\npr_err(PREFIX "Failed to get _PXM for acpi_id %d\n",\r\npr->acpi_id);\r\nreturn pxm;\r\n}\r\nop.cmd = XENPF_cpu_hotadd;\r\nop.u.cpu_add.apic_id = apic_id;\r\nop.u.cpu_add.acpi_id = pr->acpi_id;\r\nop.u.cpu_add.pxm = pxm;\r\ncpu_id = HYPERVISOR_platform_op(&op);\r\nif (cpu_id < 0)\r\npr_err(PREFIX "Failed to hotadd CPU for acpi_id %d\n",\r\npr->acpi_id);\r\nreturn cpu_id;\r\n}\r\nstatic acpi_status xen_acpi_cpu_hotadd(struct acpi_processor *pr)\r\n{\r\nif (!is_processor_present(pr->handle))\r\nreturn AE_ERROR;\r\npr->id = xen_hotadd_cpu(pr);\r\nif (invalid_logical_cpuid(pr->id))\r\nreturn AE_ERROR;\r\nxen_pcpu_hotplug_sync();\r\nreturn AE_OK;\r\n}\r\nstatic int acpi_processor_device_remove(struct acpi_device *device)\r\n{\r\npr_debug(PREFIX "Xen does not support CPU hotremove\n");\r\nreturn -ENOSYS;\r\n}\r\nstatic void acpi_processor_hotplug_notify(acpi_handle handle,\r\nu32 event, void *data)\r\n{\r\nstruct acpi_processor *pr;\r\nstruct acpi_device *device = NULL;\r\nu32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;\r\nint result;\r\nacpi_scan_lock_acquire();\r\nswitch (event) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Processor driver received %s event\n",\r\n(event == ACPI_NOTIFY_BUS_CHECK) ?\r\n"ACPI_NOTIFY_BUS_CHECK" : "ACPI_NOTIFY_DEVICE_CHECK"));\r\nif (!is_processor_present(handle))\r\nbreak;\r\nacpi_bus_get_device(handle, &device);\r\nif (acpi_device_enumerated(device))\r\nbreak;\r\nresult = acpi_bus_scan(handle);\r\nif (result) {\r\npr_err(PREFIX "Unable to add the device\n");\r\nbreak;\r\n}\r\ndevice = NULL;\r\nacpi_bus_get_device(handle, &device);\r\nif (!acpi_device_enumerated(device)) {\r\npr_err(PREFIX "Missing device object\n");\r\nbreak;\r\n}\r\nost_code = ACPI_OST_SC_SUCCESS;\r\nbreak;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"received ACPI_NOTIFY_EJECT_REQUEST\n"));\r\nif (acpi_bus_get_device(handle, &device)) {\r\npr_err(PREFIX "Device don't exist, dropping EJECT\n");\r\nbreak;\r\n}\r\npr = acpi_driver_data(device);\r\nif (!pr) {\r\npr_err(PREFIX "Driver data is NULL, dropping EJECT\n");\r\nbreak;\r\n}\r\nacpi_processor_device_remove(device);\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\ngoto out;\r\n}\r\n(void) acpi_evaluate_ost(handle, event, ost_code, NULL);\r\nout:\r\nacpi_scan_lock_release();\r\n}\r\nstatic acpi_status is_processor_device(acpi_handle handle)\r\n{\r\nstruct acpi_device_info *info;\r\nchar *hid;\r\nacpi_status status;\r\nstatus = acpi_get_object_info(handle, &info);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nif (info->type == ACPI_TYPE_PROCESSOR) {\r\nkfree(info);\r\nreturn AE_OK;\r\n}\r\nif (!(info->valid & ACPI_VALID_HID)) {\r\nkfree(info);\r\nreturn AE_ERROR;\r\n}\r\nhid = info->hardware_id.string;\r\nif ((hid == NULL) || strcmp(hid, ACPI_PROCESSOR_DEVICE_HID)) {\r\nkfree(info);\r\nreturn AE_ERROR;\r\n}\r\nkfree(info);\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status\r\nprocessor_walk_namespace_cb(acpi_handle handle,\r\nu32 lvl, void *context, void **rv)\r\n{\r\nacpi_status status;\r\nint *action = context;\r\nstatus = is_processor_device(handle);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nswitch (*action) {\r\ncase INSTALL_NOTIFY_HANDLER:\r\nacpi_install_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\nacpi_processor_hotplug_notify,\r\nNULL);\r\nbreak;\r\ncase UNINSTALL_NOTIFY_HANDLER:\r\nacpi_remove_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\nacpi_processor_hotplug_notify);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn AE_CTRL_DEPTH;\r\n}\r\nstatic\r\nvoid acpi_processor_install_hotplug_notify(void)\r\n{\r\nint action = INSTALL_NOTIFY_HANDLER;\r\nacpi_walk_namespace(ACPI_TYPE_ANY,\r\nACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nprocessor_walk_namespace_cb, NULL, &action, NULL);\r\n}\r\nstatic\r\nvoid acpi_processor_uninstall_hotplug_notify(void)\r\n{\r\nint action = UNINSTALL_NOTIFY_HANDLER;\r\nacpi_walk_namespace(ACPI_TYPE_ANY,\r\nACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nprocessor_walk_namespace_cb, NULL, &action, NULL);\r\n}\r\nstatic int __init xen_acpi_processor_init(void)\r\n{\r\nint result = 0;\r\nif (!xen_initial_domain())\r\nreturn -ENODEV;\r\nxen_stub_processor_exit();\r\nresult = acpi_bus_register_driver(&xen_acpi_processor_driver);\r\nif (result < 0) {\r\nxen_stub_processor_init();\r\nreturn result;\r\n}\r\nacpi_processor_install_hotplug_notify();\r\nreturn 0;\r\n}\r\nstatic void __exit xen_acpi_processor_exit(void)\r\n{\r\nif (!xen_initial_domain())\r\nreturn;\r\nacpi_processor_uninstall_hotplug_notify();\r\nacpi_bus_unregister_driver(&xen_acpi_processor_driver);\r\nxen_stub_processor_init();\r\nreturn;\r\n}
