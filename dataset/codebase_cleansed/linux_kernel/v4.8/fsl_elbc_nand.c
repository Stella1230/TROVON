static int fsl_elbc_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nif (section >= chip->ecc.steps)\r\nreturn -ERANGE;\r\noobregion->offset = (16 * section) + 6;\r\nif (priv->fmr & FMR_ECCM)\r\noobregion->offset += 2;\r\noobregion->length = chip->ecc.bytes;\r\nreturn 0;\r\n}\r\nstatic int fsl_elbc_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nif (section > chip->ecc.steps)\r\nreturn -ERANGE;\r\nif (!section) {\r\noobregion->offset = 0;\r\nif (mtd->writesize > 512)\r\noobregion->offset++;\r\noobregion->length = (priv->fmr & FMR_ECCM) ? 7 : 5;\r\n} else {\r\noobregion->offset = (16 * section) -\r\n((priv->fmr & FMR_ECCM) ? 5 : 7);\r\nif (section < chip->ecc.steps)\r\noobregion->length = 13;\r\nelse\r\noobregion->length = mtd->oobsize - oobregion->offset;\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\r\nint buf_num;\r\nelbc_fcm_ctrl->page = page_addr;\r\nif (priv->page_size) {\r\nout_be32(&lbc->fbar, page_addr >> 6);\r\nout_be32(&lbc->fpar,\r\n((page_addr << FPAR_LP_PI_SHIFT) & FPAR_LP_PI) |\r\n(oob ? FPAR_LP_MS : 0) | column);\r\nbuf_num = (page_addr & 1) << 2;\r\n} else {\r\nout_be32(&lbc->fbar, page_addr >> 5);\r\nout_be32(&lbc->fpar,\r\n((page_addr << FPAR_SP_PI_SHIFT) & FPAR_SP_PI) |\r\n(oob ? FPAR_SP_MS : 0) | column);\r\nbuf_num = page_addr & 7;\r\n}\r\nelbc_fcm_ctrl->addr = priv->vbase + buf_num * 1024;\r\nelbc_fcm_ctrl->index = column;\r\nif (oob)\r\nelbc_fcm_ctrl->index += priv->page_size ? 2048 : 512;\r\ndev_vdbg(priv->dev, "set_addr: bank=%d, "\r\n"elbc_fcm_ctrl->addr=0x%p (0x%p), "\r\n"index %x, pes %d ps %d\n",\r\nbuf_num, elbc_fcm_ctrl->addr, priv->vbase,\r\nelbc_fcm_ctrl->index,\r\nchip->phys_erase_shift, chip->page_shift);\r\n}\r\nstatic int fsl_elbc_run_command(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nout_be32(&lbc->fmr, priv->fmr | 3);\r\nif (elbc_fcm_ctrl->use_mdr)\r\nout_be32(&lbc->mdr, elbc_fcm_ctrl->mdr);\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_run_command: fmr=%08x fir=%08x fcr=%08x\n",\r\nin_be32(&lbc->fmr), in_be32(&lbc->fir), in_be32(&lbc->fcr));\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_run_command: fbar=%08x fpar=%08x "\r\n"fbcr=%08x bank=%d\n",\r\nin_be32(&lbc->fbar), in_be32(&lbc->fpar),\r\nin_be32(&lbc->fbcr), priv->bank);\r\nctrl->irq_status = 0;\r\nout_be32(&lbc->lsor, priv->bank);\r\nwait_event_timeout(ctrl->irq_wait, ctrl->irq_status,\r\nFCM_TIMEOUT_MSECS * HZ/1000);\r\nelbc_fcm_ctrl->status = ctrl->irq_status;\r\nif (elbc_fcm_ctrl->use_mdr)\r\nelbc_fcm_ctrl->mdr = in_be32(&lbc->mdr);\r\nelbc_fcm_ctrl->use_mdr = 0;\r\nif (elbc_fcm_ctrl->status != LTESR_CC) {\r\ndev_info(priv->dev,\r\n"command failed: fir %x fcr %x status %x mdr %x\n",\r\nin_be32(&lbc->fir), in_be32(&lbc->fcr),\r\nelbc_fcm_ctrl->status, elbc_fcm_ctrl->mdr);\r\nreturn -EIO;\r\n}\r\nif (chip->ecc.mode != NAND_ECC_HW)\r\nreturn 0;\r\nelbc_fcm_ctrl->max_bitflips = 0;\r\nif (elbc_fcm_ctrl->read_bytes == mtd->writesize + mtd->oobsize) {\r\nuint32_t lteccr = in_be32(&lbc->lteccr);\r\nif (lteccr & 0x000F000F)\r\nout_be32(&lbc->lteccr, 0x000F000F);\r\nif (lteccr & 0x000F0000) {\r\nmtd->ecc_stats.corrected++;\r\nelbc_fcm_ctrl->max_bitflips = 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsl_elbc_do_read(struct nand_chip *chip, int oob)\r\n{\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nif (priv->page_size) {\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_CA << FIR_OP1_SHIFT) |\r\n(FIR_OP_PA << FIR_OP2_SHIFT) |\r\n(FIR_OP_CM1 << FIR_OP3_SHIFT) |\r\n(FIR_OP_RBW << FIR_OP4_SHIFT));\r\nout_be32(&lbc->fcr, (NAND_CMD_READ0 << FCR_CMD0_SHIFT) |\r\n(NAND_CMD_READSTART << FCR_CMD1_SHIFT));\r\n} else {\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_CA << FIR_OP1_SHIFT) |\r\n(FIR_OP_PA << FIR_OP2_SHIFT) |\r\n(FIR_OP_RBW << FIR_OP3_SHIFT));\r\nif (oob)\r\nout_be32(&lbc->fcr, NAND_CMD_READOOB << FCR_CMD0_SHIFT);\r\nelse\r\nout_be32(&lbc->fcr, NAND_CMD_READ0 << FCR_CMD0_SHIFT);\r\n}\r\n}\r\nstatic void fsl_elbc_cmdfunc(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nelbc_fcm_ctrl->use_mdr = 0;\r\nelbc_fcm_ctrl->read_bytes = 0;\r\nif (command != NAND_CMD_PAGEPROG)\r\nelbc_fcm_ctrl->index = 0;\r\nswitch (command) {\r\ncase NAND_CMD_READ1:\r\ncolumn += 256;\r\ncase NAND_CMD_READ0:\r\ndev_dbg(priv->dev,\r\n"fsl_elbc_cmdfunc: NAND_CMD_READ0, page_addr:"\r\n" 0x%x, column: 0x%x.\n", page_addr, column);\r\nout_be32(&lbc->fbcr, 0);\r\nset_addr(mtd, 0, page_addr, 0);\r\nelbc_fcm_ctrl->read_bytes = mtd->writesize + mtd->oobsize;\r\nelbc_fcm_ctrl->index += column;\r\nfsl_elbc_do_read(chip, 0);\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_READOOB:\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_cmdfunc: NAND_CMD_READOOB, page_addr:"\r\n" 0x%x, column: 0x%x.\n", page_addr, column);\r\nout_be32(&lbc->fbcr, mtd->oobsize - column);\r\nset_addr(mtd, column, page_addr, 1);\r\nelbc_fcm_ctrl->read_bytes = mtd->writesize + mtd->oobsize;\r\nfsl_elbc_do_read(chip, 1);\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_READID:\r\ncase NAND_CMD_PARAM:\r\ndev_vdbg(priv->dev, "fsl_elbc_cmdfunc: NAND_CMD %x\n", command);\r\nout_be32(&lbc->fir, (FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_UA << FIR_OP1_SHIFT) |\r\n(FIR_OP_RBW << FIR_OP2_SHIFT));\r\nout_be32(&lbc->fcr, command << FCR_CMD0_SHIFT);\r\nout_be32(&lbc->fbcr, 256);\r\nelbc_fcm_ctrl->read_bytes = 256;\r\nelbc_fcm_ctrl->use_mdr = 1;\r\nelbc_fcm_ctrl->mdr = column;\r\nset_addr(mtd, 0, 0, 0);\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_ERASE1:\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_cmdfunc: NAND_CMD_ERASE1, "\r\n"page_addr: 0x%x.\n", page_addr);\r\nset_addr(mtd, 0, page_addr, 0);\r\nreturn;\r\ncase NAND_CMD_ERASE2:\r\ndev_vdbg(priv->dev, "fsl_elbc_cmdfunc: NAND_CMD_ERASE2.\n");\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_PA << FIR_OP1_SHIFT) |\r\n(FIR_OP_CM2 << FIR_OP2_SHIFT) |\r\n(FIR_OP_CW1 << FIR_OP3_SHIFT) |\r\n(FIR_OP_RS << FIR_OP4_SHIFT));\r\nout_be32(&lbc->fcr,\r\n(NAND_CMD_ERASE1 << FCR_CMD0_SHIFT) |\r\n(NAND_CMD_STATUS << FCR_CMD1_SHIFT) |\r\n(NAND_CMD_ERASE2 << FCR_CMD2_SHIFT));\r\nout_be32(&lbc->fbcr, 0);\r\nelbc_fcm_ctrl->read_bytes = 0;\r\nelbc_fcm_ctrl->use_mdr = 1;\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_SEQIN: {\r\n__be32 fcr;\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_cmdfunc: NAND_CMD_SEQIN/PAGE_PROG, "\r\n"page_addr: 0x%x, column: 0x%x.\n",\r\npage_addr, column);\r\nelbc_fcm_ctrl->column = column;\r\nelbc_fcm_ctrl->use_mdr = 1;\r\nif (column >= mtd->writesize) {\r\ncolumn -= mtd->writesize;\r\nelbc_fcm_ctrl->oob = 1;\r\n} else {\r\nWARN_ON(column != 0);\r\nelbc_fcm_ctrl->oob = 0;\r\n}\r\nfcr = (NAND_CMD_STATUS << FCR_CMD1_SHIFT) |\r\n(NAND_CMD_SEQIN << FCR_CMD2_SHIFT) |\r\n(NAND_CMD_PAGEPROG << FCR_CMD3_SHIFT);\r\nif (priv->page_size) {\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM2 << FIR_OP0_SHIFT) |\r\n(FIR_OP_CA << FIR_OP1_SHIFT) |\r\n(FIR_OP_PA << FIR_OP2_SHIFT) |\r\n(FIR_OP_WB << FIR_OP3_SHIFT) |\r\n(FIR_OP_CM3 << FIR_OP4_SHIFT) |\r\n(FIR_OP_CW1 << FIR_OP5_SHIFT) |\r\n(FIR_OP_RS << FIR_OP6_SHIFT));\r\n} else {\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_CM2 << FIR_OP1_SHIFT) |\r\n(FIR_OP_CA << FIR_OP2_SHIFT) |\r\n(FIR_OP_PA << FIR_OP3_SHIFT) |\r\n(FIR_OP_WB << FIR_OP4_SHIFT) |\r\n(FIR_OP_CM3 << FIR_OP5_SHIFT) |\r\n(FIR_OP_CW1 << FIR_OP6_SHIFT) |\r\n(FIR_OP_RS << FIR_OP7_SHIFT));\r\nif (elbc_fcm_ctrl->oob)\r\nfcr |= NAND_CMD_READOOB << FCR_CMD0_SHIFT;\r\nelse\r\nfcr |= NAND_CMD_READ0 << FCR_CMD0_SHIFT;\r\n}\r\nout_be32(&lbc->fcr, fcr);\r\nset_addr(mtd, column, page_addr, elbc_fcm_ctrl->oob);\r\nreturn;\r\n}\r\ncase NAND_CMD_PAGEPROG: {\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_cmdfunc: NAND_CMD_PAGEPROG "\r\n"writing %d bytes.\n", elbc_fcm_ctrl->index);\r\nif (elbc_fcm_ctrl->oob || elbc_fcm_ctrl->column != 0 ||\r\nelbc_fcm_ctrl->index != mtd->writesize + mtd->oobsize)\r\nout_be32(&lbc->fbcr,\r\nelbc_fcm_ctrl->index - elbc_fcm_ctrl->column);\r\nelse\r\nout_be32(&lbc->fbcr, 0);\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\n}\r\ncase NAND_CMD_STATUS:\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_RBW << FIR_OP1_SHIFT));\r\nout_be32(&lbc->fcr, NAND_CMD_STATUS << FCR_CMD0_SHIFT);\r\nout_be32(&lbc->fbcr, 1);\r\nset_addr(mtd, 0, 0, 0);\r\nelbc_fcm_ctrl->read_bytes = 1;\r\nfsl_elbc_run_command(mtd);\r\nsetbits8(elbc_fcm_ctrl->addr, NAND_STATUS_WP);\r\nreturn;\r\ncase NAND_CMD_RESET:\r\ndev_dbg(priv->dev, "fsl_elbc_cmdfunc: NAND_CMD_RESET.\n");\r\nout_be32(&lbc->fir, FIR_OP_CM0 << FIR_OP0_SHIFT);\r\nout_be32(&lbc->fcr, NAND_CMD_RESET << FCR_CMD0_SHIFT);\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\ndefault:\r\ndev_err(priv->dev,\r\n"fsl_elbc_cmdfunc: error, unsupported command 0x%x.\n",\r\ncommand);\r\n}\r\n}\r\nstatic void fsl_elbc_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\n}\r\nstatic void fsl_elbc_write_buf(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nunsigned int bufsize = mtd->writesize + mtd->oobsize;\r\nif (len <= 0) {\r\ndev_err(priv->dev, "write_buf of %d bytes", len);\r\nelbc_fcm_ctrl->status = 0;\r\nreturn;\r\n}\r\nif ((unsigned int)len > bufsize - elbc_fcm_ctrl->index) {\r\ndev_err(priv->dev,\r\n"write_buf beyond end of buffer "\r\n"(%d requested, %u available)\n",\r\nlen, bufsize - elbc_fcm_ctrl->index);\r\nlen = bufsize - elbc_fcm_ctrl->index;\r\n}\r\nmemcpy_toio(&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index], buf, len);\r\nin_8(&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index] + len - 1);\r\nelbc_fcm_ctrl->index += len;\r\n}\r\nstatic u8 fsl_elbc_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nif (elbc_fcm_ctrl->index < elbc_fcm_ctrl->read_bytes)\r\nreturn in_8(&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index++]);\r\ndev_err(priv->dev, "read_byte beyond end of buffer\n");\r\nreturn ERR_BYTE;\r\n}\r\nstatic void fsl_elbc_read_buf(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nint avail;\r\nif (len < 0)\r\nreturn;\r\navail = min((unsigned int)len,\r\nelbc_fcm_ctrl->read_bytes - elbc_fcm_ctrl->index);\r\nmemcpy_fromio(buf, &elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index], avail);\r\nelbc_fcm_ctrl->index += avail;\r\nif (len > avail)\r\ndev_err(priv->dev,\r\n"read_buf beyond end of buffer "\r\n"(%d requested, %d available)\n",\r\nlen, avail);\r\n}\r\nstatic int fsl_elbc_wait(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nif (elbc_fcm_ctrl->status != LTESR_CC)\r\nreturn NAND_STATUS_FAIL;\r\nreturn (elbc_fcm_ctrl->mdr & 0xff) | NAND_STATUS_WP;\r\n}\r\nstatic int fsl_elbc_chip_init_tail(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nunsigned int al;\r\nal = 0;\r\nif (chip->pagemask & 0xffff0000)\r\nal++;\r\nif (chip->pagemask & 0xff000000)\r\nal++;\r\npriv->fmr |= al << FMR_AL_SHIFT;\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->numchips = %d\n",\r\nchip->numchips);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->chipsize = %lld\n",\r\nchip->chipsize);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->pagemask = %8x\n",\r\nchip->pagemask);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->chip_delay = %d\n",\r\nchip->chip_delay);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->badblockpos = %d\n",\r\nchip->badblockpos);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->chip_shift = %d\n",\r\nchip->chip_shift);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->page_shift = %d\n",\r\nchip->page_shift);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->phys_erase_shift = %d\n",\r\nchip->phys_erase_shift);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->ecc.mode = %d\n",\r\nchip->ecc.mode);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->ecc.steps = %d\n",\r\nchip->ecc.steps);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->ecc.bytes = %d\n",\r\nchip->ecc.bytes);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->ecc.total = %d\n",\r\nchip->ecc.total);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->ooblayout = %p\n",\r\nmtd->ooblayout);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->flags = %08x\n", mtd->flags);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->size = %lld\n", mtd->size);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->erasesize = %d\n",\r\nmtd->erasesize);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->writesize = %d\n",\r\nmtd->writesize);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->oobsize = %d\n",\r\nmtd->oobsize);\r\nif (mtd->writesize == 512) {\r\npriv->page_size = 0;\r\nclrbits32(&lbc->bank[priv->bank].or, OR_FCM_PGS);\r\n} else if (mtd->writesize == 2048) {\r\npriv->page_size = 1;\r\nsetbits32(&lbc->bank[priv->bank].or, OR_FCM_PGS);\r\n} else {\r\ndev_err(priv->dev,\r\n"fsl_elbc_init: page size %d is not supported\n",\r\nmtd->writesize);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_elbc_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\r\nfsl_elbc_read_buf(mtd, buf, mtd->writesize);\r\nif (oob_required)\r\nfsl_elbc_read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (fsl_elbc_wait(mtd, chip) & NAND_STATUS_FAIL)\r\nmtd->ecc_stats.failed++;\r\nreturn elbc_fcm_ctrl->max_bitflips;\r\n}\r\nstatic int fsl_elbc_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required, int page)\r\n{\r\nfsl_elbc_write_buf(mtd, buf, mtd->writesize);\r\nfsl_elbc_write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int fsl_elbc_write_subpage(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint32_t offset, uint32_t data_len,\r\nconst uint8_t *buf, int oob_required, int page)\r\n{\r\nfsl_elbc_write_buf(mtd, buf, mtd->writesize);\r\nfsl_elbc_write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int fsl_elbc_chip_init(struct fsl_elbc_mtd *priv)\r\n{\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\r\nstruct nand_chip *chip = &priv->chip;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\ndev_dbg(priv->dev, "eLBC Set Information for bank %d\n", priv->bank);\r\nmtd->dev.parent = priv->dev;\r\nnand_set_flash_node(chip, priv->dev->of_node);\r\npriv->fmr = 15 << FMR_CWTO_SHIFT;\r\nif (in_be32(&lbc->bank[priv->bank].or) & OR_FCM_PGS)\r\npriv->fmr |= FMR_ECCM;\r\nchip->read_byte = fsl_elbc_read_byte;\r\nchip->write_buf = fsl_elbc_write_buf;\r\nchip->read_buf = fsl_elbc_read_buf;\r\nchip->select_chip = fsl_elbc_select_chip;\r\nchip->cmdfunc = fsl_elbc_cmdfunc;\r\nchip->waitfunc = fsl_elbc_wait;\r\nchip->bbt_td = &bbt_main_descr;\r\nchip->bbt_md = &bbt_mirror_descr;\r\nchip->bbt_options = NAND_BBT_USE_FLASH;\r\nchip->controller = &elbc_fcm_ctrl->controller;\r\nnand_set_controller_data(chip, priv);\r\nchip->ecc.read_page = fsl_elbc_read_page;\r\nchip->ecc.write_page = fsl_elbc_write_page;\r\nchip->ecc.write_subpage = fsl_elbc_write_subpage;\r\nif ((in_be32(&lbc->bank[priv->bank].br) & BR_DECC) ==\r\nBR_DECC_CHK_GEN) {\r\nchip->ecc.mode = NAND_ECC_HW;\r\nmtd_set_ooblayout(mtd, &fsl_elbc_ooblayout_ops);\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 3;\r\nchip->ecc.strength = 1;\r\n} else {\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\nchip->ecc.algo = NAND_ECC_HAMMING;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_elbc_chip_remove(struct fsl_elbc_mtd *priv)\r\n{\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nstruct mtd_info *mtd = nand_to_mtd(&priv->chip);\r\nnand_release(mtd);\r\nkfree(mtd->name);\r\nif (priv->vbase)\r\niounmap(priv->vbase);\r\nelbc_fcm_ctrl->chips[priv->bank] = NULL;\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int fsl_elbc_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct fsl_lbc_regs __iomem *lbc;\r\nstruct fsl_elbc_mtd *priv;\r\nstruct resource res;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl;\r\nstatic const char *part_probe_types[]\r\n= { "cmdlinepart", "RedBoot", "ofpart", NULL };\r\nint ret;\r\nint bank;\r\nstruct device *dev;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct mtd_info *mtd;\r\nif (!fsl_lbc_ctrl_dev || !fsl_lbc_ctrl_dev->regs)\r\nreturn -ENODEV;\r\nlbc = fsl_lbc_ctrl_dev->regs;\r\ndev = fsl_lbc_ctrl_dev->dev;\r\nret = of_address_to_resource(node, 0, &res);\r\nif (ret) {\r\ndev_err(dev, "failed to get resource\n");\r\nreturn ret;\r\n}\r\nfor (bank = 0; bank < MAX_BANKS; bank++)\r\nif ((in_be32(&lbc->bank[bank].br) & BR_V) &&\r\n(in_be32(&lbc->bank[bank].br) & BR_MSEL) == BR_MS_FCM &&\r\n(in_be32(&lbc->bank[bank].br) &\r\nin_be32(&lbc->bank[bank].or) & BR_BA)\r\n== fsl_lbc_addr(res.start))\r\nbreak;\r\nif (bank >= MAX_BANKS) {\r\ndev_err(dev, "address did not match any chip selects\n");\r\nreturn -ENODEV;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_lock(&fsl_elbc_nand_mutex);\r\nif (!fsl_lbc_ctrl_dev->nand) {\r\nelbc_fcm_ctrl = kzalloc(sizeof(*elbc_fcm_ctrl), GFP_KERNEL);\r\nif (!elbc_fcm_ctrl) {\r\nmutex_unlock(&fsl_elbc_nand_mutex);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nelbc_fcm_ctrl->counter++;\r\nspin_lock_init(&elbc_fcm_ctrl->controller.lock);\r\ninit_waitqueue_head(&elbc_fcm_ctrl->controller.wq);\r\nfsl_lbc_ctrl_dev->nand = elbc_fcm_ctrl;\r\n} else {\r\nelbc_fcm_ctrl = fsl_lbc_ctrl_dev->nand;\r\n}\r\nmutex_unlock(&fsl_elbc_nand_mutex);\r\nelbc_fcm_ctrl->chips[bank] = priv;\r\npriv->bank = bank;\r\npriv->ctrl = fsl_lbc_ctrl_dev;\r\npriv->dev = &pdev->dev;\r\ndev_set_drvdata(priv->dev, priv);\r\npriv->vbase = ioremap(res.start, resource_size(&res));\r\nif (!priv->vbase) {\r\ndev_err(dev, "failed to map chip region\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nmtd = nand_to_mtd(&priv->chip);\r\nmtd->name = kasprintf(GFP_KERNEL, "%llx.flash", (u64)res.start);\r\nif (!nand_to_mtd(&priv->chip)->name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = fsl_elbc_chip_init(priv);\r\nif (ret)\r\ngoto err;\r\nret = nand_scan_ident(mtd, 1, NULL);\r\nif (ret)\r\ngoto err;\r\nret = fsl_elbc_chip_init_tail(mtd);\r\nif (ret)\r\ngoto err;\r\nret = nand_scan_tail(mtd);\r\nif (ret)\r\ngoto err;\r\nmtd_device_parse_register(mtd, part_probe_types, NULL,\r\nNULL, 0);\r\nprintk(KERN_INFO "eLBC NAND device at 0x%llx, bank %d\n",\r\n(unsigned long long)res.start, priv->bank);\r\nreturn 0;\r\nerr:\r\nfsl_elbc_chip_remove(priv);\r\nreturn ret;\r\n}\r\nstatic int fsl_elbc_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = fsl_lbc_ctrl_dev->nand;\r\nstruct fsl_elbc_mtd *priv = dev_get_drvdata(&pdev->dev);\r\nfsl_elbc_chip_remove(priv);\r\nmutex_lock(&fsl_elbc_nand_mutex);\r\nelbc_fcm_ctrl->counter--;\r\nif (!elbc_fcm_ctrl->counter) {\r\nfsl_lbc_ctrl_dev->nand = NULL;\r\nkfree(elbc_fcm_ctrl);\r\n}\r\nmutex_unlock(&fsl_elbc_nand_mutex);\r\nreturn 0;\r\n}
