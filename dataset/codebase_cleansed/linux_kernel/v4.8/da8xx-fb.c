static unsigned int lcdc_read(unsigned int addr)\r\n{\r\nreturn (unsigned int)__raw_readl(da8xx_fb_reg_base + (addr));\r\n}\r\nstatic void lcdc_write(unsigned int val, unsigned int addr)\r\n{\r\n__raw_writel(val, da8xx_fb_reg_base + (addr));\r\n}\r\nstatic bool da8xx_fb_is_raster_enabled(void)\r\n{\r\nreturn !!(lcdc_read(LCD_RASTER_CTRL_REG) & LCD_RASTER_ENABLE);\r\n}\r\nstatic void lcd_enable_raster(void)\r\n{\r\nu32 reg;\r\nif (lcd_revision == LCD_VERSION_2)\r\nlcdc_write(LCD_CLK_MAIN_RESET, LCD_CLK_RESET_REG);\r\nmdelay(1);\r\nif (lcd_revision == LCD_VERSION_2)\r\nlcdc_write(0, LCD_CLK_RESET_REG);\r\nmdelay(1);\r\nreg = lcdc_read(LCD_RASTER_CTRL_REG);\r\nif (!(reg & LCD_RASTER_ENABLE))\r\nlcdc_write(reg | LCD_RASTER_ENABLE, LCD_RASTER_CTRL_REG);\r\n}\r\nstatic void lcd_disable_raster(enum da8xx_frame_complete wait_for_frame_done)\r\n{\r\nu32 reg;\r\nint ret;\r\nreg = lcdc_read(LCD_RASTER_CTRL_REG);\r\nif (reg & LCD_RASTER_ENABLE)\r\nlcdc_write(reg & ~LCD_RASTER_ENABLE, LCD_RASTER_CTRL_REG);\r\nelse\r\nreturn;\r\nif ((wait_for_frame_done == DA8XX_FRAME_WAIT) &&\r\n(lcd_revision == LCD_VERSION_2)) {\r\nframe_done_flag = 0;\r\nret = wait_event_interruptible_timeout(frame_done_wq,\r\nframe_done_flag != 0,\r\nmsecs_to_jiffies(50));\r\nif (ret == 0)\r\npr_err("LCD Controller timed out\n");\r\n}\r\n}\r\nstatic void lcd_blit(int load_mode, struct da8xx_fb_par *par)\r\n{\r\nu32 start;\r\nu32 end;\r\nu32 reg_ras;\r\nu32 reg_dma;\r\nu32 reg_int;\r\nreg_ras = lcdc_read(LCD_RASTER_CTRL_REG);\r\nreg_ras &= ~(3 << 20);\r\nreg_dma = lcdc_read(LCD_DMA_CTRL_REG);\r\nif (load_mode == LOAD_DATA) {\r\nstart = par->dma_start;\r\nend = par->dma_end;\r\nreg_ras |= LCD_PALETTE_LOAD_MODE(DATA_ONLY);\r\nif (lcd_revision == LCD_VERSION_1) {\r\nreg_dma |= LCD_V1_END_OF_FRAME_INT_ENA;\r\n} else {\r\nreg_int = lcdc_read(LCD_INT_ENABLE_SET_REG) |\r\nLCD_V2_END_OF_FRAME0_INT_ENA |\r\nLCD_V2_END_OF_FRAME1_INT_ENA |\r\nLCD_FRAME_DONE | LCD_SYNC_LOST;\r\nlcdc_write(reg_int, LCD_INT_ENABLE_SET_REG);\r\n}\r\nreg_dma |= LCD_DUAL_FRAME_BUFFER_ENABLE;\r\nlcdc_write(start, LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nlcdc_write(end, LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\nlcdc_write(start, LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\r\nlcdc_write(end, LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\r\n} else if (load_mode == LOAD_PALETTE) {\r\nstart = par->p_palette_base;\r\nend = start + par->palette_sz - 1;\r\nreg_ras |= LCD_PALETTE_LOAD_MODE(PALETTE_ONLY);\r\nif (lcd_revision == LCD_VERSION_1) {\r\nreg_ras |= LCD_V1_PL_INT_ENA;\r\n} else {\r\nreg_int = lcdc_read(LCD_INT_ENABLE_SET_REG) |\r\nLCD_V2_PL_INT_ENA;\r\nlcdc_write(reg_int, LCD_INT_ENABLE_SET_REG);\r\n}\r\nlcdc_write(start, LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nlcdc_write(end, LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\n}\r\nlcdc_write(reg_dma, LCD_DMA_CTRL_REG);\r\nlcdc_write(reg_ras, LCD_RASTER_CTRL_REG);\r\nlcd_enable_raster();\r\n}\r\nstatic int lcd_cfg_dma(int burst_size, int fifo_th)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_DMA_CTRL_REG) & 0x00000001;\r\nswitch (burst_size) {\r\ncase 1:\r\nreg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_1);\r\nbreak;\r\ncase 2:\r\nreg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_2);\r\nbreak;\r\ncase 4:\r\nreg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_4);\r\nbreak;\r\ncase 8:\r\nreg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_8);\r\nbreak;\r\ncase 16:\r\ndefault:\r\nreg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_16);\r\nbreak;\r\n}\r\nreg |= (fifo_th << 8);\r\nlcdc_write(reg, LCD_DMA_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic void lcd_cfg_ac_bias(int period, int transitions_per_int)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_RASTER_TIMING_2_REG) & 0xFFF00000;\r\nreg |= LCD_AC_BIAS_FREQUENCY(period) |\r\nLCD_AC_BIAS_TRANSITIONS_PER_INT(transitions_per_int);\r\nlcdc_write(reg, LCD_RASTER_TIMING_2_REG);\r\n}\r\nstatic void lcd_cfg_horizontal_sync(int back_porch, int pulse_width,\r\nint front_porch)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_RASTER_TIMING_0_REG) & 0x3ff;\r\nreg |= (((back_porch-1) & 0xff) << 24)\r\n| (((front_porch-1) & 0xff) << 16)\r\n| (((pulse_width-1) & 0x3f) << 10);\r\nlcdc_write(reg, LCD_RASTER_TIMING_0_REG);\r\nif (lcd_revision == LCD_VERSION_2) {\r\nreg = lcdc_read(LCD_RASTER_TIMING_2_REG) & ~0x780000ff;\r\nreg |= ((front_porch-1) & 0x300) >> 8;\r\nreg |= ((back_porch-1) & 0x300) >> 4;\r\nreg |= ((pulse_width-1) & 0x3c0) << 21;\r\nlcdc_write(reg, LCD_RASTER_TIMING_2_REG);\r\n}\r\n}\r\nstatic void lcd_cfg_vertical_sync(int back_porch, int pulse_width,\r\nint front_porch)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_RASTER_TIMING_1_REG) & 0x3ff;\r\nreg |= ((back_porch & 0xff) << 24)\r\n| ((front_porch & 0xff) << 16)\r\n| (((pulse_width-1) & 0x3f) << 10);\r\nlcdc_write(reg, LCD_RASTER_TIMING_1_REG);\r\n}\r\nstatic int lcd_cfg_display(const struct lcd_ctrl_config *cfg,\r\nstruct fb_videomode *panel)\r\n{\r\nu32 reg;\r\nu32 reg_int;\r\nreg = lcdc_read(LCD_RASTER_CTRL_REG) & ~(LCD_TFT_MODE |\r\nLCD_MONO_8BIT_MODE |\r\nLCD_MONOCHROME_MODE);\r\nswitch (cfg->panel_shade) {\r\ncase MONOCHROME:\r\nreg |= LCD_MONOCHROME_MODE;\r\nif (cfg->mono_8bit_mode)\r\nreg |= LCD_MONO_8BIT_MODE;\r\nbreak;\r\ncase COLOR_ACTIVE:\r\nreg |= LCD_TFT_MODE;\r\nif (cfg->tft_alt_mode)\r\nreg |= LCD_TFT_ALT_ENABLE;\r\nbreak;\r\ncase COLOR_PASSIVE:\r\nlcd_cfg_ac_bias(cfg->ac_bias, cfg->ac_bias_intrpt);\r\nif (cfg->bpp == 12 && cfg->stn_565_mode)\r\nreg |= LCD_STN_565_ENABLE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (lcd_revision == LCD_VERSION_1) {\r\nreg |= LCD_V1_UNDERFLOW_INT_ENA;\r\n} else {\r\nreg_int = lcdc_read(LCD_INT_ENABLE_SET_REG) |\r\nLCD_V2_UNDERFLOW_INT_ENA;\r\nlcdc_write(reg_int, LCD_INT_ENABLE_SET_REG);\r\n}\r\nlcdc_write(reg, LCD_RASTER_CTRL_REG);\r\nreg = lcdc_read(LCD_RASTER_TIMING_2_REG);\r\nreg |= LCD_SYNC_CTRL;\r\nif (cfg->sync_edge)\r\nreg |= LCD_SYNC_EDGE;\r\nelse\r\nreg &= ~LCD_SYNC_EDGE;\r\nif ((panel->sync & FB_SYNC_HOR_HIGH_ACT) == 0)\r\nreg |= LCD_INVERT_LINE_CLOCK;\r\nelse\r\nreg &= ~LCD_INVERT_LINE_CLOCK;\r\nif ((panel->sync & FB_SYNC_VERT_HIGH_ACT) == 0)\r\nreg |= LCD_INVERT_FRAME_CLOCK;\r\nelse\r\nreg &= ~LCD_INVERT_FRAME_CLOCK;\r\nlcdc_write(reg, LCD_RASTER_TIMING_2_REG);\r\nreturn 0;\r\n}\r\nstatic int lcd_cfg_frame_buffer(struct da8xx_fb_par *par, u32 width, u32 height,\r\nu32 bpp, u32 raster_order)\r\n{\r\nu32 reg;\r\nif (bpp > 16 && lcd_revision == LCD_VERSION_1)\r\nreturn -EINVAL;\r\nif (lcd_revision == LCD_VERSION_1) {\r\nwidth &= 0x3f0;\r\n} else {\r\nwidth &= 0x7f0;\r\n}\r\nreg = lcdc_read(LCD_RASTER_TIMING_0_REG);\r\nreg &= 0xfffffc00;\r\nif (lcd_revision == LCD_VERSION_1) {\r\nreg |= ((width >> 4) - 1) << 4;\r\n} else {\r\nwidth = (width >> 4) - 1;\r\nreg |= ((width & 0x3f) << 4) | ((width & 0x40) >> 3);\r\n}\r\nlcdc_write(reg, LCD_RASTER_TIMING_0_REG);\r\nreg = lcdc_read(LCD_RASTER_TIMING_1_REG);\r\nreg = ((height - 1) & 0x3ff) | (reg & 0xfffffc00);\r\nlcdc_write(reg, LCD_RASTER_TIMING_1_REG);\r\nif (lcd_revision == LCD_VERSION_2) {\r\nreg = lcdc_read(LCD_RASTER_TIMING_2_REG);\r\nreg |= ((height - 1) & 0x400) << 16;\r\nlcdc_write(reg, LCD_RASTER_TIMING_2_REG);\r\n}\r\nreg = lcdc_read(LCD_RASTER_CTRL_REG) & ~(1 << 8);\r\nif (raster_order)\r\nreg |= LCD_RASTER_ORDER;\r\npar->palette_sz = 16 * 2;\r\nswitch (bpp) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 16:\r\nbreak;\r\ncase 24:\r\nreg |= LCD_V2_TFT_24BPP_MODE;\r\nbreak;\r\ncase 32:\r\nreg |= LCD_V2_TFT_24BPP_MODE;\r\nreg |= LCD_V2_TFT_24BPP_UNPACK;\r\nbreak;\r\ncase 8:\r\npar->palette_sz = 256 * 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nlcdc_write(reg, LCD_RASTER_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic int fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct da8xx_fb_par *par = info->par;\r\nunsigned short *palette = (unsigned short *) par->v_palette_base;\r\nu_short pal;\r\nint update_hw = 0;\r\nif (regno > 255)\r\nreturn 1;\r\nif (info->fix.visual == FB_VISUAL_DIRECTCOLOR)\r\nreturn 1;\r\nif (info->var.bits_per_pixel > 16 && lcd_revision == LCD_VERSION_1)\r\nreturn -EINVAL;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nred = CNVT_TOHW(red, info->var.red.length);\r\ngreen = CNVT_TOHW(green, info->var.green.length);\r\nblue = CNVT_TOHW(blue, info->var.blue.length);\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nswitch (info->var.bits_per_pixel) {\r\ncase 4:\r\nif (regno > 15)\r\nreturn -EINVAL;\r\nif (info->var.grayscale) {\r\npal = regno;\r\n} else {\r\nred >>= 4;\r\ngreen >>= 8;\r\nblue >>= 12;\r\npal = red & 0x0f00;\r\npal |= green & 0x00f0;\r\npal |= blue & 0x000f;\r\n}\r\nif (regno == 0)\r\npal |= 0x2000;\r\npalette[regno] = pal;\r\nbreak;\r\ncase 8:\r\nred >>= 4;\r\ngreen >>= 8;\r\nblue >>= 12;\r\npal = (red & 0x0f00);\r\npal |= (green & 0x00f0);\r\npal |= (blue & 0x000f);\r\nif (palette[regno] != pal) {\r\nupdate_hw = 1;\r\npalette[regno] = pal;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 v;\r\nif (regno > 15)\r\nreturn -EINVAL;\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\n((u32 *) (info->pseudo_palette))[regno] = v;\r\nif (palette[0] != 0x4000) {\r\nupdate_hw = 1;\r\npalette[0] = 0x4000;\r\n}\r\n}\r\nif (update_hw)\r\nlcd_blit(LOAD_PALETTE, par);\r\nreturn 0;\r\n}\r\nstatic void da8xx_fb_lcd_reset(void)\r\n{\r\nlcdc_write(0, LCD_DMA_CTRL_REG);\r\nlcdc_write(0, LCD_RASTER_CTRL_REG);\r\nif (lcd_revision == LCD_VERSION_2) {\r\nlcdc_write(0, LCD_INT_ENABLE_SET_REG);\r\nlcdc_write(LCD_CLK_MAIN_RESET, LCD_CLK_RESET_REG);\r\nlcdc_write(0, LCD_CLK_RESET_REG);\r\n}\r\n}\r\nstatic int da8xx_fb_config_clk_divider(struct da8xx_fb_par *par,\r\nunsigned lcdc_clk_div,\r\nunsigned lcdc_clk_rate)\r\n{\r\nint ret;\r\nif (par->lcdc_clk_rate != lcdc_clk_rate) {\r\nret = clk_set_rate(par->lcdc_clk, lcdc_clk_rate);\r\nif (ret) {\r\ndev_err(par->dev,\r\n"unable to set clock rate at %u\n",\r\nlcdc_clk_rate);\r\nreturn ret;\r\n}\r\npar->lcdc_clk_rate = clk_get_rate(par->lcdc_clk);\r\n}\r\nlcdc_write(LCD_CLK_DIVISOR(lcdc_clk_div) |\r\n(LCD_RASTER_MODE & 0x1), LCD_CTRL_REG);\r\nif (lcd_revision == LCD_VERSION_2)\r\nlcdc_write(LCD_V2_DMA_CLK_EN | LCD_V2_LIDD_CLK_EN |\r\nLCD_V2_CORE_CLK_EN, LCD_CLK_ENABLE_REG);\r\nreturn 0;\r\n}\r\nstatic unsigned int da8xx_fb_calc_clk_divider(struct da8xx_fb_par *par,\r\nunsigned pixclock,\r\nunsigned *lcdc_clk_rate)\r\n{\r\nunsigned lcdc_clk_div;\r\npixclock = PICOS2KHZ(pixclock) * 1000;\r\n*lcdc_clk_rate = par->lcdc_clk_rate;\r\nif (pixclock < (*lcdc_clk_rate / CLK_MAX_DIV)) {\r\n*lcdc_clk_rate = clk_round_rate(par->lcdc_clk,\r\npixclock * CLK_MAX_DIV);\r\nlcdc_clk_div = CLK_MAX_DIV;\r\n} else if (pixclock > (*lcdc_clk_rate / CLK_MIN_DIV)) {\r\n*lcdc_clk_rate = clk_round_rate(par->lcdc_clk,\r\npixclock * CLK_MIN_DIV);\r\nlcdc_clk_div = CLK_MIN_DIV;\r\n} else {\r\nlcdc_clk_div = *lcdc_clk_rate / pixclock;\r\n}\r\nreturn lcdc_clk_div;\r\n}\r\nstatic int da8xx_fb_calc_config_clk_divider(struct da8xx_fb_par *par,\r\nstruct fb_videomode *mode)\r\n{\r\nunsigned lcdc_clk_rate;\r\nunsigned lcdc_clk_div = da8xx_fb_calc_clk_divider(par, mode->pixclock,\r\n&lcdc_clk_rate);\r\nreturn da8xx_fb_config_clk_divider(par, lcdc_clk_div, lcdc_clk_rate);\r\n}\r\nstatic unsigned da8xx_fb_round_clk(struct da8xx_fb_par *par,\r\nunsigned pixclock)\r\n{\r\nunsigned lcdc_clk_div, lcdc_clk_rate;\r\nlcdc_clk_div = da8xx_fb_calc_clk_divider(par, pixclock, &lcdc_clk_rate);\r\nreturn KHZ2PICOS(lcdc_clk_rate / (1000 * lcdc_clk_div));\r\n}\r\nstatic int lcd_init(struct da8xx_fb_par *par, const struct lcd_ctrl_config *cfg,\r\nstruct fb_videomode *panel)\r\n{\r\nu32 bpp;\r\nint ret = 0;\r\nret = da8xx_fb_calc_config_clk_divider(par, panel);\r\nif (ret) {\r\ndev_err(par->dev, "unable to configure clock\n");\r\nreturn ret;\r\n}\r\nif (panel->sync & FB_SYNC_CLK_INVERT)\r\nlcdc_write((lcdc_read(LCD_RASTER_TIMING_2_REG) |\r\nLCD_INVERT_PIXEL_CLOCK), LCD_RASTER_TIMING_2_REG);\r\nelse\r\nlcdc_write((lcdc_read(LCD_RASTER_TIMING_2_REG) &\r\n~LCD_INVERT_PIXEL_CLOCK), LCD_RASTER_TIMING_2_REG);\r\nret = lcd_cfg_dma(cfg->dma_burst_sz, cfg->fifo_th);\r\nif (ret < 0)\r\nreturn ret;\r\nlcd_cfg_vertical_sync(panel->upper_margin, panel->vsync_len,\r\npanel->lower_margin);\r\nlcd_cfg_horizontal_sync(panel->left_margin, panel->hsync_len,\r\npanel->right_margin);\r\nret = lcd_cfg_display(cfg, panel);\r\nif (ret < 0)\r\nreturn ret;\r\nbpp = cfg->bpp;\r\nif (bpp == 12)\r\nbpp = 16;\r\nret = lcd_cfg_frame_buffer(par, (unsigned int)panel->xres,\r\n(unsigned int)panel->yres, bpp,\r\ncfg->raster_order);\r\nif (ret < 0)\r\nreturn ret;\r\nlcdc_write((lcdc_read(LCD_RASTER_CTRL_REG) & 0xfff00fff) |\r\n(cfg->fdd << 12), LCD_RASTER_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t lcdc_irq_handler_rev02(int irq, void *arg)\r\n{\r\nstruct da8xx_fb_par *par = arg;\r\nu32 stat = lcdc_read(LCD_MASKED_STAT_REG);\r\nif ((stat & LCD_SYNC_LOST) && (stat & LCD_FIFO_UNDERFLOW)) {\r\nlcd_disable_raster(DA8XX_FRAME_NOWAIT);\r\nlcdc_write(stat, LCD_MASKED_STAT_REG);\r\nlcd_enable_raster();\r\n} else if (stat & LCD_PL_LOAD_DONE) {\r\nlcd_disable_raster(DA8XX_FRAME_NOWAIT);\r\nlcdc_write(stat, LCD_MASKED_STAT_REG);\r\nlcdc_write(LCD_V2_PL_INT_ENA, LCD_INT_ENABLE_CLR_REG);\r\nlcd_blit(LOAD_DATA, par);\r\n} else {\r\nlcdc_write(stat, LCD_MASKED_STAT_REG);\r\nif (stat & LCD_END_OF_FRAME0) {\r\npar->which_dma_channel_done = 0;\r\nlcdc_write(par->dma_start,\r\nLCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nlcdc_write(par->dma_end,\r\nLCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\npar->vsync_flag = 1;\r\nwake_up_interruptible(&par->vsync_wait);\r\n}\r\nif (stat & LCD_END_OF_FRAME1) {\r\npar->which_dma_channel_done = 1;\r\nlcdc_write(par->dma_start,\r\nLCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\r\nlcdc_write(par->dma_end,\r\nLCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\r\npar->vsync_flag = 1;\r\nwake_up_interruptible(&par->vsync_wait);\r\n}\r\nif (stat & BIT(0)) {\r\nframe_done_flag = 1;\r\nwake_up_interruptible(&frame_done_wq);\r\n}\r\n}\r\nlcdc_write(0, LCD_END_OF_INT_IND_REG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lcdc_irq_handler_rev01(int irq, void *arg)\r\n{\r\nstruct da8xx_fb_par *par = arg;\r\nu32 stat = lcdc_read(LCD_STAT_REG);\r\nu32 reg_ras;\r\nif ((stat & LCD_SYNC_LOST) && (stat & LCD_FIFO_UNDERFLOW)) {\r\nlcd_disable_raster(DA8XX_FRAME_NOWAIT);\r\nlcdc_write(stat, LCD_STAT_REG);\r\nlcd_enable_raster();\r\n} else if (stat & LCD_PL_LOAD_DONE) {\r\nlcd_disable_raster(DA8XX_FRAME_NOWAIT);\r\nlcdc_write(stat, LCD_STAT_REG);\r\nreg_ras = lcdc_read(LCD_RASTER_CTRL_REG);\r\nreg_ras &= ~LCD_V1_PL_INT_ENA;\r\nlcdc_write(reg_ras, LCD_RASTER_CTRL_REG);\r\nlcd_blit(LOAD_DATA, par);\r\n} else {\r\nlcdc_write(stat, LCD_STAT_REG);\r\nif (stat & LCD_END_OF_FRAME0) {\r\npar->which_dma_channel_done = 0;\r\nlcdc_write(par->dma_start,\r\nLCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nlcdc_write(par->dma_end,\r\nLCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\npar->vsync_flag = 1;\r\nwake_up_interruptible(&par->vsync_wait);\r\n}\r\nif (stat & LCD_END_OF_FRAME1) {\r\npar->which_dma_channel_done = 1;\r\nlcdc_write(par->dma_start,\r\nLCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\r\nlcdc_write(par->dma_end,\r\nLCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\r\npar->vsync_flag = 1;\r\nwake_up_interruptible(&par->vsync_wait);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint err = 0;\r\nstruct da8xx_fb_par *par = info->par;\r\nint bpp = var->bits_per_pixel >> 3;\r\nunsigned long line_size = var->xres_virtual * bpp;\r\nif (var->bits_per_pixel > 16 && lcd_revision == LCD_VERSION_1)\r\nreturn -EINVAL;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->nonstd = 0;\r\nbreak;\r\ncase 4:\r\nvar->red.offset = 0;\r\nvar->red.length = 4;\r\nvar->green.offset = 0;\r\nvar->green.length = 4;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 4;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->nonstd = FB_NONSTD_REV_PIX_IN_B;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->nonstd = 0;\r\nbreak;\r\ncase 24:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->nonstd = 0;\r\nbreak;\r\ncase 32:\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->nonstd = 0;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nif (line_size * var->yres_virtual > par->vram_size)\r\nvar->yres_virtual = par->vram_size / line_size;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres = var->yres_virtual;\r\nif (var->xres > var->xres_virtual)\r\nvar->xres = var->xres_virtual;\r\nif (var->xres + var->xoffset > var->xres_virtual)\r\nvar->xoffset = var->xres_virtual - var->xres;\r\nif (var->yres + var->yoffset > var->yres_virtual)\r\nvar->yoffset = var->yres_virtual - var->yres;\r\nvar->pixclock = da8xx_fb_round_clk(par, var->pixclock);\r\nreturn err;\r\n}\r\nstatic int lcd_da8xx_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct da8xx_fb_par *par;\r\npar = container_of(nb, struct da8xx_fb_par, freq_transition);\r\nif (val == CPUFREQ_POSTCHANGE) {\r\nif (par->lcdc_clk_rate != clk_get_rate(par->lcdc_clk)) {\r\npar->lcdc_clk_rate = clk_get_rate(par->lcdc_clk);\r\nlcd_disable_raster(DA8XX_FRAME_WAIT);\r\nda8xx_fb_calc_config_clk_divider(par, &par->mode);\r\nif (par->blank == FB_BLANK_UNBLANK)\r\nlcd_enable_raster();\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lcd_da8xx_cpufreq_register(struct da8xx_fb_par *par)\r\n{\r\npar->freq_transition.notifier_call = lcd_da8xx_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&par->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic void lcd_da8xx_cpufreq_deregister(struct da8xx_fb_par *par)\r\n{\r\ncpufreq_unregister_notifier(&par->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic int fb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(&dev->dev);\r\nif (info) {\r\nstruct da8xx_fb_par *par = info->par;\r\n#ifdef CONFIG_CPU_FREQ\r\nlcd_da8xx_cpufreq_deregister(par);\r\n#endif\r\nif (par->panel_power_ctrl)\r\npar->panel_power_ctrl(0);\r\nlcd_disable_raster(DA8XX_FRAME_WAIT);\r\nlcdc_write(0, LCD_RASTER_CTRL_REG);\r\nlcdc_write(0, LCD_DMA_CTRL_REG);\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\ndma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base,\r\npar->p_palette_base);\r\ndma_free_coherent(NULL, par->vram_size, par->vram_virt,\r\npar->vram_phys);\r\npm_runtime_put_sync(&dev->dev);\r\npm_runtime_disable(&dev->dev);\r\nframebuffer_release(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fb_wait_for_vsync(struct fb_info *info)\r\n{\r\nstruct da8xx_fb_par *par = info->par;\r\nint ret;\r\npar->vsync_flag = 0;\r\nret = wait_event_interruptible_timeout(par->vsync_wait,\r\npar->vsync_flag != 0,\r\npar->vsync_timeout);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int fb_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct lcd_sync_arg sync_arg;\r\nswitch (cmd) {\r\ncase FBIOGET_CONTRAST:\r\ncase FBIOPUT_CONTRAST:\r\ncase FBIGET_BRIGHTNESS:\r\ncase FBIPUT_BRIGHTNESS:\r\ncase FBIGET_COLOR:\r\ncase FBIPUT_COLOR:\r\nreturn -ENOTTY;\r\ncase FBIPUT_HSYNC:\r\nif (copy_from_user(&sync_arg, (char *)arg,\r\nsizeof(struct lcd_sync_arg)))\r\nreturn -EFAULT;\r\nlcd_cfg_horizontal_sync(sync_arg.back_porch,\r\nsync_arg.pulse_width,\r\nsync_arg.front_porch);\r\nbreak;\r\ncase FBIPUT_VSYNC:\r\nif (copy_from_user(&sync_arg, (char *)arg,\r\nsizeof(struct lcd_sync_arg)))\r\nreturn -EFAULT;\r\nlcd_cfg_vertical_sync(sync_arg.back_porch,\r\nsync_arg.pulse_width,\r\nsync_arg.front_porch);\r\nbreak;\r\ncase FBIO_WAITFORVSYNC:\r\nreturn fb_wait_for_vsync(info);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct da8xx_fb_par *par = info->par;\r\nint ret = 0;\r\nif (par->blank == blank)\r\nreturn 0;\r\npar->blank = blank;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nlcd_enable_raster();\r\nif (par->panel_power_ctrl)\r\npar->panel_power_ctrl(1);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nif (par->panel_power_ctrl)\r\npar->panel_power_ctrl(0);\r\nlcd_disable_raster(DA8XX_FRAME_WAIT);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int da8xx_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *fbi)\r\n{\r\nint ret = 0;\r\nstruct fb_var_screeninfo new_var;\r\nstruct da8xx_fb_par *par = fbi->par;\r\nstruct fb_fix_screeninfo *fix = &fbi->fix;\r\nunsigned int end;\r\nunsigned int start;\r\nunsigned long irq_flags;\r\nif (var->xoffset != fbi->var.xoffset ||\r\nvar->yoffset != fbi->var.yoffset) {\r\nmemcpy(&new_var, &fbi->var, sizeof(new_var));\r\nnew_var.xoffset = var->xoffset;\r\nnew_var.yoffset = var->yoffset;\r\nif (fb_check_var(&new_var, fbi))\r\nret = -EINVAL;\r\nelse {\r\nmemcpy(&fbi->var, &new_var, sizeof(new_var));\r\nstart = fix->smem_start +\r\nnew_var.yoffset * fix->line_length +\r\nnew_var.xoffset * fbi->var.bits_per_pixel / 8;\r\nend = start + fbi->var.yres * fix->line_length - 1;\r\npar->dma_start = start;\r\npar->dma_end = end;\r\nspin_lock_irqsave(&par->lock_for_chan_update,\r\nirq_flags);\r\nif (par->which_dma_channel_done == 0) {\r\nlcdc_write(par->dma_start,\r\nLCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nlcdc_write(par->dma_end,\r\nLCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\n} else if (par->which_dma_channel_done == 1) {\r\nlcdc_write(par->dma_start,\r\nLCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\r\nlcdc_write(par->dma_end,\r\nLCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\r\n}\r\nspin_unlock_irqrestore(&par->lock_for_chan_update,\r\nirq_flags);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int da8xxfb_set_par(struct fb_info *info)\r\n{\r\nstruct da8xx_fb_par *par = info->par;\r\nint ret;\r\nbool raster = da8xx_fb_is_raster_enabled();\r\nif (raster)\r\nlcd_disable_raster(DA8XX_FRAME_WAIT);\r\nfb_var_to_videomode(&par->mode, &info->var);\r\npar->cfg.bpp = info->var.bits_per_pixel;\r\ninfo->fix.visual = (par->cfg.bpp <= 8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = (par->mode.xres * par->cfg.bpp) / 8;\r\nret = lcd_init(par, &par->cfg, &par->mode);\r\nif (ret < 0) {\r\ndev_err(par->dev, "lcd init failed\n");\r\nreturn ret;\r\n}\r\npar->dma_start = info->fix.smem_start +\r\ninfo->var.yoffset * info->fix.line_length +\r\ninfo->var.xoffset * info->var.bits_per_pixel / 8;\r\npar->dma_end = par->dma_start +\r\ninfo->var.yres * info->fix.line_length - 1;\r\nlcdc_write(par->dma_start, LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nlcdc_write(par->dma_end, LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\nlcdc_write(par->dma_start, LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\r\nlcdc_write(par->dma_end, LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\r\nif (raster)\r\nlcd_enable_raster();\r\nreturn 0;\r\n}\r\nstatic struct fb_videomode *da8xx_fb_get_videomode(struct platform_device *dev)\r\n{\r\nstruct da8xx_lcdc_platform_data *fb_pdata = dev_get_platdata(&dev->dev);\r\nstruct fb_videomode *lcdc_info;\r\nint i;\r\nfor (i = 0, lcdc_info = known_lcd_panels;\r\ni < ARRAY_SIZE(known_lcd_panels); i++, lcdc_info++) {\r\nif (strcmp(fb_pdata->type, lcdc_info->name) == 0)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(known_lcd_panels)) {\r\ndev_err(&dev->dev, "no panel found\n");\r\nreturn NULL;\r\n}\r\ndev_info(&dev->dev, "found %s panel\n", lcdc_info->name);\r\nreturn lcdc_info;\r\n}\r\nstatic int fb_probe(struct platform_device *device)\r\n{\r\nstruct da8xx_lcdc_platform_data *fb_pdata =\r\ndev_get_platdata(&device->dev);\r\nstatic struct resource *lcdc_regs;\r\nstruct lcd_ctrl_config *lcd_cfg;\r\nstruct fb_videomode *lcdc_info;\r\nstruct fb_info *da8xx_fb_info;\r\nstruct da8xx_fb_par *par;\r\nstruct clk *tmp_lcdc_clk;\r\nint ret;\r\nunsigned long ulcm;\r\nif (fb_pdata == NULL) {\r\ndev_err(&device->dev, "Can not get platform data\n");\r\nreturn -ENOENT;\r\n}\r\nlcdc_info = da8xx_fb_get_videomode(device);\r\nif (lcdc_info == NULL)\r\nreturn -ENODEV;\r\nlcdc_regs = platform_get_resource(device, IORESOURCE_MEM, 0);\r\nda8xx_fb_reg_base = devm_ioremap_resource(&device->dev, lcdc_regs);\r\nif (IS_ERR(da8xx_fb_reg_base))\r\nreturn PTR_ERR(da8xx_fb_reg_base);\r\ntmp_lcdc_clk = devm_clk_get(&device->dev, "fck");\r\nif (IS_ERR(tmp_lcdc_clk)) {\r\ndev_err(&device->dev, "Can not get device clock\n");\r\nreturn PTR_ERR(tmp_lcdc_clk);\r\n}\r\npm_runtime_enable(&device->dev);\r\npm_runtime_get_sync(&device->dev);\r\nswitch (lcdc_read(LCD_PID_REG)) {\r\ncase 0x4C100102:\r\nlcd_revision = LCD_VERSION_1;\r\nbreak;\r\ncase 0x4F200800:\r\ncase 0x4F201000:\r\nlcd_revision = LCD_VERSION_2;\r\nbreak;\r\ndefault:\r\ndev_warn(&device->dev, "Unknown PID Reg value 0x%x, "\r\n"defaulting to LCD revision 1\n",\r\nlcdc_read(LCD_PID_REG));\r\nlcd_revision = LCD_VERSION_1;\r\nbreak;\r\n}\r\nlcd_cfg = (struct lcd_ctrl_config *)fb_pdata->controller_data;\r\nif (!lcd_cfg) {\r\nret = -EINVAL;\r\ngoto err_pm_runtime_disable;\r\n}\r\nda8xx_fb_info = framebuffer_alloc(sizeof(struct da8xx_fb_par),\r\n&device->dev);\r\nif (!da8xx_fb_info) {\r\ndev_dbg(&device->dev, "Memory allocation failed for fb_info\n");\r\nret = -ENOMEM;\r\ngoto err_pm_runtime_disable;\r\n}\r\npar = da8xx_fb_info->par;\r\npar->dev = &device->dev;\r\npar->lcdc_clk = tmp_lcdc_clk;\r\npar->lcdc_clk_rate = clk_get_rate(par->lcdc_clk);\r\nif (fb_pdata->panel_power_ctrl) {\r\npar->panel_power_ctrl = fb_pdata->panel_power_ctrl;\r\npar->panel_power_ctrl(1);\r\n}\r\nfb_videomode_to_var(&da8xx_fb_var, lcdc_info);\r\npar->cfg = *lcd_cfg;\r\nda8xx_fb_lcd_reset();\r\npar->vram_size = lcdc_info->xres * lcdc_info->yres * lcd_cfg->bpp;\r\nulcm = lcm((lcdc_info->xres * lcd_cfg->bpp)/8, PAGE_SIZE);\r\npar->vram_size = roundup(par->vram_size/8, ulcm);\r\npar->vram_size = par->vram_size * LCD_NUM_BUFFERS;\r\npar->vram_virt = dma_alloc_coherent(NULL,\r\npar->vram_size,\r\n&par->vram_phys,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!par->vram_virt) {\r\ndev_err(&device->dev,\r\n"GLCD: kmalloc for frame buffer failed\n");\r\nret = -EINVAL;\r\ngoto err_release_fb;\r\n}\r\nda8xx_fb_info->screen_base = (char __iomem *) par->vram_virt;\r\nda8xx_fb_fix.smem_start = par->vram_phys;\r\nda8xx_fb_fix.smem_len = par->vram_size;\r\nda8xx_fb_fix.line_length = (lcdc_info->xres * lcd_cfg->bpp) / 8;\r\npar->dma_start = par->vram_phys;\r\npar->dma_end = par->dma_start + lcdc_info->yres *\r\nda8xx_fb_fix.line_length - 1;\r\npar->v_palette_base = dma_zalloc_coherent(NULL, PALETTE_SIZE,\r\n&par->p_palette_base,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!par->v_palette_base) {\r\ndev_err(&device->dev,\r\n"GLCD: kmalloc for palette buffer failed\n");\r\nret = -EINVAL;\r\ngoto err_release_fb_mem;\r\n}\r\npar->irq = platform_get_irq(device, 0);\r\nif (par->irq < 0) {\r\nret = -ENOENT;\r\ngoto err_release_pl_mem;\r\n}\r\nda8xx_fb_var.grayscale =\r\nlcd_cfg->panel_shade == MONOCHROME ? 1 : 0;\r\nda8xx_fb_var.bits_per_pixel = lcd_cfg->bpp;\r\nda8xx_fb_info->flags = FBINFO_FLAG_DEFAULT;\r\nda8xx_fb_info->fix = da8xx_fb_fix;\r\nda8xx_fb_info->var = da8xx_fb_var;\r\nda8xx_fb_info->fbops = &da8xx_fb_ops;\r\nda8xx_fb_info->pseudo_palette = par->pseudo_palette;\r\nda8xx_fb_info->fix.visual = (da8xx_fb_info->var.bits_per_pixel <= 8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\nret = fb_alloc_cmap(&da8xx_fb_info->cmap, PALETTE_SIZE, 0);\r\nif (ret)\r\ngoto err_release_pl_mem;\r\nda8xx_fb_info->cmap.len = par->palette_sz;\r\nda8xx_fb_var.activate = FB_ACTIVATE_FORCE;\r\nfb_set_var(da8xx_fb_info, &da8xx_fb_var);\r\ndev_set_drvdata(&device->dev, da8xx_fb_info);\r\ninit_waitqueue_head(&par->vsync_wait);\r\npar->vsync_timeout = HZ / 5;\r\npar->which_dma_channel_done = -1;\r\nspin_lock_init(&par->lock_for_chan_update);\r\nif (register_framebuffer(da8xx_fb_info) < 0) {\r\ndev_err(&device->dev,\r\n"GLCD: Frame Buffer Registration Failed!\n");\r\nret = -EINVAL;\r\ngoto err_dealloc_cmap;\r\n}\r\n#ifdef CONFIG_CPU_FREQ\r\nret = lcd_da8xx_cpufreq_register(par);\r\nif (ret) {\r\ndev_err(&device->dev, "failed to register cpufreq\n");\r\ngoto err_cpu_freq;\r\n}\r\n#endif\r\nif (lcd_revision == LCD_VERSION_1)\r\nlcdc_irq_handler = lcdc_irq_handler_rev01;\r\nelse {\r\ninit_waitqueue_head(&frame_done_wq);\r\nlcdc_irq_handler = lcdc_irq_handler_rev02;\r\n}\r\nret = devm_request_irq(&device->dev, par->irq, lcdc_irq_handler, 0,\r\nDRIVER_NAME, par);\r\nif (ret)\r\ngoto irq_freq;\r\nreturn 0;\r\nirq_freq:\r\n#ifdef CONFIG_CPU_FREQ\r\nlcd_da8xx_cpufreq_deregister(par);\r\nerr_cpu_freq:\r\n#endif\r\nunregister_framebuffer(da8xx_fb_info);\r\nerr_dealloc_cmap:\r\nfb_dealloc_cmap(&da8xx_fb_info->cmap);\r\nerr_release_pl_mem:\r\ndma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base,\r\npar->p_palette_base);\r\nerr_release_fb_mem:\r\ndma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);\r\nerr_release_fb:\r\nframebuffer_release(da8xx_fb_info);\r\nerr_pm_runtime_disable:\r\npm_runtime_put_sync(&device->dev);\r\npm_runtime_disable(&device->dev);\r\nreturn ret;\r\n}\r\nstatic void lcd_context_save(void)\r\n{\r\nif (lcd_revision == LCD_VERSION_2) {\r\nreg_context.clk_enable = lcdc_read(LCD_CLK_ENABLE_REG);\r\nreg_context.int_enable_set = lcdc_read(LCD_INT_ENABLE_SET_REG);\r\n}\r\nreg_context.ctrl = lcdc_read(LCD_CTRL_REG);\r\nreg_context.dma_ctrl = lcdc_read(LCD_DMA_CTRL_REG);\r\nreg_context.raster_timing_0 = lcdc_read(LCD_RASTER_TIMING_0_REG);\r\nreg_context.raster_timing_1 = lcdc_read(LCD_RASTER_TIMING_1_REG);\r\nreg_context.raster_timing_2 = lcdc_read(LCD_RASTER_TIMING_2_REG);\r\nreg_context.dma_frm_buf_base_addr_0 =\r\nlcdc_read(LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nreg_context.dma_frm_buf_ceiling_addr_0 =\r\nlcdc_read(LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\nreg_context.dma_frm_buf_base_addr_1 =\r\nlcdc_read(LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\r\nreg_context.dma_frm_buf_ceiling_addr_1 =\r\nlcdc_read(LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\r\nreg_context.raster_ctrl = lcdc_read(LCD_RASTER_CTRL_REG);\r\nreturn;\r\n}\r\nstatic void lcd_context_restore(void)\r\n{\r\nif (lcd_revision == LCD_VERSION_2) {\r\nlcdc_write(reg_context.clk_enable, LCD_CLK_ENABLE_REG);\r\nlcdc_write(reg_context.int_enable_set, LCD_INT_ENABLE_SET_REG);\r\n}\r\nlcdc_write(reg_context.ctrl, LCD_CTRL_REG);\r\nlcdc_write(reg_context.dma_ctrl, LCD_DMA_CTRL_REG);\r\nlcdc_write(reg_context.raster_timing_0, LCD_RASTER_TIMING_0_REG);\r\nlcdc_write(reg_context.raster_timing_1, LCD_RASTER_TIMING_1_REG);\r\nlcdc_write(reg_context.raster_timing_2, LCD_RASTER_TIMING_2_REG);\r\nlcdc_write(reg_context.dma_frm_buf_base_addr_0,\r\nLCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nlcdc_write(reg_context.dma_frm_buf_ceiling_addr_0,\r\nLCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\nlcdc_write(reg_context.dma_frm_buf_base_addr_1,\r\nLCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\r\nlcdc_write(reg_context.dma_frm_buf_ceiling_addr_1,\r\nLCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\r\nlcdc_write(reg_context.raster_ctrl, LCD_RASTER_CTRL_REG);\r\nreturn;\r\n}\r\nstatic int fb_suspend(struct device *dev)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct da8xx_fb_par *par = info->par;\r\nconsole_lock();\r\nif (par->panel_power_ctrl)\r\npar->panel_power_ctrl(0);\r\nfb_set_suspend(info, 1);\r\nlcd_disable_raster(DA8XX_FRAME_WAIT);\r\nlcd_context_save();\r\npm_runtime_put_sync(dev);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int fb_resume(struct device *dev)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct da8xx_fb_par *par = info->par;\r\nconsole_lock();\r\npm_runtime_get_sync(dev);\r\nlcd_context_restore();\r\nif (par->blank == FB_BLANK_UNBLANK) {\r\nlcd_enable_raster();\r\nif (par->panel_power_ctrl)\r\npar->panel_power_ctrl(1);\r\n}\r\nfb_set_suspend(info, 0);\r\nconsole_unlock();\r\nreturn 0;\r\n}
