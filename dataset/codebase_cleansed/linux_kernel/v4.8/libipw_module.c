static int libipw_networks_allocate(struct libipw_device *ieee)\r\n{\r\nint i, j;\r\nfor (i = 0; i < MAX_NETWORK_COUNT; i++) {\r\nieee->networks[i] = kzalloc(sizeof(struct libipw_network),\r\nGFP_KERNEL);\r\nif (!ieee->networks[i]) {\r\nLIBIPW_ERROR("Out of memory allocating beacons\n");\r\nfor (j = 0; j < i; j++)\r\nkfree(ieee->networks[j]);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void libipw_networks_free(struct libipw_device *ieee)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_NETWORK_COUNT; i++)\r\nkfree(ieee->networks[i]);\r\n}\r\nvoid libipw_networks_age(struct libipw_device *ieee,\r\nunsigned long age_secs)\r\n{\r\nstruct libipw_network *network = NULL;\r\nunsigned long flags;\r\nunsigned long age_jiffies = msecs_to_jiffies(age_secs * MSEC_PER_SEC);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nlist_for_each_entry(network, &ieee->network_list, list) {\r\nnetwork->last_scanned -= age_jiffies;\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic void libipw_networks_initialize(struct libipw_device *ieee)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&ieee->network_free_list);\r\nINIT_LIST_HEAD(&ieee->network_list);\r\nfor (i = 0; i < MAX_NETWORK_COUNT; i++)\r\nlist_add_tail(&ieee->networks[i]->list,\r\n&ieee->network_free_list);\r\n}\r\nint libipw_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < 68) || (new_mtu > LIBIPW_DATA_LEN))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstruct net_device *alloc_libipw(int sizeof_priv, int monitor)\r\n{\r\nstruct libipw_device *ieee;\r\nstruct net_device *dev;\r\nint err;\r\nLIBIPW_DEBUG_INFO("Initializing...\n");\r\ndev = alloc_etherdev(sizeof(struct libipw_device) + sizeof_priv);\r\nif (!dev)\r\ngoto failed;\r\nieee = netdev_priv(dev);\r\nieee->dev = dev;\r\nif (!monitor) {\r\nieee->wdev.wiphy = wiphy_new(&libipw_config_ops, 0);\r\nif (!ieee->wdev.wiphy) {\r\nLIBIPW_ERROR("Unable to allocate wiphy.\n");\r\ngoto failed_free_netdev;\r\n}\r\nieee->dev->ieee80211_ptr = &ieee->wdev;\r\nieee->wdev.iftype = NL80211_IFTYPE_STATION;\r\nieee->wdev.wiphy->privid = libipw_wiphy_privid;\r\nieee->wdev.wiphy->max_scan_ssids = 1;\r\nieee->wdev.wiphy->max_scan_ie_len = 0;\r\nieee->wdev.wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION)\r\n| BIT(NL80211_IFTYPE_ADHOC);\r\n}\r\nerr = libipw_networks_allocate(ieee);\r\nif (err) {\r\nLIBIPW_ERROR("Unable to allocate beacon storage: %d\n", err);\r\ngoto failed_free_wiphy;\r\n}\r\nlibipw_networks_initialize(ieee);\r\nieee->fts = DEFAULT_FTS;\r\nieee->rts = DEFAULT_FTS;\r\nieee->scan_age = DEFAULT_MAX_SCAN_AGE;\r\nieee->open_wep = 1;\r\nieee->host_encrypt = 1;\r\nieee->host_decrypt = 1;\r\nieee->host_mc_decrypt = 1;\r\nieee->host_open_frag = 1;\r\nieee->ieee802_1x = 1;\r\nspin_lock_init(&ieee->lock);\r\nlib80211_crypt_info_init(&ieee->crypt_info, dev->name, &ieee->lock);\r\nieee->wpa_enabled = 0;\r\nieee->drop_unencrypted = 0;\r\nieee->privacy_invoked = 0;\r\nreturn dev;\r\nfailed_free_wiphy:\r\nif (!monitor)\r\nwiphy_free(ieee->wdev.wiphy);\r\nfailed_free_netdev:\r\nfree_netdev(dev);\r\nfailed:\r\nreturn NULL;\r\n}\r\nvoid free_libipw(struct net_device *dev, int monitor)\r\n{\r\nstruct libipw_device *ieee = netdev_priv(dev);\r\nlib80211_crypt_info_free(&ieee->crypt_info);\r\nlibipw_networks_free(ieee);\r\nif (!monitor)\r\nwiphy_free(ieee->wdev.wiphy);\r\nfree_netdev(dev);\r\n}\r\nstatic int debug_level_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "0x%08X\n", libipw_debug_level);\r\nreturn 0;\r\n}\r\nstatic int debug_level_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debug_level_proc_show, NULL);\r\n}\r\nstatic ssize_t debug_level_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nchar buf[] = "0x00000000\n";\r\nsize_t len = min(sizeof(buf) - 1, count);\r\nunsigned long val;\r\nif (copy_from_user(buf, buffer, len))\r\nreturn count;\r\nbuf[len] = 0;\r\nif (sscanf(buf, "%li", &val) != 1)\r\nprintk(KERN_INFO DRV_NAME\r\n": %s is not in hex or decimal form.\n", buf);\r\nelse\r\nlibipw_debug_level = val;\r\nreturn strnlen(buf, len);\r\n}\r\nstatic int __init libipw_init(void)\r\n{\r\n#ifdef CONFIG_LIBIPW_DEBUG\r\nstruct proc_dir_entry *e;\r\nlibipw_debug_level = debug;\r\nlibipw_proc = proc_mkdir(DRV_PROCNAME, init_net.proc_net);\r\nif (libipw_proc == NULL) {\r\nLIBIPW_ERROR("Unable to create " DRV_PROCNAME\r\n" proc directory\n");\r\nreturn -EIO;\r\n}\r\ne = proc_create("debug_level", S_IRUGO | S_IWUSR, libipw_proc,\r\n&debug_level_proc_fops);\r\nif (!e) {\r\nremove_proc_entry(DRV_PROCNAME, init_net.proc_net);\r\nlibipw_proc = NULL;\r\nreturn -EIO;\r\n}\r\n#endif\r\nprintk(KERN_INFO DRV_NAME ": " DRV_DESCRIPTION ", " DRV_VERSION "\n");\r\nprintk(KERN_INFO DRV_NAME ": " DRV_COPYRIGHT "\n");\r\nreturn 0;\r\n}\r\nstatic void __exit libipw_exit(void)\r\n{\r\n#ifdef CONFIG_LIBIPW_DEBUG\r\nif (libipw_proc) {\r\nremove_proc_entry("debug_level", libipw_proc);\r\nremove_proc_entry(DRV_PROCNAME, init_net.proc_net);\r\nlibipw_proc = NULL;\r\n}\r\n#endif\r\n}
