static int polaris10_set_smc_sram_address(struct pp_smumgr *smumgr, uint32_t smc_addr, uint32_t limit)\r\n{\r\nPP_ASSERT_WITH_CODE((0 == (3 & smc_addr)), "SMC address must be 4 byte aligned.", return -EINVAL);\r\nPP_ASSERT_WITH_CODE((limit > (smc_addr + 3)), "SMC addr is beyond the SMC RAM area.", return -EINVAL);\r\ncgs_write_register(smumgr->device, mmSMC_IND_INDEX_11, smc_addr);\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_11, 0);\r\nreturn 0;\r\n}\r\nint polaris10_copy_bytes_from_smc(struct pp_smumgr *smumgr, uint32_t smc_start_address, uint32_t *dest, uint32_t byte_count, uint32_t limit)\r\n{\r\nuint32_t data;\r\nuint32_t addr;\r\nuint8_t *dest_byte;\r\nuint8_t i, data_byte[4] = {0};\r\nuint32_t *pdata = (uint32_t *)&data_byte;\r\nPP_ASSERT_WITH_CODE((0 == (3 & smc_start_address)), "SMC address must be 4 byte aligned.", return -1;);\r\nPP_ASSERT_WITH_CODE((limit > (smc_start_address + byte_count)), "SMC address is beyond the SMC RAM area.", return -1);\r\naddr = smc_start_address;\r\nwhile (byte_count >= 4) {\r\npolaris10_read_smc_sram_dword(smumgr, addr, &data, limit);\r\n*dest = PP_SMC_TO_HOST_UL(data);\r\ndest += 1;\r\nbyte_count -= 4;\r\naddr += 4;\r\n}\r\nif (byte_count) {\r\npolaris10_read_smc_sram_dword(smumgr, addr, &data, limit);\r\n*pdata = PP_SMC_TO_HOST_UL(data);\r\ndest_byte = (uint8_t *)dest;\r\nfor (i = 0; i < byte_count; i++)\r\ndest_byte[i] = data_byte[i];\r\n}\r\nreturn 0;\r\n}\r\nint polaris10_copy_bytes_to_smc(struct pp_smumgr *smumgr, uint32_t smc_start_address,\r\nconst uint8_t *src, uint32_t byte_count, uint32_t limit)\r\n{\r\nint result;\r\nuint32_t data = 0;\r\nuint32_t original_data;\r\nuint32_t addr = 0;\r\nuint32_t extra_shift;\r\nPP_ASSERT_WITH_CODE((0 == (3 & smc_start_address)), "SMC address must be 4 byte aligned.", return -1);\r\nPP_ASSERT_WITH_CODE((limit > (smc_start_address + byte_count)), "SMC address is beyond the SMC RAM area.", return -1);\r\naddr = smc_start_address;\r\nwhile (byte_count >= 4) {\r\ndata = src[0] * 0x1000000 + src[1] * 0x10000 + src[2] * 0x100 + src[3];\r\nresult = polaris10_set_smc_sram_address(smumgr, addr, limit);\r\nif (0 != result)\r\nreturn result;\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_11, data);\r\nsrc += 4;\r\nbyte_count -= 4;\r\naddr += 4;\r\n}\r\nif (0 != byte_count) {\r\ndata = 0;\r\nresult = polaris10_set_smc_sram_address(smumgr, addr, limit);\r\nif (0 != result)\r\nreturn result;\r\noriginal_data = cgs_read_register(smumgr->device, mmSMC_IND_DATA_11);\r\nextra_shift = 8 * (4 - byte_count);\r\nwhile (byte_count > 0) {\r\ndata = (0x100 * data) + *src++;\r\nbyte_count--;\r\n}\r\ndata <<= extra_shift;\r\ndata |= (original_data & ~((~0UL) << extra_shift));\r\nresult = polaris10_set_smc_sram_address(smumgr, addr, limit);\r\nif (0 != result)\r\nreturn result;\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_11, data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int polaris10_program_jump_on_start(struct pp_smumgr *smumgr)\r\n{\r\nstatic const unsigned char data[4] = { 0xE0, 0x00, 0x80, 0x40 };\r\npolaris10_copy_bytes_to_smc(smumgr, 0x0, data, 4, sizeof(data)+1);\r\nreturn 0;\r\n}\r\nbool polaris10_is_smc_ram_running(struct pp_smumgr *smumgr)\r\n{\r\nreturn ((0 == SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC, SMC_SYSCON_CLOCK_CNTL_0, ck_disable))\r\n&& (0x20100 <= cgs_read_ind_register(smumgr->device, CGS_IND_REG__SMC, ixSMC_PC_C)));\r\n}\r\nstatic bool polaris10_is_hw_avfs_present(struct pp_smumgr *smumgr)\r\n{\r\nuint32_t efuse;\r\nefuse = cgs_read_ind_register(smumgr->device, CGS_IND_REG__SMC, ixSMU_EFUSE_0 + (49*4));\r\nefuse &= 0x00000001;\r\nif (efuse)\r\nreturn true;\r\nreturn false;\r\n}\r\nint polaris10_send_msg_to_smc(struct pp_smumgr *smumgr, uint16_t msg)\r\n{\r\nint ret;\r\nif (!polaris10_is_smc_ram_running(smumgr))\r\nreturn -1;\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\nret = SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP);\r\nif (ret != 1)\r\nprintk("\n failed to send pre message %x ret is %d \n", msg, ret);\r\ncgs_write_register(smumgr->device, mmSMC_MESSAGE_0, msg);\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\nret = SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP);\r\nif (ret != 1)\r\nprintk("\n failed to send message %x ret is %d \n", msg, ret);\r\nreturn 0;\r\n}\r\nint polaris10_send_msg_to_smc_without_waiting(struct pp_smumgr *smumgr, uint16_t msg)\r\n{\r\ncgs_write_register(smumgr->device, mmSMC_MESSAGE_0, msg);\r\nreturn 0;\r\n}\r\nint polaris10_send_msg_to_smc_with_parameter(struct pp_smumgr *smumgr, uint16_t msg, uint32_t parameter)\r\n{\r\nif (!polaris10_is_smc_ram_running(smumgr)) {\r\nreturn -1;\r\n}\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\ncgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, parameter);\r\nreturn polaris10_send_msg_to_smc(smumgr, msg);\r\n}\r\nint polaris10_send_msg_to_smc_with_parameter_without_waiting(struct pp_smumgr *smumgr, uint16_t msg, uint32_t parameter)\r\n{\r\ncgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, parameter);\r\nreturn polaris10_send_msg_to_smc_without_waiting(smumgr, msg);\r\n}\r\nint polaris10_send_msg_to_smc_offset(struct pp_smumgr *smumgr)\r\n{\r\ncgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, 0x20000);\r\ncgs_write_register(smumgr->device, mmSMC_MESSAGE_0, PPSMC_MSG_Test);\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\nif (1 != SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP))\r\nprintk("Failed to send Message.\n");\r\nreturn 0;\r\n}\r\nint polaris10_wait_for_smc_inactive(struct pp_smumgr *smumgr)\r\n{\r\nif (!polaris10_is_smc_ram_running(smumgr))\r\nreturn -1;\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD(smumgr, SMC_IND, SMC_SYSCON_CLOCK_CNTL_0, cken, 0);\r\nreturn 0;\r\n}\r\nstatic int polaris10_upload_smc_firmware_data(struct pp_smumgr *smumgr, uint32_t length, uint32_t *src, uint32_t limit)\r\n{\r\nuint32_t byte_count = length;\r\nPP_ASSERT_WITH_CODE((limit >= byte_count), "SMC address is beyond the SMC RAM area.", return -1);\r\ncgs_write_register(smumgr->device, mmSMC_IND_INDEX_11, 0x20000);\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_11, 1);\r\nfor (; byte_count >= 4; byte_count -= 4)\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_11, *src++);\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_11, 0);\r\nPP_ASSERT_WITH_CODE((0 == byte_count), "SMC size must be dividable by 4.", return -1);\r\nreturn 0;\r\n}\r\nstatic enum cgs_ucode_id polaris10_convert_fw_type_to_cgs(uint32_t fw_type)\r\n{\r\nenum cgs_ucode_id result = CGS_UCODE_ID_MAXIMUM;\r\nswitch (fw_type) {\r\ncase UCODE_ID_SMU:\r\nresult = CGS_UCODE_ID_SMU;\r\nbreak;\r\ncase UCODE_ID_SMU_SK:\r\nresult = CGS_UCODE_ID_SMU_SK;\r\nbreak;\r\ncase UCODE_ID_SDMA0:\r\nresult = CGS_UCODE_ID_SDMA0;\r\nbreak;\r\ncase UCODE_ID_SDMA1:\r\nresult = CGS_UCODE_ID_SDMA1;\r\nbreak;\r\ncase UCODE_ID_CP_CE:\r\nresult = CGS_UCODE_ID_CP_CE;\r\nbreak;\r\ncase UCODE_ID_CP_PFP:\r\nresult = CGS_UCODE_ID_CP_PFP;\r\nbreak;\r\ncase UCODE_ID_CP_ME:\r\nresult = CGS_UCODE_ID_CP_ME;\r\nbreak;\r\ncase UCODE_ID_CP_MEC:\r\nresult = CGS_UCODE_ID_CP_MEC;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT1:\r\nresult = CGS_UCODE_ID_CP_MEC_JT1;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT2:\r\nresult = CGS_UCODE_ID_CP_MEC_JT2;\r\nbreak;\r\ncase UCODE_ID_RLC_G:\r\nresult = CGS_UCODE_ID_RLC_G;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int polaris10_upload_smu_firmware_image(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(smumgr->backend);\r\nstruct cgs_firmware_info info = {0};\r\nif (smu_data->security_hard_key == 1)\r\ncgs_get_firmware_info(smumgr->device,\r\npolaris10_convert_fw_type_to_cgs(UCODE_ID_SMU), &info);\r\nelse\r\ncgs_get_firmware_info(smumgr->device,\r\npolaris10_convert_fw_type_to_cgs(UCODE_ID_SMU_SK), &info);\r\nresult = polaris10_upload_smc_firmware_data(smumgr, info.image_size, (uint32_t *)info.kptr, POLARIS10_SMC_SIZE);\r\nreturn result;\r\n}\r\nint polaris10_read_smc_sram_dword(struct pp_smumgr *smumgr, uint32_t smc_addr, uint32_t *value, uint32_t limit)\r\n{\r\nint result;\r\nresult = polaris10_set_smc_sram_address(smumgr, smc_addr, limit);\r\nif (result)\r\nreturn result;\r\n*value = cgs_read_register(smumgr->device, mmSMC_IND_DATA_11);\r\nreturn 0;\r\n}\r\nint polaris10_write_smc_sram_dword(struct pp_smumgr *smumgr, uint32_t smc_addr, uint32_t value, uint32_t limit)\r\n{\r\nint result;\r\nresult = polaris10_set_smc_sram_address(smumgr, smc_addr, limit);\r\nif (result)\r\nreturn result;\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_11, value);\r\nreturn 0;\r\n}\r\nint polaris10_smu_fini(struct pp_smumgr *smumgr)\r\n{\r\nif (smumgr->backend) {\r\nkfree(smumgr->backend);\r\nsmumgr->backend = NULL;\r\n}\r\ncgs_rel_firmware(smumgr->device, CGS_UCODE_ID_SMU);\r\nreturn 0;\r\n}\r\nstatic uint32_t polaris10_get_mask_for_firmware_type(uint32_t fw_type)\r\n{\r\nuint32_t result = 0;\r\nswitch (fw_type) {\r\ncase UCODE_ID_SDMA0:\r\nresult = UCODE_ID_SDMA0_MASK;\r\nbreak;\r\ncase UCODE_ID_SDMA1:\r\nresult = UCODE_ID_SDMA1_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_CE:\r\nresult = UCODE_ID_CP_CE_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_PFP:\r\nresult = UCODE_ID_CP_PFP_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_ME:\r\nresult = UCODE_ID_CP_ME_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT1:\r\ncase UCODE_ID_CP_MEC_JT2:\r\nresult = UCODE_ID_CP_MEC_MASK;\r\nbreak;\r\ncase UCODE_ID_RLC_G:\r\nresult = UCODE_ID_RLC_G_MASK;\r\nbreak;\r\ndefault:\r\nprintk("UCode type is out of range! \n");\r\nresult = 0;\r\n}\r\nreturn result;\r\n}\r\nstatic int polaris10_populate_single_firmware_entry(struct pp_smumgr *smumgr,\r\nuint32_t fw_type,\r\nstruct SMU_Entry *entry)\r\n{\r\nint result = 0;\r\nstruct cgs_firmware_info info = {0};\r\nresult = cgs_get_firmware_info(smumgr->device,\r\npolaris10_convert_fw_type_to_cgs(fw_type),\r\n&info);\r\nif (!result) {\r\nentry->version = info.version;\r\nentry->id = (uint16_t)fw_type;\r\nentry->image_addr_high = smu_upper_32_bits(info.mc_addr);\r\nentry->image_addr_low = smu_lower_32_bits(info.mc_addr);\r\nentry->meta_data_addr_high = 0;\r\nentry->meta_data_addr_low = 0;\r\nentry->data_size_byte = info.image_size;\r\nentry->num_register_entries = 0;\r\n}\r\nif (fw_type == UCODE_ID_RLC_G)\r\nentry->flags = 1;\r\nelse\r\nentry->flags = 0;\r\nreturn 0;\r\n}\r\nstatic int polaris10_request_smu_load_fw(struct pp_smumgr *smumgr)\r\n{\r\nstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(smumgr->backend);\r\nuint32_t fw_to_load;\r\nint result = 0;\r\nstruct SMU_DRAMData_TOC *toc;\r\nif (!smumgr->reload_fw) {\r\nprintk(KERN_INFO "[ powerplay ] skip reloading...\n");\r\nreturn 0;\r\n}\r\nif (smu_data->soft_regs_start)\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\nsmu_data->soft_regs_start + offsetof(SMU74_SoftRegisters, UcodeLoadStatus),\r\n0x0);\r\npolaris10_send_msg_to_smc_with_parameter(smumgr, PPSMC_MSG_SMU_DRAM_ADDR_HI, smu_data->smu_buffer.mc_addr_high);\r\npolaris10_send_msg_to_smc_with_parameter(smumgr, PPSMC_MSG_SMU_DRAM_ADDR_LO, smu_data->smu_buffer.mc_addr_low);\r\ntoc = (struct SMU_DRAMData_TOC *)smu_data->header;\r\ntoc->num_entries = 0;\r\ntoc->structure_version = 1;\r\nPP_ASSERT_WITH_CODE(0 == polaris10_populate_single_firmware_entry(smumgr, UCODE_ID_RLC_G, &toc->entry[toc->num_entries++]), "Failed to Get Firmware Entry.", return -1);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_populate_single_firmware_entry(smumgr, UCODE_ID_CP_CE, &toc->entry[toc->num_entries++]), "Failed to Get Firmware Entry.", return -1);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_populate_single_firmware_entry(smumgr, UCODE_ID_CP_PFP, &toc->entry[toc->num_entries++]), "Failed to Get Firmware Entry.", return -1);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_populate_single_firmware_entry(smumgr, UCODE_ID_CP_ME, &toc->entry[toc->num_entries++]), "Failed to Get Firmware Entry.", return -1);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_populate_single_firmware_entry(smumgr, UCODE_ID_CP_MEC, &toc->entry[toc->num_entries++]), "Failed to Get Firmware Entry.", return -1);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_populate_single_firmware_entry(smumgr, UCODE_ID_CP_MEC_JT1, &toc->entry[toc->num_entries++]), "Failed to Get Firmware Entry.", return -1);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_populate_single_firmware_entry(smumgr, UCODE_ID_CP_MEC_JT2, &toc->entry[toc->num_entries++]), "Failed to Get Firmware Entry.", return -1);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_populate_single_firmware_entry(smumgr, UCODE_ID_SDMA0, &toc->entry[toc->num_entries++]), "Failed to Get Firmware Entry.", return -1);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_populate_single_firmware_entry(smumgr, UCODE_ID_SDMA1, &toc->entry[toc->num_entries++]), "Failed to Get Firmware Entry.", return -1);\r\npolaris10_send_msg_to_smc_with_parameter(smumgr, PPSMC_MSG_DRV_DRAM_ADDR_HI, smu_data->header_buffer.mc_addr_high);\r\npolaris10_send_msg_to_smc_with_parameter(smumgr, PPSMC_MSG_DRV_DRAM_ADDR_LO, smu_data->header_buffer.mc_addr_low);\r\nfw_to_load = UCODE_ID_RLC_G_MASK\r\n+ UCODE_ID_SDMA0_MASK\r\n+ UCODE_ID_SDMA1_MASK\r\n+ UCODE_ID_CP_CE_MASK\r\n+ UCODE_ID_CP_ME_MASK\r\n+ UCODE_ID_CP_PFP_MASK\r\n+ UCODE_ID_CP_MEC_MASK;\r\nif (polaris10_send_msg_to_smc_with_parameter(smumgr, PPSMC_MSG_LoadUcodes, fw_to_load))\r\nprintk(KERN_ERR "Fail to Request SMU Load uCode");\r\nreturn result;\r\n}\r\nstatic int polaris10_check_fw_load_finish(struct pp_smumgr *smumgr, uint32_t fw_type)\r\n{\r\nstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(smumgr->backend);\r\nuint32_t fw_mask = polaris10_get_mask_for_firmware_type(fw_type);\r\nuint32_t ret;\r\nret = smum_wait_on_indirect_register(smumgr, mmSMC_IND_INDEX_11,\r\nsmu_data->soft_regs_start + offsetof(SMU74_SoftRegisters, UcodeLoadStatus),\r\nfw_mask, fw_mask);\r\nreturn ret;\r\n}\r\nstatic int polaris10_reload_firmware(struct pp_smumgr *smumgr)\r\n{\r\nreturn smumgr->smumgr_funcs->start_smu(smumgr);\r\n}\r\nstatic int polaris10_setup_pwr_virus(struct pp_smumgr *smumgr)\r\n{\r\nint i;\r\nint result = -1;\r\nuint32_t reg, data;\r\nconst PWR_Command_Table *pvirus = pwr_virus_table;\r\nstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(smumgr->backend);\r\nfor (i = 0; i < PWR_VIRUS_TABLE_SIZE; i++) {\r\nswitch (pvirus->command) {\r\ncase PwrCmdWrite:\r\nreg = pvirus->reg;\r\ndata = pvirus->data;\r\ncgs_write_register(smumgr->device, reg, data);\r\nbreak;\r\ncase PwrCmdEnd:\r\nresult = 0;\r\nbreak;\r\ndefault:\r\nprintk("Table Exit with Invalid Command!");\r\nsmu_data->avfs.avfs_btc_status = AVFS_BTC_VIRUS_FAIL;\r\nresult = -1;\r\nbreak;\r\n}\r\npvirus++;\r\n}\r\nreturn result;\r\n}\r\nstatic int polaris10_perform_btc(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(smumgr->backend);\r\nif (0 != smu_data->avfs.avfs_btc_param) {\r\nif (0 != polaris10_send_msg_to_smc_with_parameter(smumgr, PPSMC_MSG_PerformBtc, smu_data->avfs.avfs_btc_param)) {\r\nprintk("[AVFS][SmuPolaris10_PerformBtc] PerformBTC SMU msg failed");\r\nresult = -1;\r\n}\r\n}\r\nif (smu_data->avfs.avfs_btc_param > 1) {\r\ncgs_write_register(smumgr->device, mmCP_MEC_CNTL, 0x50000000);\r\ncgs_write_register(smumgr->device, mmGRBM_SOFT_RESET, 0xffffffff);\r\ncgs_write_register(smumgr->device, mmGRBM_SOFT_RESET, 0);\r\n}\r\nreturn result;\r\n}\r\nint polaris10_setup_graphics_level_structure(struct pp_smumgr *smumgr)\r\n{\r\nuint32_t vr_config;\r\nuint32_t dpm_table_start;\r\nuint16_t u16_boot_mvdd;\r\nuint32_t graphics_level_address, vr_config_address, graphics_level_size;\r\ngraphics_level_size = sizeof(avfs_graphics_level_polaris10);\r\nu16_boot_mvdd = PP_HOST_TO_SMC_US(1300 * VOLTAGE_SCALE);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_read_smc_sram_dword(smumgr,\r\nSMU7_FIRMWARE_HEADER_LOCATION + offsetof(SMU74_Firmware_Header, DpmTable),\r\n&dpm_table_start, 0x40000),\r\n"[AVFS][Polaris10_SetupGfxLvlStruct] SMU could not communicate starting address of DPM table",\r\nreturn -1);\r\nvr_config = 0x01000500;\r\nvr_config_address = dpm_table_start + offsetof(SMU74_Discrete_DpmTable, VRConfig);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_copy_bytes_to_smc(smumgr, vr_config_address,\r\n(uint8_t *)&vr_config, sizeof(uint32_t), 0x40000),\r\n"[AVFS][Polaris10_SetupGfxLvlStruct] Problems copying VRConfig value over to SMC",\r\nreturn -1);\r\ngraphics_level_address = dpm_table_start + offsetof(SMU74_Discrete_DpmTable, GraphicsLevel);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_copy_bytes_to_smc(smumgr, graphics_level_address,\r\n(uint8_t *)(&avfs_graphics_level_polaris10),\r\ngraphics_level_size, 0x40000),\r\n"[AVFS][Polaris10_SetupGfxLvlStruct] Copying of SCLK DPM table failed!",\r\nreturn -1);\r\ngraphics_level_address = dpm_table_start + offsetof(SMU74_Discrete_DpmTable, MemoryLevel);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_copy_bytes_to_smc(smumgr, graphics_level_address,\r\n(uint8_t *)(&avfs_memory_level_polaris10), sizeof(avfs_memory_level_polaris10), 0x40000),\r\n"[AVFS][Polaris10_SetupGfxLvlStruct] Copying of MCLK DPM table failed!",\r\nreturn -1);\r\ngraphics_level_address = dpm_table_start + offsetof(SMU74_Discrete_DpmTable, BootMVdd);\r\nPP_ASSERT_WITH_CODE(0 == polaris10_copy_bytes_to_smc(smumgr, graphics_level_address,\r\n(uint8_t *)(&u16_boot_mvdd), sizeof(u16_boot_mvdd), 0x40000),\r\n"[AVFS][Polaris10_SetupGfxLvlStruct] Copying of DPM table failed!",\r\nreturn -1);\r\nreturn 0;\r\n}\r\nint polaris10_avfs_event_mgr(struct pp_smumgr *smumgr, bool SMU_VFT_INTACT)\r\n{\r\nstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(smumgr->backend);\r\nswitch (smu_data->avfs.avfs_btc_status) {\r\ncase AVFS_BTC_COMPLETED_PREVIOUSLY:\r\nbreak;\r\ncase AVFS_BTC_BOOT:\r\nsmu_data->avfs.avfs_btc_status = AVFS_BTC_DPMTABLESETUP_FAILED;\r\nPP_ASSERT_WITH_CODE(0 == polaris10_setup_graphics_level_structure(smumgr),\r\n"[AVFS][Polaris10_AVFSEventMgr] Could not Copy Graphics Level table over to SMU",\r\nreturn -1);\r\nif (smu_data->avfs.avfs_btc_param > 1) {\r\nprintk("[AVFS][Polaris10_AVFSEventMgr] AC BTC has not been successfully verified on Fiji. There may be in this setting.");\r\nsmu_data->avfs.avfs_btc_status = AVFS_BTC_VIRUS_FAIL;\r\nPP_ASSERT_WITH_CODE(-1 == polaris10_setup_pwr_virus(smumgr),\r\n"[AVFS][Polaris10_AVFSEventMgr] Could not setup Pwr Virus for AVFS ",\r\nreturn -1);\r\n}\r\nsmu_data->avfs.avfs_btc_status = AVFS_BTC_FAILED;\r\nPP_ASSERT_WITH_CODE(0 == polaris10_perform_btc(smumgr),\r\n"[AVFS][Polaris10_AVFSEventMgr] Failure at SmuPolaris10_PerformBTC. AVFS Disabled",\r\nreturn -1);\r\nbreak;\r\ncase AVFS_BTC_DISABLED:\r\ncase AVFS_BTC_NOTSUPPORTED:\r\nbreak;\r\ndefault:\r\nprintk("[AVFS] Something is broken. See log!");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int polaris10_start_smu_in_protection_mode(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 1);\r\nresult = polaris10_upload_smu_firmware_image(smumgr);\r\nif (result != 0)\r\nreturn result;\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC, ixSMU_STATUS, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_CLOCK_CNTL_0, ck_disable, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 0);\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD(smumgr, SMC_IND, RCU_UC_EVENTS, INTERRUPTS_ENABLED, 1);\r\npolaris10_send_msg_to_smc_offset(smumgr);\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD_UNEQUAL(smumgr, SMC_IND, SMU_STATUS, SMU_DONE, 0);\r\nif (1 != SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMU_STATUS, SMU_PASS))\r\nPP_ASSERT_WITH_CODE(false, "SMU Firmware start failed!", return -1);\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC, ixFIRMWARE_FLAGS, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 1);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 0);\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD(smumgr, SMC_IND, FIRMWARE_FLAGS, INTERRUPTS_ENABLED, 1);\r\nreturn result;\r\n}\r\nstatic int polaris10_start_smu_in_non_protection_mode(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD_UNEQUAL(smumgr, SMC_IND, RCU_UC_EVENTS, boot_seq_done, 0);\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\nixFIRMWARE_FLAGS, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL,\r\nrst_reg, 1);\r\nresult = polaris10_upload_smu_firmware_image(smumgr);\r\nif (result != 0)\r\nreturn result;\r\npolaris10_program_jump_on_start(smumgr);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_CLOCK_CNTL_0, ck_disable, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 0);\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD(smumgr, SMC_IND,\r\nFIRMWARE_FLAGS, INTERRUPTS_ENABLED, 1);\r\nreturn result;\r\n}\r\nstatic int polaris10_start_smu(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(smumgr->backend);\r\nbool SMU_VFT_INTACT;\r\nif (!polaris10_is_smc_ram_running(smumgr)) {\r\nSMU_VFT_INTACT = false;\r\nsmu_data->protected_mode = (uint8_t) (SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC, SMU_FIRMWARE, SMU_MODE));\r\nsmu_data->security_hard_key = (uint8_t) (SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC, SMU_FIRMWARE, SMU_SEL));\r\nif (smu_data->protected_mode == 0) {\r\nresult = polaris10_start_smu_in_non_protection_mode(smumgr);\r\n} else {\r\nresult = polaris10_start_smu_in_protection_mode(smumgr);\r\nif (result != 0) {\r\nsmu_data->security_hard_key ^= 1;\r\nresult = polaris10_start_smu_in_protection_mode(smumgr);\r\n}\r\n}\r\nif (result != 0)\r\nPP_ASSERT_WITH_CODE(0, "Failed to load SMU ucode.", return result);\r\npolaris10_avfs_event_mgr(smumgr, true);\r\n} else\r\nSMU_VFT_INTACT = true;\r\nsmu_data->post_initial_boot = true;\r\npolaris10_avfs_event_mgr(smumgr, SMU_VFT_INTACT);\r\npolaris10_read_smc_sram_dword(smumgr, SMU7_FIRMWARE_HEADER_LOCATION + offsetof(SMU74_Firmware_Header, SoftRegisters),\r\n&(smu_data->soft_regs_start), 0x40000);\r\nresult = polaris10_request_smu_load_fw(smumgr);\r\nreturn result;\r\n}\r\nstatic int polaris10_smu_init(struct pp_smumgr *smumgr)\r\n{\r\nstruct polaris10_smumgr *smu_data;\r\nuint8_t *internal_buf;\r\nuint64_t mc_addr = 0;\r\nsmu_data = (struct polaris10_smumgr *)(smumgr->backend);\r\nsmu_data->header_buffer.data_size =\r\n((sizeof(struct SMU_DRAMData_TOC) / 4096) + 1) * 4096;\r\nsmu_data->smu_buffer.data_size = 200*4096;\r\nsmu_data->avfs.avfs_btc_status = AVFS_BTC_NOTSUPPORTED;\r\nsmu_allocate_memory(smumgr->device,\r\nsmu_data->header_buffer.data_size,\r\nCGS_GPU_MEM_TYPE__VISIBLE_CONTIG_FB,\r\nPAGE_SIZE,\r\n&mc_addr,\r\n&smu_data->header_buffer.kaddr,\r\n&smu_data->header_buffer.handle);\r\nsmu_data->header = smu_data->header_buffer.kaddr;\r\nsmu_data->header_buffer.mc_addr_high = smu_upper_32_bits(mc_addr);\r\nsmu_data->header_buffer.mc_addr_low = smu_lower_32_bits(mc_addr);\r\nPP_ASSERT_WITH_CODE((NULL != smu_data->header),\r\n"Out of memory.",\r\nkfree(smumgr->backend);\r\ncgs_free_gpu_mem(smumgr->device,\r\n(cgs_handle_t)smu_data->header_buffer.handle);\r\nreturn -1);\r\nsmu_allocate_memory(smumgr->device,\r\nsmu_data->smu_buffer.data_size,\r\nCGS_GPU_MEM_TYPE__VISIBLE_CONTIG_FB,\r\nPAGE_SIZE,\r\n&mc_addr,\r\n&smu_data->smu_buffer.kaddr,\r\n&smu_data->smu_buffer.handle);\r\ninternal_buf = smu_data->smu_buffer.kaddr;\r\nsmu_data->smu_buffer.mc_addr_high = smu_upper_32_bits(mc_addr);\r\nsmu_data->smu_buffer.mc_addr_low = smu_lower_32_bits(mc_addr);\r\nPP_ASSERT_WITH_CODE((NULL != internal_buf),\r\n"Out of memory.",\r\nkfree(smumgr->backend);\r\ncgs_free_gpu_mem(smumgr->device,\r\n(cgs_handle_t)smu_data->smu_buffer.handle);\r\nreturn -1;);\r\nif (polaris10_is_hw_avfs_present(smumgr))\r\nsmu_data->avfs.avfs_btc_status = AVFS_BTC_BOOT;\r\nelse\r\nsmu_data->avfs.avfs_btc_status = AVFS_BTC_NOTSUPPORTED;\r\nreturn 0;\r\n}\r\nint polaris10_smum_init(struct pp_smumgr *smumgr)\r\n{\r\nstruct polaris10_smumgr *polaris10_smu = NULL;\r\npolaris10_smu = kzalloc(sizeof(struct polaris10_smumgr), GFP_KERNEL);\r\nif (polaris10_smu == NULL)\r\nreturn -1;\r\nsmumgr->backend = polaris10_smu;\r\nsmumgr->smumgr_funcs = &ellsemere_smu_funcs;\r\nreturn 0;\r\n}
