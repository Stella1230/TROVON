void mei_amthif_reset_params(struct mei_device *dev)\r\n{\r\ndev->iamthif_current_cb = NULL;\r\ndev->iamthif_canceled = false;\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\ndev->iamthif_stall_timer = 0;\r\ndev->iamthif_open_count = 0;\r\n}\r\nint mei_amthif_host_init(struct mei_device *dev, struct mei_me_client *me_cl)\r\n{\r\nstruct mei_cl *cl = &dev->iamthif_cl;\r\nint ret;\r\nif (mei_cl_is_connected(cl))\r\nreturn 0;\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\nmei_cl_init(cl, dev);\r\nret = mei_cl_link(cl);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "amthif: failed cl_link %d\n", ret);\r\nreturn ret;\r\n}\r\nret = mei_cl_connect(cl, me_cl, NULL);\r\nreturn ret;\r\n}\r\nint mei_amthif_read(struct mei_device *dev, struct file *file,\r\nchar __user *ubuf, size_t length, loff_t *offset)\r\n{\r\nstruct mei_cl *cl = file->private_data;\r\nstruct mei_cl_cb *cb;\r\nint rets;\r\nint wait_ret;\r\ndev_dbg(dev->dev, "checking amthif data\n");\r\ncb = mei_cl_read_cb(cl, file);\r\nif (cb == NULL && file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\ndev_dbg(dev->dev, "waiting for amthif data\n");\r\nwhile (cb == NULL) {\r\nmutex_unlock(&dev->device_lock);\r\nwait_ret = wait_event_interruptible(cl->rx_wait,\r\n!list_empty(&cl->rd_completed) ||\r\n!mei_cl_is_connected(cl));\r\nmutex_lock(&dev->device_lock);\r\nif (wait_ret)\r\nreturn -ERESTARTSYS;\r\nif (!mei_cl_is_connected(cl)) {\r\nrets = -EBUSY;\r\ngoto out;\r\n}\r\ncb = mei_cl_read_cb(cl, file);\r\n}\r\nif (cb->status) {\r\nrets = cb->status;\r\ndev_dbg(dev->dev, "read operation failed %d\n", rets);\r\ngoto free;\r\n}\r\ndev_dbg(dev->dev, "Got amthif data\n");\r\nif (cb->buf_idx >= *offset && length >= (cb->buf_idx - *offset))\r\nlist_del_init(&cb->list);\r\nelse if (cb->buf_idx <= *offset) {\r\nlist_del_init(&cb->list);\r\nrets = 0;\r\ngoto free;\r\n}\r\ndev_dbg(dev->dev, "amthif cb->buf.size - %zu cb->buf_idx - %zu\n",\r\ncb->buf.size, cb->buf_idx);\r\nlength = min_t(size_t, length, (cb->buf_idx - *offset));\r\nif (copy_to_user(ubuf, cb->buf.data + *offset, length)) {\r\ndev_dbg(dev->dev, "failed to copy data to userland\n");\r\nrets = -EFAULT;\r\n} else {\r\nrets = length;\r\nif ((*offset + length) < cb->buf_idx) {\r\n*offset += length;\r\ngoto out;\r\n}\r\n}\r\nfree:\r\ndev_dbg(dev->dev, "free amthif cb memory.\n");\r\n*offset = 0;\r\nmei_io_cb_free(cb);\r\nout:\r\nreturn rets;\r\n}\r\nstatic int mei_amthif_read_start(struct mei_cl *cl, const struct file *file)\r\n{\r\nstruct mei_device *dev = cl->dev;\r\nstruct mei_cl_cb *cb;\r\nint rets;\r\ncb = mei_io_cb_init(cl, MEI_FOP_READ, file);\r\nif (!cb) {\r\nrets = -ENOMEM;\r\ngoto err;\r\n}\r\nrets = mei_io_cb_alloc_buf(cb, mei_cl_mtu(cl));\r\nif (rets)\r\ngoto err;\r\nlist_add_tail(&cb->list, &dev->ctrl_wr_list.list);\r\ndev->iamthif_state = MEI_IAMTHIF_READING;\r\ndev->iamthif_fp = cb->fp;\r\ndev->iamthif_current_cb = cb;\r\nreturn 0;\r\nerr:\r\nmei_io_cb_free(cb);\r\nreturn rets;\r\n}\r\nstatic int mei_amthif_send_cmd(struct mei_cl *cl, struct mei_cl_cb *cb)\r\n{\r\nstruct mei_device *dev;\r\nint ret;\r\nif (!cl->dev || !cb)\r\nreturn -ENODEV;\r\ndev = cl->dev;\r\ndev->iamthif_state = MEI_IAMTHIF_WRITING;\r\ndev->iamthif_current_cb = cb;\r\ndev->iamthif_fp = cb->fp;\r\ndev->iamthif_canceled = false;\r\nret = mei_cl_write(cl, cb, false);\r\nif (ret < 0)\r\nreturn ret;\r\nif (cb->completed)\r\ncb->status = mei_amthif_read_start(cl, cb->fp);\r\nreturn 0;\r\n}\r\nint mei_amthif_run_next_cmd(struct mei_device *dev)\r\n{\r\nstruct mei_cl *cl = &dev->iamthif_cl;\r\nstruct mei_cl_cb *cb;\r\ndev->iamthif_canceled = false;\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\ndev->iamthif_fp = NULL;\r\ndev_dbg(dev->dev, "complete amthif cmd_list cb.\n");\r\ncb = list_first_entry_or_null(&dev->amthif_cmd_list.list,\r\ntypeof(*cb), list);\r\nif (!cb)\r\nreturn 0;\r\nlist_del_init(&cb->list);\r\nreturn mei_amthif_send_cmd(cl, cb);\r\n}\r\nint mei_amthif_write(struct mei_cl *cl, struct mei_cl_cb *cb)\r\n{\r\nstruct mei_device *dev = cl->dev;\r\nlist_add_tail(&cb->list, &dev->amthif_cmd_list.list);\r\nif (dev->iamthif_state > MEI_IAMTHIF_IDLE &&\r\ndev->iamthif_state < MEI_IAMTHIF_READ_COMPLETE)\r\nreturn 0;\r\nreturn mei_amthif_run_next_cmd(dev);\r\n}\r\nunsigned int mei_amthif_poll(struct mei_device *dev,\r\nstruct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\npoll_wait(file, &dev->iamthif_cl.rx_wait, wait);\r\nif (dev->iamthif_state == MEI_IAMTHIF_READ_COMPLETE &&\r\ndev->iamthif_fp == file) {\r\nmask |= POLLIN | POLLRDNORM;\r\nmei_amthif_run_next_cmd(dev);\r\n}\r\nreturn mask;\r\n}\r\nint mei_amthif_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,\r\nstruct mei_cl_cb *cmpl_list)\r\n{\r\nint ret;\r\nret = mei_cl_irq_write(cl, cb, cmpl_list);\r\nif (ret)\r\nreturn ret;\r\nif (cb->completed)\r\ncb->status = mei_amthif_read_start(cl, cb->fp);\r\nreturn 0;\r\n}\r\nint mei_amthif_irq_read_msg(struct mei_cl *cl,\r\nstruct mei_msg_hdr *mei_hdr,\r\nstruct mei_cl_cb *cmpl_list)\r\n{\r\nstruct mei_device *dev;\r\nint ret;\r\ndev = cl->dev;\r\nif (dev->iamthif_state != MEI_IAMTHIF_READING) {\r\nmei_irq_discard_msg(dev, mei_hdr);\r\nreturn 0;\r\n}\r\nret = mei_cl_irq_read_msg(cl, mei_hdr, cmpl_list);\r\nif (ret)\r\nreturn ret;\r\nif (!mei_hdr->msg_complete)\r\nreturn 0;\r\ndev_dbg(dev->dev, "completed amthif read.\n ");\r\ndev->iamthif_current_cb = NULL;\r\ndev->iamthif_stall_timer = 0;\r\nreturn 0;\r\n}\r\nvoid mei_amthif_complete(struct mei_cl *cl, struct mei_cl_cb *cb)\r\n{\r\nstruct mei_device *dev = cl->dev;\r\nif (cb->fop_type == MEI_FOP_WRITE) {\r\nif (!cb->status) {\r\ndev->iamthif_stall_timer = MEI_IAMTHIF_STALL_TIMER;\r\nmei_io_cb_free(cb);\r\nreturn;\r\n}\r\nlist_add_tail(&cb->list, &cl->rd_completed);\r\nwake_up_interruptible(&cl->rx_wait);\r\nreturn;\r\n}\r\nif (!dev->iamthif_canceled) {\r\ndev->iamthif_state = MEI_IAMTHIF_READ_COMPLETE;\r\ndev->iamthif_stall_timer = 0;\r\nlist_add_tail(&cb->list, &cl->rd_completed);\r\ndev_dbg(dev->dev, "amthif read completed\n");\r\n} else {\r\nmei_amthif_run_next_cmd(dev);\r\n}\r\ndev_dbg(dev->dev, "completing amthif call back.\n");\r\nwake_up_interruptible(&cl->rx_wait);\r\n}\r\nstatic bool mei_clear_list(struct mei_device *dev,\r\nconst struct file *file, struct list_head *mei_cb_list)\r\n{\r\nstruct mei_cl *cl = &dev->iamthif_cl;\r\nstruct mei_cl_cb *cb, *next;\r\nbool removed = false;\r\nlist_for_each_entry_safe(cb, next, mei_cb_list, list) {\r\nif (file == cb->fp) {\r\nif (dev->iamthif_current_cb == cb) {\r\ndev->iamthif_current_cb = NULL;\r\nmei_hbm_cl_flow_control_req(dev, cl);\r\n}\r\nmei_io_cb_free(cb);\r\nremoved = true;\r\n}\r\n}\r\nreturn removed;\r\n}\r\nstatic bool mei_clear_lists(struct mei_device *dev, const struct file *file)\r\n{\r\nbool removed = false;\r\nstruct mei_cl *cl = &dev->iamthif_cl;\r\nmei_clear_list(dev, file, &dev->amthif_cmd_list.list);\r\nif (mei_clear_list(dev, file, &cl->rd_completed))\r\nremoved = true;\r\nmei_clear_list(dev, file, &dev->ctrl_rd_list.list);\r\nif (mei_clear_list(dev, file, &dev->ctrl_wr_list.list))\r\nremoved = true;\r\nif (mei_clear_list(dev, file, &dev->write_waiting_list.list))\r\nremoved = true;\r\nif (mei_clear_list(dev, file, &dev->write_list.list))\r\nremoved = true;\r\nif (dev->iamthif_current_cb && !removed) {\r\nif (dev->iamthif_current_cb->fp == file) {\r\nmei_io_cb_free(dev->iamthif_current_cb);\r\ndev->iamthif_current_cb = NULL;\r\nremoved = true;\r\n}\r\n}\r\nreturn removed;\r\n}\r\nint mei_amthif_release(struct mei_device *dev, struct file *file)\r\n{\r\nif (dev->iamthif_open_count > 0)\r\ndev->iamthif_open_count--;\r\nif (dev->iamthif_fp == file &&\r\ndev->iamthif_state != MEI_IAMTHIF_IDLE) {\r\ndev_dbg(dev->dev, "amthif canceled iamthif state %d\n",\r\ndev->iamthif_state);\r\ndev->iamthif_canceled = true;\r\nif (dev->iamthif_state == MEI_IAMTHIF_READ_COMPLETE) {\r\ndev_dbg(dev->dev, "run next amthif iamthif cb\n");\r\nmei_amthif_run_next_cmd(dev);\r\n}\r\n}\r\nif (mei_clear_lists(dev, file))\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\nreturn 0;\r\n}
