static struct xvip_graph_entity *\r\nxvip_graph_find_entity(struct xvip_composite_device *xdev,\r\nconst struct device_node *node)\r\n{\r\nstruct xvip_graph_entity *entity;\r\nlist_for_each_entry(entity, &xdev->entities, list) {\r\nif (entity->node == node)\r\nreturn entity;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int xvip_graph_build_one(struct xvip_composite_device *xdev,\r\nstruct xvip_graph_entity *entity)\r\n{\r\nu32 link_flags = MEDIA_LNK_FL_ENABLED;\r\nstruct media_entity *local = entity->entity;\r\nstruct media_entity *remote;\r\nstruct media_pad *local_pad;\r\nstruct media_pad *remote_pad;\r\nstruct xvip_graph_entity *ent;\r\nstruct v4l2_of_link link;\r\nstruct device_node *ep = NULL;\r\nstruct device_node *next;\r\nint ret = 0;\r\ndev_dbg(xdev->dev, "creating links for entity %s\n", local->name);\r\nwhile (1) {\r\nnext = of_graph_get_next_endpoint(entity->node, ep);\r\nif (next == NULL)\r\nbreak;\r\nof_node_put(ep);\r\nep = next;\r\ndev_dbg(xdev->dev, "processing endpoint %s\n", ep->full_name);\r\nret = v4l2_of_parse_link(ep, &link);\r\nif (ret < 0) {\r\ndev_err(xdev->dev, "failed to parse link for %s\n",\r\nep->full_name);\r\ncontinue;\r\n}\r\nif (link.local_port >= local->num_pads) {\r\ndev_err(xdev->dev, "invalid port number %u on %s\n",\r\nlink.local_port, link.local_node->full_name);\r\nv4l2_of_put_link(&link);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nlocal_pad = &local->pads[link.local_port];\r\nif (local_pad->flags & MEDIA_PAD_FL_SINK) {\r\ndev_dbg(xdev->dev, "skipping sink port %s:%u\n",\r\nlink.local_node->full_name, link.local_port);\r\nv4l2_of_put_link(&link);\r\ncontinue;\r\n}\r\nif (link.remote_node == xdev->dev->of_node) {\r\ndev_dbg(xdev->dev, "skipping DMA port %s:%u\n",\r\nlink.local_node->full_name, link.local_port);\r\nv4l2_of_put_link(&link);\r\ncontinue;\r\n}\r\nent = xvip_graph_find_entity(xdev, link.remote_node);\r\nif (ent == NULL) {\r\ndev_err(xdev->dev, "no entity found for %s\n",\r\nlink.remote_node->full_name);\r\nv4l2_of_put_link(&link);\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nremote = ent->entity;\r\nif (link.remote_port >= remote->num_pads) {\r\ndev_err(xdev->dev, "invalid port number %u on %s\n",\r\nlink.remote_port, link.remote_node->full_name);\r\nv4l2_of_put_link(&link);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nremote_pad = &remote->pads[link.remote_port];\r\nv4l2_of_put_link(&link);\r\ndev_dbg(xdev->dev, "creating %s:%u -> %s:%u link\n",\r\nlocal->name, local_pad->index,\r\nremote->name, remote_pad->index);\r\nret = media_create_pad_link(local, local_pad->index,\r\nremote, remote_pad->index,\r\nlink_flags);\r\nif (ret < 0) {\r\ndev_err(xdev->dev,\r\n"failed to create %s:%u -> %s:%u link\n",\r\nlocal->name, local_pad->index,\r\nremote->name, remote_pad->index);\r\nbreak;\r\n}\r\n}\r\nof_node_put(ep);\r\nreturn ret;\r\n}\r\nstatic struct xvip_dma *\r\nxvip_graph_find_dma(struct xvip_composite_device *xdev, unsigned int port)\r\n{\r\nstruct xvip_dma *dma;\r\nlist_for_each_entry(dma, &xdev->dmas, list) {\r\nif (dma->port == port)\r\nreturn dma;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int xvip_graph_build_dma(struct xvip_composite_device *xdev)\r\n{\r\nu32 link_flags = MEDIA_LNK_FL_ENABLED;\r\nstruct device_node *node = xdev->dev->of_node;\r\nstruct media_entity *source;\r\nstruct media_entity *sink;\r\nstruct media_pad *source_pad;\r\nstruct media_pad *sink_pad;\r\nstruct xvip_graph_entity *ent;\r\nstruct v4l2_of_link link;\r\nstruct device_node *ep = NULL;\r\nstruct device_node *next;\r\nstruct xvip_dma *dma;\r\nint ret = 0;\r\ndev_dbg(xdev->dev, "creating links for DMA engines\n");\r\nwhile (1) {\r\nnext = of_graph_get_next_endpoint(node, ep);\r\nif (next == NULL)\r\nbreak;\r\nof_node_put(ep);\r\nep = next;\r\ndev_dbg(xdev->dev, "processing endpoint %s\n", ep->full_name);\r\nret = v4l2_of_parse_link(ep, &link);\r\nif (ret < 0) {\r\ndev_err(xdev->dev, "failed to parse link for %s\n",\r\nep->full_name);\r\ncontinue;\r\n}\r\ndma = xvip_graph_find_dma(xdev, link.local_port);\r\nif (dma == NULL) {\r\ndev_err(xdev->dev, "no DMA engine found for port %u\n",\r\nlink.local_port);\r\nv4l2_of_put_link(&link);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndev_dbg(xdev->dev, "creating link for DMA engine %s\n",\r\ndma->video.name);\r\nent = xvip_graph_find_entity(xdev, link.remote_node);\r\nif (ent == NULL) {\r\ndev_err(xdev->dev, "no entity found for %s\n",\r\nlink.remote_node->full_name);\r\nv4l2_of_put_link(&link);\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nif (link.remote_port >= ent->entity->num_pads) {\r\ndev_err(xdev->dev, "invalid port number %u on %s\n",\r\nlink.remote_port, link.remote_node->full_name);\r\nv4l2_of_put_link(&link);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dma->pad.flags & MEDIA_PAD_FL_SOURCE) {\r\nsource = &dma->video.entity;\r\nsource_pad = &dma->pad;\r\nsink = ent->entity;\r\nsink_pad = &sink->pads[link.remote_port];\r\n} else {\r\nsource = ent->entity;\r\nsource_pad = &source->pads[link.remote_port];\r\nsink = &dma->video.entity;\r\nsink_pad = &dma->pad;\r\n}\r\nv4l2_of_put_link(&link);\r\ndev_dbg(xdev->dev, "creating %s:%u -> %s:%u link\n",\r\nsource->name, source_pad->index,\r\nsink->name, sink_pad->index);\r\nret = media_create_pad_link(source, source_pad->index,\r\nsink, sink_pad->index,\r\nlink_flags);\r\nif (ret < 0) {\r\ndev_err(xdev->dev,\r\n"failed to create %s:%u -> %s:%u link\n",\r\nsource->name, source_pad->index,\r\nsink->name, sink_pad->index);\r\nbreak;\r\n}\r\n}\r\nof_node_put(ep);\r\nreturn ret;\r\n}\r\nstatic int xvip_graph_notify_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nstruct xvip_composite_device *xdev =\r\ncontainer_of(notifier, struct xvip_composite_device, notifier);\r\nstruct xvip_graph_entity *entity;\r\nint ret;\r\ndev_dbg(xdev->dev, "notify complete, all subdevs registered\n");\r\nlist_for_each_entry(entity, &xdev->entities, list) {\r\nret = xvip_graph_build_one(xdev, entity);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = xvip_graph_build_dma(xdev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_device_register_subdev_nodes(&xdev->v4l2_dev);\r\nif (ret < 0)\r\ndev_err(xdev->dev, "failed to register subdev nodes\n");\r\nreturn media_device_register(&xdev->media_dev);\r\n}\r\nstatic int xvip_graph_notify_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct xvip_composite_device *xdev =\r\ncontainer_of(notifier, struct xvip_composite_device, notifier);\r\nstruct xvip_graph_entity *entity;\r\nlist_for_each_entry(entity, &xdev->entities, list) {\r\nif (entity->node != subdev->dev->of_node)\r\ncontinue;\r\nif (entity->subdev) {\r\ndev_err(xdev->dev, "duplicate subdev for node %s\n",\r\nentity->node->full_name);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(xdev->dev, "subdev %s bound\n", subdev->name);\r\nentity->entity = &subdev->entity;\r\nentity->subdev = subdev;\r\nreturn 0;\r\n}\r\ndev_err(xdev->dev, "no entity for subdev %s\n", subdev->name);\r\nreturn -EINVAL;\r\n}\r\nstatic int xvip_graph_parse_one(struct xvip_composite_device *xdev,\r\nstruct device_node *node)\r\n{\r\nstruct xvip_graph_entity *entity;\r\nstruct device_node *remote;\r\nstruct device_node *ep = NULL;\r\nint ret = 0;\r\ndev_dbg(xdev->dev, "parsing node %s\n", node->full_name);\r\nwhile (1) {\r\nep = of_graph_get_next_endpoint(node, ep);\r\nif (ep == NULL)\r\nbreak;\r\ndev_dbg(xdev->dev, "handling endpoint %s\n", ep->full_name);\r\nremote = of_graph_get_remote_port_parent(ep);\r\nif (remote == NULL) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (remote == xdev->dev->of_node ||\r\nxvip_graph_find_entity(xdev, remote)) {\r\nof_node_put(remote);\r\ncontinue;\r\n}\r\nentity = devm_kzalloc(xdev->dev, sizeof(*entity), GFP_KERNEL);\r\nif (entity == NULL) {\r\nof_node_put(remote);\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nentity->node = remote;\r\nentity->asd.match_type = V4L2_ASYNC_MATCH_OF;\r\nentity->asd.match.of.node = remote;\r\nlist_add_tail(&entity->list, &xdev->entities);\r\nxdev->num_subdevs++;\r\n}\r\nof_node_put(ep);\r\nreturn ret;\r\n}\r\nstatic int xvip_graph_parse(struct xvip_composite_device *xdev)\r\n{\r\nstruct xvip_graph_entity *entity;\r\nint ret;\r\nret = xvip_graph_parse_one(xdev, xdev->dev->of_node);\r\nif (ret < 0)\r\nreturn 0;\r\nlist_for_each_entry(entity, &xdev->entities, list) {\r\nret = xvip_graph_parse_one(xdev, entity->node);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int xvip_graph_dma_init_one(struct xvip_composite_device *xdev,\r\nstruct device_node *node)\r\n{\r\nstruct xvip_dma *dma;\r\nenum v4l2_buf_type type;\r\nconst char *direction;\r\nunsigned int index;\r\nint ret;\r\nret = of_property_read_string(node, "direction", &direction);\r\nif (ret < 0)\r\nreturn ret;\r\nif (strcmp(direction, "input") == 0)\r\ntype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nelse if (strcmp(direction, "output") == 0)\r\ntype = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nelse\r\nreturn -EINVAL;\r\nof_property_read_u32(node, "reg", &index);\r\ndma = devm_kzalloc(xdev->dev, sizeof(*dma), GFP_KERNEL);\r\nif (dma == NULL)\r\nreturn -ENOMEM;\r\nret = xvip_dma_init(xdev, dma, type, index);\r\nif (ret < 0) {\r\ndev_err(xdev->dev, "%s initialization failed\n",\r\nnode->full_name);\r\nreturn ret;\r\n}\r\nlist_add_tail(&dma->list, &xdev->dmas);\r\nxdev->v4l2_caps |= type == V4L2_BUF_TYPE_VIDEO_CAPTURE\r\n? V4L2_CAP_VIDEO_CAPTURE : V4L2_CAP_VIDEO_OUTPUT;\r\nreturn 0;\r\n}\r\nstatic int xvip_graph_dma_init(struct xvip_composite_device *xdev)\r\n{\r\nstruct device_node *ports;\r\nstruct device_node *port;\r\nint ret;\r\nports = of_get_child_by_name(xdev->dev->of_node, "ports");\r\nif (ports == NULL) {\r\ndev_err(xdev->dev, "ports node not present\n");\r\nreturn -EINVAL;\r\n}\r\nfor_each_child_of_node(ports, port) {\r\nret = xvip_graph_dma_init_one(xdev, port);\r\nif (ret < 0) {\r\nof_node_put(port);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void xvip_graph_cleanup(struct xvip_composite_device *xdev)\r\n{\r\nstruct xvip_graph_entity *entityp;\r\nstruct xvip_graph_entity *entity;\r\nstruct xvip_dma *dmap;\r\nstruct xvip_dma *dma;\r\nv4l2_async_notifier_unregister(&xdev->notifier);\r\nlist_for_each_entry_safe(entity, entityp, &xdev->entities, list) {\r\nof_node_put(entity->node);\r\nlist_del(&entity->list);\r\n}\r\nlist_for_each_entry_safe(dma, dmap, &xdev->dmas, list) {\r\nxvip_dma_cleanup(dma);\r\nlist_del(&dma->list);\r\n}\r\n}\r\nstatic int xvip_graph_init(struct xvip_composite_device *xdev)\r\n{\r\nstruct xvip_graph_entity *entity;\r\nstruct v4l2_async_subdev **subdevs = NULL;\r\nunsigned int num_subdevs;\r\nunsigned int i;\r\nint ret;\r\nret = xvip_graph_dma_init(xdev);\r\nif (ret < 0) {\r\ndev_err(xdev->dev, "DMA initialization failed\n");\r\ngoto done;\r\n}\r\nret = xvip_graph_parse(xdev);\r\nif (ret < 0) {\r\ndev_err(xdev->dev, "graph parsing failed\n");\r\ngoto done;\r\n}\r\nif (!xdev->num_subdevs) {\r\ndev_err(xdev->dev, "no subdev found in graph\n");\r\ngoto done;\r\n}\r\nnum_subdevs = xdev->num_subdevs;\r\nsubdevs = devm_kzalloc(xdev->dev, sizeof(*subdevs) * num_subdevs,\r\nGFP_KERNEL);\r\nif (subdevs == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\ni = 0;\r\nlist_for_each_entry(entity, &xdev->entities, list)\r\nsubdevs[i++] = &entity->asd;\r\nxdev->notifier.subdevs = subdevs;\r\nxdev->notifier.num_subdevs = num_subdevs;\r\nxdev->notifier.bound = xvip_graph_notify_bound;\r\nxdev->notifier.complete = xvip_graph_notify_complete;\r\nret = v4l2_async_notifier_register(&xdev->v4l2_dev, &xdev->notifier);\r\nif (ret < 0) {\r\ndev_err(xdev->dev, "notifier registration failed\n");\r\ngoto done;\r\n}\r\nret = 0;\r\ndone:\r\nif (ret < 0)\r\nxvip_graph_cleanup(xdev);\r\nreturn ret;\r\n}\r\nstatic void xvip_composite_v4l2_cleanup(struct xvip_composite_device *xdev)\r\n{\r\nv4l2_device_unregister(&xdev->v4l2_dev);\r\nmedia_device_unregister(&xdev->media_dev);\r\nmedia_device_cleanup(&xdev->media_dev);\r\n}\r\nstatic int xvip_composite_v4l2_init(struct xvip_composite_device *xdev)\r\n{\r\nint ret;\r\nxdev->media_dev.dev = xdev->dev;\r\nstrlcpy(xdev->media_dev.model, "Xilinx Video Composite Device",\r\nsizeof(xdev->media_dev.model));\r\nxdev->media_dev.hw_revision = 0;\r\nmedia_device_init(&xdev->media_dev);\r\nxdev->v4l2_dev.mdev = &xdev->media_dev;\r\nret = v4l2_device_register(xdev->dev, &xdev->v4l2_dev);\r\nif (ret < 0) {\r\ndev_err(xdev->dev, "V4L2 device registration failed (%d)\n",\r\nret);\r\nmedia_device_cleanup(&xdev->media_dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xvip_composite_probe(struct platform_device *pdev)\r\n{\r\nstruct xvip_composite_device *xdev;\r\nint ret;\r\nxdev = devm_kzalloc(&pdev->dev, sizeof(*xdev), GFP_KERNEL);\r\nif (!xdev)\r\nreturn -ENOMEM;\r\nxdev->dev = &pdev->dev;\r\nINIT_LIST_HEAD(&xdev->entities);\r\nINIT_LIST_HEAD(&xdev->dmas);\r\nret = xvip_composite_v4l2_init(xdev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = xvip_graph_init(xdev);\r\nif (ret < 0)\r\ngoto error;\r\nplatform_set_drvdata(pdev, xdev);\r\ndev_info(xdev->dev, "device registered\n");\r\nreturn 0;\r\nerror:\r\nxvip_composite_v4l2_cleanup(xdev);\r\nreturn ret;\r\n}\r\nstatic int xvip_composite_remove(struct platform_device *pdev)\r\n{\r\nstruct xvip_composite_device *xdev = platform_get_drvdata(pdev);\r\nxvip_graph_cleanup(xdev);\r\nxvip_composite_v4l2_cleanup(xdev);\r\nreturn 0;\r\n}
