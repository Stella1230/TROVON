static int raw_to_mcelsius(struct mtk_thermal *mt, int sensno, s32 raw)\r\n{\r\ns32 tmp;\r\nraw &= 0xfff;\r\ntmp = 203450520 << 3;\r\ntmp /= 165 + mt->o_slope;\r\ntmp /= 10000 + mt->adc_ge;\r\ntmp *= raw - mt->vts[sensno] - 3350;\r\ntmp >>= 3;\r\nreturn mt->degc_cali * 500 - tmp;\r\n}\r\nstatic void mtk_thermal_get_bank(struct mtk_thermal_bank *bank)\r\n{\r\nstruct mtk_thermal *mt = bank->mt;\r\nu32 val;\r\nmutex_lock(&mt->lock);\r\nval = readl(mt->thermal_base + PTPCORESEL);\r\nval &= ~0xf;\r\nval |= bank->id;\r\nwritel(val, mt->thermal_base + PTPCORESEL);\r\n}\r\nstatic void mtk_thermal_put_bank(struct mtk_thermal_bank *bank)\r\n{\r\nstruct mtk_thermal *mt = bank->mt;\r\nmutex_unlock(&mt->lock);\r\n}\r\nstatic int mtk_thermal_bank_temperature(struct mtk_thermal_bank *bank)\r\n{\r\nstruct mtk_thermal *mt = bank->mt;\r\nint i, temp = INT_MIN, max = INT_MIN;\r\nu32 raw;\r\nfor (i = 0; i < bank_data[bank->id].num_sensors; i++) {\r\nraw = readl(mt->thermal_base + sensing_points[i].msr);\r\ntemp = raw_to_mcelsius(mt, bank_data[bank->id].sensors[i], raw);\r\nif (temp > 200000)\r\ntemp = 0;\r\nif (temp > max)\r\nmax = temp;\r\n}\r\nreturn max;\r\n}\r\nstatic int mtk_read_temp(void *data, int *temperature)\r\n{\r\nstruct mtk_thermal *mt = data;\r\nint i;\r\nint tempmax = INT_MIN;\r\nfor (i = 0; i < MT8173_NUM_ZONES; i++) {\r\nstruct mtk_thermal_bank *bank = &mt->banks[i];\r\nmtk_thermal_get_bank(bank);\r\ntempmax = max(tempmax, mtk_thermal_bank_temperature(bank));\r\nmtk_thermal_put_bank(bank);\r\n}\r\n*temperature = tempmax;\r\nreturn 0;\r\n}\r\nstatic void mtk_thermal_init_bank(struct mtk_thermal *mt, int num,\r\nu32 apmixed_phys_base, u32 auxadc_phys_base)\r\n{\r\nstruct mtk_thermal_bank *bank = &mt->banks[num];\r\nconst struct mtk_thermal_bank_cfg *cfg = &bank_data[num];\r\nint i;\r\nbank->id = num;\r\nbank->mt = mt;\r\nmtk_thermal_get_bank(bank);\r\nwritel(TEMP_MONCTL1_PERIOD_UNIT(12), mt->thermal_base + TEMP_MONCTL1);\r\nwritel(TEMP_MONCTL2_FILTER_INTERVAL(1) |\r\nTEMP_MONCTL2_SENSOR_INTERVAL(429),\r\nmt->thermal_base + TEMP_MONCTL2);\r\nwritel(TEMP_AHBPOLL_ADC_POLL_INTERVAL(768),\r\nmt->thermal_base + TEMP_AHBPOLL);\r\nwritel(0x0, mt->thermal_base + TEMP_MSRCTL0);\r\nwritel(0xffffffff, mt->thermal_base + TEMP_AHBTO);\r\nwritel(0x0, mt->thermal_base + TEMP_MONIDET0);\r\nwritel(0x0, mt->thermal_base + TEMP_MONIDET1);\r\nwritel(BIT(MT8173_TEMP_AUXADC_CHANNEL), mt->thermal_base + TEMP_ADCMUX);\r\nwritel(auxadc_phys_base + AUXADC_CON1_CLR_V,\r\nmt->thermal_base + TEMP_ADCMUXADDR);\r\nwritel(apmixed_phys_base + APMIXED_SYS_TS_CON1,\r\nmt->thermal_base + TEMP_PNPMUXADDR);\r\nwritel(BIT(MT8173_TEMP_AUXADC_CHANNEL), mt->thermal_base + TEMP_ADCEN);\r\nwritel(auxadc_phys_base + AUXADC_CON1_SET_V,\r\nmt->thermal_base + TEMP_ADCENADDR);\r\nwritel(auxadc_phys_base + AUXADC_DATA(MT8173_TEMP_AUXADC_CHANNEL),\r\nmt->thermal_base + TEMP_ADCVALIDADDR);\r\nwritel(auxadc_phys_base + AUXADC_DATA(MT8173_TEMP_AUXADC_CHANNEL),\r\nmt->thermal_base + TEMP_ADCVOLTADDR);\r\nwritel(0x0, mt->thermal_base + TEMP_RDCTRL);\r\nwritel(TEMP_ADCVALIDMASK_VALID_HIGH | TEMP_ADCVALIDMASK_VALID_POS(12),\r\nmt->thermal_base + TEMP_ADCVALIDMASK);\r\nwritel(0x0, mt->thermal_base + TEMP_ADCVOLTAGESHIFT);\r\nwritel(TEMP_ADCWRITECTRL_ADC_MUX_WRITE,\r\nmt->thermal_base + TEMP_ADCWRITECTRL);\r\nfor (i = 0; i < cfg->num_sensors; i++)\r\nwritel(sensor_mux_values[cfg->sensors[i]],\r\nmt->thermal_base + sensing_points[i].adcpnp);\r\nwritel((1 << cfg->num_sensors) - 1, mt->thermal_base + TEMP_MONCTL0);\r\nwritel(TEMP_ADCWRITECTRL_ADC_PNP_WRITE |\r\nTEMP_ADCWRITECTRL_ADC_MUX_WRITE,\r\nmt->thermal_base + TEMP_ADCWRITECTRL);\r\nmtk_thermal_put_bank(bank);\r\n}\r\nstatic u64 of_get_phys_base(struct device_node *np)\r\n{\r\nu64 size64;\r\nconst __be32 *regaddr_p;\r\nregaddr_p = of_get_address(np, 0, &size64, NULL);\r\nif (!regaddr_p)\r\nreturn OF_BAD_ADDR;\r\nreturn of_translate_address(np, regaddr_p);\r\n}\r\nstatic int mtk_thermal_get_calibration_data(struct device *dev,\r\nstruct mtk_thermal *mt)\r\n{\r\nstruct nvmem_cell *cell;\r\nu32 *buf;\r\nsize_t len;\r\nint i, ret = 0;\r\nmt->adc_ge = 512;\r\nfor (i = 0; i < MT8173_NUM_SENSORS; i++)\r\nmt->vts[i] = 260;\r\nmt->degc_cali = 40;\r\nmt->o_slope = 0;\r\ncell = nvmem_cell_get(dev, "calibration-data");\r\nif (IS_ERR(cell)) {\r\nif (PTR_ERR(cell) == -EPROBE_DEFER)\r\nreturn PTR_ERR(cell);\r\nreturn 0;\r\n}\r\nbuf = (u32 *)nvmem_cell_read(cell, &len);\r\nnvmem_cell_put(cell);\r\nif (IS_ERR(buf))\r\nreturn PTR_ERR(buf);\r\nif (len < 3 * sizeof(u32)) {\r\ndev_warn(dev, "invalid calibration data\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (buf[0] & MT8173_CALIB_BUF0_VALID) {\r\nmt->adc_ge = MT8173_CALIB_BUF1_ADC_GE(buf[1]);\r\nmt->vts[MT8173_TS1] = MT8173_CALIB_BUF0_VTS_TS1(buf[0]);\r\nmt->vts[MT8173_TS2] = MT8173_CALIB_BUF0_VTS_TS2(buf[0]);\r\nmt->vts[MT8173_TS3] = MT8173_CALIB_BUF1_VTS_TS3(buf[1]);\r\nmt->vts[MT8173_TS4] = MT8173_CALIB_BUF2_VTS_TS4(buf[2]);\r\nmt->vts[MT8173_TSABB] = MT8173_CALIB_BUF2_VTS_TSABB(buf[2]);\r\nmt->degc_cali = MT8173_CALIB_BUF0_DEGC_CALI(buf[0]);\r\nmt->o_slope = MT8173_CALIB_BUF0_O_SLOPE(buf[0]);\r\n} else {\r\ndev_info(dev, "Device not calibrated, using default calibration values\n");\r\n}\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int mtk_thermal_probe(struct platform_device *pdev)\r\n{\r\nint ret, i;\r\nstruct device_node *auxadc, *apmixedsys, *np = pdev->dev.of_node;\r\nstruct mtk_thermal *mt;\r\nstruct resource *res;\r\nu64 auxadc_phys_base, apmixed_phys_base;\r\nmt = devm_kzalloc(&pdev->dev, sizeof(*mt), GFP_KERNEL);\r\nif (!mt)\r\nreturn -ENOMEM;\r\nmt->clk_peri_therm = devm_clk_get(&pdev->dev, "therm");\r\nif (IS_ERR(mt->clk_peri_therm))\r\nreturn PTR_ERR(mt->clk_peri_therm);\r\nmt->clk_auxadc = devm_clk_get(&pdev->dev, "auxadc");\r\nif (IS_ERR(mt->clk_auxadc))\r\nreturn PTR_ERR(mt->clk_auxadc);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmt->thermal_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mt->thermal_base))\r\nreturn PTR_ERR(mt->thermal_base);\r\nret = mtk_thermal_get_calibration_data(&pdev->dev, mt);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&mt->lock);\r\nmt->dev = &pdev->dev;\r\nauxadc = of_parse_phandle(np, "mediatek,auxadc", 0);\r\nif (!auxadc) {\r\ndev_err(&pdev->dev, "missing auxadc node\n");\r\nreturn -ENODEV;\r\n}\r\nauxadc_phys_base = of_get_phys_base(auxadc);\r\nof_node_put(auxadc);\r\nif (auxadc_phys_base == OF_BAD_ADDR) {\r\ndev_err(&pdev->dev, "Can't get auxadc phys address\n");\r\nreturn -EINVAL;\r\n}\r\napmixedsys = of_parse_phandle(np, "mediatek,apmixedsys", 0);\r\nif (!apmixedsys) {\r\ndev_err(&pdev->dev, "missing apmixedsys node\n");\r\nreturn -ENODEV;\r\n}\r\napmixed_phys_base = of_get_phys_base(apmixedsys);\r\nof_node_put(apmixedsys);\r\nif (apmixed_phys_base == OF_BAD_ADDR) {\r\ndev_err(&pdev->dev, "Can't get auxadc phys address\n");\r\nreturn -EINVAL;\r\n}\r\nret = clk_prepare_enable(mt->clk_auxadc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't enable auxadc clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = device_reset(&pdev->dev);\r\nif (ret)\r\ngoto err_disable_clk_auxadc;\r\nret = clk_prepare_enable(mt->clk_peri_therm);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't enable peri clk: %d\n", ret);\r\ngoto err_disable_clk_auxadc;\r\n}\r\nfor (i = 0; i < MT8173_NUM_ZONES; i++)\r\nmtk_thermal_init_bank(mt, i, apmixed_phys_base,\r\nauxadc_phys_base);\r\nplatform_set_drvdata(pdev, mt);\r\ndevm_thermal_zone_of_sensor_register(&pdev->dev, 0, mt,\r\n&mtk_thermal_ops);\r\nreturn 0;\r\nerr_disable_clk_auxadc:\r\nclk_disable_unprepare(mt->clk_auxadc);\r\nreturn ret;\r\n}\r\nstatic int mtk_thermal_remove(struct platform_device *pdev)\r\n{\r\nstruct mtk_thermal *mt = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(mt->clk_peri_therm);\r\nclk_disable_unprepare(mt->clk_auxadc);\r\nreturn 0;\r\n}
