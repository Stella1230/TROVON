static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct crypto_sparc64_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nu32 *flags = &tfm->crt_flags;\r\nswitch (key_len) {\r\ncase AES_KEYSIZE_128:\r\nctx->expanded_key_length = 0xb0;\r\nctx->ops = &aes128_ops;\r\nbreak;\r\ncase AES_KEYSIZE_192:\r\nctx->expanded_key_length = 0xd0;\r\nctx->ops = &aes192_ops;\r\nbreak;\r\ncase AES_KEYSIZE_256:\r\nctx->expanded_key_length = 0xf0;\r\nctx->ops = &aes256_ops;\r\nbreak;\r\ndefault:\r\n*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\naes_sparc64_key_expand((const u32 *)in_key, &ctx->key[0], key_len);\r\nctx->key_length = key_len;\r\nreturn 0;\r\n}\r\nstatic void aes_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct crypto_sparc64_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nctx->ops->encrypt(&ctx->key[0], (const u32 *) src, (u32 *) dst);\r\n}\r\nstatic void aes_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct crypto_sparc64_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nctx->ops->decrypt(&ctx->key[0], (const u32 *) src, (u32 *) dst);\r\n}\r\nstatic int ecb_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct crypto_sparc64_aes_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nctx->ops->load_encrypt_keys(&ctx->key[0]);\r\nwhile ((nbytes = walk.nbytes)) {\r\nunsigned int block_len = nbytes & AES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\nctx->ops->ecb_encrypt(&ctx->key[0],\r\n(const u64 *)walk.src.virt.addr,\r\n(u64 *) walk.dst.virt.addr,\r\nblock_len);\r\n}\r\nnbytes &= AES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic int ecb_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct crypto_sparc64_aes_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nu64 *key_end;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nctx->ops->load_decrypt_keys(&ctx->key[0]);\r\nkey_end = &ctx->key[ctx->expanded_key_length / sizeof(u64)];\r\nwhile ((nbytes = walk.nbytes)) {\r\nunsigned int block_len = nbytes & AES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\nctx->ops->ecb_decrypt(key_end,\r\n(const u64 *) walk.src.virt.addr,\r\n(u64 *) walk.dst.virt.addr, block_len);\r\n}\r\nnbytes &= AES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic int cbc_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct crypto_sparc64_aes_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nctx->ops->load_encrypt_keys(&ctx->key[0]);\r\nwhile ((nbytes = walk.nbytes)) {\r\nunsigned int block_len = nbytes & AES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\nctx->ops->cbc_encrypt(&ctx->key[0],\r\n(const u64 *)walk.src.virt.addr,\r\n(u64 *) walk.dst.virt.addr,\r\nblock_len, (u64 *) walk.iv);\r\n}\r\nnbytes &= AES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic int cbc_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct crypto_sparc64_aes_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nu64 *key_end;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nctx->ops->load_decrypt_keys(&ctx->key[0]);\r\nkey_end = &ctx->key[ctx->expanded_key_length / sizeof(u64)];\r\nwhile ((nbytes = walk.nbytes)) {\r\nunsigned int block_len = nbytes & AES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\nctx->ops->cbc_decrypt(key_end,\r\n(const u64 *) walk.src.virt.addr,\r\n(u64 *) walk.dst.virt.addr,\r\nblock_len, (u64 *) walk.iv);\r\n}\r\nnbytes &= AES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic void ctr_crypt_final(struct crypto_sparc64_aes_ctx *ctx,\r\nstruct blkcipher_walk *walk)\r\n{\r\nu8 *ctrblk = walk->iv;\r\nu64 keystream[AES_BLOCK_SIZE / sizeof(u64)];\r\nu8 *src = walk->src.virt.addr;\r\nu8 *dst = walk->dst.virt.addr;\r\nunsigned int nbytes = walk->nbytes;\r\nctx->ops->ecb_encrypt(&ctx->key[0], (const u64 *)ctrblk,\r\nkeystream, AES_BLOCK_SIZE);\r\ncrypto_xor((u8 *) keystream, src, nbytes);\r\nmemcpy(dst, keystream, nbytes);\r\ncrypto_inc(ctrblk, AES_BLOCK_SIZE);\r\n}\r\nstatic int ctr_crypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct crypto_sparc64_aes_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt_block(desc, &walk, AES_BLOCK_SIZE);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nctx->ops->load_encrypt_keys(&ctx->key[0]);\r\nwhile ((nbytes = walk.nbytes) >= AES_BLOCK_SIZE) {\r\nunsigned int block_len = nbytes & AES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\nctx->ops->ctr_crypt(&ctx->key[0],\r\n(const u64 *)walk.src.virt.addr,\r\n(u64 *) walk.dst.virt.addr,\r\nblock_len, (u64 *) walk.iv);\r\n}\r\nnbytes &= AES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nif (walk.nbytes) {\r\nctr_crypt_final(ctx, &walk);\r\nerr = blkcipher_walk_done(desc, &walk, 0);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic bool __init sparc64_has_aes_opcode(void)\r\n{\r\nunsigned long cfr;\r\nif (!(sparc64_elf_hwcap & HWCAP_SPARC_CRYPTO))\r\nreturn false;\r\n__asm__ __volatile__("rd %%asr26, %0" : "=r" (cfr));\r\nif (!(cfr & CFR_AES))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int __init aes_sparc64_mod_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(algs); i++)\r\nINIT_LIST_HEAD(&algs[i].cra_list);\r\nif (sparc64_has_aes_opcode()) {\r\npr_info("Using sparc64 aes opcodes optimized AES implementation\n");\r\nreturn crypto_register_algs(algs, ARRAY_SIZE(algs));\r\n}\r\npr_info("sparc64 aes opcodes not available.\n");\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit aes_sparc64_mod_fini(void)\r\n{\r\ncrypto_unregister_algs(algs, ARRAY_SIZE(algs));\r\n}
