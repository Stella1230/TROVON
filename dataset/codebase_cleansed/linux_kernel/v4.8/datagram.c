static bool ipv6_mapped_addr_any(const struct in6_addr *a)\r\n{\r\nreturn ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);\r\n}\r\nstatic void ip6_datagram_flow_key_init(struct flowi6 *fl6, struct sock *sk)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nmemset(fl6, 0, sizeof(*fl6));\r\nfl6->flowi6_proto = sk->sk_protocol;\r\nfl6->daddr = sk->sk_v6_daddr;\r\nfl6->saddr = np->saddr;\r\nfl6->flowi6_oif = sk->sk_bound_dev_if;\r\nfl6->flowi6_mark = sk->sk_mark;\r\nfl6->fl6_dport = inet->inet_dport;\r\nfl6->fl6_sport = inet->inet_sport;\r\nfl6->flowlabel = np->flow_label;\r\nif (!fl6->flowi6_oif)\r\nfl6->flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;\r\nif (!fl6->flowi6_oif && ipv6_addr_is_multicast(&fl6->daddr))\r\nfl6->flowi6_oif = np->mcast_oif;\r\nsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\r\n}\r\nint ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr)\r\n{\r\nstruct ip6_flowlabel *flowlabel = NULL;\r\nstruct in6_addr *final_p, final;\r\nstruct ipv6_txoptions *opt;\r\nstruct dst_entry *dst;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct flowi6 fl6;\r\nint err = 0;\r\nif (np->sndflow && (np->flow_label & IPV6_FLOWLABEL_MASK)) {\r\nflowlabel = fl6_sock_lookup(sk, np->flow_label);\r\nif (!flowlabel)\r\nreturn -EINVAL;\r\n}\r\nip6_datagram_flow_key_init(&fl6, sk);\r\nrcu_read_lock();\r\nopt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);\r\nfinal_p = fl6_update_dst(&fl6, opt, &final);\r\nrcu_read_unlock();\r\ndst = ip6_dst_lookup_flow(sk, &fl6, final_p);\r\nif (IS_ERR(dst)) {\r\nerr = PTR_ERR(dst);\r\ngoto out;\r\n}\r\nif (fix_sk_saddr) {\r\nif (ipv6_addr_any(&np->saddr))\r\nnp->saddr = fl6.saddr;\r\nif (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {\r\nsk->sk_v6_rcv_saddr = fl6.saddr;\r\ninet->inet_rcv_saddr = LOOPBACK4_IPV6;\r\nif (sk->sk_prot->rehash)\r\nsk->sk_prot->rehash(sk);\r\n}\r\n}\r\nip6_dst_store(sk, dst,\r\nipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?\r\n&sk->sk_v6_daddr : NULL,\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nipv6_addr_equal(&fl6.saddr, &np->saddr) ?\r\n&np->saddr :\r\n#endif\r\nNULL);\r\nout:\r\nfl6_sock_release(flowlabel);\r\nreturn err;\r\n}\r\nvoid ip6_datagram_release_cb(struct sock *sk)\r\n{\r\nstruct dst_entry *dst;\r\nif (ipv6_addr_v4mapped(&sk->sk_v6_daddr))\r\nreturn;\r\nrcu_read_lock();\r\ndst = __sk_dst_get(sk);\r\nif (!dst || !dst->obsolete ||\r\ndst->ops->check(dst, inet6_sk(sk)->dst_cookie)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nrcu_read_unlock();\r\nip6_datagram_dst_update(sk, false);\r\n}\r\nstatic int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct in6_addr *daddr;\r\nint addr_type;\r\nint err;\r\n__be32 fl6_flowlabel = 0;\r\nif (usin->sin6_family == AF_INET) {\r\nif (__ipv6_only_sock(sk))\r\nreturn -EAFNOSUPPORT;\r\nerr = __ip4_datagram_connect(sk, uaddr, addr_len);\r\ngoto ipv4_connected;\r\n}\r\nif (addr_len < SIN6_LEN_RFC2133)\r\nreturn -EINVAL;\r\nif (usin->sin6_family != AF_INET6)\r\nreturn -EAFNOSUPPORT;\r\nif (np->sndflow)\r\nfl6_flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;\r\naddr_type = ipv6_addr_type(&usin->sin6_addr);\r\nif (addr_type == IPV6_ADDR_ANY) {\r\nusin->sin6_addr.s6_addr[15] = 0x01;\r\n}\r\ndaddr = &usin->sin6_addr;\r\nif (addr_type == IPV6_ADDR_MAPPED) {\r\nstruct sockaddr_in sin;\r\nif (__ipv6_only_sock(sk)) {\r\nerr = -ENETUNREACH;\r\ngoto out;\r\n}\r\nsin.sin_family = AF_INET;\r\nsin.sin_addr.s_addr = daddr->s6_addr32[3];\r\nsin.sin_port = usin->sin6_port;\r\nerr = __ip4_datagram_connect(sk,\r\n(struct sockaddr *) &sin,\r\nsizeof(sin));\r\nipv4_connected:\r\nif (err)\r\ngoto out;\r\nipv6_addr_set_v4mapped(inet->inet_daddr, &sk->sk_v6_daddr);\r\nif (ipv6_addr_any(&np->saddr) ||\r\nipv6_mapped_addr_any(&np->saddr))\r\nipv6_addr_set_v4mapped(inet->inet_saddr, &np->saddr);\r\nif (ipv6_addr_any(&sk->sk_v6_rcv_saddr) ||\r\nipv6_mapped_addr_any(&sk->sk_v6_rcv_saddr)) {\r\nipv6_addr_set_v4mapped(inet->inet_rcv_saddr,\r\n&sk->sk_v6_rcv_saddr);\r\nif (sk->sk_prot->rehash)\r\nsk->sk_prot->rehash(sk);\r\n}\r\ngoto out;\r\n}\r\nif (__ipv6_addr_needs_scope_id(addr_type)) {\r\nif (addr_len >= sizeof(struct sockaddr_in6) &&\r\nusin->sin6_scope_id) {\r\nif (sk->sk_bound_dev_if &&\r\nsk->sk_bound_dev_if != usin->sin6_scope_id) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nsk->sk_bound_dev_if = usin->sin6_scope_id;\r\n}\r\nif (!sk->sk_bound_dev_if && (addr_type & IPV6_ADDR_MULTICAST))\r\nsk->sk_bound_dev_if = np->mcast_oif;\r\nif (!sk->sk_bound_dev_if) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nsk->sk_v6_daddr = *daddr;\r\nnp->flow_label = fl6_flowlabel;\r\ninet->inet_dport = usin->sin6_port;\r\nerr = ip6_datagram_dst_update(sk, true);\r\nif (err)\r\ngoto out;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nsk_set_txhash(sk);\r\nout:\r\nreturn err;\r\n}\r\nint ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\r\n{\r\nint res;\r\nlock_sock(sk);\r\nres = __ip6_datagram_connect(sk, uaddr, addr_len);\r\nrelease_sock(sk);\r\nreturn res;\r\n}\r\nint ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *uaddr,\r\nint addr_len)\r\n{\r\nDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, uaddr);\r\nif (sin6->sin6_family != AF_INET6)\r\nreturn -EAFNOSUPPORT;\r\nreturn ip6_datagram_connect(sk, uaddr, addr_len);\r\n}\r\nvoid ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\r\n__be16 port, u32 info, u8 *payload)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct icmp6hdr *icmph = icmp6_hdr(skb);\r\nstruct sock_exterr_skb *serr;\r\nif (!np->recverr)\r\nreturn;\r\nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb->protocol = htons(ETH_P_IPV6);\r\nserr = SKB_EXT_ERR(skb);\r\nserr->ee.ee_errno = err;\r\nserr->ee.ee_origin = SO_EE_ORIGIN_ICMP6;\r\nserr->ee.ee_type = icmph->icmp6_type;\r\nserr->ee.ee_code = icmph->icmp6_code;\r\nserr->ee.ee_pad = 0;\r\nserr->ee.ee_info = info;\r\nserr->ee.ee_data = 0;\r\nserr->addr_offset = (u8 *)&(((struct ipv6hdr *)(icmph + 1))->daddr) -\r\nskb_network_header(skb);\r\nserr->port = port;\r\n__skb_pull(skb, payload - skb->data);\r\nskb_reset_transport_header(skb);\r\nif (sock_queue_err_skb(sk, skb))\r\nkfree_skb(skb);\r\n}\r\nvoid ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info)\r\n{\r\nconst struct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct sock_exterr_skb *serr;\r\nstruct ipv6hdr *iph;\r\nstruct sk_buff *skb;\r\nif (!np->recverr)\r\nreturn;\r\nskb = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb->protocol = htons(ETH_P_IPV6);\r\nskb_put(skb, sizeof(struct ipv6hdr));\r\nskb_reset_network_header(skb);\r\niph = ipv6_hdr(skb);\r\niph->daddr = fl6->daddr;\r\nserr = SKB_EXT_ERR(skb);\r\nserr->ee.ee_errno = err;\r\nserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\r\nserr->ee.ee_type = 0;\r\nserr->ee.ee_code = 0;\r\nserr->ee.ee_pad = 0;\r\nserr->ee.ee_info = info;\r\nserr->ee.ee_data = 0;\r\nserr->addr_offset = (u8 *)&iph->daddr - skb_network_header(skb);\r\nserr->port = fl6->fl6_dport;\r\n__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\r\nskb_reset_transport_header(skb);\r\nif (sock_queue_err_skb(sk, skb))\r\nkfree_skb(skb);\r\n}\r\nvoid ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6hdr *iph;\r\nstruct sk_buff *skb;\r\nstruct ip6_mtuinfo *mtu_info;\r\nif (!np->rxopt.bits.rxpmtu)\r\nreturn;\r\nskb = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_put(skb, sizeof(struct ipv6hdr));\r\nskb_reset_network_header(skb);\r\niph = ipv6_hdr(skb);\r\niph->daddr = fl6->daddr;\r\nmtu_info = IP6CBMTU(skb);\r\nmtu_info->ip6m_mtu = mtu;\r\nmtu_info->ip6m_addr.sin6_family = AF_INET6;\r\nmtu_info->ip6m_addr.sin6_port = 0;\r\nmtu_info->ip6m_addr.sin6_flowinfo = 0;\r\nmtu_info->ip6m_addr.sin6_scope_id = fl6->flowi6_oif;\r\nmtu_info->ip6m_addr.sin6_addr = ipv6_hdr(skb)->daddr;\r\n__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\r\nskb_reset_transport_header(skb);\r\nskb = xchg(&np->rxpmtu, skb);\r\nkfree_skb(skb);\r\n}\r\nstatic inline bool ipv6_datagram_support_addr(struct sock_exterr_skb *serr)\r\n{\r\nreturn serr->ee.ee_origin == SO_EE_ORIGIN_ICMP6 ||\r\nserr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\r\nserr->ee.ee_origin == SO_EE_ORIGIN_LOCAL || serr->port;\r\n}\r\nstatic bool ip6_datagram_support_cmsg(struct sk_buff *skb,\r\nstruct sock_exterr_skb *serr)\r\n{\r\nif (serr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\r\nserr->ee.ee_origin == SO_EE_ORIGIN_ICMP6)\r\nreturn true;\r\nif (serr->ee.ee_origin == SO_EE_ORIGIN_LOCAL)\r\nreturn false;\r\nif (!skb->dev)\r\nreturn false;\r\nif (skb->protocol == htons(ETH_P_IPV6))\r\nIP6CB(skb)->iif = skb->dev->ifindex;\r\nelse\r\nPKTINFO_SKB_CB(skb)->ipi_ifindex = skb->dev->ifindex;\r\nreturn true;\r\n}\r\nint ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct sock_exterr_skb *serr;\r\nstruct sk_buff *skb;\r\nDECLARE_SOCKADDR(struct sockaddr_in6 *, sin, msg->msg_name);\r\nstruct {\r\nstruct sock_extended_err ee;\r\nstruct sockaddr_in6 offender;\r\n} errhdr;\r\nint err;\r\nint copied;\r\nerr = -EAGAIN;\r\nskb = sock_dequeue_err_skb(sk);\r\nif (!skb)\r\ngoto out;\r\ncopied = skb->len;\r\nif (copied > len) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_msg(skb, 0, msg, copied);\r\nif (unlikely(err)) {\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nsock_recv_timestamp(msg, sk, skb);\r\nserr = SKB_EXT_ERR(skb);\r\nif (sin && ipv6_datagram_support_addr(serr)) {\r\nconst unsigned char *nh = skb_network_header(skb);\r\nsin->sin6_family = AF_INET6;\r\nsin->sin6_flowinfo = 0;\r\nsin->sin6_port = serr->port;\r\nif (skb->protocol == htons(ETH_P_IPV6)) {\r\nconst struct ipv6hdr *ip6h = container_of((struct in6_addr *)(nh + serr->addr_offset),\r\nstruct ipv6hdr, daddr);\r\nsin->sin6_addr = ip6h->daddr;\r\nif (np->sndflow)\r\nsin->sin6_flowinfo = ip6_flowinfo(ip6h);\r\nsin->sin6_scope_id =\r\nipv6_iface_scope_id(&sin->sin6_addr,\r\nIP6CB(skb)->iif);\r\n} else {\r\nipv6_addr_set_v4mapped(*(__be32 *)(nh + serr->addr_offset),\r\n&sin->sin6_addr);\r\nsin->sin6_scope_id = 0;\r\n}\r\n*addr_len = sizeof(*sin);\r\n}\r\nmemcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));\r\nsin = &errhdr.offender;\r\nmemset(sin, 0, sizeof(*sin));\r\nif (ip6_datagram_support_cmsg(skb, serr)) {\r\nsin->sin6_family = AF_INET6;\r\nif (np->rxopt.all)\r\nip6_datagram_recv_common_ctl(sk, msg, skb);\r\nif (skb->protocol == htons(ETH_P_IPV6)) {\r\nsin->sin6_addr = ipv6_hdr(skb)->saddr;\r\nif (np->rxopt.all)\r\nip6_datagram_recv_specific_ctl(sk, msg, skb);\r\nsin->sin6_scope_id =\r\nipv6_iface_scope_id(&sin->sin6_addr,\r\nIP6CB(skb)->iif);\r\n} else {\r\nipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\r\n&sin->sin6_addr);\r\nif (inet_sk(sk)->cmsg_flags)\r\nip_cmsg_recv(msg, skb);\r\n}\r\n}\r\nput_cmsg(msg, SOL_IPV6, IPV6_RECVERR, sizeof(errhdr), &errhdr);\r\nmsg->msg_flags |= MSG_ERRQUEUE;\r\nerr = copied;\r\nconsume_skb(skb);\r\nout:\r\nreturn err;\r\n}\r\nint ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,\r\nint *addr_len)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct sk_buff *skb;\r\nstruct ip6_mtuinfo mtu_info;\r\nDECLARE_SOCKADDR(struct sockaddr_in6 *, sin, msg->msg_name);\r\nint err;\r\nint copied;\r\nerr = -EAGAIN;\r\nskb = xchg(&np->rxpmtu, NULL);\r\nif (!skb)\r\ngoto out;\r\ncopied = skb->len;\r\nif (copied > len) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_msg(skb, 0, msg, copied);\r\nif (err)\r\ngoto out_free_skb;\r\nsock_recv_timestamp(msg, sk, skb);\r\nmemcpy(&mtu_info, IP6CBMTU(skb), sizeof(mtu_info));\r\nif (sin) {\r\nsin->sin6_family = AF_INET6;\r\nsin->sin6_flowinfo = 0;\r\nsin->sin6_port = 0;\r\nsin->sin6_scope_id = mtu_info.ip6m_addr.sin6_scope_id;\r\nsin->sin6_addr = mtu_info.ip6m_addr.sin6_addr;\r\n*addr_len = sizeof(*sin);\r\n}\r\nput_cmsg(msg, SOL_IPV6, IPV6_PATHMTU, sizeof(mtu_info), &mtu_info);\r\nerr = copied;\r\nout_free_skb:\r\nkfree_skb(skb);\r\nout:\r\nreturn err;\r\n}\r\nvoid ip6_datagram_recv_common_ctl(struct sock *sk, struct msghdr *msg,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nbool is_ipv6 = skb->protocol == htons(ETH_P_IPV6);\r\nif (np->rxopt.bits.rxinfo) {\r\nstruct in6_pktinfo src_info;\r\nif (is_ipv6) {\r\nsrc_info.ipi6_ifindex = IP6CB(skb)->iif;\r\nsrc_info.ipi6_addr = ipv6_hdr(skb)->daddr;\r\n} else {\r\nsrc_info.ipi6_ifindex =\r\nPKTINFO_SKB_CB(skb)->ipi_ifindex;\r\nipv6_addr_set_v4mapped(ip_hdr(skb)->daddr,\r\n&src_info.ipi6_addr);\r\n}\r\nif (src_info.ipi6_ifindex >= 0)\r\nput_cmsg(msg, SOL_IPV6, IPV6_PKTINFO,\r\nsizeof(src_info), &src_info);\r\n}\r\n}\r\nvoid ip6_datagram_recv_specific_ctl(struct sock *sk, struct msghdr *msg,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct inet6_skb_parm *opt = IP6CB(skb);\r\nunsigned char *nh = skb_network_header(skb);\r\nif (np->rxopt.bits.rxhlim) {\r\nint hlim = ipv6_hdr(skb)->hop_limit;\r\nput_cmsg(msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);\r\n}\r\nif (np->rxopt.bits.rxtclass) {\r\nint tclass = ipv6_get_dsfield(ipv6_hdr(skb));\r\nput_cmsg(msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);\r\n}\r\nif (np->rxopt.bits.rxflow) {\r\n__be32 flowinfo = ip6_flowinfo((struct ipv6hdr *)nh);\r\nif (flowinfo)\r\nput_cmsg(msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);\r\n}\r\nif (np->rxopt.bits.hopopts && (opt->flags & IP6SKB_HOPBYHOP)) {\r\nu8 *ptr = nh + sizeof(struct ipv6hdr);\r\nput_cmsg(msg, SOL_IPV6, IPV6_HOPOPTS, (ptr[1]+1)<<3, ptr);\r\n}\r\nif (opt->lastopt &&\r\n(np->rxopt.bits.dstopts || np->rxopt.bits.srcrt)) {\r\nunsigned int off = sizeof(struct ipv6hdr);\r\nu8 nexthdr = ipv6_hdr(skb)->nexthdr;\r\nwhile (off <= opt->lastopt) {\r\nunsigned int len;\r\nu8 *ptr = nh + off;\r\nswitch (nexthdr) {\r\ncase IPPROTO_DSTOPTS:\r\nnexthdr = ptr[0];\r\nlen = (ptr[1] + 1) << 3;\r\nif (np->rxopt.bits.dstopts)\r\nput_cmsg(msg, SOL_IPV6, IPV6_DSTOPTS, len, ptr);\r\nbreak;\r\ncase IPPROTO_ROUTING:\r\nnexthdr = ptr[0];\r\nlen = (ptr[1] + 1) << 3;\r\nif (np->rxopt.bits.srcrt)\r\nput_cmsg(msg, SOL_IPV6, IPV6_RTHDR, len, ptr);\r\nbreak;\r\ncase IPPROTO_AH:\r\nnexthdr = ptr[0];\r\nlen = (ptr[1] + 2) << 2;\r\nbreak;\r\ndefault:\r\nnexthdr = ptr[0];\r\nlen = (ptr[1] + 1) << 3;\r\nbreak;\r\n}\r\noff += len;\r\n}\r\n}\r\nif (np->rxopt.bits.rxoinfo) {\r\nstruct in6_pktinfo src_info;\r\nsrc_info.ipi6_ifindex = opt->iif;\r\nsrc_info.ipi6_addr = ipv6_hdr(skb)->daddr;\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292PKTINFO, sizeof(src_info), &src_info);\r\n}\r\nif (np->rxopt.bits.rxohlim) {\r\nint hlim = ipv6_hdr(skb)->hop_limit;\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292HOPLIMIT, sizeof(hlim), &hlim);\r\n}\r\nif (np->rxopt.bits.ohopopts && (opt->flags & IP6SKB_HOPBYHOP)) {\r\nu8 *ptr = nh + sizeof(struct ipv6hdr);\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292HOPOPTS, (ptr[1]+1)<<3, ptr);\r\n}\r\nif (np->rxopt.bits.odstopts && opt->dst0) {\r\nu8 *ptr = nh + opt->dst0;\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292DSTOPTS, (ptr[1]+1)<<3, ptr);\r\n}\r\nif (np->rxopt.bits.osrcrt && opt->srcrt) {\r\nstruct ipv6_rt_hdr *rthdr = (struct ipv6_rt_hdr *)(nh + opt->srcrt);\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292RTHDR, (rthdr->hdrlen+1) << 3, rthdr);\r\n}\r\nif (np->rxopt.bits.odstopts && opt->dst1) {\r\nu8 *ptr = nh + opt->dst1;\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292DSTOPTS, (ptr[1]+1)<<3, ptr);\r\n}\r\nif (np->rxopt.bits.rxorigdstaddr) {\r\nstruct sockaddr_in6 sin6;\r\n__be16 *ports = (__be16 *) skb_transport_header(skb);\r\nif (skb_transport_offset(skb) + 4 <= skb->len) {\r\nsin6.sin6_family = AF_INET6;\r\nsin6.sin6_addr = ipv6_hdr(skb)->daddr;\r\nsin6.sin6_port = ports[1];\r\nsin6.sin6_flowinfo = 0;\r\nsin6.sin6_scope_id =\r\nipv6_iface_scope_id(&ipv6_hdr(skb)->daddr,\r\nopt->iif);\r\nput_cmsg(msg, SOL_IPV6, IPV6_ORIGDSTADDR, sizeof(sin6), &sin6);\r\n}\r\n}\r\n}\r\nvoid ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,\r\nstruct sk_buff *skb)\r\n{\r\nip6_datagram_recv_common_ctl(sk, msg, skb);\r\nip6_datagram_recv_specific_ctl(sk, msg, skb);\r\n}\r\nint ip6_datagram_send_ctl(struct net *net, struct sock *sk,\r\nstruct msghdr *msg, struct flowi6 *fl6,\r\nstruct ipcm6_cookie *ipc6, struct sockcm_cookie *sockc)\r\n{\r\nstruct in6_pktinfo *src_info;\r\nstruct cmsghdr *cmsg;\r\nstruct ipv6_rt_hdr *rthdr;\r\nstruct ipv6_opt_hdr *hdr;\r\nstruct ipv6_txoptions *opt = ipc6->opt;\r\nint len;\r\nint err = 0;\r\nfor_each_cmsghdr(cmsg, msg) {\r\nint addr_type;\r\nif (!CMSG_OK(msg, cmsg)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif (cmsg->cmsg_level == SOL_SOCKET) {\r\nerr = __sock_cmsg_send(sk, msg, cmsg, sockc);\r\nif (err)\r\nreturn err;\r\ncontinue;\r\n}\r\nif (cmsg->cmsg_level != SOL_IPV6)\r\ncontinue;\r\nswitch (cmsg->cmsg_type) {\r\ncase IPV6_PKTINFO:\r\ncase IPV6_2292PKTINFO:\r\n{\r\nstruct net_device *dev = NULL;\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct in6_pktinfo))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nsrc_info = (struct in6_pktinfo *)CMSG_DATA(cmsg);\r\nif (src_info->ipi6_ifindex) {\r\nif (fl6->flowi6_oif &&\r\nsrc_info->ipi6_ifindex != fl6->flowi6_oif)\r\nreturn -EINVAL;\r\nfl6->flowi6_oif = src_info->ipi6_ifindex;\r\n}\r\naddr_type = __ipv6_addr_type(&src_info->ipi6_addr);\r\nrcu_read_lock();\r\nif (fl6->flowi6_oif) {\r\ndev = dev_get_by_index_rcu(net, fl6->flowi6_oif);\r\nif (!dev) {\r\nrcu_read_unlock();\r\nreturn -ENODEV;\r\n}\r\n} else if (addr_type & IPV6_ADDR_LINKLOCAL) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nif (addr_type != IPV6_ADDR_ANY) {\r\nint strict = __ipv6_addr_src_scope(addr_type) <= IPV6_ADDR_SCOPE_LINKLOCAL;\r\nif (!(inet_sk(sk)->freebind || inet_sk(sk)->transparent) &&\r\n!ipv6_chk_addr(net, &src_info->ipi6_addr,\r\nstrict ? dev : NULL, 0) &&\r\n!ipv6_chk_acast_addr_src(net, dev,\r\n&src_info->ipi6_addr))\r\nerr = -EINVAL;\r\nelse\r\nfl6->saddr = src_info->ipi6_addr;\r\n}\r\nrcu_read_unlock();\r\nif (err)\r\ngoto exit_f;\r\nbreak;\r\n}\r\ncase IPV6_FLOWINFO:\r\nif (cmsg->cmsg_len < CMSG_LEN(4)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif (fl6->flowlabel&IPV6_FLOWINFO_MASK) {\r\nif ((fl6->flowlabel^*(__be32 *)CMSG_DATA(cmsg))&~IPV6_FLOWINFO_MASK) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\n}\r\nfl6->flowlabel = IPV6_FLOWINFO_MASK & *(__be32 *)CMSG_DATA(cmsg);\r\nbreak;\r\ncase IPV6_2292HOPOPTS:\r\ncase IPV6_HOPOPTS:\r\nif (opt->hopopt || cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nhdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\r\nlen = ((hdr->hdrlen + 1) << 3);\r\nif (cmsg->cmsg_len < CMSG_LEN(len)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\r\nerr = -EPERM;\r\ngoto exit_f;\r\n}\r\nopt->opt_nflen += len;\r\nopt->hopopt = hdr;\r\nbreak;\r\ncase IPV6_2292DSTOPTS:\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nhdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\r\nlen = ((hdr->hdrlen + 1) << 3);\r\nif (cmsg->cmsg_len < CMSG_LEN(len)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\r\nerr = -EPERM;\r\ngoto exit_f;\r\n}\r\nif (opt->dst1opt) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nopt->opt_flen += len;\r\nopt->dst1opt = hdr;\r\nbreak;\r\ncase IPV6_DSTOPTS:\r\ncase IPV6_RTHDRDSTOPTS:\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nhdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\r\nlen = ((hdr->hdrlen + 1) << 3);\r\nif (cmsg->cmsg_len < CMSG_LEN(len)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\r\nerr = -EPERM;\r\ngoto exit_f;\r\n}\r\nif (cmsg->cmsg_type == IPV6_DSTOPTS) {\r\nopt->opt_flen += len;\r\nopt->dst1opt = hdr;\r\n} else {\r\nopt->opt_nflen += len;\r\nopt->dst0opt = hdr;\r\n}\r\nbreak;\r\ncase IPV6_2292RTHDR:\r\ncase IPV6_RTHDR:\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_rt_hdr))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nrthdr = (struct ipv6_rt_hdr *)CMSG_DATA(cmsg);\r\nswitch (rthdr->type) {\r\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\r\ncase IPV6_SRCRT_TYPE_2:\r\nif (rthdr->hdrlen != 2 ||\r\nrthdr->segments_left != 1) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nlen = ((rthdr->hdrlen + 1) << 3);\r\nif (cmsg->cmsg_len < CMSG_LEN(len)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif ((rthdr->hdrlen >> 1) != rthdr->segments_left) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nopt->opt_nflen += len;\r\nopt->srcrt = rthdr;\r\nif (cmsg->cmsg_type == IPV6_2292RTHDR && opt->dst1opt) {\r\nint dsthdrlen = ((opt->dst1opt->hdrlen+1)<<3);\r\nopt->opt_nflen += dsthdrlen;\r\nopt->dst0opt = opt->dst1opt;\r\nopt->dst1opt = NULL;\r\nopt->opt_flen -= dsthdrlen;\r\n}\r\nbreak;\r\ncase IPV6_2292HOPLIMIT:\r\ncase IPV6_HOPLIMIT:\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(int))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nipc6->hlimit = *(int *)CMSG_DATA(cmsg);\r\nif (ipc6->hlimit < -1 || ipc6->hlimit > 0xff) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nbreak;\r\ncase IPV6_TCLASS:\r\n{\r\nint tc;\r\nerr = -EINVAL;\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\r\ngoto exit_f;\r\ntc = *(int *)CMSG_DATA(cmsg);\r\nif (tc < -1 || tc > 0xff)\r\ngoto exit_f;\r\nerr = 0;\r\nipc6->tclass = tc;\r\nbreak;\r\n}\r\ncase IPV6_DONTFRAG:\r\n{\r\nint df;\r\nerr = -EINVAL;\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\r\ngoto exit_f;\r\ndf = *(int *)CMSG_DATA(cmsg);\r\nif (df < 0 || df > 1)\r\ngoto exit_f;\r\nerr = 0;\r\nipc6->dontfrag = df;\r\nbreak;\r\n}\r\ndefault:\r\nnet_dbg_ratelimited("invalid cmsg type: %d\n",\r\ncmsg->cmsg_type);\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\n}\r\nexit_f:\r\nreturn err;\r\n}\r\nvoid ip6_dgram_sock_seq_show(struct seq_file *seq, struct sock *sp,\r\n__u16 srcp, __u16 destp, int bucket)\r\n{\r\nconst struct in6_addr *dest, *src;\r\ndest = &sp->sk_v6_daddr;\r\nsrc = &sp->sk_v6_rcv_saddr;\r\nseq_printf(seq,\r\n"%5d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X "\r\n"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %d\n",\r\nbucket,\r\nsrc->s6_addr32[0], src->s6_addr32[1],\r\nsrc->s6_addr32[2], src->s6_addr32[3], srcp,\r\ndest->s6_addr32[0], dest->s6_addr32[1],\r\ndest->s6_addr32[2], dest->s6_addr32[3], destp,\r\nsp->sk_state,\r\nsk_wmem_alloc_get(sp),\r\nsk_rmem_alloc_get(sp),\r\n0, 0L, 0,\r\nfrom_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\r\n0,\r\nsock_i_ino(sp),\r\natomic_read(&sp->sk_refcnt), sp,\r\natomic_read(&sp->sk_drops));\r\n}
