static inline void stb6100_normalise_regs(u8 regs[])\r\n{\r\nint i;\r\nfor (i = 0; i < STB6100_NUMREGS; i++)\r\nregs[i] = (regs[i] & stb6100_template[i].mask) | stb6100_template[i].set;\r\n}\r\nstatic int stb6100_read_regs(struct stb6100_state *state, u8 regs[])\r\n{\r\nint rc;\r\nstruct i2c_msg msg = {\r\n.addr = state->config->tuner_address,\r\n.flags = I2C_M_RD,\r\n.buf = regs,\r\n.len = STB6100_NUMREGS\r\n};\r\nrc = i2c_transfer(state->i2c, &msg, 1);\r\nif (unlikely(rc != 1)) {\r\ndprintk(verbose, FE_ERROR, 1, "Read (0x%x) err, rc=[%d]",\r\nstate->config->tuner_address, rc);\r\nreturn -EREMOTEIO;\r\n}\r\nif (unlikely(verbose > FE_DEBUG)) {\r\nint i;\r\ndprintk(verbose, FE_DEBUG, 1, " Read from 0x%02x", state->config->tuner_address);\r\nfor (i = 0; i < STB6100_NUMREGS; i++)\r\ndprintk(verbose, FE_DEBUG, 1, " %s: 0x%02x", stb6100_regnames[i], regs[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stb6100_read_reg(struct stb6100_state *state, u8 reg)\r\n{\r\nu8 regs[STB6100_NUMREGS];\r\nstruct i2c_msg msg = {\r\n.addr = state->config->tuner_address + reg,\r\n.flags = I2C_M_RD,\r\n.buf = regs,\r\n.len = 1\r\n};\r\ni2c_transfer(state->i2c, &msg, 1);\r\nif (unlikely(reg >= STB6100_NUMREGS)) {\r\ndprintk(verbose, FE_ERROR, 1, "Invalid register offset 0x%x", reg);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(verbose > FE_DEBUG)) {\r\ndprintk(verbose, FE_DEBUG, 1, " Read from 0x%02x", state->config->tuner_address);\r\ndprintk(verbose, FE_DEBUG, 1, " %s: 0x%02x", stb6100_regnames[reg], regs[0]);\r\n}\r\nreturn (unsigned int)regs[0];\r\n}\r\nstatic int stb6100_write_reg_range(struct stb6100_state *state, u8 buf[], int start, int len)\r\n{\r\nint rc;\r\nu8 cmdbuf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg = {\r\n.addr = state->config->tuner_address,\r\n.flags = 0,\r\n.buf = cmdbuf,\r\n.len = len + 1\r\n};\r\nif (1 + len > sizeof(cmdbuf)) {\r\nprintk(KERN_WARNING\r\n"%s: i2c wr: len=%d is too big!\n",\r\nKBUILD_MODNAME, len);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(start < 1 || start + len > STB6100_NUMREGS)) {\r\ndprintk(verbose, FE_ERROR, 1, "Invalid register range %d:%d",\r\nstart, len);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&cmdbuf[1], buf, len);\r\ncmdbuf[0] = start;\r\nif (unlikely(verbose > FE_DEBUG)) {\r\nint i;\r\ndprintk(verbose, FE_DEBUG, 1, " Write @ 0x%02x: [%d:%d]", state->config->tuner_address, start, len);\r\nfor (i = 0; i < len; i++)\r\ndprintk(verbose, FE_DEBUG, 1, " %s: 0x%02x", stb6100_regnames[start + i], buf[i]);\r\n}\r\nrc = i2c_transfer(state->i2c, &msg, 1);\r\nif (unlikely(rc != 1)) {\r\ndprintk(verbose, FE_ERROR, 1, "(0x%x) write err [%d:%d], rc=[%d]",\r\n(unsigned int)state->config->tuner_address, start, len, rc);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stb6100_write_reg(struct stb6100_state *state, u8 reg, u8 data)\r\n{\r\nif (unlikely(reg >= STB6100_NUMREGS)) {\r\ndprintk(verbose, FE_ERROR, 1, "Invalid register offset 0x%x", reg);\r\nreturn -EREMOTEIO;\r\n}\r\ndata = (data & stb6100_template[reg].mask) | stb6100_template[reg].set;\r\nreturn stb6100_write_reg_range(state, &data, reg, 1);\r\n}\r\nstatic int stb6100_get_status(struct dvb_frontend *fe, u32 *status)\r\n{\r\nint rc;\r\nstruct stb6100_state *state = fe->tuner_priv;\r\nrc = stb6100_read_reg(state, STB6100_LD);\r\nif (rc < 0) {\r\ndprintk(verbose, FE_ERROR, 1, "%s failed", __func__);\r\nreturn rc;\r\n}\r\nreturn (rc & STB6100_LD_LOCK) ? TUNER_STATUS_LOCKED : 0;\r\n}\r\nstatic int stb6100_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\r\n{\r\nint rc;\r\nu8 f;\r\nu32 bw;\r\nstruct stb6100_state *state = fe->tuner_priv;\r\nrc = stb6100_read_reg(state, STB6100_F);\r\nif (rc < 0)\r\nreturn rc;\r\nf = rc & STB6100_F_F;\r\nbw = (f + 5) * 2000;\r\n*bandwidth = state->bandwidth = bw * 1000;\r\ndprintk(verbose, FE_DEBUG, 1, "bandwidth = %u Hz", state->bandwidth);\r\nreturn 0;\r\n}\r\nstatic int stb6100_set_bandwidth(struct dvb_frontend *fe, u32 bandwidth)\r\n{\r\nu32 tmp;\r\nint rc;\r\nstruct stb6100_state *state = fe->tuner_priv;\r\ndprintk(verbose, FE_DEBUG, 1, "set bandwidth to %u Hz", bandwidth);\r\nbandwidth /= 2;\r\nif (bandwidth >= 36000000)\r\ntmp = 31;\r\nelse if (bandwidth <= 5000000)\r\ntmp = 0;\r\nelse\r\ntmp = (bandwidth + 500000) / 1000000 - 5;\r\nrc = stb6100_write_reg(state, STB6100_FCCK, 0x0d | STB6100_FCCK_FCCK);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = stb6100_write_reg(state, STB6100_F, 0xc0 | tmp);\r\nif (rc < 0)\r\nreturn rc;\r\nmsleep(5);\r\nrc = stb6100_write_reg(state, STB6100_FCCK, 0x0d);\r\nif (rc < 0)\r\nreturn rc;\r\nmsleep(10);\r\nreturn 0;\r\n}\r\nstatic int stb6100_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nint rc;\r\nu32 nint, nfrac, fvco;\r\nint psd2, odiv;\r\nstruct stb6100_state *state = fe->tuner_priv;\r\nu8 regs[STB6100_NUMREGS];\r\nrc = stb6100_read_regs(state, regs);\r\nif (rc < 0)\r\nreturn rc;\r\nodiv = (regs[STB6100_VCO] & STB6100_VCO_ODIV) >> STB6100_VCO_ODIV_SHIFT;\r\npsd2 = (regs[STB6100_K] & STB6100_K_PSD2) >> STB6100_K_PSD2_SHIFT;\r\nnint = regs[STB6100_NI];\r\nnfrac = ((regs[STB6100_K] & STB6100_K_NF_MSB) << 8) | regs[STB6100_NF_LSB];\r\nfvco = (nfrac * state->reference >> (9 - psd2)) + (nint * state->reference << psd2);\r\n*frequency = state->frequency = fvco >> (odiv + 1);\r\ndprintk(verbose, FE_DEBUG, 1,\r\n"frequency = %u kHz, odiv = %u, psd2 = %u, fxtal = %u kHz, fvco = %u kHz, N(I) = %u, N(F) = %u",\r\nstate->frequency, odiv, psd2, state->reference, fvco, nint, nfrac);\r\nreturn 0;\r\n}\r\nstatic int stb6100_set_frequency(struct dvb_frontend *fe, u32 frequency)\r\n{\r\nint rc;\r\nconst struct stb6100_lkup *ptr;\r\nstruct stb6100_state *state = fe->tuner_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nu32 srate = 0, fvco, nint, nfrac;\r\nu8 regs[STB6100_NUMREGS];\r\nu8 g, psd2, odiv;\r\ndprintk(verbose, FE_DEBUG, 1, "Version 2010-8-14 13:51");\r\nif (fe->ops.get_frontend) {\r\ndprintk(verbose, FE_DEBUG, 1, "Get frontend parameters");\r\nfe->ops.get_frontend(fe, p);\r\n}\r\nsrate = p->symbol_rate;\r\nrc = stb6100_write_reg(state, STB6100_FCCK, 0x4d | STB6100_FCCK_FCCK);\r\nif (rc < 0)\r\nreturn rc;\r\nregs[STB6100_LPEN] = 0xeb;\r\nrc = stb6100_write_reg(state, STB6100_LPEN, regs[STB6100_LPEN]);\r\nif (rc < 0)\r\nreturn rc;\r\nif (frequency <= 1075000)\r\nodiv = 1;\r\nelse\r\nodiv = 0;\r\nregs[STB6100_VCO] = 0xe0 | (odiv << STB6100_VCO_ODIV_SHIFT);\r\nfor (ptr = lkup;\r\n(ptr->val_high != 0) && !CHKRANGE(frequency, ptr->val_low, ptr->val_high);\r\nptr++);\r\nif (ptr->val_high == 0) {\r\nprintk(KERN_ERR "%s: frequency out of range: %u kHz\n", __func__, frequency);\r\nreturn -EINVAL;\r\n}\r\nregs[STB6100_VCO] = (regs[STB6100_VCO] & ~STB6100_VCO_OSM) | ptr->reg;\r\nrc = stb6100_write_reg(state, STB6100_VCO, regs[STB6100_VCO]);\r\nif (rc < 0)\r\nreturn rc;\r\nif ((frequency > 1075000) && (frequency <= 1325000))\r\npsd2 = 0;\r\nelse\r\npsd2 = 1;\r\nfvco = frequency << (1 + odiv);\r\nnint = fvco / (state->reference << psd2);\r\nnfrac = DIV_ROUND_CLOSEST((fvco - (nint * state->reference << psd2))\r\n<< (9 - psd2), state->reference);\r\nregs[STB6100_NI] = nint;\r\nrc = stb6100_write_reg(state, STB6100_NI, regs[STB6100_NI]);\r\nif (rc < 0)\r\nreturn rc;\r\nregs[STB6100_NF_LSB] = nfrac;\r\nrc = stb6100_write_reg(state, STB6100_NF_LSB, regs[STB6100_NF_LSB]);\r\nif (rc < 0)\r\nreturn rc;\r\nregs[STB6100_K] = (0x38 & ~STB6100_K_PSD2) | (psd2 << STB6100_K_PSD2_SHIFT);\r\nregs[STB6100_K] = (regs[STB6100_K] & ~STB6100_K_NF_MSB) | ((nfrac >> 8) & STB6100_K_NF_MSB);\r\nrc = stb6100_write_reg(state, STB6100_K, regs[STB6100_K]);\r\nif (rc < 0)\r\nreturn rc;\r\nif (srate >= 15000000)\r\ng = 9;\r\nelse if (srate >= 5000000)\r\ng = 11;\r\nelse\r\ng = 14;\r\nregs[STB6100_G] = (0x10 & ~STB6100_G_G) | g;\r\nregs[STB6100_G] &= ~STB6100_G_GCT;\r\nregs[STB6100_G] |= (1 << 5);\r\nrc = stb6100_write_reg(state, STB6100_G, regs[STB6100_G]);\r\nif (rc < 0)\r\nreturn rc;\r\nregs[STB6100_DLB] = 0xcc;\r\nrc = stb6100_write_reg(state, STB6100_DLB, regs[STB6100_DLB]);\r\nif (rc < 0)\r\nreturn rc;\r\ndprintk(verbose, FE_DEBUG, 1,\r\n"frequency = %u, srate = %u, g = %u, odiv = %u, psd2 = %u, fxtal = %u, osm = %u, fvco = %u, N(I) = %u, N(F) = %u",\r\nfrequency, srate, (unsigned int)g, (unsigned int)odiv,\r\n(unsigned int)psd2, state->reference,\r\nptr->reg, fvco, nint, nfrac);\r\nregs[STB6100_TEST1] = 0x8f;\r\nrc = stb6100_write_reg(state, STB6100_TEST1, regs[STB6100_TEST1]);\r\nif (rc < 0)\r\nreturn rc;\r\nregs[STB6100_TEST3] = 0xde;\r\nrc = stb6100_write_reg(state, STB6100_TEST3, regs[STB6100_TEST3]);\r\nif (rc < 0)\r\nreturn rc;\r\nregs[STB6100_LPEN] = 0xfb;\r\nrc = stb6100_write_reg(state, STB6100_LPEN, regs[STB6100_LPEN]);\r\nif (rc < 0)\r\nreturn rc;\r\nmsleep(2);\r\nregs[STB6100_VCO] &= ~STB6100_VCO_OCK;\r\nrc = stb6100_write_reg(state, STB6100_VCO, regs[STB6100_VCO]);\r\nif (rc < 0)\r\nreturn rc;\r\nmsleep(10);\r\nregs[STB6100_VCO] &= ~STB6100_VCO_OSCH;\r\nregs[STB6100_VCO] |= STB6100_VCO_OCK;\r\nrc = stb6100_write_reg(state, STB6100_VCO, regs[STB6100_VCO]);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = stb6100_write_reg(state, STB6100_FCCK, 0x0d);\r\nif (rc < 0)\r\nreturn rc;\r\nmsleep(10);\r\nreturn 0;\r\n}\r\nstatic int stb6100_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int stb6100_init(struct dvb_frontend *fe)\r\n{\r\nstruct stb6100_state *state = fe->tuner_priv;\r\nint refclk = 27000000;\r\nstate->bandwidth = 36000000;\r\nstate->reference = refclk / 1000;\r\nreturn 0;\r\n}\r\nstatic int stb6100_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->frequency > 0)\r\nstb6100_set_frequency(fe, c->frequency);\r\nif (c->bandwidth_hz > 0)\r\nstb6100_set_bandwidth(fe, c->bandwidth_hz);\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *stb6100_attach(struct dvb_frontend *fe,\r\nconst struct stb6100_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct stb6100_state *state = NULL;\r\nstate = kzalloc(sizeof (struct stb6100_state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->frontend = fe;\r\nstate->reference = config->refclock / 1000;\r\nfe->tuner_priv = state;\r\nfe->ops.tuner_ops = stb6100_ops;\r\nprintk("%s: Attaching STB6100 \n", __func__);\r\nreturn fe;\r\n}\r\nstatic int stb6100_release(struct dvb_frontend *fe)\r\n{\r\nstruct stb6100_state *state = fe->tuner_priv;\r\nfe->tuner_priv = NULL;\r\nkfree(state);\r\nreturn 0;\r\n}
