static bool ccu_data_offsets_valid(struct ccu_data *ccu)\r\n{\r\nstruct ccu_policy *ccu_policy = &ccu->policy;\r\nu32 limit;\r\nlimit = ccu->range - sizeof(u32);\r\nlimit = round_down(limit, sizeof(u32));\r\nif (ccu_policy_exists(ccu_policy)) {\r\nif (ccu_policy->enable.offset > limit) {\r\npr_err("%s: bad policy enable offset for %s "\r\n"(%u > %u)\n", __func__,\r\nccu->name, ccu_policy->enable.offset, limit);\r\nreturn false;\r\n}\r\nif (ccu_policy->control.offset > limit) {\r\npr_err("%s: bad policy control offset for %s "\r\n"(%u > %u)\n", __func__,\r\nccu->name, ccu_policy->control.offset, limit);\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic bool clk_requires_trigger(struct kona_clk *bcm_clk)\r\n{\r\nstruct peri_clk_data *peri = bcm_clk->u.peri;\r\nstruct bcm_clk_sel *sel;\r\nstruct bcm_clk_div *div;\r\nif (bcm_clk->type != bcm_clk_peri)\r\nreturn false;\r\nsel = &peri->sel;\r\nif (sel->parent_count && selector_exists(sel))\r\nreturn true;\r\ndiv = &peri->div;\r\nif (!divider_exists(div))\r\nreturn false;\r\nif (!divider_is_fixed(div))\r\nreturn true;\r\ndiv = &peri->pre_div;\r\nreturn divider_exists(div) && !divider_is_fixed(div);\r\n}\r\nstatic bool peri_clk_data_offsets_valid(struct kona_clk *bcm_clk)\r\n{\r\nstruct peri_clk_data *peri;\r\nstruct bcm_clk_policy *policy;\r\nstruct bcm_clk_gate *gate;\r\nstruct bcm_clk_hyst *hyst;\r\nstruct bcm_clk_div *div;\r\nstruct bcm_clk_sel *sel;\r\nstruct bcm_clk_trig *trig;\r\nconst char *name;\r\nu32 range;\r\nu32 limit;\r\nBUG_ON(bcm_clk->type != bcm_clk_peri);\r\nperi = bcm_clk->u.peri;\r\nname = bcm_clk->init_data.name;\r\nrange = bcm_clk->ccu->range;\r\nlimit = range - sizeof(u32);\r\nlimit = round_down(limit, sizeof(u32));\r\npolicy = &peri->policy;\r\nif (policy_exists(policy)) {\r\nif (policy->offset > limit) {\r\npr_err("%s: bad policy offset for %s (%u > %u)\n",\r\n__func__, name, policy->offset, limit);\r\nreturn false;\r\n}\r\n}\r\ngate = &peri->gate;\r\nhyst = &peri->hyst;\r\nif (gate_exists(gate)) {\r\nif (gate->offset > limit) {\r\npr_err("%s: bad gate offset for %s (%u > %u)\n",\r\n__func__, name, gate->offset, limit);\r\nreturn false;\r\n}\r\nif (hyst_exists(hyst)) {\r\nif (hyst->offset > limit) {\r\npr_err("%s: bad hysteresis offset for %s "\r\n"(%u > %u)\n", __func__,\r\nname, hyst->offset, limit);\r\nreturn false;\r\n}\r\n}\r\n} else if (hyst_exists(hyst)) {\r\npr_err("%s: hysteresis but no gate for %s\n", __func__, name);\r\nreturn false;\r\n}\r\ndiv = &peri->div;\r\nif (divider_exists(div)) {\r\nif (div->u.s.offset > limit) {\r\npr_err("%s: bad divider offset for %s (%u > %u)\n",\r\n__func__, name, div->u.s.offset, limit);\r\nreturn false;\r\n}\r\n}\r\ndiv = &peri->pre_div;\r\nif (divider_exists(div)) {\r\nif (div->u.s.offset > limit) {\r\npr_err("%s: bad pre-divider offset for %s "\r\n"(%u > %u)\n",\r\n__func__, name, div->u.s.offset, limit);\r\nreturn false;\r\n}\r\n}\r\nsel = &peri->sel;\r\nif (selector_exists(sel)) {\r\nif (sel->offset > limit) {\r\npr_err("%s: bad selector offset for %s (%u > %u)\n",\r\n__func__, name, sel->offset, limit);\r\nreturn false;\r\n}\r\n}\r\ntrig = &peri->trig;\r\nif (trigger_exists(trig)) {\r\nif (trig->offset > limit) {\r\npr_err("%s: bad trigger offset for %s (%u > %u)\n",\r\n__func__, name, trig->offset, limit);\r\nreturn false;\r\n}\r\n}\r\ntrig = &peri->pre_trig;\r\nif (trigger_exists(trig)) {\r\nif (trig->offset > limit) {\r\npr_err("%s: bad pre-trigger offset for %s (%u > %u)\n",\r\n__func__, name, trig->offset, limit);\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic bool bit_posn_valid(u32 bit_posn, const char *field_name,\r\nconst char *clock_name)\r\n{\r\nu32 limit = BITS_PER_BYTE * sizeof(u32) - 1;\r\nif (bit_posn > limit) {\r\npr_err("%s: bad %s bit for %s (%u > %u)\n", __func__,\r\nfield_name, clock_name, bit_posn, limit);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool bitfield_valid(u32 shift, u32 width, const char *field_name,\r\nconst char *clock_name)\r\n{\r\nu32 limit = BITS_PER_BYTE * sizeof(u32);\r\nif (!width) {\r\npr_err("%s: bad %s field width 0 for %s\n", __func__,\r\nfield_name, clock_name);\r\nreturn false;\r\n}\r\nif (shift + width > limit) {\r\npr_err("%s: bad %s for %s (%u + %u > %u)\n", __func__,\r\nfield_name, clock_name, shift, width, limit);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nccu_policy_valid(struct ccu_policy *ccu_policy, const char *ccu_name)\r\n{\r\nstruct bcm_lvm_en *enable = &ccu_policy->enable;\r\nstruct bcm_policy_ctl *control;\r\nif (!bit_posn_valid(enable->bit, "policy enable", ccu_name))\r\nreturn false;\r\ncontrol = &ccu_policy->control;\r\nif (!bit_posn_valid(control->go_bit, "policy control GO", ccu_name))\r\nreturn false;\r\nif (!bit_posn_valid(control->atl_bit, "policy control ATL", ccu_name))\r\nreturn false;\r\nif (!bit_posn_valid(control->ac_bit, "policy control AC", ccu_name))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool policy_valid(struct bcm_clk_policy *policy, const char *clock_name)\r\n{\r\nif (!bit_posn_valid(policy->bit, "policy", clock_name))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool gate_valid(struct bcm_clk_gate *gate, const char *field_name,\r\nconst char *clock_name)\r\n{\r\nif (!bit_posn_valid(gate->status_bit, "gate status", clock_name))\r\nreturn false;\r\nif (gate_is_sw_controllable(gate)) {\r\nif (!bit_posn_valid(gate->en_bit, "gate enable", clock_name))\r\nreturn false;\r\nif (gate_is_hw_controllable(gate)) {\r\nif (!bit_posn_valid(gate->hw_sw_sel_bit,\r\n"gate hw/sw select",\r\nclock_name))\r\nreturn false;\r\n}\r\n} else {\r\nBUG_ON(!gate_is_hw_controllable(gate));\r\n}\r\nreturn true;\r\n}\r\nstatic bool hyst_valid(struct bcm_clk_hyst *hyst, const char *clock_name)\r\n{\r\nif (!bit_posn_valid(hyst->en_bit, "hysteresis enable", clock_name))\r\nreturn false;\r\nif (!bit_posn_valid(hyst->val_bit, "hysteresis value", clock_name))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool sel_valid(struct bcm_clk_sel *sel, const char *field_name,\r\nconst char *clock_name)\r\n{\r\nif (!bitfield_valid(sel->shift, sel->width, field_name, clock_name))\r\nreturn false;\r\nif (sel->parent_count) {\r\nu32 max_sel;\r\nu32 limit;\r\nmax_sel = sel->parent_sel[sel->parent_count - 1];\r\nlimit = (1 << sel->width) - 1;\r\nif (max_sel > limit) {\r\npr_err("%s: bad selector for %s "\r\n"(%u needs > %u bits)\n",\r\n__func__, clock_name, max_sel,\r\nsel->width);\r\nreturn false;\r\n}\r\n} else {\r\npr_warn("%s: ignoring selector for %s (no parents)\n",\r\n__func__, clock_name);\r\nselector_clear_exists(sel);\r\nkfree(sel->parent_sel);\r\nsel->parent_sel = NULL;\r\n}\r\nreturn true;\r\n}\r\nstatic bool div_valid(struct bcm_clk_div *div, const char *field_name,\r\nconst char *clock_name)\r\n{\r\nif (divider_is_fixed(div)) {\r\nif (div->u.fixed == 0) {\r\npr_err("%s: bad %s fixed value 0 for %s\n", __func__,\r\nfield_name, clock_name);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nif (!bitfield_valid(div->u.s.shift, div->u.s.width,\r\nfield_name, clock_name))\r\nreturn false;\r\nif (divider_has_fraction(div))\r\nif (div->u.s.frac_width > div->u.s.width) {\r\npr_warn("%s: bad %s fraction width for %s (%u > %u)\n",\r\n__func__, field_name, clock_name,\r\ndiv->u.s.frac_width, div->u.s.width);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool kona_dividers_valid(struct kona_clk *bcm_clk)\r\n{\r\nstruct peri_clk_data *peri = bcm_clk->u.peri;\r\nstruct bcm_clk_div *div;\r\nstruct bcm_clk_div *pre_div;\r\nu32 limit;\r\nBUG_ON(bcm_clk->type != bcm_clk_peri);\r\nif (!divider_exists(&peri->div) || !divider_exists(&peri->pre_div))\r\nreturn true;\r\ndiv = &peri->div;\r\npre_div = &peri->pre_div;\r\nif (divider_is_fixed(div) || divider_is_fixed(pre_div))\r\nreturn true;\r\nlimit = BITS_PER_BYTE * sizeof(u32);\r\nreturn div->u.s.frac_width + pre_div->u.s.frac_width <= limit;\r\n}\r\nstatic bool trig_valid(struct bcm_clk_trig *trig, const char *field_name,\r\nconst char *clock_name)\r\n{\r\nreturn bit_posn_valid(trig->bit, field_name, clock_name);\r\n}\r\nstatic bool\r\nperi_clk_data_valid(struct kona_clk *bcm_clk)\r\n{\r\nstruct peri_clk_data *peri;\r\nstruct bcm_clk_policy *policy;\r\nstruct bcm_clk_gate *gate;\r\nstruct bcm_clk_hyst *hyst;\r\nstruct bcm_clk_sel *sel;\r\nstruct bcm_clk_div *div;\r\nstruct bcm_clk_div *pre_div;\r\nstruct bcm_clk_trig *trig;\r\nconst char *name;\r\nBUG_ON(bcm_clk->type != bcm_clk_peri);\r\nif (!peri_clk_data_offsets_valid(bcm_clk))\r\nreturn false;\r\nperi = bcm_clk->u.peri;\r\nname = bcm_clk->init_data.name;\r\npolicy = &peri->policy;\r\nif (policy_exists(policy) && !policy_valid(policy, name))\r\nreturn false;\r\ngate = &peri->gate;\r\nif (gate_exists(gate) && !gate_valid(gate, "gate", name))\r\nreturn false;\r\nhyst = &peri->hyst;\r\nif (hyst_exists(hyst) && !hyst_valid(hyst, name))\r\nreturn false;\r\nsel = &peri->sel;\r\nif (selector_exists(sel)) {\r\nif (!sel_valid(sel, "selector", name))\r\nreturn false;\r\n} else if (sel->parent_count > 1) {\r\npr_err("%s: multiple parents but no selector for %s\n",\r\n__func__, name);\r\nreturn false;\r\n}\r\ndiv = &peri->div;\r\npre_div = &peri->pre_div;\r\nif (divider_exists(div)) {\r\nif (!div_valid(div, "divider", name))\r\nreturn false;\r\nif (divider_exists(pre_div))\r\nif (!div_valid(pre_div, "pre-divider", name))\r\nreturn false;\r\n} else if (divider_exists(pre_div)) {\r\npr_err("%s: pre-divider but no divider for %s\n", __func__,\r\nname);\r\nreturn false;\r\n}\r\ntrig = &peri->trig;\r\nif (trigger_exists(trig)) {\r\nif (!trig_valid(trig, "trigger", name))\r\nreturn false;\r\nif (trigger_exists(&peri->pre_trig)) {\r\nif (!trig_valid(trig, "pre-trigger", name)) {\r\nreturn false;\r\n}\r\n}\r\nif (!clk_requires_trigger(bcm_clk)) {\r\npr_warn("%s: ignoring trigger for %s (not needed)\n",\r\n__func__, name);\r\ntrigger_clear_exists(trig);\r\n}\r\n} else if (trigger_exists(&peri->pre_trig)) {\r\npr_err("%s: pre-trigger but no trigger for %s\n", __func__,\r\nname);\r\nreturn false;\r\n} else if (clk_requires_trigger(bcm_clk)) {\r\npr_err("%s: required trigger missing for %s\n", __func__,\r\nname);\r\nreturn false;\r\n}\r\nreturn kona_dividers_valid(bcm_clk);\r\n}\r\nstatic bool kona_clk_valid(struct kona_clk *bcm_clk)\r\n{\r\nswitch (bcm_clk->type) {\r\ncase bcm_clk_peri:\r\nif (!peri_clk_data_valid(bcm_clk))\r\nreturn false;\r\nbreak;\r\ndefault:\r\npr_err("%s: unrecognized clock type (%d)\n", __func__,\r\n(int)bcm_clk->type);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic u32 *parent_process(const char *clocks[],\r\nu32 *count, const char ***names)\r\n{\r\nstatic const char **parent_names;\r\nstatic u32 *parent_sel;\r\nconst char **clock;\r\nu32 parent_count;\r\nu32 bad_count = 0;\r\nu32 orig_count;\r\nu32 i;\r\nu32 j;\r\n*count = 0;\r\n*names = NULL;\r\nif (!clocks)\r\nreturn NULL;\r\nfor (clock = clocks; *clock; clock++)\r\nif (*clock == BAD_CLK_NAME)\r\nbad_count++;\r\norig_count = (u32)(clock - clocks);\r\nparent_count = orig_count - bad_count;\r\nif (!parent_count)\r\nreturn NULL;\r\nif (parent_count > PARENT_COUNT_MAX) {\r\npr_err("%s: too many parents (%u > %u)\n", __func__,\r\nparent_count, PARENT_COUNT_MAX);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nparent_names = kmalloc_array(parent_count, sizeof(*parent_names),\r\nGFP_KERNEL);\r\nif (!parent_names) {\r\npr_err("%s: error allocating %u parent names\n", __func__,\r\nparent_count);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nparent_sel = kmalloc(parent_count * sizeof(*parent_sel), GFP_KERNEL);\r\nif (!parent_sel) {\r\npr_err("%s: error allocating %u parent selectors\n", __func__,\r\nparent_count);\r\nkfree(parent_names);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfor (i = 0, j = 0; i < orig_count; i++) {\r\nif (clocks[i] != BAD_CLK_NAME) {\r\nparent_names[j] = clocks[i];\r\nparent_sel[j] = i;\r\nj++;\r\n}\r\n}\r\n*names = parent_names;\r\n*count = parent_count;\r\nreturn parent_sel;\r\n}\r\nstatic int\r\nclk_sel_setup(const char **clocks, struct bcm_clk_sel *sel,\r\nstruct clk_init_data *init_data)\r\n{\r\nconst char **parent_names = NULL;\r\nu32 parent_count = 0;\r\nu32 *parent_sel;\r\nparent_sel = parent_process(clocks, &parent_count, &parent_names);\r\nif (IS_ERR(parent_sel)) {\r\nint ret = PTR_ERR(parent_sel);\r\npr_err("%s: error processing parent clocks for %s (%d)\n",\r\n__func__, init_data->name, ret);\r\nreturn ret;\r\n}\r\ninit_data->parent_names = parent_names;\r\ninit_data->num_parents = parent_count;\r\nsel->parent_count = parent_count;\r\nsel->parent_sel = parent_sel;\r\nreturn 0;\r\n}\r\nstatic void clk_sel_teardown(struct bcm_clk_sel *sel,\r\nstruct clk_init_data *init_data)\r\n{\r\nkfree(sel->parent_sel);\r\nsel->parent_sel = NULL;\r\nsel->parent_count = 0;\r\ninit_data->num_parents = 0;\r\nkfree(init_data->parent_names);\r\ninit_data->parent_names = NULL;\r\n}\r\nstatic void peri_clk_teardown(struct peri_clk_data *data,\r\nstruct clk_init_data *init_data)\r\n{\r\nclk_sel_teardown(&data->sel, init_data);\r\n}\r\nstatic int\r\nperi_clk_setup(struct peri_clk_data *data, struct clk_init_data *init_data)\r\n{\r\ninit_data->flags = CLK_IGNORE_UNUSED;\r\nreturn clk_sel_setup(data->clocks, &data->sel, init_data);\r\n}\r\nstatic void bcm_clk_teardown(struct kona_clk *bcm_clk)\r\n{\r\nswitch (bcm_clk->type) {\r\ncase bcm_clk_peri:\r\nperi_clk_teardown(bcm_clk->u.data, &bcm_clk->init_data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbcm_clk->u.data = NULL;\r\nbcm_clk->type = bcm_clk_none;\r\n}\r\nstatic void kona_clk_teardown(struct clk *clk)\r\n{\r\nstruct clk_hw *hw;\r\nstruct kona_clk *bcm_clk;\r\nif (!clk)\r\nreturn;\r\nhw = __clk_get_hw(clk);\r\nif (!hw) {\r\npr_err("%s: clk %p has null hw pointer\n", __func__, clk);\r\nreturn;\r\n}\r\nclk_unregister(clk);\r\nbcm_clk = to_kona_clk(hw);\r\nbcm_clk_teardown(bcm_clk);\r\n}\r\nstruct clk *kona_clk_setup(struct kona_clk *bcm_clk)\r\n{\r\nstruct clk_init_data *init_data = &bcm_clk->init_data;\r\nstruct clk *clk = NULL;\r\nswitch (bcm_clk->type) {\r\ncase bcm_clk_peri:\r\nif (peri_clk_setup(bcm_clk->u.data, init_data))\r\nreturn NULL;\r\nbreak;\r\ndefault:\r\npr_err("%s: clock type %d invalid for %s\n", __func__,\r\n(int)bcm_clk->type, init_data->name);\r\nreturn NULL;\r\n}\r\nif (!kona_clk_valid(bcm_clk)) {\r\npr_err("%s: clock data invalid for %s\n", __func__,\r\ninit_data->name);\r\ngoto out_teardown;\r\n}\r\nbcm_clk->hw.init = init_data;\r\nclk = clk_register(NULL, &bcm_clk->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: error registering clock %s (%ld)\n", __func__,\r\ninit_data->name, PTR_ERR(clk));\r\ngoto out_teardown;\r\n}\r\nBUG_ON(!clk);\r\nreturn clk;\r\nout_teardown:\r\nbcm_clk_teardown(bcm_clk);\r\nreturn NULL;\r\n}\r\nstatic void ccu_clks_teardown(struct ccu_data *ccu)\r\n{\r\nu32 i;\r\nfor (i = 0; i < ccu->clk_data.clk_num; i++)\r\nkona_clk_teardown(ccu->clk_data.clks[i]);\r\nkfree(ccu->clk_data.clks);\r\n}\r\nstatic void kona_ccu_teardown(struct ccu_data *ccu)\r\n{\r\nkfree(ccu->clk_data.clks);\r\nccu->clk_data.clks = NULL;\r\nif (!ccu->base)\r\nreturn;\r\nof_clk_del_provider(ccu->node);\r\nccu_clks_teardown(ccu);\r\nof_node_put(ccu->node);\r\nccu->node = NULL;\r\niounmap(ccu->base);\r\nccu->base = NULL;\r\n}\r\nstatic bool ccu_data_valid(struct ccu_data *ccu)\r\n{\r\nstruct ccu_policy *ccu_policy;\r\nif (!ccu_data_offsets_valid(ccu))\r\nreturn false;\r\nccu_policy = &ccu->policy;\r\nif (ccu_policy_exists(ccu_policy))\r\nif (!ccu_policy_valid(ccu_policy, ccu->name))\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid __init kona_dt_ccu_setup(struct ccu_data *ccu,\r\nstruct device_node *node)\r\n{\r\nstruct resource res = { 0 };\r\nresource_size_t range;\r\nunsigned int i;\r\nint ret;\r\nif (ccu->clk_data.clk_num) {\r\nsize_t size;\r\nsize = ccu->clk_data.clk_num * sizeof(*ccu->clk_data.clks);\r\nccu->clk_data.clks = kzalloc(size, GFP_KERNEL);\r\nif (!ccu->clk_data.clks) {\r\npr_err("%s: unable to allocate %u clocks for %s\n",\r\n__func__, ccu->clk_data.clk_num, node->name);\r\nreturn;\r\n}\r\n}\r\nret = of_address_to_resource(node, 0, &res);\r\nif (ret) {\r\npr_err("%s: no valid CCU registers found for %s\n", __func__,\r\nnode->name);\r\ngoto out_err;\r\n}\r\nrange = resource_size(&res);\r\nif (range > (resource_size_t)U32_MAX) {\r\npr_err("%s: address range too large for %s\n", __func__,\r\nnode->name);\r\ngoto out_err;\r\n}\r\nccu->range = (u32)range;\r\nif (!ccu_data_valid(ccu)) {\r\npr_err("%s: ccu data not valid for %s\n", __func__, node->name);\r\ngoto out_err;\r\n}\r\nccu->base = ioremap(res.start, ccu->range);\r\nif (!ccu->base) {\r\npr_err("%s: unable to map CCU registers for %s\n", __func__,\r\nnode->name);\r\ngoto out_err;\r\n}\r\nccu->node = of_node_get(node);\r\nfor (i = 0; i < ccu->clk_data.clk_num; i++) {\r\nif (!ccu->kona_clks[i].ccu)\r\ncontinue;\r\nccu->clk_data.clks[i] = kona_clk_setup(&ccu->kona_clks[i]);\r\n}\r\nret = of_clk_add_provider(node, of_clk_src_onecell_get, &ccu->clk_data);\r\nif (ret) {\r\npr_err("%s: error adding ccu %s as provider (%d)\n", __func__,\r\nnode->name, ret);\r\ngoto out_err;\r\n}\r\nif (!kona_ccu_init(ccu))\r\npr_err("Broadcom %s initialization had errors\n", node->name);\r\nreturn;\r\nout_err:\r\nkona_ccu_teardown(ccu);\r\npr_err("Broadcom %s setup aborted\n", node->name);\r\n}
