acpi_status\r\nacpi_ex_get_object_reference(union acpi_operand_object *obj_desc,\r\nunion acpi_operand_object **return_desc,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\nunion acpi_operand_object *reference_obj;\r\nunion acpi_operand_object *referenced_obj;\r\nACPI_FUNCTION_TRACE_PTR(ex_get_object_reference, obj_desc);\r\n*return_desc = NULL;\r\nswitch (ACPI_GET_DESCRIPTOR_TYPE(obj_desc)) {\r\ncase ACPI_DESC_TYPE_OPERAND:\r\nif (obj_desc->common.type != ACPI_TYPE_LOCAL_REFERENCE) {\r\nreturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\r\n}\r\nswitch (obj_desc->reference.class) {\r\ncase ACPI_REFCLASS_LOCAL:\r\ncase ACPI_REFCLASS_ARG:\r\ncase ACPI_REFCLASS_DEBUG:\r\nreferenced_obj = obj_desc->reference.object;\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO, "Invalid Reference Class 0x%2.2X",\r\nobj_desc->reference.class));\r\nreturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\r\n}\r\nbreak;\r\ncase ACPI_DESC_TYPE_NAMED:\r\nreferenced_obj = obj_desc;\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO, "Invalid descriptor type 0x%X",\r\nACPI_GET_DESCRIPTOR_TYPE(obj_desc)));\r\nreturn_ACPI_STATUS(AE_TYPE);\r\n}\r\nreference_obj =\r\nacpi_ut_create_internal_object(ACPI_TYPE_LOCAL_REFERENCE);\r\nif (!reference_obj) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nreference_obj->reference.class = ACPI_REFCLASS_REFOF;\r\nreference_obj->reference.object = referenced_obj;\r\n*return_desc = reference_obj;\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Object %p Type [%s], returning Reference %p\n",\r\nobj_desc, acpi_ut_get_object_type_name(obj_desc),\r\n*return_desc));\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nu64 acpi_ex_do_math_op(u16 opcode, u64 integer0, u64 integer1)\r\n{\r\nACPI_FUNCTION_ENTRY();\r\nswitch (opcode) {\r\ncase AML_ADD_OP:\r\nreturn (integer0 + integer1);\r\ncase AML_BIT_AND_OP:\r\nreturn (integer0 & integer1);\r\ncase AML_BIT_NAND_OP:\r\nreturn (~(integer0 & integer1));\r\ncase AML_BIT_OR_OP:\r\nreturn (integer0 | integer1);\r\ncase AML_BIT_NOR_OP:\r\nreturn (~(integer0 | integer1));\r\ncase AML_BIT_XOR_OP:\r\nreturn (integer0 ^ integer1);\r\ncase AML_MULTIPLY_OP:\r\nreturn (integer0 * integer1);\r\ncase AML_SHIFT_LEFT_OP:\r\nif (integer1 >= acpi_gbl_integer_bit_width) {\r\nreturn (0);\r\n}\r\nreturn (integer0 << integer1);\r\ncase AML_SHIFT_RIGHT_OP:\r\nif (integer1 >= acpi_gbl_integer_bit_width) {\r\nreturn (0);\r\n}\r\nreturn (integer0 >> integer1);\r\ncase AML_SUBTRACT_OP:\r\nreturn (integer0 - integer1);\r\ndefault:\r\nreturn (0);\r\n}\r\n}\r\nacpi_status\r\nacpi_ex_do_logical_numeric_op(u16 opcode,\r\nu64 integer0, u64 integer1, u8 *logical_result)\r\n{\r\nacpi_status status = AE_OK;\r\nu8 local_result = FALSE;\r\nACPI_FUNCTION_TRACE(ex_do_logical_numeric_op);\r\nswitch (opcode) {\r\ncase AML_LAND_OP:\r\nif (integer0 && integer1) {\r\nlocal_result = TRUE;\r\n}\r\nbreak;\r\ncase AML_LOR_OP:\r\nif (integer0 || integer1) {\r\nlocal_result = TRUE;\r\n}\r\nbreak;\r\ndefault:\r\nstatus = AE_AML_INTERNAL;\r\nbreak;\r\n}\r\n*logical_result = local_result;\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ex_do_logical_op(u16 opcode,\r\nunion acpi_operand_object *operand0,\r\nunion acpi_operand_object *operand1, u8 * logical_result)\r\n{\r\nunion acpi_operand_object *local_operand1 = operand1;\r\nu64 integer0;\r\nu64 integer1;\r\nu32 length0;\r\nu32 length1;\r\nacpi_status status = AE_OK;\r\nu8 local_result = FALSE;\r\nint compare;\r\nACPI_FUNCTION_TRACE(ex_do_logical_op);\r\nswitch (operand0->common.type) {\r\ncase ACPI_TYPE_INTEGER:\r\nstatus =\r\nacpi_ex_convert_to_integer(operand1, &local_operand1, 16);\r\nbreak;\r\ncase ACPI_TYPE_STRING:\r\nstatus =\r\nacpi_ex_convert_to_string(operand1, &local_operand1,\r\nACPI_IMPLICIT_CONVERT_HEX);\r\nbreak;\r\ncase ACPI_TYPE_BUFFER:\r\nstatus = acpi_ex_convert_to_buffer(operand1, &local_operand1);\r\nbreak;\r\ndefault:\r\nstatus = AE_AML_INTERNAL;\r\nbreak;\r\n}\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup;\r\n}\r\nif (operand0->common.type == ACPI_TYPE_INTEGER) {\r\ninteger0 = operand0->integer.value;\r\ninteger1 = local_operand1->integer.value;\r\nswitch (opcode) {\r\ncase AML_LEQUAL_OP:\r\nif (integer0 == integer1) {\r\nlocal_result = TRUE;\r\n}\r\nbreak;\r\ncase AML_LGREATER_OP:\r\nif (integer0 > integer1) {\r\nlocal_result = TRUE;\r\n}\r\nbreak;\r\ncase AML_LLESS_OP:\r\nif (integer0 < integer1) {\r\nlocal_result = TRUE;\r\n}\r\nbreak;\r\ndefault:\r\nstatus = AE_AML_INTERNAL;\r\nbreak;\r\n}\r\n} else {\r\nlength0 = operand0->buffer.length;\r\nlength1 = local_operand1->buffer.length;\r\ncompare = memcmp(operand0->buffer.pointer,\r\nlocal_operand1->buffer.pointer,\r\n(length0 > length1) ? length1 : length0);\r\nswitch (opcode) {\r\ncase AML_LEQUAL_OP:\r\nif ((length0 == length1) && (compare == 0)) {\r\nlocal_result = TRUE;\r\n}\r\nbreak;\r\ncase AML_LGREATER_OP:\r\nif (compare > 0) {\r\nlocal_result = TRUE;\r\ngoto cleanup;\r\n}\r\nif (compare < 0) {\r\ngoto cleanup;\r\n}\r\nif (length0 > length1) {\r\nlocal_result = TRUE;\r\n}\r\nbreak;\r\ncase AML_LLESS_OP:\r\nif (compare > 0) {\r\ngoto cleanup;\r\n}\r\nif (compare < 0) {\r\nlocal_result = TRUE;\r\ngoto cleanup;\r\n}\r\nif (length0 < length1) {\r\nlocal_result = TRUE;\r\n}\r\nbreak;\r\ndefault:\r\nstatus = AE_AML_INTERNAL;\r\nbreak;\r\n}\r\n}\r\ncleanup:\r\nif (local_operand1 != operand1) {\r\nacpi_ut_remove_reference(local_operand1);\r\n}\r\n*logical_result = local_result;\r\nreturn_ACPI_STATUS(status);\r\n}
