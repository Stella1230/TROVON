static int em28xx_get_key_terratec(struct i2c_client *i2c_dev,\r\nenum rc_type *protocol, u32 *scancode)\r\n{\r\nunsigned char b;\r\nif (1 != i2c_master_recv(i2c_dev, &b, 1))\r\nreturn -EIO;\r\nif (b == 0xff)\r\nreturn 0;\r\nif (b == 0xfe)\r\nreturn 1;\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = b;\r\nreturn 1;\r\n}\r\nstatic int em28xx_get_key_em_haup(struct i2c_client *i2c_dev,\r\nenum rc_type *protocol, u32 *scancode)\r\n{\r\nunsigned char buf[2];\r\nint size;\r\nsize = i2c_master_recv(i2c_dev, buf, sizeof(buf));\r\nif (size != 2)\r\nreturn -EIO;\r\nif (buf[1] == 0xff)\r\nreturn 0;\r\n*protocol = RC_TYPE_RC5;\r\n*scancode = (bitrev8(buf[1]) & 0x1f) << 8 | bitrev8(buf[0]) >> 2;\r\nreturn 1;\r\n}\r\nstatic int em28xx_get_key_pinnacle_usb_grey(struct i2c_client *i2c_dev,\r\nenum rc_type *protocol, u32 *scancode)\r\n{\r\nunsigned char buf[3];\r\nif (3 != i2c_master_recv(i2c_dev, buf, 3))\r\nreturn -EIO;\r\nif (buf[0] != 0x00)\r\nreturn 0;\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = buf[2] & 0x3f;\r\nreturn 1;\r\n}\r\nstatic int em28xx_get_key_winfast_usbii_deluxe(struct i2c_client *i2c_dev,\r\nenum rc_type *protocol, u32 *scancode)\r\n{\r\nunsigned char subaddr, keydetect, key;\r\nstruct i2c_msg msg[] = { { .addr = i2c_dev->addr, .flags = 0, .buf = &subaddr, .len = 1},\r\n{ .addr = i2c_dev->addr, .flags = I2C_M_RD, .buf = &keydetect, .len = 1} };\r\nsubaddr = 0x10;\r\nif (2 != i2c_transfer(i2c_dev->adapter, msg, 2))\r\nreturn -EIO;\r\nif (keydetect == 0x00)\r\nreturn 0;\r\nsubaddr = 0x00;\r\nmsg[1].buf = &key;\r\nif (2 != i2c_transfer(i2c_dev->adapter, msg, 2))\r\nreturn -EIO;\r\nif (key == 0x00)\r\nreturn 0;\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = key;\r\nreturn 1;\r\n}\r\nstatic int default_polling_getkey(struct em28xx_IR *ir,\r\nstruct em28xx_ir_poll_result *poll_result)\r\n{\r\nstruct em28xx *dev = ir->dev;\r\nint rc;\r\nu8 msg[3] = { 0, 0, 0 };\r\nrc = dev->em28xx_read_reg_req_len(dev, 0, EM28XX_R45_IR,\r\nmsg, sizeof(msg));\r\nif (rc < 0)\r\nreturn rc;\r\npoll_result->toggle_bit = (msg[0] >> 7);\r\npoll_result->read_count = (msg[0] & 0x7f);\r\nswitch (ir->rc_type) {\r\ncase RC_BIT_RC5:\r\npoll_result->protocol = RC_TYPE_RC5;\r\npoll_result->scancode = RC_SCANCODE_RC5(msg[1], msg[2]);\r\nbreak;\r\ncase RC_BIT_NEC:\r\npoll_result->protocol = RC_TYPE_NEC;\r\npoll_result->scancode = RC_SCANCODE_NEC(msg[1], msg[2]);\r\nbreak;\r\ndefault:\r\npoll_result->protocol = RC_TYPE_UNKNOWN;\r\npoll_result->scancode = msg[1] << 8 | msg[2];\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int em2874_polling_getkey(struct em28xx_IR *ir,\r\nstruct em28xx_ir_poll_result *poll_result)\r\n{\r\nstruct em28xx *dev = ir->dev;\r\nint rc;\r\nu8 msg[5] = { 0, 0, 0, 0, 0 };\r\nrc = dev->em28xx_read_reg_req_len(dev, 0, EM2874_R51_IR,\r\nmsg, sizeof(msg));\r\nif (rc < 0)\r\nreturn rc;\r\npoll_result->toggle_bit = (msg[0] >> 7);\r\npoll_result->read_count = (msg[0] & 0x7f);\r\nswitch (ir->rc_type) {\r\ncase RC_BIT_RC5:\r\npoll_result->protocol = RC_TYPE_RC5;\r\npoll_result->scancode = RC_SCANCODE_RC5(msg[1], msg[2]);\r\nbreak;\r\ncase RC_BIT_NEC:\r\npoll_result->protocol = RC_TYPE_RC5;\r\npoll_result->scancode = msg[1] << 8 | msg[2];\r\nif ((msg[3] ^ msg[4]) != 0xff)\r\npoll_result->scancode = RC_SCANCODE_NEC32((msg[1] << 24) |\r\n(msg[2] << 16) |\r\n(msg[3] << 8) |\r\n(msg[4]));\r\nelse if ((msg[1] ^ msg[2]) != 0xff)\r\npoll_result->scancode = RC_SCANCODE_NECX(msg[1] << 8 |\r\nmsg[2], msg[3]);\r\nelse\r\npoll_result->scancode = RC_SCANCODE_NEC(msg[1], msg[3]);\r\nbreak;\r\ncase RC_BIT_RC6_0:\r\npoll_result->protocol = RC_TYPE_RC6_0;\r\npoll_result->scancode = RC_SCANCODE_RC6_0(msg[1], msg[2]);\r\nbreak;\r\ndefault:\r\npoll_result->protocol = RC_TYPE_UNKNOWN;\r\npoll_result->scancode = (msg[1] << 24) | (msg[2] << 16) |\r\n(msg[3] << 8) | msg[4];\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int em28xx_i2c_ir_handle_key(struct em28xx_IR *ir)\r\n{\r\nstatic u32 scancode;\r\nenum rc_type protocol;\r\nint rc;\r\nrc = ir->get_key_i2c(ir->i2c_client, &protocol, &scancode);\r\nif (rc < 0) {\r\ndprintk("ir->get_key_i2c() failed: %d\n", rc);\r\nreturn rc;\r\n}\r\nif (rc) {\r\ndprintk("%s: proto = 0x%04x, scancode = 0x%04x\n",\r\n__func__, protocol, scancode);\r\nrc_keydown(ir->rc, protocol, scancode, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void em28xx_ir_handle_key(struct em28xx_IR *ir)\r\n{\r\nint result;\r\nstruct em28xx_ir_poll_result poll_result;\r\nresult = ir->get_key(ir, &poll_result);\r\nif (unlikely(result < 0)) {\r\ndprintk("ir->get_key() failed: %d\n", result);\r\nreturn;\r\n}\r\nif (unlikely(poll_result.read_count != ir->last_readcount)) {\r\ndprintk("%s: toggle: %d, count: %d, key 0x%04x\n", __func__,\r\npoll_result.toggle_bit, poll_result.read_count,\r\npoll_result.scancode);\r\nif (ir->full_code)\r\nrc_keydown(ir->rc,\r\npoll_result.protocol,\r\npoll_result.scancode,\r\npoll_result.toggle_bit);\r\nelse\r\nrc_keydown(ir->rc,\r\nRC_TYPE_UNKNOWN,\r\npoll_result.scancode & 0xff,\r\npoll_result.toggle_bit);\r\nif (ir->dev->chip_id == CHIP_ID_EM2874 ||\r\nir->dev->chip_id == CHIP_ID_EM2884)\r\nir->last_readcount = 0;\r\nelse\r\nir->last_readcount = poll_result.read_count;\r\n}\r\n}\r\nstatic void em28xx_ir_work(struct work_struct *work)\r\n{\r\nstruct em28xx_IR *ir = container_of(work, struct em28xx_IR, work.work);\r\nif (ir->i2c_client)\r\nem28xx_i2c_ir_handle_key(ir);\r\nelse\r\nem28xx_ir_handle_key(ir);\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\r\n}\r\nstatic int em28xx_ir_start(struct rc_dev *rc)\r\n{\r\nstruct em28xx_IR *ir = rc->priv;\r\nINIT_DELAYED_WORK(&ir->work, em28xx_ir_work);\r\nschedule_delayed_work(&ir->work, 0);\r\nreturn 0;\r\n}\r\nstatic void em28xx_ir_stop(struct rc_dev *rc)\r\n{\r\nstruct em28xx_IR *ir = rc->priv;\r\ncancel_delayed_work_sync(&ir->work);\r\n}\r\nstatic int em2860_ir_change_protocol(struct rc_dev *rc_dev, u64 *rc_type)\r\n{\r\nstruct em28xx_IR *ir = rc_dev->priv;\r\nstruct em28xx *dev = ir->dev;\r\nif (*rc_type & RC_BIT_RC5) {\r\ndev->board.xclk |= EM28XX_XCLK_IR_RC5_MODE;\r\nir->full_code = 1;\r\n*rc_type = RC_BIT_RC5;\r\n} else if (*rc_type & RC_BIT_NEC) {\r\ndev->board.xclk &= ~EM28XX_XCLK_IR_RC5_MODE;\r\nir->full_code = 1;\r\n*rc_type = RC_BIT_NEC;\r\n} else if (*rc_type & RC_BIT_UNKNOWN) {\r\n*rc_type = RC_BIT_UNKNOWN;\r\n} else {\r\n*rc_type = ir->rc_type;\r\nreturn -EINVAL;\r\n}\r\nem28xx_write_reg_bits(dev, EM28XX_R0F_XCLK, dev->board.xclk,\r\nEM28XX_XCLK_IR_RC5_MODE);\r\nir->rc_type = *rc_type;\r\nreturn 0;\r\n}\r\nstatic int em2874_ir_change_protocol(struct rc_dev *rc_dev, u64 *rc_type)\r\n{\r\nstruct em28xx_IR *ir = rc_dev->priv;\r\nstruct em28xx *dev = ir->dev;\r\nu8 ir_config = EM2874_IR_RC5;\r\nif (*rc_type & RC_BIT_RC5) {\r\ndev->board.xclk |= EM28XX_XCLK_IR_RC5_MODE;\r\nir->full_code = 1;\r\n*rc_type = RC_BIT_RC5;\r\n} else if (*rc_type & RC_BIT_NEC) {\r\ndev->board.xclk &= ~EM28XX_XCLK_IR_RC5_MODE;\r\nir_config = EM2874_IR_NEC | EM2874_IR_NEC_NO_PARITY;\r\nir->full_code = 1;\r\n*rc_type = RC_BIT_NEC;\r\n} else if (*rc_type & RC_BIT_RC6_0) {\r\ndev->board.xclk |= EM28XX_XCLK_IR_RC5_MODE;\r\nir_config = EM2874_IR_RC6_MODE_0;\r\nir->full_code = 1;\r\n*rc_type = RC_BIT_RC6_0;\r\n} else if (*rc_type & RC_BIT_UNKNOWN) {\r\n*rc_type = RC_BIT_UNKNOWN;\r\n} else {\r\n*rc_type = ir->rc_type;\r\nreturn -EINVAL;\r\n}\r\nem28xx_write_regs(dev, EM2874_R50_IR_CONFIG, &ir_config, 1);\r\nem28xx_write_reg_bits(dev, EM28XX_R0F_XCLK, dev->board.xclk,\r\nEM28XX_XCLK_IR_RC5_MODE);\r\nir->rc_type = *rc_type;\r\nreturn 0;\r\n}\r\nstatic int em28xx_ir_change_protocol(struct rc_dev *rc_dev, u64 *rc_type)\r\n{\r\nstruct em28xx_IR *ir = rc_dev->priv;\r\nstruct em28xx *dev = ir->dev;\r\nswitch (dev->chip_id) {\r\ncase CHIP_ID_EM2860:\r\ncase CHIP_ID_EM2883:\r\nreturn em2860_ir_change_protocol(rc_dev, rc_type);\r\ncase CHIP_ID_EM2884:\r\ncase CHIP_ID_EM2874:\r\ncase CHIP_ID_EM28174:\r\ncase CHIP_ID_EM28178:\r\nreturn em2874_ir_change_protocol(rc_dev, rc_type);\r\ndefault:\r\nprintk("Unrecognized em28xx chip id 0x%02x: IR not supported\n",\r\ndev->chip_id);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int em28xx_probe_i2c_ir(struct em28xx *dev)\r\n{\r\nint i = 0;\r\nconst unsigned short addr_list[] = {\r\n0x1f, 0x30, 0x47, I2C_CLIENT_END\r\n};\r\nwhile (addr_list[i] != I2C_CLIENT_END) {\r\nif (i2c_probe_func_quick_read(&dev->i2c_adap[dev->def_i2c_bus], addr_list[i]) == 1)\r\nreturn addr_list[i];\r\ni++;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void em28xx_query_buttons(struct work_struct *work)\r\n{\r\nstruct em28xx *dev =\r\ncontainer_of(work, struct em28xx, buttons_query_work.work);\r\nu8 i, j;\r\nint regval;\r\nbool is_pressed, was_pressed;\r\nconst struct em28xx_led *led;\r\nfor (i = 0; i < dev->num_button_polling_addresses; i++) {\r\nregval = em28xx_read_reg(dev, dev->button_polling_addresses[i]);\r\nif (regval < 0)\r\ncontinue;\r\nj = 0;\r\nwhile (dev->board.buttons[j].role >= 0 &&\r\ndev->board.buttons[j].role < EM28XX_NUM_BUTTON_ROLES) {\r\nstruct em28xx_button *button = &dev->board.buttons[j];\r\nif (button->reg_r != dev->button_polling_addresses[i]) {\r\nj++;\r\ncontinue;\r\n}\r\nis_pressed = regval & button->mask;\r\nwas_pressed = dev->button_polling_last_values[i]\r\n& button->mask;\r\nif (button->inverted) {\r\nis_pressed = !is_pressed;\r\nwas_pressed = !was_pressed;\r\n}\r\nif (is_pressed && button->reg_clearing)\r\nem28xx_write_reg(dev, button->reg_clearing,\r\n(~regval & button->mask)\r\n| (regval & ~button->mask));\r\nif (!is_pressed || was_pressed) {\r\nj++;\r\ncontinue;\r\n}\r\nswitch (button->role) {\r\ncase EM28XX_BUTTON_SNAPSHOT:\r\ninput_report_key(dev->sbutton_input_dev,\r\nEM28XX_SNAPSHOT_KEY, 1);\r\ninput_report_key(dev->sbutton_input_dev,\r\nEM28XX_SNAPSHOT_KEY, 0);\r\nbreak;\r\ncase EM28XX_BUTTON_ILLUMINATION:\r\nled = em28xx_find_led(dev,\r\nEM28XX_LED_ILLUMINATION);\r\nif (led)\r\nem28xx_toggle_reg_bits(dev,\r\nled->gpio_reg,\r\nled->gpio_mask);\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "BUG: unhandled button role.");\r\n}\r\nj++;\r\n}\r\ndev->button_polling_last_values[i] = regval;\r\n}\r\nschedule_delayed_work(&dev->buttons_query_work,\r\nmsecs_to_jiffies(dev->button_polling_interval));\r\n}\r\nstatic int em28xx_register_snapshot_button(struct em28xx *dev)\r\n{\r\nstruct input_dev *input_dev;\r\nint err;\r\nem28xx_info("Registering snapshot button...\n");\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nusb_make_path(dev->udev, dev->snapshot_button_path,\r\nsizeof(dev->snapshot_button_path));\r\nstrlcat(dev->snapshot_button_path, "/sbutton",\r\nsizeof(dev->snapshot_button_path));\r\ninput_dev->name = "em28xx snapshot button";\r\ninput_dev->phys = dev->snapshot_button_path;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\r\nset_bit(EM28XX_SNAPSHOT_KEY, input_dev->keybit);\r\ninput_dev->keycodesize = 0;\r\ninput_dev->keycodemax = 0;\r\ninput_dev->id.bustype = BUS_USB;\r\ninput_dev->id.vendor = le16_to_cpu(dev->udev->descriptor.idVendor);\r\ninput_dev->id.product = le16_to_cpu(dev->udev->descriptor.idProduct);\r\ninput_dev->id.version = 1;\r\ninput_dev->dev.parent = &dev->udev->dev;\r\nerr = input_register_device(input_dev);\r\nif (err) {\r\nem28xx_errdev("input_register_device failed\n");\r\ninput_free_device(input_dev);\r\nreturn err;\r\n}\r\ndev->sbutton_input_dev = input_dev;\r\nreturn 0;\r\n}\r\nstatic void em28xx_init_buttons(struct em28xx *dev)\r\n{\r\nu8 i = 0, j = 0;\r\nbool addr_new = false;\r\ndev->button_polling_interval = EM28XX_BUTTONS_DEBOUNCED_QUERY_INTERVAL;\r\nwhile (dev->board.buttons[i].role >= 0 &&\r\ndev->board.buttons[i].role < EM28XX_NUM_BUTTON_ROLES) {\r\nstruct em28xx_button *button = &dev->board.buttons[i];\r\naddr_new = true;\r\nfor (j = 0; j < dev->num_button_polling_addresses; j++) {\r\nif (button->reg_r == dev->button_polling_addresses[j]) {\r\naddr_new = false;\r\nbreak;\r\n}\r\n}\r\nif (addr_new && dev->num_button_polling_addresses\r\n>= EM28XX_NUM_BUTTON_ADDRESSES_MAX) {\r\nWARN_ONCE(1, "BUG: maximum number of button polling addresses exceeded.");\r\ngoto next_button;\r\n}\r\nif (button->role == EM28XX_BUTTON_SNAPSHOT) {\r\nif (em28xx_register_snapshot_button(dev) < 0)\r\ngoto next_button;\r\n} else if (button->role == EM28XX_BUTTON_ILLUMINATION) {\r\nif (!em28xx_find_led(dev, EM28XX_LED_ILLUMINATION)) {\r\nem28xx_errdev("BUG: illumination button defined, but no illumination LED.\n");\r\ngoto next_button;\r\n}\r\n}\r\nif (addr_new) {\r\nunsigned int index = dev->num_button_polling_addresses;\r\ndev->button_polling_addresses[index] = button->reg_r;\r\ndev->num_button_polling_addresses++;\r\n}\r\nif (!button->reg_clearing)\r\ndev->button_polling_interval =\r\nEM28XX_BUTTONS_VOLATILE_QUERY_INTERVAL;\r\nnext_button:\r\ni++;\r\n}\r\nif (dev->num_button_polling_addresses) {\r\nmemset(dev->button_polling_last_values, 0,\r\nEM28XX_NUM_BUTTON_ADDRESSES_MAX);\r\nschedule_delayed_work(&dev->buttons_query_work,\r\nmsecs_to_jiffies(dev->button_polling_interval));\r\n}\r\n}\r\nstatic void em28xx_shutdown_buttons(struct em28xx *dev)\r\n{\r\ncancel_delayed_work_sync(&dev->buttons_query_work);\r\ndev->num_button_polling_addresses = 0;\r\nif (dev->sbutton_input_dev != NULL) {\r\nem28xx_info("Deregistering snapshot button\n");\r\ninput_unregister_device(dev->sbutton_input_dev);\r\ndev->sbutton_input_dev = NULL;\r\n}\r\n}\r\nstatic int em28xx_ir_init(struct em28xx *dev)\r\n{\r\nstruct em28xx_IR *ir;\r\nstruct rc_dev *rc;\r\nint err = -ENOMEM;\r\nu64 rc_type;\r\nu16 i2c_rc_dev_addr = 0;\r\nif (dev->is_audio_only) {\r\nreturn 0;\r\n}\r\nkref_get(&dev->ref);\r\nINIT_DELAYED_WORK(&dev->buttons_query_work, em28xx_query_buttons);\r\nif (dev->board.buttons)\r\nem28xx_init_buttons(dev);\r\nif (dev->board.has_ir_i2c) {\r\ni2c_rc_dev_addr = em28xx_probe_i2c_ir(dev);\r\nif (!i2c_rc_dev_addr) {\r\ndev->board.has_ir_i2c = 0;\r\nem28xx_warn("No i2c IR remote control device found.\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (dev->board.ir_codes == NULL && !dev->board.has_ir_i2c) {\r\nem28xx_warn("Remote control support is not available for "\r\n"this card.\n");\r\nreturn 0;\r\n}\r\nem28xx_info("Registering input extension\n");\r\nir = kzalloc(sizeof(*ir), GFP_KERNEL);\r\nif (!ir)\r\nreturn -ENOMEM;\r\nrc = rc_allocate_device();\r\nif (!rc)\r\ngoto error;\r\nir->dev = dev;\r\ndev->ir = ir;\r\nir->rc = rc;\r\nrc->priv = ir;\r\nrc->open = em28xx_ir_start;\r\nrc->close = em28xx_ir_stop;\r\nif (dev->board.has_ir_i2c) {\r\nswitch (dev->model) {\r\ncase EM2800_BOARD_TERRATEC_CINERGY_200:\r\ncase EM2820_BOARD_TERRATEC_CINERGY_250:\r\nrc->map_name = RC_MAP_EM_TERRATEC;\r\nir->get_key_i2c = em28xx_get_key_terratec;\r\nbreak;\r\ncase EM2820_BOARD_PINNACLE_USB_2:\r\nrc->map_name = RC_MAP_PINNACLE_GREY;\r\nir->get_key_i2c = em28xx_get_key_pinnacle_usb_grey;\r\nbreak;\r\ncase EM2820_BOARD_HAUPPAUGE_WINTV_USB_2:\r\nrc->map_name = RC_MAP_HAUPPAUGE;\r\nir->get_key_i2c = em28xx_get_key_em_haup;\r\nrc->allowed_protocols = RC_BIT_RC5;\r\nbreak;\r\ncase EM2820_BOARD_LEADTEK_WINFAST_USBII_DELUXE:\r\nrc->map_name = RC_MAP_WINFAST_USBII_DELUXE;\r\nir->get_key_i2c = em28xx_get_key_winfast_usbii_deluxe;\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nir->i2c_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);\r\nif (!ir->i2c_client)\r\ngoto error;\r\nir->i2c_client->adapter = &ir->dev->i2c_adap[dev->def_i2c_bus];\r\nir->i2c_client->addr = i2c_rc_dev_addr;\r\nir->i2c_client->flags = 0;\r\n} else {\r\nswitch (dev->chip_id) {\r\ncase CHIP_ID_EM2860:\r\ncase CHIP_ID_EM2883:\r\nrc->allowed_protocols = RC_BIT_RC5 | RC_BIT_NEC;\r\nir->get_key = default_polling_getkey;\r\nbreak;\r\ncase CHIP_ID_EM2884:\r\ncase CHIP_ID_EM2874:\r\ncase CHIP_ID_EM28174:\r\ncase CHIP_ID_EM28178:\r\nir->get_key = em2874_polling_getkey;\r\nrc->allowed_protocols = RC_BIT_RC5 | RC_BIT_NEC |\r\nRC_BIT_RC6_0;\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nrc->change_protocol = em28xx_ir_change_protocol;\r\nrc->map_name = dev->board.ir_codes;\r\nrc_type = RC_BIT_UNKNOWN;\r\nerr = em28xx_ir_change_protocol(rc, &rc_type);\r\nif (err)\r\ngoto error;\r\n}\r\nir->polling = 100;\r\nsnprintf(ir->name, sizeof(ir->name), "em28xx IR (%s)", dev->name);\r\nusb_make_path(dev->udev, ir->phys, sizeof(ir->phys));\r\nstrlcat(ir->phys, "/input0", sizeof(ir->phys));\r\nrc->input_name = ir->name;\r\nrc->input_phys = ir->phys;\r\nrc->input_id.bustype = BUS_USB;\r\nrc->input_id.version = 1;\r\nrc->input_id.vendor = le16_to_cpu(dev->udev->descriptor.idVendor);\r\nrc->input_id.product = le16_to_cpu(dev->udev->descriptor.idProduct);\r\nrc->dev.parent = &dev->udev->dev;\r\nrc->driver_name = MODULE_NAME;\r\nerr = rc_register_device(rc);\r\nif (err)\r\ngoto error;\r\nem28xx_info("Input extension successfully initalized\n");\r\nreturn 0;\r\nerror:\r\nkfree(ir->i2c_client);\r\ndev->ir = NULL;\r\nrc_free_device(rc);\r\nkfree(ir);\r\nreturn err;\r\n}\r\nstatic int em28xx_ir_fini(struct em28xx *dev)\r\n{\r\nstruct em28xx_IR *ir = dev->ir;\r\nif (dev->is_audio_only) {\r\nreturn 0;\r\n}\r\nem28xx_info("Closing input extension\n");\r\nem28xx_shutdown_buttons(dev);\r\nif (!ir)\r\ngoto ref_put;\r\nrc_unregister_device(ir->rc);\r\nkfree(ir->i2c_client);\r\nkfree(ir);\r\ndev->ir = NULL;\r\nref_put:\r\nkref_put(&dev->ref, em28xx_free_device);\r\nreturn 0;\r\n}\r\nstatic int em28xx_ir_suspend(struct em28xx *dev)\r\n{\r\nstruct em28xx_IR *ir = dev->ir;\r\nif (dev->is_audio_only)\r\nreturn 0;\r\nem28xx_info("Suspending input extension\n");\r\nif (ir)\r\ncancel_delayed_work_sync(&ir->work);\r\ncancel_delayed_work_sync(&dev->buttons_query_work);\r\nreturn 0;\r\n}\r\nstatic int em28xx_ir_resume(struct em28xx *dev)\r\n{\r\nstruct em28xx_IR *ir = dev->ir;\r\nif (dev->is_audio_only)\r\nreturn 0;\r\nem28xx_info("Resuming input extension\n");\r\nif (ir)\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\r\nif (dev->num_button_polling_addresses)\r\nschedule_delayed_work(&dev->buttons_query_work,\r\nmsecs_to_jiffies(dev->button_polling_interval));\r\nreturn 0;\r\n}\r\nstatic int __init em28xx_rc_register(void)\r\n{\r\nreturn em28xx_register_extension(&rc_ops);\r\n}\r\nstatic void __exit em28xx_rc_unregister(void)\r\n{\r\nem28xx_unregister_extension(&rc_ops);\r\n}
