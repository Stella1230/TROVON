static unsigned int\r\nreject_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ipt_reject_info *reject = par->targinfo;\r\nint hook = par->hooknum;\r\nswitch (reject->with) {\r\ncase IPT_ICMP_NET_UNREACHABLE:\r\nnf_send_unreach(skb, ICMP_NET_UNREACH, hook);\r\nbreak;\r\ncase IPT_ICMP_HOST_UNREACHABLE:\r\nnf_send_unreach(skb, ICMP_HOST_UNREACH, hook);\r\nbreak;\r\ncase IPT_ICMP_PROT_UNREACHABLE:\r\nnf_send_unreach(skb, ICMP_PROT_UNREACH, hook);\r\nbreak;\r\ncase IPT_ICMP_PORT_UNREACHABLE:\r\nnf_send_unreach(skb, ICMP_PORT_UNREACH, hook);\r\nbreak;\r\ncase IPT_ICMP_NET_PROHIBITED:\r\nnf_send_unreach(skb, ICMP_NET_ANO, hook);\r\nbreak;\r\ncase IPT_ICMP_HOST_PROHIBITED:\r\nnf_send_unreach(skb, ICMP_HOST_ANO, hook);\r\nbreak;\r\ncase IPT_ICMP_ADMIN_PROHIBITED:\r\nnf_send_unreach(skb, ICMP_PKT_FILTERED, hook);\r\nbreak;\r\ncase IPT_TCP_RESET:\r\nnf_send_reset(par->net, skb, hook);\r\ncase IPT_ICMP_ECHOREPLY:\r\nbreak;\r\n}\r\nreturn NF_DROP;\r\n}\r\nstatic int reject_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ipt_reject_info *rejinfo = par->targinfo;\r\nconst struct ipt_entry *e = par->entryinfo;\r\nif (rejinfo->with == IPT_ICMP_ECHOREPLY) {\r\npr_info("ECHOREPLY no longer supported.\n");\r\nreturn -EINVAL;\r\n} else if (rejinfo->with == IPT_TCP_RESET) {\r\nif (e->ip.proto != IPPROTO_TCP ||\r\n(e->ip.invflags & XT_INV_PROTO)) {\r\npr_info("TCP_RESET invalid for non-tcp\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init reject_tg_init(void)\r\n{\r\nreturn xt_register_target(&reject_tg_reg);\r\n}\r\nstatic void __exit reject_tg_exit(void)\r\n{\r\nxt_unregister_target(&reject_tg_reg);\r\n}
