static int lpc18xx_rgu_restart(struct notifier_block *nb, unsigned long mode,\r\nvoid *cmd)\r\n{\r\nstruct lpc18xx_rgu_data *rc = container_of(nb, struct lpc18xx_rgu_data,\r\nrestart_nb);\r\nwritel(BIT(LPC18XX_RGU_CORE_RST), rc->base + LPC18XX_RGU_CTRL0);\r\nmdelay(2000);\r\npr_emerg("%s: unable to restart system\n", __func__);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int lpc18xx_rgu_setclear_reset(struct reset_controller_dev *rcdev,\r\nunsigned long id, bool set)\r\n{\r\nstruct lpc18xx_rgu_data *rc = to_rgu_data(rcdev);\r\nu32 stat_offset = LPC18XX_RGU_ACTIVE_STATUS0;\r\nu32 ctrl_offset = LPC18XX_RGU_CTRL0;\r\nunsigned long flags;\r\nu32 stat, rst_bit;\r\nstat_offset += (id / LPC18XX_RGU_RESETS_PER_REG) * sizeof(u32);\r\nctrl_offset += (id / LPC18XX_RGU_RESETS_PER_REG) * sizeof(u32);\r\nrst_bit = 1 << (id % LPC18XX_RGU_RESETS_PER_REG);\r\nspin_lock_irqsave(&rc->lock, flags);\r\nstat = ~readl(rc->base + stat_offset);\r\nif (set)\r\nwritel(stat | rst_bit, rc->base + ctrl_offset);\r\nelse\r\nwritel(stat & ~rst_bit, rc->base + ctrl_offset);\r\nspin_unlock_irqrestore(&rc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_rgu_assert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nreturn lpc18xx_rgu_setclear_reset(rcdev, id, true);\r\n}\r\nstatic int lpc18xx_rgu_deassert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nreturn lpc18xx_rgu_setclear_reset(rcdev, id, false);\r\n}\r\nstatic int lpc18xx_rgu_reset(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct lpc18xx_rgu_data *rc = to_rgu_data(rcdev);\r\nlpc18xx_rgu_assert(rcdev, id);\r\nudelay(rc->delay_us);\r\nswitch (id) {\r\ncase LPC43XX_RGU_M0SUB_RST:\r\ncase LPC43XX_RGU_M0APP_RST:\r\nlpc18xx_rgu_setclear_reset(rcdev, id, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_rgu_status(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct lpc18xx_rgu_data *rc = to_rgu_data(rcdev);\r\nu32 bit, offset = LPC18XX_RGU_ACTIVE_STATUS0;\r\noffset += (id / LPC18XX_RGU_RESETS_PER_REG) * sizeof(u32);\r\nbit = 1 << (id % LPC18XX_RGU_RESETS_PER_REG);\r\nreturn !(readl(rc->base + offset) & bit);\r\n}\r\nstatic int lpc18xx_rgu_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc18xx_rgu_data *rc;\r\nstruct resource *res;\r\nu32 fcclk, firc;\r\nint ret;\r\nrc = devm_kzalloc(&pdev->dev, sizeof(*rc), GFP_KERNEL);\r\nif (!rc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrc->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rc->base))\r\nreturn PTR_ERR(rc->base);\r\nrc->clk_reg = devm_clk_get(&pdev->dev, "reg");\r\nif (IS_ERR(rc->clk_reg)) {\r\ndev_err(&pdev->dev, "reg clock not found\n");\r\nreturn PTR_ERR(rc->clk_reg);\r\n}\r\nrc->clk_delay = devm_clk_get(&pdev->dev, "delay");\r\nif (IS_ERR(rc->clk_delay)) {\r\ndev_err(&pdev->dev, "delay clock not found\n");\r\nreturn PTR_ERR(rc->clk_delay);\r\n}\r\nret = clk_prepare_enable(rc->clk_reg);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to enable reg clock\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(rc->clk_delay);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to enable delay clock\n");\r\ngoto dis_clk_reg;\r\n}\r\nfcclk = clk_get_rate(rc->clk_reg) / USEC_PER_SEC;\r\nfirc = clk_get_rate(rc->clk_delay) / USEC_PER_SEC;\r\nif (fcclk == 0 || firc == 0)\r\nrc->delay_us = 2;\r\nelse\r\nrc->delay_us = DIV_ROUND_UP(fcclk, firc * firc);\r\nspin_lock_init(&rc->lock);\r\nrc->rcdev.owner = THIS_MODULE;\r\nrc->rcdev.nr_resets = 64;\r\nrc->rcdev.ops = &lpc18xx_rgu_ops;\r\nrc->rcdev.of_node = pdev->dev.of_node;\r\nplatform_set_drvdata(pdev, rc);\r\nret = reset_controller_register(&rc->rcdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to register device\n");\r\ngoto dis_clks;\r\n}\r\nrc->restart_nb.priority = 192,\r\nrc->restart_nb.notifier_call = lpc18xx_rgu_restart,\r\nret = register_restart_handler(&rc->restart_nb);\r\nif (ret)\r\ndev_warn(&pdev->dev, "failed to register restart handler\n");\r\nreturn 0;\r\ndis_clks:\r\nclk_disable_unprepare(rc->clk_delay);\r\ndis_clk_reg:\r\nclk_disable_unprepare(rc->clk_reg);\r\nreturn ret;\r\n}\r\nstatic int lpc18xx_rgu_remove(struct platform_device *pdev)\r\n{\r\nstruct lpc18xx_rgu_data *rc = platform_get_drvdata(pdev);\r\nint ret;\r\nret = unregister_restart_handler(&rc->restart_nb);\r\nif (ret)\r\ndev_warn(&pdev->dev, "failed to unregister restart handler\n");\r\nreset_controller_unregister(&rc->rcdev);\r\nclk_disable_unprepare(rc->clk_delay);\r\nclk_disable_unprepare(rc->clk_reg);\r\nreturn 0;\r\n}
