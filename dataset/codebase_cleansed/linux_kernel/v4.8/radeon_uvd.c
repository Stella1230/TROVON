int radeon_uvd_init(struct radeon_device *rdev)\r\n{\r\nunsigned long bo_size;\r\nconst char *fw_name = NULL, *legacy_fw_name = NULL;\r\nint i, r;\r\nINIT_DELAYED_WORK(&rdev->uvd.idle_work, radeon_uvd_idle_work_handler);\r\nswitch (rdev->family) {\r\ncase CHIP_RV610:\r\ncase CHIP_RV630:\r\ncase CHIP_RV670:\r\ncase CHIP_RV620:\r\ncase CHIP_RV635:\r\nlegacy_fw_name = FIRMWARE_R600;\r\nbreak;\r\ncase CHIP_RS780:\r\ncase CHIP_RS880:\r\nlegacy_fw_name = FIRMWARE_RS780;\r\nbreak;\r\ncase CHIP_RV770:\r\nlegacy_fw_name = FIRMWARE_RV770;\r\nbreak;\r\ncase CHIP_RV710:\r\ncase CHIP_RV730:\r\ncase CHIP_RV740:\r\nlegacy_fw_name = FIRMWARE_RV710;\r\nbreak;\r\ncase CHIP_CYPRESS:\r\ncase CHIP_HEMLOCK:\r\ncase CHIP_JUNIPER:\r\ncase CHIP_REDWOOD:\r\ncase CHIP_CEDAR:\r\nlegacy_fw_name = FIRMWARE_CYPRESS;\r\nbreak;\r\ncase CHIP_SUMO:\r\ncase CHIP_SUMO2:\r\ncase CHIP_PALM:\r\ncase CHIP_CAYMAN:\r\ncase CHIP_BARTS:\r\ncase CHIP_TURKS:\r\ncase CHIP_CAICOS:\r\nlegacy_fw_name = FIRMWARE_SUMO;\r\nbreak;\r\ncase CHIP_TAHITI:\r\ncase CHIP_VERDE:\r\ncase CHIP_PITCAIRN:\r\ncase CHIP_ARUBA:\r\ncase CHIP_OLAND:\r\nlegacy_fw_name = FIRMWARE_TAHITI;\r\nbreak;\r\ncase CHIP_BONAIRE:\r\ncase CHIP_KABINI:\r\ncase CHIP_KAVERI:\r\ncase CHIP_HAWAII:\r\ncase CHIP_MULLINS:\r\nlegacy_fw_name = FIRMWARE_BONAIRE_LEGACY;\r\nfw_name = FIRMWARE_BONAIRE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrdev->uvd.fw_header_present = false;\r\nrdev->uvd.max_handles = RADEON_DEFAULT_UVD_HANDLES;\r\nif (fw_name) {\r\nr = request_firmware(&rdev->uvd_fw, fw_name, rdev->dev);\r\nif (r) {\r\ndev_err(rdev->dev, "radeon_uvd: Can't load firmware \"%s\"\n",\r\nfw_name);\r\n} else {\r\nstruct common_firmware_header *hdr = (void *)rdev->uvd_fw->data;\r\nunsigned version_major, version_minor, family_id;\r\nr = radeon_ucode_validate(rdev->uvd_fw);\r\nif (r)\r\nreturn r;\r\nrdev->uvd.fw_header_present = true;\r\nfamily_id = le32_to_cpu(hdr->ucode_version) & 0xff;\r\nversion_major = (le32_to_cpu(hdr->ucode_version) >> 24) & 0xff;\r\nversion_minor = (le32_to_cpu(hdr->ucode_version) >> 8) & 0xff;\r\nDRM_INFO("Found UVD firmware Version: %hu.%hu Family ID: %hu\n",\r\nversion_major, version_minor, family_id);\r\nif ((version_major >= 0x01) && (version_minor >= 0x37))\r\nrdev->uvd.max_handles = RADEON_MAX_UVD_HANDLES;\r\n}\r\n}\r\nif (!fw_name || r) {\r\nr = request_firmware(&rdev->uvd_fw, legacy_fw_name, rdev->dev);\r\nif (r) {\r\ndev_err(rdev->dev, "radeon_uvd: Can't load firmware \"%s\"\n",\r\nlegacy_fw_name);\r\nreturn r;\r\n}\r\n}\r\nbo_size = RADEON_GPU_PAGE_ALIGN(rdev->uvd_fw->size + 8) +\r\nRADEON_UVD_STACK_SIZE + RADEON_UVD_HEAP_SIZE +\r\nRADEON_UVD_SESSION_SIZE * rdev->uvd.max_handles;\r\nr = radeon_bo_create(rdev, bo_size, PAGE_SIZE, true,\r\nRADEON_GEM_DOMAIN_VRAM, 0, NULL,\r\nNULL, &rdev->uvd.vcpu_bo);\r\nif (r) {\r\ndev_err(rdev->dev, "(%d) failed to allocate UVD bo\n", r);\r\nreturn r;\r\n}\r\nr = radeon_bo_reserve(rdev->uvd.vcpu_bo, false);\r\nif (r) {\r\nradeon_bo_unref(&rdev->uvd.vcpu_bo);\r\ndev_err(rdev->dev, "(%d) failed to reserve UVD bo\n", r);\r\nreturn r;\r\n}\r\nr = radeon_bo_pin(rdev->uvd.vcpu_bo, RADEON_GEM_DOMAIN_VRAM,\r\n&rdev->uvd.gpu_addr);\r\nif (r) {\r\nradeon_bo_unreserve(rdev->uvd.vcpu_bo);\r\nradeon_bo_unref(&rdev->uvd.vcpu_bo);\r\ndev_err(rdev->dev, "(%d) UVD bo pin failed\n", r);\r\nreturn r;\r\n}\r\nr = radeon_bo_kmap(rdev->uvd.vcpu_bo, &rdev->uvd.cpu_addr);\r\nif (r) {\r\ndev_err(rdev->dev, "(%d) UVD map failed\n", r);\r\nreturn r;\r\n}\r\nradeon_bo_unreserve(rdev->uvd.vcpu_bo);\r\nfor (i = 0; i < rdev->uvd.max_handles; ++i) {\r\natomic_set(&rdev->uvd.handles[i], 0);\r\nrdev->uvd.filp[i] = NULL;\r\nrdev->uvd.img_size[i] = 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_uvd_fini(struct radeon_device *rdev)\r\n{\r\nint r;\r\nif (rdev->uvd.vcpu_bo == NULL)\r\nreturn;\r\nr = radeon_bo_reserve(rdev->uvd.vcpu_bo, false);\r\nif (!r) {\r\nradeon_bo_kunmap(rdev->uvd.vcpu_bo);\r\nradeon_bo_unpin(rdev->uvd.vcpu_bo);\r\nradeon_bo_unreserve(rdev->uvd.vcpu_bo);\r\n}\r\nradeon_bo_unref(&rdev->uvd.vcpu_bo);\r\nradeon_ring_fini(rdev, &rdev->ring[R600_RING_TYPE_UVD_INDEX]);\r\nrelease_firmware(rdev->uvd_fw);\r\n}\r\nint radeon_uvd_suspend(struct radeon_device *rdev)\r\n{\r\nint i, r;\r\nif (rdev->uvd.vcpu_bo == NULL)\r\nreturn 0;\r\nfor (i = 0; i < rdev->uvd.max_handles; ++i) {\r\nuint32_t handle = atomic_read(&rdev->uvd.handles[i]);\r\nif (handle != 0) {\r\nstruct radeon_fence *fence;\r\nradeon_uvd_note_usage(rdev);\r\nr = radeon_uvd_get_destroy_msg(rdev,\r\nR600_RING_TYPE_UVD_INDEX, handle, &fence);\r\nif (r) {\r\nDRM_ERROR("Error destroying UVD (%d)!\n", r);\r\ncontinue;\r\n}\r\nradeon_fence_wait(fence, false);\r\nradeon_fence_unref(&fence);\r\nrdev->uvd.filp[i] = NULL;\r\natomic_set(&rdev->uvd.handles[i], 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint radeon_uvd_resume(struct radeon_device *rdev)\r\n{\r\nunsigned size;\r\nvoid *ptr;\r\nif (rdev->uvd.vcpu_bo == NULL)\r\nreturn -EINVAL;\r\nmemcpy(rdev->uvd.cpu_addr, rdev->uvd_fw->data, rdev->uvd_fw->size);\r\nsize = radeon_bo_size(rdev->uvd.vcpu_bo);\r\nsize -= rdev->uvd_fw->size;\r\nptr = rdev->uvd.cpu_addr;\r\nptr += rdev->uvd_fw->size;\r\nmemset(ptr, 0, size);\r\nreturn 0;\r\n}\r\nvoid radeon_uvd_force_into_uvd_segment(struct radeon_bo *rbo,\r\nuint32_t allowed_domains)\r\n{\r\nint i;\r\nfor (i = 0; i < rbo->placement.num_placement; ++i) {\r\nrbo->placements[i].fpfn = 0 >> PAGE_SHIFT;\r\nrbo->placements[i].lpfn = (256 * 1024 * 1024) >> PAGE_SHIFT;\r\n}\r\nif (allowed_domains == RADEON_GEM_DOMAIN_VRAM)\r\nreturn;\r\nif (rbo->placement.num_placement > 1)\r\nreturn;\r\nrbo->placements[1] = rbo->placements[0];\r\nrbo->placements[1].fpfn += (256 * 1024 * 1024) >> PAGE_SHIFT;\r\nrbo->placements[1].lpfn += (256 * 1024 * 1024) >> PAGE_SHIFT;\r\nrbo->placement.num_placement++;\r\nrbo->placement.num_busy_placement++;\r\n}\r\nvoid radeon_uvd_free_handles(struct radeon_device *rdev, struct drm_file *filp)\r\n{\r\nint i, r;\r\nfor (i = 0; i < rdev->uvd.max_handles; ++i) {\r\nuint32_t handle = atomic_read(&rdev->uvd.handles[i]);\r\nif (handle != 0 && rdev->uvd.filp[i] == filp) {\r\nstruct radeon_fence *fence;\r\nradeon_uvd_note_usage(rdev);\r\nr = radeon_uvd_get_destroy_msg(rdev,\r\nR600_RING_TYPE_UVD_INDEX, handle, &fence);\r\nif (r) {\r\nDRM_ERROR("Error destroying UVD (%d)!\n", r);\r\ncontinue;\r\n}\r\nradeon_fence_wait(fence, false);\r\nradeon_fence_unref(&fence);\r\nrdev->uvd.filp[i] = NULL;\r\natomic_set(&rdev->uvd.handles[i], 0);\r\n}\r\n}\r\n}\r\nstatic int radeon_uvd_cs_msg_decode(uint32_t *msg, unsigned buf_sizes[])\r\n{\r\nunsigned stream_type = msg[4];\r\nunsigned width = msg[6];\r\nunsigned height = msg[7];\r\nunsigned dpb_size = msg[9];\r\nunsigned pitch = msg[28];\r\nunsigned width_in_mb = width / 16;\r\nunsigned height_in_mb = ALIGN(height / 16, 2);\r\nunsigned image_size, tmp, min_dpb_size;\r\nimage_size = width * height;\r\nimage_size += image_size / 2;\r\nimage_size = ALIGN(image_size, 1024);\r\nswitch (stream_type) {\r\ncase 0:\r\nmin_dpb_size = image_size * 17;\r\nmin_dpb_size += width_in_mb * height_in_mb * 17 * 192;\r\nmin_dpb_size += width_in_mb * height_in_mb * 32;\r\nbreak;\r\ncase 1:\r\nmin_dpb_size = image_size * 3;\r\nmin_dpb_size += width_in_mb * height_in_mb * 128;\r\nmin_dpb_size += width_in_mb * 64;\r\nmin_dpb_size += width_in_mb * 128;\r\ntmp = max(width_in_mb, height_in_mb);\r\nmin_dpb_size += ALIGN(tmp * 7 * 16, 64);\r\nbreak;\r\ncase 3:\r\nmin_dpb_size = image_size * 3;\r\nbreak;\r\ncase 4:\r\nmin_dpb_size = image_size * 3;\r\nmin_dpb_size += width_in_mb * height_in_mb * 64;\r\nmin_dpb_size += ALIGN(width_in_mb * height_in_mb * 32, 64);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("UVD codec not handled %d!\n", stream_type);\r\nreturn -EINVAL;\r\n}\r\nif (width > pitch) {\r\nDRM_ERROR("Invalid UVD decoding target pitch!\n");\r\nreturn -EINVAL;\r\n}\r\nif (dpb_size < min_dpb_size) {\r\nDRM_ERROR("Invalid dpb_size in UVD message (%d / %d)!\n",\r\ndpb_size, min_dpb_size);\r\nreturn -EINVAL;\r\n}\r\nbuf_sizes[0x1] = dpb_size;\r\nbuf_sizes[0x2] = image_size;\r\nreturn 0;\r\n}\r\nstatic int radeon_uvd_validate_codec(struct radeon_cs_parser *p,\r\nunsigned stream_type)\r\n{\r\nswitch (stream_type) {\r\ncase 0:\r\ncase 1:\r\nreturn 0;\r\ncase 3:\r\ncase 4:\r\nif (p->rdev->family >= CHIP_PALM)\r\nreturn 0;\r\ndefault:\r\nDRM_ERROR("UVD codec not supported by hardware %d!\n",\r\nstream_type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int radeon_uvd_cs_msg(struct radeon_cs_parser *p, struct radeon_bo *bo,\r\nunsigned offset, unsigned buf_sizes[])\r\n{\r\nint32_t *msg, msg_type, handle;\r\nunsigned img_size = 0;\r\nstruct fence *f;\r\nvoid *ptr;\r\nint i, r;\r\nif (offset & 0x3F) {\r\nDRM_ERROR("UVD messages must be 64 byte aligned!\n");\r\nreturn -EINVAL;\r\n}\r\nf = reservation_object_get_excl(bo->tbo.resv);\r\nif (f) {\r\nr = radeon_fence_wait((struct radeon_fence *)f, false);\r\nif (r) {\r\nDRM_ERROR("Failed waiting for UVD message (%d)!\n", r);\r\nreturn r;\r\n}\r\n}\r\nr = radeon_bo_kmap(bo, &ptr);\r\nif (r) {\r\nDRM_ERROR("Failed mapping the UVD message (%d)!\n", r);\r\nreturn r;\r\n}\r\nmsg = ptr + offset;\r\nmsg_type = msg[1];\r\nhandle = msg[2];\r\nif (handle == 0) {\r\nDRM_ERROR("Invalid UVD handle!\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (msg_type) {\r\ncase 0:\r\nimg_size = msg[7] * msg[8];\r\nr = radeon_uvd_validate_codec(p, msg[4]);\r\nradeon_bo_kunmap(bo);\r\nif (r)\r\nreturn r;\r\nfor (i = 0; i < p->rdev->uvd.max_handles; ++i) {\r\nif (atomic_read(&p->rdev->uvd.handles[i]) == handle) {\r\nDRM_ERROR("Handle 0x%x already in use!\n", handle);\r\nreturn -EINVAL;\r\n}\r\nif (!atomic_cmpxchg(&p->rdev->uvd.handles[i], 0, handle)) {\r\np->rdev->uvd.filp[i] = p->filp;\r\np->rdev->uvd.img_size[i] = img_size;\r\nreturn 0;\r\n}\r\n}\r\nDRM_ERROR("No more free UVD handles!\n");\r\nreturn -EINVAL;\r\ncase 1:\r\nr = radeon_uvd_validate_codec(p, msg[4]);\r\nif (!r)\r\nr = radeon_uvd_cs_msg_decode(msg, buf_sizes);\r\nradeon_bo_kunmap(bo);\r\nif (r)\r\nreturn r;\r\nfor (i = 0; i < p->rdev->uvd.max_handles; ++i) {\r\nif (atomic_read(&p->rdev->uvd.handles[i]) == handle) {\r\nif (p->rdev->uvd.filp[i] != p->filp) {\r\nDRM_ERROR("UVD handle collision detected!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nDRM_ERROR("Invalid UVD handle 0x%x!\n", handle);\r\nreturn -ENOENT;\r\ncase 2:\r\nfor (i = 0; i < p->rdev->uvd.max_handles; ++i)\r\natomic_cmpxchg(&p->rdev->uvd.handles[i], handle, 0);\r\nradeon_bo_kunmap(bo);\r\nreturn 0;\r\ndefault:\r\nDRM_ERROR("Illegal UVD message type (%d)!\n", msg_type);\r\nreturn -EINVAL;\r\n}\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nstatic int radeon_uvd_cs_reloc(struct radeon_cs_parser *p,\r\nint data0, int data1,\r\nunsigned buf_sizes[], bool *has_msg_cmd)\r\n{\r\nstruct radeon_cs_chunk *relocs_chunk;\r\nstruct radeon_bo_list *reloc;\r\nunsigned idx, cmd, offset;\r\nuint64_t start, end;\r\nint r;\r\nrelocs_chunk = p->chunk_relocs;\r\noffset = radeon_get_ib_value(p, data0);\r\nidx = radeon_get_ib_value(p, data1);\r\nif (idx >= relocs_chunk->length_dw) {\r\nDRM_ERROR("Relocs at %d after relocations chunk end %d !\n",\r\nidx, relocs_chunk->length_dw);\r\nreturn -EINVAL;\r\n}\r\nreloc = &p->relocs[(idx / 4)];\r\nstart = reloc->gpu_offset;\r\nend = start + radeon_bo_size(reloc->robj);\r\nstart += offset;\r\np->ib.ptr[data0] = start & 0xFFFFFFFF;\r\np->ib.ptr[data1] = start >> 32;\r\ncmd = radeon_get_ib_value(p, p->idx) >> 1;\r\nif (cmd < 0x4) {\r\nif (end <= start) {\r\nDRM_ERROR("invalid reloc offset %X!\n", offset);\r\nreturn -EINVAL;\r\n}\r\nif ((end - start) < buf_sizes[cmd]) {\r\nDRM_ERROR("buffer (%d) to small (%d / %d)!\n", cmd,\r\n(unsigned)(end - start), buf_sizes[cmd]);\r\nreturn -EINVAL;\r\n}\r\n} else if (cmd != 0x100) {\r\nDRM_ERROR("invalid UVD command %X!\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nif ((start >> 28) != ((end - 1) >> 28)) {\r\nDRM_ERROR("reloc %LX-%LX crossing 256MB boundary!\n",\r\nstart, end);\r\nreturn -EINVAL;\r\n}\r\nif ((cmd == 0 || cmd == 0x3) &&\r\n(start >> 28) != (p->rdev->uvd.gpu_addr >> 28)) {\r\nDRM_ERROR("msg/fb buffer %LX-%LX out of 256MB segment!\n",\r\nstart, end);\r\nreturn -EINVAL;\r\n}\r\nif (cmd == 0) {\r\nif (*has_msg_cmd) {\r\nDRM_ERROR("More than one message in a UVD-IB!\n");\r\nreturn -EINVAL;\r\n}\r\n*has_msg_cmd = true;\r\nr = radeon_uvd_cs_msg(p, reloc->robj, offset, buf_sizes);\r\nif (r)\r\nreturn r;\r\n} else if (!*has_msg_cmd) {\r\nDRM_ERROR("Message needed before other commands are send!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_uvd_cs_reg(struct radeon_cs_parser *p,\r\nstruct radeon_cs_packet *pkt,\r\nint *data0, int *data1,\r\nunsigned buf_sizes[],\r\nbool *has_msg_cmd)\r\n{\r\nint i, r;\r\np->idx++;\r\nfor (i = 0; i <= pkt->count; ++i) {\r\nswitch (pkt->reg + i*4) {\r\ncase UVD_GPCOM_VCPU_DATA0:\r\n*data0 = p->idx;\r\nbreak;\r\ncase UVD_GPCOM_VCPU_DATA1:\r\n*data1 = p->idx;\r\nbreak;\r\ncase UVD_GPCOM_VCPU_CMD:\r\nr = radeon_uvd_cs_reloc(p, *data0, *data1,\r\nbuf_sizes, has_msg_cmd);\r\nif (r)\r\nreturn r;\r\nbreak;\r\ncase UVD_ENGINE_CNTL:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid reg 0x%X!\n",\r\npkt->reg + i*4);\r\nreturn -EINVAL;\r\n}\r\np->idx++;\r\n}\r\nreturn 0;\r\n}\r\nint radeon_uvd_cs_parse(struct radeon_cs_parser *p)\r\n{\r\nstruct radeon_cs_packet pkt;\r\nint r, data0 = 0, data1 = 0;\r\nbool has_msg_cmd = false;\r\nunsigned buf_sizes[] = {\r\n[0x00000000] = 2048,\r\n[0x00000001] = 32 * 1024 * 1024,\r\n[0x00000002] = 2048 * 1152 * 3,\r\n[0x00000003] = 2048,\r\n};\r\nif (p->chunk_ib->length_dw % 16) {\r\nDRM_ERROR("UVD IB length (%d) not 16 dwords aligned!\n",\r\np->chunk_ib->length_dw);\r\nreturn -EINVAL;\r\n}\r\nif (p->chunk_relocs == NULL) {\r\nDRM_ERROR("No relocation chunk !\n");\r\nreturn -EINVAL;\r\n}\r\ndo {\r\nr = radeon_cs_packet_parse(p, &pkt, p->idx);\r\nif (r)\r\nreturn r;\r\nswitch (pkt.type) {\r\ncase RADEON_PACKET_TYPE0:\r\nr = radeon_uvd_cs_reg(p, &pkt, &data0, &data1,\r\nbuf_sizes, &has_msg_cmd);\r\nif (r)\r\nreturn r;\r\nbreak;\r\ncase RADEON_PACKET_TYPE2:\r\np->idx += pkt.count + 2;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown packet type %d !\n", pkt.type);\r\nreturn -EINVAL;\r\n}\r\n} while (p->idx < p->chunk_ib->length_dw);\r\nif (!has_msg_cmd) {\r\nDRM_ERROR("UVD-IBs need a msg command!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_uvd_send_msg(struct radeon_device *rdev,\r\nint ring, uint64_t addr,\r\nstruct radeon_fence **fence)\r\n{\r\nstruct radeon_ib ib;\r\nint i, r;\r\nr = radeon_ib_get(rdev, ring, &ib, NULL, 64);\r\nif (r)\r\nreturn r;\r\nib.ptr[0] = PACKET0(UVD_GPCOM_VCPU_DATA0, 0);\r\nib.ptr[1] = addr;\r\nib.ptr[2] = PACKET0(UVD_GPCOM_VCPU_DATA1, 0);\r\nib.ptr[3] = addr >> 32;\r\nib.ptr[4] = PACKET0(UVD_GPCOM_VCPU_CMD, 0);\r\nib.ptr[5] = 0;\r\nfor (i = 6; i < 16; ++i)\r\nib.ptr[i] = PACKET2(0);\r\nib.length_dw = 16;\r\nr = radeon_ib_schedule(rdev, &ib, NULL, false);\r\nif (fence)\r\n*fence = radeon_fence_ref(ib.fence);\r\nradeon_ib_free(rdev, &ib);\r\nreturn r;\r\n}\r\nint radeon_uvd_get_create_msg(struct radeon_device *rdev, int ring,\r\nuint32_t handle, struct radeon_fence **fence)\r\n{\r\nuint64_t offs = radeon_bo_size(rdev->uvd.vcpu_bo) -\r\nRADEON_GPU_PAGE_SIZE;\r\nuint32_t *msg = rdev->uvd.cpu_addr + offs;\r\nuint64_t addr = rdev->uvd.gpu_addr + offs;\r\nint r, i;\r\nr = radeon_bo_reserve(rdev->uvd.vcpu_bo, true);\r\nif (r)\r\nreturn r;\r\nmsg[0] = cpu_to_le32(0x00000de4);\r\nmsg[1] = cpu_to_le32(0x00000000);\r\nmsg[2] = cpu_to_le32(handle);\r\nmsg[3] = cpu_to_le32(0x00000000);\r\nmsg[4] = cpu_to_le32(0x00000000);\r\nmsg[5] = cpu_to_le32(0x00000000);\r\nmsg[6] = cpu_to_le32(0x00000000);\r\nmsg[7] = cpu_to_le32(0x00000780);\r\nmsg[8] = cpu_to_le32(0x00000440);\r\nmsg[9] = cpu_to_le32(0x00000000);\r\nmsg[10] = cpu_to_le32(0x01b37000);\r\nfor (i = 11; i < 1024; ++i)\r\nmsg[i] = cpu_to_le32(0x0);\r\nr = radeon_uvd_send_msg(rdev, ring, addr, fence);\r\nradeon_bo_unreserve(rdev->uvd.vcpu_bo);\r\nreturn r;\r\n}\r\nint radeon_uvd_get_destroy_msg(struct radeon_device *rdev, int ring,\r\nuint32_t handle, struct radeon_fence **fence)\r\n{\r\nuint64_t offs = radeon_bo_size(rdev->uvd.vcpu_bo) -\r\nRADEON_GPU_PAGE_SIZE;\r\nuint32_t *msg = rdev->uvd.cpu_addr + offs;\r\nuint64_t addr = rdev->uvd.gpu_addr + offs;\r\nint r, i;\r\nr = radeon_bo_reserve(rdev->uvd.vcpu_bo, true);\r\nif (r)\r\nreturn r;\r\nmsg[0] = cpu_to_le32(0x00000de4);\r\nmsg[1] = cpu_to_le32(0x00000002);\r\nmsg[2] = cpu_to_le32(handle);\r\nmsg[3] = cpu_to_le32(0x00000000);\r\nfor (i = 4; i < 1024; ++i)\r\nmsg[i] = cpu_to_le32(0x0);\r\nr = radeon_uvd_send_msg(rdev, ring, addr, fence);\r\nradeon_bo_unreserve(rdev->uvd.vcpu_bo);\r\nreturn r;\r\n}\r\nstatic void radeon_uvd_count_handles(struct radeon_device *rdev,\r\nunsigned *sd, unsigned *hd)\r\n{\r\nunsigned i;\r\n*sd = 0;\r\n*hd = 0;\r\nfor (i = 0; i < rdev->uvd.max_handles; ++i) {\r\nif (!atomic_read(&rdev->uvd.handles[i]))\r\ncontinue;\r\nif (rdev->uvd.img_size[i] >= 720*576)\r\n++(*hd);\r\nelse\r\n++(*sd);\r\n}\r\n}\r\nstatic void radeon_uvd_idle_work_handler(struct work_struct *work)\r\n{\r\nstruct radeon_device *rdev =\r\ncontainer_of(work, struct radeon_device, uvd.idle_work.work);\r\nif (radeon_fence_count_emitted(rdev, R600_RING_TYPE_UVD_INDEX) == 0) {\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\r\nradeon_uvd_count_handles(rdev, &rdev->pm.dpm.sd,\r\n&rdev->pm.dpm.hd);\r\nradeon_dpm_enable_uvd(rdev, false);\r\n} else {\r\nradeon_set_uvd_clocks(rdev, 0, 0);\r\n}\r\n} else {\r\nschedule_delayed_work(&rdev->uvd.idle_work,\r\nmsecs_to_jiffies(UVD_IDLE_TIMEOUT_MS));\r\n}\r\n}\r\nvoid radeon_uvd_note_usage(struct radeon_device *rdev)\r\n{\r\nbool streams_changed = false;\r\nbool set_clocks = !cancel_delayed_work_sync(&rdev->uvd.idle_work);\r\nset_clocks &= schedule_delayed_work(&rdev->uvd.idle_work,\r\nmsecs_to_jiffies(UVD_IDLE_TIMEOUT_MS));\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\r\nunsigned hd = 0, sd = 0;\r\nradeon_uvd_count_handles(rdev, &sd, &hd);\r\nif ((rdev->pm.dpm.sd != sd) ||\r\n(rdev->pm.dpm.hd != hd)) {\r\nrdev->pm.dpm.sd = sd;\r\nrdev->pm.dpm.hd = hd;\r\n}\r\n}\r\nif (set_clocks || streams_changed) {\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\r\nradeon_dpm_enable_uvd(rdev, true);\r\n} else {\r\nradeon_set_uvd_clocks(rdev, 53300, 40000);\r\n}\r\n}\r\n}\r\nstatic unsigned radeon_uvd_calc_upll_post_div(unsigned vco_freq,\r\nunsigned target_freq,\r\nunsigned pd_min,\r\nunsigned pd_even)\r\n{\r\nunsigned post_div = vco_freq / target_freq;\r\nif (post_div < pd_min)\r\npost_div = pd_min;\r\nif ((vco_freq / post_div) > target_freq)\r\npost_div += 1;\r\nif (post_div > pd_even && post_div % 2)\r\npost_div += 1;\r\nreturn post_div;\r\n}\r\nint radeon_uvd_calc_upll_dividers(struct radeon_device *rdev,\r\nunsigned vclk, unsigned dclk,\r\nunsigned vco_min, unsigned vco_max,\r\nunsigned fb_factor, unsigned fb_mask,\r\nunsigned pd_min, unsigned pd_max,\r\nunsigned pd_even,\r\nunsigned *optimal_fb_div,\r\nunsigned *optimal_vclk_div,\r\nunsigned *optimal_dclk_div)\r\n{\r\nunsigned vco_freq, ref_freq = rdev->clock.spll.reference_freq;\r\nunsigned optimal_score = ~0;\r\nvco_min = max(max(vco_min, vclk), dclk);\r\nfor (vco_freq = vco_min; vco_freq <= vco_max; vco_freq += 100) {\r\nuint64_t fb_div = (uint64_t)vco_freq * fb_factor;\r\nunsigned vclk_div, dclk_div, score;\r\ndo_div(fb_div, ref_freq);\r\nif (fb_div > fb_mask)\r\nbreak;\r\nfb_div &= fb_mask;\r\nvclk_div = radeon_uvd_calc_upll_post_div(vco_freq, vclk,\r\npd_min, pd_even);\r\nif (vclk_div > pd_max)\r\nbreak;\r\ndclk_div = radeon_uvd_calc_upll_post_div(vco_freq, dclk,\r\npd_min, pd_even);\r\nif (vclk_div > pd_max)\r\nbreak;\r\nscore = vclk - (vco_freq / vclk_div) + dclk - (vco_freq / dclk_div);\r\nif (score < optimal_score) {\r\n*optimal_fb_div = fb_div;\r\n*optimal_vclk_div = vclk_div;\r\n*optimal_dclk_div = dclk_div;\r\noptimal_score = score;\r\nif (optimal_score == 0)\r\nbreak;\r\n}\r\n}\r\nif (optimal_score == ~0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint radeon_uvd_send_upll_ctlreq(struct radeon_device *rdev,\r\nunsigned cg_upll_func_cntl)\r\n{\r\nunsigned i;\r\nWREG32_P(cg_upll_func_cntl, 0, ~UPLL_CTLREQ_MASK);\r\nmdelay(10);\r\nWREG32_P(cg_upll_func_cntl, UPLL_CTLREQ_MASK, ~UPLL_CTLREQ_MASK);\r\nfor (i = 0; i < 100; ++i) {\r\nuint32_t mask = UPLL_CTLACK_MASK | UPLL_CTLACK2_MASK;\r\nif ((RREG32(cg_upll_func_cntl) & mask) == mask)\r\nbreak;\r\nmdelay(10);\r\n}\r\nWREG32_P(cg_upll_func_cntl, 0, ~UPLL_CTLREQ_MASK);\r\nif (i == 100) {\r\nDRM_ERROR("Timeout setting UVD clocks!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}
