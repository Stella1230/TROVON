int blk_rq_count_integrity_sg(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct bio_vec iv, ivprv = { NULL };\r\nunsigned int segments = 0;\r\nunsigned int seg_size = 0;\r\nstruct bvec_iter iter;\r\nint prev = 0;\r\nbio_for_each_integrity_vec(iv, bio, iter) {\r\nif (prev) {\r\nif (!BIOVEC_PHYS_MERGEABLE(&ivprv, &iv))\r\ngoto new_segment;\r\nif (!BIOVEC_SEG_BOUNDARY(q, &ivprv, &iv))\r\ngoto new_segment;\r\nif (seg_size + iv.bv_len > queue_max_segment_size(q))\r\ngoto new_segment;\r\nseg_size += iv.bv_len;\r\n} else {\r\nnew_segment:\r\nsegments++;\r\nseg_size = iv.bv_len;\r\n}\r\nprev = 1;\r\nivprv = iv;\r\n}\r\nreturn segments;\r\n}\r\nint blk_rq_map_integrity_sg(struct request_queue *q, struct bio *bio,\r\nstruct scatterlist *sglist)\r\n{\r\nstruct bio_vec iv, ivprv = { NULL };\r\nstruct scatterlist *sg = NULL;\r\nunsigned int segments = 0;\r\nstruct bvec_iter iter;\r\nint prev = 0;\r\nbio_for_each_integrity_vec(iv, bio, iter) {\r\nif (prev) {\r\nif (!BIOVEC_PHYS_MERGEABLE(&ivprv, &iv))\r\ngoto new_segment;\r\nif (!BIOVEC_SEG_BOUNDARY(q, &ivprv, &iv))\r\ngoto new_segment;\r\nif (sg->length + iv.bv_len > queue_max_segment_size(q))\r\ngoto new_segment;\r\nsg->length += iv.bv_len;\r\n} else {\r\nnew_segment:\r\nif (!sg)\r\nsg = sglist;\r\nelse {\r\nsg_unmark_end(sg);\r\nsg = sg_next(sg);\r\n}\r\nsg_set_page(sg, iv.bv_page, iv.bv_len, iv.bv_offset);\r\nsegments++;\r\n}\r\nprev = 1;\r\nivprv = iv;\r\n}\r\nif (sg)\r\nsg_mark_end(sg);\r\nreturn segments;\r\n}\r\nint blk_integrity_compare(struct gendisk *gd1, struct gendisk *gd2)\r\n{\r\nstruct blk_integrity *b1 = &gd1->queue->integrity;\r\nstruct blk_integrity *b2 = &gd2->queue->integrity;\r\nif (!b1->profile && !b2->profile)\r\nreturn 0;\r\nif (!b1->profile || !b2->profile)\r\nreturn -1;\r\nif (b1->interval_exp != b2->interval_exp) {\r\npr_err("%s: %s/%s protection interval %u != %u\n",\r\n__func__, gd1->disk_name, gd2->disk_name,\r\n1 << b1->interval_exp, 1 << b2->interval_exp);\r\nreturn -1;\r\n}\r\nif (b1->tuple_size != b2->tuple_size) {\r\npr_err("%s: %s/%s tuple sz %u != %u\n", __func__,\r\ngd1->disk_name, gd2->disk_name,\r\nb1->tuple_size, b2->tuple_size);\r\nreturn -1;\r\n}\r\nif (b1->tag_size && b2->tag_size && (b1->tag_size != b2->tag_size)) {\r\npr_err("%s: %s/%s tag sz %u != %u\n", __func__,\r\ngd1->disk_name, gd2->disk_name,\r\nb1->tag_size, b2->tag_size);\r\nreturn -1;\r\n}\r\nif (b1->profile != b2->profile) {\r\npr_err("%s: %s/%s type %s != %s\n", __func__,\r\ngd1->disk_name, gd2->disk_name,\r\nb1->profile->name, b2->profile->name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nbool blk_integrity_merge_rq(struct request_queue *q, struct request *req,\r\nstruct request *next)\r\n{\r\nif (blk_integrity_rq(req) == 0 && blk_integrity_rq(next) == 0)\r\nreturn true;\r\nif (blk_integrity_rq(req) == 0 || blk_integrity_rq(next) == 0)\r\nreturn false;\r\nif (bio_integrity(req->bio)->bip_flags !=\r\nbio_integrity(next->bio)->bip_flags)\r\nreturn false;\r\nif (req->nr_integrity_segments + next->nr_integrity_segments >\r\nq->limits.max_integrity_segments)\r\nreturn false;\r\nif (integrity_req_gap_back_merge(req, next->bio))\r\nreturn false;\r\nreturn true;\r\n}\r\nbool blk_integrity_merge_bio(struct request_queue *q, struct request *req,\r\nstruct bio *bio)\r\n{\r\nint nr_integrity_segs;\r\nstruct bio *next = bio->bi_next;\r\nif (blk_integrity_rq(req) == 0 && bio_integrity(bio) == NULL)\r\nreturn true;\r\nif (blk_integrity_rq(req) == 0 || bio_integrity(bio) == NULL)\r\nreturn false;\r\nif (bio_integrity(req->bio)->bip_flags != bio_integrity(bio)->bip_flags)\r\nreturn false;\r\nbio->bi_next = NULL;\r\nnr_integrity_segs = blk_rq_count_integrity_sg(q, bio);\r\nbio->bi_next = next;\r\nif (req->nr_integrity_segments + nr_integrity_segs >\r\nq->limits.max_integrity_segments)\r\nreturn false;\r\nreq->nr_integrity_segments += nr_integrity_segs;\r\nreturn true;\r\n}\r\nstatic ssize_t integrity_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *page)\r\n{\r\nstruct gendisk *disk = container_of(kobj, struct gendisk, integrity_kobj);\r\nstruct blk_integrity *bi = &disk->queue->integrity;\r\nstruct integrity_sysfs_entry *entry =\r\ncontainer_of(attr, struct integrity_sysfs_entry, attr);\r\nreturn entry->show(bi, page);\r\n}\r\nstatic ssize_t integrity_attr_store(struct kobject *kobj,\r\nstruct attribute *attr, const char *page,\r\nsize_t count)\r\n{\r\nstruct gendisk *disk = container_of(kobj, struct gendisk, integrity_kobj);\r\nstruct blk_integrity *bi = &disk->queue->integrity;\r\nstruct integrity_sysfs_entry *entry =\r\ncontainer_of(attr, struct integrity_sysfs_entry, attr);\r\nssize_t ret = 0;\r\nif (entry->store)\r\nret = entry->store(bi, page, count);\r\nreturn ret;\r\n}\r\nstatic ssize_t integrity_format_show(struct blk_integrity *bi, char *page)\r\n{\r\nif (bi->profile && bi->profile->name)\r\nreturn sprintf(page, "%s\n", bi->profile->name);\r\nelse\r\nreturn sprintf(page, "none\n");\r\n}\r\nstatic ssize_t integrity_tag_size_show(struct blk_integrity *bi, char *page)\r\n{\r\nreturn sprintf(page, "%u\n", bi->tag_size);\r\n}\r\nstatic ssize_t integrity_interval_show(struct blk_integrity *bi, char *page)\r\n{\r\nreturn sprintf(page, "%u\n",\r\nbi->interval_exp ? 1 << bi->interval_exp : 0);\r\n}\r\nstatic ssize_t integrity_verify_store(struct blk_integrity *bi,\r\nconst char *page, size_t count)\r\n{\r\nchar *p = (char *) page;\r\nunsigned long val = simple_strtoul(p, &p, 10);\r\nif (val)\r\nbi->flags |= BLK_INTEGRITY_VERIFY;\r\nelse\r\nbi->flags &= ~BLK_INTEGRITY_VERIFY;\r\nreturn count;\r\n}\r\nstatic ssize_t integrity_verify_show(struct blk_integrity *bi, char *page)\r\n{\r\nreturn sprintf(page, "%d\n", (bi->flags & BLK_INTEGRITY_VERIFY) != 0);\r\n}\r\nstatic ssize_t integrity_generate_store(struct blk_integrity *bi,\r\nconst char *page, size_t count)\r\n{\r\nchar *p = (char *) page;\r\nunsigned long val = simple_strtoul(p, &p, 10);\r\nif (val)\r\nbi->flags |= BLK_INTEGRITY_GENERATE;\r\nelse\r\nbi->flags &= ~BLK_INTEGRITY_GENERATE;\r\nreturn count;\r\n}\r\nstatic ssize_t integrity_generate_show(struct blk_integrity *bi, char *page)\r\n{\r\nreturn sprintf(page, "%d\n", (bi->flags & BLK_INTEGRITY_GENERATE) != 0);\r\n}\r\nstatic ssize_t integrity_device_show(struct blk_integrity *bi, char *page)\r\n{\r\nreturn sprintf(page, "%u\n",\r\n(bi->flags & BLK_INTEGRITY_DEVICE_CAPABLE) != 0);\r\n}\r\nstatic int blk_integrity_nop_fn(struct blk_integrity_iter *iter)\r\n{\r\nreturn 0;\r\n}\r\nvoid blk_integrity_register(struct gendisk *disk, struct blk_integrity *template)\r\n{\r\nstruct blk_integrity *bi = &disk->queue->integrity;\r\nbi->flags = BLK_INTEGRITY_VERIFY | BLK_INTEGRITY_GENERATE |\r\ntemplate->flags;\r\nbi->interval_exp = ilog2(queue_logical_block_size(disk->queue));\r\nbi->profile = template->profile ? template->profile : &nop_profile;\r\nbi->tuple_size = template->tuple_size;\r\nbi->tag_size = template->tag_size;\r\nblk_integrity_revalidate(disk);\r\n}\r\nvoid blk_integrity_unregister(struct gendisk *disk)\r\n{\r\nblk_integrity_revalidate(disk);\r\nmemset(&disk->queue->integrity, 0, sizeof(struct blk_integrity));\r\n}\r\nvoid blk_integrity_revalidate(struct gendisk *disk)\r\n{\r\nstruct blk_integrity *bi = &disk->queue->integrity;\r\nif (!(disk->flags & GENHD_FL_UP))\r\nreturn;\r\nif (bi->profile)\r\ndisk->queue->backing_dev_info.capabilities |=\r\nBDI_CAP_STABLE_WRITES;\r\nelse\r\ndisk->queue->backing_dev_info.capabilities &=\r\n~BDI_CAP_STABLE_WRITES;\r\n}\r\nvoid blk_integrity_add(struct gendisk *disk)\r\n{\r\nif (kobject_init_and_add(&disk->integrity_kobj, &integrity_ktype,\r\n&disk_to_dev(disk)->kobj, "%s", "integrity"))\r\nreturn;\r\nkobject_uevent(&disk->integrity_kobj, KOBJ_ADD);\r\n}\r\nvoid blk_integrity_del(struct gendisk *disk)\r\n{\r\nkobject_uevent(&disk->integrity_kobj, KOBJ_REMOVE);\r\nkobject_del(&disk->integrity_kobj);\r\nkobject_put(&disk->integrity_kobj);\r\n}
