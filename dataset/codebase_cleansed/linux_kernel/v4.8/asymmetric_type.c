struct key *find_asymmetric_key(struct key *keyring,\r\nconst struct asymmetric_key_id *id_0,\r\nconst struct asymmetric_key_id *id_1,\r\nbool partial)\r\n{\r\nstruct key *key;\r\nkey_ref_t ref;\r\nconst char *lookup;\r\nchar *req, *p;\r\nint len;\r\nif (id_0) {\r\nlookup = id_0->data;\r\nlen = id_0->len;\r\n} else {\r\nlookup = id_1->data;\r\nlen = id_1->len;\r\n}\r\np = req = kmalloc(2 + 1 + len * 2 + 1, GFP_KERNEL);\r\nif (!req)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (partial) {\r\n*p++ = 'i';\r\n*p++ = 'd';\r\n} else {\r\n*p++ = 'e';\r\n*p++ = 'x';\r\n}\r\n*p++ = ':';\r\np = bin2hex(p, lookup, len);\r\n*p = 0;\r\npr_debug("Look up: \"%s\"\n", req);\r\nref = keyring_search(make_key_ref(keyring, 1),\r\n&key_type_asymmetric, req);\r\nif (IS_ERR(ref))\r\npr_debug("Request for key '%s' err %ld\n", req, PTR_ERR(ref));\r\nkfree(req);\r\nif (IS_ERR(ref)) {\r\nswitch (PTR_ERR(ref)) {\r\ncase -EACCES:\r\ncase -ENOTDIR:\r\ncase -EAGAIN:\r\nreturn ERR_PTR(-ENOKEY);\r\ndefault:\r\nreturn ERR_CAST(ref);\r\n}\r\n}\r\nkey = key_ref_to_ptr(ref);\r\nif (id_0 && id_1) {\r\nconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\r\nif (!kids->id[0]) {\r\npr_debug("First ID matches, but second is missing\n");\r\ngoto reject;\r\n}\r\nif (!asymmetric_key_id_same(id_1, kids->id[1])) {\r\npr_debug("First ID matches, but second does not\n");\r\ngoto reject;\r\n}\r\n}\r\npr_devel("<==%s() = 0 [%x]\n", __func__, key_serial(key));\r\nreturn key;\r\nreject:\r\nkey_put(key);\r\nreturn ERR_PTR(-EKEYREJECTED);\r\n}\r\nstruct asymmetric_key_id *asymmetric_key_generate_id(const void *val_1,\r\nsize_t len_1,\r\nconst void *val_2,\r\nsize_t len_2)\r\n{\r\nstruct asymmetric_key_id *kid;\r\nkid = kmalloc(sizeof(struct asymmetric_key_id) + len_1 + len_2,\r\nGFP_KERNEL);\r\nif (!kid)\r\nreturn ERR_PTR(-ENOMEM);\r\nkid->len = len_1 + len_2;\r\nmemcpy(kid->data, val_1, len_1);\r\nmemcpy(kid->data + len_1, val_2, len_2);\r\nreturn kid;\r\n}\r\nbool asymmetric_key_id_same(const struct asymmetric_key_id *kid1,\r\nconst struct asymmetric_key_id *kid2)\r\n{\r\nif (!kid1 || !kid2)\r\nreturn false;\r\nif (kid1->len != kid2->len)\r\nreturn false;\r\nreturn memcmp(kid1->data, kid2->data, kid1->len) == 0;\r\n}\r\nbool asymmetric_key_id_partial(const struct asymmetric_key_id *kid1,\r\nconst struct asymmetric_key_id *kid2)\r\n{\r\nif (!kid1 || !kid2)\r\nreturn false;\r\nif (kid1->len < kid2->len)\r\nreturn false;\r\nreturn memcmp(kid1->data + (kid1->len - kid2->len),\r\nkid2->data, kid2->len) == 0;\r\n}\r\nstatic bool asymmetric_match_key_ids(\r\nconst struct asymmetric_key_ids *kids,\r\nconst struct asymmetric_key_id *match_id,\r\nbool (*match)(const struct asymmetric_key_id *kid1,\r\nconst struct asymmetric_key_id *kid2))\r\n{\r\nint i;\r\nif (!kids || !match_id)\r\nreturn false;\r\nfor (i = 0; i < ARRAY_SIZE(kids->id); i++)\r\nif (match(kids->id[i], match_id))\r\nreturn true;\r\nreturn false;\r\n}\r\ninline int __asymmetric_key_hex_to_key_id(const char *id,\r\nstruct asymmetric_key_id *match_id,\r\nsize_t hexlen)\r\n{\r\nmatch_id->len = hexlen;\r\nreturn hex2bin(match_id->data, id, hexlen);\r\n}\r\nstruct asymmetric_key_id *asymmetric_key_hex_to_key_id(const char *id)\r\n{\r\nstruct asymmetric_key_id *match_id;\r\nsize_t asciihexlen;\r\nint ret;\r\nif (!*id)\r\nreturn ERR_PTR(-EINVAL);\r\nasciihexlen = strlen(id);\r\nif (asciihexlen & 1)\r\nreturn ERR_PTR(-EINVAL);\r\nmatch_id = kmalloc(sizeof(struct asymmetric_key_id) + asciihexlen / 2,\r\nGFP_KERNEL);\r\nif (!match_id)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = __asymmetric_key_hex_to_key_id(id, match_id, asciihexlen / 2);\r\nif (ret < 0) {\r\nkfree(match_id);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn match_id;\r\n}\r\nstatic bool asymmetric_key_cmp(const struct key *key,\r\nconst struct key_match_data *match_data)\r\n{\r\nconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\r\nconst struct asymmetric_key_id *match_id = match_data->preparsed;\r\nreturn asymmetric_match_key_ids(kids, match_id,\r\nasymmetric_key_id_same);\r\n}\r\nstatic bool asymmetric_key_cmp_partial(const struct key *key,\r\nconst struct key_match_data *match_data)\r\n{\r\nconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\r\nconst struct asymmetric_key_id *match_id = match_data->preparsed;\r\nreturn asymmetric_match_key_ids(kids, match_id,\r\nasymmetric_key_id_partial);\r\n}\r\nstatic int asymmetric_key_match_preparse(struct key_match_data *match_data)\r\n{\r\nstruct asymmetric_key_id *match_id;\r\nconst char *spec = match_data->raw_data;\r\nconst char *id;\r\nbool (*cmp)(const struct key *, const struct key_match_data *) =\r\nasymmetric_key_cmp;\r\nif (!spec || !*spec)\r\nreturn -EINVAL;\r\nif (spec[0] == 'i' &&\r\nspec[1] == 'd' &&\r\nspec[2] == ':') {\r\nid = spec + 3;\r\ncmp = asymmetric_key_cmp_partial;\r\n} else if (spec[0] == 'e' &&\r\nspec[1] == 'x' &&\r\nspec[2] == ':') {\r\nid = spec + 3;\r\n} else {\r\ngoto default_match;\r\n}\r\nmatch_id = asymmetric_key_hex_to_key_id(id);\r\nif (IS_ERR(match_id))\r\nreturn PTR_ERR(match_id);\r\nmatch_data->preparsed = match_id;\r\nmatch_data->cmp = cmp;\r\nmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\r\nreturn 0;\r\ndefault_match:\r\nreturn 0;\r\n}\r\nstatic void asymmetric_key_match_free(struct key_match_data *match_data)\r\n{\r\nkfree(match_data->preparsed);\r\n}\r\nstatic void asymmetric_key_describe(const struct key *key, struct seq_file *m)\r\n{\r\nconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\r\nconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\r\nconst struct asymmetric_key_id *kid;\r\nconst unsigned char *p;\r\nint n;\r\nseq_puts(m, key->description);\r\nif (subtype) {\r\nseq_puts(m, ": ");\r\nsubtype->describe(key, m);\r\nif (kids && kids->id[1]) {\r\nkid = kids->id[1];\r\nseq_putc(m, ' ');\r\nn = kid->len;\r\np = kid->data;\r\nif (n > 4) {\r\np += n - 4;\r\nn = 4;\r\n}\r\nseq_printf(m, "%*phN", n, p);\r\n}\r\nseq_puts(m, " [");\r\nseq_putc(m, ']');\r\n}\r\n}\r\nstatic int asymmetric_key_preparse(struct key_preparsed_payload *prep)\r\n{\r\nstruct asymmetric_key_parser *parser;\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\nif (prep->datalen == 0)\r\nreturn -EINVAL;\r\ndown_read(&asymmetric_key_parsers_sem);\r\nret = -EBADMSG;\r\nlist_for_each_entry(parser, &asymmetric_key_parsers, link) {\r\npr_debug("Trying parser '%s'\n", parser->name);\r\nret = parser->parse(prep);\r\nif (ret != -EBADMSG) {\r\npr_debug("Parser recognised the format (ret %d)\n",\r\nret);\r\nbreak;\r\n}\r\n}\r\nup_read(&asymmetric_key_parsers_sem);\r\npr_devel("<==%s() = %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void asymmetric_key_free_kids(struct asymmetric_key_ids *kids)\r\n{\r\nint i;\r\nif (kids) {\r\nfor (i = 0; i < ARRAY_SIZE(kids->id); i++)\r\nkfree(kids->id[i]);\r\nkfree(kids);\r\n}\r\n}\r\nstatic void asymmetric_key_free_preparse(struct key_preparsed_payload *prep)\r\n{\r\nstruct asymmetric_key_subtype *subtype = prep->payload.data[asym_subtype];\r\nstruct asymmetric_key_ids *kids = prep->payload.data[asym_key_ids];\r\npr_devel("==>%s()\n", __func__);\r\nif (subtype) {\r\nsubtype->destroy(prep->payload.data[asym_crypto],\r\nprep->payload.data[asym_auth]);\r\nmodule_put(subtype->owner);\r\n}\r\nasymmetric_key_free_kids(kids);\r\nkfree(prep->description);\r\n}\r\nstatic void asymmetric_key_destroy(struct key *key)\r\n{\r\nstruct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\r\nstruct asymmetric_key_ids *kids = key->payload.data[asym_key_ids];\r\nvoid *data = key->payload.data[asym_crypto];\r\nvoid *auth = key->payload.data[asym_auth];\r\nkey->payload.data[asym_crypto] = NULL;\r\nkey->payload.data[asym_subtype] = NULL;\r\nkey->payload.data[asym_key_ids] = NULL;\r\nkey->payload.data[asym_auth] = NULL;\r\nif (subtype) {\r\nsubtype->destroy(data, auth);\r\nmodule_put(subtype->owner);\r\n}\r\nasymmetric_key_free_kids(kids);\r\n}\r\nint register_asymmetric_key_parser(struct asymmetric_key_parser *parser)\r\n{\r\nstruct asymmetric_key_parser *cursor;\r\nint ret;\r\ndown_write(&asymmetric_key_parsers_sem);\r\nlist_for_each_entry(cursor, &asymmetric_key_parsers, link) {\r\nif (strcmp(cursor->name, parser->name) == 0) {\r\npr_err("Asymmetric key parser '%s' already registered\n",\r\nparser->name);\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nlist_add_tail(&parser->link, &asymmetric_key_parsers);\r\npr_notice("Asymmetric key parser '%s' registered\n", parser->name);\r\nret = 0;\r\nout:\r\nup_write(&asymmetric_key_parsers_sem);\r\nreturn ret;\r\n}\r\nvoid unregister_asymmetric_key_parser(struct asymmetric_key_parser *parser)\r\n{\r\ndown_write(&asymmetric_key_parsers_sem);\r\nlist_del(&parser->link);\r\nup_write(&asymmetric_key_parsers_sem);\r\npr_notice("Asymmetric key parser '%s' unregistered\n", parser->name);\r\n}\r\nstatic int __init asymmetric_key_init(void)\r\n{\r\nreturn register_key_type(&key_type_asymmetric);\r\n}\r\nstatic void __exit asymmetric_key_cleanup(void)\r\n{\r\nunregister_key_type(&key_type_asymmetric);\r\n}
