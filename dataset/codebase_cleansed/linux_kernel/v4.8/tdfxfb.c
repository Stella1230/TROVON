static inline u8 vga_inb(struct tdfx_par *par, u32 reg)\r\n{\r\nreturn inb(par->iobase + reg - 0x300);\r\n}\r\nstatic inline void vga_outb(struct tdfx_par *par, u32 reg, u8 val)\r\n{\r\noutb(val, par->iobase + reg - 0x300);\r\n}\r\nstatic inline void gra_outb(struct tdfx_par *par, u32 idx, u8 val)\r\n{\r\nvga_outb(par, GRA_I, idx);\r\nwmb();\r\nvga_outb(par, GRA_D, val);\r\nwmb();\r\n}\r\nstatic inline void seq_outb(struct tdfx_par *par, u32 idx, u8 val)\r\n{\r\nvga_outb(par, SEQ_I, idx);\r\nwmb();\r\nvga_outb(par, SEQ_D, val);\r\nwmb();\r\n}\r\nstatic inline u8 seq_inb(struct tdfx_par *par, u32 idx)\r\n{\r\nvga_outb(par, SEQ_I, idx);\r\nmb();\r\nreturn vga_inb(par, SEQ_D);\r\n}\r\nstatic inline void crt_outb(struct tdfx_par *par, u32 idx, u8 val)\r\n{\r\nvga_outb(par, CRT_I, idx);\r\nwmb();\r\nvga_outb(par, CRT_D, val);\r\nwmb();\r\n}\r\nstatic inline u8 crt_inb(struct tdfx_par *par, u32 idx)\r\n{\r\nvga_outb(par, CRT_I, idx);\r\nmb();\r\nreturn vga_inb(par, CRT_D);\r\n}\r\nstatic inline void att_outb(struct tdfx_par *par, u32 idx, u8 val)\r\n{\r\nunsigned char tmp;\r\ntmp = vga_inb(par, IS1_R);\r\nvga_outb(par, ATT_IW, idx);\r\nvga_outb(par, ATT_IW, val);\r\n}\r\nstatic inline void vga_disable_video(struct tdfx_par *par)\r\n{\r\nunsigned char s;\r\ns = seq_inb(par, 0x01) | 0x20;\r\nseq_outb(par, 0x00, 0x01);\r\nseq_outb(par, 0x01, s);\r\nseq_outb(par, 0x00, 0x03);\r\n}\r\nstatic inline void vga_enable_video(struct tdfx_par *par)\r\n{\r\nunsigned char s;\r\ns = seq_inb(par, 0x01) & 0xdf;\r\nseq_outb(par, 0x00, 0x01);\r\nseq_outb(par, 0x01, s);\r\nseq_outb(par, 0x00, 0x03);\r\n}\r\nstatic inline void vga_enable_palette(struct tdfx_par *par)\r\n{\r\nvga_inb(par, IS1_R);\r\nmb();\r\nvga_outb(par, ATT_IW, 0x20);\r\n}\r\nstatic inline u32 tdfx_inl(struct tdfx_par *par, unsigned int reg)\r\n{\r\nreturn readl(par->regbase_virt + reg);\r\n}\r\nstatic inline void tdfx_outl(struct tdfx_par *par, unsigned int reg, u32 val)\r\n{\r\nwritel(val, par->regbase_virt + reg);\r\n}\r\nstatic inline void banshee_make_room(struct tdfx_par *par, int size)\r\n{\r\nwhile ((tdfx_inl(par, STATUS) & 0x1f) < size - 1)\r\ncpu_relax();\r\n}\r\nstatic int banshee_wait_idle(struct fb_info *info)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nint i = 0;\r\nbanshee_make_room(par, 1);\r\ntdfx_outl(par, COMMAND_3D, COMMAND_3D_NOP);\r\ndo {\r\nif ((tdfx_inl(par, STATUS) & STATUS_BUSY) == 0)\r\ni++;\r\n} while (i < 3);\r\nreturn 0;\r\n}\r\nstatic inline void do_setpalentry(struct tdfx_par *par, unsigned regno, u32 c)\r\n{\r\nbanshee_make_room(par, 2);\r\ntdfx_outl(par, DACADDR, regno);\r\ntdfx_inl(par, DACADDR);\r\ntdfx_outl(par, DACDATA, c);\r\n}\r\nstatic u32 do_calc_pll(int freq, int *freq_out)\r\n{\r\nint m, n, k, best_m, best_n, best_k, best_error;\r\nint fref = 14318;\r\nbest_error = freq;\r\nbest_n = best_m = best_k = 0;\r\nfor (k = 3; k >= 0; k--) {\r\nfor (m = 63; m >= 0; m--) {\r\nint n_estimated = ((freq * (m + 2) << k) / fref) - 2;\r\nfor (n = max(0, n_estimated);\r\nn <= min(255, n_estimated + 1);\r\nn++) {\r\nint f = (fref * (n + 2) / (m + 2)) >> k;\r\nint error = abs(f - freq);\r\nif (error < best_error) {\r\nbest_error = error;\r\nbest_n = n;\r\nbest_m = m;\r\nbest_k = k;\r\n}\r\n}\r\n}\r\n}\r\nn = best_n;\r\nm = best_m;\r\nk = best_k;\r\n*freq_out = (fref * (n + 2) / (m + 2)) >> k;\r\nreturn (n << 8) | (m << 2) | k;\r\n}\r\nstatic void do_write_regs(struct fb_info *info, struct banshee_reg *reg)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nint i;\r\nbanshee_wait_idle(info);\r\ntdfx_outl(par, MISCINIT1, tdfx_inl(par, MISCINIT1) | 0x01);\r\ncrt_outb(par, 0x11, crt_inb(par, 0x11) & 0x7f);\r\nbanshee_make_room(par, 3);\r\ntdfx_outl(par, VGAINIT1, reg->vgainit1 & 0x001FFFFF);\r\ntdfx_outl(par, VIDPROCCFG, reg->vidcfg & ~0x00000001);\r\n#if 0\r\ntdfx_outl(par, PLLCTRL1, reg->mempll);\r\ntdfx_outl(par, PLLCTRL2, reg->gfxpll);\r\n#endif\r\ntdfx_outl(par, PLLCTRL0, reg->vidpll);\r\nvga_outb(par, MISC_W, reg->misc[0x00] | 0x01);\r\nfor (i = 0; i < 5; i++)\r\nseq_outb(par, i, reg->seq[i]);\r\nfor (i = 0; i < 25; i++)\r\ncrt_outb(par, i, reg->crt[i]);\r\nfor (i = 0; i < 9; i++)\r\ngra_outb(par, i, reg->gra[i]);\r\nfor (i = 0; i < 21; i++)\r\natt_outb(par, i, reg->att[i]);\r\ncrt_outb(par, 0x1a, reg->ext[0]);\r\ncrt_outb(par, 0x1b, reg->ext[1]);\r\nvga_enable_palette(par);\r\nvga_enable_video(par);\r\nbanshee_make_room(par, 9);\r\ntdfx_outl(par, VGAINIT0, reg->vgainit0);\r\ntdfx_outl(par, DACMODE, reg->dacmode);\r\ntdfx_outl(par, VIDDESKSTRIDE, reg->stride);\r\ntdfx_outl(par, HWCURPATADDR, reg->curspataddr);\r\ntdfx_outl(par, VIDSCREENSIZE, reg->screensize);\r\ntdfx_outl(par, VIDDESKSTART, reg->startaddr);\r\ntdfx_outl(par, VIDPROCCFG, reg->vidcfg);\r\ntdfx_outl(par, VGAINIT1, reg->vgainit1);\r\ntdfx_outl(par, MISCINIT0, reg->miscinit0);\r\nbanshee_make_room(par, 8);\r\ntdfx_outl(par, SRCBASE, reg->startaddr);\r\ntdfx_outl(par, DSTBASE, reg->startaddr);\r\ntdfx_outl(par, COMMANDEXTRA_2D, 0);\r\ntdfx_outl(par, CLIP0MIN, 0);\r\ntdfx_outl(par, CLIP0MAX, 0x0fff0fff);\r\ntdfx_outl(par, CLIP1MIN, 0);\r\ntdfx_outl(par, CLIP1MAX, 0x0fff0fff);\r\ntdfx_outl(par, SRCXY, 0);\r\nbanshee_wait_idle(info);\r\n}\r\nstatic unsigned long do_lfb_size(struct tdfx_par *par, unsigned short dev_id)\r\n{\r\nu32 draminit0 = tdfx_inl(par, DRAMINIT0);\r\nu32 draminit1 = tdfx_inl(par, DRAMINIT1);\r\nu32 miscinit1;\r\nint num_chips = (draminit0 & DRAMINIT0_SGRAM_NUM) ? 8 : 4;\r\nint chip_size;\r\nint has_sgram = draminit1 & DRAMINIT1_MEM_SDRAM;\r\nif (dev_id < PCI_DEVICE_ID_3DFX_VOODOO5) {\r\nchip_size = 2;\r\nif (has_sgram && !(draminit0 & DRAMINIT0_SGRAM_TYPE))\r\nchip_size = 1;\r\n} else {\r\nhas_sgram = 0;\r\nchip_size = draminit0 & DRAMINIT0_SGRAM_TYPE_MASK;\r\nchip_size = 1 << (chip_size >> DRAMINIT0_SGRAM_TYPE_SHIFT);\r\n}\r\nmiscinit1 = tdfx_inl(par, MISCINIT1);\r\nmiscinit1 |= has_sgram ? 0 : MISCINIT1_2DBLOCK_DIS;\r\nmiscinit1 |= MISCINIT1_CLUT_INV;\r\nbanshee_make_room(par, 1);\r\ntdfx_outl(par, MISCINIT1, miscinit1);\r\nreturn num_chips * chip_size * 1024l * 1024;\r\n}\r\nstatic int tdfxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nu32 lpitch;\r\nif (var->bits_per_pixel != 8 && var->bits_per_pixel != 16 &&\r\nvar->bits_per_pixel != 24 && var->bits_per_pixel != 32) {\r\nDPRINTK("depth not supported: %u\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres != var->xres_virtual)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres_virtual = var->yres;\r\nif (var->xoffset) {\r\nDPRINTK("xoffset not supported\n");\r\nreturn -EINVAL;\r\n}\r\nvar->yoffset = 0;\r\nif (((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) &&\r\n(par->max_pixclock < VOODOO3_MAX_PIXCLOCK)) {\r\nDPRINTK("interlace not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (info->monspecs.hfmax && info->monspecs.vfmax &&\r\ninfo->monspecs.dclkmax && fb_validate_mode(var, info) < 0) {\r\nDPRINTK("mode outside monitor's specs\n");\r\nreturn -EINVAL;\r\n}\r\nvar->xres = (var->xres + 15) & ~15;\r\nlpitch = var->xres * ((var->bits_per_pixel + 7) >> 3);\r\nif (var->xres < 320 || var->xres > 2048) {\r\nDPRINTK("width not supported: %u\n", var->xres);\r\nreturn -EINVAL;\r\n}\r\nif (var->yres < 200 || var->yres > 2048) {\r\nDPRINTK("height not supported: %u\n", var->yres);\r\nreturn -EINVAL;\r\n}\r\nif (lpitch * var->yres_virtual > info->fix.smem_len) {\r\nvar->yres_virtual = info->fix.smem_len / lpitch;\r\nif (var->yres_virtual < var->yres) {\r\nDPRINTK("no memory for screen (%ux%ux%u)\n",\r\nvar->xres, var->yres_virtual,\r\nvar->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (PICOS2KHZ(var->pixclock) > par->max_pixclock) {\r\nDPRINTK("pixclock too high (%ldKHz)\n",\r\nPICOS2KHZ(var->pixclock));\r\nreturn -EINVAL;\r\n}\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.length = 8;\r\nvar->red.offset = 0;\r\nvar->green = var->red;\r\nvar->blue = var->red;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 32:\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\ncase 24:\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nbreak;\r\n}\r\nvar->width = -1;\r\nvar->height = -1;\r\nvar->accel_flags = FB_ACCELF_TEXT;\r\nDPRINTK("Checking graphics mode at %dx%d depth %d\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nreturn 0;\r\n}\r\nstatic int tdfxfb_set_par(struct fb_info *info)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nu32 hdispend = info->var.xres;\r\nu32 hsyncsta = hdispend + info->var.right_margin;\r\nu32 hsyncend = hsyncsta + info->var.hsync_len;\r\nu32 htotal = hsyncend + info->var.left_margin;\r\nu32 hd, hs, he, ht, hbs, hbe;\r\nu32 vd, vs, ve, vt, vbs, vbe;\r\nstruct banshee_reg reg;\r\nint fout, freq;\r\nu32 wd;\r\nu32 cpp = (info->var.bits_per_pixel + 7) >> 3;\r\nmemset(&reg, 0, sizeof(reg));\r\nreg.vidcfg = VIDCFG_VIDPROC_ENABLE | VIDCFG_DESK_ENABLE |\r\nVIDCFG_CURS_X11 |\r\n((cpp - 1) << VIDCFG_PIXFMT_SHIFT) |\r\n(cpp != 1 ? VIDCFG_CLUT_BYPASS : 0);\r\nfreq = PICOS2KHZ(info->var.pixclock);\r\nreg.vidcfg &= ~VIDCFG_2X;\r\nif (freq > par->max_pixclock / 2) {\r\nfreq = freq > par->max_pixclock ? par->max_pixclock : freq;\r\nreg.dacmode |= DACMODE_2X;\r\nreg.vidcfg |= VIDCFG_2X;\r\nhdispend >>= 1;\r\nhsyncsta >>= 1;\r\nhsyncend >>= 1;\r\nhtotal >>= 1;\r\n}\r\nwd = (hdispend >> 3) - 1;\r\nhd = wd;\r\nhs = (hsyncsta >> 3) - 1;\r\nhe = (hsyncend >> 3) - 1;\r\nht = (htotal >> 3) - 1;\r\nhbs = hd;\r\nhbe = ht;\r\nif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {\r\nvd = (info->var.yres << 1) - 1;\r\nvs = vd + (info->var.lower_margin << 1);\r\nve = vs + (info->var.vsync_len << 1);\r\nvt = ve + (info->var.upper_margin << 1) - 1;\r\nreg.screensize = info->var.xres | (info->var.yres << 13);\r\nreg.vidcfg |= VIDCFG_HALF_MODE;\r\nreg.crt[0x09] = 0x80;\r\n} else {\r\nvd = info->var.yres - 1;\r\nvs = vd + info->var.lower_margin;\r\nve = vs + info->var.vsync_len;\r\nvt = ve + info->var.upper_margin - 1;\r\nreg.screensize = info->var.xres | (info->var.yres << 12);\r\nreg.vidcfg &= ~VIDCFG_HALF_MODE;\r\n}\r\nvbs = vd;\r\nvbe = vt;\r\nreg.misc[0x00] = 0x0f |\r\n(info->var.xres < 400 ? 0xa0 :\r\ninfo->var.xres < 480 ? 0x60 :\r\ninfo->var.xres < 768 ? 0xe0 : 0x20);\r\nreg.gra[0x05] = 0x40;\r\nreg.gra[0x06] = 0x05;\r\nreg.gra[0x07] = 0x0f;\r\nreg.gra[0x08] = 0xff;\r\nreg.att[0x00] = 0x00;\r\nreg.att[0x01] = 0x01;\r\nreg.att[0x02] = 0x02;\r\nreg.att[0x03] = 0x03;\r\nreg.att[0x04] = 0x04;\r\nreg.att[0x05] = 0x05;\r\nreg.att[0x06] = 0x06;\r\nreg.att[0x07] = 0x07;\r\nreg.att[0x08] = 0x08;\r\nreg.att[0x09] = 0x09;\r\nreg.att[0x0a] = 0x0a;\r\nreg.att[0x0b] = 0x0b;\r\nreg.att[0x0c] = 0x0c;\r\nreg.att[0x0d] = 0x0d;\r\nreg.att[0x0e] = 0x0e;\r\nreg.att[0x0f] = 0x0f;\r\nreg.att[0x10] = 0x41;\r\nreg.att[0x12] = 0x0f;\r\nreg.seq[0x00] = 0x03;\r\nreg.seq[0x01] = 0x01;\r\nreg.seq[0x02] = 0x0f;\r\nreg.seq[0x03] = 0x00;\r\nreg.seq[0x04] = 0x0e;\r\nreg.crt[0x00] = ht - 4;\r\nreg.crt[0x01] = hd;\r\nreg.crt[0x02] = hbs;\r\nreg.crt[0x03] = 0x80 | (hbe & 0x1f);\r\nreg.crt[0x04] = hs;\r\nreg.crt[0x05] = ((hbe & 0x20) << 2) | (he & 0x1f);\r\nreg.crt[0x06] = vt;\r\nreg.crt[0x07] = ((vs & 0x200) >> 2) |\r\n((vd & 0x200) >> 3) |\r\n((vt & 0x200) >> 4) | 0x10 |\r\n((vbs & 0x100) >> 5) |\r\n((vs & 0x100) >> 6) |\r\n((vd & 0x100) >> 7) |\r\n((vt & 0x100) >> 8);\r\nreg.crt[0x09] |= 0x40 | ((vbs & 0x200) >> 4);\r\nreg.crt[0x10] = vs;\r\nreg.crt[0x11] = (ve & 0x0f) | 0x20;\r\nreg.crt[0x12] = vd;\r\nreg.crt[0x13] = wd;\r\nreg.crt[0x15] = vbs;\r\nreg.crt[0x16] = vbe + 1;\r\nreg.crt[0x17] = 0xc3;\r\nreg.crt[0x18] = 0xff;\r\nreg.ext[0x00] = (((ht & 0x100) >> 8) |\r\n((hd & 0x100) >> 6) |\r\n((hbs & 0x100) >> 4) |\r\n((hbe & 0x40) >> 1) |\r\n((hs & 0x100) >> 2) |\r\n((he & 0x20) << 2));\r\nreg.ext[0x01] = (((vt & 0x400) >> 10) |\r\n((vd & 0x400) >> 8) |\r\n((vbs & 0x400) >> 6) |\r\n((vbe & 0x400) >> 4));\r\nreg.vgainit0 = VGAINIT0_8BIT_DAC |\r\nVGAINIT0_EXT_ENABLE |\r\nVGAINIT0_WAKEUP_3C3 |\r\nVGAINIT0_ALT_READBACK |\r\nVGAINIT0_EXTSHIFTOUT;\r\nreg.vgainit1 = tdfx_inl(par, VGAINIT1) & 0x1fffff;\r\nif (hwcursor)\r\nreg.curspataddr = info->fix.smem_len;\r\nreg.cursloc = 0;\r\nreg.cursc0 = 0;\r\nreg.cursc1 = 0xffffff;\r\nreg.stride = info->var.xres * cpp;\r\nreg.startaddr = info->var.yoffset * reg.stride\r\n+ info->var.xoffset * cpp;\r\nreg.vidpll = do_calc_pll(freq, &fout);\r\n#if 0\r\nreg.mempll = do_calc_pll(..., &fout);\r\nreg.gfxpll = do_calc_pll(..., &fout);\r\n#endif\r\nif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)\r\nreg.vidcfg |= VIDCFG_INTERLACE;\r\nreg.miscinit0 = tdfx_inl(par, MISCINIT0);\r\n#if defined(__BIG_ENDIAN)\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\ncase 24:\r\nreg.miscinit0 &= ~(1 << 30);\r\nreg.miscinit0 &= ~(1 << 31);\r\nbreak;\r\ncase 16:\r\nreg.miscinit0 |= (1 << 30);\r\nreg.miscinit0 |= (1 << 31);\r\nbreak;\r\ncase 32:\r\nreg.miscinit0 |= (1 << 30);\r\nreg.miscinit0 &= ~(1 << 31);\r\nbreak;\r\n}\r\n#endif\r\ndo_write_regs(info, &reg);\r\ninfo->fix.line_length = reg.stride;\r\ninfo->fix.visual = (info->var.bits_per_pixel == 8)\r\n? FB_VISUAL_PSEUDOCOLOR\r\n: FB_VISUAL_TRUECOLOR;\r\nDPRINTK("Graphics mode is now set at %dx%d depth %d\n",\r\ninfo->var.xres, info->var.yres, info->var.bits_per_pixel);\r\nreturn 0;\r\n}\r\nstatic int tdfxfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nu32 rgbcol;\r\nif (regno >= info->cmap.len || regno > 255)\r\nreturn 1;\r\nif (info->var.grayscale) {\r\nblue = (red * 77 + green * 151 + blue * 28) >> 8;\r\ngreen = blue;\r\nred = blue;\r\n}\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nrgbcol = (((u32)red & 0xff00) << 8) |\r\n(((u32)green & 0xff00) << 0) |\r\n(((u32)blue & 0xff00) >> 8);\r\ndo_setpalentry(par, regno, rgbcol);\r\nbreak;\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nrgbcol = (CNVT_TOHW(red, info->var.red.length) <<\r\ninfo->var.red.offset) |\r\n(CNVT_TOHW(green, info->var.green.length) <<\r\ninfo->var.green.offset) |\r\n(CNVT_TOHW(blue, info->var.blue.length) <<\r\ninfo->var.blue.offset) |\r\n(CNVT_TOHW(transp, info->var.transp.length) <<\r\ninfo->var.transp.offset);\r\npar->palette[regno] = rgbcol;\r\n}\r\nbreak;\r\ndefault:\r\nDPRINTK("bad depth %u\n", info->var.bits_per_pixel);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tdfxfb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nint vgablank = 1;\r\nu32 dacmode = tdfx_inl(par, DACMODE);\r\ndacmode &= ~(BIT(1) | BIT(3));\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nvgablank = 0;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ndacmode |= BIT(3);\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ndacmode |= BIT(1);\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\ndacmode |= BIT(1) | BIT(3);\r\nbreak;\r\n}\r\nbanshee_make_room(par, 1);\r\ntdfx_outl(par, DACMODE, dacmode);\r\nif (vgablank)\r\nvga_disable_video(par);\r\nelse\r\nvga_enable_video(par);\r\nreturn 0;\r\n}\r\nstatic int tdfxfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nu32 addr = var->yoffset * info->fix.line_length;\r\nif (nopan || var->xoffset)\r\nreturn -EINVAL;\r\nbanshee_make_room(par, 1);\r\ntdfx_outl(par, VIDDESKSTART, addr);\r\nreturn 0;\r\n}\r\nstatic void tdfxfb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nu32 bpp = info->var.bits_per_pixel;\r\nu32 stride = info->fix.line_length;\r\nu32 fmt = stride | ((bpp + ((bpp == 8) ? 0 : 8)) << 13);\r\nint tdfx_rop;\r\nu32 dx = rect->dx;\r\nu32 dy = rect->dy;\r\nu32 dstbase = 0;\r\nif (rect->rop == ROP_COPY)\r\ntdfx_rop = TDFX_ROP_COPY;\r\nelse\r\ntdfx_rop = TDFX_ROP_XOR;\r\nif (dy + rect->height > 4095) {\r\ndstbase = stride * dy;\r\ndy = 0;\r\n}\r\nif (dx + rect->width > 4095) {\r\ndstbase += dx * bpp >> 3;\r\ndx = 0;\r\n}\r\nbanshee_make_room(par, 6);\r\ntdfx_outl(par, DSTFORMAT, fmt);\r\nif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR) {\r\ntdfx_outl(par, COLORFORE, rect->color);\r\n} else {\r\ntdfx_outl(par, COLORFORE, par->palette[rect->color]);\r\n}\r\ntdfx_outl(par, COMMAND_2D, COMMAND_2D_FILLRECT | (tdfx_rop << 24));\r\ntdfx_outl(par, DSTBASE, dstbase);\r\ntdfx_outl(par, DSTSIZE, rect->width | (rect->height << 16));\r\ntdfx_outl(par, LAUNCH_2D, dx | (dy << 16));\r\n}\r\nstatic void tdfxfb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nu32 sx = area->sx, sy = area->sy, dx = area->dx, dy = area->dy;\r\nu32 bpp = info->var.bits_per_pixel;\r\nu32 stride = info->fix.line_length;\r\nu32 blitcmd = COMMAND_2D_S2S_BITBLT | (TDFX_ROP_COPY << 24);\r\nu32 fmt = stride | ((bpp + ((bpp == 8) ? 0 : 8)) << 13);\r\nu32 dstbase = 0;\r\nu32 srcbase = 0;\r\nif (sy + area->height > 4095) {\r\nsrcbase = stride * sy;\r\nsy = 0;\r\n}\r\nif (sx + area->width > 4095) {\r\nsrcbase += sx * bpp >> 3;\r\nsx = 0;\r\n}\r\nif (dy + area->height > 4095) {\r\ndstbase = stride * dy;\r\ndy = 0;\r\n}\r\nif (dx + area->width > 4095) {\r\ndstbase += dx * bpp >> 3;\r\ndx = 0;\r\n}\r\nif (area->sx <= area->dx) {\r\nblitcmd |= BIT(14);\r\nsx += area->width - 1;\r\ndx += area->width - 1;\r\n}\r\nif (area->sy <= area->dy) {\r\nblitcmd |= BIT(15);\r\nsy += area->height - 1;\r\ndy += area->height - 1;\r\n}\r\nbanshee_make_room(par, 8);\r\ntdfx_outl(par, SRCFORMAT, fmt);\r\ntdfx_outl(par, DSTFORMAT, fmt);\r\ntdfx_outl(par, COMMAND_2D, blitcmd);\r\ntdfx_outl(par, DSTSIZE, area->width | (area->height << 16));\r\ntdfx_outl(par, DSTXY, dx | (dy << 16));\r\ntdfx_outl(par, SRCBASE, srcbase);\r\ntdfx_outl(par, DSTBASE, dstbase);\r\ntdfx_outl(par, LAUNCH_2D, sx | (sy << 16));\r\n}\r\nstatic void tdfxfb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nint size = image->height * ((image->width * image->depth + 7) >> 3);\r\nint fifo_free;\r\nint i, stride = info->fix.line_length;\r\nu32 bpp = info->var.bits_per_pixel;\r\nu32 dstfmt = stride | ((bpp + ((bpp == 8) ? 0 : 8)) << 13);\r\nu8 *chardata = (u8 *) image->data;\r\nu32 srcfmt;\r\nu32 dx = image->dx;\r\nu32 dy = image->dy;\r\nu32 dstbase = 0;\r\nif (image->depth != 1) {\r\n#ifdef BROKEN_CODE\r\nbanshee_make_room(par, 6 + ((size + 3) >> 2));\r\nsrcfmt = stride | ((bpp + ((bpp == 8) ? 0 : 8)) << 13) |\r\n0x400000;\r\n#else\r\ncfb_imageblit(info, image);\r\n#endif\r\nreturn;\r\n}\r\nbanshee_make_room(par, 9);\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\ntdfx_outl(par, COLORFORE, image->fg_color);\r\ntdfx_outl(par, COLORBACK, image->bg_color);\r\nbreak;\r\ncase FB_VISUAL_TRUECOLOR:\r\ndefault:\r\ntdfx_outl(par, COLORFORE,\r\npar->palette[image->fg_color]);\r\ntdfx_outl(par, COLORBACK,\r\npar->palette[image->bg_color]);\r\n}\r\n#ifdef __BIG_ENDIAN\r\nsrcfmt = 0x400000 | BIT(20);\r\n#else\r\nsrcfmt = 0x400000;\r\n#endif\r\nif (dy + image->height > 4095) {\r\ndstbase = stride * dy;\r\ndy = 0;\r\n}\r\nif (dx + image->width > 4095) {\r\ndstbase += dx * bpp >> 3;\r\ndx = 0;\r\n}\r\ntdfx_outl(par, DSTBASE, dstbase);\r\ntdfx_outl(par, SRCXY, 0);\r\ntdfx_outl(par, DSTXY, dx | (dy << 16));\r\ntdfx_outl(par, COMMAND_2D,\r\nCOMMAND_2D_H2S_BITBLT | (TDFX_ROP_COPY << 24));\r\ntdfx_outl(par, SRCFORMAT, srcfmt);\r\ntdfx_outl(par, DSTFORMAT, dstfmt);\r\ntdfx_outl(par, DSTSIZE, image->width | (image->height << 16));\r\nfifo_free = 0;\r\nfor (i = (size >> 2); i > 0; i--) {\r\nif (--fifo_free < 0) {\r\nfifo_free = 31;\r\nbanshee_make_room(par, fifo_free);\r\n}\r\ntdfx_outl(par, LAUNCH_2D, *(u32 *)chardata);\r\nchardata += 4;\r\n}\r\nbanshee_make_room(par, 3);\r\nswitch (size % 4) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\ntdfx_outl(par, LAUNCH_2D, *chardata);\r\nbreak;\r\ncase 2:\r\ntdfx_outl(par, LAUNCH_2D, *(u16 *)chardata);\r\nbreak;\r\ncase 3:\r\ntdfx_outl(par, LAUNCH_2D,\r\n*(u16 *)chardata | (chardata[3] << 24));\r\nbreak;\r\n}\r\n}\r\nstatic int tdfxfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct tdfx_par *par = info->par;\r\nu32 vidcfg;\r\nif (!hwcursor)\r\nreturn -EINVAL;\r\nif (cursor->image.width > 64 ||\r\ncursor->image.height > 64 ||\r\ncursor->image.depth > 1)\r\nreturn -EINVAL;\r\nvidcfg = tdfx_inl(par, VIDPROCCFG);\r\nif (cursor->enable)\r\ntdfx_outl(par, VIDPROCCFG, vidcfg | VIDCFG_HWCURSOR_ENABLE);\r\nelse\r\ntdfx_outl(par, VIDPROCCFG, vidcfg & ~VIDCFG_HWCURSOR_ENABLE);\r\nif (!cursor->set)\r\nreturn 0;\r\nif (cursor->set & FB_CUR_SETCMAP) {\r\nstruct fb_cmap cmap = info->cmap;\r\nu32 bg_idx = cursor->image.bg_color;\r\nu32 fg_idx = cursor->image.fg_color;\r\nunsigned long bg_color, fg_color;\r\nfg_color = (((u32)cmap.red[fg_idx] & 0xff00) << 8) |\r\n(((u32)cmap.green[fg_idx] & 0xff00) << 0) |\r\n(((u32)cmap.blue[fg_idx] & 0xff00) >> 8);\r\nbg_color = (((u32)cmap.red[bg_idx] & 0xff00) << 8) |\r\n(((u32)cmap.green[bg_idx] & 0xff00) << 0) |\r\n(((u32)cmap.blue[bg_idx] & 0xff00) >> 8);\r\nbanshee_make_room(par, 2);\r\ntdfx_outl(par, HWCURC0, bg_color);\r\ntdfx_outl(par, HWCURC1, fg_color);\r\n}\r\nif (cursor->set & FB_CUR_SETPOS) {\r\nint x = cursor->image.dx;\r\nint y = cursor->image.dy - info->var.yoffset;\r\nx += 63;\r\ny += 63;\r\nbanshee_make_room(par, 1);\r\ntdfx_outl(par, HWCURLOC, (y << 16) + x);\r\n}\r\nif (cursor->set & (FB_CUR_SETIMAGE | FB_CUR_SETSHAPE)) {\r\nu8 __iomem *cursorbase = info->screen_base + info->fix.smem_len;\r\nu8 *bitmap = (u8 *)cursor->image.data;\r\nu8 *mask = (u8 *)cursor->mask;\r\nint i;\r\nfb_memset(cursorbase, 0, 1024);\r\nfor (i = 0; i < cursor->image.height; i++) {\r\nint h = 0;\r\nint j = (cursor->image.width + 7) >> 3;\r\nfor (; j > 0; j--) {\r\nu8 data = *mask ^ *bitmap;\r\nif (cursor->rop == ROP_COPY)\r\ndata = *mask & *bitmap;\r\nfb_writeb(*mask, cursorbase + h);\r\nmask++;\r\nfb_writeb(data, cursorbase + h + 8);\r\nbitmap++;\r\nh++;\r\n}\r\ncursorbase += 16;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void tdfxfb_i2c_setscl(void *data, int val)\r\n{\r\nstruct tdfxfb_i2c_chan *chan = data;\r\nstruct tdfx_par *par = chan->par;\r\nunsigned int r;\r\nr = tdfx_inl(par, VIDSERPARPORT);\r\nif (val)\r\nr |= I2C_SCL_OUT;\r\nelse\r\nr &= ~I2C_SCL_OUT;\r\ntdfx_outl(par, VIDSERPARPORT, r);\r\ntdfx_inl(par, VIDSERPARPORT);\r\n}\r\nstatic void tdfxfb_i2c_setsda(void *data, int val)\r\n{\r\nstruct tdfxfb_i2c_chan *chan = data;\r\nstruct tdfx_par *par = chan->par;\r\nunsigned int r;\r\nr = tdfx_inl(par, VIDSERPARPORT);\r\nif (val)\r\nr |= I2C_SDA_OUT;\r\nelse\r\nr &= ~I2C_SDA_OUT;\r\ntdfx_outl(par, VIDSERPARPORT, r);\r\ntdfx_inl(par, VIDSERPARPORT);\r\n}\r\nstatic int tdfxfb_i2c_getscl(void *data)\r\n{\r\nstruct tdfxfb_i2c_chan *chan = data;\r\nstruct tdfx_par *par = chan->par;\r\nreturn (0 != (tdfx_inl(par, VIDSERPARPORT) & I2C_SCL_IN));\r\n}\r\nstatic int tdfxfb_i2c_getsda(void *data)\r\n{\r\nstruct tdfxfb_i2c_chan *chan = data;\r\nstruct tdfx_par *par = chan->par;\r\nreturn (0 != (tdfx_inl(par, VIDSERPARPORT) & I2C_SDA_IN));\r\n}\r\nstatic void tdfxfb_ddc_setscl(void *data, int val)\r\n{\r\nstruct tdfxfb_i2c_chan *chan = data;\r\nstruct tdfx_par *par = chan->par;\r\nunsigned int r;\r\nr = tdfx_inl(par, VIDSERPARPORT);\r\nif (val)\r\nr |= DDC_SCL_OUT;\r\nelse\r\nr &= ~DDC_SCL_OUT;\r\ntdfx_outl(par, VIDSERPARPORT, r);\r\ntdfx_inl(par, VIDSERPARPORT);\r\n}\r\nstatic void tdfxfb_ddc_setsda(void *data, int val)\r\n{\r\nstruct tdfxfb_i2c_chan *chan = data;\r\nstruct tdfx_par *par = chan->par;\r\nunsigned int r;\r\nr = tdfx_inl(par, VIDSERPARPORT);\r\nif (val)\r\nr |= DDC_SDA_OUT;\r\nelse\r\nr &= ~DDC_SDA_OUT;\r\ntdfx_outl(par, VIDSERPARPORT, r);\r\ntdfx_inl(par, VIDSERPARPORT);\r\n}\r\nstatic int tdfxfb_ddc_getscl(void *data)\r\n{\r\nstruct tdfxfb_i2c_chan *chan = data;\r\nstruct tdfx_par *par = chan->par;\r\nreturn (0 != (tdfx_inl(par, VIDSERPARPORT) & DDC_SCL_IN));\r\n}\r\nstatic int tdfxfb_ddc_getsda(void *data)\r\n{\r\nstruct tdfxfb_i2c_chan *chan = data;\r\nstruct tdfx_par *par = chan->par;\r\nreturn (0 != (tdfx_inl(par, VIDSERPARPORT) & DDC_SDA_IN));\r\n}\r\nstatic int tdfxfb_setup_ddc_bus(struct tdfxfb_i2c_chan *chan, const char *name,\r\nstruct device *dev)\r\n{\r\nint rc;\r\nstrlcpy(chan->adapter.name, name, sizeof(chan->adapter.name));\r\nchan->adapter.owner = THIS_MODULE;\r\nchan->adapter.class = I2C_CLASS_DDC;\r\nchan->adapter.algo_data = &chan->algo;\r\nchan->adapter.dev.parent = dev;\r\nchan->algo.setsda = tdfxfb_ddc_setsda;\r\nchan->algo.setscl = tdfxfb_ddc_setscl;\r\nchan->algo.getsda = tdfxfb_ddc_getsda;\r\nchan->algo.getscl = tdfxfb_ddc_getscl;\r\nchan->algo.udelay = 10;\r\nchan->algo.timeout = msecs_to_jiffies(500);\r\nchan->algo.data = chan;\r\ni2c_set_adapdata(&chan->adapter, chan);\r\nrc = i2c_bit_add_bus(&chan->adapter);\r\nif (rc == 0)\r\nDPRINTK("I2C bus %s registered.\n", name);\r\nelse\r\nchan->par = NULL;\r\nreturn rc;\r\n}\r\nstatic int tdfxfb_setup_i2c_bus(struct tdfxfb_i2c_chan *chan, const char *name,\r\nstruct device *dev)\r\n{\r\nint rc;\r\nstrlcpy(chan->adapter.name, name, sizeof(chan->adapter.name));\r\nchan->adapter.owner = THIS_MODULE;\r\nchan->adapter.algo_data = &chan->algo;\r\nchan->adapter.dev.parent = dev;\r\nchan->algo.setsda = tdfxfb_i2c_setsda;\r\nchan->algo.setscl = tdfxfb_i2c_setscl;\r\nchan->algo.getsda = tdfxfb_i2c_getsda;\r\nchan->algo.getscl = tdfxfb_i2c_getscl;\r\nchan->algo.udelay = 10;\r\nchan->algo.timeout = msecs_to_jiffies(500);\r\nchan->algo.data = chan;\r\ni2c_set_adapdata(&chan->adapter, chan);\r\nrc = i2c_bit_add_bus(&chan->adapter);\r\nif (rc == 0)\r\nDPRINTK("I2C bus %s registered.\n", name);\r\nelse\r\nchan->par = NULL;\r\nreturn rc;\r\n}\r\nstatic void tdfxfb_create_i2c_busses(struct fb_info *info)\r\n{\r\nstruct tdfx_par *par = info->par;\r\ntdfx_outl(par, VIDINFORMAT, 0x8160);\r\ntdfx_outl(par, VIDSERPARPORT, 0xcffc0020);\r\npar->chan[0].par = par;\r\npar->chan[1].par = par;\r\ntdfxfb_setup_ddc_bus(&par->chan[0], "Voodoo3-DDC", info->dev);\r\ntdfxfb_setup_i2c_bus(&par->chan[1], "Voodoo3-I2C", info->dev);\r\n}\r\nstatic void tdfxfb_delete_i2c_busses(struct tdfx_par *par)\r\n{\r\nif (par->chan[0].par)\r\ni2c_del_adapter(&par->chan[0].adapter);\r\npar->chan[0].par = NULL;\r\nif (par->chan[1].par)\r\ni2c_del_adapter(&par->chan[1].adapter);\r\npar->chan[1].par = NULL;\r\n}\r\nstatic int tdfxfb_probe_i2c_connector(struct tdfx_par *par,\r\nstruct fb_monspecs *specs)\r\n{\r\nu8 *edid = NULL;\r\nDPRINTK("Probe DDC Bus\n");\r\nif (par->chan[0].par)\r\nedid = fb_ddc_read(&par->chan[0].adapter);\r\nif (edid) {\r\nfb_edid_to_monspecs(edid, specs);\r\nkfree(edid);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int tdfxfb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct tdfx_par *default_par;\r\nstruct fb_info *info;\r\nint err, lpitch;\r\nstruct fb_monspecs *specs;\r\nbool found;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nprintk(KERN_ERR "tdfxfb: Can't enable pdev: %d\n", err);\r\nreturn err;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct tdfx_par), &pdev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\ndefault_par = info->par;\r\ninfo->fix = tdfx_fix;\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_3DFX_BANSHEE:\r\nstrcpy(info->fix.id, "3Dfx Banshee");\r\ndefault_par->max_pixclock = BANSHEE_MAX_PIXCLOCK;\r\nbreak;\r\ncase PCI_DEVICE_ID_3DFX_VOODOO3:\r\nstrcpy(info->fix.id, "3Dfx Voodoo3");\r\ndefault_par->max_pixclock = VOODOO3_MAX_PIXCLOCK;\r\nbreak;\r\ncase PCI_DEVICE_ID_3DFX_VOODOO5:\r\nstrcpy(info->fix.id, "3Dfx Voodoo5");\r\ndefault_par->max_pixclock = VOODOO5_MAX_PIXCLOCK;\r\nbreak;\r\n}\r\ninfo->fix.mmio_start = pci_resource_start(pdev, 0);\r\ninfo->fix.mmio_len = pci_resource_len(pdev, 0);\r\nif (!request_mem_region(info->fix.mmio_start, info->fix.mmio_len,\r\n"tdfx regbase")) {\r\nprintk(KERN_ERR "tdfxfb: Can't reserve regbase\n");\r\ngoto out_err;\r\n}\r\ndefault_par->regbase_virt =\r\nioremap_nocache(info->fix.mmio_start, info->fix.mmio_len);\r\nif (!default_par->regbase_virt) {\r\nprintk(KERN_ERR "fb: Can't remap %s register area.\n",\r\ninfo->fix.id);\r\ngoto out_err_regbase;\r\n}\r\ninfo->fix.smem_start = pci_resource_start(pdev, 1);\r\ninfo->fix.smem_len = do_lfb_size(default_par, pdev->device);\r\nif (!info->fix.smem_len) {\r\nprintk(KERN_ERR "fb: Can't count %s memory.\n", info->fix.id);\r\ngoto out_err_regbase;\r\n}\r\nif (!request_mem_region(info->fix.smem_start,\r\npci_resource_len(pdev, 1), "tdfx smem")) {\r\nprintk(KERN_ERR "tdfxfb: Can't reserve smem\n");\r\ngoto out_err_regbase;\r\n}\r\ninfo->screen_base = ioremap_wc(info->fix.smem_start,\r\ninfo->fix.smem_len);\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR "fb: Can't remap %s framebuffer.\n",\r\ninfo->fix.id);\r\ngoto out_err_screenbase;\r\n}\r\ndefault_par->iobase = pci_resource_start(pdev, 2);\r\nif (!request_region(pci_resource_start(pdev, 2),\r\npci_resource_len(pdev, 2), "tdfx iobase")) {\r\nprintk(KERN_ERR "tdfxfb: Can't reserve iobase\n");\r\ngoto out_err_screenbase;\r\n}\r\nprintk(KERN_INFO "fb: %s memory = %dK\n", info->fix.id,\r\ninfo->fix.smem_len >> 10);\r\nif (!nomtrr)\r\ndefault_par->wc_cookie= arch_phys_wc_add(info->fix.smem_start,\r\ninfo->fix.smem_len);\r\ninfo->fix.ypanstep = nopan ? 0 : 1;\r\ninfo->fix.ywrapstep = nowrap ? 0 : 1;\r\ninfo->fbops = &tdfxfb_ops;\r\ninfo->pseudo_palette = default_par->palette;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\n#ifdef CONFIG_FB_3DFX_ACCEL\r\ninfo->flags |= FBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_IMAGEBLIT |\r\nFBINFO_READS_FAST;\r\n#endif\r\nif (hwcursor)\r\ninfo->fix.smem_len = (info->fix.smem_len - 1024) &\r\n(PAGE_MASK << 1);\r\nspecs = &info->monspecs;\r\nfound = false;\r\ninfo->var.bits_per_pixel = 8;\r\n#ifdef CONFIG_FB_3DFX_I2C\r\ntdfxfb_create_i2c_busses(info);\r\nerr = tdfxfb_probe_i2c_connector(default_par, specs);\r\nif (!err) {\r\nif (specs->modedb == NULL)\r\nDPRINTK("Unable to get Mode Database\n");\r\nelse {\r\nconst struct fb_videomode *m;\r\nfb_videomode_to_modelist(specs->modedb,\r\nspecs->modedb_len,\r\n&info->modelist);\r\nm = fb_find_best_display(specs, &info->modelist);\r\nif (m) {\r\nfb_videomode_to_var(&info->var, m);\r\nif (tdfxfb_check_var(&info->var, info) < 0)\r\ninfo->var = tdfx_var;\r\nelse\r\nfound = true;\r\n}\r\n}\r\n}\r\n#endif\r\nif (!mode_option && !found)\r\nmode_option = "640x480@60";\r\nif (mode_option) {\r\nerr = fb_find_mode(&info->var, info, mode_option,\r\nspecs->modedb, specs->modedb_len,\r\nNULL, info->var.bits_per_pixel);\r\nif (!err || err == 4)\r\ninfo->var = tdfx_var;\r\n}\r\nif (found) {\r\nfb_destroy_modedb(specs->modedb);\r\nspecs->modedb = NULL;\r\n}\r\nlpitch = info->var.xres_virtual * ((info->var.bits_per_pixel + 7) >> 3);\r\ninfo->var.yres_virtual = info->fix.smem_len / lpitch;\r\nif (info->var.yres_virtual < info->var.yres)\r\ngoto out_err_iobase;\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\r\nprintk(KERN_ERR "tdfxfb: Can't allocate color map\n");\r\ngoto out_err_iobase;\r\n}\r\nif (register_framebuffer(info) < 0) {\r\nprintk(KERN_ERR "tdfxfb: can't register framebuffer\n");\r\nfb_dealloc_cmap(&info->cmap);\r\ngoto out_err_iobase;\r\n}\r\npci_set_drvdata(pdev, info);\r\nreturn 0;\r\nout_err_iobase:\r\n#ifdef CONFIG_FB_3DFX_I2C\r\ntdfxfb_delete_i2c_busses(default_par);\r\n#endif\r\narch_phys_wc_del(default_par->wc_cookie);\r\nrelease_region(pci_resource_start(pdev, 2),\r\npci_resource_len(pdev, 2));\r\nout_err_screenbase:\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\nrelease_mem_region(info->fix.smem_start, pci_resource_len(pdev, 1));\r\nout_err_regbase:\r\nif (default_par->regbase_virt)\r\niounmap(default_par->regbase_virt);\r\nrelease_mem_region(info->fix.mmio_start, info->fix.mmio_len);\r\nout_err:\r\nframebuffer_release(info);\r\nreturn -ENXIO;\r\n}\r\nstatic void __init tdfxfb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strcmp(this_opt, "nopan")) {\r\nnopan = 1;\r\n} else if (!strcmp(this_opt, "nowrap")) {\r\nnowrap = 1;\r\n} else if (!strncmp(this_opt, "hwcursor=", 9)) {\r\nhwcursor = simple_strtoul(this_opt + 9, NULL, 0);\r\n} else if (!strncmp(this_opt, "nomtrr", 6)) {\r\nnomtrr = 1;\r\n} else {\r\nmode_option = this_opt;\r\n}\r\n}\r\n}\r\nstatic void tdfxfb_remove(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct tdfx_par *par = info->par;\r\nunregister_framebuffer(info);\r\n#ifdef CONFIG_FB_3DFX_I2C\r\ntdfxfb_delete_i2c_busses(par);\r\n#endif\r\narch_phys_wc_del(par->wc_cookie);\r\niounmap(par->regbase_virt);\r\niounmap(info->screen_base);\r\nrelease_region(pci_resource_start(pdev, 2),\r\npci_resource_len(pdev, 2));\r\nrelease_mem_region(pci_resource_start(pdev, 1),\r\npci_resource_len(pdev, 1));\r\nrelease_mem_region(pci_resource_start(pdev, 0),\r\npci_resource_len(pdev, 0));\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nstatic int __init tdfxfb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("tdfxfb", &option))\r\nreturn -ENODEV;\r\ntdfxfb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&tdfxfb_driver);\r\n}\r\nstatic void __exit tdfxfb_exit(void)\r\n{\r\npci_unregister_driver(&tdfxfb_driver);\r\n}
