static unsigned long clk_programmable_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_programmable *prog = to_clk_programmable(hw);\r\nunsigned int pckr;\r\nregmap_read(prog->regmap, AT91_PMC_PCKR(prog->id), &pckr);\r\nreturn parent_rate >> PROG_PRES(prog->layout, pckr);\r\n}\r\nstatic int clk_programmable_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_hw *parent;\r\nlong best_rate = -EINVAL;\r\nunsigned long parent_rate;\r\nunsigned long tmp_rate;\r\nint shift;\r\nint i;\r\nfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\r\nparent = clk_hw_get_parent_by_index(hw, i);\r\nif (!parent)\r\ncontinue;\r\nparent_rate = clk_hw_get_rate(parent);\r\nfor (shift = 0; shift < PROG_PRES_MASK; shift++) {\r\ntmp_rate = parent_rate >> shift;\r\nif (tmp_rate <= req->rate)\r\nbreak;\r\n}\r\nif (tmp_rate > req->rate)\r\ncontinue;\r\nif (best_rate < 0 ||\r\n(req->rate - tmp_rate) < (req->rate - best_rate)) {\r\nbest_rate = tmp_rate;\r\nreq->best_parent_rate = parent_rate;\r\nreq->best_parent_hw = parent;\r\n}\r\nif (!best_rate)\r\nbreak;\r\n}\r\nif (best_rate < 0)\r\nreturn best_rate;\r\nreq->rate = best_rate;\r\nreturn 0;\r\n}\r\nstatic int clk_programmable_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_programmable *prog = to_clk_programmable(hw);\r\nconst struct clk_programmable_layout *layout = prog->layout;\r\nunsigned int mask = layout->css_mask;\r\nunsigned int pckr = index;\r\nif (layout->have_slck_mck)\r\nmask |= AT91_PMC_CSSMCK_MCK;\r\nif (index > layout->css_mask) {\r\nif (index > PROG_MAX_RM9200_CSS && !layout->have_slck_mck)\r\nreturn -EINVAL;\r\npckr |= AT91_PMC_CSSMCK_MCK;\r\n}\r\nregmap_update_bits(prog->regmap, AT91_PMC_PCKR(prog->id), mask, pckr);\r\nreturn 0;\r\n}\r\nstatic u8 clk_programmable_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_programmable *prog = to_clk_programmable(hw);\r\nconst struct clk_programmable_layout *layout = prog->layout;\r\nunsigned int pckr;\r\nu8 ret;\r\nregmap_read(prog->regmap, AT91_PMC_PCKR(prog->id), &pckr);\r\nret = pckr & layout->css_mask;\r\nif (layout->have_slck_mck && (pckr & AT91_PMC_CSSMCK_MCK) && !ret)\r\nret = PROG_MAX_RM9200_CSS + 1;\r\nreturn ret;\r\n}\r\nstatic int clk_programmable_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_programmable *prog = to_clk_programmable(hw);\r\nconst struct clk_programmable_layout *layout = prog->layout;\r\nunsigned long div = parent_rate / rate;\r\nunsigned int pckr;\r\nint shift = 0;\r\nregmap_read(prog->regmap, AT91_PMC_PCKR(prog->id), &pckr);\r\nif (!div)\r\nreturn -EINVAL;\r\nshift = fls(div) - 1;\r\nif (div != (1 << shift))\r\nreturn -EINVAL;\r\nif (shift >= PROG_PRES_MASK)\r\nreturn -EINVAL;\r\nregmap_update_bits(prog->regmap, AT91_PMC_PCKR(prog->id),\r\nPROG_PRES_MASK << layout->pres_shift,\r\nshift << layout->pres_shift);\r\nreturn 0;\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_programmable(struct regmap *regmap,\r\nconst char *name, const char **parent_names,\r\nu8 num_parents, u8 id,\r\nconst struct clk_programmable_layout *layout)\r\n{\r\nstruct clk_programmable *prog;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (id > PROG_ID_MAX)\r\nreturn ERR_PTR(-EINVAL);\r\nprog = kzalloc(sizeof(*prog), GFP_KERNEL);\r\nif (!prog)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &programmable_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\r\nprog->id = id;\r\nprog->layout = layout;\r\nprog->hw.init = &init;\r\nprog->regmap = regmap;\r\nclk = clk_register(NULL, &prog->hw);\r\nif (IS_ERR(clk))\r\nkfree(prog);\r\nreturn clk;\r\n}\r\nstatic void __init\r\nof_at91_clk_prog_setup(struct device_node *np,\r\nconst struct clk_programmable_layout *layout)\r\n{\r\nint num;\r\nu32 id;\r\nstruct clk *clk;\r\nunsigned int num_parents;\r\nconst char *parent_names[PROG_SOURCE_MAX];\r\nconst char *name;\r\nstruct device_node *progclknp;\r\nstruct regmap *regmap;\r\nnum_parents = of_clk_get_parent_count(np);\r\nif (num_parents == 0 || num_parents > PROG_SOURCE_MAX)\r\nreturn;\r\nof_clk_parent_fill(np, parent_names, num_parents);\r\nnum = of_get_child_count(np);\r\nif (!num || num > (PROG_ID_MAX + 1))\r\nreturn;\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nfor_each_child_of_node(np, progclknp) {\r\nif (of_property_read_u32(progclknp, "reg", &id))\r\ncontinue;\r\nif (of_property_read_string(np, "clock-output-names", &name))\r\nname = progclknp->name;\r\nclk = at91_clk_register_programmable(regmap, name,\r\nparent_names, num_parents,\r\nid, layout);\r\nif (IS_ERR(clk))\r\ncontinue;\r\nof_clk_add_provider(progclknp, of_clk_src_simple_get, clk);\r\n}\r\n}\r\nstatic void __init of_at91rm9200_clk_prog_setup(struct device_node *np)\r\n{\r\nof_at91_clk_prog_setup(np, &at91rm9200_programmable_layout);\r\n}\r\nstatic void __init of_at91sam9g45_clk_prog_setup(struct device_node *np)\r\n{\r\nof_at91_clk_prog_setup(np, &at91sam9g45_programmable_layout);\r\n}\r\nstatic void __init of_at91sam9x5_clk_prog_setup(struct device_node *np)\r\n{\r\nof_at91_clk_prog_setup(np, &at91sam9x5_programmable_layout);\r\n}
