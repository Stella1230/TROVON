static int config_out_of_range(struct pci_pbm_info *pbm,\r\nunsigned long bus,\r\nunsigned long devfn,\r\nunsigned long reg)\r\n{\r\nif (bus < pbm->pci_first_busno ||\r\nbus > pbm->pci_last_busno)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void *sun4u_config_mkaddr(struct pci_pbm_info *pbm,\r\nunsigned long bus,\r\nunsigned long devfn,\r\nunsigned long reg)\r\n{\r\nunsigned long rbits = pbm->config_space_reg_bits;\r\nif (config_out_of_range(pbm, bus, devfn, reg))\r\nreturn NULL;\r\nreg = (reg & ((1 << rbits) - 1));\r\ndevfn <<= rbits;\r\nbus <<= rbits + 8;\r\nreturn (void *) (pbm->config_space | bus | devfn | reg);\r\n}\r\nstatic int sun4u_read_pci_cfg_host(struct pci_pbm_info *pbm,\r\nunsigned char bus, unsigned int devfn,\r\nint where, int size, u32 *value)\r\n{\r\nu32 tmp32, *addr;\r\nu16 tmp16;\r\nu8 tmp8;\r\naddr = sun4u_config_mkaddr(pbm, bus, devfn, where);\r\nif (!addr)\r\nreturn PCIBIOS_SUCCESSFUL;\r\nswitch (size) {\r\ncase 1:\r\nif (where < 8) {\r\nunsigned long align = (unsigned long) addr;\r\nalign &= ~1;\r\npci_config_read16((u16 *)align, &tmp16);\r\nif (where & 1)\r\n*value = tmp16 >> 8;\r\nelse\r\n*value = tmp16 & 0xff;\r\n} else {\r\npci_config_read8((u8 *)addr, &tmp8);\r\n*value = (u32) tmp8;\r\n}\r\nbreak;\r\ncase 2:\r\nif (where < 8) {\r\npci_config_read16((u16 *)addr, &tmp16);\r\n*value = (u32) tmp16;\r\n} else {\r\npci_config_read8((u8 *)addr, &tmp8);\r\n*value = (u32) tmp8;\r\npci_config_read8(((u8 *)addr) + 1, &tmp8);\r\n*value |= ((u32) tmp8) << 8;\r\n}\r\nbreak;\r\ncase 4:\r\ntmp32 = 0xffffffff;\r\nsun4u_read_pci_cfg_host(pbm, bus, devfn,\r\nwhere, 2, &tmp32);\r\n*value = tmp32;\r\ntmp32 = 0xffffffff;\r\nsun4u_read_pci_cfg_host(pbm, bus, devfn,\r\nwhere + 2, 2, &tmp32);\r\n*value |= tmp32 << 16;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int sun4u_read_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,\r\nint where, int size, u32 *value)\r\n{\r\nstruct pci_pbm_info *pbm = bus_dev->sysdata;\r\nunsigned char bus = bus_dev->number;\r\nu32 *addr;\r\nu16 tmp16;\r\nu8 tmp8;\r\nswitch (size) {\r\ncase 1:\r\n*value = 0xff;\r\nbreak;\r\ncase 2:\r\n*value = 0xffff;\r\nbreak;\r\ncase 4:\r\n*value = 0xffffffff;\r\nbreak;\r\n}\r\nif (!bus_dev->number && !PCI_SLOT(devfn))\r\nreturn sun4u_read_pci_cfg_host(pbm, bus, devfn, where,\r\nsize, value);\r\naddr = sun4u_config_mkaddr(pbm, bus, devfn, where);\r\nif (!addr)\r\nreturn PCIBIOS_SUCCESSFUL;\r\nswitch (size) {\r\ncase 1:\r\npci_config_read8((u8 *)addr, &tmp8);\r\n*value = (u32) tmp8;\r\nbreak;\r\ncase 2:\r\nif (where & 0x01) {\r\nprintk("pci_read_config_word: misaligned reg [%x]\n",\r\nwhere);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\npci_config_read16((u16 *)addr, &tmp16);\r\n*value = (u32) tmp16;\r\nbreak;\r\ncase 4:\r\nif (where & 0x03) {\r\nprintk("pci_read_config_dword: misaligned reg [%x]\n",\r\nwhere);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\npci_config_read32(addr, value);\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int sun4u_write_pci_cfg_host(struct pci_pbm_info *pbm,\r\nunsigned char bus, unsigned int devfn,\r\nint where, int size, u32 value)\r\n{\r\nu32 *addr;\r\naddr = sun4u_config_mkaddr(pbm, bus, devfn, where);\r\nif (!addr)\r\nreturn PCIBIOS_SUCCESSFUL;\r\nswitch (size) {\r\ncase 1:\r\nif (where < 8) {\r\nunsigned long align = (unsigned long) addr;\r\nu16 tmp16;\r\nalign &= ~1;\r\npci_config_read16((u16 *)align, &tmp16);\r\nif (where & 1) {\r\ntmp16 &= 0x00ff;\r\ntmp16 |= value << 8;\r\n} else {\r\ntmp16 &= 0xff00;\r\ntmp16 |= value;\r\n}\r\npci_config_write16((u16 *)align, tmp16);\r\n} else\r\npci_config_write8((u8 *)addr, value);\r\nbreak;\r\ncase 2:\r\nif (where < 8) {\r\npci_config_write16((u16 *)addr, value);\r\n} else {\r\npci_config_write8((u8 *)addr, value & 0xff);\r\npci_config_write8(((u8 *)addr) + 1, value >> 8);\r\n}\r\nbreak;\r\ncase 4:\r\nsun4u_write_pci_cfg_host(pbm, bus, devfn,\r\nwhere, 2, value & 0xffff);\r\nsun4u_write_pci_cfg_host(pbm, bus, devfn,\r\nwhere + 2, 2, value >> 16);\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int sun4u_write_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,\r\nint where, int size, u32 value)\r\n{\r\nstruct pci_pbm_info *pbm = bus_dev->sysdata;\r\nunsigned char bus = bus_dev->number;\r\nu32 *addr;\r\nif (!bus_dev->number && !PCI_SLOT(devfn))\r\nreturn sun4u_write_pci_cfg_host(pbm, bus, devfn, where,\r\nsize, value);\r\naddr = sun4u_config_mkaddr(pbm, bus, devfn, where);\r\nif (!addr)\r\nreturn PCIBIOS_SUCCESSFUL;\r\nswitch (size) {\r\ncase 1:\r\npci_config_write8((u8 *)addr, value);\r\nbreak;\r\ncase 2:\r\nif (where & 0x01) {\r\nprintk("pci_write_config_word: misaligned reg [%x]\n",\r\nwhere);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\npci_config_write16((u16 *)addr, value);\r\nbreak;\r\ncase 4:\r\nif (where & 0x03) {\r\nprintk("pci_write_config_dword: misaligned reg [%x]\n",\r\nwhere);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\npci_config_write32(addr, value);\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int sun4v_read_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,\r\nint where, int size, u32 *value)\r\n{\r\nstruct pci_pbm_info *pbm = bus_dev->sysdata;\r\nu32 devhandle = pbm->devhandle;\r\nunsigned int bus = bus_dev->number;\r\nunsigned int device = PCI_SLOT(devfn);\r\nunsigned int func = PCI_FUNC(devfn);\r\nunsigned long ret;\r\nif (config_out_of_range(pbm, bus, devfn, where)) {\r\nret = ~0UL;\r\n} else {\r\nret = pci_sun4v_config_get(devhandle,\r\nHV_PCI_DEVICE_BUILD(bus, device, func),\r\nwhere, size);\r\n}\r\nswitch (size) {\r\ncase 1:\r\n*value = ret & 0xff;\r\nbreak;\r\ncase 2:\r\n*value = ret & 0xffff;\r\nbreak;\r\ncase 4:\r\n*value = ret & 0xffffffff;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int sun4v_write_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,\r\nint where, int size, u32 value)\r\n{\r\nstruct pci_pbm_info *pbm = bus_dev->sysdata;\r\nu32 devhandle = pbm->devhandle;\r\nunsigned int bus = bus_dev->number;\r\nunsigned int device = PCI_SLOT(devfn);\r\nunsigned int func = PCI_FUNC(devfn);\r\nif (config_out_of_range(pbm, bus, devfn, where)) {\r\n} else {\r\npci_sun4v_config_put(devhandle,\r\nHV_PCI_DEVICE_BUILD(bus, device, func),\r\nwhere, size, value);\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid pci_get_pbm_props(struct pci_pbm_info *pbm)\r\n{\r\nconst u32 *val = of_get_property(pbm->op->dev.of_node, "bus-range", NULL);\r\npbm->pci_first_busno = val[0];\r\npbm->pci_last_busno = val[1];\r\nval = of_get_property(pbm->op->dev.of_node, "ino-bitmap", NULL);\r\nif (val) {\r\npbm->ino_bitmap = (((u64)val[1] << 32UL) |\r\n((u64)val[0] << 0UL));\r\n}\r\n}\r\nstatic void pci_register_legacy_regions(struct resource *io_res,\r\nstruct resource *mem_res)\r\n{\r\nstruct resource *p;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn;\r\np->name = "Video RAM area";\r\np->start = mem_res->start + 0xa0000UL;\r\np->end = p->start + 0x1ffffUL;\r\np->flags = IORESOURCE_BUSY;\r\nrequest_resource(mem_res, p);\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn;\r\np->name = "System ROM";\r\np->start = mem_res->start + 0xf0000UL;\r\np->end = p->start + 0xffffUL;\r\np->flags = IORESOURCE_BUSY;\r\nrequest_resource(mem_res, p);\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn;\r\np->name = "Video ROM";\r\np->start = mem_res->start + 0xc0000UL;\r\np->end = p->start + 0x7fffUL;\r\np->flags = IORESOURCE_BUSY;\r\nrequest_resource(mem_res, p);\r\n}\r\nstatic void pci_register_iommu_region(struct pci_pbm_info *pbm)\r\n{\r\nconst u32 *vdma = of_get_property(pbm->op->dev.of_node, "virtual-dma",\r\nNULL);\r\nif (vdma) {\r\nstruct resource *rp = kzalloc(sizeof(*rp), GFP_KERNEL);\r\nif (!rp) {\r\npr_info("%s: Cannot allocate IOMMU resource.\n",\r\npbm->name);\r\nreturn;\r\n}\r\nrp->name = "IOMMU";\r\nrp->start = pbm->mem_space.start + (unsigned long) vdma[0];\r\nrp->end = rp->start + (unsigned long) vdma[1] - 1UL;\r\nrp->flags = IORESOURCE_BUSY;\r\nif (request_resource(&pbm->mem_space, rp)) {\r\npr_info("%s: Unable to request IOMMU resource.\n",\r\npbm->name);\r\nkfree(rp);\r\n}\r\n}\r\n}\r\nvoid pci_determine_mem_io_space(struct pci_pbm_info *pbm)\r\n{\r\nconst struct linux_prom_pci_ranges *pbm_ranges;\r\nint i, saw_mem, saw_io;\r\nint num_pbm_ranges;\r\nsaw_mem = saw_io = 0;\r\npbm_ranges = of_get_property(pbm->op->dev.of_node, "ranges", &i);\r\nif (!pbm_ranges) {\r\nprom_printf("PCI: Fatal error, missing PBM ranges property "\r\n" for %s\n",\r\npbm->name);\r\nprom_halt();\r\n}\r\nnum_pbm_ranges = i / sizeof(*pbm_ranges);\r\nmemset(&pbm->mem64_space, 0, sizeof(struct resource));\r\nfor (i = 0; i < num_pbm_ranges; i++) {\r\nconst struct linux_prom_pci_ranges *pr = &pbm_ranges[i];\r\nunsigned long a, size;\r\nu32 parent_phys_hi, parent_phys_lo;\r\nu32 size_hi, size_lo;\r\nint type;\r\nparent_phys_hi = pr->parent_phys_hi;\r\nparent_phys_lo = pr->parent_phys_lo;\r\nif (tlb_type == hypervisor)\r\nparent_phys_hi &= 0x0fffffff;\r\nsize_hi = pr->size_hi;\r\nsize_lo = pr->size_lo;\r\ntype = (pr->child_phys_hi >> 24) & 0x3;\r\na = (((unsigned long)parent_phys_hi << 32UL) |\r\n((unsigned long)parent_phys_lo << 0UL));\r\nsize = (((unsigned long)size_hi << 32UL) |\r\n((unsigned long)size_lo << 0UL));\r\nswitch (type) {\r\ncase 0:\r\npbm->config_space = a;\r\nbreak;\r\ncase 1:\r\npbm->io_space.start = a;\r\npbm->io_space.end = a + size - 1UL;\r\npbm->io_space.flags = IORESOURCE_IO;\r\nsaw_io = 1;\r\nbreak;\r\ncase 2:\r\npbm->mem_space.start = a;\r\npbm->mem_space.end = a + size - 1UL;\r\npbm->mem_space.flags = IORESOURCE_MEM;\r\nsaw_mem = 1;\r\nbreak;\r\ncase 3:\r\npbm->mem64_space.start = a;\r\npbm->mem64_space.end = a + size - 1UL;\r\npbm->mem64_space.flags = IORESOURCE_MEM;\r\nsaw_mem = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (!saw_io || !saw_mem) {\r\nprom_printf("%s: Fatal error, missing %s PBM range.\n",\r\npbm->name,\r\n(!saw_io ? "IO" : "MEM"));\r\nprom_halt();\r\n}\r\nprintk("%s: PCI IO[%llx] MEM[%llx]",\r\npbm->name,\r\npbm->io_space.start,\r\npbm->mem_space.start);\r\nif (pbm->mem64_space.flags)\r\nprintk(" MEM64[%llx]",\r\npbm->mem64_space.start);\r\nprintk("\n");\r\npbm->io_space.name = pbm->mem_space.name = pbm->name;\r\npbm->mem64_space.name = pbm->name;\r\nrequest_resource(&ioport_resource, &pbm->io_space);\r\nrequest_resource(&iomem_resource, &pbm->mem_space);\r\nif (pbm->mem64_space.flags)\r\nrequest_resource(&iomem_resource, &pbm->mem64_space);\r\npci_register_legacy_regions(&pbm->io_space,\r\n&pbm->mem_space);\r\npci_register_iommu_region(pbm);\r\n}\r\nvoid pci_scan_for_target_abort(struct pci_pbm_info *pbm,\r\nstruct pci_bus *pbus)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct pci_bus *bus;\r\nlist_for_each_entry(pdev, &pbus->devices, bus_list) {\r\nu16 status, error_bits;\r\npci_read_config_word(pdev, PCI_STATUS, &status);\r\nerror_bits =\r\n(status & (PCI_STATUS_SIG_TARGET_ABORT |\r\nPCI_STATUS_REC_TARGET_ABORT));\r\nif (error_bits) {\r\npci_write_config_word(pdev, PCI_STATUS, error_bits);\r\nprintk("%s: Device %s saw Target Abort [%016x]\n",\r\npbm->name, pci_name(pdev), status);\r\n}\r\n}\r\nlist_for_each_entry(bus, &pbus->children, node)\r\npci_scan_for_target_abort(pbm, bus);\r\n}\r\nvoid pci_scan_for_master_abort(struct pci_pbm_info *pbm,\r\nstruct pci_bus *pbus)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct pci_bus *bus;\r\nlist_for_each_entry(pdev, &pbus->devices, bus_list) {\r\nu16 status, error_bits;\r\npci_read_config_word(pdev, PCI_STATUS, &status);\r\nerror_bits =\r\n(status & (PCI_STATUS_REC_MASTER_ABORT));\r\nif (error_bits) {\r\npci_write_config_word(pdev, PCI_STATUS, error_bits);\r\nprintk("%s: Device %s received Master Abort [%016x]\n",\r\npbm->name, pci_name(pdev), status);\r\n}\r\n}\r\nlist_for_each_entry(bus, &pbus->children, node)\r\npci_scan_for_master_abort(pbm, bus);\r\n}\r\nvoid pci_scan_for_parity_error(struct pci_pbm_info *pbm,\r\nstruct pci_bus *pbus)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct pci_bus *bus;\r\nlist_for_each_entry(pdev, &pbus->devices, bus_list) {\r\nu16 status, error_bits;\r\npci_read_config_word(pdev, PCI_STATUS, &status);\r\nerror_bits =\r\n(status & (PCI_STATUS_PARITY |\r\nPCI_STATUS_DETECTED_PARITY));\r\nif (error_bits) {\r\npci_write_config_word(pdev, PCI_STATUS, error_bits);\r\nprintk("%s: Device %s saw Parity Error [%016x]\n",\r\npbm->name, pci_name(pdev), status);\r\n}\r\n}\r\nlist_for_each_entry(bus, &pbus->children, node)\r\npci_scan_for_parity_error(pbm, bus);\r\n}
