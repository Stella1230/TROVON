static inline u8\r\nbyte(const u32 x, const unsigned n)\r\n{\r\nreturn x >> (n << 3);\r\n}\r\nstatic int seed_set_key(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct seed_ctx *ctx = crypto_tfm_ctx(tfm);\r\nu32 *keyout = ctx->keysched;\r\nconst __be32 *key = (const __be32 *)in_key;\r\nu32 i, t0, t1, x1, x2, x3, x4;\r\nx1 = be32_to_cpu(key[0]);\r\nx2 = be32_to_cpu(key[1]);\r\nx3 = be32_to_cpu(key[2]);\r\nx4 = be32_to_cpu(key[3]);\r\nfor (i = 0; i < SEED_NUM_KCONSTANTS; i++) {\r\nt0 = x1 + x3 - KC[i];\r\nt1 = x2 + KC[i] - x4;\r\n*(keyout++) = SS0[byte(t0, 0)] ^ SS1[byte(t0, 1)] ^\r\nSS2[byte(t0, 2)] ^ SS3[byte(t0, 3)];\r\n*(keyout++) = SS0[byte(t1, 0)] ^ SS1[byte(t1, 1)] ^\r\nSS2[byte(t1, 2)] ^ SS3[byte(t1, 3)];\r\nif (i % 2 == 0) {\r\nt0 = x1;\r\nx1 = (x1 >> 8) ^ (x2 << 24);\r\nx2 = (x2 >> 8) ^ (t0 << 24);\r\n} else {\r\nt0 = x3;\r\nx3 = (x3 << 8) ^ (x4 >> 24);\r\nx4 = (x4 << 8) ^ (t0 >> 24);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void seed_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\r\n{\r\nconst struct seed_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __be32 *src = (const __be32 *)in;\r\n__be32 *dst = (__be32 *)out;\r\nu32 x1, x2, x3, x4, t0, t1;\r\nconst u32 *ks = ctx->keysched;\r\nx1 = be32_to_cpu(src[0]);\r\nx2 = be32_to_cpu(src[1]);\r\nx3 = be32_to_cpu(src[2]);\r\nx4 = be32_to_cpu(src[3]);\r\nOP(x1, x2, x3, x4, 0);\r\nOP(x3, x4, x1, x2, 2);\r\nOP(x1, x2, x3, x4, 4);\r\nOP(x3, x4, x1, x2, 6);\r\nOP(x1, x2, x3, x4, 8);\r\nOP(x3, x4, x1, x2, 10);\r\nOP(x1, x2, x3, x4, 12);\r\nOP(x3, x4, x1, x2, 14);\r\nOP(x1, x2, x3, x4, 16);\r\nOP(x3, x4, x1, x2, 18);\r\nOP(x1, x2, x3, x4, 20);\r\nOP(x3, x4, x1, x2, 22);\r\nOP(x1, x2, x3, x4, 24);\r\nOP(x3, x4, x1, x2, 26);\r\nOP(x1, x2, x3, x4, 28);\r\nOP(x3, x4, x1, x2, 30);\r\ndst[0] = cpu_to_be32(x3);\r\ndst[1] = cpu_to_be32(x4);\r\ndst[2] = cpu_to_be32(x1);\r\ndst[3] = cpu_to_be32(x2);\r\n}\r\nstatic void seed_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\r\n{\r\nconst struct seed_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __be32 *src = (const __be32 *)in;\r\n__be32 *dst = (__be32 *)out;\r\nu32 x1, x2, x3, x4, t0, t1;\r\nconst u32 *ks = ctx->keysched;\r\nx1 = be32_to_cpu(src[0]);\r\nx2 = be32_to_cpu(src[1]);\r\nx3 = be32_to_cpu(src[2]);\r\nx4 = be32_to_cpu(src[3]);\r\nOP(x1, x2, x3, x4, 30);\r\nOP(x3, x4, x1, x2, 28);\r\nOP(x1, x2, x3, x4, 26);\r\nOP(x3, x4, x1, x2, 24);\r\nOP(x1, x2, x3, x4, 22);\r\nOP(x3, x4, x1, x2, 20);\r\nOP(x1, x2, x3, x4, 18);\r\nOP(x3, x4, x1, x2, 16);\r\nOP(x1, x2, x3, x4, 14);\r\nOP(x3, x4, x1, x2, 12);\r\nOP(x1, x2, x3, x4, 10);\r\nOP(x3, x4, x1, x2, 8);\r\nOP(x1, x2, x3, x4, 6);\r\nOP(x3, x4, x1, x2, 4);\r\nOP(x1, x2, x3, x4, 2);\r\nOP(x3, x4, x1, x2, 0);\r\ndst[0] = cpu_to_be32(x3);\r\ndst[1] = cpu_to_be32(x4);\r\ndst[2] = cpu_to_be32(x1);\r\ndst[3] = cpu_to_be32(x2);\r\n}\r\nstatic int __init seed_init(void)\r\n{\r\nreturn crypto_register_alg(&seed_alg);\r\n}\r\nstatic void __exit seed_fini(void)\r\n{\r\ncrypto_unregister_alg(&seed_alg);\r\n}
