static void ti_thermal_work(struct work_struct *work)\r\n{\r\nstruct ti_thermal_data *data = container_of(work,\r\nstruct ti_thermal_data, thermal_wq);\r\nthermal_zone_device_update(data->ti_thermal);\r\ndev_dbg(&data->ti_thermal->device, "updated thermal zone %s\n",\r\ndata->ti_thermal->type);\r\n}\r\nstatic inline int ti_thermal_hotspot_temperature(int t, int s, int c)\r\n{\r\nint delta = t * s / 1000 + c;\r\nif (delta < 0)\r\ndelta = 0;\r\nreturn t + delta;\r\n}\r\nstatic inline int __ti_thermal_get_temp(void *devdata, int *temp)\r\n{\r\nstruct thermal_zone_device *pcb_tz = NULL;\r\nstruct ti_thermal_data *data = devdata;\r\nstruct ti_bandgap *bgp;\r\nconst struct ti_temp_sensor *s;\r\nint ret, tmp, slope, constant;\r\nint pcb_temp;\r\nif (!data)\r\nreturn 0;\r\nbgp = data->bgp;\r\ns = &bgp->conf->sensors[data->sensor_id];\r\nret = ti_bandgap_read_temperature(bgp, data->sensor_id, &tmp);\r\nif (ret)\r\nreturn ret;\r\nslope = s->slope;\r\nconstant = s->constant;\r\npcb_tz = data->pcb_tz;\r\nif (!IS_ERR(pcb_tz)) {\r\nret = thermal_zone_get_temp(pcb_tz, &pcb_temp);\r\nif (!ret) {\r\ntmp -= pcb_temp;\r\nslope = s->slope_pcb;\r\nconstant = s->constant_pcb;\r\n} else {\r\ndev_err(bgp->dev,\r\n"Failed to read PCB state. Using defaults\n");\r\nret = 0;\r\n}\r\n}\r\n*temp = ti_thermal_hotspot_temperature(tmp, slope, constant);\r\nreturn ret;\r\n}\r\nstatic inline int ti_thermal_get_temp(struct thermal_zone_device *thermal,\r\nint *temp)\r\n{\r\nstruct ti_thermal_data *data = thermal->devdata;\r\nreturn __ti_thermal_get_temp(data, temp);\r\n}\r\nstatic int ti_thermal_bind(struct thermal_zone_device *thermal,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nstruct ti_thermal_data *data = thermal->devdata;\r\nint id;\r\nif (!data || IS_ERR(data))\r\nreturn -ENODEV;\r\nif (data->cool_dev != cdev)\r\nreturn 0;\r\nid = data->sensor_id;\r\nreturn thermal_zone_bind_cooling_device(thermal, 0, cdev,\r\nTHERMAL_NO_LIMIT,\r\nTHERMAL_NO_LIMIT,\r\nTHERMAL_WEIGHT_DEFAULT);\r\n}\r\nstatic int ti_thermal_unbind(struct thermal_zone_device *thermal,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nstruct ti_thermal_data *data = thermal->devdata;\r\nif (!data || IS_ERR(data))\r\nreturn -ENODEV;\r\nif (data->cool_dev != cdev)\r\nreturn 0;\r\nreturn thermal_zone_unbind_cooling_device(thermal, 0, cdev);\r\n}\r\nstatic int ti_thermal_get_mode(struct thermal_zone_device *thermal,\r\nenum thermal_device_mode *mode)\r\n{\r\nstruct ti_thermal_data *data = thermal->devdata;\r\nif (data)\r\n*mode = data->mode;\r\nreturn 0;\r\n}\r\nstatic int ti_thermal_set_mode(struct thermal_zone_device *thermal,\r\nenum thermal_device_mode mode)\r\n{\r\nstruct ti_thermal_data *data = thermal->devdata;\r\nstruct ti_bandgap *bgp;\r\nbgp = data->bgp;\r\nif (!data->ti_thermal) {\r\ndev_notice(&thermal->device, "thermal zone not registered\n");\r\nreturn 0;\r\n}\r\nmutex_lock(&data->ti_thermal->lock);\r\nif (mode == THERMAL_DEVICE_ENABLED)\r\ndata->ti_thermal->polling_delay = FAST_TEMP_MONITORING_RATE;\r\nelse\r\ndata->ti_thermal->polling_delay = 0;\r\nmutex_unlock(&data->ti_thermal->lock);\r\ndata->mode = mode;\r\nti_bandgap_write_update_interval(bgp, data->sensor_id,\r\ndata->ti_thermal->polling_delay);\r\nthermal_zone_device_update(data->ti_thermal);\r\ndev_dbg(&thermal->device, "thermal polling set for duration=%d msec\n",\r\ndata->ti_thermal->polling_delay);\r\nreturn 0;\r\n}\r\nstatic int ti_thermal_get_trip_type(struct thermal_zone_device *thermal,\r\nint trip, enum thermal_trip_type *type)\r\n{\r\nif (!ti_thermal_is_valid_trip(trip))\r\nreturn -EINVAL;\r\nif (trip + 1 == OMAP_TRIP_NUMBER)\r\n*type = THERMAL_TRIP_CRITICAL;\r\nelse\r\n*type = THERMAL_TRIP_PASSIVE;\r\nreturn 0;\r\n}\r\nstatic int ti_thermal_get_trip_temp(struct thermal_zone_device *thermal,\r\nint trip, int *temp)\r\n{\r\nif (!ti_thermal_is_valid_trip(trip))\r\nreturn -EINVAL;\r\n*temp = ti_thermal_get_trip_value(trip);\r\nreturn 0;\r\n}\r\nstatic int __ti_thermal_get_trend(void *p, long *trend)\r\n{\r\nstruct ti_thermal_data *data = p;\r\nstruct ti_bandgap *bgp;\r\nint id, tr, ret = 0;\r\nbgp = data->bgp;\r\nid = data->sensor_id;\r\nret = ti_bandgap_get_trend(bgp, id, &tr);\r\nif (ret)\r\nreturn ret;\r\n*trend = tr;\r\nreturn 0;\r\n}\r\nstatic int ti_thermal_get_trend(struct thermal_zone_device *thermal,\r\nint trip, enum thermal_trend *trend)\r\n{\r\nint ret;\r\nlong tr;\r\nret = __ti_thermal_get_trend(thermal->devdata, &tr);\r\nif (ret)\r\nreturn ret;\r\nif (tr > 0)\r\n*trend = THERMAL_TREND_RAISING;\r\nelse if (tr < 0)\r\n*trend = THERMAL_TREND_DROPPING;\r\nelse\r\n*trend = THERMAL_TREND_STABLE;\r\nreturn 0;\r\n}\r\nstatic int ti_thermal_get_crit_temp(struct thermal_zone_device *thermal,\r\nint *temp)\r\n{\r\nreturn ti_thermal_get_trip_temp(thermal, OMAP_TRIP_NUMBER - 1, temp);\r\n}\r\nstatic struct ti_thermal_data\r\n*ti_thermal_build_data(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct ti_thermal_data *data;\r\ndata = devm_kzalloc(bgp->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(bgp->dev, "kzalloc fail\n");\r\nreturn NULL;\r\n}\r\ndata->sensor_id = id;\r\ndata->bgp = bgp;\r\ndata->mode = THERMAL_DEVICE_ENABLED;\r\ndata->pcb_tz = thermal_zone_get_zone_by_name("pcb");\r\nINIT_WORK(&data->thermal_wq, ti_thermal_work);\r\nreturn data;\r\n}\r\nint ti_thermal_expose_sensor(struct ti_bandgap *bgp, int id,\r\nchar *domain)\r\n{\r\nstruct ti_thermal_data *data;\r\ndata = ti_bandgap_get_sensor_data(bgp, id);\r\nif (!data || IS_ERR(data))\r\ndata = ti_thermal_build_data(bgp, id);\r\nif (!data)\r\nreturn -EINVAL;\r\ndata->ti_thermal = devm_thermal_zone_of_sensor_register(bgp->dev, id,\r\ndata, &ti_of_thermal_ops);\r\nif (IS_ERR(data->ti_thermal)) {\r\ndata->ti_thermal = thermal_zone_device_register(domain,\r\nOMAP_TRIP_NUMBER, 0, data, &ti_thermal_ops,\r\nNULL, FAST_TEMP_MONITORING_RATE,\r\nFAST_TEMP_MONITORING_RATE);\r\nif (IS_ERR(data->ti_thermal)) {\r\ndev_err(bgp->dev, "thermal zone device is NULL\n");\r\nreturn PTR_ERR(data->ti_thermal);\r\n}\r\ndata->ti_thermal->polling_delay = FAST_TEMP_MONITORING_RATE;\r\ndata->our_zone = true;\r\n}\r\nti_bandgap_set_sensor_data(bgp, id, data);\r\nti_bandgap_write_update_interval(bgp, data->sensor_id,\r\ndata->ti_thermal->polling_delay);\r\nreturn 0;\r\n}\r\nint ti_thermal_remove_sensor(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct ti_thermal_data *data;\r\ndata = ti_bandgap_get_sensor_data(bgp, id);\r\nif (data && data->ti_thermal) {\r\nif (data->our_zone)\r\nthermal_zone_device_unregister(data->ti_thermal);\r\n}\r\nreturn 0;\r\n}\r\nint ti_thermal_report_sensor_temperature(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct ti_thermal_data *data;\r\ndata = ti_bandgap_get_sensor_data(bgp, id);\r\nschedule_work(&data->thermal_wq);\r\nreturn 0;\r\n}\r\nint ti_thermal_register_cpu_cooling(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct ti_thermal_data *data;\r\nstruct device_node *np = bgp->dev->of_node;\r\nif (of_find_property(np, "#thermal-sensor-cells", NULL))\r\nreturn 0;\r\ndata = ti_bandgap_get_sensor_data(bgp, id);\r\nif (!data || IS_ERR(data))\r\ndata = ti_thermal_build_data(bgp, id);\r\nif (!data)\r\nreturn -EINVAL;\r\ndata->cool_dev = cpufreq_cooling_register(cpu_present_mask);\r\nif (IS_ERR(data->cool_dev)) {\r\nint ret = PTR_ERR(data->cool_dev);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(bgp->dev,\r\n"Failed to register cpu cooling device %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nti_bandgap_set_sensor_data(bgp, id, data);\r\nreturn 0;\r\n}\r\nint ti_thermal_unregister_cpu_cooling(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct ti_thermal_data *data;\r\ndata = ti_bandgap_get_sensor_data(bgp, id);\r\nif (data)\r\ncpufreq_cooling_unregister(data->cool_dev);\r\nreturn 0;\r\n}
