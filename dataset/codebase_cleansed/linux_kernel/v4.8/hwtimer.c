acpi_status acpi_get_timer_resolution(u32 * resolution)\r\n{\r\nACPI_FUNCTION_TRACE(acpi_get_timer_resolution);\r\nif (!resolution) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif ((acpi_gbl_FADT.flags & ACPI_FADT_32BIT_TIMER) == 0) {\r\n*resolution = 24;\r\n} else {\r\n*resolution = 32;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_get_timer(u32 * ticks)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_get_timer);\r\nif (!ticks) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (!acpi_gbl_FADT.xpm_timer_block.address) {\r\nreturn_ACPI_STATUS(AE_SUPPORT);\r\n}\r\nstatus = acpi_hw_read(ticks, &acpi_gbl_FADT.xpm_timer_block);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_get_timer_duration(u32 start_ticks, u32 end_ticks, u32 * time_elapsed)\r\n{\r\nacpi_status status;\r\nu32 delta_ticks;\r\nu64 quotient;\r\nACPI_FUNCTION_TRACE(acpi_get_timer_duration);\r\nif (!time_elapsed) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (!acpi_gbl_FADT.xpm_timer_block.address) {\r\nreturn_ACPI_STATUS(AE_SUPPORT);\r\n}\r\nif (start_ticks < end_ticks) {\r\ndelta_ticks = end_ticks - start_ticks;\r\n} else if (start_ticks > end_ticks) {\r\nif ((acpi_gbl_FADT.flags & ACPI_FADT_32BIT_TIMER) == 0) {\r\ndelta_ticks =\r\n(((0x00FFFFFF - start_ticks) +\r\nend_ticks) & 0x00FFFFFF);\r\n} else {\r\ndelta_ticks = (0xFFFFFFFF - start_ticks) + end_ticks;\r\n}\r\n} else {\r\n*time_elapsed = 0;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstatus = acpi_ut_short_divide(((u64)delta_ticks) * ACPI_USEC_PER_SEC,\r\nACPI_PM_TIMER_FREQUENCY, &quotient, NULL);\r\n*time_elapsed = (u32) quotient;\r\nreturn_ACPI_STATUS(status);\r\n}
