static void fib6_walker_link(struct net *net, struct fib6_walker *w)\r\n{\r\nwrite_lock_bh(&net->ipv6.fib6_walker_lock);\r\nlist_add(&w->lh, &net->ipv6.fib6_walkers);\r\nwrite_unlock_bh(&net->ipv6.fib6_walker_lock);\r\n}\r\nstatic void fib6_walker_unlink(struct net *net, struct fib6_walker *w)\r\n{\r\nwrite_lock_bh(&net->ipv6.fib6_walker_lock);\r\nlist_del(&w->lh);\r\nwrite_unlock_bh(&net->ipv6.fib6_walker_lock);\r\n}\r\nstatic int fib6_new_sernum(struct net *net)\r\n{\r\nint new, old;\r\ndo {\r\nold = atomic_read(&net->ipv6.fib6_sernum);\r\nnew = old < INT_MAX ? old + 1 : 1;\r\n} while (atomic_cmpxchg(&net->ipv6.fib6_sernum,\r\nold, new) != old);\r\nreturn new;\r\n}\r\nstatic __be32 addr_bit_set(const void *token, int fn_bit)\r\n{\r\nconst __be32 *addr = token;\r\nreturn (__force __be32)(1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)) &\r\naddr[fn_bit >> 5];\r\n}\r\nstatic struct fib6_node *node_alloc(void)\r\n{\r\nstruct fib6_node *fn;\r\nfn = kmem_cache_zalloc(fib6_node_kmem, GFP_ATOMIC);\r\nreturn fn;\r\n}\r\nstatic void node_free(struct fib6_node *fn)\r\n{\r\nkmem_cache_free(fib6_node_kmem, fn);\r\n}\r\nstatic void rt6_rcu_free(struct rt6_info *rt)\r\n{\r\ncall_rcu(&rt->dst.rcu_head, dst_rcu_free);\r\n}\r\nstatic void rt6_free_pcpu(struct rt6_info *non_pcpu_rt)\r\n{\r\nint cpu;\r\nif (!non_pcpu_rt->rt6i_pcpu)\r\nreturn;\r\nfor_each_possible_cpu(cpu) {\r\nstruct rt6_info **ppcpu_rt;\r\nstruct rt6_info *pcpu_rt;\r\nppcpu_rt = per_cpu_ptr(non_pcpu_rt->rt6i_pcpu, cpu);\r\npcpu_rt = *ppcpu_rt;\r\nif (pcpu_rt) {\r\nrt6_rcu_free(pcpu_rt);\r\n*ppcpu_rt = NULL;\r\n}\r\n}\r\nfree_percpu(non_pcpu_rt->rt6i_pcpu);\r\nnon_pcpu_rt->rt6i_pcpu = NULL;\r\n}\r\nstatic void rt6_release(struct rt6_info *rt)\r\n{\r\nif (atomic_dec_and_test(&rt->rt6i_ref)) {\r\nrt6_free_pcpu(rt);\r\nrt6_rcu_free(rt);\r\n}\r\n}\r\nstatic void fib6_link_table(struct net *net, struct fib6_table *tb)\r\n{\r\nunsigned int h;\r\nrwlock_init(&tb->tb6_lock);\r\nh = tb->tb6_id & (FIB6_TABLE_HASHSZ - 1);\r\nhlist_add_head_rcu(&tb->tb6_hlist, &net->ipv6.fib_table_hash[h]);\r\n}\r\nstatic struct fib6_table *fib6_alloc_table(struct net *net, u32 id)\r\n{\r\nstruct fib6_table *table;\r\ntable = kzalloc(sizeof(*table), GFP_ATOMIC);\r\nif (table) {\r\ntable->tb6_id = id;\r\ntable->tb6_root.leaf = net->ipv6.ip6_null_entry;\r\ntable->tb6_root.fn_flags = RTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\r\ninet_peer_base_init(&table->tb6_peers);\r\n}\r\nreturn table;\r\n}\r\nstruct fib6_table *fib6_new_table(struct net *net, u32 id)\r\n{\r\nstruct fib6_table *tb;\r\nif (id == 0)\r\nid = RT6_TABLE_MAIN;\r\ntb = fib6_get_table(net, id);\r\nif (tb)\r\nreturn tb;\r\ntb = fib6_alloc_table(net, id);\r\nif (tb)\r\nfib6_link_table(net, tb);\r\nreturn tb;\r\n}\r\nstruct fib6_table *fib6_get_table(struct net *net, u32 id)\r\n{\r\nstruct fib6_table *tb;\r\nstruct hlist_head *head;\r\nunsigned int h;\r\nif (id == 0)\r\nid = RT6_TABLE_MAIN;\r\nh = id & (FIB6_TABLE_HASHSZ - 1);\r\nrcu_read_lock();\r\nhead = &net->ipv6.fib_table_hash[h];\r\nhlist_for_each_entry_rcu(tb, head, tb6_hlist) {\r\nif (tb->tb6_id == id) {\r\nrcu_read_unlock();\r\nreturn tb;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstatic void __net_init fib6_tables_init(struct net *net)\r\n{\r\nfib6_link_table(net, net->ipv6.fib6_main_tbl);\r\nfib6_link_table(net, net->ipv6.fib6_local_tbl);\r\n}\r\nstruct fib6_table *fib6_new_table(struct net *net, u32 id)\r\n{\r\nreturn fib6_get_table(net, id);\r\n}\r\nstruct fib6_table *fib6_get_table(struct net *net, u32 id)\r\n{\r\nreturn net->ipv6.fib6_main_tbl;\r\n}\r\nstruct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\r\nint flags, pol_lookup_t lookup)\r\n{\r\nstruct rt6_info *rt;\r\nrt = lookup(net, net->ipv6.fib6_main_tbl, fl6, flags);\r\nif (rt->rt6i_flags & RTF_REJECT &&\r\nrt->dst.error == -EAGAIN) {\r\nip6_rt_put(rt);\r\nrt = net->ipv6.ip6_null_entry;\r\ndst_hold(&rt->dst);\r\n}\r\nreturn &rt->dst;\r\n}\r\nstatic void __net_init fib6_tables_init(struct net *net)\r\n{\r\nfib6_link_table(net, net->ipv6.fib6_main_tbl);\r\n}\r\nstatic int fib6_dump_node(struct fib6_walker *w)\r\n{\r\nint res;\r\nstruct rt6_info *rt;\r\nfor (rt = w->leaf; rt; rt = rt->dst.rt6_next) {\r\nres = rt6_dump_route(rt, w->args);\r\nif (res < 0) {\r\nw->leaf = rt;\r\nreturn 1;\r\n}\r\n}\r\nw->leaf = NULL;\r\nreturn 0;\r\n}\r\nstatic void fib6_dump_end(struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(cb->skb->sk);\r\nstruct fib6_walker *w = (void *)cb->args[2];\r\nif (w) {\r\nif (cb->args[4]) {\r\ncb->args[4] = 0;\r\nfib6_walker_unlink(net, w);\r\n}\r\ncb->args[2] = 0;\r\nkfree(w);\r\n}\r\ncb->done = (void *)cb->args[3];\r\ncb->args[1] = 3;\r\n}\r\nstatic int fib6_dump_done(struct netlink_callback *cb)\r\n{\r\nfib6_dump_end(cb);\r\nreturn cb->done ? cb->done(cb) : 0;\r\n}\r\nstatic int fib6_dump_table(struct fib6_table *table, struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct fib6_walker *w;\r\nint res;\r\nw = (void *)cb->args[2];\r\nw->root = &table->tb6_root;\r\nif (cb->args[4] == 0) {\r\nw->count = 0;\r\nw->skip = 0;\r\nread_lock_bh(&table->tb6_lock);\r\nres = fib6_walk(net, w);\r\nread_unlock_bh(&table->tb6_lock);\r\nif (res > 0) {\r\ncb->args[4] = 1;\r\ncb->args[5] = w->root->fn_sernum;\r\n}\r\n} else {\r\nif (cb->args[5] != w->root->fn_sernum) {\r\ncb->args[5] = w->root->fn_sernum;\r\nw->state = FWS_INIT;\r\nw->node = w->root;\r\nw->skip = w->count;\r\n} else\r\nw->skip = 0;\r\nread_lock_bh(&table->tb6_lock);\r\nres = fib6_walk_continue(w);\r\nread_unlock_bh(&table->tb6_lock);\r\nif (res <= 0) {\r\nfib6_walker_unlink(net, w);\r\ncb->args[4] = 0;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int inet6_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nunsigned int h, s_h;\r\nunsigned int e = 0, s_e;\r\nstruct rt6_rtnl_dump_arg arg;\r\nstruct fib6_walker *w;\r\nstruct fib6_table *tb;\r\nstruct hlist_head *head;\r\nint res = 0;\r\ns_h = cb->args[0];\r\ns_e = cb->args[1];\r\nw = (void *)cb->args[2];\r\nif (!w) {\r\ncb->args[3] = (long)cb->done;\r\ncb->done = fib6_dump_done;\r\nw = kzalloc(sizeof(*w), GFP_ATOMIC);\r\nif (!w)\r\nreturn -ENOMEM;\r\nw->func = fib6_dump_node;\r\ncb->args[2] = (long)w;\r\n}\r\narg.skb = skb;\r\narg.cb = cb;\r\narg.net = net;\r\nw->args = &arg;\r\nrcu_read_lock();\r\nfor (h = s_h; h < FIB6_TABLE_HASHSZ; h++, s_e = 0) {\r\ne = 0;\r\nhead = &net->ipv6.fib_table_hash[h];\r\nhlist_for_each_entry_rcu(tb, head, tb6_hlist) {\r\nif (e < s_e)\r\ngoto next;\r\nres = fib6_dump_table(tb, skb, cb);\r\nif (res != 0)\r\ngoto out;\r\nnext:\r\ne++;\r\n}\r\n}\r\nout:\r\nrcu_read_unlock();\r\ncb->args[1] = e;\r\ncb->args[0] = h;\r\nres = res < 0 ? res : skb->len;\r\nif (res <= 0)\r\nfib6_dump_end(cb);\r\nreturn res;\r\n}\r\nstatic struct fib6_node *fib6_add_1(struct fib6_node *root,\r\nstruct in6_addr *addr, int plen,\r\nint offset, int allow_create,\r\nint replace_required, int sernum)\r\n{\r\nstruct fib6_node *fn, *in, *ln;\r\nstruct fib6_node *pn = NULL;\r\nstruct rt6key *key;\r\nint bit;\r\n__be32 dir = 0;\r\nRT6_TRACE("fib6_add_1\n");\r\nfn = root;\r\ndo {\r\nkey = (struct rt6key *)((u8 *)fn->leaf + offset);\r\nif (plen < fn->fn_bit ||\r\n!ipv6_prefix_equal(&key->addr, addr, fn->fn_bit)) {\r\nif (!allow_create) {\r\nif (replace_required) {\r\npr_warn("Can't replace route, no match found\n");\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\npr_warn("NLM_F_CREATE should be set when creating new route\n");\r\n}\r\ngoto insert_above;\r\n}\r\nif (plen == fn->fn_bit) {\r\nif (!(fn->fn_flags & RTN_RTINFO)) {\r\nrt6_release(fn->leaf);\r\nfn->leaf = NULL;\r\n}\r\nfn->fn_sernum = sernum;\r\nreturn fn;\r\n}\r\nfn->fn_sernum = sernum;\r\ndir = addr_bit_set(addr, fn->fn_bit);\r\npn = fn;\r\nfn = dir ? fn->right : fn->left;\r\n} while (fn);\r\nif (!allow_create) {\r\nif (replace_required) {\r\npr_warn("Can't replace route, no match found\n");\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\npr_warn("NLM_F_CREATE should be set when creating new route\n");\r\n}\r\nln = node_alloc();\r\nif (!ln)\r\nreturn ERR_PTR(-ENOMEM);\r\nln->fn_bit = plen;\r\nln->parent = pn;\r\nln->fn_sernum = sernum;\r\nif (dir)\r\npn->right = ln;\r\nelse\r\npn->left = ln;\r\nreturn ln;\r\ninsert_above:\r\npn = fn->parent;\r\nbit = __ipv6_addr_diff(addr, &key->addr, sizeof(*addr));\r\nif (plen > bit) {\r\nin = node_alloc();\r\nln = node_alloc();\r\nif (!in || !ln) {\r\nif (in)\r\nnode_free(in);\r\nif (ln)\r\nnode_free(ln);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nin->fn_bit = bit;\r\nin->parent = pn;\r\nin->leaf = fn->leaf;\r\natomic_inc(&in->leaf->rt6i_ref);\r\nin->fn_sernum = sernum;\r\nif (dir)\r\npn->right = in;\r\nelse\r\npn->left = in;\r\nln->fn_bit = plen;\r\nln->parent = in;\r\nfn->parent = in;\r\nln->fn_sernum = sernum;\r\nif (addr_bit_set(addr, bit)) {\r\nin->right = ln;\r\nin->left = fn;\r\n} else {\r\nin->left = ln;\r\nin->right = fn;\r\n}\r\n} else {\r\nln = node_alloc();\r\nif (!ln)\r\nreturn ERR_PTR(-ENOMEM);\r\nln->fn_bit = plen;\r\nln->parent = pn;\r\nln->fn_sernum = sernum;\r\nif (dir)\r\npn->right = ln;\r\nelse\r\npn->left = ln;\r\nif (addr_bit_set(&key->addr, plen))\r\nln->right = fn;\r\nelse\r\nln->left = fn;\r\nfn->parent = ln;\r\n}\r\nreturn ln;\r\n}\r\nstatic bool rt6_qualify_for_ecmp(struct rt6_info *rt)\r\n{\r\nreturn (rt->rt6i_flags & (RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC)) ==\r\nRTF_GATEWAY;\r\n}\r\nstatic void fib6_copy_metrics(u32 *mp, const struct mx6_config *mxc)\r\n{\r\nint i;\r\nfor (i = 0; i < RTAX_MAX; i++) {\r\nif (test_bit(i, mxc->mx_valid))\r\nmp[i] = mxc->mx[i];\r\n}\r\n}\r\nstatic int fib6_commit_metrics(struct dst_entry *dst, struct mx6_config *mxc)\r\n{\r\nif (!mxc->mx)\r\nreturn 0;\r\nif (dst->flags & DST_HOST) {\r\nu32 *mp = dst_metrics_write_ptr(dst);\r\nif (unlikely(!mp))\r\nreturn -ENOMEM;\r\nfib6_copy_metrics(mp, mxc);\r\n} else {\r\ndst_init_metrics(dst, mxc->mx, false);\r\nmxc->mx = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fib6_purge_rt(struct rt6_info *rt, struct fib6_node *fn,\r\nstruct net *net)\r\n{\r\nif (atomic_read(&rt->rt6i_ref) != 1) {\r\nwhile (fn) {\r\nif (!(fn->fn_flags & RTN_RTINFO) && fn->leaf == rt) {\r\nfn->leaf = fib6_find_prefix(net, fn);\r\natomic_inc(&fn->leaf->rt6i_ref);\r\nrt6_release(rt);\r\n}\r\nfn = fn->parent;\r\n}\r\nBUG_ON(atomic_read(&rt->rt6i_ref) != 1);\r\n}\r\n}\r\nstatic int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,\r\nstruct nl_info *info, struct mx6_config *mxc)\r\n{\r\nstruct rt6_info *iter = NULL;\r\nstruct rt6_info **ins;\r\nstruct rt6_info **fallback_ins = NULL;\r\nint replace = (info->nlh &&\r\n(info->nlh->nlmsg_flags & NLM_F_REPLACE));\r\nint add = (!info->nlh ||\r\n(info->nlh->nlmsg_flags & NLM_F_CREATE));\r\nint found = 0;\r\nbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\r\nint err;\r\nins = &fn->leaf;\r\nfor (iter = fn->leaf; iter; iter = iter->dst.rt6_next) {\r\nif (iter->rt6i_metric == rt->rt6i_metric) {\r\nif (info->nlh &&\r\n(info->nlh->nlmsg_flags & NLM_F_EXCL))\r\nreturn -EEXIST;\r\nif (replace) {\r\nif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\r\nfound++;\r\nbreak;\r\n}\r\nif (rt_can_ecmp)\r\nfallback_ins = fallback_ins ?: ins;\r\ngoto next_iter;\r\n}\r\nif (iter->dst.dev == rt->dst.dev &&\r\niter->rt6i_idev == rt->rt6i_idev &&\r\nipv6_addr_equal(&iter->rt6i_gateway,\r\n&rt->rt6i_gateway)) {\r\nif (rt->rt6i_nsiblings)\r\nrt->rt6i_nsiblings = 0;\r\nif (!(iter->rt6i_flags & RTF_EXPIRES))\r\nreturn -EEXIST;\r\nif (!(rt->rt6i_flags & RTF_EXPIRES))\r\nrt6_clean_expires(iter);\r\nelse\r\nrt6_set_expires(iter, rt->dst.expires);\r\niter->rt6i_pmtu = rt->rt6i_pmtu;\r\nreturn -EEXIST;\r\n}\r\nif (rt_can_ecmp &&\r\nrt6_qualify_for_ecmp(iter))\r\nrt->rt6i_nsiblings++;\r\n}\r\nif (iter->rt6i_metric > rt->rt6i_metric)\r\nbreak;\r\nnext_iter:\r\nins = &iter->dst.rt6_next;\r\n}\r\nif (fallback_ins && !found) {\r\nins = fallback_ins;\r\niter = *ins;\r\nfound++;\r\n}\r\nif (ins == &fn->leaf)\r\nfn->rr_ptr = NULL;\r\nif (rt->rt6i_nsiblings) {\r\nunsigned int rt6i_nsiblings;\r\nstruct rt6_info *sibling, *temp_sibling;\r\nsibling = fn->leaf;\r\nwhile (sibling) {\r\nif (sibling->rt6i_metric == rt->rt6i_metric &&\r\nrt6_qualify_for_ecmp(sibling)) {\r\nlist_add_tail(&rt->rt6i_siblings,\r\n&sibling->rt6i_siblings);\r\nbreak;\r\n}\r\nsibling = sibling->dst.rt6_next;\r\n}\r\nrt6i_nsiblings = 0;\r\nlist_for_each_entry_safe(sibling, temp_sibling,\r\n&rt->rt6i_siblings, rt6i_siblings) {\r\nsibling->rt6i_nsiblings++;\r\nBUG_ON(sibling->rt6i_nsiblings != rt->rt6i_nsiblings);\r\nrt6i_nsiblings++;\r\n}\r\nBUG_ON(rt6i_nsiblings != rt->rt6i_nsiblings);\r\n}\r\nif (!replace) {\r\nif (!add)\r\npr_warn("NLM_F_CREATE should be set when creating new route\n");\r\nadd:\r\nerr = fib6_commit_metrics(&rt->dst, mxc);\r\nif (err)\r\nreturn err;\r\nrt->dst.rt6_next = iter;\r\n*ins = rt;\r\nrt->rt6i_node = fn;\r\natomic_inc(&rt->rt6i_ref);\r\ninet6_rt_notify(RTM_NEWROUTE, rt, info, 0);\r\ninfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\r\nif (!(fn->fn_flags & RTN_RTINFO)) {\r\ninfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\r\nfn->fn_flags |= RTN_RTINFO;\r\n}\r\n} else {\r\nint nsiblings;\r\nif (!found) {\r\nif (add)\r\ngoto add;\r\npr_warn("NLM_F_REPLACE set, but no existing node found!\n");\r\nreturn -ENOENT;\r\n}\r\nerr = fib6_commit_metrics(&rt->dst, mxc);\r\nif (err)\r\nreturn err;\r\n*ins = rt;\r\nrt->rt6i_node = fn;\r\nrt->dst.rt6_next = iter->dst.rt6_next;\r\natomic_inc(&rt->rt6i_ref);\r\ninet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\r\nif (!(fn->fn_flags & RTN_RTINFO)) {\r\ninfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\r\nfn->fn_flags |= RTN_RTINFO;\r\n}\r\nnsiblings = iter->rt6i_nsiblings;\r\nfib6_purge_rt(iter, fn, info->nl_net);\r\nrt6_release(iter);\r\nif (nsiblings) {\r\nins = &rt->dst.rt6_next;\r\niter = *ins;\r\nwhile (iter) {\r\nif (rt6_qualify_for_ecmp(iter)) {\r\n*ins = iter->dst.rt6_next;\r\nfib6_purge_rt(iter, fn, info->nl_net);\r\nrt6_release(iter);\r\nnsiblings--;\r\n} else {\r\nins = &iter->dst.rt6_next;\r\n}\r\niter = *ins;\r\n}\r\nWARN_ON(nsiblings != 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void fib6_start_gc(struct net *net, struct rt6_info *rt)\r\n{\r\nif (!timer_pending(&net->ipv6.ip6_fib_timer) &&\r\n(rt->rt6i_flags & (RTF_EXPIRES | RTF_CACHE)))\r\nmod_timer(&net->ipv6.ip6_fib_timer,\r\njiffies + net->ipv6.sysctl.ip6_rt_gc_interval);\r\n}\r\nvoid fib6_force_start_gc(struct net *net)\r\n{\r\nif (!timer_pending(&net->ipv6.ip6_fib_timer))\r\nmod_timer(&net->ipv6.ip6_fib_timer,\r\njiffies + net->ipv6.sysctl.ip6_rt_gc_interval);\r\n}\r\nint fib6_add(struct fib6_node *root, struct rt6_info *rt,\r\nstruct nl_info *info, struct mx6_config *mxc)\r\n{\r\nstruct fib6_node *fn, *pn = NULL;\r\nint err = -ENOMEM;\r\nint allow_create = 1;\r\nint replace_required = 0;\r\nint sernum = fib6_new_sernum(info->nl_net);\r\nif (WARN_ON_ONCE((rt->dst.flags & DST_NOCACHE) &&\r\n!atomic_read(&rt->dst.__refcnt)))\r\nreturn -EINVAL;\r\nif (info->nlh) {\r\nif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\r\nallow_create = 0;\r\nif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\r\nreplace_required = 1;\r\n}\r\nif (!allow_create && !replace_required)\r\npr_warn("RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n");\r\nfn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,\r\noffsetof(struct rt6_info, rt6i_dst), allow_create,\r\nreplace_required, sernum);\r\nif (IS_ERR(fn)) {\r\nerr = PTR_ERR(fn);\r\nfn = NULL;\r\ngoto out;\r\n}\r\npn = fn;\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nif (rt->rt6i_src.plen) {\r\nstruct fib6_node *sn;\r\nif (!fn->subtree) {\r\nstruct fib6_node *sfn;\r\nsfn = node_alloc();\r\nif (!sfn)\r\ngoto st_failure;\r\nsfn->leaf = info->nl_net->ipv6.ip6_null_entry;\r\natomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);\r\nsfn->fn_flags = RTN_ROOT;\r\nsfn->fn_sernum = sernum;\r\nsn = fib6_add_1(sfn, &rt->rt6i_src.addr,\r\nrt->rt6i_src.plen,\r\noffsetof(struct rt6_info, rt6i_src),\r\nallow_create, replace_required, sernum);\r\nif (IS_ERR(sn)) {\r\nnode_free(sfn);\r\nerr = PTR_ERR(sn);\r\ngoto st_failure;\r\n}\r\nsfn->parent = fn;\r\nfn->subtree = sfn;\r\n} else {\r\nsn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,\r\nrt->rt6i_src.plen,\r\noffsetof(struct rt6_info, rt6i_src),\r\nallow_create, replace_required, sernum);\r\nif (IS_ERR(sn)) {\r\nerr = PTR_ERR(sn);\r\ngoto st_failure;\r\n}\r\n}\r\nif (!fn->leaf) {\r\nfn->leaf = rt;\r\natomic_inc(&rt->rt6i_ref);\r\n}\r\nfn = sn;\r\n}\r\n#endif\r\nerr = fib6_add_rt2node(fn, rt, info, mxc);\r\nif (!err) {\r\nfib6_start_gc(info->nl_net, rt);\r\nif (!(rt->rt6i_flags & RTF_CACHE))\r\nfib6_prune_clones(info->nl_net, pn);\r\nrt->dst.flags &= ~DST_NOCACHE;\r\n}\r\nout:\r\nif (err) {\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nif (pn != fn && pn->leaf == rt) {\r\npn->leaf = NULL;\r\natomic_dec(&rt->rt6i_ref);\r\n}\r\nif (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {\r\npn->leaf = fib6_find_prefix(info->nl_net, pn);\r\n#if RT6_DEBUG >= 2\r\nif (!pn->leaf) {\r\nWARN_ON(pn->leaf == NULL);\r\npn->leaf = info->nl_net->ipv6.ip6_null_entry;\r\n}\r\n#endif\r\natomic_inc(&pn->leaf->rt6i_ref);\r\n}\r\n#endif\r\nif (!(rt->dst.flags & DST_NOCACHE))\r\ndst_free(&rt->dst);\r\n}\r\nreturn err;\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nst_failure:\r\nif (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))\r\nfib6_repair_tree(info->nl_net, fn);\r\nif (!(rt->dst.flags & DST_NOCACHE))\r\ndst_free(&rt->dst);\r\nreturn err;\r\n#endif\r\n}\r\nstatic struct fib6_node *fib6_lookup_1(struct fib6_node *root,\r\nstruct lookup_args *args)\r\n{\r\nstruct fib6_node *fn;\r\n__be32 dir;\r\nif (unlikely(args->offset == 0))\r\nreturn NULL;\r\nfn = root;\r\nfor (;;) {\r\nstruct fib6_node *next;\r\ndir = addr_bit_set(args->addr, fn->fn_bit);\r\nnext = dir ? fn->right : fn->left;\r\nif (next) {\r\nfn = next;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nwhile (fn) {\r\nif (FIB6_SUBTREE(fn) || fn->fn_flags & RTN_RTINFO) {\r\nstruct rt6key *key;\r\nkey = (struct rt6key *) ((u8 *) fn->leaf +\r\nargs->offset);\r\nif (ipv6_prefix_equal(&key->addr, args->addr, key->plen)) {\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nif (fn->subtree) {\r\nstruct fib6_node *sfn;\r\nsfn = fib6_lookup_1(fn->subtree,\r\nargs + 1);\r\nif (!sfn)\r\ngoto backtrack;\r\nfn = sfn;\r\n}\r\n#endif\r\nif (fn->fn_flags & RTN_RTINFO)\r\nreturn fn;\r\n}\r\n}\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nbacktrack:\r\n#endif\r\nif (fn->fn_flags & RTN_ROOT)\r\nbreak;\r\nfn = fn->parent;\r\n}\r\nreturn NULL;\r\n}\r\nstruct fib6_node *fib6_lookup(struct fib6_node *root, const struct in6_addr *daddr,\r\nconst struct in6_addr *saddr)\r\n{\r\nstruct fib6_node *fn;\r\nstruct lookup_args args[] = {\r\n{\r\n.offset = offsetof(struct rt6_info, rt6i_dst),\r\n.addr = daddr,\r\n},\r\n#ifdef CONFIG_IPV6_SUBTREES\r\n{\r\n.offset = offsetof(struct rt6_info, rt6i_src),\r\n.addr = saddr,\r\n},\r\n#endif\r\n{\r\n.offset = 0,\r\n}\r\n};\r\nfn = fib6_lookup_1(root, daddr ? args : args + 1);\r\nif (!fn || fn->fn_flags & RTN_TL_ROOT)\r\nfn = root;\r\nreturn fn;\r\n}\r\nstatic struct fib6_node *fib6_locate_1(struct fib6_node *root,\r\nconst struct in6_addr *addr,\r\nint plen, int offset)\r\n{\r\nstruct fib6_node *fn;\r\nfor (fn = root; fn ; ) {\r\nstruct rt6key *key = (struct rt6key *)((u8 *)fn->leaf + offset);\r\nif (plen < fn->fn_bit ||\r\n!ipv6_prefix_equal(&key->addr, addr, fn->fn_bit))\r\nreturn NULL;\r\nif (plen == fn->fn_bit)\r\nreturn fn;\r\nif (addr_bit_set(addr, fn->fn_bit))\r\nfn = fn->right;\r\nelse\r\nfn = fn->left;\r\n}\r\nreturn NULL;\r\n}\r\nstruct fib6_node *fib6_locate(struct fib6_node *root,\r\nconst struct in6_addr *daddr, int dst_len,\r\nconst struct in6_addr *saddr, int src_len)\r\n{\r\nstruct fib6_node *fn;\r\nfn = fib6_locate_1(root, daddr, dst_len,\r\noffsetof(struct rt6_info, rt6i_dst));\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nif (src_len) {\r\nWARN_ON(saddr == NULL);\r\nif (fn && fn->subtree)\r\nfn = fib6_locate_1(fn->subtree, saddr, src_len,\r\noffsetof(struct rt6_info, rt6i_src));\r\n}\r\n#endif\r\nif (fn && fn->fn_flags & RTN_RTINFO)\r\nreturn fn;\r\nreturn NULL;\r\n}\r\nstatic struct rt6_info *fib6_find_prefix(struct net *net, struct fib6_node *fn)\r\n{\r\nif (fn->fn_flags & RTN_ROOT)\r\nreturn net->ipv6.ip6_null_entry;\r\nwhile (fn) {\r\nif (fn->left)\r\nreturn fn->left->leaf;\r\nif (fn->right)\r\nreturn fn->right->leaf;\r\nfn = FIB6_SUBTREE(fn);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct fib6_node *fib6_repair_tree(struct net *net,\r\nstruct fib6_node *fn)\r\n{\r\nint children;\r\nint nstate;\r\nstruct fib6_node *child, *pn;\r\nstruct fib6_walker *w;\r\nint iter = 0;\r\nfor (;;) {\r\nRT6_TRACE("fixing tree: plen=%d iter=%d\n", fn->fn_bit, iter);\r\niter++;\r\nWARN_ON(fn->fn_flags & RTN_RTINFO);\r\nWARN_ON(fn->fn_flags & RTN_TL_ROOT);\r\nWARN_ON(fn->leaf);\r\nchildren = 0;\r\nchild = NULL;\r\nif (fn->right)\r\nchild = fn->right, children |= 1;\r\nif (fn->left)\r\nchild = fn->left, children |= 2;\r\nif (children == 3 || FIB6_SUBTREE(fn)\r\n#ifdef CONFIG_IPV6_SUBTREES\r\n|| (children && fn->fn_flags & RTN_ROOT)\r\n#endif\r\n) {\r\nfn->leaf = fib6_find_prefix(net, fn);\r\n#if RT6_DEBUG >= 2\r\nif (!fn->leaf) {\r\nWARN_ON(!fn->leaf);\r\nfn->leaf = net->ipv6.ip6_null_entry;\r\n}\r\n#endif\r\natomic_inc(&fn->leaf->rt6i_ref);\r\nreturn fn->parent;\r\n}\r\npn = fn->parent;\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nif (FIB6_SUBTREE(pn) == fn) {\r\nWARN_ON(!(fn->fn_flags & RTN_ROOT));\r\nFIB6_SUBTREE(pn) = NULL;\r\nnstate = FWS_L;\r\n} else {\r\nWARN_ON(fn->fn_flags & RTN_ROOT);\r\n#endif\r\nif (pn->right == fn)\r\npn->right = child;\r\nelse if (pn->left == fn)\r\npn->left = child;\r\n#if RT6_DEBUG >= 2\r\nelse\r\nWARN_ON(1);\r\n#endif\r\nif (child)\r\nchild->parent = pn;\r\nnstate = FWS_R;\r\n#ifdef CONFIG_IPV6_SUBTREES\r\n}\r\n#endif\r\nread_lock(&net->ipv6.fib6_walker_lock);\r\nFOR_WALKERS(net, w) {\r\nif (!child) {\r\nif (w->root == fn) {\r\nw->root = w->node = NULL;\r\nRT6_TRACE("W %p adjusted by delroot 1\n", w);\r\n} else if (w->node == fn) {\r\nRT6_TRACE("W %p adjusted by delnode 1, s=%d/%d\n", w, w->state, nstate);\r\nw->node = pn;\r\nw->state = nstate;\r\n}\r\n} else {\r\nif (w->root == fn) {\r\nw->root = child;\r\nRT6_TRACE("W %p adjusted by delroot 2\n", w);\r\n}\r\nif (w->node == fn) {\r\nw->node = child;\r\nif (children&2) {\r\nRT6_TRACE("W %p adjusted by delnode 2, s=%d\n", w, w->state);\r\nw->state = w->state >= FWS_R ? FWS_U : FWS_INIT;\r\n} else {\r\nRT6_TRACE("W %p adjusted by delnode 2, s=%d\n", w, w->state);\r\nw->state = w->state >= FWS_C ? FWS_U : FWS_INIT;\r\n}\r\n}\r\n}\r\n}\r\nread_unlock(&net->ipv6.fib6_walker_lock);\r\nnode_free(fn);\r\nif (pn->fn_flags & RTN_RTINFO || FIB6_SUBTREE(pn))\r\nreturn pn;\r\nrt6_release(pn->leaf);\r\npn->leaf = NULL;\r\nfn = pn;\r\n}\r\n}\r\nstatic void fib6_del_route(struct fib6_node *fn, struct rt6_info **rtp,\r\nstruct nl_info *info)\r\n{\r\nstruct fib6_walker *w;\r\nstruct rt6_info *rt = *rtp;\r\nstruct net *net = info->nl_net;\r\nRT6_TRACE("fib6_del_route\n");\r\n*rtp = rt->dst.rt6_next;\r\nrt->rt6i_node = NULL;\r\nnet->ipv6.rt6_stats->fib_rt_entries--;\r\nnet->ipv6.rt6_stats->fib_discarded_routes++;\r\nif (fn->rr_ptr == rt)\r\nfn->rr_ptr = NULL;\r\nif (rt->rt6i_nsiblings) {\r\nstruct rt6_info *sibling, *next_sibling;\r\nlist_for_each_entry_safe(sibling, next_sibling,\r\n&rt->rt6i_siblings, rt6i_siblings)\r\nsibling->rt6i_nsiblings--;\r\nrt->rt6i_nsiblings = 0;\r\nlist_del_init(&rt->rt6i_siblings);\r\n}\r\nread_lock(&net->ipv6.fib6_walker_lock);\r\nFOR_WALKERS(net, w) {\r\nif (w->state == FWS_C && w->leaf == rt) {\r\nRT6_TRACE("walker %p adjusted by delroute\n", w);\r\nw->leaf = rt->dst.rt6_next;\r\nif (!w->leaf)\r\nw->state = FWS_U;\r\n}\r\n}\r\nread_unlock(&net->ipv6.fib6_walker_lock);\r\nrt->dst.rt6_next = NULL;\r\nif (!fn->leaf) {\r\nfn->fn_flags &= ~RTN_RTINFO;\r\nnet->ipv6.rt6_stats->fib_route_nodes--;\r\nfn = fib6_repair_tree(net, fn);\r\n}\r\nfib6_purge_rt(rt, fn, net);\r\ninet6_rt_notify(RTM_DELROUTE, rt, info, 0);\r\nrt6_release(rt);\r\n}\r\nint fib6_del(struct rt6_info *rt, struct nl_info *info)\r\n{\r\nstruct net *net = info->nl_net;\r\nstruct fib6_node *fn = rt->rt6i_node;\r\nstruct rt6_info **rtp;\r\n#if RT6_DEBUG >= 2\r\nif (rt->dst.obsolete > 0) {\r\nWARN_ON(fn);\r\nreturn -ENOENT;\r\n}\r\n#endif\r\nif (!fn || rt == net->ipv6.ip6_null_entry)\r\nreturn -ENOENT;\r\nWARN_ON(!(fn->fn_flags & RTN_RTINFO));\r\nif (!(rt->rt6i_flags & RTF_CACHE)) {\r\nstruct fib6_node *pn = fn;\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nif (rt->rt6i_src.plen) {\r\nwhile (!(pn->fn_flags & RTN_ROOT))\r\npn = pn->parent;\r\npn = pn->parent;\r\n}\r\n#endif\r\nfib6_prune_clones(info->nl_net, pn);\r\n}\r\nfor (rtp = &fn->leaf; *rtp; rtp = &(*rtp)->dst.rt6_next) {\r\nif (*rtp == rt) {\r\nfib6_del_route(fn, rtp, info);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int fib6_walk_continue(struct fib6_walker *w)\r\n{\r\nstruct fib6_node *fn, *pn;\r\nfor (;;) {\r\nfn = w->node;\r\nif (!fn)\r\nreturn 0;\r\nif (w->prune && fn != w->root &&\r\nfn->fn_flags & RTN_RTINFO && w->state < FWS_C) {\r\nw->state = FWS_C;\r\nw->leaf = fn->leaf;\r\n}\r\nswitch (w->state) {\r\n#ifdef CONFIG_IPV6_SUBTREES\r\ncase FWS_S:\r\nif (FIB6_SUBTREE(fn)) {\r\nw->node = FIB6_SUBTREE(fn);\r\ncontinue;\r\n}\r\nw->state = FWS_L;\r\n#endif\r\ncase FWS_L:\r\nif (fn->left) {\r\nw->node = fn->left;\r\nw->state = FWS_INIT;\r\ncontinue;\r\n}\r\nw->state = FWS_R;\r\ncase FWS_R:\r\nif (fn->right) {\r\nw->node = fn->right;\r\nw->state = FWS_INIT;\r\ncontinue;\r\n}\r\nw->state = FWS_C;\r\nw->leaf = fn->leaf;\r\ncase FWS_C:\r\nif (w->leaf && fn->fn_flags & RTN_RTINFO) {\r\nint err;\r\nif (w->skip) {\r\nw->skip--;\r\ngoto skip;\r\n}\r\nerr = w->func(w);\r\nif (err)\r\nreturn err;\r\nw->count++;\r\ncontinue;\r\n}\r\nskip:\r\nw->state = FWS_U;\r\ncase FWS_U:\r\nif (fn == w->root)\r\nreturn 0;\r\npn = fn->parent;\r\nw->node = pn;\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nif (FIB6_SUBTREE(pn) == fn) {\r\nWARN_ON(!(fn->fn_flags & RTN_ROOT));\r\nw->state = FWS_L;\r\ncontinue;\r\n}\r\n#endif\r\nif (pn->left == fn) {\r\nw->state = FWS_R;\r\ncontinue;\r\n}\r\nif (pn->right == fn) {\r\nw->state = FWS_C;\r\nw->leaf = w->node->leaf;\r\ncontinue;\r\n}\r\n#if RT6_DEBUG >= 2\r\nWARN_ON(1);\r\n#endif\r\n}\r\n}\r\n}\r\nstatic int fib6_walk(struct net *net, struct fib6_walker *w)\r\n{\r\nint res;\r\nw->state = FWS_INIT;\r\nw->node = w->root;\r\nfib6_walker_link(net, w);\r\nres = fib6_walk_continue(w);\r\nif (res <= 0)\r\nfib6_walker_unlink(net, w);\r\nreturn res;\r\n}\r\nstatic int fib6_clean_node(struct fib6_walker *w)\r\n{\r\nint res;\r\nstruct rt6_info *rt;\r\nstruct fib6_cleaner *c = container_of(w, struct fib6_cleaner, w);\r\nstruct nl_info info = {\r\n.nl_net = c->net,\r\n};\r\nif (c->sernum != FIB6_NO_SERNUM_CHANGE &&\r\nw->node->fn_sernum != c->sernum)\r\nw->node->fn_sernum = c->sernum;\r\nif (!c->func) {\r\nWARN_ON_ONCE(c->sernum == FIB6_NO_SERNUM_CHANGE);\r\nw->leaf = NULL;\r\nreturn 0;\r\n}\r\nfor (rt = w->leaf; rt; rt = rt->dst.rt6_next) {\r\nres = c->func(rt, c->arg);\r\nif (res < 0) {\r\nw->leaf = rt;\r\nres = fib6_del(rt, &info);\r\nif (res) {\r\n#if RT6_DEBUG >= 2\r\npr_debug("%s: del failed: rt=%p@%p err=%d\n",\r\n__func__, rt, rt->rt6i_node, res);\r\n#endif\r\ncontinue;\r\n}\r\nreturn 0;\r\n}\r\nWARN_ON(res != 0);\r\n}\r\nw->leaf = rt;\r\nreturn 0;\r\n}\r\nstatic void fib6_clean_tree(struct net *net, struct fib6_node *root,\r\nint (*func)(struct rt6_info *, void *arg),\r\nbool prune, int sernum, void *arg)\r\n{\r\nstruct fib6_cleaner c;\r\nc.w.root = root;\r\nc.w.func = fib6_clean_node;\r\nc.w.prune = prune;\r\nc.w.count = 0;\r\nc.w.skip = 0;\r\nc.func = func;\r\nc.sernum = sernum;\r\nc.arg = arg;\r\nc.net = net;\r\nfib6_walk(net, &c.w);\r\n}\r\nstatic void __fib6_clean_all(struct net *net,\r\nint (*func)(struct rt6_info *, void *),\r\nint sernum, void *arg)\r\n{\r\nstruct fib6_table *table;\r\nstruct hlist_head *head;\r\nunsigned int h;\r\nrcu_read_lock();\r\nfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\r\nhead = &net->ipv6.fib_table_hash[h];\r\nhlist_for_each_entry_rcu(table, head, tb6_hlist) {\r\nwrite_lock_bh(&table->tb6_lock);\r\nfib6_clean_tree(net, &table->tb6_root,\r\nfunc, false, sernum, arg);\r\nwrite_unlock_bh(&table->tb6_lock);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid fib6_clean_all(struct net *net, int (*func)(struct rt6_info *, void *),\r\nvoid *arg)\r\n{\r\n__fib6_clean_all(net, func, FIB6_NO_SERNUM_CHANGE, arg);\r\n}\r\nstatic int fib6_prune_clone(struct rt6_info *rt, void *arg)\r\n{\r\nif (rt->rt6i_flags & RTF_CACHE) {\r\nRT6_TRACE("pruning clone %p\n", rt);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fib6_prune_clones(struct net *net, struct fib6_node *fn)\r\n{\r\nfib6_clean_tree(net, fn, fib6_prune_clone, true,\r\nFIB6_NO_SERNUM_CHANGE, NULL);\r\n}\r\nstatic void fib6_flush_trees(struct net *net)\r\n{\r\nint new_sernum = fib6_new_sernum(net);\r\n__fib6_clean_all(net, NULL, new_sernum, NULL);\r\n}\r\nstatic int fib6_age(struct rt6_info *rt, void *arg)\r\n{\r\nstruct fib6_gc_args *gc_args = arg;\r\nunsigned long now = jiffies;\r\nif (rt->rt6i_flags & RTF_EXPIRES && rt->dst.expires) {\r\nif (time_after(now, rt->dst.expires)) {\r\nRT6_TRACE("expiring %p\n", rt);\r\nreturn -1;\r\n}\r\ngc_args->more++;\r\n} else if (rt->rt6i_flags & RTF_CACHE) {\r\nif (atomic_read(&rt->dst.__refcnt) == 0 &&\r\ntime_after_eq(now, rt->dst.lastuse + gc_args->timeout)) {\r\nRT6_TRACE("aging clone %p\n", rt);\r\nreturn -1;\r\n} else if (rt->rt6i_flags & RTF_GATEWAY) {\r\nstruct neighbour *neigh;\r\n__u8 neigh_flags = 0;\r\nneigh = dst_neigh_lookup(&rt->dst, &rt->rt6i_gateway);\r\nif (neigh) {\r\nneigh_flags = neigh->flags;\r\nneigh_release(neigh);\r\n}\r\nif (!(neigh_flags & NTF_ROUTER)) {\r\nRT6_TRACE("purging route %p via non-router but gateway\n",\r\nrt);\r\nreturn -1;\r\n}\r\n}\r\ngc_args->more++;\r\n}\r\nreturn 0;\r\n}\r\nvoid fib6_run_gc(unsigned long expires, struct net *net, bool force)\r\n{\r\nstruct fib6_gc_args gc_args;\r\nunsigned long now;\r\nif (force) {\r\nspin_lock_bh(&net->ipv6.fib6_gc_lock);\r\n} else if (!spin_trylock_bh(&net->ipv6.fib6_gc_lock)) {\r\nmod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);\r\nreturn;\r\n}\r\ngc_args.timeout = expires ? (int)expires :\r\nnet->ipv6.sysctl.ip6_rt_gc_interval;\r\ngc_args.more = icmp6_dst_gc();\r\nfib6_clean_all(net, fib6_age, &gc_args);\r\nnow = jiffies;\r\nnet->ipv6.ip6_rt_last_gc = now;\r\nif (gc_args.more)\r\nmod_timer(&net->ipv6.ip6_fib_timer,\r\nround_jiffies(now\r\n+ net->ipv6.sysctl.ip6_rt_gc_interval));\r\nelse\r\ndel_timer(&net->ipv6.ip6_fib_timer);\r\nspin_unlock_bh(&net->ipv6.fib6_gc_lock);\r\n}\r\nstatic void fib6_gc_timer_cb(unsigned long arg)\r\n{\r\nfib6_run_gc(0, (struct net *)arg, true);\r\n}\r\nstatic int __net_init fib6_net_init(struct net *net)\r\n{\r\nsize_t size = sizeof(struct hlist_head) * FIB6_TABLE_HASHSZ;\r\nspin_lock_init(&net->ipv6.fib6_gc_lock);\r\nrwlock_init(&net->ipv6.fib6_walker_lock);\r\nINIT_LIST_HEAD(&net->ipv6.fib6_walkers);\r\nsetup_timer(&net->ipv6.ip6_fib_timer, fib6_gc_timer_cb, (unsigned long)net);\r\nnet->ipv6.rt6_stats = kzalloc(sizeof(*net->ipv6.rt6_stats), GFP_KERNEL);\r\nif (!net->ipv6.rt6_stats)\r\ngoto out_timer;\r\nsize = max_t(size_t, size, L1_CACHE_BYTES);\r\nnet->ipv6.fib_table_hash = kzalloc(size, GFP_KERNEL);\r\nif (!net->ipv6.fib_table_hash)\r\ngoto out_rt6_stats;\r\nnet->ipv6.fib6_main_tbl = kzalloc(sizeof(*net->ipv6.fib6_main_tbl),\r\nGFP_KERNEL);\r\nif (!net->ipv6.fib6_main_tbl)\r\ngoto out_fib_table_hash;\r\nnet->ipv6.fib6_main_tbl->tb6_id = RT6_TABLE_MAIN;\r\nnet->ipv6.fib6_main_tbl->tb6_root.leaf = net->ipv6.ip6_null_entry;\r\nnet->ipv6.fib6_main_tbl->tb6_root.fn_flags =\r\nRTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\r\ninet_peer_base_init(&net->ipv6.fib6_main_tbl->tb6_peers);\r\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\r\nnet->ipv6.fib6_local_tbl = kzalloc(sizeof(*net->ipv6.fib6_local_tbl),\r\nGFP_KERNEL);\r\nif (!net->ipv6.fib6_local_tbl)\r\ngoto out_fib6_main_tbl;\r\nnet->ipv6.fib6_local_tbl->tb6_id = RT6_TABLE_LOCAL;\r\nnet->ipv6.fib6_local_tbl->tb6_root.leaf = net->ipv6.ip6_null_entry;\r\nnet->ipv6.fib6_local_tbl->tb6_root.fn_flags =\r\nRTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\r\ninet_peer_base_init(&net->ipv6.fib6_local_tbl->tb6_peers);\r\n#endif\r\nfib6_tables_init(net);\r\nreturn 0;\r\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\r\nout_fib6_main_tbl:\r\nkfree(net->ipv6.fib6_main_tbl);\r\n#endif\r\nout_fib_table_hash:\r\nkfree(net->ipv6.fib_table_hash);\r\nout_rt6_stats:\r\nkfree(net->ipv6.rt6_stats);\r\nout_timer:\r\nreturn -ENOMEM;\r\n}\r\nstatic void fib6_net_exit(struct net *net)\r\n{\r\nrt6_ifdown(net, NULL);\r\ndel_timer_sync(&net->ipv6.ip6_fib_timer);\r\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\r\ninetpeer_invalidate_tree(&net->ipv6.fib6_local_tbl->tb6_peers);\r\nkfree(net->ipv6.fib6_local_tbl);\r\n#endif\r\ninetpeer_invalidate_tree(&net->ipv6.fib6_main_tbl->tb6_peers);\r\nkfree(net->ipv6.fib6_main_tbl);\r\nkfree(net->ipv6.fib_table_hash);\r\nkfree(net->ipv6.rt6_stats);\r\n}\r\nint __init fib6_init(void)\r\n{\r\nint ret = -ENOMEM;\r\nfib6_node_kmem = kmem_cache_create("fib6_nodes",\r\nsizeof(struct fib6_node),\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!fib6_node_kmem)\r\ngoto out;\r\nret = register_pernet_subsys(&fib6_net_ops);\r\nif (ret)\r\ngoto out_kmem_cache_create;\r\nret = __rtnl_register(PF_INET6, RTM_GETROUTE, NULL, inet6_dump_fib,\r\nNULL);\r\nif (ret)\r\ngoto out_unregister_subsys;\r\n__fib6_flush_trees = fib6_flush_trees;\r\nout:\r\nreturn ret;\r\nout_unregister_subsys:\r\nunregister_pernet_subsys(&fib6_net_ops);\r\nout_kmem_cache_create:\r\nkmem_cache_destroy(fib6_node_kmem);\r\ngoto out;\r\n}\r\nvoid fib6_gc_cleanup(void)\r\n{\r\nunregister_pernet_subsys(&fib6_net_ops);\r\nkmem_cache_destroy(fib6_node_kmem);\r\n}\r\nstatic int ipv6_route_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct rt6_info *rt = v;\r\nstruct ipv6_route_iter *iter = seq->private;\r\nseq_printf(seq, "%pi6 %02x ", &rt->rt6i_dst.addr, rt->rt6i_dst.plen);\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nseq_printf(seq, "%pi6 %02x ", &rt->rt6i_src.addr, rt->rt6i_src.plen);\r\n#else\r\nseq_puts(seq, "00000000000000000000000000000000 00 ");\r\n#endif\r\nif (rt->rt6i_flags & RTF_GATEWAY)\r\nseq_printf(seq, "%pi6", &rt->rt6i_gateway);\r\nelse\r\nseq_puts(seq, "00000000000000000000000000000000");\r\nseq_printf(seq, " %08x %08x %08x %08x %8s\n",\r\nrt->rt6i_metric, atomic_read(&rt->dst.__refcnt),\r\nrt->dst.__use, rt->rt6i_flags,\r\nrt->dst.dev ? rt->dst.dev->name : "");\r\niter->w.leaf = NULL;\r\nreturn 0;\r\n}\r\nstatic int ipv6_route_yield(struct fib6_walker *w)\r\n{\r\nstruct ipv6_route_iter *iter = w->args;\r\nif (!iter->skip)\r\nreturn 1;\r\ndo {\r\niter->w.leaf = iter->w.leaf->dst.rt6_next;\r\niter->skip--;\r\nif (!iter->skip && iter->w.leaf)\r\nreturn 1;\r\n} while (iter->w.leaf);\r\nreturn 0;\r\n}\r\nstatic void ipv6_route_seq_setup_walk(struct ipv6_route_iter *iter,\r\nstruct net *net)\r\n{\r\nmemset(&iter->w, 0, sizeof(iter->w));\r\niter->w.func = ipv6_route_yield;\r\niter->w.root = &iter->tbl->tb6_root;\r\niter->w.state = FWS_INIT;\r\niter->w.node = iter->w.root;\r\niter->w.args = iter;\r\niter->sernum = iter->w.root->fn_sernum;\r\nINIT_LIST_HEAD(&iter->w.lh);\r\nfib6_walker_link(net, &iter->w);\r\n}\r\nstatic struct fib6_table *ipv6_route_seq_next_table(struct fib6_table *tbl,\r\nstruct net *net)\r\n{\r\nunsigned int h;\r\nstruct hlist_node *node;\r\nif (tbl) {\r\nh = (tbl->tb6_id & (FIB6_TABLE_HASHSZ - 1)) + 1;\r\nnode = rcu_dereference_bh(hlist_next_rcu(&tbl->tb6_hlist));\r\n} else {\r\nh = 0;\r\nnode = NULL;\r\n}\r\nwhile (!node && h < FIB6_TABLE_HASHSZ) {\r\nnode = rcu_dereference_bh(\r\nhlist_first_rcu(&net->ipv6.fib_table_hash[h++]));\r\n}\r\nreturn hlist_entry_safe(node, struct fib6_table, tb6_hlist);\r\n}\r\nstatic void ipv6_route_check_sernum(struct ipv6_route_iter *iter)\r\n{\r\nif (iter->sernum != iter->w.root->fn_sernum) {\r\niter->sernum = iter->w.root->fn_sernum;\r\niter->w.state = FWS_INIT;\r\niter->w.node = iter->w.root;\r\nWARN_ON(iter->w.skip);\r\niter->w.skip = iter->w.count;\r\n}\r\n}\r\nstatic void *ipv6_route_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nint r;\r\nstruct rt6_info *n;\r\nstruct net *net = seq_file_net(seq);\r\nstruct ipv6_route_iter *iter = seq->private;\r\nif (!v)\r\ngoto iter_table;\r\nn = ((struct rt6_info *)v)->dst.rt6_next;\r\nif (n) {\r\n++*pos;\r\nreturn n;\r\n}\r\niter_table:\r\nipv6_route_check_sernum(iter);\r\nread_lock(&iter->tbl->tb6_lock);\r\nr = fib6_walk_continue(&iter->w);\r\nread_unlock(&iter->tbl->tb6_lock);\r\nif (r > 0) {\r\nif (v)\r\n++*pos;\r\nreturn iter->w.leaf;\r\n} else if (r < 0) {\r\nfib6_walker_unlink(net, &iter->w);\r\nreturn NULL;\r\n}\r\nfib6_walker_unlink(net, &iter->w);\r\niter->tbl = ipv6_route_seq_next_table(iter->tbl, net);\r\nif (!iter->tbl)\r\nreturn NULL;\r\nipv6_route_seq_setup_walk(iter, net);\r\ngoto iter_table;\r\n}\r\nstatic void *ipv6_route_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU_BH)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct ipv6_route_iter *iter = seq->private;\r\nrcu_read_lock_bh();\r\niter->tbl = ipv6_route_seq_next_table(NULL, net);\r\niter->skip = *pos;\r\nif (iter->tbl) {\r\nipv6_route_seq_setup_walk(iter, net);\r\nreturn ipv6_route_seq_next(seq, NULL, pos);\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nstatic bool ipv6_route_iter_active(struct ipv6_route_iter *iter)\r\n{\r\nstruct fib6_walker *w = &iter->w;\r\nreturn w->node && !(w->state == FWS_U && w->node == w->root);\r\n}\r\nstatic void ipv6_route_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU_BH)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct ipv6_route_iter *iter = seq->private;\r\nif (ipv6_route_iter_active(iter))\r\nfib6_walker_unlink(net, &iter->w);\r\nrcu_read_unlock_bh();\r\n}\r\nint ipv6_route_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ipv6_route_seq_ops,\r\nsizeof(struct ipv6_route_iter));\r\n}
