static int add_to_rbuf(struct mbox_chan *chan, void *mssg)\r\n{\r\nint idx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chan->lock, flags);\r\nif (chan->msg_count == MBOX_TX_QUEUE_LEN) {\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\nreturn -ENOBUFS;\r\n}\r\nidx = chan->msg_free;\r\nchan->msg_data[idx] = mssg;\r\nchan->msg_count++;\r\nif (idx == MBOX_TX_QUEUE_LEN - 1)\r\nchan->msg_free = 0;\r\nelse\r\nchan->msg_free++;\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\nreturn idx;\r\n}\r\nstatic void msg_submit(struct mbox_chan *chan)\r\n{\r\nunsigned count, idx;\r\nunsigned long flags;\r\nvoid *data;\r\nint err = -EBUSY;\r\nspin_lock_irqsave(&chan->lock, flags);\r\nif (!chan->msg_count || chan->active_req)\r\ngoto exit;\r\ncount = chan->msg_count;\r\nidx = chan->msg_free;\r\nif (idx >= count)\r\nidx -= count;\r\nelse\r\nidx += MBOX_TX_QUEUE_LEN - count;\r\ndata = chan->msg_data[idx];\r\nif (chan->cl->tx_prepare)\r\nchan->cl->tx_prepare(chan->cl, data);\r\nerr = chan->mbox->ops->send_data(chan, data);\r\nif (!err) {\r\nchan->active_req = data;\r\nchan->msg_count--;\r\n}\r\nexit:\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\nif (!err && (chan->txdone_method & TXDONE_BY_POLL))\r\nhrtimer_start(&chan->mbox->poll_hrt, ktime_set(0, 0),\r\nHRTIMER_MODE_REL);\r\n}\r\nstatic void tx_tick(struct mbox_chan *chan, int r)\r\n{\r\nunsigned long flags;\r\nvoid *mssg;\r\nspin_lock_irqsave(&chan->lock, flags);\r\nmssg = chan->active_req;\r\nchan->active_req = NULL;\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\nmsg_submit(chan);\r\nif (mssg && chan->cl->tx_done)\r\nchan->cl->tx_done(chan->cl, mssg, r);\r\nif (chan->cl->tx_block)\r\ncomplete(&chan->tx_complete);\r\n}\r\nstatic enum hrtimer_restart txdone_hrtimer(struct hrtimer *hrtimer)\r\n{\r\nstruct mbox_controller *mbox =\r\ncontainer_of(hrtimer, struct mbox_controller, poll_hrt);\r\nbool txdone, resched = false;\r\nint i;\r\nfor (i = 0; i < mbox->num_chans; i++) {\r\nstruct mbox_chan *chan = &mbox->chans[i];\r\nif (chan->active_req && chan->cl) {\r\ntxdone = chan->mbox->ops->last_tx_done(chan);\r\nif (txdone)\r\ntx_tick(chan, 0);\r\nelse\r\nresched = true;\r\n}\r\n}\r\nif (resched) {\r\nhrtimer_forward_now(hrtimer, ms_to_ktime(mbox->txpoll_period));\r\nreturn HRTIMER_RESTART;\r\n}\r\nreturn HRTIMER_NORESTART;\r\n}\r\nvoid mbox_chan_received_data(struct mbox_chan *chan, void *mssg)\r\n{\r\nif (chan->cl->rx_callback)\r\nchan->cl->rx_callback(chan->cl, mssg);\r\n}\r\nvoid mbox_chan_txdone(struct mbox_chan *chan, int r)\r\n{\r\nif (unlikely(!(chan->txdone_method & TXDONE_BY_IRQ))) {\r\ndev_err(chan->mbox->dev,\r\n"Controller can't run the TX ticker\n");\r\nreturn;\r\n}\r\ntx_tick(chan, r);\r\n}\r\nvoid mbox_client_txdone(struct mbox_chan *chan, int r)\r\n{\r\nif (unlikely(!(chan->txdone_method & TXDONE_BY_ACK))) {\r\ndev_err(chan->mbox->dev, "Client can't run the TX ticker\n");\r\nreturn;\r\n}\r\ntx_tick(chan, r);\r\n}\r\nbool mbox_client_peek_data(struct mbox_chan *chan)\r\n{\r\nif (chan->mbox->ops->peek_data)\r\nreturn chan->mbox->ops->peek_data(chan);\r\nreturn false;\r\n}\r\nint mbox_send_message(struct mbox_chan *chan, void *mssg)\r\n{\r\nint t;\r\nif (!chan || !chan->cl)\r\nreturn -EINVAL;\r\nt = add_to_rbuf(chan, mssg);\r\nif (t < 0) {\r\ndev_err(chan->mbox->dev, "Try increasing MBOX_TX_QUEUE_LEN\n");\r\nreturn t;\r\n}\r\nmsg_submit(chan);\r\nif (chan->cl->tx_block && chan->active_req) {\r\nunsigned long wait;\r\nint ret;\r\nif (!chan->cl->tx_tout)\r\nwait = msecs_to_jiffies(3600000);\r\nelse\r\nwait = msecs_to_jiffies(chan->cl->tx_tout);\r\nret = wait_for_completion_timeout(&chan->tx_complete, wait);\r\nif (ret == 0) {\r\nt = -EIO;\r\ntx_tick(chan, -EIO);\r\n}\r\n}\r\nreturn t;\r\n}\r\nstruct mbox_chan *mbox_request_channel(struct mbox_client *cl, int index)\r\n{\r\nstruct device *dev = cl->dev;\r\nstruct mbox_controller *mbox;\r\nstruct of_phandle_args spec;\r\nstruct mbox_chan *chan;\r\nunsigned long flags;\r\nint ret;\r\nif (!dev || !dev->of_node) {\r\npr_debug("%s: No owner device node\n", __func__);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nmutex_lock(&con_mutex);\r\nif (of_parse_phandle_with_args(dev->of_node, "mboxes",\r\n"#mbox-cells", index, &spec)) {\r\ndev_dbg(dev, "%s: can't parse \"mboxes\" property\n", __func__);\r\nmutex_unlock(&con_mutex);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nchan = ERR_PTR(-EPROBE_DEFER);\r\nlist_for_each_entry(mbox, &mbox_cons, node)\r\nif (mbox->dev->of_node == spec.np) {\r\nchan = mbox->of_xlate(mbox, &spec);\r\nbreak;\r\n}\r\nof_node_put(spec.np);\r\nif (IS_ERR(chan)) {\r\nmutex_unlock(&con_mutex);\r\nreturn chan;\r\n}\r\nif (chan->cl || !try_module_get(mbox->dev->driver->owner)) {\r\ndev_dbg(dev, "%s: mailbox not free\n", __func__);\r\nmutex_unlock(&con_mutex);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nspin_lock_irqsave(&chan->lock, flags);\r\nchan->msg_free = 0;\r\nchan->msg_count = 0;\r\nchan->active_req = NULL;\r\nchan->cl = cl;\r\ninit_completion(&chan->tx_complete);\r\nif (chan->txdone_method == TXDONE_BY_POLL && cl->knows_txdone)\r\nchan->txdone_method |= TXDONE_BY_ACK;\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\nret = chan->mbox->ops->startup(chan);\r\nif (ret) {\r\ndev_err(dev, "Unable to startup the chan (%d)\n", ret);\r\nmbox_free_channel(chan);\r\nchan = ERR_PTR(ret);\r\n}\r\nmutex_unlock(&con_mutex);\r\nreturn chan;\r\n}\r\nstruct mbox_chan *mbox_request_channel_byname(struct mbox_client *cl,\r\nconst char *name)\r\n{\r\nstruct device_node *np = cl->dev->of_node;\r\nstruct property *prop;\r\nconst char *mbox_name;\r\nint index = 0;\r\nif (!np) {\r\ndev_err(cl->dev, "%s() currently only supports DT\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!of_get_property(np, "mbox-names", NULL)) {\r\ndev_err(cl->dev,\r\n"%s() requires an \"mbox-names\" property\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nof_property_for_each_string(np, "mbox-names", prop, mbox_name) {\r\nif (!strncmp(name, mbox_name, strlen(name)))\r\nbreak;\r\nindex++;\r\n}\r\nreturn mbox_request_channel(cl, index);\r\n}\r\nvoid mbox_free_channel(struct mbox_chan *chan)\r\n{\r\nunsigned long flags;\r\nif (!chan || !chan->cl)\r\nreturn;\r\nchan->mbox->ops->shutdown(chan);\r\nspin_lock_irqsave(&chan->lock, flags);\r\nchan->cl = NULL;\r\nchan->active_req = NULL;\r\nif (chan->txdone_method == (TXDONE_BY_POLL | TXDONE_BY_ACK))\r\nchan->txdone_method = TXDONE_BY_POLL;\r\nmodule_put(chan->mbox->dev->driver->owner);\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\n}\r\nstatic struct mbox_chan *\r\nof_mbox_index_xlate(struct mbox_controller *mbox,\r\nconst struct of_phandle_args *sp)\r\n{\r\nint ind = sp->args[0];\r\nif (ind >= mbox->num_chans)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn &mbox->chans[ind];\r\n}\r\nint mbox_controller_register(struct mbox_controller *mbox)\r\n{\r\nint i, txdone;\r\nif (!mbox || !mbox->dev || !mbox->ops || !mbox->num_chans)\r\nreturn -EINVAL;\r\nif (mbox->txdone_irq)\r\ntxdone = TXDONE_BY_IRQ;\r\nelse if (mbox->txdone_poll)\r\ntxdone = TXDONE_BY_POLL;\r\nelse\r\ntxdone = TXDONE_BY_ACK;\r\nif (txdone == TXDONE_BY_POLL) {\r\nhrtimer_init(&mbox->poll_hrt, CLOCK_MONOTONIC,\r\nHRTIMER_MODE_REL);\r\nmbox->poll_hrt.function = txdone_hrtimer;\r\n}\r\nfor (i = 0; i < mbox->num_chans; i++) {\r\nstruct mbox_chan *chan = &mbox->chans[i];\r\nchan->cl = NULL;\r\nchan->mbox = mbox;\r\nchan->txdone_method = txdone;\r\nspin_lock_init(&chan->lock);\r\n}\r\nif (!mbox->of_xlate)\r\nmbox->of_xlate = of_mbox_index_xlate;\r\nmutex_lock(&con_mutex);\r\nlist_add_tail(&mbox->node, &mbox_cons);\r\nmutex_unlock(&con_mutex);\r\nreturn 0;\r\n}\r\nvoid mbox_controller_unregister(struct mbox_controller *mbox)\r\n{\r\nint i;\r\nif (!mbox)\r\nreturn;\r\nmutex_lock(&con_mutex);\r\nlist_del(&mbox->node);\r\nfor (i = 0; i < mbox->num_chans; i++)\r\nmbox_free_channel(&mbox->chans[i]);\r\nif (mbox->txdone_poll)\r\nhrtimer_cancel(&mbox->poll_hrt);\r\nmutex_unlock(&con_mutex);\r\n}
