static int wacom_get_report(struct hid_device *hdev, u8 type, u8 *buf,\r\nsize_t size, unsigned int retries)\r\n{\r\nint retval;\r\ndo {\r\nretval = hid_hw_raw_request(hdev, buf[0], buf, size, type,\r\nHID_REQ_GET_REPORT);\r\n} while ((retval == -ETIMEDOUT || retval == -EAGAIN) && --retries);\r\nif (retval < 0)\r\nhid_err(hdev, "wacom_get_report: ran out of retries "\r\n"(last error = %d)\n", retval);\r\nreturn retval;\r\n}\r\nstatic int wacom_set_report(struct hid_device *hdev, u8 type, u8 *buf,\r\nsize_t size, unsigned int retries)\r\n{\r\nint retval;\r\ndo {\r\nretval = hid_hw_raw_request(hdev, buf[0], buf, size, type,\r\nHID_REQ_SET_REPORT);\r\n} while ((retval == -ETIMEDOUT || retval == -EAGAIN) && --retries);\r\nif (retval < 0)\r\nhid_err(hdev, "wacom_set_report: ran out of retries "\r\n"(last error = %d)\n", retval);\r\nreturn retval;\r\n}\r\nstatic int wacom_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *raw_data, int size)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nif (size > WACOM_PKGLEN_MAX)\r\nreturn 1;\r\nmemcpy(wacom->wacom_wac.data, raw_data, size);\r\nwacom_wac_irq(&wacom->wacom_wac, size);\r\nreturn 0;\r\n}\r\nstatic int wacom_open(struct input_dev *dev)\r\n{\r\nstruct wacom *wacom = input_get_drvdata(dev);\r\nreturn hid_hw_open(wacom->hdev);\r\n}\r\nstatic void wacom_close(struct input_dev *dev)\r\n{\r\nstruct wacom *wacom = input_get_drvdata(dev);\r\nhid_hw_close(wacom->hdev);\r\n}\r\nstatic int wacom_calc_hid_res(int logical_extents, int physical_extents,\r\nunsigned unit, int exponent)\r\n{\r\nstruct hid_field field = {\r\n.logical_maximum = logical_extents,\r\n.physical_maximum = physical_extents,\r\n.unit = unit,\r\n.unit_exponent = exponent,\r\n};\r\nreturn hidinput_calc_abs_res(&field, ABS_X);\r\n}\r\nstatic void wacom_feature_mapping(struct hid_device *hdev,\r\nstruct hid_field *field, struct hid_usage *usage)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_features *features = &wacom->wacom_wac.features;\r\nstruct hid_data *hid_data = &wacom->wacom_wac.hid_data;\r\nu8 *data;\r\nint ret;\r\nswitch (usage->hid) {\r\ncase HID_DG_CONTACTMAX:\r\nif (!features->touch_max) {\r\ndata = kzalloc(2, GFP_KERNEL);\r\nif (!data)\r\nbreak;\r\ndata[0] = field->report->id;\r\nret = wacom_get_report(hdev, HID_FEATURE_REPORT,\r\ndata, 2, WAC_CMD_RETRIES);\r\nif (ret == 2) {\r\nfeatures->touch_max = data[1];\r\n} else {\r\nfeatures->touch_max = 16;\r\nhid_warn(hdev, "wacom_feature_mapping: "\r\n"could not get HID_DG_CONTACTMAX, "\r\n"defaulting to %d\n",\r\nfeatures->touch_max);\r\n}\r\nkfree(data);\r\n}\r\nbreak;\r\ncase HID_DG_INPUTMODE:\r\nif (usage->usage_index >= field->report_count) {\r\ndev_err(&hdev->dev, "HID_DG_INPUTMODE out of range\n");\r\nbreak;\r\n}\r\nhid_data->inputmode = field->report->id;\r\nhid_data->inputmode_index = usage->usage_index;\r\nbreak;\r\ncase HID_UP_DIGITIZER:\r\nif (field->report->id == 0x0B &&\r\n(field->application == WACOM_G9_DIGITIZER ||\r\nfield->application == WACOM_G11_DIGITIZER)) {\r\nwacom->wacom_wac.mode_report = field->report->id;\r\nwacom->wacom_wac.mode_value = 0;\r\n}\r\nbreak;\r\ncase WACOM_G9_PAGE:\r\ncase WACOM_G11_PAGE:\r\nif (field->report->id == 0x03 &&\r\n(field->application == WACOM_G9_TOUCHSCREEN ||\r\nfield->application == WACOM_G11_TOUCHSCREEN)) {\r\nwacom->wacom_wac.mode_report = field->report->id;\r\nwacom->wacom_wac.mode_value = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void wacom_usage_mapping(struct hid_device *hdev,\r\nstruct hid_field *field, struct hid_usage *usage)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_features *features = &wacom->wacom_wac.features;\r\nbool finger = WACOM_FINGER_FIELD(field);\r\nbool pen = WACOM_PEN_FIELD(field);\r\nif (pen)\r\nfeatures->device_type |= WACOM_DEVICETYPE_PEN;\r\nelse if (finger)\r\nfeatures->device_type |= WACOM_DEVICETYPE_TOUCH;\r\nelse\r\nreturn;\r\nif (features->type > BAMBOO_PT) {\r\nif (finger && !features->touch_max)\r\nfeatures->touch_max = 1;\r\n}\r\nswitch (usage->hid) {\r\ncase HID_GD_X:\r\nfeatures->x_max = field->logical_maximum;\r\nif (finger) {\r\nfeatures->x_phy = field->physical_maximum;\r\nif ((features->type != BAMBOO_PT) &&\r\n(features->type != BAMBOO_TOUCH)) {\r\nfeatures->unit = field->unit;\r\nfeatures->unitExpo = field->unit_exponent;\r\n}\r\n}\r\nbreak;\r\ncase HID_GD_Y:\r\nfeatures->y_max = field->logical_maximum;\r\nif (finger) {\r\nfeatures->y_phy = field->physical_maximum;\r\nif ((features->type != BAMBOO_PT) &&\r\n(features->type != BAMBOO_TOUCH)) {\r\nfeatures->unit = field->unit;\r\nfeatures->unitExpo = field->unit_exponent;\r\n}\r\n}\r\nbreak;\r\ncase HID_DG_TIPPRESSURE:\r\nif (pen)\r\nfeatures->pressure_max = field->logical_maximum;\r\nbreak;\r\n}\r\nif (features->type == HID_GENERIC)\r\nwacom_wac_usage_mapping(hdev, field, usage);\r\n}\r\nstatic void wacom_post_parse_hid(struct hid_device *hdev,\r\nstruct wacom_features *features)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nif (features->type == HID_GENERIC) {\r\nif (features->touch_max > 1) {\r\ninput_mt_init_slots(wacom_wac->touch_input, wacom_wac->features.touch_max,\r\nINPUT_MT_DIRECT);\r\n}\r\n}\r\n}\r\nstatic void wacom_parse_hid(struct hid_device *hdev,\r\nstruct wacom_features *features)\r\n{\r\nstruct hid_report_enum *rep_enum;\r\nstruct hid_report *hreport;\r\nint i, j;\r\nrep_enum = &hdev->report_enum[HID_FEATURE_REPORT];\r\nlist_for_each_entry(hreport, &rep_enum->report_list, list) {\r\nfor (i = 0; i < hreport->maxfield; i++) {\r\nif (hreport->field[i]->report_count < 1)\r\ncontinue;\r\nfor (j = 0; j < hreport->field[i]->maxusage; j++) {\r\nwacom_feature_mapping(hdev, hreport->field[i],\r\nhreport->field[i]->usage + j);\r\n}\r\n}\r\n}\r\nrep_enum = &hdev->report_enum[HID_INPUT_REPORT];\r\nlist_for_each_entry(hreport, &rep_enum->report_list, list) {\r\nif (!hreport->maxfield)\r\ncontinue;\r\nfor (i = 0; i < hreport->maxfield; i++)\r\nfor (j = 0; j < hreport->field[i]->maxusage; j++)\r\nwacom_usage_mapping(hdev, hreport->field[i],\r\nhreport->field[i]->usage + j);\r\n}\r\nwacom_post_parse_hid(hdev, features);\r\n}\r\nstatic int wacom_hid_set_device_mode(struct hid_device *hdev)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct hid_data *hid_data = &wacom->wacom_wac.hid_data;\r\nstruct hid_report *r;\r\nstruct hid_report_enum *re;\r\nif (hid_data->inputmode < 0)\r\nreturn 0;\r\nre = &(hdev->report_enum[HID_FEATURE_REPORT]);\r\nr = re->report_id_hash[hid_data->inputmode];\r\nif (r) {\r\nr->field[0]->value[hid_data->inputmode_index] = 2;\r\nhid_hw_request(hdev, r, HID_REQ_SET_REPORT);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wacom_set_device_mode(struct hid_device *hdev,\r\nstruct wacom_wac *wacom_wac)\r\n{\r\nu8 *rep_data;\r\nstruct hid_report *r;\r\nstruct hid_report_enum *re;\r\nint length;\r\nint error = -ENOMEM, limit = 0;\r\nif (wacom_wac->mode_report < 0)\r\nreturn 0;\r\nre = &(hdev->report_enum[HID_FEATURE_REPORT]);\r\nr = re->report_id_hash[wacom_wac->mode_report];\r\nif (!r)\r\nreturn -EINVAL;\r\nrep_data = hid_alloc_report_buf(r, GFP_KERNEL);\r\nif (!rep_data)\r\nreturn -ENOMEM;\r\nlength = hid_report_len(r);\r\ndo {\r\nrep_data[0] = wacom_wac->mode_report;\r\nrep_data[1] = wacom_wac->mode_value;\r\nerror = wacom_set_report(hdev, HID_FEATURE_REPORT, rep_data,\r\nlength, 1);\r\nif (error >= 0)\r\nerror = wacom_get_report(hdev, HID_FEATURE_REPORT,\r\nrep_data, length, 1);\r\n} while (error >= 0 &&\r\nrep_data[1] != wacom_wac->mode_report &&\r\nlimit++ < WAC_MSG_RETRIES);\r\nkfree(rep_data);\r\nreturn error < 0 ? error : 0;\r\n}\r\nstatic int wacom_bt_query_tablet_data(struct hid_device *hdev, u8 speed,\r\nstruct wacom_features *features)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nint ret;\r\nu8 rep_data[2];\r\nswitch (features->type) {\r\ncase GRAPHIRE_BT:\r\nrep_data[0] = 0x03;\r\nrep_data[1] = 0x00;\r\nret = wacom_set_report(hdev, HID_FEATURE_REPORT, rep_data, 2,\r\n3);\r\nif (ret >= 0) {\r\nrep_data[0] = speed == 0 ? 0x05 : 0x06;\r\nrep_data[1] = 0x00;\r\nret = wacom_set_report(hdev, HID_FEATURE_REPORT,\r\nrep_data, 2, 3);\r\nif (ret >= 0) {\r\nwacom->wacom_wac.bt_high_speed = speed;\r\nreturn 0;\r\n}\r\n}\r\nhid_warn(hdev, "failed to poke device, command %d, err %d\n",\r\nrep_data[0], ret);\r\nbreak;\r\ncase INTUOS4WL:\r\nif (speed == 1)\r\nwacom->wacom_wac.bt_features &= ~0x20;\r\nelse\r\nwacom->wacom_wac.bt_features |= 0x20;\r\nrep_data[0] = 0x03;\r\nrep_data[1] = wacom->wacom_wac.bt_features;\r\nret = wacom_set_report(hdev, HID_FEATURE_REPORT, rep_data, 2,\r\n1);\r\nif (ret >= 0)\r\nwacom->wacom_wac.bt_high_speed = speed;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wacom_query_tablet_data(struct hid_device *hdev,\r\nstruct wacom_features *features)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nif (hdev->bus == BUS_BLUETOOTH)\r\nreturn wacom_bt_query_tablet_data(hdev, 1, features);\r\nif (features->type != HID_GENERIC) {\r\nif (features->device_type & WACOM_DEVICETYPE_TOUCH) {\r\nif (features->type > TABLETPC) {\r\nwacom_wac->mode_report = 3;\r\nwacom_wac->mode_value = 4;\r\n} else if (features->type == WACOM_24HDT) {\r\nwacom_wac->mode_report = 18;\r\nwacom_wac->mode_value = 2;\r\n} else if (features->type == WACOM_27QHDT) {\r\nwacom_wac->mode_report = 131;\r\nwacom_wac->mode_value = 2;\r\n} else if (features->type == BAMBOO_PAD) {\r\nwacom_wac->mode_report = 2;\r\nwacom_wac->mode_value = 2;\r\n}\r\n} else if (features->device_type & WACOM_DEVICETYPE_PEN) {\r\nif (features->type <= BAMBOO_PT) {\r\nwacom_wac->mode_report = 2;\r\nwacom_wac->mode_value = 2;\r\n}\r\n}\r\n}\r\nwacom_set_device_mode(hdev, wacom_wac);\r\nif (features->type == HID_GENERIC)\r\nreturn wacom_hid_set_device_mode(hdev);\r\nreturn 0;\r\n}\r\nstatic void wacom_retrieve_hid_descriptor(struct hid_device *hdev,\r\nstruct wacom_features *features)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct usb_interface *intf = wacom->intf;\r\nfeatures->x_fuzz = 4;\r\nfeatures->y_fuzz = 4;\r\nfeatures->pressure_fuzz = 0;\r\nfeatures->distance_fuzz = 1;\r\nfeatures->tilt_fuzz = 1;\r\nif (features->type == WIRELESS) {\r\nif (intf->cur_altsetting->desc.bInterfaceNumber == 0)\r\nfeatures->device_type = WACOM_DEVICETYPE_WL_MONITOR;\r\nelse\r\nfeatures->device_type = WACOM_DEVICETYPE_NONE;\r\nreturn;\r\n}\r\nwacom_parse_hid(hdev, features);\r\n}\r\nstatic bool wacom_are_sibling(struct hid_device *hdev,\r\nstruct hid_device *sibling)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_features *features = &wacom->wacom_wac.features;\r\nint vid = features->oVid;\r\nint pid = features->oPid;\r\nint n1,n2;\r\nif (vid == 0 && pid == 0) {\r\nvid = hdev->vendor;\r\npid = hdev->product;\r\n}\r\nif (vid != sibling->vendor || pid != sibling->product)\r\nreturn false;\r\nn1 = strrchr(hdev->phys, '.') - hdev->phys;\r\nn2 = strrchr(sibling->phys, '.') - sibling->phys;\r\nif (n1 != n2 || n1 <= 0 || n2 <= 0)\r\nreturn false;\r\nreturn !strncmp(hdev->phys, sibling->phys, n1);\r\n}\r\nstatic struct wacom_hdev_data *wacom_get_hdev_data(struct hid_device *hdev)\r\n{\r\nstruct wacom_hdev_data *data;\r\nlist_for_each_entry(data, &wacom_udev_list, list) {\r\nif (wacom_are_sibling(hdev, data->dev)) {\r\nkref_get(&data->kref);\r\nreturn data;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int wacom_add_shared_data(struct hid_device *hdev)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct wacom_hdev_data *data;\r\nint retval = 0;\r\nmutex_lock(&wacom_udev_list_lock);\r\ndata = wacom_get_hdev_data(hdev);\r\nif (!data) {\r\ndata = kzalloc(sizeof(struct wacom_hdev_data), GFP_KERNEL);\r\nif (!data) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nkref_init(&data->kref);\r\ndata->dev = hdev;\r\nlist_add_tail(&data->list, &wacom_udev_list);\r\n}\r\nwacom_wac->shared = &data->shared;\r\nif (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)\r\nwacom_wac->shared->touch = hdev;\r\nelse if (wacom_wac->features.device_type & WACOM_DEVICETYPE_PEN)\r\nwacom_wac->shared->pen = hdev;\r\nout:\r\nmutex_unlock(&wacom_udev_list_lock);\r\nreturn retval;\r\n}\r\nstatic void wacom_release_shared_data(struct kref *kref)\r\n{\r\nstruct wacom_hdev_data *data =\r\ncontainer_of(kref, struct wacom_hdev_data, kref);\r\nmutex_lock(&wacom_udev_list_lock);\r\nlist_del(&data->list);\r\nmutex_unlock(&wacom_udev_list_lock);\r\nkfree(data);\r\n}\r\nstatic void wacom_remove_shared_data(struct wacom *wacom)\r\n{\r\nstruct wacom_hdev_data *data;\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nif (wacom_wac->shared) {\r\ndata = container_of(wacom_wac->shared, struct wacom_hdev_data,\r\nshared);\r\nif (wacom_wac->shared->touch == wacom->hdev)\r\nwacom_wac->shared->touch = NULL;\r\nelse if (wacom_wac->shared->pen == wacom->hdev)\r\nwacom_wac->shared->pen = NULL;\r\nkref_put(&data->kref, wacom_release_shared_data);\r\nwacom_wac->shared = NULL;\r\n}\r\n}\r\nstatic int wacom_led_control(struct wacom *wacom)\r\n{\r\nunsigned char *buf;\r\nint retval;\r\nunsigned char report_id = WAC_CMD_LED_CONTROL;\r\nint buf_size = 9;\r\nif (wacom->wacom_wac.pid) {\r\nreport_id = WAC_CMD_WL_LED_CONTROL;\r\nbuf_size = 13;\r\n}\r\nbuf = kzalloc(buf_size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (wacom->wacom_wac.features.type >= INTUOS5S &&\r\nwacom->wacom_wac.features.type <= INTUOSPL) {\r\nint ring_led = wacom->led.select[0] & 0x03;\r\nint ring_lum = (((wacom->led.llv & 0x60) >> 5) - 1) & 0x03;\r\nint crop_lum = 0;\r\nunsigned char led_bits = (crop_lum << 4) | (ring_lum << 2) | (ring_led);\r\nbuf[0] = report_id;\r\nif (wacom->wacom_wac.pid) {\r\nwacom_get_report(wacom->hdev, HID_FEATURE_REPORT,\r\nbuf, buf_size, WAC_CMD_RETRIES);\r\nbuf[0] = report_id;\r\nbuf[4] = led_bits;\r\n} else\r\nbuf[1] = led_bits;\r\n}\r\nelse {\r\nint led = wacom->led.select[0] | 0x4;\r\nif (wacom->wacom_wac.features.type == WACOM_21UX2 ||\r\nwacom->wacom_wac.features.type == WACOM_24HD)\r\nled |= (wacom->led.select[1] << 4) | 0x40;\r\nbuf[0] = report_id;\r\nbuf[1] = led;\r\nbuf[2] = wacom->led.llv;\r\nbuf[3] = wacom->led.hlv;\r\nbuf[4] = wacom->led.img_lum;\r\n}\r\nretval = wacom_set_report(wacom->hdev, HID_FEATURE_REPORT, buf, buf_size,\r\nWAC_CMD_RETRIES);\r\nkfree(buf);\r\nreturn retval;\r\n}\r\nstatic int wacom_led_putimage(struct wacom *wacom, int button_id, u8 xfer_id,\r\nconst unsigned len, const void *img)\r\n{\r\nunsigned char *buf;\r\nint i, retval;\r\nconst unsigned chunk_len = len / 4;\r\nbuf = kzalloc(chunk_len + 3 , GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = WAC_CMD_ICON_START;\r\nbuf[1] = 1;\r\nretval = wacom_set_report(wacom->hdev, HID_FEATURE_REPORT, buf, 2,\r\nWAC_CMD_RETRIES);\r\nif (retval < 0)\r\ngoto out;\r\nbuf[0] = xfer_id;\r\nbuf[1] = button_id & 0x07;\r\nfor (i = 0; i < 4; i++) {\r\nbuf[2] = i;\r\nmemcpy(buf + 3, img + i * chunk_len, chunk_len);\r\nretval = wacom_set_report(wacom->hdev, HID_FEATURE_REPORT,\r\nbuf, chunk_len + 3, WAC_CMD_RETRIES);\r\nif (retval < 0)\r\nbreak;\r\n}\r\nbuf[0] = WAC_CMD_ICON_START;\r\nbuf[1] = 0;\r\nwacom_set_report(wacom->hdev, HID_FEATURE_REPORT, buf, 2,\r\nWAC_CMD_RETRIES);\r\nout:\r\nkfree(buf);\r\nreturn retval;\r\n}\r\nstatic ssize_t wacom_led_select_store(struct device *dev, int set_id,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nunsigned int id;\r\nint err;\r\nerr = kstrtouint(buf, 10, &id);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&wacom->lock);\r\nwacom->led.select[set_id] = id & 0x3;\r\nerr = wacom_led_control(wacom);\r\nmutex_unlock(&wacom->lock);\r\nreturn err < 0 ? err : count;\r\n}\r\nstatic ssize_t wacom_luminance_store(struct wacom *wacom, u8 *dest,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int value;\r\nint err;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&wacom->lock);\r\n*dest = value & 0x7f;\r\nerr = wacom_led_control(wacom);\r\nmutex_unlock(&wacom->lock);\r\nreturn err < 0 ? err : count;\r\n}\r\nstatic ssize_t wacom_button_image_store(struct device *dev, int button_id,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nint err;\r\nunsigned len;\r\nu8 xfer_id;\r\nif (hdev->bus == BUS_BLUETOOTH) {\r\nlen = 256;\r\nxfer_id = WAC_CMD_ICON_BT_XFER;\r\n} else {\r\nlen = 1024;\r\nxfer_id = WAC_CMD_ICON_XFER;\r\n}\r\nif (count != len)\r\nreturn -EINVAL;\r\nmutex_lock(&wacom->lock);\r\nerr = wacom_led_putimage(wacom, button_id, xfer_id, len, buf);\r\nmutex_unlock(&wacom->lock);\r\nreturn err < 0 ? err : count;\r\n}\r\nstatic int wacom_initialize_leds(struct wacom *wacom)\r\n{\r\nint error;\r\nif (!(wacom->wacom_wac.features.device_type & WACOM_DEVICETYPE_PAD))\r\nreturn 0;\r\nswitch (wacom->wacom_wac.features.type) {\r\ncase INTUOS4S:\r\ncase INTUOS4:\r\ncase INTUOS4WL:\r\ncase INTUOS4L:\r\nwacom->led.select[0] = 0;\r\nwacom->led.select[1] = 0;\r\nwacom->led.llv = 10;\r\nwacom->led.hlv = 20;\r\nwacom->led.img_lum = 10;\r\nerror = sysfs_create_group(&wacom->hdev->dev.kobj,\r\n&intuos4_led_attr_group);\r\nbreak;\r\ncase WACOM_24HD:\r\ncase WACOM_21UX2:\r\nwacom->led.select[0] = 0;\r\nwacom->led.select[1] = 0;\r\nwacom->led.llv = 0;\r\nwacom->led.hlv = 0;\r\nwacom->led.img_lum = 0;\r\nerror = sysfs_create_group(&wacom->hdev->dev.kobj,\r\n&cintiq_led_attr_group);\r\nbreak;\r\ncase INTUOS5S:\r\ncase INTUOS5:\r\ncase INTUOS5L:\r\ncase INTUOSPS:\r\ncase INTUOSPM:\r\ncase INTUOSPL:\r\nwacom->led.select[0] = 0;\r\nwacom->led.select[1] = 0;\r\nwacom->led.llv = 32;\r\nwacom->led.hlv = 0;\r\nwacom->led.img_lum = 0;\r\nerror = sysfs_create_group(&wacom->hdev->dev.kobj,\r\n&intuos5_led_attr_group);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (error) {\r\nhid_err(wacom->hdev,\r\n"cannot create sysfs group err: %d\n", error);\r\nreturn error;\r\n}\r\nwacom_led_control(wacom);\r\nwacom->led_initialized = true;\r\nreturn 0;\r\n}\r\nstatic void wacom_destroy_leds(struct wacom *wacom)\r\n{\r\nif (!wacom->led_initialized)\r\nreturn;\r\nif (!(wacom->wacom_wac.features.device_type & WACOM_DEVICETYPE_PAD))\r\nreturn;\r\nwacom->led_initialized = false;\r\nswitch (wacom->wacom_wac.features.type) {\r\ncase INTUOS4S:\r\ncase INTUOS4:\r\ncase INTUOS4WL:\r\ncase INTUOS4L:\r\nsysfs_remove_group(&wacom->hdev->dev.kobj,\r\n&intuos4_led_attr_group);\r\nbreak;\r\ncase WACOM_24HD:\r\ncase WACOM_21UX2:\r\nsysfs_remove_group(&wacom->hdev->dev.kobj,\r\n&cintiq_led_attr_group);\r\nbreak;\r\ncase INTUOS5S:\r\ncase INTUOS5:\r\ncase INTUOS5L:\r\ncase INTUOSPS:\r\ncase INTUOSPM:\r\ncase INTUOSPL:\r\nsysfs_remove_group(&wacom->hdev->dev.kobj,\r\n&intuos5_led_attr_group);\r\nbreak;\r\n}\r\n}\r\nstatic int wacom_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct wacom *wacom = power_supply_get_drvdata(psy);\r\nint ret = 0;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = wacom->wacom_wac.bat_connected;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SCOPE:\r\nval->intval = POWER_SUPPLY_SCOPE_DEVICE;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nval->intval =\r\nwacom->wacom_wac.battery_capacity;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (wacom->wacom_wac.bat_charging)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (wacom->wacom_wac.battery_capacity == 100 &&\r\nwacom->wacom_wac.ps_connected)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse if (wacom->wacom_wac.ps_connected)\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wacom_ac_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct wacom *wacom = power_supply_get_drvdata(psy);\r\nint ret = 0;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = wacom->wacom_wac.ps_connected;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SCOPE:\r\nval->intval = POWER_SUPPLY_SCOPE_DEVICE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wacom_initialize_battery(struct wacom *wacom)\r\n{\r\nstatic atomic_t battery_no = ATOMIC_INIT(0);\r\nstruct power_supply_config psy_cfg = { .drv_data = wacom, };\r\nunsigned long n;\r\nif (wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) {\r\nstruct power_supply_desc *bat_desc = &wacom->battery_desc;\r\nstruct power_supply_desc *ac_desc = &wacom->ac_desc;\r\nn = atomic_inc_return(&battery_no) - 1;\r\nbat_desc->properties = wacom_battery_props;\r\nbat_desc->num_properties = ARRAY_SIZE(wacom_battery_props);\r\nbat_desc->get_property = wacom_battery_get_property;\r\nsprintf(wacom->wacom_wac.bat_name, "wacom_battery_%ld", n);\r\nbat_desc->name = wacom->wacom_wac.bat_name;\r\nbat_desc->type = POWER_SUPPLY_TYPE_BATTERY;\r\nbat_desc->use_for_apm = 0;\r\nac_desc->properties = wacom_ac_props;\r\nac_desc->num_properties = ARRAY_SIZE(wacom_ac_props);\r\nac_desc->get_property = wacom_ac_get_property;\r\nsprintf(wacom->wacom_wac.ac_name, "wacom_ac_%ld", n);\r\nac_desc->name = wacom->wacom_wac.ac_name;\r\nac_desc->type = POWER_SUPPLY_TYPE_MAINS;\r\nac_desc->use_for_apm = 0;\r\nwacom->battery = power_supply_register(&wacom->hdev->dev,\r\n&wacom->battery_desc, &psy_cfg);\r\nif (IS_ERR(wacom->battery))\r\nreturn PTR_ERR(wacom->battery);\r\npower_supply_powers(wacom->battery, &wacom->hdev->dev);\r\nwacom->ac = power_supply_register(&wacom->hdev->dev,\r\n&wacom->ac_desc,\r\n&psy_cfg);\r\nif (IS_ERR(wacom->ac)) {\r\npower_supply_unregister(wacom->battery);\r\nreturn PTR_ERR(wacom->ac);\r\n}\r\npower_supply_powers(wacom->ac, &wacom->hdev->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void wacom_destroy_battery(struct wacom *wacom)\r\n{\r\nif (wacom->battery) {\r\npower_supply_unregister(wacom->battery);\r\nwacom->battery = NULL;\r\npower_supply_unregister(wacom->ac);\r\nwacom->ac = NULL;\r\n}\r\n}\r\nstatic ssize_t wacom_show_speed(struct device *dev,\r\nstruct device_attribute\r\n*attr, char *buf)\r\n{\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);\r\n}\r\nstatic ssize_t wacom_store_speed(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nu8 new_speed;\r\nif (kstrtou8(buf, 0, &new_speed))\r\nreturn -EINVAL;\r\nif (new_speed != 0 && new_speed != 1)\r\nreturn -EINVAL;\r\nwacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);\r\nreturn count;\r\n}\r\nstatic ssize_t wacom_show_remote_mode(struct kobject *kobj,\r\nstruct kobj_attribute *kattr,\r\nchar *buf, int index)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj->parent);\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nu8 mode;\r\nmode = wacom->led.select[index];\r\nif (mode >= 0 && mode < 3)\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", mode);\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", -1);\r\n}\r\nint wacom_remote_create_attr_group(struct wacom *wacom, __u32 serial, int index)\r\n{\r\nint error = 0;\r\nchar *buf;\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nwacom_wac->serial[index] = serial;\r\nbuf = kzalloc(WAC_REMOTE_SERIAL_MAX_STRLEN, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nsnprintf(buf, WAC_REMOTE_SERIAL_MAX_STRLEN, "%d", serial);\r\nwacom->remote_group[index].name = buf;\r\nerror = sysfs_create_group(wacom->remote_dir,\r\n&wacom->remote_group[index]);\r\nif (error) {\r\nhid_err(wacom->hdev,\r\n"cannot create sysfs group err: %d\n", error);\r\nkobject_put(wacom->remote_dir);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nvoid wacom_remote_destroy_attr_group(struct wacom *wacom, __u32 serial)\r\n{\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nint i;\r\nif (!serial)\r\nreturn;\r\nfor (i = 0; i < WACOM_MAX_REMOTES; i++) {\r\nif (wacom_wac->serial[i] == serial) {\r\nwacom_wac->serial[i] = 0;\r\nwacom->led.select[i] = WACOM_STATUS_UNKNOWN;\r\nif (wacom->remote_group[i].name) {\r\nsysfs_remove_group(wacom->remote_dir,\r\n&wacom->remote_group[i]);\r\nkfree(wacom->remote_group[i].name);\r\nwacom->remote_group[i].name = NULL;\r\n}\r\n}\r\n}\r\n}\r\nstatic int wacom_cmd_unpair_remote(struct wacom *wacom, unsigned char selector)\r\n{\r\nconst size_t buf_size = 2;\r\nunsigned char *buf;\r\nint retval;\r\nbuf = kzalloc(buf_size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = WAC_CMD_DELETE_PAIRING;\r\nbuf[1] = selector;\r\nretval = wacom_set_report(wacom->hdev, HID_OUTPUT_REPORT, buf,\r\nbuf_size, WAC_CMD_RETRIES);\r\nkfree(buf);\r\nreturn retval;\r\n}\r\nstatic ssize_t wacom_store_unpair_remote(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned char selector = 0;\r\nstruct device *dev = kobj_to_dev(kobj->parent);\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nint err;\r\nif (!strncmp(buf, "*\n", 2)) {\r\nselector = WAC_CMD_UNPAIR_ALL;\r\n} else {\r\nhid_info(wacom->hdev, "remote: unrecognized unpair code: %s\n",\r\nbuf);\r\nreturn -1;\r\n}\r\nmutex_lock(&wacom->lock);\r\nerr = wacom_cmd_unpair_remote(wacom, selector);\r\nmutex_unlock(&wacom->lock);\r\nreturn err < 0 ? err : count;\r\n}\r\nstatic int wacom_initialize_remote(struct wacom *wacom)\r\n{\r\nint error = 0;\r\nstruct wacom_wac *wacom_wac = &(wacom->wacom_wac);\r\nint i;\r\nif (wacom->wacom_wac.features.type != REMOTE)\r\nreturn 0;\r\nwacom->remote_group[0] = remote0_serial_group;\r\nwacom->remote_group[1] = remote1_serial_group;\r\nwacom->remote_group[2] = remote2_serial_group;\r\nwacom->remote_group[3] = remote3_serial_group;\r\nwacom->remote_group[4] = remote4_serial_group;\r\nwacom->remote_dir = kobject_create_and_add("wacom_remote",\r\n&wacom->hdev->dev.kobj);\r\nif (!wacom->remote_dir)\r\nreturn -ENOMEM;\r\nerror = sysfs_create_files(wacom->remote_dir, remote_unpair_attrs);\r\nif (error) {\r\nhid_err(wacom->hdev,\r\n"cannot create sysfs group err: %d\n", error);\r\nreturn error;\r\n}\r\nfor (i = 0; i < WACOM_MAX_REMOTES; i++) {\r\nwacom->led.select[i] = WACOM_STATUS_UNKNOWN;\r\nwacom_wac->serial[i] = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct input_dev *wacom_allocate_input(struct wacom *wacom)\r\n{\r\nstruct input_dev *input_dev;\r\nstruct hid_device *hdev = wacom->hdev;\r\nstruct wacom_wac *wacom_wac = &(wacom->wacom_wac);\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn NULL;\r\ninput_dev->name = wacom_wac->features.name;\r\ninput_dev->phys = hdev->phys;\r\ninput_dev->dev.parent = &hdev->dev;\r\ninput_dev->open = wacom_open;\r\ninput_dev->close = wacom_close;\r\ninput_dev->uniq = hdev->uniq;\r\ninput_dev->id.bustype = hdev->bus;\r\ninput_dev->id.vendor = hdev->vendor;\r\ninput_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;\r\ninput_dev->id.version = hdev->version;\r\ninput_set_drvdata(input_dev, wacom);\r\nreturn input_dev;\r\n}\r\nstatic void wacom_clean_inputs(struct wacom *wacom)\r\n{\r\nif (wacom->wacom_wac.pen_input) {\r\nif (wacom->wacom_wac.pen_registered)\r\ninput_unregister_device(wacom->wacom_wac.pen_input);\r\nelse\r\ninput_free_device(wacom->wacom_wac.pen_input);\r\n}\r\nif (wacom->wacom_wac.touch_input) {\r\nif (wacom->wacom_wac.touch_registered)\r\ninput_unregister_device(wacom->wacom_wac.touch_input);\r\nelse\r\ninput_free_device(wacom->wacom_wac.touch_input);\r\n}\r\nif (wacom->wacom_wac.pad_input) {\r\nif (wacom->wacom_wac.pad_registered)\r\ninput_unregister_device(wacom->wacom_wac.pad_input);\r\nelse\r\ninput_free_device(wacom->wacom_wac.pad_input);\r\n}\r\nkobject_put(wacom->remote_dir);\r\nwacom->wacom_wac.pen_input = NULL;\r\nwacom->wacom_wac.touch_input = NULL;\r\nwacom->wacom_wac.pad_input = NULL;\r\nwacom->wacom_wac.pen_registered = false;\r\nwacom->wacom_wac.touch_registered = false;\r\nwacom->wacom_wac.pad_registered = false;\r\nwacom_destroy_leds(wacom);\r\n}\r\nstatic int wacom_allocate_inputs(struct wacom *wacom)\r\n{\r\nstruct wacom_wac *wacom_wac = &(wacom->wacom_wac);\r\nwacom_wac->pen_input = wacom_allocate_input(wacom);\r\nwacom_wac->touch_input = wacom_allocate_input(wacom);\r\nwacom_wac->pad_input = wacom_allocate_input(wacom);\r\nif (!wacom_wac->pen_input || !wacom_wac->touch_input || !wacom_wac->pad_input) {\r\nwacom_clean_inputs(wacom);\r\nreturn -ENOMEM;\r\n}\r\nwacom_wac->pen_input->name = wacom_wac->pen_name;\r\nwacom_wac->touch_input->name = wacom_wac->touch_name;\r\nwacom_wac->pad_input->name = wacom_wac->pad_name;\r\nreturn 0;\r\n}\r\nstatic int wacom_register_inputs(struct wacom *wacom)\r\n{\r\nstruct input_dev *pen_input_dev, *touch_input_dev, *pad_input_dev;\r\nstruct wacom_wac *wacom_wac = &(wacom->wacom_wac);\r\nint error = 0;\r\npen_input_dev = wacom_wac->pen_input;\r\ntouch_input_dev = wacom_wac->touch_input;\r\npad_input_dev = wacom_wac->pad_input;\r\nif (!pen_input_dev || !touch_input_dev || !pad_input_dev)\r\nreturn -EINVAL;\r\nerror = wacom_setup_pen_input_capabilities(pen_input_dev, wacom_wac);\r\nif (error) {\r\ninput_free_device(pen_input_dev);\r\nwacom_wac->pen_input = NULL;\r\npen_input_dev = NULL;\r\n} else {\r\nerror = input_register_device(pen_input_dev);\r\nif (error)\r\ngoto fail_register_pen_input;\r\nwacom_wac->pen_registered = true;\r\n}\r\nerror = wacom_setup_touch_input_capabilities(touch_input_dev, wacom_wac);\r\nif (error) {\r\ninput_free_device(touch_input_dev);\r\nwacom_wac->touch_input = NULL;\r\ntouch_input_dev = NULL;\r\n} else {\r\nerror = input_register_device(touch_input_dev);\r\nif (error)\r\ngoto fail_register_touch_input;\r\nwacom_wac->touch_registered = true;\r\n}\r\nerror = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);\r\nif (error) {\r\ninput_free_device(pad_input_dev);\r\nwacom_wac->pad_input = NULL;\r\npad_input_dev = NULL;\r\n} else {\r\nerror = input_register_device(pad_input_dev);\r\nif (error)\r\ngoto fail_register_pad_input;\r\nwacom_wac->pad_registered = true;\r\nerror = wacom_initialize_leds(wacom);\r\nif (error)\r\ngoto fail_leds;\r\nerror = wacom_initialize_remote(wacom);\r\nif (error)\r\ngoto fail_remote;\r\n}\r\nreturn 0;\r\nfail_remote:\r\nwacom_destroy_leds(wacom);\r\nfail_leds:\r\ninput_unregister_device(pad_input_dev);\r\npad_input_dev = NULL;\r\nwacom_wac->pad_registered = false;\r\nfail_register_pad_input:\r\nif (touch_input_dev)\r\ninput_unregister_device(touch_input_dev);\r\nwacom_wac->touch_input = NULL;\r\nwacom_wac->touch_registered = false;\r\nfail_register_touch_input:\r\nif (pen_input_dev)\r\ninput_unregister_device(pen_input_dev);\r\nwacom_wac->pen_input = NULL;\r\nwacom_wac->pen_registered = false;\r\nfail_register_pen_input:\r\nreturn error;\r\n}\r\nstatic void wacom_set_default_phy(struct wacom_features *features)\r\n{\r\nif (features->x_resolution) {\r\nfeatures->x_phy = (features->x_max * 100) /\r\nfeatures->x_resolution;\r\nfeatures->y_phy = (features->y_max * 100) /\r\nfeatures->y_resolution;\r\n}\r\n}\r\nstatic void wacom_calculate_res(struct wacom_features *features)\r\n{\r\nif (!features->unit) {\r\nfeatures->unit = 0x11;\r\nfeatures->unitExpo = -3;\r\n}\r\nfeatures->x_resolution = wacom_calc_hid_res(features->x_max,\r\nfeatures->x_phy,\r\nfeatures->unit,\r\nfeatures->unitExpo);\r\nfeatures->y_resolution = wacom_calc_hid_res(features->y_max,\r\nfeatures->y_phy,\r\nfeatures->unit,\r\nfeatures->unitExpo);\r\n}\r\nvoid wacom_battery_work(struct work_struct *work)\r\n{\r\nstruct wacom *wacom = container_of(work, struct wacom, work);\r\nif ((wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&\r\n!wacom->battery) {\r\nwacom_initialize_battery(wacom);\r\n}\r\nelse if (!(wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&\r\nwacom->battery) {\r\nwacom_destroy_battery(wacom);\r\n}\r\n}\r\nstatic size_t wacom_compute_pktlen(struct hid_device *hdev)\r\n{\r\nstruct hid_report_enum *report_enum;\r\nstruct hid_report *report;\r\nsize_t size = 0;\r\nreport_enum = hdev->report_enum + HID_INPUT_REPORT;\r\nlist_for_each_entry(report, &report_enum->report_list, list) {\r\nsize_t report_size = hid_report_len(report);\r\nif (report_size > size)\r\nsize = report_size;\r\n}\r\nreturn size;\r\n}\r\nstatic void wacom_update_name(struct wacom *wacom, const char *suffix)\r\n{\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct wacom_features *features = &wacom_wac->features;\r\nchar name[WACOM_NAME_MAX];\r\nif ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {\r\nif (strstr(wacom->hdev->name, "Wacom") ||\r\nstrstr(wacom->hdev->name, "wacom") ||\r\nstrstr(wacom->hdev->name, "WACOM")) {\r\nstrlcpy(name, wacom->hdev->name, sizeof(name));\r\nwhile (1) {\r\nchar *gap = strstr(name, " ");\r\nif (gap == NULL)\r\nbreak;\r\nmemmove(gap, gap+1, strlen(gap));\r\n}\r\nif (name[strlen(name)-1] == ' ')\r\nname[strlen(name)-1] = '\0';\r\n} else {\r\nsnprintf(name, sizeof(name),\r\n"%s %X", features->name, wacom->hdev->product);\r\n}\r\n} else {\r\nstrlcpy(name, features->name, sizeof(name));\r\n}\r\nsnprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),\r\n"%s%s Pen", name, suffix);\r\nsnprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),\r\n"%s%s Finger", name, suffix);\r\nsnprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),\r\n"%s%s Pad", name, suffix);\r\n}\r\nstatic int wacom_parse_and_register(struct wacom *wacom, bool wireless)\r\n{\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct wacom_features *features = &wacom_wac->features;\r\nstruct hid_device *hdev = wacom->hdev;\r\nint error;\r\nunsigned int connect_mask = HID_CONNECT_HIDRAW;\r\nfeatures->pktlen = wacom_compute_pktlen(hdev);\r\nif (features->pktlen > WACOM_PKGLEN_MAX)\r\nreturn -EINVAL;\r\nerror = wacom_allocate_inputs(wacom);\r\nif (error)\r\nreturn error;\r\nif (features->type == BAMBOO_PAD) {\r\nif (features->pktlen == WACOM_PKGLEN_PENABLED) {\r\nfeatures->type = HID_GENERIC;\r\n} else if ((features->pktlen != WACOM_PKGLEN_BPAD_TOUCH) &&\r\n(features->pktlen != WACOM_PKGLEN_BPAD_TOUCH_USB)) {\r\nerror = -ENODEV;\r\ngoto fail_allocate_inputs;\r\n}\r\n}\r\nwacom_set_default_phy(features);\r\nwacom_retrieve_hid_descriptor(hdev, features);\r\nwacom_setup_device_quirks(wacom);\r\nif (features->device_type == WACOM_DEVICETYPE_NONE &&\r\nfeatures->type != WIRELESS) {\r\nerror = features->type == HID_GENERIC ? -ENODEV : 0;\r\ndev_warn(&hdev->dev, "Unknown device_type for '%s'. %s.",\r\nhdev->name,\r\nerror ? "Ignoring" : "Assuming pen");\r\nif (error)\r\ngoto fail_parsed;\r\nfeatures->device_type |= WACOM_DEVICETYPE_PEN;\r\n}\r\nwacom_calculate_res(features);\r\nwacom_update_name(wacom, wireless ? " (WL)" : "");\r\nerror = wacom_add_shared_data(hdev);\r\nif (error)\r\ngoto fail_shared_data;\r\nif (!(features->device_type & WACOM_DEVICETYPE_WL_MONITOR) &&\r\n(features->quirks & WACOM_QUIRK_BATTERY)) {\r\nerror = wacom_initialize_battery(wacom);\r\nif (error)\r\ngoto fail_battery;\r\n}\r\nerror = wacom_register_inputs(wacom);\r\nif (error)\r\ngoto fail_register_inputs;\r\nif (features->type == HID_GENERIC)\r\nconnect_mask |= HID_CONNECT_DRIVER;\r\nerror = hid_hw_start(hdev, connect_mask);\r\nif (error) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto fail_hw_start;\r\n}\r\nif (!wireless) {\r\nwacom_query_tablet_data(hdev, features);\r\n}\r\nif ((features->type == BAMBOO_TOUCH) &&\r\n(features->device_type & WACOM_DEVICETYPE_PEN)) {\r\nerror = -ENODEV;\r\ngoto fail_hw_start;\r\n}\r\nif ((features->type == BAMBOO_PEN) &&\r\n((features->device_type & WACOM_DEVICETYPE_TOUCH) ||\r\n(features->device_type & WACOM_DEVICETYPE_PAD))) {\r\nerror = -ENODEV;\r\ngoto fail_hw_start;\r\n}\r\nif (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)\r\nerror = hid_hw_open(hdev);\r\nif ((wacom_wac->features.type == INTUOSHT ||\r\nwacom_wac->features.type == INTUOSHT2) &&\r\n(wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)) {\r\nwacom_wac->shared->touch_input = wacom_wac->touch_input;\r\n}\r\nreturn 0;\r\nfail_hw_start:\r\nhid_hw_stop(hdev);\r\nfail_register_inputs:\r\nwacom_clean_inputs(wacom);\r\nwacom_destroy_battery(wacom);\r\nfail_battery:\r\nwacom_remove_shared_data(wacom);\r\nfail_shared_data:\r\nfail_parsed:\r\nfail_allocate_inputs:\r\nwacom_clean_inputs(wacom);\r\nreturn error;\r\n}\r\nstatic void wacom_wireless_work(struct work_struct *work)\r\n{\r\nstruct wacom *wacom = container_of(work, struct wacom, work);\r\nstruct usb_device *usbdev = wacom->usbdev;\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct hid_device *hdev1, *hdev2;\r\nstruct wacom *wacom1, *wacom2;\r\nstruct wacom_wac *wacom_wac1, *wacom_wac2;\r\nint error;\r\nwacom_destroy_battery(wacom);\r\nhdev1 = usb_get_intfdata(usbdev->config->interface[1]);\r\nwacom1 = hid_get_drvdata(hdev1);\r\nwacom_wac1 = &(wacom1->wacom_wac);\r\nwacom_clean_inputs(wacom1);\r\nhdev2 = usb_get_intfdata(usbdev->config->interface[2]);\r\nwacom2 = hid_get_drvdata(hdev2);\r\nwacom_wac2 = &(wacom2->wacom_wac);\r\nwacom_clean_inputs(wacom2);\r\nif (wacom_wac->pid == 0) {\r\nhid_info(wacom->hdev, "wireless tablet disconnected\n");\r\nwacom_wac1->shared->type = 0;\r\n} else {\r\nconst struct hid_device_id *id = wacom_ids;\r\nhid_info(wacom->hdev, "wireless tablet connected with PID %x\n",\r\nwacom_wac->pid);\r\nwhile (id->bus) {\r\nif (id->vendor == USB_VENDOR_ID_WACOM &&\r\nid->product == wacom_wac->pid)\r\nbreak;\r\nid++;\r\n}\r\nif (!id->bus) {\r\nhid_info(wacom->hdev, "ignoring unknown PID.\n");\r\nreturn;\r\n}\r\nwacom_wac1->features =\r\n*((struct wacom_features *)id->driver_data);\r\nwacom_wac1->pid = wacom_wac->pid;\r\nhid_hw_stop(hdev1);\r\nerror = wacom_parse_and_register(wacom1, true);\r\nif (error)\r\ngoto fail;\r\nif (wacom_wac1->features.touch_max ||\r\n(wacom_wac1->features.type >= INTUOSHT &&\r\nwacom_wac1->features.type <= BAMBOO_PT)) {\r\nwacom_wac2->features =\r\n*((struct wacom_features *)id->driver_data);\r\nwacom_wac2->pid = wacom_wac->pid;\r\nhid_hw_stop(hdev2);\r\nerror = wacom_parse_and_register(wacom2, true);\r\nif (error)\r\ngoto fail;\r\n}\r\nerror = wacom_initialize_battery(wacom);\r\nif (error)\r\ngoto fail;\r\n}\r\nreturn;\r\nfail:\r\nwacom_clean_inputs(wacom1);\r\nwacom_clean_inputs(wacom2);\r\nreturn;\r\n}\r\nstatic int wacom_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct wacom *wacom;\r\nstruct wacom_wac *wacom_wac;\r\nstruct wacom_features *features;\r\nint error;\r\nif (!id->driver_data)\r\nreturn -EINVAL;\r\nhdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\r\nhdev->quirks &= ~HID_QUIRK_NOGET;\r\nwacom = kzalloc(sizeof(struct wacom), GFP_KERNEL);\r\nif (!wacom)\r\nreturn -ENOMEM;\r\nhid_set_drvdata(hdev, wacom);\r\nwacom->hdev = hdev;\r\nwacom_wac = &wacom->wacom_wac;\r\nwacom_wac->features = *((struct wacom_features *)id->driver_data);\r\nfeatures = &wacom_wac->features;\r\nif (features->check_for_hid_type && features->hid_type != hdev->type) {\r\nerror = -ENODEV;\r\ngoto fail_type;\r\n}\r\nwacom_wac->hid_data.inputmode = -1;\r\nwacom_wac->mode_report = -1;\r\nwacom->usbdev = dev;\r\nwacom->intf = intf;\r\nmutex_init(&wacom->lock);\r\nINIT_WORK(&wacom->work, wacom_wireless_work);\r\nerror = hid_parse(hdev);\r\nif (error) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto fail_parse;\r\n}\r\nerror = wacom_parse_and_register(wacom, false);\r\nif (error)\r\ngoto fail_parse;\r\nif (hdev->bus == BUS_BLUETOOTH) {\r\nerror = device_create_file(&hdev->dev, &dev_attr_speed);\r\nif (error)\r\nhid_warn(hdev,\r\n"can't create sysfs speed attribute err: %d\n",\r\nerror);\r\n}\r\nreturn 0;\r\nfail_type:\r\nfail_parse:\r\nkfree(wacom);\r\nhid_set_drvdata(hdev, NULL);\r\nreturn error;\r\n}\r\nstatic void wacom_remove(struct hid_device *hdev)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct wacom_features *features = &wacom_wac->features;\r\nif (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)\r\nhid_hw_close(hdev);\r\nhid_hw_stop(hdev);\r\ncancel_work_sync(&wacom->work);\r\nwacom_clean_inputs(wacom);\r\nif (hdev->bus == BUS_BLUETOOTH)\r\ndevice_remove_file(&hdev->dev, &dev_attr_speed);\r\nwacom_destroy_battery(wacom);\r\nwacom_remove_shared_data(wacom);\r\nhid_set_drvdata(hdev, NULL);\r\nkfree(wacom);\r\n}\r\nstatic int wacom_resume(struct hid_device *hdev)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_features *features = &wacom->wacom_wac.features;\r\nmutex_lock(&wacom->lock);\r\nwacom_query_tablet_data(hdev, features);\r\nwacom_led_control(wacom);\r\nmutex_unlock(&wacom->lock);\r\nreturn 0;\r\n}\r\nstatic int wacom_reset_resume(struct hid_device *hdev)\r\n{\r\nreturn wacom_resume(hdev);\r\n}
