static int bcm2048_send_command(struct bcm2048_device *bdev, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct i2c_client *client = bdev->client;\r\nu8 data[2];\r\nif (!bdev->power_state) {\r\ndev_err(&bdev->client->dev, "bcm2048: chip not powered!\n");\r\nreturn -EIO;\r\n}\r\ndata[0] = reg & 0xff;\r\ndata[1] = value & 0xff;\r\nif (i2c_master_send(client, data, 2) == 2)\r\nreturn 0;\r\ndev_err(&bdev->client->dev, "BCM I2C error!\n");\r\ndev_err(&bdev->client->dev, "Is Bluetooth up and running?\n");\r\nreturn -EIO;\r\n}\r\nstatic int bcm2048_recv_command(struct bcm2048_device *bdev, unsigned int reg,\r\nu8 *value)\r\n{\r\nstruct i2c_client *client = bdev->client;\r\nif (!bdev->power_state) {\r\ndev_err(&bdev->client->dev, "bcm2048: chip not powered!\n");\r\nreturn -EIO;\r\n}\r\nvalue[0] = i2c_smbus_read_byte_data(client, reg & 0xff);\r\nreturn 0;\r\n}\r\nstatic int bcm2048_recv_duples(struct bcm2048_device *bdev, unsigned int reg,\r\nu8 *value, u8 duples)\r\n{\r\nstruct i2c_client *client = bdev->client;\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg[2];\r\nu8 buf;\r\nif (!bdev->power_state) {\r\ndev_err(&bdev->client->dev, "bcm2048: chip not powered!\n");\r\nreturn -EIO;\r\n}\r\nbuf = reg & 0xff;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = client->flags & I2C_M_TEN;\r\nmsg[0].len = 1;\r\nmsg[0].buf = &buf;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = client->flags & I2C_M_TEN;\r\nmsg[1].flags |= I2C_M_RD;\r\nmsg[1].len = duples;\r\nmsg[1].buf = value;\r\nreturn i2c_transfer(adap, msg, 2);\r\n}\r\nstatic int bcm2048_set_power_state(struct bcm2048_device *bdev, u8 power)\r\n{\r\nint err = 0;\r\nmutex_lock(&bdev->mutex);\r\nif (power) {\r\nbdev->power_state = BCM2048_POWER_ON;\r\nbdev->cache_fm_rds_system |= BCM2048_FM_ON;\r\n} else {\r\nbdev->cache_fm_rds_system &= ~BCM2048_FM_ON;\r\n}\r\nif (power)\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_RDS_SYSTEM,\r\nbdev->cache_fm_rds_system);\r\nmsleep(BCM2048_DEFAULT_POWERING_DELAY);\r\nif (!power)\r\nbdev->power_state = BCM2048_POWER_OFF;\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_power_state(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_SYSTEM, &value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err && (value & BCM2048_FM_ON))\r\nreturn BCM2048_POWER_ON;\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_rds_no_lock(struct bcm2048_device *bdev, u8 rds_on)\r\n{\r\nint err;\r\nu8 flags;\r\nbdev->cache_fm_rds_system &= ~BCM2048_RDS_ON;\r\nif (rds_on) {\r\nbdev->cache_fm_rds_system |= BCM2048_RDS_ON;\r\nbdev->rds_state = BCM2048_RDS_ON;\r\nflags = BCM2048_RDS_FLAG_FIFO_WLINE;\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_RDS_MASK1,\r\nflags);\r\n} else {\r\nflags = 0;\r\nbdev->rds_state = 0;\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_RDS_MASK1,\r\nflags);\r\nmemset(&bdev->rds_info, 0, sizeof(bdev->rds_info));\r\n}\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_RDS_SYSTEM,\r\nbdev->cache_fm_rds_system);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_rds_no_lock(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_SYSTEM, &value);\r\nif (!err && (value & BCM2048_RDS_ON))\r\nreturn BCM2048_ITEM_ENABLED;\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_rds(struct bcm2048_device *bdev, u8 rds_on)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_set_rds_no_lock(bdev, rds_on);\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_rds(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_get_rds_no_lock(bdev);\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_rds_pi(struct bcm2048_device *bdev)\r\n{\r\nreturn bdev->rds_info.rds_pi;\r\n}\r\nstatic int bcm2048_set_fm_automatic_stereo_mono(struct bcm2048_device *bdev,\r\nu8 enabled)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nbdev->cache_fm_ctrl &= ~BCM2048_STEREO_MONO_AUTO_SELECT;\r\nif (enabled)\r\nbdev->cache_fm_ctrl |= BCM2048_STEREO_MONO_AUTO_SELECT;\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_CTRL,\r\nbdev->cache_fm_ctrl);\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_fm_hi_lo_injection(struct bcm2048_device *bdev,\r\nu8 hi_lo)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nbdev->cache_fm_ctrl &= ~BCM2048_HI_LO_INJECTION;\r\nif (hi_lo)\r\nbdev->cache_fm_ctrl |= BCM2048_HI_LO_INJECTION;\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_CTRL,\r\nbdev->cache_fm_ctrl);\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_hi_lo_injection(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_CTRL, &value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err && (value & BCM2048_HI_LO_INJECTION))\r\nreturn BCM2048_ITEM_ENABLED;\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_fm_frequency(struct bcm2048_device *bdev, u32 frequency)\r\n{\r\nint err;\r\nif (frequency < bdev->region_info.bottom_frequency ||\r\nfrequency > bdev->region_info.top_frequency)\r\nreturn -EDOM;\r\nfrequency -= BCM2048_FREQUENCY_BASE;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_FREQ0, lsb(frequency));\r\nerr |= bcm2048_send_command(bdev, BCM2048_I2C_FM_FREQ1,\r\nmsb(frequency));\r\nif (!err)\r\nbdev->frequency = frequency;\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_frequency(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 lsb = 0, msb = 0;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_FREQ0, &lsb);\r\nerr |= bcm2048_recv_command(bdev, BCM2048_I2C_FM_FREQ1, &msb);\r\nmutex_unlock(&bdev->mutex);\r\nif (err)\r\nreturn err;\r\nerr = compose_u16(msb, lsb);\r\nerr += BCM2048_FREQUENCY_BASE;\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_fm_af_frequency(struct bcm2048_device *bdev,\r\nu32 frequency)\r\n{\r\nint err;\r\nif (frequency < bdev->region_info.bottom_frequency ||\r\nfrequency > bdev->region_info.top_frequency)\r\nreturn -EDOM;\r\nfrequency -= BCM2048_FREQUENCY_BASE;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_AF_FREQ0,\r\nlsb(frequency));\r\nerr |= bcm2048_send_command(bdev, BCM2048_I2C_FM_AF_FREQ1,\r\nmsb(frequency));\r\nif (!err)\r\nbdev->frequency = frequency;\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_af_frequency(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 lsb = 0, msb = 0;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_AF_FREQ0, &lsb);\r\nerr |= bcm2048_recv_command(bdev, BCM2048_I2C_FM_AF_FREQ1, &msb);\r\nmutex_unlock(&bdev->mutex);\r\nif (err)\r\nreturn err;\r\nerr = compose_u16(msb, lsb);\r\nerr += BCM2048_FREQUENCY_BASE;\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_fm_deemphasis(struct bcm2048_device *bdev, int d)\r\n{\r\nint err;\r\nu8 deemphasis;\r\nif (d == BCM2048_DE_EMPHASIS_75us)\r\ndeemphasis = BCM2048_DE_EMPHASIS_SELECT;\r\nelse\r\ndeemphasis = 0;\r\nmutex_lock(&bdev->mutex);\r\nbdev->cache_fm_audio_ctrl0 &= ~BCM2048_DE_EMPHASIS_SELECT;\r\nbdev->cache_fm_audio_ctrl0 |= deemphasis;\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_AUDIO_CTRL0,\r\nbdev->cache_fm_audio_ctrl0);\r\nif (!err)\r\nbdev->region_info.deemphasis = d;\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_deemphasis(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_AUDIO_CTRL0, &value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err) {\r\nif (value & BCM2048_DE_EMPHASIS_SELECT)\r\nreturn BCM2048_DE_EMPHASIS_75us;\r\nreturn BCM2048_DE_EMPHASIS_50us;\r\n}\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_region(struct bcm2048_device *bdev, u8 region)\r\n{\r\nint err;\r\nu32 new_frequency = 0;\r\nif (region >= ARRAY_SIZE(region_configs))\r\nreturn -EINVAL;\r\nmutex_lock(&bdev->mutex);\r\nbdev->region_info = region_configs[region];\r\nif (region_configs[region].bottom_frequency < 87500)\r\nbdev->cache_fm_ctrl |= BCM2048_BAND_SELECT;\r\nelse\r\nbdev->cache_fm_ctrl &= ~BCM2048_BAND_SELECT;\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_CTRL,\r\nbdev->cache_fm_ctrl);\r\nif (err) {\r\nmutex_unlock(&bdev->mutex);\r\ngoto done;\r\n}\r\nmutex_unlock(&bdev->mutex);\r\nif (bdev->frequency < region_configs[region].bottom_frequency ||\r\nbdev->frequency > region_configs[region].top_frequency)\r\nnew_frequency = region_configs[region].bottom_frequency;\r\nif (new_frequency > 0) {\r\nerr = bcm2048_set_fm_frequency(bdev, new_frequency);\r\nif (err)\r\ngoto done;\r\n}\r\nerr = bcm2048_set_fm_deemphasis(bdev,\r\nregion_configs[region].deemphasis);\r\ndone:\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_region(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nerr = bdev->region_info.region;\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_mute(struct bcm2048_device *bdev, u16 mute)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nbdev->cache_fm_audio_ctrl0 &= ~(BCM2048_RF_MUTE | BCM2048_MANUAL_MUTE);\r\nif (mute)\r\nbdev->cache_fm_audio_ctrl0 |= (BCM2048_RF_MUTE |\r\nBCM2048_MANUAL_MUTE);\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_AUDIO_CTRL0,\r\nbdev->cache_fm_audio_ctrl0);\r\nif (!err)\r\nbdev->mute_state = mute;\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_mute(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nif (bdev->power_state) {\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_AUDIO_CTRL0,\r\n&value);\r\nif (!err)\r\nerr = value & (BCM2048_RF_MUTE | BCM2048_MANUAL_MUTE);\r\n} else {\r\nerr = bdev->mute_state;\r\n}\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_audio_route(struct bcm2048_device *bdev, u8 route)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nroute &= (BCM2048_AUDIO_ROUTE_DAC | BCM2048_AUDIO_ROUTE_I2S);\r\nbdev->cache_fm_audio_ctrl0 &= ~(BCM2048_AUDIO_ROUTE_DAC |\r\nBCM2048_AUDIO_ROUTE_I2S);\r\nbdev->cache_fm_audio_ctrl0 |= route;\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_AUDIO_CTRL0,\r\nbdev->cache_fm_audio_ctrl0);\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_audio_route(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_AUDIO_CTRL0, &value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn value & (BCM2048_AUDIO_ROUTE_DAC |\r\nBCM2048_AUDIO_ROUTE_I2S);\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_dac_output(struct bcm2048_device *bdev, u8 channels)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nbdev->cache_fm_audio_ctrl0 &= ~(BCM2048_DAC_OUTPUT_LEFT |\r\nBCM2048_DAC_OUTPUT_RIGHT);\r\nbdev->cache_fm_audio_ctrl0 |= channels;\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_AUDIO_CTRL0,\r\nbdev->cache_fm_audio_ctrl0);\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_dac_output(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_AUDIO_CTRL0, &value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn value & (BCM2048_DAC_OUTPUT_LEFT |\r\nBCM2048_DAC_OUTPUT_RIGHT);\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_fm_search_rssi_threshold(struct bcm2048_device *bdev,\r\nu8 threshold)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nthreshold &= BCM2048_SEARCH_RSSI_THRESHOLD;\r\nbdev->cache_fm_search_ctrl0 &= ~BCM2048_SEARCH_RSSI_THRESHOLD;\r\nbdev->cache_fm_search_ctrl0 |= threshold;\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_SEARCH_CTRL0,\r\nbdev->cache_fm_search_ctrl0);\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_search_rssi_threshold(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_SEARCH_CTRL0, &value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn value & BCM2048_SEARCH_RSSI_THRESHOLD;\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_fm_search_mode_direction(struct bcm2048_device *bdev,\r\nu8 direction)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nbdev->cache_fm_search_ctrl0 &= ~BCM2048_SEARCH_DIRECTION;\r\nif (direction)\r\nbdev->cache_fm_search_ctrl0 |= BCM2048_SEARCH_DIRECTION;\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_SEARCH_CTRL0,\r\nbdev->cache_fm_search_ctrl0);\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_search_mode_direction(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_SEARCH_CTRL0, &value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err && (value & BCM2048_SEARCH_DIRECTION))\r\nreturn BCM2048_SEARCH_DIRECTION_UP;\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_fm_search_tune_mode(struct bcm2048_device *bdev,\r\nu8 mode)\r\n{\r\nint err, timeout, restart_rds = 0;\r\nu8 value, flags;\r\nvalue = mode & BCM2048_FM_AUTO_SEARCH;\r\nflags = BCM2048_FM_FLAG_SEARCH_TUNE_FINISHED |\r\nBCM2048_FM_FLAG_SEARCH_TUNE_FAIL;\r\nmutex_lock(&bdev->mutex);\r\nif (bcm2048_get_rds_no_lock(bdev)) {\r\nerr = bcm2048_set_rds_no_lock(bdev, 0);\r\nif (err)\r\ngoto unlock;\r\nrestart_rds = 1;\r\n}\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_RDS_MASK0, flags);\r\nif (err)\r\ngoto unlock;\r\nbcm2048_send_command(bdev, BCM2048_I2C_FM_SEARCH_TUNE_MODE, value);\r\nif (mode != BCM2048_FM_AUTO_SEARCH_MODE)\r\ntimeout = BCM2048_DEFAULT_TIMEOUT;\r\nelse\r\ntimeout = BCM2048_AUTO_SEARCH_TIMEOUT;\r\nif (!wait_for_completion_timeout(&bdev->compl,\r\nmsecs_to_jiffies(timeout)))\r\ndev_err(&bdev->client->dev, "IRQ timeout.\n");\r\nif (value)\r\nif (!bdev->scan_state)\r\nerr = -EIO;\r\nunlock:\r\nif (restart_rds)\r\nerr |= bcm2048_set_rds_no_lock(bdev, 1);\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_search_tune_mode(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_SEARCH_TUNE_MODE,\r\n&value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn value & BCM2048_FM_AUTO_SEARCH;\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_rds_b_block_mask(struct bcm2048_device *bdev, u16 mask)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_RDS_BLKB_MASK0,\r\nlsb(mask));\r\nerr |= bcm2048_send_command(bdev, BCM2048_I2C_RDS_BLKB_MASK1,\r\nmsb(mask));\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_rds_b_block_mask(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 lsb = 0, msb = 0;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_RDS_BLKB_MASK0, &lsb);\r\nerr |= bcm2048_recv_command(bdev, BCM2048_I2C_RDS_BLKB_MASK1, &msb);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn compose_u16(msb, lsb);\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_rds_b_block_match(struct bcm2048_device *bdev,\r\nu16 match)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_RDS_BLKB_MATCH0,\r\nlsb(match));\r\nerr |= bcm2048_send_command(bdev, BCM2048_I2C_RDS_BLKB_MATCH1,\r\nmsb(match));\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_rds_b_block_match(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 lsb = 0, msb = 0;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_RDS_BLKB_MATCH0, &lsb);\r\nerr |= bcm2048_recv_command(bdev, BCM2048_I2C_RDS_BLKB_MATCH1, &msb);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn compose_u16(msb, lsb);\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_rds_pi_mask(struct bcm2048_device *bdev, u16 mask)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_RDS_PI_MASK0, lsb(mask));\r\nerr |= bcm2048_send_command(bdev, BCM2048_I2C_RDS_PI_MASK1, msb(mask));\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_rds_pi_mask(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 lsb = 0, msb = 0;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_RDS_PI_MASK0, &lsb);\r\nerr |= bcm2048_recv_command(bdev, BCM2048_I2C_RDS_PI_MASK1, &msb);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn compose_u16(msb, lsb);\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_rds_pi_match(struct bcm2048_device *bdev, u16 match)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_RDS_PI_MATCH0,\r\nlsb(match));\r\nerr |= bcm2048_send_command(bdev, BCM2048_I2C_RDS_PI_MATCH1,\r\nmsb(match));\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_rds_pi_match(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 lsb = 0, msb = 0;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_RDS_PI_MATCH0, &lsb);\r\nerr |= bcm2048_recv_command(bdev, BCM2048_I2C_RDS_PI_MATCH1, &msb);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn compose_u16(msb, lsb);\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_fm_rds_mask(struct bcm2048_device *bdev, u16 mask)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_FM_RDS_MASK0, lsb(mask));\r\nerr |= bcm2048_send_command(bdev, BCM2048_I2C_FM_RDS_MASK1, msb(mask));\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_rds_mask(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value0 = 0, value1 = 0;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_MASK0, &value0);\r\nerr |= bcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_MASK1, &value1);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn compose_u16(value1, value0);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_rds_flags(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value0 = 0, value1 = 0;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_FLAG0, &value0);\r\nerr |= bcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_FLAG1, &value1);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn compose_u16(value1, value0);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_region_bottom_frequency(struct bcm2048_device *bdev)\r\n{\r\nreturn bdev->region_info.bottom_frequency;\r\n}\r\nstatic int bcm2048_get_region_top_frequency(struct bcm2048_device *bdev)\r\n{\r\nreturn bdev->region_info.top_frequency;\r\n}\r\nstatic int bcm2048_set_fm_best_tune_mode(struct bcm2048_device *bdev, u8 mode)\r\n{\r\nint err;\r\nu8 value = 0;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_BEST_TUNE_MODE,\r\n&value);\r\nvalue &= ~BCM2048_BEST_TUNE_MODE;\r\nif (mode)\r\nvalue |= BCM2048_BEST_TUNE_MODE;\r\nerr |= bcm2048_send_command(bdev, BCM2048_I2C_FM_BEST_TUNE_MODE,\r\nvalue);\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_best_tune_mode(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_BEST_TUNE_MODE,\r\n&value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err && (value & BCM2048_BEST_TUNE_MODE))\r\nreturn BCM2048_ITEM_ENABLED;\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_carrier_error(struct bcm2048_device *bdev)\r\n{\r\nint err = 0;\r\ns8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_CARRIER, &value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn value;\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_fm_rssi(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\ns8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_RSSI, &value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err)\r\nreturn value;\r\nreturn err;\r\n}\r\nstatic int bcm2048_set_rds_wline(struct bcm2048_device *bdev, u8 wline)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_send_command(bdev, BCM2048_I2C_RDS_WLINE, wline);\r\nif (!err)\r\nbdev->fifo_size = wline;\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_rds_wline(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 value;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_RDS_WLINE, &value);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err) {\r\nbdev->fifo_size = value;\r\nreturn value;\r\n}\r\nreturn err;\r\n}\r\nstatic int bcm2048_checkrev(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nu8 version;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_REV, &version);\r\nmutex_unlock(&bdev->mutex);\r\nif (!err) {\r\ndev_info(&bdev->client->dev, "BCM2048 Version 0x%x\n",\r\nversion);\r\nreturn version;\r\n}\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_rds_rt(struct bcm2048_device *bdev, char *data)\r\n{\r\nint err = 0, i, j = 0, ce = 0, cr = 0;\r\nchar data_buffer[BCM2048_MAX_RDS_RT + 1];\r\nmutex_lock(&bdev->mutex);\r\nif (!bdev->rds_info.text_len) {\r\nerr = -EINVAL;\r\ngoto unlock;\r\n}\r\nfor (i = 0; i < BCM2048_MAX_RDS_RT; i++) {\r\nif (bdev->rds_info.rds_rt[i]) {\r\nce = i;\r\nif (bdev->rds_info.rds_rt[i] != 0x0d) {\r\ndata_buffer[j++] = bdev->rds_info.rds_rt[i];\r\n} else {\r\ncr = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (j <= BCM2048_MAX_RDS_RT)\r\ndata_buffer[j] = 0;\r\nfor (i = 0; i < BCM2048_MAX_RDS_RT; i++) {\r\nif (!bdev->rds_info.rds_rt[i]) {\r\nif (cr && (i < cr)) {\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\nif (i < ce) {\r\nif (cr && (i >= cr))\r\nbreak;\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\n}\r\n}\r\nmemcpy(data, data_buffer, sizeof(data_buffer));\r\nunlock:\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_get_rds_ps(struct bcm2048_device *bdev, char *data)\r\n{\r\nint err = 0, i, j = 0;\r\nchar data_buffer[BCM2048_MAX_RDS_PS + 1];\r\nmutex_lock(&bdev->mutex);\r\nif (!bdev->rds_info.text_len) {\r\nerr = -EINVAL;\r\ngoto unlock;\r\n}\r\nfor (i = 0; i < BCM2048_MAX_RDS_PS; i++) {\r\nif (bdev->rds_info.rds_ps[i]) {\r\ndata_buffer[j++] = bdev->rds_info.rds_ps[i];\r\n} else {\r\nif (i < (BCM2048_MAX_RDS_PS - 1)) {\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\n}\r\n}\r\nif (j <= BCM2048_MAX_RDS_PS)\r\ndata_buffer[j] = 0;\r\nmemcpy(data, data_buffer, sizeof(data_buffer));\r\nunlock:\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic void bcm2048_parse_rds_pi(struct bcm2048_device *bdev)\r\n{\r\nint i, cnt = 0;\r\nu16 pi;\r\nfor (i = 0; i < bdev->fifo_size; i += BCM2048_RDS_FIFO_DUPLE_SIZE) {\r\nif (bdev->rds_info.radio_text[i] == BCM2048_RDS_BLOCK_A) {\r\npi = (bdev->rds_info.radio_text[i + 1] << 8) +\r\nbdev->rds_info.radio_text[i + 2];\r\nif (!bdev->rds_info.rds_pi) {\r\nbdev->rds_info.rds_pi = pi;\r\nreturn;\r\n}\r\nif (pi != bdev->rds_info.rds_pi) {\r\ncnt++;\r\nif (cnt > 3) {\r\nbdev->rds_info.rds_pi = pi;\r\ncnt = 0;\r\n}\r\n} else {\r\ncnt = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic int bcm2048_rds_block_crc(struct bcm2048_device *bdev, int i)\r\n{\r\nreturn bdev->rds_info.radio_text[i] & BCM2048_RDS_CRC_MASK;\r\n}\r\nstatic void bcm2048_parse_rds_rt_block(struct bcm2048_device *bdev, int i,\r\nint index, int crc)\r\n{\r\nif (crc) {\r\nif (!bdev->rds_info.rds_rt[index])\r\nbdev->rds_info.rds_rt[index] =\r\nbdev->rds_info.radio_text[i + 1];\r\nif (!bdev->rds_info.rds_rt[index + 1])\r\nbdev->rds_info.rds_rt[index + 1] =\r\nbdev->rds_info.radio_text[i + 2];\r\n} else {\r\nbdev->rds_info.rds_rt[index] =\r\nbdev->rds_info.radio_text[i + 1];\r\nbdev->rds_info.rds_rt[index + 1] =\r\nbdev->rds_info.radio_text[i + 2];\r\n}\r\n}\r\nstatic int bcm2048_parse_rt_match_b(struct bcm2048_device *bdev, int i)\r\n{\r\nint crc, rt_id, rt_group_b, rt_ab, index = 0;\r\ncrc = bcm2048_rds_block_crc(bdev, i);\r\nif (crc == BCM2048_RDS_CRC_UNRECOVARABLE)\r\nreturn -EIO;\r\nif ((bdev->rds_info.radio_text[i] & BCM2048_RDS_BLOCK_MASK) ==\r\nBCM2048_RDS_BLOCK_B) {\r\nrt_id = bdev->rds_info.radio_text[i + 1] &\r\nBCM2048_RDS_BLOCK_MASK;\r\nrt_group_b = bdev->rds_info.radio_text[i + 1] &\r\nBCM2048_RDS_GROUP_AB_MASK;\r\nrt_ab = bdev->rds_info.radio_text[i + 2] &\r\nBCM2048_RDS_RT_AB_MASK;\r\nif (rt_group_b != bdev->rds_info.rds_rt_group_b) {\r\nmemset(bdev->rds_info.rds_rt, 0,\r\nsizeof(bdev->rds_info.rds_rt));\r\nbdev->rds_info.rds_rt_group_b = rt_group_b;\r\n}\r\nif (rt_id == BCM2048_RDS_RT) {\r\nif (rt_ab != bdev->rds_info.rds_rt_ab) {\r\nmemset(bdev->rds_info.rds_rt, 0,\r\nsizeof(bdev->rds_info.rds_rt));\r\nbdev->rds_info.rds_rt_ab = rt_ab;\r\n}\r\nindex = bdev->rds_info.radio_text[i + 2] &\r\nBCM2048_RDS_RT_INDEX;\r\nif (bdev->rds_info.rds_rt_group_b)\r\nindex <<= 1;\r\nelse\r\nindex <<= 2;\r\nreturn index;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int bcm2048_parse_rt_match_c(struct bcm2048_device *bdev, int i,\r\nint index)\r\n{\r\nint crc;\r\ncrc = bcm2048_rds_block_crc(bdev, i);\r\nif (crc == BCM2048_RDS_CRC_UNRECOVARABLE)\r\nreturn 0;\r\nBUG_ON((index+2) >= BCM2048_MAX_RDS_RT);\r\nif ((bdev->rds_info.radio_text[i] & BCM2048_RDS_BLOCK_MASK) ==\r\nBCM2048_RDS_BLOCK_C) {\r\nif (bdev->rds_info.rds_rt_group_b)\r\nreturn 1;\r\nbcm2048_parse_rds_rt_block(bdev, i, index, crc);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcm2048_parse_rt_match_d(struct bcm2048_device *bdev, int i,\r\nint index)\r\n{\r\nint crc;\r\ncrc = bcm2048_rds_block_crc(bdev, i);\r\nif (crc == BCM2048_RDS_CRC_UNRECOVARABLE)\r\nreturn;\r\nBUG_ON((index+4) >= BCM2048_MAX_RDS_RT);\r\nif ((bdev->rds_info.radio_text[i] & BCM2048_RDS_BLOCK_MASK) ==\r\nBCM2048_RDS_BLOCK_D)\r\nbcm2048_parse_rds_rt_block(bdev, i, index + 2, crc);\r\n}\r\nstatic void bcm2048_parse_rds_rt(struct bcm2048_device *bdev)\r\n{\r\nint i, index = 0, crc, match_b = 0, match_c = 0, match_d = 0;\r\nfor (i = 0; i < bdev->fifo_size; i += BCM2048_RDS_FIFO_DUPLE_SIZE) {\r\nif (match_b) {\r\nmatch_b = 0;\r\nindex = bcm2048_parse_rt_match_b(bdev, i);\r\nif (index >= 0 && index <= (BCM2048_MAX_RDS_RT - 5))\r\nmatch_c = 1;\r\ncontinue;\r\n} else if (match_c) {\r\nmatch_c = 0;\r\nif (bcm2048_parse_rt_match_c(bdev, i, index))\r\nmatch_d = 1;\r\ncontinue;\r\n} else if (match_d) {\r\nmatch_d = 0;\r\nbcm2048_parse_rt_match_d(bdev, i, index);\r\ncontinue;\r\n}\r\nif ((bdev->rds_info.radio_text[i] & BCM2048_RDS_BLOCK_MASK) ==\r\nBCM2048_RDS_BLOCK_A) {\r\ncrc = bcm2048_rds_block_crc(bdev, i);\r\nif (crc == BCM2048_RDS_CRC_UNRECOVARABLE)\r\ncontinue;\r\nif (((bdev->rds_info.radio_text[i + 1] << 8) +\r\nbdev->rds_info.radio_text[i + 2]) ==\r\nbdev->rds_info.rds_pi)\r\nmatch_b = 1;\r\n}\r\n}\r\n}\r\nstatic void bcm2048_parse_rds_ps_block(struct bcm2048_device *bdev, int i,\r\nint index, int crc)\r\n{\r\nif (crc) {\r\nif (!bdev->rds_info.rds_ps[index])\r\nbdev->rds_info.rds_ps[index] =\r\nbdev->rds_info.radio_text[i + 1];\r\nif (!bdev->rds_info.rds_ps[index + 1])\r\nbdev->rds_info.rds_ps[index + 1] =\r\nbdev->rds_info.radio_text[i + 2];\r\n} else {\r\nbdev->rds_info.rds_ps[index] =\r\nbdev->rds_info.radio_text[i + 1];\r\nbdev->rds_info.rds_ps[index + 1] =\r\nbdev->rds_info.radio_text[i + 2];\r\n}\r\n}\r\nstatic int bcm2048_parse_ps_match_c(struct bcm2048_device *bdev, int i,\r\nint index)\r\n{\r\nint crc;\r\ncrc = bcm2048_rds_block_crc(bdev, i);\r\nif (crc == BCM2048_RDS_CRC_UNRECOVARABLE)\r\nreturn 0;\r\nif ((bdev->rds_info.radio_text[i] & BCM2048_RDS_BLOCK_MASK) ==\r\nBCM2048_RDS_BLOCK_C)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void bcm2048_parse_ps_match_d(struct bcm2048_device *bdev, int i,\r\nint index)\r\n{\r\nint crc;\r\ncrc = bcm2048_rds_block_crc(bdev, i);\r\nif (crc == BCM2048_RDS_CRC_UNRECOVARABLE)\r\nreturn;\r\nif ((bdev->rds_info.radio_text[i] & BCM2048_RDS_BLOCK_MASK) ==\r\nBCM2048_RDS_BLOCK_D)\r\nbcm2048_parse_rds_ps_block(bdev, i, index, crc);\r\n}\r\nstatic int bcm2048_parse_ps_match_b(struct bcm2048_device *bdev, int i)\r\n{\r\nint crc, index, ps_id, ps_group;\r\ncrc = bcm2048_rds_block_crc(bdev, i);\r\nif (crc == BCM2048_RDS_CRC_UNRECOVARABLE)\r\nreturn -EIO;\r\nif ((bdev->rds_info.radio_text[i] & BCM2048_RDS_BLOCK_MASK) ==\r\nBCM2048_RDS_BLOCK_B) {\r\nps_id = bdev->rds_info.radio_text[i + 1] &\r\nBCM2048_RDS_BLOCK_MASK;\r\nps_group = bdev->rds_info.radio_text[i + 1] &\r\nBCM2048_RDS_GROUP_AB_MASK;\r\nif (ps_group != bdev->rds_info.rds_ps_group) {\r\nif (crc == BCM2048_RDS_CRC_NONE) {\r\nbdev->rds_info.rds_ps_group_cnt++;\r\nif (bdev->rds_info.rds_ps_group_cnt > 2) {\r\nbdev->rds_info.rds_ps_group = ps_group;\r\nbdev->rds_info.rds_ps_group_cnt = 0;\r\ndev_err(&bdev->client->dev,\r\n"RDS PS Group change!\n");\r\n} else {\r\nreturn -EIO;\r\n}\r\n} else {\r\nbdev->rds_info.rds_ps_group_cnt = 0;\r\n}\r\n}\r\nif (ps_id == BCM2048_RDS_PS) {\r\nindex = bdev->rds_info.radio_text[i + 2] &\r\nBCM2048_RDS_PS_INDEX;\r\nindex <<= 1;\r\nreturn index;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void bcm2048_parse_rds_ps(struct bcm2048_device *bdev)\r\n{\r\nint i, index = 0, crc, match_b = 0, match_c = 0, match_d = 0;\r\nfor (i = 0; i < bdev->fifo_size; i += BCM2048_RDS_FIFO_DUPLE_SIZE) {\r\nif (match_b) {\r\nmatch_b = 0;\r\nindex = bcm2048_parse_ps_match_b(bdev, i);\r\nif (index >= 0 && index < (BCM2048_MAX_RDS_PS - 1))\r\nmatch_c = 1;\r\ncontinue;\r\n} else if (match_c) {\r\nmatch_c = 0;\r\nif (bcm2048_parse_ps_match_c(bdev, i, index))\r\nmatch_d = 1;\r\ncontinue;\r\n} else if (match_d) {\r\nmatch_d = 0;\r\nbcm2048_parse_ps_match_d(bdev, i, index);\r\ncontinue;\r\n}\r\nif ((bdev->rds_info.radio_text[i] & BCM2048_RDS_BLOCK_MASK) ==\r\nBCM2048_RDS_BLOCK_A) {\r\ncrc = bcm2048_rds_block_crc(bdev, i);\r\nif (crc == BCM2048_RDS_CRC_UNRECOVARABLE)\r\ncontinue;\r\nif (((bdev->rds_info.radio_text[i + 1] << 8) +\r\nbdev->rds_info.radio_text[i + 2]) ==\r\nbdev->rds_info.rds_pi)\r\nmatch_b = 1;\r\n}\r\n}\r\n}\r\nstatic void bcm2048_rds_fifo_receive(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nmutex_lock(&bdev->mutex);\r\nerr = bcm2048_recv_duples(bdev, BCM2048_I2C_RDS_DATA,\r\nbdev->rds_info.radio_text, bdev->fifo_size);\r\nif (err != 2) {\r\ndev_err(&bdev->client->dev, "RDS Read problem\n");\r\nmutex_unlock(&bdev->mutex);\r\nreturn;\r\n}\r\nbdev->rds_info.text_len = bdev->fifo_size;\r\nbcm2048_parse_rds_pi(bdev);\r\nbcm2048_parse_rds_rt(bdev);\r\nbcm2048_parse_rds_ps(bdev);\r\nmutex_unlock(&bdev->mutex);\r\nwake_up_interruptible(&bdev->read_queue);\r\n}\r\nstatic int bcm2048_get_rds_data(struct bcm2048_device *bdev, char *data)\r\n{\r\nint err = 0, i, p = 0;\r\nchar *data_buffer;\r\nmutex_lock(&bdev->mutex);\r\nif (!bdev->rds_info.text_len) {\r\nerr = -EINVAL;\r\ngoto unlock;\r\n}\r\ndata_buffer = kcalloc(BCM2048_MAX_RDS_RADIO_TEXT, 5, GFP_KERNEL);\r\nif (!data_buffer) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nfor (i = 0; i < bdev->rds_info.text_len; i++) {\r\np += sprintf(data_buffer + p, "%x ",\r\nbdev->rds_info.radio_text[i]);\r\n}\r\nmemcpy(data, data_buffer, p);\r\nkfree(data_buffer);\r\nunlock:\r\nmutex_unlock(&bdev->mutex);\r\nreturn err;\r\n}\r\nstatic int bcm2048_init(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nerr = bcm2048_set_power_state(bdev, BCM2048_POWER_ON);\r\nif (err < 0)\r\ngoto exit;\r\nerr = bcm2048_set_audio_route(bdev, BCM2048_AUDIO_ROUTE_DAC);\r\nif (err < 0)\r\ngoto exit;\r\nerr = bcm2048_set_dac_output(bdev, BCM2048_DAC_OUTPUT_LEFT |\r\nBCM2048_DAC_OUTPUT_RIGHT);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int bcm2048_deinit(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nerr = bcm2048_set_audio_route(bdev, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = bcm2048_set_dac_output(bdev, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = bcm2048_set_power_state(bdev, BCM2048_POWER_OFF);\r\nreturn err;\r\n}\r\nstatic int bcm2048_probe(struct bcm2048_device *bdev)\r\n{\r\nint err;\r\nerr = bcm2048_set_power_state(bdev, BCM2048_POWER_ON);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = bcm2048_checkrev(bdev);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = bcm2048_set_mute(bdev, BCM2048_DEFAULT_MUTE);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = bcm2048_set_region(bdev, BCM2048_DEFAULT_REGION);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = bcm2048_set_fm_search_rssi_threshold(bdev,\r\nBCM2048_DEFAULT_RSSI_THRESHOLD);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = bcm2048_set_fm_automatic_stereo_mono(bdev, BCM2048_ITEM_ENABLED);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = bcm2048_get_rds_wline(bdev);\r\nif (err < BCM2048_DEFAULT_RDS_WLINE)\r\nerr = bcm2048_set_rds_wline(bdev, BCM2048_DEFAULT_RDS_WLINE);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = bcm2048_set_power_state(bdev, BCM2048_POWER_OFF);\r\ninit_waitqueue_head(&bdev->read_queue);\r\nbdev->rds_data_available = 0;\r\nbdev->rd_index = 0;\r\nbdev->users = 0;\r\nunlock:\r\nreturn err;\r\n}\r\nstatic void bcm2048_work(struct work_struct *work)\r\n{\r\nstruct bcm2048_device *bdev;\r\nu8 flag_lsb = 0, flag_msb = 0, flags;\r\nbdev = container_of(work, struct bcm2048_device, work);\r\nbcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_FLAG0, &flag_lsb);\r\nbcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_FLAG1, &flag_msb);\r\nif (flag_lsb & (BCM2048_FM_FLAG_SEARCH_TUNE_FINISHED |\r\nBCM2048_FM_FLAG_SEARCH_TUNE_FAIL)) {\r\nif (flag_lsb & BCM2048_FM_FLAG_SEARCH_TUNE_FAIL)\r\nbdev->scan_state = BCM2048_SCAN_FAIL;\r\nelse\r\nbdev->scan_state = BCM2048_SCAN_OK;\r\ncomplete(&bdev->compl);\r\n}\r\nif (flag_msb & BCM2048_RDS_FLAG_FIFO_WLINE) {\r\nbcm2048_rds_fifo_receive(bdev);\r\nif (bdev->rds_state) {\r\nflags = BCM2048_RDS_FLAG_FIFO_WLINE;\r\nbcm2048_send_command(bdev, BCM2048_I2C_FM_RDS_MASK1,\r\nflags);\r\n}\r\nbdev->rds_data_available = 1;\r\nbdev->rd_index = 0;\r\n}\r\n}\r\nstatic irqreturn_t bcm2048_handler(int irq, void *dev)\r\n{\r\nstruct bcm2048_device *bdev = dev;\r\ndev_dbg(&bdev->client->dev, "IRQ called, queuing work\n");\r\nif (bdev->power_state)\r\nschedule_work(&bdev->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm2048_sysfs_unregister_properties(struct bcm2048_device *bdev,\r\nint size)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++)\r\ndevice_remove_file(&bdev->client->dev, &attrs[i]);\r\nreturn 0;\r\n}\r\nstatic int bcm2048_sysfs_register_properties(struct bcm2048_device *bdev)\r\n{\r\nint err = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(attrs); i++) {\r\nif (device_create_file(&bdev->client->dev, &attrs[i]) != 0) {\r\ndev_err(&bdev->client->dev,\r\n"could not register sysfs entry\n");\r\nerr = -EBUSY;\r\nbcm2048_sysfs_unregister_properties(bdev, i);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int bcm2048_fops_open(struct file *file)\r\n{\r\nstruct bcm2048_device *bdev = video_drvdata(file);\r\nbdev->users++;\r\nbdev->rd_index = 0;\r\nbdev->rds_data_available = 0;\r\nreturn 0;\r\n}\r\nstatic int bcm2048_fops_release(struct file *file)\r\n{\r\nstruct bcm2048_device *bdev = video_drvdata(file);\r\nbdev->users--;\r\nreturn 0;\r\n}\r\nstatic unsigned int bcm2048_fops_poll(struct file *file,\r\nstruct poll_table_struct *pts)\r\n{\r\nstruct bcm2048_device *bdev = video_drvdata(file);\r\nint retval = 0;\r\npoll_wait(file, &bdev->read_queue, pts);\r\nif (bdev->rds_data_available)\r\nretval = POLLIN | POLLRDNORM;\r\nreturn retval;\r\n}\r\nstatic ssize_t bcm2048_fops_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct bcm2048_device *bdev = video_drvdata(file);\r\nint i;\r\nint retval = 0;\r\ncount = (count / 3) * 3;\r\nif (count < 3)\r\nreturn -ENOBUFS;\r\nwhile (!bdev->rds_data_available) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EWOULDBLOCK;\r\ngoto done;\r\n}\r\nif (wait_event_interruptible(bdev->read_queue,\r\nbdev->rds_data_available) < 0) {\r\nretval = -EINTR;\r\ngoto done;\r\n}\r\n}\r\nmutex_lock(&bdev->mutex);\r\ni = bdev->fifo_size - bdev->rd_index;\r\nif (count > i)\r\ncount = (i / 3) * 3;\r\ni = 0;\r\nwhile (i < count) {\r\nunsigned char tmpbuf[3];\r\ntmpbuf[i] = bdev->rds_info.radio_text[bdev->rd_index + i + 2];\r\ntmpbuf[i + 1] =\r\nbdev->rds_info.radio_text[bdev->rd_index + i + 1];\r\ntmpbuf[i + 2] =\r\n(bdev->rds_info.radio_text[bdev->rd_index + i] &\r\n0xf0) >> 4;\r\nif ((bdev->rds_info.radio_text[bdev->rd_index + i] &\r\nBCM2048_RDS_CRC_MASK) == BCM2048_RDS_CRC_UNRECOVARABLE)\r\ntmpbuf[i + 2] |= 0x80;\r\nif (copy_to_user(buf + i, tmpbuf, 3)) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\ni += 3;\r\n}\r\nbdev->rd_index += i;\r\nif (bdev->rd_index >= bdev->fifo_size)\r\nbdev->rds_data_available = 0;\r\nmutex_unlock(&bdev->mutex);\r\nif (retval == 0)\r\nretval = i;\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int bcm2048_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *capability)\r\n{\r\nstruct bcm2048_device *bdev = video_get_drvdata(video_devdata(file));\r\nstrlcpy(capability->driver, BCM2048_DRIVER_NAME,\r\nsizeof(capability->driver));\r\nstrlcpy(capability->card, BCM2048_DRIVER_CARD,\r\nsizeof(capability->card));\r\nsnprintf(capability->bus_info, 32, "I2C: 0x%X", bdev->client->addr);\r\ncapability->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |\r\nV4L2_CAP_HW_FREQ_SEEK;\r\ncapability->capabilities = capability->device_caps |\r\nV4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int bcm2048_vidioc_g_input(struct file *filp, void *priv,\r\nunsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int bcm2048_vidioc_s_input(struct file *filp, void *priv,\r\nunsigned int i)\r\n{\r\nif (i)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int bcm2048_vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(bcm2048_v4l2_queryctrl); i++) {\r\nif (qc->id && qc->id == bcm2048_v4l2_queryctrl[i].id) {\r\n*qc = bcm2048_v4l2_queryctrl[i];\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bcm2048_vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct bcm2048_device *bdev = video_get_drvdata(video_devdata(file));\r\nint err = 0;\r\nif (!bdev)\r\nreturn -ENODEV;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nerr = bcm2048_get_mute(bdev);\r\nif (err >= 0)\r\nctrl->value = err;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int bcm2048_vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct bcm2048_device *bdev = video_get_drvdata(video_devdata(file));\r\nint err = 0;\r\nif (!bdev)\r\nreturn -ENODEV;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->value) {\r\nif (bdev->power_state) {\r\nerr = bcm2048_set_mute(bdev, ctrl->value);\r\nerr |= bcm2048_deinit(bdev);\r\n}\r\n} else {\r\nif (!bdev->power_state) {\r\nerr = bcm2048_init(bdev);\r\nerr |= bcm2048_set_mute(bdev, ctrl->value);\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int bcm2048_vidioc_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *audio)\r\n{\r\nif (audio->index > 1)\r\nreturn -EINVAL;\r\nstrncpy(audio->name, "Radio", 32);\r\naudio->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int bcm2048_vidioc_s_audio(struct file *file, void *priv,\r\nconst struct v4l2_audio *audio)\r\n{\r\nif (audio->index != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int bcm2048_vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *tuner)\r\n{\r\nstruct bcm2048_device *bdev = video_get_drvdata(video_devdata(file));\r\ns8 f_error;\r\ns8 rssi;\r\nif (!bdev)\r\nreturn -ENODEV;\r\nif (tuner->index > 0)\r\nreturn -EINVAL;\r\nstrncpy(tuner->name, "FM Receiver", 32);\r\ntuner->type = V4L2_TUNER_RADIO;\r\ntuner->rangelow =\r\ndev_to_v4l2(bcm2048_get_region_bottom_frequency(bdev));\r\ntuner->rangehigh =\r\ndev_to_v4l2(bcm2048_get_region_top_frequency(bdev));\r\ntuner->rxsubchans = V4L2_TUNER_SUB_STEREO;\r\ntuner->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW;\r\ntuner->audmode = V4L2_TUNER_MODE_STEREO;\r\ntuner->afc = 0;\r\nif (bdev->power_state) {\r\nf_error = bcm2048_get_fm_carrier_error(bdev);\r\nif (f_error < BCM2048_FREQ_ERROR_FLOOR ||\r\nf_error > BCM2048_FREQ_ERROR_ROOF) {\r\ntuner->signal = 0;\r\n} else {\r\nrssi = bcm2048_get_fm_rssi(bdev);\r\nif (rssi >= BCM2048_RSSI_LEVEL_BASE) {\r\ntuner->signal = 0xFFFF;\r\n} else if (rssi > BCM2048_RSSI_LEVEL_ROOF) {\r\ntuner->signal = (rssi +\r\nBCM2048_RSSI_LEVEL_ROOF_NEG)\r\n* BCM2048_SIGNAL_MULTIPLIER;\r\n} else {\r\ntuner->signal = 0;\r\n}\r\n}\r\n} else {\r\ntuner->signal = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm2048_vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *tuner)\r\n{\r\nstruct bcm2048_device *bdev = video_get_drvdata(video_devdata(file));\r\nif (!bdev)\r\nreturn -ENODEV;\r\nif (tuner->index > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int bcm2048_vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *freq)\r\n{\r\nstruct bcm2048_device *bdev = video_get_drvdata(video_devdata(file));\r\nint err = 0;\r\nint f;\r\nif (!bdev->power_state)\r\nreturn -ENODEV;\r\nfreq->type = V4L2_TUNER_RADIO;\r\nf = bcm2048_get_fm_frequency(bdev);\r\nif (f < 0)\r\nerr = f;\r\nelse\r\nfreq->frequency = dev_to_v4l2(f);\r\nreturn err;\r\n}\r\nstatic int bcm2048_vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *freq)\r\n{\r\nstruct bcm2048_device *bdev = video_get_drvdata(video_devdata(file));\r\nint err;\r\nif (freq->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nif (!bdev->power_state)\r\nreturn -ENODEV;\r\nerr = bcm2048_set_fm_frequency(bdev, v4l2_to_dev(freq->frequency));\r\nerr |= bcm2048_set_fm_search_tune_mode(bdev, BCM2048_FM_PRE_SET_MODE);\r\nreturn err;\r\n}\r\nstatic int bcm2048_vidioc_s_hw_freq_seek(struct file *file, void *priv,\r\nconst struct v4l2_hw_freq_seek *seek)\r\n{\r\nstruct bcm2048_device *bdev = video_get_drvdata(video_devdata(file));\r\nint err;\r\nif (!bdev->power_state)\r\nreturn -ENODEV;\r\nif ((seek->tuner != 0) || (seek->type != V4L2_TUNER_RADIO))\r\nreturn -EINVAL;\r\nerr = bcm2048_set_fm_search_mode_direction(bdev, seek->seek_upward);\r\nerr |= bcm2048_set_fm_search_tune_mode(bdev,\r\nBCM2048_FM_AUTO_SEARCH_MODE);\r\nreturn err;\r\n}\r\nstatic int bcm2048_i2c_driver_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct bcm2048_device *bdev;\r\nint err;\r\nbdev = kzalloc(sizeof(*bdev), GFP_KERNEL);\r\nif (!bdev) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\nbdev->client = client;\r\ni2c_set_clientdata(client, bdev);\r\nmutex_init(&bdev->mutex);\r\ninit_completion(&bdev->compl);\r\nINIT_WORK(&bdev->work, bcm2048_work);\r\nif (client->irq) {\r\nerr = request_irq(client->irq,\r\nbcm2048_handler, IRQF_TRIGGER_FALLING,\r\nclient->name, bdev);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Could not request IRQ\n");\r\ngoto free_bdev;\r\n}\r\ndev_dbg(&client->dev, "IRQ requested.\n");\r\n} else {\r\ndev_dbg(&client->dev, "IRQ not configured. Using timeouts.\n");\r\n}\r\nbdev->videodev = bcm2048_viddev_template;\r\nvideo_set_drvdata(&bdev->videodev, bdev);\r\nif (video_register_device(&bdev->videodev, VFL_TYPE_RADIO, radio_nr)) {\r\ndev_dbg(&client->dev, "Could not register video device.\n");\r\nerr = -EIO;\r\ngoto free_irq;\r\n}\r\nerr = bcm2048_sysfs_register_properties(bdev);\r\nif (err < 0) {\r\ndev_dbg(&client->dev, "Could not register sysfs interface.\n");\r\ngoto free_registration;\r\n}\r\nerr = bcm2048_probe(bdev);\r\nif (err < 0) {\r\ndev_dbg(&client->dev, "Failed to probe device information.\n");\r\ngoto free_sysfs;\r\n}\r\nreturn 0;\r\nfree_sysfs:\r\nbcm2048_sysfs_unregister_properties(bdev, ARRAY_SIZE(attrs));\r\nfree_registration:\r\nvideo_unregister_device(&bdev->videodev);\r\nfree_irq:\r\nif (client->irq)\r\nfree_irq(client->irq, bdev);\r\nfree_bdev:\r\ni2c_set_clientdata(client, NULL);\r\nkfree(bdev);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __exit bcm2048_i2c_driver_remove(struct i2c_client *client)\r\n{\r\nstruct bcm2048_device *bdev = i2c_get_clientdata(client);\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\nif (bdev) {\r\nbcm2048_sysfs_unregister_properties(bdev, ARRAY_SIZE(attrs));\r\nvideo_unregister_device(&bdev->videodev);\r\nif (bdev->power_state)\r\nbcm2048_set_power_state(bdev, BCM2048_POWER_OFF);\r\nif (client->irq > 0)\r\nfree_irq(client->irq, bdev);\r\ncancel_work_sync(&bdev->work);\r\nkfree(bdev);\r\n}\r\nreturn 0;\r\n}
