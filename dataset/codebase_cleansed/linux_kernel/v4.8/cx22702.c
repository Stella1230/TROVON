static int cx22702_writereg(struct cx22702_state *state, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {\r\n.addr = state->config->demod_address, .flags = 0,\r\n.buf = buf, .len = 2 };\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (unlikely(ret != 1)) {\r\nprintk(KERN_ERR\r\n"%s: error (reg == 0x%02x, val == 0x%02x, ret == %i)\n",\r\n__func__, reg, data, ret);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 cx22702_readreg(struct cx22702_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 data;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->config->demod_address, .flags = 0,\r\n.buf = &reg, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD,\r\n.buf = &data, .len = 1 } };\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (unlikely(ret != 2)) {\r\nprintk(KERN_ERR "%s: error (reg == 0x%02x, ret == %i)\n",\r\n__func__, reg, ret);\r\nreturn 0;\r\n}\r\nreturn data;\r\n}\r\nstatic int cx22702_set_inversion(struct cx22702_state *state, int inversion)\r\n{\r\nu8 val;\r\nval = cx22702_readreg(state, 0x0C);\r\nswitch (inversion) {\r\ncase INVERSION_AUTO:\r\nreturn -EOPNOTSUPP;\r\ncase INVERSION_ON:\r\nval |= 0x01;\r\nbreak;\r\ncase INVERSION_OFF:\r\nval &= 0xfe;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn cx22702_writereg(state, 0x0C, val);\r\n}\r\nstatic int cx22702_get_tps(struct cx22702_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nu8 val;\r\nif (!(cx22702_readreg(state, 0x0A) & 0x20))\r\nreturn -EAGAIN;\r\nval = cx22702_readreg(state, 0x01);\r\nswitch ((val & 0x18) >> 3) {\r\ncase 0:\r\np->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\np->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\np->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch (val & 0x07) {\r\ncase 0:\r\np->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\np->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\np->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\np->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nval = cx22702_readreg(state, 0x02);\r\nswitch ((val & 0x38) >> 3) {\r\ncase 0:\r\np->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\np->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\np->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\np->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\np->code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch (val & 0x07) {\r\ncase 0:\r\np->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\np->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\np->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\np->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\np->code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nval = cx22702_readreg(state, 0x03);\r\nswitch ((val & 0x0c) >> 2) {\r\ncase 0:\r\np->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\np->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\np->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\np->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch (val & 0x03) {\r\ncase 0:\r\np->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\np->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx22702_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct cx22702_state *state = fe->demodulator_priv;\r\nu8 val;\r\ndprintk("%s(%d)\n", __func__, enable);\r\nval = cx22702_readreg(state, 0x0D);\r\nif (enable)\r\nval &= 0xfe;\r\nelse\r\nval |= 0x01;\r\nreturn cx22702_writereg(state, 0x0D, val);\r\n}\r\nstatic int cx22702_set_tps(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nu8 val;\r\nstruct cx22702_state *state = fe->demodulator_priv;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\ncx22702_set_inversion(state, p->inversion);\r\nval = cx22702_readreg(state, 0x0C) & 0xcf;\r\nswitch (p->bandwidth_hz) {\r\ncase 6000000:\r\nval |= 0x20;\r\nbreak;\r\ncase 7000000:\r\nval |= 0x10;\r\nbreak;\r\ncase 8000000:\r\nbreak;\r\ndefault:\r\ndprintk("%s: invalid bandwidth\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ncx22702_writereg(state, 0x0C, val);\r\np->code_rate_LP = FEC_AUTO;\r\nif ((p->hierarchy == HIERARCHY_AUTO) ||\r\n(p->modulation == QAM_AUTO) ||\r\n(p->code_rate_HP == FEC_AUTO) ||\r\n(p->code_rate_LP == FEC_AUTO) ||\r\n(p->guard_interval == GUARD_INTERVAL_AUTO) ||\r\n(p->transmission_mode == TRANSMISSION_MODE_AUTO)) {\r\ncx22702_writereg(state, 0x06, 0x10);\r\ncx22702_writereg(state, 0x07, 0x9);\r\ncx22702_writereg(state, 0x08, 0xC1);\r\ncx22702_writereg(state, 0x0B, cx22702_readreg(state, 0x0B)\r\n& 0xfc);\r\ncx22702_writereg(state, 0x0C,\r\n(cx22702_readreg(state, 0x0C) & 0xBF) | 0x40);\r\ncx22702_writereg(state, 0x00, 0x01);\r\ndprintk("%s: Autodetecting\n", __func__);\r\nreturn 0;\r\n}\r\nswitch (p->modulation) {\r\ncase QPSK:\r\nval = 0x00;\r\nbreak;\r\ncase QAM_16:\r\nval = 0x08;\r\nbreak;\r\ncase QAM_64:\r\nval = 0x10;\r\nbreak;\r\ndefault:\r\ndprintk("%s: invalid modulation\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (p->hierarchy) {\r\ncase HIERARCHY_NONE:\r\nbreak;\r\ncase HIERARCHY_1:\r\nval |= 0x01;\r\nbreak;\r\ncase HIERARCHY_2:\r\nval |= 0x02;\r\nbreak;\r\ncase HIERARCHY_4:\r\nval |= 0x03;\r\nbreak;\r\ndefault:\r\ndprintk("%s: invalid hierarchy\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ncx22702_writereg(state, 0x06, val);\r\nswitch (p->code_rate_HP) {\r\ncase FEC_NONE:\r\ncase FEC_1_2:\r\nval = 0x00;\r\nbreak;\r\ncase FEC_2_3:\r\nval = 0x08;\r\nbreak;\r\ncase FEC_3_4:\r\nval = 0x10;\r\nbreak;\r\ncase FEC_5_6:\r\nval = 0x18;\r\nbreak;\r\ncase FEC_7_8:\r\nval = 0x20;\r\nbreak;\r\ndefault:\r\ndprintk("%s: invalid code_rate_HP\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (p->code_rate_LP) {\r\ncase FEC_NONE:\r\ncase FEC_1_2:\r\nbreak;\r\ncase FEC_2_3:\r\nval |= 0x01;\r\nbreak;\r\ncase FEC_3_4:\r\nval |= 0x02;\r\nbreak;\r\ncase FEC_5_6:\r\nval |= 0x03;\r\nbreak;\r\ncase FEC_7_8:\r\nval |= 0x04;\r\nbreak;\r\ndefault:\r\ndprintk("%s: invalid code_rate_LP\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ncx22702_writereg(state, 0x07, val);\r\nswitch (p->guard_interval) {\r\ncase GUARD_INTERVAL_1_32:\r\nval = 0x00;\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\nval = 0x04;\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\nval = 0x08;\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\nval = 0x0c;\r\nbreak;\r\ndefault:\r\ndprintk("%s: invalid guard_interval\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (p->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nbreak;\r\ncase TRANSMISSION_MODE_8K:\r\nval |= 0x1;\r\nbreak;\r\ndefault:\r\ndprintk("%s: invalid transmission_mode\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ncx22702_writereg(state, 0x08, val);\r\ncx22702_writereg(state, 0x0B,\r\n(cx22702_readreg(state, 0x0B) & 0xfc) | 0x02);\r\ncx22702_writereg(state, 0x0C,\r\n(cx22702_readreg(state, 0x0C) & 0xBF) | 0x40);\r\ncx22702_writereg(state, 0x00, 0x01);\r\nreturn 0;\r\n}\r\nstatic int cx22702_init(struct dvb_frontend *fe)\r\n{\r\nint i;\r\nstruct cx22702_state *state = fe->demodulator_priv;\r\ncx22702_writereg(state, 0x00, 0x02);\r\nmsleep(10);\r\nfor (i = 0; i < ARRAY_SIZE(init_tab); i += 2)\r\ncx22702_writereg(state, init_tab[i], init_tab[i + 1]);\r\ncx22702_writereg(state, 0xf8, (state->config->output_mode << 1)\r\n& 0x02);\r\ncx22702_i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int cx22702_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct cx22702_state *state = fe->demodulator_priv;\r\nu8 reg0A;\r\nu8 reg23;\r\n*status = 0;\r\nreg0A = cx22702_readreg(state, 0x0A);\r\nreg23 = cx22702_readreg(state, 0x23);\r\ndprintk("%s: status demod=0x%02x agc=0x%02x\n"\r\n, __func__, reg0A, reg23);\r\nif (reg0A & 0x10) {\r\n*status |= FE_HAS_LOCK;\r\n*status |= FE_HAS_VITERBI;\r\n*status |= FE_HAS_SYNC;\r\n}\r\nif (reg0A & 0x20)\r\n*status |= FE_HAS_CARRIER;\r\nif (reg23 < 0xf0)\r\n*status |= FE_HAS_SIGNAL;\r\nreturn 0;\r\n}\r\nstatic int cx22702_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct cx22702_state *state = fe->demodulator_priv;\r\nif (cx22702_readreg(state, 0xE4) & 0x02) {\r\n*ber = (cx22702_readreg(state, 0xDE) & 0x7F) << 7\r\n| (cx22702_readreg(state, 0xDF) & 0x7F);\r\n} else {\r\n*ber = (cx22702_readreg(state, 0xDE) & 0x7F) << 7\r\n| cx22702_readreg(state, 0xDF);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx22702_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nstruct cx22702_state *state = fe->demodulator_priv;\r\nu8 reg23;\r\nreg23 = cx22702_readreg(state, 0x23);\r\nif (reg23 & 0x80) {\r\n*signal_strength = 0;\r\n} else {\r\nreg23 = ~reg23 & 0x7f;\r\n*signal_strength = (reg23 << 9) | (reg23 << 2) | (reg23 >> 5);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx22702_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct cx22702_state *state = fe->demodulator_priv;\r\nu16 rs_ber;\r\nif (cx22702_readreg(state, 0xE4) & 0x02) {\r\nrs_ber = (cx22702_readreg(state, 0xDE) & 0x7F) << 7\r\n| (cx22702_readreg(state, 0xDF) & 0x7F);\r\n} else {\r\nrs_ber = (cx22702_readreg(state, 0xDE) & 0x7F) << 8\r\n| cx22702_readreg(state, 0xDF);\r\n}\r\n*snr = ~rs_ber;\r\nreturn 0;\r\n}\r\nstatic int cx22702_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct cx22702_state *state = fe->demodulator_priv;\r\nu8 _ucblocks;\r\n_ucblocks = cx22702_readreg(state, 0xE3);\r\nif (state->prevUCBlocks < _ucblocks)\r\n*ucblocks = (_ucblocks - state->prevUCBlocks);\r\nelse\r\n*ucblocks = state->prevUCBlocks - _ucblocks;\r\nstate->prevUCBlocks = _ucblocks;\r\nreturn 0;\r\n}\r\nstatic int cx22702_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct cx22702_state *state = fe->demodulator_priv;\r\nu8 reg0C = cx22702_readreg(state, 0x0C);\r\nc->inversion = reg0C & 0x1 ? INVERSION_ON : INVERSION_OFF;\r\nreturn cx22702_get_tps(state, c);\r\n}\r\nstatic int cx22702_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic void cx22702_release(struct dvb_frontend *fe)\r\n{\r\nstruct cx22702_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *cx22702_attach(const struct cx22702_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct cx22702_state *state = NULL;\r\nstate = kzalloc(sizeof(struct cx22702_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nif (cx22702_readreg(state, 0x1f) != 0x3)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &cx22702_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
