static inline int isp1704_read(struct isp1704_charger *isp, u32 reg)\r\n{\r\nreturn usb_phy_io_read(isp->phy, reg);\r\n}\r\nstatic inline int isp1704_write(struct isp1704_charger *isp, u32 reg, u32 val)\r\n{\r\nreturn usb_phy_io_write(isp->phy, val, reg);\r\n}\r\nstatic void isp1704_charger_set_power(struct isp1704_charger *isp, bool on)\r\n{\r\nstruct isp1704_charger_data *board = isp->dev->platform_data;\r\nif (board && board->set_power)\r\nboard->set_power(on);\r\nelse if (board)\r\ngpio_set_value(board->enable_gpio, on);\r\n}\r\nstatic inline int isp1704_charger_type(struct isp1704_charger *isp)\r\n{\r\nu8 reg;\r\nu8 func_ctrl;\r\nu8 otg_ctrl;\r\nint type = POWER_SUPPLY_TYPE_USB_DCP;\r\nfunc_ctrl = isp1704_read(isp, ULPI_FUNC_CTRL);\r\notg_ctrl = isp1704_read(isp, ULPI_OTG_CTRL);\r\nreg = ULPI_OTG_CTRL_DM_PULLDOWN | ULPI_OTG_CTRL_DP_PULLDOWN;\r\nisp1704_write(isp, ULPI_CLR(ULPI_OTG_CTRL), reg);\r\nisp1704_write(isp, ULPI_CLR(ULPI_FUNC_CTRL),\r\nULPI_FUNC_CTRL_XCVRSEL_MASK);\r\nisp1704_write(isp, ULPI_SET(ULPI_FUNC_CTRL),\r\nULPI_FUNC_CTRL_FULL_SPEED);\r\nreg = ULPI_FUNC_CTRL_TERMSELECT | ULPI_FUNC_CTRL_RESET;\r\nisp1704_write(isp, ULPI_SET(ULPI_FUNC_CTRL), reg);\r\nusleep_range(1000, 2000);\r\nreg = isp1704_read(isp, ULPI_DEBUG);\r\nif ((reg & 3) != 3)\r\ntype = POWER_SUPPLY_TYPE_USB_CDP;\r\nisp1704_write(isp, ULPI_FUNC_CTRL, func_ctrl);\r\nisp1704_write(isp, ULPI_OTG_CTRL, otg_ctrl);\r\nreturn type;\r\n}\r\nstatic inline int isp1704_charger_verify(struct isp1704_charger *isp)\r\n{\r\nint ret = 0;\r\nu8 r;\r\nr = isp1704_read(isp, ULPI_FUNC_CTRL);\r\nr |= ULPI_FUNC_CTRL_RESET;\r\nisp1704_write(isp, ULPI_FUNC_CTRL, r);\r\nusleep_range(1000, 2000);\r\nr &= ~(ULPI_FUNC_CTRL_RESET | ULPI_FUNC_CTRL_OPMODE_MASK);\r\nisp1704_write(isp, ULPI_FUNC_CTRL, r);\r\nr = ULPI_OTG_CTRL_DP_PULLDOWN | ULPI_OTG_CTRL_DM_PULLDOWN;\r\nisp1704_write(isp, ULPI_CLR(ULPI_OTG_CTRL), r);\r\nr = ULPI_FUNC_CTRL_TERMSELECT | ULPI_FUNC_CTRL_RESET;\r\nisp1704_write(isp, ULPI_SET(ULPI_FUNC_CTRL), r);\r\nusleep_range(1000, 2000);\r\nif (!isp1704_read(isp, ULPI_DEBUG)) {\r\nisp1704_write(isp, ULPI_CLR(ULPI_FUNC_CTRL),\r\nULPI_FUNC_CTRL_TERMSELECT);\r\nreturn 1;\r\n}\r\nisp1704_write(isp, ULPI_SET(ISP1704_PWR_CTRL),\r\nISP1704_PWR_CTRL_DP_WKPU_EN);\r\nisp1704_write(isp, ULPI_CLR(ULPI_FUNC_CTRL),\r\nULPI_FUNC_CTRL_TERMSELECT);\r\nisp1704_write(isp, ULPI_SET(ULPI_OTG_CTRL),\r\nULPI_OTG_CTRL_DM_PULLDOWN);\r\nif (!(isp1704_read(isp, ULPI_DEBUG)))\r\nret = 1;\r\nisp1704_write(isp, ULPI_CLR(ISP1704_PWR_CTRL),\r\nISP1704_PWR_CTRL_DP_WKPU_EN);\r\nreturn ret;\r\n}\r\nstatic inline int isp1704_charger_detect(struct isp1704_charger *isp)\r\n{\r\nunsigned long timeout;\r\nu8 pwr_ctrl;\r\nint ret = 0;\r\npwr_ctrl = isp1704_read(isp, ISP1704_PWR_CTRL);\r\nisp1704_write(isp, ISP1704_PWR_CTRL,\r\nISP1704_PWR_CTRL_SWCTRL);\r\nisp1704_write(isp, ULPI_SET(ISP1704_PWR_CTRL),\r\nISP1704_PWR_CTRL_SWCTRL\r\n| ISP1704_PWR_CTRL_DPVSRC_EN);\r\nusleep_range(1000, 2000);\r\ntimeout = jiffies + msecs_to_jiffies(300);\r\ndo {\r\nif (isp1704_read(isp, ISP1704_PWR_CTRL)\r\n& ISP1704_PWR_CTRL_VDAT_DET) {\r\nret = isp1704_charger_verify(isp);\r\nbreak;\r\n}\r\n} while (!time_after(jiffies, timeout) && isp->online);\r\nisp1704_write(isp, ISP1704_PWR_CTRL, pwr_ctrl);\r\nreturn ret;\r\n}\r\nstatic inline int isp1704_charger_detect_dcp(struct isp1704_charger *isp)\r\n{\r\nif (isp1704_charger_detect(isp) &&\r\nisp1704_charger_type(isp) == POWER_SUPPLY_TYPE_USB_DCP)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void isp1704_charger_work(struct work_struct *data)\r\n{\r\nstruct isp1704_charger *isp =\r\ncontainer_of(data, struct isp1704_charger, work);\r\nstatic DEFINE_MUTEX(lock);\r\nmutex_lock(&lock);\r\nswitch (isp->phy->last_event) {\r\ncase USB_EVENT_VBUS:\r\nif (!isp->present) {\r\nisp->online = true;\r\nisp->present = 1;\r\nisp1704_charger_set_power(isp, 1);\r\nif (isp1704_charger_detect_dcp(isp)) {\r\nisp->psy_desc.type = POWER_SUPPLY_TYPE_USB_DCP;\r\nisp->current_max = 1800;\r\n} else {\r\nisp->psy_desc.type = POWER_SUPPLY_TYPE_USB;\r\nisp->current_max = 500;\r\n}\r\nif (isp->phy->otg->gadget)\r\nusb_gadget_connect(isp->phy->otg->gadget);\r\n}\r\nif (isp->psy_desc.type != POWER_SUPPLY_TYPE_USB_DCP) {\r\nif (isp->current_max > 500)\r\nisp->current_max = 500;\r\nif (isp->current_max > 100)\r\nisp->psy_desc.type = POWER_SUPPLY_TYPE_USB_CDP;\r\n}\r\nbreak;\r\ncase USB_EVENT_NONE:\r\nisp->online = false;\r\nisp->present = 0;\r\nisp->current_max = 0;\r\nisp->psy_desc.type = POWER_SUPPLY_TYPE_USB;\r\nif (isp->phy->otg->gadget)\r\nusb_gadget_disconnect(isp->phy->otg->gadget);\r\nisp1704_charger_set_power(isp, 0);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\npower_supply_changed(isp->psy);\r\nout:\r\nmutex_unlock(&lock);\r\n}\r\nstatic int isp1704_notifier_call(struct notifier_block *nb,\r\nunsigned long val, void *v)\r\n{\r\nstruct isp1704_charger *isp =\r\ncontainer_of(nb, struct isp1704_charger, nb);\r\nschedule_work(&isp->work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int isp1704_charger_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct isp1704_charger *isp = power_supply_get_drvdata(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = isp->present;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = isp->online;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_MAX:\r\nval->intval = isp->current_max;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = isp->model;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nval->strval = "NXP";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int isp1704_test_ulpi(struct isp1704_charger *isp)\r\n{\r\nint vendor;\r\nint product;\r\nint i;\r\nint ret = -ENODEV;\r\nret = isp1704_write(isp, ULPI_SCRATCH, 0xaa);\r\nif (ret < 0)\r\nreturn ret;\r\nret = isp1704_read(isp, ULPI_SCRATCH);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != 0xaa)\r\nreturn -ENODEV;\r\nvendor = isp1704_read(isp, ULPI_VENDOR_ID_LOW);\r\nvendor |= isp1704_read(isp, ULPI_VENDOR_ID_HIGH) << 8;\r\nif (vendor != NXP_VENDOR_ID)\r\nreturn -ENODEV;\r\nproduct = isp1704_read(isp, ULPI_PRODUCT_ID_LOW);\r\nproduct |= isp1704_read(isp, ULPI_PRODUCT_ID_HIGH) << 8;\r\nfor (i = 0; i < ARRAY_SIZE(isp170x_id); i++) {\r\nif (product == isp170x_id[i]) {\r\nsprintf(isp->model, "isp%x", product);\r\nreturn product;\r\n}\r\n}\r\ndev_err(isp->dev, "product id %x not matching known ids", product);\r\nreturn -ENODEV;\r\n}\r\nstatic int isp1704_charger_probe(struct platform_device *pdev)\r\n{\r\nstruct isp1704_charger *isp;\r\nint ret = -ENODEV;\r\nstruct power_supply_config psy_cfg = {};\r\nstruct isp1704_charger_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nif (np) {\r\nint gpio = of_get_named_gpio(np, "nxp,enable-gpio", 0);\r\nif (gpio < 0) {\r\ndev_err(&pdev->dev, "missing DT GPIO nxp,enable-gpio\n");\r\nreturn gpio;\r\n}\r\npdata = devm_kzalloc(&pdev->dev,\r\nsizeof(struct isp1704_charger_data), GFP_KERNEL);\r\npdata->enable_gpio = gpio;\r\ndev_info(&pdev->dev, "init gpio %d\n", pdata->enable_gpio);\r\nret = devm_gpio_request_one(&pdev->dev, pdata->enable_gpio,\r\nGPIOF_OUT_INIT_HIGH, "isp1704_reset");\r\nif (ret) {\r\ndev_err(&pdev->dev, "gpio request failed\n");\r\ngoto fail0;\r\n}\r\n}\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "missing platform data!\n");\r\nreturn -ENODEV;\r\n}\r\nisp = devm_kzalloc(&pdev->dev, sizeof(*isp), GFP_KERNEL);\r\nif (!isp)\r\nreturn -ENOMEM;\r\nif (np)\r\nisp->phy = devm_usb_get_phy_by_phandle(&pdev->dev, "usb-phy", 0);\r\nelse\r\nisp->phy = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);\r\nif (IS_ERR(isp->phy)) {\r\nret = PTR_ERR(isp->phy);\r\ndev_err(&pdev->dev, "usb_get_phy failed\n");\r\ngoto fail0;\r\n}\r\nisp->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, isp);\r\nisp1704_charger_set_power(isp, 1);\r\nret = isp1704_test_ulpi(isp);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "isp1704_test_ulpi failed\n");\r\ngoto fail1;\r\n}\r\nisp->psy_desc.name = "isp1704";\r\nisp->psy_desc.type = POWER_SUPPLY_TYPE_USB;\r\nisp->psy_desc.properties = power_props;\r\nisp->psy_desc.num_properties = ARRAY_SIZE(power_props);\r\nisp->psy_desc.get_property = isp1704_charger_get_property;\r\npsy_cfg.drv_data = isp;\r\nisp->psy = power_supply_register(isp->dev, &isp->psy_desc, &psy_cfg);\r\nif (IS_ERR(isp->psy)) {\r\nret = PTR_ERR(isp->psy);\r\ndev_err(&pdev->dev, "power_supply_register failed\n");\r\ngoto fail1;\r\n}\r\nINIT_WORK(&isp->work, isp1704_charger_work);\r\nisp->nb.notifier_call = isp1704_notifier_call;\r\nret = usb_register_notifier(isp->phy, &isp->nb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "usb_register_notifier failed\n");\r\ngoto fail2;\r\n}\r\ndev_info(isp->dev, "registered with product id %s\n", isp->model);\r\nif (isp->phy->otg->gadget)\r\nusb_gadget_disconnect(isp->phy->otg->gadget);\r\nif (isp->phy->last_event == USB_EVENT_NONE)\r\nisp1704_charger_set_power(isp, 0);\r\nif (isp->phy->last_event == USB_EVENT_VBUS &&\r\n!isp->phy->otg->default_a)\r\nschedule_work(&isp->work);\r\nreturn 0;\r\nfail2:\r\npower_supply_unregister(isp->psy);\r\nfail1:\r\nisp1704_charger_set_power(isp, 0);\r\nfail0:\r\ndev_err(&pdev->dev, "failed to register isp1704 with error %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int isp1704_charger_remove(struct platform_device *pdev)\r\n{\r\nstruct isp1704_charger *isp = platform_get_drvdata(pdev);\r\nusb_unregister_notifier(isp->phy, &isp->nb);\r\npower_supply_unregister(isp->psy);\r\nisp1704_charger_set_power(isp, 0);\r\nreturn 0;\r\n}
