static int tt3650_ci_msg(struct dvb_usb_device *d, u8 cmd, u8 *data,\r\nunsigned int write_len, unsigned int read_len)\r\n{\r\nstruct pctv452e_state *state = (struct pctv452e_state *)d->priv;\r\nu8 buf[64];\r\nu8 id;\r\nunsigned int rlen;\r\nint ret;\r\nBUG_ON(NULL == data && 0 != (write_len | read_len));\r\nBUG_ON(write_len > 64 - 4);\r\nBUG_ON(read_len > 64 - 4);\r\nid = state->c++;\r\nbuf[0] = SYNC_BYTE_OUT;\r\nbuf[1] = id;\r\nbuf[2] = cmd;\r\nbuf[3] = write_len;\r\nmemcpy(buf + 4, data, write_len);\r\nrlen = (read_len > 0) ? 64 : 0;\r\nret = dvb_usb_generic_rw(d, buf, 4 + write_len,\r\nbuf, rlen, 0);\r\nif (0 != ret)\r\ngoto failed;\r\nret = -EIO;\r\nif (SYNC_BYTE_IN != buf[0] || id != buf[1])\r\ngoto failed;\r\nmemcpy(data, buf + 4, read_len);\r\nreturn 0;\r\nfailed:\r\nerr("CI error %d; %02X %02X %02X -> %*ph.",\r\nret, SYNC_BYTE_OUT, id, cmd, 3, buf);\r\nreturn ret;\r\n}\r\nstatic int tt3650_ci_msg_locked(struct dvb_ca_en50221 *ca,\r\nu8 cmd, u8 *data, unsigned int write_len,\r\nunsigned int read_len)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct pctv452e_state *state = (struct pctv452e_state *)d->priv;\r\nint ret;\r\nmutex_lock(&state->ca_mutex);\r\nret = tt3650_ci_msg(d, cmd, data, write_len, read_len);\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int tt3650_ci_read_attribute_mem(struct dvb_ca_en50221 *ca,\r\nint slot, int address)\r\n{\r\nu8 buf[3];\r\nint ret;\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nbuf[0] = (address >> 8) & 0x0F;\r\nbuf[1] = address;\r\nret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_RD_ATTR, buf, 2, 3);\r\nci_dbg("%s %04x -> %d 0x%02x",\r\n__func__, address, ret, buf[2]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn buf[2];\r\n}\r\nstatic int tt3650_ci_write_attribute_mem(struct dvb_ca_en50221 *ca,\r\nint slot, int address, u8 value)\r\n{\r\nu8 buf[3];\r\nci_dbg("%s %d 0x%04x 0x%02x",\r\n__func__, slot, address, value);\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nbuf[0] = (address >> 8) & 0x0F;\r\nbuf[1] = address;\r\nbuf[2] = value;\r\nreturn tt3650_ci_msg_locked(ca, TT3650_CMD_CI_WR_ATTR, buf, 3, 3);\r\n}\r\nstatic int tt3650_ci_read_cam_control(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nu8 address)\r\n{\r\nu8 buf[2];\r\nint ret;\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nbuf[0] = address & 3;\r\nret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_RD_CTRL, buf, 1, 2);\r\nci_dbg("%s 0x%02x -> %d 0x%02x",\r\n__func__, address, ret, buf[1]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn buf[1];\r\n}\r\nstatic int tt3650_ci_write_cam_control(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nu8 address,\r\nu8 value)\r\n{\r\nu8 buf[2];\r\nci_dbg("%s %d 0x%02x 0x%02x",\r\n__func__, slot, address, value);\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nbuf[0] = address;\r\nbuf[1] = value;\r\nreturn tt3650_ci_msg_locked(ca, TT3650_CMD_CI_WR_CTRL, buf, 2, 2);\r\n}\r\nstatic int tt3650_ci_set_video_port(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nint enable)\r\n{\r\nu8 buf[1];\r\nint ret;\r\nci_dbg("%s %d %d", __func__, slot, enable);\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nenable = !!enable;\r\nbuf[0] = enable;\r\nret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_SET_VIDEO_PORT, buf, 1, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nif (enable != buf[0]) {\r\nerr("CI not %sabled.", enable ? "en" : "dis");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tt3650_ci_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nreturn tt3650_ci_set_video_port(ca, slot, 0);\r\n}\r\nstatic int tt3650_ci_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nreturn tt3650_ci_set_video_port(ca, slot, 1);\r\n}\r\nstatic int tt3650_ci_slot_reset(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct pctv452e_state *state = (struct pctv452e_state *)d->priv;\r\nu8 buf[1];\r\nint ret;\r\nci_dbg("%s %d", __func__, slot);\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nbuf[0] = 0;\r\nmutex_lock(&state->ca_mutex);\r\nret = tt3650_ci_msg(d, TT3650_CMD_CI_RESET, buf, 1, 1);\r\nif (0 != ret)\r\ngoto failed;\r\nmsleep(500);\r\nbuf[0] = 1;\r\nret = tt3650_ci_msg(d, TT3650_CMD_CI_RESET, buf, 1, 1);\r\nif (0 != ret)\r\ngoto failed;\r\nmsleep(500);\r\nbuf[0] = 0;\r\nret = tt3650_ci_msg(d, TT3650_CMD_CI_SET_VIDEO_PORT, buf, 1, 1);\r\nfailed:\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int tt3650_ci_poll_slot_status(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nint open)\r\n{\r\nu8 buf[1];\r\nint ret;\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_TEST, buf, 0, 1);\r\nif (0 != ret)\r\nreturn ret;\r\nif (1 == buf[0])\r\nreturn DVB_CA_EN50221_POLL_CAM_PRESENT |\r\nDVB_CA_EN50221_POLL_CAM_READY;\r\nreturn 0;\r\n}\r\nstatic void tt3650_ci_uninit(struct dvb_usb_device *d)\r\n{\r\nstruct pctv452e_state *state;\r\nci_dbg("%s", __func__);\r\nif (NULL == d)\r\nreturn;\r\nstate = (struct pctv452e_state *)d->priv;\r\nif (NULL == state)\r\nreturn;\r\nif (NULL == state->ca.data)\r\nreturn;\r\ntt3650_ci_set_video_port(&state->ca, 0, 0);\r\ndvb_ca_en50221_release(&state->ca);\r\nmemset(&state->ca, 0, sizeof(state->ca));\r\n}\r\nstatic int tt3650_ci_init(struct dvb_usb_adapter *a)\r\n{\r\nstruct dvb_usb_device *d = a->dev;\r\nstruct pctv452e_state *state = (struct pctv452e_state *)d->priv;\r\nint ret;\r\nci_dbg("%s", __func__);\r\nmutex_init(&state->ca_mutex);\r\nstate->ca.owner = THIS_MODULE;\r\nstate->ca.read_attribute_mem = tt3650_ci_read_attribute_mem;\r\nstate->ca.write_attribute_mem = tt3650_ci_write_attribute_mem;\r\nstate->ca.read_cam_control = tt3650_ci_read_cam_control;\r\nstate->ca.write_cam_control = tt3650_ci_write_cam_control;\r\nstate->ca.slot_reset = tt3650_ci_slot_reset;\r\nstate->ca.slot_shutdown = tt3650_ci_slot_shutdown;\r\nstate->ca.slot_ts_enable = tt3650_ci_slot_ts_enable;\r\nstate->ca.poll_slot_status = tt3650_ci_poll_slot_status;\r\nstate->ca.data = d;\r\nret = dvb_ca_en50221_init(&a->dvb_adap,\r\n&state->ca,\r\n0,\r\n1);\r\nif (0 != ret) {\r\nerr("Cannot initialize CI: Error %d.", ret);\r\nmemset(&state->ca, 0, sizeof(state->ca));\r\nreturn ret;\r\n}\r\ninfo("CI initialized.");\r\nreturn 0;\r\n}\r\nstatic int pctv452e_i2c_msg(struct dvb_usb_device *d, u8 addr,\r\nconst u8 *snd_buf, u8 snd_len,\r\nu8 *rcv_buf, u8 rcv_len)\r\n{\r\nstruct pctv452e_state *state = (struct pctv452e_state *)d->priv;\r\nu8 buf[64];\r\nu8 id;\r\nint ret;\r\nid = state->c++;\r\nret = -EINVAL;\r\nif (snd_len > 64 - 7 || rcv_len > 64 - 7)\r\ngoto failed;\r\nbuf[0] = SYNC_BYTE_OUT;\r\nbuf[1] = id;\r\nbuf[2] = PCTV_CMD_I2C;\r\nbuf[3] = snd_len + 3;\r\nbuf[4] = addr << 1;\r\nbuf[5] = snd_len;\r\nbuf[6] = rcv_len;\r\nmemcpy(buf + 7, snd_buf, snd_len);\r\nret = dvb_usb_generic_rw(d, buf, 7 + snd_len,\r\nbuf, 64,\r\n0);\r\nif (ret < 0)\r\ngoto failed;\r\nret = -EIO;\r\nif (SYNC_BYTE_IN != buf[0] || id != buf[1])\r\ngoto failed;\r\nret = -EREMOTEIO;\r\nif (buf[5] < snd_len || buf[6] < rcv_len)\r\ngoto failed;\r\nmemcpy(rcv_buf, buf + 7, rcv_len);\r\nreturn rcv_len;\r\nfailed:\r\nerr("I2C error %d; %02X %02X %02X %02X %02X -> "\r\n"%02X %02X %02X %02X %02X.",\r\nret, SYNC_BYTE_OUT, id, addr << 1, snd_len, rcv_len,\r\nbuf[0], buf[1], buf[4], buf[5], buf[6]);\r\nreturn ret;\r\n}\r\nstatic int pctv452e_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msg,\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adapter);\r\nint i;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num; i++) {\r\nu8 addr, snd_len, rcv_len, *snd_buf, *rcv_buf;\r\nint ret;\r\nif (msg[i].flags & I2C_M_RD) {\r\naddr = msg[i].addr;\r\nsnd_buf = NULL;\r\nsnd_len = 0;\r\nrcv_buf = msg[i].buf;\r\nrcv_len = msg[i].len;\r\n} else {\r\naddr = msg[i].addr;\r\nsnd_buf = msg[i].buf;\r\nsnd_len = msg[i].len;\r\nrcv_buf = NULL;\r\nrcv_len = 0;\r\n}\r\nret = pctv452e_i2c_msg(d, addr, snd_buf, snd_len, rcv_buf,\r\nrcv_len);\r\nif (ret < rcv_len)\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i;\r\n}\r\nstatic u32 pctv452e_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int pctv452e_power_ctrl(struct dvb_usb_device *d, int i)\r\n{\r\nstruct pctv452e_state *state = (struct pctv452e_state *)d->priv;\r\nu8 b0[] = { 0xaa, 0, PCTV_CMD_RESET, 1, 0 };\r\nu8 rx[PCTV_ANSWER_LEN];\r\nint ret;\r\ninfo("%s: %d\n", __func__, i);\r\nif (!i)\r\nreturn 0;\r\nif (state->initialized)\r\nreturn 0;\r\nret = usb_set_interface(d->udev, 0, ISOC_INTERFACE_ALTERNATIVE);\r\nif (ret != 0)\r\ninfo("%s: Warning set interface returned: %d\n",\r\n__func__, ret);\r\nb0[1] = state->c++;\r\nret = dvb_usb_generic_rw(d, b0, sizeof(b0), rx, PCTV_ANSWER_LEN, 0);\r\nif (ret)\r\nreturn ret;\r\nb0[1] = state->c++;\r\nb0[4] = 1;\r\nret = dvb_usb_generic_rw(d, b0, sizeof(b0), rx, PCTV_ANSWER_LEN, 0);\r\nif (ret)\r\nreturn ret;\r\nstate->initialized = 1;\r\nreturn 0;\r\n}\r\nstatic int pctv452e_rc_query(struct dvb_usb_device *d)\r\n{\r\nstruct pctv452e_state *state = (struct pctv452e_state *)d->priv;\r\nu8 b[CMD_BUFFER_SIZE];\r\nu8 rx[PCTV_ANSWER_LEN];\r\nint ret, i;\r\nu8 id = state->c++;\r\nb[0] = SYNC_BYTE_OUT;\r\nb[1] = id;\r\nb[2] = PCTV_CMD_IR;\r\nb[3] = 0;\r\nret = dvb_usb_generic_rw(d, b, 4, rx, PCTV_ANSWER_LEN, 0);\r\nif (ret != 0)\r\nreturn ret;\r\nif (debug > 3) {\r\ninfo("%s: read: %2d: %*ph: ", __func__, ret, 3, rx);\r\nfor (i = 0; (i < rx[3]) && ((i+3) < PCTV_ANSWER_LEN); i++)\r\ninfo(" %02x", rx[i+3]);\r\ninfo("\n");\r\n}\r\nif ((rx[3] == 9) && (rx[12] & 0x01)) {\r\nstate->last_rc_key = RC_SCANCODE_RC5(rx[7], rx[6]);\r\nif (debug > 2)\r\ninfo("%s: cmd=0x%02x sys=0x%02x\n",\r\n__func__, rx[6], rx[7]);\r\nrc_keydown(d->rc_dev, RC_TYPE_RC5, state->last_rc_key, 0);\r\n} else if (state->last_rc_key) {\r\nrc_keyup(d->rc_dev);\r\nstate->last_rc_key = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pctv452e_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nconst u8 mem_addr[] = { 0x1f, 0xcc };\r\nu8 encoded_mac[20];\r\nint ret;\r\nret = -EAGAIN;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\ngoto failed;\r\nret = pctv452e_i2c_msg(d, I2C_ADDR_24C16,\r\nmem_addr + 1, 1,\r\nencoded_mac, 20);\r\nif (-EREMOTEIO == ret)\r\nret = pctv452e_i2c_msg(d, I2C_ADDR_24C64,\r\nmem_addr, 2,\r\nencoded_mac, 20);\r\nmutex_unlock(&d->i2c_mutex);\r\nif (20 != ret)\r\ngoto failed;\r\nret = ttpci_eeprom_decode_mac(mac, encoded_mac);\r\nif (0 != ret)\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\neth_zero_addr(mac);\r\nreturn ret;\r\n}\r\nstatic int pctv452e_frontend_attach(struct dvb_usb_adapter *a)\r\n{\r\nstruct usb_device_id *id;\r\na->fe_adap[0].fe = dvb_attach(stb0899_attach, &stb0899_config,\r\n&a->dev->i2c_adap);\r\nif (!a->fe_adap[0].fe)\r\nreturn -ENODEV;\r\nif ((dvb_attach(lnbp22_attach, a->fe_adap[0].fe,\r\n&a->dev->i2c_adap)) == NULL)\r\nerr("Cannot attach lnbp22\n");\r\nid = a->dev->desc->warm_ids[0];\r\nif (USB_VID_TECHNOTREND == id->idVendor\r\n&& USB_PID_TECHNOTREND_CONNECT_S2_3650_CI == id->idProduct)\r\ntt3650_ci_init(a);\r\nreturn 0;\r\n}\r\nstatic int pctv452e_tuner_attach(struct dvb_usb_adapter *a)\r\n{\r\nif (!a->fe_adap[0].fe)\r\nreturn -ENODEV;\r\nif (dvb_attach(stb6100_attach, a->fe_adap[0].fe, &stb6100_config,\r\n&a->dev->i2c_adap) == NULL) {\r\nerr("%s failed\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pctv452e_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\ntt3650_ci_uninit(d);\r\ndvb_usb_device_exit(intf);\r\n}\r\nstatic int pctv452e_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nif (0 == dvb_usb_device_init(intf, &pctv452e_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &tt_connect_s2_3600_properties,\r\nTHIS_MODULE, NULL, adapter_nr))\r\nreturn 0;\r\nreturn -ENODEV;\r\n}
