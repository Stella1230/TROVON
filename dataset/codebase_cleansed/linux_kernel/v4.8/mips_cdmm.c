static const struct mips_cdmm_device_id *\r\nmips_cdmm_lookup(const struct mips_cdmm_device_id *table,\r\nstruct mips_cdmm_device *dev)\r\n{\r\nint ret = 0;\r\nfor (; table->type; ++table) {\r\nret = (dev->type == table->type);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret ? table : NULL;\r\n}\r\nstatic int mips_cdmm_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct mips_cdmm_device *cdev = to_mips_cdmm_device(dev);\r\nstruct mips_cdmm_driver *cdrv = to_mips_cdmm_driver(drv);\r\nreturn mips_cdmm_lookup(cdrv->id_table, cdev) != NULL;\r\n}\r\nstatic int mips_cdmm_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct mips_cdmm_device *cdev = to_mips_cdmm_device(dev);\r\nint retval = 0;\r\nretval = add_uevent_var(env, "CDMM_CPU=%u", cdev->cpu);\r\nif (retval)\r\nreturn retval;\r\nretval = add_uevent_var(env, "CDMM_TYPE=0x%02x", cdev->type);\r\nif (retval)\r\nreturn retval;\r\nretval = add_uevent_var(env, "CDMM_REV=%u", cdev->rev);\r\nif (retval)\r\nreturn retval;\r\nretval = add_uevent_var(env, "MODALIAS=mipscdmm:t%02X", cdev->type);\r\nreturn retval;\r\n}\r\nstatic long mips_cdmm_void_work(void *data)\r\n{\r\nstruct mips_cdmm_work_dev *work = data;\r\nvoid (*fn)(struct mips_cdmm_device *) = work->fn;\r\nfn(work->dev);\r\nreturn 0;\r\n}\r\nstatic long mips_cdmm_int_work(void *data)\r\n{\r\nstruct mips_cdmm_work_dev *work = data;\r\nint (*fn)(struct mips_cdmm_device *) = work->fn;\r\nreturn fn(work->dev);\r\n}\r\nint mips_cdmm_driver_register(struct mips_cdmm_driver *drv)\r\n{\r\ndrv->drv.bus = &mips_cdmm_bustype;\r\nif (drv->probe)\r\ndrv->drv.probe = mips_cdmm_probe;\r\nif (drv->remove)\r\ndrv->drv.remove = mips_cdmm_remove;\r\nif (drv->shutdown)\r\ndrv->drv.shutdown = mips_cdmm_shutdown;\r\nreturn driver_register(&drv->drv);\r\n}\r\nvoid mips_cdmm_driver_unregister(struct mips_cdmm_driver *drv)\r\n{\r\ndriver_unregister(&drv->drv);\r\n}\r\nstatic struct mips_cdmm_bus *mips_cdmm_get_bus(void)\r\n{\r\nstruct mips_cdmm_bus *bus, **bus_p;\r\nunsigned long flags;\r\nunsigned int cpu;\r\nif (!cpu_has_cdmm)\r\nreturn ERR_PTR(-ENODEV);\r\ncpu = smp_processor_id();\r\nif (cpu == 0)\r\nreturn &mips_cdmm_boot_bus;\r\nbus_p = per_cpu_ptr(&mips_cdmm_buses, cpu);\r\nlocal_irq_save(flags);\r\nbus = *bus_p;\r\nif (unlikely(!bus)) {\r\nbus = kzalloc(sizeof(*bus), GFP_ATOMIC);\r\nif (unlikely(!bus))\r\nbus = ERR_PTR(-ENOMEM);\r\nelse\r\n*bus_p = bus;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn bus;\r\n}\r\nstatic phys_addr_t mips_cdmm_cur_base(void)\r\n{\r\nunsigned long cdmmbase = read_c0_cdmmbase();\r\nif (!(cdmmbase & MIPS_CDMMBASE_EN))\r\nreturn 0;\r\nreturn (cdmmbase >> MIPS_CDMMBASE_ADDR_SHIFT)\r\n<< MIPS_CDMMBASE_ADDR_START;\r\n}\r\nphys_addr_t __weak mips_cdmm_phys_base(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mips_cdmm_setup(struct mips_cdmm_bus *bus)\r\n{\r\nunsigned long cdmmbase, flags;\r\nint ret = 0;\r\nif (IS_ERR(bus))\r\nreturn PTR_ERR(bus);\r\nlocal_irq_save(flags);\r\nif (bus->offline) {\r\nif (bus->phys == mips_cdmm_cur_base())\r\ngoto out;\r\nbus->offline = false;\r\n} else if (bus->phys > 1) {\r\ngoto out;\r\n}\r\nif (!bus->phys)\r\nbus->phys = mips_cdmm_cur_base();\r\nif (!bus->phys)\r\nbus->phys = mips_cdmm_phys_base();\r\nif (!bus->phys)\r\nbus->phys = mips_cdmm_default_base;\r\nif (!bus->phys) {\r\nbus->phys = 1;\r\npr_err("cdmm%u: Failed to choose a physical base\n",\r\nsmp_processor_id());\r\n}\r\nif (bus->phys == 1) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmips_cdmm_default_base = bus->phys;\r\npr_debug("cdmm%u: Enabling CDMM region at %pa\n",\r\nsmp_processor_id(), &bus->phys);\r\ncdmmbase = read_c0_cdmmbase();\r\ncdmmbase &= (1ul << MIPS_CDMMBASE_ADDR_SHIFT) - 1;\r\ncdmmbase |= (bus->phys >> MIPS_CDMMBASE_ADDR_START)\r\n<< MIPS_CDMMBASE_ADDR_SHIFT;\r\ncdmmbase |= MIPS_CDMMBASE_EN;\r\nwrite_c0_cdmmbase(cdmmbase);\r\ntlbw_use_hazard();\r\nbus->regs = (void __iomem *)CKSEG1ADDR(bus->phys);\r\nbus->drbs = 1 + ((cdmmbase & MIPS_CDMMBASE_SIZE) >>\r\nMIPS_CDMMBASE_SIZE_SHIFT);\r\nbus->drbs_reserved = !!(cdmmbase & MIPS_CDMMBASE_CI);\r\nout:\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nvoid __iomem *mips_cdmm_early_probe(unsigned int dev_type)\r\n{\r\nstruct mips_cdmm_bus *bus;\r\nvoid __iomem *cdmm;\r\nu32 acsr;\r\nunsigned int drb, type, size;\r\nint err;\r\nif (WARN_ON(!dev_type))\r\nreturn IOMEM_ERR_PTR(-ENODEV);\r\nbus = mips_cdmm_get_bus();\r\nerr = mips_cdmm_setup(bus);\r\nif (err)\r\nreturn IOMEM_ERR_PTR(err);\r\ndrb = bus->drbs_reserved;\r\ncdmm = bus->regs;\r\nfor (; drb < bus->drbs; drb += size + 1) {\r\nacsr = __raw_readl(cdmm + drb * CDMM_DRB_SIZE);\r\ntype = (acsr & CDMM_ACSR_DEVTYPE) >> CDMM_ACSR_DEVTYPE_SHIFT;\r\nif (type == dev_type)\r\nreturn cdmm + drb * CDMM_DRB_SIZE;\r\nsize = (acsr & CDMM_ACSR_DEVSIZE) >> CDMM_ACSR_DEVSIZE_SHIFT;\r\n}\r\nreturn IOMEM_ERR_PTR(-ENODEV);\r\n}\r\nstatic void mips_cdmm_release(struct device *dev)\r\n{\r\nstruct mips_cdmm_device *cdev = to_mips_cdmm_device(dev);\r\nkfree(cdev);\r\n}\r\nstatic void mips_cdmm_bus_discover(struct mips_cdmm_bus *bus)\r\n{\r\nvoid __iomem *cdmm;\r\nu32 acsr;\r\nunsigned int drb, type, size, rev;\r\nstruct mips_cdmm_device *dev;\r\nunsigned int cpu = smp_processor_id();\r\nint ret = 0;\r\nint id = 0;\r\ndrb = bus->drbs_reserved;\r\ncdmm = bus->regs;\r\nbus->discovered = true;\r\npr_info("cdmm%u discovery (%u blocks)\n", cpu, bus->drbs);\r\nfor (; drb < bus->drbs; drb += size + 1) {\r\nacsr = __raw_readl(cdmm + drb * CDMM_DRB_SIZE);\r\ntype = (acsr & CDMM_ACSR_DEVTYPE) >> CDMM_ACSR_DEVTYPE_SHIFT;\r\nsize = (acsr & CDMM_ACSR_DEVSIZE) >> CDMM_ACSR_DEVSIZE_SHIFT;\r\nrev = (acsr & CDMM_ACSR_DEVREV) >> CDMM_ACSR_DEVREV_SHIFT;\r\nif (!type)\r\ncontinue;\r\npr_info("cdmm%u-%u: @%u (%#x..%#x), type 0x%02x, rev %u\n",\r\ncpu, id, drb, drb * CDMM_DRB_SIZE,\r\n(drb + size + 1) * CDMM_DRB_SIZE - 1,\r\ntype, rev);\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nbreak;\r\ndev->cpu = cpu;\r\ndev->res.start = bus->phys + drb * CDMM_DRB_SIZE;\r\ndev->res.end = bus->phys +\r\n(drb + size + 1) * CDMM_DRB_SIZE - 1;\r\ndev->res.flags = IORESOURCE_MEM;\r\ndev->type = type;\r\ndev->rev = rev;\r\ndev->dev.parent = get_cpu_device(cpu);\r\ndev->dev.bus = &mips_cdmm_bustype;\r\ndev->dev.id = atomic_inc_return(&mips_cdmm_next_id);\r\ndev->dev.release = mips_cdmm_release;\r\ndev_set_name(&dev->dev, "cdmm%u-%u", cpu, id);\r\n++id;\r\nret = device_register(&dev->dev);\r\nif (ret) {\r\nput_device(&dev->dev);\r\nkfree(dev);\r\n}\r\n}\r\n}\r\nstatic long mips_cdmm_bus_down(void *data)\r\n{\r\nstruct mips_cdmm_bus *bus;\r\nlong ret;\r\nret = bus_for_each_dev(&mips_cdmm_bustype, NULL, data,\r\nmips_cdmm_cpu_down_helper);\r\nbus = mips_cdmm_get_bus();\r\nif (!IS_ERR(bus))\r\nbus->offline = true;\r\nreturn ret;\r\n}\r\nstatic long mips_cdmm_bus_up(void *data)\r\n{\r\nstruct mips_cdmm_bus *bus;\r\nlong ret;\r\nbus = mips_cdmm_get_bus();\r\nret = mips_cdmm_setup(bus);\r\nif (ret)\r\nreturn ret;\r\nbus->offline = false;\r\nif (!bus->discovered)\r\nmips_cdmm_bus_discover(bus);\r\nelse\r\nret = bus_for_each_dev(&mips_cdmm_bustype, NULL, data,\r\nmips_cdmm_cpu_up_helper);\r\nreturn ret;\r\n}\r\nstatic int mips_cdmm_cpu_notify(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nunsigned int cpu = (unsigned int)data;\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_ONLINE:\r\ncase CPU_DOWN_FAILED:\r\nmips_cdmm_bus_up(&cpu);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\nmips_cdmm_bus_down(&cpu);\r\nbreak;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init mips_cdmm_init(void)\r\n{\r\nunsigned int cpu;\r\nint ret;\r\nret = bus_register(&mips_cdmm_bustype);\r\nif (ret)\r\nreturn ret;\r\nret = register_cpu_notifier(&mips_cdmm_cpu_nb);\r\nif (ret) {\r\npr_warn("cdmm: Failed to register CPU notifier\n");\r\ngoto out;\r\n}\r\nfor_each_online_cpu(cpu)\r\nwork_on_cpu(cpu, mips_cdmm_bus_up, &cpu);\r\nreturn 0;\r\nout:\r\nbus_unregister(&mips_cdmm_bustype);\r\nreturn ret;\r\n}
