static int __must_check __smsc75xx_read_reg(struct usbnet *dev, u32 index,\r\nu32 *data, int in_pm)\r\n{\r\nu32 buf;\r\nint ret;\r\nint (*fn)(struct usbnet *, u8, u8, u16, u16, void *, u16);\r\nBUG_ON(!dev);\r\nif (!in_pm)\r\nfn = usbnet_read_cmd;\r\nelse\r\nfn = usbnet_read_cmd_nopm;\r\nret = fn(dev, USB_VENDOR_REQUEST_READ_REGISTER, USB_DIR_IN\r\n| USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index, &buf, 4);\r\nif (unlikely(ret < 0)) {\r\nnetdev_warn(dev->net, "Failed to read reg index 0x%08x: %d\n",\r\nindex, ret);\r\nreturn ret;\r\n}\r\nle32_to_cpus(&buf);\r\n*data = buf;\r\nreturn ret;\r\n}\r\nstatic int __must_check __smsc75xx_write_reg(struct usbnet *dev, u32 index,\r\nu32 data, int in_pm)\r\n{\r\nu32 buf;\r\nint ret;\r\nint (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);\r\nBUG_ON(!dev);\r\nif (!in_pm)\r\nfn = usbnet_write_cmd;\r\nelse\r\nfn = usbnet_write_cmd_nopm;\r\nbuf = data;\r\ncpu_to_le32s(&buf);\r\nret = fn(dev, USB_VENDOR_REQUEST_WRITE_REGISTER, USB_DIR_OUT\r\n| USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index, &buf, 4);\r\nif (unlikely(ret < 0))\r\nnetdev_warn(dev->net, "Failed to write reg index 0x%08x: %d\n",\r\nindex, ret);\r\nreturn ret;\r\n}\r\nstatic int __must_check smsc75xx_read_reg_nopm(struct usbnet *dev, u32 index,\r\nu32 *data)\r\n{\r\nreturn __smsc75xx_read_reg(dev, index, data, 1);\r\n}\r\nstatic int __must_check smsc75xx_write_reg_nopm(struct usbnet *dev, u32 index,\r\nu32 data)\r\n{\r\nreturn __smsc75xx_write_reg(dev, index, data, 1);\r\n}\r\nstatic int __must_check smsc75xx_read_reg(struct usbnet *dev, u32 index,\r\nu32 *data)\r\n{\r\nreturn __smsc75xx_read_reg(dev, index, data, 0);\r\n}\r\nstatic int __must_check smsc75xx_write_reg(struct usbnet *dev, u32 index,\r\nu32 data)\r\n{\r\nreturn __smsc75xx_write_reg(dev, index, data, 0);\r\n}\r\nstatic __must_check int __smsc75xx_phy_wait_not_busy(struct usbnet *dev,\r\nint in_pm)\r\n{\r\nunsigned long start_time = jiffies;\r\nu32 val;\r\nint ret;\r\ndo {\r\nret = __smsc75xx_read_reg(dev, MII_ACCESS, &val, in_pm);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading MII_ACCESS\n");\r\nreturn ret;\r\n}\r\nif (!(val & MII_ACCESS_BUSY))\r\nreturn 0;\r\n} while (!time_after(jiffies, start_time + HZ));\r\nreturn -EIO;\r\n}\r\nstatic int __smsc75xx_mdio_read(struct net_device *netdev, int phy_id, int idx,\r\nint in_pm)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nu32 val, addr;\r\nint ret;\r\nmutex_lock(&dev->phy_mutex);\r\nret = __smsc75xx_phy_wait_not_busy(dev, in_pm);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "MII is busy in smsc75xx_mdio_read\n");\r\ngoto done;\r\n}\r\nphy_id &= dev->mii.phy_id_mask;\r\nidx &= dev->mii.reg_num_mask;\r\naddr = ((phy_id << MII_ACCESS_PHY_ADDR_SHIFT) & MII_ACCESS_PHY_ADDR)\r\n| ((idx << MII_ACCESS_REG_ADDR_SHIFT) & MII_ACCESS_REG_ADDR)\r\n| MII_ACCESS_READ | MII_ACCESS_BUSY;\r\nret = __smsc75xx_write_reg(dev, MII_ACCESS, addr, in_pm);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing MII_ACCESS\n");\r\ngoto done;\r\n}\r\nret = __smsc75xx_phy_wait_not_busy(dev, in_pm);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Timed out reading MII reg %02X\n", idx);\r\ngoto done;\r\n}\r\nret = __smsc75xx_read_reg(dev, MII_DATA, &val, in_pm);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading MII_DATA\n");\r\ngoto done;\r\n}\r\nret = (u16)(val & 0xFFFF);\r\ndone:\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic void __smsc75xx_mdio_write(struct net_device *netdev, int phy_id,\r\nint idx, int regval, int in_pm)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nu32 val, addr;\r\nint ret;\r\nmutex_lock(&dev->phy_mutex);\r\nret = __smsc75xx_phy_wait_not_busy(dev, in_pm);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "MII is busy in smsc75xx_mdio_write\n");\r\ngoto done;\r\n}\r\nval = regval;\r\nret = __smsc75xx_write_reg(dev, MII_DATA, val, in_pm);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing MII_DATA\n");\r\ngoto done;\r\n}\r\nphy_id &= dev->mii.phy_id_mask;\r\nidx &= dev->mii.reg_num_mask;\r\naddr = ((phy_id << MII_ACCESS_PHY_ADDR_SHIFT) & MII_ACCESS_PHY_ADDR)\r\n| ((idx << MII_ACCESS_REG_ADDR_SHIFT) & MII_ACCESS_REG_ADDR)\r\n| MII_ACCESS_WRITE | MII_ACCESS_BUSY;\r\nret = __smsc75xx_write_reg(dev, MII_ACCESS, addr, in_pm);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing MII_ACCESS\n");\r\ngoto done;\r\n}\r\nret = __smsc75xx_phy_wait_not_busy(dev, in_pm);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Timed out writing MII reg %02X\n", idx);\r\ngoto done;\r\n}\r\ndone:\r\nmutex_unlock(&dev->phy_mutex);\r\n}\r\nstatic int smsc75xx_mdio_read_nopm(struct net_device *netdev, int phy_id,\r\nint idx)\r\n{\r\nreturn __smsc75xx_mdio_read(netdev, phy_id, idx, 1);\r\n}\r\nstatic void smsc75xx_mdio_write_nopm(struct net_device *netdev, int phy_id,\r\nint idx, int regval)\r\n{\r\n__smsc75xx_mdio_write(netdev, phy_id, idx, regval, 1);\r\n}\r\nstatic int smsc75xx_mdio_read(struct net_device *netdev, int phy_id, int idx)\r\n{\r\nreturn __smsc75xx_mdio_read(netdev, phy_id, idx, 0);\r\n}\r\nstatic void smsc75xx_mdio_write(struct net_device *netdev, int phy_id, int idx,\r\nint regval)\r\n{\r\n__smsc75xx_mdio_write(netdev, phy_id, idx, regval, 0);\r\n}\r\nstatic int smsc75xx_wait_eeprom(struct usbnet *dev)\r\n{\r\nunsigned long start_time = jiffies;\r\nu32 val;\r\nint ret;\r\ndo {\r\nret = smsc75xx_read_reg(dev, E2P_CMD, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading E2P_CMD\n");\r\nreturn ret;\r\n}\r\nif (!(val & E2P_CMD_BUSY) || (val & E2P_CMD_TIMEOUT))\r\nbreak;\r\nudelay(40);\r\n} while (!time_after(jiffies, start_time + HZ));\r\nif (val & (E2P_CMD_TIMEOUT | E2P_CMD_BUSY)) {\r\nnetdev_warn(dev->net, "EEPROM read operation timeout\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_eeprom_confirm_not_busy(struct usbnet *dev)\r\n{\r\nunsigned long start_time = jiffies;\r\nu32 val;\r\nint ret;\r\ndo {\r\nret = smsc75xx_read_reg(dev, E2P_CMD, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading E2P_CMD\n");\r\nreturn ret;\r\n}\r\nif (!(val & E2P_CMD_BUSY))\r\nreturn 0;\r\nudelay(40);\r\n} while (!time_after(jiffies, start_time + HZ));\r\nnetdev_warn(dev->net, "EEPROM is busy\n");\r\nreturn -EIO;\r\n}\r\nstatic int smsc75xx_read_eeprom(struct usbnet *dev, u32 offset, u32 length,\r\nu8 *data)\r\n{\r\nu32 val;\r\nint i, ret;\r\nBUG_ON(!dev);\r\nBUG_ON(!data);\r\nret = smsc75xx_eeprom_confirm_not_busy(dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < length; i++) {\r\nval = E2P_CMD_BUSY | E2P_CMD_READ | (offset & E2P_CMD_ADDR);\r\nret = smsc75xx_write_reg(dev, E2P_CMD, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing E2P_CMD\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_wait_eeprom(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = smsc75xx_read_reg(dev, E2P_DATA, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading E2P_DATA\n");\r\nreturn ret;\r\n}\r\ndata[i] = val & 0xFF;\r\noffset++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_write_eeprom(struct usbnet *dev, u32 offset, u32 length,\r\nu8 *data)\r\n{\r\nu32 val;\r\nint i, ret;\r\nBUG_ON(!dev);\r\nBUG_ON(!data);\r\nret = smsc75xx_eeprom_confirm_not_busy(dev);\r\nif (ret)\r\nreturn ret;\r\nval = E2P_CMD_BUSY | E2P_CMD_EWEN;\r\nret = smsc75xx_write_reg(dev, E2P_CMD, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing E2P_CMD\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_wait_eeprom(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < length; i++) {\r\nval = data[i];\r\nret = smsc75xx_write_reg(dev, E2P_DATA, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing E2P_DATA\n");\r\nreturn ret;\r\n}\r\nval = E2P_CMD_BUSY | E2P_CMD_WRITE | (offset & E2P_CMD_ADDR);\r\nret = smsc75xx_write_reg(dev, E2P_CMD, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing E2P_CMD\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_wait_eeprom(dev);\r\nif (ret < 0)\r\nreturn ret;\r\noffset++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_dataport_wait_not_busy(struct usbnet *dev)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < 100; i++) {\r\nu32 dp_sel;\r\nret = smsc75xx_read_reg(dev, DP_SEL, &dp_sel);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading DP_SEL\n");\r\nreturn ret;\r\n}\r\nif (dp_sel & DP_SEL_DPRDY)\r\nreturn 0;\r\nudelay(40);\r\n}\r\nnetdev_warn(dev->net, "smsc75xx_dataport_wait_not_busy timed out\n");\r\nreturn -EIO;\r\n}\r\nstatic int smsc75xx_dataport_write(struct usbnet *dev, u32 ram_select, u32 addr,\r\nu32 length, u32 *buf)\r\n{\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nu32 dp_sel;\r\nint i, ret;\r\nmutex_lock(&pdata->dataport_mutex);\r\nret = smsc75xx_dataport_wait_not_busy(dev);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "smsc75xx_dataport_write busy on entry\n");\r\ngoto done;\r\n}\r\nret = smsc75xx_read_reg(dev, DP_SEL, &dp_sel);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading DP_SEL\n");\r\ngoto done;\r\n}\r\ndp_sel &= ~DP_SEL_RSEL;\r\ndp_sel |= ram_select;\r\nret = smsc75xx_write_reg(dev, DP_SEL, dp_sel);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing DP_SEL\n");\r\ngoto done;\r\n}\r\nfor (i = 0; i < length; i++) {\r\nret = smsc75xx_write_reg(dev, DP_ADDR, addr + i);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing DP_ADDR\n");\r\ngoto done;\r\n}\r\nret = smsc75xx_write_reg(dev, DP_DATA, buf[i]);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing DP_DATA\n");\r\ngoto done;\r\n}\r\nret = smsc75xx_write_reg(dev, DP_CMD, DP_CMD_WRITE);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing DP_CMD\n");\r\ngoto done;\r\n}\r\nret = smsc75xx_dataport_wait_not_busy(dev);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "smsc75xx_dataport_write timeout\n");\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nmutex_unlock(&pdata->dataport_mutex);\r\nreturn ret;\r\n}\r\nstatic u32 smsc75xx_hash(char addr[ETH_ALEN])\r\n{\r\nreturn (ether_crc(ETH_ALEN, addr) >> 23) & 0x1ff;\r\n}\r\nstatic void smsc75xx_deferred_multicast_write(struct work_struct *param)\r\n{\r\nstruct smsc75xx_priv *pdata =\r\ncontainer_of(param, struct smsc75xx_priv, set_multicast);\r\nstruct usbnet *dev = pdata->dev;\r\nint ret;\r\nnetif_dbg(dev, drv, dev->net, "deferred multicast write 0x%08x\n",\r\npdata->rfe_ctl);\r\nsmsc75xx_dataport_write(dev, DP_SEL_VHF, DP_SEL_VHF_VLAN_LEN,\r\nDP_SEL_VHF_HASH_LEN, pdata->multicast_hash_table);\r\nret = smsc75xx_write_reg(dev, RFE_CTL, pdata->rfe_ctl);\r\nif (ret < 0)\r\nnetdev_warn(dev->net, "Error writing RFE_CRL\n");\r\n}\r\nstatic void smsc75xx_set_multicast(struct net_device *netdev)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&pdata->rfe_ctl_lock, flags);\r\npdata->rfe_ctl &=\r\n~(RFE_CTL_AU | RFE_CTL_AM | RFE_CTL_DPF | RFE_CTL_MHF);\r\npdata->rfe_ctl |= RFE_CTL_AB;\r\nfor (i = 0; i < DP_SEL_VHF_HASH_LEN; i++)\r\npdata->multicast_hash_table[i] = 0;\r\nif (dev->net->flags & IFF_PROMISC) {\r\nnetif_dbg(dev, drv, dev->net, "promiscuous mode enabled\n");\r\npdata->rfe_ctl |= RFE_CTL_AM | RFE_CTL_AU;\r\n} else if (dev->net->flags & IFF_ALLMULTI) {\r\nnetif_dbg(dev, drv, dev->net, "receive all multicast enabled\n");\r\npdata->rfe_ctl |= RFE_CTL_AM | RFE_CTL_DPF;\r\n} else if (!netdev_mc_empty(dev->net)) {\r\nstruct netdev_hw_addr *ha;\r\nnetif_dbg(dev, drv, dev->net, "receive multicast hash filter\n");\r\npdata->rfe_ctl |= RFE_CTL_MHF | RFE_CTL_DPF;\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nu32 bitnum = smsc75xx_hash(ha->addr);\r\npdata->multicast_hash_table[bitnum / 32] |=\r\n(1 << (bitnum % 32));\r\n}\r\n} else {\r\nnetif_dbg(dev, drv, dev->net, "receive own packets only\n");\r\npdata->rfe_ctl |= RFE_CTL_DPF;\r\n}\r\nspin_unlock_irqrestore(&pdata->rfe_ctl_lock, flags);\r\nschedule_work(&pdata->set_multicast);\r\n}\r\nstatic int smsc75xx_update_flowcontrol(struct usbnet *dev, u8 duplex,\r\nu16 lcladv, u16 rmtadv)\r\n{\r\nu32 flow = 0, fct_flow = 0;\r\nint ret;\r\nif (duplex == DUPLEX_FULL) {\r\nu8 cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\r\nif (cap & FLOW_CTRL_TX) {\r\nflow = (FLOW_TX_FCEN | 0xFFFF);\r\nfct_flow = (8 << 8) | 32;\r\n}\r\nif (cap & FLOW_CTRL_RX)\r\nflow |= FLOW_RX_FCEN;\r\nnetif_dbg(dev, link, dev->net, "rx pause %s, tx pause %s\n",\r\n(cap & FLOW_CTRL_RX ? "enabled" : "disabled"),\r\n(cap & FLOW_CTRL_TX ? "enabled" : "disabled"));\r\n} else {\r\nnetif_dbg(dev, link, dev->net, "half duplex\n");\r\n}\r\nret = smsc75xx_write_reg(dev, FLOW, flow);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing FLOW\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_write_reg(dev, FCT_FLOW, fct_flow);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing FCT_FLOW\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_link_reset(struct usbnet *dev)\r\n{\r\nstruct mii_if_info *mii = &dev->mii;\r\nstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\r\nu16 lcladv, rmtadv;\r\nint ret;\r\nsmsc75xx_mdio_write(dev->net, mii->phy_id, PHY_INT_SRC,\r\nPHY_INT_SRC_CLEAR_ALL);\r\nret = smsc75xx_write_reg(dev, INT_STS, INT_STS_CLEAR_ALL);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing INT_STS\n");\r\nreturn ret;\r\n}\r\nmii_check_media(mii, 1, 1);\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nlcladv = smsc75xx_mdio_read(dev->net, mii->phy_id, MII_ADVERTISE);\r\nrmtadv = smsc75xx_mdio_read(dev->net, mii->phy_id, MII_LPA);\r\nnetif_dbg(dev, link, dev->net, "speed: %u duplex: %d lcladv: %04x rmtadv: %04x\n",\r\nethtool_cmd_speed(&ecmd), ecmd.duplex, lcladv, rmtadv);\r\nreturn smsc75xx_update_flowcontrol(dev, ecmd.duplex, lcladv, rmtadv);\r\n}\r\nstatic void smsc75xx_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nu32 intdata;\r\nif (urb->actual_length != 4) {\r\nnetdev_warn(dev->net, "unexpected urb length %d\n",\r\nurb->actual_length);\r\nreturn;\r\n}\r\nmemcpy(&intdata, urb->transfer_buffer, 4);\r\nle32_to_cpus(&intdata);\r\nnetif_dbg(dev, link, dev->net, "intdata: 0x%08X\n", intdata);\r\nif (intdata & INT_ENP_PHY_INT)\r\nusbnet_defer_kevent(dev, EVENT_LINK_RESET);\r\nelse\r\nnetdev_warn(dev->net, "unexpected interrupt, intdata=0x%08X\n",\r\nintdata);\r\n}\r\nstatic int smsc75xx_ethtool_get_eeprom_len(struct net_device *net)\r\n{\r\nreturn MAX_EEPROM_SIZE;\r\n}\r\nstatic int smsc75xx_ethtool_get_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *ee, u8 *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nee->magic = LAN75XX_EEPROM_MAGIC;\r\nreturn smsc75xx_read_eeprom(dev, ee->offset, ee->len, data);\r\n}\r\nstatic int smsc75xx_ethtool_set_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *ee, u8 *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nif (ee->magic != LAN75XX_EEPROM_MAGIC) {\r\nnetdev_warn(dev->net, "EEPROM: magic value mismatch: 0x%x\n",\r\nee->magic);\r\nreturn -EINVAL;\r\n}\r\nreturn smsc75xx_write_eeprom(dev, ee->offset, ee->len, data);\r\n}\r\nstatic void smsc75xx_ethtool_get_wol(struct net_device *net,\r\nstruct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nwolinfo->supported = SUPPORTED_WAKE;\r\nwolinfo->wolopts = pdata->wolopts;\r\n}\r\nstatic int smsc75xx_ethtool_set_wol(struct net_device *net,\r\nstruct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nint ret;\r\npdata->wolopts = wolinfo->wolopts & SUPPORTED_WAKE;\r\nret = device_set_wakeup_enable(&dev->udev->dev, pdata->wolopts);\r\nif (ret < 0)\r\nnetdev_warn(dev->net, "device_set_wakeup_enable error %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int smsc75xx_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nif (!netif_running(netdev))\r\nreturn -EINVAL;\r\nreturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\r\n}\r\nstatic void smsc75xx_init_mac_address(struct usbnet *dev)\r\n{\r\nconst u8 *mac_addr;\r\nmac_addr = of_get_mac_address(dev->udev->dev.of_node);\r\nif (mac_addr) {\r\nmemcpy(dev->net->dev_addr, mac_addr, ETH_ALEN);\r\nreturn;\r\n}\r\nif (smsc75xx_read_eeprom(dev, EEPROM_MAC_OFFSET, ETH_ALEN,\r\ndev->net->dev_addr) == 0) {\r\nif (is_valid_ether_addr(dev->net->dev_addr)) {\r\nnetif_dbg(dev, ifup, dev->net,\r\n"MAC address read from EEPROM\n");\r\nreturn;\r\n}\r\n}\r\neth_hw_addr_random(dev->net);\r\nnetif_dbg(dev, ifup, dev->net, "MAC address set to eth_random_addr\n");\r\n}\r\nstatic int smsc75xx_set_mac_address(struct usbnet *dev)\r\n{\r\nu32 addr_lo = dev->net->dev_addr[0] | dev->net->dev_addr[1] << 8 |\r\ndev->net->dev_addr[2] << 16 | dev->net->dev_addr[3] << 24;\r\nu32 addr_hi = dev->net->dev_addr[4] | dev->net->dev_addr[5] << 8;\r\nint ret = smsc75xx_write_reg(dev, RX_ADDRH, addr_hi);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write RX_ADDRH: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_write_reg(dev, RX_ADDRL, addr_lo);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write RX_ADDRL: %d\n", ret);\r\nreturn ret;\r\n}\r\naddr_hi |= ADDR_FILTX_FB_VALID;\r\nret = smsc75xx_write_reg(dev, ADDR_FILTX, addr_hi);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write ADDR_FILTX: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_write_reg(dev, ADDR_FILTX + 4, addr_lo);\r\nif (ret < 0)\r\nnetdev_warn(dev->net, "Failed to write ADDR_FILTX+4: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int smsc75xx_phy_initialize(struct usbnet *dev)\r\n{\r\nint bmcr, ret, timeout = 0;\r\ndev->mii.dev = dev->net;\r\ndev->mii.mdio_read = smsc75xx_mdio_read;\r\ndev->mii.mdio_write = smsc75xx_mdio_write;\r\ndev->mii.phy_id_mask = 0x1f;\r\ndev->mii.reg_num_mask = 0x1f;\r\ndev->mii.supports_gmii = 1;\r\ndev->mii.phy_id = SMSC75XX_INTERNAL_PHY_ID;\r\nsmsc75xx_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);\r\ndo {\r\nmsleep(10);\r\nbmcr = smsc75xx_mdio_read(dev->net, dev->mii.phy_id, MII_BMCR);\r\nif (bmcr < 0) {\r\nnetdev_warn(dev->net, "Error reading MII_BMCR\n");\r\nreturn bmcr;\r\n}\r\ntimeout++;\r\n} while ((bmcr & BMCR_RESET) && (timeout < 100));\r\nif (timeout >= 100) {\r\nnetdev_warn(dev->net, "timeout on PHY Reset\n");\r\nreturn -EIO;\r\n}\r\nsmsc75xx_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\r\nADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP |\r\nADVERTISE_PAUSE_ASYM);\r\nsmsc75xx_mdio_write(dev->net, dev->mii.phy_id, MII_CTRL1000,\r\nADVERTISE_1000FULL);\r\nret = smsc75xx_mdio_read(dev->net, dev->mii.phy_id, PHY_INT_SRC);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PHY_INT_SRC\n");\r\nreturn ret;\r\n}\r\nsmsc75xx_mdio_write(dev->net, dev->mii.phy_id, PHY_INT_SRC, 0xffff);\r\nsmsc75xx_mdio_write(dev->net, dev->mii.phy_id, PHY_INT_MASK,\r\nPHY_INT_MASK_DEFAULT);\r\nmii_nway_restart(&dev->mii);\r\nnetif_dbg(dev, ifup, dev->net, "phy initialised successfully\n");\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_set_rx_max_frame_length(struct usbnet *dev, int size)\r\n{\r\nint ret = 0;\r\nu32 buf;\r\nbool rxenabled;\r\nret = smsc75xx_read_reg(dev, MAC_RX, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read MAC_RX: %d\n", ret);\r\nreturn ret;\r\n}\r\nrxenabled = ((buf & MAC_RX_RXEN) != 0);\r\nif (rxenabled) {\r\nbuf &= ~MAC_RX_RXEN;\r\nret = smsc75xx_write_reg(dev, MAC_RX, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write MAC_RX: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nbuf &= ~MAC_RX_MAX_SIZE;\r\nbuf |= (((size + 4) << MAC_RX_MAX_SIZE_SHIFT) & MAC_RX_MAX_SIZE);\r\nret = smsc75xx_write_reg(dev, MAC_RX, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write MAC_RX: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (rxenabled) {\r\nbuf |= MAC_RX_RXEN;\r\nret = smsc75xx_write_reg(dev, MAC_RX, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write MAC_RX: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nint ret;\r\nif (new_mtu > MAX_SINGLE_PACKET_SIZE)\r\nreturn -EINVAL;\r\nret = smsc75xx_set_rx_max_frame_length(dev, new_mtu + ETH_HLEN);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to set mac rx frame length\n");\r\nreturn ret;\r\n}\r\nreturn usbnet_change_mtu(netdev, new_mtu);\r\n}\r\nstatic int smsc75xx_set_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&pdata->rfe_ctl_lock, flags);\r\nif (features & NETIF_F_RXCSUM)\r\npdata->rfe_ctl |= RFE_CTL_TCPUDP_CKM | RFE_CTL_IP_CKM;\r\nelse\r\npdata->rfe_ctl &= ~(RFE_CTL_TCPUDP_CKM | RFE_CTL_IP_CKM);\r\nspin_unlock_irqrestore(&pdata->rfe_ctl_lock, flags);\r\nret = smsc75xx_write_reg(dev, RFE_CTL, pdata->rfe_ctl);\r\nif (ret < 0)\r\nnetdev_warn(dev->net, "Error writing RFE_CTL\n");\r\nreturn ret;\r\n}\r\nstatic int smsc75xx_wait_ready(struct usbnet *dev, int in_pm)\r\n{\r\nint timeout = 0;\r\ndo {\r\nu32 buf;\r\nint ret;\r\nret = __smsc75xx_read_reg(dev, PMT_CTL, &buf, in_pm);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read PMT_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (buf & PMT_CTL_DEV_RDY)\r\nreturn 0;\r\nmsleep(10);\r\ntimeout++;\r\n} while (timeout < 100);\r\nnetdev_warn(dev->net, "timeout waiting for device ready\n");\r\nreturn -EIO;\r\n}\r\nstatic int smsc75xx_reset(struct usbnet *dev)\r\n{\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nu32 buf;\r\nint ret = 0, timeout;\r\nnetif_dbg(dev, ifup, dev->net, "entering smsc75xx_reset\n");\r\nret = smsc75xx_wait_ready(dev, 0);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "device not ready in smsc75xx_reset\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, HW_CFG, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf |= HW_CFG_LRST;\r\nret = smsc75xx_write_reg(dev, HW_CFG, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\ntimeout = 0;\r\ndo {\r\nmsleep(10);\r\nret = smsc75xx_read_reg(dev, HW_CFG, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\ntimeout++;\r\n} while ((buf & HW_CFG_LRST) && (timeout < 100));\r\nif (timeout >= 100) {\r\nnetdev_warn(dev->net, "timeout on completion of Lite Reset\n");\r\nreturn -EIO;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "Lite reset complete, resetting PHY\n");\r\nret = smsc75xx_read_reg(dev, PMT_CTL, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read PMT_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf |= PMT_CTL_PHY_RST;\r\nret = smsc75xx_write_reg(dev, PMT_CTL, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write PMT_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\ntimeout = 0;\r\ndo {\r\nmsleep(10);\r\nret = smsc75xx_read_reg(dev, PMT_CTL, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read PMT_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\ntimeout++;\r\n} while ((buf & PMT_CTL_PHY_RST) && (timeout < 100));\r\nif (timeout >= 100) {\r\nnetdev_warn(dev->net, "timeout waiting for PHY Reset\n");\r\nreturn -EIO;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "PHY reset complete\n");\r\nret = smsc75xx_set_mac_address(dev);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to set mac address\n");\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "MAC Address: %pM\n",\r\ndev->net->dev_addr);\r\nret = smsc75xx_read_reg(dev, HW_CFG, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "Read Value from HW_CFG : 0x%08x\n",\r\nbuf);\r\nbuf |= HW_CFG_BIR;\r\nret = smsc75xx_write_reg(dev, HW_CFG, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, HW_CFG, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "Read Value from HW_CFG after writing HW_CFG_BIR: 0x%08x\n",\r\nbuf);\r\nif (!turbo_mode) {\r\nbuf = 0;\r\ndev->rx_urb_size = MAX_SINGLE_PACKET_SIZE;\r\n} else if (dev->udev->speed == USB_SPEED_HIGH) {\r\nbuf = DEFAULT_HS_BURST_CAP_SIZE / HS_USB_PKT_SIZE;\r\ndev->rx_urb_size = DEFAULT_HS_BURST_CAP_SIZE;\r\n} else {\r\nbuf = DEFAULT_FS_BURST_CAP_SIZE / FS_USB_PKT_SIZE;\r\ndev->rx_urb_size = DEFAULT_FS_BURST_CAP_SIZE;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "rx_urb_size=%ld\n",\r\n(ulong)dev->rx_urb_size);\r\nret = smsc75xx_write_reg(dev, BURST_CAP, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write BURST_CAP: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, BURST_CAP, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read BURST_CAP: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net,\r\n"Read Value from BURST_CAP after writing: 0x%08x\n", buf);\r\nret = smsc75xx_write_reg(dev, BULK_IN_DLY, DEFAULT_BULK_IN_DELAY);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write BULK_IN_DLY: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, BULK_IN_DLY, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read BULK_IN_DLY: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net,\r\n"Read Value from BULK_IN_DLY after writing: 0x%08x\n", buf);\r\nif (turbo_mode) {\r\nret = smsc75xx_read_reg(dev, HW_CFG, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "HW_CFG: 0x%08x\n", buf);\r\nbuf |= (HW_CFG_MEF | HW_CFG_BCE);\r\nret = smsc75xx_write_reg(dev, HW_CFG, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, HW_CFG, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "HW_CFG: 0x%08x\n", buf);\r\n}\r\nbuf = (MAX_RX_FIFO_SIZE - 512) / 512;\r\nret = smsc75xx_write_reg(dev, FCT_RX_FIFO_END, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write FCT_RX_FIFO_END: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "FCT_RX_FIFO_END set to 0x%08x\n", buf);\r\nbuf = (MAX_TX_FIFO_SIZE - 512) / 512;\r\nret = smsc75xx_write_reg(dev, FCT_TX_FIFO_END, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write FCT_TX_FIFO_END: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "FCT_TX_FIFO_END set to 0x%08x\n", buf);\r\nret = smsc75xx_write_reg(dev, INT_STS, INT_STS_CLEAR_ALL);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write INT_STS: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, ID_REV, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read ID_REV: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "ID_REV = 0x%08x\n", buf);\r\nret = smsc75xx_read_reg(dev, E2P_CMD, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read E2P_CMD: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!(buf & E2P_CMD_LOADED)) {\r\nret = smsc75xx_read_reg(dev, LED_GPIO_CFG, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read LED_GPIO_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf &= ~(LED_GPIO_CFG_LED2_FUN_SEL | LED_GPIO_CFG_LED10_FUN_SEL);\r\nbuf |= LED_GPIO_CFG_LEDGPIO_EN | LED_GPIO_CFG_LED2_FUN_SEL;\r\nret = smsc75xx_write_reg(dev, LED_GPIO_CFG, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write LED_GPIO_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = smsc75xx_write_reg(dev, FLOW, 0);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write FLOW: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_write_reg(dev, FCT_FLOW, 0);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write FCT_FLOW: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, RFE_CTL, &pdata->rfe_ctl);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read RFE_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\npdata->rfe_ctl |= RFE_CTL_AB | RFE_CTL_DPF;\r\nret = smsc75xx_write_reg(dev, RFE_CTL, pdata->rfe_ctl);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write RFE_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, RFE_CTL, &pdata->rfe_ctl);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read RFE_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "RFE_CTL set to 0x%08x\n",\r\npdata->rfe_ctl);\r\nsmsc75xx_set_features(dev->net, dev->net->features);\r\nsmsc75xx_set_multicast(dev->net);\r\nret = smsc75xx_phy_initialize(dev);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to initialize PHY: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, INT_EP_CTL, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read INT_EP_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf |= INT_ENP_PHY_INT;\r\nret = smsc75xx_write_reg(dev, INT_EP_CTL, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write INT_EP_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, MAC_CR, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read MAC_CR: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf |= (MAC_CR_ADD | MAC_CR_ASD);\r\nret = smsc75xx_write_reg(dev, MAC_CR, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write MAC_CR: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, MAC_TX, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read MAC_TX: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf |= MAC_TX_TXEN;\r\nret = smsc75xx_write_reg(dev, MAC_TX, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write MAC_TX: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "MAC_TX set to 0x%08x\n", buf);\r\nret = smsc75xx_read_reg(dev, FCT_TX_CTL, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read FCT_TX_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf |= FCT_TX_CTL_EN;\r\nret = smsc75xx_write_reg(dev, FCT_TX_CTL, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write FCT_TX_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "FCT_TX_CTL set to 0x%08x\n", buf);\r\nret = smsc75xx_set_rx_max_frame_length(dev, dev->net->mtu + ETH_HLEN);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to set max rx frame length\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg(dev, MAC_RX, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read MAC_RX: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf |= MAC_RX_RXEN;\r\nret = smsc75xx_write_reg(dev, MAC_RX, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write MAC_RX: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "MAC_RX set to 0x%08x\n", buf);\r\nret = smsc75xx_read_reg(dev, FCT_RX_CTL, &buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read FCT_RX_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf |= FCT_RX_CTL_EN;\r\nret = smsc75xx_write_reg(dev, FCT_RX_CTL, buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write FCT_RX_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "FCT_RX_CTL set to 0x%08x\n", buf);\r\nnetif_dbg(dev, ifup, dev->net, "smsc75xx_reset, return 0\n");\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct smsc75xx_priv *pdata = NULL;\r\nint ret;\r\nprintk(KERN_INFO SMSC_CHIPNAME " v" SMSC_DRIVER_VERSION "\n");\r\nret = usbnet_get_endpoints(dev, intf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "usbnet_get_endpoints failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev->data[0] = (unsigned long)kzalloc(sizeof(struct smsc75xx_priv),\r\nGFP_KERNEL);\r\npdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdata->dev = dev;\r\nspin_lock_init(&pdata->rfe_ctl_lock);\r\nmutex_init(&pdata->dataport_mutex);\r\nINIT_WORK(&pdata->set_multicast, smsc75xx_deferred_multicast_write);\r\nif (DEFAULT_TX_CSUM_ENABLE)\r\ndev->net->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\r\nif (DEFAULT_RX_CSUM_ENABLE)\r\ndev->net->features |= NETIF_F_RXCSUM;\r\ndev->net->hw_features = NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_RXCSUM;\r\nret = smsc75xx_wait_ready(dev, 0);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "device not ready in smsc75xx_bind\n");\r\nreturn ret;\r\n}\r\nsmsc75xx_init_mac_address(dev);\r\nret = smsc75xx_reset(dev);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "smsc75xx_reset error %d\n", ret);\r\nreturn ret;\r\n}\r\ndev->net->netdev_ops = &smsc75xx_netdev_ops;\r\ndev->net->ethtool_ops = &smsc75xx_ethtool_ops;\r\ndev->net->flags |= IFF_MULTICAST;\r\ndev->net->hard_header_len += SMSC75XX_TX_OVERHEAD;\r\ndev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\r\nreturn 0;\r\n}\r\nstatic void smsc75xx_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nif (pdata) {\r\nnetif_dbg(dev, ifdown, dev->net, "free pdata\n");\r\nkfree(pdata);\r\npdata = NULL;\r\ndev->data[0] = 0;\r\n}\r\n}\r\nstatic u16 smsc_crc(const u8 *buffer, size_t len)\r\n{\r\nreturn bitrev16(crc16(0xFFFF, buffer, len));\r\n}\r\nstatic int smsc75xx_write_wuff(struct usbnet *dev, int filter, u32 wuf_cfg,\r\nu32 wuf_mask1)\r\n{\r\nint cfg_base = WUF_CFGX + filter * 4;\r\nint mask_base = WUF_MASKX + filter * 16;\r\nint ret;\r\nret = smsc75xx_write_reg(dev, cfg_base, wuf_cfg);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUF_CFGX\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_write_reg(dev, mask_base, wuf_mask1);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUF_MASKX\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_write_reg(dev, mask_base + 4, 0);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUF_MASKX\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_write_reg(dev, mask_base + 8, 0);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUF_MASKX\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_write_reg(dev, mask_base + 12, 0);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUF_MASKX\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_enter_suspend0(struct usbnet *dev)\r\n{\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nu32 val;\r\nint ret;\r\nret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PMT_CTL\n");\r\nreturn ret;\r\n}\r\nval &= (~(PMT_CTL_SUS_MODE | PMT_CTL_PHY_RST));\r\nval |= PMT_CTL_SUS_MODE_0 | PMT_CTL_WOL_EN | PMT_CTL_WUPS;\r\nret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing PMT_CTL\n");\r\nreturn ret;\r\n}\r\npdata->suspend_flags |= SUSPEND_SUSPEND0;\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_enter_suspend1(struct usbnet *dev)\r\n{\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nu32 val;\r\nint ret;\r\nret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PMT_CTL\n");\r\nreturn ret;\r\n}\r\nval &= ~(PMT_CTL_SUS_MODE | PMT_CTL_WUPS | PMT_CTL_PHY_RST);\r\nval |= PMT_CTL_SUS_MODE_1;\r\nret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing PMT_CTL\n");\r\nreturn ret;\r\n}\r\nval &= ~PMT_CTL_WUPS;\r\nval |= (PMT_CTL_WUPS_ED | PMT_CTL_ED_EN);\r\nret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing PMT_CTL\n");\r\nreturn ret;\r\n}\r\npdata->suspend_flags |= SUSPEND_SUSPEND1;\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_enter_suspend2(struct usbnet *dev)\r\n{\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nu32 val;\r\nint ret;\r\nret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PMT_CTL\n");\r\nreturn ret;\r\n}\r\nval &= ~(PMT_CTL_SUS_MODE | PMT_CTL_WUPS | PMT_CTL_PHY_RST);\r\nval |= PMT_CTL_SUS_MODE_2;\r\nret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing PMT_CTL\n");\r\nreturn ret;\r\n}\r\npdata->suspend_flags |= SUSPEND_SUSPEND2;\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_enter_suspend3(struct usbnet *dev)\r\n{\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nu32 val;\r\nint ret;\r\nret = smsc75xx_read_reg_nopm(dev, FCT_RX_CTL, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading FCT_RX_CTL\n");\r\nreturn ret;\r\n}\r\nif (val & FCT_RX_CTL_RXUSED) {\r\nnetdev_dbg(dev->net, "rx fifo not empty in autosuspend\n");\r\nreturn -EBUSY;\r\n}\r\nret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PMT_CTL\n");\r\nreturn ret;\r\n}\r\nval &= ~(PMT_CTL_SUS_MODE | PMT_CTL_WUPS | PMT_CTL_PHY_RST);\r\nval |= PMT_CTL_SUS_MODE_3 | PMT_CTL_RES_CLR_WKP_EN;\r\nret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing PMT_CTL\n");\r\nreturn ret;\r\n}\r\nval &= ~PMT_CTL_WUPS;\r\nval |= PMT_CTL_WUPS_WOL;\r\nret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing PMT_CTL\n");\r\nreturn ret;\r\n}\r\npdata->suspend_flags |= SUSPEND_SUSPEND3;\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_enable_phy_wakeup_interrupts(struct usbnet *dev, u16 mask)\r\n{\r\nstruct mii_if_info *mii = &dev->mii;\r\nint ret;\r\nnetdev_dbg(dev->net, "enabling PHY wakeup interrupts\n");\r\nret = smsc75xx_mdio_read_nopm(dev->net, mii->phy_id, PHY_INT_SRC);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PHY_INT_SRC\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_mdio_read_nopm(dev->net, mii->phy_id, PHY_INT_MASK);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PHY_INT_MASK\n");\r\nreturn ret;\r\n}\r\nret |= mask;\r\nsmsc75xx_mdio_write_nopm(dev->net, mii->phy_id, PHY_INT_MASK, ret);\r\nreturn 0;\r\n}\r\nstatic int smsc75xx_link_ok_nopm(struct usbnet *dev)\r\n{\r\nstruct mii_if_info *mii = &dev->mii;\r\nint ret;\r\nret = smsc75xx_mdio_read_nopm(dev->net, mii->phy_id, MII_BMSR);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading MII_BMSR\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_mdio_read_nopm(dev->net, mii->phy_id, MII_BMSR);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading MII_BMSR\n");\r\nreturn ret;\r\n}\r\nreturn !!(ret & BMSR_LSTATUS);\r\n}\r\nstatic int smsc75xx_autosuspend(struct usbnet *dev, u32 link_up)\r\n{\r\nint ret;\r\nif (!netif_running(dev->net)) {\r\nnetdev_dbg(dev->net, "autosuspend entering SUSPEND2\n");\r\nreturn smsc75xx_enter_suspend2(dev);\r\n}\r\nif (!link_up) {\r\nnetdev_dbg(dev->net, "autosuspend entering SUSPEND1\n");\r\nret = smsc75xx_enable_phy_wakeup_interrupts(dev,\r\nPHY_INT_MASK_ANEG_COMP);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "error enabling PHY wakeup ints\n");\r\nreturn ret;\r\n}\r\nnetdev_info(dev->net, "entering SUSPEND1 mode\n");\r\nreturn smsc75xx_enter_suspend1(dev);\r\n}\r\nret = smsc75xx_enable_phy_wakeup_interrupts(dev,\r\nPHY_INT_MASK_LINK_DOWN);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "error enabling PHY wakeup ints\n");\r\nreturn ret;\r\n}\r\nnetdev_dbg(dev->net, "autosuspend entering SUSPEND3\n");\r\nreturn smsc75xx_enter_suspend3(dev);\r\n}\r\nstatic int smsc75xx_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nu32 val, link_up;\r\nint ret;\r\nret = usbnet_suspend(intf, message);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "usbnet_suspend error\n");\r\nreturn ret;\r\n}\r\nif (pdata->suspend_flags) {\r\nnetdev_warn(dev->net, "error during last resume\n");\r\npdata->suspend_flags = 0;\r\n}\r\nlink_up = smsc75xx_link_ok_nopm(dev);\r\nif (message.event == PM_EVENT_AUTO_SUSPEND) {\r\nret = smsc75xx_autosuspend(dev, link_up);\r\ngoto done;\r\n}\r\nif (!(pdata->wolopts & SUPPORTED_WAKE) ||\r\n!(link_up || (pdata->wolopts & WAKE_PHY))) {\r\nnetdev_info(dev->net, "entering SUSPEND2 mode\n");\r\nret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading WUCSR\n");\r\ngoto done;\r\n}\r\nval &= ~(WUCSR_MPEN | WUCSR_WUEN);\r\nret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUCSR\n");\r\ngoto done;\r\n}\r\nret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PMT_CTL\n");\r\ngoto done;\r\n}\r\nval &= ~(PMT_CTL_ED_EN | PMT_CTL_WOL_EN);\r\nret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing PMT_CTL\n");\r\ngoto done;\r\n}\r\nret = smsc75xx_enter_suspend2(dev);\r\ngoto done;\r\n}\r\nif (pdata->wolopts & WAKE_PHY) {\r\nret = smsc75xx_enable_phy_wakeup_interrupts(dev,\r\n(PHY_INT_MASK_ANEG_COMP | PHY_INT_MASK_LINK_DOWN));\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "error enabling PHY wakeup ints\n");\r\ngoto done;\r\n}\r\nif (!link_up) {\r\nstruct mii_if_info *mii = &dev->mii;\r\nnetdev_info(dev->net, "entering SUSPEND1 mode\n");\r\nret = smsc75xx_mdio_read_nopm(dev->net, mii->phy_id,\r\nPHY_MODE_CTRL_STS);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PHY_MODE_CTRL_STS\n");\r\ngoto done;\r\n}\r\nret |= MODE_CTRL_STS_EDPWRDOWN;\r\nsmsc75xx_mdio_write_nopm(dev->net, mii->phy_id,\r\nPHY_MODE_CTRL_STS, ret);\r\nret = smsc75xx_enter_suspend1(dev);\r\ngoto done;\r\n}\r\n}\r\nif (pdata->wolopts & (WAKE_MCAST | WAKE_ARP)) {\r\nint i, filter = 0;\r\nfor (i = 0; i < WUF_NUM; i++) {\r\nret = smsc75xx_write_reg_nopm(dev, WUF_CFGX + i * 4, 0);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUF_CFGX\n");\r\ngoto done;\r\n}\r\n}\r\nif (pdata->wolopts & WAKE_MCAST) {\r\nconst u8 mcast[] = {0x01, 0x00, 0x5E};\r\nnetdev_info(dev->net, "enabling multicast detection\n");\r\nval = WUF_CFGX_EN | WUF_CFGX_ATYPE_MULTICAST\r\n| smsc_crc(mcast, 3);\r\nret = smsc75xx_write_wuff(dev, filter++, val, 0x0007);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing wakeup filter\n");\r\ngoto done;\r\n}\r\n}\r\nif (pdata->wolopts & WAKE_ARP) {\r\nconst u8 arp[] = {0x08, 0x06};\r\nnetdev_info(dev->net, "enabling ARP detection\n");\r\nval = WUF_CFGX_EN | WUF_CFGX_ATYPE_ALL | (0x0C << 16)\r\n| smsc_crc(arp, 2);\r\nret = smsc75xx_write_wuff(dev, filter++, val, 0x0003);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing wakeup filter\n");\r\ngoto done;\r\n}\r\n}\r\nret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading WUCSR\n");\r\ngoto done;\r\n}\r\nval |= WUCSR_WUFR;\r\nret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUCSR\n");\r\ngoto done;\r\n}\r\nnetdev_info(dev->net, "enabling packet match detection\n");\r\nret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading WUCSR\n");\r\ngoto done;\r\n}\r\nval |= WUCSR_WUEN;\r\nret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUCSR\n");\r\ngoto done;\r\n}\r\n} else {\r\nnetdev_info(dev->net, "disabling packet match detection\n");\r\nret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading WUCSR\n");\r\ngoto done;\r\n}\r\nval &= ~WUCSR_WUEN;\r\nret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUCSR\n");\r\ngoto done;\r\n}\r\n}\r\nret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading WUCSR\n");\r\ngoto done;\r\n}\r\nval &= ~(WUCSR_MPEN | WUCSR_BCST_EN | WUCSR_PFDA_EN);\r\nret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUCSR\n");\r\ngoto done;\r\n}\r\nif (pdata->wolopts & WAKE_PHY) {\r\nnetdev_info(dev->net, "enabling PHY wakeup\n");\r\nret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PMT_CTL\n");\r\ngoto done;\r\n}\r\nval &= ~PMT_CTL_WUPS;\r\nval |= (PMT_CTL_WUPS_ED | PMT_CTL_ED_EN);\r\nret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing PMT_CTL\n");\r\ngoto done;\r\n}\r\n}\r\nif (pdata->wolopts & WAKE_MAGIC) {\r\nnetdev_info(dev->net, "enabling magic packet wakeup\n");\r\nret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading WUCSR\n");\r\ngoto done;\r\n}\r\nval |= WUCSR_MPR | WUCSR_MPEN;\r\nret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUCSR\n");\r\ngoto done;\r\n}\r\n}\r\nif (pdata->wolopts & WAKE_BCAST) {\r\nnetdev_info(dev->net, "enabling broadcast detection\n");\r\nret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading WUCSR\n");\r\ngoto done;\r\n}\r\nval |= WUCSR_BCAST_FR | WUCSR_BCST_EN;\r\nret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUCSR\n");\r\ngoto done;\r\n}\r\n}\r\nif (pdata->wolopts & WAKE_UCAST) {\r\nnetdev_info(dev->net, "enabling unicast detection\n");\r\nret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading WUCSR\n");\r\ngoto done;\r\n}\r\nval |= WUCSR_WUFR | WUCSR_PFDA_EN;\r\nret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUCSR\n");\r\ngoto done;\r\n}\r\n}\r\nret = smsc75xx_read_reg_nopm(dev, MAC_RX, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read MAC_RX: %d\n", ret);\r\ngoto done;\r\n}\r\nval |= MAC_RX_RXEN;\r\nret = smsc75xx_write_reg_nopm(dev, MAC_RX, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write MAC_RX: %d\n", ret);\r\ngoto done;\r\n}\r\nnetdev_info(dev->net, "entering SUSPEND0 mode\n");\r\nret = smsc75xx_enter_suspend0(dev);\r\ndone:\r\nif (ret && PMSG_IS_AUTO(message))\r\nusbnet_resume(intf);\r\nreturn ret;\r\n}\r\nstatic int smsc75xx_resume(struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\r\nu8 suspend_flags = pdata->suspend_flags;\r\nint ret;\r\nu32 val;\r\nnetdev_dbg(dev->net, "resume suspend_flags=0x%02x\n", suspend_flags);\r\npdata->suspend_flags = 0;\r\nif (suspend_flags & SUSPEND_ALLMODES) {\r\nret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading WUCSR\n");\r\nreturn ret;\r\n}\r\nval &= ~(WUCSR_WUEN | WUCSR_MPEN | WUCSR_PFDA_EN\r\n| WUCSR_BCST_EN);\r\nret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing WUCSR\n");\r\nreturn ret;\r\n}\r\nret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PMT_CTL\n");\r\nreturn ret;\r\n}\r\nval &= ~PMT_CTL_WOL_EN;\r\nval |= PMT_CTL_WUPS;\r\nret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing PMT_CTL\n");\r\nreturn ret;\r\n}\r\n}\r\nif (suspend_flags & SUSPEND_SUSPEND2) {\r\nnetdev_info(dev->net, "resuming from SUSPEND2\n");\r\nret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error reading PMT_CTL\n");\r\nreturn ret;\r\n}\r\nval |= PMT_CTL_PHY_PWRUP;\r\nret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Error writing PMT_CTL\n");\r\nreturn ret;\r\n}\r\n}\r\nret = smsc75xx_wait_ready(dev, 1);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "device not ready in smsc75xx_resume\n");\r\nreturn ret;\r\n}\r\nreturn usbnet_resume(intf);\r\n}\r\nstatic void smsc75xx_rx_csum_offload(struct usbnet *dev, struct sk_buff *skb,\r\nu32 rx_cmd_a, u32 rx_cmd_b)\r\n{\r\nif (!(dev->net->features & NETIF_F_RXCSUM) ||\r\nunlikely(rx_cmd_a & RX_CMD_A_LCSM)) {\r\nskb->ip_summed = CHECKSUM_NONE;\r\n} else {\r\nskb->csum = ntohs((u16)(rx_cmd_b >> RX_CMD_B_CSUM_SHIFT));\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\n}\r\n}\r\nstatic int smsc75xx_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nif (skb->len < dev->net->hard_header_len)\r\nreturn 0;\r\nwhile (skb->len > 0) {\r\nu32 rx_cmd_a, rx_cmd_b, align_count, size;\r\nstruct sk_buff *ax_skb;\r\nunsigned char *packet;\r\nmemcpy(&rx_cmd_a, skb->data, sizeof(rx_cmd_a));\r\nle32_to_cpus(&rx_cmd_a);\r\nskb_pull(skb, 4);\r\nmemcpy(&rx_cmd_b, skb->data, sizeof(rx_cmd_b));\r\nle32_to_cpus(&rx_cmd_b);\r\nskb_pull(skb, 4 + RXW_PADDING);\r\npacket = skb->data;\r\nsize = (rx_cmd_a & RX_CMD_A_LEN) - RXW_PADDING;\r\nalign_count = (4 - ((size + RXW_PADDING) % 4)) % 4;\r\nif (unlikely(rx_cmd_a & RX_CMD_A_RED)) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"Error rx_cmd_a=0x%08x\n", rx_cmd_a);\r\ndev->net->stats.rx_errors++;\r\ndev->net->stats.rx_dropped++;\r\nif (rx_cmd_a & RX_CMD_A_FCS)\r\ndev->net->stats.rx_crc_errors++;\r\nelse if (rx_cmd_a & (RX_CMD_A_LONG | RX_CMD_A_RUNT))\r\ndev->net->stats.rx_frame_errors++;\r\n} else {\r\nif (unlikely(size > (MAX_SINGLE_PACKET_SIZE + ETH_HLEN + 12))) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"size err rx_cmd_a=0x%08x\n",\r\nrx_cmd_a);\r\nreturn 0;\r\n}\r\nif (skb->len == size) {\r\nsmsc75xx_rx_csum_offload(dev, skb, rx_cmd_a,\r\nrx_cmd_b);\r\nskb_trim(skb, skb->len - 4);\r\nskb->truesize = size + sizeof(struct sk_buff);\r\nreturn 1;\r\n}\r\nax_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (unlikely(!ax_skb)) {\r\nnetdev_warn(dev->net, "Error allocating skb\n");\r\nreturn 0;\r\n}\r\nax_skb->len = size;\r\nax_skb->data = packet;\r\nskb_set_tail_pointer(ax_skb, size);\r\nsmsc75xx_rx_csum_offload(dev, ax_skb, rx_cmd_a,\r\nrx_cmd_b);\r\nskb_trim(ax_skb, ax_skb->len - 4);\r\nax_skb->truesize = size + sizeof(struct sk_buff);\r\nusbnet_skb_return(dev, ax_skb);\r\n}\r\nskb_pull(skb, size);\r\nif (skb->len)\r\nskb_pull(skb, align_count);\r\n}\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *smsc75xx_tx_fixup(struct usbnet *dev,\r\nstruct sk_buff *skb, gfp_t flags)\r\n{\r\nu32 tx_cmd_a, tx_cmd_b;\r\nif (skb_headroom(skb) < SMSC75XX_TX_OVERHEAD) {\r\nstruct sk_buff *skb2 =\r\nskb_copy_expand(skb, SMSC75XX_TX_OVERHEAD, 0, flags);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (!skb)\r\nreturn NULL;\r\n}\r\ntx_cmd_a = (u32)(skb->len & TX_CMD_A_LEN) | TX_CMD_A_FCS;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\ntx_cmd_a |= TX_CMD_A_IPE | TX_CMD_A_TPE;\r\nif (skb_is_gso(skb)) {\r\nu16 mss = max(skb_shinfo(skb)->gso_size, TX_MSS_MIN);\r\ntx_cmd_b = (mss << TX_CMD_B_MSS_SHIFT) & TX_CMD_B_MSS;\r\ntx_cmd_a |= TX_CMD_A_LSO;\r\n} else {\r\ntx_cmd_b = 0;\r\n}\r\nskb_push(skb, 4);\r\ncpu_to_le32s(&tx_cmd_b);\r\nmemcpy(skb->data, &tx_cmd_b, 4);\r\nskb_push(skb, 4);\r\ncpu_to_le32s(&tx_cmd_a);\r\nmemcpy(skb->data, &tx_cmd_a, 4);\r\nreturn skb;\r\n}\r\nstatic int smsc75xx_manage_power(struct usbnet *dev, int on)\r\n{\r\ndev->intf->needs_remote_wakeup = on;\r\nreturn 0;\r\n}
