static void krb5_nfold(u32 inbits, const u8 *in,\r\nu32 outbits, u8 *out)\r\n{\r\nunsigned long ulcm;\r\nint byte, i, msbit;\r\ninbits >>= 3;\r\noutbits >>= 3;\r\nulcm = lcm(inbits, outbits);\r\nmemset(out, 0, outbits);\r\nbyte = 0;\r\nfor (i = ulcm-1; i >= 0; i--) {\r\nmsbit = (\r\n((inbits << 3) - 1)\r\n+ (((inbits << 3) + 13) * (i/inbits))\r\n+ ((inbits - (i % inbits)) << 3)\r\n) % (inbits << 3);\r\nbyte += (((in[((inbits - 1) - (msbit >> 3)) % inbits] << 8)|\r\n(in[((inbits) - (msbit >> 3)) % inbits]))\r\n>> ((msbit & 7) + 1)) & 0xff;\r\nbyte += out[i % outbits];\r\nout[i % outbits] = byte & 0xff;\r\nbyte >>= 8;\r\n}\r\nif (byte) {\r\nfor (i = outbits - 1; i >= 0; i--) {\r\nbyte += out[i];\r\nout[i] = byte & 0xff;\r\nbyte >>= 8;\r\n}\r\n}\r\n}\r\nu32 krb5_derive_key(const struct gss_krb5_enctype *gk5e,\r\nconst struct xdr_netobj *inkey,\r\nstruct xdr_netobj *outkey,\r\nconst struct xdr_netobj *in_constant,\r\ngfp_t gfp_mask)\r\n{\r\nsize_t blocksize, keybytes, keylength, n;\r\nunsigned char *inblockdata, *outblockdata, *rawkey;\r\nstruct xdr_netobj inblock, outblock;\r\nstruct crypto_skcipher *cipher;\r\nu32 ret = EINVAL;\r\nblocksize = gk5e->blocksize;\r\nkeybytes = gk5e->keybytes;\r\nkeylength = gk5e->keylength;\r\nif ((inkey->len != keylength) || (outkey->len != keylength))\r\ngoto err_return;\r\ncipher = crypto_alloc_skcipher(gk5e->encrypt_name, 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(cipher))\r\ngoto err_return;\r\nif (crypto_skcipher_setkey(cipher, inkey->data, inkey->len))\r\ngoto err_return;\r\nret = ENOMEM;\r\ninblockdata = kmalloc(blocksize, gfp_mask);\r\nif (inblockdata == NULL)\r\ngoto err_free_cipher;\r\noutblockdata = kmalloc(blocksize, gfp_mask);\r\nif (outblockdata == NULL)\r\ngoto err_free_in;\r\nrawkey = kmalloc(keybytes, gfp_mask);\r\nif (rawkey == NULL)\r\ngoto err_free_out;\r\ninblock.data = (char *) inblockdata;\r\ninblock.len = blocksize;\r\noutblock.data = (char *) outblockdata;\r\noutblock.len = blocksize;\r\nif (in_constant->len == inblock.len) {\r\nmemcpy(inblock.data, in_constant->data, inblock.len);\r\n} else {\r\nkrb5_nfold(in_constant->len * 8, in_constant->data,\r\ninblock.len * 8, inblock.data);\r\n}\r\nn = 0;\r\nwhile (n < keybytes) {\r\n(*(gk5e->encrypt))(cipher, NULL, inblock.data,\r\noutblock.data, inblock.len);\r\nif ((keybytes - n) <= outblock.len) {\r\nmemcpy(rawkey + n, outblock.data, (keybytes - n));\r\nbreak;\r\n}\r\nmemcpy(rawkey + n, outblock.data, outblock.len);\r\nmemcpy(inblock.data, outblock.data, outblock.len);\r\nn += outblock.len;\r\n}\r\ninblock.data = (char *) rawkey;\r\ninblock.len = keybytes;\r\nBUG_ON(gk5e->mk_key == NULL);\r\nret = (*(gk5e->mk_key))(gk5e, &inblock, outkey);\r\nif (ret) {\r\ndprintk("%s: got %d from mk_key function for '%s'\n",\r\n__func__, ret, gk5e->encrypt_name);\r\ngoto err_free_raw;\r\n}\r\nret = 0;\r\nerr_free_raw:\r\nmemset(rawkey, 0, keybytes);\r\nkfree(rawkey);\r\nerr_free_out:\r\nmemset(outblockdata, 0, blocksize);\r\nkfree(outblockdata);\r\nerr_free_in:\r\nmemset(inblockdata, 0, blocksize);\r\nkfree(inblockdata);\r\nerr_free_cipher:\r\ncrypto_free_skcipher(cipher);\r\nerr_return:\r\nreturn ret;\r\n}\r\nstatic void mit_des_fixup_key_parity(u8 key[8])\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nkey[i] &= 0xfe;\r\nkey[i] |= 1^parity_char(key[i]);\r\n}\r\n}\r\nu32 gss_krb5_des3_make_key(const struct gss_krb5_enctype *gk5e,\r\nstruct xdr_netobj *randombits,\r\nstruct xdr_netobj *key)\r\n{\r\nint i;\r\nu32 ret = EINVAL;\r\nif (key->len != 24) {\r\ndprintk("%s: key->len is %d\n", __func__, key->len);\r\ngoto err_out;\r\n}\r\nif (randombits->len != 21) {\r\ndprintk("%s: randombits->len is %d\n",\r\n__func__, randombits->len);\r\ngoto err_out;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nmemcpy(key->data + i*8, randombits->data + i*7, 7);\r\nkey->data[i*8+7] = (((key->data[i*8]&1)<<1) |\r\n((key->data[i*8+1]&1)<<2) |\r\n((key->data[i*8+2]&1)<<3) |\r\n((key->data[i*8+3]&1)<<4) |\r\n((key->data[i*8+4]&1)<<5) |\r\n((key->data[i*8+5]&1)<<6) |\r\n((key->data[i*8+6]&1)<<7));\r\nmit_des_fixup_key_parity(key->data + i*8);\r\n}\r\nret = 0;\r\nerr_out:\r\nreturn ret;\r\n}\r\nu32 gss_krb5_aes_make_key(const struct gss_krb5_enctype *gk5e,\r\nstruct xdr_netobj *randombits,\r\nstruct xdr_netobj *key)\r\n{\r\nu32 ret = EINVAL;\r\nif (key->len != 16 && key->len != 32) {\r\ndprintk("%s: key->len is %d\n", __func__, key->len);\r\ngoto err_out;\r\n}\r\nif (randombits->len != 16 && randombits->len != 32) {\r\ndprintk("%s: randombits->len is %d\n",\r\n__func__, randombits->len);\r\ngoto err_out;\r\n}\r\nif (randombits->len != key->len) {\r\ndprintk("%s: randombits->len is %d, key->len is %d\n",\r\n__func__, randombits->len, key->len);\r\ngoto err_out;\r\n}\r\nmemcpy(key->data, randombits->data, key->len);\r\nret = 0;\r\nerr_out:\r\nreturn ret;\r\n}
