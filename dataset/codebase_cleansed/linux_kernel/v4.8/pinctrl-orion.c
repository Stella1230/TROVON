static int orion_mpp_ctrl_get(unsigned pid, unsigned long *config)\r\n{\r\nunsigned shift = (pid % MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\r\nif (pid < 16) {\r\nunsigned off = (pid / MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\r\n*config = (readl(mpp_base + off) >> shift) & MVEBU_MPP_MASK;\r\n}\r\nelse {\r\n*config = (readl(high_mpp_base) >> shift) & MVEBU_MPP_MASK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int orion_mpp_ctrl_set(unsigned pid, unsigned long config)\r\n{\r\nunsigned shift = (pid % MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\r\nif (pid < 16) {\r\nunsigned off = (pid / MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\r\nu32 reg = readl(mpp_base + off) & ~(MVEBU_MPP_MASK << shift);\r\nwritel(reg | (config << shift), mpp_base + off);\r\n}\r\nelse {\r\nu32 reg = readl(high_mpp_base) & ~(MVEBU_MPP_MASK << shift);\r\nwritel(reg | (config << shift), high_mpp_base);\r\n}\r\nreturn 0;\r\n}\r\nstatic int orion_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match =\r\nof_match_device(orion_pinctrl_of_match, &pdev->dev);\r\nstruct resource *res;\r\npdev->dev.platform_data = (void*)match->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmpp_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mpp_base))\r\nreturn PTR_ERR(mpp_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nhigh_mpp_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(high_mpp_base))\r\nreturn PTR_ERR(high_mpp_base);\r\nreturn mvebu_pinctrl_probe(pdev);\r\n}
