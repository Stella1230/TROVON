static bool match_i2c(struct v4l2_subdev *sd, struct v4l2_async_subdev *asd)\r\n{\r\n#if IS_ENABLED(CONFIG_I2C)\r\nstruct i2c_client *client = i2c_verify_client(sd->dev);\r\nreturn client &&\r\nasd->match.i2c.adapter_id == client->adapter->nr &&\r\nasd->match.i2c.address == client->addr;\r\n#else\r\nreturn false;\r\n#endif\r\n}\r\nstatic bool match_devname(struct v4l2_subdev *sd,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nreturn !strcmp(asd->match.device_name.name, dev_name(sd->dev));\r\n}\r\nstatic bool match_of(struct v4l2_subdev *sd, struct v4l2_async_subdev *asd)\r\n{\r\nreturn sd->of_node == asd->match.of.node;\r\n}\r\nstatic bool match_custom(struct v4l2_subdev *sd, struct v4l2_async_subdev *asd)\r\n{\r\nif (!asd->match.custom.match)\r\nreturn true;\r\nreturn asd->match.custom.match(sd->dev, asd);\r\n}\r\nstatic struct v4l2_async_subdev *v4l2_async_belongs(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *sd)\r\n{\r\nbool (*match)(struct v4l2_subdev *, struct v4l2_async_subdev *);\r\nstruct v4l2_async_subdev *asd;\r\nlist_for_each_entry(asd, &notifier->waiting, list) {\r\nswitch (asd->match_type) {\r\ncase V4L2_ASYNC_MATCH_CUSTOM:\r\nmatch = match_custom;\r\nbreak;\r\ncase V4L2_ASYNC_MATCH_DEVNAME:\r\nmatch = match_devname;\r\nbreak;\r\ncase V4L2_ASYNC_MATCH_I2C:\r\nmatch = match_i2c;\r\nbreak;\r\ncase V4L2_ASYNC_MATCH_OF:\r\nmatch = match_of;\r\nbreak;\r\ndefault:\r\nWARN_ON(true);\r\nreturn NULL;\r\n}\r\nif (match(sd, asd))\r\nreturn asd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int v4l2_async_test_notify(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *sd,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nint ret;\r\nlist_del(&asd->list);\r\nsd->asd = asd;\r\nsd->notifier = notifier;\r\nif (notifier->bound) {\r\nret = notifier->bound(notifier, sd, asd);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nlist_move(&sd->async_list, &notifier->done);\r\nret = v4l2_device_register_subdev(notifier->v4l2_dev, sd);\r\nif (ret < 0) {\r\nif (notifier->unbind)\r\nnotifier->unbind(notifier, sd, asd);\r\nreturn ret;\r\n}\r\nret = v4l2_subdev_call(sd, core, registered_async);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\nif (notifier->unbind)\r\nnotifier->unbind(notifier, sd, asd);\r\nreturn ret;\r\n}\r\nif (list_empty(&notifier->waiting) && notifier->complete)\r\nreturn notifier->complete(notifier);\r\nreturn 0;\r\n}\r\nstatic void v4l2_async_cleanup(struct v4l2_subdev *sd)\r\n{\r\nv4l2_device_unregister_subdev(sd);\r\nlist_del_init(&sd->async_list);\r\nsd->asd = NULL;\r\nsd->dev = NULL;\r\n}\r\nint v4l2_async_notifier_register(struct v4l2_device *v4l2_dev,\r\nstruct v4l2_async_notifier *notifier)\r\n{\r\nstruct v4l2_subdev *sd, *tmp;\r\nstruct v4l2_async_subdev *asd;\r\nint i;\r\nif (!notifier->num_subdevs || notifier->num_subdevs > V4L2_MAX_SUBDEVS)\r\nreturn -EINVAL;\r\nnotifier->v4l2_dev = v4l2_dev;\r\nINIT_LIST_HEAD(&notifier->waiting);\r\nINIT_LIST_HEAD(&notifier->done);\r\nfor (i = 0; i < notifier->num_subdevs; i++) {\r\nasd = notifier->subdevs[i];\r\nswitch (asd->match_type) {\r\ncase V4L2_ASYNC_MATCH_CUSTOM:\r\ncase V4L2_ASYNC_MATCH_DEVNAME:\r\ncase V4L2_ASYNC_MATCH_I2C:\r\ncase V4L2_ASYNC_MATCH_OF:\r\nbreak;\r\ndefault:\r\ndev_err(notifier->v4l2_dev ? notifier->v4l2_dev->dev : NULL,\r\n"Invalid match type %u on %p\n",\r\nasd->match_type, asd);\r\nreturn -EINVAL;\r\n}\r\nlist_add_tail(&asd->list, &notifier->waiting);\r\n}\r\nmutex_lock(&list_lock);\r\nlist_add(&notifier->list, &notifier_list);\r\nlist_for_each_entry_safe(sd, tmp, &subdev_list, async_list) {\r\nint ret;\r\nasd = v4l2_async_belongs(notifier, sd);\r\nif (!asd)\r\ncontinue;\r\nret = v4l2_async_test_notify(notifier, sd, asd);\r\nif (ret < 0) {\r\nmutex_unlock(&list_lock);\r\nreturn ret;\r\n}\r\n}\r\nmutex_unlock(&list_lock);\r\nreturn 0;\r\n}\r\nvoid v4l2_async_notifier_unregister(struct v4l2_async_notifier *notifier)\r\n{\r\nstruct v4l2_subdev *sd, *tmp;\r\nunsigned int notif_n_subdev = notifier->num_subdevs;\r\nunsigned int n_subdev = min(notif_n_subdev, V4L2_MAX_SUBDEVS);\r\nstruct device **dev;\r\nint i = 0;\r\nif (!notifier->v4l2_dev)\r\nreturn;\r\ndev = kmalloc(n_subdev * sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(notifier->v4l2_dev->dev,\r\n"Failed to allocate device cache!\n");\r\n}\r\nmutex_lock(&list_lock);\r\nlist_del(&notifier->list);\r\nlist_for_each_entry_safe(sd, tmp, &notifier->done, async_list) {\r\nstruct device *d;\r\nd = get_device(sd->dev);\r\nv4l2_async_cleanup(sd);\r\ndevice_release_driver(d);\r\nif (notifier->unbind)\r\nnotifier->unbind(notifier, sd, sd->asd);\r\nif (dev)\r\ndev[i++] = d;\r\nelse\r\nput_device(d);\r\n}\r\nmutex_unlock(&list_lock);\r\nwhile (i--) {\r\nstruct device *d = dev[i];\r\nif (d && device_attach(d) < 0) {\r\nconst char *name = "(none)";\r\nint lock = device_trylock(d);\r\nif (lock && d->driver)\r\nname = d->driver->name;\r\ndev_err(d, "Failed to re-probe to %s\n", name);\r\nif (lock)\r\ndevice_unlock(d);\r\n}\r\nput_device(d);\r\n}\r\nkfree(dev);\r\nnotifier->v4l2_dev = NULL;\r\n}\r\nint v4l2_async_register_subdev(struct v4l2_subdev *sd)\r\n{\r\nstruct v4l2_async_notifier *notifier;\r\nif (!sd->of_node && sd->dev)\r\nsd->of_node = sd->dev->of_node;\r\nmutex_lock(&list_lock);\r\nINIT_LIST_HEAD(&sd->async_list);\r\nlist_for_each_entry(notifier, &notifier_list, list) {\r\nstruct v4l2_async_subdev *asd = v4l2_async_belongs(notifier, sd);\r\nif (asd) {\r\nint ret = v4l2_async_test_notify(notifier, sd, asd);\r\nmutex_unlock(&list_lock);\r\nreturn ret;\r\n}\r\n}\r\nlist_add(&sd->async_list, &subdev_list);\r\nmutex_unlock(&list_lock);\r\nreturn 0;\r\n}\r\nvoid v4l2_async_unregister_subdev(struct v4l2_subdev *sd)\r\n{\r\nstruct v4l2_async_notifier *notifier = sd->notifier;\r\nif (!sd->asd) {\r\nif (!list_empty(&sd->async_list))\r\nv4l2_async_cleanup(sd);\r\nreturn;\r\n}\r\nmutex_lock(&list_lock);\r\nlist_add(&sd->asd->list, &notifier->waiting);\r\nv4l2_async_cleanup(sd);\r\nif (notifier->unbind)\r\nnotifier->unbind(notifier, sd, sd->asd);\r\nmutex_unlock(&list_lock);\r\n}
