static int s3c2410_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nif (section)\r\nreturn -ERANGE;\r\noobregion->offset = 0;\r\noobregion->length = 3;\r\nreturn 0;\r\n}\r\nstatic int s3c2410_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nif (section)\r\nreturn -ERANGE;\r\noobregion->offset = 8;\r\noobregion->length = 8;\r\nreturn 0;\r\n}\r\nstatic struct s3c2410_nand_mtd *s3c2410_nand_mtd_toours(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd_to_nand(mtd), struct s3c2410_nand_mtd,\r\nchip);\r\n}\r\nstatic struct s3c2410_nand_info *s3c2410_nand_mtd_toinfo(struct mtd_info *mtd)\r\n{\r\nreturn s3c2410_nand_mtd_toours(mtd)->info;\r\n}\r\nstatic struct s3c2410_nand_info *to_nand_info(struct platform_device *dev)\r\n{\r\nreturn platform_get_drvdata(dev);\r\n}\r\nstatic struct s3c2410_platform_nand *to_nand_plat(struct platform_device *dev)\r\n{\r\nreturn dev_get_platdata(&dev->dev);\r\n}\r\nstatic inline int allow_clk_suspend(struct s3c2410_nand_info *info)\r\n{\r\n#ifdef CONFIG_MTD_NAND_S3C2410_CLKSTOP\r\nreturn 1;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic void s3c2410_nand_clk_set_state(struct s3c2410_nand_info *info,\r\nenum s3c_nand_clk_state new_state)\r\n{\r\nif (!allow_clk_suspend(info) && new_state == CLOCK_SUSPEND)\r\nreturn;\r\nif (info->clk_state == CLOCK_ENABLE) {\r\nif (new_state != CLOCK_ENABLE)\r\nclk_disable_unprepare(info->clk);\r\n} else {\r\nif (new_state == CLOCK_ENABLE)\r\nclk_prepare_enable(info->clk);\r\n}\r\ninfo->clk_state = new_state;\r\n}\r\nstatic int s3c_nand_calc_rate(int wanted, unsigned long clk, int max)\r\n{\r\nint result;\r\nresult = DIV_ROUND_UP((wanted * clk), NS_IN_KHZ);\r\npr_debug("result %d from %ld, %d\n", result, clk, wanted);\r\nif (result > max) {\r\npr_err("%d ns is too big for current clock rate %ld\n",\r\nwanted, clk);\r\nreturn -1;\r\n}\r\nif (result < 1)\r\nresult = 1;\r\nreturn result;\r\n}\r\nstatic int s3c2410_nand_setrate(struct s3c2410_nand_info *info)\r\n{\r\nstruct s3c2410_platform_nand *plat = info->platform;\r\nint tacls_max = (info->cpu_type == TYPE_S3C2412) ? 8 : 4;\r\nint tacls, twrph0, twrph1;\r\nunsigned long clkrate = clk_get_rate(info->clk);\r\nunsigned long uninitialized_var(set), cfg, uninitialized_var(mask);\r\nunsigned long flags;\r\ninfo->clk_rate = clkrate;\r\nclkrate /= 1000;\r\nif (plat != NULL) {\r\ntacls = s3c_nand_calc_rate(plat->tacls, clkrate, tacls_max);\r\ntwrph0 = s3c_nand_calc_rate(plat->twrph0, clkrate, 8);\r\ntwrph1 = s3c_nand_calc_rate(plat->twrph1, clkrate, 8);\r\n} else {\r\ntacls = tacls_max;\r\ntwrph0 = 8;\r\ntwrph1 = 8;\r\n}\r\nif (tacls < 0 || twrph0 < 0 || twrph1 < 0) {\r\ndev_err(info->device, "cannot get suitable timings\n");\r\nreturn -EINVAL;\r\n}\r\ndev_info(info->device, "Tacls=%d, %dns Twrph0=%d %dns, Twrph1=%d %dns\n",\r\ntacls, to_ns(tacls, clkrate), twrph0, to_ns(twrph0, clkrate),\r\ntwrph1, to_ns(twrph1, clkrate));\r\nswitch (info->cpu_type) {\r\ncase TYPE_S3C2410:\r\nmask = (S3C2410_NFCONF_TACLS(3) |\r\nS3C2410_NFCONF_TWRPH0(7) |\r\nS3C2410_NFCONF_TWRPH1(7));\r\nset = S3C2410_NFCONF_EN;\r\nset |= S3C2410_NFCONF_TACLS(tacls - 1);\r\nset |= S3C2410_NFCONF_TWRPH0(twrph0 - 1);\r\nset |= S3C2410_NFCONF_TWRPH1(twrph1 - 1);\r\nbreak;\r\ncase TYPE_S3C2440:\r\ncase TYPE_S3C2412:\r\nmask = (S3C2440_NFCONF_TACLS(tacls_max - 1) |\r\nS3C2440_NFCONF_TWRPH0(7) |\r\nS3C2440_NFCONF_TWRPH1(7));\r\nset = S3C2440_NFCONF_TACLS(tacls - 1);\r\nset |= S3C2440_NFCONF_TWRPH0(twrph0 - 1);\r\nset |= S3C2440_NFCONF_TWRPH1(twrph1 - 1);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nlocal_irq_save(flags);\r\ncfg = readl(info->regs + S3C2410_NFCONF);\r\ncfg &= ~mask;\r\ncfg |= set;\r\nwritel(cfg, info->regs + S3C2410_NFCONF);\r\nlocal_irq_restore(flags);\r\ndev_dbg(info->device, "NF_CONF is 0x%lx\n", cfg);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_nand_inithw(struct s3c2410_nand_info *info)\r\n{\r\nint ret;\r\nret = s3c2410_nand_setrate(info);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (info->cpu_type) {\r\ncase TYPE_S3C2410:\r\ndefault:\r\nbreak;\r\ncase TYPE_S3C2440:\r\ncase TYPE_S3C2412:\r\nwritel(S3C2440_NFCONT_ENABLE, info->regs + S3C2440_NFCONT);\r\n}\r\nreturn 0;\r\n}\r\nstatic void s3c2410_nand_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct s3c2410_nand_info *info;\r\nstruct s3c2410_nand_mtd *nmtd;\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nunsigned long cur;\r\nnmtd = nand_get_controller_data(this);\r\ninfo = nmtd->info;\r\nif (chip != -1)\r\ns3c2410_nand_clk_set_state(info, CLOCK_ENABLE);\r\ncur = readl(info->sel_reg);\r\nif (chip == -1) {\r\ncur |= info->sel_bit;\r\n} else {\r\nif (nmtd->set != NULL && chip > nmtd->set->nr_chips) {\r\ndev_err(info->device, "invalid chip %d\n", chip);\r\nreturn;\r\n}\r\nif (info->platform != NULL) {\r\nif (info->platform->select_chip != NULL)\r\n(info->platform->select_chip) (nmtd->set, chip);\r\n}\r\ncur &= ~info->sel_bit;\r\n}\r\nwritel(cur, info->sel_reg);\r\nif (chip == -1)\r\ns3c2410_nand_clk_set_state(info, CLOCK_SUSPEND);\r\n}\r\nstatic void s3c2410_nand_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, info->regs + S3C2410_NFCMD);\r\nelse\r\nwriteb(cmd, info->regs + S3C2410_NFADDR);\r\n}\r\nstatic void s3c2440_nand_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, info->regs + S3C2440_NFCMD);\r\nelse\r\nwriteb(cmd, info->regs + S3C2440_NFADDR);\r\n}\r\nstatic int s3c2410_nand_devready(struct mtd_info *mtd)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nreturn readb(info->regs + S3C2410_NFSTAT) & S3C2410_NFSTAT_BUSY;\r\n}\r\nstatic int s3c2440_nand_devready(struct mtd_info *mtd)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nreturn readb(info->regs + S3C2440_NFSTAT) & S3C2440_NFSTAT_READY;\r\n}\r\nstatic int s3c2412_nand_devready(struct mtd_info *mtd)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nreturn readb(info->regs + S3C2412_NFSTAT) & S3C2412_NFSTAT_READY;\r\n}\r\nstatic int s3c2410_nand_correct_data(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nunsigned int diff0, diff1, diff2;\r\nunsigned int bit, byte;\r\npr_debug("%s(%p,%p,%p,%p)\n", __func__, mtd, dat, read_ecc, calc_ecc);\r\ndiff0 = read_ecc[0] ^ calc_ecc[0];\r\ndiff1 = read_ecc[1] ^ calc_ecc[1];\r\ndiff2 = read_ecc[2] ^ calc_ecc[2];\r\npr_debug("%s: rd %*phN calc %*phN diff %02x%02x%02x\n",\r\n__func__, 3, read_ecc, 3, calc_ecc,\r\ndiff0, diff1, diff2);\r\nif (diff0 == 0 && diff1 == 0 && diff2 == 0)\r\nreturn 0;\r\nif (read_ecc[0] == 0xff && read_ecc[1] == 0xff && read_ecc[2] == 0xff\r\n&& info->platform->ignore_unset_ecc)\r\nreturn 0;\r\nif (((diff0 ^ (diff0 >> 1)) & 0x55) == 0x55 &&\r\n((diff1 ^ (diff1 >> 1)) & 0x55) == 0x55 &&\r\n((diff2 ^ (diff2 >> 1)) & 0x55) == 0x55) {\r\nbit = ((diff2 >> 3) & 1) |\r\n((diff2 >> 4) & 2) |\r\n((diff2 >> 5) & 4);\r\nbyte = ((diff2 << 7) & 0x100) |\r\n((diff1 << 0) & 0x80) |\r\n((diff1 << 1) & 0x40) |\r\n((diff1 << 2) & 0x20) |\r\n((diff1 << 3) & 0x10) |\r\n((diff0 >> 4) & 0x08) |\r\n((diff0 >> 3) & 0x04) |\r\n((diff0 >> 2) & 0x02) |\r\n((diff0 >> 1) & 0x01);\r\ndev_dbg(info->device, "correcting error bit %d, byte %d\n",\r\nbit, byte);\r\ndat[byte] ^= (1 << bit);\r\nreturn 1;\r\n}\r\ndiff0 |= (diff1 << 8);\r\ndiff0 |= (diff2 << 16);\r\nif ((diff0 & (diff0 - 1)) == 0)\r\nreturn 1;\r\nreturn -1;\r\n}\r\nstatic void s3c2410_nand_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nunsigned long ctrl;\r\nctrl = readl(info->regs + S3C2410_NFCONF);\r\nctrl |= S3C2410_NFCONF_INITECC;\r\nwritel(ctrl, info->regs + S3C2410_NFCONF);\r\n}\r\nstatic void s3c2412_nand_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nunsigned long ctrl;\r\nctrl = readl(info->regs + S3C2440_NFCONT);\r\nwritel(ctrl | S3C2412_NFCONT_INIT_MAIN_ECC,\r\ninfo->regs + S3C2440_NFCONT);\r\n}\r\nstatic void s3c2440_nand_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nunsigned long ctrl;\r\nctrl = readl(info->regs + S3C2440_NFCONT);\r\nwritel(ctrl | S3C2440_NFCONT_INITECC, info->regs + S3C2440_NFCONT);\r\n}\r\nstatic int s3c2410_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\necc_code[0] = readb(info->regs + S3C2410_NFECC + 0);\r\necc_code[1] = readb(info->regs + S3C2410_NFECC + 1);\r\necc_code[2] = readb(info->regs + S3C2410_NFECC + 2);\r\npr_debug("%s: returning ecc %*phN\n", __func__, 3, ecc_code);\r\nreturn 0;\r\n}\r\nstatic int s3c2412_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nunsigned long ecc = readl(info->regs + S3C2412_NFMECC0);\r\necc_code[0] = ecc;\r\necc_code[1] = ecc >> 8;\r\necc_code[2] = ecc >> 16;\r\npr_debug("%s: returning ecc %*phN\n", __func__, 3, ecc_code);\r\nreturn 0;\r\n}\r\nstatic int s3c2440_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nunsigned long ecc = readl(info->regs + S3C2440_NFMECC0);\r\necc_code[0] = ecc;\r\necc_code[1] = ecc >> 8;\r\necc_code[2] = ecc >> 16;\r\npr_debug("%s: returning ecc %06lx\n", __func__, ecc & 0xffffff);\r\nreturn 0;\r\n}\r\nstatic void s3c2410_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nreadsb(this->IO_ADDR_R, buf, len);\r\n}\r\nstatic void s3c2440_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nreadsl(info->regs + S3C2440_NFDATA, buf, len >> 2);\r\nif (len & 3) {\r\nbuf += len & ~3;\r\nfor (; len & 3; len--)\r\n*buf++ = readb(info->regs + S3C2440_NFDATA);\r\n}\r\n}\r\nstatic void s3c2410_nand_write_buf(struct mtd_info *mtd, const u_char *buf,\r\nint len)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nwritesb(this->IO_ADDR_W, buf, len);\r\n}\r\nstatic void s3c2440_nand_write_buf(struct mtd_info *mtd, const u_char *buf,\r\nint len)\r\n{\r\nstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\r\nwritesl(info->regs + S3C2440_NFDATA, buf, len >> 2);\r\nif (len & 3) {\r\nbuf += len & ~3;\r\nfor (; len & 3; len--, buf++)\r\nwriteb(*buf, info->regs + S3C2440_NFDATA);\r\n}\r\n}\r\nstatic int s3c2410_nand_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct s3c2410_nand_info *info;\r\nunsigned long newclk;\r\ninfo = container_of(nb, struct s3c2410_nand_info, freq_transition);\r\nnewclk = clk_get_rate(info->clk);\r\nif ((val == CPUFREQ_POSTCHANGE && newclk < info->clk_rate) ||\r\n(val == CPUFREQ_PRECHANGE && newclk > info->clk_rate)) {\r\ns3c2410_nand_setrate(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int s3c2410_nand_cpufreq_register(struct s3c2410_nand_info *info)\r\n{\r\ninfo->freq_transition.notifier_call = s3c2410_nand_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&info->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void\r\ns3c2410_nand_cpufreq_deregister(struct s3c2410_nand_info *info)\r\n{\r\ncpufreq_unregister_notifier(&info->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline int s3c2410_nand_cpufreq_register(struct s3c2410_nand_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void\r\ns3c2410_nand_cpufreq_deregister(struct s3c2410_nand_info *info)\r\n{\r\n}\r\nstatic int s3c24xx_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c2410_nand_info *info = to_nand_info(pdev);\r\nif (info == NULL)\r\nreturn 0;\r\ns3c2410_nand_cpufreq_deregister(info);\r\nif (info->mtds != NULL) {\r\nstruct s3c2410_nand_mtd *ptr = info->mtds;\r\nint mtdno;\r\nfor (mtdno = 0; mtdno < info->mtd_count; mtdno++, ptr++) {\r\npr_debug("releasing mtd %d (%p)\n", mtdno, ptr);\r\nnand_release(nand_to_mtd(&ptr->chip));\r\n}\r\n}\r\nif (!IS_ERR(info->clk))\r\ns3c2410_nand_clk_set_state(info, CLOCK_DISABLE);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_nand_add_partition(struct s3c2410_nand_info *info,\r\nstruct s3c2410_nand_mtd *mtd,\r\nstruct s3c2410_nand_set *set)\r\n{\r\nif (set) {\r\nstruct mtd_info *mtdinfo = nand_to_mtd(&mtd->chip);\r\nmtdinfo->name = set->name;\r\nreturn mtd_device_parse_register(mtdinfo, NULL, NULL,\r\nset->partitions, set->nr_partitions);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void s3c2410_nand_init_chip(struct s3c2410_nand_info *info,\r\nstruct s3c2410_nand_mtd *nmtd,\r\nstruct s3c2410_nand_set *set)\r\n{\r\nstruct nand_chip *chip = &nmtd->chip;\r\nvoid __iomem *regs = info->regs;\r\nchip->write_buf = s3c2410_nand_write_buf;\r\nchip->read_buf = s3c2410_nand_read_buf;\r\nchip->select_chip = s3c2410_nand_select_chip;\r\nchip->chip_delay = 50;\r\nnand_set_controller_data(chip, nmtd);\r\nchip->options = set->options;\r\nchip->controller = &info->controller;\r\nswitch (info->cpu_type) {\r\ncase TYPE_S3C2410:\r\nchip->IO_ADDR_W = regs + S3C2410_NFDATA;\r\ninfo->sel_reg = regs + S3C2410_NFCONF;\r\ninfo->sel_bit = S3C2410_NFCONF_nFCE;\r\nchip->cmd_ctrl = s3c2410_nand_hwcontrol;\r\nchip->dev_ready = s3c2410_nand_devready;\r\nbreak;\r\ncase TYPE_S3C2440:\r\nchip->IO_ADDR_W = regs + S3C2440_NFDATA;\r\ninfo->sel_reg = regs + S3C2440_NFCONT;\r\ninfo->sel_bit = S3C2440_NFCONT_nFCE;\r\nchip->cmd_ctrl = s3c2440_nand_hwcontrol;\r\nchip->dev_ready = s3c2440_nand_devready;\r\nchip->read_buf = s3c2440_nand_read_buf;\r\nchip->write_buf = s3c2440_nand_write_buf;\r\nbreak;\r\ncase TYPE_S3C2412:\r\nchip->IO_ADDR_W = regs + S3C2440_NFDATA;\r\ninfo->sel_reg = regs + S3C2440_NFCONT;\r\ninfo->sel_bit = S3C2412_NFCONT_nFCE0;\r\nchip->cmd_ctrl = s3c2440_nand_hwcontrol;\r\nchip->dev_ready = s3c2412_nand_devready;\r\nif (readl(regs + S3C2410_NFCONF) & S3C2412_NFCONF_NANDBOOT)\r\ndev_info(info->device, "System booted from NAND\n");\r\nbreak;\r\n}\r\nchip->IO_ADDR_R = chip->IO_ADDR_W;\r\nnmtd->info = info;\r\nnmtd->set = set;\r\n#ifdef CONFIG_MTD_NAND_S3C2410_HWECC\r\nchip->ecc.calculate = s3c2410_nand_calculate_ecc;\r\nchip->ecc.correct = s3c2410_nand_correct_data;\r\nchip->ecc.mode = NAND_ECC_HW;\r\nchip->ecc.strength = 1;\r\nswitch (info->cpu_type) {\r\ncase TYPE_S3C2410:\r\nchip->ecc.hwctl = s3c2410_nand_enable_hwecc;\r\nchip->ecc.calculate = s3c2410_nand_calculate_ecc;\r\nbreak;\r\ncase TYPE_S3C2412:\r\nchip->ecc.hwctl = s3c2412_nand_enable_hwecc;\r\nchip->ecc.calculate = s3c2412_nand_calculate_ecc;\r\nbreak;\r\ncase TYPE_S3C2440:\r\nchip->ecc.hwctl = s3c2440_nand_enable_hwecc;\r\nchip->ecc.calculate = s3c2440_nand_calculate_ecc;\r\nbreak;\r\n}\r\n#else\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\nchip->ecc.algo = NAND_ECC_HAMMING;\r\n#endif\r\nif (set->disable_ecc)\r\nchip->ecc.mode = NAND_ECC_NONE;\r\nswitch (chip->ecc.mode) {\r\ncase NAND_ECC_NONE:\r\ndev_info(info->device, "NAND ECC disabled\n");\r\nbreak;\r\ncase NAND_ECC_SOFT:\r\ndev_info(info->device, "NAND soft ECC\n");\r\nbreak;\r\ncase NAND_ECC_HW:\r\ndev_info(info->device, "NAND hardware ECC\n");\r\nbreak;\r\ndefault:\r\ndev_info(info->device, "NAND ECC UNKNOWN\n");\r\nbreak;\r\n}\r\nif (set->flash_bbt) {\r\nchip->bbt_options |= NAND_BBT_USE_FLASH;\r\nchip->options |= NAND_SKIP_BBTSCAN;\r\n}\r\n}\r\nstatic void s3c2410_nand_update_chip(struct s3c2410_nand_info *info,\r\nstruct s3c2410_nand_mtd *nmtd)\r\n{\r\nstruct nand_chip *chip = &nmtd->chip;\r\ndev_dbg(info->device, "chip %p => page shift %d\n",\r\nchip, chip->page_shift);\r\nif (chip->ecc.mode != NAND_ECC_HW)\r\nreturn;\r\nif (chip->page_shift > 10) {\r\nchip->ecc.size = 256;\r\nchip->ecc.bytes = 3;\r\n} else {\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 3;\r\nmtd_set_ooblayout(nand_to_mtd(chip), &s3c2410_ooblayout_ops);\r\n}\r\n}\r\nstatic int s3c24xx_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c2410_platform_nand *plat = to_nand_plat(pdev);\r\nenum s3c_cpu_type cpu_type;\r\nstruct s3c2410_nand_info *info;\r\nstruct s3c2410_nand_mtd *nmtd;\r\nstruct s3c2410_nand_set *sets;\r\nstruct resource *res;\r\nint err = 0;\r\nint size;\r\nint nr_sets;\r\nint setno;\r\ncpu_type = platform_get_device_id(pdev)->driver_data;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (info == NULL) {\r\nerr = -ENOMEM;\r\ngoto exit_error;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nspin_lock_init(&info->controller.lock);\r\ninit_waitqueue_head(&info->controller.wq);\r\ninfo->clk = devm_clk_get(&pdev->dev, "nand");\r\nif (IS_ERR(info->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nerr = -ENOENT;\r\ngoto exit_error;\r\n}\r\ns3c2410_nand_clk_set_state(info, CLOCK_ENABLE);\r\nres = pdev->resource;\r\nsize = resource_size(res);\r\ninfo->device = &pdev->dev;\r\ninfo->platform = plat;\r\ninfo->cpu_type = cpu_type;\r\ninfo->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(info->regs)) {\r\nerr = PTR_ERR(info->regs);\r\ngoto exit_error;\r\n}\r\ndev_dbg(&pdev->dev, "mapped registers at %p\n", info->regs);\r\nerr = s3c2410_nand_inithw(info);\r\nif (err != 0)\r\ngoto exit_error;\r\nsets = (plat != NULL) ? plat->sets : NULL;\r\nnr_sets = (plat != NULL) ? plat->nr_sets : 1;\r\ninfo->mtd_count = nr_sets;\r\nsize = nr_sets * sizeof(*info->mtds);\r\ninfo->mtds = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\r\nif (info->mtds == NULL) {\r\nerr = -ENOMEM;\r\ngoto exit_error;\r\n}\r\nnmtd = info->mtds;\r\nfor (setno = 0; setno < nr_sets; setno++, nmtd++) {\r\nstruct mtd_info *mtd = nand_to_mtd(&nmtd->chip);\r\npr_debug("initialising set %d (%p, info %p)\n",\r\nsetno, nmtd, info);\r\nmtd->dev.parent = &pdev->dev;\r\ns3c2410_nand_init_chip(info, nmtd, sets);\r\nnmtd->scan_res = nand_scan_ident(mtd,\r\n(sets) ? sets->nr_chips : 1,\r\nNULL);\r\nif (nmtd->scan_res == 0) {\r\ns3c2410_nand_update_chip(info, nmtd);\r\nnand_scan_tail(mtd);\r\ns3c2410_nand_add_partition(info, nmtd, sets);\r\n}\r\nif (sets != NULL)\r\nsets++;\r\n}\r\nerr = s3c2410_nand_cpufreq_register(info);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to init cpufreq support\n");\r\ngoto exit_error;\r\n}\r\nif (allow_clk_suspend(info)) {\r\ndev_info(&pdev->dev, "clock idle support enabled\n");\r\ns3c2410_nand_clk_set_state(info, CLOCK_SUSPEND);\r\n}\r\nreturn 0;\r\nexit_error:\r\ns3c24xx_nand_remove(pdev);\r\nif (err == 0)\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nstatic int s3c24xx_nand_suspend(struct platform_device *dev, pm_message_t pm)\r\n{\r\nstruct s3c2410_nand_info *info = platform_get_drvdata(dev);\r\nif (info) {\r\ninfo->save_sel = readl(info->sel_reg);\r\nwritel(info->save_sel | info->sel_bit, info->sel_reg);\r\ns3c2410_nand_clk_set_state(info, CLOCK_DISABLE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_nand_resume(struct platform_device *dev)\r\n{\r\nstruct s3c2410_nand_info *info = platform_get_drvdata(dev);\r\nunsigned long sel;\r\nif (info) {\r\ns3c2410_nand_clk_set_state(info, CLOCK_ENABLE);\r\ns3c2410_nand_inithw(info);\r\nsel = readl(info->sel_reg);\r\nsel &= ~info->sel_bit;\r\nsel |= info->save_sel & info->sel_bit;\r\nwritel(sel, info->sel_reg);\r\ns3c2410_nand_clk_set_state(info, CLOCK_SUSPEND);\r\n}\r\nreturn 0;\r\n}
