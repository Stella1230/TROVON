static inline struct mtk_dpi *mtk_dpi_from_encoder(struct drm_encoder *e)\r\n{\r\nreturn container_of(e, struct mtk_dpi, encoder);\r\n}\r\nstatic void mtk_dpi_mask(struct mtk_dpi *dpi, u32 offset, u32 val, u32 mask)\r\n{\r\nu32 tmp = readl(dpi->regs + offset) & ~mask;\r\ntmp |= (val & mask);\r\nwritel(tmp, dpi->regs + offset);\r\n}\r\nstatic void mtk_dpi_sw_reset(struct mtk_dpi *dpi, bool reset)\r\n{\r\nmtk_dpi_mask(dpi, DPI_RET, reset ? RST : 0, RST);\r\n}\r\nstatic void mtk_dpi_enable(struct mtk_dpi *dpi)\r\n{\r\nmtk_dpi_mask(dpi, DPI_EN, EN, EN);\r\n}\r\nstatic void mtk_dpi_disable(struct mtk_dpi *dpi)\r\n{\r\nmtk_dpi_mask(dpi, DPI_EN, 0, EN);\r\n}\r\nstatic void mtk_dpi_config_hsync(struct mtk_dpi *dpi,\r\nstruct mtk_dpi_sync_param *sync)\r\n{\r\nmtk_dpi_mask(dpi, DPI_TGEN_HWIDTH,\r\nsync->sync_width << HPW, HPW_MASK);\r\nmtk_dpi_mask(dpi, DPI_TGEN_HPORCH,\r\nsync->back_porch << HBP, HBP_MASK);\r\nmtk_dpi_mask(dpi, DPI_TGEN_HPORCH, sync->front_porch << HFP,\r\nHFP_MASK);\r\n}\r\nstatic void mtk_dpi_config_vsync(struct mtk_dpi *dpi,\r\nstruct mtk_dpi_sync_param *sync,\r\nu32 width_addr, u32 porch_addr)\r\n{\r\nmtk_dpi_mask(dpi, width_addr,\r\nsync->sync_width << VSYNC_WIDTH_SHIFT,\r\nVSYNC_WIDTH_MASK);\r\nmtk_dpi_mask(dpi, width_addr,\r\nsync->shift_half_line << VSYNC_HALF_LINE_SHIFT,\r\nVSYNC_HALF_LINE_MASK);\r\nmtk_dpi_mask(dpi, porch_addr,\r\nsync->back_porch << VSYNC_BACK_PORCH_SHIFT,\r\nVSYNC_BACK_PORCH_MASK);\r\nmtk_dpi_mask(dpi, porch_addr,\r\nsync->front_porch << VSYNC_FRONT_PORCH_SHIFT,\r\nVSYNC_FRONT_PORCH_MASK);\r\n}\r\nstatic void mtk_dpi_config_vsync_lodd(struct mtk_dpi *dpi,\r\nstruct mtk_dpi_sync_param *sync)\r\n{\r\nmtk_dpi_config_vsync(dpi, sync, DPI_TGEN_VWIDTH, DPI_TGEN_VPORCH);\r\n}\r\nstatic void mtk_dpi_config_vsync_leven(struct mtk_dpi *dpi,\r\nstruct mtk_dpi_sync_param *sync)\r\n{\r\nmtk_dpi_config_vsync(dpi, sync, DPI_TGEN_VWIDTH_LEVEN,\r\nDPI_TGEN_VPORCH_LEVEN);\r\n}\r\nstatic void mtk_dpi_config_vsync_rodd(struct mtk_dpi *dpi,\r\nstruct mtk_dpi_sync_param *sync)\r\n{\r\nmtk_dpi_config_vsync(dpi, sync, DPI_TGEN_VWIDTH_RODD,\r\nDPI_TGEN_VPORCH_RODD);\r\n}\r\nstatic void mtk_dpi_config_vsync_reven(struct mtk_dpi *dpi,\r\nstruct mtk_dpi_sync_param *sync)\r\n{\r\nmtk_dpi_config_vsync(dpi, sync, DPI_TGEN_VWIDTH_REVEN,\r\nDPI_TGEN_VPORCH_REVEN);\r\n}\r\nstatic void mtk_dpi_config_pol(struct mtk_dpi *dpi,\r\nstruct mtk_dpi_polarities *dpi_pol)\r\n{\r\nunsigned int pol;\r\npol = (dpi_pol->ck_pol == MTK_DPI_POLARITY_RISING ? 0 : CK_POL) |\r\n(dpi_pol->de_pol == MTK_DPI_POLARITY_RISING ? 0 : DE_POL) |\r\n(dpi_pol->hsync_pol == MTK_DPI_POLARITY_RISING ? 0 : HSYNC_POL) |\r\n(dpi_pol->vsync_pol == MTK_DPI_POLARITY_RISING ? 0 : VSYNC_POL);\r\nmtk_dpi_mask(dpi, DPI_OUTPUT_SETTING, pol,\r\nCK_POL | DE_POL | HSYNC_POL | VSYNC_POL);\r\n}\r\nstatic void mtk_dpi_config_3d(struct mtk_dpi *dpi, bool en_3d)\r\n{\r\nmtk_dpi_mask(dpi, DPI_CON, en_3d ? TDFP_EN : 0, TDFP_EN);\r\n}\r\nstatic void mtk_dpi_config_interface(struct mtk_dpi *dpi, bool inter)\r\n{\r\nmtk_dpi_mask(dpi, DPI_CON, inter ? INTL_EN : 0, INTL_EN);\r\n}\r\nstatic void mtk_dpi_config_fb_size(struct mtk_dpi *dpi, u32 width, u32 height)\r\n{\r\nmtk_dpi_mask(dpi, DPI_SIZE, width << HSIZE, HSIZE_MASK);\r\nmtk_dpi_mask(dpi, DPI_SIZE, height << VSIZE, VSIZE_MASK);\r\n}\r\nstatic void mtk_dpi_config_channel_limit(struct mtk_dpi *dpi,\r\nstruct mtk_dpi_yc_limit *limit)\r\n{\r\nmtk_dpi_mask(dpi, DPI_Y_LIMIT, limit->y_bottom << Y_LIMINT_BOT,\r\nY_LIMINT_BOT_MASK);\r\nmtk_dpi_mask(dpi, DPI_Y_LIMIT, limit->y_top << Y_LIMINT_TOP,\r\nY_LIMINT_TOP_MASK);\r\nmtk_dpi_mask(dpi, DPI_C_LIMIT, limit->c_bottom << C_LIMIT_BOT,\r\nC_LIMIT_BOT_MASK);\r\nmtk_dpi_mask(dpi, DPI_C_LIMIT, limit->c_top << C_LIMIT_TOP,\r\nC_LIMIT_TOP_MASK);\r\n}\r\nstatic void mtk_dpi_config_bit_num(struct mtk_dpi *dpi,\r\nenum mtk_dpi_out_bit_num num)\r\n{\r\nu32 val;\r\nswitch (num) {\r\ncase MTK_DPI_OUT_BIT_NUM_8BITS:\r\nval = OUT_BIT_8;\r\nbreak;\r\ncase MTK_DPI_OUT_BIT_NUM_10BITS:\r\nval = OUT_BIT_10;\r\nbreak;\r\ncase MTK_DPI_OUT_BIT_NUM_12BITS:\r\nval = OUT_BIT_12;\r\nbreak;\r\ncase MTK_DPI_OUT_BIT_NUM_16BITS:\r\nval = OUT_BIT_16;\r\nbreak;\r\ndefault:\r\nval = OUT_BIT_8;\r\nbreak;\r\n}\r\nmtk_dpi_mask(dpi, DPI_OUTPUT_SETTING, val << OUT_BIT,\r\nOUT_BIT_MASK);\r\n}\r\nstatic void mtk_dpi_config_yc_map(struct mtk_dpi *dpi,\r\nenum mtk_dpi_out_yc_map map)\r\n{\r\nu32 val;\r\nswitch (map) {\r\ncase MTK_DPI_OUT_YC_MAP_RGB:\r\nval = YC_MAP_RGB;\r\nbreak;\r\ncase MTK_DPI_OUT_YC_MAP_CYCY:\r\nval = YC_MAP_CYCY;\r\nbreak;\r\ncase MTK_DPI_OUT_YC_MAP_YCYC:\r\nval = YC_MAP_YCYC;\r\nbreak;\r\ncase MTK_DPI_OUT_YC_MAP_CY:\r\nval = YC_MAP_CY;\r\nbreak;\r\ncase MTK_DPI_OUT_YC_MAP_YC:\r\nval = YC_MAP_YC;\r\nbreak;\r\ndefault:\r\nval = YC_MAP_RGB;\r\nbreak;\r\n}\r\nmtk_dpi_mask(dpi, DPI_OUTPUT_SETTING, val << YC_MAP, YC_MAP_MASK);\r\n}\r\nstatic void mtk_dpi_config_channel_swap(struct mtk_dpi *dpi,\r\nenum mtk_dpi_out_channel_swap swap)\r\n{\r\nu32 val;\r\nswitch (swap) {\r\ncase MTK_DPI_OUT_CHANNEL_SWAP_RGB:\r\nval = SWAP_RGB;\r\nbreak;\r\ncase MTK_DPI_OUT_CHANNEL_SWAP_GBR:\r\nval = SWAP_GBR;\r\nbreak;\r\ncase MTK_DPI_OUT_CHANNEL_SWAP_BRG:\r\nval = SWAP_BRG;\r\nbreak;\r\ncase MTK_DPI_OUT_CHANNEL_SWAP_RBG:\r\nval = SWAP_RBG;\r\nbreak;\r\ncase MTK_DPI_OUT_CHANNEL_SWAP_GRB:\r\nval = SWAP_GRB;\r\nbreak;\r\ncase MTK_DPI_OUT_CHANNEL_SWAP_BGR:\r\nval = SWAP_BGR;\r\nbreak;\r\ndefault:\r\nval = SWAP_RGB;\r\nbreak;\r\n}\r\nmtk_dpi_mask(dpi, DPI_OUTPUT_SETTING, val << CH_SWAP, CH_SWAP_MASK);\r\n}\r\nstatic void mtk_dpi_config_yuv422_enable(struct mtk_dpi *dpi, bool enable)\r\n{\r\nmtk_dpi_mask(dpi, DPI_CON, enable ? YUV422_EN : 0, YUV422_EN);\r\n}\r\nstatic void mtk_dpi_config_csc_enable(struct mtk_dpi *dpi, bool enable)\r\n{\r\nmtk_dpi_mask(dpi, DPI_CON, enable ? CSC_ENABLE : 0, CSC_ENABLE);\r\n}\r\nstatic void mtk_dpi_config_swap_input(struct mtk_dpi *dpi, bool enable)\r\n{\r\nmtk_dpi_mask(dpi, DPI_CON, enable ? IN_RB_SWAP : 0, IN_RB_SWAP);\r\n}\r\nstatic void mtk_dpi_config_2n_h_fre(struct mtk_dpi *dpi)\r\n{\r\nmtk_dpi_mask(dpi, DPI_H_FRE_CON, H_FRE_2N, H_FRE_2N);\r\n}\r\nstatic void mtk_dpi_config_color_format(struct mtk_dpi *dpi,\r\nenum mtk_dpi_out_color_format format)\r\n{\r\nif ((format == MTK_DPI_COLOR_FORMAT_YCBCR_444) ||\r\n(format == MTK_DPI_COLOR_FORMAT_YCBCR_444_FULL)) {\r\nmtk_dpi_config_yuv422_enable(dpi, false);\r\nmtk_dpi_config_csc_enable(dpi, true);\r\nmtk_dpi_config_swap_input(dpi, false);\r\nmtk_dpi_config_channel_swap(dpi, MTK_DPI_OUT_CHANNEL_SWAP_BGR);\r\n} else if ((format == MTK_DPI_COLOR_FORMAT_YCBCR_422) ||\r\n(format == MTK_DPI_COLOR_FORMAT_YCBCR_422_FULL)) {\r\nmtk_dpi_config_yuv422_enable(dpi, true);\r\nmtk_dpi_config_csc_enable(dpi, true);\r\nmtk_dpi_config_swap_input(dpi, true);\r\nmtk_dpi_config_channel_swap(dpi, MTK_DPI_OUT_CHANNEL_SWAP_RGB);\r\n} else {\r\nmtk_dpi_config_yuv422_enable(dpi, false);\r\nmtk_dpi_config_csc_enable(dpi, false);\r\nmtk_dpi_config_swap_input(dpi, false);\r\nmtk_dpi_config_channel_swap(dpi, MTK_DPI_OUT_CHANNEL_SWAP_RGB);\r\n}\r\n}\r\nstatic void mtk_dpi_power_off(struct mtk_dpi *dpi, enum mtk_dpi_power_ctl pctl)\r\n{\r\ndpi->power_ctl &= ~pctl;\r\nif ((dpi->power_ctl & DPI_POWER_START) ||\r\n(dpi->power_ctl & DPI_POWER_ENABLE))\r\nreturn;\r\nif (!dpi->power_sta)\r\nreturn;\r\nmtk_dpi_disable(dpi);\r\nclk_disable_unprepare(dpi->pixel_clk);\r\nclk_disable_unprepare(dpi->engine_clk);\r\ndpi->power_sta = false;\r\n}\r\nstatic int mtk_dpi_power_on(struct mtk_dpi *dpi, enum mtk_dpi_power_ctl pctl)\r\n{\r\nint ret;\r\ndpi->power_ctl |= pctl;\r\nif (!(dpi->power_ctl & DPI_POWER_START) &&\r\n!(dpi->power_ctl & DPI_POWER_ENABLE))\r\nreturn 0;\r\nif (dpi->power_sta)\r\nreturn 0;\r\nret = clk_prepare_enable(dpi->engine_clk);\r\nif (ret) {\r\ndev_err(dpi->dev, "Failed to enable engine clock: %d\n", ret);\r\ngoto err_eng;\r\n}\r\nret = clk_prepare_enable(dpi->pixel_clk);\r\nif (ret) {\r\ndev_err(dpi->dev, "Failed to enable pixel clock: %d\n", ret);\r\ngoto err_pixel;\r\n}\r\nmtk_dpi_enable(dpi);\r\ndpi->power_sta = true;\r\nreturn 0;\r\nerr_pixel:\r\nclk_disable_unprepare(dpi->engine_clk);\r\nerr_eng:\r\ndpi->power_ctl &= ~pctl;\r\nreturn ret;\r\n}\r\nstatic int mtk_dpi_set_display_mode(struct mtk_dpi *dpi,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct mtk_dpi_yc_limit limit;\r\nstruct mtk_dpi_polarities dpi_pol;\r\nstruct mtk_dpi_sync_param hsync;\r\nstruct mtk_dpi_sync_param vsync_lodd = { 0 };\r\nstruct mtk_dpi_sync_param vsync_leven = { 0 };\r\nstruct mtk_dpi_sync_param vsync_rodd = { 0 };\r\nstruct mtk_dpi_sync_param vsync_reven = { 0 };\r\nunsigned long pix_rate;\r\nunsigned long pll_rate;\r\nunsigned int factor;\r\npix_rate = 1000UL * mode->clock;\r\nif (mode->clock <= 74000)\r\nfactor = 8 * 3;\r\nelse\r\nfactor = 4 * 3;\r\npll_rate = pix_rate * factor;\r\ndev_dbg(dpi->dev, "Want PLL %lu Hz, pixel clock %lu Hz\n",\r\npll_rate, pix_rate);\r\nclk_set_rate(dpi->tvd_clk, pll_rate);\r\npll_rate = clk_get_rate(dpi->tvd_clk);\r\npix_rate = pll_rate / factor;\r\nclk_set_rate(dpi->pixel_clk, pix_rate);\r\npix_rate = clk_get_rate(dpi->pixel_clk);\r\ndev_dbg(dpi->dev, "Got PLL %lu Hz, pixel clock %lu Hz\n",\r\npll_rate, pix_rate);\r\nlimit.c_bottom = 0x0010;\r\nlimit.c_top = 0x0FE0;\r\nlimit.y_bottom = 0x0010;\r\nlimit.y_top = 0x0FE0;\r\ndpi_pol.ck_pol = MTK_DPI_POLARITY_FALLING;\r\ndpi_pol.de_pol = MTK_DPI_POLARITY_RISING;\r\ndpi_pol.hsync_pol = mode->flags & DRM_MODE_FLAG_PHSYNC ?\r\nMTK_DPI_POLARITY_FALLING : MTK_DPI_POLARITY_RISING;\r\ndpi_pol.vsync_pol = mode->flags & DRM_MODE_FLAG_PVSYNC ?\r\nMTK_DPI_POLARITY_FALLING : MTK_DPI_POLARITY_RISING;\r\nhsync.sync_width = mode->hsync_end - mode->hsync_start;\r\nhsync.back_porch = mode->htotal - mode->hsync_end;\r\nhsync.front_porch = mode->hsync_start - mode->hdisplay;\r\nhsync.shift_half_line = false;\r\nvsync_lodd.sync_width = mode->vsync_end - mode->vsync_start;\r\nvsync_lodd.back_porch = mode->vtotal - mode->vsync_end;\r\nvsync_lodd.front_porch = mode->vsync_start - mode->vdisplay;\r\nvsync_lodd.shift_half_line = false;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE &&\r\nmode->flags & DRM_MODE_FLAG_3D_MASK) {\r\nvsync_leven = vsync_lodd;\r\nvsync_rodd = vsync_lodd;\r\nvsync_reven = vsync_lodd;\r\nvsync_leven.shift_half_line = true;\r\nvsync_reven.shift_half_line = true;\r\n} else if (mode->flags & DRM_MODE_FLAG_INTERLACE &&\r\n!(mode->flags & DRM_MODE_FLAG_3D_MASK)) {\r\nvsync_leven = vsync_lodd;\r\nvsync_leven.shift_half_line = true;\r\n} else if (!(mode->flags & DRM_MODE_FLAG_INTERLACE) &&\r\nmode->flags & DRM_MODE_FLAG_3D_MASK) {\r\nvsync_rodd = vsync_lodd;\r\n}\r\nmtk_dpi_sw_reset(dpi, true);\r\nmtk_dpi_config_pol(dpi, &dpi_pol);\r\nmtk_dpi_config_hsync(dpi, &hsync);\r\nmtk_dpi_config_vsync_lodd(dpi, &vsync_lodd);\r\nmtk_dpi_config_vsync_rodd(dpi, &vsync_rodd);\r\nmtk_dpi_config_vsync_leven(dpi, &vsync_leven);\r\nmtk_dpi_config_vsync_reven(dpi, &vsync_reven);\r\nmtk_dpi_config_3d(dpi, !!(mode->flags & DRM_MODE_FLAG_3D_MASK));\r\nmtk_dpi_config_interface(dpi, !!(mode->flags &\r\nDRM_MODE_FLAG_INTERLACE));\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nmtk_dpi_config_fb_size(dpi, mode->hdisplay, mode->vdisplay / 2);\r\nelse\r\nmtk_dpi_config_fb_size(dpi, mode->hdisplay, mode->vdisplay);\r\nmtk_dpi_config_channel_limit(dpi, &limit);\r\nmtk_dpi_config_bit_num(dpi, dpi->bit_num);\r\nmtk_dpi_config_channel_swap(dpi, dpi->channel_swap);\r\nmtk_dpi_config_yc_map(dpi, dpi->yc_map);\r\nmtk_dpi_config_color_format(dpi, dpi->color_format);\r\nmtk_dpi_config_2n_h_fre(dpi);\r\nmtk_dpi_sw_reset(dpi, false);\r\nreturn 0;\r\n}\r\nstatic void mtk_dpi_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nstatic bool mtk_dpi_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void mtk_dpi_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct mtk_dpi *dpi = mtk_dpi_from_encoder(encoder);\r\ndrm_mode_copy(&dpi->mode, adjusted_mode);\r\n}\r\nstatic void mtk_dpi_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct mtk_dpi *dpi = mtk_dpi_from_encoder(encoder);\r\nmtk_dpi_power_off(dpi, DPI_POWER_ENABLE);\r\n}\r\nstatic void mtk_dpi_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct mtk_dpi *dpi = mtk_dpi_from_encoder(encoder);\r\nmtk_dpi_power_on(dpi, DPI_POWER_ENABLE);\r\nmtk_dpi_set_display_mode(dpi, &dpi->mode);\r\n}\r\nstatic int mtk_dpi_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void mtk_dpi_start(struct mtk_ddp_comp *comp)\r\n{\r\nstruct mtk_dpi *dpi = container_of(comp, struct mtk_dpi, ddp_comp);\r\nmtk_dpi_power_on(dpi, DPI_POWER_START);\r\n}\r\nstatic void mtk_dpi_stop(struct mtk_ddp_comp *comp)\r\n{\r\nstruct mtk_dpi *dpi = container_of(comp, struct mtk_dpi, ddp_comp);\r\nmtk_dpi_power_off(dpi, DPI_POWER_START);\r\n}\r\nstatic int mtk_dpi_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct mtk_dpi *dpi = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nint ret;\r\nret = mtk_ddp_comp_register(drm_dev, &dpi->ddp_comp);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to register component %s: %d\n",\r\ndev->of_node->full_name, ret);\r\nreturn ret;\r\n}\r\nret = drm_encoder_init(drm_dev, &dpi->encoder, &mtk_dpi_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS, NULL);\r\nif (ret) {\r\ndev_err(dev, "Failed to initialize decoder: %d\n", ret);\r\ngoto err_unregister;\r\n}\r\ndrm_encoder_helper_add(&dpi->encoder, &mtk_dpi_encoder_helper_funcs);\r\ndpi->encoder.possible_crtcs = BIT(1);\r\ndpi->encoder.bridge->encoder = &dpi->encoder;\r\nret = drm_bridge_attach(dpi->encoder.dev, dpi->encoder.bridge);\r\nif (ret) {\r\ndev_err(dev, "Failed to attach bridge: %d\n", ret);\r\ngoto err_cleanup;\r\n}\r\ndpi->bit_num = MTK_DPI_OUT_BIT_NUM_8BITS;\r\ndpi->channel_swap = MTK_DPI_OUT_CHANNEL_SWAP_RGB;\r\ndpi->yc_map = MTK_DPI_OUT_YC_MAP_RGB;\r\ndpi->color_format = MTK_DPI_COLOR_FORMAT_RGB;\r\nreturn 0;\r\nerr_cleanup:\r\ndrm_encoder_cleanup(&dpi->encoder);\r\nerr_unregister:\r\nmtk_ddp_comp_unregister(drm_dev, &dpi->ddp_comp);\r\nreturn ret;\r\n}\r\nstatic void mtk_dpi_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct mtk_dpi *dpi = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\ndrm_encoder_cleanup(&dpi->encoder);\r\nmtk_ddp_comp_unregister(drm_dev, &dpi->ddp_comp);\r\n}\r\nstatic int mtk_dpi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mtk_dpi *dpi;\r\nstruct resource *mem;\r\nstruct device_node *ep, *bridge_node = NULL;\r\nint comp_id;\r\nint ret;\r\ndpi = devm_kzalloc(dev, sizeof(*dpi), GFP_KERNEL);\r\nif (!dpi)\r\nreturn -ENOMEM;\r\ndpi->dev = dev;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndpi->regs = devm_ioremap_resource(dev, mem);\r\nif (IS_ERR(dpi->regs)) {\r\nret = PTR_ERR(dpi->regs);\r\ndev_err(dev, "Failed to ioremap mem resource: %d\n", ret);\r\nreturn ret;\r\n}\r\ndpi->engine_clk = devm_clk_get(dev, "engine");\r\nif (IS_ERR(dpi->engine_clk)) {\r\nret = PTR_ERR(dpi->engine_clk);\r\ndev_err(dev, "Failed to get engine clock: %d\n", ret);\r\nreturn ret;\r\n}\r\ndpi->pixel_clk = devm_clk_get(dev, "pixel");\r\nif (IS_ERR(dpi->pixel_clk)) {\r\nret = PTR_ERR(dpi->pixel_clk);\r\ndev_err(dev, "Failed to get pixel clock: %d\n", ret);\r\nreturn ret;\r\n}\r\ndpi->tvd_clk = devm_clk_get(dev, "pll");\r\nif (IS_ERR(dpi->tvd_clk)) {\r\nret = PTR_ERR(dpi->tvd_clk);\r\ndev_err(dev, "Failed to get tvdpll clock: %d\n", ret);\r\nreturn ret;\r\n}\r\ndpi->irq = platform_get_irq(pdev, 0);\r\nif (dpi->irq <= 0) {\r\ndev_err(dev, "Failed to get irq: %d\n", dpi->irq);\r\nreturn -EINVAL;\r\n}\r\nep = of_graph_get_next_endpoint(dev->of_node, NULL);\r\nif (ep) {\r\nbridge_node = of_graph_get_remote_port_parent(ep);\r\nof_node_put(ep);\r\n}\r\nif (!bridge_node) {\r\ndev_err(dev, "Failed to find bridge node\n");\r\nreturn -ENODEV;\r\n}\r\ndev_info(dev, "Found bridge node: %s\n", bridge_node->full_name);\r\ndpi->encoder.bridge = of_drm_find_bridge(bridge_node);\r\nof_node_put(bridge_node);\r\nif (!dpi->encoder.bridge)\r\nreturn -EPROBE_DEFER;\r\ncomp_id = mtk_ddp_comp_get_id(dev->of_node, MTK_DPI);\r\nif (comp_id < 0) {\r\ndev_err(dev, "Failed to identify by alias: %d\n", comp_id);\r\nreturn comp_id;\r\n}\r\nret = mtk_ddp_comp_init(dev, dev->of_node, &dpi->ddp_comp, comp_id,\r\n&mtk_dpi_funcs);\r\nif (ret) {\r\ndev_err(dev, "Failed to initialize component: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, dpi);\r\nret = component_add(dev, &mtk_dpi_component_ops);\r\nif (ret) {\r\ndev_err(dev, "Failed to add component: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_dpi_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &mtk_dpi_component_ops);\r\nreturn 0;\r\n}
