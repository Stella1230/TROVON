static u32 rtc_read_lp_counter(struct snvs_rtc_data *data)\r\n{\r\nu64 read1, read2;\r\nu32 val;\r\ndo {\r\nregmap_read(data->regmap, data->offset + SNVS_LPSRTCMR, &val);\r\nread1 = val;\r\nread1 <<= 32;\r\nregmap_read(data->regmap, data->offset + SNVS_LPSRTCLR, &val);\r\nread1 |= val;\r\nregmap_read(data->regmap, data->offset + SNVS_LPSRTCMR, &val);\r\nread2 = val;\r\nread2 <<= 32;\r\nregmap_read(data->regmap, data->offset + SNVS_LPSRTCLR, &val);\r\nread2 |= val;\r\n} while (read1 != read2);\r\nreturn (u32) (read1 >> CNTR_TO_SECS_SH);\r\n}\r\nstatic void rtc_write_sync_lp(struct snvs_rtc_data *data)\r\n{\r\nu32 count1, count2, count3;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\ndo {\r\nregmap_read(data->regmap, data->offset + SNVS_LPSRTCLR, &count1);\r\nregmap_read(data->regmap, data->offset + SNVS_LPSRTCLR, &count2);\r\n} while (count1 != count2);\r\ndo {\r\ndo {\r\nregmap_read(data->regmap, data->offset + SNVS_LPSRTCLR, &count2);\r\nregmap_read(data->regmap, data->offset + SNVS_LPSRTCLR, &count3);\r\n} while (count2 != count3);\r\n} while (count3 == count1);\r\n}\r\n}\r\nstatic int snvs_rtc_enable(struct snvs_rtc_data *data, bool enable)\r\n{\r\nint timeout = 1000;\r\nu32 lpcr;\r\nregmap_update_bits(data->regmap, data->offset + SNVS_LPCR, SNVS_LPCR_SRTC_ENV,\r\nenable ? SNVS_LPCR_SRTC_ENV : 0);\r\nwhile (--timeout) {\r\nregmap_read(data->regmap, data->offset + SNVS_LPCR, &lpcr);\r\nif (enable) {\r\nif (lpcr & SNVS_LPCR_SRTC_ENV)\r\nbreak;\r\n} else {\r\nif (!(lpcr & SNVS_LPCR_SRTC_ENV))\r\nbreak;\r\n}\r\n}\r\nif (!timeout)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nunsigned long time = rtc_read_lp_counter(data);\r\nrtc_time_to_tm(time, tm);\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nunsigned long time;\r\nrtc_tm_to_time(tm, &time);\r\nsnvs_rtc_enable(data, false);\r\nregmap_write(data->regmap, data->offset + SNVS_LPSRTCLR, time << CNTR_TO_SECS_SH);\r\nregmap_write(data->regmap, data->offset + SNVS_LPSRTCMR, time >> (32 - CNTR_TO_SECS_SH));\r\nsnvs_rtc_enable(data, true);\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nu32 lptar, lpsr;\r\nregmap_read(data->regmap, data->offset + SNVS_LPTAR, &lptar);\r\nrtc_time_to_tm(lptar, &alrm->time);\r\nregmap_read(data->regmap, data->offset + SNVS_LPSR, &lpsr);\r\nalrm->pending = (lpsr & SNVS_LPSR_LPTA) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nregmap_update_bits(data->regmap, data->offset + SNVS_LPCR,\r\n(SNVS_LPCR_LPTA_EN | SNVS_LPCR_LPWUI_EN),\r\nenable ? (SNVS_LPCR_LPTA_EN | SNVS_LPCR_LPWUI_EN) : 0);\r\nrtc_write_sync_lp(data);\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nstruct rtc_time *alrm_tm = &alrm->time;\r\nunsigned long time;\r\nrtc_tm_to_time(alrm_tm, &time);\r\nregmap_update_bits(data->regmap, data->offset + SNVS_LPCR, SNVS_LPCR_LPTA_EN, 0);\r\nregmap_write(data->regmap, data->offset + SNVS_LPTAR, time);\r\nregmap_write(data->regmap, data->offset + SNVS_LPSR, SNVS_LPSR_LPTA);\r\nreturn snvs_rtc_alarm_irq_enable(dev, alrm->enabled);\r\n}\r\nstatic irqreturn_t snvs_rtc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct device *dev = dev_id;\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nu32 lpsr;\r\nu32 events = 0;\r\nregmap_read(data->regmap, data->offset + SNVS_LPSR, &lpsr);\r\nif (lpsr & SNVS_LPSR_LPTA) {\r\nevents |= (RTC_AF | RTC_IRQF);\r\nsnvs_rtc_alarm_irq_enable(dev, 0);\r\nrtc_update_irq(data->rtc, 1, events);\r\n}\r\nregmap_write(data->regmap, data->offset + SNVS_LPSR, lpsr);\r\nreturn events ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int snvs_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct snvs_rtc_data *data;\r\nstruct resource *res;\r\nint ret;\r\nvoid __iomem *mmio;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, "regmap");\r\nif (IS_ERR(data->regmap)) {\r\ndev_warn(&pdev->dev, "snvs rtc: you use old dts file, please update it\n");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmmio = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mmio))\r\nreturn PTR_ERR(mmio);\r\ndata->regmap = devm_regmap_init_mmio(&pdev->dev, mmio, &snvs_rtc_config);\r\n} else {\r\ndata->offset = SNVS_LPREGISTER_OFFSET;\r\nof_property_read_u32(pdev->dev.of_node, "offset", &data->offset);\r\n}\r\nif (!data->regmap) {\r\ndev_err(&pdev->dev, "Can't find snvs syscon\n");\r\nreturn -ENODEV;\r\n}\r\ndata->irq = platform_get_irq(pdev, 0);\r\nif (data->irq < 0)\r\nreturn data->irq;\r\ndata->clk = devm_clk_get(&pdev->dev, "snvs-rtc");\r\nif (IS_ERR(data->clk)) {\r\ndata->clk = NULL;\r\n} else {\r\nret = clk_prepare_enable(data->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not prepare or enable the snvs clock\n");\r\nreturn ret;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, data);\r\nregmap_write(data->regmap, data->offset + SNVS_LPPGDR, SNVS_LPPGDR_INIT);\r\nregmap_write(data->regmap, data->offset + SNVS_LPSR, 0xffffffff);\r\nsnvs_rtc_enable(data, true);\r\ndevice_init_wakeup(&pdev->dev, true);\r\nret = devm_request_irq(&pdev->dev, data->irq, snvs_rtc_irq_handler,\r\nIRQF_SHARED, "rtc alarm", &pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request irq %d: %d\n",\r\ndata->irq, ret);\r\ngoto error_rtc_device_register;\r\n}\r\ndata->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&snvs_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(data->rtc)) {\r\nret = PTR_ERR(data->rtc);\r\ndev_err(&pdev->dev, "failed to register rtc: %d\n", ret);\r\ngoto error_rtc_device_register;\r\n}\r\nreturn 0;\r\nerror_rtc_device_register:\r\nif (data->clk)\r\nclk_disable_unprepare(data->clk);\r\nreturn ret;\r\n}\r\nstatic int snvs_rtc_suspend(struct device *dev)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nreturn enable_irq_wake(data->irq);\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_suspend_noirq(struct device *dev)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nif (data->clk)\r\nclk_disable_unprepare(data->clk);\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_resume(struct device *dev)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nreturn disable_irq_wake(data->irq);\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_resume_noirq(struct device *dev)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nif (data->clk)\r\nreturn clk_prepare_enable(data->clk);\r\nreturn 0;\r\n}
