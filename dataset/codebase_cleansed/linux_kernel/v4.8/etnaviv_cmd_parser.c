void __init etnaviv_validate_init(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(etnaviv_sensitive_states); i++)\r\nbitmap_set(etnaviv_states, etnaviv_sensitive_states[i].offset,\r\netnaviv_sensitive_states[i].size);\r\n}\r\nstatic void etnaviv_warn_if_non_sensitive(struct etna_validation_state *state,\r\nunsigned int buf_offset, unsigned int state_addr)\r\n{\r\nif (state->num_relocs && state->relocs->submit_offset < buf_offset) {\r\ndev_warn_once(state->gpu->dev,\r\n"%s: relocation for non-sensitive state 0x%x at offset %u\n",\r\n__func__, state_addr,\r\nstate->relocs->submit_offset);\r\nwhile (state->num_relocs &&\r\nstate->relocs->submit_offset < buf_offset) {\r\nstate->relocs++;\r\nstate->num_relocs--;\r\n}\r\n}\r\n}\r\nstatic bool etnaviv_validate_load_state(struct etna_validation_state *state,\r\nu32 *ptr, unsigned int state_offset, unsigned int num)\r\n{\r\nunsigned int size = min(ETNAVIV_STATES_SIZE, state_offset + num);\r\nunsigned int st_offset = state_offset, buf_offset;\r\nfor_each_set_bit_from(st_offset, etnaviv_states, size) {\r\nbuf_offset = (ptr - state->start +\r\nst_offset - state_offset) * 4;\r\netnaviv_warn_if_non_sensitive(state, buf_offset, st_offset * 4);\r\nif (state->num_relocs &&\r\nstate->relocs->submit_offset == buf_offset) {\r\nstate->relocs++;\r\nstate->num_relocs--;\r\ncontinue;\r\n}\r\ndev_warn_ratelimited(state->gpu->dev,\r\n"%s: load state touches restricted state 0x%x at offset %u\n",\r\n__func__, st_offset * 4, buf_offset);\r\nreturn false;\r\n}\r\nif (state->num_relocs) {\r\nbuf_offset = (ptr - state->start + num) * 4;\r\netnaviv_warn_if_non_sensitive(state, buf_offset, st_offset * 4 +\r\nstate->relocs->submit_offset -\r\nbuf_offset);\r\n}\r\nreturn true;\r\n}\r\nbool etnaviv_cmd_validate_one(struct etnaviv_gpu *gpu, u32 *stream,\r\nunsigned int size,\r\nstruct drm_etnaviv_gem_submit_reloc *relocs,\r\nunsigned int reloc_size)\r\n{\r\nstruct etna_validation_state state;\r\nu32 *buf = stream;\r\nu32 *end = buf + size;\r\nstate.gpu = gpu;\r\nstate.relocs = relocs;\r\nstate.num_relocs = reloc_size;\r\nstate.start = stream;\r\nwhile (buf < end) {\r\nu32 cmd = *buf;\r\nunsigned int len, n, off;\r\nunsigned int op = cmd >> 27;\r\nswitch (op) {\r\ncase FE_OPCODE_LOAD_STATE:\r\nn = EXTRACT(cmd, VIV_FE_LOAD_STATE_HEADER_COUNT);\r\nlen = ALIGN(1 + n, 2);\r\nif (buf + len > end)\r\nbreak;\r\noff = EXTRACT(cmd, VIV_FE_LOAD_STATE_HEADER_OFFSET);\r\nif (!etnaviv_validate_load_state(&state, buf + 1,\r\noff, n))\r\nreturn false;\r\nbreak;\r\ncase FE_OPCODE_DRAW_2D:\r\nn = EXTRACT(cmd, VIV_FE_DRAW_2D_HEADER_COUNT);\r\nif (n == 0)\r\nn = 256;\r\nlen = 2 + n * 2;\r\nbreak;\r\ndefault:\r\nlen = cmd_length[op];\r\nif (len == 0) {\r\ndev_err(gpu->dev, "%s: op %u not permitted at offset %tu\n",\r\n__func__, op, buf - state.start);\r\nreturn false;\r\n}\r\nbreak;\r\n}\r\nbuf += len;\r\n}\r\nif (buf > end) {\r\ndev_err(gpu->dev, "%s: commands overflow end of buffer: %tu > %u\n",\r\n__func__, buf - state.start, size);\r\nreturn false;\r\n}\r\nreturn true;\r\n}
