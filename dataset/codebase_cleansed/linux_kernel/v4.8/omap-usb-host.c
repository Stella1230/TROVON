static inline void usbhs_write(void __iomem *base, u32 reg, u32 val)\r\n{\r\nwritel_relaxed(val, base + reg);\r\n}\r\nstatic inline u32 usbhs_read(void __iomem *base, u32 reg)\r\n{\r\nreturn readl_relaxed(base + reg);\r\n}\r\nstatic const int omap_usbhs_get_dt_port_mode(const char *mode)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(port_modes); i++) {\r\nif (!strcmp(mode, port_modes[i]))\r\nreturn i;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic struct platform_device *omap_usbhs_alloc_child(const char *name,\r\nstruct resource *res, int num_resources, void *pdata,\r\nsize_t pdata_size, struct device *dev)\r\n{\r\nstruct platform_device *child;\r\nint ret;\r\nchild = platform_device_alloc(name, 0);\r\nif (!child) {\r\ndev_err(dev, "platform_device_alloc %s failed\n", name);\r\ngoto err_end;\r\n}\r\nret = platform_device_add_resources(child, res, num_resources);\r\nif (ret) {\r\ndev_err(dev, "platform_device_add_resources failed\n");\r\ngoto err_alloc;\r\n}\r\nret = platform_device_add_data(child, pdata, pdata_size);\r\nif (ret) {\r\ndev_err(dev, "platform_device_add_data failed\n");\r\ngoto err_alloc;\r\n}\r\nchild->dev.dma_mask = &usbhs_dmamask;\r\ndma_set_coherent_mask(&child->dev, DMA_BIT_MASK(32));\r\nchild->dev.parent = dev;\r\nret = platform_device_add(child);\r\nif (ret) {\r\ndev_err(dev, "platform_device_add failed\n");\r\ngoto err_alloc;\r\n}\r\nreturn child;\r\nerr_alloc:\r\nplatform_device_put(child);\r\nerr_end:\r\nreturn NULL;\r\n}\r\nstatic int omap_usbhs_alloc_children(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usbhs_omap_platform_data *pdata = dev_get_platdata(dev);\r\nstruct platform_device *ehci;\r\nstruct platform_device *ohci;\r\nstruct resource *res;\r\nstruct resource resources[2];\r\nint ret;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ehci");\r\nif (!res) {\r\ndev_err(dev, "EHCI get resource IORESOURCE_MEM failed\n");\r\nret = -ENODEV;\r\ngoto err_end;\r\n}\r\nresources[0] = *res;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "ehci-irq");\r\nif (!res) {\r\ndev_err(dev, " EHCI get resource IORESOURCE_IRQ failed\n");\r\nret = -ENODEV;\r\ngoto err_end;\r\n}\r\nresources[1] = *res;\r\nehci = omap_usbhs_alloc_child(OMAP_EHCI_DEVICE, resources, 2, pdata,\r\nsizeof(*pdata), dev);\r\nif (!ehci) {\r\ndev_err(dev, "omap_usbhs_alloc_child failed\n");\r\nret = -ENOMEM;\r\ngoto err_end;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ohci");\r\nif (!res) {\r\ndev_err(dev, "OHCI get resource IORESOURCE_MEM failed\n");\r\nret = -ENODEV;\r\ngoto err_ehci;\r\n}\r\nresources[0] = *res;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "ohci-irq");\r\nif (!res) {\r\ndev_err(dev, "OHCI get resource IORESOURCE_IRQ failed\n");\r\nret = -ENODEV;\r\ngoto err_ehci;\r\n}\r\nresources[1] = *res;\r\nohci = omap_usbhs_alloc_child(OMAP_OHCI_DEVICE, resources, 2, pdata,\r\nsizeof(*pdata), dev);\r\nif (!ohci) {\r\ndev_err(dev, "omap_usbhs_alloc_child failed\n");\r\nret = -ENOMEM;\r\ngoto err_ehci;\r\n}\r\nreturn 0;\r\nerr_ehci:\r\nplatform_device_unregister(ehci);\r\nerr_end:\r\nreturn ret;\r\n}\r\nstatic bool is_ohci_port(enum usbhs_omap_port_mode pmode)\r\n{\r\nswitch (pmode) {\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int usbhs_runtime_resume(struct device *dev)\r\n{\r\nstruct usbhs_hcd_omap *omap = dev_get_drvdata(dev);\r\nstruct usbhs_omap_platform_data *pdata = omap->pdata;\r\nint i, r;\r\ndev_dbg(dev, "usbhs_runtime_resume\n");\r\nomap_tll_enable(pdata);\r\nif (!IS_ERR(omap->ehci_logic_fck))\r\nclk_prepare_enable(omap->ehci_logic_fck);\r\nfor (i = 0; i < omap->nports; i++) {\r\nswitch (pdata->port_mode[i]) {\r\ncase OMAP_EHCI_PORT_MODE_HSIC:\r\nif (!IS_ERR(omap->hsic60m_clk[i])) {\r\nr = clk_prepare_enable(omap->hsic60m_clk[i]);\r\nif (r) {\r\ndev_err(dev,\r\n"Can't enable port %d hsic60m clk:%d\n",\r\ni, r);\r\n}\r\n}\r\nif (!IS_ERR(omap->hsic480m_clk[i])) {\r\nr = clk_prepare_enable(omap->hsic480m_clk[i]);\r\nif (r) {\r\ndev_err(dev,\r\n"Can't enable port %d hsic480m clk:%d\n",\r\ni, r);\r\n}\r\n}\r\ncase OMAP_EHCI_PORT_MODE_TLL:\r\nif (!IS_ERR(omap->utmi_clk[i])) {\r\nr = clk_prepare_enable(omap->utmi_clk[i]);\r\nif (r) {\r\ndev_err(dev,\r\n"Can't enable port %d clk : %d\n",\r\ni, r);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbhs_runtime_suspend(struct device *dev)\r\n{\r\nstruct usbhs_hcd_omap *omap = dev_get_drvdata(dev);\r\nstruct usbhs_omap_platform_data *pdata = omap->pdata;\r\nint i;\r\ndev_dbg(dev, "usbhs_runtime_suspend\n");\r\nfor (i = 0; i < omap->nports; i++) {\r\nswitch (pdata->port_mode[i]) {\r\ncase OMAP_EHCI_PORT_MODE_HSIC:\r\nif (!IS_ERR(omap->hsic60m_clk[i]))\r\nclk_disable_unprepare(omap->hsic60m_clk[i]);\r\nif (!IS_ERR(omap->hsic480m_clk[i]))\r\nclk_disable_unprepare(omap->hsic480m_clk[i]);\r\ncase OMAP_EHCI_PORT_MODE_TLL:\r\nif (!IS_ERR(omap->utmi_clk[i]))\r\nclk_disable_unprepare(omap->utmi_clk[i]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (!IS_ERR(omap->ehci_logic_fck))\r\nclk_disable_unprepare(omap->ehci_logic_fck);\r\nomap_tll_disable(pdata);\r\nreturn 0;\r\n}\r\nstatic unsigned omap_usbhs_rev1_hostconfig(struct usbhs_hcd_omap *omap,\r\nunsigned reg)\r\n{\r\nstruct usbhs_omap_platform_data *pdata = omap->pdata;\r\nint i;\r\nfor (i = 0; i < omap->nports; i++) {\r\nswitch (pdata->port_mode[i]) {\r\ncase OMAP_USBHS_PORT_MODE_UNUSED:\r\nreg &= ~(OMAP_UHH_HOSTCONFIG_P1_CONNECT_STATUS << i);\r\nbreak;\r\ncase OMAP_EHCI_PORT_MODE_PHY:\r\nif (pdata->single_ulpi_bypass)\r\nbreak;\r\nif (i == 0)\r\nreg &= ~OMAP_UHH_HOSTCONFIG_ULPI_P1_BYPASS;\r\nelse\r\nreg &= ~(OMAP_UHH_HOSTCONFIG_ULPI_P2_BYPASS\r\n<< (i-1));\r\nbreak;\r\ndefault:\r\nif (pdata->single_ulpi_bypass)\r\nbreak;\r\nif (i == 0)\r\nreg |= OMAP_UHH_HOSTCONFIG_ULPI_P1_BYPASS;\r\nelse\r\nreg |= OMAP_UHH_HOSTCONFIG_ULPI_P2_BYPASS\r\n<< (i-1);\r\nbreak;\r\n}\r\n}\r\nif (pdata->single_ulpi_bypass) {\r\nreg |= OMAP_UHH_HOSTCONFIG_ULPI_BYPASS;\r\nfor (i = 0; i < omap->nports; i++) {\r\nif (is_ehci_phy_mode(pdata->port_mode[i])) {\r\nreg &= ~OMAP_UHH_HOSTCONFIG_ULPI_BYPASS;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn reg;\r\n}\r\nstatic unsigned omap_usbhs_rev2_hostconfig(struct usbhs_hcd_omap *omap,\r\nunsigned reg)\r\n{\r\nstruct usbhs_omap_platform_data *pdata = omap->pdata;\r\nint i;\r\nfor (i = 0; i < omap->nports; i++) {\r\nreg &= ~(OMAP4_P1_MODE_CLEAR << 2 * i);\r\nif (is_ehci_tll_mode(pdata->port_mode[i]) ||\r\n(is_ohci_port(pdata->port_mode[i])))\r\nreg |= OMAP4_P1_MODE_TLL << 2 * i;\r\nelse if (is_ehci_hsic_mode(pdata->port_mode[i]))\r\nreg |= OMAP4_P1_MODE_HSIC << 2 * i;\r\n}\r\nreturn reg;\r\n}\r\nstatic void omap_usbhs_init(struct device *dev)\r\n{\r\nstruct usbhs_hcd_omap *omap = dev_get_drvdata(dev);\r\nunsigned reg;\r\ndev_dbg(dev, "starting TI HSUSB Controller\n");\r\npm_runtime_get_sync(dev);\r\nreg = usbhs_read(omap->uhh_base, OMAP_UHH_HOSTCONFIG);\r\nreg |= (OMAP_UHH_HOSTCONFIG_INCR4_BURST_EN\r\n| OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN\r\n| OMAP_UHH_HOSTCONFIG_INCR16_BURST_EN);\r\nreg |= OMAP4_UHH_HOSTCONFIG_APP_START_CLK;\r\nreg &= ~OMAP_UHH_HOSTCONFIG_INCRX_ALIGN_EN;\r\nswitch (omap->usbhs_rev) {\r\ncase OMAP_USBHS_REV1:\r\nreg = omap_usbhs_rev1_hostconfig(omap, reg);\r\nbreak;\r\ncase OMAP_USBHS_REV2:\r\nreg = omap_usbhs_rev2_hostconfig(omap, reg);\r\nbreak;\r\ndefault:\r\nreg = omap_usbhs_rev2_hostconfig(omap, reg);\r\nbreak;\r\n}\r\nusbhs_write(omap->uhh_base, OMAP_UHH_HOSTCONFIG, reg);\r\ndev_dbg(dev, "UHH setup done, uhh_hostconfig=%x\n", reg);\r\npm_runtime_put_sync(dev);\r\n}\r\nstatic int usbhs_omap_get_dt_pdata(struct device *dev,\r\nstruct usbhs_omap_platform_data *pdata)\r\n{\r\nint ret, i;\r\nstruct device_node *node = dev->of_node;\r\nret = of_property_read_u32(node, "num-ports", &pdata->nports);\r\nif (ret)\r\npdata->nports = 0;\r\nif (pdata->nports > OMAP3_HS_USB_PORTS) {\r\ndev_warn(dev, "Too many num_ports <%d> in device tree. Max %d\n",\r\npdata->nports, OMAP3_HS_USB_PORTS);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < OMAP3_HS_USB_PORTS; i++) {\r\nchar prop[11];\r\nconst char *mode;\r\npdata->port_mode[i] = OMAP_USBHS_PORT_MODE_UNUSED;\r\nsnprintf(prop, sizeof(prop), "port%d-mode", i + 1);\r\nret = of_property_read_string(node, prop, &mode);\r\nif (ret < 0)\r\ncontinue;\r\nret = omap_usbhs_get_dt_port_mode(mode);\r\nif (ret < 0) {\r\ndev_warn(dev, "Invalid port%d-mode \"%s\" in device tree\n",\r\ni, mode);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(dev, "port%d-mode: %s -> %d\n", i, mode, ret);\r\npdata->port_mode[i] = ret;\r\n}\r\npdata->single_ulpi_bypass = of_property_read_bool(node,\r\n"single-ulpi-bypass");\r\nreturn 0;\r\n}\r\nstatic int usbhs_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usbhs_omap_platform_data *pdata = dev_get_platdata(dev);\r\nstruct usbhs_hcd_omap *omap;\r\nstruct resource *res;\r\nint ret = 0;\r\nint i;\r\nbool need_logic_fck;\r\nif (dev->of_node) {\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nret = usbhs_omap_get_dt_pdata(dev, pdata);\r\nif (ret)\r\nreturn ret;\r\ndev->platform_data = pdata;\r\n}\r\nif (!pdata) {\r\ndev_err(dev, "Missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdata->nports > OMAP3_HS_USB_PORTS) {\r\ndev_info(dev, "Too many num_ports <%d> in platform_data. Max %d\n",\r\npdata->nports, OMAP3_HS_USB_PORTS);\r\nreturn -ENODEV;\r\n}\r\nomap = devm_kzalloc(dev, sizeof(*omap), GFP_KERNEL);\r\nif (!omap) {\r\ndev_err(dev, "Memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nomap->uhh_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(omap->uhh_base))\r\nreturn PTR_ERR(omap->uhh_base);\r\nomap->pdata = pdata;\r\nomap_tll_init(pdata);\r\npm_runtime_enable(dev);\r\nplatform_set_drvdata(pdev, omap);\r\npm_runtime_get_sync(dev);\r\nomap->usbhs_rev = usbhs_read(omap->uhh_base, OMAP_UHH_REVISION);\r\npm_runtime_put_sync(dev);\r\nif (pdata->nports) {\r\nomap->nports = pdata->nports;\r\n} else {\r\nswitch (omap->usbhs_rev) {\r\ncase OMAP_USBHS_REV1:\r\nomap->nports = 3;\r\nbreak;\r\ncase OMAP_USBHS_REV2:\r\nomap->nports = 2;\r\nbreak;\r\ndefault:\r\nomap->nports = OMAP3_HS_USB_PORTS;\r\ndev_dbg(dev,\r\n"USB HOST Rev:0x%x not recognized, assuming %d ports\n",\r\nomap->usbhs_rev, omap->nports);\r\nbreak;\r\n}\r\npdata->nports = omap->nports;\r\n}\r\ni = sizeof(struct clk *) * omap->nports;\r\nomap->utmi_clk = devm_kzalloc(dev, i, GFP_KERNEL);\r\nomap->hsic480m_clk = devm_kzalloc(dev, i, GFP_KERNEL);\r\nomap->hsic60m_clk = devm_kzalloc(dev, i, GFP_KERNEL);\r\nif (!omap->utmi_clk || !omap->hsic480m_clk || !omap->hsic60m_clk) {\r\ndev_err(dev, "Memory allocation failed\n");\r\nret = -ENOMEM;\r\ngoto err_mem;\r\n}\r\nomap->ehci_logic_fck = ERR_PTR(-ENODEV);\r\nomap->init_60m_fclk = ERR_PTR(-ENODEV);\r\nomap->utmi_p1_gfclk = ERR_PTR(-ENODEV);\r\nomap->utmi_p2_gfclk = ERR_PTR(-ENODEV);\r\nomap->xclk60mhsp1_ck = ERR_PTR(-ENODEV);\r\nomap->xclk60mhsp2_ck = ERR_PTR(-ENODEV);\r\nfor (i = 0; i < omap->nports; i++) {\r\nomap->utmi_clk[i] = ERR_PTR(-ENODEV);\r\nomap->hsic480m_clk[i] = ERR_PTR(-ENODEV);\r\nomap->hsic60m_clk[i] = ERR_PTR(-ENODEV);\r\n}\r\nif (omap->usbhs_rev == OMAP_USBHS_REV1) {\r\nneed_logic_fck = false;\r\nfor (i = 0; i < omap->nports; i++) {\r\nif (is_ehci_phy_mode(pdata->port_mode[i]) ||\r\nis_ehci_tll_mode(pdata->port_mode[i]) ||\r\nis_ehci_hsic_mode(pdata->port_mode[i]))\r\nneed_logic_fck |= true;\r\n}\r\nif (need_logic_fck) {\r\nomap->ehci_logic_fck = devm_clk_get(dev,\r\n"usbhost_120m_fck");\r\nif (IS_ERR(omap->ehci_logic_fck)) {\r\nret = PTR_ERR(omap->ehci_logic_fck);\r\ndev_err(dev, "usbhost_120m_fck failed:%d\n",\r\nret);\r\ngoto err_mem;\r\n}\r\n}\r\ngoto initialize;\r\n}\r\nomap->utmi_p1_gfclk = devm_clk_get(dev, "utmi_p1_gfclk");\r\nif (IS_ERR(omap->utmi_p1_gfclk)) {\r\nret = PTR_ERR(omap->utmi_p1_gfclk);\r\ndev_err(dev, "utmi_p1_gfclk failed error:%d\n", ret);\r\ngoto err_mem;\r\n}\r\nomap->utmi_p2_gfclk = devm_clk_get(dev, "utmi_p2_gfclk");\r\nif (IS_ERR(omap->utmi_p2_gfclk)) {\r\nret = PTR_ERR(omap->utmi_p2_gfclk);\r\ndev_err(dev, "utmi_p2_gfclk failed error:%d\n", ret);\r\ngoto err_mem;\r\n}\r\nomap->xclk60mhsp1_ck = devm_clk_get(dev, "refclk_60m_ext_p1");\r\nif (IS_ERR(omap->xclk60mhsp1_ck)) {\r\nret = PTR_ERR(omap->xclk60mhsp1_ck);\r\ndev_err(dev, "refclk_60m_ext_p1 failed error:%d\n", ret);\r\ngoto err_mem;\r\n}\r\nomap->xclk60mhsp2_ck = devm_clk_get(dev, "refclk_60m_ext_p2");\r\nif (IS_ERR(omap->xclk60mhsp2_ck)) {\r\nret = PTR_ERR(omap->xclk60mhsp2_ck);\r\ndev_err(dev, "refclk_60m_ext_p2 failed error:%d\n", ret);\r\ngoto err_mem;\r\n}\r\nomap->init_60m_fclk = devm_clk_get(dev, "refclk_60m_int");\r\nif (IS_ERR(omap->init_60m_fclk)) {\r\nret = PTR_ERR(omap->init_60m_fclk);\r\ndev_err(dev, "refclk_60m_int failed error:%d\n", ret);\r\ngoto err_mem;\r\n}\r\nfor (i = 0; i < omap->nports; i++) {\r\nchar clkname[30];\r\nsnprintf(clkname, sizeof(clkname),\r\n"usb_host_hs_utmi_p%d_clk", i + 1);\r\nomap->utmi_clk[i] = devm_clk_get(dev, clkname);\r\nif (IS_ERR(omap->utmi_clk[i])) {\r\nret = PTR_ERR(omap->utmi_clk[i]);\r\ndev_err(dev, "Failed to get clock : %s : %d\n",\r\nclkname, ret);\r\ngoto err_mem;\r\n}\r\nsnprintf(clkname, sizeof(clkname),\r\n"usb_host_hs_hsic480m_p%d_clk", i + 1);\r\nomap->hsic480m_clk[i] = devm_clk_get(dev, clkname);\r\nif (IS_ERR(omap->hsic480m_clk[i])) {\r\nret = PTR_ERR(omap->hsic480m_clk[i]);\r\ndev_err(dev, "Failed to get clock : %s : %d\n",\r\nclkname, ret);\r\ngoto err_mem;\r\n}\r\nsnprintf(clkname, sizeof(clkname),\r\n"usb_host_hs_hsic60m_p%d_clk", i + 1);\r\nomap->hsic60m_clk[i] = devm_clk_get(dev, clkname);\r\nif (IS_ERR(omap->hsic60m_clk[i])) {\r\nret = PTR_ERR(omap->hsic60m_clk[i]);\r\ndev_err(dev, "Failed to get clock : %s : %d\n",\r\nclkname, ret);\r\ngoto err_mem;\r\n}\r\n}\r\nif (is_ehci_phy_mode(pdata->port_mode[0])) {\r\nret = clk_set_parent(omap->utmi_p1_gfclk,\r\nomap->xclk60mhsp1_ck);\r\nif (ret != 0) {\r\ndev_err(dev, "xclk60mhsp1_ck set parent failed: %d\n",\r\nret);\r\ngoto err_mem;\r\n}\r\n} else if (is_ehci_tll_mode(pdata->port_mode[0])) {\r\nret = clk_set_parent(omap->utmi_p1_gfclk,\r\nomap->init_60m_fclk);\r\nif (ret != 0) {\r\ndev_err(dev, "P0 init_60m_fclk set parent failed: %d\n",\r\nret);\r\ngoto err_mem;\r\n}\r\n}\r\nif (is_ehci_phy_mode(pdata->port_mode[1])) {\r\nret = clk_set_parent(omap->utmi_p2_gfclk,\r\nomap->xclk60mhsp2_ck);\r\nif (ret != 0) {\r\ndev_err(dev, "xclk60mhsp2_ck set parent failed: %d\n",\r\nret);\r\ngoto err_mem;\r\n}\r\n} else if (is_ehci_tll_mode(pdata->port_mode[1])) {\r\nret = clk_set_parent(omap->utmi_p2_gfclk,\r\nomap->init_60m_fclk);\r\nif (ret != 0) {\r\ndev_err(dev, "P1 init_60m_fclk set parent failed: %d\n",\r\nret);\r\ngoto err_mem;\r\n}\r\n}\r\ninitialize:\r\nomap_usbhs_init(dev);\r\nif (dev->of_node) {\r\nret = of_platform_populate(dev->of_node,\r\nusbhs_child_match_table, NULL, dev);\r\nif (ret) {\r\ndev_err(dev, "Failed to create DT children: %d\n", ret);\r\ngoto err_mem;\r\n}\r\n} else {\r\nret = omap_usbhs_alloc_children(pdev);\r\nif (ret) {\r\ndev_err(dev, "omap_usbhs_alloc_children failed: %d\n",\r\nret);\r\ngoto err_mem;\r\n}\r\n}\r\nreturn 0;\r\nerr_mem:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int usbhs_omap_remove_child(struct device *dev, void *data)\r\n{\r\ndev_info(dev, "unregistering\n");\r\nplatform_device_unregister(to_platform_device(dev));\r\nreturn 0;\r\n}\r\nstatic int usbhs_omap_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\ndevice_for_each_child(&pdev->dev, NULL, usbhs_omap_remove_child);\r\nreturn 0;\r\n}\r\nstatic int __init omap_usbhs_drvinit(void)\r\n{\r\nreturn platform_driver_probe(&usbhs_omap_driver, usbhs_omap_probe);\r\n}\r\nstatic void __exit omap_usbhs_drvexit(void)\r\n{\r\nplatform_driver_unregister(&usbhs_omap_driver);\r\n}
