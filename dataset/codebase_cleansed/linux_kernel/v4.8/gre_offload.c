static struct sk_buff *gre_gso_segment(struct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\nint tnl_hlen = skb_inner_mac_header(skb) - skb_transport_header(skb);\r\nstruct sk_buff *segs = ERR_PTR(-EINVAL);\r\nu16 mac_offset = skb->mac_header;\r\n__be16 protocol = skb->protocol;\r\nu16 mac_len = skb->mac_len;\r\nint gre_offset, outer_hlen;\r\nbool need_csum, ufo;\r\nif (!skb->encapsulation)\r\ngoto out;\r\nif (unlikely(tnl_hlen < sizeof(struct gre_base_hdr)))\r\ngoto out;\r\nif (unlikely(!pskb_may_pull(skb, tnl_hlen)))\r\ngoto out;\r\nskb->encapsulation = 0;\r\nSKB_GSO_CB(skb)->encap_level = 0;\r\n__skb_pull(skb, tnl_hlen);\r\nskb_reset_mac_header(skb);\r\nskb_set_network_header(skb, skb_inner_network_offset(skb));\r\nskb->mac_len = skb_inner_network_offset(skb);\r\nskb->protocol = skb->inner_protocol;\r\nneed_csum = !!(skb_shinfo(skb)->gso_type & SKB_GSO_GRE_CSUM);\r\nskb->encap_hdr_csum = need_csum;\r\nufo = !!(skb_shinfo(skb)->gso_type & SKB_GSO_UDP);\r\nfeatures &= skb->dev->hw_enc_features;\r\nif (ufo) {\r\nfeatures &= ~NETIF_F_CSUM_MASK;\r\nif (!need_csum)\r\nfeatures |= NETIF_F_HW_CSUM;\r\n}\r\nsegs = skb_mac_gso_segment(skb, features);\r\nif (IS_ERR_OR_NULL(segs)) {\r\nskb_gso_error_unwind(skb, protocol, tnl_hlen, mac_offset,\r\nmac_len);\r\ngoto out;\r\n}\r\nouter_hlen = skb_tnl_header_len(skb);\r\ngre_offset = outer_hlen - tnl_hlen;\r\nskb = segs;\r\ndo {\r\nstruct gre_base_hdr *greh;\r\n__sum16 *pcsum;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nskb_reset_inner_headers(skb);\r\nskb->encapsulation = 1;\r\n}\r\nskb->mac_len = mac_len;\r\nskb->protocol = protocol;\r\n__skb_push(skb, outer_hlen);\r\nskb_reset_mac_header(skb);\r\nskb_set_network_header(skb, mac_len);\r\nskb_set_transport_header(skb, gre_offset);\r\nif (!need_csum)\r\ncontinue;\r\ngreh = (struct gre_base_hdr *)skb_transport_header(skb);\r\npcsum = (__sum16 *)(greh + 1);\r\nif (skb_is_gso(skb)) {\r\nunsigned int partial_adj;\r\npartial_adj = skb->len + skb_headroom(skb) -\r\nSKB_GSO_CB(skb)->data_offset -\r\nskb_shinfo(skb)->gso_size;\r\n*pcsum = ~csum_fold((__force __wsum)htonl(partial_adj));\r\n} else {\r\n*pcsum = 0;\r\n}\r\n*(pcsum + 1) = 0;\r\n*pcsum = gso_make_checksum(skb, 0);\r\n} while ((skb = skb->next));\r\nout:\r\nreturn segs;\r\n}\r\nstatic struct sk_buff **gre_gro_receive(struct sk_buff **head,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff **pp = NULL;\r\nstruct sk_buff *p;\r\nconst struct gre_base_hdr *greh;\r\nunsigned int hlen, grehlen;\r\nunsigned int off;\r\nint flush = 1;\r\nstruct packet_offload *ptype;\r\n__be16 type;\r\nif (NAPI_GRO_CB(skb)->encap_mark)\r\ngoto out;\r\nNAPI_GRO_CB(skb)->encap_mark = 1;\r\noff = skb_gro_offset(skb);\r\nhlen = off + sizeof(*greh);\r\ngreh = skb_gro_header_fast(skb, off);\r\nif (skb_gro_header_hard(skb, hlen)) {\r\ngreh = skb_gro_header_slow(skb, hlen, off);\r\nif (unlikely(!greh))\r\ngoto out;\r\n}\r\nif ((greh->flags & ~(GRE_KEY|GRE_CSUM)) != 0)\r\ngoto out;\r\nif ((greh->flags & GRE_CSUM) && NAPI_GRO_CB(skb)->is_fou)\r\ngoto out;\r\ntype = greh->protocol;\r\nrcu_read_lock();\r\nptype = gro_find_receive_by_type(type);\r\nif (!ptype)\r\ngoto out_unlock;\r\ngrehlen = GRE_HEADER_SECTION;\r\nif (greh->flags & GRE_KEY)\r\ngrehlen += GRE_HEADER_SECTION;\r\nif (greh->flags & GRE_CSUM)\r\ngrehlen += GRE_HEADER_SECTION;\r\nhlen = off + grehlen;\r\nif (skb_gro_header_hard(skb, hlen)) {\r\ngreh = skb_gro_header_slow(skb, hlen, off);\r\nif (unlikely(!greh))\r\ngoto out_unlock;\r\n}\r\nif ((greh->flags & GRE_CSUM) && !NAPI_GRO_CB(skb)->flush) {\r\nif (skb_gro_checksum_simple_validate(skb))\r\ngoto out_unlock;\r\nskb_gro_checksum_try_convert(skb, IPPROTO_GRE, 0,\r\nnull_compute_pseudo);\r\n}\r\nfor (p = *head; p; p = p->next) {\r\nconst struct gre_base_hdr *greh2;\r\nif (!NAPI_GRO_CB(p)->same_flow)\r\ncontinue;\r\ngreh2 = (struct gre_base_hdr *)(p->data + off);\r\nif (greh2->flags != greh->flags ||\r\ngreh2->protocol != greh->protocol) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\nif (greh->flags & GRE_KEY) {\r\nif (*(__be32 *)(greh2+1) != *(__be32 *)(greh+1)) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\n}\r\n}\r\nskb_gro_pull(skb, grehlen);\r\nskb_gro_postpull_rcsum(skb, greh, grehlen);\r\npp = ptype->callbacks.gro_receive(head, skb);\r\nflush = 0;\r\nout_unlock:\r\nrcu_read_unlock();\r\nout:\r\nNAPI_GRO_CB(skb)->flush |= flush;\r\nreturn pp;\r\n}\r\nstatic int gre_gro_complete(struct sk_buff *skb, int nhoff)\r\n{\r\nstruct gre_base_hdr *greh = (struct gre_base_hdr *)(skb->data + nhoff);\r\nstruct packet_offload *ptype;\r\nunsigned int grehlen = sizeof(*greh);\r\nint err = -ENOENT;\r\n__be16 type;\r\nskb->encapsulation = 1;\r\nskb_shinfo(skb)->gso_type = SKB_GSO_GRE;\r\ntype = greh->protocol;\r\nif (greh->flags & GRE_KEY)\r\ngrehlen += GRE_HEADER_SECTION;\r\nif (greh->flags & GRE_CSUM)\r\ngrehlen += GRE_HEADER_SECTION;\r\nrcu_read_lock();\r\nptype = gro_find_complete_by_type(type);\r\nif (ptype)\r\nerr = ptype->callbacks.gro_complete(skb, nhoff + grehlen);\r\nrcu_read_unlock();\r\nskb_set_inner_mac_header(skb, nhoff + grehlen);\r\nreturn err;\r\n}\r\nstatic int __init gre_offload_init(void)\r\n{\r\nint err;\r\nerr = inet_add_offload(&gre_offload, IPPROTO_GRE);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (err)\r\nreturn err;\r\nerr = inet6_add_offload(&gre_offload, IPPROTO_GRE);\r\nif (err)\r\ninet_del_offload(&gre_offload, IPPROTO_GRE);\r\n#endif\r\nreturn err;\r\n}
