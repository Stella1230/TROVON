static struct of_dma *of_dma_find_controller(struct of_phandle_args *dma_spec)\r\n{\r\nstruct of_dma *ofdma;\r\nlist_for_each_entry(ofdma, &of_dma_list, of_dma_controllers)\r\nif (ofdma->of_node == dma_spec->np)\r\nreturn ofdma;\r\npr_debug("%s: can't find DMA controller %s\n", __func__,\r\ndma_spec->np->full_name);\r\nreturn NULL;\r\n}\r\nstatic struct dma_chan *of_dma_router_xlate(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nstruct dma_chan *chan;\r\nstruct of_dma *ofdma_target;\r\nstruct of_phandle_args dma_spec_target;\r\nvoid *route_data;\r\nmemcpy(&dma_spec_target, dma_spec, sizeof(dma_spec_target));\r\nroute_data = ofdma->of_dma_route_allocate(&dma_spec_target, ofdma);\r\nif (IS_ERR(route_data))\r\nreturn NULL;\r\nofdma_target = of_dma_find_controller(&dma_spec_target);\r\nif (!ofdma_target)\r\nreturn NULL;\r\nchan = ofdma_target->of_dma_xlate(&dma_spec_target, ofdma_target);\r\nif (chan) {\r\nchan->router = ofdma->dma_router;\r\nchan->route_data = route_data;\r\n} else {\r\nofdma->dma_router->route_free(ofdma->dma_router->dev,\r\nroute_data);\r\n}\r\nof_node_put(dma_spec_target.np);\r\nreturn chan;\r\n}\r\nvoid of_dma_controller_free(struct device_node *np)\r\n{\r\nstruct of_dma *ofdma;\r\nmutex_lock(&of_dma_lock);\r\nlist_for_each_entry(ofdma, &of_dma_list, of_dma_controllers)\r\nif (ofdma->of_node == np) {\r\nlist_del(&ofdma->of_dma_controllers);\r\nkfree(ofdma);\r\nbreak;\r\n}\r\nmutex_unlock(&of_dma_lock);\r\n}\r\nint of_dma_router_register(struct device_node *np,\r\nvoid *(*of_dma_route_allocate)\r\n(struct of_phandle_args *, struct of_dma *),\r\nstruct dma_router *dma_router)\r\n{\r\nstruct of_dma *ofdma;\r\nif (!np || !of_dma_route_allocate || !dma_router) {\r\npr_err("%s: not enough information provided\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nofdma = kzalloc(sizeof(*ofdma), GFP_KERNEL);\r\nif (!ofdma)\r\nreturn -ENOMEM;\r\nofdma->of_node = np;\r\nofdma->of_dma_xlate = of_dma_router_xlate;\r\nofdma->of_dma_route_allocate = of_dma_route_allocate;\r\nofdma->dma_router = dma_router;\r\nmutex_lock(&of_dma_lock);\r\nlist_add_tail(&ofdma->of_dma_controllers, &of_dma_list);\r\nmutex_unlock(&of_dma_lock);\r\nreturn 0;\r\n}\r\nstatic int of_dma_match_channel(struct device_node *np, const char *name,\r\nint index, struct of_phandle_args *dma_spec)\r\n{\r\nconst char *s;\r\nif (of_property_read_string_index(np, "dma-names", index, &s))\r\nreturn -ENODEV;\r\nif (strcmp(name, s))\r\nreturn -ENODEV;\r\nif (of_parse_phandle_with_args(np, "dmas", "#dma-cells", index,\r\ndma_spec))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstruct dma_chan *of_dma_request_slave_channel(struct device_node *np,\r\nconst char *name)\r\n{\r\nstruct of_phandle_args dma_spec;\r\nstruct of_dma *ofdma;\r\nstruct dma_chan *chan;\r\nint count, i, start;\r\nint ret_no_channel = -ENODEV;\r\nstatic atomic_t last_index;\r\nif (!np || !name) {\r\npr_err("%s: not enough information provided\n", __func__);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nif (!of_find_property(np, "dmas", NULL))\r\nreturn ERR_PTR(-ENODEV);\r\ncount = of_property_count_strings(np, "dma-names");\r\nif (count < 0) {\r\npr_err("%s: dma-names property of node '%s' missing or empty\n",\r\n__func__, np->full_name);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstart = atomic_inc_return(&last_index);\r\nfor (i = 0; i < count; i++) {\r\nif (of_dma_match_channel(np, name,\r\n(i + start) % count,\r\n&dma_spec))\r\ncontinue;\r\nmutex_lock(&of_dma_lock);\r\nofdma = of_dma_find_controller(&dma_spec);\r\nif (ofdma) {\r\nchan = ofdma->of_dma_xlate(&dma_spec, ofdma);\r\n} else {\r\nret_no_channel = -EPROBE_DEFER;\r\nchan = NULL;\r\n}\r\nmutex_unlock(&of_dma_lock);\r\nof_node_put(dma_spec.np);\r\nif (chan)\r\nreturn chan;\r\n}\r\nreturn ERR_PTR(ret_no_channel);\r\n}\r\nstruct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nint count = dma_spec->args_count;\r\nstruct of_dma_filter_info *info = ofdma->of_dma_data;\r\nif (!info || !info->filter_fn)\r\nreturn NULL;\r\nif (count != 1)\r\nreturn NULL;\r\nreturn dma_request_channel(info->dma_cap, info->filter_fn,\r\n&dma_spec->args[0]);\r\n}\r\nstruct dma_chan *of_dma_xlate_by_chan_id(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nstruct dma_device *dev = ofdma->of_dma_data;\r\nstruct dma_chan *chan, *candidate = NULL;\r\nif (!dev || dma_spec->args_count != 1)\r\nreturn NULL;\r\nlist_for_each_entry(chan, &dev->channels, device_node)\r\nif (chan->chan_id == dma_spec->args[0]) {\r\ncandidate = chan;\r\nbreak;\r\n}\r\nif (!candidate)\r\nreturn NULL;\r\nreturn dma_get_slave_channel(candidate);\r\n}
