static void xhci_rcar_start_gen2(struct usb_hcd *hcd)\r\n{\r\nwritel(RCAR_USB3_LCLK_ENA_VAL, hcd->regs + RCAR_USB3_LCLK);\r\nwritel(RCAR_USB3_CONF1_VAL, hcd->regs + RCAR_USB3_CONF1);\r\nwritel(RCAR_USB3_CONF2_VAL, hcd->regs + RCAR_USB3_CONF2);\r\nwritel(RCAR_USB3_CONF3_VAL, hcd->regs + RCAR_USB3_CONF3);\r\nwritel(RCAR_USB3_RX_POL_VAL, hcd->regs + RCAR_USB3_RX_POL);\r\nwritel(RCAR_USB3_TX_POL_VAL, hcd->regs + RCAR_USB3_TX_POL);\r\n}\r\nstatic int xhci_rcar_is_gen2(struct device *dev)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nreturn of_device_is_compatible(node, "renesas,xhci-r8a7790") ||\r\nof_device_is_compatible(node, "renesas,xhci-r8a7791") ||\r\nof_device_is_compatible(node, "renesas,xhci-r8a7793") ||\r\nof_device_is_compatible(node, "renensas,rcar-gen2-xhci");\r\n}\r\nstatic int xhci_rcar_is_gen3(struct device *dev)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nreturn of_device_is_compatible(node, "renesas,xhci-r8a7795") ||\r\nof_device_is_compatible(node, "renesas,rcar-gen3-xhci");\r\n}\r\nvoid xhci_rcar_start(struct usb_hcd *hcd)\r\n{\r\nu32 temp;\r\nif (hcd->regs != NULL) {\r\ntemp = readl(hcd->regs + RCAR_USB3_INT_ENA);\r\ntemp |= RCAR_USB3_INT_ENA_VAL;\r\nwritel(temp, hcd->regs + RCAR_USB3_INT_ENA);\r\nif (xhci_rcar_is_gen2(hcd->self.controller))\r\nxhci_rcar_start_gen2(hcd);\r\n}\r\n}\r\nstatic int xhci_rcar_download_firmware(struct usb_hcd *hcd)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nvoid __iomem *regs = hcd->regs;\r\nstruct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);\r\nconst struct firmware *fw;\r\nint retval, index, j, time;\r\nint timeout = 10000;\r\nu32 data, val, temp;\r\nretval = request_firmware(&fw, priv->firmware_name, dev);\r\nif (retval)\r\nreturn retval;\r\ntemp = readl(regs + RCAR_USB3_DL_CTRL);\r\ntemp |= RCAR_USB3_DL_CTRL_ENABLE;\r\nwritel(temp, regs + RCAR_USB3_DL_CTRL);\r\nfor (index = 0; index < fw->size; index += 4) {\r\nfor (data = 0, j = 3; j >= 0; j--) {\r\nif ((j + index) < fw->size)\r\ndata |= fw->data[index + j] << (8 * j);\r\n}\r\nwritel(data, regs + RCAR_USB3_FW_DATA0);\r\ntemp = readl(regs + RCAR_USB3_DL_CTRL);\r\ntemp |= RCAR_USB3_DL_CTRL_FW_SET_DATA0;\r\nwritel(temp, regs + RCAR_USB3_DL_CTRL);\r\nfor (time = 0; time < timeout; time++) {\r\nval = readl(regs + RCAR_USB3_DL_CTRL);\r\nif ((val & RCAR_USB3_DL_CTRL_FW_SET_DATA0) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (time == timeout) {\r\nretval = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\ntemp = readl(regs + RCAR_USB3_DL_CTRL);\r\ntemp &= ~RCAR_USB3_DL_CTRL_ENABLE;\r\nwritel(temp, regs + RCAR_USB3_DL_CTRL);\r\nfor (time = 0; time < timeout; time++) {\r\nval = readl(regs + RCAR_USB3_DL_CTRL);\r\nif (val & RCAR_USB3_DL_CTRL_FW_SUCCESS) {\r\nretval = 0;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nif (time == timeout)\r\nretval = -ETIMEDOUT;\r\nrelease_firmware(fw);\r\nreturn retval;\r\n}\r\nint xhci_rcar_init_quirk(struct usb_hcd *hcd)\r\n{\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nif (!hcd->regs)\r\nreturn 0;\r\nif (xhci_rcar_is_gen2(hcd->self.controller) ||\r\nxhci_rcar_is_gen3(hcd->self.controller))\r\nxhci->quirks |= XHCI_NO_64BIT_SUPPORT;\r\nreturn xhci_rcar_download_firmware(hcd);\r\n}
