static int pca9541_reg_write(struct i2c_client *client, u8 command, u8 val)\r\n{\r\nstruct i2c_adapter *adap = client->adapter;\r\nint ret;\r\nif (adap->algo->master_xfer) {\r\nstruct i2c_msg msg;\r\nchar buf[2];\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nbuf[0] = command;\r\nbuf[1] = val;\r\nmsg.buf = buf;\r\nret = __i2c_transfer(adap, &msg, 1);\r\n} else {\r\nunion i2c_smbus_data data;\r\ndata.byte = val;\r\nret = adap->algo->smbus_xfer(adap, client->addr,\r\nclient->flags,\r\nI2C_SMBUS_WRITE,\r\ncommand,\r\nI2C_SMBUS_BYTE_DATA, &data);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pca9541_reg_read(struct i2c_client *client, u8 command)\r\n{\r\nstruct i2c_adapter *adap = client->adapter;\r\nint ret;\r\nu8 val;\r\nif (adap->algo->master_xfer) {\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &command\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = &val\r\n}\r\n};\r\nret = __i2c_transfer(adap, msg, 2);\r\nif (ret == 2)\r\nret = val;\r\nelse if (ret >= 0)\r\nret = -EIO;\r\n} else {\r\nunion i2c_smbus_data data;\r\nret = adap->algo->smbus_xfer(adap, client->addr,\r\nclient->flags,\r\nI2C_SMBUS_READ,\r\ncommand,\r\nI2C_SMBUS_BYTE_DATA, &data);\r\nif (!ret)\r\nret = data.byte;\r\n}\r\nreturn ret;\r\n}\r\nstatic void pca9541_release_bus(struct i2c_client *client)\r\n{\r\nint reg;\r\nreg = pca9541_reg_read(client, PCA9541_CONTROL);\r\nif (reg >= 0 && !busoff(reg) && mybus(reg))\r\npca9541_reg_write(client, PCA9541_CONTROL,\r\n(reg & PCA9541_CTL_NBUSON) >> 1);\r\n}\r\nstatic int pca9541_arbitrate(struct i2c_client *client)\r\n{\r\nstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\r\nstruct pca9541 *data = i2c_mux_priv(muxc);\r\nint reg;\r\nreg = pca9541_reg_read(client, PCA9541_CONTROL);\r\nif (reg < 0)\r\nreturn reg;\r\nif (busoff(reg)) {\r\nint istat;\r\nistat = pca9541_reg_read(client, PCA9541_ISTAT);\r\nif (!(istat & PCA9541_ISTAT_NMYTEST)\r\n|| time_is_before_eq_jiffies(data->arb_timeout)) {\r\npca9541_reg_write(client,\r\nPCA9541_CONTROL,\r\npca9541_control[reg & 0x0f]\r\n| PCA9541_CTL_NTESTON);\r\ndata->select_timeout = SELECT_DELAY_SHORT;\r\n} else {\r\ndata->select_timeout = SELECT_DELAY_LONG * 2;\r\n}\r\n} else if (mybus(reg)) {\r\nif (reg & (PCA9541_CTL_NTESTON | PCA9541_CTL_BUSINIT))\r\npca9541_reg_write(client,\r\nPCA9541_CONTROL,\r\nreg & ~(PCA9541_CTL_NTESTON\r\n| PCA9541_CTL_BUSINIT));\r\nreturn 1;\r\n} else {\r\ndata->select_timeout = SELECT_DELAY_LONG;\r\nif (time_is_before_eq_jiffies(data->arb_timeout)) {\r\npca9541_reg_write(client,\r\nPCA9541_CONTROL,\r\npca9541_control[reg & 0x0f]\r\n| PCA9541_CTL_BUSINIT\r\n| PCA9541_CTL_NTESTON);\r\n} else {\r\nif (!(reg & PCA9541_CTL_NTESTON))\r\npca9541_reg_write(client,\r\nPCA9541_CONTROL,\r\nreg | PCA9541_CTL_NTESTON);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pca9541_select_chan(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct pca9541 *data = i2c_mux_priv(muxc);\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nunsigned long timeout = jiffies + ARB2_TIMEOUT;\r\ndata->arb_timeout = jiffies + ARB_TIMEOUT;\r\ndo {\r\nret = pca9541_arbitrate(client);\r\nif (ret)\r\nreturn ret < 0 ? ret : 0;\r\nif (data->select_timeout == SELECT_DELAY_SHORT)\r\nudelay(data->select_timeout);\r\nelse\r\nmsleep(data->select_timeout / 1000);\r\n} while (time_is_after_eq_jiffies(timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int pca9541_release_chan(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct pca9541 *data = i2c_mux_priv(muxc);\r\nstruct i2c_client *client = data->client;\r\npca9541_release_bus(client);\r\nreturn 0;\r\n}\r\nstatic int pca9541_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct pca954x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct i2c_mux_core *muxc;\r\nstruct pca9541 *data;\r\nint force;\r\nint ret;\r\nif (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\ni2c_lock_adapter(adap);\r\npca9541_release_bus(client);\r\ni2c_unlock_adapter(adap);\r\nforce = 0;\r\nif (pdata)\r\nforce = pdata->modes[0].adap_id;\r\nmuxc = i2c_mux_alloc(adap, &client->dev, 1, sizeof(*data), 0,\r\npca9541_select_chan, pca9541_release_chan);\r\nif (!muxc)\r\nreturn -ENOMEM;\r\ndata = i2c_mux_priv(muxc);\r\ndata->client = client;\r\ni2c_set_clientdata(client, muxc);\r\nret = i2c_mux_add_adapter(muxc, force, 0, 0);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to register master selector\n");\r\nreturn ret;\r\n}\r\ndev_info(&client->dev, "registered master selector for I2C %s\n",\r\nclient->name);\r\nreturn 0;\r\n}\r\nstatic int pca9541_remove(struct i2c_client *client)\r\n{\r\nstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\r\ni2c_mux_del_adapters(muxc);\r\nreturn 0;\r\n}
