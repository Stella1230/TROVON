static int lgdt3306a_write_reg(struct lgdt3306a_state *state, u16 reg, u8 val)\r\n{\r\nint ret;\r\nu8 buf[] = { reg >> 8, reg & 0xff, val };\r\nstruct i2c_msg msg = {\r\n.addr = state->cfg->i2c_addr, .flags = 0,\r\n.buf = buf, .len = 3,\r\n};\r\ndbg_reg("reg: 0x%04x, val: 0x%02x\n", reg, val);\r\nret = i2c_transfer(state->i2c_adap, &msg, 1);\r\nif (ret != 1) {\r\npr_err("error (addr %02x %02x <- %02x, err = %i)\n",\r\nmsg.buf[0], msg.buf[1], msg.buf[2], ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lgdt3306a_read_reg(struct lgdt3306a_state *state, u16 reg, u8 *val)\r\n{\r\nint ret;\r\nu8 reg_buf[] = { reg >> 8, reg & 0xff };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->cfg->i2c_addr,\r\n.flags = 0, .buf = reg_buf, .len = 2 },\r\n{ .addr = state->cfg->i2c_addr,\r\n.flags = I2C_M_RD, .buf = val, .len = 1 },\r\n};\r\nret = i2c_transfer(state->i2c_adap, msg, 2);\r\nif (ret != 2) {\r\npr_err("error (addr %02x reg %04x error (ret == %i)\n",\r\nstate->cfg->i2c_addr, reg, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EREMOTEIO;\r\n}\r\ndbg_reg("reg: 0x%04x, val: 0x%02x\n", reg, *val);\r\nreturn 0;\r\n}\r\nstatic int lgdt3306a_set_reg_bit(struct lgdt3306a_state *state,\r\nu16 reg, int bit, int onoff)\r\n{\r\nu8 val;\r\nint ret;\r\ndbg_reg("reg: 0x%04x, bit: %d, level: %d\n", reg, bit, onoff);\r\nret = lgdt3306a_read_reg(state, reg, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nval &= ~(1 << bit);\r\nval |= (onoff & 1) << bit;\r\nret = lgdt3306a_write_reg(state, reg, val);\r\nlg_chkerr(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_soft_reset(struct lgdt3306a_state *state)\r\n{\r\nint ret;\r\ndbg_info("\n");\r\nret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nmsleep(20);\r\nret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 1);\r\nlg_chkerr(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_mpeg_mode(struct lgdt3306a_state *state,\r\nenum lgdt3306a_mpeg_mode mode)\r\n{\r\nu8 val;\r\nint ret;\r\ndbg_info("(%d)\n", mode);\r\nret = lgdt3306a_set_reg_bit(state, 0x0071, 7,\r\nmode == LGDT3306A_MPEG_PARALLEL ? 1 : 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_reg_bit(state, 0x0071, 6, 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x0070, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nval |= 0x10;\r\nif (mode == LGDT3306A_MPEG_PARALLEL)\r\nval &= ~0x10;\r\nret = lgdt3306a_write_reg(state, 0x0070, val);\r\nlg_chkerr(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_mpeg_mode_polarity(struct lgdt3306a_state *state,\r\nenum lgdt3306a_tp_clock_edge edge,\r\nenum lgdt3306a_tp_valid_polarity valid)\r\n{\r\nu8 val;\r\nint ret;\r\ndbg_info("edge=%d, valid=%d\n", edge, valid);\r\nret = lgdt3306a_read_reg(state, 0x0070, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nval &= ~0x06;\r\nif (edge == LGDT3306A_TPCLK_RISING_EDGE)\r\nval |= 0x04;\r\nif (valid == LGDT3306A_TP_VALID_HIGH)\r\nval |= 0x02;\r\nret = lgdt3306a_write_reg(state, 0x0070, val);\r\nlg_chkerr(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_mpeg_tristate(struct lgdt3306a_state *state,\r\nint mode)\r\n{\r\nu8 val;\r\nint ret;\r\ndbg_info("(%d)\n", mode);\r\nif (mode) {\r\nret = lgdt3306a_read_reg(state, 0x0070, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nval &= ~0xa8;\r\nret = lgdt3306a_write_reg(state, 0x0070, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 1);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\n} else {\r\nret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x0070, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nval |= 0xa8;\r\nret = lgdt3306a_write_reg(state, 0x0070, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\ndbg_info("acquire=%d\n", acquire);\r\nreturn lgdt3306a_mpeg_tristate(state, acquire ? 0 : 1);\r\n}\r\nstatic int lgdt3306a_power(struct lgdt3306a_state *state,\r\nint mode)\r\n{\r\nint ret;\r\ndbg_info("(%d)\n", mode);\r\nif (mode == 0) {\r\nret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\n} else {\r\nret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 1);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 1);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\n}\r\n#ifdef DBG_DUMP\r\nlgdt3306a_DumpAllRegs(state);\r\n#endif\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_set_vsb(struct lgdt3306a_state *state)\r\n{\r\nu8 val;\r\nint ret;\r\ndbg_info("\n");\r\nret = lgdt3306a_read_reg(state, 0x0002, &val);\r\nval &= 0xf7;\r\nval |= 0x04;\r\nret = lgdt3306a_write_reg(state, 0x0002, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_write_reg(state, 0x0008, 0x80);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x0009, &val);\r\nval &= 0xe3;\r\nval |= 0x0c;\r\nret = lgdt3306a_write_reg(state, 0x0009, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x0009, &val);\r\nval &= 0xfc;\r\nret = lgdt3306a_write_reg(state, 0x0009, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x000d, &val);\r\nval &= 0xbf;\r\nret = lgdt3306a_write_reg(state, 0x000d, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\n#if 0\r\nret = lgdt3306a_write_reg(state, 0x0024, 0x00);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_write_reg(state, 0x002e, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x002f, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0030, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x002b, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x002c, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x002d, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0028, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0029, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x002a, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0025, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0026, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0027, 0x00);\r\n#else\r\nret = lgdt3306a_write_reg(state, 0x0024, 0x5A);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_write_reg(state, 0x002e, 0x5A);\r\nret = lgdt3306a_write_reg(state, 0x002f, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0030, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x002b, 0x36);\r\nret = lgdt3306a_write_reg(state, 0x002c, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x002d, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0028, 0x2A);\r\nret = lgdt3306a_write_reg(state, 0x0029, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x002a, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0025, 0x06);\r\nret = lgdt3306a_write_reg(state, 0x0026, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0027, 0x00);\r\n#endif\r\nret = lgdt3306a_read_reg(state, 0x001e, &val);\r\nval &= 0x0f;\r\nval |= 0xa0;\r\nret = lgdt3306a_write_reg(state, 0x001e, val);\r\nret = lgdt3306a_write_reg(state, 0x0022, 0x08);\r\nret = lgdt3306a_write_reg(state, 0x0023, 0xFF);\r\nret = lgdt3306a_read_reg(state, 0x211f, &val);\r\nval &= 0xef;\r\nret = lgdt3306a_write_reg(state, 0x211f, val);\r\nret = lgdt3306a_write_reg(state, 0x2173, 0x01);\r\nret = lgdt3306a_read_reg(state, 0x1061, &val);\r\nval &= 0xf8;\r\nval |= 0x04;\r\nret = lgdt3306a_write_reg(state, 0x1061, val);\r\nret = lgdt3306a_read_reg(state, 0x103d, &val);\r\nval &= 0xcf;\r\nret = lgdt3306a_write_reg(state, 0x103d, val);\r\nret = lgdt3306a_write_reg(state, 0x2122, 0x40);\r\nret = lgdt3306a_read_reg(state, 0x2141, &val);\r\nval &= 0x3f;\r\nret = lgdt3306a_write_reg(state, 0x2141, val);\r\nret = lgdt3306a_read_reg(state, 0x2135, &val);\r\nval &= 0x0f;\r\nval |= 0x70;\r\nret = lgdt3306a_write_reg(state, 0x2135, val);\r\nret = lgdt3306a_read_reg(state, 0x0003, &val);\r\nval &= 0xf7;\r\nret = lgdt3306a_write_reg(state, 0x0003, val);\r\nret = lgdt3306a_read_reg(state, 0x001c, &val);\r\nval &= 0x7f;\r\nret = lgdt3306a_write_reg(state, 0x001c, val);\r\nret = lgdt3306a_read_reg(state, 0x2179, &val);\r\nval &= 0xf8;\r\nret = lgdt3306a_write_reg(state, 0x2179, val);\r\nret = lgdt3306a_read_reg(state, 0x217a, &val);\r\nval &= 0xf8;\r\nret = lgdt3306a_write_reg(state, 0x217a, val);\r\nret = lgdt3306a_soft_reset(state);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\ndbg_info("complete\n");\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)\r\n{\r\nu8 val;\r\nint ret;\r\ndbg_info("modulation=%d\n", modulation);\r\nret = lgdt3306a_write_reg(state, 0x0008, 0x08);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x0002, &val);\r\nval &= 0xfb;\r\nval |= 0x08;\r\nret = lgdt3306a_write_reg(state, 0x0002, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x0009, &val);\r\nval &= 0xe3;\r\nret = lgdt3306a_write_reg(state, 0x0009, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x0009, &val);\r\nval &= 0xfc;\r\nval |= 0x02;\r\nret = lgdt3306a_write_reg(state, 0x0009, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x101a, &val);\r\nval &= 0xf8;\r\nif (modulation == QAM_64)\r\nval |= 0x02;\r\nelse\r\nval |= 0x04;\r\nret = lgdt3306a_write_reg(state, 0x101a, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x000d, &val);\r\nval &= 0xbf;\r\nval |= 0x40;\r\nret = lgdt3306a_write_reg(state, 0x000d, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x0024, &val);\r\nval &= 0x00;\r\nret = lgdt3306a_write_reg(state, 0x0024, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_soft_reset(state);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\ndbg_info("complete\n");\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_set_modulation(struct lgdt3306a_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nint ret;\r\ndbg_info("\n");\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nret = lgdt3306a_set_vsb(state);\r\nbreak;\r\ncase QAM_64:\r\nret = lgdt3306a_set_qam(state, QAM_64);\r\nbreak;\r\ncase QAM_256:\r\nret = lgdt3306a_set_qam(state, QAM_256);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nstate->current_modulation = p->modulation;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_agc_setup(struct lgdt3306a_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\ndbg_info("\n");\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lgdt3306a_set_inversion(struct lgdt3306a_state *state,\r\nint inversion)\r\n{\r\nint ret;\r\ndbg_info("(%d)\n", inversion);\r\nret = lgdt3306a_set_reg_bit(state, 0x0002, 2, inversion ? 1 : 0);\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_set_inversion_auto(struct lgdt3306a_state *state,\r\nint enabled)\r\n{\r\nint ret;\r\ndbg_info("(%d)\n", enabled);\r\nret = lgdt3306a_set_reg_bit(state, 0x0002, 3, enabled);\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_spectral_inversion(struct lgdt3306a_state *state,\r\nstruct dtv_frontend_properties *p,\r\nint inversion)\r\n{\r\nint ret = 0;\r\ndbg_info("(%d)\n", inversion);\r\n#if 0\r\nret = lgdt3306a_set_inversion(state, inversion);\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nret = lgdt3306a_set_inversion_auto(state, 0);\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nret = lgdt3306a_set_inversion_auto(state, 1);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_set_if(struct lgdt3306a_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nint ret;\r\nu16 if_freq_khz;\r\nu8 nco1, nco2;\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nif_freq_khz = state->cfg->vsb_if_khz;\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nif_freq_khz = state->cfg->qam_if_khz;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (if_freq_khz) {\r\ndefault:\r\npr_warn("IF=%d KHz is not supportted, 3250 assumed\n",\r\nif_freq_khz);\r\ncase 3250:\r\nnco1 = 0x34;\r\nnco2 = 0x00;\r\nbreak;\r\ncase 3500:\r\nnco1 = 0x38;\r\nnco2 = 0x00;\r\nbreak;\r\ncase 4000:\r\nnco1 = 0x40;\r\nnco2 = 0x00;\r\nbreak;\r\ncase 5000:\r\nnco1 = 0x50;\r\nnco2 = 0x00;\r\nbreak;\r\ncase 5380:\r\nnco1 = 0x56;\r\nnco2 = 0x14;\r\nbreak;\r\n}\r\nret = lgdt3306a_write_reg(state, 0x0010, nco1);\r\nif (ret)\r\nreturn ret;\r\nret = lgdt3306a_write_reg(state, 0x0011, nco2);\r\nif (ret)\r\nreturn ret;\r\ndbg_info("if_freq=%d KHz->[%04x]\n", if_freq_khz, nco1<<8 | nco2);\r\nreturn 0;\r\n}\r\nstatic int lgdt3306a_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\nif (state->cfg->deny_i2c_rptr) {\r\ndbg_info("deny_i2c_rptr=%d\n", state->cfg->deny_i2c_rptr);\r\nreturn 0;\r\n}\r\ndbg_info("(%d)\n", enable);\r\nreturn lgdt3306a_set_reg_bit(state, 0x0002, 7, enable ? 0 : 1);\r\n}\r\nstatic int lgdt3306a_sleep(struct lgdt3306a_state *state)\r\n{\r\nint ret;\r\ndbg_info("\n");\r\nstate->current_frequency = -1;\r\nret = lgdt3306a_mpeg_tristate(state, 1);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_power(state, 0);\r\nlg_chkerr(ret);\r\nfail:\r\nreturn 0;\r\n}\r\nstatic int lgdt3306a_fe_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\nreturn lgdt3306a_sleep(state);\r\n}\r\nstatic int lgdt3306a_init(struct dvb_frontend *fe)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\nu8 val;\r\nint ret;\r\ndbg_info("\n");\r\nret = lgdt3306a_set_reg_bit(state, 0x0001, 0, 1);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_inversion_auto(state, 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_inversion(state, 1);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_reg_bit(state, 0x0004, 7, 1);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_reg_bit(state, 0x0004, 2, 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_reg_bit(state, 0x0004, 3, 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_reg_bit(state, 0x0005, 6, 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nif (state->cfg->xtalMHz == 24) {\r\nret = lgdt3306a_read_reg(state, 0x0005, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nval &= 0xc0;\r\nval |= 0x25;\r\nret = lgdt3306a_write_reg(state, 0x0005, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_write_reg(state, 0x0006, 0x64);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x000d, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nval &= 0xc0;\r\nval |= 0x18;\r\nret = lgdt3306a_write_reg(state, 0x000d, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\n} else if (state->cfg->xtalMHz == 25) {\r\nret = lgdt3306a_read_reg(state, 0x0005, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nval &= 0xc0;\r\nval |= 0x25;\r\nret = lgdt3306a_write_reg(state, 0x0005, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_write_reg(state, 0x0006, 0x64);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_read_reg(state, 0x000d, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nval &= 0xc0;\r\nval |= 0x19;\r\nret = lgdt3306a_write_reg(state, 0x000d, val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\n} else {\r\npr_err("Bad xtalMHz=%d\n", state->cfg->xtalMHz);\r\n}\r\n#if 0\r\nret = lgdt3306a_write_reg(state, 0x000e, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x000f, 0x00);\r\n#endif\r\nret = lgdt3306a_write_reg(state, 0x0010, 0x34);\r\nret = lgdt3306a_write_reg(state, 0x0011, 0x00);\r\nret = lgdt3306a_write_reg(state, 0x0014, 0);\r\nret = lgdt3306a_read_reg(state, 0x103c, &val);\r\nval &= 0x0f;\r\nval |= 0x20;\r\nret = lgdt3306a_write_reg(state, 0x103c, val);\r\nret = lgdt3306a_read_reg(state, 0x103d, &val);\r\nval &= 0xfc;\r\nval |= 0x03;\r\nret = lgdt3306a_write_reg(state, 0x103d, val);\r\nret = lgdt3306a_read_reg(state, 0x1036, &val);\r\nval &= 0xf0;\r\nval |= 0x0c;\r\nret = lgdt3306a_write_reg(state, 0x1036, val);\r\nret = lgdt3306a_read_reg(state, 0x211f, &val);\r\nval &= 0xef;\r\nret = lgdt3306a_write_reg(state, 0x211f, val);\r\nret = lgdt3306a_read_reg(state, 0x2849, &val);\r\nval &= 0xef;\r\nret = lgdt3306a_write_reg(state, 0x2849, val);\r\nret = lgdt3306a_set_vsb(state);\r\nret = lgdt3306a_mpeg_mode(state, state->cfg->mpeg_mode);\r\nret = lgdt3306a_mpeg_tristate(state, 1);\r\nret = lgdt3306a_sleep(state);\r\nlg_chkerr(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_set_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\nint ret;\r\ndbg_info("(%d, %d)\n", p->frequency, p->modulation);\r\nif (state->current_frequency == p->frequency &&\r\nstate->current_modulation == p->modulation) {\r\ndbg_info(" (already set, skipping ...)\n");\r\nreturn 0;\r\n}\r\nstate->current_frequency = -1;\r\nstate->current_modulation = -1;\r\nret = lgdt3306a_power(state, 1);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n#if 0\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nstate->current_frequency = p->frequency;\r\n#endif\r\n}\r\nret = lgdt3306a_set_modulation(state, p);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_agc_setup(state, p);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_set_if(state, p);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_spectral_inversion(state, p,\r\nstate->cfg->spectral_inversion ? 1 : 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_mpeg_mode(state, state->cfg->mpeg_mode);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_mpeg_mode_polarity(state,\r\nstate->cfg->tpclk_edge,\r\nstate->cfg->tpvalid_polarity);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_mpeg_tristate(state, 0);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nret = lgdt3306a_soft_reset(state);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\n#ifdef DBG_DUMP\r\nlgdt3306a_DumpAllRegs(state);\r\n#endif\r\nstate->current_frequency = p->frequency;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\ndbg_info("(%u, %d)\n",\r\nstate->current_frequency, state->current_modulation);\r\np->modulation = state->current_modulation;\r\np->frequency = state->current_frequency;\r\nreturn 0;\r\n}\r\nstatic enum dvbfe_algo lgdt3306a_get_frontend_algo(struct dvb_frontend *fe)\r\n{\r\n#if 1\r\nreturn DVBFE_ALGO_CUSTOM;\r\n#else\r\nreturn DVBFE_ALGO_HW;\r\n#endif\r\n}\r\nstatic int lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)\r\n{\r\nu8 val;\r\nint ret;\r\nu8 snrRef, maxPowerMan, nCombDet;\r\nu16 fbDlyCir;\r\nret = lgdt3306a_read_reg(state, 0x21a1, &val);\r\nif (ret)\r\nreturn ret;\r\nsnrRef = val & 0x3f;\r\nret = lgdt3306a_read_reg(state, 0x2185, &maxPowerMan);\r\nif (ret)\r\nreturn ret;\r\nret = lgdt3306a_read_reg(state, 0x2191, &val);\r\nif (ret)\r\nreturn ret;\r\nnCombDet = (val & 0x80) >> 7;\r\nret = lgdt3306a_read_reg(state, 0x2180, &val);\r\nif (ret)\r\nreturn ret;\r\nfbDlyCir = (val & 0x03) << 8;\r\nret = lgdt3306a_read_reg(state, 0x2181, &val);\r\nif (ret)\r\nreturn ret;\r\nfbDlyCir |= val;\r\ndbg_info("snrRef=%d maxPowerMan=0x%x nCombDet=%d fbDlyCir=0x%x\n",\r\nsnrRef, maxPowerMan, nCombDet, fbDlyCir);\r\nret = lgdt3306a_read_reg(state, 0x1061, &val);\r\nif (ret)\r\nreturn ret;\r\nval &= 0xf8;\r\nif ((snrRef > 18) && (maxPowerMan > 0x68)\r\n&& (nCombDet == 0x01)\r\n&& ((fbDlyCir == 0x03FF) || (fbDlyCir < 0x6C))) {\r\nval |= 0x00;\r\n} else {\r\nval |= 0x04;\r\n}\r\nret = lgdt3306a_write_reg(state, 0x1061, val);\r\nif (ret)\r\nreturn ret;\r\nret = lgdt3306a_read_reg(state, 0x0024, &val);\r\nif (ret)\r\nreturn ret;\r\nval &= 0x0f;\r\nif (nCombDet == 0) {\r\nval |= 0x50;\r\n}\r\nret = lgdt3306a_write_reg(state, 0x0024, val);\r\nif (ret)\r\nreturn ret;\r\nret = lgdt3306a_read_reg(state, 0x103d, &val);\r\nif (ret)\r\nreturn ret;\r\nval &= 0xcf;\r\nval |= 0x20;\r\nret = lgdt3306a_write_reg(state, 0x103d, val);\r\nreturn ret;\r\n}\r\nstatic enum lgdt3306a_modulation\r\nlgdt3306a_check_oper_mode(struct lgdt3306a_state *state)\r\n{\r\nu8 val = 0;\r\nint ret;\r\nret = lgdt3306a_read_reg(state, 0x0081, &val);\r\nif (ret)\r\ngoto err;\r\nif (val & 0x80) {\r\ndbg_info("VSB\n");\r\nreturn LG3306_VSB;\r\n}\r\nif (val & 0x08) {\r\nret = lgdt3306a_read_reg(state, 0x00a6, &val);\r\nif (ret)\r\ngoto err;\r\nval = val >> 2;\r\nif (val & 0x01) {\r\ndbg_info("QAM256\n");\r\nreturn LG3306_QAM256;\r\n}\r\ndbg_info("QAM64\n");\r\nreturn LG3306_QAM64;\r\n}\r\nerr:\r\npr_warn("UNKNOWN\n");\r\nreturn LG3306_UNKNOWN_MODE;\r\n}\r\nstatic enum lgdt3306a_lock_status\r\nlgdt3306a_check_lock_status(struct lgdt3306a_state *state,\r\nenum lgdt3306a_lock_check whatLock)\r\n{\r\nu8 val = 0;\r\nint ret;\r\nenum lgdt3306a_modulation modeOper;\r\nenum lgdt3306a_lock_status lockStatus;\r\nmodeOper = LG3306_UNKNOWN_MODE;\r\nswitch (whatLock) {\r\ncase LG3306_SYNC_LOCK:\r\n{\r\nret = lgdt3306a_read_reg(state, 0x00a6, &val);\r\nif (ret)\r\nreturn ret;\r\nif ((val & 0x80) == 0x80)\r\nlockStatus = LG3306_LOCK;\r\nelse\r\nlockStatus = LG3306_UNLOCK;\r\ndbg_info("SYNC_LOCK=%x\n", lockStatus);\r\nbreak;\r\n}\r\ncase LG3306_AGC_LOCK:\r\n{\r\nret = lgdt3306a_read_reg(state, 0x0080, &val);\r\nif (ret)\r\nreturn ret;\r\nif ((val & 0x40) == 0x40)\r\nlockStatus = LG3306_LOCK;\r\nelse\r\nlockStatus = LG3306_UNLOCK;\r\ndbg_info("AGC_LOCK=%x\n", lockStatus);\r\nbreak;\r\n}\r\ncase LG3306_TR_LOCK:\r\n{\r\nmodeOper = lgdt3306a_check_oper_mode(state);\r\nif ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256)) {\r\nret = lgdt3306a_read_reg(state, 0x1094, &val);\r\nif (ret)\r\nreturn ret;\r\nif ((val & 0x80) == 0x80)\r\nlockStatus = LG3306_LOCK;\r\nelse\r\nlockStatus = LG3306_UNLOCK;\r\n} else\r\nlockStatus = LG3306_UNKNOWN_LOCK;\r\ndbg_info("TR_LOCK=%x\n", lockStatus);\r\nbreak;\r\n}\r\ncase LG3306_FEC_LOCK:\r\n{\r\nmodeOper = lgdt3306a_check_oper_mode(state);\r\nif ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256)) {\r\nret = lgdt3306a_read_reg(state, 0x0080, &val);\r\nif (ret)\r\nreturn ret;\r\nif ((val & 0x10) == 0x10)\r\nlockStatus = LG3306_LOCK;\r\nelse\r\nlockStatus = LG3306_UNLOCK;\r\n} else\r\nlockStatus = LG3306_UNKNOWN_LOCK;\r\ndbg_info("FEC_LOCK=%x\n", lockStatus);\r\nbreak;\r\n}\r\ndefault:\r\nlockStatus = LG3306_UNKNOWN_LOCK;\r\npr_warn("UNKNOWN whatLock=%d\n", whatLock);\r\nbreak;\r\n}\r\nreturn lockStatus;\r\n}\r\nstatic enum lgdt3306a_neverlock_status\r\nlgdt3306a_check_neverlock_status(struct lgdt3306a_state *state)\r\n{\r\nu8 val = 0;\r\nint ret;\r\nenum lgdt3306a_neverlock_status lockStatus;\r\nret = lgdt3306a_read_reg(state, 0x0080, &val);\r\nif (ret)\r\nreturn ret;\r\nlockStatus = (enum lgdt3306a_neverlock_status)(val & 0x03);\r\ndbg_info("NeverLock=%d", lockStatus);\r\nreturn lockStatus;\r\n}\r\nstatic int lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)\r\n{\r\nu8 val = 0;\r\nint ret;\r\nu8 currChDiffACQ, snrRef, mainStrong, aiccrejStatus;\r\nret = lgdt3306a_read_reg(state, 0x21bc, &currChDiffACQ);\r\nif (ret)\r\nreturn ret;\r\nret = lgdt3306a_read_reg(state, 0x21a1, &val);\r\nif (ret)\r\nreturn ret;\r\nsnrRef = val & 0x3f;\r\nret = lgdt3306a_read_reg(state, 0x2199, &val);\r\nif (ret)\r\nreturn ret;\r\nmainStrong = (val & 0x40) >> 6;\r\nret = lgdt3306a_read_reg(state, 0x0090, &val);\r\nif (ret)\r\nreturn ret;\r\naiccrejStatus = (val & 0xf0) >> 4;\r\ndbg_info("snrRef=%d mainStrong=%d aiccrejStatus=%d currChDiffACQ=0x%x\n",\r\nsnrRef, mainStrong, aiccrejStatus, currChDiffACQ);\r\n#if 0\r\nif ((mainStrong == 0) && (currChDiffACQ > 0x70))\r\n#endif\r\nif (mainStrong == 0) {\r\nret = lgdt3306a_read_reg(state, 0x2135, &val);\r\nif (ret)\r\nreturn ret;\r\nval &= 0x0f;\r\nval |= 0xa0;\r\nret = lgdt3306a_write_reg(state, 0x2135, val);\r\nif (ret)\r\nreturn ret;\r\nret = lgdt3306a_read_reg(state, 0x2141, &val);\r\nif (ret)\r\nreturn ret;\r\nval &= 0x3f;\r\nval |= 0x80;\r\nret = lgdt3306a_write_reg(state, 0x2141, val);\r\nif (ret)\r\nreturn ret;\r\nret = lgdt3306a_write_reg(state, 0x2122, 0x70);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = lgdt3306a_read_reg(state, 0x2135, &val);\r\nif (ret)\r\nreturn ret;\r\nval &= 0x0f;\r\nval |= 0x70;\r\nret = lgdt3306a_write_reg(state, 0x2135, val);\r\nif (ret)\r\nreturn ret;\r\nret = lgdt3306a_read_reg(state, 0x2141, &val);\r\nif (ret)\r\nreturn ret;\r\nval &= 0x3f;\r\nval |= 0x40;\r\nret = lgdt3306a_write_reg(state, 0x2141, val);\r\nif (ret)\r\nreturn ret;\r\nret = lgdt3306a_write_reg(state, 0x2122, 0x40);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum lgdt3306a_lock_status\r\nlgdt3306a_sync_lock_poll(struct lgdt3306a_state *state)\r\n{\r\nenum lgdt3306a_lock_status syncLockStatus = LG3306_UNLOCK;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nmsleep(30);\r\nsyncLockStatus = lgdt3306a_check_lock_status(state,\r\nLG3306_SYNC_LOCK);\r\nif (syncLockStatus == LG3306_LOCK) {\r\ndbg_info("locked(%d)\n", i);\r\nreturn LG3306_LOCK;\r\n}\r\n}\r\ndbg_info("not locked\n");\r\nreturn LG3306_UNLOCK;\r\n}\r\nstatic enum lgdt3306a_lock_status\r\nlgdt3306a_fec_lock_poll(struct lgdt3306a_state *state)\r\n{\r\nenum lgdt3306a_lock_status FECLockStatus = LG3306_UNLOCK;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nmsleep(30);\r\nFECLockStatus = lgdt3306a_check_lock_status(state,\r\nLG3306_FEC_LOCK);\r\nif (FECLockStatus == LG3306_LOCK) {\r\ndbg_info("locked(%d)\n", i);\r\nreturn FECLockStatus;\r\n}\r\n}\r\ndbg_info("not locked\n");\r\nreturn FECLockStatus;\r\n}\r\nstatic enum lgdt3306a_neverlock_status\r\nlgdt3306a_neverlock_poll(struct lgdt3306a_state *state)\r\n{\r\nenum lgdt3306a_neverlock_status NLLockStatus = LG3306_NL_FAIL;\r\nint i;\r\nfor (i = 0; i < 5; i++) {\r\nmsleep(30);\r\nNLLockStatus = lgdt3306a_check_neverlock_status(state);\r\nif (NLLockStatus == LG3306_NL_LOCK) {\r\ndbg_info("NL_LOCK(%d)\n", i);\r\nreturn NLLockStatus;\r\n}\r\n}\r\ndbg_info("NLLockStatus=%d\n", NLLockStatus);\r\nreturn NLLockStatus;\r\n}\r\nstatic u8 lgdt3306a_get_packet_error(struct lgdt3306a_state *state)\r\n{\r\nu8 val;\r\nint ret;\r\nret = lgdt3306a_read_reg(state, 0x00fa, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn val;\r\n}\r\nstatic u32 log10_x1000(u32 x)\r\n{\r\nu32 diff_val, step_val, step_log10;\r\nu32 log_val = 0;\r\nu32 i;\r\nif (x <= 0)\r\nreturn -1000000;\r\nif (x == 10)\r\nreturn 0;\r\nif (x < 10) {\r\nwhile (x < 10) {\r\nx = x * 10;\r\nlog_val--;\r\n}\r\n} else {\r\nwhile (x >= 100) {\r\nx = x / 10;\r\nlog_val++;\r\n}\r\n}\r\nlog_val *= 1000;\r\nif (x == 10)\r\nreturn log_val;\r\nfor (i = 1; i < ARRAY_SIZE(valx_x10); i++) {\r\nif (valx_x10[i] >= x)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(valx_x10))\r\nreturn log_val + log10x_x1000[i - 1];\r\ndiff_val = x - valx_x10[i-1];\r\nstep_val = valx_x10[i] - valx_x10[i - 1];\r\nstep_log10 = log10x_x1000[i] - log10x_x1000[i - 1];\r\nreturn log_val + log10x_x1000[i - 1] +\r\n((diff_val*step_log10) / step_val);\r\n}\r\nstatic u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)\r\n{\r\nu32 mse;\r\nu32 pwr;\r\nu32 snr_x100;\r\nmse = (read_reg(state, 0x00ec) << 8) |\r\n(read_reg(state, 0x00ed));\r\npwr = (read_reg(state, 0x00e8) << 8) |\r\n(read_reg(state, 0x00e9));\r\nif (mse == 0)\r\nreturn 0;\r\nsnr_x100 = log10_x1000((pwr * 10000) / mse) - 3000;\r\ndbg_info("mse=%u, pwr=%u, snr_x100=%d\n", mse, pwr, snr_x100);\r\nreturn snr_x100;\r\n}\r\nstatic enum lgdt3306a_lock_status\r\nlgdt3306a_vsb_lock_poll(struct lgdt3306a_state *state)\r\n{\r\nint ret;\r\nu8 cnt = 0;\r\nu8 packet_error;\r\nu32 snr;\r\nfor (cnt = 0; cnt < 10; cnt++) {\r\nif (lgdt3306a_sync_lock_poll(state) == LG3306_UNLOCK) {\r\ndbg_info("no sync lock!\n");\r\nreturn LG3306_UNLOCK;\r\n}\r\nmsleep(20);\r\nret = lgdt3306a_pre_monitoring(state);\r\nif (ret)\r\nbreak;\r\npacket_error = lgdt3306a_get_packet_error(state);\r\nsnr = lgdt3306a_calculate_snr_x100(state);\r\ndbg_info("cnt=%d errors=%d snr=%d\n", cnt, packet_error, snr);\r\nif ((snr >= 1500) && (packet_error < 0xff))\r\nreturn LG3306_LOCK;\r\n}\r\ndbg_info("not locked!\n");\r\nreturn LG3306_UNLOCK;\r\n}\r\nstatic enum lgdt3306a_lock_status\r\nlgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)\r\n{\r\nu8 cnt;\r\nu8 packet_error;\r\nu32 snr;\r\nfor (cnt = 0; cnt < 10; cnt++) {\r\nif (lgdt3306a_fec_lock_poll(state) == LG3306_UNLOCK) {\r\ndbg_info("no fec lock!\n");\r\nreturn LG3306_UNLOCK;\r\n}\r\nmsleep(20);\r\npacket_error = lgdt3306a_get_packet_error(state);\r\nsnr = lgdt3306a_calculate_snr_x100(state);\r\ndbg_info("cnt=%d errors=%d snr=%d\n", cnt, packet_error, snr);\r\nif ((snr >= 1500) && (packet_error < 0xff))\r\nreturn LG3306_LOCK;\r\n}\r\ndbg_info("not locked!\n");\r\nreturn LG3306_UNLOCK;\r\n}\r\nstatic int lgdt3306a_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\nu16 strength = 0;\r\nint ret = 0;\r\nif (fe->ops.tuner_ops.get_rf_strength) {\r\nret = fe->ops.tuner_ops.get_rf_strength(fe, &strength);\r\nif (ret == 0)\r\ndbg_info("strength=%d\n", strength);\r\nelse\r\ndbg_info("fe->ops.tuner_ops.get_rf_strength() failed\n");\r\n}\r\n*status = 0;\r\nif (lgdt3306a_neverlock_poll(state) == LG3306_NL_LOCK) {\r\n*status |= FE_HAS_SIGNAL;\r\n*status |= FE_HAS_CARRIER;\r\nswitch (state->current_modulation) {\r\ncase QAM_256:\r\ncase QAM_64:\r\nif (lgdt3306a_qam_lock_poll(state) == LG3306_LOCK) {\r\n*status |= FE_HAS_VITERBI;\r\n*status |= FE_HAS_SYNC;\r\n*status |= FE_HAS_LOCK;\r\n}\r\nbreak;\r\ncase VSB_8:\r\nif (lgdt3306a_vsb_lock_poll(state) == LG3306_LOCK) {\r\n*status |= FE_HAS_VITERBI;\r\n*status |= FE_HAS_SYNC;\r\n*status |= FE_HAS_LOCK;\r\nret = lgdt3306a_monitor_vsb(state);\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\nstate->snr = lgdt3306a_calculate_snr_x100(state);\r\n*snr = state->snr/10;\r\nreturn 0;\r\n}\r\nstatic int lgdt3306a_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\nu16 snr;\r\nint ret;\r\nu32 ref_snr;\r\nu32 str;\r\n*strength = 0;\r\nswitch (state->current_modulation) {\r\ncase VSB_8:\r\nref_snr = 1600;\r\nbreak;\r\ncase QAM_64:\r\nref_snr = 2200;\r\nbreak;\r\ncase QAM_256:\r\nref_snr = 2800;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = fe->ops.read_snr(fe, &snr);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nif (state->snr <= (ref_snr - 100))\r\nstr = 0;\r\nelse if (state->snr <= ref_snr)\r\nstr = (0xffff * 65) / 100;\r\nelse {\r\nstr = state->snr - ref_snr;\r\nstr /= 50;\r\nstr += 78;\r\nif (str > 100)\r\nstr = 100;\r\nstr = (0xffff * str) / 100;\r\n}\r\n*strength = (u16)str;\r\ndbg_info("strength=%u\n", *strength);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\nu32 tmp;\r\n*ber = 0;\r\n#if 1\r\ntmp = read_reg(state, 0x00fc);\r\ntmp = (tmp << 8) | read_reg(state, 0x00fd);\r\ntmp = (tmp << 8) | read_reg(state, 0x00fe);\r\ntmp = (tmp << 8) | read_reg(state, 0x00ff);\r\n*ber = tmp;\r\ndbg_info("ber=%u\n", tmp);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int lgdt3306a_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\n*ucblocks = 0;\r\n#if 1\r\n*ucblocks = read_reg(state, 0x00f4);\r\ndbg_info("ucblocks=%u\n", *ucblocks);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int lgdt3306a_tune(struct dvb_frontend *fe, bool re_tune,\r\nunsigned int mode_flags, unsigned int *delay,\r\nenum fe_status *status)\r\n{\r\nint ret = 0;\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\ndbg_info("re_tune=%u\n", re_tune);\r\nif (re_tune) {\r\nstate->current_frequency = -1;\r\nret = lgdt3306a_set_parameters(fe);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\n*delay = 125;\r\nret = lgdt3306a_read_status(fe, status);\r\nreturn ret;\r\n}\r\nstatic int lgdt3306a_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings\r\n*fe_tune_settings)\r\n{\r\nfe_tune_settings->min_delay_ms = 100;\r\ndbg_info("\n");\r\nreturn 0;\r\n}\r\nstatic int lgdt3306a_search(struct dvb_frontend *fe)\r\n{\r\nenum fe_status status = 0;\r\nint i, ret;\r\nret = lgdt3306a_set_parameters(fe);\r\nif (ret)\r\ngoto error;\r\nfor (i = 20; i > 0; i--) {\r\ndbg_info(": loop=%d\n", i);\r\nmsleep(50);\r\nret = lgdt3306a_read_status(fe, &status);\r\nif (ret)\r\ngoto error;\r\nif (status & FE_HAS_LOCK)\r\nbreak;\r\n}\r\nif (status & FE_HAS_LOCK)\r\nreturn DVBFE_ALGO_SEARCH_SUCCESS;\r\nelse\r\nreturn DVBFE_ALGO_SEARCH_AGAIN;\r\nerror:\r\ndbg_info("failed (%d)\n", ret);\r\nreturn DVBFE_ALGO_SEARCH_ERROR;\r\n}\r\nstatic void lgdt3306a_release(struct dvb_frontend *fe)\r\n{\r\nstruct lgdt3306a_state *state = fe->demodulator_priv;\r\ndbg_info("\n");\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,\r\nstruct i2c_adapter *i2c_adap)\r\n{\r\nstruct lgdt3306a_state *state = NULL;\r\nint ret;\r\nu8 val;\r\ndbg_info("(%d-%04x)\n",\r\ni2c_adap ? i2c_adapter_id(i2c_adap) : 0,\r\nconfig ? config->i2c_addr : 0);\r\nstate = kzalloc(sizeof(struct lgdt3306a_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto fail;\r\nstate->cfg = config;\r\nstate->i2c_adap = i2c_adap;\r\nmemcpy(&state->frontend.ops, &lgdt3306a_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nret = lgdt3306a_read_reg(state, 0x0000, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nif ((val & 0x74) != 0x74) {\r\npr_warn("expected 0x74, got 0x%x\n", (val & 0x74));\r\n#if 0\r\ngoto fail;\r\n#endif\r\n}\r\nret = lgdt3306a_read_reg(state, 0x0001, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nif ((val & 0xf6) != 0xc6) {\r\npr_warn("expected 0xc6, got 0x%x\n", (val & 0xf6));\r\n#if 0\r\ngoto fail;\r\n#endif\r\n}\r\nret = lgdt3306a_read_reg(state, 0x0002, &val);\r\nif (lg_chkerr(ret))\r\ngoto fail;\r\nif ((val & 0x73) != 0x03) {\r\npr_warn("expected 0x03, got 0x%x\n", (val & 0x73));\r\n#if 0\r\ngoto fail;\r\n#endif\r\n}\r\nstate->current_frequency = -1;\r\nstate->current_modulation = -1;\r\nlgdt3306a_sleep(state);\r\nreturn &state->frontend;\r\nfail:\r\npr_warn("unable to detect LGDT3306A hardware\n");\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nstatic void lgdt3306a_DumpAllRegs(struct lgdt3306a_state *state)\r\n{\r\nmemset(regval2, 0xff, sizeof(regval2));\r\nlgdt3306a_DumpRegs(state);\r\n}\r\nstatic void lgdt3306a_DumpRegs(struct lgdt3306a_state *state)\r\n{\r\nint i;\r\nint sav_debug = debug;\r\nif ((debug & DBG_DUMP) == 0)\r\nreturn;\r\ndebug &= ~DBG_REG;\r\nlg_debug("\n");\r\nfor (i = 0; i < numDumpRegs; i++) {\r\nlgdt3306a_read_reg(state, regtab[i], &regval1[i]);\r\nif (regval1[i] != regval2[i]) {\r\nlg_debug(" %04X = %02X\n", regtab[i], regval1[i]);\r\nregval2[i] = regval1[i];\r\n}\r\n}\r\ndebug = sav_debug;\r\n}
