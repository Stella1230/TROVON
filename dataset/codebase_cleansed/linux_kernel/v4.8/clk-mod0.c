static void sun4i_a10_get_mod0_factors(struct factors_request *req)\r\n{\r\nu8 div, calcm, calcp;\r\nif (req->rate > req->parent_rate)\r\nreq->rate = req->parent_rate;\r\ndiv = DIV_ROUND_UP(req->parent_rate, req->rate);\r\nif (div < 16)\r\ncalcp = 0;\r\nelse if (div / 2 < 16)\r\ncalcp = 1;\r\nelse if (div / 4 < 16)\r\ncalcp = 2;\r\nelse\r\ncalcp = 3;\r\ncalcm = DIV_ROUND_UP(div, 1 << calcp);\r\nreq->rate = (req->parent_rate >> calcp) / calcm;\r\nreq->m = calcm - 1;\r\nreq->p = calcp;\r\n}\r\nstatic void __init sun4i_a10_mod0_setup(struct device_node *node)\r\n{\r\nvoid __iomem *reg;\r\nreg = of_iomap(node, 0);\r\nif (!reg) {\r\nreturn;\r\n}\r\nsunxi_factors_register(node, &sun4i_a10_mod0_data,\r\n&sun4i_a10_mod0_lock, reg);\r\n}\r\nstatic int sun4i_a10_mod0_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *r;\r\nvoid __iomem *reg;\r\nif (!np)\r\nreturn -ENODEV;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nsunxi_factors_register(np, &sun4i_a10_mod0_data,\r\n&sun4i_a10_mod0_lock, reg);\r\nreturn 0;\r\n}\r\nstatic void __init sun9i_a80_mod0_setup(struct device_node *node)\r\n{\r\nvoid __iomem *reg;\r\nreg = of_io_request_and_map(node, 0, of_node_full_name(node));\r\nif (IS_ERR(reg)) {\r\npr_err("Could not get registers for mod0-clk: %s\n",\r\nnode->name);\r\nreturn;\r\n}\r\nsunxi_factors_register(node, &sun9i_a80_mod0_data,\r\n&sun4i_a10_mod0_lock, reg);\r\n}\r\nstatic void __init sun5i_a13_mbus_setup(struct device_node *node)\r\n{\r\nstruct clk *mbus;\r\nvoid __iomem *reg;\r\nreg = of_iomap(node, 0);\r\nif (!reg) {\r\npr_err("Could not get registers for a13-mbus-clk\n");\r\nreturn;\r\n}\r\nmbus = sunxi_factors_register(node, &sun4i_a10_mod0_data,\r\n&sun5i_a13_mbus_lock, reg);\r\n__clk_get(mbus);\r\nclk_prepare_enable(mbus);\r\n}\r\nstatic int mmc_get_phase(struct clk_hw *hw)\r\n{\r\nstruct clk *mmc, *mmc_parent, *clk = hw->clk;\r\nstruct mmc_phase *phase = to_mmc_phase(hw);\r\nunsigned int mmc_rate, mmc_parent_rate;\r\nu16 step, mmc_div;\r\nu32 value;\r\nu8 delay;\r\nvalue = readl(phase->reg);\r\ndelay = (value >> phase->offset) & 0x3;\r\nif (!delay)\r\nreturn 180;\r\nmmc = clk_get_parent(clk);\r\nif (!mmc)\r\nreturn -EINVAL;\r\nmmc_rate = clk_get_rate(mmc);\r\nif (!mmc_rate)\r\nreturn -EINVAL;\r\nmmc_parent = clk_get_parent(mmc);\r\nif (!mmc_parent)\r\nreturn -EINVAL;\r\nmmc_parent_rate = clk_get_rate(mmc_parent);\r\nif (!mmc_parent_rate)\r\nreturn -EINVAL;\r\nmmc_div = mmc_parent_rate / mmc_rate;\r\nstep = DIV_ROUND_CLOSEST(360, mmc_div);\r\nreturn delay * step;\r\n}\r\nstatic int mmc_set_phase(struct clk_hw *hw, int degrees)\r\n{\r\nstruct clk *mmc, *mmc_parent, *clk = hw->clk;\r\nstruct mmc_phase *phase = to_mmc_phase(hw);\r\nunsigned int mmc_rate, mmc_parent_rate;\r\nunsigned long flags;\r\nu32 value;\r\nu8 delay;\r\nmmc = clk_get_parent(clk);\r\nif (!mmc)\r\nreturn -EINVAL;\r\nmmc_rate = clk_get_rate(mmc);\r\nif (!mmc_rate)\r\nreturn -EINVAL;\r\nmmc_parent = clk_get_parent(mmc);\r\nif (!mmc_parent)\r\nreturn -EINVAL;\r\nmmc_parent_rate = clk_get_rate(mmc_parent);\r\nif (!mmc_parent_rate)\r\nreturn -EINVAL;\r\nif (degrees != 180) {\r\nu16 step, mmc_div;\r\nmmc_div = mmc_parent_rate / mmc_rate;\r\nstep = DIV_ROUND_CLOSEST(360, mmc_div);\r\ndelay = DIV_ROUND_CLOSEST(degrees, step);\r\n} else {\r\ndelay = 0;\r\n}\r\nspin_lock_irqsave(phase->lock, flags);\r\nvalue = readl(phase->reg);\r\nvalue &= ~GENMASK(phase->offset + 3, phase->offset);\r\nvalue |= delay << phase->offset;\r\nwritel(value, phase->reg);\r\nspin_unlock_irqrestore(phase->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void __init sunxi_mmc_setup(struct device_node *node,\r\nconst struct factors_data *data,\r\nspinlock_t *lock)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nconst char *parent;\r\nvoid __iomem *reg;\r\nint i;\r\nreg = of_io_request_and_map(node, 0, of_node_full_name(node));\r\nif (IS_ERR(reg)) {\r\npr_err("Couldn't map the %s clock registers\n", node->name);\r\nreturn;\r\n}\r\nclk_data = kmalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\nreturn;\r\nclk_data->clks = kcalloc(3, sizeof(*clk_data->clks), GFP_KERNEL);\r\nif (!clk_data->clks)\r\ngoto err_free_data;\r\nclk_data->clk_num = 3;\r\nclk_data->clks[0] = sunxi_factors_register(node, data, lock, reg);\r\nif (!clk_data->clks[0])\r\ngoto err_free_clks;\r\nparent = __clk_get_name(clk_data->clks[0]);\r\nfor (i = 1; i < 3; i++) {\r\nstruct clk_init_data init = {\r\n.num_parents = 1,\r\n.parent_names = &parent,\r\n.ops = &mmc_clk_ops,\r\n};\r\nstruct mmc_phase *phase;\r\nphase = kmalloc(sizeof(*phase), GFP_KERNEL);\r\nif (!phase)\r\ncontinue;\r\nphase->hw.init = &init;\r\nphase->reg = reg;\r\nphase->lock = lock;\r\nif (i == 1)\r\nphase->offset = 8;\r\nelse\r\nphase->offset = 20;\r\nif (of_property_read_string_index(node, "clock-output-names",\r\ni, &init.name))\r\ninit.name = node->name;\r\nclk_data->clks[i] = clk_register(NULL, &phase->hw);\r\nif (IS_ERR(clk_data->clks[i])) {\r\nkfree(phase);\r\ncontinue;\r\n}\r\n}\r\nof_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nreturn;\r\nerr_free_clks:\r\nkfree(clk_data->clks);\r\nerr_free_data:\r\nkfree(clk_data);\r\n}\r\nstatic void __init sun4i_a10_mmc_setup(struct device_node *node)\r\n{\r\nsunxi_mmc_setup(node, &sun4i_a10_mod0_data, &sun4i_a10_mmc_lock);\r\n}\r\nstatic void __init sun9i_a80_mmc_setup(struct device_node *node)\r\n{\r\nsunxi_mmc_setup(node, &sun9i_a80_mod0_data, &sun9i_a80_mmc_lock);\r\n}
