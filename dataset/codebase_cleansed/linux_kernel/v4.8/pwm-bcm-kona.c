static inline struct kona_pwmc *to_kona_pwmc(struct pwm_chip *_chip)\r\n{\r\nreturn container_of(_chip, struct kona_pwmc, chip);\r\n}\r\nstatic void kona_pwmc_prepare_for_settings(struct kona_pwmc *kp,\r\nunsigned int chan)\r\n{\r\nunsigned int value = readl(kp->base + PWM_CONTROL_OFFSET);\r\nvalue |= 1 << PWM_CONTROL_SMOOTH_SHIFT(chan);\r\nvalue &= ~(1 << PWM_CONTROL_TRIGGER_SHIFT(chan));\r\nwritel(value, kp->base + PWM_CONTROL_OFFSET);\r\nndelay(400);\r\n}\r\nstatic void kona_pwmc_apply_settings(struct kona_pwmc *kp, unsigned int chan)\r\n{\r\nunsigned int value = readl(kp->base + PWM_CONTROL_OFFSET);\r\nvalue &= ~(1 << PWM_CONTROL_SMOOTH_SHIFT(chan));\r\nvalue |= 1 << PWM_CONTROL_TRIGGER_SHIFT(chan);\r\nwritel(value, kp->base + PWM_CONTROL_OFFSET);\r\nndelay(400);\r\n}\r\nstatic int kona_pwmc_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct kona_pwmc *kp = to_kona_pwmc(chip);\r\nu64 val, div, rate;\r\nunsigned long prescale = PRESCALE_MIN, pc, dc;\r\nunsigned int value, chan = pwm->hwpwm;\r\nrate = clk_get_rate(kp->clk);\r\nwhile (1) {\r\ndiv = 1000000000;\r\ndiv *= 1 + prescale;\r\nval = rate * period_ns;\r\npc = div64_u64(val, div);\r\nval = rate * duty_ns;\r\ndc = div64_u64(val, div);\r\nif (pc < PERIOD_COUNT_MIN || dc < DUTY_CYCLE_HIGH_MIN)\r\nreturn -EINVAL;\r\nif (pc <= PERIOD_COUNT_MAX && dc <= DUTY_CYCLE_HIGH_MAX)\r\nbreak;\r\nif (++prescale > PRESCALE_MAX)\r\nreturn -EINVAL;\r\n}\r\nif (pwm_is_enabled(pwm)) {\r\nkona_pwmc_prepare_for_settings(kp, chan);\r\nvalue = readl(kp->base + PRESCALE_OFFSET);\r\nvalue &= ~PRESCALE_MASK(chan);\r\nvalue |= prescale << PRESCALE_SHIFT(chan);\r\nwritel(value, kp->base + PRESCALE_OFFSET);\r\nwritel(pc, kp->base + PERIOD_COUNT_OFFSET(chan));\r\nwritel(dc, kp->base + DUTY_CYCLE_HIGH_OFFSET(chan));\r\nkona_pwmc_apply_settings(kp, chan);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kona_pwmc_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct kona_pwmc *kp = to_kona_pwmc(chip);\r\nunsigned int chan = pwm->hwpwm;\r\nunsigned int value;\r\nint ret;\r\nret = clk_prepare_enable(kp->clk);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "failed to enable clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nkona_pwmc_prepare_for_settings(kp, chan);\r\nvalue = readl(kp->base + PWM_CONTROL_OFFSET);\r\nif (polarity == PWM_POLARITY_NORMAL)\r\nvalue |= 1 << PWM_CONTROL_POLARITY_SHIFT(chan);\r\nelse\r\nvalue &= ~(1 << PWM_CONTROL_POLARITY_SHIFT(chan));\r\nwritel(value, kp->base + PWM_CONTROL_OFFSET);\r\nkona_pwmc_apply_settings(kp, chan);\r\nclk_disable_unprepare(kp->clk);\r\nreturn 0;\r\n}\r\nstatic int kona_pwmc_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct kona_pwmc *kp = to_kona_pwmc(chip);\r\nint ret;\r\nret = clk_prepare_enable(kp->clk);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "failed to enable clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = kona_pwmc_config(chip, pwm, pwm_get_duty_cycle(pwm),\r\npwm_get_period(pwm));\r\nif (ret < 0) {\r\nclk_disable_unprepare(kp->clk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void kona_pwmc_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct kona_pwmc *kp = to_kona_pwmc(chip);\r\nunsigned int chan = pwm->hwpwm;\r\nunsigned int value;\r\nkona_pwmc_prepare_for_settings(kp, chan);\r\nwritel(0, kp->base + DUTY_CYCLE_HIGH_OFFSET(chan));\r\nwritel(0, kp->base + PERIOD_COUNT_OFFSET(chan));\r\nvalue = readl(kp->base + PRESCALE_OFFSET);\r\nvalue &= ~PRESCALE_MASK(chan);\r\nwritel(value, kp->base + PRESCALE_OFFSET);\r\nkona_pwmc_apply_settings(kp, chan);\r\nclk_disable_unprepare(kp->clk);\r\n}\r\nstatic int kona_pwmc_probe(struct platform_device *pdev)\r\n{\r\nstruct kona_pwmc *kp;\r\nstruct resource *res;\r\nunsigned int chan;\r\nunsigned int value = 0;\r\nint ret = 0;\r\nkp = devm_kzalloc(&pdev->dev, sizeof(*kp), GFP_KERNEL);\r\nif (kp == NULL)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, kp);\r\nkp->chip.dev = &pdev->dev;\r\nkp->chip.ops = &kona_pwm_ops;\r\nkp->chip.base = -1;\r\nkp->chip.npwm = 6;\r\nkp->chip.of_xlate = of_pwm_xlate_with_flags;\r\nkp->chip.of_pwm_n_cells = 3;\r\nkp->chip.can_sleep = true;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nkp->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(kp->base))\r\nreturn PTR_ERR(kp->base);\r\nkp->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(kp->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock: %ld\n",\r\nPTR_ERR(kp->clk));\r\nreturn PTR_ERR(kp->clk);\r\n}\r\nret = clk_prepare_enable(kp->clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to enable clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (chan = 0; chan < kp->chip.npwm; chan++)\r\nvalue |= (1 << PWM_CONTROL_TYPE_SHIFT(chan));\r\nwritel(value, kp->base + PWM_CONTROL_OFFSET);\r\nclk_disable_unprepare(kp->clk);\r\nret = pwmchip_add_with_polarity(&kp->chip, PWM_POLARITY_INVERSED);\r\nif (ret < 0)\r\ndev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int kona_pwmc_remove(struct platform_device *pdev)\r\n{\r\nstruct kona_pwmc *kp = platform_get_drvdata(pdev);\r\nunsigned int chan;\r\nfor (chan = 0; chan < kp->chip.npwm; chan++)\r\nif (pwm_is_enabled(&kp->chip.pwms[chan]))\r\nclk_disable_unprepare(kp->clk);\r\nreturn pwmchip_remove(&kp->chip);\r\n}
