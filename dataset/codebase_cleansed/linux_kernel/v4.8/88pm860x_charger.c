static int measure_vchg(struct pm860x_charger_info *info, int *data)\r\n{\r\nunsigned char buf[2];\r\nint ret = 0;\r\nret = pm860x_bulk_read(info->i2c, PM8607_VCHG_MEAS1, 2, buf);\r\nif (ret < 0)\r\nreturn ret;\r\n*data = ((buf[0] & 0xff) << 4) | (buf[1] & 0x0f);\r\n*data = ((*data & 0xfff) * 9 * 125) >> 9;\r\ndev_dbg(info->dev, "%s, vchg: %d mv\n", __func__, *data);\r\nreturn ret;\r\n}\r\nstatic void set_vchg_threshold(struct pm860x_charger_info *info,\r\nint min, int max)\r\n{\r\nint data;\r\nif (min <= 0)\r\ndata = 0;\r\nelse\r\ndata = (min << 5) / 1125;\r\npm860x_reg_write(info->i2c, PM8607_VCHG_LOWTH, data);\r\ndev_dbg(info->dev, "VCHG_LOWTH:%dmv, 0x%x\n", min, data);\r\nif (max <= 0)\r\ndata = 0xff;\r\nelse\r\ndata = (max << 5) / 1125;\r\npm860x_reg_write(info->i2c, PM8607_VCHG_HIGHTH, data);\r\ndev_dbg(info->dev, "VCHG_HIGHTH:%dmv, 0x%x\n", max, data);\r\n}\r\nstatic void set_vbatt_threshold(struct pm860x_charger_info *info,\r\nint min, int max)\r\n{\r\nint data;\r\nif (min <= 0)\r\ndata = 0;\r\nelse\r\ndata = (min << 5) / 675;\r\npm860x_reg_write(info->i2c, PM8607_VBAT_LOWTH, data);\r\ndev_dbg(info->dev, "VBAT Min:%dmv, LOWTH:0x%x\n", min, data);\r\nif (max <= 0)\r\ndata = 0xff;\r\nelse\r\ndata = (max << 5) / 675;\r\npm860x_reg_write(info->i2c, PM8607_VBAT_HIGHTH, data);\r\ndev_dbg(info->dev, "VBAT Max:%dmv, HIGHTH:0x%x\n", max, data);\r\nreturn;\r\n}\r\nstatic int start_precharge(struct pm860x_charger_info *info)\r\n{\r\nint ret;\r\ndev_dbg(info->dev, "Start Pre-charging!\n");\r\nset_vbatt_threshold(info, 0, 0);\r\nret = pm860x_reg_write(info->i2c_8606, PM8606_PREREGULATORA,\r\nPREREG1_1350MA | PREREG1_VSYS_4_5V);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL1, 3,\r\nCC1_MODE_OFF);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL3, (0xf << 4),\r\nCC3_270MIN_TIMEOUT);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_reg_write(info->i2c, PM8607_CHG_CTRL4,\r\nCC4_IPRE_40MA | CC4_VPCHG_3_2V |\r\nCC4_IFCHG_MON_EN | CC4_BTEMP_MON_EN);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL7,\r\nCC7_BAT_REM_EN | CC7_IFSM_EN,\r\nCC7_BAT_REM_EN | CC7_IFSM_EN);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL1, 3,\r\nCC1_MODE_PRECHARGE);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int start_fastcharge(struct pm860x_charger_info *info)\r\n{\r\nint ret;\r\ndev_dbg(info->dev, "Start Fast-charging!\n");\r\nret = pm860x_reg_write(info->i2c, PM8607_CHG_CTRL1,\r\nCC1_MODE_OFF | CC1_ITERM_60MA |\r\nCC1_VFCHG_4_2V);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_reg_write(info->i2c_8606, PM8606_PREREGULATORA,\r\nPREREG1_540MA | PREREG1_VSYS_4_5V);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL2, 0x1f,\r\nCC2_ICHG_500MA);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL3, (0xf << 4),\r\nCC3_270MIN_TIMEOUT);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL4,\r\nCC4_IFCHG_MON_EN | CC4_BTEMP_MON_EN,\r\nCC4_IFCHG_MON_EN | CC4_BTEMP_MON_EN);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL6,\r\nCC6_BAT_OV_EN | CC6_BAT_UV_EN |\r\nCC6_UV_VBAT_SET,\r\nCC6_BAT_OV_EN | CC6_BAT_UV_EN |\r\nCC6_UV_VBAT_SET);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL7,\r\nCC7_BAT_REM_EN | CC7_IFSM_EN,\r\nCC7_BAT_REM_EN | CC7_IFSM_EN);\r\nif (ret < 0)\r\ngoto out;\r\nret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL1, 3,\r\nCC1_MODE_FASTCHARGE);\r\nset_vchg_threshold(info, VCHG_NORMAL_LOW, VCHG_NORMAL_HIGH);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void stop_charge(struct pm860x_charger_info *info, int vbatt)\r\n{\r\ndev_dbg(info->dev, "Stop charging!\n");\r\npm860x_set_bits(info->i2c, PM8607_CHG_CTRL1, 3, CC1_MODE_OFF);\r\nif (vbatt > CHARGE_THRESHOLD && info->online)\r\nset_vbatt_threshold(info, CHARGE_THRESHOLD, 0);\r\n}\r\nstatic void power_off_notification(struct pm860x_charger_info *info)\r\n{\r\ndev_dbg(info->dev, "Power-off notification!\n");\r\n}\r\nstatic int set_charging_fsm(struct pm860x_charger_info *info)\r\n{\r\nstruct power_supply *psy;\r\nunion power_supply_propval data;\r\nunsigned char fsm_state[][16] = { "init", "discharge", "precharge",\r\n"fastcharge",\r\n};\r\nint ret;\r\nint vbatt;\r\npsy = power_supply_get_by_name(pm860x_supplied_to[0]);\r\nif (!psy)\r\nreturn -EINVAL;\r\nret = power_supply_get_property(psy, POWER_SUPPLY_PROP_VOLTAGE_NOW,\r\n&data);\r\nif (ret) {\r\npower_supply_put(psy);\r\nreturn ret;\r\n}\r\nvbatt = data.intval / 1000;\r\nret = power_supply_get_property(psy, POWER_SUPPLY_PROP_PRESENT, &data);\r\nif (ret) {\r\npower_supply_put(psy);\r\nreturn ret;\r\n}\r\npower_supply_put(psy);\r\nmutex_lock(&info->lock);\r\ninfo->present = data.intval;\r\ndev_dbg(info->dev, "Entering FSM:%s, Charger:%s, Battery:%s, "\r\n"Allowed:%d\n",\r\n&fsm_state[info->state][0],\r\n(info->online) ? "online" : "N/A",\r\n(info->present) ? "present" : "N/A", info->allowed);\r\ndev_dbg(info->dev, "set_charging_fsm:vbatt:%d(mV)\n", vbatt);\r\nswitch (info->state) {\r\ncase FSM_INIT:\r\nif (info->online && info->present && info->allowed) {\r\nif (vbatt < PRECHARGE_THRESHOLD) {\r\ninfo->state = FSM_PRECHARGE;\r\nstart_precharge(info);\r\n} else if (vbatt > DISCHARGE_THRESHOLD) {\r\ninfo->state = FSM_DISCHARGE;\r\nstop_charge(info, vbatt);\r\n} else if (vbatt < DISCHARGE_THRESHOLD) {\r\ninfo->state = FSM_FASTCHARGE;\r\nstart_fastcharge(info);\r\n}\r\n} else {\r\nif (vbatt < POWEROFF_THRESHOLD) {\r\npower_off_notification(info);\r\n} else {\r\ninfo->state = FSM_DISCHARGE;\r\nstop_charge(info, vbatt);\r\n}\r\n}\r\nbreak;\r\ncase FSM_PRECHARGE:\r\nif (info->online && info->present && info->allowed) {\r\nif (vbatt > PRECHARGE_THRESHOLD) {\r\ninfo->state = FSM_FASTCHARGE;\r\nstart_fastcharge(info);\r\n}\r\n} else {\r\ninfo->state = FSM_DISCHARGE;\r\nstop_charge(info, vbatt);\r\n}\r\nbreak;\r\ncase FSM_FASTCHARGE:\r\nif (info->online && info->present && info->allowed) {\r\nif (vbatt < PRECHARGE_THRESHOLD) {\r\ninfo->state = FSM_PRECHARGE;\r\nstart_precharge(info);\r\n}\r\n} else {\r\ninfo->state = FSM_DISCHARGE;\r\nstop_charge(info, vbatt);\r\n}\r\nbreak;\r\ncase FSM_DISCHARGE:\r\nif (info->online && info->present && info->allowed) {\r\nif (vbatt < PRECHARGE_THRESHOLD) {\r\ninfo->state = FSM_PRECHARGE;\r\nstart_precharge(info);\r\n} else if (vbatt < DISCHARGE_THRESHOLD) {\r\ninfo->state = FSM_FASTCHARGE;\r\nstart_fastcharge(info);\r\n}\r\n} else {\r\nif (vbatt < POWEROFF_THRESHOLD)\r\npower_off_notification(info);\r\nelse if (vbatt > CHARGE_THRESHOLD && info->online)\r\nset_vbatt_threshold(info, CHARGE_THRESHOLD, 0);\r\n}\r\nbreak;\r\ndefault:\r\ndev_warn(info->dev, "FSM meets wrong state:%d\n",\r\ninfo->state);\r\nbreak;\r\n}\r\ndev_dbg(info->dev,\r\n"Out FSM:%s, Charger:%s, Battery:%s, Allowed:%d\n",\r\n&fsm_state[info->state][0],\r\n(info->online) ? "online" : "N/A",\r\n(info->present) ? "present" : "N/A", info->allowed);\r\nmutex_unlock(&info->lock);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pm860x_charger_handler(int irq, void *data)\r\n{\r\nstruct pm860x_charger_info *info = data;\r\nint ret;\r\nmutex_lock(&info->lock);\r\nret = pm860x_reg_read(info->i2c, PM8607_STATUS_2);\r\nif (ret < 0) {\r\nmutex_unlock(&info->lock);\r\ngoto out;\r\n}\r\nif (ret & STATUS2_CHG) {\r\ninfo->online = 1;\r\ninfo->allowed = 1;\r\n} else {\r\ninfo->online = 0;\r\ninfo->allowed = 0;\r\n}\r\nmutex_unlock(&info->lock);\r\ndev_dbg(info->dev, "%s, Charger:%s, Allowed:%d\n", __func__,\r\n(info->online) ? "online" : "N/A", info->allowed);\r\nset_charging_fsm(info);\r\npower_supply_changed(info->usb);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pm860x_temp_handler(int irq, void *data)\r\n{\r\nstruct power_supply *psy;\r\nstruct pm860x_charger_info *info = data;\r\nunion power_supply_propval temp;\r\nint value;\r\nint ret;\r\npsy = power_supply_get_by_name(pm860x_supplied_to[0]);\r\nif (!psy)\r\nreturn IRQ_HANDLED;\r\nret = power_supply_get_property(psy, POWER_SUPPLY_PROP_TEMP, &temp);\r\nif (ret)\r\ngoto out;\r\nvalue = temp.intval / 10;\r\nmutex_lock(&info->lock);\r\nif (value < -10 || value > 40)\r\ninfo->allowed = 0;\r\nelse\r\ninfo->allowed = 1;\r\ndev_dbg(info->dev, "%s, Allowed: %d\n", __func__, info->allowed);\r\nmutex_unlock(&info->lock);\r\nset_charging_fsm(info);\r\nout:\r\npower_supply_put(psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pm860x_exception_handler(int irq, void *data)\r\n{\r\nstruct pm860x_charger_info *info = data;\r\nmutex_lock(&info->lock);\r\ninfo->allowed = 0;\r\nmutex_unlock(&info->lock);\r\ndev_dbg(info->dev, "%s, irq: %d\n", __func__, irq);\r\nset_charging_fsm(info);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pm860x_done_handler(int irq, void *data)\r\n{\r\nstruct pm860x_charger_info *info = data;\r\nstruct power_supply *psy;\r\nunion power_supply_propval val;\r\nint ret;\r\nint vbatt;\r\nmutex_lock(&info->lock);\r\nif (info->state == FSM_PRECHARGE) {\r\ninfo->allowed = 1;\r\ngoto out;\r\n}\r\nmdelay(5);\r\ninfo->allowed = 0;\r\npsy = power_supply_get_by_name(pm860x_supplied_to[0]);\r\nif (!psy)\r\ngoto out;\r\nret = power_supply_get_property(psy, POWER_SUPPLY_PROP_VOLTAGE_NOW,\r\n&val);\r\nif (ret)\r\ngoto out_psy_put;\r\nvbatt = val.intval / 1000;\r\nret = pm860x_reg_read(info->i2c, PM8607_STATUS_2);\r\nif (ret < 0)\r\ngoto out_psy_put;\r\nif (vbatt > CHARGE_THRESHOLD && ret & STATUS2_CHG)\r\npower_supply_set_property(psy, POWER_SUPPLY_PROP_CHARGE_FULL,\r\n&val);\r\nout_psy_put:\r\npower_supply_put(psy);\r\nout:\r\nmutex_unlock(&info->lock);\r\ndev_dbg(info->dev, "%s, Allowed: %d\n", __func__, info->allowed);\r\nset_charging_fsm(info);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pm860x_vbattery_handler(int irq, void *data)\r\n{\r\nstruct pm860x_charger_info *info = data;\r\nmutex_lock(&info->lock);\r\nset_vbatt_threshold(info, 0, 0);\r\nif (info->present && info->online)\r\ninfo->allowed = 1;\r\nelse\r\ninfo->allowed = 0;\r\nmutex_unlock(&info->lock);\r\ndev_dbg(info->dev, "%s, Allowed: %d\n", __func__, info->allowed);\r\nset_charging_fsm(info);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pm860x_vchg_handler(int irq, void *data)\r\n{\r\nstruct pm860x_charger_info *info = data;\r\nint vchg = 0;\r\nif (info->present)\r\ngoto out;\r\nmeasure_vchg(info, &vchg);\r\nmutex_lock(&info->lock);\r\nif (!info->online) {\r\nint status;\r\nstatus = pm860x_reg_read(info->i2c_8606, PM8606_FLAGS);\r\nif (status & OVER_TEMP_FLAG) {\r\npm860x_set_bits(info->i2c_8606, PM8606_FLAGS,\r\nOVER_TEMP_FLAG, OVER_TEMP_FLAG);\r\npm860x_set_bits(info->i2c_8606,\r\nPM8606_VSYS,\r\nOVTEMP_AUTORECOVER,\r\nOVTEMP_AUTORECOVER);\r\ndev_dbg(info->dev,\r\n"%s, pm8606 over-temp occurred\n", __func__);\r\n}\r\n}\r\nif (vchg > VCHG_NORMAL_CHECK) {\r\nset_vchg_threshold(info, VCHG_OVP_LOW, 0);\r\ninfo->allowed = 0;\r\ndev_dbg(info->dev,\r\n"%s,pm8607 over-vchg occurred,vchg = %dmv\n",\r\n__func__, vchg);\r\n} else if (vchg < VCHG_OVP_LOW) {\r\nset_vchg_threshold(info, VCHG_NORMAL_LOW,\r\nVCHG_NORMAL_HIGH);\r\ninfo->allowed = 1;\r\ndev_dbg(info->dev,\r\n"%s,pm8607 over-vchg recover,vchg = %dmv\n",\r\n__func__, vchg);\r\n}\r\nmutex_unlock(&info->lock);\r\ndev_dbg(info->dev, "%s, Allowed: %d\n", __func__, info->allowed);\r\nset_charging_fsm(info);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pm860x_usb_get_prop(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct pm860x_charger_info *info = power_supply_get_drvdata(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (info->state == FSM_FASTCHARGE ||\r\ninfo->state == FSM_PRECHARGE)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = info->online;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm860x_init_charger(struct pm860x_charger_info *info)\r\n{\r\nint ret;\r\nret = pm860x_reg_read(info->i2c, PM8607_STATUS_2);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&info->lock);\r\ninfo->state = FSM_INIT;\r\nif (ret & STATUS2_CHG) {\r\ninfo->online = 1;\r\ninfo->allowed = 1;\r\n} else {\r\ninfo->online = 0;\r\ninfo->allowed = 0;\r\n}\r\nmutex_unlock(&info->lock);\r\nset_charging_fsm(info);\r\nreturn 0;\r\n}\r\nstatic int pm860x_charger_probe(struct platform_device *pdev)\r\n{\r\nstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\r\nstruct power_supply_config psy_cfg = {};\r\nstruct pm860x_charger_info *info;\r\nint ret;\r\nint count;\r\nint i;\r\nint j;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ncount = pdev->num_resources;\r\nfor (i = 0, j = 0; i < count; i++) {\r\ninfo->irq[j] = platform_get_irq(pdev, i);\r\nif (info->irq[j] < 0)\r\ncontinue;\r\nj++;\r\n}\r\ninfo->irq_nums = j;\r\ninfo->chip = chip;\r\ninfo->i2c =\r\n(chip->id == CHIP_PM8607) ? chip->client : chip->companion;\r\ninfo->i2c_8606 =\r\n(chip->id == CHIP_PM8607) ? chip->companion : chip->client;\r\nif (!info->i2c_8606) {\r\ndev_err(&pdev->dev, "Missed I2C address of 88PM8606!\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ninfo->dev = &pdev->dev;\r\nset_vchg_threshold(info, VCHG_NORMAL_LOW, VCHG_OVP_LOW);\r\nmutex_init(&info->lock);\r\nplatform_set_drvdata(pdev, info);\r\npsy_cfg.drv_data = info;\r\npsy_cfg.supplied_to = pm860x_supplied_to;\r\npsy_cfg.num_supplicants = ARRAY_SIZE(pm860x_supplied_to);\r\ninfo->usb = power_supply_register(&pdev->dev, &pm860x_charger_desc,\r\n&psy_cfg);\r\nif (IS_ERR(info->usb)) {\r\nret = PTR_ERR(info->usb);\r\ngoto out;\r\n}\r\npm860x_init_charger(info);\r\nfor (i = 0; i < ARRAY_SIZE(info->irq); i++) {\r\nret = request_threaded_irq(info->irq[i], NULL,\r\npm860x_irq_descs[i].handler,\r\nIRQF_ONESHOT, pm860x_irq_descs[i].name, info);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",\r\ninfo->irq[i], ret);\r\ngoto out_irq;\r\n}\r\n}\r\nreturn 0;\r\nout_irq:\r\npower_supply_unregister(info->usb);\r\nwhile (--i >= 0)\r\nfree_irq(info->irq[i], info);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pm860x_charger_remove(struct platform_device *pdev)\r\n{\r\nstruct pm860x_charger_info *info = platform_get_drvdata(pdev);\r\nint i;\r\npower_supply_unregister(info->usb);\r\nfor (i = 0; i < info->irq_nums; i++)\r\nfree_irq(info->irq[i], info);\r\nreturn 0;\r\n}
