static inline void walkera0701_parse_frame(struct walkera_dev *w)\r\n{\r\nint i;\r\nint val1, val2, val3, val4, val5, val6, val7, val8;\r\nint magic, magic_bit;\r\nint crc1, crc2;\r\nfor (crc1 = crc2 = i = 0; i < 10; i++) {\r\ncrc1 += w->buf[i] & 7;\r\ncrc2 += (w->buf[i] & 8) >> 3;\r\n}\r\nif ((w->buf[10] & 7) != (crc1 & 7))\r\nreturn;\r\nif (((w->buf[10] & 8) >> 3) != (((crc1 >> 3) + crc2) & 1))\r\nreturn;\r\nfor (crc1 = crc2 = 0, i = 11; i < 23; i++) {\r\ncrc1 += w->buf[i] & 7;\r\ncrc2 += (w->buf[i] & 8) >> 3;\r\n}\r\nif ((w->buf[23] & 7) != (crc1 & 7))\r\nreturn;\r\nif (((w->buf[23] & 8) >> 3) != (((crc1 >> 3) + crc2) & 1))\r\nreturn;\r\nval1 = ((w->buf[0] & 7) * 256 + w->buf[1] * 16 + w->buf[2]) >> 2;\r\nval1 *= ((w->buf[0] >> 2) & 2) - 1;\r\nval2 = (w->buf[2] & 1) << 8 | (w->buf[3] << 4) | w->buf[4];\r\nval2 *= (w->buf[2] & 2) - 1;\r\nval3 = ((w->buf[5] & 7) * 256 + w->buf[6] * 16 + w->buf[7]) >> 2;\r\nval3 *= ((w->buf[5] >> 2) & 2) - 1;\r\nval4 = (w->buf[7] & 1) << 8 | (w->buf[8] << 4) | w->buf[9];\r\nval4 *= (w->buf[7] & 2) - 1;\r\nval5 = ((w->buf[11] & 7) * 256 + w->buf[12] * 16 + w->buf[13]) >> 2;\r\nval5 *= ((w->buf[11] >> 2) & 2) - 1;\r\nval6 = (w->buf[13] & 1) << 8 | (w->buf[14] << 4) | w->buf[15];\r\nval6 *= (w->buf[13] & 2) - 1;\r\nval7 = ((w->buf[16] & 7) * 256 + w->buf[17] * 16 + w->buf[18]) >> 2;\r\nval7 *= ((w->buf[16] >> 2) & 2) - 1;\r\nval8 = (w->buf[18] & 1) << 8 | (w->buf[19] << 4) | w->buf[20];\r\nval8 *= (w->buf[18] & 2) - 1;\r\nmagic = (w->buf[21] << 4) | w->buf[22];\r\nmagic_bit = (w->buf[24] & 8) >> 3;\r\npr_debug("%4d %4d %4d %4d %4d %4d %4d %4d (magic %2x %d)\n",\r\nval1, val2, val3, val4, val5, val6, val7, val8,\r\nmagic, magic_bit);\r\ninput_report_abs(w->input_dev, ABS_X, val2);\r\ninput_report_abs(w->input_dev, ABS_Y, val1);\r\ninput_report_abs(w->input_dev, ABS_Z, val6);\r\ninput_report_abs(w->input_dev, ABS_THROTTLE, val3);\r\ninput_report_abs(w->input_dev, ABS_RUDDER, val4);\r\ninput_report_abs(w->input_dev, ABS_MISC, val7);\r\ninput_report_key(w->input_dev, BTN_GEAR_DOWN, val5 > 0);\r\n}\r\nstatic inline int read_ack(struct pardevice *p)\r\n{\r\nreturn parport_read_status(p->port) & 0x40;\r\n}\r\nstatic void walkera0701_irq_handler(void *handler_data)\r\n{\r\nu64 pulse_time;\r\nstruct walkera_dev *w = handler_data;\r\nw->irq_time = ktime_to_ns(ktime_get());\r\npulse_time = w->irq_time - w->irq_lasttime;\r\nw->irq_lasttime = w->irq_time;\r\nif (unlikely(0 != hrtimer_try_to_cancel(&w->timer))) {\r\nw->counter = NO_SYNC;\r\nreturn;\r\n}\r\nif (w->counter < NO_SYNC) {\r\nif (w->ack) {\r\npulse_time -= BIN1_PULSE;\r\nw->buf[w->counter] = 8;\r\n} else {\r\npulse_time -= BIN0_PULSE;\r\nw->buf[w->counter] = 0;\r\n}\r\nif (w->counter == 24) {\r\nwalkera0701_parse_frame(w);\r\nw->counter = NO_SYNC;\r\nif (abs(pulse_time - SYNC_PULSE) < RESERVE)\r\nw->counter = 0;\r\n} else {\r\nif ((pulse_time > (ANALOG_MIN_PULSE - RESERVE)\r\n&& (pulse_time < (ANALOG_MAX_PULSE + RESERVE)))) {\r\npulse_time -= (ANALOG_MIN_PULSE - RESERVE);\r\npulse_time = (u32) pulse_time / ANALOG_DELTA;\r\nw->buf[w->counter++] |= (pulse_time & 7);\r\n} else\r\nw->counter = NO_SYNC;\r\n}\r\n} else if (abs(pulse_time - SYNC_PULSE - BIN0_PULSE) <\r\nRESERVE + BIN1_PULSE - BIN0_PULSE)\r\nw->counter = 0;\r\nhrtimer_start(&w->timer, ktime_set(0, BIN_SAMPLE), HRTIMER_MODE_REL);\r\n}\r\nstatic enum hrtimer_restart timer_handler(struct hrtimer\r\n*handle)\r\n{\r\nstruct walkera_dev *w;\r\nw = container_of(handle, struct walkera_dev, timer);\r\nw->ack = read_ack(w->pardevice);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int walkera0701_open(struct input_dev *dev)\r\n{\r\nstruct walkera_dev *w = input_get_drvdata(dev);\r\nif (parport_claim(w->pardevice))\r\nreturn -EBUSY;\r\nparport_enable_irq(w->parport);\r\nreturn 0;\r\n}\r\nstatic void walkera0701_close(struct input_dev *dev)\r\n{\r\nstruct walkera_dev *w = input_get_drvdata(dev);\r\nparport_disable_irq(w->parport);\r\nhrtimer_cancel(&w->timer);\r\nparport_release(w->pardevice);\r\n}\r\nstatic void walkera0701_attach(struct parport *pp)\r\n{\r\nstruct pardev_cb walkera0701_parport_cb;\r\nstruct walkera_dev *w = &w_dev;\r\nif (pp->number != walkera0701_pp_no) {\r\npr_debug("Not using parport%d.\n", pp->number);\r\nreturn;\r\n}\r\nif (pp->irq == -1) {\r\npr_err("parport %d does not have interrupt assigned\n",\r\npp->number);\r\nreturn;\r\n}\r\nw->parport = pp;\r\nmemset(&walkera0701_parport_cb, 0, sizeof(walkera0701_parport_cb));\r\nwalkera0701_parport_cb.flags = PARPORT_FLAG_EXCL;\r\nwalkera0701_parport_cb.irq_func = walkera0701_irq_handler;\r\nwalkera0701_parport_cb.private = w;\r\nw->pardevice = parport_register_dev_model(pp, "walkera0701",\r\n&walkera0701_parport_cb, 0);\r\nif (!w->pardevice) {\r\npr_err("failed to register parport device\n");\r\nreturn;\r\n}\r\nif (parport_negotiate(w->pardevice->port, IEEE1284_MODE_COMPAT)) {\r\npr_err("failed to negotiate parport mode\n");\r\ngoto err_unregister_device;\r\n}\r\nhrtimer_init(&w->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nw->timer.function = timer_handler;\r\nw->input_dev = input_allocate_device();\r\nif (!w->input_dev) {\r\npr_err("failed to allocate input device\n");\r\ngoto err_unregister_device;\r\n}\r\ninput_set_drvdata(w->input_dev, w);\r\nw->input_dev->name = "Walkera WK-0701 TX";\r\nw->input_dev->phys = w->parport->name;\r\nw->input_dev->id.bustype = BUS_PARPORT;\r\nw->input_dev->id.vendor = 0x0001;\r\nw->input_dev->id.product = 0x0001;\r\nw->input_dev->id.version = 0x0100;\r\nw->input_dev->dev.parent = w->parport->dev;\r\nw->input_dev->open = walkera0701_open;\r\nw->input_dev->close = walkera0701_close;\r\nw->input_dev->evbit[0] = BIT(EV_ABS) | BIT_MASK(EV_KEY);\r\nw->input_dev->keybit[BIT_WORD(BTN_GEAR_DOWN)] = BIT_MASK(BTN_GEAR_DOWN);\r\ninput_set_abs_params(w->input_dev, ABS_X, -512, 512, 0, 0);\r\ninput_set_abs_params(w->input_dev, ABS_Y, -512, 512, 0, 0);\r\ninput_set_abs_params(w->input_dev, ABS_Z, -512, 512, 0, 0);\r\ninput_set_abs_params(w->input_dev, ABS_THROTTLE, -512, 512, 0, 0);\r\ninput_set_abs_params(w->input_dev, ABS_RUDDER, -512, 512, 0, 0);\r\ninput_set_abs_params(w->input_dev, ABS_MISC, -512, 512, 0, 0);\r\nif (input_register_device(w->input_dev)) {\r\npr_err("failed to register input device\n");\r\ngoto err_free_input_dev;\r\n}\r\nreturn;\r\nerr_free_input_dev:\r\ninput_free_device(w->input_dev);\r\nerr_unregister_device:\r\nparport_unregister_device(w->pardevice);\r\n}\r\nstatic void walkera0701_detach(struct parport *port)\r\n{\r\nstruct walkera_dev *w = &w_dev;\r\nif (!w->pardevice || w->parport->number != port->number)\r\nreturn;\r\ninput_unregister_device(w->input_dev);\r\nparport_unregister_device(w->pardevice);\r\nw->parport = NULL;\r\n}\r\nstatic int __init walkera0701_init(void)\r\n{\r\nreturn parport_register_driver(&walkera0701_parport_driver);\r\n}\r\nstatic void __exit walkera0701_exit(void)\r\n{\r\nparport_unregister_driver(&walkera0701_parport_driver);\r\n}
