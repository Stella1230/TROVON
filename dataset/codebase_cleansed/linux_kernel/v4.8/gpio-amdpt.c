static int pt_gpio_request(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pt_gpio_chip *pt_gpio = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 using_pins;\r\ndev_dbg(gc->parent, "pt_gpio_request offset=%x\n", offset);\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nusing_pins = readl(pt_gpio->reg_base + PT_SYNC_REG);\r\nif (using_pins & BIT(offset)) {\r\ndev_warn(gc->parent, "PT GPIO pin %x reconfigured\n",\r\noffset);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nwritel(using_pins | BIT(offset), pt_gpio->reg_base + PT_SYNC_REG);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void pt_gpio_free(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pt_gpio_chip *pt_gpio = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 using_pins;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nusing_pins = readl(pt_gpio->reg_base + PT_SYNC_REG);\r\nusing_pins &= ~BIT(offset);\r\nwritel(using_pins, pt_gpio->reg_base + PT_SYNC_REG);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\ndev_dbg(gc->parent, "pt_gpio_free offset=%x\n", offset);\r\n}\r\nstatic int pt_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct acpi_device *acpi_dev;\r\nacpi_handle handle = ACPI_HANDLE(dev);\r\nstruct pt_gpio_chip *pt_gpio;\r\nstruct resource *res_mem;\r\nint ret = 0;\r\nif (acpi_bus_get_device(handle, &acpi_dev)) {\r\ndev_err(dev, "PT GPIO device node not found\n");\r\nreturn -ENODEV;\r\n}\r\npt_gpio = devm_kzalloc(dev, sizeof(struct pt_gpio_chip), GFP_KERNEL);\r\nif (!pt_gpio)\r\nreturn -ENOMEM;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_mem) {\r\ndev_err(&pdev->dev, "Failed to get MMIO resource for PT GPIO.\n");\r\nreturn -EINVAL;\r\n}\r\npt_gpio->reg_base = devm_ioremap_resource(dev, res_mem);\r\nif (IS_ERR(pt_gpio->reg_base)) {\r\ndev_err(&pdev->dev, "Failed to map MMIO resource for PT GPIO.\n");\r\nreturn PTR_ERR(pt_gpio->reg_base);\r\n}\r\nret = bgpio_init(&pt_gpio->gc, dev, 4,\r\npt_gpio->reg_base + PT_INPUTDATA_REG,\r\npt_gpio->reg_base + PT_OUTPUTDATA_REG, NULL,\r\npt_gpio->reg_base + PT_DIRECTION_REG, NULL,\r\nBGPIOF_READ_OUTPUT_REG_SET);\r\nif (ret) {\r\ndev_err(&pdev->dev, "bgpio_init failed\n");\r\nreturn ret;\r\n}\r\npt_gpio->gc.owner = THIS_MODULE;\r\npt_gpio->gc.request = pt_gpio_request;\r\npt_gpio->gc.free = pt_gpio_free;\r\npt_gpio->gc.ngpio = PT_TOTAL_GPIO;\r\n#if defined(CONFIG_OF_GPIO)\r\npt_gpio->gc.of_node = pdev->dev.of_node;\r\n#endif\r\nret = gpiochip_add_data(&pt_gpio->gc, pt_gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register GPIO lib\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, pt_gpio);\r\nwritel(0, pt_gpio->reg_base + PT_SYNC_REG);\r\nwritel(0, pt_gpio->reg_base + PT_CLOCKRATE_REG);\r\ndev_dbg(&pdev->dev, "PT GPIO driver loaded\n");\r\nreturn ret;\r\n}\r\nstatic int pt_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct pt_gpio_chip *pt_gpio = platform_get_drvdata(pdev);\r\ngpiochip_remove(&pt_gpio->gc);\r\nreturn 0;\r\n}
