static inline unsigned long get_bank_addr(unsigned int memconfig)\r\n{\r\nreturn (memconfig & SGIMC_MCONFIG_BASEADDR) << ((sgimc->systemid & SGIMC_SYSID_MASKREV) >= 5 ? 24 : 22);\r\n}\r\nstatic inline unsigned long get_bank_size(unsigned int memconfig)\r\n{\r\nreturn ((memconfig & SGIMC_MCONFIG_RMASK) + 0x0100) << ((sgimc->systemid & SGIMC_SYSID_MASKREV) >= 5 ? 16 : 14);\r\n}\r\nstatic inline unsigned int get_bank_config(int bank)\r\n{\r\nunsigned int res = bank > 1 ? sgimc->mconfig1 : sgimc->mconfig0;\r\nreturn bank % 2 ? res & 0xffff : res >> 16;\r\n}\r\nstatic void __init probe_memory(void)\r\n{\r\nint i, j, found, cnt = 0;\r\nstruct mem bank[4];\r\nstruct mem space[2] = {{SGIMC_SEG0_BADDR, 0}, {SGIMC_SEG1_BADDR, 0}};\r\nprintk(KERN_INFO "MC: Probing memory configuration:\n");\r\nfor (i = 0; i < ARRAY_SIZE(bank); i++) {\r\nunsigned int tmp = get_bank_config(i);\r\nif (!(tmp & SGIMC_MCONFIG_BVALID))\r\ncontinue;\r\nbank[cnt].size = get_bank_size(tmp);\r\nbank[cnt].addr = get_bank_addr(tmp);\r\nprintk(KERN_INFO " bank%d: %3ldM @ %08lx\n",\r\ni, bank[cnt].size / 1024 / 1024, bank[cnt].addr);\r\ncnt++;\r\n}\r\ndo {\r\nunsigned long addr, size;\r\nfound = 0;\r\nfor (i = 1; i < cnt; i++)\r\nif (bank[i-1].addr > bank[i].addr) {\r\naddr = bank[i].addr;\r\nsize = bank[i].size;\r\nbank[i].addr = bank[i-1].addr;\r\nbank[i].size = bank[i-1].size;\r\nbank[i-1].addr = addr;\r\nbank[i-1].size = size;\r\nfound = 1;\r\n}\r\n} while (found);\r\nfor (i = 0; i < cnt; i++) {\r\nfound = 0;\r\nfor (j = 0; j < ARRAY_SIZE(space) && !found; j++)\r\nif (space[j].addr + space[j].size == bank[i].addr) {\r\nspace[j].size += bank[i].size;\r\nfound = 1;\r\n}\r\nif (!found)\r\nprintk(KERN_CRIT "MC: Memory configuration mismatch "\r\n"(%08lx), expect Bus Error soon\n",\r\nbank[i].addr);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(space); i++)\r\nif (space[i].size)\r\nadd_memory_region(space[i].addr, space[i].size,\r\nBOOT_MEM_RAM);\r\n}\r\nvoid __init sgimc_init(void)\r\n{\r\nu32 tmp;\r\nsgimc = (struct sgimc_regs *)\r\nioremap(SGIMC_BASE, sizeof(struct sgimc_regs));\r\nprintk(KERN_INFO "MC: SGI memory controller Revision %d\n",\r\n(int) sgimc->systemid & SGIMC_SYSID_MASKREV);\r\ntmp = sgimc->cpuctrl0;\r\ntmp &= ~SGIMC_CCTRL0_WDOG;\r\nsgimc->cpuctrl0 = tmp;\r\nsgimc->cstat = sgimc->gstat = 0;\r\ntmp = sgimc->cpuctrl0;\r\n#ifndef CONFIG_SGI_IP28\r\ntmp |= SGIMC_CCTRL0_EPERRGIO | SGIMC_CCTRL0_EPERRMEM;\r\n#endif\r\ntmp |= SGIMC_CCTRL0_R4KNOCHKPARR;\r\nsgimc->cpuctrl0 = tmp;\r\ntmp = sgimc->cpuctrl1;\r\ntmp &= ~0xf;\r\ntmp |= 0xd;\r\nsgimc->cpuctrl1 = tmp;\r\nsgimc->divider = 0x101;\r\ntmp = sgimc->giopar & SGIMC_GIOPAR_GFX64;\r\ntmp |= SGIMC_GIOPAR_HPC64;\r\ntmp |= SGIMC_GIOPAR_ONEBUS;\r\nif (ip22_is_fullhouse()) {\r\nif (SGIOC_SYSID_BOARDREV(sgioc->sysid) < 2) {\r\ntmp |= SGIMC_GIOPAR_HPC264;\r\ntmp |= SGIMC_GIOPAR_PLINEEXP0;\r\ntmp |= SGIMC_GIOPAR_MASTEREXP1;\r\ntmp |= SGIMC_GIOPAR_RTIMEEXP0;\r\n} else {\r\ntmp |= SGIMC_GIOPAR_HPC264;\r\ntmp |= SGIMC_GIOPAR_PLINEEXP0;\r\ntmp |= SGIMC_GIOPAR_PLINEEXP1;\r\ntmp |= SGIMC_GIOPAR_MASTEREISA;\r\n}\r\n} else {\r\ntmp |= SGIMC_GIOPAR_EISA64;\r\ntmp |= SGIMC_GIOPAR_MASTEREISA;\r\n}\r\nsgimc->giopar = tmp;\r\nprobe_memory();\r\n}\r\nvoid __init prom_meminit(void) {}\r\nvoid __init prom_free_prom_memory(void)\r\n{\r\n#ifdef CONFIG_SGI_IP28\r\nu32 mconfig1;\r\nunsigned long flags;\r\nspinlock_t lock;\r\nspin_lock_irqsave(&lock, flags);\r\nmconfig1 = sgimc->mconfig1;\r\nsgimc->mconfig1 = (mconfig1 & 0xffff0000) | 0x2060;\r\niob();\r\n*(unsigned long *)PHYS_TO_XKSEG_UNCACHED(0x60000000) = 0;\r\niob();\r\nsgimc->cmacc = (sgimc->cmacc & ~0xf) | 4;\r\niob();\r\nsgimc->mconfig1 = mconfig1;\r\niob();\r\nspin_unlock_irqrestore(&lock, flags);\r\n#endif\r\n}
