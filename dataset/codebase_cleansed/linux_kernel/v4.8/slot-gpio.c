static irqreturn_t mmc_gpio_cd_irqt(int irq, void *dev_id)\r\n{\r\nstruct mmc_host *host = dev_id;\r\nhost->trigger_card_event = true;\r\nmmc_detect_change(host, msecs_to_jiffies(200));\r\nreturn IRQ_HANDLED;\r\n}\r\nint mmc_gpio_alloc(struct mmc_host *host)\r\n{\r\nsize_t len = strlen(dev_name(host->parent)) + 4;\r\nstruct mmc_gpio *ctx = devm_kzalloc(host->parent,\r\nsizeof(*ctx) + 2 * len, GFP_KERNEL);\r\nif (ctx) {\r\nctx->ro_label = ctx->cd_label + len;\r\nsnprintf(ctx->cd_label, len, "%s cd", dev_name(host->parent));\r\nsnprintf(ctx->ro_label, len, "%s ro", dev_name(host->parent));\r\nhost->slot.handler_priv = ctx;\r\nhost->slot.cd_irq = -EINVAL;\r\n}\r\nreturn ctx ? 0 : -ENOMEM;\r\n}\r\nint mmc_gpio_get_ro(struct mmc_host *host)\r\n{\r\nstruct mmc_gpio *ctx = host->slot.handler_priv;\r\nif (!ctx || !ctx->ro_gpio)\r\nreturn -ENOSYS;\r\nif (ctx->override_ro_active_level)\r\nreturn !gpiod_get_raw_value_cansleep(ctx->ro_gpio) ^\r\n!!(host->caps2 & MMC_CAP2_RO_ACTIVE_HIGH);\r\nreturn gpiod_get_value_cansleep(ctx->ro_gpio);\r\n}\r\nint mmc_gpio_get_cd(struct mmc_host *host)\r\n{\r\nstruct mmc_gpio *ctx = host->slot.handler_priv;\r\nif (!ctx || !ctx->cd_gpio)\r\nreturn -ENOSYS;\r\nif (ctx->override_cd_active_level)\r\nreturn !gpiod_get_raw_value_cansleep(ctx->cd_gpio) ^\r\n!!(host->caps2 & MMC_CAP2_CD_ACTIVE_HIGH);\r\nreturn gpiod_get_value_cansleep(ctx->cd_gpio);\r\n}\r\nint mmc_gpio_request_ro(struct mmc_host *host, unsigned int gpio)\r\n{\r\nstruct mmc_gpio *ctx = host->slot.handler_priv;\r\nint ret;\r\nif (!gpio_is_valid(gpio))\r\nreturn -EINVAL;\r\nret = devm_gpio_request_one(host->parent, gpio, GPIOF_DIR_IN,\r\nctx->ro_label);\r\nif (ret < 0)\r\nreturn ret;\r\nctx->override_ro_active_level = true;\r\nctx->ro_gpio = gpio_to_desc(gpio);\r\nreturn 0;\r\n}\r\nvoid mmc_gpiod_request_cd_irq(struct mmc_host *host)\r\n{\r\nstruct mmc_gpio *ctx = host->slot.handler_priv;\r\nint ret, irq;\r\nif (host->slot.cd_irq >= 0 || !ctx || !ctx->cd_gpio)\r\nreturn;\r\nirq = gpiod_to_irq(ctx->cd_gpio);\r\nif (irq >= 0 && host->caps & MMC_CAP_NEEDS_POLL)\r\nirq = -EINVAL;\r\nif (irq >= 0) {\r\nif (!ctx->cd_gpio_isr)\r\nctx->cd_gpio_isr = mmc_gpio_cd_irqt;\r\nret = devm_request_threaded_irq(host->parent, irq,\r\nNULL, ctx->cd_gpio_isr,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nctx->cd_label, host);\r\nif (ret < 0)\r\nirq = ret;\r\n}\r\nhost->slot.cd_irq = irq;\r\nif (irq < 0)\r\nhost->caps |= MMC_CAP_NEEDS_POLL;\r\n}\r\nvoid mmc_gpio_set_cd_isr(struct mmc_host *host,\r\nirqreturn_t (*isr)(int irq, void *dev_id))\r\n{\r\nstruct mmc_gpio *ctx = host->slot.handler_priv;\r\nWARN_ON(ctx->cd_gpio_isr);\r\nctx->cd_gpio_isr = isr;\r\n}\r\nint mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,\r\nunsigned int debounce)\r\n{\r\nstruct mmc_gpio *ctx = host->slot.handler_priv;\r\nint ret;\r\nret = devm_gpio_request_one(host->parent, gpio, GPIOF_DIR_IN,\r\nctx->cd_label);\r\nif (ret < 0)\r\nreturn ret;\r\nif (debounce) {\r\nret = gpio_set_debounce(gpio, debounce);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nctx->override_cd_active_level = true;\r\nctx->cd_gpio = gpio_to_desc(gpio);\r\nreturn 0;\r\n}\r\nint mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,\r\nunsigned int idx, bool override_active_level,\r\nunsigned int debounce, bool *gpio_invert)\r\n{\r\nstruct mmc_gpio *ctx = host->slot.handler_priv;\r\nstruct gpio_desc *desc;\r\nint ret;\r\nif (!con_id)\r\ncon_id = ctx->cd_label;\r\ndesc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\nif (debounce) {\r\nret = gpiod_set_debounce(desc, debounce);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (gpio_invert)\r\n*gpio_invert = !gpiod_is_active_low(desc);\r\nctx->override_cd_active_level = override_active_level;\r\nctx->cd_gpio = desc;\r\nreturn 0;\r\n}\r\nint mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,\r\nunsigned int idx, bool override_active_level,\r\nunsigned int debounce, bool *gpio_invert)\r\n{\r\nstruct mmc_gpio *ctx = host->slot.handler_priv;\r\nstruct gpio_desc *desc;\r\nint ret;\r\nif (!con_id)\r\ncon_id = ctx->ro_label;\r\ndesc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\nif (debounce) {\r\nret = gpiod_set_debounce(desc, debounce);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (gpio_invert)\r\n*gpio_invert = !gpiod_is_active_low(desc);\r\nctx->override_ro_active_level = override_active_level;\r\nctx->ro_gpio = desc;\r\nreturn 0;\r\n}
