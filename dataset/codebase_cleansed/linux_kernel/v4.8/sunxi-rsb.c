static int sunxi_rsb_device_match(struct device *dev, struct device_driver *drv)\r\n{\r\nreturn of_driver_match_device(dev, drv);\r\n}\r\nstatic int sunxi_rsb_device_probe(struct device *dev)\r\n{\r\nconst struct sunxi_rsb_driver *drv = to_sunxi_rsb_driver(dev->driver);\r\nstruct sunxi_rsb_device *rdev = to_sunxi_rsb_device(dev);\r\nint ret;\r\nif (!drv->probe)\r\nreturn -ENODEV;\r\nif (!rdev->irq) {\r\nint irq = -ENOENT;\r\nif (dev->of_node)\r\nirq = of_irq_get(dev->of_node, 0);\r\nif (irq == -EPROBE_DEFER)\r\nreturn irq;\r\nif (irq < 0)\r\nirq = 0;\r\nrdev->irq = irq;\r\n}\r\nret = of_clk_set_defaults(dev->of_node, false);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn drv->probe(rdev);\r\n}\r\nstatic int sunxi_rsb_device_remove(struct device *dev)\r\n{\r\nconst struct sunxi_rsb_driver *drv = to_sunxi_rsb_driver(dev->driver);\r\nreturn drv->remove(to_sunxi_rsb_device(dev));\r\n}\r\nstatic void sunxi_rsb_dev_release(struct device *dev)\r\n{\r\nstruct sunxi_rsb_device *rdev = to_sunxi_rsb_device(dev);\r\nkfree(rdev);\r\n}\r\nstatic struct sunxi_rsb_device *sunxi_rsb_device_create(struct sunxi_rsb *rsb,\r\nstruct device_node *node, u16 hwaddr, u8 rtaddr)\r\n{\r\nint err;\r\nstruct sunxi_rsb_device *rdev;\r\nrdev = kzalloc(sizeof(*rdev), GFP_KERNEL);\r\nif (!rdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nrdev->rsb = rsb;\r\nrdev->hwaddr = hwaddr;\r\nrdev->rtaddr = rtaddr;\r\nrdev->dev.bus = &sunxi_rsb_bus;\r\nrdev->dev.parent = rsb->dev;\r\nrdev->dev.of_node = node;\r\nrdev->dev.release = sunxi_rsb_dev_release;\r\ndev_set_name(&rdev->dev, "%s-%x", RSB_CTRL_NAME, hwaddr);\r\nerr = device_register(&rdev->dev);\r\nif (err < 0) {\r\ndev_err(&rdev->dev, "Can't add %s, status %d\n",\r\ndev_name(&rdev->dev), err);\r\ngoto err_device_add;\r\n}\r\ndev_dbg(&rdev->dev, "device %s registered\n", dev_name(&rdev->dev));\r\nerr_device_add:\r\nput_device(&rdev->dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void sunxi_rsb_device_unregister(struct sunxi_rsb_device *rdev)\r\n{\r\ndevice_unregister(&rdev->dev);\r\n}\r\nstatic int sunxi_rsb_remove_devices(struct device *dev, void *data)\r\n{\r\nstruct sunxi_rsb_device *rdev = to_sunxi_rsb_device(dev);\r\nif (dev->bus == &sunxi_rsb_bus)\r\nsunxi_rsb_device_unregister(rdev);\r\nreturn 0;\r\n}\r\nint sunxi_rsb_driver_register(struct sunxi_rsb_driver *rdrv)\r\n{\r\nrdrv->driver.bus = &sunxi_rsb_bus;\r\nreturn driver_register(&rdrv->driver);\r\n}\r\nstatic int _sunxi_rsb_run_xfer(struct sunxi_rsb *rsb)\r\n{\r\nif (readl(rsb->regs + RSB_CTRL) & RSB_CTRL_START_TRANS) {\r\ndev_dbg(rsb->dev, "RSB transfer still in progress\n");\r\nreturn -EBUSY;\r\n}\r\nreinit_completion(&rsb->complete);\r\nwritel(RSB_INTS_LOAD_BSY | RSB_INTS_TRANS_ERR | RSB_INTS_TRANS_OVER,\r\nrsb->regs + RSB_INTE);\r\nwritel(RSB_CTRL_START_TRANS | RSB_CTRL_GLOBAL_INT_ENB,\r\nrsb->regs + RSB_CTRL);\r\nif (!wait_for_completion_io_timeout(&rsb->complete,\r\nmsecs_to_jiffies(100))) {\r\ndev_dbg(rsb->dev, "RSB timeout\n");\r\nwritel(RSB_CTRL_ABORT_TRANS, rsb->regs + RSB_CTRL);\r\nwritel(readl(rsb->regs + RSB_INTS), rsb->regs + RSB_INTS);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (rsb->status & RSB_INTS_LOAD_BSY) {\r\ndev_dbg(rsb->dev, "RSB busy\n");\r\nreturn -EBUSY;\r\n}\r\nif (rsb->status & RSB_INTS_TRANS_ERR) {\r\nif (rsb->status & RSB_INTS_TRANS_ERR_ACK) {\r\ndev_dbg(rsb->dev, "RSB slave nack\n");\r\nreturn -EINVAL;\r\n}\r\nif (rsb->status & RSB_INTS_TRANS_ERR_DATA) {\r\ndev_dbg(rsb->dev, "RSB transfer data error\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sunxi_rsb_read(struct sunxi_rsb *rsb, u8 rtaddr, u8 addr,\r\nu32 *buf, size_t len)\r\n{\r\nu32 cmd;\r\nint ret;\r\nif (!buf)\r\nreturn -EINVAL;\r\nswitch (len) {\r\ncase 1:\r\ncmd = RSB_CMD_RD8;\r\nbreak;\r\ncase 2:\r\ncmd = RSB_CMD_RD16;\r\nbreak;\r\ncase 4:\r\ncmd = RSB_CMD_RD32;\r\nbreak;\r\ndefault:\r\ndev_err(rsb->dev, "Invalid access width: %zd\n", len);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&rsb->lock);\r\nwritel(addr, rsb->regs + RSB_ADDR);\r\nwritel(RSB_DAR_RTA(rtaddr), rsb->regs + RSB_DAR);\r\nwritel(cmd, rsb->regs + RSB_CMD);\r\nret = _sunxi_rsb_run_xfer(rsb);\r\nif (ret)\r\ngoto unlock;\r\n*buf = readl(rsb->regs + RSB_DATA);\r\nunlock:\r\nmutex_unlock(&rsb->lock);\r\nreturn ret;\r\n}\r\nstatic int sunxi_rsb_write(struct sunxi_rsb *rsb, u8 rtaddr, u8 addr,\r\nconst u32 *buf, size_t len)\r\n{\r\nu32 cmd;\r\nint ret;\r\nif (!buf)\r\nreturn -EINVAL;\r\nswitch (len) {\r\ncase 1:\r\ncmd = RSB_CMD_WR8;\r\nbreak;\r\ncase 2:\r\ncmd = RSB_CMD_WR16;\r\nbreak;\r\ncase 4:\r\ncmd = RSB_CMD_WR32;\r\nbreak;\r\ndefault:\r\ndev_err(rsb->dev, "Invalid access width: %zd\n", len);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&rsb->lock);\r\nwritel(addr, rsb->regs + RSB_ADDR);\r\nwritel(RSB_DAR_RTA(rtaddr), rsb->regs + RSB_DAR);\r\nwritel(*buf, rsb->regs + RSB_DATA);\r\nwritel(cmd, rsb->regs + RSB_CMD);\r\nret = _sunxi_rsb_run_xfer(rsb);\r\nmutex_unlock(&rsb->lock);\r\nreturn ret;\r\n}\r\nstatic int regmap_sunxi_rsb_reg_read(void *context, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nstruct sunxi_rsb_ctx *ctx = context;\r\nstruct sunxi_rsb_device *rdev = ctx->rdev;\r\nif (reg > 0xff)\r\nreturn -EINVAL;\r\nreturn sunxi_rsb_read(rdev->rsb, rdev->rtaddr, reg, val, ctx->size);\r\n}\r\nstatic int regmap_sunxi_rsb_reg_write(void *context, unsigned int reg,\r\nunsigned int val)\r\n{\r\nstruct sunxi_rsb_ctx *ctx = context;\r\nstruct sunxi_rsb_device *rdev = ctx->rdev;\r\nreturn sunxi_rsb_write(rdev->rsb, rdev->rtaddr, reg, &val, ctx->size);\r\n}\r\nstatic void regmap_sunxi_rsb_free_ctx(void *context)\r\n{\r\nstruct sunxi_rsb_ctx *ctx = context;\r\nkfree(ctx);\r\n}\r\nstatic struct sunxi_rsb_ctx *regmap_sunxi_rsb_init_ctx(struct sunxi_rsb_device *rdev,\r\nconst struct regmap_config *config)\r\n{\r\nstruct sunxi_rsb_ctx *ctx;\r\nswitch (config->val_bits) {\r\ncase 8:\r\ncase 16:\r\ncase 32:\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn ERR_PTR(-ENOMEM);\r\nctx->rdev = rdev;\r\nctx->size = config->val_bits / 8;\r\nreturn ctx;\r\n}\r\nstruct regmap *__devm_regmap_init_sunxi_rsb(struct sunxi_rsb_device *rdev,\r\nconst struct regmap_config *config,\r\nstruct lock_class_key *lock_key,\r\nconst char *lock_name)\r\n{\r\nstruct sunxi_rsb_ctx *ctx = regmap_sunxi_rsb_init_ctx(rdev, config);\r\nif (IS_ERR(ctx))\r\nreturn ERR_CAST(ctx);\r\nreturn __devm_regmap_init(&rdev->dev, &regmap_sunxi_rsb, ctx, config,\r\nlock_key, lock_name);\r\n}\r\nstatic irqreturn_t sunxi_rsb_irq(int irq, void *dev_id)\r\n{\r\nstruct sunxi_rsb *rsb = dev_id;\r\nu32 status;\r\nstatus = readl(rsb->regs + RSB_INTS);\r\nrsb->status = status;\r\nstatus &= (RSB_INTS_LOAD_BSY | RSB_INTS_TRANS_ERR |\r\nRSB_INTS_TRANS_OVER);\r\nwritel(status, rsb->regs + RSB_INTS);\r\ncomplete(&rsb->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sunxi_rsb_init_device_mode(struct sunxi_rsb *rsb)\r\n{\r\nint ret = 0;\r\nu32 reg;\r\nwritel(RSB_DMCR_DEVICE_START | RSB_DMCR_MODE_DATA |\r\nRSB_DMCR_MODE_REG | RSB_DMCR_DEV_ADDR, rsb->regs + RSB_DMCR);\r\nreadl_poll_timeout(rsb->regs + RSB_DMCR, reg,\r\n!(reg & RSB_DMCR_DEVICE_START), 100, 250000);\r\nif (reg & RSB_DMCR_DEVICE_START)\r\nret = -ETIMEDOUT;\r\nwritel(readl(rsb->regs + RSB_INTS), rsb->regs + RSB_INTS);\r\nreturn ret;\r\n}\r\nstatic u8 sunxi_rsb_get_rtaddr(u16 hwaddr)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(sunxi_rsb_addr_maps); i++)\r\nif (hwaddr == sunxi_rsb_addr_maps[i].hwaddr)\r\nreturn sunxi_rsb_addr_maps[i].rtaddr;\r\nreturn 0;\r\n}\r\nstatic int of_rsb_register_devices(struct sunxi_rsb *rsb)\r\n{\r\nstruct device *dev = rsb->dev;\r\nstruct device_node *child, *np = dev->of_node;\r\nu32 hwaddr;\r\nu8 rtaddr;\r\nint ret;\r\nif (!np)\r\nreturn -EINVAL;\r\nfor_each_available_child_of_node(np, child) {\r\ndev_dbg(dev, "setting child %s runtime address\n",\r\nchild->full_name);\r\nret = of_property_read_u32(child, "reg", &hwaddr);\r\nif (ret) {\r\ndev_err(dev, "%s: invalid 'reg' property: %d\n",\r\nchild->full_name, ret);\r\ncontinue;\r\n}\r\nrtaddr = sunxi_rsb_get_rtaddr(hwaddr);\r\nif (!rtaddr) {\r\ndev_err(dev, "%s: unknown hardware device address\n",\r\nchild->full_name);\r\ncontinue;\r\n}\r\nwritel(RSB_CMD_STRA, rsb->regs + RSB_CMD);\r\nwritel(RSB_DAR_RTA(rtaddr) | RSB_DAR_DA(hwaddr),\r\nrsb->regs + RSB_DAR);\r\nret = _sunxi_rsb_run_xfer(rsb);\r\nif (ret)\r\ndev_warn(dev, "%s: set runtime address failed: %d\n",\r\nchild->full_name, ret);\r\n}\r\nfor_each_available_child_of_node(np, child) {\r\nstruct sunxi_rsb_device *rdev;\r\ndev_dbg(dev, "adding child %s\n", child->full_name);\r\nret = of_property_read_u32(child, "reg", &hwaddr);\r\nif (ret)\r\ncontinue;\r\nrtaddr = sunxi_rsb_get_rtaddr(hwaddr);\r\nif (!rtaddr)\r\ncontinue;\r\nrdev = sunxi_rsb_device_create(rsb, child, hwaddr, rtaddr);\r\nif (IS_ERR(rdev))\r\ndev_err(dev, "failed to add child device %s: %ld\n",\r\nchild->full_name, PTR_ERR(rdev));\r\n}\r\nreturn 0;\r\n}\r\nstatic int sunxi_rsb_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct resource *r;\r\nstruct sunxi_rsb *rsb;\r\nunsigned long p_clk_freq;\r\nu32 clk_delay, clk_freq = 3000000;\r\nint clk_div, irq, ret;\r\nu32 reg;\r\nof_property_read_u32(np, "clock-frequency", &clk_freq);\r\nif (clk_freq > RSB_MAX_FREQ) {\r\ndev_err(dev,\r\n"clock-frequency (%u Hz) is too high (max = 20MHz)\n",\r\nclk_freq);\r\nreturn -EINVAL;\r\n}\r\nrsb = devm_kzalloc(dev, sizeof(*rsb), GFP_KERNEL);\r\nif (!rsb)\r\nreturn -ENOMEM;\r\nrsb->dev = dev;\r\nplatform_set_drvdata(pdev, rsb);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrsb->regs = devm_ioremap_resource(dev, r);\r\nif (IS_ERR(rsb->regs))\r\nreturn PTR_ERR(rsb->regs);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "failed to retrieve irq: %d\n", irq);\r\nreturn irq;\r\n}\r\nrsb->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(rsb->clk)) {\r\nret = PTR_ERR(rsb->clk);\r\ndev_err(dev, "failed to retrieve clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(rsb->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable clk: %d\n", ret);\r\nreturn ret;\r\n}\r\np_clk_freq = clk_get_rate(rsb->clk);\r\nrsb->rstc = devm_reset_control_get(dev, NULL);\r\nif (IS_ERR(rsb->rstc)) {\r\nret = PTR_ERR(rsb->rstc);\r\ndev_err(dev, "failed to retrieve reset controller: %d\n", ret);\r\ngoto err_clk_disable;\r\n}\r\nret = reset_control_deassert(rsb->rstc);\r\nif (ret) {\r\ndev_err(dev, "failed to deassert reset line: %d\n", ret);\r\ngoto err_clk_disable;\r\n}\r\ninit_completion(&rsb->complete);\r\nmutex_init(&rsb->lock);\r\nwritel(RSB_CTRL_SOFT_RST, rsb->regs + RSB_CTRL);\r\nreadl_poll_timeout(rsb->regs + RSB_CTRL, reg,\r\n!(reg & RSB_CTRL_SOFT_RST), 1000, 100000);\r\nclk_div = p_clk_freq / clk_freq / 2;\r\nif (!clk_div)\r\nclk_div = 1;\r\nelse if (clk_div > RSB_CCR_MAX_CLK_DIV + 1)\r\nclk_div = RSB_CCR_MAX_CLK_DIV + 1;\r\nclk_delay = clk_div >> 1;\r\nif (!clk_delay)\r\nclk_delay = 1;\r\ndev_info(dev, "RSB running at %lu Hz\n", p_clk_freq / clk_div / 2);\r\nwritel(RSB_CCR_SDA_OUT_DELAY(clk_delay) | RSB_CCR_CLK_DIV(clk_div - 1),\r\nrsb->regs + RSB_CCR);\r\nret = devm_request_irq(dev, irq, sunxi_rsb_irq, 0, RSB_CTRL_NAME, rsb);\r\nif (ret) {\r\ndev_err(dev, "can't register interrupt handler irq %d: %d\n",\r\nirq, ret);\r\ngoto err_reset_assert;\r\n}\r\nret = sunxi_rsb_init_device_mode(rsb);\r\nif (ret)\r\ndev_warn(dev, "Initialize device mode failed: %d\n", ret);\r\nof_rsb_register_devices(rsb);\r\nreturn 0;\r\nerr_reset_assert:\r\nreset_control_assert(rsb->rstc);\r\nerr_clk_disable:\r\nclk_disable_unprepare(rsb->clk);\r\nreturn ret;\r\n}\r\nstatic int sunxi_rsb_remove(struct platform_device *pdev)\r\n{\r\nstruct sunxi_rsb *rsb = platform_get_drvdata(pdev);\r\ndevice_for_each_child(rsb->dev, NULL, sunxi_rsb_remove_devices);\r\nreset_control_assert(rsb->rstc);\r\nclk_disable_unprepare(rsb->clk);\r\nreturn 0;\r\n}\r\nstatic int __init sunxi_rsb_init(void)\r\n{\r\nint ret;\r\nret = bus_register(&sunxi_rsb_bus);\r\nif (ret) {\r\npr_err("failed to register sunxi sunxi_rsb bus: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn platform_driver_register(&sunxi_rsb_driver);\r\n}\r\nstatic void __exit sunxi_rsb_exit(void)\r\n{\r\nplatform_driver_unregister(&sunxi_rsb_driver);\r\nbus_unregister(&sunxi_rsb_bus);\r\n}
