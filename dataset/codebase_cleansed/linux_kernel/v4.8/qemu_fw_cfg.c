static inline u16 fw_cfg_sel_endianness(u16 key)\r\n{\r\nreturn fw_cfg_is_mmio ? cpu_to_be16(key) : cpu_to_le16(key);\r\n}\r\nstatic inline void fw_cfg_read_blob(u16 key,\r\nvoid *buf, loff_t pos, size_t count)\r\n{\r\nu32 glk = -1U;\r\nacpi_status status;\r\nstatus = acpi_acquire_global_lock(ACPI_WAIT_FOREVER, &glk);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_CONFIGURED) {\r\nWARN(1, "fw_cfg_read_blob: Failed to lock ACPI!\n");\r\nmemset(buf, 0, count);\r\nreturn;\r\n}\r\nmutex_lock(&fw_cfg_dev_lock);\r\niowrite16(fw_cfg_sel_endianness(key), fw_cfg_reg_ctrl);\r\nwhile (pos-- > 0)\r\nioread8(fw_cfg_reg_data);\r\nioread8_rep(fw_cfg_reg_data, buf, count);\r\nmutex_unlock(&fw_cfg_dev_lock);\r\nacpi_release_global_lock(glk);\r\n}\r\nstatic void fw_cfg_io_cleanup(void)\r\n{\r\nif (fw_cfg_is_mmio) {\r\niounmap(fw_cfg_dev_base);\r\nrelease_mem_region(fw_cfg_p_base, fw_cfg_p_size);\r\n} else {\r\nioport_unmap(fw_cfg_dev_base);\r\nrelease_region(fw_cfg_p_base, fw_cfg_p_size);\r\n}\r\n}\r\nstatic int fw_cfg_do_platform_probe(struct platform_device *pdev)\r\n{\r\nchar sig[FW_CFG_SIG_SIZE];\r\nstruct resource *range, *ctrl, *data;\r\nfw_cfg_is_mmio = false;\r\nrange = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!range) {\r\nfw_cfg_is_mmio = true;\r\nrange = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!range)\r\nreturn -EINVAL;\r\n}\r\nfw_cfg_p_base = range->start;\r\nfw_cfg_p_size = resource_size(range);\r\nif (fw_cfg_is_mmio) {\r\nif (!request_mem_region(fw_cfg_p_base,\r\nfw_cfg_p_size, "fw_cfg_mem"))\r\nreturn -EBUSY;\r\nfw_cfg_dev_base = ioremap(fw_cfg_p_base, fw_cfg_p_size);\r\nif (!fw_cfg_dev_base) {\r\nrelease_mem_region(fw_cfg_p_base, fw_cfg_p_size);\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nif (!request_region(fw_cfg_p_base,\r\nfw_cfg_p_size, "fw_cfg_io"))\r\nreturn -EBUSY;\r\nfw_cfg_dev_base = ioport_map(fw_cfg_p_base, fw_cfg_p_size);\r\nif (!fw_cfg_dev_base) {\r\nrelease_region(fw_cfg_p_base, fw_cfg_p_size);\r\nreturn -EFAULT;\r\n}\r\n}\r\nctrl = platform_get_resource_byname(pdev, IORESOURCE_REG, "ctrl");\r\ndata = platform_get_resource_byname(pdev, IORESOURCE_REG, "data");\r\nif (ctrl && data) {\r\nfw_cfg_reg_ctrl = fw_cfg_dev_base + ctrl->start;\r\nfw_cfg_reg_data = fw_cfg_dev_base + data->start;\r\n} else {\r\nfw_cfg_reg_ctrl = fw_cfg_dev_base + FW_CFG_CTRL_OFF;\r\nfw_cfg_reg_data = fw_cfg_dev_base + FW_CFG_DATA_OFF;\r\n}\r\nfw_cfg_read_blob(FW_CFG_SIGNATURE, sig, 0, FW_CFG_SIG_SIZE);\r\nif (memcmp(sig, "QEMU", FW_CFG_SIG_SIZE) != 0) {\r\nfw_cfg_io_cleanup();\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t fw_cfg_showrev(struct kobject *k, struct attribute *a, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", fw_cfg_rev);\r\n}\r\nstatic inline struct fw_cfg_sysfs_entry *to_entry(struct kobject *kobj)\r\n{\r\nreturn container_of(kobj, struct fw_cfg_sysfs_entry, kobj);\r\n}\r\nstatic inline struct fw_cfg_sysfs_attribute *to_attr(struct attribute *attr)\r\n{\r\nreturn container_of(attr, struct fw_cfg_sysfs_attribute, attr);\r\n}\r\nstatic inline void fw_cfg_sysfs_cache_enlist(struct fw_cfg_sysfs_entry *entry)\r\n{\r\nspin_lock(&fw_cfg_cache_lock);\r\nlist_add_tail(&entry->list, &fw_cfg_entry_cache);\r\nspin_unlock(&fw_cfg_cache_lock);\r\n}\r\nstatic inline void fw_cfg_sysfs_cache_delist(struct fw_cfg_sysfs_entry *entry)\r\n{\r\nspin_lock(&fw_cfg_cache_lock);\r\nlist_del(&entry->list);\r\nspin_unlock(&fw_cfg_cache_lock);\r\n}\r\nstatic void fw_cfg_sysfs_cache_cleanup(void)\r\n{\r\nstruct fw_cfg_sysfs_entry *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &fw_cfg_entry_cache, list) {\r\nkobject_put(&entry->kobj);\r\n}\r\n}\r\nstatic ssize_t fw_cfg_sysfs_show_size(struct fw_cfg_sysfs_entry *e, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", e->f.size);\r\n}\r\nstatic ssize_t fw_cfg_sysfs_show_key(struct fw_cfg_sysfs_entry *e, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", e->f.select);\r\n}\r\nstatic ssize_t fw_cfg_sysfs_show_name(struct fw_cfg_sysfs_entry *e, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", e->f.name);\r\n}\r\nstatic ssize_t fw_cfg_sysfs_attr_show(struct kobject *kobj, struct attribute *a,\r\nchar *buf)\r\n{\r\nstruct fw_cfg_sysfs_entry *entry = to_entry(kobj);\r\nstruct fw_cfg_sysfs_attribute *attr = to_attr(a);\r\nreturn attr->show(entry, buf);\r\n}\r\nstatic void fw_cfg_sysfs_release_entry(struct kobject *kobj)\r\n{\r\nstruct fw_cfg_sysfs_entry *entry = to_entry(kobj);\r\nfw_cfg_sysfs_cache_delist(entry);\r\nkfree(entry);\r\n}\r\nstatic ssize_t fw_cfg_sysfs_read_raw(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nstruct fw_cfg_sysfs_entry *entry = to_entry(kobj);\r\nif (pos > entry->f.size)\r\nreturn -EINVAL;\r\nif (count > entry->f.size - pos)\r\ncount = entry->f.size - pos;\r\nfw_cfg_read_blob(entry->f.select, buf, pos, count);\r\nreturn count;\r\n}\r\nstatic int fw_cfg_build_symlink(struct kset *dir,\r\nstruct kobject *target, const char *name)\r\n{\r\nint ret;\r\nstruct kset *subdir;\r\nstruct kobject *ko;\r\nchar *name_copy, *p, *tok;\r\nif (!dir || !target || !name || !*name)\r\nreturn -EINVAL;\r\nname_copy = p = kstrdup(name, GFP_KERNEL);\r\nif (!name_copy)\r\nreturn -ENOMEM;\r\nwhile ((tok = strsep(&p, "/")) && *tok) {\r\nif (!p || !*p) {\r\nret = sysfs_create_link(&dir->kobj, target, tok);\r\nbreak;\r\n}\r\nko = kset_find_obj(dir, tok);\r\nif (ko) {\r\nkobject_put(ko);\r\nif (ko->ktype != dir->kobj.ktype) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndir = to_kset(ko);\r\n} else {\r\nsubdir = kzalloc(sizeof(struct kset), GFP_KERNEL);\r\nif (!subdir) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nsubdir->kobj.kset = dir;\r\nsubdir->kobj.ktype = dir->kobj.ktype;\r\nret = kobject_set_name(&subdir->kobj, "%s", tok);\r\nif (ret) {\r\nkfree(subdir);\r\nbreak;\r\n}\r\nret = kset_register(subdir);\r\nif (ret) {\r\nkfree(subdir);\r\nbreak;\r\n}\r\ndir = subdir;\r\n}\r\n}\r\nkfree(name_copy);\r\nreturn ret;\r\n}\r\nstatic void fw_cfg_kset_unregister_recursive(struct kset *kset)\r\n{\r\nstruct kobject *k, *next;\r\nlist_for_each_entry_safe(k, next, &kset->list, entry)\r\nif (k->ktype == kset->kobj.ktype)\r\nfw_cfg_kset_unregister_recursive(to_kset(k));\r\nkset_unregister(kset);\r\n}\r\nstatic int fw_cfg_register_file(const struct fw_cfg_file *f)\r\n{\r\nint err;\r\nstruct fw_cfg_sysfs_entry *entry;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nmemcpy(&entry->f, f, sizeof(struct fw_cfg_file));\r\nerr = kobject_init_and_add(&entry->kobj, &fw_cfg_sysfs_entry_ktype,\r\nfw_cfg_sel_ko, "%d", entry->f.select);\r\nif (err)\r\ngoto err_register;\r\nerr = sysfs_create_bin_file(&entry->kobj, &fw_cfg_sysfs_attr_raw);\r\nif (err)\r\ngoto err_add_raw;\r\nfw_cfg_build_symlink(fw_cfg_fname_kset, &entry->kobj, entry->f.name);\r\nfw_cfg_sysfs_cache_enlist(entry);\r\nreturn 0;\r\nerr_add_raw:\r\nkobject_del(&entry->kobj);\r\nerr_register:\r\nkfree(entry);\r\nreturn err;\r\n}\r\nstatic int fw_cfg_register_dir_entries(void)\r\n{\r\nint ret = 0;\r\nu32 count, i;\r\nstruct fw_cfg_file *dir;\r\nsize_t dir_size;\r\nfw_cfg_read_blob(FW_CFG_FILE_DIR, &count, 0, sizeof(count));\r\ncount = be32_to_cpu(count);\r\ndir_size = count * sizeof(struct fw_cfg_file);\r\ndir = kmalloc(dir_size, GFP_KERNEL);\r\nif (!dir)\r\nreturn -ENOMEM;\r\nfw_cfg_read_blob(FW_CFG_FILE_DIR, dir, sizeof(count), dir_size);\r\nfor (i = 0; i < count; i++) {\r\ndir[i].size = be32_to_cpu(dir[i].size);\r\ndir[i].select = be16_to_cpu(dir[i].select);\r\nret = fw_cfg_register_file(&dir[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nkfree(dir);\r\nreturn ret;\r\n}\r\nstatic inline void fw_cfg_kobj_cleanup(struct kobject *kobj)\r\n{\r\nkobject_del(kobj);\r\nkobject_put(kobj);\r\n}\r\nstatic int fw_cfg_sysfs_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nif (fw_cfg_sel_ko)\r\nreturn -EBUSY;\r\nerr = -ENOMEM;\r\nfw_cfg_sel_ko = kobject_create_and_add("by_key", fw_cfg_top_ko);\r\nif (!fw_cfg_sel_ko)\r\ngoto err_sel;\r\nfw_cfg_fname_kset = kset_create_and_add("by_name", NULL, fw_cfg_top_ko);\r\nif (!fw_cfg_fname_kset)\r\ngoto err_name;\r\nerr = fw_cfg_do_platform_probe(pdev);\r\nif (err)\r\ngoto err_probe;\r\nfw_cfg_read_blob(FW_CFG_ID, &fw_cfg_rev, 0, sizeof(fw_cfg_rev));\r\nfw_cfg_rev = le32_to_cpu(fw_cfg_rev);\r\nerr = sysfs_create_file(fw_cfg_top_ko, &fw_cfg_rev_attr.attr);\r\nif (err)\r\ngoto err_rev;\r\nerr = fw_cfg_register_dir_entries();\r\nif (err)\r\ngoto err_dir;\r\npr_debug("fw_cfg: loaded.\n");\r\nreturn 0;\r\nerr_dir:\r\nfw_cfg_sysfs_cache_cleanup();\r\nsysfs_remove_file(fw_cfg_top_ko, &fw_cfg_rev_attr.attr);\r\nerr_rev:\r\nfw_cfg_io_cleanup();\r\nerr_probe:\r\nfw_cfg_kset_unregister_recursive(fw_cfg_fname_kset);\r\nerr_name:\r\nfw_cfg_kobj_cleanup(fw_cfg_sel_ko);\r\nerr_sel:\r\nreturn err;\r\n}\r\nstatic int fw_cfg_sysfs_remove(struct platform_device *pdev)\r\n{\r\npr_debug("fw_cfg: unloading.\n");\r\nfw_cfg_sysfs_cache_cleanup();\r\nfw_cfg_kset_unregister_recursive(fw_cfg_fname_kset);\r\nfw_cfg_kobj_cleanup(fw_cfg_sel_ko);\r\nfw_cfg_io_cleanup();\r\nreturn 0;\r\n}\r\nstatic int fw_cfg_cmdline_set(const char *arg, const struct kernel_param *kp)\r\n{\r\nstruct resource res[3] = {};\r\nchar *str;\r\nphys_addr_t base;\r\nresource_size_t size, ctrl_off, data_off;\r\nint processed, consumed = 0;\r\nif (fw_cfg_cmdline_dev) {\r\nplatform_device_unregister(fw_cfg_cmdline_dev);\r\nreturn -EINVAL;\r\n}\r\nsize = memparse(arg, &str);\r\nprocessed = sscanf(str, PH_ADDR_SCAN_FMT,\r\n&base, &consumed,\r\n&ctrl_off, &data_off, &consumed);\r\nif (str[consumed] ||\r\n(processed != 1 && processed != 3))\r\nreturn -EINVAL;\r\nres[0].start = base;\r\nres[0].end = base + size - 1;\r\nres[0].flags = !strcmp(kp->name, "mmio") ? IORESOURCE_MEM :\r\nIORESOURCE_IO;\r\nif (processed > 1) {\r\nres[1].name = "ctrl";\r\nres[1].start = ctrl_off;\r\nres[1].flags = IORESOURCE_REG;\r\nres[2].name = "data";\r\nres[2].start = data_off;\r\nres[2].flags = IORESOURCE_REG;\r\n}\r\nfw_cfg_cmdline_dev = platform_device_register_simple("fw_cfg",\r\nPLATFORM_DEVID_NONE, res, processed);\r\nif (IS_ERR(fw_cfg_cmdline_dev))\r\nreturn PTR_ERR(fw_cfg_cmdline_dev);\r\nreturn 0;\r\n}\r\nstatic int fw_cfg_cmdline_get(char *buf, const struct kernel_param *kp)\r\n{\r\nif (!fw_cfg_cmdline_dev ||\r\n(!strcmp(kp->name, "mmio") ^\r\n(fw_cfg_cmdline_dev->resource[0].flags == IORESOURCE_MEM)))\r\nreturn 0;\r\nswitch (fw_cfg_cmdline_dev->num_resources) {\r\ncase 1:\r\nreturn snprintf(buf, PAGE_SIZE, PH_ADDR_PR_1_FMT,\r\nresource_size(&fw_cfg_cmdline_dev->resource[0]),\r\nfw_cfg_cmdline_dev->resource[0].start);\r\ncase 3:\r\nreturn snprintf(buf, PAGE_SIZE, PH_ADDR_PR_3_FMT,\r\nresource_size(&fw_cfg_cmdline_dev->resource[0]),\r\nfw_cfg_cmdline_dev->resource[0].start,\r\nfw_cfg_cmdline_dev->resource[1].start,\r\nfw_cfg_cmdline_dev->resource[2].start);\r\n}\r\nWARN(1, "Unexpected number of resources: %d\n",\r\nfw_cfg_cmdline_dev->num_resources);\r\nreturn 0;\r\n}\r\nstatic int __init fw_cfg_sysfs_init(void)\r\n{\r\nint ret;\r\nfw_cfg_top_ko = kobject_create_and_add("qemu_fw_cfg", firmware_kobj);\r\nif (!fw_cfg_top_ko)\r\nreturn -ENOMEM;\r\nret = platform_driver_register(&fw_cfg_sysfs_driver);\r\nif (ret)\r\nfw_cfg_kobj_cleanup(fw_cfg_top_ko);\r\nreturn ret;\r\n}\r\nstatic void __exit fw_cfg_sysfs_exit(void)\r\n{\r\nplatform_driver_unregister(&fw_cfg_sysfs_driver);\r\n#ifdef CONFIG_FW_CFG_SYSFS_CMDLINE\r\nplatform_device_unregister(fw_cfg_cmdline_dev);\r\n#endif\r\nfw_cfg_kobj_cleanup(fw_cfg_top_ko);\r\n}
