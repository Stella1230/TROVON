static uint16_t combios_get_table_offset(struct drm_device *dev,\r\nenum radeon_combios_table_offset table)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint rev, size;\r\nuint16_t offset = 0, check_offset;\r\nif (!rdev->bios)\r\nreturn 0;\r\nswitch (table) {\r\ncase COMBIOS_ASIC_INIT_1_TABLE:\r\ncheck_offset = 0xc;\r\nbreak;\r\ncase COMBIOS_BIOS_SUPPORT_TABLE:\r\ncheck_offset = 0x14;\r\nbreak;\r\ncase COMBIOS_DAC_PROGRAMMING_TABLE:\r\ncheck_offset = 0x2a;\r\nbreak;\r\ncase COMBIOS_MAX_COLOR_DEPTH_TABLE:\r\ncheck_offset = 0x2c;\r\nbreak;\r\ncase COMBIOS_CRTC_INFO_TABLE:\r\ncheck_offset = 0x2e;\r\nbreak;\r\ncase COMBIOS_PLL_INFO_TABLE:\r\ncheck_offset = 0x30;\r\nbreak;\r\ncase COMBIOS_TV_INFO_TABLE:\r\ncheck_offset = 0x32;\r\nbreak;\r\ncase COMBIOS_DFP_INFO_TABLE:\r\ncheck_offset = 0x34;\r\nbreak;\r\ncase COMBIOS_HW_CONFIG_INFO_TABLE:\r\ncheck_offset = 0x36;\r\nbreak;\r\ncase COMBIOS_MULTIMEDIA_INFO_TABLE:\r\ncheck_offset = 0x38;\r\nbreak;\r\ncase COMBIOS_TV_STD_PATCH_TABLE:\r\ncheck_offset = 0x3e;\r\nbreak;\r\ncase COMBIOS_LCD_INFO_TABLE:\r\ncheck_offset = 0x40;\r\nbreak;\r\ncase COMBIOS_MOBILE_INFO_TABLE:\r\ncheck_offset = 0x42;\r\nbreak;\r\ncase COMBIOS_PLL_INIT_TABLE:\r\ncheck_offset = 0x46;\r\nbreak;\r\ncase COMBIOS_MEM_CONFIG_TABLE:\r\ncheck_offset = 0x48;\r\nbreak;\r\ncase COMBIOS_SAVE_MASK_TABLE:\r\ncheck_offset = 0x4a;\r\nbreak;\r\ncase COMBIOS_HARDCODED_EDID_TABLE:\r\ncheck_offset = 0x4c;\r\nbreak;\r\ncase COMBIOS_ASIC_INIT_2_TABLE:\r\ncheck_offset = 0x4e;\r\nbreak;\r\ncase COMBIOS_CONNECTOR_INFO_TABLE:\r\ncheck_offset = 0x50;\r\nbreak;\r\ncase COMBIOS_DYN_CLK_1_TABLE:\r\ncheck_offset = 0x52;\r\nbreak;\r\ncase COMBIOS_RESERVED_MEM_TABLE:\r\ncheck_offset = 0x54;\r\nbreak;\r\ncase COMBIOS_EXT_TMDS_INFO_TABLE:\r\ncheck_offset = 0x58;\r\nbreak;\r\ncase COMBIOS_MEM_CLK_INFO_TABLE:\r\ncheck_offset = 0x5a;\r\nbreak;\r\ncase COMBIOS_EXT_DAC_INFO_TABLE:\r\ncheck_offset = 0x5c;\r\nbreak;\r\ncase COMBIOS_MISC_INFO_TABLE:\r\ncheck_offset = 0x5e;\r\nbreak;\r\ncase COMBIOS_CRT_INFO_TABLE:\r\ncheck_offset = 0x60;\r\nbreak;\r\ncase COMBIOS_INTEGRATED_SYSTEM_INFO_TABLE:\r\ncheck_offset = 0x62;\r\nbreak;\r\ncase COMBIOS_COMPONENT_VIDEO_INFO_TABLE:\r\ncheck_offset = 0x64;\r\nbreak;\r\ncase COMBIOS_FAN_SPEED_INFO_TABLE:\r\ncheck_offset = 0x66;\r\nbreak;\r\ncase COMBIOS_OVERDRIVE_INFO_TABLE:\r\ncheck_offset = 0x68;\r\nbreak;\r\ncase COMBIOS_OEM_INFO_TABLE:\r\ncheck_offset = 0x6a;\r\nbreak;\r\ncase COMBIOS_DYN_CLK_2_TABLE:\r\ncheck_offset = 0x6c;\r\nbreak;\r\ncase COMBIOS_POWER_CONNECTOR_INFO_TABLE:\r\ncheck_offset = 0x6e;\r\nbreak;\r\ncase COMBIOS_I2C_INFO_TABLE:\r\ncheck_offset = 0x70;\r\nbreak;\r\ncase COMBIOS_ASIC_INIT_3_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_MISC_INFO_TABLE);\r\nif (check_offset) {\r\nrev = RBIOS8(check_offset);\r\nif (rev > 0) {\r\ncheck_offset = RBIOS16(check_offset + 0x3);\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\n}\r\nbreak;\r\ncase COMBIOS_ASIC_INIT_4_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_MISC_INFO_TABLE);\r\nif (check_offset) {\r\nrev = RBIOS8(check_offset);\r\nif (rev > 0) {\r\ncheck_offset = RBIOS16(check_offset + 0x5);\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\n}\r\nbreak;\r\ncase COMBIOS_DETECTED_MEM_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_MISC_INFO_TABLE);\r\nif (check_offset) {\r\nrev = RBIOS8(check_offset);\r\nif (rev > 0) {\r\ncheck_offset = RBIOS16(check_offset + 0x7);\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\n}\r\nbreak;\r\ncase COMBIOS_ASIC_INIT_5_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_MISC_INFO_TABLE);\r\nif (check_offset) {\r\nrev = RBIOS8(check_offset);\r\nif (rev == 2) {\r\ncheck_offset = RBIOS16(check_offset + 0x9);\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\n}\r\nbreak;\r\ncase COMBIOS_RAM_RESET_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_MEM_CONFIG_TABLE);\r\nif (check_offset) {\r\nwhile (RBIOS8(check_offset++));\r\ncheck_offset += 2;\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\nbreak;\r\ncase COMBIOS_POWERPLAY_INFO_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_MOBILE_INFO_TABLE);\r\nif (check_offset) {\r\ncheck_offset = RBIOS16(check_offset + 0x11);\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\nbreak;\r\ncase COMBIOS_GPIO_INFO_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_MOBILE_INFO_TABLE);\r\nif (check_offset) {\r\ncheck_offset = RBIOS16(check_offset + 0x13);\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\nbreak;\r\ncase COMBIOS_LCD_DDC_INFO_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_MOBILE_INFO_TABLE);\r\nif (check_offset) {\r\ncheck_offset = RBIOS16(check_offset + 0x15);\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\nbreak;\r\ncase COMBIOS_TMDS_POWER_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_MOBILE_INFO_TABLE);\r\nif (check_offset) {\r\ncheck_offset = RBIOS16(check_offset + 0x17);\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\nbreak;\r\ncase COMBIOS_TMDS_POWER_ON_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_TMDS_POWER_TABLE);\r\nif (check_offset) {\r\ncheck_offset = RBIOS16(check_offset + 0x2);\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\nbreak;\r\ncase COMBIOS_TMDS_POWER_OFF_TABLE:\r\ncheck_offset =\r\ncombios_get_table_offset(dev, COMBIOS_TMDS_POWER_TABLE);\r\nif (check_offset) {\r\ncheck_offset = RBIOS16(check_offset + 0x4);\r\nif (check_offset)\r\noffset = check_offset;\r\n}\r\nbreak;\r\ndefault:\r\ncheck_offset = 0;\r\nbreak;\r\n}\r\nsize = RBIOS8(rdev->bios_header_start + 0x6);\r\nif (table < COMBIOS_ASIC_INIT_3_TABLE && check_offset && check_offset < size)\r\noffset = RBIOS16(rdev->bios_header_start + check_offset);\r\nreturn offset;\r\n}\r\nbool radeon_combios_check_hardcoded_edid(struct radeon_device *rdev)\r\n{\r\nint edid_info, size;\r\nstruct edid *edid;\r\nunsigned char *raw;\r\nedid_info = combios_get_table_offset(rdev->ddev, COMBIOS_HARDCODED_EDID_TABLE);\r\nif (!edid_info)\r\nreturn false;\r\nraw = rdev->bios + edid_info;\r\nsize = EDID_LENGTH * (raw[0x7e] + 1);\r\nedid = kmalloc(size, GFP_KERNEL);\r\nif (edid == NULL)\r\nreturn false;\r\nmemcpy((unsigned char *)edid, raw, size);\r\nif (!drm_edid_is_valid(edid)) {\r\nkfree(edid);\r\nreturn false;\r\n}\r\nrdev->mode_info.bios_hardcoded_edid = edid;\r\nrdev->mode_info.bios_hardcoded_edid_size = size;\r\nreturn true;\r\n}\r\nstruct edid *\r\nradeon_bios_get_hardcoded_edid(struct radeon_device *rdev)\r\n{\r\nstruct edid *edid;\r\nif (rdev->mode_info.bios_hardcoded_edid) {\r\nedid = kmalloc(rdev->mode_info.bios_hardcoded_edid_size, GFP_KERNEL);\r\nif (edid) {\r\nmemcpy((unsigned char *)edid,\r\n(unsigned char *)rdev->mode_info.bios_hardcoded_edid,\r\nrdev->mode_info.bios_hardcoded_edid_size);\r\nreturn edid;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct radeon_i2c_bus_rec combios_setup_i2c_bus(struct radeon_device *rdev,\r\nenum radeon_combios_ddc ddc,\r\nu32 clk_mask,\r\nu32 data_mask)\r\n{\r\nstruct radeon_i2c_bus_rec i2c;\r\nint ddc_line = 0;\r\nswitch (ddc) {\r\ncase DDC_NONE_DETECTED:\r\ndefault:\r\nddc_line = 0;\r\nbreak;\r\ncase DDC_DVI:\r\nddc_line = RADEON_GPIO_DVI_DDC;\r\nbreak;\r\ncase DDC_VGA:\r\nddc_line = RADEON_GPIO_VGA_DDC;\r\nbreak;\r\ncase DDC_LCD:\r\nddc_line = RADEON_GPIOPAD_MASK;\r\nbreak;\r\ncase DDC_GPIO:\r\nddc_line = RADEON_MDGPIO_MASK;\r\nbreak;\r\ncase DDC_MONID:\r\nif (rdev->family == CHIP_RS300 ||\r\nrdev->family == CHIP_RS400 ||\r\nrdev->family == CHIP_RS480)\r\nddc_line = RADEON_GPIOPAD_MASK;\r\nelse if (rdev->family == CHIP_R300 ||\r\nrdev->family == CHIP_R350) {\r\nddc_line = RADEON_GPIO_DVI_DDC;\r\nddc = DDC_DVI;\r\n} else\r\nddc_line = RADEON_GPIO_MONID;\r\nbreak;\r\ncase DDC_CRT2:\r\nif (rdev->family == CHIP_R200 ||\r\nrdev->family == CHIP_R300 ||\r\nrdev->family == CHIP_R350) {\r\nddc_line = RADEON_GPIO_DVI_DDC;\r\nddc = DDC_DVI;\r\n} else if (rdev->family == CHIP_RS300 ||\r\nrdev->family == CHIP_RS400 ||\r\nrdev->family == CHIP_RS480)\r\nddc_line = RADEON_GPIO_MONID;\r\nelse if (rdev->family >= CHIP_RV350) {\r\nddc_line = RADEON_GPIO_MONID;\r\nddc = DDC_MONID;\r\n} else\r\nddc_line = RADEON_GPIO_CRT2_DDC;\r\nbreak;\r\n}\r\nif (ddc_line == RADEON_GPIOPAD_MASK) {\r\ni2c.mask_clk_reg = RADEON_GPIOPAD_MASK;\r\ni2c.mask_data_reg = RADEON_GPIOPAD_MASK;\r\ni2c.a_clk_reg = RADEON_GPIOPAD_A;\r\ni2c.a_data_reg = RADEON_GPIOPAD_A;\r\ni2c.en_clk_reg = RADEON_GPIOPAD_EN;\r\ni2c.en_data_reg = RADEON_GPIOPAD_EN;\r\ni2c.y_clk_reg = RADEON_GPIOPAD_Y;\r\ni2c.y_data_reg = RADEON_GPIOPAD_Y;\r\n} else if (ddc_line == RADEON_MDGPIO_MASK) {\r\ni2c.mask_clk_reg = RADEON_MDGPIO_MASK;\r\ni2c.mask_data_reg = RADEON_MDGPIO_MASK;\r\ni2c.a_clk_reg = RADEON_MDGPIO_A;\r\ni2c.a_data_reg = RADEON_MDGPIO_A;\r\ni2c.en_clk_reg = RADEON_MDGPIO_EN;\r\ni2c.en_data_reg = RADEON_MDGPIO_EN;\r\ni2c.y_clk_reg = RADEON_MDGPIO_Y;\r\ni2c.y_data_reg = RADEON_MDGPIO_Y;\r\n} else {\r\ni2c.mask_clk_reg = ddc_line;\r\ni2c.mask_data_reg = ddc_line;\r\ni2c.a_clk_reg = ddc_line;\r\ni2c.a_data_reg = ddc_line;\r\ni2c.en_clk_reg = ddc_line;\r\ni2c.en_data_reg = ddc_line;\r\ni2c.y_clk_reg = ddc_line;\r\ni2c.y_data_reg = ddc_line;\r\n}\r\nif (clk_mask && data_mask) {\r\ni2c.mask_clk_mask = clk_mask;\r\ni2c.mask_data_mask = data_mask;\r\ni2c.a_clk_mask = clk_mask;\r\ni2c.a_data_mask = data_mask;\r\ni2c.en_clk_mask = clk_mask;\r\ni2c.en_data_mask = data_mask;\r\ni2c.y_clk_mask = clk_mask;\r\ni2c.y_data_mask = data_mask;\r\n} else if ((ddc_line == RADEON_GPIOPAD_MASK) ||\r\n(ddc_line == RADEON_MDGPIO_MASK)) {\r\ni2c.mask_clk_mask = (0x20 << 8);\r\ni2c.mask_data_mask = 0x80;\r\ni2c.a_clk_mask = (0x20 << 8);\r\ni2c.a_data_mask = 0x80;\r\ni2c.en_clk_mask = (0x20 << 8);\r\ni2c.en_data_mask = 0x80;\r\ni2c.y_clk_mask = (0x20 << 8);\r\ni2c.y_data_mask = 0x80;\r\n} else {\r\ni2c.mask_clk_mask = RADEON_GPIO_MASK_1;\r\ni2c.mask_data_mask = RADEON_GPIO_MASK_0;\r\ni2c.a_clk_mask = RADEON_GPIO_A_1;\r\ni2c.a_data_mask = RADEON_GPIO_A_0;\r\ni2c.en_clk_mask = RADEON_GPIO_EN_1;\r\ni2c.en_data_mask = RADEON_GPIO_EN_0;\r\ni2c.y_clk_mask = RADEON_GPIO_Y_1;\r\ni2c.y_data_mask = RADEON_GPIO_Y_0;\r\n}\r\nswitch (rdev->family) {\r\ncase CHIP_R100:\r\ncase CHIP_RV100:\r\ncase CHIP_RS100:\r\ncase CHIP_RV200:\r\ncase CHIP_RS200:\r\ncase CHIP_RS300:\r\nswitch (ddc_line) {\r\ncase RADEON_GPIO_DVI_DDC:\r\ni2c.hw_capable = true;\r\nbreak;\r\ndefault:\r\ni2c.hw_capable = false;\r\nbreak;\r\n}\r\nbreak;\r\ncase CHIP_R200:\r\nswitch (ddc_line) {\r\ncase RADEON_GPIO_DVI_DDC:\r\ncase RADEON_GPIO_MONID:\r\ni2c.hw_capable = true;\r\nbreak;\r\ndefault:\r\ni2c.hw_capable = false;\r\nbreak;\r\n}\r\nbreak;\r\ncase CHIP_RV250:\r\ncase CHIP_RV280:\r\nswitch (ddc_line) {\r\ncase RADEON_GPIO_VGA_DDC:\r\ncase RADEON_GPIO_DVI_DDC:\r\ncase RADEON_GPIO_CRT2_DDC:\r\ni2c.hw_capable = true;\r\nbreak;\r\ndefault:\r\ni2c.hw_capable = false;\r\nbreak;\r\n}\r\nbreak;\r\ncase CHIP_R300:\r\ncase CHIP_R350:\r\nswitch (ddc_line) {\r\ncase RADEON_GPIO_VGA_DDC:\r\ncase RADEON_GPIO_DVI_DDC:\r\ni2c.hw_capable = true;\r\nbreak;\r\ndefault:\r\ni2c.hw_capable = false;\r\nbreak;\r\n}\r\nbreak;\r\ncase CHIP_RV350:\r\ncase CHIP_RV380:\r\ncase CHIP_RS400:\r\ncase CHIP_RS480:\r\nswitch (ddc_line) {\r\ncase RADEON_GPIO_VGA_DDC:\r\ncase RADEON_GPIO_DVI_DDC:\r\ni2c.hw_capable = true;\r\nbreak;\r\ncase RADEON_GPIO_MONID:\r\ni2c.hw_capable = false;\r\nbreak;\r\ndefault:\r\ni2c.hw_capable = false;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ni2c.hw_capable = false;\r\nbreak;\r\n}\r\ni2c.mm_i2c = false;\r\ni2c.i2c_id = ddc;\r\ni2c.hpd = RADEON_HPD_NONE;\r\nif (ddc_line)\r\ni2c.valid = true;\r\nelse\r\ni2c.valid = false;\r\nreturn i2c;\r\n}\r\nstatic struct radeon_i2c_bus_rec radeon_combios_get_i2c_info_from_table(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nstruct radeon_i2c_bus_rec i2c;\r\nu16 offset;\r\nu8 id, blocks, clk, data;\r\nint i;\r\ni2c.valid = false;\r\noffset = combios_get_table_offset(dev, COMBIOS_I2C_INFO_TABLE);\r\nif (offset) {\r\nblocks = RBIOS8(offset + 2);\r\nfor (i = 0; i < blocks; i++) {\r\nid = RBIOS8(offset + 3 + (i * 5) + 0);\r\nif (id == 136) {\r\nclk = RBIOS8(offset + 3 + (i * 5) + 3);\r\ndata = RBIOS8(offset + 3 + (i * 5) + 4);\r\ni2c = combios_setup_i2c_bus(rdev, DDC_MONID,\r\n(1 << clk), (1 << data));\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn i2c;\r\n}\r\nvoid radeon_combios_i2c_init(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nstruct radeon_i2c_bus_rec i2c;\r\ni2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nrdev->i2c_bus[0] = radeon_i2c_create(dev, &i2c, "DVI_DDC");\r\ni2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nrdev->i2c_bus[1] = radeon_i2c_create(dev, &i2c, "VGA_DDC");\r\ni2c.valid = true;\r\ni2c.hw_capable = true;\r\ni2c.mm_i2c = true;\r\ni2c.i2c_id = 0xa0;\r\nrdev->i2c_bus[2] = radeon_i2c_create(dev, &i2c, "MM_I2C");\r\nif (rdev->family == CHIP_R300 ||\r\nrdev->family == CHIP_R350) {\r\n} else if (rdev->family == CHIP_RS300 ||\r\nrdev->family == CHIP_RS400 ||\r\nrdev->family == CHIP_RS480) {\r\ni2c = combios_setup_i2c_bus(rdev, DDC_CRT2, 0, 0);\r\nrdev->i2c_bus[3] = radeon_i2c_create(dev, &i2c, "MONID");\r\ni2c = radeon_combios_get_i2c_info_from_table(rdev);\r\nif (i2c.valid)\r\nrdev->i2c_bus[4] = radeon_i2c_create(dev, &i2c, "GPIOPAD_MASK");\r\n} else if ((rdev->family == CHIP_R200) ||\r\n(rdev->family >= CHIP_R300)) {\r\ni2c = combios_setup_i2c_bus(rdev, DDC_MONID, 0, 0);\r\nrdev->i2c_bus[3] = radeon_i2c_create(dev, &i2c, "MONID");\r\n} else {\r\ni2c = combios_setup_i2c_bus(rdev, DDC_MONID, 0, 0);\r\nrdev->i2c_bus[3] = radeon_i2c_create(dev, &i2c, "MONID");\r\ni2c = combios_setup_i2c_bus(rdev, DDC_CRT2, 0, 0);\r\nrdev->i2c_bus[4] = radeon_i2c_create(dev, &i2c, "CRT2_DDC");\r\n}\r\n}\r\nbool radeon_combios_get_clock_info(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint16_t pll_info;\r\nstruct radeon_pll *p1pll = &rdev->clock.p1pll;\r\nstruct radeon_pll *p2pll = &rdev->clock.p2pll;\r\nstruct radeon_pll *spll = &rdev->clock.spll;\r\nstruct radeon_pll *mpll = &rdev->clock.mpll;\r\nint8_t rev;\r\nuint16_t sclk, mclk;\r\npll_info = combios_get_table_offset(dev, COMBIOS_PLL_INFO_TABLE);\r\nif (pll_info) {\r\nrev = RBIOS8(pll_info);\r\np1pll->reference_freq = RBIOS16(pll_info + 0xe);\r\np1pll->reference_div = RBIOS16(pll_info + 0x10);\r\np1pll->pll_out_min = RBIOS32(pll_info + 0x12);\r\np1pll->pll_out_max = RBIOS32(pll_info + 0x16);\r\np1pll->lcd_pll_out_min = p1pll->pll_out_min;\r\np1pll->lcd_pll_out_max = p1pll->pll_out_max;\r\nif (rev > 9) {\r\np1pll->pll_in_min = RBIOS32(pll_info + 0x36);\r\np1pll->pll_in_max = RBIOS32(pll_info + 0x3a);\r\n} else {\r\np1pll->pll_in_min = 40;\r\np1pll->pll_in_max = 500;\r\n}\r\n*p2pll = *p1pll;\r\nspll->reference_freq = RBIOS16(pll_info + 0x1a);\r\nspll->reference_div = RBIOS16(pll_info + 0x1c);\r\nspll->pll_out_min = RBIOS32(pll_info + 0x1e);\r\nspll->pll_out_max = RBIOS32(pll_info + 0x22);\r\nif (rev > 10) {\r\nspll->pll_in_min = RBIOS32(pll_info + 0x48);\r\nspll->pll_in_max = RBIOS32(pll_info + 0x4c);\r\n} else {\r\nspll->pll_in_min = 40;\r\nspll->pll_in_max = 500;\r\n}\r\nmpll->reference_freq = RBIOS16(pll_info + 0x26);\r\nmpll->reference_div = RBIOS16(pll_info + 0x28);\r\nmpll->pll_out_min = RBIOS32(pll_info + 0x2a);\r\nmpll->pll_out_max = RBIOS32(pll_info + 0x2e);\r\nif (rev > 10) {\r\nmpll->pll_in_min = RBIOS32(pll_info + 0x5a);\r\nmpll->pll_in_max = RBIOS32(pll_info + 0x5e);\r\n} else {\r\nmpll->pll_in_min = 40;\r\nmpll->pll_in_max = 500;\r\n}\r\nsclk = RBIOS16(pll_info + 0xa);\r\nmclk = RBIOS16(pll_info + 0x8);\r\nif (sclk == 0)\r\nsclk = 200 * 100;\r\nif (mclk == 0)\r\nmclk = 200 * 100;\r\nrdev->clock.default_sclk = sclk;\r\nrdev->clock.default_mclk = mclk;\r\nif (RBIOS32(pll_info + 0x16))\r\nrdev->clock.max_pixel_clock = RBIOS32(pll_info + 0x16);\r\nelse\r\nrdev->clock.max_pixel_clock = 35000;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool radeon_combios_sideport_present(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nu16 igp_info;\r\nif (rdev->family == CHIP_RS400)\r\nreturn false;\r\nigp_info = combios_get_table_offset(dev, COMBIOS_INTEGRATED_SYSTEM_INFO_TABLE);\r\nif (igp_info) {\r\nif (RBIOS16(igp_info + 0x4))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void radeon_legacy_get_primary_dac_info_from_table(struct radeon_device *rdev,\r\nstruct radeon_encoder_primary_dac *p_dac)\r\n{\r\np_dac->ps2_pdac_adj = default_primarydac_adj[rdev->family];\r\nreturn;\r\n}\r\nstruct radeon_encoder_primary_dac *radeon_combios_get_primary_dac_info(struct\r\nradeon_encoder\r\n*encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint16_t dac_info;\r\nuint8_t rev, bg, dac;\r\nstruct radeon_encoder_primary_dac *p_dac = NULL;\r\nint found = 0;\r\np_dac = kzalloc(sizeof(struct radeon_encoder_primary_dac),\r\nGFP_KERNEL);\r\nif (!p_dac)\r\nreturn NULL;\r\ndac_info = combios_get_table_offset(dev, COMBIOS_CRT_INFO_TABLE);\r\nif (dac_info) {\r\nrev = RBIOS8(dac_info) & 0x3;\r\nif (rev < 2) {\r\nbg = RBIOS8(dac_info + 0x2) & 0xf;\r\ndac = (RBIOS8(dac_info + 0x2) >> 4) & 0xf;\r\np_dac->ps2_pdac_adj = (bg << 8) | (dac);\r\n} else {\r\nbg = RBIOS8(dac_info + 0x2) & 0xf;\r\ndac = RBIOS8(dac_info + 0x3) & 0xf;\r\np_dac->ps2_pdac_adj = (bg << 8) | (dac);\r\n}\r\nif ((dac == 0) || (bg == 0))\r\nfound = 0;\r\nelse\r\nfound = 1;\r\n}\r\nif (((dev->pdev->device == 0x5159) &&\r\n(dev->pdev->subsystem_vendor == 0x174B) &&\r\n(dev->pdev->subsystem_device == 0x7c28)) ||\r\n((dev->pdev->device == 0x514D) &&\r\n(dev->pdev->subsystem_vendor == 0x174B) &&\r\n(dev->pdev->subsystem_device == 0x7149))) {\r\nfound = 0;\r\n}\r\nif (!found)\r\nradeon_legacy_get_primary_dac_info_from_table(rdev, p_dac);\r\nreturn p_dac;\r\n}\r\nenum radeon_tv_std\r\nradeon_combios_get_tv_info(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nuint16_t tv_info;\r\nenum radeon_tv_std tv_std = TV_STD_NTSC;\r\ntv_info = combios_get_table_offset(dev, COMBIOS_TV_INFO_TABLE);\r\nif (tv_info) {\r\nif (RBIOS8(tv_info + 6) == 'T') {\r\nswitch (RBIOS8(tv_info + 7) & 0xf) {\r\ncase 1:\r\ntv_std = TV_STD_NTSC;\r\nDRM_DEBUG_KMS("Default TV standard: NTSC\n");\r\nbreak;\r\ncase 2:\r\ntv_std = TV_STD_PAL;\r\nDRM_DEBUG_KMS("Default TV standard: PAL\n");\r\nbreak;\r\ncase 3:\r\ntv_std = TV_STD_PAL_M;\r\nDRM_DEBUG_KMS("Default TV standard: PAL-M\n");\r\nbreak;\r\ncase 4:\r\ntv_std = TV_STD_PAL_60;\r\nDRM_DEBUG_KMS("Default TV standard: PAL-60\n");\r\nbreak;\r\ncase 5:\r\ntv_std = TV_STD_NTSC_J;\r\nDRM_DEBUG_KMS("Default TV standard: NTSC-J\n");\r\nbreak;\r\ncase 6:\r\ntv_std = TV_STD_SCART_PAL;\r\nDRM_DEBUG_KMS("Default TV standard: SCART-PAL\n");\r\nbreak;\r\ndefault:\r\ntv_std = TV_STD_NTSC;\r\nDRM_DEBUG_KMS\r\n("Unknown TV standard; defaulting to NTSC\n");\r\nbreak;\r\n}\r\nswitch ((RBIOS8(tv_info + 9) >> 2) & 0x3) {\r\ncase 0:\r\nDRM_DEBUG_KMS("29.498928713 MHz TV ref clk\n");\r\nbreak;\r\ncase 1:\r\nDRM_DEBUG_KMS("28.636360000 MHz TV ref clk\n");\r\nbreak;\r\ncase 2:\r\nDRM_DEBUG_KMS("14.318180000 MHz TV ref clk\n");\r\nbreak;\r\ncase 3:\r\nDRM_DEBUG_KMS("27.000000000 MHz TV ref clk\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn tv_std;\r\n}\r\nstatic void radeon_legacy_get_tv_dac_info_from_table(struct radeon_device *rdev,\r\nstruct radeon_encoder_tv_dac *tv_dac)\r\n{\r\ntv_dac->ps2_tvdac_adj = default_tvdac_adj[rdev->family];\r\nif ((rdev->flags & RADEON_IS_MOBILITY) && (rdev->family == CHIP_RV250))\r\ntv_dac->ps2_tvdac_adj = 0x00880000;\r\ntv_dac->pal_tvdac_adj = tv_dac->ps2_tvdac_adj;\r\ntv_dac->ntsc_tvdac_adj = tv_dac->ps2_tvdac_adj;\r\nreturn;\r\n}\r\nstruct radeon_encoder_tv_dac *radeon_combios_get_tv_dac_info(struct\r\nradeon_encoder\r\n*encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint16_t dac_info;\r\nuint8_t rev, bg, dac;\r\nstruct radeon_encoder_tv_dac *tv_dac = NULL;\r\nint found = 0;\r\ntv_dac = kzalloc(sizeof(struct radeon_encoder_tv_dac), GFP_KERNEL);\r\nif (!tv_dac)\r\nreturn NULL;\r\ndac_info = combios_get_table_offset(dev, COMBIOS_TV_INFO_TABLE);\r\nif (dac_info) {\r\nrev = RBIOS8(dac_info + 0x3);\r\nif (rev > 4) {\r\nbg = RBIOS8(dac_info + 0xc) & 0xf;\r\ndac = RBIOS8(dac_info + 0xd) & 0xf;\r\ntv_dac->ps2_tvdac_adj = (bg << 16) | (dac << 20);\r\nbg = RBIOS8(dac_info + 0xe) & 0xf;\r\ndac = RBIOS8(dac_info + 0xf) & 0xf;\r\ntv_dac->pal_tvdac_adj = (bg << 16) | (dac << 20);\r\nbg = RBIOS8(dac_info + 0x10) & 0xf;\r\ndac = RBIOS8(dac_info + 0x11) & 0xf;\r\ntv_dac->ntsc_tvdac_adj = (bg << 16) | (dac << 20);\r\nif (tv_dac->ps2_tvdac_adj)\r\nfound = 1;\r\n} else if (rev > 1) {\r\nbg = RBIOS8(dac_info + 0xc) & 0xf;\r\ndac = (RBIOS8(dac_info + 0xc) >> 4) & 0xf;\r\ntv_dac->ps2_tvdac_adj = (bg << 16) | (dac << 20);\r\nbg = RBIOS8(dac_info + 0xd) & 0xf;\r\ndac = (RBIOS8(dac_info + 0xd) >> 4) & 0xf;\r\ntv_dac->pal_tvdac_adj = (bg << 16) | (dac << 20);\r\nbg = RBIOS8(dac_info + 0xe) & 0xf;\r\ndac = (RBIOS8(dac_info + 0xe) >> 4) & 0xf;\r\ntv_dac->ntsc_tvdac_adj = (bg << 16) | (dac << 20);\r\nif (tv_dac->ps2_tvdac_adj)\r\nfound = 1;\r\n}\r\ntv_dac->tv_std = radeon_combios_get_tv_info(rdev);\r\n}\r\nif (!found) {\r\ndac_info =\r\ncombios_get_table_offset(dev, COMBIOS_CRT_INFO_TABLE);\r\nif (dac_info) {\r\nrev = RBIOS8(dac_info) & 0x3;\r\nif (rev < 2) {\r\nbg = RBIOS8(dac_info + 0x3) & 0xf;\r\ndac = (RBIOS8(dac_info + 0x3) >> 4) & 0xf;\r\ntv_dac->ps2_tvdac_adj =\r\n(bg << 16) | (dac << 20);\r\ntv_dac->pal_tvdac_adj = tv_dac->ps2_tvdac_adj;\r\ntv_dac->ntsc_tvdac_adj = tv_dac->ps2_tvdac_adj;\r\nif (tv_dac->ps2_tvdac_adj)\r\nfound = 1;\r\n} else {\r\nbg = RBIOS8(dac_info + 0x4) & 0xf;\r\ndac = RBIOS8(dac_info + 0x5) & 0xf;\r\ntv_dac->ps2_tvdac_adj =\r\n(bg << 16) | (dac << 20);\r\ntv_dac->pal_tvdac_adj = tv_dac->ps2_tvdac_adj;\r\ntv_dac->ntsc_tvdac_adj = tv_dac->ps2_tvdac_adj;\r\nif (tv_dac->ps2_tvdac_adj)\r\nfound = 1;\r\n}\r\n} else {\r\nDRM_INFO("No TV DAC info found in BIOS\n");\r\n}\r\n}\r\nif (!found)\r\nradeon_legacy_get_tv_dac_info_from_table(rdev, tv_dac);\r\nreturn tv_dac;\r\n}\r\nstatic struct radeon_encoder_lvds *radeon_legacy_get_lvds_info_from_regs(struct\r\nradeon_device\r\n*rdev)\r\n{\r\nstruct radeon_encoder_lvds *lvds = NULL;\r\nuint32_t fp_vert_stretch, fp_horz_stretch;\r\nuint32_t ppll_div_sel, ppll_val;\r\nuint32_t lvds_ss_gen_cntl = RREG32(RADEON_LVDS_SS_GEN_CNTL);\r\nlvds = kzalloc(sizeof(struct radeon_encoder_lvds), GFP_KERNEL);\r\nif (!lvds)\r\nreturn NULL;\r\nfp_vert_stretch = RREG32(RADEON_FP_VERT_STRETCH);\r\nfp_horz_stretch = RREG32(RADEON_FP_HORZ_STRETCH);\r\nlvds->panel_pwr_delay = 200;\r\nlvds->panel_vcc_delay = 2000;\r\nlvds->lvds_gen_cntl = RREG32(RADEON_LVDS_GEN_CNTL);\r\nlvds->panel_digon_delay = (lvds_ss_gen_cntl >> RADEON_LVDS_PWRSEQ_DELAY1_SHIFT) & 0xf;\r\nlvds->panel_blon_delay = (lvds_ss_gen_cntl >> RADEON_LVDS_PWRSEQ_DELAY2_SHIFT) & 0xf;\r\nif (fp_vert_stretch & RADEON_VERT_STRETCH_ENABLE)\r\nlvds->native_mode.vdisplay =\r\n((fp_vert_stretch & RADEON_VERT_PANEL_SIZE) >>\r\nRADEON_VERT_PANEL_SHIFT) + 1;\r\nelse\r\nlvds->native_mode.vdisplay =\r\n(RREG32(RADEON_CRTC_V_TOTAL_DISP) >> 16) + 1;\r\nif (fp_horz_stretch & RADEON_HORZ_STRETCH_ENABLE)\r\nlvds->native_mode.hdisplay =\r\n(((fp_horz_stretch & RADEON_HORZ_PANEL_SIZE) >>\r\nRADEON_HORZ_PANEL_SHIFT) + 1) * 8;\r\nelse\r\nlvds->native_mode.hdisplay =\r\n((RREG32(RADEON_CRTC_H_TOTAL_DISP) >> 16) + 1) * 8;\r\nif ((lvds->native_mode.hdisplay < 640) ||\r\n(lvds->native_mode.vdisplay < 480)) {\r\nlvds->native_mode.hdisplay = 640;\r\nlvds->native_mode.vdisplay = 480;\r\n}\r\nppll_div_sel = RREG8(RADEON_CLOCK_CNTL_INDEX + 1) & 0x3;\r\nppll_val = RREG32_PLL(RADEON_PPLL_DIV_0 + ppll_div_sel);\r\nif ((ppll_val & 0x000707ff) == 0x1bb)\r\nlvds->use_bios_dividers = false;\r\nelse {\r\nlvds->panel_ref_divider =\r\nRREG32_PLL(RADEON_PPLL_REF_DIV) & 0x3ff;\r\nlvds->panel_post_divider = (ppll_val >> 16) & 0x7;\r\nlvds->panel_fb_divider = ppll_val & 0x7ff;\r\nif ((lvds->panel_ref_divider != 0) &&\r\n(lvds->panel_fb_divider > 3))\r\nlvds->use_bios_dividers = true;\r\n}\r\nlvds->panel_vcc_delay = 200;\r\nDRM_INFO("Panel info derived from registers\n");\r\nDRM_INFO("Panel Size %dx%d\n", lvds->native_mode.hdisplay,\r\nlvds->native_mode.vdisplay);\r\nreturn lvds;\r\n}\r\nstruct radeon_encoder_lvds *radeon_combios_get_lvds_info(struct radeon_encoder\r\n*encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint16_t lcd_info;\r\nuint32_t panel_setup;\r\nchar stmp[30];\r\nint tmp, i;\r\nstruct radeon_encoder_lvds *lvds = NULL;\r\nlcd_info = combios_get_table_offset(dev, COMBIOS_LCD_INFO_TABLE);\r\nif (lcd_info) {\r\nlvds = kzalloc(sizeof(struct radeon_encoder_lvds), GFP_KERNEL);\r\nif (!lvds)\r\nreturn NULL;\r\nfor (i = 0; i < 24; i++)\r\nstmp[i] = RBIOS8(lcd_info + i + 1);\r\nstmp[24] = 0;\r\nDRM_INFO("Panel ID String: %s\n", stmp);\r\nlvds->native_mode.hdisplay = RBIOS16(lcd_info + 0x19);\r\nlvds->native_mode.vdisplay = RBIOS16(lcd_info + 0x1b);\r\nDRM_INFO("Panel Size %dx%d\n", lvds->native_mode.hdisplay,\r\nlvds->native_mode.vdisplay);\r\nlvds->panel_vcc_delay = RBIOS16(lcd_info + 0x2c);\r\nlvds->panel_vcc_delay = min_t(u16, lvds->panel_vcc_delay, 2000);\r\nlvds->panel_pwr_delay = RBIOS8(lcd_info + 0x24);\r\nlvds->panel_digon_delay = RBIOS16(lcd_info + 0x38) & 0xf;\r\nlvds->panel_blon_delay = (RBIOS16(lcd_info + 0x38) >> 4) & 0xf;\r\nlvds->panel_ref_divider = RBIOS16(lcd_info + 0x2e);\r\nlvds->panel_post_divider = RBIOS8(lcd_info + 0x30);\r\nlvds->panel_fb_divider = RBIOS16(lcd_info + 0x31);\r\nif ((lvds->panel_ref_divider != 0) &&\r\n(lvds->panel_fb_divider > 3))\r\nlvds->use_bios_dividers = true;\r\npanel_setup = RBIOS32(lcd_info + 0x39);\r\nlvds->lvds_gen_cntl = 0xff00;\r\nif (panel_setup & 0x1)\r\nlvds->lvds_gen_cntl |= RADEON_LVDS_PANEL_FORMAT;\r\nif ((panel_setup >> 4) & 0x1)\r\nlvds->lvds_gen_cntl |= RADEON_LVDS_PANEL_TYPE;\r\nswitch ((panel_setup >> 8) & 0x7) {\r\ncase 0:\r\nlvds->lvds_gen_cntl |= RADEON_LVDS_NO_FM;\r\nbreak;\r\ncase 1:\r\nlvds->lvds_gen_cntl |= RADEON_LVDS_2_GREY;\r\nbreak;\r\ncase 2:\r\nlvds->lvds_gen_cntl |= RADEON_LVDS_4_GREY;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((panel_setup >> 16) & 0x1)\r\nlvds->lvds_gen_cntl |= RADEON_LVDS_FP_POL_LOW;\r\nif ((panel_setup >> 17) & 0x1)\r\nlvds->lvds_gen_cntl |= RADEON_LVDS_LP_POL_LOW;\r\nif ((panel_setup >> 18) & 0x1)\r\nlvds->lvds_gen_cntl |= RADEON_LVDS_DTM_POL_LOW;\r\nif ((panel_setup >> 23) & 0x1)\r\nlvds->lvds_gen_cntl |= RADEON_LVDS_BL_CLK_SEL;\r\nlvds->lvds_gen_cntl |= (panel_setup & 0xf0000000);\r\nfor (i = 0; i < 32; i++) {\r\ntmp = RBIOS16(lcd_info + 64 + i * 2);\r\nif (tmp == 0)\r\nbreak;\r\nif ((RBIOS16(tmp) == lvds->native_mode.hdisplay) &&\r\n(RBIOS16(tmp + 2) == lvds->native_mode.vdisplay)) {\r\nu32 hss = (RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;\r\nif (hss > lvds->native_mode.hdisplay)\r\nhss = (10 - 1) * 8;\r\nlvds->native_mode.htotal = lvds->native_mode.hdisplay +\r\n(RBIOS16(tmp + 17) - RBIOS16(tmp + 19)) * 8;\r\nlvds->native_mode.hsync_start = lvds->native_mode.hdisplay +\r\nhss;\r\nlvds->native_mode.hsync_end = lvds->native_mode.hsync_start +\r\n(RBIOS8(tmp + 23) * 8);\r\nlvds->native_mode.vtotal = lvds->native_mode.vdisplay +\r\n(RBIOS16(tmp + 24) - RBIOS16(tmp + 26));\r\nlvds->native_mode.vsync_start = lvds->native_mode.vdisplay +\r\n((RBIOS16(tmp + 28) & 0x7ff) - RBIOS16(tmp + 26));\r\nlvds->native_mode.vsync_end = lvds->native_mode.vsync_start +\r\n((RBIOS16(tmp + 28) & 0xf800) >> 11);\r\nlvds->native_mode.clock = RBIOS16(tmp + 9) * 10;\r\nlvds->native_mode.flags = 0;\r\ndrm_mode_set_crtcinfo(&lvds->native_mode, CRTC_INTERLACE_HALVE_V);\r\n}\r\n}\r\n} else {\r\nDRM_INFO("No panel info found in BIOS\n");\r\nlvds = radeon_legacy_get_lvds_info_from_regs(rdev);\r\n}\r\nif (lvds)\r\nencoder->native_mode = lvds->native_mode;\r\nreturn lvds;\r\n}\r\nbool radeon_legacy_get_tmds_info_from_table(struct radeon_encoder *encoder,\r\nstruct radeon_encoder_int_tmds *tmds)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\ntmds->tmds_pll[i].value =\r\ndefault_tmds_pll[rdev->family][i].value;\r\ntmds->tmds_pll[i].freq = default_tmds_pll[rdev->family][i].freq;\r\n}\r\nreturn true;\r\n}\r\nbool radeon_legacy_get_tmds_info_from_combios(struct radeon_encoder *encoder,\r\nstruct radeon_encoder_int_tmds *tmds)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint16_t tmds_info;\r\nint i, n;\r\nuint8_t ver;\r\ntmds_info = combios_get_table_offset(dev, COMBIOS_DFP_INFO_TABLE);\r\nif (tmds_info) {\r\nver = RBIOS8(tmds_info);\r\nDRM_DEBUG_KMS("DFP table revision: %d\n", ver);\r\nif (ver == 3) {\r\nn = RBIOS8(tmds_info + 5) + 1;\r\nif (n > 4)\r\nn = 4;\r\nfor (i = 0; i < n; i++) {\r\ntmds->tmds_pll[i].value =\r\nRBIOS32(tmds_info + i * 10 + 0x08);\r\ntmds->tmds_pll[i].freq =\r\nRBIOS16(tmds_info + i * 10 + 0x10);\r\nDRM_DEBUG_KMS("TMDS PLL From COMBIOS %u %x\n",\r\ntmds->tmds_pll[i].freq,\r\ntmds->tmds_pll[i].value);\r\n}\r\n} else if (ver == 4) {\r\nint stride = 0;\r\nn = RBIOS8(tmds_info + 5) + 1;\r\nif (n > 4)\r\nn = 4;\r\nfor (i = 0; i < n; i++) {\r\ntmds->tmds_pll[i].value =\r\nRBIOS32(tmds_info + stride + 0x08);\r\ntmds->tmds_pll[i].freq =\r\nRBIOS16(tmds_info + stride + 0x10);\r\nif (i == 0)\r\nstride += 10;\r\nelse\r\nstride += 6;\r\nDRM_DEBUG_KMS("TMDS PLL From COMBIOS %u %x\n",\r\ntmds->tmds_pll[i].freq,\r\ntmds->tmds_pll[i].value);\r\n}\r\n}\r\n} else {\r\nDRM_INFO("No TMDS info found in BIOS\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool radeon_legacy_get_ext_tmds_info_from_table(struct radeon_encoder *encoder,\r\nstruct radeon_encoder_ext_tmds *tmds)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_i2c_bus_rec i2c_bus;\r\ni2c_bus = combios_setup_i2c_bus(rdev, DDC_MONID, 0, 0);\r\ntmds->i2c_bus = radeon_i2c_lookup(rdev, &i2c_bus);\r\nswitch (rdev->mode_info.connector_table) {\r\ncase CT_POWERBOOK_EXTERNAL:\r\ncase CT_MINI_EXTERNAL:\r\ndefault:\r\ntmds->dvo_chip = DVO_SIL164;\r\ntmds->slave_addr = 0x70 >> 1;\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nbool radeon_legacy_get_ext_tmds_info_from_combios(struct radeon_encoder *encoder,\r\nstruct radeon_encoder_ext_tmds *tmds)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint16_t offset;\r\nuint8_t ver;\r\nenum radeon_combios_ddc gpio;\r\nstruct radeon_i2c_bus_rec i2c_bus;\r\ntmds->i2c_bus = NULL;\r\nif (rdev->flags & RADEON_IS_IGP) {\r\ni2c_bus = combios_setup_i2c_bus(rdev, DDC_MONID, 0, 0);\r\ntmds->i2c_bus = radeon_i2c_lookup(rdev, &i2c_bus);\r\ntmds->dvo_chip = DVO_SIL164;\r\ntmds->slave_addr = 0x70 >> 1;\r\n} else {\r\noffset = combios_get_table_offset(dev, COMBIOS_EXT_TMDS_INFO_TABLE);\r\nif (offset) {\r\nver = RBIOS8(offset);\r\nDRM_DEBUG_KMS("External TMDS Table revision: %d\n", ver);\r\ntmds->slave_addr = RBIOS8(offset + 4 + 2);\r\ntmds->slave_addr >>= 1;\r\ngpio = RBIOS8(offset + 4 + 3);\r\nif (gpio == DDC_LCD) {\r\ni2c_bus.valid = true;\r\ni2c_bus.hw_capable = true;\r\ni2c_bus.mm_i2c = true;\r\ni2c_bus.i2c_id = 0xa0;\r\n} else\r\ni2c_bus = combios_setup_i2c_bus(rdev, gpio, 0, 0);\r\ntmds->i2c_bus = radeon_i2c_lookup(rdev, &i2c_bus);\r\n}\r\n}\r\nif (!tmds->i2c_bus) {\r\nDRM_INFO("No valid Ext TMDS info found in BIOS\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool radeon_get_legacy_connector_info_from_table(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_i2c_bus_rec ddc_i2c;\r\nstruct radeon_hpd hpd;\r\nrdev->mode_info.connector_table = radeon_connector_table;\r\nif (rdev->mode_info.connector_table == CT_NONE) {\r\n#ifdef CONFIG_PPC_PMAC\r\nif (of_machine_is_compatible("PowerBook3,3")) {\r\nrdev->mode_info.connector_table = CT_POWERBOOK_VGA;\r\n} else if (of_machine_is_compatible("PowerBook3,4") ||\r\nof_machine_is_compatible("PowerBook3,5")) {\r\nrdev->mode_info.connector_table = CT_POWERBOOK_INTERNAL;\r\n} else if (of_machine_is_compatible("PowerBook5,1") ||\r\nof_machine_is_compatible("PowerBook5,2") ||\r\nof_machine_is_compatible("PowerBook5,3") ||\r\nof_machine_is_compatible("PowerBook5,4") ||\r\nof_machine_is_compatible("PowerBook5,5")) {\r\nrdev->mode_info.connector_table = CT_POWERBOOK_EXTERNAL;\r\n} else if (of_machine_is_compatible("PowerBook5,6")) {\r\nrdev->mode_info.connector_table = CT_POWERBOOK_EXTERNAL;\r\n} else if (of_machine_is_compatible("PowerBook5,7") ||\r\nof_machine_is_compatible("PowerBook5,8") ||\r\nof_machine_is_compatible("PowerBook5,9")) {\r\nrdev->mode_info.connector_table = CT_POWERBOOK_EXTERNAL;\r\n} else if (of_machine_is_compatible("PowerBook4,1") ||\r\nof_machine_is_compatible("PowerBook4,2") ||\r\nof_machine_is_compatible("PowerBook4,3") ||\r\nof_machine_is_compatible("PowerBook6,3") ||\r\nof_machine_is_compatible("PowerBook6,5") ||\r\nof_machine_is_compatible("PowerBook6,7")) {\r\nrdev->mode_info.connector_table = CT_IBOOK;\r\n} else if (of_machine_is_compatible("PowerMac3,5")) {\r\nrdev->mode_info.connector_table = CT_MAC_G4_SILVER;\r\n} else if (of_machine_is_compatible("PowerMac4,4")) {\r\nrdev->mode_info.connector_table = CT_EMAC;\r\n} else if (of_machine_is_compatible("PowerMac10,1")) {\r\nrdev->mode_info.connector_table = CT_MINI_INTERNAL;\r\n} else if (of_machine_is_compatible("PowerMac10,2")) {\r\nrdev->mode_info.connector_table = CT_MINI_EXTERNAL;\r\n} else if (of_machine_is_compatible("PowerMac12,1")) {\r\nrdev->mode_info.connector_table = CT_IMAC_G5_ISIGHT;\r\n} else if ((rdev->pdev->device == 0x4a48) &&\r\n(rdev->pdev->subsystem_vendor == 0x1002) &&\r\n(rdev->pdev->subsystem_device == 0x4a48)) {\r\nrdev->mode_info.connector_table = CT_MAC_X800;\r\n} else if ((of_machine_is_compatible("PowerMac7,2") ||\r\nof_machine_is_compatible("PowerMac7,3")) &&\r\n(rdev->pdev->device == 0x4150) &&\r\n(rdev->pdev->subsystem_vendor == 0x1002) &&\r\n(rdev->pdev->subsystem_device == 0x4150)) {\r\nrdev->mode_info.connector_table = CT_MAC_G5_9600;\r\n} else if ((rdev->pdev->device == 0x4c66) &&\r\n(rdev->pdev->subsystem_vendor == 0x1002) &&\r\n(rdev->pdev->subsystem_device == 0x4c66)) {\r\nrdev->mode_info.connector_table = CT_SAM440EP;\r\n} else\r\n#endif\r\n#ifdef CONFIG_PPC64\r\nif (ASIC_IS_RN50(rdev))\r\nrdev->mode_info.connector_table = CT_RN50_POWER;\r\nelse\r\n#endif\r\nrdev->mode_info.connector_table = CT_GENERIC;\r\n}\r\nswitch (rdev->mode_info.connector_table) {\r\ncase CT_GENERIC:\r\nDRM_INFO("Connector Table: %d (generic)\n",\r\nrdev->mode_info.connector_table);\r\nif (rdev->flags & RADEON_SINGLE_CRTC) {\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\n} else if (rdev->flags & RADEON_IS_MOBILITY) {\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_NONE_DETECTED, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_LCD1_SUPPORT,\r\n0),\r\nATOM_DEVICE_LCD1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0,\r\nATOM_DEVICE_LCD1_SUPPORT,\r\nDRM_MODE_CONNECTOR_LVDS,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_LVDS,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\n} else {\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_1;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP1_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP1_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0,\r\nATOM_DEVICE_DFP1_SUPPORT |\r\nATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\n}\r\nif (rdev->family != CHIP_R100 && rdev->family != CHIP_R200) {\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 2,\r\nATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\n}\r\nbreak;\r\ncase CT_IBOOK:\r\nDRM_INFO("Connector Table: %d (ibook)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_LCD1_SUPPORT,\r\n0),\r\nATOM_DEVICE_LCD1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0, ATOM_DEVICE_LCD1_SUPPORT,\r\nDRM_MODE_CONNECTOR_LVDS, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_LVDS,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1, ATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 2, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ncase CT_POWERBOOK_EXTERNAL:\r\nDRM_INFO("Connector Table: %d (powerbook external tmds)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_LCD1_SUPPORT,\r\n0),\r\nATOM_DEVICE_LCD1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0, ATOM_DEVICE_LCD1_SUPPORT,\r\nDRM_MODE_CONNECTOR_LVDS, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_LVDS,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_2;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP2_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP2_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1,\r\nATOM_DEVICE_DFP2_SUPPORT |\r\nATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 2, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ncase CT_POWERBOOK_INTERNAL:\r\nDRM_INFO("Connector Table: %d (powerbook internal tmds)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_LCD1_SUPPORT,\r\n0),\r\nATOM_DEVICE_LCD1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0, ATOM_DEVICE_LCD1_SUPPORT,\r\nDRM_MODE_CONNECTOR_LVDS, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_LVDS,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_1;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP1_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP1_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1,\r\nATOM_DEVICE_DFP1_SUPPORT |\r\nATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 2, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ncase CT_POWERBOOK_VGA:\r\nDRM_INFO("Connector Table: %d (powerbook vga)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_LCD1_SUPPORT,\r\n0),\r\nATOM_DEVICE_LCD1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0, ATOM_DEVICE_LCD1_SUPPORT,\r\nDRM_MODE_CONNECTOR_LVDS, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_LVDS,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1, ATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 2, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ncase CT_MINI_EXTERNAL:\r\nDRM_INFO("Connector Table: %d (mini external tmds)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_CRT2, 0, 0);\r\nhpd.hpd = RADEON_HPD_2;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP2_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP2_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0,\r\nATOM_DEVICE_DFP2_SUPPORT |\r\nATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ncase CT_MINI_INTERNAL:\r\nDRM_INFO("Connector Table: %d (mini internal tmds)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_CRT2, 0, 0);\r\nhpd.hpd = RADEON_HPD_1;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP1_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP1_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0,\r\nATOM_DEVICE_DFP1_SUPPORT |\r\nATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ncase CT_IMAC_G5_ISIGHT:\r\nDRM_INFO("Connector Table: %d (imac g5 isight)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_MONID, 0, 0);\r\nhpd.hpd = RADEON_HPD_1;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP1_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0, ATOM_DEVICE_DFP1_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVID, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_D,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1, ATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 2, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ncase CT_EMAC:\r\nDRM_INFO("Connector Table: %d (emac)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0, ATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_CRT2, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1, ATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 2, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ncase CT_RN50_POWER:\r\nDRM_INFO("Connector Table: %d (rn50-power)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0, ATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_CRT2, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1, ATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\nbreak;\r\ncase CT_MAC_X800:\r\nDRM_INFO("Connector Table: %d (mac x800)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_1;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP1_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP1_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0,\r\nATOM_DEVICE_DFP1_SUPPORT |\r\nATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_MONID, 0, 0);\r\nhpd.hpd = RADEON_HPD_2;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP2_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP2_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1,\r\nATOM_DEVICE_DFP2_SUPPORT |\r\nATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I,\r\n&hpd);\r\nbreak;\r\ncase CT_MAC_G5_9600:\r\nDRM_INFO("Connector Table: %d (mac g5 9600)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_1;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP2_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP2_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0,\r\nATOM_DEVICE_DFP2_SUPPORT |\r\nATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_2;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP1_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP1_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1,\r\nATOM_DEVICE_DFP1_SUPPORT |\r\nATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 2, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ncase CT_SAM440EP:\r\nDRM_INFO("Connector Table: %d (SAM440ep embedded board)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_NONE_DETECTED, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_LCD1_SUPPORT,\r\n0),\r\nATOM_DEVICE_LCD1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0, ATOM_DEVICE_LCD1_SUPPORT,\r\nDRM_MODE_CONNECTOR_LVDS, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_LVDS,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_1;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP1_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP1_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1,\r\nATOM_DEVICE_DFP1_SUPPORT |\r\nATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 2,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 3, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ncase CT_MAC_G4_SILVER:\r\nDRM_INFO("Connector Table: %d (mac g4 silver)\n",\r\nrdev->mode_info.connector_table);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_1;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP1_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP1_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\nradeon_add_legacy_connector(dev, 0,\r\nATOM_DEVICE_DFP1_SUPPORT |\r\nATOM_DEVICE_CRT2_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I,\r\n&hpd);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 1, ATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA, &ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 2, ATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ndefault:\r\nDRM_INFO("Connector table: %d (invalid)\n",\r\nrdev->mode_info.connector_table);\r\nreturn false;\r\n}\r\nradeon_link_encoder_connector(dev);\r\nreturn true;\r\n}\r\nstatic bool radeon_apply_legacy_quirks(struct drm_device *dev,\r\nint bios_index,\r\nenum radeon_combios_connector\r\n*legacy_connector,\r\nstruct radeon_i2c_bus_rec *ddc_i2c,\r\nstruct radeon_hpd *hpd)\r\n{\r\nif (dev->pdev->device == 0x515e &&\r\ndev->pdev->subsystem_vendor == 0x1014) {\r\nif (*legacy_connector == CONNECTOR_CRT_LEGACY &&\r\nddc_i2c->mask_clk_reg == RADEON_GPIO_CRT2_DDC)\r\nreturn false;\r\n}\r\nif (dev->pdev->device == 0x5B60 &&\r\ndev->pdev->subsystem_vendor == 0x17af &&\r\ndev->pdev->subsystem_device == 0x201e && bios_index == 2) {\r\nif (*legacy_connector == CONNECTOR_DVI_I_LEGACY)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool radeon_apply_legacy_tv_quirks(struct drm_device *dev)\r\n{\r\nif (dev->pdev->device == 0x5975 &&\r\ndev->pdev->subsystem_vendor == 0x1025 &&\r\ndev->pdev->subsystem_device == 0x009f)\r\nreturn false;\r\nif (dev->pdev->device == 0x5974 &&\r\ndev->pdev->subsystem_vendor == 0x103c &&\r\ndev->pdev->subsystem_device == 0x280a)\r\nreturn false;\r\nif (dev->pdev->device == 0x5955 &&\r\ndev->pdev->subsystem_vendor == 0x1462 &&\r\ndev->pdev->subsystem_device == 0x0131)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic uint16_t combios_check_dl_dvi(struct drm_device *dev, int is_dvi_d)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t ext_tmds_info;\r\nif (rdev->flags & RADEON_IS_IGP) {\r\nif (is_dvi_d)\r\nreturn CONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_D;\r\nelse\r\nreturn CONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I;\r\n}\r\next_tmds_info = combios_get_table_offset(dev, COMBIOS_EXT_TMDS_INFO_TABLE);\r\nif (ext_tmds_info) {\r\nuint8_t rev = RBIOS8(ext_tmds_info);\r\nuint8_t flags = RBIOS8(ext_tmds_info + 4 + 5);\r\nif (rev >= 3) {\r\nif (is_dvi_d)\r\nreturn CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_D;\r\nelse\r\nreturn CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I;\r\n} else {\r\nif (flags & 1) {\r\nif (is_dvi_d)\r\nreturn CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_D;\r\nelse\r\nreturn CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I;\r\n}\r\n}\r\n}\r\nif (is_dvi_d)\r\nreturn CONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_D;\r\nelse\r\nreturn CONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I;\r\n}\r\nbool radeon_get_legacy_connector_info_from_bios(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t conn_info, entry, devices;\r\nuint16_t tmp, connector_object_id;\r\nenum radeon_combios_ddc ddc_type;\r\nenum radeon_combios_connector connector;\r\nint i = 0;\r\nstruct radeon_i2c_bus_rec ddc_i2c;\r\nstruct radeon_hpd hpd;\r\nconn_info = combios_get_table_offset(dev, COMBIOS_CONNECTOR_INFO_TABLE);\r\nif (conn_info) {\r\nfor (i = 0; i < 4; i++) {\r\nentry = conn_info + 2 + i * 2;\r\nif (!RBIOS16(entry))\r\nbreak;\r\ntmp = RBIOS16(entry);\r\nconnector = (tmp >> 12) & 0xf;\r\nddc_type = (tmp >> 8) & 0xf;\r\nif (ddc_type == 5)\r\nddc_i2c = radeon_combios_get_i2c_info_from_table(rdev);\r\nelse\r\nddc_i2c = combios_setup_i2c_bus(rdev, ddc_type, 0, 0);\r\nswitch (connector) {\r\ncase CONNECTOR_PROPRIETARY_LEGACY:\r\ncase CONNECTOR_DVI_I_LEGACY:\r\ncase CONNECTOR_DVI_D_LEGACY:\r\nif ((tmp >> 4) & 0x1)\r\nhpd.hpd = RADEON_HPD_2;\r\nelse\r\nhpd.hpd = RADEON_HPD_1;\r\nbreak;\r\ndefault:\r\nhpd.hpd = RADEON_HPD_NONE;\r\nbreak;\r\n}\r\nif (!radeon_apply_legacy_quirks(dev, i, &connector,\r\n&ddc_i2c, &hpd))\r\ncontinue;\r\nswitch (connector) {\r\ncase CONNECTOR_PROPRIETARY_LEGACY:\r\nif ((tmp >> 4) & 0x1)\r\ndevices = ATOM_DEVICE_DFP2_SUPPORT;\r\nelse\r\ndevices = ATOM_DEVICE_DFP1_SUPPORT;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum\r\n(dev, devices, 0),\r\ndevices);\r\nradeon_add_legacy_connector(dev, i, devices,\r\nlegacy_connector_convert\r\n[connector],\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_D,\r\n&hpd);\r\nbreak;\r\ncase CONNECTOR_CRT_LEGACY:\r\nif (tmp & 0x1) {\r\ndevices = ATOM_DEVICE_CRT2_SUPPORT;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum\r\n(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\n} else {\r\ndevices = ATOM_DEVICE_CRT1_SUPPORT;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum\r\n(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\n}\r\nradeon_add_legacy_connector(dev,\r\ni,\r\ndevices,\r\nlegacy_connector_convert\r\n[connector],\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\nbreak;\r\ncase CONNECTOR_DVI_I_LEGACY:\r\ndevices = 0;\r\nif (tmp & 0x1) {\r\ndevices |= ATOM_DEVICE_CRT2_SUPPORT;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum\r\n(dev,\r\nATOM_DEVICE_CRT2_SUPPORT,\r\n2),\r\nATOM_DEVICE_CRT2_SUPPORT);\r\n} else {\r\ndevices |= ATOM_DEVICE_CRT1_SUPPORT;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum\r\n(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\n}\r\nif (dev->pdev->device == 0x5159 &&\r\ndev->pdev->subsystem_vendor == 0x1014 &&\r\ndev->pdev->subsystem_device == 0x029A) {\r\ntmp &= ~(1 << 4);\r\n}\r\nif ((tmp >> 4) & 0x1) {\r\ndevices |= ATOM_DEVICE_DFP2_SUPPORT;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum\r\n(dev,\r\nATOM_DEVICE_DFP2_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP2_SUPPORT);\r\nconnector_object_id = combios_check_dl_dvi(dev, 0);\r\n} else {\r\ndevices |= ATOM_DEVICE_DFP1_SUPPORT;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum\r\n(dev,\r\nATOM_DEVICE_DFP1_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP1_SUPPORT);\r\nconnector_object_id = CONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I;\r\n}\r\nradeon_add_legacy_connector(dev,\r\ni,\r\ndevices,\r\nlegacy_connector_convert\r\n[connector],\r\n&ddc_i2c,\r\nconnector_object_id,\r\n&hpd);\r\nbreak;\r\ncase CONNECTOR_DVI_D_LEGACY:\r\nif ((tmp >> 4) & 0x1) {\r\ndevices = ATOM_DEVICE_DFP2_SUPPORT;\r\nconnector_object_id = combios_check_dl_dvi(dev, 1);\r\n} else {\r\ndevices = ATOM_DEVICE_DFP1_SUPPORT;\r\nconnector_object_id = CONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I;\r\n}\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum\r\n(dev, devices, 0),\r\ndevices);\r\nradeon_add_legacy_connector(dev, i, devices,\r\nlegacy_connector_convert\r\n[connector],\r\n&ddc_i2c,\r\nconnector_object_id,\r\n&hpd);\r\nbreak;\r\ncase CONNECTOR_CTV_LEGACY:\r\ncase CONNECTOR_STV_LEGACY:\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum\r\n(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, i,\r\nATOM_DEVICE_TV1_SUPPORT,\r\nlegacy_connector_convert\r\n[connector],\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown connector type: %d\n",\r\nconnector);\r\ncontinue;\r\n}\r\n}\r\n} else {\r\nuint16_t tmds_info =\r\ncombios_get_table_offset(dev, COMBIOS_DFP_INFO_TABLE);\r\nif (tmds_info) {\r\nDRM_DEBUG_KMS("Found DFP table, assuming DVI connector\n");\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_DFP1_SUPPORT,\r\n0),\r\nATOM_DEVICE_DFP1_SUPPORT);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_DVI, 0, 0);\r\nhpd.hpd = RADEON_HPD_1;\r\nradeon_add_legacy_connector(dev,\r\n0,\r\nATOM_DEVICE_CRT1_SUPPORT |\r\nATOM_DEVICE_DFP1_SUPPORT,\r\nDRM_MODE_CONNECTOR_DVII,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I,\r\n&hpd);\r\n} else {\r\nuint16_t crt_info =\r\ncombios_get_table_offset(dev, COMBIOS_CRT_INFO_TABLE);\r\nDRM_DEBUG_KMS("Found CRT table, assuming VGA connector\n");\r\nif (crt_info) {\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\n1),\r\nATOM_DEVICE_CRT1_SUPPORT);\r\nddc_i2c = combios_setup_i2c_bus(rdev, DDC_VGA, 0, 0);\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_connector(dev,\r\n0,\r\nATOM_DEVICE_CRT1_SUPPORT,\r\nDRM_MODE_CONNECTOR_VGA,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_VGA,\r\n&hpd);\r\n} else {\r\nDRM_DEBUG_KMS("No connector info found\n");\r\nreturn false;\r\n}\r\n}\r\n}\r\nif (rdev->flags & RADEON_IS_MOBILITY || rdev->flags & RADEON_IS_IGP) {\r\nuint16_t lcd_info =\r\ncombios_get_table_offset(dev, COMBIOS_LCD_INFO_TABLE);\r\nif (lcd_info) {\r\nuint16_t lcd_ddc_info =\r\ncombios_get_table_offset(dev,\r\nCOMBIOS_LCD_DDC_INFO_TABLE);\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\nATOM_DEVICE_LCD1_SUPPORT,\r\n0),\r\nATOM_DEVICE_LCD1_SUPPORT);\r\nif (lcd_ddc_info) {\r\nddc_type = RBIOS8(lcd_ddc_info + 2);\r\nswitch (ddc_type) {\r\ncase DDC_LCD:\r\nddc_i2c =\r\ncombios_setup_i2c_bus(rdev,\r\nDDC_LCD,\r\nRBIOS32(lcd_ddc_info + 3),\r\nRBIOS32(lcd_ddc_info + 7));\r\nradeon_i2c_add(rdev, &ddc_i2c, "LCD");\r\nbreak;\r\ncase DDC_GPIO:\r\nddc_i2c =\r\ncombios_setup_i2c_bus(rdev,\r\nDDC_GPIO,\r\nRBIOS32(lcd_ddc_info + 3),\r\nRBIOS32(lcd_ddc_info + 7));\r\nradeon_i2c_add(rdev, &ddc_i2c, "LCD");\r\nbreak;\r\ndefault:\r\nddc_i2c =\r\ncombios_setup_i2c_bus(rdev, ddc_type, 0, 0);\r\nbreak;\r\n}\r\nDRM_DEBUG_KMS("LCD DDC Info Table found!\n");\r\n} else\r\nddc_i2c.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nradeon_add_legacy_connector(dev,\r\n5,\r\nATOM_DEVICE_LCD1_SUPPORT,\r\nDRM_MODE_CONNECTOR_LVDS,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_LVDS,\r\n&hpd);\r\n}\r\n}\r\nif (rdev->family != CHIP_R100 && rdev->family != CHIP_R200) {\r\nuint32_t tv_info =\r\ncombios_get_table_offset(dev, COMBIOS_TV_INFO_TABLE);\r\nif (tv_info) {\r\nif (RBIOS8(tv_info + 6) == 'T') {\r\nif (radeon_apply_legacy_tv_quirks(dev)) {\r\nhpd.hpd = RADEON_HPD_NONE;\r\nddc_i2c.valid = false;\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum\r\n(dev,\r\nATOM_DEVICE_TV1_SUPPORT,\r\n2),\r\nATOM_DEVICE_TV1_SUPPORT);\r\nradeon_add_legacy_connector(dev, 6,\r\nATOM_DEVICE_TV1_SUPPORT,\r\nDRM_MODE_CONNECTOR_SVIDEO,\r\n&ddc_i2c,\r\nCONNECTOR_OBJECT_ID_SVIDEO,\r\n&hpd);\r\n}\r\n}\r\n}\r\n}\r\nradeon_link_encoder_connector(dev);\r\nreturn true;\r\n}\r\nvoid radeon_combios_get_power_modes(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nu16 offset, misc, misc2 = 0;\r\nu8 rev, blocks, tmp;\r\nint state_index = 0;\r\nstruct radeon_i2c_bus_rec i2c_bus;\r\nrdev->pm.default_power_state_index = -1;\r\nrdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state) * 2, GFP_KERNEL);\r\nif (rdev->pm.power_state) {\r\nrdev->pm.power_state[0].clock_info =\r\nkzalloc(sizeof(struct radeon_pm_clock_info) * 1, GFP_KERNEL);\r\nrdev->pm.power_state[1].clock_info =\r\nkzalloc(sizeof(struct radeon_pm_clock_info) * 1, GFP_KERNEL);\r\nif (!rdev->pm.power_state[0].clock_info ||\r\n!rdev->pm.power_state[1].clock_info)\r\ngoto pm_failed;\r\n} else\r\ngoto pm_failed;\r\noffset = combios_get_table_offset(dev, COMBIOS_OVERDRIVE_INFO_TABLE);\r\nif (offset) {\r\nu8 thermal_controller = 0, gpio = 0, i2c_addr = 0, clk_bit = 0, data_bit = 0;\r\nrev = RBIOS8(offset);\r\nif (rev == 0) {\r\nthermal_controller = RBIOS8(offset + 3);\r\ngpio = RBIOS8(offset + 4) & 0x3f;\r\ni2c_addr = RBIOS8(offset + 5);\r\n} else if (rev == 1) {\r\nthermal_controller = RBIOS8(offset + 4);\r\ngpio = RBIOS8(offset + 5) & 0x3f;\r\ni2c_addr = RBIOS8(offset + 6);\r\n} else if (rev == 2) {\r\nthermal_controller = RBIOS8(offset + 4);\r\ngpio = RBIOS8(offset + 5) & 0x3f;\r\ni2c_addr = RBIOS8(offset + 6);\r\nclk_bit = RBIOS8(offset + 0xa);\r\ndata_bit = RBIOS8(offset + 0xb);\r\n}\r\nif ((thermal_controller > 0) && (thermal_controller < 3)) {\r\nDRM_INFO("Possible %s thermal controller at 0x%02x\n",\r\nthermal_controller_names[thermal_controller],\r\ni2c_addr >> 1);\r\nif (gpio == DDC_LCD) {\r\ni2c_bus.valid = true;\r\ni2c_bus.hw_capable = true;\r\ni2c_bus.mm_i2c = true;\r\ni2c_bus.i2c_id = 0xa0;\r\n} else if (gpio == DDC_GPIO)\r\ni2c_bus = combios_setup_i2c_bus(rdev, gpio, 1 << clk_bit, 1 << data_bit);\r\nelse\r\ni2c_bus = combios_setup_i2c_bus(rdev, gpio, 0, 0);\r\nrdev->pm.i2c_bus = radeon_i2c_lookup(rdev, &i2c_bus);\r\nif (rdev->pm.i2c_bus) {\r\nstruct i2c_board_info info = { };\r\nconst char *name = thermal_controller_names[thermal_controller];\r\ninfo.addr = i2c_addr >> 1;\r\nstrlcpy(info.type, name, sizeof(info.type));\r\ni2c_new_device(&rdev->pm.i2c_bus->adapter, &info);\r\n}\r\n}\r\n} else {\r\nif ((dev->pdev->device == 0x4152) &&\r\n(dev->pdev->subsystem_vendor == 0x1043) &&\r\n(dev->pdev->subsystem_device == 0xc002)) {\r\ni2c_bus = combios_setup_i2c_bus(rdev, DDC_MONID, 0, 0);\r\nrdev->pm.i2c_bus = radeon_i2c_lookup(rdev, &i2c_bus);\r\nif (rdev->pm.i2c_bus) {\r\nstruct i2c_board_info info = { };\r\nconst char *name = "f75375";\r\ninfo.addr = 0x28;\r\nstrlcpy(info.type, name, sizeof(info.type));\r\ni2c_new_device(&rdev->pm.i2c_bus->adapter, &info);\r\nDRM_INFO("Possible %s thermal controller at 0x%02x\n",\r\nname, info.addr);\r\n}\r\n}\r\n}\r\nif (rdev->flags & RADEON_IS_MOBILITY) {\r\noffset = combios_get_table_offset(dev, COMBIOS_POWERPLAY_INFO_TABLE);\r\nif (offset) {\r\nrev = RBIOS8(offset);\r\nblocks = RBIOS8(offset + 0x2);\r\nrdev->pm.power_state[state_index].num_clock_modes = 1;\r\nrdev->pm.power_state[state_index].clock_info[0].mclk = RBIOS32(offset + 0x5 + 0x2);\r\nrdev->pm.power_state[state_index].clock_info[0].sclk = RBIOS32(offset + 0x5 + 0x6);\r\nif ((rdev->pm.power_state[state_index].clock_info[0].mclk == 0) ||\r\n(rdev->pm.power_state[state_index].clock_info[0].sclk == 0))\r\ngoto default_mode;\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_BATTERY;\r\nmisc = RBIOS16(offset + 0x5 + 0x0);\r\nif (rev > 4)\r\nmisc2 = RBIOS16(offset + 0x5 + 0xe);\r\nrdev->pm.power_state[state_index].misc = misc;\r\nrdev->pm.power_state[state_index].misc2 = misc2;\r\nif (misc & 0x4) {\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type = VOLTAGE_GPIO;\r\nif (misc & 0x8)\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\r\ntrue;\r\nelse\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\r\nfalse;\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.gpio.valid = true;\r\nif (rev < 6) {\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.gpio.reg =\r\nRBIOS16(offset + 0x5 + 0xb) * 4;\r\ntmp = RBIOS8(offset + 0x5 + 0xd);\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.gpio.mask = (1 << tmp);\r\n} else {\r\nu8 entries = RBIOS8(offset + 0x5 + 0xb);\r\nu16 voltage_table_offset = RBIOS16(offset + 0x5 + 0xc);\r\nif (entries && voltage_table_offset) {\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.gpio.reg =\r\nRBIOS16(voltage_table_offset) * 4;\r\ntmp = RBIOS8(voltage_table_offset + 0x2);\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.gpio.mask = (1 << tmp);\r\n} else\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.gpio.valid = false;\r\n}\r\nswitch ((misc2 & 0x700) >> 8) {\r\ncase 0:\r\ndefault:\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.delay = 0;\r\nbreak;\r\ncase 1:\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.delay = 33;\r\nbreak;\r\ncase 2:\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.delay = 66;\r\nbreak;\r\ncase 3:\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.delay = 99;\r\nbreak;\r\ncase 4:\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.delay = 132;\r\nbreak;\r\n}\r\n} else\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type = VOLTAGE_NONE;\r\nif (rev > 6)\r\nrdev->pm.power_state[state_index].pcie_lanes =\r\nRBIOS8(offset + 0x5 + 0x10);\r\nrdev->pm.power_state[state_index].flags = RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\r\nstate_index++;\r\n} else {\r\n}\r\n} else {\r\n}\r\ndefault_mode:\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_DEFAULT;\r\nrdev->pm.power_state[state_index].num_clock_modes = 1;\r\nrdev->pm.power_state[state_index].clock_info[0].mclk = rdev->clock.default_mclk;\r\nrdev->pm.power_state[state_index].clock_info[0].sclk = rdev->clock.default_sclk;\r\nrdev->pm.power_state[state_index].default_clock_mode = &rdev->pm.power_state[state_index].clock_info[0];\r\nif ((state_index > 0) &&\r\n(rdev->pm.power_state[0].clock_info[0].voltage.type == VOLTAGE_GPIO))\r\nrdev->pm.power_state[state_index].clock_info[0].voltage =\r\nrdev->pm.power_state[0].clock_info[0].voltage;\r\nelse\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type = VOLTAGE_NONE;\r\nrdev->pm.power_state[state_index].pcie_lanes = 16;\r\nrdev->pm.power_state[state_index].flags = 0;\r\nrdev->pm.default_power_state_index = state_index;\r\nrdev->pm.num_power_states = state_index + 1;\r\nrdev->pm.current_power_state_index = rdev->pm.default_power_state_index;\r\nrdev->pm.current_clock_mode_index = 0;\r\nreturn;\r\npm_failed:\r\nrdev->pm.default_power_state_index = state_index;\r\nrdev->pm.num_power_states = 0;\r\nrdev->pm.current_power_state_index = rdev->pm.default_power_state_index;\r\nrdev->pm.current_clock_mode_index = 0;\r\n}\r\nvoid radeon_external_tmds_setup(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_ext_tmds *tmds = radeon_encoder->enc_priv;\r\nif (!tmds)\r\nreturn;\r\nswitch (tmds->dvo_chip) {\r\ncase DVO_SIL164:\r\nradeon_i2c_put_byte(tmds->i2c_bus,\r\ntmds->slave_addr,\r\n0x08, 0x30);\r\nradeon_i2c_put_byte(tmds->i2c_bus,\r\ntmds->slave_addr,\r\n0x09, 0x00);\r\nradeon_i2c_put_byte(tmds->i2c_bus,\r\ntmds->slave_addr,\r\n0x0a, 0x90);\r\nradeon_i2c_put_byte(tmds->i2c_bus,\r\ntmds->slave_addr,\r\n0x0c, 0x89);\r\nradeon_i2c_put_byte(tmds->i2c_bus,\r\ntmds->slave_addr,\r\n0x08, 0x3b);\r\nbreak;\r\ncase DVO_SIL1178:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nbool radeon_combios_external_tmds_setup(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nuint16_t offset;\r\nuint8_t blocks, slave_addr, rev;\r\nuint32_t index, id;\r\nuint32_t reg, val, and_mask, or_mask;\r\nstruct radeon_encoder_ext_tmds *tmds = radeon_encoder->enc_priv;\r\nif (!tmds)\r\nreturn false;\r\nif (rdev->flags & RADEON_IS_IGP) {\r\noffset = combios_get_table_offset(dev, COMBIOS_TMDS_POWER_ON_TABLE);\r\nrev = RBIOS8(offset);\r\nif (offset) {\r\nrev = RBIOS8(offset);\r\nif (rev > 1) {\r\nblocks = RBIOS8(offset + 3);\r\nindex = offset + 4;\r\nwhile (blocks > 0) {\r\nid = RBIOS16(index);\r\nindex += 2;\r\nswitch (id >> 13) {\r\ncase 0:\r\nreg = (id & 0x1fff) * 4;\r\nval = RBIOS32(index);\r\nindex += 4;\r\nWREG32(reg, val);\r\nbreak;\r\ncase 2:\r\nreg = (id & 0x1fff) * 4;\r\nand_mask = RBIOS32(index);\r\nindex += 4;\r\nor_mask = RBIOS32(index);\r\nindex += 4;\r\nval = RREG32(reg);\r\nval = (val & and_mask) | or_mask;\r\nWREG32(reg, val);\r\nbreak;\r\ncase 3:\r\nval = RBIOS16(index);\r\nindex += 2;\r\nudelay(val);\r\nbreak;\r\ncase 4:\r\nval = RBIOS16(index);\r\nindex += 2;\r\nmdelay(val);\r\nbreak;\r\ncase 6:\r\nslave_addr = id & 0xff;\r\nslave_addr >>= 1;\r\nindex++;\r\nreg = RBIOS8(index);\r\nindex++;\r\nval = RBIOS8(index);\r\nindex++;\r\nradeon_i2c_put_byte(tmds->i2c_bus,\r\nslave_addr,\r\nreg, val);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown id %d\n", id >> 13);\r\nbreak;\r\n}\r\nblocks--;\r\n}\r\nreturn true;\r\n}\r\n}\r\n} else {\r\noffset = combios_get_table_offset(dev, COMBIOS_EXT_TMDS_INFO_TABLE);\r\nif (offset) {\r\nindex = offset + 10;\r\nid = RBIOS16(index);\r\nwhile (id != 0xffff) {\r\nindex += 2;\r\nswitch (id >> 13) {\r\ncase 0:\r\nreg = (id & 0x1fff) * 4;\r\nval = RBIOS32(index);\r\nWREG32(reg, val);\r\nbreak;\r\ncase 2:\r\nreg = (id & 0x1fff) * 4;\r\nand_mask = RBIOS32(index);\r\nindex += 4;\r\nor_mask = RBIOS32(index);\r\nindex += 4;\r\nval = RREG32(reg);\r\nval = (val & and_mask) | or_mask;\r\nWREG32(reg, val);\r\nbreak;\r\ncase 4:\r\nval = RBIOS16(index);\r\nindex += 2;\r\nudelay(val);\r\nbreak;\r\ncase 5:\r\nreg = id & 0x1fff;\r\nand_mask = RBIOS32(index);\r\nindex += 4;\r\nor_mask = RBIOS32(index);\r\nindex += 4;\r\nval = RREG32_PLL(reg);\r\nval = (val & and_mask) | or_mask;\r\nWREG32_PLL(reg, val);\r\nbreak;\r\ncase 6:\r\nreg = id & 0x1fff;\r\nval = RBIOS8(index);\r\nindex += 1;\r\nradeon_i2c_put_byte(tmds->i2c_bus,\r\ntmds->slave_addr,\r\nreg, val);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown id %d\n", id >> 13);\r\nbreak;\r\n}\r\nid = RBIOS16(index);\r\n}\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void combios_parse_mmio_table(struct drm_device *dev, uint16_t offset)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (offset) {\r\nwhile (RBIOS16(offset)) {\r\nuint16_t cmd = ((RBIOS16(offset) & 0xe000) >> 13);\r\nuint32_t addr = (RBIOS16(offset) & 0x1fff);\r\nuint32_t val, and_mask, or_mask;\r\nuint32_t tmp;\r\noffset += 2;\r\nswitch (cmd) {\r\ncase 0:\r\nval = RBIOS32(offset);\r\noffset += 4;\r\nWREG32(addr, val);\r\nbreak;\r\ncase 1:\r\nval = RBIOS32(offset);\r\noffset += 4;\r\nWREG32(addr, val);\r\nbreak;\r\ncase 2:\r\nand_mask = RBIOS32(offset);\r\noffset += 4;\r\nor_mask = RBIOS32(offset);\r\noffset += 4;\r\ntmp = RREG32(addr);\r\ntmp &= and_mask;\r\ntmp |= or_mask;\r\nWREG32(addr, tmp);\r\nbreak;\r\ncase 3:\r\nand_mask = RBIOS32(offset);\r\noffset += 4;\r\nor_mask = RBIOS32(offset);\r\noffset += 4;\r\ntmp = RREG32(addr);\r\ntmp &= and_mask;\r\ntmp |= or_mask;\r\nWREG32(addr, tmp);\r\nbreak;\r\ncase 4:\r\nval = RBIOS16(offset);\r\noffset += 2;\r\nudelay(val);\r\nbreak;\r\ncase 5:\r\nval = RBIOS16(offset);\r\noffset += 2;\r\nswitch (addr) {\r\ncase 8:\r\nwhile (val--) {\r\nif (!\r\n(RREG32_PLL\r\n(RADEON_CLK_PWRMGT_CNTL) &\r\nRADEON_MC_BUSY))\r\nbreak;\r\n}\r\nbreak;\r\ncase 9:\r\nwhile (val--) {\r\nif ((RREG32(RADEON_MC_STATUS) &\r\nRADEON_MC_IDLE))\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void combios_parse_pll_table(struct drm_device *dev, uint16_t offset)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (offset) {\r\nwhile (RBIOS8(offset)) {\r\nuint8_t cmd = ((RBIOS8(offset) & 0xc0) >> 6);\r\nuint8_t addr = (RBIOS8(offset) & 0x3f);\r\nuint32_t val, shift, tmp;\r\nuint32_t and_mask, or_mask;\r\noffset++;\r\nswitch (cmd) {\r\ncase 0:\r\nval = RBIOS32(offset);\r\noffset += 4;\r\nWREG32_PLL(addr, val);\r\nbreak;\r\ncase 1:\r\nshift = RBIOS8(offset) * 8;\r\noffset++;\r\nand_mask = RBIOS8(offset) << shift;\r\nand_mask |= ~(0xff << shift);\r\noffset++;\r\nor_mask = RBIOS8(offset) << shift;\r\noffset++;\r\ntmp = RREG32_PLL(addr);\r\ntmp &= and_mask;\r\ntmp |= or_mask;\r\nWREG32_PLL(addr, tmp);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ntmp = 1000;\r\nswitch (addr) {\r\ncase 1:\r\nudelay(150);\r\nbreak;\r\ncase 2:\r\nmdelay(1);\r\nbreak;\r\ncase 3:\r\nwhile (tmp--) {\r\nif (!\r\n(RREG32_PLL\r\n(RADEON_CLK_PWRMGT_CNTL) &\r\nRADEON_MC_BUSY))\r\nbreak;\r\n}\r\nbreak;\r\ncase 4:\r\nwhile (tmp--) {\r\nif (RREG32_PLL\r\n(RADEON_CLK_PWRMGT_CNTL) &\r\nRADEON_DLL_READY)\r\nbreak;\r\n}\r\nbreak;\r\ncase 5:\r\ntmp =\r\nRREG32_PLL(RADEON_CLK_PWRMGT_CNTL);\r\nif (tmp & RADEON_CG_NO1_DEBUG_0) {\r\n#if 0\r\nuint32_t mclk_cntl =\r\nRREG32_PLL\r\n(RADEON_MCLK_CNTL);\r\nmclk_cntl &= 0xffff0000;\r\nWREG32_PLL(RADEON_MCLK_CNTL,\r\nmclk_cntl);\r\nmdelay(10);\r\n#endif\r\nWREG32_PLL\r\n(RADEON_CLK_PWRMGT_CNTL,\r\ntmp &\r\n~RADEON_CG_NO1_DEBUG_0);\r\nmdelay(10);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void combios_parse_ram_reset_table(struct drm_device *dev,\r\nuint16_t offset)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t tmp;\r\nif (offset) {\r\nuint8_t val = RBIOS8(offset);\r\nwhile (val != 0xff) {\r\noffset++;\r\nif (val == 0x0f) {\r\nuint32_t channel_complete_mask;\r\nif (ASIC_IS_R300(rdev))\r\nchannel_complete_mask =\r\nR300_MEM_PWRUP_COMPLETE;\r\nelse\r\nchannel_complete_mask =\r\nRADEON_MEM_PWRUP_COMPLETE;\r\ntmp = 20000;\r\nwhile (tmp--) {\r\nif ((RREG32(RADEON_MEM_STR_CNTL) &\r\nchannel_complete_mask) ==\r\nchannel_complete_mask)\r\nbreak;\r\n}\r\n} else {\r\nuint32_t or_mask = RBIOS16(offset);\r\noffset += 2;\r\ntmp = RREG32(RADEON_MEM_SDRAM_MODE_REG);\r\ntmp &= RADEON_SDRAM_MODE_MASK;\r\ntmp |= or_mask;\r\nWREG32(RADEON_MEM_SDRAM_MODE_REG, tmp);\r\nor_mask = val << 24;\r\ntmp = RREG32(RADEON_MEM_SDRAM_MODE_REG);\r\ntmp &= RADEON_B3MEM_RESET_MASK;\r\ntmp |= or_mask;\r\nWREG32(RADEON_MEM_SDRAM_MODE_REG, tmp);\r\n}\r\nval = RBIOS8(offset);\r\n}\r\n}\r\n}\r\nstatic uint32_t combios_detect_ram(struct drm_device *dev, int ram,\r\nint mem_addr_mapping)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t mem_cntl;\r\nuint32_t mem_size;\r\nuint32_t addr = 0;\r\nmem_cntl = RREG32(RADEON_MEM_CNTL);\r\nif (mem_cntl & RV100_HALF_MODE)\r\nram /= 2;\r\nmem_size = ram;\r\nmem_cntl &= ~(0xff << 8);\r\nmem_cntl |= (mem_addr_mapping & 0xff) << 8;\r\nWREG32(RADEON_MEM_CNTL, mem_cntl);\r\nRREG32(RADEON_MEM_CNTL);\r\nwhile (ram--) {\r\naddr = ram * 1024 * 1024;\r\nWREG32_IDX((addr) | RADEON_MM_APER, 0xdeadbeef);\r\nif (RREG32_IDX((addr) | RADEON_MM_APER) != 0xdeadbeef)\r\nreturn 0;\r\n}\r\nreturn mem_size;\r\n}\r\nstatic void combios_write_ram_size(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint8_t rev;\r\nuint16_t offset;\r\nuint32_t mem_size = 0;\r\nuint32_t mem_cntl = 0;\r\nif (rdev->flags & RADEON_IS_IGP)\r\nreturn;\r\noffset = combios_get_table_offset(dev, COMBIOS_DETECTED_MEM_TABLE);\r\nif (offset) {\r\nrev = RBIOS8(offset);\r\nif (rev < 3) {\r\nmem_cntl = RBIOS32(offset + 1);\r\nmem_size = RBIOS16(offset + 5);\r\nif ((rdev->family < CHIP_R200) &&\r\n!ASIC_IS_RN50(rdev))\r\nWREG32(RADEON_MEM_CNTL, mem_cntl);\r\n}\r\n}\r\nif (!mem_size) {\r\noffset =\r\ncombios_get_table_offset(dev, COMBIOS_MEM_CONFIG_TABLE);\r\nif (offset) {\r\nrev = RBIOS8(offset - 1);\r\nif (rev < 1) {\r\nif ((rdev->family < CHIP_R200)\r\n&& !ASIC_IS_RN50(rdev)) {\r\nint ram = 0;\r\nint mem_addr_mapping = 0;\r\nwhile (RBIOS8(offset)) {\r\nram = RBIOS8(offset);\r\nmem_addr_mapping =\r\nRBIOS8(offset + 1);\r\nif (mem_addr_mapping != 0x25)\r\nram *= 2;\r\nmem_size =\r\ncombios_detect_ram(dev, ram,\r\nmem_addr_mapping);\r\nif (mem_size)\r\nbreak;\r\noffset += 2;\r\n}\r\n} else\r\nmem_size = RBIOS8(offset);\r\n} else {\r\nmem_size = RBIOS8(offset);\r\nmem_size *= 2;\r\n}\r\n}\r\n}\r\nmem_size *= (1024 * 1024);\r\nWREG32(RADEON_CONFIG_MEMSIZE, mem_size);\r\n}\r\nvoid radeon_combios_asic_init(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint16_t table;\r\nif (rdev->bios == NULL)\r\nreturn;\r\ntable = combios_get_table_offset(dev, COMBIOS_ASIC_INIT_1_TABLE);\r\nif (table)\r\ncombios_parse_mmio_table(dev, table);\r\ntable = combios_get_table_offset(dev, COMBIOS_PLL_INIT_TABLE);\r\nif (table)\r\ncombios_parse_pll_table(dev, table);\r\ntable = combios_get_table_offset(dev, COMBIOS_ASIC_INIT_2_TABLE);\r\nif (table)\r\ncombios_parse_mmio_table(dev, table);\r\nif (!(rdev->flags & RADEON_IS_IGP)) {\r\ntable =\r\ncombios_get_table_offset(dev, COMBIOS_ASIC_INIT_4_TABLE);\r\nif (table)\r\ncombios_parse_mmio_table(dev, table);\r\ntable = combios_get_table_offset(dev, COMBIOS_RAM_RESET_TABLE);\r\nif (table)\r\ncombios_parse_ram_reset_table(dev, table);\r\ntable =\r\ncombios_get_table_offset(dev, COMBIOS_ASIC_INIT_3_TABLE);\r\nif (table)\r\ncombios_parse_mmio_table(dev, table);\r\ncombios_write_ram_size(dev);\r\n}\r\nif (rdev->family == CHIP_RS480 &&\r\nrdev->pdev->subsystem_vendor == 0x103c &&\r\nrdev->pdev->subsystem_device == 0x308b)\r\nreturn;\r\nif (rdev->family == CHIP_RS480 &&\r\nrdev->pdev->subsystem_vendor == 0x103c &&\r\nrdev->pdev->subsystem_device == 0x30a4)\r\nreturn;\r\nif (rdev->family == CHIP_RS480 &&\r\nrdev->pdev->subsystem_vendor == 0x103c &&\r\nrdev->pdev->subsystem_device == 0x30ae)\r\nreturn;\r\nif (rdev->family == CHIP_RS480 &&\r\nrdev->pdev->subsystem_vendor == 0x103c &&\r\nrdev->pdev->subsystem_device == 0x280a)\r\nreturn;\r\ntable = combios_get_table_offset(dev, COMBIOS_DYN_CLK_1_TABLE);\r\nif (table)\r\ncombios_parse_pll_table(dev, table);\r\n}\r\nvoid radeon_combios_initialize_bios_scratch_regs(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t bios_0_scratch, bios_6_scratch, bios_7_scratch;\r\nbios_0_scratch = RREG32(RADEON_BIOS_0_SCRATCH);\r\nbios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);\r\nbios_7_scratch = RREG32(RADEON_BIOS_7_SCRATCH);\r\nbios_0_scratch &= ~RADEON_DRIVER_BRIGHTNESS_EN;\r\nbios_6_scratch |= (RADEON_DISPLAY_SWITCHING_DIS |\r\nRADEON_ACC_MODE_CHANGE);\r\nbios_7_scratch |= RADEON_DRV_LOADED;\r\nWREG32(RADEON_BIOS_0_SCRATCH, bios_0_scratch);\r\nWREG32(RADEON_BIOS_6_SCRATCH, bios_6_scratch);\r\nWREG32(RADEON_BIOS_7_SCRATCH, bios_7_scratch);\r\n}\r\nvoid radeon_combios_output_lock(struct drm_encoder *encoder, bool lock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t bios_6_scratch;\r\nbios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);\r\nif (lock)\r\nbios_6_scratch |= RADEON_DRIVER_CRITICAL;\r\nelse\r\nbios_6_scratch &= ~RADEON_DRIVER_CRITICAL;\r\nWREG32(RADEON_BIOS_6_SCRATCH, bios_6_scratch);\r\n}\r\nvoid\r\nradeon_combios_connected_scratch_regs(struct drm_connector *connector,\r\nstruct drm_encoder *encoder,\r\nbool connected)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector =\r\nto_radeon_connector(connector);\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nuint32_t bios_4_scratch = RREG32(RADEON_BIOS_4_SCRATCH);\r\nuint32_t bios_5_scratch = RREG32(RADEON_BIOS_5_SCRATCH);\r\nif ((radeon_encoder->devices & ATOM_DEVICE_TV1_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_TV1_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("TV1 connected\n");\r\nbios_4_scratch |= RADEON_TV1_ATTACHED_SVIDEO;\r\nbios_5_scratch |= RADEON_TV1_ON;\r\nbios_5_scratch |= RADEON_ACC_REQ_TV1;\r\n} else {\r\nDRM_DEBUG_KMS("TV1 disconnected\n");\r\nbios_4_scratch &= ~RADEON_TV1_ATTACHED_MASK;\r\nbios_5_scratch &= ~RADEON_TV1_ON;\r\nbios_5_scratch &= ~RADEON_ACC_REQ_TV1;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_LCD1_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("LCD1 connected\n");\r\nbios_4_scratch |= RADEON_LCD1_ATTACHED;\r\nbios_5_scratch |= RADEON_LCD1_ON;\r\nbios_5_scratch |= RADEON_ACC_REQ_LCD1;\r\n} else {\r\nDRM_DEBUG_KMS("LCD1 disconnected\n");\r\nbios_4_scratch &= ~RADEON_LCD1_ATTACHED;\r\nbios_5_scratch &= ~RADEON_LCD1_ON;\r\nbios_5_scratch &= ~RADEON_ACC_REQ_LCD1;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_CRT1_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_CRT1_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("CRT1 connected\n");\r\nbios_4_scratch |= RADEON_CRT1_ATTACHED_COLOR;\r\nbios_5_scratch |= RADEON_CRT1_ON;\r\nbios_5_scratch |= RADEON_ACC_REQ_CRT1;\r\n} else {\r\nDRM_DEBUG_KMS("CRT1 disconnected\n");\r\nbios_4_scratch &= ~RADEON_CRT1_ATTACHED_MASK;\r\nbios_5_scratch &= ~RADEON_CRT1_ON;\r\nbios_5_scratch &= ~RADEON_ACC_REQ_CRT1;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_CRT2_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_CRT2_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("CRT2 connected\n");\r\nbios_4_scratch |= RADEON_CRT2_ATTACHED_COLOR;\r\nbios_5_scratch |= RADEON_CRT2_ON;\r\nbios_5_scratch |= RADEON_ACC_REQ_CRT2;\r\n} else {\r\nDRM_DEBUG_KMS("CRT2 disconnected\n");\r\nbios_4_scratch &= ~RADEON_CRT2_ATTACHED_MASK;\r\nbios_5_scratch &= ~RADEON_CRT2_ON;\r\nbios_5_scratch &= ~RADEON_ACC_REQ_CRT2;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_DFP1_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_DFP1_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("DFP1 connected\n");\r\nbios_4_scratch |= RADEON_DFP1_ATTACHED;\r\nbios_5_scratch |= RADEON_DFP1_ON;\r\nbios_5_scratch |= RADEON_ACC_REQ_DFP1;\r\n} else {\r\nDRM_DEBUG_KMS("DFP1 disconnected\n");\r\nbios_4_scratch &= ~RADEON_DFP1_ATTACHED;\r\nbios_5_scratch &= ~RADEON_DFP1_ON;\r\nbios_5_scratch &= ~RADEON_ACC_REQ_DFP1;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_DFP2_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_DFP2_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("DFP2 connected\n");\r\nbios_4_scratch |= RADEON_DFP2_ATTACHED;\r\nbios_5_scratch |= RADEON_DFP2_ON;\r\nbios_5_scratch |= RADEON_ACC_REQ_DFP2;\r\n} else {\r\nDRM_DEBUG_KMS("DFP2 disconnected\n");\r\nbios_4_scratch &= ~RADEON_DFP2_ATTACHED;\r\nbios_5_scratch &= ~RADEON_DFP2_ON;\r\nbios_5_scratch &= ~RADEON_ACC_REQ_DFP2;\r\n}\r\n}\r\nWREG32(RADEON_BIOS_4_SCRATCH, bios_4_scratch);\r\nWREG32(RADEON_BIOS_5_SCRATCH, bios_5_scratch);\r\n}\r\nvoid\r\nradeon_combios_encoder_crtc_scratch_regs(struct drm_encoder *encoder, int crtc)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nuint32_t bios_5_scratch = RREG32(RADEON_BIOS_5_SCRATCH);\r\nif (radeon_encoder->devices & ATOM_DEVICE_TV1_SUPPORT) {\r\nbios_5_scratch &= ~RADEON_TV1_CRTC_MASK;\r\nbios_5_scratch |= (crtc << RADEON_TV1_CRTC_SHIFT);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_CRT1_SUPPORT) {\r\nbios_5_scratch &= ~RADEON_CRT1_CRTC_MASK;\r\nbios_5_scratch |= (crtc << RADEON_CRT1_CRTC_SHIFT);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_CRT2_SUPPORT) {\r\nbios_5_scratch &= ~RADEON_CRT2_CRTC_MASK;\r\nbios_5_scratch |= (crtc << RADEON_CRT2_CRTC_SHIFT);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT) {\r\nbios_5_scratch &= ~RADEON_LCD1_CRTC_MASK;\r\nbios_5_scratch |= (crtc << RADEON_LCD1_CRTC_SHIFT);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_DFP1_SUPPORT) {\r\nbios_5_scratch &= ~RADEON_DFP1_CRTC_MASK;\r\nbios_5_scratch |= (crtc << RADEON_DFP1_CRTC_SHIFT);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_DFP2_SUPPORT) {\r\nbios_5_scratch &= ~RADEON_DFP2_CRTC_MASK;\r\nbios_5_scratch |= (crtc << RADEON_DFP2_CRTC_SHIFT);\r\n}\r\nWREG32(RADEON_BIOS_5_SCRATCH, bios_5_scratch);\r\n}\r\nvoid\r\nradeon_combios_encoder_dpms_scratch_regs(struct drm_encoder *encoder, bool on)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nuint32_t bios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);\r\nif (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT)) {\r\nif (on)\r\nbios_6_scratch |= RADEON_TV_DPMS_ON;\r\nelse\r\nbios_6_scratch &= ~RADEON_TV_DPMS_ON;\r\n}\r\nif (radeon_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT)) {\r\nif (on)\r\nbios_6_scratch |= RADEON_CRT_DPMS_ON;\r\nelse\r\nbios_6_scratch &= ~RADEON_CRT_DPMS_ON;\r\n}\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nif (on)\r\nbios_6_scratch |= RADEON_LCD_DPMS_ON;\r\nelse\r\nbios_6_scratch &= ~RADEON_LCD_DPMS_ON;\r\n}\r\nif (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\r\nif (on)\r\nbios_6_scratch |= RADEON_DFP_DPMS_ON;\r\nelse\r\nbios_6_scratch &= ~RADEON_DFP_DPMS_ON;\r\n}\r\nWREG32(RADEON_BIOS_6_SCRATCH, bios_6_scratch);\r\n}
