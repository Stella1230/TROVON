static unsigned int etb_get_buffer_depth(struct etb_drvdata *drvdata)\r\n{\r\nu32 depth = 0;\r\npm_runtime_get_sync(drvdata->dev);\r\ndepth = readl_relaxed(drvdata->base + ETB_RAM_DEPTH_REG);\r\npm_runtime_put(drvdata->dev);\r\nreturn depth;\r\n}\r\nstatic void etb_enable_hw(struct etb_drvdata *drvdata)\r\n{\r\nint i;\r\nu32 depth;\r\nCS_UNLOCK(drvdata->base);\r\ndepth = drvdata->buffer_depth;\r\nwritel_relaxed(0x0, drvdata->base + ETB_RAM_WRITE_POINTER);\r\nfor (i = 0; i < depth; i++)\r\nwritel_relaxed(0x0, drvdata->base + ETB_RWD_REG);\r\nwritel_relaxed(0x0, drvdata->base + ETB_RAM_WRITE_POINTER);\r\nwritel_relaxed(0x0, drvdata->base + ETB_RAM_READ_POINTER);\r\nwritel_relaxed(drvdata->trigger_cntr, drvdata->base + ETB_TRG);\r\nwritel_relaxed(ETB_FFCR_EN_FTC | ETB_FFCR_STOP_TRIGGER,\r\ndrvdata->base + ETB_FFCR);\r\nwritel_relaxed(ETB_CTL_CAPT_EN, drvdata->base + ETB_CTL_REG);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic int etb_enable(struct coresight_device *csdev, u32 mode)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nstruct etb_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nval = local_cmpxchg(&drvdata->mode,\r\nCS_MODE_DISABLED, mode);\r\nif (val == CS_MODE_PERF)\r\nreturn -EBUSY;\r\nif (val == CS_MODE_SYSFS)\r\ngoto out;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\netb_enable_hw(drvdata);\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nout:\r\ndev_info(drvdata->dev, "ETB enabled\n");\r\nreturn 0;\r\n}\r\nstatic void etb_disable_hw(struct etb_drvdata *drvdata)\r\n{\r\nu32 ffcr;\r\nCS_UNLOCK(drvdata->base);\r\nffcr = readl_relaxed(drvdata->base + ETB_FFCR);\r\nffcr |= ETB_FFCR_STOP_FI;\r\nwritel_relaxed(ffcr, drvdata->base + ETB_FFCR);\r\nffcr |= ETB_FFCR_FON_MAN;\r\nwritel_relaxed(ffcr, drvdata->base + ETB_FFCR);\r\nif (coresight_timeout(drvdata->base, ETB_FFCR, ETB_FFCR_BIT, 0)) {\r\ndev_err(drvdata->dev,\r\n"timeout observed when probing at offset %#x\n",\r\nETB_FFCR);\r\n}\r\nwritel_relaxed(0x0, drvdata->base + ETB_CTL_REG);\r\nif (coresight_timeout(drvdata->base, ETB_FFSR, ETB_FFSR_BIT, 1)) {\r\ndev_err(drvdata->dev,\r\n"timeout observed when probing at offset %#x\n",\r\nETB_FFCR);\r\n}\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void etb_dump_hw(struct etb_drvdata *drvdata)\r\n{\r\nint i;\r\nu8 *buf_ptr;\r\nu32 read_data, depth;\r\nu32 read_ptr, write_ptr;\r\nu32 frame_off, frame_endoff;\r\nCS_UNLOCK(drvdata->base);\r\nread_ptr = readl_relaxed(drvdata->base + ETB_RAM_READ_POINTER);\r\nwrite_ptr = readl_relaxed(drvdata->base + ETB_RAM_WRITE_POINTER);\r\nframe_off = write_ptr % ETB_FRAME_SIZE_WORDS;\r\nframe_endoff = ETB_FRAME_SIZE_WORDS - frame_off;\r\nif (frame_off) {\r\ndev_err(drvdata->dev,\r\n"write_ptr: %lu not aligned to formatter frame size\n",\r\n(unsigned long)write_ptr);\r\ndev_err(drvdata->dev, "frameoff: %lu, frame_endoff: %lu\n",\r\n(unsigned long)frame_off, (unsigned long)frame_endoff);\r\nwrite_ptr += frame_endoff;\r\n}\r\nif ((readl_relaxed(drvdata->base + ETB_STATUS_REG)\r\n& ETB_STATUS_RAM_FULL) == 0)\r\nwritel_relaxed(0x0, drvdata->base + ETB_RAM_READ_POINTER);\r\nelse\r\nwritel_relaxed(write_ptr, drvdata->base + ETB_RAM_READ_POINTER);\r\ndepth = drvdata->buffer_depth;\r\nbuf_ptr = drvdata->buf;\r\nfor (i = 0; i < depth; i++) {\r\nread_data = readl_relaxed(drvdata->base +\r\nETB_RAM_READ_DATA_REG);\r\n*buf_ptr++ = read_data >> 0;\r\n*buf_ptr++ = read_data >> 8;\r\n*buf_ptr++ = read_data >> 16;\r\n*buf_ptr++ = read_data >> 24;\r\n}\r\nif (frame_off) {\r\nbuf_ptr -= (frame_endoff * 4);\r\nfor (i = 0; i < frame_endoff; i++) {\r\n*buf_ptr++ = 0x0;\r\n*buf_ptr++ = 0x0;\r\n*buf_ptr++ = 0x0;\r\n*buf_ptr++ = 0x0;\r\n}\r\n}\r\nwritel_relaxed(read_ptr, drvdata->base + ETB_RAM_READ_POINTER);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void etb_disable(struct coresight_device *csdev)\r\n{\r\nstruct etb_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nunsigned long flags;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\netb_disable_hw(drvdata);\r\netb_dump_hw(drvdata);\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nlocal_set(&drvdata->mode, CS_MODE_DISABLED);\r\ndev_info(drvdata->dev, "ETB disabled\n");\r\n}\r\nstatic void *etb_alloc_buffer(struct coresight_device *csdev, int cpu,\r\nvoid **pages, int nr_pages, bool overwrite)\r\n{\r\nint node;\r\nstruct cs_buffers *buf;\r\nif (cpu == -1)\r\ncpu = smp_processor_id();\r\nnode = cpu_to_node(cpu);\r\nbuf = kzalloc_node(sizeof(struct cs_buffers), GFP_KERNEL, node);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->snapshot = overwrite;\r\nbuf->nr_pages = nr_pages;\r\nbuf->data_pages = pages;\r\nreturn buf;\r\n}\r\nstatic void etb_free_buffer(void *config)\r\n{\r\nstruct cs_buffers *buf = config;\r\nkfree(buf);\r\n}\r\nstatic int etb_set_buffer(struct coresight_device *csdev,\r\nstruct perf_output_handle *handle,\r\nvoid *sink_config)\r\n{\r\nint ret = 0;\r\nunsigned long head;\r\nstruct cs_buffers *buf = sink_config;\r\nhead = handle->head & ((buf->nr_pages << PAGE_SHIFT) - 1);\r\nbuf->cur = head / PAGE_SIZE;\r\nbuf->offset = head % PAGE_SIZE;\r\nlocal_set(&buf->data_size, 0);\r\nreturn ret;\r\n}\r\nstatic unsigned long etb_reset_buffer(struct coresight_device *csdev,\r\nstruct perf_output_handle *handle,\r\nvoid *sink_config, bool *lost)\r\n{\r\nunsigned long size = 0;\r\nstruct cs_buffers *buf = sink_config;\r\nif (buf) {\r\nif (buf->snapshot)\r\nhandle->head = local_xchg(&buf->data_size,\r\nbuf->nr_pages << PAGE_SHIFT);\r\n*lost = !!local_xchg(&buf->lost, 0);\r\nsize = local_xchg(&buf->data_size, 0);\r\n}\r\nreturn size;\r\n}\r\nstatic void etb_update_buffer(struct coresight_device *csdev,\r\nstruct perf_output_handle *handle,\r\nvoid *sink_config)\r\n{\r\nint i, cur;\r\nu8 *buf_ptr;\r\nu32 read_ptr, write_ptr, capacity;\r\nu32 status, read_data, to_read;\r\nunsigned long offset;\r\nstruct cs_buffers *buf = sink_config;\r\nstruct etb_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nif (!buf)\r\nreturn;\r\ncapacity = drvdata->buffer_depth * ETB_FRAME_SIZE_WORDS;\r\nCS_UNLOCK(drvdata->base);\r\netb_disable_hw(drvdata);\r\nread_ptr = readl_relaxed(drvdata->base + ETB_RAM_READ_POINTER);\r\nwrite_ptr = readl_relaxed(drvdata->base + ETB_RAM_WRITE_POINTER);\r\nif (write_ptr % ETB_FRAME_SIZE_WORDS) {\r\ndev_err(drvdata->dev,\r\n"write_ptr: %lu not aligned to formatter frame size\n",\r\n(unsigned long)write_ptr);\r\nwrite_ptr &= ~(ETB_FRAME_SIZE_WORDS - 1);\r\nlocal_inc(&buf->lost);\r\n}\r\nstatus = readl_relaxed(drvdata->base + ETB_STATUS_REG);\r\nif (status & ETB_STATUS_RAM_FULL) {\r\nlocal_inc(&buf->lost);\r\nto_read = capacity;\r\nread_ptr = write_ptr;\r\n} else {\r\nto_read = CIRC_CNT(write_ptr, read_ptr, drvdata->buffer_depth);\r\nto_read *= ETB_FRAME_SIZE_WORDS;\r\n}\r\nif (!buf->snapshot && to_read > handle->size) {\r\nu32 mask = ~(ETB_FRAME_SIZE_WORDS - 1);\r\nto_read = handle->size & mask;\r\nread_ptr = (write_ptr + drvdata->buffer_depth) -\r\nto_read / ETB_FRAME_SIZE_WORDS;\r\nif (read_ptr > (drvdata->buffer_depth - 1))\r\nread_ptr -= drvdata->buffer_depth;\r\nlocal_inc(&buf->lost);\r\n}\r\nwritel_relaxed(read_ptr, drvdata->base + ETB_RAM_READ_POINTER);\r\ncur = buf->cur;\r\noffset = buf->offset;\r\nfor (i = 0; i < to_read; i += 4) {\r\nbuf_ptr = buf->data_pages[cur] + offset;\r\nread_data = readl_relaxed(drvdata->base +\r\nETB_RAM_READ_DATA_REG);\r\n*buf_ptr++ = read_data >> 0;\r\n*buf_ptr++ = read_data >> 8;\r\n*buf_ptr++ = read_data >> 16;\r\n*buf_ptr++ = read_data >> 24;\r\noffset += 4;\r\nif (offset >= PAGE_SIZE) {\r\noffset = 0;\r\ncur++;\r\ncur &= buf->nr_pages - 1;\r\n}\r\n}\r\nwritel_relaxed(0x0, drvdata->base + ETB_RAM_READ_POINTER);\r\nwritel_relaxed(0x0, drvdata->base + ETB_RAM_WRITE_POINTER);\r\nif (buf->snapshot)\r\nlocal_set(&buf->data_size, (cur * PAGE_SIZE) + offset);\r\nelse\r\nlocal_add(to_read, &buf->data_size);\r\netb_enable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void etb_dump(struct etb_drvdata *drvdata)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (local_read(&drvdata->mode) == CS_MODE_SYSFS) {\r\netb_disable_hw(drvdata);\r\netb_dump_hw(drvdata);\r\netb_enable_hw(drvdata);\r\n}\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\ndev_info(drvdata->dev, "ETB dumped\n");\r\n}\r\nstatic int etb_open(struct inode *inode, struct file *file)\r\n{\r\nstruct etb_drvdata *drvdata = container_of(file->private_data,\r\nstruct etb_drvdata, miscdev);\r\nif (local_cmpxchg(&drvdata->reading, 0, 1))\r\nreturn -EBUSY;\r\ndev_dbg(drvdata->dev, "%s: successfully opened\n", __func__);\r\nreturn 0;\r\n}\r\nstatic ssize_t etb_read(struct file *file, char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nu32 depth;\r\nstruct etb_drvdata *drvdata = container_of(file->private_data,\r\nstruct etb_drvdata, miscdev);\r\netb_dump(drvdata);\r\ndepth = drvdata->buffer_depth;\r\nif (*ppos + len > depth * 4)\r\nlen = depth * 4 - *ppos;\r\nif (copy_to_user(data, drvdata->buf + *ppos, len)) {\r\ndev_dbg(drvdata->dev, "%s: copy_to_user failed\n", __func__);\r\nreturn -EFAULT;\r\n}\r\n*ppos += len;\r\ndev_dbg(drvdata->dev, "%s: %zu bytes copied, %d bytes left\n",\r\n__func__, len, (int)(depth * 4 - *ppos));\r\nreturn len;\r\n}\r\nstatic int etb_release(struct inode *inode, struct file *file)\r\n{\r\nstruct etb_drvdata *drvdata = container_of(file->private_data,\r\nstruct etb_drvdata, miscdev);\r\nlocal_set(&drvdata->reading, 0);\r\ndev_dbg(drvdata->dev, "%s: released\n", __func__);\r\nreturn 0;\r\n}\r\nstatic ssize_t trigger_cntr_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct etb_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nunsigned long val = drvdata->trigger_cntr;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t trigger_cntr_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etb_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->trigger_cntr = val;\r\nreturn size;\r\n}\r\nstatic int etb_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint ret;\r\nvoid __iomem *base;\r\nstruct device *dev = &adev->dev;\r\nstruct coresight_platform_data *pdata = NULL;\r\nstruct etb_drvdata *drvdata;\r\nstruct resource *res = &adev->res;\r\nstruct coresight_desc *desc;\r\nstruct device_node *np = adev->dev.of_node;\r\nif (np) {\r\npdata = of_get_coresight_platform_data(dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nadev->dev.platform_data = pdata;\r\n}\r\ndrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\ndrvdata->dev = &adev->dev;\r\ndrvdata->atclk = devm_clk_get(&adev->dev, "atclk");\r\nif (!IS_ERR(drvdata->atclk)) {\r\nret = clk_prepare_enable(drvdata->atclk);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndev_set_drvdata(dev, drvdata);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndrvdata->base = base;\r\nspin_lock_init(&drvdata->spinlock);\r\ndrvdata->buffer_depth = etb_get_buffer_depth(drvdata);\r\npm_runtime_put(&adev->dev);\r\nif (drvdata->buffer_depth & 0x80000000)\r\nreturn -EINVAL;\r\ndrvdata->buf = devm_kzalloc(dev,\r\ndrvdata->buffer_depth * 4, GFP_KERNEL);\r\nif (!drvdata->buf) {\r\ndev_err(dev, "Failed to allocate %u bytes for buffer data\n",\r\ndrvdata->buffer_depth * 4);\r\nreturn -ENOMEM;\r\n}\r\ndesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ndesc->type = CORESIGHT_DEV_TYPE_SINK;\r\ndesc->subtype.sink_subtype = CORESIGHT_DEV_SUBTYPE_SINK_BUFFER;\r\ndesc->ops = &etb_cs_ops;\r\ndesc->pdata = pdata;\r\ndesc->dev = dev;\r\ndesc->groups = coresight_etb_groups;\r\ndrvdata->csdev = coresight_register(desc);\r\nif (IS_ERR(drvdata->csdev))\r\nreturn PTR_ERR(drvdata->csdev);\r\ndrvdata->miscdev.name = pdata->name;\r\ndrvdata->miscdev.minor = MISC_DYNAMIC_MINOR;\r\ndrvdata->miscdev.fops = &etb_fops;\r\nret = misc_register(&drvdata->miscdev);\r\nif (ret)\r\ngoto err_misc_register;\r\nreturn 0;\r\nerr_misc_register:\r\ncoresight_unregister(drvdata->csdev);\r\nreturn ret;\r\n}\r\nstatic int etb_runtime_suspend(struct device *dev)\r\n{\r\nstruct etb_drvdata *drvdata = dev_get_drvdata(dev);\r\nif (drvdata && !IS_ERR(drvdata->atclk))\r\nclk_disable_unprepare(drvdata->atclk);\r\nreturn 0;\r\n}\r\nstatic int etb_runtime_resume(struct device *dev)\r\n{\r\nstruct etb_drvdata *drvdata = dev_get_drvdata(dev);\r\nif (drvdata && !IS_ERR(drvdata->atclk))\r\nclk_prepare_enable(drvdata->atclk);\r\nreturn 0;\r\n}
