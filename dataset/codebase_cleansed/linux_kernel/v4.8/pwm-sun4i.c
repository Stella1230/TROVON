static inline struct sun4i_pwm_chip *to_sun4i_pwm_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct sun4i_pwm_chip, chip);\r\n}\r\nstatic inline u32 sun4i_pwm_readl(struct sun4i_pwm_chip *chip,\r\nunsigned long offset)\r\n{\r\nreturn readl(chip->base + offset);\r\n}\r\nstatic inline void sun4i_pwm_writel(struct sun4i_pwm_chip *chip,\r\nu32 val, unsigned long offset)\r\n{\r\nwritel(val, chip->base + offset);\r\n}\r\nstatic int sun4i_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct sun4i_pwm_chip *sun4i_pwm = to_sun4i_pwm_chip(chip);\r\nu32 prd, dty, val, clk_gate;\r\nu64 clk_rate, div = 0;\r\nunsigned int prescaler = 0;\r\nint err;\r\nclk_rate = clk_get_rate(sun4i_pwm->clk);\r\nif (sun4i_pwm->data->has_prescaler_bypass) {\r\nprescaler = PWM_PRESCAL_MASK;\r\ndiv = clk_rate * period_ns + NSEC_PER_SEC / 2;\r\ndo_div(div, NSEC_PER_SEC);\r\nif (div - 1 > PWM_PRD_MASK)\r\nprescaler = 0;\r\n}\r\nif (prescaler == 0) {\r\nfor (prescaler = 0; prescaler < PWM_PRESCAL_MASK; prescaler++) {\r\nif (!prescaler_table[prescaler])\r\ncontinue;\r\ndiv = clk_rate;\r\ndo_div(div, prescaler_table[prescaler]);\r\ndiv = div * period_ns;\r\ndo_div(div, NSEC_PER_SEC);\r\nif (div - 1 <= PWM_PRD_MASK)\r\nbreak;\r\n}\r\nif (div - 1 > PWM_PRD_MASK) {\r\ndev_err(chip->dev, "period exceeds the maximum value\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nprd = div;\r\ndiv *= duty_ns;\r\ndo_div(div, period_ns);\r\ndty = div;\r\nerr = clk_prepare_enable(sun4i_pwm->clk);\r\nif (err) {\r\ndev_err(chip->dev, "failed to enable PWM clock\n");\r\nreturn err;\r\n}\r\nspin_lock(&sun4i_pwm->ctrl_lock);\r\nval = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\r\nif (sun4i_pwm->data->has_rdy && (val & PWM_RDY(pwm->hwpwm))) {\r\nspin_unlock(&sun4i_pwm->ctrl_lock);\r\nclk_disable_unprepare(sun4i_pwm->clk);\r\nreturn -EBUSY;\r\n}\r\nclk_gate = val & BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\r\nif (clk_gate) {\r\nval &= ~BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\r\nsun4i_pwm_writel(sun4i_pwm, val, PWM_CTRL_REG);\r\n}\r\nval = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\r\nval &= ~BIT_CH(PWM_PRESCAL_MASK, pwm->hwpwm);\r\nval |= BIT_CH(prescaler, pwm->hwpwm);\r\nsun4i_pwm_writel(sun4i_pwm, val, PWM_CTRL_REG);\r\nval = (dty & PWM_DTY_MASK) | PWM_PRD(prd);\r\nsun4i_pwm_writel(sun4i_pwm, val, PWM_CH_PRD(pwm->hwpwm));\r\nif (clk_gate) {\r\nval = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\r\nval |= clk_gate;\r\nsun4i_pwm_writel(sun4i_pwm, val, PWM_CTRL_REG);\r\n}\r\nspin_unlock(&sun4i_pwm->ctrl_lock);\r\nclk_disable_unprepare(sun4i_pwm->clk);\r\nreturn 0;\r\n}\r\nstatic int sun4i_pwm_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct sun4i_pwm_chip *sun4i_pwm = to_sun4i_pwm_chip(chip);\r\nu32 val;\r\nint ret;\r\nret = clk_prepare_enable(sun4i_pwm->clk);\r\nif (ret) {\r\ndev_err(chip->dev, "failed to enable PWM clock\n");\r\nreturn ret;\r\n}\r\nspin_lock(&sun4i_pwm->ctrl_lock);\r\nval = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\r\nif (polarity != PWM_POLARITY_NORMAL)\r\nval &= ~BIT_CH(PWM_ACT_STATE, pwm->hwpwm);\r\nelse\r\nval |= BIT_CH(PWM_ACT_STATE, pwm->hwpwm);\r\nsun4i_pwm_writel(sun4i_pwm, val, PWM_CTRL_REG);\r\nspin_unlock(&sun4i_pwm->ctrl_lock);\r\nclk_disable_unprepare(sun4i_pwm->clk);\r\nreturn 0;\r\n}\r\nstatic int sun4i_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct sun4i_pwm_chip *sun4i_pwm = to_sun4i_pwm_chip(chip);\r\nu32 val;\r\nint ret;\r\nret = clk_prepare_enable(sun4i_pwm->clk);\r\nif (ret) {\r\ndev_err(chip->dev, "failed to enable PWM clock\n");\r\nreturn ret;\r\n}\r\nspin_lock(&sun4i_pwm->ctrl_lock);\r\nval = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\r\nval |= BIT_CH(PWM_EN, pwm->hwpwm);\r\nval |= BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\r\nsun4i_pwm_writel(sun4i_pwm, val, PWM_CTRL_REG);\r\nspin_unlock(&sun4i_pwm->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic void sun4i_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct sun4i_pwm_chip *sun4i_pwm = to_sun4i_pwm_chip(chip);\r\nu32 val;\r\nspin_lock(&sun4i_pwm->ctrl_lock);\r\nval = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\r\nval &= ~BIT_CH(PWM_EN, pwm->hwpwm);\r\nval &= ~BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\r\nsun4i_pwm_writel(sun4i_pwm, val, PWM_CTRL_REG);\r\nspin_unlock(&sun4i_pwm->ctrl_lock);\r\nclk_disable_unprepare(sun4i_pwm->clk);\r\n}\r\nstatic int sun4i_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct sun4i_pwm_chip *pwm;\r\nstruct resource *res;\r\nu32 val;\r\nint i, ret;\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(sun4i_pwm_dt_ids, &pdev->dev);\r\npwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);\r\nif (!pwm)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npwm->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pwm->base))\r\nreturn PTR_ERR(pwm->base);\r\npwm->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pwm->clk))\r\nreturn PTR_ERR(pwm->clk);\r\npwm->data = match->data;\r\npwm->chip.dev = &pdev->dev;\r\npwm->chip.ops = &sun4i_pwm_ops;\r\npwm->chip.base = -1;\r\npwm->chip.npwm = pwm->data->npwm;\r\npwm->chip.can_sleep = true;\r\npwm->chip.of_xlate = of_pwm_xlate_with_flags;\r\npwm->chip.of_pwm_n_cells = 3;\r\nspin_lock_init(&pwm->ctrl_lock);\r\nret = pwmchip_add(&pwm->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, pwm);\r\nret = clk_prepare_enable(pwm->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable PWM clock\n");\r\ngoto clk_error;\r\n}\r\nval = sun4i_pwm_readl(pwm, PWM_CTRL_REG);\r\nfor (i = 0; i < pwm->chip.npwm; i++)\r\nif (!(val & BIT_CH(PWM_ACT_STATE, i)))\r\npwm_set_polarity(&pwm->chip.pwms[i],\r\nPWM_POLARITY_INVERSED);\r\nclk_disable_unprepare(pwm->clk);\r\nreturn 0;\r\nclk_error:\r\npwmchip_remove(&pwm->chip);\r\nreturn ret;\r\n}\r\nstatic int sun4i_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct sun4i_pwm_chip *pwm = platform_get_drvdata(pdev);\r\nreturn pwmchip_remove(&pwm->chip);\r\n}
