static void qcom_ep_reset_assert(struct qcom_pcie *pcie)\r\n{\r\ngpiod_set_value(pcie->reset, 1);\r\nusleep_range(PERST_DELAY_US, PERST_DELAY_US + 500);\r\n}\r\nstatic void qcom_ep_reset_deassert(struct qcom_pcie *pcie)\r\n{\r\ngpiod_set_value(pcie->reset, 0);\r\nusleep_range(PERST_DELAY_US, PERST_DELAY_US + 500);\r\n}\r\nstatic irqreturn_t qcom_pcie_msi_irq_handler(int irq, void *arg)\r\n{\r\nstruct pcie_port *pp = arg;\r\nreturn dw_handle_msi_irq(pp);\r\n}\r\nstatic int qcom_pcie_establish_link(struct qcom_pcie *pcie)\r\n{\r\nu32 val;\r\nif (dw_pcie_link_up(&pcie->pp))\r\nreturn 0;\r\nval = readl(pcie->elbi + PCIE20_ELBI_SYS_CTRL);\r\nval |= PCIE20_ELBI_SYS_CTRL_LT_ENABLE;\r\nwritel(val, pcie->elbi + PCIE20_ELBI_SYS_CTRL);\r\nreturn dw_pcie_wait_for_link(&pcie->pp);\r\n}\r\nstatic int qcom_pcie_get_resources_v0(struct qcom_pcie *pcie)\r\n{\r\nstruct qcom_pcie_resources_v0 *res = &pcie->res.v0;\r\nstruct device *dev = pcie->dev;\r\nres->vdda = devm_regulator_get(dev, "vdda");\r\nif (IS_ERR(res->vdda))\r\nreturn PTR_ERR(res->vdda);\r\nres->vdda_phy = devm_regulator_get(dev, "vdda_phy");\r\nif (IS_ERR(res->vdda_phy))\r\nreturn PTR_ERR(res->vdda_phy);\r\nres->vdda_refclk = devm_regulator_get(dev, "vdda_refclk");\r\nif (IS_ERR(res->vdda_refclk))\r\nreturn PTR_ERR(res->vdda_refclk);\r\nres->iface_clk = devm_clk_get(dev, "iface");\r\nif (IS_ERR(res->iface_clk))\r\nreturn PTR_ERR(res->iface_clk);\r\nres->core_clk = devm_clk_get(dev, "core");\r\nif (IS_ERR(res->core_clk))\r\nreturn PTR_ERR(res->core_clk);\r\nres->phy_clk = devm_clk_get(dev, "phy");\r\nif (IS_ERR(res->phy_clk))\r\nreturn PTR_ERR(res->phy_clk);\r\nres->pci_reset = devm_reset_control_get(dev, "pci");\r\nif (IS_ERR(res->pci_reset))\r\nreturn PTR_ERR(res->pci_reset);\r\nres->axi_reset = devm_reset_control_get(dev, "axi");\r\nif (IS_ERR(res->axi_reset))\r\nreturn PTR_ERR(res->axi_reset);\r\nres->ahb_reset = devm_reset_control_get(dev, "ahb");\r\nif (IS_ERR(res->ahb_reset))\r\nreturn PTR_ERR(res->ahb_reset);\r\nres->por_reset = devm_reset_control_get(dev, "por");\r\nif (IS_ERR(res->por_reset))\r\nreturn PTR_ERR(res->por_reset);\r\nres->phy_reset = devm_reset_control_get(dev, "phy");\r\nif (IS_ERR(res->phy_reset))\r\nreturn PTR_ERR(res->phy_reset);\r\nreturn 0;\r\n}\r\nstatic int qcom_pcie_get_resources_v1(struct qcom_pcie *pcie)\r\n{\r\nstruct qcom_pcie_resources_v1 *res = &pcie->res.v1;\r\nstruct device *dev = pcie->dev;\r\nres->vdda = devm_regulator_get(dev, "vdda");\r\nif (IS_ERR(res->vdda))\r\nreturn PTR_ERR(res->vdda);\r\nres->iface = devm_clk_get(dev, "iface");\r\nif (IS_ERR(res->iface))\r\nreturn PTR_ERR(res->iface);\r\nres->aux = devm_clk_get(dev, "aux");\r\nif (IS_ERR(res->aux))\r\nreturn PTR_ERR(res->aux);\r\nres->master_bus = devm_clk_get(dev, "master_bus");\r\nif (IS_ERR(res->master_bus))\r\nreturn PTR_ERR(res->master_bus);\r\nres->slave_bus = devm_clk_get(dev, "slave_bus");\r\nif (IS_ERR(res->slave_bus))\r\nreturn PTR_ERR(res->slave_bus);\r\nres->core = devm_reset_control_get(dev, "core");\r\nif (IS_ERR(res->core))\r\nreturn PTR_ERR(res->core);\r\nreturn 0;\r\n}\r\nstatic void qcom_pcie_deinit_v0(struct qcom_pcie *pcie)\r\n{\r\nstruct qcom_pcie_resources_v0 *res = &pcie->res.v0;\r\nreset_control_assert(res->pci_reset);\r\nreset_control_assert(res->axi_reset);\r\nreset_control_assert(res->ahb_reset);\r\nreset_control_assert(res->por_reset);\r\nreset_control_assert(res->pci_reset);\r\nclk_disable_unprepare(res->iface_clk);\r\nclk_disable_unprepare(res->core_clk);\r\nclk_disable_unprepare(res->phy_clk);\r\nregulator_disable(res->vdda);\r\nregulator_disable(res->vdda_phy);\r\nregulator_disable(res->vdda_refclk);\r\n}\r\nstatic int qcom_pcie_init_v0(struct qcom_pcie *pcie)\r\n{\r\nstruct qcom_pcie_resources_v0 *res = &pcie->res.v0;\r\nstruct device *dev = pcie->dev;\r\nu32 val;\r\nint ret;\r\nret = regulator_enable(res->vdda);\r\nif (ret) {\r\ndev_err(dev, "cannot enable vdda regulator\n");\r\nreturn ret;\r\n}\r\nret = regulator_enable(res->vdda_refclk);\r\nif (ret) {\r\ndev_err(dev, "cannot enable vdda_refclk regulator\n");\r\ngoto err_refclk;\r\n}\r\nret = regulator_enable(res->vdda_phy);\r\nif (ret) {\r\ndev_err(dev, "cannot enable vdda_phy regulator\n");\r\ngoto err_vdda_phy;\r\n}\r\nret = reset_control_assert(res->ahb_reset);\r\nif (ret) {\r\ndev_err(dev, "cannot assert ahb reset\n");\r\ngoto err_assert_ahb;\r\n}\r\nret = clk_prepare_enable(res->iface_clk);\r\nif (ret) {\r\ndev_err(dev, "cannot prepare/enable iface clock\n");\r\ngoto err_assert_ahb;\r\n}\r\nret = clk_prepare_enable(res->phy_clk);\r\nif (ret) {\r\ndev_err(dev, "cannot prepare/enable phy clock\n");\r\ngoto err_clk_phy;\r\n}\r\nret = clk_prepare_enable(res->core_clk);\r\nif (ret) {\r\ndev_err(dev, "cannot prepare/enable core clock\n");\r\ngoto err_clk_core;\r\n}\r\nret = reset_control_deassert(res->ahb_reset);\r\nif (ret) {\r\ndev_err(dev, "cannot deassert ahb reset\n");\r\ngoto err_deassert_ahb;\r\n}\r\nval = readl(pcie->parf + PCIE20_PARF_PHY_CTRL);\r\nval &= ~BIT(0);\r\nwritel(val, pcie->parf + PCIE20_PARF_PHY_CTRL);\r\nval = readl(pcie->parf + PCIE20_PARF_PHY_REFCLK);\r\nval |= BIT(16);\r\nwritel(val, pcie->parf + PCIE20_PARF_PHY_REFCLK);\r\nret = reset_control_deassert(res->phy_reset);\r\nif (ret) {\r\ndev_err(dev, "cannot deassert phy reset\n");\r\nreturn ret;\r\n}\r\nret = reset_control_deassert(res->pci_reset);\r\nif (ret) {\r\ndev_err(dev, "cannot deassert pci reset\n");\r\nreturn ret;\r\n}\r\nret = reset_control_deassert(res->por_reset);\r\nif (ret) {\r\ndev_err(dev, "cannot deassert por reset\n");\r\nreturn ret;\r\n}\r\nret = reset_control_deassert(res->axi_reset);\r\nif (ret) {\r\ndev_err(dev, "cannot deassert axi reset\n");\r\nreturn ret;\r\n}\r\nusleep_range(1000, 1500);\r\nreturn 0;\r\nerr_deassert_ahb:\r\nclk_disable_unprepare(res->core_clk);\r\nerr_clk_core:\r\nclk_disable_unprepare(res->phy_clk);\r\nerr_clk_phy:\r\nclk_disable_unprepare(res->iface_clk);\r\nerr_assert_ahb:\r\nregulator_disable(res->vdda_phy);\r\nerr_vdda_phy:\r\nregulator_disable(res->vdda_refclk);\r\nerr_refclk:\r\nregulator_disable(res->vdda);\r\nreturn ret;\r\n}\r\nstatic void qcom_pcie_deinit_v1(struct qcom_pcie *pcie)\r\n{\r\nstruct qcom_pcie_resources_v1 *res = &pcie->res.v1;\r\nreset_control_assert(res->core);\r\nclk_disable_unprepare(res->slave_bus);\r\nclk_disable_unprepare(res->master_bus);\r\nclk_disable_unprepare(res->iface);\r\nclk_disable_unprepare(res->aux);\r\nregulator_disable(res->vdda);\r\n}\r\nstatic int qcom_pcie_init_v1(struct qcom_pcie *pcie)\r\n{\r\nstruct qcom_pcie_resources_v1 *res = &pcie->res.v1;\r\nstruct device *dev = pcie->dev;\r\nint ret;\r\nret = reset_control_deassert(res->core);\r\nif (ret) {\r\ndev_err(dev, "cannot deassert core reset\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(res->aux);\r\nif (ret) {\r\ndev_err(dev, "cannot prepare/enable aux clock\n");\r\ngoto err_res;\r\n}\r\nret = clk_prepare_enable(res->iface);\r\nif (ret) {\r\ndev_err(dev, "cannot prepare/enable iface clock\n");\r\ngoto err_aux;\r\n}\r\nret = clk_prepare_enable(res->master_bus);\r\nif (ret) {\r\ndev_err(dev, "cannot prepare/enable master_bus clock\n");\r\ngoto err_iface;\r\n}\r\nret = clk_prepare_enable(res->slave_bus);\r\nif (ret) {\r\ndev_err(dev, "cannot prepare/enable slave_bus clock\n");\r\ngoto err_master;\r\n}\r\nret = regulator_enable(res->vdda);\r\nif (ret) {\r\ndev_err(dev, "cannot enable vdda regulator\n");\r\ngoto err_slave;\r\n}\r\nwritel(0, pcie->parf + PCIE20_PARF_DBI_BASE_ADDR);\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nu32 val = readl(pcie->parf + PCIE20_PARF_AXI_MSTR_WR_ADDR_HALT);\r\nval |= BIT(31);\r\nwritel(val, pcie->parf + PCIE20_PARF_AXI_MSTR_WR_ADDR_HALT);\r\n}\r\nreturn 0;\r\nerr_slave:\r\nclk_disable_unprepare(res->slave_bus);\r\nerr_master:\r\nclk_disable_unprepare(res->master_bus);\r\nerr_iface:\r\nclk_disable_unprepare(res->iface);\r\nerr_aux:\r\nclk_disable_unprepare(res->aux);\r\nerr_res:\r\nreset_control_assert(res->core);\r\nreturn ret;\r\n}\r\nstatic int qcom_pcie_link_up(struct pcie_port *pp)\r\n{\r\nstruct qcom_pcie *pcie = to_qcom_pcie(pp);\r\nu16 val = readw(pcie->dbi + PCIE20_CAP + PCI_EXP_LNKSTA);\r\nreturn !!(val & PCI_EXP_LNKSTA_DLLLA);\r\n}\r\nstatic void qcom_pcie_host_init(struct pcie_port *pp)\r\n{\r\nstruct qcom_pcie *pcie = to_qcom_pcie(pp);\r\nint ret;\r\nqcom_ep_reset_assert(pcie);\r\nret = pcie->ops->init(pcie);\r\nif (ret)\r\ngoto err_deinit;\r\nret = phy_power_on(pcie->phy);\r\nif (ret)\r\ngoto err_deinit;\r\ndw_pcie_setup_rc(pp);\r\nif (IS_ENABLED(CONFIG_PCI_MSI))\r\ndw_pcie_msi_init(pp);\r\nqcom_ep_reset_deassert(pcie);\r\nret = qcom_pcie_establish_link(pcie);\r\nif (ret)\r\ngoto err;\r\nreturn;\r\nerr:\r\nqcom_ep_reset_assert(pcie);\r\nphy_power_off(pcie->phy);\r\nerr_deinit:\r\npcie->ops->deinit(pcie);\r\n}\r\nstatic int qcom_pcie_rd_own_conf(struct pcie_port *pp, int where, int size,\r\nu32 *val)\r\n{\r\nif (where == PCI_CLASS_REVISION && size == 4) {\r\n*val = readl(pp->dbi_base + PCI_CLASS_REVISION);\r\n*val &= 0xff;\r\n*val |= PCI_CLASS_BRIDGE_PCI << 16;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nreturn dw_pcie_cfg_read(pp->dbi_base + where, size, val);\r\n}\r\nstatic int qcom_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct qcom_pcie *pcie;\r\nstruct pcie_port *pp;\r\nint ret;\r\npcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn -ENOMEM;\r\npcie->ops = (struct qcom_pcie_ops *)of_device_get_match_data(dev);\r\npcie->dev = dev;\r\npcie->reset = devm_gpiod_get_optional(dev, "perst", GPIOD_OUT_LOW);\r\nif (IS_ERR(pcie->reset))\r\nreturn PTR_ERR(pcie->reset);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "parf");\r\npcie->parf = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pcie->parf))\r\nreturn PTR_ERR(pcie->parf);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dbi");\r\npcie->dbi = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pcie->dbi))\r\nreturn PTR_ERR(pcie->dbi);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "elbi");\r\npcie->elbi = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pcie->elbi))\r\nreturn PTR_ERR(pcie->elbi);\r\npcie->phy = devm_phy_optional_get(dev, "pciephy");\r\nif (IS_ERR(pcie->phy))\r\nreturn PTR_ERR(pcie->phy);\r\nret = pcie->ops->get_resources(pcie);\r\nif (ret)\r\nreturn ret;\r\npp = &pcie->pp;\r\npp->dev = dev;\r\npp->dbi_base = pcie->dbi;\r\npp->root_bus_nr = -1;\r\npp->ops = &qcom_pcie_dw_ops;\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\npp->msi_irq = platform_get_irq_byname(pdev, "msi");\r\nif (pp->msi_irq < 0)\r\nreturn pp->msi_irq;\r\nret = devm_request_irq(dev, pp->msi_irq,\r\nqcom_pcie_msi_irq_handler,\r\nIRQF_SHARED, "qcom-pcie-msi", pp);\r\nif (ret) {\r\ndev_err(dev, "cannot request msi irq\n");\r\nreturn ret;\r\n}\r\n}\r\nret = phy_init(pcie->phy);\r\nif (ret)\r\nreturn ret;\r\nret = dw_pcie_host_init(pp);\r\nif (ret) {\r\ndev_err(dev, "cannot initialize host\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, pcie);\r\nreturn 0;\r\n}\r\nstatic int qcom_pcie_remove(struct platform_device *pdev)\r\n{\r\nstruct qcom_pcie *pcie = platform_get_drvdata(pdev);\r\nqcom_ep_reset_assert(pcie);\r\nphy_power_off(pcie->phy);\r\nphy_exit(pcie->phy);\r\npcie->ops->deinit(pcie);\r\nreturn 0;\r\n}
