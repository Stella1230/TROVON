static void armadaxp_init_sensor(struct platform_device *pdev,\r\nstruct armada_thermal_priv *priv)\r\n{\r\nunsigned long reg;\r\nreg = readl_relaxed(priv->control);\r\nreg |= PMU_TDC0_OTF_CAL_MASK;\r\nwritel(reg, priv->control);\r\nreg &= ~PMU_TDC0_REF_CAL_CNT_MASK;\r\nreg |= (0xf1 << PMU_TDC0_REF_CAL_CNT_OFFS);\r\nwritel(reg, priv->control);\r\nreg = readl_relaxed(priv->control);\r\nwritel((reg | PMU_TDC0_SW_RST_MASK), priv->control);\r\nwritel(reg, priv->control);\r\nreg = readl_relaxed(priv->sensor);\r\nreg &= ~PMU_TM_DISABLE_MASK;\r\nwritel(reg, priv->sensor);\r\n}\r\nstatic void armada370_init_sensor(struct platform_device *pdev,\r\nstruct armada_thermal_priv *priv)\r\n{\r\nunsigned long reg;\r\nreg = readl_relaxed(priv->control);\r\nreg |= PMU_TDC0_OTF_CAL_MASK;\r\nwritel(reg, priv->control);\r\nreg &= ~PMU_TDC0_REF_CAL_CNT_MASK;\r\nreg |= (0xf1 << PMU_TDC0_REF_CAL_CNT_OFFS);\r\nwritel(reg, priv->control);\r\nreg &= ~PMU_TDC0_START_CAL_MASK;\r\nwritel(reg, priv->control);\r\nmdelay(10);\r\n}\r\nstatic void armada375_init_sensor(struct platform_device *pdev,\r\nstruct armada_thermal_priv *priv)\r\n{\r\nunsigned long reg;\r\nreg = readl(priv->control + 4);\r\nreg &= ~(A375_UNIT_CONTROL_MASK << A375_UNIT_CONTROL_SHIFT);\r\nreg &= ~A375_READOUT_INVERT;\r\nreg &= ~A375_HW_RESETn;\r\nwritel(reg, priv->control + 4);\r\nmdelay(20);\r\nreg |= A375_HW_RESETn;\r\nwritel(reg, priv->control + 4);\r\nmdelay(50);\r\n}\r\nstatic void armada380_init_sensor(struct platform_device *pdev,\r\nstruct armada_thermal_priv *priv)\r\n{\r\nunsigned long reg = readl_relaxed(priv->control);\r\nif (!(reg & A380_HW_RESET)) {\r\nreg |= A380_HW_RESET;\r\nwritel(reg, priv->control);\r\nmdelay(10);\r\n}\r\n}\r\nstatic bool armada_is_valid(struct armada_thermal_priv *priv)\r\n{\r\nunsigned long reg = readl_relaxed(priv->sensor);\r\nreturn (reg >> priv->data->is_valid_shift) & THERMAL_VALID_MASK;\r\n}\r\nstatic int armada_get_temp(struct thermal_zone_device *thermal,\r\nint *temp)\r\n{\r\nstruct armada_thermal_priv *priv = thermal->devdata;\r\nunsigned long reg;\r\nunsigned long m, b, div;\r\nif (priv->data->is_valid && !priv->data->is_valid(priv)) {\r\ndev_err(&thermal->device,\r\n"Temperature sensor reading not valid\n");\r\nreturn -EIO;\r\n}\r\nreg = readl_relaxed(priv->sensor);\r\nreg = (reg >> priv->data->temp_shift) & priv->data->temp_mask;\r\nb = priv->data->coef_b;\r\nm = priv->data->coef_m;\r\ndiv = priv->data->coef_div;\r\nif (priv->data->inverted)\r\n*temp = ((m * reg) - b) / div;\r\nelse\r\n*temp = (b - (m * reg)) / div;\r\nreturn 0;\r\n}\r\nstatic int armada_thermal_probe(struct platform_device *pdev)\r\n{\r\nstruct thermal_zone_device *thermal;\r\nconst struct of_device_id *match;\r\nstruct armada_thermal_priv *priv;\r\nstruct resource *res;\r\nmatch = of_match_device(armada_thermal_id_table, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->sensor = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->sensor))\r\nreturn PTR_ERR(priv->sensor);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npriv->control = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->control))\r\nreturn PTR_ERR(priv->control);\r\npriv->data = (struct armada_thermal_data *)match->data;\r\npriv->data->init_sensor(pdev, priv);\r\nthermal = thermal_zone_device_register("armada_thermal", 0, 0,\r\npriv, &ops, NULL, 0, 0);\r\nif (IS_ERR(thermal)) {\r\ndev_err(&pdev->dev,\r\n"Failed to register thermal zone device\n");\r\nreturn PTR_ERR(thermal);\r\n}\r\nplatform_set_drvdata(pdev, thermal);\r\nreturn 0;\r\n}\r\nstatic int armada_thermal_exit(struct platform_device *pdev)\r\n{\r\nstruct thermal_zone_device *armada_thermal =\r\nplatform_get_drvdata(pdev);\r\nthermal_zone_device_unregister(armada_thermal);\r\nreturn 0;\r\n}
