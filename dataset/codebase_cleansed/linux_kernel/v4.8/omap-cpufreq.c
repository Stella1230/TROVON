static int omap_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\nint r, ret;\r\nstruct dev_pm_opp *opp;\r\nunsigned long freq, volt = 0, volt_old = 0, tol = 0;\r\nunsigned int old_freq, new_freq;\r\nold_freq = policy->cur;\r\nnew_freq = freq_table[index].frequency;\r\nfreq = new_freq * 1000;\r\nret = clk_round_rate(policy->clk, freq);\r\nif (ret < 0) {\r\ndev_warn(mpu_dev,\r\n"CPUfreq: Cannot find matching frequency for %lu\n",\r\nfreq);\r\nreturn ret;\r\n}\r\nfreq = ret;\r\nif (mpu_reg) {\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_ceil(mpu_dev, &freq);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\ndev_err(mpu_dev, "%s: unable to find MPU OPP for %d\n",\r\n__func__, new_freq);\r\nreturn -EINVAL;\r\n}\r\nvolt = dev_pm_opp_get_voltage(opp);\r\nrcu_read_unlock();\r\ntol = volt * OPP_TOLERANCE / 100;\r\nvolt_old = regulator_get_voltage(mpu_reg);\r\n}\r\ndev_dbg(mpu_dev, "cpufreq-omap: %u MHz, %ld mV --> %u MHz, %ld mV\n",\r\nold_freq / 1000, volt_old ? volt_old / 1000 : -1,\r\nnew_freq / 1000, volt ? volt / 1000 : -1);\r\nif (mpu_reg && (new_freq > old_freq)) {\r\nr = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);\r\nif (r < 0) {\r\ndev_warn(mpu_dev, "%s: unable to scale voltage up.\n",\r\n__func__);\r\nreturn r;\r\n}\r\n}\r\nret = clk_set_rate(policy->clk, new_freq * 1000);\r\nif (mpu_reg && (new_freq < old_freq)) {\r\nr = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);\r\nif (r < 0) {\r\ndev_warn(mpu_dev, "%s: unable to scale voltage down.\n",\r\n__func__);\r\nclk_set_rate(policy->clk, old_freq * 1000);\r\nreturn r;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void freq_table_free(void)\r\n{\r\nif (atomic_dec_and_test(&freq_table_users))\r\ndev_pm_opp_free_cpufreq_table(mpu_dev, &freq_table);\r\n}\r\nstatic int omap_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nint result;\r\npolicy->clk = clk_get(NULL, "cpufreq_ck");\r\nif (IS_ERR(policy->clk))\r\nreturn PTR_ERR(policy->clk);\r\nif (!freq_table) {\r\nresult = dev_pm_opp_init_cpufreq_table(mpu_dev, &freq_table);\r\nif (result) {\r\ndev_err(mpu_dev,\r\n"%s: cpu%d: failed creating freq table[%d]\n",\r\n__func__, policy->cpu, result);\r\ngoto fail;\r\n}\r\n}\r\natomic_inc_return(&freq_table_users);\r\nresult = cpufreq_generic_init(policy, freq_table, 300 * 1000);\r\nif (!result)\r\nreturn 0;\r\nfreq_table_free();\r\nfail:\r\nclk_put(policy->clk);\r\nreturn result;\r\n}\r\nstatic int omap_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nfreq_table_free();\r\nclk_put(policy->clk);\r\nreturn 0;\r\n}\r\nstatic int omap_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nmpu_dev = get_cpu_device(0);\r\nif (!mpu_dev) {\r\npr_warn("%s: unable to get the MPU device\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmpu_reg = regulator_get(mpu_dev, "vcc");\r\nif (IS_ERR(mpu_reg)) {\r\npr_warn("%s: unable to get MPU regulator\n", __func__);\r\nmpu_reg = NULL;\r\n} else {\r\nif (regulator_get_voltage(mpu_reg) < 0) {\r\npr_warn("%s: physical regulator not present for MPU\n",\r\n__func__);\r\nregulator_put(mpu_reg);\r\nmpu_reg = NULL;\r\n}\r\n}\r\nreturn cpufreq_register_driver(&omap_driver);\r\n}\r\nstatic int omap_cpufreq_remove(struct platform_device *pdev)\r\n{\r\nreturn cpufreq_unregister_driver(&omap_driver);\r\n}
