static void reg_w(struct gspca_dev *gspca_dev,\r\nint len)\r\n{\r\nint alen, ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_bulk_msg(gspca_dev->dev,\r\nusb_sndbulkpipe(gspca_dev->dev, 4),\r\ngspca_dev->usb_buf,\r\nlen,\r\n&alen,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg write [%02x] error %d\n",\r\ngspca_dev->usb_buf[0], ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void mi_w(struct gspca_dev *gspca_dev,\r\nu8 addr,\r\nu8 value)\r\n{\r\ngspca_dev->usb_buf[0] = 0x1f;\r\ngspca_dev->usb_buf[1] = 0;\r\ngspca_dev->usb_buf[2] = addr;\r\ngspca_dev->usb_buf[3] = value;\r\nreg_w(gspca_dev, 4);\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\ngspca_dev->usb_buf[0] = 0x61;\r\ngspca_dev->usb_buf[1] = val;\r\nreg_w(gspca_dev, 2);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\ngspca_dev->usb_buf[0] = 0x5f;\r\ngspca_dev->usb_buf[1] = val << 3;\r\ngspca_dev->usb_buf[2] = ((val >> 2) & 0xf8) | 0x04;\r\nreg_w(gspca_dev, 3);\r\n}\r\nstatic void setgamma(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\ngspca_dev->usb_buf[0] = 0x06;\r\ngspca_dev->usb_buf[1] = val * 0x40;\r\nreg_w(gspca_dev, 2);\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\ngspca_dev->usb_buf[0] = 0x67;\r\ngspca_dev->usb_buf[1] = val * 4 + 3;\r\nreg_w(gspca_dev, 2);\r\n}\r\nstatic void setilluminators(struct gspca_dev *gspca_dev, bool top, bool bottom)\r\n{\r\ngspca_dev->usb_buf[0] = 0x22;\r\nif (top)\r\ngspca_dev->usb_buf[1] = 0x76;\r\nelse if (bottom)\r\ngspca_dev->usb_buf[1] = 0x7a;\r\nelse\r\ngspca_dev->usb_buf[1] = 0x7e;\r\nreg_w(gspca_dev, 2);\r\n}\r\nstatic int mars_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (ctrl->id == V4L2_CID_ILLUMINATORS_1) {\r\nif (ctrl->is_new && ctrl->val)\r\nsd->illum_bottom->val = 0;\r\nif (sd->illum_bottom->is_new && sd->illum_bottom->val)\r\nsd->illum_top->val = 0;\r\n}\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetcolors(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nsetgamma(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_ILLUMINATORS_1:\r\nsetilluminators(gspca_dev, sd->illum_top->val,\r\nsd->illum_bottom->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nsetsharpness(gspca_dev, ctrl->val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 6);\r\nsd->brightness = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 30, 1, 15);\r\nsd->saturation = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 200);\r\nsd->gamma = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\r\nV4L2_CID_GAMMA, 0, 3, 1, 1);\r\nsd->sharpness = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0, 2, 1, 1);\r\nsd->illum_top = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\r\nV4L2_CID_ILLUMINATORS_1, 0, 1, 1, 0);\r\nsd->illum_top->flags |= V4L2_CTRL_FLAG_UPDATE;\r\nsd->illum_bottom = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\r\nV4L2_CID_ILLUMINATORS_2, 0, 1, 1, 0);\r\nsd->illum_bottom->flags |= V4L2_CTRL_FLAG_UPDATE;\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nv4l2_ctrl_cluster(2, &sd->illum_top);\r\nreturn 0;\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 *data;\r\nint i;\r\njpeg_define(sd->jpeg_hdr, gspca_dev->pixfmt.height,\r\ngspca_dev->pixfmt.width,\r\n0x21);\r\njpeg_set_qual(sd->jpeg_hdr, QUALITY);\r\ndata = gspca_dev->usb_buf;\r\ndata[0] = 0x01;\r\ndata[1] = 0x01;\r\nreg_w(gspca_dev, 2);\r\ndata[0] = 0x00;\r\ndata[1] = 0x0c | 0x01;\r\ndata[2] = 0x01;\r\ndata[3] = gspca_dev->pixfmt.width / 8;\r\ndata[4] = gspca_dev->pixfmt.height / 8;\r\ndata[5] = 0x30;\r\ndata[6] = 0x02;\r\ndata[7] = v4l2_ctrl_g_ctrl(sd->gamma) * 0x40;\r\ndata[8] = 0x01;\r\ndata[9] = 0x52;\r\ndata[10] = 0x18;\r\nreg_w(gspca_dev, 11);\r\ndata[0] = 0x23;\r\ndata[1] = 0x09;\r\nreg_w(gspca_dev, 2);\r\ndata[0] = 0x3c;\r\ndata[1] = 50;\r\nreg_w(gspca_dev, 2);\r\ndata[0] = 0x5e;\r\ndata[1] = 0;\r\ndata[2] = v4l2_ctrl_g_ctrl(sd->saturation) << 3;\r\ndata[3] = ((v4l2_ctrl_g_ctrl(sd->saturation) >> 2) & 0xf8) | 0x04;\r\ndata[4] = v4l2_ctrl_g_ctrl(sd->brightness);\r\ndata[5] = 0x00;\r\nreg_w(gspca_dev, 6);\r\ndata[0] = 0x67;\r\ndata[1] = v4l2_ctrl_g_ctrl(sd->sharpness) * 4 + 3;\r\ndata[2] = 0x14;\r\nreg_w(gspca_dev, 3);\r\ndata[0] = 0x69;\r\ndata[1] = 0x2f;\r\ndata[2] = 0x28;\r\ndata[3] = 0x42;\r\nreg_w(gspca_dev, 4);\r\ndata[0] = 0x63;\r\ndata[1] = 0x07;\r\nreg_w(gspca_dev, 2);\r\nfor (i = 0; i < sizeof mi_data; i++)\r\nmi_w(gspca_dev, i + 1, mi_data[i]);\r\ndata[0] = 0x00;\r\ndata[1] = 0x4d;\r\nreg_w(gspca_dev, 2);\r\nsetilluminators(gspca_dev, v4l2_ctrl_g_ctrl(sd->illum_top),\r\nv4l2_ctrl_g_ctrl(sd->illum_bottom));\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (v4l2_ctrl_g_ctrl(sd->illum_top) ||\r\nv4l2_ctrl_g_ctrl(sd->illum_bottom)) {\r\nsetilluminators(gspca_dev, false, false);\r\nmsleep(20);\r\n}\r\ngspca_dev->usb_buf[0] = 1;\r\ngspca_dev->usb_buf[1] = 0;\r\nreg_w(gspca_dev, 2);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint p;\r\nif (len < 6) {\r\nreturn;\r\n}\r\nfor (p = 0; p < len - 6; p++) {\r\nif (data[0 + p] == 0xff\r\n&& data[1 + p] == 0xff\r\n&& data[2 + p] == 0x00\r\n&& data[3 + p] == 0xff\r\n&& data[4 + p] == 0x96) {\r\nif (data[5 + p] == 0x64\r\n|| data[5 + p] == 0x65\r\n|| data[5 + p] == 0x66\r\n|| data[5 + p] == 0x67) {\r\nPDEBUG(D_PACK, "sof offset: %d len: %d",\r\np, len);\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\ndata, p);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\ndata += p + 16;\r\nlen -= p + 16;\r\nbreak;\r\n}\r\n}\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
