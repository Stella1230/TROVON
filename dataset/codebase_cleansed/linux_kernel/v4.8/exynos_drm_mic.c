static void mic_set_path(struct exynos_mic *mic, bool enable)\r\n{\r\nint ret;\r\nunsigned int val;\r\nret = regmap_read(mic->sysreg, DSD_CFG_MUX, &val);\r\nif (ret) {\r\nDRM_ERROR("mic: Failed to read system register\n");\r\nreturn;\r\n}\r\nif (enable) {\r\nif (mic->i80_mode)\r\nval |= MIC0_I80_MUX;\r\nelse\r\nval |= MIC0_RGB_MUX;\r\nval |= MIC0_ON_MUX;\r\n} else\r\nval &= ~(MIC0_RGB_MUX | MIC0_I80_MUX | MIC0_ON_MUX);\r\nret = regmap_write(mic->sysreg, DSD_CFG_MUX, val);\r\nif (ret)\r\nDRM_ERROR("mic: Failed to read system register\n");\r\n}\r\nstatic int mic_sw_reset(struct exynos_mic *mic)\r\n{\r\nunsigned int retry = 100;\r\nint ret;\r\nwritel(MIC_SW_RST, mic->reg + MIC_OP);\r\nwhile (retry-- > 0) {\r\nret = readl(mic->reg + MIC_OP);\r\nif (!(ret & MIC_SW_RST))\r\nreturn 0;\r\nudelay(10);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void mic_set_porch_timing(struct exynos_mic *mic)\r\n{\r\nstruct videomode vm = mic->vm;\r\nu32 reg;\r\nreg = MIC_V_PULSE_WIDTH(vm.vsync_len) +\r\nMIC_V_PERIOD_LINE(vm.vsync_len + vm.vactive +\r\nvm.vback_porch + vm.vfront_porch);\r\nwritel(reg, mic->reg + MIC_V_TIMING_0);\r\nreg = MIC_VBP_SIZE(vm.vback_porch) +\r\nMIC_VFP_SIZE(vm.vfront_porch);\r\nwritel(reg, mic->reg + MIC_V_TIMING_1);\r\nreg = MIC_V_PULSE_WIDTH(vm.hsync_len) +\r\nMIC_V_PERIOD_LINE(vm.hsync_len + vm.hactive +\r\nvm.hback_porch + vm.hfront_porch);\r\nwritel(reg, mic->reg + MIC_INPUT_TIMING_0);\r\nreg = MIC_VBP_SIZE(vm.hback_porch) +\r\nMIC_VFP_SIZE(vm.hfront_porch);\r\nwritel(reg, mic->reg + MIC_INPUT_TIMING_1);\r\n}\r\nstatic void mic_set_img_size(struct exynos_mic *mic)\r\n{\r\nstruct videomode *vm = &mic->vm;\r\nu32 reg;\r\nreg = MIC_IMG_H_SIZE(vm->hactive) +\r\nMIC_IMG_V_SIZE(vm->vactive);\r\nwritel(reg, mic->reg + MIC_IMG_SIZE);\r\n}\r\nstatic void mic_set_output_timing(struct exynos_mic *mic)\r\n{\r\nstruct videomode vm = mic->vm;\r\nu32 reg, bs_size_2d;\r\nDRM_DEBUG("w: %u, h: %u\n", vm.hactive, vm.vactive);\r\nbs_size_2d = ((vm.hactive >> 2) << 1) + (vm.vactive % 4);\r\nreg = MIC_BS_SIZE_2D(bs_size_2d);\r\nwritel(reg, mic->reg + MIC_2D_OUTPUT_TIMING_2);\r\nif (!mic->i80_mode) {\r\nreg = MIC_H_PULSE_WIDTH_2D(vm.hsync_len) +\r\nMIC_H_PERIOD_PIXEL_2D(vm.hsync_len + bs_size_2d +\r\nvm.hback_porch + vm.hfront_porch);\r\nwritel(reg, mic->reg + MIC_2D_OUTPUT_TIMING_0);\r\nreg = MIC_HBP_SIZE_2D(vm.hback_porch) +\r\nMIC_H_PERIOD_PIXEL_2D(vm.hfront_porch);\r\nwritel(reg, mic->reg + MIC_2D_OUTPUT_TIMING_1);\r\n}\r\n}\r\nstatic void mic_set_reg_on(struct exynos_mic *mic, bool enable)\r\n{\r\nu32 reg = readl(mic->reg + MIC_OP);\r\nif (enable) {\r\nreg &= ~(MIC_MODE_SEL_MASK | MIC_CORE_VER_CONTROL | MIC_PSR_EN);\r\nreg |= (MIC_CORE_EN | MIC_BS_CHG_OUT | MIC_ON_REG);\r\nreg &= ~MIC_MODE_SEL_COMMAND_MODE;\r\nif (mic->i80_mode)\r\nreg |= MIC_MODE_SEL_COMMAND_MODE;\r\n} else {\r\nreg &= ~MIC_CORE_EN;\r\n}\r\nreg |= MIC_UPD_REG;\r\nwritel(reg, mic->reg + MIC_OP);\r\n}\r\nstatic struct device_node *get_remote_node(struct device_node *from, int reg)\r\n{\r\nstruct device_node *endpoint = NULL, *remote_node = NULL;\r\nendpoint = of_graph_get_endpoint_by_regs(from, reg, -1);\r\nif (!endpoint) {\r\nDRM_ERROR("mic: Failed to find remote port from %s",\r\nfrom->full_name);\r\ngoto exit;\r\n}\r\nremote_node = of_graph_get_remote_port_parent(endpoint);\r\nif (!remote_node) {\r\nDRM_ERROR("mic: Failed to find remote port parent from %s",\r\nfrom->full_name);\r\ngoto exit;\r\n}\r\nexit:\r\nof_node_put(endpoint);\r\nreturn remote_node;\r\n}\r\nstatic int parse_dt(struct exynos_mic *mic)\r\n{\r\nint ret = 0, i, j;\r\nstruct device_node *remote_node;\r\nstruct device_node *nodes[3];\r\nfor (i = 0, j = 0; i < NUM_ENDPOINTS; i++) {\r\nremote_node = get_remote_node(mic->dev->of_node, i);\r\nif (!remote_node) {\r\nret = -EPIPE;\r\ngoto exit;\r\n}\r\nnodes[j++] = remote_node;\r\nswitch (i) {\r\ncase ENDPOINT_DECON_NODE:\r\nif (of_get_child_by_name(remote_node,\r\n"i80-if-timings"))\r\nmic->i80_mode = 1;\r\nbreak;\r\ncase ENDPOINT_DSI_NODE:\r\nremote_node = get_remote_node(remote_node, 1);\r\nif (!remote_node) {\r\nret = -EPIPE;\r\ngoto exit;\r\n}\r\nnodes[j++] = remote_node;\r\nret = of_get_videomode(remote_node,\r\n&mic->vm, 0);\r\nif (ret) {\r\nDRM_ERROR("mic: failed to get videomode");\r\ngoto exit;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("mic: Unknown endpoint from MIC");\r\nbreak;\r\n}\r\n}\r\nexit:\r\nwhile (--j > -1)\r\nof_node_put(nodes[j]);\r\nreturn ret;\r\n}\r\nstatic void mic_disable(struct drm_bridge *bridge) { }\r\nstatic void mic_post_disable(struct drm_bridge *bridge)\r\n{\r\nstruct exynos_mic *mic = bridge->driver_private;\r\nint i;\r\nmutex_lock(&mic_mutex);\r\nif (!mic->enabled)\r\ngoto already_disabled;\r\nmic_set_path(mic, 0);\r\nfor (i = NUM_CLKS - 1; i > -1; i--)\r\nclk_disable_unprepare(mic->clks[i]);\r\nmic->enabled = 0;\r\nalready_disabled:\r\nmutex_unlock(&mic_mutex);\r\n}\r\nstatic void mic_pre_enable(struct drm_bridge *bridge)\r\n{\r\nstruct exynos_mic *mic = bridge->driver_private;\r\nint ret, i;\r\nmutex_lock(&mic_mutex);\r\nif (mic->enabled)\r\ngoto already_enabled;\r\nfor (i = 0; i < NUM_CLKS; i++) {\r\nret = clk_prepare_enable(mic->clks[i]);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to enable clock (%s)\n",\r\nclk_names[i]);\r\ngoto turn_off_clks;\r\n}\r\n}\r\nmic_set_path(mic, 1);\r\nret = mic_sw_reset(mic);\r\nif (ret) {\r\nDRM_ERROR("Failed to reset\n");\r\ngoto turn_off_clks;\r\n}\r\nif (!mic->i80_mode)\r\nmic_set_porch_timing(mic);\r\nmic_set_img_size(mic);\r\nmic_set_output_timing(mic);\r\nmic_set_reg_on(mic, 1);\r\nmic->enabled = 1;\r\nmutex_unlock(&mic_mutex);\r\nreturn;\r\nturn_off_clks:\r\nwhile (--i > -1)\r\nclk_disable_unprepare(mic->clks[i]);\r\nalready_enabled:\r\nmutex_unlock(&mic_mutex);\r\n}\r\nstatic void mic_enable(struct drm_bridge *bridge) { }\r\nstatic int exynos_mic_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct exynos_mic *mic = dev_get_drvdata(dev);\r\nint ret;\r\nmic->bridge.funcs = &mic_bridge_funcs;\r\nmic->bridge.of_node = dev->of_node;\r\nmic->bridge.driver_private = mic;\r\nret = drm_bridge_add(&mic->bridge);\r\nif (ret)\r\nDRM_ERROR("mic: Failed to add MIC to the global bridge list\n");\r\nreturn ret;\r\n}\r\nstatic void exynos_mic_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct exynos_mic *mic = dev_get_drvdata(dev);\r\nint i;\r\nmutex_lock(&mic_mutex);\r\nif (!mic->enabled)\r\ngoto already_disabled;\r\nfor (i = NUM_CLKS - 1; i > -1; i--)\r\nclk_disable_unprepare(mic->clks[i]);\r\nalready_disabled:\r\nmutex_unlock(&mic_mutex);\r\ndrm_bridge_remove(&mic->bridge);\r\n}\r\nstatic int exynos_mic_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct exynos_mic *mic;\r\nstruct resource res;\r\nint ret, i;\r\nmic = devm_kzalloc(dev, sizeof(*mic), GFP_KERNEL);\r\nif (!mic) {\r\nDRM_ERROR("mic: Failed to allocate memory for MIC object\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nmic->dev = dev;\r\nret = parse_dt(mic);\r\nif (ret)\r\ngoto err;\r\nret = of_address_to_resource(dev->of_node, 0, &res);\r\nif (ret) {\r\nDRM_ERROR("mic: Failed to get mem region for MIC\n");\r\ngoto err;\r\n}\r\nmic->reg = devm_ioremap(dev, res.start, resource_size(&res));\r\nif (!mic->reg) {\r\nDRM_ERROR("mic: Failed to remap for MIC\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nmic->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"samsung,disp-syscon");\r\nif (IS_ERR(mic->sysreg)) {\r\nDRM_ERROR("mic: Failed to get system register.\n");\r\nret = PTR_ERR(mic->sysreg);\r\ngoto err;\r\n}\r\nfor (i = 0; i < NUM_CLKS; i++) {\r\nmic->clks[i] = devm_clk_get(dev, clk_names[i]);\r\nif (IS_ERR(mic->clks[i])) {\r\nDRM_ERROR("mic: Failed to get clock (%s)\n",\r\nclk_names[i]);\r\nret = PTR_ERR(mic->clks[i]);\r\ngoto err;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, mic);\r\nDRM_DEBUG_KMS("MIC has been probed\n");\r\nreturn component_add(dev, &exynos_mic_component_ops);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int exynos_mic_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &exynos_mic_component_ops);\r\nreturn 0;\r\n}
