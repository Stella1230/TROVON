static int ci_set_smc_sram_address(struct amdgpu_device *adev,\r\nu32 smc_address, u32 limit)\r\n{\r\nif (smc_address & 3)\r\nreturn -EINVAL;\r\nif ((smc_address + 3) > limit)\r\nreturn -EINVAL;\r\nWREG32(mmSMC_IND_INDEX_0, smc_address);\r\nWREG32_P(mmSMC_IND_ACCESS_CNTL, 0, ~SMC_IND_ACCESS_CNTL__AUTO_INCREMENT_IND_0_MASK);\r\nreturn 0;\r\n}\r\nint amdgpu_ci_copy_bytes_to_smc(struct amdgpu_device *adev,\r\nu32 smc_start_address,\r\nconst u8 *src, u32 byte_count, u32 limit)\r\n{\r\nunsigned long flags;\r\nu32 data, original_data;\r\nu32 addr;\r\nu32 extra_shift;\r\nint ret = 0;\r\nif (smc_start_address & 3)\r\nreturn -EINVAL;\r\nif ((smc_start_address + byte_count) > limit)\r\nreturn -EINVAL;\r\naddr = smc_start_address;\r\nspin_lock_irqsave(&adev->smc_idx_lock, flags);\r\nwhile (byte_count >= 4) {\r\ndata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\r\nret = ci_set_smc_sram_address(adev, addr, limit);\r\nif (ret)\r\ngoto done;\r\nWREG32(mmSMC_IND_DATA_0, data);\r\nsrc += 4;\r\nbyte_count -= 4;\r\naddr += 4;\r\n}\r\nif (byte_count > 0) {\r\ndata = 0;\r\nret = ci_set_smc_sram_address(adev, addr, limit);\r\nif (ret)\r\ngoto done;\r\noriginal_data = RREG32(mmSMC_IND_DATA_0);\r\nextra_shift = 8 * (4 - byte_count);\r\nwhile (byte_count > 0) {\r\ndata = (data << 8) + *src++;\r\nbyte_count--;\r\n}\r\ndata <<= extra_shift;\r\ndata |= (original_data & ~((~0UL) << extra_shift));\r\nret = ci_set_smc_sram_address(adev, addr, limit);\r\nif (ret)\r\ngoto done;\r\nWREG32(mmSMC_IND_DATA_0, data);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&adev->smc_idx_lock, flags);\r\nreturn ret;\r\n}\r\nvoid amdgpu_ci_start_smc(struct amdgpu_device *adev)\r\n{\r\nu32 tmp = RREG32_SMC(ixSMC_SYSCON_RESET_CNTL);\r\ntmp &= ~SMC_SYSCON_RESET_CNTL__rst_reg_MASK;\r\nWREG32_SMC(ixSMC_SYSCON_RESET_CNTL, tmp);\r\n}\r\nvoid amdgpu_ci_reset_smc(struct amdgpu_device *adev)\r\n{\r\nu32 tmp = RREG32_SMC(ixSMC_SYSCON_RESET_CNTL);\r\ntmp |= SMC_SYSCON_RESET_CNTL__rst_reg_MASK;\r\nWREG32_SMC(ixSMC_SYSCON_RESET_CNTL, tmp);\r\n}\r\nint amdgpu_ci_program_jump_on_start(struct amdgpu_device *adev)\r\n{\r\nstatic u8 data[] = { 0xE0, 0x00, 0x80, 0x40 };\r\nreturn amdgpu_ci_copy_bytes_to_smc(adev, 0x0, data, 4, sizeof(data)+1);\r\n}\r\nvoid amdgpu_ci_stop_smc_clock(struct amdgpu_device *adev)\r\n{\r\nu32 tmp = RREG32_SMC(ixSMC_SYSCON_CLOCK_CNTL_0);\r\ntmp |= SMC_SYSCON_CLOCK_CNTL_0__ck_disable_MASK;\r\nWREG32_SMC(ixSMC_SYSCON_CLOCK_CNTL_0, tmp);\r\n}\r\nvoid amdgpu_ci_start_smc_clock(struct amdgpu_device *adev)\r\n{\r\nu32 tmp = RREG32_SMC(ixSMC_SYSCON_CLOCK_CNTL_0);\r\ntmp &= ~SMC_SYSCON_CLOCK_CNTL_0__ck_disable_MASK;\r\nWREG32_SMC(ixSMC_SYSCON_CLOCK_CNTL_0, tmp);\r\n}\r\nbool amdgpu_ci_is_smc_running(struct amdgpu_device *adev)\r\n{\r\nu32 clk = RREG32_SMC(ixSMC_SYSCON_CLOCK_CNTL_0);\r\nu32 pc_c = RREG32_SMC(ixSMC_PC_C);\r\nif (!(clk & SMC_SYSCON_CLOCK_CNTL_0__ck_disable_MASK) && (0x20100 <= pc_c))\r\nreturn true;\r\nreturn false;\r\n}\r\nPPSMC_Result amdgpu_ci_send_msg_to_smc(struct amdgpu_device *adev, PPSMC_Msg msg)\r\n{\r\nu32 tmp;\r\nint i;\r\nif (!amdgpu_ci_is_smc_running(adev))\r\nreturn PPSMC_Result_Failed;\r\nWREG32(mmSMC_MESSAGE_0, msg);\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\ntmp = RREG32(mmSMC_RESP_0);\r\nif (tmp != 0)\r\nbreak;\r\nudelay(1);\r\n}\r\ntmp = RREG32(mmSMC_RESP_0);\r\nreturn (PPSMC_Result)tmp;\r\n}\r\nPPSMC_Result amdgpu_ci_wait_for_smc_inactive(struct amdgpu_device *adev)\r\n{\r\nu32 tmp;\r\nint i;\r\nif (!amdgpu_ci_is_smc_running(adev))\r\nreturn PPSMC_Result_OK;\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\ntmp = RREG32_SMC(ixSMC_SYSCON_CLOCK_CNTL_0);\r\nif ((tmp & SMC_SYSCON_CLOCK_CNTL_0__cken_MASK) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nreturn PPSMC_Result_OK;\r\n}\r\nint amdgpu_ci_load_smc_ucode(struct amdgpu_device *adev, u32 limit)\r\n{\r\nconst struct smc_firmware_header_v1_0 *hdr;\r\nunsigned long flags;\r\nu32 ucode_start_address;\r\nu32 ucode_size;\r\nconst u8 *src;\r\nu32 data;\r\nif (!adev->pm.fw)\r\nreturn -EINVAL;\r\nhdr = (const struct smc_firmware_header_v1_0 *)adev->pm.fw->data;\r\namdgpu_ucode_print_smc_hdr(&hdr->header);\r\nadev->pm.fw_version = le32_to_cpu(hdr->header.ucode_version);\r\nucode_start_address = le32_to_cpu(hdr->ucode_start_addr);\r\nucode_size = le32_to_cpu(hdr->header.ucode_size_bytes);\r\nsrc = (const u8 *)\r\n(adev->pm.fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\r\nif (ucode_size & 3)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&adev->smc_idx_lock, flags);\r\nWREG32(mmSMC_IND_INDEX_0, ucode_start_address);\r\nWREG32_P(mmSMC_IND_ACCESS_CNTL, SMC_IND_ACCESS_CNTL__AUTO_INCREMENT_IND_0_MASK,\r\n~SMC_IND_ACCESS_CNTL__AUTO_INCREMENT_IND_0_MASK);\r\nwhile (ucode_size >= 4) {\r\ndata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\r\nWREG32(mmSMC_IND_DATA_0, data);\r\nsrc += 4;\r\nucode_size -= 4;\r\n}\r\nWREG32_P(mmSMC_IND_ACCESS_CNTL, 0, ~SMC_IND_ACCESS_CNTL__AUTO_INCREMENT_IND_0_MASK);\r\nspin_unlock_irqrestore(&adev->smc_idx_lock, flags);\r\nreturn 0;\r\n}\r\nint amdgpu_ci_read_smc_sram_dword(struct amdgpu_device *adev,\r\nu32 smc_address, u32 *value, u32 limit)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&adev->smc_idx_lock, flags);\r\nret = ci_set_smc_sram_address(adev, smc_address, limit);\r\nif (ret == 0)\r\n*value = RREG32(mmSMC_IND_DATA_0);\r\nspin_unlock_irqrestore(&adev->smc_idx_lock, flags);\r\nreturn ret;\r\n}\r\nint amdgpu_ci_write_smc_sram_dword(struct amdgpu_device *adev,\r\nu32 smc_address, u32 value, u32 limit)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&adev->smc_idx_lock, flags);\r\nret = ci_set_smc_sram_address(adev, smc_address, limit);\r\nif (ret == 0)\r\nWREG32(mmSMC_IND_DATA_0, value);\r\nspin_unlock_irqrestore(&adev->smc_idx_lock, flags);\r\nreturn ret;\r\n}
