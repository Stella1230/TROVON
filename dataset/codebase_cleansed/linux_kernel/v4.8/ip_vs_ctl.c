int ip_vs_get_debug_level(void)\r\n{\r\nreturn sysctl_ip_vs_debug_level;\r\n}\r\nstatic bool __ip_vs_addr_is_local_v6(struct net *net,\r\nconst struct in6_addr *addr)\r\n{\r\nstruct flowi6 fl6 = {\r\n.daddr = *addr,\r\n};\r\nstruct dst_entry *dst = ip6_route_output(net, NULL, &fl6);\r\nbool is_local;\r\nis_local = !dst->error && dst->dev && (dst->dev->flags & IFF_LOOPBACK);\r\ndst_release(dst);\r\nreturn is_local;\r\n}\r\nstatic void update_defense_level(struct netns_ipvs *ipvs)\r\n{\r\nstruct sysinfo i;\r\nstatic int old_secure_tcp = 0;\r\nint availmem;\r\nint nomem;\r\nint to_change = -1;\r\nsi_meminfo(&i);\r\navailmem = i.freeram + i.bufferram;\r\nnomem = (availmem < ipvs->sysctl_amemthresh);\r\nlocal_bh_disable();\r\nspin_lock(&ipvs->dropentry_lock);\r\nswitch (ipvs->sysctl_drop_entry) {\r\ncase 0:\r\natomic_set(&ipvs->dropentry, 0);\r\nbreak;\r\ncase 1:\r\nif (nomem) {\r\natomic_set(&ipvs->dropentry, 1);\r\nipvs->sysctl_drop_entry = 2;\r\n} else {\r\natomic_set(&ipvs->dropentry, 0);\r\n}\r\nbreak;\r\ncase 2:\r\nif (nomem) {\r\natomic_set(&ipvs->dropentry, 1);\r\n} else {\r\natomic_set(&ipvs->dropentry, 0);\r\nipvs->sysctl_drop_entry = 1;\r\n};\r\nbreak;\r\ncase 3:\r\natomic_set(&ipvs->dropentry, 1);\r\nbreak;\r\n}\r\nspin_unlock(&ipvs->dropentry_lock);\r\nspin_lock(&ipvs->droppacket_lock);\r\nswitch (ipvs->sysctl_drop_packet) {\r\ncase 0:\r\nipvs->drop_rate = 0;\r\nbreak;\r\ncase 1:\r\nif (nomem) {\r\nipvs->drop_rate = ipvs->drop_counter\r\n= ipvs->sysctl_amemthresh /\r\n(ipvs->sysctl_amemthresh-availmem);\r\nipvs->sysctl_drop_packet = 2;\r\n} else {\r\nipvs->drop_rate = 0;\r\n}\r\nbreak;\r\ncase 2:\r\nif (nomem) {\r\nipvs->drop_rate = ipvs->drop_counter\r\n= ipvs->sysctl_amemthresh /\r\n(ipvs->sysctl_amemthresh-availmem);\r\n} else {\r\nipvs->drop_rate = 0;\r\nipvs->sysctl_drop_packet = 1;\r\n}\r\nbreak;\r\ncase 3:\r\nipvs->drop_rate = ipvs->sysctl_am_droprate;\r\nbreak;\r\n}\r\nspin_unlock(&ipvs->droppacket_lock);\r\nspin_lock(&ipvs->securetcp_lock);\r\nswitch (ipvs->sysctl_secure_tcp) {\r\ncase 0:\r\nif (old_secure_tcp >= 2)\r\nto_change = 0;\r\nbreak;\r\ncase 1:\r\nif (nomem) {\r\nif (old_secure_tcp < 2)\r\nto_change = 1;\r\nipvs->sysctl_secure_tcp = 2;\r\n} else {\r\nif (old_secure_tcp >= 2)\r\nto_change = 0;\r\n}\r\nbreak;\r\ncase 2:\r\nif (nomem) {\r\nif (old_secure_tcp < 2)\r\nto_change = 1;\r\n} else {\r\nif (old_secure_tcp >= 2)\r\nto_change = 0;\r\nipvs->sysctl_secure_tcp = 1;\r\n}\r\nbreak;\r\ncase 3:\r\nif (old_secure_tcp < 2)\r\nto_change = 1;\r\nbreak;\r\n}\r\nold_secure_tcp = ipvs->sysctl_secure_tcp;\r\nif (to_change >= 0)\r\nip_vs_protocol_timeout_change(ipvs,\r\nipvs->sysctl_secure_tcp > 1);\r\nspin_unlock(&ipvs->securetcp_lock);\r\nlocal_bh_enable();\r\n}\r\nstatic void defense_work_handler(struct work_struct *work)\r\n{\r\nstruct netns_ipvs *ipvs =\r\ncontainer_of(work, struct netns_ipvs, defense_work.work);\r\nupdate_defense_level(ipvs);\r\nif (atomic_read(&ipvs->dropentry))\r\nip_vs_random_dropentry(ipvs);\r\nschedule_delayed_work(&ipvs->defense_work, DEFENSE_TIMER_PERIOD);\r\n}\r\nint\r\nip_vs_use_count_inc(void)\r\n{\r\nreturn try_module_get(THIS_MODULE);\r\n}\r\nvoid\r\nip_vs_use_count_dec(void)\r\n{\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic inline unsigned int\r\nip_vs_svc_hashkey(struct netns_ipvs *ipvs, int af, unsigned int proto,\r\nconst union nf_inet_addr *addr, __be16 port)\r\n{\r\nregister unsigned int porth = ntohs(port);\r\n__be32 addr_fold = addr->ip;\r\n__u32 ahash;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\naddr_fold = addr->ip6[0]^addr->ip6[1]^\r\naddr->ip6[2]^addr->ip6[3];\r\n#endif\r\nahash = ntohl(addr_fold);\r\nahash ^= ((size_t) ipvs >> 8);\r\nreturn (proto ^ ahash ^ (porth >> IP_VS_SVC_TAB_BITS) ^ porth) &\r\nIP_VS_SVC_TAB_MASK;\r\n}\r\nstatic inline unsigned int ip_vs_svc_fwm_hashkey(struct netns_ipvs *ipvs, __u32 fwmark)\r\n{\r\nreturn (((size_t)ipvs>>8) ^ fwmark) & IP_VS_SVC_TAB_MASK;\r\n}\r\nstatic int ip_vs_svc_hash(struct ip_vs_service *svc)\r\n{\r\nunsigned int hash;\r\nif (svc->flags & IP_VS_SVC_F_HASHED) {\r\npr_err("%s(): request for already hashed, called from %pF\n",\r\n__func__, __builtin_return_address(0));\r\nreturn 0;\r\n}\r\nif (svc->fwmark == 0) {\r\nhash = ip_vs_svc_hashkey(svc->ipvs, svc->af, svc->protocol,\r\n&svc->addr, svc->port);\r\nhlist_add_head_rcu(&svc->s_list, &ip_vs_svc_table[hash]);\r\n} else {\r\nhash = ip_vs_svc_fwm_hashkey(svc->ipvs, svc->fwmark);\r\nhlist_add_head_rcu(&svc->f_list, &ip_vs_svc_fwm_table[hash]);\r\n}\r\nsvc->flags |= IP_VS_SVC_F_HASHED;\r\natomic_inc(&svc->refcnt);\r\nreturn 1;\r\n}\r\nstatic int ip_vs_svc_unhash(struct ip_vs_service *svc)\r\n{\r\nif (!(svc->flags & IP_VS_SVC_F_HASHED)) {\r\npr_err("%s(): request for unhash flagged, called from %pF\n",\r\n__func__, __builtin_return_address(0));\r\nreturn 0;\r\n}\r\nif (svc->fwmark == 0) {\r\nhlist_del_rcu(&svc->s_list);\r\n} else {\r\nhlist_del_rcu(&svc->f_list);\r\n}\r\nsvc->flags &= ~IP_VS_SVC_F_HASHED;\r\natomic_dec(&svc->refcnt);\r\nreturn 1;\r\n}\r\nstatic inline struct ip_vs_service *\r\n__ip_vs_service_find(struct netns_ipvs *ipvs, int af, __u16 protocol,\r\nconst union nf_inet_addr *vaddr, __be16 vport)\r\n{\r\nunsigned int hash;\r\nstruct ip_vs_service *svc;\r\nhash = ip_vs_svc_hashkey(ipvs, af, protocol, vaddr, vport);\r\nhlist_for_each_entry_rcu(svc, &ip_vs_svc_table[hash], s_list) {\r\nif ((svc->af == af)\r\n&& ip_vs_addr_equal(af, &svc->addr, vaddr)\r\n&& (svc->port == vport)\r\n&& (svc->protocol == protocol)\r\n&& (svc->ipvs == ipvs)) {\r\nreturn svc;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct ip_vs_service *\r\n__ip_vs_svc_fwm_find(struct netns_ipvs *ipvs, int af, __u32 fwmark)\r\n{\r\nunsigned int hash;\r\nstruct ip_vs_service *svc;\r\nhash = ip_vs_svc_fwm_hashkey(ipvs, fwmark);\r\nhlist_for_each_entry_rcu(svc, &ip_vs_svc_fwm_table[hash], f_list) {\r\nif (svc->fwmark == fwmark && svc->af == af\r\n&& (svc->ipvs == ipvs)) {\r\nreturn svc;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct ip_vs_service *\r\nip_vs_service_find(struct netns_ipvs *ipvs, int af, __u32 fwmark, __u16 protocol,\r\nconst union nf_inet_addr *vaddr, __be16 vport)\r\n{\r\nstruct ip_vs_service *svc;\r\nif (fwmark) {\r\nsvc = __ip_vs_svc_fwm_find(ipvs, af, fwmark);\r\nif (svc)\r\ngoto out;\r\n}\r\nsvc = __ip_vs_service_find(ipvs, af, protocol, vaddr, vport);\r\nif (svc == NULL\r\n&& protocol == IPPROTO_TCP\r\n&& atomic_read(&ipvs->ftpsvc_counter)\r\n&& (vport == FTPDATA || ntohs(vport) >= PROT_SOCK)) {\r\nsvc = __ip_vs_service_find(ipvs, af, protocol, vaddr, FTPPORT);\r\n}\r\nif (svc == NULL\r\n&& atomic_read(&ipvs->nullsvc_counter)) {\r\nsvc = __ip_vs_service_find(ipvs, af, protocol, vaddr, 0);\r\n}\r\nout:\r\nIP_VS_DBG_BUF(9, "lookup service: fwm %u %s %s:%u %s\n",\r\nfwmark, ip_vs_proto_name(protocol),\r\nIP_VS_DBG_ADDR(af, vaddr), ntohs(vport),\r\nsvc ? "hit" : "not hit");\r\nreturn svc;\r\n}\r\nstatic inline void\r\n__ip_vs_bind_svc(struct ip_vs_dest *dest, struct ip_vs_service *svc)\r\n{\r\natomic_inc(&svc->refcnt);\r\nrcu_assign_pointer(dest->svc, svc);\r\n}\r\nstatic void ip_vs_service_free(struct ip_vs_service *svc)\r\n{\r\nfree_percpu(svc->stats.cpustats);\r\nkfree(svc);\r\n}\r\nstatic void ip_vs_service_rcu_free(struct rcu_head *head)\r\n{\r\nstruct ip_vs_service *svc;\r\nsvc = container_of(head, struct ip_vs_service, rcu_head);\r\nip_vs_service_free(svc);\r\n}\r\nstatic void __ip_vs_svc_put(struct ip_vs_service *svc, bool do_delay)\r\n{\r\nif (atomic_dec_and_test(&svc->refcnt)) {\r\nIP_VS_DBG_BUF(3, "Removing service %u/%s:%u\n",\r\nsvc->fwmark,\r\nIP_VS_DBG_ADDR(svc->af, &svc->addr),\r\nntohs(svc->port));\r\nif (do_delay)\r\ncall_rcu(&svc->rcu_head, ip_vs_service_rcu_free);\r\nelse\r\nip_vs_service_free(svc);\r\n}\r\n}\r\nstatic inline unsigned int ip_vs_rs_hashkey(int af,\r\nconst union nf_inet_addr *addr,\r\n__be16 port)\r\n{\r\nregister unsigned int porth = ntohs(port);\r\n__be32 addr_fold = addr->ip;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\naddr_fold = addr->ip6[0]^addr->ip6[1]^\r\naddr->ip6[2]^addr->ip6[3];\r\n#endif\r\nreturn (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)\r\n& IP_VS_RTAB_MASK;\r\n}\r\nstatic void ip_vs_rs_hash(struct netns_ipvs *ipvs, struct ip_vs_dest *dest)\r\n{\r\nunsigned int hash;\r\nif (dest->in_rs_table)\r\nreturn;\r\nhash = ip_vs_rs_hashkey(dest->af, &dest->addr, dest->port);\r\nhlist_add_head_rcu(&dest->d_list, &ipvs->rs_table[hash]);\r\ndest->in_rs_table = 1;\r\n}\r\nstatic void ip_vs_rs_unhash(struct ip_vs_dest *dest)\r\n{\r\nif (dest->in_rs_table) {\r\nhlist_del_rcu(&dest->d_list);\r\ndest->in_rs_table = 0;\r\n}\r\n}\r\nbool ip_vs_has_real_service(struct netns_ipvs *ipvs, int af, __u16 protocol,\r\nconst union nf_inet_addr *daddr, __be16 dport)\r\n{\r\nunsigned int hash;\r\nstruct ip_vs_dest *dest;\r\nhash = ip_vs_rs_hashkey(af, daddr, dport);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(dest, &ipvs->rs_table[hash], d_list) {\r\nif (dest->port == dport &&\r\ndest->af == af &&\r\nip_vs_addr_equal(af, &dest->addr, daddr) &&\r\n(dest->protocol == protocol || dest->vfwmark)) {\r\nrcu_read_unlock();\r\nreturn true;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn false;\r\n}\r\nstruct ip_vs_dest *ip_vs_find_real_service(struct netns_ipvs *ipvs, int af,\r\n__u16 protocol,\r\nconst union nf_inet_addr *daddr,\r\n__be16 dport)\r\n{\r\nunsigned int hash;\r\nstruct ip_vs_dest *dest;\r\nhash = ip_vs_rs_hashkey(af, daddr, dport);\r\nhlist_for_each_entry_rcu(dest, &ipvs->rs_table[hash], d_list) {\r\nif (dest->port == dport &&\r\ndest->af == af &&\r\nip_vs_addr_equal(af, &dest->addr, daddr) &&\r\n(dest->protocol == protocol || dest->vfwmark)) {\r\nreturn dest;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ip_vs_dest *\r\nip_vs_lookup_dest(struct ip_vs_service *svc, int dest_af,\r\nconst union nf_inet_addr *daddr, __be16 dport)\r\n{\r\nstruct ip_vs_dest *dest;\r\nlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\r\nif ((dest->af == dest_af) &&\r\nip_vs_addr_equal(dest_af, &dest->addr, daddr) &&\r\n(dest->port == dport)) {\r\nreturn dest;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct ip_vs_dest *ip_vs_find_dest(struct netns_ipvs *ipvs, int svc_af, int dest_af,\r\nconst union nf_inet_addr *daddr,\r\n__be16 dport,\r\nconst union nf_inet_addr *vaddr,\r\n__be16 vport, __u16 protocol, __u32 fwmark,\r\n__u32 flags)\r\n{\r\nstruct ip_vs_dest *dest;\r\nstruct ip_vs_service *svc;\r\n__be16 port = dport;\r\nsvc = ip_vs_service_find(ipvs, svc_af, fwmark, protocol, vaddr, vport);\r\nif (!svc)\r\nreturn NULL;\r\nif (fwmark && (flags & IP_VS_CONN_F_FWD_MASK) != IP_VS_CONN_F_MASQ)\r\nport = 0;\r\ndest = ip_vs_lookup_dest(svc, dest_af, daddr, port);\r\nif (!dest)\r\ndest = ip_vs_lookup_dest(svc, dest_af, daddr, port ^ dport);\r\nreturn dest;\r\n}\r\nvoid ip_vs_dest_dst_rcu_free(struct rcu_head *head)\r\n{\r\nstruct ip_vs_dest_dst *dest_dst = container_of(head,\r\nstruct ip_vs_dest_dst,\r\nrcu_head);\r\ndst_release(dest_dst->dst_cache);\r\nkfree(dest_dst);\r\n}\r\nstatic void __ip_vs_dst_cache_reset(struct ip_vs_dest *dest)\r\n{\r\nstruct ip_vs_dest_dst *old;\r\nold = rcu_dereference_protected(dest->dest_dst, 1);\r\nif (old) {\r\nRCU_INIT_POINTER(dest->dest_dst, NULL);\r\ncall_rcu(&old->rcu_head, ip_vs_dest_dst_rcu_free);\r\n}\r\n}\r\nstatic struct ip_vs_dest *\r\nip_vs_trash_get_dest(struct ip_vs_service *svc, int dest_af,\r\nconst union nf_inet_addr *daddr, __be16 dport)\r\n{\r\nstruct ip_vs_dest *dest;\r\nstruct netns_ipvs *ipvs = svc->ipvs;\r\nspin_lock_bh(&ipvs->dest_trash_lock);\r\nlist_for_each_entry(dest, &ipvs->dest_trash, t_list) {\r\nIP_VS_DBG_BUF(3, "Destination %u/%s:%u still in trash, "\r\n"dest->refcnt=%d\n",\r\ndest->vfwmark,\r\nIP_VS_DBG_ADDR(dest->af, &dest->addr),\r\nntohs(dest->port),\r\natomic_read(&dest->refcnt));\r\nif (dest->af == dest_af &&\r\nip_vs_addr_equal(dest_af, &dest->addr, daddr) &&\r\ndest->port == dport &&\r\ndest->vfwmark == svc->fwmark &&\r\ndest->protocol == svc->protocol &&\r\n(svc->fwmark ||\r\n(ip_vs_addr_equal(svc->af, &dest->vaddr, &svc->addr) &&\r\ndest->vport == svc->port))) {\r\nlist_del(&dest->t_list);\r\nip_vs_dest_hold(dest);\r\ngoto out;\r\n}\r\n}\r\ndest = NULL;\r\nout:\r\nspin_unlock_bh(&ipvs->dest_trash_lock);\r\nreturn dest;\r\n}\r\nstatic void ip_vs_dest_free(struct ip_vs_dest *dest)\r\n{\r\nstruct ip_vs_service *svc = rcu_dereference_protected(dest->svc, 1);\r\n__ip_vs_dst_cache_reset(dest);\r\n__ip_vs_svc_put(svc, false);\r\nfree_percpu(dest->stats.cpustats);\r\nip_vs_dest_put_and_free(dest);\r\n}\r\nstatic void ip_vs_trash_cleanup(struct netns_ipvs *ipvs)\r\n{\r\nstruct ip_vs_dest *dest, *nxt;\r\ndel_timer_sync(&ipvs->dest_trash_timer);\r\nlist_for_each_entry_safe(dest, nxt, &ipvs->dest_trash, t_list) {\r\nlist_del(&dest->t_list);\r\nip_vs_dest_free(dest);\r\n}\r\n}\r\nstatic void\r\nip_vs_copy_stats(struct ip_vs_kstats *dst, struct ip_vs_stats *src)\r\n{\r\n#define IP_VS_SHOW_STATS_COUNTER(c) dst->c = src->kstats.c - src->kstats0.c\r\nspin_lock_bh(&src->lock);\r\nIP_VS_SHOW_STATS_COUNTER(conns);\r\nIP_VS_SHOW_STATS_COUNTER(inpkts);\r\nIP_VS_SHOW_STATS_COUNTER(outpkts);\r\nIP_VS_SHOW_STATS_COUNTER(inbytes);\r\nIP_VS_SHOW_STATS_COUNTER(outbytes);\r\nip_vs_read_estimator(dst, src);\r\nspin_unlock_bh(&src->lock);\r\n}\r\nstatic void\r\nip_vs_export_stats_user(struct ip_vs_stats_user *dst, struct ip_vs_kstats *src)\r\n{\r\ndst->conns = (u32)src->conns;\r\ndst->inpkts = (u32)src->inpkts;\r\ndst->outpkts = (u32)src->outpkts;\r\ndst->inbytes = src->inbytes;\r\ndst->outbytes = src->outbytes;\r\ndst->cps = (u32)src->cps;\r\ndst->inpps = (u32)src->inpps;\r\ndst->outpps = (u32)src->outpps;\r\ndst->inbps = (u32)src->inbps;\r\ndst->outbps = (u32)src->outbps;\r\n}\r\nstatic void\r\nip_vs_zero_stats(struct ip_vs_stats *stats)\r\n{\r\nspin_lock_bh(&stats->lock);\r\n#define IP_VS_ZERO_STATS_COUNTER(c) stats->kstats0.c = stats->kstats.c\r\nIP_VS_ZERO_STATS_COUNTER(conns);\r\nIP_VS_ZERO_STATS_COUNTER(inpkts);\r\nIP_VS_ZERO_STATS_COUNTER(outpkts);\r\nIP_VS_ZERO_STATS_COUNTER(inbytes);\r\nIP_VS_ZERO_STATS_COUNTER(outbytes);\r\nip_vs_zero_estimator(stats);\r\nspin_unlock_bh(&stats->lock);\r\n}\r\nstatic void\r\n__ip_vs_update_dest(struct ip_vs_service *svc, struct ip_vs_dest *dest,\r\nstruct ip_vs_dest_user_kern *udest, int add)\r\n{\r\nstruct netns_ipvs *ipvs = svc->ipvs;\r\nstruct ip_vs_service *old_svc;\r\nstruct ip_vs_scheduler *sched;\r\nint conn_flags;\r\nBUG_ON(!add && udest->af != dest->af);\r\nif (add && udest->af != svc->af)\r\nipvs->mixed_address_family_dests++;\r\natomic_set(&dest->weight, udest->weight);\r\nconn_flags = udest->conn_flags & IP_VS_CONN_F_DEST_MASK;\r\nconn_flags |= IP_VS_CONN_F_INACTIVE;\r\nif ((conn_flags & IP_VS_CONN_F_FWD_MASK) != IP_VS_CONN_F_MASQ) {\r\nconn_flags |= IP_VS_CONN_F_NOOUTPUT;\r\n} else {\r\nip_vs_rs_hash(ipvs, dest);\r\n}\r\natomic_set(&dest->conn_flags, conn_flags);\r\nold_svc = rcu_dereference_protected(dest->svc, 1);\r\nif (!old_svc) {\r\n__ip_vs_bind_svc(dest, svc);\r\n} else {\r\nif (old_svc != svc) {\r\nip_vs_zero_stats(&dest->stats);\r\n__ip_vs_bind_svc(dest, svc);\r\n__ip_vs_svc_put(old_svc, true);\r\n}\r\n}\r\ndest->flags |= IP_VS_DEST_F_AVAILABLE;\r\nif (udest->u_threshold == 0 || udest->u_threshold > dest->u_threshold)\r\ndest->flags &= ~IP_VS_DEST_F_OVERLOAD;\r\ndest->u_threshold = udest->u_threshold;\r\ndest->l_threshold = udest->l_threshold;\r\ndest->af = udest->af;\r\nspin_lock_bh(&dest->dst_lock);\r\n__ip_vs_dst_cache_reset(dest);\r\nspin_unlock_bh(&dest->dst_lock);\r\nif (add) {\r\nip_vs_start_estimator(svc->ipvs, &dest->stats);\r\nlist_add_rcu(&dest->n_list, &svc->destinations);\r\nsvc->num_dests++;\r\nsched = rcu_dereference_protected(svc->scheduler, 1);\r\nif (sched && sched->add_dest)\r\nsched->add_dest(svc, dest);\r\n} else {\r\nsched = rcu_dereference_protected(svc->scheduler, 1);\r\nif (sched && sched->upd_dest)\r\nsched->upd_dest(svc, dest);\r\n}\r\n}\r\nstatic int\r\nip_vs_new_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest,\r\nstruct ip_vs_dest **dest_p)\r\n{\r\nstruct ip_vs_dest *dest;\r\nunsigned int atype, i;\r\nEnterFunction(2);\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (udest->af == AF_INET6) {\r\natype = ipv6_addr_type(&udest->addr.in6);\r\nif ((!(atype & IPV6_ADDR_UNICAST) ||\r\natype & IPV6_ADDR_LINKLOCAL) &&\r\n!__ip_vs_addr_is_local_v6(svc->ipvs->net, &udest->addr.in6))\r\nreturn -EINVAL;\r\n} else\r\n#endif\r\n{\r\natype = inet_addr_type(svc->ipvs->net, udest->addr.ip);\r\nif (atype != RTN_LOCAL && atype != RTN_UNICAST)\r\nreturn -EINVAL;\r\n}\r\ndest = kzalloc(sizeof(struct ip_vs_dest), GFP_KERNEL);\r\nif (dest == NULL)\r\nreturn -ENOMEM;\r\ndest->stats.cpustats = alloc_percpu(struct ip_vs_cpu_stats);\r\nif (!dest->stats.cpustats)\r\ngoto err_alloc;\r\nfor_each_possible_cpu(i) {\r\nstruct ip_vs_cpu_stats *ip_vs_dest_stats;\r\nip_vs_dest_stats = per_cpu_ptr(dest->stats.cpustats, i);\r\nu64_stats_init(&ip_vs_dest_stats->syncp);\r\n}\r\ndest->af = udest->af;\r\ndest->protocol = svc->protocol;\r\ndest->vaddr = svc->addr;\r\ndest->vport = svc->port;\r\ndest->vfwmark = svc->fwmark;\r\nip_vs_addr_copy(udest->af, &dest->addr, &udest->addr);\r\ndest->port = udest->port;\r\natomic_set(&dest->activeconns, 0);\r\natomic_set(&dest->inactconns, 0);\r\natomic_set(&dest->persistconns, 0);\r\natomic_set(&dest->refcnt, 1);\r\nINIT_HLIST_NODE(&dest->d_list);\r\nspin_lock_init(&dest->dst_lock);\r\nspin_lock_init(&dest->stats.lock);\r\n__ip_vs_update_dest(svc, dest, udest, 1);\r\n*dest_p = dest;\r\nLeaveFunction(2);\r\nreturn 0;\r\nerr_alloc:\r\nkfree(dest);\r\nreturn -ENOMEM;\r\n}\r\nstatic int\r\nip_vs_add_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\r\n{\r\nstruct ip_vs_dest *dest;\r\nunion nf_inet_addr daddr;\r\n__be16 dport = udest->port;\r\nint ret;\r\nEnterFunction(2);\r\nif (udest->weight < 0) {\r\npr_err("%s(): server weight less than zero\n", __func__);\r\nreturn -ERANGE;\r\n}\r\nif (udest->l_threshold > udest->u_threshold) {\r\npr_err("%s(): lower threshold is higher than upper threshold\n",\r\n__func__);\r\nreturn -ERANGE;\r\n}\r\nip_vs_addr_copy(udest->af, &daddr, &udest->addr);\r\nrcu_read_lock();\r\ndest = ip_vs_lookup_dest(svc, udest->af, &daddr, dport);\r\nrcu_read_unlock();\r\nif (dest != NULL) {\r\nIP_VS_DBG(1, "%s(): dest already exists\n", __func__);\r\nreturn -EEXIST;\r\n}\r\ndest = ip_vs_trash_get_dest(svc, udest->af, &daddr, dport);\r\nif (dest != NULL) {\r\nIP_VS_DBG_BUF(3, "Get destination %s:%u from trash, "\r\n"dest->refcnt=%d, service %u/%s:%u\n",\r\nIP_VS_DBG_ADDR(udest->af, &daddr), ntohs(dport),\r\natomic_read(&dest->refcnt),\r\ndest->vfwmark,\r\nIP_VS_DBG_ADDR(svc->af, &dest->vaddr),\r\nntohs(dest->vport));\r\n__ip_vs_update_dest(svc, dest, udest, 1);\r\nret = 0;\r\n} else {\r\nret = ip_vs_new_dest(svc, udest, &dest);\r\n}\r\nLeaveFunction(2);\r\nreturn ret;\r\n}\r\nstatic int\r\nip_vs_edit_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\r\n{\r\nstruct ip_vs_dest *dest;\r\nunion nf_inet_addr daddr;\r\n__be16 dport = udest->port;\r\nEnterFunction(2);\r\nif (udest->weight < 0) {\r\npr_err("%s(): server weight less than zero\n", __func__);\r\nreturn -ERANGE;\r\n}\r\nif (udest->l_threshold > udest->u_threshold) {\r\npr_err("%s(): lower threshold is higher than upper threshold\n",\r\n__func__);\r\nreturn -ERANGE;\r\n}\r\nip_vs_addr_copy(udest->af, &daddr, &udest->addr);\r\nrcu_read_lock();\r\ndest = ip_vs_lookup_dest(svc, udest->af, &daddr, dport);\r\nrcu_read_unlock();\r\nif (dest == NULL) {\r\nIP_VS_DBG(1, "%s(): dest doesn't exist\n", __func__);\r\nreturn -ENOENT;\r\n}\r\n__ip_vs_update_dest(svc, dest, udest, 0);\r\nLeaveFunction(2);\r\nreturn 0;\r\n}\r\nstatic void __ip_vs_del_dest(struct netns_ipvs *ipvs, struct ip_vs_dest *dest,\r\nbool cleanup)\r\n{\r\nip_vs_stop_estimator(ipvs, &dest->stats);\r\nip_vs_rs_unhash(dest);\r\nspin_lock_bh(&ipvs->dest_trash_lock);\r\nIP_VS_DBG_BUF(3, "Moving dest %s:%u into trash, dest->refcnt=%d\n",\r\nIP_VS_DBG_ADDR(dest->af, &dest->addr), ntohs(dest->port),\r\natomic_read(&dest->refcnt));\r\nif (list_empty(&ipvs->dest_trash) && !cleanup)\r\nmod_timer(&ipvs->dest_trash_timer,\r\njiffies + (IP_VS_DEST_TRASH_PERIOD >> 1));\r\nlist_add(&dest->t_list, &ipvs->dest_trash);\r\ndest->idle_start = 0;\r\nspin_unlock_bh(&ipvs->dest_trash_lock);\r\nip_vs_dest_put(dest);\r\n}\r\nstatic void __ip_vs_unlink_dest(struct ip_vs_service *svc,\r\nstruct ip_vs_dest *dest,\r\nint svcupd)\r\n{\r\ndest->flags &= ~IP_VS_DEST_F_AVAILABLE;\r\nlist_del_rcu(&dest->n_list);\r\nsvc->num_dests--;\r\nif (dest->af != svc->af)\r\nsvc->ipvs->mixed_address_family_dests--;\r\nif (svcupd) {\r\nstruct ip_vs_scheduler *sched;\r\nsched = rcu_dereference_protected(svc->scheduler, 1);\r\nif (sched && sched->del_dest)\r\nsched->del_dest(svc, dest);\r\n}\r\n}\r\nstatic int\r\nip_vs_del_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\r\n{\r\nstruct ip_vs_dest *dest;\r\n__be16 dport = udest->port;\r\nEnterFunction(2);\r\nrcu_read_lock();\r\ndest = ip_vs_lookup_dest(svc, udest->af, &udest->addr, dport);\r\nrcu_read_unlock();\r\nif (dest == NULL) {\r\nIP_VS_DBG(1, "%s(): destination not found!\n", __func__);\r\nreturn -ENOENT;\r\n}\r\n__ip_vs_unlink_dest(svc, dest, 1);\r\n__ip_vs_del_dest(svc->ipvs, dest, false);\r\nLeaveFunction(2);\r\nreturn 0;\r\n}\r\nstatic void ip_vs_dest_trash_expire(unsigned long data)\r\n{\r\nstruct netns_ipvs *ipvs = (struct netns_ipvs *)data;\r\nstruct ip_vs_dest *dest, *next;\r\nunsigned long now = jiffies;\r\nspin_lock(&ipvs->dest_trash_lock);\r\nlist_for_each_entry_safe(dest, next, &ipvs->dest_trash, t_list) {\r\nif (atomic_read(&dest->refcnt) > 0)\r\ncontinue;\r\nif (dest->idle_start) {\r\nif (time_before(now, dest->idle_start +\r\nIP_VS_DEST_TRASH_PERIOD))\r\ncontinue;\r\n} else {\r\ndest->idle_start = max(1UL, now);\r\ncontinue;\r\n}\r\nIP_VS_DBG_BUF(3, "Removing destination %u/%s:%u from trash\n",\r\ndest->vfwmark,\r\nIP_VS_DBG_ADDR(dest->af, &dest->addr),\r\nntohs(dest->port));\r\nlist_del(&dest->t_list);\r\nip_vs_dest_free(dest);\r\n}\r\nif (!list_empty(&ipvs->dest_trash))\r\nmod_timer(&ipvs->dest_trash_timer,\r\njiffies + (IP_VS_DEST_TRASH_PERIOD >> 1));\r\nspin_unlock(&ipvs->dest_trash_lock);\r\n}\r\nstatic int\r\nip_vs_add_service(struct netns_ipvs *ipvs, struct ip_vs_service_user_kern *u,\r\nstruct ip_vs_service **svc_p)\r\n{\r\nint ret = 0, i;\r\nstruct ip_vs_scheduler *sched = NULL;\r\nstruct ip_vs_pe *pe = NULL;\r\nstruct ip_vs_service *svc = NULL;\r\nip_vs_use_count_inc();\r\nif (strcmp(u->sched_name, "none")) {\r\nsched = ip_vs_scheduler_get(u->sched_name);\r\nif (!sched) {\r\npr_info("Scheduler module ip_vs_%s not found\n",\r\nu->sched_name);\r\nret = -ENOENT;\r\ngoto out_err;\r\n}\r\n}\r\nif (u->pe_name && *u->pe_name) {\r\npe = ip_vs_pe_getbyname(u->pe_name);\r\nif (pe == NULL) {\r\npr_info("persistence engine module ip_vs_pe_%s "\r\n"not found\n", u->pe_name);\r\nret = -ENOENT;\r\ngoto out_err;\r\n}\r\n}\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (u->af == AF_INET6) {\r\n__u32 plen = (__force __u32) u->netmask;\r\nif (plen < 1 || plen > 128) {\r\nret = -EINVAL;\r\ngoto out_err;\r\n}\r\n}\r\n#endif\r\nsvc = kzalloc(sizeof(struct ip_vs_service), GFP_KERNEL);\r\nif (svc == NULL) {\r\nIP_VS_DBG(1, "%s(): no memory\n", __func__);\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nsvc->stats.cpustats = alloc_percpu(struct ip_vs_cpu_stats);\r\nif (!svc->stats.cpustats) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nfor_each_possible_cpu(i) {\r\nstruct ip_vs_cpu_stats *ip_vs_stats;\r\nip_vs_stats = per_cpu_ptr(svc->stats.cpustats, i);\r\nu64_stats_init(&ip_vs_stats->syncp);\r\n}\r\natomic_set(&svc->refcnt, 0);\r\nsvc->af = u->af;\r\nsvc->protocol = u->protocol;\r\nip_vs_addr_copy(svc->af, &svc->addr, &u->addr);\r\nsvc->port = u->port;\r\nsvc->fwmark = u->fwmark;\r\nsvc->flags = u->flags;\r\nsvc->timeout = u->timeout * HZ;\r\nsvc->netmask = u->netmask;\r\nsvc->ipvs = ipvs;\r\nINIT_LIST_HEAD(&svc->destinations);\r\nspin_lock_init(&svc->sched_lock);\r\nspin_lock_init(&svc->stats.lock);\r\nif (sched) {\r\nret = ip_vs_bind_scheduler(svc, sched);\r\nif (ret)\r\ngoto out_err;\r\nsched = NULL;\r\n}\r\nRCU_INIT_POINTER(svc->pe, pe);\r\npe = NULL;\r\nif (svc->port == FTPPORT)\r\natomic_inc(&ipvs->ftpsvc_counter);\r\nelse if (svc->port == 0)\r\natomic_inc(&ipvs->nullsvc_counter);\r\nif (svc->pe && svc->pe->conn_out)\r\natomic_inc(&ipvs->conn_out_counter);\r\nip_vs_start_estimator(ipvs, &svc->stats);\r\nif (svc->af == AF_INET)\r\nipvs->num_services++;\r\nip_vs_svc_hash(svc);\r\n*svc_p = svc;\r\nipvs->enable = 1;\r\nreturn 0;\r\nout_err:\r\nif (svc != NULL) {\r\nip_vs_unbind_scheduler(svc, sched);\r\nip_vs_service_free(svc);\r\n}\r\nip_vs_scheduler_put(sched);\r\nip_vs_pe_put(pe);\r\nip_vs_use_count_dec();\r\nreturn ret;\r\n}\r\nstatic int\r\nip_vs_edit_service(struct ip_vs_service *svc, struct ip_vs_service_user_kern *u)\r\n{\r\nstruct ip_vs_scheduler *sched = NULL, *old_sched;\r\nstruct ip_vs_pe *pe = NULL, *old_pe = NULL;\r\nint ret = 0;\r\nbool new_pe_conn_out, old_pe_conn_out;\r\nif (strcmp(u->sched_name, "none")) {\r\nsched = ip_vs_scheduler_get(u->sched_name);\r\nif (!sched) {\r\npr_info("Scheduler module ip_vs_%s not found\n",\r\nu->sched_name);\r\nreturn -ENOENT;\r\n}\r\n}\r\nold_sched = sched;\r\nif (u->pe_name && *u->pe_name) {\r\npe = ip_vs_pe_getbyname(u->pe_name);\r\nif (pe == NULL) {\r\npr_info("persistence engine module ip_vs_pe_%s "\r\n"not found\n", u->pe_name);\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nold_pe = pe;\r\n}\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (u->af == AF_INET6) {\r\n__u32 plen = (__force __u32) u->netmask;\r\nif (plen < 1 || plen > 128) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\n#endif\r\nold_sched = rcu_dereference_protected(svc->scheduler, 1);\r\nif (sched != old_sched) {\r\nif (old_sched) {\r\nip_vs_unbind_scheduler(svc, old_sched);\r\nRCU_INIT_POINTER(svc->scheduler, NULL);\r\nsynchronize_rcu();\r\n}\r\nif (sched) {\r\nret = ip_vs_bind_scheduler(svc, sched);\r\nif (ret) {\r\nip_vs_scheduler_put(sched);\r\ngoto out;\r\n}\r\n}\r\n}\r\nsvc->flags = u->flags | IP_VS_SVC_F_HASHED;\r\nsvc->timeout = u->timeout * HZ;\r\nsvc->netmask = u->netmask;\r\nold_pe = rcu_dereference_protected(svc->pe, 1);\r\nif (pe != old_pe) {\r\nrcu_assign_pointer(svc->pe, pe);\r\nnew_pe_conn_out = (pe && pe->conn_out) ? true : false;\r\nold_pe_conn_out = (old_pe && old_pe->conn_out) ? true : false;\r\nif (new_pe_conn_out && !old_pe_conn_out)\r\natomic_inc(&svc->ipvs->conn_out_counter);\r\nif (old_pe_conn_out && !new_pe_conn_out)\r\natomic_dec(&svc->ipvs->conn_out_counter);\r\n}\r\nout:\r\nip_vs_scheduler_put(old_sched);\r\nip_vs_pe_put(old_pe);\r\nreturn ret;\r\n}\r\nstatic void __ip_vs_del_service(struct ip_vs_service *svc, bool cleanup)\r\n{\r\nstruct ip_vs_dest *dest, *nxt;\r\nstruct ip_vs_scheduler *old_sched;\r\nstruct ip_vs_pe *old_pe;\r\nstruct netns_ipvs *ipvs = svc->ipvs;\r\nif (svc->af == AF_INET)\r\nipvs->num_services--;\r\nip_vs_stop_estimator(svc->ipvs, &svc->stats);\r\nold_sched = rcu_dereference_protected(svc->scheduler, 1);\r\nip_vs_unbind_scheduler(svc, old_sched);\r\nip_vs_scheduler_put(old_sched);\r\nold_pe = rcu_dereference_protected(svc->pe, 1);\r\nif (old_pe && old_pe->conn_out)\r\natomic_dec(&ipvs->conn_out_counter);\r\nip_vs_pe_put(old_pe);\r\nlist_for_each_entry_safe(dest, nxt, &svc->destinations, n_list) {\r\n__ip_vs_unlink_dest(svc, dest, 0);\r\n__ip_vs_del_dest(svc->ipvs, dest, cleanup);\r\n}\r\nif (svc->port == FTPPORT)\r\natomic_dec(&ipvs->ftpsvc_counter);\r\nelse if (svc->port == 0)\r\natomic_dec(&ipvs->nullsvc_counter);\r\n__ip_vs_svc_put(svc, true);\r\nip_vs_use_count_dec();\r\n}\r\nstatic void ip_vs_unlink_service(struct ip_vs_service *svc, bool cleanup)\r\n{\r\natomic_inc(&svc->refcnt);\r\nip_vs_svc_unhash(svc);\r\n__ip_vs_del_service(svc, cleanup);\r\n}\r\nstatic int ip_vs_del_service(struct ip_vs_service *svc)\r\n{\r\nif (svc == NULL)\r\nreturn -EEXIST;\r\nip_vs_unlink_service(svc, false);\r\nreturn 0;\r\n}\r\nstatic int ip_vs_flush(struct netns_ipvs *ipvs, bool cleanup)\r\n{\r\nint idx;\r\nstruct ip_vs_service *svc;\r\nstruct hlist_node *n;\r\nfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\r\nhlist_for_each_entry_safe(svc, n, &ip_vs_svc_table[idx],\r\ns_list) {\r\nif (svc->ipvs == ipvs)\r\nip_vs_unlink_service(svc, cleanup);\r\n}\r\n}\r\nfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\r\nhlist_for_each_entry_safe(svc, n, &ip_vs_svc_fwm_table[idx],\r\nf_list) {\r\nif (svc->ipvs == ipvs)\r\nip_vs_unlink_service(svc, cleanup);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid ip_vs_service_net_cleanup(struct netns_ipvs *ipvs)\r\n{\r\nEnterFunction(2);\r\nmutex_lock(&__ip_vs_mutex);\r\nip_vs_flush(ipvs, true);\r\nmutex_unlock(&__ip_vs_mutex);\r\nLeaveFunction(2);\r\n}\r\nstatic inline void\r\nip_vs_forget_dev(struct ip_vs_dest *dest, struct net_device *dev)\r\n{\r\nstruct ip_vs_dest_dst *dest_dst;\r\nspin_lock_bh(&dest->dst_lock);\r\ndest_dst = rcu_dereference_protected(dest->dest_dst, 1);\r\nif (dest_dst && dest_dst->dst_cache->dev == dev) {\r\nIP_VS_DBG_BUF(3, "Reset dev:%s dest %s:%u ,dest->refcnt=%d\n",\r\ndev->name,\r\nIP_VS_DBG_ADDR(dest->af, &dest->addr),\r\nntohs(dest->port),\r\natomic_read(&dest->refcnt));\r\n__ip_vs_dst_cache_reset(dest);\r\n}\r\nspin_unlock_bh(&dest->dst_lock);\r\n}\r\nstatic int ip_vs_dst_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct net *net = dev_net(dev);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nstruct ip_vs_service *svc;\r\nstruct ip_vs_dest *dest;\r\nunsigned int idx;\r\nif (event != NETDEV_DOWN || !ipvs)\r\nreturn NOTIFY_DONE;\r\nIP_VS_DBG(3, "%s() dev=%s\n", __func__, dev->name);\r\nEnterFunction(2);\r\nmutex_lock(&__ip_vs_mutex);\r\nfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\r\nhlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\r\nif (svc->ipvs == ipvs) {\r\nlist_for_each_entry(dest, &svc->destinations,\r\nn_list) {\r\nip_vs_forget_dev(dest, dev);\r\n}\r\n}\r\n}\r\nhlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\r\nif (svc->ipvs == ipvs) {\r\nlist_for_each_entry(dest, &svc->destinations,\r\nn_list) {\r\nip_vs_forget_dev(dest, dev);\r\n}\r\n}\r\n}\r\n}\r\nspin_lock_bh(&ipvs->dest_trash_lock);\r\nlist_for_each_entry(dest, &ipvs->dest_trash, t_list) {\r\nip_vs_forget_dev(dest, dev);\r\n}\r\nspin_unlock_bh(&ipvs->dest_trash_lock);\r\nmutex_unlock(&__ip_vs_mutex);\r\nLeaveFunction(2);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int ip_vs_zero_service(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_dest *dest;\r\nlist_for_each_entry(dest, &svc->destinations, n_list) {\r\nip_vs_zero_stats(&dest->stats);\r\n}\r\nip_vs_zero_stats(&svc->stats);\r\nreturn 0;\r\n}\r\nstatic int ip_vs_zero_all(struct netns_ipvs *ipvs)\r\n{\r\nint idx;\r\nstruct ip_vs_service *svc;\r\nfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\r\nhlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\r\nif (svc->ipvs == ipvs)\r\nip_vs_zero_service(svc);\r\n}\r\n}\r\nfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\r\nhlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\r\nif (svc->ipvs == ipvs)\r\nip_vs_zero_service(svc);\r\n}\r\n}\r\nip_vs_zero_stats(&ipvs->tot_stats);\r\nreturn 0;\r\n}\r\nstatic int\r\nproc_do_defense_mode(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nstruct netns_ipvs *ipvs = table->extra2;\r\nint *valp = table->data;\r\nint val = *valp;\r\nint rc;\r\nrc = proc_dointvec(table, write, buffer, lenp, ppos);\r\nif (write && (*valp != val)) {\r\nif ((*valp < 0) || (*valp > 3)) {\r\n*valp = val;\r\n} else {\r\nupdate_defense_level(ipvs);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nproc_do_sync_threshold(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint *valp = table->data;\r\nint val[2];\r\nint rc;\r\nmemcpy(val, valp, sizeof(val));\r\nrc = proc_dointvec(table, write, buffer, lenp, ppos);\r\nif (write && (valp[0] < 0 || valp[1] < 0 ||\r\n(valp[0] >= valp[1] && valp[1]))) {\r\nmemcpy(valp, val, sizeof(val));\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nproc_do_sync_mode(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint *valp = table->data;\r\nint val = *valp;\r\nint rc;\r\nrc = proc_dointvec(table, write, buffer, lenp, ppos);\r\nif (write && (*valp != val)) {\r\nif ((*valp < 0) || (*valp > 1)) {\r\n*valp = val;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nproc_do_sync_ports(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint *valp = table->data;\r\nint val = *valp;\r\nint rc;\r\nrc = proc_dointvec(table, write, buffer, lenp, ppos);\r\nif (write && (*valp != val)) {\r\nif (*valp < 1 || !is_power_of_2(*valp)) {\r\n*valp = val;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic inline const char *ip_vs_fwd_name(unsigned int flags)\r\n{\r\nswitch (flags & IP_VS_CONN_F_FWD_MASK) {\r\ncase IP_VS_CONN_F_LOCALNODE:\r\nreturn "Local";\r\ncase IP_VS_CONN_F_TUNNEL:\r\nreturn "Tunnel";\r\ncase IP_VS_CONN_F_DROUTE:\r\nreturn "Route";\r\ndefault:\r\nreturn "Masq";\r\n}\r\n}\r\nstatic struct ip_vs_service *ip_vs_info_array(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nstruct ip_vs_iter *iter = seq->private;\r\nint idx;\r\nstruct ip_vs_service *svc;\r\nfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\r\nhlist_for_each_entry_rcu(svc, &ip_vs_svc_table[idx], s_list) {\r\nif ((svc->ipvs == ipvs) && pos-- == 0) {\r\niter->table = ip_vs_svc_table;\r\niter->bucket = idx;\r\nreturn svc;\r\n}\r\n}\r\n}\r\nfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\r\nhlist_for_each_entry_rcu(svc, &ip_vs_svc_fwm_table[idx],\r\nf_list) {\r\nif ((svc->ipvs == ipvs) && pos-- == 0) {\r\niter->table = ip_vs_svc_fwm_table;\r\niter->bucket = idx;\r\nreturn svc;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *ip_vs_info_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock();\r\nreturn *pos ? ip_vs_info_array(seq, *pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *ip_vs_info_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct hlist_node *e;\r\nstruct ip_vs_iter *iter;\r\nstruct ip_vs_service *svc;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN)\r\nreturn ip_vs_info_array(seq,0);\r\nsvc = v;\r\niter = seq->private;\r\nif (iter->table == ip_vs_svc_table) {\r\ne = rcu_dereference(hlist_next_rcu(&svc->s_list));\r\nif (e)\r\nreturn hlist_entry(e, struct ip_vs_service, s_list);\r\nwhile (++iter->bucket < IP_VS_SVC_TAB_SIZE) {\r\nhlist_for_each_entry_rcu(svc,\r\n&ip_vs_svc_table[iter->bucket],\r\ns_list) {\r\nreturn svc;\r\n}\r\n}\r\niter->table = ip_vs_svc_fwm_table;\r\niter->bucket = -1;\r\ngoto scan_fwmark;\r\n}\r\ne = rcu_dereference(hlist_next_rcu(&svc->f_list));\r\nif (e)\r\nreturn hlist_entry(e, struct ip_vs_service, f_list);\r\nscan_fwmark:\r\nwhile (++iter->bucket < IP_VS_SVC_TAB_SIZE) {\r\nhlist_for_each_entry_rcu(svc,\r\n&ip_vs_svc_fwm_table[iter->bucket],\r\nf_list)\r\nreturn svc;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ip_vs_info_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic int ip_vs_info_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq,\r\n"IP Virtual Server version %d.%d.%d (size=%d)\n",\r\nNVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);\r\nseq_puts(seq,\r\n"Prot LocalAddress:Port Scheduler Flags\n");\r\nseq_puts(seq,\r\n" -> RemoteAddress:Port Forward Weight ActiveConn InActConn\n");\r\n} else {\r\nconst struct ip_vs_service *svc = v;\r\nconst struct ip_vs_iter *iter = seq->private;\r\nconst struct ip_vs_dest *dest;\r\nstruct ip_vs_scheduler *sched = rcu_dereference(svc->scheduler);\r\nchar *sched_name = sched ? sched->name : "none";\r\nif (iter->table == ip_vs_svc_table) {\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (svc->af == AF_INET6)\r\nseq_printf(seq, "%s [%pI6]:%04X %s ",\r\nip_vs_proto_name(svc->protocol),\r\n&svc->addr.in6,\r\nntohs(svc->port),\r\nsched_name);\r\nelse\r\n#endif\r\nseq_printf(seq, "%s %08X:%04X %s %s ",\r\nip_vs_proto_name(svc->protocol),\r\nntohl(svc->addr.ip),\r\nntohs(svc->port),\r\nsched_name,\r\n(svc->flags & IP_VS_SVC_F_ONEPACKET)?"ops ":"");\r\n} else {\r\nseq_printf(seq, "FWM %08X %s %s",\r\nsvc->fwmark, sched_name,\r\n(svc->flags & IP_VS_SVC_F_ONEPACKET)?"ops ":"");\r\n}\r\nif (svc->flags & IP_VS_SVC_F_PERSISTENT)\r\nseq_printf(seq, "persistent %d %08X\n",\r\nsvc->timeout,\r\nntohl(svc->netmask));\r\nelse\r\nseq_putc(seq, '\n');\r\nlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (dest->af == AF_INET6)\r\nseq_printf(seq,\r\n" -> [%pI6]:%04X"\r\n" %-7s %-6d %-10d %-10d\n",\r\n&dest->addr.in6,\r\nntohs(dest->port),\r\nip_vs_fwd_name(atomic_read(&dest->conn_flags)),\r\natomic_read(&dest->weight),\r\natomic_read(&dest->activeconns),\r\natomic_read(&dest->inactconns));\r\nelse\r\n#endif\r\nseq_printf(seq,\r\n" -> %08X:%04X "\r\n"%-7s %-6d %-10d %-10d\n",\r\nntohl(dest->addr.ip),\r\nntohs(dest->port),\r\nip_vs_fwd_name(atomic_read(&dest->conn_flags)),\r\natomic_read(&dest->weight),\r\natomic_read(&dest->activeconns),\r\natomic_read(&dest->inactconns));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ip_vs_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ip_vs_info_seq_ops,\r\nsizeof(struct ip_vs_iter));\r\n}\r\nstatic int ip_vs_stats_show(struct seq_file *seq, void *v)\r\n{\r\nstruct net *net = seq_file_single_net(seq);\r\nstruct ip_vs_kstats show;\r\nseq_puts(seq,\r\n" Total Incoming Outgoing Incoming Outgoing\n");\r\nseq_printf(seq,\r\n" Conns Packets Packets Bytes Bytes\n");\r\nip_vs_copy_stats(&show, &net_ipvs(net)->tot_stats);\r\nseq_printf(seq, "%8LX %8LX %8LX %16LX %16LX\n\n",\r\n(unsigned long long)show.conns,\r\n(unsigned long long)show.inpkts,\r\n(unsigned long long)show.outpkts,\r\n(unsigned long long)show.inbytes,\r\n(unsigned long long)show.outbytes);\r\nseq_puts(seq,\r\n" Conns/s Pkts/s Pkts/s Bytes/s Bytes/s\n");\r\nseq_printf(seq, "%8LX %8LX %8LX %16LX %16LX\n",\r\n(unsigned long long)show.cps,\r\n(unsigned long long)show.inpps,\r\n(unsigned long long)show.outpps,\r\n(unsigned long long)show.inbps,\r\n(unsigned long long)show.outbps);\r\nreturn 0;\r\n}\r\nstatic int ip_vs_stats_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open_net(inode, file, ip_vs_stats_show);\r\n}\r\nstatic int ip_vs_stats_percpu_show(struct seq_file *seq, void *v)\r\n{\r\nstruct net *net = seq_file_single_net(seq);\r\nstruct ip_vs_stats *tot_stats = &net_ipvs(net)->tot_stats;\r\nstruct ip_vs_cpu_stats __percpu *cpustats = tot_stats->cpustats;\r\nstruct ip_vs_kstats kstats;\r\nint i;\r\nseq_puts(seq,\r\n" Total Incoming Outgoing Incoming Outgoing\n");\r\nseq_printf(seq,\r\n"CPU Conns Packets Packets Bytes Bytes\n");\r\nfor_each_possible_cpu(i) {\r\nstruct ip_vs_cpu_stats *u = per_cpu_ptr(cpustats, i);\r\nunsigned int start;\r\nu64 conns, inpkts, outpkts, inbytes, outbytes;\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&u->syncp);\r\nconns = u->cnt.conns;\r\ninpkts = u->cnt.inpkts;\r\noutpkts = u->cnt.outpkts;\r\ninbytes = u->cnt.inbytes;\r\noutbytes = u->cnt.outbytes;\r\n} while (u64_stats_fetch_retry_irq(&u->syncp, start));\r\nseq_printf(seq, "%3X %8LX %8LX %8LX %16LX %16LX\n",\r\ni, (u64)conns, (u64)inpkts,\r\n(u64)outpkts, (u64)inbytes,\r\n(u64)outbytes);\r\n}\r\nip_vs_copy_stats(&kstats, tot_stats);\r\nseq_printf(seq, " ~ %8LX %8LX %8LX %16LX %16LX\n\n",\r\n(unsigned long long)kstats.conns,\r\n(unsigned long long)kstats.inpkts,\r\n(unsigned long long)kstats.outpkts,\r\n(unsigned long long)kstats.inbytes,\r\n(unsigned long long)kstats.outbytes);\r\nseq_puts(seq,\r\n" Conns/s Pkts/s Pkts/s Bytes/s Bytes/s\n");\r\nseq_printf(seq, " %8LX %8LX %8LX %16LX %16LX\n",\r\nkstats.cps,\r\nkstats.inpps,\r\nkstats.outpps,\r\nkstats.inbps,\r\nkstats.outbps);\r\nreturn 0;\r\n}\r\nstatic int ip_vs_stats_percpu_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open_net(inode, file, ip_vs_stats_percpu_show);\r\n}\r\nstatic int ip_vs_set_timeout(struct netns_ipvs *ipvs, struct ip_vs_timeout_user *u)\r\n{\r\n#if defined(CONFIG_IP_VS_PROTO_TCP) || defined(CONFIG_IP_VS_PROTO_UDP)\r\nstruct ip_vs_proto_data *pd;\r\n#endif\r\nIP_VS_DBG(2, "Setting timeout tcp:%d tcpfin:%d udp:%d\n",\r\nu->tcp_timeout,\r\nu->tcp_fin_timeout,\r\nu->udp_timeout);\r\n#ifdef CONFIG_IP_VS_PROTO_TCP\r\nif (u->tcp_timeout) {\r\npd = ip_vs_proto_data_get(ipvs, IPPROTO_TCP);\r\npd->timeout_table[IP_VS_TCP_S_ESTABLISHED]\r\n= u->tcp_timeout * HZ;\r\n}\r\nif (u->tcp_fin_timeout) {\r\npd = ip_vs_proto_data_get(ipvs, IPPROTO_TCP);\r\npd->timeout_table[IP_VS_TCP_S_FIN_WAIT]\r\n= u->tcp_fin_timeout * HZ;\r\n}\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_UDP\r\nif (u->udp_timeout) {\r\npd = ip_vs_proto_data_get(ipvs, IPPROTO_UDP);\r\npd->timeout_table[IP_VS_UDP_S_NORMAL]\r\n= u->udp_timeout * HZ;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void ip_vs_copy_usvc_compat(struct ip_vs_service_user_kern *usvc,\r\nstruct ip_vs_service_user *usvc_compat)\r\n{\r\nmemset(usvc, 0, sizeof(*usvc));\r\nusvc->af = AF_INET;\r\nusvc->protocol = usvc_compat->protocol;\r\nusvc->addr.ip = usvc_compat->addr;\r\nusvc->port = usvc_compat->port;\r\nusvc->fwmark = usvc_compat->fwmark;\r\nusvc->sched_name = usvc_compat->sched_name;\r\nusvc->flags = usvc_compat->flags;\r\nusvc->timeout = usvc_compat->timeout;\r\nusvc->netmask = usvc_compat->netmask;\r\n}\r\nstatic void ip_vs_copy_udest_compat(struct ip_vs_dest_user_kern *udest,\r\nstruct ip_vs_dest_user *udest_compat)\r\n{\r\nmemset(udest, 0, sizeof(*udest));\r\nudest->addr.ip = udest_compat->addr;\r\nudest->port = udest_compat->port;\r\nudest->conn_flags = udest_compat->conn_flags;\r\nudest->weight = udest_compat->weight;\r\nudest->u_threshold = udest_compat->u_threshold;\r\nudest->l_threshold = udest_compat->l_threshold;\r\nudest->af = AF_INET;\r\n}\r\nstatic int\r\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\r\n{\r\nstruct net *net = sock_net(sk);\r\nint ret;\r\nunsigned char arg[MAX_SET_ARGLEN];\r\nstruct ip_vs_service_user *usvc_compat;\r\nstruct ip_vs_service_user_kern usvc;\r\nstruct ip_vs_service *svc;\r\nstruct ip_vs_dest_user *udest_compat;\r\nstruct ip_vs_dest_user_kern udest;\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nBUILD_BUG_ON(sizeof(arg) > 255);\r\nif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\r\nreturn -EINVAL;\r\nif (len != set_arglen[CMDID(cmd)]) {\r\nIP_VS_DBG(1, "set_ctl: len %u != %u\n",\r\nlen, set_arglen[CMDID(cmd)]);\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(arg, user, len) != 0)\r\nreturn -EFAULT;\r\nip_vs_use_count_inc();\r\nif (cmd == IP_VS_SO_SET_STARTDAEMON ||\r\ncmd == IP_VS_SO_SET_STOPDAEMON) {\r\nstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\r\nif (cmd == IP_VS_SO_SET_STARTDAEMON) {\r\nstruct ipvs_sync_daemon_cfg cfg;\r\nmemset(&cfg, 0, sizeof(cfg));\r\nstrlcpy(cfg.mcast_ifn, dm->mcast_ifn,\r\nsizeof(cfg.mcast_ifn));\r\ncfg.syncid = dm->syncid;\r\nrtnl_lock();\r\nmutex_lock(&ipvs->sync_mutex);\r\nret = start_sync_thread(ipvs, &cfg, dm->state);\r\nmutex_unlock(&ipvs->sync_mutex);\r\nrtnl_unlock();\r\n} else {\r\nmutex_lock(&ipvs->sync_mutex);\r\nret = stop_sync_thread(ipvs, dm->state);\r\nmutex_unlock(&ipvs->sync_mutex);\r\n}\r\ngoto out_dec;\r\n}\r\nmutex_lock(&__ip_vs_mutex);\r\nif (cmd == IP_VS_SO_SET_FLUSH) {\r\nret = ip_vs_flush(ipvs, false);\r\ngoto out_unlock;\r\n} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\r\nret = ip_vs_set_timeout(ipvs, (struct ip_vs_timeout_user *)arg);\r\ngoto out_unlock;\r\n}\r\nusvc_compat = (struct ip_vs_service_user *)arg;\r\nudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\r\nip_vs_copy_usvc_compat(&usvc, usvc_compat);\r\nip_vs_copy_udest_compat(&udest, udest_compat);\r\nif (cmd == IP_VS_SO_SET_ZERO) {\r\nif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\r\nret = ip_vs_zero_all(ipvs);\r\ngoto out_unlock;\r\n}\r\n}\r\nif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP &&\r\nusvc.protocol != IPPROTO_SCTP) {\r\npr_err("set_ctl: invalid protocol: %d %pI4:%d %s\n",\r\nusvc.protocol, &usvc.addr.ip,\r\nntohs(usvc.port), usvc.sched_name);\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nrcu_read_lock();\r\nif (usvc.fwmark == 0)\r\nsvc = __ip_vs_service_find(ipvs, usvc.af, usvc.protocol,\r\n&usvc.addr, usvc.port);\r\nelse\r\nsvc = __ip_vs_svc_fwm_find(ipvs, usvc.af, usvc.fwmark);\r\nrcu_read_unlock();\r\nif (cmd != IP_VS_SO_SET_ADD\r\n&& (svc == NULL || svc->protocol != usvc.protocol)) {\r\nret = -ESRCH;\r\ngoto out_unlock;\r\n}\r\nswitch (cmd) {\r\ncase IP_VS_SO_SET_ADD:\r\nif (svc != NULL)\r\nret = -EEXIST;\r\nelse\r\nret = ip_vs_add_service(ipvs, &usvc, &svc);\r\nbreak;\r\ncase IP_VS_SO_SET_EDIT:\r\nret = ip_vs_edit_service(svc, &usvc);\r\nbreak;\r\ncase IP_VS_SO_SET_DEL:\r\nret = ip_vs_del_service(svc);\r\nif (!ret)\r\ngoto out_unlock;\r\nbreak;\r\ncase IP_VS_SO_SET_ZERO:\r\nret = ip_vs_zero_service(svc);\r\nbreak;\r\ncase IP_VS_SO_SET_ADDDEST:\r\nret = ip_vs_add_dest(svc, &udest);\r\nbreak;\r\ncase IP_VS_SO_SET_EDITDEST:\r\nret = ip_vs_edit_dest(svc, &udest);\r\nbreak;\r\ncase IP_VS_SO_SET_DELDEST:\r\nret = ip_vs_del_dest(svc, &udest);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nout_unlock:\r\nmutex_unlock(&__ip_vs_mutex);\r\nout_dec:\r\nip_vs_use_count_dec();\r\nreturn ret;\r\n}\r\nstatic void\r\nip_vs_copy_service(struct ip_vs_service_entry *dst, struct ip_vs_service *src)\r\n{\r\nstruct ip_vs_scheduler *sched;\r\nstruct ip_vs_kstats kstats;\r\nchar *sched_name;\r\nsched = rcu_dereference_protected(src->scheduler, 1);\r\nsched_name = sched ? sched->name : "none";\r\ndst->protocol = src->protocol;\r\ndst->addr = src->addr.ip;\r\ndst->port = src->port;\r\ndst->fwmark = src->fwmark;\r\nstrlcpy(dst->sched_name, sched_name, sizeof(dst->sched_name));\r\ndst->flags = src->flags;\r\ndst->timeout = src->timeout / HZ;\r\ndst->netmask = src->netmask;\r\ndst->num_dests = src->num_dests;\r\nip_vs_copy_stats(&kstats, &src->stats);\r\nip_vs_export_stats_user(&dst->stats, &kstats);\r\n}\r\nstatic inline int\r\n__ip_vs_get_service_entries(struct netns_ipvs *ipvs,\r\nconst struct ip_vs_get_services *get,\r\nstruct ip_vs_get_services __user *uptr)\r\n{\r\nint idx, count=0;\r\nstruct ip_vs_service *svc;\r\nstruct ip_vs_service_entry entry;\r\nint ret = 0;\r\nfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\r\nhlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\r\nif (svc->af != AF_INET || (svc->ipvs != ipvs))\r\ncontinue;\r\nif (count >= get->num_services)\r\ngoto out;\r\nmemset(&entry, 0, sizeof(entry));\r\nip_vs_copy_service(&entry, svc);\r\nif (copy_to_user(&uptr->entrytable[count],\r\n&entry, sizeof(entry))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\ncount++;\r\n}\r\n}\r\nfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\r\nhlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\r\nif (svc->af != AF_INET || (svc->ipvs != ipvs))\r\ncontinue;\r\nif (count >= get->num_services)\r\ngoto out;\r\nmemset(&entry, 0, sizeof(entry));\r\nip_vs_copy_service(&entry, svc);\r\nif (copy_to_user(&uptr->entrytable[count],\r\n&entry, sizeof(entry))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\ncount++;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic inline int\r\n__ip_vs_get_dest_entries(struct netns_ipvs *ipvs, const struct ip_vs_get_dests *get,\r\nstruct ip_vs_get_dests __user *uptr)\r\n{\r\nstruct ip_vs_service *svc;\r\nunion nf_inet_addr addr = { .ip = get->addr };\r\nint ret = 0;\r\nrcu_read_lock();\r\nif (get->fwmark)\r\nsvc = __ip_vs_svc_fwm_find(ipvs, AF_INET, get->fwmark);\r\nelse\r\nsvc = __ip_vs_service_find(ipvs, AF_INET, get->protocol, &addr,\r\nget->port);\r\nrcu_read_unlock();\r\nif (svc) {\r\nint count = 0;\r\nstruct ip_vs_dest *dest;\r\nstruct ip_vs_dest_entry entry;\r\nstruct ip_vs_kstats kstats;\r\nmemset(&entry, 0, sizeof(entry));\r\nlist_for_each_entry(dest, &svc->destinations, n_list) {\r\nif (count >= get->num_dests)\r\nbreak;\r\nif (dest->af != svc->af)\r\ncontinue;\r\nentry.addr = dest->addr.ip;\r\nentry.port = dest->port;\r\nentry.conn_flags = atomic_read(&dest->conn_flags);\r\nentry.weight = atomic_read(&dest->weight);\r\nentry.u_threshold = dest->u_threshold;\r\nentry.l_threshold = dest->l_threshold;\r\nentry.activeconns = atomic_read(&dest->activeconns);\r\nentry.inactconns = atomic_read(&dest->inactconns);\r\nentry.persistconns = atomic_read(&dest->persistconns);\r\nip_vs_copy_stats(&kstats, &dest->stats);\r\nip_vs_export_stats_user(&entry.stats, &kstats);\r\nif (copy_to_user(&uptr->entrytable[count],\r\n&entry, sizeof(entry))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ncount++;\r\n}\r\n} else\r\nret = -ESRCH;\r\nreturn ret;\r\n}\r\nstatic inline void\r\n__ip_vs_get_timeouts(struct netns_ipvs *ipvs, struct ip_vs_timeout_user *u)\r\n{\r\n#if defined(CONFIG_IP_VS_PROTO_TCP) || defined(CONFIG_IP_VS_PROTO_UDP)\r\nstruct ip_vs_proto_data *pd;\r\n#endif\r\nmemset(u, 0, sizeof (*u));\r\n#ifdef CONFIG_IP_VS_PROTO_TCP\r\npd = ip_vs_proto_data_get(ipvs, IPPROTO_TCP);\r\nu->tcp_timeout = pd->timeout_table[IP_VS_TCP_S_ESTABLISHED] / HZ;\r\nu->tcp_fin_timeout = pd->timeout_table[IP_VS_TCP_S_FIN_WAIT] / HZ;\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_UDP\r\npd = ip_vs_proto_data_get(ipvs, IPPROTO_UDP);\r\nu->udp_timeout =\r\npd->timeout_table[IP_VS_UDP_S_NORMAL] / HZ;\r\n#endif\r\n}\r\nstatic int\r\ndo_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\r\n{\r\nunsigned char arg[MAX_GET_ARGLEN];\r\nint ret = 0;\r\nunsigned int copylen;\r\nstruct net *net = sock_net(sk);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nBUG_ON(!net);\r\nBUILD_BUG_ON(sizeof(arg) > 255);\r\nif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\r\nreturn -EINVAL;\r\ncopylen = get_arglen[CMDID(cmd)];\r\nif (*len < (int) copylen) {\r\nIP_VS_DBG(1, "get_ctl: len %d < %u\n", *len, copylen);\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(arg, user, copylen) != 0)\r\nreturn -EFAULT;\r\nif (cmd == IP_VS_SO_GET_DAEMON) {\r\nstruct ip_vs_daemon_user d[2];\r\nmemset(&d, 0, sizeof(d));\r\nmutex_lock(&ipvs->sync_mutex);\r\nif (ipvs->sync_state & IP_VS_STATE_MASTER) {\r\nd[0].state = IP_VS_STATE_MASTER;\r\nstrlcpy(d[0].mcast_ifn, ipvs->mcfg.mcast_ifn,\r\nsizeof(d[0].mcast_ifn));\r\nd[0].syncid = ipvs->mcfg.syncid;\r\n}\r\nif (ipvs->sync_state & IP_VS_STATE_BACKUP) {\r\nd[1].state = IP_VS_STATE_BACKUP;\r\nstrlcpy(d[1].mcast_ifn, ipvs->bcfg.mcast_ifn,\r\nsizeof(d[1].mcast_ifn));\r\nd[1].syncid = ipvs->bcfg.syncid;\r\n}\r\nif (copy_to_user(user, &d, sizeof(d)) != 0)\r\nret = -EFAULT;\r\nmutex_unlock(&ipvs->sync_mutex);\r\nreturn ret;\r\n}\r\nmutex_lock(&__ip_vs_mutex);\r\nswitch (cmd) {\r\ncase IP_VS_SO_GET_VERSION:\r\n{\r\nchar buf[64];\r\nsprintf(buf, "IP Virtual Server version %d.%d.%d (size=%d)",\r\nNVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);\r\nif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n*len = strlen(buf)+1;\r\n}\r\nbreak;\r\ncase IP_VS_SO_GET_INFO:\r\n{\r\nstruct ip_vs_getinfo info;\r\ninfo.version = IP_VS_VERSION_CODE;\r\ninfo.size = ip_vs_conn_tab_size;\r\ninfo.num_services = ipvs->num_services;\r\nif (copy_to_user(user, &info, sizeof(info)) != 0)\r\nret = -EFAULT;\r\n}\r\nbreak;\r\ncase IP_VS_SO_GET_SERVICES:\r\n{\r\nstruct ip_vs_get_services *get;\r\nint size;\r\nget = (struct ip_vs_get_services *)arg;\r\nsize = sizeof(*get) +\r\nsizeof(struct ip_vs_service_entry) * get->num_services;\r\nif (*len != size) {\r\npr_err("length: %u != %u\n", *len, size);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = __ip_vs_get_service_entries(ipvs, get, user);\r\n}\r\nbreak;\r\ncase IP_VS_SO_GET_SERVICE:\r\n{\r\nstruct ip_vs_service_entry *entry;\r\nstruct ip_vs_service *svc;\r\nunion nf_inet_addr addr;\r\nentry = (struct ip_vs_service_entry *)arg;\r\naddr.ip = entry->addr;\r\nrcu_read_lock();\r\nif (entry->fwmark)\r\nsvc = __ip_vs_svc_fwm_find(ipvs, AF_INET, entry->fwmark);\r\nelse\r\nsvc = __ip_vs_service_find(ipvs, AF_INET,\r\nentry->protocol, &addr,\r\nentry->port);\r\nrcu_read_unlock();\r\nif (svc) {\r\nip_vs_copy_service(entry, svc);\r\nif (copy_to_user(user, entry, sizeof(*entry)) != 0)\r\nret = -EFAULT;\r\n} else\r\nret = -ESRCH;\r\n}\r\nbreak;\r\ncase IP_VS_SO_GET_DESTS:\r\n{\r\nstruct ip_vs_get_dests *get;\r\nint size;\r\nget = (struct ip_vs_get_dests *)arg;\r\nsize = sizeof(*get) +\r\nsizeof(struct ip_vs_dest_entry) * get->num_dests;\r\nif (*len != size) {\r\npr_err("length: %u != %u\n", *len, size);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = __ip_vs_get_dest_entries(ipvs, get, user);\r\n}\r\nbreak;\r\ncase IP_VS_SO_GET_TIMEOUT:\r\n{\r\nstruct ip_vs_timeout_user t;\r\n__ip_vs_get_timeouts(ipvs, &t);\r\nif (copy_to_user(user, &t, sizeof(t)) != 0)\r\nret = -EFAULT;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&__ip_vs_mutex);\r\nreturn ret;\r\n}\r\nstatic int ip_vs_genl_fill_stats(struct sk_buff *skb, int container_type,\r\nstruct ip_vs_kstats *kstats)\r\n{\r\nstruct nlattr *nl_stats = nla_nest_start(skb, container_type);\r\nif (!nl_stats)\r\nreturn -EMSGSIZE;\r\nif (nla_put_u32(skb, IPVS_STATS_ATTR_CONNS, (u32)kstats->conns) ||\r\nnla_put_u32(skb, IPVS_STATS_ATTR_INPKTS, (u32)kstats->inpkts) ||\r\nnla_put_u32(skb, IPVS_STATS_ATTR_OUTPKTS, (u32)kstats->outpkts) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_INBYTES, kstats->inbytes,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_OUTBYTES, kstats->outbytes,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u32(skb, IPVS_STATS_ATTR_CPS, (u32)kstats->cps) ||\r\nnla_put_u32(skb, IPVS_STATS_ATTR_INPPS, (u32)kstats->inpps) ||\r\nnla_put_u32(skb, IPVS_STATS_ATTR_OUTPPS, (u32)kstats->outpps) ||\r\nnla_put_u32(skb, IPVS_STATS_ATTR_INBPS, (u32)kstats->inbps) ||\r\nnla_put_u32(skb, IPVS_STATS_ATTR_OUTBPS, (u32)kstats->outbps))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nl_stats);\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nl_stats);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ip_vs_genl_fill_stats64(struct sk_buff *skb, int container_type,\r\nstruct ip_vs_kstats *kstats)\r\n{\r\nstruct nlattr *nl_stats = nla_nest_start(skb, container_type);\r\nif (!nl_stats)\r\nreturn -EMSGSIZE;\r\nif (nla_put_u64_64bit(skb, IPVS_STATS_ATTR_CONNS, kstats->conns,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_INPKTS, kstats->inpkts,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_OUTPKTS, kstats->outpkts,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_INBYTES, kstats->inbytes,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_OUTBYTES, kstats->outbytes,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_CPS, kstats->cps,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_INPPS, kstats->inpps,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_OUTPPS, kstats->outpps,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_INBPS, kstats->inbps,\r\nIPVS_STATS_ATTR_PAD) ||\r\nnla_put_u64_64bit(skb, IPVS_STATS_ATTR_OUTBPS, kstats->outbps,\r\nIPVS_STATS_ATTR_PAD))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nl_stats);\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nl_stats);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ip_vs_genl_fill_service(struct sk_buff *skb,\r\nstruct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_scheduler *sched;\r\nstruct ip_vs_pe *pe;\r\nstruct nlattr *nl_service;\r\nstruct ip_vs_flags flags = { .flags = svc->flags,\r\n.mask = ~0 };\r\nstruct ip_vs_kstats kstats;\r\nchar *sched_name;\r\nnl_service = nla_nest_start(skb, IPVS_CMD_ATTR_SERVICE);\r\nif (!nl_service)\r\nreturn -EMSGSIZE;\r\nif (nla_put_u16(skb, IPVS_SVC_ATTR_AF, svc->af))\r\ngoto nla_put_failure;\r\nif (svc->fwmark) {\r\nif (nla_put_u32(skb, IPVS_SVC_ATTR_FWMARK, svc->fwmark))\r\ngoto nla_put_failure;\r\n} else {\r\nif (nla_put_u16(skb, IPVS_SVC_ATTR_PROTOCOL, svc->protocol) ||\r\nnla_put(skb, IPVS_SVC_ATTR_ADDR, sizeof(svc->addr), &svc->addr) ||\r\nnla_put_be16(skb, IPVS_SVC_ATTR_PORT, svc->port))\r\ngoto nla_put_failure;\r\n}\r\nsched = rcu_dereference_protected(svc->scheduler, 1);\r\nsched_name = sched ? sched->name : "none";\r\npe = rcu_dereference_protected(svc->pe, 1);\r\nif (nla_put_string(skb, IPVS_SVC_ATTR_SCHED_NAME, sched_name) ||\r\n(pe && nla_put_string(skb, IPVS_SVC_ATTR_PE_NAME, pe->name)) ||\r\nnla_put(skb, IPVS_SVC_ATTR_FLAGS, sizeof(flags), &flags) ||\r\nnla_put_u32(skb, IPVS_SVC_ATTR_TIMEOUT, svc->timeout / HZ) ||\r\nnla_put_be32(skb, IPVS_SVC_ATTR_NETMASK, svc->netmask))\r\ngoto nla_put_failure;\r\nip_vs_copy_stats(&kstats, &svc->stats);\r\nif (ip_vs_genl_fill_stats(skb, IPVS_SVC_ATTR_STATS, &kstats))\r\ngoto nla_put_failure;\r\nif (ip_vs_genl_fill_stats64(skb, IPVS_SVC_ATTR_STATS64, &kstats))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nl_service);\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nl_service);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ip_vs_genl_dump_service(struct sk_buff *skb,\r\nstruct ip_vs_service *svc,\r\nstruct netlink_callback *cb)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\r\n&ip_vs_genl_family, NLM_F_MULTI,\r\nIPVS_CMD_NEW_SERVICE);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (ip_vs_genl_fill_service(skb, svc) < 0)\r\ngoto nla_put_failure;\r\ngenlmsg_end(skb, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ip_vs_genl_dump_services(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nint idx = 0, i;\r\nint start = cb->args[0];\r\nstruct ip_vs_service *svc;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nmutex_lock(&__ip_vs_mutex);\r\nfor (i = 0; i < IP_VS_SVC_TAB_SIZE; i++) {\r\nhlist_for_each_entry(svc, &ip_vs_svc_table[i], s_list) {\r\nif (++idx <= start || (svc->ipvs != ipvs))\r\ncontinue;\r\nif (ip_vs_genl_dump_service(skb, svc, cb) < 0) {\r\nidx--;\r\ngoto nla_put_failure;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < IP_VS_SVC_TAB_SIZE; i++) {\r\nhlist_for_each_entry(svc, &ip_vs_svc_fwm_table[i], f_list) {\r\nif (++idx <= start || (svc->ipvs != ipvs))\r\ncontinue;\r\nif (ip_vs_genl_dump_service(skb, svc, cb) < 0) {\r\nidx--;\r\ngoto nla_put_failure;\r\n}\r\n}\r\n}\r\nnla_put_failure:\r\nmutex_unlock(&__ip_vs_mutex);\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nstatic int ip_vs_genl_parse_service(struct netns_ipvs *ipvs,\r\nstruct ip_vs_service_user_kern *usvc,\r\nstruct nlattr *nla, int full_entry,\r\nstruct ip_vs_service **ret_svc)\r\n{\r\nstruct nlattr *attrs[IPVS_SVC_ATTR_MAX + 1];\r\nstruct nlattr *nla_af, *nla_port, *nla_fwmark, *nla_protocol, *nla_addr;\r\nstruct ip_vs_service *svc;\r\nif (nla == NULL ||\r\nnla_parse_nested(attrs, IPVS_SVC_ATTR_MAX, nla, ip_vs_svc_policy))\r\nreturn -EINVAL;\r\nnla_af = attrs[IPVS_SVC_ATTR_AF];\r\nnla_protocol = attrs[IPVS_SVC_ATTR_PROTOCOL];\r\nnla_addr = attrs[IPVS_SVC_ATTR_ADDR];\r\nnla_port = attrs[IPVS_SVC_ATTR_PORT];\r\nnla_fwmark = attrs[IPVS_SVC_ATTR_FWMARK];\r\nif (!(nla_af && (nla_fwmark || (nla_port && nla_protocol && nla_addr))))\r\nreturn -EINVAL;\r\nmemset(usvc, 0, sizeof(*usvc));\r\nusvc->af = nla_get_u16(nla_af);\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (usvc->af != AF_INET && usvc->af != AF_INET6)\r\n#else\r\nif (usvc->af != AF_INET)\r\n#endif\r\nreturn -EAFNOSUPPORT;\r\nif (nla_fwmark) {\r\nusvc->protocol = IPPROTO_TCP;\r\nusvc->fwmark = nla_get_u32(nla_fwmark);\r\n} else {\r\nusvc->protocol = nla_get_u16(nla_protocol);\r\nnla_memcpy(&usvc->addr, nla_addr, sizeof(usvc->addr));\r\nusvc->port = nla_get_be16(nla_port);\r\nusvc->fwmark = 0;\r\n}\r\nrcu_read_lock();\r\nif (usvc->fwmark)\r\nsvc = __ip_vs_svc_fwm_find(ipvs, usvc->af, usvc->fwmark);\r\nelse\r\nsvc = __ip_vs_service_find(ipvs, usvc->af, usvc->protocol,\r\n&usvc->addr, usvc->port);\r\nrcu_read_unlock();\r\n*ret_svc = svc;\r\nif (full_entry) {\r\nstruct nlattr *nla_sched, *nla_flags, *nla_pe, *nla_timeout,\r\n*nla_netmask;\r\nstruct ip_vs_flags flags;\r\nnla_sched = attrs[IPVS_SVC_ATTR_SCHED_NAME];\r\nnla_pe = attrs[IPVS_SVC_ATTR_PE_NAME];\r\nnla_flags = attrs[IPVS_SVC_ATTR_FLAGS];\r\nnla_timeout = attrs[IPVS_SVC_ATTR_TIMEOUT];\r\nnla_netmask = attrs[IPVS_SVC_ATTR_NETMASK];\r\nif (!(nla_sched && nla_flags && nla_timeout && nla_netmask))\r\nreturn -EINVAL;\r\nnla_memcpy(&flags, nla_flags, sizeof(flags));\r\nif (svc)\r\nusvc->flags = svc->flags;\r\nusvc->flags = (usvc->flags & ~flags.mask) |\r\n(flags.flags & flags.mask);\r\nusvc->sched_name = nla_data(nla_sched);\r\nusvc->pe_name = nla_pe ? nla_data(nla_pe) : NULL;\r\nusvc->timeout = nla_get_u32(nla_timeout);\r\nusvc->netmask = nla_get_be32(nla_netmask);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ip_vs_service *ip_vs_genl_find_service(struct netns_ipvs *ipvs,\r\nstruct nlattr *nla)\r\n{\r\nstruct ip_vs_service_user_kern usvc;\r\nstruct ip_vs_service *svc;\r\nint ret;\r\nret = ip_vs_genl_parse_service(ipvs, &usvc, nla, 0, &svc);\r\nreturn ret ? ERR_PTR(ret) : svc;\r\n}\r\nstatic int ip_vs_genl_fill_dest(struct sk_buff *skb, struct ip_vs_dest *dest)\r\n{\r\nstruct nlattr *nl_dest;\r\nstruct ip_vs_kstats kstats;\r\nnl_dest = nla_nest_start(skb, IPVS_CMD_ATTR_DEST);\r\nif (!nl_dest)\r\nreturn -EMSGSIZE;\r\nif (nla_put(skb, IPVS_DEST_ATTR_ADDR, sizeof(dest->addr), &dest->addr) ||\r\nnla_put_be16(skb, IPVS_DEST_ATTR_PORT, dest->port) ||\r\nnla_put_u32(skb, IPVS_DEST_ATTR_FWD_METHOD,\r\n(atomic_read(&dest->conn_flags) &\r\nIP_VS_CONN_F_FWD_MASK)) ||\r\nnla_put_u32(skb, IPVS_DEST_ATTR_WEIGHT,\r\natomic_read(&dest->weight)) ||\r\nnla_put_u32(skb, IPVS_DEST_ATTR_U_THRESH, dest->u_threshold) ||\r\nnla_put_u32(skb, IPVS_DEST_ATTR_L_THRESH, dest->l_threshold) ||\r\nnla_put_u32(skb, IPVS_DEST_ATTR_ACTIVE_CONNS,\r\natomic_read(&dest->activeconns)) ||\r\nnla_put_u32(skb, IPVS_DEST_ATTR_INACT_CONNS,\r\natomic_read(&dest->inactconns)) ||\r\nnla_put_u32(skb, IPVS_DEST_ATTR_PERSIST_CONNS,\r\natomic_read(&dest->persistconns)) ||\r\nnla_put_u16(skb, IPVS_DEST_ATTR_ADDR_FAMILY, dest->af))\r\ngoto nla_put_failure;\r\nip_vs_copy_stats(&kstats, &dest->stats);\r\nif (ip_vs_genl_fill_stats(skb, IPVS_DEST_ATTR_STATS, &kstats))\r\ngoto nla_put_failure;\r\nif (ip_vs_genl_fill_stats64(skb, IPVS_DEST_ATTR_STATS64, &kstats))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nl_dest);\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nl_dest);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ip_vs_genl_dump_dest(struct sk_buff *skb, struct ip_vs_dest *dest,\r\nstruct netlink_callback *cb)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\r\n&ip_vs_genl_family, NLM_F_MULTI,\r\nIPVS_CMD_NEW_DEST);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (ip_vs_genl_fill_dest(skb, dest) < 0)\r\ngoto nla_put_failure;\r\ngenlmsg_end(skb, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ip_vs_genl_dump_dests(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nint idx = 0;\r\nint start = cb->args[0];\r\nstruct ip_vs_service *svc;\r\nstruct ip_vs_dest *dest;\r\nstruct nlattr *attrs[IPVS_CMD_ATTR_MAX + 1];\r\nstruct net *net = sock_net(skb->sk);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nmutex_lock(&__ip_vs_mutex);\r\nif (nlmsg_parse(cb->nlh, GENL_HDRLEN, attrs,\r\nIPVS_CMD_ATTR_MAX, ip_vs_cmd_policy))\r\ngoto out_err;\r\nsvc = ip_vs_genl_find_service(ipvs, attrs[IPVS_CMD_ATTR_SERVICE]);\r\nif (IS_ERR(svc) || svc == NULL)\r\ngoto out_err;\r\nlist_for_each_entry(dest, &svc->destinations, n_list) {\r\nif (++idx <= start)\r\ncontinue;\r\nif (ip_vs_genl_dump_dest(skb, dest, cb) < 0) {\r\nidx--;\r\ngoto nla_put_failure;\r\n}\r\n}\r\nnla_put_failure:\r\ncb->args[0] = idx;\r\nout_err:\r\nmutex_unlock(&__ip_vs_mutex);\r\nreturn skb->len;\r\n}\r\nstatic int ip_vs_genl_parse_dest(struct ip_vs_dest_user_kern *udest,\r\nstruct nlattr *nla, int full_entry)\r\n{\r\nstruct nlattr *attrs[IPVS_DEST_ATTR_MAX + 1];\r\nstruct nlattr *nla_addr, *nla_port;\r\nstruct nlattr *nla_addr_family;\r\nif (nla == NULL ||\r\nnla_parse_nested(attrs, IPVS_DEST_ATTR_MAX, nla, ip_vs_dest_policy))\r\nreturn -EINVAL;\r\nnla_addr = attrs[IPVS_DEST_ATTR_ADDR];\r\nnla_port = attrs[IPVS_DEST_ATTR_PORT];\r\nnla_addr_family = attrs[IPVS_DEST_ATTR_ADDR_FAMILY];\r\nif (!(nla_addr && nla_port))\r\nreturn -EINVAL;\r\nmemset(udest, 0, sizeof(*udest));\r\nnla_memcpy(&udest->addr, nla_addr, sizeof(udest->addr));\r\nudest->port = nla_get_be16(nla_port);\r\nif (nla_addr_family)\r\nudest->af = nla_get_u16(nla_addr_family);\r\nelse\r\nudest->af = 0;\r\nif (full_entry) {\r\nstruct nlattr *nla_fwd, *nla_weight, *nla_u_thresh,\r\n*nla_l_thresh;\r\nnla_fwd = attrs[IPVS_DEST_ATTR_FWD_METHOD];\r\nnla_weight = attrs[IPVS_DEST_ATTR_WEIGHT];\r\nnla_u_thresh = attrs[IPVS_DEST_ATTR_U_THRESH];\r\nnla_l_thresh = attrs[IPVS_DEST_ATTR_L_THRESH];\r\nif (!(nla_fwd && nla_weight && nla_u_thresh && nla_l_thresh))\r\nreturn -EINVAL;\r\nudest->conn_flags = nla_get_u32(nla_fwd)\r\n& IP_VS_CONN_F_FWD_MASK;\r\nudest->weight = nla_get_u32(nla_weight);\r\nudest->u_threshold = nla_get_u32(nla_u_thresh);\r\nudest->l_threshold = nla_get_u32(nla_l_thresh);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ip_vs_genl_fill_daemon(struct sk_buff *skb, __u32 state,\r\nstruct ipvs_sync_daemon_cfg *c)\r\n{\r\nstruct nlattr *nl_daemon;\r\nnl_daemon = nla_nest_start(skb, IPVS_CMD_ATTR_DAEMON);\r\nif (!nl_daemon)\r\nreturn -EMSGSIZE;\r\nif (nla_put_u32(skb, IPVS_DAEMON_ATTR_STATE, state) ||\r\nnla_put_string(skb, IPVS_DAEMON_ATTR_MCAST_IFN, c->mcast_ifn) ||\r\nnla_put_u32(skb, IPVS_DAEMON_ATTR_SYNC_ID, c->syncid) ||\r\nnla_put_u16(skb, IPVS_DAEMON_ATTR_SYNC_MAXLEN, c->sync_maxlen) ||\r\nnla_put_u16(skb, IPVS_DAEMON_ATTR_MCAST_PORT, c->mcast_port) ||\r\nnla_put_u8(skb, IPVS_DAEMON_ATTR_MCAST_TTL, c->mcast_ttl))\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (c->mcast_af == AF_INET6) {\r\nif (nla_put_in6_addr(skb, IPVS_DAEMON_ATTR_MCAST_GROUP6,\r\n&c->mcast_group.in6))\r\ngoto nla_put_failure;\r\n} else\r\n#endif\r\nif (c->mcast_af == AF_INET &&\r\nnla_put_in_addr(skb, IPVS_DAEMON_ATTR_MCAST_GROUP,\r\nc->mcast_group.ip))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nl_daemon);\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nl_daemon);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ip_vs_genl_dump_daemon(struct sk_buff *skb, __u32 state,\r\nstruct ipvs_sync_daemon_cfg *c,\r\nstruct netlink_callback *cb)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\r\n&ip_vs_genl_family, NLM_F_MULTI,\r\nIPVS_CMD_NEW_DAEMON);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (ip_vs_genl_fill_daemon(skb, state, c))\r\ngoto nla_put_failure;\r\ngenlmsg_end(skb, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ip_vs_genl_dump_daemons(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nmutex_lock(&ipvs->sync_mutex);\r\nif ((ipvs->sync_state & IP_VS_STATE_MASTER) && !cb->args[0]) {\r\nif (ip_vs_genl_dump_daemon(skb, IP_VS_STATE_MASTER,\r\n&ipvs->mcfg, cb) < 0)\r\ngoto nla_put_failure;\r\ncb->args[0] = 1;\r\n}\r\nif ((ipvs->sync_state & IP_VS_STATE_BACKUP) && !cb->args[1]) {\r\nif (ip_vs_genl_dump_daemon(skb, IP_VS_STATE_BACKUP,\r\n&ipvs->bcfg, cb) < 0)\r\ngoto nla_put_failure;\r\ncb->args[1] = 1;\r\n}\r\nnla_put_failure:\r\nmutex_unlock(&ipvs->sync_mutex);\r\nreturn skb->len;\r\n}\r\nstatic int ip_vs_genl_new_daemon(struct netns_ipvs *ipvs, struct nlattr **attrs)\r\n{\r\nstruct ipvs_sync_daemon_cfg c;\r\nstruct nlattr *a;\r\nint ret;\r\nmemset(&c, 0, sizeof(c));\r\nif (!(attrs[IPVS_DAEMON_ATTR_STATE] &&\r\nattrs[IPVS_DAEMON_ATTR_MCAST_IFN] &&\r\nattrs[IPVS_DAEMON_ATTR_SYNC_ID]))\r\nreturn -EINVAL;\r\nstrlcpy(c.mcast_ifn, nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),\r\nsizeof(c.mcast_ifn));\r\nc.syncid = nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]);\r\na = attrs[IPVS_DAEMON_ATTR_SYNC_MAXLEN];\r\nif (a)\r\nc.sync_maxlen = nla_get_u16(a);\r\na = attrs[IPVS_DAEMON_ATTR_MCAST_GROUP];\r\nif (a) {\r\nc.mcast_af = AF_INET;\r\nc.mcast_group.ip = nla_get_in_addr(a);\r\nif (!ipv4_is_multicast(c.mcast_group.ip))\r\nreturn -EINVAL;\r\n} else {\r\na = attrs[IPVS_DAEMON_ATTR_MCAST_GROUP6];\r\nif (a) {\r\n#ifdef CONFIG_IP_VS_IPV6\r\nint addr_type;\r\nc.mcast_af = AF_INET6;\r\nc.mcast_group.in6 = nla_get_in6_addr(a);\r\naddr_type = ipv6_addr_type(&c.mcast_group.in6);\r\nif (!(addr_type & IPV6_ADDR_MULTICAST))\r\nreturn -EINVAL;\r\n#else\r\nreturn -EAFNOSUPPORT;\r\n#endif\r\n}\r\n}\r\na = attrs[IPVS_DAEMON_ATTR_MCAST_PORT];\r\nif (a)\r\nc.mcast_port = nla_get_u16(a);\r\na = attrs[IPVS_DAEMON_ATTR_MCAST_TTL];\r\nif (a)\r\nc.mcast_ttl = nla_get_u8(a);\r\nif (ipvs->mixed_address_family_dests > 0)\r\nreturn -EINVAL;\r\nrtnl_lock();\r\nmutex_lock(&ipvs->sync_mutex);\r\nret = start_sync_thread(ipvs, &c,\r\nnla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]));\r\nmutex_unlock(&ipvs->sync_mutex);\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nstatic int ip_vs_genl_del_daemon(struct netns_ipvs *ipvs, struct nlattr **attrs)\r\n{\r\nint ret;\r\nif (!attrs[IPVS_DAEMON_ATTR_STATE])\r\nreturn -EINVAL;\r\nmutex_lock(&ipvs->sync_mutex);\r\nret = stop_sync_thread(ipvs,\r\nnla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]));\r\nmutex_unlock(&ipvs->sync_mutex);\r\nreturn ret;\r\n}\r\nstatic int ip_vs_genl_set_config(struct netns_ipvs *ipvs, struct nlattr **attrs)\r\n{\r\nstruct ip_vs_timeout_user t;\r\n__ip_vs_get_timeouts(ipvs, &t);\r\nif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP])\r\nt.tcp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP]);\r\nif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN])\r\nt.tcp_fin_timeout =\r\nnla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN]);\r\nif (attrs[IPVS_CMD_ATTR_TIMEOUT_UDP])\r\nt.udp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_UDP]);\r\nreturn ip_vs_set_timeout(ipvs, &t);\r\n}\r\nstatic int ip_vs_genl_set_daemon(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint ret = -EINVAL, cmd;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\ncmd = info->genlhdr->cmd;\r\nif (cmd == IPVS_CMD_NEW_DAEMON || cmd == IPVS_CMD_DEL_DAEMON) {\r\nstruct nlattr *daemon_attrs[IPVS_DAEMON_ATTR_MAX + 1];\r\nif (!info->attrs[IPVS_CMD_ATTR_DAEMON] ||\r\nnla_parse_nested(daemon_attrs, IPVS_DAEMON_ATTR_MAX,\r\ninfo->attrs[IPVS_CMD_ATTR_DAEMON],\r\nip_vs_daemon_policy))\r\ngoto out;\r\nif (cmd == IPVS_CMD_NEW_DAEMON)\r\nret = ip_vs_genl_new_daemon(ipvs, daemon_attrs);\r\nelse\r\nret = ip_vs_genl_del_daemon(ipvs, daemon_attrs);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ip_vs_genl_set_cmd(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct ip_vs_service *svc = NULL;\r\nstruct ip_vs_service_user_kern usvc;\r\nstruct ip_vs_dest_user_kern udest;\r\nint ret = 0, cmd;\r\nint need_full_svc = 0, need_full_dest = 0;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\ncmd = info->genlhdr->cmd;\r\nmutex_lock(&__ip_vs_mutex);\r\nif (cmd == IPVS_CMD_FLUSH) {\r\nret = ip_vs_flush(ipvs, false);\r\ngoto out;\r\n} else if (cmd == IPVS_CMD_SET_CONFIG) {\r\nret = ip_vs_genl_set_config(ipvs, info->attrs);\r\ngoto out;\r\n} else if (cmd == IPVS_CMD_ZERO &&\r\n!info->attrs[IPVS_CMD_ATTR_SERVICE]) {\r\nret = ip_vs_zero_all(ipvs);\r\ngoto out;\r\n}\r\nif (cmd == IPVS_CMD_NEW_SERVICE || cmd == IPVS_CMD_SET_SERVICE)\r\nneed_full_svc = 1;\r\nret = ip_vs_genl_parse_service(ipvs, &usvc,\r\ninfo->attrs[IPVS_CMD_ATTR_SERVICE],\r\nneed_full_svc, &svc);\r\nif (ret)\r\ngoto out;\r\nif ((cmd != IPVS_CMD_NEW_SERVICE) && (svc == NULL)) {\r\nret = -ESRCH;\r\ngoto out;\r\n}\r\nif (cmd == IPVS_CMD_NEW_DEST || cmd == IPVS_CMD_SET_DEST ||\r\ncmd == IPVS_CMD_DEL_DEST) {\r\nif (cmd != IPVS_CMD_DEL_DEST)\r\nneed_full_dest = 1;\r\nret = ip_vs_genl_parse_dest(&udest,\r\ninfo->attrs[IPVS_CMD_ATTR_DEST],\r\nneed_full_dest);\r\nif (ret)\r\ngoto out;\r\nif (udest.af == 0)\r\nudest.af = svc->af;\r\nif (udest.af != svc->af && cmd != IPVS_CMD_DEL_DEST) {\r\nif (ipvs->sync_state) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (udest.conn_flags) {\r\ncase IP_VS_CONN_F_TUNNEL:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\n}\r\nswitch (cmd) {\r\ncase IPVS_CMD_NEW_SERVICE:\r\nif (svc == NULL)\r\nret = ip_vs_add_service(ipvs, &usvc, &svc);\r\nelse\r\nret = -EEXIST;\r\nbreak;\r\ncase IPVS_CMD_SET_SERVICE:\r\nret = ip_vs_edit_service(svc, &usvc);\r\nbreak;\r\ncase IPVS_CMD_DEL_SERVICE:\r\nret = ip_vs_del_service(svc);\r\nbreak;\r\ncase IPVS_CMD_NEW_DEST:\r\nret = ip_vs_add_dest(svc, &udest);\r\nbreak;\r\ncase IPVS_CMD_SET_DEST:\r\nret = ip_vs_edit_dest(svc, &udest);\r\nbreak;\r\ncase IPVS_CMD_DEL_DEST:\r\nret = ip_vs_del_dest(svc, &udest);\r\nbreak;\r\ncase IPVS_CMD_ZERO:\r\nret = ip_vs_zero_service(svc);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&__ip_vs_mutex);\r\nreturn ret;\r\n}\r\nstatic int ip_vs_genl_get_cmd(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct sk_buff *msg;\r\nvoid *reply;\r\nint ret, cmd, reply_cmd;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\ncmd = info->genlhdr->cmd;\r\nif (cmd == IPVS_CMD_GET_SERVICE)\r\nreply_cmd = IPVS_CMD_NEW_SERVICE;\r\nelse if (cmd == IPVS_CMD_GET_INFO)\r\nreply_cmd = IPVS_CMD_SET_INFO;\r\nelse if (cmd == IPVS_CMD_GET_CONFIG)\r\nreply_cmd = IPVS_CMD_SET_CONFIG;\r\nelse {\r\npr_err("unknown Generic Netlink command\n");\r\nreturn -EINVAL;\r\n}\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmutex_lock(&__ip_vs_mutex);\r\nreply = genlmsg_put_reply(msg, info, &ip_vs_genl_family, 0, reply_cmd);\r\nif (reply == NULL)\r\ngoto nla_put_failure;\r\nswitch (cmd) {\r\ncase IPVS_CMD_GET_SERVICE:\r\n{\r\nstruct ip_vs_service *svc;\r\nsvc = ip_vs_genl_find_service(ipvs,\r\ninfo->attrs[IPVS_CMD_ATTR_SERVICE]);\r\nif (IS_ERR(svc)) {\r\nret = PTR_ERR(svc);\r\ngoto out_err;\r\n} else if (svc) {\r\nret = ip_vs_genl_fill_service(msg, svc);\r\nif (ret)\r\ngoto nla_put_failure;\r\n} else {\r\nret = -ESRCH;\r\ngoto out_err;\r\n}\r\nbreak;\r\n}\r\ncase IPVS_CMD_GET_CONFIG:\r\n{\r\nstruct ip_vs_timeout_user t;\r\n__ip_vs_get_timeouts(ipvs, &t);\r\n#ifdef CONFIG_IP_VS_PROTO_TCP\r\nif (nla_put_u32(msg, IPVS_CMD_ATTR_TIMEOUT_TCP,\r\nt.tcp_timeout) ||\r\nnla_put_u32(msg, IPVS_CMD_ATTR_TIMEOUT_TCP_FIN,\r\nt.tcp_fin_timeout))\r\ngoto nla_put_failure;\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_UDP\r\nif (nla_put_u32(msg, IPVS_CMD_ATTR_TIMEOUT_UDP, t.udp_timeout))\r\ngoto nla_put_failure;\r\n#endif\r\nbreak;\r\n}\r\ncase IPVS_CMD_GET_INFO:\r\nif (nla_put_u32(msg, IPVS_INFO_ATTR_VERSION,\r\nIP_VS_VERSION_CODE) ||\r\nnla_put_u32(msg, IPVS_INFO_ATTR_CONN_TAB_SIZE,\r\nip_vs_conn_tab_size))\r\ngoto nla_put_failure;\r\nbreak;\r\n}\r\ngenlmsg_end(msg, reply);\r\nret = genlmsg_reply(msg, info);\r\ngoto out;\r\nnla_put_failure:\r\npr_err("not enough space in Netlink message\n");\r\nret = -EMSGSIZE;\r\nout_err:\r\nnlmsg_free(msg);\r\nout:\r\nmutex_unlock(&__ip_vs_mutex);\r\nreturn ret;\r\n}\r\nstatic int __init ip_vs_genl_register(void)\r\n{\r\nreturn genl_register_family_with_ops(&ip_vs_genl_family,\r\nip_vs_genl_ops);\r\n}\r\nstatic void ip_vs_genl_unregister(void)\r\n{\r\ngenl_unregister_family(&ip_vs_genl_family);\r\n}\r\nstatic int __net_init ip_vs_control_net_init_sysctl(struct netns_ipvs *ipvs)\r\n{\r\nstruct net *net = ipvs->net;\r\nint idx;\r\nstruct ctl_table *tbl;\r\natomic_set(&ipvs->dropentry, 0);\r\nspin_lock_init(&ipvs->dropentry_lock);\r\nspin_lock_init(&ipvs->droppacket_lock);\r\nspin_lock_init(&ipvs->securetcp_lock);\r\nif (!net_eq(net, &init_net)) {\r\ntbl = kmemdup(vs_vars, sizeof(vs_vars), GFP_KERNEL);\r\nif (tbl == NULL)\r\nreturn -ENOMEM;\r\nif (net->user_ns != &init_user_ns)\r\ntbl[0].procname = NULL;\r\n} else\r\ntbl = vs_vars;\r\nfor (idx = 0; idx < ARRAY_SIZE(vs_vars); idx++) {\r\nif (tbl[idx].proc_handler == proc_do_defense_mode)\r\ntbl[idx].extra2 = ipvs;\r\n}\r\nidx = 0;\r\nipvs->sysctl_amemthresh = 1024;\r\ntbl[idx++].data = &ipvs->sysctl_amemthresh;\r\nipvs->sysctl_am_droprate = 10;\r\ntbl[idx++].data = &ipvs->sysctl_am_droprate;\r\ntbl[idx++].data = &ipvs->sysctl_drop_entry;\r\ntbl[idx++].data = &ipvs->sysctl_drop_packet;\r\n#ifdef CONFIG_IP_VS_NFCT\r\ntbl[idx++].data = &ipvs->sysctl_conntrack;\r\n#endif\r\ntbl[idx++].data = &ipvs->sysctl_secure_tcp;\r\nipvs->sysctl_snat_reroute = 1;\r\ntbl[idx++].data = &ipvs->sysctl_snat_reroute;\r\nipvs->sysctl_sync_ver = 1;\r\ntbl[idx++].data = &ipvs->sysctl_sync_ver;\r\nipvs->sysctl_sync_ports = 1;\r\ntbl[idx++].data = &ipvs->sysctl_sync_ports;\r\ntbl[idx++].data = &ipvs->sysctl_sync_persist_mode;\r\nipvs->sysctl_sync_qlen_max = nr_free_buffer_pages() / 32;\r\ntbl[idx++].data = &ipvs->sysctl_sync_qlen_max;\r\nipvs->sysctl_sync_sock_size = 0;\r\ntbl[idx++].data = &ipvs->sysctl_sync_sock_size;\r\ntbl[idx++].data = &ipvs->sysctl_cache_bypass;\r\ntbl[idx++].data = &ipvs->sysctl_expire_nodest_conn;\r\ntbl[idx++].data = &ipvs->sysctl_sloppy_tcp;\r\ntbl[idx++].data = &ipvs->sysctl_sloppy_sctp;\r\ntbl[idx++].data = &ipvs->sysctl_expire_quiescent_template;\r\nipvs->sysctl_sync_threshold[0] = DEFAULT_SYNC_THRESHOLD;\r\nipvs->sysctl_sync_threshold[1] = DEFAULT_SYNC_PERIOD;\r\ntbl[idx].data = &ipvs->sysctl_sync_threshold;\r\ntbl[idx++].maxlen = sizeof(ipvs->sysctl_sync_threshold);\r\nipvs->sysctl_sync_refresh_period = DEFAULT_SYNC_REFRESH_PERIOD;\r\ntbl[idx++].data = &ipvs->sysctl_sync_refresh_period;\r\nipvs->sysctl_sync_retries = clamp_t(int, DEFAULT_SYNC_RETRIES, 0, 3);\r\ntbl[idx++].data = &ipvs->sysctl_sync_retries;\r\ntbl[idx++].data = &ipvs->sysctl_nat_icmp_send;\r\nipvs->sysctl_pmtu_disc = 1;\r\ntbl[idx++].data = &ipvs->sysctl_pmtu_disc;\r\ntbl[idx++].data = &ipvs->sysctl_backup_only;\r\nipvs->sysctl_conn_reuse_mode = 1;\r\ntbl[idx++].data = &ipvs->sysctl_conn_reuse_mode;\r\ntbl[idx++].data = &ipvs->sysctl_schedule_icmp;\r\ntbl[idx++].data = &ipvs->sysctl_ignore_tunneled;\r\nipvs->sysctl_hdr = register_net_sysctl(net, "net/ipv4/vs", tbl);\r\nif (ipvs->sysctl_hdr == NULL) {\r\nif (!net_eq(net, &init_net))\r\nkfree(tbl);\r\nreturn -ENOMEM;\r\n}\r\nip_vs_start_estimator(ipvs, &ipvs->tot_stats);\r\nipvs->sysctl_tbl = tbl;\r\nINIT_DELAYED_WORK(&ipvs->defense_work, defense_work_handler);\r\nschedule_delayed_work(&ipvs->defense_work, DEFENSE_TIMER_PERIOD);\r\nreturn 0;\r\n}\r\nstatic void __net_exit ip_vs_control_net_cleanup_sysctl(struct netns_ipvs *ipvs)\r\n{\r\nstruct net *net = ipvs->net;\r\ncancel_delayed_work_sync(&ipvs->defense_work);\r\ncancel_work_sync(&ipvs->defense_work.work);\r\nunregister_net_sysctl_table(ipvs->sysctl_hdr);\r\nip_vs_stop_estimator(ipvs, &ipvs->tot_stats);\r\nif (!net_eq(net, &init_net))\r\nkfree(ipvs->sysctl_tbl);\r\n}\r\nstatic int __net_init ip_vs_control_net_init_sysctl(struct netns_ipvs *ipvs) { return 0; }\r\nstatic void __net_exit ip_vs_control_net_cleanup_sysctl(struct netns_ipvs *ipvs) { }\r\nint __net_init ip_vs_control_net_init(struct netns_ipvs *ipvs)\r\n{\r\nint i, idx;\r\nfor (idx = 0; idx < IP_VS_RTAB_SIZE; idx++)\r\nINIT_HLIST_HEAD(&ipvs->rs_table[idx]);\r\nINIT_LIST_HEAD(&ipvs->dest_trash);\r\nspin_lock_init(&ipvs->dest_trash_lock);\r\nsetup_timer(&ipvs->dest_trash_timer, ip_vs_dest_trash_expire,\r\n(unsigned long) ipvs);\r\natomic_set(&ipvs->ftpsvc_counter, 0);\r\natomic_set(&ipvs->nullsvc_counter, 0);\r\natomic_set(&ipvs->conn_out_counter, 0);\r\nipvs->tot_stats.cpustats = alloc_percpu(struct ip_vs_cpu_stats);\r\nif (!ipvs->tot_stats.cpustats)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(i) {\r\nstruct ip_vs_cpu_stats *ipvs_tot_stats;\r\nipvs_tot_stats = per_cpu_ptr(ipvs->tot_stats.cpustats, i);\r\nu64_stats_init(&ipvs_tot_stats->syncp);\r\n}\r\nspin_lock_init(&ipvs->tot_stats.lock);\r\nproc_create("ip_vs", 0, ipvs->net->proc_net, &ip_vs_info_fops);\r\nproc_create("ip_vs_stats", 0, ipvs->net->proc_net, &ip_vs_stats_fops);\r\nproc_create("ip_vs_stats_percpu", 0, ipvs->net->proc_net,\r\n&ip_vs_stats_percpu_fops);\r\nif (ip_vs_control_net_init_sysctl(ipvs))\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nfree_percpu(ipvs->tot_stats.cpustats);\r\nreturn -ENOMEM;\r\n}\r\nvoid __net_exit ip_vs_control_net_cleanup(struct netns_ipvs *ipvs)\r\n{\r\nip_vs_trash_cleanup(ipvs);\r\nip_vs_control_net_cleanup_sysctl(ipvs);\r\nremove_proc_entry("ip_vs_stats_percpu", ipvs->net->proc_net);\r\nremove_proc_entry("ip_vs_stats", ipvs->net->proc_net);\r\nremove_proc_entry("ip_vs", ipvs->net->proc_net);\r\nfree_percpu(ipvs->tot_stats.cpustats);\r\n}\r\nint __init ip_vs_register_nl_ioctl(void)\r\n{\r\nint ret;\r\nret = nf_register_sockopt(&ip_vs_sockopts);\r\nif (ret) {\r\npr_err("cannot register sockopt.\n");\r\ngoto err_sock;\r\n}\r\nret = ip_vs_genl_register();\r\nif (ret) {\r\npr_err("cannot register Generic Netlink interface.\n");\r\ngoto err_genl;\r\n}\r\nreturn 0;\r\nerr_genl:\r\nnf_unregister_sockopt(&ip_vs_sockopts);\r\nerr_sock:\r\nreturn ret;\r\n}\r\nvoid ip_vs_unregister_nl_ioctl(void)\r\n{\r\nip_vs_genl_unregister();\r\nnf_unregister_sockopt(&ip_vs_sockopts);\r\n}\r\nint __init ip_vs_control_init(void)\r\n{\r\nint idx;\r\nint ret;\r\nEnterFunction(2);\r\nfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\r\nINIT_HLIST_HEAD(&ip_vs_svc_table[idx]);\r\nINIT_HLIST_HEAD(&ip_vs_svc_fwm_table[idx]);\r\n}\r\nsmp_wmb();\r\nret = register_netdevice_notifier(&ip_vs_dst_notifier);\r\nif (ret < 0)\r\nreturn ret;\r\nLeaveFunction(2);\r\nreturn 0;\r\n}\r\nvoid ip_vs_control_cleanup(void)\r\n{\r\nEnterFunction(2);\r\nunregister_netdevice_notifier(&ip_vs_dst_notifier);\r\nLeaveFunction(2);\r\n}
