static int apply_r_mips_32_rela(struct module *me, u32 *location, Elf_Addr v)\r\n{\r\n*location = v;\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_26_rela(struct module *me, u32 *location, Elf_Addr v)\r\n{\r\nif (v % 4) {\r\npr_err("module %s: dangerous R_MIPS_26 RELA relocation\n",\r\nme->name);\r\nreturn -ENOEXEC;\r\n}\r\nif ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {\r\npr_err("module %s: relocation overflow\n", me->name);\r\nreturn -ENOEXEC;\r\n}\r\n*location = (*location & ~0x03ffffff) | ((v >> 2) & 0x03ffffff);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_hi16_rela(struct module *me, u32 *location, Elf_Addr v)\r\n{\r\n*location = (*location & 0xffff0000) |\r\n((((long long) v + 0x8000LL) >> 16) & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_lo16_rela(struct module *me, u32 *location, Elf_Addr v)\r\n{\r\n*location = (*location & 0xffff0000) | (v & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_pc_rela(struct module *me, u32 *location, Elf_Addr v,\r\nunsigned bits)\r\n{\r\nunsigned long mask = GENMASK(bits - 1, 0);\r\nunsigned long se_bits;\r\nlong offset;\r\nif (v % 4) {\r\npr_err("module %s: dangerous R_MIPS_PC%u RELA relocation\n",\r\nme->name, bits);\r\nreturn -ENOEXEC;\r\n}\r\noffset = ((long)v - (long)location) >> 2;\r\nse_bits = (offset & BIT(bits - 1)) ? ~0ul : 0;\r\nif ((offset & ~mask) != (se_bits & ~mask)) {\r\npr_err("module %s: relocation overflow\n", me->name);\r\nreturn -ENOEXEC;\r\n}\r\n*location = (*location & ~mask) | (offset & mask);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_pc16_rela(struct module *me, u32 *location, Elf_Addr v)\r\n{\r\nreturn apply_r_mips_pc_rela(me, location, v, 16);\r\n}\r\nstatic int apply_r_mips_pc21_rela(struct module *me, u32 *location, Elf_Addr v)\r\n{\r\nreturn apply_r_mips_pc_rela(me, location, v, 21);\r\n}\r\nstatic int apply_r_mips_pc26_rela(struct module *me, u32 *location, Elf_Addr v)\r\n{\r\nreturn apply_r_mips_pc_rela(me, location, v, 26);\r\n}\r\nstatic int apply_r_mips_64_rela(struct module *me, u32 *location, Elf_Addr v)\r\n{\r\n*(Elf_Addr *)location = v;\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_higher_rela(struct module *me, u32 *location,\r\nElf_Addr v)\r\n{\r\n*location = (*location & 0xffff0000) |\r\n((((long long) v + 0x80008000LL) >> 32) & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_highest_rela(struct module *me, u32 *location,\r\nElf_Addr v)\r\n{\r\n*location = (*location & 0xffff0000) |\r\n((((long long) v + 0x800080008000LL) >> 48) & 0xffff);\r\nreturn 0;\r\n}\r\nint apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,\r\nunsigned int symindex, unsigned int relsec,\r\nstruct module *me)\r\n{\r\nElf_Mips_Rela *rel = (void *) sechdrs[relsec].sh_addr;\r\nint (*handler)(struct module *me, u32 *location, Elf_Addr v);\r\nElf_Sym *sym;\r\nu32 *location;\r\nunsigned int i, type;\r\nElf_Addr v;\r\nint res;\r\npr_debug("Applying relocate section %u to %u\n", relsec,\r\nsechdrs[relsec].sh_info);\r\nfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {\r\nlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\r\n+ rel[i].r_offset;\r\nsym = (Elf_Sym *)sechdrs[symindex].sh_addr\r\n+ ELF_MIPS_R_SYM(rel[i]);\r\nif (sym->st_value >= -MAX_ERRNO) {\r\nif (ELF_ST_BIND(sym->st_info) == STB_WEAK)\r\ncontinue;\r\npr_warn("%s: Unknown symbol %s\n",\r\nme->name, strtab + sym->st_name);\r\nreturn -ENOENT;\r\n}\r\ntype = ELF_MIPS_R_TYPE(rel[i]);\r\nif (type < ARRAY_SIZE(reloc_handlers_rela))\r\nhandler = reloc_handlers_rela[type];\r\nelse\r\nhandler = NULL;\r\nif (!handler) {\r\npr_err("%s: Unknown relocation type %u\n",\r\nme->name, type);\r\nreturn -EINVAL;\r\n}\r\nv = sym->st_value + rel[i].r_addend;\r\nres = handler(me, location, v);\r\nif (res)\r\nreturn res;\r\n}\r\nreturn 0;\r\n}
