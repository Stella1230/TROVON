static inline cputime64_t get_cpu_idle_time(unsigned int cpu)\r\n{\r\nu64 retval;\r\nretval = kcpustat_cpu(cpu).cpustat[CPUTIME_IDLE] +\r\nkcpustat_cpu(cpu).cpustat[CPUTIME_IOWAIT];\r\nif (rackmeter_ignore_nice)\r\nretval += kcpustat_cpu(cpu).cpustat[CPUTIME_NICE];\r\nreturn retval;\r\n}\r\nstatic void rackmeter_setup_i2s(struct rackmeter *rm)\r\n{\r\nstruct macio_chip *macio = rm->mdev->bus->chip;\r\npmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, RACKMETER_MAGIC_GPIO, 5);\r\npmac_call_feature(PMAC_FTR_SOUND_CHIP_ENABLE, rm->i2s, 0, 1);\r\nMACIO_BIS(KEYLARGO_FCR1, KL1_I2S0_ENABLE);\r\nMACIO_BIC(KEYLARGO_FCR1, KL1_I2S0_CLK_ENABLE_BIT);\r\n(void)MACIO_IN32(KEYLARGO_FCR1);\r\nudelay(10);\r\nout_le32(rm->i2s_regs + 0x10, 0x01fa0000);\r\n(void)in_le32(rm->i2s_regs + 0x10);\r\nudelay(10);\r\nMACIO_BIS(KEYLARGO_FCR1, KL1_I2S0_CELL_ENABLE |\r\nKL1_I2S0_CLK_ENABLE_BIT);\r\n(void)MACIO_IN32(KEYLARGO_FCR1);\r\nudelay(10);\r\n}\r\nstatic void rackmeter_set_default_pattern(struct rackmeter *rm)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\nif (i < 8)\r\nrm->ubuf[i] = (i & 1) * 255;\r\nelse\r\nrm->ubuf[i] = ((~i) & 1) * 255;\r\n}\r\n}\r\nstatic void rackmeter_do_pause(struct rackmeter *rm, int pause)\r\n{\r\nstruct rackmeter_dma *rdma = rm->dma_buf_v;\r\npr_debug("rackmeter: %s\n", pause ? "paused" : "started");\r\nrm->paused = pause;\r\nif (pause) {\r\nDBDMA_DO_STOP(rm->dma_regs);\r\nreturn;\r\n}\r\nmemset(rdma->buf1, 0, ARRAY_SIZE(rdma->buf1));\r\nmemset(rdma->buf2, 0, ARRAY_SIZE(rdma->buf2));\r\nrm->dma_buf_v->mark = 0;\r\nmb();\r\nout_le32(&rm->dma_regs->cmdptr_hi, 0);\r\nout_le32(&rm->dma_regs->cmdptr, rm->dma_buf_p);\r\nout_le32(&rm->dma_regs->control, (RUN << 16) | RUN);\r\n}\r\nstatic void rackmeter_setup_dbdma(struct rackmeter *rm)\r\n{\r\nstruct rackmeter_dma *db = rm->dma_buf_v;\r\nstruct dbdma_cmd *cmd = db->cmd;\r\nDBDMA_DO_RESET(rm->dma_regs);\r\npr_debug("rackmeter: mark offset=0x%zx\n",\r\noffsetof(struct rackmeter_dma, mark));\r\npr_debug("rackmeter: buf1 offset=0x%zx\n",\r\noffsetof(struct rackmeter_dma, buf1));\r\npr_debug("rackmeter: buf2 offset=0x%zx\n",\r\noffsetof(struct rackmeter_dma, buf2));\r\nmemset(cmd, 0, 4 * sizeof(struct dbdma_cmd));\r\ncmd->req_count = cpu_to_le16(4);\r\ncmd->command = cpu_to_le16(STORE_WORD | INTR_ALWAYS | KEY_SYSTEM);\r\ncmd->phy_addr = cpu_to_le32(rm->dma_buf_p +\r\noffsetof(struct rackmeter_dma, mark));\r\ncmd->cmd_dep = cpu_to_le32(0x02000000);\r\ncmd++;\r\ncmd->req_count = cpu_to_le16(SAMPLE_COUNT * 4);\r\ncmd->command = cpu_to_le16(OUTPUT_MORE);\r\ncmd->phy_addr = cpu_to_le32(rm->dma_buf_p +\r\noffsetof(struct rackmeter_dma, buf1));\r\ncmd++;\r\ncmd->req_count = cpu_to_le16(4);\r\ncmd->command = cpu_to_le16(STORE_WORD | INTR_ALWAYS | KEY_SYSTEM);\r\ncmd->phy_addr = cpu_to_le32(rm->dma_buf_p +\r\noffsetof(struct rackmeter_dma, mark));\r\ncmd->cmd_dep = cpu_to_le32(0x01000000);\r\ncmd++;\r\ncmd->req_count = cpu_to_le16(SAMPLE_COUNT * 4);\r\ncmd->command = cpu_to_le16(OUTPUT_MORE | BR_ALWAYS);\r\ncmd->phy_addr = cpu_to_le32(rm->dma_buf_p +\r\noffsetof(struct rackmeter_dma, buf2));\r\ncmd->cmd_dep = cpu_to_le32(rm->dma_buf_p);\r\nrackmeter_do_pause(rm, 0);\r\n}\r\nstatic void rackmeter_do_timer(struct work_struct *work)\r\n{\r\nstruct rackmeter_cpu *rcpu =\r\ncontainer_of(work, struct rackmeter_cpu, sniffer.work);\r\nstruct rackmeter *rm = rcpu->rm;\r\nunsigned int cpu = smp_processor_id();\r\ncputime64_t cur_jiffies, total_idle_ticks;\r\nunsigned int total_ticks, idle_ticks;\r\nint i, offset, load, cumm, pause;\r\ncur_jiffies = jiffies64_to_cputime64(get_jiffies_64());\r\ntotal_ticks = (unsigned int) (cur_jiffies - rcpu->prev_wall);\r\nrcpu->prev_wall = cur_jiffies;\r\ntotal_idle_ticks = get_cpu_idle_time(cpu);\r\nidle_ticks = (unsigned int) (total_idle_ticks - rcpu->prev_idle);\r\nidle_ticks = min(idle_ticks, total_ticks);\r\nrcpu->prev_idle = total_idle_ticks;\r\nload = (9 * (total_ticks - idle_ticks)) / total_ticks;\r\noffset = cpu << 3;\r\ncumm = 0;\r\nfor (i = 0; i < 8; i++) {\r\nu8 ub = (load > i) ? 0xff : 0;\r\nrm->ubuf[i + offset] = ub;\r\ncumm |= ub;\r\n}\r\nrcpu->zero = (cumm == 0);\r\npause = (rm->cpu[0].zero && rm->cpu[1].zero);\r\nif (pause != rm->paused) {\r\nmutex_lock(&rm->sem);\r\npause = (rm->cpu[0].zero && rm->cpu[1].zero);\r\nrackmeter_do_pause(rm, pause);\r\nmutex_unlock(&rm->sem);\r\n}\r\nschedule_delayed_work_on(cpu, &rcpu->sniffer,\r\nmsecs_to_jiffies(CPU_SAMPLING_RATE));\r\n}\r\nstatic void rackmeter_init_cpu_sniffer(struct rackmeter *rm)\r\n{\r\nunsigned int cpu;\r\nrm->cpu[0].rm = rm;\r\nINIT_DELAYED_WORK(&rm->cpu[0].sniffer, rackmeter_do_timer);\r\nrm->cpu[1].rm = rm;\r\nINIT_DELAYED_WORK(&rm->cpu[1].sniffer, rackmeter_do_timer);\r\nfor_each_online_cpu(cpu) {\r\nstruct rackmeter_cpu *rcpu;\r\nif (cpu > 1)\r\ncontinue;\r\nrcpu = &rm->cpu[cpu];\r\nrcpu->prev_idle = get_cpu_idle_time(cpu);\r\nrcpu->prev_wall = jiffies64_to_cputime64(get_jiffies_64());\r\nschedule_delayed_work_on(cpu, &rm->cpu[cpu].sniffer,\r\nmsecs_to_jiffies(CPU_SAMPLING_RATE));\r\n}\r\n}\r\nstatic void rackmeter_stop_cpu_sniffer(struct rackmeter *rm)\r\n{\r\ncancel_delayed_work_sync(&rm->cpu[0].sniffer);\r\ncancel_delayed_work_sync(&rm->cpu[1].sniffer);\r\n}\r\nstatic int rackmeter_setup(struct rackmeter *rm)\r\n{\r\npr_debug("rackmeter: setting up i2s..\n");\r\nrackmeter_setup_i2s(rm);\r\npr_debug("rackmeter: setting up default pattern..\n");\r\nrackmeter_set_default_pattern(rm);\r\npr_debug("rackmeter: setting up dbdma..\n");\r\nrackmeter_setup_dbdma(rm);\r\npr_debug("rackmeter: start CPU measurements..\n");\r\nrackmeter_init_cpu_sniffer(rm);\r\nprintk(KERN_INFO "RackMeter initialized\n");\r\nreturn 0;\r\n}\r\nstatic u32 rackmeter_calc_sample(struct rackmeter *rm, unsigned int index)\r\n{\r\nint led;\r\nu32 sample = 0;\r\nfor (led = 0; led < 16; led++) {\r\nsample >>= 1;\r\nsample |= ((rm->ubuf[led] >= 0x80) << 15);\r\n}\r\nreturn (sample << 17) | (sample >> 15);\r\n}\r\nstatic irqreturn_t rackmeter_irq(int irq, void *arg)\r\n{\r\nstruct rackmeter *rm = arg;\r\nstruct rackmeter_dma *db = rm->dma_buf_v;\r\nunsigned int mark, i;\r\nu32 *buf;\r\n(void)in_le32(&rm->dma_regs->status);\r\nrmb();\r\nmark = db->mark;\r\nif (mark != 1 && mark != 2) {\r\nprintk(KERN_WARNING "rackmeter: Incorrect DMA mark 0x%08x\n",\r\nmark);\r\nif (++rm->stale_irq > 3) {\r\nprintk(KERN_ERR "rackmeter: Too many errors,"\r\n" stopping DMA\n");\r\nDBDMA_DO_RESET(rm->dma_regs);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nbuf = mark == 1 ? db->buf1 : db->buf2;\r\nfor (i = 0; i < SAMPLE_COUNT; i++)\r\nbuf[i] = rackmeter_calc_sample(rm, i);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rackmeter_probe(struct macio_dev* mdev,\r\nconst struct of_device_id *match)\r\n{\r\nstruct device_node *i2s = NULL, *np = NULL;\r\nstruct rackmeter *rm = NULL;\r\nstruct resource ri2s, rdma;\r\nint rc = -ENODEV;\r\npr_debug("rackmeter_probe()\n");\r\nwhile ((i2s = of_get_next_child(mdev->ofdev.dev.of_node, i2s)) != NULL)\r\nif (strcmp(i2s->name, "i2s-a") == 0)\r\nbreak;\r\nif (i2s == NULL) {\r\npr_debug(" i2s-a child not found\n");\r\ngoto bail;\r\n}\r\nwhile ((np = of_get_next_child(i2s, np)) != NULL) {\r\nif (strcmp(np->name, "lightshow") == 0)\r\nbreak;\r\nif ((strcmp(np->name, "sound") == 0) &&\r\nof_get_property(np, "virtual", NULL) != NULL)\r\nbreak;\r\n}\r\nif (np == NULL) {\r\npr_debug(" lightshow or sound+virtual child not found\n");\r\ngoto bail;\r\n}\r\nrm = kzalloc(sizeof(struct rackmeter), GFP_KERNEL);\r\nif (rm == NULL) {\r\nprintk(KERN_ERR "rackmeter: failed to allocate memory !\n");\r\nrc = -ENOMEM;\r\ngoto bail_release;\r\n}\r\nrm->mdev = mdev;\r\nrm->i2s = i2s;\r\nmutex_init(&rm->sem);\r\ndev_set_drvdata(&mdev->ofdev.dev, rm);\r\n#if 0\r\nif (macio_resource_count(mdev) < 2 || macio_irq_count(mdev) < 2) {\r\nprintk(KERN_ERR\r\n"rackmeter: found match but lacks resources: %s"\r\n" (%d resources, %d interrupts)\n",\r\nmdev->ofdev.node->full_name);\r\nrc = -ENXIO;\r\ngoto bail_free;\r\n}\r\nif (macio_request_resources(mdev, "rackmeter")) {\r\nprintk(KERN_ERR\r\n"rackmeter: failed to request resources: %s\n",\r\nmdev->ofdev.node->full_name);\r\nrc = -EBUSY;\r\ngoto bail_free;\r\n}\r\nrm->irq = macio_irq(mdev, 1);\r\n#else\r\nrm->irq = irq_of_parse_and_map(i2s, 1);\r\nif (rm->irq == NO_IRQ ||\r\nof_address_to_resource(i2s, 0, &ri2s) ||\r\nof_address_to_resource(i2s, 1, &rdma)) {\r\nprintk(KERN_ERR\r\n"rackmeter: found match but lacks resources: %s",\r\nmdev->ofdev.dev.of_node->full_name);\r\nrc = -ENXIO;\r\ngoto bail_free;\r\n}\r\n#endif\r\npr_debug(" i2s @0x%08x\n", (unsigned int)ri2s.start);\r\npr_debug(" dma @0x%08x\n", (unsigned int)rdma.start);\r\npr_debug(" irq %d\n", rm->irq);\r\nrm->ubuf = (u8 *)__get_free_page(GFP_KERNEL);\r\nif (rm->ubuf == NULL) {\r\nprintk(KERN_ERR\r\n"rackmeter: failed to allocate samples page !\n");\r\nrc = -ENOMEM;\r\ngoto bail_release;\r\n}\r\nrm->dma_buf_v = dma_alloc_coherent(&macio_get_pci_dev(mdev)->dev,\r\nsizeof(struct rackmeter_dma),\r\n&rm->dma_buf_p, GFP_KERNEL);\r\nif (rm->dma_buf_v == NULL) {\r\nprintk(KERN_ERR\r\n"rackmeter: failed to allocate dma buffer !\n");\r\nrc = -ENOMEM;\r\ngoto bail_free_samples;\r\n}\r\n#if 0\r\nrm->i2s_regs = ioremap(macio_resource_start(mdev, 0), 0x1000);\r\n#else\r\nrm->i2s_regs = ioremap(ri2s.start, 0x1000);\r\n#endif\r\nif (rm->i2s_regs == NULL) {\r\nprintk(KERN_ERR\r\n"rackmeter: failed to map i2s registers !\n");\r\nrc = -ENXIO;\r\ngoto bail_free_dma;\r\n}\r\n#if 0\r\nrm->dma_regs = ioremap(macio_resource_start(mdev, 1), 0x100);\r\n#else\r\nrm->dma_regs = ioremap(rdma.start, 0x100);\r\n#endif\r\nif (rm->dma_regs == NULL) {\r\nprintk(KERN_ERR\r\n"rackmeter: failed to map dma registers !\n");\r\nrc = -ENXIO;\r\ngoto bail_unmap_i2s;\r\n}\r\nrc = rackmeter_setup(rm);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"rackmeter: failed to initialize !\n");\r\nrc = -ENXIO;\r\ngoto bail_unmap_dma;\r\n}\r\nrc = request_irq(rm->irq, rackmeter_irq, 0, "rackmeter", rm);\r\nif (rc != 0) {\r\nprintk(KERN_ERR\r\n"rackmeter: failed to request interrupt !\n");\r\ngoto bail_stop_dma;\r\n}\r\nof_node_put(np);\r\nreturn 0;\r\nbail_stop_dma:\r\nDBDMA_DO_RESET(rm->dma_regs);\r\nbail_unmap_dma:\r\niounmap(rm->dma_regs);\r\nbail_unmap_i2s:\r\niounmap(rm->i2s_regs);\r\nbail_free_dma:\r\ndma_free_coherent(&macio_get_pci_dev(mdev)->dev,\r\nsizeof(struct rackmeter_dma),\r\nrm->dma_buf_v, rm->dma_buf_p);\r\nbail_free_samples:\r\nfree_page((unsigned long)rm->ubuf);\r\nbail_release:\r\n#if 0\r\nmacio_release_resources(mdev);\r\n#endif\r\nbail_free:\r\nkfree(rm);\r\nbail:\r\nof_node_put(i2s);\r\nof_node_put(np);\r\ndev_set_drvdata(&mdev->ofdev.dev, NULL);\r\nreturn rc;\r\n}\r\nstatic int rackmeter_remove(struct macio_dev* mdev)\r\n{\r\nstruct rackmeter *rm = dev_get_drvdata(&mdev->ofdev.dev);\r\nrackmeter_stop_cpu_sniffer(rm);\r\ndev_set_drvdata(&mdev->ofdev.dev, NULL);\r\nDBDMA_DO_RESET(rm->dma_regs);\r\nfree_irq(rm->irq, rm);\r\niounmap(rm->dma_regs);\r\niounmap(rm->i2s_regs);\r\ndma_free_coherent(&macio_get_pci_dev(mdev)->dev,\r\nsizeof(struct rackmeter_dma),\r\nrm->dma_buf_v, rm->dma_buf_p);\r\nfree_page((unsigned long)rm->ubuf);\r\n#if 0\r\nmacio_release_resources(mdev);\r\n#endif\r\nkfree(rm);\r\nreturn 0;\r\n}\r\nstatic int rackmeter_shutdown(struct macio_dev* mdev)\r\n{\r\nstruct rackmeter *rm = dev_get_drvdata(&mdev->ofdev.dev);\r\nif (rm == NULL)\r\nreturn -ENODEV;\r\nrackmeter_stop_cpu_sniffer(rm);\r\nDBDMA_DO_RESET(rm->dma_regs);\r\nreturn 0;\r\n}\r\nstatic int __init rackmeter_init(void)\r\n{\r\npr_debug("rackmeter_init()\n");\r\nreturn macio_register_driver(&rackmeter_driver);\r\n}\r\nstatic void __exit rackmeter_exit(void)\r\n{\r\npr_debug("rackmeter_exit()\n");\r\nmacio_unregister_driver(&rackmeter_driver);\r\n}
