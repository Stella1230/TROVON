static int do_dh(MPI result, MPI base, MPI xa, MPI p)\r\n{\r\nreturn mpi_powm(result, base, xa, p);\r\n}\r\nstatic ssize_t mpi_from_key(key_serial_t keyid, size_t maxlen, MPI *mpi)\r\n{\r\nstruct key *key;\r\nkey_ref_t key_ref;\r\nlong status;\r\nssize_t ret;\r\nkey_ref = lookup_user_key(keyid, 0, KEY_NEED_READ);\r\nif (IS_ERR(key_ref)) {\r\nret = -ENOKEY;\r\ngoto error;\r\n}\r\nkey = key_ref_to_ptr(key_ref);\r\nret = -EOPNOTSUPP;\r\nif (key->type == &key_type_user) {\r\ndown_read(&key->sem);\r\nstatus = key_validate(key);\r\nif (status == 0) {\r\nconst struct user_key_payload *payload;\r\npayload = user_key_payload(key);\r\nif (maxlen == 0) {\r\n*mpi = NULL;\r\nret = payload->datalen;\r\n} else if (payload->datalen <= maxlen) {\r\n*mpi = mpi_read_raw_data(payload->data,\r\npayload->datalen);\r\nif (*mpi)\r\nret = payload->datalen;\r\n} else {\r\nret = -EINVAL;\r\n}\r\n}\r\nup_read(&key->sem);\r\n}\r\nkey_put(key);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_dh_compute(struct keyctl_dh_params __user *params,\r\nchar __user *buffer, size_t buflen,\r\nvoid __user *reserved)\r\n{\r\nlong ret;\r\nMPI base, private, prime, result;\r\nunsigned nbytes;\r\nstruct keyctl_dh_params pcopy;\r\nuint8_t *kbuf;\r\nssize_t keylen;\r\nsize_t resultlen;\r\nif (!params || (!buffer && buflen)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (copy_from_user(&pcopy, params, sizeof(pcopy)) != 0) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (reserved) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nkeylen = mpi_from_key(pcopy.prime, buflen, &prime);\r\nif (keylen < 0 || !prime) {\r\nret = keylen;\r\ngoto out;\r\n}\r\nresultlen = keylen;\r\nkeylen = mpi_from_key(pcopy.base, SIZE_MAX, &base);\r\nif (keylen < 0 || !base) {\r\nret = keylen;\r\ngoto error1;\r\n}\r\nkeylen = mpi_from_key(pcopy.private, SIZE_MAX, &private);\r\nif (keylen < 0 || !private) {\r\nret = keylen;\r\ngoto error2;\r\n}\r\nresult = mpi_alloc(0);\r\nif (!result) {\r\nret = -ENOMEM;\r\ngoto error3;\r\n}\r\nkbuf = kmalloc(resultlen, GFP_KERNEL);\r\nif (!kbuf) {\r\nret = -ENOMEM;\r\ngoto error4;\r\n}\r\nret = do_dh(result, base, private, prime);\r\nif (ret)\r\ngoto error5;\r\nret = mpi_read_buffer(result, kbuf, resultlen, &nbytes, NULL);\r\nif (ret != 0)\r\ngoto error5;\r\nret = nbytes;\r\nif (copy_to_user(buffer, kbuf, nbytes) != 0)\r\nret = -EFAULT;\r\nerror5:\r\nkfree(kbuf);\r\nerror4:\r\nmpi_free(result);\r\nerror3:\r\nmpi_free(private);\r\nerror2:\r\nmpi_free(base);\r\nerror1:\r\nmpi_free(prime);\r\nout:\r\nreturn ret;\r\n}
