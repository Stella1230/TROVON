static int skb_to_mamac(const struct sk_buff *skb, struct mbo *mbo)\r\n{\r\nu8 *buff = mbo->virt_address;\r\nconst u8 broadcast[] = { 0x03, 0xFF };\r\nconst u8 *dest_addr = skb->data + 4;\r\nconst u8 *eth_type = skb->data + 12;\r\nunsigned int payload_len = skb->len - ETH_HLEN;\r\nunsigned int mdp_len = payload_len + MDP_HDR_LEN;\r\nif (mbo->buffer_length < mdp_len) {\r\npr_err("drop: too small buffer! (%d for %d)\n",\r\nmbo->buffer_length, mdp_len);\r\nreturn -EINVAL;\r\n}\r\nif (skb->len < ETH_HLEN) {\r\npr_err("drop: too small packet! (%d)\n", skb->len);\r\nreturn -EINVAL;\r\n}\r\nif (dest_addr[0] == 0xFF && dest_addr[1] == 0xFF)\r\ndest_addr = broadcast;\r\n*buff++ = HB(mdp_len - 2);\r\n*buff++ = LB(mdp_len - 2);\r\n*buff++ = PMHL;\r\n*buff++ = (PMS_FIFONO_MDP << PMS_FIFONO_SHIFT) | PMS_MSGTYPE_DATA;\r\n*buff++ = PMS_DEF_PRIO;\r\n*buff++ = dest_addr[0];\r\n*buff++ = dest_addr[1];\r\n*buff++ = 0x00;\r\n*buff++ = HB(payload_len + 6);\r\n*buff++ = LB(payload_len + 6);\r\n*buff++ = eth_type[0];\r\n*buff++ = eth_type[1];\r\n*buff++ = 0;\r\n*buff++ = 0;\r\n*buff++ = PMS_TELID_UNSEGM_MAMAC << 4 | HB(payload_len);\r\n*buff++ = LB(payload_len);\r\nmemcpy(buff, skb->data + ETH_HLEN, payload_len);\r\nmbo->buffer_length = mdp_len;\r\nreturn 0;\r\n}\r\nstatic int skb_to_mep(const struct sk_buff *skb, struct mbo *mbo)\r\n{\r\nu8 *buff = mbo->virt_address;\r\nunsigned int mep_len = skb->len + MEP_HDR_LEN;\r\nif (mbo->buffer_length < mep_len) {\r\npr_err("drop: too small buffer! (%d for %d)\n",\r\nmbo->buffer_length, mep_len);\r\nreturn -EINVAL;\r\n}\r\n*buff++ = HB(mep_len - 2);\r\n*buff++ = LB(mep_len - 2);\r\n*buff++ = PMHL;\r\n*buff++ = (PMS_FIFONO_MEP << PMS_FIFONO_SHIFT) | PMS_MSGTYPE_DATA;\r\n*buff++ = (MEP_DEF_RETRY << PMS_RETRY_SHIFT) | PMS_DEF_PRIO;\r\n*buff++ = 0;\r\n*buff++ = 0;\r\n*buff++ = 0;\r\nmemcpy(buff, skb->data, skb->len);\r\nmbo->buffer_length = mep_len;\r\nreturn 0;\r\n}\r\nstatic int most_nd_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct net_dev_context *nd = dev->ml_priv;\r\nint err = eth_mac_addr(dev, p);\r\nif (err)\r\nreturn err;\r\nBUG_ON(nd->dev != dev);\r\nnd->is_mamac =\r\n(dev->dev_addr[0] == 0 && dev->dev_addr[1] == 0 &&\r\ndev->dev_addr[2] == 0 && dev->dev_addr[3] == 0);\r\ndev->mtu = nd->is_mamac ? MAMAC_DATA_LEN : ETH_DATA_LEN;\r\nreturn 0;\r\n}\r\nstatic int most_nd_open(struct net_device *dev)\r\n{\r\nstruct net_dev_context *nd = dev->ml_priv;\r\nnetdev_info(dev, "open net device\n");\r\nBUG_ON(nd->dev != dev);\r\nif (nd->channels_opened)\r\nreturn -EFAULT;\r\nBUG_ON(!nd->tx.linked || !nd->rx.linked);\r\nif (most_start_channel(nd->iface, nd->rx.ch_id, &aim)) {\r\nnetdev_err(dev, "most_start_channel() failed\n");\r\nreturn -EBUSY;\r\n}\r\nif (most_start_channel(nd->iface, nd->tx.ch_id, &aim)) {\r\nnetdev_err(dev, "most_start_channel() failed\n");\r\nmost_stop_channel(nd->iface, nd->rx.ch_id, &aim);\r\nreturn -EBUSY;\r\n}\r\nnd->channels_opened = true;\r\nif (nd->is_mamac) {\r\nnd->link_stat = 1;\r\nnetif_wake_queue(dev);\r\n} else {\r\nnd->iface->request_netinfo(nd->iface, nd->tx.ch_id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int most_nd_stop(struct net_device *dev)\r\n{\r\nstruct net_dev_context *nd = dev->ml_priv;\r\nnetdev_info(dev, "stop net device\n");\r\nBUG_ON(nd->dev != dev);\r\nnetif_stop_queue(dev);\r\nif (nd->channels_opened) {\r\nmost_stop_channel(nd->iface, nd->rx.ch_id, &aim);\r\nmost_stop_channel(nd->iface, nd->tx.ch_id, &aim);\r\nnd->channels_opened = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t most_nd_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_dev_context *nd = dev->ml_priv;\r\nstruct mbo *mbo;\r\nint ret;\r\nBUG_ON(nd->dev != dev);\r\nmbo = most_get_mbo(nd->iface, nd->tx.ch_id, &aim);\r\nif (!mbo) {\r\nnetif_stop_queue(dev);\r\ndev->stats.tx_fifo_errors++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (nd->is_mamac)\r\nret = skb_to_mamac(skb, mbo);\r\nelse\r\nret = skb_to_mep(skb, mbo);\r\nif (ret) {\r\nmost_put_mbo(mbo);\r\ndev->stats.tx_dropped++;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nmost_submit_mbo(mbo);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void most_nd_setup(struct net_device *dev)\r\n{\r\nnetdev_info(dev, "setup net device\n");\r\nether_setup(dev);\r\ndev->netdev_ops = &most_nd_ops;\r\n}\r\nstatic void most_net_rm_netdev_safe(struct net_dev_context *nd)\r\n{\r\nif (!nd->dev)\r\nreturn;\r\npr_info("remove net device %p\n", nd->dev);\r\nunregister_netdev(nd->dev);\r\nfree_netdev(nd->dev);\r\nnd->dev = NULL;\r\n}\r\nstatic struct net_dev_context *get_net_dev_context(\r\nstruct most_interface *iface)\r\n{\r\nstruct net_dev_context *nd, *tmp;\r\nspin_lock(&list_lock);\r\nlist_for_each_entry_safe(nd, tmp, &net_devices, list) {\r\nif (nd->iface == iface) {\r\nspin_unlock(&list_lock);\r\nreturn nd;\r\n}\r\n}\r\nspin_unlock(&list_lock);\r\nreturn NULL;\r\n}\r\nstatic int aim_probe_channel(struct most_interface *iface, int channel_idx,\r\nstruct most_channel_config *ccfg,\r\nstruct kobject *parent, char *name)\r\n{\r\nstruct net_dev_context *nd;\r\nstruct net_dev_channel *ch;\r\nif (!iface)\r\nreturn -EINVAL;\r\nif (ccfg->data_type != MOST_CH_ASYNC)\r\nreturn -EINVAL;\r\nnd = get_net_dev_context(iface);\r\nif (!nd) {\r\nnd = kzalloc(sizeof(*nd), GFP_KERNEL);\r\nif (!nd)\r\nreturn -ENOMEM;\r\nnd->iface = iface;\r\nspin_lock(&list_lock);\r\nlist_add(&nd->list, &net_devices);\r\nspin_unlock(&list_lock);\r\n}\r\nch = ccfg->direction == MOST_CH_TX ? &nd->tx : &nd->rx;\r\nif (ch->linked) {\r\npr_err("only one channel per instance & direction allowed\n");\r\nreturn -EINVAL;\r\n}\r\nif (nd->tx.linked || nd->rx.linked) {\r\nstruct net_device *dev =\r\nalloc_netdev(0, "meth%d", NET_NAME_UNKNOWN,\r\nmost_nd_setup);\r\nif (!dev) {\r\npr_err("no memory for net_device\n");\r\nreturn -ENOMEM;\r\n}\r\nnd->dev = dev;\r\nch->ch_id = channel_idx;\r\nch->linked = true;\r\ndev->ml_priv = nd;\r\nif (register_netdev(dev)) {\r\npr_err("registering net device failed\n");\r\nch->linked = false;\r\nfree_netdev(dev);\r\nreturn -EINVAL;\r\n}\r\n}\r\nch->ch_id = channel_idx;\r\nch->linked = true;\r\nreturn 0;\r\n}\r\nstatic int aim_disconnect_channel(struct most_interface *iface,\r\nint channel_idx)\r\n{\r\nstruct net_dev_context *nd;\r\nstruct net_dev_channel *ch;\r\nnd = get_net_dev_context(iface);\r\nif (!nd)\r\nreturn -EINVAL;\r\nif (nd->rx.linked && channel_idx == nd->rx.ch_id)\r\nch = &nd->rx;\r\nelse if (nd->tx.linked && channel_idx == nd->tx.ch_id)\r\nch = &nd->tx;\r\nelse\r\nreturn -EINVAL;\r\nch->linked = false;\r\nmost_net_rm_netdev_safe(nd);\r\nif (!nd->rx.linked && !nd->tx.linked) {\r\nspin_lock(&list_lock);\r\nlist_del(&nd->list);\r\nspin_unlock(&list_lock);\r\nkfree(nd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aim_resume_tx_channel(struct most_interface *iface,\r\nint channel_idx)\r\n{\r\nstruct net_dev_context *nd;\r\nnd = get_net_dev_context(iface);\r\nif (!nd || !nd->channels_opened || nd->tx.ch_id != channel_idx)\r\nreturn 0;\r\nif (!nd->dev)\r\nreturn 0;\r\nnetif_wake_queue(nd->dev);\r\nreturn 0;\r\n}\r\nstatic int aim_rx_data(struct mbo *mbo)\r\n{\r\nconst u32 zero = 0;\r\nstruct net_dev_context *nd;\r\nchar *buf = mbo->virt_address;\r\nu32 len = mbo->processed_length;\r\nstruct sk_buff *skb;\r\nstruct net_device *dev;\r\nunsigned int skb_len;\r\nnd = get_net_dev_context(mbo->ifp);\r\nif (!nd || !nd->channels_opened || nd->rx.ch_id != mbo->hdm_channel_id)\r\nreturn -EIO;\r\ndev = nd->dev;\r\nif (!dev) {\r\npr_err_once("drop packet: missing net_device\n");\r\nreturn -EIO;\r\n}\r\nif (nd->is_mamac) {\r\nif (!PMS_IS_MAMAC(buf, len))\r\nreturn -EIO;\r\nskb = dev_alloc_skb(len - MDP_HDR_LEN + 2 * ETH_ALEN + 2);\r\n} else {\r\nif (!PMS_IS_MEP(buf, len))\r\nreturn -EIO;\r\nskb = dev_alloc_skb(len - MEP_HDR_LEN);\r\n}\r\nif (!skb) {\r\ndev->stats.rx_dropped++;\r\npr_err_once("drop packet: no memory for skb\n");\r\ngoto out;\r\n}\r\nskb->dev = dev;\r\nif (nd->is_mamac) {\r\nether_addr_copy(skb_put(skb, ETH_ALEN), dev->dev_addr);\r\nmemcpy(skb_put(skb, 4), &zero, 4);\r\nmemcpy(skb_put(skb, 2), buf + 5, 2);\r\nmemcpy(skb_put(skb, 2), buf + 10, 2);\r\nbuf += MDP_HDR_LEN;\r\nlen -= MDP_HDR_LEN;\r\n} else {\r\nbuf += MEP_HDR_LEN;\r\nlen -= MEP_HDR_LEN;\r\n}\r\nmemcpy(skb_put(skb, len), buf, len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nskb_len = skb->len;\r\nif (netif_rx(skb) == NET_RX_SUCCESS) {\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb_len;\r\n} else {\r\ndev->stats.rx_dropped++;\r\n}\r\nout:\r\nmost_put_mbo(mbo);\r\nreturn 0;\r\n}\r\nstatic int __init most_net_init(void)\r\n{\r\npr_info("most_net_init()\n");\r\nspin_lock_init(&list_lock);\r\nreturn most_register_aim(&aim);\r\n}\r\nstatic void __exit most_net_exit(void)\r\n{\r\nstruct net_dev_context *nd, *tmp;\r\nspin_lock(&list_lock);\r\nlist_for_each_entry_safe(nd, tmp, &net_devices, list) {\r\nlist_del(&nd->list);\r\nspin_unlock(&list_lock);\r\nmost_net_rm_netdev_safe(nd);\r\nkfree(nd);\r\nspin_lock(&list_lock);\r\n}\r\nspin_unlock(&list_lock);\r\nmost_deregister_aim(&aim);\r\npr_info("most_net_exit()\n");\r\n}\r\nvoid most_deliver_netinfo(struct most_interface *iface,\r\nunsigned char link_stat, unsigned char *mac_addr)\r\n{\r\nstruct net_dev_context *nd;\r\nstruct net_device *dev;\r\npr_info("Received netinfo from %s\n", iface->description);\r\nnd = get_net_dev_context(iface);\r\nif (!nd)\r\nreturn;\r\ndev = nd->dev;\r\nif (!dev)\r\nreturn;\r\nif (mac_addr)\r\nether_addr_copy(dev->dev_addr, mac_addr);\r\nif (nd->link_stat != link_stat) {\r\nnd->link_stat = link_stat;\r\nif (nd->link_stat)\r\nnetif_wake_queue(dev);\r\nelse\r\nnetif_stop_queue(dev);\r\n}\r\n}
