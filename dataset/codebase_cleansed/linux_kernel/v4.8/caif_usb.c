static int cfusbl_receive(struct cflayer *layr, struct cfpkt *pkt)\r\n{\r\nu8 hpad;\r\ncfpkt_extr_head(pkt, &hpad, 1);\r\ncfpkt_extr_head(pkt, NULL, hpad);\r\nreturn layr->up->receive(layr->up, pkt);\r\n}\r\nstatic int cfusbl_transmit(struct cflayer *layr, struct cfpkt *pkt)\r\n{\r\nstruct caif_payload_info *info;\r\nu8 hpad;\r\nu8 zeros[CFUSB_ALIGNMENT];\r\nstruct sk_buff *skb;\r\nstruct cfusbl *usbl = container_of(layr, struct cfusbl, layer);\r\nskb = cfpkt_tonative(pkt);\r\nskb_reset_network_header(skb);\r\nskb->protocol = htons(ETH_P_IP);\r\ninfo = cfpkt_info(pkt);\r\nhpad = (info->hdr_len + CFUSB_PAD_DESCR_SZ) & (CFUSB_ALIGNMENT - 1);\r\nif (skb_headroom(skb) < ETH_HLEN + CFUSB_PAD_DESCR_SZ + hpad) {\r\npr_warn("Headroom to small\n");\r\nkfree_skb(skb);\r\nreturn -EIO;\r\n}\r\nmemset(zeros, 0, hpad);\r\ncfpkt_add_head(pkt, zeros, hpad);\r\ncfpkt_add_head(pkt, &hpad, 1);\r\ncfpkt_add_head(pkt, usbl->tx_eth_hdr, sizeof(usbl->tx_eth_hdr));\r\nreturn layr->dn->transmit(layr->dn, pkt);\r\n}\r\nstatic void cfusbl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\r\nint phyid)\r\n{\r\nif (layr->up && layr->up->ctrlcmd)\r\nlayr->up->ctrlcmd(layr->up, ctrl, layr->id);\r\n}\r\nstatic struct cflayer *cfusbl_create(int phyid, u8 ethaddr[ETH_ALEN],\r\nu8 braddr[ETH_ALEN])\r\n{\r\nstruct cfusbl *this = kmalloc(sizeof(struct cfusbl), GFP_ATOMIC);\r\nif (!this)\r\nreturn NULL;\r\ncaif_assert(offsetof(struct cfusbl, layer) == 0);\r\nmemset(&this->layer, 0, sizeof(this->layer));\r\nthis->layer.receive = cfusbl_receive;\r\nthis->layer.transmit = cfusbl_transmit;\r\nthis->layer.ctrlcmd = cfusbl_ctrlcmd;\r\nsnprintf(this->layer.name, CAIF_LAYER_NAME_SZ, "usb%d", phyid);\r\nthis->layer.id = phyid;\r\nether_addr_copy(&this->tx_eth_hdr[ETH_ALEN], braddr);\r\nether_addr_copy(&this->tx_eth_hdr[ETH_ALEN], ethaddr);\r\nthis->tx_eth_hdr[12] = cpu_to_be16(ETH_P_802_EX1) & 0xff;\r\nthis->tx_eth_hdr[13] = (cpu_to_be16(ETH_P_802_EX1) >> 8) & 0xff;\r\npr_debug("caif ethernet TX-header dst:%pM src:%pM type:%02x%02x\n",\r\nthis->tx_eth_hdr, this->tx_eth_hdr + ETH_ALEN,\r\nthis->tx_eth_hdr[12], this->tx_eth_hdr[13]);\r\nreturn (struct cflayer *) this;\r\n}\r\nstatic int cfusbl_device_notify(struct notifier_block *me, unsigned long what,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct caif_dev_common common;\r\nstruct cflayer *layer, *link_support;\r\nstruct usbnet *usbnet;\r\nstruct usb_device *usbdev;\r\nif (!(dev->dev.parent && dev->dev.parent->driver &&\r\nstrcmp(dev->dev.parent->driver->name, "cdc_ncm") == 0))\r\nreturn 0;\r\nusbnet = netdev_priv(dev);\r\nusbdev = usbnet->udev;\r\npr_debug("USB CDC NCM device VID:0x%4x PID:0x%4x\n",\r\nle16_to_cpu(usbdev->descriptor.idVendor),\r\nle16_to_cpu(usbdev->descriptor.idProduct));\r\nif (!(le16_to_cpu(usbdev->descriptor.idVendor) == STE_USB_VID &&\r\nle16_to_cpu(usbdev->descriptor.idProduct) == STE_USB_PID_CAIF))\r\nreturn 0;\r\nif (what == NETDEV_UNREGISTER)\r\nmodule_put(THIS_MODULE);\r\nif (what != NETDEV_REGISTER)\r\nreturn 0;\r\n__module_get(THIS_MODULE);\r\nmemset(&common, 0, sizeof(common));\r\ncommon.use_frag = false;\r\ncommon.use_fcs = false;\r\ncommon.use_stx = false;\r\ncommon.link_select = CAIF_LINK_HIGH_BANDW;\r\ncommon.flowctrl = NULL;\r\nlink_support = cfusbl_create(dev->ifindex, dev->dev_addr,\r\ndev->broadcast);\r\nif (!link_support)\r\nreturn -ENOMEM;\r\nif (dev->num_tx_queues > 1)\r\npr_warn("USB device uses more than one tx queue\n");\r\ncaif_enroll_dev(dev, &common, link_support, CFUSB_MAX_HEADLEN,\r\n&layer, &caif_usb_type.func);\r\nif (!pack_added)\r\ndev_add_pack(&caif_usb_type);\r\npack_added = true;\r\nstrncpy(layer->name, dev->name,\r\nsizeof(layer->name) - 1);\r\nlayer->name[sizeof(layer->name) - 1] = 0;\r\nreturn 0;\r\n}\r\nstatic int __init cfusbl_init(void)\r\n{\r\nreturn register_netdevice_notifier(&caif_device_notifier);\r\n}\r\nstatic void __exit cfusbl_exit(void)\r\n{\r\nunregister_netdevice_notifier(&caif_device_notifier);\r\ndev_remove_pack(&caif_usb_type);\r\n}
