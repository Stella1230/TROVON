static void dwc2_track_missed_sofs(struct dwc2_hsotg *hsotg)\r\n{\r\nu16 curr_frame_number = hsotg->frame_number;\r\nu16 expected = dwc2_frame_num_inc(hsotg->last_frame_num, 1);\r\nif (expected != curr_frame_number)\r\ndwc2_sch_vdbg(hsotg, "MISSED SOF %04x != %04x\n",\r\nexpected, curr_frame_number);\r\n#ifdef CONFIG_USB_DWC2_TRACK_MISSED_SOFS\r\nif (hsotg->frame_num_idx < FRAME_NUM_ARRAY_SIZE) {\r\nif (expected != curr_frame_number) {\r\nhsotg->frame_num_array[hsotg->frame_num_idx] =\r\ncurr_frame_number;\r\nhsotg->last_frame_num_array[hsotg->frame_num_idx] =\r\nhsotg->last_frame_num;\r\nhsotg->frame_num_idx++;\r\n}\r\n} else if (!hsotg->dumped_frame_num_array) {\r\nint i;\r\ndev_info(hsotg->dev, "Frame Last Frame\n");\r\ndev_info(hsotg->dev, "----- ----------\n");\r\nfor (i = 0; i < FRAME_NUM_ARRAY_SIZE; i++) {\r\ndev_info(hsotg->dev, "0x%04x 0x%04x\n",\r\nhsotg->frame_num_array[i],\r\nhsotg->last_frame_num_array[i]);\r\n}\r\nhsotg->dumped_frame_num_array = 1;\r\n}\r\n#endif\r\nhsotg->last_frame_num = curr_frame_number;\r\n}\r\nstatic void dwc2_hc_handle_tt_clear(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nstruct usb_device *root_hub = dwc2_hsotg_to_hcd(hsotg)->self.root_hub;\r\nstruct urb *usb_urb;\r\nif (!chan->qh)\r\nreturn;\r\nif (chan->qh->dev_speed == USB_SPEED_HIGH)\r\nreturn;\r\nif (!qtd->urb)\r\nreturn;\r\nusb_urb = qtd->urb->priv;\r\nif (!usb_urb || !usb_urb->dev || !usb_urb->dev->tt)\r\nreturn;\r\nif (usb_urb->dev->tt->hub == root_hub)\r\nreturn;\r\nif (qtd->urb->status != -EPIPE && qtd->urb->status != -EREMOTEIO) {\r\nchan->qh->tt_buffer_dirty = 1;\r\nif (usb_hub_clear_tt_buffer(usb_urb))\r\nchan->qh->tt_buffer_dirty = 0;\r\n}\r\n}\r\nstatic void dwc2_sof_intr(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct list_head *qh_entry;\r\nstruct dwc2_qh *qh;\r\nenum dwc2_transaction_type tr_type;\r\ndwc2_writel(GINTSTS_SOF, hsotg->regs + GINTSTS);\r\n#ifdef DEBUG_SOF\r\ndev_vdbg(hsotg->dev, "--Start of Frame Interrupt--\n");\r\n#endif\r\nhsotg->frame_number = dwc2_hcd_get_frame_number(hsotg);\r\ndwc2_track_missed_sofs(hsotg);\r\nqh_entry = hsotg->periodic_sched_inactive.next;\r\nwhile (qh_entry != &hsotg->periodic_sched_inactive) {\r\nqh = list_entry(qh_entry, struct dwc2_qh, qh_list_entry);\r\nqh_entry = qh_entry->next;\r\nif (dwc2_frame_num_le(qh->next_active_frame,\r\nhsotg->frame_number)) {\r\ndwc2_sch_vdbg(hsotg, "QH=%p ready fn=%04x, nxt=%04x\n",\r\nqh, hsotg->frame_number,\r\nqh->next_active_frame);\r\nlist_move_tail(&qh->qh_list_entry,\r\n&hsotg->periodic_sched_ready);\r\n}\r\n}\r\ntr_type = dwc2_hcd_select_transactions(hsotg);\r\nif (tr_type != DWC2_TRANSACTION_NONE)\r\ndwc2_hcd_queue_transactions(hsotg, tr_type);\r\n}\r\nstatic void dwc2_rx_fifo_level_intr(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 grxsts, chnum, bcnt, dpid, pktsts;\r\nstruct dwc2_host_chan *chan;\r\nif (dbg_perio())\r\ndev_vdbg(hsotg->dev, "--RxFIFO Level Interrupt--\n");\r\ngrxsts = dwc2_readl(hsotg->regs + GRXSTSP);\r\nchnum = (grxsts & GRXSTS_HCHNUM_MASK) >> GRXSTS_HCHNUM_SHIFT;\r\nchan = hsotg->hc_ptr_array[chnum];\r\nif (!chan) {\r\ndev_err(hsotg->dev, "Unable to get corresponding channel\n");\r\nreturn;\r\n}\r\nbcnt = (grxsts & GRXSTS_BYTECNT_MASK) >> GRXSTS_BYTECNT_SHIFT;\r\ndpid = (grxsts & GRXSTS_DPID_MASK) >> GRXSTS_DPID_SHIFT;\r\npktsts = (grxsts & GRXSTS_PKTSTS_MASK) >> GRXSTS_PKTSTS_SHIFT;\r\nif (dbg_perio()) {\r\ndev_vdbg(hsotg->dev, " Ch num = %d\n", chnum);\r\ndev_vdbg(hsotg->dev, " Count = %d\n", bcnt);\r\ndev_vdbg(hsotg->dev, " DPID = %d, chan.dpid = %d\n", dpid,\r\nchan->data_pid_start);\r\ndev_vdbg(hsotg->dev, " PStatus = %d\n", pktsts);\r\n}\r\nswitch (pktsts) {\r\ncase GRXSTS_PKTSTS_HCHIN:\r\nif (bcnt > 0) {\r\ndwc2_read_packet(hsotg, chan->xfer_buf, bcnt);\r\nchan->xfer_count += bcnt;\r\nchan->xfer_buf += bcnt;\r\n}\r\nbreak;\r\ncase GRXSTS_PKTSTS_HCHIN_XFER_COMP:\r\ncase GRXSTS_PKTSTS_DATATOGGLEERR:\r\ncase GRXSTS_PKTSTS_HCHHALTED:\r\nbreak;\r\ndefault:\r\ndev_err(hsotg->dev,\r\n"RxFIFO Level Interrupt: Unknown status %d\n", pktsts);\r\nbreak;\r\n}\r\n}\r\nstatic void dwc2_np_tx_fifo_empty_intr(struct dwc2_hsotg *hsotg)\r\n{\r\ndev_vdbg(hsotg->dev, "--Non-Periodic TxFIFO Empty Interrupt--\n");\r\ndwc2_hcd_queue_transactions(hsotg, DWC2_TRANSACTION_NON_PERIODIC);\r\n}\r\nstatic void dwc2_perio_tx_fifo_empty_intr(struct dwc2_hsotg *hsotg)\r\n{\r\nif (dbg_perio())\r\ndev_vdbg(hsotg->dev, "--Periodic TxFIFO Empty Interrupt--\n");\r\ndwc2_hcd_queue_transactions(hsotg, DWC2_TRANSACTION_PERIODIC);\r\n}\r\nstatic void dwc2_hprt0_enable(struct dwc2_hsotg *hsotg, u32 hprt0,\r\nu32 *hprt0_modify)\r\n{\r\nstruct dwc2_core_params *params = hsotg->core_params;\r\nint do_reset = 0;\r\nu32 usbcfg;\r\nu32 prtspd;\r\nu32 hcfg;\r\nu32 fslspclksel;\r\nu32 hfir;\r\ndev_vdbg(hsotg->dev, "%s(%p)\n", __func__, hsotg);\r\nhfir = dwc2_readl(hsotg->regs + HFIR);\r\nhfir &= ~HFIR_FRINT_MASK;\r\nhfir |= dwc2_calc_frame_interval(hsotg) << HFIR_FRINT_SHIFT &\r\nHFIR_FRINT_MASK;\r\ndwc2_writel(hfir, hsotg->regs + HFIR);\r\nif (!params->host_support_fs_ls_low_power) {\r\nhsotg->flags.b.port_reset_change = 1;\r\nreturn;\r\n}\r\nusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);\r\nprtspd = (hprt0 & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;\r\nif (prtspd == HPRT0_SPD_LOW_SPEED || prtspd == HPRT0_SPD_FULL_SPEED) {\r\nif (!(usbcfg & GUSBCFG_PHY_LP_CLK_SEL)) {\r\nusbcfg |= GUSBCFG_PHY_LP_CLK_SEL;\r\ndwc2_writel(usbcfg, hsotg->regs + GUSBCFG);\r\ndo_reset = 1;\r\n}\r\nhcfg = dwc2_readl(hsotg->regs + HCFG);\r\nfslspclksel = (hcfg & HCFG_FSLSPCLKSEL_MASK) >>\r\nHCFG_FSLSPCLKSEL_SHIFT;\r\nif (prtspd == HPRT0_SPD_LOW_SPEED &&\r\nparams->host_ls_low_power_phy_clk ==\r\nDWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ) {\r\ndev_vdbg(hsotg->dev,\r\n"FS_PHY programming HCFG to 6 MHz\n");\r\nif (fslspclksel != HCFG_FSLSPCLKSEL_6_MHZ) {\r\nfslspclksel = HCFG_FSLSPCLKSEL_6_MHZ;\r\nhcfg &= ~HCFG_FSLSPCLKSEL_MASK;\r\nhcfg |= fslspclksel << HCFG_FSLSPCLKSEL_SHIFT;\r\ndwc2_writel(hcfg, hsotg->regs + HCFG);\r\ndo_reset = 1;\r\n}\r\n} else {\r\ndev_vdbg(hsotg->dev,\r\n"FS_PHY programming HCFG to 48 MHz\n");\r\nif (fslspclksel != HCFG_FSLSPCLKSEL_48_MHZ) {\r\nfslspclksel = HCFG_FSLSPCLKSEL_48_MHZ;\r\nhcfg &= ~HCFG_FSLSPCLKSEL_MASK;\r\nhcfg |= fslspclksel << HCFG_FSLSPCLKSEL_SHIFT;\r\ndwc2_writel(hcfg, hsotg->regs + HCFG);\r\ndo_reset = 1;\r\n}\r\n}\r\n} else {\r\nif (usbcfg & GUSBCFG_PHY_LP_CLK_SEL) {\r\nusbcfg &= ~GUSBCFG_PHY_LP_CLK_SEL;\r\ndwc2_writel(usbcfg, hsotg->regs + GUSBCFG);\r\ndo_reset = 1;\r\n}\r\n}\r\nif (do_reset) {\r\n*hprt0_modify |= HPRT0_RST;\r\ndwc2_writel(*hprt0_modify, hsotg->regs + HPRT0);\r\nqueue_delayed_work(hsotg->wq_otg, &hsotg->reset_work,\r\nmsecs_to_jiffies(60));\r\n} else {\r\nhsotg->flags.b.port_reset_change = 1;\r\n}\r\n}\r\nstatic void dwc2_port_intr(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 hprt0;\r\nu32 hprt0_modify;\r\ndev_vdbg(hsotg->dev, "--Port Interrupt--\n");\r\nhprt0 = dwc2_readl(hsotg->regs + HPRT0);\r\nhprt0_modify = hprt0;\r\nhprt0_modify &= ~(HPRT0_ENA | HPRT0_CONNDET | HPRT0_ENACHG |\r\nHPRT0_OVRCURRCHG);\r\nif (hprt0 & HPRT0_CONNDET) {\r\ndwc2_writel(hprt0_modify | HPRT0_CONNDET, hsotg->regs + HPRT0);\r\ndev_vdbg(hsotg->dev,\r\n"--Port Interrupt HPRT0=0x%08x Port Connect Detected--\n",\r\nhprt0);\r\ndwc2_hcd_connect(hsotg);\r\n}\r\nif (hprt0 & HPRT0_ENACHG) {\r\ndwc2_writel(hprt0_modify | HPRT0_ENACHG, hsotg->regs + HPRT0);\r\ndev_vdbg(hsotg->dev,\r\n" --Port Interrupt HPRT0=0x%08x Port Enable Changed (now %d)--\n",\r\nhprt0, !!(hprt0 & HPRT0_ENA));\r\nif (hprt0 & HPRT0_ENA) {\r\nhsotg->new_connection = true;\r\ndwc2_hprt0_enable(hsotg, hprt0, &hprt0_modify);\r\n} else {\r\nhsotg->flags.b.port_enable_change = 1;\r\nif (hsotg->core_params->dma_desc_fs_enable) {\r\nu32 hcfg;\r\nhsotg->core_params->dma_desc_enable = 0;\r\nhsotg->new_connection = false;\r\nhcfg = dwc2_readl(hsotg->regs + HCFG);\r\nhcfg &= ~HCFG_DESCDMA;\r\ndwc2_writel(hcfg, hsotg->regs + HCFG);\r\n}\r\n}\r\n}\r\nif (hprt0 & HPRT0_OVRCURRCHG) {\r\ndwc2_writel(hprt0_modify | HPRT0_OVRCURRCHG,\r\nhsotg->regs + HPRT0);\r\ndev_vdbg(hsotg->dev,\r\n" --Port Interrupt HPRT0=0x%08x Port Overcurrent Changed--\n",\r\nhprt0);\r\nhsotg->flags.b.port_over_current_change = 1;\r\n}\r\n}\r\nstatic u32 dwc2_get_actual_xfer_length(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd,\r\nenum dwc2_halt_status halt_status,\r\nint *short_read)\r\n{\r\nu32 hctsiz, count, length;\r\nhctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));\r\nif (halt_status == DWC2_HC_XFER_COMPLETE) {\r\nif (chan->ep_is_in) {\r\ncount = (hctsiz & TSIZ_XFERSIZE_MASK) >>\r\nTSIZ_XFERSIZE_SHIFT;\r\nlength = chan->xfer_len - count;\r\nif (short_read != NULL)\r\n*short_read = (count != 0);\r\n} else if (chan->qh->do_split) {\r\nlength = qtd->ssplit_out_xfer_count;\r\n} else {\r\nlength = chan->xfer_len;\r\n}\r\n} else {\r\ncount = (hctsiz & TSIZ_PKTCNT_MASK) >> TSIZ_PKTCNT_SHIFT;\r\nlength = (chan->start_pkt_count - count) * chan->max_packet;\r\n}\r\nreturn length;\r\n}\r\nstatic int dwc2_update_urb_state(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_hcd_urb *urb,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nu32 hctsiz;\r\nint xfer_done = 0;\r\nint short_read = 0;\r\nint xfer_length = dwc2_get_actual_xfer_length(hsotg, chan, chnum, qtd,\r\nDWC2_HC_XFER_COMPLETE,\r\n&short_read);\r\nif (urb->actual_length + xfer_length > urb->length) {\r\ndev_warn(hsotg->dev, "%s(): trimming xfer length\n", __func__);\r\nxfer_length = urb->length - urb->actual_length;\r\n}\r\ndev_vdbg(hsotg->dev, "urb->actual_length=%d xfer_length=%d\n",\r\nurb->actual_length, xfer_length);\r\nurb->actual_length += xfer_length;\r\nif (xfer_length && chan->ep_type == USB_ENDPOINT_XFER_BULK &&\r\n(urb->flags & URB_SEND_ZERO_PACKET) &&\r\nurb->actual_length >= urb->length &&\r\n!(urb->length % chan->max_packet)) {\r\nxfer_done = 0;\r\n} else if (short_read || urb->actual_length >= urb->length) {\r\nxfer_done = 1;\r\nurb->status = 0;\r\n}\r\nhctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));\r\ndev_vdbg(hsotg->dev, "DWC_otg: %s: %s, channel %d\n",\r\n__func__, (chan->ep_is_in ? "IN" : "OUT"), chnum);\r\ndev_vdbg(hsotg->dev, " chan->xfer_len %d\n", chan->xfer_len);\r\ndev_vdbg(hsotg->dev, " hctsiz.xfersize %d\n",\r\n(hctsiz & TSIZ_XFERSIZE_MASK) >> TSIZ_XFERSIZE_SHIFT);\r\ndev_vdbg(hsotg->dev, " urb->transfer_buffer_length %d\n", urb->length);\r\ndev_vdbg(hsotg->dev, " urb->actual_length %d\n", urb->actual_length);\r\ndev_vdbg(hsotg->dev, " short_read %d, xfer_done %d\n", short_read,\r\nxfer_done);\r\nreturn xfer_done;\r\n}\r\nvoid dwc2_hcd_save_data_toggle(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nu32 hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));\r\nu32 pid = (hctsiz & TSIZ_SC_MC_PID_MASK) >> TSIZ_SC_MC_PID_SHIFT;\r\nif (chan->ep_type != USB_ENDPOINT_XFER_CONTROL) {\r\nif (WARN(!chan || !chan->qh,\r\n"chan->qh must be specified for non-control eps\n"))\r\nreturn;\r\nif (pid == TSIZ_SC_MC_PID_DATA0)\r\nchan->qh->data_toggle = DWC2_HC_PID_DATA0;\r\nelse\r\nchan->qh->data_toggle = DWC2_HC_PID_DATA1;\r\n} else {\r\nif (WARN(!qtd,\r\n"qtd must be specified for control eps\n"))\r\nreturn;\r\nif (pid == TSIZ_SC_MC_PID_DATA0)\r\nqtd->data_toggle = DWC2_HC_PID_DATA0;\r\nelse\r\nqtd->data_toggle = DWC2_HC_PID_DATA1;\r\n}\r\n}\r\nstatic enum dwc2_halt_status dwc2_update_isoc_urb_state(\r\nstruct dwc2_hsotg *hsotg, struct dwc2_host_chan *chan,\r\nint chnum, struct dwc2_qtd *qtd,\r\nenum dwc2_halt_status halt_status)\r\n{\r\nstruct dwc2_hcd_iso_packet_desc *frame_desc;\r\nstruct dwc2_hcd_urb *urb = qtd->urb;\r\nif (!urb)\r\nreturn DWC2_HC_XFER_NO_HALT_STATUS;\r\nframe_desc = &urb->iso_descs[qtd->isoc_frame_index];\r\nswitch (halt_status) {\r\ncase DWC2_HC_XFER_COMPLETE:\r\nframe_desc->status = 0;\r\nframe_desc->actual_length = dwc2_get_actual_xfer_length(hsotg,\r\nchan, chnum, qtd, halt_status, NULL);\r\nbreak;\r\ncase DWC2_HC_XFER_FRAME_OVERRUN:\r\nurb->error_count++;\r\nif (chan->ep_is_in)\r\nframe_desc->status = -ENOSR;\r\nelse\r\nframe_desc->status = -ECOMM;\r\nframe_desc->actual_length = 0;\r\nbreak;\r\ncase DWC2_HC_XFER_BABBLE_ERR:\r\nurb->error_count++;\r\nframe_desc->status = -EOVERFLOW;\r\nbreak;\r\ncase DWC2_HC_XFER_XACT_ERR:\r\nurb->error_count++;\r\nframe_desc->status = -EPROTO;\r\nframe_desc->actual_length = dwc2_get_actual_xfer_length(hsotg,\r\nchan, chnum, qtd, halt_status, NULL);\r\nif (chan->qh->do_split &&\r\nchan->ep_type == USB_ENDPOINT_XFER_ISOC && chan->ep_is_in &&\r\nhsotg->core_params->dma_enable > 0) {\r\nqtd->complete_split = 0;\r\nqtd->isoc_split_offset = 0;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(hsotg->dev, "Unhandled halt_status (%d)\n",\r\nhalt_status);\r\nbreak;\r\n}\r\nif (++qtd->isoc_frame_index == urb->packet_count) {\r\ndwc2_host_complete(hsotg, qtd, 0);\r\nhalt_status = DWC2_HC_XFER_URB_COMPLETE;\r\n} else {\r\nhalt_status = DWC2_HC_XFER_COMPLETE;\r\n}\r\nreturn halt_status;\r\n}\r\nstatic void dwc2_deactivate_qh(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\r\nint free_qtd)\r\n{\r\nint continue_split = 0;\r\nstruct dwc2_qtd *qtd;\r\nif (dbg_qh(qh))\r\ndev_vdbg(hsotg->dev, " %s(%p,%p,%d)\n", __func__,\r\nhsotg, qh, free_qtd);\r\nif (list_empty(&qh->qtd_list)) {\r\ndev_dbg(hsotg->dev, "## QTD list empty ##\n");\r\ngoto no_qtd;\r\n}\r\nqtd = list_first_entry(&qh->qtd_list, struct dwc2_qtd, qtd_list_entry);\r\nif (qtd->complete_split)\r\ncontinue_split = 1;\r\nelse if (qtd->isoc_split_pos == DWC2_HCSPLT_XACTPOS_MID ||\r\nqtd->isoc_split_pos == DWC2_HCSPLT_XACTPOS_END)\r\ncontinue_split = 1;\r\nif (free_qtd) {\r\ndwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);\r\ncontinue_split = 0;\r\n}\r\nno_qtd:\r\nqh->channel = NULL;\r\ndwc2_hcd_qh_deactivate(hsotg, qh, continue_split);\r\n}\r\nstatic void dwc2_release_channel(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan,\r\nstruct dwc2_qtd *qtd,\r\nenum dwc2_halt_status halt_status)\r\n{\r\nenum dwc2_transaction_type tr_type;\r\nu32 haintmsk;\r\nint free_qtd = 0;\r\nif (dbg_hc(chan))\r\ndev_vdbg(hsotg->dev, " %s: channel %d, halt_status %d\n",\r\n__func__, chan->hc_num, halt_status);\r\nswitch (halt_status) {\r\ncase DWC2_HC_XFER_URB_COMPLETE:\r\nfree_qtd = 1;\r\nbreak;\r\ncase DWC2_HC_XFER_AHB_ERR:\r\ncase DWC2_HC_XFER_STALL:\r\ncase DWC2_HC_XFER_BABBLE_ERR:\r\nfree_qtd = 1;\r\nbreak;\r\ncase DWC2_HC_XFER_XACT_ERR:\r\nif (qtd && qtd->error_count >= 3) {\r\ndev_vdbg(hsotg->dev,\r\n" Complete URB with transaction error\n");\r\nfree_qtd = 1;\r\ndwc2_host_complete(hsotg, qtd, -EPROTO);\r\n}\r\nbreak;\r\ncase DWC2_HC_XFER_URB_DEQUEUE:\r\ngoto cleanup;\r\ncase DWC2_HC_XFER_PERIODIC_INCOMPLETE:\r\ndev_vdbg(hsotg->dev, " Complete URB with I/O error\n");\r\nfree_qtd = 1;\r\ndwc2_host_complete(hsotg, qtd, -EIO);\r\nbreak;\r\ncase DWC2_HC_XFER_NO_HALT_STATUS:\r\ndefault:\r\nbreak;\r\n}\r\ndwc2_deactivate_qh(hsotg, chan->qh, free_qtd);\r\ncleanup:\r\nif (!list_empty(&chan->hc_list_entry))\r\nlist_del(&chan->hc_list_entry);\r\ndwc2_hc_cleanup(hsotg, chan);\r\nlist_add_tail(&chan->hc_list_entry, &hsotg->free_hc_list);\r\nif (hsotg->core_params->uframe_sched > 0) {\r\nhsotg->available_host_channels++;\r\n} else {\r\nswitch (chan->ep_type) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ncase USB_ENDPOINT_XFER_BULK:\r\nhsotg->non_periodic_channels--;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nhaintmsk = dwc2_readl(hsotg->regs + HAINTMSK);\r\nhaintmsk &= ~(1 << chan->hc_num);\r\ndwc2_writel(haintmsk, hsotg->regs + HAINTMSK);\r\ntr_type = dwc2_hcd_select_transactions(hsotg);\r\nif (tr_type != DWC2_TRANSACTION_NONE)\r\ndwc2_hcd_queue_transactions(hsotg, tr_type);\r\n}\r\nstatic void dwc2_halt_channel(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, struct dwc2_qtd *qtd,\r\nenum dwc2_halt_status halt_status)\r\n{\r\nif (dbg_hc(chan))\r\ndev_vdbg(hsotg->dev, "%s()\n", __func__);\r\nif (hsotg->core_params->dma_enable > 0) {\r\nif (dbg_hc(chan))\r\ndev_vdbg(hsotg->dev, "DMA enabled\n");\r\ndwc2_release_channel(hsotg, chan, qtd, halt_status);\r\nreturn;\r\n}\r\ndwc2_hc_halt(hsotg, chan, halt_status);\r\nif (chan->halt_on_queue) {\r\nu32 gintmsk;\r\ndev_vdbg(hsotg->dev, "Halt on queue\n");\r\nif (chan->ep_type == USB_ENDPOINT_XFER_CONTROL ||\r\nchan->ep_type == USB_ENDPOINT_XFER_BULK) {\r\ndev_vdbg(hsotg->dev, "control/bulk\n");\r\ngintmsk = dwc2_readl(hsotg->regs + GINTMSK);\r\ngintmsk |= GINTSTS_NPTXFEMP;\r\ndwc2_writel(gintmsk, hsotg->regs + GINTMSK);\r\n} else {\r\ndev_vdbg(hsotg->dev, "isoc/intr\n");\r\nlist_move_tail(&chan->qh->qh_list_entry,\r\n&hsotg->periodic_sched_assigned);\r\ngintmsk = dwc2_readl(hsotg->regs + GINTMSK);\r\ngintmsk |= GINTSTS_PTXFEMP;\r\ndwc2_writel(gintmsk, hsotg->regs + GINTMSK);\r\n}\r\n}\r\n}\r\nstatic void dwc2_complete_non_periodic_xfer(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan,\r\nint chnum, struct dwc2_qtd *qtd,\r\nenum dwc2_halt_status halt_status)\r\n{\r\ndev_vdbg(hsotg->dev, "%s()\n", __func__);\r\nqtd->error_count = 0;\r\nif (chan->hcint & HCINTMSK_NYET) {\r\ndev_vdbg(hsotg->dev, "got NYET\n");\r\nchan->qh->ping_state = 1;\r\n}\r\nif (chan->ep_is_in) {\r\ndwc2_halt_channel(hsotg, chan, qtd, halt_status);\r\n} else {\r\ndwc2_release_channel(hsotg, chan, qtd, halt_status);\r\n}\r\n}\r\nstatic void dwc2_complete_periodic_xfer(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd,\r\nenum dwc2_halt_status halt_status)\r\n{\r\nu32 hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));\r\nqtd->error_count = 0;\r\nif (!chan->ep_is_in || (hctsiz & TSIZ_PKTCNT_MASK) == 0)\r\ndwc2_release_channel(hsotg, chan, qtd, halt_status);\r\nelse\r\ndwc2_halt_channel(hsotg, chan, qtd, halt_status);\r\n}\r\nstatic int dwc2_xfercomp_isoc_split_in(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nstruct dwc2_hcd_iso_packet_desc *frame_desc;\r\nu32 len;\r\nif (!qtd->urb)\r\nreturn 0;\r\nframe_desc = &qtd->urb->iso_descs[qtd->isoc_frame_index];\r\nlen = dwc2_get_actual_xfer_length(hsotg, chan, chnum, qtd,\r\nDWC2_HC_XFER_COMPLETE, NULL);\r\nif (!len) {\r\nqtd->complete_split = 0;\r\nqtd->isoc_split_offset = 0;\r\nreturn 0;\r\n}\r\nframe_desc->actual_length += len;\r\nqtd->isoc_split_offset += len;\r\nif (frame_desc->actual_length >= frame_desc->length) {\r\nframe_desc->status = 0;\r\nqtd->isoc_frame_index++;\r\nqtd->complete_split = 0;\r\nqtd->isoc_split_offset = 0;\r\n}\r\nif (qtd->isoc_frame_index == qtd->urb->packet_count) {\r\ndwc2_host_complete(hsotg, qtd, 0);\r\ndwc2_release_channel(hsotg, chan, qtd,\r\nDWC2_HC_XFER_URB_COMPLETE);\r\n} else {\r\ndwc2_release_channel(hsotg, chan, qtd,\r\nDWC2_HC_XFER_NO_HALT_STATUS);\r\n}\r\nreturn 1;\r\n}\r\nstatic void dwc2_hc_xfercomp_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nstruct dwc2_hcd_urb *urb = qtd->urb;\r\nenum dwc2_halt_status halt_status = DWC2_HC_XFER_COMPLETE;\r\nint pipe_type;\r\nint urb_xfer_done;\r\nif (dbg_hc(chan))\r\ndev_vdbg(hsotg->dev,\r\n"--Host Channel %d Interrupt: Transfer Complete--\n",\r\nchnum);\r\nif (!urb)\r\ngoto handle_xfercomp_done;\r\npipe_type = dwc2_hcd_get_pipe_type(&urb->pipe_info);\r\nif (hsotg->core_params->dma_desc_enable > 0) {\r\ndwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum, halt_status);\r\nif (pipe_type == USB_ENDPOINT_XFER_ISOC)\r\nreturn;\r\ngoto handle_xfercomp_done;\r\n}\r\nif (chan->qh->do_split) {\r\nif (chan->ep_type == USB_ENDPOINT_XFER_ISOC && chan->ep_is_in &&\r\nhsotg->core_params->dma_enable > 0) {\r\nif (qtd->complete_split &&\r\ndwc2_xfercomp_isoc_split_in(hsotg, chan, chnum,\r\nqtd))\r\ngoto handle_xfercomp_done;\r\n} else {\r\nqtd->complete_split = 0;\r\n}\r\n}\r\nswitch (pipe_type) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nswitch (qtd->control_phase) {\r\ncase DWC2_CONTROL_SETUP:\r\nif (urb->length > 0)\r\nqtd->control_phase = DWC2_CONTROL_DATA;\r\nelse\r\nqtd->control_phase = DWC2_CONTROL_STATUS;\r\ndev_vdbg(hsotg->dev,\r\n" Control setup transaction done\n");\r\nhalt_status = DWC2_HC_XFER_COMPLETE;\r\nbreak;\r\ncase DWC2_CONTROL_DATA:\r\nurb_xfer_done = dwc2_update_urb_state(hsotg, chan,\r\nchnum, urb, qtd);\r\nif (urb_xfer_done) {\r\nqtd->control_phase = DWC2_CONTROL_STATUS;\r\ndev_vdbg(hsotg->dev,\r\n" Control data transfer done\n");\r\n} else {\r\ndwc2_hcd_save_data_toggle(hsotg, chan, chnum,\r\nqtd);\r\n}\r\nhalt_status = DWC2_HC_XFER_COMPLETE;\r\nbreak;\r\ncase DWC2_CONTROL_STATUS:\r\ndev_vdbg(hsotg->dev, " Control transfer complete\n");\r\nif (urb->status == -EINPROGRESS)\r\nurb->status = 0;\r\ndwc2_host_complete(hsotg, qtd, urb->status);\r\nhalt_status = DWC2_HC_XFER_URB_COMPLETE;\r\nbreak;\r\n}\r\ndwc2_complete_non_periodic_xfer(hsotg, chan, chnum, qtd,\r\nhalt_status);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\ndev_vdbg(hsotg->dev, " Bulk transfer complete\n");\r\nurb_xfer_done = dwc2_update_urb_state(hsotg, chan, chnum, urb,\r\nqtd);\r\nif (urb_xfer_done) {\r\ndwc2_host_complete(hsotg, qtd, urb->status);\r\nhalt_status = DWC2_HC_XFER_URB_COMPLETE;\r\n} else {\r\nhalt_status = DWC2_HC_XFER_COMPLETE;\r\n}\r\ndwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\r\ndwc2_complete_non_periodic_xfer(hsotg, chan, chnum, qtd,\r\nhalt_status);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\ndev_vdbg(hsotg->dev, " Interrupt transfer complete\n");\r\nurb_xfer_done = dwc2_update_urb_state(hsotg, chan, chnum, urb,\r\nqtd);\r\nif (urb_xfer_done) {\r\ndwc2_host_complete(hsotg, qtd, urb->status);\r\nhalt_status = DWC2_HC_XFER_URB_COMPLETE;\r\n} else {\r\nhalt_status = DWC2_HC_XFER_COMPLETE;\r\n}\r\ndwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\r\ndwc2_complete_periodic_xfer(hsotg, chan, chnum, qtd,\r\nhalt_status);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (dbg_perio())\r\ndev_vdbg(hsotg->dev, " Isochronous transfer complete\n");\r\nif (qtd->isoc_split_pos == DWC2_HCSPLT_XACTPOS_ALL)\r\nhalt_status = dwc2_update_isoc_urb_state(hsotg, chan,\r\nchnum, qtd, DWC2_HC_XFER_COMPLETE);\r\ndwc2_complete_periodic_xfer(hsotg, chan, chnum, qtd,\r\nhalt_status);\r\nbreak;\r\n}\r\nhandle_xfercomp_done:\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_XFERCOMPL);\r\n}\r\nstatic void dwc2_hc_stall_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nstruct dwc2_hcd_urb *urb = qtd->urb;\r\nint pipe_type;\r\ndev_dbg(hsotg->dev, "--Host Channel %d Interrupt: STALL Received--\n",\r\nchnum);\r\nif (hsotg->core_params->dma_desc_enable > 0) {\r\ndwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\r\nDWC2_HC_XFER_STALL);\r\ngoto handle_stall_done;\r\n}\r\nif (!urb)\r\ngoto handle_stall_halt;\r\npipe_type = dwc2_hcd_get_pipe_type(&urb->pipe_info);\r\nif (pipe_type == USB_ENDPOINT_XFER_CONTROL)\r\ndwc2_host_complete(hsotg, qtd, -EPIPE);\r\nif (pipe_type == USB_ENDPOINT_XFER_BULK ||\r\npipe_type == USB_ENDPOINT_XFER_INT) {\r\ndwc2_host_complete(hsotg, qtd, -EPIPE);\r\nchan->qh->data_toggle = 0;\r\n}\r\nhandle_stall_halt:\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_STALL);\r\nhandle_stall_done:\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_STALL);\r\n}\r\nstatic void dwc2_update_urb_state_abn(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_hcd_urb *urb,\r\nstruct dwc2_qtd *qtd,\r\nenum dwc2_halt_status halt_status)\r\n{\r\nu32 xfer_length = dwc2_get_actual_xfer_length(hsotg, chan, chnum,\r\nqtd, halt_status, NULL);\r\nu32 hctsiz;\r\nif (urb->actual_length + xfer_length > urb->length) {\r\ndev_warn(hsotg->dev, "%s(): trimming xfer length\n", __func__);\r\nxfer_length = urb->length - urb->actual_length;\r\n}\r\nurb->actual_length += xfer_length;\r\nhctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));\r\ndev_vdbg(hsotg->dev, "DWC_otg: %s: %s, channel %d\n",\r\n__func__, (chan->ep_is_in ? "IN" : "OUT"), chnum);\r\ndev_vdbg(hsotg->dev, " chan->start_pkt_count %d\n",\r\nchan->start_pkt_count);\r\ndev_vdbg(hsotg->dev, " hctsiz.pktcnt %d\n",\r\n(hctsiz & TSIZ_PKTCNT_MASK) >> TSIZ_PKTCNT_SHIFT);\r\ndev_vdbg(hsotg->dev, " chan->max_packet %d\n", chan->max_packet);\r\ndev_vdbg(hsotg->dev, " bytes_transferred %d\n",\r\nxfer_length);\r\ndev_vdbg(hsotg->dev, " urb->actual_length %d\n",\r\nurb->actual_length);\r\ndev_vdbg(hsotg->dev, " urb->transfer_buffer_length %d\n",\r\nurb->length);\r\n}\r\nstatic void dwc2_hc_nak_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nif (!qtd) {\r\ndev_dbg(hsotg->dev, "%s: qtd is NULL\n", __func__);\r\nreturn;\r\n}\r\nif (!qtd->urb) {\r\ndev_dbg(hsotg->dev, "%s: qtd->urb is NULL\n", __func__);\r\nreturn;\r\n}\r\nif (dbg_hc(chan))\r\ndev_vdbg(hsotg->dev, "--Host Channel %d Interrupt: NAK Received--\n",\r\nchnum);\r\nif (chan->do_split) {\r\nif (chan->complete_split)\r\nqtd->error_count = 0;\r\nqtd->complete_split = 0;\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_NAK);\r\ngoto handle_nak_done;\r\n}\r\nswitch (dwc2_hcd_get_pipe_type(&qtd->urb->pipe_info)) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (hsotg->core_params->dma_enable > 0 && chan->ep_is_in) {\r\nqtd->error_count = 0;\r\nbreak;\r\n}\r\nqtd->error_count = 0;\r\nif (!chan->qh->ping_state) {\r\ndwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb,\r\nqtd, DWC2_HC_XFER_NAK);\r\ndwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\r\nif (chan->speed == USB_SPEED_HIGH)\r\nchan->qh->ping_state = 1;\r\n}\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_NAK);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nqtd->error_count = 0;\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_NAK);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ndev_err(hsotg->dev, "NACK interrupt for ISOC transfer\n");\r\nbreak;\r\n}\r\nhandle_nak_done:\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_NAK);\r\n}\r\nstatic void dwc2_hc_ack_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nstruct dwc2_hcd_iso_packet_desc *frame_desc;\r\nif (dbg_hc(chan))\r\ndev_vdbg(hsotg->dev, "--Host Channel %d Interrupt: ACK Received--\n",\r\nchnum);\r\nif (chan->do_split) {\r\nif (!chan->ep_is_in &&\r\nchan->data_pid_start != DWC2_HC_PID_SETUP)\r\nqtd->ssplit_out_xfer_count = chan->xfer_len;\r\nif (chan->ep_type != USB_ENDPOINT_XFER_ISOC || chan->ep_is_in) {\r\nqtd->complete_split = 1;\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_ACK);\r\n} else {\r\nswitch (chan->xact_pos) {\r\ncase DWC2_HCSPLT_XACTPOS_ALL:\r\nbreak;\r\ncase DWC2_HCSPLT_XACTPOS_END:\r\nqtd->isoc_split_pos = DWC2_HCSPLT_XACTPOS_ALL;\r\nqtd->isoc_split_offset = 0;\r\nbreak;\r\ncase DWC2_HCSPLT_XACTPOS_BEGIN:\r\ncase DWC2_HCSPLT_XACTPOS_MID:\r\nframe_desc = &qtd->urb->iso_descs[\r\nqtd->isoc_frame_index];\r\nqtd->isoc_split_offset += 188;\r\nif (frame_desc->length - qtd->isoc_split_offset\r\n<= 188)\r\nqtd->isoc_split_pos =\r\nDWC2_HCSPLT_XACTPOS_END;\r\nelse\r\nqtd->isoc_split_pos =\r\nDWC2_HCSPLT_XACTPOS_MID;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nqtd->error_count = 0;\r\nif (chan->qh->ping_state) {\r\nchan->qh->ping_state = 0;\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_ACK);\r\n}\r\n}\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_ACK);\r\n}\r\nstatic void dwc2_hc_nyet_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nif (dbg_hc(chan))\r\ndev_vdbg(hsotg->dev, "--Host Channel %d Interrupt: NYET Received--\n",\r\nchnum);\r\nif (chan->do_split && chan->complete_split) {\r\nif (chan->ep_is_in && chan->ep_type == USB_ENDPOINT_XFER_ISOC &&\r\nhsotg->core_params->dma_enable > 0) {\r\nqtd->complete_split = 0;\r\nqtd->isoc_split_offset = 0;\r\nqtd->isoc_frame_index++;\r\nif (qtd->urb &&\r\nqtd->isoc_frame_index == qtd->urb->packet_count) {\r\ndwc2_host_complete(hsotg, qtd, 0);\r\ndwc2_release_channel(hsotg, chan, qtd,\r\nDWC2_HC_XFER_URB_COMPLETE);\r\n} else {\r\ndwc2_release_channel(hsotg, chan, qtd,\r\nDWC2_HC_XFER_NO_HALT_STATUS);\r\n}\r\ngoto handle_nyet_done;\r\n}\r\nif (chan->ep_type == USB_ENDPOINT_XFER_INT ||\r\nchan->ep_type == USB_ENDPOINT_XFER_ISOC) {\r\nstruct dwc2_qh *qh = chan->qh;\r\nbool past_end;\r\nif (hsotg->core_params->uframe_sched <= 0) {\r\nint frnum = dwc2_hcd_get_frame_number(hsotg);\r\npast_end = dwc2_full_frame_num(frnum) !=\r\ndwc2_full_frame_num(qh->next_active_frame);\r\n} else {\r\nint end_frnum;\r\nend_frnum = dwc2_frame_num_inc(\r\nqh->start_active_frame,\r\nqh->num_hs_transfers);\r\nif (qh->ep_type != USB_ENDPOINT_XFER_ISOC ||\r\nqh->ep_is_in)\r\nend_frnum =\r\ndwc2_frame_num_inc(end_frnum, 1);\r\npast_end = dwc2_frame_num_le(\r\nend_frnum, qh->next_active_frame);\r\n}\r\nif (past_end) {\r\n#if 0\r\nqtd->error_count++;\r\n#endif\r\nqtd->complete_split = 0;\r\ndwc2_halt_channel(hsotg, chan, qtd,\r\nDWC2_HC_XFER_XACT_ERR);\r\ngoto handle_nyet_done;\r\n}\r\n}\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_NYET);\r\ngoto handle_nyet_done;\r\n}\r\nchan->qh->ping_state = 1;\r\nqtd->error_count = 0;\r\ndwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb, qtd,\r\nDWC2_HC_XFER_NYET);\r\ndwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_NYET);\r\nhandle_nyet_done:\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_NYET);\r\n}\r\nstatic void dwc2_hc_babble_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\ndev_dbg(hsotg->dev, "--Host Channel %d Interrupt: Babble Error--\n",\r\nchnum);\r\ndwc2_hc_handle_tt_clear(hsotg, chan, qtd);\r\nif (hsotg->core_params->dma_desc_enable > 0) {\r\ndwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\r\nDWC2_HC_XFER_BABBLE_ERR);\r\ngoto disable_int;\r\n}\r\nif (chan->ep_type != USB_ENDPOINT_XFER_ISOC) {\r\ndwc2_host_complete(hsotg, qtd, -EOVERFLOW);\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_BABBLE_ERR);\r\n} else {\r\nenum dwc2_halt_status halt_status;\r\nhalt_status = dwc2_update_isoc_urb_state(hsotg, chan, chnum,\r\nqtd, DWC2_HC_XFER_BABBLE_ERR);\r\ndwc2_halt_channel(hsotg, chan, qtd, halt_status);\r\n}\r\ndisable_int:\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_BBLERR);\r\n}\r\nstatic void dwc2_hc_ahberr_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nstruct dwc2_hcd_urb *urb = qtd->urb;\r\nchar *pipetype, *speed;\r\nu32 hcchar;\r\nu32 hcsplt;\r\nu32 hctsiz;\r\nu32 hc_dma;\r\ndev_dbg(hsotg->dev, "--Host Channel %d Interrupt: AHB Error--\n",\r\nchnum);\r\nif (!urb)\r\ngoto handle_ahberr_halt;\r\ndwc2_hc_handle_tt_clear(hsotg, chan, qtd);\r\nhcchar = dwc2_readl(hsotg->regs + HCCHAR(chnum));\r\nhcsplt = dwc2_readl(hsotg->regs + HCSPLT(chnum));\r\nhctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));\r\nhc_dma = dwc2_readl(hsotg->regs + HCDMA(chnum));\r\ndev_err(hsotg->dev, "AHB ERROR, Channel %d\n", chnum);\r\ndev_err(hsotg->dev, " hcchar 0x%08x, hcsplt 0x%08x\n", hcchar, hcsplt);\r\ndev_err(hsotg->dev, " hctsiz 0x%08x, hc_dma 0x%08x\n", hctsiz, hc_dma);\r\ndev_err(hsotg->dev, " Device address: %d\n",\r\ndwc2_hcd_get_dev_addr(&urb->pipe_info));\r\ndev_err(hsotg->dev, " Endpoint: %d, %s\n",\r\ndwc2_hcd_get_ep_num(&urb->pipe_info),\r\ndwc2_hcd_is_pipe_in(&urb->pipe_info) ? "IN" : "OUT");\r\nswitch (dwc2_hcd_get_pipe_type(&urb->pipe_info)) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\npipetype = "CONTROL";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\npipetype = "BULK";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\npipetype = "INTERRUPT";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\npipetype = "ISOCHRONOUS";\r\nbreak;\r\ndefault:\r\npipetype = "UNKNOWN";\r\nbreak;\r\n}\r\ndev_err(hsotg->dev, " Endpoint type: %s\n", pipetype);\r\nswitch (chan->speed) {\r\ncase USB_SPEED_HIGH:\r\nspeed = "HIGH";\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nspeed = "FULL";\r\nbreak;\r\ncase USB_SPEED_LOW:\r\nspeed = "LOW";\r\nbreak;\r\ndefault:\r\nspeed = "UNKNOWN";\r\nbreak;\r\n}\r\ndev_err(hsotg->dev, " Speed: %s\n", speed);\r\ndev_err(hsotg->dev, " Max packet size: %d\n",\r\ndwc2_hcd_get_mps(&urb->pipe_info));\r\ndev_err(hsotg->dev, " Data buffer length: %d\n", urb->length);\r\ndev_err(hsotg->dev, " Transfer buffer: %p, Transfer DMA: %08lx\n",\r\nurb->buf, (unsigned long)urb->dma);\r\ndev_err(hsotg->dev, " Setup buffer: %p, Setup DMA: %08lx\n",\r\nurb->setup_packet, (unsigned long)urb->setup_dma);\r\ndev_err(hsotg->dev, " Interval: %d\n", urb->interval);\r\nif (hsotg->core_params->dma_desc_enable > 0) {\r\ndwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\r\nDWC2_HC_XFER_AHB_ERR);\r\ngoto handle_ahberr_done;\r\n}\r\ndwc2_host_complete(hsotg, qtd, -EIO);\r\nhandle_ahberr_halt:\r\ndwc2_hc_halt(hsotg, chan, DWC2_HC_XFER_AHB_ERR);\r\nhandle_ahberr_done:\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_AHBERR);\r\n}\r\nstatic void dwc2_hc_xacterr_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\ndev_dbg(hsotg->dev,\r\n"--Host Channel %d Interrupt: Transaction Error--\n", chnum);\r\ndwc2_hc_handle_tt_clear(hsotg, chan, qtd);\r\nif (hsotg->core_params->dma_desc_enable > 0) {\r\ndwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\r\nDWC2_HC_XFER_XACT_ERR);\r\ngoto handle_xacterr_done;\r\n}\r\nswitch (dwc2_hcd_get_pipe_type(&qtd->urb->pipe_info)) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ncase USB_ENDPOINT_XFER_BULK:\r\nqtd->error_count++;\r\nif (!chan->qh->ping_state) {\r\ndwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb,\r\nqtd, DWC2_HC_XFER_XACT_ERR);\r\ndwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\r\nif (!chan->ep_is_in && chan->speed == USB_SPEED_HIGH)\r\nchan->qh->ping_state = 1;\r\n}\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_XACT_ERR);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nqtd->error_count++;\r\nif (chan->do_split && chan->complete_split)\r\nqtd->complete_split = 0;\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_XACT_ERR);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\n{\r\nenum dwc2_halt_status halt_status;\r\nhalt_status = dwc2_update_isoc_urb_state(hsotg, chan,\r\nchnum, qtd, DWC2_HC_XFER_XACT_ERR);\r\ndwc2_halt_channel(hsotg, chan, qtd, halt_status);\r\n}\r\nbreak;\r\n}\r\nhandle_xacterr_done:\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_XACTERR);\r\n}\r\nstatic void dwc2_hc_frmovrun_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nenum dwc2_halt_status halt_status;\r\nif (dbg_hc(chan))\r\ndev_dbg(hsotg->dev, "--Host Channel %d Interrupt: Frame Overrun--\n",\r\nchnum);\r\ndwc2_hc_handle_tt_clear(hsotg, chan, qtd);\r\nswitch (dwc2_hcd_get_pipe_type(&qtd->urb->pipe_info)) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ncase USB_ENDPOINT_XFER_BULK:\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_FRAME_OVERRUN);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nhalt_status = dwc2_update_isoc_urb_state(hsotg, chan, chnum,\r\nqtd, DWC2_HC_XFER_FRAME_OVERRUN);\r\ndwc2_halt_channel(hsotg, chan, qtd, halt_status);\r\nbreak;\r\n}\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_FRMOVRUN);\r\n}\r\nstatic void dwc2_hc_datatglerr_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\ndev_dbg(hsotg->dev,\r\n"--Host Channel %d Interrupt: Data Toggle Error--\n", chnum);\r\nif (chan->ep_is_in)\r\nqtd->error_count = 0;\r\nelse\r\ndev_err(hsotg->dev,\r\n"Data Toggle Error on OUT transfer, channel %d\n",\r\nchnum);\r\ndwc2_hc_handle_tt_clear(hsotg, chan, qtd);\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_DATATGLERR);\r\n}\r\nstatic bool dwc2_halt_status_ok(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\n#ifdef DEBUG\r\nu32 hcchar;\r\nu32 hctsiz;\r\nu32 hcintmsk;\r\nu32 hcsplt;\r\nif (chan->halt_status == DWC2_HC_XFER_NO_HALT_STATUS) {\r\nhcchar = dwc2_readl(hsotg->regs + HCCHAR(chnum));\r\nhctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));\r\nhcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(chnum));\r\nhcsplt = dwc2_readl(hsotg->regs + HCSPLT(chnum));\r\ndev_dbg(hsotg->dev,\r\n"%s: chan->halt_status DWC2_HC_XFER_NO_HALT_STATUS,\n",\r\n__func__);\r\ndev_dbg(hsotg->dev,\r\n"channel %d, hcchar 0x%08x, hctsiz 0x%08x,\n",\r\nchnum, hcchar, hctsiz);\r\ndev_dbg(hsotg->dev,\r\n"hcint 0x%08x, hcintmsk 0x%08x, hcsplt 0x%08x,\n",\r\nchan->hcint, hcintmsk, hcsplt);\r\nif (qtd)\r\ndev_dbg(hsotg->dev, "qtd->complete_split %d\n",\r\nqtd->complete_split);\r\ndev_warn(hsotg->dev,\r\n"%s: no halt status, channel %d, ignoring interrupt\n",\r\n__func__, chnum);\r\nreturn false;\r\n}\r\nhcchar = dwc2_readl(hsotg->regs + HCCHAR(chnum));\r\nif (hcchar & HCCHAR_CHDIS) {\r\ndev_warn(hsotg->dev,\r\n"%s: hcchar.chdis set unexpectedly, hcchar 0x%08x, trying to halt again\n",\r\n__func__, hcchar);\r\nchan->halt_pending = 0;\r\ndwc2_halt_channel(hsotg, chan, qtd, chan->halt_status);\r\nreturn false;\r\n}\r\n#endif\r\nreturn true;\r\n}\r\nstatic void dwc2_hc_chhltd_intr_dma(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nu32 hcintmsk;\r\nint out_nak_enh = 0;\r\nif (dbg_hc(chan))\r\ndev_vdbg(hsotg->dev,\r\n"--Host Channel %d Interrupt: DMA Channel Halted--\n",\r\nchnum);\r\nif (hsotg->hw_params.snpsid >= DWC2_CORE_REV_2_71a) {\r\nif (chan->speed == USB_SPEED_HIGH && !chan->ep_is_in &&\r\n(chan->ep_type == USB_ENDPOINT_XFER_CONTROL ||\r\nchan->ep_type == USB_ENDPOINT_XFER_BULK)) {\r\nout_nak_enh = 1;\r\n}\r\n}\r\nif (chan->halt_status == DWC2_HC_XFER_URB_DEQUEUE ||\r\n(chan->halt_status == DWC2_HC_XFER_AHB_ERR &&\r\nhsotg->core_params->dma_desc_enable <= 0)) {\r\nif (hsotg->core_params->dma_desc_enable > 0)\r\ndwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\r\nchan->halt_status);\r\nelse\r\ndwc2_release_channel(hsotg, chan, qtd,\r\nchan->halt_status);\r\nreturn;\r\n}\r\nhcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(chnum));\r\nif (chan->hcint & HCINTMSK_XFERCOMPL) {\r\nif (chan->ep_type == USB_ENDPOINT_XFER_ISOC && !chan->ep_is_in)\r\ndwc2_hc_ack_intr(hsotg, chan, chnum, qtd);\r\ndwc2_hc_xfercomp_intr(hsotg, chan, chnum, qtd);\r\n} else if (chan->hcint & HCINTMSK_STALL) {\r\ndwc2_hc_stall_intr(hsotg, chan, chnum, qtd);\r\n} else if ((chan->hcint & HCINTMSK_XACTERR) &&\r\nhsotg->core_params->dma_desc_enable <= 0) {\r\nif (out_nak_enh) {\r\nif (chan->hcint &\r\n(HCINTMSK_NYET | HCINTMSK_NAK | HCINTMSK_ACK)) {\r\ndev_vdbg(hsotg->dev,\r\n"XactErr with NYET/NAK/ACK\n");\r\nqtd->error_count = 0;\r\n} else {\r\ndev_vdbg(hsotg->dev,\r\n"XactErr without NYET/NAK/ACK\n");\r\n}\r\n}\r\ndwc2_hc_xacterr_intr(hsotg, chan, chnum, qtd);\r\n} else if ((chan->hcint & HCINTMSK_XCS_XACT) &&\r\nhsotg->core_params->dma_desc_enable > 0) {\r\ndwc2_hc_xacterr_intr(hsotg, chan, chnum, qtd);\r\n} else if ((chan->hcint & HCINTMSK_AHBERR) &&\r\nhsotg->core_params->dma_desc_enable > 0) {\r\ndwc2_hc_ahberr_intr(hsotg, chan, chnum, qtd);\r\n} else if (chan->hcint & HCINTMSK_BBLERR) {\r\ndwc2_hc_babble_intr(hsotg, chan, chnum, qtd);\r\n} else if (chan->hcint & HCINTMSK_FRMOVRUN) {\r\ndwc2_hc_frmovrun_intr(hsotg, chan, chnum, qtd);\r\n} else if (!out_nak_enh) {\r\nif (chan->hcint & HCINTMSK_NYET) {\r\ndwc2_hc_nyet_intr(hsotg, chan, chnum, qtd);\r\n} else if ((chan->hcint & HCINTMSK_NAK) &&\r\n!(hcintmsk & HCINTMSK_NAK)) {\r\ndwc2_hc_nak_intr(hsotg, chan, chnum, qtd);\r\n} else if ((chan->hcint & HCINTMSK_ACK) &&\r\n!(hcintmsk & HCINTMSK_ACK)) {\r\ndwc2_hc_ack_intr(hsotg, chan, chnum, qtd);\r\n} else {\r\nif (chan->ep_type == USB_ENDPOINT_XFER_INT ||\r\nchan->ep_type == USB_ENDPOINT_XFER_ISOC) {\r\ndev_dbg(hsotg->dev,\r\n"%s: Halt channel %d (assume incomplete periodic transfer)\n",\r\n__func__, chnum);\r\ndwc2_halt_channel(hsotg, chan, qtd,\r\nDWC2_HC_XFER_PERIODIC_INCOMPLETE);\r\n} else {\r\ndev_err(hsotg->dev,\r\n"%s: Channel %d - ChHltd set, but reason is unknown\n",\r\n__func__, chnum);\r\ndev_err(hsotg->dev,\r\n"hcint 0x%08x, intsts 0x%08x\n",\r\nchan->hcint,\r\ndwc2_readl(hsotg->regs + GINTSTS));\r\ngoto error;\r\n}\r\n}\r\n} else {\r\ndev_info(hsotg->dev,\r\n"NYET/NAK/ACK/other in non-error case, 0x%08x\n",\r\nchan->hcint);\r\nerror:\r\nqtd->error_count++;\r\ndwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb,\r\nqtd, DWC2_HC_XFER_XACT_ERR);\r\ndwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\r\ndwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_XACT_ERR);\r\n}\r\n}\r\nstatic void dwc2_hc_chhltd_intr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_host_chan *chan, int chnum,\r\nstruct dwc2_qtd *qtd)\r\n{\r\nif (dbg_hc(chan))\r\ndev_vdbg(hsotg->dev, "--Host Channel %d Interrupt: Channel Halted--\n",\r\nchnum);\r\nif (hsotg->core_params->dma_enable > 0) {\r\ndwc2_hc_chhltd_intr_dma(hsotg, chan, chnum, qtd);\r\n} else {\r\nif (!dwc2_halt_status_ok(hsotg, chan, chnum, qtd))\r\nreturn;\r\ndwc2_release_channel(hsotg, chan, qtd, chan->halt_status);\r\n}\r\n}\r\nstatic bool dwc2_check_qtd_still_ok(struct dwc2_qtd *qtd, struct dwc2_qh *qh)\r\n{\r\nstruct dwc2_qtd *cur_head;\r\nif (qh == NULL)\r\nreturn false;\r\ncur_head = list_first_entry(&qh->qtd_list, struct dwc2_qtd,\r\nqtd_list_entry);\r\nreturn (cur_head == qtd);\r\n}\r\nstatic void dwc2_hc_n_intr(struct dwc2_hsotg *hsotg, int chnum)\r\n{\r\nstruct dwc2_qtd *qtd;\r\nstruct dwc2_host_chan *chan;\r\nu32 hcint, hcintmsk;\r\nchan = hsotg->hc_ptr_array[chnum];\r\nhcint = dwc2_readl(hsotg->regs + HCINT(chnum));\r\nhcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(chnum));\r\nif (!chan) {\r\ndev_err(hsotg->dev, "## hc_ptr_array for channel is NULL ##\n");\r\ndwc2_writel(hcint, hsotg->regs + HCINT(chnum));\r\nreturn;\r\n}\r\nif (dbg_hc(chan)) {\r\ndev_vdbg(hsotg->dev, "--Host Channel Interrupt--, Channel %d\n",\r\nchnum);\r\ndev_vdbg(hsotg->dev,\r\n" hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\n",\r\nhcint, hcintmsk, hcint & hcintmsk);\r\n}\r\ndwc2_writel(hcint, hsotg->regs + HCINT(chnum));\r\nif (!chan->qh) {\r\ndev_warn(hsotg->dev, "Interrupt on disabled channel\n");\r\nreturn;\r\n}\r\nchan->hcint = hcint;\r\nhcint &= hcintmsk;\r\nif (chan->halt_status == DWC2_HC_XFER_URB_DEQUEUE) {\r\nWARN_ON(hcint != HCINTMSK_CHHLTD);\r\nif (hsotg->core_params->dma_desc_enable > 0)\r\ndwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\r\nchan->halt_status);\r\nelse\r\ndwc2_release_channel(hsotg, chan, NULL,\r\nchan->halt_status);\r\nreturn;\r\n}\r\nif (list_empty(&chan->qh->qtd_list)) {\r\ndev_dbg(hsotg->dev, "## no QTD queued for channel %d ##\n",\r\nchnum);\r\ndev_dbg(hsotg->dev,\r\n" hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\n",\r\nchan->hcint, hcintmsk, hcint);\r\nchan->halt_status = DWC2_HC_XFER_NO_HALT_STATUS;\r\ndisable_hc_int(hsotg, chnum, HCINTMSK_CHHLTD);\r\nchan->hcint = 0;\r\nreturn;\r\n}\r\nqtd = list_first_entry(&chan->qh->qtd_list, struct dwc2_qtd,\r\nqtd_list_entry);\r\nif (hsotg->core_params->dma_enable <= 0) {\r\nif ((hcint & HCINTMSK_CHHLTD) && hcint != HCINTMSK_CHHLTD)\r\nhcint &= ~HCINTMSK_CHHLTD;\r\n}\r\nif (hcint & HCINTMSK_XFERCOMPL) {\r\ndwc2_hc_xfercomp_intr(hsotg, chan, chnum, qtd);\r\nhcint &= ~HCINTMSK_NYET;\r\n}\r\nif (hcint & HCINTMSK_CHHLTD) {\r\ndwc2_hc_chhltd_intr(hsotg, chan, chnum, qtd);\r\nif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\r\ngoto exit;\r\n}\r\nif (hcint & HCINTMSK_AHBERR) {\r\ndwc2_hc_ahberr_intr(hsotg, chan, chnum, qtd);\r\nif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\r\ngoto exit;\r\n}\r\nif (hcint & HCINTMSK_STALL) {\r\ndwc2_hc_stall_intr(hsotg, chan, chnum, qtd);\r\nif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\r\ngoto exit;\r\n}\r\nif (hcint & HCINTMSK_NAK) {\r\ndwc2_hc_nak_intr(hsotg, chan, chnum, qtd);\r\nif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\r\ngoto exit;\r\n}\r\nif (hcint & HCINTMSK_ACK) {\r\ndwc2_hc_ack_intr(hsotg, chan, chnum, qtd);\r\nif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\r\ngoto exit;\r\n}\r\nif (hcint & HCINTMSK_NYET) {\r\ndwc2_hc_nyet_intr(hsotg, chan, chnum, qtd);\r\nif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\r\ngoto exit;\r\n}\r\nif (hcint & HCINTMSK_XACTERR) {\r\ndwc2_hc_xacterr_intr(hsotg, chan, chnum, qtd);\r\nif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\r\ngoto exit;\r\n}\r\nif (hcint & HCINTMSK_BBLERR) {\r\ndwc2_hc_babble_intr(hsotg, chan, chnum, qtd);\r\nif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\r\ngoto exit;\r\n}\r\nif (hcint & HCINTMSK_FRMOVRUN) {\r\ndwc2_hc_frmovrun_intr(hsotg, chan, chnum, qtd);\r\nif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\r\ngoto exit;\r\n}\r\nif (hcint & HCINTMSK_DATATGLERR) {\r\ndwc2_hc_datatglerr_intr(hsotg, chan, chnum, qtd);\r\nif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\r\ngoto exit;\r\n}\r\nexit:\r\nchan->hcint = 0;\r\n}\r\nstatic void dwc2_hc_intr(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 haint;\r\nint i;\r\nstruct dwc2_host_chan *chan, *chan_tmp;\r\nhaint = dwc2_readl(hsotg->regs + HAINT);\r\nif (dbg_perio()) {\r\ndev_vdbg(hsotg->dev, "%s()\n", __func__);\r\ndev_vdbg(hsotg->dev, "HAINT=%08x\n", haint);\r\n}\r\nlist_for_each_entry_safe(chan, chan_tmp, &hsotg->split_order,\r\nsplit_order_list_entry) {\r\nint hc_num = chan->hc_num;\r\nif (haint & (1 << hc_num)) {\r\ndwc2_hc_n_intr(hsotg, hc_num);\r\nhaint &= ~(1 << hc_num);\r\n}\r\n}\r\nfor (i = 0; i < hsotg->core_params->host_channels; i++) {\r\nif (haint & (1 << i))\r\ndwc2_hc_n_intr(hsotg, i);\r\n}\r\n}\r\nirqreturn_t dwc2_handle_hcd_intr(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 gintsts, dbg_gintsts;\r\nirqreturn_t retval = IRQ_NONE;\r\nif (!dwc2_is_controller_alive(hsotg)) {\r\ndev_warn(hsotg->dev, "Controller is dead\n");\r\nreturn retval;\r\n}\r\nspin_lock(&hsotg->lock);\r\nif (dwc2_is_host_mode(hsotg)) {\r\ngintsts = dwc2_read_core_intr(hsotg);\r\nif (!gintsts) {\r\nspin_unlock(&hsotg->lock);\r\nreturn retval;\r\n}\r\nretval = IRQ_HANDLED;\r\ndbg_gintsts = gintsts;\r\n#ifndef DEBUG_SOF\r\ndbg_gintsts &= ~GINTSTS_SOF;\r\n#endif\r\nif (!dbg_perio())\r\ndbg_gintsts &= ~(GINTSTS_HCHINT | GINTSTS_RXFLVL |\r\nGINTSTS_PTXFEMP);\r\nif (dbg_gintsts)\r\ndev_vdbg(hsotg->dev,\r\n"DWC OTG HCD Interrupt Detected gintsts&gintmsk=0x%08x\n",\r\ngintsts);\r\nif (gintsts & GINTSTS_SOF)\r\ndwc2_sof_intr(hsotg);\r\nif (gintsts & GINTSTS_RXFLVL)\r\ndwc2_rx_fifo_level_intr(hsotg);\r\nif (gintsts & GINTSTS_NPTXFEMP)\r\ndwc2_np_tx_fifo_empty_intr(hsotg);\r\nif (gintsts & GINTSTS_PRTINT)\r\ndwc2_port_intr(hsotg);\r\nif (gintsts & GINTSTS_HCHINT)\r\ndwc2_hc_intr(hsotg);\r\nif (gintsts & GINTSTS_PTXFEMP)\r\ndwc2_perio_tx_fifo_empty_intr(hsotg);\r\nif (dbg_gintsts) {\r\ndev_vdbg(hsotg->dev,\r\n"DWC OTG HCD Finished Servicing Interrupts\n");\r\ndev_vdbg(hsotg->dev,\r\n"DWC OTG HCD gintsts=0x%08x gintmsk=0x%08x\n",\r\ndwc2_readl(hsotg->regs + GINTSTS),\r\ndwc2_readl(hsotg->regs + GINTMSK));\r\n}\r\n}\r\nspin_unlock(&hsotg->lock);\r\nreturn retval;\r\n}
