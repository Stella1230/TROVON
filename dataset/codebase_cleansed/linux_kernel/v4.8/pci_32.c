static void\r\nfixup_cpc710_pci64(struct pci_dev* dev)\r\n{\r\ndev->resource[0].start = dev->resource[0].end = 0;\r\ndev->resource[0].flags = 0;\r\ndev->resource[1].start = dev->resource[1].end = 0;\r\ndev->resource[1].flags = 0;\r\n}\r\nstatic void\r\nmake_one_node_map(struct device_node* node, u8 pci_bus)\r\n{\r\nconst int *bus_range;\r\nint len;\r\nif (pci_bus >= pci_bus_count)\r\nreturn;\r\nbus_range = of_get_property(node, "bus-range", &len);\r\nif (bus_range == NULL || len < 2 * sizeof(int)) {\r\nprintk(KERN_WARNING "Can't get bus-range for %s, "\r\n"assuming it starts at 0\n", node->full_name);\r\npci_to_OF_bus_map[pci_bus] = 0;\r\n} else\r\npci_to_OF_bus_map[pci_bus] = bus_range[0];\r\nfor_each_child_of_node(node, node) {\r\nstruct pci_dev* dev;\r\nconst unsigned int *class_code, *reg;\r\nclass_code = of_get_property(node, "class-code", NULL);\r\nif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\r\n(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\r\ncontinue;\r\nreg = of_get_property(node, "reg", NULL);\r\nif (!reg)\r\ncontinue;\r\ndev = pci_get_bus_and_slot(pci_bus, ((reg[0] >> 8) & 0xff));\r\nif (!dev || !dev->subordinate) {\r\npci_dev_put(dev);\r\ncontinue;\r\n}\r\nmake_one_node_map(node, dev->subordinate->number);\r\npci_dev_put(dev);\r\n}\r\n}\r\nvoid\r\npcibios_make_OF_bus_map(void)\r\n{\r\nint i;\r\nstruct pci_controller *hose, *tmp;\r\nstruct property *map_prop;\r\nstruct device_node *dn;\r\npci_to_OF_bus_map = kmalloc(pci_bus_count, GFP_KERNEL);\r\nif (!pci_to_OF_bus_map) {\r\nprintk(KERN_ERR "Can't allocate OF bus map !\n");\r\nreturn;\r\n}\r\nfor (i=0; i<pci_bus_count; i++)\r\npci_to_OF_bus_map[i] = 0xff;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\r\nstruct device_node* node = hose->dn;\r\nif (!node)\r\ncontinue;\r\nmake_one_node_map(node, hose->first_busno);\r\n}\r\ndn = of_find_node_by_path("/");\r\nmap_prop = of_find_property(dn, "pci-OF-bus-map", NULL);\r\nif (map_prop) {\r\nBUG_ON(pci_bus_count > map_prop->length);\r\nmemcpy(map_prop->value, pci_to_OF_bus_map, pci_bus_count);\r\n}\r\nof_node_put(dn);\r\n#ifdef DEBUG\r\nprintk("PCI->OF bus map:\n");\r\nfor (i=0; i<pci_bus_count; i++) {\r\nif (pci_to_OF_bus_map[i] == 0xff)\r\ncontinue;\r\nprintk("%d -> %d\n", i, pci_to_OF_bus_map[i]);\r\n}\r\n#endif\r\n}\r\nint pci_device_from_OF_node(struct device_node *node, u8 *bus, u8 *devfn)\r\n{\r\nstruct pci_dev *dev = NULL;\r\nconst __be32 *reg;\r\nint size;\r\nif (!pci_find_hose_for_OF_device(node))\r\nreturn -ENODEV;\r\nreg = of_get_property(node, "reg", &size);\r\nif (!reg || size < 5 * sizeof(u32))\r\nreturn -ENODEV;\r\n*bus = (be32_to_cpup(&reg[0]) >> 16) & 0xff;\r\n*devfn = (be32_to_cpup(&reg[0]) >> 8) & 0xff;\r\nif (!pci_to_OF_bus_map)\r\nreturn 0;\r\nfor_each_pci_dev(dev)\r\nif (pci_to_OF_bus_map[dev->bus->number] == *bus &&\r\ndev->devfn == *devfn) {\r\n*bus = dev->bus->number;\r\npci_dev_put(dev);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nvoid __init\r\npci_create_OF_bus_map(void)\r\n{\r\nstruct property* of_prop;\r\nstruct device_node *dn;\r\nof_prop = memblock_virt_alloc(sizeof(struct property) + 256, 0);\r\ndn = of_find_node_by_path("/");\r\nif (dn) {\r\nmemset(of_prop, -1, sizeof(struct property) + 256);\r\nof_prop->name = "pci-OF-bus-map";\r\nof_prop->length = 256;\r\nof_prop->value = &of_prop[1];\r\nof_add_property(dn, of_prop);\r\nof_node_put(dn);\r\n}\r\n}\r\nvoid pcibios_setup_phb_io_space(struct pci_controller *hose)\r\n{\r\nunsigned long io_offset;\r\nstruct resource *res = &hose->io_resource;\r\nio_offset = pcibios_io_space_offset(hose);\r\nres->start += io_offset;\r\nres->end += io_offset;\r\n}\r\nstatic int __init pcibios_init(void)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nint next_busno = 0;\r\nprintk(KERN_INFO "PCI: Probing PCI hardware\n");\r\nif (pci_has_flag(PCI_REASSIGN_ALL_BUS))\r\npci_assign_all_buses = 1;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\r\nif (pci_assign_all_buses)\r\nhose->first_busno = next_busno;\r\nhose->last_busno = 0xff;\r\npcibios_scan_phb(hose);\r\npci_bus_add_devices(hose->bus);\r\nif (pci_assign_all_buses || next_busno <= hose->last_busno)\r\nnext_busno = hose->last_busno + pcibios_assign_bus_offset;\r\n}\r\npci_bus_count = next_busno;\r\nif (pci_assign_all_buses)\r\npcibios_make_OF_bus_map();\r\npcibios_resource_survey();\r\nif (ppc_md.pcibios_after_init)\r\nppc_md.pcibios_after_init();\r\nreturn 0;\r\n}\r\nstatic struct pci_controller*\r\npci_bus_to_hose(int bus)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\r\nif (bus >= hose->first_busno && bus <= hose->last_busno)\r\nreturn hose;\r\nreturn NULL;\r\n}\r\nlong sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn)\r\n{\r\nstruct pci_controller* hose;\r\nlong result = -EOPNOTSUPP;\r\nhose = pci_bus_to_hose(bus);\r\nif (!hose)\r\nreturn -ENODEV;\r\nswitch (which) {\r\ncase IOBASE_BRIDGE_NUMBER:\r\nreturn (long)hose->first_busno;\r\ncase IOBASE_MEMORY:\r\nreturn (long)hose->mem_offset[0];\r\ncase IOBASE_IO:\r\nreturn (long)hose->io_base_phys;\r\ncase IOBASE_ISA_IO:\r\nreturn (long)isa_io_base;\r\ncase IOBASE_ISA_MEM:\r\nreturn (long)isa_mem_base;\r\n}\r\nreturn result;\r\n}
