static void spc_fill_alua_data(struct se_lun *lun, unsigned char *buf)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nbuf[5] = 0x80;\r\nspin_lock(&lun->lun_tg_pt_gp_lock);\r\ntg_pt_gp = lun->lun_tg_pt_gp;\r\nif (tg_pt_gp)\r\nbuf[5] |= tg_pt_gp->tg_pt_gp_alua_access_type;\r\nspin_unlock(&lun->lun_tg_pt_gp_lock);\r\n}\r\nsense_reason_t\r\nspc_emulate_inquiry_std(struct se_cmd *cmd, unsigned char *buf)\r\n{\r\nstruct se_lun *lun = cmd->se_lun;\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_session *sess = cmd->se_sess;\r\nif (dev->transport->get_device_type(dev) == TYPE_TAPE)\r\nbuf[1] = 0x80;\r\nbuf[2] = 0x05;\r\nbuf[3] = 2;\r\nspc_fill_alua_data(lun, buf);\r\nif (dev->dev_attrib.emulate_3pc)\r\nbuf[5] |= 0x8;\r\nif (sess->sup_prot_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS)) {\r\nif (dev->dev_attrib.pi_prot_type || cmd->se_sess->sess_prot_type)\r\nbuf[5] |= 0x1;\r\n}\r\nbuf[7] = 0x2;\r\nmemcpy(&buf[8], "LIO-ORG ", 8);\r\nmemset(&buf[16], 0x20, 16);\r\nmemcpy(&buf[16], dev->t10_wwn.model,\r\nmin_t(size_t, strlen(dev->t10_wwn.model), 16));\r\nmemcpy(&buf[32], dev->t10_wwn.revision,\r\nmin_t(size_t, strlen(dev->t10_wwn.revision), 4));\r\nbuf[4] = 31;\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nspc_emulate_evpd_80(struct se_cmd *cmd, unsigned char *buf)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nu16 len;\r\nif (dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL) {\r\nlen = sprintf(&buf[4], "%s", dev->t10_wwn.unit_serial);\r\nlen++;\r\nbuf[3] = len;\r\n}\r\nreturn 0;\r\n}\r\nvoid spc_parse_naa_6h_vendor_specific(struct se_device *dev,\r\nunsigned char *buf)\r\n{\r\nunsigned char *p = &dev->t10_wwn.unit_serial[0];\r\nint cnt;\r\nbool next = true;\r\nfor (cnt = 0; *p && cnt < 13; p++) {\r\nint val = hex_to_bin(*p);\r\nif (val < 0)\r\ncontinue;\r\nif (next) {\r\nnext = false;\r\nbuf[cnt++] |= val;\r\n} else {\r\nnext = true;\r\nbuf[cnt] = val << 4;\r\n}\r\n}\r\n}\r\nsense_reason_t\r\nspc_emulate_evpd_83(struct se_cmd *cmd, unsigned char *buf)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_lun *lun = cmd->se_lun;\r\nstruct se_portal_group *tpg = NULL;\r\nstruct t10_alua_lu_gp_member *lu_gp_mem;\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nunsigned char *prod = &dev->t10_wwn.model[0];\r\nu32 prod_len;\r\nu32 unit_serial_len, off = 0;\r\nu16 len = 0, id_len;\r\noff = 4;\r\nif (!(dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL))\r\ngoto check_t10_vend_desc;\r\nbuf[off++] = 0x1;\r\nbuf[off] = 0x00;\r\nbuf[off++] |= 0x3;\r\noff++;\r\nbuf[off++] = 0x10;\r\nbuf[off++] = (0x6 << 4);\r\nbuf[off++] = 0x01;\r\nbuf[off++] = 0x40;\r\nbuf[off] = (0x5 << 4);\r\nspc_parse_naa_6h_vendor_specific(dev, &buf[off]);\r\nlen = 20;\r\noff = (len + 4);\r\ncheck_t10_vend_desc:\r\nid_len = 8;\r\nprod_len = 4;\r\nprod_len += 8;\r\nprod_len += strlen(prod);\r\nprod_len++;\r\nif (dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL) {\r\nunit_serial_len = strlen(&dev->t10_wwn.unit_serial[0]);\r\nunit_serial_len++;\r\nid_len += sprintf(&buf[off+12], "%s:%s", prod,\r\n&dev->t10_wwn.unit_serial[0]);\r\n}\r\nbuf[off] = 0x2;\r\nbuf[off+1] = 0x1;\r\nbuf[off+2] = 0x0;\r\nmemcpy(&buf[off+4], "LIO-ORG", 8);\r\nid_len++;\r\nbuf[off+3] = id_len;\r\nlen += (id_len + 4);\r\noff += (id_len + 4);\r\nif (1) {\r\nstruct t10_alua_lu_gp *lu_gp;\r\nu32 padding, scsi_name_len, scsi_target_len;\r\nu16 lu_gp_id = 0;\r\nu16 tg_pt_gp_id = 0;\r\nu16 tpgt;\r\ntpg = lun->lun_tpg;\r\nbuf[off] = tpg->proto_id << 4;\r\nbuf[off++] |= 0x1;\r\nbuf[off] = 0x80;\r\nbuf[off] |= 0x10;\r\nbuf[off++] |= 0x4;\r\noff++;\r\nbuf[off++] = 4;\r\noff += 2;\r\nbuf[off++] = ((lun->lun_rtpi >> 8) & 0xff);\r\nbuf[off++] = (lun->lun_rtpi & 0xff);\r\nlen += 8;\r\nspin_lock(&lun->lun_tg_pt_gp_lock);\r\ntg_pt_gp = lun->lun_tg_pt_gp;\r\nif (!tg_pt_gp) {\r\nspin_unlock(&lun->lun_tg_pt_gp_lock);\r\ngoto check_lu_gp;\r\n}\r\ntg_pt_gp_id = tg_pt_gp->tg_pt_gp_id;\r\nspin_unlock(&lun->lun_tg_pt_gp_lock);\r\nbuf[off] = tpg->proto_id << 4;\r\nbuf[off++] |= 0x1;\r\nbuf[off] = 0x80;\r\nbuf[off] |= 0x10;\r\nbuf[off++] |= 0x5;\r\noff++;\r\nbuf[off++] = 4;\r\noff += 2;\r\nbuf[off++] = ((tg_pt_gp_id >> 8) & 0xff);\r\nbuf[off++] = (tg_pt_gp_id & 0xff);\r\nlen += 8;\r\ncheck_lu_gp:\r\nlu_gp_mem = dev->dev_alua_lu_gp_mem;\r\nif (!lu_gp_mem)\r\ngoto check_scsi_name;\r\nspin_lock(&lu_gp_mem->lu_gp_mem_lock);\r\nlu_gp = lu_gp_mem->lu_gp;\r\nif (!lu_gp) {\r\nspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\r\ngoto check_scsi_name;\r\n}\r\nlu_gp_id = lu_gp->lu_gp_id;\r\nspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\r\nbuf[off++] |= 0x1;\r\nbuf[off++] |= 0x6;\r\noff++;\r\nbuf[off++] = 4;\r\noff += 2;\r\nbuf[off++] = ((lu_gp_id >> 8) & 0xff);\r\nbuf[off++] = (lu_gp_id & 0xff);\r\nlen += 8;\r\ncheck_scsi_name:\r\nbuf[off] = tpg->proto_id << 4;\r\nbuf[off++] |= 0x3;\r\nbuf[off] = 0x80;\r\nbuf[off] |= 0x10;\r\nbuf[off++] |= 0x8;\r\noff += 2;\r\ntpgt = tpg->se_tpg_tfo->tpg_get_tag(tpg);\r\nscsi_name_len = sprintf(&buf[off], "%s,t,0x%04x",\r\ntpg->se_tpg_tfo->tpg_get_wwn(tpg), tpgt);\r\nscsi_name_len += 1 ;\r\npadding = ((-scsi_name_len) & 3);\r\nif (padding)\r\nscsi_name_len += padding;\r\nif (scsi_name_len > 256)\r\nscsi_name_len = 256;\r\nbuf[off-1] = scsi_name_len;\r\noff += scsi_name_len;\r\nlen += (scsi_name_len + 4);\r\nbuf[off] = tpg->proto_id << 4;\r\nbuf[off++] |= 0x3;\r\nbuf[off] = 0x80;\r\nbuf[off] |= 0x20;\r\nbuf[off++] |= 0x8;\r\noff += 2;\r\nscsi_target_len = sprintf(&buf[off], "%s",\r\ntpg->se_tpg_tfo->tpg_get_wwn(tpg));\r\nscsi_target_len += 1 ;\r\npadding = ((-scsi_target_len) & 3);\r\nif (padding)\r\nscsi_target_len += padding;\r\nif (scsi_target_len > 256)\r\nscsi_target_len = 256;\r\nbuf[off-1] = scsi_target_len;\r\noff += scsi_target_len;\r\nlen += (scsi_target_len + 4);\r\n}\r\nbuf[2] = ((len >> 8) & 0xff);\r\nbuf[3] = (len & 0xff);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nspc_emulate_evpd_86(struct se_cmd *cmd, unsigned char *buf)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_session *sess = cmd->se_sess;\r\nbuf[3] = 0x3c;\r\nif (sess->sup_prot_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS)) {\r\nif (dev->dev_attrib.pi_prot_type == TARGET_DIF_TYPE1_PROT ||\r\ncmd->se_sess->sess_prot_type == TARGET_DIF_TYPE1_PROT)\r\nbuf[4] = 0x5;\r\nelse if (dev->dev_attrib.pi_prot_type == TARGET_DIF_TYPE3_PROT ||\r\ncmd->se_sess->sess_prot_type == TARGET_DIF_TYPE3_PROT)\r\nbuf[4] = 0x4;\r\n}\r\nif ((dev->transport->get_device_type(dev) == TYPE_DISK) &&\r\n(sess->sup_prot_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS)) &&\r\n(dev->dev_attrib.pi_prot_type || cmd->se_sess->sess_prot_type)) {\r\nbuf[4] |= (0x3 << 3);\r\n}\r\nbuf[5] = 0x07;\r\nif (target_check_wce(dev))\r\nbuf[6] = 0x01;\r\nspin_lock(&cmd->se_dev->t10_alua.lba_map_lock);\r\nif (!list_empty(&dev->t10_alua.lba_map_list))\r\nbuf[8] = 0x10;\r\nspin_unlock(&cmd->se_dev->t10_alua.lba_map_lock);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nspc_emulate_evpd_b0(struct se_cmd *cmd, unsigned char *buf)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nu32 mtl = 0;\r\nint have_tp = 0, opt, min;\r\nif (dev->dev_attrib.emulate_tpu || dev->dev_attrib.emulate_tpws)\r\nhave_tp = 1;\r\nbuf[0] = dev->transport->get_device_type(dev);\r\nbuf[3] = have_tp ? 0x3c : 0x10;\r\nbuf[4] = 0x01;\r\nif (dev->dev_attrib.emulate_caw)\r\nbuf[5] = 0x01;\r\nif (dev->transport->get_io_min && (min = dev->transport->get_io_min(dev)))\r\nput_unaligned_be16(min / dev->dev_attrib.block_size, &buf[6]);\r\nelse\r\nput_unaligned_be16(1, &buf[6]);\r\nif (cmd->se_tfo->max_data_sg_nents) {\r\nmtl = (cmd->se_tfo->max_data_sg_nents * PAGE_SIZE) /\r\ndev->dev_attrib.block_size;\r\n}\r\nput_unaligned_be32(min_not_zero(mtl, dev->dev_attrib.hw_max_sectors), &buf[8]);\r\nif (dev->transport->get_io_opt && (opt = dev->transport->get_io_opt(dev)))\r\nput_unaligned_be32(opt / dev->dev_attrib.block_size, &buf[12]);\r\nelse\r\nput_unaligned_be32(dev->dev_attrib.optimal_sectors, &buf[12]);\r\nif (!have_tp)\r\ngoto max_write_same;\r\nput_unaligned_be32(dev->dev_attrib.max_unmap_lba_count, &buf[20]);\r\nput_unaligned_be32(dev->dev_attrib.max_unmap_block_desc_count,\r\n&buf[24]);\r\nput_unaligned_be32(dev->dev_attrib.unmap_granularity, &buf[28]);\r\nput_unaligned_be32(dev->dev_attrib.unmap_granularity_alignment,\r\n&buf[32]);\r\nif (dev->dev_attrib.unmap_granularity_alignment != 0)\r\nbuf[32] |= 0x80;\r\nmax_write_same:\r\nput_unaligned_be64(dev->dev_attrib.max_write_same_len, &buf[36]);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nspc_emulate_evpd_b1(struct se_cmd *cmd, unsigned char *buf)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nbuf[0] = dev->transport->get_device_type(dev);\r\nbuf[3] = 0x3c;\r\nbuf[5] = dev->dev_attrib.is_nonrot ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nspc_emulate_evpd_b2(struct se_cmd *cmd, unsigned char *buf)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nbuf[0] = dev->transport->get_device_type(dev);\r\nput_unaligned_be16(0x0004, &buf[2]);\r\nbuf[4] = 0x00;\r\nif (dev->dev_attrib.emulate_tpu != 0)\r\nbuf[5] = 0x80;\r\nif (dev->dev_attrib.emulate_tpws != 0)\r\nbuf[5] |= 0x40 | 0x20;\r\nif (((dev->dev_attrib.emulate_tpu != 0) ||\r\n(dev->dev_attrib.emulate_tpws != 0)) &&\r\n(dev->dev_attrib.unmap_zeroes_data != 0))\r\nbuf[5] |= 0x04;\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nspc_emulate_evpd_b3(struct se_cmd *cmd, unsigned char *buf)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nbuf[0] = dev->transport->get_device_type(dev);\r\nbuf[3] = 0x0c;\r\nput_unaligned_be32(dev->t10_alua.lba_map_segment_size, &buf[8]);\r\nput_unaligned_be32(dev->t10_alua.lba_map_segment_multiplier, &buf[12]);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nspc_emulate_evpd_00(struct se_cmd *cmd, unsigned char *buf)\r\n{\r\nint p;\r\nif (cmd->se_dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL) {\r\nbuf[3] = ARRAY_SIZE(evpd_handlers);\r\nfor (p = 0; p < ARRAY_SIZE(evpd_handlers); ++p)\r\nbuf[p + 4] = evpd_handlers[p].page;\r\n}\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nspc_emulate_inquiry(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_portal_group *tpg = cmd->se_lun->lun_tpg;\r\nunsigned char *rbuf;\r\nunsigned char *cdb = cmd->t_task_cdb;\r\nunsigned char *buf;\r\nsense_reason_t ret;\r\nint p;\r\nint len = 0;\r\nbuf = kzalloc(SE_INQUIRY_BUF, GFP_KERNEL);\r\nif (!buf) {\r\npr_err("Unable to allocate response buffer for INQUIRY\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nif (dev == rcu_access_pointer(tpg->tpg_virt_lun0->lun_se_dev))\r\nbuf[0] = 0x3f;\r\nelse\r\nbuf[0] = dev->transport->get_device_type(dev);\r\nif (!(cdb[1] & 0x1)) {\r\nif (cdb[2]) {\r\npr_err("INQUIRY with EVPD==0 but PAGE CODE=%02x\n",\r\ncdb[2]);\r\nret = TCM_INVALID_CDB_FIELD;\r\ngoto out;\r\n}\r\nret = spc_emulate_inquiry_std(cmd, buf);\r\nlen = buf[4] + 5;\r\ngoto out;\r\n}\r\nfor (p = 0; p < ARRAY_SIZE(evpd_handlers); ++p) {\r\nif (cdb[2] == evpd_handlers[p].page) {\r\nbuf[1] = cdb[2];\r\nret = evpd_handlers[p].emulate(cmd, buf);\r\nlen = get_unaligned_be16(&buf[2]) + 4;\r\ngoto out;\r\n}\r\n}\r\npr_err("Unknown VPD Code: 0x%02x\n", cdb[2]);\r\nret = TCM_INVALID_CDB_FIELD;\r\nout:\r\nrbuf = transport_kmap_data_sg(cmd);\r\nif (rbuf) {\r\nmemcpy(rbuf, buf, min_t(u32, SE_INQUIRY_BUF, cmd->data_length));\r\ntransport_kunmap_data_sg(cmd);\r\n}\r\nkfree(buf);\r\nif (!ret)\r\ntarget_complete_cmd_with_length(cmd, GOOD, len);\r\nreturn ret;\r\n}\r\nstatic int spc_modesense_rwrecovery(struct se_cmd *cmd, u8 pc, u8 *p)\r\n{\r\np[0] = 0x01;\r\np[1] = 0x0a;\r\nif (pc == 1)\r\ngoto out;\r\nout:\r\nreturn 12;\r\n}\r\nstatic int spc_modesense_control(struct se_cmd *cmd, u8 pc, u8 *p)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_session *sess = cmd->se_sess;\r\np[0] = 0x0a;\r\np[1] = 0x0a;\r\nif (pc == 1)\r\ngoto out;\r\np[2] = (1 << 1);\r\nif (target_sense_desc_format(dev))\r\np[2] |= (1 << 2);\r\np[3] = (dev->dev_attrib.emulate_rest_reord == 1) ? 0x00 : 0x10;\r\np[4] = (dev->dev_attrib.emulate_ua_intlck_ctrl == 2) ? 0x30 :\r\n(dev->dev_attrib.emulate_ua_intlck_ctrl == 1) ? 0x20 : 0x00;\r\np[5] = (dev->dev_attrib.emulate_tas) ? 0x40 : 0x00;\r\nif (sess->sup_prot_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS)) {\r\nif (dev->dev_attrib.pi_prot_type || sess->sess_prot_type)\r\np[5] |= 0x80;\r\n}\r\np[8] = 0xff;\r\np[9] = 0xff;\r\np[11] = 30;\r\nout:\r\nreturn 12;\r\n}\r\nstatic int spc_modesense_caching(struct se_cmd *cmd, u8 pc, u8 *p)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\np[0] = 0x08;\r\np[1] = 0x12;\r\nif (pc == 1)\r\ngoto out;\r\nif (target_check_wce(dev))\r\np[2] = 0x04;\r\np[12] = 0x20;\r\nout:\r\nreturn 20;\r\n}\r\nstatic int spc_modesense_informational_exceptions(struct se_cmd *cmd, u8 pc, unsigned char *p)\r\n{\r\np[0] = 0x1c;\r\np[1] = 0x0a;\r\nif (pc == 1)\r\ngoto out;\r\nout:\r\nreturn 12;\r\n}\r\nstatic void spc_modesense_write_protect(unsigned char *buf, int type)\r\n{\r\nswitch (type) {\r\ncase TYPE_DISK:\r\ncase TYPE_TAPE:\r\ndefault:\r\nbuf[0] |= 0x80;\r\nbreak;\r\n}\r\n}\r\nstatic void spc_modesense_dpofua(unsigned char *buf, int type)\r\n{\r\nswitch (type) {\r\ncase TYPE_DISK:\r\nbuf[0] |= 0x10;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int spc_modesense_blockdesc(unsigned char *buf, u64 blocks, u32 block_size)\r\n{\r\n*buf++ = 8;\r\nput_unaligned_be32(min(blocks, 0xffffffffull), buf);\r\nbuf += 4;\r\nput_unaligned_be32(block_size, buf);\r\nreturn 9;\r\n}\r\nstatic int spc_modesense_long_blockdesc(unsigned char *buf, u64 blocks, u32 block_size)\r\n{\r\nif (blocks <= 0xffffffff)\r\nreturn spc_modesense_blockdesc(buf + 3, blocks, block_size) + 3;\r\n*buf++ = 1;\r\nbuf += 2;\r\n*buf++ = 16;\r\nput_unaligned_be64(blocks, buf);\r\nbuf += 12;\r\nput_unaligned_be32(block_size, buf);\r\nreturn 17;\r\n}\r\nstatic sense_reason_t spc_emulate_modesense(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nchar *cdb = cmd->t_task_cdb;\r\nunsigned char buf[SE_MODE_PAGE_BUF], *rbuf;\r\nint type = dev->transport->get_device_type(dev);\r\nint ten = (cmd->t_task_cdb[0] == MODE_SENSE_10);\r\nbool dbd = !!(cdb[1] & 0x08);\r\nbool llba = ten ? !!(cdb[1] & 0x10) : false;\r\nu8 pc = cdb[2] >> 6;\r\nu8 page = cdb[2] & 0x3f;\r\nu8 subpage = cdb[3];\r\nint length = 0;\r\nint ret;\r\nint i;\r\nmemset(buf, 0, SE_MODE_PAGE_BUF);\r\nlength = ten ? 3 : 2;\r\nif (cmd->se_lun->lun_access_ro || target_lun_is_rdonly(cmd))\r\nspc_modesense_write_protect(&buf[length], type);\r\nif (target_check_fua(dev))\r\nspc_modesense_dpofua(&buf[length], type);\r\n++length;\r\nif (!dbd && type == TYPE_DISK) {\r\nu64 blocks = dev->transport->get_blocks(dev);\r\nu32 block_size = dev->dev_attrib.block_size;\r\nif (ten) {\r\nif (llba) {\r\nlength += spc_modesense_long_blockdesc(&buf[length],\r\nblocks, block_size);\r\n} else {\r\nlength += 3;\r\nlength += spc_modesense_blockdesc(&buf[length],\r\nblocks, block_size);\r\n}\r\n} else {\r\nlength += spc_modesense_blockdesc(&buf[length], blocks,\r\nblock_size);\r\n}\r\n} else {\r\nif (ten)\r\nlength += 4;\r\nelse\r\nlength += 1;\r\n}\r\nif (page == 0x3f) {\r\nif (subpage != 0x00 && subpage != 0xff) {\r\npr_warn("MODE_SENSE: Invalid subpage code: 0x%02x\n", subpage);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(modesense_handlers); ++i) {\r\nif ((modesense_handlers[i].subpage & ~subpage) == 0) {\r\nret = modesense_handlers[i].emulate(cmd, pc, &buf[length]);\r\nif (!ten && length + ret >= 255)\r\nbreak;\r\nlength += ret;\r\n}\r\n}\r\ngoto set_length;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(modesense_handlers); ++i)\r\nif (modesense_handlers[i].page == page &&\r\nmodesense_handlers[i].subpage == subpage) {\r\nlength += modesense_handlers[i].emulate(cmd, pc, &buf[length]);\r\ngoto set_length;\r\n}\r\nif (page != 0x03)\r\npr_err("MODE SENSE: unimplemented page/subpage: 0x%02x/0x%02x\n",\r\npage, subpage);\r\nreturn TCM_UNKNOWN_MODE_PAGE;\r\nset_length:\r\nif (ten)\r\nput_unaligned_be16(length - 2, buf);\r\nelse\r\nbuf[0] = length - 1;\r\nrbuf = transport_kmap_data_sg(cmd);\r\nif (rbuf) {\r\nmemcpy(rbuf, buf, min_t(u32, SE_MODE_PAGE_BUF, cmd->data_length));\r\ntransport_kunmap_data_sg(cmd);\r\n}\r\ntarget_complete_cmd_with_length(cmd, GOOD, length);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t spc_emulate_modeselect(struct se_cmd *cmd)\r\n{\r\nchar *cdb = cmd->t_task_cdb;\r\nbool ten = cdb[0] == MODE_SELECT_10;\r\nint off = ten ? 8 : 4;\r\nbool pf = !!(cdb[1] & 0x10);\r\nu8 page, subpage;\r\nunsigned char *buf;\r\nunsigned char tbuf[SE_MODE_PAGE_BUF];\r\nint length;\r\nsense_reason_t ret = 0;\r\nint i;\r\nif (!cmd->data_length) {\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn 0;\r\n}\r\nif (cmd->data_length < off + 2)\r\nreturn TCM_PARAMETER_LIST_LENGTH_ERROR;\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nif (!pf) {\r\nret = TCM_INVALID_CDB_FIELD;\r\ngoto out;\r\n}\r\npage = buf[off] & 0x3f;\r\nsubpage = buf[off] & 0x40 ? buf[off + 1] : 0;\r\nfor (i = 0; i < ARRAY_SIZE(modesense_handlers); ++i)\r\nif (modesense_handlers[i].page == page &&\r\nmodesense_handlers[i].subpage == subpage) {\r\nmemset(tbuf, 0, SE_MODE_PAGE_BUF);\r\nlength = modesense_handlers[i].emulate(cmd, 0, tbuf);\r\ngoto check_contents;\r\n}\r\nret = TCM_UNKNOWN_MODE_PAGE;\r\ngoto out;\r\ncheck_contents:\r\nif (cmd->data_length < off + length) {\r\nret = TCM_PARAMETER_LIST_LENGTH_ERROR;\r\ngoto out;\r\n}\r\nif (memcmp(buf + off, tbuf, length))\r\nret = TCM_INVALID_PARAMETER_LIST;\r\nout:\r\ntransport_kunmap_data_sg(cmd);\r\nif (!ret)\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn ret;\r\n}\r\nstatic sense_reason_t spc_emulate_request_sense(struct se_cmd *cmd)\r\n{\r\nunsigned char *cdb = cmd->t_task_cdb;\r\nunsigned char *rbuf;\r\nu8 ua_asc = 0, ua_ascq = 0;\r\nunsigned char buf[SE_SENSE_BUF];\r\nbool desc_format = target_sense_desc_format(cmd->se_dev);\r\nmemset(buf, 0, SE_SENSE_BUF);\r\nif (cdb[1] & 0x01) {\r\npr_err("REQUEST_SENSE description emulation not"\r\n" supported\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nrbuf = transport_kmap_data_sg(cmd);\r\nif (!rbuf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nif (!core_scsi3_ua_clear_for_request_sense(cmd, &ua_asc, &ua_ascq))\r\nscsi_build_sense_buffer(desc_format, buf, UNIT_ATTENTION,\r\nua_asc, ua_ascq);\r\nelse\r\nscsi_build_sense_buffer(desc_format, buf, NO_SENSE, 0x0, 0x0);\r\nmemcpy(rbuf, buf, min_t(u32, sizeof(buf), cmd->data_length));\r\ntransport_kunmap_data_sg(cmd);\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn 0;\r\n}\r\nsense_reason_t spc_emulate_report_luns(struct se_cmd *cmd)\r\n{\r\nstruct se_dev_entry *deve;\r\nstruct se_session *sess = cmd->se_sess;\r\nstruct se_node_acl *nacl;\r\nstruct scsi_lun slun;\r\nunsigned char *buf;\r\nu32 lun_count = 0, offset = 8;\r\n__be32 len;\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (cmd->data_length && !buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nif (!sess)\r\ngoto done;\r\nnacl = sess->se_node_acl;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link) {\r\nlun_count++;\r\nif (offset >= cmd->data_length)\r\ncontinue;\r\nint_to_scsilun(deve->mapped_lun, &slun);\r\nmemcpy(buf + offset, &slun,\r\nmin(8u, cmd->data_length - offset));\r\noffset += 8;\r\n}\r\nrcu_read_unlock();\r\ndone:\r\nif (lun_count == 0) {\r\nint_to_scsilun(0, &slun);\r\nif (cmd->data_length > 8)\r\nmemcpy(buf + offset, &slun,\r\nmin(8u, cmd->data_length - offset));\r\nlun_count = 1;\r\n}\r\nif (buf) {\r\nlen = cpu_to_be32(lun_count * 8);\r\nmemcpy(buf, &len, min_t(int, sizeof len, cmd->data_length));\r\ntransport_kunmap_data_sg(cmd);\r\n}\r\ntarget_complete_cmd_with_length(cmd, GOOD, 8 + lun_count * 8);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nspc_emulate_testunitready(struct se_cmd *cmd)\r\n{\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn 0;\r\n}\r\nsense_reason_t\r\nspc_parse_cdb(struct se_cmd *cmd, unsigned int *size)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nunsigned char *cdb = cmd->t_task_cdb;\r\nswitch (cdb[0]) {\r\ncase MODE_SELECT:\r\n*size = cdb[4];\r\ncmd->execute_cmd = spc_emulate_modeselect;\r\nbreak;\r\ncase MODE_SELECT_10:\r\n*size = (cdb[7] << 8) + cdb[8];\r\ncmd->execute_cmd = spc_emulate_modeselect;\r\nbreak;\r\ncase MODE_SENSE:\r\n*size = cdb[4];\r\ncmd->execute_cmd = spc_emulate_modesense;\r\nbreak;\r\ncase MODE_SENSE_10:\r\n*size = (cdb[7] << 8) + cdb[8];\r\ncmd->execute_cmd = spc_emulate_modesense;\r\nbreak;\r\ncase LOG_SELECT:\r\ncase LOG_SENSE:\r\n*size = (cdb[7] << 8) + cdb[8];\r\nbreak;\r\ncase PERSISTENT_RESERVE_IN:\r\n*size = (cdb[7] << 8) + cdb[8];\r\ncmd->execute_cmd = target_scsi3_emulate_pr_in;\r\nbreak;\r\ncase PERSISTENT_RESERVE_OUT:\r\n*size = (cdb[7] << 8) + cdb[8];\r\ncmd->execute_cmd = target_scsi3_emulate_pr_out;\r\nbreak;\r\ncase RELEASE:\r\ncase RELEASE_10:\r\nif (cdb[0] == RELEASE_10)\r\n*size = (cdb[7] << 8) | cdb[8];\r\nelse\r\n*size = cmd->data_length;\r\ncmd->execute_cmd = target_scsi2_reservation_release;\r\nbreak;\r\ncase RESERVE:\r\ncase RESERVE_10:\r\nif (cdb[0] == RESERVE_10)\r\n*size = (cdb[7] << 8) | cdb[8];\r\nelse\r\n*size = cmd->data_length;\r\ncmd->execute_cmd = target_scsi2_reservation_reserve;\r\nbreak;\r\ncase REQUEST_SENSE:\r\n*size = cdb[4];\r\ncmd->execute_cmd = spc_emulate_request_sense;\r\nbreak;\r\ncase INQUIRY:\r\n*size = (cdb[3] << 8) + cdb[4];\r\ncmd->sam_task_attr = TCM_HEAD_TAG;\r\ncmd->execute_cmd = spc_emulate_inquiry;\r\nbreak;\r\ncase SECURITY_PROTOCOL_IN:\r\ncase SECURITY_PROTOCOL_OUT:\r\n*size = (cdb[6] << 24) | (cdb[7] << 16) | (cdb[8] << 8) | cdb[9];\r\nbreak;\r\ncase EXTENDED_COPY:\r\n*size = get_unaligned_be32(&cdb[10]);\r\ncmd->execute_cmd = target_do_xcopy;\r\nbreak;\r\ncase RECEIVE_COPY_RESULTS:\r\n*size = get_unaligned_be32(&cdb[10]);\r\ncmd->execute_cmd = target_do_receive_copy_results;\r\nbreak;\r\ncase READ_ATTRIBUTE:\r\ncase WRITE_ATTRIBUTE:\r\n*size = (cdb[10] << 24) | (cdb[11] << 16) |\r\n(cdb[12] << 8) | cdb[13];\r\nbreak;\r\ncase RECEIVE_DIAGNOSTIC:\r\ncase SEND_DIAGNOSTIC:\r\n*size = (cdb[3] << 8) | cdb[4];\r\nbreak;\r\ncase WRITE_BUFFER:\r\n*size = (cdb[6] << 16) + (cdb[7] << 8) + cdb[8];\r\nbreak;\r\ncase REPORT_LUNS:\r\ncmd->execute_cmd = spc_emulate_report_luns;\r\n*size = (cdb[6] << 24) | (cdb[7] << 16) | (cdb[8] << 8) | cdb[9];\r\ncmd->sam_task_attr = TCM_HEAD_TAG;\r\nbreak;\r\ncase TEST_UNIT_READY:\r\ncmd->execute_cmd = spc_emulate_testunitready;\r\n*size = 0;\r\nbreak;\r\ncase MAINTENANCE_IN:\r\nif (dev->transport->get_device_type(dev) != TYPE_ROM) {\r\nif ((cdb[1] & 0x1f) == MI_REPORT_TARGET_PGS) {\r\ncmd->execute_cmd =\r\ntarget_emulate_report_target_port_groups;\r\n}\r\n*size = get_unaligned_be32(&cdb[6]);\r\n} else {\r\n*size = get_unaligned_be16(&cdb[8]);\r\n}\r\nbreak;\r\ncase MAINTENANCE_OUT:\r\nif (dev->transport->get_device_type(dev) != TYPE_ROM) {\r\nif (cdb[1] == MO_SET_TARGET_PGS) {\r\ncmd->execute_cmd =\r\ntarget_emulate_set_target_port_groups;\r\n}\r\n*size = get_unaligned_be32(&cdb[6]);\r\n} else {\r\n*size = get_unaligned_be16(&cdb[8]);\r\n}\r\nbreak;\r\ndefault:\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\n}\r\nreturn 0;\r\n}
