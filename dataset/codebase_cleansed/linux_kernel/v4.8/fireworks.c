static int\r\nget_hardware_info(struct snd_efw *efw)\r\n{\r\nstruct fw_device *fw_dev = fw_parent_device(efw->unit);\r\nstruct snd_efw_hwinfo *hwinfo;\r\nchar version[12] = {0};\r\nint err;\r\nhwinfo = kzalloc(sizeof(struct snd_efw_hwinfo), GFP_KERNEL);\r\nif (hwinfo == NULL)\r\nreturn -ENOMEM;\r\nerr = snd_efw_command_get_hwinfo(efw, hwinfo);\r\nif (err < 0)\r\ngoto end;\r\nsnprintf(version, sizeof(version), "%u.%u",\r\n(hwinfo->arm_version >> 24) & 0xff,\r\n(hwinfo->arm_version >> 16) & 0xff);\r\nefw->firmware_version = hwinfo->arm_version;\r\nstrcpy(efw->card->driver, "Fireworks");\r\nstrcpy(efw->card->shortname, hwinfo->model_name);\r\nstrcpy(efw->card->mixername, hwinfo->model_name);\r\nsnprintf(efw->card->longname, sizeof(efw->card->longname),\r\n"%s %s v%s, GUID %08x%08x at %s, S%d",\r\nhwinfo->vendor_name, hwinfo->model_name, version,\r\nhwinfo->guid_hi, hwinfo->guid_lo,\r\ndev_name(&efw->unit->device), 100 << fw_dev->max_speed);\r\nif (hwinfo->flags & BIT(FLAG_RESP_ADDR_CHANGABLE))\r\nefw->resp_addr_changable = true;\r\nefw->supported_sampling_rate = 0;\r\nif ((hwinfo->min_sample_rate <= 22050)\r\n&& (22050 <= hwinfo->max_sample_rate))\r\nefw->supported_sampling_rate |= SNDRV_PCM_RATE_22050;\r\nif ((hwinfo->min_sample_rate <= 32000)\r\n&& (32000 <= hwinfo->max_sample_rate))\r\nefw->supported_sampling_rate |= SNDRV_PCM_RATE_32000;\r\nif ((hwinfo->min_sample_rate <= 44100)\r\n&& (44100 <= hwinfo->max_sample_rate))\r\nefw->supported_sampling_rate |= SNDRV_PCM_RATE_44100;\r\nif ((hwinfo->min_sample_rate <= 48000)\r\n&& (48000 <= hwinfo->max_sample_rate))\r\nefw->supported_sampling_rate |= SNDRV_PCM_RATE_48000;\r\nif ((hwinfo->min_sample_rate <= 88200)\r\n&& (88200 <= hwinfo->max_sample_rate))\r\nefw->supported_sampling_rate |= SNDRV_PCM_RATE_88200;\r\nif ((hwinfo->min_sample_rate <= 96000)\r\n&& (96000 <= hwinfo->max_sample_rate))\r\nefw->supported_sampling_rate |= SNDRV_PCM_RATE_96000;\r\nif ((hwinfo->min_sample_rate <= 176400)\r\n&& (176400 <= hwinfo->max_sample_rate))\r\nefw->supported_sampling_rate |= SNDRV_PCM_RATE_176400;\r\nif ((hwinfo->min_sample_rate <= 192000)\r\n&& (192000 <= hwinfo->max_sample_rate))\r\nefw->supported_sampling_rate |= SNDRV_PCM_RATE_192000;\r\nif (hwinfo->midi_out_ports > SND_EFW_MAX_MIDI_OUT_PORTS ||\r\nhwinfo->midi_in_ports > SND_EFW_MAX_MIDI_IN_PORTS) {\r\nerr = -EIO;\r\ngoto end;\r\n}\r\nefw->midi_out_ports = hwinfo->midi_out_ports;\r\nefw->midi_in_ports = hwinfo->midi_in_ports;\r\nif (hwinfo->amdtp_tx_pcm_channels > AM824_MAX_CHANNELS_FOR_PCM ||\r\nhwinfo->amdtp_tx_pcm_channels_2x > AM824_MAX_CHANNELS_FOR_PCM ||\r\nhwinfo->amdtp_tx_pcm_channels_4x > AM824_MAX_CHANNELS_FOR_PCM ||\r\nhwinfo->amdtp_rx_pcm_channels > AM824_MAX_CHANNELS_FOR_PCM ||\r\nhwinfo->amdtp_rx_pcm_channels_2x > AM824_MAX_CHANNELS_FOR_PCM ||\r\nhwinfo->amdtp_rx_pcm_channels_4x > AM824_MAX_CHANNELS_FOR_PCM) {\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\nefw->pcm_capture_channels[0] = hwinfo->amdtp_tx_pcm_channels;\r\nefw->pcm_capture_channels[1] = hwinfo->amdtp_tx_pcm_channels_2x;\r\nefw->pcm_capture_channels[2] = hwinfo->amdtp_tx_pcm_channels_4x;\r\nefw->pcm_playback_channels[0] = hwinfo->amdtp_rx_pcm_channels;\r\nefw->pcm_playback_channels[1] = hwinfo->amdtp_rx_pcm_channels_2x;\r\nefw->pcm_playback_channels[2] = hwinfo->amdtp_rx_pcm_channels_4x;\r\nif (hwinfo->phys_in_grp_count > HWINFO_MAX_CAPS_GROUPS ||\r\nhwinfo->phys_out_grp_count > HWINFO_MAX_CAPS_GROUPS) {\r\nerr = -EIO;\r\ngoto end;\r\n}\r\nefw->phys_in = hwinfo->phys_in;\r\nefw->phys_out = hwinfo->phys_out;\r\nefw->phys_in_grp_count = hwinfo->phys_in_grp_count;\r\nefw->phys_out_grp_count = hwinfo->phys_out_grp_count;\r\nmemcpy(&efw->phys_in_grps, hwinfo->phys_in_grps,\r\nsizeof(struct snd_efw_phys_grp) * hwinfo->phys_in_grp_count);\r\nmemcpy(&efw->phys_out_grps, hwinfo->phys_out_grps,\r\nsizeof(struct snd_efw_phys_grp) * hwinfo->phys_out_grp_count);\r\nif (hwinfo->type == MODEL_ECHO_AUDIOFIRE_9)\r\nefw->is_af9 = true;\r\nif (hwinfo->type == MODEL_ECHO_AUDIOFIRE_2 ||\r\nhwinfo->type == MODEL_ECHO_AUDIOFIRE_4 ||\r\nhwinfo->type == MODEL_ECHO_AUDIOFIRE_9 ||\r\nhwinfo->type == MODEL_GIBSON_RIP ||\r\nhwinfo->type == MODEL_GIBSON_GOLDTOP)\r\nefw->is_fireworks3 = true;\r\nend:\r\nkfree(hwinfo);\r\nreturn err;\r\n}\r\nstatic void efw_free(struct snd_efw *efw)\r\n{\r\nsnd_efw_stream_destroy_duplex(efw);\r\nsnd_efw_transaction_remove_instance(efw);\r\nfw_unit_put(efw->unit);\r\nkfree(efw->resp_buf);\r\nmutex_destroy(&efw->mutex);\r\nkfree(efw);\r\n}\r\nstatic void\r\nefw_card_free(struct snd_card *card)\r\n{\r\nstruct snd_efw *efw = card->private_data;\r\nif (efw->card_index >= 0) {\r\nmutex_lock(&devices_mutex);\r\nclear_bit(efw->card_index, devices_used);\r\nmutex_unlock(&devices_mutex);\r\n}\r\nefw_free(card->private_data);\r\n}\r\nstatic void\r\ndo_registration(struct work_struct *work)\r\n{\r\nstruct snd_efw *efw = container_of(work, struct snd_efw, dwork.work);\r\nunsigned int card_index;\r\nint err;\r\nif (efw->registered)\r\nreturn;\r\nmutex_lock(&devices_mutex);\r\nfor (card_index = 0; card_index < SNDRV_CARDS; ++card_index) {\r\nif (!test_bit(card_index, devices_used) && enable[card_index])\r\nbreak;\r\n}\r\nif (card_index >= SNDRV_CARDS) {\r\nmutex_unlock(&devices_mutex);\r\nreturn;\r\n}\r\nerr = snd_card_new(&efw->unit->device, index[card_index],\r\nid[card_index], THIS_MODULE, 0, &efw->card);\r\nif (err < 0) {\r\nmutex_unlock(&devices_mutex);\r\nreturn;\r\n}\r\nsnd_efw_resp_buf_size = clamp(snd_efw_resp_buf_size,\r\nSND_EFW_RESPONSE_MAXIMUM_BYTES, 4096U);\r\nefw->resp_buf = kzalloc(snd_efw_resp_buf_size, GFP_KERNEL);\r\nif (efw->resp_buf == NULL) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nefw->pull_ptr = efw->push_ptr = efw->resp_buf;\r\nsnd_efw_transaction_add_instance(efw);\r\nerr = get_hardware_info(efw);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_efw_stream_init_duplex(efw);\r\nif (err < 0)\r\ngoto error;\r\nsnd_efw_proc_init(efw);\r\nif (efw->midi_out_ports || efw->midi_in_ports) {\r\nerr = snd_efw_create_midi_devices(efw);\r\nif (err < 0)\r\ngoto error;\r\n}\r\nerr = snd_efw_create_pcm_devices(efw);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_efw_create_hwdep_device(efw);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(efw->card);\r\nif (err < 0)\r\ngoto error;\r\nset_bit(card_index, devices_used);\r\nmutex_unlock(&devices_mutex);\r\nefw->card->private_free = efw_card_free;\r\nefw->card->private_data = efw;\r\nefw->registered = true;\r\nreturn;\r\nerror:\r\nmutex_unlock(&devices_mutex);\r\nsnd_efw_transaction_remove_instance(efw);\r\nsnd_efw_stream_destroy_duplex(efw);\r\nsnd_card_free(efw->card);\r\ndev_info(&efw->unit->device,\r\n"Sound card registration failed: %d\n", err);\r\n}\r\nstatic int\r\nefw_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)\r\n{\r\nstruct snd_efw *efw;\r\nefw = kzalloc(sizeof(struct snd_efw), GFP_KERNEL);\r\nif (efw == NULL)\r\nreturn -ENOMEM;\r\nefw->unit = fw_unit_get(unit);\r\ndev_set_drvdata(&unit->device, efw);\r\nmutex_init(&efw->mutex);\r\nspin_lock_init(&efw->lock);\r\ninit_waitqueue_head(&efw->hwdep_wait);\r\nINIT_DEFERRABLE_WORK(&efw->dwork, do_registration);\r\nsnd_fw_schedule_registration(unit, &efw->dwork);\r\nreturn 0;\r\n}\r\nstatic void efw_update(struct fw_unit *unit)\r\n{\r\nstruct snd_efw *efw = dev_get_drvdata(&unit->device);\r\nif (!efw->registered)\r\nsnd_fw_schedule_registration(unit, &efw->dwork);\r\nsnd_efw_transaction_bus_reset(efw->unit);\r\nif (efw->registered) {\r\nmutex_lock(&efw->mutex);\r\nsnd_efw_stream_update_duplex(efw);\r\nmutex_unlock(&efw->mutex);\r\n}\r\n}\r\nstatic void efw_remove(struct fw_unit *unit)\r\n{\r\nstruct snd_efw *efw = dev_get_drvdata(&unit->device);\r\ncancel_delayed_work_sync(&efw->dwork);\r\nif (efw->registered) {\r\nsnd_card_free_when_closed(efw->card);\r\n} else {\r\nefw_free(efw);\r\n}\r\n}\r\nstatic int __init snd_efw_init(void)\r\n{\r\nint err;\r\nerr = snd_efw_transaction_register();\r\nif (err < 0)\r\ngoto end;\r\nerr = driver_register(&efw_driver.driver);\r\nif (err < 0)\r\nsnd_efw_transaction_unregister();\r\nend:\r\nreturn err;\r\n}\r\nstatic void __exit snd_efw_exit(void)\r\n{\r\nsnd_efw_transaction_unregister();\r\ndriver_unregister(&efw_driver.driver);\r\n}
