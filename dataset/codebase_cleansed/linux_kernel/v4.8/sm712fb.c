static void __init sm7xx_vga_setup(char *options)\r\n{\r\nint i;\r\nif (!options || !*options)\r\nreturn;\r\nsmtc_scr_info.lfb_width = 0;\r\nsmtc_scr_info.lfb_height = 0;\r\nsmtc_scr_info.lfb_depth = 0;\r\npr_debug("sm7xx_vga_setup = %s\n", options);\r\nfor (i = 0; i < ARRAY_SIZE(vesa_mode_table); i++) {\r\nif (strstr(options, vesa_mode_table[i].index)) {\r\nsmtc_scr_info.lfb_width = vesa_mode_table[i].lfb_width;\r\nsmtc_scr_info.lfb_height =\r\nvesa_mode_table[i].lfb_height;\r\nsmtc_scr_info.lfb_depth = vesa_mode_table[i].lfb_depth;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void sm712_setpalette(int regno, unsigned red, unsigned green,\r\nunsigned blue, struct fb_info *info)\r\n{\r\nsmtc_seqw(0x66, (smtc_seqr(0x66) & 0xC3) | 0x10);\r\nsmtc_mmiowb(regno, dac_reg);\r\nsmtc_mmiowb(red >> 10, dac_val);\r\nsmtc_mmiowb(green >> 10, dac_val);\r\nsmtc_mmiowb(blue >> 10, dac_val);\r\n}\r\nstatic inline unsigned int chan_to_field(unsigned int chan,\r\nstruct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int smtc_blank(int blank_mode, struct fb_info *info)\r\n{\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nsmtc_seqw(0x01, (smtc_seqr(0x01) & (~0x20)));\r\nsmtc_seqw(0x6a, 0x16);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x21, (smtc_seqr(0x21) & 0x77));\r\nsmtc_seqw(0x22, (smtc_seqr(0x22) & (~0x30)));\r\nsmtc_seqw(0x23, (smtc_seqr(0x23) & (~0xc0)));\r\nsmtc_seqw(0x24, (smtc_seqr(0x24) | 0x01));\r\nsmtc_seqw(0x31, (smtc_seqr(0x31) | 0x03));\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nsmtc_seqw(0x01, (smtc_seqr(0x01) & (~0x20)));\r\nsmtc_seqw(0x6a, 0x16);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x22, (smtc_seqr(0x22) & (~0x30)));\r\nsmtc_seqw(0x23, (smtc_seqr(0x23) & (~0xc0)));\r\nsmtc_seqw(0x24, (smtc_seqr(0x24) | 0x01));\r\nsmtc_seqw(0x31, ((smtc_seqr(0x31) & (~0x07)) | 0x00));\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nsmtc_seqw(0x01, (smtc_seqr(0x01) | 0x20));\r\nsmtc_seqw(0x20, (smtc_seqr(0x20) & (~0xB0)));\r\nsmtc_seqw(0x6a, 0x0c);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x21, (smtc_seqr(0x21) | 0x88));\r\nsmtc_seqw(0x22, ((smtc_seqr(0x22) & (~0x30)) | 0x20));\r\nsmtc_seqw(0x23, ((smtc_seqr(0x23) & (~0xc0)) | 0x20));\r\nsmtc_seqw(0x24, (smtc_seqr(0x24) & (~0x01)));\r\nsmtc_seqw(0x31, ((smtc_seqr(0x31) & (~0x07)) | 0x00));\r\nsmtc_seqw(0x34, (smtc_seqr(0x34) | 0x80));\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nsmtc_seqw(0x01, (smtc_seqr(0x01) | 0x20));\r\nsmtc_seqw(0x20, (smtc_seqr(0x20) & (~0xB0)));\r\nsmtc_seqw(0x6a, 0x0c);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x21, (smtc_seqr(0x21) | 0x88));\r\nsmtc_seqw(0x22, ((smtc_seqr(0x22) & (~0x30)) | 0x10));\r\nsmtc_seqw(0x23, ((smtc_seqr(0x23) & (~0xc0)) | 0xD8));\r\nsmtc_seqw(0x24, (smtc_seqr(0x24) & (~0x01)));\r\nsmtc_seqw(0x31, ((smtc_seqr(0x31) & (~0x07)) | 0x00));\r\nsmtc_seqw(0x34, (smtc_seqr(0x34) | 0x80));\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nsmtc_seqw(0x01, (smtc_seqr(0x01) | 0x20));\r\nsmtc_seqw(0x20, (smtc_seqr(0x20) & (~0xB0)));\r\nsmtc_seqw(0x6a, 0x0c);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x21, (smtc_seqr(0x21) | 0x88));\r\nsmtc_seqw(0x22, ((smtc_seqr(0x22) & (~0x30)) | 0x30));\r\nsmtc_seqw(0x23, ((smtc_seqr(0x23) & (~0xc0)) | 0xD8));\r\nsmtc_seqw(0x24, (smtc_seqr(0x24) & (~0x01)));\r\nsmtc_seqw(0x31, ((smtc_seqr(0x31) & (~0x07)) | 0x00));\r\nsmtc_seqw(0x34, (smtc_seqr(0x34) | 0x80));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smtc_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned trans, struct fb_info *info)\r\n{\r\nstruct smtcfb_info *sfb;\r\nu32 val;\r\nsfb = info->par;\r\nif (regno > 255)\r\nreturn 1;\r\nswitch (sfb->fb->fix.visual) {\r\ncase FB_VISUAL_DIRECTCOLOR:\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno >= 16)\r\nbreak;\r\nif (sfb->fb->var.bits_per_pixel == 16) {\r\nu32 *pal = sfb->fb->pseudo_palette;\r\nval = chan_to_field(red, &sfb->fb->var.red);\r\nval |= chan_to_field(green, &sfb->fb->var.green);\r\nval |= chan_to_field(blue, &sfb->fb->var.blue);\r\npal[regno] = pal_rgb(red, green, blue, val);\r\n} else {\r\nu32 *pal = sfb->fb->pseudo_palette;\r\nval = chan_to_field(red, &sfb->fb->var.red);\r\nval |= chan_to_field(green, &sfb->fb->var.green);\r\nval |= chan_to_field(blue, &sfb->fb->var.blue);\r\npal[regno] = big_swap(val);\r\n}\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nsm712_setpalette(regno, red, green, blue, info);\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t smtcfb_read(struct fb_info *info, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned long p = *ppos;\r\nu32 *buffer, *dst;\r\nu32 __iomem *src;\r\nint c, i, cnt = 0, err = 0;\r\nunsigned long total_size;\r\nif (!info || !info->screen_base)\r\nreturn -ENODEV;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn -EPERM;\r\ntotal_size = info->screen_size;\r\nif (total_size == 0)\r\ntotal_size = info->fix.smem_len;\r\nif (p >= total_size)\r\nreturn 0;\r\nif (count >= total_size)\r\ncount = total_size;\r\nif (count + p > total_size)\r\ncount = total_size - p;\r\nbuffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nsrc = (u32 __iomem *)(info->screen_base + p);\r\nif (info->fbops->fb_sync)\r\ninfo->fbops->fb_sync(info);\r\nwhile (count) {\r\nc = (count > PAGE_SIZE) ? PAGE_SIZE : count;\r\ndst = buffer;\r\nfor (i = c >> 2; i--;) {\r\n*dst = fb_readl(src++);\r\n*dst = big_swap(*dst);\r\ndst++;\r\n}\r\nif (c & 3) {\r\nu8 *dst8 = (u8 *)dst;\r\nu8 __iomem *src8 = (u8 __iomem *)src;\r\nfor (i = c & 3; i--;) {\r\nif (i & 1) {\r\n*dst8++ = fb_readb(++src8);\r\n} else {\r\n*dst8++ = fb_readb(--src8);\r\nsrc8 += 2;\r\n}\r\n}\r\nsrc = (u32 __iomem *)src8;\r\n}\r\nif (copy_to_user(buf, buffer, c)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\n*ppos += c;\r\nbuf += c;\r\ncnt += c;\r\ncount -= c;\r\n}\r\nkfree(buffer);\r\nreturn (err) ? err : cnt;\r\n}\r\nstatic ssize_t smtcfb_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned long p = *ppos;\r\nu32 *buffer, *src;\r\nu32 __iomem *dst;\r\nint c, i, cnt = 0, err = 0;\r\nunsigned long total_size;\r\nif (!info || !info->screen_base)\r\nreturn -ENODEV;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn -EPERM;\r\ntotal_size = info->screen_size;\r\nif (total_size == 0)\r\ntotal_size = info->fix.smem_len;\r\nif (p > total_size)\r\nreturn -EFBIG;\r\nif (count > total_size) {\r\nerr = -EFBIG;\r\ncount = total_size;\r\n}\r\nif (count + p > total_size) {\r\nif (!err)\r\nerr = -ENOSPC;\r\ncount = total_size - p;\r\n}\r\nbuffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\ndst = (u32 __iomem *)(info->screen_base + p);\r\nif (info->fbops->fb_sync)\r\ninfo->fbops->fb_sync(info);\r\nwhile (count) {\r\nc = (count > PAGE_SIZE) ? PAGE_SIZE : count;\r\nsrc = buffer;\r\nif (copy_from_user(src, buf, c)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nfor (i = c >> 2; i--;) {\r\nfb_writel(big_swap(*src), dst++);\r\nsrc++;\r\n}\r\nif (c & 3) {\r\nu8 *src8 = (u8 *)src;\r\nu8 __iomem *dst8 = (u8 __iomem *)dst;\r\nfor (i = c & 3; i--;) {\r\nif (i & 1) {\r\nfb_writeb(*src8++, ++dst8);\r\n} else {\r\nfb_writeb(*src8++, --dst8);\r\ndst8 += 2;\r\n}\r\n}\r\ndst = (u32 __iomem *)dst8;\r\n}\r\n*ppos += c;\r\nbuf += c;\r\ncnt += c;\r\ncount -= c;\r\n}\r\nkfree(buffer);\r\nreturn (cnt) ? cnt : err;\r\n}\r\nstatic void sm7xx_set_timing(struct smtcfb_info *sfb)\r\n{\r\nint i = 0, j = 0;\r\nu32 m_nscreenstride;\r\ndev_dbg(&sfb->pdev->dev,\r\n"sfb->width=%d sfb->height=%d sfb->fb->var.bits_per_pixel=%d sfb->hz=%d\n",\r\nsfb->width, sfb->height, sfb->fb->var.bits_per_pixel, sfb->hz);\r\nfor (j = 0; j < ARRAY_SIZE(vgamode); j++) {\r\nif (vgamode[j].mmsizex != sfb->width ||\r\nvgamode[j].mmsizey != sfb->height ||\r\nvgamode[j].bpp != sfb->fb->var.bits_per_pixel ||\r\nvgamode[j].hz != sfb->hz)\r\ncontinue;\r\ndev_dbg(&sfb->pdev->dev,\r\n"vgamode[j].mmsizex=%d vgamode[j].mmSizeY=%d vgamode[j].bpp=%d vgamode[j].hz=%d\n",\r\nvgamode[j].mmsizex, vgamode[j].mmsizey,\r\nvgamode[j].bpp, vgamode[j].hz);\r\ndev_dbg(&sfb->pdev->dev, "vgamode index=%d\n", j);\r\nsmtc_mmiowb(0x0, 0x3c6);\r\nsmtc_seqw(0, 0x1);\r\nsmtc_mmiowb(vgamode[j].init_misc, 0x3c2);\r\nfor (i = 0; i < SIZE_SR00_SR04; i++)\r\nsmtc_seqw(i, vgamode[j].init_sr00_sr04[i]);\r\nfor (i = 0; i < SIZE_SR10_SR24; i++)\r\nsmtc_seqw(i + 0x10, vgamode[j].init_sr10_sr24[i]);\r\nfor (i = 0; i < SIZE_SR30_SR75; i++)\r\nif ((i + 0x30) != 0x62 && (i + 0x30) != 0x6a &&\r\n(i + 0x30) != 0x6b)\r\nsmtc_seqw(i + 0x30,\r\nvgamode[j].init_sr30_sr75[i]);\r\nfor (i = 0; i < SIZE_SR80_SR93; i++)\r\nsmtc_seqw(i + 0x80, vgamode[j].init_sr80_sr93[i]);\r\nfor (i = 0; i < SIZE_SRA0_SRAF; i++)\r\nsmtc_seqw(i + 0xa0, vgamode[j].init_sra0_sraf[i]);\r\nfor (i = 0; i < SIZE_GR00_GR08; i++)\r\nsmtc_grphw(i, vgamode[j].init_gr00_gr08[i]);\r\nfor (i = 0; i < SIZE_AR00_AR14; i++)\r\nsmtc_attrw(i, vgamode[j].init_ar00_ar14[i]);\r\nfor (i = 0; i < SIZE_CR00_CR18; i++)\r\nsmtc_crtcw(i, vgamode[j].init_cr00_cr18[i]);\r\nfor (i = 0; i < SIZE_CR30_CR4D; i++)\r\nsmtc_crtcw(i + 0x30, vgamode[j].init_cr30_cr4d[i]);\r\nfor (i = 0; i < SIZE_CR90_CRA7; i++)\r\nsmtc_crtcw(i + 0x90, vgamode[j].init_cr90_cra7[i]);\r\n}\r\nsmtc_mmiowb(0x67, 0x3c2);\r\nwritel(0x0, sfb->vp_regs + 0x0C);\r\nwritel(0x0, sfb->vp_regs + 0x40);\r\nm_nscreenstride = (sfb->width * sfb->fb->var.bits_per_pixel) / 64;\r\nswitch (sfb->fb->var.bits_per_pixel) {\r\ncase 8:\r\nwritel(0x0, sfb->vp_regs + 0x0);\r\nbreak;\r\ncase 16:\r\nwritel(0x00020000, sfb->vp_regs + 0x0);\r\nbreak;\r\ncase 24:\r\nwritel(0x00040000, sfb->vp_regs + 0x0);\r\nbreak;\r\ncase 32:\r\nwritel(0x00030000, sfb->vp_regs + 0x0);\r\nbreak;\r\n}\r\nwritel((u32)(((m_nscreenstride + 2) << 16) | m_nscreenstride),\r\nsfb->vp_regs + 0x10);\r\n}\r\nstatic void smtc_set_timing(struct smtcfb_info *sfb)\r\n{\r\nswitch (sfb->chip_id) {\r\ncase 0x710:\r\ncase 0x712:\r\ncase 0x720:\r\nsm7xx_set_timing(sfb);\r\nbreak;\r\n}\r\n}\r\nstatic void smtcfb_setmode(struct smtcfb_info *sfb)\r\n{\r\nswitch (sfb->fb->var.bits_per_pixel) {\r\ncase 32:\r\nsfb->fb->fix.visual = FB_VISUAL_TRUECOLOR;\r\nsfb->fb->fix.line_length = sfb->fb->var.xres * 4;\r\nsfb->fb->var.red.length = 8;\r\nsfb->fb->var.green.length = 8;\r\nsfb->fb->var.blue.length = 8;\r\nsfb->fb->var.red.offset = 16;\r\nsfb->fb->var.green.offset = 8;\r\nsfb->fb->var.blue.offset = 0;\r\nbreak;\r\ncase 24:\r\nsfb->fb->fix.visual = FB_VISUAL_TRUECOLOR;\r\nsfb->fb->fix.line_length = sfb->fb->var.xres * 3;\r\nsfb->fb->var.red.length = 8;\r\nsfb->fb->var.green.length = 8;\r\nsfb->fb->var.blue.length = 8;\r\nsfb->fb->var.red.offset = 16;\r\nsfb->fb->var.green.offset = 8;\r\nsfb->fb->var.blue.offset = 0;\r\nbreak;\r\ncase 8:\r\nsfb->fb->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nsfb->fb->fix.line_length = sfb->fb->var.xres;\r\nsfb->fb->var.red.length = 3;\r\nsfb->fb->var.green.length = 3;\r\nsfb->fb->var.blue.length = 2;\r\nsfb->fb->var.red.offset = 5;\r\nsfb->fb->var.green.offset = 2;\r\nsfb->fb->var.blue.offset = 0;\r\nbreak;\r\ncase 16:\r\ndefault:\r\nsfb->fb->fix.visual = FB_VISUAL_TRUECOLOR;\r\nsfb->fb->fix.line_length = sfb->fb->var.xres * 2;\r\nsfb->fb->var.red.length = 5;\r\nsfb->fb->var.green.length = 6;\r\nsfb->fb->var.blue.length = 5;\r\nsfb->fb->var.red.offset = 11;\r\nsfb->fb->var.green.offset = 5;\r\nsfb->fb->var.blue.offset = 0;\r\nbreak;\r\n}\r\nsfb->width = sfb->fb->var.xres;\r\nsfb->height = sfb->fb->var.yres;\r\nsfb->hz = 60;\r\nsmtc_set_timing(sfb);\r\n}\r\nstatic int smtc_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif ((var->bits_per_pixel != 8) && (var->bits_per_pixel != 16) &&\r\n(var->bits_per_pixel != 24) && (var->bits_per_pixel != 32))\r\nvar->bits_per_pixel = 16;\r\nreturn 0;\r\n}\r\nstatic int smtc_set_par(struct fb_info *info)\r\n{\r\nsmtcfb_setmode(info->par);\r\nreturn 0;\r\n}\r\nstatic void smtc_unmap_mmio(struct smtcfb_info *sfb)\r\n{\r\nif (sfb && smtc_regbaseaddress)\r\nsmtc_regbaseaddress = NULL;\r\n}\r\nstatic int smtc_map_smem(struct smtcfb_info *sfb,\r\nstruct pci_dev *pdev, u_long smem_len)\r\n{\r\nsfb->fb->fix.smem_start = pci_resource_start(pdev, 0);\r\nif (sfb->fb->var.bits_per_pixel == 32)\r\nsfb->fb->fix.smem_start += big_addr;\r\nsfb->fb->fix.smem_len = smem_len;\r\nsfb->fb->screen_base = sfb->lfb;\r\nif (!sfb->fb->screen_base) {\r\ndev_err(&pdev->dev,\r\n"%s: unable to map screen memory\n", sfb->fb->fix.id);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void smtc_unmap_smem(struct smtcfb_info *sfb)\r\n{\r\nif (sfb && sfb->fb->screen_base) {\r\niounmap(sfb->fb->screen_base);\r\nsfb->fb->screen_base = NULL;\r\n}\r\n}\r\nstatic inline void sm7xx_init_hw(void)\r\n{\r\noutb_p(0x18, 0x3c4);\r\noutb_p(0x11, 0x3c5);\r\n}\r\nstatic int smtcfb_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct smtcfb_info *sfb;\r\nstruct fb_info *info;\r\nu_long smem_size = 0x00800000;\r\nint err;\r\nunsigned long mmio_base;\r\ndev_info(&pdev->dev, "Silicon Motion display driver.\n");\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\nerr = pci_request_region(pdev, 0, "sm7xxfb");\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "cannot reserve framebuffer region\n");\r\ngoto failed_regions;\r\n}\r\nsprintf(smtcfb_fix.id, "sm%Xfb", ent->device);\r\ninfo = framebuffer_alloc(sizeof(*sfb), &pdev->dev);\r\nif (!info) {\r\ndev_err(&pdev->dev, "framebuffer_alloc failed\n");\r\nerr = -ENOMEM;\r\ngoto failed_free;\r\n}\r\nsfb = info->par;\r\nsfb->fb = info;\r\nsfb->chip_id = ent->device;\r\nsfb->pdev = pdev;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\ninfo->fbops = &smtcfb_ops;\r\ninfo->fix = smtcfb_fix;\r\ninfo->var = smtcfb_var;\r\ninfo->pseudo_palette = sfb->colreg;\r\ninfo->par = sfb;\r\npci_set_drvdata(pdev, sfb);\r\nsm7xx_init_hw();\r\nif (smtc_scr_info.lfb_width != 0) {\r\nsfb->fb->var.xres = smtc_scr_info.lfb_width;\r\nsfb->fb->var.yres = smtc_scr_info.lfb_height;\r\nsfb->fb->var.bits_per_pixel = smtc_scr_info.lfb_depth;\r\n} else {\r\nsfb->fb->var.xres = SCREEN_X_RES;\r\nsfb->fb->var.yres = SCREEN_Y_RES;\r\nsfb->fb->var.bits_per_pixel = SCREEN_BPP;\r\n}\r\nbig_pixel_depth(sfb->fb->var.bits_per_pixel, smtc_scr_info.lfb_depth);\r\nmmio_base = pci_resource_start(pdev, 0);\r\npci_read_config_byte(pdev, PCI_REVISION_ID, &sfb->chip_rev_id);\r\nswitch (sfb->chip_id) {\r\ncase 0x710:\r\ncase 0x712:\r\nsfb->fb->fix.mmio_start = mmio_base + 0x00400000;\r\nsfb->fb->fix.mmio_len = 0x00400000;\r\nsmem_size = SM712_VIDEOMEMORYSIZE;\r\nsfb->lfb = ioremap(mmio_base, mmio_addr);\r\nif (!sfb->lfb) {\r\ndev_err(&pdev->dev,\r\n"%s: unable to map memory mapped IO!\n",\r\nsfb->fb->fix.id);\r\nerr = -ENOMEM;\r\ngoto failed_fb;\r\n}\r\nsfb->mmio = (smtc_regbaseaddress =\r\nsfb->lfb + 0x00700000);\r\nsfb->dp_regs = sfb->lfb + 0x00408000;\r\nsfb->vp_regs = sfb->lfb + 0x0040c000;\r\nif (sfb->fb->var.bits_per_pixel == 32) {\r\nsfb->lfb += big_addr;\r\ndev_info(&pdev->dev, "sfb->lfb=%p\n", sfb->lfb);\r\n}\r\nsmtc_seqw(0x6a, 0x16);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x62, 0x3e);\r\nsmtc_seqw(0x17, 0x20);\r\nif (sfb->fb->var.bits_per_pixel == 32)\r\nseqw17();\r\nbreak;\r\ncase 0x720:\r\nsfb->fb->fix.mmio_start = mmio_base;\r\nsfb->fb->fix.mmio_len = 0x00200000;\r\nsmem_size = SM722_VIDEOMEMORYSIZE;\r\nsfb->dp_regs = ioremap(mmio_base, 0x00a00000);\r\nsfb->lfb = sfb->dp_regs + 0x00200000;\r\nsfb->mmio = (smtc_regbaseaddress =\r\nsfb->dp_regs + 0x000c0000);\r\nsfb->vp_regs = sfb->dp_regs + 0x800;\r\nsmtc_seqw(0x62, 0xff);\r\nsmtc_seqw(0x6a, 0x0d);\r\nsmtc_seqw(0x6b, 0x02);\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev,\r\n"No valid Silicon Motion display chip was detected!\n");\r\ngoto failed_fb;\r\n}\r\nif (15 == sfb->fb->var.bits_per_pixel)\r\nsfb->fb->var.bits_per_pixel = 16;\r\nsfb->fb->var.xres_virtual = sfb->fb->var.xres;\r\nsfb->fb->var.yres_virtual = sfb->fb->var.yres;\r\nerr = smtc_map_smem(sfb, pdev, smem_size);\r\nif (err)\r\ngoto failed;\r\nsmtcfb_setmode(sfb);\r\nerr = register_framebuffer(info);\r\nif (err < 0)\r\ngoto failed;\r\ndev_info(&pdev->dev,\r\n"Silicon Motion SM%X Rev%X primary display mode %dx%d-%d Init Complete.\n",\r\nsfb->chip_id, sfb->chip_rev_id, sfb->fb->var.xres,\r\nsfb->fb->var.yres, sfb->fb->var.bits_per_pixel);\r\nreturn 0;\r\nfailed:\r\ndev_err(&pdev->dev, "Silicon Motion, Inc. primary display init fail.\n");\r\nsmtc_unmap_smem(sfb);\r\nsmtc_unmap_mmio(sfb);\r\nfailed_fb:\r\nframebuffer_release(info);\r\nfailed_free:\r\npci_release_region(pdev, 0);\r\nfailed_regions:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void smtcfb_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct smtcfb_info *sfb;\r\nsfb = pci_get_drvdata(pdev);\r\nsmtc_unmap_smem(sfb);\r\nsmtc_unmap_mmio(sfb);\r\nunregister_framebuffer(sfb->fb);\r\nframebuffer_release(sfb->fb);\r\npci_release_region(pdev, 0);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __maybe_unused smtcfb_pci_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct smtcfb_info *sfb;\r\nsfb = pci_get_drvdata(pdev);\r\nsmtc_seqw(0x20, (smtc_seqr(0x20) | 0xc0));\r\nsmtc_seqw(0x69, (smtc_seqr(0x69) & 0xf7));\r\nconsole_lock();\r\nfb_set_suspend(sfb->fb, 1);\r\nconsole_unlock();\r\nsmtc_seqw(0x21, 0xff);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused smtcfb_pci_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct smtcfb_info *sfb;\r\nsfb = pci_get_drvdata(pdev);\r\nsm7xx_init_hw();\r\nswitch (sfb->chip_id) {\r\ncase 0x710:\r\ncase 0x712:\r\nsmtc_seqw(0x6a, 0x16);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x62, 0x3e);\r\nsmtc_seqw(0x17, 0x20);\r\nif (sfb->fb->var.bits_per_pixel == 32)\r\nseqw17();\r\nbreak;\r\ncase 0x720:\r\nsmtc_seqw(0x62, 0xff);\r\nsmtc_seqw(0x6a, 0x0d);\r\nsmtc_seqw(0x6b, 0x02);\r\nbreak;\r\n}\r\nsmtc_seqw(0x34, (smtc_seqr(0x34) | 0xc0));\r\nsmtc_seqw(0x33, ((smtc_seqr(0x33) | 0x08) & 0xfb));\r\nsmtcfb_setmode(sfb);\r\nconsole_lock();\r\nfb_set_suspend(sfb->fb, 0);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int __init sm712fb_init(void)\r\n{\r\nchar *option = NULL;\r\nif (fb_get_options("sm712fb", &option))\r\nreturn -ENODEV;\r\nif (option && *option)\r\nmode_option = option;\r\nsm7xx_vga_setup(mode_option);\r\nreturn pci_register_driver(&smtcfb_driver);\r\n}\r\nstatic void __exit sm712fb_exit(void)\r\n{\r\npci_unregister_driver(&smtcfb_driver);\r\n}
