static unsigned int mpls_encap_size(struct mpls_iptunnel_encap *en)\r\n{\r\nreturn en->labels * sizeof(struct mpls_shim_hdr);\r\n}\r\nstatic int mpls_output(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct mpls_iptunnel_encap *tun_encap_info;\r\nstruct mpls_shim_hdr *hdr;\r\nstruct net_device *out_dev;\r\nunsigned int hh_len;\r\nunsigned int new_header_size;\r\nunsigned int mtu;\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct rtable *rt = NULL;\r\nstruct rt6_info *rt6 = NULL;\r\nint err = 0;\r\nbool bos;\r\nint i;\r\nunsigned int ttl;\r\nif (dst->ops->family == AF_INET) {\r\nttl = ip_hdr(skb)->ttl;\r\nrt = (struct rtable *)dst;\r\n} else if (dst->ops->family == AF_INET6) {\r\nttl = ipv6_hdr(skb)->hop_limit;\r\nrt6 = (struct rt6_info *)dst;\r\n} else {\r\ngoto drop;\r\n}\r\nskb_orphan(skb);\r\nout_dev = dst->dev;\r\nif (!mpls_output_possible(out_dev) ||\r\n!dst->lwtstate || skb_warn_if_lro(skb))\r\ngoto drop;\r\nskb_forward_csum(skb);\r\ntun_encap_info = mpls_lwtunnel_encap(dst->lwtstate);\r\nnew_header_size = mpls_encap_size(tun_encap_info);\r\nmtu = mpls_dev_mtu(out_dev);\r\nif (mpls_pkt_too_big(skb, mtu - new_header_size))\r\ngoto drop;\r\nhh_len = LL_RESERVED_SPACE(out_dev);\r\nif (!out_dev->header_ops)\r\nhh_len = 0;\r\nif (skb_cow(skb, hh_len + new_header_size))\r\ngoto drop;\r\nskb_push(skb, new_header_size);\r\nskb_reset_network_header(skb);\r\nskb->dev = out_dev;\r\nskb->protocol = htons(ETH_P_MPLS_UC);\r\nhdr = mpls_hdr(skb);\r\nbos = true;\r\nfor (i = tun_encap_info->labels - 1; i >= 0; i--) {\r\nhdr[i] = mpls_entry_encode(tun_encap_info->label[i],\r\nttl, 0, bos);\r\nbos = false;\r\n}\r\nif (rt)\r\nerr = neigh_xmit(NEIGH_ARP_TABLE, out_dev, &rt->rt_gateway,\r\nskb);\r\nelse if (rt6)\r\nerr = neigh_xmit(NEIGH_ND_TABLE, out_dev, &rt6->rt6i_gateway,\r\nskb);\r\nif (err)\r\nnet_dbg_ratelimited("%s: packet transmission failed: %d\n",\r\n__func__, err);\r\nreturn 0;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nstatic int mpls_build_state(struct net_device *dev, struct nlattr *nla,\r\nunsigned int family, const void *cfg,\r\nstruct lwtunnel_state **ts)\r\n{\r\nstruct mpls_iptunnel_encap *tun_encap_info;\r\nstruct nlattr *tb[MPLS_IPTUNNEL_MAX + 1];\r\nstruct lwtunnel_state *newts;\r\nint tun_encap_info_len;\r\nint ret;\r\nret = nla_parse_nested(tb, MPLS_IPTUNNEL_MAX, nla,\r\nmpls_iptunnel_policy);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!tb[MPLS_IPTUNNEL_DST])\r\nreturn -EINVAL;\r\ntun_encap_info_len = sizeof(*tun_encap_info);\r\nnewts = lwtunnel_state_alloc(tun_encap_info_len);\r\nif (!newts)\r\nreturn -ENOMEM;\r\nnewts->len = tun_encap_info_len;\r\ntun_encap_info = mpls_lwtunnel_encap(newts);\r\nret = nla_get_labels(tb[MPLS_IPTUNNEL_DST], MAX_NEW_LABELS,\r\n&tun_encap_info->labels, tun_encap_info->label);\r\nif (ret)\r\ngoto errout;\r\nnewts->type = LWTUNNEL_ENCAP_MPLS;\r\nnewts->flags |= LWTUNNEL_STATE_OUTPUT_REDIRECT;\r\n*ts = newts;\r\nreturn 0;\r\nerrout:\r\nkfree(newts);\r\n*ts = NULL;\r\nreturn ret;\r\n}\r\nstatic int mpls_fill_encap_info(struct sk_buff *skb,\r\nstruct lwtunnel_state *lwtstate)\r\n{\r\nstruct mpls_iptunnel_encap *tun_encap_info;\r\ntun_encap_info = mpls_lwtunnel_encap(lwtstate);\r\nif (nla_put_labels(skb, MPLS_IPTUNNEL_DST, tun_encap_info->labels,\r\ntun_encap_info->label))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int mpls_encap_nlsize(struct lwtunnel_state *lwtstate)\r\n{\r\nstruct mpls_iptunnel_encap *tun_encap_info;\r\ntun_encap_info = mpls_lwtunnel_encap(lwtstate);\r\nreturn nla_total_size(tun_encap_info->labels * 4);\r\n}\r\nstatic int mpls_encap_cmp(struct lwtunnel_state *a, struct lwtunnel_state *b)\r\n{\r\nstruct mpls_iptunnel_encap *a_hdr = mpls_lwtunnel_encap(a);\r\nstruct mpls_iptunnel_encap *b_hdr = mpls_lwtunnel_encap(b);\r\nint l;\r\nif (a_hdr->labels != b_hdr->labels)\r\nreturn 1;\r\nfor (l = 0; l < MAX_NEW_LABELS; l++)\r\nif (a_hdr->label[l] != b_hdr->label[l])\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init mpls_iptunnel_init(void)\r\n{\r\nreturn lwtunnel_encap_add_ops(&mpls_iptun_ops, LWTUNNEL_ENCAP_MPLS);\r\n}\r\nstatic void __exit mpls_iptunnel_exit(void)\r\n{\r\nlwtunnel_encap_del_ops(&mpls_iptun_ops, LWTUNNEL_ENCAP_MPLS);\r\n}
