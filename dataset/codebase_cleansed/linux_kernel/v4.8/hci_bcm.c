static int bcm_set_baudrate(struct hci_uart *hu, unsigned int speed)\r\n{\r\nstruct hci_dev *hdev = hu->hdev;\r\nstruct sk_buff *skb;\r\nstruct bcm_update_uart_baud_rate param;\r\nif (speed > 3000000) {\r\nstruct bcm_write_uart_clock_setting clock;\r\nclock.type = BCM_UART_CLOCK_48MHZ;\r\nbt_dev_dbg(hdev, "Set Controller clock (%d)", clock.type);\r\nskb = __hci_cmd_sync(hdev, 0xfc45, 1, &clock, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nint err = PTR_ERR(skb);\r\nbt_dev_err(hdev, "BCM: failed to write clock (%d)",\r\nerr);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\n}\r\nbt_dev_dbg(hdev, "Set Controller UART speed to %d bit/s", speed);\r\nparam.zero = cpu_to_le16(0);\r\nparam.baud_rate = cpu_to_le32(speed);\r\nskb = __hci_cmd_sync(hdev, 0xfc18, sizeof(param), &param,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nint err = PTR_ERR(skb);\r\nbt_dev_err(hdev, "BCM: failed to write update baudrate (%d)",\r\nerr);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic bool bcm_device_exists(struct bcm_device *device)\r\n{\r\nstruct list_head *p;\r\nlist_for_each(p, &bcm_device_list) {\r\nstruct bcm_device *dev = list_entry(p, struct bcm_device, list);\r\nif (device == dev)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int bcm_gpio_set_power(struct bcm_device *dev, bool powered)\r\n{\r\nif (powered && !IS_ERR(dev->clk) && !dev->clk_enabled)\r\nclk_enable(dev->clk);\r\ngpiod_set_value(dev->shutdown, powered);\r\ngpiod_set_value(dev->device_wakeup, powered);\r\nif (!powered && !IS_ERR(dev->clk) && dev->clk_enabled)\r\nclk_disable(dev->clk);\r\ndev->clk_enabled = powered;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bcm_host_wake(int irq, void *data)\r\n{\r\nstruct bcm_device *bdev = data;\r\nbt_dev_dbg(bdev, "Host wake IRQ");\r\npm_runtime_get(&bdev->pdev->dev);\r\npm_runtime_mark_last_busy(&bdev->pdev->dev);\r\npm_runtime_put_autosuspend(&bdev->pdev->dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm_request_irq(struct bcm_data *bcm)\r\n{\r\nstruct bcm_device *bdev = bcm->dev;\r\nint err = 0;\r\nmutex_lock(&bcm_device_lock);\r\nif (!bcm_device_exists(bdev)) {\r\nerr = -ENODEV;\r\ngoto unlock;\r\n}\r\nif (bdev->irq > 0) {\r\nerr = devm_request_irq(&bdev->pdev->dev, bdev->irq,\r\nbcm_host_wake, IRQF_TRIGGER_RISING,\r\n"host_wake", bdev);\r\nif (err)\r\ngoto unlock;\r\ndevice_init_wakeup(&bdev->pdev->dev, true);\r\npm_runtime_set_autosuspend_delay(&bdev->pdev->dev,\r\nBCM_AUTOSUSPEND_DELAY);\r\npm_runtime_use_autosuspend(&bdev->pdev->dev);\r\npm_runtime_set_active(&bdev->pdev->dev);\r\npm_runtime_enable(&bdev->pdev->dev);\r\n}\r\nunlock:\r\nmutex_unlock(&bcm_device_lock);\r\nreturn err;\r\n}\r\nstatic int bcm_setup_sleep(struct hci_uart *hu)\r\n{\r\nstruct bcm_data *bcm = hu->priv;\r\nstruct sk_buff *skb;\r\nstruct bcm_set_sleep_mode sleep_params = default_sleep_params;\r\nsleep_params.host_wake_active = !bcm->dev->irq_polarity;\r\nskb = __hci_cmd_sync(hu->hdev, 0xfc27, sizeof(sleep_params),\r\n&sleep_params, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nint err = PTR_ERR(skb);\r\nbt_dev_err(hu->hdev, "Sleep VSC failed (%d)", err);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\nbt_dev_dbg(hu->hdev, "Set Sleep Parameters VSC succeeded");\r\nreturn 0;\r\n}\r\nstatic inline int bcm_request_irq(struct bcm_data *bcm) { return 0; }\r\nstatic inline int bcm_setup_sleep(struct hci_uart *hu) { return 0; }\r\nstatic int bcm_set_diag(struct hci_dev *hdev, bool enable)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct bcm_data *bcm = hu->priv;\r\nstruct sk_buff *skb;\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -ENETDOWN;\r\nskb = bt_skb_alloc(3, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\n*skb_put(skb, 1) = BCM_LM_DIAG_PKT;\r\n*skb_put(skb, 1) = 0xf0;\r\n*skb_put(skb, 1) = enable;\r\nskb_queue_tail(&bcm->txq, skb);\r\nhci_uart_tx_wakeup(hu);\r\nreturn 0;\r\n}\r\nstatic int bcm_open(struct hci_uart *hu)\r\n{\r\nstruct bcm_data *bcm;\r\nstruct list_head *p;\r\nbt_dev_dbg(hu->hdev, "hu %p", hu);\r\nbcm = kzalloc(sizeof(*bcm), GFP_KERNEL);\r\nif (!bcm)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&bcm->txq);\r\nhu->priv = bcm;\r\nmutex_lock(&bcm_device_lock);\r\nlist_for_each(p, &bcm_device_list) {\r\nstruct bcm_device *dev = list_entry(p, struct bcm_device, list);\r\nif (hu->tty->dev->parent == dev->pdev->dev.parent) {\r\nbcm->dev = dev;\r\nhu->init_speed = dev->init_speed;\r\n#ifdef CONFIG_PM\r\ndev->hu = hu;\r\n#endif\r\nbcm_gpio_set_power(bcm->dev, true);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&bcm_device_lock);\r\nreturn 0;\r\n}\r\nstatic int bcm_close(struct hci_uart *hu)\r\n{\r\nstruct bcm_data *bcm = hu->priv;\r\nstruct bcm_device *bdev = bcm->dev;\r\nbt_dev_dbg(hu->hdev, "hu %p", hu);\r\nmutex_lock(&bcm_device_lock);\r\nif (bcm_device_exists(bdev)) {\r\nbcm_gpio_set_power(bdev, false);\r\n#ifdef CONFIG_PM\r\npm_runtime_disable(&bdev->pdev->dev);\r\npm_runtime_set_suspended(&bdev->pdev->dev);\r\nif (device_can_wakeup(&bdev->pdev->dev)) {\r\ndevm_free_irq(&bdev->pdev->dev, bdev->irq, bdev);\r\ndevice_init_wakeup(&bdev->pdev->dev, false);\r\n}\r\nbdev->hu = NULL;\r\n#endif\r\n}\r\nmutex_unlock(&bcm_device_lock);\r\nskb_queue_purge(&bcm->txq);\r\nkfree_skb(bcm->rx_skb);\r\nkfree(bcm);\r\nhu->priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int bcm_flush(struct hci_uart *hu)\r\n{\r\nstruct bcm_data *bcm = hu->priv;\r\nbt_dev_dbg(hu->hdev, "hu %p", hu);\r\nskb_queue_purge(&bcm->txq);\r\nreturn 0;\r\n}\r\nstatic int bcm_setup(struct hci_uart *hu)\r\n{\r\nstruct bcm_data *bcm = hu->priv;\r\nchar fw_name[64];\r\nconst struct firmware *fw;\r\nunsigned int speed;\r\nint err;\r\nbt_dev_dbg(hu->hdev, "hu %p", hu);\r\nhu->hdev->set_diag = bcm_set_diag;\r\nhu->hdev->set_bdaddr = btbcm_set_bdaddr;\r\nerr = btbcm_initialize(hu->hdev, fw_name, sizeof(fw_name));\r\nif (err)\r\nreturn err;\r\nerr = request_firmware(&fw, fw_name, &hu->hdev->dev);\r\nif (err < 0) {\r\nbt_dev_info(hu->hdev, "BCM: Patch %s not found", fw_name);\r\nreturn 0;\r\n}\r\nerr = btbcm_patchram(hu->hdev, fw);\r\nif (err) {\r\nbt_dev_info(hu->hdev, "BCM: Patch failed (%d)", err);\r\ngoto finalize;\r\n}\r\nif (hu->init_speed)\r\nspeed = hu->init_speed;\r\nelse if (hu->proto->init_speed)\r\nspeed = hu->proto->init_speed;\r\nelse\r\nspeed = 0;\r\nif (speed)\r\nhci_uart_set_baudrate(hu, speed);\r\nif (hu->oper_speed)\r\nspeed = hu->oper_speed;\r\nelse if (hu->proto->oper_speed)\r\nspeed = hu->proto->oper_speed;\r\nelse\r\nspeed = 0;\r\nif (speed) {\r\nerr = bcm_set_baudrate(hu, speed);\r\nif (!err)\r\nhci_uart_set_baudrate(hu, speed);\r\n}\r\nfinalize:\r\nrelease_firmware(fw);\r\nerr = btbcm_finalize(hu->hdev);\r\nif (err)\r\nreturn err;\r\nerr = bcm_request_irq(bcm);\r\nif (!err)\r\nerr = bcm_setup_sleep(hu);\r\nreturn err;\r\n}\r\nstatic int bcm_recv(struct hci_uart *hu, const void *data, int count)\r\n{\r\nstruct bcm_data *bcm = hu->priv;\r\nif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\r\nreturn -EUNATCH;\r\nbcm->rx_skb = h4_recv_buf(hu->hdev, bcm->rx_skb, data, count,\r\nbcm_recv_pkts, ARRAY_SIZE(bcm_recv_pkts));\r\nif (IS_ERR(bcm->rx_skb)) {\r\nint err = PTR_ERR(bcm->rx_skb);\r\nbt_dev_err(hu->hdev, "Frame reassembly failed (%d)", err);\r\nbcm->rx_skb = NULL;\r\nreturn err;\r\n} else if (!bcm->rx_skb) {\r\nmutex_lock(&bcm_device_lock);\r\nif (bcm->dev && bcm_device_exists(bcm->dev)) {\r\npm_runtime_get(&bcm->dev->pdev->dev);\r\npm_runtime_mark_last_busy(&bcm->dev->pdev->dev);\r\npm_runtime_put_autosuspend(&bcm->dev->pdev->dev);\r\n}\r\nmutex_unlock(&bcm_device_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic int bcm_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nstruct bcm_data *bcm = hu->priv;\r\nbt_dev_dbg(hu->hdev, "hu %p skb %p", hu, skb);\r\nmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\r\nskb_queue_tail(&bcm->txq, skb);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *bcm_dequeue(struct hci_uart *hu)\r\n{\r\nstruct bcm_data *bcm = hu->priv;\r\nstruct sk_buff *skb = NULL;\r\nstruct bcm_device *bdev = NULL;\r\nmutex_lock(&bcm_device_lock);\r\nif (bcm_device_exists(bcm->dev)) {\r\nbdev = bcm->dev;\r\npm_runtime_get_sync(&bdev->pdev->dev);\r\n}\r\nskb = skb_dequeue(&bcm->txq);\r\nif (bdev) {\r\npm_runtime_mark_last_busy(&bdev->pdev->dev);\r\npm_runtime_put_autosuspend(&bdev->pdev->dev);\r\n}\r\nmutex_unlock(&bcm_device_lock);\r\nreturn skb;\r\n}\r\nstatic int bcm_suspend_device(struct device *dev)\r\n{\r\nstruct bcm_device *bdev = platform_get_drvdata(to_platform_device(dev));\r\nbt_dev_dbg(bdev, "");\r\nif (!bdev->is_suspended && bdev->hu) {\r\nhci_uart_set_flow_control(bdev->hu, true);\r\nbdev->is_suspended = true;\r\n}\r\nif (bdev->device_wakeup) {\r\ngpiod_set_value(bdev->device_wakeup, false);\r\nbt_dev_dbg(bdev, "suspend, delaying 15 ms");\r\nmdelay(15);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_resume_device(struct device *dev)\r\n{\r\nstruct bcm_device *bdev = platform_get_drvdata(to_platform_device(dev));\r\nbt_dev_dbg(bdev, "");\r\nif (bdev->device_wakeup) {\r\ngpiod_set_value(bdev->device_wakeup, true);\r\nbt_dev_dbg(bdev, "resume, delaying 15 ms");\r\nmdelay(15);\r\n}\r\nif (bdev->is_suspended && bdev->hu) {\r\nbdev->is_suspended = false;\r\nhci_uart_set_flow_control(bdev->hu, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_suspend(struct device *dev)\r\n{\r\nstruct bcm_device *bdev = platform_get_drvdata(to_platform_device(dev));\r\nint error;\r\nbt_dev_dbg(bdev, "suspend: is_suspended %d", bdev->is_suspended);\r\nmutex_lock(&bcm_device_lock);\r\nif (!bdev->hu)\r\ngoto unlock;\r\nif (pm_runtime_active(dev))\r\nbcm_suspend_device(dev);\r\nif (device_may_wakeup(&bdev->pdev->dev)) {\r\nerror = enable_irq_wake(bdev->irq);\r\nif (!error)\r\nbt_dev_dbg(bdev, "BCM irq: enabled");\r\n}\r\nunlock:\r\nmutex_unlock(&bcm_device_lock);\r\nreturn 0;\r\n}\r\nstatic int bcm_resume(struct device *dev)\r\n{\r\nstruct bcm_device *bdev = platform_get_drvdata(to_platform_device(dev));\r\nbt_dev_dbg(bdev, "resume: is_suspended %d", bdev->is_suspended);\r\nmutex_lock(&bcm_device_lock);\r\nif (!bdev->hu)\r\ngoto unlock;\r\nif (device_may_wakeup(&bdev->pdev->dev)) {\r\ndisable_irq_wake(bdev->irq);\r\nbt_dev_dbg(bdev, "BCM irq: disabled");\r\n}\r\nbcm_resume_device(dev);\r\nunlock:\r\nmutex_unlock(&bcm_device_lock);\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nreturn 0;\r\n}\r\nstatic int bcm_resource(struct acpi_resource *ares, void *data)\r\n{\r\nstruct bcm_device *dev = data;\r\nstruct acpi_resource_extended_irq *irq;\r\nstruct acpi_resource_gpio *gpio;\r\nstruct acpi_resource_uart_serialbus *sb;\r\nswitch (ares->type) {\r\ncase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\r\nirq = &ares->data.extended_irq;\r\ndev->irq_polarity = irq->polarity;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_GPIO:\r\ngpio = &ares->data.gpio;\r\nif (gpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT)\r\ndev->irq_polarity = gpio->polarity;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_SERIAL_BUS:\r\nsb = &ares->data.uart_serial_bus;\r\nif (sb->type == ACPI_RESOURCE_SERIAL_TYPE_UART)\r\ndev->init_speed = sb->default_baud_rate;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int bcm_acpi_probe(struct bcm_device *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nLIST_HEAD(resources);\r\nconst struct dmi_system_id *dmi_id;\r\nint ret;\r\ndev->name = dev_name(&pdev->dev);\r\nret = acpi_dev_add_driver_gpios(ACPI_COMPANION(&pdev->dev),\r\nacpi_bcm_default_gpios);\r\nif (ret)\r\nreturn ret;\r\ndev->clk = devm_clk_get(&pdev->dev, NULL);\r\ndev->device_wakeup = devm_gpiod_get_optional(&pdev->dev,\r\n"device-wakeup",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(dev->device_wakeup))\r\nreturn PTR_ERR(dev->device_wakeup);\r\ndev->shutdown = devm_gpiod_get_optional(&pdev->dev, "shutdown",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(dev->shutdown))\r\nreturn PTR_ERR(dev->shutdown);\r\ndev->irq = platform_get_irq(pdev, 0);\r\nif (dev->irq <= 0) {\r\nstruct gpio_desc *gpio;\r\ngpio = devm_gpiod_get_optional(&pdev->dev, "host-wakeup",\r\nGPIOD_IN);\r\nif (IS_ERR(gpio))\r\nreturn PTR_ERR(gpio);\r\ndev->irq = gpiod_to_irq(gpio);\r\n}\r\ndev_info(&pdev->dev, "BCM irq: %d\n", dev->irq);\r\nif ((!dev->device_wakeup && !dev->shutdown) || !dev->name) {\r\ndev_err(&pdev->dev, "invalid platform data\n");\r\nreturn -EINVAL;\r\n}\r\nret = acpi_dev_get_resources(ACPI_COMPANION(&dev->pdev->dev),\r\n&resources, bcm_resource, dev);\r\nif (ret < 0)\r\nreturn ret;\r\nacpi_dev_free_resource_list(&resources);\r\ndmi_id = dmi_first_match(bcm_wrong_irq_dmi_table);\r\nif (dmi_id) {\r\nbt_dev_warn(dev, "%s: Overwriting IRQ polarity to active low",\r\ndmi_id->ident);\r\ndev->irq_polarity = *(u8 *)dmi_id->driver_data;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_acpi_probe(struct bcm_device *dev)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int bcm_probe(struct platform_device *pdev)\r\n{\r\nstruct bcm_device *dev;\r\nint ret;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->pdev = pdev;\r\nret = bcm_acpi_probe(dev);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, dev);\r\ndev_info(&pdev->dev, "%s device registered.\n", dev->name);\r\nmutex_lock(&bcm_device_lock);\r\nlist_add_tail(&dev->list, &bcm_device_list);\r\nmutex_unlock(&bcm_device_lock);\r\nbcm_gpio_set_power(dev, false);\r\nreturn 0;\r\n}\r\nstatic int bcm_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm_device *dev = platform_get_drvdata(pdev);\r\nmutex_lock(&bcm_device_lock);\r\nlist_del(&dev->list);\r\nmutex_unlock(&bcm_device_lock);\r\nacpi_dev_remove_driver_gpios(ACPI_COMPANION(&pdev->dev));\r\ndev_info(&pdev->dev, "%s device unregistered.\n", dev->name);\r\nreturn 0;\r\n}\r\nint __init bcm_init(void)\r\n{\r\nplatform_driver_register(&bcm_driver);\r\nreturn hci_uart_register_proto(&bcm_proto);\r\n}\r\nint __exit bcm_deinit(void)\r\n{\r\nplatform_driver_unregister(&bcm_driver);\r\nreturn hci_uart_unregister_proto(&bcm_proto);\r\n}
