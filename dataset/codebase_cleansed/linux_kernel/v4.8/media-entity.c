static inline const char *gobj_type(enum media_gobj_type type)\r\n{\r\nswitch (type) {\r\ncase MEDIA_GRAPH_ENTITY:\r\nreturn "entity";\r\ncase MEDIA_GRAPH_PAD:\r\nreturn "pad";\r\ncase MEDIA_GRAPH_LINK:\r\nreturn "link";\r\ncase MEDIA_GRAPH_INTF_DEVNODE:\r\nreturn "intf-devnode";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nstatic inline const char *intf_type(struct media_interface *intf)\r\n{\r\nswitch (intf->type) {\r\ncase MEDIA_INTF_T_DVB_FE:\r\nreturn "dvb-frontend";\r\ncase MEDIA_INTF_T_DVB_DEMUX:\r\nreturn "dvb-demux";\r\ncase MEDIA_INTF_T_DVB_DVR:\r\nreturn "dvb-dvr";\r\ncase MEDIA_INTF_T_DVB_CA:\r\nreturn "dvb-ca";\r\ncase MEDIA_INTF_T_DVB_NET:\r\nreturn "dvb-net";\r\ncase MEDIA_INTF_T_V4L_VIDEO:\r\nreturn "v4l-video";\r\ncase MEDIA_INTF_T_V4L_VBI:\r\nreturn "v4l-vbi";\r\ncase MEDIA_INTF_T_V4L_RADIO:\r\nreturn "v4l-radio";\r\ncase MEDIA_INTF_T_V4L_SUBDEV:\r\nreturn "v4l-subdev";\r\ncase MEDIA_INTF_T_V4L_SWRADIO:\r\nreturn "v4l-swradio";\r\ncase MEDIA_INTF_T_ALSA_PCM_CAPTURE:\r\nreturn "alsa-pcm-capture";\r\ncase MEDIA_INTF_T_ALSA_PCM_PLAYBACK:\r\nreturn "alsa-pcm-playback";\r\ncase MEDIA_INTF_T_ALSA_CONTROL:\r\nreturn "alsa-control";\r\ncase MEDIA_INTF_T_ALSA_COMPRESS:\r\nreturn "alsa-compress";\r\ncase MEDIA_INTF_T_ALSA_RAWMIDI:\r\nreturn "alsa-rawmidi";\r\ncase MEDIA_INTF_T_ALSA_HWDEP:\r\nreturn "alsa-hwdep";\r\ncase MEDIA_INTF_T_ALSA_SEQUENCER:\r\nreturn "alsa-sequencer";\r\ncase MEDIA_INTF_T_ALSA_TIMER:\r\nreturn "alsa-timer";\r\ndefault:\r\nreturn "unknown-intf";\r\n}\r\n}\r\n__must_check int __media_entity_enum_init(struct media_entity_enum *ent_enum,\r\nint idx_max)\r\n{\r\nidx_max = ALIGN(idx_max, BITS_PER_LONG);\r\nent_enum->bmap = kcalloc(idx_max / BITS_PER_LONG, sizeof(long),\r\nGFP_KERNEL);\r\nif (!ent_enum->bmap)\r\nreturn -ENOMEM;\r\nbitmap_zero(ent_enum->bmap, idx_max);\r\nent_enum->idx_max = idx_max;\r\nreturn 0;\r\n}\r\nvoid media_entity_enum_cleanup(struct media_entity_enum *ent_enum)\r\n{\r\nkfree(ent_enum->bmap);\r\n}\r\nstatic void dev_dbg_obj(const char *event_name, struct media_gobj *gobj)\r\n{\r\n#if defined(DEBUG) || defined (CONFIG_DYNAMIC_DEBUG)\r\nswitch (media_type(gobj)) {\r\ncase MEDIA_GRAPH_ENTITY:\r\ndev_dbg(gobj->mdev->dev,\r\n"%s id %u: entity '%s'\n",\r\nevent_name, media_id(gobj),\r\ngobj_to_entity(gobj)->name);\r\nbreak;\r\ncase MEDIA_GRAPH_LINK:\r\n{\r\nstruct media_link *link = gobj_to_link(gobj);\r\ndev_dbg(gobj->mdev->dev,\r\n"%s id %u: %s link id %u ==> id %u\n",\r\nevent_name, media_id(gobj),\r\nmedia_type(link->gobj0) == MEDIA_GRAPH_PAD ?\r\n"data" : "interface",\r\nmedia_id(link->gobj0),\r\nmedia_id(link->gobj1));\r\nbreak;\r\n}\r\ncase MEDIA_GRAPH_PAD:\r\n{\r\nstruct media_pad *pad = gobj_to_pad(gobj);\r\ndev_dbg(gobj->mdev->dev,\r\n"%s id %u: %s%spad '%s':%d\n",\r\nevent_name, media_id(gobj),\r\npad->flags & MEDIA_PAD_FL_SINK ? "sink " : "",\r\npad->flags & MEDIA_PAD_FL_SOURCE ? "source " : "",\r\npad->entity->name, pad->index);\r\nbreak;\r\n}\r\ncase MEDIA_GRAPH_INTF_DEVNODE:\r\n{\r\nstruct media_interface *intf = gobj_to_intf(gobj);\r\nstruct media_intf_devnode *devnode = intf_to_devnode(intf);\r\ndev_dbg(gobj->mdev->dev,\r\n"%s id %u: intf_devnode %s - major: %d, minor: %d\n",\r\nevent_name, media_id(gobj),\r\nintf_type(intf),\r\ndevnode->major, devnode->minor);\r\nbreak;\r\n}\r\n}\r\n#endif\r\n}\r\nvoid media_gobj_create(struct media_device *mdev,\r\nenum media_gobj_type type,\r\nstruct media_gobj *gobj)\r\n{\r\nBUG_ON(!mdev);\r\ngobj->mdev = mdev;\r\ngobj->id = media_gobj_gen_id(type, ++mdev->id);\r\nswitch (type) {\r\ncase MEDIA_GRAPH_ENTITY:\r\nlist_add_tail(&gobj->list, &mdev->entities);\r\nbreak;\r\ncase MEDIA_GRAPH_PAD:\r\nlist_add_tail(&gobj->list, &mdev->pads);\r\nbreak;\r\ncase MEDIA_GRAPH_LINK:\r\nlist_add_tail(&gobj->list, &mdev->links);\r\nbreak;\r\ncase MEDIA_GRAPH_INTF_DEVNODE:\r\nlist_add_tail(&gobj->list, &mdev->interfaces);\r\nbreak;\r\n}\r\nmdev->topology_version++;\r\ndev_dbg_obj(__func__, gobj);\r\n}\r\nvoid media_gobj_destroy(struct media_gobj *gobj)\r\n{\r\ndev_dbg_obj(__func__, gobj);\r\ngobj->mdev->topology_version++;\r\nlist_del(&gobj->list);\r\n}\r\nint media_entity_pads_init(struct media_entity *entity, u16 num_pads,\r\nstruct media_pad *pads)\r\n{\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nunsigned int i;\r\nentity->num_pads = num_pads;\r\nentity->pads = pads;\r\nif (mdev)\r\nmutex_lock(&mdev->graph_mutex);\r\nfor (i = 0; i < num_pads; i++) {\r\npads[i].entity = entity;\r\npads[i].index = i;\r\nif (mdev)\r\nmedia_gobj_create(mdev, MEDIA_GRAPH_PAD,\r\n&entity->pads[i].graph_obj);\r\n}\r\nif (mdev)\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn 0;\r\n}\r\nstatic struct media_entity *\r\nmedia_entity_other(struct media_entity *entity, struct media_link *link)\r\n{\r\nif (link->source->entity == entity)\r\nreturn link->sink->entity;\r\nelse\r\nreturn link->source->entity;\r\n}\r\nstatic void stack_push(struct media_entity_graph *graph,\r\nstruct media_entity *entity)\r\n{\r\nif (graph->top == MEDIA_ENTITY_ENUM_MAX_DEPTH - 1) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\ngraph->top++;\r\ngraph->stack[graph->top].link = entity->links.next;\r\ngraph->stack[graph->top].entity = entity;\r\n}\r\nstatic struct media_entity *stack_pop(struct media_entity_graph *graph)\r\n{\r\nstruct media_entity *entity;\r\nentity = graph->stack[graph->top].entity;\r\ngraph->top--;\r\nreturn entity;\r\n}\r\n__must_check int media_entity_graph_walk_init(\r\nstruct media_entity_graph *graph, struct media_device *mdev)\r\n{\r\nreturn media_entity_enum_init(&graph->ent_enum, mdev);\r\n}\r\nvoid media_entity_graph_walk_cleanup(struct media_entity_graph *graph)\r\n{\r\nmedia_entity_enum_cleanup(&graph->ent_enum);\r\n}\r\nvoid media_entity_graph_walk_start(struct media_entity_graph *graph,\r\nstruct media_entity *entity)\r\n{\r\nmedia_entity_enum_zero(&graph->ent_enum);\r\nmedia_entity_enum_set(&graph->ent_enum, entity);\r\ngraph->top = 0;\r\ngraph->stack[graph->top].entity = NULL;\r\nstack_push(graph, entity);\r\n}\r\nstruct media_entity *\r\nmedia_entity_graph_walk_next(struct media_entity_graph *graph)\r\n{\r\nif (stack_top(graph) == NULL)\r\nreturn NULL;\r\nwhile (link_top(graph) != &stack_top(graph)->links) {\r\nstruct media_entity *entity = stack_top(graph);\r\nstruct media_link *link;\r\nstruct media_entity *next;\r\nlink = list_entry(link_top(graph), typeof(*link), list);\r\nif (!(link->flags & MEDIA_LNK_FL_ENABLED)) {\r\nlink_top(graph) = link_top(graph)->next;\r\ncontinue;\r\n}\r\nnext = media_entity_other(entity, link);\r\nif (media_entity_enum_test_and_set(&graph->ent_enum, next)) {\r\nlink_top(graph) = link_top(graph)->next;\r\ncontinue;\r\n}\r\nlink_top(graph) = link_top(graph)->next;\r\nstack_push(graph, next);\r\n}\r\nreturn stack_pop(graph);\r\n}\r\n__must_check int __media_entity_pipeline_start(struct media_entity *entity,\r\nstruct media_pipeline *pipe)\r\n{\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nstruct media_entity_graph *graph = &pipe->graph;\r\nstruct media_entity *entity_err = entity;\r\nstruct media_link *link;\r\nint ret;\r\nif (!pipe->streaming_count++) {\r\nret = media_entity_graph_walk_init(&pipe->graph, mdev);\r\nif (ret)\r\ngoto error_graph_walk_start;\r\n}\r\nmedia_entity_graph_walk_start(&pipe->graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(graph))) {\r\nDECLARE_BITMAP(active, MEDIA_ENTITY_MAX_PADS);\r\nDECLARE_BITMAP(has_no_links, MEDIA_ENTITY_MAX_PADS);\r\nentity->stream_count++;\r\nif (WARN_ON(entity->pipe && entity->pipe != pipe)) {\r\nret = -EBUSY;\r\ngoto error;\r\n}\r\nentity->pipe = pipe;\r\nif (entity->stream_count > 1)\r\ncontinue;\r\nif (!entity->ops || !entity->ops->link_validate)\r\ncontinue;\r\nbitmap_zero(active, entity->num_pads);\r\nbitmap_fill(has_no_links, entity->num_pads);\r\nlist_for_each_entry(link, &entity->links, list) {\r\nstruct media_pad *pad = link->sink->entity == entity\r\n? link->sink : link->source;\r\nbitmap_clear(has_no_links, pad->index, 1);\r\nif (!(pad->flags & MEDIA_PAD_FL_MUST_CONNECT) ||\r\nlink->flags & MEDIA_LNK_FL_ENABLED)\r\nbitmap_set(active, pad->index, 1);\r\nif (link->sink != pad ||\r\n!(link->flags & MEDIA_LNK_FL_ENABLED))\r\ncontinue;\r\nret = entity->ops->link_validate(link);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\ndev_dbg(entity->graph_obj.mdev->dev,\r\n"link validation failed for \"%s\":%u -> \"%s\":%u, error %d\n",\r\nlink->source->entity->name,\r\nlink->source->index,\r\nentity->name, link->sink->index, ret);\r\ngoto error;\r\n}\r\n}\r\nbitmap_or(active, active, has_no_links, entity->num_pads);\r\nif (!bitmap_full(active, entity->num_pads)) {\r\nret = -ENOLINK;\r\ndev_dbg(entity->graph_obj.mdev->dev,\r\n"\"%s\":%u must be connected by an enabled link\n",\r\nentity->name,\r\n(unsigned)find_first_zero_bit(\r\nactive, entity->num_pads));\r\ngoto error;\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\nmedia_entity_graph_walk_start(graph, entity_err);\r\nwhile ((entity_err = media_entity_graph_walk_next(graph))) {\r\nif (entity->stream_count > 0) {\r\nentity_err->stream_count--;\r\nif (entity_err->stream_count == 0)\r\nentity_err->pipe = NULL;\r\n}\r\nif (entity_err == entity)\r\nbreak;\r\n}\r\nerror_graph_walk_start:\r\nif (!--pipe->streaming_count)\r\nmedia_entity_graph_walk_cleanup(graph);\r\nreturn ret;\r\n}\r\n__must_check int media_entity_pipeline_start(struct media_entity *entity,\r\nstruct media_pipeline *pipe)\r\n{\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nint ret;\r\nmutex_lock(&mdev->graph_mutex);\r\nret = __media_entity_pipeline_start(entity, pipe);\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn ret;\r\n}\r\nvoid __media_entity_pipeline_stop(struct media_entity *entity)\r\n{\r\nstruct media_entity_graph *graph = &entity->pipe->graph;\r\nstruct media_pipeline *pipe = entity->pipe;\r\nWARN_ON(!pipe->streaming_count);\r\nmedia_entity_graph_walk_start(graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(graph))) {\r\nif (entity->stream_count > 0) {\r\nentity->stream_count--;\r\nif (entity->stream_count == 0)\r\nentity->pipe = NULL;\r\n}\r\n}\r\nif (!--pipe->streaming_count)\r\nmedia_entity_graph_walk_cleanup(graph);\r\n}\r\nvoid media_entity_pipeline_stop(struct media_entity *entity)\r\n{\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nmutex_lock(&mdev->graph_mutex);\r\n__media_entity_pipeline_stop(entity);\r\nmutex_unlock(&mdev->graph_mutex);\r\n}\r\nstruct media_entity *media_entity_get(struct media_entity *entity)\r\n{\r\nif (entity == NULL)\r\nreturn NULL;\r\nif (entity->graph_obj.mdev->dev &&\r\n!try_module_get(entity->graph_obj.mdev->dev->driver->owner))\r\nreturn NULL;\r\nreturn entity;\r\n}\r\nvoid media_entity_put(struct media_entity *entity)\r\n{\r\nif (entity == NULL)\r\nreturn;\r\nif (entity->graph_obj.mdev->dev)\r\nmodule_put(entity->graph_obj.mdev->dev->driver->owner);\r\n}\r\nstatic struct media_link *media_add_link(struct list_head *head)\r\n{\r\nstruct media_link *link;\r\nlink = kzalloc(sizeof(*link), GFP_KERNEL);\r\nif (link == NULL)\r\nreturn NULL;\r\nlist_add_tail(&link->list, head);\r\nreturn link;\r\n}\r\nstatic void __media_entity_remove_link(struct media_entity *entity,\r\nstruct media_link *link)\r\n{\r\nstruct media_link *rlink, *tmp;\r\nstruct media_entity *remote;\r\nif (link->source->entity == entity)\r\nremote = link->sink->entity;\r\nelse\r\nremote = link->source->entity;\r\nlist_for_each_entry_safe(rlink, tmp, &remote->links, list) {\r\nif (rlink != link->reverse)\r\ncontinue;\r\nif (link->source->entity == entity)\r\nremote->num_backlinks--;\r\nlist_del(&rlink->list);\r\nmedia_gobj_destroy(&rlink->graph_obj);\r\nkfree(rlink);\r\nif (--remote->num_links == 0)\r\nbreak;\r\n}\r\nlist_del(&link->list);\r\nmedia_gobj_destroy(&link->graph_obj);\r\nkfree(link);\r\n}\r\nint\r\nmedia_create_pad_link(struct media_entity *source, u16 source_pad,\r\nstruct media_entity *sink, u16 sink_pad, u32 flags)\r\n{\r\nstruct media_link *link;\r\nstruct media_link *backlink;\r\nBUG_ON(source == NULL || sink == NULL);\r\nBUG_ON(source_pad >= source->num_pads);\r\nBUG_ON(sink_pad >= sink->num_pads);\r\nlink = media_add_link(&source->links);\r\nif (link == NULL)\r\nreturn -ENOMEM;\r\nlink->source = &source->pads[source_pad];\r\nlink->sink = &sink->pads[sink_pad];\r\nlink->flags = flags & ~MEDIA_LNK_FL_INTERFACE_LINK;\r\nmedia_gobj_create(source->graph_obj.mdev, MEDIA_GRAPH_LINK,\r\n&link->graph_obj);\r\nbacklink = media_add_link(&sink->links);\r\nif (backlink == NULL) {\r\n__media_entity_remove_link(source, link);\r\nreturn -ENOMEM;\r\n}\r\nbacklink->source = &source->pads[source_pad];\r\nbacklink->sink = &sink->pads[sink_pad];\r\nbacklink->flags = flags;\r\nbacklink->is_backlink = true;\r\nmedia_gobj_create(sink->graph_obj.mdev, MEDIA_GRAPH_LINK,\r\n&backlink->graph_obj);\r\nlink->reverse = backlink;\r\nbacklink->reverse = link;\r\nsink->num_backlinks++;\r\nsink->num_links++;\r\nsource->num_links++;\r\nreturn 0;\r\n}\r\nint media_create_pad_links(const struct media_device *mdev,\r\nconst u32 source_function,\r\nstruct media_entity *source,\r\nconst u16 source_pad,\r\nconst u32 sink_function,\r\nstruct media_entity *sink,\r\nconst u16 sink_pad,\r\nu32 flags,\r\nconst bool allow_both_undefined)\r\n{\r\nstruct media_entity *entity;\r\nunsigned function;\r\nint ret;\r\nif (source && sink)\r\nreturn media_create_pad_link(source, source_pad,\r\nsink, sink_pad, flags);\r\nif (!source && !sink) {\r\nif (!allow_both_undefined)\r\nreturn 0;\r\nmedia_device_for_each_entity(source, mdev) {\r\nif (source->function != source_function)\r\ncontinue;\r\nmedia_device_for_each_entity(sink, mdev) {\r\nif (sink->function != sink_function)\r\ncontinue;\r\nret = media_create_pad_link(source, source_pad,\r\nsink, sink_pad,\r\nflags);\r\nif (ret)\r\nreturn ret;\r\nflags &= ~(MEDIA_LNK_FL_ENABLED |\r\nMEDIA_LNK_FL_IMMUTABLE);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nif (source)\r\nfunction = sink_function;\r\nelse\r\nfunction = source_function;\r\nmedia_device_for_each_entity(entity, mdev) {\r\nif (entity->function != function)\r\ncontinue;\r\nif (source)\r\nret = media_create_pad_link(source, source_pad,\r\nentity, sink_pad, flags);\r\nelse\r\nret = media_create_pad_link(entity, source_pad,\r\nsink, sink_pad, flags);\r\nif (ret)\r\nreturn ret;\r\nflags &= ~(MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\r\n}\r\nreturn 0;\r\n}\r\nvoid __media_entity_remove_links(struct media_entity *entity)\r\n{\r\nstruct media_link *link, *tmp;\r\nlist_for_each_entry_safe(link, tmp, &entity->links, list)\r\n__media_entity_remove_link(entity, link);\r\nentity->num_links = 0;\r\nentity->num_backlinks = 0;\r\n}\r\nvoid media_entity_remove_links(struct media_entity *entity)\r\n{\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nif (mdev == NULL)\r\nreturn;\r\nmutex_lock(&mdev->graph_mutex);\r\n__media_entity_remove_links(entity);\r\nmutex_unlock(&mdev->graph_mutex);\r\n}\r\nstatic int __media_entity_setup_link_notify(struct media_link *link, u32 flags)\r\n{\r\nint ret;\r\nret = media_entity_call(link->source->entity, link_setup,\r\nlink->source, link->sink, flags);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nret = media_entity_call(link->sink->entity, link_setup,\r\nlink->sink, link->source, flags);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\nmedia_entity_call(link->source->entity, link_setup,\r\nlink->source, link->sink, link->flags);\r\nreturn ret;\r\n}\r\nlink->flags = flags;\r\nlink->reverse->flags = link->flags;\r\nreturn 0;\r\n}\r\nint __media_entity_setup_link(struct media_link *link, u32 flags)\r\n{\r\nconst u32 mask = MEDIA_LNK_FL_ENABLED;\r\nstruct media_device *mdev;\r\nstruct media_entity *source, *sink;\r\nint ret = -EBUSY;\r\nif (link == NULL)\r\nreturn -EINVAL;\r\nif ((link->flags & ~mask) != (flags & ~mask))\r\nreturn -EINVAL;\r\nif (link->flags & MEDIA_LNK_FL_IMMUTABLE)\r\nreturn link->flags == flags ? 0 : -EINVAL;\r\nif (link->flags == flags)\r\nreturn 0;\r\nsource = link->source->entity;\r\nsink = link->sink->entity;\r\nif (!(link->flags & MEDIA_LNK_FL_DYNAMIC) &&\r\n(source->stream_count || sink->stream_count))\r\nreturn -EBUSY;\r\nmdev = source->graph_obj.mdev;\r\nif (mdev->link_notify) {\r\nret = mdev->link_notify(link, flags,\r\nMEDIA_DEV_NOTIFY_PRE_LINK_CH);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = __media_entity_setup_link_notify(link, flags);\r\nif (mdev->link_notify)\r\nmdev->link_notify(link, flags, MEDIA_DEV_NOTIFY_POST_LINK_CH);\r\nreturn ret;\r\n}\r\nint media_entity_setup_link(struct media_link *link, u32 flags)\r\n{\r\nint ret;\r\nmutex_lock(&link->graph_obj.mdev->graph_mutex);\r\nret = __media_entity_setup_link(link, flags);\r\nmutex_unlock(&link->graph_obj.mdev->graph_mutex);\r\nreturn ret;\r\n}\r\nstruct media_link *\r\nmedia_entity_find_link(struct media_pad *source, struct media_pad *sink)\r\n{\r\nstruct media_link *link;\r\nlist_for_each_entry(link, &source->entity->links, list) {\r\nif (link->source->entity == source->entity &&\r\nlink->source->index == source->index &&\r\nlink->sink->entity == sink->entity &&\r\nlink->sink->index == sink->index)\r\nreturn link;\r\n}\r\nreturn NULL;\r\n}\r\nstruct media_pad *media_entity_remote_pad(struct media_pad *pad)\r\n{\r\nstruct media_link *link;\r\nlist_for_each_entry(link, &pad->entity->links, list) {\r\nif (!(link->flags & MEDIA_LNK_FL_ENABLED))\r\ncontinue;\r\nif (link->source == pad)\r\nreturn link->sink;\r\nif (link->sink == pad)\r\nreturn link->source;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void media_interface_init(struct media_device *mdev,\r\nstruct media_interface *intf,\r\nu32 gobj_type,\r\nu32 intf_type, u32 flags)\r\n{\r\nintf->type = intf_type;\r\nintf->flags = flags;\r\nINIT_LIST_HEAD(&intf->links);\r\nmedia_gobj_create(mdev, gobj_type, &intf->graph_obj);\r\n}\r\nstruct media_intf_devnode *media_devnode_create(struct media_device *mdev,\r\nu32 type, u32 flags,\r\nu32 major, u32 minor)\r\n{\r\nstruct media_intf_devnode *devnode;\r\ndevnode = kzalloc(sizeof(*devnode), GFP_KERNEL);\r\nif (!devnode)\r\nreturn NULL;\r\ndevnode->major = major;\r\ndevnode->minor = minor;\r\nmedia_interface_init(mdev, &devnode->intf, MEDIA_GRAPH_INTF_DEVNODE,\r\ntype, flags);\r\nreturn devnode;\r\n}\r\nvoid media_devnode_remove(struct media_intf_devnode *devnode)\r\n{\r\nmedia_remove_intf_links(&devnode->intf);\r\nmedia_gobj_destroy(&devnode->intf.graph_obj);\r\nkfree(devnode);\r\n}\r\nstruct media_link *media_create_intf_link(struct media_entity *entity,\r\nstruct media_interface *intf,\r\nu32 flags)\r\n{\r\nstruct media_link *link;\r\nlink = media_add_link(&intf->links);\r\nif (link == NULL)\r\nreturn NULL;\r\nlink->intf = intf;\r\nlink->entity = entity;\r\nlink->flags = flags | MEDIA_LNK_FL_INTERFACE_LINK;\r\nmedia_gobj_create(intf->graph_obj.mdev, MEDIA_GRAPH_LINK,\r\n&link->graph_obj);\r\nreturn link;\r\n}\r\nvoid __media_remove_intf_link(struct media_link *link)\r\n{\r\nlist_del(&link->list);\r\nmedia_gobj_destroy(&link->graph_obj);\r\nkfree(link);\r\n}\r\nvoid media_remove_intf_link(struct media_link *link)\r\n{\r\nstruct media_device *mdev = link->graph_obj.mdev;\r\nif (mdev == NULL)\r\nreturn;\r\nmutex_lock(&mdev->graph_mutex);\r\n__media_remove_intf_link(link);\r\nmutex_unlock(&mdev->graph_mutex);\r\n}\r\nvoid __media_remove_intf_links(struct media_interface *intf)\r\n{\r\nstruct media_link *link, *tmp;\r\nlist_for_each_entry_safe(link, tmp, &intf->links, list)\r\n__media_remove_intf_link(link);\r\n}\r\nvoid media_remove_intf_links(struct media_interface *intf)\r\n{\r\nstruct media_device *mdev = intf->graph_obj.mdev;\r\nif (mdev == NULL)\r\nreturn;\r\nmutex_lock(&mdev->graph_mutex);\r\n__media_remove_intf_links(intf);\r\nmutex_unlock(&mdev->graph_mutex);\r\n}
