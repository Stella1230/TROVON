static struct alias_server *_find_server(struct dasd_uid *uid)\r\n{\r\nstruct alias_server *pos;\r\nlist_for_each_entry(pos, &aliastree.serverlist, server) {\r\nif (!strncmp(pos->uid.vendor, uid->vendor,\r\nsizeof(uid->vendor))\r\n&& !strncmp(pos->uid.serial, uid->serial,\r\nsizeof(uid->serial)))\r\nreturn pos;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct alias_lcu *_find_lcu(struct alias_server *server,\r\nstruct dasd_uid *uid)\r\n{\r\nstruct alias_lcu *pos;\r\nlist_for_each_entry(pos, &server->lculist, lcu) {\r\nif (pos->uid.ssid == uid->ssid)\r\nreturn pos;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct alias_pav_group *_find_group(struct alias_lcu *lcu,\r\nstruct dasd_uid *uid)\r\n{\r\nstruct alias_pav_group *pos;\r\n__u8 search_unit_addr;\r\nif (lcu->pav == HYPER_PAV) {\r\nif (list_empty(&lcu->grouplist))\r\nreturn NULL;\r\nelse\r\nreturn list_first_entry(&lcu->grouplist,\r\nstruct alias_pav_group, group);\r\n}\r\nif (uid->type == UA_BASE_DEVICE)\r\nsearch_unit_addr = uid->real_unit_addr;\r\nelse\r\nsearch_unit_addr = uid->base_unit_addr;\r\nlist_for_each_entry(pos, &lcu->grouplist, group) {\r\nif (pos->uid.base_unit_addr == search_unit_addr &&\r\n!strncmp(pos->uid.vduit, uid->vduit, sizeof(uid->vduit)))\r\nreturn pos;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct alias_server *_allocate_server(struct dasd_uid *uid)\r\n{\r\nstruct alias_server *server;\r\nserver = kzalloc(sizeof(*server), GFP_KERNEL);\r\nif (!server)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(server->uid.vendor, uid->vendor, sizeof(uid->vendor));\r\nmemcpy(server->uid.serial, uid->serial, sizeof(uid->serial));\r\nINIT_LIST_HEAD(&server->server);\r\nINIT_LIST_HEAD(&server->lculist);\r\nreturn server;\r\n}\r\nstatic void _free_server(struct alias_server *server)\r\n{\r\nkfree(server);\r\n}\r\nstatic struct alias_lcu *_allocate_lcu(struct dasd_uid *uid)\r\n{\r\nstruct alias_lcu *lcu;\r\nlcu = kzalloc(sizeof(*lcu), GFP_KERNEL);\r\nif (!lcu)\r\nreturn ERR_PTR(-ENOMEM);\r\nlcu->uac = kzalloc(sizeof(*(lcu->uac)), GFP_KERNEL | GFP_DMA);\r\nif (!lcu->uac)\r\ngoto out_err1;\r\nlcu->rsu_cqr = kzalloc(sizeof(*lcu->rsu_cqr), GFP_KERNEL | GFP_DMA);\r\nif (!lcu->rsu_cqr)\r\ngoto out_err2;\r\nlcu->rsu_cqr->cpaddr = kzalloc(sizeof(struct ccw1),\r\nGFP_KERNEL | GFP_DMA);\r\nif (!lcu->rsu_cqr->cpaddr)\r\ngoto out_err3;\r\nlcu->rsu_cqr->data = kzalloc(16, GFP_KERNEL | GFP_DMA);\r\nif (!lcu->rsu_cqr->data)\r\ngoto out_err4;\r\nmemcpy(lcu->uid.vendor, uid->vendor, sizeof(uid->vendor));\r\nmemcpy(lcu->uid.serial, uid->serial, sizeof(uid->serial));\r\nlcu->uid.ssid = uid->ssid;\r\nlcu->pav = NO_PAV;\r\nlcu->flags = NEED_UAC_UPDATE | UPDATE_PENDING;\r\nINIT_LIST_HEAD(&lcu->lcu);\r\nINIT_LIST_HEAD(&lcu->inactive_devices);\r\nINIT_LIST_HEAD(&lcu->active_devices);\r\nINIT_LIST_HEAD(&lcu->grouplist);\r\nINIT_WORK(&lcu->suc_data.worker, summary_unit_check_handling_work);\r\nINIT_DELAYED_WORK(&lcu->ruac_data.dwork, lcu_update_work);\r\nspin_lock_init(&lcu->lock);\r\ninit_completion(&lcu->lcu_setup);\r\nreturn lcu;\r\nout_err4:\r\nkfree(lcu->rsu_cqr->cpaddr);\r\nout_err3:\r\nkfree(lcu->rsu_cqr);\r\nout_err2:\r\nkfree(lcu->uac);\r\nout_err1:\r\nkfree(lcu);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void _free_lcu(struct alias_lcu *lcu)\r\n{\r\nkfree(lcu->rsu_cqr->data);\r\nkfree(lcu->rsu_cqr->cpaddr);\r\nkfree(lcu->rsu_cqr);\r\nkfree(lcu->uac);\r\nkfree(lcu);\r\n}\r\nint dasd_alias_make_device_known_to_lcu(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private = device->private;\r\nunsigned long flags;\r\nstruct alias_server *server, *newserver;\r\nstruct alias_lcu *lcu, *newlcu;\r\nstruct dasd_uid uid;\r\ndevice->discipline->get_uid(device, &uid);\r\nspin_lock_irqsave(&aliastree.lock, flags);\r\nserver = _find_server(&uid);\r\nif (!server) {\r\nspin_unlock_irqrestore(&aliastree.lock, flags);\r\nnewserver = _allocate_server(&uid);\r\nif (IS_ERR(newserver))\r\nreturn PTR_ERR(newserver);\r\nspin_lock_irqsave(&aliastree.lock, flags);\r\nserver = _find_server(&uid);\r\nif (!server) {\r\nlist_add(&newserver->server, &aliastree.serverlist);\r\nserver = newserver;\r\n} else {\r\n_free_server(newserver);\r\n}\r\n}\r\nlcu = _find_lcu(server, &uid);\r\nif (!lcu) {\r\nspin_unlock_irqrestore(&aliastree.lock, flags);\r\nnewlcu = _allocate_lcu(&uid);\r\nif (IS_ERR(newlcu))\r\nreturn PTR_ERR(newlcu);\r\nspin_lock_irqsave(&aliastree.lock, flags);\r\nlcu = _find_lcu(server, &uid);\r\nif (!lcu) {\r\nlist_add(&newlcu->lcu, &server->lculist);\r\nlcu = newlcu;\r\n} else {\r\n_free_lcu(newlcu);\r\n}\r\n}\r\nspin_lock(&lcu->lock);\r\nlist_add(&device->alias_list, &lcu->inactive_devices);\r\nprivate->lcu = lcu;\r\nspin_unlock(&lcu->lock);\r\nspin_unlock_irqrestore(&aliastree.lock, flags);\r\nreturn 0;\r\n}\r\nvoid dasd_alias_disconnect_device_from_lcu(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private = device->private;\r\nunsigned long flags;\r\nstruct alias_lcu *lcu;\r\nstruct alias_server *server;\r\nint was_pending;\r\nstruct dasd_uid uid;\r\nlcu = private->lcu;\r\nif (!lcu)\r\nreturn;\r\ndevice->discipline->get_uid(device, &uid);\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nlist_del_init(&device->alias_list);\r\nif (device == lcu->suc_data.device) {\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\ncancel_work_sync(&lcu->suc_data.worker);\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nif (device == lcu->suc_data.device) {\r\ndasd_put_device(device);\r\nlcu->suc_data.device = NULL;\r\n}\r\n}\r\nwas_pending = 0;\r\nif (device == lcu->ruac_data.device) {\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\nwas_pending = 1;\r\ncancel_delayed_work_sync(&lcu->ruac_data.dwork);\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nif (device == lcu->ruac_data.device) {\r\ndasd_put_device(device);\r\nlcu->ruac_data.device = NULL;\r\n}\r\n}\r\nprivate->lcu = NULL;\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\nspin_lock_irqsave(&aliastree.lock, flags);\r\nspin_lock(&lcu->lock);\r\nif (list_empty(&lcu->grouplist) &&\r\nlist_empty(&lcu->active_devices) &&\r\nlist_empty(&lcu->inactive_devices)) {\r\nlist_del(&lcu->lcu);\r\nspin_unlock(&lcu->lock);\r\n_free_lcu(lcu);\r\nlcu = NULL;\r\n} else {\r\nif (was_pending)\r\n_schedule_lcu_update(lcu, NULL);\r\nspin_unlock(&lcu->lock);\r\n}\r\nserver = _find_server(&uid);\r\nif (server && list_empty(&server->lculist)) {\r\nlist_del(&server->server);\r\n_free_server(server);\r\n}\r\nspin_unlock_irqrestore(&aliastree.lock, flags);\r\n}\r\nstatic int _add_device_to_lcu(struct alias_lcu *lcu,\r\nstruct dasd_device *device,\r\nstruct dasd_device *pos)\r\n{\r\nstruct dasd_eckd_private *private = device->private;\r\nstruct alias_pav_group *group;\r\nstruct dasd_uid uid;\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\nprivate->uid.type = lcu->uac->unit[private->uid.real_unit_addr].ua_type;\r\nprivate->uid.base_unit_addr =\r\nlcu->uac->unit[private->uid.real_unit_addr].base_ua;\r\nuid = private->uid;\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\nif (lcu->pav == NO_PAV) {\r\nlist_move(&device->alias_list, &lcu->active_devices);\r\nreturn 0;\r\n}\r\ngroup = _find_group(lcu, &uid);\r\nif (!group) {\r\ngroup = kzalloc(sizeof(*group), GFP_ATOMIC);\r\nif (!group)\r\nreturn -ENOMEM;\r\nmemcpy(group->uid.vendor, uid.vendor, sizeof(uid.vendor));\r\nmemcpy(group->uid.serial, uid.serial, sizeof(uid.serial));\r\ngroup->uid.ssid = uid.ssid;\r\nif (uid.type == UA_BASE_DEVICE)\r\ngroup->uid.base_unit_addr = uid.real_unit_addr;\r\nelse\r\ngroup->uid.base_unit_addr = uid.base_unit_addr;\r\nmemcpy(group->uid.vduit, uid.vduit, sizeof(uid.vduit));\r\nINIT_LIST_HEAD(&group->group);\r\nINIT_LIST_HEAD(&group->baselist);\r\nINIT_LIST_HEAD(&group->aliaslist);\r\nlist_add(&group->group, &lcu->grouplist);\r\n}\r\nif (uid.type == UA_BASE_DEVICE)\r\nlist_move(&device->alias_list, &group->baselist);\r\nelse\r\nlist_move(&device->alias_list, &group->aliaslist);\r\nprivate->pavgroup = group;\r\nreturn 0;\r\n}\r\nstatic void _remove_device_from_lcu(struct alias_lcu *lcu,\r\nstruct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private = device->private;\r\nstruct alias_pav_group *group;\r\nlist_move(&device->alias_list, &lcu->inactive_devices);\r\ngroup = private->pavgroup;\r\nif (!group)\r\nreturn;\r\nprivate->pavgroup = NULL;\r\nif (list_empty(&group->baselist) && list_empty(&group->aliaslist)) {\r\nlist_del(&group->group);\r\nkfree(group);\r\nreturn;\r\n}\r\nif (group->next == device)\r\ngroup->next = NULL;\r\n}\r\nstatic int\r\nsuborder_not_supported(struct dasd_ccw_req *cqr)\r\n{\r\nchar *sense;\r\nchar reason;\r\nchar msg_format;\r\nchar msg_no;\r\nsense = dasd_get_sense(&cqr->irb);\r\nif (!sense)\r\nreturn 0;\r\nreason = sense[0];\r\nmsg_format = (sense[7] & 0xF0);\r\nmsg_no = (sense[7] & 0x0F);\r\nif ((reason == 0x80) && (msg_format == 0x00) && (msg_no == 0x04))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int read_unit_address_configuration(struct dasd_device *device,\r\nstruct alias_lcu *lcu)\r\n{\r\nstruct dasd_psf_prssd_data *prssdp;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nint rc;\r\nunsigned long flags;\r\ncqr = dasd_kmalloc_request(DASD_ECKD_MAGIC, 1 + 1 ,\r\n(sizeof(struct dasd_psf_prssd_data)),\r\ndevice);\r\nif (IS_ERR(cqr))\r\nreturn PTR_ERR(cqr);\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\nclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\ncqr->retries = 10;\r\ncqr->expires = 20 * HZ;\r\nprssdp = (struct dasd_psf_prssd_data *) cqr->data;\r\nmemset(prssdp, 0, sizeof(struct dasd_psf_prssd_data));\r\nprssdp->order = PSF_ORDER_PRSSD;\r\nprssdp->suborder = 0x0e;\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_PSF;\r\nccw->count = sizeof(struct dasd_psf_prssd_data);\r\nccw->flags |= CCW_FLAG_CC;\r\nccw->cda = (__u32)(addr_t) prssdp;\r\nmemset(lcu->uac, 0, sizeof(*(lcu->uac)));\r\nccw++;\r\nccw->cmd_code = DASD_ECKD_CCW_RSSD;\r\nccw->count = sizeof(*(lcu->uac));\r\nccw->cda = (__u32)(addr_t) lcu->uac;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nlcu->flags &= ~NEED_UAC_UPDATE;\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\ndo {\r\nrc = dasd_sleep_on(cqr);\r\nif (rc && suborder_not_supported(cqr))\r\nreturn -EOPNOTSUPP;\r\n} while (rc && (cqr->retries > 0));\r\nif (rc) {\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nlcu->flags |= NEED_UAC_UPDATE;\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\n}\r\ndasd_kfree_request(cqr, cqr->memdev);\r\nreturn rc;\r\n}\r\nstatic int _lcu_update(struct dasd_device *refdev, struct alias_lcu *lcu)\r\n{\r\nunsigned long flags;\r\nstruct alias_pav_group *pavgroup, *tempgroup;\r\nstruct dasd_device *device, *tempdev;\r\nint i, rc;\r\nstruct dasd_eckd_private *private;\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nlist_for_each_entry_safe(pavgroup, tempgroup, &lcu->grouplist, group) {\r\nlist_for_each_entry_safe(device, tempdev, &pavgroup->baselist,\r\nalias_list) {\r\nlist_move(&device->alias_list, &lcu->active_devices);\r\nprivate = device->private;\r\nprivate->pavgroup = NULL;\r\n}\r\nlist_for_each_entry_safe(device, tempdev, &pavgroup->aliaslist,\r\nalias_list) {\r\nlist_move(&device->alias_list, &lcu->active_devices);\r\nprivate = device->private;\r\nprivate->pavgroup = NULL;\r\n}\r\nlist_del(&pavgroup->group);\r\nkfree(pavgroup);\r\n}\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\nrc = read_unit_address_configuration(refdev, lcu);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nlcu->pav = NO_PAV;\r\nfor (i = 0; i < MAX_DEVICES_PER_LCU; ++i) {\r\nswitch (lcu->uac->unit[i].ua_type) {\r\ncase UA_BASE_PAV_ALIAS:\r\nlcu->pav = BASE_PAV;\r\nbreak;\r\ncase UA_HYPER_PAV_ALIAS:\r\nlcu->pav = HYPER_PAV;\r\nbreak;\r\n}\r\nif (lcu->pav != NO_PAV)\r\nbreak;\r\n}\r\nlist_for_each_entry_safe(device, tempdev, &lcu->active_devices,\r\nalias_list) {\r\n_add_device_to_lcu(lcu, device, refdev);\r\n}\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void lcu_update_work(struct work_struct *work)\r\n{\r\nstruct alias_lcu *lcu;\r\nstruct read_uac_work_data *ruac_data;\r\nstruct dasd_device *device;\r\nunsigned long flags;\r\nint rc;\r\nruac_data = container_of(work, struct read_uac_work_data, dwork.work);\r\nlcu = container_of(ruac_data, struct alias_lcu, ruac_data);\r\ndevice = ruac_data->device;\r\nrc = _lcu_update(device, lcu);\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nif ((rc && (rc != -EOPNOTSUPP)) || (lcu->flags & NEED_UAC_UPDATE)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "could not update"\r\n" alias data in lcu (rc = %d), retry later", rc);\r\nif (!schedule_delayed_work(&lcu->ruac_data.dwork, 30*HZ))\r\ndasd_put_device(device);\r\n} else {\r\ndasd_put_device(device);\r\nlcu->ruac_data.device = NULL;\r\nlcu->flags &= ~UPDATE_PENDING;\r\n}\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\n}\r\nstatic int _schedule_lcu_update(struct alias_lcu *lcu,\r\nstruct dasd_device *device)\r\n{\r\nstruct dasd_device *usedev = NULL;\r\nstruct alias_pav_group *group;\r\nlcu->flags |= NEED_UAC_UPDATE;\r\nif (lcu->ruac_data.device) {\r\nreturn 0;\r\n}\r\nif (device && !list_empty(&device->alias_list))\r\nusedev = device;\r\nif (!usedev && !list_empty(&lcu->grouplist)) {\r\ngroup = list_first_entry(&lcu->grouplist,\r\nstruct alias_pav_group, group);\r\nif (!list_empty(&group->baselist))\r\nusedev = list_first_entry(&group->baselist,\r\nstruct dasd_device,\r\nalias_list);\r\nelse if (!list_empty(&group->aliaslist))\r\nusedev = list_first_entry(&group->aliaslist,\r\nstruct dasd_device,\r\nalias_list);\r\n}\r\nif (!usedev && !list_empty(&lcu->active_devices)) {\r\nusedev = list_first_entry(&lcu->active_devices,\r\nstruct dasd_device, alias_list);\r\n}\r\nif (!usedev)\r\nreturn -EINVAL;\r\ndasd_get_device(usedev);\r\nlcu->ruac_data.device = usedev;\r\nif (!schedule_delayed_work(&lcu->ruac_data.dwork, 0))\r\ndasd_put_device(usedev);\r\nreturn 0;\r\n}\r\nint dasd_alias_add_device(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private = device->private;\r\nstruct alias_lcu *lcu;\r\nunsigned long flags;\r\nint rc;\r\nlcu = private->lcu;\r\nrc = 0;\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nif (!(lcu->flags & UPDATE_PENDING)) {\r\nrc = _add_device_to_lcu(lcu, device, device);\r\nif (rc)\r\nlcu->flags |= UPDATE_PENDING;\r\n}\r\nif (lcu->flags & UPDATE_PENDING) {\r\nlist_move(&device->alias_list, &lcu->active_devices);\r\n_schedule_lcu_update(lcu, device);\r\n}\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\nreturn rc;\r\n}\r\nint dasd_alias_update_add_device(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private = device->private;\r\nprivate->lcu->flags |= UPDATE_PENDING;\r\nreturn dasd_alias_add_device(device);\r\n}\r\nint dasd_alias_remove_device(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private = device->private;\r\nstruct alias_lcu *lcu = private->lcu;\r\nunsigned long flags;\r\nif (!lcu)\r\nreturn 0;\r\nspin_lock_irqsave(&lcu->lock, flags);\r\n_remove_device_from_lcu(lcu, device);\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\nreturn 0;\r\n}\r\nstruct dasd_device *dasd_alias_get_start_dev(struct dasd_device *base_device)\r\n{\r\nstruct dasd_eckd_private *alias_priv, *private = base_device->private;\r\nstruct alias_pav_group *group = private->pavgroup;\r\nstruct alias_lcu *lcu = private->lcu;\r\nstruct dasd_device *alias_device;\r\nunsigned long flags;\r\nif (!group || !lcu)\r\nreturn NULL;\r\nif (lcu->pav == NO_PAV ||\r\nlcu->flags & (NEED_UAC_UPDATE | UPDATE_PENDING))\r\nreturn NULL;\r\nif (unlikely(!(private->features.feature[8] & 0x01))) {\r\nDBF_DEV_EVENT(DBF_ERR, base_device, "%s",\r\n"Prefix not enabled with PAV enabled\n");\r\nreturn NULL;\r\n}\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nalias_device = group->next;\r\nif (!alias_device) {\r\nif (list_empty(&group->aliaslist)) {\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\nreturn NULL;\r\n} else {\r\nalias_device = list_first_entry(&group->aliaslist,\r\nstruct dasd_device,\r\nalias_list);\r\n}\r\n}\r\nif (list_is_last(&alias_device->alias_list, &group->aliaslist))\r\ngroup->next = list_first_entry(&group->aliaslist,\r\nstruct dasd_device, alias_list);\r\nelse\r\ngroup->next = list_first_entry(&alias_device->alias_list,\r\nstruct dasd_device, alias_list);\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\nalias_priv = alias_device->private;\r\nif ((alias_priv->count < private->count) && !alias_device->stopped &&\r\n!test_bit(DASD_FLAG_OFFLINE, &alias_device->flags))\r\nreturn alias_device;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic int reset_summary_unit_check(struct alias_lcu *lcu,\r\nstruct dasd_device *device,\r\nchar reason)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nint rc = 0;\r\nstruct ccw1 *ccw;\r\ncqr = lcu->rsu_cqr;\r\nstrncpy((char *) &cqr->magic, "ECKD", 4);\r\nASCEBC((char *) &cqr->magic, 4);\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_RSCK;\r\nccw->flags = CCW_FLAG_SLI;\r\nccw->count = 16;\r\nccw->cda = (__u32)(addr_t) cqr->data;\r\n((char *)cqr->data)[0] = reason;\r\nclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\ncqr->retries = 255;\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\ncqr->block = NULL;\r\ncqr->expires = 5 * HZ;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nrc = dasd_sleep_on_immediatly(cqr);\r\nreturn rc;\r\n}\r\nstatic void _restart_all_base_devices_on_lcu(struct alias_lcu *lcu)\r\n{\r\nstruct alias_pav_group *pavgroup;\r\nstruct dasd_device *device;\r\nstruct dasd_eckd_private *private;\r\nlist_for_each_entry(device, &lcu->active_devices, alias_list) {\r\nprivate = device->private;\r\nif (private->uid.type != UA_BASE_DEVICE)\r\ncontinue;\r\ndasd_schedule_block_bh(device->block);\r\ndasd_schedule_device_bh(device);\r\n}\r\nlist_for_each_entry(device, &lcu->inactive_devices, alias_list) {\r\nprivate = device->private;\r\nif (private->uid.type != UA_BASE_DEVICE)\r\ncontinue;\r\ndasd_schedule_block_bh(device->block);\r\ndasd_schedule_device_bh(device);\r\n}\r\nlist_for_each_entry(pavgroup, &lcu->grouplist, group) {\r\nlist_for_each_entry(device, &pavgroup->baselist, alias_list) {\r\ndasd_schedule_block_bh(device->block);\r\ndasd_schedule_device_bh(device);\r\n}\r\n}\r\n}\r\nstatic void flush_all_alias_devices_on_lcu(struct alias_lcu *lcu)\r\n{\r\nstruct alias_pav_group *pavgroup;\r\nstruct dasd_device *device, *temp;\r\nstruct dasd_eckd_private *private;\r\nint rc;\r\nunsigned long flags;\r\nLIST_HEAD(active);\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nlist_for_each_entry_safe(device, temp, &lcu->active_devices,\r\nalias_list) {\r\nprivate = device->private;\r\nif (private->uid.type == UA_BASE_DEVICE)\r\ncontinue;\r\nlist_move(&device->alias_list, &active);\r\n}\r\nlist_for_each_entry(pavgroup, &lcu->grouplist, group) {\r\nlist_splice_init(&pavgroup->aliaslist, &active);\r\n}\r\nwhile (!list_empty(&active)) {\r\ndevice = list_first_entry(&active, struct dasd_device,\r\nalias_list);\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\nrc = dasd_flush_device_queue(device);\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nif (device == list_first_entry(&active,\r\nstruct dasd_device, alias_list)) {\r\nlist_move(&device->alias_list, &lcu->active_devices);\r\nprivate = device->private;\r\nprivate->pavgroup = NULL;\r\n}\r\n}\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\n}\r\nstatic void _stop_all_devices_on_lcu(struct alias_lcu *lcu)\r\n{\r\nstruct alias_pav_group *pavgroup;\r\nstruct dasd_device *device;\r\nlist_for_each_entry(device, &lcu->active_devices, alias_list) {\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\ndasd_device_set_stop_bits(device, DASD_STOPPED_SU);\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\n}\r\nlist_for_each_entry(device, &lcu->inactive_devices, alias_list) {\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\ndasd_device_set_stop_bits(device, DASD_STOPPED_SU);\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\n}\r\nlist_for_each_entry(pavgroup, &lcu->grouplist, group) {\r\nlist_for_each_entry(device, &pavgroup->baselist, alias_list) {\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\ndasd_device_set_stop_bits(device, DASD_STOPPED_SU);\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\n}\r\nlist_for_each_entry(device, &pavgroup->aliaslist, alias_list) {\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\ndasd_device_set_stop_bits(device, DASD_STOPPED_SU);\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\n}\r\n}\r\n}\r\nstatic void _unstop_all_devices_on_lcu(struct alias_lcu *lcu)\r\n{\r\nstruct alias_pav_group *pavgroup;\r\nstruct dasd_device *device;\r\nlist_for_each_entry(device, &lcu->active_devices, alias_list) {\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\ndasd_device_remove_stop_bits(device, DASD_STOPPED_SU);\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\n}\r\nlist_for_each_entry(device, &lcu->inactive_devices, alias_list) {\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\ndasd_device_remove_stop_bits(device, DASD_STOPPED_SU);\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\n}\r\nlist_for_each_entry(pavgroup, &lcu->grouplist, group) {\r\nlist_for_each_entry(device, &pavgroup->baselist, alias_list) {\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\ndasd_device_remove_stop_bits(device, DASD_STOPPED_SU);\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\n}\r\nlist_for_each_entry(device, &pavgroup->aliaslist, alias_list) {\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\ndasd_device_remove_stop_bits(device, DASD_STOPPED_SU);\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\n}\r\n}\r\n}\r\nstatic void summary_unit_check_handling_work(struct work_struct *work)\r\n{\r\nstruct alias_lcu *lcu;\r\nstruct summary_unit_check_work_data *suc_data;\r\nunsigned long flags;\r\nstruct dasd_device *device;\r\nsuc_data = container_of(work, struct summary_unit_check_work_data,\r\nworker);\r\nlcu = container_of(suc_data, struct alias_lcu, suc_data);\r\ndevice = suc_data->device;\r\nflush_all_alias_devices_on_lcu(lcu);\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\ndasd_device_remove_stop_bits(device,\r\n(DASD_STOPPED_SU | DASD_STOPPED_PENDING));\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nreset_summary_unit_check(lcu, device, suc_data->reason);\r\nspin_lock_irqsave(&lcu->lock, flags);\r\n_unstop_all_devices_on_lcu(lcu);\r\n_restart_all_base_devices_on_lcu(lcu);\r\n_schedule_lcu_update(lcu, device);\r\nlcu->suc_data.device = NULL;\r\ndasd_put_device(device);\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\n}\r\nvoid dasd_alias_handle_summary_unit_check(struct work_struct *work)\r\n{\r\nstruct dasd_device *device = container_of(work, struct dasd_device,\r\nsuc_work);\r\nstruct dasd_eckd_private *private = device->private;\r\nstruct alias_lcu *lcu;\r\nunsigned long flags;\r\nlcu = private->lcu;\r\nif (!lcu) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"device not ready to handle summary"\r\n" unit check (no lcu structure)");\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&lcu->lock, flags);\r\nif (list_empty(&device->alias_list)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"device is in offline processing,"\r\n" don't do summary unit check handling");\r\ngoto out_unlock;\r\n}\r\nif (lcu->suc_data.device) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"previous instance of summary unit check worker"\r\n" still pending");\r\ngoto out_unlock;\r\n}\r\n_stop_all_devices_on_lcu(lcu);\r\nlcu->flags |= NEED_UAC_UPDATE | UPDATE_PENDING;\r\nlcu->suc_data.reason = private->suc_reason;\r\nlcu->suc_data.device = device;\r\ndasd_get_device(device);\r\nif (!schedule_work(&lcu->suc_data.worker))\r\ndasd_put_device(device);\r\nout_unlock:\r\nspin_unlock_irqrestore(&lcu->lock, flags);\r\nout:\r\nclear_bit(DASD_FLAG_SUC, &device->flags);\r\ndasd_put_device(device);\r\n}
