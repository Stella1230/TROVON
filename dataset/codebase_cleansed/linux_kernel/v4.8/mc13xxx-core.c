void mc13xxx_lock(struct mc13xxx *mc13xxx)\r\n{\r\nif (!mutex_trylock(&mc13xxx->lock)) {\r\ndev_dbg(mc13xxx->dev, "wait for %s from %ps\n",\r\n__func__, __builtin_return_address(0));\r\nmutex_lock(&mc13xxx->lock);\r\n}\r\ndev_dbg(mc13xxx->dev, "%s from %ps\n",\r\n__func__, __builtin_return_address(0));\r\n}\r\nvoid mc13xxx_unlock(struct mc13xxx *mc13xxx)\r\n{\r\ndev_dbg(mc13xxx->dev, "%s from %ps\n",\r\n__func__, __builtin_return_address(0));\r\nmutex_unlock(&mc13xxx->lock);\r\n}\r\nint mc13xxx_reg_read(struct mc13xxx *mc13xxx, unsigned int offset, u32 *val)\r\n{\r\nint ret;\r\nret = regmap_read(mc13xxx->regmap, offset, val);\r\ndev_vdbg(mc13xxx->dev, "[0x%02x] -> 0x%06x\n", offset, *val);\r\nreturn ret;\r\n}\r\nint mc13xxx_reg_write(struct mc13xxx *mc13xxx, unsigned int offset, u32 val)\r\n{\r\ndev_vdbg(mc13xxx->dev, "[0x%02x] <- 0x%06x\n", offset, val);\r\nif (val >= BIT(24))\r\nreturn -EINVAL;\r\nreturn regmap_write(mc13xxx->regmap, offset, val);\r\n}\r\nint mc13xxx_reg_rmw(struct mc13xxx *mc13xxx, unsigned int offset,\r\nu32 mask, u32 val)\r\n{\r\nBUG_ON(val & ~mask);\r\ndev_vdbg(mc13xxx->dev, "[0x%02x] <- 0x%06x (mask: 0x%06x)\n",\r\noffset, val, mask);\r\nreturn regmap_update_bits(mc13xxx->regmap, offset, mask, val);\r\n}\r\nint mc13xxx_irq_mask(struct mc13xxx *mc13xxx, int irq)\r\n{\r\nint virq = regmap_irq_get_virq(mc13xxx->irq_data, irq);\r\ndisable_irq_nosync(virq);\r\nreturn 0;\r\n}\r\nint mc13xxx_irq_unmask(struct mc13xxx *mc13xxx, int irq)\r\n{\r\nint virq = regmap_irq_get_virq(mc13xxx->irq_data, irq);\r\nenable_irq(virq);\r\nreturn 0;\r\n}\r\nint mc13xxx_irq_status(struct mc13xxx *mc13xxx, int irq,\r\nint *enabled, int *pending)\r\n{\r\nint ret;\r\nunsigned int offmask = irq < 24 ? MC13XXX_IRQMASK0 : MC13XXX_IRQMASK1;\r\nunsigned int offstat = irq < 24 ? MC13XXX_IRQSTAT0 : MC13XXX_IRQSTAT1;\r\nu32 irqbit = 1 << (irq < 24 ? irq : irq - 24);\r\nif (irq < 0 || irq >= ARRAY_SIZE(mc13xxx->irqs))\r\nreturn -EINVAL;\r\nif (enabled) {\r\nu32 mask;\r\nret = mc13xxx_reg_read(mc13xxx, offmask, &mask);\r\nif (ret)\r\nreturn ret;\r\n*enabled = mask & irqbit;\r\n}\r\nif (pending) {\r\nu32 stat;\r\nret = mc13xxx_reg_read(mc13xxx, offstat, &stat);\r\nif (ret)\r\nreturn ret;\r\n*pending = stat & irqbit;\r\n}\r\nreturn 0;\r\n}\r\nint mc13xxx_irq_request(struct mc13xxx *mc13xxx, int irq,\r\nirq_handler_t handler, const char *name, void *dev)\r\n{\r\nint virq = regmap_irq_get_virq(mc13xxx->irq_data, irq);\r\nreturn devm_request_threaded_irq(mc13xxx->dev, virq, NULL, handler,\r\nIRQF_ONESHOT, name, dev);\r\n}\r\nint mc13xxx_irq_free(struct mc13xxx *mc13xxx, int irq, void *dev)\r\n{\r\nint virq = regmap_irq_get_virq(mc13xxx->irq_data, irq);\r\ndevm_free_irq(mc13xxx->dev, virq, dev);\r\nreturn 0;\r\n}\r\nstatic void mc13xxx_print_revision(struct mc13xxx *mc13xxx, u32 revision)\r\n{\r\ndev_info(mc13xxx->dev, "%s: rev: %d.%d, "\r\n"fin: %d, fab: %d, icid: %d/%d\n",\r\nmc13xxx->variant->name,\r\nmaskval(revision, MC13XXX_REVISION_REVFULL),\r\nmaskval(revision, MC13XXX_REVISION_REVMETAL),\r\nmaskval(revision, MC13XXX_REVISION_FIN),\r\nmaskval(revision, MC13XXX_REVISION_FAB),\r\nmaskval(revision, MC13XXX_REVISION_ICID),\r\nmaskval(revision, MC13XXX_REVISION_ICIDCODE));\r\n}\r\nstatic void mc34708_print_revision(struct mc13xxx *mc13xxx, u32 revision)\r\n{\r\ndev_info(mc13xxx->dev, "%s: rev %d.%d, fin: %d, fab: %d\n",\r\nmc13xxx->variant->name,\r\nmaskval(revision, MC34708_REVISION_REVFULL),\r\nmaskval(revision, MC34708_REVISION_REVMETAL),\r\nmaskval(revision, MC34708_REVISION_FIN),\r\nmaskval(revision, MC34708_REVISION_FAB));\r\n}\r\nstatic const char *mc13xxx_get_chipname(struct mc13xxx *mc13xxx)\r\n{\r\nreturn mc13xxx->variant->name;\r\n}\r\nint mc13xxx_get_flags(struct mc13xxx *mc13xxx)\r\n{\r\nreturn mc13xxx->flags;\r\n}\r\nstatic irqreturn_t mc13xxx_handler_adcdone(int irq, void *data)\r\n{\r\nstruct mc13xxx_adcdone_data *adcdone_data = data;\r\ncomplete_all(&adcdone_data->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nint mc13xxx_adc_do_conversion(struct mc13xxx *mc13xxx, unsigned int mode,\r\nunsigned int channel, u8 ato, bool atox,\r\nunsigned int *sample)\r\n{\r\nu32 adc0, adc1, old_adc0;\r\nint i, ret;\r\nstruct mc13xxx_adcdone_data adcdone_data = {\r\n.mc13xxx = mc13xxx,\r\n};\r\ninit_completion(&adcdone_data.done);\r\ndev_dbg(mc13xxx->dev, "%s\n", __func__);\r\nmc13xxx_lock(mc13xxx);\r\nif (mc13xxx->adcflags & MC13XXX_ADC_WORKING) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nmc13xxx->adcflags |= MC13XXX_ADC_WORKING;\r\nmc13xxx_reg_read(mc13xxx, MC13XXX_ADC0, &old_adc0);\r\nadc0 = MC13XXX_ADC0_ADINC1 | MC13XXX_ADC0_ADINC2;\r\nadc1 = MC13XXX_ADC1_ADEN | MC13XXX_ADC1_ADTRIGIGN | MC13XXX_ADC1_ASC;\r\nif (channel > 7)\r\nadc1 |= MC13XXX_ADC1_ADSEL;\r\nswitch (mode) {\r\ncase MC13XXX_ADC_MODE_TS:\r\nadc0 |= MC13XXX_ADC0_ADREFEN | MC13XXX_ADC0_TSMOD0 |\r\nMC13XXX_ADC0_TSMOD1;\r\nadc1 |= 4 << MC13XXX_ADC1_CHAN1_SHIFT;\r\nbreak;\r\ncase MC13XXX_ADC_MODE_SINGLE_CHAN:\r\nadc0 |= old_adc0 & MC13XXX_ADC0_CONFIG_MASK;\r\nadc1 |= (channel & 0x7) << MC13XXX_ADC1_CHAN0_SHIFT;\r\nadc1 |= MC13XXX_ADC1_RAND;\r\nbreak;\r\ncase MC13XXX_ADC_MODE_MULT_CHAN:\r\nadc0 |= old_adc0 & MC13XXX_ADC0_CONFIG_MASK;\r\nadc1 |= 4 << MC13XXX_ADC1_CHAN1_SHIFT;\r\nbreak;\r\ndefault:\r\nmc13xxx_unlock(mc13xxx);\r\nreturn -EINVAL;\r\n}\r\nadc1 |= ato << MC13783_ADC1_ATO_SHIFT;\r\nif (atox)\r\nadc1 |= MC13783_ADC1_ATOX;\r\ndev_dbg(mc13xxx->dev, "%s: request irq\n", __func__);\r\nmc13xxx_irq_request(mc13xxx, MC13XXX_IRQ_ADCDONE,\r\nmc13xxx_handler_adcdone, __func__, &adcdone_data);\r\nmc13xxx_reg_write(mc13xxx, MC13XXX_ADC0, adc0);\r\nmc13xxx_reg_write(mc13xxx, MC13XXX_ADC1, adc1);\r\nmc13xxx_unlock(mc13xxx);\r\nret = wait_for_completion_interruptible_timeout(&adcdone_data.done, HZ);\r\nif (!ret)\r\nret = -ETIMEDOUT;\r\nmc13xxx_lock(mc13xxx);\r\nmc13xxx_irq_free(mc13xxx, MC13XXX_IRQ_ADCDONE, &adcdone_data);\r\nif (ret > 0)\r\nfor (i = 0; i < 4; ++i) {\r\nret = mc13xxx_reg_read(mc13xxx,\r\nMC13XXX_ADC2, &sample[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nif (mode == MC13XXX_ADC_MODE_TS)\r\nmc13xxx_reg_write(mc13xxx, MC13XXX_ADC0, old_adc0);\r\nmc13xxx->adcflags &= ~MC13XXX_ADC_WORKING;\r\nout:\r\nmc13xxx_unlock(mc13xxx);\r\nreturn ret;\r\n}\r\nstatic int mc13xxx_add_subdevice_pdata(struct mc13xxx *mc13xxx,\r\nconst char *format, void *pdata, size_t pdata_size)\r\n{\r\nchar buf[30];\r\nconst char *name = mc13xxx_get_chipname(mc13xxx);\r\nstruct mfd_cell cell = {\r\n.platform_data = pdata,\r\n.pdata_size = pdata_size,\r\n};\r\nif (snprintf(buf, sizeof(buf), format, name) > sizeof(buf))\r\nreturn -E2BIG;\r\ncell.name = kmemdup(buf, strlen(buf) + 1, GFP_KERNEL);\r\nif (!cell.name)\r\nreturn -ENOMEM;\r\nreturn mfd_add_devices(mc13xxx->dev, -1, &cell, 1, NULL, 0,\r\nregmap_irq_get_domain(mc13xxx->irq_data));\r\n}\r\nstatic int mc13xxx_add_subdevice(struct mc13xxx *mc13xxx, const char *format)\r\n{\r\nreturn mc13xxx_add_subdevice_pdata(mc13xxx, format, NULL, 0);\r\n}\r\nstatic int mc13xxx_probe_flags_dt(struct mc13xxx *mc13xxx)\r\n{\r\nstruct device_node *np = mc13xxx->dev->of_node;\r\nif (!np)\r\nreturn -ENODEV;\r\nif (of_property_read_bool(np, "fsl,mc13xxx-uses-adc"))\r\nmc13xxx->flags |= MC13XXX_USE_ADC;\r\nif (of_property_read_bool(np, "fsl,mc13xxx-uses-codec"))\r\nmc13xxx->flags |= MC13XXX_USE_CODEC;\r\nif (of_property_read_bool(np, "fsl,mc13xxx-uses-rtc"))\r\nmc13xxx->flags |= MC13XXX_USE_RTC;\r\nif (of_property_read_bool(np, "fsl,mc13xxx-uses-touch"))\r\nmc13xxx->flags |= MC13XXX_USE_TOUCHSCREEN;\r\nreturn 0;\r\n}\r\nstatic inline int mc13xxx_probe_flags_dt(struct mc13xxx *mc13xxx)\r\n{\r\nreturn -ENODEV;\r\n}\r\nint mc13xxx_common_init(struct device *dev)\r\n{\r\nstruct mc13xxx_platform_data *pdata = dev_get_platdata(dev);\r\nstruct mc13xxx *mc13xxx = dev_get_drvdata(dev);\r\nu32 revision;\r\nint i, ret;\r\nmc13xxx->dev = dev;\r\nret = mc13xxx_reg_read(mc13xxx, MC13XXX_REVISION, &revision);\r\nif (ret)\r\nreturn ret;\r\nmc13xxx->variant->print_revision(mc13xxx, revision);\r\nret = mc13xxx_reg_rmw(mc13xxx, MC13XXX_PWRCTRL,\r\nMC13XXX_PWRCTRL_WDIRESET, MC13XXX_PWRCTRL_WDIRESET);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(mc13xxx->irqs); i++) {\r\nmc13xxx->irqs[i].reg_offset = i / MC13XXX_IRQ_PER_REG;\r\nmc13xxx->irqs[i].mask = BIT(i % MC13XXX_IRQ_PER_REG);\r\n}\r\nmc13xxx->irq_chip.name = dev_name(dev);\r\nmc13xxx->irq_chip.status_base = MC13XXX_IRQSTAT0;\r\nmc13xxx->irq_chip.mask_base = MC13XXX_IRQMASK0;\r\nmc13xxx->irq_chip.ack_base = MC13XXX_IRQSTAT0;\r\nmc13xxx->irq_chip.irq_reg_stride = MC13XXX_IRQSTAT1 - MC13XXX_IRQSTAT0;\r\nmc13xxx->irq_chip.init_ack_masked = true;\r\nmc13xxx->irq_chip.use_ack = true;\r\nmc13xxx->irq_chip.num_regs = MC13XXX_IRQ_REG_CNT;\r\nmc13xxx->irq_chip.irqs = mc13xxx->irqs;\r\nmc13xxx->irq_chip.num_irqs = ARRAY_SIZE(mc13xxx->irqs);\r\nret = regmap_add_irq_chip(mc13xxx->regmap, mc13xxx->irq, IRQF_ONESHOT,\r\n0, &mc13xxx->irq_chip, &mc13xxx->irq_data);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&mc13xxx->lock);\r\nif (mc13xxx_probe_flags_dt(mc13xxx) < 0 && pdata)\r\nmc13xxx->flags = pdata->flags;\r\nif (pdata) {\r\nmc13xxx_add_subdevice_pdata(mc13xxx, "%s-regulator",\r\n&pdata->regulators, sizeof(pdata->regulators));\r\nmc13xxx_add_subdevice_pdata(mc13xxx, "%s-led",\r\npdata->leds, sizeof(*pdata->leds));\r\nmc13xxx_add_subdevice_pdata(mc13xxx, "%s-pwrbutton",\r\npdata->buttons, sizeof(*pdata->buttons));\r\nif (mc13xxx->flags & MC13XXX_USE_CODEC)\r\nmc13xxx_add_subdevice_pdata(mc13xxx, "%s-codec",\r\npdata->codec, sizeof(*pdata->codec));\r\nif (mc13xxx->flags & MC13XXX_USE_TOUCHSCREEN)\r\nmc13xxx_add_subdevice_pdata(mc13xxx, "%s-ts",\r\n&pdata->touch, sizeof(pdata->touch));\r\n} else {\r\nmc13xxx_add_subdevice(mc13xxx, "%s-regulator");\r\nmc13xxx_add_subdevice(mc13xxx, "%s-led");\r\nmc13xxx_add_subdevice(mc13xxx, "%s-pwrbutton");\r\nif (mc13xxx->flags & MC13XXX_USE_CODEC)\r\nmc13xxx_add_subdevice(mc13xxx, "%s-codec");\r\nif (mc13xxx->flags & MC13XXX_USE_TOUCHSCREEN)\r\nmc13xxx_add_subdevice(mc13xxx, "%s-ts");\r\n}\r\nif (mc13xxx->flags & MC13XXX_USE_ADC)\r\nmc13xxx_add_subdevice(mc13xxx, "%s-adc");\r\nif (mc13xxx->flags & MC13XXX_USE_RTC)\r\nmc13xxx_add_subdevice(mc13xxx, "%s-rtc");\r\nreturn 0;\r\n}\r\nint mc13xxx_common_exit(struct device *dev)\r\n{\r\nstruct mc13xxx *mc13xxx = dev_get_drvdata(dev);\r\nmfd_remove_devices(dev);\r\nregmap_del_irq_chip(mc13xxx->irq, mc13xxx->irq_data);\r\nmutex_destroy(&mc13xxx->lock);\r\nreturn 0;\r\n}
