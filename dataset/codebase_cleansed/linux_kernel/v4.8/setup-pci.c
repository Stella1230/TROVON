static int ide_setup_pci_baseregs(struct pci_dev *dev, const char *name)\r\n{\r\nu8 progif = 0;\r\nif (pci_read_config_byte(dev, PCI_CLASS_PROG, &progif) ||\r\n(progif & 5) != 5) {\r\nif ((progif & 0xa) != 0xa) {\r\nprintk(KERN_INFO "%s %s: device not capable of full "\r\n"native PCI mode\n", name, pci_name(dev));\r\nreturn -EOPNOTSUPP;\r\n}\r\nprintk(KERN_INFO "%s %s: placing both ports into native PCI "\r\n"mode\n", name, pci_name(dev));\r\n(void) pci_write_config_byte(dev, PCI_CLASS_PROG, progif|5);\r\nif (pci_read_config_byte(dev, PCI_CLASS_PROG, &progif) ||\r\n(progif & 5) != 5) {\r\nprintk(KERN_ERR "%s %s: rewrite of PROGIF failed, "\r\n"wanted 0x%04x, got 0x%04x\n",\r\nname, pci_name(dev), progif | 5, progif);\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ide_pci_clear_simplex(unsigned long dma_base, const char *name)\r\n{\r\nu8 dma_stat = inb(dma_base + 2);\r\noutb(dma_stat & 0x60, dma_base + 2);\r\ndma_stat = inb(dma_base + 2);\r\nreturn (dma_stat & 0x80) ? 1 : 0;\r\n}\r\nunsigned long ide_pci_dma_base(ide_hwif_t *hwif, const struct ide_port_info *d)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long dma_base = 0;\r\nif (hwif->host_flags & IDE_HFLAG_MMIO)\r\nreturn hwif->dma_base;\r\nif (hwif->mate && hwif->mate->dma_base) {\r\ndma_base = hwif->mate->dma_base - (hwif->channel ? 0 : 8);\r\n} else {\r\nu8 baridx = (d->host_flags & IDE_HFLAG_CS5520) ? 2 : 4;\r\ndma_base = pci_resource_start(dev, baridx);\r\nif (dma_base == 0) {\r\nprintk(KERN_ERR "%s %s: DMA base is invalid\n",\r\nd->name, pci_name(dev));\r\nreturn 0;\r\n}\r\n}\r\nif (hwif->channel)\r\ndma_base += 8;\r\nreturn dma_base;\r\n}\r\nint ide_pci_check_simplex(ide_hwif_t *hwif, const struct ide_port_info *d)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu8 dma_stat;\r\nif (d->host_flags & (IDE_HFLAG_MMIO | IDE_HFLAG_CS5520))\r\ngoto out;\r\nif (d->host_flags & IDE_HFLAG_CLEAR_SIMPLEX) {\r\nif (ide_pci_clear_simplex(hwif->dma_base, d->name))\r\nprintk(KERN_INFO "%s %s: simplex device: DMA forced\n",\r\nd->name, pci_name(dev));\r\ngoto out;\r\n}\r\ndma_stat = hwif->dma_ops->dma_sff_read_status(hwif);\r\nif ((dma_stat & 0x80) && hwif->mate && hwif->mate->dma_base) {\r\nprintk(KERN_INFO "%s %s: simplex device: DMA disabled\n",\r\nd->name, pci_name(dev));\r\nreturn -1;\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nint ide_pci_set_master(struct pci_dev *dev, const char *name)\r\n{\r\nu16 pcicmd;\r\npci_read_config_word(dev, PCI_COMMAND, &pcicmd);\r\nif ((pcicmd & PCI_COMMAND_MASTER) == 0) {\r\npci_set_master(dev);\r\nif (pci_read_config_word(dev, PCI_COMMAND, &pcicmd) ||\r\n(pcicmd & PCI_COMMAND_MASTER) == 0) {\r\nprintk(KERN_ERR "%s %s: error updating PCICMD\n",\r\nname, pci_name(dev));\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid ide_setup_pci_noise(struct pci_dev *dev, const struct ide_port_info *d)\r\n{\r\nprintk(KERN_INFO "%s %s: IDE controller (0x%04x:0x%04x rev 0x%02x)\n",\r\nd->name, pci_name(dev),\r\ndev->vendor, dev->device, dev->revision);\r\n}\r\nstatic int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)\r\n{\r\nint ret, bars;\r\nif (pci_enable_device(dev)) {\r\nret = pci_enable_device_io(dev);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "%s %s: couldn't enable device\n",\r\nd->name, pci_name(dev));\r\ngoto out;\r\n}\r\nprintk(KERN_WARNING "%s %s: BIOS configuration fixed\n",\r\nd->name, pci_name(dev));\r\n}\r\nret = dma_set_mask(&dev->dev, DMA_BIT_MASK(32));\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s %s: can't set DMA mask\n",\r\nd->name, pci_name(dev));\r\ngoto out;\r\n}\r\nif (d->host_flags & IDE_HFLAG_SINGLE)\r\nbars = (1 << 2) - 1;\r\nelse\r\nbars = (1 << 4) - 1;\r\nif ((d->host_flags & IDE_HFLAG_NO_DMA) == 0) {\r\nif (d->host_flags & IDE_HFLAG_CS5520)\r\nbars |= (1 << 2);\r\nelse\r\nbars |= (1 << 4);\r\n}\r\nret = pci_request_selected_regions(dev, bars, d->name);\r\nif (ret < 0)\r\nprintk(KERN_ERR "%s %s: can't reserve resources\n",\r\nd->name, pci_name(dev));\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ide_pci_configure(struct pci_dev *dev, const struct ide_port_info *d)\r\n{\r\nu16 pcicmd = 0;\r\nif (ide_setup_pci_baseregs(dev, d->name) ||\r\npci_write_config_word(dev, PCI_COMMAND, pcicmd | PCI_COMMAND_IO)) {\r\nprintk(KERN_INFO "%s %s: device disabled (BIOS)\n",\r\nd->name, pci_name(dev));\r\nreturn -ENODEV;\r\n}\r\nif (pci_read_config_word(dev, PCI_COMMAND, &pcicmd)) {\r\nprintk(KERN_ERR "%s %s: error accessing PCI regs\n",\r\nd->name, pci_name(dev));\r\nreturn -EIO;\r\n}\r\nif (!(pcicmd & PCI_COMMAND_IO)) {\r\nprintk(KERN_ERR "%s %s: unable to enable IDE controller\n",\r\nd->name, pci_name(dev));\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *d,\r\nint bar)\r\n{\r\nulong flags = pci_resource_flags(dev, bar);\r\nif (!flags || pci_resource_len(dev, bar) == 0)\r\nreturn 0;\r\nif (flags & IORESOURCE_IO)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int ide_hw_configure(struct pci_dev *dev, const struct ide_port_info *d,\r\nunsigned int port, struct ide_hw *hw)\r\n{\r\nunsigned long ctl = 0, base = 0;\r\nif ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {\r\nif (ide_pci_check_iomem(dev, d, 2 * port) ||\r\nide_pci_check_iomem(dev, d, 2 * port + 1)) {\r\nprintk(KERN_ERR "%s %s: I/O baseregs (BIOS) are "\r\n"reported as MEM for port %d!\n",\r\nd->name, pci_name(dev), port);\r\nreturn -EINVAL;\r\n}\r\nctl = pci_resource_start(dev, 2*port+1);\r\nbase = pci_resource_start(dev, 2*port);\r\n} else {\r\nctl = port ? 0x374 : 0x3f4;\r\nbase = port ? 0x170 : 0x1f0;\r\n}\r\nif (!base || !ctl) {\r\nprintk(KERN_ERR "%s %s: bad PCI BARs for port %d, skipping\n",\r\nd->name, pci_name(dev), port);\r\nreturn -EINVAL;\r\n}\r\nmemset(hw, 0, sizeof(*hw));\r\nhw->dev = &dev->dev;\r\nide_std_init_ports(hw, base, ctl | 2);\r\nreturn 0;\r\n}\r\nint ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nif ((d->host_flags & IDE_HFLAG_NO_AUTODMA) == 0 ||\r\n((dev->class >> 8) == PCI_CLASS_STORAGE_IDE &&\r\n(dev->class & 0x80))) {\r\nunsigned long base = ide_pci_dma_base(hwif, d);\r\nif (base == 0)\r\nreturn -1;\r\nhwif->dma_base = base;\r\nif (hwif->dma_ops == NULL)\r\nhwif->dma_ops = &sff_dma_ops;\r\nif (ide_pci_check_simplex(hwif, d) < 0)\r\nreturn -1;\r\nif (ide_pci_set_master(dev, d->name) < 0)\r\nreturn -1;\r\nif (hwif->host_flags & IDE_HFLAG_MMIO)\r\nprintk(KERN_INFO " %s: MMIO-DMA\n", hwif->name);\r\nelse\r\nprintk(KERN_INFO " %s: BM-DMA at 0x%04lx-0x%04lx\n",\r\nhwif->name, base, base + 7);\r\nhwif->extra_base = base + (hwif->channel ? 8 : 16);\r\nif (ide_allocate_dma_engine(hwif))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ide_setup_pci_controller(struct pci_dev *dev,\r\nconst struct ide_port_info *d, int noisy)\r\n{\r\nint ret;\r\nu16 pcicmd;\r\nif (noisy)\r\nide_setup_pci_noise(dev, d);\r\nret = ide_pci_enable(dev, d);\r\nif (ret < 0)\r\ngoto out;\r\nret = pci_read_config_word(dev, PCI_COMMAND, &pcicmd);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s %s: error accessing PCI regs\n",\r\nd->name, pci_name(dev));\r\ngoto out;\r\n}\r\nif (!(pcicmd & PCI_COMMAND_IO)) {\r\nret = ide_pci_configure(dev, d);\r\nif (ret < 0)\r\ngoto out;\r\nprintk(KERN_INFO "%s %s: device enabled (Linux)\n",\r\nd->name, pci_name(dev));\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nvoid ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d,\r\nstruct ide_hw *hw, struct ide_hw **hws)\r\n{\r\nint channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;\r\nu8 tmp;\r\nfor (port = 0; port < channels; ++port) {\r\nconst struct ide_pci_enablebit *e = &d->enablebits[port];\r\nif (e->reg && (pci_read_config_byte(dev, e->reg, &tmp) ||\r\n(tmp & e->mask) != e->val)) {\r\nprintk(KERN_INFO "%s %s: IDE port disabled\n",\r\nd->name, pci_name(dev));\r\ncontinue;\r\n}\r\nif (ide_hw_configure(dev, d, port, hw + port))\r\ncontinue;\r\n*(hws + port) = hw + port;\r\n}\r\n}\r\nstatic int do_ide_setup_pci_device(struct pci_dev *dev,\r\nconst struct ide_port_info *d,\r\nu8 noisy)\r\n{\r\nint pciirq, ret;\r\npciirq = dev->irq;\r\nret = d->init_chipset ? d->init_chipset(dev) : 0;\r\nif (ret < 0)\r\ngoto out;\r\nif (ide_pci_is_in_compatibility_mode(dev)) {\r\nif (noisy)\r\nprintk(KERN_INFO "%s %s: not 100%% native mode: will "\r\n"probe irqs later\n", d->name, pci_name(dev));\r\npciirq = 0;\r\n} else if (!pciirq && noisy) {\r\nprintk(KERN_WARNING "%s %s: bad irq (%d): will probe later\n",\r\nd->name, pci_name(dev), pciirq);\r\n} else if (noisy) {\r\nprintk(KERN_INFO "%s %s: 100%% native mode on irq %d\n",\r\nd->name, pci_name(dev), pciirq);\r\n}\r\nret = pciirq;\r\nout:\r\nreturn ret;\r\n}\r\nint ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,\r\nconst struct ide_port_info *d, void *priv)\r\n{\r\nstruct pci_dev *pdev[] = { dev1, dev2 };\r\nstruct ide_host *host;\r\nint ret, i, n_ports = dev2 ? 4 : 2;\r\nstruct ide_hw hw[4], *hws[] = { NULL, NULL, NULL, NULL };\r\nfor (i = 0; i < n_ports / 2; i++) {\r\nret = ide_setup_pci_controller(pdev[i], d, !i);\r\nif (ret < 0)\r\ngoto out;\r\nide_pci_setup_ports(pdev[i], d, &hw[i*2], &hws[i*2]);\r\n}\r\nhost = ide_host_alloc(d, hws, n_ports);\r\nif (host == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nhost->dev[0] = &dev1->dev;\r\nif (dev2)\r\nhost->dev[1] = &dev2->dev;\r\nhost->host_priv = priv;\r\nhost->irq_flags = IRQF_SHARED;\r\npci_set_drvdata(pdev[0], host);\r\nif (dev2)\r\npci_set_drvdata(pdev[1], host);\r\nfor (i = 0; i < n_ports / 2; i++) {\r\nret = do_ide_setup_pci_device(pdev[i], d, !i);\r\nif (ret < 0)\r\ngoto out;\r\nif (ide_pci_is_in_compatibility_mode(pdev[i])) {\r\nhw[i*2].irq = pci_get_legacy_ide_irq(pdev[i], 0);\r\nhw[i*2 + 1].irq = pci_get_legacy_ide_irq(pdev[i], 1);\r\n} else\r\nhw[i*2 + 1].irq = hw[i*2].irq = ret;\r\n}\r\nret = ide_host_register(host, d, hws);\r\nif (ret)\r\nide_host_free(host);\r\nout:\r\nreturn ret;\r\n}\r\nint ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,\r\nvoid *priv)\r\n{\r\nreturn ide_pci_init_two(dev, NULL, d, priv);\r\n}\r\nvoid ide_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nstruct pci_dev *dev2 = host->dev[1] ? to_pci_dev(host->dev[1]) : NULL;\r\nint bars;\r\nif (host->host_flags & IDE_HFLAG_SINGLE)\r\nbars = (1 << 2) - 1;\r\nelse\r\nbars = (1 << 4) - 1;\r\nif ((host->host_flags & IDE_HFLAG_NO_DMA) == 0) {\r\nif (host->host_flags & IDE_HFLAG_CS5520)\r\nbars |= (1 << 2);\r\nelse\r\nbars |= (1 << 4);\r\n}\r\nide_host_remove(host);\r\nif (dev2)\r\npci_release_selected_regions(dev2, bars);\r\npci_release_selected_regions(dev, bars);\r\nif (dev2)\r\npci_disable_device(dev2);\r\npci_disable_device(dev);\r\n}\r\nint ide_pci_suspend(struct pci_dev *dev, pm_message_t state)\r\n{\r\npci_save_state(dev);\r\npci_disable_device(dev);\r\npci_set_power_state(dev, pci_choose_state(dev, state));\r\nreturn 0;\r\n}\r\nint ide_pci_resume(struct pci_dev *dev)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nint rc;\r\npci_set_power_state(dev, PCI_D0);\r\nrc = pci_enable_device(dev);\r\nif (rc)\r\nreturn rc;\r\npci_restore_state(dev);\r\npci_set_master(dev);\r\nif (host->init_chipset)\r\nhost->init_chipset(dev);\r\nreturn 0;\r\n}
