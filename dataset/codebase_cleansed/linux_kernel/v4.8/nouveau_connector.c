struct nouveau_encoder *\r\nfind_encoder(struct drm_connector *connector, int type)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct drm_encoder *enc;\r\nint i, id;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nid = connector->encoder_ids[i];\r\nif (!id)\r\nbreak;\r\nenc = drm_encoder_find(dev, id);\r\nif (!enc)\r\ncontinue;\r\nnv_encoder = nouveau_encoder(enc);\r\nif (type == DCB_OUTPUT_ANY ||\r\n(nv_encoder->dcb && nv_encoder->dcb->type == type))\r\nreturn nv_encoder;\r\n}\r\nreturn NULL;\r\n}\r\nstruct nouveau_connector *\r\nnouveau_encoder_connector_get(struct nouveau_encoder *encoder)\r\n{\r\nstruct drm_device *dev = to_drm_encoder(encoder)->dev;\r\nstruct drm_connector *drm_connector;\r\nlist_for_each_entry(drm_connector, &dev->mode_config.connector_list, head) {\r\nif (drm_connector->encoder == to_drm_encoder(encoder))\r\nreturn nouveau_connector(drm_connector);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nnouveau_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nnvif_notify_fini(&nv_connector->hpd);\r\nkfree(nv_connector->edid);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nif (nv_connector->aux.transfer)\r\ndrm_dp_aux_unregister(&nv_connector->aux);\r\nkfree(connector);\r\n}\r\nstatic struct nouveau_encoder *\r\nnouveau_connector_ddc_detect(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvkm_gpio *gpio = nvxx_gpio(&drm->device);\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct drm_encoder *encoder;\r\nint i, panel = -ENODEV;\r\nif (nv_connector->type == DCB_CONNECTOR_eDP) {\r\npanel = nvkm_gpio_get(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff);\r\nif (panel == 0) {\r\nnvkm_gpio_set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, 1);\r\nmsleep(300);\r\n}\r\n}\r\nfor (i = 0; nv_encoder = NULL, i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nint id = connector->encoder_ids[i];\r\nif (id == 0)\r\nbreak;\r\nencoder = drm_encoder_find(dev, id);\r\nif (!encoder)\r\ncontinue;\r\nnv_encoder = nouveau_encoder(encoder);\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_DP) {\r\nint ret = nouveau_dp_detect(nv_encoder);\r\nif (ret == 0)\r\nbreak;\r\n} else\r\nif ((vga_switcheroo_handler_flags() &\r\nVGA_SWITCHEROO_CAN_SWITCH_DDC) &&\r\nnv_encoder->dcb->type == DCB_OUTPUT_LVDS &&\r\nnv_encoder->i2c) {\r\nint ret;\r\nvga_switcheroo_lock_ddc(dev->pdev);\r\nret = nvkm_probe_i2c(nv_encoder->i2c, 0x50);\r\nvga_switcheroo_unlock_ddc(dev->pdev);\r\nif (ret)\r\nbreak;\r\n} else\r\nif (nv_encoder->i2c) {\r\nif (nvkm_probe_i2c(nv_encoder->i2c, 0x50))\r\nbreak;\r\n}\r\n}\r\nif (!nv_encoder && panel == 0)\r\nnvkm_gpio_set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, panel);\r\nreturn nv_encoder;\r\n}\r\nstatic struct nouveau_encoder *\r\nnouveau_connector_of_detect(struct drm_connector *connector)\r\n{\r\n#ifdef __powerpc__\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct device_node *cn, *dn = pci_device_to_OF_node(dev->pdev);\r\nif (!dn ||\r\n!((nv_encoder = find_encoder(connector, DCB_OUTPUT_TMDS)) ||\r\n(nv_encoder = find_encoder(connector, DCB_OUTPUT_ANALOG))))\r\nreturn NULL;\r\nfor_each_child_of_node(dn, cn) {\r\nconst char *name = of_get_property(cn, "name", NULL);\r\nconst void *edid = of_get_property(cn, "EDID", NULL);\r\nint idx = name ? name[strlen(name) - 1] - 'A' : 0;\r\nif (nv_encoder->dcb->i2c_index == idx && edid) {\r\nnv_connector->edid =\r\nkmemdup(edid, EDID_LENGTH, GFP_KERNEL);\r\nof_node_put(cn);\r\nreturn nv_encoder;\r\n}\r\n}\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic void\r\nnouveau_connector_set_encoder(struct drm_connector *connector,\r\nstruct nouveau_encoder *nv_encoder)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct drm_device *dev = connector->dev;\r\nif (nv_connector->detected_encoder == nv_encoder)\r\nreturn;\r\nnv_connector->detected_encoder = nv_encoder;\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = true;\r\n} else\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS ||\r\nnv_encoder->dcb->type == DCB_OUTPUT_TMDS) {\r\nconnector->doublescan_allowed = false;\r\nconnector->interlace_allowed = false;\r\n} else {\r\nconnector->doublescan_allowed = true;\r\nif (drm->device.info.family == NV_DEVICE_INFO_V0_KELVIN ||\r\n(drm->device.info.family == NV_DEVICE_INFO_V0_CELSIUS &&\r\n(dev->pdev->device & 0x0ff0) != 0x0100 &&\r\n(dev->pdev->device & 0x0ff0) != 0x0150))\r\nconnector->interlace_allowed = false;\r\nelse\r\nconnector->interlace_allowed = true;\r\n}\r\nif (nv_connector->type == DCB_CONNECTOR_DVI_I) {\r\ndrm_object_property_set_value(&connector->base,\r\ndev->mode_config.dvi_i_subconnector_property,\r\nnv_encoder->dcb->type == DCB_OUTPUT_TMDS ?\r\nDRM_MODE_SUBCONNECTOR_DVID :\r\nDRM_MODE_SUBCONNECTOR_DVIA);\r\n}\r\n}\r\nstatic enum drm_connector_status\r\nnouveau_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = NULL;\r\nstruct nouveau_encoder *nv_partner;\r\nstruct i2c_adapter *i2c;\r\nint type;\r\nint ret;\r\nenum drm_connector_status conn_status = connector_status_disconnected;\r\nif (nv_connector->edid) {\r\ndrm_mode_connector_update_edid_property(connector, NULL);\r\nkfree(nv_connector->edid);\r\nnv_connector->edid = NULL;\r\n}\r\nret = pm_runtime_get_sync(connector->dev->dev);\r\nif (ret < 0 && ret != -EACCES)\r\nreturn conn_status;\r\nnv_encoder = nouveau_connector_ddc_detect(connector);\r\nif (nv_encoder && (i2c = nv_encoder->i2c) != NULL) {\r\nif ((vga_switcheroo_handler_flags() &\r\nVGA_SWITCHEROO_CAN_SWITCH_DDC) &&\r\nnv_connector->type == DCB_CONNECTOR_LVDS)\r\nnv_connector->edid = drm_get_edid_switcheroo(connector,\r\ni2c);\r\nelse\r\nnv_connector->edid = drm_get_edid(connector, i2c);\r\ndrm_mode_connector_update_edid_property(connector,\r\nnv_connector->edid);\r\nif (!nv_connector->edid) {\r\nNV_ERROR(drm, "DDC responded, but no EDID for %s\n",\r\nconnector->name);\r\ngoto detect_analog;\r\n}\r\nnv_partner = NULL;\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_TMDS)\r\nnv_partner = find_encoder(connector, DCB_OUTPUT_ANALOG);\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_ANALOG)\r\nnv_partner = find_encoder(connector, DCB_OUTPUT_TMDS);\r\nif (nv_partner && ((nv_encoder->dcb->type == DCB_OUTPUT_ANALOG &&\r\nnv_partner->dcb->type == DCB_OUTPUT_TMDS) ||\r\n(nv_encoder->dcb->type == DCB_OUTPUT_TMDS &&\r\nnv_partner->dcb->type == DCB_OUTPUT_ANALOG))) {\r\nif (nv_connector->edid->input & DRM_EDID_INPUT_DIGITAL)\r\ntype = DCB_OUTPUT_TMDS;\r\nelse\r\ntype = DCB_OUTPUT_ANALOG;\r\nnv_encoder = find_encoder(connector, type);\r\n}\r\nnouveau_connector_set_encoder(connector, nv_encoder);\r\nconn_status = connector_status_connected;\r\ngoto out;\r\n}\r\nnv_encoder = nouveau_connector_of_detect(connector);\r\nif (nv_encoder) {\r\nnouveau_connector_set_encoder(connector, nv_encoder);\r\nconn_status = connector_status_connected;\r\ngoto out;\r\n}\r\ndetect_analog:\r\nnv_encoder = find_encoder(connector, DCB_OUTPUT_ANALOG);\r\nif (!nv_encoder && !nouveau_tv_disable)\r\nnv_encoder = find_encoder(connector, DCB_OUTPUT_TV);\r\nif (nv_encoder && force) {\r\nstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\r\nconst struct drm_encoder_helper_funcs *helper =\r\nencoder->helper_private;\r\nif (helper->detect(encoder, connector) ==\r\nconnector_status_connected) {\r\nnouveau_connector_set_encoder(connector, nv_encoder);\r\nconn_status = connector_status_connected;\r\ngoto out;\r\n}\r\n}\r\nout:\r\npm_runtime_mark_last_busy(connector->dev->dev);\r\npm_runtime_put_autosuspend(connector->dev->dev);\r\nreturn conn_status;\r\n}\r\nstatic enum drm_connector_status\r\nnouveau_connector_detect_lvds(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = NULL;\r\nenum drm_connector_status status = connector_status_disconnected;\r\nif (nv_connector->edid) {\r\ndrm_mode_connector_update_edid_property(connector, NULL);\r\nkfree(nv_connector->edid);\r\nnv_connector->edid = NULL;\r\n}\r\nnv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);\r\nif (!nv_encoder)\r\nreturn connector_status_disconnected;\r\nif (!drm->vbios.fp_no_ddc) {\r\nstatus = nouveau_connector_detect(connector, force);\r\nif (status == connector_status_connected)\r\ngoto out;\r\n}\r\nif (nv_encoder->dcb->lvdsconf.use_acpi_for_edid) {\r\nif ((nv_connector->edid = nouveau_acpi_edid(dev, connector))) {\r\nstatus = connector_status_connected;\r\ngoto out;\r\n}\r\n}\r\nif (nouveau_bios_fp_mode(dev, NULL) && (drm->vbios.fp_no_ddc ||\r\nnv_encoder->dcb->lvdsconf.use_straps_for_mode)) {\r\nstatus = connector_status_connected;\r\ngoto out;\r\n}\r\nif (!drm->vbios.fp_no_ddc) {\r\nstruct edid *edid =\r\n(struct edid *)nouveau_bios_embedded_edid(dev);\r\nif (edid) {\r\nnv_connector->edid =\r\nkmemdup(edid, EDID_LENGTH, GFP_KERNEL);\r\nif (nv_connector->edid)\r\nstatus = connector_status_connected;\r\n}\r\n}\r\nout:\r\n#if defined(CONFIG_ACPI_BUTTON) || \\r\n(defined(CONFIG_ACPI_BUTTON_MODULE) && defined(MODULE))\r\nif (status == connector_status_connected &&\r\n!nouveau_ignorelid && !acpi_lid_open())\r\nstatus = connector_status_unknown;\r\n#endif\r\ndrm_mode_connector_update_edid_property(connector, nv_connector->edid);\r\nnouveau_connector_set_encoder(connector, nv_encoder);\r\nreturn status;\r\n}\r\nstatic void\r\nnouveau_connector_force(struct drm_connector *connector)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder;\r\nint type;\r\nif (nv_connector->type == DCB_CONNECTOR_DVI_I) {\r\nif (connector->force == DRM_FORCE_ON_DIGITAL)\r\ntype = DCB_OUTPUT_TMDS;\r\nelse\r\ntype = DCB_OUTPUT_ANALOG;\r\n} else\r\ntype = DCB_OUTPUT_ANY;\r\nnv_encoder = find_encoder(connector, type);\r\nif (!nv_encoder) {\r\nNV_ERROR(drm, "can't find encoder to force %s on!\n",\r\nconnector->name);\r\nconnector->status = connector_status_disconnected;\r\nreturn;\r\n}\r\nnouveau_connector_set_encoder(connector, nv_encoder);\r\n}\r\nstatic int\r\nnouveau_connector_set_property(struct drm_connector *connector,\r\nstruct drm_property *property, uint64_t value)\r\n{\r\nstruct nouveau_display *disp = nouveau_display(connector->dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\r\nstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_crtc *nv_crtc;\r\nint ret;\r\nnv_crtc = NULL;\r\nif (connector->encoder && connector->encoder->crtc)\r\nnv_crtc = nouveau_crtc(connector->encoder->crtc);\r\nif (property == dev->mode_config.scaling_mode_property) {\r\nbool modeset = false;\r\nswitch (value) {\r\ncase DRM_MODE_SCALE_NONE:\r\nswitch (nv_connector->type) {\r\ncase DCB_CONNECTOR_LVDS:\r\ncase DCB_CONNECTOR_LVDS_SPWG:\r\ncase DCB_CONNECTOR_eDP:\r\nif (disp->disp.oclass < NV50_DISP)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase DRM_MODE_SCALE_FULLSCREEN:\r\ncase DRM_MODE_SCALE_CENTER:\r\ncase DRM_MODE_SCALE_ASPECT:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((nv_connector->scaling_mode == DRM_MODE_SCALE_NONE) ||\r\n(value == DRM_MODE_SCALE_NONE))\r\nmodeset = true;\r\nnv_connector->scaling_mode = value;\r\nif (!nv_crtc)\r\nreturn 0;\r\nif (modeset || !nv_crtc->set_scale) {\r\nret = drm_crtc_helper_set_mode(&nv_crtc->base,\r\n&nv_crtc->base.mode,\r\nnv_crtc->base.x,\r\nnv_crtc->base.y, NULL);\r\nif (!ret)\r\nreturn -EINVAL;\r\n} else {\r\nret = nv_crtc->set_scale(nv_crtc, true);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nif (property == disp->underscan_property) {\r\nif (nv_connector->underscan != value) {\r\nnv_connector->underscan = value;\r\nif (!nv_crtc || !nv_crtc->set_scale)\r\nreturn 0;\r\nreturn nv_crtc->set_scale(nv_crtc, true);\r\n}\r\nreturn 0;\r\n}\r\nif (property == disp->underscan_hborder_property) {\r\nif (nv_connector->underscan_hborder != value) {\r\nnv_connector->underscan_hborder = value;\r\nif (!nv_crtc || !nv_crtc->set_scale)\r\nreturn 0;\r\nreturn nv_crtc->set_scale(nv_crtc, true);\r\n}\r\nreturn 0;\r\n}\r\nif (property == disp->underscan_vborder_property) {\r\nif (nv_connector->underscan_vborder != value) {\r\nnv_connector->underscan_vborder = value;\r\nif (!nv_crtc || !nv_crtc->set_scale)\r\nreturn 0;\r\nreturn nv_crtc->set_scale(nv_crtc, true);\r\n}\r\nreturn 0;\r\n}\r\nif (property == disp->dithering_mode) {\r\nnv_connector->dithering_mode = value;\r\nif (!nv_crtc || !nv_crtc->set_dither)\r\nreturn 0;\r\nreturn nv_crtc->set_dither(nv_crtc, true);\r\n}\r\nif (property == disp->dithering_depth) {\r\nnv_connector->dithering_depth = value;\r\nif (!nv_crtc || !nv_crtc->set_dither)\r\nreturn 0;\r\nreturn nv_crtc->set_dither(nv_crtc, true);\r\n}\r\nif (nv_crtc && nv_crtc->set_color_vibrance) {\r\nif (property == disp->vibrant_hue_property) {\r\nnv_crtc->vibrant_hue = value - 90;\r\nreturn nv_crtc->set_color_vibrance(nv_crtc, true);\r\n}\r\nif (property == disp->color_vibrance_property) {\r\nnv_crtc->color_vibrance = value - 100;\r\nreturn nv_crtc->set_color_vibrance(nv_crtc, true);\r\n}\r\n}\r\nif (nv_encoder && nv_encoder->dcb->type == DCB_OUTPUT_TV)\r\nreturn get_slave_funcs(encoder)->set_property(\r\nencoder, connector, property, value);\r\nreturn -EINVAL;\r\n}\r\nstatic struct drm_display_mode *\r\nnouveau_connector_native_mode(struct drm_connector *connector)\r\n{\r\nconst struct drm_connector_helper_funcs *helper = connector->helper_private;\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *mode, *largest = NULL;\r\nint high_w = 0, high_h = 0, high_v = 0;\r\nlist_for_each_entry(mode, &nv_connector->base.probed_modes, head) {\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\nif (helper->mode_valid(connector, mode) != MODE_OK ||\r\n(mode->flags & DRM_MODE_FLAG_INTERLACE))\r\ncontinue;\r\nif (mode->type & DRM_MODE_TYPE_PREFERRED) {\r\nNV_DEBUG(drm, "native mode from preferred\n");\r\nreturn drm_mode_duplicate(dev, mode);\r\n}\r\nif (mode->hdisplay < high_w)\r\ncontinue;\r\nif (mode->hdisplay == high_w && mode->vdisplay < high_h)\r\ncontinue;\r\nif (mode->hdisplay == high_w && mode->vdisplay == high_h &&\r\nmode->vrefresh < high_v)\r\ncontinue;\r\nhigh_w = mode->hdisplay;\r\nhigh_h = mode->vdisplay;\r\nhigh_v = mode->vrefresh;\r\nlargest = mode;\r\n}\r\nNV_DEBUG(drm, "native mode from largest: %dx%d@%d\n",\r\nhigh_w, high_h, high_v);\r\nreturn largest ? drm_mode_duplicate(dev, largest) : NULL;\r\n}\r\nstatic int\r\nnouveau_connector_scaler_modes_add(struct drm_connector *connector)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct drm_display_mode *native = nv_connector->native_mode, *m;\r\nstruct drm_device *dev = connector->dev;\r\nstruct moderec *mode = &scaler_modes[0];\r\nint modes = 0;\r\nif (!native)\r\nreturn 0;\r\nwhile (mode->hdisplay) {\r\nif (mode->hdisplay <= native->hdisplay &&\r\nmode->vdisplay <= native->vdisplay &&\r\n(mode->hdisplay != native->hdisplay ||\r\nmode->vdisplay != native->vdisplay)) {\r\nm = drm_cvt_mode(dev, mode->hdisplay, mode->vdisplay,\r\ndrm_mode_vrefresh(native), false,\r\nfalse, false);\r\nif (!m)\r\ncontinue;\r\ndrm_mode_probed_add(connector, m);\r\nmodes++;\r\n}\r\nmode++;\r\n}\r\nreturn modes;\r\n}\r\nstatic void\r\nnouveau_connector_detect_depth(struct drm_connector *connector)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\r\nstruct nvbios *bios = &drm->vbios;\r\nstruct drm_display_mode *mode = nv_connector->native_mode;\r\nbool duallink;\r\nif (nv_connector->edid && connector->display_info.bpc)\r\nreturn;\r\nif (nv_connector->type == DCB_CONNECTOR_eDP) {\r\nconnector->display_info.bpc = 6;\r\nreturn;\r\n}\r\nif (nv_encoder->dcb->type != DCB_OUTPUT_LVDS) {\r\nconnector->display_info.bpc = 8;\r\nreturn;\r\n}\r\nconnector->display_info.bpc = 6;\r\nif (bios->fp_no_ddc) {\r\nif (bios->fp.if_is_24bit)\r\nconnector->display_info.bpc = 8;\r\nreturn;\r\n}\r\nif (nv_connector->edid &&\r\nnv_connector->type == DCB_CONNECTOR_LVDS_SPWG)\r\nduallink = ((u8 *)nv_connector->edid)[121] == 2;\r\nelse\r\nduallink = mode->clock >= bios->fp.duallink_transition_clk;\r\nif ((!duallink && (bios->fp.strapless_is_24bit & 1)) ||\r\n( duallink && (bios->fp.strapless_is_24bit & 2)))\r\nconnector->display_info.bpc = 8;\r\n}\r\nstatic int\r\nnouveau_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\r\nstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\r\nint ret = 0;\r\nif (nv_connector->native_mode) {\r\ndrm_mode_destroy(dev, nv_connector->native_mode);\r\nnv_connector->native_mode = NULL;\r\n}\r\nif (nv_connector->edid)\r\nret = drm_add_edid_modes(connector, nv_connector->edid);\r\nelse\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS &&\r\n(nv_encoder->dcb->lvdsconf.use_straps_for_mode ||\r\ndrm->vbios.fp_no_ddc) && nouveau_bios_fp_mode(dev, NULL)) {\r\nstruct drm_display_mode mode;\r\nnouveau_bios_fp_mode(dev, &mode);\r\nnv_connector->native_mode = drm_mode_duplicate(dev, &mode);\r\n}\r\nif (connector->connector_type != DRM_MODE_CONNECTOR_LVDS)\r\nnouveau_connector_detect_depth(connector);\r\nif (!nv_connector->native_mode)\r\nnv_connector->native_mode =\r\nnouveau_connector_native_mode(connector);\r\nif (ret == 0 && nv_connector->native_mode) {\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_duplicate(dev, nv_connector->native_mode);\r\ndrm_mode_probed_add(connector, mode);\r\nret = 1;\r\n}\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)\r\nnouveau_connector_detect_depth(connector);\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_TV)\r\nret = get_slave_funcs(encoder)->get_modes(encoder, connector);\r\nif (nv_connector->type == DCB_CONNECTOR_LVDS ||\r\nnv_connector->type == DCB_CONNECTOR_LVDS_SPWG ||\r\nnv_connector->type == DCB_CONNECTOR_eDP)\r\nret += nouveau_connector_scaler_modes_add(connector);\r\nreturn ret;\r\n}\r\nstatic unsigned\r\nget_tmds_link_bandwidth(struct drm_connector *connector, bool hdmi)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct dcb_output *dcb = nv_connector->detected_encoder->dcb;\r\nif (hdmi) {\r\nif (nouveau_hdmimhz > 0)\r\nreturn nouveau_hdmimhz * 1000;\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_KEPLER)\r\nreturn 297000;\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_FERMI)\r\nreturn 225000;\r\n}\r\nif (dcb->location != DCB_LOC_ON_CHIP ||\r\ndrm->device.info.chipset >= 0x46)\r\nreturn 165000;\r\nelse if (drm->device.info.chipset >= 0x40)\r\nreturn 155000;\r\nelse if (drm->device.info.chipset >= 0x18)\r\nreturn 135000;\r\nelse\r\nreturn 112000;\r\n}\r\nstatic int\r\nnouveau_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\r\nstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\r\nunsigned min_clock = 25000, max_clock = min_clock;\r\nunsigned clock = mode->clock;\r\nbool hdmi;\r\nswitch (nv_encoder->dcb->type) {\r\ncase DCB_OUTPUT_LVDS:\r\nif (nv_connector->native_mode &&\r\n(mode->hdisplay > nv_connector->native_mode->hdisplay ||\r\nmode->vdisplay > nv_connector->native_mode->vdisplay))\r\nreturn MODE_PANEL;\r\nmin_clock = 0;\r\nmax_clock = 400000;\r\nbreak;\r\ncase DCB_OUTPUT_TMDS:\r\nhdmi = drm_detect_hdmi_monitor(nv_connector->edid);\r\nmax_clock = get_tmds_link_bandwidth(connector, hdmi);\r\nif (!hdmi && nouveau_duallink &&\r\nnv_encoder->dcb->duallink_possible)\r\nmax_clock *= 2;\r\nbreak;\r\ncase DCB_OUTPUT_ANALOG:\r\nmax_clock = nv_encoder->dcb->crtconf.maxfreq;\r\nif (!max_clock)\r\nmax_clock = 350000;\r\nbreak;\r\ncase DCB_OUTPUT_TV:\r\nreturn get_slave_funcs(encoder)->mode_valid(encoder, mode);\r\ncase DCB_OUTPUT_DP:\r\nmax_clock = nv_encoder->dp.link_nr;\r\nmax_clock *= nv_encoder->dp.link_bw;\r\nclock = clock * (connector->display_info.bpc * 3) / 10;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nreturn MODE_BAD;\r\n}\r\nif (clock < min_clock)\r\nreturn MODE_CLOCK_LOW;\r\nif (clock > max_clock)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic struct drm_encoder *\r\nnouveau_connector_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nif (nv_connector->detected_encoder)\r\nreturn to_drm_encoder(nv_connector->detected_encoder);\r\nreturn NULL;\r\n}\r\nstatic int\r\nnouveau_connector_dp_dpms(struct drm_connector *connector, int mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = NULL;\r\nif (connector->encoder)\r\nnv_encoder = nouveau_encoder(connector->encoder);\r\nif (nv_encoder && nv_encoder->dcb &&\r\nnv_encoder->dcb->type == DCB_OUTPUT_DP) {\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nu8 data = DP_SET_POWER_D0;\r\nnvkm_wraux(nv_encoder->aux, DP_SET_POWER, &data, 1);\r\nusleep_range(1000, 2000);\r\n} else {\r\nu8 data = DP_SET_POWER_D3;\r\nnvkm_wraux(nv_encoder->aux, DP_SET_POWER, &data, 1);\r\n}\r\n}\r\nreturn drm_helper_connector_dpms(connector, mode);\r\n}\r\nstatic int\r\nnouveau_connector_hotplug(struct nvif_notify *notify)\r\n{\r\nstruct nouveau_connector *nv_connector =\r\ncontainer_of(notify, typeof(*nv_connector), hpd);\r\nstruct drm_connector *connector = &nv_connector->base;\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nconst struct nvif_notify_conn_rep_v0 *rep = notify->data;\r\nconst char *name = connector->name;\r\nif (rep->mask & NVIF_NOTIFY_CONN_V0_IRQ) {\r\n} else {\r\nbool plugged = (rep->mask != NVIF_NOTIFY_CONN_V0_UNPLUG);\r\nNV_DEBUG(drm, "%splugged %s\n", plugged ? "" : "un", name);\r\nmutex_lock(&drm->dev->mode_config.mutex);\r\nif (plugged)\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);\r\nelse\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);\r\nmutex_unlock(&drm->dev->mode_config.mutex);\r\ndrm_helper_hpd_irq_event(connector->dev);\r\n}\r\nreturn NVIF_NOTIFY_KEEP;\r\n}\r\nstatic ssize_t\r\nnouveau_connector_aux_xfer(struct drm_dp_aux *obj, struct drm_dp_aux_msg *msg)\r\n{\r\nstruct nouveau_connector *nv_connector =\r\ncontainer_of(obj, typeof(*nv_connector), aux);\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct nvkm_i2c_aux *aux;\r\nint ret;\r\nnv_encoder = find_encoder(&nv_connector->base, DCB_OUTPUT_DP);\r\nif (!nv_encoder || !(aux = nv_encoder->aux))\r\nreturn -ENODEV;\r\nif (WARN_ON(msg->size > 16))\r\nreturn -E2BIG;\r\nif (msg->size == 0)\r\nreturn msg->size;\r\nret = nvkm_i2c_aux_acquire(aux);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_i2c_aux_xfer(aux, false, msg->request, msg->address,\r\nmsg->buffer, msg->size);\r\nnvkm_i2c_aux_release(aux);\r\nif (ret >= 0) {\r\nmsg->reply = ret;\r\nreturn msg->size;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ndrm_conntype_from_dcb(enum dcb_connector_type dcb)\r\n{\r\nswitch (dcb) {\r\ncase DCB_CONNECTOR_VGA : return DRM_MODE_CONNECTOR_VGA;\r\ncase DCB_CONNECTOR_TV_0 :\r\ncase DCB_CONNECTOR_TV_1 :\r\ncase DCB_CONNECTOR_TV_3 : return DRM_MODE_CONNECTOR_TV;\r\ncase DCB_CONNECTOR_DMS59_0 :\r\ncase DCB_CONNECTOR_DMS59_1 :\r\ncase DCB_CONNECTOR_DVI_I : return DRM_MODE_CONNECTOR_DVII;\r\ncase DCB_CONNECTOR_DVI_D : return DRM_MODE_CONNECTOR_DVID;\r\ncase DCB_CONNECTOR_LVDS :\r\ncase DCB_CONNECTOR_LVDS_SPWG: return DRM_MODE_CONNECTOR_LVDS;\r\ncase DCB_CONNECTOR_DMS59_DP0:\r\ncase DCB_CONNECTOR_DMS59_DP1:\r\ncase DCB_CONNECTOR_DP : return DRM_MODE_CONNECTOR_DisplayPort;\r\ncase DCB_CONNECTOR_eDP : return DRM_MODE_CONNECTOR_eDP;\r\ncase DCB_CONNECTOR_HDMI_0 :\r\ncase DCB_CONNECTOR_HDMI_1 :\r\ncase DCB_CONNECTOR_HDMI_C : return DRM_MODE_CONNECTOR_HDMIA;\r\ndefault:\r\nbreak;\r\n}\r\nreturn DRM_MODE_CONNECTOR_Unknown;\r\n}\r\nstruct drm_connector *\r\nnouveau_connector_create(struct drm_device *dev, int index)\r\n{\r\nconst struct drm_connector_funcs *funcs = &nouveau_connector_funcs;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_display *disp = nouveau_display(dev);\r\nstruct nouveau_connector *nv_connector = NULL;\r\nstruct drm_connector *connector;\r\nint type, ret = 0;\r\nbool dummy;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nnv_connector = nouveau_connector(connector);\r\nif (nv_connector->index == index)\r\nreturn connector;\r\n}\r\nnv_connector = kzalloc(sizeof(*nv_connector), GFP_KERNEL);\r\nif (!nv_connector)\r\nreturn ERR_PTR(-ENOMEM);\r\nconnector = &nv_connector->base;\r\nnv_connector->index = index;\r\nnv_connector->dcb = olddcb_conn(dev, index);\r\nif (nv_connector->dcb) {\r\nu32 entry = ROM16(nv_connector->dcb[0]);\r\nif (olddcb_conntab(dev)[3] >= 4)\r\nentry |= (u32)ROM16(nv_connector->dcb[2]) << 16;\r\nnv_connector->type = nv_connector->dcb[0];\r\nif (drm_conntype_from_dcb(nv_connector->type) ==\r\nDRM_MODE_CONNECTOR_Unknown) {\r\nNV_WARN(drm, "unknown connector type %02x\n",\r\nnv_connector->type);\r\nnv_connector->type = DCB_CONNECTOR_NONE;\r\n}\r\nif (nv_match_device(dev, 0x0421, 0x1458, 0x344c)) {\r\nif (nv_connector->type == DCB_CONNECTOR_HDMI_1)\r\nnv_connector->type = DCB_CONNECTOR_DVI_I;\r\n}\r\nif (nv_match_device(dev, 0x0402, 0x1458, 0x3455)) {\r\nif (nv_connector->type == DCB_CONNECTOR_HDMI_1)\r\nnv_connector->type = DCB_CONNECTOR_DVI_I;\r\n}\r\n} else {\r\nnv_connector->type = DCB_CONNECTOR_NONE;\r\n}\r\nif (nv_connector->type == DCB_CONNECTOR_NONE) {\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct dcb_table *dcbt = &drm->vbios.dcb;\r\nu32 encoders = 0;\r\nint i;\r\nfor (i = 0; i < dcbt->entries; i++) {\r\nif (dcbt->entry[i].connector == nv_connector->index)\r\nencoders |= (1 << dcbt->entry[i].type);\r\n}\r\nif (encoders & (1 << DCB_OUTPUT_DP)) {\r\nif (encoders & (1 << DCB_OUTPUT_TMDS))\r\nnv_connector->type = DCB_CONNECTOR_DP;\r\nelse\r\nnv_connector->type = DCB_CONNECTOR_eDP;\r\n} else\r\nif (encoders & (1 << DCB_OUTPUT_TMDS)) {\r\nif (encoders & (1 << DCB_OUTPUT_ANALOG))\r\nnv_connector->type = DCB_CONNECTOR_DVI_I;\r\nelse\r\nnv_connector->type = DCB_CONNECTOR_DVI_D;\r\n} else\r\nif (encoders & (1 << DCB_OUTPUT_ANALOG)) {\r\nnv_connector->type = DCB_CONNECTOR_VGA;\r\n} else\r\nif (encoders & (1 << DCB_OUTPUT_LVDS)) {\r\nnv_connector->type = DCB_CONNECTOR_LVDS;\r\n} else\r\nif (encoders & (1 << DCB_OUTPUT_TV)) {\r\nnv_connector->type = DCB_CONNECTOR_TV_0;\r\n}\r\n}\r\nswitch ((type = drm_conntype_from_dcb(nv_connector->type))) {\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\nret = nouveau_bios_parse_lvds_table(dev, 0, &dummy, &dummy);\r\nif (ret) {\r\nNV_ERROR(drm, "Error parsing LVDS table, disabling\n");\r\nkfree(nv_connector);\r\nreturn ERR_PTR(ret);\r\n}\r\nfuncs = &nouveau_connector_funcs_lvds;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\ncase DRM_MODE_CONNECTOR_eDP:\r\nnv_connector->aux.dev = dev->dev;\r\nnv_connector->aux.transfer = nouveau_connector_aux_xfer;\r\nret = drm_dp_aux_register(&nv_connector->aux);\r\nif (ret) {\r\nNV_ERROR(drm, "failed to register aux channel\n");\r\nkfree(nv_connector);\r\nreturn ERR_PTR(ret);\r\n}\r\nfuncs = &nouveau_connector_funcs_dp;\r\nbreak;\r\ndefault:\r\nfuncs = &nouveau_connector_funcs;\r\nbreak;\r\n}\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\ndrm_connector_init(dev, connector, funcs, type);\r\ndrm_connector_helper_add(connector, &nouveau_connector_helper_funcs);\r\nif (nv_connector->type == DCB_CONNECTOR_DVI_I)\r\ndrm_object_attach_property(&connector->base, dev->mode_config.dvi_i_subconnector_property, 0);\r\nif (disp->underscan_property &&\r\n(type == DRM_MODE_CONNECTOR_DVID ||\r\ntype == DRM_MODE_CONNECTOR_DVII ||\r\ntype == DRM_MODE_CONNECTOR_HDMIA ||\r\ntype == DRM_MODE_CONNECTOR_DisplayPort)) {\r\ndrm_object_attach_property(&connector->base,\r\ndisp->underscan_property,\r\nUNDERSCAN_OFF);\r\ndrm_object_attach_property(&connector->base,\r\ndisp->underscan_hborder_property,\r\n0);\r\ndrm_object_attach_property(&connector->base,\r\ndisp->underscan_vborder_property,\r\n0);\r\n}\r\nif (disp->vibrant_hue_property)\r\ndrm_object_attach_property(&connector->base,\r\ndisp->vibrant_hue_property,\r\n90);\r\nif (disp->color_vibrance_property)\r\ndrm_object_attach_property(&connector->base,\r\ndisp->color_vibrance_property,\r\n150);\r\nswitch (nv_connector->type) {\r\ncase DCB_CONNECTOR_LVDS:\r\ncase DCB_CONNECTOR_LVDS_SPWG:\r\ncase DCB_CONNECTOR_eDP:\r\nif (disp->disp.oclass < NV50_DISP) {\r\nnv_connector->scaling_mode = DRM_MODE_SCALE_FULLSCREEN;\r\nbreak;\r\n}\r\nnv_connector->scaling_mode = DRM_MODE_SCALE_NONE;\r\nbreak;\r\ndefault:\r\nnv_connector->scaling_mode = DRM_MODE_SCALE_NONE;\r\nbreak;\r\n}\r\nswitch (nv_connector->type) {\r\ncase DCB_CONNECTOR_TV_0:\r\ncase DCB_CONNECTOR_TV_1:\r\ncase DCB_CONNECTOR_TV_3:\r\nbreak;\r\ncase DCB_CONNECTOR_VGA:\r\nif (disp->disp.oclass < NV50_DISP)\r\nbreak;\r\ndefault:\r\ndrm_object_attach_property(&connector->base, dev->mode_config.\r\nscaling_mode_property,\r\nnv_connector->scaling_mode);\r\nbreak;\r\n}\r\nswitch (nv_connector->type) {\r\ncase DCB_CONNECTOR_TV_0:\r\ncase DCB_CONNECTOR_TV_1:\r\ncase DCB_CONNECTOR_TV_3:\r\ncase DCB_CONNECTOR_VGA:\r\nbreak;\r\ndefault:\r\nif (disp->dithering_mode) {\r\nnv_connector->dithering_mode = DITHERING_MODE_AUTO;\r\ndrm_object_attach_property(&connector->base,\r\ndisp->dithering_mode,\r\nnv_connector->\r\ndithering_mode);\r\n}\r\nif (disp->dithering_depth) {\r\nnv_connector->dithering_depth = DITHERING_DEPTH_AUTO;\r\ndrm_object_attach_property(&connector->base,\r\ndisp->dithering_depth,\r\nnv_connector->\r\ndithering_depth);\r\n}\r\nbreak;\r\n}\r\nret = nvif_notify_init(&disp->disp, nouveau_connector_hotplug, true,\r\nNV04_DISP_NTFY_CONN,\r\n&(struct nvif_notify_conn_req_v0) {\r\n.mask = NVIF_NOTIFY_CONN_V0_ANY,\r\n.conn = index,\r\n},\r\nsizeof(struct nvif_notify_conn_req_v0),\r\nsizeof(struct nvif_notify_conn_rep_v0),\r\n&nv_connector->hpd);\r\nif (ret)\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\nelse\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\ndrm_connector_register(connector);\r\nreturn connector;\r\n}
