static inline int overlap(int min1, int max1, int min2, int max2)\r\n{\r\nreturn max1 > min2 && min1 < max2;\r\n}\r\nint nf_register_sockopt(struct nf_sockopt_ops *reg)\r\n{\r\nstruct nf_sockopt_ops *ops;\r\nint ret = 0;\r\nmutex_lock(&nf_sockopt_mutex);\r\nlist_for_each_entry(ops, &nf_sockopts, list) {\r\nif (ops->pf == reg->pf\r\n&& (overlap(ops->set_optmin, ops->set_optmax,\r\nreg->set_optmin, reg->set_optmax)\r\n|| overlap(ops->get_optmin, ops->get_optmax,\r\nreg->get_optmin, reg->get_optmax))) {\r\nNFDEBUG("nf_sock overlap: %u-%u/%u-%u v %u-%u/%u-%u\n",\r\nops->set_optmin, ops->set_optmax,\r\nops->get_optmin, ops->get_optmax,\r\nreg->set_optmin, reg->set_optmax,\r\nreg->get_optmin, reg->get_optmax);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\n}\r\nlist_add(&reg->list, &nf_sockopts);\r\nout:\r\nmutex_unlock(&nf_sockopt_mutex);\r\nreturn ret;\r\n}\r\nvoid nf_unregister_sockopt(struct nf_sockopt_ops *reg)\r\n{\r\nmutex_lock(&nf_sockopt_mutex);\r\nlist_del(&reg->list);\r\nmutex_unlock(&nf_sockopt_mutex);\r\n}\r\nstatic struct nf_sockopt_ops *nf_sockopt_find(struct sock *sk, u_int8_t pf,\r\nint val, int get)\r\n{\r\nstruct nf_sockopt_ops *ops;\r\nmutex_lock(&nf_sockopt_mutex);\r\nlist_for_each_entry(ops, &nf_sockopts, list) {\r\nif (ops->pf == pf) {\r\nif (!try_module_get(ops->owner))\r\ngoto out_nosup;\r\nif (get) {\r\nif (val >= ops->get_optmin &&\r\nval < ops->get_optmax)\r\ngoto out;\r\n} else {\r\nif (val >= ops->set_optmin &&\r\nval < ops->set_optmax)\r\ngoto out;\r\n}\r\nmodule_put(ops->owner);\r\n}\r\n}\r\nout_nosup:\r\nops = ERR_PTR(-ENOPROTOOPT);\r\nout:\r\nmutex_unlock(&nf_sockopt_mutex);\r\nreturn ops;\r\n}\r\nstatic int nf_sockopt(struct sock *sk, u_int8_t pf, int val,\r\nchar __user *opt, int *len, int get)\r\n{\r\nstruct nf_sockopt_ops *ops;\r\nint ret;\r\nops = nf_sockopt_find(sk, pf, val, get);\r\nif (IS_ERR(ops))\r\nreturn PTR_ERR(ops);\r\nif (get)\r\nret = ops->get(sk, val, opt, len);\r\nelse\r\nret = ops->set(sk, val, opt, *len);\r\nmodule_put(ops->owner);\r\nreturn ret;\r\n}\r\nint nf_setsockopt(struct sock *sk, u_int8_t pf, int val, char __user *opt,\r\nunsigned int len)\r\n{\r\nreturn nf_sockopt(sk, pf, val, opt, &len, 0);\r\n}\r\nint nf_getsockopt(struct sock *sk, u_int8_t pf, int val, char __user *opt,\r\nint *len)\r\n{\r\nreturn nf_sockopt(sk, pf, val, opt, len, 1);\r\n}\r\nstatic int compat_nf_sockopt(struct sock *sk, u_int8_t pf, int val,\r\nchar __user *opt, int *len, int get)\r\n{\r\nstruct nf_sockopt_ops *ops;\r\nint ret;\r\nops = nf_sockopt_find(sk, pf, val, get);\r\nif (IS_ERR(ops))\r\nreturn PTR_ERR(ops);\r\nif (get) {\r\nif (ops->compat_get)\r\nret = ops->compat_get(sk, val, opt, len);\r\nelse\r\nret = ops->get(sk, val, opt, len);\r\n} else {\r\nif (ops->compat_set)\r\nret = ops->compat_set(sk, val, opt, *len);\r\nelse\r\nret = ops->set(sk, val, opt, *len);\r\n}\r\nmodule_put(ops->owner);\r\nreturn ret;\r\n}\r\nint compat_nf_setsockopt(struct sock *sk, u_int8_t pf,\r\nint val, char __user *opt, unsigned int len)\r\n{\r\nreturn compat_nf_sockopt(sk, pf, val, opt, &len, 0);\r\n}\r\nint compat_nf_getsockopt(struct sock *sk, u_int8_t pf,\r\nint val, char __user *opt, int *len)\r\n{\r\nreturn compat_nf_sockopt(sk, pf, val, opt, len, 1);\r\n}
