static struct ccp_vdata *ccp_get_of_version(struct platform_device *pdev)\r\n{\r\n#ifdef CONFIG_OF\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(ccp_of_match, pdev->dev.of_node);\r\nif (match && match->data)\r\nreturn (struct ccp_vdata *)match->data;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic struct ccp_vdata *ccp_get_acpi_version(struct platform_device *pdev)\r\n{\r\n#ifdef CONFIG_ACPI\r\nconst struct acpi_device_id *match;\r\nmatch = acpi_match_device(ccp_acpi_match, &pdev->dev);\r\nif (match && match->driver_data)\r\nreturn (struct ccp_vdata *)match->driver_data;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int ccp_get_irq(struct ccp_device *ccp)\r\n{\r\nstruct device *dev = ccp->dev;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nint ret;\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nccp->irq = ret;\r\nret = request_irq(ccp->irq, ccp->vdata->perform->irqhandler, 0,\r\nccp->name, dev);\r\nif (ret) {\r\ndev_notice(dev, "unable to allocate IRQ (%d)\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccp_get_irqs(struct ccp_device *ccp)\r\n{\r\nstruct device *dev = ccp->dev;\r\nint ret;\r\nret = ccp_get_irq(ccp);\r\nif (!ret)\r\nreturn 0;\r\ndev_notice(dev, "could not enable interrupts (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic void ccp_free_irqs(struct ccp_device *ccp)\r\n{\r\nstruct device *dev = ccp->dev;\r\nfree_irq(ccp->irq, dev);\r\n}\r\nstatic struct resource *ccp_find_mmio_area(struct ccp_device *ccp)\r\n{\r\nstruct device *dev = ccp->dev;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct resource *ior;\r\nior = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (ior && (resource_size(ior) >= 0x800))\r\nreturn ior;\r\nreturn NULL;\r\n}\r\nstatic int ccp_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct ccp_device *ccp;\r\nstruct ccp_platform *ccp_platform;\r\nstruct device *dev = &pdev->dev;\r\nenum dev_dma_attr attr;\r\nstruct resource *ior;\r\nint ret;\r\nret = -ENOMEM;\r\nccp = ccp_alloc_struct(dev);\r\nif (!ccp)\r\ngoto e_err;\r\nccp_platform = devm_kzalloc(dev, sizeof(*ccp_platform), GFP_KERNEL);\r\nif (!ccp_platform)\r\ngoto e_err;\r\nccp->dev_specific = ccp_platform;\r\nccp->vdata = pdev->dev.of_node ? ccp_get_of_version(pdev)\r\n: ccp_get_acpi_version(pdev);\r\nif (!ccp->vdata || !ccp->vdata->version) {\r\nret = -ENODEV;\r\ndev_err(dev, "missing driver data\n");\r\ngoto e_err;\r\n}\r\nccp->get_irq = ccp_get_irqs;\r\nccp->free_irq = ccp_free_irqs;\r\nior = ccp_find_mmio_area(ccp);\r\nccp->io_map = devm_ioremap_resource(dev, ior);\r\nif (IS_ERR(ccp->io_map)) {\r\nret = PTR_ERR(ccp->io_map);\r\ngoto e_err;\r\n}\r\nccp->io_regs = ccp->io_map;\r\nattr = device_get_dma_attr(dev);\r\nif (attr == DEV_DMA_NOT_SUPPORTED) {\r\ndev_err(dev, "DMA is not supported");\r\ngoto e_err;\r\n}\r\nccp_platform->coherent = (attr == DEV_DMA_COHERENT);\r\nif (ccp_platform->coherent)\r\nccp->axcache = CACHE_WB_NO_ALLOC;\r\nelse\r\nccp->axcache = CACHE_NONE;\r\nret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(48));\r\nif (ret) {\r\ndev_err(dev, "dma_set_mask_and_coherent failed (%d)\n", ret);\r\ngoto e_err;\r\n}\r\ndev_set_drvdata(dev, ccp);\r\nret = ccp->vdata->perform->init(ccp);\r\nif (ret)\r\ngoto e_err;\r\ndev_notice(dev, "enabled\n");\r\nreturn 0;\r\ne_err:\r\ndev_notice(dev, "initialization failed\n");\r\nreturn ret;\r\n}\r\nstatic int ccp_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ccp_device *ccp = dev_get_drvdata(dev);\r\nccp->vdata->perform->destroy(ccp);\r\ndev_notice(dev, "disabled\n");\r\nreturn 0;\r\n}\r\nstatic int ccp_platform_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ccp_device *ccp = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&ccp->cmd_lock, flags);\r\nccp->suspending = 1;\r\nfor (i = 0; i < ccp->cmd_q_count; i++)\r\nwake_up_process(ccp->cmd_q[i].kthread);\r\nspin_unlock_irqrestore(&ccp->cmd_lock, flags);\r\nwhile (!ccp_queues_suspended(ccp))\r\nwait_event_interruptible(ccp->suspend_queue,\r\nccp_queues_suspended(ccp));\r\nreturn 0;\r\n}\r\nstatic int ccp_platform_resume(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ccp_device *ccp = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&ccp->cmd_lock, flags);\r\nccp->suspending = 0;\r\nfor (i = 0; i < ccp->cmd_q_count; i++) {\r\nccp->cmd_q[i].suspended = 0;\r\nwake_up_process(ccp->cmd_q[i].kthread);\r\n}\r\nspin_unlock_irqrestore(&ccp->cmd_lock, flags);\r\nreturn 0;\r\n}\r\nint ccp_platform_init(void)\r\n{\r\nreturn platform_driver_register(&ccp_platform_driver);\r\n}\r\nvoid ccp_platform_exit(void)\r\n{\r\nplatform_driver_unregister(&ccp_platform_driver);\r\n}
