static void ql_zap(struct qlogicfas408_priv *priv)\r\n{\r\nint x;\r\nint qbase = priv->qbase;\r\nint int_type = priv->int_type;\r\nx = inb(qbase + 0xd);\r\nREG0;\r\noutb(3, qbase + 3);\r\noutb(2, qbase + 3);\r\nif (x & 0x80)\r\nREG1;\r\n}\r\nstatic int ql_pdma(struct qlogicfas408_priv *priv, int phase, char *request, int reqlen)\r\n{\r\nint j;\r\nint qbase = priv->qbase;\r\nj = 0;\r\nif (phase & 1) {\r\n#if QL_TURBO_PDMA\r\nrtrc(4)\r\nif (reqlen >= 128 && (inb(qbase + 8) & 2)) {\r\ninsl(qbase + 4, request, 32);\r\nreqlen -= 128;\r\nrequest += 128;\r\n}\r\nwhile (reqlen >= 84 && !(j & 0xc0))\r\nif ((j = inb(qbase + 8)) & 4)\r\n{\r\ninsl(qbase + 4, request, 21);\r\nreqlen -= 84;\r\nrequest += 84;\r\n}\r\nif (reqlen >= 44 && (inb(qbase + 8) & 8)) {\r\ninsl(qbase + 4, request, 11);\r\nreqlen -= 44;\r\nrequest += 44;\r\n}\r\n#endif\r\nrtrc(7)\r\nj = 0;\r\nwhile (reqlen && !((j & 0x10) && (j & 0xc0)))\r\n{\r\nj &= 0xc0;\r\nwhile (reqlen && !((j = inb(qbase + 8)) & 0x10))\r\n{\r\n*request++ = inb(qbase + 4);\r\nreqlen--;\r\n}\r\nif (j & 0x10)\r\nj = inb(qbase + 8);\r\n}\r\n} else {\r\n#if QL_TURBO_PDMA\r\nrtrc(4)\r\nif (reqlen >= 128 && inb(qbase + 8) & 0x10) {\r\noutsl(qbase + 4, request, 32);\r\nreqlen -= 128;\r\nrequest += 128;\r\n}\r\nwhile (reqlen >= 84 && !(j & 0xc0))\r\nif (!((j = inb(qbase + 8)) & 8)) {\r\noutsl(qbase + 4, request, 21);\r\nreqlen -= 84;\r\nrequest += 84;\r\n}\r\nif (reqlen >= 40 && !(inb(qbase + 8) & 4)) {\r\noutsl(qbase + 4, request, 10);\r\nreqlen -= 40;\r\nrequest += 40;\r\n}\r\n#endif\r\nrtrc(7)\r\nj = 0;\r\nwhile (reqlen && !((j & 2) && (j & 0xc0))) {\r\nwhile (reqlen && !((j = inb(qbase + 8)) & 2))\r\n{\r\noutb(*request++, qbase + 4);\r\nreqlen--;\r\n}\r\nif (j & 2)\r\nj = inb(qbase + 8);\r\n}\r\n}\r\nreturn inb(qbase + 8) & 0xc0;\r\n}\r\nstatic int ql_wai(struct qlogicfas408_priv *priv)\r\n{\r\nint k;\r\nint qbase = priv->qbase;\r\nunsigned long i;\r\nk = 0;\r\ni = jiffies + WATCHDOG;\r\nwhile (time_before(jiffies, i) && !priv->qabort &&\r\n!((k = inb(qbase + 4)) & 0xe0)) {\r\nbarrier();\r\ncpu_relax();\r\n}\r\nif (time_after_eq(jiffies, i))\r\nreturn (DID_TIME_OUT);\r\nif (priv->qabort)\r\nreturn (priv->qabort == 1 ? DID_ABORT : DID_RESET);\r\nif (k & 0x60)\r\nql_zap(priv);\r\nif (k & 0x20)\r\nreturn (DID_PARITY);\r\nif (k & 0x40)\r\nreturn (DID_ERROR);\r\nreturn 0;\r\n}\r\nstatic void ql_icmd(struct scsi_cmnd *cmd)\r\n{\r\nstruct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);\r\nint qbase = priv->qbase;\r\nint int_type = priv->int_type;\r\nunsigned int i;\r\npriv->qabort = 0;\r\nREG0;\r\ninb(qbase + 5);\r\nif (inb(qbase + 5))\r\noutb(2, qbase + 3);\r\nelse if (inb(qbase + 7) & 0x1f)\r\noutb(1, qbase + 3);\r\nwhile (inb(qbase + 5));\r\nREG1;\r\noutb(1, qbase + 8);\r\noutb(0, qbase + 0xb);\r\ninb(qbase + 8);\r\nREG0;\r\noutb(0x40, qbase + 0xb);\r\noutb(qlcfgc, qbase + 0xc);\r\noutb(0x40 | qlcfg8 | priv->qinitid, qbase + 8);\r\noutb(qlcfg7, qbase + 7);\r\noutb(qlcfg6, qbase + 6);\r\noutb(qlcfg5, qbase + 5);\r\noutb(qlcfg9 & 7, qbase + 9);\r\noutb(scmd_id(cmd), qbase + 4);\r\nfor (i = 0; i < cmd->cmd_len; i++)\r\noutb(cmd->cmnd[i], qbase + 2);\r\npriv->qlcmd = cmd;\r\noutb(0x41, qbase + 3);\r\n}\r\nstatic unsigned int ql_pcmd(struct scsi_cmnd *cmd)\r\n{\r\nunsigned int i, j;\r\nunsigned long k;\r\nunsigned int result;\r\nunsigned int status;\r\nunsigned int message;\r\nunsigned int phase;\r\nunsigned int reqlen;\r\nchar *buf;\r\nstruct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);\r\nint qbase = priv->qbase;\r\nint int_type = priv->int_type;\r\nrtrc(1)\r\nj = inb(qbase + 6);\r\ni = inb(qbase + 5);\r\nif (i == 0x20) {\r\nreturn (DID_NO_CONNECT << 16);\r\n}\r\ni |= inb(qbase + 5);\r\nif (i != 0x18) {\r\nprintk(KERN_ERR "Ql:Bad Interrupt status:%02x\n", i);\r\nql_zap(priv);\r\nreturn (DID_BAD_INTR << 16);\r\n}\r\nj &= 7;\r\nif (j != 3 && j != 4) {\r\nprintk(KERN_ERR "Ql:Bad sequence for command %d, int %02X, cmdleft = %d\n",\r\nj, i, inb(qbase + 7) & 0x1f);\r\nql_zap(priv);\r\nreturn (DID_ERROR << 16);\r\n}\r\nresult = DID_OK;\r\nif (inb(qbase + 7) & 0x1f)\r\noutb(1, qbase + 3);\r\nreqlen = scsi_bufflen(cmd);\r\nif (reqlen && !((phase = inb(qbase + 4)) & 6)) {\r\nstruct scatterlist *sg;\r\nrtrc(2)\r\noutb(reqlen, qbase);\r\noutb(reqlen >> 8, qbase + 1);\r\noutb(reqlen >> 16, qbase + 0xe);\r\noutb(0x90, qbase + 3);\r\nREG1;\r\nscsi_for_each_sg(cmd, sg, scsi_sg_count(cmd), i) {\r\nif (priv->qabort) {\r\nREG0;\r\nreturn ((priv->qabort == 1 ?\r\nDID_ABORT : DID_RESET) << 16);\r\n}\r\nbuf = sg_virt(sg);\r\nif (ql_pdma(priv, phase, buf, sg->length))\r\nbreak;\r\n}\r\nREG0;\r\nrtrc(2)\r\nif ((k = ql_wai(priv)))\r\nreturn (k << 16);\r\nk = inb(qbase + 5);\r\n}\r\nk = jiffies + WATCHDOG;\r\nwhile (time_before(jiffies, k) && !priv->qabort &&\r\n!(inb(qbase + 4) & 6))\r\ncpu_relax();\r\nif (time_after_eq(jiffies, k)) {\r\nql_zap(priv);\r\nreturn (DID_TIME_OUT << 16);\r\n}\r\nwhile (inb(qbase + 5))\r\ncpu_relax();\r\nif (priv->qabort)\r\nreturn ((priv->qabort == 1 ? DID_ABORT : DID_RESET) << 16);\r\noutb(0x11, qbase + 3);\r\nif ((k = ql_wai(priv)))\r\nreturn (k << 16);\r\ni = inb(qbase + 5);\r\nj = inb(qbase + 7) & 0x1f;\r\nstatus = inb(qbase + 2);\r\nmessage = inb(qbase + 2);\r\nif (!((i == 8 && j == 2) || (i == 0x10 && j == 1))) {\r\nprintk(KERN_ERR "Ql:Error during status phase, int=%02X, %d bytes recd\n", i, j);\r\nresult = DID_ERROR;\r\n}\r\noutb(0x12, qbase + 3);\r\nrtrc(1)\r\nif ((k = ql_wai(priv)))\r\nreturn (k << 16);\r\ni = inb(qbase + 5);\r\nwhile (!priv->qabort && ((i & 0x20) != 0x20)) {\r\nbarrier();\r\ncpu_relax();\r\ni |= inb(qbase + 5);\r\n}\r\nrtrc(0)\r\nif (priv->qabort)\r\nreturn ((priv->qabort == 1 ? DID_ABORT : DID_RESET) << 16);\r\nreturn (result << 16) | (message << 8) | (status & STATUS_MASK);\r\n}\r\nstatic void ql_ihandl(void *dev_id)\r\n{\r\nstruct scsi_cmnd *icmd;\r\nstruct Scsi_Host *host = dev_id;\r\nstruct qlogicfas408_priv *priv = get_priv_by_host(host);\r\nint qbase = priv->qbase;\r\nREG0;\r\nif (!(inb(qbase + 4) & 0x80))\r\nreturn;\r\nif (priv->qlcmd == NULL) {\r\nint i;\r\ni = 16;\r\nwhile (i-- && inb(qbase + 5));\r\nreturn;\r\n}\r\nicmd = priv->qlcmd;\r\nicmd->result = ql_pcmd(icmd);\r\npriv->qlcmd = NULL;\r\n(icmd->scsi_done) (icmd);\r\n}\r\nirqreturn_t qlogicfas408_ihandl(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nstruct Scsi_Host *host = dev_id;\r\nspin_lock_irqsave(host->host_lock, flags);\r\nql_ihandl(dev_id);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int qlogicfas408_queuecommand_lck(struct scsi_cmnd *cmd,\r\nvoid (*done) (struct scsi_cmnd *))\r\n{\r\nstruct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);\r\nif (scmd_id(cmd) == priv->qinitid) {\r\ncmd->result = DID_BAD_TARGET << 16;\r\ndone(cmd);\r\nreturn 0;\r\n}\r\ncmd->scsi_done = done;\r\nwhile (priv->qlcmd != NULL) {\r\nbarrier();\r\ncpu_relax();\r\n}\r\nql_icmd(cmd);\r\nreturn 0;\r\n}\r\nint qlogicfas408_biosparam(struct scsi_device *disk, struct block_device *dev,\r\nsector_t capacity, int ip[])\r\n{\r\nip[0] = 0x40;\r\nip[1] = 0x20;\r\nip[2] = (unsigned long) capacity / (ip[0] * ip[1]);\r\nif (ip[2] > 1024) {\r\nip[0] = 0xff;\r\nip[1] = 0x3f;\r\nip[2] = (unsigned long) capacity / (ip[0] * ip[1]);\r\n#if 0\r\nif (ip[2] > 1023)\r\nip[2] = 1023;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nint qlogicfas408_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);\r\npriv->qabort = 1;\r\nql_zap(priv);\r\nreturn SUCCESS;\r\n}\r\nint qlogicfas408_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);\r\nunsigned long flags;\r\npriv->qabort = 2;\r\nspin_lock_irqsave(cmd->device->host->host_lock, flags);\r\nql_zap(priv);\r\nspin_unlock_irqrestore(cmd->device->host->host_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nconst char *qlogicfas408_info(struct Scsi_Host *host)\r\n{\r\nstruct qlogicfas408_priv *priv = get_priv_by_host(host);\r\nreturn priv->qinfo;\r\n}\r\nint qlogicfas408_get_chip_type(int qbase, int int_type)\r\n{\r\nREG1;\r\nreturn inb(qbase + 0xe) & 0xf8;\r\n}\r\nvoid qlogicfas408_setup(int qbase, int id, int int_type)\r\n{\r\noutb(1, qbase + 8);\r\nREG0;\r\noutb(0x40 | qlcfg8 | id, qbase + 8);\r\noutb(qlcfg5, qbase + 5);\r\noutb(qlcfg9, qbase + 9);\r\n#if QL_RESET_AT_START\r\noutb(3, qbase + 3);\r\nREG1;\r\nwhile (inb(qbase + 0xf) & 4)\r\ncpu_relax();\r\nREG0;\r\n#endif\r\n}\r\nint qlogicfas408_detect(int qbase, int int_type)\r\n{\r\nREG1;\r\nreturn (((inb(qbase + 0xe) ^ inb(qbase + 0xe)) == 7) &&\r\n((inb(qbase + 0xe) ^ inb(qbase + 0xe)) == 7));\r\n}\r\nvoid qlogicfas408_disable_ints(struct qlogicfas408_priv *priv)\r\n{\r\nint qbase = priv->qbase;\r\nint int_type = priv->int_type;\r\nREG1;\r\noutb(0, qbase + 0xb);\r\n}\r\nstatic int __init qlogicfas408_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit qlogicfas408_exit(void)\r\n{\r\n}
