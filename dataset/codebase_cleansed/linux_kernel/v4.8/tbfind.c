acpi_status\r\nacpi_tb_find_table(char *signature,\r\nchar *oem_id, char *oem_table_id, u32 *table_index)\r\n{\r\nacpi_status status;\r\nstruct acpi_table_header header;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(tb_find_table);\r\nif (!acpi_ut_valid_nameseg(signature)) {\r\nreturn_ACPI_STATUS(AE_BAD_SIGNATURE);\r\n}\r\nif ((strlen(oem_id) > ACPI_OEM_ID_SIZE) ||\r\n(strlen(oem_table_id) > ACPI_OEM_TABLE_ID_SIZE)) {\r\nreturn_ACPI_STATUS(AE_AML_STRING_LIMIT);\r\n}\r\nmemset(&header, 0, sizeof(struct acpi_table_header));\r\nACPI_MOVE_NAME(header.signature, signature);\r\nstrncpy(header.oem_id, oem_id, ACPI_OEM_ID_SIZE);\r\nstrncpy(header.oem_table_id, oem_table_id, ACPI_OEM_TABLE_ID_SIZE);\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {\r\nif (memcmp(&(acpi_gbl_root_table_list.tables[i].signature),\r\nheader.signature, ACPI_NAME_SIZE)) {\r\ncontinue;\r\n}\r\nif (!acpi_gbl_root_table_list.tables[i].pointer) {\r\nstatus =\r\nacpi_tb_validate_table(&acpi_gbl_root_table_list.\r\ntables[i]);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (!acpi_gbl_root_table_list.tables[i].pointer) {\r\ncontinue;\r\n}\r\n}\r\nif (!memcmp\r\n(acpi_gbl_root_table_list.tables[i].pointer->signature,\r\nheader.signature, ACPI_NAME_SIZE) && (!oem_id[0]\r\n||\r\n!memcmp\r\n(acpi_gbl_root_table_list.\r\ntables[i].pointer->\r\noem_id,\r\nheader.oem_id,\r\nACPI_OEM_ID_SIZE))\r\n&& (!oem_table_id[0]\r\n|| !memcmp(acpi_gbl_root_table_list.tables[i].pointer->\r\noem_table_id, header.oem_table_id,\r\nACPI_OEM_TABLE_ID_SIZE))) {\r\n*table_index = i;\r\nACPI_DEBUG_PRINT((ACPI_DB_TABLES,\r\n"Found table [%4.4s]\n",\r\nheader.signature));\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\n}\r\nreturn_ACPI_STATUS(AE_NOT_FOUND);\r\n}
