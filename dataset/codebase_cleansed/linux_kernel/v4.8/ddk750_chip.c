logical_chip_type_t getChipType(void)\r\n{\r\nunsigned short physicalID;\r\nchar physicalRev;\r\nlogical_chip_type_t chip;\r\nphysicalID = devId750;\r\nphysicalRev = revId750;\r\nif (physicalID == 0x718)\r\nchip = SM718;\r\nelse if (physicalID == 0x750) {\r\nchip = SM750;\r\nif (physicalRev == SM750LE_REVISION_ID)\r\nchip = SM750LE;\r\n} else\r\nchip = SM_UNKNOWN;\r\nreturn chip;\r\n}\r\nstatic unsigned int get_mxclk_freq(void)\r\n{\r\nunsigned int pll_reg;\r\nunsigned int M, N, OD, POD;\r\nif (getChipType() == SM750LE)\r\nreturn MHz(130);\r\npll_reg = PEEK32(MXCLK_PLL_CTRL);\r\nM = (pll_reg & PLL_CTRL_M_MASK) >> PLL_CTRL_M_SHIFT;\r\nN = (pll_reg & PLL_CTRL_N_MASK) >> PLL_CTRL_M_SHIFT;\r\nOD = (pll_reg & PLL_CTRL_OD_MASK) >> PLL_CTRL_OD_SHIFT;\r\nPOD = (pll_reg & PLL_CTRL_POD_MASK) >> PLL_CTRL_POD_SHIFT;\r\nreturn DEFAULT_INPUT_CLOCK * M / N / (1 << OD) / (1 << POD);\r\n}\r\nstatic void setChipClock(unsigned int frequency)\r\n{\r\npll_value_t pll;\r\nunsigned int ulActualMxClk;\r\nif (getChipType() == SM750LE)\r\nreturn;\r\nif (frequency) {\r\npll.inputFreq = DEFAULT_INPUT_CLOCK;\r\npll.clockType = MXCLK_PLL;\r\nulActualMxClk = calcPllValue(frequency, &pll);\r\nPOKE32(MXCLK_PLL_CTRL, formatPllReg(&pll));\r\n}\r\n}\r\nstatic void setMemoryClock(unsigned int frequency)\r\n{\r\nunsigned int reg, divisor;\r\nif (getChipType() == SM750LE)\r\nreturn;\r\nif (frequency) {\r\nif (frequency > MHz(336))\r\nfrequency = MHz(336);\r\ndivisor = roundedDiv(get_mxclk_freq(), frequency);\r\nreg = PEEK32(CURRENT_GATE) & ~CURRENT_GATE_M2XCLK_MASK;\r\nswitch (divisor) {\r\ndefault:\r\ncase 1:\r\nreg |= CURRENT_GATE_M2XCLK_DIV_1;\r\nbreak;\r\ncase 2:\r\nreg |= CURRENT_GATE_M2XCLK_DIV_2;\r\nbreak;\r\ncase 3:\r\nreg |= CURRENT_GATE_M2XCLK_DIV_3;\r\nbreak;\r\ncase 4:\r\nreg |= CURRENT_GATE_M2XCLK_DIV_4;\r\nbreak;\r\n}\r\nsetCurrentGate(reg);\r\n}\r\n}\r\nstatic void setMasterClock(unsigned int frequency)\r\n{\r\nunsigned int reg, divisor;\r\nif (getChipType() == SM750LE)\r\nreturn;\r\nif (frequency) {\r\nif (frequency > MHz(190))\r\nfrequency = MHz(190);\r\ndivisor = roundedDiv(get_mxclk_freq(), frequency);\r\nreg = PEEK32(CURRENT_GATE) & ~CURRENT_GATE_MCLK_MASK;\r\nswitch (divisor) {\r\ndefault:\r\ncase 3:\r\nreg |= CURRENT_GATE_MCLK_DIV_3;\r\nbreak;\r\ncase 4:\r\nreg |= CURRENT_GATE_MCLK_DIV_4;\r\nbreak;\r\ncase 6:\r\nreg |= CURRENT_GATE_MCLK_DIV_6;\r\nbreak;\r\ncase 8:\r\nreg |= CURRENT_GATE_MCLK_DIV_8;\r\nbreak;\r\n}\r\nsetCurrentGate(reg);\r\n}\r\n}\r\nunsigned int ddk750_getVMSize(void)\r\n{\r\nunsigned int reg;\r\nunsigned int data;\r\nif (getChipType() == SM750LE)\r\nreturn SZ_64M;\r\nreg = PEEK32(MODE0_GATE);\r\nreg |= MODE0_GATE_GPIO;\r\nPOKE32(MODE0_GATE, reg);\r\nreg = PEEK32(MISC_CTRL) & MISC_CTRL_LOCALMEM_SIZE_MASK;\r\nswitch (reg) {\r\ncase MISC_CTRL_LOCALMEM_SIZE_8M:\r\ndata = SZ_8M; break;\r\ncase MISC_CTRL_LOCALMEM_SIZE_16M:\r\ndata = SZ_16M; break;\r\ncase MISC_CTRL_LOCALMEM_SIZE_32M:\r\ndata = SZ_32M; break;\r\ncase MISC_CTRL_LOCALMEM_SIZE_64M:\r\ndata = SZ_64M; break;\r\ndefault:\r\ndata = 0;\r\nbreak;\r\n}\r\nreturn data;\r\n}\r\nint ddk750_initHw(initchip_param_t *pInitParam)\r\n{\r\nunsigned int reg;\r\nif (pInitParam->powerMode != 0)\r\npInitParam->powerMode = 0;\r\nsetPowerMode(pInitParam->powerMode);\r\nreg = PEEK32(CURRENT_GATE);\r\nreg |= (CURRENT_GATE_DISPLAY | CURRENT_GATE_LOCALMEM);\r\nsetCurrentGate(reg);\r\nif (getChipType() != SM750LE) {\r\nreg = PEEK32(VGA_CONFIGURATION);\r\nreg |= (VGA_CONFIGURATION_PLL | VGA_CONFIGURATION_MODE);\r\nPOKE32(VGA_CONFIGURATION, reg);\r\n} else {\r\n#if defined(__i386__) || defined(__x86_64__)\r\noutb_p(0x88, 0x3d4);\r\noutb_p(0x06, 0x3d5);\r\n#endif\r\n}\r\nsetChipClock(MHz((unsigned int)pInitParam->chipClock));\r\nsetMemoryClock(MHz(pInitParam->memClock));\r\nsetMasterClock(MHz(pInitParam->masterClock));\r\nif (pInitParam->resetMemory == 1) {\r\nreg = PEEK32(MISC_CTRL);\r\nreg &= ~MISC_CTRL_LOCALMEM_RESET;\r\nPOKE32(MISC_CTRL, reg);\r\nreg |= MISC_CTRL_LOCALMEM_RESET;\r\nPOKE32(MISC_CTRL, reg);\r\n}\r\nif (pInitParam->setAllEngOff == 1) {\r\nenable2DEngine(0);\r\nreg = PEEK32(VIDEO_DISPLAY_CTRL);\r\nreg &= ~DISPLAY_CTRL_PLANE;\r\nPOKE32(VIDEO_DISPLAY_CTRL, reg);\r\nreg = PEEK32(VIDEO_ALPHA_DISPLAY_CTRL);\r\nreg &= ~DISPLAY_CTRL_PLANE;\r\nPOKE32(VIDEO_ALPHA_DISPLAY_CTRL, reg);\r\nreg = PEEK32(ALPHA_DISPLAY_CTRL);\r\nreg &= ~DISPLAY_CTRL_PLANE;\r\nPOKE32(ALPHA_DISPLAY_CTRL, reg);\r\nreg = PEEK32(DMA_ABORT_INTERRUPT);\r\nreg |= DMA_ABORT_INTERRUPT_ABORT_1;\r\nPOKE32(DMA_ABORT_INTERRUPT, reg);\r\nenableDMA(0);\r\n}\r\nreturn 0;\r\n}\r\nunsigned int calcPllValue(unsigned int request_orig, pll_value_t *pll)\r\n{\r\nint N, M, X, d;\r\nint mini_diff;\r\nunsigned int RN, quo, rem, fl_quo;\r\nunsigned int input, request;\r\nunsigned int tmpClock, ret;\r\nconst int max_OD = 3;\r\nint max_d = 6;\r\nif (getChipType() == SM750LE) {\r\nreturn request_orig;\r\n}\r\nret = 0;\r\nmini_diff = ~0;\r\nrequest = request_orig / 1000;\r\ninput = pll->inputFreq / 1000;\r\nif (pll->clockType == MXCLK_PLL)\r\nmax_d = 3;\r\nfor (N = 15; N > 1; N--) {\r\nRN = N * request;\r\nquo = RN / input;\r\nrem = RN % input;\r\nfl_quo = (rem * 10000 / input);\r\nfor (d = max_d; d >= 0; d--) {\r\nX = (1 << d);\r\nM = quo * X;\r\nM += fl_quo * X / 10000;\r\nM += (fl_quo * X % 10000) > 5000 ? 1 : 0;\r\nif (M < 256 && M > 0) {\r\nunsigned int diff;\r\ntmpClock = pll->inputFreq * M / N / X;\r\ndiff = abs(tmpClock - request_orig);\r\nif (diff < mini_diff) {\r\npll->M = M;\r\npll->N = N;\r\npll->POD = 0;\r\nif (d > max_OD)\r\npll->POD = d - max_OD;\r\npll->OD = d - pll->POD;\r\nmini_diff = diff;\r\nret = tmpClock;\r\n}\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nunsigned int formatPllReg(pll_value_t *pPLL)\r\n{\r\n#ifndef VALIDATION_CHIP\r\nunsigned int POD = pPLL->POD;\r\n#endif\r\nunsigned int OD = pPLL->OD;\r\nunsigned int M = pPLL->M;\r\nunsigned int N = pPLL->N;\r\nunsigned int reg = 0;\r\nreg = PLL_CTRL_POWER |\r\n#ifndef VALIDATION_CHIP\r\n((POD << PLL_CTRL_POD_SHIFT) & PLL_CTRL_POD_MASK) |\r\n#endif\r\n((OD << PLL_CTRL_OD_SHIFT) & PLL_CTRL_OD_MASK) |\r\n((N << PLL_CTRL_N_SHIFT) & PLL_CTRL_N_MASK) |\r\n((M << PLL_CTRL_M_SHIFT) & PLL_CTRL_M_MASK);\r\nreturn reg;\r\n}
