static int push_cxx_to_hypervisor(struct acpi_processor *_pr)\r\n{\r\nstruct xen_platform_op op = {\r\n.cmd = XENPF_set_processor_pminfo,\r\n.interface_version = XENPF_INTERFACE_VERSION,\r\n.u.set_pminfo.id = _pr->acpi_id,\r\n.u.set_pminfo.type = XEN_PM_CX,\r\n};\r\nstruct xen_processor_cx *dst_cx, *dst_cx_states = NULL;\r\nstruct acpi_processor_cx *cx;\r\nunsigned int i, ok;\r\nint ret = 0;\r\ndst_cx_states = kcalloc(_pr->power.count,\r\nsizeof(struct xen_processor_cx), GFP_KERNEL);\r\nif (!dst_cx_states)\r\nreturn -ENOMEM;\r\nfor (ok = 0, i = 1; i <= _pr->power.count; i++) {\r\ncx = &_pr->power.states[i];\r\nif (!cx->valid)\r\ncontinue;\r\ndst_cx = &(dst_cx_states[ok++]);\r\ndst_cx->reg.space_id = ACPI_ADR_SPACE_SYSTEM_IO;\r\nif (cx->entry_method == ACPI_CSTATE_SYSTEMIO) {\r\ndst_cx->reg.bit_width = 8;\r\ndst_cx->reg.bit_offset = 0;\r\ndst_cx->reg.access_size = 1;\r\n} else {\r\ndst_cx->reg.space_id = ACPI_ADR_SPACE_FIXED_HARDWARE;\r\nif (cx->entry_method == ACPI_CSTATE_FFH) {\r\ndst_cx->reg.bit_offset = 2;\r\ndst_cx->reg.bit_width = 1;\r\n}\r\ndst_cx->reg.access_size = 0;\r\n}\r\ndst_cx->reg.address = cx->address;\r\ndst_cx->type = cx->type;\r\ndst_cx->latency = cx->latency;\r\ndst_cx->dpcnt = 0;\r\nset_xen_guest_handle(dst_cx->dp, NULL);\r\n}\r\nif (!ok) {\r\npr_debug("No _Cx for ACPI CPU %u\n", _pr->acpi_id);\r\nkfree(dst_cx_states);\r\nreturn -EINVAL;\r\n}\r\nop.u.set_pminfo.power.count = ok;\r\nop.u.set_pminfo.power.flags.bm_control = _pr->flags.bm_control;\r\nop.u.set_pminfo.power.flags.bm_check = _pr->flags.bm_check;\r\nop.u.set_pminfo.power.flags.has_cst = _pr->flags.has_cst;\r\nop.u.set_pminfo.power.flags.power_setup_done =\r\n_pr->flags.power_setup_done;\r\nset_xen_guest_handle(op.u.set_pminfo.power.states, dst_cx_states);\r\nif (!no_hypercall)\r\nret = HYPERVISOR_platform_op(&op);\r\nif (!ret) {\r\npr_debug("ACPI CPU%u - C-states uploaded.\n", _pr->acpi_id);\r\nfor (i = 1; i <= _pr->power.count; i++) {\r\ncx = &_pr->power.states[i];\r\nif (!cx->valid)\r\ncontinue;\r\npr_debug(" C%d: %s %d uS\n",\r\ncx->type, cx->desc, (u32)cx->latency);\r\n}\r\n} else if ((ret != -EINVAL) && (ret != -ENOSYS))\r\npr_err("(CX): Hypervisor error (%d) for ACPI CPU%u\n",\r\nret, _pr->acpi_id);\r\nkfree(dst_cx_states);\r\nreturn ret;\r\n}\r\nstatic struct xen_processor_px *\r\nxen_copy_pss_data(struct acpi_processor *_pr,\r\nstruct xen_processor_performance *dst_perf)\r\n{\r\nstruct xen_processor_px *dst_states = NULL;\r\nunsigned int i;\r\nBUILD_BUG_ON(sizeof(struct xen_processor_px) !=\r\nsizeof(struct acpi_processor_px));\r\ndst_states = kcalloc(_pr->performance->state_count,\r\nsizeof(struct xen_processor_px), GFP_KERNEL);\r\nif (!dst_states)\r\nreturn ERR_PTR(-ENOMEM);\r\ndst_perf->state_count = _pr->performance->state_count;\r\nfor (i = 0; i < _pr->performance->state_count; i++) {\r\nmemcpy(&(dst_states[i]), &(_pr->performance->states[i]),\r\nsizeof(struct acpi_processor_px));\r\n}\r\nreturn dst_states;\r\n}\r\nstatic int xen_copy_psd_data(struct acpi_processor *_pr,\r\nstruct xen_processor_performance *dst)\r\n{\r\nstruct acpi_psd_package *pdomain;\r\nBUILD_BUG_ON(sizeof(struct xen_psd_package) !=\r\nsizeof(struct acpi_psd_package));\r\ndst->shared_type = _pr->performance->shared_type;\r\npdomain = &(_pr->performance->domain_info);\r\nif (pdomain->num_processors <= 1) {\r\nif (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ALL)\r\ndst->shared_type = CPUFREQ_SHARED_TYPE_ALL;\r\nelse if (pdomain->coord_type == DOMAIN_COORD_TYPE_HW_ALL)\r\ndst->shared_type = CPUFREQ_SHARED_TYPE_HW;\r\nelse if (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ANY)\r\ndst->shared_type = CPUFREQ_SHARED_TYPE_ANY;\r\n}\r\nmemcpy(&(dst->domain_info), pdomain, sizeof(struct acpi_psd_package));\r\nreturn 0;\r\n}\r\nstatic int xen_copy_pct_data(struct acpi_pct_register *pct,\r\nstruct xen_pct_register *dst_pct)\r\n{\r\ndst_pct->descriptor = pct->descriptor;\r\ndst_pct->length = pct->length;\r\ndst_pct->space_id = pct->space_id;\r\ndst_pct->bit_width = pct->bit_width;\r\ndst_pct->bit_offset = pct->bit_offset;\r\ndst_pct->reserved = pct->reserved;\r\ndst_pct->address = pct->address;\r\nreturn 0;\r\n}\r\nstatic int push_pxx_to_hypervisor(struct acpi_processor *_pr)\r\n{\r\nint ret = 0;\r\nstruct xen_platform_op op = {\r\n.cmd = XENPF_set_processor_pminfo,\r\n.interface_version = XENPF_INTERFACE_VERSION,\r\n.u.set_pminfo.id = _pr->acpi_id,\r\n.u.set_pminfo.type = XEN_PM_PX,\r\n};\r\nstruct xen_processor_performance *dst_perf;\r\nstruct xen_processor_px *dst_states = NULL;\r\ndst_perf = &op.u.set_pminfo.perf;\r\ndst_perf->platform_limit = _pr->performance_platform_limit;\r\ndst_perf->flags |= XEN_PX_PPC;\r\nxen_copy_pct_data(&(_pr->performance->control_register),\r\n&dst_perf->control_register);\r\nxen_copy_pct_data(&(_pr->performance->status_register),\r\n&dst_perf->status_register);\r\ndst_perf->flags |= XEN_PX_PCT;\r\ndst_states = xen_copy_pss_data(_pr, dst_perf);\r\nif (!IS_ERR_OR_NULL(dst_states)) {\r\nset_xen_guest_handle(dst_perf->states, dst_states);\r\ndst_perf->flags |= XEN_PX_PSS;\r\n}\r\nif (!xen_copy_psd_data(_pr, dst_perf))\r\ndst_perf->flags |= XEN_PX_PSD;\r\nif (dst_perf->flags != (XEN_PX_PSD | XEN_PX_PSS | XEN_PX_PCT | XEN_PX_PPC)) {\r\npr_warn("ACPI CPU%u missing some P-state data (%x), skipping\n",\r\n_pr->acpi_id, dst_perf->flags);\r\nret = -ENODEV;\r\ngoto err_free;\r\n}\r\nif (!no_hypercall)\r\nret = HYPERVISOR_platform_op(&op);\r\nif (!ret) {\r\nstruct acpi_processor_performance *perf;\r\nunsigned int i;\r\nperf = _pr->performance;\r\npr_debug("ACPI CPU%u - P-states uploaded.\n", _pr->acpi_id);\r\nfor (i = 0; i < perf->state_count; i++) {\r\npr_debug(" %cP%d: %d MHz, %d mW, %d uS\n",\r\n(i == perf->state ? '*' : ' '), i,\r\n(u32) perf->states[i].core_frequency,\r\n(u32) perf->states[i].power,\r\n(u32) perf->states[i].transition_latency);\r\n}\r\n} else if ((ret != -EINVAL) && (ret != -ENOSYS))\r\npr_warn("(_PXX): Hypervisor error (%d) for ACPI CPU%u\n",\r\nret, _pr->acpi_id);\r\nerr_free:\r\nif (!IS_ERR_OR_NULL(dst_states))\r\nkfree(dst_states);\r\nreturn ret;\r\n}\r\nstatic int upload_pm_data(struct acpi_processor *_pr)\r\n{\r\nint err = 0;\r\nmutex_lock(&acpi_ids_mutex);\r\nif (__test_and_set_bit(_pr->acpi_id, acpi_ids_done)) {\r\nmutex_unlock(&acpi_ids_mutex);\r\nreturn -EBUSY;\r\n}\r\nif (_pr->flags.power)\r\nerr = push_cxx_to_hypervisor(_pr);\r\nif (_pr->performance && _pr->performance->states)\r\nerr |= push_pxx_to_hypervisor(_pr);\r\nmutex_unlock(&acpi_ids_mutex);\r\nreturn err;\r\n}\r\nstatic unsigned int __init get_max_acpi_id(void)\r\n{\r\nstruct xenpf_pcpuinfo *info;\r\nstruct xen_platform_op op = {\r\n.cmd = XENPF_get_cpuinfo,\r\n.interface_version = XENPF_INTERFACE_VERSION,\r\n};\r\nint ret = 0;\r\nunsigned int i, last_cpu, max_acpi_id = 0;\r\ninfo = &op.u.pcpu_info;\r\ninfo->xen_cpuid = 0;\r\nret = HYPERVISOR_platform_op(&op);\r\nif (ret)\r\nreturn NR_CPUS;\r\nlast_cpu = op.u.pcpu_info.max_present;\r\nfor (i = 0; i <= last_cpu; i++) {\r\ninfo->xen_cpuid = i;\r\nret = HYPERVISOR_platform_op(&op);\r\nif (ret)\r\ncontinue;\r\nmax_acpi_id = max(info->acpi_id, max_acpi_id);\r\n}\r\nmax_acpi_id *= 2;\r\npr_debug("Max ACPI ID: %u\n", max_acpi_id);\r\nreturn max_acpi_id;\r\n}\r\nstatic acpi_status\r\nread_acpi_id(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nu32 acpi_id;\r\nacpi_status status;\r\nacpi_object_type acpi_type;\r\nunsigned long long tmp;\r\nunion acpi_object object = { 0 };\r\nstruct acpi_buffer buffer = { sizeof(union acpi_object), &object };\r\nacpi_io_address pblk = 0;\r\nstatus = acpi_get_type(handle, &acpi_type);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nswitch (acpi_type) {\r\ncase ACPI_TYPE_PROCESSOR:\r\nstatus = acpi_evaluate_object(handle, NULL, NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nacpi_id = object.processor.proc_id;\r\npblk = object.processor.pblk_address;\r\nbreak;\r\ncase ACPI_TYPE_DEVICE:\r\nstatus = acpi_evaluate_integer(handle, "_UID", NULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nacpi_id = tmp;\r\nbreak;\r\ndefault:\r\nreturn AE_OK;\r\n}\r\nif (acpi_id > nr_acpi_bits) {\r\npr_debug("We only have %u, trying to set %u\n",\r\nnr_acpi_bits, acpi_id);\r\nreturn AE_OK;\r\n}\r\n__set_bit(acpi_id, acpi_id_present);\r\npr_debug("ACPI CPU%u w/ PBLK:0x%lx\n", acpi_id, (unsigned long)pblk);\r\nstatus = acpi_evaluate_object(handle, "_CST", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nif (!pblk)\r\nreturn AE_OK;\r\n}\r\n__set_bit(acpi_id, acpi_id_cst_present);\r\nreturn AE_OK;\r\n}\r\nstatic int check_acpi_ids(struct acpi_processor *pr_backup)\r\n{\r\nif (!pr_backup)\r\nreturn -ENODEV;\r\nif (acpi_id_present && acpi_id_cst_present)\r\ngoto upload;\r\nacpi_id_present = kcalloc(BITS_TO_LONGS(nr_acpi_bits), sizeof(unsigned long), GFP_KERNEL);\r\nif (!acpi_id_present)\r\nreturn -ENOMEM;\r\nacpi_id_cst_present = kcalloc(BITS_TO_LONGS(nr_acpi_bits), sizeof(unsigned long), GFP_KERNEL);\r\nif (!acpi_id_cst_present) {\r\nkfree(acpi_id_present);\r\nreturn -ENOMEM;\r\n}\r\nacpi_walk_namespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nread_acpi_id, NULL, NULL, NULL);\r\nacpi_get_devices("ACPI0007", read_acpi_id, NULL, NULL);\r\nupload:\r\nif (!bitmap_equal(acpi_id_present, acpi_ids_done, nr_acpi_bits)) {\r\nunsigned int i;\r\nfor_each_set_bit(i, acpi_id_present, nr_acpi_bits) {\r\npr_backup->acpi_id = i;\r\npr_backup->flags.power = test_bit(i, acpi_id_cst_present);\r\n(void)upload_pm_data(pr_backup);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_acpi_perf_data(void)\r\n{\r\nunsigned int i;\r\nfor_each_possible_cpu(i)\r\nfree_cpumask_var(per_cpu_ptr(acpi_perf_data, i)\r\n->shared_cpu_map);\r\nfree_percpu(acpi_perf_data);\r\n}\r\nstatic int xen_upload_processor_pm_data(void)\r\n{\r\nstruct acpi_processor *pr_backup = NULL;\r\nunsigned int i;\r\nint rc = 0;\r\npr_info("Uploading Xen processor PM info\n");\r\nfor_each_possible_cpu(i) {\r\nstruct acpi_processor *_pr;\r\n_pr = per_cpu(processors, i );\r\nif (!_pr)\r\ncontinue;\r\nif (!pr_backup) {\r\npr_backup = kzalloc(sizeof(struct acpi_processor), GFP_KERNEL);\r\nif (pr_backup)\r\nmemcpy(pr_backup, _pr, sizeof(struct acpi_processor));\r\n}\r\n(void)upload_pm_data(_pr);\r\n}\r\nrc = check_acpi_ids(pr_backup);\r\nkfree(pr_backup);\r\nreturn rc;\r\n}\r\nstatic int xen_acpi_processor_resume(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nbitmap_zero(acpi_ids_done, nr_acpi_bits);\r\nreturn xen_upload_processor_pm_data();\r\n}\r\nstatic int __init xen_acpi_processor_init(void)\r\n{\r\nunsigned int i;\r\nint rc;\r\nif (!xen_initial_domain())\r\nreturn -ENODEV;\r\nnr_acpi_bits = get_max_acpi_id() + 1;\r\nacpi_ids_done = kcalloc(BITS_TO_LONGS(nr_acpi_bits), sizeof(unsigned long), GFP_KERNEL);\r\nif (!acpi_ids_done)\r\nreturn -ENOMEM;\r\nacpi_perf_data = alloc_percpu(struct acpi_processor_performance);\r\nif (!acpi_perf_data) {\r\npr_debug("Memory allocation error for acpi_perf_data\n");\r\nkfree(acpi_ids_done);\r\nreturn -ENOMEM;\r\n}\r\nfor_each_possible_cpu(i) {\r\nif (!zalloc_cpumask_var_node(\r\n&per_cpu_ptr(acpi_perf_data, i)->shared_cpu_map,\r\nGFP_KERNEL, cpu_to_node(i))) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\n}\r\n(void)acpi_processor_preregister_performance(acpi_perf_data);\r\nfor_each_possible_cpu(i) {\r\nstruct acpi_processor *pr;\r\nstruct acpi_processor_performance *perf;\r\npr = per_cpu(processors, i);\r\nperf = per_cpu_ptr(acpi_perf_data, i);\r\nif (!pr)\r\ncontinue;\r\npr->performance = perf;\r\nrc = acpi_processor_get_performance_info(pr);\r\nif (rc)\r\ngoto err_out;\r\n}\r\nrc = xen_upload_processor_pm_data();\r\nif (rc)\r\ngoto err_unregister;\r\nxen_resume_notifier_register(&xen_acpi_processor_resume_nb);\r\nreturn 0;\r\nerr_unregister:\r\nfor_each_possible_cpu(i)\r\nacpi_processor_unregister_performance(i);\r\nerr_out:\r\nfree_acpi_perf_data();\r\nkfree(acpi_ids_done);\r\nreturn rc;\r\n}\r\nstatic void __exit xen_acpi_processor_exit(void)\r\n{\r\nint i;\r\nxen_resume_notifier_unregister(&xen_acpi_processor_resume_nb);\r\nkfree(acpi_ids_done);\r\nkfree(acpi_id_present);\r\nkfree(acpi_id_cst_present);\r\nfor_each_possible_cpu(i)\r\nacpi_processor_unregister_performance(i);\r\nfree_acpi_perf_data();\r\n}
