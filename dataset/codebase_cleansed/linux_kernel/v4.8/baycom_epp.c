static inline int check_crc_ccitt(const unsigned char *buf, int cnt)\r\n{\r\nreturn (crc_ccitt(0xffff, buf, cnt) & 0xffff) == 0xf0b8;\r\n}\r\nstatic inline int calc_crc_ccitt(const unsigned char *buf, int cnt)\r\n{\r\nreturn (crc_ccitt(0xffff, buf, cnt) ^ 0xffff) & 0xffff;\r\n}\r\nstatic inline void baycom_int_freq(struct baycom_state *bc)\r\n{\r\n#ifdef BAYCOM_DEBUG\r\nunsigned long cur_jiffies = jiffies;\r\nbc->debug_vals.cur_intcnt++;\r\nif (time_after_eq(cur_jiffies, bc->debug_vals.last_jiffies + HZ)) {\r\nbc->debug_vals.last_jiffies = cur_jiffies;\r\nbc->debug_vals.last_intcnt = bc->debug_vals.cur_intcnt;\r\nbc->debug_vals.cur_intcnt = 0;\r\nbc->debug_vals.last_pllcorr = bc->debug_vals.cur_pllcorr;\r\nbc->debug_vals.cur_pllcorr = 0;\r\n}\r\n#endif\r\n}\r\nstatic int eppconfig(struct baycom_state *bc)\r\n{\r\nchar modearg[256];\r\nchar portarg[16];\r\nchar *argv[] = { eppconfig_path, "-s", "-p", portarg, "-m", modearg,\r\nNULL };\r\nsprintf(modearg, "%sclk,%smodem,fclk=%d,bps=%d,divider=%d%s,extstat",\r\nbc->cfg.intclk ? "int" : "ext",\r\nbc->cfg.extmodem ? "ext" : "int", bc->cfg.fclk, bc->cfg.bps,\r\n(bc->cfg.fclk + 8 * bc->cfg.bps) / (16 * bc->cfg.bps),\r\nbc->cfg.loopback ? ",loopback" : "");\r\nsprintf(portarg, "%ld", bc->pdev->port->base);\r\nprintk(KERN_DEBUG "%s: %s -s -p %s -m %s\n", bc_drvname, eppconfig_path, portarg, modearg);\r\nreturn call_usermodehelper(eppconfig_path, argv, envp, UMH_WAIT_PROC);\r\n}\r\nstatic inline void do_kiss_params(struct baycom_state *bc,\r\nunsigned char *data, unsigned long len)\r\n{\r\n#ifdef KISS_VERBOSE\r\n#define PKP(a,b) printk(KERN_INFO "baycomm_epp: channel params: " a "\n", b)\r\n#else\r\n#define PKP(a,b)\r\n#endif\r\nif (len < 2)\r\nreturn;\r\nswitch(data[0]) {\r\ncase PARAM_TXDELAY:\r\nbc->ch_params.tx_delay = data[1];\r\nPKP("TX delay = %ums", 10 * bc->ch_params.tx_delay);\r\nbreak;\r\ncase PARAM_PERSIST:\r\nbc->ch_params.ppersist = data[1];\r\nPKP("p persistence = %u", bc->ch_params.ppersist);\r\nbreak;\r\ncase PARAM_SLOTTIME:\r\nbc->ch_params.slottime = data[1];\r\nPKP("slot time = %ums", bc->ch_params.slottime);\r\nbreak;\r\ncase PARAM_TXTAIL:\r\nbc->ch_params.tx_tail = data[1];\r\nPKP("TX tail = %ums", bc->ch_params.tx_tail);\r\nbreak;\r\ncase PARAM_FULLDUP:\r\nbc->ch_params.fulldup = !!data[1];\r\nPKP("%s duplex", bc->ch_params.fulldup ? "full" : "half");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#undef PKP\r\n}\r\nstatic void encode_hdlc(struct baycom_state *bc)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *wp, *bp;\r\nint pkt_len;\r\nunsigned bitstream, notbitstream, bitbuf, numbit, crc;\r\nunsigned char crcarr[2];\r\nint j;\r\nif (bc->hdlctx.bufcnt > 0)\r\nreturn;\r\nskb = bc->skb;\r\nif (!skb)\r\nreturn;\r\nbc->skb = NULL;\r\npkt_len = skb->len-1;\r\nwp = bc->hdlctx.buf;\r\nbp = skb->data+1;\r\ncrc = calc_crc_ccitt(bp, pkt_len);\r\ncrcarr[0] = crc;\r\ncrcarr[1] = crc >> 8;\r\n*wp++ = 0x7e;\r\nbitstream = bitbuf = numbit = 0;\r\nwhile (pkt_len > -2) {\r\nbitstream >>= 8;\r\nbitstream |= ((unsigned int)*bp) << 8;\r\nbitbuf |= ((unsigned int)*bp) << numbit;\r\nnotbitstream = ~bitstream;\r\nbp++;\r\npkt_len--;\r\nif (!pkt_len)\r\nbp = crcarr;\r\nfor (j = 0; j < 8; j++)\r\nif (unlikely(!(notbitstream & (0x1f0 << j)))) {\r\nbitstream &= ~(0x100 << j);\r\nbitbuf = (bitbuf & (((2 << j) << numbit) - 1)) |\r\n((bitbuf & ~(((2 << j) << numbit) - 1)) << 1);\r\nnumbit++;\r\nnotbitstream = ~bitstream;\r\n}\r\nnumbit += 8;\r\nwhile (numbit >= 8) {\r\n*wp++ = bitbuf;\r\nbitbuf >>= 8;\r\nnumbit -= 8;\r\n}\r\n}\r\nbitbuf |= 0x7e7e << numbit;\r\nnumbit += 16;\r\nwhile (numbit >= 8) {\r\n*wp++ = bitbuf;\r\nbitbuf >>= 8;\r\nnumbit -= 8;\r\n}\r\nbc->hdlctx.bufptr = bc->hdlctx.buf;\r\nbc->hdlctx.bufcnt = wp - bc->hdlctx.buf;\r\ndev_kfree_skb(skb);\r\nbc->dev->stats.tx_packets++;\r\n}\r\nstatic int transmit(struct baycom_state *bc, int cnt, unsigned char stat)\r\n{\r\nstruct parport *pp = bc->pdev->port;\r\nunsigned char tmp[128];\r\nint i, j;\r\nif (bc->hdlctx.state == tx_tail && !(stat & EPP_PTTBIT))\r\nbc->hdlctx.state = tx_idle;\r\nif (bc->hdlctx.state == tx_idle && bc->hdlctx.calibrate <= 0) {\r\nif (bc->hdlctx.bufcnt <= 0)\r\nencode_hdlc(bc);\r\nif (bc->hdlctx.bufcnt <= 0)\r\nreturn 0;\r\nif (!bc->ch_params.fulldup) {\r\nif (!(stat & EPP_DCDBIT)) {\r\nbc->hdlctx.slotcnt = bc->ch_params.slottime;\r\nreturn 0;\r\n}\r\nif ((--bc->hdlctx.slotcnt) > 0)\r\nreturn 0;\r\nbc->hdlctx.slotcnt = bc->ch_params.slottime;\r\nif ((prandom_u32() % 256) > bc->ch_params.ppersist)\r\nreturn 0;\r\n}\r\n}\r\nif (bc->hdlctx.state == tx_idle && bc->hdlctx.bufcnt > 0) {\r\nbc->hdlctx.state = tx_keyup;\r\nbc->hdlctx.flags = tenms_to_flags(bc, bc->ch_params.tx_delay);\r\nbc->ptt_keyed++;\r\n}\r\nwhile (cnt > 0) {\r\nswitch (bc->hdlctx.state) {\r\ncase tx_keyup:\r\ni = min_t(int, cnt, bc->hdlctx.flags);\r\ncnt -= i;\r\nbc->hdlctx.flags -= i;\r\nif (bc->hdlctx.flags <= 0)\r\nbc->hdlctx.state = tx_data;\r\nmemset(tmp, 0x7e, sizeof(tmp));\r\nwhile (i > 0) {\r\nj = (i > sizeof(tmp)) ? sizeof(tmp) : i;\r\nif (j != pp->ops->epp_write_data(pp, tmp, j, 0))\r\nreturn -1;\r\ni -= j;\r\n}\r\nbreak;\r\ncase tx_data:\r\nif (bc->hdlctx.bufcnt <= 0) {\r\nencode_hdlc(bc);\r\nif (bc->hdlctx.bufcnt <= 0) {\r\nbc->hdlctx.state = tx_tail;\r\nbc->hdlctx.flags = tenms_to_flags(bc, bc->ch_params.tx_tail);\r\nbreak;\r\n}\r\n}\r\ni = min_t(int, cnt, bc->hdlctx.bufcnt);\r\nbc->hdlctx.bufcnt -= i;\r\ncnt -= i;\r\nif (i != pp->ops->epp_write_data(pp, bc->hdlctx.bufptr, i, 0))\r\nreturn -1;\r\nbc->hdlctx.bufptr += i;\r\nbreak;\r\ncase tx_tail:\r\nencode_hdlc(bc);\r\nif (bc->hdlctx.bufcnt > 0) {\r\nbc->hdlctx.state = tx_data;\r\nbreak;\r\n}\r\ni = min_t(int, cnt, bc->hdlctx.flags);\r\nif (i) {\r\ncnt -= i;\r\nbc->hdlctx.flags -= i;\r\nmemset(tmp, 0x7e, sizeof(tmp));\r\nwhile (i > 0) {\r\nj = (i > sizeof(tmp)) ? sizeof(tmp) : i;\r\nif (j != pp->ops->epp_write_data(pp, tmp, j, 0))\r\nreturn -1;\r\ni -= j;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nif (bc->hdlctx.calibrate <= 0)\r\nreturn 0;\r\ni = min_t(int, cnt, bc->hdlctx.calibrate);\r\ncnt -= i;\r\nbc->hdlctx.calibrate -= i;\r\nmemset(tmp, 0, sizeof(tmp));\r\nwhile (i > 0) {\r\nj = (i > sizeof(tmp)) ? sizeof(tmp) : i;\r\nif (j != pp->ops->epp_write_data(pp, tmp, j, 0))\r\nreturn -1;\r\ni -= j;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_rxpacket(struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nunsigned char *cp;\r\nunsigned pktlen;\r\nif (bc->hdlcrx.bufcnt < 4)\r\nreturn;\r\nif (!check_crc_ccitt(bc->hdlcrx.buf, bc->hdlcrx.bufcnt))\r\nreturn;\r\npktlen = bc->hdlcrx.bufcnt-2+1;\r\nif (!(skb = dev_alloc_skb(pktlen))) {\r\nprintk("%s: memory squeeze, dropping packet\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\ncp = skb_put(skb, pktlen);\r\n*cp++ = 0;\r\nmemcpy(cp, bc->hdlcrx.buf, pktlen - 1);\r\nskb->protocol = ax25_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nstatic int receive(struct net_device *dev, int cnt)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nstruct parport *pp = bc->pdev->port;\r\nunsigned int bitbuf, notbitstream, bitstream, numbits, state;\r\nunsigned char tmp[128];\r\nunsigned char *cp;\r\nint cnt2, ret = 0;\r\nint j;\r\nnumbits = bc->hdlcrx.numbits;\r\nstate = bc->hdlcrx.state;\r\nbitstream = bc->hdlcrx.bitstream;\r\nbitbuf = bc->hdlcrx.bitbuf;\r\nwhile (cnt > 0) {\r\ncnt2 = (cnt > sizeof(tmp)) ? sizeof(tmp) : cnt;\r\ncnt -= cnt2;\r\nif (cnt2 != pp->ops->epp_read_data(pp, tmp, cnt2, 0)) {\r\nret = -1;\r\nbreak;\r\n}\r\ncp = tmp;\r\nfor (; cnt2 > 0; cnt2--, cp++) {\r\nbitstream >>= 8;\r\nbitstream |= (*cp) << 8;\r\nbitbuf >>= 8;\r\nbitbuf |= (*cp) << 8;\r\nnumbits += 8;\r\nnotbitstream = ~bitstream;\r\nfor (j = 0; j < 8; j++) {\r\nif (unlikely(!(notbitstream & (0x0fc << j)))) {\r\nif (!(notbitstream & (0x1fc << j)))\r\nstate = 0;\r\nelse if ((bitstream & (0x1fe << j)) == (0x0fc << j)) {\r\nif (state)\r\ndo_rxpacket(dev);\r\nbc->hdlcrx.bufcnt = 0;\r\nbc->hdlcrx.bufptr = bc->hdlcrx.buf;\r\nstate = 1;\r\nnumbits = 7-j;\r\n}\r\n}\r\nelse if (unlikely((bitstream & (0x1f8 << j)) == (0xf8 << j))) {\r\nnumbits--;\r\nbitbuf = (bitbuf & ((~0xff) << j)) | ((bitbuf & ~((~0xff) << j)) << 1);\r\n}\r\n}\r\nwhile (state && numbits >= 8) {\r\nif (bc->hdlcrx.bufcnt >= TXBUFFER_SIZE) {\r\nstate = 0;\r\n} else {\r\n*(bc->hdlcrx.bufptr)++ = bitbuf >> (16-numbits);\r\nbc->hdlcrx.bufcnt++;\r\nnumbits -= 8;\r\n}\r\n}\r\n}\r\n}\r\nbc->hdlcrx.numbits = numbits;\r\nbc->hdlcrx.state = state;\r\nbc->hdlcrx.bitstream = bitstream;\r\nbc->hdlcrx.bitbuf = bitbuf;\r\nreturn ret;\r\n}\r\nstatic void epp_bh(struct work_struct *work)\r\n{\r\nstruct net_device *dev;\r\nstruct baycom_state *bc;\r\nstruct parport *pp;\r\nunsigned char stat;\r\nunsigned char tmp[2];\r\nunsigned int time1 = 0, time2 = 0, time3 = 0;\r\nint cnt, cnt2;\r\nbc = container_of(work, struct baycom_state, run_work.work);\r\ndev = bc->dev;\r\nif (!bc->work_running)\r\nreturn;\r\nbaycom_int_freq(bc);\r\npp = bc->pdev->port;\r\nif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\r\ngoto epptimeout;\r\nbc->stat = stat;\r\nbc->debug_vals.last_pllcorr = stat;\r\nGETTICK(time1);\r\nif (bc->modem == EPP_FPGAEXTSTATUS) {\r\ntmp[0] = EPP_TX_FIFO_ENABLE|EPP_RX_FIFO_ENABLE|EPP_MODEM_ENABLE|1;\r\nif (pp->ops->epp_write_addr(pp, tmp, 1, 0) != 1)\r\ngoto epptimeout;\r\nif (pp->ops->epp_read_addr(pp, tmp, 2, 0) != 2)\r\ngoto epptimeout;\r\ncnt = tmp[0] | (tmp[1] << 8);\r\ncnt &= 0x7fff;\r\ntmp[0] = EPP_TX_FIFO_ENABLE|EPP_RX_FIFO_ENABLE|EPP_MODEM_ENABLE|2;\r\nif (pp->ops->epp_write_addr(pp, tmp, 1, 0) != 1)\r\ngoto epptimeout;\r\nif (pp->ops->epp_read_addr(pp, tmp, 2, 0) != 2)\r\ngoto epptimeout;\r\ncnt2 = tmp[0] | (tmp[1] << 8);\r\ncnt2 = 16384 - (cnt2 & 0x7fff);\r\ntmp[0] = EPP_TX_FIFO_ENABLE|EPP_RX_FIFO_ENABLE|EPP_MODEM_ENABLE;\r\nif (pp->ops->epp_write_addr(pp, tmp, 1, 0) != 1)\r\ngoto epptimeout;\r\nif (transmit(bc, cnt2, stat))\r\ngoto epptimeout;\r\nGETTICK(time2);\r\nif (receive(dev, cnt))\r\ngoto epptimeout;\r\nif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\r\ngoto epptimeout;\r\nbc->stat = stat;\r\n} else {\r\nswitch (stat & (EPP_NTAEF|EPP_NTHF)) {\r\ncase EPP_NTHF:\r\ncnt = 2048 - 256;\r\nbreak;\r\ncase EPP_NTAEF:\r\ncnt = 2048 - 1793;\r\nbreak;\r\ncase 0:\r\ncnt = 0;\r\nbreak;\r\ndefault:\r\ncnt = 2048 - 1025;\r\nbreak;\r\n}\r\nif (transmit(bc, cnt, stat))\r\ngoto epptimeout;\r\nGETTICK(time2);\r\nwhile ((stat & (EPP_NRAEF|EPP_NRHF)) != EPP_NRHF) {\r\nswitch (stat & (EPP_NRAEF|EPP_NRHF)) {\r\ncase EPP_NRAEF:\r\ncnt = 1025;\r\nbreak;\r\ncase 0:\r\ncnt = 1793;\r\nbreak;\r\ndefault:\r\ncnt = 256;\r\nbreak;\r\n}\r\nif (receive(dev, cnt))\r\ngoto epptimeout;\r\nif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\r\ngoto epptimeout;\r\n}\r\ncnt = 0;\r\nif (bc->bitrate < 50000)\r\ncnt = 256;\r\nelse if (bc->bitrate < 100000)\r\ncnt = 128;\r\nwhile (cnt > 0 && stat & EPP_NREF) {\r\nif (receive(dev, 1))\r\ngoto epptimeout;\r\ncnt--;\r\nif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\r\ngoto epptimeout;\r\n}\r\n}\r\nGETTICK(time3);\r\n#ifdef BAYCOM_DEBUG\r\nbc->debug_vals.mod_cycles = time2 - time1;\r\nbc->debug_vals.demod_cycles = time3 - time2;\r\n#endif\r\nschedule_delayed_work(&bc->run_work, 1);\r\nif (!bc->skb)\r\nnetif_wake_queue(dev);\r\nreturn;\r\nepptimeout:\r\nprintk(KERN_ERR "%s: EPP timeout!\n", bc_drvname);\r\n}\r\nstatic int baycom_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nif (skb->protocol == htons(ETH_P_IP))\r\nreturn ax25_ip_xmit(skb);\r\nif (skb->data[0] != 0) {\r\ndo_kiss_params(bc, skb->data, skb->len);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (bc->skb) {\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb->len >= HDLCDRV_MAXFLEN+1 || skb->len < 3) {\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(dev);\r\nbc->skb = skb;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int baycom_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = (struct sockaddr *)addr;\r\nmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic void epp_wakeup(void *handle)\r\n{\r\nstruct net_device *dev = (struct net_device *)handle;\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nprintk(KERN_DEBUG "baycom_epp: %s: why am I being woken up?\n", dev->name);\r\nif (!parport_claim(bc->pdev))\r\nprintk(KERN_DEBUG "baycom_epp: %s: I'm broken.\n", dev->name);\r\n}\r\nstatic int epp_open(struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nstruct parport *pp = parport_find_base(dev->base_addr);\r\nunsigned int i, j;\r\nunsigned char tmp[128];\r\nunsigned char stat;\r\nunsigned long tstart;\r\nif (!pp) {\r\nprintk(KERN_ERR "%s: parport at 0x%lx unknown\n", bc_drvname, dev->base_addr);\r\nreturn -ENXIO;\r\n}\r\n#if 0\r\nif (pp->irq < 0) {\r\nprintk(KERN_ERR "%s: parport at 0x%lx has no irq\n", bc_drvname, pp->base);\r\nparport_put_port(pp);\r\nreturn -ENXIO;\r\n}\r\n#endif\r\nif ((~pp->modes) & (PARPORT_MODE_TRISTATE | PARPORT_MODE_PCSPP | PARPORT_MODE_SAFEININT)) {\r\nprintk(KERN_ERR "%s: parport at 0x%lx cannot be used\n",\r\nbc_drvname, pp->base);\r\nparport_put_port(pp);\r\nreturn -EIO;\r\n}\r\nmemset(&bc->modem, 0, sizeof(bc->modem));\r\nbc->pdev = parport_register_device(pp, dev->name, NULL, epp_wakeup,\r\nNULL, PARPORT_DEV_EXCL, dev);\r\nparport_put_port(pp);\r\nif (!bc->pdev) {\r\nprintk(KERN_ERR "%s: cannot register parport at 0x%lx\n", bc_drvname, pp->base);\r\nreturn -ENXIO;\r\n}\r\nif (parport_claim(bc->pdev)) {\r\nprintk(KERN_ERR "%s: parport at 0x%lx busy\n", bc_drvname, pp->base);\r\nparport_unregister_device(bc->pdev);\r\nreturn -EBUSY;\r\n}\r\ndev->irq = 0;\r\nINIT_DELAYED_WORK(&bc->run_work, epp_bh);\r\nbc->work_running = 1;\r\nbc->modem = EPP_CONVENTIONAL;\r\nif (eppconfig(bc))\r\nprintk(KERN_INFO "%s: no FPGA detected, assuming conventional EPP modem\n", bc_drvname);\r\nelse\r\nbc->modem = EPP_FPGAEXTSTATUS;\r\nparport_write_control(pp, LPTCTRL_PROGRAM);\r\ntmp[0] = 0;\r\ntmp[1] = EPP_TX_FIFO_ENABLE|EPP_RX_FIFO_ENABLE|EPP_MODEM_ENABLE;\r\nif (pp->ops->epp_write_addr(pp, tmp, 2, 0) != 2)\r\ngoto epptimeout;\r\ntstart = jiffies;\r\ni = 0;\r\nwhile (time_before(jiffies, tstart + HZ/3)) {\r\nif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\r\ngoto epptimeout;\r\nif ((stat & (EPP_NRAEF|EPP_NRHF)) == EPP_NRHF) {\r\nschedule();\r\ncontinue;\r\n}\r\nif (pp->ops->epp_read_data(pp, tmp, 128, 0) != 128)\r\ngoto epptimeout;\r\nif (pp->ops->epp_read_data(pp, tmp, 128, 0) != 128)\r\ngoto epptimeout;\r\ni += 256;\r\n}\r\nfor (j = 0; j < 256; j++) {\r\nif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\r\ngoto epptimeout;\r\nif (!(stat & EPP_NREF))\r\nbreak;\r\nif (pp->ops->epp_read_data(pp, tmp, 1, 0) != 1)\r\ngoto epptimeout;\r\ni++;\r\n}\r\ntstart = jiffies - tstart;\r\nbc->bitrate = i * (8 * HZ) / tstart;\r\nj = 1;\r\ni = bc->bitrate >> 3;\r\nwhile (j < 7 && i > 150) {\r\nj++;\r\ni >>= 1;\r\n}\r\nprintk(KERN_INFO "%s: autoprobed bitrate: %d int divider: %d int rate: %d\n",\r\nbc_drvname, bc->bitrate, j, bc->bitrate >> (j+2));\r\ntmp[0] = EPP_TX_FIFO_ENABLE|EPP_RX_FIFO_ENABLE|EPP_MODEM_ENABLE;\r\nif (pp->ops->epp_write_addr(pp, tmp, 1, 0) != 1)\r\ngoto epptimeout;\r\nbc->hdlcrx.state = 0;\r\nbc->hdlcrx.numbits = 0;\r\nbc->hdlctx.state = tx_idle;\r\nbc->hdlctx.bufcnt = 0;\r\nbc->hdlctx.slotcnt = bc->ch_params.slottime;\r\nbc->hdlctx.calibrate = 0;\r\nschedule_delayed_work(&bc->run_work, 1);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nepptimeout:\r\nprintk(KERN_ERR "%s: epp timeout during bitrate probe\n", bc_drvname);\r\nparport_write_control(pp, 0);\r\nparport_release(bc->pdev);\r\nparport_unregister_device(bc->pdev);\r\nreturn -EIO;\r\n}\r\nstatic int epp_close(struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nstruct parport *pp = bc->pdev->port;\r\nunsigned char tmp[1];\r\nbc->work_running = 0;\r\ncancel_delayed_work_sync(&bc->run_work);\r\nbc->stat = EPP_DCDBIT;\r\ntmp[0] = 0;\r\npp->ops->epp_write_addr(pp, tmp, 1, 0);\r\nparport_write_control(pp, 0);\r\nparport_release(bc->pdev);\r\nparport_unregister_device(bc->pdev);\r\nif (bc->skb)\r\ndev_kfree_skb(bc->skb);\r\nbc->skb = NULL;\r\nprintk(KERN_INFO "%s: close epp at iobase 0x%lx irq %u\n",\r\nbc_drvname, dev->base_addr, dev->irq);\r\nreturn 0;\r\n}\r\nstatic int baycom_setmode(struct baycom_state *bc, const char *modestr)\r\n{\r\nconst char *cp;\r\nif (strstr(modestr,"intclk"))\r\nbc->cfg.intclk = 1;\r\nif (strstr(modestr,"extclk"))\r\nbc->cfg.intclk = 0;\r\nif (strstr(modestr,"intmodem"))\r\nbc->cfg.extmodem = 0;\r\nif (strstr(modestr,"extmodem"))\r\nbc->cfg.extmodem = 1;\r\nif (strstr(modestr,"noloopback"))\r\nbc->cfg.loopback = 0;\r\nif (strstr(modestr,"loopback"))\r\nbc->cfg.loopback = 1;\r\nif ((cp = strstr(modestr,"fclk="))) {\r\nbc->cfg.fclk = simple_strtoul(cp+5, NULL, 0);\r\nif (bc->cfg.fclk < 1000000)\r\nbc->cfg.fclk = 1000000;\r\nif (bc->cfg.fclk > 25000000)\r\nbc->cfg.fclk = 25000000;\r\n}\r\nif ((cp = strstr(modestr,"bps="))) {\r\nbc->cfg.bps = simple_strtoul(cp+4, NULL, 0);\r\nif (bc->cfg.bps < 1000)\r\nbc->cfg.bps = 1000;\r\nif (bc->cfg.bps > 1500000)\r\nbc->cfg.bps = 1500000;\r\n}\r\nreturn 0;\r\n}\r\nstatic int baycom_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nstruct hdlcdrv_ioctl hi;\r\nif (cmd != SIOCDEVPRIVATE)\r\nreturn -ENOIOCTLCMD;\r\nif (copy_from_user(&hi, ifr->ifr_data, sizeof(hi)))\r\nreturn -EFAULT;\r\nswitch (hi.cmd) {\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\ncase HDLCDRVCTL_GETCHANNELPAR:\r\nhi.data.cp.tx_delay = bc->ch_params.tx_delay;\r\nhi.data.cp.tx_tail = bc->ch_params.tx_tail;\r\nhi.data.cp.slottime = bc->ch_params.slottime;\r\nhi.data.cp.ppersist = bc->ch_params.ppersist;\r\nhi.data.cp.fulldup = bc->ch_params.fulldup;\r\nbreak;\r\ncase HDLCDRVCTL_SETCHANNELPAR:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\nbc->ch_params.tx_delay = hi.data.cp.tx_delay;\r\nbc->ch_params.tx_tail = hi.data.cp.tx_tail;\r\nbc->ch_params.slottime = hi.data.cp.slottime;\r\nbc->ch_params.ppersist = hi.data.cp.ppersist;\r\nbc->ch_params.fulldup = hi.data.cp.fulldup;\r\nbc->hdlctx.slotcnt = 1;\r\nreturn 0;\r\ncase HDLCDRVCTL_GETMODEMPAR:\r\nhi.data.mp.iobase = dev->base_addr;\r\nhi.data.mp.irq = dev->irq;\r\nhi.data.mp.dma = dev->dma;\r\nhi.data.mp.dma2 = 0;\r\nhi.data.mp.seriobase = 0;\r\nhi.data.mp.pariobase = 0;\r\nhi.data.mp.midiiobase = 0;\r\nbreak;\r\ncase HDLCDRVCTL_SETMODEMPAR:\r\nif ((!capable(CAP_SYS_RAWIO)) || netif_running(dev))\r\nreturn -EACCES;\r\ndev->base_addr = hi.data.mp.iobase;\r\ndev->irq = 0;\r\ndev->dma = 0;\r\nreturn 0;\r\ncase HDLCDRVCTL_GETSTAT:\r\nhi.data.cs.ptt = !!(bc->stat & EPP_PTTBIT);\r\nhi.data.cs.dcd = !(bc->stat & EPP_DCDBIT);\r\nhi.data.cs.ptt_keyed = bc->ptt_keyed;\r\nhi.data.cs.tx_packets = dev->stats.tx_packets;\r\nhi.data.cs.tx_errors = dev->stats.tx_errors;\r\nhi.data.cs.rx_packets = dev->stats.rx_packets;\r\nhi.data.cs.rx_errors = dev->stats.rx_errors;\r\nbreak;\r\ncase HDLCDRVCTL_OLDGETSTAT:\r\nhi.data.ocs.ptt = !!(bc->stat & EPP_PTTBIT);\r\nhi.data.ocs.dcd = !(bc->stat & EPP_DCDBIT);\r\nhi.data.ocs.ptt_keyed = bc->ptt_keyed;\r\nbreak;\r\ncase HDLCDRVCTL_CALIBRATE:\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nbc->hdlctx.calibrate = hi.data.calibrate * bc->bitrate / 8;\r\nreturn 0;\r\ncase HDLCDRVCTL_DRIVERNAME:\r\nstrncpy(hi.data.drivername, "baycom_epp", sizeof(hi.data.drivername));\r\nbreak;\r\ncase HDLCDRVCTL_GETMODE:\r\nsprintf(hi.data.modename, "%sclk,%smodem,fclk=%d,bps=%d%s",\r\nbc->cfg.intclk ? "int" : "ext",\r\nbc->cfg.extmodem ? "ext" : "int", bc->cfg.fclk, bc->cfg.bps,\r\nbc->cfg.loopback ? ",loopback" : "");\r\nbreak;\r\ncase HDLCDRVCTL_SETMODE:\r\nif (!capable(CAP_NET_ADMIN) || netif_running(dev))\r\nreturn -EACCES;\r\nhi.data.modename[sizeof(hi.data.modename)-1] = '\0';\r\nreturn baycom_setmode(bc, hi.data.modename);\r\ncase HDLCDRVCTL_MODELIST:\r\nstrncpy(hi.data.modename, "intclk,extclk,intmodem,extmodem,divider=x",\r\nsizeof(hi.data.modename));\r\nbreak;\r\ncase HDLCDRVCTL_MODEMPARMASK:\r\nreturn HDLCDRV_PARMASK_IOBASE;\r\n}\r\nif (copy_to_user(ifr->ifr_data, &hi, sizeof(hi)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void baycom_probe(struct net_device *dev)\r\n{\r\nconst struct hdlcdrv_channel_params dflt_ch_params = {\r\n20, 2, 10, 40, 0\r\n};\r\nstruct baycom_state *bc;\r\nbc = netdev_priv(dev);\r\nbc->ch_params = dflt_ch_params;\r\nbc->ptt_keyed = 0;\r\nbc->skb = NULL;\r\ndev->netdev_ops = &baycom_netdev_ops;\r\ndev->header_ops = &ax25_header_ops;\r\ndev->type = ARPHRD_AX25;\r\ndev->hard_header_len = AX25_MAX_HEADER_LEN + AX25_BPQ_HEADER_LEN;\r\ndev->mtu = AX25_DEF_PACLEN;\r\ndev->addr_len = AX25_ADDR_LEN;\r\nmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\r\nmemcpy(dev->dev_addr, &null_ax25_address, AX25_ADDR_LEN);\r\ndev->tx_queue_len = 16;\r\ndev->flags = 0;\r\n}\r\nstatic void __init baycom_epp_dev_setup(struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nbc->dev = dev;\r\nbc->magic = BAYCOM_MAGIC;\r\nbc->cfg.fclk = 19666600;\r\nbc->cfg.bps = 9600;\r\nbaycom_probe(dev);\r\n}\r\nstatic int __init init_baycomepp(void)\r\n{\r\nint i, found = 0;\r\nchar set_hw = 1;\r\nprintk(bc_drvinfo);\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *dev;\r\ndev = alloc_netdev(sizeof(struct baycom_state), "bce%d",\r\nNET_NAME_UNKNOWN, baycom_epp_dev_setup);\r\nif (!dev) {\r\nprintk(KERN_WARNING "bce%d : out of memory\n", i);\r\nreturn found ? 0 : -ENOMEM;\r\n}\r\nsprintf(dev->name, "bce%d", i);\r\ndev->base_addr = iobase[i];\r\nif (!mode[i])\r\nset_hw = 0;\r\nif (!set_hw)\r\niobase[i] = 0;\r\nif (register_netdev(dev)) {\r\nprintk(KERN_WARNING "%s: cannot register net device %s\n", bc_drvname, dev->name);\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\nif (set_hw && baycom_setmode(netdev_priv(dev), mode[i]))\r\nset_hw = 0;\r\nbaycom_device[i] = dev;\r\nfound++;\r\n}\r\nreturn found ? 0 : -ENXIO;\r\n}\r\nstatic void __exit cleanup_baycomepp(void)\r\n{\r\nint i;\r\nfor(i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *dev = baycom_device[i];\r\nif (dev) {\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nif (bc->magic == BAYCOM_MAGIC) {\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n} else\r\nprintk(paranoia_str, "cleanup_module");\r\n}\r\n}\r\n}\r\nstatic int __init baycom_epp_setup(char *str)\r\n{\r\nstatic unsigned __initdata nr_dev = 0;\r\nint ints[2];\r\nif (nr_dev >= NR_PORTS)\r\nreturn 0;\r\nstr = get_options(str, 2, ints);\r\nif (ints[0] < 1)\r\nreturn 0;\r\nmode[nr_dev] = str;\r\niobase[nr_dev] = ints[1];\r\nnr_dev++;\r\nreturn 1;\r\n}
