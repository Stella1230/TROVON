static void __init mini2440_map_io(void)\r\n{\r\ns3c24xx_init_io(mini2440_iodesc, ARRAY_SIZE(mini2440_iodesc));\r\ns3c24xx_init_uarts(mini2440_uartcfgs, ARRAY_SIZE(mini2440_uartcfgs));\r\nsamsung_set_timer_source(SAMSUNG_PWM3, SAMSUNG_PWM4);\r\n}\r\nstatic void __init mini2440_init_time(void)\r\n{\r\ns3c2440_init_clocks(12000000);\r\nsamsung_timer_init();\r\n}\r\nstatic int __init mini2440_features_setup(char *str)\r\n{\r\nif (str)\r\nstrlcpy(mini2440_features_str, str, sizeof(mini2440_features_str));\r\nreturn 1;\r\n}\r\nstatic void __init mini2440_parse_features(\r\nstruct mini2440_features_t * features,\r\nconst char * features_str )\r\n{\r\nconst char * fp = features_str;\r\nfeatures->count = 0;\r\nfeatures->done = 0;\r\nfeatures->lcd_index = -1;\r\nwhile (*fp) {\r\nchar f = *fp++;\r\nswitch (f) {\r\ncase '0'...'9':\r\nif (features->done & FEATURE_SCREEN) {\r\nprintk(KERN_INFO "MINI2440: '%c' ignored, "\r\n"screen type already set\n", f);\r\n} else {\r\nint li = f - '0';\r\nif (li >= ARRAY_SIZE(mini2440_lcd_cfg))\r\nprintk(KERN_INFO "MINI2440: "\r\n"'%c' out of range LCD mode\n", f);\r\nelse {\r\nfeatures->optional[features->count++] =\r\n&s3c_device_lcd;\r\nfeatures->lcd_index = li;\r\n}\r\n}\r\nfeatures->done |= FEATURE_SCREEN;\r\nbreak;\r\ncase 'b':\r\nif (features->done & FEATURE_BACKLIGHT)\r\nprintk(KERN_INFO "MINI2440: '%c' ignored, "\r\n"backlight already set\n", f);\r\nelse {\r\nfeatures->optional[features->count++] =\r\n&mini2440_led_backlight;\r\n}\r\nfeatures->done |= FEATURE_BACKLIGHT;\r\nbreak;\r\ncase 't':\r\nprintk(KERN_INFO "MINI2440: '%c' ignored, "\r\n"touchscreen not compiled in\n", f);\r\nbreak;\r\ncase 'c':\r\nif (features->done & FEATURE_CAMERA)\r\nprintk(KERN_INFO "MINI2440: '%c' ignored, "\r\n"camera already registered\n", f);\r\nelse\r\nfeatures->optional[features->count++] =\r\n&s3c_device_camif;\r\nfeatures->done |= FEATURE_CAMERA;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void __init mini2440_init(void)\r\n{\r\nstruct mini2440_features_t features = { 0 };\r\nint i;\r\nprintk(KERN_INFO "MINI2440: Option string mini2440=%s\n",\r\nmini2440_features_str);\r\nmini2440_parse_features(&features, mini2440_features_str);\r\ns3c_gpio_cfgpin(S3C2410_GPC(0), S3C2410_GPC0_LEND);\r\nWARN_ON(gpio_request_one(S3C2410_GPG(4), GPIOF_OUT_INIT_HIGH, NULL));\r\ngpio_free(S3C2410_GPG(4));\r\ngpio_request_one(S3C2410_GPB(1), GPIOF_IN, NULL);\r\ns3c_gpio_setpull(S3C2410_GPB(1), S3C_GPIO_PULL_UP);\r\ngpio_free(S3C2410_GPB(1));\r\nfor (i = 0; i < ARRAY_SIZE(mini2440_buttons); i++) {\r\ns3c_gpio_setpull(mini2440_buttons[i].gpio, S3C_GPIO_PULL_UP);\r\ns3c_gpio_cfgpin(mini2440_buttons[i].gpio, S3C2410_GPIO_INPUT);\r\n}\r\nif (features.lcd_index != -1) {\r\nint li;\r\nmini2440_fb_info.displays =\r\n&mini2440_lcd_cfg[features.lcd_index];\r\nprintk(KERN_INFO "MINI2440: LCD");\r\nfor (li = 0; li < ARRAY_SIZE(mini2440_lcd_cfg); li++)\r\nif (li == features.lcd_index)\r\nprintk(" [%d:%dx%d]", li,\r\nmini2440_lcd_cfg[li].width,\r\nmini2440_lcd_cfg[li].height);\r\nelse\r\nprintk(" %d:%dx%d", li,\r\nmini2440_lcd_cfg[li].width,\r\nmini2440_lcd_cfg[li].height);\r\nprintk("\n");\r\ns3c24xx_fb_set_platdata(&mini2440_fb_info);\r\n}\r\ns3c24xx_udc_set_platdata(&mini2440_udc_cfg);\r\ns3c24xx_mci_set_platdata(&mini2440_mmc_cfg);\r\ns3c_nand_set_platdata(&mini2440_nand_info);\r\ns3c_i2c0_set_platdata(NULL);\r\ni2c_register_board_info(0, mini2440_i2c_devs,\r\nARRAY_SIZE(mini2440_i2c_devs));\r\nplatform_add_devices(mini2440_devices, ARRAY_SIZE(mini2440_devices));\r\nif (features.count)\r\nplatform_add_devices(features.optional, features.count);\r\n}
