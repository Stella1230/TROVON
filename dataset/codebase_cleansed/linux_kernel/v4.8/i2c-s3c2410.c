static inline kernel_ulong_t s3c24xx_get_device_quirks(struct platform_device *pdev)\r\n{\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(s3c24xx_i2c_match, pdev->dev.of_node);\r\nreturn (kernel_ulong_t)match->data;\r\n}\r\nreturn platform_get_device_id(pdev)->driver_data;\r\n}\r\nstatic inline void s3c24xx_i2c_master_complete(struct s3c24xx_i2c *i2c, int ret)\r\n{\r\ndev_dbg(i2c->dev, "master_complete %d\n", ret);\r\ni2c->msg_ptr = 0;\r\ni2c->msg = NULL;\r\ni2c->msg_idx++;\r\ni2c->msg_num = 0;\r\nif (ret)\r\ni2c->msg_idx = ret;\r\nif (!(i2c->quirks & QUIRK_POLL))\r\nwake_up(&i2c->wait);\r\n}\r\nstatic inline void s3c24xx_i2c_disable_ack(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\nwritel(tmp & ~S3C2410_IICCON_ACKEN, i2c->regs + S3C2410_IICCON);\r\n}\r\nstatic inline void s3c24xx_i2c_enable_ack(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\nwritel(tmp | S3C2410_IICCON_ACKEN, i2c->regs + S3C2410_IICCON);\r\n}\r\nstatic inline void s3c24xx_i2c_disable_irq(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\nwritel(tmp & ~S3C2410_IICCON_IRQEN, i2c->regs + S3C2410_IICCON);\r\n}\r\nstatic inline void s3c24xx_i2c_enable_irq(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\nwritel(tmp | S3C2410_IICCON_IRQEN, i2c->regs + S3C2410_IICCON);\r\n}\r\nstatic bool is_ack(struct s3c24xx_i2c *i2c)\r\n{\r\nint tries;\r\nfor (tries = 50; tries; --tries) {\r\nif (readl(i2c->regs + S3C2410_IICCON)\r\n& S3C2410_IICCON_IRQPEND) {\r\nif (!(readl(i2c->regs + S3C2410_IICSTAT)\r\n& S3C2410_IICSTAT_LASTBIT))\r\nreturn true;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\ndev_err(i2c->dev, "ack was not received\n");\r\nreturn false;\r\n}\r\nstatic void s3c24xx_i2c_message_start(struct s3c24xx_i2c *i2c,\r\nstruct i2c_msg *msg)\r\n{\r\nunsigned int addr = (msg->addr & 0x7f) << 1;\r\nunsigned long stat;\r\nunsigned long iiccon;\r\nstat = 0;\r\nstat |= S3C2410_IICSTAT_TXRXEN;\r\nif (msg->flags & I2C_M_RD) {\r\nstat |= S3C2410_IICSTAT_MASTER_RX;\r\naddr |= 1;\r\n} else\r\nstat |= S3C2410_IICSTAT_MASTER_TX;\r\nif (msg->flags & I2C_M_REV_DIR_ADDR)\r\naddr ^= 1;\r\ns3c24xx_i2c_enable_ack(i2c);\r\niiccon = readl(i2c->regs + S3C2410_IICCON);\r\nwritel(stat, i2c->regs + S3C2410_IICSTAT);\r\ndev_dbg(i2c->dev, "START: %08lx to IICSTAT, %02x to DS\n", stat, addr);\r\nwriteb(addr, i2c->regs + S3C2410_IICDS);\r\nndelay(i2c->tx_setup);\r\ndev_dbg(i2c->dev, "iiccon, %08lx\n", iiccon);\r\nwritel(iiccon, i2c->regs + S3C2410_IICCON);\r\nstat |= S3C2410_IICSTAT_START;\r\nwritel(stat, i2c->regs + S3C2410_IICSTAT);\r\nif (i2c->quirks & QUIRK_POLL) {\r\nwhile ((i2c->msg_num != 0) && is_ack(i2c)) {\r\ni2c_s3c_irq_nextbyte(i2c, stat);\r\nstat = readl(i2c->regs + S3C2410_IICSTAT);\r\nif (stat & S3C2410_IICSTAT_ARBITR)\r\ndev_err(i2c->dev, "deal with arbitration loss\n");\r\n}\r\n}\r\n}\r\nstatic inline void s3c24xx_i2c_stop(struct s3c24xx_i2c *i2c, int ret)\r\n{\r\nunsigned long iicstat = readl(i2c->regs + S3C2410_IICSTAT);\r\ndev_dbg(i2c->dev, "STOP\n");\r\nif (i2c->quirks & QUIRK_HDMIPHY) {\r\niicstat &= ~S3C2410_IICSTAT_TXRXEN;\r\n} else {\r\niicstat &= ~S3C2410_IICSTAT_START;\r\n}\r\nwritel(iicstat, i2c->regs + S3C2410_IICSTAT);\r\ni2c->state = STATE_STOP;\r\ns3c24xx_i2c_master_complete(i2c, ret);\r\ns3c24xx_i2c_disable_irq(i2c);\r\n}\r\nstatic inline int is_lastmsg(struct s3c24xx_i2c *i2c)\r\n{\r\nreturn i2c->msg_idx >= (i2c->msg_num - 1);\r\n}\r\nstatic inline int is_msglast(struct s3c24xx_i2c *i2c)\r\n{\r\nif (i2c->msg->flags & I2C_M_RECV_LEN && i2c->msg->len == 1)\r\nreturn 0;\r\nreturn i2c->msg_ptr == i2c->msg->len-1;\r\n}\r\nstatic inline int is_msgend(struct s3c24xx_i2c *i2c)\r\n{\r\nreturn i2c->msg_ptr >= i2c->msg->len;\r\n}\r\nstatic int i2c_s3c_irq_nextbyte(struct s3c24xx_i2c *i2c, unsigned long iicstat)\r\n{\r\nunsigned long tmp;\r\nunsigned char byte;\r\nint ret = 0;\r\nswitch (i2c->state) {\r\ncase STATE_IDLE:\r\ndev_err(i2c->dev, "%s: called in STATE_IDLE\n", __func__);\r\ngoto out;\r\ncase STATE_STOP:\r\ndev_err(i2c->dev, "%s: called in STATE_STOP\n", __func__);\r\ns3c24xx_i2c_disable_irq(i2c);\r\ngoto out_ack;\r\ncase STATE_START:\r\nif (iicstat & S3C2410_IICSTAT_LASTBIT &&\r\n!(i2c->msg->flags & I2C_M_IGNORE_NAK)) {\r\ndev_dbg(i2c->dev, "ack was not received\n");\r\ns3c24xx_i2c_stop(i2c, -ENXIO);\r\ngoto out_ack;\r\n}\r\nif (i2c->msg->flags & I2C_M_RD)\r\ni2c->state = STATE_READ;\r\nelse\r\ni2c->state = STATE_WRITE;\r\nif (is_lastmsg(i2c) && i2c->msg->len == 0) {\r\ns3c24xx_i2c_stop(i2c, 0);\r\ngoto out_ack;\r\n}\r\nif (i2c->state == STATE_READ)\r\ngoto prepare_read;\r\ncase STATE_WRITE:\r\nif (!(i2c->msg->flags & I2C_M_IGNORE_NAK)) {\r\nif (iicstat & S3C2410_IICSTAT_LASTBIT) {\r\ndev_dbg(i2c->dev, "WRITE: No Ack\n");\r\ns3c24xx_i2c_stop(i2c, -ECONNREFUSED);\r\ngoto out_ack;\r\n}\r\n}\r\nretry_write:\r\nif (!is_msgend(i2c)) {\r\nbyte = i2c->msg->buf[i2c->msg_ptr++];\r\nwriteb(byte, i2c->regs + S3C2410_IICDS);\r\nndelay(i2c->tx_setup);\r\n} else if (!is_lastmsg(i2c)) {\r\ndev_dbg(i2c->dev, "WRITE: Next Message\n");\r\ni2c->msg_ptr = 0;\r\ni2c->msg_idx++;\r\ni2c->msg++;\r\nif (i2c->msg->flags & I2C_M_NOSTART) {\r\nif (i2c->msg->flags & I2C_M_RD) {\r\ns3c24xx_i2c_stop(i2c, -EINVAL);\r\n}\r\ngoto retry_write;\r\n} else {\r\ns3c24xx_i2c_message_start(i2c, i2c->msg);\r\ni2c->state = STATE_START;\r\n}\r\n} else {\r\ns3c24xx_i2c_stop(i2c, 0);\r\n}\r\nbreak;\r\ncase STATE_READ:\r\nbyte = readb(i2c->regs + S3C2410_IICDS);\r\ni2c->msg->buf[i2c->msg_ptr++] = byte;\r\nif (i2c->msg->flags & I2C_M_RECV_LEN && i2c->msg->len == 1)\r\ni2c->msg->len += byte;\r\nprepare_read:\r\nif (is_msglast(i2c)) {\r\nif (is_lastmsg(i2c))\r\ns3c24xx_i2c_disable_ack(i2c);\r\n} else if (is_msgend(i2c)) {\r\nif (is_lastmsg(i2c)) {\r\ndev_dbg(i2c->dev, "READ: Send Stop\n");\r\ns3c24xx_i2c_stop(i2c, 0);\r\n} else {\r\ndev_dbg(i2c->dev, "READ: Next Transfer\n");\r\ni2c->msg_ptr = 0;\r\ni2c->msg_idx++;\r\ni2c->msg++;\r\n}\r\n}\r\nbreak;\r\n}\r\nout_ack:\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\ntmp &= ~S3C2410_IICCON_IRQPEND;\r\nwritel(tmp, i2c->regs + S3C2410_IICCON);\r\nout:\r\nreturn ret;\r\n}\r\nstatic irqreturn_t s3c24xx_i2c_irq(int irqno, void *dev_id)\r\n{\r\nstruct s3c24xx_i2c *i2c = dev_id;\r\nunsigned long status;\r\nunsigned long tmp;\r\nstatus = readl(i2c->regs + S3C2410_IICSTAT);\r\nif (status & S3C2410_IICSTAT_ARBITR) {\r\ndev_err(i2c->dev, "deal with arbitration loss\n");\r\n}\r\nif (i2c->state == STATE_IDLE) {\r\ndev_dbg(i2c->dev, "IRQ: error i2c->state == IDLE\n");\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\ntmp &= ~S3C2410_IICCON_IRQPEND;\r\nwritel(tmp, i2c->regs + S3C2410_IICCON);\r\ngoto out;\r\n}\r\ni2c_s3c_irq_nextbyte(i2c, status);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void s3c24xx_i2c_disable_bus(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + S3C2410_IICSTAT);\r\ntmp &= ~S3C2410_IICSTAT_TXRXEN;\r\nwritel(tmp, i2c->regs + S3C2410_IICSTAT);\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\ntmp &= ~(S3C2410_IICCON_IRQEN | S3C2410_IICCON_IRQPEND |\r\nS3C2410_IICCON_ACKEN);\r\nwritel(tmp, i2c->regs + S3C2410_IICCON);\r\n}\r\nstatic int s3c24xx_i2c_set_master(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long iicstat;\r\nint timeout = 400;\r\nwhile (timeout-- > 0) {\r\niicstat = readl(i2c->regs + S3C2410_IICSTAT);\r\nif (!(iicstat & S3C2410_IICSTAT_BUSBUSY))\r\nreturn 0;\r\nmsleep(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void s3c24xx_i2c_wait_idle(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long iicstat;\r\nktime_t start, now;\r\nunsigned long delay;\r\nint spins;\r\ndev_dbg(i2c->dev, "waiting for bus idle\n");\r\nstart = now = ktime_get();\r\nspins = 3;\r\niicstat = readl(i2c->regs + S3C2410_IICSTAT);\r\nwhile ((iicstat & S3C2410_IICSTAT_START) && --spins) {\r\ncpu_relax();\r\niicstat = readl(i2c->regs + S3C2410_IICSTAT);\r\n}\r\ndelay = 1;\r\nwhile ((iicstat & S3C2410_IICSTAT_START) &&\r\nktime_us_delta(now, start) < S3C2410_IDLE_TIMEOUT) {\r\nusleep_range(delay, 2 * delay);\r\nif (delay < S3C2410_IDLE_TIMEOUT / 10)\r\ndelay <<= 1;\r\nnow = ktime_get();\r\niicstat = readl(i2c->regs + S3C2410_IICSTAT);\r\n}\r\nif (iicstat & S3C2410_IICSTAT_START)\r\ndev_warn(i2c->dev, "timeout waiting for bus idle\n");\r\n}\r\nstatic int s3c24xx_i2c_doxfer(struct s3c24xx_i2c *i2c,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nunsigned long timeout;\r\nint ret;\r\nif (i2c->suspended)\r\nreturn -EIO;\r\nret = s3c24xx_i2c_set_master(i2c);\r\nif (ret != 0) {\r\ndev_err(i2c->dev, "cannot get bus (error %d)\n", ret);\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\ni2c->msg = msgs;\r\ni2c->msg_num = num;\r\ni2c->msg_ptr = 0;\r\ni2c->msg_idx = 0;\r\ni2c->state = STATE_START;\r\ns3c24xx_i2c_enable_irq(i2c);\r\ns3c24xx_i2c_message_start(i2c, msgs);\r\nif (i2c->quirks & QUIRK_POLL) {\r\nret = i2c->msg_idx;\r\nif (ret != num)\r\ndev_dbg(i2c->dev, "incomplete xfer (%d)\n", ret);\r\ngoto out;\r\n}\r\ntimeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 5);\r\nret = i2c->msg_idx;\r\nif (timeout == 0)\r\ndev_dbg(i2c->dev, "timeout\n");\r\nelse if (ret != num)\r\ndev_dbg(i2c->dev, "incomplete xfer (%d)\n", ret);\r\nif (i2c->quirks & QUIRK_HDMIPHY)\r\ngoto out;\r\ns3c24xx_i2c_wait_idle(i2c);\r\ns3c24xx_i2c_disable_bus(i2c);\r\nout:\r\ni2c->state = STATE_IDLE;\r\nreturn ret;\r\n}\r\nstatic int s3c24xx_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct s3c24xx_i2c *i2c = (struct s3c24xx_i2c *)adap->algo_data;\r\nint retry;\r\nint ret;\r\nret = clk_enable(i2c->clk);\r\nif (ret)\r\nreturn ret;\r\nfor (retry = 0; retry < adap->retries; retry++) {\r\nret = s3c24xx_i2c_doxfer(i2c, msgs, num);\r\nif (ret != -EAGAIN) {\r\nclk_disable(i2c->clk);\r\nreturn ret;\r\n}\r\ndev_dbg(i2c->dev, "Retrying transmission (%d)\n", retry);\r\nudelay(100);\r\n}\r\nclk_disable(i2c->clk);\r\nreturn -EREMOTEIO;\r\n}\r\nstatic u32 s3c24xx_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_NOSTART |\r\nI2C_FUNC_PROTOCOL_MANGLING;\r\n}\r\nstatic int s3c24xx_i2c_calcdivisor(unsigned long clkin, unsigned int wanted,\r\nunsigned int *div1, unsigned int *divs)\r\n{\r\nunsigned int calc_divs = clkin / wanted;\r\nunsigned int calc_div1;\r\nif (calc_divs > (16*16))\r\ncalc_div1 = 512;\r\nelse\r\ncalc_div1 = 16;\r\ncalc_divs += calc_div1-1;\r\ncalc_divs /= calc_div1;\r\nif (calc_divs == 0)\r\ncalc_divs = 1;\r\nif (calc_divs > 17)\r\ncalc_divs = 17;\r\n*divs = calc_divs;\r\n*div1 = calc_div1;\r\nreturn clkin / (calc_divs * calc_div1);\r\n}\r\nstatic int s3c24xx_i2c_clockrate(struct s3c24xx_i2c *i2c, unsigned int *got)\r\n{\r\nstruct s3c2410_platform_i2c *pdata = i2c->pdata;\r\nunsigned long clkin = clk_get_rate(i2c->clk);\r\nunsigned int divs, div1;\r\nunsigned long target_frequency;\r\nu32 iiccon;\r\nint freq;\r\ni2c->clkrate = clkin;\r\nclkin /= 1000;\r\ndev_dbg(i2c->dev, "pdata desired frequency %lu\n", pdata->frequency);\r\ntarget_frequency = pdata->frequency ? pdata->frequency : 100000;\r\ntarget_frequency /= 1000;\r\nfreq = s3c24xx_i2c_calcdivisor(clkin, target_frequency, &div1, &divs);\r\nif (freq > target_frequency) {\r\ndev_err(i2c->dev,\r\n"Unable to achieve desired frequency %luKHz." \\r\n" Lowest achievable %dKHz\n", target_frequency, freq);\r\nreturn -EINVAL;\r\n}\r\n*got = freq;\r\niiccon = readl(i2c->regs + S3C2410_IICCON);\r\niiccon &= ~(S3C2410_IICCON_SCALEMASK | S3C2410_IICCON_TXDIV_512);\r\niiccon |= (divs-1);\r\nif (div1 == 512)\r\niiccon |= S3C2410_IICCON_TXDIV_512;\r\nif (i2c->quirks & QUIRK_POLL)\r\niiccon |= S3C2410_IICCON_SCALE(2);\r\nwritel(iiccon, i2c->regs + S3C2410_IICCON);\r\nif (i2c->quirks & QUIRK_S3C2440) {\r\nunsigned long sda_delay;\r\nif (pdata->sda_delay) {\r\nsda_delay = clkin * pdata->sda_delay;\r\nsda_delay = DIV_ROUND_UP(sda_delay, 1000000);\r\nsda_delay = DIV_ROUND_UP(sda_delay, 5);\r\nif (sda_delay > 3)\r\nsda_delay = 3;\r\nsda_delay |= S3C2410_IICLC_FILTER_ON;\r\n} else\r\nsda_delay = 0;\r\ndev_dbg(i2c->dev, "IICLC=%08lx\n", sda_delay);\r\nwritel(sda_delay, i2c->regs + S3C2440_IICLC);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_i2c_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct s3c24xx_i2c *i2c = freq_to_i2c(nb);\r\nunsigned int got;\r\nint delta_f;\r\nint ret;\r\ndelta_f = clk_get_rate(i2c->clk) - i2c->clkrate;\r\nif ((val == CPUFREQ_POSTCHANGE && delta_f < 0) ||\r\n(val == CPUFREQ_PRECHANGE && delta_f > 0)) {\r\ni2c_lock_adapter(&i2c->adap);\r\nret = s3c24xx_i2c_clockrate(i2c, &got);\r\ni2c_unlock_adapter(&i2c->adap);\r\nif (ret < 0)\r\ndev_err(i2c->dev, "cannot find frequency (%d)\n", ret);\r\nelse\r\ndev_info(i2c->dev, "setting freq %d\n", got);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int s3c24xx_i2c_register_cpufreq(struct s3c24xx_i2c *i2c)\r\n{\r\ni2c->freq_transition.notifier_call = s3c24xx_i2c_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&i2c->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void s3c24xx_i2c_deregister_cpufreq(struct s3c24xx_i2c *i2c)\r\n{\r\ncpufreq_unregister_notifier(&i2c->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline int s3c24xx_i2c_register_cpufreq(struct s3c24xx_i2c *i2c)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void s3c24xx_i2c_deregister_cpufreq(struct s3c24xx_i2c *i2c)\r\n{\r\n}\r\nstatic int s3c24xx_i2c_parse_dt_gpio(struct s3c24xx_i2c *i2c)\r\n{\r\nint idx, gpio, ret;\r\nif (i2c->quirks & QUIRK_NO_GPIO)\r\nreturn 0;\r\nfor (idx = 0; idx < 2; idx++) {\r\ngpio = of_get_gpio(i2c->dev->of_node, idx);\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(i2c->dev, "invalid gpio[%d]: %d\n", idx, gpio);\r\ngoto free_gpio;\r\n}\r\ni2c->gpios[idx] = gpio;\r\nret = gpio_request(gpio, "i2c-bus");\r\nif (ret) {\r\ndev_err(i2c->dev, "gpio [%d] request failed (%d)\n",\r\ngpio, ret);\r\ngoto free_gpio;\r\n}\r\n}\r\nreturn 0;\r\nfree_gpio:\r\nwhile (--idx >= 0)\r\ngpio_free(i2c->gpios[idx]);\r\nreturn -EINVAL;\r\n}\r\nstatic void s3c24xx_i2c_dt_gpio_free(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned int idx;\r\nif (i2c->quirks & QUIRK_NO_GPIO)\r\nreturn;\r\nfor (idx = 0; idx < 2; idx++)\r\ngpio_free(i2c->gpios[idx]);\r\n}\r\nstatic int s3c24xx_i2c_parse_dt_gpio(struct s3c24xx_i2c *i2c)\r\n{\r\nreturn 0;\r\n}\r\nstatic void s3c24xx_i2c_dt_gpio_free(struct s3c24xx_i2c *i2c)\r\n{\r\n}\r\nstatic int s3c24xx_i2c_init(struct s3c24xx_i2c *i2c)\r\n{\r\nstruct s3c2410_platform_i2c *pdata;\r\nunsigned int freq;\r\npdata = i2c->pdata;\r\nwriteb(pdata->slave_addr, i2c->regs + S3C2410_IICADD);\r\ndev_info(i2c->dev, "slave address 0x%02x\n", pdata->slave_addr);\r\nwritel(0, i2c->regs + S3C2410_IICCON);\r\nwritel(0, i2c->regs + S3C2410_IICSTAT);\r\nif (s3c24xx_i2c_clockrate(i2c, &freq) != 0) {\r\ndev_err(i2c->dev, "cannot meet bus frequency required\n");\r\nreturn -EINVAL;\r\n}\r\ndev_info(i2c->dev, "bus frequency set to %d KHz\n", freq);\r\ndev_dbg(i2c->dev, "S3C2410_IICCON=0x%02x\n",\r\nreadl(i2c->regs + S3C2410_IICCON));\r\nreturn 0;\r\n}\r\nstatic void\r\ns3c24xx_i2c_parse_dt(struct device_node *np, struct s3c24xx_i2c *i2c)\r\n{\r\nstruct s3c2410_platform_i2c *pdata = i2c->pdata;\r\nint id;\r\nif (!np)\r\nreturn;\r\npdata->bus_num = -1;\r\nof_property_read_u32(np, "samsung,i2c-sda-delay", &pdata->sda_delay);\r\nof_property_read_u32(np, "samsung,i2c-slave-addr", &pdata->slave_addr);\r\nof_property_read_u32(np, "samsung,i2c-max-bus-freq",\r\n(u32 *)&pdata->frequency);\r\nid = of_alias_get_id(np, "i2c");\r\ni2c->sysreg = syscon_regmap_lookup_by_phandle(np,\r\n"samsung,sysreg-phandle");\r\nif (IS_ERR(i2c->sysreg))\r\nreturn;\r\nregmap_update_bits(i2c->sysreg, EXYNOS5_SYS_I2C_CFG, BIT(id), 0);\r\n}\r\nstatic void\r\ns3c24xx_i2c_parse_dt(struct device_node *np, struct s3c24xx_i2c *i2c) { }\r\nstatic int s3c24xx_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c24xx_i2c *i2c;\r\nstruct s3c2410_platform_i2c *pdata = NULL;\r\nstruct resource *res;\r\nint ret;\r\nif (!pdev->dev.of_node) {\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(struct s3c24xx_i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\ni2c->pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!i2c->pdata)\r\nreturn -ENOMEM;\r\ni2c->quirks = s3c24xx_get_device_quirks(pdev);\r\ni2c->sysreg = ERR_PTR(-ENOENT);\r\nif (pdata)\r\nmemcpy(i2c->pdata, pdata, sizeof(*pdata));\r\nelse\r\ns3c24xx_i2c_parse_dt(pdev->dev.of_node, i2c);\r\nstrlcpy(i2c->adap.name, "s3c2410-i2c", sizeof(i2c->adap.name));\r\ni2c->adap.owner = THIS_MODULE;\r\ni2c->adap.algo = &s3c24xx_i2c_algorithm;\r\ni2c->adap.retries = 2;\r\ni2c->adap.class = I2C_CLASS_DEPRECATED;\r\ni2c->tx_setup = 50;\r\ninit_waitqueue_head(&i2c->wait);\r\ni2c->dev = &pdev->dev;\r\ni2c->clk = devm_clk_get(&pdev->dev, "i2c");\r\nif (IS_ERR(i2c->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nreturn -ENOENT;\r\n}\r\ndev_dbg(&pdev->dev, "clock source %p\n", i2c->clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c->regs))\r\nreturn PTR_ERR(i2c->regs);\r\ndev_dbg(&pdev->dev, "registers %p (%p)\n",\r\ni2c->regs, res);\r\ni2c->adap.algo_data = i2c;\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->pctrl = devm_pinctrl_get_select_default(i2c->dev);\r\nif (i2c->pdata->cfg_gpio)\r\ni2c->pdata->cfg_gpio(to_platform_device(i2c->dev));\r\nelse if (IS_ERR(i2c->pctrl) && s3c24xx_i2c_parse_dt_gpio(i2c))\r\nreturn -EINVAL;\r\nret = clk_prepare_enable(i2c->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "I2C clock enable failed\n");\r\nreturn ret;\r\n}\r\nret = s3c24xx_i2c_init(i2c);\r\nclk_disable(i2c->clk);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "I2C controller init failed\n");\r\nclk_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\nif (!(i2c->quirks & QUIRK_POLL)) {\r\ni2c->irq = ret = platform_get_irq(pdev, 0);\r\nif (ret <= 0) {\r\ndev_err(&pdev->dev, "cannot find IRQ\n");\r\nclk_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, i2c->irq, s3c24xx_i2c_irq,\r\n0, dev_name(&pdev->dev), i2c);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "cannot claim IRQ %d\n", i2c->irq);\r\nclk_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\n}\r\nret = s3c24xx_i2c_register_cpufreq(i2c);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register cpufreq notifier\n");\r\nclk_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\ni2c->adap.nr = i2c->pdata->bus_num;\r\ni2c->adap.dev.of_node = pdev->dev.of_node;\r\nplatform_set_drvdata(pdev, i2c);\r\npm_runtime_enable(&pdev->dev);\r\nret = i2c_add_numbered_adapter(&i2c->adap);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add bus to i2c core\n");\r\npm_runtime_disable(&pdev->dev);\r\ns3c24xx_i2c_deregister_cpufreq(i2c);\r\nclk_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\ndev_info(&pdev->dev, "%s: S3C I2C adapter\n", dev_name(&i2c->adap.dev));\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c24xx_i2c *i2c = platform_get_drvdata(pdev);\r\nclk_unprepare(i2c->clk);\r\npm_runtime_disable(&pdev->dev);\r\ns3c24xx_i2c_deregister_cpufreq(i2c);\r\ni2c_del_adapter(&i2c->adap);\r\nif (pdev->dev.of_node && IS_ERR(i2c->pctrl))\r\ns3c24xx_i2c_dt_gpio_free(i2c);\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_i2c_suspend_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s3c24xx_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c->suspended = 1;\r\nif (!IS_ERR(i2c->sysreg))\r\nregmap_read(i2c->sysreg, EXYNOS5_SYS_I2C_CFG, &i2c->sys_i2c_cfg);\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_i2c_resume_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s3c24xx_i2c *i2c = platform_get_drvdata(pdev);\r\nint ret;\r\nif (!IS_ERR(i2c->sysreg))\r\nregmap_write(i2c->sysreg, EXYNOS5_SYS_I2C_CFG, i2c->sys_i2c_cfg);\r\nret = clk_enable(i2c->clk);\r\nif (ret)\r\nreturn ret;\r\ns3c24xx_i2c_init(i2c);\r\nclk_disable(i2c->clk);\r\ni2c->suspended = 0;\r\nreturn 0;\r\n}\r\nstatic int __init i2c_adap_s3c_init(void)\r\n{\r\nreturn platform_driver_register(&s3c24xx_i2c_driver);\r\n}\r\nstatic void __exit i2c_adap_s3c_exit(void)\r\n{\r\nplatform_driver_unregister(&s3c24xx_i2c_driver);\r\n}
