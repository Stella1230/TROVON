static u32 size_round_up(size_t size, size_t blksize)\r\n{\r\nreturn ((size + blksize - 1) / blksize) * blksize;\r\n}\r\nstatic void dir_crypt_complete(struct crypto_async_request *req, int res)\r\n{\r\nstruct fscrypt_completion_result *ecr = req->data;\r\nif (res == -EINPROGRESS)\r\nreturn;\r\necr->res = res;\r\ncomplete(&ecr->completion);\r\n}\r\nstatic int fname_encrypt(struct inode *inode,\r\nconst struct qstr *iname, struct fscrypt_str *oname)\r\n{\r\nu32 ciphertext_len;\r\nstruct skcipher_request *req = NULL;\r\nDECLARE_FS_COMPLETION_RESULT(ecr);\r\nstruct fscrypt_info *ci = inode->i_crypt_info;\r\nstruct crypto_skcipher *tfm = ci->ci_ctfm;\r\nint res = 0;\r\nchar iv[FS_CRYPTO_BLOCK_SIZE];\r\nstruct scatterlist src_sg, dst_sg;\r\nint padding = 4 << (ci->ci_flags & FS_POLICY_FLAGS_PAD_MASK);\r\nchar *workbuf, buf[32], *alloc_buf = NULL;\r\nunsigned lim;\r\nlim = inode->i_sb->s_cop->max_namelen(inode);\r\nif (iname->len <= 0 || iname->len > lim)\r\nreturn -EIO;\r\nciphertext_len = (iname->len < FS_CRYPTO_BLOCK_SIZE) ?\r\nFS_CRYPTO_BLOCK_SIZE : iname->len;\r\nciphertext_len = size_round_up(ciphertext_len, padding);\r\nciphertext_len = (ciphertext_len > lim) ? lim : ciphertext_len;\r\nif (ciphertext_len <= sizeof(buf)) {\r\nworkbuf = buf;\r\n} else {\r\nalloc_buf = kmalloc(ciphertext_len, GFP_NOFS);\r\nif (!alloc_buf)\r\nreturn -ENOMEM;\r\nworkbuf = alloc_buf;\r\n}\r\nreq = skcipher_request_alloc(tfm, GFP_NOFS);\r\nif (!req) {\r\nprintk_ratelimited(KERN_ERR\r\n"%s: crypto_request_alloc() failed\n", __func__);\r\nkfree(alloc_buf);\r\nreturn -ENOMEM;\r\n}\r\nskcipher_request_set_callback(req,\r\nCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\r\ndir_crypt_complete, &ecr);\r\nmemcpy(workbuf, iname->name, iname->len);\r\nif (iname->len < ciphertext_len)\r\nmemset(workbuf + iname->len, 0, ciphertext_len - iname->len);\r\nmemset(iv, 0, FS_CRYPTO_BLOCK_SIZE);\r\nsg_init_one(&src_sg, workbuf, ciphertext_len);\r\nsg_init_one(&dst_sg, oname->name, ciphertext_len);\r\nskcipher_request_set_crypt(req, &src_sg, &dst_sg, ciphertext_len, iv);\r\nres = crypto_skcipher_encrypt(req);\r\nif (res == -EINPROGRESS || res == -EBUSY) {\r\nwait_for_completion(&ecr.completion);\r\nres = ecr.res;\r\n}\r\nkfree(alloc_buf);\r\nskcipher_request_free(req);\r\nif (res < 0)\r\nprintk_ratelimited(KERN_ERR\r\n"%s: Error (error code %d)\n", __func__, res);\r\noname->len = ciphertext_len;\r\nreturn res;\r\n}\r\nstatic int fname_decrypt(struct inode *inode,\r\nconst struct fscrypt_str *iname,\r\nstruct fscrypt_str *oname)\r\n{\r\nstruct skcipher_request *req = NULL;\r\nDECLARE_FS_COMPLETION_RESULT(ecr);\r\nstruct scatterlist src_sg, dst_sg;\r\nstruct fscrypt_info *ci = inode->i_crypt_info;\r\nstruct crypto_skcipher *tfm = ci->ci_ctfm;\r\nint res = 0;\r\nchar iv[FS_CRYPTO_BLOCK_SIZE];\r\nunsigned lim;\r\nlim = inode->i_sb->s_cop->max_namelen(inode);\r\nif (iname->len <= 0 || iname->len > lim)\r\nreturn -EIO;\r\nreq = skcipher_request_alloc(tfm, GFP_NOFS);\r\nif (!req) {\r\nprintk_ratelimited(KERN_ERR\r\n"%s: crypto_request_alloc() failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nskcipher_request_set_callback(req,\r\nCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\r\ndir_crypt_complete, &ecr);\r\nmemset(iv, 0, FS_CRYPTO_BLOCK_SIZE);\r\nsg_init_one(&src_sg, iname->name, iname->len);\r\nsg_init_one(&dst_sg, oname->name, oname->len);\r\nskcipher_request_set_crypt(req, &src_sg, &dst_sg, iname->len, iv);\r\nres = crypto_skcipher_decrypt(req);\r\nif (res == -EINPROGRESS || res == -EBUSY) {\r\nwait_for_completion(&ecr.completion);\r\nres = ecr.res;\r\n}\r\nskcipher_request_free(req);\r\nif (res < 0) {\r\nprintk_ratelimited(KERN_ERR\r\n"%s: Error (error code %d)\n", __func__, res);\r\nreturn res;\r\n}\r\noname->len = strnlen(oname->name, iname->len);\r\nreturn oname->len;\r\n}\r\nstatic int digest_encode(const char *src, int len, char *dst)\r\n{\r\nint i = 0, bits = 0, ac = 0;\r\nchar *cp = dst;\r\nwhile (i < len) {\r\nac += (((unsigned char) src[i]) << bits);\r\nbits += 8;\r\ndo {\r\n*cp++ = lookup_table[ac & 0x3f];\r\nac >>= 6;\r\nbits -= 6;\r\n} while (bits >= 6);\r\ni++;\r\n}\r\nif (bits)\r\n*cp++ = lookup_table[ac & 0x3f];\r\nreturn cp - dst;\r\n}\r\nstatic int digest_decode(const char *src, int len, char *dst)\r\n{\r\nint i = 0, bits = 0, ac = 0;\r\nconst char *p;\r\nchar *cp = dst;\r\nwhile (i < len) {\r\np = strchr(lookup_table, src[i]);\r\nif (p == NULL || src[i] == 0)\r\nreturn -2;\r\nac += (p - lookup_table) << bits;\r\nbits += 6;\r\nif (bits >= 8) {\r\n*cp++ = ac & 0xff;\r\nac >>= 8;\r\nbits -= 8;\r\n}\r\ni++;\r\n}\r\nif (ac)\r\nreturn -1;\r\nreturn cp - dst;\r\n}\r\nu32 fscrypt_fname_encrypted_size(struct inode *inode, u32 ilen)\r\n{\r\nint padding = 32;\r\nstruct fscrypt_info *ci = inode->i_crypt_info;\r\nif (ci)\r\npadding = 4 << (ci->ci_flags & FS_POLICY_FLAGS_PAD_MASK);\r\nif (ilen < FS_CRYPTO_BLOCK_SIZE)\r\nilen = FS_CRYPTO_BLOCK_SIZE;\r\nreturn size_round_up(ilen, padding);\r\n}\r\nint fscrypt_fname_alloc_buffer(struct inode *inode,\r\nu32 ilen, struct fscrypt_str *crypto_str)\r\n{\r\nunsigned int olen = fscrypt_fname_encrypted_size(inode, ilen);\r\ncrypto_str->len = olen;\r\nif (olen < FS_FNAME_CRYPTO_DIGEST_SIZE * 2)\r\nolen = FS_FNAME_CRYPTO_DIGEST_SIZE * 2;\r\ncrypto_str->name = kmalloc(olen + 1, GFP_NOFS);\r\nif (!(crypto_str->name))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid fscrypt_fname_free_buffer(struct fscrypt_str *crypto_str)\r\n{\r\nif (!crypto_str)\r\nreturn;\r\nkfree(crypto_str->name);\r\ncrypto_str->name = NULL;\r\n}\r\nint fscrypt_fname_disk_to_usr(struct inode *inode,\r\nu32 hash, u32 minor_hash,\r\nconst struct fscrypt_str *iname,\r\nstruct fscrypt_str *oname)\r\n{\r\nconst struct qstr qname = FSTR_TO_QSTR(iname);\r\nchar buf[24];\r\nint ret;\r\nif (fscrypt_is_dot_dotdot(&qname)) {\r\noname->name[0] = '.';\r\noname->name[iname->len - 1] = '.';\r\noname->len = iname->len;\r\nreturn oname->len;\r\n}\r\nif (iname->len < FS_CRYPTO_BLOCK_SIZE)\r\nreturn -EUCLEAN;\r\nif (inode->i_crypt_info)\r\nreturn fname_decrypt(inode, iname, oname);\r\nif (iname->len <= FS_FNAME_CRYPTO_DIGEST_SIZE) {\r\nret = digest_encode(iname->name, iname->len, oname->name);\r\noname->len = ret;\r\nreturn ret;\r\n}\r\nif (hash) {\r\nmemcpy(buf, &hash, 4);\r\nmemcpy(buf + 4, &minor_hash, 4);\r\n} else {\r\nmemset(buf, 0, 8);\r\n}\r\nmemcpy(buf + 8, iname->name + iname->len - 16, 16);\r\noname->name[0] = '_';\r\nret = digest_encode(buf, 24, oname->name + 1);\r\noname->len = ret + 1;\r\nreturn ret + 1;\r\n}\r\nint fscrypt_fname_usr_to_disk(struct inode *inode,\r\nconst struct qstr *iname,\r\nstruct fscrypt_str *oname)\r\n{\r\nif (fscrypt_is_dot_dotdot(iname)) {\r\noname->name[0] = '.';\r\noname->name[iname->len - 1] = '.';\r\noname->len = iname->len;\r\nreturn oname->len;\r\n}\r\nif (inode->i_crypt_info)\r\nreturn fname_encrypt(inode, iname, oname);\r\nreturn -EACCES;\r\n}\r\nint fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\r\nint lookup, struct fscrypt_name *fname)\r\n{\r\nint ret = 0, bigname = 0;\r\nmemset(fname, 0, sizeof(struct fscrypt_name));\r\nfname->usr_fname = iname;\r\nif (!dir->i_sb->s_cop->is_encrypted(dir) ||\r\nfscrypt_is_dot_dotdot(iname)) {\r\nfname->disk_name.name = (unsigned char *)iname->name;\r\nfname->disk_name.len = iname->len;\r\nreturn 0;\r\n}\r\nret = get_crypt_info(dir);\r\nif (ret && ret != -EOPNOTSUPP)\r\nreturn ret;\r\nif (dir->i_crypt_info) {\r\nret = fscrypt_fname_alloc_buffer(dir, iname->len,\r\n&fname->crypto_buf);\r\nif (ret < 0)\r\nreturn ret;\r\nret = fname_encrypt(dir, iname, &fname->crypto_buf);\r\nif (ret < 0)\r\ngoto errout;\r\nfname->disk_name.name = fname->crypto_buf.name;\r\nfname->disk_name.len = fname->crypto_buf.len;\r\nreturn 0;\r\n}\r\nif (!lookup)\r\nreturn -EACCES;\r\nif (iname->name[0] == '_')\r\nbigname = 1;\r\nif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\r\nreturn -ENOENT;\r\nfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\r\nif (fname->crypto_buf.name == NULL)\r\nreturn -ENOMEM;\r\nret = digest_decode(iname->name + bigname, iname->len - bigname,\r\nfname->crypto_buf.name);\r\nif (ret < 0) {\r\nret = -ENOENT;\r\ngoto errout;\r\n}\r\nfname->crypto_buf.len = ret;\r\nif (bigname) {\r\nmemcpy(&fname->hash, fname->crypto_buf.name, 4);\r\nmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\r\n} else {\r\nfname->disk_name.name = fname->crypto_buf.name;\r\nfname->disk_name.len = fname->crypto_buf.len;\r\n}\r\nreturn 0;\r\nerrout:\r\nfscrypt_fname_free_buffer(&fname->crypto_buf);\r\nreturn ret;\r\n}\r\nvoid fscrypt_free_filename(struct fscrypt_name *fname)\r\n{\r\nkfree(fname->crypto_buf.name);\r\nfname->crypto_buf.name = NULL;\r\nfname->usr_fname = NULL;\r\nfname->disk_name.name = NULL;\r\n}
