static inline u32 m_can_read(const struct m_can_priv *priv, enum m_can_reg reg)\r\n{\r\nreturn readl(priv->base + reg);\r\n}\r\nstatic inline void m_can_write(const struct m_can_priv *priv,\r\nenum m_can_reg reg, u32 val)\r\n{\r\nwritel(val, priv->base + reg);\r\n}\r\nstatic inline u32 m_can_fifo_read(const struct m_can_priv *priv,\r\nu32 fgi, unsigned int offset)\r\n{\r\nreturn readl(priv->mram_base + priv->mcfg[MRAM_RXF0].off +\r\nfgi * RXF0_ELEMENT_SIZE + offset);\r\n}\r\nstatic inline void m_can_fifo_write(const struct m_can_priv *priv,\r\nu32 fpi, unsigned int offset, u32 val)\r\n{\r\nwritel(val, priv->mram_base + priv->mcfg[MRAM_TXB].off +\r\nfpi * TXB_ELEMENT_SIZE + offset);\r\n}\r\nstatic inline void m_can_config_endisable(const struct m_can_priv *priv,\r\nbool enable)\r\n{\r\nu32 cccr = m_can_read(priv, M_CAN_CCCR);\r\nu32 timeout = 10;\r\nu32 val = 0;\r\nif (enable) {\r\nm_can_write(priv, M_CAN_CCCR, cccr | CCCR_INIT);\r\nudelay(5);\r\nm_can_write(priv, M_CAN_CCCR, cccr | CCCR_INIT | CCCR_CCE);\r\n} else {\r\nm_can_write(priv, M_CAN_CCCR, cccr & ~(CCCR_INIT | CCCR_CCE));\r\n}\r\nif (enable)\r\nval = CCCR_INIT | CCCR_CCE;\r\nwhile ((m_can_read(priv, M_CAN_CCCR) & (CCCR_INIT | CCCR_CCE)) != val) {\r\nif (timeout == 0) {\r\nnetdev_warn(priv->dev, "Failed to init module\n");\r\nreturn;\r\n}\r\ntimeout--;\r\nudelay(1);\r\n}\r\n}\r\nstatic inline void m_can_enable_all_interrupts(const struct m_can_priv *priv)\r\n{\r\nm_can_write(priv, M_CAN_ILE, ILE_EINT0 | ILE_EINT1);\r\n}\r\nstatic inline void m_can_disable_all_interrupts(const struct m_can_priv *priv)\r\n{\r\nm_can_write(priv, M_CAN_ILE, 0x0);\r\n}\r\nstatic void m_can_read_fifo(struct net_device *dev, u32 rxfs)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct canfd_frame *cf;\r\nstruct sk_buff *skb;\r\nu32 id, fgi, dlc;\r\nint i;\r\nfgi = (rxfs & RXFS_FGI_MASK) >> RXFS_FGI_OFF;\r\ndlc = m_can_fifo_read(priv, fgi, M_CAN_FIFO_DLC);\r\nif (dlc & RX_BUF_EDL)\r\nskb = alloc_canfd_skb(dev, &cf);\r\nelse\r\nskb = alloc_can_skb(dev, (struct can_frame **)&cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nif (dlc & RX_BUF_EDL)\r\ncf->len = can_dlc2len((dlc >> 16) & 0x0F);\r\nelse\r\ncf->len = get_can_dlc((dlc >> 16) & 0x0F);\r\nid = m_can_fifo_read(priv, fgi, M_CAN_FIFO_ID);\r\nif (id & RX_BUF_XTD)\r\ncf->can_id = (id & CAN_EFF_MASK) | CAN_EFF_FLAG;\r\nelse\r\ncf->can_id = (id >> 18) & CAN_SFF_MASK;\r\nif (id & RX_BUF_ESI) {\r\ncf->flags |= CANFD_ESI;\r\nnetdev_dbg(dev, "ESI Error\n");\r\n}\r\nif (!(dlc & RX_BUF_EDL) && (id & RX_BUF_RTR)) {\r\ncf->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nif (dlc & RX_BUF_BRS)\r\ncf->flags |= CANFD_BRS;\r\nfor (i = 0; i < cf->len; i += 4)\r\n*(u32 *)(cf->data + i) =\r\nm_can_fifo_read(priv, fgi,\r\nM_CAN_FIFO_DATA(i / 4));\r\n}\r\nm_can_write(priv, M_CAN_RXF0A, fgi);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->len;\r\nnetif_receive_skb(skb);\r\n}\r\nstatic int m_can_do_rx_poll(struct net_device *dev, int quota)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nu32 pkts = 0;\r\nu32 rxfs;\r\nrxfs = m_can_read(priv, M_CAN_RXF0S);\r\nif (!(rxfs & RXFS_FFL_MASK)) {\r\nnetdev_dbg(dev, "no messages in fifo0\n");\r\nreturn 0;\r\n}\r\nwhile ((rxfs & RXFS_FFL_MASK) && (quota > 0)) {\r\nif (rxfs & RXFS_RFL)\r\nnetdev_warn(dev, "Rx FIFO 0 Message Lost\n");\r\nm_can_read_fifo(dev, rxfs);\r\nquota--;\r\npkts++;\r\nrxfs = m_can_read(priv, M_CAN_RXF0S);\r\n}\r\nif (pkts)\r\ncan_led_event(dev, CAN_LED_EVENT_RX);\r\nreturn pkts;\r\n}\r\nstatic int m_can_handle_lost_msg(struct net_device *dev)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct sk_buff *skb;\r\nstruct can_frame *frame;\r\nnetdev_err(dev, "msg lost in rxf0\n");\r\nstats->rx_errors++;\r\nstats->rx_over_errors++;\r\nskb = alloc_can_err_skb(dev, &frame);\r\nif (unlikely(!skb))\r\nreturn 0;\r\nframe->can_id |= CAN_ERR_CRTL;\r\nframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int m_can_handle_lec_err(struct net_device *dev,\r\nenum m_can_lec_type lec_type)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nswitch (lec_type) {\r\ncase LEC_STUFF_ERROR:\r\nnetdev_dbg(dev, "stuff error\n");\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nbreak;\r\ncase LEC_FORM_ERROR:\r\nnetdev_dbg(dev, "form error\n");\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nbreak;\r\ncase LEC_ACK_ERROR:\r\nnetdev_dbg(dev, "ack error\n");\r\ncf->data[3] = CAN_ERR_PROT_LOC_ACK;\r\nbreak;\r\ncase LEC_BIT1_ERROR:\r\nnetdev_dbg(dev, "bit1 error\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\nbreak;\r\ncase LEC_BIT0_ERROR:\r\nnetdev_dbg(dev, "bit0 error\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\nbreak;\r\ncase LEC_CRC_ERROR:\r\nnetdev_dbg(dev, "CRC error\n");\r\ncf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int __m_can_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nunsigned int ecr;\r\necr = m_can_read(priv, M_CAN_ECR);\r\nbec->rxerr = (ecr & ECR_REC_MASK) >> ECR_REC_SHIFT;\r\nbec->txerr = ecr & ECR_TEC_MASK;\r\nreturn 0;\r\n}\r\nstatic int m_can_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nint err;\r\nerr = clk_prepare_enable(priv->hclk);\r\nif (err)\r\nreturn err;\r\nerr = clk_prepare_enable(priv->cclk);\r\nif (err) {\r\nclk_disable_unprepare(priv->hclk);\r\nreturn err;\r\n}\r\n__m_can_get_berr_counter(dev, bec);\r\nclk_disable_unprepare(priv->cclk);\r\nclk_disable_unprepare(priv->hclk);\r\nreturn 0;\r\n}\r\nstatic int m_can_handle_state_change(struct net_device *dev,\r\nenum can_state new_state)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct can_berr_counter bec;\r\nunsigned int ecr;\r\nswitch (new_state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\npriv->can.can_stats.error_warning++;\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\npriv->can.can_stats.error_passive++;\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\nbreak;\r\ncase CAN_STATE_BUS_OFF:\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\nm_can_disable_all_interrupts(priv);\r\npriv->can.can_stats.bus_off++;\r\ncan_bus_off(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\n__m_can_get_berr_counter(dev, &bec);\r\nswitch (new_state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (bec.txerr > bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\ncf->data[6] = bec.txerr;\r\ncf->data[7] = bec.rxerr;\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\ncf->can_id |= CAN_ERR_CRTL;\r\necr = m_can_read(priv, M_CAN_ECR);\r\nif (ecr & ECR_RP)\r\ncf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\r\nif (bec.txerr > 127)\r\ncf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\r\ncf->data[6] = bec.txerr;\r\ncf->data[7] = bec.rxerr;\r\nbreak;\r\ncase CAN_STATE_BUS_OFF:\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int m_can_handle_state_errors(struct net_device *dev, u32 psr)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nint work_done = 0;\r\nif ((psr & PSR_EW) &&\r\n(priv->can.state != CAN_STATE_ERROR_WARNING)) {\r\nnetdev_dbg(dev, "entered error warning state\n");\r\nwork_done += m_can_handle_state_change(dev,\r\nCAN_STATE_ERROR_WARNING);\r\n}\r\nif ((psr & PSR_EP) &&\r\n(priv->can.state != CAN_STATE_ERROR_PASSIVE)) {\r\nnetdev_dbg(dev, "entered error passive state\n");\r\nwork_done += m_can_handle_state_change(dev,\r\nCAN_STATE_ERROR_PASSIVE);\r\n}\r\nif ((psr & PSR_BO) &&\r\n(priv->can.state != CAN_STATE_BUS_OFF)) {\r\nnetdev_dbg(dev, "entered error bus off state\n");\r\nwork_done += m_can_handle_state_change(dev,\r\nCAN_STATE_BUS_OFF);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void m_can_handle_other_err(struct net_device *dev, u32 irqstatus)\r\n{\r\nif (irqstatus & IR_WDI)\r\nnetdev_err(dev, "Message RAM Watchdog event due to missing READY\n");\r\nif (irqstatus & IR_ELO)\r\nnetdev_err(dev, "Error Logging Overflow\n");\r\nif (irqstatus & IR_BEU)\r\nnetdev_err(dev, "Bit Error Uncorrected\n");\r\nif (irqstatus & IR_BEC)\r\nnetdev_err(dev, "Bit Error Corrected\n");\r\nif (irqstatus & IR_TOO)\r\nnetdev_err(dev, "Timeout reached\n");\r\nif (irqstatus & IR_MRAF)\r\nnetdev_err(dev, "Message RAM access failure occurred\n");\r\n}\r\nstatic inline bool is_lec_err(u32 psr)\r\n{\r\npsr &= LEC_UNUSED;\r\nreturn psr && (psr != LEC_UNUSED);\r\n}\r\nstatic int m_can_handle_bus_errors(struct net_device *dev, u32 irqstatus,\r\nu32 psr)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nint work_done = 0;\r\nif (irqstatus & IR_RF0L)\r\nwork_done += m_can_handle_lost_msg(dev);\r\nif ((priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) &&\r\nis_lec_err(psr))\r\nwork_done += m_can_handle_lec_err(dev, psr & LEC_UNUSED);\r\nm_can_handle_other_err(dev, irqstatus);\r\nreturn work_done;\r\n}\r\nstatic int m_can_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct net_device *dev = napi->dev;\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nint work_done = 0;\r\nu32 irqstatus, psr;\r\nirqstatus = priv->irqstatus | m_can_read(priv, M_CAN_IR);\r\nif (!irqstatus)\r\ngoto end;\r\npsr = m_can_read(priv, M_CAN_PSR);\r\nif (irqstatus & IR_ERR_STATE)\r\nwork_done += m_can_handle_state_errors(dev, psr);\r\nif (irqstatus & IR_ERR_BUS)\r\nwork_done += m_can_handle_bus_errors(dev, irqstatus, psr);\r\nif (irqstatus & IR_RF0N)\r\nwork_done += m_can_do_rx_poll(dev, (quota - work_done));\r\nif (work_done < quota) {\r\nnapi_complete(napi);\r\nm_can_enable_all_interrupts(priv);\r\n}\r\nend:\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t m_can_isr(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nu32 ir;\r\nir = m_can_read(priv, M_CAN_IR);\r\nif (!ir)\r\nreturn IRQ_NONE;\r\nif (ir & IR_ALL_INT)\r\nm_can_write(priv, M_CAN_IR, ir);\r\nif ((ir & IR_RF0N) || (ir & IR_ERR_ALL)) {\r\npriv->irqstatus = ir;\r\nm_can_disable_all_interrupts(priv);\r\nnapi_schedule(&priv->napi);\r\n}\r\nif (ir & IR_TC) {\r\nstats->tx_bytes += can_get_echo_skb(dev, 0);\r\nstats->tx_packets++;\r\ncan_led_event(dev, CAN_LED_EVENT_TX);\r\nnetif_wake_queue(dev);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int m_can_set_bittiming(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nconst struct can_bittiming *bt = &priv->can.bittiming;\r\nconst struct can_bittiming *dbt = &priv->can.data_bittiming;\r\nu16 brp, sjw, tseg1, tseg2;\r\nu32 reg_btp;\r\nbrp = bt->brp - 1;\r\nsjw = bt->sjw - 1;\r\ntseg1 = bt->prop_seg + bt->phase_seg1 - 1;\r\ntseg2 = bt->phase_seg2 - 1;\r\nreg_btp = (brp << BTR_BRP_SHIFT) | (sjw << BTR_SJW_SHIFT) |\r\n(tseg1 << BTR_TSEG1_SHIFT) | (tseg2 << BTR_TSEG2_SHIFT);\r\nm_can_write(priv, M_CAN_BTP, reg_btp);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\r\nbrp = dbt->brp - 1;\r\nsjw = dbt->sjw - 1;\r\ntseg1 = dbt->prop_seg + dbt->phase_seg1 - 1;\r\ntseg2 = dbt->phase_seg2 - 1;\r\nreg_btp = (brp << FBTR_FBRP_SHIFT) | (sjw << FBTR_FSJW_SHIFT) |\r\n(tseg1 << FBTR_FTSEG1_SHIFT) |\r\n(tseg2 << FBTR_FTSEG2_SHIFT);\r\nm_can_write(priv, M_CAN_FBTP, reg_btp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void m_can_chip_config(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nu32 cccr, test;\r\nm_can_config_endisable(priv, true);\r\nm_can_write(priv, M_CAN_RXESC, M_CAN_RXESC_64BYTES);\r\nm_can_write(priv, M_CAN_GFC, 0x0);\r\nm_can_write(priv, M_CAN_TXBC, (1 << TXBC_NDTB_OFF) |\r\npriv->mcfg[MRAM_TXB].off);\r\nm_can_write(priv, M_CAN_TXESC, TXESC_TBDS_64BYTES);\r\nm_can_write(priv, M_CAN_TXEFC, (1 << TXEFC_EFS_OFF) |\r\npriv->mcfg[MRAM_TXE].off);\r\nm_can_write(priv, M_CAN_RXF0C,\r\n(priv->mcfg[MRAM_RXF0].num << RXFC_FS_OFF) |\r\nRXFC_FWM_1 | priv->mcfg[MRAM_RXF0].off);\r\nm_can_write(priv, M_CAN_RXF1C,\r\n(priv->mcfg[MRAM_RXF1].num << RXFC_FS_OFF) |\r\nRXFC_FWM_1 | priv->mcfg[MRAM_RXF1].off);\r\ncccr = m_can_read(priv, M_CAN_CCCR);\r\ncccr &= ~(CCCR_TEST | CCCR_MON | (CCCR_CMR_MASK << CCCR_CMR_SHIFT) |\r\n(CCCR_CME_MASK << CCCR_CME_SHIFT));\r\ntest = m_can_read(priv, M_CAN_TEST);\r\ntest &= ~TEST_LBCK;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\ncccr |= CCCR_MON;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {\r\ncccr |= CCCR_TEST;\r\ntest |= TEST_LBCK;\r\n}\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD)\r\ncccr |= CCCR_CME_CANFD_BRS << CCCR_CME_SHIFT;\r\nm_can_write(priv, M_CAN_CCCR, cccr);\r\nm_can_write(priv, M_CAN_TEST, test);\r\nm_can_write(priv, M_CAN_IR, IR_ALL_INT);\r\nif (!(priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING))\r\nm_can_write(priv, M_CAN_IE, IR_ALL_INT & ~IR_ERR_LEC);\r\nelse\r\nm_can_write(priv, M_CAN_IE, IR_ALL_INT);\r\nm_can_write(priv, M_CAN_ILS, ILS_ALL_INT0);\r\nm_can_set_bittiming(dev);\r\nm_can_config_endisable(priv, false);\r\n}\r\nstatic void m_can_start(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nm_can_chip_config(dev);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nm_can_enable_all_interrupts(priv);\r\n}\r\nstatic int m_can_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nm_can_start(dev);\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_m_can_dev(struct net_device *dev)\r\n{\r\nfree_candev(dev);\r\n}\r\nstatic struct net_device *alloc_m_can_dev(void)\r\n{\r\nstruct net_device *dev;\r\nstruct m_can_priv *priv;\r\ndev = alloc_candev(sizeof(*priv), 1);\r\nif (!dev)\r\nreturn NULL;\r\npriv = netdev_priv(dev);\r\nnetif_napi_add(dev, &priv->napi, m_can_poll, M_CAN_NAPI_WEIGHT);\r\npriv->dev = dev;\r\npriv->can.bittiming_const = &m_can_bittiming_const;\r\npriv->can.data_bittiming_const = &m_can_data_bittiming_const;\r\npriv->can.do_set_mode = m_can_set_mode;\r\npriv->can.do_get_berr_counter = m_can_get_berr_counter;\r\ncan_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_LISTENONLY |\r\nCAN_CTRLMODE_BERR_REPORTING |\r\nCAN_CTRLMODE_FD;\r\nreturn dev;\r\n}\r\nstatic int m_can_open(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nint err;\r\nerr = clk_prepare_enable(priv->hclk);\r\nif (err)\r\nreturn err;\r\nerr = clk_prepare_enable(priv->cclk);\r\nif (err)\r\ngoto exit_disable_hclk;\r\nerr = open_candev(dev);\r\nif (err) {\r\nnetdev_err(dev, "failed to open can device\n");\r\ngoto exit_disable_cclk;\r\n}\r\nerr = request_irq(dev->irq, m_can_isr, IRQF_SHARED, dev->name,\r\ndev);\r\nif (err < 0) {\r\nnetdev_err(dev, "failed to request interrupt\n");\r\ngoto exit_irq_fail;\r\n}\r\nm_can_start(dev);\r\ncan_led_event(dev, CAN_LED_EVENT_OPEN);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nexit_irq_fail:\r\nclose_candev(dev);\r\nexit_disable_cclk:\r\nclk_disable_unprepare(priv->cclk);\r\nexit_disable_hclk:\r\nclk_disable_unprepare(priv->hclk);\r\nreturn err;\r\n}\r\nstatic void m_can_stop(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nm_can_disable_all_interrupts(priv);\r\nclk_disable_unprepare(priv->hclk);\r\nclk_disable_unprepare(priv->cclk);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic int m_can_close(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&priv->napi);\r\nm_can_stop(dev);\r\nfree_irq(dev->irq, dev);\r\nclose_candev(dev);\r\ncan_led_event(dev, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t m_can_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\r\nu32 id, cccr;\r\nint i;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nnetif_stop_queue(dev);\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\nid = cf->can_id & CAN_EFF_MASK;\r\nid |= TX_BUF_XTD;\r\n} else {\r\nid = ((cf->can_id & CAN_SFF_MASK) << 18);\r\n}\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nid |= TX_BUF_RTR;\r\nm_can_fifo_write(priv, 0, M_CAN_FIFO_ID, id);\r\nm_can_fifo_write(priv, 0, M_CAN_FIFO_DLC, can_len2dlc(cf->len) << 16);\r\nfor (i = 0; i < cf->len; i += 4)\r\nm_can_fifo_write(priv, 0, M_CAN_FIFO_DATA(i / 4),\r\n*(u32 *)(cf->data + i));\r\ncan_put_echo_skb(skb, dev, 0);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\r\ncccr = m_can_read(priv, M_CAN_CCCR);\r\ncccr &= ~(CCCR_CMR_MASK << CCCR_CMR_SHIFT);\r\nif (can_is_canfd_skb(skb)) {\r\nif (cf->flags & CANFD_BRS)\r\ncccr |= CCCR_CMR_CANFD_BRS << CCCR_CMR_SHIFT;\r\nelse\r\ncccr |= CCCR_CMR_CANFD << CCCR_CMR_SHIFT;\r\n} else {\r\ncccr |= CCCR_CMR_CAN << CCCR_CMR_SHIFT;\r\n}\r\nm_can_write(priv, M_CAN_CCCR, cccr);\r\n}\r\nm_can_write(priv, M_CAN_TXBTIE, 0x1);\r\nm_can_write(priv, M_CAN_TXBAR, 0x1);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int register_m_can_dev(struct net_device *dev)\r\n{\r\ndev->flags |= IFF_ECHO;\r\ndev->netdev_ops = &m_can_netdev_ops;\r\nreturn register_candev(dev);\r\n}\r\nstatic int m_can_of_parse_mram(struct platform_device *pdev,\r\nstruct m_can_priv *priv)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *res;\r\nvoid __iomem *addr;\r\nu32 out_val[MRAM_CFG_LEN];\r\nint i, start, end, ret;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "message_ram");\r\nif (!res)\r\nreturn -ENODEV;\r\naddr = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!addr)\r\nreturn -ENOMEM;\r\nret = of_property_read_u32_array(np, "bosch,mram-cfg",\r\nout_val, sizeof(out_val) / 4);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can not get message ram configuration\n");\r\nreturn -ENODEV;\r\n}\r\npriv->mram_base = addr;\r\npriv->mcfg[MRAM_SIDF].off = out_val[0];\r\npriv->mcfg[MRAM_SIDF].num = out_val[1];\r\npriv->mcfg[MRAM_XIDF].off = priv->mcfg[MRAM_SIDF].off +\r\npriv->mcfg[MRAM_SIDF].num * SIDF_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_XIDF].num = out_val[2];\r\npriv->mcfg[MRAM_RXF0].off = priv->mcfg[MRAM_XIDF].off +\r\npriv->mcfg[MRAM_XIDF].num * XIDF_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_RXF0].num = out_val[3] & RXFC_FS_MASK;\r\npriv->mcfg[MRAM_RXF1].off = priv->mcfg[MRAM_RXF0].off +\r\npriv->mcfg[MRAM_RXF0].num * RXF0_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_RXF1].num = out_val[4] & RXFC_FS_MASK;\r\npriv->mcfg[MRAM_RXB].off = priv->mcfg[MRAM_RXF1].off +\r\npriv->mcfg[MRAM_RXF1].num * RXF1_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_RXB].num = out_val[5];\r\npriv->mcfg[MRAM_TXE].off = priv->mcfg[MRAM_RXB].off +\r\npriv->mcfg[MRAM_RXB].num * RXB_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_TXE].num = out_val[6];\r\npriv->mcfg[MRAM_TXB].off = priv->mcfg[MRAM_TXE].off +\r\npriv->mcfg[MRAM_TXE].num * TXE_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_TXB].num = out_val[7] & TXBC_NDTB_MASK;\r\ndev_dbg(&pdev->dev, "mram_base %p sidf 0x%x %d xidf 0x%x %d rxf0 0x%x %d rxf1 0x%x %d rxb 0x%x %d txe 0x%x %d txb 0x%x %d\n",\r\npriv->mram_base,\r\npriv->mcfg[MRAM_SIDF].off, priv->mcfg[MRAM_SIDF].num,\r\npriv->mcfg[MRAM_XIDF].off, priv->mcfg[MRAM_XIDF].num,\r\npriv->mcfg[MRAM_RXF0].off, priv->mcfg[MRAM_RXF0].num,\r\npriv->mcfg[MRAM_RXF1].off, priv->mcfg[MRAM_RXF1].num,\r\npriv->mcfg[MRAM_RXB].off, priv->mcfg[MRAM_RXB].num,\r\npriv->mcfg[MRAM_TXE].off, priv->mcfg[MRAM_TXE].num,\r\npriv->mcfg[MRAM_TXB].off, priv->mcfg[MRAM_TXB].num);\r\nstart = priv->mcfg[MRAM_SIDF].off;\r\nend = priv->mcfg[MRAM_TXB].off +\r\npriv->mcfg[MRAM_TXB].num * TXB_ELEMENT_SIZE;\r\nfor (i = start; i < end; i += 4)\r\nwritel(0x0, priv->mram_base + i);\r\nreturn 0;\r\n}\r\nstatic int m_can_plat_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct m_can_priv *priv;\r\nstruct resource *res;\r\nvoid __iomem *addr;\r\nstruct clk *hclk, *cclk;\r\nint irq, ret;\r\nhclk = devm_clk_get(&pdev->dev, "hclk");\r\ncclk = devm_clk_get(&pdev->dev, "cclk");\r\nif (IS_ERR(hclk) || IS_ERR(cclk)) {\r\ndev_err(&pdev->dev, "no clock find\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "m_can");\r\naddr = devm_ioremap_resource(&pdev->dev, res);\r\nirq = platform_get_irq_byname(pdev, "int0");\r\nif (IS_ERR(addr) || irq < 0)\r\nreturn -EINVAL;\r\ndev = alloc_m_can_dev();\r\nif (!dev)\r\nreturn -ENOMEM;\r\npriv = netdev_priv(dev);\r\ndev->irq = irq;\r\npriv->base = addr;\r\npriv->device = &pdev->dev;\r\npriv->hclk = hclk;\r\npriv->cclk = cclk;\r\npriv->can.clock.freq = clk_get_rate(cclk);\r\nret = m_can_of_parse_mram(pdev, priv);\r\nif (ret)\r\ngoto failed_free_dev;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nret = register_m_can_dev(dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "registering %s failed (err=%d)\n",\r\nKBUILD_MODNAME, ret);\r\ngoto failed_free_dev;\r\n}\r\ndevm_can_led_init(dev);\r\ndev_info(&pdev->dev, "%s device registered (regs=%p, irq=%d)\n",\r\nKBUILD_MODNAME, priv->base, dev->irq);\r\nreturn 0;\r\nfailed_free_dev:\r\nfree_m_can_dev(dev);\r\nreturn ret;\r\n}\r\nstatic __maybe_unused int m_can_suspend(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct m_can_priv *priv = netdev_priv(ndev);\r\nif (netif_running(ndev)) {\r\nnetif_stop_queue(ndev);\r\nnetif_device_detach(ndev);\r\n}\r\npriv->can.state = CAN_STATE_SLEEPING;\r\nreturn 0;\r\n}\r\nstatic __maybe_unused int m_can_resume(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct m_can_priv *priv = netdev_priv(ndev);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (netif_running(ndev)) {\r\nnetif_device_attach(ndev);\r\nnetif_start_queue(ndev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void unregister_m_can_dev(struct net_device *dev)\r\n{\r\nunregister_candev(dev);\r\n}\r\nstatic int m_can_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nunregister_m_can_dev(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_m_can_dev(dev);\r\nreturn 0;\r\n}
