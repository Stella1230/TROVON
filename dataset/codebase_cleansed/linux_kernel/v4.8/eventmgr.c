static int pem_init(struct pp_eventmgr *eventmgr)\r\n{\r\nint result = 0;\r\nstruct pem_event_data event_data = { {0} };\r\npem_init_feature_info(eventmgr);\r\npem_init_event_action_chains(eventmgr);\r\nresult = pem_handle_event(eventmgr, AMD_PP_EVENT_INITIALIZE, &event_data);\r\nif (0 != result)\r\nreturn result;\r\nresult = pem_register_interrupts(eventmgr);\r\nreturn 0;\r\n}\r\nstatic void pem_fini(struct pp_eventmgr *eventmgr)\r\n{\r\nstruct pem_event_data event_data = { {0} };\r\npem_uninit_featureInfo(eventmgr);\r\npem_unregister_interrupts(eventmgr);\r\npem_handle_event(eventmgr, AMD_PP_EVENT_UNINITIALIZE, &event_data);\r\n}\r\nint eventmgr_init(struct pp_instance *handle)\r\n{\r\nint result = 0;\r\nstruct pp_eventmgr *eventmgr;\r\nif (handle == NULL)\r\nreturn -EINVAL;\r\neventmgr = kzalloc(sizeof(struct pp_eventmgr), GFP_KERNEL);\r\nif (eventmgr == NULL)\r\nreturn -ENOMEM;\r\neventmgr->hwmgr = handle->hwmgr;\r\nhandle->eventmgr = eventmgr;\r\neventmgr->platform_descriptor = &(eventmgr->hwmgr->platform_descriptor);\r\neventmgr->pp_eventmgr_init = pem_init;\r\neventmgr->pp_eventmgr_fini = pem_fini;\r\nreturn result;\r\n}\r\nint eventmgr_fini(struct pp_eventmgr *eventmgr)\r\n{\r\nkfree(eventmgr);\r\nreturn 0;\r\n}\r\nstatic int pem_handle_event_unlocked(struct pp_eventmgr *eventmgr, enum amd_pp_event event, struct pem_event_data *data)\r\n{\r\nif (eventmgr == NULL || event >= AMD_PP_EVENT_MAX || data == NULL)\r\nreturn -EINVAL;\r\nreturn pem_excute_event_chain(eventmgr, eventmgr->event_chain[event], data);\r\n}\r\nint pem_handle_event(struct pp_eventmgr *eventmgr, enum amd_pp_event event, struct pem_event_data *event_data)\r\n{\r\nint r = 0;\r\nr = pem_handle_event_unlocked(eventmgr, event, event_data);\r\nreturn r;\r\n}\r\nbool pem_is_hw_access_blocked(struct pp_eventmgr *eventmgr)\r\n{\r\nreturn (eventmgr->block_adjust_power_state || phm_is_hw_access_blocked(eventmgr->hwmgr));\r\n}
