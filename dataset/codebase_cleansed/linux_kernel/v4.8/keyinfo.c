static void derive_crypt_complete(struct crypto_async_request *req, int rc)\r\n{\r\nstruct fscrypt_completion_result *ecr = req->data;\r\nif (rc == -EINPROGRESS)\r\nreturn;\r\necr->res = rc;\r\ncomplete(&ecr->completion);\r\n}\r\nstatic int derive_key_aes(u8 deriving_key[FS_AES_128_ECB_KEY_SIZE],\r\nu8 source_key[FS_AES_256_XTS_KEY_SIZE],\r\nu8 derived_key[FS_AES_256_XTS_KEY_SIZE])\r\n{\r\nint res = 0;\r\nstruct skcipher_request *req = NULL;\r\nDECLARE_FS_COMPLETION_RESULT(ecr);\r\nstruct scatterlist src_sg, dst_sg;\r\nstruct crypto_skcipher *tfm = crypto_alloc_skcipher("ecb(aes)", 0, 0);\r\nif (IS_ERR(tfm)) {\r\nres = PTR_ERR(tfm);\r\ntfm = NULL;\r\ngoto out;\r\n}\r\ncrypto_skcipher_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);\r\nreq = skcipher_request_alloc(tfm, GFP_NOFS);\r\nif (!req) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nskcipher_request_set_callback(req,\r\nCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\r\nderive_crypt_complete, &ecr);\r\nres = crypto_skcipher_setkey(tfm, deriving_key,\r\nFS_AES_128_ECB_KEY_SIZE);\r\nif (res < 0)\r\ngoto out;\r\nsg_init_one(&src_sg, source_key, FS_AES_256_XTS_KEY_SIZE);\r\nsg_init_one(&dst_sg, derived_key, FS_AES_256_XTS_KEY_SIZE);\r\nskcipher_request_set_crypt(req, &src_sg, &dst_sg,\r\nFS_AES_256_XTS_KEY_SIZE, NULL);\r\nres = crypto_skcipher_encrypt(req);\r\nif (res == -EINPROGRESS || res == -EBUSY) {\r\nwait_for_completion(&ecr.completion);\r\nres = ecr.res;\r\n}\r\nout:\r\nskcipher_request_free(req);\r\ncrypto_free_skcipher(tfm);\r\nreturn res;\r\n}\r\nstatic int validate_user_key(struct fscrypt_info *crypt_info,\r\nstruct fscrypt_context *ctx, u8 *raw_key,\r\nu8 *prefix, int prefix_size)\r\n{\r\nu8 *full_key_descriptor;\r\nstruct key *keyring_key;\r\nstruct fscrypt_key *master_key;\r\nconst struct user_key_payload *ukp;\r\nint full_key_len = prefix_size + (FS_KEY_DESCRIPTOR_SIZE * 2) + 1;\r\nint res;\r\nfull_key_descriptor = kmalloc(full_key_len, GFP_NOFS);\r\nif (!full_key_descriptor)\r\nreturn -ENOMEM;\r\nmemcpy(full_key_descriptor, prefix, prefix_size);\r\nsprintf(full_key_descriptor + prefix_size,\r\n"%*phN", FS_KEY_DESCRIPTOR_SIZE,\r\nctx->master_key_descriptor);\r\nfull_key_descriptor[full_key_len - 1] = '\0';\r\nkeyring_key = request_key(&key_type_logon, full_key_descriptor, NULL);\r\nkfree(full_key_descriptor);\r\nif (IS_ERR(keyring_key))\r\nreturn PTR_ERR(keyring_key);\r\nif (keyring_key->type != &key_type_logon) {\r\nprintk_once(KERN_WARNING\r\n"%s: key type must be logon\n", __func__);\r\nres = -ENOKEY;\r\ngoto out;\r\n}\r\ndown_read(&keyring_key->sem);\r\nukp = user_key_payload(keyring_key);\r\nif (ukp->datalen != sizeof(struct fscrypt_key)) {\r\nres = -EINVAL;\r\nup_read(&keyring_key->sem);\r\ngoto out;\r\n}\r\nmaster_key = (struct fscrypt_key *)ukp->data;\r\nBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\r\nif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\r\nprintk_once(KERN_WARNING\r\n"%s: key size incorrect: %d\n",\r\n__func__, master_key->size);\r\nres = -ENOKEY;\r\nup_read(&keyring_key->sem);\r\ngoto out;\r\n}\r\nres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\r\nup_read(&keyring_key->sem);\r\nif (res)\r\ngoto out;\r\ncrypt_info->ci_keyring_key = keyring_key;\r\nreturn 0;\r\nout:\r\nkey_put(keyring_key);\r\nreturn res;\r\n}\r\nstatic void put_crypt_info(struct fscrypt_info *ci)\r\n{\r\nif (!ci)\r\nreturn;\r\nkey_put(ci->ci_keyring_key);\r\ncrypto_free_skcipher(ci->ci_ctfm);\r\nkmem_cache_free(fscrypt_info_cachep, ci);\r\n}\r\nint get_crypt_info(struct inode *inode)\r\n{\r\nstruct fscrypt_info *crypt_info;\r\nstruct fscrypt_context ctx;\r\nstruct crypto_skcipher *ctfm;\r\nconst char *cipher_str;\r\nu8 raw_key[FS_MAX_KEY_SIZE];\r\nu8 mode;\r\nint res;\r\nres = fscrypt_initialize();\r\nif (res)\r\nreturn res;\r\nif (!inode->i_sb->s_cop->get_context)\r\nreturn -EOPNOTSUPP;\r\nretry:\r\ncrypt_info = ACCESS_ONCE(inode->i_crypt_info);\r\nif (crypt_info) {\r\nif (!crypt_info->ci_keyring_key ||\r\nkey_validate(crypt_info->ci_keyring_key) == 0)\r\nreturn 0;\r\nfscrypt_put_encryption_info(inode, crypt_info);\r\ngoto retry;\r\n}\r\nres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\r\nif (res < 0) {\r\nif (!fscrypt_dummy_context_enabled(inode))\r\nreturn res;\r\nctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;\r\nctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;\r\nctx.flags = 0;\r\n} else if (res != sizeof(ctx)) {\r\nreturn -EINVAL;\r\n}\r\nres = 0;\r\ncrypt_info = kmem_cache_alloc(fscrypt_info_cachep, GFP_NOFS);\r\nif (!crypt_info)\r\nreturn -ENOMEM;\r\ncrypt_info->ci_flags = ctx.flags;\r\ncrypt_info->ci_data_mode = ctx.contents_encryption_mode;\r\ncrypt_info->ci_filename_mode = ctx.filenames_encryption_mode;\r\ncrypt_info->ci_ctfm = NULL;\r\ncrypt_info->ci_keyring_key = NULL;\r\nmemcpy(crypt_info->ci_master_key, ctx.master_key_descriptor,\r\nsizeof(crypt_info->ci_master_key));\r\nif (S_ISREG(inode->i_mode))\r\nmode = crypt_info->ci_data_mode;\r\nelse if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\r\nmode = crypt_info->ci_filename_mode;\r\nelse\r\nBUG();\r\nswitch (mode) {\r\ncase FS_ENCRYPTION_MODE_AES_256_XTS:\r\ncipher_str = "xts(aes)";\r\nbreak;\r\ncase FS_ENCRYPTION_MODE_AES_256_CTS:\r\ncipher_str = "cts(cbc(aes))";\r\nbreak;\r\ndefault:\r\nprintk_once(KERN_WARNING\r\n"%s: unsupported key mode %d (ino %u)\n",\r\n__func__, mode, (unsigned) inode->i_ino);\r\nres = -ENOKEY;\r\ngoto out;\r\n}\r\nif (fscrypt_dummy_context_enabled(inode)) {\r\nmemset(raw_key, 0x42, FS_AES_256_XTS_KEY_SIZE);\r\ngoto got_key;\r\n}\r\nres = validate_user_key(crypt_info, &ctx, raw_key,\r\nFS_KEY_DESC_PREFIX, FS_KEY_DESC_PREFIX_SIZE);\r\nif (res && inode->i_sb->s_cop->key_prefix) {\r\nu8 *prefix = NULL;\r\nint prefix_size, res2;\r\nprefix_size = inode->i_sb->s_cop->key_prefix(inode, &prefix);\r\nres2 = validate_user_key(crypt_info, &ctx, raw_key,\r\nprefix, prefix_size);\r\nif (res2) {\r\nif (res2 == -ENOKEY)\r\nres = -ENOKEY;\r\ngoto out;\r\n}\r\n} else if (res) {\r\ngoto out;\r\n}\r\ngot_key:\r\nctfm = crypto_alloc_skcipher(cipher_str, 0, 0);\r\nif (!ctfm || IS_ERR(ctfm)) {\r\nres = ctfm ? PTR_ERR(ctfm) : -ENOMEM;\r\nprintk(KERN_DEBUG\r\n"%s: error %d (inode %u) allocating crypto tfm\n",\r\n__func__, res, (unsigned) inode->i_ino);\r\ngoto out;\r\n}\r\ncrypt_info->ci_ctfm = ctfm;\r\ncrypto_skcipher_clear_flags(ctfm, ~0);\r\ncrypto_skcipher_set_flags(ctfm, CRYPTO_TFM_REQ_WEAK_KEY);\r\nres = crypto_skcipher_setkey(ctfm, raw_key, fscrypt_key_size(mode));\r\nif (res)\r\ngoto out;\r\nmemzero_explicit(raw_key, sizeof(raw_key));\r\nif (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) != NULL) {\r\nput_crypt_info(crypt_info);\r\ngoto retry;\r\n}\r\nreturn 0;\r\nout:\r\nif (res == -ENOKEY)\r\nres = 0;\r\nput_crypt_info(crypt_info);\r\nmemzero_explicit(raw_key, sizeof(raw_key));\r\nreturn res;\r\n}\r\nvoid fscrypt_put_encryption_info(struct inode *inode, struct fscrypt_info *ci)\r\n{\r\nstruct fscrypt_info *prev;\r\nif (ci == NULL)\r\nci = ACCESS_ONCE(inode->i_crypt_info);\r\nif (ci == NULL)\r\nreturn;\r\nprev = cmpxchg(&inode->i_crypt_info, ci, NULL);\r\nif (prev != ci)\r\nreturn;\r\nput_crypt_info(ci);\r\n}\r\nint fscrypt_get_encryption_info(struct inode *inode)\r\n{\r\nstruct fscrypt_info *ci = inode->i_crypt_info;\r\nif (!ci ||\r\n(ci->ci_keyring_key &&\r\n(ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\r\n(1 << KEY_FLAG_REVOKED) |\r\n(1 << KEY_FLAG_DEAD)))))\r\nreturn get_crypt_info(inode);\r\nreturn 0;\r\n}
