acpi_status\r\nacpi_ev_walk_gpe_list(acpi_gpe_callback gpe_walk_callback, void *context)\r\n{\r\nstruct acpi_gpe_block_info *gpe_block;\r\nstruct acpi_gpe_xrupt_info *gpe_xrupt_info;\r\nacpi_status status = AE_OK;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(ev_walk_gpe_list);\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;\r\nwhile (gpe_xrupt_info) {\r\ngpe_block = gpe_xrupt_info->gpe_block_list_head;\r\nwhile (gpe_block) {\r\nstatus =\r\ngpe_walk_callback(gpe_xrupt_info, gpe_block,\r\ncontext);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_CTRL_END) {\r\nstatus = AE_OK;\r\n}\r\ngoto unlock_and_exit;\r\n}\r\ngpe_block = gpe_block->next;\r\n}\r\ngpe_xrupt_info = gpe_xrupt_info->next;\r\n}\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ev_get_gpe_device(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\r\nstruct acpi_gpe_block_info *gpe_block, void *context)\r\n{\r\nstruct acpi_gpe_device_info *info = context;\r\ninfo->next_block_base_index += gpe_block->gpe_count;\r\nif (info->index < info->next_block_base_index) {\r\nif ((gpe_block->node)->type == ACPI_TYPE_DEVICE) {\r\ninfo->gpe_device = gpe_block->node;\r\n}\r\ninfo->status = AE_OK;\r\nreturn (AE_CTRL_END);\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_ev_get_gpe_xrupt_block(u32 interrupt_number,\r\nstruct acpi_gpe_xrupt_info **gpe_xrupt_block)\r\n{\r\nstruct acpi_gpe_xrupt_info *next_gpe_xrupt;\r\nstruct acpi_gpe_xrupt_info *gpe_xrupt;\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(ev_get_gpe_xrupt_block);\r\nnext_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;\r\nwhile (next_gpe_xrupt) {\r\nif (next_gpe_xrupt->interrupt_number == interrupt_number) {\r\n*gpe_xrupt_block = next_gpe_xrupt;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nnext_gpe_xrupt = next_gpe_xrupt->next;\r\n}\r\ngpe_xrupt = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_xrupt_info));\r\nif (!gpe_xrupt) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\ngpe_xrupt->interrupt_number = interrupt_number;\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\nif (acpi_gbl_gpe_xrupt_list_head) {\r\nnext_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;\r\nwhile (next_gpe_xrupt->next) {\r\nnext_gpe_xrupt = next_gpe_xrupt->next;\r\n}\r\nnext_gpe_xrupt->next = gpe_xrupt;\r\ngpe_xrupt->previous = next_gpe_xrupt;\r\n} else {\r\nacpi_gbl_gpe_xrupt_list_head = gpe_xrupt;\r\n}\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nif (interrupt_number != acpi_gbl_FADT.sci_interrupt) {\r\nstatus = acpi_os_install_interrupt_handler(interrupt_number,\r\nacpi_ev_gpe_xrupt_handler,\r\ngpe_xrupt);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Could not install GPE interrupt handler at level 0x%X",\r\ninterrupt_number));\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\n*gpe_xrupt_block = gpe_xrupt;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_ev_delete_gpe_xrupt(struct acpi_gpe_xrupt_info *gpe_xrupt)\r\n{\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(ev_delete_gpe_xrupt);\r\nif (gpe_xrupt->interrupt_number == acpi_gbl_FADT.sci_interrupt) {\r\ngpe_xrupt->gpe_block_list_head = NULL;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstatus =\r\nacpi_os_remove_interrupt_handler(gpe_xrupt->interrupt_number,\r\nacpi_ev_gpe_xrupt_handler);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\nif (gpe_xrupt->previous) {\r\ngpe_xrupt->previous->next = gpe_xrupt->next;\r\n} else {\r\nacpi_gbl_gpe_xrupt_list_head = gpe_xrupt->next;\r\n}\r\nif (gpe_xrupt->next) {\r\ngpe_xrupt->next->previous = gpe_xrupt->previous;\r\n}\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nACPI_FREE(gpe_xrupt);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\r\nstruct acpi_gpe_block_info *gpe_block,\r\nvoid *context)\r\n{\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nstruct acpi_gpe_notify_info *notify;\r\nstruct acpi_gpe_notify_info *next;\r\nu32 i;\r\nu32 j;\r\nACPI_FUNCTION_TRACE(ev_delete_gpe_handlers);\r\nfor (i = 0; i < gpe_block->register_count; i++) {\r\nfor (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {\r\ngpe_event_info = &gpe_block->event_info[((acpi_size)i *\r\nACPI_GPE_REGISTER_WIDTH)\r\n+ j];\r\nif ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_HANDLER) ||\r\n(ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_RAW_HANDLER)) {\r\nACPI_FREE(gpe_event_info->dispatch.handler);\r\ngpe_event_info->dispatch.handler = NULL;\r\ngpe_event_info->flags &=\r\n~ACPI_GPE_DISPATCH_MASK;\r\n} else if (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags)\r\n== ACPI_GPE_DISPATCH_NOTIFY) {\r\nnotify = gpe_event_info->dispatch.notify_list;\r\nwhile (notify) {\r\nnext = notify->next;\r\nACPI_FREE(notify);\r\nnotify = next;\r\n}\r\ngpe_event_info->dispatch.notify_list = NULL;\r\ngpe_event_info->flags &=\r\n~ACPI_GPE_DISPATCH_MASK;\r\n}\r\n}\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
