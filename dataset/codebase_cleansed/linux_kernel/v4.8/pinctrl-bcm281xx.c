static inline enum bcm281xx_pin_type pin_type_get(struct pinctrl_dev *pctldev,\r\nunsigned pin)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\nif (pin >= pdata->npins)\r\nreturn BCM281XX_PIN_TYPE_UNKNOWN;\r\nreturn *(enum bcm281xx_pin_type *)(pdata->pins[pin].drv_data);\r\n}\r\nstatic inline void bcm281xx_pin_update(u32 *reg_val, u32 *reg_mask,\r\nu32 param_val, u32 param_shift,\r\nu32 param_mask)\r\n{\r\n*reg_val &= ~param_mask;\r\n*reg_val |= (param_val << param_shift) & param_mask;\r\n*reg_mask |= param_mask;\r\n}\r\nstatic int bcm281xx_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pdata->npins;\r\n}\r\nstatic const char *bcm281xx_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pdata->pins[group].name;\r\n}\r\nstatic int bcm281xx_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = &pdata->pins[group].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic void bcm281xx_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, " %s", dev_name(pctldev->dev));\r\n}\r\nstatic int bcm281xx_pinctrl_get_fcns_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pdata->nfunctions;\r\n}\r\nstatic const char *bcm281xx_pinctrl_get_fcn_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pdata->functions[function].name;\r\n}\r\nstatic int bcm281xx_pinctrl_get_fcn_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pdata->functions[function].groups;\r\n*num_groups = pdata->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int bcm281xx_pinmux_set(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nunsigned group)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct bcm281xx_pin_function *f = &pdata->functions[function];\r\nu32 offset = 4 * pdata->pins[group].number;\r\nint rc = 0;\r\ndev_dbg(pctldev->dev,\r\n"%s(): Enable function %s (%d) of pin %s (%d) @offset 0x%x.\n",\r\n__func__, f->name, function, pdata->pins[group].name,\r\npdata->pins[group].number, offset);\r\nrc = regmap_update_bits(pdata->regmap, offset,\r\nBCM281XX_PIN_REG_F_SEL_MASK,\r\nfunction << BCM281XX_PIN_REG_F_SEL_SHIFT);\r\nif (rc)\r\ndev_err(pctldev->dev,\r\n"Error updating register for pin %s (%d).\n",\r\npdata->pins[group].name, pdata->pins[group].number);\r\nreturn rc;\r\n}\r\nstatic int bcm281xx_pinctrl_pin_config_get(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *config)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int bcm281xx_std_pin_update(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *configs,\r\nunsigned num_configs,\r\nu32 *val,\r\nu32 *mask)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\nint i;\r\nenum pin_config_param param;\r\nu16 arg;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\narg = (arg >= 1 ? 1 : 0);\r\nbcm281xx_pin_update(val, mask, arg,\r\nBCM281XX_PIN_SHIFT(STD, HYST),\r\nBCM281XX_PIN_MASK(STD, HYST));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nbcm281xx_pin_update(val, mask, 0,\r\nBCM281XX_PIN_SHIFT(STD, PULL_UP),\r\nBCM281XX_PIN_MASK(STD, PULL_UP));\r\nbcm281xx_pin_update(val, mask, 0,\r\nBCM281XX_PIN_SHIFT(STD, PULL_DN),\r\nBCM281XX_PIN_MASK(STD, PULL_DN));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nbcm281xx_pin_update(val, mask, 1,\r\nBCM281XX_PIN_SHIFT(STD, PULL_UP),\r\nBCM281XX_PIN_MASK(STD, PULL_UP));\r\nbcm281xx_pin_update(val, mask, 0,\r\nBCM281XX_PIN_SHIFT(STD, PULL_DN),\r\nBCM281XX_PIN_MASK(STD, PULL_DN));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nbcm281xx_pin_update(val, mask, 0,\r\nBCM281XX_PIN_SHIFT(STD, PULL_UP),\r\nBCM281XX_PIN_MASK(STD, PULL_UP));\r\nbcm281xx_pin_update(val, mask, 1,\r\nBCM281XX_PIN_SHIFT(STD, PULL_DN),\r\nBCM281XX_PIN_MASK(STD, PULL_DN));\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\narg = (arg >= 1 ? 1 : 0);\r\nbcm281xx_pin_update(val, mask, arg,\r\nBCM281XX_PIN_SHIFT(STD, SLEW),\r\nBCM281XX_PIN_MASK(STD, SLEW));\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\narg = (arg >= 1 ? 0 : 1);\r\nbcm281xx_pin_update(val, mask, arg,\r\nBCM281XX_PIN_SHIFT(STD, INPUT_DIS),\r\nBCM281XX_PIN_MASK(STD, INPUT_DIS));\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nif ((arg < 2) || (arg > 16) || (arg % 2)) {\r\ndev_err(pctldev->dev,\r\n"Invalid Drive Strength value (%d) for "\r\n"pin %s (%d). Valid values are "\r\n"(2..16) mA, even numbers only.\n",\r\narg, pdata->pins[pin].name, pin);\r\nreturn -EINVAL;\r\n}\r\nbcm281xx_pin_update(val, mask, (arg/2)-1,\r\nBCM281XX_PIN_SHIFT(STD, DRV_STR),\r\nBCM281XX_PIN_MASK(STD, DRV_STR));\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev,\r\n"Unrecognized pin config %d for pin %s (%d).\n",\r\nparam, pdata->pins[pin].name, pin);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm281xx_i2c_pin_update(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *configs,\r\nunsigned num_configs,\r\nu32 *val,\r\nu32 *mask)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\nint i, j;\r\nenum pin_config_param param;\r\nu16 arg;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nfor (j = 0; j < ARRAY_SIZE(bcm281xx_pullup_map); j++)\r\nif (bcm281xx_pullup_map[j] == arg)\r\nbreak;\r\nif (j == ARRAY_SIZE(bcm281xx_pullup_map)) {\r\ndev_err(pctldev->dev,\r\n"Invalid pull-up value (%d) for pin %s "\r\n"(%d). Valid values are 568, 720, 831, "\r\n"1080, 1200, 1800, 2700 Ohms.\n",\r\narg, pdata->pins[pin].name, pin);\r\nreturn -EINVAL;\r\n}\r\nbcm281xx_pin_update(val, mask, j+1,\r\nBCM281XX_PIN_SHIFT(I2C, PULL_UP_STR),\r\nBCM281XX_PIN_MASK(I2C, PULL_UP_STR));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nbcm281xx_pin_update(val, mask, 0,\r\nBCM281XX_PIN_SHIFT(I2C, PULL_UP_STR),\r\nBCM281XX_PIN_MASK(I2C, PULL_UP_STR));\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\narg = (arg >= 1 ? 1 : 0);\r\nbcm281xx_pin_update(val, mask, arg,\r\nBCM281XX_PIN_SHIFT(I2C, SLEW),\r\nBCM281XX_PIN_MASK(I2C, SLEW));\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\narg = (arg >= 1 ? 0 : 1);\r\nbcm281xx_pin_update(val, mask, arg,\r\nBCM281XX_PIN_SHIFT(I2C, INPUT_DIS),\r\nBCM281XX_PIN_MASK(I2C, INPUT_DIS));\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev,\r\n"Unrecognized pin config %d for pin %s (%d).\n",\r\nparam, pdata->pins[pin].name, pin);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm281xx_hdmi_pin_update(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *configs,\r\nunsigned num_configs,\r\nu32 *val,\r\nu32 *mask)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\nint i;\r\nenum pin_config_param param;\r\nu16 arg;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_SLEW_RATE:\r\narg = (arg >= 1 ? 1 : 0);\r\nbcm281xx_pin_update(val, mask, arg,\r\nBCM281XX_PIN_SHIFT(HDMI, MODE),\r\nBCM281XX_PIN_MASK(HDMI, MODE));\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\narg = (arg >= 1 ? 0 : 1);\r\nbcm281xx_pin_update(val, mask, arg,\r\nBCM281XX_PIN_SHIFT(HDMI, INPUT_DIS),\r\nBCM281XX_PIN_MASK(HDMI, INPUT_DIS));\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev,\r\n"Unrecognized pin config %d for pin %s (%d).\n",\r\nparam, pdata->pins[pin].name, pin);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm281xx_pinctrl_pin_config_set(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\r\nenum bcm281xx_pin_type pin_type;\r\nu32 offset = 4 * pin;\r\nu32 cfg_val, cfg_mask;\r\nint rc;\r\ncfg_val = 0;\r\ncfg_mask = 0;\r\npin_type = pin_type_get(pctldev, pin);\r\nswitch (pin_type) {\r\ncase BCM281XX_PIN_TYPE_STD:\r\nrc = bcm281xx_std_pin_update(pctldev, pin, configs,\r\nnum_configs, &cfg_val, &cfg_mask);\r\nbreak;\r\ncase BCM281XX_PIN_TYPE_I2C:\r\nrc = bcm281xx_i2c_pin_update(pctldev, pin, configs,\r\nnum_configs, &cfg_val, &cfg_mask);\r\nbreak;\r\ncase BCM281XX_PIN_TYPE_HDMI:\r\nrc = bcm281xx_hdmi_pin_update(pctldev, pin, configs,\r\nnum_configs, &cfg_val, &cfg_mask);\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev, "Unknown pin type for pin %s (%d).\n",\r\npdata->pins[pin].name, pin);\r\nreturn -EINVAL;\r\n}\r\nif (rc)\r\nreturn rc;\r\ndev_dbg(pctldev->dev,\r\n"%s(): Set pin %s (%d) with config 0x%x, mask 0x%x\n",\r\n__func__, pdata->pins[pin].name, pin, cfg_val, cfg_mask);\r\nrc = regmap_update_bits(pdata->regmap, offset, cfg_mask, cfg_val);\r\nif (rc) {\r\ndev_err(pctldev->dev,\r\n"Error updating register for pin %s (%d).\n",\r\npdata->pins[pin].name, pin);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init bcm281xx_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct bcm281xx_pinctrl_data *pdata = &bcm281xx_pinctrl;\r\nstruct resource *res;\r\nstruct pinctrl_dev *pctl;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npdata->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pdata->reg_base)) {\r\ndev_err(&pdev->dev, "Failed to ioremap MEM resource\n");\r\nreturn -ENODEV;\r\n}\r\npdata->regmap = devm_regmap_init_mmio(&pdev->dev, pdata->reg_base,\r\n&bcm281xx_pinctrl_regmap_config);\r\nif (IS_ERR(pdata->regmap)) {\r\ndev_err(&pdev->dev, "Regmap MMIO init failed.\n");\r\nreturn -ENODEV;\r\n}\r\nbcm281xx_pinctrl_desc.name = dev_name(&pdev->dev);\r\nbcm281xx_pinctrl_desc.pins = bcm281xx_pinctrl.pins;\r\nbcm281xx_pinctrl_desc.npins = bcm281xx_pinctrl.npins;\r\npctl = devm_pinctrl_register(&pdev->dev, &bcm281xx_pinctrl_desc, pdata);\r\nif (IS_ERR(pctl)) {\r\ndev_err(&pdev->dev, "Failed to register pinctrl\n");\r\nreturn PTR_ERR(pctl);\r\n}\r\nplatform_set_drvdata(pdev, pdata);\r\nreturn 0;\r\n}
