static int read_peer_guid(u64 *guid, const struct sbp_management_request *req)\r\n{\r\nint ret;\r\n__be32 high, low;\r\nret = sbp_run_transaction(req->card, TCODE_READ_QUADLET_REQUEST,\r\nreq->node_addr, req->generation, req->speed,\r\n(CSR_REGISTER_BASE | CSR_CONFIG_ROM) + 3 * 4,\r\n&high, sizeof(high));\r\nif (ret != RCODE_COMPLETE)\r\nreturn ret;\r\nret = sbp_run_transaction(req->card, TCODE_READ_QUADLET_REQUEST,\r\nreq->node_addr, req->generation, req->speed,\r\n(CSR_REGISTER_BASE | CSR_CONFIG_ROM) + 4 * 4,\r\n&low, sizeof(low));\r\nif (ret != RCODE_COMPLETE)\r\nreturn ret;\r\n*guid = (u64)be32_to_cpu(high) << 32 | be32_to_cpu(low);\r\nreturn RCODE_COMPLETE;\r\n}\r\nstatic struct sbp_session *sbp_session_find_by_guid(\r\nstruct sbp_tpg *tpg, u64 guid)\r\n{\r\nstruct se_session *se_sess;\r\nstruct sbp_session *sess, *found = NULL;\r\nspin_lock_bh(&tpg->se_tpg.session_lock);\r\nlist_for_each_entry(se_sess, &tpg->se_tpg.tpg_sess_list, sess_list) {\r\nsess = se_sess->fabric_sess_ptr;\r\nif (sess->guid == guid)\r\nfound = sess;\r\n}\r\nspin_unlock_bh(&tpg->se_tpg.session_lock);\r\nreturn found;\r\n}\r\nstatic struct sbp_login_descriptor *sbp_login_find_by_lun(\r\nstruct sbp_session *session, u32 unpacked_lun)\r\n{\r\nstruct sbp_login_descriptor *login, *found = NULL;\r\nspin_lock_bh(&session->lock);\r\nlist_for_each_entry(login, &session->login_list, link) {\r\nif (login->login_lun == unpacked_lun)\r\nfound = login;\r\n}\r\nspin_unlock_bh(&session->lock);\r\nreturn found;\r\n}\r\nstatic int sbp_login_count_all_by_lun(\r\nstruct sbp_tpg *tpg,\r\nu32 unpacked_lun,\r\nint exclusive)\r\n{\r\nstruct se_session *se_sess;\r\nstruct sbp_session *sess;\r\nstruct sbp_login_descriptor *login;\r\nint count = 0;\r\nspin_lock_bh(&tpg->se_tpg.session_lock);\r\nlist_for_each_entry(se_sess, &tpg->se_tpg.tpg_sess_list, sess_list) {\r\nsess = se_sess->fabric_sess_ptr;\r\nspin_lock_bh(&sess->lock);\r\nlist_for_each_entry(login, &sess->login_list, link) {\r\nif (login->login_lun != unpacked_lun)\r\ncontinue;\r\nif (!exclusive || login->exclusive)\r\ncount++;\r\n}\r\nspin_unlock_bh(&sess->lock);\r\n}\r\nspin_unlock_bh(&tpg->se_tpg.session_lock);\r\nreturn count;\r\n}\r\nstatic struct sbp_login_descriptor *sbp_login_find_by_id(\r\nstruct sbp_tpg *tpg, int login_id)\r\n{\r\nstruct se_session *se_sess;\r\nstruct sbp_session *sess;\r\nstruct sbp_login_descriptor *login, *found = NULL;\r\nspin_lock_bh(&tpg->se_tpg.session_lock);\r\nlist_for_each_entry(se_sess, &tpg->se_tpg.tpg_sess_list, sess_list) {\r\nsess = se_sess->fabric_sess_ptr;\r\nspin_lock_bh(&sess->lock);\r\nlist_for_each_entry(login, &sess->login_list, link) {\r\nif (login->login_id == login_id)\r\nfound = login;\r\n}\r\nspin_unlock_bh(&sess->lock);\r\n}\r\nspin_unlock_bh(&tpg->se_tpg.session_lock);\r\nreturn found;\r\n}\r\nstatic u32 sbp_get_lun_from_tpg(struct sbp_tpg *tpg, u32 login_lun, int *err)\r\n{\r\nstruct se_portal_group *se_tpg = &tpg->se_tpg;\r\nstruct se_lun *se_lun;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(se_lun, &se_tpg->tpg_lun_hlist, link) {\r\nif (se_lun->unpacked_lun == login_lun) {\r\nrcu_read_unlock();\r\n*err = 0;\r\nreturn login_lun;\r\n}\r\n}\r\nrcu_read_unlock();\r\n*err = -ENODEV;\r\nreturn login_lun;\r\n}\r\nstatic struct sbp_session *sbp_session_create(\r\nstruct sbp_tpg *tpg,\r\nu64 guid)\r\n{\r\nstruct sbp_session *sess;\r\nint ret;\r\nchar guid_str[17];\r\nsnprintf(guid_str, sizeof(guid_str), "%016llx", guid);\r\nsess = kmalloc(sizeof(*sess), GFP_KERNEL);\r\nif (!sess) {\r\npr_err("failed to allocate session descriptor\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nspin_lock_init(&sess->lock);\r\nINIT_LIST_HEAD(&sess->login_list);\r\nINIT_DELAYED_WORK(&sess->maint_work, session_maintenance_work);\r\nsess->guid = guid;\r\nsess->se_sess = target_alloc_session(&tpg->se_tpg, 128,\r\nsizeof(struct sbp_target_request),\r\nTARGET_PROT_NORMAL, guid_str,\r\nsess, NULL);\r\nif (IS_ERR(sess->se_sess)) {\r\npr_err("failed to init se_session\n");\r\nret = PTR_ERR(sess->se_sess);\r\nkfree(sess);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn sess;\r\n}\r\nstatic void sbp_session_release(struct sbp_session *sess, bool cancel_work)\r\n{\r\nspin_lock_bh(&sess->lock);\r\nif (!list_empty(&sess->login_list)) {\r\nspin_unlock_bh(&sess->lock);\r\nreturn;\r\n}\r\nspin_unlock_bh(&sess->lock);\r\nif (cancel_work)\r\ncancel_delayed_work_sync(&sess->maint_work);\r\ntransport_deregister_session_configfs(sess->se_sess);\r\ntransport_deregister_session(sess->se_sess);\r\nif (sess->card)\r\nfw_card_put(sess->card);\r\nkfree(sess);\r\n}\r\nstatic void sbp_login_release(struct sbp_login_descriptor *login,\r\nbool cancel_work)\r\n{\r\nstruct sbp_session *sess = login->sess;\r\nsbp_target_agent_unregister(login->tgt_agt);\r\nif (sess) {\r\nspin_lock_bh(&sess->lock);\r\nlist_del(&login->link);\r\nspin_unlock_bh(&sess->lock);\r\nsbp_session_release(sess, cancel_work);\r\n}\r\nkfree(login);\r\n}\r\nstatic void sbp_management_request_login(\r\nstruct sbp_management_agent *agent, struct sbp_management_request *req,\r\nint *status_data_size)\r\n{\r\nstruct sbp_tport *tport = agent->tport;\r\nstruct sbp_tpg *tpg = tport->tpg;\r\nstruct sbp_session *sess;\r\nstruct sbp_login_descriptor *login;\r\nstruct sbp_login_response_block *response;\r\nu64 guid;\r\nu32 unpacked_lun;\r\nint login_response_len, ret;\r\nunpacked_lun = sbp_get_lun_from_tpg(tpg,\r\nLOGIN_ORB_LUN(be32_to_cpu(req->orb.misc)), &ret);\r\nif (ret) {\r\npr_notice("login to unknown LUN: %d\n",\r\nLOGIN_ORB_LUN(be32_to_cpu(req->orb.misc)));\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_LUN_NOTSUPP));\r\nreturn;\r\n}\r\nret = read_peer_guid(&guid, req);\r\nif (ret != RCODE_COMPLETE) {\r\npr_warn("failed to read peer GUID: %d\n", ret);\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_TRANSPORT_FAILURE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_UNSPECIFIED_ERROR));\r\nreturn;\r\n}\r\npr_notice("mgt_agent LOGIN to LUN %d from %016llx\n",\r\nunpacked_lun, guid);\r\nsess = sbp_session_find_by_guid(tpg, guid);\r\nif (sess) {\r\nlogin = sbp_login_find_by_lun(sess, unpacked_lun);\r\nif (login) {\r\npr_notice("initiator already logged-in\n");\r\ngoto already_logged_in;\r\n}\r\n}\r\nif (LOGIN_ORB_EXCLUSIVE(be32_to_cpu(req->orb.misc)) &&\r\nsbp_login_count_all_by_lun(tpg, unpacked_lun, 0)) {\r\npr_warn("refusing exclusive login with other active logins\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_ACCESS_DENIED));\r\nreturn;\r\n}\r\nif (sbp_login_count_all_by_lun(tpg, unpacked_lun, 1)) {\r\npr_warn("refusing login while another exclusive login present\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_ACCESS_DENIED));\r\nreturn;\r\n}\r\nif (sbp_login_count_all_by_lun(tpg, unpacked_lun, 0) >=\r\ntport->max_logins_per_lun) {\r\npr_warn("max number of logins reached\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_RESOURCES_UNAVAIL));\r\nreturn;\r\n}\r\nif (!sess) {\r\nsess = sbp_session_create(tpg, guid);\r\nif (IS_ERR(sess)) {\r\nswitch (PTR_ERR(sess)) {\r\ncase -EPERM:\r\nret = SBP_STATUS_ACCESS_DENIED;\r\nbreak;\r\ndefault:\r\nret = SBP_STATUS_RESOURCES_UNAVAIL;\r\nbreak;\r\n}\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(\r\nSTATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(ret));\r\nreturn;\r\n}\r\nsess->node_id = req->node_addr;\r\nsess->card = fw_card_get(req->card);\r\nsess->generation = req->generation;\r\nsess->speed = req->speed;\r\nschedule_delayed_work(&sess->maint_work,\r\nSESSION_MAINTENANCE_INTERVAL);\r\n}\r\nsess->reconnect_hold = min(\r\n1 << LOGIN_ORB_RECONNECT(be32_to_cpu(req->orb.misc)),\r\ntport->max_reconnect_timeout) - 1;\r\nlogin = kmalloc(sizeof(*login), GFP_KERNEL);\r\nif (!login) {\r\npr_err("failed to allocate login descriptor\n");\r\nsbp_session_release(sess, true);\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_RESOURCES_UNAVAIL));\r\nreturn;\r\n}\r\nlogin->sess = sess;\r\nlogin->login_lun = unpacked_lun;\r\nlogin->status_fifo_addr = sbp2_pointer_to_addr(&req->orb.status_fifo);\r\nlogin->exclusive = LOGIN_ORB_EXCLUSIVE(be32_to_cpu(req->orb.misc));\r\nlogin->login_id = atomic_inc_return(&login_id);\r\nlogin->tgt_agt = sbp_target_agent_register(login);\r\nif (IS_ERR(login->tgt_agt)) {\r\nret = PTR_ERR(login->tgt_agt);\r\npr_err("failed to map command block handler: %d\n", ret);\r\nsbp_session_release(sess, true);\r\nkfree(login);\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_RESOURCES_UNAVAIL));\r\nreturn;\r\n}\r\nspin_lock_bh(&sess->lock);\r\nlist_add_tail(&login->link, &sess->login_list);\r\nspin_unlock_bh(&sess->lock);\r\nalready_logged_in:\r\nresponse = kzalloc(sizeof(*response), GFP_KERNEL);\r\nif (!response) {\r\npr_err("failed to allocate login response block\n");\r\nsbp_login_release(login, true);\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_RESOURCES_UNAVAIL));\r\nreturn;\r\n}\r\nlogin_response_len = clamp_val(\r\nLOGIN_ORB_RESPONSE_LENGTH(be32_to_cpu(req->orb.length)),\r\n12, sizeof(*response));\r\nresponse->misc = cpu_to_be32(\r\n((login_response_len & 0xffff) << 16) |\r\n(login->login_id & 0xffff));\r\nresponse->reconnect_hold = cpu_to_be32(sess->reconnect_hold & 0xffff);\r\naddr_to_sbp2_pointer(login->tgt_agt->handler.offset,\r\n&response->command_block_agent);\r\nret = sbp_run_transaction(sess->card, TCODE_WRITE_BLOCK_REQUEST,\r\nsess->node_id, sess->generation, sess->speed,\r\nsbp2_pointer_to_addr(&req->orb.ptr2), response,\r\nlogin_response_len);\r\nif (ret != RCODE_COMPLETE) {\r\npr_debug("failed to write login response block: %x\n", ret);\r\nkfree(response);\r\nsbp_login_release(login, true);\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_TRANSPORT_FAILURE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_UNSPECIFIED_ERROR));\r\nreturn;\r\n}\r\nkfree(response);\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_OK));\r\n}\r\nstatic void sbp_management_request_query_logins(\r\nstruct sbp_management_agent *agent, struct sbp_management_request *req,\r\nint *status_data_size)\r\n{\r\npr_notice("QUERY LOGINS not implemented\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\r\n}\r\nstatic void sbp_management_request_reconnect(\r\nstruct sbp_management_agent *agent, struct sbp_management_request *req,\r\nint *status_data_size)\r\n{\r\nstruct sbp_tport *tport = agent->tport;\r\nstruct sbp_tpg *tpg = tport->tpg;\r\nint ret;\r\nu64 guid;\r\nstruct sbp_login_descriptor *login;\r\nret = read_peer_guid(&guid, req);\r\nif (ret != RCODE_COMPLETE) {\r\npr_warn("failed to read peer GUID: %d\n", ret);\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_TRANSPORT_FAILURE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_UNSPECIFIED_ERROR));\r\nreturn;\r\n}\r\npr_notice("mgt_agent RECONNECT from %016llx\n", guid);\r\nlogin = sbp_login_find_by_id(tpg,\r\nRECONNECT_ORB_LOGIN_ID(be32_to_cpu(req->orb.misc)));\r\nif (!login) {\r\npr_err("mgt_agent RECONNECT unknown login ID\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_ACCESS_DENIED));\r\nreturn;\r\n}\r\nif (login->sess->guid != guid) {\r\npr_err("mgt_agent RECONNECT login GUID doesn't match\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_ACCESS_DENIED));\r\nreturn;\r\n}\r\nspin_lock_bh(&login->sess->lock);\r\nif (login->sess->card)\r\nfw_card_put(login->sess->card);\r\nlogin->sess->generation = req->generation;\r\nlogin->sess->node_id = req->node_addr;\r\nlogin->sess->card = fw_card_get(req->card);\r\nlogin->sess->speed = req->speed;\r\nspin_unlock_bh(&login->sess->lock);\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_OK));\r\n}\r\nstatic void sbp_management_request_logout(\r\nstruct sbp_management_agent *agent, struct sbp_management_request *req,\r\nint *status_data_size)\r\n{\r\nstruct sbp_tport *tport = agent->tport;\r\nstruct sbp_tpg *tpg = tport->tpg;\r\nint id;\r\nstruct sbp_login_descriptor *login;\r\nid = LOGOUT_ORB_LOGIN_ID(be32_to_cpu(req->orb.misc));\r\nlogin = sbp_login_find_by_id(tpg, id);\r\nif (!login) {\r\npr_warn("cannot find login: %d\n", id);\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_LOGIN_ID_UNKNOWN));\r\nreturn;\r\n}\r\npr_info("mgt_agent LOGOUT from LUN %d session %d\n",\r\nlogin->login_lun, login->login_id);\r\nif (req->node_addr != login->sess->node_id) {\r\npr_warn("logout from different node ID\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_ACCESS_DENIED));\r\nreturn;\r\n}\r\nsbp_login_release(login, true);\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_OK));\r\n}\r\nstatic void session_check_for_reset(struct sbp_session *sess)\r\n{\r\nbool card_valid = false;\r\nspin_lock_bh(&sess->lock);\r\nif (sess->card) {\r\nspin_lock_irq(&sess->card->lock);\r\ncard_valid = (sess->card->local_node != NULL);\r\nspin_unlock_irq(&sess->card->lock);\r\nif (!card_valid) {\r\nfw_card_put(sess->card);\r\nsess->card = NULL;\r\n}\r\n}\r\nif (!card_valid || (sess->generation != sess->card->generation)) {\r\npr_info("Waiting for reconnect from node: %016llx\n",\r\nsess->guid);\r\nsess->node_id = -1;\r\nsess->reconnect_expires = get_jiffies_64() +\r\n((sess->reconnect_hold + 1) * HZ);\r\n}\r\nspin_unlock_bh(&sess->lock);\r\n}\r\nstatic void session_reconnect_expired(struct sbp_session *sess)\r\n{\r\nstruct sbp_login_descriptor *login, *temp;\r\nLIST_HEAD(login_list);\r\npr_info("Reconnect timer expired for node: %016llx\n", sess->guid);\r\nspin_lock_bh(&sess->lock);\r\nlist_for_each_entry_safe(login, temp, &sess->login_list, link) {\r\nlogin->sess = NULL;\r\nlist_move_tail(&login->link, &login_list);\r\n}\r\nspin_unlock_bh(&sess->lock);\r\nlist_for_each_entry_safe(login, temp, &login_list, link) {\r\nlist_del(&login->link);\r\nsbp_login_release(login, false);\r\n}\r\nsbp_session_release(sess, false);\r\n}\r\nstatic void session_maintenance_work(struct work_struct *work)\r\n{\r\nstruct sbp_session *sess = container_of(work, struct sbp_session,\r\nmaint_work.work);\r\nspin_lock_bh(&sess->lock);\r\nif (list_empty(&sess->login_list)) {\r\nspin_unlock_bh(&sess->lock);\r\nreturn;\r\n}\r\nspin_unlock_bh(&sess->lock);\r\nif (sess->node_id != -1) {\r\nsession_check_for_reset(sess);\r\nschedule_delayed_work(&sess->maint_work,\r\nSESSION_MAINTENANCE_INTERVAL);\r\n} else if (!time_after64(get_jiffies_64(), sess->reconnect_expires)) {\r\nschedule_delayed_work(&sess->maint_work,\r\nSESSION_MAINTENANCE_INTERVAL);\r\n} else {\r\nsession_reconnect_expired(sess);\r\n}\r\n}\r\nstatic int tgt_agent_rw_agent_state(struct fw_card *card, int tcode, void *data,\r\nstruct sbp_target_agent *agent)\r\n{\r\nint state;\r\nswitch (tcode) {\r\ncase TCODE_READ_QUADLET_REQUEST:\r\npr_debug("tgt_agent AGENT_STATE READ\n");\r\nspin_lock_bh(&agent->lock);\r\nstate = agent->state;\r\nspin_unlock_bh(&agent->lock);\r\n*(__be32 *)data = cpu_to_be32(state);\r\nreturn RCODE_COMPLETE;\r\ncase TCODE_WRITE_QUADLET_REQUEST:\r\nreturn RCODE_COMPLETE;\r\ndefault:\r\nreturn RCODE_TYPE_ERROR;\r\n}\r\n}\r\nstatic int tgt_agent_rw_agent_reset(struct fw_card *card, int tcode, void *data,\r\nstruct sbp_target_agent *agent)\r\n{\r\nswitch (tcode) {\r\ncase TCODE_WRITE_QUADLET_REQUEST:\r\npr_debug("tgt_agent AGENT_RESET\n");\r\nspin_lock_bh(&agent->lock);\r\nagent->state = AGENT_STATE_RESET;\r\nspin_unlock_bh(&agent->lock);\r\nreturn RCODE_COMPLETE;\r\ndefault:\r\nreturn RCODE_TYPE_ERROR;\r\n}\r\n}\r\nstatic int tgt_agent_rw_orb_pointer(struct fw_card *card, int tcode, void *data,\r\nstruct sbp_target_agent *agent)\r\n{\r\nstruct sbp2_pointer *ptr = data;\r\nswitch (tcode) {\r\ncase TCODE_WRITE_BLOCK_REQUEST:\r\nspin_lock_bh(&agent->lock);\r\nif (agent->state != AGENT_STATE_SUSPENDED &&\r\nagent->state != AGENT_STATE_RESET) {\r\nspin_unlock_bh(&agent->lock);\r\npr_notice("Ignoring ORB_POINTER write while active.\n");\r\nreturn RCODE_CONFLICT_ERROR;\r\n}\r\nagent->state = AGENT_STATE_ACTIVE;\r\nspin_unlock_bh(&agent->lock);\r\nagent->orb_pointer = sbp2_pointer_to_addr(ptr);\r\nagent->doorbell = false;\r\npr_debug("tgt_agent ORB_POINTER write: 0x%llx\n",\r\nagent->orb_pointer);\r\nqueue_work(system_unbound_wq, &agent->work);\r\nreturn RCODE_COMPLETE;\r\ncase TCODE_READ_BLOCK_REQUEST:\r\npr_debug("tgt_agent ORB_POINTER READ\n");\r\nspin_lock_bh(&agent->lock);\r\naddr_to_sbp2_pointer(agent->orb_pointer, ptr);\r\nspin_unlock_bh(&agent->lock);\r\nreturn RCODE_COMPLETE;\r\ndefault:\r\nreturn RCODE_TYPE_ERROR;\r\n}\r\n}\r\nstatic int tgt_agent_rw_doorbell(struct fw_card *card, int tcode, void *data,\r\nstruct sbp_target_agent *agent)\r\n{\r\nswitch (tcode) {\r\ncase TCODE_WRITE_QUADLET_REQUEST:\r\nspin_lock_bh(&agent->lock);\r\nif (agent->state != AGENT_STATE_SUSPENDED) {\r\nspin_unlock_bh(&agent->lock);\r\npr_debug("Ignoring DOORBELL while active.\n");\r\nreturn RCODE_CONFLICT_ERROR;\r\n}\r\nagent->state = AGENT_STATE_ACTIVE;\r\nspin_unlock_bh(&agent->lock);\r\nagent->doorbell = true;\r\npr_debug("tgt_agent DOORBELL\n");\r\nqueue_work(system_unbound_wq, &agent->work);\r\nreturn RCODE_COMPLETE;\r\ncase TCODE_READ_QUADLET_REQUEST:\r\nreturn RCODE_COMPLETE;\r\ndefault:\r\nreturn RCODE_TYPE_ERROR;\r\n}\r\n}\r\nstatic int tgt_agent_rw_unsolicited_status_enable(struct fw_card *card,\r\nint tcode, void *data, struct sbp_target_agent *agent)\r\n{\r\nswitch (tcode) {\r\ncase TCODE_WRITE_QUADLET_REQUEST:\r\npr_debug("tgt_agent UNSOLICITED_STATUS_ENABLE\n");\r\nreturn RCODE_COMPLETE;\r\ncase TCODE_READ_QUADLET_REQUEST:\r\nreturn RCODE_COMPLETE;\r\ndefault:\r\nreturn RCODE_TYPE_ERROR;\r\n}\r\n}\r\nstatic void tgt_agent_rw(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source, int generation,\r\nunsigned long long offset, void *data, size_t length,\r\nvoid *callback_data)\r\n{\r\nstruct sbp_target_agent *agent = callback_data;\r\nstruct sbp_session *sess = agent->login->sess;\r\nint sess_gen, sess_node, rcode;\r\nspin_lock_bh(&sess->lock);\r\nsess_gen = sess->generation;\r\nsess_node = sess->node_id;\r\nspin_unlock_bh(&sess->lock);\r\nif (generation != sess_gen) {\r\npr_notice("ignoring request with wrong generation\n");\r\nrcode = RCODE_TYPE_ERROR;\r\ngoto out;\r\n}\r\nif (source != sess_node) {\r\npr_notice("ignoring request from foreign node (%x != %x)\n",\r\nsource, sess_node);\r\nrcode = RCODE_TYPE_ERROR;\r\ngoto out;\r\n}\r\noffset -= agent->handler.offset;\r\nif (offset == 0x00 && length == 4) {\r\nrcode = tgt_agent_rw_agent_state(card, tcode, data, agent);\r\n} else if (offset == 0x04 && length == 4) {\r\nrcode = tgt_agent_rw_agent_reset(card, tcode, data, agent);\r\n} else if (offset == 0x08 && length == 8) {\r\nrcode = tgt_agent_rw_orb_pointer(card, tcode, data, agent);\r\n} else if (offset == 0x10 && length == 4) {\r\nrcode = tgt_agent_rw_doorbell(card, tcode, data, agent);\r\n} else if (offset == 0x14 && length == 4) {\r\nrcode = tgt_agent_rw_unsolicited_status_enable(card, tcode,\r\ndata, agent);\r\n} else {\r\nrcode = RCODE_ADDRESS_ERROR;\r\n}\r\nout:\r\nfw_send_response(card, request, rcode);\r\n}\r\nstatic void tgt_agent_process_work(struct work_struct *work)\r\n{\r\nstruct sbp_target_request *req =\r\ncontainer_of(work, struct sbp_target_request, work);\r\npr_debug("tgt_orb ptr:0x%llx next_ORB:0x%llx data_descriptor:0x%llx misc:0x%x\n",\r\nreq->orb_pointer,\r\nsbp2_pointer_to_addr(&req->orb.next_orb),\r\nsbp2_pointer_to_addr(&req->orb.data_descriptor),\r\nbe32_to_cpu(req->orb.misc));\r\nif (req->orb_pointer >> 32)\r\npr_debug("ORB with high bits set\n");\r\nswitch (ORB_REQUEST_FORMAT(be32_to_cpu(req->orb.misc))) {\r\ncase 0:\r\nsbp_handle_command(req);\r\nreturn;\r\ncase 1:\r\ncase 2:\r\nreq->status.status |= cpu_to_be32(\r\nSTATUS_BLOCK_RESP(\r\nSTATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_DEAD(0) |\r\nSTATUS_BLOCK_LEN(1) |\r\nSTATUS_BLOCK_SBP_STATUS(\r\nSBP_STATUS_REQ_TYPE_NOTSUPP));\r\nsbp_send_status(req);\r\nreturn;\r\ncase 3:\r\nreq->status.status |= cpu_to_be32(\r\nSTATUS_BLOCK_RESP(\r\nSTATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_DEAD(0) |\r\nSTATUS_BLOCK_LEN(1) |\r\nSTATUS_BLOCK_SBP_STATUS(\r\nSBP_STATUS_DUMMY_ORB_COMPLETE));\r\nsbp_send_status(req);\r\nreturn;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic inline bool tgt_agent_check_active(struct sbp_target_agent *agent)\r\n{\r\nbool active;\r\nspin_lock_bh(&agent->lock);\r\nactive = (agent->state == AGENT_STATE_ACTIVE);\r\nspin_unlock_bh(&agent->lock);\r\nreturn active;\r\n}\r\nstatic struct sbp_target_request *sbp_mgt_get_req(struct sbp_session *sess,\r\nstruct fw_card *card, u64 next_orb)\r\n{\r\nstruct se_session *se_sess = sess->se_sess;\r\nstruct sbp_target_request *req;\r\nint tag;\r\ntag = percpu_ida_alloc(&se_sess->sess_tag_pool, GFP_ATOMIC);\r\nif (tag < 0)\r\nreturn ERR_PTR(-ENOMEM);\r\nreq = &((struct sbp_target_request *)se_sess->sess_cmd_map)[tag];\r\nmemset(req, 0, sizeof(*req));\r\nreq->se_cmd.map_tag = tag;\r\nreq->se_cmd.tag = next_orb;\r\nreturn req;\r\n}\r\nstatic void tgt_agent_fetch_work(struct work_struct *work)\r\n{\r\nstruct sbp_target_agent *agent =\r\ncontainer_of(work, struct sbp_target_agent, work);\r\nstruct sbp_session *sess = agent->login->sess;\r\nstruct sbp_target_request *req;\r\nint ret;\r\nbool doorbell = agent->doorbell;\r\nu64 next_orb = agent->orb_pointer;\r\nwhile (next_orb && tgt_agent_check_active(agent)) {\r\nreq = sbp_mgt_get_req(sess, sess->card, next_orb);\r\nif (IS_ERR(req)) {\r\nspin_lock_bh(&agent->lock);\r\nagent->state = AGENT_STATE_DEAD;\r\nspin_unlock_bh(&agent->lock);\r\nreturn;\r\n}\r\nreq->login = agent->login;\r\nreq->orb_pointer = next_orb;\r\nreq->status.status = cpu_to_be32(STATUS_BLOCK_ORB_OFFSET_HIGH(\r\nreq->orb_pointer >> 32));\r\nreq->status.orb_low = cpu_to_be32(\r\nreq->orb_pointer & 0xfffffffc);\r\nret = sbp_run_transaction(sess->card, TCODE_READ_BLOCK_REQUEST,\r\nsess->node_id, sess->generation, sess->speed,\r\nreq->orb_pointer, &req->orb, sizeof(req->orb));\r\nif (ret != RCODE_COMPLETE) {\r\npr_debug("tgt_orb fetch failed: %x\n", ret);\r\nreq->status.status |= cpu_to_be32(\r\nSTATUS_BLOCK_SRC(\r\nSTATUS_SRC_ORB_FINISHED) |\r\nSTATUS_BLOCK_RESP(\r\nSTATUS_RESP_TRANSPORT_FAILURE) |\r\nSTATUS_BLOCK_DEAD(1) |\r\nSTATUS_BLOCK_LEN(1) |\r\nSTATUS_BLOCK_SBP_STATUS(\r\nSBP_STATUS_UNSPECIFIED_ERROR));\r\nspin_lock_bh(&agent->lock);\r\nagent->state = AGENT_STATE_DEAD;\r\nspin_unlock_bh(&agent->lock);\r\nsbp_send_status(req);\r\nreturn;\r\n}\r\nif (be32_to_cpu(req->orb.next_orb.high) & 0x80000000) {\r\nnext_orb = 0;\r\nreq->status.status |= cpu_to_be32(STATUS_BLOCK_SRC(\r\nSTATUS_SRC_ORB_FINISHED));\r\n} else {\r\nnext_orb = sbp2_pointer_to_addr(&req->orb.next_orb);\r\nreq->status.status |= cpu_to_be32(STATUS_BLOCK_SRC(\r\nSTATUS_SRC_ORB_CONTINUING));\r\n}\r\nif (tgt_agent_check_active(agent) && !doorbell) {\r\nINIT_WORK(&req->work, tgt_agent_process_work);\r\nqueue_work(system_unbound_wq, &req->work);\r\n} else {\r\nsbp_free_request(req);\r\n}\r\nspin_lock_bh(&agent->lock);\r\ndoorbell = agent->doorbell = false;\r\nif (next_orb)\r\nagent->orb_pointer = next_orb;\r\nelse\r\nagent->state = AGENT_STATE_SUSPENDED;\r\nspin_unlock_bh(&agent->lock);\r\n};\r\n}\r\nstatic struct sbp_target_agent *sbp_target_agent_register(\r\nstruct sbp_login_descriptor *login)\r\n{\r\nstruct sbp_target_agent *agent;\r\nint ret;\r\nagent = kmalloc(sizeof(*agent), GFP_KERNEL);\r\nif (!agent)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&agent->lock);\r\nagent->handler.length = 0x20;\r\nagent->handler.address_callback = tgt_agent_rw;\r\nagent->handler.callback_data = agent;\r\nagent->login = login;\r\nagent->state = AGENT_STATE_RESET;\r\nINIT_WORK(&agent->work, tgt_agent_fetch_work);\r\nagent->orb_pointer = 0;\r\nagent->doorbell = false;\r\nret = fw_core_add_address_handler(&agent->handler,\r\n&sbp_register_region);\r\nif (ret < 0) {\r\nkfree(agent);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn agent;\r\n}\r\nstatic void sbp_target_agent_unregister(struct sbp_target_agent *agent)\r\n{\r\nfw_core_remove_address_handler(&agent->handler);\r\ncancel_work_sync(&agent->work);\r\nkfree(agent);\r\n}\r\nstatic int sbp_run_transaction(struct fw_card *card, int tcode, int destination_id,\r\nint generation, int speed, unsigned long long offset,\r\nvoid *payload, size_t length)\r\n{\r\nint attempt, ret, delay;\r\nfor (attempt = 1; attempt <= 5; attempt++) {\r\nret = fw_run_transaction(card, tcode, destination_id,\r\ngeneration, speed, offset, payload, length);\r\nswitch (ret) {\r\ncase RCODE_COMPLETE:\r\ncase RCODE_TYPE_ERROR:\r\ncase RCODE_ADDRESS_ERROR:\r\ncase RCODE_GENERATION:\r\nreturn ret;\r\ndefault:\r\ndelay = 5 * attempt * attempt;\r\nusleep_range(delay, delay * 2);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sbp_run_request_transaction(struct sbp_target_request *req,\r\nint tcode, unsigned long long offset, void *payload,\r\nsize_t length)\r\n{\r\nstruct sbp_login_descriptor *login = req->login;\r\nstruct sbp_session *sess = login->sess;\r\nstruct fw_card *card;\r\nint node_id, generation, speed, ret;\r\nspin_lock_bh(&sess->lock);\r\ncard = fw_card_get(sess->card);\r\nnode_id = sess->node_id;\r\ngeneration = sess->generation;\r\nspeed = sess->speed;\r\nspin_unlock_bh(&sess->lock);\r\nret = sbp_run_transaction(card, tcode, node_id, generation, speed,\r\noffset, payload, length);\r\nfw_card_put(card);\r\nreturn ret;\r\n}\r\nstatic int sbp_fetch_command(struct sbp_target_request *req)\r\n{\r\nint ret, cmd_len, copy_len;\r\ncmd_len = scsi_command_size(req->orb.command_block);\r\nreq->cmd_buf = kmalloc(cmd_len, GFP_KERNEL);\r\nif (!req->cmd_buf)\r\nreturn -ENOMEM;\r\nmemcpy(req->cmd_buf, req->orb.command_block,\r\nmin_t(int, cmd_len, sizeof(req->orb.command_block)));\r\nif (cmd_len > sizeof(req->orb.command_block)) {\r\npr_debug("sbp_fetch_command: filling in long command\n");\r\ncopy_len = cmd_len - sizeof(req->orb.command_block);\r\nret = sbp_run_request_transaction(req,\r\nTCODE_READ_BLOCK_REQUEST,\r\nreq->orb_pointer + sizeof(req->orb),\r\nreq->cmd_buf + sizeof(req->orb.command_block),\r\ncopy_len);\r\nif (ret != RCODE_COMPLETE)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sbp_fetch_page_table(struct sbp_target_request *req)\r\n{\r\nint pg_tbl_sz, ret;\r\nstruct sbp_page_table_entry *pg_tbl;\r\nif (!CMDBLK_ORB_PG_TBL_PRESENT(be32_to_cpu(req->orb.misc)))\r\nreturn 0;\r\npg_tbl_sz = CMDBLK_ORB_DATA_SIZE(be32_to_cpu(req->orb.misc)) *\r\nsizeof(struct sbp_page_table_entry);\r\npg_tbl = kmalloc(pg_tbl_sz, GFP_KERNEL);\r\nif (!pg_tbl)\r\nreturn -ENOMEM;\r\nret = sbp_run_request_transaction(req, TCODE_READ_BLOCK_REQUEST,\r\nsbp2_pointer_to_addr(&req->orb.data_descriptor),\r\npg_tbl, pg_tbl_sz);\r\nif (ret != RCODE_COMPLETE) {\r\nkfree(pg_tbl);\r\nreturn -EIO;\r\n}\r\nreq->pg_tbl = pg_tbl;\r\nreturn 0;\r\n}\r\nstatic void sbp_calc_data_length_direction(struct sbp_target_request *req,\r\nu32 *data_len, enum dma_data_direction *data_dir)\r\n{\r\nint data_size, direction, idx;\r\ndata_size = CMDBLK_ORB_DATA_SIZE(be32_to_cpu(req->orb.misc));\r\ndirection = CMDBLK_ORB_DIRECTION(be32_to_cpu(req->orb.misc));\r\nif (!data_size) {\r\n*data_len = 0;\r\n*data_dir = DMA_NONE;\r\nreturn;\r\n}\r\n*data_dir = direction ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nif (req->pg_tbl) {\r\n*data_len = 0;\r\nfor (idx = 0; idx < data_size; idx++) {\r\n*data_len += be16_to_cpu(\r\nreq->pg_tbl[idx].segment_length);\r\n}\r\n} else {\r\n*data_len = data_size;\r\n}\r\n}\r\nstatic void sbp_handle_command(struct sbp_target_request *req)\r\n{\r\nstruct sbp_login_descriptor *login = req->login;\r\nstruct sbp_session *sess = login->sess;\r\nint ret, unpacked_lun;\r\nu32 data_length;\r\nenum dma_data_direction data_dir;\r\nret = sbp_fetch_command(req);\r\nif (ret) {\r\npr_debug("sbp_handle_command: fetch command failed: %d\n", ret);\r\ngoto err;\r\n}\r\nret = sbp_fetch_page_table(req);\r\nif (ret) {\r\npr_debug("sbp_handle_command: fetch page table failed: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nunpacked_lun = req->login->login_lun;\r\nsbp_calc_data_length_direction(req, &data_length, &data_dir);\r\npr_debug("sbp_handle_command ORB:0x%llx unpacked_lun:%d data_len:%d data_dir:%d\n",\r\nreq->orb_pointer, unpacked_lun, data_length, data_dir);\r\nreq->se_cmd.tag = req->orb_pointer;\r\nif (target_submit_cmd(&req->se_cmd, sess->se_sess, req->cmd_buf,\r\nreq->sense_buf, unpacked_lun, data_length,\r\nTCM_SIMPLE_TAG, data_dir, TARGET_SCF_ACK_KREF))\r\ngoto err;\r\nreturn;\r\nerr:\r\nreq->status.status |= cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_TRANSPORT_FAILURE) |\r\nSTATUS_BLOCK_DEAD(0) |\r\nSTATUS_BLOCK_LEN(1) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_UNSPECIFIED_ERROR));\r\nsbp_send_status(req);\r\n}\r\nstatic int sbp_rw_data(struct sbp_target_request *req)\r\n{\r\nstruct sbp_session *sess = req->login->sess;\r\nint tcode, sg_miter_flags, max_payload, pg_size, speed, node_id,\r\ngeneration, num_pte, length, tfr_length,\r\nrcode = RCODE_COMPLETE;\r\nstruct sbp_page_table_entry *pte;\r\nunsigned long long offset;\r\nstruct fw_card *card;\r\nstruct sg_mapping_iter iter;\r\nif (req->se_cmd.data_direction == DMA_FROM_DEVICE) {\r\ntcode = TCODE_WRITE_BLOCK_REQUEST;\r\nsg_miter_flags = SG_MITER_FROM_SG;\r\n} else {\r\ntcode = TCODE_READ_BLOCK_REQUEST;\r\nsg_miter_flags = SG_MITER_TO_SG;\r\n}\r\nmax_payload = 4 << CMDBLK_ORB_MAX_PAYLOAD(be32_to_cpu(req->orb.misc));\r\nspeed = CMDBLK_ORB_SPEED(be32_to_cpu(req->orb.misc));\r\npg_size = CMDBLK_ORB_PG_SIZE(be32_to_cpu(req->orb.misc));\r\nif (pg_size) {\r\npr_err("sbp_run_transaction: page size ignored\n");\r\npg_size = 0x100 << pg_size;\r\n}\r\nspin_lock_bh(&sess->lock);\r\ncard = fw_card_get(sess->card);\r\nnode_id = sess->node_id;\r\ngeneration = sess->generation;\r\nspin_unlock_bh(&sess->lock);\r\nif (req->pg_tbl) {\r\npte = req->pg_tbl;\r\nnum_pte = CMDBLK_ORB_DATA_SIZE(be32_to_cpu(req->orb.misc));\r\noffset = 0;\r\nlength = 0;\r\n} else {\r\npte = NULL;\r\nnum_pte = 0;\r\noffset = sbp2_pointer_to_addr(&req->orb.data_descriptor);\r\nlength = req->se_cmd.data_length;\r\n}\r\nsg_miter_start(&iter, req->se_cmd.t_data_sg, req->se_cmd.t_data_nents,\r\nsg_miter_flags);\r\nwhile (length || num_pte) {\r\nif (!length) {\r\noffset = (u64)be16_to_cpu(pte->segment_base_hi) << 32 |\r\nbe32_to_cpu(pte->segment_base_lo);\r\nlength = be16_to_cpu(pte->segment_length);\r\npte++;\r\nnum_pte--;\r\n}\r\nsg_miter_next(&iter);\r\ntfr_length = min3(length, max_payload, (int)iter.length);\r\nrcode = sbp_run_transaction(card, tcode, node_id,\r\ngeneration, speed,\r\noffset, iter.addr, tfr_length);\r\nif (rcode != RCODE_COMPLETE)\r\nbreak;\r\nlength -= tfr_length;\r\noffset += tfr_length;\r\niter.consumed = tfr_length;\r\n}\r\nsg_miter_stop(&iter);\r\nfw_card_put(card);\r\nif (rcode == RCODE_COMPLETE) {\r\nWARN_ON(length != 0);\r\nreturn 0;\r\n} else {\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int sbp_send_status(struct sbp_target_request *req)\r\n{\r\nint rc, ret = 0, length;\r\nstruct sbp_login_descriptor *login = req->login;\r\nlength = (((be32_to_cpu(req->status.status) >> 24) & 0x07) + 1) * 4;\r\nrc = sbp_run_request_transaction(req, TCODE_WRITE_BLOCK_REQUEST,\r\nlogin->status_fifo_addr, &req->status, length);\r\nif (rc != RCODE_COMPLETE) {\r\npr_debug("sbp_send_status: write failed: 0x%x\n", rc);\r\nret = -EIO;\r\ngoto put_ref;\r\n}\r\npr_debug("sbp_send_status: status write complete for ORB: 0x%llx\n",\r\nreq->orb_pointer);\r\nput_ref:\r\ntarget_put_sess_cmd(&req->se_cmd);\r\nreturn ret;\r\n}\r\nstatic void sbp_sense_mangle(struct sbp_target_request *req)\r\n{\r\nstruct se_cmd *se_cmd = &req->se_cmd;\r\nu8 *sense = req->sense_buf;\r\nu8 *status = req->status.data;\r\nWARN_ON(se_cmd->scsi_sense_length < 18);\r\nswitch (sense[0] & 0x7f) {\r\ncase 0x70:\r\nstatus[0] = 0 << 6;\r\nbreak;\r\ncase 0x71:\r\nstatus[0] = 1 << 6;\r\nbreak;\r\ncase 0x72:\r\ncase 0x73:\r\ndefault:\r\npr_err("sbp_send_sense: unknown sense format: 0x%x\n",\r\nsense[0]);\r\nreq->status.status |= cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_DEAD(0) |\r\nSTATUS_BLOCK_LEN(1) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQUEST_ABORTED));\r\nreturn;\r\n}\r\nstatus[0] |= se_cmd->scsi_status & 0x3f;\r\nstatus[1] =\r\n(sense[0] & 0x80) |\r\n((sense[2] & 0xe0) >> 1) |\r\n(sense[2] & 0x0f);\r\nstatus[2] = se_cmd->scsi_asc;\r\nstatus[3] = se_cmd->scsi_ascq;\r\nstatus[4] = sense[3];\r\nstatus[5] = sense[4];\r\nstatus[6] = sense[5];\r\nstatus[7] = sense[6];\r\nstatus[8] = sense[8];\r\nstatus[9] = sense[9];\r\nstatus[10] = sense[10];\r\nstatus[11] = sense[11];\r\nstatus[12] = sense[14];\r\nstatus[13] = sense[15];\r\nstatus[14] = sense[16];\r\nstatus[15] = sense[17];\r\nreq->status.status |= cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_DEAD(0) |\r\nSTATUS_BLOCK_LEN(5) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_OK));\r\n}\r\nstatic int sbp_send_sense(struct sbp_target_request *req)\r\n{\r\nstruct se_cmd *se_cmd = &req->se_cmd;\r\nif (se_cmd->scsi_sense_length) {\r\nsbp_sense_mangle(req);\r\n} else {\r\nreq->status.status |= cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_DEAD(0) |\r\nSTATUS_BLOCK_LEN(1) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_OK));\r\n}\r\nreturn sbp_send_status(req);\r\n}\r\nstatic void sbp_free_request(struct sbp_target_request *req)\r\n{\r\nstruct se_cmd *se_cmd = &req->se_cmd;\r\nstruct se_session *se_sess = se_cmd->se_sess;\r\nkfree(req->pg_tbl);\r\nkfree(req->cmd_buf);\r\npercpu_ida_free(&se_sess->sess_tag_pool, se_cmd->map_tag);\r\n}\r\nstatic void sbp_mgt_agent_process(struct work_struct *work)\r\n{\r\nstruct sbp_management_agent *agent =\r\ncontainer_of(work, struct sbp_management_agent, work);\r\nstruct sbp_management_request *req = agent->request;\r\nint ret;\r\nint status_data_len = 0;\r\nret = sbp_run_transaction(req->card, TCODE_READ_BLOCK_REQUEST,\r\nreq->node_addr, req->generation, req->speed,\r\nagent->orb_offset, &req->orb, sizeof(req->orb));\r\nif (ret != RCODE_COMPLETE) {\r\npr_debug("mgt_orb fetch failed: %x\n", ret);\r\ngoto out;\r\n}\r\npr_debug("mgt_orb ptr1:0x%llx ptr2:0x%llx misc:0x%x len:0x%x status_fifo:0x%llx\n",\r\nsbp2_pointer_to_addr(&req->orb.ptr1),\r\nsbp2_pointer_to_addr(&req->orb.ptr2),\r\nbe32_to_cpu(req->orb.misc), be32_to_cpu(req->orb.length),\r\nsbp2_pointer_to_addr(&req->orb.status_fifo));\r\nif (!ORB_NOTIFY(be32_to_cpu(req->orb.misc)) ||\r\nORB_REQUEST_FORMAT(be32_to_cpu(req->orb.misc)) != 0) {\r\npr_err("mgt_orb bad request\n");\r\ngoto out;\r\n}\r\nswitch (MANAGEMENT_ORB_FUNCTION(be32_to_cpu(req->orb.misc))) {\r\ncase MANAGEMENT_ORB_FUNCTION_LOGIN:\r\nsbp_management_request_login(agent, req, &status_data_len);\r\nbreak;\r\ncase MANAGEMENT_ORB_FUNCTION_QUERY_LOGINS:\r\nsbp_management_request_query_logins(agent, req,\r\n&status_data_len);\r\nbreak;\r\ncase MANAGEMENT_ORB_FUNCTION_RECONNECT:\r\nsbp_management_request_reconnect(agent, req, &status_data_len);\r\nbreak;\r\ncase MANAGEMENT_ORB_FUNCTION_SET_PASSWORD:\r\npr_notice("SET PASSWORD not implemented\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\r\nbreak;\r\ncase MANAGEMENT_ORB_FUNCTION_LOGOUT:\r\nsbp_management_request_logout(agent, req, &status_data_len);\r\nbreak;\r\ncase MANAGEMENT_ORB_FUNCTION_ABORT_TASK:\r\npr_notice("ABORT TASK not implemented\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\r\nbreak;\r\ncase MANAGEMENT_ORB_FUNCTION_ABORT_TASK_SET:\r\npr_notice("ABORT TASK SET not implemented\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\r\nbreak;\r\ncase MANAGEMENT_ORB_FUNCTION_LOGICAL_UNIT_RESET:\r\npr_notice("LOGICAL UNIT RESET not implemented\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\r\nbreak;\r\ncase MANAGEMENT_ORB_FUNCTION_TARGET_RESET:\r\npr_notice("TARGET RESET not implemented\n");\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\r\nbreak;\r\ndefault:\r\npr_notice("unknown management function 0x%x\n",\r\nMANAGEMENT_ORB_FUNCTION(be32_to_cpu(req->orb.misc)));\r\nreq->status.status = cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\r\nbreak;\r\n}\r\nreq->status.status |= cpu_to_be32(\r\nSTATUS_BLOCK_SRC(1) |\r\nSTATUS_BLOCK_LEN(DIV_ROUND_UP(status_data_len, 4) + 1) |\r\nSTATUS_BLOCK_ORB_OFFSET_HIGH(agent->orb_offset >> 32));\r\nreq->status.orb_low = cpu_to_be32(agent->orb_offset);\r\nret = sbp_run_transaction(req->card, TCODE_WRITE_BLOCK_REQUEST,\r\nreq->node_addr, req->generation, req->speed,\r\nsbp2_pointer_to_addr(&req->orb.status_fifo),\r\n&req->status, 8 + status_data_len);\r\nif (ret != RCODE_COMPLETE) {\r\npr_debug("mgt_orb status write failed: %x\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nfw_card_put(req->card);\r\nkfree(req);\r\nspin_lock_bh(&agent->lock);\r\nagent->state = MANAGEMENT_AGENT_STATE_IDLE;\r\nspin_unlock_bh(&agent->lock);\r\n}\r\nstatic void sbp_mgt_agent_rw(struct fw_card *card,\r\nstruct fw_request *request, int tcode, int destination, int source,\r\nint generation, unsigned long long offset, void *data, size_t length,\r\nvoid *callback_data)\r\n{\r\nstruct sbp_management_agent *agent = callback_data;\r\nstruct sbp2_pointer *ptr = data;\r\nint rcode = RCODE_ADDRESS_ERROR;\r\nif (!agent->tport->enable)\r\ngoto out;\r\nif ((offset != agent->handler.offset) || (length != 8))\r\ngoto out;\r\nif (tcode == TCODE_WRITE_BLOCK_REQUEST) {\r\nstruct sbp_management_request *req;\r\nint prev_state;\r\nspin_lock_bh(&agent->lock);\r\nprev_state = agent->state;\r\nagent->state = MANAGEMENT_AGENT_STATE_BUSY;\r\nspin_unlock_bh(&agent->lock);\r\nif (prev_state == MANAGEMENT_AGENT_STATE_BUSY) {\r\npr_notice("ignoring management request while busy\n");\r\nrcode = RCODE_CONFLICT_ERROR;\r\ngoto out;\r\n}\r\nreq = kzalloc(sizeof(*req), GFP_ATOMIC);\r\nif (!req) {\r\nrcode = RCODE_CONFLICT_ERROR;\r\ngoto out;\r\n}\r\nreq->card = fw_card_get(card);\r\nreq->generation = generation;\r\nreq->node_addr = source;\r\nreq->speed = fw_get_request_speed(request);\r\nagent->orb_offset = sbp2_pointer_to_addr(ptr);\r\nagent->request = req;\r\nqueue_work(system_unbound_wq, &agent->work);\r\nrcode = RCODE_COMPLETE;\r\n} else if (tcode == TCODE_READ_BLOCK_REQUEST) {\r\naddr_to_sbp2_pointer(agent->orb_offset, ptr);\r\nrcode = RCODE_COMPLETE;\r\n} else {\r\nrcode = RCODE_TYPE_ERROR;\r\n}\r\nout:\r\nfw_send_response(card, request, rcode);\r\n}\r\nstatic struct sbp_management_agent *sbp_management_agent_register(\r\nstruct sbp_tport *tport)\r\n{\r\nint ret;\r\nstruct sbp_management_agent *agent;\r\nagent = kmalloc(sizeof(*agent), GFP_KERNEL);\r\nif (!agent)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&agent->lock);\r\nagent->tport = tport;\r\nagent->handler.length = 0x08;\r\nagent->handler.address_callback = sbp_mgt_agent_rw;\r\nagent->handler.callback_data = agent;\r\nagent->state = MANAGEMENT_AGENT_STATE_IDLE;\r\nINIT_WORK(&agent->work, sbp_mgt_agent_process);\r\nagent->orb_offset = 0;\r\nagent->request = NULL;\r\nret = fw_core_add_address_handler(&agent->handler,\r\n&sbp_register_region);\r\nif (ret < 0) {\r\nkfree(agent);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn agent;\r\n}\r\nstatic void sbp_management_agent_unregister(struct sbp_management_agent *agent)\r\n{\r\nfw_core_remove_address_handler(&agent->handler);\r\ncancel_work_sync(&agent->work);\r\nkfree(agent);\r\n}\r\nstatic int sbp_check_true(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic int sbp_check_false(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic char *sbp_get_fabric_name(void)\r\n{\r\nreturn "sbp";\r\n}\r\nstatic char *sbp_get_fabric_wwn(struct se_portal_group *se_tpg)\r\n{\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nreturn &tport->tport_name[0];\r\n}\r\nstatic u16 sbp_get_tag(struct se_portal_group *se_tpg)\r\n{\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nreturn tpg->tport_tpgt;\r\n}\r\nstatic u32 sbp_tpg_get_inst_index(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic void sbp_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct sbp_target_request *req = container_of(se_cmd,\r\nstruct sbp_target_request, se_cmd);\r\nsbp_free_request(req);\r\n}\r\nstatic u32 sbp_sess_get_index(struct se_session *se_sess)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sbp_write_pending(struct se_cmd *se_cmd)\r\n{\r\nstruct sbp_target_request *req = container_of(se_cmd,\r\nstruct sbp_target_request, se_cmd);\r\nint ret;\r\nret = sbp_rw_data(req);\r\nif (ret) {\r\nreq->status.status |= cpu_to_be32(\r\nSTATUS_BLOCK_RESP(\r\nSTATUS_RESP_TRANSPORT_FAILURE) |\r\nSTATUS_BLOCK_DEAD(0) |\r\nSTATUS_BLOCK_LEN(1) |\r\nSTATUS_BLOCK_SBP_STATUS(\r\nSBP_STATUS_UNSPECIFIED_ERROR));\r\nsbp_send_status(req);\r\nreturn ret;\r\n}\r\ntarget_execute_cmd(se_cmd);\r\nreturn 0;\r\n}\r\nstatic int sbp_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sbp_set_default_node_attrs(struct se_node_acl *nacl)\r\n{\r\nreturn;\r\n}\r\nstatic int sbp_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sbp_queue_data_in(struct se_cmd *se_cmd)\r\n{\r\nstruct sbp_target_request *req = container_of(se_cmd,\r\nstruct sbp_target_request, se_cmd);\r\nint ret;\r\nret = sbp_rw_data(req);\r\nif (ret) {\r\nreq->status.status |= cpu_to_be32(\r\nSTATUS_BLOCK_RESP(STATUS_RESP_TRANSPORT_FAILURE) |\r\nSTATUS_BLOCK_DEAD(0) |\r\nSTATUS_BLOCK_LEN(1) |\r\nSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_UNSPECIFIED_ERROR));\r\nsbp_send_status(req);\r\nreturn ret;\r\n}\r\nreturn sbp_send_sense(req);\r\n}\r\nstatic int sbp_queue_status(struct se_cmd *se_cmd)\r\n{\r\nstruct sbp_target_request *req = container_of(se_cmd,\r\nstruct sbp_target_request, se_cmd);\r\nreturn sbp_send_sense(req);\r\n}\r\nstatic void sbp_queue_tm_rsp(struct se_cmd *se_cmd)\r\n{\r\n}\r\nstatic void sbp_aborted_task(struct se_cmd *se_cmd)\r\n{\r\nreturn;\r\n}\r\nstatic int sbp_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nstruct sbp_target_request *req = container_of(se_cmd,\r\nstruct sbp_target_request, se_cmd);\r\nreturn transport_generic_free_cmd(&req->se_cmd, 0);\r\n}\r\nstatic int sbp_count_se_tpg_luns(struct se_portal_group *tpg)\r\n{\r\nstruct se_lun *lun;\r\nint count = 0;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(lun, &tpg->tpg_lun_hlist, link)\r\ncount++;\r\nrcu_read_unlock();\r\nreturn count;\r\n}\r\nstatic int sbp_update_unit_directory(struct sbp_tport *tport)\r\n{\r\nstruct se_lun *lun;\r\nint num_luns, num_entries, idx = 0, mgt_agt_addr, ret;\r\nu32 *data;\r\nif (tport->unit_directory.data) {\r\nfw_core_remove_descriptor(&tport->unit_directory);\r\nkfree(tport->unit_directory.data);\r\ntport->unit_directory.data = NULL;\r\n}\r\nif (!tport->enable || !tport->tpg)\r\nreturn 0;\r\nnum_luns = sbp_count_se_tpg_luns(&tport->tpg->se_tpg);\r\nnum_entries = ARRAY_SIZE(sbp_unit_directory_template) + 4 + num_luns;\r\nif (tport->directory_id != -1)\r\nnum_entries++;\r\ndata = kcalloc((num_entries + 4), sizeof(u32), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata[idx++] = num_entries << 16;\r\nif (tport->directory_id != -1)\r\ndata[idx++] = (CSR_DIRECTORY_ID << 24) | tport->directory_id;\r\nmemcpy(&data[idx], sbp_unit_directory_template,\r\nsizeof(sbp_unit_directory_template));\r\nidx += ARRAY_SIZE(sbp_unit_directory_template);\r\nmgt_agt_addr = (tport->mgt_agt->handler.offset - CSR_REGISTER_BASE) / 4;\r\ndata[idx++] = 0x54000000 | (mgt_agt_addr & 0x00ffffff);\r\ndata[idx++] = 0x3a000000 |\r\n(((tport->mgt_orb_timeout * 2) << 8) & 0xff00) |\r\nSBP_ORB_FETCH_SIZE;\r\ndata[idx++] = 0x3d000000 | (tport->max_reconnect_timeout & 0xffff);\r\ndata[idx++] = 0x8d000000 | (num_luns + 1);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(lun, &tport->tpg->se_tpg.tpg_lun_hlist, link) {\r\nstruct se_device *dev;\r\nint type;\r\ndev = rcu_dereference_raw(lun->lun_se_dev);\r\ntype = dev->transport->get_device_type(dev);\r\ndata[idx++] = 0x14000000 |\r\n((type << 16) & 0x1f0000) |\r\n(lun->unpacked_lun & 0xffff);\r\n}\r\nrcu_read_unlock();\r\ndata[idx++] = 2 << 16;\r\ndata[idx++] = tport->guid >> 32;\r\ndata[idx++] = tport->guid;\r\ntport->unit_directory.length = idx;\r\ntport->unit_directory.key = (CSR_DIRECTORY | CSR_UNIT) << 24;\r\ntport->unit_directory.data = data;\r\nret = fw_core_add_descriptor(&tport->unit_directory);\r\nif (ret < 0) {\r\nkfree(tport->unit_directory.data);\r\ntport->unit_directory.data = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t sbp_parse_wwn(const char *name, u64 *wwn)\r\n{\r\nconst char *cp;\r\nchar c, nibble;\r\nint pos = 0, err;\r\n*wwn = 0;\r\nfor (cp = name; cp < &name[SBP_NAMELEN - 1]; cp++) {\r\nc = *cp;\r\nif (c == '\n' && cp[1] == '\0')\r\ncontinue;\r\nif (c == '\0') {\r\nerr = 2;\r\nif (pos != 16)\r\ngoto fail;\r\nreturn cp - name;\r\n}\r\nerr = 3;\r\nif (isdigit(c))\r\nnibble = c - '0';\r\nelse if (isxdigit(c))\r\nnibble = tolower(c) - 'a' + 10;\r\nelse\r\ngoto fail;\r\n*wwn = (*wwn << 4) | nibble;\r\npos++;\r\n}\r\nerr = 4;\r\nfail:\r\nprintk(KERN_INFO "err %u len %zu pos %u\n",\r\nerr, cp - name, pos);\r\nreturn -1;\r\n}\r\nstatic ssize_t sbp_format_wwn(char *buf, size_t len, u64 wwn)\r\n{\r\nreturn snprintf(buf, len, "%016llx", wwn);\r\n}\r\nstatic int sbp_init_nodeacl(struct se_node_acl *se_nacl, const char *name)\r\n{\r\nu64 guid = 0;\r\nif (sbp_parse_wwn(name, &guid) < 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sbp_post_link_lun(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_lun *se_lun)\r\n{\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nreturn sbp_update_unit_directory(tpg->tport);\r\n}\r\nstatic void sbp_pre_unlink_lun(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_lun *se_lun)\r\n{\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nint ret;\r\nif (sbp_count_se_tpg_luns(&tpg->se_tpg) == 0)\r\ntport->enable = 0;\r\nret = sbp_update_unit_directory(tport);\r\nif (ret < 0)\r\npr_err("unlink LUN: failed to update unit directory\n");\r\n}\r\nstatic struct se_portal_group *sbp_make_tpg(\r\nstruct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct sbp_tport *tport =\r\ncontainer_of(wwn, struct sbp_tport, tport_wwn);\r\nstruct sbp_tpg *tpg;\r\nunsigned long tpgt;\r\nint ret;\r\nif (strstr(name, "tpgt_") != name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\r\nreturn ERR_PTR(-EINVAL);\r\nif (tport->tpg) {\r\npr_err("Only one TPG per Unit is possible.\n");\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\ntpg = kzalloc(sizeof(*tpg), GFP_KERNEL);\r\nif (!tpg) {\r\npr_err("Unable to allocate struct sbp_tpg\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ntpg->tport = tport;\r\ntpg->tport_tpgt = tpgt;\r\ntport->tpg = tpg;\r\ntport->enable = 0;\r\ntport->directory_id = -1;\r\ntport->mgt_orb_timeout = 15;\r\ntport->max_reconnect_timeout = 5;\r\ntport->max_logins_per_lun = 1;\r\ntport->mgt_agt = sbp_management_agent_register(tport);\r\nif (IS_ERR(tport->mgt_agt)) {\r\nret = PTR_ERR(tport->mgt_agt);\r\ngoto out_free_tpg;\r\n}\r\nret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_SBP);\r\nif (ret < 0)\r\ngoto out_unreg_mgt_agt;\r\nreturn &tpg->se_tpg;\r\nout_unreg_mgt_agt:\r\nsbp_management_agent_unregister(tport->mgt_agt);\r\nout_free_tpg:\r\ntport->tpg = NULL;\r\nkfree(tpg);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void sbp_drop_tpg(struct se_portal_group *se_tpg)\r\n{\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\ncore_tpg_deregister(se_tpg);\r\nsbp_management_agent_unregister(tport->mgt_agt);\r\ntport->tpg = NULL;\r\nkfree(tpg);\r\n}\r\nstatic struct se_wwn *sbp_make_tport(\r\nstruct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct sbp_tport *tport;\r\nu64 guid = 0;\r\nif (sbp_parse_wwn(name, &guid) < 0)\r\nreturn ERR_PTR(-EINVAL);\r\ntport = kzalloc(sizeof(*tport), GFP_KERNEL);\r\nif (!tport) {\r\npr_err("Unable to allocate struct sbp_tport\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ntport->guid = guid;\r\nsbp_format_wwn(tport->tport_name, SBP_NAMELEN, guid);\r\nreturn &tport->tport_wwn;\r\n}\r\nstatic void sbp_drop_tport(struct se_wwn *wwn)\r\n{\r\nstruct sbp_tport *tport =\r\ncontainer_of(wwn, struct sbp_tport, tport_wwn);\r\nkfree(tport);\r\n}\r\nstatic ssize_t sbp_wwn_version_show(struct config_item *item, char *page)\r\n{\r\nreturn sprintf(page, "FireWire SBP fabric module %s\n", SBP_VERSION);\r\n}\r\nstatic ssize_t sbp_tpg_directory_id_show(struct config_item *item, char *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nif (tport->directory_id == -1)\r\nreturn sprintf(page, "implicit\n");\r\nelse\r\nreturn sprintf(page, "%06x\n", tport->directory_id);\r\n}\r\nstatic ssize_t sbp_tpg_directory_id_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nunsigned long val;\r\nif (tport->enable) {\r\npr_err("Cannot change the directory_id on an active target.\n");\r\nreturn -EBUSY;\r\n}\r\nif (strstr(page, "implicit") == page) {\r\ntport->directory_id = -1;\r\n} else {\r\nif (kstrtoul(page, 16, &val) < 0)\r\nreturn -EINVAL;\r\nif (val > 0xffffff)\r\nreturn -EINVAL;\r\ntport->directory_id = val;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t sbp_tpg_enable_show(struct config_item *item, char *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nreturn sprintf(page, "%d\n", tport->enable);\r\n}\r\nstatic ssize_t sbp_tpg_enable_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(page, 0, &val) < 0)\r\nreturn -EINVAL;\r\nif ((val != 0) && (val != 1))\r\nreturn -EINVAL;\r\nif (tport->enable == val)\r\nreturn count;\r\nif (val) {\r\nif (sbp_count_se_tpg_luns(&tpg->se_tpg) == 0) {\r\npr_err("Cannot enable a target with no LUNs!\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nspin_lock_bh(&se_tpg->session_lock);\r\nif (!list_empty(&se_tpg->tpg_sess_list)) {\r\nspin_unlock_bh(&se_tpg->session_lock);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_bh(&se_tpg->session_lock);\r\n}\r\ntport->enable = val;\r\nret = sbp_update_unit_directory(tport);\r\nif (ret < 0) {\r\npr_err("Could not update Config ROM\n");\r\nreturn ret;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t sbp_tpg_attrib_mgt_orb_timeout_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_portal_group *se_tpg = attrib_to_tpg(item);\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nreturn sprintf(page, "%d\n", tport->mgt_orb_timeout);\r\n}\r\nstatic ssize_t sbp_tpg_attrib_mgt_orb_timeout_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = attrib_to_tpg(item);\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(page, 0, &val) < 0)\r\nreturn -EINVAL;\r\nif ((val < 1) || (val > 127))\r\nreturn -EINVAL;\r\nif (tport->mgt_orb_timeout == val)\r\nreturn count;\r\ntport->mgt_orb_timeout = val;\r\nret = sbp_update_unit_directory(tport);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t sbp_tpg_attrib_max_reconnect_timeout_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_portal_group *se_tpg = attrib_to_tpg(item);\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nreturn sprintf(page, "%d\n", tport->max_reconnect_timeout);\r\n}\r\nstatic ssize_t sbp_tpg_attrib_max_reconnect_timeout_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = attrib_to_tpg(item);\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(page, 0, &val) < 0)\r\nreturn -EINVAL;\r\nif ((val < 1) || (val > 32767))\r\nreturn -EINVAL;\r\nif (tport->max_reconnect_timeout == val)\r\nreturn count;\r\ntport->max_reconnect_timeout = val;\r\nret = sbp_update_unit_directory(tport);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t sbp_tpg_attrib_max_logins_per_lun_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_portal_group *se_tpg = attrib_to_tpg(item);\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nreturn sprintf(page, "%d\n", tport->max_logins_per_lun);\r\n}\r\nstatic ssize_t sbp_tpg_attrib_max_logins_per_lun_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = attrib_to_tpg(item);\r\nstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\r\nstruct sbp_tport *tport = tpg->tport;\r\nunsigned long val;\r\nif (kstrtoul(page, 0, &val) < 0)\r\nreturn -EINVAL;\r\nif ((val < 1) || (val > 127))\r\nreturn -EINVAL;\r\ntport->max_logins_per_lun = val;\r\nreturn count;\r\n}\r\nstatic int __init sbp_init(void)\r\n{\r\nreturn target_register_template(&sbp_ops);\r\n}\r\nstatic void __exit sbp_exit(void)\r\n{\r\ntarget_unregister_template(&sbp_ops);\r\n}
