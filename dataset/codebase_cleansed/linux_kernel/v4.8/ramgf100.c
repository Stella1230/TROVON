static void\r\ngf100_ram_train(struct gf100_ramfuc *fuc, u32 magic)\r\n{\r\nstruct gf100_ram *ram = container_of(fuc, typeof(*ram), fuc);\r\nstruct nvkm_fb *fb = ram->base.fb;\r\nstruct nvkm_device *device = fb->subdev.device;\r\nu32 part = nvkm_rd32(device, 0x022438), i;\r\nu32 mask = nvkm_rd32(device, 0x022554);\r\nu32 addr = 0x110974;\r\nram_wr32(fuc, 0x10f910, magic);\r\nram_wr32(fuc, 0x10f914, magic);\r\nfor (i = 0; (magic & 0x80000000) && i < part; addr += 0x1000, i++) {\r\nif (mask & (1 << i))\r\ncontinue;\r\nram_wait(fuc, addr, 0x0000000f, 0x00000000, 500000);\r\n}\r\n}\r\nstatic int\r\ngf100_ram_calc(struct nvkm_ram *base, u32 freq)\r\n{\r\nstruct gf100_ram *ram = gf100_ram(base);\r\nstruct gf100_ramfuc *fuc = &ram->fuc;\r\nstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nstruct nvkm_clk *clk = device->clk;\r\nstruct nvkm_bios *bios = device->bios;\r\nstruct nvbios_ramcfg cfg;\r\nu8 ver, cnt, len, strap;\r\nstruct {\r\nu32 data;\r\nu8 size;\r\n} rammap, ramcfg, timing;\r\nint ref, div, out;\r\nint from, mode;\r\nint N1, M1, P;\r\nint ret;\r\nrammap.data = nvbios_rammapEm(bios, freq / 1000, &ver, &rammap.size,\r\n&cnt, &ramcfg.size, &cfg);\r\nif (!rammap.data || ver != 0x10 || rammap.size < 0x0e) {\r\nnvkm_error(subdev, "invalid/missing rammap entry\n");\r\nreturn -EINVAL;\r\n}\r\nstrap = nvbios_ramcfg_index(subdev);\r\nif (strap >= cnt) {\r\nnvkm_error(subdev, "invalid ramcfg strap\n");\r\nreturn -EINVAL;\r\n}\r\nramcfg.data = rammap.data + rammap.size + (strap * ramcfg.size);\r\nif (!ramcfg.data || ver != 0x10 || ramcfg.size < 0x0e) {\r\nnvkm_error(subdev, "invalid/missing ramcfg entry\n");\r\nreturn -EINVAL;\r\n}\r\nstrap = nvbios_rd08(bios, ramcfg.data + 0x01);\r\nif (strap != 0xff) {\r\ntiming.data = nvbios_timingEe(bios, strap, &ver, &timing.size,\r\n&cnt, &len);\r\nif (!timing.data || ver != 0x10 || timing.size < 0x19) {\r\nnvkm_error(subdev, "invalid/missing timing entry\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ntiming.data = 0;\r\n}\r\nret = ram_init(fuc, ram->base.fb);\r\nif (ret)\r\nreturn ret;\r\nfrom = !!(ram_rd32(fuc, 0x1373f0) & 0x00000002);\r\nif (!(ram_rd32(fuc, 0x137300) & 0x00000100))\r\nref = nvkm_clk_read(clk, nv_clk_src_sppll0);\r\nelse\r\nref = nvkm_clk_read(clk, nv_clk_src_sppll1);\r\ndiv = max(min((ref * 2) / freq, (u32)65), (u32)2) - 2;\r\nout = (ref * 2) / (div + 2);\r\nmode = freq != out;\r\nram_mask(fuc, 0x137360, 0x00000002, 0x00000000);\r\nif ((ram_rd32(fuc, 0x132000) & 0x00000002) || 0 ) {\r\nram_nuke(fuc, 0x132000);\r\nram_mask(fuc, 0x132000, 0x00000002, 0x00000002);\r\nram_mask(fuc, 0x132000, 0x00000002, 0x00000000);\r\n}\r\nif (mode == 1) {\r\nram_nuke(fuc, 0x10fe20);\r\nram_mask(fuc, 0x10fe20, 0x00000002, 0x00000002);\r\nram_mask(fuc, 0x10fe20, 0x00000002, 0x00000000);\r\n}\r\nram_wr32(fuc, 0x132100, 0x00000001);\r\nif (mode == 1 && from == 0) {\r\nret = gt215_pll_calc(subdev, &ram->refpll, ram->mempll.refclk,\r\n&N1, NULL, &M1, &P);\r\nif (ret <= 0) {\r\nnvkm_error(subdev, "unable to calc refpll\n");\r\nreturn ret ? ret : -ERANGE;\r\n}\r\nram_wr32(fuc, 0x10fe20, 0x20010000);\r\nram_wr32(fuc, 0x137320, 0x00000003);\r\nram_wr32(fuc, 0x137330, 0x81200006);\r\nram_wr32(fuc, 0x10fe24, (P << 16) | (N1 << 8) | M1);\r\nram_wr32(fuc, 0x10fe20, 0x20010001);\r\nram_wait(fuc, 0x137390, 0x00020000, 0x00020000, 64000);\r\nret = gt215_pll_calc(subdev, &ram->mempll, freq,\r\n&N1, NULL, &M1, &P);\r\nif (ret <= 0) {\r\nnvkm_error(subdev, "unable to calc refpll\n");\r\nreturn ret ? ret : -ERANGE;\r\n}\r\nram_wr32(fuc, 0x10fe20, 0x20010005);\r\nram_wr32(fuc, 0x132004, (P << 16) | (N1 << 8) | M1);\r\nram_wr32(fuc, 0x132000, 0x18010101);\r\nram_wait(fuc, 0x137390, 0x00000002, 0x00000002, 64000);\r\n} else\r\nif (mode == 0) {\r\nram_wr32(fuc, 0x137300, 0x00000003);\r\n}\r\nif (from == 0) {\r\nram_nuke(fuc, 0x10fb04);\r\nram_mask(fuc, 0x10fb04, 0x0000ffff, 0x00000000);\r\nram_nuke(fuc, 0x10fb08);\r\nram_mask(fuc, 0x10fb08, 0x0000ffff, 0x00000000);\r\nram_wr32(fuc, 0x10f988, 0x2004ff00);\r\nram_wr32(fuc, 0x10f98c, 0x003fc040);\r\nram_wr32(fuc, 0x10f990, 0x20012001);\r\nram_wr32(fuc, 0x10f998, 0x00011a00);\r\nram_wr32(fuc, 0x13d8f4, 0x00000000);\r\n} else {\r\nram_wr32(fuc, 0x10f988, 0x20010000);\r\nram_wr32(fuc, 0x10f98c, 0x00000000);\r\nram_wr32(fuc, 0x10f990, 0x20012001);\r\nram_wr32(fuc, 0x10f998, 0x00010a00);\r\n}\r\nif (from == 0) {\r\n}\r\nram_wr32(fuc, 0x100b0c, 0x00080012);\r\nram_wr32(fuc, 0x611200, 0x00003300);\r\nram_mask(fuc, 0x10f200, 0x00000800, 0x00000000);\r\nram_wr32(fuc, 0x10f210, 0x00000000);\r\nram_nsec(fuc, 1000);\r\nif (mode == 0)\r\ngf100_ram_train(fuc, 0x000c1001);\r\nram_wr32(fuc, 0x10f310, 0x00000001);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f090, 0x00000061);\r\nram_wr32(fuc, 0x10f090, 0xc000007f);\r\nram_nsec(fuc, 1000);\r\nif (from == 0) {\r\nram_wr32(fuc, 0x10f824, 0x00007fd4);\r\n} else {\r\nram_wr32(fuc, 0x1373ec, 0x00020404);\r\n}\r\nif (mode == 0) {\r\nram_mask(fuc, 0x10f808, 0x00080000, 0x00000000);\r\nram_mask(fuc, 0x10f200, 0x00008000, 0x00008000);\r\nram_wr32(fuc, 0x10f830, 0x41500010);\r\nram_mask(fuc, 0x10f830, 0x01000000, 0x00000000);\r\nram_mask(fuc, 0x132100, 0x00000100, 0x00000100);\r\nram_wr32(fuc, 0x10f050, 0xff000090);\r\nram_wr32(fuc, 0x1373ec, 0x00020f0f);\r\nram_wr32(fuc, 0x1373f0, 0x00000003);\r\nram_wr32(fuc, 0x137310, 0x81201616);\r\nram_wr32(fuc, 0x132100, 0x00000001);\r\nram_wr32(fuc, 0x10f830, 0x00300017);\r\nram_wr32(fuc, 0x1373f0, 0x00000001);\r\nram_wr32(fuc, 0x10f824, 0x00007e77);\r\nram_wr32(fuc, 0x132000, 0x18030001);\r\nram_wr32(fuc, 0x10f090, 0x4000007e);\r\nram_nsec(fuc, 2000);\r\nram_wr32(fuc, 0x10f314, 0x00000001);\r\nram_wr32(fuc, 0x10f210, 0x80000000);\r\nram_wr32(fuc, 0x10f338, 0x00300220);\r\nram_wr32(fuc, 0x10f300, 0x0000011d);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f290, 0x02060505);\r\nram_wr32(fuc, 0x10f294, 0x34208288);\r\nram_wr32(fuc, 0x10f298, 0x44050411);\r\nram_wr32(fuc, 0x10f29c, 0x0000114c);\r\nram_wr32(fuc, 0x10f2a0, 0x42e10069);\r\nram_wr32(fuc, 0x10f614, 0x40044f77);\r\nram_wr32(fuc, 0x10f610, 0x40044f77);\r\nram_wr32(fuc, 0x10f344, 0x00600009);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f348, 0x00700008);\r\nram_wr32(fuc, 0x61c140, 0x19240000);\r\nram_wr32(fuc, 0x10f830, 0x00300017);\r\ngf100_ram_train(fuc, 0x80021001);\r\ngf100_ram_train(fuc, 0x80081001);\r\nram_wr32(fuc, 0x10f340, 0x00500004);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f830, 0x01300017);\r\nram_wr32(fuc, 0x10f830, 0x00300017);\r\nram_wr32(fuc, 0x100b0c, 0x00080028);\r\nram_wr32(fuc, 0x611200, 0x00003330);\r\n} else {\r\nram_wr32(fuc, 0x10f800, 0x00001800);\r\nram_wr32(fuc, 0x13d8f4, 0x00000000);\r\nram_wr32(fuc, 0x1373ec, 0x00020404);\r\nram_wr32(fuc, 0x1373f0, 0x00000003);\r\nram_wr32(fuc, 0x10f830, 0x40700010);\r\nram_wr32(fuc, 0x10f830, 0x40500010);\r\nram_wr32(fuc, 0x13d8f4, 0x00000000);\r\nram_wr32(fuc, 0x1373f8, 0x00000000);\r\nram_wr32(fuc, 0x132100, 0x00000101);\r\nram_wr32(fuc, 0x137310, 0x89201616);\r\nram_wr32(fuc, 0x10f050, 0xff000090);\r\nram_wr32(fuc, 0x1373ec, 0x00030404);\r\nram_wr32(fuc, 0x1373f0, 0x00000002);\r\nram_wr32(fuc, 0x132100, 0x00000001);\r\nram_wr32(fuc, 0x1373f8, 0x00002000);\r\nram_nsec(fuc, 2000);\r\nram_wr32(fuc, 0x10f808, 0x7aaa0050);\r\nram_wr32(fuc, 0x10f830, 0x00500010);\r\nram_wr32(fuc, 0x10f200, 0x00ce1000);\r\nram_wr32(fuc, 0x10f090, 0x4000007e);\r\nram_nsec(fuc, 2000);\r\nram_wr32(fuc, 0x10f314, 0x00000001);\r\nram_wr32(fuc, 0x10f210, 0x80000000);\r\nram_wr32(fuc, 0x10f338, 0x00300200);\r\nram_wr32(fuc, 0x10f300, 0x0000084d);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f290, 0x0b343825);\r\nram_wr32(fuc, 0x10f294, 0x3483028e);\r\nram_wr32(fuc, 0x10f298, 0x440c0600);\r\nram_wr32(fuc, 0x10f29c, 0x0000214c);\r\nram_wr32(fuc, 0x10f2a0, 0x42e20069);\r\nram_wr32(fuc, 0x10f200, 0x00ce0000);\r\nram_wr32(fuc, 0x10f614, 0x60044e77);\r\nram_wr32(fuc, 0x10f610, 0x60044e77);\r\nram_wr32(fuc, 0x10f340, 0x00500000);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f344, 0x00600228);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f348, 0x00700000);\r\nram_wr32(fuc, 0x13d8f4, 0x00000000);\r\nram_wr32(fuc, 0x61c140, 0x09a40000);\r\ngf100_ram_train(fuc, 0x800e1008);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f800, 0x00001804);\r\nram_wr32(fuc, 0x13d8f4, 0x00000000);\r\nram_wr32(fuc, 0x100b0c, 0x00080028);\r\nram_wr32(fuc, 0x611200, 0x00003330);\r\nram_nsec(fuc, 100000);\r\nram_wr32(fuc, 0x10f9b0, 0x05313f41);\r\nram_wr32(fuc, 0x10f9b4, 0x00002f50);\r\ngf100_ram_train(fuc, 0x010c1001);\r\n}\r\nram_mask(fuc, 0x10f200, 0x00000800, 0x00000800);\r\nif (mode == 0)\r\nram_mask(fuc, 0x132000, 0x00000001, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int\r\ngf100_ram_prog(struct nvkm_ram *base)\r\n{\r\nstruct gf100_ram *ram = gf100_ram(base);\r\nstruct nvkm_device *device = ram->base.fb->subdev.device;\r\nram_exec(&ram->fuc, nvkm_boolopt(device->cfgopt, "NvMemExec", true));\r\nreturn 0;\r\n}\r\nstatic void\r\ngf100_ram_tidy(struct nvkm_ram *base)\r\n{\r\nstruct gf100_ram *ram = gf100_ram(base);\r\nram_exec(&ram->fuc, false);\r\n}\r\nvoid\r\ngf100_ram_put(struct nvkm_ram *ram, struct nvkm_mem **pmem)\r\n{\r\nstruct nvkm_ltc *ltc = ram->fb->subdev.device->ltc;\r\nstruct nvkm_mem *mem = *pmem;\r\n*pmem = NULL;\r\nif (unlikely(mem == NULL))\r\nreturn;\r\nmutex_lock(&ram->fb->subdev.mutex);\r\nif (mem->tag)\r\nnvkm_ltc_tags_free(ltc, &mem->tag);\r\n__nv50_ram_put(ram, mem);\r\nmutex_unlock(&ram->fb->subdev.mutex);\r\nkfree(mem);\r\n}\r\nint\r\ngf100_ram_get(struct nvkm_ram *ram, u64 size, u32 align, u32 ncmin,\r\nu32 memtype, struct nvkm_mem **pmem)\r\n{\r\nstruct nvkm_ltc *ltc = ram->fb->subdev.device->ltc;\r\nstruct nvkm_mm *mm = &ram->vram;\r\nstruct nvkm_mm_node *r;\r\nstruct nvkm_mem *mem;\r\nint type = (memtype & 0x0ff);\r\nint back = (memtype & 0x800);\r\nconst bool comp = gf100_pte_storage_type_map[type] != type;\r\nint ret;\r\nsize >>= NVKM_RAM_MM_SHIFT;\r\nalign >>= NVKM_RAM_MM_SHIFT;\r\nncmin >>= NVKM_RAM_MM_SHIFT;\r\nif (!ncmin)\r\nncmin = size;\r\nmem = kzalloc(sizeof(*mem), GFP_KERNEL);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&mem->regions);\r\nmem->size = size;\r\nmutex_lock(&ram->fb->subdev.mutex);\r\nif (comp) {\r\nif (align == (1 << (17 - NVKM_RAM_MM_SHIFT))) {\r\nint n = size >> 5;\r\nnvkm_ltc_tags_alloc(ltc, n, &mem->tag);\r\n}\r\nif (unlikely(!mem->tag))\r\ntype = gf100_pte_storage_type_map[type];\r\n}\r\nmem->memtype = type;\r\ndo {\r\nif (back)\r\nret = nvkm_mm_tail(mm, 0, 1, size, ncmin, align, &r);\r\nelse\r\nret = nvkm_mm_head(mm, 0, 1, size, ncmin, align, &r);\r\nif (ret) {\r\nmutex_unlock(&ram->fb->subdev.mutex);\r\nram->func->put(ram, &mem);\r\nreturn ret;\r\n}\r\nlist_add_tail(&r->rl_entry, &mem->regions);\r\nsize -= r->length;\r\n} while (size);\r\nmutex_unlock(&ram->fb->subdev.mutex);\r\nr = list_first_entry(&mem->regions, struct nvkm_mm_node, rl_entry);\r\nmem->offset = (u64)r->offset << NVKM_RAM_MM_SHIFT;\r\n*pmem = mem;\r\nreturn 0;\r\n}\r\nstatic int\r\ngf100_ram_init(struct nvkm_ram *base)\r\n{\r\nstatic const u8 train0[] = {\r\n0x00, 0xff, 0x55, 0xaa, 0x33, 0xcc,\r\n0x00, 0xff, 0xff, 0x00, 0xff, 0x00,\r\n};\r\nstatic const u32 train1[] = {\r\n0x00000000, 0xffffffff,\r\n0x55555555, 0xaaaaaaaa,\r\n0x33333333, 0xcccccccc,\r\n0xf0f0f0f0, 0x0f0f0f0f,\r\n0x00ff00ff, 0xff00ff00,\r\n0x0000ffff, 0xffff0000,\r\n};\r\nstruct gf100_ram *ram = gf100_ram(base);\r\nstruct nvkm_device *device = ram->base.fb->subdev.device;\r\nint i;\r\nswitch (ram->base.type) {\r\ncase NVKM_RAM_TYPE_GDDR5:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 0x30; i++) {\r\nnvkm_wr32(device, 0x10f968, 0x00000000 | (i << 8));\r\nnvkm_wr32(device, 0x10f96c, 0x00000000 | (i << 8));\r\nnvkm_wr32(device, 0x10f920, 0x00000100 | train0[i % 12]);\r\nnvkm_wr32(device, 0x10f924, 0x00000100 | train0[i % 12]);\r\nnvkm_wr32(device, 0x10f918, train1[i % 12]);\r\nnvkm_wr32(device, 0x10f91c, train1[i % 12]);\r\nnvkm_wr32(device, 0x10f920, 0x00000000 | train0[i % 12]);\r\nnvkm_wr32(device, 0x10f924, 0x00000000 | train0[i % 12]);\r\nnvkm_wr32(device, 0x10f918, train1[i % 12]);\r\nnvkm_wr32(device, 0x10f91c, train1[i % 12]);\r\n}\r\nreturn 0;\r\n}\r\nint\r\ngf100_ram_ctor(const struct nvkm_ram_func *func, struct nvkm_fb *fb,\r\nu32 maskaddr, struct nvkm_ram *ram)\r\n{\r\nstruct nvkm_subdev *subdev = &fb->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nstruct nvkm_bios *bios = device->bios;\r\nconst u32 rsvd_head = ( 256 * 1024);\r\nconst u32 rsvd_tail = (1024 * 1024);\r\nu32 parts = nvkm_rd32(device, 0x022438);\r\nu32 pmask = nvkm_rd32(device, maskaddr);\r\nu64 bsize = (u64)nvkm_rd32(device, 0x10f20c) << 20;\r\nu64 psize, size = 0;\r\nenum nvkm_ram_type type = nvkm_fb_bios_memtype(bios);\r\nbool uniform = true;\r\nint ret, i;\r\nnvkm_debug(subdev, "100800: %08x\n", nvkm_rd32(device, 0x100800));\r\nnvkm_debug(subdev, "parts %08x mask %08x\n", parts, pmask);\r\nfor (i = 0; i < parts; i++) {\r\nif (pmask & (1 << i))\r\ncontinue;\r\npsize = (u64)nvkm_rd32(device, 0x11020c + (i * 0x1000)) << 20;\r\nif (psize != bsize) {\r\nif (psize < bsize)\r\nbsize = psize;\r\nuniform = false;\r\n}\r\nnvkm_debug(subdev, "%d: %d MiB\n", i, (u32)(psize >> 20));\r\nsize += psize;\r\n}\r\nret = nvkm_ram_ctor(func, fb, type, size, 0, ram);\r\nif (ret)\r\nreturn ret;\r\nnvkm_mm_fini(&ram->vram);\r\nif (uniform) {\r\nret = nvkm_mm_init(&ram->vram, rsvd_head >> NVKM_RAM_MM_SHIFT,\r\n(size - rsvd_head - rsvd_tail) >>\r\nNVKM_RAM_MM_SHIFT, 1);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = nvkm_mm_init(&ram->vram, rsvd_head >> NVKM_RAM_MM_SHIFT,\r\n((bsize * parts) - rsvd_head) >>\r\nNVKM_RAM_MM_SHIFT, 1);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_mm_init(&ram->vram, (0x0200000000ULL + bsize) >>\r\nNVKM_RAM_MM_SHIFT,\r\n(size - (bsize * parts) - rsvd_tail) >>\r\nNVKM_RAM_MM_SHIFT, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nram->ranks = (nvkm_rd32(device, 0x10f200) & 0x00000004) ? 2 : 1;\r\nreturn 0;\r\n}\r\nint\r\ngf100_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)\r\n{\r\nstruct nvkm_subdev *subdev = &fb->subdev;\r\nstruct nvkm_bios *bios = subdev->device->bios;\r\nstruct gf100_ram *ram;\r\nint ret;\r\nif (!(ram = kzalloc(sizeof(*ram), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pram = &ram->base;\r\nret = gf100_ram_ctor(&gf100_ram_func, fb, 0x022554, &ram->base);\r\nif (ret)\r\nreturn ret;\r\nret = nvbios_pll_parse(bios, 0x0c, &ram->refpll);\r\nif (ret) {\r\nnvkm_error(subdev, "mclk refpll data not found\n");\r\nreturn ret;\r\n}\r\nret = nvbios_pll_parse(bios, 0x04, &ram->mempll);\r\nif (ret) {\r\nnvkm_error(subdev, "mclk pll data not found\n");\r\nreturn ret;\r\n}\r\nram->fuc.r_0x10fe20 = ramfuc_reg(0x10fe20);\r\nram->fuc.r_0x10fe24 = ramfuc_reg(0x10fe24);\r\nram->fuc.r_0x137320 = ramfuc_reg(0x137320);\r\nram->fuc.r_0x137330 = ramfuc_reg(0x137330);\r\nram->fuc.r_0x132000 = ramfuc_reg(0x132000);\r\nram->fuc.r_0x132004 = ramfuc_reg(0x132004);\r\nram->fuc.r_0x132100 = ramfuc_reg(0x132100);\r\nram->fuc.r_0x137390 = ramfuc_reg(0x137390);\r\nram->fuc.r_0x10f290 = ramfuc_reg(0x10f290);\r\nram->fuc.r_0x10f294 = ramfuc_reg(0x10f294);\r\nram->fuc.r_0x10f298 = ramfuc_reg(0x10f298);\r\nram->fuc.r_0x10f29c = ramfuc_reg(0x10f29c);\r\nram->fuc.r_0x10f2a0 = ramfuc_reg(0x10f2a0);\r\nram->fuc.r_0x10f300 = ramfuc_reg(0x10f300);\r\nram->fuc.r_0x10f338 = ramfuc_reg(0x10f338);\r\nram->fuc.r_0x10f340 = ramfuc_reg(0x10f340);\r\nram->fuc.r_0x10f344 = ramfuc_reg(0x10f344);\r\nram->fuc.r_0x10f348 = ramfuc_reg(0x10f348);\r\nram->fuc.r_0x10f910 = ramfuc_reg(0x10f910);\r\nram->fuc.r_0x10f914 = ramfuc_reg(0x10f914);\r\nram->fuc.r_0x100b0c = ramfuc_reg(0x100b0c);\r\nram->fuc.r_0x10f050 = ramfuc_reg(0x10f050);\r\nram->fuc.r_0x10f090 = ramfuc_reg(0x10f090);\r\nram->fuc.r_0x10f200 = ramfuc_reg(0x10f200);\r\nram->fuc.r_0x10f210 = ramfuc_reg(0x10f210);\r\nram->fuc.r_0x10f310 = ramfuc_reg(0x10f310);\r\nram->fuc.r_0x10f314 = ramfuc_reg(0x10f314);\r\nram->fuc.r_0x10f610 = ramfuc_reg(0x10f610);\r\nram->fuc.r_0x10f614 = ramfuc_reg(0x10f614);\r\nram->fuc.r_0x10f800 = ramfuc_reg(0x10f800);\r\nram->fuc.r_0x10f808 = ramfuc_reg(0x10f808);\r\nram->fuc.r_0x10f824 = ramfuc_reg(0x10f824);\r\nram->fuc.r_0x10f830 = ramfuc_reg(0x10f830);\r\nram->fuc.r_0x10f988 = ramfuc_reg(0x10f988);\r\nram->fuc.r_0x10f98c = ramfuc_reg(0x10f98c);\r\nram->fuc.r_0x10f990 = ramfuc_reg(0x10f990);\r\nram->fuc.r_0x10f998 = ramfuc_reg(0x10f998);\r\nram->fuc.r_0x10f9b0 = ramfuc_reg(0x10f9b0);\r\nram->fuc.r_0x10f9b4 = ramfuc_reg(0x10f9b4);\r\nram->fuc.r_0x10fb04 = ramfuc_reg(0x10fb04);\r\nram->fuc.r_0x10fb08 = ramfuc_reg(0x10fb08);\r\nram->fuc.r_0x137310 = ramfuc_reg(0x137300);\r\nram->fuc.r_0x137310 = ramfuc_reg(0x137310);\r\nram->fuc.r_0x137360 = ramfuc_reg(0x137360);\r\nram->fuc.r_0x1373ec = ramfuc_reg(0x1373ec);\r\nram->fuc.r_0x1373f0 = ramfuc_reg(0x1373f0);\r\nram->fuc.r_0x1373f8 = ramfuc_reg(0x1373f8);\r\nram->fuc.r_0x61c140 = ramfuc_reg(0x61c140);\r\nram->fuc.r_0x611200 = ramfuc_reg(0x611200);\r\nram->fuc.r_0x13d8f4 = ramfuc_reg(0x13d8f4);\r\nreturn 0;\r\n}
