static void fsl_free_resource(struct work_struct *ws)\r\n{\r\nstruct fsl_mpic_timer_wakeup *wakeup =\r\ncontainer_of(ws, struct fsl_mpic_timer_wakeup, free_work);\r\nmutex_lock(&sysfs_lock);\r\nif (wakeup->timer) {\r\ndisable_irq_wake(wakeup->timer->irq);\r\nmpic_free_timer(wakeup->timer);\r\n}\r\nwakeup->timer = NULL;\r\nmutex_unlock(&sysfs_lock);\r\n}\r\nstatic irqreturn_t fsl_mpic_timer_irq(int irq, void *dev_id)\r\n{\r\nstruct fsl_mpic_timer_wakeup *wakeup = dev_id;\r\nschedule_work(&wakeup->free_work);\r\nreturn wakeup->timer ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic ssize_t fsl_timer_wakeup_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct timeval interval;\r\nint val = 0;\r\nmutex_lock(&sysfs_lock);\r\nif (fsl_wakeup->timer) {\r\nmpic_get_remain_time(fsl_wakeup->timer, &interval);\r\nval = interval.tv_sec + 1;\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t fsl_timer_wakeup_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct timeval interval;\r\nint ret;\r\ninterval.tv_usec = 0;\r\nif (kstrtol(buf, 0, &interval.tv_sec))\r\nreturn -EINVAL;\r\nmutex_lock(&sysfs_lock);\r\nif (fsl_wakeup->timer) {\r\ndisable_irq_wake(fsl_wakeup->timer->irq);\r\nmpic_free_timer(fsl_wakeup->timer);\r\nfsl_wakeup->timer = NULL;\r\n}\r\nif (!interval.tv_sec) {\r\nmutex_unlock(&sysfs_lock);\r\nreturn count;\r\n}\r\nfsl_wakeup->timer = mpic_request_timer(fsl_mpic_timer_irq,\r\nfsl_wakeup, &interval);\r\nif (!fsl_wakeup->timer) {\r\nmutex_unlock(&sysfs_lock);\r\nreturn -EINVAL;\r\n}\r\nret = enable_irq_wake(fsl_wakeup->timer->irq);\r\nif (ret) {\r\nmpic_free_timer(fsl_wakeup->timer);\r\nfsl_wakeup->timer = NULL;\r\nmutex_unlock(&sysfs_lock);\r\nreturn ret;\r\n}\r\nmpic_start_timer(fsl_wakeup->timer);\r\nmutex_unlock(&sysfs_lock);\r\nreturn count;\r\n}\r\nstatic int __init fsl_wakeup_sys_init(void)\r\n{\r\nint ret;\r\nfsl_wakeup = kzalloc(sizeof(struct fsl_mpic_timer_wakeup), GFP_KERNEL);\r\nif (!fsl_wakeup)\r\nreturn -ENOMEM;\r\nINIT_WORK(&fsl_wakeup->free_work, fsl_free_resource);\r\nret = device_create_file(mpic_subsys.dev_root, &mpic_attributes);\r\nif (ret)\r\nkfree(fsl_wakeup);\r\nreturn ret;\r\n}\r\nstatic void __exit fsl_wakeup_sys_exit(void)\r\n{\r\ndevice_remove_file(mpic_subsys.dev_root, &mpic_attributes);\r\nmutex_lock(&sysfs_lock);\r\nif (fsl_wakeup->timer) {\r\ndisable_irq_wake(fsl_wakeup->timer->irq);\r\nmpic_free_timer(fsl_wakeup->timer);\r\n}\r\nkfree(fsl_wakeup);\r\nmutex_unlock(&sysfs_lock);\r\n}
