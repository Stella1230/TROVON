static inline void initialize_SCp(struct scsi_cmnd *cmd)\r\n{\r\nif (scsi_bufflen(cmd)) {\r\ncmd->SCp.buffer = scsi_sglist(cmd);\r\ncmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\n} else {\r\ncmd->SCp.buffer = NULL;\r\ncmd->SCp.buffers_residual = 0;\r\ncmd->SCp.ptr = NULL;\r\ncmd->SCp.this_residual = 0;\r\n}\r\ncmd->SCp.Status = 0;\r\ncmd->SCp.Message = 0;\r\n}\r\nstatic int NCR5380_poll_politely2(struct Scsi_Host *instance,\r\nint reg1, int bit1, int val1,\r\nint reg2, int bit2, int val2, int wait)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned long deadline = jiffies + wait;\r\nunsigned long n;\r\nn = min(10000U, jiffies_to_usecs(wait));\r\nn *= hostdata->accesses_per_ms;\r\nn /= 2000;\r\ndo {\r\nif ((NCR5380_read(reg1) & bit1) == val1)\r\nreturn 0;\r\nif ((NCR5380_read(reg2) & bit2) == val2)\r\nreturn 0;\r\ncpu_relax();\r\n} while (n--);\r\nif (irqs_disabled() || in_interrupt())\r\nreturn -ETIMEDOUT;\r\nwhile (time_is_after_jiffies(deadline)) {\r\nschedule_timeout_uninterruptible(1);\r\nif ((NCR5380_read(reg1) & bit1) == val1)\r\nreturn 0;\r\nif ((NCR5380_read(reg2) & bit2) == val2)\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline int NCR5380_poll_politely(struct Scsi_Host *instance,\r\nint reg, int bit, int val, int wait)\r\n{\r\nreturn NCR5380_poll_politely2(instance, reg, bit, val,\r\nreg, bit, val, wait);\r\n}\r\nstatic void NCR5380_print(struct Scsi_Host *instance)\r\n{\r\nunsigned char status, data, basr, mr, icr, i;\r\ndata = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\nstatus = NCR5380_read(STATUS_REG);\r\nmr = NCR5380_read(MODE_REG);\r\nicr = NCR5380_read(INITIATOR_COMMAND_REG);\r\nbasr = NCR5380_read(BUS_AND_STATUS_REG);\r\nprintk(KERN_DEBUG "SR = 0x%02x : ", status);\r\nfor (i = 0; signals[i].mask; ++i)\r\nif (status & signals[i].mask)\r\nprintk(KERN_CONT "%s, ", signals[i].name);\r\nprintk(KERN_CONT "\nBASR = 0x%02x : ", basr);\r\nfor (i = 0; basrs[i].mask; ++i)\r\nif (basr & basrs[i].mask)\r\nprintk(KERN_CONT "%s, ", basrs[i].name);\r\nprintk(KERN_CONT "\nICR = 0x%02x : ", icr);\r\nfor (i = 0; icrs[i].mask; ++i)\r\nif (icr & icrs[i].mask)\r\nprintk(KERN_CONT "%s, ", icrs[i].name);\r\nprintk(KERN_CONT "\nMR = 0x%02x : ", mr);\r\nfor (i = 0; mrs[i].mask; ++i)\r\nif (mr & mrs[i].mask)\r\nprintk(KERN_CONT "%s, ", mrs[i].name);\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic void NCR5380_print_phase(struct Scsi_Host *instance)\r\n{\r\nunsigned char status;\r\nint i;\r\nstatus = NCR5380_read(STATUS_REG);\r\nif (!(status & SR_REQ))\r\nshost_printk(KERN_DEBUG, instance, "REQ not asserted, phase unknown.\n");\r\nelse {\r\nfor (i = 0; (phases[i].value != PHASE_UNKNOWN) &&\r\n(phases[i].value != (status & PHASE_MASK)); ++i)\r\n;\r\nshost_printk(KERN_DEBUG, instance, "phase %s\n", phases[i].name);\r\n}\r\n}\r\nstatic irqreturn_t __init probe_intr(int irq, void *dev_id)\r\n{\r\nprobe_irq = irq;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init __maybe_unused NCR5380_probe_irq(struct Scsi_Host *instance,\r\nint possible)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned long timeout;\r\nint trying_irqs, i, mask;\r\nfor (trying_irqs = 0, i = 1, mask = 2; i < 16; ++i, mask <<= 1)\r\nif ((mask & possible) && (request_irq(i, &probe_intr, 0, "NCR-probe", NULL) == 0))\r\ntrying_irqs |= mask;\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nprobe_irq = NO_IRQ;\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nNCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA | ICR_ASSERT_SEL);\r\nwhile (probe_irq == NO_IRQ && time_before(jiffies, timeout))\r\nschedule_timeout_uninterruptible(1);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nfor (i = 1, mask = 2; i < 16; ++i, mask <<= 1)\r\nif (trying_irqs & mask)\r\nfree_irq(i, NULL);\r\nreturn probe_irq;\r\n}\r\nstatic const char *NCR5380_info(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nreturn hostdata->info;\r\n}\r\nstatic void prepare_info(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nsnprintf(hostdata->info, sizeof(hostdata->info),\r\n"%s, io_port 0x%lx, n_io_port %d, "\r\n"base 0x%lx, irq %d, "\r\n"can_queue %d, cmd_per_lun %d, "\r\n"sg_tablesize %d, this_id %d, "\r\n"flags { %s%s%s}, "\r\n"options { %s} ",\r\ninstance->hostt->name, instance->io_port, instance->n_io_port,\r\ninstance->base, instance->irq,\r\ninstance->can_queue, instance->cmd_per_lun,\r\ninstance->sg_tablesize, instance->this_id,\r\nhostdata->flags & FLAG_DMA_FIXUP ? "DMA_FIXUP " : "",\r\nhostdata->flags & FLAG_NO_PSEUDO_DMA ? "NO_PSEUDO_DMA " : "",\r\nhostdata->flags & FLAG_TOSHIBA_DELAY ? "TOSHIBA_DELAY " : "",\r\n#ifdef DIFFERENTIAL\r\n"DIFFERENTIAL "\r\n#endif\r\n#ifdef PARITY\r\n"PARITY "\r\n#endif\r\n"");\r\n}\r\nstatic int NCR5380_init(struct Scsi_Host *instance, int flags)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint i;\r\nunsigned long deadline;\r\ninstance->max_lun = 7;\r\nhostdata->host = instance;\r\nhostdata->id_mask = 1 << instance->this_id;\r\nhostdata->id_higher_mask = 0;\r\nfor (i = hostdata->id_mask; i <= 0x80; i <<= 1)\r\nif (i > hostdata->id_mask)\r\nhostdata->id_higher_mask |= i;\r\nfor (i = 0; i < 8; ++i)\r\nhostdata->busy[i] = 0;\r\nhostdata->dma_len = 0;\r\nspin_lock_init(&hostdata->lock);\r\nhostdata->connected = NULL;\r\nhostdata->sensing = NULL;\r\nINIT_LIST_HEAD(&hostdata->autosense);\r\nINIT_LIST_HEAD(&hostdata->unissued);\r\nINIT_LIST_HEAD(&hostdata->disconnected);\r\nhostdata->flags = flags;\r\nINIT_WORK(&hostdata->main_task, NCR5380_main);\r\nhostdata->work_q = alloc_workqueue("ncr5380_%d",\r\nWQ_UNBOUND | WQ_MEM_RECLAIM,\r\n1, instance->host_no);\r\nif (!hostdata->work_q)\r\nreturn -ENOMEM;\r\nprepare_info(instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\ni = 0;\r\ndeadline = jiffies + 1;\r\ndo {\r\ncpu_relax();\r\n} while (time_is_after_jiffies(deadline));\r\ndeadline += msecs_to_jiffies(256);\r\ndo {\r\nNCR5380_read(STATUS_REG);\r\n++i;\r\ncpu_relax();\r\n} while (time_is_after_jiffies(deadline));\r\nhostdata->accesses_per_ms = i / 256;\r\nreturn 0;\r\n}\r\nstatic int NCR5380_maybe_reset_bus(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint pass;\r\nfor (pass = 1; (NCR5380_read(STATUS_REG) & SR_BSY) && pass <= 6; ++pass) {\r\nswitch (pass) {\r\ncase 1:\r\ncase 3:\r\ncase 5:\r\nshost_printk(KERN_ERR, instance, "SCSI bus busy, waiting up to five seconds\n");\r\nNCR5380_poll_politely(instance,\r\nSTATUS_REG, SR_BSY, 0, 5 * HZ);\r\nbreak;\r\ncase 2:\r\nshost_printk(KERN_ERR, instance, "bus busy, attempting abort\n");\r\ndo_abort(instance);\r\nbreak;\r\ncase 4:\r\nshost_printk(KERN_ERR, instance, "bus busy, attempting reset\n");\r\ndo_reset(instance);\r\nif (hostdata->flags & FLAG_TOSHIBA_DELAY)\r\nmsleep(2500);\r\nelse\r\nmsleep(500);\r\nbreak;\r\ncase 6:\r\nshost_printk(KERN_ERR, instance, "bus locked solid\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void NCR5380_exit(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\ncancel_work_sync(&hostdata->main_task);\r\ndestroy_workqueue(hostdata->work_q);\r\n}\r\nstatic void complete_cmd(struct Scsi_Host *instance,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\ndsprintk(NDEBUG_QUEUES, instance, "complete_cmd: cmd %p\n", cmd);\r\nif (hostdata->sensing == cmd) {\r\nif ((cmd->result & 0xff) != SAM_STAT_GOOD) {\r\nscsi_eh_restore_cmnd(cmd, &hostdata->ses);\r\nset_host_byte(cmd, DID_ERROR);\r\n} else\r\nscsi_eh_restore_cmnd(cmd, &hostdata->ses);\r\nhostdata->sensing = NULL;\r\n}\r\nhostdata->busy[scmd_id(cmd)] &= ~(1 << cmd->device->lun);\r\ncmd->scsi_done(cmd);\r\n}\r\nstatic int NCR5380_queue_command(struct Scsi_Host *instance,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nstruct NCR5380_cmd *ncmd = scsi_cmd_priv(cmd);\r\nunsigned long flags;\r\n#if (NDEBUG & NDEBUG_NO_WRITE)\r\nswitch (cmd->cmnd[0]) {\r\ncase WRITE_6:\r\ncase WRITE_10:\r\nshost_printk(KERN_DEBUG, instance, "WRITE attempted with NDEBUG_NO_WRITE set\n");\r\ncmd->result = (DID_ERROR << 16);\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\n#endif\r\ncmd->result = 0;\r\nif (!NCR5380_acquire_dma_irq(instance))\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nspin_lock_irqsave(&hostdata->lock, flags);\r\nif (cmd->cmnd[0] == REQUEST_SENSE)\r\nlist_add(&ncmd->list, &hostdata->unissued);\r\nelse\r\nlist_add_tail(&ncmd->list, &hostdata->unissued);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\ndsprintk(NDEBUG_QUEUES, instance, "command %p added to %s of queue\n",\r\ncmd, (cmd->cmnd[0] == REQUEST_SENSE) ? "head" : "tail");\r\nqueue_work(hostdata->work_q, &hostdata->main_task);\r\nreturn 0;\r\n}\r\nstatic inline void maybe_release_dma_irq(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nif (list_empty(&hostdata->disconnected) &&\r\nlist_empty(&hostdata->unissued) &&\r\nlist_empty(&hostdata->autosense) &&\r\n!hostdata->connected &&\r\n!hostdata->selecting)\r\nNCR5380_release_dma_irq(instance);\r\n}\r\nstatic struct scsi_cmnd *dequeue_next_cmd(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nstruct NCR5380_cmd *ncmd;\r\nstruct scsi_cmnd *cmd;\r\nif (hostdata->sensing || list_empty(&hostdata->autosense)) {\r\nlist_for_each_entry(ncmd, &hostdata->unissued, list) {\r\ncmd = NCR5380_to_scmd(ncmd);\r\ndsprintk(NDEBUG_QUEUES, instance, "dequeue: cmd=%p target=%d busy=0x%02x lun=%llu\n",\r\ncmd, scmd_id(cmd), hostdata->busy[scmd_id(cmd)], cmd->device->lun);\r\nif (!(hostdata->busy[scmd_id(cmd)] & (1 << cmd->device->lun))) {\r\nlist_del(&ncmd->list);\r\ndsprintk(NDEBUG_QUEUES, instance,\r\n"dequeue: removed %p from issue queue\n", cmd);\r\nreturn cmd;\r\n}\r\n}\r\n} else {\r\nncmd = list_first_entry(&hostdata->autosense,\r\nstruct NCR5380_cmd, list);\r\nlist_del(&ncmd->list);\r\ncmd = NCR5380_to_scmd(ncmd);\r\ndsprintk(NDEBUG_QUEUES, instance,\r\n"dequeue: removed %p from autosense queue\n", cmd);\r\nscsi_eh_prep_cmnd(cmd, &hostdata->ses, NULL, 0, ~0);\r\nhostdata->sensing = cmd;\r\nreturn cmd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void requeue_cmd(struct Scsi_Host *instance, struct scsi_cmnd *cmd)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nstruct NCR5380_cmd *ncmd = scsi_cmd_priv(cmd);\r\nif (hostdata->sensing == cmd) {\r\nscsi_eh_restore_cmnd(cmd, &hostdata->ses);\r\nlist_add(&ncmd->list, &hostdata->autosense);\r\nhostdata->sensing = NULL;\r\n} else\r\nlist_add(&ncmd->list, &hostdata->unissued);\r\n}\r\nstatic void NCR5380_main(struct work_struct *work)\r\n{\r\nstruct NCR5380_hostdata *hostdata =\r\ncontainer_of(work, struct NCR5380_hostdata, main_task);\r\nstruct Scsi_Host *instance = hostdata->host;\r\nint done;\r\ndo {\r\ndone = 1;\r\nspin_lock_irq(&hostdata->lock);\r\nwhile (!hostdata->connected && !hostdata->selecting) {\r\nstruct scsi_cmnd *cmd = dequeue_next_cmd(instance);\r\nif (!cmd)\r\nbreak;\r\ndsprintk(NDEBUG_MAIN, instance, "main: dequeued %p\n", cmd);\r\nif (!NCR5380_select(instance, cmd)) {\r\ndsprintk(NDEBUG_MAIN, instance, "main: select complete\n");\r\nmaybe_release_dma_irq(instance);\r\n} else {\r\ndsprintk(NDEBUG_MAIN | NDEBUG_QUEUES, instance,\r\n"main: select failed, returning %p to queue\n", cmd);\r\nrequeue_cmd(instance, cmd);\r\n}\r\n}\r\nif (hostdata->connected && !hostdata->dma_len) {\r\ndsprintk(NDEBUG_MAIN, instance, "main: performing information transfer\n");\r\nNCR5380_information_transfer(instance);\r\ndone = 0;\r\n}\r\nspin_unlock_irq(&hostdata->lock);\r\nif (!done)\r\ncond_resched();\r\n} while (!done);\r\n}\r\nstatic void NCR5380_dma_complete(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint transferred;\r\nunsigned char **data;\r\nint *count;\r\nint saved_data = 0, overrun = 0;\r\nunsigned char p;\r\nif (hostdata->read_overruns) {\r\np = hostdata->connected->SCp.phase;\r\nif (p & SR_IO) {\r\nudelay(10);\r\nif ((NCR5380_read(BUS_AND_STATUS_REG) &\r\n(BASR_PHASE_MATCH | BASR_ACK)) ==\r\n(BASR_PHASE_MATCH | BASR_ACK)) {\r\nsaved_data = NCR5380_read(INPUT_DATA_REG);\r\noverrun = 1;\r\ndsprintk(NDEBUG_DMA, instance, "read overrun handled\n");\r\n}\r\n}\r\n}\r\n#ifdef CONFIG_SUN3\r\nif ((sun3scsi_dma_finish(rq_data_dir(hostdata->connected->request)))) {\r\npr_err("scsi%d: overrun in UDC counter -- not prepared to deal with this!\n",\r\ninstance->host_no);\r\nBUG();\r\n}\r\nif ((NCR5380_read(BUS_AND_STATUS_REG) & (BASR_PHASE_MATCH | BASR_ACK)) ==\r\n(BASR_PHASE_MATCH | BASR_ACK)) {\r\npr_err("scsi%d: BASR %02x\n", instance->host_no,\r\nNCR5380_read(BUS_AND_STATUS_REG));\r\npr_err("scsi%d: bus stuck in data phase -- probably a single byte overrun!\n",\r\ninstance->host_no);\r\nBUG();\r\n}\r\n#endif\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\ntransferred = hostdata->dma_len - NCR5380_dma_residual(instance);\r\nhostdata->dma_len = 0;\r\ndata = (unsigned char **)&hostdata->connected->SCp.ptr;\r\ncount = &hostdata->connected->SCp.this_residual;\r\n*data += transferred;\r\n*count -= transferred;\r\nif (hostdata->read_overruns) {\r\nint cnt, toPIO;\r\nif ((NCR5380_read(STATUS_REG) & PHASE_MASK) == p && (p & SR_IO)) {\r\ncnt = toPIO = hostdata->read_overruns;\r\nif (overrun) {\r\ndsprintk(NDEBUG_DMA, instance,\r\n"Got an input overrun, using saved byte\n");\r\n*(*data)++ = saved_data;\r\n(*count)--;\r\ncnt--;\r\ntoPIO--;\r\n}\r\nif (toPIO > 0) {\r\ndsprintk(NDEBUG_DMA, instance,\r\n"Doing %d byte PIO to 0x%p\n", cnt, *data);\r\nNCR5380_transfer_pio(instance, &p, &cnt, data);\r\n*count -= toPIO - cnt;\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t __maybe_unused NCR5380_intr(int irq, void *dev_id)\r\n{\r\nstruct Scsi_Host *instance = dev_id;\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint handled = 0;\r\nunsigned char basr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hostdata->lock, flags);\r\nbasr = NCR5380_read(BUS_AND_STATUS_REG);\r\nif (basr & BASR_IRQ) {\r\nunsigned char mr = NCR5380_read(MODE_REG);\r\nunsigned char sr = NCR5380_read(STATUS_REG);\r\ndsprintk(NDEBUG_INTR, instance, "IRQ %d, BASR 0x%02x, SR 0x%02x, MR 0x%02x\n",\r\nirq, basr, sr, mr);\r\nif ((mr & MR_DMA_MODE) || (mr & MR_MONITOR_BSY)) {\r\ndsprintk(NDEBUG_INTR, instance, "interrupt in DMA mode\n");\r\nif (hostdata->connected) {\r\nNCR5380_dma_complete(instance);\r\nqueue_work(hostdata->work_q, &hostdata->main_task);\r\n} else {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n}\r\n} else if ((NCR5380_read(CURRENT_SCSI_DATA_REG) & hostdata->id_mask) &&\r\n(sr & (SR_SEL | SR_IO | SR_BSY | SR_RST)) == (SR_SEL | SR_IO)) {\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\ndsprintk(NDEBUG_INTR, instance, "interrupt with SEL and IO\n");\r\nif (!hostdata->connected) {\r\nNCR5380_reselect(instance);\r\nqueue_work(hostdata->work_q, &hostdata->main_task);\r\n}\r\nif (!hostdata->connected)\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\n} else {\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\ndsprintk(NDEBUG_INTR, instance, "unknown interrupt\n");\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\n}\r\nhandled = 1;\r\n} else {\r\nshost_printk(KERN_NOTICE, instance, "interrupt without IRQ bit\n");\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\n}\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic struct scsi_cmnd *NCR5380_select(struct Scsi_Host *instance,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned char tmp[3], phase;\r\nunsigned char *data;\r\nint len;\r\nint err;\r\nNCR5380_dprint(NDEBUG_ARBITRATION, instance);\r\ndsprintk(NDEBUG_ARBITRATION, instance, "starting arbitration, id = %d\n",\r\ninstance->this_id);\r\nhostdata->selecting = cmd;\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask);\r\nNCR5380_write(MODE_REG, MR_ARBITRATE);\r\nspin_unlock_irq(&hostdata->lock);\r\nerr = NCR5380_poll_politely2(instance, MODE_REG, MR_ARBITRATE, 0,\r\nINITIATOR_COMMAND_REG, ICR_ARBITRATION_PROGRESS,\r\nICR_ARBITRATION_PROGRESS, HZ);\r\nspin_lock_irq(&hostdata->lock);\r\nif (!(NCR5380_read(MODE_REG) & MR_ARBITRATE)) {\r\ngoto out;\r\n}\r\nif (!hostdata->selecting) {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\ngoto out;\r\n}\r\nif (err < 0) {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nshost_printk(KERN_ERR, instance,\r\n"select: arbitration timeout\n");\r\ngoto out;\r\n}\r\nspin_unlock_irq(&hostdata->lock);\r\nudelay(3);\r\nif ((NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||\r\n(NCR5380_read(CURRENT_SCSI_DATA_REG) & hostdata->id_higher_mask) ||\r\n(NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST)) {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\ndsprintk(NDEBUG_ARBITRATION, instance, "lost arbitration, deasserting MR_ARBITRATE\n");\r\nspin_lock_irq(&hostdata->lock);\r\ngoto out;\r\n}\r\nNCR5380_write(INITIATOR_COMMAND_REG,\r\nICR_BASE | ICR_ASSERT_SEL | ICR_ASSERT_BSY);\r\nif (hostdata->flags & FLAG_TOSHIBA_DELAY)\r\nudelay(15);\r\nelse\r\nudelay(2);\r\nspin_lock_irq(&hostdata->lock);\r\nif (!(NCR5380_read(MODE_REG) & MR_ARBITRATE))\r\ngoto out;\r\nif (!hostdata->selecting) {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\ngoto out;\r\n}\r\ndsprintk(NDEBUG_ARBITRATION, instance, "won arbitration\n");\r\nNCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask | (1 << scmd_id(cmd)));\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_BSY |\r\nICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_SEL);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nspin_unlock_irq(&hostdata->lock);\r\nudelay(1);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA |\r\nICR_ASSERT_ATN | ICR_ASSERT_SEL);\r\nudelay(1);\r\ndsprintk(NDEBUG_SELECTION, instance, "selecting target %d\n", scmd_id(cmd));\r\nerr = NCR5380_poll_politely(instance, STATUS_REG, SR_BSY, SR_BSY,\r\nmsecs_to_jiffies(250));\r\nif ((NCR5380_read(STATUS_REG) & (SR_SEL | SR_IO)) == (SR_SEL | SR_IO)) {\r\nspin_lock_irq(&hostdata->lock);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_reselect(instance);\r\nif (!hostdata->connected)\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nshost_printk(KERN_ERR, instance, "reselection after won arbitration?\n");\r\ngoto out;\r\n}\r\nif (err < 0) {\r\nspin_lock_irq(&hostdata->lock);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nif (hostdata->selecting) {\r\ncmd->result = DID_BAD_TARGET << 16;\r\ncomplete_cmd(instance, cmd);\r\ndsprintk(NDEBUG_SELECTION, instance, "target did not respond within 250ms\n");\r\ncmd = NULL;\r\n}\r\ngoto out;\r\n}\r\nudelay(1);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nerr = NCR5380_poll_politely(instance, STATUS_REG, SR_REQ, SR_REQ, HZ);\r\nspin_lock_irq(&hostdata->lock);\r\nif (err < 0) {\r\nshost_printk(KERN_ERR, instance, "select: REQ timeout\n");\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\ngoto out;\r\n}\r\nif (!hostdata->selecting) {\r\ndo_abort(instance);\r\ngoto out;\r\n}\r\ndsprintk(NDEBUG_SELECTION, instance, "target %d selected, going into MESSAGE OUT phase.\n",\r\nscmd_id(cmd));\r\ntmp[0] = IDENTIFY(((instance->irq == NO_IRQ) ? 0 : 1), cmd->device->lun);\r\nlen = 1;\r\ndata = tmp;\r\nphase = PHASE_MSGOUT;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ndsprintk(NDEBUG_SELECTION, instance, "nexus established.\n");\r\nhostdata->connected = cmd;\r\nhostdata->busy[cmd->device->id] |= 1 << cmd->device->lun;\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_INTR;\r\n#endif\r\ninitialize_SCp(cmd);\r\ncmd = NULL;\r\nout:\r\nif (!hostdata->selecting)\r\nreturn NULL;\r\nhostdata->selecting = NULL;\r\nreturn cmd;\r\n}\r\nstatic int NCR5380_transfer_pio(struct Scsi_Host *instance,\r\nunsigned char *phase, int *count,\r\nunsigned char **data)\r\n{\r\nunsigned char p = *phase, tmp;\r\nint c = *count;\r\nunsigned char *d = *data;\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));\r\ndo {\r\nif (NCR5380_poll_politely(instance, STATUS_REG, SR_REQ, SR_REQ, HZ) < 0)\r\nbreak;\r\ndsprintk(NDEBUG_HANDSHAKE, instance, "REQ asserted\n");\r\nif ((NCR5380_read(STATUS_REG) & PHASE_MASK) != p) {\r\ndsprintk(NDEBUG_PIO, instance, "phase mismatch\n");\r\nNCR5380_dprint_phase(NDEBUG_PIO, instance);\r\nbreak;\r\n}\r\nif (!(p & SR_IO))\r\nNCR5380_write(OUTPUT_DATA_REG, *d);\r\nelse\r\n*d = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\n++d;\r\nif (!(p & SR_IO)) {\r\nif (!((p & SR_MSG) && c > 1)) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_DATA | ICR_ASSERT_ACK);\r\n} else {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_DATA | ICR_ASSERT_ATN);\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_ACK);\r\n}\r\n} else {\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);\r\n}\r\nif (NCR5380_poll_politely(instance,\r\nSTATUS_REG, SR_REQ, 0, 5 * HZ) < 0)\r\nbreak;\r\ndsprintk(NDEBUG_HANDSHAKE, instance, "REQ negated, handshake complete\n");\r\nif (!(p == PHASE_MSGIN && c == 1)) {\r\nif (p == PHASE_MSGOUT && c > 1)\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nelse\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\n}\r\n} while (--c);\r\ndsprintk(NDEBUG_PIO, instance, "residual %d\n", c);\r\n*count = c;\r\n*data = d;\r\ntmp = NCR5380_read(STATUS_REG);\r\nif ((tmp & SR_REQ) || ((tmp & SR_IO) && c == 0))\r\n*phase = tmp & PHASE_MASK;\r\nelse\r\n*phase = PHASE_UNKNOWN;\r\nif (!c || (*phase == p))\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n}\r\nstatic void do_reset(struct Scsi_Host *instance)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nNCR5380_write(TARGET_COMMAND_REG,\r\nPHASE_SR_TO_TCR(NCR5380_read(STATUS_REG) & PHASE_MASK));\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST);\r\nudelay(50);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\n(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int do_abort(struct Scsi_Host *instance)\r\n{\r\nunsigned char *msgptr, phase, tmp;\r\nint len;\r\nint rc;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nrc = NCR5380_poll_politely(instance, STATUS_REG, SR_REQ, SR_REQ, 10 * HZ);\r\nif (rc < 0)\r\ngoto timeout;\r\ntmp = NCR5380_read(STATUS_REG) & PHASE_MASK;\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));\r\nif (tmp != PHASE_MSGOUT) {\r\nNCR5380_write(INITIATOR_COMMAND_REG,\r\nICR_BASE | ICR_ASSERT_ATN | ICR_ASSERT_ACK);\r\nrc = NCR5380_poll_politely(instance, STATUS_REG, SR_REQ, 0, 3 * HZ);\r\nif (rc < 0)\r\ngoto timeout;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\n}\r\ntmp = ABORT;\r\nmsgptr = &tmp;\r\nlen = 1;\r\nphase = PHASE_MSGOUT;\r\nNCR5380_transfer_pio(instance, &phase, &len, &msgptr);\r\nreturn len ? -1 : 0;\r\ntimeout:\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nreturn -1;\r\n}\r\nstatic int NCR5380_transfer_dma(struct Scsi_Host *instance,\r\nunsigned char *phase, int *count,\r\nunsigned char **data)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint c = *count;\r\nunsigned char p = *phase;\r\nunsigned char *d = *data;\r\nunsigned char tmp;\r\nint result = 0;\r\nif ((tmp = (NCR5380_read(STATUS_REG) & PHASE_MASK)) != p) {\r\n*phase = tmp;\r\nreturn -1;\r\n}\r\nhostdata->connected->SCp.phase = p;\r\nif (p & SR_IO) {\r\nif (hostdata->read_overruns)\r\nc -= hostdata->read_overruns;\r\nelse if (hostdata->flags & FLAG_DMA_FIXUP)\r\n--c;\r\n}\r\ndsprintk(NDEBUG_DMA, instance, "initializing DMA %s: length %d, address %p\n",\r\n(p & SR_IO) ? "receive" : "send", c, d);\r\n#ifdef CONFIG_SUN3\r\nsun3scsi_dma_start(c, *data);\r\n#endif\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));\r\nNCR5380_write(MODE_REG, MR_BASE | MR_DMA_MODE | MR_MONITOR_BSY |\r\nMR_ENABLE_EOP_INTR);\r\nif (!(hostdata->flags & FLAG_LATE_DMA_SETUP)) {\r\nif (p & SR_IO)\r\nresult = NCR5380_dma_recv_setup(instance, d, c);\r\nelse\r\nresult = NCR5380_dma_send_setup(instance, d, c);\r\n}\r\nif (p & SR_IO) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_io_delay(1);\r\nNCR5380_write(START_DMA_INITIATOR_RECEIVE_REG, 0);\r\n} else {\r\nNCR5380_io_delay(1);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);\r\nNCR5380_io_delay(1);\r\nNCR5380_write(START_DMA_SEND_REG, 0);\r\nNCR5380_io_delay(1);\r\n}\r\n#ifdef CONFIG_SUN3\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\nsun3_dma_active = 1;\r\n#endif\r\nif (hostdata->flags & FLAG_LATE_DMA_SETUP) {\r\nif (p & SR_IO)\r\nresult = NCR5380_dma_recv_setup(instance, d, c);\r\nelse\r\nresult = NCR5380_dma_send_setup(instance, d, c);\r\n}\r\nif (result < 0)\r\nreturn result;\r\nif (result > 0) {\r\nhostdata->dma_len = result;\r\nreturn 0;\r\n}\r\nhostdata->dma_len = c;\r\nif (hostdata->flags & FLAG_DMA_FIXUP) {\r\nif (p & SR_IO) {\r\nif (NCR5380_poll_politely(instance, BUS_AND_STATUS_REG,\r\nBASR_DRQ, BASR_DRQ, HZ) < 0) {\r\nresult = -1;\r\nshost_printk(KERN_ERR, instance, "PDMA read: DRQ timeout\n");\r\n}\r\nif (NCR5380_poll_politely(instance, STATUS_REG,\r\nSR_REQ, 0, HZ) < 0) {\r\nresult = -1;\r\nshost_printk(KERN_ERR, instance, "PDMA read: !REQ timeout\n");\r\n}\r\nd[*count - 1] = NCR5380_read(INPUT_DATA_REG);\r\n} else {\r\nif (NCR5380_poll_politely2(instance,\r\nBUS_AND_STATUS_REG, BASR_DRQ, BASR_DRQ,\r\nBUS_AND_STATUS_REG, BASR_PHASE_MATCH, 0, HZ) < 0) {\r\nresult = -1;\r\nshost_printk(KERN_ERR, instance, "PDMA write: DRQ and phase timeout\n");\r\n}\r\n}\r\n}\r\nNCR5380_dma_complete(instance);\r\nreturn result;\r\n}\r\nstatic void NCR5380_information_transfer(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned char msgout = NOP;\r\nint sink = 0;\r\nint len;\r\nint transfersize;\r\nunsigned char *data;\r\nunsigned char phase, tmp, extended_msg[10], old_phase = 0xff;\r\nstruct scsi_cmnd *cmd;\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_INTR;\r\n#endif\r\nwhile ((cmd = hostdata->connected)) {\r\nstruct NCR5380_cmd *ncmd = scsi_cmd_priv(cmd);\r\ntmp = NCR5380_read(STATUS_REG);\r\nif (tmp & SR_REQ) {\r\nphase = (tmp & PHASE_MASK);\r\nif (phase != old_phase) {\r\nold_phase = phase;\r\nNCR5380_dprint_phase(NDEBUG_INFORMATION, instance);\r\n}\r\n#ifdef CONFIG_SUN3\r\nif (phase == PHASE_CMDOUT) {\r\nvoid *d;\r\nunsigned long count;\r\nif (!cmd->SCp.this_residual && cmd->SCp.buffers_residual) {\r\ncount = cmd->SCp.buffer->length;\r\nd = sg_virt(cmd->SCp.buffer);\r\n} else {\r\ncount = cmd->SCp.this_residual;\r\nd = cmd->SCp.ptr;\r\n}\r\nif (sun3_dma_setup_done != cmd &&\r\nsun3scsi_dma_xfer_len(count, cmd) > 0) {\r\nsun3scsi_dma_setup(instance, d, count,\r\nrq_data_dir(cmd->request));\r\nsun3_dma_setup_done = cmd;\r\n}\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_INTR;\r\n#endif\r\n}\r\n#endif\r\nif (sink && (phase != PHASE_MSGOUT)) {\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN |\r\nICR_ASSERT_ACK);\r\nwhile (NCR5380_read(STATUS_REG) & SR_REQ)\r\n;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_ATN);\r\nsink = 0;\r\ncontinue;\r\n}\r\nswitch (phase) {\r\ncase PHASE_DATAOUT:\r\n#if (NDEBUG & NDEBUG_NO_DATAOUT)\r\nshost_printk(KERN_DEBUG, instance, "NDEBUG_NO_DATAOUT set, attempted DATAOUT aborted\n");\r\nsink = 1;\r\ndo_abort(instance);\r\ncmd->result = DID_ERROR << 16;\r\ncomplete_cmd(instance, cmd);\r\nhostdata->connected = NULL;\r\nreturn;\r\n#endif\r\ncase PHASE_DATAIN:\r\nif (!cmd->SCp.this_residual && cmd->SCp.buffers_residual) {\r\n++cmd->SCp.buffer;\r\n--cmd->SCp.buffers_residual;\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\ndsprintk(NDEBUG_INFORMATION, instance, "%d bytes and %d buffers left\n",\r\ncmd->SCp.this_residual,\r\ncmd->SCp.buffers_residual);\r\n}\r\ntransfersize = 0;\r\nif (!cmd->device->borken)\r\ntransfersize = NCR5380_dma_xfer_len(instance, cmd, phase);\r\nif (transfersize > 0) {\r\nlen = transfersize;\r\nif (NCR5380_transfer_dma(instance, &phase,\r\n&len, (unsigned char **)&cmd->SCp.ptr)) {\r\nscmd_printk(KERN_INFO, cmd,\r\n"switching to slow handshake\n");\r\ncmd->device->borken = 1;\r\nsink = 1;\r\ndo_abort(instance);\r\ncmd->result = DID_ERROR << 16;\r\n}\r\n} else {\r\ntransfersize = min((unsigned long)cmd->SCp.this_residual,\r\nhostdata->accesses_per_ms / 2);\r\nlen = transfersize;\r\nNCR5380_transfer_pio(instance, &phase, &len,\r\n(unsigned char **)&cmd->SCp.ptr);\r\ncmd->SCp.this_residual -= transfersize - len;\r\n}\r\n#ifdef CONFIG_SUN3\r\nif (sun3_dma_setup_done == cmd)\r\nsun3_dma_setup_done = NULL;\r\n#endif\r\nreturn;\r\ncase PHASE_MSGIN:\r\nlen = 1;\r\ndata = &tmp;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ncmd->SCp.Message = tmp;\r\nswitch (tmp) {\r\ncase ABORT:\r\ncase COMMAND_COMPLETE:\r\nsink = 1;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\ndsprintk(NDEBUG_QUEUES, instance,\r\n"COMMAND COMPLETE %p target %d lun %llu\n",\r\ncmd, scmd_id(cmd), cmd->device->lun);\r\nhostdata->connected = NULL;\r\ncmd->result &= ~0xffff;\r\ncmd->result |= cmd->SCp.Status;\r\ncmd->result |= cmd->SCp.Message << 8;\r\nif (cmd->cmnd[0] == REQUEST_SENSE)\r\ncomplete_cmd(instance, cmd);\r\nelse {\r\nif (cmd->SCp.Status == SAM_STAT_CHECK_CONDITION ||\r\ncmd->SCp.Status == SAM_STAT_COMMAND_TERMINATED) {\r\ndsprintk(NDEBUG_QUEUES, instance, "autosense: adding cmd %p to tail of autosense queue\n",\r\ncmd);\r\nlist_add_tail(&ncmd->list,\r\n&hostdata->autosense);\r\n} else\r\ncomplete_cmd(instance, cmd);\r\n}\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nmaybe_release_dma_irq(instance);\r\nreturn;\r\ncase MESSAGE_REJECT:\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nswitch (hostdata->last_message) {\r\ncase HEAD_OF_QUEUE_TAG:\r\ncase ORDERED_QUEUE_TAG:\r\ncase SIMPLE_QUEUE_TAG:\r\ncmd->device->simple_tags = 0;\r\nhostdata->busy[cmd->device->id] |= (1 << (cmd->device->lun & 0xFF));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase DISCONNECT:\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nhostdata->connected = NULL;\r\nlist_add(&ncmd->list, &hostdata->disconnected);\r\ndsprintk(NDEBUG_INFORMATION | NDEBUG_QUEUES,\r\ninstance, "connected command %p for target %d lun %llu moved to disconnected queue\n",\r\ncmd, scmd_id(cmd), cmd->device->lun);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\nreturn;\r\ncase SAVE_POINTERS:\r\ncase RESTORE_POINTERS:\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nextended_msg[0] = EXTENDED_MESSAGE;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nspin_unlock_irq(&hostdata->lock);\r\ndsprintk(NDEBUG_EXTENDED, instance, "receiving extended message\n");\r\nlen = 2;\r\ndata = extended_msg + 1;\r\nphase = PHASE_MSGIN;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ndsprintk(NDEBUG_EXTENDED, instance, "length %d, code 0x%02x\n",\r\n(int)extended_msg[1],\r\n(int)extended_msg[2]);\r\nif (!len && extended_msg[1] > 0 &&\r\nextended_msg[1] <= sizeof(extended_msg) - 2) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nlen = extended_msg[1] - 1;\r\ndata = extended_msg + 3;\r\nphase = PHASE_MSGIN;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ndsprintk(NDEBUG_EXTENDED, instance, "message received, residual %d\n",\r\nlen);\r\nswitch (extended_msg[2]) {\r\ncase EXTENDED_SDTR:\r\ncase EXTENDED_WDTR:\r\ncase EXTENDED_MODIFY_DATA_POINTER:\r\ncase EXTENDED_EXTENDED_IDENTIFY:\r\ntmp = 0;\r\n}\r\n} else if (len) {\r\nshost_printk(KERN_ERR, instance, "error receiving extended message\n");\r\ntmp = 0;\r\n} else {\r\nshost_printk(KERN_NOTICE, instance, "extended message code %02x length %d is too long\n",\r\nextended_msg[2], extended_msg[1]);\r\ntmp = 0;\r\n}\r\nspin_lock_irq(&hostdata->lock);\r\nif (!hostdata->connected)\r\nreturn;\r\ndefault:\r\nif (!tmp) {\r\nshost_printk(KERN_ERR, instance, "rejecting message ");\r\nspi_print_msg(extended_msg);\r\nprintk("\n");\r\n} else if (tmp != EXTENDED_MESSAGE)\r\nscmd_printk(KERN_INFO, cmd,\r\n"rejecting unknown message %02x\n",\r\ntmp);\r\nelse\r\nscmd_printk(KERN_INFO, cmd,\r\n"rejecting unknown extended message code %02x, length %d\n",\r\nextended_msg[1], extended_msg[0]);\r\nmsgout = MESSAGE_REJECT;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nbreak;\r\n}\r\nbreak;\r\ncase PHASE_MSGOUT:\r\nlen = 1;\r\ndata = &msgout;\r\nhostdata->last_message = msgout;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\nif (msgout == ABORT) {\r\nhostdata->connected = NULL;\r\ncmd->result = DID_ERROR << 16;\r\ncomplete_cmd(instance, cmd);\r\nmaybe_release_dma_irq(instance);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nreturn;\r\n}\r\nmsgout = NOP;\r\nbreak;\r\ncase PHASE_CMDOUT:\r\nlen = cmd->cmd_len;\r\ndata = cmd->cmnd;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\nbreak;\r\ncase PHASE_STATIN:\r\nlen = 1;\r\ndata = &tmp;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ncmd->SCp.Status = tmp;\r\nbreak;\r\ndefault:\r\nshost_printk(KERN_ERR, instance, "unknown phase\n");\r\nNCR5380_dprint(NDEBUG_ANY, instance);\r\n}\r\n} else {\r\nspin_unlock_irq(&hostdata->lock);\r\nNCR5380_poll_politely(instance, STATUS_REG, SR_REQ, SR_REQ, HZ);\r\nspin_lock_irq(&hostdata->lock);\r\n}\r\n}\r\n}\r\nstatic void NCR5380_reselect(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned char target_mask;\r\nunsigned char lun;\r\nunsigned char msg[3];\r\nstruct NCR5380_cmd *ncmd;\r\nstruct scsi_cmnd *tmp;\r\nNCR5380_write(MODE_REG, MR_BASE);\r\ntarget_mask = NCR5380_read(CURRENT_SCSI_DATA_REG) & ~(hostdata->id_mask);\r\ndsprintk(NDEBUG_RESELECTION, instance, "reselect\n");\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_BSY);\r\nif (NCR5380_poll_politely(instance,\r\nSTATUS_REG, SR_SEL, 0, 2 * HZ) < 0) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nreturn;\r\n}\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nif (NCR5380_poll_politely(instance,\r\nSTATUS_REG, SR_REQ, SR_REQ, 2 * HZ) < 0) {\r\ndo_abort(instance);\r\nreturn;\r\n}\r\n#ifdef CONFIG_SUN3\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(PHASE_MSGIN));\r\nmsg[0] = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\n#else\r\n{\r\nint len = 1;\r\nunsigned char *data = msg;\r\nunsigned char phase = PHASE_MSGIN;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\nif (len) {\r\ndo_abort(instance);\r\nreturn;\r\n}\r\n}\r\n#endif\r\nif (!(msg[0] & 0x80)) {\r\nshost_printk(KERN_ERR, instance, "expecting IDENTIFY message, got ");\r\nspi_print_msg(msg);\r\nprintk("\n");\r\ndo_abort(instance);\r\nreturn;\r\n}\r\nlun = msg[0] & 0x07;\r\ntmp = NULL;\r\nlist_for_each_entry(ncmd, &hostdata->disconnected, list) {\r\nstruct scsi_cmnd *cmd = NCR5380_to_scmd(ncmd);\r\nif (target_mask == (1 << scmd_id(cmd)) &&\r\nlun == (u8)cmd->device->lun) {\r\nlist_del(&ncmd->list);\r\ntmp = cmd;\r\nbreak;\r\n}\r\n}\r\nif (tmp) {\r\ndsprintk(NDEBUG_RESELECTION | NDEBUG_QUEUES, instance,\r\n"reselect: removed %p from disconnected queue\n", tmp);\r\n} else {\r\nshost_printk(KERN_ERR, instance, "target bitmask 0x%02x lun %d not in disconnected queue.\n",\r\ntarget_mask, lun);\r\ndo_abort(instance);\r\nreturn;\r\n}\r\n#ifdef CONFIG_SUN3\r\n{\r\nvoid *d;\r\nunsigned long count;\r\nif (!tmp->SCp.this_residual && tmp->SCp.buffers_residual) {\r\ncount = tmp->SCp.buffer->length;\r\nd = sg_virt(tmp->SCp.buffer);\r\n} else {\r\ncount = tmp->SCp.this_residual;\r\nd = tmp->SCp.ptr;\r\n}\r\nif (sun3_dma_setup_done != tmp &&\r\nsun3scsi_dma_xfer_len(count, tmp) > 0) {\r\nsun3scsi_dma_setup(instance, d, count,\r\nrq_data_dir(tmp->request));\r\nsun3_dma_setup_done = tmp;\r\n}\r\n}\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);\r\n#endif\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nhostdata->connected = tmp;\r\ndsprintk(NDEBUG_RESELECTION, instance, "nexus established, target %d, lun %llu\n",\r\nscmd_id(tmp), tmp->device->lun);\r\n}\r\nstatic bool list_find_cmd(struct list_head *haystack,\r\nstruct scsi_cmnd *needle)\r\n{\r\nstruct NCR5380_cmd *ncmd;\r\nlist_for_each_entry(ncmd, haystack, list)\r\nif (NCR5380_to_scmd(ncmd) == needle)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool list_del_cmd(struct list_head *haystack,\r\nstruct scsi_cmnd *needle)\r\n{\r\nif (list_find_cmd(haystack, needle)) {\r\nstruct NCR5380_cmd *ncmd = scsi_cmd_priv(needle);\r\nlist_del(&ncmd->list);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int NCR5380_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned long flags;\r\nint result = SUCCESS;\r\nspin_lock_irqsave(&hostdata->lock, flags);\r\n#if (NDEBUG & NDEBUG_ANY)\r\nscmd_printk(KERN_INFO, cmd, __func__);\r\n#endif\r\nNCR5380_dprint(NDEBUG_ANY, instance);\r\nNCR5380_dprint_phase(NDEBUG_ANY, instance);\r\nif (list_del_cmd(&hostdata->unissued, cmd)) {\r\ndsprintk(NDEBUG_ABORT, instance,\r\n"abort: removed %p from issue queue\n", cmd);\r\ncmd->result = DID_ABORT << 16;\r\ncmd->scsi_done(cmd);\r\ngoto out;\r\n}\r\nif (hostdata->selecting == cmd) {\r\ndsprintk(NDEBUG_ABORT, instance,\r\n"abort: cmd %p == selecting\n", cmd);\r\nhostdata->selecting = NULL;\r\ncmd->result = DID_ABORT << 16;\r\ncomplete_cmd(instance, cmd);\r\ngoto out;\r\n}\r\nif (list_del_cmd(&hostdata->disconnected, cmd)) {\r\ndsprintk(NDEBUG_ABORT, instance,\r\n"abort: removed %p from disconnected list\n", cmd);\r\nset_host_byte(cmd, DID_ERROR);\r\ncomplete_cmd(instance, cmd);\r\nresult = FAILED;\r\ngoto out;\r\n}\r\nif (hostdata->connected == cmd) {\r\ndsprintk(NDEBUG_ABORT, instance, "abort: cmd %p is connected\n", cmd);\r\nhostdata->connected = NULL;\r\nhostdata->dma_len = 0;\r\nif (do_abort(instance)) {\r\nset_host_byte(cmd, DID_ERROR);\r\ncomplete_cmd(instance, cmd);\r\nresult = FAILED;\r\ngoto out;\r\n}\r\nset_host_byte(cmd, DID_ABORT);\r\ncomplete_cmd(instance, cmd);\r\ngoto out;\r\n}\r\nif (list_del_cmd(&hostdata->autosense, cmd)) {\r\ndsprintk(NDEBUG_ABORT, instance,\r\n"abort: removed %p from sense queue\n", cmd);\r\nset_host_byte(cmd, DID_ERROR);\r\ncomplete_cmd(instance, cmd);\r\n}\r\nout:\r\nif (result == FAILED)\r\ndsprintk(NDEBUG_ABORT, instance, "abort: failed to abort %p\n", cmd);\r\nelse\r\ndsprintk(NDEBUG_ABORT, instance, "abort: successfully aborted %p\n", cmd);\r\nqueue_work(hostdata->work_q, &hostdata->main_task);\r\nmaybe_release_dma_irq(instance);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nreturn result;\r\n}\r\nstatic int NCR5380_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint i;\r\nunsigned long flags;\r\nstruct NCR5380_cmd *ncmd;\r\nspin_lock_irqsave(&hostdata->lock, flags);\r\n#if (NDEBUG & NDEBUG_ANY)\r\nscmd_printk(KERN_INFO, cmd, __func__);\r\n#endif\r\nNCR5380_dprint(NDEBUG_ANY, instance);\r\nNCR5380_dprint_phase(NDEBUG_ANY, instance);\r\ndo_reset(instance);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nif (list_del_cmd(&hostdata->unissued, cmd)) {\r\ncmd->result = DID_RESET << 16;\r\ncmd->scsi_done(cmd);\r\n}\r\nif (hostdata->selecting) {\r\nhostdata->selecting->result = DID_RESET << 16;\r\ncomplete_cmd(instance, hostdata->selecting);\r\nhostdata->selecting = NULL;\r\n}\r\nlist_for_each_entry(ncmd, &hostdata->disconnected, list) {\r\nstruct scsi_cmnd *cmd = NCR5380_to_scmd(ncmd);\r\nset_host_byte(cmd, DID_RESET);\r\ncomplete_cmd(instance, cmd);\r\n}\r\nINIT_LIST_HEAD(&hostdata->disconnected);\r\nlist_for_each_entry(ncmd, &hostdata->autosense, list) {\r\nstruct scsi_cmnd *cmd = NCR5380_to_scmd(ncmd);\r\nset_host_byte(cmd, DID_RESET);\r\ncmd->scsi_done(cmd);\r\n}\r\nINIT_LIST_HEAD(&hostdata->autosense);\r\nif (hostdata->connected) {\r\nset_host_byte(hostdata->connected, DID_RESET);\r\ncomplete_cmd(instance, hostdata->connected);\r\nhostdata->connected = NULL;\r\n}\r\nfor (i = 0; i < 8; ++i)\r\nhostdata->busy[i] = 0;\r\nhostdata->dma_len = 0;\r\nqueue_work(hostdata->work_q, &hostdata->main_task);\r\nmaybe_release_dma_irq(instance);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nreturn SUCCESS;\r\n}
