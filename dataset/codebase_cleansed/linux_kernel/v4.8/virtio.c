static ssize_t device_show(struct device *_d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct virtio_device *dev = dev_to_virtio(_d);\r\nreturn sprintf(buf, "0x%04x\n", dev->id.device);\r\n}\r\nstatic ssize_t vendor_show(struct device *_d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct virtio_device *dev = dev_to_virtio(_d);\r\nreturn sprintf(buf, "0x%04x\n", dev->id.vendor);\r\n}\r\nstatic ssize_t status_show(struct device *_d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct virtio_device *dev = dev_to_virtio(_d);\r\nreturn sprintf(buf, "0x%08x\n", dev->config->get_status(dev));\r\n}\r\nstatic ssize_t modalias_show(struct device *_d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct virtio_device *dev = dev_to_virtio(_d);\r\nreturn sprintf(buf, "virtio:d%08Xv%08X\n",\r\ndev->id.device, dev->id.vendor);\r\n}\r\nstatic ssize_t features_show(struct device *_d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct virtio_device *dev = dev_to_virtio(_d);\r\nunsigned int i;\r\nssize_t len = 0;\r\nfor (i = 0; i < sizeof(dev->features)*8; i++)\r\nlen += sprintf(buf+len, "%c",\r\n__virtio_test_bit(dev, i) ? '1' : '0');\r\nlen += sprintf(buf+len, "\n");\r\nreturn len;\r\n}\r\nstatic inline int virtio_id_match(const struct virtio_device *dev,\r\nconst struct virtio_device_id *id)\r\n{\r\nif (id->device != dev->id.device && id->device != VIRTIO_DEV_ANY_ID)\r\nreturn 0;\r\nreturn id->vendor == VIRTIO_DEV_ANY_ID || id->vendor == dev->id.vendor;\r\n}\r\nstatic int virtio_dev_match(struct device *_dv, struct device_driver *_dr)\r\n{\r\nunsigned int i;\r\nstruct virtio_device *dev = dev_to_virtio(_dv);\r\nconst struct virtio_device_id *ids;\r\nids = drv_to_virtio(_dr)->id_table;\r\nfor (i = 0; ids[i].device; i++)\r\nif (virtio_id_match(dev, &ids[i]))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int virtio_uevent(struct device *_dv, struct kobj_uevent_env *env)\r\n{\r\nstruct virtio_device *dev = dev_to_virtio(_dv);\r\nreturn add_uevent_var(env, "MODALIAS=virtio:d%08Xv%08X",\r\ndev->id.device, dev->id.vendor);\r\n}\r\nstatic void add_status(struct virtio_device *dev, unsigned status)\r\n{\r\ndev->config->set_status(dev, dev->config->get_status(dev) | status);\r\n}\r\nvoid virtio_check_driver_offered_feature(const struct virtio_device *vdev,\r\nunsigned int fbit)\r\n{\r\nunsigned int i;\r\nstruct virtio_driver *drv = drv_to_virtio(vdev->dev.driver);\r\nfor (i = 0; i < drv->feature_table_size; i++)\r\nif (drv->feature_table[i] == fbit)\r\nreturn;\r\nif (drv->feature_table_legacy) {\r\nfor (i = 0; i < drv->feature_table_size_legacy; i++)\r\nif (drv->feature_table_legacy[i] == fbit)\r\nreturn;\r\n}\r\nBUG();\r\n}\r\nstatic void __virtio_config_changed(struct virtio_device *dev)\r\n{\r\nstruct virtio_driver *drv = drv_to_virtio(dev->dev.driver);\r\nif (!dev->config_enabled)\r\ndev->config_change_pending = true;\r\nelse if (drv && drv->config_changed)\r\ndrv->config_changed(dev);\r\n}\r\nvoid virtio_config_changed(struct virtio_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->config_lock, flags);\r\n__virtio_config_changed(dev);\r\nspin_unlock_irqrestore(&dev->config_lock, flags);\r\n}\r\nstatic void virtio_config_disable(struct virtio_device *dev)\r\n{\r\nspin_lock_irq(&dev->config_lock);\r\ndev->config_enabled = false;\r\nspin_unlock_irq(&dev->config_lock);\r\n}\r\nstatic void virtio_config_enable(struct virtio_device *dev)\r\n{\r\nspin_lock_irq(&dev->config_lock);\r\ndev->config_enabled = true;\r\nif (dev->config_change_pending)\r\n__virtio_config_changed(dev);\r\ndev->config_change_pending = false;\r\nspin_unlock_irq(&dev->config_lock);\r\n}\r\nstatic int virtio_finalize_features(struct virtio_device *dev)\r\n{\r\nint ret = dev->config->finalize_features(dev);\r\nunsigned status;\r\nif (ret)\r\nreturn ret;\r\nif (!virtio_has_feature(dev, VIRTIO_F_VERSION_1))\r\nreturn 0;\r\nadd_status(dev, VIRTIO_CONFIG_S_FEATURES_OK);\r\nstatus = dev->config->get_status(dev);\r\nif (!(status & VIRTIO_CONFIG_S_FEATURES_OK)) {\r\ndev_err(&dev->dev, "virtio: device refuses features: %x\n",\r\nstatus);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int virtio_dev_probe(struct device *_d)\r\n{\r\nint err, i;\r\nstruct virtio_device *dev = dev_to_virtio(_d);\r\nstruct virtio_driver *drv = drv_to_virtio(dev->dev.driver);\r\nu64 device_features;\r\nu64 driver_features;\r\nu64 driver_features_legacy;\r\nadd_status(dev, VIRTIO_CONFIG_S_DRIVER);\r\ndevice_features = dev->config->get_features(dev);\r\ndriver_features = 0;\r\nfor (i = 0; i < drv->feature_table_size; i++) {\r\nunsigned int f = drv->feature_table[i];\r\nBUG_ON(f >= 64);\r\ndriver_features |= (1ULL << f);\r\n}\r\nif (drv->feature_table_legacy) {\r\ndriver_features_legacy = 0;\r\nfor (i = 0; i < drv->feature_table_size_legacy; i++) {\r\nunsigned int f = drv->feature_table_legacy[i];\r\nBUG_ON(f >= 64);\r\ndriver_features_legacy |= (1ULL << f);\r\n}\r\n} else {\r\ndriver_features_legacy = driver_features;\r\n}\r\nif (device_features & (1ULL << VIRTIO_F_VERSION_1))\r\ndev->features = driver_features & device_features;\r\nelse\r\ndev->features = driver_features_legacy & device_features;\r\nfor (i = VIRTIO_TRANSPORT_F_START; i < VIRTIO_TRANSPORT_F_END; i++)\r\nif (device_features & (1ULL << i))\r\n__virtio_set_bit(dev, i);\r\nerr = virtio_finalize_features(dev);\r\nif (err)\r\ngoto err;\r\nerr = drv->probe(dev);\r\nif (err)\r\ngoto err;\r\nif (!(dev->config->get_status(dev) & VIRTIO_CONFIG_S_DRIVER_OK))\r\nvirtio_device_ready(dev);\r\nif (drv->scan)\r\ndrv->scan(dev);\r\nvirtio_config_enable(dev);\r\nreturn 0;\r\nerr:\r\nadd_status(dev, VIRTIO_CONFIG_S_FAILED);\r\nreturn err;\r\n}\r\nstatic int virtio_dev_remove(struct device *_d)\r\n{\r\nstruct virtio_device *dev = dev_to_virtio(_d);\r\nstruct virtio_driver *drv = drv_to_virtio(dev->dev.driver);\r\nvirtio_config_disable(dev);\r\ndrv->remove(dev);\r\nWARN_ON_ONCE(dev->config->get_status(dev));\r\nadd_status(dev, VIRTIO_CONFIG_S_ACKNOWLEDGE);\r\nreturn 0;\r\n}\r\nint register_virtio_driver(struct virtio_driver *driver)\r\n{\r\nBUG_ON(driver->feature_table_size && !driver->feature_table);\r\ndriver->driver.bus = &virtio_bus;\r\nreturn driver_register(&driver->driver);\r\n}\r\nvoid unregister_virtio_driver(struct virtio_driver *driver)\r\n{\r\ndriver_unregister(&driver->driver);\r\n}\r\nint register_virtio_device(struct virtio_device *dev)\r\n{\r\nint err;\r\ndev->dev.bus = &virtio_bus;\r\nerr = ida_simple_get(&virtio_index_ida, 0, 0, GFP_KERNEL);\r\nif (err < 0)\r\ngoto out;\r\ndev->index = err;\r\ndev_set_name(&dev->dev, "virtio%u", dev->index);\r\nspin_lock_init(&dev->config_lock);\r\ndev->config_enabled = false;\r\ndev->config_change_pending = false;\r\ndev->config->reset(dev);\r\nadd_status(dev, VIRTIO_CONFIG_S_ACKNOWLEDGE);\r\nINIT_LIST_HEAD(&dev->vqs);\r\nerr = device_register(&dev->dev);\r\nout:\r\nif (err)\r\nadd_status(dev, VIRTIO_CONFIG_S_FAILED);\r\nreturn err;\r\n}\r\nvoid unregister_virtio_device(struct virtio_device *dev)\r\n{\r\nint index = dev->index;\r\ndevice_unregister(&dev->dev);\r\nida_simple_remove(&virtio_index_ida, index);\r\n}\r\nint virtio_device_freeze(struct virtio_device *dev)\r\n{\r\nstruct virtio_driver *drv = drv_to_virtio(dev->dev.driver);\r\nvirtio_config_disable(dev);\r\ndev->failed = dev->config->get_status(dev) & VIRTIO_CONFIG_S_FAILED;\r\nif (drv && drv->freeze)\r\nreturn drv->freeze(dev);\r\nreturn 0;\r\n}\r\nint virtio_device_restore(struct virtio_device *dev)\r\n{\r\nstruct virtio_driver *drv = drv_to_virtio(dev->dev.driver);\r\nint ret;\r\ndev->config->reset(dev);\r\nadd_status(dev, VIRTIO_CONFIG_S_ACKNOWLEDGE);\r\nif (dev->failed)\r\nadd_status(dev, VIRTIO_CONFIG_S_FAILED);\r\nif (!drv)\r\nreturn 0;\r\nadd_status(dev, VIRTIO_CONFIG_S_DRIVER);\r\nret = virtio_finalize_features(dev);\r\nif (ret)\r\ngoto err;\r\nif (drv->restore) {\r\nret = drv->restore(dev);\r\nif (ret)\r\ngoto err;\r\n}\r\nadd_status(dev, VIRTIO_CONFIG_S_DRIVER_OK);\r\nvirtio_config_enable(dev);\r\nreturn 0;\r\nerr:\r\nadd_status(dev, VIRTIO_CONFIG_S_FAILED);\r\nreturn ret;\r\n}\r\nstatic int virtio_init(void)\r\n{\r\nif (bus_register(&virtio_bus) != 0)\r\npanic("virtio bus registration failed");\r\nreturn 0;\r\n}\r\nstatic void __exit virtio_exit(void)\r\n{\r\nbus_unregister(&virtio_bus);\r\nida_destroy(&virtio_index_ida);\r\n}
