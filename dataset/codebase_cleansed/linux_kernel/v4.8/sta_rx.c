static bool\r\nmwifiex_discard_gratuitous_arp(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nconst struct mwifiex_arp_eth_header *arp;\r\nstruct ethhdr *eth;\r\nstruct ipv6hdr *ipv6;\r\nstruct icmp6hdr *icmpv6;\r\neth = (struct ethhdr *)skb->data;\r\nswitch (ntohs(eth->h_proto)) {\r\ncase ETH_P_ARP:\r\narp = (void *)(skb->data + sizeof(struct ethhdr));\r\nif (arp->hdr.ar_op == htons(ARPOP_REPLY) ||\r\narp->hdr.ar_op == htons(ARPOP_REQUEST)) {\r\nif (!memcmp(arp->ar_sip, arp->ar_tip, 4))\r\nreturn true;\r\n}\r\nbreak;\r\ncase ETH_P_IPV6:\r\nipv6 = (void *)(skb->data + sizeof(struct ethhdr));\r\nicmpv6 = (void *)(skb->data + sizeof(struct ethhdr) +\r\nsizeof(struct ipv6hdr));\r\nif (NDISC_NEIGHBOUR_ADVERTISEMENT == icmpv6->icmp6_type) {\r\nif (!memcmp(&ipv6->saddr, &ipv6->daddr,\r\nsizeof(struct in6_addr)))\r\nreturn true;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nint mwifiex_process_rx_packet(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nint ret;\r\nstruct rx_packet_hdr *rx_pkt_hdr;\r\nstruct rxpd *local_rx_pd;\r\nint hdr_chop;\r\nstruct ethhdr *eth;\r\nu16 rx_pkt_off, rx_pkt_len;\r\nu8 *offset;\r\nu8 adj_rx_rate = 0;\r\nlocal_rx_pd = (struct rxpd *) (skb->data);\r\nrx_pkt_off = le16_to_cpu(local_rx_pd->rx_pkt_offset);\r\nrx_pkt_len = le16_to_cpu(local_rx_pd->rx_pkt_length);\r\nrx_pkt_hdr = (void *)local_rx_pd + rx_pkt_off;\r\nif ((!memcmp(&rx_pkt_hdr->rfc1042_hdr, bridge_tunnel_header,\r\nsizeof(bridge_tunnel_header))) ||\r\n(!memcmp(&rx_pkt_hdr->rfc1042_hdr, rfc1042_header,\r\nsizeof(rfc1042_header)) &&\r\nntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_AARP &&\r\nntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_IPX)) {\r\neth = (struct ethhdr *)\r\n((u8 *) &rx_pkt_hdr->eth803_hdr\r\n+ sizeof(rx_pkt_hdr->eth803_hdr) +\r\nsizeof(rx_pkt_hdr->rfc1042_hdr)\r\n- sizeof(rx_pkt_hdr->eth803_hdr.h_dest)\r\n- sizeof(rx_pkt_hdr->eth803_hdr.h_source)\r\n- sizeof(rx_pkt_hdr->rfc1042_hdr.snap_type));\r\nmemcpy(eth->h_source, rx_pkt_hdr->eth803_hdr.h_source,\r\nsizeof(eth->h_source));\r\nmemcpy(eth->h_dest, rx_pkt_hdr->eth803_hdr.h_dest,\r\nsizeof(eth->h_dest));\r\nhdr_chop = (u8 *) eth - (u8 *) local_rx_pd;\r\n} else {\r\nhdr_chop = (u8 *) &rx_pkt_hdr->eth803_hdr -\r\n(u8 *) local_rx_pd;\r\n}\r\nskb_pull(skb, hdr_chop);\r\nif (priv->hs2_enabled &&\r\nmwifiex_discard_gratuitous_arp(priv, skb)) {\r\nmwifiex_dbg(priv->adapter, INFO, "Bypassed Gratuitous ARP\n");\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nif (ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\r\nntohs(rx_pkt_hdr->eth803_hdr.h_proto) == ETH_P_TDLS) {\r\noffset = (u8 *)local_rx_pd + rx_pkt_off;\r\nmwifiex_process_tdls_action_frame(priv, offset, rx_pkt_len);\r\n}\r\npriv->rxpd_rate = local_rx_pd->rx_rate;\r\npriv->rxpd_htinfo = local_rx_pd->ht_info;\r\nif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA ||\r\nGET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\r\nadj_rx_rate = mwifiex_adjust_data_rate(priv, priv->rxpd_rate,\r\npriv->rxpd_htinfo);\r\nmwifiex_hist_data_add(priv, adj_rx_rate, local_rx_pd->snr,\r\nlocal_rx_pd->nf);\r\n}\r\nret = mwifiex_recv_packet(priv, skb);\r\nif (ret == -1)\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"recv packet failed\n");\r\nreturn ret;\r\n}\r\nint mwifiex_process_sta_rx_packet(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret = 0;\r\nstruct rxpd *local_rx_pd;\r\nstruct rx_packet_hdr *rx_pkt_hdr;\r\nu8 ta[ETH_ALEN];\r\nu16 rx_pkt_type, rx_pkt_offset, rx_pkt_length, seq_num;\r\nstruct mwifiex_sta_node *sta_ptr;\r\nlocal_rx_pd = (struct rxpd *) (skb->data);\r\nrx_pkt_type = le16_to_cpu(local_rx_pd->rx_pkt_type);\r\nrx_pkt_offset = le16_to_cpu(local_rx_pd->rx_pkt_offset);\r\nrx_pkt_length = le16_to_cpu(local_rx_pd->rx_pkt_length);\r\nseq_num = le16_to_cpu(local_rx_pd->seq_num);\r\nrx_pkt_hdr = (void *)local_rx_pd + rx_pkt_offset;\r\nif ((rx_pkt_offset + rx_pkt_length) > (u16) skb->len) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"wrong rx packet: len=%d, rx_pkt_offset=%d, rx_pkt_length=%d\n",\r\nskb->len, rx_pkt_offset, rx_pkt_length);\r\npriv->stats.rx_dropped++;\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nif (rx_pkt_type == PKT_TYPE_MGMT) {\r\nret = mwifiex_process_mgmt_packet(priv, skb);\r\nif (ret)\r\nmwifiex_dbg(adapter, DATA, "Rx of mgmt packet failed");\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nif ((!IS_11N_ENABLED(priv) &&\r\n!(ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\r\n!(local_rx_pd->flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET))) ||\r\n!ether_addr_equal_unaligned(priv->curr_addr, rx_pkt_hdr->eth803_hdr.h_dest)) {\r\nmwifiex_process_rx_packet(priv, skb);\r\nreturn ret;\r\n}\r\nif (mwifiex_queuing_ra_based(priv) ||\r\n(ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\r\nlocal_rx_pd->flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET)) {\r\nmemcpy(ta, rx_pkt_hdr->eth803_hdr.h_source, ETH_ALEN);\r\nif (local_rx_pd->flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET &&\r\nlocal_rx_pd->priority < MAX_NUM_TID) {\r\nsta_ptr = mwifiex_get_sta_entry(priv, ta);\r\nif (sta_ptr)\r\nsta_ptr->rx_seq[local_rx_pd->priority] =\r\nle16_to_cpu(local_rx_pd->seq_num);\r\nmwifiex_auto_tdls_update_peer_signal(priv, ta,\r\nlocal_rx_pd->snr,\r\nlocal_rx_pd->nf);\r\n}\r\n} else {\r\nif (rx_pkt_type != PKT_TYPE_BAR)\r\npriv->rx_seq[local_rx_pd->priority] = seq_num;\r\nmemcpy(ta, priv->curr_bss_params.bss_descriptor.mac_address,\r\nETH_ALEN);\r\n}\r\nret = mwifiex_11n_rx_reorder_pkt(priv, seq_num, local_rx_pd->priority,\r\nta, (u8) rx_pkt_type, skb);\r\nif (ret || (rx_pkt_type == PKT_TYPE_BAR))\r\ndev_kfree_skb_any(skb);\r\nif (ret)\r\npriv->stats.rx_dropped++;\r\nreturn ret;\r\n}
