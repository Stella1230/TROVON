static ssize_t acpi_object_path(acpi_handle handle, char *buf)\r\n{\r\nstruct acpi_buffer path = {ACPI_ALLOCATE_BUFFER, NULL};\r\nint result;\r\nresult = acpi_get_name(handle, ACPI_FULL_PATHNAME, &path);\r\nif (result)\r\nreturn result;\r\nresult = sprintf(buf, "%s\n", (char *)path.pointer);\r\nkfree(path.pointer);\r\nreturn result;\r\n}\r\nstatic ssize_t data_node_show_path(struct acpi_data_node *dn, char *buf)\r\n{\r\nreturn acpi_object_path(dn->handle, buf);\r\n}\r\nstatic ssize_t acpi_data_node_attr_show(struct kobject *kobj,\r\nstruct attribute *attr, char *buf)\r\n{\r\nstruct acpi_data_node *dn = to_data_node(kobj);\r\nstruct acpi_data_node_attr *dn_attr = to_attr(attr);\r\nreturn dn_attr->show ? dn_attr->show(dn, buf) : -ENXIO;\r\n}\r\nstatic void acpi_data_node_release(struct kobject *kobj)\r\n{\r\nstruct acpi_data_node *dn = to_data_node(kobj);\r\ncomplete(&dn->kobj_done);\r\n}\r\nstatic void acpi_expose_nondev_subnodes(struct kobject *kobj,\r\nstruct acpi_device_data *data)\r\n{\r\nstruct list_head *list = &data->subnodes;\r\nstruct acpi_data_node *dn;\r\nif (list_empty(list))\r\nreturn;\r\nlist_for_each_entry(dn, list, sibling) {\r\nint ret;\r\ninit_completion(&dn->kobj_done);\r\nret = kobject_init_and_add(&dn->kobj, &acpi_data_node_ktype,\r\nkobj, "%s", dn->name);\r\nif (ret)\r\nacpi_handle_err(dn->handle, "Failed to expose (%d)\n", ret);\r\nelse\r\nacpi_expose_nondev_subnodes(&dn->kobj, &dn->data);\r\n}\r\n}\r\nstatic void acpi_hide_nondev_subnodes(struct acpi_device_data *data)\r\n{\r\nstruct list_head *list = &data->subnodes;\r\nstruct acpi_data_node *dn;\r\nif (list_empty(list))\r\nreturn;\r\nlist_for_each_entry_reverse(dn, list, sibling) {\r\nacpi_hide_nondev_subnodes(&dn->data);\r\nkobject_put(&dn->kobj);\r\n}\r\n}\r\nstatic int create_pnp_modalias(struct acpi_device *acpi_dev, char *modalias,\r\nint size)\r\n{\r\nint len;\r\nint count;\r\nstruct acpi_hardware_id *id;\r\ncount = 0;\r\nlist_for_each_entry(id, &acpi_dev->pnp.ids, list)\r\nif (strcmp(id->id, ACPI_DT_NAMESPACE_HID))\r\ncount++;\r\nif (!count)\r\nreturn 0;\r\nlen = snprintf(modalias, size, "acpi:");\r\nif (len <= 0)\r\nreturn len;\r\nsize -= len;\r\nlist_for_each_entry(id, &acpi_dev->pnp.ids, list) {\r\nif (!strcmp(id->id, ACPI_DT_NAMESPACE_HID))\r\ncontinue;\r\ncount = snprintf(&modalias[len], size, "%s:", id->id);\r\nif (count < 0)\r\nreturn -EINVAL;\r\nif (count >= size)\r\nreturn -ENOMEM;\r\nlen += count;\r\nsize -= count;\r\n}\r\nmodalias[len] = '\0';\r\nreturn len;\r\n}\r\nstatic int create_of_modalias(struct acpi_device *acpi_dev, char *modalias,\r\nint size)\r\n{\r\nstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\r\nconst union acpi_object *of_compatible, *obj;\r\nint len, count;\r\nint i, nval;\r\nchar *c;\r\nacpi_get_name(acpi_dev->handle, ACPI_SINGLE_NAME, &buf);\r\nfor (c = buf.pointer; *c != '\0'; c++)\r\n*c = tolower(*c);\r\nlen = snprintf(modalias, size, "of:N%sT", (char *)buf.pointer);\r\nACPI_FREE(buf.pointer);\r\nif (len <= 0)\r\nreturn len;\r\nof_compatible = acpi_dev->data.of_compatible;\r\nif (of_compatible->type == ACPI_TYPE_PACKAGE) {\r\nnval = of_compatible->package.count;\r\nobj = of_compatible->package.elements;\r\n} else {\r\nnval = 1;\r\nobj = of_compatible;\r\n}\r\nfor (i = 0; i < nval; i++, obj++) {\r\ncount = snprintf(&modalias[len], size, "C%s",\r\nobj->string.pointer);\r\nif (count < 0)\r\nreturn -EINVAL;\r\nif (count >= size)\r\nreturn -ENOMEM;\r\nlen += count;\r\nsize -= count;\r\n}\r\nmodalias[len] = '\0';\r\nreturn len;\r\n}\r\nint __acpi_device_uevent_modalias(struct acpi_device *adev,\r\nstruct kobj_uevent_env *env)\r\n{\r\nint len;\r\nif (!adev)\r\nreturn -ENODEV;\r\nif (list_empty(&adev->pnp.ids))\r\nreturn 0;\r\nif (add_uevent_var(env, "MODALIAS="))\r\nreturn -ENOMEM;\r\nlen = create_pnp_modalias(adev, &env->buf[env->buflen - 1],\r\nsizeof(env->buf) - env->buflen);\r\nif (len < 0)\r\nreturn len;\r\nenv->buflen += len;\r\nif (!adev->data.of_compatible)\r\nreturn 0;\r\nif (len > 0 && add_uevent_var(env, "MODALIAS="))\r\nreturn -ENOMEM;\r\nlen = create_of_modalias(adev, &env->buf[env->buflen - 1],\r\nsizeof(env->buf) - env->buflen);\r\nif (len < 0)\r\nreturn len;\r\nenv->buflen += len;\r\nreturn 0;\r\n}\r\nint acpi_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nreturn __acpi_device_uevent_modalias(acpi_companion_match(dev), env);\r\n}\r\nstatic int __acpi_device_modalias(struct acpi_device *adev, char *buf, int size)\r\n{\r\nint len, count;\r\nif (!adev)\r\nreturn -ENODEV;\r\nif (list_empty(&adev->pnp.ids))\r\nreturn 0;\r\nlen = create_pnp_modalias(adev, buf, size - 1);\r\nif (len < 0) {\r\nreturn len;\r\n} else if (len > 0) {\r\nbuf[len++] = '\n';\r\nsize -= len;\r\n}\r\nif (!adev->data.of_compatible)\r\nreturn len;\r\ncount = create_of_modalias(adev, buf + len, size - 1);\r\nif (count < 0) {\r\nreturn count;\r\n} else if (count > 0) {\r\nlen += count;\r\nbuf[len++] = '\n';\r\n}\r\nreturn len;\r\n}\r\nint acpi_device_modalias(struct device *dev, char *buf, int size)\r\n{\r\nreturn __acpi_device_modalias(acpi_companion_match(dev), buf, size);\r\n}\r\nstatic ssize_t\r\nacpi_device_modalias_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn __acpi_device_modalias(to_acpi_device(dev), buf, 1024);\r\n}\r\nstatic ssize_t real_power_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct acpi_device *adev = to_acpi_device(dev);\r\nint state;\r\nint ret;\r\nret = acpi_device_get_power(adev, &state);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%s\n", acpi_power_state_string(state));\r\n}\r\nstatic ssize_t power_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct acpi_device *adev = to_acpi_device(dev);\r\nreturn sprintf(buf, "%s\n", acpi_power_state_string(adev->power.state));\r\n}\r\nstatic ssize_t\r\nacpi_eject_store(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct acpi_device *acpi_device = to_acpi_device(d);\r\nacpi_object_type not_used;\r\nacpi_status status;\r\nif (!count || buf[0] != '1')\r\nreturn -EINVAL;\r\nif ((!acpi_device->handler || !acpi_device->handler->hotplug.enabled)\r\n&& !acpi_device->driver)\r\nreturn -ENODEV;\r\nstatus = acpi_get_type(acpi_device->handle, &not_used);\r\nif (ACPI_FAILURE(status) || !acpi_device->flags.ejectable)\r\nreturn -ENODEV;\r\nget_device(&acpi_device->dev);\r\nstatus = acpi_hotplug_schedule(acpi_device, ACPI_OST_EC_OSPM_EJECT);\r\nif (ACPI_SUCCESS(status))\r\nreturn count;\r\nput_device(&acpi_device->dev);\r\nacpi_evaluate_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,\r\nACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);\r\nreturn status == AE_NO_MEMORY ? -ENOMEM : -EAGAIN;\r\n}\r\nstatic ssize_t\r\nacpi_device_hid_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nreturn sprintf(buf, "%s\n", acpi_device_hid(acpi_dev));\r\n}\r\nstatic ssize_t acpi_device_uid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nreturn sprintf(buf, "%s\n", acpi_dev->pnp.unique_id);\r\n}\r\nstatic ssize_t acpi_device_adr_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nreturn sprintf(buf, "0x%08x\n",\r\n(unsigned int)(acpi_dev->pnp.bus_address));\r\n}\r\nstatic ssize_t acpi_device_path_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nreturn acpi_object_path(acpi_dev->handle, buf);\r\n}\r\nstatic ssize_t description_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf) {\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nint result;\r\nif (acpi_dev->pnp.str_obj == NULL)\r\nreturn 0;\r\nresult = utf16s_to_utf8s(\r\n(wchar_t *)acpi_dev->pnp.str_obj->buffer.pointer,\r\nacpi_dev->pnp.str_obj->buffer.length,\r\nUTF16_LITTLE_ENDIAN, buf,\r\nPAGE_SIZE);\r\nbuf[result++] = '\n';\r\nreturn result;\r\n}\r\nstatic ssize_t\r\nacpi_device_sun_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf) {\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nacpi_status status;\r\nunsigned long long sun;\r\nstatus = acpi_evaluate_integer(acpi_dev->handle, "_SUN", NULL, &sun);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\nreturn sprintf(buf, "%llu\n", sun);\r\n}\r\nstatic ssize_t\r\nacpi_device_hrv_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf) {\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nacpi_status status;\r\nunsigned long long hrv;\r\nstatus = acpi_evaluate_integer(acpi_dev->handle, "_HRV", NULL, &hrv);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\nreturn sprintf(buf, "%llu\n", hrv);\r\n}\r\nstatic ssize_t status_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf) {\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nacpi_status status;\r\nunsigned long long sta;\r\nstatus = acpi_evaluate_integer(acpi_dev->handle, "_STA", NULL, &sta);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\nreturn sprintf(buf, "%llu\n", sta);\r\n}\r\nint acpi_device_setup_files(struct acpi_device *dev)\r\n{\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nacpi_status status;\r\nint result = 0;\r\nif (dev->handle) {\r\nresult = device_create_file(&dev->dev, &dev_attr_path);\r\nif (result)\r\ngoto end;\r\n}\r\nif (!list_empty(&dev->pnp.ids)) {\r\nresult = device_create_file(&dev->dev, &dev_attr_hid);\r\nif (result)\r\ngoto end;\r\nresult = device_create_file(&dev->dev, &dev_attr_modalias);\r\nif (result)\r\ngoto end;\r\n}\r\nif (acpi_has_method(dev->handle, "_STR")) {\r\nstatus = acpi_evaluate_object(dev->handle, "_STR",\r\nNULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nbuffer.pointer = NULL;\r\ndev->pnp.str_obj = buffer.pointer;\r\nresult = device_create_file(&dev->dev, &dev_attr_description);\r\nif (result)\r\ngoto end;\r\n}\r\nif (dev->pnp.type.bus_address)\r\nresult = device_create_file(&dev->dev, &dev_attr_adr);\r\nif (dev->pnp.unique_id)\r\nresult = device_create_file(&dev->dev, &dev_attr_uid);\r\nif (acpi_has_method(dev->handle, "_SUN")) {\r\nresult = device_create_file(&dev->dev, &dev_attr_sun);\r\nif (result)\r\ngoto end;\r\n}\r\nif (acpi_has_method(dev->handle, "_HRV")) {\r\nresult = device_create_file(&dev->dev, &dev_attr_hrv);\r\nif (result)\r\ngoto end;\r\n}\r\nif (acpi_has_method(dev->handle, "_STA")) {\r\nresult = device_create_file(&dev->dev, &dev_attr_status);\r\nif (result)\r\ngoto end;\r\n}\r\nif (acpi_has_method(dev->handle, "_EJ0")) {\r\nresult = device_create_file(&dev->dev, &dev_attr_eject);\r\nif (result)\r\nreturn result;\r\n}\r\nif (dev->flags.power_manageable) {\r\nresult = device_create_file(&dev->dev, &dev_attr_power_state);\r\nif (result)\r\nreturn result;\r\nif (dev->power.flags.power_resources)\r\nresult = device_create_file(&dev->dev,\r\n&dev_attr_real_power_state);\r\n}\r\nacpi_expose_nondev_subnodes(&dev->dev.kobj, &dev->data);\r\nend:\r\nreturn result;\r\n}\r\nvoid acpi_device_remove_files(struct acpi_device *dev)\r\n{\r\nacpi_hide_nondev_subnodes(&dev->data);\r\nif (dev->flags.power_manageable) {\r\ndevice_remove_file(&dev->dev, &dev_attr_power_state);\r\nif (dev->power.flags.power_resources)\r\ndevice_remove_file(&dev->dev,\r\n&dev_attr_real_power_state);\r\n}\r\nif (acpi_has_method(dev->handle, "_STR")) {\r\nkfree(dev->pnp.str_obj);\r\ndevice_remove_file(&dev->dev, &dev_attr_description);\r\n}\r\nif (acpi_has_method(dev->handle, "_EJ0"))\r\ndevice_remove_file(&dev->dev, &dev_attr_eject);\r\nif (acpi_has_method(dev->handle, "_SUN"))\r\ndevice_remove_file(&dev->dev, &dev_attr_sun);\r\nif (acpi_has_method(dev->handle, "_HRV"))\r\ndevice_remove_file(&dev->dev, &dev_attr_hrv);\r\nif (dev->pnp.unique_id)\r\ndevice_remove_file(&dev->dev, &dev_attr_uid);\r\nif (dev->pnp.type.bus_address)\r\ndevice_remove_file(&dev->dev, &dev_attr_adr);\r\ndevice_remove_file(&dev->dev, &dev_attr_modalias);\r\ndevice_remove_file(&dev->dev, &dev_attr_hid);\r\nif (acpi_has_method(dev->handle, "_STA"))\r\ndevice_remove_file(&dev->dev, &dev_attr_status);\r\nif (dev->handle)\r\ndevice_remove_file(&dev->dev, &dev_attr_path);\r\n}
