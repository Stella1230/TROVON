static int pbclk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct pic32_periph_clk *pb = clkhw_to_pbclk(hw);\r\nreturn readl(pb->ctrl_reg) & PB_DIV_ENABLE;\r\n}\r\nstatic int pbclk_enable(struct clk_hw *hw)\r\n{\r\nstruct pic32_periph_clk *pb = clkhw_to_pbclk(hw);\r\nwritel(PB_DIV_ENABLE, PIC32_SET(pb->ctrl_reg));\r\nreturn 0;\r\n}\r\nstatic void pbclk_disable(struct clk_hw *hw)\r\n{\r\nstruct pic32_periph_clk *pb = clkhw_to_pbclk(hw);\r\nwritel(PB_DIV_ENABLE, PIC32_CLR(pb->ctrl_reg));\r\n}\r\nstatic unsigned long calc_best_divided_rate(unsigned long rate,\r\nunsigned long parent_rate,\r\nu32 divider_max,\r\nu32 divider_min)\r\n{\r\nunsigned long divided_rate, divided_rate_down, best_rate;\r\nunsigned long div, div_up;\r\ndiv = parent_rate / rate;\r\ndiv = clamp_val(div, divider_min, divider_max);\r\ndiv_up = clamp_val(div + 1, divider_min, divider_max);\r\ndivided_rate = parent_rate / div;\r\ndivided_rate_down = parent_rate / div_up;\r\nif (abs(rate - divided_rate_down) < abs(rate - divided_rate))\r\nbest_rate = divided_rate_down;\r\nelse\r\nbest_rate = divided_rate;\r\nreturn best_rate;\r\n}\r\nstatic inline u32 pbclk_read_pbdiv(struct pic32_periph_clk *pb)\r\n{\r\nreturn ((readl(pb->ctrl_reg) >> PB_DIV_SHIFT) & PB_DIV_MASK) + 1;\r\n}\r\nstatic unsigned long pbclk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct pic32_periph_clk *pb = clkhw_to_pbclk(hw);\r\nreturn parent_rate / pbclk_read_pbdiv(pb);\r\n}\r\nstatic long pbclk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nreturn calc_best_divided_rate(rate, *parent_rate,\r\nPB_DIV_MAX, PB_DIV_MIN);\r\n}\r\nstatic int pbclk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct pic32_periph_clk *pb = clkhw_to_pbclk(hw);\r\nunsigned long flags;\r\nu32 v, div;\r\nint err;\r\nerr = readl_poll_timeout(pb->ctrl_reg, v, v & PB_DIV_READY,\r\n1, LOCK_TIMEOUT_US);\r\nif (err)\r\nreturn err;\r\ndiv = DIV_ROUND_CLOSEST(parent_rate, rate);\r\nspin_lock_irqsave(&pb->core->reg_lock, flags);\r\nv = readl(pb->ctrl_reg);\r\nv &= ~PB_DIV_MASK;\r\nv |= (div - 1);\r\npic32_syskey_unlock();\r\nwritel(v, pb->ctrl_reg);\r\nspin_unlock_irqrestore(&pb->core->reg_lock, flags);\r\nerr = readl_poll_timeout_atomic(pb->ctrl_reg, v, v & PB_DIV_READY,\r\n1, LOCK_TIMEOUT_US);\r\nif (err)\r\nreturn err;\r\nreturn (pbclk_read_pbdiv(pb) == div) ? 0 : -EBUSY;\r\n}\r\nstruct clk *pic32_periph_clk_register(const struct pic32_periph_clk_data *desc,\r\nstruct pic32_clk_common *core)\r\n{\r\nstruct pic32_periph_clk *pbclk;\r\nstruct clk *clk;\r\npbclk = devm_kzalloc(core->dev, sizeof(*pbclk), GFP_KERNEL);\r\nif (!pbclk)\r\nreturn ERR_PTR(-ENOMEM);\r\npbclk->hw.init = &desc->init_data;\r\npbclk->core = core;\r\npbclk->ctrl_reg = desc->ctrl_reg + core->iobase;\r\nclk = devm_clk_register(core->dev, &pbclk->hw);\r\nif (IS_ERR(clk)) {\r\ndev_err(core->dev, "%s: clk_register() failed\n", __func__);\r\ndevm_kfree(core->dev, pbclk);\r\n}\r\nreturn clk;\r\n}\r\nstatic int roclk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\r\nreturn readl(refo->ctrl_reg) & REFO_ON;\r\n}\r\nstatic int roclk_enable(struct clk_hw *hw)\r\n{\r\nstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\r\nwritel(REFO_ON | REFO_OE, PIC32_SET(refo->ctrl_reg));\r\nreturn 0;\r\n}\r\nstatic void roclk_disable(struct clk_hw *hw)\r\n{\r\nstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\r\nwritel(REFO_ON | REFO_OE, PIC32_CLR(refo->ctrl_reg));\r\n}\r\nstatic void roclk_init(struct clk_hw *hw)\r\n{\r\nroclk_disable(hw);\r\n}\r\nstatic u8 roclk_get_parent(struct clk_hw *hw)\r\n{\r\nstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\r\nu32 v, i;\r\nv = (readl(refo->ctrl_reg) >> REFO_SEL_SHIFT) & REFO_SEL_MASK;\r\nif (!refo->parent_map)\r\nreturn v;\r\nfor (i = 0; i < clk_hw_get_num_parents(hw); i++)\r\nif (refo->parent_map[i] == v)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned long roclk_calc_rate(unsigned long parent_rate,\r\nu32 rodiv, u32 rotrim)\r\n{\r\nu64 rate64;\r\nif (rotrim) {\r\nrodiv = (rodiv << 9) + rotrim;\r\nrate64 = parent_rate;\r\nrate64 <<= 8;\r\ndo_div(rate64, rodiv);\r\n} else if (rodiv) {\r\nrate64 = parent_rate / (rodiv << 1);\r\n} else {\r\nrate64 = parent_rate;\r\n}\r\nreturn rate64;\r\n}\r\nstatic void roclk_calc_div_trim(unsigned long rate,\r\nunsigned long parent_rate,\r\nu32 *rodiv_p, u32 *rotrim_p)\r\n{\r\nu32 div, rotrim, rodiv;\r\nu64 frac;\r\nif (parent_rate <= rate) {\r\ndiv = 0;\r\nfrac = 0;\r\nrodiv = 0;\r\nrotrim = 0;\r\n} else {\r\ndiv = parent_rate / (rate << 1);\r\nfrac = parent_rate;\r\nfrac <<= 8;\r\ndo_div(frac, rate);\r\nfrac -= (u64)(div << 9);\r\nrodiv = (div > REFO_DIV_MASK) ? REFO_DIV_MASK : div;\r\nrotrim = (frac >= REFO_TRIM_MAX) ? REFO_TRIM_MAX : frac;\r\n}\r\nif (rodiv_p)\r\n*rodiv_p = rodiv;\r\nif (rotrim_p)\r\n*rotrim_p = rotrim;\r\n}\r\nstatic unsigned long roclk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\r\nu32 v, rodiv, rotrim;\r\nv = readl(refo->ctrl_reg);\r\nrodiv = (v >> REFO_DIV_SHIFT) & REFO_DIV_MASK;\r\nv = readl(refo->ctrl_reg + REFO_TRIM_REG);\r\nrotrim = (v >> REFO_TRIM_SHIFT) & REFO_TRIM_MASK;\r\nreturn roclk_calc_rate(parent_rate, rodiv, rotrim);\r\n}\r\nstatic long roclk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nu32 rotrim, rodiv;\r\nroclk_calc_div_trim(rate, *parent_rate, &rodiv, &rotrim);\r\nreturn roclk_calc_rate(*parent_rate, rodiv, rotrim);\r\n}\r\nstatic int roclk_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_hw *parent_clk, *best_parent_clk = NULL;\r\nunsigned int i, delta, best_delta = -1;\r\nunsigned long parent_rate, best_parent_rate = 0;\r\nunsigned long best = 0, nearest_rate;\r\nfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\r\nparent_clk = clk_hw_get_parent_by_index(hw, i);\r\nif (!parent_clk)\r\ncontinue;\r\nparent_rate = clk_hw_get_rate(parent_clk);\r\nif (req->rate > parent_rate)\r\ncontinue;\r\nnearest_rate = roclk_round_rate(hw, req->rate, &parent_rate);\r\ndelta = abs(nearest_rate - req->rate);\r\nif ((nearest_rate >= req->rate) && (delta < best_delta)) {\r\nbest_parent_clk = parent_clk;\r\nbest_parent_rate = parent_rate;\r\nbest = nearest_rate;\r\nbest_delta = delta;\r\nif (delta == 0)\r\nbreak;\r\n}\r\n}\r\nif (!best_parent_clk) {\r\npr_err("%s:%s, no parent found for rate %lu.\n",\r\n__func__, clk_hw_get_name(hw), req->rate);\r\nreturn clk_hw_get_rate(hw);\r\n}\r\npr_debug("%s,rate %lu, best_parent(%s, %lu), best %lu, delta %d\n",\r\nclk_hw_get_name(hw), req->rate,\r\nclk_hw_get_name(best_parent_clk), best_parent_rate,\r\nbest, best_delta);\r\nif (req->best_parent_rate)\r\nreq->best_parent_rate = best_parent_rate;\r\nif (req->best_parent_hw)\r\nreq->best_parent_hw = best_parent_clk;\r\nreturn best;\r\n}\r\nstatic int roclk_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\r\nunsigned long flags;\r\nu32 v;\r\nint err;\r\nif (refo->parent_map)\r\nindex = refo->parent_map[index];\r\nerr = readl_poll_timeout(refo->ctrl_reg, v, !(v & REFO_ACTIVE),\r\n1, LOCK_TIMEOUT_US);\r\nif (err) {\r\npr_err("%s: poll failed, clk active\n", clk_hw_get_name(hw));\r\nreturn err;\r\n}\r\nspin_lock_irqsave(&refo->core->reg_lock, flags);\r\npic32_syskey_unlock();\r\nv = readl(refo->ctrl_reg);\r\nv &= ~(REFO_SEL_MASK << REFO_SEL_SHIFT);\r\nv |= index << REFO_SEL_SHIFT;\r\nwritel(v, refo->ctrl_reg);\r\nspin_unlock_irqrestore(&refo->core->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int roclk_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long parent_rate,\r\nu8 index)\r\n{\r\nstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\r\nunsigned long flags;\r\nu32 trim, rodiv, v;\r\nint err;\r\nroclk_calc_div_trim(rate, parent_rate, &rodiv, &trim);\r\npr_debug("parent_rate = %lu, rate = %lu, div = %d, trim = %d\n",\r\nparent_rate, rate, rodiv, trim);\r\nerr = readl_poll_timeout(refo->ctrl_reg, v,\r\n!(v & (REFO_ACTIVE | REFO_DIVSW_EN)),\r\n1, LOCK_TIMEOUT_US);\r\nif (err) {\r\npr_err("%s: poll timedout, clock is still active\n", __func__);\r\nreturn err;\r\n}\r\nspin_lock_irqsave(&refo->core->reg_lock, flags);\r\nv = readl(refo->ctrl_reg);\r\npic32_syskey_unlock();\r\nif (refo->parent_map)\r\nindex = refo->parent_map[index];\r\nv &= ~(REFO_SEL_MASK << REFO_SEL_SHIFT);\r\nv |= index << REFO_SEL_SHIFT;\r\nv &= ~(REFO_DIV_MASK << REFO_DIV_SHIFT);\r\nv |= rodiv << REFO_DIV_SHIFT;\r\nwritel(v, refo->ctrl_reg);\r\nv = readl(refo->ctrl_reg + REFO_TRIM_REG);\r\nv &= ~(REFO_TRIM_MASK << REFO_TRIM_SHIFT);\r\nv |= trim << REFO_TRIM_SHIFT;\r\nwritel(v, refo->ctrl_reg + REFO_TRIM_REG);\r\nwritel(REFO_ON | REFO_DIVSW_EN, PIC32_SET(refo->ctrl_reg));\r\nerr = readl_poll_timeout_atomic(refo->ctrl_reg, v, !(v & REFO_DIVSW_EN),\r\n1, LOCK_TIMEOUT_US);\r\nwritel(REFO_ON, PIC32_CLR(refo->ctrl_reg));\r\nspin_unlock_irqrestore(&refo->core->reg_lock, flags);\r\nreturn err;\r\n}\r\nstatic int roclk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nu8 index = roclk_get_parent(hw);\r\nreturn roclk_set_rate_and_parent(hw, rate, parent_rate, index);\r\n}\r\nstruct clk *pic32_refo_clk_register(const struct pic32_ref_osc_data *data,\r\nstruct pic32_clk_common *core)\r\n{\r\nstruct pic32_ref_osc *refo;\r\nstruct clk *clk;\r\nrefo = devm_kzalloc(core->dev, sizeof(*refo), GFP_KERNEL);\r\nif (!refo)\r\nreturn ERR_PTR(-ENOMEM);\r\nrefo->core = core;\r\nrefo->hw.init = &data->init_data;\r\nrefo->ctrl_reg = data->ctrl_reg + core->iobase;\r\nrefo->parent_map = data->parent_map;\r\nclk = devm_clk_register(core->dev, &refo->hw);\r\nif (IS_ERR(clk))\r\ndev_err(core->dev, "%s: clk_register() failed\n", __func__);\r\nreturn clk;\r\n}\r\nstatic inline u32 spll_odiv_to_divider(u32 odiv)\r\n{\r\nodiv = clamp_val(odiv, PLL_ODIV_MIN, PLL_ODIV_MAX);\r\nreturn 1 << odiv;\r\n}\r\nstatic unsigned long spll_calc_mult_div(struct pic32_sys_pll *pll,\r\nunsigned long rate,\r\nunsigned long parent_rate,\r\nu32 *mult_p, u32 *odiv_p)\r\n{\r\nu32 mul, div, best_mul = 1, best_div = 1;\r\nunsigned long new_rate, best_rate = rate;\r\nunsigned int best_delta = -1, delta, match_found = 0;\r\nu64 rate64;\r\nparent_rate /= pll->idiv;\r\nfor (mul = 1; mul <= PLL_MULT_MAX; mul++) {\r\nfor (div = PLL_ODIV_MIN; div <= PLL_ODIV_MAX; div++) {\r\nrate64 = parent_rate;\r\nrate64 *= mul;\r\ndo_div(rate64, 1 << div);\r\nnew_rate = rate64;\r\ndelta = abs(rate - new_rate);\r\nif ((new_rate >= rate) && (delta < best_delta)) {\r\nbest_delta = delta;\r\nbest_rate = new_rate;\r\nbest_mul = mul;\r\nbest_div = div;\r\nmatch_found = 1;\r\n}\r\n}\r\n}\r\nif (!match_found) {\r\npr_warn("spll: no match found\n");\r\nreturn 0;\r\n}\r\npr_debug("rate %lu, par_rate %lu/mult %u, div %u, best_rate %lu\n",\r\nrate, parent_rate, best_mul, best_div, best_rate);\r\nif (mult_p)\r\n*mult_p = best_mul - 1;\r\nif (odiv_p)\r\n*odiv_p = best_div;\r\nreturn best_rate;\r\n}\r\nstatic unsigned long spll_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct pic32_sys_pll *pll = clkhw_to_spll(hw);\r\nunsigned long pll_in_rate;\r\nu32 mult, odiv, div, v;\r\nu64 rate64;\r\nv = readl(pll->ctrl_reg);\r\nodiv = ((v >> PLL_ODIV_SHIFT) & PLL_ODIV_MASK);\r\nmult = ((v >> PLL_MULT_SHIFT) & PLL_MULT_MASK) + 1;\r\ndiv = spll_odiv_to_divider(odiv);\r\npll_in_rate = parent_rate / pll->idiv;\r\nrate64 = pll_in_rate;\r\nrate64 *= mult;\r\ndo_div(rate64, div);\r\nreturn rate64;\r\n}\r\nstatic long spll_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct pic32_sys_pll *pll = clkhw_to_spll(hw);\r\nreturn spll_calc_mult_div(pll, rate, *parent_rate, NULL, NULL);\r\n}\r\nstatic int spll_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct pic32_sys_pll *pll = clkhw_to_spll(hw);\r\nunsigned long ret, flags;\r\nu32 mult, odiv, v;\r\nint err;\r\nret = spll_calc_mult_div(pll, rate, parent_rate, &mult, &odiv);\r\nif (!ret)\r\nreturn -EINVAL;\r\nif (unlikely(clk_hw_get_parent(pic32_sclk_hw) == hw)) {\r\npr_err("%s: failed, clk in-use\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nspin_lock_irqsave(&pll->core->reg_lock, flags);\r\nv = readl(pll->ctrl_reg);\r\nv &= ~(PLL_MULT_MASK << PLL_MULT_SHIFT);\r\nv &= ~(PLL_ODIV_MASK << PLL_ODIV_SHIFT);\r\nv |= (mult << PLL_MULT_SHIFT) | (odiv << PLL_ODIV_SHIFT);\r\npic32_syskey_unlock();\r\nwritel(v, pll->ctrl_reg);\r\ncpu_relax();\r\ncpu_nop5();\r\ncpu_nop5();\r\nerr = readl_poll_timeout_atomic(pll->status_reg, v,\r\nv & pll->lock_mask, 1, 100);\r\nspin_unlock_irqrestore(&pll->core->reg_lock, flags);\r\nreturn err;\r\n}\r\nstruct clk *pic32_spll_clk_register(const struct pic32_sys_pll_data *data,\r\nstruct pic32_clk_common *core)\r\n{\r\nstruct pic32_sys_pll *spll;\r\nstruct clk *clk;\r\nspll = devm_kzalloc(core->dev, sizeof(*spll), GFP_KERNEL);\r\nif (!spll)\r\nreturn ERR_PTR(-ENOMEM);\r\nspll->core = core;\r\nspll->hw.init = &data->init_data;\r\nspll->ctrl_reg = data->ctrl_reg + core->iobase;\r\nspll->status_reg = data->status_reg + core->iobase;\r\nspll->lock_mask = data->lock_mask;\r\nspll->idiv = (readl(spll->ctrl_reg) >> PLL_IDIV_SHIFT) & PLL_IDIV_MASK;\r\nspll->idiv += 1;\r\nclk = devm_clk_register(core->dev, &spll->hw);\r\nif (IS_ERR(clk))\r\ndev_err(core->dev, "sys_pll: clk_register() failed\n");\r\nreturn clk;\r\n}\r\nstatic unsigned long sclk_get_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct pic32_sys_clk *sclk = clkhw_to_sys_clk(hw);\r\nu32 div;\r\ndiv = (readl(sclk->slew_reg) >> SLEW_SYSDIV_SHIFT) & SLEW_SYSDIV;\r\ndiv += 1;\r\nreturn parent_rate / div;\r\n}\r\nstatic long sclk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nreturn calc_best_divided_rate(rate, *parent_rate, SLEW_SYSDIV, 1);\r\n}\r\nstatic int sclk_set_rate(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate)\r\n{\r\nstruct pic32_sys_clk *sclk = clkhw_to_sys_clk(hw);\r\nunsigned long flags;\r\nu32 v, div;\r\nint err;\r\ndiv = parent_rate / rate;\r\nspin_lock_irqsave(&sclk->core->reg_lock, flags);\r\nv = readl(sclk->slew_reg);\r\nv &= ~(SLEW_SYSDIV << SLEW_SYSDIV_SHIFT);\r\nv |= (div - 1) << SLEW_SYSDIV_SHIFT;\r\npic32_syskey_unlock();\r\nwritel(v, sclk->slew_reg);\r\nerr = readl_poll_timeout_atomic(sclk->slew_reg, v,\r\n!(v & SLEW_BUSY), 1, LOCK_TIMEOUT_US);\r\nspin_unlock_irqrestore(&sclk->core->reg_lock, flags);\r\nreturn err;\r\n}\r\nstatic u8 sclk_get_parent(struct clk_hw *hw)\r\n{\r\nstruct pic32_sys_clk *sclk = clkhw_to_sys_clk(hw);\r\nu32 i, v;\r\nv = (readl(sclk->mux_reg) >> OSC_CUR_SHIFT) & OSC_CUR_MASK;\r\nif (!sclk->parent_map)\r\nreturn v;\r\nfor (i = 0; i < clk_hw_get_num_parents(hw); i++)\r\nif (sclk->parent_map[i] == v)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic int sclk_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct pic32_sys_clk *sclk = clkhw_to_sys_clk(hw);\r\nunsigned long flags;\r\nu32 nosc, cosc, v;\r\nint err;\r\nspin_lock_irqsave(&sclk->core->reg_lock, flags);\r\nnosc = sclk->parent_map ? sclk->parent_map[index] : index;\r\nv = readl(sclk->mux_reg);\r\nv &= ~(OSC_NEW_MASK << OSC_NEW_SHIFT);\r\nv |= nosc << OSC_NEW_SHIFT;\r\npic32_syskey_unlock();\r\nwritel(v, sclk->mux_reg);\r\nwritel(OSC_SWEN, PIC32_SET(sclk->mux_reg));\r\ncpu_relax();\r\ncpu_nop5();\r\nerr = readl_poll_timeout_atomic(sclk->slew_reg, v,\r\n!(v & OSC_SWEN), 1, LOCK_TIMEOUT_US);\r\nspin_unlock_irqrestore(&sclk->core->reg_lock, flags);\r\ncosc = (readl(sclk->mux_reg) >> OSC_CUR_SHIFT) & OSC_CUR_MASK;\r\nif (cosc != nosc) {\r\npr_err("%s: err, failed to set_parent() to %d, current %d\n",\r\nclk_hw_get_name(hw), nosc, cosc);\r\nerr = -EBUSY;\r\n}\r\nreturn err;\r\n}\r\nstatic void sclk_init(struct clk_hw *hw)\r\n{\r\nstruct pic32_sys_clk *sclk = clkhw_to_sys_clk(hw);\r\nunsigned long flags;\r\nu32 v;\r\npic32_sclk_hw = hw;\r\nif (sclk->slew_div) {\r\nspin_lock_irqsave(&sclk->core->reg_lock, flags);\r\nv = readl(sclk->slew_reg);\r\nv &= ~(SLEW_DIV << SLEW_DIV_SHIFT);\r\nv |= sclk->slew_div << SLEW_DIV_SHIFT;\r\nv |= SLEW_DOWNEN | SLEW_UPEN;\r\nwritel(v, sclk->slew_reg);\r\nspin_unlock_irqrestore(&sclk->core->reg_lock, flags);\r\n}\r\n}\r\nstruct clk *pic32_sys_clk_register(const struct pic32_sys_clk_data *data,\r\nstruct pic32_clk_common *core)\r\n{\r\nstruct pic32_sys_clk *sclk;\r\nstruct clk *clk;\r\nsclk = devm_kzalloc(core->dev, sizeof(*sclk), GFP_KERNEL);\r\nif (!sclk)\r\nreturn ERR_PTR(-ENOMEM);\r\nsclk->core = core;\r\nsclk->hw.init = &data->init_data;\r\nsclk->mux_reg = data->mux_reg + core->iobase;\r\nsclk->slew_reg = data->slew_reg + core->iobase;\r\nsclk->slew_div = data->slew_div;\r\nsclk->parent_map = data->parent_map;\r\nclk = devm_clk_register(core->dev, &sclk->hw);\r\nif (IS_ERR(clk))\r\ndev_err(core->dev, "%s: clk register failed\n", __func__);\r\nreturn clk;\r\n}\r\nstatic int sosc_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct pic32_sec_osc *sosc = clkhw_to_sosc(hw);\r\nu32 v;\r\npic32_syskey_unlock();\r\nwritel(sosc->enable_mask, PIC32_SET(sosc->enable_reg));\r\nreturn readl_poll_timeout_atomic(sosc->status_reg, v,\r\nv & sosc->status_mask, 1, 100);\r\n}\r\nstatic void sosc_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct pic32_sec_osc *sosc = clkhw_to_sosc(hw);\r\npic32_syskey_unlock();\r\nwritel(sosc->enable_mask, PIC32_CLR(sosc->enable_reg));\r\n}\r\nstatic int sosc_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct pic32_sec_osc *sosc = clkhw_to_sosc(hw);\r\nu32 enabled, ready;\r\nenabled = readl(sosc->enable_reg) & sosc->enable_mask;\r\nready = readl(sosc->status_reg) & sosc->status_mask;\r\nreturn enabled && ready;\r\n}\r\nstatic unsigned long sosc_clk_calc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn clkhw_to_sosc(hw)->fixed_rate;\r\n}\r\nstruct clk *pic32_sosc_clk_register(const struct pic32_sec_osc_data *data,\r\nstruct pic32_clk_common *core)\r\n{\r\nstruct pic32_sec_osc *sosc;\r\nsosc = devm_kzalloc(core->dev, sizeof(*sosc), GFP_KERNEL);\r\nif (!sosc)\r\nreturn ERR_PTR(-ENOMEM);\r\nsosc->core = core;\r\nsosc->hw.init = &data->init_data;\r\nsosc->fixed_rate = data->fixed_rate;\r\nsosc->enable_mask = data->enable_mask;\r\nsosc->status_mask = data->status_mask;\r\nsosc->enable_reg = data->enable_reg + core->iobase;\r\nsosc->status_reg = data->status_reg + core->iobase;\r\nreturn devm_clk_register(core->dev, &sosc->hw);\r\n}
