static u8 sja1000_isa_mem_read_reg(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn readb(priv->reg_base + reg);\r\n}\r\nstatic void sja1000_isa_mem_write_reg(const struct sja1000_priv *priv,\r\nint reg, u8 val)\r\n{\r\nwriteb(val, priv->reg_base + reg);\r\n}\r\nstatic u8 sja1000_isa_port_read_reg(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn inb((unsigned long)priv->reg_base + reg);\r\n}\r\nstatic void sja1000_isa_port_write_reg(const struct sja1000_priv *priv,\r\nint reg, u8 val)\r\n{\r\noutb(val, (unsigned long)priv->reg_base + reg);\r\n}\r\nstatic u8 sja1000_isa_port_read_reg_indirect(const struct sja1000_priv *priv,\r\nint reg)\r\n{\r\nunsigned long flags, base = (unsigned long)priv->reg_base;\r\nu8 readval;\r\nspin_lock_irqsave(&indirect_lock[priv->dev->dev_id], flags);\r\noutb(reg, base);\r\nreadval = inb(base + 1);\r\nspin_unlock_irqrestore(&indirect_lock[priv->dev->dev_id], flags);\r\nreturn readval;\r\n}\r\nstatic void sja1000_isa_port_write_reg_indirect(const struct sja1000_priv *priv,\r\nint reg, u8 val)\r\n{\r\nunsigned long flags, base = (unsigned long)priv->reg_base;\r\nspin_lock_irqsave(&indirect_lock[priv->dev->dev_id], flags);\r\noutb(reg, base);\r\noutb(val, base + 1);\r\nspin_unlock_irqrestore(&indirect_lock[priv->dev->dev_id], flags);\r\n}\r\nstatic int sja1000_isa_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct sja1000_priv *priv;\r\nvoid __iomem *base = NULL;\r\nint iosize = SJA1000_IOSIZE;\r\nint idx = pdev->id;\r\nint err;\r\ndev_dbg(&pdev->dev, "probing idx=%d: port=%#lx, mem=%#lx, irq=%d\n",\r\nidx, port[idx], mem[idx], irq[idx]);\r\nif (mem[idx]) {\r\nif (!request_mem_region(mem[idx], iosize, DRV_NAME)) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\nbase = ioremap_nocache(mem[idx], iosize);\r\nif (!base) {\r\nerr = -ENOMEM;\r\ngoto exit_release;\r\n}\r\n} else {\r\nif (indirect[idx] > 0 ||\r\n(indirect[idx] == -1 && indirect[0] > 0))\r\niosize = SJA1000_IOSIZE_INDIRECT;\r\nif (!request_region(port[idx], iosize, DRV_NAME)) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\n}\r\ndev = alloc_sja1000dev(0);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto exit_unmap;\r\n}\r\npriv = netdev_priv(dev);\r\ndev->irq = irq[idx];\r\npriv->irq_flags = IRQF_SHARED;\r\nif (mem[idx]) {\r\npriv->reg_base = base;\r\ndev->base_addr = mem[idx];\r\npriv->read_reg = sja1000_isa_mem_read_reg;\r\npriv->write_reg = sja1000_isa_mem_write_reg;\r\n} else {\r\npriv->reg_base = (void __iomem *)port[idx];\r\ndev->base_addr = port[idx];\r\nif (iosize == SJA1000_IOSIZE_INDIRECT) {\r\npriv->read_reg = sja1000_isa_port_read_reg_indirect;\r\npriv->write_reg = sja1000_isa_port_write_reg_indirect;\r\nspin_lock_init(&indirect_lock[idx]);\r\n} else {\r\npriv->read_reg = sja1000_isa_port_read_reg;\r\npriv->write_reg = sja1000_isa_port_write_reg;\r\n}\r\n}\r\nif (clk[idx])\r\npriv->can.clock.freq = clk[idx] / 2;\r\nelse if (clk[0])\r\npriv->can.clock.freq = clk[0] / 2;\r\nelse\r\npriv->can.clock.freq = CLK_DEFAULT / 2;\r\nif (ocr[idx] != 0xff)\r\npriv->ocr = ocr[idx];\r\nelse if (ocr[0] != 0xff)\r\npriv->ocr = ocr[0];\r\nelse\r\npriv->ocr = OCR_DEFAULT;\r\nif (cdr[idx] != 0xff)\r\npriv->cdr = cdr[idx];\r\nelse if (cdr[0] != 0xff)\r\npriv->cdr = cdr[0];\r\nelse\r\npriv->cdr = CDR_DEFAULT;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ndev->dev_id = idx;\r\nerr = register_sja1000dev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "registering %s failed (err=%d)\n",\r\nDRV_NAME, err);\r\ngoto exit_unmap;\r\n}\r\ndev_info(&pdev->dev, "%s device registered (reg_base=0x%p, irq=%d)\n",\r\nDRV_NAME, priv->reg_base, dev->irq);\r\nreturn 0;\r\nexit_unmap:\r\nif (mem[idx])\r\niounmap(base);\r\nexit_release:\r\nif (mem[idx])\r\nrelease_mem_region(mem[idx], iosize);\r\nelse\r\nrelease_region(port[idx], iosize);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int sja1000_isa_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nint idx = pdev->id;\r\nunregister_sja1000dev(dev);\r\nif (mem[idx]) {\r\niounmap(priv->reg_base);\r\nrelease_mem_region(mem[idx], SJA1000_IOSIZE);\r\n} else {\r\nif (priv->read_reg == sja1000_isa_port_read_reg_indirect)\r\nrelease_region(port[idx], SJA1000_IOSIZE_INDIRECT);\r\nelse\r\nrelease_region(port[idx], SJA1000_IOSIZE);\r\n}\r\nfree_sja1000dev(dev);\r\nreturn 0;\r\n}\r\nstatic int __init sja1000_isa_init(void)\r\n{\r\nint idx, err;\r\nfor (idx = 0; idx < MAXDEV; idx++) {\r\nif ((port[idx] || mem[idx]) && irq[idx]) {\r\nsja1000_isa_devs[idx] =\r\nplatform_device_alloc(DRV_NAME, idx);\r\nif (!sja1000_isa_devs[idx]) {\r\nerr = -ENOMEM;\r\ngoto exit_free_devices;\r\n}\r\nerr = platform_device_add(sja1000_isa_devs[idx]);\r\nif (err) {\r\nplatform_device_put(sja1000_isa_devs[idx]);\r\ngoto exit_free_devices;\r\n}\r\npr_debug("%s: platform device %d: port=%#lx, mem=%#lx, "\r\n"irq=%d\n",\r\nDRV_NAME, idx, port[idx], mem[idx], irq[idx]);\r\n} else if (idx == 0 || port[idx] || mem[idx]) {\r\npr_err("%s: insufficient parameters supplied\n",\r\nDRV_NAME);\r\nerr = -EINVAL;\r\ngoto exit_free_devices;\r\n}\r\n}\r\nerr = platform_driver_register(&sja1000_isa_driver);\r\nif (err)\r\ngoto exit_free_devices;\r\npr_info("Legacy %s driver for max. %d devices registered\n",\r\nDRV_NAME, MAXDEV);\r\nreturn 0;\r\nexit_free_devices:\r\nwhile (--idx >= 0) {\r\nif (sja1000_isa_devs[idx])\r\nplatform_device_unregister(sja1000_isa_devs[idx]);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit sja1000_isa_exit(void)\r\n{\r\nint idx;\r\nplatform_driver_unregister(&sja1000_isa_driver);\r\nfor (idx = 0; idx < MAXDEV; idx++) {\r\nif (sja1000_isa_devs[idx])\r\nplatform_device_unregister(sja1000_isa_devs[idx]);\r\n}\r\n}
