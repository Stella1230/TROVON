static int __i2c_mux_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct i2c_mux_priv *priv = adap->algo_data;\r\nstruct i2c_mux_core *muxc = priv->muxc;\r\nstruct i2c_adapter *parent = muxc->parent;\r\nint ret;\r\nret = muxc->select(muxc, priv->chan_id);\r\nif (ret >= 0)\r\nret = __i2c_transfer(parent, msgs, num);\r\nif (muxc->deselect)\r\nmuxc->deselect(muxc, priv->chan_id);\r\nreturn ret;\r\n}\r\nstatic int i2c_mux_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct i2c_mux_priv *priv = adap->algo_data;\r\nstruct i2c_mux_core *muxc = priv->muxc;\r\nstruct i2c_adapter *parent = muxc->parent;\r\nint ret;\r\nret = muxc->select(muxc, priv->chan_id);\r\nif (ret >= 0)\r\nret = i2c_transfer(parent, msgs, num);\r\nif (muxc->deselect)\r\nmuxc->deselect(muxc, priv->chan_id);\r\nreturn ret;\r\n}\r\nstatic int __i2c_mux_smbus_xfer(struct i2c_adapter *adap,\r\nu16 addr, unsigned short flags,\r\nchar read_write, u8 command,\r\nint size, union i2c_smbus_data *data)\r\n{\r\nstruct i2c_mux_priv *priv = adap->algo_data;\r\nstruct i2c_mux_core *muxc = priv->muxc;\r\nstruct i2c_adapter *parent = muxc->parent;\r\nint ret;\r\nret = muxc->select(muxc, priv->chan_id);\r\nif (ret >= 0)\r\nret = parent->algo->smbus_xfer(parent, addr, flags,\r\nread_write, command, size, data);\r\nif (muxc->deselect)\r\nmuxc->deselect(muxc, priv->chan_id);\r\nreturn ret;\r\n}\r\nstatic int i2c_mux_smbus_xfer(struct i2c_adapter *adap,\r\nu16 addr, unsigned short flags,\r\nchar read_write, u8 command,\r\nint size, union i2c_smbus_data *data)\r\n{\r\nstruct i2c_mux_priv *priv = adap->algo_data;\r\nstruct i2c_mux_core *muxc = priv->muxc;\r\nstruct i2c_adapter *parent = muxc->parent;\r\nint ret;\r\nret = muxc->select(muxc, priv->chan_id);\r\nif (ret >= 0)\r\nret = i2c_smbus_xfer(parent, addr, flags,\r\nread_write, command, size, data);\r\nif (muxc->deselect)\r\nmuxc->deselect(muxc, priv->chan_id);\r\nreturn ret;\r\n}\r\nstatic u32 i2c_mux_functionality(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_mux_priv *priv = adap->algo_data;\r\nstruct i2c_adapter *parent = priv->muxc->parent;\r\nreturn parent->algo->functionality(parent);\r\n}\r\nstatic unsigned int i2c_mux_parent_classes(struct i2c_adapter *parent)\r\n{\r\nunsigned int class = 0;\r\ndo {\r\nclass |= parent->class;\r\nparent = i2c_parent_is_i2c_adapter(parent);\r\n} while (parent);\r\nreturn class;\r\n}\r\nstatic void i2c_mux_lock_bus(struct i2c_adapter *adapter, unsigned int flags)\r\n{\r\nstruct i2c_mux_priv *priv = adapter->algo_data;\r\nstruct i2c_adapter *parent = priv->muxc->parent;\r\nrt_mutex_lock(&parent->mux_lock);\r\nif (!(flags & I2C_LOCK_ROOT_ADAPTER))\r\nreturn;\r\ni2c_lock_bus(parent, flags);\r\n}\r\nstatic int i2c_mux_trylock_bus(struct i2c_adapter *adapter, unsigned int flags)\r\n{\r\nstruct i2c_mux_priv *priv = adapter->algo_data;\r\nstruct i2c_adapter *parent = priv->muxc->parent;\r\nif (!rt_mutex_trylock(&parent->mux_lock))\r\nreturn 0;\r\nif (!(flags & I2C_LOCK_ROOT_ADAPTER))\r\nreturn 1;\r\nif (parent->trylock_bus(parent, flags))\r\nreturn 1;\r\nrt_mutex_unlock(&parent->mux_lock);\r\nreturn 0;\r\n}\r\nstatic void i2c_mux_unlock_bus(struct i2c_adapter *adapter, unsigned int flags)\r\n{\r\nstruct i2c_mux_priv *priv = adapter->algo_data;\r\nstruct i2c_adapter *parent = priv->muxc->parent;\r\nif (flags & I2C_LOCK_ROOT_ADAPTER)\r\ni2c_unlock_bus(parent, flags);\r\nrt_mutex_unlock(&parent->mux_lock);\r\n}\r\nstatic void i2c_parent_lock_bus(struct i2c_adapter *adapter,\r\nunsigned int flags)\r\n{\r\nstruct i2c_mux_priv *priv = adapter->algo_data;\r\nstruct i2c_adapter *parent = priv->muxc->parent;\r\nrt_mutex_lock(&parent->mux_lock);\r\ni2c_lock_bus(parent, flags);\r\n}\r\nstatic int i2c_parent_trylock_bus(struct i2c_adapter *adapter,\r\nunsigned int flags)\r\n{\r\nstruct i2c_mux_priv *priv = adapter->algo_data;\r\nstruct i2c_adapter *parent = priv->muxc->parent;\r\nif (!rt_mutex_trylock(&parent->mux_lock))\r\nreturn 0;\r\nif (parent->trylock_bus(parent, flags))\r\nreturn 1;\r\nrt_mutex_unlock(&parent->mux_lock);\r\nreturn 0;\r\n}\r\nstatic void i2c_parent_unlock_bus(struct i2c_adapter *adapter,\r\nunsigned int flags)\r\n{\r\nstruct i2c_mux_priv *priv = adapter->algo_data;\r\nstruct i2c_adapter *parent = priv->muxc->parent;\r\ni2c_unlock_bus(parent, flags);\r\nrt_mutex_unlock(&parent->mux_lock);\r\n}\r\nstruct i2c_adapter *i2c_root_adapter(struct device *dev)\r\n{\r\nstruct device *i2c;\r\nstruct i2c_adapter *i2c_root;\r\nfor (i2c = dev; i2c; i2c = i2c->parent) {\r\nif (i2c->type == &i2c_adapter_type)\r\nbreak;\r\n}\r\nif (!i2c)\r\nreturn NULL;\r\ni2c_root = to_i2c_adapter(i2c);\r\nwhile (i2c_parent_is_i2c_adapter(i2c_root))\r\ni2c_root = i2c_parent_is_i2c_adapter(i2c_root);\r\nreturn i2c_root;\r\n}\r\nstruct i2c_mux_core *i2c_mux_alloc(struct i2c_adapter *parent,\r\nstruct device *dev, int max_adapters,\r\nint sizeof_priv, u32 flags,\r\nint (*select)(struct i2c_mux_core *, u32),\r\nint (*deselect)(struct i2c_mux_core *, u32))\r\n{\r\nstruct i2c_mux_core *muxc;\r\nmuxc = devm_kzalloc(dev, sizeof(*muxc)\r\n+ max_adapters * sizeof(muxc->adapter[0])\r\n+ sizeof_priv, GFP_KERNEL);\r\nif (!muxc)\r\nreturn NULL;\r\nif (sizeof_priv)\r\nmuxc->priv = &muxc->adapter[max_adapters];\r\nmuxc->parent = parent;\r\nmuxc->dev = dev;\r\nif (flags & I2C_MUX_LOCKED)\r\nmuxc->mux_locked = true;\r\nmuxc->select = select;\r\nmuxc->deselect = deselect;\r\nmuxc->max_adapters = max_adapters;\r\nreturn muxc;\r\n}\r\nint i2c_mux_add_adapter(struct i2c_mux_core *muxc,\r\nu32 force_nr, u32 chan_id,\r\nunsigned int class)\r\n{\r\nstruct i2c_adapter *parent = muxc->parent;\r\nstruct i2c_mux_priv *priv;\r\nchar symlink_name[20];\r\nint ret;\r\nif (muxc->num_adapters >= muxc->max_adapters) {\r\ndev_err(muxc->dev, "No room for more i2c-mux adapters\n");\r\nreturn -EINVAL;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->muxc = muxc;\r\npriv->chan_id = chan_id;\r\nif (parent->algo->master_xfer) {\r\nif (muxc->mux_locked)\r\npriv->algo.master_xfer = i2c_mux_master_xfer;\r\nelse\r\npriv->algo.master_xfer = __i2c_mux_master_xfer;\r\n}\r\nif (parent->algo->smbus_xfer) {\r\nif (muxc->mux_locked)\r\npriv->algo.smbus_xfer = i2c_mux_smbus_xfer;\r\nelse\r\npriv->algo.smbus_xfer = __i2c_mux_smbus_xfer;\r\n}\r\npriv->algo.functionality = i2c_mux_functionality;\r\nsnprintf(priv->adap.name, sizeof(priv->adap.name),\r\n"i2c-%d-mux (chan_id %d)", i2c_adapter_id(parent), chan_id);\r\npriv->adap.owner = THIS_MODULE;\r\npriv->adap.algo = &priv->algo;\r\npriv->adap.algo_data = priv;\r\npriv->adap.dev.parent = &parent->dev;\r\npriv->adap.retries = parent->retries;\r\npriv->adap.timeout = parent->timeout;\r\npriv->adap.quirks = parent->quirks;\r\nif (muxc->mux_locked) {\r\npriv->adap.lock_bus = i2c_mux_lock_bus;\r\npriv->adap.trylock_bus = i2c_mux_trylock_bus;\r\npriv->adap.unlock_bus = i2c_mux_unlock_bus;\r\n} else {\r\npriv->adap.lock_bus = i2c_parent_lock_bus;\r\npriv->adap.trylock_bus = i2c_parent_trylock_bus;\r\npriv->adap.unlock_bus = i2c_parent_unlock_bus;\r\n}\r\nif (i2c_mux_parent_classes(parent) & class)\r\ndev_err(&parent->dev,\r\n"Segment %d behind mux can't share classes with ancestors\n",\r\nchan_id);\r\nelse\r\npriv->adap.class = class;\r\nif (muxc->dev->of_node) {\r\nstruct device_node *child;\r\nu32 reg;\r\nfor_each_child_of_node(muxc->dev->of_node, child) {\r\nret = of_property_read_u32(child, "reg", &reg);\r\nif (ret)\r\ncontinue;\r\nif (chan_id == reg) {\r\npriv->adap.dev.of_node = child;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (has_acpi_companion(muxc->dev))\r\nacpi_preset_companion(&priv->adap.dev,\r\nACPI_COMPANION(muxc->dev),\r\nchan_id);\r\nif (force_nr) {\r\npriv->adap.nr = force_nr;\r\nret = i2c_add_numbered_adapter(&priv->adap);\r\n} else {\r\nret = i2c_add_adapter(&priv->adap);\r\n}\r\nif (ret < 0) {\r\ndev_err(&parent->dev,\r\n"failed to add mux-adapter (error=%d)\n",\r\nret);\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nWARN(sysfs_create_link(&priv->adap.dev.kobj, &muxc->dev->kobj,\r\n"mux_device"),\r\n"can't create symlink to mux device\n");\r\nsnprintf(symlink_name, sizeof(symlink_name), "channel-%u", chan_id);\r\nWARN(sysfs_create_link(&muxc->dev->kobj, &priv->adap.dev.kobj,\r\nsymlink_name),\r\n"can't create symlink for channel %u\n", chan_id);\r\ndev_info(&parent->dev, "Added multiplexed i2c bus %d\n",\r\ni2c_adapter_id(&priv->adap));\r\nmuxc->adapter[muxc->num_adapters++] = &priv->adap;\r\nreturn 0;\r\n}\r\nvoid i2c_mux_del_adapters(struct i2c_mux_core *muxc)\r\n{\r\nchar symlink_name[20];\r\nwhile (muxc->num_adapters) {\r\nstruct i2c_adapter *adap = muxc->adapter[--muxc->num_adapters];\r\nstruct i2c_mux_priv *priv = adap->algo_data;\r\nmuxc->adapter[muxc->num_adapters] = NULL;\r\nsnprintf(symlink_name, sizeof(symlink_name),\r\n"channel-%u", priv->chan_id);\r\nsysfs_remove_link(&muxc->dev->kobj, symlink_name);\r\nsysfs_remove_link(&priv->adap.dev.kobj, "mux_device");\r\ni2c_del_adapter(adap);\r\nkfree(priv);\r\n}\r\n}
