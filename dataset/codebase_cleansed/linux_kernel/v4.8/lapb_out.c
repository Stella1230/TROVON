static void lapb_send_iframe(struct lapb_cb *lapb, struct sk_buff *skb, int poll_bit)\r\n{\r\nunsigned char *frame;\r\nif (!skb)\r\nreturn;\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nframe = skb_push(skb, 2);\r\nframe[0] = LAPB_I;\r\nframe[0] |= lapb->vs << 1;\r\nframe[1] = poll_bit ? LAPB_EPF : 0;\r\nframe[1] |= lapb->vr << 1;\r\n} else {\r\nframe = skb_push(skb, 1);\r\n*frame = LAPB_I;\r\n*frame |= poll_bit ? LAPB_SPF : 0;\r\n*frame |= lapb->vr << 5;\r\n*frame |= lapb->vs << 1;\r\n}\r\nlapb_dbg(1, "(%p) S%d TX I(%d) S%d R%d\n",\r\nlapb->dev, lapb->state, poll_bit, lapb->vs, lapb->vr);\r\nlapb_transmit_buffer(lapb, skb, LAPB_COMMAND);\r\n}\r\nvoid lapb_kick(struct lapb_cb *lapb)\r\n{\r\nstruct sk_buff *skb, *skbn;\r\nunsigned short modulus, start, end;\r\nmodulus = (lapb->mode & LAPB_EXTENDED) ? LAPB_EMODULUS : LAPB_SMODULUS;\r\nstart = !skb_peek(&lapb->ack_queue) ? lapb->va : lapb->vs;\r\nend = (lapb->va + lapb->window) % modulus;\r\nif (!(lapb->condition & LAPB_PEER_RX_BUSY_CONDITION) &&\r\nstart != end && skb_peek(&lapb->write_queue)) {\r\nlapb->vs = start;\r\nskb = skb_dequeue(&lapb->write_queue);\r\ndo {\r\nif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {\r\nskb_queue_head(&lapb->write_queue, skb);\r\nbreak;\r\n}\r\nif (skb->sk)\r\nskb_set_owner_w(skbn, skb->sk);\r\nlapb_send_iframe(lapb, skbn, LAPB_POLLOFF);\r\nlapb->vs = (lapb->vs + 1) % modulus;\r\nskb_queue_tail(&lapb->ack_queue, skb);\r\n} while (lapb->vs != end && (skb = skb_dequeue(&lapb->write_queue)) != NULL);\r\nlapb->condition &= ~LAPB_ACK_PENDING_CONDITION;\r\nif (!lapb_t1timer_running(lapb))\r\nlapb_start_t1timer(lapb);\r\n}\r\n}\r\nvoid lapb_transmit_buffer(struct lapb_cb *lapb, struct sk_buff *skb, int type)\r\n{\r\nunsigned char *ptr;\r\nptr = skb_push(skb, 1);\r\nif (lapb->mode & LAPB_MLP) {\r\nif (lapb->mode & LAPB_DCE) {\r\nif (type == LAPB_COMMAND)\r\n*ptr = LAPB_ADDR_C;\r\nif (type == LAPB_RESPONSE)\r\n*ptr = LAPB_ADDR_D;\r\n} else {\r\nif (type == LAPB_COMMAND)\r\n*ptr = LAPB_ADDR_D;\r\nif (type == LAPB_RESPONSE)\r\n*ptr = LAPB_ADDR_C;\r\n}\r\n} else {\r\nif (lapb->mode & LAPB_DCE) {\r\nif (type == LAPB_COMMAND)\r\n*ptr = LAPB_ADDR_A;\r\nif (type == LAPB_RESPONSE)\r\n*ptr = LAPB_ADDR_B;\r\n} else {\r\nif (type == LAPB_COMMAND)\r\n*ptr = LAPB_ADDR_B;\r\nif (type == LAPB_RESPONSE)\r\n*ptr = LAPB_ADDR_A;\r\n}\r\n}\r\nlapb_dbg(2, "(%p) S%d TX %3ph\n", lapb->dev, lapb->state, skb->data);\r\nif (!lapb_data_transmit(lapb, skb))\r\nkfree_skb(skb);\r\n}\r\nvoid lapb_establish_data_link(struct lapb_cb *lapb)\r\n{\r\nlapb->condition = 0x00;\r\nlapb->n2count = 0;\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nlapb_dbg(1, "(%p) S%d TX SABME(1)\n", lapb->dev, lapb->state);\r\nlapb_send_control(lapb, LAPB_SABME, LAPB_POLLON, LAPB_COMMAND);\r\n} else {\r\nlapb_dbg(1, "(%p) S%d TX SABM(1)\n", lapb->dev, lapb->state);\r\nlapb_send_control(lapb, LAPB_SABM, LAPB_POLLON, LAPB_COMMAND);\r\n}\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\n}\r\nvoid lapb_enquiry_response(struct lapb_cb *lapb)\r\n{\r\nlapb_dbg(1, "(%p) S%d TX RR(1) R%d\n",\r\nlapb->dev, lapb->state, lapb->vr);\r\nlapb_send_control(lapb, LAPB_RR, LAPB_POLLON, LAPB_RESPONSE);\r\nlapb->condition &= ~LAPB_ACK_PENDING_CONDITION;\r\n}\r\nvoid lapb_timeout_response(struct lapb_cb *lapb)\r\n{\r\nlapb_dbg(1, "(%p) S%d TX RR(0) R%d\n",\r\nlapb->dev, lapb->state, lapb->vr);\r\nlapb_send_control(lapb, LAPB_RR, LAPB_POLLOFF, LAPB_RESPONSE);\r\nlapb->condition &= ~LAPB_ACK_PENDING_CONDITION;\r\n}\r\nvoid lapb_check_iframes_acked(struct lapb_cb *lapb, unsigned short nr)\r\n{\r\nif (lapb->vs == nr) {\r\nlapb_frames_acked(lapb, nr);\r\nlapb_stop_t1timer(lapb);\r\nlapb->n2count = 0;\r\n} else if (lapb->va != nr) {\r\nlapb_frames_acked(lapb, nr);\r\nlapb_start_t1timer(lapb);\r\n}\r\n}\r\nvoid lapb_check_need_response(struct lapb_cb *lapb, int type, int pf)\r\n{\r\nif (type == LAPB_COMMAND && pf)\r\nlapb_enquiry_response(lapb);\r\n}
