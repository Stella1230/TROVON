int rtw_ch_set_search_ch(struct rt_channel_info *ch_set, const u32 ch)\r\n{\r\nint i;\r\nfor (i = 0; ch_set[i].ChannelNum != 0; i++) {\r\nif (ch == ch_set[i].ChannelNum)\r\nbreak;\r\n}\r\nif (i >= ch_set[i].ChannelNum)\r\nreturn -1;\r\nreturn i;\r\n}\r\nstruct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv)\r\n{\r\nstruct xmit_frame *pmgntframe;\r\nstruct xmit_buf *pxmitbuf;\r\npmgntframe = rtw_alloc_xmitframe(pxmitpriv);\r\nif (pmgntframe == NULL) {\r\nDBG_88E("%s, alloc xmitframe fail\n", __func__);\r\nreturn NULL;\r\n}\r\npxmitbuf = rtw_alloc_xmitbuf_ext(pxmitpriv);\r\nif (pxmitbuf == NULL) {\r\nDBG_88E("%s, alloc xmitbuf fail\n", __func__);\r\nrtw_free_xmitframe(pxmitpriv, pmgntframe);\r\nreturn NULL;\r\n}\r\npmgntframe->frame_tag = MGNT_FRAMETAG;\r\npmgntframe->pxmitbuf = pxmitbuf;\r\npmgntframe->buf_addr = pxmitbuf->pbuf;\r\npxmitbuf->priv_data = pmgntframe;\r\nreturn pmgntframe;\r\n}\r\nvoid update_mgnt_tx_rate(struct adapter *padapter, u8 rate)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\npmlmeext->tx_rate = rate;\r\nDBG_88E("%s(): rate = %x\n", __func__, rate);\r\n}\r\nvoid update_mgntframe_attrib(struct adapter *padapter, struct pkt_attrib *pattrib)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nmemset((u8 *)(pattrib), 0, sizeof(struct pkt_attrib));\r\npattrib->hdrlen = 24;\r\npattrib->nr_frags = 1;\r\npattrib->priority = 7;\r\npattrib->mac_id = 0;\r\npattrib->qsel = 0x12;\r\npattrib->pktlen = 0;\r\nif (pmlmeext->cur_wireless_mode & WIRELESS_11B)\r\npattrib->raid = 6;\r\nelse\r\npattrib->raid = 5;\r\npattrib->encrypt = _NO_PRIVACY_;\r\npattrib->bswenc = false;\r\npattrib->qos_en = false;\r\npattrib->ht_en = false;\r\npattrib->bwmode = HT_CHANNEL_WIDTH_20;\r\npattrib->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\npattrib->sgi = false;\r\npattrib->seqnum = pmlmeext->mgnt_seq;\r\npattrib->retry_ctrl = true;\r\n}\r\nstatic void dump_mgntframe(struct adapter *padapter,\r\nstruct xmit_frame *pmgntframe)\r\n{\r\nif (padapter->bSurpriseRemoved || padapter->bDriverStopped)\r\nreturn;\r\nrtw_hal_mgnt_xmit(padapter, pmgntframe);\r\n}\r\nstatic s32 dump_mgntframe_and_wait(struct adapter *padapter,\r\nstruct xmit_frame *pmgntframe,\r\nint timeout_ms)\r\n{\r\ns32 ret = _FAIL;\r\nstruct xmit_buf *pxmitbuf = pmgntframe->pxmitbuf;\r\nstruct submit_ctx sctx;\r\nif (padapter->bSurpriseRemoved || padapter->bDriverStopped)\r\nreturn ret;\r\nrtw_sctx_init(&sctx, timeout_ms);\r\npxmitbuf->sctx = &sctx;\r\nret = rtw_hal_mgnt_xmit(padapter, pmgntframe);\r\nif (ret == _SUCCESS)\r\nret = rtw_sctx_wait(&sctx);\r\nreturn ret;\r\n}\r\nstatic s32 dump_mgntframe_and_wait_ack(struct adapter *padapter,\r\nstruct xmit_frame *pmgntframe)\r\n{\r\ns32 ret = _FAIL;\r\nu32 timeout_ms = 500;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nif (padapter->bSurpriseRemoved || padapter->bDriverStopped)\r\nreturn -1;\r\nif (mutex_lock_interruptible(&pxmitpriv->ack_tx_mutex))\r\nreturn _FAIL;\r\npxmitpriv->ack_tx = true;\r\npmgntframe->ack_report = 1;\r\nif (rtw_hal_mgnt_xmit(padapter, pmgntframe) == _SUCCESS) {\r\nret = rtw_ack_tx_wait(pxmitpriv, timeout_ms);\r\n}\r\npxmitpriv->ack_tx = false;\r\nmutex_unlock(&pxmitpriv->ack_tx_mutex);\r\nreturn ret;\r\n}\r\nstatic int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)\r\n{\r\nu8 *ssid_ie;\r\nint ssid_len_ori;\r\nint len_diff = 0;\r\nssid_ie = rtw_get_ie(ies, WLAN_EID_SSID, &ssid_len_ori, ies_len);\r\nif (ssid_ie && ssid_len_ori > 0) {\r\nswitch (hidden_ssid_mode) {\r\ncase 1: {\r\nu8 *next_ie = ssid_ie + 2 + ssid_len_ori;\r\nu32 remain_len = 0;\r\nremain_len = ies_len - (next_ie - ies);\r\nssid_ie[1] = 0;\r\nmemcpy(ssid_ie+2, next_ie, remain_len);\r\nlen_diff -= ssid_len_ori;\r\nbreak;\r\n}\r\ncase 2:\r\nmemset(&ssid_ie[2], 0, ssid_len_ori);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn len_diff;\r\n}\r\nstatic void issue_beacon(struct adapter *padapter, int timeout_ms)\r\n{\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nunsigned int rate_len;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nu8 bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL) {\r\nDBG_88E("%s, alloc mgnt frame fail\n", __func__);\r\nreturn;\r\n}\r\n#if defined(CONFIG_88EU_AP_MODE)\r\nspin_lock_bh(&pmlmepriv->bcn_update_lock);\r\n#endif\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\npattrib->qsel = 0x10;\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, cur_network->MacAddress, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, 0);\r\nSetFrameSubType(pframe, WIFI_BEACON);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\r\nint len_diff;\r\nu8 *wps_ie;\r\nuint wps_ielen;\r\nu8 sr = 0;\r\nmemcpy(pframe, cur_network->IEs, cur_network->IELength);\r\nlen_diff = update_hidden_ssid(\r\npframe+_BEACON_IE_OFFSET_\r\n, cur_network->IELength-_BEACON_IE_OFFSET_\r\n, pmlmeinfo->hidden_ssid_mode\r\n);\r\npframe += (cur_network->IELength+len_diff);\r\npattrib->pktlen += (cur_network->IELength+len_diff);\r\nwps_ie = rtw_get_wps_ie(pmgntframe->buf_addr+TXDESC_OFFSET+sizeof(struct rtw_ieee80211_hdr_3addr)+_BEACON_IE_OFFSET_,\r\npattrib->pktlen-sizeof(struct rtw_ieee80211_hdr_3addr)-_BEACON_IE_OFFSET_, NULL, &wps_ielen);\r\nif (wps_ie && wps_ielen > 0)\r\nrtw_get_wps_attr_content(wps_ie, wps_ielen, WPS_ATTR_SELECTED_REGISTRAR, (u8 *)(&sr), NULL);\r\nif (sr != 0)\r\nset_fwstate(pmlmepriv, WIFI_UNDER_WPS);\r\nelse\r\n_clr_fwstate_(pmlmepriv, WIFI_UNDER_WPS);\r\ngoto _issue_bcn;\r\n}\r\npframe += 8;\r\npattrib->pktlen += 8;\r\nmemcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);\r\npframe += 2;\r\npattrib->pktlen += 2;\r\nmemcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);\r\npframe += 2;\r\npattrib->pktlen += 2;\r\npframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pattrib->pktlen);\r\nrate_len = rtw_get_rateset_len(cur_network->SupportedRates);\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, min_t(unsigned int, rate_len, 8), cur_network->SupportedRates, &pattrib->pktlen);\r\npframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);\r\n{\r\nu8 erpinfo = 0;\r\nu32 ATIMWindow;\r\nATIMWindow = 0;\r\npframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);\r\npframe = rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo, &pattrib->pktlen);\r\n}\r\nif (rate_len > 8)\r\npframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pattrib->pktlen);\r\n_issue_bcn:\r\n#if defined(CONFIG_88EU_AP_MODE)\r\npmlmepriv->update_bcn = false;\r\nspin_unlock_bh(&pmlmepriv->bcn_update_lock);\r\n#endif\r\nif ((pattrib->pktlen + TXDESC_SIZE) > 512) {\r\nDBG_88E("beacon frame too large\n");\r\nreturn;\r\n}\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\nif (timeout_ms > 0)\r\ndump_mgntframe_and_wait(padapter, pmgntframe, timeout_ms);\r\nelse\r\ndump_mgntframe(padapter, pmgntframe);\r\n}\r\nstatic void issue_probersp(struct adapter *padapter, unsigned char *da)\r\n{\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nunsigned char *mac, *bssid;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\n#if defined(CONFIG_88EU_AP_MODE)\r\nu8 *pwps_ie;\r\nuint wps_ielen;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\n#endif\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nunsigned int rate_len;\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL) {\r\nDBG_88E("%s, alloc mgnt frame fail\n", __func__);\r\nreturn;\r\n}\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nmac = myid(&(padapter->eeprompriv));\r\nbssid = cur_network->MacAddress;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, da, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, mac, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, bssid, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nSetFrameSubType(fctrl, WIFI_PROBERSP);\r\npattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen = pattrib->hdrlen;\r\npframe += pattrib->hdrlen;\r\nif (cur_network->IELength > MAX_IE_SZ)\r\nreturn;\r\n#if defined(CONFIG_88EU_AP_MODE)\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\r\npwps_ie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen);\r\nif ((pmlmepriv->wps_probe_resp_ie != NULL) && pwps_ie && (wps_ielen > 0)) {\r\nuint wps_offset, remainder_ielen;\r\nu8 *premainder_ie;\r\nwps_offset = (uint)(pwps_ie - cur_network->IEs);\r\npremainder_ie = pwps_ie + wps_ielen;\r\nremainder_ielen = cur_network->IELength - wps_offset - wps_ielen;\r\nmemcpy(pframe, cur_network->IEs, wps_offset);\r\npframe += wps_offset;\r\npattrib->pktlen += wps_offset;\r\nwps_ielen = (uint)pmlmepriv->wps_probe_resp_ie[1];\r\nif ((wps_offset+wps_ielen+2) <= MAX_IE_SZ) {\r\nmemcpy(pframe, pmlmepriv->wps_probe_resp_ie, wps_ielen+2);\r\npframe += wps_ielen+2;\r\npattrib->pktlen += wps_ielen+2;\r\n}\r\nif ((wps_offset+wps_ielen+2+remainder_ielen) <= MAX_IE_SZ) {\r\nmemcpy(pframe, premainder_ie, remainder_ielen);\r\npframe += remainder_ielen;\r\npattrib->pktlen += remainder_ielen;\r\n}\r\n} else {\r\nmemcpy(pframe, cur_network->IEs, cur_network->IELength);\r\npframe += cur_network->IELength;\r\npattrib->pktlen += cur_network->IELength;\r\n}\r\n} else\r\n#endif\r\n{\r\npframe += 8;\r\npattrib->pktlen += 8;\r\nmemcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);\r\npframe += 2;\r\npattrib->pktlen += 2;\r\nmemcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);\r\npframe += 2;\r\npattrib->pktlen += 2;\r\npframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pattrib->pktlen);\r\nrate_len = rtw_get_rateset_len(cur_network->SupportedRates);\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, min_t(unsigned int, rate_len, 8), cur_network->SupportedRates, &pattrib->pktlen);\r\npframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {\r\nu8 erpinfo = 0;\r\nu32 ATIMWindow;\r\nATIMWindow = 0;\r\npframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);\r\npframe = rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo, &pattrib->pktlen);\r\n}\r\nif (rate_len > 8)\r\npframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pattrib->pktlen);\r\n}\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\ndump_mgntframe(padapter, pmgntframe);\r\n}\r\nstatic int issue_probereq(struct adapter *padapter, struct ndis_802_11_ssid *pssid, u8 *da, bool wait_ack)\r\n{\r\nint ret = _FAIL;\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nunsigned char *mac;\r\nunsigned char bssrate[NumRates];\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nint bssrate_len = 0;\r\nu8 bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+issue_probereq\n"));\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\ngoto exit;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nmac = myid(&(padapter->eeprompriv));\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nif (da) {\r\nmemcpy(pwlanhdr->addr1, da, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, da, ETH_ALEN);\r\n} else {\r\nmemcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, bc_addr, ETH_ALEN);\r\n}\r\nmemcpy(pwlanhdr->addr2, mac, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nSetFrameSubType(pframe, WIFI_PROBEREQ);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\nif (pssid)\r\npframe = rtw_set_ie(pframe, _SSID_IE_, pssid->SsidLength, pssid->Ssid, &(pattrib->pktlen));\r\nelse\r\npframe = rtw_set_ie(pframe, _SSID_IE_, 0, NULL, &(pattrib->pktlen));\r\nget_rate_set(padapter, bssrate, &bssrate_len);\r\nif (bssrate_len > 8) {\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , 8, bssrate, &(pattrib->pktlen));\r\npframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));\r\n} else {\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));\r\n}\r\nif (pmlmepriv->wps_probe_req_ie_len > 0 && pmlmepriv->wps_probe_req_ie) {\r\nmemcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);\r\npframe += pmlmepriv->wps_probe_req_ie_len;\r\npattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;\r\n}\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,\r\n("issuing probe_req, tx_len=%d\n", pattrib->last_txcmdsz));\r\nif (wait_ack) {\r\nret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);\r\n} else {\r\ndump_mgntframe(padapter, pmgntframe);\r\nret = _SUCCESS;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int issue_probereq_ex(struct adapter *padapter,\r\nstruct ndis_802_11_ssid *pssid, u8 *da,\r\nint try_cnt, int wait_ms)\r\n{\r\nint ret;\r\nint i = 0;\r\nunsigned long start = jiffies;\r\ndo {\r\nret = issue_probereq(padapter, pssid, da, wait_ms > 0 ? true : false);\r\ni++;\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\r\nbreak;\r\nif (i < try_cnt && wait_ms > 0 && ret == _FAIL)\r\nmsleep(wait_ms);\r\n} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));\r\nif (ret != _FAIL) {\r\nret = _SUCCESS;\r\ngoto exit;\r\n}\r\nif (try_cnt && wait_ms) {\r\nif (da)\r\nDBG_88E(FUNC_ADPT_FMT" to %pM, ch:%u%s, %d/%d in %u ms\n",\r\nFUNC_ADPT_ARG(padapter), da, rtw_get_oper_ch(padapter),\r\nret == _SUCCESS ? ", acked" : "", i, try_cnt,\r\njiffies_to_msecs(jiffies - start));\r\nelse\r\nDBG_88E(FUNC_ADPT_FMT", ch:%u%s, %d/%d in %u ms\n",\r\nFUNC_ADPT_ARG(padapter), rtw_get_oper_ch(padapter),\r\nret == _SUCCESS ? ", acked" : "", i, try_cnt,\r\njiffies_to_msecs(jiffies - start));\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void issue_auth(struct adapter *padapter, struct sta_info *psta,\r\nunsigned short status)\r\n{\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nunsigned int val32;\r\nu16 val16;\r\n#ifdef CONFIG_88EU_AP_MODE\r\n__le16 le_val16;\r\n#endif\r\nint use_shared_key = 0;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\nreturn;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nSetFrameSubType(pframe, WIFI_AUTH);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\nif (psta) {\r\n#ifdef CONFIG_88EU_AP_MODE\r\nmemcpy(pwlanhdr->addr1, psta->hwaddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nval16 = (u16)psta->authalg;\r\nif (status != _STATS_SUCCESSFUL_)\r\nval16 = 0;\r\nif (val16) {\r\nle_val16 = cpu_to_le16(val16);\r\nuse_shared_key = 1;\r\n} else {\r\nle_val16 = 0;\r\n}\r\npframe = rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_, &le_val16,\r\n&pattrib->pktlen);\r\nval16 = (u16)psta->auth_seq;\r\nle_val16 = cpu_to_le16(val16);\r\npframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, &le_val16,\r\n&pattrib->pktlen);\r\nval16 = status;\r\nle_val16 = cpu_to_le16(val16);\r\npframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_,\r\n&le_val16, &pattrib->pktlen);\r\nif ((psta->auth_seq == 2) && (psta->state & WIFI_FW_AUTH_STATE) && (use_shared_key == 1))\r\npframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, psta->chg_txt, &(pattrib->pktlen));\r\n#endif\r\n} else {\r\n__le32 le_tmp32;\r\n__le16 le_tmp16;\r\nmemcpy(pwlanhdr->addr1, pnetwork->MacAddress, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&padapter->eeprompriv), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pnetwork->MacAddress, ETH_ALEN);\r\nval16 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared) ? 1 : 0;\r\nif (val16)\r\nuse_shared_key = 1;\r\nif ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key == 1)) {\r\nval32 = (pmlmeinfo->iv++) | (pmlmeinfo->key_index << 30);\r\nle_tmp32 = cpu_to_le32(val32);\r\npframe = rtw_set_fixed_ie(pframe, 4, &le_tmp32,\r\n&pattrib->pktlen);\r\npattrib->iv_len = 4;\r\n}\r\nle_tmp16 = cpu_to_le16(val16);\r\npframe = rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_, &le_tmp16,\r\n&pattrib->pktlen);\r\nval16 = pmlmeinfo->auth_seq;\r\nle_tmp16 = cpu_to_le16(val16);\r\npframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, &le_tmp16,\r\n&pattrib->pktlen);\r\nle_tmp16 = cpu_to_le16(status);\r\npframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, &le_tmp16,\r\n&pattrib->pktlen);\r\nif ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key == 1)) {\r\npframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, pmlmeinfo->chg_txt, &(pattrib->pktlen));\r\nSetPrivacy(fctrl);\r\npattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->encrypt = _WEP40_;\r\npattrib->icv_len = 4;\r\npattrib->pktlen += pattrib->icv_len;\r\n}\r\n}\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\nrtw_wep_encrypt(padapter, (u8 *)pmgntframe);\r\nDBG_88E("%s\n", __func__);\r\ndump_mgntframe(padapter, pmgntframe);\r\n}\r\nstatic void issue_asocrsp(struct adapter *padapter, unsigned short status,\r\nstruct sta_info *pstat, int pkt_type)\r\n{\r\nstruct xmit_frame *pmgntframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pbuf, *pframe;\r\nunsigned short val;\r\n__le16 *fctrl;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nu8 *ie = pnetwork->IEs;\r\n__le16 lestatus, leval;\r\nDBG_88E("%s\n", __func__);\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\nreturn;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nmemcpy((void *)GetAddr1Ptr(pwlanhdr), pstat->hwaddr, ETH_ALEN);\r\nmemcpy((void *)GetAddr2Ptr(pwlanhdr), myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy((void *)GetAddr3Ptr(pwlanhdr), pnetwork->MacAddress, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nif ((pkt_type == WIFI_ASSOCRSP) || (pkt_type == WIFI_REASSOCRSP))\r\nSetFrameSubType(pwlanhdr, pkt_type);\r\nelse\r\nreturn;\r\npattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen += pattrib->hdrlen;\r\npframe += pattrib->hdrlen;\r\nval = *(unsigned short *)rtw_get_capability_from_ie(ie);\r\npframe = rtw_set_fixed_ie(pframe, _CAPABILITY_, &val, &pattrib->pktlen);\r\nlestatus = cpu_to_le16(status);\r\npframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, &lestatus,\r\n&pattrib->pktlen);\r\nleval = cpu_to_le16(pstat->aid | BIT(14) | BIT(15));\r\npframe = rtw_set_fixed_ie(pframe, _ASOC_ID_, &leval, &pattrib->pktlen);\r\nif (pstat->bssratelen <= 8) {\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, pstat->bssratelen, pstat->bssrateset, &(pattrib->pktlen));\r\n} else {\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pstat->bssrateset, &(pattrib->pktlen));\r\npframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (pstat->bssratelen-8), pstat->bssrateset+8, &(pattrib->pktlen));\r\n}\r\nif ((pstat->flags & WLAN_STA_HT) && (pmlmepriv->htpriv.ht_option)) {\r\nuint ie_len = 0;\r\npbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_CAPABILITY_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));\r\nif (pbuf && ie_len > 0) {\r\nmemcpy(pframe, pbuf, ie_len+2);\r\npframe += (ie_len+2);\r\npattrib->pktlen += (ie_len+2);\r\n}\r\npbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));\r\nif (pbuf && ie_len > 0) {\r\nmemcpy(pframe, pbuf, ie_len+2);\r\npframe += (ie_len+2);\r\npattrib->pktlen += (ie_len+2);\r\n}\r\n}\r\nif ((pstat->flags & WLAN_STA_WME) && (pmlmepriv->qospriv.qos_option)) {\r\nuint ie_len = 0;\r\nunsigned char WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};\r\nfor (pbuf = ie + _BEACON_IE_OFFSET_;; pbuf += (ie_len + 2)) {\r\npbuf = rtw_get_ie(pbuf, _VENDOR_SPECIFIC_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));\r\nif (pbuf && !memcmp(pbuf+2, WMM_PARA_IE, 6)) {\r\nmemcpy(pframe, pbuf, ie_len+2);\r\npframe += (ie_len+2);\r\npattrib->pktlen += (ie_len+2);\r\nbreak;\r\n}\r\nif ((pbuf == NULL) || (ie_len == 0))\r\nbreak;\r\n}\r\n}\r\nif (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_REALTEK)\r\npframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 6 , REALTEK_96B_IE, &(pattrib->pktlen));\r\nif (pmlmepriv->wps_assoc_resp_ie && pmlmepriv->wps_assoc_resp_ie_len > 0) {\r\nmemcpy(pframe, pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);\r\npframe += pmlmepriv->wps_assoc_resp_ie_len;\r\npattrib->pktlen += pmlmepriv->wps_assoc_resp_ie_len;\r\n}\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\ndump_mgntframe(padapter, pmgntframe);\r\n}\r\nstatic void issue_assocreq(struct adapter *padapter)\r\n{\r\nint ret = _FAIL;\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe, *p;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nunsigned int i, j, ie_len, index = 0;\r\nunsigned char rf_type, bssrate[NumRates], sta_bssrate[NumRates];\r\nstruct ndis_802_11_var_ie *pIE;\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nint bssrate_len = 0, sta_bssrate_len = 0;\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\ngoto exit;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, pnetwork->MacAddress, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pnetwork->MacAddress, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nSetFrameSubType(pframe, WIFI_ASSOCREQ);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\nmemcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);\r\npframe += 2;\r\npattrib->pktlen += 2;\r\nput_unaligned_le16(3, pframe);\r\npframe += 2;\r\npattrib->pktlen += 2;\r\npframe = rtw_set_ie(pframe, _SSID_IE_, pmlmeinfo->network.Ssid.SsidLength, pmlmeinfo->network.Ssid.Ssid, &(pattrib->pktlen));\r\nget_rate_set(padapter, sta_bssrate, &sta_bssrate_len);\r\nif (pmlmeext->cur_channel == 14)\r\nsta_bssrate_len = 4;\r\nfor (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {\r\nif (pmlmeinfo->network.SupportedRates[i] == 0)\r\nbreak;\r\nDBG_88E("network.SupportedRates[%d]=%02X\n", i, pmlmeinfo->network.SupportedRates[i]);\r\n}\r\nfor (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {\r\nif (pmlmeinfo->network.SupportedRates[i] == 0)\r\nbreak;\r\nfor (j = 0; j < sta_bssrate_len; j++) {\r\nif ((pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK)\r\n== (sta_bssrate[j]|IEEE80211_BASIC_RATE_MASK))\r\nbreak;\r\n}\r\nif (j == sta_bssrate_len) {\r\nDBG_88E("%s(): the rate[%d]=%02X is not supported by STA!\n", __func__, i, pmlmeinfo->network.SupportedRates[i]);\r\n} else {\r\nbssrate[index++] = pmlmeinfo->network.SupportedRates[i];\r\n}\r\n}\r\nbssrate_len = index;\r\nDBG_88E("bssrate_len=%d\n", bssrate_len);\r\nif (bssrate_len == 0) {\r\nrtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);\r\nrtw_free_xmitframe(pxmitpriv, pmgntframe);\r\ngoto exit;\r\n}\r\nif (bssrate_len > 8) {\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , 8, bssrate, &(pattrib->pktlen));\r\npframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));\r\n} else {\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));\r\n}\r\np = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(struct ndis_802_11_fixed_ie)), _RSN_IE_2_, &ie_len, (pmlmeinfo->network.IELength - sizeof(struct ndis_802_11_fixed_ie)));\r\nif (p != NULL)\r\npframe = rtw_set_ie(pframe, _RSN_IE_2_, ie_len, (p + 2), &(pattrib->pktlen));\r\nif (padapter->mlmepriv.htpriv.ht_option) {\r\np = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(struct ndis_802_11_fixed_ie)), _HT_CAPABILITY_IE_, &ie_len, (pmlmeinfo->network.IELength - sizeof(struct ndis_802_11_fixed_ie)));\r\nif ((p != NULL) && (!(is_ap_in_tkip(padapter)))) {\r\nmemcpy(&(pmlmeinfo->HT_caps), (p + 2), sizeof(struct HT_caps_element));\r\nif (pregpriv->cbw40_enable == 0)\r\npmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info &= cpu_to_le16(~(BIT(6) | BIT(1)));\r\nelse\r\npmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(BIT(1));\r\npmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x000c);\r\nrtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));\r\nswitch (rf_type) {\r\ncase RF_1T1R:\r\nif (pregpriv->rx_stbc)\r\npmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);\r\nmemcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_1R, 16);\r\nbreak;\r\ncase RF_2T2R:\r\ncase RF_1T2R:\r\ndefault:\r\nif ((pregpriv->rx_stbc == 0x3) ||\r\n((pmlmeext->cur_wireless_mode & WIRELESS_11_24N) && (pregpriv->rx_stbc == 0x1)) ||\r\n(pregpriv->wifi_spec == 1)) {\r\nDBG_88E("declare supporting RX STBC\n");\r\npmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0200);\r\n}\r\nmemcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_2R, 16);\r\nbreak;\r\n}\r\npframe = rtw_set_ie(pframe, _HT_CAPABILITY_IE_, ie_len , (u8 *)(&(pmlmeinfo->HT_caps)), &(pattrib->pktlen));\r\n}\r\n}\r\nfor (i = sizeof(struct ndis_802_11_fixed_ie); i < pmlmeinfo->network.IELength; i += (pIE->Length + 2)) {\r\npIE = (struct ndis_802_11_var_ie *)(pmlmeinfo->network.IEs + i);\r\nswitch (pIE->ElementID) {\r\ncase _VENDOR_SPECIFIC_IE_:\r\nif ((!memcmp(pIE->data, RTW_WPA_OUI, 4)) ||\r\n(!memcmp(pIE->data, WMM_OUI, 4)) ||\r\n(!memcmp(pIE->data, WPS_OUI, 4))) {\r\nif (!padapter->registrypriv.wifi_spec) {\r\nif (!memcmp(pIE->data, WPS_OUI, 4))\r\npIE->Length = 14;\r\n}\r\npframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, pIE->Length, pIE->data, &(pattrib->pktlen));\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_REALTEK)\r\npframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 6 , REALTEK_96B_IE, &(pattrib->pktlen));\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\ndump_mgntframe(padapter, pmgntframe);\r\nret = _SUCCESS;\r\nexit:\r\nif (ret == _SUCCESS)\r\nrtw_buf_update(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len, (u8 *)pwlanhdr, pattrib->pktlen);\r\nelse\r\nrtw_buf_free(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len);\r\n}\r\nstatic int _issue_nulldata(struct adapter *padapter, unsigned char *da, unsigned int power_mode, int wait_ack)\r\n{\r\nint ret = _FAIL;\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nstruct xmit_priv *pxmitpriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nstruct wlan_bssid_ex *pnetwork;\r\nif (!padapter)\r\ngoto exit;\r\npxmitpriv = &(padapter->xmitpriv);\r\npmlmeext = &(padapter->mlmeextpriv);\r\npmlmeinfo = &(pmlmeext->mlmext_info);\r\npnetwork = &(pmlmeinfo->network);\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\ngoto exit;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\npattrib->retry_ctrl = false;\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)\r\nSetFrDs(fctrl);\r\nelse if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)\r\nSetToDs(fctrl);\r\nif (power_mode)\r\nSetPwrMgt(fctrl);\r\nmemcpy(pwlanhdr->addr1, da, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pnetwork->MacAddress, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nSetFrameSubType(pframe, WIFI_DATA_NULL);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\nif (wait_ack) {\r\nret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);\r\n} else {\r\ndump_mgntframe(padapter, pmgntframe);\r\nret = _SUCCESS;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nint issue_nulldata(struct adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms)\r\n{\r\nint ret;\r\nint i = 0;\r\nunsigned long start = jiffies;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nif (da == NULL)\r\nda = pnetwork->MacAddress;\r\ndo {\r\nret = _issue_nulldata(padapter, da, power_mode, wait_ms > 0 ? true : false);\r\ni++;\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\r\nbreak;\r\nif (i < try_cnt && wait_ms > 0 && ret == _FAIL)\r\nmsleep(wait_ms);\r\n} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));\r\nif (ret != _FAIL) {\r\nret = _SUCCESS;\r\ngoto exit;\r\n}\r\nif (try_cnt && wait_ms) {\r\nif (da)\r\nDBG_88E(FUNC_ADPT_FMT" to %pM, ch:%u%s, %d/%d in %u ms\n",\r\nFUNC_ADPT_ARG(padapter), da, rtw_get_oper_ch(padapter),\r\nret == _SUCCESS ? ", acked" : "", i, try_cnt,\r\njiffies_to_msecs(jiffies - start));\r\nelse\r\nDBG_88E(FUNC_ADPT_FMT", ch:%u%s, %d/%d in %u ms\n",\r\nFUNC_ADPT_ARG(padapter), rtw_get_oper_ch(padapter),\r\nret == _SUCCESS ? ", acked" : "", i, try_cnt,\r\njiffies_to_msecs(jiffies - start));\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int _issue_qos_nulldata(struct adapter *padapter, unsigned char *da, u16 tid, int wait_ack)\r\n{\r\nint ret = _FAIL;\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nunsigned short *qc;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nDBG_88E("%s\n", __func__);\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\ngoto exit;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\npattrib->hdrlen += 2;\r\npattrib->qos_en = true;\r\npattrib->eosp = 1;\r\npattrib->ack_policy = 0;\r\npattrib->mdata = 0;\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)\r\nSetFrDs(fctrl);\r\nelse if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)\r\nSetToDs(fctrl);\r\nif (pattrib->mdata)\r\nSetMData(fctrl);\r\nqc = (unsigned short *)(pframe + pattrib->hdrlen - 2);\r\nSetPriority(qc, tid);\r\nSetEOSP(qc, pattrib->eosp);\r\nSetAckpolicy(qc, pattrib->ack_policy);\r\nmemcpy(pwlanhdr->addr1, da, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pnetwork->MacAddress, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nSetFrameSubType(pframe, WIFI_QOS_DATA_NULL);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr_qos);\r\npattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr_qos);\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\nif (wait_ack) {\r\nret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);\r\n} else {\r\ndump_mgntframe(padapter, pmgntframe);\r\nret = _SUCCESS;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nint issue_qos_nulldata(struct adapter *padapter, unsigned char *da, u16 tid, int try_cnt, int wait_ms)\r\n{\r\nint ret;\r\nint i = 0;\r\nunsigned long start = jiffies;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nif (da == NULL)\r\nda = pnetwork->MacAddress;\r\ndo {\r\nret = _issue_qos_nulldata(padapter, da, tid, wait_ms > 0 ? true : false);\r\ni++;\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\r\nbreak;\r\nif (i < try_cnt && wait_ms > 0 && ret == _FAIL)\r\nmsleep(wait_ms);\r\n} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));\r\nif (ret != _FAIL) {\r\nret = _SUCCESS;\r\ngoto exit;\r\n}\r\nif (try_cnt && wait_ms) {\r\nif (da)\r\nDBG_88E(FUNC_ADPT_FMT" to %pM, ch:%u%s, %d/%d in %u ms\n",\r\nFUNC_ADPT_ARG(padapter), da, rtw_get_oper_ch(padapter),\r\nret == _SUCCESS ? ", acked" : "", i, try_cnt,\r\njiffies_to_msecs(jiffies - start));\r\nelse\r\nDBG_88E(FUNC_ADPT_FMT", ch:%u%s, %d/%d in %u ms\n",\r\nFUNC_ADPT_ARG(padapter), rtw_get_oper_ch(padapter),\r\nret == _SUCCESS ? ", acked" : "", i, try_cnt,\r\njiffies_to_msecs(jiffies - start));\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int _issue_deauth(struct adapter *padapter, unsigned char *da, unsigned short reason, u8 wait_ack)\r\n{\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nint ret = _FAIL;\r\n__le16 le_tmp;\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\ngoto exit;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\npattrib->retry_ctrl = false;\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, da, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pnetwork->MacAddress, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nSetFrameSubType(pframe, WIFI_DEAUTH);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\nle_tmp = cpu_to_le16(reason);\r\npframe = rtw_set_fixed_ie(pframe, _RSON_CODE_, &le_tmp,\r\n&pattrib->pktlen);\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\nif (wait_ack) {\r\nret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);\r\n} else {\r\ndump_mgntframe(padapter, pmgntframe);\r\nret = _SUCCESS;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nint issue_deauth(struct adapter *padapter, unsigned char *da, unsigned short reason)\r\n{\r\nDBG_88E("%s to %pM\n", __func__, da);\r\nreturn _issue_deauth(padapter, da, reason, false);\r\n}\r\nstatic int issue_deauth_ex(struct adapter *padapter, u8 *da,\r\nunsigned short reason, int try_cnt,\r\nint wait_ms)\r\n{\r\nint ret;\r\nint i = 0;\r\nunsigned long start = jiffies;\r\ndo {\r\nret = _issue_deauth(padapter, da, reason, wait_ms > 0 ? true : false);\r\ni++;\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\r\nbreak;\r\nif (i < try_cnt && wait_ms > 0 && ret == _FAIL)\r\nmsleep(wait_ms);\r\n} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));\r\nif (ret != _FAIL) {\r\nret = _SUCCESS;\r\ngoto exit;\r\n}\r\nif (try_cnt && wait_ms) {\r\nif (da)\r\nDBG_88E(FUNC_ADPT_FMT" to %pM, ch:%u%s, %d/%d in %u ms\n",\r\nFUNC_ADPT_ARG(padapter), da, rtw_get_oper_ch(padapter),\r\nret == _SUCCESS ? ", acked" : "", i, try_cnt,\r\njiffies_to_msecs(jiffies - start));\r\nelse\r\nDBG_88E(FUNC_ADPT_FMT", ch:%u%s, %d/%d in %u ms\n",\r\nFUNC_ADPT_ARG(padapter), rtw_get_oper_ch(padapter),\r\nret == _SUCCESS ? ", acked" : "", i, try_cnt,\r\njiffies_to_msecs(jiffies - start));\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nvoid issue_action_spct_ch_switch(struct adapter *padapter, u8 *ra, u8 new_ch, u8 ch_offset)\r\n{\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nDBG_88E(FUNC_NDEV_FMT" ra =%pM, ch:%u, offset:%u\n",\r\nFUNC_NDEV_ARG(padapter->pnetdev), ra, new_ch, ch_offset);\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\nreturn;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, ra, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, ra, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nSetFrameSubType(pframe, WIFI_ACTION);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\n{\r\nu8 category, action;\r\ncategory = RTW_WLAN_CATEGORY_SPECTRUM_MGMT;\r\naction = RTW_WLAN_ACTION_SPCT_CHL_SWITCH;\r\npframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));\r\npframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));\r\n}\r\npframe = rtw_set_ie_ch_switch(pframe, &(pattrib->pktlen), 0, new_ch, 0);\r\npframe = rtw_set_ie_secondary_ch_offset(pframe, &(pattrib->pktlen),\r\nhal_ch_offset_to_secondary_ch_offset(ch_offset));\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\ndump_mgntframe(padapter, pmgntframe);\r\n}\r\nstatic void issue_action_BA(struct adapter *padapter, unsigned char *raddr,\r\nunsigned char action, unsigned short status)\r\n{\r\nu8 category = RTW_WLAN_CATEGORY_BACK;\r\nu16 start_seq;\r\nu16 BA_para_set;\r\nu16 reason_code;\r\nu16 BA_timeout_value;\r\n__le16 le_tmp;\r\nu16 BA_starting_seqctrl = 0;\r\nenum ht_cap_ampdu_factor max_rx_ampdu_factor;\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nu8 *pframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nDBG_88E("%s, category=%d, action=%d, status=%d\n", __func__, category, action, status);\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\nreturn;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, raddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pnetwork->MacAddress, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nSetFrameSubType(pframe, WIFI_ACTION);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\npframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));\r\npframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));\r\nif (category == 3) {\r\nswitch (action) {\r\ncase 0:\r\ndo {\r\npmlmeinfo->dialogToken++;\r\n} while (pmlmeinfo->dialogToken == 0);\r\npframe = rtw_set_fixed_ie(pframe, 1, &(pmlmeinfo->dialogToken), &(pattrib->pktlen));\r\nBA_para_set = 0x1002 | ((status & 0xf) << 2);\r\nle_tmp = cpu_to_le16(BA_para_set);\r\npframe = rtw_set_fixed_ie(pframe, 2, &(le_tmp),\r\n&pattrib->pktlen);\r\nBA_timeout_value = 5000;\r\nle_tmp = cpu_to_le16(BA_timeout_value);\r\npframe = rtw_set_fixed_ie(pframe, 2, &(le_tmp),\r\n&pattrib->pktlen);\r\npsta = rtw_get_stainfo(pstapriv, raddr);\r\nif (psta != NULL) {\r\nstart_seq = (psta->sta_xmitpriv.txseq_tid[status & 0x07]&0xfff) + 1;\r\nDBG_88E("BA_starting_seqctrl=%d for TID=%d\n", start_seq, status & 0x07);\r\npsta->BA_starting_seqctrl[status & 0x07] = start_seq;\r\nBA_starting_seqctrl = start_seq << 4;\r\n}\r\nle_tmp = cpu_to_le16(BA_starting_seqctrl);\r\npframe = rtw_set_fixed_ie(pframe, 2, &(le_tmp),\r\n&pattrib->pktlen);\r\nbreak;\r\ncase 1:\r\n{\r\nstruct ADDBA_request *ADDBA_req = &pmlmeinfo->ADDBA_req;\r\npframe = rtw_set_fixed_ie(pframe, 1,\r\n&ADDBA_req->dialog_token,\r\n&pattrib->pktlen);\r\npframe = rtw_set_fixed_ie(pframe, 2, &status,\r\n&pattrib->pktlen);\r\nBA_para_set = le16_to_cpu(ADDBA_req->BA_para_set) &\r\n0x3f;\r\nrtw_hal_get_def_var(padapter, HW_VAR_MAX_RX_AMPDU_FACTOR, &max_rx_ampdu_factor);\r\nswitch (max_rx_ampdu_factor) {\r\ncase MAX_AMPDU_FACTOR_64K:\r\nBA_para_set |= 0x1000;\r\nbreak;\r\ncase MAX_AMPDU_FACTOR_32K:\r\nBA_para_set |= 0x0800;\r\nbreak;\r\ncase MAX_AMPDU_FACTOR_16K:\r\nBA_para_set |= 0x0400;\r\nbreak;\r\ncase MAX_AMPDU_FACTOR_8K:\r\nBA_para_set |= 0x0200;\r\nbreak;\r\ndefault:\r\nBA_para_set |= 0x1000;\r\nbreak;\r\n}\r\nif (pregpriv->ampdu_amsdu == 0)\r\nBA_para_set = BA_para_set & ~BIT(0);\r\nelse if (pregpriv->ampdu_amsdu == 1)\r\nBA_para_set = BA_para_set | BIT(0);\r\nle_tmp = cpu_to_le16(BA_para_set);\r\npframe = rtw_set_fixed_ie(pframe, 2, &(le_tmp),\r\n&pattrib->pktlen);\r\npframe = rtw_set_fixed_ie(pframe, 2,\r\n&ADDBA_req->BA_timeout_value,\r\n&pattrib->pktlen);\r\nbreak;\r\n}\r\ncase 2:\r\nBA_para_set = (status & 0x1F) << 3;\r\nle_tmp = cpu_to_le16(BA_para_set);\r\npframe = rtw_set_fixed_ie(pframe, 2, &(le_tmp),\r\n&pattrib->pktlen);\r\nreason_code = 37;\r\nle_tmp = cpu_to_le16(reason_code);\r\npframe = rtw_set_fixed_ie(pframe, 2, &(le_tmp),\r\n&pattrib->pktlen);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\ndump_mgntframe(padapter, pmgntframe);\r\n}\r\nstatic void issue_action_BSSCoexistPacket(struct adapter *padapter)\r\n{\r\nstruct list_head *plist, *phead;\r\nunsigned char category, action;\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nstruct wlan_network *pnetwork = NULL;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct __queue *queue = &(pmlmepriv->scanned_queue);\r\nu8 InfoContent[16] = {0};\r\nu8 ICS[8][15];\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nif ((pmlmepriv->num_FortyMHzIntolerant == 0) || (pmlmepriv->num_sta_no_ht == 0))\r\nreturn;\r\nif (pmlmeinfo->bwmode_updated)\r\nreturn;\r\nDBG_88E("%s\n", __func__);\r\ncategory = RTW_WLAN_CATEGORY_PUBLIC;\r\naction = ACT_PUBLIC_BSSCOEXIST;\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\nreturn;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, cur_network->MacAddress, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, cur_network->MacAddress, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\r\npmlmeext->mgnt_seq++;\r\nSetFrameSubType(pframe, WIFI_ACTION);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr);\r\npattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\npframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));\r\npframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));\r\nif (pmlmepriv->num_FortyMHzIntolerant > 0) {\r\nu8 iedata = 0;\r\niedata |= BIT(2);\r\npframe = rtw_set_ie(pframe, EID_BSSCoexistence, 1, &iedata, &(pattrib->pktlen));\r\n}\r\nmemset(ICS, 0, sizeof(ICS));\r\nif (pmlmepriv->num_sta_no_ht > 0) {\r\nint i;\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\nphead = get_list_head(queue);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\nint len;\r\nu8 *p;\r\nstruct wlan_bssid_ex *pbss_network;\r\npnetwork = container_of(plist, struct wlan_network, list);\r\nplist = plist->next;\r\npbss_network = (struct wlan_bssid_ex *)&pnetwork->network;\r\np = rtw_get_ie(pbss_network->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, pbss_network->IELength - _FIXED_IE_LENGTH_);\r\nif ((p == NULL) || (len == 0)) {\r\nif ((pbss_network->Configuration.DSConfig <= 0) || (pbss_network->Configuration.DSConfig > 14))\r\ncontinue;\r\nICS[0][pbss_network->Configuration.DSConfig] = 1;\r\nif (ICS[0][0] == 0)\r\nICS[0][0] = 1;\r\n}\r\n}\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\nfor (i = 0; i < 8; i++) {\r\nif (ICS[i][0] == 1) {\r\nint j, k = 0;\r\nInfoContent[k] = i;\r\nk++;\r\nfor (j = 1; j <= 14; j++) {\r\nif (ICS[i][j] == 1) {\r\nif (k < 16) {\r\nInfoContent[k] = j;\r\nk++;\r\n}\r\n}\r\n}\r\npframe = rtw_set_ie(pframe, EID_BSSIntolerantChlReport, k, InfoContent, &(pattrib->pktlen));\r\n}\r\n}\r\n}\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\ndump_mgntframe(padapter, pmgntframe);\r\n}\r\nunsigned int send_delba(struct adapter *padapter, u8 initiator, u8 *addr)\r\n{\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct sta_info *psta = NULL;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu16 tid;\r\nif ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)\r\nif (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))\r\nreturn _SUCCESS;\r\npsta = rtw_get_stainfo(pstapriv, addr);\r\nif (psta == NULL)\r\nreturn _SUCCESS;\r\nif (initiator == 0) {\r\nfor (tid = 0; tid < MAXTID; tid++) {\r\nif (psta->recvreorder_ctrl[tid].enable) {\r\nDBG_88E("rx agg disable tid(%d)\n", tid);\r\nissue_action_BA(padapter, addr, RTW_WLAN_ACTION_DELBA, (((tid << 1) | initiator)&0x1F));\r\npsta->recvreorder_ctrl[tid].enable = false;\r\npsta->recvreorder_ctrl[tid].indicate_seq = 0xffff;\r\n}\r\n}\r\n} else if (initiator == 1) {\r\nfor (tid = 0; tid < MAXTID; tid++) {\r\nif (psta->htpriv.agg_enable_bitmap & BIT(tid)) {\r\nDBG_88E("tx agg disable tid(%d)\n", tid);\r\nissue_action_BA(padapter, addr, RTW_WLAN_ACTION_DELBA, (((tid << 1) | initiator)&0x1F));\r\npsta->htpriv.agg_enable_bitmap &= ~BIT(tid);\r\npsta->htpriv.candidate_tid_bitmap &= ~BIT(tid);\r\n}\r\n}\r\n}\r\nreturn _SUCCESS;\r\n}\r\nunsigned int send_beacon(struct adapter *padapter)\r\n{\r\nu8 bxmitok = false;\r\nint issue = 0;\r\nint poll = 0;\r\nunsigned long start = jiffies;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BCN_VALID, NULL);\r\ndo {\r\nissue_beacon(padapter, 100);\r\nissue++;\r\ndo {\r\nyield();\r\nrtw_hal_get_hwreg(padapter, HW_VAR_BCN_VALID, (u8 *)(&bxmitok));\r\npoll++;\r\n} while ((poll%10) != 0 && !bxmitok && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\r\n} while (!bxmitok && issue < 100 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\r\nif (padapter->bSurpriseRemoved || padapter->bDriverStopped)\r\nreturn _FAIL;\r\nif (!bxmitok) {\r\nDBG_88E("%s fail! %u ms\n", __func__,\r\njiffies_to_msecs(jiffies - start));\r\nreturn _FAIL;\r\n} else {\r\nu32 passing_time = jiffies_to_msecs(jiffies - start);\r\nif (passing_time > 100 || issue > 3)\r\nDBG_88E("%s success, issue:%d, poll:%d, %u ms\n",\r\n__func__, issue, poll,\r\njiffies_to_msecs(jiffies - start));\r\nreturn _SUCCESS;\r\n}\r\n}\r\nstatic void site_survey(struct adapter *padapter)\r\n{\r\nunsigned char survey_channel = 0, val8;\r\nenum rt_scan_type ScanType = SCAN_PASSIVE;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu32 initialgain = 0;\r\nstruct rtw_ieee80211_channel *ch;\r\nif (pmlmeext->sitesurvey_res.channel_idx < pmlmeext->sitesurvey_res.ch_num) {\r\nch = &pmlmeext->sitesurvey_res.ch[pmlmeext->sitesurvey_res.channel_idx];\r\nsurvey_channel = ch->hw_value;\r\nScanType = (ch->flags & RTW_IEEE80211_CHAN_PASSIVE_SCAN) ? SCAN_PASSIVE : SCAN_ACTIVE;\r\n}\r\nif (survey_channel != 0) {\r\nif (pmlmeext->sitesurvey_res.channel_idx == 0)\r\nset_channel_bwmode(padapter, survey_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);\r\nelse\r\nSelectChannel(padapter, survey_channel);\r\nif (ScanType == SCAN_ACTIVE) {\r\nint i;\r\nfor (i = 0; i < RTW_SSID_SCAN_AMOUNT; i++) {\r\nif (pmlmeext->sitesurvey_res.ssid[i].SsidLength) {\r\nissue_probereq(padapter,\r\n&(pmlmeext->sitesurvey_res.ssid[i]),\r\nNULL, false);\r\nissue_probereq(padapter,\r\n&(pmlmeext->sitesurvey_res.ssid[i]),\r\nNULL, false);\r\n}\r\n}\r\nif (pmlmeext->sitesurvey_res.scan_mode == SCAN_ACTIVE) {\r\nissue_probereq(padapter, NULL, NULL, false);\r\nissue_probereq(padapter, NULL, NULL, false);\r\n}\r\nif (pmlmeext->sitesurvey_res.scan_mode == SCAN_ACTIVE) {\r\nissue_probereq(padapter, NULL, NULL, false);\r\nissue_probereq(padapter, NULL, NULL, false);\r\n}\r\n}\r\nset_survey_timer(pmlmeext, pmlmeext->chan_scan_time);\r\n} else {\r\nif (rtw_hal_antdiv_before_linked(padapter)) {\r\npmlmeext->sitesurvey_res.bss_cnt = 0;\r\npmlmeext->sitesurvey_res.channel_idx = -1;\r\npmlmeext->chan_scan_time = SURVEY_TO / 2;\r\nset_survey_timer(pmlmeext, pmlmeext->chan_scan_time);\r\nreturn;\r\n}\r\npmlmeext->sitesurvey_res.state = SCAN_COMPLETE;\r\nset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\r\nSet_MSR(padapter, (pmlmeinfo->state & 0x3));\r\ninitialgain = 0xff;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));\r\nRestore_DM_Func_Flag(padapter);\r\nif (is_client_associated_to_ap(padapter))\r\nissue_nulldata(padapter, NULL, 0, 3, 500);\r\nval8 = 0;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));\r\nreport_surveydone_event(padapter);\r\npmlmeext->chan_scan_time = SURVEY_TO;\r\npmlmeext->sitesurvey_res.state = SCAN_DISABLE;\r\nissue_action_BSSCoexistPacket(padapter);\r\nissue_action_BSSCoexistPacket(padapter);\r\nissue_action_BSSCoexistPacket(padapter);\r\n}\r\n}\r\nstatic u8 collect_bss_info(struct adapter *padapter,\r\nstruct recv_frame *precv_frame,\r\nstruct wlan_bssid_ex *bssid)\r\n{\r\nint i;\r\nu32 len;\r\nu8 *p;\r\nu16 val16, subtype;\r\nu8 *pframe = precv_frame->rx_data;\r\nu32 packet_len = precv_frame->len;\r\nu8 ie_offset;\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nlen = packet_len - sizeof(struct rtw_ieee80211_hdr_3addr);\r\nif (len > MAX_IE_SZ)\r\nreturn _FAIL;\r\nmemset(bssid, 0, sizeof(struct wlan_bssid_ex));\r\nsubtype = GetFrameSubType(pframe);\r\nif (subtype == WIFI_BEACON) {\r\nbssid->Reserved[0] = 1;\r\nie_offset = _BEACON_IE_OFFSET_;\r\n} else {\r\nif (subtype == WIFI_PROBEREQ) {\r\nie_offset = _PROBEREQ_IE_OFFSET_;\r\nbssid->Reserved[0] = 2;\r\n} else if (subtype == WIFI_PROBERSP) {\r\nie_offset = _PROBERSP_IE_OFFSET_;\r\nbssid->Reserved[0] = 3;\r\n} else {\r\nbssid->Reserved[0] = 0;\r\nie_offset = _FIXED_IE_LENGTH_;\r\n}\r\n}\r\nbssid->Length = sizeof(struct wlan_bssid_ex) - MAX_IE_SZ + len;\r\nbssid->IELength = len;\r\nmemcpy(bssid->IEs, (pframe + sizeof(struct rtw_ieee80211_hdr_3addr)), bssid->IELength);\r\nbssid->Rssi = precv_frame->attrib.phy_info.recvpower;\r\nbssid->PhyInfo.SignalQuality = precv_frame->attrib.phy_info.SignalQuality;\r\nbssid->PhyInfo.SignalStrength = precv_frame->attrib.phy_info.SignalStrength;\r\nrtw_hal_get_def_var(padapter, HAL_DEF_CURRENT_ANTENNA, &bssid->PhyInfo.Optimum_antenna);\r\np = rtw_get_ie(bssid->IEs + ie_offset, _SSID_IE_, &len, bssid->IELength - ie_offset);\r\nif (p == NULL) {\r\nDBG_88E("marc: cannot find SSID for survey event\n");\r\nreturn _FAIL;\r\n}\r\nif (len) {\r\nif (len > NDIS_802_11_LENGTH_SSID) {\r\nDBG_88E("%s()-%d: IE too long (%d) for survey event\n", __func__, __LINE__, len);\r\nreturn _FAIL;\r\n}\r\nmemcpy(bssid->Ssid.Ssid, (p + 2), len);\r\nbssid->Ssid.SsidLength = len;\r\n} else {\r\nbssid->Ssid.SsidLength = 0;\r\n}\r\nmemset(bssid->SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);\r\ni = 0;\r\np = rtw_get_ie(bssid->IEs + ie_offset, _SUPPORTEDRATES_IE_, &len, bssid->IELength - ie_offset);\r\nif (p != NULL) {\r\nif (len > NDIS_802_11_LENGTH_RATES_EX) {\r\nDBG_88E("%s()-%d: IE too long (%d) for survey event\n", __func__, __LINE__, len);\r\nreturn _FAIL;\r\n}\r\nmemcpy(bssid->SupportedRates, (p + 2), len);\r\ni = len;\r\n}\r\np = rtw_get_ie(bssid->IEs + ie_offset, _EXT_SUPPORTEDRATES_IE_, &len, bssid->IELength - ie_offset);\r\nif (p != NULL) {\r\nif (len > (NDIS_802_11_LENGTH_RATES_EX-i)) {\r\nDBG_88E("%s()-%d: IE too long (%d) for survey event\n", __func__, __LINE__, len);\r\nreturn _FAIL;\r\n}\r\nmemcpy(bssid->SupportedRates + i, (p + 2), len);\r\n}\r\nbssid->NetworkTypeInUse = Ndis802_11OFDM24;\r\nif (bssid->IELength < 12)\r\nreturn _FAIL;\r\np = rtw_get_ie(bssid->IEs + ie_offset, _DSSET_IE_, &len, bssid->IELength - ie_offset);\r\nbssid->Configuration.DSConfig = 0;\r\nbssid->Configuration.Length = 0;\r\nif (p) {\r\nbssid->Configuration.DSConfig = *(p + 2);\r\n} else {\r\np = rtw_get_ie(bssid->IEs + ie_offset, _HT_ADD_INFO_IE_, &len, bssid->IELength - ie_offset);\r\nif (p) {\r\nstruct HT_info_element *HT_info = (struct HT_info_element *)(p + 2);\r\nbssid->Configuration.DSConfig = HT_info->primary_channel;\r\n} else {\r\nbssid->Configuration.DSConfig = rtw_get_oper_ch(padapter);\r\n}\r\n}\r\nif (subtype == WIFI_PROBEREQ) {\r\nbssid->InfrastructureMode = Ndis802_11Infrastructure;\r\nmemcpy(bssid->MacAddress, GetAddr2Ptr(pframe), ETH_ALEN);\r\nbssid->Privacy = 1;\r\nreturn _SUCCESS;\r\n}\r\nbssid->Configuration.BeaconPeriod =\r\nget_unaligned_le16(rtw_get_beacon_interval_from_ie(bssid->IEs));\r\nval16 = rtw_get_capability((struct wlan_bssid_ex *)bssid);\r\nif (val16 & BIT(0)) {\r\nbssid->InfrastructureMode = Ndis802_11Infrastructure;\r\nmemcpy(bssid->MacAddress, GetAddr2Ptr(pframe), ETH_ALEN);\r\n} else {\r\nbssid->InfrastructureMode = Ndis802_11IBSS;\r\nmemcpy(bssid->MacAddress, GetAddr3Ptr(pframe), ETH_ALEN);\r\n}\r\nif (val16 & BIT(4))\r\nbssid->Privacy = 1;\r\nelse\r\nbssid->Privacy = 0;\r\nbssid->Configuration.ATIMWindow = 0;\r\nif ((pregistrypriv->wifi_spec == 1) && (!pmlmeinfo->bwmode_updated)) {\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\np = rtw_get_ie(bssid->IEs + ie_offset, _HT_CAPABILITY_IE_, &len, bssid->IELength - ie_offset);\r\nif (p && len > 0) {\r\nstruct HT_caps_element *pHT_caps;\r\npHT_caps = (struct HT_caps_element *)(p + 2);\r\nif (le16_to_cpu(pHT_caps->u.HT_cap_element.HT_caps_info)&BIT(14))\r\npmlmepriv->num_FortyMHzIntolerant++;\r\n} else {\r\npmlmepriv->num_sta_no_ht++;\r\n}\r\n}\r\nif (bssid->Configuration.DSConfig != rtw_get_oper_ch(padapter))\r\nbssid->PhyInfo.SignalQuality = 101;\r\nreturn _SUCCESS;\r\n}\r\nstatic void start_create_ibss(struct adapter *padapter)\r\n{\r\nunsigned short caps;\r\nu8 val8;\r\nu8 join_type;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\r\npmlmeext->cur_channel = (u8)pnetwork->Configuration.DSConfig;\r\npmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);\r\nupdate_wireless_mode(padapter);\r\ncaps = rtw_get_capability((struct wlan_bssid_ex *)pnetwork);\r\nupdate_capinfo(padapter, caps);\r\nif (caps&cap_IBSS) {\r\nval8 = 0xcf;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));\r\nset_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);\r\nbeacon_timing_control(padapter);\r\npmlmeinfo->state = WIFI_FW_ADHOC_STATE;\r\nSet_MSR(padapter, (pmlmeinfo->state & 0x3));\r\nif (send_beacon(padapter) == _FAIL) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("issuing beacon frame fail....\n"));\r\nreport_join_res(padapter, -1);\r\npmlmeinfo->state = WIFI_FW_NULL_STATE;\r\n} else {\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BSSID, padapter->registrypriv.dev_network.MacAddress);\r\njoin_type = 0;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));\r\nreport_join_res(padapter, 1);\r\npmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;\r\n}\r\n} else {\r\nDBG_88E("start_create_ibss, invalid cap:%x\n", caps);\r\nreturn;\r\n}\r\n}\r\nstatic void start_clnt_join(struct adapter *padapter)\r\n{\r\nunsigned short caps;\r\nu8 val8;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\r\nint beacon_timeout;\r\npmlmeext->cur_channel = (u8)pnetwork->Configuration.DSConfig;\r\npmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);\r\nupdate_wireless_mode(padapter);\r\ncaps = rtw_get_capability((struct wlan_bssid_ex *)pnetwork);\r\nupdate_capinfo(padapter, caps);\r\nif (caps&cap_ESS) {\r\nSet_MSR(padapter, WIFI_FW_STATION_STATE);\r\nval8 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_8021X) ? 0xcc : 0xcf;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));\r\nset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\r\nbeacon_timeout = decide_wait_for_beacon_timeout(pmlmeinfo->bcn_interval);\r\nset_link_timer(pmlmeext, beacon_timeout);\r\nmod_timer(&padapter->mlmepriv.assoc_timer, jiffies +\r\nmsecs_to_jiffies((REAUTH_TO * REAUTH_LIMIT) + (REASSOC_TO * REASSOC_LIMIT) + beacon_timeout));\r\npmlmeinfo->state = WIFI_FW_AUTH_NULL | WIFI_FW_STATION_STATE;\r\n} else if (caps&cap_IBSS) {\r\nSet_MSR(padapter, WIFI_FW_ADHOC_STATE);\r\nval8 = 0xcf;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));\r\nset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\r\nbeacon_timing_control(padapter);\r\npmlmeinfo->state = WIFI_FW_ADHOC_STATE;\r\nreport_join_res(padapter, 1);\r\n} else {\r\nreturn;\r\n}\r\n}\r\nstatic void start_clnt_auth(struct adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\ndel_timer_sync(&pmlmeext->link_timer);\r\npmlmeinfo->state &= (~WIFI_FW_AUTH_NULL);\r\npmlmeinfo->state |= WIFI_FW_AUTH_STATE;\r\npmlmeinfo->auth_seq = 1;\r\npmlmeinfo->reauth_count = 0;\r\npmlmeinfo->reassoc_count = 0;\r\npmlmeinfo->link_count = 0;\r\npmlmeext->retry = 0;\r\nissue_deauth(padapter, (&(pmlmeinfo->network))->MacAddress, WLAN_REASON_DEAUTH_LEAVING);\r\nDBG_88E_LEVEL(_drv_info_, "start auth\n");\r\nissue_auth(padapter, NULL, 0);\r\nset_link_timer(pmlmeext, REAUTH_TO);\r\n}\r\nstatic void start_clnt_assoc(struct adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\ndel_timer_sync(&pmlmeext->link_timer);\r\npmlmeinfo->state &= (~(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE));\r\npmlmeinfo->state |= (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE);\r\nissue_assocreq(padapter);\r\nset_link_timer(pmlmeext, REASSOC_TO);\r\n}\r\nstatic unsigned int receive_disconnect(struct adapter *padapter,\r\nunsigned char *MacAddr,\r\nunsigned short reason)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nif (memcmp(MacAddr, pnetwork->MacAddress, ETH_ALEN))\r\nreturn _SUCCESS;\r\nDBG_88E("%s\n", __func__);\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) {\r\nif (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) {\r\npmlmeinfo->state = WIFI_FW_NULL_STATE;\r\nreport_del_sta_event(padapter, MacAddr, reason);\r\n} else if (pmlmeinfo->state & WIFI_FW_LINKING_STATE) {\r\npmlmeinfo->state = WIFI_FW_NULL_STATE;\r\nreport_join_res(padapter, -2);\r\n}\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic void process_80211d(struct adapter *padapter, struct wlan_bssid_ex *bssid)\r\n{\r\nstruct registry_priv *pregistrypriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct rt_channel_info *chplan_new;\r\nu8 channel;\r\nu8 i;\r\npregistrypriv = &padapter->registrypriv;\r\npmlmeext = &padapter->mlmeextpriv;\r\nif (pregistrypriv->enable80211d &&\r\n(!pmlmeext->update_channel_plan_by_ap_done)) {\r\nu8 *ie, *p;\r\nu32 len;\r\nstruct rt_channel_plan chplan_ap;\r\nstruct rt_channel_info chplan_sta[MAX_CHANNEL_NUM];\r\nu8 country[4];\r\nu8 fcn;\r\nu8 noc;\r\nu8 j, k;\r\nie = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _COUNTRY_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);\r\nif (!ie)\r\nreturn;\r\nif (len < 6)\r\nreturn;\r\nie += 2;\r\np = ie;\r\nie += len;\r\nmemset(country, 0, 4);\r\nmemcpy(country, p, 3);\r\np += 3;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,\r\n("%s: 802.11d country =%s\n", __func__, country));\r\ni = 0;\r\nwhile ((ie - p) >= 3) {\r\nfcn = *(p++);\r\nnoc = *(p++);\r\np++;\r\nfor (j = 0; j < noc; j++) {\r\nif (fcn <= 14)\r\nchannel = fcn + j;\r\nelse\r\nchannel = fcn + j*4;\r\nchplan_ap.Channel[i++] = channel;\r\n}\r\n}\r\nchplan_ap.Len = i;\r\nmemcpy(chplan_sta, pmlmeext->channel_set, sizeof(chplan_sta));\r\nmemset(pmlmeext->channel_set, 0, sizeof(pmlmeext->channel_set));\r\nchplan_new = pmlmeext->channel_set;\r\ni = 0;\r\nj = 0;\r\nk = 0;\r\nif (pregistrypriv->wireless_mode & WIRELESS_11G) {\r\ndo {\r\nif ((i == MAX_CHANNEL_NUM) ||\r\n(chplan_sta[i].ChannelNum == 0) ||\r\n(chplan_sta[i].ChannelNum > 14))\r\nbreak;\r\nif ((j == chplan_ap.Len) || (chplan_ap.Channel[j] > 14))\r\nbreak;\r\nif (chplan_sta[i].ChannelNum == chplan_ap.Channel[j]) {\r\nchplan_new[k].ChannelNum = chplan_ap.Channel[j];\r\nchplan_new[k].ScanType = SCAN_ACTIVE;\r\ni++;\r\nj++;\r\nk++;\r\n} else if (chplan_sta[i].ChannelNum < chplan_ap.Channel[j]) {\r\nchplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;\r\nchplan_new[k].ScanType = SCAN_PASSIVE;\r\ni++;\r\nk++;\r\n} else if (chplan_sta[i].ChannelNum > chplan_ap.Channel[j]) {\r\nchplan_new[k].ChannelNum = chplan_ap.Channel[j];\r\nchplan_new[k].ScanType = SCAN_ACTIVE;\r\nj++;\r\nk++;\r\n}\r\n} while (1);\r\nwhile ((i < MAX_CHANNEL_NUM) &&\r\n(chplan_sta[i].ChannelNum != 0) &&\r\n(chplan_sta[i].ChannelNum <= 14)) {\r\nchplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;\r\nchplan_new[k].ScanType = SCAN_PASSIVE;\r\ni++;\r\nk++;\r\n}\r\nwhile ((j < chplan_ap.Len) && (chplan_ap.Channel[j] <= 14)) {\r\nchplan_new[k].ChannelNum = chplan_ap.Channel[j];\r\nchplan_new[k].ScanType = SCAN_ACTIVE;\r\nj++;\r\nk++;\r\n}\r\n} else {\r\nwhile ((i < MAX_CHANNEL_NUM) &&\r\n(chplan_sta[i].ChannelNum != 0) &&\r\n(chplan_sta[i].ChannelNum <= 14)) {\r\nchplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;\r\nchplan_new[k].ScanType = chplan_sta[i].ScanType;\r\ni++;\r\nk++;\r\n}\r\nwhile ((j < chplan_ap.Len) && (chplan_ap.Channel[j] <= 14))\r\nj++;\r\n}\r\nwhile ((i < MAX_CHANNEL_NUM) && (chplan_sta[i].ChannelNum != 0)) {\r\nchplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;\r\nchplan_new[k].ScanType = chplan_sta[i].ScanType;\r\ni++;\r\nk++;\r\n}\r\npmlmeext->update_channel_plan_by_ap_done = 1;\r\n}\r\nchannel = bssid->Configuration.DSConfig;\r\nchplan_new = pmlmeext->channel_set;\r\ni = 0;\r\nwhile ((i < MAX_CHANNEL_NUM) && (chplan_new[i].ChannelNum != 0)) {\r\nif (chplan_new[i].ChannelNum == channel) {\r\nif (chplan_new[i].ScanType == SCAN_PASSIVE) {\r\nchplan_new[i].ScanType = SCAN_ACTIVE;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,\r\n("%s: change channel %d scan type from passive to active\n",\r\n__func__, channel));\r\n}\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nstatic unsigned int OnProbeReq(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nunsigned int ielen;\r\nunsigned char *p;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur = &(pmlmeinfo->network);\r\nu8 *pframe = precv_frame->rx_data;\r\nuint len = precv_frame->len;\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\r\nreturn _SUCCESS;\r\nif (!check_fwstate(pmlmepriv, _FW_LINKED) &&\r\n!check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))\r\nreturn _SUCCESS;\r\np = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SSID_IE_, (int *)&ielen,\r\nlen - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);\r\nif (p != NULL) {\r\nif ((ielen != 0 && memcmp((void *)(p+2), (void *)cur->Ssid.Ssid, cur->Ssid.SsidLength)) ||\r\n(ielen == 0 && pmlmeinfo->hidden_ssid_mode))\r\nreturn _SUCCESS;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) &&\r\npmlmepriv->cur_network.join_res)\r\nissue_probersp(padapter, get_sa(pframe));\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnProbeRsp(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {\r\nreport_survey_event(padapter, precv_frame);\r\nreturn _SUCCESS;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnBeacon(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nint cam_idx;\r\nstruct sta_info *psta;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nu8 *pframe = precv_frame->rx_data;\r\nuint len = precv_frame->len;\r\nstruct wlan_bssid_ex *pbss;\r\nint ret = _SUCCESS;\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nif (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {\r\nreport_survey_event(padapter, precv_frame);\r\nreturn _SUCCESS;\r\n}\r\nif (!memcmp(GetAddr3Ptr(pframe), pnetwork->MacAddress, ETH_ALEN)) {\r\nif (pmlmeinfo->state & WIFI_FW_AUTH_NULL) {\r\npbss = (struct wlan_bssid_ex *)rtw_malloc(sizeof(struct wlan_bssid_ex));\r\nif (pbss) {\r\nif (collect_bss_info(padapter, precv_frame, pbss) == _SUCCESS) {\r\nupdate_network(&(pmlmepriv->cur_network.network), pbss, padapter, true);\r\nrtw_get_bcn_info(&(pmlmepriv->cur_network));\r\n}\r\nkfree(pbss);\r\n}\r\npmlmeinfo->assoc_AP_vendor = check_assoc_AP(pframe+sizeof(struct rtw_ieee80211_hdr_3addr), len-sizeof(struct rtw_ieee80211_hdr_3addr));\r\nupdate_TSF(pmlmeext, pframe, len);\r\nstart_clnt_auth(padapter);\r\nreturn _SUCCESS;\r\n}\r\nif (((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) && (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {\r\npsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\r\nif (psta != NULL) {\r\nret = rtw_check_bcn_info(padapter, pframe, len);\r\nif (!ret) {\r\nDBG_88E_LEVEL(_drv_info_, "ap has changed, disconnect now\n ");\r\nreceive_disconnect(padapter, pmlmeinfo->network.MacAddress , 65535);\r\nreturn _SUCCESS;\r\n}\r\nif ((sta_rx_pkts(psta) & 0xf) == 0)\r\nupdate_beacon_info(padapter, pframe, len, psta);\r\n}\r\n} else if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {\r\npsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\r\nif (psta != NULL) {\r\nif ((sta_rx_pkts(psta) & 0xf) == 0)\r\nupdate_beacon_info(padapter, pframe, len, psta);\r\n} else {\r\ncam_idx = allocate_fw_sta_entry(padapter);\r\nif (cam_idx == NUM_STA)\r\ngoto _END_ONBEACON_;\r\nif (update_sta_support_rate(padapter, (pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_), (len - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_), cam_idx) == _FAIL) {\r\npmlmeinfo->FW_sta_info[cam_idx].status = 0;\r\ngoto _END_ONBEACON_;\r\n}\r\nupdate_TSF(pmlmeext, pframe, len);\r\nreport_add_sta_event(padapter, GetAddr2Ptr(pframe), cam_idx);\r\n}\r\n}\r\n}\r\n_END_ONBEACON_:\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnAuth(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nunsigned int auth_mode, ie_len;\r\nu16 seq;\r\nunsigned char *sa, *p;\r\nu16 algorithm;\r\nint status;\r\nstatic struct sta_info stat;\r\nstruct sta_info *pstat = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 *pframe = precv_frame->rx_data;\r\nuint len = precv_frame->len;\r\nif ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)\r\nreturn _FAIL;\r\nDBG_88E("+OnAuth\n");\r\nsa = GetAddr2Ptr(pframe);\r\nauth_mode = psecuritypriv->dot11AuthAlgrthm;\r\nseq = le16_to_cpu(*(__le16 *)((size_t)pframe + WLAN_HDR_A3_LEN + 2));\r\nalgorithm = le16_to_cpu(*(__le16 *)((size_t)pframe + WLAN_HDR_A3_LEN));\r\nDBG_88E("auth alg=%x, seq=%X\n", algorithm, seq);\r\nif (auth_mode == 2 && psecuritypriv->dot11PrivacyAlgrthm != _WEP40_ &&\r\npsecuritypriv->dot11PrivacyAlgrthm != _WEP104_)\r\nauth_mode = 0;\r\nif ((algorithm > 0 && auth_mode == 0) ||\r\n(algorithm == 0 && auth_mode == 1)) {\r\nDBG_88E("auth rejected due to bad alg [alg=%d, auth_mib=%d] %02X%02X%02X%02X%02X%02X\n",\r\nalgorithm, auth_mode, sa[0], sa[1], sa[2], sa[3], sa[4], sa[5]);\r\nstatus = _STATS_NO_SUPP_ALG_;\r\ngoto auth_fail;\r\n}\r\nif (!rtw_access_ctrl(padapter, sa)) {\r\nstatus = _STATS_UNABLE_HANDLE_STA_;\r\ngoto auth_fail;\r\n}\r\npstat = rtw_get_stainfo(pstapriv, sa);\r\nif (pstat == NULL) {\r\nDBG_88E("going to alloc stainfo for sa=%pM\n", sa);\r\npstat = rtw_alloc_stainfo(pstapriv, sa);\r\nif (pstat == NULL) {\r\nDBG_88E(" Exceed the upper limit of supported clients...\n");\r\nstatus = _STATS_UNABLE_HANDLE_STA_;\r\ngoto auth_fail;\r\n}\r\npstat->state = WIFI_FW_AUTH_NULL;\r\npstat->auth_seq = 0;\r\n} else {\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nif (!list_empty(&pstat->asoc_list)) {\r\nlist_del_init(&pstat->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nif (seq == 1) {\r\n}\r\n}\r\nspin_lock_bh(&pstapriv->auth_list_lock);\r\nif (list_empty(&pstat->auth_list)) {\r\nlist_add_tail(&pstat->auth_list, &pstapriv->auth_list);\r\npstapriv->auth_list_cnt++;\r\n}\r\nspin_unlock_bh(&pstapriv->auth_list_lock);\r\nif (pstat->auth_seq == 0)\r\npstat->expire_to = pstapriv->auth_to;\r\nif ((pstat->auth_seq + 1) != seq) {\r\nDBG_88E("(1)auth rejected because out of seq [rx_seq=%d, exp_seq=%d]!\n",\r\nseq, pstat->auth_seq+1);\r\nstatus = _STATS_OUT_OF_AUTH_SEQ_;\r\ngoto auth_fail;\r\n}\r\nif (algorithm == 0 && (auth_mode == 0 || auth_mode == 2)) {\r\nif (seq == 1) {\r\npstat->state &= ~WIFI_FW_AUTH_NULL;\r\npstat->state |= WIFI_FW_AUTH_SUCCESS;\r\npstat->expire_to = pstapriv->assoc_to;\r\npstat->authalg = algorithm;\r\n} else {\r\nDBG_88E("(2)auth rejected because out of seq [rx_seq=%d, exp_seq=%d]!\n",\r\nseq, pstat->auth_seq+1);\r\nstatus = _STATS_OUT_OF_AUTH_SEQ_;\r\ngoto auth_fail;\r\n}\r\n} else {\r\nif (seq == 1) {\r\npstat->state &= ~WIFI_FW_AUTH_NULL;\r\npstat->state |= WIFI_FW_AUTH_STATE;\r\npstat->authalg = algorithm;\r\npstat->auth_seq = 2;\r\n} else if (seq == 3) {\r\nDBG_88E("checking for challenging txt...\n");\r\np = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + 4 + _AUTH_IE_OFFSET_ , _CHLGETXT_IE_, (int *)&ie_len,\r\nlen - WLAN_HDR_A3_LEN - _AUTH_IE_OFFSET_ - 4);\r\nif ((p == NULL) || (ie_len <= 0)) {\r\nDBG_88E("auth rejected because challenge failure!(1)\n");\r\nstatus = _STATS_CHALLENGE_FAIL_;\r\ngoto auth_fail;\r\n}\r\nif (!memcmp((void *)(p + 2), pstat->chg_txt, 128)) {\r\npstat->state &= (~WIFI_FW_AUTH_STATE);\r\npstat->state |= WIFI_FW_AUTH_SUCCESS;\r\npstat->expire_to = pstapriv->assoc_to;\r\n} else {\r\nDBG_88E("auth rejected because challenge failure!\n");\r\nstatus = _STATS_CHALLENGE_FAIL_;\r\ngoto auth_fail;\r\n}\r\n} else {\r\nDBG_88E("(3)auth rejected because out of seq [rx_seq=%d, exp_seq=%d]!\n",\r\nseq, pstat->auth_seq+1);\r\nstatus = _STATS_OUT_OF_AUTH_SEQ_;\r\ngoto auth_fail;\r\n}\r\n}\r\npstat->auth_seq = seq + 1;\r\nissue_auth(padapter, pstat, (unsigned short)(_STATS_SUCCESSFUL_));\r\nif (pstat->state & WIFI_FW_AUTH_SUCCESS)\r\npstat->auth_seq = 0;\r\nreturn _SUCCESS;\r\nauth_fail:\r\nif (pstat)\r\nrtw_free_stainfo(padapter, pstat);\r\npstat = &stat;\r\nmemset((char *)pstat, '\0', sizeof(stat));\r\npstat->auth_seq = 2;\r\nmemcpy(pstat->hwaddr, sa, 6);\r\nissue_auth(padapter, pstat, (unsigned short)status);\r\nreturn _FAIL;\r\n}\r\nstatic unsigned int OnAuthClient(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nunsigned int seq, len, status, offset;\r\nunsigned char *p;\r\nunsigned int go2asoc = 0;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 *pframe = precv_frame->rx_data;\r\nuint pkt_len = precv_frame->len;\r\nDBG_88E("%s\n", __func__);\r\nif (memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))\r\nreturn _SUCCESS;\r\nif (!(pmlmeinfo->state & WIFI_FW_AUTH_STATE))\r\nreturn _SUCCESS;\r\noffset = (GetPrivacy(pframe)) ? 4 : 0;\r\nseq = le16_to_cpu(*(__le16 *)((size_t)pframe + WLAN_HDR_A3_LEN + offset + 2));\r\nstatus = le16_to_cpu(*(__le16 *)((size_t)pframe + WLAN_HDR_A3_LEN + offset + 4));\r\nif (status != 0) {\r\nDBG_88E("clnt auth fail, status: %d\n", status);\r\nif (status == 13) {\r\nif (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)\r\npmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;\r\nelse\r\npmlmeinfo->auth_algo = dot11AuthAlgrthm_Shared;\r\n}\r\nset_link_timer(pmlmeext, 1);\r\ngoto authclnt_fail;\r\n}\r\nif (seq == 2) {\r\nif (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared) {\r\np = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _AUTH_IE_OFFSET_, _CHLGETXT_IE_, (int *)&len,\r\npkt_len - WLAN_HDR_A3_LEN - _AUTH_IE_OFFSET_);\r\nif (p == NULL)\r\ngoto authclnt_fail;\r\nmemcpy((void *)(pmlmeinfo->chg_txt), (void *)(p + 2), len);\r\npmlmeinfo->auth_seq = 3;\r\nissue_auth(padapter, NULL, 0);\r\nset_link_timer(pmlmeext, REAUTH_TO);\r\nreturn _SUCCESS;\r\n} else {\r\ngo2asoc = 1;\r\n}\r\n} else if (seq == 4) {\r\nif (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)\r\ngo2asoc = 1;\r\nelse\r\ngoto authclnt_fail;\r\n} else {\r\ngoto authclnt_fail;\r\n}\r\nif (go2asoc) {\r\nDBG_88E_LEVEL(_drv_info_, "auth success, start assoc\n");\r\nstart_clnt_assoc(padapter);\r\nreturn _SUCCESS;\r\n}\r\nauthclnt_fail:\r\nreturn _FAIL;\r\n}\r\nstatic unsigned int OnAssocReq(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\n#ifdef CONFIG_88EU_AP_MODE\r\nu16 capab_info;\r\nstruct rtw_ieee802_11_elems elems;\r\nstruct sta_info *pstat;\r\nunsigned char reassoc, *p, *pos, *wpa_ie;\r\nunsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};\r\nint i, ie_len, wpa_ie_len, left;\r\nunsigned char supportRate[16];\r\nint supportRateNum;\r\nunsigned short status = _STATS_SUCCESSFUL_;\r\nunsigned short frame_type, ie_offset = 0;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur = &(pmlmeinfo->network);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nu8 *pframe = precv_frame->rx_data;\r\nuint pkt_len = precv_frame->len;\r\nif ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)\r\nreturn _FAIL;\r\nframe_type = GetFrameSubType(pframe);\r\nif (frame_type == WIFI_ASSOCREQ) {\r\nreassoc = 0;\r\nie_offset = _ASOCREQ_IE_OFFSET_;\r\n} else {\r\nreassoc = 1;\r\nie_offset = _REASOCREQ_IE_OFFSET_;\r\n}\r\nif (pkt_len < IEEE80211_3ADDR_LEN + ie_offset) {\r\nDBG_88E("handle_assoc(reassoc=%d) - too short payload (len=%lu)"\r\n"\n", reassoc, (unsigned long)pkt_len);\r\nreturn _FAIL;\r\n}\r\npstat = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\r\nif (pstat == NULL) {\r\nstatus = _RSON_CLS2_;\r\ngoto asoc_class2_error;\r\n}\r\ncapab_info = get_unaligned_le16(pframe + WLAN_HDR_A3_LEN);\r\nleft = pkt_len - (IEEE80211_3ADDR_LEN + ie_offset);\r\npos = pframe + (IEEE80211_3ADDR_LEN + ie_offset);\r\nDBG_88E("%s\n", __func__);\r\nif (!((pstat->state) & WIFI_FW_AUTH_SUCCESS)) {\r\nif (!((pstat->state) & WIFI_FW_ASSOC_SUCCESS)) {\r\nstatus = _RSON_CLS2_;\r\ngoto asoc_class2_error;\r\n} else {\r\npstat->state &= (~WIFI_FW_ASSOC_SUCCESS);\r\npstat->state |= WIFI_FW_ASSOC_STATE;\r\n}\r\n} else {\r\npstat->state &= (~WIFI_FW_AUTH_SUCCESS);\r\npstat->state |= WIFI_FW_ASSOC_STATE;\r\n}\r\npstat->capability = capab_info;\r\nif (rtw_ieee802_11_parse_elems(pos, left, &elems, 1) == ParseFailed ||\r\n!elems.ssid) {\r\nDBG_88E("STA %pM sent invalid association request\n",\r\npstat->hwaddr);\r\nstatus = _STATS_FAILURE_;\r\ngoto OnAssocReqFail;\r\n}\r\np = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _SSID_IE_, &ie_len,\r\npkt_len - WLAN_HDR_A3_LEN - ie_offset);\r\nif (p == NULL)\r\nstatus = _STATS_FAILURE_;\r\nif (ie_len == 0) {\r\nstatus = _STATS_FAILURE_;\r\n} else {\r\nif (memcmp((void *)(p+2), cur->Ssid.Ssid, cur->Ssid.SsidLength))\r\nstatus = _STATS_FAILURE_;\r\nif (ie_len != cur->Ssid.SsidLength)\r\nstatus = _STATS_FAILURE_;\r\n}\r\nif (_STATS_SUCCESSFUL_ != status)\r\ngoto OnAssocReqFail;\r\np = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _SUPPORTEDRATES_IE_, &ie_len, pkt_len - WLAN_HDR_A3_LEN - ie_offset);\r\nif (p == NULL) {\r\nDBG_88E("Rx a sta assoc-req which supported rate is empty!\n");\r\nstatus = _STATS_FAILURE_;\r\ngoto OnAssocReqFail;\r\n} else {\r\nmemcpy(supportRate, p+2, ie_len);\r\nsupportRateNum = ie_len;\r\np = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _EXT_SUPPORTEDRATES_IE_ , &ie_len,\r\npkt_len - WLAN_HDR_A3_LEN - ie_offset);\r\nif (p != NULL) {\r\nif (supportRateNum <= sizeof(supportRate)) {\r\nmemcpy(supportRate+supportRateNum, p+2, ie_len);\r\nsupportRateNum += ie_len;\r\n}\r\n}\r\n}\r\npstat->bssratelen = supportRateNum;\r\nmemcpy(pstat->bssrateset, supportRate, supportRateNum);\r\nUpdateBrateTblForSoftAP(pstat->bssrateset, pstat->bssratelen);\r\npstat->dot8021xalg = 0;\r\npstat->wpa_psk = 0;\r\npstat->wpa_group_cipher = 0;\r\npstat->wpa2_group_cipher = 0;\r\npstat->wpa_pairwise_cipher = 0;\r\npstat->wpa2_pairwise_cipher = 0;\r\nmemset(pstat->wpa_ie, 0, sizeof(pstat->wpa_ie));\r\nif ((psecuritypriv->wpa_psk & BIT(1)) && elems.rsn_ie) {\r\nint group_cipher = 0, pairwise_cipher = 0;\r\nwpa_ie = elems.rsn_ie;\r\nwpa_ie_len = elems.rsn_ie_len;\r\nif (rtw_parse_wpa2_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {\r\npstat->dot8021xalg = 1;\r\npstat->wpa_psk |= BIT(1);\r\npstat->wpa2_group_cipher = group_cipher&psecuritypriv->wpa2_group_cipher;\r\npstat->wpa2_pairwise_cipher = pairwise_cipher&psecuritypriv->wpa2_pairwise_cipher;\r\nif (!pstat->wpa2_group_cipher)\r\nstatus = WLAN_STATUS_INVALID_GROUP_CIPHER;\r\nif (!pstat->wpa2_pairwise_cipher)\r\nstatus = WLAN_STATUS_INVALID_PAIRWISE_CIPHER;\r\n} else {\r\nstatus = WLAN_STATUS_INVALID_IE;\r\n}\r\n} else if ((psecuritypriv->wpa_psk & BIT(0)) && elems.wpa_ie) {\r\nint group_cipher = 0, pairwise_cipher = 0;\r\nwpa_ie = elems.wpa_ie;\r\nwpa_ie_len = elems.wpa_ie_len;\r\nif (rtw_parse_wpa_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {\r\npstat->dot8021xalg = 1;\r\npstat->wpa_psk |= BIT(0);\r\npstat->wpa_group_cipher = group_cipher&psecuritypriv->wpa_group_cipher;\r\npstat->wpa_pairwise_cipher = pairwise_cipher&psecuritypriv->wpa_pairwise_cipher;\r\nif (!pstat->wpa_group_cipher)\r\nstatus = WLAN_STATUS_INVALID_GROUP_CIPHER;\r\nif (!pstat->wpa_pairwise_cipher)\r\nstatus = WLAN_STATUS_INVALID_PAIRWISE_CIPHER;\r\n} else {\r\nstatus = WLAN_STATUS_INVALID_IE;\r\n}\r\n} else {\r\nwpa_ie = NULL;\r\nwpa_ie_len = 0;\r\n}\r\nif (_STATS_SUCCESSFUL_ != status)\r\ngoto OnAssocReqFail;\r\npstat->flags &= ~(WLAN_STA_WPS | WLAN_STA_MAYBE_WPS);\r\nif (wpa_ie == NULL) {\r\nif (elems.wps_ie) {\r\nDBG_88E("STA included WPS IE in "\r\n"(Re)Association Request - assume WPS is "\r\n"used\n");\r\npstat->flags |= WLAN_STA_WPS;\r\n} else {\r\nDBG_88E("STA did not include WPA/RSN IE "\r\n"in (Re)Association Request - possible WPS "\r\n"use\n");\r\npstat->flags |= WLAN_STA_MAYBE_WPS;\r\n}\r\nif ((psecuritypriv->wpa_psk > 0) && (pstat->flags & (WLAN_STA_WPS|WLAN_STA_MAYBE_WPS))) {\r\nif (pmlmepriv->wps_beacon_ie) {\r\nu8 selected_registrar = 0;\r\nrtw_get_wps_attr_content(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len, WPS_ATTR_SELECTED_REGISTRAR , &selected_registrar, NULL);\r\nif (!selected_registrar) {\r\nDBG_88E("selected_registrar is false , or AP is not ready to do WPS\n");\r\nstatus = _STATS_UNABLE_HANDLE_STA_;\r\ngoto OnAssocReqFail;\r\n}\r\n}\r\n}\r\n} else {\r\nint copy_len;\r\nif (psecuritypriv->wpa_psk == 0) {\r\nDBG_88E("STA %pM: WPA/RSN IE in association "\r\n"request, but AP don't support WPA/RSN\n", pstat->hwaddr);\r\nstatus = WLAN_STATUS_INVALID_IE;\r\ngoto OnAssocReqFail;\r\n}\r\nif (elems.wps_ie) {\r\nDBG_88E("STA included WPS IE in "\r\n"(Re)Association Request - WPS is "\r\n"used\n");\r\npstat->flags |= WLAN_STA_WPS;\r\ncopy_len = 0;\r\n} else {\r\ncopy_len = min_t(int, wpa_ie_len + 2, sizeof(pstat->wpa_ie));\r\n}\r\nif (copy_len > 0)\r\nmemcpy(pstat->wpa_ie, wpa_ie-2, copy_len);\r\n}\r\npstat->flags &= ~WLAN_STA_WME;\r\npstat->qos_option = 0;\r\npstat->qos_info = 0;\r\npstat->has_legacy_ac = true;\r\npstat->uapsd_vo = 0;\r\npstat->uapsd_vi = 0;\r\npstat->uapsd_be = 0;\r\npstat->uapsd_bk = 0;\r\nif (pmlmepriv->qospriv.qos_option) {\r\np = pframe + WLAN_HDR_A3_LEN + ie_offset; ie_len = 0;\r\nfor (;;) {\r\np = rtw_get_ie(p, _VENDOR_SPECIFIC_IE_, &ie_len, pkt_len - WLAN_HDR_A3_LEN - ie_offset);\r\nif (p != NULL) {\r\nif (!memcmp(p+2, WMM_IE, 6)) {\r\npstat->flags |= WLAN_STA_WME;\r\npstat->qos_option = 1;\r\npstat->qos_info = *(p+8);\r\npstat->max_sp_len = (pstat->qos_info>>5)&0x3;\r\nif ((pstat->qos_info&0xf) != 0xf)\r\npstat->has_legacy_ac = true;\r\nelse\r\npstat->has_legacy_ac = false;\r\nif (pstat->qos_info&0xf) {\r\nif (pstat->qos_info&BIT(0))\r\npstat->uapsd_vo = BIT(0)|BIT(1);\r\nelse\r\npstat->uapsd_vo = 0;\r\nif (pstat->qos_info&BIT(1))\r\npstat->uapsd_vi = BIT(0)|BIT(1);\r\nelse\r\npstat->uapsd_vi = 0;\r\nif (pstat->qos_info&BIT(2))\r\npstat->uapsd_bk = BIT(0)|BIT(1);\r\nelse\r\npstat->uapsd_bk = 0;\r\nif (pstat->qos_info&BIT(3))\r\npstat->uapsd_be = BIT(0)|BIT(1);\r\nelse\r\npstat->uapsd_be = 0;\r\n}\r\nbreak;\r\n}\r\n} else {\r\nbreak;\r\n}\r\np = p + ie_len + 2;\r\n}\r\n}\r\nmemset(&pstat->htpriv.ht_cap, 0, sizeof(struct rtw_ieee80211_ht_cap));\r\nif (elems.ht_capabilities && elems.ht_capabilities_len >= sizeof(struct rtw_ieee80211_ht_cap)) {\r\npstat->flags |= WLAN_STA_HT;\r\npstat->flags |= WLAN_STA_WME;\r\nmemcpy(&pstat->htpriv.ht_cap, elems.ht_capabilities, sizeof(struct rtw_ieee80211_ht_cap));\r\n} else {\r\npstat->flags &= ~WLAN_STA_HT;\r\n}\r\nif ((!pmlmepriv->htpriv.ht_option) && (pstat->flags&WLAN_STA_HT)) {\r\nstatus = _STATS_FAILURE_;\r\ngoto OnAssocReqFail;\r\n}\r\nif ((pstat->flags & WLAN_STA_HT) &&\r\n((pstat->wpa2_pairwise_cipher&WPA_CIPHER_TKIP) ||\r\n(pstat->wpa_pairwise_cipher&WPA_CIPHER_TKIP))) {\r\nDBG_88E("HT: %pM tried to "\r\n"use TKIP with HT association\n", pstat->hwaddr);\r\n}\r\npstat->flags |= WLAN_STA_NONERP;\r\nfor (i = 0; i < pstat->bssratelen; i++) {\r\nif ((pstat->bssrateset[i] & 0x7f) > 22) {\r\npstat->flags &= ~WLAN_STA_NONERP;\r\nbreak;\r\n}\r\n}\r\nif (pstat->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\r\npstat->flags |= WLAN_STA_SHORT_PREAMBLE;\r\nelse\r\npstat->flags &= ~WLAN_STA_SHORT_PREAMBLE;\r\nif (status != _STATS_SUCCESSFUL_)\r\ngoto OnAssocReqFail;\r\nif (pstat->aid > 0) {\r\nDBG_88E(" old AID %d\n", pstat->aid);\r\n} else {\r\nfor (pstat->aid = 1; pstat->aid <= NUM_STA; pstat->aid++)\r\nif (pstapriv->sta_aid[pstat->aid - 1] == NULL)\r\nbreak;\r\nif (pstat->aid > pstapriv->max_num_sta) {\r\npstat->aid = 0;\r\nDBG_88E(" no room for more AIDs\n");\r\nstatus = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;\r\ngoto OnAssocReqFail;\r\n} else {\r\npstapriv->sta_aid[pstat->aid - 1] = pstat;\r\nDBG_88E("allocate new AID=(%d)\n", pstat->aid);\r\n}\r\n}\r\npstat->state &= (~WIFI_FW_ASSOC_STATE);\r\npstat->state |= WIFI_FW_ASSOC_SUCCESS;\r\nspin_lock_bh(&pstapriv->auth_list_lock);\r\nif (!list_empty(&pstat->auth_list)) {\r\nlist_del_init(&pstat->auth_list);\r\npstapriv->auth_list_cnt--;\r\n}\r\nspin_unlock_bh(&pstapriv->auth_list_lock);\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nif (list_empty(&pstat->asoc_list)) {\r\npstat->expire_to = pstapriv->expire_to;\r\nlist_add_tail(&pstat->asoc_list, &pstapriv->asoc_list);\r\npstapriv->asoc_list_cnt++;\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nif ((pstat->state & WIFI_FW_ASSOC_SUCCESS) && (_STATS_SUCCESSFUL_ == status)) {\r\nbss_cap_update_on_sta_join(padapter, pstat);\r\nsta_info_update(padapter, pstat);\r\nif (frame_type == WIFI_ASSOCREQ)\r\nissue_asocrsp(padapter, status, pstat, WIFI_ASSOCRSP);\r\nelse\r\nissue_asocrsp(padapter, status, pstat, WIFI_REASSOCRSP);\r\nDBG_88E("indicate_sta_join_event to upper layer - hostapd\n");\r\nrtw_indicate_sta_assoc_event(padapter, pstat);\r\nreport_add_sta_event(padapter, pstat->hwaddr, pstat->aid);\r\n}\r\nreturn _SUCCESS;\r\nasoc_class2_error:\r\nissue_deauth(padapter, (void *)GetAddr2Ptr(pframe), status);\r\nreturn _FAIL;\r\nOnAssocReqFail:\r\npstat->aid = 0;\r\nif (frame_type == WIFI_ASSOCREQ)\r\nissue_asocrsp(padapter, status, pstat, WIFI_ASSOCRSP);\r\nelse\r\nissue_asocrsp(padapter, status, pstat, WIFI_REASSOCRSP);\r\n#endif\r\nreturn _FAIL;\r\n}\r\nstatic unsigned int OnAssocRsp(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nuint i;\r\nint res;\r\nunsigned short status;\r\nstruct ndis_802_11_var_ie *pIE;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 *pframe = precv_frame->rx_data;\r\nuint pkt_len = precv_frame->len;\r\nDBG_88E("%s\n", __func__);\r\nif (memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))\r\nreturn _SUCCESS;\r\nif (!(pmlmeinfo->state & (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE)))\r\nreturn _SUCCESS;\r\nif (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)\r\nreturn _SUCCESS;\r\ndel_timer_sync(&pmlmeext->link_timer);\r\nstatus = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN + 2));\r\nif (status > 0) {\r\nDBG_88E("assoc reject, status code: %d\n", status);\r\npmlmeinfo->state = WIFI_FW_NULL_STATE;\r\nres = -4;\r\ngoto report_assoc_result;\r\n}\r\npmlmeinfo->capability = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));\r\npmlmeinfo->slotTime = (pmlmeinfo->capability & BIT(10)) ? 9 : 20;\r\npmlmeinfo->aid = (int)(le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN + 4))&0x3fff);\r\nres = pmlmeinfo->aid;\r\nfor (i = (6 + WLAN_HDR_A3_LEN); i < pkt_len;) {\r\npIE = (struct ndis_802_11_var_ie *)(pframe + i);\r\nswitch (pIE->ElementID) {\r\ncase _VENDOR_SPECIFIC_IE_:\r\nif (!memcmp(pIE->data, WMM_PARA_OUI, 6))\r\nWMM_param_handler(padapter, pIE);\r\nbreak;\r\ncase _HT_CAPABILITY_IE_:\r\nHT_caps_handler(padapter, pIE);\r\nbreak;\r\ncase _HT_EXTRA_INFO_IE_:\r\nHT_info_handler(padapter, pIE);\r\nbreak;\r\ncase _ERPINFO_IE_:\r\nERP_IE_handler(padapter, pIE);\r\ndefault:\r\nbreak;\r\n}\r\ni += (pIE->Length + 2);\r\n}\r\npmlmeinfo->state &= (~WIFI_FW_ASSOC_STATE);\r\npmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;\r\nUpdateBrateTbl(padapter, pmlmeinfo->network.SupportedRates);\r\nreport_assoc_result:\r\nif (res > 0) {\r\nrtw_buf_update(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len, pframe, pkt_len);\r\n} else {\r\nrtw_buf_free(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len);\r\n}\r\nreport_join_res(padapter, res);\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnDeAuth(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nunsigned short reason;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 *pframe = precv_frame->rx_data;\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nif (memcmp(GetAddr3Ptr(pframe), pnetwork->MacAddress, ETH_ALEN))\r\nreturn _SUCCESS;\r\nreason = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));\r\nDBG_88E("%s Reason code(%d)\n", __func__, reason);\r\n#ifdef CONFIG_88EU_AP_MODE\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nDBG_88E_LEVEL(_drv_always_, "ap recv deauth reason code(%d) sta:%pM\n",\r\nreason, GetAddr2Ptr(pframe));\r\npsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\r\nif (psta) {\r\nu8 updated = 0;\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nif (!list_empty(&psta->asoc_list)) {\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nupdated = ap_free_sta(padapter, psta, false, reason);\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nassociated_clients_update(padapter, updated);\r\n}\r\nreturn _SUCCESS;\r\n} else\r\n#endif\r\n{\r\nDBG_88E_LEVEL(_drv_always_, "sta recv deauth reason code(%d) sta:%pM\n",\r\nreason, GetAddr3Ptr(pframe));\r\nreceive_disconnect(padapter, GetAddr3Ptr(pframe) , reason);\r\n}\r\npmlmepriv->LinkDetectInfo.bBusyTraffic = false;\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnDisassoc(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nu16 reason;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 *pframe = precv_frame->rx_data;\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nif (memcmp(GetAddr3Ptr(pframe), pnetwork->MacAddress, ETH_ALEN))\r\nreturn _SUCCESS;\r\nreason = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));\r\nDBG_88E("%s Reason code(%d)\n", __func__, reason);\r\n#ifdef CONFIG_88EU_AP_MODE\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nDBG_88E_LEVEL(_drv_always_, "ap recv disassoc reason code(%d) sta:%pM\n",\r\nreason, GetAddr2Ptr(pframe));\r\npsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\r\nif (psta) {\r\nu8 updated = 0;\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nif (!list_empty(&psta->asoc_list)) {\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nupdated = ap_free_sta(padapter, psta, false, reason);\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nassociated_clients_update(padapter, updated);\r\n}\r\nreturn _SUCCESS;\r\n} else\r\n#endif\r\n{\r\nDBG_88E_LEVEL(_drv_always_, "ap recv disassoc reason code(%d) sta:%pM\n",\r\nreason, GetAddr3Ptr(pframe));\r\nreceive_disconnect(padapter, GetAddr3Ptr(pframe), reason);\r\n}\r\npmlmepriv->LinkDetectInfo.bBusyTraffic = false;\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnAtim(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nDBG_88E("%s\n", __func__);\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int on_action_spct(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nu8 *pframe = precv_frame->rx_data;\r\nu8 *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);\r\nu8 category;\r\nu8 action;\r\nDBG_88E(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(padapter->pnetdev));\r\npsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\r\nif (!psta)\r\ngoto exit;\r\ncategory = frame_body[0];\r\nif (category != RTW_WLAN_CATEGORY_SPECTRUM_MGMT)\r\ngoto exit;\r\naction = frame_body[1];\r\nswitch (action) {\r\ncase RTW_WLAN_ACTION_SPCT_MSR_REQ:\r\ncase RTW_WLAN_ACTION_SPCT_MSR_RPRT:\r\ncase RTW_WLAN_ACTION_SPCT_TPC_REQ:\r\ncase RTW_WLAN_ACTION_SPCT_TPC_RPRT:\r\nbreak;\r\ncase RTW_WLAN_ACTION_SPCT_CHL_SWITCH:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nexit:\r\nreturn _FAIL;\r\n}\r\nstatic unsigned int OnAction_qos(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnAction_dls(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnAction_back(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nu8 *addr;\r\nstruct sta_info *psta = NULL;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nunsigned char *frame_body;\r\nunsigned char category, action;\r\nunsigned short tid, status, reason_code = 0;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 *pframe = precv_frame->rx_data;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nif (memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe),\r\nETH_ALEN))\r\nreturn _SUCCESS;\r\nDBG_88E("%s\n", __func__);\r\nif ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)\r\nif (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))\r\nreturn _SUCCESS;\r\naddr = GetAddr2Ptr(pframe);\r\npsta = rtw_get_stainfo(pstapriv, addr);\r\nif (psta == NULL)\r\nreturn _SUCCESS;\r\nframe_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));\r\ncategory = frame_body[0];\r\nif (category == RTW_WLAN_CATEGORY_BACK) {\r\nif (!pmlmeinfo->HT_enable)\r\nreturn _SUCCESS;\r\naction = frame_body[1];\r\nDBG_88E("%s, action=%d\n", __func__, action);\r\nswitch (action) {\r\ncase RTW_WLAN_ACTION_ADDBA_REQ:\r\nmemcpy(&(pmlmeinfo->ADDBA_req), &(frame_body[2]), sizeof(struct ADDBA_request));\r\nprocess_addba_req(padapter, (u8 *)&(pmlmeinfo->ADDBA_req), addr);\r\nissue_action_BA(padapter, addr,\r\nRTW_WLAN_ACTION_ADDBA_RESP,\r\npmlmeinfo->accept_addba_req ? 0 : 37);\r\nbreak;\r\ncase RTW_WLAN_ACTION_ADDBA_RESP:\r\nstatus = get_unaligned_le16(&frame_body[3]);\r\ntid = (frame_body[5] >> 2) & 0x7;\r\nif (status == 0) {\r\nDBG_88E("agg_enable for TID=%d\n", tid);\r\npsta->htpriv.agg_enable_bitmap |= 1 << tid;\r\npsta->htpriv.candidate_tid_bitmap &= ~BIT(tid);\r\n} else {\r\npsta->htpriv.agg_enable_bitmap &= ~BIT(tid);\r\n}\r\nbreak;\r\ncase RTW_WLAN_ACTION_DELBA:\r\nif ((frame_body[3] & BIT(3)) == 0) {\r\npsta->htpriv.agg_enable_bitmap &= ~(1 << ((frame_body[3] >> 4) & 0xf));\r\npsta->htpriv.candidate_tid_bitmap &= ~(1 << ((frame_body[3] >> 4) & 0xf));\r\nreason_code = get_unaligned_le16(&frame_body[4]);\r\n} else if ((frame_body[3] & BIT(3)) == BIT(3)) {\r\ntid = (frame_body[3] >> 4) & 0x0F;\r\npreorder_ctrl = &psta->recvreorder_ctrl[tid];\r\npreorder_ctrl->enable = false;\r\npreorder_ctrl->indicate_seq = 0xffff;\r\n}\r\nDBG_88E("%s(): DELBA: %x(%x)\n", __func__, pmlmeinfo->agg_enable_bitmap, reason_code);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic s32 rtw_action_public_decache(struct recv_frame *recv_frame, s32 token)\r\n{\r\nstruct adapter *adapter = recv_frame->adapter;\r\nstruct mlme_ext_priv *mlmeext = &(adapter->mlmeextpriv);\r\nu8 *frame = recv_frame->rx_data;\r\nu16 seq_ctrl = ((recv_frame->attrib.seq_num&0xffff) << 4) |\r\n(recv_frame->attrib.frag_num & 0xf);\r\nif (GetRetry(frame)) {\r\nif (token >= 0) {\r\nif ((seq_ctrl == mlmeext->action_public_rxseq) && (token == mlmeext->action_public_dialog_token)) {\r\nDBG_88E(FUNC_ADPT_FMT" seq_ctrl = 0x%x, rxseq = 0x%x, token:%d\n",\r\nFUNC_ADPT_ARG(adapter), seq_ctrl, mlmeext->action_public_rxseq, token);\r\nreturn _FAIL;\r\n}\r\n} else {\r\nif (seq_ctrl == mlmeext->action_public_rxseq) {\r\nDBG_88E(FUNC_ADPT_FMT" seq_ctrl = 0x%x, rxseq = 0x%x\n",\r\nFUNC_ADPT_ARG(adapter), seq_ctrl, mlmeext->action_public_rxseq);\r\nreturn _FAIL;\r\n}\r\n}\r\n}\r\nmlmeext->action_public_rxseq = seq_ctrl;\r\nif (token >= 0)\r\nmlmeext->action_public_dialog_token = token;\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int on_action_public_p2p(struct recv_frame *precv_frame)\r\n{\r\nu8 *pframe = precv_frame->rx_data;\r\nu8 *frame_body;\r\nu8 dialogToken = 0;\r\nframe_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));\r\ndialogToken = frame_body[7];\r\nif (rtw_action_public_decache(precv_frame, dialogToken) == _FAIL)\r\nreturn _FAIL;\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int on_action_public_vendor(struct recv_frame *precv_frame)\r\n{\r\nunsigned int ret = _FAIL;\r\nu8 *pframe = precv_frame->rx_data;\r\nu8 *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);\r\nif (!memcmp(frame_body + 2, P2P_OUI, 4))\r\nret = on_action_public_p2p(precv_frame);\r\nreturn ret;\r\n}\r\nstatic unsigned int on_action_public_default(struct recv_frame *precv_frame, u8 action)\r\n{\r\nunsigned int ret = _FAIL;\r\nu8 *pframe = precv_frame->rx_data;\r\nu8 *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);\r\nu8 token;\r\ntoken = frame_body[2];\r\nif (rtw_action_public_decache(precv_frame, token) == _FAIL)\r\ngoto exit;\r\nret = _SUCCESS;\r\nexit:\r\nreturn ret;\r\n}\r\nstatic unsigned int on_action_public(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nunsigned int ret = _FAIL;\r\nu8 *pframe = precv_frame->rx_data;\r\nu8 *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);\r\nu8 category, action;\r\nif (memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))\r\ngoto exit;\r\ncategory = frame_body[0];\r\nif (category != RTW_WLAN_CATEGORY_PUBLIC)\r\ngoto exit;\r\naction = frame_body[1];\r\nswitch (action) {\r\ncase ACT_PUBLIC_VENDOR:\r\nret = on_action_public_vendor(precv_frame);\r\nbreak;\r\ndefault:\r\nret = on_action_public_default(precv_frame, action);\r\nbreak;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic unsigned int OnAction_ht(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnAction_wmm(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnAction_p2p(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int DoReserved(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int OnAction(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nint i;\r\nunsigned char category;\r\nstruct action_handler *ptable;\r\nunsigned char *frame_body;\r\nu8 *pframe = precv_frame->rx_data;\r\nframe_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));\r\ncategory = frame_body[0];\r\nfor (i = 0; i < ARRAY_SIZE(OnAction_tbl); i++) {\r\nptable = &OnAction_tbl[i];\r\nif (category == ptable->num)\r\nptable->func(padapter, precv_frame);\r\n}\r\nreturn _SUCCESS;\r\n}\r\nint init_hw_mlme_ext(struct adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\r\nreturn _SUCCESS;\r\n}\r\nstatic void init_mlme_ext_priv_value(struct adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nunsigned char mixed_datarate[NumRates] = {\r\n_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_,\r\n_9M_RATE_, _12M_RATE_, _18M_RATE_, _24M_RATE_, _36M_RATE_,\r\n_48M_RATE_, _54M_RATE_, 0xff\r\n};\r\nunsigned char mixed_basicrate[NumRates] = {\r\n_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_,\r\n_12M_RATE_, _24M_RATE_, 0xff,\r\n};\r\natomic_set(&pmlmeext->event_seq, 0);\r\npmlmeext->mgnt_seq = 0;\r\npmlmeext->cur_channel = padapter->registrypriv.channel;\r\npmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\npmlmeext->oper_channel = pmlmeext->cur_channel;\r\npmlmeext->oper_bwmode = pmlmeext->cur_bwmode;\r\npmlmeext->oper_ch_offset = pmlmeext->cur_ch_offset;\r\npmlmeext->retry = 0;\r\npmlmeext->cur_wireless_mode = padapter->registrypriv.wireless_mode;\r\nmemcpy(pmlmeext->datarate, mixed_datarate, NumRates);\r\nmemcpy(pmlmeext->basicrate, mixed_basicrate, NumRates);\r\npmlmeext->tx_rate = IEEE80211_CCK_RATE_1MB;\r\npmlmeext->sitesurvey_res.state = SCAN_DISABLE;\r\npmlmeext->sitesurvey_res.channel_idx = 0;\r\npmlmeext->sitesurvey_res.bss_cnt = 0;\r\npmlmeext->scan_abort = false;\r\npmlmeinfo->state = WIFI_FW_NULL_STATE;\r\npmlmeinfo->reauth_count = 0;\r\npmlmeinfo->reassoc_count = 0;\r\npmlmeinfo->link_count = 0;\r\npmlmeinfo->auth_seq = 0;\r\npmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;\r\npmlmeinfo->key_index = 0;\r\npmlmeinfo->iv = 0;\r\npmlmeinfo->enc_algo = _NO_PRIVACY_;\r\npmlmeinfo->authModeToggle = 0;\r\nmemset(pmlmeinfo->chg_txt, 0, 128);\r\npmlmeinfo->slotTime = SHORT_SLOT_TIME;\r\npmlmeinfo->preamble_mode = PREAMBLE_AUTO;\r\npmlmeinfo->dialogToken = 0;\r\npmlmeext->action_public_rxseq = 0xffff;\r\npmlmeext->action_public_dialog_token = 0xff;\r\n}\r\nstatic int has_channel(struct rt_channel_info *channel_set,\r\nu8 chanset_size,\r\nu8 chan) {\r\nint i;\r\nfor (i = 0; i < chanset_size; i++) {\r\nif (channel_set[i].ChannelNum == chan)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void init_channel_list(struct adapter *padapter, struct rt_channel_info *channel_set,\r\nu8 chanset_size,\r\nstruct p2p_channels *channel_list) {\r\nstruct p2p_oper_class_map op_class[] = {\r\n{ IEEE80211G, 81, 1, 13, 1, BW20 },\r\n{ IEEE80211G, 82, 14, 14, 1, BW20 },\r\n{ -1, 0, 0, 0, 0, BW20 }\r\n};\r\nint cla, op;\r\ncla = 0;\r\nfor (op = 0; op_class[op].op_class; op++) {\r\nu8 ch;\r\nstruct p2p_oper_class_map *o = &op_class[op];\r\nstruct p2p_reg_class *reg = NULL;\r\nfor (ch = o->min_chan; ch <= o->max_chan; ch += o->inc) {\r\nif (!has_channel(channel_set, chanset_size, ch)) {\r\ncontinue;\r\n}\r\nif ((0 == padapter->registrypriv.ht_enable) && (8 == o->inc))\r\ncontinue;\r\nif ((0 == (padapter->registrypriv.cbw40_enable & BIT(1))) &&\r\n((BW40MINUS == o->bw) || (BW40PLUS == o->bw)))\r\ncontinue;\r\nif (reg == NULL) {\r\nreg = &channel_list->reg_class[cla];\r\ncla++;\r\nreg->reg_class = o->op_class;\r\nreg->channels = 0;\r\n}\r\nreg->channel[reg->channels] = ch;\r\nreg->channels++;\r\n}\r\n}\r\nchannel_list->reg_classes = cla;\r\n}\r\nstatic u8 init_channel_set(struct adapter *padapter, u8 ChannelPlan, struct rt_channel_info *channel_set)\r\n{\r\nu8 index, chanset_size = 0;\r\nu8 b2_4GBand = false;\r\nu8 Index2G = 0;\r\nmemset(channel_set, 0, sizeof(struct rt_channel_info) * MAX_CHANNEL_NUM);\r\nif (ChannelPlan >= RT_CHANNEL_DOMAIN_MAX && ChannelPlan != RT_CHANNEL_DOMAIN_REALTEK_DEFINE) {\r\nDBG_88E("ChannelPlan ID %x error !!!!!\n", ChannelPlan);\r\nreturn chanset_size;\r\n}\r\nif (padapter->registrypriv.wireless_mode & WIRELESS_11G) {\r\nb2_4GBand = true;\r\nif (RT_CHANNEL_DOMAIN_REALTEK_DEFINE == ChannelPlan)\r\nIndex2G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index2G;\r\nelse\r\nIndex2G = RTW_ChannelPlanMap[ChannelPlan].Index2G;\r\n}\r\nif (b2_4GBand) {\r\nfor (index = 0; index < RTW_ChannelPlan2G[Index2G].Len; index++) {\r\nchannel_set[chanset_size].ChannelNum = RTW_ChannelPlan2G[Index2G].Channel[index];\r\nif ((RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN == ChannelPlan) ||\r\n(RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN_2G == ChannelPlan)) {\r\nif (channel_set[chanset_size].ChannelNum >= 1 && channel_set[chanset_size].ChannelNum <= 11)\r\nchannel_set[chanset_size].ScanType = SCAN_ACTIVE;\r\nelse if ((channel_set[chanset_size].ChannelNum >= 12 && channel_set[chanset_size].ChannelNum <= 14))\r\nchannel_set[chanset_size].ScanType = SCAN_PASSIVE;\r\n} else if (RT_CHANNEL_DOMAIN_WORLD_WIDE_13 == ChannelPlan ||\r\nRT_CHANNEL_DOMAIN_2G_WORLD == Index2G) {\r\nif (channel_set[chanset_size].ChannelNum <= 11)\r\nchannel_set[chanset_size].ScanType = SCAN_ACTIVE;\r\nelse\r\nchannel_set[chanset_size].ScanType = SCAN_PASSIVE;\r\n} else {\r\nchannel_set[chanset_size].ScanType = SCAN_ACTIVE;\r\n}\r\nchanset_size++;\r\n}\r\n}\r\nreturn chanset_size;\r\n}\r\nint init_mlme_ext_priv(struct adapter *padapter)\r\n{\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\npmlmeext->padapter = padapter;\r\ninit_mlme_ext_priv_value(padapter);\r\npmlmeinfo->accept_addba_req = pregistrypriv->accept_addba_req;\r\ninit_mlme_ext_timer(padapter);\r\n#ifdef CONFIG_88EU_AP_MODE\r\ninit_mlme_ap_info(padapter);\r\n#endif\r\npmlmeext->max_chan_nums = init_channel_set(padapter, pmlmepriv->ChannelPlan, pmlmeext->channel_set);\r\ninit_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);\r\npmlmeext->chan_scan_time = SURVEY_TO;\r\npmlmeext->mlmeext_init = true;\r\npmlmeext->active_keep_alive_check = true;\r\nreturn _SUCCESS;\r\n}\r\nvoid free_mlme_ext_priv(struct mlme_ext_priv *pmlmeext)\r\n{\r\nstruct adapter *padapter = pmlmeext->padapter;\r\nif (!padapter)\r\nreturn;\r\nif (padapter->bDriverStopped) {\r\ndel_timer_sync(&pmlmeext->survey_timer);\r\ndel_timer_sync(&pmlmeext->link_timer);\r\n}\r\n}\r\nstatic void _mgt_dispatcher(struct adapter *padapter, struct mlme_handler *ptable, struct recv_frame *precv_frame)\r\n{\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nu8 *pframe = precv_frame->rx_data;\r\nif (ptable->func) {\r\nif (memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN) &&\r\nmemcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN))\r\nreturn;\r\nptable->func(padapter, precv_frame);\r\n}\r\n}\r\nvoid mgt_dispatcher(struct adapter *padapter, struct recv_frame *precv_frame)\r\n{\r\nint index;\r\nstruct mlme_handler *ptable;\r\n#ifdef CONFIG_88EU_AP_MODE\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\n#endif\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nu8 *pframe = precv_frame->rx_data;\r\nstruct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, GetAddr2Ptr(pframe));\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("+mgt_dispatcher: type(0x%x) subtype(0x%x)\n",\r\n(unsigned int)GetFrameType(pframe),\r\n(unsigned int)GetFrameSubType(pframe)));\r\nif (GetFrameType(pframe) != WIFI_MGT_TYPE) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,\r\n("mgt_dispatcher: type(0x%x) error!\n",\r\n(unsigned int)GetFrameType(pframe)));\r\nreturn;\r\n}\r\nif (memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN) &&\r\nmemcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN))\r\nreturn;\r\nptable = mlme_sta_tbl;\r\nindex = GetFrameSubType(pframe) >> 4;\r\nif (index > 13) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("Currently we do not support reserved sub-fr-type=%d\n", index));\r\nreturn;\r\n}\r\nptable += index;\r\nif (psta != NULL) {\r\nif (GetRetry(pframe)) {\r\nif (precv_frame->attrib.seq_num ==\r\npsta->RxMgmtFrameSeqNum) {\r\nDBG_88E("Drop duplicate management frame with seq_num=%d.\n",\r\nprecv_frame->attrib.seq_num);\r\nreturn;\r\n}\r\n}\r\npsta->RxMgmtFrameSeqNum = precv_frame->attrib.seq_num;\r\n}\r\n#ifdef CONFIG_88EU_AP_MODE\r\nswitch (GetFrameSubType(pframe)) {\r\ncase WIFI_AUTH:\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE))\r\nptable->func = &OnAuth;\r\nelse\r\nptable->func = &OnAuthClient;\r\ncase WIFI_ASSOCREQ:\r\ncase WIFI_REASSOCREQ:\r\ncase WIFI_PROBEREQ:\r\ncase WIFI_BEACON:\r\ncase WIFI_ACTION:\r\n_mgt_dispatcher(padapter, ptable, precv_frame);\r\nbreak;\r\ndefault:\r\n_mgt_dispatcher(padapter, ptable, precv_frame);\r\nbreak;\r\n}\r\n#else\r\n_mgt_dispatcher(padapter, ptable, precv_frame);\r\n#endif\r\n}\r\nvoid report_survey_event(struct adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nstruct cmd_obj *pcmd_obj;\r\nu8 *pevtcmd;\r\nu32 cmdsz;\r\nstruct survey_event *psurvey_evt;\r\nstruct C2HEvent_Header *pc2h_evt_hdr;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct cmd_priv *pcmdpriv;\r\nif (!padapter)\r\nreturn;\r\npmlmeext = &padapter->mlmeextpriv;\r\npcmdpriv = &padapter->cmdpriv;\r\npcmd_obj = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);\r\nif (!pcmd_obj)\r\nreturn;\r\ncmdsz = sizeof(struct survey_event) + sizeof(struct C2HEvent_Header);\r\npevtcmd = kzalloc(cmdsz, GFP_ATOMIC);\r\nif (!pevtcmd) {\r\nkfree(pcmd_obj);\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&pcmd_obj->list);\r\npcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\r\npcmd_obj->cmdsz = cmdsz;\r\npcmd_obj->parmbuf = pevtcmd;\r\npcmd_obj->rsp = NULL;\r\npcmd_obj->rspsz = 0;\r\npc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\r\npc2h_evt_hdr->len = sizeof(struct survey_event);\r\npc2h_evt_hdr->ID = GEN_EVT_CODE(_Survey);\r\npc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\r\npsurvey_evt = (struct survey_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\r\nif (collect_bss_info(padapter, precv_frame, (struct wlan_bssid_ex *)&psurvey_evt->bss) == _FAIL) {\r\nkfree(pcmd_obj);\r\nkfree(pevtcmd);\r\nreturn;\r\n}\r\nprocess_80211d(padapter, &psurvey_evt->bss);\r\nrtw_enqueue_cmd(pcmdpriv, pcmd_obj);\r\npmlmeext->sitesurvey_res.bss_cnt++;\r\n}\r\nvoid report_surveydone_event(struct adapter *padapter)\r\n{\r\nstruct cmd_obj *pcmd_obj;\r\nu8 *pevtcmd;\r\nu32 cmdsz;\r\nstruct surveydone_event *psurveydone_evt;\r\nstruct C2HEvent_Header *pc2h_evt_hdr;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\npcmd_obj = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (!pcmd_obj)\r\nreturn;\r\ncmdsz = sizeof(struct surveydone_event) + sizeof(struct C2HEvent_Header);\r\npevtcmd = kzalloc(cmdsz, GFP_KERNEL);\r\nif (!pevtcmd) {\r\nkfree(pcmd_obj);\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&pcmd_obj->list);\r\npcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\r\npcmd_obj->cmdsz = cmdsz;\r\npcmd_obj->parmbuf = pevtcmd;\r\npcmd_obj->rsp = NULL;\r\npcmd_obj->rspsz = 0;\r\npc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\r\npc2h_evt_hdr->len = sizeof(struct surveydone_event);\r\npc2h_evt_hdr->ID = GEN_EVT_CODE(_SurveyDone);\r\npc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\r\npsurveydone_evt = (struct surveydone_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\r\npsurveydone_evt->bss_cnt = pmlmeext->sitesurvey_res.bss_cnt;\r\nDBG_88E("survey done event(%x)\n", psurveydone_evt->bss_cnt);\r\nrtw_enqueue_cmd(pcmdpriv, pcmd_obj);\r\n}\r\nvoid report_join_res(struct adapter *padapter, int res)\r\n{\r\nstruct cmd_obj *pcmd_obj;\r\nu8 *pevtcmd;\r\nu32 cmdsz;\r\nstruct joinbss_event *pjoinbss_evt;\r\nstruct C2HEvent_Header *pc2h_evt_hdr;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\npcmd_obj = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);\r\nif (!pcmd_obj)\r\nreturn;\r\ncmdsz = sizeof(struct joinbss_event) + sizeof(struct C2HEvent_Header);\r\npevtcmd = kzalloc(cmdsz, GFP_ATOMIC);\r\nif (!pevtcmd) {\r\nkfree(pcmd_obj);\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&pcmd_obj->list);\r\npcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\r\npcmd_obj->cmdsz = cmdsz;\r\npcmd_obj->parmbuf = pevtcmd;\r\npcmd_obj->rsp = NULL;\r\npcmd_obj->rspsz = 0;\r\npc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\r\npc2h_evt_hdr->len = sizeof(struct joinbss_event);\r\npc2h_evt_hdr->ID = GEN_EVT_CODE(_JoinBss);\r\npc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\r\npjoinbss_evt = (struct joinbss_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\r\nmemcpy((unsigned char *)(&(pjoinbss_evt->network.network)), &(pmlmeinfo->network), sizeof(struct wlan_bssid_ex));\r\npjoinbss_evt->network.join_res = res;\r\npjoinbss_evt->network.aid = res;\r\nDBG_88E("report_join_res(%d)\n", res);\r\nrtw_joinbss_event_prehandle(padapter, (u8 *)&pjoinbss_evt->network);\r\nrtw_enqueue_cmd(pcmdpriv, pcmd_obj);\r\n}\r\nvoid report_del_sta_event(struct adapter *padapter, unsigned char *MacAddr, unsigned short reason)\r\n{\r\nstruct cmd_obj *pcmd_obj;\r\nu8 *pevtcmd;\r\nu32 cmdsz;\r\nstruct sta_info *psta;\r\nint mac_id;\r\nstruct stadel_event *pdel_sta_evt;\r\nstruct C2HEvent_Header *pc2h_evt_hdr;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\npcmd_obj = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (!pcmd_obj)\r\nreturn;\r\ncmdsz = sizeof(struct stadel_event) + sizeof(struct C2HEvent_Header);\r\npevtcmd = kzalloc(cmdsz, GFP_KERNEL);\r\nif (!pevtcmd) {\r\nkfree(pcmd_obj);\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&pcmd_obj->list);\r\npcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\r\npcmd_obj->cmdsz = cmdsz;\r\npcmd_obj->parmbuf = pevtcmd;\r\npcmd_obj->rsp = NULL;\r\npcmd_obj->rspsz = 0;\r\npc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\r\npc2h_evt_hdr->len = sizeof(struct stadel_event);\r\npc2h_evt_hdr->ID = GEN_EVT_CODE(_DelSTA);\r\npc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\r\npdel_sta_evt = (struct stadel_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\r\nmemcpy((unsigned char *)(&(pdel_sta_evt->macaddr)), MacAddr, ETH_ALEN);\r\nmemcpy((unsigned char *)(pdel_sta_evt->rsvd), (unsigned char *)(&reason), 2);\r\npsta = rtw_get_stainfo(&padapter->stapriv, MacAddr);\r\nif (psta)\r\nmac_id = (int)psta->mac_id;\r\nelse\r\nmac_id = -1;\r\npdel_sta_evt->mac_id = mac_id;\r\nDBG_88E("report_del_sta_event: delete STA, mac_id =%d\n", mac_id);\r\nrtw_enqueue_cmd(pcmdpriv, pcmd_obj);\r\n}\r\nvoid report_add_sta_event(struct adapter *padapter, unsigned char *MacAddr, int cam_idx)\r\n{\r\nstruct cmd_obj *pcmd_obj;\r\nu8 *pevtcmd;\r\nu32 cmdsz;\r\nstruct stassoc_event *padd_sta_evt;\r\nstruct C2HEvent_Header *pc2h_evt_hdr;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\npcmd_obj = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (!pcmd_obj)\r\nreturn;\r\ncmdsz = sizeof(struct stassoc_event) + sizeof(struct C2HEvent_Header);\r\npevtcmd = kzalloc(cmdsz, GFP_KERNEL);\r\nif (!pevtcmd) {\r\nkfree(pcmd_obj);\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&pcmd_obj->list);\r\npcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\r\npcmd_obj->cmdsz = cmdsz;\r\npcmd_obj->parmbuf = pevtcmd;\r\npcmd_obj->rsp = NULL;\r\npcmd_obj->rspsz = 0;\r\npc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\r\npc2h_evt_hdr->len = sizeof(struct stassoc_event);\r\npc2h_evt_hdr->ID = GEN_EVT_CODE(_AddSTA);\r\npc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\r\npadd_sta_evt = (struct stassoc_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\r\nmemcpy((unsigned char *)(&(padd_sta_evt->macaddr)), MacAddr, ETH_ALEN);\r\npadd_sta_evt->cam_id = cam_idx;\r\nDBG_88E("report_add_sta_event: add STA\n");\r\nrtw_enqueue_cmd(pcmdpriv, pcmd_obj);\r\n}\r\nvoid update_sta_info(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nVCS_update(padapter, psta);\r\nif (pmlmepriv->htpriv.ht_option) {\r\npsta->htpriv.ht_option = true;\r\npsta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;\r\nif (support_short_GI(padapter, &(pmlmeinfo->HT_caps)))\r\npsta->htpriv.sgi = true;\r\npsta->qos_option = true;\r\n} else {\r\npsta->htpriv.ht_option = false;\r\npsta->htpriv.ampdu_enable = false;\r\npsta->htpriv.sgi = false;\r\npsta->qos_option = false;\r\n}\r\npsta->htpriv.bwmode = pmlmeext->cur_bwmode;\r\npsta->htpriv.ch_offset = pmlmeext->cur_ch_offset;\r\npsta->htpriv.agg_enable_bitmap = 0x0;\r\npsta->htpriv.candidate_tid_bitmap = 0x0;\r\nif (pmlmepriv->qospriv.qos_option)\r\npsta->qos_option = true;\r\npsta->state = _FW_LINKED;\r\n}\r\nvoid mlmeext_joinbss_event_callback(struct adapter *padapter, int join_res)\r\n{\r\nstruct sta_info *psta, *psta_bmc;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nu8 join_type;\r\nu16 media_status;\r\nif (join_res < 0) {\r\njoin_type = 1;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);\r\nupdate_tx_basic_rate(padapter, padapter->registrypriv.wireless_mode);\r\ngoto exit_mlmeext_joinbss_event_callback;\r\n}\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {\r\npsta_bmc = rtw_get_bcmc_stainfo(padapter);\r\nif (psta_bmc) {\r\npmlmeinfo->FW_sta_info[psta_bmc->mac_id].psta = psta_bmc;\r\nupdate_bmc_sta_support_rate(padapter, psta_bmc->mac_id);\r\nUpdate_RA_Entry(padapter, psta_bmc->mac_id);\r\n}\r\n}\r\nSwitch_DM_Func(padapter, DYNAMIC_ALL_FUNC_ENABLE, true);\r\nupdate_IOT_info(padapter);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BASIC_RATE, cur_network->SupportedRates);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BEACON_INTERVAL, (u8 *)(&pmlmeinfo->bcn_interval));\r\nupdate_capinfo(padapter, pmlmeinfo->capability);\r\nWMMOnAssocRsp(padapter);\r\nHTOnAssocRsp(padapter);\r\nset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\r\npsta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);\r\nif (psta) {\r\npmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;\r\npsta->wireless_mode = pmlmeext->cur_wireless_mode;\r\nset_sta_rate(padapter, psta);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_TX_RPT_MAX_MACID, (u8 *)&psta->mac_id);\r\nmedia_status = (psta->mac_id<<8)|1;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_H2C_MEDIA_STATUS_RPT, (u8 *)&media_status);\r\n}\r\njoin_type = 2;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) {\r\ncorrect_TSF(padapter, pmlmeext);\r\n}\r\nrtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_CONNECT, 0);\r\nexit_mlmeext_joinbss_event_callback:\r\nDBG_88E("=>%s\n", __func__);\r\n}\r\nvoid mlmeext_sta_add_event_callback(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 join_type;\r\nDBG_88E("%s\n", __func__);\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {\r\nif (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) {\r\n} else {\r\ncorrect_TSF(padapter, pmlmeext);\r\nif (send_beacon(padapter) == _FAIL) {\r\npmlmeinfo->FW_sta_info[psta->mac_id].status = 0;\r\npmlmeinfo->state ^= WIFI_FW_ADHOC_STATE;\r\nreturn;\r\n}\r\npmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;\r\n}\r\njoin_type = 2;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));\r\n}\r\npmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;\r\nUpdate_RA_Entry(padapter, psta->mac_id);\r\nupdate_sta_info(padapter, psta);\r\n}\r\nvoid mlmeext_sta_del_event_callback(struct adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif (is_client_associated_to_ap(padapter) || is_IBSS_empty(padapter)) {\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, NULL);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);\r\nupdate_tx_basic_rate(padapter, padapter->registrypriv.wireless_mode);\r\npmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\r\nflush_all_cam_entry(padapter);\r\npmlmeinfo->state = WIFI_FW_NULL_STATE;\r\nSet_MSR(padapter, _HW_STATE_STATION_);\r\ndel_timer_sync(&pmlmeext->link_timer);\r\n}\r\n}\r\nvoid _linked_rx_signal_strehgth_display(struct adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 mac_id;\r\nint UndecoratedSmoothedPWDB;\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)\r\nmac_id = 0;\r\nelse if ((pmlmeinfo->state&0x03) == _HW_STATE_AP_)\r\nmac_id = 2;\r\nrtw_hal_get_def_var(padapter, HW_DEF_RA_INFO_DUMP, &mac_id);\r\nrtw_hal_get_def_var(padapter, HAL_DEF_UNDERCORATEDSMOOTHEDPWDB, &UndecoratedSmoothedPWDB);\r\nDBG_88E("UndecoratedSmoothedPWDB:%d\n", UndecoratedSmoothedPWDB);\r\n}\r\nstatic u8 chk_ap_is_alive(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nu8 ret = false;\r\nif ((sta_rx_data_pkts(psta) == sta_last_rx_data_pkts(psta)) &&\r\nsta_rx_beacon_pkts(psta) == sta_last_rx_beacon_pkts(psta) &&\r\nsta_rx_probersp_pkts(psta) == sta_last_rx_probersp_pkts(psta))\r\nret = false;\r\nelse\r\nret = true;\r\nsta_update_last_rx_pkts(psta);\r\nreturn ret;\r\n}\r\nvoid linked_status_chk(struct adapter *padapter)\r\n{\r\nu32 i;\r\nstruct sta_info *psta;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nif (padapter->bRxRSSIDisplay)\r\n_linked_rx_signal_strehgth_display(padapter);\r\nif (is_client_associated_to_ap(padapter)) {\r\nint tx_chk = _SUCCESS, rx_chk = _SUCCESS;\r\nint rx_chk_limit;\r\nrx_chk_limit = 4;\r\npsta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);\r\nif (psta != NULL) {\r\nbool is_p2p_enable = false;\r\nif (!chk_ap_is_alive(padapter, psta))\r\nrx_chk = _FAIL;\r\nif (pxmitpriv->last_tx_pkts == pxmitpriv->tx_pkts)\r\ntx_chk = _FAIL;\r\nif (pmlmeext->active_keep_alive_check && (rx_chk == _FAIL || tx_chk == _FAIL)) {\r\nu8 backup_oper_channel = 0;\r\nif (rtw_get_oper_ch(padapter) != pmlmeext->cur_channel) {\r\nbackup_oper_channel = rtw_get_oper_ch(padapter);\r\nSelectChannel(padapter, pmlmeext->cur_channel);\r\n}\r\nif (rx_chk != _SUCCESS)\r\nissue_probereq_ex(padapter, &pmlmeinfo->network.Ssid, psta->hwaddr, 3, 1);\r\nif ((tx_chk != _SUCCESS && pmlmeinfo->link_count++ == 0xf) || rx_chk != _SUCCESS) {\r\ntx_chk = issue_nulldata(padapter, psta->hwaddr, 0, 3, 1);\r\nif (tx_chk == _SUCCESS && !is_p2p_enable)\r\nrx_chk = _SUCCESS;\r\n}\r\nif (backup_oper_channel > 0)\r\nSelectChannel(padapter, backup_oper_channel);\r\n} else {\r\nif (rx_chk != _SUCCESS) {\r\nif (pmlmeext->retry == 0) {\r\nissue_probereq(padapter,\r\n&pmlmeinfo->network.Ssid,\r\npmlmeinfo->network.MacAddress,\r\nfalse);\r\nissue_probereq(padapter,\r\n&pmlmeinfo->network.Ssid,\r\npmlmeinfo->network.MacAddress,\r\nfalse);\r\nissue_probereq(padapter,\r\n&pmlmeinfo->network.Ssid,\r\npmlmeinfo->network.MacAddress,\r\nfalse);\r\n}\r\n}\r\nif (tx_chk != _SUCCESS && pmlmeinfo->link_count++ == 0xf) {\r\ntx_chk = issue_nulldata(padapter, NULL, 0, 1, 0);\r\n}\r\n}\r\nif (rx_chk == _FAIL) {\r\npmlmeext->retry++;\r\nif (pmlmeext->retry > rx_chk_limit) {\r\nDBG_88E_LEVEL(_drv_always_, FUNC_ADPT_FMT" disconnect or roaming\n",\r\nFUNC_ADPT_ARG(padapter));\r\nreceive_disconnect(padapter, pmlmeinfo->network.MacAddress,\r\nWLAN_REASON_EXPIRATION_CHK);\r\nreturn;\r\n}\r\n} else {\r\npmlmeext->retry = 0;\r\n}\r\nif (tx_chk == _FAIL) {\r\npmlmeinfo->link_count &= 0xf;\r\n} else {\r\npxmitpriv->last_tx_pkts = pxmitpriv->tx_pkts;\r\npmlmeinfo->link_count = 0;\r\n}\r\n}\r\n} else if (is_client_associated_to_ibss(padapter)) {\r\nfor (i = IBSS_START_MAC_ID; i < NUM_STA; i++) {\r\nif (pmlmeinfo->FW_sta_info[i].status == 1) {\r\npsta = pmlmeinfo->FW_sta_info[i].psta;\r\nif (NULL == psta)\r\ncontinue;\r\nif (pmlmeinfo->FW_sta_info[i].rx_pkt == sta_rx_pkts(psta)) {\r\nif (pmlmeinfo->FW_sta_info[i].retry < 3) {\r\npmlmeinfo->FW_sta_info[i].retry++;\r\n} else {\r\npmlmeinfo->FW_sta_info[i].retry = 0;\r\npmlmeinfo->FW_sta_info[i].status = 0;\r\nreport_del_sta_event(padapter, psta->hwaddr\r\n, 65535\r\n);\r\n}\r\n} else {\r\npmlmeinfo->FW_sta_info[i].retry = 0;\r\npmlmeinfo->FW_sta_info[i].rx_pkt = (u32)sta_rx_pkts(psta);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nvoid survey_timer_hdl(unsigned long data)\r\n{\r\nstruct adapter *padapter = (struct adapter *)data;\r\nstruct cmd_obj *ph2c;\r\nstruct sitesurvey_parm *psurveyPara;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (pmlmeext->sitesurvey_res.state > SCAN_START) {\r\nif (pmlmeext->sitesurvey_res.state == SCAN_PROCESS)\r\npmlmeext->sitesurvey_res.channel_idx++;\r\nif (pmlmeext->scan_abort) {\r\npmlmeext->sitesurvey_res.channel_idx = pmlmeext->sitesurvey_res.ch_num;\r\nDBG_88E("%s idx:%d\n", __func__\r\n, pmlmeext->sitesurvey_res.channel_idx);\r\npmlmeext->scan_abort = false;\r\n}\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);\r\nif (!ph2c)\r\ngoto exit_survey_timer_hdl;\r\npsurveyPara = kzalloc(sizeof(struct sitesurvey_parm), GFP_ATOMIC);\r\nif (!psurveyPara) {\r\nkfree(ph2c);\r\ngoto exit_survey_timer_hdl;\r\n}\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SiteSurvey));\r\nrtw_enqueue_cmd(pcmdpriv, ph2c);\r\n}\r\nexit_survey_timer_hdl:\r\nreturn;\r\n}\r\nvoid link_timer_hdl(unsigned long data)\r\n{\r\nstruct adapter *padapter = (struct adapter *)data;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif (pmlmeinfo->state & WIFI_FW_AUTH_NULL) {\r\nDBG_88E("link_timer_hdl:no beacon while connecting\n");\r\npmlmeinfo->state = WIFI_FW_NULL_STATE;\r\nreport_join_res(padapter, -3);\r\n} else if (pmlmeinfo->state & WIFI_FW_AUTH_STATE) {\r\nif (++pmlmeinfo->reauth_count > REAUTH_LIMIT) {\r\npmlmeinfo->state = 0;\r\nreport_join_res(padapter, -1);\r\nreturn;\r\n}\r\nDBG_88E("link_timer_hdl: auth timeout and try again\n");\r\npmlmeinfo->auth_seq = 1;\r\nissue_auth(padapter, NULL, 0);\r\nset_link_timer(pmlmeext, REAUTH_TO);\r\n} else if (pmlmeinfo->state & WIFI_FW_ASSOC_STATE) {\r\nif (++pmlmeinfo->reassoc_count > REASSOC_LIMIT) {\r\npmlmeinfo->state = WIFI_FW_NULL_STATE;\r\nreport_join_res(padapter, -2);\r\nreturn;\r\n}\r\nDBG_88E("link_timer_hdl: assoc timeout and try again\n");\r\nissue_assocreq(padapter);\r\nset_link_timer(pmlmeext, REASSOC_TO);\r\n}\r\n}\r\nvoid addba_timer_hdl(unsigned long data)\r\n{\r\nstruct sta_info *psta = (struct sta_info *)data;\r\nstruct ht_priv *phtpriv;\r\nif (!psta)\r\nreturn;\r\nphtpriv = &psta->htpriv;\r\nif ((phtpriv->ht_option) && (phtpriv->ampdu_enable)) {\r\nif (phtpriv->candidate_tid_bitmap)\r\nphtpriv->candidate_tid_bitmap = 0x0;\r\n}\r\n}\r\nu8 setopmode_hdl(struct adapter *padapter, u8 *pbuf)\r\n{\r\nu8 type;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct setopmode_parm *psetop = (struct setopmode_parm *)pbuf;\r\nif (psetop->mode == Ndis802_11APMode) {\r\npmlmeinfo->state = WIFI_FW_AP_STATE;\r\ntype = _HW_STATE_AP_;\r\n} else if (psetop->mode == Ndis802_11Infrastructure) {\r\npmlmeinfo->state &= ~(BIT(0)|BIT(1));\r\npmlmeinfo->state |= WIFI_FW_STATION_STATE;\r\ntype = _HW_STATE_STATION_;\r\n} else if (psetop->mode == Ndis802_11IBSS) {\r\ntype = _HW_STATE_ADHOC_;\r\n} else {\r\ntype = _HW_STATE_NOLINK_;\r\n}\r\nrtw_hal_set_hwreg(padapter, HW_VAR_SET_OPMODE, (u8 *)(&type));\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 createbss_hdl(struct adapter *padapter, u8 *pbuf)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\r\nstruct wlan_bssid_ex *pparm = (struct wlan_bssid_ex *)pbuf;\r\nif (pparm->InfrastructureMode == Ndis802_11APMode) {\r\n#ifdef CONFIG_88EU_AP_MODE\r\nif (pmlmeinfo->state == WIFI_FW_AP_STATE) {\r\nreturn H2C_SUCCESS;\r\n}\r\n#endif\r\n}\r\nif (pparm->InfrastructureMode == Ndis802_11IBSS) {\r\nrtw_joinbss_reset(padapter);\r\npmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\npmlmeinfo->ERP_enable = 0;\r\npmlmeinfo->WMM_enable = 0;\r\npmlmeinfo->HT_enable = 0;\r\npmlmeinfo->HT_caps_enable = 0;\r\npmlmeinfo->HT_info_enable = 0;\r\npmlmeinfo->agg_enable_bitmap = 0;\r\npmlmeinfo->candidate_tid_bitmap = 0;\r\nSave_DM_Func_Flag(padapter);\r\nSwitch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false);\r\ndel_timer_sync(&pmlmeext->link_timer);\r\nflush_all_cam_entry(padapter);\r\nmemcpy(pnetwork, pbuf, offsetof(struct wlan_bssid_ex, IELength));\r\npnetwork->IELength = ((struct wlan_bssid_ex *)pbuf)->IELength;\r\nif (pnetwork->IELength > MAX_IE_SZ)\r\nreturn H2C_PARAMETERS_ERROR;\r\nmemcpy(pnetwork->IEs, ((struct wlan_bssid_ex *)pbuf)->IEs, pnetwork->IELength);\r\nstart_create_ibss(padapter);\r\n}\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 join_cmd_hdl(struct adapter *padapter, u8 *pbuf)\r\n{\r\nu8 join_type;\r\nstruct ndis_802_11_var_ie *pIE;\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\r\nstruct wlan_bssid_ex *pparm = (struct wlan_bssid_ex *)pbuf;\r\nu32 i;\r\nif (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) {\r\nif (pmlmeinfo->state & WIFI_FW_STATION_STATE)\r\nissue_deauth_ex(padapter, pnetwork->MacAddress, WLAN_REASON_DEAUTH_LEAVING, 5, 100);\r\npmlmeinfo->state = WIFI_FW_NULL_STATE;\r\nflush_all_cam_entry(padapter);\r\ndel_timer_sync(&pmlmeext->link_timer);\r\nSet_MSR(padapter, _HW_STATE_STATION_);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, NULL);\r\n}\r\nrtw_antenna_select_cmd(padapter, pparm->PhyInfo.Optimum_antenna, false);\r\nrtw_joinbss_reset(padapter);\r\npmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\npmlmeinfo->ERP_enable = 0;\r\npmlmeinfo->WMM_enable = 0;\r\npmlmeinfo->HT_enable = 0;\r\npmlmeinfo->HT_caps_enable = 0;\r\npmlmeinfo->HT_info_enable = 0;\r\npmlmeinfo->agg_enable_bitmap = 0;\r\npmlmeinfo->candidate_tid_bitmap = 0;\r\npmlmeinfo->bwmode_updated = false;\r\nmemcpy(pnetwork, pbuf, offsetof(struct wlan_bssid_ex, IELength));\r\npnetwork->IELength = ((struct wlan_bssid_ex *)pbuf)->IELength;\r\nif (pnetwork->IELength > MAX_IE_SZ)\r\nreturn H2C_PARAMETERS_ERROR;\r\nmemcpy(pnetwork->IEs, ((struct wlan_bssid_ex *)pbuf)->IEs, pnetwork->IELength);\r\nfor (i = sizeof(struct ndis_802_11_fixed_ie); i < pnetwork->IELength;) {\r\npIE = (struct ndis_802_11_var_ie *)(pnetwork->IEs + i);\r\nswitch (pIE->ElementID) {\r\ncase _VENDOR_SPECIFIC_IE_:\r\nif (!memcmp(pIE->data, WMM_OUI, 4))\r\npmlmeinfo->WMM_enable = 1;\r\nbreak;\r\ncase _HT_CAPABILITY_IE_:\r\npmlmeinfo->HT_caps_enable = 1;\r\nbreak;\r\ncase _HT_EXTRA_INFO_IE_:\r\npmlmeinfo->HT_info_enable = 1;\r\n{\r\nstruct HT_info_element *pht_info = (struct HT_info_element *)(pIE->data);\r\nif ((pregpriv->cbw40_enable) && (pht_info->infos[0] & BIT(2))) {\r\npmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;\r\nswitch (pht_info->infos[0] & 0x3) {\r\ncase 1:\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nbreak;\r\ncase 3:\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nbreak;\r\ndefault:\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nbreak;\r\n}\r\nDBG_88E("set ch/bw before connected\n");\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ni += (pIE->Length + 2);\r\n}\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BSSID, pmlmeinfo->network.MacAddress);\r\njoin_type = 0;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));\r\ndel_timer_sync(&pmlmeext->link_timer);\r\nstart_clnt_join(padapter);\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 disconnect_hdl(struct adapter *padapter, unsigned char *pbuf)\r\n{\r\nstruct disconnect_parm *param = (struct disconnect_parm *)pbuf;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\r\nu8 val8;\r\nif (is_client_associated_to_ap(padapter))\r\nissue_deauth_ex(padapter, pnetwork->MacAddress, WLAN_REASON_DEAUTH_LEAVING, param->deauth_timeout_ms/100, 100);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, NULL);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);\r\nupdate_tx_basic_rate(padapter, padapter->registrypriv.wireless_mode);\r\nif (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)) {\r\nval8 = 0;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BCN_FUNC, (u8 *)(&val8));\r\n}\r\nSet_MSR(padapter, _HW_STATE_STATION_);\r\npmlmeinfo->state = WIFI_FW_NULL_STATE;\r\npmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\r\nflush_all_cam_entry(padapter);\r\ndel_timer_sync(&pmlmeext->link_timer);\r\nrtw_free_uc_swdec_pending_queue(padapter);\r\nreturn H2C_SUCCESS;\r\n}\r\nstatic int rtw_scan_ch_decision(struct adapter *padapter, struct rtw_ieee80211_channel *out,\r\nu32 out_num, struct rtw_ieee80211_channel *in, u32 in_num)\r\n{\r\nint i, j;\r\nint set_idx;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nmemset(out, 0, sizeof(struct rtw_ieee80211_channel)*out_num);\r\nj = 0;\r\nfor (i = 0; i < in_num; i++) {\r\nset_idx = rtw_ch_set_search_ch(pmlmeext->channel_set, in[i].hw_value);\r\nif (in[i].hw_value && !(in[i].flags & RTW_IEEE80211_CHAN_DISABLED) &&\r\nset_idx >= 0) {\r\nout[j] = in[i];\r\nif (pmlmeext->channel_set[set_idx].ScanType == SCAN_PASSIVE)\r\nout[j].flags &= RTW_IEEE80211_CHAN_PASSIVE_SCAN;\r\nj++;\r\n}\r\nif (j >= out_num)\r\nbreak;\r\n}\r\nif (j == 0) {\r\nfor (i = 0; i < pmlmeext->max_chan_nums; i++) {\r\nout[i].hw_value = pmlmeext->channel_set[i].ChannelNum;\r\nif (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)\r\nout[i].flags &= RTW_IEEE80211_CHAN_PASSIVE_SCAN;\r\nj++;\r\n}\r\n}\r\nreturn j;\r\n}\r\nu8 sitesurvey_cmd_hdl(struct adapter *padapter, u8 *pbuf)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct sitesurvey_parm *pparm = (struct sitesurvey_parm *)pbuf;\r\nu8 bdelayscan = false;\r\nu8 val8;\r\nu32 initialgain;\r\nu32 i;\r\nif (pmlmeext->sitesurvey_res.state == SCAN_DISABLE) {\r\nrtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, NULL);\r\npmlmeext->sitesurvey_res.state = SCAN_START;\r\npmlmeext->sitesurvey_res.bss_cnt = 0;\r\npmlmeext->sitesurvey_res.channel_idx = 0;\r\nfor (i = 0; i < RTW_SSID_SCAN_AMOUNT; i++) {\r\nif (pparm->ssid[i].SsidLength) {\r\nmemcpy(pmlmeext->sitesurvey_res.ssid[i].Ssid, pparm->ssid[i].Ssid, IW_ESSID_MAX_SIZE);\r\npmlmeext->sitesurvey_res.ssid[i].SsidLength = pparm->ssid[i].SsidLength;\r\n} else {\r\npmlmeext->sitesurvey_res.ssid[i].SsidLength = 0;\r\n}\r\n}\r\npmlmeext->sitesurvey_res.ch_num = rtw_scan_ch_decision(padapter\r\n, pmlmeext->sitesurvey_res.ch, RTW_CHANNEL_SCAN_AMOUNT\r\n, pparm->ch, pparm->ch_num\r\n);\r\npmlmeext->sitesurvey_res.scan_mode = pparm->scan_mode;\r\nif (is_client_associated_to_ap(padapter)) {\r\npmlmeext->sitesurvey_res.state = SCAN_TXNULL;\r\nissue_nulldata(padapter, NULL, 1, 3, 500);\r\nbdelayscan = true;\r\n}\r\nif (bdelayscan) {\r\nset_survey_timer(pmlmeext, 50);\r\nreturn H2C_SUCCESS;\r\n}\r\n}\r\nif ((pmlmeext->sitesurvey_res.state == SCAN_START) || (pmlmeext->sitesurvey_res.state == SCAN_TXNULL)) {\r\nSave_DM_Func_Flag(padapter);\r\nSwitch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false);\r\ninitialgain = 0x1E;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));\r\nSet_MSR(padapter, _HW_STATE_NOLINK_);\r\nval8 = 1;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));\r\npmlmeext->sitesurvey_res.state = SCAN_PROCESS;\r\n}\r\nsite_survey(padapter);\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 setauth_hdl(struct adapter *padapter, unsigned char *pbuf)\r\n{\r\nstruct setauth_parm *pparm = (struct setauth_parm *)pbuf;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif (pparm->mode < 4)\r\npmlmeinfo->auth_algo = pparm->mode;\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 setkey_hdl(struct adapter *padapter, u8 *pbuf)\r\n{\r\nunsigned short ctrl;\r\nstruct setkey_parm *pparm = (struct setkey_parm *)pbuf;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nunsigned char null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\r\nif (pparm->set_tx)\r\npmlmeinfo->key_index = pparm->keyid;\r\nctrl = BIT(15) | ((pparm->algorithm) << 2) | pparm->keyid;\r\nDBG_88E_LEVEL(_drv_info_, "set group key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) "\r\n"keyid:%d\n", pparm->algorithm, pparm->keyid);\r\nwrite_cam(padapter, pparm->keyid, ctrl, null_sta, pparm->key);\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 set_stakey_hdl(struct adapter *padapter, u8 *pbuf)\r\n{\r\nu16 ctrl = 0;\r\nu8 cam_id;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct set_stakey_parm *pparm = (struct set_stakey_parm *)pbuf;\r\ncam_id = 4;\r\nDBG_88E_LEVEL(_drv_info_, "set pairwise key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) camid:%d\n",\r\npparm->algorithm, cam_id);\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nif (pparm->algorithm == _NO_PRIVACY_) {\r\nclear_cam_entry(padapter, pparm->id);\r\nreturn H2C_SUCCESS_RSP;\r\n}\r\npsta = rtw_get_stainfo(pstapriv, pparm->addr);\r\nif (psta) {\r\nctrl = BIT(15) | ((pparm->algorithm) << 2);\r\nDBG_88E("r871x_set_stakey_hdl(): enc_algorithm=%d\n", pparm->algorithm);\r\nif ((psta->mac_id < 1) || (psta->mac_id > (NUM_STA-4))) {\r\nDBG_88E("r871x_set_stakey_hdl():set_stakey failed, mac_id(aid)=%d\n", psta->mac_id);\r\nreturn H2C_REJECTED;\r\n}\r\ncam_id = psta->mac_id + 3;\r\nDBG_88E("Write CAM, mac_addr =%pM, cam_entry=%d\n",\r\npparm->addr, cam_id);\r\nwrite_cam(padapter, cam_id, ctrl, pparm->addr, pparm->key);\r\nreturn H2C_SUCCESS_RSP;\r\n} else {\r\nDBG_88E("r871x_set_stakey_hdl(): sta has been free\n");\r\nreturn H2C_REJECTED;\r\n}\r\n}\r\nif (pparm->algorithm == _NO_PRIVACY_) {\r\nclear_cam_entry(padapter, pparm->id);\r\nreturn H2C_SUCCESS;\r\n}\r\nctrl = BIT(15) | ((pparm->algorithm) << 2);\r\nwrite_cam(padapter, cam_id, ctrl, pparm->addr, pparm->key);\r\npmlmeinfo->enc_algo = pparm->algorithm;\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 add_ba_hdl(struct adapter *padapter, unsigned char *pbuf)\r\n{\r\nstruct addBaReq_parm *pparm = (struct addBaReq_parm *)pbuf;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, pparm->addr);\r\nif (!psta)\r\nreturn H2C_SUCCESS;\r\nif (((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && (pmlmeinfo->HT_enable)) ||\r\n((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)) {\r\nissue_action_BA(padapter, pparm->addr, RTW_WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);\r\nmod_timer(&psta->addba_retry_timer,\r\njiffies + msecs_to_jiffies(ADDBA_TO));\r\n} else {\r\npsta->htpriv.candidate_tid_bitmap &= ~BIT(pparm->tid);\r\n}\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 set_tx_beacon_cmd(struct adapter *padapter)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct wlan_bssid_ex *ptxBeacon_parm;\r\nstruct cmd_priv *pcmdpriv = &(padapter->cmdpriv);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 res = _SUCCESS;\r\nint len_diff = 0;\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (!ph2c) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nptxBeacon_parm = kmemdup(&(pmlmeinfo->network),\r\nsizeof(struct wlan_bssid_ex), GFP_KERNEL);\r\nif (ptxBeacon_parm == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nlen_diff = update_hidden_ssid(ptxBeacon_parm->IEs+_BEACON_IE_OFFSET_,\r\nptxBeacon_parm->IELength-_BEACON_IE_OFFSET_,\r\npmlmeinfo->hidden_ssid_mode);\r\nptxBeacon_parm->IELength += len_diff;\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, ptxBeacon_parm, GEN_CMD_CODE(_TX_Beacon));\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\nexit:\r\nreturn res;\r\n}\r\nu8 mlme_evt_hdl(struct adapter *padapter, unsigned char *pbuf)\r\n{\r\nu8 evt_code;\r\nu16 evt_sz;\r\nuint *peventbuf;\r\nvoid (*event_callback)(struct adapter *dev, u8 *pbuf);\r\npeventbuf = (uint *)pbuf;\r\nevt_sz = (u16)(*peventbuf&0xffff);\r\nevt_code = (u8)((*peventbuf>>16)&0xff);\r\nif (evt_code >= MAX_C2HEVT) {\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nEvent Code(%d) mismatch!\n", evt_code));\r\ngoto _abort_event_;\r\n}\r\nif ((wlanevents[evt_code].parmsize != 0) &&\r\n(wlanevents[evt_code].parmsize != evt_sz)) {\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,\r\n("\nEvent(%d) Parm Size mismatch (%d vs %d)!\n",\r\nevt_code, wlanevents[evt_code].parmsize, evt_sz));\r\ngoto _abort_event_;\r\n}\r\npeventbuf += 2;\r\nif (peventbuf) {\r\nevent_callback = wlanevents[evt_code].event_callback;\r\nevent_callback(padapter, (u8 *)peventbuf);\r\n}\r\n_abort_event_:\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 tx_beacon_hdl(struct adapter *padapter, unsigned char *pbuf)\r\n{\r\nif (send_beacon(padapter) == _FAIL) {\r\nDBG_88E("issue_beacon, fail!\n");\r\nreturn H2C_PARAMETERS_ERROR;\r\n}\r\n#ifdef CONFIG_88EU_AP_MODE\r\nelse {\r\nstruct sta_info *psta_bmc;\r\nstruct list_head *xmitframe_plist, *xmitframe_phead;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\npsta_bmc = rtw_get_bcmc_stainfo(padapter);\r\nif (!psta_bmc)\r\nreturn H2C_SUCCESS;\r\nif ((pstapriv->tim_bitmap&BIT(0)) && (psta_bmc->sleepq_len > 0)) {\r\nmsleep(10);\r\nspin_lock_bh(&psta_bmc->sleep_q.lock);\r\nxmitframe_phead = get_list_head(&psta_bmc->sleep_q);\r\nxmitframe_plist = xmitframe_phead->next;\r\nwhile (xmitframe_phead != xmitframe_plist) {\r\npxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);\r\nxmitframe_plist = xmitframe_plist->next;\r\nlist_del_init(&pxmitframe->list);\r\npsta_bmc->sleepq_len--;\r\nif (psta_bmc->sleepq_len > 0)\r\npxmitframe->attrib.mdata = 1;\r\nelse\r\npxmitframe->attrib.mdata = 0;\r\npxmitframe->attrib.triggered = 1;\r\npxmitframe->attrib.qsel = 0x11;\r\nspin_unlock_bh(&psta_bmc->sleep_q.lock);\r\nif (rtw_hal_xmit(padapter, pxmitframe))\r\nrtw_os_xmit_complete(padapter, pxmitframe);\r\nspin_lock_bh(&psta_bmc->sleep_q.lock);\r\n}\r\nspin_unlock_bh(&psta_bmc->sleep_q.lock);\r\n}\r\n}\r\n#endif\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 set_ch_hdl(struct adapter *padapter, u8 *pbuf)\r\n{\r\nstruct set_ch_parm *set_ch_parm;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (!pbuf)\r\nreturn H2C_PARAMETERS_ERROR;\r\nset_ch_parm = (struct set_ch_parm *)pbuf;\r\nDBG_88E(FUNC_NDEV_FMT" ch:%u, bw:%u, ch_offset:%u\n",\r\nFUNC_NDEV_ARG(padapter->pnetdev),\r\nset_ch_parm->ch, set_ch_parm->bw, set_ch_parm->ch_offset);\r\npmlmeext->cur_channel = set_ch_parm->ch;\r\npmlmeext->cur_ch_offset = set_ch_parm->ch_offset;\r\npmlmeext->cur_bwmode = set_ch_parm->bw;\r\nset_channel_bwmode(padapter, set_ch_parm->ch, set_ch_parm->ch_offset, set_ch_parm->bw);\r\nreturn H2C_SUCCESS;\r\n}\r\nu8 set_chplan_hdl(struct adapter *padapter, unsigned char *pbuf)\r\n{\r\nstruct SetChannelPlan_param *setChannelPlan_param;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (!pbuf)\r\nreturn H2C_PARAMETERS_ERROR;\r\nsetChannelPlan_param = (struct SetChannelPlan_param *)pbuf;\r\npmlmeext->max_chan_nums = init_channel_set(padapter, setChannelPlan_param->channel_plan, pmlmeext->channel_set);\r\ninit_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);\r\nreturn H2C_SUCCESS;\r\n}
