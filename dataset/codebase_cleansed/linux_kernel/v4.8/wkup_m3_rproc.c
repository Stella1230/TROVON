static int wkup_m3_rproc_start(struct rproc *rproc)\r\n{\r\nstruct wkup_m3_rproc *wkupm3 = rproc->priv;\r\nstruct platform_device *pdev = wkupm3->pdev;\r\nstruct device *dev = &pdev->dev;\r\nstruct wkup_m3_platform_data *pdata = dev_get_platdata(dev);\r\nif (pdata->deassert_reset(pdev, pdata->reset_name)) {\r\ndev_err(dev, "Unable to reset wkup_m3!\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wkup_m3_rproc_stop(struct rproc *rproc)\r\n{\r\nstruct wkup_m3_rproc *wkupm3 = rproc->priv;\r\nstruct platform_device *pdev = wkupm3->pdev;\r\nstruct device *dev = &pdev->dev;\r\nstruct wkup_m3_platform_data *pdata = dev_get_platdata(dev);\r\nif (pdata->assert_reset(pdev, pdata->reset_name)) {\r\ndev_err(dev, "Unable to assert reset of wkup_m3!\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *wkup_m3_rproc_da_to_va(struct rproc *rproc, u64 da, int len)\r\n{\r\nstruct wkup_m3_rproc *wkupm3 = rproc->priv;\r\nvoid *va = NULL;\r\nint i;\r\nu32 offset;\r\nif (len <= 0)\r\nreturn NULL;\r\nfor (i = 0; i < WKUPM3_MEM_MAX; i++) {\r\nif (da >= wkupm3->mem[i].dev_addr && da + len <=\r\nwkupm3->mem[i].dev_addr + wkupm3->mem[i].size) {\r\noffset = da - wkupm3->mem[i].dev_addr;\r\nva = (__force void *)(wkupm3->mem[i].cpu_addr + offset);\r\nbreak;\r\n}\r\n}\r\nreturn va;\r\n}\r\nstatic int wkup_m3_rproc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct wkup_m3_platform_data *pdata = dev->platform_data;\r\nconst char *mem_names[WKUPM3_MEM_MAX] = { "umem", "dmem" };\r\nstruct wkup_m3_rproc *wkupm3;\r\nconst char *fw_name;\r\nstruct rproc *rproc;\r\nstruct resource *res;\r\nconst __be32 *addrp;\r\nu32 l4_offset = 0;\r\nu64 size;\r\nint ret;\r\nint i;\r\nif (!(pdata && pdata->deassert_reset && pdata->assert_reset &&\r\npdata->reset_name)) {\r\ndev_err(dev, "Platform data missing!\n");\r\nreturn -ENODEV;\r\n}\r\nret = of_property_read_string(dev->of_node, "ti,pm-firmware",\r\n&fw_name);\r\nif (ret) {\r\ndev_err(dev, "No firmware filename given\n");\r\nreturn -ENODEV;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "pm_runtime_get_sync() failed\n");\r\ngoto err;\r\n}\r\nrproc = rproc_alloc(dev, "wkup_m3", &wkup_m3_rproc_ops,\r\nfw_name, sizeof(*wkupm3));\r\nif (!rproc) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nwkupm3 = rproc->priv;\r\nwkupm3->rproc = rproc;\r\nwkupm3->pdev = pdev;\r\nfor (i = 0; i < ARRAY_SIZE(mem_names); i++) {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\nmem_names[i]);\r\nwkupm3->mem[i].cpu_addr = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(wkupm3->mem[i].cpu_addr)) {\r\ndev_err(&pdev->dev, "devm_ioremap_resource failed for resource %d\n",\r\ni);\r\nret = PTR_ERR(wkupm3->mem[i].cpu_addr);\r\ngoto err;\r\n}\r\nwkupm3->mem[i].bus_addr = res->start;\r\nwkupm3->mem[i].size = resource_size(res);\r\naddrp = of_get_address(dev->of_node, i, &size, NULL);\r\nif (!strcmp(mem_names[i], "umem"))\r\nl4_offset = be32_to_cpu(*addrp);\r\nwkupm3->mem[i].dev_addr = be32_to_cpu(*addrp) - l4_offset;\r\n}\r\ndev_set_drvdata(dev, rproc);\r\nret = rproc_add(rproc);\r\nif (ret) {\r\ndev_err(dev, "rproc_add failed\n");\r\ngoto err_put_rproc;\r\n}\r\nreturn 0;\r\nerr_put_rproc:\r\nrproc_put(rproc);\r\nerr:\r\npm_runtime_put_noidle(dev);\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int wkup_m3_rproc_remove(struct platform_device *pdev)\r\n{\r\nstruct rproc *rproc = platform_get_drvdata(pdev);\r\nrproc_del(rproc);\r\nrproc_put(rproc);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int wkup_m3_rpm_suspend(struct device *dev)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int wkup_m3_rpm_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}
