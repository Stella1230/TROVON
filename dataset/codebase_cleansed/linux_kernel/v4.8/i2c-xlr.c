static inline void xlr_i2c_wreg(u32 __iomem *base, unsigned int reg, u32 val)\r\n{\r\n__raw_writel(val, base + reg);\r\n}\r\nstatic inline u32 xlr_i2c_rdreg(u32 __iomem *base, unsigned int reg)\r\n{\r\nreturn __raw_readl(base + reg);\r\n}\r\nstatic int xlr_i2c_busy(struct xlr_i2c_private *priv, u32 status)\r\n{\r\nreturn (status & XLR_I2C_BUS_BUSY) == priv->cfg->status_busy;\r\n}\r\nstatic int xlr_i2c_idle(struct xlr_i2c_private *priv)\r\n{\r\nreturn !xlr_i2c_busy(priv, xlr_i2c_rdreg(priv->iobase, XLR_I2C_STATUS));\r\n}\r\nstatic int xlr_i2c_wait(struct xlr_i2c_private *priv, unsigned long timeout)\r\n{\r\nint status;\r\nint t;\r\nt = wait_event_timeout(priv->wait, xlr_i2c_idle(priv),\r\nmsecs_to_jiffies(timeout));\r\nif (!t)\r\nreturn -ETIMEDOUT;\r\nstatus = xlr_i2c_rdreg(priv->iobase, XLR_I2C_STATUS);\r\nreturn status & XLR_I2C_ACK_ERR ? -EIO : 0;\r\n}\r\nstatic void xlr_i2c_tx_irq(struct xlr_i2c_private *priv, u32 status)\r\n{\r\nstruct i2c_msg *msg = priv->msg;\r\nif (status & XLR_I2C_SDOEMPTY)\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_DATAOUT,\r\nmsg->buf[priv->pos++]);\r\n}\r\nstatic void xlr_i2c_rx_irq(struct xlr_i2c_private *priv, u32 status)\r\n{\r\nstruct i2c_msg *msg = priv->msg;\r\nif (status & XLR_I2C_RXRDY)\r\nmsg->buf[priv->pos++] =\r\nxlr_i2c_rdreg(priv->iobase, XLR_I2C_DATAIN);\r\n}\r\nstatic irqreturn_t xlr_i2c_irq(int irq, void *dev_id)\r\n{\r\nstruct xlr_i2c_private *priv = dev_id;\r\nstruct i2c_msg *msg = priv->msg;\r\nu32 int_stat, status;\r\nint_stat = xlr_i2c_rdreg(priv->iobase, XLR_I2C_INT_STAT);\r\nif (!int_stat)\r\nreturn IRQ_NONE;\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_INT_STAT, int_stat);\r\nif (!msg)\r\nreturn IRQ_HANDLED;\r\nstatus = xlr_i2c_rdreg(priv->iobase, XLR_I2C_STATUS);\r\nif (priv->pos < msg->len) {\r\nif (msg->flags & I2C_M_RD)\r\nxlr_i2c_rx_irq(priv, status);\r\nelse\r\nxlr_i2c_tx_irq(priv, status);\r\n}\r\nif (!xlr_i2c_busy(priv, status))\r\nwake_up(&priv->wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xlr_i2c_tx(struct xlr_i2c_private *priv, u16 len,\r\nu8 *buf, u16 addr)\r\n{\r\nstruct i2c_adapter *adap = &priv->adap;\r\nunsigned long timeout, stoptime, checktime;\r\nu32 i2c_status;\r\nint pos, timedout;\r\nu8 offset;\r\nu32 xfer;\r\nif (!len)\r\nreturn -EOPNOTSUPP;\r\noffset = buf[0];\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_ADDR, offset);\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_DEVADDR, addr);\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_CFG,\r\nXLR_I2C_CFG_ADDR | priv->cfg->cfg_extra);\r\ntimeout = msecs_to_jiffies(XLR_I2C_TIMEOUT);\r\nstoptime = jiffies + timeout;\r\ntimedout = 0;\r\nif (len == 1) {\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_BYTECNT, len - 1);\r\nxfer = XLR_I2C_STARTXFR_ND;\r\npos = 1;\r\n} else {\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_BYTECNT, len - 2);\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_DATAOUT, buf[1]);\r\nxfer = XLR_I2C_STARTXFR_WR;\r\npos = 2;\r\n}\r\npriv->pos = pos;\r\nretry:\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_STARTXFR, xfer);\r\nif (priv->irq > 0)\r\nreturn xlr_i2c_wait(priv, XLR_I2C_TIMEOUT * len);\r\nwhile (!timedout) {\r\nchecktime = jiffies;\r\ni2c_status = xlr_i2c_rdreg(priv->iobase, XLR_I2C_STATUS);\r\nif ((i2c_status & XLR_I2C_SDOEMPTY) && pos < len) {\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_DATAOUT, buf[pos++]);\r\nstoptime = jiffies + timeout;\r\n}\r\ntimedout = time_after(checktime, stoptime);\r\nif (i2c_status & XLR_I2C_ARB_STARTERR) {\r\nif (timedout)\r\nbreak;\r\ngoto retry;\r\n}\r\nif (i2c_status & XLR_I2C_ACK_ERR)\r\nreturn -EIO;\r\nif (!xlr_i2c_busy(priv, i2c_status) && pos >= len)\r\nreturn 0;\r\n}\r\ndev_err(&adap->dev, "I2C transmit timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int xlr_i2c_rx(struct xlr_i2c_private *priv, u16 len, u8 *buf, u16 addr)\r\n{\r\nstruct i2c_adapter *adap = &priv->adap;\r\nu32 i2c_status;\r\nunsigned long timeout, stoptime, checktime;\r\nint nbytes, timedout;\r\nif (!len)\r\nreturn -EOPNOTSUPP;\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_CFG,\r\nXLR_I2C_CFG_NOADDR | priv->cfg->cfg_extra);\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_BYTECNT, len - 1);\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_DEVADDR, addr);\r\npriv->pos = 0;\r\ntimeout = msecs_to_jiffies(XLR_I2C_TIMEOUT);\r\nstoptime = jiffies + timeout;\r\ntimedout = 0;\r\nnbytes = 0;\r\nretry:\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_STARTXFR, XLR_I2C_STARTXFR_RD);\r\nif (priv->irq > 0)\r\nreturn xlr_i2c_wait(priv, XLR_I2C_TIMEOUT * len);\r\nwhile (!timedout) {\r\nchecktime = jiffies;\r\ni2c_status = xlr_i2c_rdreg(priv->iobase, XLR_I2C_STATUS);\r\nif (i2c_status & XLR_I2C_RXRDY) {\r\nif (nbytes >= len)\r\nreturn -EIO;\r\nbuf[nbytes++] =\r\nxlr_i2c_rdreg(priv->iobase, XLR_I2C_DATAIN);\r\nstoptime = jiffies + timeout;\r\n}\r\ntimedout = time_after(checktime, stoptime);\r\nif (i2c_status & XLR_I2C_ARB_STARTERR) {\r\nif (timedout)\r\nbreak;\r\ngoto retry;\r\n}\r\nif (i2c_status & XLR_I2C_ACK_ERR)\r\nreturn -EIO;\r\nif (!xlr_i2c_busy(priv, i2c_status))\r\nreturn 0;\r\n}\r\ndev_err(&adap->dev, "I2C receive timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int xlr_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct i2c_msg *msg;\r\nint i;\r\nint ret = 0;\r\nstruct xlr_i2c_private *priv = i2c_get_adapdata(adap);\r\nret = clk_enable(priv->clk);\r\nif (ret)\r\nreturn ret;\r\nif (priv->irq)\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_INT_EN, 0xf);\r\nfor (i = 0; ret == 0 && i < num; i++) {\r\nmsg = &msgs[i];\r\npriv->msg = msg;\r\nif (msg->flags & I2C_M_RD)\r\nret = xlr_i2c_rx(priv, msg->len, &msg->buf[0],\r\nmsg->addr);\r\nelse\r\nret = xlr_i2c_tx(priv, msg->len, &msg->buf[0],\r\nmsg->addr);\r\n}\r\nif (priv->irq)\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_INT_EN, 0);\r\nclk_disable(priv->clk);\r\npriv->msg = NULL;\r\nreturn (ret != 0) ? ret : num;\r\n}\r\nstatic u32 xlr_func(struct i2c_adapter *adap)\r\n{\r\nreturn (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) | I2C_FUNC_I2C;\r\n}\r\nstatic int xlr_i2c_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct xlr_i2c_private *priv;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nunsigned long clk_rate;\r\nunsigned long clk_div;\r\nu32 busfreq;\r\nint irq;\r\nint ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmatch = of_match_device(xlr_i2c_dt_ids, &pdev->dev);\r\nif (match)\r\npriv->cfg = match->data;\r\nelse\r\npriv->cfg = &xlr_i2c_config_default;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->iobase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->iobase))\r\nreturn PTR_ERR(priv->iobase);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq > 0 && (priv->cfg->flags & XLR_I2C_FLAG_IRQ)) {\r\npriv->irq = irq;\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_INT_EN, 0);\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_INT_STAT, 0xf);\r\nret = devm_request_irq(&pdev->dev, priv->irq, xlr_i2c_irq,\r\nIRQF_SHARED, dev_name(&pdev->dev),\r\npriv);\r\nif (ret)\r\nreturn ret;\r\ninit_waitqueue_head(&priv->wait);\r\n}\r\nif (of_property_read_u32(pdev->dev.of_node, "clock-frequency",\r\n&busfreq))\r\nbusfreq = 100000;\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(clk)) {\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\nreturn ret;\r\nclk_rate = clk_get_rate(clk);\r\nclk_div = DIV_ROUND_UP(clk_rate, 2 * busfreq);\r\nxlr_i2c_wreg(priv->iobase, XLR_I2C_CLKDIV, clk_div);\r\nclk_disable(clk);\r\npriv->clk = clk;\r\n}\r\npriv->adap.dev.parent = &pdev->dev;\r\npriv->adap.dev.of_node = pdev->dev.of_node;\r\npriv->adap.owner = THIS_MODULE;\r\npriv->adap.algo_data = priv;\r\npriv->adap.algo = &xlr_i2c_algo;\r\npriv->adap.nr = pdev->id;\r\npriv->adap.class = I2C_CLASS_HWMON;\r\nsnprintf(priv->adap.name, sizeof(priv->adap.name), "xlr-i2c");\r\ni2c_set_adapdata(&priv->adap, priv);\r\nret = i2c_add_numbered_adapter(&priv->adap);\r\nif (ret < 0) {\r\ndev_err(&priv->adap.dev, "Failed to add i2c bus.\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\ndev_info(&priv->adap.dev, "Added I2C Bus.\n");\r\nreturn 0;\r\n}\r\nstatic int xlr_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct xlr_i2c_private *priv;\r\npriv = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&priv->adap);\r\nclk_unprepare(priv->clk);\r\nreturn 0;\r\n}
