static void dn_log_martian(struct sk_buff *skb, const char *msg)\r\n{\r\nif (decnet_log_martians) {\r\nchar *devname = skb->dev ? skb->dev->name : "???";\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nnet_info_ratelimited("DECnet: Martian packet (%s) dev=%s src=0x%04hx dst=0x%04hx srcport=0x%04hx dstport=0x%04hx\n",\r\nmsg, devname,\r\nle16_to_cpu(cb->src),\r\nle16_to_cpu(cb->dst),\r\nle16_to_cpu(cb->src_port),\r\nle16_to_cpu(cb->dst_port));\r\n}\r\n}\r\nstatic void dn_ack(struct sock *sk, struct sk_buff *skb, unsigned short ack)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nunsigned short type = ((ack >> 12) & 0x0003);\r\nint wakeup = 0;\r\nswitch (type) {\r\ncase 0:\r\nif (dn_after(ack, scp->ackrcv_dat)) {\r\nscp->ackrcv_dat = ack & 0x0fff;\r\nwakeup |= dn_nsp_check_xmit_queue(sk, skb,\r\n&scp->data_xmit_queue,\r\nack);\r\n}\r\nbreak;\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nif (dn_after(ack, scp->ackrcv_oth)) {\r\nscp->ackrcv_oth = ack & 0x0fff;\r\nwakeup |= dn_nsp_check_xmit_queue(sk, skb,\r\n&scp->other_xmit_queue,\r\nack);\r\n}\r\nbreak;\r\ncase 3:\r\nbreak;\r\n}\r\nif (wakeup && !sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\n}\r\nstatic int dn_process_ack(struct sock *sk, struct sk_buff *skb, int oth)\r\n{\r\n__le16 *ptr = (__le16 *)skb->data;\r\nint len = 0;\r\nunsigned short ack;\r\nif (skb->len < 2)\r\nreturn len;\r\nif ((ack = le16_to_cpu(*ptr)) & 0x8000) {\r\nskb_pull(skb, 2);\r\nptr++;\r\nlen += 2;\r\nif ((ack & 0x4000) == 0) {\r\nif (oth)\r\nack ^= 0x2000;\r\ndn_ack(sk, skb, ack);\r\n}\r\n}\r\nif (skb->len < 2)\r\nreturn len;\r\nif ((ack = le16_to_cpu(*ptr)) & 0x8000) {\r\nskb_pull(skb, 2);\r\nlen += 2;\r\nif ((ack & 0x4000) == 0) {\r\nif (oth)\r\nack ^= 0x2000;\r\ndn_ack(sk, skb, ack);\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic inline int dn_check_idf(unsigned char **pptr, int *len, unsigned char max, unsigned char follow_on)\r\n{\r\nunsigned char *ptr = *pptr;\r\nunsigned char flen = *ptr++;\r\n(*len)--;\r\nif (flen > max)\r\nreturn -1;\r\nif ((flen + follow_on) > *len)\r\nreturn -1;\r\n*len -= flen;\r\n*pptr = ptr + flen;\r\nreturn 0;\r\n}\r\nstatic struct sock *dn_find_listener(struct sk_buff *skb, unsigned short *reason)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nstruct nsp_conn_init_msg *msg = (struct nsp_conn_init_msg *)skb->data;\r\nstruct sockaddr_dn dstaddr;\r\nstruct sockaddr_dn srcaddr;\r\nunsigned char type = 0;\r\nint dstlen;\r\nint srclen;\r\nunsigned char *ptr;\r\nint len;\r\nint err = 0;\r\nunsigned char menuver;\r\nmemset(&dstaddr, 0, sizeof(struct sockaddr_dn));\r\nmemset(&srcaddr, 0, sizeof(struct sockaddr_dn));\r\ncb->src_port = msg->srcaddr;\r\ncb->dst_port = msg->dstaddr;\r\ncb->services = msg->services;\r\ncb->info = msg->info;\r\ncb->segsize = le16_to_cpu(msg->segsize);\r\nif (!pskb_may_pull(skb, sizeof(*msg)))\r\ngoto err_out;\r\nskb_pull(skb, sizeof(*msg));\r\nlen = skb->len;\r\nptr = skb->data;\r\ndstlen = dn_username2sockaddr(ptr, len, &dstaddr, &type);\r\nerr++;\r\nif (dstlen < 0)\r\ngoto err_out;\r\nerr++;\r\nif (type > 1)\r\ngoto err_out;\r\nlen -= dstlen;\r\nptr += dstlen;\r\nsrclen = dn_username2sockaddr(ptr, len, &srcaddr, &type);\r\nerr++;\r\nif (srclen < 0)\r\ngoto err_out;\r\nlen -= srclen;\r\nptr += srclen;\r\nerr++;\r\nif (len < 1)\r\ngoto err_out;\r\nmenuver = *ptr;\r\nptr++;\r\nlen--;\r\nerr++;\r\nif ((menuver & (DN_MENUVER_ACC | DN_MENUVER_USR)) && (len < 1))\r\ngoto err_out;\r\nerr++;\r\nif (menuver & DN_MENUVER_ACC) {\r\nif (dn_check_idf(&ptr, &len, 39, 1))\r\ngoto err_out;\r\nif (dn_check_idf(&ptr, &len, 39, 1))\r\ngoto err_out;\r\nif (dn_check_idf(&ptr, &len, 39, (menuver & DN_MENUVER_USR) ? 1 : 0))\r\ngoto err_out;\r\n}\r\nerr++;\r\nif (menuver & DN_MENUVER_USR) {\r\nif (dn_check_idf(&ptr, &len, 16, 0))\r\ngoto err_out;\r\n}\r\nreturn dn_sklist_find_listener(&dstaddr);\r\nerr_out:\r\ndn_log_martian(skb, ci_err_table[err].text);\r\n*reason = ci_err_table[err].reason;\r\nreturn NULL;\r\n}\r\nstatic void dn_nsp_conn_init(struct sock *sk, struct sk_buff *skb)\r\n{\r\nif (sk_acceptq_is_full(sk)) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nsk->sk_ack_backlog++;\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\nsk->sk_state_change(sk);\r\n}\r\nstatic void dn_nsp_conn_conf(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nstruct dn_scp *scp = DN_SK(sk);\r\nunsigned char *ptr;\r\nif (skb->len < 4)\r\ngoto out;\r\nptr = skb->data;\r\ncb->services = *ptr++;\r\ncb->info = *ptr++;\r\ncb->segsize = le16_to_cpu(*(__le16 *)ptr);\r\nif ((scp->state == DN_CI) || (scp->state == DN_CD)) {\r\nscp->persist = 0;\r\nscp->addrrem = cb->src_port;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nscp->state = DN_RUN;\r\nscp->services_rem = cb->services;\r\nscp->info_rem = cb->info;\r\nscp->segsize_rem = cb->segsize;\r\nif ((scp->services_rem & NSP_FC_MASK) == NSP_FC_NONE)\r\nscp->max_window = decnet_no_fc_max_cwnd;\r\nif (skb->len > 0) {\r\nu16 dlen = *skb->data;\r\nif ((dlen <= 16) && (dlen <= skb->len)) {\r\nscp->conndata_in.opt_optl = cpu_to_le16(dlen);\r\nskb_copy_from_linear_data_offset(skb, 1,\r\nscp->conndata_in.opt_data, dlen);\r\n}\r\n}\r\ndn_nsp_send_link(sk, DN_NOCHANGE, 0);\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\n}\r\nout:\r\nkfree_skb(skb);\r\n}\r\nstatic void dn_nsp_conn_ack(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (scp->state == DN_CI) {\r\nscp->state = DN_CD;\r\nscp->persist = 0;\r\n}\r\nkfree_skb(skb);\r\n}\r\nstatic void dn_nsp_disc_init(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nunsigned short reason;\r\nif (skb->len < 2)\r\ngoto out;\r\nreason = le16_to_cpu(*(__le16 *)skb->data);\r\nskb_pull(skb, 2);\r\nscp->discdata_in.opt_status = cpu_to_le16(reason);\r\nscp->discdata_in.opt_optl = 0;\r\nmemset(scp->discdata_in.opt_data, 0, 16);\r\nif (skb->len > 0) {\r\nu16 dlen = *skb->data;\r\nif ((dlen <= 16) && (dlen <= skb->len)) {\r\nscp->discdata_in.opt_optl = cpu_to_le16(dlen);\r\nskb_copy_from_linear_data_offset(skb, 1, scp->discdata_in.opt_data, dlen);\r\n}\r\n}\r\nscp->addrrem = cb->src_port;\r\nsk->sk_state = TCP_CLOSE;\r\nswitch (scp->state) {\r\ncase DN_CI:\r\ncase DN_CD:\r\nscp->state = DN_RJ;\r\nsk->sk_err = ECONNREFUSED;\r\nbreak;\r\ncase DN_RUN:\r\nsk->sk_shutdown |= SHUTDOWN_MASK;\r\nscp->state = DN_DN;\r\nbreak;\r\ncase DN_DI:\r\nscp->state = DN_DIC;\r\nbreak;\r\n}\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\nif (sk->sk_socket->state != SS_UNCONNECTED)\r\nsk->sk_socket->state = SS_DISCONNECTING;\r\nsk->sk_state_change(sk);\r\n}\r\nif (scp->addrrem) {\r\ndn_nsp_send_disc(sk, NSP_DISCCONF, NSP_REASON_DC, GFP_ATOMIC);\r\n}\r\nscp->persist_fxn = dn_destroy_timer;\r\nscp->persist = dn_nsp_persist(sk);\r\nout:\r\nkfree_skb(skb);\r\n}\r\nstatic void dn_nsp_disc_conf(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nunsigned short reason;\r\nif (skb->len != 2)\r\ngoto out;\r\nreason = le16_to_cpu(*(__le16 *)skb->data);\r\nsk->sk_state = TCP_CLOSE;\r\nswitch (scp->state) {\r\ncase DN_CI:\r\nscp->state = DN_NR;\r\nbreak;\r\ncase DN_DR:\r\nif (reason == NSP_REASON_DC)\r\nscp->state = DN_DRC;\r\nif (reason == NSP_REASON_NL)\r\nscp->state = DN_CN;\r\nbreak;\r\ncase DN_DI:\r\nscp->state = DN_DIC;\r\nbreak;\r\ncase DN_RUN:\r\nsk->sk_shutdown |= SHUTDOWN_MASK;\r\ncase DN_CC:\r\nscp->state = DN_CN;\r\n}\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\nif (sk->sk_socket->state != SS_UNCONNECTED)\r\nsk->sk_socket->state = SS_DISCONNECTING;\r\nsk->sk_state_change(sk);\r\n}\r\nscp->persist_fxn = dn_destroy_timer;\r\nscp->persist = dn_nsp_persist(sk);\r\nout:\r\nkfree_skb(skb);\r\n}\r\nstatic void dn_nsp_linkservice(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nunsigned short segnum;\r\nunsigned char lsflags;\r\nsigned char fcval;\r\nint wake_up = 0;\r\nchar *ptr = skb->data;\r\nunsigned char fctype = scp->services_rem & NSP_FC_MASK;\r\nif (skb->len != 4)\r\ngoto out;\r\nsegnum = le16_to_cpu(*(__le16 *)ptr);\r\nptr += 2;\r\nlsflags = *(unsigned char *)ptr++;\r\nfcval = *ptr;\r\nif (lsflags & 0xf8)\r\ngoto out;\r\nif (seq_next(scp->numoth_rcv, segnum)) {\r\nseq_add(&scp->numoth_rcv, 1);\r\nswitch(lsflags & 0x04) {\r\ncase 0x00:\r\nswitch(lsflags & 0x03) {\r\ncase 0x00:\r\nif (fcval < 0) {\r\nunsigned char p_fcval = -fcval;\r\nif ((scp->flowrem_dat > p_fcval) &&\r\n(fctype == NSP_FC_SCMC)) {\r\nscp->flowrem_dat -= p_fcval;\r\n}\r\n} else if (fcval > 0) {\r\nscp->flowrem_dat += fcval;\r\nwake_up = 1;\r\n}\r\nbreak;\r\ncase 0x01:\r\nscp->flowrem_sw = DN_DONTSEND;\r\nbreak;\r\ncase 0x02:\r\nscp->flowrem_sw = DN_SEND;\r\ndn_nsp_output(sk);\r\nwake_up = 1;\r\n}\r\nbreak;\r\ncase 0x04:\r\nif (fcval > 0) {\r\nscp->flowrem_oth += fcval;\r\nwake_up = 1;\r\n}\r\nbreak;\r\n}\r\nif (wake_up && !sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\n}\r\ndn_nsp_send_oth_ack(sk);\r\nout:\r\nkfree_skb(skb);\r\n}\r\nstatic __inline__ int dn_queue_skb(struct sock *sk, struct sk_buff *skb, int sig, struct sk_buff_head *queue)\r\n{\r\nint err;\r\nif (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >=\r\n(unsigned int)sk->sk_rcvbuf) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = sk_filter(sk, skb);\r\nif (err)\r\ngoto out;\r\nskb_set_owner_r(skb, sk);\r\nskb_queue_tail(queue, skb);\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_data_ready(sk);\r\nout:\r\nreturn err;\r\n}\r\nstatic void dn_nsp_otherdata(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nunsigned short segnum;\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nint queued = 0;\r\nif (skb->len < 2)\r\ngoto out;\r\ncb->segnum = segnum = le16_to_cpu(*(__le16 *)skb->data);\r\nskb_pull(skb, 2);\r\nif (seq_next(scp->numoth_rcv, segnum)) {\r\nif (dn_queue_skb(sk, skb, SIGURG, &scp->other_receive_queue) == 0) {\r\nseq_add(&scp->numoth_rcv, 1);\r\nscp->other_report = 0;\r\nqueued = 1;\r\n}\r\n}\r\ndn_nsp_send_oth_ack(sk);\r\nout:\r\nif (!queued)\r\nkfree_skb(skb);\r\n}\r\nstatic void dn_nsp_data(struct sock *sk, struct sk_buff *skb)\r\n{\r\nint queued = 0;\r\nunsigned short segnum;\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (skb->len < 2)\r\ngoto out;\r\ncb->segnum = segnum = le16_to_cpu(*(__le16 *)skb->data);\r\nskb_pull(skb, 2);\r\nif (seq_next(scp->numdat_rcv, segnum)) {\r\nif (dn_queue_skb(sk, skb, SIGIO, &sk->sk_receive_queue) == 0) {\r\nseq_add(&scp->numdat_rcv, 1);\r\nqueued = 1;\r\n}\r\nif ((scp->flowloc_sw == DN_SEND) && dn_congested(sk)) {\r\nscp->flowloc_sw = DN_DONTSEND;\r\ndn_nsp_send_link(sk, DN_DONTSEND, 0);\r\n}\r\n}\r\ndn_nsp_send_data_ack(sk);\r\nout:\r\nif (!queued)\r\nkfree_skb(skb);\r\n}\r\nstatic void dn_returned_conn_init(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (scp->state == DN_CI) {\r\nscp->state = DN_NC;\r\nsk->sk_state = TCP_CLOSE;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\n}\r\nkfree_skb(skb);\r\n}\r\nstatic int dn_nsp_no_socket(struct sk_buff *skb, unsigned short reason)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nint ret = NET_RX_DROP;\r\nif (cb->rt_flags & DN_RT_F_RTS)\r\ngoto out;\r\nif ((reason != NSP_REASON_OK) && ((cb->nsp_flags & 0x0c) == 0x08)) {\r\nswitch (cb->nsp_flags & 0x70) {\r\ncase 0x10:\r\ncase 0x60:\r\ndn_nsp_return_disc(skb, NSP_DISCINIT, reason);\r\nret = NET_RX_SUCCESS;\r\nbreak;\r\ncase 0x20:\r\ndn_nsp_return_disc(skb, NSP_DISCCONF, reason);\r\nret = NET_RX_SUCCESS;\r\nbreak;\r\n}\r\n}\r\nout:\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int dn_nsp_rx_packet(struct net *net, struct sock *sk2,\r\nstruct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nstruct sock *sk = NULL;\r\nunsigned char *ptr = (unsigned char *)skb->data;\r\nunsigned short reason = NSP_REASON_NL;\r\nif (!pskb_may_pull(skb, 2))\r\ngoto free_out;\r\nskb_reset_transport_header(skb);\r\ncb->nsp_flags = *ptr++;\r\nif (decnet_debug_level & 2)\r\nprintk(KERN_DEBUG "dn_nsp_rx: Message type 0x%02x\n", (int)cb->nsp_flags);\r\nif (cb->nsp_flags & 0x83)\r\ngoto free_out;\r\nif ((cb->nsp_flags & 0x0c) == 0x08) {\r\nswitch (cb->nsp_flags & 0x70) {\r\ncase 0x00:\r\ncase 0x70:\r\ncase 0x50:\r\ngoto free_out;\r\ncase 0x10:\r\ncase 0x60:\r\nif (unlikely(cb->rt_flags & DN_RT_F_RTS))\r\ngoto free_out;\r\nsk = dn_find_listener(skb, &reason);\r\ngoto got_it;\r\n}\r\n}\r\nif (!pskb_may_pull(skb, 3))\r\ngoto free_out;\r\ncb->dst_port = *(__le16 *)ptr;\r\ncb->src_port = 0;\r\nptr += 2;\r\nif (pskb_may_pull(skb, 5)) {\r\ncb->src_port = *(__le16 *)ptr;\r\nptr += 2;\r\nskb_pull(skb, 5);\r\n}\r\nif (unlikely(cb->rt_flags & DN_RT_F_RTS)) {\r\n__le16 tmp = cb->dst_port;\r\ncb->dst_port = cb->src_port;\r\ncb->src_port = tmp;\r\ntmp = cb->dst;\r\ncb->dst = cb->src;\r\ncb->src = tmp;\r\n}\r\nsk = dn_find_by_skb(skb);\r\ngot_it:\r\nif (sk != NULL) {\r\nstruct dn_scp *scp = DN_SK(sk);\r\nscp->nsp_rxtshift = 0;\r\nif (cb->nsp_flags & ~0x60) {\r\nif (unlikely(skb_linearize(skb)))\r\ngoto free_out;\r\n}\r\nreturn sk_receive_skb(sk, skb, 0);\r\n}\r\nreturn dn_nsp_no_socket(skb, reason);\r\nfree_out:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nint dn_nsp_rx(struct sk_buff *skb)\r\n{\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_LOCAL_IN,\r\n&init_net, NULL, skb, skb->dev, NULL,\r\ndn_nsp_rx_packet);\r\n}\r\nint dn_nsp_backlog_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nif (cb->rt_flags & DN_RT_F_RTS) {\r\nif (cb->nsp_flags == 0x18 || cb->nsp_flags == 0x68)\r\ndn_returned_conn_init(sk, skb);\r\nelse\r\nkfree_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nif ((cb->nsp_flags & 0x0c) == 0x08) {\r\nswitch (cb->nsp_flags & 0x70) {\r\ncase 0x10:\r\ncase 0x60:\r\ndn_nsp_conn_init(sk, skb);\r\nbreak;\r\ncase 0x20:\r\ndn_nsp_conn_conf(sk, skb);\r\nbreak;\r\ncase 0x30:\r\ndn_nsp_disc_init(sk, skb);\r\nbreak;\r\ncase 0x40:\r\ndn_nsp_disc_conf(sk, skb);\r\nbreak;\r\n}\r\n} else if (cb->nsp_flags == 0x24) {\r\ndn_nsp_conn_ack(sk, skb);\r\n} else {\r\nint other = 1;\r\nif ((scp->state == DN_CC) && !sock_flag(sk, SOCK_DEAD)) {\r\nscp->state = DN_RUN;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nsk->sk_state_change(sk);\r\n}\r\nif ((cb->nsp_flags & 0x1c) == 0)\r\nother = 0;\r\nif (cb->nsp_flags == 0x04)\r\nother = 0;\r\ndn_process_ack(sk, skb, other);\r\nif ((cb->nsp_flags & 0x0c) == 0) {\r\nif (scp->state != DN_RUN)\r\ngoto free_out;\r\nswitch (cb->nsp_flags) {\r\ncase 0x10:\r\ndn_nsp_linkservice(sk, skb);\r\nbreak;\r\ncase 0x30:\r\ndn_nsp_otherdata(sk, skb);\r\nbreak;\r\ndefault:\r\ndn_nsp_data(sk, skb);\r\n}\r\n} else {\r\nfree_out:\r\nkfree_skb(skb);\r\n}\r\n}\r\nreturn NET_RX_SUCCESS;\r\n}
