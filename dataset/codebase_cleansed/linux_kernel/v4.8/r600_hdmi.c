static struct r600_audio_pin r600_audio_status(struct radeon_device *rdev)\r\n{\r\nstruct r600_audio_pin status;\r\nuint32_t value;\r\nvalue = RREG32(R600_AUDIO_RATE_BPS_CHANNEL);\r\nstatus.channels = (value & 0x7) + 1;\r\nswitch ((value & 0xF0) >> 4) {\r\ncase 0x0:\r\nstatus.bits_per_sample = 8;\r\nbreak;\r\ncase 0x1:\r\nstatus.bits_per_sample = 16;\r\nbreak;\r\ncase 0x2:\r\nstatus.bits_per_sample = 20;\r\nbreak;\r\ncase 0x3:\r\nstatus.bits_per_sample = 24;\r\nbreak;\r\ncase 0x4:\r\nstatus.bits_per_sample = 32;\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Unknown bits per sample 0x%x, using 16\n",\r\n(int)value);\r\nstatus.bits_per_sample = 16;\r\n}\r\nif (value & 0x4000)\r\nstatus.rate = 44100;\r\nelse\r\nstatus.rate = 48000;\r\nstatus.rate *= ((value >> 11) & 0x7) + 1;\r\nstatus.rate /= ((value >> 8) & 0x7) + 1;\r\nvalue = RREG32(R600_AUDIO_STATUS_BITS);\r\nstatus.status_bits = value & 0xff;\r\nstatus.category_code = (value >> 8) & 0xff;\r\nreturn status;\r\n}\r\nvoid r600_audio_update_hdmi(struct work_struct *work)\r\n{\r\nstruct radeon_device *rdev = container_of(work, struct radeon_device,\r\naudio_work);\r\nstruct drm_device *dev = rdev->ddev;\r\nstruct r600_audio_pin audio_status = r600_audio_status(rdev);\r\nstruct drm_encoder *encoder;\r\nbool changed = false;\r\nif (rdev->audio.pin[0].channels != audio_status.channels ||\r\nrdev->audio.pin[0].rate != audio_status.rate ||\r\nrdev->audio.pin[0].bits_per_sample != audio_status.bits_per_sample ||\r\nrdev->audio.pin[0].status_bits != audio_status.status_bits ||\r\nrdev->audio.pin[0].category_code != audio_status.category_code) {\r\nrdev->audio.pin[0] = audio_status;\r\nchanged = true;\r\n}\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (!radeon_encoder_is_digital(encoder))\r\ncontinue;\r\nif (changed || r600_hdmi_buffer_status_changed(encoder))\r\nr600_hdmi_update_audio_settings(encoder);\r\n}\r\n}\r\nvoid r600_audio_enable(struct radeon_device *rdev,\r\nstruct r600_audio_pin *pin,\r\nu8 enable_mask)\r\n{\r\nu32 tmp = RREG32(AZ_HOT_PLUG_CONTROL);\r\nif (!pin)\r\nreturn;\r\nif (enable_mask) {\r\ntmp |= AUDIO_ENABLED;\r\nif (enable_mask & 1)\r\ntmp |= PIN0_AUDIO_ENABLED;\r\nif (enable_mask & 2)\r\ntmp |= PIN1_AUDIO_ENABLED;\r\nif (enable_mask & 4)\r\ntmp |= PIN2_AUDIO_ENABLED;\r\nif (enable_mask & 8)\r\ntmp |= PIN3_AUDIO_ENABLED;\r\n} else {\r\ntmp &= ~(AUDIO_ENABLED |\r\nPIN0_AUDIO_ENABLED |\r\nPIN1_AUDIO_ENABLED |\r\nPIN2_AUDIO_ENABLED |\r\nPIN3_AUDIO_ENABLED);\r\n}\r\nWREG32(AZ_HOT_PLUG_CONTROL, tmp);\r\n}\r\nstruct r600_audio_pin *r600_audio_get_pin(struct radeon_device *rdev)\r\n{\r\nreturn &rdev->audio.pin[0];\r\n}\r\nvoid r600_hdmi_update_acr(struct drm_encoder *encoder, long offset,\r\nconst struct radeon_hdmi_acr *acr)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t acr_ctl = ASIC_IS_DCE3(rdev) ? DCE3_HDMI0_ACR_PACKET_CONTROL :\r\nHDMI0_ACR_PACKET_CONTROL;\r\nWREG32_P(acr_ctl + offset,\r\nHDMI0_ACR_SOURCE |\r\nHDMI0_ACR_AUTO_SEND,\r\n~(HDMI0_ACR_SOURCE |\r\nHDMI0_ACR_AUTO_SEND));\r\nWREG32_P(HDMI0_ACR_32_0 + offset,\r\nHDMI0_ACR_CTS_32(acr->cts_32khz),\r\n~HDMI0_ACR_CTS_32_MASK);\r\nWREG32_P(HDMI0_ACR_32_1 + offset,\r\nHDMI0_ACR_N_32(acr->n_32khz),\r\n~HDMI0_ACR_N_32_MASK);\r\nWREG32_P(HDMI0_ACR_44_0 + offset,\r\nHDMI0_ACR_CTS_44(acr->cts_44_1khz),\r\n~HDMI0_ACR_CTS_44_MASK);\r\nWREG32_P(HDMI0_ACR_44_1 + offset,\r\nHDMI0_ACR_N_44(acr->n_44_1khz),\r\n~HDMI0_ACR_N_44_MASK);\r\nWREG32_P(HDMI0_ACR_48_0 + offset,\r\nHDMI0_ACR_CTS_48(acr->cts_48khz),\r\n~HDMI0_ACR_CTS_48_MASK);\r\nWREG32_P(HDMI0_ACR_48_1 + offset,\r\nHDMI0_ACR_N_48(acr->n_48khz),\r\n~HDMI0_ACR_N_48_MASK);\r\n}\r\nvoid r600_set_avi_packet(struct radeon_device *rdev, u32 offset,\r\nunsigned char *buffer, size_t size)\r\n{\r\nuint8_t *frame = buffer + 3;\r\nWREG32(HDMI0_AVI_INFO0 + offset,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(HDMI0_AVI_INFO1 + offset,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x7] << 24));\r\nWREG32(HDMI0_AVI_INFO2 + offset,\r\nframe[0x8] | (frame[0x9] << 8) | (frame[0xA] << 16) | (frame[0xB] << 24));\r\nWREG32(HDMI0_AVI_INFO3 + offset,\r\nframe[0xC] | (frame[0xD] << 8) | (buffer[1] << 24));\r\nWREG32_OR(HDMI0_INFOFRAME_CONTROL1 + offset,\r\nHDMI0_AVI_INFO_LINE(2));\r\nWREG32_OR(HDMI0_INFOFRAME_CONTROL0 + offset,\r\nHDMI0_AVI_INFO_SEND |\r\nHDMI0_AVI_INFO_CONT);\r\n}\r\nstatic void r600_hdmi_update_audio_infoframe(struct drm_encoder *encoder,\r\nconst void *buffer, size_t size)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nconst u8 *frame = buffer + 3;\r\nWREG32(HDMI0_AUDIO_INFO0 + offset,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(HDMI0_AUDIO_INFO1 + offset,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x8] << 24));\r\n}\r\nstatic bool r600_hdmi_is_audio_buffer_filled(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nreturn (RREG32(HDMI0_STATUS + offset) & 0x10) != 0;\r\n}\r\nint r600_hdmi_buffer_status_changed(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nint status, result;\r\nif (!dig->afmt || !dig->afmt->enabled)\r\nreturn 0;\r\nstatus = r600_hdmi_is_audio_buffer_filled(encoder);\r\nresult = dig->afmt->last_buffer_filled_status != status;\r\ndig->afmt->last_buffer_filled_status = status;\r\nreturn result;\r\n}\r\nvoid r600_hdmi_audio_workaround(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nbool hdmi_audio_workaround = false;\r\nu32 value;\r\nif (!hdmi_audio_workaround ||\r\nr600_hdmi_is_audio_buffer_filled(encoder))\r\nvalue = 0;\r\nelse\r\nvalue = HDMI0_AUDIO_TEST_EN;\r\nWREG32_P(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nvalue, ~HDMI0_AUDIO_TEST_EN);\r\n}\r\nvoid r600_hdmi_audio_set_dto(struct radeon_device *rdev,\r\nstruct radeon_crtc *crtc, unsigned int clock)\r\n{\r\nstruct radeon_encoder *radeon_encoder;\r\nstruct radeon_encoder_atom_dig *dig;\r\nif (!crtc)\r\nreturn;\r\nradeon_encoder = to_radeon_encoder(crtc->encoder);\r\ndig = radeon_encoder->enc_priv;\r\nif (!dig)\r\nreturn;\r\nif (dig->dig_encoder == 0) {\r\nWREG32(DCCG_AUDIO_DTO0_PHASE, 24000 * 100);\r\nWREG32(DCCG_AUDIO_DTO0_MODULE, clock * 100);\r\nWREG32(DCCG_AUDIO_DTO_SELECT, 0);\r\n} else {\r\nWREG32(DCCG_AUDIO_DTO1_PHASE, 24000 * 100);\r\nWREG32(DCCG_AUDIO_DTO1_MODULE, clock * 100);\r\nWREG32(DCCG_AUDIO_DTO_SELECT, 1);\r\n}\r\n}\r\nvoid r600_set_vbi_packet(struct drm_encoder *encoder, u32 offset)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nWREG32_OR(HDMI0_VBI_PACKET_CONTROL + offset,\r\nHDMI0_NULL_SEND |\r\nHDMI0_GC_SEND |\r\nHDMI0_GC_CONT);\r\n}\r\nvoid r600_set_audio_packet(struct drm_encoder *encoder, u32 offset)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nWREG32_P(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nHDMI0_AUDIO_SAMPLE_SEND |\r\nHDMI0_AUDIO_DELAY_EN(1) |\r\nHDMI0_AUDIO_PACKETS_PER_LINE(3) |\r\nHDMI0_60958_CS_UPDATE,\r\n~(HDMI0_AUDIO_SAMPLE_SEND |\r\nHDMI0_AUDIO_DELAY_EN_MASK |\r\nHDMI0_AUDIO_PACKETS_PER_LINE_MASK |\r\nHDMI0_60958_CS_UPDATE));\r\nWREG32_OR(HDMI0_INFOFRAME_CONTROL0 + offset,\r\nHDMI0_AUDIO_INFO_SEND |\r\nHDMI0_AUDIO_INFO_UPDATE);\r\nWREG32_P(HDMI0_INFOFRAME_CONTROL1 + offset,\r\nHDMI0_AUDIO_INFO_LINE(2),\r\n~HDMI0_AUDIO_INFO_LINE_MASK);\r\nWREG32_AND(HDMI0_GENERIC_PACKET_CONTROL + offset,\r\n~(HDMI0_GENERIC0_SEND |\r\nHDMI0_GENERIC0_CONT |\r\nHDMI0_GENERIC0_UPDATE |\r\nHDMI0_GENERIC1_SEND |\r\nHDMI0_GENERIC1_CONT |\r\nHDMI0_GENERIC0_LINE_MASK |\r\nHDMI0_GENERIC1_LINE_MASK));\r\nWREG32_P(HDMI0_60958_0 + offset,\r\nHDMI0_60958_CS_CHANNEL_NUMBER_L(1),\r\n~(HDMI0_60958_CS_CHANNEL_NUMBER_L_MASK |\r\nHDMI0_60958_CS_CLOCK_ACCURACY_MASK));\r\nWREG32_P(HDMI0_60958_1 + offset,\r\nHDMI0_60958_CS_CHANNEL_NUMBER_R(2),\r\n~HDMI0_60958_CS_CHANNEL_NUMBER_R_MASK);\r\n}\r\nvoid r600_set_mute(struct drm_encoder *encoder, u32 offset, bool mute)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (mute)\r\nWREG32_OR(HDMI0_GC + offset, HDMI0_GC_AVMUTE);\r\nelse\r\nWREG32_AND(HDMI0_GC + offset, ~HDMI0_GC_AVMUTE);\r\n}\r\nvoid r600_hdmi_update_audio_settings(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct r600_audio_pin audio = r600_audio_status(rdev);\r\nuint8_t buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AUDIO_INFOFRAME_SIZE];\r\nstruct hdmi_audio_infoframe frame;\r\nuint32_t offset;\r\nuint32_t value;\r\nssize_t err;\r\nif (!dig->afmt || !dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\nDRM_DEBUG("%s with %d channels, %d Hz sampling rate, %d bits per sample,\n",\r\nr600_hdmi_is_audio_buffer_filled(encoder) ? "playing" : "stopped",\r\naudio.channels, audio.rate, audio.bits_per_sample);\r\nDRM_DEBUG("0x%02X IEC60958 status bits and 0x%02X category code\n",\r\n(int)audio.status_bits, (int)audio.category_code);\r\nerr = hdmi_audio_infoframe_init(&frame);\r\nif (err < 0) {\r\nDRM_ERROR("failed to setup audio infoframe\n");\r\nreturn;\r\n}\r\nframe.channels = audio.channels;\r\nerr = hdmi_audio_infoframe_pack(&frame, buffer, sizeof(buffer));\r\nif (err < 0) {\r\nDRM_ERROR("failed to pack audio infoframe\n");\r\nreturn;\r\n}\r\nvalue = RREG32(HDMI0_AUDIO_PACKET_CONTROL + offset);\r\nif (value & HDMI0_AUDIO_TEST_EN)\r\nWREG32(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nvalue & ~HDMI0_AUDIO_TEST_EN);\r\nWREG32_OR(HDMI0_CONTROL + offset,\r\nHDMI0_ERROR_ACK);\r\nWREG32_AND(HDMI0_INFOFRAME_CONTROL0 + offset,\r\n~HDMI0_AUDIO_INFO_SOURCE);\r\nr600_hdmi_update_audio_infoframe(encoder, buffer, sizeof(buffer));\r\nWREG32_OR(HDMI0_INFOFRAME_CONTROL0 + offset,\r\nHDMI0_AUDIO_INFO_CONT |\r\nHDMI0_AUDIO_INFO_UPDATE);\r\n}\r\nvoid r600_hdmi_enable(struct drm_encoder *encoder, bool enable)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nu32 hdmi = HDMI0_ERROR_ACK;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (!ASIC_IS_DCE3(rdev)) {\r\nif (enable)\r\nhdmi |= HDMI0_ENABLE;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nif (enable) {\r\nWREG32_OR(AVIVO_TMDSA_CNTL, AVIVO_TMDSA_CNTL_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_TMDSA);\r\n} else {\r\nWREG32_AND(AVIVO_TMDSA_CNTL, ~AVIVO_TMDSA_CNTL_HDMI_EN);\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nif (enable) {\r\nWREG32_OR(AVIVO_LVTMA_CNTL, AVIVO_LVTMA_CNTL_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_LVTMA);\r\n} else {\r\nWREG32_AND(AVIVO_LVTMA_CNTL, ~AVIVO_LVTMA_CNTL_HDMI_EN);\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\nif (enable) {\r\nWREG32_OR(DDIA_CNTL, DDIA_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_DDIA);\r\n} else {\r\nWREG32_AND(DDIA_CNTL, ~DDIA_HDMI_EN);\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nif (enable)\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_DVOA);\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Invalid encoder for HDMI: 0x%X\n",\r\nradeon_encoder->encoder_id);\r\nbreak;\r\n}\r\nWREG32(HDMI0_CONTROL + dig->afmt->offset, hdmi);\r\n}\r\nif (rdev->irq.installed) {\r\nif (enable)\r\nradeon_irq_kms_enable_afmt(rdev, dig->afmt->id);\r\nelse\r\nradeon_irq_kms_disable_afmt(rdev, dig->afmt->id);\r\n}\r\ndig->afmt->enabled = enable;\r\nDRM_DEBUG("%sabling HDMI interface @ 0x%04X for encoder 0x%x\n",\r\nenable ? "En" : "Dis", dig->afmt->offset, radeon_encoder->encoder_id);\r\n}
