static inline void msi_writel(struct altera_msi *msi, const u32 value,\r\nconst u32 reg)\r\n{\r\nwritel_relaxed(value, msi->csr_base + reg);\r\n}\r\nstatic inline u32 msi_readl(struct altera_msi *msi, const u32 reg)\r\n{\r\nreturn readl_relaxed(msi->csr_base + reg);\r\n}\r\nstatic void altera_msi_isr(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct altera_msi *msi;\r\nunsigned long status;\r\nu32 num_of_vectors;\r\nu32 bit;\r\nu32 virq;\r\nchained_irq_enter(chip, desc);\r\nmsi = irq_desc_get_handler_data(desc);\r\nnum_of_vectors = msi->num_of_vectors;\r\nwhile ((status = msi_readl(msi, MSI_STATUS)) != 0) {\r\nfor_each_set_bit(bit, &status, msi->num_of_vectors) {\r\nreadl_relaxed(msi->vector_base + (bit * sizeof(u32)));\r\nvirq = irq_find_mapping(msi->inner_domain, bit);\r\nif (virq)\r\ngeneric_handle_irq(virq);\r\nelse\r\ndev_err(&msi->pdev->dev, "unexpected MSI\n");\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void altera_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\r\n{\r\nstruct altera_msi *msi = irq_data_get_irq_chip_data(data);\r\nphys_addr_t addr = msi->vector_phy + (data->hwirq * sizeof(u32));\r\nmsg->address_lo = lower_32_bits(addr);\r\nmsg->address_hi = upper_32_bits(addr);\r\nmsg->data = data->hwirq;\r\ndev_dbg(&msi->pdev->dev, "msi#%d address_hi %#x address_lo %#x\n",\r\n(int)data->hwirq, msg->address_hi, msg->address_lo);\r\n}\r\nstatic int altera_msi_set_affinity(struct irq_data *irq_data,\r\nconst struct cpumask *mask, bool force)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int altera_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs, void *args)\r\n{\r\nstruct altera_msi *msi = domain->host_data;\r\nunsigned long bit;\r\nu32 mask;\r\nWARN_ON(nr_irqs != 1);\r\nmutex_lock(&msi->lock);\r\nbit = find_first_zero_bit(msi->used, msi->num_of_vectors);\r\nif (bit >= msi->num_of_vectors) {\r\nmutex_unlock(&msi->lock);\r\nreturn -ENOSPC;\r\n}\r\nset_bit(bit, msi->used);\r\nmutex_unlock(&msi->lock);\r\nirq_domain_set_info(domain, virq, bit, &altera_msi_bottom_irq_chip,\r\ndomain->host_data, handle_simple_irq,\r\nNULL, NULL);\r\nmask = msi_readl(msi, MSI_INTMASK);\r\nmask |= 1 << bit;\r\nmsi_writel(msi, mask, MSI_INTMASK);\r\nreturn 0;\r\n}\r\nstatic void altera_irq_domain_free(struct irq_domain *domain,\r\nunsigned int virq, unsigned int nr_irqs)\r\n{\r\nstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\r\nstruct altera_msi *msi = irq_data_get_irq_chip_data(d);\r\nu32 mask;\r\nmutex_lock(&msi->lock);\r\nif (!test_bit(d->hwirq, msi->used)) {\r\ndev_err(&msi->pdev->dev, "trying to free unused MSI#%lu\n",\r\nd->hwirq);\r\n} else {\r\n__clear_bit(d->hwirq, msi->used);\r\nmask = msi_readl(msi, MSI_INTMASK);\r\nmask &= ~(1 << d->hwirq);\r\nmsi_writel(msi, mask, MSI_INTMASK);\r\n}\r\nmutex_unlock(&msi->lock);\r\n}\r\nstatic int altera_allocate_domains(struct altera_msi *msi)\r\n{\r\nstruct fwnode_handle *fwnode = of_node_to_fwnode(msi->pdev->dev.of_node);\r\nmsi->inner_domain = irq_domain_add_linear(NULL, msi->num_of_vectors,\r\n&msi_domain_ops, msi);\r\nif (!msi->inner_domain) {\r\ndev_err(&msi->pdev->dev, "failed to create IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nmsi->msi_domain = pci_msi_create_irq_domain(fwnode,\r\n&altera_msi_domain_info, msi->inner_domain);\r\nif (!msi->msi_domain) {\r\ndev_err(&msi->pdev->dev, "failed to create MSI domain\n");\r\nirq_domain_remove(msi->inner_domain);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void altera_free_domains(struct altera_msi *msi)\r\n{\r\nirq_domain_remove(msi->msi_domain);\r\nirq_domain_remove(msi->inner_domain);\r\n}\r\nstatic int altera_msi_remove(struct platform_device *pdev)\r\n{\r\nstruct altera_msi *msi = platform_get_drvdata(pdev);\r\nmsi_writel(msi, 0, MSI_INTMASK);\r\nirq_set_chained_handler(msi->irq, NULL);\r\nirq_set_handler_data(msi->irq, NULL);\r\naltera_free_domains(msi);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int altera_msi_probe(struct platform_device *pdev)\r\n{\r\nstruct altera_msi *msi;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *res;\r\nint ret;\r\nmsi = devm_kzalloc(&pdev->dev, sizeof(struct altera_msi),\r\nGFP_KERNEL);\r\nif (!msi)\r\nreturn -ENOMEM;\r\nmutex_init(&msi->lock);\r\nmsi->pdev = pdev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "csr");\r\nif (!res) {\r\ndev_err(&pdev->dev, "no csr memory resource defined\n");\r\nreturn -ENODEV;\r\n}\r\nmsi->csr_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(msi->csr_base)) {\r\ndev_err(&pdev->dev, "failed to map csr memory\n");\r\nreturn PTR_ERR(msi->csr_base);\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"vector_slave");\r\nif (!res) {\r\ndev_err(&pdev->dev, "no vector_slave memory resource defined\n");\r\nreturn -ENODEV;\r\n}\r\nmsi->vector_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(msi->vector_base)) {\r\ndev_err(&pdev->dev, "failed to map vector_slave memory\n");\r\nreturn PTR_ERR(msi->vector_base);\r\n}\r\nmsi->vector_phy = res->start;\r\nif (of_property_read_u32(np, "num-vectors", &msi->num_of_vectors)) {\r\ndev_err(&pdev->dev, "failed to parse the number of vectors\n");\r\nreturn -EINVAL;\r\n}\r\nret = altera_allocate_domains(msi);\r\nif (ret)\r\nreturn ret;\r\nmsi->irq = platform_get_irq(pdev, 0);\r\nif (msi->irq <= 0) {\r\ndev_err(&pdev->dev, "failed to map IRQ: %d\n", msi->irq);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nirq_set_chained_handler_and_data(msi->irq, altera_msi_isr, msi);\r\nplatform_set_drvdata(pdev, msi);\r\nreturn 0;\r\nerr:\r\naltera_msi_remove(pdev);\r\nreturn ret;\r\n}\r\nstatic int __init altera_msi_init(void)\r\n{\r\nreturn platform_driver_register(&altera_msi_driver);\r\n}
