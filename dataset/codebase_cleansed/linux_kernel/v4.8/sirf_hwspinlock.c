static int sirf_hwspinlock_trylock(struct hwspinlock *lock)\r\n{\r\nvoid __iomem *lock_addr = lock->priv;\r\nreturn !!readl(lock_addr);\r\n}\r\nstatic void sirf_hwspinlock_unlock(struct hwspinlock *lock)\r\n{\r\nvoid __iomem *lock_addr = lock->priv;\r\nwritel(0, lock_addr);\r\n}\r\nstatic int sirf_hwspinlock_probe(struct platform_device *pdev)\r\n{\r\nstruct sirf_hwspinlock *hwspin;\r\nstruct hwspinlock *hwlock;\r\nint idx, ret;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nhwspin = devm_kzalloc(&pdev->dev, sizeof(*hwspin) +\r\nsizeof(*hwlock) * HW_SPINLOCK_NUMBER, GFP_KERNEL);\r\nif (!hwspin)\r\nreturn -ENOMEM;\r\nhwspin->io_base = of_iomap(pdev->dev.of_node, 0);\r\nif (!hwspin->io_base)\r\nreturn -ENOMEM;\r\nfor (idx = 0; idx < HW_SPINLOCK_NUMBER; idx++) {\r\nhwlock = &hwspin->bank.lock[idx];\r\nhwlock->priv = hwspin->io_base + HW_SPINLOCK_OFFSET(idx);\r\n}\r\nplatform_set_drvdata(pdev, hwspin);\r\npm_runtime_enable(&pdev->dev);\r\nret = hwspin_lock_register(&hwspin->bank, &pdev->dev,\r\n&sirf_hwspinlock_ops, 0,\r\nHW_SPINLOCK_NUMBER);\r\nif (ret)\r\ngoto reg_failed;\r\nreturn 0;\r\nreg_failed:\r\npm_runtime_disable(&pdev->dev);\r\niounmap(hwspin->io_base);\r\nreturn ret;\r\n}\r\nstatic int sirf_hwspinlock_remove(struct platform_device *pdev)\r\n{\r\nstruct sirf_hwspinlock *hwspin = platform_get_drvdata(pdev);\r\nint ret;\r\nret = hwspin_lock_unregister(&hwspin->bank);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s failed: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\npm_runtime_disable(&pdev->dev);\r\niounmap(hwspin->io_base);\r\nreturn 0;\r\n}
