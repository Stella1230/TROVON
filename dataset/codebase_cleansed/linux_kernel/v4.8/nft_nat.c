static void nft_nat_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_nat *priv = nft_expr_priv(expr);\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(pkt->skb, &ctinfo);\r\nstruct nf_nat_range range;\r\nmemset(&range, 0, sizeof(range));\r\nif (priv->sreg_addr_min) {\r\nif (priv->family == AF_INET) {\r\nrange.min_addr.ip = (__force __be32)\r\nregs->data[priv->sreg_addr_min];\r\nrange.max_addr.ip = (__force __be32)\r\nregs->data[priv->sreg_addr_max];\r\n} else {\r\nmemcpy(range.min_addr.ip6,\r\n&regs->data[priv->sreg_addr_min],\r\nsizeof(range.min_addr.ip6));\r\nmemcpy(range.max_addr.ip6,\r\n&regs->data[priv->sreg_addr_max],\r\nsizeof(range.max_addr.ip6));\r\n}\r\nrange.flags |= NF_NAT_RANGE_MAP_IPS;\r\n}\r\nif (priv->sreg_proto_min) {\r\nrange.min_proto.all =\r\n*(__be16 *)&regs->data[priv->sreg_proto_min];\r\nrange.max_proto.all =\r\n*(__be16 *)&regs->data[priv->sreg_proto_max];\r\nrange.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\r\n}\r\nrange.flags |= priv->flags;\r\nregs->verdict.code = nf_nat_setup_info(ct, &range, priv->type);\r\n}\r\nstatic int nft_nat_validate(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nft_data **data)\r\n{\r\nstruct nft_nat *priv = nft_expr_priv(expr);\r\nint err;\r\nerr = nft_chain_validate_dependency(ctx->chain, NFT_CHAIN_T_NAT);\r\nif (err < 0)\r\nreturn err;\r\nswitch (priv->type) {\r\ncase NFT_NAT_SNAT:\r\nerr = nft_chain_validate_hooks(ctx->chain,\r\n(1 << NF_INET_POST_ROUTING) |\r\n(1 << NF_INET_LOCAL_IN));\r\nbreak;\r\ncase NFT_NAT_DNAT:\r\nerr = nft_chain_validate_hooks(ctx->chain,\r\n(1 << NF_INET_PRE_ROUTING) |\r\n(1 << NF_INET_LOCAL_OUT));\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int nft_nat_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_nat *priv = nft_expr_priv(expr);\r\nunsigned int alen, plen;\r\nu32 family;\r\nint err;\r\nif (tb[NFTA_NAT_TYPE] == NULL ||\r\n(tb[NFTA_NAT_REG_ADDR_MIN] == NULL &&\r\ntb[NFTA_NAT_REG_PROTO_MIN] == NULL))\r\nreturn -EINVAL;\r\nswitch (ntohl(nla_get_be32(tb[NFTA_NAT_TYPE]))) {\r\ncase NFT_NAT_SNAT:\r\npriv->type = NF_NAT_MANIP_SRC;\r\nbreak;\r\ncase NFT_NAT_DNAT:\r\npriv->type = NF_NAT_MANIP_DST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = nft_nat_validate(ctx, expr, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_NAT_FAMILY] == NULL)\r\nreturn -EINVAL;\r\nfamily = ntohl(nla_get_be32(tb[NFTA_NAT_FAMILY]));\r\nif (family != ctx->afi->family)\r\nreturn -EOPNOTSUPP;\r\nswitch (family) {\r\ncase NFPROTO_IPV4:\r\nalen = FIELD_SIZEOF(struct nf_nat_range, min_addr.ip);\r\nbreak;\r\ncase NFPROTO_IPV6:\r\nalen = FIELD_SIZEOF(struct nf_nat_range, min_addr.ip6);\r\nbreak;\r\ndefault:\r\nreturn -EAFNOSUPPORT;\r\n}\r\npriv->family = family;\r\nif (tb[NFTA_NAT_REG_ADDR_MIN]) {\r\npriv->sreg_addr_min =\r\nnft_parse_register(tb[NFTA_NAT_REG_ADDR_MIN]);\r\nerr = nft_validate_register_load(priv->sreg_addr_min, alen);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_NAT_REG_ADDR_MAX]) {\r\npriv->sreg_addr_max =\r\nnft_parse_register(tb[NFTA_NAT_REG_ADDR_MAX]);\r\nerr = nft_validate_register_load(priv->sreg_addr_max,\r\nalen);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\npriv->sreg_addr_max = priv->sreg_addr_min;\r\n}\r\n}\r\nplen = FIELD_SIZEOF(struct nf_nat_range, min_addr.all);\r\nif (tb[NFTA_NAT_REG_PROTO_MIN]) {\r\npriv->sreg_proto_min =\r\nnft_parse_register(tb[NFTA_NAT_REG_PROTO_MIN]);\r\nerr = nft_validate_register_load(priv->sreg_proto_min, plen);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_NAT_REG_PROTO_MAX]) {\r\npriv->sreg_proto_max =\r\nnft_parse_register(tb[NFTA_NAT_REG_PROTO_MAX]);\r\nerr = nft_validate_register_load(priv->sreg_proto_max,\r\nplen);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\npriv->sreg_proto_max = priv->sreg_proto_min;\r\n}\r\n}\r\nif (tb[NFTA_NAT_FLAGS]) {\r\npriv->flags = ntohl(nla_get_be32(tb[NFTA_NAT_FLAGS]));\r\nif (priv->flags & ~NF_NAT_RANGE_MASK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nft_nat_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_nat *priv = nft_expr_priv(expr);\r\nswitch (priv->type) {\r\ncase NF_NAT_MANIP_SRC:\r\nif (nla_put_be32(skb, NFTA_NAT_TYPE, htonl(NFT_NAT_SNAT)))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase NF_NAT_MANIP_DST:\r\nif (nla_put_be32(skb, NFTA_NAT_TYPE, htonl(NFT_NAT_DNAT)))\r\ngoto nla_put_failure;\r\nbreak;\r\n}\r\nif (nla_put_be32(skb, NFTA_NAT_FAMILY, htonl(priv->family)))\r\ngoto nla_put_failure;\r\nif (priv->sreg_addr_min) {\r\nif (nft_dump_register(skb, NFTA_NAT_REG_ADDR_MIN,\r\npriv->sreg_addr_min) ||\r\nnft_dump_register(skb, NFTA_NAT_REG_ADDR_MAX,\r\npriv->sreg_addr_max))\r\ngoto nla_put_failure;\r\n}\r\nif (priv->sreg_proto_min) {\r\nif (nft_dump_register(skb, NFTA_NAT_REG_PROTO_MIN,\r\npriv->sreg_proto_min) ||\r\nnft_dump_register(skb, NFTA_NAT_REG_PROTO_MAX,\r\npriv->sreg_proto_max))\r\ngoto nla_put_failure;\r\n}\r\nif (priv->flags != 0) {\r\nif (nla_put_be32(skb, NFTA_NAT_FLAGS, htonl(priv->flags)))\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int __init nft_nat_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_nat_type);\r\n}\r\nstatic void __exit nft_nat_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_nat_type);\r\n}
