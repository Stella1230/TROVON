static acpi_status acpi_run_oshp(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer string = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &string);\r\nstatus = acpi_evaluate_object(handle, METHOD_NAME_OSHP, NULL, NULL);\r\nif (ACPI_FAILURE(status))\r\nif (status != AE_NOT_FOUND)\r\nprintk(KERN_ERR "%s:%s OSHP fails=0x%x\n",\r\n__func__, (char *)string.pointer, status);\r\nelse\r\ndbg("%s:%s OSHP not found\n",\r\n__func__, (char *)string.pointer);\r\nelse\r\npr_debug("%s:%s OSHP passes\n", __func__,\r\n(char *)string.pointer);\r\nkfree(string.pointer);\r\nreturn status;\r\n}\r\nint acpi_get_hp_hw_control_from_firmware(struct pci_dev *pdev, u32 flags)\r\n{\r\nacpi_status status;\r\nacpi_handle chandle, handle;\r\nstruct acpi_buffer string = { ACPI_ALLOCATE_BUFFER, NULL };\r\nflags &= OSC_PCI_SHPC_NATIVE_HP_CONTROL;\r\nif (!flags) {\r\nerr("Invalid flags %u specified!\n", flags);\r\nreturn -EINVAL;\r\n}\r\nhandle = acpi_find_root_bridge_handle(pdev);\r\nif (handle) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &string);\r\ndbg("Trying to get hotplug control for %s\n",\r\n(char *)string.pointer);\r\nstatus = acpi_pci_osc_control_set(handle, &flags, flags);\r\nif (ACPI_SUCCESS(status))\r\ngoto got_one;\r\nif (status == AE_SUPPORT)\r\ngoto no_control;\r\nkfree(string.pointer);\r\nstring = (struct acpi_buffer){ ACPI_ALLOCATE_BUFFER, NULL };\r\n}\r\nhandle = ACPI_HANDLE(&pdev->dev);\r\nif (!handle) {\r\nstruct pci_bus *pbus;\r\nfor (pbus = pdev->bus; pbus; pbus = pbus->parent) {\r\nhandle = acpi_pci_get_bridge_handle(pbus);\r\nif (handle)\r\nbreak;\r\n}\r\n}\r\nwhile (handle) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &string);\r\ndbg("Trying to get hotplug control for %s\n",\r\n(char *)string.pointer);\r\nstatus = acpi_run_oshp(handle);\r\nif (ACPI_SUCCESS(status))\r\ngoto got_one;\r\nif (acpi_is_root_bridge(handle))\r\nbreak;\r\nchandle = handle;\r\nstatus = acpi_get_parent(chandle, &handle);\r\nif (ACPI_FAILURE(status))\r\nbreak;\r\n}\r\nno_control:\r\ndbg("Cannot get control of hotplug hardware for pci %s\n",\r\npci_name(pdev));\r\nkfree(string.pointer);\r\nreturn -ENODEV;\r\ngot_one:\r\ndbg("Gained control for hotplug HW for pci %s (%s)\n",\r\npci_name(pdev), (char *)string.pointer);\r\nkfree(string.pointer);\r\nreturn 0;\r\n}\r\nstatic int pcihp_is_ejectable(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nunsigned long long removable;\r\nif (!acpi_has_method(handle, "_ADR"))\r\nreturn 0;\r\nif (acpi_has_method(handle, "_EJ0"))\r\nreturn 1;\r\nstatus = acpi_evaluate_integer(handle, "_RMV", NULL, &removable);\r\nif (ACPI_SUCCESS(status) && removable)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint acpi_pci_check_ejectable(struct pci_bus *pbus, acpi_handle handle)\r\n{\r\nacpi_handle bridge_handle, parent_handle;\r\nbridge_handle = acpi_pci_get_bridge_handle(pbus);\r\nif (!bridge_handle)\r\nreturn 0;\r\nif ((ACPI_FAILURE(acpi_get_parent(handle, &parent_handle))))\r\nreturn 0;\r\nif (bridge_handle != parent_handle)\r\nreturn 0;\r\nreturn pcihp_is_ejectable(handle);\r\n}\r\nstatic acpi_status\r\ncheck_hotplug(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nint *found = (int *)context;\r\nif (pcihp_is_ejectable(handle)) {\r\n*found = 1;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nreturn AE_OK;\r\n}\r\nint acpi_pci_detect_ejectable(acpi_handle handle)\r\n{\r\nint found = 0;\r\nif (!handle)\r\nreturn found;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,\r\ncheck_hotplug, NULL, (void *)&found, NULL);\r\nreturn found;\r\n}
