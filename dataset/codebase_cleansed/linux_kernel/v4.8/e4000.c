static int e4000_init(struct e4000_dev *dev)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_write(dev->regmap, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x06, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x7a, 0x96);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0x7e, "\x01\xfe", 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x82, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x24, 0x05);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0x87, "\x20\x01", 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0x9f, "\x7f\x07", 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x2d, 0x1f);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0x70, "\x01\x01", 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x1a, 0x17);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x1f, 0x1a);\r\nif (ret)\r\ngoto err;\r\ndev->active = true;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_sleep(struct e4000_dev *dev)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\ndev->active = false;\r\nret = regmap_write(dev->regmap, 0x00, 0x00);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_set_params(struct e4000_dev *dev)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nint ret, i;\r\nunsigned int div_n, k, k_cw, div_out;\r\nu64 f_vco;\r\nu8 buf[5], i_data[4], q_data[4];\r\nif (!dev->active) {\r\ndev_dbg(&client->dev, "tuner is sleeping\n");\r\nreturn 0;\r\n}\r\nret = regmap_write(dev->regmap, 0x1a, 0x00);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e4000_pll_lut); i++) {\r\nif (dev->f_frequency <= e4000_pll_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e4000_pll_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n#define F_REF dev->clk\r\ndiv_out = e4000_pll_lut[i].div_out;\r\nf_vco = (u64) dev->f_frequency * div_out;\r\ndiv_n = div_u64_rem(f_vco, F_REF, &k);\r\nk_cw = div_u64((u64) k * 0x10000, F_REF);\r\ndev_dbg(&client->dev,\r\n"frequency=%u bandwidth=%u f_vco=%llu F_REF=%u div_n=%u k=%u k_cw=%04x div_out=%u\n",\r\ndev->f_frequency, dev->f_bandwidth, f_vco, F_REF, div_n, k,\r\nk_cw, div_out);\r\nbuf[0] = div_n;\r\nbuf[1] = (k_cw >> 0) & 0xff;\r\nbuf[2] = (k_cw >> 8) & 0xff;\r\nbuf[3] = 0x00;\r\nbuf[4] = e4000_pll_lut[i].div_out_reg;\r\nret = regmap_bulk_write(dev->regmap, 0x09, buf, 5);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e400_lna_filter_lut); i++) {\r\nif (dev->f_frequency <= e400_lna_filter_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e400_lna_filter_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap, 0x10, e400_lna_filter_lut[i].val);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e4000_if_filter_lut); i++) {\r\nif (dev->f_bandwidth <= e4000_if_filter_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e4000_if_filter_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbuf[0] = e4000_if_filter_lut[i].reg11_val;\r\nbuf[1] = e4000_if_filter_lut[i].reg12_val;\r\nret = regmap_bulk_write(dev->regmap, 0x11, buf, 2);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e4000_band_lut); i++) {\r\nif (dev->f_frequency <= e4000_band_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e4000_band_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap, 0x07, e4000_band_lut[i].reg07_val);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x78, e4000_band_lut[i].reg78_val);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < 4; i++) {\r\nif (i == 0)\r\nret = regmap_bulk_write(dev->regmap, 0x15, "\x00\x7e\x24", 3);\r\nelse if (i == 1)\r\nret = regmap_bulk_write(dev->regmap, 0x15, "\x00\x7f", 2);\r\nelse if (i == 2)\r\nret = regmap_bulk_write(dev->regmap, 0x15, "\x01", 1);\r\nelse\r\nret = regmap_bulk_write(dev->regmap, 0x16, "\x7e", 1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x29, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_read(dev->regmap, 0x2a, buf, 3);\r\nif (ret)\r\ngoto err;\r\ni_data[i] = (((buf[2] >> 0) & 0x3) << 6) | (buf[0] & 0x3f);\r\nq_data[i] = (((buf[2] >> 4) & 0x3) << 6) | (buf[1] & 0x3f);\r\n}\r\nswap(q_data[2], q_data[3]);\r\nswap(i_data[2], i_data[3]);\r\nret = regmap_bulk_write(dev->regmap, 0x50, q_data, 4);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0x60, i_data, 4);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x1a, 0x17);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic inline struct e4000_dev *e4000_subdev_to_dev(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct e4000_dev, sd);\r\n}\r\nstatic int e4000_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ndev_dbg(&client->dev, "on=%d\n", on);\r\nif (on)\r\nret = e4000_init(dev);\r\nelse\r\nret = e4000_sleep(dev);\r\nif (ret)\r\nreturn ret;\r\nreturn e4000_set_params(dev);\r\n}\r\nstatic int e4000_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *v)\r\n{\r\nstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "index=%d\n", v->index);\r\nstrlcpy(v->name, "Elonics E4000", sizeof(v->name));\r\nv->type = V4L2_TUNER_RF;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = bands[0].rangelow;\r\nv->rangehigh = bands[1].rangehigh;\r\nreturn 0;\r\n}\r\nstatic int e4000_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *v)\r\n{\r\nstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "index=%d\n", v->index);\r\nreturn 0;\r\n}\r\nstatic int e4000_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\r\n{\r\nstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "tuner=%d\n", f->tuner);\r\nf->frequency = dev->f_frequency;\r\nreturn 0;\r\n}\r\nstatic int e4000_s_frequency(struct v4l2_subdev *sd,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "tuner=%d type=%d frequency=%u\n",\r\nf->tuner, f->type, f->frequency);\r\ndev->f_frequency = clamp_t(unsigned int, f->frequency,\r\nbands[0].rangelow, bands[1].rangehigh);\r\nreturn e4000_set_params(dev);\r\n}\r\nstatic int e4000_enum_freq_bands(struct v4l2_subdev *sd,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "tuner=%d type=%d index=%d\n",\r\nband->tuner, band->type, band->index);\r\nif (band->index >= ARRAY_SIZE(bands))\r\nreturn -EINVAL;\r\nband->capability = bands[band->index].capability;\r\nband->rangelow = bands[band->index].rangelow;\r\nband->rangehigh = bands[band->index].rangehigh;\r\nreturn 0;\r\n}\r\nstatic int e4000_set_lna_gain(struct dvb_frontend *fe)\r\n{\r\nstruct e4000_dev *dev = fe->tuner_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nu8 u8tmp;\r\ndev_dbg(&client->dev, "lna auto=%d->%d val=%d->%d\n",\r\ndev->lna_gain_auto->cur.val, dev->lna_gain_auto->val,\r\ndev->lna_gain->cur.val, dev->lna_gain->val);\r\nif (dev->lna_gain_auto->val && dev->if_gain_auto->cur.val)\r\nu8tmp = 0x17;\r\nelse if (dev->lna_gain_auto->val)\r\nu8tmp = 0x19;\r\nelse if (dev->if_gain_auto->cur.val)\r\nu8tmp = 0x16;\r\nelse\r\nu8tmp = 0x10;\r\nret = regmap_write(dev->regmap, 0x1a, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (dev->lna_gain_auto->val == false) {\r\nret = regmap_write(dev->regmap, 0x14, dev->lna_gain->val);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_set_mixer_gain(struct dvb_frontend *fe)\r\n{\r\nstruct e4000_dev *dev = fe->tuner_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nu8 u8tmp;\r\ndev_dbg(&client->dev, "mixer auto=%d->%d val=%d->%d\n",\r\ndev->mixer_gain_auto->cur.val, dev->mixer_gain_auto->val,\r\ndev->mixer_gain->cur.val, dev->mixer_gain->val);\r\nif (dev->mixer_gain_auto->val)\r\nu8tmp = 0x15;\r\nelse\r\nu8tmp = 0x14;\r\nret = regmap_write(dev->regmap, 0x20, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (dev->mixer_gain_auto->val == false) {\r\nret = regmap_write(dev->regmap, 0x15, dev->mixer_gain->val);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_set_if_gain(struct dvb_frontend *fe)\r\n{\r\nstruct e4000_dev *dev = fe->tuner_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nu8 buf[2];\r\nu8 u8tmp;\r\ndev_dbg(&client->dev, "if auto=%d->%d val=%d->%d\n",\r\ndev->if_gain_auto->cur.val, dev->if_gain_auto->val,\r\ndev->if_gain->cur.val, dev->if_gain->val);\r\nif (dev->if_gain_auto->val && dev->lna_gain_auto->cur.val)\r\nu8tmp = 0x17;\r\nelse if (dev->lna_gain_auto->cur.val)\r\nu8tmp = 0x19;\r\nelse if (dev->if_gain_auto->val)\r\nu8tmp = 0x16;\r\nelse\r\nu8tmp = 0x10;\r\nret = regmap_write(dev->regmap, 0x1a, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (dev->if_gain_auto->val == false) {\r\nbuf[0] = e4000_if_gain_lut[dev->if_gain->val].reg16_val;\r\nbuf[1] = e4000_if_gain_lut[dev->if_gain->val].reg17_val;\r\nret = regmap_bulk_write(dev->regmap, 0x16, buf, 2);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_pll_lock(struct dvb_frontend *fe)\r\n{\r\nstruct e4000_dev *dev = fe->tuner_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nunsigned int uitmp;\r\nret = regmap_read(dev->regmap, 0x07, &uitmp);\r\nif (ret)\r\ngoto err;\r\ndev->pll_lock->val = (uitmp & 0x01);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct e4000_dev *dev = container_of(ctrl->handler, struct e4000_dev, hdl);\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nif (!dev->active)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_PLL_LOCK:\r\nret = e4000_pll_lock(dev->fe);\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "unknown ctrl: id=%d name=%s\n",\r\nctrl->id, ctrl->name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int e4000_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct e4000_dev *dev = container_of(ctrl->handler, struct e4000_dev, hdl);\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nif (!dev->active)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH:\r\ndev->f_bandwidth = dev->bandwidth->val;\r\nret = e4000_set_params(dev);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN:\r\nret = e4000_set_lna_gain(dev->fe);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN:\r\nret = e4000_set_mixer_gain(dev->fe);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_IF_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_IF_GAIN:\r\nret = e4000_set_if_gain(dev->fe);\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "unknown ctrl: id=%d name=%s\n",\r\nctrl->id, ctrl->name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int e4000_dvb_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct e4000_dev *dev = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\ndev->f_frequency = c->frequency;\r\ndev->f_bandwidth = c->bandwidth_hz;\r\nreturn e4000_set_params(dev);\r\n}\r\nstatic int e4000_dvb_init(struct dvb_frontend *fe)\r\n{\r\nreturn e4000_init(fe->tuner_priv);\r\n}\r\nstatic int e4000_dvb_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn e4000_sleep(fe->tuner_priv);\r\n}\r\nstatic int e4000_dvb_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int e4000_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct e4000_dev *dev;\r\nstruct e4000_config *cfg = client->dev.platform_data;\r\nstruct dvb_frontend *fe = cfg->fe;\r\nint ret;\r\nunsigned int uitmp;\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n};\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->clk = cfg->clock;\r\ndev->client = client;\r\ndev->fe = cfg->fe;\r\ndev->regmap = devm_regmap_init_i2c(client, &regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err_kfree;\r\n}\r\nret = regmap_read(dev->regmap, 0x02, &uitmp);\r\nif (ret)\r\ngoto err_kfree;\r\ndev_dbg(&client->dev, "chip id=%02x\n", uitmp);\r\nif (uitmp != 0x40) {\r\nret = -ENODEV;\r\ngoto err_kfree;\r\n}\r\nret = regmap_write(dev->regmap, 0x00, 0x00);\r\nif (ret)\r\ngoto err_kfree;\r\n#if IS_ENABLED(CONFIG_VIDEO_V4L2)\r\nv4l2_ctrl_handler_init(&dev->hdl, 9);\r\ndev->bandwidth_auto = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH_AUTO, 0, 1, 1, 1);\r\ndev->bandwidth = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH, 4300000, 11000000, 100000, 4300000);\r\nv4l2_ctrl_auto_cluster(2, &dev->bandwidth_auto, 0, false);\r\ndev->lna_gain_auto = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 1);\r\ndev->lna_gain = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_LNA_GAIN, 0, 15, 1, 10);\r\nv4l2_ctrl_auto_cluster(2, &dev->lna_gain_auto, 0, false);\r\ndev->mixer_gain_auto = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 1);\r\ndev->mixer_gain = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 1, 1, 1);\r\nv4l2_ctrl_auto_cluster(2, &dev->mixer_gain_auto, 0, false);\r\ndev->if_gain_auto = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_IF_GAIN_AUTO, 0, 1, 1, 1);\r\ndev->if_gain = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_IF_GAIN, 0, 54, 1, 0);\r\nv4l2_ctrl_auto_cluster(2, &dev->if_gain_auto, 0, false);\r\ndev->pll_lock = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_PLL_LOCK, 0, 1, 1, 0);\r\nif (dev->hdl.error) {\r\nret = dev->hdl.error;\r\ndev_err(&client->dev, "Could not initialize controls\n");\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\ngoto err_kfree;\r\n}\r\ndev->sd.ctrl_handler = &dev->hdl;\r\ndev->f_frequency = bands[0].rangelow;\r\ndev->f_bandwidth = dev->bandwidth->val;\r\nv4l2_i2c_subdev_init(&dev->sd, client, &e4000_subdev_ops);\r\n#endif\r\nfe->tuner_priv = dev;\r\nmemcpy(&fe->ops.tuner_ops, &e4000_dvb_tuner_ops,\r\nsizeof(fe->ops.tuner_ops));\r\nv4l2_set_subdevdata(&dev->sd, client);\r\ni2c_set_clientdata(client, &dev->sd);\r\ndev_info(&client->dev, "Elonics E4000 successfully identified\n");\r\nreturn 0;\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct e4000_dev *dev = container_of(sd, struct e4000_dev, sd);\r\ndev_dbg(&client->dev, "\n");\r\n#if IS_ENABLED(CONFIG_VIDEO_V4L2)\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\n#endif\r\nkfree(dev);\r\nreturn 0;\r\n}
