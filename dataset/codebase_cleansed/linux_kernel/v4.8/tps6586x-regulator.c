static inline int tps6586x_regulator_preinit(struct device *parent,\r\nstruct tps6586x_regulator *ri)\r\n{\r\nuint8_t val1, val2;\r\nint ret;\r\nif (ri->enable_reg[0] == ri->enable_reg[1] &&\r\nri->enable_bit[0] == ri->enable_bit[1])\r\nreturn 0;\r\nret = tps6586x_read(parent, ri->enable_reg[0], &val1);\r\nif (ret)\r\nreturn ret;\r\nret = tps6586x_read(parent, ri->enable_reg[1], &val2);\r\nif (ret)\r\nreturn ret;\r\nif (!(val2 & (1 << ri->enable_bit[1])))\r\nreturn 0;\r\nif (!(val1 & (1 << ri->enable_bit[0]))) {\r\nret = tps6586x_set_bits(parent, ri->enable_reg[0],\r\n1 << ri->enable_bit[0]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn tps6586x_clr_bits(parent, ri->enable_reg[1],\r\n1 << ri->enable_bit[1]);\r\n}\r\nstatic int tps6586x_regulator_set_slew_rate(struct platform_device *pdev,\r\nint id, struct regulator_init_data *p)\r\n{\r\nstruct device *parent = pdev->dev.parent;\r\nstruct tps6586x_settings *setting = p->driver_data;\r\nuint8_t reg;\r\nif (setting == NULL)\r\nreturn 0;\r\nif (!(setting->slew_rate & TPS6586X_SLEW_RATE_SET))\r\nreturn 0;\r\nswitch (id) {\r\ncase TPS6586X_ID_SM_0:\r\nreg = TPS6586X_SM0SL;\r\nbreak;\r\ncase TPS6586X_ID_SM_1:\r\nreg = TPS6586X_SM1SL;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Only SM0/SM1 can set slew rate\n");\r\nreturn -EINVAL;\r\n}\r\nreturn tps6586x_write(parent, reg,\r\nsetting->slew_rate & TPS6586X_SLEW_RATE_MASK);\r\n}\r\nstatic struct tps6586x_regulator *find_regulator_info(int id, int version)\r\n{\r\nstruct tps6586x_regulator *ri;\r\nstruct tps6586x_regulator *table = NULL;\r\nint num;\r\nint i;\r\nswitch (version) {\r\ncase TPS658623:\r\ntable = tps658623_regulator;\r\nnum = ARRAY_SIZE(tps658623_regulator);\r\nbreak;\r\ncase TPS658640:\r\ncase TPS658640v2:\r\ntable = tps658640_regulator;\r\nnum = ARRAY_SIZE(tps658640_regulator);\r\nbreak;\r\ncase TPS658643:\r\ntable = tps658643_regulator;\r\nnum = ARRAY_SIZE(tps658643_regulator);\r\nbreak;\r\n}\r\nif (table) {\r\nfor (i = 0; i < num; i++) {\r\nri = &table[i];\r\nif (ri->desc.id == id)\r\nreturn ri;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(tps6586x_regulator); i++) {\r\nri = &tps6586x_regulator[i];\r\nif (ri->desc.id == id)\r\nreturn ri;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct tps6586x_platform_data *tps6586x_parse_regulator_dt(\r\nstruct platform_device *pdev,\r\nstruct of_regulator_match **tps6586x_reg_matches)\r\n{\r\nconst unsigned int num = ARRAY_SIZE(tps6586x_matches);\r\nstruct device_node *np = pdev->dev.parent->of_node;\r\nstruct device_node *regs;\r\nconst char *sys_rail = NULL;\r\nunsigned int i;\r\nstruct tps6586x_platform_data *pdata;\r\nint err;\r\nregs = of_get_child_by_name(np, "regulators");\r\nif (!regs) {\r\ndev_err(&pdev->dev, "regulator node not found\n");\r\nreturn NULL;\r\n}\r\nerr = of_regulator_match(&pdev->dev, regs, tps6586x_matches, num);\r\nof_node_put(regs);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "Regulator match failed, e %d\n", err);\r\nreturn NULL;\r\n}\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nfor (i = 0; i < num; i++) {\r\nuintptr_t id;\r\nif (!tps6586x_matches[i].init_data)\r\ncontinue;\r\npdata->reg_init_data[i] = tps6586x_matches[i].init_data;\r\nid = (uintptr_t)tps6586x_matches[i].driver_data;\r\nif (id == TPS6586X_ID_SYS)\r\nsys_rail = pdata->reg_init_data[i]->constraints.name;\r\nif ((id == TPS6586X_ID_LDO_5) || (id == TPS6586X_ID_LDO_RTC))\r\npdata->reg_init_data[i]->supply_regulator = sys_rail;\r\n}\r\n*tps6586x_reg_matches = tps6586x_matches;\r\nreturn pdata;\r\n}\r\nstatic struct tps6586x_platform_data *tps6586x_parse_regulator_dt(\r\nstruct platform_device *pdev,\r\nstruct of_regulator_match **tps6586x_reg_matches)\r\n{\r\n*tps6586x_reg_matches = NULL;\r\nreturn NULL;\r\n}\r\nstatic int tps6586x_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct tps6586x_regulator *ri = NULL;\r\nstruct regulator_config config = { };\r\nstruct regulator_dev *rdev;\r\nstruct regulator_init_data *reg_data;\r\nstruct tps6586x_platform_data *pdata;\r\nstruct of_regulator_match *tps6586x_reg_matches = NULL;\r\nint version;\r\nint id;\r\nint err;\r\ndev_dbg(&pdev->dev, "Probing regulator\n");\r\npdata = dev_get_platdata(pdev->dev.parent);\r\nif ((!pdata) && (pdev->dev.parent->of_node))\r\npdata = tps6586x_parse_regulator_dt(pdev,\r\n&tps6586x_reg_matches);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Platform data not available, exiting\n");\r\nreturn -ENODEV;\r\n}\r\nversion = tps6586x_get_version(pdev->dev.parent);\r\nfor (id = 0; id < TPS6586X_ID_MAX_REGULATOR; ++id) {\r\nreg_data = pdata->reg_init_data[id];\r\nri = find_regulator_info(id, version);\r\nif (!ri) {\r\ndev_err(&pdev->dev, "invalid regulator ID specified\n");\r\nreturn -EINVAL;\r\n}\r\nerr = tps6586x_regulator_preinit(pdev->dev.parent, ri);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"regulator %d preinit failed, e %d\n", id, err);\r\nreturn err;\r\n}\r\nconfig.dev = pdev->dev.parent;\r\nconfig.init_data = reg_data;\r\nconfig.driver_data = ri;\r\nif (tps6586x_reg_matches)\r\nconfig.of_node = tps6586x_reg_matches[id].of_node;\r\nrdev = devm_regulator_register(&pdev->dev, &ri->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "failed to register regulator %s\n",\r\nri->desc.name);\r\nreturn PTR_ERR(rdev);\r\n}\r\nif (reg_data) {\r\nerr = tps6586x_regulator_set_slew_rate(pdev, id,\r\nreg_data);\r\nif (err < 0) {\r\ndev_err(&pdev->dev,\r\n"Slew rate config failed, e %d\n", err);\r\nreturn err;\r\n}\r\n}\r\n}\r\nplatform_set_drvdata(pdev, rdev);\r\nreturn 0;\r\n}\r\nstatic int __init tps6586x_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&tps6586x_regulator_driver);\r\n}\r\nstatic void __exit tps6586x_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&tps6586x_regulator_driver);\r\n}
