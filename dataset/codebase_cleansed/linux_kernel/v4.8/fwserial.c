static inline void debug_short_write(struct fwtty_port *port, int c, int n)\r\n{\r\nint avail;\r\nif (n < c) {\r\nspin_lock_bh(&port->lock);\r\navail = dma_fifo_avail(&port->tx_fifo);\r\nspin_unlock_bh(&port->lock);\r\nfwtty_dbg(port, "short write: avail:%d req:%d wrote:%d\n",\r\navail, c, n);\r\n}\r\n}\r\nstatic void fwtty_profile_fifo(struct fwtty_port *port, unsigned int *stat)\r\n{\r\nspin_lock_bh(&port->lock);\r\nfwtty_profile_data(stat, dma_fifo_avail(&port->tx_fifo));\r\nspin_unlock_bh(&port->lock);\r\n}\r\nstatic void fwtty_dump_profile(struct seq_file *m, struct stats *stats)\r\n{\r\nint k = 4;\r\nunsigned int sum;\r\nint j;\r\nchar t[10];\r\nsnprintf(t, 10, "< %d", 1 << k);\r\nseq_printf(m, "\n%14s %6s", " ", t);\r\nfor (j = k + 1; j < DISTRIBUTION_MAX_INDEX; ++j)\r\nseq_printf(m, "%6d", 1 << j);\r\n++k;\r\nfor (j = 0, sum = 0; j <= k; ++j)\r\nsum += stats->reads[j];\r\nseq_printf(m, "\n%14s: %6d", "reads", sum);\r\nfor (j = k + 1; j <= DISTRIBUTION_MAX_INDEX; ++j)\r\nseq_printf(m, "%6d", stats->reads[j]);\r\nfor (j = 0, sum = 0; j <= k; ++j)\r\nsum += stats->writes[j];\r\nseq_printf(m, "\n%14s: %6d", "writes", sum);\r\nfor (j = k + 1; j <= DISTRIBUTION_MAX_INDEX; ++j)\r\nseq_printf(m, "%6d", stats->writes[j]);\r\nfor (j = 0, sum = 0; j <= k; ++j)\r\nsum += stats->txns[j];\r\nseq_printf(m, "\n%14s: %6d", "txns", sum);\r\nfor (j = k + 1; j <= DISTRIBUTION_MAX_INDEX; ++j)\r\nseq_printf(m, "%6d", stats->txns[j]);\r\nfor (j = 0, sum = 0; j <= k; ++j)\r\nsum += stats->unthrottle[j];\r\nseq_printf(m, "\n%14s: %6d", "avail @ unthr", sum);\r\nfor (j = k + 1; j <= DISTRIBUTION_MAX_INDEX; ++j)\r\nseq_printf(m, "%6d", stats->unthrottle[j]);\r\n}\r\nstatic inline int device_max_receive(struct fw_device *fw_device)\r\n{\r\nreturn min(2 << fw_device->max_rec, 4096);\r\n}\r\nstatic void fwtty_log_tx_error(struct fwtty_port *port, int rcode)\r\n{\r\nswitch (rcode) {\r\ncase RCODE_SEND_ERROR:\r\nfwtty_err_ratelimited(port, "card busy\n");\r\nbreak;\r\ncase RCODE_ADDRESS_ERROR:\r\nfwtty_err_ratelimited(port, "bad unit addr or write length\n");\r\nbreak;\r\ncase RCODE_DATA_ERROR:\r\nfwtty_err_ratelimited(port, "failed rx\n");\r\nbreak;\r\ncase RCODE_NO_ACK:\r\nfwtty_err_ratelimited(port, "missing ack\n");\r\nbreak;\r\ncase RCODE_BUSY:\r\nfwtty_err_ratelimited(port, "remote busy\n");\r\nbreak;\r\ndefault:\r\nfwtty_err_ratelimited(port, "failed tx: %d\n", rcode);\r\n}\r\n}\r\nstatic void fwtty_txn_constructor(void *this)\r\n{\r\nstruct fwtty_transaction *txn = this;\r\ninit_timer(&txn->fw_txn.split_timeout_timer);\r\n}\r\nstatic void fwtty_common_callback(struct fw_card *card, int rcode,\r\nvoid *payload, size_t len, void *cb_data)\r\n{\r\nstruct fwtty_transaction *txn = cb_data;\r\nstruct fwtty_port *port = txn->port;\r\nif (port && rcode != RCODE_COMPLETE)\r\nfwtty_log_tx_error(port, rcode);\r\nif (txn->callback)\r\ntxn->callback(card, rcode, payload, len, txn);\r\nkmem_cache_free(fwtty_txn_cache, txn);\r\n}\r\nstatic int fwtty_send_data_async(struct fwtty_peer *peer, int tcode,\r\nunsigned long long addr, void *payload,\r\nsize_t len, fwtty_transaction_cb callback,\r\nstruct fwtty_port *port)\r\n{\r\nstruct fwtty_transaction *txn;\r\nint generation;\r\ntxn = kmem_cache_alloc(fwtty_txn_cache, GFP_ATOMIC);\r\nif (!txn)\r\nreturn -ENOMEM;\r\ntxn->callback = callback;\r\ntxn->port = port;\r\ngeneration = peer->generation;\r\nsmp_rmb();\r\nfw_send_request(peer->serial->card, &txn->fw_txn, tcode,\r\npeer->node_id, generation, peer->speed, addr, payload,\r\nlen, fwtty_common_callback, txn);\r\nreturn 0;\r\n}\r\nstatic void fwtty_send_txn_async(struct fwtty_peer *peer,\r\nstruct fwtty_transaction *txn, int tcode,\r\nunsigned long long addr, void *payload,\r\nsize_t len, fwtty_transaction_cb callback,\r\nstruct fwtty_port *port)\r\n{\r\nint generation;\r\ntxn->callback = callback;\r\ntxn->port = port;\r\ngeneration = peer->generation;\r\nsmp_rmb();\r\nfw_send_request(peer->serial->card, &txn->fw_txn, tcode,\r\npeer->node_id, generation, peer->speed, addr, payload,\r\nlen, fwtty_common_callback, txn);\r\n}\r\nstatic void __fwtty_restart_tx(struct fwtty_port *port)\r\n{\r\nint len, avail;\r\nlen = dma_fifo_out_level(&port->tx_fifo);\r\nif (len)\r\nschedule_delayed_work(&port->drain, 0);\r\navail = dma_fifo_avail(&port->tx_fifo);\r\nfwtty_dbg(port, "fifo len: %d avail: %d\n", len, avail);\r\n}\r\nstatic void fwtty_restart_tx(struct fwtty_port *port)\r\n{\r\nspin_lock_bh(&port->lock);\r\n__fwtty_restart_tx(port);\r\nspin_unlock_bh(&port->lock);\r\n}\r\nstatic void fwtty_update_port_status(struct fwtty_port *port,\r\nunsigned int status)\r\n{\r\nunsigned int delta;\r\nstruct tty_struct *tty;\r\nstatus &= ~MCTRL_MASK;\r\ndelta = (port->mstatus ^ status) & ~MCTRL_MASK;\r\ndelta &= ~(status & TIOCM_RNG);\r\nport->mstatus = status;\r\nif (delta & TIOCM_RNG)\r\n++port->icount.rng;\r\nif (delta & TIOCM_DSR)\r\n++port->icount.dsr;\r\nif (delta & TIOCM_CAR)\r\n++port->icount.dcd;\r\nif (delta & TIOCM_CTS)\r\n++port->icount.cts;\r\nfwtty_dbg(port, "status: %x delta: %x\n", status, delta);\r\nif (delta & TIOCM_CAR) {\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && !C_CLOCAL(tty)) {\r\nif (status & TIOCM_CAR)\r\nwake_up_interruptible(&port->port.open_wait);\r\nelse\r\nschedule_work(&port->hangup);\r\n}\r\ntty_kref_put(tty);\r\n}\r\nif (delta & TIOCM_CTS) {\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && C_CRTSCTS(tty)) {\r\nif (tty->hw_stopped) {\r\nif (status & TIOCM_CTS) {\r\ntty->hw_stopped = 0;\r\nif (port->loopback)\r\n__fwtty_restart_tx(port);\r\nelse\r\nfwtty_restart_tx(port);\r\n}\r\n} else {\r\nif (~status & TIOCM_CTS)\r\ntty->hw_stopped = 1;\r\n}\r\n}\r\ntty_kref_put(tty);\r\n} else if (delta & OOB_TX_THROTTLE) {\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\nif (tty->hw_stopped) {\r\nif (~status & OOB_TX_THROTTLE) {\r\ntty->hw_stopped = 0;\r\nif (port->loopback)\r\n__fwtty_restart_tx(port);\r\nelse\r\nfwtty_restart_tx(port);\r\n}\r\n} else {\r\nif (status & OOB_TX_THROTTLE)\r\ntty->hw_stopped = 1;\r\n}\r\n}\r\ntty_kref_put(tty);\r\n}\r\nif (delta & (UART_LSR_BI << 24)) {\r\nif (status & (UART_LSR_BI << 24)) {\r\nport->break_last = jiffies;\r\nschedule_delayed_work(&port->emit_breaks, 0);\r\n} else {\r\nmod_delayed_work(system_wq, &port->emit_breaks, 0);\r\n}\r\n}\r\nif (delta & (TIOCM_DSR | TIOCM_CAR | TIOCM_CTS | TIOCM_RNG))\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\n}\r\nstatic unsigned int __fwtty_port_line_status(struct fwtty_port *port)\r\n{\r\nunsigned int status = 0;\r\nif (port->mctrl & TIOCM_DTR)\r\nstatus |= TIOCM_DSR | TIOCM_CAR;\r\nif (port->mctrl & TIOCM_RTS)\r\nstatus |= TIOCM_CTS;\r\nif (port->mctrl & OOB_RX_THROTTLE)\r\nstatus |= OOB_TX_THROTTLE;\r\nif (port->break_ctl)\r\nstatus |= UART_LSR_BI << 24;\r\nreturn status;\r\n}\r\nstatic int __fwtty_write_port_status(struct fwtty_port *port)\r\n{\r\nstruct fwtty_peer *peer;\r\nint err = -ENOENT;\r\nunsigned int status = __fwtty_port_line_status(port);\r\nrcu_read_lock();\r\npeer = rcu_dereference(port->peer);\r\nif (peer) {\r\nerr = fwtty_send_data_async(peer, TCODE_WRITE_QUADLET_REQUEST,\r\npeer->status_addr, &status,\r\nsizeof(status), NULL, port);\r\n}\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int fwtty_write_port_status(struct fwtty_port *port)\r\n{\r\nint err;\r\nspin_lock_bh(&port->lock);\r\nerr = __fwtty_write_port_status(port);\r\nspin_unlock_bh(&port->lock);\r\nreturn err;\r\n}\r\nstatic void fwtty_throttle_port(struct fwtty_port *port)\r\n{\r\nstruct tty_struct *tty;\r\nunsigned int old;\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty)\r\nreturn;\r\nspin_lock_bh(&port->lock);\r\nold = port->mctrl;\r\nport->mctrl |= OOB_RX_THROTTLE;\r\nif (C_CRTSCTS(tty))\r\nport->mctrl &= ~TIOCM_RTS;\r\nif (~old & OOB_RX_THROTTLE)\r\n__fwtty_write_port_status(port);\r\nspin_unlock_bh(&port->lock);\r\ntty_kref_put(tty);\r\n}\r\nstatic void fwtty_do_hangup(struct work_struct *work)\r\n{\r\nstruct fwtty_port *port = to_port(work, hangup);\r\nstruct tty_struct *tty;\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(50));\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty)\r\ntty_vhangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic void fwtty_emit_breaks(struct work_struct *work)\r\n{\r\nstruct fwtty_port *port = to_port(to_delayed_work(work), emit_breaks);\r\nstatic const char buf[16];\r\nunsigned long now = jiffies;\r\nunsigned long elapsed = now - port->break_last;\r\nint n, t, c, brk = 0;\r\nn = (elapsed * port->cps) / HZ + 1;\r\nport->break_last = now;\r\nfwtty_dbg(port, "sending %d brks\n", n);\r\nwhile (n) {\r\nt = min(n, 16);\r\nc = tty_insert_flip_string_fixed_flag(&port->port, buf,\r\nTTY_BREAK, t);\r\nn -= c;\r\nbrk += c;\r\nif (c < t)\r\nbreak;\r\n}\r\ntty_flip_buffer_push(&port->port);\r\nif (port->mstatus & (UART_LSR_BI << 24))\r\nschedule_delayed_work(&port->emit_breaks, FREQ_BREAKS);\r\nport->icount.brk += brk;\r\n}\r\nstatic int fwtty_rx(struct fwtty_port *port, unsigned char *data, size_t len)\r\n{\r\nint c, n = len;\r\nunsigned int lsr;\r\nint err = 0;\r\nfwtty_dbg(port, "%d\n", n);\r\nfwtty_profile_data(port->stats.reads, n);\r\nif (port->write_only) {\r\nn = 0;\r\ngoto out;\r\n}\r\nlsr = (port->mstatus >> 24) & ~UART_LSR_BI;\r\nif (port->overrun)\r\nlsr |= UART_LSR_OE;\r\nif (lsr & UART_LSR_OE)\r\n++port->icount.overrun;\r\nlsr &= port->status_mask;\r\nif (lsr & ~port->ignore_mask & UART_LSR_OE) {\r\nif (!tty_insert_flip_char(&port->port, 0, TTY_OVERRUN)) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\n}\r\nport->overrun = false;\r\nif (lsr & port->ignore_mask & ~UART_LSR_OE) {\r\nn = 0;\r\ngoto out;\r\n}\r\nc = tty_insert_flip_string_fixed_flag(&port->port, data, TTY_NORMAL, n);\r\nif (c > 0)\r\ntty_flip_buffer_push(&port->port);\r\nn -= c;\r\nif (n) {\r\nport->overrun = true;\r\nerr = -EIO;\r\nfwtty_err_ratelimited(port, "flip buffer overrun\n");\r\n} else {\r\nif (tty_buffer_space_avail(&port->port) < HIGH_WATERMARK)\r\nfwtty_throttle_port(port);\r\n}\r\nout:\r\nport->icount.rx += len;\r\nport->stats.lost += n;\r\nreturn err;\r\n}\r\nstatic void fwtty_port_handler(struct fw_card *card,\r\nstruct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation,\r\nunsigned long long addr,\r\nvoid *data, size_t len,\r\nvoid *callback_data)\r\n{\r\nstruct fwtty_port *port = callback_data;\r\nstruct fwtty_peer *peer;\r\nint err;\r\nint rcode;\r\nrcu_read_lock();\r\npeer = __fwserial_peer_by_node_id(card, generation, source);\r\nrcu_read_unlock();\r\nif (!peer || peer != rcu_access_pointer(port->peer)) {\r\nrcode = RCODE_ADDRESS_ERROR;\r\nfwtty_err_ratelimited(port, "ignoring unauthenticated data\n");\r\ngoto respond;\r\n}\r\nswitch (tcode) {\r\ncase TCODE_WRITE_QUADLET_REQUEST:\r\nif (addr != port->rx_handler.offset || len != 4) {\r\nrcode = RCODE_ADDRESS_ERROR;\r\n} else {\r\nfwtty_update_port_status(port, *(unsigned int *)data);\r\nrcode = RCODE_COMPLETE;\r\n}\r\nbreak;\r\ncase TCODE_WRITE_BLOCK_REQUEST:\r\nif (addr != port->rx_handler.offset + 4 ||\r\nlen > port->rx_handler.length - 4) {\r\nrcode = RCODE_ADDRESS_ERROR;\r\n} else {\r\nerr = fwtty_rx(port, data, len);\r\nswitch (err) {\r\ncase 0:\r\nrcode = RCODE_COMPLETE;\r\nbreak;\r\ncase -EIO:\r\nrcode = RCODE_DATA_ERROR;\r\nbreak;\r\ndefault:\r\nrcode = RCODE_CONFLICT_ERROR;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nrcode = RCODE_TYPE_ERROR;\r\n}\r\nrespond:\r\nfw_send_response(card, request, rcode);\r\n}\r\nstatic void fwtty_tx_complete(struct fw_card *card, int rcode,\r\nvoid *data, size_t length,\r\nstruct fwtty_transaction *txn)\r\n{\r\nstruct fwtty_port *port = txn->port;\r\nint len;\r\nfwtty_dbg(port, "rcode: %d\n", rcode);\r\nswitch (rcode) {\r\ncase RCODE_COMPLETE:\r\nspin_lock_bh(&port->lock);\r\ndma_fifo_out_complete(&port->tx_fifo, &txn->dma_pended);\r\nlen = dma_fifo_level(&port->tx_fifo);\r\nspin_unlock_bh(&port->lock);\r\nport->icount.tx += txn->dma_pended.len;\r\nbreak;\r\ndefault:\r\nspin_lock_bh(&port->lock);\r\ndma_fifo_out_complete(&port->tx_fifo, &txn->dma_pended);\r\nlen = dma_fifo_level(&port->tx_fifo);\r\nspin_unlock_bh(&port->lock);\r\nport->stats.dropped += txn->dma_pended.len;\r\n}\r\nif (len < WAKEUP_CHARS)\r\ntty_port_tty_wakeup(&port->port);\r\n}\r\nstatic int fwtty_tx(struct fwtty_port *port, bool drain)\r\n{\r\nstruct fwtty_peer *peer;\r\nstruct fwtty_transaction *txn;\r\nstruct tty_struct *tty;\r\nint n, len;\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty)\r\nreturn -ENOENT;\r\nrcu_read_lock();\r\npeer = rcu_dereference(port->peer);\r\nif (!peer) {\r\nn = -EIO;\r\ngoto out;\r\n}\r\nif (test_and_set_bit(IN_TX, &port->flags)) {\r\nn = -EALREADY;\r\ngoto out;\r\n}\r\nn = -EAGAIN;\r\nwhile (!tty->stopped && !tty->hw_stopped &&\r\n!test_bit(STOP_TX, &port->flags)) {\r\ntxn = kmem_cache_alloc(fwtty_txn_cache, GFP_ATOMIC);\r\nif (!txn) {\r\nn = -ENOMEM;\r\nbreak;\r\n}\r\nspin_lock_bh(&port->lock);\r\nn = dma_fifo_out_pend(&port->tx_fifo, &txn->dma_pended);\r\nspin_unlock_bh(&port->lock);\r\nfwtty_dbg(port, "out: %u rem: %d\n", txn->dma_pended.len, n);\r\nif (n < 0) {\r\nkmem_cache_free(fwtty_txn_cache, txn);\r\nif (n == -EAGAIN) {\r\n++port->stats.tx_stall;\r\n} else if (n == -ENODATA) {\r\nfwtty_profile_data(port->stats.txns, 0);\r\n} else {\r\n++port->stats.fifo_errs;\r\nfwtty_err_ratelimited(port, "fifo err: %d\n",\r\nn);\r\n}\r\nbreak;\r\n}\r\nfwtty_profile_data(port->stats.txns, txn->dma_pended.len);\r\nfwtty_send_txn_async(peer, txn, TCODE_WRITE_BLOCK_REQUEST,\r\npeer->fifo_addr, txn->dma_pended.data,\r\ntxn->dma_pended.len, fwtty_tx_complete,\r\nport);\r\n++port->stats.sent;\r\nif (n == 0 || (!drain && n < WRITER_MINIMUM))\r\nbreak;\r\n}\r\nif (n >= 0 || n == -EAGAIN || n == -ENOMEM || n == -ENODATA) {\r\nspin_lock_bh(&port->lock);\r\nlen = dma_fifo_out_level(&port->tx_fifo);\r\nif (len) {\r\nunsigned long delay = (n == -ENOMEM) ? HZ : 1;\r\nschedule_delayed_work(&port->drain, delay);\r\n}\r\nlen = dma_fifo_level(&port->tx_fifo);\r\nspin_unlock_bh(&port->lock);\r\nif (drain && len < WAKEUP_CHARS)\r\ntty_wakeup(tty);\r\n}\r\nclear_bit(IN_TX, &port->flags);\r\nwake_up_interruptible(&port->wait_tx);\r\nout:\r\nrcu_read_unlock();\r\ntty_kref_put(tty);\r\nreturn n;\r\n}\r\nstatic void fwtty_drain_tx(struct work_struct *work)\r\n{\r\nstruct fwtty_port *port = to_port(to_delayed_work(work), drain);\r\nfwtty_tx(port, true);\r\n}\r\nstatic void fwtty_write_xchar(struct fwtty_port *port, char ch)\r\n{\r\nstruct fwtty_peer *peer;\r\n++port->stats.xchars;\r\nfwtty_dbg(port, "%02x\n", ch);\r\nrcu_read_lock();\r\npeer = rcu_dereference(port->peer);\r\nif (peer) {\r\nfwtty_send_data_async(peer, TCODE_WRITE_BLOCK_REQUEST,\r\npeer->fifo_addr, &ch, sizeof(ch),\r\nNULL, port);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic struct fwtty_port *fwtty_port_get(unsigned int index)\r\n{\r\nstruct fwtty_port *port;\r\nif (index >= MAX_TOTAL_PORTS)\r\nreturn NULL;\r\nmutex_lock(&port_table_lock);\r\nport = port_table[index];\r\nif (port)\r\nkref_get(&port->serial->kref);\r\nmutex_unlock(&port_table_lock);\r\nreturn port;\r\n}\r\nstatic int fwtty_ports_add(struct fw_serial *serial)\r\n{\r\nint err = -EBUSY;\r\nint i, j;\r\nif (port_table_corrupt)\r\nreturn err;\r\nmutex_lock(&port_table_lock);\r\nfor (i = 0; i + num_ports <= MAX_TOTAL_PORTS; i += num_ports) {\r\nif (!port_table[i]) {\r\nfor (j = 0; j < num_ports; ++i, ++j) {\r\nserial->ports[j]->index = i;\r\nport_table[i] = serial->ports[j];\r\n}\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&port_table_lock);\r\nreturn err;\r\n}\r\nstatic void fwserial_destroy(struct kref *kref)\r\n{\r\nstruct fw_serial *serial = to_serial(kref, kref);\r\nstruct fwtty_port **ports = serial->ports;\r\nint j, i = ports[0]->index;\r\nsynchronize_rcu();\r\nmutex_lock(&port_table_lock);\r\nfor (j = 0; j < num_ports; ++i, ++j) {\r\nport_table_corrupt |= port_table[i] != ports[j];\r\nWARN_ONCE(port_table_corrupt, "port_table[%d]: %p != ports[%d]: %p",\r\ni, port_table[i], j, ports[j]);\r\nport_table[i] = NULL;\r\n}\r\nmutex_unlock(&port_table_lock);\r\nfor (j = 0; j < num_ports; ++j) {\r\nfw_core_remove_address_handler(&ports[j]->rx_handler);\r\ntty_port_destroy(&ports[j]->port);\r\nkfree(ports[j]);\r\n}\r\nkfree(serial);\r\n}\r\nstatic void fwtty_port_put(struct fwtty_port *port)\r\n{\r\nkref_put(&port->serial->kref, fwserial_destroy);\r\n}\r\nstatic void fwtty_port_dtr_rts(struct tty_port *tty_port, int on)\r\n{\r\nstruct fwtty_port *port = to_port(tty_port, port);\r\nfwtty_dbg(port, "on/off: %d\n", on);\r\nspin_lock_bh(&port->lock);\r\nif (!port->port.console) {\r\nif (on)\r\nport->mctrl |= TIOCM_DTR | TIOCM_RTS;\r\nelse\r\nport->mctrl &= ~(TIOCM_DTR | TIOCM_RTS);\r\n}\r\n__fwtty_write_port_status(port);\r\nspin_unlock_bh(&port->lock);\r\n}\r\nstatic int fwtty_port_carrier_raised(struct tty_port *tty_port)\r\n{\r\nstruct fwtty_port *port = to_port(tty_port, port);\r\nint rc;\r\nrc = (port->mstatus & TIOCM_CAR);\r\nfwtty_dbg(port, "%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic unsigned int set_termios(struct fwtty_port *port, struct tty_struct *tty)\r\n{\r\nunsigned int baud, frame;\r\nbaud = tty_termios_baud_rate(&tty->termios);\r\ntty_termios_encode_baud_rate(&tty->termios, baud, baud);\r\nframe = 12 + ((C_CSTOPB(tty)) ? 4 : 2) + ((C_PARENB(tty)) ? 2 : 0);\r\nswitch (C_CSIZE(tty)) {\r\ncase CS5:\r\nframe -= (C_CSTOPB(tty)) ? 1 : 0;\r\nbreak;\r\ncase CS6:\r\nframe += 2;\r\nbreak;\r\ncase CS7:\r\nframe += 4;\r\nbreak;\r\ncase CS8:\r\nframe += 6;\r\nbreak;\r\n}\r\nport->cps = (baud << 1) / frame;\r\nport->status_mask = UART_LSR_OE;\r\nif (_I_FLAG(tty, BRKINT | PARMRK))\r\nport->status_mask |= UART_LSR_BI;\r\nport->ignore_mask = 0;\r\nif (I_IGNBRK(tty)) {\r\nport->ignore_mask |= UART_LSR_BI;\r\nif (I_IGNPAR(tty))\r\nport->ignore_mask |= UART_LSR_OE;\r\n}\r\nport->write_only = !C_CREAD(tty);\r\nif (port->loopback) {\r\ntty->termios.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHOKE |\r\nECHONL | ECHOPRT | ECHOCTL);\r\ntty->termios.c_oflag &= ~ONLCR;\r\n}\r\nreturn baud;\r\n}\r\nstatic int fwtty_port_activate(struct tty_port *tty_port,\r\nstruct tty_struct *tty)\r\n{\r\nstruct fwtty_port *port = to_port(tty_port, port);\r\nunsigned int baud;\r\nint err;\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\nerr = dma_fifo_alloc(&port->tx_fifo, FWTTY_PORT_TXFIFO_LEN,\r\ncache_line_size(),\r\nport->max_payload,\r\nFWTTY_PORT_MAX_PEND_DMA,\r\nGFP_KERNEL);\r\nif (err)\r\nreturn err;\r\nspin_lock_bh(&port->lock);\r\nbaud = set_termios(port, tty);\r\nif (!port->port.console) {\r\nport->mctrl = 0;\r\nif (baud != 0)\r\nport->mctrl = TIOCM_DTR | TIOCM_RTS;\r\n}\r\nif (C_CRTSCTS(tty) && ~port->mstatus & TIOCM_CTS)\r\ntty->hw_stopped = 1;\r\n__fwtty_write_port_status(port);\r\nspin_unlock_bh(&port->lock);\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\nreturn 0;\r\n}\r\nstatic void fwtty_port_shutdown(struct tty_port *tty_port)\r\n{\r\nstruct fwtty_port *port = to_port(tty_port, port);\r\ncancel_delayed_work_sync(&port->emit_breaks);\r\ncancel_delayed_work_sync(&port->drain);\r\nspin_lock_bh(&port->lock);\r\nport->flags = 0;\r\nport->break_ctl = 0;\r\nport->overrun = 0;\r\n__fwtty_write_port_status(port);\r\ndma_fifo_free(&port->tx_fifo);\r\nspin_unlock_bh(&port->lock);\r\n}\r\nstatic int fwtty_open(struct tty_struct *tty, struct file *fp)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nreturn tty_port_open(&port->port, tty, fp);\r\n}\r\nstatic void fwtty_close(struct tty_struct *tty, struct file *fp)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\ntty_port_close(&port->port, tty, fp);\r\n}\r\nstatic void fwtty_hangup(struct tty_struct *tty)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\ntty_port_hangup(&port->port);\r\n}\r\nstatic void fwtty_cleanup(struct tty_struct *tty)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\ntty->driver_data = NULL;\r\nfwtty_port_put(port);\r\n}\r\nstatic int fwtty_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nstruct fwtty_port *port = fwtty_port_get(tty->index);\r\nint err;\r\nerr = tty_standard_install(driver, tty);\r\nif (!err)\r\ntty->driver_data = port;\r\nelse\r\nfwtty_port_put(port);\r\nreturn err;\r\n}\r\nstatic int fwloop_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nstruct fwtty_port *port = fwtty_port_get(table_idx(tty->index));\r\nint err;\r\nerr = tty_standard_install(driver, tty);\r\nif (!err)\r\ntty->driver_data = port;\r\nelse\r\nfwtty_port_put(port);\r\nreturn err;\r\n}\r\nstatic int fwtty_write(struct tty_struct *tty, const unsigned char *buf, int c)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nint n, len;\r\nfwtty_dbg(port, "%d\n", c);\r\nfwtty_profile_data(port->stats.writes, c);\r\nspin_lock_bh(&port->lock);\r\nn = dma_fifo_in(&port->tx_fifo, buf, c);\r\nlen = dma_fifo_out_level(&port->tx_fifo);\r\nif (len < DRAIN_THRESHOLD)\r\nschedule_delayed_work(&port->drain, 1);\r\nspin_unlock_bh(&port->lock);\r\nif (len >= DRAIN_THRESHOLD)\r\nfwtty_tx(port, false);\r\ndebug_short_write(port, c, n);\r\nreturn (n < 0) ? 0 : n;\r\n}\r\nstatic int fwtty_write_room(struct tty_struct *tty)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nint n;\r\nspin_lock_bh(&port->lock);\r\nn = dma_fifo_avail(&port->tx_fifo);\r\nspin_unlock_bh(&port->lock);\r\nfwtty_dbg(port, "%d\n", n);\r\nreturn n;\r\n}\r\nstatic int fwtty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nint n;\r\nspin_lock_bh(&port->lock);\r\nn = dma_fifo_level(&port->tx_fifo);\r\nspin_unlock_bh(&port->lock);\r\nfwtty_dbg(port, "%d\n", n);\r\nreturn n;\r\n}\r\nstatic void fwtty_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nfwtty_dbg(port, "%02x\n", ch);\r\nfwtty_write_xchar(port, ch);\r\n}\r\nstatic void fwtty_throttle(struct tty_struct *tty)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\n++port->stats.throttled;\r\n}\r\nstatic void fwtty_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nfwtty_dbg(port, "CRTSCTS: %d\n", C_CRTSCTS(tty) != 0);\r\nfwtty_profile_fifo(port, port->stats.unthrottle);\r\nspin_lock_bh(&port->lock);\r\nport->mctrl &= ~OOB_RX_THROTTLE;\r\nif (C_CRTSCTS(tty))\r\nport->mctrl |= TIOCM_RTS;\r\n__fwtty_write_port_status(port);\r\nspin_unlock_bh(&port->lock);\r\n}\r\nstatic int check_msr_delta(struct fwtty_port *port, unsigned long mask,\r\nstruct async_icount *prev)\r\n{\r\nstruct async_icount now;\r\nint delta;\r\nnow = port->icount;\r\ndelta = ((mask & TIOCM_RNG && prev->rng != now.rng) ||\r\n(mask & TIOCM_DSR && prev->dsr != now.dsr) ||\r\n(mask & TIOCM_CAR && prev->dcd != now.dcd) ||\r\n(mask & TIOCM_CTS && prev->cts != now.cts));\r\n*prev = now;\r\nreturn delta;\r\n}\r\nstatic int wait_msr_change(struct fwtty_port *port, unsigned long mask)\r\n{\r\nstruct async_icount prev;\r\nprev = port->icount;\r\nreturn wait_event_interruptible(port->port.delta_msr_wait,\r\ncheck_msr_delta(port, mask, &prev));\r\n}\r\nstatic int get_serial_info(struct fwtty_port *port,\r\nstruct serial_struct __user *info)\r\n{\r\nstruct serial_struct tmp;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.type = PORT_UNKNOWN;\r\ntmp.line = port->port.tty->index;\r\ntmp.flags = port->port.flags;\r\ntmp.xmit_fifo_size = FWTTY_PORT_TXFIFO_LEN;\r\ntmp.baud_base = 400000000;\r\ntmp.close_delay = port->port.close_delay;\r\nreturn (copy_to_user(info, &tmp, sizeof(*info))) ? -EFAULT : 0;\r\n}\r\nstatic int set_serial_info(struct fwtty_port *port,\r\nstruct serial_struct __user *info)\r\n{\r\nstruct serial_struct tmp;\r\nif (copy_from_user(&tmp, info, sizeof(tmp)))\r\nreturn -EFAULT;\r\nif (tmp.irq != 0 || tmp.port != 0 || tmp.custom_divisor != 0 ||\r\ntmp.baud_base != 400000000)\r\nreturn -EPERM;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif (((tmp.flags & ~ASYNC_USR_MASK) !=\r\n(port->port.flags & ~ASYNC_USR_MASK)))\r\nreturn -EPERM;\r\n} else {\r\nport->port.close_delay = tmp.close_delay * HZ / 100;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fwtty_ioctl(struct tty_struct *tty, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nint err;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nmutex_lock(&port->port.mutex);\r\nerr = get_serial_info(port, (void __user *)arg);\r\nmutex_unlock(&port->port.mutex);\r\nbreak;\r\ncase TIOCSSERIAL:\r\nmutex_lock(&port->port.mutex);\r\nerr = set_serial_info(port, (void __user *)arg);\r\nmutex_unlock(&port->port.mutex);\r\nbreak;\r\ncase TIOCMIWAIT:\r\nerr = wait_msr_change(port, arg);\r\nbreak;\r\ndefault:\r\nerr = -ENOIOCTLCMD;\r\n}\r\nreturn err;\r\n}\r\nstatic void fwtty_set_termios(struct tty_struct *tty, struct ktermios *old)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nunsigned int baud;\r\nspin_lock_bh(&port->lock);\r\nbaud = set_termios(port, tty);\r\nif ((baud == 0) && (old->c_cflag & CBAUD)) {\r\nport->mctrl &= ~(TIOCM_DTR | TIOCM_RTS);\r\n} else if ((baud != 0) && !(old->c_cflag & CBAUD)) {\r\nif (C_CRTSCTS(tty) || !tty_throttled(tty))\r\nport->mctrl |= TIOCM_DTR | TIOCM_RTS;\r\nelse\r\nport->mctrl |= TIOCM_DTR;\r\n}\r\n__fwtty_write_port_status(port);\r\nspin_unlock_bh(&port->lock);\r\nif (old->c_cflag & CRTSCTS) {\r\nif (!C_CRTSCTS(tty)) {\r\ntty->hw_stopped = 0;\r\nfwtty_restart_tx(port);\r\n}\r\n} else if (C_CRTSCTS(tty) && ~port->mstatus & TIOCM_CTS) {\r\ntty->hw_stopped = 1;\r\n}\r\n}\r\nstatic int fwtty_break_ctl(struct tty_struct *tty, int state)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nlong ret;\r\nfwtty_dbg(port, "%d\n", state);\r\nif (state == -1) {\r\nset_bit(STOP_TX, &port->flags);\r\nret = wait_event_interruptible_timeout(port->wait_tx,\r\n!test_bit(IN_TX, &port->flags),\r\n10);\r\nif (ret == 0 || ret == -ERESTARTSYS) {\r\nclear_bit(STOP_TX, &port->flags);\r\nfwtty_restart_tx(port);\r\nreturn -EINTR;\r\n}\r\n}\r\nspin_lock_bh(&port->lock);\r\nport->break_ctl = (state == -1);\r\n__fwtty_write_port_status(port);\r\nspin_unlock_bh(&port->lock);\r\nif (state == 0) {\r\nspin_lock_bh(&port->lock);\r\ndma_fifo_reset(&port->tx_fifo);\r\nclear_bit(STOP_TX, &port->flags);\r\nspin_unlock_bh(&port->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fwtty_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nunsigned int tiocm;\r\nspin_lock_bh(&port->lock);\r\ntiocm = (port->mctrl & MCTRL_MASK) | (port->mstatus & ~MCTRL_MASK);\r\nspin_unlock_bh(&port->lock);\r\nfwtty_dbg(port, "%x\n", tiocm);\r\nreturn tiocm;\r\n}\r\nstatic int fwtty_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nfwtty_dbg(port, "set: %x clear: %x\n", set, clear);\r\nspin_lock_bh(&port->lock);\r\nport->mctrl &= ~(clear & MCTRL_MASK & 0xffff);\r\nport->mctrl |= set & MCTRL_MASK & 0xffff;\r\n__fwtty_write_port_status(port);\r\nspin_unlock_bh(&port->lock);\r\nreturn 0;\r\n}\r\nstatic int fwtty_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct fwtty_port *port = tty->driver_data;\r\nstruct stats stats;\r\nmemcpy(&stats, &port->stats, sizeof(stats));\r\nif (port->port.console)\r\n(*port->fwcon_ops->stats)(&stats, port->con_data);\r\nicount->cts = port->icount.cts;\r\nicount->dsr = port->icount.dsr;\r\nicount->rng = port->icount.rng;\r\nicount->dcd = port->icount.dcd;\r\nicount->rx = port->icount.rx;\r\nicount->tx = port->icount.tx + stats.xchars;\r\nicount->frame = port->icount.frame;\r\nicount->overrun = port->icount.overrun;\r\nicount->parity = port->icount.parity;\r\nicount->brk = port->icount.brk;\r\nicount->buf_overrun = port->icount.overrun;\r\nreturn 0;\r\n}\r\nstatic void fwtty_proc_show_port(struct seq_file *m, struct fwtty_port *port)\r\n{\r\nstruct stats stats;\r\nmemcpy(&stats, &port->stats, sizeof(stats));\r\nif (port->port.console)\r\n(*port->fwcon_ops->stats)(&stats, port->con_data);\r\nseq_printf(m, " addr:%012llx tx:%d rx:%d", port->rx_handler.offset,\r\nport->icount.tx + stats.xchars, port->icount.rx);\r\nseq_printf(m, " cts:%d dsr:%d rng:%d dcd:%d", port->icount.cts,\r\nport->icount.dsr, port->icount.rng, port->icount.dcd);\r\nseq_printf(m, " fe:%d oe:%d pe:%d brk:%d", port->icount.frame,\r\nport->icount.overrun, port->icount.parity, port->icount.brk);\r\n}\r\nstatic void fwtty_debugfs_show_port(struct seq_file *m, struct fwtty_port *port)\r\n{\r\nstruct stats stats;\r\nmemcpy(&stats, &port->stats, sizeof(stats));\r\nif (port->port.console)\r\n(*port->fwcon_ops->stats)(&stats, port->con_data);\r\nseq_printf(m, " dr:%d st:%d err:%d lost:%d", stats.dropped,\r\nstats.tx_stall, stats.fifo_errs, stats.lost);\r\nseq_printf(m, " pkts:%d thr:%d", stats.sent, stats.throttled);\r\nif (port->port.console) {\r\nseq_puts(m, "\n ");\r\n(*port->fwcon_ops->proc_show)(m, port->con_data);\r\n}\r\nfwtty_dump_profile(m, &port->stats);\r\n}\r\nstatic void fwtty_debugfs_show_peer(struct seq_file *m, struct fwtty_peer *peer)\r\n{\r\nint generation = peer->generation;\r\nsmp_rmb();\r\nseq_printf(m, " %s:", dev_name(&peer->unit->device));\r\nseq_printf(m, " node:%04x gen:%d", peer->node_id, generation);\r\nseq_printf(m, " sp:%d max:%d guid:%016llx", peer->speed,\r\npeer->max_payload, (unsigned long long)peer->guid);\r\nseq_printf(m, " mgmt:%012llx", (unsigned long long)peer->mgmt_addr);\r\nseq_printf(m, " addr:%012llx", (unsigned long long)peer->status_addr);\r\nseq_putc(m, '\n');\r\n}\r\nstatic int fwtty_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct fwtty_port *port;\r\nint i;\r\nseq_puts(m, "fwserinfo: 1.0 driver: 1.0\n");\r\nfor (i = 0; i < MAX_TOTAL_PORTS && (port = fwtty_port_get(i)); ++i) {\r\nseq_printf(m, "%2d:", i);\r\nif (capable(CAP_SYS_ADMIN))\r\nfwtty_proc_show_port(m, port);\r\nfwtty_port_put(port);\r\nseq_puts(m, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int fwtty_debugfs_stats_show(struct seq_file *m, void *v)\r\n{\r\nstruct fw_serial *serial = m->private;\r\nstruct fwtty_port *port;\r\nint i;\r\nfor (i = 0; i < num_ports; ++i) {\r\nport = fwtty_port_get(serial->ports[i]->index);\r\nif (port) {\r\nseq_printf(m, "%2d:", port->index);\r\nfwtty_proc_show_port(m, port);\r\nfwtty_debugfs_show_port(m, port);\r\nfwtty_port_put(port);\r\nseq_puts(m, "\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fwtty_debugfs_peers_show(struct seq_file *m, void *v)\r\n{\r\nstruct fw_serial *serial = m->private;\r\nstruct fwtty_peer *peer;\r\nrcu_read_lock();\r\nseq_printf(m, "card: %s guid: %016llx\n",\r\ndev_name(serial->card->device),\r\n(unsigned long long)serial->card->guid);\r\nlist_for_each_entry_rcu(peer, &serial->peer_list, list)\r\nfwtty_debugfs_show_peer(m, peer);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int fwtty_proc_open(struct inode *inode, struct file *fp)\r\n{\r\nreturn single_open(fp, fwtty_proc_show, NULL);\r\n}\r\nstatic int fwtty_stats_open(struct inode *inode, struct file *fp)\r\n{\r\nreturn single_open(fp, fwtty_debugfs_stats_show, inode->i_private);\r\n}\r\nstatic int fwtty_peers_open(struct inode *inode, struct file *fp)\r\n{\r\nreturn single_open(fp, fwtty_debugfs_peers_show, inode->i_private);\r\n}\r\nstatic inline int mgmt_pkt_expected_len(__be16 code)\r\n{\r\nstatic const struct fwserial_mgmt_pkt pkt;\r\nswitch (be16_to_cpu(code)) {\r\ncase FWSC_VIRT_CABLE_PLUG:\r\nreturn sizeof(pkt.hdr) + sizeof(pkt.plug_req);\r\ncase FWSC_VIRT_CABLE_PLUG_RSP:\r\nreturn sizeof(pkt.hdr) + sizeof(pkt.plug_rsp);\r\ncase FWSC_VIRT_CABLE_UNPLUG:\r\ncase FWSC_VIRT_CABLE_UNPLUG_RSP:\r\ncase FWSC_VIRT_CABLE_PLUG_RSP | FWSC_RSP_NACK:\r\ncase FWSC_VIRT_CABLE_UNPLUG_RSP | FWSC_RSP_NACK:\r\nreturn sizeof(pkt.hdr);\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic inline void fill_plug_params(struct virt_plug_params *params,\r\nstruct fwtty_port *port)\r\n{\r\nu64 status_addr = port->rx_handler.offset;\r\nu64 fifo_addr = port->rx_handler.offset + 4;\r\nsize_t fifo_len = port->rx_handler.length - 4;\r\nparams->status_hi = cpu_to_be32(status_addr >> 32);\r\nparams->status_lo = cpu_to_be32(status_addr);\r\nparams->fifo_hi = cpu_to_be32(fifo_addr >> 32);\r\nparams->fifo_lo = cpu_to_be32(fifo_addr);\r\nparams->fifo_len = cpu_to_be32(fifo_len);\r\n}\r\nstatic inline void fill_plug_req(struct fwserial_mgmt_pkt *pkt,\r\nstruct fwtty_port *port)\r\n{\r\npkt->hdr.code = cpu_to_be16(FWSC_VIRT_CABLE_PLUG);\r\npkt->hdr.len = cpu_to_be16(mgmt_pkt_expected_len(pkt->hdr.code));\r\nfill_plug_params(&pkt->plug_req, port);\r\n}\r\nstatic inline void fill_plug_rsp_ok(struct fwserial_mgmt_pkt *pkt,\r\nstruct fwtty_port *port)\r\n{\r\npkt->hdr.code = cpu_to_be16(FWSC_VIRT_CABLE_PLUG_RSP);\r\npkt->hdr.len = cpu_to_be16(mgmt_pkt_expected_len(pkt->hdr.code));\r\nfill_plug_params(&pkt->plug_rsp, port);\r\n}\r\nstatic inline void fill_plug_rsp_nack(struct fwserial_mgmt_pkt *pkt)\r\n{\r\npkt->hdr.code = cpu_to_be16(FWSC_VIRT_CABLE_PLUG_RSP | FWSC_RSP_NACK);\r\npkt->hdr.len = cpu_to_be16(mgmt_pkt_expected_len(pkt->hdr.code));\r\n}\r\nstatic inline void fill_unplug_req(struct fwserial_mgmt_pkt *pkt)\r\n{\r\npkt->hdr.code = cpu_to_be16(FWSC_VIRT_CABLE_UNPLUG);\r\npkt->hdr.len = cpu_to_be16(mgmt_pkt_expected_len(pkt->hdr.code));\r\n}\r\nstatic inline void fill_unplug_rsp_nack(struct fwserial_mgmt_pkt *pkt)\r\n{\r\npkt->hdr.code = cpu_to_be16(FWSC_VIRT_CABLE_UNPLUG_RSP | FWSC_RSP_NACK);\r\npkt->hdr.len = cpu_to_be16(mgmt_pkt_expected_len(pkt->hdr.code));\r\n}\r\nstatic inline void fill_unplug_rsp_ok(struct fwserial_mgmt_pkt *pkt)\r\n{\r\npkt->hdr.code = cpu_to_be16(FWSC_VIRT_CABLE_UNPLUG_RSP);\r\npkt->hdr.len = cpu_to_be16(mgmt_pkt_expected_len(pkt->hdr.code));\r\n}\r\nstatic void fwserial_virt_plug_complete(struct fwtty_peer *peer,\r\nstruct virt_plug_params *params)\r\n{\r\nstruct fwtty_port *port = peer->port;\r\npeer->status_addr = be32_to_u64(params->status_hi, params->status_lo);\r\npeer->fifo_addr = be32_to_u64(params->fifo_hi, params->fifo_lo);\r\npeer->fifo_len = be32_to_cpu(params->fifo_len);\r\npeer_set_state(peer, FWPS_ATTACHED);\r\nspin_lock_bh(&port->lock);\r\nport->max_payload = min(peer->max_payload, peer->fifo_len);\r\ndma_fifo_change_tx_limit(&port->tx_fifo, port->max_payload);\r\nspin_unlock_bh(&peer->port->lock);\r\nif (port->port.console && port->fwcon_ops->notify)\r\n(*port->fwcon_ops->notify)(FWCON_NOTIFY_ATTACH, port->con_data);\r\nfwtty_info(&peer->unit, "peer (guid:%016llx) connected on %s\n",\r\n(unsigned long long)peer->guid, dev_name(port->device));\r\n}\r\nstatic inline int fwserial_send_mgmt_sync(struct fwtty_peer *peer,\r\nstruct fwserial_mgmt_pkt *pkt)\r\n{\r\nint generation;\r\nint rcode, tries = 5;\r\ndo {\r\ngeneration = peer->generation;\r\nsmp_rmb();\r\nrcode = fw_run_transaction(peer->serial->card,\r\nTCODE_WRITE_BLOCK_REQUEST,\r\npeer->node_id,\r\ngeneration, peer->speed,\r\npeer->mgmt_addr,\r\npkt, be16_to_cpu(pkt->hdr.len));\r\nif (rcode == RCODE_BUSY || rcode == RCODE_SEND_ERROR ||\r\nrcode == RCODE_GENERATION) {\r\nfwtty_dbg(&peer->unit, "mgmt write error: %d\n", rcode);\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n} while (--tries > 0);\r\nreturn rcode;\r\n}\r\nstatic struct fwtty_port *fwserial_claim_port(struct fwtty_peer *peer,\r\nint index)\r\n{\r\nstruct fwtty_port *port;\r\nif (index < 0 || index >= num_ports)\r\nreturn ERR_PTR(-EINVAL);\r\nsynchronize_rcu();\r\nport = peer->serial->ports[index];\r\nspin_lock_bh(&port->lock);\r\nif (!rcu_access_pointer(port->peer))\r\nrcu_assign_pointer(port->peer, peer);\r\nelse\r\nport = ERR_PTR(-EBUSY);\r\nspin_unlock_bh(&port->lock);\r\nreturn port;\r\n}\r\nstatic struct fwtty_port *fwserial_find_port(struct fwtty_peer *peer)\r\n{\r\nstruct fwtty_port **ports = peer->serial->ports;\r\nint i;\r\nsynchronize_rcu();\r\nfor (i = 0; i < num_ttys; ++i) {\r\nspin_lock_bh(&ports[i]->lock);\r\nif (!ports[i]->peer) {\r\nrcu_assign_pointer(ports[i]->peer, peer);\r\nspin_unlock_bh(&ports[i]->lock);\r\nreturn ports[i];\r\n}\r\nspin_unlock_bh(&ports[i]->lock);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void fwserial_release_port(struct fwtty_port *port, bool reset)\r\n{\r\nif (reset)\r\nfwtty_update_port_status(port, 0);\r\nspin_lock_bh(&port->lock);\r\nport->max_payload = link_speed_to_max_payload(SCODE_100);\r\ndma_fifo_change_tx_limit(&port->tx_fifo, port->max_payload);\r\nRCU_INIT_POINTER(port->peer, NULL);\r\nspin_unlock_bh(&port->lock);\r\nif (port->port.console && port->fwcon_ops->notify)\r\n(*port->fwcon_ops->notify)(FWCON_NOTIFY_DETACH, port->con_data);\r\n}\r\nstatic void fwserial_plug_timeout(unsigned long data)\r\n{\r\nstruct fwtty_peer *peer = (struct fwtty_peer *)data;\r\nstruct fwtty_port *port;\r\nspin_lock_bh(&peer->lock);\r\nif (peer->state != FWPS_PLUG_PENDING) {\r\nspin_unlock_bh(&peer->lock);\r\nreturn;\r\n}\r\nport = peer_revert_state(peer);\r\nspin_unlock_bh(&peer->lock);\r\nif (port)\r\nfwserial_release_port(port, false);\r\n}\r\nstatic int fwserial_connect_peer(struct fwtty_peer *peer)\r\n{\r\nstruct fwtty_port *port;\r\nstruct fwserial_mgmt_pkt *pkt;\r\nint err, rcode;\r\npkt = kmalloc(sizeof(*pkt), GFP_KERNEL);\r\nif (!pkt)\r\nreturn -ENOMEM;\r\nport = fwserial_find_port(peer);\r\nif (!port) {\r\nfwtty_err(&peer->unit, "avail ports in use\n");\r\nerr = -EBUSY;\r\ngoto free_pkt;\r\n}\r\nspin_lock_bh(&peer->lock);\r\nif (peer->state != FWPS_NOT_ATTACHED) {\r\nerr = -EBUSY;\r\ngoto release_port;\r\n}\r\npeer->port = port;\r\npeer_set_state(peer, FWPS_PLUG_PENDING);\r\nfill_plug_req(pkt, peer->port);\r\nsetup_timer(&peer->timer, fwserial_plug_timeout, (unsigned long)peer);\r\nmod_timer(&peer->timer, jiffies + VIRT_CABLE_PLUG_TIMEOUT);\r\nspin_unlock_bh(&peer->lock);\r\nrcode = fwserial_send_mgmt_sync(peer, pkt);\r\nspin_lock_bh(&peer->lock);\r\nif (peer->state == FWPS_PLUG_PENDING && rcode != RCODE_COMPLETE) {\r\nif (rcode == RCODE_CONFLICT_ERROR)\r\nerr = -EAGAIN;\r\nelse\r\nerr = -EIO;\r\ngoto cancel_timer;\r\n}\r\nspin_unlock_bh(&peer->lock);\r\nkfree(pkt);\r\nreturn 0;\r\ncancel_timer:\r\ndel_timer(&peer->timer);\r\npeer_revert_state(peer);\r\nrelease_port:\r\nspin_unlock_bh(&peer->lock);\r\nfwserial_release_port(port, false);\r\nfree_pkt:\r\nkfree(pkt);\r\nreturn err;\r\n}\r\nstatic void fwserial_close_port(struct tty_driver *driver,\r\nstruct fwtty_port *port)\r\n{\r\nstruct tty_struct *tty;\r\nmutex_lock(&port->port.mutex);\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\ntty_vhangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nmutex_unlock(&port->port.mutex);\r\nif (driver == fwloop_driver)\r\ntty_unregister_device(driver, loop_idx(port));\r\nelse\r\ntty_unregister_device(driver, port->index);\r\n}\r\nstatic struct fw_serial *fwserial_lookup(struct fw_card *card)\r\n{\r\nstruct fw_serial *serial;\r\nlist_for_each_entry(serial, &fwserial_list, list) {\r\nif (card == serial->card)\r\nreturn serial;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct fw_serial *__fwserial_lookup_rcu(struct fw_card *card)\r\n{\r\nstruct fw_serial *serial;\r\nlist_for_each_entry_rcu(serial, &fwserial_list, list) {\r\nif (card == serial->card)\r\nreturn serial;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct fwtty_peer *__fwserial_peer_by_node_id(struct fw_card *card,\r\nint generation, int id)\r\n{\r\nstruct fw_serial *serial;\r\nstruct fwtty_peer *peer;\r\nserial = __fwserial_lookup_rcu(card);\r\nif (!serial) {\r\nfwtty_err(card, "unknown card (guid %016llx)\n",\r\n(unsigned long long)card->guid);\r\nreturn NULL;\r\n}\r\nlist_for_each_entry_rcu(peer, &serial->peer_list, list) {\r\nint g = peer->generation;\r\nsmp_rmb();\r\nif (generation == g && id == peer->node_id)\r\nreturn peer;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __dump_peer_list(struct fw_card *card)\r\n{\r\nstruct fw_serial *serial;\r\nstruct fwtty_peer *peer;\r\nserial = __fwserial_lookup_rcu(card);\r\nif (!serial)\r\nreturn;\r\nlist_for_each_entry_rcu(peer, &serial->peer_list, list) {\r\nint g = peer->generation;\r\nsmp_rmb();\r\nfwtty_dbg(card, "peer(%d:%x) guid: %016llx\n",\r\ng, peer->node_id, (unsigned long long)peer->guid);\r\n}\r\n}\r\nstatic void fwserial_auto_connect(struct work_struct *work)\r\n{\r\nstruct fwtty_peer *peer = to_peer(to_delayed_work(work), connect);\r\nint err;\r\nerr = fwserial_connect_peer(peer);\r\nif (err == -EAGAIN && ++peer->connect_retries < MAX_CONNECT_RETRIES)\r\nschedule_delayed_work(&peer->connect, CONNECT_RETRY_DELAY);\r\n}\r\nstatic void fwserial_peer_workfn(struct work_struct *work)\r\n{\r\nstruct fwtty_peer *peer = to_peer(work, work);\r\npeer->workfn(work);\r\n}\r\nstatic int fwserial_add_peer(struct fw_serial *serial, struct fw_unit *unit)\r\n{\r\nstruct device *dev = &unit->device;\r\nstruct fw_device *parent = fw_parent_device(unit);\r\nstruct fwtty_peer *peer;\r\nstruct fw_csr_iterator ci;\r\nint key, val;\r\nint generation;\r\npeer = kzalloc(sizeof(*peer), GFP_KERNEL);\r\nif (!peer)\r\nreturn -ENOMEM;\r\npeer_set_state(peer, FWPS_NOT_ATTACHED);\r\ndev_set_drvdata(dev, peer);\r\npeer->unit = unit;\r\npeer->guid = (u64)parent->config_rom[3] << 32 | parent->config_rom[4];\r\npeer->speed = parent->max_speed;\r\npeer->max_payload = min(device_max_receive(parent),\r\nlink_speed_to_max_payload(peer->speed));\r\ngeneration = parent->generation;\r\nsmp_rmb();\r\npeer->node_id = parent->node_id;\r\nsmp_wmb();\r\npeer->generation = generation;\r\nfw_csr_iterator_init(&ci, unit->directory);\r\nwhile (fw_csr_iterator_next(&ci, &key, &val)) {\r\nif (key == (CSR_OFFSET | CSR_DEPENDENT_INFO)) {\r\npeer->mgmt_addr = CSR_REGISTER_BASE + 4 * val;\r\nbreak;\r\n}\r\n}\r\nif (peer->mgmt_addr == 0ULL) {\r\npeer_set_state(peer, FWPS_NO_MGMT_ADDR);\r\n}\r\nspin_lock_init(&peer->lock);\r\npeer->port = NULL;\r\ninit_timer(&peer->timer);\r\nINIT_WORK(&peer->work, fwserial_peer_workfn);\r\nINIT_DELAYED_WORK(&peer->connect, fwserial_auto_connect);\r\npeer->serial = serial;\r\nlist_add_rcu(&peer->list, &serial->peer_list);\r\nfwtty_info(&peer->unit, "peer added (guid:%016llx)\n",\r\n(unsigned long long)peer->guid);\r\nif (parent->is_local) {\r\nserial->self = peer;\r\nif (create_loop_dev) {\r\nstruct fwtty_port *port;\r\nport = fwserial_claim_port(peer, num_ttys);\r\nif (!IS_ERR(port)) {\r\nstruct virt_plug_params params;\r\nspin_lock_bh(&peer->lock);\r\npeer->port = port;\r\nfill_plug_params(&params, port);\r\nfwserial_virt_plug_complete(peer, &params);\r\nspin_unlock_bh(&peer->lock);\r\nfwtty_write_port_status(port);\r\n}\r\n}\r\n} else if (auto_connect) {\r\nschedule_delayed_work(&peer->connect, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fwserial_remove_peer(struct fwtty_peer *peer)\r\n{\r\nstruct fwtty_port *port;\r\nspin_lock_bh(&peer->lock);\r\npeer_set_state(peer, FWPS_GONE);\r\nspin_unlock_bh(&peer->lock);\r\ncancel_delayed_work_sync(&peer->connect);\r\ncancel_work_sync(&peer->work);\r\nspin_lock_bh(&peer->lock);\r\nif (peer == peer->serial->self)\r\npeer->serial->self = NULL;\r\ndel_timer(&peer->timer);\r\nport = peer->port;\r\npeer->port = NULL;\r\nlist_del_rcu(&peer->list);\r\nfwtty_info(&peer->unit, "peer removed (guid:%016llx)\n",\r\n(unsigned long long)peer->guid);\r\nspin_unlock_bh(&peer->lock);\r\nif (port)\r\nfwserial_release_port(port, true);\r\nsynchronize_rcu();\r\nkfree(peer);\r\n}\r\nstatic int fwserial_create(struct fw_unit *unit)\r\n{\r\nstruct fw_device *parent = fw_parent_device(unit);\r\nstruct fw_card *card = parent->card;\r\nstruct fw_serial *serial;\r\nstruct fwtty_port *port;\r\nstruct device *tty_dev;\r\nint i, j;\r\nint err;\r\nserial = kzalloc(sizeof(*serial), GFP_KERNEL);\r\nif (!serial)\r\nreturn -ENOMEM;\r\nkref_init(&serial->kref);\r\nserial->card = card;\r\nINIT_LIST_HEAD(&serial->peer_list);\r\nfor (i = 0; i < num_ports; ++i) {\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port) {\r\nerr = -ENOMEM;\r\ngoto free_ports;\r\n}\r\ntty_port_init(&port->port);\r\nport->index = FWTTY_INVALID_INDEX;\r\nport->port.ops = &fwtty_port_ops;\r\nport->serial = serial;\r\ntty_buffer_set_limit(&port->port, 128 * 1024);\r\nspin_lock_init(&port->lock);\r\nINIT_DELAYED_WORK(&port->drain, fwtty_drain_tx);\r\nINIT_DELAYED_WORK(&port->emit_breaks, fwtty_emit_breaks);\r\nINIT_WORK(&port->hangup, fwtty_do_hangup);\r\ninit_waitqueue_head(&port->wait_tx);\r\nport->max_payload = link_speed_to_max_payload(SCODE_100);\r\ndma_fifo_init(&port->tx_fifo);\r\nRCU_INIT_POINTER(port->peer, NULL);\r\nserial->ports[i] = port;\r\nport->rx_handler.length = FWTTY_PORT_RXFIFO_LEN + 4;\r\nport->rx_handler.address_callback = fwtty_port_handler;\r\nport->rx_handler.callback_data = port;\r\nerr = fw_core_add_address_handler(&port->rx_handler,\r\n&fw_high_memory_region);\r\nif (err) {\r\nkfree(port);\r\ngoto free_ports;\r\n}\r\n}\r\nerr = fwtty_ports_add(serial);\r\nif (err) {\r\nfwtty_err(&unit, "no space in port table\n");\r\ngoto free_ports;\r\n}\r\nfor (j = 0; j < num_ttys; ++j) {\r\ntty_dev = tty_port_register_device(&serial->ports[j]->port,\r\nfwtty_driver,\r\nserial->ports[j]->index,\r\ncard->device);\r\nif (IS_ERR(tty_dev)) {\r\nerr = PTR_ERR(tty_dev);\r\nfwtty_err(&unit, "register tty device error (%d)\n",\r\nerr);\r\ngoto unregister_ttys;\r\n}\r\nserial->ports[j]->device = tty_dev;\r\n}\r\nif (create_loop_dev) {\r\nstruct device *loop_dev;\r\nloop_dev = tty_port_register_device(&serial->ports[j]->port,\r\nfwloop_driver,\r\nloop_idx(serial->ports[j]),\r\ncard->device);\r\nif (IS_ERR(loop_dev)) {\r\nerr = PTR_ERR(loop_dev);\r\nfwtty_err(&unit, "create loop device failed (%d)\n",\r\nerr);\r\ngoto unregister_ttys;\r\n}\r\nserial->ports[j]->device = loop_dev;\r\nserial->ports[j]->loopback = true;\r\n}\r\nif (!IS_ERR_OR_NULL(fwserial_debugfs)) {\r\nserial->debugfs = debugfs_create_dir(dev_name(&unit->device),\r\nfwserial_debugfs);\r\nif (!IS_ERR_OR_NULL(serial->debugfs)) {\r\ndebugfs_create_file("peers", 0444, serial->debugfs,\r\nserial, &fwtty_peers_fops);\r\ndebugfs_create_file("stats", 0444, serial->debugfs,\r\nserial, &fwtty_stats_fops);\r\n}\r\n}\r\nlist_add_rcu(&serial->list, &fwserial_list);\r\nfwtty_notice(&unit, "TTY over FireWire on device %s (guid %016llx)\n",\r\ndev_name(card->device), (unsigned long long)card->guid);\r\nerr = fwserial_add_peer(serial, unit);\r\nif (!err)\r\nreturn 0;\r\nfwtty_err(&unit, "unable to add peer unit device (%d)\n", err);\r\ndebugfs_remove_recursive(serial->debugfs);\r\nlist_del_rcu(&serial->list);\r\nif (create_loop_dev)\r\ntty_unregister_device(fwloop_driver,\r\nloop_idx(serial->ports[j]));\r\nunregister_ttys:\r\nfor (--j; j >= 0; --j)\r\ntty_unregister_device(fwtty_driver, serial->ports[j]->index);\r\nkref_put(&serial->kref, fwserial_destroy);\r\nreturn err;\r\nfree_ports:\r\nfor (--i; i >= 0; --i) {\r\ntty_port_destroy(&serial->ports[i]->port);\r\nkfree(serial->ports[i]);\r\n}\r\nkfree(serial);\r\nreturn err;\r\n}\r\nstatic int fwserial_probe(struct fw_unit *unit,\r\nconst struct ieee1394_device_id *id)\r\n{\r\nstruct fw_serial *serial;\r\nint err;\r\nmutex_lock(&fwserial_list_mutex);\r\nserial = fwserial_lookup(fw_parent_device(unit)->card);\r\nif (!serial)\r\nerr = fwserial_create(unit);\r\nelse\r\nerr = fwserial_add_peer(serial, unit);\r\nmutex_unlock(&fwserial_list_mutex);\r\nreturn err;\r\n}\r\nstatic void fwserial_remove(struct fw_unit *unit)\r\n{\r\nstruct fwtty_peer *peer = dev_get_drvdata(&unit->device);\r\nstruct fw_serial *serial = peer->serial;\r\nint i;\r\nmutex_lock(&fwserial_list_mutex);\r\nfwserial_remove_peer(peer);\r\nif (list_empty(&serial->peer_list)) {\r\nlist_del_rcu(&serial->list);\r\ndebugfs_remove_recursive(serial->debugfs);\r\nfor (i = 0; i < num_ttys; ++i)\r\nfwserial_close_port(fwtty_driver, serial->ports[i]);\r\nif (create_loop_dev)\r\nfwserial_close_port(fwloop_driver, serial->ports[i]);\r\nkref_put(&serial->kref, fwserial_destroy);\r\n}\r\nmutex_unlock(&fwserial_list_mutex);\r\n}\r\nstatic void fwserial_update(struct fw_unit *unit)\r\n{\r\nstruct fw_device *parent = fw_parent_device(unit);\r\nstruct fwtty_peer *peer = dev_get_drvdata(&unit->device);\r\nint generation;\r\ngeneration = parent->generation;\r\nsmp_rmb();\r\npeer->node_id = parent->node_id;\r\nsmp_wmb();\r\npeer->generation = generation;\r\n}\r\nstatic void fwserial_handle_plug_req(struct work_struct *work)\r\n{\r\nstruct fwtty_peer *peer = to_peer(work, work);\r\nstruct virt_plug_params *plug_req = &peer->work_params.plug_req;\r\nstruct fwtty_port *port;\r\nstruct fwserial_mgmt_pkt *pkt;\r\nint rcode;\r\npkt = kmalloc(sizeof(*pkt), GFP_KERNEL);\r\nif (!pkt)\r\nreturn;\r\nport = fwserial_find_port(peer);\r\nspin_lock_bh(&peer->lock);\r\nswitch (peer->state) {\r\ncase FWPS_NOT_ATTACHED:\r\nif (!port) {\r\nfwtty_err(&peer->unit, "no more ports avail\n");\r\nfill_plug_rsp_nack(pkt);\r\n} else {\r\npeer->port = port;\r\nfill_plug_rsp_ok(pkt, peer->port);\r\npeer_set_state(peer, FWPS_PLUG_RESPONDING);\r\nport = NULL;\r\n}\r\nbreak;\r\ncase FWPS_PLUG_PENDING:\r\nif (peer->serial->card->guid > peer->guid)\r\ngoto cleanup;\r\ndel_timer(&peer->timer);\r\nfill_plug_rsp_ok(pkt, peer->port);\r\npeer_set_state(peer, FWPS_PLUG_RESPONDING);\r\nbreak;\r\ndefault:\r\nfill_plug_rsp_nack(pkt);\r\n}\r\nspin_unlock_bh(&peer->lock);\r\nif (port)\r\nfwserial_release_port(port, false);\r\nrcode = fwserial_send_mgmt_sync(peer, pkt);\r\nspin_lock_bh(&peer->lock);\r\nif (peer->state == FWPS_PLUG_RESPONDING) {\r\nif (rcode == RCODE_COMPLETE) {\r\nstruct fwtty_port *tmp = peer->port;\r\nfwserial_virt_plug_complete(peer, plug_req);\r\nspin_unlock_bh(&peer->lock);\r\nfwtty_write_port_status(tmp);\r\nspin_lock_bh(&peer->lock);\r\n} else {\r\nfwtty_err(&peer->unit, "PLUG_RSP error (%d)\n", rcode);\r\nport = peer_revert_state(peer);\r\n}\r\n}\r\ncleanup:\r\nspin_unlock_bh(&peer->lock);\r\nif (port)\r\nfwserial_release_port(port, false);\r\nkfree(pkt);\r\n}\r\nstatic void fwserial_handle_unplug_req(struct work_struct *work)\r\n{\r\nstruct fwtty_peer *peer = to_peer(work, work);\r\nstruct fwtty_port *port = NULL;\r\nstruct fwserial_mgmt_pkt *pkt;\r\nint rcode;\r\npkt = kmalloc(sizeof(*pkt), GFP_KERNEL);\r\nif (!pkt)\r\nreturn;\r\nspin_lock_bh(&peer->lock);\r\nswitch (peer->state) {\r\ncase FWPS_ATTACHED:\r\nfill_unplug_rsp_ok(pkt);\r\npeer_set_state(peer, FWPS_UNPLUG_RESPONDING);\r\nbreak;\r\ncase FWPS_UNPLUG_PENDING:\r\nif (peer->serial->card->guid > peer->guid)\r\ngoto cleanup;\r\ndel_timer(&peer->timer);\r\nfill_unplug_rsp_ok(pkt);\r\npeer_set_state(peer, FWPS_UNPLUG_RESPONDING);\r\nbreak;\r\ndefault:\r\nfill_unplug_rsp_nack(pkt);\r\n}\r\nspin_unlock_bh(&peer->lock);\r\nrcode = fwserial_send_mgmt_sync(peer, pkt);\r\nspin_lock_bh(&peer->lock);\r\nif (peer->state == FWPS_UNPLUG_RESPONDING) {\r\nif (rcode != RCODE_COMPLETE)\r\nfwtty_err(&peer->unit, "UNPLUG_RSP error (%d)\n",\r\nrcode);\r\nport = peer_revert_state(peer);\r\n}\r\ncleanup:\r\nspin_unlock_bh(&peer->lock);\r\nif (port)\r\nfwserial_release_port(port, true);\r\nkfree(pkt);\r\n}\r\nstatic int fwserial_parse_mgmt_write(struct fwtty_peer *peer,\r\nstruct fwserial_mgmt_pkt *pkt,\r\nunsigned long long addr,\r\nsize_t len)\r\n{\r\nstruct fwtty_port *port = NULL;\r\nbool reset = false;\r\nint rcode;\r\nif (addr != fwserial_mgmt_addr_handler.offset || len < sizeof(pkt->hdr))\r\nreturn RCODE_ADDRESS_ERROR;\r\nif (len != be16_to_cpu(pkt->hdr.len) ||\r\nlen != mgmt_pkt_expected_len(pkt->hdr.code))\r\nreturn RCODE_DATA_ERROR;\r\nspin_lock_bh(&peer->lock);\r\nif (peer->state == FWPS_GONE) {\r\nfwtty_err(&peer->unit, "peer already removed\n");\r\nspin_unlock_bh(&peer->lock);\r\nreturn RCODE_ADDRESS_ERROR;\r\n}\r\nrcode = RCODE_COMPLETE;\r\nfwtty_dbg(&peer->unit, "mgmt: hdr.code: %04hx\n", pkt->hdr.code);\r\nswitch (be16_to_cpu(pkt->hdr.code) & FWSC_CODE_MASK) {\r\ncase FWSC_VIRT_CABLE_PLUG:\r\nif (work_pending(&peer->work)) {\r\nfwtty_err(&peer->unit, "plug req: busy\n");\r\nrcode = RCODE_CONFLICT_ERROR;\r\n} else {\r\npeer->work_params.plug_req = pkt->plug_req;\r\npeer->workfn = fwserial_handle_plug_req;\r\nqueue_work(system_unbound_wq, &peer->work);\r\n}\r\nbreak;\r\ncase FWSC_VIRT_CABLE_PLUG_RSP:\r\nif (peer->state != FWPS_PLUG_PENDING) {\r\nrcode = RCODE_CONFLICT_ERROR;\r\n} else if (be16_to_cpu(pkt->hdr.code) & FWSC_RSP_NACK) {\r\nfwtty_notice(&peer->unit, "NACK plug rsp\n");\r\nport = peer_revert_state(peer);\r\n} else {\r\nstruct fwtty_port *tmp = peer->port;\r\nfwserial_virt_plug_complete(peer, &pkt->plug_rsp);\r\nspin_unlock_bh(&peer->lock);\r\nfwtty_write_port_status(tmp);\r\nspin_lock_bh(&peer->lock);\r\n}\r\nbreak;\r\ncase FWSC_VIRT_CABLE_UNPLUG:\r\nif (work_pending(&peer->work)) {\r\nfwtty_err(&peer->unit, "unplug req: busy\n");\r\nrcode = RCODE_CONFLICT_ERROR;\r\n} else {\r\npeer->workfn = fwserial_handle_unplug_req;\r\nqueue_work(system_unbound_wq, &peer->work);\r\n}\r\nbreak;\r\ncase FWSC_VIRT_CABLE_UNPLUG_RSP:\r\nif (peer->state != FWPS_UNPLUG_PENDING) {\r\nrcode = RCODE_CONFLICT_ERROR;\r\n} else {\r\nif (be16_to_cpu(pkt->hdr.code) & FWSC_RSP_NACK)\r\nfwtty_notice(&peer->unit, "NACK unplug?\n");\r\nport = peer_revert_state(peer);\r\nreset = true;\r\n}\r\nbreak;\r\ndefault:\r\nfwtty_err(&peer->unit, "unknown mgmt code %d\n",\r\nbe16_to_cpu(pkt->hdr.code));\r\nrcode = RCODE_DATA_ERROR;\r\n}\r\nspin_unlock_bh(&peer->lock);\r\nif (port)\r\nfwserial_release_port(port, reset);\r\nreturn rcode;\r\n}\r\nstatic void fwserial_mgmt_handler(struct fw_card *card,\r\nstruct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation,\r\nunsigned long long addr,\r\nvoid *data, size_t len,\r\nvoid *callback_data)\r\n{\r\nstruct fwserial_mgmt_pkt *pkt = data;\r\nstruct fwtty_peer *peer;\r\nint rcode;\r\nrcu_read_lock();\r\npeer = __fwserial_peer_by_node_id(card, generation, source);\r\nif (!peer) {\r\nfwtty_dbg(card, "peer(%d:%x) not found\n", generation, source);\r\n__dump_peer_list(card);\r\nrcode = RCODE_CONFLICT_ERROR;\r\n} else {\r\nswitch (tcode) {\r\ncase TCODE_WRITE_BLOCK_REQUEST:\r\nrcode = fwserial_parse_mgmt_write(peer, pkt, addr, len);\r\nbreak;\r\ndefault:\r\nrcode = RCODE_TYPE_ERROR;\r\n}\r\n}\r\nrcu_read_unlock();\r\nfw_send_response(card, request, rcode);\r\n}\r\nstatic int __init fwserial_init(void)\r\n{\r\nint err, num_loops = !!(create_loop_dev);\r\nfwserial_debugfs = debugfs_create_dir(KBUILD_MODNAME, NULL);\r\nif (num_ttys + num_loops > MAX_CARD_PORTS)\r\nnum_ttys = MAX_CARD_PORTS - num_loops;\r\nnum_ports = num_ttys + num_loops;\r\nfwtty_driver = tty_alloc_driver(MAX_TOTAL_PORTS, TTY_DRIVER_REAL_RAW\r\n| TTY_DRIVER_DYNAMIC_DEV);\r\nif (IS_ERR(fwtty_driver)) {\r\nerr = PTR_ERR(fwtty_driver);\r\ngoto remove_debugfs;\r\n}\r\nfwtty_driver->driver_name = KBUILD_MODNAME;\r\nfwtty_driver->name = tty_dev_name;\r\nfwtty_driver->major = 0;\r\nfwtty_driver->minor_start = 0;\r\nfwtty_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nfwtty_driver->subtype = SERIAL_TYPE_NORMAL;\r\nfwtty_driver->init_termios = tty_std_termios;\r\nfwtty_driver->init_termios.c_cflag |= CLOCAL;\r\ntty_set_operations(fwtty_driver, &fwtty_ops);\r\nerr = tty_register_driver(fwtty_driver);\r\nif (err) {\r\npr_err("register tty driver failed (%d)\n", err);\r\ngoto put_tty;\r\n}\r\nif (create_loop_dev) {\r\nfwloop_driver = tty_alloc_driver(MAX_TOTAL_PORTS / num_ports,\r\nTTY_DRIVER_REAL_RAW\r\n| TTY_DRIVER_DYNAMIC_DEV);\r\nif (IS_ERR(fwloop_driver)) {\r\nerr = PTR_ERR(fwloop_driver);\r\ngoto unregister_driver;\r\n}\r\nfwloop_driver->driver_name = KBUILD_MODNAME "_loop";\r\nfwloop_driver->name = loop_dev_name;\r\nfwloop_driver->major = 0;\r\nfwloop_driver->minor_start = 0;\r\nfwloop_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nfwloop_driver->subtype = SERIAL_TYPE_NORMAL;\r\nfwloop_driver->init_termios = tty_std_termios;\r\nfwloop_driver->init_termios.c_cflag |= CLOCAL;\r\ntty_set_operations(fwloop_driver, &fwloop_ops);\r\nerr = tty_register_driver(fwloop_driver);\r\nif (err) {\r\npr_err("register loop driver failed (%d)\n", err);\r\ngoto put_loop;\r\n}\r\n}\r\nfwtty_txn_cache = kmem_cache_create("fwtty_txn_cache",\r\nsizeof(struct fwtty_transaction),\r\n0, 0, fwtty_txn_constructor);\r\nif (!fwtty_txn_cache) {\r\nerr = -ENOMEM;\r\ngoto unregister_loop;\r\n}\r\nfwserial_mgmt_addr_handler.length = sizeof(struct fwserial_mgmt_pkt);\r\nfwserial_mgmt_addr_handler.address_callback = fwserial_mgmt_handler;\r\nerr = fw_core_add_address_handler(&fwserial_mgmt_addr_handler,\r\n&fwserial_mgmt_addr_region);\r\nif (err) {\r\npr_err("add management handler failed (%d)\n", err);\r\ngoto destroy_cache;\r\n}\r\nfwserial_unit_directory_data.unit_addr_offset =\r\nFW_UNIT_ADDRESS(fwserial_mgmt_addr_handler.offset);\r\nerr = fw_core_add_descriptor(&fwserial_unit_directory);\r\nif (err) {\r\npr_err("add unit descriptor failed (%d)\n", err);\r\ngoto remove_handler;\r\n}\r\nerr = driver_register(&fwserial_driver.driver);\r\nif (err) {\r\npr_err("register fwserial driver failed (%d)\n", err);\r\ngoto remove_descriptor;\r\n}\r\nreturn 0;\r\nremove_descriptor:\r\nfw_core_remove_descriptor(&fwserial_unit_directory);\r\nremove_handler:\r\nfw_core_remove_address_handler(&fwserial_mgmt_addr_handler);\r\ndestroy_cache:\r\nkmem_cache_destroy(fwtty_txn_cache);\r\nunregister_loop:\r\nif (create_loop_dev)\r\ntty_unregister_driver(fwloop_driver);\r\nput_loop:\r\nif (create_loop_dev)\r\nput_tty_driver(fwloop_driver);\r\nunregister_driver:\r\ntty_unregister_driver(fwtty_driver);\r\nput_tty:\r\nput_tty_driver(fwtty_driver);\r\nremove_debugfs:\r\ndebugfs_remove_recursive(fwserial_debugfs);\r\nreturn err;\r\n}\r\nstatic void __exit fwserial_exit(void)\r\n{\r\ndriver_unregister(&fwserial_driver.driver);\r\nfw_core_remove_descriptor(&fwserial_unit_directory);\r\nfw_core_remove_address_handler(&fwserial_mgmt_addr_handler);\r\nkmem_cache_destroy(fwtty_txn_cache);\r\nif (create_loop_dev) {\r\ntty_unregister_driver(fwloop_driver);\r\nput_tty_driver(fwloop_driver);\r\n}\r\ntty_unregister_driver(fwtty_driver);\r\nput_tty_driver(fwtty_driver);\r\ndebugfs_remove_recursive(fwserial_debugfs);\r\n}
