static int mei_open(struct inode *inode, struct file *file)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_cl *cl;\r\nint err;\r\ndev = container_of(inode->i_cdev, struct mei_device, cdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nif (dev->dev_state != MEI_DEV_ENABLED) {\r\ndev_dbg(dev->dev, "dev_state != MEI_ENABLED dev_state = %s\n",\r\nmei_dev_state_str(dev->dev_state));\r\nerr = -ENODEV;\r\ngoto err_unlock;\r\n}\r\ncl = mei_cl_alloc_linked(dev);\r\nif (IS_ERR(cl)) {\r\nerr = PTR_ERR(cl);\r\ngoto err_unlock;\r\n}\r\nfile->private_data = cl;\r\nmutex_unlock(&dev->device_lock);\r\nreturn nonseekable_open(inode, file);\r\nerr_unlock:\r\nmutex_unlock(&dev->device_lock);\r\nreturn err;\r\n}\r\nstatic int mei_release(struct inode *inode, struct file *file)\r\n{\r\nstruct mei_cl *cl = file->private_data;\r\nstruct mei_device *dev;\r\nint rets;\r\nif (WARN_ON(!cl || !cl->dev))\r\nreturn -ENODEV;\r\ndev = cl->dev;\r\nmutex_lock(&dev->device_lock);\r\nif (cl == &dev->iamthif_cl) {\r\nrets = mei_amthif_release(dev, file);\r\ngoto out;\r\n}\r\nrets = mei_cl_disconnect(cl);\r\nmei_cl_flush_queues(cl, file);\r\ncl_dbg(dev, cl, "removing\n");\r\nmei_cl_unlink(cl);\r\nfile->private_data = NULL;\r\nkfree(cl);\r\nout:\r\nmutex_unlock(&dev->device_lock);\r\nreturn rets;\r\n}\r\nstatic ssize_t mei_read(struct file *file, char __user *ubuf,\r\nsize_t length, loff_t *offset)\r\n{\r\nstruct mei_cl *cl = file->private_data;\r\nstruct mei_device *dev;\r\nstruct mei_cl_cb *cb = NULL;\r\nint rets;\r\nint err;\r\nif (WARN_ON(!cl || !cl->dev))\r\nreturn -ENODEV;\r\ndev = cl->dev;\r\nmutex_lock(&dev->device_lock);\r\nif (dev->dev_state != MEI_DEV_ENABLED) {\r\nrets = -ENODEV;\r\ngoto out;\r\n}\r\nif (length == 0) {\r\nrets = 0;\r\ngoto out;\r\n}\r\nif (ubuf == NULL) {\r\nrets = -EMSGSIZE;\r\ngoto out;\r\n}\r\nif (cl == &dev->iamthif_cl) {\r\nrets = mei_amthif_read(dev, file, ubuf, length, offset);\r\ngoto out;\r\n}\r\ncb = mei_cl_read_cb(cl, file);\r\nif (cb)\r\ngoto copy_buffer;\r\nif (*offset > 0)\r\n*offset = 0;\r\nerr = mei_cl_read_start(cl, length, file);\r\nif (err && err != -EBUSY) {\r\ncl_dbg(dev, cl, "mei start read failure status = %d\n", err);\r\nrets = err;\r\ngoto out;\r\n}\r\nif (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nrets = -EAGAIN;\r\ngoto out;\r\n}\r\nmutex_unlock(&dev->device_lock);\r\nif (wait_event_interruptible(cl->rx_wait,\r\n(!list_empty(&cl->rd_completed)) ||\r\n(!mei_cl_is_connected(cl)))) {\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nreturn -ERESTARTSYS;\r\n}\r\nmutex_lock(&dev->device_lock);\r\nif (!mei_cl_is_connected(cl)) {\r\nrets = -EBUSY;\r\ngoto out;\r\n}\r\n}\r\ncb = mei_cl_read_cb(cl, file);\r\nif (!cb) {\r\nrets = 0;\r\ngoto out;\r\n}\r\ncopy_buffer:\r\nif (cb->status) {\r\nrets = cb->status;\r\ncl_dbg(dev, cl, "read operation failed %d\n", rets);\r\ngoto free;\r\n}\r\ncl_dbg(dev, cl, "buf.size = %zu buf.idx = %zu offset = %lld\n",\r\ncb->buf.size, cb->buf_idx, *offset);\r\nif (*offset >= cb->buf_idx) {\r\nrets = 0;\r\ngoto free;\r\n}\r\nlength = min_t(size_t, length, cb->buf_idx - *offset);\r\nif (copy_to_user(ubuf, cb->buf.data + *offset, length)) {\r\ndev_dbg(dev->dev, "failed to copy data to userland\n");\r\nrets = -EFAULT;\r\ngoto free;\r\n}\r\nrets = length;\r\n*offset += length;\r\nif (*offset < cb->buf_idx)\r\ngoto out;\r\nfree:\r\nmei_io_cb_free(cb);\r\n*offset = 0;\r\nout:\r\ncl_dbg(dev, cl, "end mei read rets = %d\n", rets);\r\nmutex_unlock(&dev->device_lock);\r\nreturn rets;\r\n}\r\nstatic ssize_t mei_write(struct file *file, const char __user *ubuf,\r\nsize_t length, loff_t *offset)\r\n{\r\nstruct mei_cl *cl = file->private_data;\r\nstruct mei_cl_cb *cb;\r\nstruct mei_device *dev;\r\nint rets;\r\nif (WARN_ON(!cl || !cl->dev))\r\nreturn -ENODEV;\r\ndev = cl->dev;\r\nmutex_lock(&dev->device_lock);\r\nif (dev->dev_state != MEI_DEV_ENABLED) {\r\nrets = -ENODEV;\r\ngoto out;\r\n}\r\nif (!mei_cl_is_connected(cl)) {\r\ncl_err(dev, cl, "is not connected");\r\nrets = -ENODEV;\r\ngoto out;\r\n}\r\nif (!mei_me_cl_is_active(cl->me_cl)) {\r\nrets = -ENOTTY;\r\ngoto out;\r\n}\r\nif (length > mei_cl_mtu(cl)) {\r\nrets = -EFBIG;\r\ngoto out;\r\n}\r\nif (length == 0) {\r\nrets = 0;\r\ngoto out;\r\n}\r\n*offset = 0;\r\ncb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, file);\r\nif (!cb) {\r\nrets = -ENOMEM;\r\ngoto out;\r\n}\r\nrets = copy_from_user(cb->buf.data, ubuf, length);\r\nif (rets) {\r\ndev_dbg(dev->dev, "failed to copy data from userland\n");\r\nrets = -EFAULT;\r\nmei_io_cb_free(cb);\r\ngoto out;\r\n}\r\nif (cl == &dev->iamthif_cl) {\r\nrets = mei_amthif_write(cl, cb);\r\nif (!rets)\r\nrets = length;\r\ngoto out;\r\n}\r\nrets = mei_cl_write(cl, cb, false);\r\nout:\r\nmutex_unlock(&dev->device_lock);\r\nreturn rets;\r\n}\r\nstatic int mei_ioctl_connect_client(struct file *file,\r\nstruct mei_connect_client_data *data)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_client *client;\r\nstruct mei_me_client *me_cl;\r\nstruct mei_cl *cl;\r\nint rets;\r\ncl = file->private_data;\r\ndev = cl->dev;\r\nif (dev->dev_state != MEI_DEV_ENABLED)\r\nreturn -ENODEV;\r\nif (cl->state != MEI_FILE_INITIALIZING &&\r\ncl->state != MEI_FILE_DISCONNECTED)\r\nreturn -EBUSY;\r\nme_cl = mei_me_cl_by_uuid(dev, &data->in_client_uuid);\r\nif (!me_cl) {\r\ndev_dbg(dev->dev, "Cannot connect to FW Client UUID = %pUl\n",\r\n&data->in_client_uuid);\r\nrets = -ENOTTY;\r\ngoto end;\r\n}\r\nif (me_cl->props.fixed_address) {\r\nbool forbidden = dev->override_fixed_address ?\r\n!dev->allow_fixed_address : !dev->hbm_f_fa_supported;\r\nif (forbidden) {\r\ndev_dbg(dev->dev, "Connection forbidden to FW Client UUID = %pUl\n",\r\n&data->in_client_uuid);\r\nrets = -ENOTTY;\r\ngoto end;\r\n}\r\n}\r\ndev_dbg(dev->dev, "Connect to FW Client ID = %d\n",\r\nme_cl->client_id);\r\ndev_dbg(dev->dev, "FW Client - Protocol Version = %d\n",\r\nme_cl->props.protocol_version);\r\ndev_dbg(dev->dev, "FW Client - Max Msg Len = %d\n",\r\nme_cl->props.max_msg_length);\r\nif (uuid_le_cmp(data->in_client_uuid, mei_amthif_guid) == 0) {\r\ndev_dbg(dev->dev, "FW Client is amthi\n");\r\nif (!mei_cl_is_connected(&dev->iamthif_cl)) {\r\nrets = -ENODEV;\r\ngoto end;\r\n}\r\nmei_cl_unlink(cl);\r\nkfree(cl);\r\ncl = NULL;\r\ndev->iamthif_open_count++;\r\nfile->private_data = &dev->iamthif_cl;\r\nclient = &data->out_client_properties;\r\nclient->max_msg_length = me_cl->props.max_msg_length;\r\nclient->protocol_version = me_cl->props.protocol_version;\r\nrets = dev->iamthif_cl.status;\r\ngoto end;\r\n}\r\nclient = &data->out_client_properties;\r\nclient->max_msg_length = me_cl->props.max_msg_length;\r\nclient->protocol_version = me_cl->props.protocol_version;\r\ndev_dbg(dev->dev, "Can connect?\n");\r\nrets = mei_cl_connect(cl, me_cl, file);\r\nend:\r\nmei_me_cl_put(me_cl);\r\nreturn rets;\r\n}\r\nstatic int mei_ioctl_client_notify_request(const struct file *file, u32 request)\r\n{\r\nstruct mei_cl *cl = file->private_data;\r\nif (request != MEI_HBM_NOTIFICATION_START &&\r\nrequest != MEI_HBM_NOTIFICATION_STOP)\r\nreturn -EINVAL;\r\nreturn mei_cl_notify_request(cl, file, (u8)request);\r\n}\r\nstatic int mei_ioctl_client_notify_get(const struct file *file, u32 *notify_get)\r\n{\r\nstruct mei_cl *cl = file->private_data;\r\nbool notify_ev;\r\nbool block = (file->f_flags & O_NONBLOCK) == 0;\r\nint rets;\r\nrets = mei_cl_notify_get(cl, block, &notify_ev);\r\nif (rets)\r\nreturn rets;\r\n*notify_get = notify_ev ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic long mei_ioctl(struct file *file, unsigned int cmd, unsigned long data)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_cl *cl = file->private_data;\r\nstruct mei_connect_client_data connect_data;\r\nu32 notify_get, notify_req;\r\nint rets;\r\nif (WARN_ON(!cl || !cl->dev))\r\nreturn -ENODEV;\r\ndev = cl->dev;\r\ndev_dbg(dev->dev, "IOCTL cmd = 0x%x", cmd);\r\nmutex_lock(&dev->device_lock);\r\nif (dev->dev_state != MEI_DEV_ENABLED) {\r\nrets = -ENODEV;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase IOCTL_MEI_CONNECT_CLIENT:\r\ndev_dbg(dev->dev, ": IOCTL_MEI_CONNECT_CLIENT.\n");\r\nif (copy_from_user(&connect_data, (char __user *)data,\r\nsizeof(struct mei_connect_client_data))) {\r\ndev_dbg(dev->dev, "failed to copy data from userland\n");\r\nrets = -EFAULT;\r\ngoto out;\r\n}\r\nrets = mei_ioctl_connect_client(file, &connect_data);\r\nif (rets)\r\ngoto out;\r\nif (copy_to_user((char __user *)data, &connect_data,\r\nsizeof(struct mei_connect_client_data))) {\r\ndev_dbg(dev->dev, "failed to copy data to userland\n");\r\nrets = -EFAULT;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IOCTL_MEI_NOTIFY_SET:\r\ndev_dbg(dev->dev, ": IOCTL_MEI_NOTIFY_SET.\n");\r\nif (copy_from_user(&notify_req,\r\n(char __user *)data, sizeof(notify_req))) {\r\ndev_dbg(dev->dev, "failed to copy data from userland\n");\r\nrets = -EFAULT;\r\ngoto out;\r\n}\r\nrets = mei_ioctl_client_notify_request(file, notify_req);\r\nbreak;\r\ncase IOCTL_MEI_NOTIFY_GET:\r\ndev_dbg(dev->dev, ": IOCTL_MEI_NOTIFY_GET.\n");\r\nrets = mei_ioctl_client_notify_get(file, &notify_get);\r\nif (rets)\r\ngoto out;\r\ndev_dbg(dev->dev, "copy connect data to user\n");\r\nif (copy_to_user((char __user *)data,\r\n&notify_get, sizeof(notify_get))) {\r\ndev_dbg(dev->dev, "failed to copy data to userland\n");\r\nrets = -EFAULT;\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, ": unsupported ioctl %d.\n", cmd);\r\nrets = -ENOIOCTLCMD;\r\n}\r\nout:\r\nmutex_unlock(&dev->device_lock);\r\nreturn rets;\r\n}\r\nstatic long mei_compat_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long data)\r\n{\r\nreturn mei_ioctl(file, cmd, (unsigned long)compat_ptr(data));\r\n}\r\nstatic unsigned int mei_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned long req_events = poll_requested_events(wait);\r\nstruct mei_cl *cl = file->private_data;\r\nstruct mei_device *dev;\r\nunsigned int mask = 0;\r\nbool notify_en;\r\nif (WARN_ON(!cl || !cl->dev))\r\nreturn POLLERR;\r\ndev = cl->dev;\r\nmutex_lock(&dev->device_lock);\r\nnotify_en = cl->notify_en && (req_events & POLLPRI);\r\nif (dev->dev_state != MEI_DEV_ENABLED ||\r\n!mei_cl_is_connected(cl)) {\r\nmask = POLLERR;\r\ngoto out;\r\n}\r\nif (cl == &dev->iamthif_cl) {\r\nmask = mei_amthif_poll(dev, file, wait);\r\ngoto out;\r\n}\r\nif (notify_en) {\r\npoll_wait(file, &cl->ev_wait, wait);\r\nif (cl->notify_ev)\r\nmask |= POLLPRI;\r\n}\r\nif (req_events & (POLLIN | POLLRDNORM)) {\r\npoll_wait(file, &cl->rx_wait, wait);\r\nif (!list_empty(&cl->rd_completed))\r\nmask |= POLLIN | POLLRDNORM;\r\nelse\r\nmei_cl_read_start(cl, 0, file);\r\n}\r\nout:\r\nmutex_unlock(&dev->device_lock);\r\nreturn mask;\r\n}\r\nstatic int mei_fasync(int fd, struct file *file, int band)\r\n{\r\nstruct mei_cl *cl = file->private_data;\r\nif (!mei_cl_is_connected(cl))\r\nreturn -ENODEV;\r\nreturn fasync_helper(fd, file, band, &cl->ev_async);\r\n}\r\nstatic ssize_t fw_status_show(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mei_device *dev = dev_get_drvdata(device);\r\nstruct mei_fw_status fw_status;\r\nint err, i;\r\nssize_t cnt = 0;\r\nmutex_lock(&dev->device_lock);\r\nerr = mei_fw_status(dev, &fw_status);\r\nmutex_unlock(&dev->device_lock);\r\nif (err) {\r\ndev_err(device, "read fw_status error = %d\n", err);\r\nreturn err;\r\n}\r\nfor (i = 0; i < fw_status.count; i++)\r\ncnt += scnprintf(buf + cnt, PAGE_SIZE - cnt, "%08X\n",\r\nfw_status.status[i]);\r\nreturn cnt;\r\n}\r\nstatic int mei_minor_get(struct mei_device *dev)\r\n{\r\nint ret;\r\nmutex_lock(&mei_minor_lock);\r\nret = idr_alloc(&mei_idr, dev, 0, MEI_MAX_DEVS, GFP_KERNEL);\r\nif (ret >= 0)\r\ndev->minor = ret;\r\nelse if (ret == -ENOSPC)\r\ndev_err(dev->dev, "too many mei devices\n");\r\nmutex_unlock(&mei_minor_lock);\r\nreturn ret;\r\n}\r\nstatic void mei_minor_free(struct mei_device *dev)\r\n{\r\nmutex_lock(&mei_minor_lock);\r\nidr_remove(&mei_idr, dev->minor);\r\nmutex_unlock(&mei_minor_lock);\r\n}\r\nint mei_register(struct mei_device *dev, struct device *parent)\r\n{\r\nstruct device *clsdev;\r\nint ret, devno;\r\nret = mei_minor_get(dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndevno = MKDEV(MAJOR(mei_devt), dev->minor);\r\ncdev_init(&dev->cdev, &mei_fops);\r\ndev->cdev.owner = parent->driver->owner;\r\nret = cdev_add(&dev->cdev, devno, 1);\r\nif (ret) {\r\ndev_err(parent, "unable to add device %d:%d\n",\r\nMAJOR(mei_devt), dev->minor);\r\ngoto err_dev_add;\r\n}\r\nclsdev = device_create_with_groups(mei_class, parent, devno,\r\ndev, mei_groups,\r\n"mei%d", dev->minor);\r\nif (IS_ERR(clsdev)) {\r\ndev_err(parent, "unable to create device %d:%d\n",\r\nMAJOR(mei_devt), dev->minor);\r\nret = PTR_ERR(clsdev);\r\ngoto err_dev_create;\r\n}\r\nret = mei_dbgfs_register(dev, dev_name(clsdev));\r\nif (ret) {\r\ndev_err(clsdev, "cannot register debugfs ret = %d\n", ret);\r\ngoto err_dev_dbgfs;\r\n}\r\nreturn 0;\r\nerr_dev_dbgfs:\r\ndevice_destroy(mei_class, devno);\r\nerr_dev_create:\r\ncdev_del(&dev->cdev);\r\nerr_dev_add:\r\nmei_minor_free(dev);\r\nreturn ret;\r\n}\r\nvoid mei_deregister(struct mei_device *dev)\r\n{\r\nint devno;\r\ndevno = dev->cdev.dev;\r\ncdev_del(&dev->cdev);\r\nmei_dbgfs_deregister(dev);\r\ndevice_destroy(mei_class, devno);\r\nmei_minor_free(dev);\r\n}\r\nstatic int __init mei_init(void)\r\n{\r\nint ret;\r\nmei_class = class_create(THIS_MODULE, "mei");\r\nif (IS_ERR(mei_class)) {\r\npr_err("couldn't create class\n");\r\nret = PTR_ERR(mei_class);\r\ngoto err;\r\n}\r\nret = alloc_chrdev_region(&mei_devt, 0, MEI_MAX_DEVS, "mei");\r\nif (ret < 0) {\r\npr_err("unable to allocate char dev region\n");\r\ngoto err_class;\r\n}\r\nret = mei_cl_bus_init();\r\nif (ret < 0) {\r\npr_err("unable to initialize bus\n");\r\ngoto err_chrdev;\r\n}\r\nreturn 0;\r\nerr_chrdev:\r\nunregister_chrdev_region(mei_devt, MEI_MAX_DEVS);\r\nerr_class:\r\nclass_destroy(mei_class);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void __exit mei_exit(void)\r\n{\r\nunregister_chrdev_region(mei_devt, MEI_MAX_DEVS);\r\nclass_destroy(mei_class);\r\nmei_cl_bus_exit();\r\n}
