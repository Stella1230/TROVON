static ssize_t cxacru_sysfs_showattr_u32(u32 value, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", value);\r\n}\r\nstatic ssize_t cxacru_sysfs_showattr_s8(s8 value, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", value);\r\n}\r\nstatic ssize_t cxacru_sysfs_showattr_dB(s16 value, char *buf)\r\n{\r\nif (likely(value >= 0)) {\r\nreturn snprintf(buf, PAGE_SIZE, "%u.%02u\n",\r\nvalue / 100, value % 100);\r\n} else {\r\nvalue = -value;\r\nreturn snprintf(buf, PAGE_SIZE, "-%u.%02u\n",\r\nvalue / 100, value % 100);\r\n}\r\n}\r\nstatic ssize_t cxacru_sysfs_showattr_bool(u32 value, char *buf)\r\n{\r\nstatic char *str[] = { "no", "yes" };\r\nif (unlikely(value >= ARRAY_SIZE(str)))\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", value);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", str[value]);\r\n}\r\nstatic ssize_t cxacru_sysfs_showattr_LINK(u32 value, char *buf)\r\n{\r\nstatic char *str[] = { NULL, "not connected", "connected", "lost" };\r\nif (unlikely(value >= ARRAY_SIZE(str) || str[value] == NULL))\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", value);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", str[value]);\r\n}\r\nstatic ssize_t cxacru_sysfs_showattr_LINE(u32 value, char *buf)\r\n{\r\nstatic char *str[] = { "down", "attempting to activate",\r\n"training", "channel analysis", "exchange", "up",\r\n"waiting", "initialising"\r\n};\r\nif (unlikely(value >= ARRAY_SIZE(str)))\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", value);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", str[value]);\r\n}\r\nstatic ssize_t cxacru_sysfs_showattr_MODU(u32 value, char *buf)\r\n{\r\nstatic char *str[] = {\r\n"",\r\n"ANSI T1.413",\r\n"ITU-T G.992.1 (G.DMT)",\r\n"ITU-T G.992.2 (G.LITE)"\r\n};\r\nif (unlikely(value >= ARRAY_SIZE(str)))\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", value);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", str[value]);\r\n}\r\nstatic ssize_t cxacru_sysfs_show_mac_address(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct cxacru_data *instance = to_usbatm_driver_data(\r\nto_usb_interface(dev));\r\nif (instance == NULL || instance->usbatm->atm_dev == NULL)\r\nreturn -ENODEV;\r\nreturn snprintf(buf, PAGE_SIZE, "%pM\n",\r\ninstance->usbatm->atm_dev->esi);\r\n}\r\nstatic ssize_t cxacru_sysfs_show_adsl_state(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstatic char *str[] = { "running", "stopped" };\r\nstruct cxacru_data *instance = to_usbatm_driver_data(\r\nto_usb_interface(dev));\r\nu32 value;\r\nif (instance == NULL)\r\nreturn -ENODEV;\r\nvalue = instance->card_info[CXINF_LINE_STARTABLE];\r\nif (unlikely(value >= ARRAY_SIZE(str)))\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", value);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", str[value]);\r\n}\r\nstatic ssize_t cxacru_sysfs_store_adsl_state(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct cxacru_data *instance = to_usbatm_driver_data(\r\nto_usb_interface(dev));\r\nint ret;\r\nint poll = -1;\r\nchar str_cmd[8];\r\nint len = strlen(buf);\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\nret = sscanf(buf, "%7s", str_cmd);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nret = 0;\r\nif (instance == NULL)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&instance->adsl_state_serialize))\r\nreturn -ERESTARTSYS;\r\nif (!strcmp(str_cmd, "stop") || !strcmp(str_cmd, "restart")) {\r\nret = cxacru_cm(instance, CM_REQUEST_CHIP_ADSL_LINE_STOP, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\natm_err(instance->usbatm, "change adsl state:"\r\n" CHIP_ADSL_LINE_STOP returned %d\n", ret);\r\nret = -EIO;\r\n} else {\r\nret = len;\r\npoll = CXPOLL_STOPPED;\r\n}\r\n}\r\nif (!strcmp(str_cmd, "restart"))\r\nmsleep(1500);\r\nif (!strcmp(str_cmd, "start") || !strcmp(str_cmd, "restart")) {\r\nret = cxacru_cm(instance, CM_REQUEST_CHIP_ADSL_LINE_START, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\natm_err(instance->usbatm, "change adsl state:"\r\n" CHIP_ADSL_LINE_START returned %d\n", ret);\r\nret = -EIO;\r\n} else {\r\nret = len;\r\npoll = CXPOLL_POLLING;\r\n}\r\n}\r\nif (!strcmp(str_cmd, "poll")) {\r\nret = len;\r\npoll = CXPOLL_POLLING;\r\n}\r\nif (ret == 0) {\r\nret = -EINVAL;\r\npoll = -1;\r\n}\r\nif (poll == CXPOLL_POLLING) {\r\nmutex_lock(&instance->poll_state_serialize);\r\nswitch (instance->poll_state) {\r\ncase CXPOLL_STOPPED:\r\ninstance->poll_state = CXPOLL_POLLING;\r\nbreak;\r\ncase CXPOLL_STOPPING:\r\ninstance->poll_state = CXPOLL_POLLING;\r\ncase CXPOLL_POLLING:\r\ncase CXPOLL_SHUTDOWN:\r\npoll = -1;\r\n}\r\nmutex_unlock(&instance->poll_state_serialize);\r\n} else if (poll == CXPOLL_STOPPED) {\r\nmutex_lock(&instance->poll_state_serialize);\r\nif (instance->poll_state == CXPOLL_POLLING)\r\ninstance->poll_state = CXPOLL_STOPPING;\r\nmutex_unlock(&instance->poll_state_serialize);\r\n}\r\nmutex_unlock(&instance->adsl_state_serialize);\r\nif (poll == CXPOLL_POLLING)\r\ncxacru_poll_status(&instance->poll_work.work);\r\nreturn ret;\r\n}\r\nstatic ssize_t cxacru_sysfs_store_adsl_config(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct cxacru_data *instance = to_usbatm_driver_data(\r\nto_usb_interface(dev));\r\nint len = strlen(buf);\r\nint ret, pos, num;\r\n__le32 data[CMD_PACKET_SIZE / 4];\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\nif (instance == NULL)\r\nreturn -ENODEV;\r\npos = 0;\r\nnum = 0;\r\nwhile (pos < len) {\r\nint tmp;\r\nu32 index;\r\nu32 value;\r\nret = sscanf(buf + pos, "%x=%x%n", &index, &value, &tmp);\r\nif (ret < 2)\r\nreturn -EINVAL;\r\nif (index < 0 || index > 0x7f)\r\nreturn -EINVAL;\r\nif (tmp < 0 || tmp > len - pos)\r\nreturn -EINVAL;\r\npos += tmp;\r\nif (buf[pos] == '\n' && pos == len-1)\r\npos++;\r\ndata[num * 2 + 1] = cpu_to_le32(index);\r\ndata[num * 2 + 2] = cpu_to_le32(value);\r\nnum++;\r\nif (pos >= len || num >= CMD_MAX_CONFIG) {\r\nchar log[CMD_MAX_CONFIG * 12 + 1];\r\ndata[0] = cpu_to_le32(num);\r\nret = cxacru_cm(instance, CM_REQUEST_CARD_DATA_SET,\r\n(u8 *) data, 4 + num * 8, NULL, 0);\r\nif (ret < 0) {\r\natm_err(instance->usbatm,\r\n"set card data returned %d\n", ret);\r\nreturn -EIO;\r\n}\r\nfor (tmp = 0; tmp < num; tmp++)\r\nsnprintf(log + tmp*12, 13, " %02x=%08x",\r\nle32_to_cpu(data[tmp * 2 + 1]),\r\nle32_to_cpu(data[tmp * 2 + 2]));\r\natm_info(instance->usbatm, "config%s\n", log);\r\nnum = 0;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic void cxacru_blocking_completion(struct urb *urb)\r\n{\r\ncomplete(urb->context);\r\n}\r\nstatic void cxacru_timeout_kill(unsigned long data)\r\n{\r\nusb_unlink_urb((struct urb *) data);\r\n}\r\nstatic int cxacru_start_wait_urb(struct urb *urb, struct completion *done,\r\nint *actual_length)\r\n{\r\nstruct timer_list timer;\r\ninit_timer(&timer);\r\ntimer.expires = jiffies + msecs_to_jiffies(CMD_TIMEOUT);\r\ntimer.data = (unsigned long) urb;\r\ntimer.function = cxacru_timeout_kill;\r\nadd_timer(&timer);\r\nwait_for_completion(done);\r\ndel_timer_sync(&timer);\r\nif (actual_length)\r\n*actual_length = urb->actual_length;\r\nreturn urb->status;\r\n}\r\nstatic int cxacru_cm(struct cxacru_data *instance, enum cxacru_cm_request cm,\r\nu8 *wdata, int wsize, u8 *rdata, int rsize)\r\n{\r\nint ret, actlen;\r\nint offb, offd;\r\nconst int stride = CMD_PACKET_SIZE - 4;\r\nu8 *wbuf = instance->snd_buf;\r\nu8 *rbuf = instance->rcv_buf;\r\nint wbuflen = ((wsize - 1) / stride + 1) * CMD_PACKET_SIZE;\r\nint rbuflen = ((rsize - 1) / stride + 1) * CMD_PACKET_SIZE;\r\nif (wbuflen > PAGE_SIZE || rbuflen > PAGE_SIZE) {\r\nif (printk_ratelimit())\r\nusb_err(instance->usbatm, "requested transfer size too large (%d, %d)\n",\r\nwbuflen, rbuflen);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nmutex_lock(&instance->cm_serialize);\r\ninit_completion(&instance->rcv_done);\r\nret = usb_submit_urb(instance->rcv_urb, GFP_KERNEL);\r\nif (ret < 0) {\r\nif (printk_ratelimit())\r\nusb_err(instance->usbatm, "submit of read urb for cm %#x failed (%d)\n",\r\ncm, ret);\r\ngoto fail;\r\n}\r\nmemset(wbuf, 0, wbuflen);\r\nwbuf[0] = cm;\r\nfor (offb = offd = 0; offd < wsize; offd += stride, offb += CMD_PACKET_SIZE) {\r\nwbuf[offb] = cm;\r\nmemcpy(wbuf + offb + 4, wdata + offd, min_t(int, stride, wsize - offd));\r\n}\r\ninstance->snd_urb->transfer_buffer_length = wbuflen;\r\ninit_completion(&instance->snd_done);\r\nret = usb_submit_urb(instance->snd_urb, GFP_KERNEL);\r\nif (ret < 0) {\r\nif (printk_ratelimit())\r\nusb_err(instance->usbatm, "submit of write urb for cm %#x failed (%d)\n",\r\ncm, ret);\r\ngoto fail;\r\n}\r\nret = cxacru_start_wait_urb(instance->snd_urb, &instance->snd_done, NULL);\r\nif (ret < 0) {\r\nif (printk_ratelimit())\r\nusb_err(instance->usbatm, "send of cm %#x failed (%d)\n", cm, ret);\r\ngoto fail;\r\n}\r\nret = cxacru_start_wait_urb(instance->rcv_urb, &instance->rcv_done, &actlen);\r\nif (ret < 0) {\r\nif (printk_ratelimit())\r\nusb_err(instance->usbatm, "receive of cm %#x failed (%d)\n", cm, ret);\r\ngoto fail;\r\n}\r\nif (actlen % CMD_PACKET_SIZE || !actlen) {\r\nif (printk_ratelimit())\r\nusb_err(instance->usbatm, "invalid response length to cm %#x: %d\n",\r\ncm, actlen);\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nfor (offb = offd = 0; offd < rsize && offb < actlen; offb += CMD_PACKET_SIZE) {\r\nif (rbuf[offb] != cm) {\r\nif (printk_ratelimit())\r\nusb_err(instance->usbatm, "wrong cm %#x in response to cm %#x\n",\r\nrbuf[offb], cm);\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nif (rbuf[offb + 1] != CM_STATUS_SUCCESS) {\r\nif (printk_ratelimit())\r\nusb_err(instance->usbatm, "response to cm %#x failed: %#x\n",\r\ncm, rbuf[offb + 1]);\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nif (offd >= rsize)\r\nbreak;\r\nmemcpy(rdata + offd, rbuf + offb + 4, min_t(int, stride, rsize - offd));\r\noffd += stride;\r\n}\r\nret = offd;\r\nusb_dbg(instance->usbatm, "cm %#x\n", cm);\r\nfail:\r\nmutex_unlock(&instance->cm_serialize);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int cxacru_cm_get_array(struct cxacru_data *instance, enum cxacru_cm_request cm,\r\nu32 *data, int size)\r\n{\r\nint ret, len;\r\n__le32 *buf;\r\nint offb;\r\nunsigned int offd;\r\nconst int stride = CMD_PACKET_SIZE / (4 * 2) - 1;\r\nint buflen = ((size - 1) / stride + 1 + size * 2) * 4;\r\nbuf = kmalloc(buflen, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = cxacru_cm(instance, cm, NULL, 0, (u8 *) buf, buflen);\r\nif (ret < 0)\r\ngoto cleanup;\r\nlen = ret / 4;\r\nfor (offb = 0; offb < len; ) {\r\nint l = le32_to_cpu(buf[offb++]);\r\nif (l < 0 || l > stride || l > (len - offb) / 2) {\r\nif (printk_ratelimit())\r\nusb_err(instance->usbatm, "invalid data length from cm %#x: %d\n",\r\ncm, l);\r\nret = -EIO;\r\ngoto cleanup;\r\n}\r\nwhile (l--) {\r\noffd = le32_to_cpu(buf[offb++]);\r\nif (offd >= size) {\r\nif (printk_ratelimit())\r\nusb_err(instance->usbatm, "wrong index %#x in response to cm %#x\n",\r\noffd, cm);\r\nret = -EIO;\r\ngoto cleanup;\r\n}\r\ndata[offd] = le32_to_cpu(buf[offb++]);\r\n}\r\n}\r\nret = 0;\r\ncleanup:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int cxacru_card_status(struct cxacru_data *instance)\r\n{\r\nint ret = cxacru_cm(instance, CM_REQUEST_CARD_GET_STATUS, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\nusb_dbg(instance->usbatm, "cxacru_adsl_start: CARD_GET_STATUS returned %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cxacru_remove_device_files(struct usbatm_data *usbatm_instance,\r\nstruct atm_dev *atm_dev)\r\n{\r\nstruct usb_interface *intf = usbatm_instance->usb_intf;\r\n#define CXACRU_DEVICE_REMOVE_FILE(_name) \\r\ndevice_remove_file(&intf->dev, &dev_attr_##_name);\r\nCXACRU_ALL_FILES(REMOVE);\r\n#undef CXACRU_DEVICE_REMOVE_FILE\r\n}\r\nstatic int cxacru_atm_start(struct usbatm_data *usbatm_instance,\r\nstruct atm_dev *atm_dev)\r\n{\r\nstruct cxacru_data *instance = usbatm_instance->driver_data;\r\nstruct usb_interface *intf = usbatm_instance->usb_intf;\r\nint ret;\r\nint start_polling = 1;\r\ndev_dbg(&intf->dev, "%s\n", __func__);\r\nret = cxacru_cm(instance, CM_REQUEST_CARD_GET_MAC_ADDRESS, NULL, 0,\r\natm_dev->esi, sizeof(atm_dev->esi));\r\nif (ret < 0) {\r\natm_err(usbatm_instance, "cxacru_atm_start: CARD_GET_MAC_ADDRESS returned %d\n", ret);\r\nreturn ret;\r\n}\r\n#define CXACRU_DEVICE_CREATE_FILE(_name) \\r\nret = device_create_file(&intf->dev, &dev_attr_##_name); \\r\nif (unlikely(ret)) \\r\ngoto fail_sysfs;\r\nCXACRU_ALL_FILES(CREATE);\r\n#undef CXACRU_DEVICE_CREATE_FILE\r\nmutex_lock(&instance->adsl_state_serialize);\r\nret = cxacru_cm(instance, CM_REQUEST_CHIP_ADSL_LINE_START, NULL, 0, NULL, 0);\r\nif (ret < 0)\r\natm_err(usbatm_instance, "cxacru_atm_start: CHIP_ADSL_LINE_START returned %d\n", ret);\r\nmutex_lock(&instance->poll_state_serialize);\r\nswitch (instance->poll_state) {\r\ncase CXPOLL_STOPPED:\r\ninstance->poll_state = CXPOLL_POLLING;\r\nbreak;\r\ncase CXPOLL_STOPPING:\r\ninstance->poll_state = CXPOLL_POLLING;\r\ncase CXPOLL_POLLING:\r\ncase CXPOLL_SHUTDOWN:\r\nstart_polling = 0;\r\n}\r\nmutex_unlock(&instance->poll_state_serialize);\r\nmutex_unlock(&instance->adsl_state_serialize);\r\nprintk(KERN_INFO "%s%d: %s %pM\n", atm_dev->type, atm_dev->number,\r\nusbatm_instance->description, atm_dev->esi);\r\nif (start_polling)\r\ncxacru_poll_status(&instance->poll_work.work);\r\nreturn 0;\r\nfail_sysfs:\r\nusb_err(usbatm_instance, "cxacru_atm_start: device_create_file failed (%d)\n", ret);\r\ncxacru_remove_device_files(usbatm_instance, atm_dev);\r\nreturn ret;\r\n}\r\nstatic void cxacru_poll_status(struct work_struct *work)\r\n{\r\nstruct cxacru_data *instance =\r\ncontainer_of(work, struct cxacru_data, poll_work.work);\r\nu32 buf[CXINF_MAX] = {};\r\nstruct usbatm_data *usbatm = instance->usbatm;\r\nstruct atm_dev *atm_dev = usbatm->atm_dev;\r\nint keep_polling = 1;\r\nint ret;\r\nret = cxacru_cm_get_array(instance, CM_REQUEST_CARD_INFO_GET, buf, CXINF_MAX);\r\nif (ret < 0) {\r\nif (ret != -ESHUTDOWN)\r\natm_warn(usbatm, "poll status: error %d\n", ret);\r\nmutex_lock(&instance->poll_state_serialize);\r\nif (instance->poll_state != CXPOLL_SHUTDOWN) {\r\ninstance->poll_state = CXPOLL_STOPPED;\r\nif (ret != -ESHUTDOWN)\r\natm_warn(usbatm, "polling disabled, set adsl_state"\r\n" to 'start' or 'poll' to resume\n");\r\n}\r\nmutex_unlock(&instance->poll_state_serialize);\r\ngoto reschedule;\r\n}\r\nmemcpy(instance->card_info, buf, sizeof(instance->card_info));\r\nif (instance->adsl_status != buf[CXINF_LINE_STARTABLE]) {\r\ninstance->adsl_status = buf[CXINF_LINE_STARTABLE];\r\nswitch (instance->adsl_status) {\r\ncase 0:\r\natm_printk(KERN_INFO, usbatm, "ADSL state: running\n");\r\nbreak;\r\ncase 1:\r\natm_printk(KERN_INFO, usbatm, "ADSL state: stopped\n");\r\nbreak;\r\ndefault:\r\natm_printk(KERN_INFO, usbatm, "Unknown adsl status %02x\n", instance->adsl_status);\r\nbreak;\r\n}\r\n}\r\nif (instance->line_status == buf[CXINF_LINE_STATUS])\r\ngoto reschedule;\r\ninstance->line_status = buf[CXINF_LINE_STATUS];\r\nswitch (instance->line_status) {\r\ncase 0:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\r\natm_info(usbatm, "ADSL line: down\n");\r\nbreak;\r\ncase 1:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\r\natm_info(usbatm, "ADSL line: attempting to activate\n");\r\nbreak;\r\ncase 2:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\r\natm_info(usbatm, "ADSL line: training\n");\r\nbreak;\r\ncase 3:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\r\natm_info(usbatm, "ADSL line: channel analysis\n");\r\nbreak;\r\ncase 4:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\r\natm_info(usbatm, "ADSL line: exchange\n");\r\nbreak;\r\ncase 5:\r\natm_dev->link_rate = buf[CXINF_DOWNSTREAM_RATE] * 1000 / 424;\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_FOUND);\r\natm_info(usbatm, "ADSL line: up (%d kb/s down | %d kb/s up)\n",\r\nbuf[CXINF_DOWNSTREAM_RATE], buf[CXINF_UPSTREAM_RATE]);\r\nbreak;\r\ncase 6:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\r\natm_info(usbatm, "ADSL line: waiting\n");\r\nbreak;\r\ncase 7:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\r\natm_info(usbatm, "ADSL line: initializing\n");\r\nbreak;\r\ndefault:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_UNKNOWN);\r\natm_info(usbatm, "Unknown line state %02x\n", instance->line_status);\r\nbreak;\r\n}\r\nreschedule:\r\nmutex_lock(&instance->poll_state_serialize);\r\nif (instance->poll_state == CXPOLL_STOPPING &&\r\ninstance->adsl_status == 1 &&\r\ninstance->line_status == 0)\r\ninstance->poll_state = CXPOLL_STOPPED;\r\nif (instance->poll_state == CXPOLL_STOPPED)\r\nkeep_polling = 0;\r\nmutex_unlock(&instance->poll_state_serialize);\r\nif (keep_polling)\r\nschedule_delayed_work(&instance->poll_work,\r\nround_jiffies_relative(POLL_INTERVAL*HZ));\r\n}\r\nstatic int cxacru_fw(struct usb_device *usb_dev, enum cxacru_fw_request fw,\r\nu8 code1, u8 code2, u32 addr, const u8 *data, int size)\r\n{\r\nint ret;\r\nu8 *buf;\r\nint offd, offb;\r\nconst int stride = CMD_PACKET_SIZE - 8;\r\nbuf = (u8 *) __get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\noffb = offd = 0;\r\ndo {\r\nint l = min_t(int, stride, size - offd);\r\nbuf[offb++] = fw;\r\nbuf[offb++] = l;\r\nbuf[offb++] = code1;\r\nbuf[offb++] = code2;\r\nput_unaligned(cpu_to_le32(addr), (__le32 *)(buf + offb));\r\noffb += 4;\r\naddr += l;\r\nif (l)\r\nmemcpy(buf + offb, data + offd, l);\r\nif (l < stride)\r\nmemset(buf + offb + l, 0, stride - l);\r\noffb += stride;\r\noffd += stride;\r\nif ((offb >= PAGE_SIZE) || (offd >= size)) {\r\nret = usb_bulk_msg(usb_dev, usb_sndbulkpipe(usb_dev, CXACRU_EP_CMD),\r\nbuf, offb, NULL, CMD_TIMEOUT);\r\nif (ret < 0) {\r\ndev_dbg(&usb_dev->dev, "sending fw %#x failed\n", fw);\r\ngoto cleanup;\r\n}\r\noffb = 0;\r\n}\r\n} while (offd < size);\r\ndev_dbg(&usb_dev->dev, "sent fw %#x\n", fw);\r\nret = 0;\r\ncleanup:\r\nfree_page((unsigned long) buf);\r\nreturn ret;\r\n}\r\nstatic void cxacru_upload_firmware(struct cxacru_data *instance,\r\nconst struct firmware *fw,\r\nconst struct firmware *bp)\r\n{\r\nint ret;\r\nstruct usbatm_data *usbatm = instance->usbatm;\r\nstruct usb_device *usb_dev = usbatm->usb_dev;\r\n__le16 signature[] = { usb_dev->descriptor.idVendor,\r\nusb_dev->descriptor.idProduct };\r\n__le32 val;\r\nusb_dbg(usbatm, "%s\n", __func__);\r\nval = cpu_to_le32(instance->modem_type->pll_f_clk);\r\nret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, PLLFCLK_ADDR, (u8 *) &val, 4);\r\nif (ret) {\r\nusb_err(usbatm, "FirmwarePllFClkValue failed: %d\n", ret);\r\nreturn;\r\n}\r\nval = cpu_to_le32(instance->modem_type->pll_b_clk);\r\nret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, PLLBCLK_ADDR, (u8 *) &val, 4);\r\nif (ret) {\r\nusb_err(usbatm, "FirmwarePllBClkValue failed: %d\n", ret);\r\nreturn;\r\n}\r\nval = cpu_to_le32(SDRAM_ENA);\r\nret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, SDRAMEN_ADDR, (u8 *) &val, 4);\r\nif (ret) {\r\nusb_err(usbatm, "Enable SDRAM failed: %d\n", ret);\r\nreturn;\r\n}\r\nusb_info(usbatm, "loading firmware\n");\r\nret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, FW_ADDR, fw->data, fw->size);\r\nif (ret) {\r\nusb_err(usbatm, "Firmware upload failed: %d\n", ret);\r\nreturn;\r\n}\r\nif (instance->modem_type->boot_rom_patch) {\r\nusb_info(usbatm, "loading boot ROM patch\n");\r\nret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, BR_ADDR, bp->data, bp->size);\r\nif (ret) {\r\nusb_err(usbatm, "Boot ROM patching failed: %d\n", ret);\r\nreturn;\r\n}\r\n}\r\nret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, SIG_ADDR, (u8 *) signature, 4);\r\nif (ret) {\r\nusb_err(usbatm, "Signature storing failed: %d\n", ret);\r\nreturn;\r\n}\r\nusb_info(usbatm, "starting device\n");\r\nif (instance->modem_type->boot_rom_patch) {\r\nval = cpu_to_le32(BR_ADDR);\r\nret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, BR_STACK_ADDR, (u8 *) &val, 4);\r\n} else {\r\nret = cxacru_fw(usb_dev, FW_GOTO_MEM, 0x0, 0x0, FW_ADDR, NULL, 0);\r\n}\r\nif (ret) {\r\nusb_err(usbatm, "Passing control to firmware failed: %d\n", ret);\r\nreturn;\r\n}\r\nmsleep_interruptible(1000);\r\nusb_clear_halt(usb_dev, usb_sndbulkpipe(usb_dev, CXACRU_EP_CMD));\r\nusb_clear_halt(usb_dev, usb_rcvbulkpipe(usb_dev, CXACRU_EP_CMD));\r\nusb_clear_halt(usb_dev, usb_sndbulkpipe(usb_dev, CXACRU_EP_DATA));\r\nusb_clear_halt(usb_dev, usb_rcvbulkpipe(usb_dev, CXACRU_EP_DATA));\r\nret = cxacru_cm(instance, CM_REQUEST_CARD_GET_STATUS, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\nusb_err(usbatm, "modem failed to initialize: %d\n", ret);\r\nreturn;\r\n}\r\n}\r\nstatic int cxacru_find_firmware(struct cxacru_data *instance,\r\nchar *phase, const struct firmware **fw_p)\r\n{\r\nstruct usbatm_data *usbatm = instance->usbatm;\r\nstruct device *dev = &usbatm->usb_intf->dev;\r\nchar buf[16];\r\nsprintf(buf, "cxacru-%s.bin", phase);\r\nusb_dbg(usbatm, "cxacru_find_firmware: looking for %s\n", buf);\r\nif (request_firmware(fw_p, buf, dev)) {\r\nusb_dbg(usbatm, "no stage %s firmware found\n", phase);\r\nreturn -ENOENT;\r\n}\r\nusb_info(usbatm, "found firmware %s\n", buf);\r\nreturn 0;\r\n}\r\nstatic int cxacru_heavy_init(struct usbatm_data *usbatm_instance,\r\nstruct usb_interface *usb_intf)\r\n{\r\nconst struct firmware *fw, *bp;\r\nstruct cxacru_data *instance = usbatm_instance->driver_data;\r\nint ret = cxacru_find_firmware(instance, "fw", &fw);\r\nif (ret) {\r\nusb_warn(usbatm_instance, "firmware (cxacru-fw.bin) unavailable (system misconfigured?)\n");\r\nreturn ret;\r\n}\r\nif (instance->modem_type->boot_rom_patch) {\r\nret = cxacru_find_firmware(instance, "bp", &bp);\r\nif (ret) {\r\nusb_warn(usbatm_instance, "boot ROM patch (cxacru-bp.bin) unavailable (system misconfigured?)\n");\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\n}\r\ncxacru_upload_firmware(instance, fw, bp);\r\nif (instance->modem_type->boot_rom_patch)\r\nrelease_firmware(bp);\r\nrelease_firmware(fw);\r\nret = cxacru_card_status(instance);\r\nif (ret)\r\nusb_dbg(usbatm_instance, "modem initialisation failed\n");\r\nelse\r\nusb_dbg(usbatm_instance, "done setting up the modem\n");\r\nreturn ret;\r\n}\r\nstatic int cxacru_bind(struct usbatm_data *usbatm_instance,\r\nstruct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct cxacru_data *instance;\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct usb_host_endpoint *cmd_ep = usb_dev->ep_in[CXACRU_EP_CMD];\r\nint ret;\r\ninstance = kzalloc(sizeof(*instance), GFP_KERNEL);\r\nif (!instance) {\r\nusb_dbg(usbatm_instance, "cxacru_bind: no memory for instance data\n");\r\nreturn -ENOMEM;\r\n}\r\ninstance->usbatm = usbatm_instance;\r\ninstance->modem_type = (struct cxacru_modem_type *) id->driver_info;\r\nmutex_init(&instance->poll_state_serialize);\r\ninstance->poll_state = CXPOLL_STOPPED;\r\ninstance->line_status = -1;\r\ninstance->adsl_status = -1;\r\nmutex_init(&instance->adsl_state_serialize);\r\ninstance->rcv_buf = (u8 *) __get_free_page(GFP_KERNEL);\r\nif (!instance->rcv_buf) {\r\nusb_dbg(usbatm_instance, "cxacru_bind: no memory for rcv_buf\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\ninstance->snd_buf = (u8 *) __get_free_page(GFP_KERNEL);\r\nif (!instance->snd_buf) {\r\nusb_dbg(usbatm_instance, "cxacru_bind: no memory for snd_buf\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\ninstance->rcv_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!instance->rcv_urb) {\r\nusb_dbg(usbatm_instance, "cxacru_bind: no memory for rcv_urb\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\ninstance->snd_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!instance->snd_urb) {\r\nusb_dbg(usbatm_instance, "cxacru_bind: no memory for snd_urb\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nif (!cmd_ep) {\r\nusb_dbg(usbatm_instance, "cxacru_bind: no command endpoint\n");\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\nif ((cmd_ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)\r\n== USB_ENDPOINT_XFER_INT) {\r\nusb_fill_int_urb(instance->rcv_urb,\r\nusb_dev, usb_rcvintpipe(usb_dev, CXACRU_EP_CMD),\r\ninstance->rcv_buf, PAGE_SIZE,\r\ncxacru_blocking_completion, &instance->rcv_done, 1);\r\nusb_fill_int_urb(instance->snd_urb,\r\nusb_dev, usb_sndintpipe(usb_dev, CXACRU_EP_CMD),\r\ninstance->snd_buf, PAGE_SIZE,\r\ncxacru_blocking_completion, &instance->snd_done, 4);\r\n} else {\r\nusb_fill_bulk_urb(instance->rcv_urb,\r\nusb_dev, usb_rcvbulkpipe(usb_dev, CXACRU_EP_CMD),\r\ninstance->rcv_buf, PAGE_SIZE,\r\ncxacru_blocking_completion, &instance->rcv_done);\r\nusb_fill_bulk_urb(instance->snd_urb,\r\nusb_dev, usb_sndbulkpipe(usb_dev, CXACRU_EP_CMD),\r\ninstance->snd_buf, PAGE_SIZE,\r\ncxacru_blocking_completion, &instance->snd_done);\r\n}\r\nmutex_init(&instance->cm_serialize);\r\nINIT_DELAYED_WORK(&instance->poll_work, cxacru_poll_status);\r\nusbatm_instance->driver_data = instance;\r\nusbatm_instance->flags = (cxacru_card_status(instance) ? 0 : UDSL_SKIP_HEAVY_INIT);\r\nreturn 0;\r\nfail:\r\nfree_page((unsigned long) instance->snd_buf);\r\nfree_page((unsigned long) instance->rcv_buf);\r\nusb_free_urb(instance->snd_urb);\r\nusb_free_urb(instance->rcv_urb);\r\nkfree(instance);\r\nreturn ret;\r\n}\r\nstatic void cxacru_unbind(struct usbatm_data *usbatm_instance,\r\nstruct usb_interface *intf)\r\n{\r\nstruct cxacru_data *instance = usbatm_instance->driver_data;\r\nint is_polling = 1;\r\nusb_dbg(usbatm_instance, "cxacru_unbind entered\n");\r\nif (!instance) {\r\nusb_dbg(usbatm_instance, "cxacru_unbind: NULL instance!\n");\r\nreturn;\r\n}\r\nmutex_lock(&instance->poll_state_serialize);\r\nBUG_ON(instance->poll_state == CXPOLL_SHUTDOWN);\r\nif (instance->poll_state == CXPOLL_STOPPED)\r\nis_polling = 0;\r\ninstance->poll_state = CXPOLL_SHUTDOWN;\r\nmutex_unlock(&instance->poll_state_serialize);\r\nif (is_polling)\r\ncancel_delayed_work_sync(&instance->poll_work);\r\nusb_kill_urb(instance->snd_urb);\r\nusb_kill_urb(instance->rcv_urb);\r\nusb_free_urb(instance->snd_urb);\r\nusb_free_urb(instance->rcv_urb);\r\nfree_page((unsigned long) instance->snd_buf);\r\nfree_page((unsigned long) instance->rcv_buf);\r\nkfree(instance);\r\nusbatm_instance->driver_data = NULL;\r\n}\r\nstatic int cxacru_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nchar buf[15];\r\nif (usb_dev->descriptor.bDeviceClass == USB_CLASS_VENDOR_SPEC\r\n&& usb_string(usb_dev, usb_dev->descriptor.iProduct,\r\nbuf, sizeof(buf)) > 0) {\r\nif (!strcmp(buf, "USB NET CARD")) {\r\ndev_info(&intf->dev, "ignoring cx82310_eth device\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn usbatm_usb_probe(intf, id, &cxacru_driver);\r\n}
