static int\r\ntlc591xx_set_mode(struct regmap *regmap, u8 mode)\r\n{\r\nint err;\r\nu8 val;\r\nerr = regmap_write(regmap, TLC591XX_REG_MODE1, MODE1_NORMAL_MODE);\r\nif (err)\r\nreturn err;\r\nval = MODE2_OCH_STOP | mode;\r\nreturn regmap_write(regmap, TLC591XX_REG_MODE2, val);\r\n}\r\nstatic int\r\ntlc591xx_set_ledout(struct tlc591xx_priv *priv, struct tlc591xx_led *led,\r\nu8 val)\r\n{\r\nunsigned int i = (led->led_no % 4) * 2;\r\nunsigned int mask = LEDOUT_MASK << i;\r\nunsigned int addr = priv->reg_ledout_offset + (led->led_no >> 2);\r\nval = val << i;\r\nreturn regmap_update_bits(priv->regmap, addr, mask, val);\r\n}\r\nstatic int\r\ntlc591xx_set_pwm(struct tlc591xx_priv *priv, struct tlc591xx_led *led,\r\nu8 brightness)\r\n{\r\nu8 pwm = TLC591XX_REG_PWM(led->led_no);\r\nreturn regmap_write(priv->regmap, pwm, brightness);\r\n}\r\nstatic int\r\ntlc591xx_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct tlc591xx_led *led = ldev_to_led(led_cdev);\r\nstruct tlc591xx_priv *priv = led->priv;\r\nint err;\r\nswitch (brightness) {\r\ncase 0:\r\nerr = tlc591xx_set_ledout(priv, led, LEDOUT_OFF);\r\nbreak;\r\ncase LED_FULL:\r\nerr = tlc591xx_set_ledout(priv, led, LEDOUT_ON);\r\nbreak;\r\ndefault:\r\nerr = tlc591xx_set_ledout(priv, led, LEDOUT_DIM);\r\nif (!err)\r\nerr = tlc591xx_set_pwm(priv, led, brightness);\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\ntlc591xx_destroy_devices(struct tlc591xx_priv *priv, unsigned int j)\r\n{\r\nint i = j;\r\nwhile (--i >= 0) {\r\nif (priv->leds[i].active)\r\nled_classdev_unregister(&priv->leds[i].ldev);\r\n}\r\n}\r\nstatic int\r\ntlc591xx_configure(struct device *dev,\r\nstruct tlc591xx_priv *priv,\r\nconst struct tlc591xx *tlc591xx)\r\n{\r\nunsigned int i;\r\nint err = 0;\r\ntlc591xx_set_mode(priv->regmap, MODE2_DIM);\r\nfor (i = 0; i < TLC591XX_MAX_LEDS; i++) {\r\nstruct tlc591xx_led *led = &priv->leds[i];\r\nif (!led->active)\r\ncontinue;\r\nled->priv = priv;\r\nled->led_no = i;\r\nled->ldev.brightness_set_blocking = tlc591xx_brightness_set;\r\nled->ldev.max_brightness = LED_FULL;\r\nerr = led_classdev_register(dev, &led->ldev);\r\nif (err < 0) {\r\ndev_err(dev, "couldn't register LED %s\n",\r\nled->ldev.name);\r\ngoto exit;\r\n}\r\n}\r\nreturn 0;\r\nexit:\r\ntlc591xx_destroy_devices(priv, i);\r\nreturn err;\r\n}\r\nstatic int\r\ntlc591xx_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device_node *np = client->dev.of_node, *child;\r\nstruct device *dev = &client->dev;\r\nconst struct of_device_id *match;\r\nconst struct tlc591xx *tlc591xx;\r\nstruct tlc591xx_priv *priv;\r\nint err, count, reg;\r\nmatch = of_match_device(of_tlc591xx_leds_match, dev);\r\nif (!match)\r\nreturn -ENODEV;\r\ntlc591xx = match->data;\r\nif (!np)\r\nreturn -ENODEV;\r\ncount = of_get_child_count(np);\r\nif (!count || count > tlc591xx->max_leds)\r\nreturn -EINVAL;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->regmap = devm_regmap_init_i2c(client, &tlc591xx_regmap);\r\nif (IS_ERR(priv->regmap)) {\r\nerr = PTR_ERR(priv->regmap);\r\ndev_err(dev, "Failed to allocate register map: %d\n", err);\r\nreturn err;\r\n}\r\npriv->reg_ledout_offset = tlc591xx->reg_ledout_offset;\r\ni2c_set_clientdata(client, priv);\r\nfor_each_child_of_node(np, child) {\r\nerr = of_property_read_u32(child, "reg", &reg);\r\nif (err)\r\nreturn err;\r\nif (reg < 0 || reg >= tlc591xx->max_leds)\r\nreturn -EINVAL;\r\nif (priv->leds[reg].active)\r\nreturn -EINVAL;\r\npriv->leds[reg].active = true;\r\npriv->leds[reg].ldev.name =\r\nof_get_property(child, "label", NULL) ? : child->name;\r\npriv->leds[reg].ldev.default_trigger =\r\nof_get_property(child, "linux,default-trigger", NULL);\r\n}\r\nreturn tlc591xx_configure(dev, priv, tlc591xx);\r\n}\r\nstatic int\r\ntlc591xx_remove(struct i2c_client *client)\r\n{\r\nstruct tlc591xx_priv *priv = i2c_get_clientdata(client);\r\ntlc591xx_destroy_devices(priv, TLC591XX_MAX_LEDS);\r\nreturn 0;\r\n}
