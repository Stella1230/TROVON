struct page **ceph_get_direct_page_vector(const void __user *data,\r\nint num_pages, bool write_page)\r\n{\r\nstruct page **pages;\r\nint got = 0;\r\nint rc = 0;\r\npages = kmalloc(sizeof(*pages) * num_pages, GFP_NOFS);\r\nif (!pages)\r\nreturn ERR_PTR(-ENOMEM);\r\nwhile (got < num_pages) {\r\nrc = get_user_pages_unlocked(\r\n(unsigned long)data + ((unsigned long)got * PAGE_SIZE),\r\nnum_pages - got, write_page, 0, pages + got);\r\nif (rc < 0)\r\nbreak;\r\nBUG_ON(rc == 0);\r\ngot += rc;\r\n}\r\nif (rc < 0)\r\ngoto fail;\r\nreturn pages;\r\nfail:\r\nceph_put_page_vector(pages, got, false);\r\nreturn ERR_PTR(rc);\r\n}\r\nvoid ceph_put_page_vector(struct page **pages, int num_pages, bool dirty)\r\n{\r\nint i;\r\nfor (i = 0; i < num_pages; i++) {\r\nif (dirty)\r\nset_page_dirty_lock(pages[i]);\r\nput_page(pages[i]);\r\n}\r\nkvfree(pages);\r\n}\r\nvoid ceph_release_page_vector(struct page **pages, int num_pages)\r\n{\r\nint i;\r\nfor (i = 0; i < num_pages; i++)\r\n__free_pages(pages[i], 0);\r\nkfree(pages);\r\n}\r\nstruct page **ceph_alloc_page_vector(int num_pages, gfp_t flags)\r\n{\r\nstruct page **pages;\r\nint i;\r\npages = kmalloc(sizeof(*pages) * num_pages, flags);\r\nif (!pages)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < num_pages; i++) {\r\npages[i] = __page_cache_alloc(flags);\r\nif (pages[i] == NULL) {\r\nceph_release_page_vector(pages, i);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\nreturn pages;\r\n}\r\nint ceph_copy_user_to_page_vector(struct page **pages,\r\nconst void __user *data,\r\nloff_t off, size_t len)\r\n{\r\nint i = 0;\r\nint po = off & ~PAGE_MASK;\r\nint left = len;\r\nint l, bad;\r\nwhile (left > 0) {\r\nl = min_t(int, PAGE_SIZE-po, left);\r\nbad = copy_from_user(page_address(pages[i]) + po, data, l);\r\nif (bad == l)\r\nreturn -EFAULT;\r\ndata += l - bad;\r\nleft -= l - bad;\r\npo += l - bad;\r\nif (po == PAGE_SIZE) {\r\npo = 0;\r\ni++;\r\n}\r\n}\r\nreturn len;\r\n}\r\nvoid ceph_copy_to_page_vector(struct page **pages,\r\nconst void *data,\r\nloff_t off, size_t len)\r\n{\r\nint i = 0;\r\nsize_t po = off & ~PAGE_MASK;\r\nsize_t left = len;\r\nwhile (left > 0) {\r\nsize_t l = min_t(size_t, PAGE_SIZE-po, left);\r\nmemcpy(page_address(pages[i]) + po, data, l);\r\ndata += l;\r\nleft -= l;\r\npo += l;\r\nif (po == PAGE_SIZE) {\r\npo = 0;\r\ni++;\r\n}\r\n}\r\n}\r\nvoid ceph_copy_from_page_vector(struct page **pages,\r\nvoid *data,\r\nloff_t off, size_t len)\r\n{\r\nint i = 0;\r\nsize_t po = off & ~PAGE_MASK;\r\nsize_t left = len;\r\nwhile (left > 0) {\r\nsize_t l = min_t(size_t, PAGE_SIZE-po, left);\r\nmemcpy(data, page_address(pages[i]) + po, l);\r\ndata += l;\r\nleft -= l;\r\npo += l;\r\nif (po == PAGE_SIZE) {\r\npo = 0;\r\ni++;\r\n}\r\n}\r\n}\r\nvoid ceph_zero_page_vector_range(int off, int len, struct page **pages)\r\n{\r\nint i = off >> PAGE_SHIFT;\r\noff &= ~PAGE_MASK;\r\ndout("zero_page_vector_page %u~%u\n", off, len);\r\nif (off) {\r\nint end = min((int)PAGE_SIZE, off + len);\r\ndout("zeroing %d %p head from %d\n", i, pages[i],\r\n(int)off);\r\nzero_user_segment(pages[i], off, end);\r\nlen -= (end - off);\r\ni++;\r\n}\r\nwhile (len >= PAGE_SIZE) {\r\ndout("zeroing %d %p len=%d\n", i, pages[i], len);\r\nzero_user_segment(pages[i], 0, PAGE_SIZE);\r\nlen -= PAGE_SIZE;\r\ni++;\r\n}\r\nif (len) {\r\ndout("zeroing %d %p tail to %d\n", i, pages[i], (int)len);\r\nzero_user_segment(pages[i], 0, len);\r\n}\r\n}
