static void sun4i_get_pll1_factors(struct factors_request *req)\r\n{\r\nu8 div;\r\ndiv = req->rate / 6000000;\r\nreq->rate = 6000000 * div;\r\nreq->m = 0;\r\nif (req->rate >= 768000000 || req->rate == 42000000 ||\r\nreq->rate == 54000000)\r\nreq->k = 1;\r\nelse\r\nreq->k = 0;\r\nif (div < 10)\r\nreq->p = 3;\r\nelse if (div < 20 || (div < 32 && (div & 1)))\r\nreq->p = 2;\r\nelse if (div < 40 || (div < 64 && (div & 2)))\r\nreq->p = 1;\r\nelse\r\nreq->p = 0;\r\ndiv <<= req->p;\r\ndiv /= (req->k + 1);\r\nreq->n = div / 4;\r\n}\r\nstatic void sun6i_a31_get_pll1_factors(struct factors_request *req)\r\n{\r\nu32 freq_mhz = req->rate / 1000000;\r\nu32 parent_freq_mhz = req->parent_rate / 1000000;\r\nu32 round_freq_6 = round_down(freq_mhz, 6);\r\nu32 round_freq_16 = round_down(freq_mhz, 16);\r\nif (round_freq_6 > round_freq_16)\r\nfreq_mhz = round_freq_6;\r\nelse\r\nfreq_mhz = round_freq_16;\r\nreq->rate = freq_mhz * 1000000;\r\nif (!(freq_mhz % 32))\r\nreq->k = 3;\r\nelse if (!(freq_mhz % 9))\r\nreq->k = 2;\r\nelse if (!(freq_mhz % 8))\r\nreq->k = 1;\r\nelse\r\nreq->k = 0;\r\nif ((freq_mhz % 6) == 2 || (freq_mhz % 6) == 4)\r\nreq->m = 2;\r\nelse if ((freq_mhz / 6) & 1)\r\nreq->m = 3;\r\nelse\r\nreq->m = 1;\r\nreq->n = freq_mhz * (req->m + 1) / ((req->k + 1) * parent_freq_mhz)\r\n- 1;\r\nif ((req->n + 1) > 31 && (req->m + 1) > 1) {\r\nreq->n = (req->n + 1) / 2 - 1;\r\nreq->m = (req->m + 1) / 2 - 1;\r\n}\r\n}\r\nstatic void sun8i_a23_get_pll1_factors(struct factors_request *req)\r\n{\r\nu8 div;\r\ndiv = req->rate / 6000000;\r\nreq->rate = 6000000 * div;\r\nreq->m = 0;\r\nif (req->rate >= 768000000 || req->rate == 42000000 ||\r\nreq->rate == 54000000)\r\nreq->k = 1;\r\nelse\r\nreq->k = 0;\r\nif (div < 20 || (div < 32 && (div & 1)))\r\nreq->p = 2;\r\nelse if (div < 40 || (div < 64 && (div & 2)))\r\nreq->p = 1;\r\nelse\r\nreq->p = 0;\r\ndiv <<= req->p;\r\ndiv /= (req->k + 1);\r\nreq->n = div / 4 - 1;\r\n}\r\nstatic void sun4i_get_pll5_factors(struct factors_request *req)\r\n{\r\nu8 div;\r\ndiv = req->rate / req->parent_rate;\r\nreq->rate = req->parent_rate * div;\r\nif (div < 31)\r\nreq->k = 0;\r\nelse if (div / 2 < 31)\r\nreq->k = 1;\r\nelse if (div / 3 < 31)\r\nreq->k = 2;\r\nelse\r\nreq->k = 3;\r\nreq->n = DIV_ROUND_UP(div, (req->k + 1));\r\n}\r\nstatic void sun6i_a31_get_pll6_factors(struct factors_request *req)\r\n{\r\nu8 div;\r\ndiv = req->rate / req->parent_rate;\r\nreq->rate = req->parent_rate * div;\r\nreq->k = div / 32;\r\nif (req->k > 3)\r\nreq->k = 3;\r\nreq->n = DIV_ROUND_UP(div, (req->k + 1)) - 1;\r\n}\r\nstatic void sun5i_a13_get_ahb_factors(struct factors_request *req)\r\n{\r\nu32 div;\r\nif (req->parent_rate < req->rate)\r\nreq->rate = req->parent_rate;\r\nif (req->rate < 8000)\r\nreq->rate = 8000;\r\nif (req->rate > 300000000)\r\nreq->rate = 300000000;\r\ndiv = order_base_2(DIV_ROUND_UP(req->parent_rate, req->rate));\r\nif (div > 3)\r\ndiv = 3;\r\nreq->rate = req->parent_rate >> div;\r\nreq->p = div;\r\n}\r\nstatic void sun6i_get_ahb1_factors(struct factors_request *req)\r\n{\r\nu8 div, calcp, calcm = 1;\r\nif (req->parent_rate && req->rate > req->parent_rate)\r\nreq->rate = req->parent_rate;\r\ndiv = DIV_ROUND_UP(req->parent_rate, req->rate);\r\nif (req->parent_index == SUN6I_AHB1_PARENT_PLL6) {\r\nif (div < 4)\r\ncalcp = 0;\r\nelse if (div / 2 < 4)\r\ncalcp = 1;\r\nelse if (div / 4 < 4)\r\ncalcp = 2;\r\nelse\r\ncalcp = 3;\r\ncalcm = DIV_ROUND_UP(div, 1 << calcp);\r\n} else {\r\ncalcp = __roundup_pow_of_two(div);\r\ncalcp = calcp > 3 ? 3 : calcp;\r\n}\r\nreq->rate = (req->parent_rate / calcm) >> calcp;\r\nreq->p = calcp;\r\nreq->m = calcm - 1;\r\n}\r\nstatic void sun6i_ahb1_recalc(struct factors_request *req)\r\n{\r\nreq->rate = req->parent_rate;\r\nif (req->parent_index == SUN6I_AHB1_PARENT_PLL6)\r\nreq->rate /= req->m + 1;\r\nreq->rate >>= req->p;\r\n}\r\nstatic void sun4i_get_apb1_factors(struct factors_request *req)\r\n{\r\nu8 calcm, calcp;\r\nint div;\r\nif (req->parent_rate < req->rate)\r\nreq->rate = req->parent_rate;\r\ndiv = DIV_ROUND_UP(req->parent_rate, req->rate);\r\nif (div > 32)\r\nreturn;\r\nif (div <= 4)\r\ncalcp = 0;\r\nelse if (div <= 8)\r\ncalcp = 1;\r\nelse if (div <= 16)\r\ncalcp = 2;\r\nelse\r\ncalcp = 3;\r\ncalcm = (req->parent_rate >> calcp) - 1;\r\nreq->rate = (req->parent_rate >> calcp) / (calcm + 1);\r\nreq->m = calcm;\r\nreq->p = calcp;\r\n}\r\nstatic void sun7i_a20_get_out_factors(struct factors_request *req)\r\n{\r\nu8 div, calcm, calcp;\r\nif (req->rate > req->parent_rate)\r\nreq->rate = req->parent_rate;\r\ndiv = DIV_ROUND_UP(req->parent_rate, req->rate);\r\nif (div < 32)\r\ncalcp = 0;\r\nelse if (div / 2 < 32)\r\ncalcp = 1;\r\nelse if (div / 4 < 32)\r\ncalcp = 2;\r\nelse\r\ncalcp = 3;\r\ncalcm = DIV_ROUND_UP(div, 1 << calcp);\r\nreq->rate = (req->parent_rate >> calcp) / calcm;\r\nreq->m = calcm - 1;\r\nreq->p = calcp;\r\n}\r\nstatic struct clk * __init sunxi_factors_clk_setup(struct device_node *node,\r\nconst struct factors_data *data)\r\n{\r\nvoid __iomem *reg;\r\nreg = of_iomap(node, 0);\r\nif (!reg) {\r\npr_err("Could not get registers for factors-clk: %s\n",\r\nnode->name);\r\nreturn NULL;\r\n}\r\nreturn sunxi_factors_register(node, data, &clk_lock, reg);\r\n}\r\nstatic void __init sun4i_pll1_clk_setup(struct device_node *node)\r\n{\r\nsunxi_factors_clk_setup(node, &sun4i_pll1_data);\r\n}\r\nstatic void __init sun6i_pll1_clk_setup(struct device_node *node)\r\n{\r\nsunxi_factors_clk_setup(node, &sun6i_a31_pll1_data);\r\n}\r\nstatic void __init sun8i_pll1_clk_setup(struct device_node *node)\r\n{\r\nsunxi_factors_clk_setup(node, &sun8i_a23_pll1_data);\r\n}\r\nstatic void __init sun7i_pll4_clk_setup(struct device_node *node)\r\n{\r\nsunxi_factors_clk_setup(node, &sun7i_a20_pll4_data);\r\n}\r\nstatic void __init sun5i_ahb_clk_setup(struct device_node *node)\r\n{\r\nsunxi_factors_clk_setup(node, &sun5i_a13_ahb_data);\r\n}\r\nstatic void __init sun6i_ahb1_clk_setup(struct device_node *node)\r\n{\r\nsunxi_factors_clk_setup(node, &sun6i_ahb1_data);\r\n}\r\nstatic void __init sun4i_apb1_clk_setup(struct device_node *node)\r\n{\r\nsunxi_factors_clk_setup(node, &sun4i_apb1_data);\r\n}\r\nstatic void __init sun7i_out_clk_setup(struct device_node *node)\r\n{\r\nsunxi_factors_clk_setup(node, &sun7i_a20_out_data);\r\n}\r\nstatic struct clk * __init sunxi_mux_clk_setup(struct device_node *node,\r\nconst struct mux_data *data)\r\n{\r\nstruct clk *clk;\r\nconst char *clk_name = node->name;\r\nconst char *parents[SUNXI_MAX_PARENTS];\r\nvoid __iomem *reg;\r\nint i;\r\nreg = of_iomap(node, 0);\r\nif (!reg) {\r\npr_err("Could not map registers for mux-clk: %s\n",\r\nof_node_full_name(node));\r\nreturn NULL;\r\n}\r\ni = of_clk_parent_fill(node, parents, SUNXI_MAX_PARENTS);\r\nif (of_property_read_string(node, "clock-output-names", &clk_name)) {\r\npr_err("%s: could not read clock-output-names from \"%s\"\n",\r\n__func__, of_node_full_name(node));\r\ngoto out_unmap;\r\n}\r\nclk = clk_register_mux(NULL, clk_name, parents, i,\r\nCLK_SET_RATE_PARENT, reg,\r\ndata->shift, SUNXI_MUX_GATE_WIDTH,\r\n0, &clk_lock);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: failed to register mux clock %s: %ld\n", __func__,\r\nclk_name, PTR_ERR(clk));\r\ngoto out_unmap;\r\n}\r\nif (of_clk_add_provider(node, of_clk_src_simple_get, clk)) {\r\npr_err("%s: failed to add clock provider for %s\n",\r\n__func__, clk_name);\r\nclk_unregister_divider(clk);\r\ngoto out_unmap;\r\n}\r\nreturn clk;\r\nout_unmap:\r\niounmap(reg);\r\nreturn NULL;\r\n}\r\nstatic void __init sun4i_cpu_clk_setup(struct device_node *node)\r\n{\r\nstruct clk *clk;\r\nclk = sunxi_mux_clk_setup(node, &sun4i_cpu_mux_data);\r\nif (!clk)\r\nreturn;\r\n__clk_get(clk);\r\nclk_prepare_enable(clk);\r\n}\r\nstatic void __init sun6i_ahb1_mux_clk_setup(struct device_node *node)\r\n{\r\nsunxi_mux_clk_setup(node, &sun6i_a31_ahb1_mux_data);\r\n}\r\nstatic void __init sun8i_ahb2_clk_setup(struct device_node *node)\r\n{\r\nsunxi_mux_clk_setup(node, &sun8i_h3_ahb2_mux_data);\r\n}\r\nstatic void __init sunxi_divider_clk_setup(struct device_node *node,\r\nconst struct div_data *data)\r\n{\r\nstruct clk *clk;\r\nconst char *clk_name = node->name;\r\nconst char *clk_parent;\r\nvoid __iomem *reg;\r\nreg = of_iomap(node, 0);\r\nif (!reg) {\r\npr_err("Could not map registers for mux-clk: %s\n",\r\nof_node_full_name(node));\r\nreturn;\r\n}\r\nclk_parent = of_clk_get_parent_name(node, 0);\r\nif (of_property_read_string(node, "clock-output-names", &clk_name)) {\r\npr_err("%s: could not read clock-output-names from \"%s\"\n",\r\n__func__, of_node_full_name(node));\r\ngoto out_unmap;\r\n}\r\nclk = clk_register_divider_table(NULL, clk_name, clk_parent, 0,\r\nreg, data->shift, data->width,\r\ndata->pow ? CLK_DIVIDER_POWER_OF_TWO : 0,\r\ndata->table, &clk_lock);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: failed to register divider clock %s: %ld\n",\r\n__func__, clk_name, PTR_ERR(clk));\r\ngoto out_unmap;\r\n}\r\nif (of_clk_add_provider(node, of_clk_src_simple_get, clk)) {\r\npr_err("%s: failed to add clock provider for %s\n",\r\n__func__, clk_name);\r\ngoto out_unregister;\r\n}\r\nif (clk_register_clkdev(clk, clk_name, NULL)) {\r\nof_clk_del_provider(node);\r\ngoto out_unregister;\r\n}\r\nreturn;\r\nout_unregister:\r\nclk_unregister_divider(clk);\r\nout_unmap:\r\niounmap(reg);\r\n}\r\nstatic void __init sun4i_ahb_clk_setup(struct device_node *node)\r\n{\r\nsunxi_divider_clk_setup(node, &sun4i_ahb_data);\r\n}\r\nstatic void __init sun4i_apb0_clk_setup(struct device_node *node)\r\n{\r\nsunxi_divider_clk_setup(node, &sun4i_apb0_data);\r\n}\r\nstatic void __init sun4i_axi_clk_setup(struct device_node *node)\r\n{\r\nsunxi_divider_clk_setup(node, &sun4i_axi_data);\r\n}\r\nstatic void __init sun8i_axi_clk_setup(struct device_node *node)\r\n{\r\nsunxi_divider_clk_setup(node, &sun8i_a23_axi_data);\r\n}\r\nstatic struct clk ** __init sunxi_divs_clk_setup(struct device_node *node,\r\nconst struct divs_data *data)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nconst char *parent;\r\nconst char *clk_name;\r\nstruct clk **clks, *pclk;\r\nstruct clk_hw *gate_hw, *rate_hw;\r\nconst struct clk_ops *rate_ops;\r\nstruct clk_gate *gate = NULL;\r\nstruct clk_fixed_factor *fix_factor;\r\nstruct clk_divider *divider;\r\nstruct factors_data factors = *data->factors;\r\nchar *derived_name = NULL;\r\nvoid __iomem *reg;\r\nint ndivs = SUNXI_DIVS_MAX_QTY, i = 0;\r\nint flags, clkflags;\r\nif (data->ndivs)\r\nndivs = data->ndivs;\r\nfor (i = 0; i < ndivs; i++) {\r\nif (data->div[i].self) {\r\nof_property_read_string_index(node, "clock-output-names",\r\ni, &factors.name);\r\nbreak;\r\n}\r\n}\r\nif (factors.name == NULL) {\r\nchar *endp;\r\nof_property_read_string_index(node, "clock-output-names",\r\n0, &clk_name);\r\nendp = strchr(clk_name, '_');\r\nif (endp) {\r\nderived_name = kstrndup(clk_name, endp - clk_name,\r\nGFP_KERNEL);\r\nfactors.name = derived_name;\r\n} else {\r\nfactors.name = clk_name;\r\n}\r\n}\r\npclk = sunxi_factors_clk_setup(node, &factors);\r\nif (!pclk)\r\nreturn NULL;\r\nparent = __clk_get_name(pclk);\r\nkfree(derived_name);\r\nreg = of_iomap(node, 0);\r\nif (!reg) {\r\npr_err("Could not map registers for divs-clk: %s\n",\r\nof_node_full_name(node));\r\nreturn NULL;\r\n}\r\nclk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);\r\nif (!clk_data)\r\ngoto out_unmap;\r\nclks = kcalloc(ndivs, sizeof(*clks), GFP_KERNEL);\r\nif (!clks)\r\ngoto free_clkdata;\r\nclk_data->clks = clks;\r\nclkflags = !strcmp("pll5", parent) ? 0 : CLK_SET_RATE_PARENT;\r\nfor (i = 0; i < ndivs; i++) {\r\nif (of_property_read_string_index(node, "clock-output-names",\r\ni, &clk_name) != 0)\r\nbreak;\r\nif (data->div[i].self) {\r\nclk_data->clks[i] = pclk;\r\ncontinue;\r\n}\r\ngate_hw = NULL;\r\nrate_hw = NULL;\r\nrate_ops = NULL;\r\nif (data->div[i].gate) {\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate)\r\ngoto free_clks;\r\ngate->reg = reg;\r\ngate->bit_idx = data->div[i].gate;\r\ngate->lock = &clk_lock;\r\ngate_hw = &gate->hw;\r\n}\r\nif (data->div[i].fixed) {\r\nfix_factor = kzalloc(sizeof(*fix_factor), GFP_KERNEL);\r\nif (!fix_factor)\r\ngoto free_gate;\r\nfix_factor->mult = 1;\r\nfix_factor->div = data->div[i].fixed;\r\nrate_hw = &fix_factor->hw;\r\nrate_ops = &clk_fixed_factor_ops;\r\n} else {\r\ndivider = kzalloc(sizeof(*divider), GFP_KERNEL);\r\nif (!divider)\r\ngoto free_gate;\r\nflags = data->div[i].pow ? CLK_DIVIDER_POWER_OF_TWO : 0;\r\ndivider->reg = reg;\r\ndivider->shift = data->div[i].shift;\r\ndivider->width = SUNXI_DIVISOR_WIDTH;\r\ndivider->flags = flags;\r\ndivider->lock = &clk_lock;\r\ndivider->table = data->div[i].table;\r\nrate_hw = &divider->hw;\r\nrate_ops = &clk_divider_ops;\r\n}\r\nclks[i] = clk_register_composite(NULL, clk_name, &parent, 1,\r\nNULL, NULL,\r\nrate_hw, rate_ops,\r\ngate_hw, &clk_gate_ops,\r\nclkflags);\r\nWARN_ON(IS_ERR(clk_data->clks[i]));\r\n}\r\nclk_data->clk_num = i;\r\nif (of_clk_add_provider(node, of_clk_src_onecell_get, clk_data)) {\r\npr_err("%s: failed to add clock provider for %s\n",\r\n__func__, clk_name);\r\ngoto free_gate;\r\n}\r\nreturn clks;\r\nfree_gate:\r\nkfree(gate);\r\nfree_clks:\r\nkfree(clks);\r\nfree_clkdata:\r\nkfree(clk_data);\r\nout_unmap:\r\niounmap(reg);\r\nreturn NULL;\r\n}\r\nstatic void __init sun4i_pll5_clk_setup(struct device_node *node)\r\n{\r\nstruct clk **clks;\r\nclks = sunxi_divs_clk_setup(node, &pll5_divs_data);\r\nif (!clks)\r\nreturn;\r\n__clk_get(clks[0]);\r\nclk_prepare_enable(clks[0]);\r\n}\r\nstatic void __init sun4i_pll6_clk_setup(struct device_node *node)\r\n{\r\nsunxi_divs_clk_setup(node, &pll6_divs_data);\r\n}\r\nstatic void __init sun6i_pll6_clk_setup(struct device_node *node)\r\n{\r\nsunxi_divs_clk_setup(node, &sun6i_a31_pll6_divs_data);\r\n}\r\nstatic void sun6i_display_factors(struct factors_request *req)\r\n{\r\nu8 m;\r\nif (req->rate > req->parent_rate)\r\nreq->rate = req->parent_rate;\r\nm = DIV_ROUND_UP(req->parent_rate, req->rate);\r\nreq->rate = req->parent_rate / m;\r\nreq->m = m - 1;\r\n}\r\nstatic void __init sun6i_display_setup(struct device_node *node)\r\n{\r\nsunxi_factors_clk_setup(node, &sun6i_display_data);\r\n}
