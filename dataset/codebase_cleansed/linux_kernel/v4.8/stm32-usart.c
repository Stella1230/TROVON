static inline struct stm32_port *to_stm32_port(struct uart_port *port)\r\n{\r\nreturn container_of(port, struct stm32_port, port);\r\n}\r\nstatic void stm32_set_bits(struct uart_port *port, u32 reg, u32 bits)\r\n{\r\nu32 val;\r\nval = readl_relaxed(port->membase + reg);\r\nval |= bits;\r\nwritel_relaxed(val, port->membase + reg);\r\n}\r\nstatic void stm32_clr_bits(struct uart_port *port, u32 reg, u32 bits)\r\n{\r\nu32 val;\r\nval = readl_relaxed(port->membase + reg);\r\nval &= ~bits;\r\nwritel_relaxed(val, port->membase + reg);\r\n}\r\nstatic void stm32_receive_chars(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nunsigned long c;\r\nu32 sr;\r\nchar flag;\r\nif (port->irq_wake)\r\npm_wakeup_event(tport->tty->dev, 0);\r\nwhile ((sr = readl_relaxed(port->membase + USART_SR)) & USART_SR_RXNE) {\r\nsr |= USART_SR_DUMMY_RX;\r\nc = readl_relaxed(port->membase + USART_DR);\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nif (sr & USART_SR_ERR_MASK) {\r\nif (sr & USART_SR_LBD) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (sr & USART_SR_ORE) {\r\nport->icount.overrun++;\r\n} else if (sr & USART_SR_PE) {\r\nport->icount.parity++;\r\n} else if (sr & USART_SR_FE) {\r\nport->icount.frame++;\r\n}\r\nsr &= port->read_status_mask;\r\nif (sr & USART_SR_LBD)\r\nflag = TTY_BREAK;\r\nelse if (sr & USART_SR_PE)\r\nflag = TTY_PARITY;\r\nelse if (sr & USART_SR_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, c))\r\ncontinue;\r\nuart_insert_char(port, sr, USART_SR_ORE, c, flag);\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tport);\r\nspin_lock(&port->lock);\r\n}\r\nstatic void stm32_transmit_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (port->x_char) {\r\nwritel_relaxed(port->x_char, port->membase + USART_DR);\r\nport->x_char = 0;\r\nport->icount.tx++;\r\nreturn;\r\n}\r\nif (uart_tx_stopped(port)) {\r\nstm32_stop_tx(port);\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit)) {\r\nstm32_stop_tx(port);\r\nreturn;\r\n}\r\nwritel_relaxed(xmit->buf[xmit->tail], port->membase + USART_DR);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nstm32_stop_tx(port);\r\n}\r\nstatic irqreturn_t stm32_interrupt(int irq, void *ptr)\r\n{\r\nstruct uart_port *port = ptr;\r\nu32 sr;\r\nspin_lock(&port->lock);\r\nsr = readl_relaxed(port->membase + USART_SR);\r\nif (sr & USART_SR_RXNE)\r\nstm32_receive_chars(port);\r\nif (sr & USART_SR_TXE)\r\nstm32_transmit_chars(port);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int stm32_tx_empty(struct uart_port *port)\r\n{\r\nreturn readl_relaxed(port->membase + USART_SR) & USART_SR_TXE;\r\n}\r\nstatic void stm32_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nif ((mctrl & TIOCM_RTS) && (port->status & UPSTAT_AUTORTS))\r\nstm32_set_bits(port, USART_CR3, USART_CR3_RTSE);\r\nelse\r\nstm32_clr_bits(port, USART_CR3, USART_CR3_RTSE);\r\n}\r\nstatic unsigned int stm32_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void stm32_stop_tx(struct uart_port *port)\r\n{\r\nstm32_clr_bits(port, USART_CR1, USART_CR1_TXEIE);\r\n}\r\nstatic void stm32_start_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (uart_circ_empty(xmit))\r\nreturn;\r\nstm32_set_bits(port, USART_CR1, USART_CR1_TXEIE | USART_CR1_TE);\r\n}\r\nstatic void stm32_throttle(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nstm32_clr_bits(port, USART_CR1, USART_CR1_RXNEIE);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void stm32_unthrottle(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nstm32_set_bits(port, USART_CR1, USART_CR1_RXNEIE);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void stm32_stop_rx(struct uart_port *port)\r\n{\r\nstm32_clr_bits(port, USART_CR1, USART_CR1_RXNEIE);\r\n}\r\nstatic void stm32_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nstatic int stm32_startup(struct uart_port *port)\r\n{\r\nconst char *name = to_platform_device(port->dev)->name;\r\nu32 val;\r\nint ret;\r\nret = request_irq(port->irq, stm32_interrupt, 0, name, port);\r\nif (ret)\r\nreturn ret;\r\nval = USART_CR1_RXNEIE | USART_CR1_TE | USART_CR1_RE;\r\nstm32_set_bits(port, USART_CR1, val);\r\nreturn 0;\r\n}\r\nstatic void stm32_shutdown(struct uart_port *port)\r\n{\r\nu32 val;\r\nval = USART_CR1_TXEIE | USART_CR1_RXNEIE | USART_CR1_TE | USART_CR1_RE;\r\nstm32_set_bits(port, USART_CR1, val);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void stm32_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct stm32_port *stm32_port = to_stm32_port(port);\r\nunsigned int baud;\r\nu32 usartdiv, mantissa, fraction, oversampling;\r\ntcflag_t cflag = termios->c_cflag;\r\nu32 cr1, cr2, cr3;\r\nunsigned long flags;\r\nif (!stm32_port->hw_flow_control)\r\ncflag &= ~CRTSCTS;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 8);\r\nspin_lock_irqsave(&port->lock, flags);\r\nwritel_relaxed(0, port->membase + USART_CR1);\r\ncr1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE | USART_CR1_RXNEIE;\r\ncr2 = 0;\r\ncr3 = 0;\r\nif (cflag & CSTOPB)\r\ncr2 |= USART_CR2_STOP_2B;\r\nif (cflag & PARENB) {\r\ncr1 |= USART_CR1_PCE;\r\nif ((cflag & CSIZE) == CS8)\r\ncr1 |= USART_CR1_M;\r\n}\r\nif (cflag & PARODD)\r\ncr1 |= USART_CR1_PS;\r\nport->status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS);\r\nif (cflag & CRTSCTS) {\r\nport->status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;\r\ncr3 |= USART_CR3_CTSE;\r\n}\r\nusartdiv = DIV_ROUND_CLOSEST(port->uartclk, baud);\r\nif (usartdiv < 16) {\r\noversampling = 8;\r\nstm32_set_bits(port, USART_CR1, USART_CR1_OVER8);\r\n} else {\r\noversampling = 16;\r\nstm32_clr_bits(port, USART_CR1, USART_CR1_OVER8);\r\n}\r\nmantissa = (usartdiv / oversampling) << USART_BRR_DIV_M_SHIFT;\r\nfraction = usartdiv % oversampling;\r\nwritel_relaxed(mantissa | fraction, port->membase + USART_BRR);\r\nuart_update_timeout(port, cflag, baud);\r\nport->read_status_mask = USART_SR_ORE;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= USART_SR_PE | USART_SR_FE;\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nport->read_status_mask |= USART_SR_LBD;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask = USART_SR_PE | USART_SR_FE;\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= USART_SR_LBD;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= USART_SR_ORE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= USART_SR_DUMMY_RX;\r\nwritel_relaxed(cr3, port->membase + USART_CR3);\r\nwritel_relaxed(cr2, port->membase + USART_CR2);\r\nwritel_relaxed(cr1, port->membase + USART_CR1);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *stm32_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_STM32) ? DRIVER_NAME : NULL;\r\n}\r\nstatic void stm32_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int stm32_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void stm32_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_STM32;\r\n}\r\nstatic int\r\nstm32_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void stm32_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct stm32_port *stm32port = container_of(port,\r\nstruct stm32_port, port);\r\nunsigned long flags = 0;\r\nswitch (state) {\r\ncase UART_PM_STATE_ON:\r\nclk_prepare_enable(stm32port->clk);\r\nbreak;\r\ncase UART_PM_STATE_OFF:\r\nspin_lock_irqsave(&port->lock, flags);\r\nstm32_clr_bits(port, USART_CR1, USART_CR1_UE);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nclk_disable_unprepare(stm32port->clk);\r\nbreak;\r\n}\r\n}\r\nstatic int stm32_init_port(struct stm32_port *stm32port,\r\nstruct platform_device *pdev)\r\n{\r\nstruct uart_port *port = &stm32port->port;\r\nstruct resource *res;\r\nint ret;\r\nport->iotype = UPIO_MEM;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->ops = &stm32_uart_ops;\r\nport->dev = &pdev->dev;\r\nport->irq = platform_get_irq(pdev, 0);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nport->membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(port->membase))\r\nreturn PTR_ERR(port->membase);\r\nport->mapbase = res->start;\r\nspin_lock_init(&port->lock);\r\nstm32port->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(stm32port->clk))\r\nreturn PTR_ERR(stm32port->clk);\r\nret = clk_prepare_enable(stm32port->clk);\r\nif (ret)\r\nreturn ret;\r\nstm32port->port.uartclk = clk_get_rate(stm32port->clk);\r\nif (!stm32port->port.uartclk)\r\nret = -EINVAL;\r\nclk_disable_unprepare(stm32port->clk);\r\nreturn ret;\r\n}\r\nstatic struct stm32_port *stm32_of_get_stm32_port(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint id;\r\nif (!np)\r\nreturn NULL;\r\nid = of_alias_get_id(np, "serial");\r\nif (id < 0)\r\nid = 0;\r\nif (WARN_ON(id >= STM32_MAX_PORTS))\r\nreturn NULL;\r\nstm32_ports[id].hw_flow_control = of_property_read_bool(np,\r\n"auto-flow-control");\r\nstm32_ports[id].port.line = id;\r\nreturn &stm32_ports[id];\r\n}\r\nstatic int stm32_serial_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct stm32_port *stm32port;\r\nstm32port = stm32_of_get_stm32_port(pdev);\r\nif (!stm32port)\r\nreturn -ENODEV;\r\nret = stm32_init_port(stm32port, pdev);\r\nif (ret)\r\nreturn ret;\r\nret = uart_add_one_port(&stm32_usart_driver, &stm32port->port);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, &stm32port->port);\r\nreturn 0;\r\n}\r\nstatic int stm32_serial_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nreturn uart_remove_one_port(&stm32_usart_driver, port);\r\n}\r\nstatic void stm32_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (!(readl_relaxed(port->membase + USART_SR) & USART_SR_TXE))\r\ncpu_relax();\r\nwritel_relaxed(ch, port->membase + USART_DR);\r\n}\r\nstatic void stm32_console_write(struct console *co, const char *s, unsigned cnt)\r\n{\r\nstruct uart_port *port = &stm32_ports[co->index].port;\r\nunsigned long flags;\r\nu32 old_cr1, new_cr1;\r\nint locked = 1;\r\nlocal_irq_save(flags);\r\nif (port->sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock(&port->lock);\r\nelse\r\nspin_lock(&port->lock);\r\nold_cr1 = readl_relaxed(port->membase + USART_CR1);\r\nnew_cr1 = old_cr1 & ~USART_CR1_IE_MASK;\r\nwritel_relaxed(new_cr1, port->membase + USART_CR1);\r\nuart_console_write(port, s, cnt, stm32_console_putchar);\r\nwritel_relaxed(old_cr1, port->membase + USART_CR1);\r\nif (locked)\r\nspin_unlock(&port->lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int stm32_console_setup(struct console *co, char *options)\r\n{\r\nstruct stm32_port *stm32port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index >= STM32_MAX_PORTS)\r\nreturn -ENODEV;\r\nstm32port = &stm32_ports[co->index];\r\nif (stm32port->port.mapbase == 0 || stm32port->port.membase == NULL)\r\nreturn -ENXIO;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&stm32port->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init usart_init(void)\r\n{\r\nstatic char banner[] __initdata = "STM32 USART driver initialized";\r\nint ret;\r\npr_info("%s\n", banner);\r\nret = uart_register_driver(&stm32_usart_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&stm32_serial_driver);\r\nif (ret)\r\nuart_unregister_driver(&stm32_usart_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit usart_exit(void)\r\n{\r\nplatform_driver_unregister(&stm32_serial_driver);\r\nuart_unregister_driver(&stm32_usart_driver);\r\n}
