static void issue_park_cmd(ide_drive_t *drive, unsigned long timeout)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct request_queue *q = drive->queue;\r\nstruct request *rq;\r\nint rc;\r\ntimeout += jiffies;\r\nspin_lock_irq(&hwif->lock);\r\nif (drive->dev_flags & IDE_DFLAG_PARKED) {\r\nint reset_timer = time_before(timeout, drive->sleep);\r\nint start_queue = 0;\r\ndrive->sleep = timeout;\r\nwake_up_all(&ide_park_wq);\r\nif (reset_timer && del_timer(&hwif->timer))\r\nstart_queue = 1;\r\nspin_unlock_irq(&hwif->lock);\r\nif (start_queue)\r\nblk_run_queue(q);\r\nreturn;\r\n}\r\nspin_unlock_irq(&hwif->lock);\r\nrq = blk_get_request(q, READ, __GFP_RECLAIM);\r\nrq->cmd[0] = REQ_PARK_HEADS;\r\nrq->cmd_len = 1;\r\nrq->cmd_type = REQ_TYPE_DRV_PRIV;\r\nrq->special = &timeout;\r\nrc = blk_execute_rq(q, NULL, rq, 1);\r\nblk_put_request(rq);\r\nif (rc)\r\ngoto out;\r\nrq = blk_get_request(q, READ, GFP_NOWAIT);\r\nif (IS_ERR(rq))\r\ngoto out;\r\nrq->cmd[0] = REQ_UNPARK_HEADS;\r\nrq->cmd_len = 1;\r\nrq->cmd_type = REQ_TYPE_DRV_PRIV;\r\nelv_add_request(q, rq, ELEVATOR_INSERT_FRONT);\r\nout:\r\nreturn;\r\n}\r\nide_startstop_t ide_do_park_unpark(ide_drive_t *drive, struct request *rq)\r\n{\r\nstruct ide_cmd cmd;\r\nstruct ide_taskfile *tf = &cmd.tf;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nif (rq->cmd[0] == REQ_PARK_HEADS) {\r\ndrive->sleep = *(unsigned long *)rq->special;\r\ndrive->dev_flags |= IDE_DFLAG_SLEEPING;\r\ntf->command = ATA_CMD_IDLEIMMEDIATE;\r\ntf->feature = 0x44;\r\ntf->lbal = 0x4c;\r\ntf->lbam = 0x4e;\r\ntf->lbah = 0x55;\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\n} else\r\ntf->command = ATA_CMD_CHK_POWER;\r\ncmd.tf_flags |= IDE_TFLAG_CUSTOM_HANDLER;\r\ncmd.protocol = ATA_PROT_NODATA;\r\ncmd.rq = rq;\r\nreturn do_rw_taskfile(drive, &cmd);\r\n}\r\nssize_t ide_park_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nide_drive_t *drive = to_ide_device(dev);\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned long now;\r\nunsigned int msecs;\r\nif (drive->dev_flags & IDE_DFLAG_NO_UNLOAD)\r\nreturn -EOPNOTSUPP;\r\nspin_lock_irq(&hwif->lock);\r\nnow = jiffies;\r\nif (drive->dev_flags & IDE_DFLAG_PARKED &&\r\ntime_after(drive->sleep, now))\r\nmsecs = jiffies_to_msecs(drive->sleep - now);\r\nelse\r\nmsecs = 0;\r\nspin_unlock_irq(&hwif->lock);\r\nreturn snprintf(buf, 20, "%u\n", msecs);\r\n}\r\nssize_t ide_park_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\n#define MAX_PARK_TIMEOUT 30000\r\nide_drive_t *drive = to_ide_device(dev);\r\nlong int input;\r\nint rc;\r\nrc = kstrtol(buf, 10, &input);\r\nif (rc)\r\nreturn rc;\r\nif (input < -2)\r\nreturn -EINVAL;\r\nif (input > MAX_PARK_TIMEOUT) {\r\ninput = MAX_PARK_TIMEOUT;\r\nrc = -EOVERFLOW;\r\n}\r\nmutex_lock(&ide_setting_mtx);\r\nif (input >= 0) {\r\nif (drive->dev_flags & IDE_DFLAG_NO_UNLOAD)\r\nrc = -EOPNOTSUPP;\r\nelse if (input || drive->dev_flags & IDE_DFLAG_PARKED)\r\nissue_park_cmd(drive, msecs_to_jiffies(input));\r\n} else {\r\nif (drive->media == ide_disk)\r\nswitch (input) {\r\ncase -1:\r\ndrive->dev_flags &= ~IDE_DFLAG_NO_UNLOAD;\r\nbreak;\r\ncase -2:\r\ndrive->dev_flags |= IDE_DFLAG_NO_UNLOAD;\r\nbreak;\r\n}\r\nelse\r\nrc = -EOPNOTSUPP;\r\n}\r\nmutex_unlock(&ide_setting_mtx);\r\nreturn rc ? rc : len;\r\n}
