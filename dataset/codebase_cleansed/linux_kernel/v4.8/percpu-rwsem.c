int __percpu_init_rwsem(struct percpu_rw_semaphore *brw,\r\nconst char *name, struct lock_class_key *rwsem_key)\r\n{\r\nbrw->fast_read_ctr = alloc_percpu(int);\r\nif (unlikely(!brw->fast_read_ctr))\r\nreturn -ENOMEM;\r\n__init_rwsem(&brw->rw_sem, name, rwsem_key);\r\nrcu_sync_init(&brw->rss, RCU_SCHED_SYNC);\r\natomic_set(&brw->slow_read_ctr, 0);\r\ninit_waitqueue_head(&brw->write_waitq);\r\nreturn 0;\r\n}\r\nvoid percpu_free_rwsem(struct percpu_rw_semaphore *brw)\r\n{\r\nif (!brw->fast_read_ctr)\r\nreturn;\r\nrcu_sync_dtor(&brw->rss);\r\nfree_percpu(brw->fast_read_ctr);\r\nbrw->fast_read_ctr = NULL;\r\n}\r\nstatic bool update_fast_ctr(struct percpu_rw_semaphore *brw, unsigned int val)\r\n{\r\nbool success;\r\npreempt_disable();\r\nsuccess = rcu_sync_is_idle(&brw->rss);\r\nif (likely(success))\r\n__this_cpu_add(*brw->fast_read_ctr, val);\r\npreempt_enable();\r\nreturn success;\r\n}\r\nvoid percpu_down_read(struct percpu_rw_semaphore *brw)\r\n{\r\nmight_sleep();\r\nrwsem_acquire_read(&brw->rw_sem.dep_map, 0, 0, _RET_IP_);\r\nif (likely(update_fast_ctr(brw, +1)))\r\nreturn;\r\n__down_read(&brw->rw_sem);\r\natomic_inc(&brw->slow_read_ctr);\r\n__up_read(&brw->rw_sem);\r\n}\r\nint percpu_down_read_trylock(struct percpu_rw_semaphore *brw)\r\n{\r\nif (unlikely(!update_fast_ctr(brw, +1))) {\r\nif (!__down_read_trylock(&brw->rw_sem))\r\nreturn 0;\r\natomic_inc(&brw->slow_read_ctr);\r\n__up_read(&brw->rw_sem);\r\n}\r\nrwsem_acquire_read(&brw->rw_sem.dep_map, 0, 1, _RET_IP_);\r\nreturn 1;\r\n}\r\nvoid percpu_up_read(struct percpu_rw_semaphore *brw)\r\n{\r\nrwsem_release(&brw->rw_sem.dep_map, 1, _RET_IP_);\r\nif (likely(update_fast_ctr(brw, -1)))\r\nreturn;\r\nif (atomic_dec_and_test(&brw->slow_read_ctr))\r\nwake_up_all(&brw->write_waitq);\r\n}\r\nstatic int clear_fast_ctr(struct percpu_rw_semaphore *brw)\r\n{\r\nunsigned int sum = 0;\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\nsum += per_cpu(*brw->fast_read_ctr, cpu);\r\nper_cpu(*brw->fast_read_ctr, cpu) = 0;\r\n}\r\nreturn sum;\r\n}\r\nvoid percpu_down_write(struct percpu_rw_semaphore *brw)\r\n{\r\nrcu_sync_enter(&brw->rss);\r\ndown_write(&brw->rw_sem);\r\natomic_add(clear_fast_ctr(brw), &brw->slow_read_ctr);\r\nwait_event(brw->write_waitq, !atomic_read(&brw->slow_read_ctr));\r\n}\r\nvoid percpu_up_write(struct percpu_rw_semaphore *brw)\r\n{\r\nup_write(&brw->rw_sem);\r\nrcu_sync_exit(&brw->rss);\r\n}
