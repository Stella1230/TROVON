static struct mbox_chan *get_pcc_channel(int id)\r\n{\r\nif (id < 0 || id > pcc_mbox_ctrl.num_chans)\r\nreturn ERR_PTR(-ENOENT);\r\nreturn &pcc_mbox_channels[id];\r\n}\r\nstruct mbox_chan *pcc_mbox_request_channel(struct mbox_client *cl,\r\nint subspace_id)\r\n{\r\nstruct device *dev = pcc_mbox_ctrl.dev;\r\nstruct mbox_chan *chan;\r\nunsigned long flags;\r\nchan = get_pcc_channel(subspace_id);\r\nif (IS_ERR(chan) || chan->cl) {\r\ndev_err(dev, "Channel not found for idx: %d\n", subspace_id);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nspin_lock_irqsave(&chan->lock, flags);\r\nchan->msg_free = 0;\r\nchan->msg_count = 0;\r\nchan->active_req = NULL;\r\nchan->cl = cl;\r\ninit_completion(&chan->tx_complete);\r\nif (chan->txdone_method == TXDONE_BY_POLL && cl->knows_txdone)\r\nchan->txdone_method |= TXDONE_BY_ACK;\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\nreturn chan;\r\n}\r\nvoid pcc_mbox_free_channel(struct mbox_chan *chan)\r\n{\r\nunsigned long flags;\r\nif (!chan || !chan->cl)\r\nreturn;\r\nspin_lock_irqsave(&chan->lock, flags);\r\nchan->cl = NULL;\r\nchan->active_req = NULL;\r\nif (chan->txdone_method == (TXDONE_BY_POLL | TXDONE_BY_ACK))\r\nchan->txdone_method = TXDONE_BY_POLL;\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\n}\r\nstatic int read_register(void __iomem *vaddr, u64 *val, unsigned int bit_width)\r\n{\r\nint ret_val = 0;\r\nswitch (bit_width) {\r\ncase 8:\r\n*val = readb(vaddr);\r\nbreak;\r\ncase 16:\r\n*val = readw(vaddr);\r\nbreak;\r\ncase 32:\r\n*val = readl(vaddr);\r\nbreak;\r\ncase 64:\r\n*val = readq(vaddr);\r\nbreak;\r\ndefault:\r\npr_debug("Error: Cannot read register of %u bit width",\r\nbit_width);\r\nret_val = -EFAULT;\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int write_register(void __iomem *vaddr, u64 val, unsigned int bit_width)\r\n{\r\nint ret_val = 0;\r\nswitch (bit_width) {\r\ncase 8:\r\nwriteb(val, vaddr);\r\nbreak;\r\ncase 16:\r\nwritew(val, vaddr);\r\nbreak;\r\ncase 32:\r\nwritel(val, vaddr);\r\nbreak;\r\ncase 64:\r\nwriteq(val, vaddr);\r\nbreak;\r\ndefault:\r\npr_debug("Error: Cannot write register of %u bit width",\r\nbit_width);\r\nret_val = -EFAULT;\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int pcc_send_data(struct mbox_chan *chan, void *data)\r\n{\r\nstruct acpi_pcct_hw_reduced *pcct_ss = chan->con_priv;\r\nstruct acpi_generic_address *doorbell;\r\nu64 doorbell_preserve;\r\nu64 doorbell_val;\r\nu64 doorbell_write;\r\nu32 id = chan - pcc_mbox_channels;\r\nint ret = 0;\r\nif (id >= pcc_mbox_ctrl.num_chans) {\r\npr_debug("pcc_send_data: Invalid mbox_chan passed\n");\r\nreturn -ENOENT;\r\n}\r\ndoorbell = &pcct_ss->doorbell_register;\r\ndoorbell_preserve = pcct_ss->preserve_mask;\r\ndoorbell_write = pcct_ss->write_mask;\r\nif (pcc_doorbell_vaddr[id]) {\r\nret = read_register(pcc_doorbell_vaddr[id], &doorbell_val,\r\ndoorbell->bit_width);\r\nif (ret)\r\nreturn ret;\r\nret = write_register(pcc_doorbell_vaddr[id],\r\n(doorbell_val & doorbell_preserve) | doorbell_write,\r\ndoorbell->bit_width);\r\n} else {\r\nret = acpi_read(&doorbell_val, doorbell);\r\nif (ret)\r\nreturn ret;\r\nret = acpi_write((doorbell_val & doorbell_preserve) | doorbell_write,\r\ndoorbell);\r\n}\r\nreturn ret;\r\n}\r\nstatic int parse_pcc_subspace(struct acpi_subtable_header *header,\r\nconst unsigned long end)\r\n{\r\nstruct acpi_pcct_hw_reduced *pcct_ss;\r\nif (pcc_mbox_ctrl.num_chans <= MAX_PCC_SUBSPACES) {\r\npcct_ss = (struct acpi_pcct_hw_reduced *) header;\r\nif (pcct_ss->header.type !=\r\nACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE) {\r\npr_err("Incorrect PCC Subspace type detected\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init acpi_pcc_probe(void)\r\n{\r\nacpi_size pcct_tbl_header_size;\r\nstruct acpi_table_header *pcct_tbl;\r\nstruct acpi_subtable_header *pcct_entry;\r\nint count, i;\r\nacpi_status status = AE_OK;\r\nstatus = acpi_get_table_with_size(ACPI_SIG_PCCT, 0,\r\n&pcct_tbl,\r\n&pcct_tbl_header_size);\r\nif (ACPI_FAILURE(status) || !pcct_tbl) {\r\npr_warn("PCCT header not found.\n");\r\nreturn -ENODEV;\r\n}\r\ncount = acpi_table_parse_entries(ACPI_SIG_PCCT,\r\nsizeof(struct acpi_table_pcct),\r\nACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE,\r\nparse_pcc_subspace, MAX_PCC_SUBSPACES);\r\nif (count <= 0) {\r\npr_err("Error parsing PCC subspaces from PCCT\n");\r\nreturn -EINVAL;\r\n}\r\npcc_mbox_channels = kzalloc(sizeof(struct mbox_chan) *\r\ncount, GFP_KERNEL);\r\nif (!pcc_mbox_channels) {\r\npr_err("Could not allocate space for PCC mbox channels\n");\r\nreturn -ENOMEM;\r\n}\r\npcc_doorbell_vaddr = kcalloc(count, sizeof(void *), GFP_KERNEL);\r\nif (!pcc_doorbell_vaddr) {\r\nkfree(pcc_mbox_channels);\r\nreturn -ENOMEM;\r\n}\r\npcct_entry = (struct acpi_subtable_header *) (\r\n(unsigned long) pcct_tbl + sizeof(struct acpi_table_pcct));\r\nfor (i = 0; i < count; i++) {\r\nstruct acpi_generic_address *db_reg;\r\nstruct acpi_pcct_hw_reduced *pcct_ss;\r\npcc_mbox_channels[i].con_priv = pcct_entry;\r\npcct_ss = (struct acpi_pcct_hw_reduced *)pcct_entry;\r\ndb_reg = &pcct_ss->doorbell_register;\r\nif (db_reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)\r\npcc_doorbell_vaddr[i] = acpi_os_ioremap(db_reg->address,\r\ndb_reg->bit_width/8);\r\npcct_entry = (struct acpi_subtable_header *)\r\n((unsigned long) pcct_entry + pcct_entry->length);\r\n}\r\npcc_mbox_ctrl.num_chans = count;\r\npr_info("Detected %d PCC Subspaces\n", pcc_mbox_ctrl.num_chans);\r\nreturn 0;\r\n}\r\nstatic int pcc_mbox_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\npcc_mbox_ctrl.chans = pcc_mbox_channels;\r\npcc_mbox_ctrl.ops = &pcc_chan_ops;\r\npcc_mbox_ctrl.dev = &pdev->dev;\r\npr_info("Registering PCC driver as Mailbox controller\n");\r\nret = mbox_controller_register(&pcc_mbox_ctrl);\r\nif (ret) {\r\npr_err("Err registering PCC as Mailbox controller: %d\n", ret);\r\nret = -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init pcc_init(void)\r\n{\r\nint ret;\r\nstruct platform_device *pcc_pdev;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nret = acpi_pcc_probe();\r\nif (ret) {\r\npr_debug("ACPI PCC probe failed.\n");\r\nreturn -ENODEV;\r\n}\r\npcc_pdev = platform_create_bundle(&pcc_mbox_driver,\r\npcc_mbox_probe, NULL, 0, NULL, 0);\r\nif (IS_ERR(pcc_pdev)) {\r\npr_debug("Err creating PCC platform bundle\n");\r\nreturn PTR_ERR(pcc_pdev);\r\n}\r\nreturn 0;\r\n}
