static struct sunxi_pinctrl_group *\r\nsunxi_pinctrl_find_group_by_name(struct sunxi_pinctrl *pctl, const char *group)\r\n{\r\nint i;\r\nfor (i = 0; i < pctl->ngroups; i++) {\r\nstruct sunxi_pinctrl_group *grp = pctl->groups + i;\r\nif (!strcmp(grp->name, group))\r\nreturn grp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sunxi_pinctrl_function *\r\nsunxi_pinctrl_find_function_by_name(struct sunxi_pinctrl *pctl,\r\nconst char *name)\r\n{\r\nstruct sunxi_pinctrl_function *func = pctl->functions;\r\nint i;\r\nfor (i = 0; i < pctl->nfunctions; i++) {\r\nif (!func[i].name)\r\nbreak;\r\nif (!strcmp(func[i].name, name))\r\nreturn func + i;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sunxi_desc_function *\r\nsunxi_pinctrl_desc_find_function_by_name(struct sunxi_pinctrl *pctl,\r\nconst char *pin_name,\r\nconst char *func_name)\r\n{\r\nint i;\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nif (!strcmp(pin->pin.name, pin_name)) {\r\nstruct sunxi_desc_function *func = pin->functions;\r\nwhile (func->name) {\r\nif (!strcmp(func->name, func_name))\r\nreturn func;\r\nfunc++;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sunxi_desc_function *\r\nsunxi_pinctrl_desc_find_function_by_pin(struct sunxi_pinctrl *pctl,\r\nconst u16 pin_num,\r\nconst char *func_name)\r\n{\r\nint i;\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nif (pin->pin.number == pin_num) {\r\nstruct sunxi_desc_function *func = pin->functions;\r\nwhile (func->name) {\r\nif (!strcmp(func->name, func_name))\r\nreturn func;\r\nfunc++;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sunxi_pctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->ngroups;\r\n}\r\nstatic const char *sunxi_pctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->groups[group].name;\r\n}\r\nstatic int sunxi_pctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = (unsigned *)&pctl->groups[group].pin;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int sunxi_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *node,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned long *pinconfig;\r\nstruct property *prop;\r\nconst char *function;\r\nconst char *group;\r\nint ret, nmaps, i = 0;\r\nu32 val;\r\n*map = NULL;\r\n*num_maps = 0;\r\nret = of_property_read_string(node, "allwinner,function", &function);\r\nif (ret) {\r\ndev_err(pctl->dev,\r\n"missing allwinner,function property in node %s\n",\r\nnode->name);\r\nreturn -EINVAL;\r\n}\r\nnmaps = of_property_count_strings(node, "allwinner,pins") * 2;\r\nif (nmaps < 0) {\r\ndev_err(pctl->dev,\r\n"missing allwinner,pins property in node %s\n",\r\nnode->name);\r\nreturn -EINVAL;\r\n}\r\n*map = kmalloc(nmaps * sizeof(struct pinctrl_map), GFP_KERNEL);\r\nif (!*map)\r\nreturn -ENOMEM;\r\nof_property_for_each_string(node, "allwinner,pins", prop, group) {\r\nstruct sunxi_pinctrl_group *grp =\r\nsunxi_pinctrl_find_group_by_name(pctl, group);\r\nint j = 0, configlen = 0;\r\nif (!grp) {\r\ndev_err(pctl->dev, "unknown pin %s", group);\r\ncontinue;\r\n}\r\nif (!sunxi_pinctrl_desc_find_function_by_name(pctl,\r\ngrp->name,\r\nfunction)) {\r\ndev_err(pctl->dev, "unsupported function %s on pin %s",\r\nfunction, group);\r\ncontinue;\r\n}\r\n(*map)[i].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[i].data.mux.group = group;\r\n(*map)[i].data.mux.function = function;\r\ni++;\r\n(*map)[i].type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\n(*map)[i].data.configs.group_or_pin = group;\r\nif (of_find_property(node, "allwinner,drive", NULL))\r\nconfiglen++;\r\nif (of_find_property(node, "allwinner,pull", NULL))\r\nconfiglen++;\r\npinconfig = kzalloc(configlen * sizeof(*pinconfig), GFP_KERNEL);\r\nif (!pinconfig) {\r\nkfree(*map);\r\nreturn -ENOMEM;\r\n}\r\nif (!of_property_read_u32(node, "allwinner,drive", &val)) {\r\nu16 strength = (val + 1) * 10;\r\npinconfig[j++] =\r\npinconf_to_config_packed(PIN_CONFIG_DRIVE_STRENGTH,\r\nstrength);\r\n}\r\nif (!of_property_read_u32(node, "allwinner,pull", &val)) {\r\nenum pin_config_param pull = PIN_CONFIG_END;\r\nif (val == 1)\r\npull = PIN_CONFIG_BIAS_PULL_UP;\r\nelse if (val == 2)\r\npull = PIN_CONFIG_BIAS_PULL_DOWN;\r\npinconfig[j++] = pinconf_to_config_packed(pull, 0);\r\n}\r\n(*map)[i].data.configs.configs = pinconfig;\r\n(*map)[i].data.configs.num_configs = configlen;\r\ni++;\r\n}\r\n*num_maps = nmaps;\r\nreturn 0;\r\n}\r\nstatic void sunxi_pctrl_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map,\r\nunsigned num_maps)\r\n{\r\nint i;\r\nfor (i = 0; i < num_maps; i++) {\r\nif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)\r\nkfree(map[i].data.configs.configs);\r\n}\r\nkfree(map);\r\n}\r\nstatic int sunxi_pconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nunsigned long *config)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*config = pctl->groups[group].config;\r\nreturn 0;\r\n}\r\nstatic int sunxi_pconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sunxi_pinctrl_group *g = &pctl->groups[group];\r\nunsigned long flags;\r\nunsigned pin = g->pin - pctl->desc->pin_base;\r\nu32 val, mask;\r\nu16 strength;\r\nu8 dlevel;\r\nint i;\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nfor (i = 0; i < num_configs; i++) {\r\nswitch (pinconf_to_config_param(configs[i])) {\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nstrength = pinconf_to_config_argument(configs[i]);\r\nif (strength > 40) {\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\nreturn -EINVAL;\r\n}\r\ndlevel = strength / 10 - 1;\r\nval = readl(pctl->membase + sunxi_dlevel_reg(pin));\r\nmask = DLEVEL_PINS_MASK << sunxi_dlevel_offset(pin);\r\nwritel((val & ~mask)\r\n| dlevel << sunxi_dlevel_offset(pin),\r\npctl->membase + sunxi_dlevel_reg(pin));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nval = readl(pctl->membase + sunxi_pull_reg(pin));\r\nmask = PULL_PINS_MASK << sunxi_pull_offset(pin);\r\nwritel((val & ~mask) | 1 << sunxi_pull_offset(pin),\r\npctl->membase + sunxi_pull_reg(pin));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nval = readl(pctl->membase + sunxi_pull_reg(pin));\r\nmask = PULL_PINS_MASK << sunxi_pull_offset(pin);\r\nwritel((val & ~mask) | 2 << sunxi_pull_offset(pin),\r\npctl->membase + sunxi_pull_reg(pin));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ng->config = configs[i];\r\n}\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sunxi_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->nfunctions;\r\n}\r\nstatic const char *sunxi_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->functions[function].name;\r\n}\r\nstatic int sunxi_pmx_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pctl->functions[function].groups;\r\n*num_groups = pctl->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic void sunxi_pmx_set(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nu8 config)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned long flags;\r\nu32 val, mask;\r\nspin_lock_irqsave(&pctl->lock, flags);\r\npin -= pctl->desc->pin_base;\r\nval = readl(pctl->membase + sunxi_mux_reg(pin));\r\nmask = MUX_PINS_MASK << sunxi_mux_offset(pin);\r\nwritel((val & ~mask) | config << sunxi_mux_offset(pin),\r\npctl->membase + sunxi_mux_reg(pin));\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\n}\r\nstatic int sunxi_pmx_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nunsigned group)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sunxi_pinctrl_group *g = pctl->groups + group;\r\nstruct sunxi_pinctrl_function *func = pctl->functions + function;\r\nstruct sunxi_desc_function *desc =\r\nsunxi_pinctrl_desc_find_function_by_name(pctl,\r\ng->name,\r\nfunc->name);\r\nif (!desc)\r\nreturn -EINVAL;\r\nsunxi_pmx_set(pctldev, g->pin, desc->muxval);\r\nreturn 0;\r\n}\r\nstatic int\r\nsunxi_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset,\r\nbool input)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sunxi_desc_function *desc;\r\nconst char *func;\r\nif (input)\r\nfunc = "gpio_in";\r\nelse\r\nfunc = "gpio_out";\r\ndesc = sunxi_pinctrl_desc_find_function_by_pin(pctl, offset, func);\r\nif (!desc)\r\nreturn -EINVAL;\r\nsunxi_pmx_set(pctldev, offset, desc->muxval);\r\nreturn 0;\r\n}\r\nstatic int sunxi_pinctrl_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(chip->base + offset);\r\n}\r\nstatic int sunxi_pinctrl_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sunxi_pinctrl *pctl = gpiochip_get_data(chip);\r\nu32 reg = sunxi_data_reg(offset);\r\nu8 index = sunxi_data_offset(offset);\r\nbool set_mux = pctl->desc->irq_read_needs_mux &&\r\ngpiochip_line_is_irq(chip, offset);\r\nu32 pin = offset + chip->base;\r\nu32 val;\r\nif (set_mux)\r\nsunxi_pmx_set(pctl->pctl_dev, pin, SUN4I_FUNC_INPUT);\r\nval = (readl(pctl->membase + reg) >> index) & DATA_PINS_MASK;\r\nif (set_mux)\r\nsunxi_pmx_set(pctl->pctl_dev, pin, SUN4I_FUNC_IRQ);\r\nreturn !!val;\r\n}\r\nstatic void sunxi_pinctrl_gpio_set(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct sunxi_pinctrl *pctl = gpiochip_get_data(chip);\r\nu32 reg = sunxi_data_reg(offset);\r\nu8 index = sunxi_data_offset(offset);\r\nunsigned long flags;\r\nu32 regval;\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nregval = readl(pctl->membase + reg);\r\nif (value)\r\nregval |= BIT(index);\r\nelse\r\nregval &= ~(BIT(index));\r\nwritel(regval, pctl->membase + reg);\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\n}\r\nstatic int sunxi_pinctrl_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nsunxi_pinctrl_gpio_set(chip, offset, value);\r\nreturn pinctrl_gpio_direction_output(chip->base + offset);\r\n}\r\nstatic int sunxi_pinctrl_gpio_of_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec,\r\nu32 *flags)\r\n{\r\nint pin, base;\r\nbase = PINS_PER_BANK * gpiospec->args[0];\r\npin = base + gpiospec->args[1];\r\nif (pin > gc->ngpio)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpiospec->args[2];\r\nreturn pin;\r\n}\r\nstatic int sunxi_pinctrl_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sunxi_pinctrl *pctl = gpiochip_get_data(chip);\r\nstruct sunxi_desc_function *desc;\r\nunsigned pinnum = pctl->desc->pin_base + offset;\r\nunsigned irqnum;\r\nif (offset >= chip->ngpio)\r\nreturn -ENXIO;\r\ndesc = sunxi_pinctrl_desc_find_function_by_pin(pctl, pinnum, "irq");\r\nif (!desc)\r\nreturn -EINVAL;\r\nirqnum = desc->irqbank * IRQ_PER_BANK + desc->irqnum;\r\ndev_dbg(chip->parent, "%s: request IRQ for GPIO %d, return %d\n",\r\nchip->label, offset + chip->base, irqnum);\r\nreturn irq_find_mapping(pctl->domain, irqnum);\r\n}\r\nstatic int sunxi_pinctrl_irq_request_resources(struct irq_data *d)\r\n{\r\nstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nstruct sunxi_desc_function *func;\r\nint ret;\r\nfunc = sunxi_pinctrl_desc_find_function_by_pin(pctl,\r\npctl->irq_array[d->hwirq], "irq");\r\nif (!func)\r\nreturn -EINVAL;\r\nret = gpiochip_lock_as_irq(pctl->chip,\r\npctl->irq_array[d->hwirq] - pctl->desc->pin_base);\r\nif (ret) {\r\ndev_err(pctl->dev, "unable to lock HW IRQ %lu for IRQ\n",\r\nirqd_to_hwirq(d));\r\nreturn ret;\r\n}\r\nsunxi_pmx_set(pctl->pctl_dev, pctl->irq_array[d->hwirq], func->muxval);\r\nreturn 0;\r\n}\r\nstatic void sunxi_pinctrl_irq_release_resources(struct irq_data *d)\r\n{\r\nstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\ngpiochip_unlock_as_irq(pctl->chip,\r\npctl->irq_array[d->hwirq] - pctl->desc->pin_base);\r\n}\r\nstatic int sunxi_pinctrl_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nu32 reg = sunxi_irq_cfg_reg(d->hwirq, pctl->desc->irq_bank_base);\r\nu8 index = sunxi_irq_cfg_offset(d->hwirq);\r\nunsigned long flags;\r\nu32 regval;\r\nu8 mode;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nmode = IRQ_EDGE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nmode = IRQ_EDGE_FALLING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nmode = IRQ_EDGE_BOTH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nmode = IRQ_LEVEL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nmode = IRQ_LEVEL_LOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nif (type & IRQ_TYPE_LEVEL_MASK)\r\nirq_set_chip_handler_name_locked(d, &sunxi_pinctrl_level_irq_chip,\r\nhandle_fasteoi_irq, NULL);\r\nelse\r\nirq_set_chip_handler_name_locked(d, &sunxi_pinctrl_edge_irq_chip,\r\nhandle_edge_irq, NULL);\r\nregval = readl(pctl->membase + reg);\r\nregval &= ~(IRQ_CFG_IRQ_MASK << index);\r\nwritel(regval | (mode << index), pctl->membase + reg);\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sunxi_pinctrl_irq_ack(struct irq_data *d)\r\n{\r\nstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nu32 status_reg = sunxi_irq_status_reg(d->hwirq,\r\npctl->desc->irq_bank_base);\r\nu8 status_idx = sunxi_irq_status_offset(d->hwirq);\r\nwritel(1 << status_idx, pctl->membase + status_reg);\r\n}\r\nstatic void sunxi_pinctrl_irq_mask(struct irq_data *d)\r\n{\r\nstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nu32 reg = sunxi_irq_ctrl_reg(d->hwirq, pctl->desc->irq_bank_base);\r\nu8 idx = sunxi_irq_ctrl_offset(d->hwirq);\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nval = readl(pctl->membase + reg);\r\nwritel(val & ~(1 << idx), pctl->membase + reg);\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\n}\r\nstatic void sunxi_pinctrl_irq_unmask(struct irq_data *d)\r\n{\r\nstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nu32 reg = sunxi_irq_ctrl_reg(d->hwirq, pctl->desc->irq_bank_base);\r\nu8 idx = sunxi_irq_ctrl_offset(d->hwirq);\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nval = readl(pctl->membase + reg);\r\nwritel(val | (1 << idx), pctl->membase + reg);\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\n}\r\nstatic void sunxi_pinctrl_irq_ack_unmask(struct irq_data *d)\r\n{\r\nsunxi_pinctrl_irq_ack(d);\r\nsunxi_pinctrl_irq_unmask(d);\r\n}\r\nstatic int sunxi_pinctrl_irq_of_xlate(struct irq_domain *d,\r\nstruct device_node *node,\r\nconst u32 *intspec,\r\nunsigned int intsize,\r\nunsigned long *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\nstruct sunxi_pinctrl *pctl = d->host_data;\r\nstruct sunxi_desc_function *desc;\r\nint pin, base;\r\nif (intsize < 3)\r\nreturn -EINVAL;\r\nbase = PINS_PER_BANK * intspec[0];\r\npin = pctl->desc->pin_base + base + intspec[1];\r\ndesc = sunxi_pinctrl_desc_find_function_by_pin(pctl, pin, "irq");\r\nif (!desc)\r\nreturn -EINVAL;\r\n*out_hwirq = desc->irqbank * PINS_PER_BANK + desc->irqnum;\r\n*out_type = intspec[2];\r\nreturn 0;\r\n}\r\nstatic void sunxi_pinctrl_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned int irq = irq_desc_get_irq(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct sunxi_pinctrl *pctl = irq_desc_get_handler_data(desc);\r\nunsigned long bank, reg, val;\r\nfor (bank = 0; bank < pctl->desc->irq_banks; bank++)\r\nif (irq == pctl->irq[bank])\r\nbreak;\r\nif (bank == pctl->desc->irq_banks)\r\nreturn;\r\nreg = sunxi_irq_status_reg_from_bank(bank, pctl->desc->irq_bank_base);\r\nval = readl(pctl->membase + reg);\r\nif (val) {\r\nint irqoffset;\r\nchained_irq_enter(chip, desc);\r\nfor_each_set_bit(irqoffset, &val, IRQ_PER_BANK) {\r\nint pin_irq = irq_find_mapping(pctl->domain,\r\nbank * IRQ_PER_BANK + irqoffset);\r\ngeneric_handle_irq(pin_irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\n}\r\nstatic int sunxi_pinctrl_add_function(struct sunxi_pinctrl *pctl,\r\nconst char *name)\r\n{\r\nstruct sunxi_pinctrl_function *func = pctl->functions;\r\nwhile (func->name) {\r\nif (strcmp(func->name, name) == 0) {\r\nfunc->ngroups++;\r\nreturn -EEXIST;\r\n}\r\nfunc++;\r\n}\r\nfunc->name = name;\r\nfunc->ngroups = 1;\r\npctl->nfunctions++;\r\nreturn 0;\r\n}\r\nstatic int sunxi_pinctrl_build_state(struct platform_device *pdev)\r\n{\r\nstruct sunxi_pinctrl *pctl = platform_get_drvdata(pdev);\r\nint i;\r\npctl->ngroups = pctl->desc->npins;\r\npctl->groups = devm_kzalloc(&pdev->dev,\r\npctl->ngroups * sizeof(*pctl->groups),\r\nGFP_KERNEL);\r\nif (!pctl->groups)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nstruct sunxi_pinctrl_group *group = pctl->groups + i;\r\ngroup->name = pin->pin.name;\r\ngroup->pin = pin->pin.number;\r\n}\r\npctl->functions = devm_kzalloc(&pdev->dev,\r\npctl->desc->npins * sizeof(*pctl->functions),\r\nGFP_KERNEL);\r\nif (!pctl->functions)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nstruct sunxi_desc_function *func = pin->functions;\r\nwhile (func->name) {\r\nif (!strcmp(func->name, "irq")) {\r\nint irqnum = func->irqnum + func->irqbank * IRQ_PER_BANK;\r\npctl->irq_array[irqnum] = pin->pin.number;\r\n}\r\nsunxi_pinctrl_add_function(pctl, func->name);\r\nfunc++;\r\n}\r\n}\r\npctl->functions = krealloc(pctl->functions,\r\npctl->nfunctions * sizeof(*pctl->functions),\r\nGFP_KERNEL);\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nstruct sunxi_desc_function *func = pin->functions;\r\nwhile (func->name) {\r\nstruct sunxi_pinctrl_function *func_item;\r\nconst char **func_grp;\r\nfunc_item = sunxi_pinctrl_find_function_by_name(pctl,\r\nfunc->name);\r\nif (!func_item)\r\nreturn -EINVAL;\r\nif (!func_item->groups) {\r\nfunc_item->groups =\r\ndevm_kzalloc(&pdev->dev,\r\nfunc_item->ngroups * sizeof(*func_item->groups),\r\nGFP_KERNEL);\r\nif (!func_item->groups)\r\nreturn -ENOMEM;\r\n}\r\nfunc_grp = func_item->groups;\r\nwhile (*func_grp)\r\nfunc_grp++;\r\n*func_grp = pin->pin.name;\r\nfunc++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint sunxi_pinctrl_init(struct platform_device *pdev,\r\nconst struct sunxi_pinctrl_desc *desc)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct pinctrl_desc *pctrl_desc;\r\nstruct pinctrl_pin_desc *pins;\r\nstruct sunxi_pinctrl *pctl;\r\nstruct resource *res;\r\nint i, ret, last_pin;\r\nstruct clk *clk;\r\npctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\r\nif (!pctl)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, pctl);\r\nspin_lock_init(&pctl->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npctl->membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pctl->membase))\r\nreturn PTR_ERR(pctl->membase);\r\npctl->dev = &pdev->dev;\r\npctl->desc = desc;\r\npctl->irq_array = devm_kcalloc(&pdev->dev,\r\nIRQ_PER_BANK * pctl->desc->irq_banks,\r\nsizeof(*pctl->irq_array),\r\nGFP_KERNEL);\r\nif (!pctl->irq_array)\r\nreturn -ENOMEM;\r\nret = sunxi_pinctrl_build_state(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "dt probe failed: %d\n", ret);\r\nreturn ret;\r\n}\r\npins = devm_kzalloc(&pdev->dev,\r\npctl->desc->npins * sizeof(*pins),\r\nGFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctl->desc->npins; i++)\r\npins[i] = pctl->desc->pins[i].pin;\r\npctrl_desc = devm_kzalloc(&pdev->dev,\r\nsizeof(*pctrl_desc),\r\nGFP_KERNEL);\r\nif (!pctrl_desc)\r\nreturn -ENOMEM;\r\npctrl_desc->name = dev_name(&pdev->dev);\r\npctrl_desc->owner = THIS_MODULE;\r\npctrl_desc->pins = pins;\r\npctrl_desc->npins = pctl->desc->npins;\r\npctrl_desc->confops = &sunxi_pconf_ops;\r\npctrl_desc->pctlops = &sunxi_pctrl_ops;\r\npctrl_desc->pmxops = &sunxi_pmx_ops;\r\npctl->pctl_dev = devm_pinctrl_register(&pdev->dev, pctrl_desc, pctl);\r\nif (IS_ERR(pctl->pctl_dev)) {\r\ndev_err(&pdev->dev, "couldn't register pinctrl driver\n");\r\nreturn PTR_ERR(pctl->pctl_dev);\r\n}\r\npctl->chip = devm_kzalloc(&pdev->dev, sizeof(*pctl->chip), GFP_KERNEL);\r\nif (!pctl->chip)\r\nreturn -ENOMEM;\r\nlast_pin = pctl->desc->pins[pctl->desc->npins - 1].pin.number;\r\npctl->chip->owner = THIS_MODULE;\r\npctl->chip->request = gpiochip_generic_request,\r\npctl->chip->free = gpiochip_generic_free,\r\npctl->chip->direction_input = sunxi_pinctrl_gpio_direction_input,\r\npctl->chip->direction_output = sunxi_pinctrl_gpio_direction_output,\r\npctl->chip->get = sunxi_pinctrl_gpio_get,\r\npctl->chip->set = sunxi_pinctrl_gpio_set,\r\npctl->chip->of_xlate = sunxi_pinctrl_gpio_of_xlate,\r\npctl->chip->to_irq = sunxi_pinctrl_gpio_to_irq,\r\npctl->chip->of_gpio_n_cells = 3,\r\npctl->chip->can_sleep = false,\r\npctl->chip->ngpio = round_up(last_pin, PINS_PER_BANK) -\r\npctl->desc->pin_base;\r\npctl->chip->label = dev_name(&pdev->dev);\r\npctl->chip->parent = &pdev->dev;\r\npctl->chip->base = pctl->desc->pin_base;\r\nret = gpiochip_add_data(pctl->chip, pctl);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nret = gpiochip_add_pin_range(pctl->chip, dev_name(&pdev->dev),\r\npin->pin.number - pctl->desc->pin_base,\r\npin->pin.number, 1);\r\nif (ret)\r\ngoto gpiochip_error;\r\n}\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ngoto gpiochip_error;\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\ngoto gpiochip_error;\r\npctl->irq = devm_kcalloc(&pdev->dev,\r\npctl->desc->irq_banks,\r\nsizeof(*pctl->irq),\r\nGFP_KERNEL);\r\nif (!pctl->irq) {\r\nret = -ENOMEM;\r\ngoto clk_error;\r\n}\r\nfor (i = 0; i < pctl->desc->irq_banks; i++) {\r\npctl->irq[i] = platform_get_irq(pdev, i);\r\nif (pctl->irq[i] < 0) {\r\nret = pctl->irq[i];\r\ngoto clk_error;\r\n}\r\n}\r\npctl->domain = irq_domain_add_linear(node,\r\npctl->desc->irq_banks * IRQ_PER_BANK,\r\n&sunxi_pinctrl_irq_domain_ops,\r\npctl);\r\nif (!pctl->domain) {\r\ndev_err(&pdev->dev, "Couldn't register IRQ domain\n");\r\nret = -ENOMEM;\r\ngoto clk_error;\r\n}\r\nfor (i = 0; i < (pctl->desc->irq_banks * IRQ_PER_BANK); i++) {\r\nint irqno = irq_create_mapping(pctl->domain, i);\r\nirq_set_chip_and_handler(irqno, &sunxi_pinctrl_edge_irq_chip,\r\nhandle_edge_irq);\r\nirq_set_chip_data(irqno, pctl);\r\n}\r\nfor (i = 0; i < pctl->desc->irq_banks; i++) {\r\nwritel(0, pctl->membase + sunxi_irq_ctrl_reg_from_bank(i,\r\npctl->desc->irq_bank_base));\r\nwritel(0xffffffff,\r\npctl->membase + sunxi_irq_status_reg_from_bank(i,\r\npctl->desc->irq_bank_base));\r\nirq_set_chained_handler_and_data(pctl->irq[i],\r\nsunxi_pinctrl_irq_handler,\r\npctl);\r\n}\r\ndev_info(&pdev->dev, "initialized sunXi PIO driver\n");\r\nreturn 0;\r\nclk_error:\r\nclk_disable_unprepare(clk);\r\ngpiochip_error:\r\ngpiochip_remove(pctl->chip);\r\nreturn ret;\r\n}
