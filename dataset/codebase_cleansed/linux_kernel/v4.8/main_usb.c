static void vnt_set_options(struct vnt_private *priv)\r\n{\r\nif (vnt_tx_buffers < CB_MIN_TX_DESC || vnt_tx_buffers > CB_MAX_TX_DESC)\r\npriv->num_tx_context = TX_DESC_DEF0;\r\nelse\r\npriv->num_tx_context = vnt_tx_buffers;\r\nif (vnt_rx_buffers < CB_MIN_RX_DESC || vnt_rx_buffers > CB_MAX_RX_DESC)\r\npriv->num_rcb = RX_DESC_DEF0;\r\nelse\r\npriv->num_rcb = vnt_rx_buffers;\r\npriv->short_retry_limit = SHORT_RETRY_DEF;\r\npriv->long_retry_limit = LONG_RETRY_DEF;\r\npriv->op_mode = NL80211_IFTYPE_UNSPECIFIED;\r\npriv->bb_type = BBP_TYPE_DEF;\r\npriv->packet_type = priv->bb_type;\r\npriv->auto_fb_ctrl = AUTO_FB_0;\r\npriv->preamble_type = 0;\r\npriv->exist_sw_net_addr = false;\r\n}\r\nstatic int vnt_init_registers(struct vnt_private *priv)\r\n{\r\nstruct vnt_cmd_card_init *init_cmd = &priv->init_command;\r\nstruct vnt_rsp_card_init *init_rsp = &priv->init_response;\r\nu8 antenna;\r\nint ii;\r\nint status = STATUS_SUCCESS;\r\nu8 tmp;\r\nu8 calib_tx_iq = 0, calib_tx_dc = 0, calib_rx_iq = 0;\r\ndev_dbg(&priv->usb->dev, "---->INIbInitAdapter. [%d][%d]\n",\r\nDEVICE_INIT_COLD, priv->packet_type);\r\nif (!vnt_check_firmware_version(priv)) {\r\nif (vnt_download_firmware(priv) == true) {\r\nif (vnt_firmware_branch_to_sram(priv) == false) {\r\ndev_dbg(&priv->usb->dev,\r\n" vnt_firmware_branch_to_sram fail\n");\r\nreturn false;\r\n}\r\n} else {\r\ndev_dbg(&priv->usb->dev, "FIRMWAREbDownload fail\n");\r\nreturn false;\r\n}\r\n}\r\nif (!vnt_vt3184_init(priv)) {\r\ndev_dbg(&priv->usb->dev, "vnt_vt3184_init fail\n");\r\nreturn false;\r\n}\r\ninit_cmd->init_class = DEVICE_INIT_COLD;\r\ninit_cmd->exist_sw_net_addr = priv->exist_sw_net_addr;\r\nfor (ii = 0; ii < 6; ii++)\r\ninit_cmd->sw_net_addr[ii] = priv->current_net_addr[ii];\r\ninit_cmd->short_retry_limit = priv->short_retry_limit;\r\ninit_cmd->long_retry_limit = priv->long_retry_limit;\r\nstatus = vnt_control_out(priv,\r\nMESSAGE_TYPE_CARDINIT, 0, 0,\r\nsizeof(struct vnt_cmd_card_init), (u8 *)init_cmd);\r\nif (status != STATUS_SUCCESS) {\r\ndev_dbg(&priv->usb->dev, "Issue Card init fail\n");\r\nreturn false;\r\n}\r\nstatus = vnt_control_in(priv, MESSAGE_TYPE_INIT_RSP, 0, 0,\r\nsizeof(struct vnt_rsp_card_init), (u8 *)init_rsp);\r\nif (status != STATUS_SUCCESS) {\r\ndev_dbg(&priv->usb->dev,\r\n"Cardinit request in status fail!\n");\r\nreturn false;\r\n}\r\nstatus = vnt_control_in(priv, MESSAGE_TYPE_READ,\r\nMAC_REG_LOCALID, MESSAGE_REQUEST_MACREG, 1,\r\n&priv->local_id);\r\nif (status != STATUS_SUCCESS)\r\nreturn false;\r\npriv->top_ofdm_basic_rate = RATE_24M;\r\npriv->top_cck_basic_rate = RATE_1M;\r\npriv->power = 0xFF;\r\npriv->cck_pwr = priv->eeprom[EEP_OFS_PWR_CCK];\r\npriv->ofdm_pwr_g = priv->eeprom[EEP_OFS_PWR_OFDMG];\r\nfor (ii = 0; ii < 14; ii++) {\r\npriv->cck_pwr_tbl[ii] =\r\npriv->eeprom[ii + EEP_OFS_CCK_PWR_TBL];\r\nif (priv->cck_pwr_tbl[ii] == 0)\r\npriv->cck_pwr_tbl[ii] = priv->cck_pwr;\r\npriv->ofdm_pwr_tbl[ii] =\r\npriv->eeprom[ii + EEP_OFS_OFDM_PWR_TBL];\r\nif (priv->ofdm_pwr_tbl[ii] == 0)\r\npriv->ofdm_pwr_tbl[ii] = priv->ofdm_pwr_g;\r\n}\r\nfor (ii = 11; ii < 14; ii++) {\r\npriv->cck_pwr_tbl[ii] = priv->cck_pwr_tbl[10];\r\npriv->ofdm_pwr_tbl[ii] = priv->ofdm_pwr_tbl[10];\r\n}\r\npriv->ofdm_pwr_a = 0x34;\r\nfor (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) {\r\npriv->ofdm_a_pwr_tbl[ii] =\r\npriv->eeprom[ii + EEP_OFS_OFDMA_PWR_TBL];\r\nif (priv->ofdm_a_pwr_tbl[ii] == 0)\r\npriv->ofdm_a_pwr_tbl[ii] = priv->ofdm_pwr_a;\r\n}\r\nantenna = priv->eeprom[EEP_OFS_ANTENNA];\r\nif (antenna & EEP_ANTINV)\r\npriv->tx_rx_ant_inv = true;\r\nelse\r\npriv->tx_rx_ant_inv = false;\r\nantenna &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\r\nif (antenna == 0)\r\nantenna = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\r\nif (antenna == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {\r\npriv->tx_antenna_mode = ANT_B;\r\npriv->rx_antenna_sel = 1;\r\nif (priv->tx_rx_ant_inv)\r\npriv->rx_antenna_mode = ANT_A;\r\nelse\r\npriv->rx_antenna_mode = ANT_B;\r\n} else {\r\npriv->rx_antenna_sel = 0;\r\nif (antenna & EEP_ANTENNA_AUX) {\r\npriv->tx_antenna_mode = ANT_A;\r\nif (priv->tx_rx_ant_inv)\r\npriv->rx_antenna_mode = ANT_B;\r\nelse\r\npriv->rx_antenna_mode = ANT_A;\r\n} else {\r\npriv->tx_antenna_mode = ANT_B;\r\nif (priv->tx_rx_ant_inv)\r\npriv->rx_antenna_mode = ANT_A;\r\nelse\r\npriv->rx_antenna_mode = ANT_B;\r\n}\r\n}\r\nvnt_set_antenna_mode(priv, priv->rx_antenna_mode);\r\npriv->auto_fb_ctrl = AUTO_FB_0;\r\npriv->bb_type = BB_TYPE_11G;\r\npriv->rf_type = init_rsp->rf_type;\r\nif (priv->rf_type == RF_VT3226D0) {\r\nif ((priv->eeprom[EEP_OFS_MAJOR_VER] == 0x1) &&\r\n(priv->eeprom[EEP_OFS_MINOR_VER] >= 0x4)) {\r\ncalib_tx_iq = priv->eeprom[EEP_OFS_CALIB_TX_IQ];\r\ncalib_tx_dc = priv->eeprom[EEP_OFS_CALIB_TX_DC];\r\ncalib_rx_iq = priv->eeprom[EEP_OFS_CALIB_RX_IQ];\r\nif (calib_tx_iq || calib_tx_dc || calib_rx_iq) {\r\nvnt_control_out_u8(priv,\r\nMESSAGE_REQUEST_BBREG,\r\n0xff,\r\n0x03);\r\nvnt_control_out_u8(priv,\r\nMESSAGE_REQUEST_BBREG,\r\n0xfb,\r\ncalib_tx_iq);\r\nvnt_control_out_u8(priv,\r\nMESSAGE_REQUEST_BBREG,\r\n0xfC,\r\ncalib_tx_dc);\r\nvnt_control_out_u8(priv,\r\nMESSAGE_REQUEST_BBREG,\r\n0xfd,\r\ncalib_rx_iq);\r\n} else {\r\nvnt_control_out_u8(priv,\r\nMESSAGE_REQUEST_BBREG,\r\n0xff,\r\n0x0);\r\n}\r\n}\r\n}\r\nmemcpy(priv->permanent_net_addr, init_rsp->net_addr, 6);\r\nether_addr_copy(priv->current_net_addr, priv->permanent_net_addr);\r\ndev_dbg(&priv->usb->dev, "Network address = %pM\n",\r\npriv->current_net_addr);\r\nif (priv->bb_type == BB_TYPE_11A)\r\npriv->short_slot_time = true;\r\nelse\r\npriv->short_slot_time = false;\r\nvnt_set_short_slot_time(priv);\r\npriv->radio_ctl = priv->eeprom[EEP_OFS_RADIOCTL];\r\nif ((priv->radio_ctl & EEP_RADIOCTL_ENABLE) != 0) {\r\nstatus = vnt_control_in(priv, MESSAGE_TYPE_READ,\r\nMAC_REG_GPIOCTL1, MESSAGE_REQUEST_MACREG, 1, &tmp);\r\nif (status != STATUS_SUCCESS)\r\nreturn false;\r\nif ((tmp & GPIO3_DATA) == 0)\r\nvnt_mac_reg_bits_on(priv, MAC_REG_GPIOCTL1,\r\nGPIO3_INTMD);\r\nelse\r\nvnt_mac_reg_bits_off(priv, MAC_REG_GPIOCTL1,\r\nGPIO3_INTMD);\r\n}\r\nvnt_mac_set_led(priv, LEDSTS_TMLEN, 0x38);\r\nvnt_mac_set_led(priv, LEDSTS_STS, LEDSTS_SLOW);\r\nvnt_mac_reg_bits_on(priv, MAC_REG_GPIOCTL0, 0x01);\r\nvnt_radio_power_on(priv);\r\ndev_dbg(&priv->usb->dev, "<----INIbInitAdapter Exit\n");\r\nreturn true;\r\n}\r\nstatic void vnt_free_tx_bufs(struct vnt_private *priv)\r\n{\r\nstruct vnt_usb_send_context *tx_context;\r\nint ii;\r\nfor (ii = 0; ii < priv->num_tx_context; ii++) {\r\ntx_context = priv->tx_context[ii];\r\nif (tx_context->urb) {\r\nusb_kill_urb(tx_context->urb);\r\nusb_free_urb(tx_context->urb);\r\n}\r\nkfree(tx_context);\r\n}\r\n}\r\nstatic void vnt_free_rx_bufs(struct vnt_private *priv)\r\n{\r\nstruct vnt_rcb *rcb;\r\nint ii;\r\nfor (ii = 0; ii < priv->num_rcb; ii++) {\r\nrcb = priv->rcb[ii];\r\nif (!rcb)\r\ncontinue;\r\nif (rcb->urb) {\r\nusb_kill_urb(rcb->urb);\r\nusb_free_urb(rcb->urb);\r\n}\r\nif (rcb->skb)\r\ndev_kfree_skb(rcb->skb);\r\nkfree(rcb);\r\n}\r\n}\r\nstatic void usb_device_reset(struct vnt_private *priv)\r\n{\r\nint status;\r\nstatus = usb_reset_device(priv->usb);\r\nif (status)\r\ndev_warn(&priv->usb->dev,\r\n"usb_device_reset fail status=%d\n", status);\r\n}\r\nstatic void vnt_free_int_bufs(struct vnt_private *priv)\r\n{\r\nkfree(priv->int_buf.data_buf);\r\n}\r\nstatic bool vnt_alloc_bufs(struct vnt_private *priv)\r\n{\r\nstruct vnt_usb_send_context *tx_context;\r\nstruct vnt_rcb *rcb;\r\nint ii;\r\nfor (ii = 0; ii < priv->num_tx_context; ii++) {\r\ntx_context = kmalloc(sizeof(struct vnt_usb_send_context),\r\nGFP_KERNEL);\r\nif (!tx_context)\r\ngoto free_tx;\r\npriv->tx_context[ii] = tx_context;\r\ntx_context->priv = priv;\r\ntx_context->pkt_no = ii;\r\ntx_context->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!tx_context->urb) {\r\ndev_err(&priv->usb->dev, "alloc tx urb failed\n");\r\ngoto free_tx;\r\n}\r\ntx_context->in_use = false;\r\n}\r\nfor (ii = 0; ii < priv->num_rcb; ii++) {\r\npriv->rcb[ii] = kzalloc(sizeof(struct vnt_rcb), GFP_KERNEL);\r\nif (!priv->rcb[ii]) {\r\ndev_err(&priv->usb->dev,\r\n"failed to allocate rcb no %d\n", ii);\r\ngoto free_rx_tx;\r\n}\r\nrcb = priv->rcb[ii];\r\nrcb->priv = priv;\r\nrcb->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rcb->urb) {\r\ndev_err(&priv->usb->dev, "Failed to alloc rx urb\n");\r\ngoto free_rx_tx;\r\n}\r\nrcb->skb = dev_alloc_skb(priv->rx_buf_sz);\r\nif (!rcb->skb)\r\ngoto free_rx_tx;\r\nrcb->in_use = false;\r\nif (vnt_submit_rx_urb(priv, rcb))\r\ngoto free_rx_tx;\r\n}\r\npriv->interrupt_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!priv->interrupt_urb) {\r\ndev_err(&priv->usb->dev, "Failed to alloc int urb\n");\r\ngoto free_rx_tx;\r\n}\r\npriv->int_buf.data_buf = kmalloc(MAX_INTERRUPT_SIZE, GFP_KERNEL);\r\nif (!priv->int_buf.data_buf) {\r\nusb_free_urb(priv->interrupt_urb);\r\ngoto free_rx_tx;\r\n}\r\nreturn true;\r\nfree_rx_tx:\r\nvnt_free_rx_bufs(priv);\r\nfree_tx:\r\nvnt_free_tx_bufs(priv);\r\nreturn false;\r\n}\r\nstatic void vnt_tx_80211(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control, struct sk_buff *skb)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nif (vnt_tx_packet(priv, skb))\r\nieee80211_free_txskb(hw, skb);\r\n}\r\nstatic int vnt_start(struct ieee80211_hw *hw)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\npriv->rx_buf_sz = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;\r\nif (!vnt_alloc_bufs(priv)) {\r\ndev_dbg(&priv->usb->dev, "vnt_alloc_bufs fail...\n");\r\nreturn -ENOMEM;\r\n}\r\nclear_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags);\r\nif (vnt_init_registers(priv) == false) {\r\ndev_dbg(&priv->usb->dev, " init register fail\n");\r\ngoto free_all;\r\n}\r\npriv->int_interval = 1;\r\nvnt_int_start_interrupt(priv);\r\nieee80211_wake_queues(hw);\r\nreturn 0;\r\nfree_all:\r\nvnt_free_rx_bufs(priv);\r\nvnt_free_tx_bufs(priv);\r\nvnt_free_int_bufs(priv);\r\nusb_kill_urb(priv->interrupt_urb);\r\nusb_free_urb(priv->interrupt_urb);\r\nreturn -ENOMEM;\r\n}\r\nstatic void vnt_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nint i;\r\nif (!priv)\r\nreturn;\r\nfor (i = 0; i < MAX_KEY_TABLE; i++)\r\nvnt_mac_disable_keyentry(priv, i);\r\npriv->key_entry_inuse = 0;\r\nif (!test_bit(DEVICE_FLAGS_UNPLUG, &priv->flags))\r\nvnt_mac_shutdown(priv);\r\nieee80211_stop_queues(hw);\r\nset_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags);\r\ncancel_delayed_work_sync(&priv->run_command_work);\r\npriv->cmd_running = false;\r\nvnt_free_tx_bufs(priv);\r\nvnt_free_rx_bufs(priv);\r\nvnt_free_int_bufs(priv);\r\nusb_kill_urb(priv->interrupt_urb);\r\nusb_free_urb(priv->interrupt_urb);\r\n}\r\nstatic int vnt_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\npriv->vif = vif;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nvnt_mac_reg_bits_off(priv, MAC_REG_RCR, RCR_UNICAST);\r\nvnt_mac_reg_bits_on(priv, MAC_REG_HOSTCR, HOSTCR_ADHOC);\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nvnt_mac_reg_bits_off(priv, MAC_REG_RCR, RCR_UNICAST);\r\nvnt_mac_reg_bits_on(priv, MAC_REG_HOSTCR, HOSTCR_AP);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->op_mode = vif->type;\r\nvnt_set_bss_mode(priv);\r\nvnt_mac_set_led(priv, LEDSTS_STS, LEDSTS_INTER);\r\nreturn 0;\r\n}\r\nstatic void vnt_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nvnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);\r\nvnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\r\nvnt_mac_reg_bits_off(priv, MAC_REG_HOSTCR, HOSTCR_ADHOC);\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nvnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);\r\nvnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\r\nvnt_mac_reg_bits_off(priv, MAC_REG_HOSTCR, HOSTCR_AP);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvnt_radio_power_off(priv);\r\npriv->op_mode = NL80211_IFTYPE_UNSPECIFIED;\r\nvnt_mac_set_led(priv, LEDSTS_STS, LEDSTS_SLOW);\r\n}\r\nstatic int vnt_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nu8 bb_type;\r\nif (changed & IEEE80211_CONF_CHANGE_PS) {\r\nif (conf->flags & IEEE80211_CONF_PS)\r\nvnt_enable_power_saving(priv, conf->listen_interval);\r\nelse\r\nvnt_disable_power_saving(priv);\r\n}\r\nif ((changed & IEEE80211_CONF_CHANGE_CHANNEL) ||\r\n(conf->flags & IEEE80211_CONF_OFFCHANNEL)) {\r\nvnt_set_channel(priv, conf->chandef.chan->hw_value);\r\nif (conf->chandef.chan->band == NL80211_BAND_5GHZ)\r\nbb_type = BB_TYPE_11A;\r\nelse\r\nbb_type = BB_TYPE_11G;\r\nif (priv->bb_type != bb_type) {\r\npriv->bb_type = bb_type;\r\nvnt_set_bss_mode(priv);\r\n}\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_POWER) {\r\nif (priv->bb_type == BB_TYPE_11B)\r\npriv->current_rate = RATE_1M;\r\nelse\r\npriv->current_rate = RATE_54M;\r\nvnt_rf_setpower(priv, priv->current_rate,\r\nconf->chandef.chan->hw_value);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vnt_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, struct ieee80211_bss_conf *conf,\r\nu32 changed)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\npriv->current_aid = conf->aid;\r\nif (changed & BSS_CHANGED_BSSID && conf->bssid)\r\nvnt_mac_set_bssid_addr(priv, (u8 *)conf->bssid);\r\nif (changed & BSS_CHANGED_BASIC_RATES) {\r\npriv->basic_rates = conf->basic_rates;\r\nvnt_update_top_rates(priv);\r\ndev_dbg(&priv->usb->dev, "basic rates %x\n", conf->basic_rates);\r\n}\r\nif (changed & BSS_CHANGED_ERP_PREAMBLE) {\r\nif (conf->use_short_preamble) {\r\nvnt_mac_enable_barker_preamble_mode(priv);\r\npriv->preamble_type = true;\r\n} else {\r\nvnt_mac_disable_barker_preamble_mode(priv);\r\npriv->preamble_type = false;\r\n}\r\n}\r\nif (changed & BSS_CHANGED_ERP_CTS_PROT) {\r\nif (conf->use_cts_prot)\r\nvnt_mac_enable_protect_mode(priv);\r\nelse\r\nvnt_mac_disable_protect_mode(priv);\r\n}\r\nif (changed & BSS_CHANGED_ERP_SLOT) {\r\nif (conf->use_short_slot)\r\npriv->short_slot_time = true;\r\nelse\r\npriv->short_slot_time = false;\r\nvnt_set_short_slot_time(priv);\r\nvnt_set_vga_gain_offset(priv, priv->bb_vga[0]);\r\nvnt_update_pre_ed_threshold(priv, false);\r\n}\r\nif (changed & BSS_CHANGED_TXPOWER)\r\nvnt_rf_setpower(priv, priv->current_rate,\r\nconf->chandef.chan->hw_value);\r\nif (changed & BSS_CHANGED_BEACON_ENABLED) {\r\ndev_dbg(&priv->usb->dev,\r\n"Beacon enable %d\n", conf->enable_beacon);\r\nif (conf->enable_beacon) {\r\nvnt_beacon_enable(priv, vif, conf);\r\nvnt_mac_reg_bits_on(priv, MAC_REG_TCR, TCR_AUTOBCNTX);\r\n} else {\r\nvnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);\r\n}\r\n}\r\nif (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_BEACON_INFO) &&\r\npriv->op_mode != NL80211_IFTYPE_AP) {\r\nif (conf->assoc && conf->beacon_rate) {\r\nvnt_mac_reg_bits_on(priv, MAC_REG_TFTCTL,\r\nTFTCTL_TSFCNTREN);\r\nvnt_adjust_tsf(priv, conf->beacon_rate->hw_value,\r\nconf->sync_tsf, priv->current_tsf);\r\nvnt_mac_set_beacon_interval(priv, conf->beacon_int);\r\nvnt_reset_next_tbtt(priv, conf->beacon_int);\r\n} else {\r\nvnt_clear_current_tsf(priv);\r\nvnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL,\r\nTFTCTL_TSFCNTREN);\r\n}\r\n}\r\n}\r\nstatic u64 vnt_prepare_multicast(struct ieee80211_hw *hw,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nstruct netdev_hw_addr *ha;\r\nu64 mc_filter = 0;\r\nu32 bit_nr = 0;\r\nnetdev_hw_addr_list_for_each(ha, mc_list) {\r\nbit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter |= 1ULL << (bit_nr & 0x3f);\r\n}\r\npriv->mc_list_count = mc_list->count;\r\nreturn mc_filter;\r\n}\r\nstatic void vnt_configure(struct ieee80211_hw *hw,\r\nunsigned int changed_flags, unsigned int *total_flags, u64 multicast)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nu8 rx_mode = 0;\r\nint rc;\r\n*total_flags &= FIF_ALLMULTI | FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC;\r\nrc = vnt_control_in(priv, MESSAGE_TYPE_READ, MAC_REG_RCR,\r\nMESSAGE_REQUEST_MACREG, sizeof(u8), &rx_mode);\r\nif (!rc)\r\nrx_mode = RCR_MULTICAST | RCR_BROADCAST;\r\ndev_dbg(&priv->usb->dev, "rx mode in = %x\n", rx_mode);\r\nif (changed_flags & FIF_ALLMULTI) {\r\nif (*total_flags & FIF_ALLMULTI) {\r\nif (priv->mc_list_count > 2)\r\nvnt_mac_set_filter(priv, ~0);\r\nelse\r\nvnt_mac_set_filter(priv, multicast);\r\nrx_mode |= RCR_MULTICAST | RCR_BROADCAST;\r\n} else {\r\nrx_mode &= ~(RCR_MULTICAST | RCR_BROADCAST);\r\n}\r\n}\r\nif (changed_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC)) {\r\nif (*total_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC))\r\nrx_mode &= ~RCR_BSSID;\r\nelse\r\nrx_mode |= RCR_BSSID;\r\n}\r\nvnt_control_out_u8(priv, MESSAGE_REQUEST_MACREG, MAC_REG_RCR, rx_mode);\r\ndev_dbg(&priv->usb->dev, "rx mode out= %x\n", rx_mode);\r\n}\r\nstatic int vnt_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nswitch (cmd) {\r\ncase SET_KEY:\r\nif (vnt_set_keys(hw, sta, vif, key))\r\nreturn -EOPNOTSUPP;\r\nbreak;\r\ncase DISABLE_KEY:\r\nif (test_bit(key->hw_key_idx, &priv->key_entry_inuse))\r\nclear_bit(key->hw_key_idx, &priv->key_entry_inuse);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vnt_sw_scan_start(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nconst u8 *addr)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nvnt_set_bss_mode(priv);\r\nvnt_update_pre_ed_threshold(priv, true);\r\n}\r\nstatic void vnt_sw_scan_complete(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nvnt_update_pre_ed_threshold(priv, false);\r\n}\r\nstatic int vnt_get_stats(struct ieee80211_hw *hw,\r\nstruct ieee80211_low_level_stats *stats)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nmemcpy(stats, &priv->low_stats, sizeof(*stats));\r\nreturn 0;\r\n}\r\nstatic u64 vnt_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nreturn priv->current_tsf;\r\n}\r\nstatic void vnt_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nu64 tsf)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nvnt_update_next_tbtt(priv, tsf, vif->bss_conf.beacon_int);\r\n}\r\nstatic void vnt_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nvnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\r\nvnt_clear_current_tsf(priv);\r\n}\r\nint vnt_init(struct vnt_private *priv)\r\n{\r\nif (!(vnt_init_registers(priv)))\r\nreturn -EAGAIN;\r\nSET_IEEE80211_PERM_ADDR(priv->hw, priv->permanent_net_addr);\r\nvnt_init_bands(priv);\r\nif (ieee80211_register_hw(priv->hw))\r\nreturn -ENODEV;\r\npriv->mac_hw = true;\r\nvnt_radio_power_off(priv);\r\nreturn 0;\r\n}\r\nstatic int\r\nvt6656_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev;\r\nstruct vnt_private *priv;\r\nstruct ieee80211_hw *hw;\r\nstruct wiphy *wiphy;\r\nint rc = 0;\r\nudev = usb_get_dev(interface_to_usbdev(intf));\r\ndev_notice(&udev->dev, "%s Ver. %s\n",\r\nDEVICE_FULL_DRV_NAM, DEVICE_VERSION);\r\ndev_notice(&udev->dev,\r\n"Copyright (c) 2004 VIA Networking Technologies, Inc.\n");\r\nhw = ieee80211_alloc_hw(sizeof(struct vnt_private), &vnt_mac_ops);\r\nif (!hw) {\r\ndev_err(&udev->dev, "could not register ieee80211_hw\n");\r\nrc = -ENOMEM;\r\ngoto err_nomem;\r\n}\r\npriv = hw->priv;\r\npriv->hw = hw;\r\npriv->usb = udev;\r\nvnt_set_options(priv);\r\nspin_lock_init(&priv->lock);\r\nmutex_init(&priv->usb_lock);\r\nINIT_DELAYED_WORK(&priv->run_command_work, vnt_run_command);\r\nusb_set_intfdata(intf, priv);\r\nwiphy = priv->hw->wiphy;\r\nwiphy->frag_threshold = FRAG_THRESH_DEF;\r\nwiphy->rts_threshold = RTS_THRESH_DEF;\r\nwiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_ADHOC) | BIT(NL80211_IFTYPE_AP);\r\nieee80211_hw_set(priv->hw, TIMING_BEACON_ONLY);\r\nieee80211_hw_set(priv->hw, SIGNAL_DBM);\r\nieee80211_hw_set(priv->hw, RX_INCLUDES_FCS);\r\nieee80211_hw_set(priv->hw, REPORTS_TX_ACK_STATUS);\r\nieee80211_hw_set(priv->hw, SUPPORTS_PS);\r\npriv->hw->max_signal = 100;\r\nSET_IEEE80211_DEV(priv->hw, &intf->dev);\r\nusb_device_reset(priv);\r\nclear_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags);\r\nvnt_reset_command_timer(priv);\r\nvnt_schedule_command(priv, WLAN_CMD_INIT_MAC80211);\r\nreturn 0;\r\nerr_nomem:\r\nusb_put_dev(udev);\r\nreturn rc;\r\n}\r\nstatic void vt6656_disconnect(struct usb_interface *intf)\r\n{\r\nstruct vnt_private *priv = usb_get_intfdata(intf);\r\nif (!priv)\r\nreturn;\r\nif (priv->mac_hw)\r\nieee80211_unregister_hw(priv->hw);\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_dev(interface_to_usbdev(intf));\r\nset_bit(DEVICE_FLAGS_UNPLUG, &priv->flags);\r\nieee80211_free_hw(priv->hw);\r\n}\r\nstatic int vt6656_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vt6656_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}
