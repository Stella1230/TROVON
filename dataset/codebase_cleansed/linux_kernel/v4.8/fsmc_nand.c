static int fsmc_ecc1_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nif (section >= chip->ecc.steps)\r\nreturn -ERANGE;\r\noobregion->offset = (section * 16) + 2;\r\noobregion->length = 3;\r\nreturn 0;\r\n}\r\nstatic int fsmc_ecc1_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nif (section >= chip->ecc.steps)\r\nreturn -ERANGE;\r\noobregion->offset = (section * 16) + 8;\r\nif (section < chip->ecc.steps - 1)\r\noobregion->length = 8;\r\nelse\r\noobregion->length = mtd->oobsize - oobregion->offset;\r\nreturn 0;\r\n}\r\nstatic int fsmc_ecc4_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nif (section >= chip->ecc.steps)\r\nreturn -ERANGE;\r\noobregion->length = chip->ecc.bytes;\r\nif (!section && mtd->writesize <= 512)\r\noobregion->offset = 0;\r\nelse\r\noobregion->offset = (section * 16) + 2;\r\nreturn 0;\r\n}\r\nstatic int fsmc_ecc4_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nif (section >= chip->ecc.steps)\r\nreturn -ERANGE;\r\noobregion->offset = (section * 16) + 15;\r\nif (section < chip->ecc.steps - 1)\r\noobregion->length = 3;\r\nelse\r\noobregion->length = mtd->oobsize - oobregion->offset;\r\nreturn 0;\r\n}\r\nstatic inline struct fsmc_nand_data *mtd_to_fsmc(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd_to_nand(mtd), struct fsmc_nand_data, nand);\r\n}\r\nstatic void fsmc_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsmc_nand_data *host;\r\nhost = mtd_to_fsmc(mtd);\r\nswitch (chipnr) {\r\ncase -1:\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);\r\nbreak;\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nif (host->select_chip)\r\nhost->select_chip(chipnr,\r\nchip->options & NAND_BUSWIDTH_16);\r\nbreak;\r\ndefault:\r\ndev_err(host->dev, "unsupported chip-select %d\n", chipnr);\r\n}\r\n}\r\nstatic void fsmc_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nstruct fsmc_nand_data *host = mtd_to_fsmc(mtd);\r\nvoid __iomem *regs = host->regs_va;\r\nunsigned int bank = host->bank;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nu32 pc;\r\nif (ctrl & NAND_CLE) {\r\nthis->IO_ADDR_R = host->cmd_va;\r\nthis->IO_ADDR_W = host->cmd_va;\r\n} else if (ctrl & NAND_ALE) {\r\nthis->IO_ADDR_R = host->addr_va;\r\nthis->IO_ADDR_W = host->addr_va;\r\n} else {\r\nthis->IO_ADDR_R = host->data_va;\r\nthis->IO_ADDR_W = host->data_va;\r\n}\r\npc = readl(FSMC_NAND_REG(regs, bank, PC));\r\nif (ctrl & NAND_NCE)\r\npc |= FSMC_ENABLE;\r\nelse\r\npc &= ~FSMC_ENABLE;\r\nwritel_relaxed(pc, FSMC_NAND_REG(regs, bank, PC));\r\n}\r\nmb();\r\nif (cmd != NAND_CMD_NONE)\r\nwriteb_relaxed(cmd, this->IO_ADDR_W);\r\n}\r\nstatic void fsmc_nand_setup(void __iomem *regs, uint32_t bank,\r\nuint32_t busw, struct fsmc_nand_timings *timings)\r\n{\r\nuint32_t value = FSMC_DEVTYPE_NAND | FSMC_ENABLE | FSMC_WAITON;\r\nuint32_t tclr, tar, thiz, thold, twait, tset;\r\nstruct fsmc_nand_timings *tims;\r\nstruct fsmc_nand_timings default_timings = {\r\n.tclr = FSMC_TCLR_1,\r\n.tar = FSMC_TAR_1,\r\n.thiz = FSMC_THIZ_1,\r\n.thold = FSMC_THOLD_4,\r\n.twait = FSMC_TWAIT_6,\r\n.tset = FSMC_TSET_0,\r\n};\r\nif (timings)\r\ntims = timings;\r\nelse\r\ntims = &default_timings;\r\ntclr = (tims->tclr & FSMC_TCLR_MASK) << FSMC_TCLR_SHIFT;\r\ntar = (tims->tar & FSMC_TAR_MASK) << FSMC_TAR_SHIFT;\r\nthiz = (tims->thiz & FSMC_THIZ_MASK) << FSMC_THIZ_SHIFT;\r\nthold = (tims->thold & FSMC_THOLD_MASK) << FSMC_THOLD_SHIFT;\r\ntwait = (tims->twait & FSMC_TWAIT_MASK) << FSMC_TWAIT_SHIFT;\r\ntset = (tims->tset & FSMC_TSET_MASK) << FSMC_TSET_SHIFT;\r\nif (busw)\r\nwritel_relaxed(value | FSMC_DEVWID_16,\r\nFSMC_NAND_REG(regs, bank, PC));\r\nelse\r\nwritel_relaxed(value | FSMC_DEVWID_8,\r\nFSMC_NAND_REG(regs, bank, PC));\r\nwritel_relaxed(readl(FSMC_NAND_REG(regs, bank, PC)) | tclr | tar,\r\nFSMC_NAND_REG(regs, bank, PC));\r\nwritel_relaxed(thiz | thold | twait | tset,\r\nFSMC_NAND_REG(regs, bank, COMM));\r\nwritel_relaxed(thiz | thold | twait | tset,\r\nFSMC_NAND_REG(regs, bank, ATTRIB));\r\n}\r\nstatic void fsmc_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct fsmc_nand_data *host = mtd_to_fsmc(mtd);\r\nvoid __iomem *regs = host->regs_va;\r\nuint32_t bank = host->bank;\r\nwritel_relaxed(readl(FSMC_NAND_REG(regs, bank, PC)) & ~FSMC_ECCPLEN_256,\r\nFSMC_NAND_REG(regs, bank, PC));\r\nwritel_relaxed(readl(FSMC_NAND_REG(regs, bank, PC)) & ~FSMC_ECCEN,\r\nFSMC_NAND_REG(regs, bank, PC));\r\nwritel_relaxed(readl(FSMC_NAND_REG(regs, bank, PC)) | FSMC_ECCEN,\r\nFSMC_NAND_REG(regs, bank, PC));\r\n}\r\nstatic int fsmc_read_hwecc_ecc4(struct mtd_info *mtd, const uint8_t *data,\r\nuint8_t *ecc)\r\n{\r\nstruct fsmc_nand_data *host = mtd_to_fsmc(mtd);\r\nvoid __iomem *regs = host->regs_va;\r\nuint32_t bank = host->bank;\r\nuint32_t ecc_tmp;\r\nunsigned long deadline = jiffies + FSMC_BUSY_WAIT_TIMEOUT;\r\ndo {\r\nif (readl_relaxed(FSMC_NAND_REG(regs, bank, STS)) & FSMC_CODE_RDY)\r\nbreak;\r\nelse\r\ncond_resched();\r\n} while (!time_after_eq(jiffies, deadline));\r\nif (time_after_eq(jiffies, deadline)) {\r\ndev_err(host->dev, "calculate ecc timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\necc_tmp = readl_relaxed(FSMC_NAND_REG(regs, bank, ECC1));\r\necc[0] = (uint8_t) (ecc_tmp >> 0);\r\necc[1] = (uint8_t) (ecc_tmp >> 8);\r\necc[2] = (uint8_t) (ecc_tmp >> 16);\r\necc[3] = (uint8_t) (ecc_tmp >> 24);\r\necc_tmp = readl_relaxed(FSMC_NAND_REG(regs, bank, ECC2));\r\necc[4] = (uint8_t) (ecc_tmp >> 0);\r\necc[5] = (uint8_t) (ecc_tmp >> 8);\r\necc[6] = (uint8_t) (ecc_tmp >> 16);\r\necc[7] = (uint8_t) (ecc_tmp >> 24);\r\necc_tmp = readl_relaxed(FSMC_NAND_REG(regs, bank, ECC3));\r\necc[8] = (uint8_t) (ecc_tmp >> 0);\r\necc[9] = (uint8_t) (ecc_tmp >> 8);\r\necc[10] = (uint8_t) (ecc_tmp >> 16);\r\necc[11] = (uint8_t) (ecc_tmp >> 24);\r\necc_tmp = readl_relaxed(FSMC_NAND_REG(regs, bank, STS));\r\necc[12] = (uint8_t) (ecc_tmp >> 16);\r\nreturn 0;\r\n}\r\nstatic int fsmc_read_hwecc_ecc1(struct mtd_info *mtd, const uint8_t *data,\r\nuint8_t *ecc)\r\n{\r\nstruct fsmc_nand_data *host = mtd_to_fsmc(mtd);\r\nvoid __iomem *regs = host->regs_va;\r\nuint32_t bank = host->bank;\r\nuint32_t ecc_tmp;\r\necc_tmp = readl_relaxed(FSMC_NAND_REG(regs, bank, ECC1));\r\necc[0] = (uint8_t) (ecc_tmp >> 0);\r\necc[1] = (uint8_t) (ecc_tmp >> 8);\r\necc[2] = (uint8_t) (ecc_tmp >> 16);\r\nreturn 0;\r\n}\r\nstatic int count_written_bits(uint8_t *buff, int size, int max_bits)\r\n{\r\nint k, written_bits = 0;\r\nfor (k = 0; k < size; k++) {\r\nwritten_bits += hweight8(~buff[k]);\r\nif (written_bits > max_bits)\r\nbreak;\r\n}\r\nreturn written_bits;\r\n}\r\nstatic void dma_complete(void *param)\r\n{\r\nstruct fsmc_nand_data *host = param;\r\ncomplete(&host->dma_access_complete);\r\n}\r\nstatic int dma_xfer(struct fsmc_nand_data *host, void *buffer, int len,\r\nenum dma_data_direction direction)\r\n{\r\nstruct dma_chan *chan;\r\nstruct dma_device *dma_dev;\r\nstruct dma_async_tx_descriptor *tx;\r\ndma_addr_t dma_dst, dma_src, dma_addr;\r\ndma_cookie_t cookie;\r\nunsigned long flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\r\nint ret;\r\nunsigned long time_left;\r\nif (direction == DMA_TO_DEVICE)\r\nchan = host->write_dma_chan;\r\nelse if (direction == DMA_FROM_DEVICE)\r\nchan = host->read_dma_chan;\r\nelse\r\nreturn -EINVAL;\r\ndma_dev = chan->device;\r\ndma_addr = dma_map_single(dma_dev->dev, buffer, len, direction);\r\nif (direction == DMA_TO_DEVICE) {\r\ndma_src = dma_addr;\r\ndma_dst = host->data_pa;\r\n} else {\r\ndma_src = host->data_pa;\r\ndma_dst = dma_addr;\r\n}\r\ntx = dma_dev->device_prep_dma_memcpy(chan, dma_dst, dma_src,\r\nlen, flags);\r\nif (!tx) {\r\ndev_err(host->dev, "device_prep_dma_memcpy error\n");\r\nret = -EIO;\r\ngoto unmap_dma;\r\n}\r\ntx->callback = dma_complete;\r\ntx->callback_param = host;\r\ncookie = tx->tx_submit(tx);\r\nret = dma_submit_error(cookie);\r\nif (ret) {\r\ndev_err(host->dev, "dma_submit_error %d\n", cookie);\r\ngoto unmap_dma;\r\n}\r\ndma_async_issue_pending(chan);\r\ntime_left =\r\nwait_for_completion_timeout(&host->dma_access_complete,\r\nmsecs_to_jiffies(3000));\r\nif (time_left == 0) {\r\ndmaengine_terminate_all(chan);\r\ndev_err(host->dev, "wait_for_completion_timeout\n");\r\nret = -ETIMEDOUT;\r\ngoto unmap_dma;\r\n}\r\nret = 0;\r\nunmap_dma:\r\ndma_unmap_single(dma_dev->dev, dma_addr, len, direction);\r\nreturn ret;\r\n}\r\nstatic void fsmc_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nif (IS_ALIGNED((uint32_t)buf, sizeof(uint32_t)) &&\r\nIS_ALIGNED(len, sizeof(uint32_t))) {\r\nuint32_t *p = (uint32_t *)buf;\r\nlen = len >> 2;\r\nfor (i = 0; i < len; i++)\r\nwritel_relaxed(p[i], chip->IO_ADDR_W);\r\n} else {\r\nfor (i = 0; i < len; i++)\r\nwriteb_relaxed(buf[i], chip->IO_ADDR_W);\r\n}\r\n}\r\nstatic void fsmc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nif (IS_ALIGNED((uint32_t)buf, sizeof(uint32_t)) &&\r\nIS_ALIGNED(len, sizeof(uint32_t))) {\r\nuint32_t *p = (uint32_t *)buf;\r\nlen = len >> 2;\r\nfor (i = 0; i < len; i++)\r\np[i] = readl_relaxed(chip->IO_ADDR_R);\r\n} else {\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = readb_relaxed(chip->IO_ADDR_R);\r\n}\r\n}\r\nstatic void fsmc_read_buf_dma(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct fsmc_nand_data *host = mtd_to_fsmc(mtd);\r\ndma_xfer(host, buf, len, DMA_FROM_DEVICE);\r\n}\r\nstatic void fsmc_write_buf_dma(struct mtd_info *mtd, const uint8_t *buf,\r\nint len)\r\n{\r\nstruct fsmc_nand_data *host = mtd_to_fsmc(mtd);\r\ndma_xfer(host, (void *)buf, len, DMA_TO_DEVICE);\r\n}\r\nstatic int fsmc_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nint i, j, s, stat, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nuint8_t *ecc_code = chip->buffers->ecccode;\r\nint off, len, group = 0;\r\nuint16_t ecc_oob[7];\r\nuint8_t *oob = (uint8_t *)&ecc_oob[0];\r\nunsigned int max_bitflips = 0;\r\nfor (i = 0, s = 0; s < eccsteps; s++, i += eccbytes, p += eccsize) {\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, s * eccsize, page);\r\nchip->ecc.hwctl(mtd, NAND_ECC_READ);\r\nchip->read_buf(mtd, p, eccsize);\r\nfor (j = 0; j < eccbytes;) {\r\nstruct mtd_oob_region oobregion;\r\nint ret;\r\nret = mtd_ooblayout_ecc(mtd, group++, &oobregion);\r\nif (ret)\r\nreturn ret;\r\noff = oobregion.offset;\r\nlen = oobregion.length;\r\nif (chip->options & NAND_BUSWIDTH_16)\r\nlen = roundup(len, 2);\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, off, page);\r\nchip->read_buf(mtd, oob + j, len);\r\nj += len;\r\n}\r\nmemcpy(&ecc_code[i], oob, chip->ecc.bytes);\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\nstat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic int fsmc_bch8_correct_data(struct mtd_info *mtd, uint8_t *dat,\r\nuint8_t *read_ecc, uint8_t *calc_ecc)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsmc_nand_data *host = mtd_to_fsmc(mtd);\r\nvoid __iomem *regs = host->regs_va;\r\nunsigned int bank = host->bank;\r\nuint32_t err_idx[8];\r\nuint32_t num_err, i;\r\nuint32_t ecc1, ecc2, ecc3, ecc4;\r\nnum_err = (readl_relaxed(FSMC_NAND_REG(regs, bank, STS)) >> 10) & 0xF;\r\nif (likely(num_err == 0))\r\nreturn 0;\r\nif (unlikely(num_err > 8)) {\r\nint bits_ecc = count_written_bits(read_ecc, chip->ecc.bytes, 8);\r\nint bits_data = count_written_bits(dat, chip->ecc.size, 8);\r\nif ((bits_ecc + bits_data) <= 8) {\r\nif (bits_data)\r\nmemset(dat, 0xff, chip->ecc.size);\r\nreturn bits_data;\r\n}\r\nreturn -EBADMSG;\r\n}\r\necc1 = readl_relaxed(FSMC_NAND_REG(regs, bank, ECC1));\r\necc2 = readl_relaxed(FSMC_NAND_REG(regs, bank, ECC2));\r\necc3 = readl_relaxed(FSMC_NAND_REG(regs, bank, ECC3));\r\necc4 = readl_relaxed(FSMC_NAND_REG(regs, bank, STS));\r\nerr_idx[0] = (ecc1 >> 0) & 0x1FFF;\r\nerr_idx[1] = (ecc1 >> 13) & 0x1FFF;\r\nerr_idx[2] = (((ecc2 >> 0) & 0x7F) << 6) | ((ecc1 >> 26) & 0x3F);\r\nerr_idx[3] = (ecc2 >> 7) & 0x1FFF;\r\nerr_idx[4] = (((ecc3 >> 0) & 0x1) << 12) | ((ecc2 >> 20) & 0xFFF);\r\nerr_idx[5] = (ecc3 >> 1) & 0x1FFF;\r\nerr_idx[6] = (ecc3 >> 14) & 0x1FFF;\r\nerr_idx[7] = (((ecc4 >> 16) & 0xFF) << 5) | ((ecc3 >> 27) & 0x1F);\r\ni = 0;\r\nwhile (num_err--) {\r\nchange_bit(0, (unsigned long *)&err_idx[i]);\r\nchange_bit(1, (unsigned long *)&err_idx[i]);\r\nif (err_idx[i] < chip->ecc.size * 8) {\r\nchange_bit(err_idx[i], (unsigned long *)dat);\r\ni++;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic bool filter(struct dma_chan *chan, void *slave)\r\n{\r\nchan->private = slave;\r\nreturn true;\r\n}\r\nstatic int fsmc_nand_probe_config_dt(struct platform_device *pdev,\r\nstruct device_node *np)\r\n{\r\nstruct fsmc_nand_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nu32 val;\r\nint ret;\r\npdata->width = 8;\r\nif (!of_property_read_u32(np, "bank-width", &val)) {\r\nif (val == 2) {\r\npdata->width = 16;\r\n} else if (val != 1) {\r\ndev_err(&pdev->dev, "invalid bank-width %u\n", val);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (of_get_property(np, "nand-skip-bbtscan", NULL))\r\npdata->options = NAND_SKIP_BBTSCAN;\r\npdata->nand_timings = devm_kzalloc(&pdev->dev,\r\nsizeof(*pdata->nand_timings), GFP_KERNEL);\r\nif (!pdata->nand_timings)\r\nreturn -ENOMEM;\r\nret = of_property_read_u8_array(np, "timings", (u8 *)pdata->nand_timings,\r\nsizeof(*pdata->nand_timings));\r\nif (ret) {\r\ndev_info(&pdev->dev, "No timings in dts specified, using default timings!\n");\r\npdata->nand_timings = NULL;\r\n}\r\npdata->bank = 0;\r\nif (!of_property_read_u32(np, "bank", &val)) {\r\nif (val > 3) {\r\ndev_err(&pdev->dev, "invalid bank %u\n", val);\r\nreturn -EINVAL;\r\n}\r\npdata->bank = val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsmc_nand_probe_config_dt(struct platform_device *pdev,\r\nstruct device_node *np)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int __init fsmc_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct fsmc_nand_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node __maybe_unused *np = pdev->dev.of_node;\r\nstruct fsmc_nand_data *host;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand;\r\nstruct resource *res;\r\ndma_cap_mask_t mask;\r\nint ret = 0;\r\nu32 pid;\r\nint i;\r\nif (np) {\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\npdev->dev.platform_data = pdata;\r\nret = fsmc_nand_probe_config_dt(pdev, np);\r\nif (ret) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "platform data is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nhost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\r\nif (!host)\r\nreturn -ENOMEM;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "nand_data");\r\nhost->data_va = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->data_va))\r\nreturn PTR_ERR(host->data_va);\r\nhost->data_pa = (dma_addr_t)res->start;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "nand_addr");\r\nhost->addr_va = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->addr_va))\r\nreturn PTR_ERR(host->addr_va);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "nand_cmd");\r\nhost->cmd_va = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->cmd_va))\r\nreturn PTR_ERR(host->cmd_va);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "fsmc_regs");\r\nhost->regs_va = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->regs_va))\r\nreturn PTR_ERR(host->regs_va);\r\nhost->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(host->clk)) {\r\ndev_err(&pdev->dev, "failed to fetch block clock\n");\r\nreturn PTR_ERR(host->clk);\r\n}\r\nret = clk_prepare_enable(host->clk);\r\nif (ret)\r\ngoto err_clk_prepare_enable;\r\nfor (pid = 0, i = 0; i < 4; i++)\r\npid |= (readl(host->regs_va + resource_size(res) - 0x20 + 4 * i) & 255) << (i * 8);\r\nhost->pid = pid;\r\ndev_info(&pdev->dev, "FSMC device partno %03x, manufacturer %02x, "\r\n"revision %02x, config %02x\n",\r\nAMBA_PART_BITS(pid), AMBA_MANF_BITS(pid),\r\nAMBA_REV_BITS(pid), AMBA_CONFIG_BITS(pid));\r\nhost->bank = pdata->bank;\r\nhost->select_chip = pdata->select_bank;\r\nhost->partitions = pdata->partitions;\r\nhost->nr_partitions = pdata->nr_partitions;\r\nhost->dev = &pdev->dev;\r\nhost->dev_timings = pdata->nand_timings;\r\nhost->mode = pdata->mode;\r\nif (host->mode == USE_DMA_ACCESS)\r\ninit_completion(&host->dma_access_complete);\r\nmtd = nand_to_mtd(&host->nand);\r\nnand = &host->nand;\r\nnand_set_controller_data(nand, host);\r\nnand_set_flash_node(nand, np);\r\nmtd->dev.parent = &pdev->dev;\r\nnand->IO_ADDR_R = host->data_va;\r\nnand->IO_ADDR_W = host->data_va;\r\nnand->cmd_ctrl = fsmc_cmd_ctrl;\r\nnand->chip_delay = 30;\r\nnand->ecc.mode = NAND_ECC_HW;\r\nnand->ecc.hwctl = fsmc_enable_hwecc;\r\nnand->ecc.size = 512;\r\nnand->options = pdata->options;\r\nnand->select_chip = fsmc_select_chip;\r\nnand->badblockbits = 7;\r\nnand_set_flash_node(nand, np);\r\nif (pdata->width == FSMC_NAND_BW16)\r\nnand->options |= NAND_BUSWIDTH_16;\r\nswitch (host->mode) {\r\ncase USE_DMA_ACCESS:\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_MEMCPY, mask);\r\nhost->read_dma_chan = dma_request_channel(mask, filter,\r\npdata->read_dma_priv);\r\nif (!host->read_dma_chan) {\r\ndev_err(&pdev->dev, "Unable to get read dma channel\n");\r\ngoto err_req_read_chnl;\r\n}\r\nhost->write_dma_chan = dma_request_channel(mask, filter,\r\npdata->write_dma_priv);\r\nif (!host->write_dma_chan) {\r\ndev_err(&pdev->dev, "Unable to get write dma channel\n");\r\ngoto err_req_write_chnl;\r\n}\r\nnand->read_buf = fsmc_read_buf_dma;\r\nnand->write_buf = fsmc_write_buf_dma;\r\nbreak;\r\ndefault:\r\ncase USE_WORD_ACCESS:\r\nnand->read_buf = fsmc_read_buf;\r\nnand->write_buf = fsmc_write_buf;\r\nbreak;\r\n}\r\nfsmc_nand_setup(host->regs_va, host->bank,\r\nnand->options & NAND_BUSWIDTH_16,\r\nhost->dev_timings);\r\nif (AMBA_REV_BITS(host->pid) >= 8) {\r\nnand->ecc.read_page = fsmc_read_page_hwecc;\r\nnand->ecc.calculate = fsmc_read_hwecc_ecc4;\r\nnand->ecc.correct = fsmc_bch8_correct_data;\r\nnand->ecc.bytes = 13;\r\nnand->ecc.strength = 8;\r\n}\r\nif (nand_scan_ident(mtd, 1, NULL)) {\r\nret = -ENXIO;\r\ndev_err(&pdev->dev, "No NAND Device found!\n");\r\ngoto err_scan_ident;\r\n}\r\nif (AMBA_REV_BITS(host->pid) >= 8) {\r\nswitch (mtd->oobsize) {\r\ncase 16:\r\ncase 64:\r\ncase 128:\r\ncase 224:\r\ncase 256:\r\nbreak;\r\ndefault:\r\ndev_warn(&pdev->dev, "No oob scheme defined for oobsize %d\n",\r\nmtd->oobsize);\r\nret = -EINVAL;\r\ngoto err_probe;\r\n}\r\nmtd_set_ooblayout(mtd, &fsmc_ecc4_ooblayout_ops);\r\n} else {\r\nswitch (nand->ecc.mode) {\r\ncase NAND_ECC_HW:\r\ndev_info(&pdev->dev, "Using 1-bit HW ECC scheme\n");\r\nnand->ecc.calculate = fsmc_read_hwecc_ecc1;\r\nnand->ecc.correct = nand_correct_data;\r\nnand->ecc.bytes = 3;\r\nnand->ecc.strength = 1;\r\nbreak;\r\ncase NAND_ECC_SOFT:\r\nif (nand->ecc.algo == NAND_ECC_BCH) {\r\ndev_info(&pdev->dev, "Using 4-bit SW BCH ECC scheme\n");\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported ECC mode!\n");\r\ngoto err_probe;\r\n}\r\nif (nand->ecc.mode == NAND_ECC_HW) {\r\nswitch (mtd->oobsize) {\r\ncase 16:\r\ncase 64:\r\ncase 128:\r\nmtd_set_ooblayout(mtd,\r\n&fsmc_ecc1_ooblayout_ops);\r\nbreak;\r\ndefault:\r\ndev_warn(&pdev->dev,\r\n"No oob scheme defined for oobsize %d\n",\r\nmtd->oobsize);\r\nret = -EINVAL;\r\ngoto err_probe;\r\n}\r\n}\r\n}\r\nif (nand_scan_tail(mtd)) {\r\nret = -ENXIO;\r\ngoto err_probe;\r\n}\r\nmtd->name = "nand";\r\nret = mtd_device_register(mtd, host->partitions, host->nr_partitions);\r\nif (ret)\r\ngoto err_probe;\r\nplatform_set_drvdata(pdev, host);\r\ndev_info(&pdev->dev, "FSMC NAND driver registration successful\n");\r\nreturn 0;\r\nerr_probe:\r\nerr_scan_ident:\r\nif (host->mode == USE_DMA_ACCESS)\r\ndma_release_channel(host->write_dma_chan);\r\nerr_req_write_chnl:\r\nif (host->mode == USE_DMA_ACCESS)\r\ndma_release_channel(host->read_dma_chan);\r\nerr_req_read_chnl:\r\nclk_disable_unprepare(host->clk);\r\nerr_clk_prepare_enable:\r\nclk_put(host->clk);\r\nreturn ret;\r\n}\r\nstatic int fsmc_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct fsmc_nand_data *host = platform_get_drvdata(pdev);\r\nif (host) {\r\nnand_release(nand_to_mtd(&host->nand));\r\nif (host->mode == USE_DMA_ACCESS) {\r\ndma_release_channel(host->write_dma_chan);\r\ndma_release_channel(host->read_dma_chan);\r\n}\r\nclk_disable_unprepare(host->clk);\r\nclk_put(host->clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsmc_nand_suspend(struct device *dev)\r\n{\r\nstruct fsmc_nand_data *host = dev_get_drvdata(dev);\r\nif (host)\r\nclk_disable_unprepare(host->clk);\r\nreturn 0;\r\n}\r\nstatic int fsmc_nand_resume(struct device *dev)\r\n{\r\nstruct fsmc_nand_data *host = dev_get_drvdata(dev);\r\nif (host) {\r\nclk_prepare_enable(host->clk);\r\nfsmc_nand_setup(host->regs_va, host->bank,\r\nhost->nand.options & NAND_BUSWIDTH_16,\r\nhost->dev_timings);\r\n}\r\nreturn 0;\r\n}
