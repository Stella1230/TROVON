u32\r\nkrb5_encrypt(\r\nstruct crypto_skcipher *tfm,\r\nvoid * iv,\r\nvoid * in,\r\nvoid * out,\r\nint length)\r\n{\r\nu32 ret = -EINVAL;\r\nstruct scatterlist sg[1];\r\nu8 local_iv[GSS_KRB5_MAX_BLOCKSIZE] = {0};\r\nSKCIPHER_REQUEST_ON_STACK(req, tfm);\r\nif (length % crypto_skcipher_blocksize(tfm) != 0)\r\ngoto out;\r\nif (crypto_skcipher_ivsize(tfm) > GSS_KRB5_MAX_BLOCKSIZE) {\r\ndprintk("RPC: gss_k5encrypt: tfm iv size too large %d\n",\r\ncrypto_skcipher_ivsize(tfm));\r\ngoto out;\r\n}\r\nif (iv)\r\nmemcpy(local_iv, iv, crypto_skcipher_ivsize(tfm));\r\nmemcpy(out, in, length);\r\nsg_init_one(sg, out, length);\r\nskcipher_request_set_tfm(req, tfm);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg, sg, length, local_iv);\r\nret = crypto_skcipher_encrypt(req);\r\nskcipher_request_zero(req);\r\nout:\r\ndprintk("RPC: krb5_encrypt returns %d\n", ret);\r\nreturn ret;\r\n}\r\nu32\r\nkrb5_decrypt(\r\nstruct crypto_skcipher *tfm,\r\nvoid * iv,\r\nvoid * in,\r\nvoid * out,\r\nint length)\r\n{\r\nu32 ret = -EINVAL;\r\nstruct scatterlist sg[1];\r\nu8 local_iv[GSS_KRB5_MAX_BLOCKSIZE] = {0};\r\nSKCIPHER_REQUEST_ON_STACK(req, tfm);\r\nif (length % crypto_skcipher_blocksize(tfm) != 0)\r\ngoto out;\r\nif (crypto_skcipher_ivsize(tfm) > GSS_KRB5_MAX_BLOCKSIZE) {\r\ndprintk("RPC: gss_k5decrypt: tfm iv size too large %d\n",\r\ncrypto_skcipher_ivsize(tfm));\r\ngoto out;\r\n}\r\nif (iv)\r\nmemcpy(local_iv,iv, crypto_skcipher_ivsize(tfm));\r\nmemcpy(out, in, length);\r\nsg_init_one(sg, out, length);\r\nskcipher_request_set_tfm(req, tfm);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg, sg, length, local_iv);\r\nret = crypto_skcipher_decrypt(req);\r\nskcipher_request_zero(req);\r\nout:\r\ndprintk("RPC: gss_k5decrypt returns %d\n",ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nchecksummer(struct scatterlist *sg, void *data)\r\n{\r\nstruct ahash_request *req = data;\r\nahash_request_set_crypt(req, sg, NULL, sg->length);\r\nreturn crypto_ahash_update(req);\r\n}\r\nstatic int\r\narcfour_hmac_md5_usage_to_salt(unsigned int usage, u8 salt[4])\r\n{\r\nunsigned int ms_usage;\r\nswitch (usage) {\r\ncase KG_USAGE_SIGN:\r\nms_usage = 15;\r\nbreak;\r\ncase KG_USAGE_SEAL:\r\nms_usage = 13;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsalt[0] = (ms_usage >> 0) & 0xff;\r\nsalt[1] = (ms_usage >> 8) & 0xff;\r\nsalt[2] = (ms_usage >> 16) & 0xff;\r\nsalt[3] = (ms_usage >> 24) & 0xff;\r\nreturn 0;\r\n}\r\nstatic u32\r\nmake_checksum_hmac_md5(struct krb5_ctx *kctx, char *header, int hdrlen,\r\nstruct xdr_buf *body, int body_offset, u8 *cksumkey,\r\nunsigned int usage, struct xdr_netobj *cksumout)\r\n{\r\nstruct scatterlist sg[1];\r\nint err;\r\nu8 checksumdata[GSS_KRB5_MAX_CKSUM_LEN];\r\nu8 rc4salt[4];\r\nstruct crypto_ahash *md5;\r\nstruct crypto_ahash *hmac_md5;\r\nstruct ahash_request *req;\r\nif (cksumkey == NULL)\r\nreturn GSS_S_FAILURE;\r\nif (cksumout->len < kctx->gk5e->cksumlength) {\r\ndprintk("%s: checksum buffer length, %u, too small for %s\n",\r\n__func__, cksumout->len, kctx->gk5e->name);\r\nreturn GSS_S_FAILURE;\r\n}\r\nif (arcfour_hmac_md5_usage_to_salt(usage, rc4salt)) {\r\ndprintk("%s: invalid usage value %u\n", __func__, usage);\r\nreturn GSS_S_FAILURE;\r\n}\r\nmd5 = crypto_alloc_ahash("md5", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(md5))\r\nreturn GSS_S_FAILURE;\r\nhmac_md5 = crypto_alloc_ahash(kctx->gk5e->cksum_name, 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(hmac_md5)) {\r\ncrypto_free_ahash(md5);\r\nreturn GSS_S_FAILURE;\r\n}\r\nreq = ahash_request_alloc(md5, GFP_KERNEL);\r\nif (!req) {\r\ncrypto_free_ahash(hmac_md5);\r\ncrypto_free_ahash(md5);\r\nreturn GSS_S_FAILURE;\r\n}\r\nahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\r\nerr = crypto_ahash_init(req);\r\nif (err)\r\ngoto out;\r\nsg_init_one(sg, rc4salt, 4);\r\nahash_request_set_crypt(req, sg, NULL, 4);\r\nerr = crypto_ahash_update(req);\r\nif (err)\r\ngoto out;\r\nsg_init_one(sg, header, hdrlen);\r\nahash_request_set_crypt(req, sg, NULL, hdrlen);\r\nerr = crypto_ahash_update(req);\r\nif (err)\r\ngoto out;\r\nerr = xdr_process_buf(body, body_offset, body->len - body_offset,\r\nchecksummer, req);\r\nif (err)\r\ngoto out;\r\nahash_request_set_crypt(req, NULL, checksumdata, 0);\r\nerr = crypto_ahash_final(req);\r\nif (err)\r\ngoto out;\r\nahash_request_free(req);\r\nreq = ahash_request_alloc(hmac_md5, GFP_KERNEL);\r\nif (!req) {\r\ncrypto_free_ahash(hmac_md5);\r\ncrypto_free_ahash(md5);\r\nreturn GSS_S_FAILURE;\r\n}\r\nahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\r\nerr = crypto_ahash_init(req);\r\nif (err)\r\ngoto out;\r\nerr = crypto_ahash_setkey(hmac_md5, cksumkey, kctx->gk5e->keylength);\r\nif (err)\r\ngoto out;\r\nsg_init_one(sg, checksumdata, crypto_ahash_digestsize(md5));\r\nahash_request_set_crypt(req, sg, checksumdata,\r\ncrypto_ahash_digestsize(md5));\r\nerr = crypto_ahash_digest(req);\r\nif (err)\r\ngoto out;\r\nmemcpy(cksumout->data, checksumdata, kctx->gk5e->cksumlength);\r\ncksumout->len = kctx->gk5e->cksumlength;\r\nout:\r\nahash_request_free(req);\r\ncrypto_free_ahash(md5);\r\ncrypto_free_ahash(hmac_md5);\r\nreturn err ? GSS_S_FAILURE : 0;\r\n}\r\nu32\r\nmake_checksum(struct krb5_ctx *kctx, char *header, int hdrlen,\r\nstruct xdr_buf *body, int body_offset, u8 *cksumkey,\r\nunsigned int usage, struct xdr_netobj *cksumout)\r\n{\r\nstruct crypto_ahash *tfm;\r\nstruct ahash_request *req;\r\nstruct scatterlist sg[1];\r\nint err;\r\nu8 checksumdata[GSS_KRB5_MAX_CKSUM_LEN];\r\nunsigned int checksumlen;\r\nif (kctx->gk5e->ctype == CKSUMTYPE_HMAC_MD5_ARCFOUR)\r\nreturn make_checksum_hmac_md5(kctx, header, hdrlen,\r\nbody, body_offset,\r\ncksumkey, usage, cksumout);\r\nif (cksumout->len < kctx->gk5e->cksumlength) {\r\ndprintk("%s: checksum buffer length, %u, too small for %s\n",\r\n__func__, cksumout->len, kctx->gk5e->name);\r\nreturn GSS_S_FAILURE;\r\n}\r\ntfm = crypto_alloc_ahash(kctx->gk5e->cksum_name, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm))\r\nreturn GSS_S_FAILURE;\r\nreq = ahash_request_alloc(tfm, GFP_KERNEL);\r\nif (!req) {\r\ncrypto_free_ahash(tfm);\r\nreturn GSS_S_FAILURE;\r\n}\r\nahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\r\nchecksumlen = crypto_ahash_digestsize(tfm);\r\nif (cksumkey != NULL) {\r\nerr = crypto_ahash_setkey(tfm, cksumkey,\r\nkctx->gk5e->keylength);\r\nif (err)\r\ngoto out;\r\n}\r\nerr = crypto_ahash_init(req);\r\nif (err)\r\ngoto out;\r\nsg_init_one(sg, header, hdrlen);\r\nahash_request_set_crypt(req, sg, NULL, hdrlen);\r\nerr = crypto_ahash_update(req);\r\nif (err)\r\ngoto out;\r\nerr = xdr_process_buf(body, body_offset, body->len - body_offset,\r\nchecksummer, req);\r\nif (err)\r\ngoto out;\r\nahash_request_set_crypt(req, NULL, checksumdata, 0);\r\nerr = crypto_ahash_final(req);\r\nif (err)\r\ngoto out;\r\nswitch (kctx->gk5e->ctype) {\r\ncase CKSUMTYPE_RSA_MD5:\r\nerr = kctx->gk5e->encrypt(kctx->seq, NULL, checksumdata,\r\nchecksumdata, checksumlen);\r\nif (err)\r\ngoto out;\r\nmemcpy(cksumout->data,\r\nchecksumdata + checksumlen - kctx->gk5e->cksumlength,\r\nkctx->gk5e->cksumlength);\r\nbreak;\r\ncase CKSUMTYPE_HMAC_SHA1_DES3:\r\nmemcpy(cksumout->data, checksumdata, kctx->gk5e->cksumlength);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\ncksumout->len = kctx->gk5e->cksumlength;\r\nout:\r\nahash_request_free(req);\r\ncrypto_free_ahash(tfm);\r\nreturn err ? GSS_S_FAILURE : 0;\r\n}\r\nu32\r\nmake_checksum_v2(struct krb5_ctx *kctx, char *header, int hdrlen,\r\nstruct xdr_buf *body, int body_offset, u8 *cksumkey,\r\nunsigned int usage, struct xdr_netobj *cksumout)\r\n{\r\nstruct crypto_ahash *tfm;\r\nstruct ahash_request *req;\r\nstruct scatterlist sg[1];\r\nint err;\r\nu8 checksumdata[GSS_KRB5_MAX_CKSUM_LEN];\r\nunsigned int checksumlen;\r\nif (kctx->gk5e->keyed_cksum == 0) {\r\ndprintk("%s: expected keyed hash for %s\n",\r\n__func__, kctx->gk5e->name);\r\nreturn GSS_S_FAILURE;\r\n}\r\nif (cksumkey == NULL) {\r\ndprintk("%s: no key supplied for %s\n",\r\n__func__, kctx->gk5e->name);\r\nreturn GSS_S_FAILURE;\r\n}\r\ntfm = crypto_alloc_ahash(kctx->gk5e->cksum_name, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm))\r\nreturn GSS_S_FAILURE;\r\nchecksumlen = crypto_ahash_digestsize(tfm);\r\nreq = ahash_request_alloc(tfm, GFP_KERNEL);\r\nif (!req) {\r\ncrypto_free_ahash(tfm);\r\nreturn GSS_S_FAILURE;\r\n}\r\nahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\r\nerr = crypto_ahash_setkey(tfm, cksumkey, kctx->gk5e->keylength);\r\nif (err)\r\ngoto out;\r\nerr = crypto_ahash_init(req);\r\nif (err)\r\ngoto out;\r\nerr = xdr_process_buf(body, body_offset, body->len - body_offset,\r\nchecksummer, req);\r\nif (err)\r\ngoto out;\r\nif (header != NULL) {\r\nsg_init_one(sg, header, hdrlen);\r\nahash_request_set_crypt(req, sg, NULL, hdrlen);\r\nerr = crypto_ahash_update(req);\r\nif (err)\r\ngoto out;\r\n}\r\nahash_request_set_crypt(req, NULL, checksumdata, 0);\r\nerr = crypto_ahash_final(req);\r\nif (err)\r\ngoto out;\r\ncksumout->len = kctx->gk5e->cksumlength;\r\nswitch (kctx->gk5e->ctype) {\r\ncase CKSUMTYPE_HMAC_SHA1_96_AES128:\r\ncase CKSUMTYPE_HMAC_SHA1_96_AES256:\r\nmemcpy(cksumout->data, checksumdata, kctx->gk5e->cksumlength);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nout:\r\nahash_request_free(req);\r\ncrypto_free_ahash(tfm);\r\nreturn err ? GSS_S_FAILURE : 0;\r\n}\r\nstatic int\r\nencryptor(struct scatterlist *sg, void *data)\r\n{\r\nstruct encryptor_desc *desc = data;\r\nstruct xdr_buf *outbuf = desc->outbuf;\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(desc->req);\r\nstruct page *in_page;\r\nint thislen = desc->fraglen + sg->length;\r\nint fraglen, ret;\r\nint page_pos;\r\nBUG_ON(desc->fragno > 3);\r\npage_pos = desc->pos - outbuf->head[0].iov_len;\r\nif (page_pos >= 0 && page_pos < outbuf->page_len) {\r\nint i = (page_pos + outbuf->page_base) >> PAGE_SHIFT;\r\nin_page = desc->pages[i];\r\n} else {\r\nin_page = sg_page(sg);\r\n}\r\nsg_set_page(&desc->infrags[desc->fragno], in_page, sg->length,\r\nsg->offset);\r\nsg_set_page(&desc->outfrags[desc->fragno], sg_page(sg), sg->length,\r\nsg->offset);\r\ndesc->fragno++;\r\ndesc->fraglen += sg->length;\r\ndesc->pos += sg->length;\r\nfraglen = thislen & (crypto_skcipher_blocksize(tfm) - 1);\r\nthislen -= fraglen;\r\nif (thislen == 0)\r\nreturn 0;\r\nsg_mark_end(&desc->infrags[desc->fragno - 1]);\r\nsg_mark_end(&desc->outfrags[desc->fragno - 1]);\r\nskcipher_request_set_crypt(desc->req, desc->infrags, desc->outfrags,\r\nthislen, desc->iv);\r\nret = crypto_skcipher_encrypt(desc->req);\r\nif (ret)\r\nreturn ret;\r\nsg_init_table(desc->infrags, 4);\r\nsg_init_table(desc->outfrags, 4);\r\nif (fraglen) {\r\nsg_set_page(&desc->outfrags[0], sg_page(sg), fraglen,\r\nsg->offset + sg->length - fraglen);\r\ndesc->infrags[0] = desc->outfrags[0];\r\nsg_assign_page(&desc->infrags[0], in_page);\r\ndesc->fragno = 1;\r\ndesc->fraglen = fraglen;\r\n} else {\r\ndesc->fragno = 0;\r\ndesc->fraglen = 0;\r\n}\r\nreturn 0;\r\n}\r\nint\r\ngss_encrypt_xdr_buf(struct crypto_skcipher *tfm, struct xdr_buf *buf,\r\nint offset, struct page **pages)\r\n{\r\nint ret;\r\nstruct encryptor_desc desc;\r\nSKCIPHER_REQUEST_ON_STACK(req, tfm);\r\nBUG_ON((buf->len - offset) % crypto_skcipher_blocksize(tfm) != 0);\r\nskcipher_request_set_tfm(req, tfm);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nmemset(desc.iv, 0, sizeof(desc.iv));\r\ndesc.req = req;\r\ndesc.pos = offset;\r\ndesc.outbuf = buf;\r\ndesc.pages = pages;\r\ndesc.fragno = 0;\r\ndesc.fraglen = 0;\r\nsg_init_table(desc.infrags, 4);\r\nsg_init_table(desc.outfrags, 4);\r\nret = xdr_process_buf(buf, offset, buf->len - offset, encryptor, &desc);\r\nskcipher_request_zero(req);\r\nreturn ret;\r\n}\r\nstatic int\r\ndecryptor(struct scatterlist *sg, void *data)\r\n{\r\nstruct decryptor_desc *desc = data;\r\nint thislen = desc->fraglen + sg->length;\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(desc->req);\r\nint fraglen, ret;\r\nBUG_ON(desc->fragno > 3);\r\nsg_set_page(&desc->frags[desc->fragno], sg_page(sg), sg->length,\r\nsg->offset);\r\ndesc->fragno++;\r\ndesc->fraglen += sg->length;\r\nfraglen = thislen & (crypto_skcipher_blocksize(tfm) - 1);\r\nthislen -= fraglen;\r\nif (thislen == 0)\r\nreturn 0;\r\nsg_mark_end(&desc->frags[desc->fragno - 1]);\r\nskcipher_request_set_crypt(desc->req, desc->frags, desc->frags,\r\nthislen, desc->iv);\r\nret = crypto_skcipher_decrypt(desc->req);\r\nif (ret)\r\nreturn ret;\r\nsg_init_table(desc->frags, 4);\r\nif (fraglen) {\r\nsg_set_page(&desc->frags[0], sg_page(sg), fraglen,\r\nsg->offset + sg->length - fraglen);\r\ndesc->fragno = 1;\r\ndesc->fraglen = fraglen;\r\n} else {\r\ndesc->fragno = 0;\r\ndesc->fraglen = 0;\r\n}\r\nreturn 0;\r\n}\r\nint\r\ngss_decrypt_xdr_buf(struct crypto_skcipher *tfm, struct xdr_buf *buf,\r\nint offset)\r\n{\r\nint ret;\r\nstruct decryptor_desc desc;\r\nSKCIPHER_REQUEST_ON_STACK(req, tfm);\r\nBUG_ON((buf->len - offset) % crypto_skcipher_blocksize(tfm) != 0);\r\nskcipher_request_set_tfm(req, tfm);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nmemset(desc.iv, 0, sizeof(desc.iv));\r\ndesc.req = req;\r\ndesc.fragno = 0;\r\ndesc.fraglen = 0;\r\nsg_init_table(desc.frags, 4);\r\nret = xdr_process_buf(buf, offset, buf->len - offset, decryptor, &desc);\r\nskcipher_request_zero(req);\r\nreturn ret;\r\n}\r\nint\r\nxdr_extend_head(struct xdr_buf *buf, unsigned int base, unsigned int shiftlen)\r\n{\r\nu8 *p;\r\nif (shiftlen == 0)\r\nreturn 0;\r\nBUILD_BUG_ON(GSS_KRB5_MAX_SLACK_NEEDED > RPC_MAX_AUTH_SIZE);\r\nBUG_ON(shiftlen > RPC_MAX_AUTH_SIZE);\r\np = buf->head[0].iov_base + base;\r\nmemmove(p + shiftlen, p, buf->head[0].iov_len - base);\r\nbuf->head[0].iov_len += shiftlen;\r\nbuf->len += shiftlen;\r\nreturn 0;\r\n}\r\nstatic u32\r\ngss_krb5_cts_crypt(struct crypto_skcipher *cipher, struct xdr_buf *buf,\r\nu32 offset, u8 *iv, struct page **pages, int encrypt)\r\n{\r\nu32 ret;\r\nstruct scatterlist sg[1];\r\nSKCIPHER_REQUEST_ON_STACK(req, cipher);\r\nu8 data[GSS_KRB5_MAX_BLOCKSIZE * 2];\r\nstruct page **save_pages;\r\nu32 len = buf->len - offset;\r\nif (len > ARRAY_SIZE(data)) {\r\nWARN_ON(0);\r\nreturn -ENOMEM;\r\n}\r\nsave_pages = buf->pages;\r\nif (encrypt)\r\nbuf->pages = pages;\r\nret = read_bytes_from_xdr_buf(buf, offset, data, len);\r\nbuf->pages = save_pages;\r\nif (ret)\r\ngoto out;\r\nsg_init_one(sg, data, len);\r\nskcipher_request_set_tfm(req, cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg, sg, len, iv);\r\nif (encrypt)\r\nret = crypto_skcipher_encrypt(req);\r\nelse\r\nret = crypto_skcipher_decrypt(req);\r\nskcipher_request_zero(req);\r\nif (ret)\r\ngoto out;\r\nret = write_bytes_to_xdr_buf(buf, offset, data, len);\r\nout:\r\nreturn ret;\r\n}\r\nu32\r\ngss_krb5_aes_encrypt(struct krb5_ctx *kctx, u32 offset,\r\nstruct xdr_buf *buf, struct page **pages)\r\n{\r\nu32 err;\r\nstruct xdr_netobj hmac;\r\nu8 *cksumkey;\r\nu8 *ecptr;\r\nstruct crypto_skcipher *cipher, *aux_cipher;\r\nint blocksize;\r\nstruct page **save_pages;\r\nint nblocks, nbytes;\r\nstruct encryptor_desc desc;\r\nu32 cbcbytes;\r\nunsigned int usage;\r\nif (kctx->initiate) {\r\ncipher = kctx->initiator_enc;\r\naux_cipher = kctx->initiator_enc_aux;\r\ncksumkey = kctx->initiator_integ;\r\nusage = KG_USAGE_INITIATOR_SEAL;\r\n} else {\r\ncipher = kctx->acceptor_enc;\r\naux_cipher = kctx->acceptor_enc_aux;\r\ncksumkey = kctx->acceptor_integ;\r\nusage = KG_USAGE_ACCEPTOR_SEAL;\r\n}\r\nblocksize = crypto_skcipher_blocksize(cipher);\r\noffset += GSS_KRB5_TOK_HDR_LEN;\r\nif (xdr_extend_head(buf, offset, kctx->gk5e->conflen))\r\nreturn GSS_S_FAILURE;\r\ngss_krb5_make_confounder(buf->head[0].iov_base + offset, kctx->gk5e->conflen);\r\noffset -= GSS_KRB5_TOK_HDR_LEN;\r\nif (buf->tail[0].iov_base != NULL) {\r\necptr = buf->tail[0].iov_base + buf->tail[0].iov_len;\r\n} else {\r\nbuf->tail[0].iov_base = buf->head[0].iov_base\r\n+ buf->head[0].iov_len;\r\nbuf->tail[0].iov_len = 0;\r\necptr = buf->tail[0].iov_base;\r\n}\r\nmemcpy(ecptr, buf->head[0].iov_base + offset, GSS_KRB5_TOK_HDR_LEN);\r\nbuf->tail[0].iov_len += GSS_KRB5_TOK_HDR_LEN;\r\nbuf->len += GSS_KRB5_TOK_HDR_LEN;\r\nhmac.len = GSS_KRB5_MAX_CKSUM_LEN;\r\nhmac.data = buf->tail[0].iov_base + buf->tail[0].iov_len;\r\nsave_pages = buf->pages;\r\nbuf->pages = pages;\r\nerr = make_checksum_v2(kctx, NULL, 0, buf,\r\noffset + GSS_KRB5_TOK_HDR_LEN,\r\ncksumkey, usage, &hmac);\r\nbuf->pages = save_pages;\r\nif (err)\r\nreturn GSS_S_FAILURE;\r\nnbytes = buf->len - offset - GSS_KRB5_TOK_HDR_LEN;\r\nnblocks = (nbytes + blocksize - 1) / blocksize;\r\ncbcbytes = 0;\r\nif (nblocks > 2)\r\ncbcbytes = (nblocks - 2) * blocksize;\r\nmemset(desc.iv, 0, sizeof(desc.iv));\r\nif (cbcbytes) {\r\nSKCIPHER_REQUEST_ON_STACK(req, aux_cipher);\r\ndesc.pos = offset + GSS_KRB5_TOK_HDR_LEN;\r\ndesc.fragno = 0;\r\ndesc.fraglen = 0;\r\ndesc.pages = pages;\r\ndesc.outbuf = buf;\r\ndesc.req = req;\r\nskcipher_request_set_tfm(req, aux_cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nsg_init_table(desc.infrags, 4);\r\nsg_init_table(desc.outfrags, 4);\r\nerr = xdr_process_buf(buf, offset + GSS_KRB5_TOK_HDR_LEN,\r\ncbcbytes, encryptor, &desc);\r\nskcipher_request_zero(req);\r\nif (err)\r\ngoto out_err;\r\n}\r\nerr = gss_krb5_cts_crypt(cipher, buf,\r\noffset + GSS_KRB5_TOK_HDR_LEN + cbcbytes,\r\ndesc.iv, pages, 1);\r\nif (err) {\r\nerr = GSS_S_FAILURE;\r\ngoto out_err;\r\n}\r\nbuf->tail[0].iov_len += kctx->gk5e->cksumlength;\r\nbuf->len += kctx->gk5e->cksumlength;\r\nout_err:\r\nif (err)\r\nerr = GSS_S_FAILURE;\r\nreturn err;\r\n}\r\nu32\r\ngss_krb5_aes_decrypt(struct krb5_ctx *kctx, u32 offset, struct xdr_buf *buf,\r\nu32 *headskip, u32 *tailskip)\r\n{\r\nstruct xdr_buf subbuf;\r\nu32 ret = 0;\r\nu8 *cksum_key;\r\nstruct crypto_skcipher *cipher, *aux_cipher;\r\nstruct xdr_netobj our_hmac_obj;\r\nu8 our_hmac[GSS_KRB5_MAX_CKSUM_LEN];\r\nu8 pkt_hmac[GSS_KRB5_MAX_CKSUM_LEN];\r\nint nblocks, blocksize, cbcbytes;\r\nstruct decryptor_desc desc;\r\nunsigned int usage;\r\nif (kctx->initiate) {\r\ncipher = kctx->acceptor_enc;\r\naux_cipher = kctx->acceptor_enc_aux;\r\ncksum_key = kctx->acceptor_integ;\r\nusage = KG_USAGE_ACCEPTOR_SEAL;\r\n} else {\r\ncipher = kctx->initiator_enc;\r\naux_cipher = kctx->initiator_enc_aux;\r\ncksum_key = kctx->initiator_integ;\r\nusage = KG_USAGE_INITIATOR_SEAL;\r\n}\r\nblocksize = crypto_skcipher_blocksize(cipher);\r\nxdr_buf_subsegment(buf, &subbuf, offset + GSS_KRB5_TOK_HDR_LEN,\r\n(buf->len - offset - GSS_KRB5_TOK_HDR_LEN -\r\nkctx->gk5e->cksumlength));\r\nnblocks = (subbuf.len + blocksize - 1) / blocksize;\r\ncbcbytes = 0;\r\nif (nblocks > 2)\r\ncbcbytes = (nblocks - 2) * blocksize;\r\nmemset(desc.iv, 0, sizeof(desc.iv));\r\nif (cbcbytes) {\r\nSKCIPHER_REQUEST_ON_STACK(req, aux_cipher);\r\ndesc.fragno = 0;\r\ndesc.fraglen = 0;\r\ndesc.req = req;\r\nskcipher_request_set_tfm(req, aux_cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nsg_init_table(desc.frags, 4);\r\nret = xdr_process_buf(&subbuf, 0, cbcbytes, decryptor, &desc);\r\nskcipher_request_zero(req);\r\nif (ret)\r\ngoto out_err;\r\n}\r\nret = gss_krb5_cts_crypt(cipher, &subbuf, cbcbytes, desc.iv, NULL, 0);\r\nif (ret)\r\ngoto out_err;\r\nour_hmac_obj.len = sizeof(our_hmac);\r\nour_hmac_obj.data = our_hmac;\r\nret = make_checksum_v2(kctx, NULL, 0, &subbuf, 0,\r\ncksum_key, usage, &our_hmac_obj);\r\nif (ret)\r\ngoto out_err;\r\nret = read_bytes_from_xdr_buf(buf, buf->len - kctx->gk5e->cksumlength,\r\npkt_hmac, kctx->gk5e->cksumlength);\r\nif (ret)\r\ngoto out_err;\r\nif (memcmp(pkt_hmac, our_hmac, kctx->gk5e->cksumlength) != 0) {\r\nret = GSS_S_BAD_SIG;\r\ngoto out_err;\r\n}\r\n*headskip = kctx->gk5e->conflen;\r\n*tailskip = kctx->gk5e->cksumlength;\r\nout_err:\r\nif (ret && ret != GSS_S_BAD_SIG)\r\nret = GSS_S_FAILURE;\r\nreturn ret;\r\n}\r\nint\r\nkrb5_rc4_setup_seq_key(struct krb5_ctx *kctx, struct crypto_skcipher *cipher,\r\nunsigned char *cksum)\r\n{\r\nstruct crypto_shash *hmac;\r\nstruct shash_desc *desc;\r\nu8 Kseq[GSS_KRB5_MAX_KEYLEN];\r\nu32 zeroconstant = 0;\r\nint err;\r\ndprintk("%s: entered\n", __func__);\r\nhmac = crypto_alloc_shash(kctx->gk5e->cksum_name, 0, 0);\r\nif (IS_ERR(hmac)) {\r\ndprintk("%s: error %ld, allocating hash '%s'\n",\r\n__func__, PTR_ERR(hmac), kctx->gk5e->cksum_name);\r\nreturn PTR_ERR(hmac);\r\n}\r\ndesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(hmac),\r\nGFP_KERNEL);\r\nif (!desc) {\r\ndprintk("%s: failed to allocate shash descriptor for '%s'\n",\r\n__func__, kctx->gk5e->cksum_name);\r\ncrypto_free_shash(hmac);\r\nreturn -ENOMEM;\r\n}\r\ndesc->tfm = hmac;\r\ndesc->flags = 0;\r\nerr = crypto_shash_setkey(hmac, kctx->Ksess, kctx->gk5e->keylength);\r\nif (err)\r\ngoto out_err;\r\nerr = crypto_shash_digest(desc, (u8 *)&zeroconstant, 4, Kseq);\r\nif (err)\r\ngoto out_err;\r\nerr = crypto_shash_setkey(hmac, Kseq, kctx->gk5e->keylength);\r\nif (err)\r\ngoto out_err;\r\nerr = crypto_shash_digest(desc, cksum, 8, Kseq);\r\nif (err)\r\ngoto out_err;\r\nerr = crypto_skcipher_setkey(cipher, Kseq, kctx->gk5e->keylength);\r\nif (err)\r\ngoto out_err;\r\nerr = 0;\r\nout_err:\r\nkzfree(desc);\r\ncrypto_free_shash(hmac);\r\ndprintk("%s: returning %d\n", __func__, err);\r\nreturn err;\r\n}\r\nint\r\nkrb5_rc4_setup_enc_key(struct krb5_ctx *kctx, struct crypto_skcipher *cipher,\r\ns32 seqnum)\r\n{\r\nstruct crypto_shash *hmac;\r\nstruct shash_desc *desc;\r\nu8 Kcrypt[GSS_KRB5_MAX_KEYLEN];\r\nu8 zeroconstant[4] = {0};\r\nu8 seqnumarray[4];\r\nint err, i;\r\ndprintk("%s: entered, seqnum %u\n", __func__, seqnum);\r\nhmac = crypto_alloc_shash(kctx->gk5e->cksum_name, 0, 0);\r\nif (IS_ERR(hmac)) {\r\ndprintk("%s: error %ld, allocating hash '%s'\n",\r\n__func__, PTR_ERR(hmac), kctx->gk5e->cksum_name);\r\nreturn PTR_ERR(hmac);\r\n}\r\ndesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(hmac),\r\nGFP_KERNEL);\r\nif (!desc) {\r\ndprintk("%s: failed to allocate shash descriptor for '%s'\n",\r\n__func__, kctx->gk5e->cksum_name);\r\ncrypto_free_shash(hmac);\r\nreturn -ENOMEM;\r\n}\r\ndesc->tfm = hmac;\r\ndesc->flags = 0;\r\nfor (i = 0; i < kctx->gk5e->keylength; i++)\r\nKcrypt[i] = kctx->Ksess[i] ^ 0xf0;\r\nerr = crypto_shash_setkey(hmac, Kcrypt, kctx->gk5e->keylength);\r\nif (err)\r\ngoto out_err;\r\nerr = crypto_shash_digest(desc, zeroconstant, 4, Kcrypt);\r\nif (err)\r\ngoto out_err;\r\nerr = crypto_shash_setkey(hmac, Kcrypt, kctx->gk5e->keylength);\r\nif (err)\r\ngoto out_err;\r\nseqnumarray[0] = (unsigned char) ((seqnum >> 24) & 0xff);\r\nseqnumarray[1] = (unsigned char) ((seqnum >> 16) & 0xff);\r\nseqnumarray[2] = (unsigned char) ((seqnum >> 8) & 0xff);\r\nseqnumarray[3] = (unsigned char) ((seqnum >> 0) & 0xff);\r\nerr = crypto_shash_digest(desc, seqnumarray, 4, Kcrypt);\r\nif (err)\r\ngoto out_err;\r\nerr = crypto_skcipher_setkey(cipher, Kcrypt, kctx->gk5e->keylength);\r\nif (err)\r\ngoto out_err;\r\nerr = 0;\r\nout_err:\r\nkzfree(desc);\r\ncrypto_free_shash(hmac);\r\ndprintk("%s: returning %d\n", __func__, err);\r\nreturn err;\r\n}
