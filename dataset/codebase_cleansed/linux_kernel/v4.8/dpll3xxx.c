static void _omap3_dpll_write_clken(struct clk_hw_omap *clk, u8 clken_bits)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\ndd = clk->dpll_data;\r\nv = ti_clk_ll_ops->clk_readl(dd->control_reg);\r\nv &= ~dd->enable_mask;\r\nv |= clken_bits << __ffs(dd->enable_mask);\r\nti_clk_ll_ops->clk_writel(v, dd->control_reg);\r\n}\r\nstatic int _omap3_wait_dpll_status(struct clk_hw_omap *clk, u8 state)\r\n{\r\nconst struct dpll_data *dd;\r\nint i = 0;\r\nint ret = -EINVAL;\r\nconst char *clk_name;\r\ndd = clk->dpll_data;\r\nclk_name = clk_hw_get_name(&clk->hw);\r\nstate <<= __ffs(dd->idlest_mask);\r\nwhile (((ti_clk_ll_ops->clk_readl(dd->idlest_reg) & dd->idlest_mask)\r\n!= state) && i < MAX_DPLL_WAIT_TRIES) {\r\ni++;\r\nudelay(1);\r\n}\r\nif (i == MAX_DPLL_WAIT_TRIES) {\r\npr_err("clock: %s failed transition to '%s'\n",\r\nclk_name, (state) ? "locked" : "bypassed");\r\n} else {\r\npr_debug("clock: %s transition to '%s' in %d loops\n",\r\nclk_name, (state) ? "locked" : "bypassed", i);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic u16 _omap3_dpll_compute_freqsel(struct clk_hw_omap *clk, u8 n)\r\n{\r\nunsigned long fint;\r\nu16 f = 0;\r\nfint = clk_hw_get_rate(clk->dpll_data->clk_ref) / n;\r\npr_debug("clock: fint is %lu\n", fint);\r\nif (fint >= 750000 && fint <= 1000000)\r\nf = 0x3;\r\nelse if (fint > 1000000 && fint <= 1250000)\r\nf = 0x4;\r\nelse if (fint > 1250000 && fint <= 1500000)\r\nf = 0x5;\r\nelse if (fint > 1500000 && fint <= 1750000)\r\nf = 0x6;\r\nelse if (fint > 1750000 && fint <= 2100000)\r\nf = 0x7;\r\nelse if (fint > 7500000 && fint <= 10000000)\r\nf = 0xB;\r\nelse if (fint > 10000000 && fint <= 12500000)\r\nf = 0xC;\r\nelse if (fint > 12500000 && fint <= 15000000)\r\nf = 0xD;\r\nelse if (fint > 15000000 && fint <= 17500000)\r\nf = 0xE;\r\nelse if (fint > 17500000 && fint <= 21000000)\r\nf = 0xF;\r\nelse\r\npr_debug("clock: unknown freqsel setting for %d\n", n);\r\nreturn f;\r\n}\r\nstatic int _omap3_noncore_dpll_lock(struct clk_hw_omap *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu8 ai;\r\nu8 state = 1;\r\nint r = 0;\r\npr_debug("clock: locking DPLL %s\n", clk_hw_get_name(&clk->hw));\r\ndd = clk->dpll_data;\r\nstate <<= __ffs(dd->idlest_mask);\r\nif ((ti_clk_ll_ops->clk_readl(dd->idlest_reg) & dd->idlest_mask) ==\r\nstate)\r\ngoto done;\r\nai = omap3_dpll_autoidle_read(clk);\r\nif (ai)\r\nomap3_dpll_deny_idle(clk);\r\n_omap3_dpll_write_clken(clk, DPLL_LOCKED);\r\nr = _omap3_wait_dpll_status(clk, 1);\r\nif (ai)\r\nomap3_dpll_allow_idle(clk);\r\ndone:\r\nreturn r;\r\n}\r\nstatic int _omap3_noncore_dpll_bypass(struct clk_hw_omap *clk)\r\n{\r\nint r;\r\nu8 ai;\r\nif (!(clk->dpll_data->modes & (1 << DPLL_LOW_POWER_BYPASS)))\r\nreturn -EINVAL;\r\npr_debug("clock: configuring DPLL %s for low-power bypass\n",\r\nclk_hw_get_name(&clk->hw));\r\nai = omap3_dpll_autoidle_read(clk);\r\n_omap3_dpll_write_clken(clk, DPLL_LOW_POWER_BYPASS);\r\nr = _omap3_wait_dpll_status(clk, 0);\r\nif (ai)\r\nomap3_dpll_allow_idle(clk);\r\nreturn r;\r\n}\r\nstatic int _omap3_noncore_dpll_stop(struct clk_hw_omap *clk)\r\n{\r\nu8 ai;\r\nif (!(clk->dpll_data->modes & (1 << DPLL_LOW_POWER_STOP)))\r\nreturn -EINVAL;\r\npr_debug("clock: stopping DPLL %s\n", clk_hw_get_name(&clk->hw));\r\nai = omap3_dpll_autoidle_read(clk);\r\n_omap3_dpll_write_clken(clk, DPLL_LOW_POWER_STOP);\r\nif (ai)\r\nomap3_dpll_allow_idle(clk);\r\nreturn 0;\r\n}\r\nstatic void _lookup_dco(struct clk_hw_omap *clk, u8 *dco, u16 m, u8 n)\r\n{\r\nunsigned long fint, clkinp;\r\nclkinp = clk_hw_get_rate(clk_hw_get_parent(&clk->hw));\r\nfint = (clkinp / n) * m;\r\nif (fint < 1000000000)\r\n*dco = 2;\r\nelse\r\n*dco = 4;\r\n}\r\nstatic void _lookup_sddiv(struct clk_hw_omap *clk, u8 *sd_div, u16 m, u8 n)\r\n{\r\nunsigned long clkinp, sd;\r\nint mod1, mod2;\r\nclkinp = clk_hw_get_rate(clk_hw_get_parent(&clk->hw));\r\nclkinp /= 100000;\r\nmod1 = (clkinp * m) % (250 * n);\r\nsd = (clkinp * m) / (250 * n);\r\nmod2 = sd % 10;\r\nsd /= 10;\r\nif (mod1 || mod2)\r\nsd++;\r\n*sd_div = sd;\r\n}\r\nstatic int omap3_noncore_dpll_program(struct clk_hw_omap *clk, u16 freqsel)\r\n{\r\nstruct dpll_data *dd = clk->dpll_data;\r\nu8 dco, sd_div, ai = 0;\r\nu32 v;\r\nbool errata_i810;\r\n_omap3_noncore_dpll_bypass(clk);\r\nif (ti_clk_get_features()->flags & TI_CLK_DPLL_HAS_FREQSEL) {\r\nv = ti_clk_ll_ops->clk_readl(dd->control_reg);\r\nv &= ~dd->freqsel_mask;\r\nv |= freqsel << __ffs(dd->freqsel_mask);\r\nti_clk_ll_ops->clk_writel(v, dd->control_reg);\r\n}\r\nv = ti_clk_ll_ops->clk_readl(dd->mult_div1_reg);\r\nif (dd->dcc_mask) {\r\nif (dd->last_rounded_rate >= dd->dcc_rate)\r\nv |= dd->dcc_mask;\r\nelse\r\nv &= ~dd->dcc_mask;\r\n}\r\nv &= ~(dd->mult_mask | dd->div1_mask);\r\nv |= dd->last_rounded_m << __ffs(dd->mult_mask);\r\nv |= (dd->last_rounded_n - 1) << __ffs(dd->div1_mask);\r\nif (dd->dco_mask) {\r\n_lookup_dco(clk, &dco, dd->last_rounded_m, dd->last_rounded_n);\r\nv &= ~(dd->dco_mask);\r\nv |= dco << __ffs(dd->dco_mask);\r\n}\r\nif (dd->sddiv_mask) {\r\n_lookup_sddiv(clk, &sd_div, dd->last_rounded_m,\r\ndd->last_rounded_n);\r\nv &= ~(dd->sddiv_mask);\r\nv |= sd_div << __ffs(dd->sddiv_mask);\r\n}\r\nerrata_i810 = ti_clk_get_features()->flags & TI_CLK_ERRATA_I810;\r\nif (errata_i810) {\r\nai = omap3_dpll_autoidle_read(clk);\r\nif (ai) {\r\nomap3_dpll_deny_idle(clk);\r\nomap3_dpll_autoidle_read(clk);\r\n}\r\n}\r\nti_clk_ll_ops->clk_writel(v, dd->mult_div1_reg);\r\nif (dd->m4xen_mask || dd->lpmode_mask) {\r\nv = ti_clk_ll_ops->clk_readl(dd->control_reg);\r\nif (dd->m4xen_mask) {\r\nif (dd->last_rounded_m4xen)\r\nv |= dd->m4xen_mask;\r\nelse\r\nv &= ~dd->m4xen_mask;\r\n}\r\nif (dd->lpmode_mask) {\r\nif (dd->last_rounded_lpmode)\r\nv |= dd->lpmode_mask;\r\nelse\r\nv &= ~dd->lpmode_mask;\r\n}\r\nti_clk_ll_ops->clk_writel(v, dd->control_reg);\r\n}\r\n_omap3_noncore_dpll_lock(clk);\r\nif (errata_i810 && ai)\r\nomap3_dpll_allow_idle(clk);\r\nreturn 0;\r\n}\r\nunsigned long omap3_dpll_recalc(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nreturn omap2_get_dpll_rate(clk);\r\n}\r\nint omap3_noncore_dpll_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nint r;\r\nstruct dpll_data *dd;\r\nstruct clk_hw *parent;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn -EINVAL;\r\nif (clk->clkdm) {\r\nr = ti_clk_ll_ops->clkdm_clk_enable(clk->clkdm, hw->clk);\r\nif (r) {\r\nWARN(1,\r\n"%s: could not enable %s's clockdomain %s: %d\n",\r\n__func__, clk_hw_get_name(hw),\r\nclk->clkdm_name, r);\r\nreturn r;\r\n}\r\n}\r\nparent = clk_hw_get_parent(hw);\r\nif (clk_hw_get_rate(hw) == clk_hw_get_rate(dd->clk_bypass)) {\r\nWARN_ON(parent != dd->clk_bypass);\r\nr = _omap3_noncore_dpll_bypass(clk);\r\n} else {\r\nWARN_ON(parent != dd->clk_ref);\r\nr = _omap3_noncore_dpll_lock(clk);\r\n}\r\nreturn r;\r\n}\r\nvoid omap3_noncore_dpll_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\n_omap3_noncore_dpll_stop(clk);\r\nif (clk->clkdm)\r\nti_clk_ll_ops->clkdm_clk_disable(clk->clkdm, hw->clk);\r\n}\r\nint omap3_noncore_dpll_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nstruct dpll_data *dd;\r\nif (!req->rate)\r\nreturn -EINVAL;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn -EINVAL;\r\nif (clk_hw_get_rate(dd->clk_bypass) == req->rate &&\r\n(dd->modes & (1 << DPLL_LOW_POWER_BYPASS))) {\r\nreq->best_parent_hw = dd->clk_bypass;\r\n} else {\r\nreq->rate = omap2_dpll_round_rate(hw, req->rate,\r\n&req->best_parent_rate);\r\nreq->best_parent_hw = dd->clk_ref;\r\n}\r\nreq->best_parent_rate = req->rate;\r\nreturn 0;\r\n}\r\nint omap3_noncore_dpll_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nint ret;\r\nif (!hw)\r\nreturn -EINVAL;\r\nif (index)\r\nret = _omap3_noncore_dpll_bypass(clk);\r\nelse\r\nret = _omap3_noncore_dpll_lock(clk);\r\nreturn ret;\r\n}\r\nint omap3_noncore_dpll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nstruct dpll_data *dd;\r\nu16 freqsel = 0;\r\nint ret;\r\nif (!hw || !rate)\r\nreturn -EINVAL;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn -EINVAL;\r\nif (clk_hw_get_parent(hw) != dd->clk_ref)\r\nreturn -EINVAL;\r\nif (dd->last_rounded_rate == 0)\r\nreturn -EINVAL;\r\nif (ti_clk_get_features()->flags & TI_CLK_DPLL_HAS_FREQSEL) {\r\nfreqsel = _omap3_dpll_compute_freqsel(clk, dd->last_rounded_n);\r\nWARN_ON(!freqsel);\r\n}\r\npr_debug("%s: %s: set rate: locking rate to %lu.\n", __func__,\r\nclk_hw_get_name(hw), rate);\r\nret = omap3_noncore_dpll_program(clk, freqsel);\r\nreturn ret;\r\n}\r\nint omap3_noncore_dpll_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long parent_rate,\r\nu8 index)\r\n{\r\nint ret;\r\nif (!hw || !rate)\r\nreturn -EINVAL;\r\nif (index)\r\nret = omap3_noncore_dpll_set_parent(hw, index);\r\nelse\r\nret = omap3_noncore_dpll_set_rate(hw, rate, parent_rate);\r\nreturn ret;\r\n}\r\nstatic u32 omap3_dpll_autoidle_read(struct clk_hw_omap *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\nif (!clk || !clk->dpll_data)\r\nreturn -EINVAL;\r\ndd = clk->dpll_data;\r\nif (!dd->autoidle_reg)\r\nreturn -EINVAL;\r\nv = ti_clk_ll_ops->clk_readl(dd->autoidle_reg);\r\nv &= dd->autoidle_mask;\r\nv >>= __ffs(dd->autoidle_mask);\r\nreturn v;\r\n}\r\nstatic void omap3_dpll_allow_idle(struct clk_hw_omap *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\nif (!clk || !clk->dpll_data)\r\nreturn;\r\ndd = clk->dpll_data;\r\nif (!dd->autoidle_reg)\r\nreturn;\r\nv = ti_clk_ll_ops->clk_readl(dd->autoidle_reg);\r\nv &= ~dd->autoidle_mask;\r\nv |= DPLL_AUTOIDLE_LOW_POWER_STOP << __ffs(dd->autoidle_mask);\r\nti_clk_ll_ops->clk_writel(v, dd->autoidle_reg);\r\n}\r\nstatic void omap3_dpll_deny_idle(struct clk_hw_omap *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\nif (!clk || !clk->dpll_data)\r\nreturn;\r\ndd = clk->dpll_data;\r\nif (!dd->autoidle_reg)\r\nreturn;\r\nv = ti_clk_ll_ops->clk_readl(dd->autoidle_reg);\r\nv &= ~dd->autoidle_mask;\r\nv |= DPLL_AUTOIDLE_DISABLE << __ffs(dd->autoidle_mask);\r\nti_clk_ll_ops->clk_writel(v, dd->autoidle_reg);\r\n}\r\nstatic struct clk_hw_omap *omap3_find_clkoutx2_dpll(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *pclk = NULL;\r\ndo {\r\ndo {\r\nhw = clk_hw_get_parent(hw);\r\n} while (hw && (clk_hw_get_flags(hw) & CLK_IS_BASIC));\r\nif (!hw)\r\nbreak;\r\npclk = to_clk_hw_omap(hw);\r\n} while (pclk && !pclk->dpll_data);\r\nif (!pclk) {\r\nWARN_ON(1);\r\nreturn NULL;\r\n}\r\nreturn pclk;\r\n}\r\nunsigned long omap3_clkoutx2_recalc(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nconst struct dpll_data *dd;\r\nunsigned long rate;\r\nu32 v;\r\nstruct clk_hw_omap *pclk = NULL;\r\nif (!parent_rate)\r\nreturn 0;\r\npclk = omap3_find_clkoutx2_dpll(hw);\r\nif (!pclk)\r\nreturn 0;\r\ndd = pclk->dpll_data;\r\nWARN_ON(!dd->enable_mask);\r\nv = ti_clk_ll_ops->clk_readl(dd->control_reg) & dd->enable_mask;\r\nv >>= __ffs(dd->enable_mask);\r\nif ((v != OMAP3XXX_EN_DPLL_LOCKED) || (dd->flags & DPLL_J_TYPE))\r\nrate = parent_rate;\r\nelse\r\nrate = parent_rate * 2;\r\nreturn rate;\r\n}\r\nint omap3_dpll4_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nif (ti_clk_get_features()->flags & TI_CLK_DPLL4_DENY_REPROGRAM) {\r\npr_err("clock: DPLL4 cannot change rate due to silicon 'Limitation 2.5' on 3430ES1.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn omap3_noncore_dpll_set_rate(hw, rate, parent_rate);\r\n}\r\nint omap3_dpll4_set_rate_and_parent(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate, u8 index)\r\n{\r\nif (ti_clk_get_features()->flags & TI_CLK_DPLL4_DENY_REPROGRAM) {\r\npr_err("clock: DPLL4 cannot change rate due to silicon 'Limitation 2.5' on 3430ES1.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn omap3_noncore_dpll_set_rate_and_parent(hw, rate, parent_rate,\r\nindex);\r\n}
