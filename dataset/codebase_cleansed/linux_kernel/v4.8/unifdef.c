int\r\nmain(int argc, char *argv[])\r\n{\r\nint opt;\r\nwhile ((opt = getopt(argc, argv, "i:D:U:I:o:bBcdeKklnsStV")) != -1)\r\nswitch (opt) {\r\ncase 'i':\r\nopt = *optarg++;\r\nif (opt == 'D')\r\naddsym(true, true, optarg);\r\nelse if (opt == 'U')\r\naddsym(true, false, optarg);\r\nelse\r\nusage();\r\nbreak;\r\ncase 'D':\r\naddsym(false, true, optarg);\r\nbreak;\r\ncase 'U':\r\naddsym(false, false, optarg);\r\nbreak;\r\ncase 'I':\r\nbreak;\r\ncase 'b':\r\ncase 'l':\r\nlnblank = true;\r\nbreak;\r\ncase 'B':\r\ncompblank = true;\r\nbreak;\r\ncase 'c':\r\ncomplement = true;\r\nbreak;\r\ncase 'd':\r\ndebugging = true;\r\nbreak;\r\ncase 'e':\r\niocccok = true;\r\nbreak;\r\ncase 'K':\r\nstrictlogic = true;\r\nbreak;\r\ncase 'k':\r\nkillconsts = true;\r\nbreak;\r\ncase 'n':\r\nlnnum = true;\r\nbreak;\r\ncase 'o':\r\nofilename = optarg;\r\nbreak;\r\ncase 's':\r\nsymlist = true;\r\nbreak;\r\ncase 'S':\r\nsymlist = symdepth = true;\r\nbreak;\r\ncase 't':\r\ntext = true;\r\nbreak;\r\ncase 'V':\r\nversion();\r\ndefault:\r\nusage();\r\n}\r\nargc -= optind;\r\nargv += optind;\r\nif (compblank && lnblank)\r\nerrx(2, "-B and -b are mutually exclusive");\r\nif (argc > 1) {\r\nerrx(2, "can only do one file");\r\n} else if (argc == 1 && strcmp(*argv, "-") != 0) {\r\nfilename = *argv;\r\ninput = fopen(filename, "rb");\r\nif (input == NULL)\r\nerr(2, "can't open %s", filename);\r\n} else {\r\nfilename = "[stdin]";\r\ninput = stdin;\r\n}\r\nif (ofilename == NULL) {\r\nofilename = "[stdout]";\r\noutput = stdout;\r\n} else {\r\nstruct stat ist, ost;\r\nif (stat(ofilename, &ost) == 0 &&\r\nfstat(fileno(input), &ist) == 0)\r\noverwriting = (ist.st_dev == ost.st_dev\r\n&& ist.st_ino == ost.st_ino);\r\nif (overwriting) {\r\nconst char *dirsep;\r\nint ofd;\r\ndirsep = strrchr(ofilename, '/');\r\nif (dirsep != NULL)\r\nsnprintf(tempname, sizeof(tempname),\r\n"%.*s/" TEMPLATE,\r\n(int)(dirsep - ofilename), ofilename);\r\nelse\r\nsnprintf(tempname, sizeof(tempname),\r\nTEMPLATE);\r\nofd = mkstemp(tempname);\r\nif (ofd != -1)\r\noutput = fdopen(ofd, "wb+");\r\nif (output == NULL)\r\nerr(2, "can't create temporary file");\r\nfchmod(ofd, ist.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO));\r\n} else {\r\noutput = fopen(ofilename, "wb");\r\nif (output == NULL)\r\nerr(2, "can't open %s", ofilename);\r\n}\r\n}\r\nprocess();\r\nabort();\r\n}\r\nstatic void\r\nversion(void)\r\n{\r\nconst char *c = copyright;\r\nfor (;;) {\r\nwhile (*++c != '$')\r\nif (*c == '\0')\r\nexit(0);\r\nwhile (*++c != '$')\r\nputc(*c, stderr);\r\nputc('\n', stderr);\r\n}\r\n}\r\nstatic void\r\nusage(void)\r\n{\r\nfprintf(stderr, "usage: unifdef [-bBcdeKknsStV] [-Ipath]"\r\n" [-Dsym[=val]] [-Usym] [-iDsym[=val]] [-iUsym] ... [file]\n");\r\nexit(2);\r\n}\r\nstatic void Eelif (void) { error("Inappropriate #elif"); }\r\nstatic void Eelse (void) { error("Inappropriate #else"); }\r\nstatic void Eendif(void) { error("Inappropriate #endif"); }\r\nstatic void Eeof (void) { error("Premature EOF"); }\r\nstatic void Eioccc(void) { error("Obfuscated preprocessor control line"); }\r\nstatic void print (void) { flushline(true); }\r\nstatic void drop (void) { flushline(false); }\r\nstatic void Strue (void) { drop(); ignoreoff(); state(IS_TRUE_PREFIX); }\r\nstatic void Sfalse(void) { drop(); ignoreoff(); state(IS_FALSE_PREFIX); }\r\nstatic void Selse (void) { drop(); state(IS_TRUE_ELSE); }\r\nstatic void Pelif (void) { print(); ignoreoff(); state(IS_PASS_MIDDLE); }\r\nstatic void Pelse (void) { print(); state(IS_PASS_ELSE); }\r\nstatic void Pendif(void) { print(); unnest(); }\r\nstatic void Dfalse(void) { drop(); ignoreoff(); state(IS_FALSE_TRAILER); }\r\nstatic void Delif (void) { drop(); ignoreoff(); state(IS_FALSE_MIDDLE); }\r\nstatic void Delse (void) { drop(); state(IS_FALSE_ELSE); }\r\nstatic void Dendif(void) { drop(); unnest(); }\r\nstatic void Fdrop (void) { nest(); Dfalse(); }\r\nstatic void Fpass (void) { nest(); Pelif(); }\r\nstatic void Ftrue (void) { nest(); Strue(); }\r\nstatic void Ffalse(void) { nest(); Sfalse(); }\r\nstatic void Oiffy (void) { if (!iocccok) Eioccc(); Fpass(); ignoreon(); }\r\nstatic void Oif (void) { if (!iocccok) Eioccc(); Fpass(); }\r\nstatic void Oelif (void) { if (!iocccok) Eioccc(); Pelif(); }\r\nstatic void Idrop (void) { Fdrop(); ignoreon(); }\r\nstatic void Itrue (void) { Ftrue(); ignoreon(); }\r\nstatic void Ifalse(void) { Ffalse(); ignoreon(); }\r\nstatic void Mpass (void) { strncpy(keyword, "if ", 4); Pelif(); }\r\nstatic void Mtrue (void) { keywordedit("else"); state(IS_TRUE_MIDDLE); }\r\nstatic void Melif (void) { keywordedit("endif"); state(IS_FALSE_TRAILER); }\r\nstatic void Melse (void) { keywordedit("endif"); state(IS_FALSE_ELSE); }\r\nstatic void\r\nignoreoff(void)\r\n{\r\nif (depth == 0)\r\nabort();\r\nignoring[depth] = ignoring[depth-1];\r\n}\r\nstatic void\r\nignoreon(void)\r\n{\r\nignoring[depth] = true;\r\n}\r\nstatic void\r\nkeywordedit(const char *replacement)\r\n{\r\nsnprintf(keyword, tline + sizeof(tline) - keyword,\r\n"%s%s", replacement, newline);\r\nprint();\r\n}\r\nstatic void\r\nnest(void)\r\n{\r\nif (depth > MAXDEPTH-1)\r\nabort();\r\nif (depth == MAXDEPTH-1)\r\nerror("Too many levels of nesting");\r\ndepth += 1;\r\nstifline[depth] = linenum;\r\n}\r\nstatic void\r\nunnest(void)\r\n{\r\nif (depth == 0)\r\nabort();\r\ndepth -= 1;\r\n}\r\nstatic void\r\nstate(Ifstate is)\r\n{\r\nifstate[depth] = is;\r\n}\r\nstatic void\r\nflushline(bool keep)\r\n{\r\nif (symlist)\r\nreturn;\r\nif (keep ^ complement) {\r\nbool blankline = tline[strspn(tline, " \t\r\n")] == '\0';\r\nif (blankline && compblank && blankcount != blankmax) {\r\ndelcount += 1;\r\nblankcount += 1;\r\n} else {\r\nif (lnnum && delcount > 0)\r\nprintf("#line %d%s", linenum, newline);\r\nfputs(tline, output);\r\ndelcount = 0;\r\nblankmax = blankcount = blankline ? blankcount + 1 : 0;\r\n}\r\n} else {\r\nif (lnblank)\r\nfputs(newline, output);\r\nexitstat = 1;\r\ndelcount += 1;\r\nblankcount = 0;\r\n}\r\nif (debugging)\r\nfflush(output);\r\n}\r\nstatic void\r\nprocess(void)\r\n{\r\nblankmax = blankcount = 1000;\r\nfor (;;) {\r\nLinetype lineval = parseline();\r\ntrans_table[ifstate[depth]][lineval]();\r\ndebug("process line %d %s -> %s depth %d",\r\nlinenum, linetype_name[lineval],\r\nifstate_name[ifstate[depth]], depth);\r\n}\r\n}\r\nstatic void\r\ncloseout(void)\r\n{\r\nif (symdepth && !zerosyms)\r\nprintf("\n");\r\nif (fclose(output) == EOF) {\r\nwarn("couldn't write to %s", ofilename);\r\nif (overwriting) {\r\nunlink(tempname);\r\nerrx(2, "%s unchanged", filename);\r\n} else {\r\nexit(2);\r\n}\r\n}\r\n}\r\nstatic void\r\ndone(void)\r\n{\r\nif (incomment)\r\nerror("EOF in comment");\r\ncloseout();\r\nif (overwriting && rename(tempname, ofilename) == -1) {\r\nwarn("couldn't rename temporary file");\r\nunlink(tempname);\r\nerrx(2, "%s unchanged", ofilename);\r\n}\r\nexit(exitstat);\r\n}\r\nstatic Linetype\r\nparseline(void)\r\n{\r\nconst char *cp;\r\nint cursym;\r\nint kwlen;\r\nLinetype retval;\r\nComment_state wascomment;\r\nlinenum++;\r\nif (fgets(tline, MAXLINE, input) == NULL)\r\nreturn (LT_EOF);\r\nif (newline == NULL) {\r\nif (strrchr(tline, '\n') == strrchr(tline, '\r') + 1)\r\nnewline = newline_crlf;\r\nelse\r\nnewline = newline_unix;\r\n}\r\nretval = LT_PLAIN;\r\nwascomment = incomment;\r\ncp = skipcomment(tline);\r\nif (linestate == LS_START) {\r\nif (*cp == '#') {\r\nlinestate = LS_HASH;\r\nfirstsym = true;\r\ncp = skipcomment(cp + 1);\r\n} else if (*cp != '\0')\r\nlinestate = LS_DIRTY;\r\n}\r\nif (!incomment && linestate == LS_HASH) {\r\nkeyword = tline + (cp - tline);\r\ncp = skipsym(cp);\r\nkwlen = cp - keyword;\r\nif (strncmp(cp, "\\\r\n", 3) == 0 ||\r\nstrncmp(cp, "\\\n", 2) == 0)\r\nEioccc();\r\nif (strlcmp("ifdef", keyword, kwlen) == 0 ||\r\nstrlcmp("ifndef", keyword, kwlen) == 0) {\r\ncp = skipcomment(cp);\r\nif ((cursym = findsym(cp)) < 0)\r\nretval = LT_IF;\r\nelse {\r\nretval = (keyword[2] == 'n')\r\n? LT_FALSE : LT_TRUE;\r\nif (value[cursym] == NULL)\r\nretval = (retval == LT_TRUE)\r\n? LT_FALSE : LT_TRUE;\r\nif (ignore[cursym])\r\nretval = (retval == LT_TRUE)\r\n? LT_TRUEI : LT_FALSEI;\r\n}\r\ncp = skipsym(cp);\r\n} else if (strlcmp("if", keyword, kwlen) == 0)\r\nretval = ifeval(&cp);\r\nelse if (strlcmp("elif", keyword, kwlen) == 0)\r\nretval = ifeval(&cp) - LT_IF + LT_ELIF;\r\nelse if (strlcmp("else", keyword, kwlen) == 0)\r\nretval = LT_ELSE;\r\nelse if (strlcmp("endif", keyword, kwlen) == 0)\r\nretval = LT_ENDIF;\r\nelse {\r\nlinestate = LS_DIRTY;\r\nretval = LT_PLAIN;\r\n}\r\ncp = skipcomment(cp);\r\nif (*cp != '\0') {\r\nlinestate = LS_DIRTY;\r\nif (retval == LT_TRUE || retval == LT_FALSE ||\r\nretval == LT_TRUEI || retval == LT_FALSEI)\r\nretval = LT_IF;\r\nif (retval == LT_ELTRUE || retval == LT_ELFALSE)\r\nretval = LT_ELIF;\r\n}\r\nif (retval != LT_PLAIN && (wascomment || incomment)) {\r\nretval += LT_DODGY;\r\nif (incomment)\r\nlinestate = LS_DIRTY;\r\n}\r\nif (linestate == LS_HASH) {\r\nsize_t len = cp - tline;\r\nif (fgets(tline + len, MAXLINE - len, input) == NULL) {\r\nstrcpy(tline + len, newline);\r\ncp += strlen(newline);\r\nlinestate = LS_START;\r\n} else {\r\nlinestate = LS_DIRTY;\r\n}\r\n}\r\n}\r\nif (linestate == LS_DIRTY) {\r\nwhile (*cp != '\0')\r\ncp = skipcomment(cp + 1);\r\n}\r\ndebug("parser line %d state %s comment %s line", linenum,\r\ncomment_name[incomment], linestate_name[linestate]);\r\nreturn (retval);\r\n}\r\nstatic Linetype op_strict(int *p, int v, Linetype at, Linetype bt) {\r\nif(at == LT_IF || bt == LT_IF) return (LT_IF);\r\nreturn (*p = v, v ? LT_TRUE : LT_FALSE);\r\n}\r\nstatic Linetype op_lt(int *p, Linetype at, int a, Linetype bt, int b) {\r\nreturn op_strict(p, a < b, at, bt);\r\n}\r\nstatic Linetype op_gt(int *p, Linetype at, int a, Linetype bt, int b) {\r\nreturn op_strict(p, a > b, at, bt);\r\n}\r\nstatic Linetype op_le(int *p, Linetype at, int a, Linetype bt, int b) {\r\nreturn op_strict(p, a <= b, at, bt);\r\n}\r\nstatic Linetype op_ge(int *p, Linetype at, int a, Linetype bt, int b) {\r\nreturn op_strict(p, a >= b, at, bt);\r\n}\r\nstatic Linetype op_eq(int *p, Linetype at, int a, Linetype bt, int b) {\r\nreturn op_strict(p, a == b, at, bt);\r\n}\r\nstatic Linetype op_ne(int *p, Linetype at, int a, Linetype bt, int b) {\r\nreturn op_strict(p, a != b, at, bt);\r\n}\r\nstatic Linetype op_or(int *p, Linetype at, int a, Linetype bt, int b) {\r\nif (!strictlogic && (at == LT_TRUE || bt == LT_TRUE))\r\nreturn (*p = 1, LT_TRUE);\r\nreturn op_strict(p, a || b, at, bt);\r\n}\r\nstatic Linetype op_and(int *p, Linetype at, int a, Linetype bt, int b) {\r\nif (!strictlogic && (at == LT_FALSE || bt == LT_FALSE))\r\nreturn (*p = 0, LT_FALSE);\r\nreturn op_strict(p, a && b, at, bt);\r\n}\r\nstatic Linetype\r\neval_unary(const struct ops *ops, int *valp, const char **cpp)\r\n{\r\nconst char *cp;\r\nchar *ep;\r\nint sym;\r\nbool defparen;\r\nLinetype lt;\r\ncp = skipcomment(*cpp);\r\nif (*cp == '!') {\r\ndebug("eval%d !", ops - eval_ops);\r\ncp++;\r\nlt = eval_unary(ops, valp, &cp);\r\nif (lt == LT_ERROR)\r\nreturn (LT_ERROR);\r\nif (lt != LT_IF) {\r\n*valp = !*valp;\r\nlt = *valp ? LT_TRUE : LT_FALSE;\r\n}\r\n} else if (*cp == '(') {\r\ncp++;\r\ndebug("eval%d (", ops - eval_ops);\r\nlt = eval_table(eval_ops, valp, &cp);\r\nif (lt == LT_ERROR)\r\nreturn (LT_ERROR);\r\ncp = skipcomment(cp);\r\nif (*cp++ != ')')\r\nreturn (LT_ERROR);\r\n} else if (isdigit((unsigned char)*cp)) {\r\ndebug("eval%d number", ops - eval_ops);\r\n*valp = strtol(cp, &ep, 0);\r\nif (ep == cp)\r\nreturn (LT_ERROR);\r\nlt = *valp ? LT_TRUE : LT_FALSE;\r\ncp = skipsym(cp);\r\n} else if (strncmp(cp, "defined", 7) == 0 && endsym(cp[7])) {\r\ncp = skipcomment(cp+7);\r\ndebug("eval%d defined", ops - eval_ops);\r\nif (*cp == '(') {\r\ncp = skipcomment(cp+1);\r\ndefparen = true;\r\n} else {\r\ndefparen = false;\r\n}\r\nsym = findsym(cp);\r\nif (sym < 0) {\r\nlt = LT_IF;\r\n} else {\r\n*valp = (value[sym] != NULL);\r\nlt = *valp ? LT_TRUE : LT_FALSE;\r\n}\r\ncp = skipsym(cp);\r\ncp = skipcomment(cp);\r\nif (defparen && *cp++ != ')')\r\nreturn (LT_ERROR);\r\nconstexpr = false;\r\n} else if (!endsym(*cp)) {\r\ndebug("eval%d symbol", ops - eval_ops);\r\nsym = findsym(cp);\r\ncp = skipsym(cp);\r\nif (sym < 0) {\r\nlt = LT_IF;\r\ncp = skipargs(cp);\r\n} else if (value[sym] == NULL) {\r\n*valp = 0;\r\nlt = LT_FALSE;\r\n} else {\r\n*valp = strtol(value[sym], &ep, 0);\r\nif (*ep != '\0' || ep == value[sym])\r\nreturn (LT_ERROR);\r\nlt = *valp ? LT_TRUE : LT_FALSE;\r\ncp = skipargs(cp);\r\n}\r\nconstexpr = false;\r\n} else {\r\ndebug("eval%d bad expr", ops - eval_ops);\r\nreturn (LT_ERROR);\r\n}\r\n*cpp = cp;\r\ndebug("eval%d = %d", ops - eval_ops, *valp);\r\nreturn (lt);\r\n}\r\nstatic Linetype\r\neval_table(const struct ops *ops, int *valp, const char **cpp)\r\n{\r\nconst struct op *op;\r\nconst char *cp;\r\nint val;\r\nLinetype lt, rt;\r\ndebug("eval%d", ops - eval_ops);\r\ncp = *cpp;\r\nlt = ops->inner(ops+1, valp, &cp);\r\nif (lt == LT_ERROR)\r\nreturn (LT_ERROR);\r\nfor (;;) {\r\ncp = skipcomment(cp);\r\nfor (op = ops->op; op->str != NULL; op++)\r\nif (strncmp(cp, op->str, strlen(op->str)) == 0)\r\nbreak;\r\nif (op->str == NULL)\r\nbreak;\r\ncp += strlen(op->str);\r\ndebug("eval%d %s", ops - eval_ops, op->str);\r\nrt = ops->inner(ops+1, &val, &cp);\r\nif (rt == LT_ERROR)\r\nreturn (LT_ERROR);\r\nlt = op->fn(valp, lt, *valp, rt, val);\r\n}\r\n*cpp = cp;\r\ndebug("eval%d = %d", ops - eval_ops, *valp);\r\ndebug("eval%d lt = %s", ops - eval_ops, linetype_name[lt]);\r\nreturn (lt);\r\n}\r\nstatic Linetype\r\nifeval(const char **cpp)\r\n{\r\nint ret;\r\nint val = 0;\r\ndebug("eval %s", *cpp);\r\nconstexpr = killconsts ? false : true;\r\nret = eval_table(eval_ops, &val, cpp);\r\ndebug("eval = %d", val);\r\nreturn (constexpr ? LT_IF : ret == LT_ERROR ? LT_IF : ret);\r\n}\r\nstatic const char *\r\nskipcomment(const char *cp)\r\n{\r\nif (text || ignoring[depth]) {\r\nfor (; isspace((unsigned char)*cp); cp++)\r\nif (*cp == '\n')\r\nlinestate = LS_START;\r\nreturn (cp);\r\n}\r\nwhile (*cp != '\0')\r\nif (strncmp(cp, "\\\r\n", 3) == 0)\r\ncp += 3;\r\nelse if (strncmp(cp, "\\\n", 2) == 0)\r\ncp += 2;\r\nelse switch (incomment) {\r\ncase NO_COMMENT:\r\nif (strncmp(cp, "/\\\r\n", 4) == 0) {\r\nincomment = STARTING_COMMENT;\r\ncp += 4;\r\n} else if (strncmp(cp, "/\\\n", 3) == 0) {\r\nincomment = STARTING_COMMENT;\r\ncp += 3;\r\n} else if (strncmp(cp, "/*", 2) == 0) {\r\nincomment = C_COMMENT;\r\ncp += 2;\r\n} else if (strncmp(cp, "//", 2) == 0) {\r\nincomment = CXX_COMMENT;\r\ncp += 2;\r\n} else if (strncmp(cp, "\'", 1) == 0) {\r\nincomment = CHAR_LITERAL;\r\nlinestate = LS_DIRTY;\r\ncp += 1;\r\n} else if (strncmp(cp, "\"", 1) == 0) {\r\nincomment = STRING_LITERAL;\r\nlinestate = LS_DIRTY;\r\ncp += 1;\r\n} else if (strncmp(cp, "\n", 1) == 0) {\r\nlinestate = LS_START;\r\ncp += 1;\r\n} else if (strchr(" \r\t", *cp) != NULL) {\r\ncp += 1;\r\n} else\r\nreturn (cp);\r\ncontinue;\r\ncase CXX_COMMENT:\r\nif (strncmp(cp, "\n", 1) == 0) {\r\nincomment = NO_COMMENT;\r\nlinestate = LS_START;\r\n}\r\ncp += 1;\r\ncontinue;\r\ncase CHAR_LITERAL:\r\ncase STRING_LITERAL:\r\nif ((incomment == CHAR_LITERAL && cp[0] == '\'') ||\r\n(incomment == STRING_LITERAL && cp[0] == '\"')) {\r\nincomment = NO_COMMENT;\r\ncp += 1;\r\n} else if (cp[0] == '\\') {\r\nif (cp[1] == '\0')\r\ncp += 1;\r\nelse\r\ncp += 2;\r\n} else if (strncmp(cp, "\n", 1) == 0) {\r\nif (incomment == CHAR_LITERAL)\r\nerror("unterminated char literal");\r\nelse\r\nerror("unterminated string literal");\r\n} else\r\ncp += 1;\r\ncontinue;\r\ncase C_COMMENT:\r\nif (strncmp(cp, "*\\\r\n", 4) == 0) {\r\nincomment = FINISHING_COMMENT;\r\ncp += 4;\r\n} else if (strncmp(cp, "*\\\n", 3) == 0) {\r\nincomment = FINISHING_COMMENT;\r\ncp += 3;\r\n} else if (strncmp(cp, "*/", 2) == 0) {\r\nincomment = NO_COMMENT;\r\ncp += 2;\r\n} else\r\ncp += 1;\r\ncontinue;\r\ncase STARTING_COMMENT:\r\nif (*cp == '*') {\r\nincomment = C_COMMENT;\r\ncp += 1;\r\n} else if (*cp == '/') {\r\nincomment = CXX_COMMENT;\r\ncp += 1;\r\n} else {\r\nincomment = NO_COMMENT;\r\nlinestate = LS_DIRTY;\r\n}\r\ncontinue;\r\ncase FINISHING_COMMENT:\r\nif (*cp == '/') {\r\nincomment = NO_COMMENT;\r\ncp += 1;\r\n} else\r\nincomment = C_COMMENT;\r\ncontinue;\r\ndefault:\r\nabort();\r\n}\r\nreturn (cp);\r\n}\r\nstatic const char *\r\nskipargs(const char *cp)\r\n{\r\nconst char *ocp = cp;\r\nint level = 0;\r\ncp = skipcomment(cp);\r\nif (*cp != '(')\r\nreturn (cp);\r\ndo {\r\nif (*cp == '(')\r\nlevel++;\r\nif (*cp == ')')\r\nlevel--;\r\ncp = skipcomment(cp+1);\r\n} while (level != 0 && *cp != '\0');\r\nif (level == 0)\r\nreturn (cp);\r\nelse\r\nreturn (ocp);\r\n}\r\nstatic const char *\r\nskipsym(const char *cp)\r\n{\r\nwhile (!endsym(*cp))\r\n++cp;\r\nreturn (cp);\r\n}\r\nstatic int\r\nfindsym(const char *str)\r\n{\r\nconst char *cp;\r\nint symind;\r\ncp = skipsym(str);\r\nif (cp == str)\r\nreturn (-1);\r\nif (symlist) {\r\nif (symdepth && firstsym)\r\nprintf("%s%3d", zerosyms ? "" : "\n", depth);\r\nfirstsym = zerosyms = false;\r\nprintf("%s%.*s%s",\r\nsymdepth ? " " : "",\r\n(int)(cp-str), str,\r\nsymdepth ? "" : "\n");\r\nreturn (0);\r\n}\r\nfor (symind = 0; symind < nsyms; ++symind) {\r\nif (strlcmp(symname[symind], str, cp-str) == 0) {\r\ndebug("findsym %s %s", symname[symind],\r\nvalue[symind] ? value[symind] : "");\r\nreturn (symind);\r\n}\r\n}\r\nreturn (-1);\r\n}\r\nstatic void\r\naddsym(bool ignorethis, bool definethis, char *sym)\r\n{\r\nint symind;\r\nchar *val;\r\nsymind = findsym(sym);\r\nif (symind < 0) {\r\nif (nsyms >= MAXSYMS)\r\nerrx(2, "too many symbols");\r\nsymind = nsyms++;\r\n}\r\nsymname[symind] = sym;\r\nignore[symind] = ignorethis;\r\nval = sym + (skipsym(sym) - sym);\r\nif (definethis) {\r\nif (*val == '=') {\r\nvalue[symind] = val+1;\r\n*val = '\0';\r\n} else if (*val == '\0')\r\nvalue[symind] = "1";\r\nelse\r\nusage();\r\n} else {\r\nif (*val != '\0')\r\nusage();\r\nvalue[symind] = NULL;\r\n}\r\ndebug("addsym %s=%s", symname[symind],\r\nvalue[symind] ? value[symind] : "undef");\r\n}\r\nstatic int\r\nstrlcmp(const char *s, const char *t, size_t n)\r\n{\r\nwhile (n-- && *t != '\0')\r\nif (*s != *t)\r\nreturn ((unsigned char)*s - (unsigned char)*t);\r\nelse\r\n++s, ++t;\r\nreturn ((unsigned char)*s);\r\n}\r\nstatic void\r\ndebug(const char *msg, ...)\r\n{\r\nva_list ap;\r\nif (debugging) {\r\nva_start(ap, msg);\r\nvwarnx(msg, ap);\r\nva_end(ap);\r\n}\r\n}\r\nstatic void\r\nerror(const char *msg)\r\n{\r\nif (depth == 0)\r\nwarnx("%s: %d: %s", filename, linenum, msg);\r\nelse\r\nwarnx("%s: %d: %s (#if line %d depth %d)",\r\nfilename, linenum, msg, stifline[depth], depth);\r\ncloseout();\r\nerrx(2, "output may be truncated");\r\n}
