static inline uint32_t get_next_dtype(void __iomem *p)\r\n{\r\nuint32_t dtype;\r\ndtype = readl(p);\r\nreturn dtype >> 28;\r\n}\r\nstatic int chameleon_parse_bdd(struct mcb_bus *bus,\r\nphys_addr_t mapbase,\r\nvoid __iomem *base)\r\n{\r\nreturn 0;\r\n}\r\nstatic int chameleon_parse_gdd(struct mcb_bus *bus,\r\nphys_addr_t mapbase,\r\nvoid __iomem *base)\r\n{\r\nstruct chameleon_gdd __iomem *gdd =\r\n(struct chameleon_gdd __iomem *) base;\r\nstruct mcb_device *mdev;\r\nu32 offset;\r\nu32 size;\r\nint ret;\r\n__le32 reg1;\r\n__le32 reg2;\r\nmdev = mcb_alloc_dev(bus);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nreg1 = readl(&gdd->reg1);\r\nreg2 = readl(&gdd->reg2);\r\noffset = readl(&gdd->offset);\r\nsize = readl(&gdd->size);\r\nmdev->id = GDD_DEV(reg1);\r\nmdev->rev = GDD_REV(reg1);\r\nmdev->var = GDD_VAR(reg1);\r\nmdev->bar = GDD_BAR(reg2);\r\nmdev->group = GDD_GRP(reg2);\r\nmdev->inst = GDD_INS(reg2);\r\npr_debug("Found a 16z%03d\n", mdev->id);\r\nmdev->irq.start = GDD_IRQ(reg1);\r\nmdev->irq.end = GDD_IRQ(reg1);\r\nmdev->irq.flags = IORESOURCE_IRQ;\r\nmdev->mem.start = mapbase + offset;\r\nmdev->mem.end = mdev->mem.start + size - 1;\r\nmdev->mem.flags = IORESOURCE_MEM;\r\nmdev->is_added = false;\r\nret = mcb_device_register(bus, mdev);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nmcb_free_dev(mdev);\r\nreturn ret;\r\n}\r\nint chameleon_parse_cells(struct mcb_bus *bus, phys_addr_t mapbase,\r\nvoid __iomem *base)\r\n{\r\nchar __iomem *p = base;\r\nstruct chameleon_fpga_header *header;\r\nuint32_t dtype;\r\nint num_cells = 0;\r\nint ret = 0;\r\nu32 hsize;\r\nhsize = sizeof(struct chameleon_fpga_header);\r\nheader = kzalloc(hsize, GFP_KERNEL);\r\nif (!header)\r\nreturn -ENOMEM;\r\nmemcpy_fromio(header, p, hsize);\r\nheader->magic = le16_to_cpu(header->magic);\r\nif (header->magic != CHAMELEONV2_MAGIC) {\r\npr_err("Unsupported chameleon version 0x%x\n",\r\nheader->magic);\r\nkfree(header);\r\nreturn -ENODEV;\r\n}\r\np += hsize;\r\nbus->revision = header->revision;\r\nbus->model = header->model;\r\nbus->minor = header->minor;\r\nsnprintf(bus->name, CHAMELEON_FILENAME_LEN + 1, "%s",\r\nheader->filename);\r\nfor_each_chameleon_cell(dtype, p) {\r\nswitch (dtype) {\r\ncase CHAMELEON_DTYPE_GENERAL:\r\nret = chameleon_parse_gdd(bus, mapbase, p);\r\nif (ret < 0)\r\ngoto out;\r\np += sizeof(struct chameleon_gdd);\r\nbreak;\r\ncase CHAMELEON_DTYPE_BRIDGE:\r\nchameleon_parse_bdd(bus, mapbase, p);\r\np += sizeof(struct chameleon_bdd);\r\nbreak;\r\ncase CHAMELEON_DTYPE_END:\r\nbreak;\r\ndefault:\r\npr_err("Invalid chameleon descriptor type 0x%x\n",\r\ndtype);\r\nkfree(header);\r\nreturn -EINVAL;\r\n}\r\nnum_cells++;\r\n}\r\nif (num_cells == 0)\r\nnum_cells = -EINVAL;\r\nkfree(header);\r\nreturn num_cells;\r\nout:\r\nkfree(header);\r\nreturn ret;\r\n}
