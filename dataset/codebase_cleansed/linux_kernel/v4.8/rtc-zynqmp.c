static int xlnx_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\r\nunsigned long new_time;\r\nnew_time = rtc_tm_to_time64(tm) + 1;\r\nif (new_time > RTC_SEC_MAX_VAL)\r\nreturn -EINVAL;\r\nxrtcdev->calibval &= RTC_CALIB_MASK;\r\nwritel(xrtcdev->calibval, (xrtcdev->reg_base + RTC_CALIB_WR));\r\nwritel(new_time, xrtcdev->reg_base + RTC_SET_TM_WR);\r\nwritel(RTC_INT_SEC, xrtcdev->reg_base + RTC_INT_STS);\r\nreturn 0;\r\n}\r\nstatic int xlnx_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nu32 status;\r\nunsigned long read_time;\r\nstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\r\nstatus = readl(xrtcdev->reg_base + RTC_INT_STS);\r\nif (status & RTC_INT_SEC) {\r\nrtc_time64_to_tm(readl(xrtcdev->reg_base + RTC_CUR_TM), tm);\r\n} else {\r\nread_time = readl(xrtcdev->reg_base + RTC_SET_TM_RD) - 1;\r\nrtc_time64_to_tm(read_time, tm);\r\n}\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int xlnx_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\r\nrtc_time64_to_tm(readl(xrtcdev->reg_base + RTC_ALRM), &alrm->time);\r\nalrm->enabled = readl(xrtcdev->reg_base + RTC_INT_MASK) & RTC_INT_ALRM;\r\nreturn 0;\r\n}\r\nstatic int xlnx_rtc_alarm_irq_enable(struct device *dev, u32 enabled)\r\n{\r\nstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\r\nif (enabled)\r\nwritel(RTC_INT_ALRM, xrtcdev->reg_base + RTC_INT_EN);\r\nelse\r\nwritel(RTC_INT_ALRM, xrtcdev->reg_base + RTC_INT_DIS);\r\nreturn 0;\r\n}\r\nstatic int xlnx_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\r\nunsigned long alarm_time;\r\nalarm_time = rtc_tm_to_time64(&alrm->time);\r\nif (alarm_time > RTC_SEC_MAX_VAL)\r\nreturn -EINVAL;\r\nwritel((u32)alarm_time, (xrtcdev->reg_base + RTC_ALRM));\r\nxlnx_rtc_alarm_irq_enable(dev, alrm->enabled);\r\nreturn 0;\r\n}\r\nstatic void xlnx_init_rtc(struct xlnx_rtc_dev *xrtcdev)\r\n{\r\nu32 rtc_ctrl;\r\nrtc_ctrl = readl(xrtcdev->reg_base + RTC_CTRL);\r\nrtc_ctrl |= RTC_BATT_EN;\r\nwritel(rtc_ctrl, xrtcdev->reg_base + RTC_CTRL);\r\nxrtcdev->calibval &= RTC_CALIB_MASK;\r\nwritel(xrtcdev->calibval, (xrtcdev->reg_base + RTC_CALIB_WR));\r\n}\r\nstatic irqreturn_t xlnx_rtc_interrupt(int irq, void *id)\r\n{\r\nstruct xlnx_rtc_dev *xrtcdev = (struct xlnx_rtc_dev *)id;\r\nunsigned int status;\r\nstatus = readl(xrtcdev->reg_base + RTC_INT_STS);\r\nif (!(status & (RTC_INT_SEC | RTC_INT_ALRM)))\r\nreturn IRQ_NONE;\r\nwritel(RTC_INT_ALRM, xrtcdev->reg_base + RTC_INT_STS);\r\nif (status & RTC_INT_ALRM)\r\nrtc_update_irq(xrtcdev->rtc, 1, RTC_IRQF | RTC_AF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xlnx_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct xlnx_rtc_dev *xrtcdev;\r\nstruct resource *res;\r\nint ret;\r\nxrtcdev = devm_kzalloc(&pdev->dev, sizeof(*xrtcdev), GFP_KERNEL);\r\nif (!xrtcdev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, xrtcdev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nxrtcdev->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(xrtcdev->reg_base))\r\nreturn PTR_ERR(xrtcdev->reg_base);\r\nxrtcdev->alarm_irq = platform_get_irq_byname(pdev, "alarm");\r\nif (xrtcdev->alarm_irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource\n");\r\nreturn xrtcdev->alarm_irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, xrtcdev->alarm_irq,\r\nxlnx_rtc_interrupt, 0,\r\ndev_name(&pdev->dev), xrtcdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request irq failed\n");\r\nreturn ret;\r\n}\r\nxrtcdev->sec_irq = platform_get_irq_byname(pdev, "sec");\r\nif (xrtcdev->sec_irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource\n");\r\nreturn xrtcdev->sec_irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, xrtcdev->sec_irq,\r\nxlnx_rtc_interrupt, 0,\r\ndev_name(&pdev->dev), xrtcdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request irq failed\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(pdev->dev.of_node, "calibration",\r\n&xrtcdev->calibval);\r\nif (ret)\r\nxrtcdev->calibval = RTC_CALIB_DEF;\r\nxlnx_init_rtc(xrtcdev);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nxrtcdev->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&xlnx_rtc_ops, THIS_MODULE);\r\nreturn PTR_ERR_OR_ZERO(xrtcdev->rtc);\r\n}\r\nstatic int xlnx_rtc_remove(struct platform_device *pdev)\r\n{\r\nxlnx_rtc_alarm_irq_enable(&pdev->dev, 0);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused xlnx_rtc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct xlnx_rtc_dev *xrtcdev = platform_get_drvdata(pdev);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(xrtcdev->alarm_irq);\r\nelse\r\nxlnx_rtc_alarm_irq_enable(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused xlnx_rtc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct xlnx_rtc_dev *xrtcdev = platform_get_drvdata(pdev);\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(xrtcdev->alarm_irq);\r\nelse\r\nxlnx_rtc_alarm_irq_enable(dev, 1);\r\nreturn 0;\r\n}
