static inline u32 vnet_tx_dring_avail(struct vio_dring_state *dr)\r\n{\r\nreturn vio_dring_avail(dr, VNET_TX_RING_SIZE);\r\n}\r\nstatic int vnet_handle_unknown(struct vnet_port *port, void *arg)\r\n{\r\nstruct vio_msg_tag *pkt = arg;\r\npr_err("Received unknown msg [%02x:%02x:%04x:%08x]\n",\r\npkt->type, pkt->stype, pkt->stype_env, pkt->sid);\r\npr_err("Resetting connection\n");\r\nldc_disconnect(port->vio.lp);\r\nreturn -ECONNRESET;\r\n}\r\nint sunvnet_send_attr_common(struct vio_driver_state *vio)\r\n{\r\nstruct vnet_port *port = to_vnet_port(vio);\r\nstruct net_device *dev = VNET_PORT_TO_NET_DEVICE(port);\r\nstruct vio_net_attr_info pkt;\r\nint framelen = ETH_FRAME_LEN;\r\nint i, err;\r\nerr = vnet_port_alloc_tx_ring(to_vnet_port(vio));\r\nif (err)\r\nreturn err;\r\nmemset(&pkt, 0, sizeof(pkt));\r\npkt.tag.type = VIO_TYPE_CTRL;\r\npkt.tag.stype = VIO_SUBTYPE_INFO;\r\npkt.tag.stype_env = VIO_ATTR_INFO;\r\npkt.tag.sid = vio_send_sid(vio);\r\nif (vio_version_before(vio, 1, 2))\r\npkt.xfer_mode = VIO_DRING_MODE;\r\nelse\r\npkt.xfer_mode = VIO_NEW_DRING_MODE;\r\npkt.addr_type = VNET_ADDR_ETHERMAC;\r\npkt.ack_freq = 0;\r\nfor (i = 0; i < 6; i++)\r\npkt.addr |= (u64)dev->dev_addr[i] << ((5 - i) * 8);\r\nif (vio_version_after(vio, 1, 3)) {\r\nif (port->rmtu) {\r\nport->rmtu = min(VNET_MAXPACKET, port->rmtu);\r\npkt.mtu = port->rmtu;\r\n} else {\r\nport->rmtu = VNET_MAXPACKET;\r\npkt.mtu = port->rmtu;\r\n}\r\nif (vio_version_after_eq(vio, 1, 6))\r\npkt.options = VIO_TX_DRING;\r\n} else if (vio_version_before(vio, 1, 3)) {\r\npkt.mtu = framelen;\r\n} else {\r\npkt.mtu = framelen + VLAN_HLEN;\r\n}\r\npkt.cflags = 0;\r\nif (vio_version_after_eq(vio, 1, 7) && port->tso) {\r\npkt.cflags |= VNET_LSO_IPV4_CAPAB;\r\nif (!port->tsolen)\r\nport->tsolen = VNET_MAXTSO;\r\npkt.ipv4_lso_maxlen = port->tsolen;\r\n}\r\npkt.plnk_updt = PHYSLINK_UPDATE_NONE;\r\nviodbg(HS, "SEND NET ATTR xmode[0x%x] atype[0x%x] addr[%llx] "\r\n"ackfreq[%u] plnk_updt[0x%02x] opts[0x%02x] mtu[%llu] "\r\n"cflags[0x%04x] lso_max[%u]\n",\r\npkt.xfer_mode, pkt.addr_type,\r\n(unsigned long long)pkt.addr,\r\npkt.ack_freq, pkt.plnk_updt, pkt.options,\r\n(unsigned long long)pkt.mtu, pkt.cflags, pkt.ipv4_lso_maxlen);\r\nreturn vio_ldc_send(vio, &pkt, sizeof(pkt));\r\n}\r\nstatic int handle_attr_info(struct vio_driver_state *vio,\r\nstruct vio_net_attr_info *pkt)\r\n{\r\nstruct vnet_port *port = to_vnet_port(vio);\r\nu64 localmtu;\r\nu8 xfer_mode;\r\nviodbg(HS, "GOT NET ATTR xmode[0x%x] atype[0x%x] addr[%llx] "\r\n"ackfreq[%u] plnk_updt[0x%02x] opts[0x%02x] mtu[%llu] "\r\n" (rmtu[%llu]) cflags[0x%04x] lso_max[%u]\n",\r\npkt->xfer_mode, pkt->addr_type,\r\n(unsigned long long)pkt->addr,\r\npkt->ack_freq, pkt->plnk_updt, pkt->options,\r\n(unsigned long long)pkt->mtu, port->rmtu, pkt->cflags,\r\npkt->ipv4_lso_maxlen);\r\npkt->tag.sid = vio_send_sid(vio);\r\nxfer_mode = pkt->xfer_mode;\r\nif (vio_version_before(vio, 1, 2) && xfer_mode == VIO_DRING_MODE)\r\nxfer_mode = VIO_NEW_DRING_MODE;\r\nif (vio_version_before(vio, 1, 3)) {\r\nlocalmtu = ETH_FRAME_LEN;\r\n} else if (vio_version_after(vio, 1, 3)) {\r\nlocalmtu = port->rmtu ? port->rmtu : VNET_MAXPACKET;\r\nlocalmtu = min(pkt->mtu, localmtu);\r\npkt->mtu = localmtu;\r\n} else {\r\nlocalmtu = ETH_FRAME_LEN + VLAN_HLEN;\r\n}\r\nport->rmtu = localmtu;\r\nif (vio_version_after_eq(vio, 1, 7))\r\nport->tso &= !!(pkt->cflags & VNET_LSO_IPV4_CAPAB);\r\nelse\r\nport->tso = false;\r\nif (port->tso) {\r\nif (!port->tsolen)\r\nport->tsolen = VNET_MAXTSO;\r\nport->tsolen = min(port->tsolen, pkt->ipv4_lso_maxlen);\r\nif (port->tsolen < VNET_MINTSO) {\r\nport->tso = false;\r\nport->tsolen = 0;\r\npkt->cflags &= ~VNET_LSO_IPV4_CAPAB;\r\n}\r\npkt->ipv4_lso_maxlen = port->tsolen;\r\n} else {\r\npkt->cflags &= ~VNET_LSO_IPV4_CAPAB;\r\npkt->ipv4_lso_maxlen = 0;\r\n}\r\nif (vio_version_after_eq(vio, 1, 6)) {\r\npkt->xfer_mode = VIO_NEW_DRING_MODE;\r\npkt->options = VIO_TX_DRING;\r\n}\r\nif (!(xfer_mode | VIO_NEW_DRING_MODE) ||\r\npkt->addr_type != VNET_ADDR_ETHERMAC ||\r\npkt->mtu != localmtu) {\r\nviodbg(HS, "SEND NET ATTR NACK\n");\r\npkt->tag.stype = VIO_SUBTYPE_NACK;\r\n(void)vio_ldc_send(vio, pkt, sizeof(*pkt));\r\nreturn -ECONNRESET;\r\n}\r\nviodbg(HS, "SEND NET ATTR ACK xmode[0x%x] atype[0x%x] "\r\n"addr[%llx] ackfreq[%u] plnk_updt[0x%02x] opts[0x%02x] "\r\n"mtu[%llu] (rmtu[%llu]) cflags[0x%04x] lso_max[%u]\n",\r\npkt->xfer_mode, pkt->addr_type,\r\n(unsigned long long)pkt->addr,\r\npkt->ack_freq, pkt->plnk_updt, pkt->options,\r\n(unsigned long long)pkt->mtu, port->rmtu, pkt->cflags,\r\npkt->ipv4_lso_maxlen);\r\npkt->tag.stype = VIO_SUBTYPE_ACK;\r\nreturn vio_ldc_send(vio, pkt, sizeof(*pkt));\r\n}\r\nstatic int handle_attr_ack(struct vio_driver_state *vio,\r\nstruct vio_net_attr_info *pkt)\r\n{\r\nviodbg(HS, "GOT NET ATTR ACK\n");\r\nreturn 0;\r\n}\r\nstatic int handle_attr_nack(struct vio_driver_state *vio,\r\nstruct vio_net_attr_info *pkt)\r\n{\r\nviodbg(HS, "GOT NET ATTR NACK\n");\r\nreturn -ECONNRESET;\r\n}\r\nint sunvnet_handle_attr_common(struct vio_driver_state *vio, void *arg)\r\n{\r\nstruct vio_net_attr_info *pkt = arg;\r\nswitch (pkt->tag.stype) {\r\ncase VIO_SUBTYPE_INFO:\r\nreturn handle_attr_info(vio, pkt);\r\ncase VIO_SUBTYPE_ACK:\r\nreturn handle_attr_ack(vio, pkt);\r\ncase VIO_SUBTYPE_NACK:\r\nreturn handle_attr_nack(vio, pkt);\r\ndefault:\r\nreturn -ECONNRESET;\r\n}\r\n}\r\nvoid sunvnet_handshake_complete_common(struct vio_driver_state *vio)\r\n{\r\nstruct vio_dring_state *dr;\r\ndr = &vio->drings[VIO_DRIVER_RX_RING];\r\ndr->rcv_nxt = 1;\r\ndr->snd_nxt = 1;\r\ndr = &vio->drings[VIO_DRIVER_TX_RING];\r\ndr->rcv_nxt = 1;\r\ndr->snd_nxt = 1;\r\n}\r\nstatic struct sk_buff *alloc_and_align_skb(struct net_device *dev,\r\nunsigned int len)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long addr, off;\r\nskb = netdev_alloc_skb(dev, len + VNET_PACKET_SKIP + 8 + 8);\r\nif (unlikely(!skb))\r\nreturn NULL;\r\naddr = (unsigned long)skb->data;\r\noff = ((addr + 7UL) & ~7UL) - addr;\r\nif (off)\r\nskb_reserve(skb, off);\r\nreturn skb;\r\n}\r\nstatic inline void vnet_fullcsum(struct sk_buff *skb)\r\n{\r\nstruct iphdr *iph = ip_hdr(skb);\r\nint offset = skb_transport_offset(skb);\r\nif (skb->protocol != htons(ETH_P_IP))\r\nreturn;\r\nif (iph->protocol != IPPROTO_TCP &&\r\niph->protocol != IPPROTO_UDP)\r\nreturn;\r\nskb->ip_summed = CHECKSUM_NONE;\r\nskb->csum_level = 1;\r\nskb->csum = 0;\r\nif (iph->protocol == IPPROTO_TCP) {\r\nstruct tcphdr *ptcp = tcp_hdr(skb);\r\nptcp->check = 0;\r\nskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\r\nptcp->check = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\nskb->len - offset, IPPROTO_TCP,\r\nskb->csum);\r\n} else if (iph->protocol == IPPROTO_UDP) {\r\nstruct udphdr *pudp = udp_hdr(skb);\r\npudp->check = 0;\r\nskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\r\npudp->check = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\nskb->len - offset, IPPROTO_UDP,\r\nskb->csum);\r\n}\r\n}\r\nstatic int vnet_rx_one(struct vnet_port *port, struct vio_net_desc *desc)\r\n{\r\nstruct net_device *dev = VNET_PORT_TO_NET_DEVICE(port);\r\nunsigned int len = desc->size;\r\nunsigned int copy_len;\r\nstruct sk_buff *skb;\r\nint maxlen;\r\nint err;\r\nerr = -EMSGSIZE;\r\nif (port->tso && port->tsolen > port->rmtu)\r\nmaxlen = port->tsolen;\r\nelse\r\nmaxlen = port->rmtu;\r\nif (unlikely(len < ETH_ZLEN || len > maxlen)) {\r\ndev->stats.rx_length_errors++;\r\ngoto out_dropped;\r\n}\r\nskb = alloc_and_align_skb(dev, len);\r\nerr = -ENOMEM;\r\nif (unlikely(!skb)) {\r\ndev->stats.rx_missed_errors++;\r\ngoto out_dropped;\r\n}\r\ncopy_len = (len + VNET_PACKET_SKIP + 7U) & ~7U;\r\nskb_put(skb, copy_len);\r\nerr = ldc_copy(port->vio.lp, LDC_COPY_IN,\r\nskb->data, copy_len, 0,\r\ndesc->cookies, desc->ncookies);\r\nif (unlikely(err < 0)) {\r\ndev->stats.rx_frame_errors++;\r\ngoto out_free_skb;\r\n}\r\nskb_pull(skb, VNET_PACKET_SKIP);\r\nskb_trim(skb, len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nif (vio_version_after_eq(&port->vio, 1, 8)) {\r\nstruct vio_net_dext *dext = vio_net_ext(desc);\r\nskb_reset_network_header(skb);\r\nif (dext->flags & VNET_PKT_HCK_IPV4_HDRCKSUM) {\r\nif (skb->protocol == ETH_P_IP) {\r\nstruct iphdr *iph = ip_hdr(skb);\r\niph->check = 0;\r\nip_send_check(iph);\r\n}\r\n}\r\nif ((dext->flags & VNET_PKT_HCK_FULLCKSUM) &&\r\nskb->ip_summed == CHECKSUM_NONE) {\r\nif (skb->protocol == htons(ETH_P_IP)) {\r\nstruct iphdr *iph = ip_hdr(skb);\r\nint ihl = iph->ihl * 4;\r\nskb_reset_transport_header(skb);\r\nskb_set_transport_header(skb, ihl);\r\nvnet_fullcsum(skb);\r\n}\r\n}\r\nif (dext->flags & VNET_PKT_HCK_IPV4_HDRCKSUM_OK) {\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb->csum_level = 0;\r\nif (dext->flags & VNET_PKT_HCK_FULLCKSUM_OK)\r\nskb->csum_level = 1;\r\n}\r\n}\r\nskb->ip_summed = port->switch_port ? CHECKSUM_NONE : CHECKSUM_PARTIAL;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nnapi_gro_receive(&port->napi, skb);\r\nreturn 0;\r\nout_free_skb:\r\nkfree_skb(skb);\r\nout_dropped:\r\ndev->stats.rx_dropped++;\r\nreturn err;\r\n}\r\nstatic int vnet_send_ack(struct vnet_port *port, struct vio_dring_state *dr,\r\nu32 start, u32 end, u8 vio_dring_state)\r\n{\r\nstruct vio_dring_data hdr = {\r\n.tag = {\r\n.type = VIO_TYPE_DATA,\r\n.stype = VIO_SUBTYPE_ACK,\r\n.stype_env = VIO_DRING_DATA,\r\n.sid = vio_send_sid(&port->vio),\r\n},\r\n.dring_ident = dr->ident,\r\n.start_idx = start,\r\n.end_idx = end,\r\n.state = vio_dring_state,\r\n};\r\nint err, delay;\r\nint retries = 0;\r\nhdr.seq = dr->snd_nxt;\r\ndelay = 1;\r\ndo {\r\nerr = vio_ldc_send(&port->vio, &hdr, sizeof(hdr));\r\nif (err > 0) {\r\ndr->snd_nxt++;\r\nbreak;\r\n}\r\nudelay(delay);\r\nif ((delay <<= 1) > 128)\r\ndelay = 128;\r\nif (retries++ > VNET_MAX_RETRIES) {\r\npr_info("ECONNRESET %x:%x:%x:%x:%x:%x\n",\r\nport->raddr[0], port->raddr[1],\r\nport->raddr[2], port->raddr[3],\r\nport->raddr[4], port->raddr[5]);\r\nbreak;\r\n}\r\n} while (err == -EAGAIN);\r\nif (err <= 0 && vio_dring_state == VIO_DRING_STOPPED) {\r\nport->stop_rx_idx = end;\r\nport->stop_rx = true;\r\n} else {\r\nport->stop_rx_idx = 0;\r\nport->stop_rx = false;\r\n}\r\nreturn err;\r\n}\r\nstatic struct vio_net_desc *get_rx_desc(struct vnet_port *port,\r\nstruct vio_dring_state *dr,\r\nu32 index)\r\n{\r\nstruct vio_net_desc *desc = port->vio.desc_buf;\r\nint err;\r\nerr = ldc_get_dring_entry(port->vio.lp, desc, dr->entry_size,\r\n(index * dr->entry_size),\r\ndr->cookies, dr->ncookies);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nreturn desc;\r\n}\r\nstatic int put_rx_desc(struct vnet_port *port,\r\nstruct vio_dring_state *dr,\r\nstruct vio_net_desc *desc,\r\nu32 index)\r\n{\r\nint err;\r\nerr = ldc_put_dring_entry(port->vio.lp, desc, dr->entry_size,\r\n(index * dr->entry_size),\r\ndr->cookies, dr->ncookies);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int vnet_walk_rx_one(struct vnet_port *port,\r\nstruct vio_dring_state *dr,\r\nu32 index, int *needs_ack)\r\n{\r\nstruct vio_net_desc *desc = get_rx_desc(port, dr, index);\r\nstruct vio_driver_state *vio = &port->vio;\r\nint err;\r\nBUG_ON(!desc);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\nif (desc->hdr.state != VIO_DESC_READY)\r\nreturn 1;\r\ndma_rmb();\r\nviodbg(DATA, "vio_walk_rx_one desc[%02x:%02x:%08x:%08x:%llx:%llx]\n",\r\ndesc->hdr.state, desc->hdr.ack,\r\ndesc->size, desc->ncookies,\r\ndesc->cookies[0].cookie_addr,\r\ndesc->cookies[0].cookie_size);\r\nerr = vnet_rx_one(port, desc);\r\nif (err == -ECONNRESET)\r\nreturn err;\r\ntrace_vnet_rx_one(port->vio._local_sid, port->vio._peer_sid,\r\nindex, desc->hdr.ack);\r\ndesc->hdr.state = VIO_DESC_DONE;\r\nerr = put_rx_desc(port, dr, desc, index);\r\nif (err < 0)\r\nreturn err;\r\n*needs_ack = desc->hdr.ack;\r\nreturn 0;\r\n}\r\nstatic int vnet_walk_rx(struct vnet_port *port, struct vio_dring_state *dr,\r\nu32 start, u32 end, int *npkts, int budget)\r\n{\r\nstruct vio_driver_state *vio = &port->vio;\r\nint ack_start = -1, ack_end = -1;\r\nbool send_ack = true;\r\nend = (end == (u32)-1) ? vio_dring_prev(dr, start)\r\n: vio_dring_next(dr, end);\r\nviodbg(DATA, "vnet_walk_rx start[%08x] end[%08x]\n", start, end);\r\nwhile (start != end) {\r\nint ack = 0, err = vnet_walk_rx_one(port, dr, start, &ack);\r\nif (err == -ECONNRESET)\r\nreturn err;\r\nif (err != 0)\r\nbreak;\r\n(*npkts)++;\r\nif (ack_start == -1)\r\nack_start = start;\r\nack_end = start;\r\nstart = vio_dring_next(dr, start);\r\nif (ack && start != end) {\r\nerr = vnet_send_ack(port, dr, ack_start, ack_end,\r\nVIO_DRING_ACTIVE);\r\nif (err == -ECONNRESET)\r\nreturn err;\r\nack_start = -1;\r\n}\r\nif ((*npkts) >= budget) {\r\nsend_ack = false;\r\nbreak;\r\n}\r\n}\r\nif (unlikely(ack_start == -1)) {\r\nack_end = vio_dring_prev(dr, start);\r\nack_start = ack_end;\r\n}\r\nif (send_ack) {\r\nport->napi_resume = false;\r\ntrace_vnet_tx_send_stopped_ack(port->vio._local_sid,\r\nport->vio._peer_sid,\r\nack_end, *npkts);\r\nreturn vnet_send_ack(port, dr, ack_start, ack_end,\r\nVIO_DRING_STOPPED);\r\n} else {\r\ntrace_vnet_tx_defer_stopped_ack(port->vio._local_sid,\r\nport->vio._peer_sid,\r\nack_end, *npkts);\r\nport->napi_resume = true;\r\nport->napi_stop_idx = ack_end;\r\nreturn 1;\r\n}\r\n}\r\nstatic int vnet_rx(struct vnet_port *port, void *msgbuf, int *npkts,\r\nint budget)\r\n{\r\nstruct vio_dring_data *pkt = msgbuf;\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_RX_RING];\r\nstruct vio_driver_state *vio = &port->vio;\r\nviodbg(DATA, "vnet_rx stype_env[%04x] seq[%016llx] rcv_nxt[%016llx]\n",\r\npkt->tag.stype_env, pkt->seq, dr->rcv_nxt);\r\nif (unlikely(pkt->tag.stype_env != VIO_DRING_DATA))\r\nreturn 0;\r\nif (unlikely(pkt->seq != dr->rcv_nxt)) {\r\npr_err("RX out of sequence seq[0x%llx] rcv_nxt[0x%llx]\n",\r\npkt->seq, dr->rcv_nxt);\r\nreturn 0;\r\n}\r\nif (!port->napi_resume)\r\ndr->rcv_nxt++;\r\nreturn vnet_walk_rx(port, dr, pkt->start_idx, pkt->end_idx,\r\nnpkts, budget);\r\n}\r\nstatic int idx_is_pending(struct vio_dring_state *dr, u32 end)\r\n{\r\nu32 idx = dr->cons;\r\nint found = 0;\r\nwhile (idx != dr->prod) {\r\nif (idx == end) {\r\nfound = 1;\r\nbreak;\r\n}\r\nidx = vio_dring_next(dr, idx);\r\n}\r\nreturn found;\r\n}\r\nstatic int vnet_ack(struct vnet_port *port, void *msgbuf)\r\n{\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nstruct vio_dring_data *pkt = msgbuf;\r\nstruct net_device *dev;\r\nu32 end;\r\nstruct vio_net_desc *desc;\r\nstruct netdev_queue *txq;\r\nif (unlikely(pkt->tag.stype_env != VIO_DRING_DATA))\r\nreturn 0;\r\nend = pkt->end_idx;\r\ndev = VNET_PORT_TO_NET_DEVICE(port);\r\nnetif_tx_lock(dev);\r\nif (unlikely(!idx_is_pending(dr, end))) {\r\nnetif_tx_unlock(dev);\r\nreturn 0;\r\n}\r\ntrace_vnet_rx_stopped_ack(port->vio._local_sid,\r\nport->vio._peer_sid, end);\r\ndr->cons = vio_dring_next(dr, end);\r\ndesc = vio_dring_entry(dr, dr->cons);\r\nif (desc->hdr.state == VIO_DESC_READY && !port->start_cons) {\r\nif (__vnet_tx_trigger(port, dr->cons) > 0)\r\nport->start_cons = false;\r\nelse\r\nport->start_cons = true;\r\n} else {\r\nport->start_cons = true;\r\n}\r\nnetif_tx_unlock(dev);\r\ntxq = netdev_get_tx_queue(dev, port->q_index);\r\nif (unlikely(netif_tx_queue_stopped(txq) &&\r\nvnet_tx_dring_avail(dr) >= VNET_TX_WAKEUP_THRESH(dr)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int vnet_nack(struct vnet_port *port, void *msgbuf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int handle_mcast(struct vnet_port *port, void *msgbuf)\r\n{\r\nstruct vio_net_mcast_info *pkt = msgbuf;\r\nstruct net_device *dev = VNET_PORT_TO_NET_DEVICE(port);\r\nif (pkt->tag.stype != VIO_SUBTYPE_ACK)\r\npr_err("%s: Got unexpected MCAST reply [%02x:%02x:%04x:%08x]\n",\r\ndev->name,\r\npkt->tag.type,\r\npkt->tag.stype,\r\npkt->tag.stype_env,\r\npkt->tag.sid);\r\nreturn 0;\r\n}\r\nstatic void maybe_tx_wakeup(struct vnet_port *port)\r\n{\r\nstruct netdev_queue *txq;\r\ntxq = netdev_get_tx_queue(VNET_PORT_TO_NET_DEVICE(port),\r\nport->q_index);\r\n__netif_tx_lock(txq, smp_processor_id());\r\nif (likely(netif_tx_queue_stopped(txq))) {\r\nstruct vio_dring_state *dr;\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nnetif_tx_wake_queue(txq);\r\n}\r\n__netif_tx_unlock(txq);\r\n}\r\nbool sunvnet_port_is_up_common(struct vnet_port *vnet)\r\n{\r\nstruct vio_driver_state *vio = &vnet->vio;\r\nreturn !!(vio->hs_state & VIO_HS_COMPLETE);\r\n}\r\nstatic int vnet_event_napi(struct vnet_port *port, int budget)\r\n{\r\nstruct vio_driver_state *vio = &port->vio;\r\nint tx_wakeup, err;\r\nint npkts = 0;\r\nint event = (port->rx_event & LDC_EVENT_RESET);\r\nldc_ctrl:\r\nif (unlikely(event == LDC_EVENT_RESET ||\r\nevent == LDC_EVENT_UP)) {\r\nvio_link_state_change(vio, event);\r\nif (event == LDC_EVENT_RESET) {\r\nvnet_port_reset(port);\r\nvio_port_up(vio);\r\n}\r\nport->rx_event = 0;\r\nreturn 0;\r\n}\r\nevent = (port->rx_event & LDC_EVENT_UP);\r\nport->rx_event &= ~(LDC_EVENT_RESET | LDC_EVENT_UP);\r\nif (event == LDC_EVENT_UP)\r\ngoto ldc_ctrl;\r\nevent = port->rx_event;\r\nif (!(event & LDC_EVENT_DATA_READY))\r\nreturn 0;\r\nBUG_ON(event != LDC_EVENT_DATA_READY);\r\nerr = 0;\r\ntx_wakeup = 0;\r\nwhile (1) {\r\nunion {\r\nstruct vio_msg_tag tag;\r\nu64 raw[8];\r\n} msgbuf;\r\nif (port->napi_resume) {\r\nstruct vio_dring_data *pkt =\r\n(struct vio_dring_data *)&msgbuf;\r\nstruct vio_dring_state *dr =\r\n&port->vio.drings[VIO_DRIVER_RX_RING];\r\npkt->tag.type = VIO_TYPE_DATA;\r\npkt->tag.stype = VIO_SUBTYPE_INFO;\r\npkt->tag.stype_env = VIO_DRING_DATA;\r\npkt->seq = dr->rcv_nxt;\r\npkt->start_idx = vio_dring_next(dr,\r\nport->napi_stop_idx);\r\npkt->end_idx = -1;\r\ngoto napi_resume;\r\n}\r\nerr = ldc_read(vio->lp, &msgbuf, sizeof(msgbuf));\r\nif (unlikely(err < 0)) {\r\nif (err == -ECONNRESET)\r\nvio_conn_reset(vio);\r\nbreak;\r\n}\r\nif (err == 0)\r\nbreak;\r\nviodbg(DATA, "TAG [%02x:%02x:%04x:%08x]\n",\r\nmsgbuf.tag.type,\r\nmsgbuf.tag.stype,\r\nmsgbuf.tag.stype_env,\r\nmsgbuf.tag.sid);\r\nerr = vio_validate_sid(vio, &msgbuf.tag);\r\nif (err < 0)\r\nbreak;\r\nnapi_resume:\r\nif (likely(msgbuf.tag.type == VIO_TYPE_DATA)) {\r\nif (msgbuf.tag.stype == VIO_SUBTYPE_INFO) {\r\nif (!sunvnet_port_is_up_common(port)) {\r\nerr = -ECONNRESET;\r\nbreak;\r\n}\r\nerr = vnet_rx(port, &msgbuf, &npkts, budget);\r\nif (npkts >= budget)\r\nbreak;\r\nif (npkts == 0)\r\nbreak;\r\n} else if (msgbuf.tag.stype == VIO_SUBTYPE_ACK) {\r\nerr = vnet_ack(port, &msgbuf);\r\nif (err > 0)\r\ntx_wakeup |= err;\r\n} else if (msgbuf.tag.stype == VIO_SUBTYPE_NACK) {\r\nerr = vnet_nack(port, &msgbuf);\r\n}\r\n} else if (msgbuf.tag.type == VIO_TYPE_CTRL) {\r\nif (msgbuf.tag.stype_env == VNET_MCAST_INFO)\r\nerr = handle_mcast(port, &msgbuf);\r\nelse\r\nerr = vio_control_pkt_engine(vio, &msgbuf);\r\nif (err)\r\nbreak;\r\n} else {\r\nerr = vnet_handle_unknown(port, &msgbuf);\r\n}\r\nif (err == -ECONNRESET)\r\nbreak;\r\n}\r\nif (unlikely(tx_wakeup && err != -ECONNRESET))\r\nmaybe_tx_wakeup(port);\r\nreturn npkts;\r\n}\r\nint sunvnet_poll_common(struct napi_struct *napi, int budget)\r\n{\r\nstruct vnet_port *port = container_of(napi, struct vnet_port, napi);\r\nstruct vio_driver_state *vio = &port->vio;\r\nint processed = vnet_event_napi(port, budget);\r\nif (processed < budget) {\r\nnapi_complete(napi);\r\nport->rx_event &= ~LDC_EVENT_DATA_READY;\r\nvio_set_intr(vio->vdev->rx_ino, HV_INTR_ENABLED);\r\n}\r\nreturn processed;\r\n}\r\nvoid sunvnet_event_common(void *arg, int event)\r\n{\r\nstruct vnet_port *port = arg;\r\nstruct vio_driver_state *vio = &port->vio;\r\nport->rx_event |= event;\r\nvio_set_intr(vio->vdev->rx_ino, HV_INTR_DISABLED);\r\nnapi_schedule(&port->napi);\r\n}\r\nstatic int __vnet_tx_trigger(struct vnet_port *port, u32 start)\r\n{\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nstruct vio_dring_data hdr = {\r\n.tag = {\r\n.type = VIO_TYPE_DATA,\r\n.stype = VIO_SUBTYPE_INFO,\r\n.stype_env = VIO_DRING_DATA,\r\n.sid = vio_send_sid(&port->vio),\r\n},\r\n.dring_ident = dr->ident,\r\n.start_idx = start,\r\n.end_idx = (u32)-1,\r\n};\r\nint err, delay;\r\nint retries = 0;\r\nif (port->stop_rx) {\r\ntrace_vnet_tx_pending_stopped_ack(port->vio._local_sid,\r\nport->vio._peer_sid,\r\nport->stop_rx_idx, -1);\r\nerr = vnet_send_ack(port,\r\n&port->vio.drings[VIO_DRIVER_RX_RING],\r\nport->stop_rx_idx, -1,\r\nVIO_DRING_STOPPED);\r\nif (err <= 0)\r\nreturn err;\r\n}\r\nhdr.seq = dr->snd_nxt;\r\ndelay = 1;\r\ndo {\r\nerr = vio_ldc_send(&port->vio, &hdr, sizeof(hdr));\r\nif (err > 0) {\r\ndr->snd_nxt++;\r\nbreak;\r\n}\r\nudelay(delay);\r\nif ((delay <<= 1) > 128)\r\ndelay = 128;\r\nif (retries++ > VNET_MAX_RETRIES)\r\nbreak;\r\n} while (err == -EAGAIN);\r\ntrace_vnet_tx_trigger(port->vio._local_sid,\r\nport->vio._peer_sid, start, err);\r\nreturn err;\r\n}\r\nstatic struct sk_buff *vnet_clean_tx_ring(struct vnet_port *port,\r\nunsigned *pending)\r\n{\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nstruct sk_buff *skb = NULL;\r\nint i, txi;\r\n*pending = 0;\r\ntxi = dr->prod;\r\nfor (i = 0; i < VNET_TX_RING_SIZE; ++i) {\r\nstruct vio_net_desc *d;\r\n--txi;\r\nif (txi < 0)\r\ntxi = VNET_TX_RING_SIZE - 1;\r\nd = vio_dring_entry(dr, txi);\r\nif (d->hdr.state == VIO_DESC_READY) {\r\n(*pending)++;\r\ncontinue;\r\n}\r\nif (port->tx_bufs[txi].skb) {\r\nif (d->hdr.state != VIO_DESC_DONE)\r\npr_notice("invalid ring buffer state %d\n",\r\nd->hdr.state);\r\nBUG_ON(port->tx_bufs[txi].skb->next);\r\nport->tx_bufs[txi].skb->next = skb;\r\nskb = port->tx_bufs[txi].skb;\r\nport->tx_bufs[txi].skb = NULL;\r\nldc_unmap(port->vio.lp,\r\nport->tx_bufs[txi].cookies,\r\nport->tx_bufs[txi].ncookies);\r\n} else if (d->hdr.state == VIO_DESC_FREE) {\r\nbreak;\r\n}\r\nd->hdr.state = VIO_DESC_FREE;\r\n}\r\nreturn skb;\r\n}\r\nstatic inline void vnet_free_skbs(struct sk_buff *skb)\r\n{\r\nstruct sk_buff *next;\r\nwhile (skb) {\r\nnext = skb->next;\r\nskb->next = NULL;\r\ndev_kfree_skb(skb);\r\nskb = next;\r\n}\r\n}\r\nvoid sunvnet_clean_timer_expire_common(unsigned long port0)\r\n{\r\nstruct vnet_port *port = (struct vnet_port *)port0;\r\nstruct sk_buff *freeskbs;\r\nunsigned pending;\r\nnetif_tx_lock(VNET_PORT_TO_NET_DEVICE(port));\r\nfreeskbs = vnet_clean_tx_ring(port, &pending);\r\nnetif_tx_unlock(VNET_PORT_TO_NET_DEVICE(port));\r\nvnet_free_skbs(freeskbs);\r\nif (pending)\r\n(void)mod_timer(&port->clean_timer,\r\njiffies + VNET_CLEAN_TIMEOUT);\r\nelse\r\ndel_timer(&port->clean_timer);\r\n}\r\nstatic inline int vnet_skb_map(struct ldc_channel *lp, struct sk_buff *skb,\r\nstruct ldc_trans_cookie *cookies, int ncookies,\r\nunsigned int map_perm)\r\n{\r\nint i, nc, err, blen;\r\nblen = skb_headlen(skb);\r\nif (blen < ETH_ZLEN)\r\nblen = ETH_ZLEN;\r\nblen += VNET_PACKET_SKIP;\r\nblen += 8 - (blen & 7);\r\nerr = ldc_map_single(lp, skb->data - VNET_PACKET_SKIP, blen, cookies,\r\nncookies, map_perm);\r\nif (err < 0)\r\nreturn err;\r\nnc = err;\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nskb_frag_t *f = &skb_shinfo(skb)->frags[i];\r\nu8 *vaddr;\r\nif (nc < ncookies) {\r\nvaddr = kmap_atomic(skb_frag_page(f));\r\nblen = skb_frag_size(f);\r\nblen += 8 - (blen & 7);\r\nerr = ldc_map_single(lp, vaddr + f->page_offset,\r\nblen, cookies + nc, ncookies - nc,\r\nmap_perm);\r\nkunmap_atomic(vaddr);\r\n} else {\r\nerr = -EMSGSIZE;\r\n}\r\nif (err < 0) {\r\nldc_unmap(lp, cookies, nc);\r\nreturn err;\r\n}\r\nnc += err;\r\n}\r\nreturn nc;\r\n}\r\nstatic inline struct sk_buff *vnet_skb_shape(struct sk_buff *skb, int ncookies)\r\n{\r\nstruct sk_buff *nskb;\r\nint i, len, pad, docopy;\r\nlen = skb->len;\r\npad = 0;\r\nif (len < ETH_ZLEN) {\r\npad += ETH_ZLEN - skb->len;\r\nlen += pad;\r\n}\r\nlen += VNET_PACKET_SKIP;\r\npad += 8 - (len & 7);\r\ndocopy = skb_shinfo(skb)->nr_frags >= ncookies;\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nskb_frag_t *f = &skb_shinfo(skb)->frags[i];\r\ndocopy |= f->page_offset & 7;\r\n}\r\nif (((unsigned long)skb->data & 7) != VNET_PACKET_SKIP ||\r\nskb_tailroom(skb) < pad ||\r\nskb_headroom(skb) < VNET_PACKET_SKIP || docopy) {\r\nint start = 0, offset;\r\n__wsum csum;\r\nlen = skb->len > ETH_ZLEN ? skb->len : ETH_ZLEN;\r\nnskb = alloc_and_align_skb(skb->dev, len);\r\nif (!nskb) {\r\ndev_kfree_skb(skb);\r\nreturn NULL;\r\n}\r\nskb_reserve(nskb, VNET_PACKET_SKIP);\r\nnskb->protocol = skb->protocol;\r\noffset = skb_mac_header(skb) - skb->data;\r\nskb_set_mac_header(nskb, offset);\r\noffset = skb_network_header(skb) - skb->data;\r\nskb_set_network_header(nskb, offset);\r\noffset = skb_transport_header(skb) - skb->data;\r\nskb_set_transport_header(nskb, offset);\r\noffset = 0;\r\nnskb->csum_offset = skb->csum_offset;\r\nnskb->ip_summed = skb->ip_summed;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nstart = skb_checksum_start_offset(skb);\r\nif (start) {\r\nstruct iphdr *iph = ip_hdr(nskb);\r\nint offset = start + nskb->csum_offset;\r\nif (skb_copy_bits(skb, 0, nskb->data, start)) {\r\ndev_kfree_skb(nskb);\r\ndev_kfree_skb(skb);\r\nreturn NULL;\r\n}\r\n*(__sum16 *)(skb->data + offset) = 0;\r\ncsum = skb_copy_and_csum_bits(skb, start,\r\nnskb->data + start,\r\nskb->len - start, 0);\r\nif (iph->protocol == IPPROTO_TCP ||\r\niph->protocol == IPPROTO_UDP) {\r\ncsum = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\nskb->len - start,\r\niph->protocol, csum);\r\n}\r\n*(__sum16 *)(nskb->data + offset) = csum;\r\nnskb->ip_summed = CHECKSUM_NONE;\r\n} else if (skb_copy_bits(skb, 0, nskb->data, skb->len)) {\r\ndev_kfree_skb(nskb);\r\ndev_kfree_skb(skb);\r\nreturn NULL;\r\n}\r\n(void)skb_put(nskb, skb->len);\r\nif (skb_is_gso(skb)) {\r\nskb_shinfo(nskb)->gso_size = skb_shinfo(skb)->gso_size;\r\nskb_shinfo(nskb)->gso_type = skb_shinfo(skb)->gso_type;\r\n}\r\nnskb->queue_mapping = skb->queue_mapping;\r\ndev_kfree_skb(skb);\r\nskb = nskb;\r\n}\r\nreturn skb;\r\n}\r\nvoid sunvnet_tx_timeout_common(struct net_device *dev)\r\n{\r\n}\r\nint sunvnet_open_common(struct net_device *dev)\r\n{\r\nnetif_carrier_on(dev);\r\nnetif_tx_start_all_queues(dev);\r\nreturn 0;\r\n}\r\nint sunvnet_close_common(struct net_device *dev)\r\n{\r\nnetif_tx_stop_all_queues(dev);\r\nnetif_carrier_off(dev);\r\nreturn 0;\r\n}\r\nstatic struct vnet_mcast_entry *__vnet_mc_find(struct vnet *vp, u8 *addr)\r\n{\r\nstruct vnet_mcast_entry *m;\r\nfor (m = vp->mcast_list; m; m = m->next) {\r\nif (ether_addr_equal(m->addr, addr))\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __update_mc_list(struct vnet *vp, struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nstruct vnet_mcast_entry *m;\r\nm = __vnet_mc_find(vp, ha->addr);\r\nif (m) {\r\nm->hit = 1;\r\ncontinue;\r\n}\r\nif (!m) {\r\nm = kzalloc(sizeof(*m), GFP_ATOMIC);\r\nif (!m)\r\ncontinue;\r\nmemcpy(m->addr, ha->addr, ETH_ALEN);\r\nm->hit = 1;\r\nm->next = vp->mcast_list;\r\nvp->mcast_list = m;\r\n}\r\n}\r\n}\r\nstatic void __send_mc_list(struct vnet *vp, struct vnet_port *port)\r\n{\r\nstruct vio_net_mcast_info info;\r\nstruct vnet_mcast_entry *m, **pp;\r\nint n_addrs;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.tag.type = VIO_TYPE_CTRL;\r\ninfo.tag.stype = VIO_SUBTYPE_INFO;\r\ninfo.tag.stype_env = VNET_MCAST_INFO;\r\ninfo.tag.sid = vio_send_sid(&port->vio);\r\ninfo.set = 1;\r\nn_addrs = 0;\r\nfor (m = vp->mcast_list; m; m = m->next) {\r\nif (m->sent)\r\ncontinue;\r\nm->sent = 1;\r\nmemcpy(&info.mcast_addr[n_addrs * ETH_ALEN],\r\nm->addr, ETH_ALEN);\r\nif (++n_addrs == VNET_NUM_MCAST) {\r\ninfo.count = n_addrs;\r\n(void)vio_ldc_send(&port->vio, &info,\r\nsizeof(info));\r\nn_addrs = 0;\r\n}\r\n}\r\nif (n_addrs) {\r\ninfo.count = n_addrs;\r\n(void)vio_ldc_send(&port->vio, &info, sizeof(info));\r\n}\r\ninfo.set = 0;\r\nn_addrs = 0;\r\npp = &vp->mcast_list;\r\nwhile ((m = *pp) != NULL) {\r\nif (m->hit) {\r\nm->hit = 0;\r\npp = &m->next;\r\ncontinue;\r\n}\r\nmemcpy(&info.mcast_addr[n_addrs * ETH_ALEN],\r\nm->addr, ETH_ALEN);\r\nif (++n_addrs == VNET_NUM_MCAST) {\r\ninfo.count = n_addrs;\r\n(void)vio_ldc_send(&port->vio, &info,\r\nsizeof(info));\r\nn_addrs = 0;\r\n}\r\n*pp = m->next;\r\nkfree(m);\r\n}\r\nif (n_addrs) {\r\ninfo.count = n_addrs;\r\n(void)vio_ldc_send(&port->vio, &info, sizeof(info));\r\n}\r\n}\r\nvoid sunvnet_set_rx_mode_common(struct net_device *dev, struct vnet *vp)\r\n{\r\nstruct vnet_port *port;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(port, &vp->port_list, list) {\r\nif (port->switch_port) {\r\n__update_mc_list(vp, dev);\r\n__send_mc_list(vp, port);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nint sunvnet_change_mtu_common(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu < 68 || new_mtu > 65535)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nint sunvnet_set_mac_addr_common(struct net_device *dev, void *p)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid sunvnet_port_free_tx_bufs_common(struct vnet_port *port)\r\n{\r\nstruct vio_dring_state *dr;\r\nint i;\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nif (!dr->base)\r\nreturn;\r\nfor (i = 0; i < VNET_TX_RING_SIZE; i++) {\r\nstruct vio_net_desc *d;\r\nvoid *skb = port->tx_bufs[i].skb;\r\nif (!skb)\r\ncontinue;\r\nd = vio_dring_entry(dr, i);\r\nldc_unmap(port->vio.lp,\r\nport->tx_bufs[i].cookies,\r\nport->tx_bufs[i].ncookies);\r\ndev_kfree_skb(skb);\r\nport->tx_bufs[i].skb = NULL;\r\nd->hdr.state = VIO_DESC_FREE;\r\n}\r\nldc_free_exp_dring(port->vio.lp, dr->base,\r\n(dr->entry_size * dr->num_entries),\r\ndr->cookies, dr->ncookies);\r\ndr->base = NULL;\r\ndr->entry_size = 0;\r\ndr->num_entries = 0;\r\ndr->pending = 0;\r\ndr->ncookies = 0;\r\n}\r\nstatic void vnet_port_reset(struct vnet_port *port)\r\n{\r\ndel_timer(&port->clean_timer);\r\nsunvnet_port_free_tx_bufs_common(port);\r\nport->rmtu = 0;\r\nport->tso = true;\r\nport->tsolen = 0;\r\n}\r\nstatic int vnet_port_alloc_tx_ring(struct vnet_port *port)\r\n{\r\nstruct vio_dring_state *dr;\r\nunsigned long len, elen;\r\nint i, err, ncookies;\r\nvoid *dring;\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nelen = sizeof(struct vio_net_desc) +\r\nsizeof(struct ldc_trans_cookie) * 2;\r\nif (vio_version_after_eq(&port->vio, 1, 7))\r\nelen += sizeof(struct vio_net_dext);\r\nlen = VNET_TX_RING_SIZE * elen;\r\nncookies = VIO_MAX_RING_COOKIES;\r\ndring = ldc_alloc_exp_dring(port->vio.lp, len,\r\ndr->cookies, &ncookies,\r\n(LDC_MAP_SHADOW |\r\nLDC_MAP_DIRECT |\r\nLDC_MAP_RW));\r\nif (IS_ERR(dring)) {\r\nerr = PTR_ERR(dring);\r\ngoto err_out;\r\n}\r\ndr->base = dring;\r\ndr->entry_size = elen;\r\ndr->num_entries = VNET_TX_RING_SIZE;\r\ndr->prod = 0;\r\ndr->cons = 0;\r\nport->start_cons = true;\r\ndr->pending = VNET_TX_RING_SIZE;\r\ndr->ncookies = ncookies;\r\nfor (i = 0; i < VNET_TX_RING_SIZE; ++i) {\r\nstruct vio_net_desc *d;\r\nd = vio_dring_entry(dr, i);\r\nd->hdr.state = VIO_DESC_FREE;\r\n}\r\nreturn 0;\r\nerr_out:\r\nsunvnet_port_free_tx_bufs_common(port);\r\nreturn err;\r\n}\r\nvoid sunvnet_poll_controller_common(struct net_device *dev, struct vnet *vp)\r\n{\r\nstruct vnet_port *port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vp->lock, flags);\r\nif (!list_empty(&vp->port_list)) {\r\nport = list_entry(vp->port_list.next, struct vnet_port, list);\r\nnapi_schedule(&port->napi);\r\n}\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\n}\r\nvoid sunvnet_port_add_txq_common(struct vnet_port *port)\r\n{\r\nstruct vnet *vp = port->vp;\r\nint n;\r\nn = vp->nports++;\r\nn = n & (VNET_MAX_TXQS - 1);\r\nport->q_index = n;\r\nnetif_tx_wake_queue(netdev_get_tx_queue(VNET_PORT_TO_NET_DEVICE(port),\r\nport->q_index));\r\n}\r\nvoid sunvnet_port_rm_txq_common(struct vnet_port *port)\r\n{\r\nport->vp->nports--;\r\nnetif_tx_stop_queue(netdev_get_tx_queue(VNET_PORT_TO_NET_DEVICE(port),\r\nport->q_index));\r\n}
