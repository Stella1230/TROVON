static void DAC1064_calcclock(const struct matrox_fb_info *minfo,\r\nunsigned int freq, unsigned int fmax,\r\nunsigned int *in, unsigned int *feed,\r\nunsigned int *post)\r\n{\r\nunsigned int fvco;\r\nunsigned int p;\r\nDBG(__func__)\r\nfvco = PLL_calcclock(minfo, freq, fmax, in, feed, &p);\r\np = (1 << p) - 1;\r\nif (fvco <= 100000)\r\n;\r\nelse if (fvco <= 140000)\r\np |= 0x08;\r\nelse if (fvco <= 180000)\r\np |= 0x10;\r\nelse\r\np |= 0x18;\r\n*post = p;\r\n}\r\nstatic void DAC1064_setpclk(struct matrox_fb_info *minfo, unsigned long fout)\r\n{\r\nunsigned int m, n, p;\r\nDBG(__func__)\r\nDAC1064_calcclock(minfo, fout, minfo->max_pixel_clock, &m, &n, &p);\r\nminfo->hw.DACclk[0] = m;\r\nminfo->hw.DACclk[1] = n;\r\nminfo->hw.DACclk[2] = p;\r\n}\r\nstatic void DAC1064_setmclk(struct matrox_fb_info *minfo, int oscinfo,\r\nunsigned long fmem)\r\n{\r\nu_int32_t mx;\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nDBG(__func__)\r\nif (minfo->devflags.noinit) {\r\nhw->DACclk[3] = inDAC1064(minfo, DAC1064_XSYSPLLM);\r\nhw->DACclk[4] = inDAC1064(minfo, DAC1064_XSYSPLLN);\r\nhw->DACclk[5] = inDAC1064(minfo, DAC1064_XSYSPLLP);\r\nreturn;\r\n}\r\nmx = hw->MXoptionReg | 0x00000004;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mx);\r\nmx &= ~0x000000BB;\r\nif (oscinfo & DAC1064_OPT_GDIV1)\r\nmx |= 0x00000008;\r\nif (oscinfo & DAC1064_OPT_MDIV1)\r\nmx |= 0x00000010;\r\nif (oscinfo & DAC1064_OPT_RESERVED)\r\nmx |= 0x00000080;\r\nif ((oscinfo & DAC1064_OPT_SCLK_MASK) == DAC1064_OPT_SCLK_PLL) {\r\nint clk;\r\nunsigned int m, n, p;\r\nmx |= 0x00000020;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mx);\r\nmx &= ~0x00000004;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mx);\r\nDAC1064_calcclock(minfo, fmem, minfo->max_pixel_clock, &m, &n, &p);\r\noutDAC1064(minfo, DAC1064_XSYSPLLM, hw->DACclk[3] = m);\r\noutDAC1064(minfo, DAC1064_XSYSPLLN, hw->DACclk[4] = n);\r\noutDAC1064(minfo, DAC1064_XSYSPLLP, hw->DACclk[5] = p);\r\nfor (clk = 65536; clk; --clk) {\r\nif (inDAC1064(minfo, DAC1064_XSYSPLLSTAT) & 0x40)\r\nbreak;\r\n}\r\nif (!clk)\r\nprintk(KERN_ERR "matroxfb: aiee, SYSPLL not locked\n");\r\nmx |= 0x00000005;\r\n} else {\r\nmx |= oscinfo & DAC1064_OPT_SCLK_MASK;\r\n}\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mx);\r\nmx &= ~0x00000004;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mx);\r\nhw->MXoptionReg = mx;\r\n}\r\nstatic void g450_set_plls(struct matrox_fb_info *minfo)\r\n{\r\nu_int32_t c2_ctl;\r\nunsigned int pxc;\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nint pixelmnp;\r\nint videomnp;\r\nc2_ctl = hw->crtc2.ctl & ~0x4007;\r\nc2_ctl |= 0x0001;\r\nhw->DACreg[POS1064_XPWRCTRL] &= ~0x02;\r\npixelmnp = minfo->crtc1.mnp;\r\nvideomnp = minfo->crtc2.mnp;\r\nif (videomnp < 0) {\r\nc2_ctl &= ~0x0001;\r\nhw->DACreg[POS1064_XPWRCTRL] &= ~0x10;\r\n} else if (minfo->crtc2.pixclock == minfo->features.pll.ref_freq) {\r\nc2_ctl |= 0x4002;\r\n} else if (videomnp == pixelmnp) {\r\nc2_ctl |= 0x0004;\r\n} else {\r\nif (0 == ((videomnp ^ pixelmnp) & 0xFFFFFF00)) {\r\npixelmnp += 0x000100;\r\n}\r\nc2_ctl |= 0x0006;\r\nhw->DACreg[POS1064_XPWRCTRL] |= 0x02;\r\noutDAC1064(minfo, M1064_XPWRCTRL, hw->DACreg[POS1064_XPWRCTRL]);\r\nmatroxfb_g450_setpll_cond(minfo, videomnp, M_VIDEO_PLL);\r\n}\r\nhw->DACreg[POS1064_XPIXCLKCTRL] &= ~M1064_XPIXCLKCTRL_PLL_UP;\r\nif (pixelmnp >= 0) {\r\nhw->DACreg[POS1064_XPIXCLKCTRL] |= M1064_XPIXCLKCTRL_PLL_UP;\r\noutDAC1064(minfo, M1064_XPIXCLKCTRL, hw->DACreg[POS1064_XPIXCLKCTRL]);\r\nmatroxfb_g450_setpll_cond(minfo, pixelmnp, M_PIXEL_PLL_C);\r\n}\r\nif (c2_ctl != hw->crtc2.ctl) {\r\nhw->crtc2.ctl = c2_ctl;\r\nmga_outl(0x3C10, c2_ctl);\r\n}\r\npxc = minfo->crtc1.pixclock;\r\nif (pxc == 0 || minfo->outputs[2].src == MATROXFB_SRC_CRTC2) {\r\npxc = minfo->crtc2.pixclock;\r\n}\r\nif (minfo->chip == MGA_G550) {\r\nif (pxc < 45000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x00;\r\n} else if (pxc < 55000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x08;\r\n} else if (pxc < 70000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x10;\r\n} else if (pxc < 85000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x18;\r\n} else if (pxc < 100000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x20;\r\n} else if (pxc < 115000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x28;\r\n} else if (pxc < 125000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x30;\r\n} else {\r\nhw->DACreg[POS1064_XPANMODE] = 0x38;\r\n}\r\n} else {\r\nif (pxc < 45000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x00;\r\n} else if (pxc < 65000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x08;\r\n} else if (pxc < 85000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x10;\r\n} else if (pxc < 105000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x18;\r\n} else if (pxc < 135000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x20;\r\n} else if (pxc < 160000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x28;\r\n} else if (pxc < 175000) {\r\nhw->DACreg[POS1064_XPANMODE] = 0x30;\r\n} else {\r\nhw->DACreg[POS1064_XPANMODE] = 0x38;\r\n}\r\n}\r\n}\r\nvoid DAC1064_global_init(struct matrox_fb_info *minfo)\r\n{\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nhw->DACreg[POS1064_XMISCCTRL] &= M1064_XMISCCTRL_DAC_WIDTHMASK;\r\nhw->DACreg[POS1064_XMISCCTRL] |= M1064_XMISCCTRL_LUT_EN;\r\nhw->DACreg[POS1064_XPIXCLKCTRL] = M1064_XPIXCLKCTRL_PLL_UP | M1064_XPIXCLKCTRL_EN | M1064_XPIXCLKCTRL_SRC_PLL;\r\n#ifdef CONFIG_FB_MATROX_G\r\nif (minfo->devflags.g450dac) {\r\nhw->DACreg[POS1064_XPWRCTRL] = 0x1F;\r\nhw->DACreg[POS1064_XOUTPUTCONN] = 0x00;\r\nhw->DACreg[POS1064_XMISCCTRL] |= M1064_XMISCCTRL_DAC_EN;\r\nswitch (minfo->outputs[0].src) {\r\ncase MATROXFB_SRC_CRTC1:\r\ncase MATROXFB_SRC_CRTC2:\r\nhw->DACreg[POS1064_XOUTPUTCONN] |= 0x01;\r\nbreak;\r\ncase MATROXFB_SRC_NONE:\r\nhw->DACreg[POS1064_XMISCCTRL] &= ~M1064_XMISCCTRL_DAC_EN;\r\nbreak;\r\n}\r\nswitch (minfo->outputs[1].src) {\r\ncase MATROXFB_SRC_CRTC1:\r\nhw->DACreg[POS1064_XOUTPUTCONN] |= 0x04;\r\nbreak;\r\ncase MATROXFB_SRC_CRTC2:\r\nif (minfo->outputs[1].mode == MATROXFB_OUTPUT_MODE_MONITOR) {\r\nhw->DACreg[POS1064_XOUTPUTCONN] |= 0x08;\r\n} else {\r\nhw->DACreg[POS1064_XOUTPUTCONN] |= 0x0C;\r\n}\r\nbreak;\r\ncase MATROXFB_SRC_NONE:\r\nhw->DACreg[POS1064_XPWRCTRL] &= ~0x01;\r\nbreak;\r\n}\r\nswitch (minfo->outputs[2].src) {\r\ncase MATROXFB_SRC_CRTC1:\r\nhw->DACreg[POS1064_XOUTPUTCONN] |= 0x20;\r\nbreak;\r\ncase MATROXFB_SRC_CRTC2:\r\nhw->DACreg[POS1064_XOUTPUTCONN] |= 0x40;\r\nbreak;\r\ncase MATROXFB_SRC_NONE:\r\n#if 0\r\nhw->DACreg[POS1064_XPWRCTRL] &= ~0x04;\r\n#endif\r\nbreak;\r\n}\r\ng450_set_plls(minfo);\r\n} else\r\n#endif\r\n{\r\nif (minfo->outputs[1].src == MATROXFB_SRC_CRTC1) {\r\nhw->DACreg[POS1064_XPIXCLKCTRL] = M1064_XPIXCLKCTRL_PLL_UP | M1064_XPIXCLKCTRL_EN | M1064_XPIXCLKCTRL_SRC_EXT;\r\nhw->DACreg[POS1064_XMISCCTRL] |= GX00_XMISCCTRL_MFC_MAFC | G400_XMISCCTRL_VDO_MAFC12;\r\n} else if (minfo->outputs[1].src == MATROXFB_SRC_CRTC2) {\r\nhw->DACreg[POS1064_XMISCCTRL] |= GX00_XMISCCTRL_MFC_MAFC | G400_XMISCCTRL_VDO_C2_MAFC12;\r\n} else if (minfo->outputs[2].src == MATROXFB_SRC_CRTC1)\r\nhw->DACreg[POS1064_XMISCCTRL] |= GX00_XMISCCTRL_MFC_PANELLINK | G400_XMISCCTRL_VDO_MAFC12;\r\nelse\r\nhw->DACreg[POS1064_XMISCCTRL] |= GX00_XMISCCTRL_MFC_DIS;\r\nif (minfo->outputs[0].src != MATROXFB_SRC_NONE)\r\nhw->DACreg[POS1064_XMISCCTRL] |= M1064_XMISCCTRL_DAC_EN;\r\n}\r\n}\r\nvoid DAC1064_global_restore(struct matrox_fb_info *minfo)\r\n{\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\noutDAC1064(minfo, M1064_XPIXCLKCTRL, hw->DACreg[POS1064_XPIXCLKCTRL]);\r\noutDAC1064(minfo, M1064_XMISCCTRL, hw->DACreg[POS1064_XMISCCTRL]);\r\nif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG400) {\r\noutDAC1064(minfo, 0x20, 0x04);\r\noutDAC1064(minfo, 0x1F, minfo->devflags.dfp_type);\r\nif (minfo->devflags.g450dac) {\r\noutDAC1064(minfo, M1064_XSYNCCTRL, 0xCC);\r\noutDAC1064(minfo, M1064_XPWRCTRL, hw->DACreg[POS1064_XPWRCTRL]);\r\noutDAC1064(minfo, M1064_XPANMODE, hw->DACreg[POS1064_XPANMODE]);\r\noutDAC1064(minfo, M1064_XOUTPUTCONN, hw->DACreg[POS1064_XOUTPUTCONN]);\r\n}\r\n}\r\n}\r\nstatic int DAC1064_init_1(struct matrox_fb_info *minfo, struct my_timming *m)\r\n{\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nDBG(__func__)\r\nmemcpy(hw->DACreg, MGA1064_DAC, sizeof(MGA1064_DAC_regs));\r\nswitch (minfo->fbcon.var.bits_per_pixel) {\r\ncase 8:\r\nhw->DACreg[POS1064_XMULCTRL] = M1064_XMULCTRL_DEPTH_8BPP | M1064_XMULCTRL_GRAPHICS_PALETIZED;\r\nbreak;\r\ncase 16:\r\nif (minfo->fbcon.var.green.length == 5)\r\nhw->DACreg[POS1064_XMULCTRL] = M1064_XMULCTRL_DEPTH_15BPP_1BPP | M1064_XMULCTRL_GRAPHICS_PALETIZED;\r\nelse\r\nhw->DACreg[POS1064_XMULCTRL] = M1064_XMULCTRL_DEPTH_16BPP | M1064_XMULCTRL_GRAPHICS_PALETIZED;\r\nbreak;\r\ncase 24:\r\nhw->DACreg[POS1064_XMULCTRL] = M1064_XMULCTRL_DEPTH_24BPP | M1064_XMULCTRL_GRAPHICS_PALETIZED;\r\nbreak;\r\ncase 32:\r\nhw->DACreg[POS1064_XMULCTRL] = M1064_XMULCTRL_DEPTH_32BPP | M1064_XMULCTRL_GRAPHICS_PALETIZED;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nhw->DACreg[POS1064_XVREFCTRL] = minfo->features.DAC1064.xvrefctrl;\r\nhw->DACreg[POS1064_XGENCTRL] &= ~M1064_XGENCTRL_SYNC_ON_GREEN_MASK;\r\nhw->DACreg[POS1064_XGENCTRL] |= (m->sync & FB_SYNC_ON_GREEN)?M1064_XGENCTRL_SYNC_ON_GREEN:M1064_XGENCTRL_NO_SYNC_ON_GREEN;\r\nhw->DACreg[POS1064_XCURADDL] = 0;\r\nhw->DACreg[POS1064_XCURADDH] = 0;\r\nDAC1064_global_init(minfo);\r\nreturn 0;\r\n}\r\nstatic int DAC1064_init_2(struct matrox_fb_info *minfo, struct my_timming *m)\r\n{\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nDBG(__func__)\r\nif (minfo->fbcon.var.bits_per_pixel > 16) {\r\nint i;\r\nfor (i = 0; i < 256; i++) {\r\nhw->DACpal[i * 3 + 0] = i;\r\nhw->DACpal[i * 3 + 1] = i;\r\nhw->DACpal[i * 3 + 2] = i;\r\n}\r\n} else if (minfo->fbcon.var.bits_per_pixel > 8) {\r\nif (minfo->fbcon.var.green.length == 5) {\r\nint i;\r\nfor (i = 0; i < 32; i++) {\r\nhw->DACpal[i * 3 + 0] = i << 3;\r\nhw->DACpal[i * 3 + 1] = i << 3;\r\nhw->DACpal[i * 3 + 2] = i << 3;\r\nhw->DACpal[(i + 128) * 3 + 0] = i << 3;\r\nhw->DACpal[(i + 128) * 3 + 1] = i << 3;\r\nhw->DACpal[(i + 128) * 3 + 2] = i << 3;\r\n}\r\n} else {\r\nint i;\r\nfor (i = 0; i < 64; i++) {\r\nhw->DACpal[i * 3 + 0] = i << 3;\r\nhw->DACpal[i * 3 + 1] = i << 2;\r\nhw->DACpal[i * 3 + 2] = i << 3;\r\n}\r\n}\r\n} else {\r\nmemset(hw->DACpal, 0, 768);\r\n}\r\nreturn 0;\r\n}\r\nstatic void DAC1064_restore_1(struct matrox_fb_info *minfo)\r\n{\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nCRITFLAGS\r\nDBG(__func__)\r\nCRITBEGIN\r\nif ((inDAC1064(minfo, DAC1064_XSYSPLLM) != hw->DACclk[3]) ||\r\n(inDAC1064(minfo, DAC1064_XSYSPLLN) != hw->DACclk[4]) ||\r\n(inDAC1064(minfo, DAC1064_XSYSPLLP) != hw->DACclk[5])) {\r\noutDAC1064(minfo, DAC1064_XSYSPLLM, hw->DACclk[3]);\r\noutDAC1064(minfo, DAC1064_XSYSPLLN, hw->DACclk[4]);\r\noutDAC1064(minfo, DAC1064_XSYSPLLP, hw->DACclk[5]);\r\n}\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < sizeof(MGA1064_DAC_regs); i++) {\r\nif ((i != POS1064_XPIXCLKCTRL) && (i != POS1064_XMISCCTRL))\r\noutDAC1064(minfo, MGA1064_DAC_regs[i], hw->DACreg[i]);\r\n}\r\n}\r\nDAC1064_global_restore(minfo);\r\nCRITEND\r\n}\r\nstatic void DAC1064_restore_2(struct matrox_fb_info *minfo)\r\n{\r\n#ifdef DEBUG\r\nunsigned int i;\r\n#endif\r\nDBG(__func__)\r\n#ifdef DEBUG\r\ndprintk(KERN_DEBUG "DAC1064regs ");\r\nfor (i = 0; i < sizeof(MGA1064_DAC_regs); i++) {\r\ndprintk("R%02X=%02X ", MGA1064_DAC_regs[i], minfo->hw.DACreg[i]);\r\nif ((i & 0x7) == 0x7) dprintk(KERN_DEBUG "continuing... ");\r\n}\r\ndprintk(KERN_DEBUG "DAC1064clk ");\r\nfor (i = 0; i < 6; i++)\r\ndprintk("C%02X=%02X ", i, minfo->hw.DACclk[i]);\r\ndprintk("\n");\r\n#endif\r\n}\r\nstatic int m1064_compute(void* out, struct my_timming* m) {\r\n#define minfo ((struct matrox_fb_info*)out)\r\n{\r\nint i;\r\nint tmout;\r\nCRITFLAGS\r\nDAC1064_setpclk(minfo, m->pixclock);\r\nCRITBEGIN\r\nfor (i = 0; i < 3; i++)\r\noutDAC1064(minfo, M1064_XPIXPLLCM + i, minfo->hw.DACclk[i]);\r\nfor (tmout = 500000; tmout; tmout--) {\r\nif (inDAC1064(minfo, M1064_XPIXPLLSTAT) & 0x40)\r\nbreak;\r\nudelay(10);\r\n}\r\nCRITEND\r\nif (!tmout)\r\nprintk(KERN_ERR "matroxfb: Pixel PLL not locked after 5 secs\n");\r\n}\r\n#undef minfo\r\nreturn 0;\r\n}\r\nstatic int g450_compute(void* out, struct my_timming* m) {\r\n#define minfo ((struct matrox_fb_info*)out)\r\nif (m->mnp < 0) {\r\nm->mnp = matroxfb_g450_setclk(minfo, m->pixclock, (m->crtc == MATROXFB_SRC_CRTC1) ? M_PIXEL_PLL_C : M_VIDEO_PLL);\r\nif (m->mnp >= 0) {\r\nm->pixclock = g450_mnp2f(minfo, m->mnp);\r\n}\r\n}\r\n#undef minfo\r\nreturn 0;\r\n}\r\nstatic int MGA1064_init(struct matrox_fb_info *minfo, struct my_timming *m)\r\n{\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nDBG(__func__)\r\nif (DAC1064_init_1(minfo, m)) return 1;\r\nif (matroxfb_vgaHWinit(minfo, m)) return 1;\r\nhw->MiscOutReg = 0xCB;\r\nif (m->sync & FB_SYNC_HOR_HIGH_ACT)\r\nhw->MiscOutReg &= ~0x40;\r\nif (m->sync & FB_SYNC_VERT_HIGH_ACT)\r\nhw->MiscOutReg &= ~0x80;\r\nif (m->sync & FB_SYNC_COMP_HIGH_ACT)\r\nhw->CRTCEXT[3] |= 0x40;\r\nif (DAC1064_init_2(minfo, m)) return 1;\r\nreturn 0;\r\n}\r\nstatic int MGAG100_init(struct matrox_fb_info *minfo, struct my_timming *m)\r\n{\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nDBG(__func__)\r\nif (DAC1064_init_1(minfo, m)) return 1;\r\nhw->MXoptionReg &= ~0x2000;\r\nif (matroxfb_vgaHWinit(minfo, m)) return 1;\r\nhw->MiscOutReg = 0xEF;\r\nif (m->sync & FB_SYNC_HOR_HIGH_ACT)\r\nhw->MiscOutReg &= ~0x40;\r\nif (m->sync & FB_SYNC_VERT_HIGH_ACT)\r\nhw->MiscOutReg &= ~0x80;\r\nif (m->sync & FB_SYNC_COMP_HIGH_ACT)\r\nhw->CRTCEXT[3] |= 0x40;\r\nif (DAC1064_init_2(minfo, m)) return 1;\r\nreturn 0;\r\n}\r\nstatic void MGA1064_ramdac_init(struct matrox_fb_info *minfo)\r\n{\r\nDBG(__func__)\r\nminfo->features.pll.vco_freq_min = 62000;\r\nminfo->features.pll.ref_freq = 14318;\r\nminfo->features.pll.feed_div_min = 100;\r\nminfo->features.pll.feed_div_max = 127;\r\nminfo->features.pll.in_div_min = 1;\r\nminfo->features.pll.in_div_max = 31;\r\nminfo->features.pll.post_shift_max = 3;\r\nminfo->features.DAC1064.xvrefctrl = DAC1064_XVREFCTRL_EXTERNAL;\r\nDAC1064_setmclk(minfo, DAC1064_OPT_MDIV2 | DAC1064_OPT_GDIV3 | DAC1064_OPT_SCLK_PLL, 133333);\r\n}\r\nstatic void MGAG100_progPixClock(const struct matrox_fb_info *minfo, int flags,\r\nint m, int n, int p)\r\n{\r\nint reg;\r\nint selClk;\r\nint clk;\r\nDBG(__func__)\r\noutDAC1064(minfo, M1064_XPIXCLKCTRL, inDAC1064(minfo, M1064_XPIXCLKCTRL) | M1064_XPIXCLKCTRL_DIS |\r\nM1064_XPIXCLKCTRL_PLL_UP);\r\nswitch (flags & 3) {\r\ncase 0: reg = M1064_XPIXPLLAM; break;\r\ncase 1: reg = M1064_XPIXPLLBM; break;\r\ndefault: reg = M1064_XPIXPLLCM; break;\r\n}\r\noutDAC1064(minfo, reg++, m);\r\noutDAC1064(minfo, reg++, n);\r\noutDAC1064(minfo, reg, p);\r\nselClk = mga_inb(M_MISC_REG_READ) & ~0xC;\r\nswitch (flags & 0x03) {\r\ncase 0x00: break;\r\ncase 0x01: selClk |= 4; break;\r\ndefault: selClk |= 0x0C; break;\r\n}\r\nmga_outb(M_MISC_REG, selClk);\r\nfor (clk = 500000; clk; clk--) {\r\nif (inDAC1064(minfo, M1064_XPIXPLLSTAT) & 0x40)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!clk)\r\nprintk(KERN_ERR "matroxfb: Pixel PLL%c not locked after usual time\n", (reg-M1064_XPIXPLLAM-2)/4 + 'A');\r\nselClk = inDAC1064(minfo, M1064_XPIXCLKCTRL) & ~M1064_XPIXCLKCTRL_SRC_MASK;\r\nswitch (flags & 0x0C) {\r\ncase 0x00: selClk |= M1064_XPIXCLKCTRL_SRC_PCI; break;\r\ncase 0x04: selClk |= M1064_XPIXCLKCTRL_SRC_PLL; break;\r\ndefault: selClk |= M1064_XPIXCLKCTRL_SRC_EXT; break;\r\n}\r\noutDAC1064(minfo, M1064_XPIXCLKCTRL, selClk);\r\noutDAC1064(minfo, M1064_XPIXCLKCTRL, inDAC1064(minfo, M1064_XPIXCLKCTRL) & ~M1064_XPIXCLKCTRL_DIS);\r\n}\r\nstatic void MGAG100_setPixClock(const struct matrox_fb_info *minfo, int flags,\r\nint freq)\r\n{\r\nunsigned int m, n, p;\r\nDBG(__func__)\r\nDAC1064_calcclock(minfo, freq, minfo->max_pixel_clock, &m, &n, &p);\r\nMGAG100_progPixClock(minfo, flags, m, n, p);\r\n}\r\nstatic int MGA1064_preinit(struct matrox_fb_info *minfo)\r\n{\r\nstatic const int vxres_mystique[] = { 512, 640, 768, 800, 832, 960,\r\n1024, 1152, 1280, 1600, 1664, 1920,\r\n2048, 0};\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nDBG(__func__)\r\nminfo->capable.text = 1;\r\nminfo->capable.vxres = vxres_mystique;\r\nminfo->outputs[0].output = &m1064;\r\nminfo->outputs[0].src = minfo->outputs[0].default_src;\r\nminfo->outputs[0].data = minfo;\r\nminfo->outputs[0].mode = MATROXFB_OUTPUT_MODE_MONITOR;\r\nif (minfo->devflags.noinit)\r\nreturn 0;\r\nhw->MXoptionReg &= 0xC0000100;\r\nhw->MXoptionReg |= 0x00094E20;\r\nif (minfo->devflags.novga)\r\nhw->MXoptionReg &= ~0x00000100;\r\nif (minfo->devflags.nobios)\r\nhw->MXoptionReg &= ~0x40000000;\r\nif (minfo->devflags.nopciretry)\r\nhw->MXoptionReg |= 0x20000000;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\r\nmga_setr(M_SEQ_INDEX, 0x01, 0x20);\r\nmga_outl(M_CTLWTST, 0x00000000);\r\nudelay(200);\r\nmga_outl(M_MACCESS, 0x00008000);\r\nudelay(100);\r\nmga_outl(M_MACCESS, 0x0000C000);\r\nreturn 0;\r\n}\r\nstatic void MGA1064_reset(struct matrox_fb_info *minfo)\r\n{\r\nDBG(__func__);\r\nMGA1064_ramdac_init(minfo);\r\n}\r\nstatic void g450_mclk_init(struct matrox_fb_info *minfo)\r\n{\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg | 4);\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION3_REG, minfo->values.reg.opt3 & ~0x00300C03);\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\r\nif (((minfo->values.reg.opt3 & 0x000003) == 0x000003) ||\r\n((minfo->values.reg.opt3 & 0x000C00) == 0x000C00) ||\r\n((minfo->values.reg.opt3 & 0x300000) == 0x300000)) {\r\nmatroxfb_g450_setclk(minfo, minfo->values.pll.video, M_VIDEO_PLL);\r\n} else {\r\nunsigned long flags;\r\nunsigned int pwr;\r\nmatroxfb_DAC_lock_irqsave(flags);\r\npwr = inDAC1064(minfo, M1064_XPWRCTRL) & ~0x02;\r\noutDAC1064(minfo, M1064_XPWRCTRL, pwr);\r\nmatroxfb_DAC_unlock_irqrestore(flags);\r\n}\r\nmatroxfb_g450_setclk(minfo, minfo->values.pll.system, M_SYSTEM_PLL);\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg | 4);\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION3_REG, minfo->values.reg.opt3);\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\r\n}\r\nstatic void g450_memory_init(struct matrox_fb_info *minfo)\r\n{\r\nminfo->hw.MXoptionReg &= ~0x001F8000;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\r\nminfo->hw.MXoptionReg &= ~0x00207E00;\r\nminfo->hw.MXoptionReg |= 0x00207E00 & minfo->values.reg.opt;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION2_REG, minfo->values.reg.opt2);\r\nmga_outl(M_CTLWTST, minfo->values.reg.mctlwtst);\r\npci_write_config_dword(minfo->pcidev, PCI_MEMMISC_REG, minfo->values.reg.memmisc & ~0x80000000U);\r\nmga_outl(M_MEMRDBK, minfo->values.reg.memrdbk);\r\nmga_outl(M_MACCESS, minfo->values.reg.maccess);\r\npci_write_config_dword(minfo->pcidev, PCI_MEMMISC_REG, minfo->values.reg.memmisc | 0x80000000U);\r\nudelay(200);\r\nif (minfo->values.memory.ddr && (!minfo->values.memory.emrswen || !minfo->values.memory.dll)) {\r\nmga_outl(M_MEMRDBK, minfo->values.reg.memrdbk & ~0x1000);\r\n}\r\nmga_outl(M_MACCESS, minfo->values.reg.maccess | 0x8000);\r\nudelay(200);\r\nminfo->hw.MXoptionReg |= 0x001F8000 & minfo->values.reg.opt;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\r\nmga_outl(M_PLNWT, 0);\r\nmga_outl(M_PLNWT, ~0);\r\nif (minfo->values.reg.mctlwtst != minfo->values.reg.mctlwtst_core) {\r\nmga_outl(M_CTLWTST, minfo->values.reg.mctlwtst_core);\r\n}\r\n}\r\nstatic void g450_preinit(struct matrox_fb_info *minfo)\r\n{\r\nu_int32_t c2ctl;\r\nu_int8_t curctl;\r\nu_int8_t c1ctl;\r\nminfo->hw.MXoptionReg &= 0xC0000100;\r\nminfo->hw.MXoptionReg |= 0x00000020;\r\nif (minfo->devflags.novga)\r\nminfo->hw.MXoptionReg &= ~0x00000100;\r\nif (minfo->devflags.nobios)\r\nminfo->hw.MXoptionReg &= ~0x40000000;\r\nif (minfo->devflags.nopciretry)\r\nminfo->hw.MXoptionReg |= 0x20000000;\r\nminfo->hw.MXoptionReg |= minfo->values.reg.opt & 0x03400040;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\r\nc2ctl = mga_inl(M_C2CTL);\r\nmga_outl(M_C2CTL, c2ctl & ~1);\r\ncurctl = inDAC1064(minfo, M1064_XCURCTRL);\r\noutDAC1064(minfo, M1064_XCURCTRL, 0);\r\nc1ctl = mga_readr(M_SEQ_INDEX, 1);\r\nmga_setr(M_SEQ_INDEX, 1, c1ctl | 0x20);\r\ng450_mclk_init(minfo);\r\ng450_memory_init(minfo);\r\nmatroxfb_g450_setclk(minfo, 25175, M_PIXEL_PLL_A);\r\nmatroxfb_g450_setclk(minfo, 28322, M_PIXEL_PLL_B);\r\nmga_setr(M_SEQ_INDEX, 1, c1ctl);\r\noutDAC1064(minfo, M1064_XCURCTRL, curctl);\r\nmga_outl(M_C2CTL, c2ctl);\r\nreturn;\r\n}\r\nstatic int MGAG100_preinit(struct matrox_fb_info *minfo)\r\n{\r\nstatic const int vxres_g100[] = { 512, 640, 768, 800, 832, 960,\r\n1024, 1152, 1280, 1600, 1664, 1920,\r\n2048, 0};\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nu_int32_t reg50;\r\n#if 0\r\nu_int32_t q;\r\n#endif\r\nDBG(__func__)\r\nif (minfo->devflags.g450dac) {\r\nminfo->features.pll.vco_freq_min = 130000;\r\n} else {\r\nminfo->features.pll.vco_freq_min = 62000;\r\n}\r\nif (!minfo->features.pll.ref_freq) {\r\nminfo->features.pll.ref_freq = 27000;\r\n}\r\nminfo->features.pll.feed_div_min = 7;\r\nminfo->features.pll.feed_div_max = 127;\r\nminfo->features.pll.in_div_min = 1;\r\nminfo->features.pll.in_div_max = 31;\r\nminfo->features.pll.post_shift_max = 3;\r\nminfo->features.DAC1064.xvrefctrl = DAC1064_XVREFCTRL_G100_DEFAULT;\r\nminfo->capable.text = 1;\r\nminfo->capable.vxres = vxres_g100;\r\nminfo->capable.plnwt = minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG100\r\n? minfo->devflags.sgram : 1;\r\nif (minfo->devflags.g450dac) {\r\nminfo->outputs[0].output = &g450out;\r\n} else {\r\nminfo->outputs[0].output = &m1064;\r\n}\r\nminfo->outputs[0].src = minfo->outputs[0].default_src;\r\nminfo->outputs[0].data = minfo;\r\nminfo->outputs[0].mode = MATROXFB_OUTPUT_MODE_MONITOR;\r\nif (minfo->devflags.g450dac) {\r\nmga_outl(0x1C0C, 0);\r\n}\r\nif (minfo->devflags.noinit)\r\nreturn 0;\r\nif (minfo->devflags.g450dac) {\r\ng450_preinit(minfo);\r\nreturn 0;\r\n}\r\nhw->MXoptionReg &= 0xC0000100;\r\nhw->MXoptionReg |= 0x00000020;\r\nif (minfo->devflags.novga)\r\nhw->MXoptionReg &= ~0x00000100;\r\nif (minfo->devflags.nobios)\r\nhw->MXoptionReg &= ~0x40000000;\r\nif (minfo->devflags.nopciretry)\r\nhw->MXoptionReg |= 0x20000000;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\r\nDAC1064_setmclk(minfo, DAC1064_OPT_MDIV2 | DAC1064_OPT_GDIV3 | DAC1064_OPT_SCLK_PCI, 133333);\r\nif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG100) {\r\npci_read_config_dword(minfo->pcidev, PCI_OPTION2_REG, &reg50);\r\nreg50 &= ~0x3000;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION2_REG, reg50);\r\nhw->MXoptionReg |= 0x1080;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\r\nmga_outl(M_CTLWTST, minfo->values.reg.mctlwtst);\r\nudelay(100);\r\nmga_outb(0x1C05, 0x00);\r\nmga_outb(0x1C05, 0x80);\r\nudelay(100);\r\nmga_outb(0x1C05, 0x40);\r\nmga_outb(0x1C05, 0xC0);\r\nudelay(100);\r\nreg50 &= ~0xFF;\r\nreg50 |= 0x07;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION2_REG, reg50);\r\nmga_outb(M_GRAPHICS_INDEX, 6);\r\nmga_outb(M_GRAPHICS_DATA, (mga_inb(M_GRAPHICS_DATA) & 3) | 4);\r\nmga_setr(M_EXTVGA_INDEX, 0x03, 0x81);\r\nmga_setr(M_EXTVGA_INDEX, 0x04, 0x00);\r\nmga_writeb(minfo->video.vbase, 0x0000, 0xAA);\r\nmga_writeb(minfo->video.vbase, 0x0800, 0x55);\r\nmga_writeb(minfo->video.vbase, 0x4000, 0x55);\r\n#if 0\r\nif (mga_readb(minfo->video.vbase, 0x0000) != 0xAA) {\r\nhw->MXoptionReg &= ~0x1000;\r\n}\r\n#endif\r\nhw->MXoptionReg |= 0x00078020;\r\n} else if (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG200) {\r\npci_read_config_dword(minfo->pcidev, PCI_OPTION2_REG, &reg50);\r\nreg50 &= ~0x3000;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION2_REG, reg50);\r\nif (minfo->devflags.memtype == -1)\r\nhw->MXoptionReg |= minfo->values.reg.opt & 0x1C00;\r\nelse\r\nhw->MXoptionReg |= (minfo->devflags.memtype & 7) << 10;\r\nif (minfo->devflags.sgram)\r\nhw->MXoptionReg |= 0x4000;\r\nmga_outl(M_CTLWTST, minfo->values.reg.mctlwtst);\r\nmga_outl(M_MEMRDBK, minfo->values.reg.memrdbk);\r\nudelay(200);\r\nmga_outl(M_MACCESS, 0x00000000);\r\nmga_outl(M_MACCESS, 0x00008000);\r\nudelay(100);\r\nmga_outw(M_MEMRDBK, minfo->values.reg.memrdbk);\r\nhw->MXoptionReg |= 0x00078020;\r\n} else {\r\npci_read_config_dword(minfo->pcidev, PCI_OPTION2_REG, &reg50);\r\nreg50 &= ~0x00000100;\r\nreg50 |= 0x00000000;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION2_REG, reg50);\r\nif (minfo->devflags.memtype == -1)\r\nhw->MXoptionReg |= minfo->values.reg.opt & 0x1C00;\r\nelse\r\nhw->MXoptionReg |= (minfo->devflags.memtype & 7) << 10;\r\nif (minfo->devflags.sgram)\r\nhw->MXoptionReg |= 0x4000;\r\nmga_outl(M_CTLWTST, minfo->values.reg.mctlwtst);\r\nmga_outl(M_MEMRDBK, minfo->values.reg.memrdbk);\r\nudelay(200);\r\nmga_outl(M_MACCESS, 0x00000000);\r\nmga_outl(M_MACCESS, 0x00008000);\r\nudelay(100);\r\nmga_outl(M_MEMRDBK, minfo->values.reg.memrdbk);\r\nhw->MXoptionReg |= 0x00040020;\r\n}\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\r\nreturn 0;\r\n}\r\nstatic void MGAG100_reset(struct matrox_fb_info *minfo)\r\n{\r\nu_int8_t b;\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nDBG(__func__)\r\n{\r\n#ifdef G100_BROKEN_IBM_82351\r\nu_int32_t d;\r\nfind 1014/22 (IBM/82351);\r\npci_read_config_byte(ibm, PCI_SECONDARY_BUS, &b);\r\nif (b == minfo->pcidev->bus->number) {\r\npci_write_config_byte(ibm, PCI_COMMAND+1, 0);\r\npci_write_config_byte(ibm, 0x41, 0xF4);\r\npci_write_config_byte(ibm, PCI_IO_BASE, 0xF0);\r\npci_write_config_byte(ibm, PCI_IO_LIMIT, 0x00);\r\n}\r\n#endif\r\nif (!minfo->devflags.noinit) {\r\nif (x7AF4 & 8) {\r\nhw->MXoptionReg |= 0x40;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\r\n}\r\nmga_setr(M_EXTVGA_INDEX, 0x06, 0x00);\r\n}\r\n}\r\nif (minfo->devflags.g450dac) {\r\nhw->DACclk[3] = inDAC1064(minfo, DAC1064_XSYSPLLM);\r\nhw->DACclk[4] = inDAC1064(minfo, DAC1064_XSYSPLLN);\r\nhw->DACclk[5] = inDAC1064(minfo, DAC1064_XSYSPLLP);\r\n} else {\r\nDAC1064_setmclk(minfo, DAC1064_OPT_RESERVED | DAC1064_OPT_MDIV2 | DAC1064_OPT_GDIV1 | DAC1064_OPT_SCLK_PLL, 133333);\r\n}\r\nif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG400) {\r\nif (minfo->devflags.dfp_type == -1) {\r\nminfo->devflags.dfp_type = inDAC1064(minfo, 0x1F);\r\n}\r\n}\r\nif (minfo->devflags.noinit)\r\nreturn;\r\nif (minfo->devflags.g450dac) {\r\n} else {\r\nMGAG100_setPixClock(minfo, 4, 25175);\r\nMGAG100_setPixClock(minfo, 5, 28322);\r\nif (x7AF4 & 0x10) {\r\nb = inDAC1064(minfo, M1064_XGENIODATA) & ~1;\r\noutDAC1064(minfo, M1064_XGENIODATA, b);\r\nb = inDAC1064(minfo, M1064_XGENIOCTRL) | 1;\r\noutDAC1064(minfo, M1064_XGENIOCTRL, b);\r\n}\r\n}\r\n}\r\nstatic void MGA1064_restore(struct matrox_fb_info *minfo)\r\n{\r\nint i;\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nCRITFLAGS\r\nDBG(__func__)\r\nCRITBEGIN\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\r\nmga_outb(M_IEN, 0x00);\r\nmga_outb(M_CACHEFLUSH, 0x00);\r\nCRITEND\r\nDAC1064_restore_1(minfo);\r\nmatroxfb_vgaHWrestore(minfo);\r\nminfo->crtc1.panpos = -1;\r\nfor (i = 0; i < 6; i++)\r\nmga_setr(M_EXTVGA_INDEX, i, hw->CRTCEXT[i]);\r\nDAC1064_restore_2(minfo);\r\n}\r\nstatic void MGAG100_restore(struct matrox_fb_info *minfo)\r\n{\r\nint i;\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nCRITFLAGS\r\nDBG(__func__)\r\nCRITBEGIN\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\r\nCRITEND\r\nDAC1064_restore_1(minfo);\r\nmatroxfb_vgaHWrestore(minfo);\r\nif (minfo->devflags.support32MB)\r\nmga_setr(M_EXTVGA_INDEX, 8, hw->CRTCEXT[8]);\r\nminfo->crtc1.panpos = -1;\r\nfor (i = 0; i < 6; i++)\r\nmga_setr(M_EXTVGA_INDEX, i, hw->CRTCEXT[i]);\r\nDAC1064_restore_2(minfo);\r\n}
