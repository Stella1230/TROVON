int cckrates_included23a(unsigned char *rate, int ratelen)\r\n{\r\nint i;\r\nfor (i = 0; i < ratelen; i++) {\r\nif (((rate[i]) & 0x7f) == 2 || ((rate[i]) & 0x7f) == 4 ||\r\n((rate[i]) & 0x7f) == 11 || ((rate[i]) & 0x7f) == 22)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint cckratesonly_included23a(unsigned char *rate, int ratelen)\r\n{\r\nint i;\r\nfor (i = 0; i < ratelen; i++) {\r\nif (((rate[i]) & 0x7f) != 2 && ((rate[i]) & 0x7f) != 4 &&\r\n((rate[i]) & 0x7f) != 11 && ((rate[i]) & 0x7f) != 22)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nunsigned char networktype_to_raid23a(unsigned char network_type)\r\n{\r\nunsigned char raid;\r\nswitch (network_type) {\r\ncase WIRELESS_11B:\r\nraid = RATR_INX_WIRELESS_B;\r\nbreak;\r\ncase WIRELESS_11A:\r\ncase WIRELESS_11G:\r\nraid = RATR_INX_WIRELESS_G;\r\nbreak;\r\ncase WIRELESS_11BG:\r\nraid = RATR_INX_WIRELESS_GB;\r\nbreak;\r\ncase WIRELESS_11_24N:\r\ncase WIRELESS_11_5N:\r\nraid = RATR_INX_WIRELESS_N;\r\nbreak;\r\ncase WIRELESS_11A_5N:\r\ncase WIRELESS_11G_24N:\r\nraid = RATR_INX_WIRELESS_NG;\r\nbreak;\r\ncase WIRELESS_11BG_24N:\r\nraid = RATR_INX_WIRELESS_NGB;\r\nbreak;\r\ndefault:\r\nraid = RATR_INX_WIRELESS_GB;\r\nbreak;\r\n}\r\nreturn raid;\r\n}\r\nu8 judge_network_type23a(struct rtw_adapter *padapter,\r\nunsigned char *rate, int ratelen)\r\n{\r\nu8 network_type = 0;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nif (pmlmeext->cur_channel > 14) {\r\nif (pmlmeinfo->HT_enable)\r\nnetwork_type = WIRELESS_11_5N;\r\nnetwork_type |= WIRELESS_11A;\r\n} else {\r\nif (pmlmeinfo->HT_enable)\r\nnetwork_type = WIRELESS_11_24N;\r\nif ((cckratesonly_included23a(rate, ratelen)) == true)\r\nnetwork_type |= WIRELESS_11B;\r\nelse if ((cckrates_included23a(rate, ratelen)) == true)\r\nnetwork_type |= WIRELESS_11BG;\r\nelse\r\nnetwork_type |= WIRELESS_11G;\r\n}\r\nreturn network_type;\r\n}\r\nstatic unsigned char ratetbl_val_2wifirate(unsigned char rate)\r\n{\r\nunsigned char val = 0;\r\nswitch (rate & 0x7f) {\r\ncase 0:\r\nval = IEEE80211_CCK_RATE_1MB;\r\nbreak;\r\ncase 1:\r\nval = IEEE80211_CCK_RATE_2MB;\r\nbreak;\r\ncase 2:\r\nval = IEEE80211_CCK_RATE_5MB;\r\nbreak;\r\ncase 3:\r\nval = IEEE80211_CCK_RATE_11MB;\r\nbreak;\r\ncase 4:\r\nval = IEEE80211_OFDM_RATE_6MB;\r\nbreak;\r\ncase 5:\r\nval = IEEE80211_OFDM_RATE_9MB;\r\nbreak;\r\ncase 6:\r\nval = IEEE80211_OFDM_RATE_12MB;\r\nbreak;\r\ncase 7:\r\nval = IEEE80211_OFDM_RATE_18MB;\r\nbreak;\r\ncase 8:\r\nval = IEEE80211_OFDM_RATE_24MB;\r\nbreak;\r\ncase 9:\r\nval = IEEE80211_OFDM_RATE_36MB;\r\nbreak;\r\ncase 10:\r\nval = IEEE80211_OFDM_RATE_48MB;\r\nbreak;\r\ncase 11:\r\nval = IEEE80211_OFDM_RATE_54MB;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic int is_basicrate(struct rtw_adapter *padapter, unsigned char rate)\r\n{\r\nint i;\r\nunsigned char val;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nfor (i = 0; i < NumRates; i++) {\r\nval = pmlmeext->basicrate[i];\r\nif (val != 0xff && val != 0xfe) {\r\nif (rate == ratetbl_val_2wifirate(val))\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic unsigned int ratetbl2rateset(struct rtw_adapter *padapter,\r\nunsigned char *rateset)\r\n{\r\nint i;\r\nunsigned char rate;\r\nunsigned int len = 0;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nfor (i = 0; i < NumRates; i++) {\r\nrate = pmlmeext->datarate[i];\r\nswitch (rate) {\r\ncase 0xff:\r\nreturn len;\r\ncase 0xfe:\r\ncontinue;\r\ndefault:\r\nrate = ratetbl_val_2wifirate(rate);\r\nif (is_basicrate(padapter, rate) == true)\r\nrate |= IEEE80211_BASIC_RATE_MASK;\r\nrateset[len] = rate;\r\nlen++;\r\nbreak;\r\n}\r\n}\r\nreturn len;\r\n}\r\nvoid get_rate_set23a(struct rtw_adapter *padapter,\r\nunsigned char *pbssrate, int *bssrate_len)\r\n{\r\nunsigned char supportedrates[NumRates];\r\nmemset(supportedrates, 0, NumRates);\r\n*bssrate_len = ratetbl2rateset(padapter, supportedrates);\r\nmemcpy(pbssrate, supportedrates, *bssrate_len);\r\n}\r\nvoid UpdateBrateTbl23a(struct rtw_adapter *Adapter, u8 *mBratesOS)\r\n{\r\nu8 i;\r\nu8 rate;\r\nfor (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {\r\nrate = mBratesOS[i] & 0x7f;\r\nswitch (rate) {\r\ncase IEEE80211_CCK_RATE_1MB:\r\ncase IEEE80211_CCK_RATE_2MB:\r\ncase IEEE80211_CCK_RATE_5MB:\r\ncase IEEE80211_CCK_RATE_11MB:\r\ncase IEEE80211_OFDM_RATE_6MB:\r\ncase IEEE80211_OFDM_RATE_12MB:\r\ncase IEEE80211_OFDM_RATE_24MB:\r\nmBratesOS[i] |= IEEE80211_BASIC_RATE_MASK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid Update23aTblForSoftAP(u8 *bssrateset, u32 bssratelen)\r\n{\r\nu8 i;\r\nu8 rate;\r\nfor (i = 0; i < bssratelen; i++) {\r\nrate = bssrateset[i] & 0x7f;\r\nswitch (rate) {\r\ncase IEEE80211_CCK_RATE_1MB:\r\ncase IEEE80211_CCK_RATE_2MB:\r\ncase IEEE80211_CCK_RATE_5MB:\r\ncase IEEE80211_CCK_RATE_11MB:\r\nbssrateset[i] |= IEEE80211_BASIC_RATE_MASK;\r\nbreak;\r\n}\r\n}\r\n}\r\ninline u8 rtw_get_oper_ch23a(struct rtw_adapter *adapter)\r\n{\r\nreturn adapter_to_dvobj(adapter)->oper_channel;\r\n}\r\ninline void rtw_set_oper_ch23a(struct rtw_adapter *adapter, u8 ch)\r\n{\r\nadapter_to_dvobj(adapter)->oper_channel = ch;\r\n}\r\ninline void rtw_set_oper_bw23a(struct rtw_adapter *adapter, u8 bw)\r\n{\r\nadapter_to_dvobj(adapter)->oper_bwmode = bw;\r\n}\r\ninline void rtw_set_oper_ch23aoffset23a(struct rtw_adapter *adapter, u8 offset)\r\n{\r\nadapter_to_dvobj(adapter)->oper_ch_offset = offset;\r\n}\r\nvoid SelectChannel23a(struct rtw_adapter *padapter, unsigned char channel)\r\n{\r\nmutex_lock(&adapter_to_dvobj(padapter)->setch_mutex);\r\nrtw_set_oper_ch23a(padapter, channel);\r\nPHY_SwChnl8723A(padapter, channel);\r\nmutex_unlock(&adapter_to_dvobj(padapter)->setch_mutex);\r\n}\r\nstatic void set_bwmode(struct rtw_adapter *padapter, unsigned short bwmode,\r\nunsigned char channel_offset)\r\n{\r\nmutex_lock(&adapter_to_dvobj(padapter)->setbw_mutex);\r\nrtw_set_oper_bw23a(padapter, bwmode);\r\nrtw_set_oper_ch23aoffset23a(padapter, channel_offset);\r\nPHY_SetBWMode23a8723A(padapter, (enum ht_channel_width)bwmode,\r\nchannel_offset);\r\nmutex_unlock(&adapter_to_dvobj(padapter)->setbw_mutex);\r\n}\r\nvoid set_channel_bwmode23a(struct rtw_adapter *padapter, unsigned char channel,\r\nunsigned char channel_offset, unsigned short bwmode)\r\n{\r\nu8 center_ch;\r\nif (bwmode == HT_CHANNEL_WIDTH_20 ||\r\nchannel_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE) {\r\ncenter_ch = channel;\r\n} else {\r\nif (channel_offset == HAL_PRIME_CHNL_OFFSET_LOWER) {\r\ncenter_ch = channel + 2;\r\n} else {\r\ncenter_ch = channel - 2;\r\n}\r\n}\r\nmutex_lock(&adapter_to_dvobj(padapter)->setch_mutex);\r\nrtw_set_oper_ch23a(padapter, channel);\r\nrtw_set_oper_bw23a(padapter, bwmode);\r\nrtw_set_oper_ch23aoffset23a(padapter, channel_offset);\r\nPHY_SwChnl8723A(padapter, center_ch);\r\nmutex_unlock(&adapter_to_dvobj(padapter)->setch_mutex);\r\nset_bwmode(padapter, bwmode, channel_offset);\r\n}\r\ninline u8 *get_my_bssid23a(struct wlan_bssid_ex *pnetwork)\r\n{\r\nreturn pnetwork->MacAddress;\r\n}\r\nbool is_client_associated_to_ap23a(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nif (!padapter)\r\nreturn false;\r\npmlmeext = &padapter->mlmeextpriv;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\nif (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS &&\r\n(pmlmeinfo->state & 0x03) == MSR_INFRA)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nbool is_client_associated_to_ibss23a(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nif (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS &&\r\n(pmlmeinfo->state & 0x03) == MSR_ADHOC)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nbool is_IBSS_empty23a(struct rtw_adapter *padapter)\r\n{\r\nunsigned int i;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nfor (i = IBSS_START_MAC_ID; i < NUM_STA; i++) {\r\nif (pmlmeinfo->FW_sta_info[i].status == 1)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nunsigned int decide_wait_for_beacon_timeout23a(unsigned int bcn_interval)\r\n{\r\nif ((bcn_interval << 2) < WAIT_FOR_BCN_TO_MIN)\r\nreturn WAIT_FOR_BCN_TO_MIN;\r\nelse if ((bcn_interval << 2) > WAIT_FOR_BCN_TO_MAX)\r\nreturn WAIT_FOR_BCN_TO_MAX;\r\nelse\r\nreturn bcn_interval << 2;\r\n}\r\nvoid clear_cam_entry23a(struct rtw_adapter *padapter, u8 entry)\r\n{\r\nunsigned char null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char null_key[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00};\r\nrtl8723a_cam_write(padapter, entry, 0, null_sta, null_key);\r\n}\r\nint allocate_fw_sta_entry23a(struct rtw_adapter *padapter)\r\n{\r\nunsigned int mac_id;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nfor (mac_id = IBSS_START_MAC_ID; mac_id < NUM_STA; mac_id++) {\r\nif (pmlmeinfo->FW_sta_info[mac_id].status == 0) {\r\npmlmeinfo->FW_sta_info[mac_id].status = 1;\r\npmlmeinfo->FW_sta_info[mac_id].retry = 0;\r\nbreak;\r\n}\r\n}\r\nreturn mac_id;\r\n}\r\nvoid flush_all_cam_entry23a(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nrtl8723a_cam_invalidate_all(padapter);\r\nmemset(pmlmeinfo->FW_sta_info, 0, sizeof(pmlmeinfo->FW_sta_info));\r\n}\r\nint WMM_param_handler23a(struct rtw_adapter *padapter, const u8 *p)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nif (pmlmepriv->qos_option == 0) {\r\npmlmeinfo->WMM_enable = 0;\r\nreturn _FAIL;\r\n}\r\npmlmeinfo->WMM_enable = 1;\r\nmemcpy(&pmlmeinfo->WMM_param, p + 2 + 6,\r\nsizeof(struct WMM_para_element));\r\nreturn true;\r\n}\r\nvoid WMMOnAssocRsp23a(struct rtw_adapter *padapter)\r\n{\r\nu8 ACI, ACM, AIFS, ECWMin, ECWMax, aSifsTime;\r\nu8 acm_mask;\r\nu16 TXOP;\r\nu32 acParm, i;\r\nu32 edca[4], inx[4];\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nif (pmlmeinfo->WMM_enable == 0) {\r\npadapter->mlmepriv.acm_mask = 0;\r\nreturn;\r\n}\r\nacm_mask = 0;\r\nif (pmlmeext->cur_wireless_mode == WIRELESS_11B)\r\naSifsTime = 10;\r\nelse\r\naSifsTime = 16;\r\nfor (i = 0; i < 4; i++) {\r\nACI = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5) & 0x03;\r\nACM = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4) & 0x01;\r\nAIFS = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 0x0f) *\r\npmlmeinfo->slotTime + aSifsTime;\r\nECWMin = pmlmeinfo->WMM_param.ac_param[i].CW & 0x0f;\r\nECWMax = (pmlmeinfo->WMM_param.ac_param[i].CW & 0xf0) >> 4;\r\nTXOP = le16_to_cpu(pmlmeinfo->WMM_param.ac_param[i].TXOP_limit);\r\nacParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);\r\nswitch (ACI) {\r\ncase 0x0:\r\nrtl8723a_set_ac_param_be(padapter, acParm);\r\nacm_mask |= (ACM? BIT(1):0);\r\nedca[XMIT_BE_QUEUE] = acParm;\r\nbreak;\r\ncase 0x1:\r\nrtl8723a_set_ac_param_bk(padapter, acParm);\r\nedca[XMIT_BK_QUEUE] = acParm;\r\nbreak;\r\ncase 0x2:\r\nrtl8723a_set_ac_param_vi(padapter, acParm);\r\nacm_mask |= (ACM? BIT(2):0);\r\nedca[XMIT_VI_QUEUE] = acParm;\r\nbreak;\r\ncase 0x3:\r\nrtl8723a_set_ac_param_vo(padapter, acParm);\r\nacm_mask |= (ACM? BIT(3):0);\r\nedca[XMIT_VO_QUEUE] = acParm;\r\nbreak;\r\n}\r\nDBG_8723A("WMM(%x): %x, %x\n", ACI, ACM, acParm);\r\n}\r\nif (padapter->registrypriv.acm_method == 1)\r\nrtl8723a_set_acm_ctrl(padapter, acm_mask);\r\nelse\r\npadapter->mlmepriv.acm_mask = acm_mask;\r\ninx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;\r\nif (pregpriv->wifi_spec == 1) {\r\nu32 j, change_inx = false;\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = i+1; j < 4; j++) {\r\nif ((edca[j] & 0xFFFF) < (edca[i] & 0xFFFF)) {\r\nchange_inx = true;\r\n} else if ((edca[j] & 0xFFFF) ==\r\n(edca[i] & 0xFFFF)) {\r\nif ((edca[j] >> 16) > (edca[i] >> 16))\r\nchange_inx = true;\r\n}\r\nif (change_inx) {\r\nswap(edca[i], edca[j]);\r\nswap(inx[i], inx[j]);\r\nchange_inx = false;\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 0; i<4; i++) {\r\npxmitpriv->wmm_para_seq[i] = inx[i];\r\nDBG_8723A("wmm_para_seq(%d): %d\n", i,\r\npxmitpriv->wmm_para_seq[i]);\r\n}\r\n}\r\nstatic void bwmode_update_check(struct rtw_adapter *padapter, const u8 *p)\r\n{\r\nstruct ieee80211_ht_operation *pHT_info;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nunsigned char new_bwmode;\r\nunsigned char new_ch_offset;\r\nif (!p)\r\nreturn;\r\nif (!phtpriv->ht_option)\r\nreturn;\r\nif (p[1] != sizeof(struct ieee80211_ht_operation))\r\nreturn;\r\npHT_info = (struct ieee80211_ht_operation *)(p + 2);\r\nif ((pHT_info->ht_param & IEEE80211_HT_PARAM_CHAN_WIDTH_ANY) &&\r\npregistrypriv->cbw40_enable) {\r\nnew_bwmode = HT_CHANNEL_WIDTH_40;\r\nswitch (pHT_info->ht_param & IEEE80211_HT_PARAM_CHA_SEC_OFFSET){\r\ncase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\r\nnew_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nbreak;\r\ncase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\r\nnew_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nbreak;\r\ndefault:\r\nnew_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nbreak;\r\n}\r\n} else {\r\nnew_bwmode = HT_CHANNEL_WIDTH_20;\r\nnew_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\n}\r\nif (new_bwmode != pmlmeext->cur_bwmode ||\r\nnew_ch_offset != pmlmeext->cur_ch_offset) {\r\npmlmeinfo->bwmode_updated = true;\r\npmlmeext->cur_bwmode = new_bwmode;\r\npmlmeext->cur_ch_offset = new_ch_offset;\r\nHT_info_handler23a(padapter, p);\r\n} else\r\npmlmeinfo->bwmode_updated = false;\r\nif (pmlmeinfo->bwmode_updated) {\r\nstruct sta_info *psta;\r\nstruct wlan_bssid_ex *cur_network = &pmlmeinfo->network;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\npsta = rtw_get_stainfo23a(pstapriv, cur_network->MacAddress);\r\nif (psta) {\r\nstruct ht_priv *phtpriv_sta = &psta->htpriv;\r\nif (phtpriv_sta->ht_option) {\r\nphtpriv_sta->bwmode = pmlmeext->cur_bwmode;\r\nphtpriv_sta->ch_offset =\r\npmlmeext->cur_ch_offset;\r\n} else {\r\nphtpriv_sta->bwmode = HT_CHANNEL_WIDTH_20;\r\nphtpriv_sta->ch_offset =\r\nHAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\n}\r\n}\r\n}\r\n}\r\nvoid HT_caps_handler23a(struct rtw_adapter *padapter, const u8 *p)\r\n{\r\nunsigned int i;\r\nu8 rf_type;\r\nu8 max_AMPDU_len, min_MPDU_spacing;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nstruct ieee80211_ht_cap *cap;\r\nu8 *dstcap;\r\nif (!p)\r\nreturn;\r\nif (!phtpriv->ht_option)\r\nreturn;\r\npmlmeinfo->HT_caps_enable = 1;\r\ncap = &pmlmeinfo->ht_cap;\r\ndstcap = (u8 *)cap;\r\nfor (i = 0; i < p[1]; i++) {\r\nif (i != 2) {\r\ndstcap[i] &= p[i + 2];\r\n} else {\r\nif ((cap->ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_FACTOR) >\r\n(p[i + 2] & IEEE80211_HT_AMPDU_PARM_FACTOR))\r\nmax_AMPDU_len = p[i + 2] &\r\nIEEE80211_HT_AMPDU_PARM_FACTOR;\r\nelse\r\nmax_AMPDU_len = cap->ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_FACTOR;\r\nif ((cap->ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_DENSITY) >\r\n(p[i + 2] & IEEE80211_HT_AMPDU_PARM_DENSITY))\r\nmin_MPDU_spacing = cap->ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_DENSITY;\r\nelse\r\nmin_MPDU_spacing = p[i + 2] &\r\nIEEE80211_HT_AMPDU_PARM_DENSITY;\r\ncap->ampdu_params_info =\r\nmax_AMPDU_len | min_MPDU_spacing;\r\n}\r\n}\r\nrf_type = rtl8723a_get_rf_type(padapter);\r\nfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++) {\r\nif (rf_type == RF_1T1R || rf_type == RF_1T2R)\r\ncap->mcs.rx_mask[i] &= MCS_rate_1R23A[i];\r\nelse\r\ncap->mcs.rx_mask[i] &= MCS_rate_2R23A[i];\r\n}\r\n}\r\nvoid HT_info_handler23a(struct rtw_adapter *padapter, const u8 *p)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nif (!p)\r\nreturn;\r\nif (!phtpriv->ht_option)\r\nreturn;\r\nif (p[1] != sizeof(struct ieee80211_ht_operation))\r\nreturn;\r\npmlmeinfo->HT_info_enable = 1;\r\nmemcpy(&pmlmeinfo->HT_info, p + 2, p[1]);\r\n}\r\nvoid HTOnAssocRsp23a(struct rtw_adapter *padapter)\r\n{\r\nunsigned char max_AMPDU_len;\r\nunsigned char min_MPDU_spacing;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nDBG_8723A("%s\n", __func__);\r\nif (pmlmeinfo->HT_info_enable && pmlmeinfo->HT_caps_enable)\r\npmlmeinfo->HT_enable = 1;\r\nelse {\r\npmlmeinfo->HT_enable = 0;\r\nreturn;\r\n}\r\nmax_AMPDU_len = pmlmeinfo->ht_cap.ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_FACTOR;\r\nmin_MPDU_spacing =\r\n(pmlmeinfo->ht_cap.ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_DENSITY) >> 2;\r\nrtl8723a_set_ampdu_min_space(padapter, min_MPDU_spacing);\r\nrtl8723a_set_ampdu_factor(padapter, max_AMPDU_len);\r\n}\r\nvoid ERP_IE_handler23a(struct rtw_adapter *padapter, const u8 *p)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nif (p[1] > 1)\r\nreturn;\r\npmlmeinfo->ERP_enable = 1;\r\nmemcpy(&pmlmeinfo->ERP_IE, p + 2, p[1]);\r\n}\r\nvoid VCS_update23a(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nswitch (pregpriv->vrtl_carrier_sense) {\r\ncase 0:\r\npsta->rtsen = 0;\r\npsta->cts2self = 0;\r\nbreak;\r\ncase 1:\r\nif (pregpriv->vcs_type == RTS_CTS) {\r\npsta->rtsen = 1;\r\npsta->cts2self = 0;\r\n} else {\r\npsta->rtsen = 0;\r\npsta->cts2self = 1;\r\n}\r\nbreak;\r\ncase 2:\r\ndefault:\r\nif (pmlmeinfo->ERP_enable && pmlmeinfo->ERP_IE & BIT(1)) {\r\nif (pregpriv->vcs_type == RTS_CTS) {\r\npsta->rtsen = 1;\r\npsta->cts2self = 0;\r\n} else {\r\npsta->rtsen = 0;\r\npsta->cts2self = 1;\r\n}\r\n} else {\r\npsta->rtsen = 0;\r\npsta->cts2self = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nint rtw_check_bcn_info23a(struct rtw_adapter *Adapter,\r\nstruct ieee80211_mgmt *mgmt, u32 pkt_len)\r\n{\r\nstruct wlan_network *cur_network = &Adapter->mlmepriv.cur_network;\r\nstruct ieee80211_ht_operation *pht_info;\r\nunsigned short val16;\r\nu8 crypto, bcn_channel;\r\nint group_cipher = 0, pairwise_cipher = 0, is_8021x = 0, r;\r\nint pie_len, ssid_len, privacy;\r\nconst u8 *p, *ssid;\r\nif (!is_client_associated_to_ap23a(Adapter))\r\nreturn _SUCCESS;\r\nif (unlikely(!ieee80211_is_beacon(mgmt->frame_control))) {\r\nprintk(KERN_WARNING "%s: received a non beacon frame!\n",\r\n__func__);\r\nreturn _FAIL;\r\n}\r\nif (!ether_addr_equal(cur_network->network.MacAddress, mgmt->bssid)) {\r\nDBG_8723A("%s: linked but recv other bssid bcn %pM %pM\n",\r\n__func__, mgmt->bssid,\r\ncur_network->network.MacAddress);\r\nreturn _FAIL;\r\n}\r\npie_len = pkt_len - offsetof(struct ieee80211_mgmt, u.beacon.variable);\r\np = cfg80211_find_ie(WLAN_EID_DS_PARAMS, mgmt->u.beacon.variable,\r\npie_len);\r\nif (p)\r\nbcn_channel = p[2];\r\nelse {\r\np = cfg80211_find_ie(WLAN_EID_HT_OPERATION,\r\nmgmt->u.beacon.variable, pie_len);\r\nif (p && p[1] > 0) {\r\npht_info = (struct ieee80211_ht_operation *)(p + 2);\r\nbcn_channel = pht_info->primary_chan;\r\n} else {\r\nDBG_8723A("Oops: %s we don't find channel IE, so don't "\r\n"check it\n", __func__);\r\nbcn_channel = Adapter->mlmeextpriv.cur_channel;\r\n}\r\n}\r\nif (bcn_channel != Adapter->mlmeextpriv.cur_channel) {\r\nDBG_8723A("%s beacon channel:%d cur channel:%d disconnect\n",\r\n__func__, bcn_channel,\r\nAdapter->mlmeextpriv.cur_channel);\r\ngoto _mismatch;\r\n}\r\np = cfg80211_find_ie(WLAN_EID_SSID, mgmt->u.beacon.variable, pie_len);\r\nif (p && p[1]) {\r\nssid = p + 2;\r\nssid_len = p[1];\r\n} else {\r\nDBG_8723A("%s marc: cannot find SSID for survey event\n",\r\n__func__);\r\nssid = NULL;\r\nssid_len = 0;\r\n}\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n"%s bssid.Ssid.Ssid:%s bssid.Ssid.SsidLength:%d cur_network->network.Ssid.Ssid:%s len:%d\n",\r\n__func__, ssid, ssid_len, cur_network->network.Ssid.ssid,\r\ncur_network->network.Ssid.ssid_len);\r\nif (ssid_len != cur_network->network.Ssid.ssid_len || ssid_len > 32 ||\r\n(ssid_len &&\r\nmemcmp(ssid, cur_network->network.Ssid.ssid, ssid_len))) {\r\nDBG_8723A("%s(), SSID is not match return FAIL\n", __func__);\r\ngoto _mismatch;\r\n}\r\nval16 = le16_to_cpu(mgmt->u.beacon.capab_info);\r\nif (val16 & WLAN_CAPABILITY_PRIVACY)\r\nprivacy = 1;\r\nelse\r\nprivacy = 0;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n"%s(): cur_network->network.Privacy is %d, bssid.Privacy is %d\n",\r\n__func__, cur_network->network.Privacy, privacy);\r\nif (cur_network->network.Privacy != privacy) {\r\nDBG_8723A("%s(), privacy is not match return FAIL\n", __func__);\r\ngoto _mismatch;\r\n}\r\np = cfg80211_find_ie(WLAN_EID_RSN, mgmt->u.beacon.variable, pie_len);\r\nif (p && p[1]) {\r\ncrypto = ENCRYP_PROTOCOL_WPA2;\r\nif (p && p[1]) {\r\nr = rtw_parse_wpa2_ie23a(p, p[1] + 2, &group_cipher,\r\n&pairwise_cipher, &is_8021x);\r\nif (r == _SUCCESS)\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n"%s pnetwork->pairwise_cipher: %d, pnetwork->group_cipher: %d, is_802x : %d\n",\r\n__func__, pairwise_cipher,\r\ngroup_cipher, is_8021x);\r\n}\r\n} else {\r\np = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\r\nWLAN_OUI_TYPE_MICROSOFT_WPA,\r\nmgmt->u.beacon.variable, pie_len);\r\nif (p && p[1]) {\r\ncrypto = ENCRYP_PROTOCOL_WPA;\r\nr = rtw_parse_wpa_ie23a(p, p[1] + 2, &group_cipher,\r\n&pairwise_cipher, &is_8021x);\r\nif (r == _SUCCESS)\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n"%s pnetwork->pairwise_cipher: %d, group_cipher is %d, is_8021x is %d\n",\r\n__func__, pairwise_cipher,\r\ngroup_cipher, is_8021x);\r\n} else {\r\nif (privacy)\r\ncrypto = ENCRYP_PROTOCOL_WEP;\r\nelse\r\ncrypto = ENCRYP_PROTOCOL_OPENSYS;\r\n}\r\n}\r\nif (cur_network->BcnInfo.encryp_protocol != crypto) {\r\nDBG_8723A("%s(): encryption mismatch, return FAIL\n", __func__);\r\ngoto _mismatch;\r\n}\r\nif (crypto == ENCRYP_PROTOCOL_WPA || crypto == ENCRYP_PROTOCOL_WPA2) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,\r\n"%s cur_network->group_cipher is %d: %d\n", __func__,\r\ncur_network->BcnInfo.group_cipher, group_cipher);\r\nif (pairwise_cipher != cur_network->BcnInfo.pairwise_cipher ||\r\ngroup_cipher != cur_network->BcnInfo.group_cipher) {\r\nDBG_8723A("%s pairwise_cipher(%x:%x) or group_cipher "\r\n"(%x:%x) is not match, return FAIL\n",\r\n__func__, pairwise_cipher,\r\ncur_network->BcnInfo.pairwise_cipher,\r\ngroup_cipher,\r\ncur_network->BcnInfo.group_cipher);\r\ngoto _mismatch;\r\n}\r\nif (is_8021x != cur_network->BcnInfo.is_8021x) {\r\nDBG_8723A("%s authentication is not match, return "\r\n"FAIL\n", __func__);\r\ngoto _mismatch;\r\n}\r\n}\r\nreturn _SUCCESS;\r\n_mismatch:\r\nreturn _FAIL;\r\n}\r\nvoid update_beacon23a_info(struct rtw_adapter *padapter,\r\nstruct ieee80211_mgmt *mgmt,\r\nuint pkt_len, struct sta_info *psta)\r\n{\r\nunsigned int len;\r\nconst u8 *p;\r\nlen = pkt_len - offsetof(struct ieee80211_mgmt, u.beacon.variable);\r\np = cfg80211_find_ie(WLAN_EID_HT_OPERATION, mgmt->u.beacon.variable,\r\nlen);\r\nif (p)\r\nbwmode_update_check(padapter, p);\r\np = cfg80211_find_ie(WLAN_EID_ERP_INFO, mgmt->u.beacon.variable, len);\r\nif (p) {\r\nERP_IE_handler23a(padapter, p);\r\nVCS_update23a(padapter, psta);\r\n}\r\n}\r\nbool is_ap_in_tkip23a(struct rtw_adapter *padapter)\r\n{\r\nu32 i;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct wlan_bssid_ex *cur_network = &pmlmeinfo->network;\r\nconst u8 *p;\r\nif (cur_network->capability & WLAN_CAPABILITY_PRIVACY) {\r\nfor (i = 0; i < pmlmeinfo->network.IELength;) {\r\np = pmlmeinfo->network.IEs + i;\r\nswitch (p[0]) {\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nif (!memcmp(p + 2, RTW_WPA_OUI23A_TYPE, 4) &&\r\n!memcmp(p + 2 + 12, WPA_TKIP_CIPHER, 4))\r\nreturn true;\r\nbreak;\r\ncase WLAN_EID_RSN:\r\nif (!memcmp(p + 2 + 8, RSN_TKIP_CIPHER, 4))\r\nreturn true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ni += (p[1] + 2);\r\n}\r\nreturn false;\r\n} else\r\nreturn false;\r\n}\r\nbool should_forbid_n_rate23a(struct rtw_adapter *padapter)\r\n{\r\nu32 i;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_bssid_ex *cur_network = &pmlmepriv->cur_network.network;\r\nconst u8 *p;\r\nif (cur_network->capability & WLAN_CAPABILITY_PRIVACY) {\r\nfor (i = 0; i < cur_network->IELength;) {\r\np = cur_network->IEs + i;\r\nswitch (p[0]) {\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nif (!memcmp(p + 2, RTW_WPA_OUI23A_TYPE, 4) &&\r\n(!memcmp(p + 2 + 12,\r\nWPA_CIPHER_SUITE_CCMP23A, 4) ||\r\n!memcmp(p + 2 + 16,\r\nWPA_CIPHER_SUITE_CCMP23A, 4)))\r\nreturn false;\r\nbreak;\r\ncase WLAN_EID_RSN:\r\nif (!memcmp(p + 2 + 8,\r\nRSN_CIPHER_SUITE_CCMP23A, 4) ||\r\n!memcmp(p + 2 + 12,\r\nRSN_CIPHER_SUITE_CCMP23A, 4))\r\nreturn false;\r\ndefault:\r\nbreak;\r\n}\r\ni += (p[1] + 2);\r\n}\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nbool is_ap_in_wep23a(struct rtw_adapter *padapter)\r\n{\r\nu32 i;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct wlan_bssid_ex *cur_network = &pmlmeinfo->network;\r\nconst u8 *p;\r\nif (cur_network->capability & WLAN_CAPABILITY_PRIVACY) {\r\nfor (i = 0; i < pmlmeinfo->network.IELength;) {\r\np = pmlmeinfo->network.IEs + i;\r\nswitch (p[0]) {\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nif (!memcmp(p + 2, RTW_WPA_OUI23A_TYPE, 4))\r\nreturn false;\r\nbreak;\r\ncase WLAN_EID_RSN:\r\nreturn false;\r\ndefault:\r\nbreak;\r\n}\r\ni += (p[1] + 2);\r\n}\r\nreturn true;\r\n} else\r\nreturn false;\r\n}\r\nstatic int wifirate2_ratetbl_inx23a(unsigned char rate)\r\n{\r\nint inx = 0;\r\nrate = rate & 0x7f;\r\nswitch (rate) {\r\ncase 54*2:\r\ninx = 11;\r\nbreak;\r\ncase 48*2:\r\ninx = 10;\r\nbreak;\r\ncase 36*2:\r\ninx = 9;\r\nbreak;\r\ncase 24*2:\r\ninx = 8;\r\nbreak;\r\ncase 18*2:\r\ninx = 7;\r\nbreak;\r\ncase 12*2:\r\ninx = 6;\r\nbreak;\r\ncase 9*2:\r\ninx = 5;\r\nbreak;\r\ncase 6*2:\r\ninx = 4;\r\nbreak;\r\ncase 11*2:\r\ninx = 3;\r\nbreak;\r\ncase 11:\r\ninx = 2;\r\nbreak;\r\ncase 2*2:\r\ninx = 1;\r\nbreak;\r\ncase 1*2:\r\ninx = 0;\r\nbreak;\r\n}\r\nreturn inx;\r\n}\r\nunsigned int update_basic_rate23a(unsigned char *ptn, unsigned int ptn_sz)\r\n{\r\nunsigned int i, num_of_rate;\r\nunsigned int mask = 0;\r\nnum_of_rate = (ptn_sz > NumRates)? NumRates: ptn_sz;\r\nfor (i = 0; i < num_of_rate; i++) {\r\nif ((*(ptn + i)) & 0x80)\r\nmask |= 0x1 << wifirate2_ratetbl_inx23a(*(ptn + i));\r\n}\r\nreturn mask;\r\n}\r\nunsigned int update_supported_rate23a(unsigned char *ptn, unsigned int ptn_sz)\r\n{\r\nunsigned int i, num_of_rate;\r\nunsigned int mask = 0;\r\nnum_of_rate = (ptn_sz > NumRates) ? NumRates : ptn_sz;\r\nfor (i = 0; i < num_of_rate; i++)\r\nmask |= 0x1 << wifirate2_ratetbl_inx23a(*(ptn + i));\r\nreturn mask;\r\n}\r\nunsigned int update_MSC_rate23a(struct ieee80211_ht_cap *pHT_caps)\r\n{\r\nunsigned int mask;\r\nmask = pHT_caps->mcs.rx_mask[0] << 12 |\r\npHT_caps->mcs.rx_mask[1] << 20;\r\nreturn mask;\r\n}\r\nint support_short_GI23a(struct rtw_adapter *padapter,\r\nstruct ieee80211_ht_cap *pHT_caps)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nunsigned char bit_offset;\r\nif (!pmlmeinfo->HT_enable)\r\nreturn _FAIL;\r\nif (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_RALINK)\r\nreturn _FAIL;\r\nbit_offset = (pmlmeext->cur_bwmode & HT_CHANNEL_WIDTH_40)? 6: 5;\r\nif (pHT_caps->cap_info & cpu_to_le16(0x1 << bit_offset))\r\nreturn _SUCCESS;\r\nelse\r\nreturn _FAIL;\r\n}\r\nunsigned char get_highest_rate_idx23a(u32 mask)\r\n{\r\nint i;\r\nunsigned char rate_idx = 0;\r\nfor (i = 27; i >= 0; i--) {\r\nif (mask & BIT(i)) {\r\nrate_idx = i;\r\nbreak;\r\n}\r\n}\r\nreturn rate_idx;\r\n}\r\nvoid Update_RA_Entry23a(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nrtw_hal_update_ra_mask23a(psta, 0);\r\n}\r\nstatic void enable_rate_adaptive(struct rtw_adapter *padapter,\r\nstruct sta_info *psta)\r\n{\r\nUpdate_RA_Entry23a(padapter, psta);\r\n}\r\nvoid set_sta_rate23a(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nenable_rate_adaptive(padapter, psta);\r\n}\r\nvoid update_tx_basic_rate23a(struct rtw_adapter *padapter, u8 wirelessmode)\r\n{\r\nunsigned char supported_rates[NDIS_802_11_LENGTH_RATES_EX];\r\nmemset(supported_rates, 0, NDIS_802_11_LENGTH_RATES_EX);\r\nif (wirelessmode == WIRELESS_11B) {\r\nmemcpy(supported_rates, rtw_basic_rate_cck, 4);\r\n} else if (wirelessmode & WIRELESS_11B) {\r\nmemcpy(supported_rates, rtw_basic_rate_mix, 7);\r\n} else {\r\nmemcpy(supported_rates, rtw_basic_rate_ofdm, 3);\r\n}\r\nif (wirelessmode & WIRELESS_11B)\r\nupdate_mgnt_tx_rate23a(padapter, IEEE80211_CCK_RATE_1MB);\r\nelse\r\nupdate_mgnt_tx_rate23a(padapter, IEEE80211_OFDM_RATE_6MB);\r\nHalSetBrateCfg23a(padapter, supported_rates);\r\n}\r\nunsigned char check_assoc_AP23a(u8 *pframe, uint len)\r\n{\r\nint i;\r\nu8 epigram_vendor_flag;\r\nu8 ralink_vendor_flag;\r\nconst u8 *p;\r\nepigram_vendor_flag = 0;\r\nralink_vendor_flag = 0;\r\nfor (i = 0; i < len;) {\r\np = pframe + i;\r\nswitch (p[0]) {\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nif (!memcmp(p + 2, ARTHEROS_OUI1, 3) ||\r\n!memcmp(p + 2, ARTHEROS_OUI2, 3)) {\r\nDBG_8723A("link to Artheros AP\n");\r\nreturn HT_IOT_PEER_ATHEROS;\r\n} else if (!memcmp(p + 2, BROADCOM_OUI1, 3) ||\r\n!memcmp(p + 2, BROADCOM_OUI2, 3)) {\r\nDBG_8723A("link to Broadcom AP\n");\r\nreturn HT_IOT_PEER_BROADCOM;\r\n} else if (!memcmp(p + 2, MARVELL_OUI, 3)) {\r\nDBG_8723A("link to Marvell AP\n");\r\nreturn HT_IOT_PEER_MARVELL;\r\n} else if (!memcmp(p + 2, RALINK_OUI, 3)) {\r\nif (!ralink_vendor_flag)\r\nralink_vendor_flag = 1;\r\nelse {\r\nDBG_8723A("link to Ralink AP\n");\r\nreturn HT_IOT_PEER_RALINK;\r\n}\r\n} else if (!memcmp(p + 2, CISCO_OUI, 3)) {\r\nDBG_8723A("link to Cisco AP\n");\r\nreturn HT_IOT_PEER_CISCO;\r\n} else if (!memcmp(p + 2, REALTEK_OUI, 3)) {\r\nDBG_8723A("link to Realtek 96B\n");\r\nreturn HT_IOT_PEER_REALTEK;\r\n} else if (!memcmp(p + 2, AIRGOCAP_OUI, 3)) {\r\nDBG_8723A("link to Airgo Cap\n");\r\nreturn HT_IOT_PEER_AIRGO;\r\n} else if (!memcmp(p + 2, EPIGRAM_OUI, 3)) {\r\nepigram_vendor_flag = 1;\r\nif (ralink_vendor_flag) {\r\nDBG_8723A("link to Tenda W311R AP\n");\r\nreturn HT_IOT_PEER_TENDA;\r\n} else\r\nDBG_8723A("Capture EPIGRAM_OUI\n");\r\n} else\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ni += (p[1] + 2);\r\n}\r\nif (ralink_vendor_flag && !epigram_vendor_flag) {\r\nDBG_8723A("link to Ralink AP\n");\r\nreturn HT_IOT_PEER_RALINK;\r\n} else if (ralink_vendor_flag && epigram_vendor_flag) {\r\nDBG_8723A("link to Tenda W311R AP\n");\r\nreturn HT_IOT_PEER_TENDA;\r\n} else {\r\nDBG_8723A("link to new AP\n");\r\nreturn HT_IOT_PEER_UNKNOWN;\r\n}\r\n}\r\nvoid update_IOT_info23a(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nswitch (pmlmeinfo->assoc_AP_vendor) {\r\ncase HT_IOT_PEER_MARVELL:\r\npmlmeinfo->turboMode_cts2self = 1;\r\npmlmeinfo->turboMode_rtsen = 0;\r\nbreak;\r\ncase HT_IOT_PEER_RALINK:\r\npmlmeinfo->turboMode_cts2self = 0;\r\npmlmeinfo->turboMode_rtsen = 1;\r\nrtl8723a_odm_support_ability_clr(padapter, (u32)\r\n~DYNAMIC_BB_DYNAMIC_TXPWR);\r\nbreak;\r\ncase HT_IOT_PEER_REALTEK:\r\nrtl8723a_odm_support_ability_clr(padapter, (u32)\r\n~DYNAMIC_BB_DYNAMIC_TXPWR);\r\nbreak;\r\ndefault:\r\npmlmeinfo->turboMode_cts2self = 0;\r\npmlmeinfo->turboMode_rtsen = 1;\r\nbreak;\r\n}\r\n}\r\nvoid update_capinfo23a(struct rtw_adapter *Adapter, u16 updateCap)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nif (updateCap & cShortPreamble) {\r\nif (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) {\r\npmlmeinfo->preamble_mode = PREAMBLE_SHORT;\r\nrtl8723a_ack_preamble(Adapter, true);\r\n}\r\n} else {\r\nif (pmlmeinfo->preamble_mode != PREAMBLE_LONG) {\r\npmlmeinfo->preamble_mode = PREAMBLE_LONG;\r\nrtl8723a_ack_preamble(Adapter, false);\r\n}\r\n}\r\nif (updateCap & cIBSS) {\r\npmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;\r\n} else {\r\nif (pmlmeext->cur_wireless_mode &\r\n(WIRELESS_11G | WIRELESS_11_24N)) {\r\nif (updateCap & cShortSlotTime) {\r\nif (pmlmeinfo->slotTime != SHORT_SLOT_TIME)\r\npmlmeinfo->slotTime = SHORT_SLOT_TIME;\r\n} else {\r\nif (pmlmeinfo->slotTime != NON_SHORT_SLOT_TIME)\r\npmlmeinfo->slotTime =\r\nNON_SHORT_SLOT_TIME;\r\n}\r\n} else if (pmlmeext->cur_wireless_mode &\r\n(WIRELESS_11A | WIRELESS_11_5N)) {\r\npmlmeinfo->slotTime = SHORT_SLOT_TIME;\r\n} else {\r\npmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;\r\n}\r\n}\r\nrtl8723a_set_slot_time(Adapter, pmlmeinfo->slotTime);\r\n}\r\nvoid update_wireless_mode23a(struct rtw_adapter *padapter)\r\n{\r\nint ratelen, network_type = 0;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct wlan_bssid_ex *cur_network = &pmlmeinfo->network;\r\nunsigned char *rate = cur_network->SupportedRates;\r\nratelen = rtw_get_rateset_len23a(cur_network->SupportedRates);\r\nif ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable))\r\npmlmeinfo->HT_enable = 1;\r\nif (pmlmeext->cur_channel > 14) {\r\nif (pmlmeinfo->HT_enable)\r\nnetwork_type = WIRELESS_11_5N;\r\nnetwork_type |= WIRELESS_11A;\r\n} else {\r\nif (pmlmeinfo->HT_enable)\r\nnetwork_type = WIRELESS_11_24N;\r\nif (cckratesonly_included23a(rate, ratelen) == true)\r\nnetwork_type |= WIRELESS_11B;\r\nelse if (cckrates_included23a(rate, ratelen) == true)\r\nnetwork_type |= WIRELESS_11BG;\r\nelse\r\nnetwork_type |= WIRELESS_11G;\r\n}\r\npmlmeext->cur_wireless_mode =\r\nnetwork_type & padapter->registrypriv.wireless_mode;\r\nrtl8723a_set_resp_sifs(padapter, 0x08, 0x08, 0x0a, 0x0a);\r\nif (pmlmeext->cur_wireless_mode & WIRELESS_11B)\r\nupdate_mgnt_tx_rate23a(padapter, IEEE80211_CCK_RATE_1MB);\r\nelse\r\nupdate_mgnt_tx_rate23a(padapter, IEEE80211_OFDM_RATE_6MB);\r\n}\r\nvoid update_bmc_sta_support_rate23a(struct rtw_adapter *padapter, u32 mac_id)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nif (pmlmeext->cur_wireless_mode & WIRELESS_11B) {\r\nmemcpy((pmlmeinfo->FW_sta_info[mac_id].SupportedRates),\r\nrtw_basic_rate_cck, 4);\r\n} else {\r\nmemcpy(pmlmeinfo->FW_sta_info[mac_id].SupportedRates,\r\nrtw_basic_rate_ofdm, 3);\r\n}\r\n}\r\nint update_sta_support_rate23a(struct rtw_adapter *padapter, u8 *pvar_ie,\r\nuint var_ie_len, int cam_idx)\r\n{\r\nint supportRateNum = 0;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nconst u8 *p;\r\np = cfg80211_find_ie(WLAN_EID_SUPP_RATES, pvar_ie, var_ie_len);\r\nif (!p)\r\nreturn _FAIL;\r\nmemcpy(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates, p + 2, p[1]);\r\nsupportRateNum = p[1];\r\np = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES, pvar_ie, var_ie_len);\r\nif (p)\r\nmemcpy(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates +\r\nsupportRateNum, p + 2, p[1]);\r\nreturn _SUCCESS;\r\n}\r\nvoid process_addba_req23a(struct rtw_adapter *padapter,\r\nu8 *paddba_req, u8 *addr)\r\n{\r\nstruct sta_info *psta;\r\nu16 tid, start_seq, param;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct ADDBA_request *preq = (struct ADDBA_request *)paddba_req;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\npsta = rtw_get_stainfo23a(pstapriv, addr);\r\nif (psta) {\r\nstart_seq = le16_to_cpu(preq->BA_starting_seqctrl) >> 4;\r\nparam = le16_to_cpu(preq->BA_para_set);\r\ntid = (param >> 2) & 0x0f;\r\npreorder_ctrl = &psta->recvreorder_ctrl[tid];\r\npreorder_ctrl->indicate_seq = 0xffff;\r\npreorder_ctrl->enable = (pmlmeinfo->bAcceptAddbaReq == true) ?\r\ntrue : false;\r\n}\r\n}
