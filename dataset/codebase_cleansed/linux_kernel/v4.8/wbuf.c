static int jffs2_wbuf_pending_for_ino(struct jffs2_sb_info *c, uint32_t ino)\r\n{\r\nstruct jffs2_inodirty *this = c->wbuf_inodes;\r\nif (this == &inodirty_nomem)\r\nreturn 1;\r\nif (this && !ino)\r\nreturn 1;\r\nwhile (this) {\r\nif (this->ino == ino)\r\nreturn 1;\r\nthis = this->next;\r\n}\r\nreturn 0;\r\n}\r\nstatic void jffs2_clear_wbuf_ino_list(struct jffs2_sb_info *c)\r\n{\r\nstruct jffs2_inodirty *this;\r\nthis = c->wbuf_inodes;\r\nif (this != &inodirty_nomem) {\r\nwhile (this) {\r\nstruct jffs2_inodirty *next = this->next;\r\nkfree(this);\r\nthis = next;\r\n}\r\n}\r\nc->wbuf_inodes = NULL;\r\n}\r\nstatic void jffs2_wbuf_dirties_inode(struct jffs2_sb_info *c, uint32_t ino)\r\n{\r\nstruct jffs2_inodirty *new;\r\njffs2_dirty_trigger(c);\r\nif (jffs2_wbuf_pending_for_ino(c, ino))\r\nreturn;\r\nnew = kmalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new) {\r\njffs2_dbg(1, "No memory to allocate inodirty. Fallback to all considered dirty\n");\r\njffs2_clear_wbuf_ino_list(c);\r\nc->wbuf_inodes = &inodirty_nomem;\r\nreturn;\r\n}\r\nnew->ino = ino;\r\nnew->next = c->wbuf_inodes;\r\nc->wbuf_inodes = new;\r\nreturn;\r\n}\r\nstatic inline void jffs2_refile_wbuf_blocks(struct jffs2_sb_info *c)\r\n{\r\nstruct list_head *this, *next;\r\nstatic int n;\r\nif (list_empty(&c->erasable_pending_wbuf_list))\r\nreturn;\r\nlist_for_each_safe(this, next, &c->erasable_pending_wbuf_list) {\r\nstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\r\njffs2_dbg(1, "Removing eraseblock at 0x%08x from erasable_pending_wbuf_list...\n",\r\njeb->offset);\r\nlist_del(this);\r\nif ((jiffies + (n++)) & 127) {\r\njffs2_dbg(1, "...and adding to erase_pending_list\n");\r\nlist_add_tail(&jeb->list, &c->erase_pending_list);\r\nc->nr_erasing_blocks++;\r\njffs2_garbage_collect_trigger(c);\r\n} else {\r\njffs2_dbg(1, "...and adding to erasable_list\n");\r\nlist_add_tail(&jeb->list, &c->erasable_list);\r\n}\r\n}\r\n}\r\nstatic void jffs2_block_refile(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, int allow_empty)\r\n{\r\njffs2_dbg(1, "About to refile bad block at %08x\n", jeb->offset);\r\nif (c->nextblock == jeb)\r\nc->nextblock = NULL;\r\nelse\r\nlist_del(&jeb->list);\r\nif (jeb->first_node) {\r\njffs2_dbg(1, "Refiling block at %08x to bad_used_list\n",\r\njeb->offset);\r\nlist_add(&jeb->list, &c->bad_used_list);\r\n} else {\r\nBUG_ON(allow_empty == REFILE_NOTEMPTY);\r\njffs2_dbg(1, "Refiling block at %08x to erase_pending_list\n",\r\njeb->offset);\r\nlist_add(&jeb->list, &c->erase_pending_list);\r\nc->nr_erasing_blocks++;\r\njffs2_garbage_collect_trigger(c);\r\n}\r\nif (!jffs2_prealloc_raw_node_refs(c, jeb, 1)) {\r\nuint32_t oldfree = jeb->free_size;\r\njffs2_link_node_ref(c, jeb,\r\n(jeb->offset+c->sector_size-oldfree) | REF_OBSOLETE,\r\noldfree, NULL);\r\nc->wasted_size += oldfree;\r\njeb->wasted_size += oldfree;\r\nc->dirty_size -= oldfree;\r\njeb->dirty_size -= oldfree;\r\n}\r\njffs2_dbg_dump_block_lists_nolock(c);\r\njffs2_dbg_acct_sanity_check_nolock(c,jeb);\r\njffs2_dbg_acct_paranoia_check_nolock(c, jeb);\r\n}\r\nstatic struct jffs2_raw_node_ref **jffs2_incore_replace_raw(struct jffs2_sb_info *c,\r\nstruct jffs2_inode_info *f,\r\nstruct jffs2_raw_node_ref *raw,\r\nunion jffs2_node_union *node)\r\n{\r\nstruct jffs2_node_frag *frag;\r\nstruct jffs2_full_dirent *fd;\r\ndbg_noderef("incore_replace_raw: node at %p is {%04x,%04x}\n",\r\nnode, je16_to_cpu(node->u.magic), je16_to_cpu(node->u.nodetype));\r\nBUG_ON(je16_to_cpu(node->u.magic) != 0x1985 &&\r\nje16_to_cpu(node->u.magic) != 0);\r\nswitch (je16_to_cpu(node->u.nodetype)) {\r\ncase JFFS2_NODETYPE_INODE:\r\nif (f->metadata && f->metadata->raw == raw) {\r\ndbg_noderef("Will replace ->raw in f->metadata at %p\n", f->metadata);\r\nreturn &f->metadata->raw;\r\n}\r\nfrag = jffs2_lookup_node_frag(&f->fragtree, je32_to_cpu(node->i.offset));\r\nBUG_ON(!frag);\r\nwhile (!frag->node || frag->node->raw != raw) {\r\nfrag = frag_next(frag);\r\nBUG_ON(!frag);\r\n}\r\ndbg_noderef("Will replace ->raw in full_dnode at %p\n", frag->node);\r\nreturn &frag->node->raw;\r\ncase JFFS2_NODETYPE_DIRENT:\r\nfor (fd = f->dents; fd; fd = fd->next) {\r\nif (fd->raw == raw) {\r\ndbg_noderef("Will replace ->raw in full_dirent at %p\n", fd);\r\nreturn &fd->raw;\r\n}\r\n}\r\nBUG();\r\ndefault:\r\ndbg_noderef("Don't care about replacing raw for nodetype %x\n",\r\nje16_to_cpu(node->u.nodetype));\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int jffs2_verify_write(struct jffs2_sb_info *c, unsigned char *buf,\r\nuint32_t ofs)\r\n{\r\nint ret;\r\nsize_t retlen;\r\nchar *eccstr;\r\nret = mtd_read(c->mtd, ofs, c->wbuf_pagesize, &retlen, c->wbuf_verify);\r\nif (ret && ret != -EUCLEAN && ret != -EBADMSG) {\r\npr_warn("%s(): Read back of page at %08x failed: %d\n",\r\n__func__, c->wbuf_ofs, ret);\r\nreturn ret;\r\n} else if (retlen != c->wbuf_pagesize) {\r\npr_warn("%s(): Read back of page at %08x gave short read: %zd not %d\n",\r\n__func__, ofs, retlen, c->wbuf_pagesize);\r\nreturn -EIO;\r\n}\r\nif (!memcmp(buf, c->wbuf_verify, c->wbuf_pagesize))\r\nreturn 0;\r\nif (ret == -EUCLEAN)\r\neccstr = "corrected";\r\nelse if (ret == -EBADMSG)\r\neccstr = "correction failed";\r\nelse\r\neccstr = "OK or unused";\r\npr_warn("Write verify error (ECC %s) at %08x. Wrote:\n",\r\neccstr, c->wbuf_ofs);\r\nprint_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 16, 1,\r\nc->wbuf, c->wbuf_pagesize, 0);\r\npr_warn("Read back:\n");\r\nprint_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 16, 1,\r\nc->wbuf_verify, c->wbuf_pagesize, 0);\r\nreturn -EIO;\r\n}\r\nstatic void jffs2_wbuf_recover(struct jffs2_sb_info *c)\r\n{\r\nstruct jffs2_eraseblock *jeb, *new_jeb;\r\nstruct jffs2_raw_node_ref *raw, *next, *first_raw = NULL;\r\nsize_t retlen;\r\nint ret;\r\nint nr_refile = 0;\r\nunsigned char *buf;\r\nuint32_t start, end, ofs, len;\r\njeb = &c->blocks[c->wbuf_ofs / c->sector_size];\r\nspin_lock(&c->erase_completion_lock);\r\nif (c->wbuf_ofs % c->mtd->erasesize)\r\njffs2_block_refile(c, jeb, REFILE_NOTEMPTY);\r\nelse\r\njffs2_block_refile(c, jeb, REFILE_ANYWAY);\r\nspin_unlock(&c->erase_completion_lock);\r\nBUG_ON(!ref_obsolete(jeb->last_node));\r\nfor (next = raw = jeb->first_node; next; raw = next) {\r\nnext = ref_next(raw);\r\nif (ref_obsolete(raw) ||\r\n(next && ref_offset(next) <= c->wbuf_ofs)) {\r\ndbg_noderef("Skipping node at 0x%08x(%d)-0x%08x which is either before 0x%08x or obsolete\n",\r\nref_offset(raw), ref_flags(raw),\r\n(ref_offset(raw) + ref_totlen(c, jeb, raw)),\r\nc->wbuf_ofs);\r\ncontinue;\r\n}\r\ndbg_noderef("First node to be recovered is at 0x%08x(%d)-0x%08x\n",\r\nref_offset(raw), ref_flags(raw),\r\n(ref_offset(raw) + ref_totlen(c, jeb, raw)));\r\nfirst_raw = raw;\r\nbreak;\r\n}\r\nif (!first_raw) {\r\njffs2_dbg(1, "No non-obsolete nodes to be recovered. Just filing block bad\n");\r\nc->wbuf_len = 0;\r\nreturn;\r\n}\r\nstart = ref_offset(first_raw);\r\nend = ref_offset(jeb->last_node);\r\nnr_refile = 1;\r\nwhile ((raw = ref_next(raw)) != jeb->last_node)\r\nnr_refile++;\r\ndbg_noderef("wbuf recover %08x-%08x (%d bytes in %d nodes)\n",\r\nstart, end, end - start, nr_refile);\r\nbuf = NULL;\r\nif (start < c->wbuf_ofs) {\r\nbuf = kmalloc(end - start, GFP_KERNEL);\r\nif (!buf) {\r\npr_crit("Malloc failure in wbuf recovery. Data loss ensues.\n");\r\ngoto read_failed;\r\n}\r\nret = mtd_read(c->mtd, start, c->wbuf_ofs - start, &retlen,\r\nbuf);\r\nif ((ret == -EUCLEAN || ret == -EBADMSG) &&\r\n(retlen == c->wbuf_ofs - start))\r\nret = 0;\r\nif (ret || retlen != c->wbuf_ofs - start) {\r\npr_crit("Old data are already lost in wbuf recovery. Data loss ensues.\n");\r\nkfree(buf);\r\nbuf = NULL;\r\nread_failed:\r\nfirst_raw = ref_next(first_raw);\r\nnr_refile--;\r\nwhile (first_raw && ref_obsolete(first_raw)) {\r\nfirst_raw = ref_next(first_raw);\r\nnr_refile--;\r\n}\r\nif (!first_raw) {\r\nc->wbuf_len = 0;\r\nreturn;\r\n}\r\nstart = ref_offset(first_raw);\r\ndbg_noderef("wbuf now recover %08x-%08x (%d bytes in %d nodes)\n",\r\nstart, end, end - start, nr_refile);\r\n} else {\r\nmemcpy(buf + (c->wbuf_ofs - start), c->wbuf, end - c->wbuf_ofs);\r\n}\r\n}\r\nret = jffs2_reserve_space_gc(c, end-start, &len, JFFS2_SUMMARY_NOSUM_SIZE);\r\nif (ret) {\r\npr_warn("Failed to allocate space for wbuf recovery. Data loss ensues.\n");\r\nkfree(buf);\r\nreturn;\r\n}\r\njffs2_sum_disable_collecting(c->summary);\r\nret = jffs2_prealloc_raw_node_refs(c, c->nextblock, nr_refile);\r\nif (ret) {\r\npr_warn("Failed to allocate node refs for wbuf recovery. Data loss ensues.\n");\r\nkfree(buf);\r\nreturn;\r\n}\r\nofs = write_ofs(c);\r\nif (end-start >= c->wbuf_pagesize) {\r\nunsigned char *rewrite_buf = buf?:c->wbuf;\r\nuint32_t towrite = (end-start) - ((end-start)%c->wbuf_pagesize);\r\njffs2_dbg(1, "Write 0x%x bytes at 0x%08x in wbuf recover\n",\r\ntowrite, ofs);\r\n#ifdef BREAKMEHEADER\r\nstatic int breakme;\r\nif (breakme++ == 20) {\r\npr_notice("Faking write error at 0x%08x\n", ofs);\r\nbreakme = 0;\r\nmtd_write(c->mtd, ofs, towrite, &retlen, brokenbuf);\r\nret = -EIO;\r\n} else\r\n#endif\r\nret = mtd_write(c->mtd, ofs, towrite, &retlen,\r\nrewrite_buf);\r\nif (ret || retlen != towrite || jffs2_verify_write(c, rewrite_buf, ofs)) {\r\npr_crit("Recovery of wbuf failed due to a second write error\n");\r\nkfree(buf);\r\nif (retlen)\r\njffs2_add_physical_node_ref(c, ofs | REF_OBSOLETE, ref_totlen(c, jeb, first_raw), NULL);\r\nreturn;\r\n}\r\npr_notice("Recovery of wbuf succeeded to %08x\n", ofs);\r\nc->wbuf_len = (end - start) - towrite;\r\nc->wbuf_ofs = ofs + towrite;\r\nmemmove(c->wbuf, rewrite_buf + towrite, c->wbuf_len);\r\n} else {\r\nif (buf) {\r\nmemcpy(c->wbuf, buf, end-start);\r\n} else {\r\nmemmove(c->wbuf, c->wbuf + (start - c->wbuf_ofs), end - start);\r\n}\r\nc->wbuf_ofs = ofs;\r\nc->wbuf_len = end - start;\r\n}\r\nnew_jeb = &c->blocks[ofs / c->sector_size];\r\nspin_lock(&c->erase_completion_lock);\r\nfor (raw = first_raw; raw != jeb->last_node; raw = ref_next(raw)) {\r\nuint32_t rawlen = ref_totlen(c, jeb, raw);\r\nstruct jffs2_inode_cache *ic;\r\nstruct jffs2_raw_node_ref *new_ref;\r\nstruct jffs2_raw_node_ref **adjust_ref = NULL;\r\nstruct jffs2_inode_info *f = NULL;\r\njffs2_dbg(1, "Refiling block of %08x at %08x(%d) to %08x\n",\r\nrawlen, ref_offset(raw), ref_flags(raw), ofs);\r\nic = jffs2_raw_ref_to_ic(raw);\r\nif (ic && ic->class == RAWNODE_CLASS_XATTR_DATUM) {\r\nstruct jffs2_xattr_datum *xd = (void *)ic;\r\nBUG_ON(xd->node != raw);\r\nadjust_ref = &xd->node;\r\nraw->next_in_ino = NULL;\r\nic = NULL;\r\n} else if (ic && ic->class == RAWNODE_CLASS_XATTR_REF) {\r\nstruct jffs2_xattr_datum *xr = (void *)ic;\r\nBUG_ON(xr->node != raw);\r\nadjust_ref = &xr->node;\r\nraw->next_in_ino = NULL;\r\nic = NULL;\r\n} else if (ic && ic->class == RAWNODE_CLASS_INODE_CACHE) {\r\nstruct jffs2_raw_node_ref **p = &ic->nodes;\r\nwhile (*p && *p != (void *)ic) {\r\nif (*p == raw) {\r\n(*p) = (raw->next_in_ino);\r\nraw->next_in_ino = NULL;\r\nbreak;\r\n}\r\np = &((*p)->next_in_ino);\r\n}\r\nif (ic->state == INO_STATE_PRESENT && !ref_obsolete(raw)) {\r\nf = jffs2_gc_fetch_inode(c, ic->ino, !ic->pino_nlink);\r\nif (IS_ERR(f)) {\r\nJFFS2_ERROR("Failed to iget() ino #%u, err %ld\n",\r\nic->ino, PTR_ERR(f));\r\nBUG();\r\n}\r\nadjust_ref = jffs2_incore_replace_raw(c, f, raw,\r\n(void *)(buf?:c->wbuf) + (ref_offset(raw) - start));\r\n} else if (unlikely(ic->state != INO_STATE_PRESENT &&\r\nic->state != INO_STATE_CHECKEDABSENT &&\r\nic->state != INO_STATE_GC)) {\r\nJFFS2_ERROR("Inode #%u is in strange state %d!\n", ic->ino, ic->state);\r\nBUG();\r\n}\r\n}\r\nnew_ref = jffs2_link_node_ref(c, new_jeb, ofs | ref_flags(raw), rawlen, ic);\r\nif (adjust_ref) {\r\nBUG_ON(*adjust_ref != raw);\r\n*adjust_ref = new_ref;\r\n}\r\nif (f)\r\njffs2_gc_release_inode(c, f);\r\nif (!ref_obsolete(raw)) {\r\njeb->dirty_size += rawlen;\r\njeb->used_size -= rawlen;\r\nc->dirty_size += rawlen;\r\nc->used_size -= rawlen;\r\nraw->flash_offset = ref_offset(raw) | REF_OBSOLETE;\r\nBUG_ON(raw->next_in_ino);\r\n}\r\nofs += rawlen;\r\n}\r\nkfree(buf);\r\nif (first_raw == jeb->first_node) {\r\njffs2_dbg(1, "Failing block at %08x is now empty. Moving to erase_pending_list\n",\r\njeb->offset);\r\nlist_move(&jeb->list, &c->erase_pending_list);\r\nc->nr_erasing_blocks++;\r\njffs2_garbage_collect_trigger(c);\r\n}\r\njffs2_dbg_acct_sanity_check_nolock(c, jeb);\r\njffs2_dbg_acct_paranoia_check_nolock(c, jeb);\r\njffs2_dbg_acct_sanity_check_nolock(c, new_jeb);\r\njffs2_dbg_acct_paranoia_check_nolock(c, new_jeb);\r\nspin_unlock(&c->erase_completion_lock);\r\njffs2_dbg(1, "wbuf recovery completed OK. wbuf_ofs 0x%08x, len 0x%x\n",\r\nc->wbuf_ofs, c->wbuf_len);\r\n}\r\nstatic int __jffs2_flush_wbuf(struct jffs2_sb_info *c, int pad)\r\n{\r\nstruct jffs2_eraseblock *wbuf_jeb;\r\nint ret;\r\nsize_t retlen;\r\nif (!jffs2_is_writebuffered(c))\r\nreturn 0;\r\nif (!mutex_is_locked(&c->alloc_sem)) {\r\npr_crit("jffs2_flush_wbuf() called with alloc_sem not locked!\n");\r\nBUG();\r\n}\r\nif (!c->wbuf_len)\r\nreturn 0;\r\nwbuf_jeb = &c->blocks[c->wbuf_ofs / c->sector_size];\r\nif (jffs2_prealloc_raw_node_refs(c, wbuf_jeb, c->nextblock->allocated_refs + 1))\r\nreturn -ENOMEM;\r\nif (pad ) {\r\nc->wbuf_len = PAD(c->wbuf_len);\r\nmemset(c->wbuf + c->wbuf_len, 0, c->wbuf_pagesize - c->wbuf_len);\r\nif ( c->wbuf_len + sizeof(struct jffs2_unknown_node) < c->wbuf_pagesize) {\r\nstruct jffs2_unknown_node *padnode = (void *)(c->wbuf + c->wbuf_len);\r\npadnode->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\r\npadnode->nodetype = cpu_to_je16(JFFS2_NODETYPE_PADDING);\r\npadnode->totlen = cpu_to_je32(c->wbuf_pagesize - c->wbuf_len);\r\npadnode->hdr_crc = cpu_to_je32(crc32(0, padnode, sizeof(*padnode)-4));\r\n}\r\n}\r\n#ifdef BREAKME\r\nstatic int breakme;\r\nif (breakme++ == 20) {\r\npr_notice("Faking write error at 0x%08x\n", c->wbuf_ofs);\r\nbreakme = 0;\r\nmtd_write(c->mtd, c->wbuf_ofs, c->wbuf_pagesize, &retlen,\r\nbrokenbuf);\r\nret = -EIO;\r\n} else\r\n#endif\r\nret = mtd_write(c->mtd, c->wbuf_ofs, c->wbuf_pagesize,\r\n&retlen, c->wbuf);\r\nif (ret) {\r\npr_warn("jffs2_flush_wbuf(): Write failed with %d\n", ret);\r\ngoto wfail;\r\n} else if (retlen != c->wbuf_pagesize) {\r\npr_warn("jffs2_flush_wbuf(): Write was short: %zd instead of %d\n",\r\nretlen, c->wbuf_pagesize);\r\nret = -EIO;\r\ngoto wfail;\r\n} else if ((ret = jffs2_verify_write(c, c->wbuf, c->wbuf_ofs))) {\r\nwfail:\r\njffs2_wbuf_recover(c);\r\nreturn ret;\r\n}\r\nif (pad) {\r\nuint32_t waste = c->wbuf_pagesize - c->wbuf_len;\r\njffs2_dbg(1, "jffs2_flush_wbuf() adjusting free_size of %sblock at %08x\n",\r\n(wbuf_jeb == c->nextblock) ? "next" : "",\r\nwbuf_jeb->offset);\r\nif (wbuf_jeb->free_size < waste) {\r\npr_crit("jffs2_flush_wbuf(): Accounting error. wbuf at 0x%08x has 0x%03x bytes, 0x%03x left.\n",\r\nc->wbuf_ofs, c->wbuf_len, waste);\r\npr_crit("jffs2_flush_wbuf(): But free_size for block at 0x%08x is only 0x%08x\n",\r\nwbuf_jeb->offset, wbuf_jeb->free_size);\r\nBUG();\r\n}\r\nspin_lock(&c->erase_completion_lock);\r\njffs2_link_node_ref(c, wbuf_jeb, (c->wbuf_ofs + c->wbuf_len) | REF_OBSOLETE, waste, NULL);\r\nwbuf_jeb->dirty_size -= waste;\r\nc->dirty_size -= waste;\r\nwbuf_jeb->wasted_size += waste;\r\nc->wasted_size += waste;\r\n} else\r\nspin_lock(&c->erase_completion_lock);\r\njffs2_refile_wbuf_blocks(c);\r\njffs2_clear_wbuf_ino_list(c);\r\nspin_unlock(&c->erase_completion_lock);\r\nmemset(c->wbuf,0xff,c->wbuf_pagesize);\r\nc->wbuf_ofs += c->wbuf_pagesize;\r\nc->wbuf_len = 0;\r\nreturn 0;\r\n}\r\nint jffs2_flush_wbuf_gc(struct jffs2_sb_info *c, uint32_t ino)\r\n{\r\nuint32_t old_wbuf_ofs;\r\nuint32_t old_wbuf_len;\r\nint ret = 0;\r\njffs2_dbg(1, "jffs2_flush_wbuf_gc() called for ino #%u...\n", ino);\r\nif (!c->wbuf)\r\nreturn 0;\r\nmutex_lock(&c->alloc_sem);\r\nif (!jffs2_wbuf_pending_for_ino(c, ino)) {\r\njffs2_dbg(1, "Ino #%d not pending in wbuf. Returning\n", ino);\r\nmutex_unlock(&c->alloc_sem);\r\nreturn 0;\r\n}\r\nold_wbuf_ofs = c->wbuf_ofs;\r\nold_wbuf_len = c->wbuf_len;\r\nif (c->unchecked_size) {\r\njffs2_dbg(1, "%s(): padding. Not finished checking\n",\r\n__func__);\r\ndown_write(&c->wbuf_sem);\r\nret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\r\nif (ret)\r\nret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\r\nup_write(&c->wbuf_sem);\r\n} else while (old_wbuf_len &&\r\nold_wbuf_ofs == c->wbuf_ofs) {\r\nmutex_unlock(&c->alloc_sem);\r\njffs2_dbg(1, "%s(): calls gc pass\n", __func__);\r\nret = jffs2_garbage_collect_pass(c);\r\nif (ret) {\r\nmutex_lock(&c->alloc_sem);\r\ndown_write(&c->wbuf_sem);\r\nret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\r\nif (ret)\r\nret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\r\nup_write(&c->wbuf_sem);\r\nbreak;\r\n}\r\nmutex_lock(&c->alloc_sem);\r\n}\r\njffs2_dbg(1, "%s(): ends...\n", __func__);\r\nmutex_unlock(&c->alloc_sem);\r\nreturn ret;\r\n}\r\nint jffs2_flush_wbuf_pad(struct jffs2_sb_info *c)\r\n{\r\nint ret;\r\nif (!c->wbuf)\r\nreturn 0;\r\ndown_write(&c->wbuf_sem);\r\nret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\r\nif (ret)\r\nret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\r\nup_write(&c->wbuf_sem);\r\nreturn ret;\r\n}\r\nstatic size_t jffs2_fill_wbuf(struct jffs2_sb_info *c, const uint8_t *buf,\r\nsize_t len)\r\n{\r\nif (len && !c->wbuf_len && (len >= c->wbuf_pagesize))\r\nreturn 0;\r\nif (len > (c->wbuf_pagesize - c->wbuf_len))\r\nlen = c->wbuf_pagesize - c->wbuf_len;\r\nmemcpy(c->wbuf + c->wbuf_len, buf, len);\r\nc->wbuf_len += (uint32_t) len;\r\nreturn len;\r\n}\r\nint jffs2_flash_writev(struct jffs2_sb_info *c, const struct kvec *invecs,\r\nunsigned long count, loff_t to, size_t *retlen,\r\nuint32_t ino)\r\n{\r\nstruct jffs2_eraseblock *jeb;\r\nsize_t wbuf_retlen, donelen = 0;\r\nuint32_t outvec_to = to;\r\nint ret, invec;\r\nif (!jffs2_is_writebuffered(c))\r\nreturn jffs2_flash_direct_writev(c, invecs, count, to, retlen);\r\ndown_write(&c->wbuf_sem);\r\nif (c->wbuf_ofs == 0xFFFFFFFF) {\r\nc->wbuf_ofs = PAGE_DIV(to);\r\nc->wbuf_len = PAGE_MOD(to);\r\nmemset(c->wbuf,0xff,c->wbuf_pagesize);\r\n}\r\nif (SECTOR_ADDR(to) != SECTOR_ADDR(c->wbuf_ofs)) {\r\nif (c->wbuf_len) {\r\njffs2_dbg(1, "%s(): to 0x%lx causes flush of wbuf at 0x%08x\n",\r\n__func__, (unsigned long)to, c->wbuf_ofs);\r\nret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\r\nif (ret)\r\ngoto outerr;\r\n}\r\nc->wbuf_ofs = PAGE_DIV(to);\r\nc->wbuf_len = PAGE_MOD(to);\r\n}\r\nif (to != PAD(c->wbuf_ofs + c->wbuf_len)) {\r\npr_crit("%s(): Non-contiguous write to %08lx\n",\r\n__func__, (unsigned long)to);\r\nif (c->wbuf_len)\r\npr_crit("wbuf was previously %08x-%08x\n",\r\nc->wbuf_ofs, c->wbuf_ofs + c->wbuf_len);\r\nBUG();\r\n}\r\nif (c->wbuf_len != PAGE_MOD(to)) {\r\nc->wbuf_len = PAGE_MOD(to);\r\nif (!c->wbuf_len) {\r\nc->wbuf_len = c->wbuf_pagesize;\r\nret = __jffs2_flush_wbuf(c, NOPAD);\r\nif (ret)\r\ngoto outerr;\r\n}\r\n}\r\nfor (invec = 0; invec < count; invec++) {\r\nint vlen = invecs[invec].iov_len;\r\nuint8_t *v = invecs[invec].iov_base;\r\nwbuf_retlen = jffs2_fill_wbuf(c, v, vlen);\r\nif (c->wbuf_len == c->wbuf_pagesize) {\r\nret = __jffs2_flush_wbuf(c, NOPAD);\r\nif (ret)\r\ngoto outerr;\r\n}\r\nvlen -= wbuf_retlen;\r\noutvec_to += wbuf_retlen;\r\ndonelen += wbuf_retlen;\r\nv += wbuf_retlen;\r\nif (vlen >= c->wbuf_pagesize) {\r\nret = mtd_write(c->mtd, outvec_to, PAGE_DIV(vlen),\r\n&wbuf_retlen, v);\r\nif (ret < 0 || wbuf_retlen != PAGE_DIV(vlen))\r\ngoto outfile;\r\nvlen -= wbuf_retlen;\r\noutvec_to += wbuf_retlen;\r\nc->wbuf_ofs = outvec_to;\r\ndonelen += wbuf_retlen;\r\nv += wbuf_retlen;\r\n}\r\nwbuf_retlen = jffs2_fill_wbuf(c, v, vlen);\r\nif (c->wbuf_len == c->wbuf_pagesize) {\r\nret = __jffs2_flush_wbuf(c, NOPAD);\r\nif (ret)\r\ngoto outerr;\r\n}\r\noutvec_to += wbuf_retlen;\r\ndonelen += wbuf_retlen;\r\n}\r\n*retlen = donelen;\r\nif (jffs2_sum_active()) {\r\nint res = jffs2_sum_add_kvec(c, invecs, count, (uint32_t) to);\r\nif (res)\r\nreturn res;\r\n}\r\nif (c->wbuf_len && ino)\r\njffs2_wbuf_dirties_inode(c, ino);\r\nret = 0;\r\nup_write(&c->wbuf_sem);\r\nreturn ret;\r\noutfile:\r\nspin_lock(&c->erase_completion_lock);\r\njeb = &c->blocks[outvec_to / c->sector_size];\r\njffs2_block_refile(c, jeb, REFILE_ANYWAY);\r\nspin_unlock(&c->erase_completion_lock);\r\nouterr:\r\n*retlen = 0;\r\nup_write(&c->wbuf_sem);\r\nreturn ret;\r\n}\r\nint jffs2_flash_write(struct jffs2_sb_info *c, loff_t ofs, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct kvec vecs[1];\r\nif (!jffs2_is_writebuffered(c))\r\nreturn jffs2_flash_direct_write(c, ofs, len, retlen, buf);\r\nvecs[0].iov_base = (unsigned char *) buf;\r\nvecs[0].iov_len = len;\r\nreturn jffs2_flash_writev(c, vecs, 1, ofs, retlen, 0);\r\n}\r\nint jffs2_flash_read(struct jffs2_sb_info *c, loff_t ofs, size_t len, size_t *retlen, u_char *buf)\r\n{\r\nloff_t orbf = 0, owbf = 0, lwbf = 0;\r\nint ret;\r\nif (!jffs2_is_writebuffered(c))\r\nreturn mtd_read(c->mtd, ofs, len, retlen, buf);\r\ndown_read(&c->wbuf_sem);\r\nret = mtd_read(c->mtd, ofs, len, retlen, buf);\r\nif ( (ret == -EBADMSG || ret == -EUCLEAN) && (*retlen == len) ) {\r\nif (ret == -EBADMSG)\r\npr_warn("mtd->read(0x%zx bytes from 0x%llx) returned ECC error\n",\r\nlen, ofs);\r\nret = 0;\r\n}\r\nif (!c->wbuf_pagesize || !c->wbuf_len)\r\ngoto exit;\r\nif (SECTOR_ADDR(ofs) != SECTOR_ADDR(c->wbuf_ofs))\r\ngoto exit;\r\nif (ofs >= c->wbuf_ofs) {\r\nowbf = (ofs - c->wbuf_ofs);\r\nif (owbf > c->wbuf_len)\r\ngoto exit;\r\nlwbf = c->wbuf_len - owbf;\r\nif (lwbf > len)\r\nlwbf = len;\r\n} else {\r\norbf = (c->wbuf_ofs - ofs);\r\nif (orbf > len)\r\ngoto exit;\r\nlwbf = len - orbf;\r\nif (lwbf > c->wbuf_len)\r\nlwbf = c->wbuf_len;\r\n}\r\nif (lwbf > 0)\r\nmemcpy(buf+orbf,c->wbuf+owbf,lwbf);\r\nexit:\r\nup_read(&c->wbuf_sem);\r\nreturn ret;\r\n}\r\nint jffs2_check_oob_empty(struct jffs2_sb_info *c,\r\nstruct jffs2_eraseblock *jeb, int mode)\r\n{\r\nint i, ret;\r\nint cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\r\nstruct mtd_oob_ops ops;\r\nops.mode = MTD_OPS_AUTO_OOB;\r\nops.ooblen = NR_OOB_SCAN_PAGES * c->oobavail;\r\nops.oobbuf = c->oobbuf;\r\nops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\r\nops.datbuf = NULL;\r\nret = mtd_read_oob(c->mtd, jeb->offset, &ops);\r\nif ((ret && !mtd_is_bitflip(ret)) || ops.oobretlen != ops.ooblen) {\r\npr_err("cannot read OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\n",\r\njeb->offset, ops.ooblen, ops.oobretlen, ret);\r\nif (!ret || mtd_is_bitflip(ret))\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nfor(i = 0; i < ops.ooblen; i++) {\r\nif (mode && i < cmlen)\r\ncontinue;\r\nif (ops.oobbuf[i] != 0xFF) {\r\njffs2_dbg(2, "Found %02x at %x in OOB for "\r\n"%08x\n", ops.oobbuf[i], i, jeb->offset);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c,\r\nstruct jffs2_eraseblock *jeb)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint ret, cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\r\nops.mode = MTD_OPS_AUTO_OOB;\r\nops.ooblen = cmlen;\r\nops.oobbuf = c->oobbuf;\r\nops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\r\nops.datbuf = NULL;\r\nret = mtd_read_oob(c->mtd, jeb->offset, &ops);\r\nif ((ret && !mtd_is_bitflip(ret)) || ops.oobretlen != ops.ooblen) {\r\npr_err("cannot read OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\n",\r\njeb->offset, ops.ooblen, ops.oobretlen, ret);\r\nif (!ret || mtd_is_bitflip(ret))\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nreturn !!memcmp(&oob_cleanmarker, c->oobbuf, cmlen);\r\n}\r\nint jffs2_write_nand_cleanmarker(struct jffs2_sb_info *c,\r\nstruct jffs2_eraseblock *jeb)\r\n{\r\nint ret;\r\nstruct mtd_oob_ops ops;\r\nint cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\r\nops.mode = MTD_OPS_AUTO_OOB;\r\nops.ooblen = cmlen;\r\nops.oobbuf = (uint8_t *)&oob_cleanmarker;\r\nops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\r\nops.datbuf = NULL;\r\nret = mtd_write_oob(c->mtd, jeb->offset, &ops);\r\nif (ret || ops.oobretlen != ops.ooblen) {\r\npr_err("cannot write OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\n",\r\njeb->offset, ops.ooblen, ops.oobretlen, ret);\r\nif (!ret)\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint jffs2_write_nand_badblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset)\r\n{\r\nint ret;\r\nif( ++jeb->bad_count < MAX_ERASE_FAILURES)\r\nreturn 0;\r\npr_warn("marking eraseblock at %08x as bad\n", bad_offset);\r\nret = mtd_block_markbad(c->mtd, bad_offset);\r\nif (ret) {\r\njffs2_dbg(1, "%s(): Write failed for block at %08x: error %d\n",\r\n__func__, jeb->offset, ret);\r\nreturn ret;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct jffs2_sb_info *work_to_sb(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork;\r\ndwork = to_delayed_work(work);\r\nreturn container_of(dwork, struct jffs2_sb_info, wbuf_dwork);\r\n}\r\nstatic void delayed_wbuf_sync(struct work_struct *work)\r\n{\r\nstruct jffs2_sb_info *c = work_to_sb(work);\r\nstruct super_block *sb = OFNI_BS_2SFFJ(c);\r\nif (!(sb->s_flags & MS_RDONLY)) {\r\njffs2_dbg(1, "%s()\n", __func__);\r\njffs2_flush_wbuf_gc(c, 0);\r\n}\r\n}\r\nvoid jffs2_dirty_trigger(struct jffs2_sb_info *c)\r\n{\r\nstruct super_block *sb = OFNI_BS_2SFFJ(c);\r\nunsigned long delay;\r\nif (sb->s_flags & MS_RDONLY)\r\nreturn;\r\ndelay = msecs_to_jiffies(dirty_writeback_interval * 10);\r\nif (queue_delayed_work(system_long_wq, &c->wbuf_dwork, delay))\r\njffs2_dbg(1, "%s()\n", __func__);\r\n}\r\nint jffs2_nand_flash_setup(struct jffs2_sb_info *c)\r\n{\r\nif (!c->mtd->oobsize)\r\nreturn 0;\r\nc->cleanmarker_size = 0;\r\nif (c->mtd->oobavail == 0) {\r\npr_err("inconsistent device description\n");\r\nreturn -EINVAL;\r\n}\r\njffs2_dbg(1, "using OOB on NAND\n");\r\nc->oobavail = c->mtd->oobavail;\r\ninit_rwsem(&c->wbuf_sem);\r\nINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\r\nc->wbuf_pagesize = c->mtd->writesize;\r\nc->wbuf_ofs = 0xFFFFFFFF;\r\nc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\r\nif (!c->wbuf)\r\nreturn -ENOMEM;\r\nc->oobbuf = kmalloc(NR_OOB_SCAN_PAGES * c->oobavail, GFP_KERNEL);\r\nif (!c->oobbuf) {\r\nkfree(c->wbuf);\r\nreturn -ENOMEM;\r\n}\r\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\r\nc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\r\nif (!c->wbuf_verify) {\r\nkfree(c->oobbuf);\r\nkfree(c->wbuf);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid jffs2_nand_flash_cleanup(struct jffs2_sb_info *c)\r\n{\r\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\r\nkfree(c->wbuf_verify);\r\n#endif\r\nkfree(c->wbuf);\r\nkfree(c->oobbuf);\r\n}\r\nint jffs2_dataflash_setup(struct jffs2_sb_info *c) {\r\nc->cleanmarker_size = 0;\r\ninit_rwsem(&c->wbuf_sem);\r\nINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\r\nc->wbuf_pagesize = c->mtd->erasesize;\r\nc->sector_size = 8 * c->mtd->erasesize;\r\nwhile (c->sector_size < 8192) {\r\nc->sector_size *= 2;\r\n}\r\nc->flash_size = c->mtd->size;\r\nif ((c->flash_size % c->sector_size) != 0) {\r\nc->flash_size = (c->flash_size / c->sector_size) * c->sector_size;\r\npr_warn("flash size adjusted to %dKiB\n", c->flash_size);\r\n}\r\nc->wbuf_ofs = 0xFFFFFFFF;\r\nc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\r\nif (!c->wbuf)\r\nreturn -ENOMEM;\r\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\r\nc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\r\nif (!c->wbuf_verify) {\r\nkfree(c->wbuf);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\npr_info("write-buffering enabled buffer (%d) erasesize (%d)\n",\r\nc->wbuf_pagesize, c->sector_size);\r\nreturn 0;\r\n}\r\nvoid jffs2_dataflash_cleanup(struct jffs2_sb_info *c) {\r\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\r\nkfree(c->wbuf_verify);\r\n#endif\r\nkfree(c->wbuf);\r\n}\r\nint jffs2_nor_wbuf_flash_setup(struct jffs2_sb_info *c) {\r\nc->cleanmarker_size = max(16u, c->mtd->writesize);\r\ninit_rwsem(&c->wbuf_sem);\r\nINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\r\nc->wbuf_pagesize = c->mtd->writesize;\r\nc->wbuf_ofs = 0xFFFFFFFF;\r\nc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\r\nif (!c->wbuf)\r\nreturn -ENOMEM;\r\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\r\nc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\r\nif (!c->wbuf_verify) {\r\nkfree(c->wbuf);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid jffs2_nor_wbuf_flash_cleanup(struct jffs2_sb_info *c) {\r\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\r\nkfree(c->wbuf_verify);\r\n#endif\r\nkfree(c->wbuf);\r\n}\r\nint jffs2_ubivol_setup(struct jffs2_sb_info *c) {\r\nc->cleanmarker_size = 0;\r\nif (c->mtd->writesize == 1)\r\nreturn 0;\r\ninit_rwsem(&c->wbuf_sem);\r\nINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\r\nc->wbuf_pagesize = c->mtd->writesize;\r\nc->wbuf_ofs = 0xFFFFFFFF;\r\nc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\r\nif (!c->wbuf)\r\nreturn -ENOMEM;\r\npr_info("write-buffering enabled buffer (%d) erasesize (%d)\n",\r\nc->wbuf_pagesize, c->sector_size);\r\nreturn 0;\r\n}\r\nvoid jffs2_ubivol_cleanup(struct jffs2_sb_info *c) {\r\nkfree(c->wbuf);\r\n}
