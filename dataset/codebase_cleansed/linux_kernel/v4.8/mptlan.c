static int\r\nlan_reply (MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *reply)\r\n{\r\nstruct net_device *dev = ioc->netdev;\r\nint FreeReqFrame = 0;\r\ndioprintk((KERN_INFO MYNAM ": %s/%s: Got reply.\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev)));\r\nif (mf == NULL) {\r\nu32 tmsg = CAST_PTR_TO_U32(reply);\r\ndioprintk((KERN_INFO MYNAM ": %s/%s: @lan_reply, tmsg %08x\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\ntmsg));\r\nswitch (GET_LAN_FORM(tmsg)) {\r\n#if 0\r\ncase LAN_REPLY_FORM_MESSAGE_CONTEXT:\r\nFreeReqFrame = 1;\r\nbreak;\r\n#endif\r\ncase LAN_REPLY_FORM_SEND_SINGLE:\r\n(void) mpt_lan_send_turbo(dev, tmsg);\r\nFreeReqFrame = 0;\r\nbreak;\r\ncase LAN_REPLY_FORM_RECEIVE_SINGLE:\r\nmpt_lan_receive_post_turbo(dev, tmsg);\r\nbreak;\r\ndefault:\r\nprintk (KERN_ERR MYNAM "/lan_reply: Got a turbo reply "\r\n"that I don't know what to do with\n");\r\nbreak;\r\n}\r\nreturn FreeReqFrame;\r\n}\r\nswitch (reply->u.hdr.Function) {\r\ncase MPI_FUNCTION_LAN_SEND:\r\n{\r\nLANSendReply_t *pSendRep;\r\npSendRep = (LANSendReply_t *) reply;\r\nFreeReqFrame = mpt_lan_send_reply(dev, pSendRep);\r\nbreak;\r\n}\r\ncase MPI_FUNCTION_LAN_RECEIVE:\r\n{\r\nLANReceivePostReply_t *pRecvRep;\r\npRecvRep = (LANReceivePostReply_t *) reply;\r\nif (pRecvRep->NumberOfContexts) {\r\nmpt_lan_receive_post_reply(dev, pRecvRep);\r\nif (!(pRecvRep->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY))\r\nFreeReqFrame = 1;\r\n} else\r\ndioprintk((KERN_INFO MYNAM "@lan_reply: zero context "\r\n"ReceivePostReply received.\n"));\r\nbreak;\r\n}\r\ncase MPI_FUNCTION_LAN_RESET:\r\nFreeReqFrame = 1;\r\nbreak;\r\ncase MPI_FUNCTION_EVENT_NOTIFICATION:\r\ncase MPI_FUNCTION_EVENT_ACK:\r\nFreeReqFrame = 1;\r\nbreak;\r\ndefault:\r\nprintk (KERN_ERR MYNAM "/lan_reply: Got a non-turbo "\r\n"reply that I don't know what to do with\n");\r\nFreeReqFrame = 1;\r\nbreak;\r\n}\r\nreturn FreeReqFrame;\r\n}\r\nstatic int\r\nmpt_lan_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\r\n{\r\nstruct net_device *dev = ioc->netdev;\r\nstruct mpt_lan_priv *priv;\r\nif (dev == NULL)\r\nreturn(1);\r\nelse\r\npriv = netdev_priv(dev);\r\ndlprintk((KERN_INFO MYNAM ": IOC %s_reset routed to LAN driver!\n",\r\nreset_phase==MPT_IOC_SETUP_RESET ? "setup" : (\r\nreset_phase==MPT_IOC_PRE_RESET ? "pre" : "post")));\r\nif (priv->mpt_rxfidx == NULL)\r\nreturn (1);\r\nif (reset_phase == MPT_IOC_SETUP_RESET) {\r\n;\r\n} else if (reset_phase == MPT_IOC_PRE_RESET) {\r\nint i;\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\ndlprintk ((KERN_INFO "mptlan/ioc_reset: called netif_stop_queue for %s.\n", dev->name));\r\natomic_set(&priv->buckets_out, 0);\r\nspin_lock_irqsave(&priv->rxfidx_lock, flags);\r\npriv->mpt_rxfidx_tail = -1;\r\nfor (i = 0; i < priv->max_buckets_out; i++)\r\npriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = i;\r\nspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\r\n} else {\r\nmpt_lan_post_receive_buckets(priv);\r\nnetif_wake_queue(dev);\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nmpt_lan_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\r\n{\r\ndlprintk((KERN_INFO MYNAM ": MPT event routed to LAN driver!\n"));\r\nswitch (le32_to_cpu(pEvReply->Event)) {\r\ncase MPI_EVENT_NONE:\r\ncase MPI_EVENT_LOG_DATA:\r\ncase MPI_EVENT_STATE_CHANGE:\r\ncase MPI_EVENT_UNIT_ATTENTION:\r\ncase MPI_EVENT_IOC_BUS_RESET:\r\ncase MPI_EVENT_EXT_BUS_RESET:\r\ncase MPI_EVENT_RESCAN:\r\ncase MPI_EVENT_LINK_STATUS_CHANGE:\r\ncase MPI_EVENT_LOOP_STATE_CHANGE:\r\ncase MPI_EVENT_LOGOUT:\r\ncase MPI_EVENT_EVENT_CHANGE:\r\ndefault:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nmpt_lan_open(struct net_device *dev)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nint i;\r\nif (mpt_lan_reset(dev) != 0) {\r\nMPT_ADAPTER *mpt_dev = priv->mpt_dev;\r\nprintk (KERN_WARNING MYNAM "/lan_open: lan_reset failed.");\r\nif (mpt_dev->active)\r\nprintk ("The ioc is active. Perhaps it needs to be"\r\n" reset?\n");\r\nelse\r\nprintk ("The ioc in inactive, most likely in the "\r\n"process of being reset. Please try again in "\r\n"a moment.\n");\r\n}\r\npriv->mpt_txfidx = kmalloc(priv->tx_max_out * sizeof(int), GFP_KERNEL);\r\nif (priv->mpt_txfidx == NULL)\r\ngoto out;\r\npriv->mpt_txfidx_tail = -1;\r\npriv->SendCtl = kcalloc(priv->tx_max_out, sizeof(struct BufferControl),\r\nGFP_KERNEL);\r\nif (priv->SendCtl == NULL)\r\ngoto out_mpt_txfidx;\r\nfor (i = 0; i < priv->tx_max_out; i++)\r\npriv->mpt_txfidx[++priv->mpt_txfidx_tail] = i;\r\ndlprintk((KERN_INFO MYNAM "@lo: Finished initializing SendCtl\n"));\r\npriv->mpt_rxfidx = kmalloc(priv->max_buckets_out * sizeof(int),\r\nGFP_KERNEL);\r\nif (priv->mpt_rxfidx == NULL)\r\ngoto out_SendCtl;\r\npriv->mpt_rxfidx_tail = -1;\r\npriv->RcvCtl = kcalloc(priv->max_buckets_out,\r\nsizeof(struct BufferControl),\r\nGFP_KERNEL);\r\nif (priv->RcvCtl == NULL)\r\ngoto out_mpt_rxfidx;\r\nfor (i = 0; i < priv->max_buckets_out; i++)\r\npriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = i;\r\ndlprintk((KERN_INFO MYNAM "/lo: txfidx contains - "));\r\nfor (i = 0; i < priv->tx_max_out; i++)\r\ndlprintk((" %xh", priv->mpt_txfidx[i]));\r\ndlprintk(("\n"));\r\ndlprintk((KERN_INFO MYNAM "/lo: Finished initializing RcvCtl\n"));\r\nmpt_lan_post_receive_buckets(priv);\r\nprintk(KERN_INFO MYNAM ": %s/%s: interface up & active\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev));\r\nif (mpt_event_register(LanCtx, mpt_lan_event_process) != 0) {\r\nprintk (KERN_WARNING MYNAM "/lo: Unable to register for Event"\r\n" Notifications. This is a bad thing! We're not going "\r\n"to go ahead, but I'd be leery of system stability at "\r\n"this point.\n");\r\n}\r\nnetif_start_queue(dev);\r\ndlprintk((KERN_INFO MYNAM "/lo: Done.\n"));\r\nreturn 0;\r\nout_mpt_rxfidx:\r\nkfree(priv->mpt_rxfidx);\r\npriv->mpt_rxfidx = NULL;\r\nout_SendCtl:\r\nkfree(priv->SendCtl);\r\npriv->SendCtl = NULL;\r\nout_mpt_txfidx:\r\nkfree(priv->mpt_txfidx);\r\npriv->mpt_txfidx = NULL;\r\nout: return -ENOMEM;\r\n}\r\nstatic int\r\nmpt_lan_reset(struct net_device *dev)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nLANResetRequest_t *pResetReq;\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nmf = mpt_get_msg_frame(LanCtx, priv->mpt_dev);\r\nif (mf == NULL) {\r\nreturn -1;\r\n}\r\npResetReq = (LANResetRequest_t *) mf;\r\npResetReq->Function = MPI_FUNCTION_LAN_RESET;\r\npResetReq->ChainOffset = 0;\r\npResetReq->Reserved = 0;\r\npResetReq->PortNumber = priv->pnum;\r\npResetReq->MsgFlags = 0;\r\npResetReq->Reserved2 = 0;\r\nmpt_put_msg_frame(LanCtx, priv->mpt_dev, mf);\r\nreturn 0;\r\n}\r\nstatic int\r\nmpt_lan_close(struct net_device *dev)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nMPT_ADAPTER *mpt_dev = priv->mpt_dev;\r\nunsigned long timeout;\r\nint i;\r\ndlprintk((KERN_INFO MYNAM ": mpt_lan_close called\n"));\r\nmpt_event_deregister(LanCtx);\r\ndlprintk((KERN_INFO MYNAM ":lan_close: Posted %d buckets "\r\n"since driver was loaded, %d still out\n",\r\npriv->total_posted,atomic_read(&priv->buckets_out)));\r\nnetif_stop_queue(dev);\r\nmpt_lan_reset(dev);\r\ntimeout = jiffies + 2 * HZ;\r\nwhile (atomic_read(&priv->buckets_out) && time_before(jiffies, timeout))\r\nschedule_timeout_interruptible(1);\r\nfor (i = 0; i < priv->max_buckets_out; i++) {\r\nif (priv->RcvCtl[i].skb != NULL) {\r\ndlprintk((KERN_INFO MYNAM "/lan_close: bucket %05x "\r\n"is still out\n", i));\r\npci_unmap_single(mpt_dev->pcidev, priv->RcvCtl[i].dma,\r\npriv->RcvCtl[i].len,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(priv->RcvCtl[i].skb);\r\n}\r\n}\r\nkfree(priv->RcvCtl);\r\nkfree(priv->mpt_rxfidx);\r\nfor (i = 0; i < priv->tx_max_out; i++) {\r\nif (priv->SendCtl[i].skb != NULL) {\r\npci_unmap_single(mpt_dev->pcidev, priv->SendCtl[i].dma,\r\npriv->SendCtl[i].len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb(priv->SendCtl[i].skb);\r\n}\r\n}\r\nkfree(priv->SendCtl);\r\nkfree(priv->mpt_txfidx);\r\natomic_set(&priv->buckets_out, 0);\r\nprintk(KERN_INFO MYNAM ": %s/%s: interface down & inactive\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev));\r\nreturn 0;\r\n}\r\nstatic int\r\nmpt_lan_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < MPT_LAN_MIN_MTU) || (new_mtu > MPT_LAN_MAX_MTU))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void\r\nmpt_lan_tx_timeout(struct net_device *dev)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nMPT_ADAPTER *mpt_dev = priv->mpt_dev;\r\nif (mpt_dev->active) {\r\ndlprintk (("mptlan/tx_timeout: calling netif_wake_queue for %s.\n", dev->name));\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic int\r\nmpt_lan_send_turbo(struct net_device *dev, u32 tmsg)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nMPT_ADAPTER *mpt_dev = priv->mpt_dev;\r\nstruct sk_buff *sent;\r\nunsigned long flags;\r\nu32 ctx;\r\nctx = GET_LAN_BUFFER_CONTEXT(tmsg);\r\nsent = priv->SendCtl[ctx].skb;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += sent->len;\r\ndioprintk((KERN_INFO MYNAM ": %s/%s: @%s, skb %p sent.\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\n__func__, sent));\r\npriv->SendCtl[ctx].skb = NULL;\r\npci_unmap_single(mpt_dev->pcidev, priv->SendCtl[ctx].dma,\r\npriv->SendCtl[ctx].len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(sent);\r\nspin_lock_irqsave(&priv->txfidx_lock, flags);\r\npriv->mpt_txfidx[++priv->mpt_txfidx_tail] = ctx;\r\nspin_unlock_irqrestore(&priv->txfidx_lock, flags);\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nmpt_lan_send_reply(struct net_device *dev, LANSendReply_t *pSendRep)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nMPT_ADAPTER *mpt_dev = priv->mpt_dev;\r\nstruct sk_buff *sent;\r\nunsigned long flags;\r\nint FreeReqFrame = 0;\r\nu32 *pContext;\r\nu32 ctx;\r\nu8 count;\r\ncount = pSendRep->NumberOfContexts;\r\ndioprintk((KERN_INFO MYNAM ": send_reply: IOCStatus: %04x\n",\r\nle16_to_cpu(pSendRep->IOCStatus)));\r\nswitch (le16_to_cpu(pSendRep->IOCStatus) & MPI_IOCSTATUS_MASK) {\r\ncase MPI_IOCSTATUS_SUCCESS:\r\ndev->stats.tx_packets += count;\r\nbreak;\r\ncase MPI_IOCSTATUS_LAN_CANCELED:\r\ncase MPI_IOCSTATUS_LAN_TRANSMIT_ABORTED:\r\nbreak;\r\ncase MPI_IOCSTATUS_INVALID_SGL:\r\ndev->stats.tx_errors += count;\r\nprintk (KERN_ERR MYNAM ": %s/%s: ERROR - Invalid SGL sent to IOC!\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev));\r\ngoto out;\r\ndefault:\r\ndev->stats.tx_errors += count;\r\nbreak;\r\n}\r\npContext = &pSendRep->BufferContext;\r\nspin_lock_irqsave(&priv->txfidx_lock, flags);\r\nwhile (count > 0) {\r\nctx = GET_LAN_BUFFER_CONTEXT(le32_to_cpu(*pContext));\r\nsent = priv->SendCtl[ctx].skb;\r\ndev->stats.tx_bytes += sent->len;\r\ndioprintk((KERN_INFO MYNAM ": %s/%s: @%s, skb %p sent.\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\n__func__, sent));\r\npriv->SendCtl[ctx].skb = NULL;\r\npci_unmap_single(mpt_dev->pcidev, priv->SendCtl[ctx].dma,\r\npriv->SendCtl[ctx].len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(sent);\r\npriv->mpt_txfidx[++priv->mpt_txfidx_tail] = ctx;\r\npContext++;\r\ncount--;\r\n}\r\nspin_unlock_irqrestore(&priv->txfidx_lock, flags);\r\nout:\r\nif (!(pSendRep->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY))\r\nFreeReqFrame = 1;\r\nnetif_wake_queue(dev);\r\nreturn FreeReqFrame;\r\n}\r\nstatic int\r\nmpt_lan_sdu_send (struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nMPT_ADAPTER *mpt_dev = priv->mpt_dev;\r\nMPT_FRAME_HDR *mf;\r\nLANSendRequest_t *pSendReq;\r\nSGETransaction32_t *pTrans;\r\nSGESimple64_t *pSimple;\r\nconst unsigned char *mac;\r\ndma_addr_t dma;\r\nunsigned long flags;\r\nint ctx;\r\nu16 cur_naa = 0x1000;\r\ndioprintk((KERN_INFO MYNAM ": %s called, skb_addr = %p\n",\r\n__func__, skb));\r\nspin_lock_irqsave(&priv->txfidx_lock, flags);\r\nif (priv->mpt_txfidx_tail < 0) {\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&priv->txfidx_lock, flags);\r\nprintk (KERN_ERR "%s: no tx context available: %u\n",\r\n__func__, priv->mpt_txfidx_tail);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nmf = mpt_get_msg_frame(LanCtx, mpt_dev);\r\nif (mf == NULL) {\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&priv->txfidx_lock, flags);\r\nprintk (KERN_ERR "%s: Unable to alloc request frame\n",\r\n__func__);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nctx = priv->mpt_txfidx[priv->mpt_txfidx_tail--];\r\nspin_unlock_irqrestore(&priv->txfidx_lock, flags);\r\npSendReq = (LANSendRequest_t *) mf;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, 12);\r\ndma = pci_map_single(mpt_dev->pcidev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\npriv->SendCtl[ctx].skb = skb;\r\npriv->SendCtl[ctx].dma = dma;\r\npriv->SendCtl[ctx].len = skb->len;\r\npSendReq->Reserved = 0;\r\npSendReq->Function = MPI_FUNCTION_LAN_SEND;\r\npSendReq->ChainOffset = 0;\r\npSendReq->Reserved2 = 0;\r\npSendReq->MsgFlags = 0;\r\npSendReq->PortNumber = priv->pnum;\r\npTrans = (SGETransaction32_t *) pSendReq->SG_List;\r\npTrans->ContextSize = sizeof(u32);\r\npTrans->DetailsLength = 2 * sizeof(u32);\r\npTrans->Flags = 0;\r\npTrans->TransactionContext[0] = cpu_to_le32(ctx);\r\nmac = skb_mac_header(skb);\r\npTrans->TransactionDetails[0] = cpu_to_le32((cur_naa << 16) |\r\n(mac[0] << 8) |\r\n(mac[1] << 0));\r\npTrans->TransactionDetails[1] = cpu_to_le32((mac[2] << 24) |\r\n(mac[3] << 16) |\r\n(mac[4] << 8) |\r\n(mac[5] << 0));\r\npSimple = (SGESimple64_t *) &pTrans->TransactionDetails[2];\r\npSimple->FlagsLength = cpu_to_le32(\r\n((MPI_SGE_FLAGS_LAST_ELEMENT |\r\nMPI_SGE_FLAGS_END_OF_BUFFER |\r\nMPI_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI_SGE_FLAGS_SYSTEM_ADDRESS |\r\nMPI_SGE_FLAGS_HOST_TO_IOC |\r\nMPI_SGE_FLAGS_64_BIT_ADDRESSING |\r\nMPI_SGE_FLAGS_END_OF_LIST) << MPI_SGE_FLAGS_SHIFT) |\r\nskb->len);\r\npSimple->Address.Low = cpu_to_le32((u32) dma);\r\nif (sizeof(dma_addr_t) > sizeof(u32))\r\npSimple->Address.High = cpu_to_le32((u32) ((u64) dma >> 32));\r\nelse\r\npSimple->Address.High = 0;\r\nmpt_put_msg_frame (LanCtx, mpt_dev, mf);\r\nnetif_trans_update(dev);\r\ndioprintk((KERN_INFO MYNAM ": %s/%s: Sending packet. FlagsLength = %08x.\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\nle32_to_cpu(pSimple->FlagsLength)));\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\nmpt_lan_wake_post_buckets_task(struct net_device *dev, int priority)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nif (test_and_set_bit(0, &priv->post_buckets_active) == 0) {\r\nif (priority) {\r\nschedule_delayed_work(&priv->post_buckets_task, 0);\r\n} else {\r\nschedule_delayed_work(&priv->post_buckets_task, 1);\r\ndioprintk((KERN_INFO MYNAM ": post_buckets queued on "\r\n"timer.\n"));\r\n}\r\ndioprintk((KERN_INFO MYNAM ": %s/%s: Queued post_buckets task.\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev) ));\r\n}\r\n}\r\nstatic int\r\nmpt_lan_receive_skb(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nskb->protocol = mpt_lan_type_trans(skb, dev);\r\ndioprintk((KERN_INFO MYNAM ": %s/%s: Incoming packet (%d bytes) "\r\n"delivered to upper level.\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev), skb->len));\r\ndev->stats.rx_bytes += skb->len;\r\ndev->stats.rx_packets++;\r\nskb->dev = dev;\r\nnetif_rx(skb);\r\ndioprintk((MYNAM "/receive_skb: %d buckets remaining\n",\r\natomic_read(&priv->buckets_out)));\r\nif (atomic_read(&priv->buckets_out) < priv->bucketthresh)\r\nmpt_lan_wake_post_buckets_task(dev, 1);\r\ndioprintk((KERN_INFO MYNAM "/receive_post_reply: %d buckets "\r\n"remaining, %d received back since sod\n",\r\natomic_read(&priv->buckets_out), priv->total_received));\r\nreturn 0;\r\n}\r\nstatic int\r\nmpt_lan_receive_post_turbo(struct net_device *dev, u32 tmsg)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nMPT_ADAPTER *mpt_dev = priv->mpt_dev;\r\nstruct sk_buff *skb, *old_skb;\r\nunsigned long flags;\r\nu32 ctx, len;\r\nctx = GET_LAN_BUCKET_CONTEXT(tmsg);\r\nskb = priv->RcvCtl[ctx].skb;\r\nlen = GET_LAN_PACKET_LENGTH(tmsg);\r\nif (len < MPT_LAN_RX_COPYBREAK) {\r\nold_skb = skb;\r\nskb = (struct sk_buff *)dev_alloc_skb(len);\r\nif (!skb) {\r\nprintk (KERN_ERR MYNAM ": %s/%s: ERROR - Can't allocate skb! (%s@%d)\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\n__FILE__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\npci_dma_sync_single_for_cpu(mpt_dev->pcidev, priv->RcvCtl[ctx].dma,\r\npriv->RcvCtl[ctx].len, PCI_DMA_FROMDEVICE);\r\nskb_copy_from_linear_data(old_skb, skb_put(skb, len), len);\r\npci_dma_sync_single_for_device(mpt_dev->pcidev, priv->RcvCtl[ctx].dma,\r\npriv->RcvCtl[ctx].len, PCI_DMA_FROMDEVICE);\r\ngoto out;\r\n}\r\nskb_put(skb, len);\r\npriv->RcvCtl[ctx].skb = NULL;\r\npci_unmap_single(mpt_dev->pcidev, priv->RcvCtl[ctx].dma,\r\npriv->RcvCtl[ctx].len, PCI_DMA_FROMDEVICE);\r\nout:\r\nspin_lock_irqsave(&priv->rxfidx_lock, flags);\r\npriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\r\nspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\r\natomic_dec(&priv->buckets_out);\r\npriv->total_received++;\r\nreturn mpt_lan_receive_skb(dev, skb);\r\n}\r\nstatic int\r\nmpt_lan_receive_post_free(struct net_device *dev,\r\nLANReceivePostReply_t *pRecvRep)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nMPT_ADAPTER *mpt_dev = priv->mpt_dev;\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nu32 ctx;\r\nint count;\r\nint i;\r\ncount = pRecvRep->NumberOfContexts;\r\ndlprintk((KERN_INFO MYNAM "/receive_post_reply: "\r\n"IOC returned %d buckets, freeing them...\n", count));\r\nspin_lock_irqsave(&priv->rxfidx_lock, flags);\r\nfor (i = 0; i < count; i++) {\r\nctx = le32_to_cpu(pRecvRep->BucketContext[i]);\r\nskb = priv->RcvCtl[ctx].skb;\r\npriv->RcvCtl[ctx].skb = NULL;\r\npci_unmap_single(mpt_dev->pcidev, priv->RcvCtl[ctx].dma,\r\npriv->RcvCtl[ctx].len, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb_any(skb);\r\npriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\r\n}\r\nspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\r\natomic_sub(count, &priv->buckets_out);\r\ndlprintk((KERN_INFO MYNAM "@receive_post_reply: %d buckets "\r\n"remaining, %d received back since sod.\n",\r\natomic_read(&priv->buckets_out), priv->total_received));\r\nreturn 0;\r\n}\r\nstatic int\r\nmpt_lan_receive_post_reply(struct net_device *dev,\r\nLANReceivePostReply_t *pRecvRep)\r\n{\r\nstruct mpt_lan_priv *priv = netdev_priv(dev);\r\nMPT_ADAPTER *mpt_dev = priv->mpt_dev;\r\nstruct sk_buff *skb, *old_skb;\r\nunsigned long flags;\r\nu32 len, ctx, offset;\r\nu32 remaining = le32_to_cpu(pRecvRep->BucketsRemaining);\r\nint count;\r\nint i, l;\r\ndioprintk((KERN_INFO MYNAM ": mpt_lan_receive_post_reply called\n"));\r\ndioprintk((KERN_INFO MYNAM ": receive_post_reply: IOCStatus: %04x\n",\r\nle16_to_cpu(pRecvRep->IOCStatus)));\r\nif ((le16_to_cpu(pRecvRep->IOCStatus) & MPI_IOCSTATUS_MASK) ==\r\nMPI_IOCSTATUS_LAN_CANCELED)\r\nreturn mpt_lan_receive_post_free(dev, pRecvRep);\r\nlen = le32_to_cpu(pRecvRep->PacketLength);\r\nif (len == 0) {\r\nprintk (KERN_ERR MYNAM ": %s/%s: ERROR - Got a non-TURBO "\r\n"ReceivePostReply w/ PacketLength zero!\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev));\r\nprintk (KERN_ERR MYNAM ": MsgFlags = %02x, IOCStatus = %04x\n",\r\npRecvRep->MsgFlags, le16_to_cpu(pRecvRep->IOCStatus));\r\nreturn -1;\r\n}\r\nctx = le32_to_cpu(pRecvRep->BucketContext[0]);\r\ncount = pRecvRep->NumberOfContexts;\r\nskb = priv->RcvCtl[ctx].skb;\r\noffset = le32_to_cpu(pRecvRep->PacketOffset);\r\ndioprintk((KERN_INFO MYNAM ": %s/%s: @rpr, offset = %d, len = %d\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\noffset, len));\r\nif (count > 1) {\r\nint szrem = len;\r\nskb = (struct sk_buff *)dev_alloc_skb(len);\r\nif (!skb) {\r\nprintk (KERN_ERR MYNAM ": %s/%s: ERROR - Can't allocate skb! (%s@%d)\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\n__FILE__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&priv->rxfidx_lock, flags);\r\nfor (i = 0; i < count; i++) {\r\nctx = le32_to_cpu(pRecvRep->BucketContext[i]);\r\nold_skb = priv->RcvCtl[ctx].skb;\r\nl = priv->RcvCtl[ctx].len;\r\nif (szrem < l)\r\nl = szrem;\r\npci_dma_sync_single_for_cpu(mpt_dev->pcidev,\r\npriv->RcvCtl[ctx].dma,\r\npriv->RcvCtl[ctx].len,\r\nPCI_DMA_FROMDEVICE);\r\nskb_copy_from_linear_data(old_skb, skb_put(skb, l), l);\r\npci_dma_sync_single_for_device(mpt_dev->pcidev,\r\npriv->RcvCtl[ctx].dma,\r\npriv->RcvCtl[ctx].len,\r\nPCI_DMA_FROMDEVICE);\r\npriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\r\nszrem -= l;\r\n}\r\nspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\r\n} else if (len < MPT_LAN_RX_COPYBREAK) {\r\nold_skb = skb;\r\nskb = (struct sk_buff *)dev_alloc_skb(len);\r\nif (!skb) {\r\nprintk (KERN_ERR MYNAM ": %s/%s: ERROR - Can't allocate skb! (%s@%d)\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\n__FILE__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\npci_dma_sync_single_for_cpu(mpt_dev->pcidev,\r\npriv->RcvCtl[ctx].dma,\r\npriv->RcvCtl[ctx].len,\r\nPCI_DMA_FROMDEVICE);\r\nskb_copy_from_linear_data(old_skb, skb_put(skb, len), len);\r\npci_dma_sync_single_for_device(mpt_dev->pcidev,\r\npriv->RcvCtl[ctx].dma,\r\npriv->RcvCtl[ctx].len,\r\nPCI_DMA_FROMDEVICE);\r\nspin_lock_irqsave(&priv->rxfidx_lock, flags);\r\npriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\r\nspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\r\n} else {\r\nspin_lock_irqsave(&priv->rxfidx_lock, flags);\r\npriv->RcvCtl[ctx].skb = NULL;\r\npci_unmap_single(mpt_dev->pcidev, priv->RcvCtl[ctx].dma,\r\npriv->RcvCtl[ctx].len, PCI_DMA_FROMDEVICE);\r\npriv->RcvCtl[ctx].dma = 0;\r\npriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\r\nspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\r\nskb_put(skb,len);\r\n}\r\natomic_sub(count, &priv->buckets_out);\r\npriv->total_received += count;\r\nif (priv->mpt_rxfidx_tail >= MPT_LAN_MAX_BUCKETS_OUT) {\r\nprintk (KERN_ERR MYNAM ": %s/%s: Yoohoo! mpt_rxfidx_tail = %d, "\r\n"MPT_LAN_MAX_BUCKETS_OUT = %d\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\npriv->mpt_rxfidx_tail,\r\nMPT_LAN_MAX_BUCKETS_OUT);\r\nreturn -1;\r\n}\r\nif (remaining == 0)\r\nprintk (KERN_WARNING MYNAM ": %s/%s: WARNING - IOC out of buckets! "\r\n"(priv->buckets_out = %d)\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\natomic_read(&priv->buckets_out));\r\nelse if (remaining < 10)\r\nprintk (KERN_INFO MYNAM ": %s/%s: IOC says %d buckets left. "\r\n"(priv->buckets_out = %d)\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\nremaining, atomic_read(&priv->buckets_out));\r\nif ((remaining < priv->bucketthresh) &&\r\n((atomic_read(&priv->buckets_out) - remaining) >\r\nMPT_LAN_BUCKETS_REMAIN_MISMATCH_THRESH)) {\r\nprintk (KERN_WARNING MYNAM " Mismatch between driver's "\r\n"buckets_out count and fw's BucketsRemaining "\r\n"count has crossed the threshold, issuing a "\r\n"LanReset to clear the fw's hashtable. You may "\r\n"want to check your /var/log/messages for \"CRC "\r\n"error\" event notifications.\n");\r\nmpt_lan_reset(dev);\r\nmpt_lan_wake_post_buckets_task(dev, 0);\r\n}\r\nreturn mpt_lan_receive_skb(dev, skb);\r\n}\r\nstatic void\r\nmpt_lan_post_receive_buckets(struct mpt_lan_priv *priv)\r\n{\r\nstruct net_device *dev = priv->dev;\r\nMPT_ADAPTER *mpt_dev = priv->mpt_dev;\r\nMPT_FRAME_HDR *mf;\r\nLANReceivePostRequest_t *pRecvReq;\r\nSGETransaction32_t *pTrans;\r\nSGESimple64_t *pSimple;\r\nstruct sk_buff *skb;\r\ndma_addr_t dma;\r\nu32 curr, buckets, count, max;\r\nu32 len = (dev->mtu + dev->hard_header_len + 4);\r\nunsigned long flags;\r\nint i;\r\ncurr = atomic_read(&priv->buckets_out);\r\nbuckets = (priv->max_buckets_out - curr);\r\ndioprintk((KERN_INFO MYNAM ": %s/%s: @%s, Start_buckets = %u, buckets_out = %u\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\n__func__, buckets, curr));\r\nmax = (mpt_dev->req_sz - MPT_LAN_RECEIVE_POST_REQUEST_SIZE) /\r\n(MPT_LAN_TRANSACTION32_SIZE + sizeof(SGESimple64_t));\r\nwhile (buckets) {\r\nmf = mpt_get_msg_frame(LanCtx, mpt_dev);\r\nif (mf == NULL) {\r\nprintk (KERN_ERR "%s: Unable to alloc request frame\n",\r\n__func__);\r\ndioprintk((KERN_ERR "%s: %u buckets remaining\n",\r\n__func__, buckets));\r\ngoto out;\r\n}\r\npRecvReq = (LANReceivePostRequest_t *) mf;\r\ni = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\r\nmpt_dev->RequestNB[i] = 0;\r\ncount = buckets;\r\nif (count > max)\r\ncount = max;\r\npRecvReq->Function = MPI_FUNCTION_LAN_RECEIVE;\r\npRecvReq->ChainOffset = 0;\r\npRecvReq->MsgFlags = 0;\r\npRecvReq->PortNumber = priv->pnum;\r\npTrans = (SGETransaction32_t *) pRecvReq->SG_List;\r\npSimple = NULL;\r\nfor (i = 0; i < count; i++) {\r\nint ctx;\r\nspin_lock_irqsave(&priv->rxfidx_lock, flags);\r\nif (priv->mpt_rxfidx_tail < 0) {\r\nprintk (KERN_ERR "%s: Can't alloc context\n",\r\n__func__);\r\nspin_unlock_irqrestore(&priv->rxfidx_lock,\r\nflags);\r\nbreak;\r\n}\r\nctx = priv->mpt_rxfidx[priv->mpt_rxfidx_tail--];\r\nskb = priv->RcvCtl[ctx].skb;\r\nif (skb && (priv->RcvCtl[ctx].len != len)) {\r\npci_unmap_single(mpt_dev->pcidev,\r\npriv->RcvCtl[ctx].dma,\r\npriv->RcvCtl[ctx].len,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(priv->RcvCtl[ctx].skb);\r\nskb = priv->RcvCtl[ctx].skb = NULL;\r\n}\r\nif (skb == NULL) {\r\nskb = dev_alloc_skb(len);\r\nif (skb == NULL) {\r\nprintk (KERN_WARNING\r\nMYNAM "/%s: Can't alloc skb\n",\r\n__func__);\r\npriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\r\nspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\r\nbreak;\r\n}\r\ndma = pci_map_single(mpt_dev->pcidev, skb->data,\r\nlen, PCI_DMA_FROMDEVICE);\r\npriv->RcvCtl[ctx].skb = skb;\r\npriv->RcvCtl[ctx].dma = dma;\r\npriv->RcvCtl[ctx].len = len;\r\n}\r\nspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\r\npTrans->ContextSize = sizeof(u32);\r\npTrans->DetailsLength = 0;\r\npTrans->Flags = 0;\r\npTrans->TransactionContext[0] = cpu_to_le32(ctx);\r\npSimple = (SGESimple64_t *) pTrans->TransactionDetails;\r\npSimple->FlagsLength = cpu_to_le32(\r\n((MPI_SGE_FLAGS_END_OF_BUFFER |\r\nMPI_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI_SGE_FLAGS_64_BIT_ADDRESSING) << MPI_SGE_FLAGS_SHIFT) | len);\r\npSimple->Address.Low = cpu_to_le32((u32) priv->RcvCtl[ctx].dma);\r\nif (sizeof(dma_addr_t) > sizeof(u32))\r\npSimple->Address.High = cpu_to_le32((u32) ((u64) priv->RcvCtl[ctx].dma >> 32));\r\nelse\r\npSimple->Address.High = 0;\r\npTrans = (SGETransaction32_t *) (pSimple + 1);\r\n}\r\nif (pSimple == NULL) {\r\nprintk (KERN_WARNING MYNAM "/%s: No buckets posted\n",\r\n__func__);\r\nmpt_free_msg_frame(mpt_dev, mf);\r\ngoto out;\r\n}\r\npSimple->FlagsLength |= cpu_to_le32(MPI_SGE_FLAGS_END_OF_LIST << MPI_SGE_FLAGS_SHIFT);\r\npRecvReq->BucketCount = cpu_to_le32(i);\r\nmpt_put_msg_frame(LanCtx, mpt_dev, mf);\r\npriv->total_posted += i;\r\nbuckets -= i;\r\natomic_add(i, &priv->buckets_out);\r\n}\r\nout:\r\ndioprintk((KERN_INFO MYNAM "/%s: End_buckets = %u, priv->buckets_out = %u\n",\r\n__func__, buckets, atomic_read(&priv->buckets_out)));\r\ndioprintk((KERN_INFO MYNAM "/%s: Posted %u buckets and received %u back\n",\r\n__func__, priv->total_posted, priv->total_received));\r\nclear_bit(0, &priv->post_buckets_active);\r\n}\r\nstatic void\r\nmpt_lan_post_receive_buckets_work(struct work_struct *work)\r\n{\r\nmpt_lan_post_receive_buckets(container_of(work, struct mpt_lan_priv,\r\npost_buckets_task.work));\r\n}\r\nstatic struct net_device *\r\nmpt_register_lan_device (MPT_ADAPTER *mpt_dev, int pnum)\r\n{\r\nstruct net_device *dev;\r\nstruct mpt_lan_priv *priv;\r\nu8 HWaddr[FC_ALEN], *a;\r\ndev = alloc_fcdev(sizeof(struct mpt_lan_priv));\r\nif (!dev)\r\nreturn NULL;\r\ndev->mtu = MPT_LAN_MTU;\r\npriv = netdev_priv(dev);\r\npriv->dev = dev;\r\npriv->mpt_dev = mpt_dev;\r\npriv->pnum = pnum;\r\nINIT_DELAYED_WORK(&priv->post_buckets_task,\r\nmpt_lan_post_receive_buckets_work);\r\npriv->post_buckets_active = 0;\r\ndlprintk((KERN_INFO MYNAM "@%d: bucketlen = %d\n",\r\n__LINE__, dev->mtu + dev->hard_header_len + 4));\r\natomic_set(&priv->buckets_out, 0);\r\npriv->total_posted = 0;\r\npriv->total_received = 0;\r\npriv->max_buckets_out = max_buckets_out;\r\nif (mpt_dev->pfacts[0].MaxLanBuckets < max_buckets_out)\r\npriv->max_buckets_out = mpt_dev->pfacts[0].MaxLanBuckets;\r\ndlprintk((KERN_INFO MYNAM "@%d: MaxLanBuckets=%d, max_buckets_out/priv=%d/%d\n",\r\n__LINE__,\r\nmpt_dev->pfacts[0].MaxLanBuckets,\r\nmax_buckets_out,\r\npriv->max_buckets_out));\r\npriv->bucketthresh = priv->max_buckets_out * 2 / 3;\r\nspin_lock_init(&priv->txfidx_lock);\r\nspin_lock_init(&priv->rxfidx_lock);\r\na = (u8 *) &mpt_dev->lan_cnfg_page1.HardwareAddressLow;\r\nHWaddr[0] = a[5];\r\nHWaddr[1] = a[4];\r\nHWaddr[2] = a[3];\r\nHWaddr[3] = a[2];\r\nHWaddr[4] = a[1];\r\nHWaddr[5] = a[0];\r\ndev->addr_len = FC_ALEN;\r\nmemcpy(dev->dev_addr, HWaddr, FC_ALEN);\r\nmemset(dev->broadcast, 0xff, FC_ALEN);\r\npriv->tx_max_out = (tx_max_out_p <= MPT_TX_MAX_OUT_LIM) ?\r\ntx_max_out_p : MPT_TX_MAX_OUT_LIM;\r\ndev->netdev_ops = &mpt_netdev_ops;\r\ndev->watchdog_timeo = MPT_LAN_TX_TIMEOUT;\r\ndlprintk((KERN_INFO MYNAM ": Finished registering dev "\r\n"and setting initial values\n"));\r\nif (register_netdev(dev) != 0) {\r\nfree_netdev(dev);\r\ndev = NULL;\r\n}\r\nreturn dev;\r\n}\r\nstatic int\r\nmptlan_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nstruct net_device *dev;\r\nint i;\r\nfor (i = 0; i < ioc->facts.NumberOfPorts; i++) {\r\nprintk(KERN_INFO MYNAM ": %s: PortNum=%x, "\r\n"ProtocolFlags=%02Xh (%c%c%c%c)\n",\r\nioc->name, ioc->pfacts[i].PortNumber,\r\nioc->pfacts[i].ProtocolFlags,\r\nMPT_PROTOCOL_FLAGS_c_c_c_c(\r\nioc->pfacts[i].ProtocolFlags));\r\nif (!(ioc->pfacts[i].ProtocolFlags &\r\nMPI_PORTFACTS_PROTOCOL_LAN)) {\r\nprintk(KERN_INFO MYNAM ": %s: Hmmm... LAN protocol "\r\n"seems to be disabled on this adapter port!\n",\r\nioc->name);\r\ncontinue;\r\n}\r\ndev = mpt_register_lan_device(ioc, i);\r\nif (!dev) {\r\nprintk(KERN_ERR MYNAM ": %s: Unable to register "\r\n"port%d as a LAN device\n", ioc->name,\r\nioc->pfacts[i].PortNumber);\r\ncontinue;\r\n}\r\nprintk(KERN_INFO MYNAM ": %s: Fusion MPT LAN device "\r\n"registered as '%s'\n", ioc->name, dev->name);\r\nprintk(KERN_INFO MYNAM ": %s/%s: "\r\n"LanAddr = %pM\n",\r\nIOC_AND_NETDEV_NAMES_s_s(dev),\r\ndev->dev_addr);\r\nioc->netdev = dev;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void\r\nmptlan_remove(struct pci_dev *pdev)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nstruct net_device *dev = ioc->netdev;\r\nif(dev != NULL) {\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\nstatic int __init mpt_lan_init (void)\r\n{\r\nshow_mptmod_ver(LANAME, LANVER);\r\nLanCtx = mpt_register(lan_reply, MPTLAN_DRIVER,\r\n"lan_reply");\r\nif (LanCtx <= 0) {\r\nprintk (KERN_ERR MYNAM ": Failed to register with MPT base driver\n");\r\nreturn -EBUSY;\r\n}\r\ndlprintk((KERN_INFO MYNAM ": assigned context of %d\n", LanCtx));\r\nif (mpt_reset_register(LanCtx, mpt_lan_ioc_reset)) {\r\nprintk(KERN_ERR MYNAM ": Eieee! unable to register a reset "\r\n"handler with mptbase! The world is at an end! "\r\n"Everything is fading to black! Goodbye.\n");\r\nreturn -EBUSY;\r\n}\r\ndlprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));\r\nmpt_device_driver_register(&mptlan_driver, MPTLAN_DRIVER);\r\nreturn 0;\r\n}\r\nstatic void __exit mpt_lan_exit(void)\r\n{\r\nmpt_device_driver_deregister(MPTLAN_DRIVER);\r\nmpt_reset_deregister(LanCtx);\r\nif (LanCtx) {\r\nmpt_deregister(LanCtx);\r\nLanCtx = MPT_MAX_PROTOCOL_DRIVERS;\r\n}\r\n}\r\nstatic unsigned short\r\nmpt_lan_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct mpt_lan_ohdr *fch = (struct mpt_lan_ohdr *)skb->data;\r\nstruct fcllc *fcllc;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, sizeof(struct mpt_lan_ohdr));\r\nif (fch->dtype == htons(0xffff)) {\r\nu32 *p = (u32 *) fch;\r\nswab32s(p + 0);\r\nswab32s(p + 1);\r\nswab32s(p + 2);\r\nswab32s(p + 3);\r\nprintk (KERN_WARNING MYNAM ": %s: WARNING - Broadcast swap F/W bug detected!\n",\r\nNETDEV_PTR_TO_IOC_NAME_s(dev));\r\nprintk (KERN_WARNING MYNAM ": Please update sender @ MAC_addr = %pM\n",\r\nfch->saddr);\r\n}\r\nif (*fch->daddr & 1) {\r\nif (!memcmp(fch->daddr, dev->broadcast, FC_ALEN)) {\r\nskb->pkt_type = PACKET_BROADCAST;\r\n} else {\r\nskb->pkt_type = PACKET_MULTICAST;\r\n}\r\n} else {\r\nif (memcmp(fch->daddr, dev->dev_addr, FC_ALEN)) {\r\nskb->pkt_type = PACKET_OTHERHOST;\r\n} else {\r\nskb->pkt_type = PACKET_HOST;\r\n}\r\n}\r\nfcllc = (struct fcllc *)skb->data;\r\nif (fcllc->dsap == EXTENDED_SAP &&\r\n(fcllc->ethertype == htons(ETH_P_IP) ||\r\nfcllc->ethertype == htons(ETH_P_ARP))) {\r\nskb_pull(skb, sizeof(struct fcllc));\r\nreturn fcllc->ethertype;\r\n}\r\nreturn htons(ETH_P_802_2);\r\n}
