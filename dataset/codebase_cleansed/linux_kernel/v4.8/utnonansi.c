void acpi_ut_strlwr(char *src_string)\r\n{\r\nchar *string;\r\nACPI_FUNCTION_ENTRY();\r\nif (!src_string) {\r\nreturn;\r\n}\r\nfor (string = src_string; *string; string++) {\r\n*string = (char)tolower((int)*string);\r\n}\r\n}\r\nvoid acpi_ut_strupr(char *src_string)\r\n{\r\nchar *string;\r\nACPI_FUNCTION_ENTRY();\r\nif (!src_string) {\r\nreturn;\r\n}\r\nfor (string = src_string; *string; string++) {\r\n*string = (char)toupper((int)*string);\r\n}\r\n}\r\nint acpi_ut_stricmp(char *string1, char *string2)\r\n{\r\nint c1;\r\nint c2;\r\ndo {\r\nc1 = tolower((int)*string1);\r\nc2 = tolower((int)*string2);\r\nstring1++;\r\nstring2++;\r\n}\r\nwhile ((c1 == c2) && (c1));\r\nreturn (c1 - c2);\r\n}\r\nu8 acpi_ut_safe_strcpy(char *dest, acpi_size dest_size, char *source)\r\n{\r\nif (strlen(source) >= dest_size) {\r\nreturn (TRUE);\r\n}\r\nstrcpy(dest, source);\r\nreturn (FALSE);\r\n}\r\nu8 acpi_ut_safe_strcat(char *dest, acpi_size dest_size, char *source)\r\n{\r\nif ((strlen(dest) + strlen(source)) >= dest_size) {\r\nreturn (TRUE);\r\n}\r\nstrcat(dest, source);\r\nreturn (FALSE);\r\n}\r\nu8\r\nacpi_ut_safe_strncat(char *dest,\r\nacpi_size dest_size,\r\nchar *source, acpi_size max_transfer_length)\r\n{\r\nacpi_size actual_transfer_length;\r\nactual_transfer_length = ACPI_MIN(max_transfer_length, strlen(source));\r\nif ((strlen(dest) + actual_transfer_length) >= dest_size) {\r\nreturn (TRUE);\r\n}\r\nstrncat(dest, source, max_transfer_length);\r\nreturn (FALSE);\r\n}\r\nacpi_status\r\nacpi_ut_strtoul64(char *string,\r\nu32 base, u32 max_integer_byte_width, u64 *ret_integer)\r\n{\r\nu32 this_digit = 0;\r\nu64 return_value = 0;\r\nu64 quotient;\r\nu64 dividend;\r\nu8 valid_digits = 0;\r\nu8 sign_of0x = 0;\r\nu8 term = 0;\r\nACPI_FUNCTION_TRACE_STR(ut_strtoul64, string);\r\nswitch (base) {\r\ncase ACPI_ANY_BASE:\r\ncase 10:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (!string) {\r\ngoto error_exit;\r\n}\r\nwhile ((*string) && (isspace((int)*string) || *string == '\t')) {\r\nstring++;\r\n}\r\nif (base == ACPI_ANY_BASE) {\r\nif ((*string == '0') && (tolower((int)*(string + 1)) == 'x')) {\r\nsign_of0x = 1;\r\nbase = 16;\r\nstring += 2;\r\n} else {\r\nbase = 10;\r\n}\r\n}\r\nif (!(*string) || isspace((int)*string) || *string == '\t') {\r\nif (base == ACPI_ANY_BASE) {\r\ngoto error_exit;\r\n} else {\r\ngoto all_done;\r\n}\r\n}\r\ndividend = (max_integer_byte_width <= ACPI_MAX32_BYTE_WIDTH) ?\r\nACPI_UINT32_MAX : ACPI_UINT64_MAX;\r\nwhile (*string) {\r\nif (isdigit((int)*string)) {\r\nthis_digit = ((u8)*string) - '0';\r\n} else if (base == 10) {\r\nterm = 1;\r\n} else {\r\nthis_digit = (u8)toupper((int)*string);\r\nif (isxdigit((int)this_digit)) {\r\nthis_digit = this_digit - 'A' + 10;\r\n} else {\r\nterm = 1;\r\n}\r\n}\r\nif (term) {\r\nif (base == ACPI_ANY_BASE) {\r\ngoto error_exit;\r\n} else {\r\nbreak;\r\n}\r\n} else if ((valid_digits == 0) && (this_digit == 0)\r\n&& !sign_of0x) {\r\nstring++;\r\ncontinue;\r\n}\r\nvalid_digits++;\r\nif (sign_of0x && ((valid_digits > 16) ||\r\n((valid_digits > 8)\r\n&& (max_integer_byte_width <=\r\nACPI_MAX32_BYTE_WIDTH)))) {\r\ngoto error_exit;\r\n}\r\n(void)acpi_ut_short_divide((dividend - (u64)this_digit), base,\r\n&quotient, NULL);\r\nif (return_value > quotient) {\r\nif (base == ACPI_ANY_BASE) {\r\ngoto error_exit;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn_value *= base;\r\nreturn_value += this_digit;\r\nstring++;\r\n}\r\nall_done:\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Converted value: %8.8X%8.8X\n",\r\nACPI_FORMAT_UINT64(return_value)));\r\n*ret_integer = return_value;\r\nreturn_ACPI_STATUS(AE_OK);\r\nerror_exit:\r\nif (base == 10) {\r\nreturn_ACPI_STATUS(AE_BAD_DECIMAL_CONSTANT);\r\n} else {\r\nreturn_ACPI_STATUS(AE_BAD_HEX_CONSTANT);\r\n}\r\n}\r\nacpi_status strtoul64(char *string, u32 base, u64 *ret_integer)\r\n{\r\nu32 index;\r\nu32 sign;\r\nu64 return_value = 0;\r\nacpi_status status = AE_OK;\r\n*ret_integer = 0;\r\nswitch (base) {\r\ncase 0:\r\ncase 8:\r\ncase 10:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nwhile (isspace((int)*string) || *string == '\t') {\r\n++string;\r\n}\r\nif (*string == '-') {\r\nsign = ACPI_SIGN_NEGATIVE;\r\n++string;\r\n} else if (*string == '+') {\r\n++string;\r\nsign = ACPI_SIGN_POSITIVE;\r\n} else {\r\nsign = ACPI_SIGN_POSITIVE;\r\n}\r\nif (base == 0) {\r\nif (*string == '0') {\r\nif (tolower((int)*(++string)) == 'x') {\r\nbase = 16;\r\n++string;\r\n} else {\r\nbase = 8;\r\n}\r\n} else {\r\nbase = 10;\r\n}\r\n}\r\nif (base == 8 && *string == '0') {\r\nstring++;\r\n}\r\nif (base == 16 && *string == '0' && tolower((int)*(++string)) == 'x') {\r\nstring++;\r\n}\r\nwhile (*string) {\r\nif (isdigit((int)*string)) {\r\nindex = ((u8)*string) - '0';\r\n} else {\r\nindex = (u8)toupper((int)*string);\r\nif (isupper((int)index)) {\r\nindex = index - 'A' + 10;\r\n} else {\r\ngoto error_exit;\r\n}\r\n}\r\nif (index >= base) {\r\ngoto error_exit;\r\n}\r\nif (return_value > ((ACPI_UINT64_MAX - (u64)index) / (u64)base)) {\r\ngoto error_exit;\r\n} else {\r\nreturn_value *= base;\r\nreturn_value += index;\r\n}\r\n++string;\r\n}\r\nif (sign == ACPI_SIGN_NEGATIVE) {\r\nreturn_value = (ACPI_UINT32_MAX - return_value) + 1;\r\n}\r\n*ret_integer = return_value;\r\nreturn (status);\r\nerror_exit:\r\nswitch (base) {\r\ncase 8:\r\nstatus = AE_BAD_OCTAL_CONSTANT;\r\nbreak;\r\ncase 10:\r\nstatus = AE_BAD_DECIMAL_CONSTANT;\r\nbreak;\r\ncase 16:\r\nstatus = AE_BAD_HEX_CONSTANT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn (status);\r\n}
