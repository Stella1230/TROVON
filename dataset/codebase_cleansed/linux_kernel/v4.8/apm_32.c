static void apm_error(char *str, int err)\r\n{\r\nint i;\r\nfor (i = 0; i < ERROR_COUNT; i++)\r\nif (error_table[i].key == err)\r\nbreak;\r\nif (i < ERROR_COUNT)\r\npr_notice("%s: %s\n", str, error_table[i].msg);\r\nelse if (err < 0)\r\npr_notice("%s: linux error code %i\n", str, err);\r\nelse\r\npr_notice("%s: unknown error code %#2.2x\n",\r\nstr, err);\r\n}\r\nstatic inline unsigned long __apm_irq_save(void)\r\n{\r\nunsigned long flags;\r\nlocal_save_flags(flags);\r\nif (apm_info.allow_ints) {\r\nif (irqs_disabled_flags(flags))\r\nlocal_irq_enable();\r\n} else\r\nlocal_irq_disable();\r\nreturn flags;\r\n}\r\nstatic inline void apm_irq_restore(unsigned long flags)\r\n{\r\nif (irqs_disabled_flags(flags))\r\nlocal_irq_disable();\r\nelse if (irqs_disabled())\r\nlocal_irq_enable();\r\n}\r\nstatic long __apm_bios_call(void *_call)\r\n{\r\nAPM_DECL_SEGS\r\nunsigned long flags;\r\nint cpu;\r\nstruct desc_struct save_desc_40;\r\nstruct desc_struct *gdt;\r\nstruct apm_bios_call *call = _call;\r\ncpu = get_cpu();\r\nBUG_ON(cpu != 0);\r\ngdt = get_cpu_gdt_table(cpu);\r\nsave_desc_40 = gdt[0x40 / 8];\r\ngdt[0x40 / 8] = bad_bios_desc;\r\napm_irq_save(flags);\r\nAPM_DO_SAVE_SEGS;\r\napm_bios_call_asm(call->func, call->ebx, call->ecx,\r\n&call->eax, &call->ebx, &call->ecx, &call->edx,\r\n&call->esi);\r\nAPM_DO_RESTORE_SEGS;\r\napm_irq_restore(flags);\r\ngdt[0x40 / 8] = save_desc_40;\r\nput_cpu();\r\nreturn call->eax & 0xff;\r\n}\r\nstatic int on_cpu0(long (*fn)(void *), struct apm_bios_call *call)\r\n{\r\nint ret;\r\nif (get_cpu() == 0) {\r\nret = fn(call);\r\nput_cpu();\r\n} else {\r\nput_cpu();\r\nret = work_on_cpu(0, fn, call);\r\n}\r\nif (ret < 0)\r\ncall->err = ret;\r\nelse\r\ncall->err = (call->eax >> 8) & 0xff;\r\nreturn ret;\r\n}\r\nstatic int apm_bios_call(struct apm_bios_call *call)\r\n{\r\nreturn on_cpu0(__apm_bios_call, call);\r\n}\r\nstatic long __apm_bios_call_simple(void *_call)\r\n{\r\nu8 error;\r\nAPM_DECL_SEGS\r\nunsigned long flags;\r\nint cpu;\r\nstruct desc_struct save_desc_40;\r\nstruct desc_struct *gdt;\r\nstruct apm_bios_call *call = _call;\r\ncpu = get_cpu();\r\nBUG_ON(cpu != 0);\r\ngdt = get_cpu_gdt_table(cpu);\r\nsave_desc_40 = gdt[0x40 / 8];\r\ngdt[0x40 / 8] = bad_bios_desc;\r\napm_irq_save(flags);\r\nAPM_DO_SAVE_SEGS;\r\nerror = apm_bios_call_simple_asm(call->func, call->ebx, call->ecx,\r\n&call->eax);\r\nAPM_DO_RESTORE_SEGS;\r\napm_irq_restore(flags);\r\ngdt[0x40 / 8] = save_desc_40;\r\nput_cpu();\r\nreturn error;\r\n}\r\nstatic int apm_bios_call_simple(u32 func, u32 ebx_in, u32 ecx_in, u32 *eax,\r\nint *err)\r\n{\r\nstruct apm_bios_call call;\r\nint ret;\r\ncall.func = func;\r\ncall.ebx = ebx_in;\r\ncall.ecx = ecx_in;\r\nret = on_cpu0(__apm_bios_call_simple, &call);\r\n*eax = call.eax;\r\n*err = call.err;\r\nreturn ret;\r\n}\r\nstatic int apm_driver_version(u_short *val)\r\n{\r\nu32 eax;\r\nint err;\r\nif (apm_bios_call_simple(APM_FUNC_VERSION, 0, *val, &eax, &err))\r\nreturn err;\r\n*val = eax;\r\nreturn APM_SUCCESS;\r\n}\r\nstatic int apm_get_event(apm_event_t *event, apm_eventinfo_t *info)\r\n{\r\nstruct apm_bios_call call;\r\ncall.func = APM_FUNC_GET_EVENT;\r\ncall.ebx = call.ecx = 0;\r\nif (apm_bios_call(&call))\r\nreturn call.err;\r\n*event = call.ebx;\r\nif (apm_info.connection_version < 0x0102)\r\n*info = ~0;\r\nelse\r\n*info = call.ecx;\r\nreturn APM_SUCCESS;\r\n}\r\nstatic int set_power_state(u_short what, u_short state)\r\n{\r\nu32 eax;\r\nint err;\r\nif (apm_bios_call_simple(APM_FUNC_SET_STATE, what, state, &eax, &err))\r\nreturn err;\r\nreturn APM_SUCCESS;\r\n}\r\nstatic int set_system_power_state(u_short state)\r\n{\r\nreturn set_power_state(APM_DEVICE_ALL, state);\r\n}\r\nstatic int apm_do_idle(void)\r\n{\r\nu32 eax;\r\nu8 ret = 0;\r\nint idled = 0;\r\nint err = 0;\r\nif (!need_resched()) {\r\nidled = 1;\r\nret = apm_bios_call_simple(APM_FUNC_IDLE, 0, 0, &eax, &err);\r\n}\r\nif (!idled)\r\nreturn 0;\r\nif (ret) {\r\nstatic unsigned long t;\r\nif (++t < 5) {\r\nprintk(KERN_DEBUG "apm_do_idle failed (%d)\n", err);\r\nt = jiffies;\r\n}\r\nreturn -1;\r\n}\r\nclock_slowed = (apm_info.bios.flags & APM_IDLE_SLOWS_CLOCK) != 0;\r\nreturn clock_slowed;\r\n}\r\nstatic void apm_do_busy(void)\r\n{\r\nu32 dummy;\r\nint err;\r\nif (clock_slowed || ALWAYS_CALL_BUSY) {\r\n(void)apm_bios_call_simple(APM_FUNC_BUSY, 0, 0, &dummy, &err);\r\nclock_slowed = 0;\r\n}\r\n}\r\nstatic int apm_cpu_idle(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv, int index)\r\n{\r\nstatic int use_apm_idle;\r\nstatic unsigned int last_jiffies;\r\nstatic unsigned int last_stime;\r\ncputime_t stime;\r\nint apm_idle_done = 0;\r\nunsigned int jiffies_since_last_check = jiffies - last_jiffies;\r\nunsigned int bucket;\r\nrecalc:\r\ntask_cputime(current, NULL, &stime);\r\nif (jiffies_since_last_check > IDLE_CALC_LIMIT) {\r\nuse_apm_idle = 0;\r\n} else if (jiffies_since_last_check > idle_period) {\r\nunsigned int idle_percentage;\r\nidle_percentage = cputime_to_jiffies(stime - last_stime);\r\nidle_percentage *= 100;\r\nidle_percentage /= jiffies_since_last_check;\r\nuse_apm_idle = (idle_percentage > idle_threshold);\r\nif (apm_info.forbid_idle)\r\nuse_apm_idle = 0;\r\n}\r\nlast_jiffies = jiffies;\r\nlast_stime = stime;\r\nbucket = IDLE_LEAKY_MAX;\r\nwhile (!need_resched()) {\r\nif (use_apm_idle) {\r\nunsigned int t;\r\nt = jiffies;\r\nswitch (apm_do_idle()) {\r\ncase 0:\r\napm_idle_done = 1;\r\nif (t != jiffies) {\r\nif (bucket) {\r\nbucket = IDLE_LEAKY_MAX;\r\ncontinue;\r\n}\r\n} else if (bucket) {\r\nbucket--;\r\ncontinue;\r\n}\r\nbreak;\r\ncase 1:\r\napm_idle_done = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ndefault_idle();\r\nlocal_irq_disable();\r\njiffies_since_last_check = jiffies - last_jiffies;\r\nif (jiffies_since_last_check > idle_period)\r\ngoto recalc;\r\n}\r\nif (apm_idle_done)\r\napm_do_busy();\r\nreturn index;\r\n}\r\nstatic void apm_power_off(void)\r\n{\r\nif (apm_info.realmode_power_off) {\r\nset_cpus_allowed_ptr(current, cpumask_of(0));\r\nmachine_real_restart(MRR_APM);\r\n} else {\r\n(void)set_system_power_state(APM_STATE_OFF);\r\n}\r\n}\r\nstatic int apm_enable_power_management(int enable)\r\n{\r\nu32 eax;\r\nint err;\r\nif ((enable == 0) && (apm_info.bios.flags & APM_BIOS_DISENGAGED))\r\nreturn APM_NOT_ENGAGED;\r\nif (apm_bios_call_simple(APM_FUNC_ENABLE_PM, APM_DEVICE_BALL,\r\nenable, &eax, &err))\r\nreturn err;\r\nif (enable)\r\napm_info.bios.flags &= ~APM_BIOS_DISABLED;\r\nelse\r\napm_info.bios.flags |= APM_BIOS_DISABLED;\r\nreturn APM_SUCCESS;\r\n}\r\nstatic int apm_get_power_status(u_short *status, u_short *bat, u_short *life)\r\n{\r\nstruct apm_bios_call call;\r\ncall.func = APM_FUNC_GET_STATUS;\r\ncall.ebx = APM_DEVICE_ALL;\r\ncall.ecx = 0;\r\nif (apm_info.get_power_status_broken)\r\nreturn APM_32_UNSUPPORTED;\r\nif (apm_bios_call(&call))\r\nreturn call.err;\r\n*status = call.ebx;\r\n*bat = call.ecx;\r\nif (apm_info.get_power_status_swabinminutes) {\r\n*life = swab16((u16)call.edx);\r\n*life |= 0x8000;\r\n} else\r\n*life = call.edx;\r\nreturn APM_SUCCESS;\r\n}\r\nstatic int apm_engage_power_management(u_short device, int enable)\r\n{\r\nu32 eax;\r\nint err;\r\nif ((enable == 0) && (device == APM_DEVICE_ALL)\r\n&& (apm_info.bios.flags & APM_BIOS_DISABLED))\r\nreturn APM_DISABLED;\r\nif (apm_bios_call_simple(APM_FUNC_ENGAGE_PM, device, enable,\r\n&eax, &err))\r\nreturn err;\r\nif (device == APM_DEVICE_ALL) {\r\nif (enable)\r\napm_info.bios.flags &= ~APM_BIOS_DISENGAGED;\r\nelse\r\napm_info.bios.flags |= APM_BIOS_DISENGAGED;\r\n}\r\nreturn APM_SUCCESS;\r\n}\r\nstatic int apm_console_blank(int blank)\r\n{\r\nint error = APM_NOT_ENGAGED;\r\nint i;\r\nu_short state;\r\nstatic const u_short dev[3] = { 0x100, 0x1FF, 0x101 };\r\nstate = blank ? APM_STATE_STANDBY : APM_STATE_READY;\r\nfor (i = 0; i < ARRAY_SIZE(dev); i++) {\r\nerror = set_power_state(dev[i], state);\r\nif ((error == APM_SUCCESS) || (error == APM_NO_ERROR))\r\nreturn 1;\r\nif (error == APM_NOT_ENGAGED)\r\nbreak;\r\n}\r\nif (error == APM_NOT_ENGAGED) {\r\nstatic int tried;\r\nint eng_error;\r\nif (tried++ == 0) {\r\neng_error = apm_engage_power_management(APM_DEVICE_ALL, 1);\r\nif (eng_error) {\r\napm_error("set display", error);\r\napm_error("engage interface", eng_error);\r\nreturn 0;\r\n} else\r\nreturn apm_console_blank(blank);\r\n}\r\n}\r\napm_error("set display", error);\r\nreturn 0;\r\n}\r\nstatic int queue_empty(struct apm_user *as)\r\n{\r\nreturn as->event_head == as->event_tail;\r\n}\r\nstatic apm_event_t get_queued_event(struct apm_user *as)\r\n{\r\nif (++as->event_tail >= APM_MAX_EVENTS)\r\nas->event_tail = 0;\r\nreturn as->events[as->event_tail];\r\n}\r\nstatic void queue_event(apm_event_t event, struct apm_user *sender)\r\n{\r\nstruct apm_user *as;\r\nspin_lock(&user_list_lock);\r\nif (user_list == NULL)\r\ngoto out;\r\nfor (as = user_list; as != NULL; as = as->next) {\r\nif ((as == sender) || (!as->reader))\r\ncontinue;\r\nif (++as->event_head >= APM_MAX_EVENTS)\r\nas->event_head = 0;\r\nif (as->event_head == as->event_tail) {\r\nstatic int notified;\r\nif (notified++ == 0)\r\npr_err("an event queue overflowed\n");\r\nif (++as->event_tail >= APM_MAX_EVENTS)\r\nas->event_tail = 0;\r\n}\r\nas->events[as->event_head] = event;\r\nif (!as->suser || !as->writer)\r\ncontinue;\r\nswitch (event) {\r\ncase APM_SYS_SUSPEND:\r\ncase APM_USER_SUSPEND:\r\nas->suspends_pending++;\r\nsuspends_pending++;\r\nbreak;\r\ncase APM_SYS_STANDBY:\r\ncase APM_USER_STANDBY:\r\nas->standbys_pending++;\r\nstandbys_pending++;\r\nbreak;\r\n}\r\n}\r\nwake_up_interruptible(&apm_waitqueue);\r\nout:\r\nspin_unlock(&user_list_lock);\r\n}\r\nstatic void reinit_timer(void)\r\n{\r\n#ifdef INIT_TIMER_AFTER_SUSPEND\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&i8253_lock, flags);\r\noutb_p(0x34, PIT_MODE);\r\nudelay(10);\r\noutb_p(LATCH & 0xff, PIT_CH0);\r\nudelay(10);\r\noutb_p(LATCH >> 8, PIT_CH0);\r\nudelay(10);\r\nraw_spin_unlock_irqrestore(&i8253_lock, flags);\r\n#endif\r\n}\r\nstatic int suspend(int vetoable)\r\n{\r\nint err;\r\nstruct apm_user *as;\r\ndpm_suspend_start(PMSG_SUSPEND);\r\ndpm_suspend_end(PMSG_SUSPEND);\r\nlocal_irq_disable();\r\nsyscore_suspend();\r\nlocal_irq_enable();\r\nsave_processor_state();\r\nerr = set_system_power_state(APM_STATE_SUSPEND);\r\nignore_normal_resume = 1;\r\nrestore_processor_state();\r\nlocal_irq_disable();\r\nreinit_timer();\r\nif (err == APM_NO_ERROR)\r\nerr = APM_SUCCESS;\r\nif (err != APM_SUCCESS)\r\napm_error("suspend", err);\r\nerr = (err == APM_SUCCESS) ? 0 : -EIO;\r\nsyscore_resume();\r\nlocal_irq_enable();\r\ndpm_resume_start(PMSG_RESUME);\r\ndpm_resume_end(PMSG_RESUME);\r\nqueue_event(APM_NORMAL_RESUME, NULL);\r\nspin_lock(&user_list_lock);\r\nfor (as = user_list; as != NULL; as = as->next) {\r\nas->suspend_wait = 0;\r\nas->suspend_result = err;\r\n}\r\nspin_unlock(&user_list_lock);\r\nwake_up_interruptible(&apm_suspend_waitqueue);\r\nreturn err;\r\n}\r\nstatic void standby(void)\r\n{\r\nint err;\r\ndpm_suspend_end(PMSG_SUSPEND);\r\nlocal_irq_disable();\r\nsyscore_suspend();\r\nlocal_irq_enable();\r\nerr = set_system_power_state(APM_STATE_STANDBY);\r\nif ((err != APM_SUCCESS) && (err != APM_NO_ERROR))\r\napm_error("standby", err);\r\nlocal_irq_disable();\r\nsyscore_resume();\r\nlocal_irq_enable();\r\ndpm_resume_start(PMSG_RESUME);\r\n}\r\nstatic apm_event_t get_event(void)\r\n{\r\nint error;\r\napm_event_t event = APM_NO_EVENTS;\r\napm_eventinfo_t info;\r\nstatic int notified;\r\nerror = apm_get_event(&event, &info);\r\nif (error == APM_SUCCESS)\r\nreturn event;\r\nif ((error != APM_NO_EVENTS) && (notified++ == 0))\r\napm_error("get_event", error);\r\nreturn 0;\r\n}\r\nstatic void check_events(void)\r\n{\r\napm_event_t event;\r\nstatic unsigned long last_resume;\r\nstatic int ignore_bounce;\r\nwhile ((event = get_event()) != 0) {\r\nif (debug) {\r\nif (event <= NR_APM_EVENT_NAME)\r\nprintk(KERN_DEBUG "apm: received %s notify\n",\r\napm_event_name[event - 1]);\r\nelse\r\nprintk(KERN_DEBUG "apm: received unknown "\r\n"event 0x%02x\n", event);\r\n}\r\nif (ignore_bounce\r\n&& (time_after(jiffies, last_resume + bounce_interval)))\r\nignore_bounce = 0;\r\nswitch (event) {\r\ncase APM_SYS_STANDBY:\r\ncase APM_USER_STANDBY:\r\nqueue_event(event, NULL);\r\nif (standbys_pending <= 0)\r\nstandby();\r\nbreak;\r\ncase APM_USER_SUSPEND:\r\n#ifdef CONFIG_APM_IGNORE_USER_SUSPEND\r\nif (apm_info.connection_version > 0x100)\r\nset_system_power_state(APM_STATE_REJECT);\r\nbreak;\r\n#endif\r\ncase APM_SYS_SUSPEND:\r\nif (ignore_bounce) {\r\nif (apm_info.connection_version > 0x100)\r\nset_system_power_state(APM_STATE_REJECT);\r\nbreak;\r\n}\r\nif (ignore_sys_suspend)\r\nreturn;\r\nignore_sys_suspend = 1;\r\nqueue_event(event, NULL);\r\nif (suspends_pending <= 0)\r\n(void) suspend(1);\r\nbreak;\r\ncase APM_NORMAL_RESUME:\r\ncase APM_CRITICAL_RESUME:\r\ncase APM_STANDBY_RESUME:\r\nignore_sys_suspend = 0;\r\nlast_resume = jiffies;\r\nignore_bounce = 1;\r\nif ((event != APM_NORMAL_RESUME)\r\n|| (ignore_normal_resume == 0)) {\r\ndpm_resume_end(PMSG_RESUME);\r\nqueue_event(event, NULL);\r\n}\r\nignore_normal_resume = 0;\r\nbreak;\r\ncase APM_CAPABILITY_CHANGE:\r\ncase APM_LOW_BATTERY:\r\ncase APM_POWER_STATUS_CHANGE:\r\nqueue_event(event, NULL);\r\nbreak;\r\ncase APM_UPDATE_TIME:\r\nbreak;\r\ncase APM_CRITICAL_SUSPEND:\r\n(void)suspend(0);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void apm_event_handler(void)\r\n{\r\nstatic int pending_count = 4;\r\nint err;\r\nif ((standbys_pending > 0) || (suspends_pending > 0)) {\r\nif ((apm_info.connection_version > 0x100) &&\r\n(pending_count-- <= 0)) {\r\npending_count = 4;\r\nif (debug)\r\nprintk(KERN_DEBUG "apm: setting state busy\n");\r\nerr = set_system_power_state(APM_STATE_BUSY);\r\nif (err)\r\napm_error("busy", err);\r\n}\r\n} else\r\npending_count = 4;\r\ncheck_events();\r\n}\r\nstatic void apm_mainloop(void)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(&apm_waitqueue, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nfor (;;) {\r\nschedule_timeout(APM_CHECK_TIMEOUT);\r\nif (kthread_should_stop())\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\napm_event_handler();\r\n}\r\nremove_wait_queue(&apm_waitqueue, &wait);\r\n}\r\nstatic int check_apm_user(struct apm_user *as, const char *func)\r\n{\r\nif (as == NULL || as->magic != APM_BIOS_MAGIC) {\r\npr_err("%s passed bad filp\n", func);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t do_read(struct file *fp, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct apm_user *as;\r\nint i;\r\napm_event_t event;\r\nas = fp->private_data;\r\nif (check_apm_user(as, "read"))\r\nreturn -EIO;\r\nif ((int)count < sizeof(apm_event_t))\r\nreturn -EINVAL;\r\nif ((queue_empty(as)) && (fp->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\nwait_event_interruptible(apm_waitqueue, !queue_empty(as));\r\ni = count;\r\nwhile ((i >= sizeof(event)) && !queue_empty(as)) {\r\nevent = get_queued_event(as);\r\nif (copy_to_user(buf, &event, sizeof(event))) {\r\nif (i < count)\r\nbreak;\r\nreturn -EFAULT;\r\n}\r\nswitch (event) {\r\ncase APM_SYS_SUSPEND:\r\ncase APM_USER_SUSPEND:\r\nas->suspends_read++;\r\nbreak;\r\ncase APM_SYS_STANDBY:\r\ncase APM_USER_STANDBY:\r\nas->standbys_read++;\r\nbreak;\r\n}\r\nbuf += sizeof(event);\r\ni -= sizeof(event);\r\n}\r\nif (i < count)\r\nreturn count - i;\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nreturn 0;\r\n}\r\nstatic unsigned int do_poll(struct file *fp, poll_table *wait)\r\n{\r\nstruct apm_user *as;\r\nas = fp->private_data;\r\nif (check_apm_user(as, "poll"))\r\nreturn 0;\r\npoll_wait(fp, &apm_waitqueue, wait);\r\nif (!queue_empty(as))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic long do_ioctl(struct file *filp, u_int cmd, u_long arg)\r\n{\r\nstruct apm_user *as;\r\nint ret;\r\nas = filp->private_data;\r\nif (check_apm_user(as, "ioctl"))\r\nreturn -EIO;\r\nif (!as->suser || !as->writer)\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase APM_IOC_STANDBY:\r\nmutex_lock(&apm_mutex);\r\nif (as->standbys_read > 0) {\r\nas->standbys_read--;\r\nas->standbys_pending--;\r\nstandbys_pending--;\r\n} else\r\nqueue_event(APM_USER_STANDBY, as);\r\nif (standbys_pending <= 0)\r\nstandby();\r\nmutex_unlock(&apm_mutex);\r\nbreak;\r\ncase APM_IOC_SUSPEND:\r\nmutex_lock(&apm_mutex);\r\nif (as->suspends_read > 0) {\r\nas->suspends_read--;\r\nas->suspends_pending--;\r\nsuspends_pending--;\r\n} else\r\nqueue_event(APM_USER_SUSPEND, as);\r\nif (suspends_pending <= 0) {\r\nret = suspend(1);\r\nmutex_unlock(&apm_mutex);\r\n} else {\r\nas->suspend_wait = 1;\r\nmutex_unlock(&apm_mutex);\r\nwait_event_interruptible(apm_suspend_waitqueue,\r\nas->suspend_wait == 0);\r\nret = as->suspend_result;\r\n}\r\nreturn ret;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct apm_user *as;\r\nas = filp->private_data;\r\nif (check_apm_user(as, "release"))\r\nreturn 0;\r\nfilp->private_data = NULL;\r\nif (as->standbys_pending > 0) {\r\nstandbys_pending -= as->standbys_pending;\r\nif (standbys_pending <= 0)\r\nstandby();\r\n}\r\nif (as->suspends_pending > 0) {\r\nsuspends_pending -= as->suspends_pending;\r\nif (suspends_pending <= 0)\r\n(void) suspend(1);\r\n}\r\nspin_lock(&user_list_lock);\r\nif (user_list == as)\r\nuser_list = as->next;\r\nelse {\r\nstruct apm_user *as1;\r\nfor (as1 = user_list;\r\n(as1 != NULL) && (as1->next != as);\r\nas1 = as1->next)\r\n;\r\nif (as1 == NULL)\r\npr_err("filp not in user list\n");\r\nelse\r\nas1->next = as->next;\r\n}\r\nspin_unlock(&user_list_lock);\r\nkfree(as);\r\nreturn 0;\r\n}\r\nstatic int do_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct apm_user *as;\r\nas = kmalloc(sizeof(*as), GFP_KERNEL);\r\nif (as == NULL)\r\nreturn -ENOMEM;\r\nas->magic = APM_BIOS_MAGIC;\r\nas->event_tail = as->event_head = 0;\r\nas->suspends_pending = as->standbys_pending = 0;\r\nas->suspends_read = as->standbys_read = 0;\r\nas->suser = capable(CAP_SYS_ADMIN);\r\nas->writer = (filp->f_mode & FMODE_WRITE) == FMODE_WRITE;\r\nas->reader = (filp->f_mode & FMODE_READ) == FMODE_READ;\r\nspin_lock(&user_list_lock);\r\nas->next = user_list;\r\nuser_list = as;\r\nspin_unlock(&user_list_lock);\r\nfilp->private_data = as;\r\nreturn 0;\r\n}\r\nstatic int proc_apm_show(struct seq_file *m, void *v)\r\n{\r\nunsigned short bx;\r\nunsigned short cx;\r\nunsigned short dx;\r\nint error;\r\nunsigned short ac_line_status = 0xff;\r\nunsigned short battery_status = 0xff;\r\nunsigned short battery_flag = 0xff;\r\nint percentage = -1;\r\nint time_units = -1;\r\nchar *units = "?";\r\nif ((num_online_cpus() == 1) &&\r\n!(error = apm_get_power_status(&bx, &cx, &dx))) {\r\nac_line_status = (bx >> 8) & 0xff;\r\nbattery_status = bx & 0xff;\r\nif ((cx & 0xff) != 0xff)\r\npercentage = cx & 0xff;\r\nif (apm_info.connection_version > 0x100) {\r\nbattery_flag = (cx >> 8) & 0xff;\r\nif (dx != 0xffff) {\r\nunits = (dx & 0x8000) ? "min" : "sec";\r\ntime_units = dx & 0x7fff;\r\n}\r\n}\r\n}\r\nseq_printf(m, "%s %d.%d 0x%02x 0x%02x 0x%02x 0x%02x %d%% %d %s\n",\r\ndriver_version,\r\n(apm_info.bios.version >> 8) & 0xff,\r\napm_info.bios.version & 0xff,\r\napm_info.bios.flags,\r\nac_line_status,\r\nbattery_status,\r\nbattery_flag,\r\npercentage,\r\ntime_units,\r\nunits);\r\nreturn 0;\r\n}\r\nstatic int proc_apm_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_apm_show, NULL);\r\n}\r\nstatic int apm(void *unused)\r\n{\r\nunsigned short bx;\r\nunsigned short cx;\r\nunsigned short dx;\r\nint error;\r\nchar *power_stat;\r\nchar *bat_stat;\r\nset_cpus_allowed_ptr(current, cpumask_of(0));\r\nBUG_ON(smp_processor_id() != 0);\r\nif (apm_info.connection_version == 0) {\r\napm_info.connection_version = apm_info.bios.version;\r\nif (apm_info.connection_version > 0x100) {\r\nif (apm_info.connection_version > 0x0102)\r\napm_info.connection_version = 0x0102;\r\nerror = apm_driver_version(&apm_info.connection_version);\r\nif (error != APM_SUCCESS) {\r\napm_error("driver version", error);\r\napm_info.connection_version = 0x100;\r\n}\r\n}\r\n}\r\nif (debug)\r\nprintk(KERN_INFO "apm: Connection version %d.%d\n",\r\n(apm_info.connection_version >> 8) & 0xff,\r\napm_info.connection_version & 0xff);\r\n#ifdef CONFIG_APM_DO_ENABLE\r\nif (apm_info.bios.flags & APM_BIOS_DISABLED) {\r\nerror = apm_enable_power_management(1);\r\nif (error) {\r\napm_error("enable power management", error);\r\nreturn -1;\r\n}\r\n}\r\n#endif\r\nif ((apm_info.bios.flags & APM_BIOS_DISENGAGED)\r\n&& (apm_info.connection_version > 0x0100)) {\r\nerror = apm_engage_power_management(APM_DEVICE_ALL, 1);\r\nif (error) {\r\napm_error("engage power management", error);\r\nreturn -1;\r\n}\r\n}\r\nif (debug && (num_online_cpus() == 1 || smp)) {\r\nerror = apm_get_power_status(&bx, &cx, &dx);\r\nif (error)\r\nprintk(KERN_INFO "apm: power status not available\n");\r\nelse {\r\nswitch ((bx >> 8) & 0xff) {\r\ncase 0:\r\npower_stat = "off line";\r\nbreak;\r\ncase 1:\r\npower_stat = "on line";\r\nbreak;\r\ncase 2:\r\npower_stat = "on backup power";\r\nbreak;\r\ndefault:\r\npower_stat = "unknown";\r\nbreak;\r\n}\r\nswitch (bx & 0xff) {\r\ncase 0:\r\nbat_stat = "high";\r\nbreak;\r\ncase 1:\r\nbat_stat = "low";\r\nbreak;\r\ncase 2:\r\nbat_stat = "critical";\r\nbreak;\r\ncase 3:\r\nbat_stat = "charging";\r\nbreak;\r\ndefault:\r\nbat_stat = "unknown";\r\nbreak;\r\n}\r\nprintk(KERN_INFO\r\n"apm: AC %s, battery status %s, battery life ",\r\npower_stat, bat_stat);\r\nif ((cx & 0xff) == 0xff)\r\nprintk("unknown\n");\r\nelse\r\nprintk("%d%%\n", cx & 0xff);\r\nif (apm_info.connection_version > 0x100) {\r\nprintk(KERN_INFO\r\n"apm: battery flag 0x%02x, battery life ",\r\n(cx >> 8) & 0xff);\r\nif (dx == 0xffff)\r\nprintk("unknown\n");\r\nelse\r\nprintk("%d %s\n", dx & 0x7fff,\r\n(dx & 0x8000) ?\r\n"minutes" : "seconds");\r\n}\r\n}\r\n}\r\nif (power_off)\r\npm_power_off = apm_power_off;\r\nif (num_online_cpus() == 1 || smp) {\r\n#if defined(CONFIG_APM_DISPLAY_BLANK) && defined(CONFIG_VT)\r\nconsole_blank_hook = apm_console_blank;\r\n#endif\r\napm_mainloop();\r\n#if defined(CONFIG_APM_DISPLAY_BLANK) && defined(CONFIG_VT)\r\nconsole_blank_hook = NULL;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init apm_setup(char *str)\r\n{\r\nint invert;\r\nwhile ((str != NULL) && (*str != '\0')) {\r\nif (strncmp(str, "off", 3) == 0)\r\napm_disabled = 1;\r\nif (strncmp(str, "on", 2) == 0)\r\napm_disabled = 0;\r\nif ((strncmp(str, "bounce-interval=", 16) == 0) ||\r\n(strncmp(str, "bounce_interval=", 16) == 0))\r\nbounce_interval = simple_strtol(str + 16, NULL, 0);\r\nif ((strncmp(str, "idle-threshold=", 15) == 0) ||\r\n(strncmp(str, "idle_threshold=", 15) == 0))\r\nidle_threshold = simple_strtol(str + 15, NULL, 0);\r\nif ((strncmp(str, "idle-period=", 12) == 0) ||\r\n(strncmp(str, "idle_period=", 12) == 0))\r\nidle_period = simple_strtol(str + 12, NULL, 0);\r\ninvert = (strncmp(str, "no-", 3) == 0) ||\r\n(strncmp(str, "no_", 3) == 0);\r\nif (invert)\r\nstr += 3;\r\nif (strncmp(str, "debug", 5) == 0)\r\ndebug = !invert;\r\nif ((strncmp(str, "power-off", 9) == 0) ||\r\n(strncmp(str, "power_off", 9) == 0))\r\npower_off = !invert;\r\nif (strncmp(str, "smp", 3) == 0) {\r\nsmp = !invert;\r\nidle_threshold = 100;\r\n}\r\nif ((strncmp(str, "allow-ints", 10) == 0) ||\r\n(strncmp(str, "allow_ints", 10) == 0))\r\napm_info.allow_ints = !invert;\r\nif ((strncmp(str, "broken-psr", 10) == 0) ||\r\n(strncmp(str, "broken_psr", 10) == 0))\r\napm_info.get_power_status_broken = !invert;\r\nif ((strncmp(str, "realmode-power-off", 18) == 0) ||\r\n(strncmp(str, "realmode_power_off", 18) == 0))\r\napm_info.realmode_power_off = !invert;\r\nstr = strchr(str, ',');\r\nif (str != NULL)\r\nstr += strspn(str, ", \t");\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init print_if_true(const struct dmi_system_id *d)\r\n{\r\nprintk("%s\n", d->ident);\r\nreturn 0;\r\n}\r\nstatic int __init broken_ps2_resume(const struct dmi_system_id *d)\r\n{\r\nprintk(KERN_INFO "%s machine detected. Mousepad Resume Bug "\r\n"workaround hopefully not needed.\n", d->ident);\r\nreturn 0;\r\n}\r\nstatic int __init set_realmode_power_off(const struct dmi_system_id *d)\r\n{\r\nif (apm_info.realmode_power_off == 0) {\r\napm_info.realmode_power_off = 1;\r\nprintk(KERN_INFO "%s bios detected. "\r\n"Using realmode poweroff only.\n", d->ident);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init set_apm_ints(const struct dmi_system_id *d)\r\n{\r\nif (apm_info.allow_ints == 0) {\r\napm_info.allow_ints = 1;\r\nprintk(KERN_INFO "%s machine detected. "\r\n"Enabling interrupts during APM calls.\n", d->ident);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init apm_is_horked(const struct dmi_system_id *d)\r\n{\r\nif (apm_info.disabled == 0) {\r\napm_info.disabled = 1;\r\nprintk(KERN_INFO "%s machine detected. "\r\n"Disabling APM.\n", d->ident);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init apm_is_horked_d850md(const struct dmi_system_id *d)\r\n{\r\nif (apm_info.disabled == 0) {\r\napm_info.disabled = 1;\r\nprintk(KERN_INFO "%s machine detected. "\r\n"Disabling APM.\n", d->ident);\r\nprintk(KERN_INFO "This bug is fixed in bios P15 which is available for\n");\r\nprintk(KERN_INFO "download from support.intel.com\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init apm_likes_to_melt(const struct dmi_system_id *d)\r\n{\r\nif (apm_info.forbid_idle == 0) {\r\napm_info.forbid_idle = 1;\r\nprintk(KERN_INFO "%s machine detected. "\r\n"Disabling APM idle calls.\n", d->ident);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init broken_apm_power(const struct dmi_system_id *d)\r\n{\r\napm_info.get_power_status_broken = 1;\r\nprintk(KERN_WARNING "BIOS strings suggest APM bugs, "\r\n"disabling power status reporting.\n");\r\nreturn 0;\r\n}\r\nstatic int __init swab_apm_power_in_minutes(const struct dmi_system_id *d)\r\n{\r\napm_info.get_power_status_swabinminutes = 1;\r\nprintk(KERN_WARNING "BIOS strings suggest APM reports battery life "\r\n"in minutes and wrong byte order.\n");\r\nreturn 0;\r\n}\r\nstatic int __init apm_init(void)\r\n{\r\nstruct desc_struct *gdt;\r\nint err;\r\ndmi_check_system(apm_dmi_table);\r\nif (apm_info.bios.version == 0 || machine_is_olpc()) {\r\nprintk(KERN_INFO "apm: BIOS not found.\n");\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO\r\n"apm: BIOS version %d.%d Flags 0x%02x (Driver version %s)\n",\r\n((apm_info.bios.version >> 8) & 0xff),\r\n(apm_info.bios.version & 0xff),\r\napm_info.bios.flags,\r\ndriver_version);\r\nif ((apm_info.bios.flags & APM_32_BIT_SUPPORT) == 0) {\r\nprintk(KERN_INFO "apm: no 32 bit BIOS support\n");\r\nreturn -ENODEV;\r\n}\r\nif (allow_ints)\r\napm_info.allow_ints = 1;\r\nif (broken_psr)\r\napm_info.get_power_status_broken = 1;\r\nif (realmode_power_off)\r\napm_info.realmode_power_off = 1;\r\nif (apm_disabled != -1)\r\napm_info.disabled = apm_disabled;\r\nif (apm_info.bios.version == 0x001)\r\napm_info.bios.version = 0x100;\r\nif (apm_info.bios.version < 0x102)\r\napm_info.bios.cseg_16_len = 0;\r\nif (debug) {\r\nprintk(KERN_INFO "apm: entry %x:%x cseg16 %x dseg %x",\r\napm_info.bios.cseg, apm_info.bios.offset,\r\napm_info.bios.cseg_16, apm_info.bios.dseg);\r\nif (apm_info.bios.version > 0x100)\r\nprintk(" cseg len %x, dseg len %x",\r\napm_info.bios.cseg_len,\r\napm_info.bios.dseg_len);\r\nif (apm_info.bios.version > 0x101)\r\nprintk(" cseg16 len %x", apm_info.bios.cseg_16_len);\r\nprintk("\n");\r\n}\r\nif (apm_info.disabled) {\r\npr_notice("disabled on user request.\n");\r\nreturn -ENODEV;\r\n}\r\nif ((num_online_cpus() > 1) && !power_off && !smp) {\r\npr_notice("disabled - APM is not SMP safe.\n");\r\napm_info.disabled = 1;\r\nreturn -ENODEV;\r\n}\r\nif (!acpi_disabled) {\r\npr_notice("overridden by ACPI.\n");\r\napm_info.disabled = 1;\r\nreturn -ENODEV;\r\n}\r\napm_bios_entry.offset = apm_info.bios.offset;\r\napm_bios_entry.segment = APM_CS;\r\ngdt = get_cpu_gdt_table(0);\r\nset_desc_base(&gdt[APM_CS >> 3],\r\n(unsigned long)__va((unsigned long)apm_info.bios.cseg << 4));\r\nset_desc_base(&gdt[APM_CS_16 >> 3],\r\n(unsigned long)__va((unsigned long)apm_info.bios.cseg_16 << 4));\r\nset_desc_base(&gdt[APM_DS >> 3],\r\n(unsigned long)__va((unsigned long)apm_info.bios.dseg << 4));\r\nproc_create("apm", 0, NULL, &apm_file_ops);\r\nkapmd_task = kthread_create(apm, NULL, "kapmd");\r\nif (IS_ERR(kapmd_task)) {\r\npr_err("disabled - Unable to start kernel thread\n");\r\nerr = PTR_ERR(kapmd_task);\r\nkapmd_task = NULL;\r\nremove_proc_entry("apm", NULL);\r\nreturn err;\r\n}\r\nwake_up_process(kapmd_task);\r\nif (num_online_cpus() > 1 && !smp) {\r\nprintk(KERN_NOTICE\r\n"apm: disabled - APM is not SMP safe (power off active).\n");\r\nreturn 0;\r\n}\r\nif (misc_register(&apm_device))\r\nprintk(KERN_WARNING "apm: Could not register misc device.\n");\r\nif (HZ != 100)\r\nidle_period = (idle_period * HZ) / 100;\r\nif (idle_threshold < 100) {\r\nif (!cpuidle_register_driver(&apm_idle_driver))\r\nif (cpuidle_register_device(&apm_cpuidle_device))\r\ncpuidle_unregister_driver(&apm_idle_driver);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit apm_exit(void)\r\n{\r\nint error;\r\ncpuidle_unregister_device(&apm_cpuidle_device);\r\ncpuidle_unregister_driver(&apm_idle_driver);\r\nif (((apm_info.bios.flags & APM_BIOS_DISENGAGED) == 0)\r\n&& (apm_info.connection_version > 0x0100)) {\r\nerror = apm_engage_power_management(APM_DEVICE_ALL, 0);\r\nif (error)\r\napm_error("disengage power management", error);\r\n}\r\nmisc_deregister(&apm_device);\r\nremove_proc_entry("apm", NULL);\r\nif (power_off)\r\npm_power_off = NULL;\r\nif (kapmd_task) {\r\nkthread_stop(kapmd_task);\r\nkapmd_task = NULL;\r\n}\r\n}
