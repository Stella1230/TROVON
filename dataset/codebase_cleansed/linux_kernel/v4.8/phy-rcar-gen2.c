static int rcar_gen2_phy_init(struct phy *p)\r\n{\r\nstruct rcar_gen2_phy *phy = phy_get_drvdata(p);\r\nstruct rcar_gen2_channel *channel = phy->channel;\r\nstruct rcar_gen2_phy_driver *drv = channel->drv;\r\nunsigned long flags;\r\nu32 ugctrl2;\r\nif (cmpxchg(&channel->selected_phy, -1, phy->number) != -1)\r\nreturn -EBUSY;\r\nclk_prepare_enable(drv->clk);\r\nspin_lock_irqsave(&drv->lock, flags);\r\nugctrl2 = readl(drv->base + USBHS_UGCTRL2);\r\nugctrl2 &= ~channel->select_mask;\r\nugctrl2 |= phy->select_value;\r\nwritel(ugctrl2, drv->base + USBHS_UGCTRL2);\r\nspin_unlock_irqrestore(&drv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int rcar_gen2_phy_exit(struct phy *p)\r\n{\r\nstruct rcar_gen2_phy *phy = phy_get_drvdata(p);\r\nstruct rcar_gen2_channel *channel = phy->channel;\r\nclk_disable_unprepare(channel->drv->clk);\r\nchannel->selected_phy = -1;\r\nreturn 0;\r\n}\r\nstatic int rcar_gen2_phy_power_on(struct phy *p)\r\n{\r\nstruct rcar_gen2_phy *phy = phy_get_drvdata(p);\r\nstruct rcar_gen2_phy_driver *drv = phy->channel->drv;\r\nvoid __iomem *base = drv->base;\r\nunsigned long flags;\r\nu32 value;\r\nint err = 0, i;\r\nif (phy->select_value != USBHS_UGCTRL2_USB0SEL_HS_USB)\r\nreturn 0;\r\nspin_lock_irqsave(&drv->lock, flags);\r\nvalue = readl(base + USBHS_UGCTRL);\r\nvalue &= ~USBHS_UGCTRL_PLLRESET;\r\nwritel(value, base + USBHS_UGCTRL);\r\nvalue = readw(base + USBHS_LPSTS);\r\nvalue |= USBHS_LPSTS_SUSPM;\r\nwritew(value, base + USBHS_LPSTS);\r\nfor (i = 0; i < 20; i++) {\r\nvalue = readl(base + USBHS_UGSTS);\r\nif ((value & USBHS_UGSTS_LOCK) == USBHS_UGSTS_LOCK) {\r\nvalue = readl(base + USBHS_UGCTRL);\r\nvalue |= USBHS_UGCTRL_CONNECT;\r\nwritel(value, base + USBHS_UGCTRL);\r\ngoto out;\r\n}\r\nudelay(1);\r\n}\r\nerr = -ETIMEDOUT;\r\nout:\r\nspin_unlock_irqrestore(&drv->lock, flags);\r\nreturn err;\r\n}\r\nstatic int rcar_gen2_phy_power_off(struct phy *p)\r\n{\r\nstruct rcar_gen2_phy *phy = phy_get_drvdata(p);\r\nstruct rcar_gen2_phy_driver *drv = phy->channel->drv;\r\nvoid __iomem *base = drv->base;\r\nunsigned long flags;\r\nu32 value;\r\nif (phy->select_value != USBHS_UGCTRL2_USB0SEL_HS_USB)\r\nreturn 0;\r\nspin_lock_irqsave(&drv->lock, flags);\r\nvalue = readl(base + USBHS_UGCTRL);\r\nvalue &= ~USBHS_UGCTRL_CONNECT;\r\nwritel(value, base + USBHS_UGCTRL);\r\nvalue = readw(base + USBHS_LPSTS);\r\nvalue &= ~USBHS_LPSTS_SUSPM;\r\nwritew(value, base + USBHS_LPSTS);\r\nvalue = readl(base + USBHS_UGCTRL);\r\nvalue |= USBHS_UGCTRL_PLLRESET;\r\nwritel(value, base + USBHS_UGCTRL);\r\nspin_unlock_irqrestore(&drv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct phy *rcar_gen2_phy_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct rcar_gen2_phy_driver *drv;\r\nstruct device_node *np = args->np;\r\nint i;\r\ndrv = dev_get_drvdata(dev);\r\nif (!drv)\r\nreturn ERR_PTR(-EINVAL);\r\nfor (i = 0; i < drv->num_channels; i++) {\r\nif (np == drv->channels[i].of_node)\r\nbreak;\r\n}\r\nif (i >= drv->num_channels || args->args[0] >= 2)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn drv->channels[i].phys[args->args[0]].phy;\r\n}\r\nstatic int rcar_gen2_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rcar_gen2_phy_driver *drv;\r\nstruct phy_provider *provider;\r\nstruct device_node *np;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nstruct clk *clk;\r\nint i = 0;\r\nif (!dev->of_node) {\r\ndev_err(dev,\r\n"This driver is required to be instantiated from device tree\n");\r\nreturn -EINVAL;\r\n}\r\nclk = devm_clk_get(dev, "usbhs");\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "Can't get USBHS clock\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndrv = devm_kzalloc(dev, sizeof(*drv), GFP_KERNEL);\r\nif (!drv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&drv->lock);\r\ndrv->clk = clk;\r\ndrv->base = base;\r\ndrv->num_channels = of_get_child_count(dev->of_node);\r\ndrv->channels = devm_kcalloc(dev, drv->num_channels,\r\nsizeof(struct rcar_gen2_channel),\r\nGFP_KERNEL);\r\nif (!drv->channels)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(dev->of_node, np) {\r\nstruct rcar_gen2_channel *channel = drv->channels + i;\r\nu32 channel_num;\r\nint error, n;\r\nchannel->of_node = np;\r\nchannel->drv = drv;\r\nchannel->selected_phy = -1;\r\nerror = of_property_read_u32(np, "reg", &channel_num);\r\nif (error || channel_num > 2) {\r\ndev_err(dev, "Invalid \"reg\" property\n");\r\nreturn error;\r\n}\r\nchannel->select_mask = select_mask[channel_num];\r\nfor (n = 0; n < PHYS_PER_CHANNEL; n++) {\r\nstruct rcar_gen2_phy *phy = &channel->phys[n];\r\nphy->channel = channel;\r\nphy->number = n;\r\nphy->select_value = select_value[channel_num][n];\r\nphy->phy = devm_phy_create(dev, NULL,\r\n&rcar_gen2_phy_ops);\r\nif (IS_ERR(phy->phy)) {\r\ndev_err(dev, "Failed to create PHY\n");\r\nreturn PTR_ERR(phy->phy);\r\n}\r\nphy_set_drvdata(phy->phy, phy);\r\n}\r\ni++;\r\n}\r\nprovider = devm_of_phy_provider_register(dev, rcar_gen2_phy_xlate);\r\nif (IS_ERR(provider)) {\r\ndev_err(dev, "Failed to register PHY provider\n");\r\nreturn PTR_ERR(provider);\r\n}\r\ndev_set_drvdata(dev, drv);\r\nreturn 0;\r\n}
