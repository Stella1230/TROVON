u64 op_x86_get_ctrl(struct op_x86_model_spec const *model,\r\nstruct op_counter_config *counter_config)\r\n{\r\nu64 val = 0;\r\nu16 event = (u16)counter_config->event;\r\nval |= ARCH_PERFMON_EVENTSEL_INT;\r\nval |= counter_config->user ? ARCH_PERFMON_EVENTSEL_USR : 0;\r\nval |= counter_config->kernel ? ARCH_PERFMON_EVENTSEL_OS : 0;\r\nval |= (counter_config->unit_mask & 0xFF) << 8;\r\ncounter_config->extra &= (ARCH_PERFMON_EVENTSEL_INV |\r\nARCH_PERFMON_EVENTSEL_EDGE |\r\nARCH_PERFMON_EVENTSEL_CMASK);\r\nval |= counter_config->extra;\r\nevent &= model->event_mask ? model->event_mask : 0xFF;\r\nval |= event & 0xFF;\r\nval |= (u64)(event & 0x0F00) << 24;\r\nreturn val;\r\n}\r\nstatic int profile_exceptions_notify(unsigned int val, struct pt_regs *regs)\r\n{\r\nif (ctr_running)\r\nmodel->check_ctrs(regs, this_cpu_ptr(&cpu_msrs));\r\nelse if (!nmi_enabled)\r\nreturn NMI_DONE;\r\nelse\r\nmodel->stop(this_cpu_ptr(&cpu_msrs));\r\nreturn NMI_HANDLED;\r\n}\r\nstatic void nmi_cpu_save_registers(struct op_msrs *msrs)\r\n{\r\nstruct op_msr *counters = msrs->counters;\r\nstruct op_msr *controls = msrs->controls;\r\nunsigned int i;\r\nfor (i = 0; i < model->num_counters; ++i) {\r\nif (counters[i].addr)\r\nrdmsrl(counters[i].addr, counters[i].saved);\r\n}\r\nfor (i = 0; i < model->num_controls; ++i) {\r\nif (controls[i].addr)\r\nrdmsrl(controls[i].addr, controls[i].saved);\r\n}\r\n}\r\nstatic void nmi_cpu_start(void *dummy)\r\n{\r\nstruct op_msrs const *msrs = this_cpu_ptr(&cpu_msrs);\r\nif (!msrs->controls)\r\nWARN_ON_ONCE(1);\r\nelse\r\nmodel->start(msrs);\r\n}\r\nstatic int nmi_start(void)\r\n{\r\nget_online_cpus();\r\nctr_running = 1;\r\nsmp_mb();\r\non_each_cpu(nmi_cpu_start, NULL, 1);\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nstatic void nmi_cpu_stop(void *dummy)\r\n{\r\nstruct op_msrs const *msrs = this_cpu_ptr(&cpu_msrs);\r\nif (!msrs->controls)\r\nWARN_ON_ONCE(1);\r\nelse\r\nmodel->stop(msrs);\r\n}\r\nstatic void nmi_stop(void)\r\n{\r\nget_online_cpus();\r\non_each_cpu(nmi_cpu_stop, NULL, 1);\r\nctr_running = 0;\r\nput_online_cpus();\r\n}\r\nstatic inline int has_mux(void)\r\n{\r\nreturn !!model->switch_ctrl;\r\n}\r\ninline int op_x86_phys_to_virt(int phys)\r\n{\r\nreturn __this_cpu_read(switch_index) + phys;\r\n}\r\ninline int op_x86_virt_to_phys(int virt)\r\n{\r\nreturn virt % model->num_counters;\r\n}\r\nstatic void nmi_shutdown_mux(void)\r\n{\r\nint i;\r\nif (!has_mux())\r\nreturn;\r\nfor_each_possible_cpu(i) {\r\nkfree(per_cpu(cpu_msrs, i).multiplex);\r\nper_cpu(cpu_msrs, i).multiplex = NULL;\r\nper_cpu(switch_index, i) = 0;\r\n}\r\n}\r\nstatic int nmi_setup_mux(void)\r\n{\r\nsize_t multiplex_size =\r\nsizeof(struct op_msr) * model->num_virt_counters;\r\nint i;\r\nif (!has_mux())\r\nreturn 1;\r\nfor_each_possible_cpu(i) {\r\nper_cpu(cpu_msrs, i).multiplex =\r\nkzalloc(multiplex_size, GFP_KERNEL);\r\nif (!per_cpu(cpu_msrs, i).multiplex)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void nmi_cpu_setup_mux(int cpu, struct op_msrs const * const msrs)\r\n{\r\nint i;\r\nstruct op_msr *multiplex = msrs->multiplex;\r\nif (!has_mux())\r\nreturn;\r\nfor (i = 0; i < model->num_virt_counters; ++i) {\r\nif (counter_config[i].enabled) {\r\nmultiplex[i].saved = -(u64)counter_config[i].count;\r\n} else {\r\nmultiplex[i].saved = 0;\r\n}\r\n}\r\nper_cpu(switch_index, cpu) = 0;\r\n}\r\nstatic void nmi_cpu_save_mpx_registers(struct op_msrs *msrs)\r\n{\r\nstruct op_msr *counters = msrs->counters;\r\nstruct op_msr *multiplex = msrs->multiplex;\r\nint i;\r\nfor (i = 0; i < model->num_counters; ++i) {\r\nint virt = op_x86_phys_to_virt(i);\r\nif (counters[i].addr)\r\nrdmsrl(counters[i].addr, multiplex[virt].saved);\r\n}\r\n}\r\nstatic void nmi_cpu_restore_mpx_registers(struct op_msrs *msrs)\r\n{\r\nstruct op_msr *counters = msrs->counters;\r\nstruct op_msr *multiplex = msrs->multiplex;\r\nint i;\r\nfor (i = 0; i < model->num_counters; ++i) {\r\nint virt = op_x86_phys_to_virt(i);\r\nif (counters[i].addr)\r\nwrmsrl(counters[i].addr, multiplex[virt].saved);\r\n}\r\n}\r\nstatic void nmi_cpu_switch(void *dummy)\r\n{\r\nint cpu = smp_processor_id();\r\nint si = per_cpu(switch_index, cpu);\r\nstruct op_msrs *msrs = &per_cpu(cpu_msrs, cpu);\r\nnmi_cpu_stop(NULL);\r\nnmi_cpu_save_mpx_registers(msrs);\r\nsi += model->num_counters;\r\nif ((si >= model->num_virt_counters) || (counter_config[si].count == 0))\r\nper_cpu(switch_index, cpu) = 0;\r\nelse\r\nper_cpu(switch_index, cpu) = si;\r\nmodel->switch_ctrl(model, msrs);\r\nnmi_cpu_restore_mpx_registers(msrs);\r\nnmi_cpu_start(NULL);\r\n}\r\nstatic int nmi_multiplex_on(void)\r\n{\r\nreturn counter_config[model->num_counters].count ? 0 : -EINVAL;\r\n}\r\nstatic int nmi_switch_event(void)\r\n{\r\nif (!has_mux())\r\nreturn -ENOSYS;\r\nif (nmi_multiplex_on() < 0)\r\nreturn -EINVAL;\r\nget_online_cpus();\r\nif (ctr_running)\r\non_each_cpu(nmi_cpu_switch, NULL, 1);\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nstatic inline void mux_init(struct oprofile_operations *ops)\r\n{\r\nif (has_mux())\r\nops->switch_events = nmi_switch_event;\r\n}\r\nstatic void mux_clone(int cpu)\r\n{\r\nif (!has_mux())\r\nreturn;\r\nmemcpy(per_cpu(cpu_msrs, cpu).multiplex,\r\nper_cpu(cpu_msrs, 0).multiplex,\r\nsizeof(struct op_msr) * model->num_virt_counters);\r\n}\r\ninline int op_x86_phys_to_virt(int phys) { return phys; }\r\ninline int op_x86_virt_to_phys(int virt) { return virt; }\r\nstatic inline void nmi_shutdown_mux(void) { }\r\nstatic inline int nmi_setup_mux(void) { return 1; }\r\nstatic inline void\r\nnmi_cpu_setup_mux(int cpu, struct op_msrs const * const msrs) { }\r\nstatic inline void mux_init(struct oprofile_operations *ops) { }\r\nstatic void mux_clone(int cpu) { }\r\nstatic void free_msrs(void)\r\n{\r\nint i;\r\nfor_each_possible_cpu(i) {\r\nkfree(per_cpu(cpu_msrs, i).counters);\r\nper_cpu(cpu_msrs, i).counters = NULL;\r\nkfree(per_cpu(cpu_msrs, i).controls);\r\nper_cpu(cpu_msrs, i).controls = NULL;\r\n}\r\nnmi_shutdown_mux();\r\n}\r\nstatic int allocate_msrs(void)\r\n{\r\nsize_t controls_size = sizeof(struct op_msr) * model->num_controls;\r\nsize_t counters_size = sizeof(struct op_msr) * model->num_counters;\r\nint i;\r\nfor_each_possible_cpu(i) {\r\nper_cpu(cpu_msrs, i).counters = kzalloc(counters_size,\r\nGFP_KERNEL);\r\nif (!per_cpu(cpu_msrs, i).counters)\r\ngoto fail;\r\nper_cpu(cpu_msrs, i).controls = kzalloc(controls_size,\r\nGFP_KERNEL);\r\nif (!per_cpu(cpu_msrs, i).controls)\r\ngoto fail;\r\n}\r\nif (!nmi_setup_mux())\r\ngoto fail;\r\nreturn 1;\r\nfail:\r\nfree_msrs();\r\nreturn 0;\r\n}\r\nstatic void nmi_cpu_setup(void *dummy)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct op_msrs *msrs = &per_cpu(cpu_msrs, cpu);\r\nnmi_cpu_save_registers(msrs);\r\nraw_spin_lock(&oprofilefs_lock);\r\nmodel->setup_ctrs(model, msrs);\r\nnmi_cpu_setup_mux(cpu, msrs);\r\nraw_spin_unlock(&oprofilefs_lock);\r\nper_cpu(saved_lvtpc, cpu) = apic_read(APIC_LVTPC);\r\napic_write(APIC_LVTPC, APIC_DM_NMI);\r\n}\r\nstatic void nmi_cpu_restore_registers(struct op_msrs *msrs)\r\n{\r\nstruct op_msr *counters = msrs->counters;\r\nstruct op_msr *controls = msrs->controls;\r\nunsigned int i;\r\nfor (i = 0; i < model->num_controls; ++i) {\r\nif (controls[i].addr)\r\nwrmsrl(controls[i].addr, controls[i].saved);\r\n}\r\nfor (i = 0; i < model->num_counters; ++i) {\r\nif (counters[i].addr)\r\nwrmsrl(counters[i].addr, counters[i].saved);\r\n}\r\n}\r\nstatic void nmi_cpu_shutdown(void *dummy)\r\n{\r\nunsigned int v;\r\nint cpu = smp_processor_id();\r\nstruct op_msrs *msrs = &per_cpu(cpu_msrs, cpu);\r\nv = apic_read(APIC_LVTERR);\r\napic_write(APIC_LVTERR, v | APIC_LVT_MASKED);\r\napic_write(APIC_LVTPC, per_cpu(saved_lvtpc, cpu));\r\napic_write(APIC_LVTERR, v);\r\nnmi_cpu_restore_registers(msrs);\r\n}\r\nstatic void nmi_cpu_up(void *dummy)\r\n{\r\nif (nmi_enabled)\r\nnmi_cpu_setup(dummy);\r\nif (ctr_running)\r\nnmi_cpu_start(dummy);\r\n}\r\nstatic void nmi_cpu_down(void *dummy)\r\n{\r\nif (ctr_running)\r\nnmi_cpu_stop(dummy);\r\nif (nmi_enabled)\r\nnmi_cpu_shutdown(dummy);\r\n}\r\nstatic int nmi_create_files(struct dentry *root)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < model->num_virt_counters; ++i) {\r\nstruct dentry *dir;\r\nchar buf[4];\r\nif (!avail_to_resrv_perfctr_nmi_bit(op_x86_virt_to_phys(i)))\r\ncontinue;\r\nsnprintf(buf, sizeof(buf), "%d", i);\r\ndir = oprofilefs_mkdir(root, buf);\r\noprofilefs_create_ulong(dir, "enabled", &counter_config[i].enabled);\r\noprofilefs_create_ulong(dir, "event", &counter_config[i].event);\r\noprofilefs_create_ulong(dir, "count", &counter_config[i].count);\r\noprofilefs_create_ulong(dir, "unit_mask", &counter_config[i].unit_mask);\r\noprofilefs_create_ulong(dir, "kernel", &counter_config[i].kernel);\r\noprofilefs_create_ulong(dir, "user", &counter_config[i].user);\r\noprofilefs_create_ulong(dir, "extra", &counter_config[i].extra);\r\n}\r\nreturn 0;\r\n}\r\nstatic int oprofile_cpu_notifier(struct notifier_block *b, unsigned long action,\r\nvoid *data)\r\n{\r\nint cpu = (unsigned long)data;\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_DOWN_FAILED:\r\ncase CPU_ONLINE:\r\nsmp_call_function_single(cpu, nmi_cpu_up, NULL, 0);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\nsmp_call_function_single(cpu, nmi_cpu_down, NULL, 1);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int nmi_setup(void)\r\n{\r\nint err = 0;\r\nint cpu;\r\nif (!allocate_msrs())\r\nreturn -ENOMEM;\r\nerr = model->fill_in_addresses(&per_cpu(cpu_msrs, 0));\r\nif (err)\r\ngoto fail;\r\nfor_each_possible_cpu(cpu) {\r\nif (!cpu)\r\ncontinue;\r\nmemcpy(per_cpu(cpu_msrs, cpu).counters,\r\nper_cpu(cpu_msrs, 0).counters,\r\nsizeof(struct op_msr) * model->num_counters);\r\nmemcpy(per_cpu(cpu_msrs, cpu).controls,\r\nper_cpu(cpu_msrs, 0).controls,\r\nsizeof(struct op_msr) * model->num_controls);\r\nmux_clone(cpu);\r\n}\r\nnmi_enabled = 0;\r\nctr_running = 0;\r\nsmp_mb();\r\nerr = register_nmi_handler(NMI_LOCAL, profile_exceptions_notify,\r\n0, "oprofile");\r\nif (err)\r\ngoto fail;\r\ncpu_notifier_register_begin();\r\nget_online_cpus();\r\nnmi_enabled = 1;\r\nsmp_mb();\r\non_each_cpu(nmi_cpu_setup, NULL, 1);\r\n__register_cpu_notifier(&oprofile_cpu_nb);\r\nput_online_cpus();\r\ncpu_notifier_register_done();\r\nreturn 0;\r\nfail:\r\nfree_msrs();\r\nreturn err;\r\n}\r\nstatic void nmi_shutdown(void)\r\n{\r\nstruct op_msrs *msrs;\r\ncpu_notifier_register_begin();\r\nget_online_cpus();\r\non_each_cpu(nmi_cpu_shutdown, NULL, 1);\r\nnmi_enabled = 0;\r\nctr_running = 0;\r\n__unregister_cpu_notifier(&oprofile_cpu_nb);\r\nput_online_cpus();\r\ncpu_notifier_register_done();\r\nsmp_mb();\r\nunregister_nmi_handler(NMI_LOCAL, "oprofile");\r\nmsrs = &get_cpu_var(cpu_msrs);\r\nmodel->shutdown(msrs);\r\nfree_msrs();\r\nput_cpu_var(cpu_msrs);\r\n}\r\nstatic int nmi_suspend(void)\r\n{\r\nif (nmi_enabled == 1)\r\nnmi_cpu_stop(NULL);\r\nreturn 0;\r\n}\r\nstatic void nmi_resume(void)\r\n{\r\nif (nmi_enabled == 1)\r\nnmi_cpu_start(NULL);\r\n}\r\nstatic void __init init_suspend_resume(void)\r\n{\r\nregister_syscore_ops(&oprofile_syscore_ops);\r\n}\r\nstatic void exit_suspend_resume(void)\r\n{\r\nunregister_syscore_ops(&oprofile_syscore_ops);\r\n}\r\nstatic inline void init_suspend_resume(void) { }\r\nstatic inline void exit_suspend_resume(void) { }\r\nstatic int __init p4_init(char **cpu_type)\r\n{\r\n__u8 cpu_model = boot_cpu_data.x86_model;\r\nif (cpu_model > 6 || cpu_model == 5)\r\nreturn 0;\r\n#ifndef CONFIG_SMP\r\n*cpu_type = "i386/p4";\r\nmodel = &op_p4_spec;\r\nreturn 1;\r\n#else\r\nswitch (smp_num_siblings) {\r\ncase 1:\r\n*cpu_type = "i386/p4";\r\nmodel = &op_p4_spec;\r\nreturn 1;\r\ncase 2:\r\n*cpu_type = "i386/p4-ht";\r\nmodel = &op_p4_ht2_spec;\r\nreturn 1;\r\n}\r\n#endif\r\nprintk(KERN_INFO "oprofile: P4 HyperThreading detected with > 2 threads\n");\r\nprintk(KERN_INFO "oprofile: Reverting to timer mode.\n");\r\nreturn 0;\r\n}\r\nstatic int set_cpu_type(const char *str, struct kernel_param *kp)\r\n{\r\nif (!strcmp(str, "timer")) {\r\nforce_cpu_type = timer;\r\nprintk(KERN_INFO "oprofile: forcing NMI timer mode\n");\r\n} else if (!strcmp(str, "arch_perfmon")) {\r\nforce_cpu_type = arch_perfmon;\r\nprintk(KERN_INFO "oprofile: forcing architectural perfmon\n");\r\n} else {\r\nforce_cpu_type = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ppro_init(char **cpu_type)\r\n{\r\n__u8 cpu_model = boot_cpu_data.x86_model;\r\nstruct op_x86_model_spec *spec = &op_ppro_spec;\r\nif (force_cpu_type == arch_perfmon && boot_cpu_has(X86_FEATURE_ARCH_PERFMON))\r\nreturn 0;\r\nswitch (cpu_model) {\r\ncase 0 ... 2:\r\n*cpu_type = "i386/ppro";\r\nbreak;\r\ncase 3 ... 5:\r\n*cpu_type = "i386/pii";\r\nbreak;\r\ncase 6 ... 8:\r\ncase 10 ... 11:\r\n*cpu_type = "i386/piii";\r\nbreak;\r\ncase 9:\r\ncase 13:\r\n*cpu_type = "i386/p6_mobile";\r\nbreak;\r\ncase 14:\r\n*cpu_type = "i386/core";\r\nbreak;\r\ncase 0x0f:\r\ncase 0x16:\r\ncase 0x17:\r\ncase 0x1d:\r\n*cpu_type = "i386/core_2";\r\nbreak;\r\ncase 0x1a:\r\ncase 0x1e:\r\ncase 0x2e:\r\nspec = &op_arch_perfmon_spec;\r\n*cpu_type = "i386/core_i7";\r\nbreak;\r\ncase 0x1c:\r\n*cpu_type = "i386/atom";\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nmodel = spec;\r\nreturn 1;\r\n}\r\nint __init op_nmi_init(struct oprofile_operations *ops)\r\n{\r\n__u8 vendor = boot_cpu_data.x86_vendor;\r\n__u8 family = boot_cpu_data.x86;\r\nchar *cpu_type = NULL;\r\nint ret = 0;\r\nif (!boot_cpu_has(X86_FEATURE_APIC))\r\nreturn -ENODEV;\r\nif (force_cpu_type == timer)\r\nreturn -ENODEV;\r\nswitch (vendor) {\r\ncase X86_VENDOR_AMD:\r\nswitch (family) {\r\ncase 6:\r\ncpu_type = "i386/athlon";\r\nbreak;\r\ncase 0xf:\r\ncpu_type = "x86-64/hammer";\r\nbreak;\r\ncase 0x10:\r\ncpu_type = "x86-64/family10";\r\nbreak;\r\ncase 0x11:\r\ncpu_type = "x86-64/family11h";\r\nbreak;\r\ncase 0x12:\r\ncpu_type = "x86-64/family12h";\r\nbreak;\r\ncase 0x14:\r\ncpu_type = "x86-64/family14h";\r\nbreak;\r\ncase 0x15:\r\ncpu_type = "x86-64/family15h";\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nmodel = &op_amd_spec;\r\nbreak;\r\ncase X86_VENDOR_INTEL:\r\nswitch (family) {\r\ncase 0xf:\r\np4_init(&cpu_type);\r\nbreak;\r\ncase 6:\r\nppro_init(&cpu_type);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (cpu_type)\r\nbreak;\r\nif (!boot_cpu_has(X86_FEATURE_ARCH_PERFMON))\r\nreturn -ENODEV;\r\ncpu_type = "i386/arch_perfmon";\r\nmodel = &op_arch_perfmon_spec;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nops->create_files = nmi_create_files;\r\nops->setup = nmi_setup;\r\nops->shutdown = nmi_shutdown;\r\nops->start = nmi_start;\r\nops->stop = nmi_stop;\r\nops->cpu_type = cpu_type;\r\nif (model->init)\r\nret = model->init(ops);\r\nif (ret)\r\nreturn ret;\r\nif (!model->num_virt_counters)\r\nmodel->num_virt_counters = model->num_counters;\r\nmux_init(ops);\r\ninit_suspend_resume();\r\nprintk(KERN_INFO "oprofile: using NMI interrupt.\n");\r\nreturn 0;\r\n}\r\nvoid op_nmi_exit(void)\r\n{\r\nexit_suspend_resume();\r\n}
