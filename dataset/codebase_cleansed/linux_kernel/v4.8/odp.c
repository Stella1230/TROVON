void mlx5_ib_invalidate_range(struct ib_umem *umem, unsigned long start,\r\nunsigned long end)\r\n{\r\nstruct mlx5_ib_mr *mr;\r\nconst u64 umr_block_mask = (MLX5_UMR_MTT_ALIGNMENT / sizeof(u64)) - 1;\r\nu64 idx = 0, blk_start_idx = 0;\r\nint in_block = 0;\r\nu64 addr;\r\nif (!umem || !umem->odp_data) {\r\npr_err("invalidation called on NULL umem or non-ODP umem\n");\r\nreturn;\r\n}\r\nmr = umem->odp_data->private;\r\nif (!mr || !mr->ibmr.pd)\r\nreturn;\r\nstart = max_t(u64, ib_umem_start(umem), start);\r\nend = min_t(u64, ib_umem_end(umem), end);\r\nfor (addr = start; addr < end; addr += (u64)umem->page_size) {\r\nidx = (addr - ib_umem_start(umem)) / PAGE_SIZE;\r\nif (umem->odp_data->dma_list[idx] &\r\n(ODP_READ_ALLOWED_BIT | ODP_WRITE_ALLOWED_BIT)) {\r\nif (!in_block) {\r\nblk_start_idx = idx;\r\nin_block = 1;\r\n}\r\n} else {\r\nu64 umr_offset = idx & umr_block_mask;\r\nif (in_block && umr_offset == 0) {\r\nmlx5_ib_update_mtt(mr, blk_start_idx,\r\nidx - blk_start_idx, 1);\r\nin_block = 0;\r\n}\r\n}\r\n}\r\nif (in_block)\r\nmlx5_ib_update_mtt(mr, blk_start_idx, idx - blk_start_idx + 1,\r\n1);\r\nib_umem_odp_unmap_dma_pages(umem, start, end);\r\n}\r\nvoid mlx5_ib_internal_fill_odp_caps(struct mlx5_ib_dev *dev)\r\n{\r\nstruct ib_odp_caps *caps = &dev->odp_caps;\r\nmemset(caps, 0, sizeof(*caps));\r\nif (!MLX5_CAP_GEN(dev->mdev, pg))\r\nreturn;\r\ncaps->general_caps = IB_ODP_SUPPORT;\r\nif (MLX5_CAP_ODP(dev->mdev, ud_odp_caps.send))\r\ncaps->per_transport_caps.ud_odp_caps |= IB_ODP_SUPPORT_SEND;\r\nif (MLX5_CAP_ODP(dev->mdev, rc_odp_caps.send))\r\ncaps->per_transport_caps.rc_odp_caps |= IB_ODP_SUPPORT_SEND;\r\nif (MLX5_CAP_ODP(dev->mdev, rc_odp_caps.receive))\r\ncaps->per_transport_caps.rc_odp_caps |= IB_ODP_SUPPORT_RECV;\r\nif (MLX5_CAP_ODP(dev->mdev, rc_odp_caps.write))\r\ncaps->per_transport_caps.rc_odp_caps |= IB_ODP_SUPPORT_WRITE;\r\nif (MLX5_CAP_ODP(dev->mdev, rc_odp_caps.read))\r\ncaps->per_transport_caps.rc_odp_caps |= IB_ODP_SUPPORT_READ;\r\nreturn;\r\n}\r\nstatic struct mlx5_ib_mr *mlx5_ib_odp_find_mr_lkey(struct mlx5_ib_dev *dev,\r\nu32 key)\r\n{\r\nu32 base_key = mlx5_base_mkey(key);\r\nstruct mlx5_core_mkey *mmkey = __mlx5_mr_lookup(dev->mdev, base_key);\r\nstruct mlx5_ib_mr *mr = container_of(mmkey, struct mlx5_ib_mr, mmkey);\r\nif (!mmkey || mmkey->key != key || !mr->live)\r\nreturn NULL;\r\nreturn container_of(mmkey, struct mlx5_ib_mr, mmkey);\r\n}\r\nstatic void mlx5_ib_page_fault_resume(struct mlx5_ib_qp *qp,\r\nstruct mlx5_ib_pfault *pfault,\r\nint error)\r\n{\r\nstruct mlx5_ib_dev *dev = to_mdev(qp->ibqp.pd->device);\r\nu32 qpn = qp->trans_qp.base.mqp.qpn;\r\nint ret = mlx5_core_page_fault_resume(dev->mdev,\r\nqpn,\r\npfault->mpfault.flags,\r\nerror);\r\nif (ret)\r\npr_err("Failed to resolve the page fault on QP 0x%x\n", qpn);\r\n}\r\nstatic int pagefault_single_data_segment(struct mlx5_ib_qp *qp,\r\nstruct mlx5_ib_pfault *pfault,\r\nu32 key, u64 io_virt, size_t bcnt,\r\nu32 *bytes_mapped)\r\n{\r\nstruct mlx5_ib_dev *mib_dev = to_mdev(qp->ibqp.pd->device);\r\nint srcu_key;\r\nunsigned int current_seq;\r\nu64 start_idx;\r\nint npages = 0, ret = 0;\r\nstruct mlx5_ib_mr *mr;\r\nu64 access_mask = ODP_READ_ALLOWED_BIT;\r\nsrcu_key = srcu_read_lock(&mib_dev->mr_srcu);\r\nmr = mlx5_ib_odp_find_mr_lkey(mib_dev, key);\r\nif (!mr || !mr->ibmr.pd) {\r\npr_err("Failed to find relevant mr for lkey=0x%06x, probably the MR was destroyed\n",\r\nkey);\r\nret = -EFAULT;\r\ngoto srcu_unlock;\r\n}\r\nif (!mr->umem->odp_data) {\r\npr_debug("skipping non ODP MR (lkey=0x%06x) in page fault handler.\n",\r\nkey);\r\nif (bytes_mapped)\r\n*bytes_mapped +=\r\n(bcnt - pfault->mpfault.bytes_committed);\r\ngoto srcu_unlock;\r\n}\r\nif (mr->ibmr.pd != qp->ibqp.pd) {\r\npr_err("Page-fault with different PDs for QP and MR.\n");\r\nret = -EFAULT;\r\ngoto srcu_unlock;\r\n}\r\ncurrent_seq = ACCESS_ONCE(mr->umem->odp_data->notifiers_seq);\r\nsmp_rmb();\r\nio_virt += pfault->mpfault.bytes_committed;\r\nbcnt -= pfault->mpfault.bytes_committed;\r\nstart_idx = (io_virt - (mr->mmkey.iova & PAGE_MASK)) >> PAGE_SHIFT;\r\nif (mr->umem->writable)\r\naccess_mask |= ODP_WRITE_ALLOWED_BIT;\r\nnpages = ib_umem_odp_map_dma_pages(mr->umem, io_virt, bcnt,\r\naccess_mask, current_seq);\r\nif (npages < 0) {\r\nret = npages;\r\ngoto srcu_unlock;\r\n}\r\nif (npages > 0) {\r\nmutex_lock(&mr->umem->odp_data->umem_mutex);\r\nif (!ib_umem_mmu_notifier_retry(mr->umem, current_seq)) {\r\nret = mlx5_ib_update_mtt(mr, start_idx, npages, 0);\r\n} else {\r\nret = -EAGAIN;\r\n}\r\nmutex_unlock(&mr->umem->odp_data->umem_mutex);\r\nif (ret < 0) {\r\nif (ret != -EAGAIN)\r\npr_err("Failed to update mkey page tables\n");\r\ngoto srcu_unlock;\r\n}\r\nif (bytes_mapped) {\r\nu32 new_mappings = npages * PAGE_SIZE -\r\n(io_virt - round_down(io_virt, PAGE_SIZE));\r\n*bytes_mapped += min_t(u32, new_mappings, bcnt);\r\n}\r\n}\r\nsrcu_unlock:\r\nif (ret == -EAGAIN) {\r\nif (!mr->umem->odp_data->dying) {\r\nstruct ib_umem_odp *odp_data = mr->umem->odp_data;\r\nunsigned long timeout =\r\nmsecs_to_jiffies(MMU_NOTIFIER_TIMEOUT);\r\nif (!wait_for_completion_timeout(\r\n&odp_data->notifier_completion,\r\ntimeout)) {\r\npr_warn("timeout waiting for mmu notifier completion\n");\r\n}\r\n} else {\r\nret = -EFAULT;\r\n}\r\n}\r\nsrcu_read_unlock(&mib_dev->mr_srcu, srcu_key);\r\npfault->mpfault.bytes_committed = 0;\r\nreturn ret ? ret : npages;\r\n}\r\nstatic int pagefault_data_segments(struct mlx5_ib_qp *qp,\r\nstruct mlx5_ib_pfault *pfault, void *wqe,\r\nvoid *wqe_end, u32 *bytes_mapped,\r\nu32 *total_wqe_bytes, int receive_queue)\r\n{\r\nint ret = 0, npages = 0;\r\nu64 io_virt;\r\nu32 key;\r\nu32 byte_count;\r\nsize_t bcnt;\r\nint inline_segment;\r\nif (receive_queue && qp->ibqp.srq)\r\nwqe += sizeof(struct mlx5_wqe_srq_next_seg);\r\nif (bytes_mapped)\r\n*bytes_mapped = 0;\r\nif (total_wqe_bytes)\r\n*total_wqe_bytes = 0;\r\nwhile (wqe < wqe_end) {\r\nstruct mlx5_wqe_data_seg *dseg = wqe;\r\nio_virt = be64_to_cpu(dseg->addr);\r\nkey = be32_to_cpu(dseg->lkey);\r\nbyte_count = be32_to_cpu(dseg->byte_count);\r\ninline_segment = !!(byte_count & MLX5_INLINE_SEG);\r\nbcnt = byte_count & ~MLX5_INLINE_SEG;\r\nif (inline_segment) {\r\nbcnt = bcnt & MLX5_WQE_INLINE_SEG_BYTE_COUNT_MASK;\r\nwqe += ALIGN(sizeof(struct mlx5_wqe_inline_seg) + bcnt,\r\n16);\r\n} else {\r\nwqe += sizeof(*dseg);\r\n}\r\nif (receive_queue && bcnt == 0 && key == MLX5_INVALID_LKEY &&\r\nio_virt == 0)\r\nbreak;\r\nif (!inline_segment && total_wqe_bytes) {\r\n*total_wqe_bytes += bcnt - min_t(size_t, bcnt,\r\npfault->mpfault.bytes_committed);\r\n}\r\nif (bcnt == 0)\r\nbcnt = 1U << 31;\r\nif (inline_segment || bcnt <= pfault->mpfault.bytes_committed) {\r\npfault->mpfault.bytes_committed -=\r\nmin_t(size_t, bcnt,\r\npfault->mpfault.bytes_committed);\r\ncontinue;\r\n}\r\nret = pagefault_single_data_segment(qp, pfault, key, io_virt,\r\nbcnt, bytes_mapped);\r\nif (ret < 0)\r\nbreak;\r\nnpages += ret;\r\n}\r\nreturn ret < 0 ? ret : npages;\r\n}\r\nstatic int mlx5_ib_mr_initiator_pfault_handler(\r\nstruct mlx5_ib_qp *qp, struct mlx5_ib_pfault *pfault,\r\nvoid **wqe, void **wqe_end, int wqe_length)\r\n{\r\nstruct mlx5_ib_dev *dev = to_mdev(qp->ibqp.pd->device);\r\nstruct mlx5_wqe_ctrl_seg *ctrl = *wqe;\r\nu16 wqe_index = pfault->mpfault.wqe.wqe_index;\r\nunsigned ds, opcode;\r\n#if defined(DEBUG)\r\nu32 ctrl_wqe_index, ctrl_qpn;\r\n#endif\r\nu32 qpn = qp->trans_qp.base.mqp.qpn;\r\nds = be32_to_cpu(ctrl->qpn_ds) & MLX5_WQE_CTRL_DS_MASK;\r\nif (ds * MLX5_WQE_DS_UNITS > wqe_length) {\r\nmlx5_ib_err(dev, "Unable to read the complete WQE. ds = 0x%x, ret = 0x%x\n",\r\nds, wqe_length);\r\nreturn -EFAULT;\r\n}\r\nif (ds == 0) {\r\nmlx5_ib_err(dev, "Got WQE with zero DS. wqe_index=%x, qpn=%x\n",\r\nwqe_index, qpn);\r\nreturn -EFAULT;\r\n}\r\n#if defined(DEBUG)\r\nctrl_wqe_index = (be32_to_cpu(ctrl->opmod_idx_opcode) &\r\nMLX5_WQE_CTRL_WQE_INDEX_MASK) >>\r\nMLX5_WQE_CTRL_WQE_INDEX_SHIFT;\r\nif (wqe_index != ctrl_wqe_index) {\r\nmlx5_ib_err(dev, "Got WQE with invalid wqe_index. wqe_index=0x%x, qpn=0x%x ctrl->wqe_index=0x%x\n",\r\nwqe_index, qpn,\r\nctrl_wqe_index);\r\nreturn -EFAULT;\r\n}\r\nctrl_qpn = (be32_to_cpu(ctrl->qpn_ds) & MLX5_WQE_CTRL_QPN_MASK) >>\r\nMLX5_WQE_CTRL_QPN_SHIFT;\r\nif (qpn != ctrl_qpn) {\r\nmlx5_ib_err(dev, "Got WQE with incorrect QP number. wqe_index=0x%x, qpn=0x%x ctrl->qpn=0x%x\n",\r\nwqe_index, qpn,\r\nctrl_qpn);\r\nreturn -EFAULT;\r\n}\r\n#endif\r\n*wqe_end = *wqe + ds * MLX5_WQE_DS_UNITS;\r\n*wqe += sizeof(*ctrl);\r\nopcode = be32_to_cpu(ctrl->opmod_idx_opcode) &\r\nMLX5_WQE_CTRL_OPCODE_MASK;\r\nswitch (qp->ibqp.qp_type) {\r\ncase IB_QPT_RC:\r\nswitch (opcode) {\r\ncase MLX5_OPCODE_SEND:\r\ncase MLX5_OPCODE_SEND_IMM:\r\ncase MLX5_OPCODE_SEND_INVAL:\r\nif (!(dev->odp_caps.per_transport_caps.rc_odp_caps &\r\nIB_ODP_SUPPORT_SEND))\r\ngoto invalid_transport_or_opcode;\r\nbreak;\r\ncase MLX5_OPCODE_RDMA_WRITE:\r\ncase MLX5_OPCODE_RDMA_WRITE_IMM:\r\nif (!(dev->odp_caps.per_transport_caps.rc_odp_caps &\r\nIB_ODP_SUPPORT_WRITE))\r\ngoto invalid_transport_or_opcode;\r\n*wqe += sizeof(struct mlx5_wqe_raddr_seg);\r\nbreak;\r\ncase MLX5_OPCODE_RDMA_READ:\r\nif (!(dev->odp_caps.per_transport_caps.rc_odp_caps &\r\nIB_ODP_SUPPORT_READ))\r\ngoto invalid_transport_or_opcode;\r\n*wqe += sizeof(struct mlx5_wqe_raddr_seg);\r\nbreak;\r\ndefault:\r\ngoto invalid_transport_or_opcode;\r\n}\r\nbreak;\r\ncase IB_QPT_UD:\r\nswitch (opcode) {\r\ncase MLX5_OPCODE_SEND:\r\ncase MLX5_OPCODE_SEND_IMM:\r\nif (!(dev->odp_caps.per_transport_caps.ud_odp_caps &\r\nIB_ODP_SUPPORT_SEND))\r\ngoto invalid_transport_or_opcode;\r\n*wqe += sizeof(struct mlx5_wqe_datagram_seg);\r\nbreak;\r\ndefault:\r\ngoto invalid_transport_or_opcode;\r\n}\r\nbreak;\r\ndefault:\r\ninvalid_transport_or_opcode:\r\nmlx5_ib_err(dev, "ODP fault on QP of an unsupported opcode or transport. transport: 0x%x opcode: 0x%x.\n",\r\nqp->ibqp.qp_type, opcode);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx5_ib_mr_responder_pfault_handler(\r\nstruct mlx5_ib_qp *qp, struct mlx5_ib_pfault *pfault,\r\nvoid **wqe, void **wqe_end, int wqe_length)\r\n{\r\nstruct mlx5_ib_dev *dev = to_mdev(qp->ibqp.pd->device);\r\nstruct mlx5_ib_wq *wq = &qp->rq;\r\nint wqe_size = 1 << wq->wqe_shift;\r\nif (qp->ibqp.srq) {\r\nmlx5_ib_err(dev, "ODP fault on SRQ is not supported\n");\r\nreturn -EFAULT;\r\n}\r\nif (qp->wq_sig) {\r\nmlx5_ib_err(dev, "ODP fault with WQE signatures is not supported\n");\r\nreturn -EFAULT;\r\n}\r\nif (wqe_size > wqe_length) {\r\nmlx5_ib_err(dev, "Couldn't read all of the receive WQE's content\n");\r\nreturn -EFAULT;\r\n}\r\nswitch (qp->ibqp.qp_type) {\r\ncase IB_QPT_RC:\r\nif (!(dev->odp_caps.per_transport_caps.rc_odp_caps &\r\nIB_ODP_SUPPORT_RECV))\r\ngoto invalid_transport_or_opcode;\r\nbreak;\r\ndefault:\r\ninvalid_transport_or_opcode:\r\nmlx5_ib_err(dev, "ODP fault on QP of an unsupported transport. transport: 0x%x\n",\r\nqp->ibqp.qp_type);\r\nreturn -EFAULT;\r\n}\r\n*wqe_end = *wqe + wqe_size;\r\nreturn 0;\r\n}\r\nstatic void mlx5_ib_mr_wqe_pfault_handler(struct mlx5_ib_qp *qp,\r\nstruct mlx5_ib_pfault *pfault)\r\n{\r\nstruct mlx5_ib_dev *dev = to_mdev(qp->ibqp.pd->device);\r\nint ret;\r\nvoid *wqe, *wqe_end;\r\nu32 bytes_mapped, total_wqe_bytes;\r\nchar *buffer = NULL;\r\nint resume_with_error = 0;\r\nu16 wqe_index = pfault->mpfault.wqe.wqe_index;\r\nint requestor = pfault->mpfault.flags & MLX5_PFAULT_REQUESTOR;\r\nu32 qpn = qp->trans_qp.base.mqp.qpn;\r\nbuffer = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buffer) {\r\nmlx5_ib_err(dev, "Error allocating memory for IO page fault handling.\n");\r\nresume_with_error = 1;\r\ngoto resolve_page_fault;\r\n}\r\nret = mlx5_ib_read_user_wqe(qp, requestor, wqe_index, buffer,\r\nPAGE_SIZE, &qp->trans_qp.base);\r\nif (ret < 0) {\r\nmlx5_ib_err(dev, "Failed reading a WQE following page fault, error=%x, wqe_index=%x, qpn=%x\n",\r\n-ret, wqe_index, qpn);\r\nresume_with_error = 1;\r\ngoto resolve_page_fault;\r\n}\r\nwqe = buffer;\r\nif (requestor)\r\nret = mlx5_ib_mr_initiator_pfault_handler(qp, pfault, &wqe,\r\n&wqe_end, ret);\r\nelse\r\nret = mlx5_ib_mr_responder_pfault_handler(qp, pfault, &wqe,\r\n&wqe_end, ret);\r\nif (ret < 0) {\r\nresume_with_error = 1;\r\ngoto resolve_page_fault;\r\n}\r\nif (wqe >= wqe_end) {\r\nmlx5_ib_err(dev, "ODP fault on invalid WQE.\n");\r\nresume_with_error = 1;\r\ngoto resolve_page_fault;\r\n}\r\nret = pagefault_data_segments(qp, pfault, wqe, wqe_end, &bytes_mapped,\r\n&total_wqe_bytes, !requestor);\r\nif (ret == -EAGAIN) {\r\ngoto resolve_page_fault;\r\n} else if (ret < 0 || total_wqe_bytes > bytes_mapped) {\r\nmlx5_ib_err(dev, "Error getting user pages for page fault. Error: 0x%x\n",\r\n-ret);\r\nresume_with_error = 1;\r\ngoto resolve_page_fault;\r\n}\r\nresolve_page_fault:\r\nmlx5_ib_page_fault_resume(qp, pfault, resume_with_error);\r\nmlx5_ib_dbg(dev, "PAGE FAULT completed. QP 0x%x resume_with_error=%d, flags: 0x%x\n",\r\nqpn, resume_with_error,\r\npfault->mpfault.flags);\r\nfree_page((unsigned long)buffer);\r\n}\r\nstatic int pages_in_range(u64 address, u32 length)\r\n{\r\nreturn (ALIGN(address + length, PAGE_SIZE) -\r\n(address & PAGE_MASK)) >> PAGE_SHIFT;\r\n}\r\nstatic void mlx5_ib_mr_rdma_pfault_handler(struct mlx5_ib_qp *qp,\r\nstruct mlx5_ib_pfault *pfault)\r\n{\r\nstruct mlx5_pagefault *mpfault = &pfault->mpfault;\r\nu64 address;\r\nu32 length;\r\nu32 prefetch_len = mpfault->bytes_committed;\r\nint prefetch_activated = 0;\r\nu32 rkey = mpfault->rdma.r_key;\r\nint ret;\r\nstruct mlx5_ib_pfault dummy_pfault = {};\r\ndummy_pfault.mpfault.bytes_committed = 0;\r\nmpfault->rdma.rdma_va += mpfault->bytes_committed;\r\nmpfault->rdma.rdma_op_len -= min(mpfault->bytes_committed,\r\nmpfault->rdma.rdma_op_len);\r\nmpfault->bytes_committed = 0;\r\naddress = mpfault->rdma.rdma_va;\r\nlength = mpfault->rdma.rdma_op_len;\r\nif (length == 0) {\r\nprefetch_activated = 1;\r\nlength = mpfault->rdma.packet_size;\r\nprefetch_len = min(MAX_PREFETCH_LEN, prefetch_len);\r\n}\r\nret = pagefault_single_data_segment(qp, pfault, rkey, address, length,\r\nNULL);\r\nif (ret == -EAGAIN) {\r\nprefetch_activated = 0;\r\n} else if (ret < 0 || pages_in_range(address, length) > ret) {\r\nmlx5_ib_page_fault_resume(qp, pfault, 1);\r\nreturn;\r\n}\r\nmlx5_ib_page_fault_resume(qp, pfault, 0);\r\nif (prefetch_activated) {\r\nret = pagefault_single_data_segment(qp, &dummy_pfault, rkey,\r\naddress,\r\nprefetch_len,\r\nNULL);\r\nif (ret < 0) {\r\npr_warn("Prefetch failed (ret = %d, prefetch_activated = %d) for QPN %d, address: 0x%.16llx, length = 0x%.16x\n",\r\nret, prefetch_activated,\r\nqp->ibqp.qp_num, address, prefetch_len);\r\n}\r\n}\r\n}\r\nvoid mlx5_ib_mr_pfault_handler(struct mlx5_ib_qp *qp,\r\nstruct mlx5_ib_pfault *pfault)\r\n{\r\nu8 event_subtype = pfault->mpfault.event_subtype;\r\nswitch (event_subtype) {\r\ncase MLX5_PFAULT_SUBTYPE_WQE:\r\nmlx5_ib_mr_wqe_pfault_handler(qp, pfault);\r\nbreak;\r\ncase MLX5_PFAULT_SUBTYPE_RDMA:\r\nmlx5_ib_mr_rdma_pfault_handler(qp, pfault);\r\nbreak;\r\ndefault:\r\npr_warn("Invalid page fault event subtype: 0x%x\n",\r\nevent_subtype);\r\nmlx5_ib_page_fault_resume(qp, pfault, 1);\r\nbreak;\r\n}\r\n}\r\nstatic void mlx5_ib_qp_pfault_action(struct work_struct *work)\r\n{\r\nstruct mlx5_ib_pfault *pfault = container_of(work,\r\nstruct mlx5_ib_pfault,\r\nwork);\r\nenum mlx5_ib_pagefault_context context =\r\nmlx5_ib_get_pagefault_context(&pfault->mpfault);\r\nstruct mlx5_ib_qp *qp = container_of(pfault, struct mlx5_ib_qp,\r\npagefaults[context]);\r\nmlx5_ib_mr_pfault_handler(qp, pfault);\r\n}\r\nvoid mlx5_ib_qp_disable_pagefaults(struct mlx5_ib_qp *qp)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&qp->disable_page_faults_lock, flags);\r\nqp->disable_page_faults = 1;\r\nspin_unlock_irqrestore(&qp->disable_page_faults_lock, flags);\r\nflush_workqueue(mlx5_ib_page_fault_wq);\r\n}\r\nvoid mlx5_ib_qp_enable_pagefaults(struct mlx5_ib_qp *qp)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&qp->disable_page_faults_lock, flags);\r\nqp->disable_page_faults = 0;\r\nspin_unlock_irqrestore(&qp->disable_page_faults_lock, flags);\r\n}\r\nstatic void mlx5_ib_pfault_handler(struct mlx5_core_qp *qp,\r\nstruct mlx5_pagefault *pfault)\r\n{\r\nstruct mlx5_ib_qp *mibqp = to_mibqp(qp);\r\nenum mlx5_ib_pagefault_context context =\r\nmlx5_ib_get_pagefault_context(pfault);\r\nstruct mlx5_ib_pfault *qp_pfault = &mibqp->pagefaults[context];\r\nqp_pfault->mpfault = *pfault;\r\nspin_lock(&mibqp->disable_page_faults_lock);\r\nif (!mibqp->disable_page_faults)\r\nqueue_work(mlx5_ib_page_fault_wq, &qp_pfault->work);\r\nspin_unlock(&mibqp->disable_page_faults_lock);\r\n}\r\nvoid mlx5_ib_odp_create_qp(struct mlx5_ib_qp *qp)\r\n{\r\nint i;\r\nqp->disable_page_faults = 1;\r\nspin_lock_init(&qp->disable_page_faults_lock);\r\nqp->trans_qp.base.mqp.pfault_handler = mlx5_ib_pfault_handler;\r\nfor (i = 0; i < MLX5_IB_PAGEFAULT_CONTEXTS; ++i)\r\nINIT_WORK(&qp->pagefaults[i].work, mlx5_ib_qp_pfault_action);\r\n}\r\nint mlx5_ib_odp_init_one(struct mlx5_ib_dev *ibdev)\r\n{\r\nint ret;\r\nret = init_srcu_struct(&ibdev->mr_srcu);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid mlx5_ib_odp_remove_one(struct mlx5_ib_dev *ibdev)\r\n{\r\ncleanup_srcu_struct(&ibdev->mr_srcu);\r\n}\r\nint __init mlx5_ib_odp_init(void)\r\n{\r\nmlx5_ib_page_fault_wq =\r\ncreate_singlethread_workqueue("mlx5_ib_page_faults");\r\nif (!mlx5_ib_page_fault_wq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid mlx5_ib_odp_cleanup(void)\r\n{\r\ndestroy_workqueue(mlx5_ib_page_fault_wq);\r\n}
