static struct sdesc *init_sdesc(struct crypto_shash *alg)\r\n{\r\nstruct sdesc *sdesc;\r\nint size;\r\nsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\r\nsdesc = kmalloc(size, GFP_KERNEL);\r\nif (!sdesc)\r\nreturn ERR_PTR(-ENOMEM);\r\nsdesc->shash.tfm = alg;\r\nsdesc->shash.flags = 0x0;\r\nreturn sdesc;\r\n}\r\nstatic int TSS_sha1(const unsigned char *data, unsigned int datalen,\r\nunsigned char *digest)\r\n{\r\nstruct sdesc *sdesc;\r\nint ret;\r\nsdesc = init_sdesc(hashalg);\r\nif (IS_ERR(sdesc)) {\r\npr_info("trusted_key: can't alloc %s\n", hash_alg);\r\nreturn PTR_ERR(sdesc);\r\n}\r\nret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\r\nkfree(sdesc);\r\nreturn ret;\r\n}\r\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\r\nunsigned int keylen, ...)\r\n{\r\nstruct sdesc *sdesc;\r\nva_list argp;\r\nunsigned int dlen;\r\nunsigned char *data;\r\nint ret;\r\nsdesc = init_sdesc(hmacalg);\r\nif (IS_ERR(sdesc)) {\r\npr_info("trusted_key: can't alloc %s\n", hmac_alg);\r\nreturn PTR_ERR(sdesc);\r\n}\r\nret = crypto_shash_setkey(hmacalg, key, keylen);\r\nif (ret < 0)\r\ngoto out;\r\nret = crypto_shash_init(&sdesc->shash);\r\nif (ret < 0)\r\ngoto out;\r\nva_start(argp, keylen);\r\nfor (;;) {\r\ndlen = va_arg(argp, unsigned int);\r\nif (dlen == 0)\r\nbreak;\r\ndata = va_arg(argp, unsigned char *);\r\nif (data == NULL) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = crypto_shash_update(&sdesc->shash, data, dlen);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nva_end(argp);\r\nif (!ret)\r\nret = crypto_shash_final(&sdesc->shash, digest);\r\nout:\r\nkfree(sdesc);\r\nreturn ret;\r\n}\r\nstatic int TSS_authhmac(unsigned char *digest, const unsigned char *key,\r\nunsigned int keylen, unsigned char *h1,\r\nunsigned char *h2, unsigned char h3, ...)\r\n{\r\nunsigned char paramdigest[SHA1_DIGEST_SIZE];\r\nstruct sdesc *sdesc;\r\nunsigned int dlen;\r\nunsigned char *data;\r\nunsigned char c;\r\nint ret;\r\nva_list argp;\r\nsdesc = init_sdesc(hashalg);\r\nif (IS_ERR(sdesc)) {\r\npr_info("trusted_key: can't alloc %s\n", hash_alg);\r\nreturn PTR_ERR(sdesc);\r\n}\r\nc = h3;\r\nret = crypto_shash_init(&sdesc->shash);\r\nif (ret < 0)\r\ngoto out;\r\nva_start(argp, h3);\r\nfor (;;) {\r\ndlen = va_arg(argp, unsigned int);\r\nif (dlen == 0)\r\nbreak;\r\ndata = va_arg(argp, unsigned char *);\r\nif (!data) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = crypto_shash_update(&sdesc->shash, data, dlen);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nva_end(argp);\r\nif (!ret)\r\nret = crypto_shash_final(&sdesc->shash, paramdigest);\r\nif (!ret)\r\nret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\r\nparamdigest, TPM_NONCE_SIZE, h1,\r\nTPM_NONCE_SIZE, h2, 1, &c, 0, 0);\r\nout:\r\nkfree(sdesc);\r\nreturn ret;\r\n}\r\nstatic int TSS_checkhmac1(unsigned char *buffer,\r\nconst uint32_t command,\r\nconst unsigned char *ononce,\r\nconst unsigned char *key,\r\nunsigned int keylen, ...)\r\n{\r\nuint32_t bufsize;\r\nuint16_t tag;\r\nuint32_t ordinal;\r\nuint32_t result;\r\nunsigned char *enonce;\r\nunsigned char *continueflag;\r\nunsigned char *authdata;\r\nunsigned char testhmac[SHA1_DIGEST_SIZE];\r\nunsigned char paramdigest[SHA1_DIGEST_SIZE];\r\nstruct sdesc *sdesc;\r\nunsigned int dlen;\r\nunsigned int dpos;\r\nva_list argp;\r\nint ret;\r\nbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\r\ntag = LOAD16(buffer, 0);\r\nordinal = command;\r\nresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\r\nif (tag == TPM_TAG_RSP_COMMAND)\r\nreturn 0;\r\nif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\r\nreturn -EINVAL;\r\nauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\r\ncontinueflag = authdata - 1;\r\nenonce = continueflag - TPM_NONCE_SIZE;\r\nsdesc = init_sdesc(hashalg);\r\nif (IS_ERR(sdesc)) {\r\npr_info("trusted_key: can't alloc %s\n", hash_alg);\r\nreturn PTR_ERR(sdesc);\r\n}\r\nret = crypto_shash_init(&sdesc->shash);\r\nif (ret < 0)\r\ngoto out;\r\nret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\r\nsizeof result);\r\nif (ret < 0)\r\ngoto out;\r\nret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\r\nsizeof ordinal);\r\nif (ret < 0)\r\ngoto out;\r\nva_start(argp, keylen);\r\nfor (;;) {\r\ndlen = va_arg(argp, unsigned int);\r\nif (dlen == 0)\r\nbreak;\r\ndpos = va_arg(argp, unsigned int);\r\nret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nva_end(argp);\r\nif (!ret)\r\nret = crypto_shash_final(&sdesc->shash, paramdigest);\r\nif (ret < 0)\r\ngoto out;\r\nret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\r\nTPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\r\n1, continueflag, 0, 0);\r\nif (ret < 0)\r\ngoto out;\r\nif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\r\nret = -EINVAL;\r\nout:\r\nkfree(sdesc);\r\nreturn ret;\r\n}\r\nstatic int TSS_checkhmac2(unsigned char *buffer,\r\nconst uint32_t command,\r\nconst unsigned char *ononce,\r\nconst unsigned char *key1,\r\nunsigned int keylen1,\r\nconst unsigned char *key2,\r\nunsigned int keylen2, ...)\r\n{\r\nuint32_t bufsize;\r\nuint16_t tag;\r\nuint32_t ordinal;\r\nuint32_t result;\r\nunsigned char *enonce1;\r\nunsigned char *continueflag1;\r\nunsigned char *authdata1;\r\nunsigned char *enonce2;\r\nunsigned char *continueflag2;\r\nunsigned char *authdata2;\r\nunsigned char testhmac1[SHA1_DIGEST_SIZE];\r\nunsigned char testhmac2[SHA1_DIGEST_SIZE];\r\nunsigned char paramdigest[SHA1_DIGEST_SIZE];\r\nstruct sdesc *sdesc;\r\nunsigned int dlen;\r\nunsigned int dpos;\r\nva_list argp;\r\nint ret;\r\nbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\r\ntag = LOAD16(buffer, 0);\r\nordinal = command;\r\nresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\r\nif (tag == TPM_TAG_RSP_COMMAND)\r\nreturn 0;\r\nif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\r\nreturn -EINVAL;\r\nauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\r\n+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\r\nauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\r\ncontinueflag1 = authdata1 - 1;\r\ncontinueflag2 = authdata2 - 1;\r\nenonce1 = continueflag1 - TPM_NONCE_SIZE;\r\nenonce2 = continueflag2 - TPM_NONCE_SIZE;\r\nsdesc = init_sdesc(hashalg);\r\nif (IS_ERR(sdesc)) {\r\npr_info("trusted_key: can't alloc %s\n", hash_alg);\r\nreturn PTR_ERR(sdesc);\r\n}\r\nret = crypto_shash_init(&sdesc->shash);\r\nif (ret < 0)\r\ngoto out;\r\nret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\r\nsizeof result);\r\nif (ret < 0)\r\ngoto out;\r\nret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\r\nsizeof ordinal);\r\nif (ret < 0)\r\ngoto out;\r\nva_start(argp, keylen2);\r\nfor (;;) {\r\ndlen = va_arg(argp, unsigned int);\r\nif (dlen == 0)\r\nbreak;\r\ndpos = va_arg(argp, unsigned int);\r\nret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nva_end(argp);\r\nif (!ret)\r\nret = crypto_shash_final(&sdesc->shash, paramdigest);\r\nif (ret < 0)\r\ngoto out;\r\nret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\r\nparamdigest, TPM_NONCE_SIZE, enonce1,\r\nTPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\r\nif (ret < 0)\r\ngoto out;\r\nif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\r\nparamdigest, TPM_NONCE_SIZE, enonce2,\r\nTPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\r\nif (ret < 0)\r\ngoto out;\r\nif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\r\nret = -EINVAL;\r\nout:\r\nkfree(sdesc);\r\nreturn ret;\r\n}\r\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\r\nsize_t buflen)\r\n{\r\nint rc;\r\ndump_tpm_buf(cmd);\r\nrc = tpm_send(chip_num, cmd, buflen);\r\ndump_tpm_buf(cmd);\r\nif (rc > 0)\r\nrc = -EPERM;\r\nreturn rc;\r\n}\r\nstatic int pcrlock(const int pcrnum)\r\n{\r\nunsigned char hash[SHA1_DIGEST_SIZE];\r\nint ret;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\r\nif (ret != SHA1_DIGEST_SIZE)\r\nreturn ret;\r\nreturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\r\n}\r\nstatic int osap(struct tpm_buf *tb, struct osapsess *s,\r\nconst unsigned char *key, uint16_t type, uint32_t handle)\r\n{\r\nunsigned char enonce[TPM_NONCE_SIZE];\r\nunsigned char ononce[TPM_NONCE_SIZE];\r\nint ret;\r\nret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\r\nif (ret != TPM_NONCE_SIZE)\r\nreturn ret;\r\nINIT_BUF(tb);\r\nstore16(tb, TPM_TAG_RQU_COMMAND);\r\nstore32(tb, TPM_OSAP_SIZE);\r\nstore32(tb, TPM_ORD_OSAP);\r\nstore16(tb, type);\r\nstore32(tb, handle);\r\nstorebytes(tb, ononce, TPM_NONCE_SIZE);\r\nret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\r\nif (ret < 0)\r\nreturn ret;\r\ns->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\r\nmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\r\nTPM_NONCE_SIZE);\r\nmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\r\nTPM_NONCE_SIZE]), TPM_NONCE_SIZE);\r\nreturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\r\nenonce, TPM_NONCE_SIZE, ononce, 0, 0);\r\n}\r\nstatic int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\r\n{\r\nint ret;\r\nINIT_BUF(tb);\r\nstore16(tb, TPM_TAG_RQU_COMMAND);\r\nstore32(tb, TPM_OIAP_SIZE);\r\nstore32(tb, TPM_ORD_OIAP);\r\nret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\r\nif (ret < 0)\r\nreturn ret;\r\n*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\r\nmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\r\nTPM_NONCE_SIZE);\r\nreturn 0;\r\n}\r\nstatic int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\r\nuint32_t keyhandle, const unsigned char *keyauth,\r\nconst unsigned char *data, uint32_t datalen,\r\nunsigned char *blob, uint32_t *bloblen,\r\nconst unsigned char *blobauth,\r\nconst unsigned char *pcrinfo, uint32_t pcrinfosize)\r\n{\r\nstruct osapsess sess;\r\nstruct tpm_digests *td;\r\nunsigned char cont;\r\nuint32_t ordinal;\r\nuint32_t pcrsize;\r\nuint32_t datsize;\r\nint sealinfosize;\r\nint encdatasize;\r\nint storedsize;\r\nint ret;\r\nint i;\r\ntd = kmalloc(sizeof *td, GFP_KERNEL);\r\nif (!td)\r\nreturn -ENOMEM;\r\nret = osap(tb, &sess, keyauth, keytype, keyhandle);\r\nif (ret < 0)\r\ngoto out;\r\ndump_sess(&sess);\r\nmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\r\nmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\r\nret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\r\nif (ret < 0)\r\ngoto out;\r\nret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\r\nif (ret != TPM_NONCE_SIZE)\r\ngoto out;\r\nordinal = htonl(TPM_ORD_SEAL);\r\ndatsize = htonl(datalen);\r\npcrsize = htonl(pcrinfosize);\r\ncont = 0;\r\nfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\r\ntd->encauth[i] = td->xorhash[i] ^ blobauth[i];\r\nif (pcrinfosize == 0) {\r\nret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\r\nsess.enonce, td->nonceodd, cont,\r\nsizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\r\ntd->encauth, sizeof(uint32_t), &pcrsize,\r\nsizeof(uint32_t), &datsize, datalen, data, 0,\r\n0);\r\n} else {\r\nret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\r\nsess.enonce, td->nonceodd, cont,\r\nsizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\r\ntd->encauth, sizeof(uint32_t), &pcrsize,\r\npcrinfosize, pcrinfo, sizeof(uint32_t),\r\n&datsize, datalen, data, 0, 0);\r\n}\r\nif (ret < 0)\r\ngoto out;\r\nINIT_BUF(tb);\r\nstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\r\nstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\r\nstore32(tb, TPM_ORD_SEAL);\r\nstore32(tb, keyhandle);\r\nstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\r\nstore32(tb, pcrinfosize);\r\nstorebytes(tb, pcrinfo, pcrinfosize);\r\nstore32(tb, datalen);\r\nstorebytes(tb, data, datalen);\r\nstore32(tb, sess.handle);\r\nstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\r\nstore8(tb, cont);\r\nstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\r\nret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\r\nif (ret < 0)\r\ngoto out;\r\nsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\r\nencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\r\nsizeof(uint32_t) + sealinfosize);\r\nstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\r\nsizeof(uint32_t) + encdatasize;\r\nret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\r\nSHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\r\n0);\r\nif (!ret) {\r\nmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\r\n*bloblen = storedsize;\r\n}\r\nout:\r\nkfree(td);\r\nreturn ret;\r\n}\r\nstatic int tpm_unseal(struct tpm_buf *tb,\r\nuint32_t keyhandle, const unsigned char *keyauth,\r\nconst unsigned char *blob, int bloblen,\r\nconst unsigned char *blobauth,\r\nunsigned char *data, unsigned int *datalen)\r\n{\r\nunsigned char nonceodd[TPM_NONCE_SIZE];\r\nunsigned char enonce1[TPM_NONCE_SIZE];\r\nunsigned char enonce2[TPM_NONCE_SIZE];\r\nunsigned char authdata1[SHA1_DIGEST_SIZE];\r\nunsigned char authdata2[SHA1_DIGEST_SIZE];\r\nuint32_t authhandle1 = 0;\r\nuint32_t authhandle2 = 0;\r\nunsigned char cont = 0;\r\nuint32_t ordinal;\r\nuint32_t keyhndl;\r\nint ret;\r\nret = oiap(tb, &authhandle1, enonce1);\r\nif (ret < 0) {\r\npr_info("trusted_key: oiap failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = oiap(tb, &authhandle2, enonce2);\r\nif (ret < 0) {\r\npr_info("trusted_key: oiap failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nordinal = htonl(TPM_ORD_UNSEAL);\r\nkeyhndl = htonl(SRKHANDLE);\r\nret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\r\nif (ret != TPM_NONCE_SIZE) {\r\npr_info("trusted_key: tpm_get_random failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\r\nenonce1, nonceodd, cont, sizeof(uint32_t),\r\n&ordinal, bloblen, blob, 0, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\r\nenonce2, nonceodd, cont, sizeof(uint32_t),\r\n&ordinal, bloblen, blob, 0, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nINIT_BUF(tb);\r\nstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\r\nstore32(tb, TPM_UNSEAL_SIZE + bloblen);\r\nstore32(tb, TPM_ORD_UNSEAL);\r\nstore32(tb, keyhandle);\r\nstorebytes(tb, blob, bloblen);\r\nstore32(tb, authhandle1);\r\nstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\r\nstore8(tb, cont);\r\nstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\r\nstore32(tb, authhandle2);\r\nstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\r\nstore8(tb, cont);\r\nstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\r\nret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\r\nif (ret < 0) {\r\npr_info("trusted_key: authhmac failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\n*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\r\nret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\r\nkeyauth, SHA1_DIGEST_SIZE,\r\nblobauth, SHA1_DIGEST_SIZE,\r\nsizeof(uint32_t), TPM_DATA_OFFSET,\r\n*datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\r\n0);\r\nif (ret < 0) {\r\npr_info("trusted_key: TSS_checkhmac2 failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\r\nreturn 0;\r\n}\r\nstatic int key_seal(struct trusted_key_payload *p,\r\nstruct trusted_key_options *o)\r\n{\r\nstruct tpm_buf *tb;\r\nint ret;\r\ntb = kzalloc(sizeof *tb, GFP_KERNEL);\r\nif (!tb)\r\nreturn -ENOMEM;\r\np->key[p->key_len] = p->migratable;\r\nret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\r\np->key, p->key_len + 1, p->blob, &p->blob_len,\r\no->blobauth, o->pcrinfo, o->pcrinfo_len);\r\nif (ret < 0)\r\npr_info("trusted_key: srkseal failed (%d)\n", ret);\r\nkfree(tb);\r\nreturn ret;\r\n}\r\nstatic int key_unseal(struct trusted_key_payload *p,\r\nstruct trusted_key_options *o)\r\n{\r\nstruct tpm_buf *tb;\r\nint ret;\r\ntb = kzalloc(sizeof *tb, GFP_KERNEL);\r\nif (!tb)\r\nreturn -ENOMEM;\r\nret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\r\no->blobauth, p->key, &p->key_len);\r\nif (ret < 0)\r\npr_info("trusted_key: srkunseal failed (%d)\n", ret);\r\nelse\r\np->migratable = p->key[--p->key_len];\r\nkfree(tb);\r\nreturn ret;\r\n}\r\nstatic int getoptions(char *c, struct trusted_key_payload *pay,\r\nstruct trusted_key_options *opt)\r\n{\r\nsubstring_t args[MAX_OPT_ARGS];\r\nchar *p = c;\r\nint token;\r\nint res;\r\nunsigned long handle;\r\nunsigned long lock;\r\nunsigned long token_mask = 0;\r\nunsigned int digest_len;\r\nint i;\r\nint tpm2;\r\ntpm2 = tpm_is_tpm2(TPM_ANY_NUM);\r\nif (tpm2 < 0)\r\nreturn tpm2;\r\nopt->hash = tpm2 ? HASH_ALGO_SHA256 : HASH_ALGO_SHA1;\r\nwhile ((p = strsep(&c, " \t"))) {\r\nif (*p == '\0' || *p == ' ' || *p == '\t')\r\ncontinue;\r\ntoken = match_token(p, key_tokens, args);\r\nif (test_and_set_bit(token, &token_mask))\r\nreturn -EINVAL;\r\nswitch (token) {\r\ncase Opt_pcrinfo:\r\nopt->pcrinfo_len = strlen(args[0].from) / 2;\r\nif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\r\nreturn -EINVAL;\r\nres = hex2bin(opt->pcrinfo, args[0].from,\r\nopt->pcrinfo_len);\r\nif (res < 0)\r\nreturn -EINVAL;\r\nbreak;\r\ncase Opt_keyhandle:\r\nres = kstrtoul(args[0].from, 16, &handle);\r\nif (res < 0)\r\nreturn -EINVAL;\r\nopt->keytype = SEAL_keytype;\r\nopt->keyhandle = handle;\r\nbreak;\r\ncase Opt_keyauth:\r\nif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\r\nreturn -EINVAL;\r\nres = hex2bin(opt->keyauth, args[0].from,\r\nSHA1_DIGEST_SIZE);\r\nif (res < 0)\r\nreturn -EINVAL;\r\nbreak;\r\ncase Opt_blobauth:\r\nif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\r\nreturn -EINVAL;\r\nres = hex2bin(opt->blobauth, args[0].from,\r\nSHA1_DIGEST_SIZE);\r\nif (res < 0)\r\nreturn -EINVAL;\r\nbreak;\r\ncase Opt_migratable:\r\nif (*args[0].from == '0')\r\npay->migratable = 0;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase Opt_pcrlock:\r\nres = kstrtoul(args[0].from, 10, &lock);\r\nif (res < 0)\r\nreturn -EINVAL;\r\nopt->pcrlock = lock;\r\nbreak;\r\ncase Opt_hash:\r\nif (test_bit(Opt_policydigest, &token_mask))\r\nreturn -EINVAL;\r\nfor (i = 0; i < HASH_ALGO__LAST; i++) {\r\nif (!strcmp(args[0].from, hash_algo_name[i])) {\r\nopt->hash = i;\r\nbreak;\r\n}\r\n}\r\nif (i == HASH_ALGO__LAST)\r\nreturn -EINVAL;\r\nif (!tpm2 && i != HASH_ALGO_SHA1) {\r\npr_info("trusted_key: TPM 1.x only supports SHA-1.\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase Opt_policydigest:\r\ndigest_len = hash_digest_size[opt->hash];\r\nif (!tpm2 || strlen(args[0].from) != (2 * digest_len))\r\nreturn -EINVAL;\r\nres = hex2bin(opt->policydigest, args[0].from,\r\ndigest_len);\r\nif (res < 0)\r\nreturn -EINVAL;\r\nopt->policydigest_len = digest_len;\r\nbreak;\r\ncase Opt_policyhandle:\r\nif (!tpm2)\r\nreturn -EINVAL;\r\nres = kstrtoul(args[0].from, 16, &handle);\r\nif (res < 0)\r\nreturn -EINVAL;\r\nopt->policyhandle = handle;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int datablob_parse(char *datablob, struct trusted_key_payload *p,\r\nstruct trusted_key_options *o)\r\n{\r\nsubstring_t args[MAX_OPT_ARGS];\r\nlong keylen;\r\nint ret = -EINVAL;\r\nint key_cmd;\r\nchar *c;\r\nc = strsep(&datablob, " \t");\r\nif (!c)\r\nreturn -EINVAL;\r\nkey_cmd = match_token(c, key_tokens, args);\r\nswitch (key_cmd) {\r\ncase Opt_new:\r\nc = strsep(&datablob, " \t");\r\nif (!c)\r\nreturn -EINVAL;\r\nret = kstrtol(c, 10, &keylen);\r\nif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\r\nreturn -EINVAL;\r\np->key_len = keylen;\r\nret = getoptions(datablob, p, o);\r\nif (ret < 0)\r\nreturn ret;\r\nret = Opt_new;\r\nbreak;\r\ncase Opt_load:\r\nc = strsep(&datablob, " \t");\r\nif (!c)\r\nreturn -EINVAL;\r\np->blob_len = strlen(c) / 2;\r\nif (p->blob_len > MAX_BLOB_SIZE)\r\nreturn -EINVAL;\r\nret = hex2bin(p->blob, c, p->blob_len);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nret = getoptions(datablob, p, o);\r\nif (ret < 0)\r\nreturn ret;\r\nret = Opt_load;\r\nbreak;\r\ncase Opt_update:\r\nret = getoptions(datablob, p, o);\r\nif (ret < 0)\r\nreturn ret;\r\nret = Opt_update;\r\nbreak;\r\ncase Opt_err:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct trusted_key_options *trusted_options_alloc(void)\r\n{\r\nstruct trusted_key_options *options;\r\nint tpm2;\r\ntpm2 = tpm_is_tpm2(TPM_ANY_NUM);\r\nif (tpm2 < 0)\r\nreturn NULL;\r\noptions = kzalloc(sizeof *options, GFP_KERNEL);\r\nif (options) {\r\noptions->keytype = SRK_keytype;\r\nif (!tpm2)\r\noptions->keyhandle = SRKHANDLE;\r\n}\r\nreturn options;\r\n}\r\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\r\n{\r\nstruct trusted_key_payload *p = NULL;\r\nint ret;\r\nret = key_payload_reserve(key, sizeof *p);\r\nif (ret < 0)\r\nreturn p;\r\np = kzalloc(sizeof *p, GFP_KERNEL);\r\nif (p)\r\np->migratable = 1;\r\nreturn p;\r\n}\r\nstatic int trusted_instantiate(struct key *key,\r\nstruct key_preparsed_payload *prep)\r\n{\r\nstruct trusted_key_payload *payload = NULL;\r\nstruct trusted_key_options *options = NULL;\r\nsize_t datalen = prep->datalen;\r\nchar *datablob;\r\nint ret = 0;\r\nint key_cmd;\r\nsize_t key_len;\r\nint tpm2;\r\ntpm2 = tpm_is_tpm2(TPM_ANY_NUM);\r\nif (tpm2 < 0)\r\nreturn tpm2;\r\nif (datalen <= 0 || datalen > 32767 || !prep->data)\r\nreturn -EINVAL;\r\ndatablob = kmalloc(datalen + 1, GFP_KERNEL);\r\nif (!datablob)\r\nreturn -ENOMEM;\r\nmemcpy(datablob, prep->data, datalen);\r\ndatablob[datalen] = '\0';\r\noptions = trusted_options_alloc();\r\nif (!options) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npayload = trusted_payload_alloc(key);\r\nif (!payload) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nkey_cmd = datablob_parse(datablob, payload, options);\r\nif (key_cmd < 0) {\r\nret = key_cmd;\r\ngoto out;\r\n}\r\nif (!options->keyhandle) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndump_payload(payload);\r\ndump_options(options);\r\nswitch (key_cmd) {\r\ncase Opt_load:\r\nif (tpm2)\r\nret = tpm_unseal_trusted(TPM_ANY_NUM, payload, options);\r\nelse\r\nret = key_unseal(payload, options);\r\ndump_payload(payload);\r\ndump_options(options);\r\nif (ret < 0)\r\npr_info("trusted_key: key_unseal failed (%d)\n", ret);\r\nbreak;\r\ncase Opt_new:\r\nkey_len = payload->key_len;\r\nret = tpm_get_random(TPM_ANY_NUM, payload->key, key_len);\r\nif (ret != key_len) {\r\npr_info("trusted_key: key_create failed (%d)\n", ret);\r\ngoto out;\r\n}\r\nif (tpm2)\r\nret = tpm_seal_trusted(TPM_ANY_NUM, payload, options);\r\nelse\r\nret = key_seal(payload, options);\r\nif (ret < 0)\r\npr_info("trusted_key: key_seal failed (%d)\n", ret);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!ret && options->pcrlock)\r\nret = pcrlock(options->pcrlock);\r\nout:\r\nkfree(datablob);\r\nkfree(options);\r\nif (!ret)\r\nrcu_assign_keypointer(key, payload);\r\nelse\r\nkfree(payload);\r\nreturn ret;\r\n}\r\nstatic void trusted_rcu_free(struct rcu_head *rcu)\r\n{\r\nstruct trusted_key_payload *p;\r\np = container_of(rcu, struct trusted_key_payload, rcu);\r\nmemset(p->key, 0, p->key_len);\r\nkfree(p);\r\n}\r\nstatic int trusted_update(struct key *key, struct key_preparsed_payload *prep)\r\n{\r\nstruct trusted_key_payload *p;\r\nstruct trusted_key_payload *new_p;\r\nstruct trusted_key_options *new_o;\r\nsize_t datalen = prep->datalen;\r\nchar *datablob;\r\nint ret = 0;\r\nif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\r\nreturn -ENOKEY;\r\np = key->payload.data[0];\r\nif (!p->migratable)\r\nreturn -EPERM;\r\nif (datalen <= 0 || datalen > 32767 || !prep->data)\r\nreturn -EINVAL;\r\ndatablob = kmalloc(datalen + 1, GFP_KERNEL);\r\nif (!datablob)\r\nreturn -ENOMEM;\r\nnew_o = trusted_options_alloc();\r\nif (!new_o) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nnew_p = trusted_payload_alloc(key);\r\nif (!new_p) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(datablob, prep->data, datalen);\r\ndatablob[datalen] = '\0';\r\nret = datablob_parse(datablob, new_p, new_o);\r\nif (ret != Opt_update) {\r\nret = -EINVAL;\r\nkfree(new_p);\r\ngoto out;\r\n}\r\nif (!new_o->keyhandle) {\r\nret = -EINVAL;\r\nkfree(new_p);\r\ngoto out;\r\n}\r\nnew_p->migratable = p->migratable;\r\nnew_p->key_len = p->key_len;\r\nmemcpy(new_p->key, p->key, p->key_len);\r\ndump_payload(p);\r\ndump_payload(new_p);\r\nret = key_seal(new_p, new_o);\r\nif (ret < 0) {\r\npr_info("trusted_key: key_seal failed (%d)\n", ret);\r\nkfree(new_p);\r\ngoto out;\r\n}\r\nif (new_o->pcrlock) {\r\nret = pcrlock(new_o->pcrlock);\r\nif (ret < 0) {\r\npr_info("trusted_key: pcrlock failed (%d)\n", ret);\r\nkfree(new_p);\r\ngoto out;\r\n}\r\n}\r\nrcu_assign_keypointer(key, new_p);\r\ncall_rcu(&p->rcu, trusted_rcu_free);\r\nout:\r\nkfree(datablob);\r\nkfree(new_o);\r\nreturn ret;\r\n}\r\nstatic long trusted_read(const struct key *key, char __user *buffer,\r\nsize_t buflen)\r\n{\r\nstruct trusted_key_payload *p;\r\nchar *ascii_buf;\r\nchar *bufp;\r\nint i;\r\np = rcu_dereference_key(key);\r\nif (!p)\r\nreturn -EINVAL;\r\nif (!buffer || buflen <= 0)\r\nreturn 2 * p->blob_len;\r\nascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);\r\nif (!ascii_buf)\r\nreturn -ENOMEM;\r\nbufp = ascii_buf;\r\nfor (i = 0; i < p->blob_len; i++)\r\nbufp = hex_byte_pack(bufp, p->blob[i]);\r\nif ((copy_to_user(buffer, ascii_buf, 2 * p->blob_len)) != 0) {\r\nkfree(ascii_buf);\r\nreturn -EFAULT;\r\n}\r\nkfree(ascii_buf);\r\nreturn 2 * p->blob_len;\r\n}\r\nstatic void trusted_destroy(struct key *key)\r\n{\r\nstruct trusted_key_payload *p = key->payload.data[0];\r\nif (!p)\r\nreturn;\r\nmemset(p->key, 0, p->key_len);\r\nkfree(key->payload.data[0]);\r\n}\r\nstatic void trusted_shash_release(void)\r\n{\r\nif (hashalg)\r\ncrypto_free_shash(hashalg);\r\nif (hmacalg)\r\ncrypto_free_shash(hmacalg);\r\n}\r\nstatic int __init trusted_shash_alloc(void)\r\n{\r\nint ret;\r\nhmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(hmacalg)) {\r\npr_info("trusted_key: could not allocate crypto %s\n",\r\nhmac_alg);\r\nreturn PTR_ERR(hmacalg);\r\n}\r\nhashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(hashalg)) {\r\npr_info("trusted_key: could not allocate crypto %s\n",\r\nhash_alg);\r\nret = PTR_ERR(hashalg);\r\ngoto hashalg_fail;\r\n}\r\nreturn 0;\r\nhashalg_fail:\r\ncrypto_free_shash(hmacalg);\r\nreturn ret;\r\n}\r\nstatic int __init init_trusted(void)\r\n{\r\nint ret;\r\nret = trusted_shash_alloc();\r\nif (ret < 0)\r\nreturn ret;\r\nret = register_key_type(&key_type_trusted);\r\nif (ret < 0)\r\ntrusted_shash_release();\r\nreturn ret;\r\n}\r\nstatic void __exit cleanup_trusted(void)\r\n{\r\ntrusted_shash_release();\r\nunregister_key_type(&key_type_trusted);\r\n}
