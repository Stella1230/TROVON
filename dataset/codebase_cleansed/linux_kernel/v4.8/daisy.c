static void add_dev(int devnum, struct parport *port, int daisy)\r\n{\r\nstruct daisydev *newdev, **p;\r\nnewdev = kmalloc(sizeof(struct daisydev), GFP_KERNEL);\r\nif (newdev) {\r\nnewdev->port = port;\r\nnewdev->daisy = daisy;\r\nnewdev->devnum = devnum;\r\nspin_lock(&topology_lock);\r\nfor (p = &topology; *p && (*p)->devnum<devnum; p = &(*p)->next)\r\n;\r\nnewdev->next = *p;\r\n*p = newdev;\r\nspin_unlock(&topology_lock);\r\n}\r\n}\r\nstatic struct parport *clone_parport(struct parport *real, int muxport)\r\n{\r\nstruct parport *extra = parport_register_port(real->base,\r\nreal->irq,\r\nreal->dma,\r\nreal->ops);\r\nif (extra) {\r\nextra->portnum = real->portnum;\r\nextra->physport = real;\r\nextra->muxport = muxport;\r\nreal->slaves[muxport-1] = extra;\r\n}\r\nreturn extra;\r\n}\r\nint parport_daisy_init(struct parport *port)\r\n{\r\nint detected = 0;\r\nchar *deviceid;\r\nstatic const char *th[] = { "th", "st", "nd", "rd", "th" };\r\nint num_ports;\r\nint i;\r\nint last_try = 0;\r\nagain:\r\nif (port->muxport < 0 && mux_present(port) &&\r\n((num_ports = num_mux_ports(port)) == 2 || num_ports == 4)) {\r\nport->muxport = 0;\r\nprintk(KERN_INFO\r\n"%s: 1st (default) port of %d-way multiplexor\n",\r\nport->name, num_ports);\r\nfor (i = 1; i < num_ports; i++) {\r\nstruct parport *extra = clone_parport(port, i);\r\nif (!extra) {\r\nif (signal_pending(current))\r\nbreak;\r\nschedule();\r\ncontinue;\r\n}\r\nprintk(KERN_INFO\r\n"%s: %d%s port of %d-way multiplexor on %s\n",\r\nextra->name, i + 1, th[i + 1], num_ports,\r\nport->name);\r\nparport_daisy_init(extra);\r\n}\r\n}\r\nif (port->muxport >= 0)\r\nselect_port(port);\r\nparport_daisy_deselect_all(port);\r\ndetected += assign_addrs(port);\r\nadd_dev(numdevs++, port, -1);\r\ndeviceid = kmalloc(1024, GFP_KERNEL);\r\nif (deviceid) {\r\nif (parport_device_id(numdevs - 1, deviceid, 1024) > 2)\r\ndetected++;\r\nkfree(deviceid);\r\n}\r\nif (!detected && !last_try) {\r\nparport_daisy_fini(port);\r\nparport_write_control(port, PARPORT_CONTROL_SELECT);\r\nudelay(50);\r\nparport_write_control(port,\r\nPARPORT_CONTROL_SELECT |\r\nPARPORT_CONTROL_INIT);\r\nudelay(50);\r\nlast_try = 1;\r\ngoto again;\r\n}\r\nreturn detected;\r\n}\r\nvoid parport_daisy_fini(struct parport *port)\r\n{\r\nstruct daisydev **p;\r\nspin_lock(&topology_lock);\r\np = &topology;\r\nwhile (*p) {\r\nstruct daisydev *dev = *p;\r\nif (dev->port != port) {\r\np = &dev->next;\r\ncontinue;\r\n}\r\n*p = dev->next;\r\nkfree(dev);\r\n}\r\nif (!topology) numdevs = 0;\r\nspin_unlock(&topology_lock);\r\nreturn;\r\n}\r\nstruct pardevice *parport_open(int devnum, const char *name)\r\n{\r\nstruct daisydev *p = topology;\r\nstruct parport *port;\r\nstruct pardevice *dev;\r\nint daisy;\r\nspin_lock(&topology_lock);\r\nwhile (p && p->devnum != devnum)\r\np = p->next;\r\nif (!p) {\r\nspin_unlock(&topology_lock);\r\nreturn NULL;\r\n}\r\ndaisy = p->daisy;\r\nport = parport_get_port(p->port);\r\nspin_unlock(&topology_lock);\r\ndev = parport_register_device(port, name, NULL, NULL, NULL, 0, NULL);\r\nparport_put_port(port);\r\nif (!dev)\r\nreturn NULL;\r\ndev->daisy = daisy;\r\nif (daisy >= 0) {\r\nint selected;\r\nparport_claim_or_block(dev);\r\nselected = port->daisy;\r\nparport_release(dev);\r\nif (selected != daisy) {\r\nparport_unregister_device(dev);\r\nreturn NULL;\r\n}\r\n}\r\nreturn dev;\r\n}\r\nvoid parport_close(struct pardevice *dev)\r\n{\r\nparport_unregister_device(dev);\r\n}\r\nstatic int cpp_daisy(struct parport *port, int cmd)\r\n{\r\nunsigned char s;\r\nparport_data_forward(port);\r\nparport_write_data(port, 0xaa); udelay(2);\r\nparport_write_data(port, 0x55); udelay(2);\r\nparport_write_data(port, 0x00); udelay(2);\r\nparport_write_data(port, 0xff); udelay(2);\r\ns = parport_read_status(port) & (PARPORT_STATUS_BUSY\r\n| PARPORT_STATUS_PAPEROUT\r\n| PARPORT_STATUS_SELECT\r\n| PARPORT_STATUS_ERROR);\r\nif (s != (PARPORT_STATUS_BUSY\r\n| PARPORT_STATUS_PAPEROUT\r\n| PARPORT_STATUS_SELECT\r\n| PARPORT_STATUS_ERROR)) {\r\nDPRINTK(KERN_DEBUG "%s: cpp_daisy: aa5500ff(%02x)\n",\r\nport->name, s);\r\nreturn -ENXIO;\r\n}\r\nparport_write_data(port, 0x87); udelay(2);\r\ns = parport_read_status(port) & (PARPORT_STATUS_BUSY\r\n| PARPORT_STATUS_PAPEROUT\r\n| PARPORT_STATUS_SELECT\r\n| PARPORT_STATUS_ERROR);\r\nif (s != (PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR)) {\r\nDPRINTK(KERN_DEBUG "%s: cpp_daisy: aa5500ff87(%02x)\n",\r\nport->name, s);\r\nreturn -ENXIO;\r\n}\r\nparport_write_data(port, 0x78); udelay(2);\r\nparport_write_data(port, cmd); udelay(2);\r\nparport_frob_control(port,\r\nPARPORT_CONTROL_STROBE,\r\nPARPORT_CONTROL_STROBE);\r\nudelay(1);\r\ns = parport_read_status(port);\r\nparport_frob_control(port, PARPORT_CONTROL_STROBE, 0);\r\nudelay(1);\r\nparport_write_data(port, 0xff); udelay(2);\r\nreturn s;\r\n}\r\nstatic int cpp_mux(struct parport *port, int cmd)\r\n{\r\nunsigned char s;\r\nint rc;\r\nparport_data_forward(port);\r\nparport_write_data(port, 0xaa); udelay(2);\r\nparport_write_data(port, 0x55); udelay(2);\r\nparport_write_data(port, 0xf0); udelay(2);\r\nparport_write_data(port, 0x0f); udelay(2);\r\nparport_write_data(port, 0x52); udelay(2);\r\nparport_write_data(port, 0xad); udelay(2);\r\nparport_write_data(port, cmd); udelay(2);\r\ns = parport_read_status(port);\r\nif (!(s & PARPORT_STATUS_ACK)) {\r\nDPRINTK(KERN_DEBUG "%s: cpp_mux: aa55f00f52ad%02x(%02x)\n",\r\nport->name, cmd, s);\r\nreturn -EIO;\r\n}\r\nrc = (((s & PARPORT_STATUS_SELECT ? 1 : 0) << 0) |\r\n((s & PARPORT_STATUS_PAPEROUT ? 1 : 0) << 1) |\r\n((s & PARPORT_STATUS_BUSY ? 0 : 1) << 2) |\r\n((s & PARPORT_STATUS_ERROR ? 0 : 1) << 3));\r\nreturn rc;\r\n}\r\nvoid parport_daisy_deselect_all(struct parport *port)\r\n{\r\ncpp_daisy(port, 0x30);\r\n}\r\nint parport_daisy_select(struct parport *port, int daisy, int mode)\r\n{\r\nswitch (mode)\r\n{\r\ncase IEEE1284_MODE_EPP:\r\ncase IEEE1284_MODE_EPPSL:\r\ncase IEEE1284_MODE_EPPSWE:\r\nreturn !(cpp_daisy(port, 0x20 + daisy) &\r\nPARPORT_STATUS_ERROR);\r\ncase IEEE1284_MODE_ECP:\r\ncase IEEE1284_MODE_ECPRLE:\r\ncase IEEE1284_MODE_ECPSWE:\r\nreturn !(cpp_daisy(port, 0xd0 + daisy) &\r\nPARPORT_STATUS_ERROR);\r\ncase IEEE1284_MODE_BECP:\r\ncase IEEE1284_MODE_NIBBLE:\r\ncase IEEE1284_MODE_BYTE:\r\ncase IEEE1284_MODE_COMPAT:\r\ndefault:\r\nreturn !(cpp_daisy(port, 0xe0 + daisy) &\r\nPARPORT_STATUS_ERROR);\r\n}\r\n}\r\nstatic int mux_present(struct parport *port)\r\n{\r\nreturn cpp_mux(port, 0x51) == 3;\r\n}\r\nstatic int num_mux_ports(struct parport *port)\r\n{\r\nreturn cpp_mux(port, 0x58);\r\n}\r\nstatic int select_port(struct parport *port)\r\n{\r\nint muxport = port->muxport;\r\nreturn cpp_mux(port, 0x60 + muxport) == muxport;\r\n}\r\nstatic int assign_addrs(struct parport *port)\r\n{\r\nunsigned char s;\r\nunsigned char daisy;\r\nint thisdev = numdevs;\r\nint detected;\r\nchar *deviceid;\r\nparport_data_forward(port);\r\nparport_write_data(port, 0xaa); udelay(2);\r\nparport_write_data(port, 0x55); udelay(2);\r\nparport_write_data(port, 0x00); udelay(2);\r\nparport_write_data(port, 0xff); udelay(2);\r\ns = parport_read_status(port) & (PARPORT_STATUS_BUSY\r\n| PARPORT_STATUS_PAPEROUT\r\n| PARPORT_STATUS_SELECT\r\n| PARPORT_STATUS_ERROR);\r\nif (s != (PARPORT_STATUS_BUSY\r\n| PARPORT_STATUS_PAPEROUT\r\n| PARPORT_STATUS_SELECT\r\n| PARPORT_STATUS_ERROR)) {\r\nDPRINTK(KERN_DEBUG "%s: assign_addrs: aa5500ff(%02x)\n",\r\nport->name, s);\r\nreturn 0;\r\n}\r\nparport_write_data(port, 0x87); udelay(2);\r\ns = parport_read_status(port) & (PARPORT_STATUS_BUSY\r\n| PARPORT_STATUS_PAPEROUT\r\n| PARPORT_STATUS_SELECT\r\n| PARPORT_STATUS_ERROR);\r\nif (s != (PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR)) {\r\nDPRINTK(KERN_DEBUG "%s: assign_addrs: aa5500ff87(%02x)\n",\r\nport->name, s);\r\nreturn 0;\r\n}\r\nparport_write_data(port, 0x78); udelay(2);\r\ns = parport_read_status(port);\r\nfor (daisy = 0;\r\n(s & (PARPORT_STATUS_PAPEROUT|PARPORT_STATUS_SELECT))\r\n== (PARPORT_STATUS_PAPEROUT|PARPORT_STATUS_SELECT)\r\n&& daisy < 4;\r\n++daisy) {\r\nparport_write_data(port, daisy);\r\nudelay(2);\r\nparport_frob_control(port,\r\nPARPORT_CONTROL_STROBE,\r\nPARPORT_CONTROL_STROBE);\r\nudelay(1);\r\nparport_frob_control(port, PARPORT_CONTROL_STROBE, 0);\r\nudelay(1);\r\nadd_dev(numdevs++, port, daisy);\r\nif (!(s & PARPORT_STATUS_BUSY))\r\nbreak;\r\ns = parport_read_status(port);\r\n}\r\nparport_write_data(port, 0xff); udelay(2);\r\ndetected = numdevs - thisdev;\r\nDPRINTK(KERN_DEBUG "%s: Found %d daisy-chained devices\n", port->name,\r\ndetected);\r\ndeviceid = kmalloc(1024, GFP_KERNEL);\r\nif (!deviceid) return 0;\r\nfor (daisy = 0; thisdev < numdevs; thisdev++, daisy++)\r\nparport_device_id(thisdev, deviceid, 1024);\r\nkfree(deviceid);\r\nreturn detected;\r\n}
