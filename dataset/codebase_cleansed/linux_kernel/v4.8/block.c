static int __init ubiblock_set_param(const char *val,\r\nconst struct kernel_param *kp)\r\n{\r\nint i, ret;\r\nsize_t len;\r\nstruct ubiblock_param *param;\r\nchar buf[UBIBLOCK_PARAM_LEN];\r\nchar *pbuf = &buf[0];\r\nchar *tokens[UBIBLOCK_PARAM_COUNT];\r\nif (!val)\r\nreturn -EINVAL;\r\nlen = strnlen(val, UBIBLOCK_PARAM_LEN);\r\nif (len == 0) {\r\npr_warn("UBI: block: empty 'block=' parameter - ignored\n");\r\nreturn 0;\r\n}\r\nif (len == UBIBLOCK_PARAM_LEN) {\r\npr_err("UBI: block: parameter \"%s\" is too long, max. is %d\n",\r\nval, UBIBLOCK_PARAM_LEN);\r\nreturn -EINVAL;\r\n}\r\nstrcpy(buf, val);\r\nif (buf[len - 1] == '\n')\r\nbuf[len - 1] = '\0';\r\nfor (i = 0; i < UBIBLOCK_PARAM_COUNT; i++)\r\ntokens[i] = strsep(&pbuf, ",");\r\nparam = &ubiblock_param[ubiblock_devs];\r\nif (tokens[1]) {\r\nret = kstrtoint(tokens[0], 10, &param->ubi_num);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nret = kstrtoint(tokens[1], 10, &param->vol_id);\r\nif (ret < 0) {\r\nparam->vol_id = -1;\r\nstrcpy(param->name, tokens[1]);\r\n}\r\n} else {\r\nstrcpy(param->name, tokens[0]);\r\nparam->ubi_num = -1;\r\nparam->vol_id = -1;\r\n}\r\nubiblock_devs++;\r\nreturn 0;\r\n}\r\nstatic struct ubiblock *find_dev_nolock(int ubi_num, int vol_id)\r\n{\r\nstruct ubiblock *dev;\r\nlist_for_each_entry(dev, &ubiblock_devices, list)\r\nif (dev->ubi_num == ubi_num && dev->vol_id == vol_id)\r\nreturn dev;\r\nreturn NULL;\r\n}\r\nstatic int ubiblock_read(struct ubiblock_pdu *pdu)\r\n{\r\nint ret, leb, offset, bytes_left, to_read;\r\nu64 pos;\r\nstruct request *req = blk_mq_rq_from_pdu(pdu);\r\nstruct ubiblock *dev = req->q->queuedata;\r\nto_read = blk_rq_bytes(req);\r\npos = blk_rq_pos(req) << 9;\r\noffset = do_div(pos, dev->leb_size);\r\nleb = pos;\r\nbytes_left = to_read;\r\nwhile (bytes_left) {\r\nif (offset + to_read > dev->leb_size)\r\nto_read = dev->leb_size - offset;\r\nret = ubi_read_sg(dev->desc, leb, &pdu->usgl, offset, to_read);\r\nif (ret < 0)\r\nreturn ret;\r\nbytes_left -= to_read;\r\nto_read = bytes_left;\r\nleb += 1;\r\noffset = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ubiblock_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct ubiblock *dev = bdev->bd_disk->private_data;\r\nint ret;\r\nmutex_lock(&dev->dev_mutex);\r\nif (dev->refcnt > 0) {\r\ngoto out_done;\r\n}\r\nif (mode & FMODE_WRITE) {\r\nret = -EPERM;\r\ngoto out_unlock;\r\n}\r\ndev->desc = ubi_open_volume(dev->ubi_num, dev->vol_id, UBI_READONLY);\r\nif (IS_ERR(dev->desc)) {\r\ndev_err(disk_to_dev(dev->gd), "failed to open ubi volume %d_%d",\r\ndev->ubi_num, dev->vol_id);\r\nret = PTR_ERR(dev->desc);\r\ndev->desc = NULL;\r\ngoto out_unlock;\r\n}\r\nout_done:\r\ndev->refcnt++;\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn 0;\r\nout_unlock:\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn ret;\r\n}\r\nstatic void ubiblock_release(struct gendisk *gd, fmode_t mode)\r\n{\r\nstruct ubiblock *dev = gd->private_data;\r\nmutex_lock(&dev->dev_mutex);\r\ndev->refcnt--;\r\nif (dev->refcnt == 0) {\r\nubi_close_volume(dev->desc);\r\ndev->desc = NULL;\r\n}\r\nmutex_unlock(&dev->dev_mutex);\r\n}\r\nstatic int ubiblock_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\ngeo->heads = 1;\r\ngeo->cylinders = 1;\r\ngeo->sectors = get_capacity(bdev->bd_disk);\r\ngeo->start = 0;\r\nreturn 0;\r\n}\r\nstatic void ubiblock_do_work(struct work_struct *work)\r\n{\r\nint ret;\r\nstruct ubiblock_pdu *pdu = container_of(work, struct ubiblock_pdu, work);\r\nstruct request *req = blk_mq_rq_from_pdu(pdu);\r\nblk_mq_start_request(req);\r\nblk_rq_map_sg(req->q, req, pdu->usgl.sg);\r\nret = ubiblock_read(pdu);\r\nrq_flush_dcache_pages(req);\r\nblk_mq_end_request(req, ret);\r\n}\r\nstatic int ubiblock_queue_rq(struct blk_mq_hw_ctx *hctx,\r\nconst struct blk_mq_queue_data *bd)\r\n{\r\nstruct request *req = bd->rq;\r\nstruct ubiblock *dev = hctx->queue->queuedata;\r\nstruct ubiblock_pdu *pdu = blk_mq_rq_to_pdu(req);\r\nif (req->cmd_type != REQ_TYPE_FS)\r\nreturn BLK_MQ_RQ_QUEUE_ERROR;\r\nif (rq_data_dir(req) != READ)\r\nreturn BLK_MQ_RQ_QUEUE_ERROR;\r\nubi_sgl_init(&pdu->usgl);\r\nqueue_work(dev->wq, &pdu->work);\r\nreturn BLK_MQ_RQ_QUEUE_OK;\r\n}\r\nstatic int ubiblock_init_request(void *data, struct request *req,\r\nunsigned int hctx_idx,\r\nunsigned int request_idx,\r\nunsigned int numa_node)\r\n{\r\nstruct ubiblock_pdu *pdu = blk_mq_rq_to_pdu(req);\r\nsg_init_table(pdu->usgl.sg, UBI_MAX_SG_COUNT);\r\nINIT_WORK(&pdu->work, ubiblock_do_work);\r\nreturn 0;\r\n}\r\nint ubiblock_create(struct ubi_volume_info *vi)\r\n{\r\nstruct ubiblock *dev;\r\nstruct gendisk *gd;\r\nu64 disk_capacity = vi->used_bytes >> 9;\r\nint ret;\r\nif ((sector_t)disk_capacity != disk_capacity)\r\nreturn -EFBIG;\r\nmutex_lock(&devices_mutex);\r\nif (find_dev_nolock(vi->ubi_num, vi->vol_id)) {\r\nmutex_unlock(&devices_mutex);\r\nreturn -EEXIST;\r\n}\r\nmutex_unlock(&devices_mutex);\r\ndev = kzalloc(sizeof(struct ubiblock), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nmutex_init(&dev->dev_mutex);\r\ndev->ubi_num = vi->ubi_num;\r\ndev->vol_id = vi->vol_id;\r\ndev->leb_size = vi->usable_leb_size;\r\ngd = alloc_disk(1);\r\nif (!gd) {\r\npr_err("UBI: block: alloc_disk failed");\r\nret = -ENODEV;\r\ngoto out_free_dev;\r\n}\r\ngd->fops = &ubiblock_ops;\r\ngd->major = ubiblock_major;\r\ngd->first_minor = idr_alloc(&ubiblock_minor_idr, dev, 0, 0, GFP_KERNEL);\r\nif (gd->first_minor < 0) {\r\ndev_err(disk_to_dev(gd),\r\n"block: dynamic minor allocation failed");\r\nret = -ENODEV;\r\ngoto out_put_disk;\r\n}\r\ngd->private_data = dev;\r\nsprintf(gd->disk_name, "ubiblock%d_%d", dev->ubi_num, dev->vol_id);\r\nset_capacity(gd, disk_capacity);\r\ndev->gd = gd;\r\ndev->tag_set.ops = &ubiblock_mq_ops;\r\ndev->tag_set.queue_depth = 64;\r\ndev->tag_set.numa_node = NUMA_NO_NODE;\r\ndev->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;\r\ndev->tag_set.cmd_size = sizeof(struct ubiblock_pdu);\r\ndev->tag_set.driver_data = dev;\r\ndev->tag_set.nr_hw_queues = 1;\r\nret = blk_mq_alloc_tag_set(&dev->tag_set);\r\nif (ret) {\r\ndev_err(disk_to_dev(dev->gd), "blk_mq_alloc_tag_set failed");\r\ngoto out_remove_minor;\r\n}\r\ndev->rq = blk_mq_init_queue(&dev->tag_set);\r\nif (IS_ERR(dev->rq)) {\r\ndev_err(disk_to_dev(gd), "blk_mq_init_queue failed");\r\nret = PTR_ERR(dev->rq);\r\ngoto out_free_tags;\r\n}\r\nblk_queue_max_segments(dev->rq, UBI_MAX_SG_COUNT);\r\ndev->rq->queuedata = dev;\r\ndev->gd->queue = dev->rq;\r\ndev->wq = alloc_workqueue("%s", 0, 0, gd->disk_name);\r\nif (!dev->wq) {\r\nret = -ENOMEM;\r\ngoto out_free_queue;\r\n}\r\nmutex_lock(&devices_mutex);\r\nlist_add_tail(&dev->list, &ubiblock_devices);\r\nmutex_unlock(&devices_mutex);\r\nadd_disk(dev->gd);\r\ndev_info(disk_to_dev(dev->gd), "created from ubi%d:%d(%s)",\r\ndev->ubi_num, dev->vol_id, vi->name);\r\nreturn 0;\r\nout_free_queue:\r\nblk_cleanup_queue(dev->rq);\r\nout_free_tags:\r\nblk_mq_free_tag_set(&dev->tag_set);\r\nout_remove_minor:\r\nidr_remove(&ubiblock_minor_idr, gd->first_minor);\r\nout_put_disk:\r\nput_disk(dev->gd);\r\nout_free_dev:\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nstatic void ubiblock_cleanup(struct ubiblock *dev)\r\n{\r\ndel_gendisk(dev->gd);\r\ndestroy_workqueue(dev->wq);\r\nblk_cleanup_queue(dev->rq);\r\nblk_mq_free_tag_set(&dev->tag_set);\r\ndev_info(disk_to_dev(dev->gd), "released");\r\nidr_remove(&ubiblock_minor_idr, dev->gd->first_minor);\r\nput_disk(dev->gd);\r\n}\r\nint ubiblock_remove(struct ubi_volume_info *vi)\r\n{\r\nstruct ubiblock *dev;\r\nmutex_lock(&devices_mutex);\r\ndev = find_dev_nolock(vi->ubi_num, vi->vol_id);\r\nif (!dev) {\r\nmutex_unlock(&devices_mutex);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&dev->dev_mutex);\r\nif (dev->refcnt > 0) {\r\nmutex_unlock(&dev->dev_mutex);\r\nmutex_unlock(&devices_mutex);\r\nreturn -EBUSY;\r\n}\r\nlist_del(&dev->list);\r\nmutex_unlock(&devices_mutex);\r\nubiblock_cleanup(dev);\r\nmutex_unlock(&dev->dev_mutex);\r\nkfree(dev);\r\nreturn 0;\r\n}\r\nstatic int ubiblock_resize(struct ubi_volume_info *vi)\r\n{\r\nstruct ubiblock *dev;\r\nu64 disk_capacity = vi->used_bytes >> 9;\r\nmutex_lock(&devices_mutex);\r\ndev = find_dev_nolock(vi->ubi_num, vi->vol_id);\r\nif (!dev) {\r\nmutex_unlock(&devices_mutex);\r\nreturn -ENODEV;\r\n}\r\nif ((sector_t)disk_capacity != disk_capacity) {\r\nmutex_unlock(&devices_mutex);\r\ndev_warn(disk_to_dev(dev->gd), "the volume is too big (%d LEBs), cannot resize",\r\nvi->size);\r\nreturn -EFBIG;\r\n}\r\nmutex_lock(&dev->dev_mutex);\r\nif (get_capacity(dev->gd) != disk_capacity) {\r\nset_capacity(dev->gd, disk_capacity);\r\ndev_info(disk_to_dev(dev->gd), "resized to %lld bytes",\r\nvi->used_bytes);\r\n}\r\nmutex_unlock(&dev->dev_mutex);\r\nmutex_unlock(&devices_mutex);\r\nreturn 0;\r\n}\r\nstatic int ubiblock_notify(struct notifier_block *nb,\r\nunsigned long notification_type, void *ns_ptr)\r\n{\r\nstruct ubi_notification *nt = ns_ptr;\r\nswitch (notification_type) {\r\ncase UBI_VOLUME_ADDED:\r\nbreak;\r\ncase UBI_VOLUME_REMOVED:\r\nubiblock_remove(&nt->vi);\r\nbreak;\r\ncase UBI_VOLUME_RESIZED:\r\nubiblock_resize(&nt->vi);\r\nbreak;\r\ncase UBI_VOLUME_UPDATED:\r\nif (nt->vi.vol_type == UBI_STATIC_VOLUME)\r\nubiblock_resize(&nt->vi);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic struct ubi_volume_desc * __init\r\nopen_volume_desc(const char *name, int ubi_num, int vol_id)\r\n{\r\nif (ubi_num == -1)\r\nreturn ubi_open_volume_path(name, UBI_READONLY);\r\nelse if (vol_id == -1)\r\nreturn ubi_open_volume_nm(ubi_num, name, UBI_READONLY);\r\nelse\r\nreturn ubi_open_volume(ubi_num, vol_id, UBI_READONLY);\r\n}\r\nstatic void __init ubiblock_create_from_param(void)\r\n{\r\nint i, ret = 0;\r\nstruct ubiblock_param *p;\r\nstruct ubi_volume_desc *desc;\r\nstruct ubi_volume_info vi;\r\nfor (i = 0; i < ubiblock_devs; i++) {\r\np = &ubiblock_param[i];\r\ndesc = open_volume_desc(p->name, p->ubi_num, p->vol_id);\r\nif (IS_ERR(desc)) {\r\npr_err(\r\n"UBI: block: can't open volume on ubi%d_%d, err=%ld",\r\np->ubi_num, p->vol_id, PTR_ERR(desc));\r\ncontinue;\r\n}\r\nubi_get_volume_info(desc, &vi);\r\nubi_close_volume(desc);\r\nret = ubiblock_create(&vi);\r\nif (ret) {\r\npr_err(\r\n"UBI: block: can't add '%s' volume on ubi%d_%d, err=%d",\r\nvi.name, p->ubi_num, p->vol_id, ret);\r\ncontinue;\r\n}\r\n}\r\n}\r\nstatic void ubiblock_remove_all(void)\r\n{\r\nstruct ubiblock *next;\r\nstruct ubiblock *dev;\r\nlist_for_each_entry_safe(dev, next, &ubiblock_devices, list) {\r\nWARN_ON(dev->desc);\r\nlist_del(&dev->list);\r\nubiblock_cleanup(dev);\r\nkfree(dev);\r\n}\r\n}\r\nint __init ubiblock_init(void)\r\n{\r\nint ret;\r\nubiblock_major = register_blkdev(0, "ubiblock");\r\nif (ubiblock_major < 0)\r\nreturn ubiblock_major;\r\nubiblock_create_from_param();\r\nret = ubi_register_volume_notifier(&ubiblock_notifier, 1);\r\nif (ret)\r\ngoto err_unreg;\r\nreturn 0;\r\nerr_unreg:\r\nunregister_blkdev(ubiblock_major, "ubiblock");\r\nubiblock_remove_all();\r\nreturn ret;\r\n}\r\nvoid __exit ubiblock_exit(void)\r\n{\r\nubi_unregister_volume_notifier(&ubiblock_notifier);\r\nubiblock_remove_all();\r\nunregister_blkdev(ubiblock_major, "ubiblock");\r\n}
