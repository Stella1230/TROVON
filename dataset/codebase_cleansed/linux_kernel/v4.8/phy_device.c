void phy_device_free(struct phy_device *phydev)\r\n{\r\nput_device(&phydev->mdio.dev);\r\n}\r\nstatic void phy_mdio_device_free(struct mdio_device *mdiodev)\r\n{\r\nstruct phy_device *phydev;\r\nphydev = container_of(mdiodev, struct phy_device, mdio);\r\nphy_device_free(phydev);\r\n}\r\nstatic void phy_device_release(struct device *dev)\r\n{\r\nkfree(to_phy_device(dev));\r\n}\r\nstatic void phy_mdio_device_remove(struct mdio_device *mdiodev)\r\n{\r\nstruct phy_device *phydev;\r\nphydev = container_of(mdiodev, struct phy_device, mdio);\r\nphy_device_remove(phydev);\r\n}\r\nstatic bool mdio_bus_phy_may_suspend(struct phy_device *phydev)\r\n{\r\nstruct device_driver *drv = phydev->mdio.dev.driver;\r\nstruct phy_driver *phydrv = to_phy_driver(drv);\r\nstruct net_device *netdev = phydev->attached_dev;\r\nif (!drv || !phydrv->suspend)\r\nreturn false;\r\nif (!netdev)\r\nreturn !phydev->suspended;\r\nif (netdev->dev.parent && device_may_wakeup(netdev->dev.parent))\r\nreturn false;\r\nif (device_may_wakeup(&netdev->dev))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int mdio_bus_phy_suspend(struct device *dev)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nif (phydev->attached_dev && phydev->adjust_link)\r\nphy_stop_machine(phydev);\r\nif (!mdio_bus_phy_may_suspend(phydev))\r\nreturn 0;\r\nreturn phy_suspend(phydev);\r\n}\r\nstatic int mdio_bus_phy_resume(struct device *dev)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nint ret;\r\nif (!mdio_bus_phy_may_suspend(phydev))\r\ngoto no_resume;\r\nret = phy_resume(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\nno_resume:\r\nif (phydev->attached_dev && phydev->adjust_link)\r\nphy_start_machine(phydev);\r\nreturn 0;\r\n}\r\nstatic int mdio_bus_phy_restore(struct device *dev)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nstruct net_device *netdev = phydev->attached_dev;\r\nint ret;\r\nif (!netdev)\r\nreturn 0;\r\nret = phy_init_hw(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\nphydev->link = 0;\r\nphydev->state = PHY_UP;\r\nphy_start_machine(phydev);\r\nreturn 0;\r\n}\r\nint phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,\r\nint (*run)(struct phy_device *))\r\n{\r\nstruct phy_fixup *fixup = kzalloc(sizeof(*fixup), GFP_KERNEL);\r\nif (!fixup)\r\nreturn -ENOMEM;\r\nstrlcpy(fixup->bus_id, bus_id, sizeof(fixup->bus_id));\r\nfixup->phy_uid = phy_uid;\r\nfixup->phy_uid_mask = phy_uid_mask;\r\nfixup->run = run;\r\nmutex_lock(&phy_fixup_lock);\r\nlist_add_tail(&fixup->list, &phy_fixup_list);\r\nmutex_unlock(&phy_fixup_lock);\r\nreturn 0;\r\n}\r\nint phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,\r\nint (*run)(struct phy_device *))\r\n{\r\nreturn phy_register_fixup(PHY_ANY_ID, phy_uid, phy_uid_mask, run);\r\n}\r\nint phy_register_fixup_for_id(const char *bus_id,\r\nint (*run)(struct phy_device *))\r\n{\r\nreturn phy_register_fixup(bus_id, PHY_ANY_UID, 0xffffffff, run);\r\n}\r\nstatic int phy_needs_fixup(struct phy_device *phydev, struct phy_fixup *fixup)\r\n{\r\nif (strcmp(fixup->bus_id, phydev_name(phydev)) != 0)\r\nif (strcmp(fixup->bus_id, PHY_ANY_ID) != 0)\r\nreturn 0;\r\nif ((fixup->phy_uid & fixup->phy_uid_mask) !=\r\n(phydev->phy_id & fixup->phy_uid_mask))\r\nif (fixup->phy_uid != PHY_ANY_UID)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int phy_scan_fixups(struct phy_device *phydev)\r\n{\r\nstruct phy_fixup *fixup;\r\nmutex_lock(&phy_fixup_lock);\r\nlist_for_each_entry(fixup, &phy_fixup_list, list) {\r\nif (phy_needs_fixup(phydev, fixup)) {\r\nint err = fixup->run(phydev);\r\nif (err < 0) {\r\nmutex_unlock(&phy_fixup_lock);\r\nreturn err;\r\n}\r\nphydev->has_fixups = true;\r\n}\r\n}\r\nmutex_unlock(&phy_fixup_lock);\r\nreturn 0;\r\n}\r\nstatic int phy_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nstruct phy_driver *phydrv = to_phy_driver(drv);\r\nconst int num_ids = ARRAY_SIZE(phydev->c45_ids.device_ids);\r\nint i;\r\nif (!(phydrv->mdiodrv.flags & MDIO_DEVICE_IS_PHY))\r\nreturn 0;\r\nif (phydrv->match_phy_device)\r\nreturn phydrv->match_phy_device(phydev);\r\nif (phydev->is_c45) {\r\nfor (i = 1; i < num_ids; i++) {\r\nif (!(phydev->c45_ids.devices_in_package & (1 << i)))\r\ncontinue;\r\nif ((phydrv->phy_id & phydrv->phy_id_mask) ==\r\n(phydev->c45_ids.device_ids[i] &\r\nphydrv->phy_id_mask))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n} else {\r\nreturn (phydrv->phy_id & phydrv->phy_id_mask) ==\r\n(phydev->phy_id & phydrv->phy_id_mask);\r\n}\r\n}\r\nstruct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,\r\nbool is_c45,\r\nstruct phy_c45_device_ids *c45_ids)\r\n{\r\nstruct phy_device *dev;\r\nstruct mdio_device *mdiodev;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nmdiodev = &dev->mdio;\r\nmdiodev->dev.release = phy_device_release;\r\nmdiodev->dev.parent = &bus->dev;\r\nmdiodev->dev.bus = &mdio_bus_type;\r\nmdiodev->bus = bus;\r\nmdiodev->pm_ops = MDIO_BUS_PHY_PM_OPS;\r\nmdiodev->bus_match = phy_bus_match;\r\nmdiodev->addr = addr;\r\nmdiodev->flags = MDIO_DEVICE_FLAG_PHY;\r\nmdiodev->device_free = phy_mdio_device_free;\r\nmdiodev->device_remove = phy_mdio_device_remove;\r\ndev->speed = 0;\r\ndev->duplex = -1;\r\ndev->pause = 0;\r\ndev->asym_pause = 0;\r\ndev->link = 1;\r\ndev->interface = PHY_INTERFACE_MODE_GMII;\r\ndev->autoneg = AUTONEG_ENABLE;\r\ndev->is_c45 = is_c45;\r\ndev->phy_id = phy_id;\r\nif (c45_ids)\r\ndev->c45_ids = *c45_ids;\r\ndev->irq = bus->irq[addr];\r\ndev_set_name(&mdiodev->dev, PHY_ID_FMT, bus->id, addr);\r\ndev->state = PHY_DOWN;\r\nmutex_init(&dev->lock);\r\nINIT_DELAYED_WORK(&dev->state_queue, phy_state_machine);\r\nINIT_WORK(&dev->phy_queue, phy_change);\r\nrequest_module(MDIO_MODULE_PREFIX MDIO_ID_FMT, MDIO_ID_ARGS(phy_id));\r\ndevice_initialize(&mdiodev->dev);\r\nreturn dev;\r\n}\r\nstatic int get_phy_c45_devs_in_pkg(struct mii_bus *bus, int addr, int dev_addr,\r\nu32 *devices_in_package)\r\n{\r\nint phy_reg, reg_addr;\r\nreg_addr = MII_ADDR_C45 | dev_addr << 16 | MDIO_DEVS2;\r\nphy_reg = mdiobus_read(bus, addr, reg_addr);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\n*devices_in_package = (phy_reg & 0xffff) << 16;\r\nreg_addr = MII_ADDR_C45 | dev_addr << 16 | MDIO_DEVS1;\r\nphy_reg = mdiobus_read(bus, addr, reg_addr);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\n*devices_in_package |= (phy_reg & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int get_phy_c45_ids(struct mii_bus *bus, int addr, u32 *phy_id,\r\nstruct phy_c45_device_ids *c45_ids) {\r\nint phy_reg;\r\nint i, reg_addr;\r\nconst int num_ids = ARRAY_SIZE(c45_ids->device_ids);\r\nu32 *devs = &c45_ids->devices_in_package;\r\nfor (i = 1; i < num_ids && *devs == 0; i++) {\r\nphy_reg = get_phy_c45_devs_in_pkg(bus, addr, i, devs);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\nif ((*devs & 0x1fffffff) == 0x1fffffff) {\r\nphy_reg = get_phy_c45_devs_in_pkg(bus, addr, 0, devs);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\nif ((*devs & 0x1fffffff) == 0x1fffffff) {\r\n*phy_id = 0xffffffff;\r\nreturn 0;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nfor (i = 1; i < num_ids; i++) {\r\nif (!(c45_ids->devices_in_package & (1 << i)))\r\ncontinue;\r\nreg_addr = MII_ADDR_C45 | i << 16 | MII_PHYSID1;\r\nphy_reg = mdiobus_read(bus, addr, reg_addr);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\nc45_ids->device_ids[i] = (phy_reg & 0xffff) << 16;\r\nreg_addr = MII_ADDR_C45 | i << 16 | MII_PHYSID2;\r\nphy_reg = mdiobus_read(bus, addr, reg_addr);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\nc45_ids->device_ids[i] |= (phy_reg & 0xffff);\r\n}\r\n*phy_id = 0;\r\nreturn 0;\r\n}\r\nstatic int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id,\r\nbool is_c45, struct phy_c45_device_ids *c45_ids)\r\n{\r\nint phy_reg;\r\nif (is_c45)\r\nreturn get_phy_c45_ids(bus, addr, phy_id, c45_ids);\r\nphy_reg = mdiobus_read(bus, addr, MII_PHYSID1);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\n*phy_id = (phy_reg & 0xffff) << 16;\r\nphy_reg = mdiobus_read(bus, addr, MII_PHYSID2);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\n*phy_id |= (phy_reg & 0xffff);\r\nreturn 0;\r\n}\r\nstruct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45)\r\n{\r\nstruct phy_c45_device_ids c45_ids = {0};\r\nu32 phy_id = 0;\r\nint r;\r\nr = get_phy_id(bus, addr, &phy_id, is_c45, &c45_ids);\r\nif (r)\r\nreturn ERR_PTR(r);\r\nif ((phy_id & 0x1fffffff) == 0x1fffffff)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn phy_device_create(bus, addr, phy_id, is_c45, &c45_ids);\r\n}\r\nstatic ssize_t\r\nphy_id_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nreturn sprintf(buf, "0x%.8lx\n", (unsigned long)phydev->phy_id);\r\n}\r\nstatic ssize_t\r\nphy_interface_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nconst char *mode = NULL;\r\nif (phy_is_internal(phydev))\r\nmode = "internal";\r\nelse\r\nmode = phy_modes(phydev->interface);\r\nreturn sprintf(buf, "%s\n", mode);\r\n}\r\nstatic ssize_t\r\nphy_has_fixups_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nreturn sprintf(buf, "%d\n", phydev->has_fixups);\r\n}\r\nint phy_device_register(struct phy_device *phydev)\r\n{\r\nint err;\r\nerr = mdiobus_register_device(&phydev->mdio);\r\nif (err)\r\nreturn err;\r\nerr = phy_scan_fixups(phydev);\r\nif (err) {\r\npr_err("PHY %d failed to initialize\n", phydev->mdio.addr);\r\ngoto out;\r\n}\r\nphydev->mdio.dev.groups = phy_dev_groups;\r\nerr = device_add(&phydev->mdio.dev);\r\nif (err) {\r\npr_err("PHY %d failed to add\n", phydev->mdio.addr);\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nmdiobus_unregister_device(&phydev->mdio);\r\nreturn err;\r\n}\r\nvoid phy_device_remove(struct phy_device *phydev)\r\n{\r\ndevice_del(&phydev->mdio.dev);\r\nmdiobus_unregister_device(&phydev->mdio);\r\n}\r\nstruct phy_device *phy_find_first(struct mii_bus *bus)\r\n{\r\nstruct phy_device *phydev;\r\nint addr;\r\nfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\r\nphydev = mdiobus_get_phy(bus, addr);\r\nif (phydev)\r\nreturn phydev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void phy_prepare_link(struct phy_device *phydev,\r\nvoid (*handler)(struct net_device *))\r\n{\r\nphydev->adjust_link = handler;\r\n}\r\nint phy_connect_direct(struct net_device *dev, struct phy_device *phydev,\r\nvoid (*handler)(struct net_device *),\r\nphy_interface_t interface)\r\n{\r\nint rc;\r\nrc = phy_attach_direct(dev, phydev, phydev->dev_flags, interface);\r\nif (rc)\r\nreturn rc;\r\nphy_prepare_link(phydev, handler);\r\nphy_start_machine(phydev);\r\nif (phydev->irq > 0)\r\nphy_start_interrupts(phydev);\r\nreturn 0;\r\n}\r\nstruct phy_device *phy_connect(struct net_device *dev, const char *bus_id,\r\nvoid (*handler)(struct net_device *),\r\nphy_interface_t interface)\r\n{\r\nstruct phy_device *phydev;\r\nstruct device *d;\r\nint rc;\r\nd = bus_find_device_by_name(&mdio_bus_type, NULL, bus_id);\r\nif (!d) {\r\npr_err("PHY %s not found\n", bus_id);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nphydev = to_phy_device(d);\r\nrc = phy_connect_direct(dev, phydev, handler, interface);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn phydev;\r\n}\r\nvoid phy_disconnect(struct phy_device *phydev)\r\n{\r\nif (phydev->irq > 0)\r\nphy_stop_interrupts(phydev);\r\nphy_stop_machine(phydev);\r\nphydev->adjust_link = NULL;\r\nphy_detach(phydev);\r\n}\r\nstatic int phy_poll_reset(struct phy_device *phydev)\r\n{\r\nunsigned int retries = 12;\r\nint ret;\r\ndo {\r\nmsleep(50);\r\nret = phy_read(phydev, MII_BMCR);\r\nif (ret < 0)\r\nreturn ret;\r\n} while (ret & BMCR_RESET && --retries);\r\nif (ret & BMCR_RESET)\r\nreturn -ETIMEDOUT;\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nint phy_init_hw(struct phy_device *phydev)\r\n{\r\nint ret = 0;\r\nif (!phydev->drv || !phydev->drv->config_init)\r\nreturn 0;\r\nif (phydev->drv->soft_reset)\r\nret = phydev->drv->soft_reset(phydev);\r\nelse\r\nret = genphy_soft_reset(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = phy_scan_fixups(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn phydev->drv->config_init(phydev);\r\n}\r\nvoid phy_attached_info(struct phy_device *phydev)\r\n{\r\nphy_attached_print(phydev, NULL);\r\n}\r\nvoid phy_attached_print(struct phy_device *phydev, const char *fmt, ...)\r\n{\r\nif (!fmt) {\r\ndev_info(&phydev->mdio.dev, ATTACHED_FMT "\n",\r\nphydev->drv->name, phydev_name(phydev),\r\nphydev->irq);\r\n} else {\r\nva_list ap;\r\ndev_info(&phydev->mdio.dev, ATTACHED_FMT,\r\nphydev->drv->name, phydev_name(phydev),\r\nphydev->irq);\r\nva_start(ap, fmt);\r\nvprintk(fmt, ap);\r\nva_end(ap);\r\n}\r\n}\r\nint phy_attach_direct(struct net_device *dev, struct phy_device *phydev,\r\nu32 flags, phy_interface_t interface)\r\n{\r\nstruct mii_bus *bus = phydev->mdio.bus;\r\nstruct device *d = &phydev->mdio.dev;\r\nint err;\r\nif (!try_module_get(bus->owner)) {\r\ndev_err(&dev->dev, "failed to get the bus module\n");\r\nreturn -EIO;\r\n}\r\nget_device(d);\r\nif (!d->driver) {\r\nif (phydev->is_c45)\r\nd->driver =\r\n&genphy_driver[GENPHY_DRV_10G].mdiodrv.driver;\r\nelse\r\nd->driver =\r\n&genphy_driver[GENPHY_DRV_1G].mdiodrv.driver;\r\nerr = d->driver->probe(d);\r\nif (err >= 0)\r\nerr = device_bind_driver(d);\r\nif (err)\r\ngoto error;\r\n}\r\nif (phydev->attached_dev) {\r\ndev_err(&dev->dev, "PHY already attached\n");\r\nerr = -EBUSY;\r\ngoto error;\r\n}\r\nphydev->attached_dev = dev;\r\ndev->phydev = phydev;\r\nphydev->dev_flags = flags;\r\nphydev->interface = interface;\r\nphydev->state = PHY_READY;\r\nnetif_carrier_off(phydev->attached_dev);\r\nerr = phy_init_hw(phydev);\r\nif (err)\r\nphy_detach(phydev);\r\nelse\r\nphy_resume(phydev);\r\nreturn err;\r\nerror:\r\nput_device(d);\r\nmodule_put(bus->owner);\r\nreturn err;\r\n}\r\nstruct phy_device *phy_attach(struct net_device *dev, const char *bus_id,\r\nphy_interface_t interface)\r\n{\r\nstruct bus_type *bus = &mdio_bus_type;\r\nstruct phy_device *phydev;\r\nstruct device *d;\r\nint rc;\r\nd = bus_find_device_by_name(bus, NULL, bus_id);\r\nif (!d) {\r\npr_err("PHY %s not found\n", bus_id);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nphydev = to_phy_device(d);\r\nrc = phy_attach_direct(dev, phydev, phydev->dev_flags, interface);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn phydev;\r\n}\r\nvoid phy_detach(struct phy_device *phydev)\r\n{\r\nstruct mii_bus *bus;\r\nint i;\r\nphydev->attached_dev->phydev = NULL;\r\nphydev->attached_dev = NULL;\r\nphy_suspend(phydev);\r\nfor (i = 0; i < ARRAY_SIZE(genphy_driver); i++) {\r\nif (phydev->mdio.dev.driver ==\r\n&genphy_driver[i].mdiodrv.driver) {\r\ndevice_release_driver(&phydev->mdio.dev);\r\nbreak;\r\n}\r\n}\r\nbus = phydev->mdio.bus;\r\nput_device(&phydev->mdio.dev);\r\nmodule_put(bus->owner);\r\n}\r\nint phy_suspend(struct phy_device *phydev)\r\n{\r\nstruct phy_driver *phydrv = to_phy_driver(phydev->mdio.dev.driver);\r\nstruct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };\r\nint ret = 0;\r\nphy_ethtool_get_wol(phydev, &wol);\r\nif (wol.wolopts)\r\nreturn -EBUSY;\r\nif (phydrv->suspend)\r\nret = phydrv->suspend(phydev);\r\nif (ret)\r\nreturn ret;\r\nphydev->suspended = true;\r\nreturn ret;\r\n}\r\nint phy_resume(struct phy_device *phydev)\r\n{\r\nstruct phy_driver *phydrv = to_phy_driver(phydev->mdio.dev.driver);\r\nint ret = 0;\r\nif (phydrv->resume)\r\nret = phydrv->resume(phydev);\r\nif (ret)\r\nreturn ret;\r\nphydev->suspended = false;\r\nreturn ret;\r\n}\r\nstatic int genphy_config_advert(struct phy_device *phydev)\r\n{\r\nu32 advertise;\r\nint oldadv, adv, bmsr;\r\nint err, changed = 0;\r\nphydev->advertising &= phydev->supported;\r\nadvertise = phydev->advertising;\r\nadv = phy_read(phydev, MII_ADVERTISE);\r\nif (adv < 0)\r\nreturn adv;\r\noldadv = adv;\r\nadv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4 | ADVERTISE_PAUSE_CAP |\r\nADVERTISE_PAUSE_ASYM);\r\nadv |= ethtool_adv_to_mii_adv_t(advertise);\r\nif (adv != oldadv) {\r\nerr = phy_write(phydev, MII_ADVERTISE, adv);\r\nif (err < 0)\r\nreturn err;\r\nchanged = 1;\r\n}\r\nbmsr = phy_read(phydev, MII_BMSR);\r\nif (bmsr < 0)\r\nreturn bmsr;\r\nif (!(bmsr & BMSR_ESTATEN))\r\nreturn changed;\r\nadv = phy_read(phydev, MII_CTRL1000);\r\nif (adv < 0)\r\nreturn adv;\r\noldadv = adv;\r\nadv &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);\r\nif (phydev->supported & (SUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full)) {\r\nadv |= ethtool_adv_to_mii_ctrl1000_t(advertise);\r\n}\r\nif (adv != oldadv)\r\nchanged = 1;\r\nerr = phy_write(phydev, MII_CTRL1000, adv);\r\nif (err < 0)\r\nreturn err;\r\nreturn changed;\r\n}\r\nint genphy_setup_forced(struct phy_device *phydev)\r\n{\r\nint ctl = phy_read(phydev, MII_BMCR);\r\nctl &= BMCR_LOOPBACK | BMCR_ISOLATE | BMCR_PDOWN;\r\nphydev->pause = 0;\r\nphydev->asym_pause = 0;\r\nif (SPEED_1000 == phydev->speed)\r\nctl |= BMCR_SPEED1000;\r\nelse if (SPEED_100 == phydev->speed)\r\nctl |= BMCR_SPEED100;\r\nif (DUPLEX_FULL == phydev->duplex)\r\nctl |= BMCR_FULLDPLX;\r\nreturn phy_write(phydev, MII_BMCR, ctl);\r\n}\r\nint genphy_restart_aneg(struct phy_device *phydev)\r\n{\r\nint ctl = phy_read(phydev, MII_BMCR);\r\nif (ctl < 0)\r\nreturn ctl;\r\nctl |= BMCR_ANENABLE | BMCR_ANRESTART;\r\nctl &= ~BMCR_ISOLATE;\r\nreturn phy_write(phydev, MII_BMCR, ctl);\r\n}\r\nint genphy_config_aneg(struct phy_device *phydev)\r\n{\r\nint result;\r\nif (AUTONEG_ENABLE != phydev->autoneg)\r\nreturn genphy_setup_forced(phydev);\r\nresult = genphy_config_advert(phydev);\r\nif (result < 0)\r\nreturn result;\r\nif (result == 0) {\r\nint ctl = phy_read(phydev, MII_BMCR);\r\nif (ctl < 0)\r\nreturn ctl;\r\nif (!(ctl & BMCR_ANENABLE) || (ctl & BMCR_ISOLATE))\r\nresult = 1;\r\n}\r\nif (result > 0)\r\nresult = genphy_restart_aneg(phydev);\r\nreturn result;\r\n}\r\nint genphy_aneg_done(struct phy_device *phydev)\r\n{\r\nint retval = phy_read(phydev, MII_BMSR);\r\nreturn (retval < 0) ? retval : (retval & BMSR_ANEGCOMPLETE);\r\n}\r\nstatic int gen10g_config_aneg(struct phy_device *phydev)\r\n{\r\nreturn 0;\r\n}\r\nint genphy_update_link(struct phy_device *phydev)\r\n{\r\nint status;\r\nstatus = phy_read(phydev, MII_BMSR);\r\nif (status < 0)\r\nreturn status;\r\nstatus = phy_read(phydev, MII_BMSR);\r\nif (status < 0)\r\nreturn status;\r\nif ((status & BMSR_LSTATUS) == 0)\r\nphydev->link = 0;\r\nelse\r\nphydev->link = 1;\r\nreturn 0;\r\n}\r\nint genphy_read_status(struct phy_device *phydev)\r\n{\r\nint adv;\r\nint err;\r\nint lpa;\r\nint lpagb = 0;\r\nint common_adv;\r\nint common_adv_gb = 0;\r\nerr = genphy_update_link(phydev);\r\nif (err)\r\nreturn err;\r\nphydev->lp_advertising = 0;\r\nif (AUTONEG_ENABLE == phydev->autoneg) {\r\nif (phydev->supported & (SUPPORTED_1000baseT_Half\r\n| SUPPORTED_1000baseT_Full)) {\r\nlpagb = phy_read(phydev, MII_STAT1000);\r\nif (lpagb < 0)\r\nreturn lpagb;\r\nadv = phy_read(phydev, MII_CTRL1000);\r\nif (adv < 0)\r\nreturn adv;\r\nphydev->lp_advertising =\r\nmii_stat1000_to_ethtool_lpa_t(lpagb);\r\ncommon_adv_gb = lpagb & adv << 2;\r\n}\r\nlpa = phy_read(phydev, MII_LPA);\r\nif (lpa < 0)\r\nreturn lpa;\r\nphydev->lp_advertising |= mii_lpa_to_ethtool_lpa_t(lpa);\r\nadv = phy_read(phydev, MII_ADVERTISE);\r\nif (adv < 0)\r\nreturn adv;\r\ncommon_adv = lpa & adv;\r\nphydev->speed = SPEED_10;\r\nphydev->duplex = DUPLEX_HALF;\r\nphydev->pause = 0;\r\nphydev->asym_pause = 0;\r\nif (common_adv_gb & (LPA_1000FULL | LPA_1000HALF)) {\r\nphydev->speed = SPEED_1000;\r\nif (common_adv_gb & LPA_1000FULL)\r\nphydev->duplex = DUPLEX_FULL;\r\n} else if (common_adv & (LPA_100FULL | LPA_100HALF)) {\r\nphydev->speed = SPEED_100;\r\nif (common_adv & LPA_100FULL)\r\nphydev->duplex = DUPLEX_FULL;\r\n} else\r\nif (common_adv & LPA_10FULL)\r\nphydev->duplex = DUPLEX_FULL;\r\nif (phydev->duplex == DUPLEX_FULL) {\r\nphydev->pause = lpa & LPA_PAUSE_CAP ? 1 : 0;\r\nphydev->asym_pause = lpa & LPA_PAUSE_ASYM ? 1 : 0;\r\n}\r\n} else {\r\nint bmcr = phy_read(phydev, MII_BMCR);\r\nif (bmcr < 0)\r\nreturn bmcr;\r\nif (bmcr & BMCR_FULLDPLX)\r\nphydev->duplex = DUPLEX_FULL;\r\nelse\r\nphydev->duplex = DUPLEX_HALF;\r\nif (bmcr & BMCR_SPEED1000)\r\nphydev->speed = SPEED_1000;\r\nelse if (bmcr & BMCR_SPEED100)\r\nphydev->speed = SPEED_100;\r\nelse\r\nphydev->speed = SPEED_10;\r\nphydev->pause = 0;\r\nphydev->asym_pause = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gen10g_read_status(struct phy_device *phydev)\r\n{\r\nint devad, reg;\r\nu32 mmd_mask = phydev->c45_ids.devices_in_package;\r\nphydev->link = 1;\r\nphydev->speed = SPEED_10000;\r\nphydev->duplex = DUPLEX_FULL;\r\nfor (devad = 0; mmd_mask; devad++, mmd_mask = mmd_mask >> 1) {\r\nif (!(mmd_mask & 1))\r\ncontinue;\r\nphy_read_mmd(phydev, devad, MDIO_STAT1);\r\nreg = phy_read_mmd(phydev, devad, MDIO_STAT1);\r\nif (reg < 0 || !(reg & MDIO_STAT1_LSTATUS))\r\nphydev->link = 0;\r\n}\r\nreturn 0;\r\n}\r\nint genphy_soft_reset(struct phy_device *phydev)\r\n{\r\nint ret;\r\nret = phy_write(phydev, MII_BMCR, BMCR_RESET);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn phy_poll_reset(phydev);\r\n}\r\nint genphy_config_init(struct phy_device *phydev)\r\n{\r\nint val;\r\nu32 features;\r\nfeatures = (SUPPORTED_TP | SUPPORTED_MII\r\n| SUPPORTED_AUI | SUPPORTED_FIBRE |\r\nSUPPORTED_BNC | SUPPORTED_Pause | SUPPORTED_Asym_Pause);\r\nval = phy_read(phydev, MII_BMSR);\r\nif (val < 0)\r\nreturn val;\r\nif (val & BMSR_ANEGCAPABLE)\r\nfeatures |= SUPPORTED_Autoneg;\r\nif (val & BMSR_100FULL)\r\nfeatures |= SUPPORTED_100baseT_Full;\r\nif (val & BMSR_100HALF)\r\nfeatures |= SUPPORTED_100baseT_Half;\r\nif (val & BMSR_10FULL)\r\nfeatures |= SUPPORTED_10baseT_Full;\r\nif (val & BMSR_10HALF)\r\nfeatures |= SUPPORTED_10baseT_Half;\r\nif (val & BMSR_ESTATEN) {\r\nval = phy_read(phydev, MII_ESTATUS);\r\nif (val < 0)\r\nreturn val;\r\nif (val & ESTATUS_1000_TFULL)\r\nfeatures |= SUPPORTED_1000baseT_Full;\r\nif (val & ESTATUS_1000_THALF)\r\nfeatures |= SUPPORTED_1000baseT_Half;\r\n}\r\nphydev->supported &= features;\r\nphydev->advertising &= features;\r\nreturn 0;\r\n}\r\nstatic int gen10g_soft_reset(struct phy_device *phydev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gen10g_config_init(struct phy_device *phydev)\r\n{\r\nphydev->supported = SUPPORTED_10000baseT_Full;\r\nphydev->advertising = SUPPORTED_10000baseT_Full;\r\nreturn 0;\r\n}\r\nint genphy_suspend(struct phy_device *phydev)\r\n{\r\nint value;\r\nmutex_lock(&phydev->lock);\r\nvalue = phy_read(phydev, MII_BMCR);\r\nphy_write(phydev, MII_BMCR, value | BMCR_PDOWN);\r\nmutex_unlock(&phydev->lock);\r\nreturn 0;\r\n}\r\nstatic int gen10g_suspend(struct phy_device *phydev)\r\n{\r\nreturn 0;\r\n}\r\nint genphy_resume(struct phy_device *phydev)\r\n{\r\nint value;\r\nmutex_lock(&phydev->lock);\r\nvalue = phy_read(phydev, MII_BMCR);\r\nphy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);\r\nmutex_unlock(&phydev->lock);\r\nreturn 0;\r\n}\r\nstatic int gen10g_resume(struct phy_device *phydev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __set_phy_supported(struct phy_device *phydev, u32 max_speed)\r\n{\r\nphydev->supported &= PHY_DEFAULT_FEATURES;\r\nswitch (max_speed) {\r\ndefault:\r\nreturn -ENOTSUPP;\r\ncase SPEED_1000:\r\nphydev->supported |= PHY_1000BT_FEATURES;\r\ncase SPEED_100:\r\nphydev->supported |= PHY_100BT_FEATURES;\r\ncase SPEED_10:\r\nphydev->supported |= PHY_10BT_FEATURES;\r\n}\r\nreturn 0;\r\n}\r\nint phy_set_max_speed(struct phy_device *phydev, u32 max_speed)\r\n{\r\nint err;\r\nerr = __set_phy_supported(phydev, max_speed);\r\nif (err)\r\nreturn err;\r\nphydev->advertising = phydev->supported;\r\nreturn 0;\r\n}\r\nstatic void of_set_phy_supported(struct phy_device *phydev)\r\n{\r\nstruct device_node *node = phydev->mdio.dev.of_node;\r\nu32 max_speed;\r\nif (!IS_ENABLED(CONFIG_OF_MDIO))\r\nreturn;\r\nif (!node)\r\nreturn;\r\nif (!of_property_read_u32(node, "max-speed", &max_speed))\r\n__set_phy_supported(phydev, max_speed);\r\n}\r\nstatic int phy_probe(struct device *dev)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nstruct device_driver *drv = phydev->mdio.dev.driver;\r\nstruct phy_driver *phydrv = to_phy_driver(drv);\r\nint err = 0;\r\nphydev->drv = phydrv;\r\nif (!(phydrv->flags & PHY_HAS_INTERRUPT) &&\r\nphy_interrupt_is_valid(phydev))\r\nphydev->irq = PHY_POLL;\r\nif (phydrv->flags & PHY_IS_INTERNAL)\r\nphydev->is_internal = true;\r\nmutex_lock(&phydev->lock);\r\nphydev->supported = phydrv->features;\r\nof_set_phy_supported(phydev);\r\nphydev->advertising = phydev->supported;\r\nphydev->state = PHY_READY;\r\nif (phydev->drv->probe)\r\nerr = phydev->drv->probe(phydev);\r\nmutex_unlock(&phydev->lock);\r\nreturn err;\r\n}\r\nstatic int phy_remove(struct device *dev)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nmutex_lock(&phydev->lock);\r\nphydev->state = PHY_DOWN;\r\nmutex_unlock(&phydev->lock);\r\nif (phydev->drv->remove)\r\nphydev->drv->remove(phydev);\r\nphydev->drv = NULL;\r\nreturn 0;\r\n}\r\nint phy_driver_register(struct phy_driver *new_driver, struct module *owner)\r\n{\r\nint retval;\r\nnew_driver->mdiodrv.flags |= MDIO_DEVICE_IS_PHY;\r\nnew_driver->mdiodrv.driver.name = new_driver->name;\r\nnew_driver->mdiodrv.driver.bus = &mdio_bus_type;\r\nnew_driver->mdiodrv.driver.probe = phy_probe;\r\nnew_driver->mdiodrv.driver.remove = phy_remove;\r\nnew_driver->mdiodrv.driver.owner = owner;\r\nretval = driver_register(&new_driver->mdiodrv.driver);\r\nif (retval) {\r\npr_err("%s: Error %d in registering driver\n",\r\nnew_driver->name, retval);\r\nreturn retval;\r\n}\r\npr_debug("%s: Registered new driver\n", new_driver->name);\r\nreturn 0;\r\n}\r\nint phy_drivers_register(struct phy_driver *new_driver, int n,\r\nstruct module *owner)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < n; i++) {\r\nret = phy_driver_register(new_driver + i, owner);\r\nif (ret) {\r\nwhile (i-- > 0)\r\nphy_driver_unregister(new_driver + i);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid phy_driver_unregister(struct phy_driver *drv)\r\n{\r\ndriver_unregister(&drv->mdiodrv.driver);\r\n}\r\nvoid phy_drivers_unregister(struct phy_driver *drv, int n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++)\r\nphy_driver_unregister(drv + i);\r\n}\r\nstatic int __init phy_init(void)\r\n{\r\nint rc;\r\nrc = mdio_bus_init();\r\nif (rc)\r\nreturn rc;\r\nrc = phy_drivers_register(genphy_driver,\r\nARRAY_SIZE(genphy_driver), THIS_MODULE);\r\nif (rc)\r\nmdio_bus_exit();\r\nreturn rc;\r\n}\r\nstatic void __exit phy_exit(void)\r\n{\r\nphy_drivers_unregister(genphy_driver,\r\nARRAY_SIZE(genphy_driver));\r\nmdio_bus_exit();\r\n}
