static int\r\nqtd_fill(struct ehci_hcd *ehci, struct ehci_qtd *qtd, dma_addr_t buf,\r\nsize_t len, int token, int maxpacket)\r\n{\r\nint i, count;\r\nu64 addr = buf;\r\nqtd->hw_buf[0] = cpu_to_hc32(ehci, (u32)addr);\r\nqtd->hw_buf_hi[0] = cpu_to_hc32(ehci, (u32)(addr >> 32));\r\ncount = 0x1000 - (buf & 0x0fff);\r\nif (likely (len < count))\r\ncount = len;\r\nelse {\r\nbuf += 0x1000;\r\nbuf &= ~0x0fff;\r\nfor (i = 1; count < len && i < 5; i++) {\r\naddr = buf;\r\nqtd->hw_buf[i] = cpu_to_hc32(ehci, (u32)addr);\r\nqtd->hw_buf_hi[i] = cpu_to_hc32(ehci,\r\n(u32)(addr >> 32));\r\nbuf += 0x1000;\r\nif ((count + 0x1000) < len)\r\ncount += 0x1000;\r\nelse\r\ncount = len;\r\n}\r\nif (count != len)\r\ncount -= (count % maxpacket);\r\n}\r\nqtd->hw_token = cpu_to_hc32(ehci, (count << 16) | token);\r\nqtd->length = count;\r\nreturn count;\r\n}\r\nstatic inline void\r\nqh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)\r\n{\r\nstruct ehci_qh_hw *hw = qh->hw;\r\nWARN_ON(qh->qh_state != QH_STATE_IDLE);\r\nhw->hw_qtd_next = QTD_NEXT(ehci, qtd->qtd_dma);\r\nhw->hw_alt_next = EHCI_LIST_END(ehci);\r\nif (!(hw->hw_info1 & cpu_to_hc32(ehci, QH_TOGGLE_CTL))) {\r\nunsigned is_out, epnum;\r\nis_out = qh->is_out;\r\nepnum = (hc32_to_cpup(ehci, &hw->hw_info1) >> 8) & 0x0f;\r\nif (unlikely(!usb_gettoggle(qh->ps.udev, epnum, is_out))) {\r\nhw->hw_token &= ~cpu_to_hc32(ehci, QTD_TOGGLE);\r\nusb_settoggle(qh->ps.udev, epnum, is_out, 1);\r\n}\r\n}\r\nhw->hw_token &= cpu_to_hc32(ehci, QTD_TOGGLE | QTD_STS_PING);\r\n}\r\nstatic void\r\nqh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nstruct ehci_qtd *qtd;\r\nqtd = list_entry(qh->qtd_list.next, struct ehci_qtd, qtd_list);\r\nif (qh->hw->hw_token & ACTIVE_BIT(ehci)) {\r\nqh->hw->hw_qtd_next = qtd->hw_next;\r\nif (qh->should_be_inactive)\r\nehci_warn(ehci, "qh %p should be inactive!\n", qh);\r\n} else {\r\nqh_update(ehci, qh, qtd);\r\n}\r\nqh->should_be_inactive = 0;\r\n}\r\nstatic void ehci_clear_tt_buffer_complete(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct ehci_qh *qh = ep->hcpriv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nqh->clearing_tt = 0;\r\nif (qh->qh_state == QH_STATE_IDLE && !list_empty(&qh->qtd_list)\r\n&& ehci->rh_state == EHCI_RH_RUNNING)\r\nqh_link_async(ehci, qh);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\n}\r\nstatic void ehci_clear_tt_buffer(struct ehci_hcd *ehci, struct ehci_qh *qh,\r\nstruct urb *urb, u32 token)\r\n{\r\nif (urb->dev->tt && !usb_pipeint(urb->pipe) && !qh->clearing_tt) {\r\n#ifdef CONFIG_DYNAMIC_DEBUG\r\nstruct usb_device *tt = urb->dev->tt->hub;\r\ndev_dbg(&tt->dev,\r\n"clear tt buffer port %d, a%d ep%d t%08x\n",\r\nurb->dev->ttport, urb->dev->devnum,\r\nusb_pipeendpoint(urb->pipe), token);\r\n#endif\r\nif (!ehci_is_TDI(ehci)\r\n|| urb->dev->tt->hub !=\r\nehci_to_hcd(ehci)->self.root_hub) {\r\nif (usb_hub_clear_tt_buffer(urb) == 0)\r\nqh->clearing_tt = 1;\r\n} else {\r\n}\r\n}\r\n}\r\nstatic int qtd_copy_status (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nsize_t length,\r\nu32 token\r\n)\r\n{\r\nint status = -EINPROGRESS;\r\nif (likely (QTD_PID (token) != 2))\r\nurb->actual_length += length - QTD_LENGTH (token);\r\nif (unlikely(urb->unlinked))\r\nreturn status;\r\nif (unlikely (IS_SHORT_READ (token)))\r\nstatus = -EREMOTEIO;\r\nif (token & QTD_STS_HALT) {\r\nif (token & QTD_STS_BABBLE) {\r\nstatus = -EOVERFLOW;\r\n} else if (QTD_CERR(token)) {\r\nstatus = -EPIPE;\r\n} else if (token & QTD_STS_MMF) {\r\nstatus = -EPROTO;\r\n} else if (token & QTD_STS_DBE) {\r\nstatus = (QTD_PID (token) == 1)\r\n? -ENOSR\r\n: -ECOMM;\r\n} else if (token & QTD_STS_XACT) {\r\nehci_dbg(ehci, "devpath %s ep%d%s 3strikes\n",\r\nurb->dev->devpath,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out");\r\nstatus = -EPROTO;\r\n} else {\r\nstatus = -EPROTO;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void\r\nehci_urb_done(struct ehci_hcd *ehci, struct urb *urb, int status)\r\n{\r\nif (usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {\r\nehci_to_hcd(ehci)->self.bandwidth_int_reqs--;\r\n}\r\nif (unlikely(urb->unlinked)) {\r\nCOUNT(ehci->stats.unlink);\r\n} else {\r\nif (status == -EINPROGRESS || status == -EREMOTEIO)\r\nstatus = 0;\r\nCOUNT(ehci->stats.complete);\r\n}\r\n#ifdef EHCI_URB_TRACE\r\nehci_dbg (ehci,\r\n"%s %s urb %p ep%d%s status %d len %d/%d\n",\r\n__func__, urb->dev->devpath, urb,\r\nusb_pipeendpoint (urb->pipe),\r\nusb_pipein (urb->pipe) ? "in" : "out",\r\nstatus,\r\nurb->actual_length, urb->transfer_buffer_length);\r\n#endif\r\nusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\r\nusb_hcd_giveback_urb(ehci_to_hcd(ehci), urb, status);\r\n}\r\nstatic unsigned\r\nqh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nstruct ehci_qtd *last, *end = qh->dummy;\r\nstruct list_head *entry, *tmp;\r\nint last_status;\r\nint stopped;\r\nu8 state;\r\nstruct ehci_qh_hw *hw = qh->hw;\r\nstate = qh->qh_state;\r\nqh->qh_state = QH_STATE_COMPLETING;\r\nstopped = (state == QH_STATE_IDLE);\r\nrescan:\r\nlast = NULL;\r\nlast_status = -EINPROGRESS;\r\nqh->dequeue_during_giveback = 0;\r\nlist_for_each_safe (entry, tmp, &qh->qtd_list) {\r\nstruct ehci_qtd *qtd;\r\nstruct urb *urb;\r\nu32 token = 0;\r\nqtd = list_entry (entry, struct ehci_qtd, qtd_list);\r\nurb = qtd->urb;\r\nif (last) {\r\nif (likely (last->urb != urb)) {\r\nehci_urb_done(ehci, last->urb, last_status);\r\nlast_status = -EINPROGRESS;\r\n}\r\nehci_qtd_free (ehci, last);\r\nlast = NULL;\r\n}\r\nif (qtd == end)\r\nbreak;\r\nrmb ();\r\ntoken = hc32_to_cpu(ehci, qtd->hw_token);\r\nretry_xacterr:\r\nif ((token & QTD_STS_ACTIVE) == 0) {\r\nif (token & QTD_STS_DBE)\r\nehci_dbg(ehci,\r\n"detected DataBufferErr for urb %p ep%d%s len %d, qtd %p [qh %p]\n",\r\nurb,\r\nusb_endpoint_num(&urb->ep->desc),\r\nusb_endpoint_dir_in(&urb->ep->desc) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nqtd,\r\nqh);\r\nif ((token & QTD_STS_HALT) != 0) {\r\nif ((token & QTD_STS_XACT) &&\r\nQTD_CERR(token) == 0 &&\r\n++qh->xacterrs < QH_XACTERR_MAX &&\r\n!urb->unlinked) {\r\nehci_dbg(ehci,\r\n"detected XactErr len %zu/%zu retry %d\n",\r\nqtd->length - QTD_LENGTH(token), qtd->length, qh->xacterrs);\r\ntoken &= ~QTD_STS_HALT;\r\ntoken |= QTD_STS_ACTIVE |\r\n(EHCI_TUNE_CERR << 10);\r\nqtd->hw_token = cpu_to_hc32(ehci,\r\ntoken);\r\nwmb();\r\nhw->hw_token = cpu_to_hc32(ehci,\r\ntoken);\r\ngoto retry_xacterr;\r\n}\r\nstopped = 1;\r\nqh->unlink_reason |= QH_UNLINK_HALTED;\r\n} else if (IS_SHORT_READ (token)\r\n&& !(qtd->hw_alt_next\r\n& EHCI_LIST_END(ehci))) {\r\nstopped = 1;\r\nqh->unlink_reason |= QH_UNLINK_SHORT_READ;\r\n}\r\n} else if (likely (!stopped\r\n&& ehci->rh_state >= EHCI_RH_RUNNING)) {\r\nbreak;\r\n} else {\r\nstopped = 1;\r\nif (ehci->rh_state < EHCI_RH_RUNNING) {\r\nlast_status = -ESHUTDOWN;\r\nqh->unlink_reason |= QH_UNLINK_SHUTDOWN;\r\n}\r\nelse if (last_status == -EINPROGRESS && !urb->unlinked)\r\ncontinue;\r\nif (state == QH_STATE_IDLE &&\r\nqh->qtd_list.next == &qtd->qtd_list &&\r\n(hw->hw_token & ACTIVE_BIT(ehci))) {\r\ntoken = hc32_to_cpu(ehci, hw->hw_token);\r\nhw->hw_token &= ~ACTIVE_BIT(ehci);\r\nqh->should_be_inactive = 1;\r\nehci_clear_tt_buffer(ehci, qh, urb, token);\r\n}\r\n}\r\nif (last_status == -EINPROGRESS) {\r\nlast_status = qtd_copy_status(ehci, urb,\r\nqtd->length, token);\r\nif (last_status == -EREMOTEIO\r\n&& (qtd->hw_alt_next\r\n& EHCI_LIST_END(ehci)))\r\nlast_status = -EINPROGRESS;\r\nif (unlikely(last_status != -EINPROGRESS &&\r\nlast_status != -EREMOTEIO)) {\r\nif (last_status != -EPIPE)\r\nehci_clear_tt_buffer(ehci, qh, urb,\r\ntoken);\r\n}\r\n}\r\nif (stopped && qtd->qtd_list.prev != &qh->qtd_list) {\r\nlast = list_entry (qtd->qtd_list.prev,\r\nstruct ehci_qtd, qtd_list);\r\nlast->hw_next = qtd->hw_next;\r\n}\r\nlist_del (&qtd->qtd_list);\r\nlast = qtd;\r\nqh->xacterrs = 0;\r\n}\r\nif (likely (last != NULL)) {\r\nehci_urb_done(ehci, last->urb, last_status);\r\nehci_qtd_free (ehci, last);\r\n}\r\nif (unlikely(qh->dequeue_during_giveback)) {\r\nif (state == QH_STATE_IDLE)\r\ngoto rescan;\r\n}\r\nqh->qh_state = state;\r\nif (stopped != 0 || hw->hw_qtd_next == EHCI_LIST_END(ehci))\r\nqh->unlink_reason |= QH_UNLINK_DUMMY_OVERLAY;\r\nreturn qh->unlink_reason;\r\n}\r\nstatic void qtd_list_free (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list\r\n) {\r\nstruct list_head *entry, *temp;\r\nlist_for_each_safe (entry, temp, qtd_list) {\r\nstruct ehci_qtd *qtd;\r\nqtd = list_entry (entry, struct ehci_qtd, qtd_list);\r\nlist_del (&qtd->qtd_list);\r\nehci_qtd_free (ehci, qtd);\r\n}\r\n}\r\nstatic struct list_head *\r\nqh_urb_transaction (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct list_head *head,\r\ngfp_t flags\r\n) {\r\nstruct ehci_qtd *qtd, *qtd_prev;\r\ndma_addr_t buf;\r\nint len, this_sg_len, maxpacket;\r\nint is_input;\r\nu32 token;\r\nint i;\r\nstruct scatterlist *sg;\r\nqtd = ehci_qtd_alloc (ehci, flags);\r\nif (unlikely (!qtd))\r\nreturn NULL;\r\nlist_add_tail (&qtd->qtd_list, head);\r\nqtd->urb = urb;\r\ntoken = QTD_STS_ACTIVE;\r\ntoken |= (EHCI_TUNE_CERR << 10);\r\nlen = urb->transfer_buffer_length;\r\nis_input = usb_pipein (urb->pipe);\r\nif (usb_pipecontrol (urb->pipe)) {\r\nqtd_fill(ehci, qtd, urb->setup_dma,\r\nsizeof (struct usb_ctrlrequest),\r\ntoken | (2 << 8), 8);\r\ntoken ^= QTD_TOGGLE;\r\nqtd_prev = qtd;\r\nqtd = ehci_qtd_alloc (ehci, flags);\r\nif (unlikely (!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\r\nlist_add_tail (&qtd->qtd_list, head);\r\nif (len == 0)\r\ntoken |= (1 << 8);\r\n}\r\ni = urb->num_mapped_sgs;\r\nif (len > 0 && i > 0) {\r\nsg = urb->sg;\r\nbuf = sg_dma_address(sg);\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\n} else {\r\nsg = NULL;\r\nbuf = urb->transfer_dma;\r\nthis_sg_len = len;\r\n}\r\nif (is_input)\r\ntoken |= (1 << 8);\r\nmaxpacket = max_packet(usb_maxpacket(urb->dev, urb->pipe, !is_input));\r\nfor (;;) {\r\nint this_qtd_len;\r\nthis_qtd_len = qtd_fill(ehci, qtd, buf, this_sg_len, token,\r\nmaxpacket);\r\nthis_sg_len -= this_qtd_len;\r\nlen -= this_qtd_len;\r\nbuf += this_qtd_len;\r\nif (is_input)\r\nqtd->hw_alt_next = ehci->async->hw->hw_alt_next;\r\nif ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)\r\ntoken ^= QTD_TOGGLE;\r\nif (likely(this_sg_len <= 0)) {\r\nif (--i <= 0 || len <= 0)\r\nbreak;\r\nsg = sg_next(sg);\r\nbuf = sg_dma_address(sg);\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\n}\r\nqtd_prev = qtd;\r\nqtd = ehci_qtd_alloc (ehci, flags);\r\nif (unlikely (!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\r\nlist_add_tail (&qtd->qtd_list, head);\r\n}\r\nif (likely ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0\r\n|| usb_pipecontrol (urb->pipe)))\r\nqtd->hw_alt_next = EHCI_LIST_END(ehci);\r\nif (likely (urb->transfer_buffer_length != 0)) {\r\nint one_more = 0;\r\nif (usb_pipecontrol (urb->pipe)) {\r\none_more = 1;\r\ntoken ^= 0x0100;\r\ntoken |= QTD_TOGGLE;\r\n} else if (usb_pipeout(urb->pipe)\r\n&& (urb->transfer_flags & URB_ZERO_PACKET)\r\n&& !(urb->transfer_buffer_length % maxpacket)) {\r\none_more = 1;\r\n}\r\nif (one_more) {\r\nqtd_prev = qtd;\r\nqtd = ehci_qtd_alloc (ehci, flags);\r\nif (unlikely (!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\r\nlist_add_tail (&qtd->qtd_list, head);\r\nqtd_fill(ehci, qtd, 0, 0, token, 0);\r\n}\r\n}\r\nif (likely (!(urb->transfer_flags & URB_NO_INTERRUPT)))\r\nqtd->hw_token |= cpu_to_hc32(ehci, QTD_IOC);\r\nreturn head;\r\ncleanup:\r\nqtd_list_free (ehci, urb, head);\r\nreturn NULL;\r\n}\r\nstatic struct ehci_qh *\r\nqh_make (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\ngfp_t flags\r\n) {\r\nstruct ehci_qh *qh = ehci_qh_alloc (ehci, flags);\r\nu32 info1 = 0, info2 = 0;\r\nint is_input, type;\r\nint maxp = 0;\r\nstruct usb_tt *tt = urb->dev->tt;\r\nstruct ehci_qh_hw *hw;\r\nif (!qh)\r\nreturn qh;\r\ninfo1 |= usb_pipeendpoint (urb->pipe) << 8;\r\ninfo1 |= usb_pipedevice (urb->pipe) << 0;\r\nis_input = usb_pipein (urb->pipe);\r\ntype = usb_pipetype (urb->pipe);\r\nmaxp = usb_maxpacket (urb->dev, urb->pipe, !is_input);\r\nif (max_packet(maxp) > 1024) {\r\nehci_dbg(ehci, "bogus qh maxpacket %d\n", max_packet(maxp));\r\ngoto done;\r\n}\r\nif (type == PIPE_INTERRUPT) {\r\nunsigned tmp;\r\nqh->ps.usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,\r\nis_input, 0,\r\nhb_mult(maxp) * max_packet(maxp)));\r\nqh->ps.phase = NO_FRAME;\r\nif (urb->dev->speed == USB_SPEED_HIGH) {\r\nqh->ps.c_usecs = 0;\r\nqh->gap_uf = 0;\r\nif (urb->interval > 1 && urb->interval < 8) {\r\nurb->interval = 1;\r\n} else if (urb->interval > ehci->periodic_size << 3) {\r\nurb->interval = ehci->periodic_size << 3;\r\n}\r\nqh->ps.period = urb->interval >> 3;\r\ntmp = min_t(unsigned, EHCI_BANDWIDTH_SIZE,\r\n1 << (urb->ep->desc.bInterval - 1));\r\nqh->ps.bw_uperiod = min_t(unsigned, tmp, urb->interval);\r\nqh->ps.bw_period = qh->ps.bw_uperiod >> 3;\r\n} else {\r\nint think_time;\r\nqh->gap_uf = 1 + usb_calc_bus_time (urb->dev->speed,\r\nis_input, 0, maxp) / (125 * 1000);\r\nif (is_input) {\r\nqh->ps.c_usecs = qh->ps.usecs + HS_USECS(0);\r\nqh->ps.usecs = HS_USECS(1);\r\n} else {\r\nqh->ps.usecs += HS_USECS(1);\r\nqh->ps.c_usecs = HS_USECS(0);\r\n}\r\nthink_time = tt ? tt->think_time : 0;\r\nqh->ps.tt_usecs = NS_TO_US(think_time +\r\nusb_calc_bus_time (urb->dev->speed,\r\nis_input, 0, max_packet (maxp)));\r\nif (urb->interval > ehci->periodic_size)\r\nurb->interval = ehci->periodic_size;\r\nqh->ps.period = urb->interval;\r\ntmp = min_t(unsigned, EHCI_BANDWIDTH_FRAMES,\r\nurb->ep->desc.bInterval);\r\ntmp = rounddown_pow_of_two(tmp);\r\nqh->ps.bw_period = min_t(unsigned, tmp, urb->interval);\r\nqh->ps.bw_uperiod = qh->ps.bw_period << 3;\r\n}\r\n}\r\nqh->ps.udev = urb->dev;\r\nqh->ps.ep = urb->ep;\r\nswitch (urb->dev->speed) {\r\ncase USB_SPEED_LOW:\r\ninfo1 |= QH_LOW_SPEED;\r\ncase USB_SPEED_FULL:\r\nif (type != PIPE_INTERRUPT)\r\ninfo1 |= (EHCI_TUNE_RL_TT << 28);\r\nif (type == PIPE_CONTROL) {\r\ninfo1 |= QH_CONTROL_EP;\r\ninfo1 |= QH_TOGGLE_CTL;\r\n}\r\ninfo1 |= maxp << 16;\r\ninfo2 |= (EHCI_TUNE_MULT_TT << 30);\r\nif (ehci_has_fsl_portno_bug(ehci))\r\ninfo2 |= (urb->dev->ttport-1) << 23;\r\nelse\r\ninfo2 |= urb->dev->ttport << 23;\r\nif (tt && tt->hub != ehci_to_hcd(ehci)->self.root_hub)\r\ninfo2 |= tt->hub->devnum << 16;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ninfo1 |= QH_HIGH_SPEED;\r\nif (type == PIPE_CONTROL) {\r\ninfo1 |= (EHCI_TUNE_RL_HS << 28);\r\ninfo1 |= 64 << 16;\r\ninfo1 |= QH_TOGGLE_CTL;\r\ninfo2 |= (EHCI_TUNE_MULT_HS << 30);\r\n} else if (type == PIPE_BULK) {\r\ninfo1 |= (EHCI_TUNE_RL_HS << 28);\r\ninfo1 |= max_packet(maxp) << 16;\r\ninfo2 |= (EHCI_TUNE_MULT_HS << 30);\r\n} else {\r\ninfo1 |= max_packet (maxp) << 16;\r\ninfo2 |= hb_mult (maxp) << 30;\r\n}\r\nbreak;\r\ndefault:\r\nehci_dbg(ehci, "bogus dev %p speed %d\n", urb->dev,\r\nurb->dev->speed);\r\ndone:\r\nqh_destroy(ehci, qh);\r\nreturn NULL;\r\n}\r\nqh->qh_state = QH_STATE_IDLE;\r\nhw = qh->hw;\r\nhw->hw_info1 = cpu_to_hc32(ehci, info1);\r\nhw->hw_info2 = cpu_to_hc32(ehci, info2);\r\nqh->is_out = !is_input;\r\nusb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe), !is_input, 1);\r\nreturn qh;\r\n}\r\nstatic void enable_async(struct ehci_hcd *ehci)\r\n{\r\nif (ehci->async_count++)\r\nreturn;\r\nehci->enabled_hrtimer_events &= ~BIT(EHCI_HRTIMER_DISABLE_ASYNC);\r\nehci_poll_ASS(ehci);\r\nturn_on_io_watchdog(ehci);\r\n}\r\nstatic void disable_async(struct ehci_hcd *ehci)\r\n{\r\nif (--ehci->async_count)\r\nreturn;\r\nWARN_ON(ehci->async->qh_next.qh || !list_empty(&ehci->async_unlink) ||\r\n!list_empty(&ehci->async_idle));\r\nehci_poll_ASS(ehci);\r\n}\r\nstatic void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\n__hc32 dma = QH_NEXT(ehci, qh->qh_dma);\r\nstruct ehci_qh *head;\r\nif (unlikely(qh->clearing_tt))\r\nreturn;\r\nWARN_ON(qh->qh_state != QH_STATE_IDLE);\r\nqh_refresh(ehci, qh);\r\nhead = ehci->async;\r\nqh->qh_next = head->qh_next;\r\nqh->hw->hw_next = head->hw->hw_next;\r\nwmb ();\r\nhead->qh_next.qh = qh;\r\nhead->hw->hw_next = dma;\r\nqh->qh_state = QH_STATE_LINKED;\r\nqh->xacterrs = 0;\r\nqh->unlink_reason = 0;\r\nenable_async(ehci);\r\n}\r\nstatic struct ehci_qh *qh_append_tds (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list,\r\nint epnum,\r\nvoid **ptr\r\n)\r\n{\r\nstruct ehci_qh *qh = NULL;\r\n__hc32 qh_addr_mask = cpu_to_hc32(ehci, 0x7f);\r\nqh = (struct ehci_qh *) *ptr;\r\nif (unlikely (qh == NULL)) {\r\nqh = qh_make (ehci, urb, GFP_ATOMIC);\r\n*ptr = qh;\r\n}\r\nif (likely (qh != NULL)) {\r\nstruct ehci_qtd *qtd;\r\nif (unlikely (list_empty (qtd_list)))\r\nqtd = NULL;\r\nelse\r\nqtd = list_entry (qtd_list->next, struct ehci_qtd,\r\nqtd_list);\r\nif (unlikely (epnum == 0)) {\r\nif (usb_pipedevice (urb->pipe) == 0)\r\nqh->hw->hw_info1 &= ~qh_addr_mask;\r\n}\r\nif (likely (qtd != NULL)) {\r\nstruct ehci_qtd *dummy;\r\ndma_addr_t dma;\r\n__hc32 token;\r\ntoken = qtd->hw_token;\r\nqtd->hw_token = HALT_BIT(ehci);\r\ndummy = qh->dummy;\r\ndma = dummy->qtd_dma;\r\n*dummy = *qtd;\r\ndummy->qtd_dma = dma;\r\nlist_del (&qtd->qtd_list);\r\nlist_add (&dummy->qtd_list, qtd_list);\r\nlist_splice_tail(qtd_list, &qh->qtd_list);\r\nehci_qtd_init(ehci, qtd, qtd->qtd_dma);\r\nqh->dummy = qtd;\r\ndma = qtd->qtd_dma;\r\nqtd = list_entry (qh->qtd_list.prev,\r\nstruct ehci_qtd, qtd_list);\r\nqtd->hw_next = QTD_NEXT(ehci, dma);\r\nwmb ();\r\ndummy->hw_token = token;\r\nurb->hcpriv = qh;\r\n}\r\n}\r\nreturn qh;\r\n}\r\nstatic int\r\nsubmit_async (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list,\r\ngfp_t mem_flags\r\n) {\r\nint epnum;\r\nunsigned long flags;\r\nstruct ehci_qh *qh = NULL;\r\nint rc;\r\nepnum = urb->ep->desc.bEndpointAddress;\r\n#ifdef EHCI_URB_TRACE\r\n{\r\nstruct ehci_qtd *qtd;\r\nqtd = list_entry(qtd_list->next, struct ehci_qtd, qtd_list);\r\nehci_dbg(ehci,\r\n"%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\n",\r\n__func__, urb->dev->devpath, urb,\r\nepnum & 0x0f, (epnum & USB_DIR_IN) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nqtd, urb->ep->hcpriv);\r\n}\r\n#endif\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\r\nrc = -ESHUTDOWN;\r\ngoto done;\r\n}\r\nrc = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\r\nif (unlikely(rc))\r\ngoto done;\r\nqh = qh_append_tds(ehci, urb, qtd_list, epnum, &urb->ep->hcpriv);\r\nif (unlikely(qh == NULL)) {\r\nusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\r\nrc = -ENOMEM;\r\ngoto done;\r\n}\r\nif (likely (qh->qh_state == QH_STATE_IDLE))\r\nqh_link_async(ehci, qh);\r\ndone:\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nif (unlikely (qh == NULL))\r\nqtd_list_free (ehci, urb, qtd_list);\r\nreturn rc;\r\n}\r\nstatic int submit_single_step_set_feature(\r\nstruct usb_hcd *hcd,\r\nstruct urb *urb,\r\nint is_setup\r\n) {\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct list_head qtd_list;\r\nstruct list_head *head;\r\nstruct ehci_qtd *qtd, *qtd_prev;\r\ndma_addr_t buf;\r\nint len, maxpacket;\r\nu32 token;\r\nINIT_LIST_HEAD(&qtd_list);\r\nhead = &qtd_list;\r\nqtd = ehci_qtd_alloc(ehci, GFP_KERNEL);\r\nif (unlikely(!qtd))\r\nreturn -1;\r\nlist_add_tail(&qtd->qtd_list, head);\r\nqtd->urb = urb;\r\ntoken = QTD_STS_ACTIVE;\r\ntoken |= (EHCI_TUNE_CERR << 10);\r\nlen = urb->transfer_buffer_length;\r\nif (is_setup) {\r\nqtd_fill(ehci, qtd, urb->setup_dma,\r\nsizeof(struct usb_ctrlrequest),\r\ntoken | (2 << 8), 8);\r\nsubmit_async(ehci, urb, &qtd_list, GFP_ATOMIC);\r\nreturn 0;\r\n}\r\ntoken ^= QTD_TOGGLE;\r\nbuf = urb->transfer_dma;\r\ntoken |= (1 << 8);\r\nmaxpacket = max_packet(usb_maxpacket(urb->dev, urb->pipe, 0));\r\nqtd_fill(ehci, qtd, buf, len, token, maxpacket);\r\nqtd->hw_alt_next = EHCI_LIST_END(ehci);\r\ntoken ^= 0x0100;\r\ntoken |= QTD_TOGGLE;\r\nqtd_prev = qtd;\r\nqtd = ehci_qtd_alloc(ehci, GFP_ATOMIC);\r\nif (unlikely(!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\r\nlist_add_tail(&qtd->qtd_list, head);\r\nqtd_fill(ehci, qtd, 0, 0, token, 0);\r\nif (likely(!(urb->transfer_flags & URB_NO_INTERRUPT)))\r\nqtd->hw_token |= cpu_to_hc32(ehci, QTD_IOC);\r\nsubmit_async(ehci, urb, &qtd_list, GFP_KERNEL);\r\nreturn 0;\r\ncleanup:\r\nqtd_list_free(ehci, urb, head);\r\nreturn -1;\r\n}\r\nstatic void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nstruct ehci_qh *prev;\r\nqh->qh_state = QH_STATE_UNLINK_WAIT;\r\nlist_add_tail(&qh->unlink_node, &ehci->async_unlink);\r\nprev = ehci->async;\r\nwhile (prev->qh_next.qh != qh)\r\nprev = prev->qh_next.qh;\r\nprev->hw->hw_next = qh->hw->hw_next;\r\nprev->qh_next = qh->qh_next;\r\nif (ehci->qh_scan_next == qh)\r\nehci->qh_scan_next = qh->qh_next.qh;\r\n}\r\nstatic void start_iaa_cycle(struct ehci_hcd *ehci)\r\n{\r\nif (unlikely(ehci->rh_state < EHCI_RH_RUNNING)) {\r\nend_unlink_async(ehci);\r\n} else if (ehci->rh_state == EHCI_RH_RUNNING &&\r\n!ehci->iaa_in_progress) {\r\nwmb();\r\nehci_writel(ehci, ehci->command | CMD_IAAD,\r\n&ehci->regs->command);\r\nehci_readl(ehci, &ehci->regs->command);\r\nehci->iaa_in_progress = true;\r\nehci_enable_event(ehci, EHCI_HRTIMER_IAA_WATCHDOG, true);\r\n}\r\n}\r\nstatic void end_iaa_cycle(struct ehci_hcd *ehci)\r\n{\r\nif (ehci->has_synopsys_hc_bug)\r\nehci_writel(ehci, (u32) ehci->async->qh_dma,\r\n&ehci->regs->async_next);\r\nehci->iaa_in_progress = false;\r\nend_unlink_async(ehci);\r\n}\r\nstatic void end_unlink_async(struct ehci_hcd *ehci)\r\n{\r\nstruct ehci_qh *qh;\r\nbool early_exit;\r\nif (list_empty(&ehci->async_unlink))\r\nreturn;\r\nqh = list_first_entry(&ehci->async_unlink, struct ehci_qh,\r\nunlink_node);\r\nearly_exit = ehci->async_unlinking;\r\nif (ehci->rh_state < EHCI_RH_RUNNING)\r\nlist_splice_tail_init(&ehci->async_unlink, &ehci->async_idle);\r\nelse if (qh->qh_state == QH_STATE_UNLINK) {\r\nlist_move_tail(&qh->unlink_node, &ehci->async_idle);\r\n}\r\nelse if (qh->unlink_reason & (QH_UNLINK_HALTED |\r\nQH_UNLINK_SHORT_READ | QH_UNLINK_DUMMY_OVERLAY))\r\ngoto DelayDone;\r\nelse if ((qh->unlink_reason & QH_UNLINK_QUEUE_EMPTY) &&\r\nlist_empty(&qh->qtd_list))\r\ngoto DelayDone;\r\nelse if (qh->hw->hw_token & cpu_to_hc32(ehci, QTD_STS_HALT))\r\ngoto DelayDone;\r\nelse {\r\n__hc32 qh_current, qh_token;\r\nqh_current = qh->hw->hw_current;\r\nqh_token = qh->hw->hw_token;\r\nif (qh_current != ehci->old_current ||\r\nqh_token != ehci->old_token) {\r\nehci->old_current = qh_current;\r\nehci->old_token = qh_token;\r\nehci_enable_event(ehci,\r\nEHCI_HRTIMER_ACTIVE_UNLINK, true);\r\nreturn;\r\n}\r\nDelayDone:\r\nqh->qh_state = QH_STATE_UNLINK;\r\nearly_exit = true;\r\n}\r\nehci->old_current = ~0;\r\nif (!list_empty(&ehci->async_unlink))\r\nstart_iaa_cycle(ehci);\r\nif (early_exit)\r\nreturn;\r\nehci->async_unlinking = true;\r\nwhile (!list_empty(&ehci->async_idle)) {\r\nqh = list_first_entry(&ehci->async_idle, struct ehci_qh,\r\nunlink_node);\r\nlist_del(&qh->unlink_node);\r\nqh->qh_state = QH_STATE_IDLE;\r\nqh->qh_next.qh = NULL;\r\nif (!list_empty(&qh->qtd_list))\r\nqh_completions(ehci, qh);\r\nif (!list_empty(&qh->qtd_list) &&\r\nehci->rh_state == EHCI_RH_RUNNING)\r\nqh_link_async(ehci, qh);\r\ndisable_async(ehci);\r\n}\r\nehci->async_unlinking = false;\r\n}\r\nstatic void unlink_empty_async(struct ehci_hcd *ehci)\r\n{\r\nstruct ehci_qh *qh;\r\nstruct ehci_qh *qh_to_unlink = NULL;\r\nint count = 0;\r\nfor (qh = ehci->async->qh_next.qh; qh; qh = qh->qh_next.qh) {\r\nif (list_empty(&qh->qtd_list) &&\r\nqh->qh_state == QH_STATE_LINKED) {\r\n++count;\r\nif (qh->unlink_cycle != ehci->async_unlink_cycle)\r\nqh_to_unlink = qh;\r\n}\r\n}\r\nif (list_empty(&ehci->async_unlink) && qh_to_unlink) {\r\nqh_to_unlink->unlink_reason |= QH_UNLINK_QUEUE_EMPTY;\r\nstart_unlink_async(ehci, qh_to_unlink);\r\n--count;\r\n}\r\nif (count > 0) {\r\nehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);\r\n++ehci->async_unlink_cycle;\r\n}\r\n}\r\nstatic void unlink_empty_async_suspended(struct ehci_hcd *ehci)\r\n{\r\nstruct ehci_qh *qh;\r\nwhile (ehci->async->qh_next.qh) {\r\nqh = ehci->async->qh_next.qh;\r\nWARN_ON(!list_empty(&qh->qtd_list));\r\nsingle_unlink_async(ehci, qh);\r\n}\r\n}\r\nstatic void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nif (qh->qh_state != QH_STATE_LINKED)\r\nreturn;\r\nsingle_unlink_async(ehci, qh);\r\nstart_iaa_cycle(ehci);\r\n}\r\nstatic void scan_async (struct ehci_hcd *ehci)\r\n{\r\nstruct ehci_qh *qh;\r\nbool check_unlinks_later = false;\r\nehci->qh_scan_next = ehci->async->qh_next.qh;\r\nwhile (ehci->qh_scan_next) {\r\nqh = ehci->qh_scan_next;\r\nehci->qh_scan_next = qh->qh_next.qh;\r\nif (!list_empty(&qh->qtd_list)) {\r\nint temp;\r\ntemp = qh_completions(ehci, qh);\r\nif (unlikely(temp)) {\r\nstart_unlink_async(ehci, qh);\r\n} else if (list_empty(&qh->qtd_list)\r\n&& qh->qh_state == QH_STATE_LINKED) {\r\nqh->unlink_cycle = ehci->async_unlink_cycle;\r\ncheck_unlinks_later = true;\r\n}\r\n}\r\n}\r\nif (check_unlinks_later && ehci->rh_state == EHCI_RH_RUNNING &&\r\n!(ehci->enabled_hrtimer_events &\r\nBIT(EHCI_HRTIMER_ASYNC_UNLINKS))) {\r\nehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);\r\n++ehci->async_unlink_cycle;\r\n}\r\n}
