static inline u32 grcan_read_reg(u32 __iomem *reg)\r\n{\r\nreturn ioread32be(reg);\r\n}\r\nstatic inline void grcan_write_reg(u32 __iomem *reg, u32 val)\r\n{\r\niowrite32be(val, reg);\r\n}\r\nstatic inline u32 grcan_read_reg(u32 __iomem *reg)\r\n{\r\nreturn ioread32(reg);\r\n}\r\nstatic inline void grcan_write_reg(u32 __iomem *reg, u32 val)\r\n{\r\niowrite32(val, reg);\r\n}\r\nstatic inline void grcan_clear_bits(u32 __iomem *reg, u32 mask)\r\n{\r\ngrcan_write_reg(reg, grcan_read_reg(reg) & ~mask);\r\n}\r\nstatic inline void grcan_set_bits(u32 __iomem *reg, u32 mask)\r\n{\r\ngrcan_write_reg(reg, grcan_read_reg(reg) | mask);\r\n}\r\nstatic inline u32 grcan_read_bits(u32 __iomem *reg, u32 mask)\r\n{\r\nreturn grcan_read_reg(reg) & mask;\r\n}\r\nstatic inline void grcan_write_bits(u32 __iomem *reg, u32 value, u32 mask)\r\n{\r\nu32 old = grcan_read_reg(reg);\r\ngrcan_write_reg(reg, (old & ~mask) | (value & mask));\r\n}\r\nstatic inline u32 grcan_ring_add(u32 a, u32 b, u32 size)\r\n{\r\nu32 sum = a + b;\r\nif (sum < size)\r\nreturn sum;\r\nelse\r\nreturn sum - size;\r\n}\r\nstatic inline u32 grcan_ring_sub(u32 a, u32 b, u32 size)\r\n{\r\nreturn grcan_ring_add(a, size - b, size);\r\n}\r\nstatic inline u32 grcan_txspace(size_t txsize, u32 txwr, u32 eskbp)\r\n{\r\nu32 slots = txsize / GRCAN_MSG_SIZE - 1;\r\nu32 used = grcan_ring_sub(txwr, eskbp, txsize) / GRCAN_MSG_SIZE;\r\nreturn slots - used;\r\n}\r\nstatic int grcan_set_bittiming(struct net_device *dev)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nu32 timing = 0;\r\nint bpr, rsj, ps1, ps2, scaler;\r\nif (grcan_read_bits(&regs->ctrl, GRCAN_CTRL_ENABLE))\r\nreturn -EBUSY;\r\nbpr = 0;\r\nrsj = bt->sjw;\r\nps1 = (bt->prop_seg + bt->phase_seg1) - 1;\r\nps2 = bt->phase_seg2;\r\nscaler = (bt->brp - 1);\r\nnetdev_dbg(dev, "Request for BPR=%d, RSJ=%d, PS1=%d, PS2=%d, SCALER=%d",\r\nbpr, rsj, ps1, ps2, scaler);\r\nif (!(ps1 > ps2)) {\r\nnetdev_err(dev, "PS1 > PS2 must hold: PS1=%d, PS2=%d\n",\r\nps1, ps2);\r\nreturn -EINVAL;\r\n}\r\nif (!(ps2 >= rsj)) {\r\nnetdev_err(dev, "PS2 >= RSJ must hold: PS2=%d, RSJ=%d\n",\r\nps2, rsj);\r\nreturn -EINVAL;\r\n}\r\ntiming |= (bpr << GRCAN_CONF_BPR_BIT) & GRCAN_CONF_BPR;\r\ntiming |= (rsj << GRCAN_CONF_RSJ_BIT) & GRCAN_CONF_RSJ;\r\ntiming |= (ps1 << GRCAN_CONF_PS1_BIT) & GRCAN_CONF_PS1;\r\ntiming |= (ps2 << GRCAN_CONF_PS2_BIT) & GRCAN_CONF_PS2;\r\ntiming |= (scaler << GRCAN_CONF_SCALER_BIT) & GRCAN_CONF_SCALER;\r\nnetdev_info(dev, "setting timing=0x%x\n", timing);\r\ngrcan_write_bits(&regs->conf, timing, GRCAN_CONF_TIMING);\r\nreturn 0;\r\n}\r\nstatic int grcan_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nu32 status = grcan_read_reg(&regs->stat);\r\nbec->txerr = (status & GRCAN_STAT_TXERRCNT) >> GRCAN_STAT_TXERRCNT_BIT;\r\nbec->rxerr = (status & GRCAN_STAT_RXERRCNT) >> GRCAN_STAT_RXERRCNT_BIT;\r\nreturn 0;\r\n}\r\nstatic void grcan_reset(struct net_device *dev)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nu32 config = grcan_read_reg(&regs->conf);\r\ngrcan_set_bits(&regs->ctrl, GRCAN_CTRL_RESET);\r\ngrcan_write_reg(&regs->conf, config);\r\npriv->eskbp = grcan_read_reg(&regs->txrd);\r\npriv->can.state = CAN_STATE_STOPPED;\r\ngrcan_write_reg(&regs->rxmask, 0);\r\n}\r\nstatic void grcan_stop_hardware(struct net_device *dev)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\ngrcan_write_reg(&regs->imr, GRCAN_IRQ_NONE);\r\ngrcan_clear_bits(&regs->txctrl, GRCAN_TXCTRL_ENABLE);\r\ngrcan_clear_bits(&regs->rxctrl, GRCAN_RXCTRL_ENABLE);\r\ngrcan_clear_bits(&regs->ctrl, GRCAN_CTRL_ENABLE);\r\n}\r\nstatic int catch_up_echo_skb(struct net_device *dev, int budget, bool echo)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nstruct grcan_dma *dma = &priv->dma;\r\nstruct net_device_stats *stats = &dev->stats;\r\nint i, work_done;\r\nu32 txrd = grcan_read_reg(&regs->txrd);\r\nfor (work_done = 0; work_done < budget || budget < 0; work_done++) {\r\nif (priv->eskbp == txrd)\r\nbreak;\r\ni = priv->eskbp / GRCAN_MSG_SIZE;\r\nif (echo) {\r\nstats->tx_packets++;\r\nstats->tx_bytes += priv->txdlc[i];\r\npriv->txdlc[i] = 0;\r\ncan_get_echo_skb(dev, i);\r\n} else {\r\ncan_free_echo_skb(dev, i);\r\n}\r\npriv->eskbp = grcan_ring_add(priv->eskbp, GRCAN_MSG_SIZE,\r\ndma->tx.size);\r\ntxrd = grcan_read_reg(&regs->txrd);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void grcan_lost_one_shot_frame(struct net_device *dev)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nstruct grcan_dma *dma = &priv->dma;\r\nu32 txrd;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncatch_up_echo_skb(dev, -1, true);\r\nif (unlikely(grcan_read_bits(&regs->txctrl, GRCAN_TXCTRL_ENABLE))) {\r\nnetdev_err(dev, "TXCTRL enabled at TXLOSS in one shot mode\n");\r\n} else {\r\ntxrd = grcan_read_reg(&regs->txrd);\r\ntxrd = grcan_ring_add(txrd, GRCAN_MSG_SIZE, dma->tx.size);\r\ngrcan_write_reg(&regs->txrd, txrd);\r\ncatch_up_echo_skb(dev, -1, false);\r\nif (!priv->resetting && !priv->closing &&\r\n!(priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)) {\r\nnetif_wake_queue(dev);\r\ngrcan_set_bits(&regs->txctrl, GRCAN_TXCTRL_ENABLE);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void grcan_err(struct net_device *dev, u32 sources, u32 status)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nstruct grcan_dma *dma = &priv->dma;\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame cf;\r\nmemset(&cf, 0, sizeof(cf));\r\nif (sources & GRCAN_IRQ_TXLOSS) {\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\r\ngrcan_lost_one_shot_frame(dev);\r\nif (!(status & GRCAN_STAT_ERRCTR_RELATED)) {\r\nnetdev_dbg(dev, "tx message lost\n");\r\nstats->tx_errors++;\r\n}\r\n}\r\nif ((sources & GRCAN_IRQ_ERRCTR_RELATED) ||\r\n(status & GRCAN_STAT_ERRCTR_RELATED)) {\r\nenum can_state state = priv->can.state;\r\nenum can_state oldstate = state;\r\nu32 txerr = (status & GRCAN_STAT_TXERRCNT)\r\n>> GRCAN_STAT_TXERRCNT_BIT;\r\nu32 rxerr = (status & GRCAN_STAT_RXERRCNT)\r\n>> GRCAN_STAT_RXERRCNT_BIT;\r\nif (status & GRCAN_STAT_OFF) {\r\nstate = CAN_STATE_BUS_OFF;\r\n} else if (status & GRCAN_STAT_PASS) {\r\nstate = CAN_STATE_ERROR_PASSIVE;\r\n} else if (txerr >= GRCAN_STAT_ERRCNT_WARNING_LIMIT ||\r\nrxerr >= GRCAN_STAT_ERRCNT_WARNING_LIMIT) {\r\nstate = CAN_STATE_ERROR_WARNING;\r\n} else {\r\nstate = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nif (state != oldstate) {\r\nswitch (state) {\r\ncase CAN_STATE_BUS_OFF:\r\nnetdev_dbg(dev, "bus-off\n");\r\nnetif_carrier_off(dev);\r\npriv->can.can_stats.bus_off++;\r\nif (!priv->can.restart_ms)\r\ngrcan_stop_hardware(dev);\r\ncf.can_id |= CAN_ERR_BUSOFF;\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\nnetdev_dbg(dev, "Error passive condition\n");\r\npriv->can.can_stats.error_passive++;\r\ncf.can_id |= CAN_ERR_CRTL;\r\nif (txerr >= GRCAN_STAT_ERRCNT_PASSIVE_LIMIT)\r\ncf.data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\r\nif (rxerr >= GRCAN_STAT_ERRCNT_PASSIVE_LIMIT)\r\ncf.data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\r\nbreak;\r\ncase CAN_STATE_ERROR_WARNING:\r\nnetdev_dbg(dev, "Error warning condition\n");\r\npriv->can.can_stats.error_warning++;\r\ncf.can_id |= CAN_ERR_CRTL;\r\nif (txerr >= GRCAN_STAT_ERRCNT_WARNING_LIMIT)\r\ncf.data[1] |= CAN_ERR_CRTL_TX_WARNING;\r\nif (rxerr >= GRCAN_STAT_ERRCNT_WARNING_LIMIT)\r\ncf.data[1] |= CAN_ERR_CRTL_RX_WARNING;\r\nbreak;\r\ncase CAN_STATE_ERROR_ACTIVE:\r\nnetdev_dbg(dev, "Error active condition\n");\r\ncf.can_id |= CAN_ERR_CRTL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncf.data[6] = txerr;\r\ncf.data[7] = rxerr;\r\npriv->can.state = state;\r\n}\r\nif (priv->can.restart_ms && oldstate == CAN_STATE_BUS_OFF) {\r\nunsigned long flags;\r\ncf.can_id |= CAN_ERR_RESTARTED;\r\nnetdev_dbg(dev, "restarted\n");\r\npriv->can.can_stats.restarts++;\r\nnetif_carrier_on(dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!priv->resetting && !priv->closing) {\r\nu32 txwr = grcan_read_reg(&regs->txwr);\r\nif (grcan_txspace(dma->tx.size, txwr,\r\npriv->eskbp))\r\nnetif_wake_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\n}\r\nif ((sources & GRCAN_IRQ_OR) || (status & GRCAN_STAT_OR)) {\r\nnetdev_dbg(dev, "got data overrun interrupt\n");\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\ncf.can_id |= CAN_ERR_CRTL;\r\ncf.data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\r\n}\r\nif (sources & (GRCAN_IRQ_TXAHBERR | GRCAN_IRQ_RXAHBERR) ||\r\n(status & GRCAN_STAT_AHBERR)) {\r\nchar *txrx = "";\r\nunsigned long flags;\r\nif (sources & GRCAN_IRQ_TXAHBERR) {\r\ntxrx = "on tx ";\r\nstats->tx_errors++;\r\n} else if (sources & GRCAN_IRQ_RXAHBERR) {\r\ntxrx = "on rx ";\r\nstats->rx_errors++;\r\n}\r\nnetdev_err(dev, "Fatal AHB buss error %s- halting device\n",\r\ntxrx);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->closing = true;\r\nnetif_stop_queue(dev);\r\ngrcan_stop_hardware(dev);\r\npriv->can.state = CAN_STATE_STOPPED;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nif (cf.can_id) {\r\nstruct can_frame *skb_cf;\r\nstruct sk_buff *skb = alloc_can_err_skb(dev, &skb_cf);\r\nif (skb == NULL) {\r\nnetdev_dbg(dev, "could not allocate error frame\n");\r\nreturn;\r\n}\r\nskb_cf->can_id |= cf.can_id;\r\nmemcpy(skb_cf->data, cf.data, sizeof(cf.data));\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic irqreturn_t grcan_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nu32 sources, status;\r\nsources = grcan_read_reg(&regs->pimsr);\r\nif (!sources)\r\nreturn IRQ_NONE;\r\ngrcan_write_reg(&regs->picr, sources);\r\nstatus = grcan_read_reg(&regs->stat);\r\nif (priv->need_txbug_workaround &&\r\n(sources & (GRCAN_IRQ_TX | GRCAN_IRQ_TXLOSS))) {\r\ndel_timer(&priv->hang_timer);\r\n}\r\nif (sources & (GRCAN_IRQ_TX | GRCAN_IRQ_RX)) {\r\ngrcan_clear_bits(&regs->imr, GRCAN_IRQ_TX | GRCAN_IRQ_RX);\r\nnapi_schedule(&priv->napi);\r\n}\r\nif (sources & GRCAN_IRQ_ERRORS)\r\ngrcan_err(dev, sources, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void grcan_running_reset(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->resetting = false;\r\ndel_timer(&priv->hang_timer);\r\ndel_timer(&priv->rr_timer);\r\nif (!priv->closing) {\r\nu32 imr = grcan_read_reg(&regs->imr);\r\nu32 txaddr = grcan_read_reg(&regs->txaddr);\r\nu32 txsize = grcan_read_reg(&regs->txsize);\r\nu32 txwr = grcan_read_reg(&regs->txwr);\r\nu32 txrd = grcan_read_reg(&regs->txrd);\r\nu32 eskbp = priv->eskbp;\r\nu32 rxaddr = grcan_read_reg(&regs->rxaddr);\r\nu32 rxsize = grcan_read_reg(&regs->rxsize);\r\nu32 rxwr = grcan_read_reg(&regs->rxwr);\r\nu32 rxrd = grcan_read_reg(&regs->rxrd);\r\ngrcan_reset(dev);\r\ngrcan_write_reg(&regs->txaddr, txaddr);\r\ngrcan_write_reg(&regs->txsize, txsize);\r\ngrcan_write_reg(&regs->txwr, txwr);\r\ngrcan_write_reg(&regs->txrd, txrd);\r\npriv->eskbp = eskbp;\r\ngrcan_write_reg(&regs->rxaddr, rxaddr);\r\ngrcan_write_reg(&regs->rxsize, rxsize);\r\ngrcan_write_reg(&regs->rxwr, rxwr);\r\ngrcan_write_reg(&regs->rxrd, rxrd);\r\ngrcan_write_reg(&regs->imr, imr);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\ngrcan_write_reg(&regs->txctrl, GRCAN_TXCTRL_ENABLE\r\n| (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT\r\n? GRCAN_TXCTRL_SINGLE : 0));\r\ngrcan_write_reg(&regs->rxctrl, GRCAN_RXCTRL_ENABLE);\r\ngrcan_write_reg(&regs->ctrl, GRCAN_CTRL_ENABLE);\r\nif (grcan_txspace(priv->dma.tx.size, txwr, priv->eskbp) &&\r\n!(priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\r\nnetif_wake_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnetdev_err(dev, "Device reset and restored\n");\r\n}\r\nstatic inline u32 grcan_ongoing_wait_usecs(__u32 bitrate)\r\n{\r\nreturn 1000000 * 3 * GRCAN_EFF_FRAME_MAX_BITS / bitrate;\r\n}\r\nstatic inline void grcan_reset_timer(struct timer_list *timer, __u32 bitrate)\r\n{\r\nu32 wait_jiffies = usecs_to_jiffies(grcan_ongoing_wait_usecs(bitrate));\r\nmod_timer(timer, jiffies + wait_jiffies);\r\n}\r\nstatic void grcan_initiate_running_reset(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nunsigned long flags;\r\nnetdev_err(dev, "Device seems hanged - reset scheduled\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!priv->resetting && !priv->closing) {\r\npriv->resetting = true;\r\nnetif_stop_queue(dev);\r\ngrcan_clear_bits(&regs->txctrl, GRCAN_TXCTRL_ENABLE);\r\ngrcan_clear_bits(&regs->rxctrl, GRCAN_RXCTRL_ENABLE);\r\ngrcan_reset_timer(&priv->rr_timer, priv->can.bittiming.bitrate);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void grcan_free_dma_buffers(struct net_device *dev)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_dma *dma = &priv->dma;\r\ndma_free_coherent(&dev->dev, dma->base_size, dma->base_buf,\r\ndma->base_handle);\r\nmemset(dma, 0, sizeof(*dma));\r\n}\r\nstatic int grcan_allocate_dma_buffers(struct net_device *dev,\r\nsize_t tsize, size_t rsize)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_dma *dma = &priv->dma;\r\nstruct grcan_dma_buffer *large = rsize > tsize ? &dma->rx : &dma->tx;\r\nstruct grcan_dma_buffer *small = rsize > tsize ? &dma->tx : &dma->rx;\r\nsize_t shift;\r\nsize_t maxs = max(tsize, rsize);\r\nsize_t lsize = ALIGN(maxs, GRCAN_BUFFER_ALIGNMENT);\r\nsize_t ssize = min(tsize, rsize);\r\ndma->base_size = lsize + ssize + GRCAN_BUFFER_ALIGNMENT;\r\ndma->base_buf = dma_alloc_coherent(&dev->dev,\r\ndma->base_size,\r\n&dma->base_handle,\r\nGFP_KERNEL);\r\nif (!dma->base_buf)\r\nreturn -ENOMEM;\r\ndma->tx.size = tsize;\r\ndma->rx.size = rsize;\r\nlarge->handle = ALIGN(dma->base_handle, GRCAN_BUFFER_ALIGNMENT);\r\nsmall->handle = large->handle + lsize;\r\nshift = large->handle - dma->base_handle;\r\nlarge->buf = dma->base_buf + shift;\r\nsmall->buf = large->buf + lsize;\r\nreturn 0;\r\n}\r\nstatic int grcan_start(struct net_device *dev)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nu32 confop, txctrl;\r\ngrcan_reset(dev);\r\ngrcan_write_reg(&regs->txaddr, priv->dma.tx.handle);\r\ngrcan_write_reg(&regs->txsize, priv->dma.tx.size);\r\ngrcan_write_reg(&regs->rxaddr, priv->dma.rx.handle);\r\ngrcan_write_reg(&regs->rxsize, priv->dma.rx.size);\r\ngrcan_read_reg(&regs->pir);\r\ngrcan_write_reg(&regs->imr, GRCAN_IRQ_DEFAULT);\r\nconfop = GRCAN_CONF_ABORT\r\n| (priv->config.enable0 ? GRCAN_CONF_ENABLE0 : 0)\r\n| (priv->config.enable1 ? GRCAN_CONF_ENABLE1 : 0)\r\n| (priv->config.select ? GRCAN_CONF_SELECT : 0)\r\n| (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY ?\r\nGRCAN_CONF_SILENT : 0)\r\n| (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES ?\r\nGRCAN_CONF_SAM : 0);\r\ngrcan_write_bits(&regs->conf, confop, GRCAN_CONF_OPERATION);\r\ntxctrl = GRCAN_TXCTRL_ENABLE\r\n| (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT\r\n? GRCAN_TXCTRL_SINGLE : 0);\r\ngrcan_write_reg(&regs->txctrl, txctrl);\r\ngrcan_write_reg(&regs->rxctrl, GRCAN_RXCTRL_ENABLE);\r\ngrcan_write_reg(&regs->ctrl, GRCAN_CTRL_ENABLE);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int grcan_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nint err = 0;\r\nif (mode == CAN_MODE_START) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->closing || priv->resetting) {\r\nerr = -EBUSY;\r\n} else {\r\nnetdev_info(dev, "Restarting device\n");\r\ngrcan_start(dev);\r\nif (!(priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\r\nnetif_wake_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn err;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int grcan_open(struct net_device *dev)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_dma *dma = &priv->dma;\r\nunsigned long flags;\r\nint err;\r\nerr = grcan_allocate_dma_buffers(dev, priv->config.txsize,\r\npriv->config.rxsize);\r\nif (err) {\r\nnetdev_err(dev, "could not allocate DMA buffers\n");\r\nreturn err;\r\n}\r\npriv->echo_skb = kzalloc(dma->tx.size * sizeof(*priv->echo_skb),\r\nGFP_KERNEL);\r\nif (!priv->echo_skb) {\r\nerr = -ENOMEM;\r\ngoto exit_free_dma_buffers;\r\n}\r\npriv->can.echo_skb_max = dma->tx.size;\r\npriv->can.echo_skb = priv->echo_skb;\r\npriv->txdlc = kzalloc(dma->tx.size * sizeof(*priv->txdlc), GFP_KERNEL);\r\nif (!priv->txdlc) {\r\nerr = -ENOMEM;\r\ngoto exit_free_echo_skb;\r\n}\r\nerr = open_candev(dev);\r\nif (err)\r\ngoto exit_free_txdlc;\r\nerr = request_irq(dev->irq, grcan_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (err)\r\ngoto exit_close_candev;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nnapi_enable(&priv->napi);\r\ngrcan_start(dev);\r\nif (!(priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\r\nnetif_start_queue(dev);\r\npriv->resetting = false;\r\npriv->closing = false;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\nexit_close_candev:\r\nclose_candev(dev);\r\nexit_free_txdlc:\r\nkfree(priv->txdlc);\r\nexit_free_echo_skb:\r\nkfree(priv->echo_skb);\r\nexit_free_dma_buffers:\r\ngrcan_free_dma_buffers(dev);\r\nreturn err;\r\n}\r\nstatic int grcan_close(struct net_device *dev)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nnapi_disable(&priv->napi);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->closing = true;\r\nif (priv->need_txbug_workaround) {\r\ndel_timer_sync(&priv->hang_timer);\r\ndel_timer_sync(&priv->rr_timer);\r\n}\r\nnetif_stop_queue(dev);\r\ngrcan_stop_hardware(dev);\r\npriv->can.state = CAN_STATE_STOPPED;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nfree_irq(dev->irq, dev);\r\nclose_candev(dev);\r\ngrcan_free_dma_buffers(dev);\r\npriv->can.echo_skb_max = 0;\r\npriv->can.echo_skb = NULL;\r\nkfree(priv->echo_skb);\r\nkfree(priv->txdlc);\r\nreturn 0;\r\n}\r\nstatic int grcan_transmit_catch_up(struct net_device *dev, int budget)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nint work_done;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nwork_done = catch_up_echo_skb(dev, budget, true);\r\nif (work_done) {\r\nif (!priv->resetting && !priv->closing &&\r\n!(priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\r\nnetif_wake_queue(dev);\r\nif (priv->need_txbug_workaround)\r\ndel_timer(&priv->hang_timer);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn work_done;\r\n}\r\nstatic int grcan_receive(struct net_device *dev, int budget)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nstruct grcan_dma *dma = &priv->dma;\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu32 wr, rd, startrd;\r\nu32 *slot;\r\nu32 i, rtr, eff, j, shift;\r\nint work_done = 0;\r\nrd = grcan_read_reg(&regs->rxrd);\r\nstartrd = rd;\r\nfor (work_done = 0; work_done < budget; work_done++) {\r\nwr = grcan_read_reg(&regs->rxwr);\r\nif (rd == wr)\r\nbreak;\r\nskb = alloc_can_skb(dev, &cf);\r\nif (skb == NULL) {\r\nnetdev_err(dev,\r\n"dropping frame: skb allocation failed\n");\r\nstats->rx_dropped++;\r\ncontinue;\r\n}\r\nslot = dma->rx.buf + rd;\r\neff = slot[0] & GRCAN_MSG_IDE;\r\nrtr = slot[0] & GRCAN_MSG_RTR;\r\nif (eff) {\r\ncf->can_id = ((slot[0] & GRCAN_MSG_EID)\r\n>> GRCAN_MSG_EID_BIT);\r\ncf->can_id |= CAN_EFF_FLAG;\r\n} else {\r\ncf->can_id = ((slot[0] & GRCAN_MSG_BID)\r\n>> GRCAN_MSG_BID_BIT);\r\n}\r\ncf->can_dlc = get_can_dlc((slot[1] & GRCAN_MSG_DLC)\r\n>> GRCAN_MSG_DLC_BIT);\r\nif (rtr) {\r\ncf->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nfor (i = 0; i < cf->can_dlc; i++) {\r\nj = GRCAN_MSG_DATA_SLOT_INDEX(i);\r\nshift = GRCAN_MSG_DATA_SHIFT(i);\r\ncf->data[i] = (u8)(slot[j] >> shift);\r\n}\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nrd = grcan_ring_add(rd, GRCAN_MSG_SIZE, dma->rx.size);\r\n}\r\nmb();\r\nif (likely(rd != startrd))\r\ngrcan_write_reg(&regs->rxrd, rd);\r\nreturn work_done;\r\n}\r\nstatic int grcan_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct grcan_priv *priv = container_of(napi, struct grcan_priv, napi);\r\nstruct net_device *dev = priv->dev;\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nunsigned long flags;\r\nint tx_work_done, rx_work_done;\r\nint rx_budget = budget / 2;\r\nint tx_budget = budget - rx_budget;\r\nrx_work_done = grcan_receive(dev, rx_budget);\r\ntx_work_done = grcan_transmit_catch_up(dev, tx_budget);\r\nif (rx_work_done < rx_budget && tx_work_done < tx_budget) {\r\nnapi_complete(napi);\r\nspin_lock_irqsave(&priv->lock, flags);\r\ngrcan_set_bits(&regs->imr, GRCAN_IRQ_TX | GRCAN_IRQ_RX);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nreturn rx_work_done + tx_work_done;\r\n}\r\nstatic int grcan_txbug_workaround(struct net_device *dev, struct sk_buff *skb,\r\nu32 txwr, u32 oneshotmode,\r\nnetdev_tx_t *netdev_tx_status)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nstruct grcan_dma *dma = &priv->dma;\r\nint i;\r\nunsigned long flags;\r\nfor (i = 0; i < GRCAN_SHORTWAIT_USECS; i++) {\r\nudelay(1);\r\nif (!grcan_read_bits(&regs->txctrl, GRCAN_TXCTRL_ONGOING) ||\r\ngrcan_read_reg(&regs->txrd) == txwr) {\r\nreturn 0;\r\n}\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!priv->resetting && !priv->closing) {\r\nif (grcan_txspace(dma->tx.size, txwr, priv->eskbp))\r\nnetif_wake_queue(dev);\r\nif (!timer_pending(&priv->hang_timer))\r\ngrcan_reset_timer(&priv->hang_timer,\r\npriv->can.bittiming.bitrate);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (oneshotmode) {\r\nkfree_skb(skb);\r\n*netdev_tx_status = NETDEV_TX_OK;\r\n} else {\r\n*netdev_tx_status = NETDEV_TX_BUSY;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic netdev_tx_t grcan_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nstruct grcan_registers __iomem *regs = priv->regs;\r\nstruct grcan_dma *dma = &priv->dma;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nu32 id, txwr, txrd, space, txctrl;\r\nint slotindex;\r\nu32 *slot;\r\nu32 i, rtr, eff, dlc, tmp, err;\r\nint j, shift;\r\nunsigned long flags;\r\nu32 oneshotmode = priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nreturn NETDEV_TX_BUSY;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ntxwr = grcan_read_reg(&regs->txwr);\r\nspace = grcan_txspace(dma->tx.size, txwr, priv->eskbp);\r\nslotindex = txwr / GRCAN_MSG_SIZE;\r\nslot = dma->tx.buf + txwr;\r\nif (unlikely(space == 1))\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (unlikely(!space)) {\r\nnetdev_err(dev, "No buffer space, but queue is non-stopped.\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\neff = cf->can_id & CAN_EFF_FLAG;\r\nrtr = cf->can_id & CAN_RTR_FLAG;\r\nid = cf->can_id & (eff ? CAN_EFF_MASK : CAN_SFF_MASK);\r\ndlc = cf->can_dlc;\r\nif (eff)\r\ntmp = (id << GRCAN_MSG_EID_BIT) & GRCAN_MSG_EID;\r\nelse\r\ntmp = (id << GRCAN_MSG_BID_BIT) & GRCAN_MSG_BID;\r\nslot[0] = (eff ? GRCAN_MSG_IDE : 0) | (rtr ? GRCAN_MSG_RTR : 0) | tmp;\r\nslot[1] = ((dlc << GRCAN_MSG_DLC_BIT) & GRCAN_MSG_DLC);\r\nslot[2] = 0;\r\nslot[3] = 0;\r\nfor (i = 0; i < dlc; i++) {\r\nj = GRCAN_MSG_DATA_SLOT_INDEX(i);\r\nshift = GRCAN_MSG_DATA_SHIFT(i);\r\nslot[j] |= cf->data[i] << shift;\r\n}\r\ntxctrl = grcan_read_reg(&regs->txctrl);\r\nif (!(txctrl & GRCAN_TXCTRL_ENABLE))\r\nnetdev_err(dev, "tx channel spuriously disabled\n");\r\nif (oneshotmode && !(txctrl & GRCAN_TXCTRL_SINGLE))\r\nnetdev_err(dev, "one-shot mode spuriously disabled\n");\r\nif (priv->need_txbug_workaround) {\r\ntxrd = grcan_read_reg(&regs->txrd);\r\nif (unlikely(grcan_ring_sub(txwr, txrd, dma->tx.size) == 1)) {\r\nnetdev_tx_t txstatus;\r\nerr = grcan_txbug_workaround(dev, skb, txwr,\r\noneshotmode, &txstatus);\r\nif (err)\r\nreturn txstatus;\r\n}\r\n}\r\npriv->txdlc[slotindex] = cf->can_dlc;\r\ncan_put_echo_skb(skb, dev, slotindex);\r\nwmb();\r\ngrcan_write_reg(&regs->txwr,\r\ngrcan_ring_add(txwr, GRCAN_MSG_SIZE, dma->tx.size));\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void grcan_sanitize_module_config(struct platform_device *ofdev)\r\n{\r\ngrcan_sanitize_enable0(ofdev);\r\ngrcan_sanitize_enable1(ofdev);\r\ngrcan_sanitize_select(ofdev);\r\ngrcan_sanitize_txsize(ofdev);\r\ngrcan_sanitize_rxsize(ofdev);\r\n}\r\nstatic int grcan_setup_netdev(struct platform_device *ofdev,\r\nvoid __iomem *base,\r\nint irq, u32 ambafreq, bool txbug)\r\n{\r\nstruct net_device *dev;\r\nstruct grcan_priv *priv;\r\nstruct grcan_registers __iomem *regs;\r\nint err;\r\ndev = alloc_candev(sizeof(struct grcan_priv), 0);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->irq = irq;\r\ndev->flags |= IFF_ECHO;\r\ndev->netdev_ops = &grcan_netdev_ops;\r\ndev->sysfs_groups[0] = &sysfs_grcan_group;\r\npriv = netdev_priv(dev);\r\nmemcpy(&priv->config, &grcan_module_config,\r\nsizeof(struct grcan_device_config));\r\npriv->dev = dev;\r\npriv->regs = base;\r\npriv->can.bittiming_const = &grcan_bittiming_const;\r\npriv->can.do_set_bittiming = grcan_set_bittiming;\r\npriv->can.do_set_mode = grcan_set_mode;\r\npriv->can.do_get_berr_counter = grcan_get_berr_counter;\r\npriv->can.clock.freq = ambafreq;\r\npriv->can.ctrlmode_supported =\r\nCAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_ONE_SHOT;\r\npriv->need_txbug_workaround = txbug;\r\nregs = priv->regs;\r\ngrcan_set_bits(&regs->ctrl, GRCAN_CTRL_RESET);\r\ngrcan_set_bits(&regs->conf, GRCAN_CONF_SAM);\r\nif (grcan_read_bits(&regs->conf, GRCAN_CONF_SAM)) {\r\npriv->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\r\ndev_dbg(&ofdev->dev, "Hardware supports triple-sampling\n");\r\n}\r\nspin_lock_init(&priv->lock);\r\nif (priv->need_txbug_workaround) {\r\ninit_timer(&priv->rr_timer);\r\npriv->rr_timer.function = grcan_running_reset;\r\npriv->rr_timer.data = (unsigned long)dev;\r\ninit_timer(&priv->hang_timer);\r\npriv->hang_timer.function = grcan_initiate_running_reset;\r\npriv->hang_timer.data = (unsigned long)dev;\r\n}\r\nnetif_napi_add(dev, &priv->napi, grcan_poll, GRCAN_NAPI_WEIGHT);\r\nSET_NETDEV_DEV(dev, &ofdev->dev);\r\ndev_info(&ofdev->dev, "regs=0x%p, irq=%d, clock=%d\n",\r\npriv->regs, dev->irq, priv->can.clock.freq);\r\nerr = register_candev(dev);\r\nif (err)\r\ngoto exit_free_candev;\r\nplatform_set_drvdata(ofdev, dev);\r\ngrcan_write_reg(&regs->ctrl, GRCAN_CTRL_RESET);\r\nreturn 0;\r\nexit_free_candev:\r\nfree_candev(dev);\r\nreturn err;\r\n}\r\nstatic int grcan_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct resource *res;\r\nu32 sysid, ambafreq;\r\nint irq, err;\r\nvoid __iomem *base;\r\nbool txbug = true;\r\nerr = of_property_read_u32(np, "systemid", &sysid);\r\nif (!err && ((sysid & GRLIB_VERSION_MASK)\r\n>= GRCAN_TXBUG_SAFE_GRLIB_VERSION))\r\ntxbug = false;\r\nerr = of_property_read_u32(np, "freq", &ambafreq);\r\nif (err) {\r\ndev_err(&ofdev->dev, "unable to fetch \"freq\" property\n");\r\ngoto exit_error;\r\n}\r\nres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&ofdev->dev, res);\r\nif (IS_ERR(base)) {\r\nerr = PTR_ERR(base);\r\ngoto exit_error;\r\n}\r\nirq = irq_of_parse_and_map(np, GRCAN_IRQIX_IRQ);\r\nif (!irq) {\r\ndev_err(&ofdev->dev, "no irq found\n");\r\nerr = -ENODEV;\r\ngoto exit_error;\r\n}\r\ngrcan_sanitize_module_config(ofdev);\r\nerr = grcan_setup_netdev(ofdev, base, irq, ambafreq, txbug);\r\nif (err)\r\ngoto exit_dispose_irq;\r\nreturn 0;\r\nexit_dispose_irq:\r\nirq_dispose_mapping(irq);\r\nexit_error:\r\ndev_err(&ofdev->dev,\r\n"%s socket CAN driver initialization failed with error %d\n",\r\nDRV_NAME, err);\r\nreturn err;\r\n}\r\nstatic int grcan_remove(struct platform_device *ofdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(ofdev);\r\nstruct grcan_priv *priv = netdev_priv(dev);\r\nunregister_candev(dev);\r\nirq_dispose_mapping(dev->irq);\r\nnetif_napi_del(&priv->napi);\r\nfree_candev(dev);\r\nreturn 0;\r\n}
