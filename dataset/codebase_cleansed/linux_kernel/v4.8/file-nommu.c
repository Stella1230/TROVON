static unsigned ramfs_mmap_capabilities(struct file *file)\r\n{\r\nreturn NOMMU_MAP_DIRECT | NOMMU_MAP_COPY | NOMMU_MAP_READ |\r\nNOMMU_MAP_WRITE | NOMMU_MAP_EXEC;\r\n}\r\nint ramfs_nommu_expand_for_mapping(struct inode *inode, size_t newsize)\r\n{\r\nunsigned long npages, xpages, loop;\r\nstruct page *pages;\r\nunsigned order;\r\nvoid *data;\r\nint ret;\r\ngfp_t gfp = mapping_gfp_mask(inode->i_mapping);\r\norder = get_order(newsize);\r\nif (unlikely(order >= MAX_ORDER))\r\nreturn -EFBIG;\r\nret = inode_newsize_ok(inode, newsize);\r\nif (ret)\r\nreturn ret;\r\ni_size_write(inode, newsize);\r\npages = alloc_pages(gfp, order);\r\nif (!pages)\r\nreturn -ENOMEM;\r\nxpages = 1UL << order;\r\nnpages = (newsize + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nsplit_page(pages, order);\r\nfor (loop = npages; loop < xpages; loop++)\r\n__free_page(pages + loop);\r\nnewsize = PAGE_SIZE * npages;\r\ndata = page_address(pages);\r\nmemset(data, 0, newsize);\r\nfor (loop = 0; loop < npages; loop++) {\r\nstruct page *page = pages + loop;\r\nret = add_to_page_cache_lru(page, inode->i_mapping, loop,\r\ngfp);\r\nif (ret < 0)\r\ngoto add_error;\r\nSetPageDirty(page);\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nput_page(page);\r\n}\r\nreturn 0;\r\nadd_error:\r\nwhile (loop < npages)\r\n__free_page(pages + loop++);\r\nreturn ret;\r\n}\r\nstatic int ramfs_nommu_resize(struct inode *inode, loff_t newsize, loff_t size)\r\n{\r\nint ret;\r\nif (size == 0) {\r\nif (unlikely(newsize >> 32))\r\nreturn -EFBIG;\r\nreturn ramfs_nommu_expand_for_mapping(inode, newsize);\r\n}\r\nif (newsize < size) {\r\nret = nommu_shrink_inode_mappings(inode, size, newsize);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ntruncate_setsize(inode, newsize);\r\nreturn 0;\r\n}\r\nstatic int ramfs_nommu_setattr(struct dentry *dentry, struct iattr *ia)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nunsigned int old_ia_valid = ia->ia_valid;\r\nint ret = 0;\r\nret = inode_change_ok(inode, ia);\r\nif (ret)\r\nreturn ret;\r\nif (ia->ia_valid & ATTR_SIZE) {\r\nloff_t size = inode->i_size;\r\nif (ia->ia_size != size) {\r\nret = ramfs_nommu_resize(inode, ia->ia_size, size);\r\nif (ret < 0 || ia->ia_valid == ATTR_SIZE)\r\ngoto out;\r\n} else {\r\nia->ia_valid |= ATTR_MTIME|ATTR_CTIME;\r\n}\r\n}\r\nsetattr_copy(inode, ia);\r\nout:\r\nia->ia_valid = old_ia_valid;\r\nreturn ret;\r\n}\r\nstatic unsigned long ramfs_nommu_get_unmapped_area(struct file *file,\r\nunsigned long addr, unsigned long len,\r\nunsigned long pgoff, unsigned long flags)\r\n{\r\nunsigned long maxpages, lpages, nr, loop, ret;\r\nstruct inode *inode = file_inode(file);\r\nstruct page **pages = NULL, **ptr, *page;\r\nloff_t isize;\r\nlpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nisize = i_size_read(inode);\r\nret = -ENOSYS;\r\nmaxpages = (isize + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nif (pgoff >= maxpages)\r\ngoto out;\r\nif (maxpages - pgoff < lpages)\r\ngoto out;\r\npages = kcalloc(lpages, sizeof(struct page *), GFP_KERNEL);\r\nif (!pages)\r\ngoto out_free;\r\nnr = find_get_pages(inode->i_mapping, pgoff, lpages, pages);\r\nif (nr != lpages)\r\ngoto out_free_pages;\r\nptr = pages;\r\npage = *ptr++;\r\npage++;\r\nfor (loop = lpages; loop > 1; loop--)\r\nif (*ptr++ != page++)\r\ngoto out_free_pages;\r\nret = (unsigned long) page_address(pages[0]);\r\nout_free_pages:\r\nptr = pages;\r\nfor (loop = nr; loop > 0; loop--)\r\nput_page(*ptr++);\r\nout_free:\r\nkfree(pages);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ramfs_nommu_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nif (!(vma->vm_flags & (VM_SHARED | VM_MAYSHARE)))\r\nreturn -ENOSYS;\r\nfile_accessed(file);\r\nvma->vm_ops = &generic_file_vm_ops;\r\nreturn 0;\r\n}
