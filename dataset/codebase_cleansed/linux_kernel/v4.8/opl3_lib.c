static void snd_opl2_command(struct snd_opl3 * opl3, unsigned short cmd, unsigned char val)\r\n{\r\nunsigned long flags;\r\nunsigned long port;\r\nport = (cmd & OPL3_RIGHT) ? opl3->r_port : opl3->l_port;\r\nspin_lock_irqsave(&opl3->reg_lock, flags);\r\noutb((unsigned char) cmd, port);\r\nudelay(10);\r\noutb((unsigned char) val, port + 1);\r\nudelay(30);\r\nspin_unlock_irqrestore(&opl3->reg_lock, flags);\r\n}\r\nstatic void snd_opl3_command(struct snd_opl3 * opl3, unsigned short cmd, unsigned char val)\r\n{\r\nunsigned long flags;\r\nunsigned long port;\r\nport = (cmd & OPL3_RIGHT) ? opl3->r_port : opl3->l_port;\r\nspin_lock_irqsave(&opl3->reg_lock, flags);\r\noutb((unsigned char) cmd, port);\r\ninb(opl3->l_port);\r\ninb(opl3->l_port);\r\noutb((unsigned char) val, port + 1);\r\ninb(opl3->l_port);\r\ninb(opl3->l_port);\r\nspin_unlock_irqrestore(&opl3->reg_lock, flags);\r\n}\r\nstatic int snd_opl3_detect(struct snd_opl3 * opl3)\r\n{\r\nunsigned char stat1, stat2, signature;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_TIMER1_MASK | OPL3_TIMER2_MASK);\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_IRQ_RESET);\r\nsignature = stat1 = inb(opl3->l_port);\r\nif ((stat1 & 0xe0) != 0x00) {\r\nsnd_printd("OPL3: stat1 = 0x%x\n", stat1);\r\nreturn -ENODEV;\r\n}\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER1, 0xff);\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_TIMER2_MASK | OPL3_TIMER1_START);\r\nudelay(200);\r\nstat2 = inb(opl3->l_port);\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_TIMER1_MASK | OPL3_TIMER2_MASK);\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_IRQ_RESET);\r\nif ((stat2 & 0xe0) != 0xc0) {\r\nsnd_printd("OPL3: stat2 = 0x%x\n", stat2);\r\nreturn -ENODEV;\r\n}\r\nif (opl3->hardware != OPL3_HW_AUTO)\r\nreturn 0;\r\nif (signature == 0x06) {\r\nopl3->hardware = OPL3_HW_OPL2;\r\n} else {\r\nif (snd_BUG_ON(!opl3->r_port))\r\nreturn -ENODEV;\r\nopl3->hardware = OPL3_HW_OPL3;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_timer1_start(struct snd_timer * timer)\r\n{\r\nunsigned long flags;\r\nunsigned char tmp;\r\nunsigned int ticks;\r\nstruct snd_opl3 *opl3;\r\nopl3 = snd_timer_chip(timer);\r\nspin_lock_irqsave(&opl3->timer_lock, flags);\r\nticks = timer->sticks;\r\ntmp = (opl3->timer_enable | OPL3_TIMER1_START) & ~OPL3_TIMER1_MASK;\r\nopl3->timer_enable = tmp;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER1, 256 - ticks);\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);\r\nspin_unlock_irqrestore(&opl3->timer_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_timer1_stop(struct snd_timer * timer)\r\n{\r\nunsigned long flags;\r\nunsigned char tmp;\r\nstruct snd_opl3 *opl3;\r\nopl3 = snd_timer_chip(timer);\r\nspin_lock_irqsave(&opl3->timer_lock, flags);\r\ntmp = (opl3->timer_enable | OPL3_TIMER1_MASK) & ~OPL3_TIMER1_START;\r\nopl3->timer_enable = tmp;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);\r\nspin_unlock_irqrestore(&opl3->timer_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_timer2_start(struct snd_timer * timer)\r\n{\r\nunsigned long flags;\r\nunsigned char tmp;\r\nunsigned int ticks;\r\nstruct snd_opl3 *opl3;\r\nopl3 = snd_timer_chip(timer);\r\nspin_lock_irqsave(&opl3->timer_lock, flags);\r\nticks = timer->sticks;\r\ntmp = (opl3->timer_enable | OPL3_TIMER2_START) & ~OPL3_TIMER2_MASK;\r\nopl3->timer_enable = tmp;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER2, 256 - ticks);\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);\r\nspin_unlock_irqrestore(&opl3->timer_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_timer2_stop(struct snd_timer * timer)\r\n{\r\nunsigned long flags;\r\nunsigned char tmp;\r\nstruct snd_opl3 *opl3;\r\nopl3 = snd_timer_chip(timer);\r\nspin_lock_irqsave(&opl3->timer_lock, flags);\r\ntmp = (opl3->timer_enable | OPL3_TIMER2_MASK) & ~OPL3_TIMER2_START;\r\nopl3->timer_enable = tmp;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);\r\nspin_unlock_irqrestore(&opl3->timer_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_timer1_init(struct snd_opl3 * opl3, int timer_no)\r\n{\r\nstruct snd_timer *timer = NULL;\r\nstruct snd_timer_id tid;\r\nint err;\r\ntid.dev_class = SNDRV_TIMER_CLASS_CARD;\r\ntid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\r\ntid.card = opl3->card->number;\r\ntid.device = timer_no;\r\ntid.subdevice = 0;\r\nif ((err = snd_timer_new(opl3->card, "AdLib timer #1", &tid, &timer)) >= 0) {\r\nstrcpy(timer->name, "AdLib timer #1");\r\ntimer->private_data = opl3;\r\ntimer->hw = snd_opl3_timer1;\r\n}\r\nopl3->timer1 = timer;\r\nreturn err;\r\n}\r\nstatic int snd_opl3_timer2_init(struct snd_opl3 * opl3, int timer_no)\r\n{\r\nstruct snd_timer *timer = NULL;\r\nstruct snd_timer_id tid;\r\nint err;\r\ntid.dev_class = SNDRV_TIMER_CLASS_CARD;\r\ntid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\r\ntid.card = opl3->card->number;\r\ntid.device = timer_no;\r\ntid.subdevice = 0;\r\nif ((err = snd_timer_new(opl3->card, "AdLib timer #2", &tid, &timer)) >= 0) {\r\nstrcpy(timer->name, "AdLib timer #2");\r\ntimer->private_data = opl3;\r\ntimer->hw = snd_opl3_timer2;\r\n}\r\nopl3->timer2 = timer;\r\nreturn err;\r\n}\r\nvoid snd_opl3_interrupt(struct snd_hwdep * hw)\r\n{\r\nunsigned char status;\r\nstruct snd_opl3 *opl3;\r\nstruct snd_timer *timer;\r\nif (hw == NULL)\r\nreturn;\r\nopl3 = hw->private_data;\r\nstatus = inb(opl3->l_port);\r\n#if 0\r\nsnd_printk(KERN_DEBUG "AdLib IRQ status = 0x%x\n", status);\r\n#endif\r\nif (!(status & 0x80))\r\nreturn;\r\nif (status & 0x40) {\r\ntimer = opl3->timer1;\r\nsnd_timer_interrupt(timer, timer->sticks);\r\n}\r\nif (status & 0x20) {\r\ntimer = opl3->timer2;\r\nsnd_timer_interrupt(timer, timer->sticks);\r\n}\r\n}\r\nstatic int snd_opl3_free(struct snd_opl3 *opl3)\r\n{\r\nif (snd_BUG_ON(!opl3))\r\nreturn -ENXIO;\r\nif (opl3->private_free)\r\nopl3->private_free(opl3);\r\nsnd_opl3_clear_patches(opl3);\r\nrelease_and_free_resource(opl3->res_l_port);\r\nrelease_and_free_resource(opl3->res_r_port);\r\nkfree(opl3);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_opl3 *opl3 = device->device_data;\r\nreturn snd_opl3_free(opl3);\r\n}\r\nint snd_opl3_new(struct snd_card *card,\r\nunsigned short hardware,\r\nstruct snd_opl3 **ropl3)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_opl3_dev_free,\r\n};\r\nstruct snd_opl3 *opl3;\r\nint err;\r\n*ropl3 = NULL;\r\nopl3 = kzalloc(sizeof(*opl3), GFP_KERNEL);\r\nif (opl3 == NULL) {\r\nsnd_printk(KERN_ERR "opl3: cannot allocate\n");\r\nreturn -ENOMEM;\r\n}\r\nopl3->card = card;\r\nopl3->hardware = hardware;\r\nspin_lock_init(&opl3->reg_lock);\r\nspin_lock_init(&opl3->timer_lock);\r\nif ((err = snd_device_new(card, SNDRV_DEV_CODEC, opl3, &ops)) < 0) {\r\nsnd_opl3_free(opl3);\r\nreturn err;\r\n}\r\n*ropl3 = opl3;\r\nreturn 0;\r\n}\r\nint snd_opl3_init(struct snd_opl3 *opl3)\r\n{\r\nif (! opl3->command) {\r\nprintk(KERN_ERR "snd_opl3_init: command not defined!\n");\r\nreturn -EINVAL;\r\n}\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TEST, OPL3_ENABLE_WAVE_SELECT);\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, 0x00);\r\nswitch (opl3->hardware & OPL3_HW_MASK) {\r\ncase OPL3_HW_OPL2:\r\nopl3->max_voices = MAX_OPL2_VOICES;\r\nbreak;\r\ncase OPL3_HW_OPL3:\r\ncase OPL3_HW_OPL4:\r\nopl3->max_voices = MAX_OPL3_VOICES;\r\nopl3->command(opl3, OPL3_RIGHT | OPL3_REG_MODE, OPL3_OPL3_ENABLE);\r\n}\r\nreturn 0;\r\n}\r\nint snd_opl3_create(struct snd_card *card,\r\nunsigned long l_port,\r\nunsigned long r_port,\r\nunsigned short hardware,\r\nint integrated,\r\nstruct snd_opl3 ** ropl3)\r\n{\r\nstruct snd_opl3 *opl3;\r\nint err;\r\n*ropl3 = NULL;\r\nif ((err = snd_opl3_new(card, hardware, &opl3)) < 0)\r\nreturn err;\r\nif (! integrated) {\r\nif ((opl3->res_l_port = request_region(l_port, 2, "OPL2/3 (left)")) == NULL) {\r\nsnd_printk(KERN_ERR "opl3: can't grab left port 0x%lx\n", l_port);\r\nsnd_device_free(card, opl3);\r\nreturn -EBUSY;\r\n}\r\nif (r_port != 0 &&\r\n(opl3->res_r_port = request_region(r_port, 2, "OPL2/3 (right)")) == NULL) {\r\nsnd_printk(KERN_ERR "opl3: can't grab right port 0x%lx\n", r_port);\r\nsnd_device_free(card, opl3);\r\nreturn -EBUSY;\r\n}\r\n}\r\nopl3->l_port = l_port;\r\nopl3->r_port = r_port;\r\nswitch (opl3->hardware) {\r\ncase OPL3_HW_OPL3_SV:\r\ncase OPL3_HW_OPL3_CS:\r\ncase OPL3_HW_OPL3_FM801:\r\nopl3->command = &snd_opl3_command;\r\nbreak;\r\ndefault:\r\nopl3->command = &snd_opl2_command;\r\nif ((err = snd_opl3_detect(opl3)) < 0) {\r\nsnd_printd("OPL2/3 chip not detected at 0x%lx/0x%lx\n",\r\nopl3->l_port, opl3->r_port);\r\nsnd_device_free(card, opl3);\r\nreturn err;\r\n}\r\nswitch (opl3->hardware & OPL3_HW_MASK) {\r\ncase OPL3_HW_OPL3:\r\ncase OPL3_HW_OPL4:\r\nopl3->command = &snd_opl3_command;\r\n}\r\n}\r\nsnd_opl3_init(opl3);\r\n*ropl3 = opl3;\r\nreturn 0;\r\n}\r\nint snd_opl3_timer_new(struct snd_opl3 * opl3, int timer1_dev, int timer2_dev)\r\n{\r\nint err;\r\nif (timer1_dev >= 0)\r\nif ((err = snd_opl3_timer1_init(opl3, timer1_dev)) < 0)\r\nreturn err;\r\nif (timer2_dev >= 0) {\r\nif ((err = snd_opl3_timer2_init(opl3, timer2_dev)) < 0) {\r\nsnd_device_free(opl3->card, opl3->timer1);\r\nopl3->timer1 = NULL;\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint snd_opl3_hwdep_new(struct snd_opl3 * opl3,\r\nint device, int seq_device,\r\nstruct snd_hwdep ** rhwdep)\r\n{\r\nstruct snd_hwdep *hw;\r\nstruct snd_card *card = opl3->card;\r\nint err;\r\nif (rhwdep)\r\n*rhwdep = NULL;\r\nif ((err = snd_hwdep_new(card, "OPL2/OPL3", device, &hw)) < 0) {\r\nsnd_device_free(card, opl3);\r\nreturn err;\r\n}\r\nhw->private_data = opl3;\r\nhw->exclusive = 1;\r\n#ifdef CONFIG_SND_OSSEMUL\r\nif (device == 0)\r\nhw->oss_type = SNDRV_OSS_DEVICE_TYPE_DMFM;\r\n#endif\r\nstrcpy(hw->name, hw->id);\r\nswitch (opl3->hardware & OPL3_HW_MASK) {\r\ncase OPL3_HW_OPL2:\r\nstrcpy(hw->name, "OPL2 FM");\r\nhw->iface = SNDRV_HWDEP_IFACE_OPL2;\r\nbreak;\r\ncase OPL3_HW_OPL3:\r\nstrcpy(hw->name, "OPL3 FM");\r\nhw->iface = SNDRV_HWDEP_IFACE_OPL3;\r\nbreak;\r\ncase OPL3_HW_OPL4:\r\nstrcpy(hw->name, "OPL4 FM");\r\nhw->iface = SNDRV_HWDEP_IFACE_OPL4;\r\nbreak;\r\n}\r\nhw->ops.open = snd_opl3_open;\r\nhw->ops.ioctl = snd_opl3_ioctl;\r\nhw->ops.write = snd_opl3_write;\r\nhw->ops.release = snd_opl3_release;\r\nopl3->hwdep = hw;\r\nopl3->seq_dev_num = seq_device;\r\n#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))\r\nif (snd_seq_device_new(card, seq_device, SNDRV_SEQ_DEV_ID_OPL3,\r\nsizeof(struct snd_opl3 *), &opl3->seq_dev) >= 0) {\r\nstrcpy(opl3->seq_dev->name, hw->name);\r\n*(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(opl3->seq_dev) = opl3;\r\n}\r\n#endif\r\nif (rhwdep)\r\n*rhwdep = hw;\r\nreturn 0;\r\n}\r\nstatic int __init alsa_opl3_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_opl3_exit(void)\r\n{\r\n}
