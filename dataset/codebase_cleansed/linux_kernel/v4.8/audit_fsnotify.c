static void audit_fsnotify_mark_free(struct audit_fsnotify_mark *audit_mark)\r\n{\r\nkfree(audit_mark->path);\r\nkfree(audit_mark);\r\n}\r\nstatic void audit_fsnotify_free_mark(struct fsnotify_mark *mark)\r\n{\r\nstruct audit_fsnotify_mark *audit_mark;\r\naudit_mark = container_of(mark, struct audit_fsnotify_mark, mark);\r\naudit_fsnotify_mark_free(audit_mark);\r\n}\r\nchar *audit_mark_path(struct audit_fsnotify_mark *mark)\r\n{\r\nreturn mark->path;\r\n}\r\nint audit_mark_compare(struct audit_fsnotify_mark *mark, unsigned long ino, dev_t dev)\r\n{\r\nif (mark->ino == AUDIT_INO_UNSET)\r\nreturn 0;\r\nreturn (mark->ino == ino) && (mark->dev == dev);\r\n}\r\nstatic void audit_update_mark(struct audit_fsnotify_mark *audit_mark,\r\nstruct inode *inode)\r\n{\r\naudit_mark->dev = inode ? inode->i_sb->s_dev : AUDIT_DEV_UNSET;\r\naudit_mark->ino = inode ? inode->i_ino : AUDIT_INO_UNSET;\r\n}\r\nstruct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pathname, int len)\r\n{\r\nstruct audit_fsnotify_mark *audit_mark;\r\nstruct path path;\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\nint ret;\r\nif (pathname[0] != '/' || pathname[len-1] == '/')\r\nreturn ERR_PTR(-EINVAL);\r\ndentry = kern_path_locked(pathname, &path);\r\nif (IS_ERR(dentry))\r\nreturn (void *)dentry;\r\ninode = path.dentry->d_inode;\r\ninode_unlock(inode);\r\naudit_mark = kzalloc(sizeof(*audit_mark), GFP_KERNEL);\r\nif (unlikely(!audit_mark)) {\r\naudit_mark = ERR_PTR(-ENOMEM);\r\ngoto out;\r\n}\r\nfsnotify_init_mark(&audit_mark->mark, audit_fsnotify_free_mark);\r\naudit_mark->mark.mask = AUDIT_FS_EVENTS;\r\naudit_mark->path = pathname;\r\naudit_update_mark(audit_mark, dentry->d_inode);\r\naudit_mark->rule = krule;\r\nret = fsnotify_add_mark(&audit_mark->mark, audit_fsnotify_group, inode, NULL, true);\r\nif (ret < 0) {\r\naudit_fsnotify_mark_free(audit_mark);\r\naudit_mark = ERR_PTR(ret);\r\n}\r\nout:\r\ndput(dentry);\r\npath_put(&path);\r\nreturn audit_mark;\r\n}\r\nstatic void audit_mark_log_rule_change(struct audit_fsnotify_mark *audit_mark, char *op)\r\n{\r\nstruct audit_buffer *ab;\r\nstruct audit_krule *rule = audit_mark->rule;\r\nif (!audit_enabled)\r\nreturn;\r\nab = audit_log_start(NULL, GFP_NOFS, AUDIT_CONFIG_CHANGE);\r\nif (unlikely(!ab))\r\nreturn;\r\naudit_log_format(ab, "auid=%u ses=%u op=",\r\nfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\r\naudit_get_sessionid(current));\r\naudit_log_string(ab, op);\r\naudit_log_format(ab, " path=");\r\naudit_log_untrustedstring(ab, audit_mark->path);\r\naudit_log_key(ab, rule->filterkey);\r\naudit_log_format(ab, " list=%d res=1", rule->listnr);\r\naudit_log_end(ab);\r\n}\r\nvoid audit_remove_mark(struct audit_fsnotify_mark *audit_mark)\r\n{\r\nfsnotify_destroy_mark(&audit_mark->mark, audit_fsnotify_group);\r\nfsnotify_put_mark(&audit_mark->mark);\r\n}\r\nvoid audit_remove_mark_rule(struct audit_krule *krule)\r\n{\r\nstruct audit_fsnotify_mark *mark = krule->exe;\r\naudit_remove_mark(mark);\r\n}\r\nstatic void audit_autoremove_mark_rule(struct audit_fsnotify_mark *audit_mark)\r\n{\r\nstruct audit_krule *rule = audit_mark->rule;\r\nstruct audit_entry *entry = container_of(rule, struct audit_entry, rule);\r\naudit_mark_log_rule_change(audit_mark, "autoremove_rule");\r\naudit_del_rule(entry);\r\n}\r\nstatic int audit_mark_handle_event(struct fsnotify_group *group,\r\nstruct inode *to_tell,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmount_mark,\r\nu32 mask, void *data, int data_type,\r\nconst unsigned char *dname, u32 cookie)\r\n{\r\nstruct audit_fsnotify_mark *audit_mark;\r\nstruct inode *inode = NULL;\r\naudit_mark = container_of(inode_mark, struct audit_fsnotify_mark, mark);\r\nBUG_ON(group != audit_fsnotify_group);\r\nswitch (data_type) {\r\ncase (FSNOTIFY_EVENT_PATH):\r\ninode = ((struct path *)data)->dentry->d_inode;\r\nbreak;\r\ncase (FSNOTIFY_EVENT_INODE):\r\ninode = (struct inode *)data;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n};\r\nif (mask & (FS_CREATE|FS_MOVED_TO|FS_DELETE|FS_MOVED_FROM)) {\r\nif (audit_compare_dname_path(dname, audit_mark->path, AUDIT_NAME_FULL))\r\nreturn 0;\r\naudit_update_mark(audit_mark, inode);\r\n} else if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF))\r\naudit_autoremove_mark_rule(audit_mark);\r\nreturn 0;\r\n}\r\nstatic int __init audit_fsnotify_init(void)\r\n{\r\naudit_fsnotify_group = fsnotify_alloc_group(&audit_mark_fsnotify_ops);\r\nif (IS_ERR(audit_fsnotify_group)) {\r\naudit_fsnotify_group = NULL;\r\naudit_panic("cannot create audit fsnotify group");\r\n}\r\nreturn 0;\r\n}
