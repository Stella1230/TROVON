static int qat_uclo_init_ae_data(struct icp_qat_uclo_objhandle *obj_handle,\r\nunsigned int ae, unsigned int image_num)\r\n{\r\nstruct icp_qat_uclo_aedata *ae_data;\r\nstruct icp_qat_uclo_encapme *encap_image;\r\nstruct icp_qat_uclo_page *page = NULL;\r\nstruct icp_qat_uclo_aeslice *ae_slice = NULL;\r\nae_data = &obj_handle->ae_data[ae];\r\nencap_image = &obj_handle->ae_uimage[image_num];\r\nae_slice = &ae_data->ae_slices[ae_data->slice_num];\r\nae_slice->encap_image = encap_image;\r\nif (encap_image->img_ptr) {\r\nae_slice->ctx_mask_assigned =\r\nencap_image->img_ptr->ctx_assigned;\r\nae_data->eff_ustore_size = obj_handle->ustore_phy_size;\r\n} else {\r\nae_slice->ctx_mask_assigned = 0;\r\n}\r\nae_slice->region = kzalloc(sizeof(*ae_slice->region), GFP_KERNEL);\r\nif (!ae_slice->region)\r\nreturn -ENOMEM;\r\nae_slice->page = kzalloc(sizeof(*ae_slice->page), GFP_KERNEL);\r\nif (!ae_slice->page)\r\ngoto out_err;\r\npage = ae_slice->page;\r\npage->encap_page = encap_image->page;\r\nae_slice->page->region = ae_slice->region;\r\nae_data->slice_num++;\r\nreturn 0;\r\nout_err:\r\nkfree(ae_slice->region);\r\nae_slice->region = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic int qat_uclo_free_ae_data(struct icp_qat_uclo_aedata *ae_data)\r\n{\r\nunsigned int i;\r\nif (!ae_data) {\r\npr_err("QAT: bad argument, ae_data is NULL\n ");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ae_data->slice_num; i++) {\r\nkfree(ae_data->ae_slices[i].region);\r\nae_data->ae_slices[i].region = NULL;\r\nkfree(ae_data->ae_slices[i].page);\r\nae_data->ae_slices[i].page = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic char *qat_uclo_get_string(struct icp_qat_uof_strtable *str_table,\r\nunsigned int str_offset)\r\n{\r\nif ((!str_table->table_len) || (str_offset > str_table->table_len))\r\nreturn NULL;\r\nreturn (char *)(((uintptr_t)(str_table->strings)) + str_offset);\r\n}\r\nstatic int qat_uclo_check_uof_format(struct icp_qat_uof_filehdr *hdr)\r\n{\r\nint maj = hdr->maj_ver & 0xff;\r\nint min = hdr->min_ver & 0xff;\r\nif (hdr->file_id != ICP_QAT_UOF_FID) {\r\npr_err("QAT: Invalid header 0x%x\n", hdr->file_id);\r\nreturn -EINVAL;\r\n}\r\nif (min != ICP_QAT_UOF_MINVER || maj != ICP_QAT_UOF_MAJVER) {\r\npr_err("QAT: bad UOF version, major 0x%x, minor 0x%x\n",\r\nmaj, min);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_check_suof_format(struct icp_qat_suof_filehdr *suof_hdr)\r\n{\r\nint maj = suof_hdr->maj_ver & 0xff;\r\nint min = suof_hdr->min_ver & 0xff;\r\nif (suof_hdr->file_id != ICP_QAT_SUOF_FID) {\r\npr_err("QAT: invalid header 0x%x\n", suof_hdr->file_id);\r\nreturn -EINVAL;\r\n}\r\nif (suof_hdr->fw_type != 0) {\r\npr_err("QAT: unsupported firmware type\n");\r\nreturn -EINVAL;\r\n}\r\nif (suof_hdr->num_chunks <= 0x1) {\r\npr_err("QAT: SUOF chunk amount is incorrect\n");\r\nreturn -EINVAL;\r\n}\r\nif (maj != ICP_QAT_SUOF_MAJVER || min != ICP_QAT_SUOF_MINVER) {\r\npr_err("QAT: bad SUOF version, major 0x%x, minor 0x%x\n",\r\nmaj, min);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qat_uclo_wr_sram_by_words(struct icp_qat_fw_loader_handle *handle,\r\nunsigned int addr, unsigned int *val,\r\nunsigned int num_in_bytes)\r\n{\r\nunsigned int outval;\r\nunsigned char *ptr = (unsigned char *)val;\r\nwhile (num_in_bytes) {\r\nmemcpy(&outval, ptr, 4);\r\nSRAM_WRITE(handle, addr, outval);\r\nnum_in_bytes -= 4;\r\nptr += 4;\r\naddr += 4;\r\n}\r\n}\r\nstatic void qat_uclo_wr_umem_by_words(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int addr,\r\nunsigned int *val,\r\nunsigned int num_in_bytes)\r\n{\r\nunsigned int outval;\r\nunsigned char *ptr = (unsigned char *)val;\r\naddr >>= 0x2;\r\nwhile (num_in_bytes) {\r\nmemcpy(&outval, ptr, 4);\r\nqat_hal_wr_umem(handle, ae, addr++, 1, &outval);\r\nnum_in_bytes -= 4;\r\nptr += 4;\r\n}\r\n}\r\nstatic void qat_uclo_batch_wr_umem(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae,\r\nstruct icp_qat_uof_batch_init\r\n*umem_init_header)\r\n{\r\nstruct icp_qat_uof_batch_init *umem_init;\r\nif (!umem_init_header)\r\nreturn;\r\numem_init = umem_init_header->next;\r\nwhile (umem_init) {\r\nunsigned int addr, *value, size;\r\nae = umem_init->ae;\r\naddr = umem_init->addr;\r\nvalue = umem_init->value;\r\nsize = umem_init->size;\r\nqat_uclo_wr_umem_by_words(handle, ae, addr, value, size);\r\numem_init = umem_init->next;\r\n}\r\n}\r\nstatic void\r\nqat_uclo_cleanup_batch_init_list(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_batch_init **base)\r\n{\r\nstruct icp_qat_uof_batch_init *umem_init;\r\numem_init = *base;\r\nwhile (umem_init) {\r\nstruct icp_qat_uof_batch_init *pre;\r\npre = umem_init;\r\numem_init = umem_init->next;\r\nkfree(pre);\r\n}\r\n*base = NULL;\r\n}\r\nstatic int qat_uclo_parse_num(char *str, unsigned int *num)\r\n{\r\nchar buf[16] = {0};\r\nunsigned long ae = 0;\r\nint i;\r\nstrncpy(buf, str, 15);\r\nfor (i = 0; i < 16; i++) {\r\nif (!isdigit(buf[i])) {\r\nbuf[i] = '\0';\r\nbreak;\r\n}\r\n}\r\nif ((kstrtoul(buf, 10, &ae)))\r\nreturn -EFAULT;\r\n*num = (unsigned int)ae;\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_fetch_initmem_ae(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_initmem *init_mem,\r\nunsigned int size_range, unsigned int *ae)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nchar *str;\r\nif ((init_mem->addr + init_mem->num_in_bytes) > (size_range << 0x2)) {\r\npr_err("QAT: initmem is out of range");\r\nreturn -EINVAL;\r\n}\r\nif (init_mem->scope != ICP_QAT_UOF_LOCAL_SCOPE) {\r\npr_err("QAT: Memory scope for init_mem error\n");\r\nreturn -EINVAL;\r\n}\r\nstr = qat_uclo_get_string(&obj_handle->str_table, init_mem->sym_name);\r\nif (!str) {\r\npr_err("QAT: AE name assigned in UOF init table is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nif (qat_uclo_parse_num(str, ae)) {\r\npr_err("QAT: Parse num for AE number failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (*ae >= ICP_QAT_UCLO_MAX_AE) {\r\npr_err("QAT: ae %d out of range\n", *ae);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_create_batch_init_list(struct icp_qat_fw_loader_handle\r\n*handle, struct icp_qat_uof_initmem\r\n*init_mem, unsigned int ae,\r\nstruct icp_qat_uof_batch_init\r\n**init_tab_base)\r\n{\r\nstruct icp_qat_uof_batch_init *init_header, *tail;\r\nstruct icp_qat_uof_batch_init *mem_init, *tail_old;\r\nstruct icp_qat_uof_memvar_attr *mem_val_attr;\r\nunsigned int i, flag = 0;\r\nmem_val_attr =\r\n(struct icp_qat_uof_memvar_attr *)((uintptr_t)init_mem +\r\nsizeof(struct icp_qat_uof_initmem));\r\ninit_header = *init_tab_base;\r\nif (!init_header) {\r\ninit_header = kzalloc(sizeof(*init_header), GFP_KERNEL);\r\nif (!init_header)\r\nreturn -ENOMEM;\r\ninit_header->size = 1;\r\n*init_tab_base = init_header;\r\nflag = 1;\r\n}\r\ntail_old = init_header;\r\nwhile (tail_old->next)\r\ntail_old = tail_old->next;\r\ntail = tail_old;\r\nfor (i = 0; i < init_mem->val_attr_num; i++) {\r\nmem_init = kzalloc(sizeof(*mem_init), GFP_KERNEL);\r\nif (!mem_init)\r\ngoto out_err;\r\nmem_init->ae = ae;\r\nmem_init->addr = init_mem->addr + mem_val_attr->offset_in_byte;\r\nmem_init->value = &mem_val_attr->value;\r\nmem_init->size = 4;\r\nmem_init->next = NULL;\r\ntail->next = mem_init;\r\ntail = mem_init;\r\ninit_header->size += qat_hal_get_ins_num();\r\nmem_val_attr++;\r\n}\r\nreturn 0;\r\nout_err:\r\nwhile (tail_old) {\r\nmem_init = tail_old->next;\r\nkfree(tail_old);\r\ntail_old = mem_init;\r\n}\r\nif (flag)\r\nkfree(*init_tab_base);\r\nreturn -ENOMEM;\r\n}\r\nstatic int qat_uclo_init_lmem_seg(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_initmem *init_mem)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int ae;\r\nif (qat_uclo_fetch_initmem_ae(handle, init_mem,\r\nICP_QAT_UCLO_MAX_LMEM_REG, &ae))\r\nreturn -EINVAL;\r\nif (qat_uclo_create_batch_init_list(handle, init_mem, ae,\r\n&obj_handle->lm_init_tab[ae]))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_umem_seg(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_initmem *init_mem)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int ae, ustore_size, uaddr, i;\r\nustore_size = obj_handle->ustore_phy_size;\r\nif (qat_uclo_fetch_initmem_ae(handle, init_mem, ustore_size, &ae))\r\nreturn -EINVAL;\r\nif (qat_uclo_create_batch_init_list(handle, init_mem, ae,\r\n&obj_handle->umem_init_tab[ae]))\r\nreturn -EINVAL;\r\nuaddr = (init_mem->addr + init_mem->num_in_bytes) >> 0x2;\r\nfor (i = 0; i < obj_handle->ae_data[ae].slice_num; i++) {\r\nif (obj_handle->ae_data[ae].ae_slices[i].\r\nencap_image->uwords_num < uaddr)\r\nobj_handle->ae_data[ae].ae_slices[i].\r\nencap_image->uwords_num = uaddr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_ae_memory(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_initmem *init_mem)\r\n{\r\nswitch (init_mem->region) {\r\ncase ICP_QAT_UOF_LMEM_REGION:\r\nif (qat_uclo_init_lmem_seg(handle, init_mem))\r\nreturn -EINVAL;\r\nbreak;\r\ncase ICP_QAT_UOF_UMEM_REGION:\r\nif (qat_uclo_init_umem_seg(handle, init_mem))\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\npr_err("QAT: initmem region error. region type=0x%x\n",\r\ninit_mem->region);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_ustore(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uclo_encapme *image)\r\n{\r\nunsigned int i;\r\nstruct icp_qat_uclo_encap_page *page;\r\nstruct icp_qat_uof_image *uof_image;\r\nunsigned char ae;\r\nunsigned int ustore_size;\r\nunsigned int patt_pos;\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nuint64_t *fill_data;\r\nuof_image = image->img_ptr;\r\nfill_data = kcalloc(ICP_QAT_UCLO_MAX_USTORE, sizeof(uint64_t),\r\nGFP_KERNEL);\r\nif (!fill_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ICP_QAT_UCLO_MAX_USTORE; i++)\r\nmemcpy(&fill_data[i], &uof_image->fill_pattern,\r\nsizeof(uint64_t));\r\npage = image->page;\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!test_bit(ae, (unsigned long *)&uof_image->ae_assigned))\r\ncontinue;\r\nustore_size = obj_handle->ae_data[ae].eff_ustore_size;\r\npatt_pos = page->beg_addr_p + page->micro_words_num;\r\nqat_hal_wr_uwords(handle, (unsigned char)ae, 0,\r\npage->beg_addr_p, &fill_data[0]);\r\nqat_hal_wr_uwords(handle, (unsigned char)ae, patt_pos,\r\nustore_size - patt_pos + 1,\r\n&fill_data[page->beg_addr_p]);\r\n}\r\nkfree(fill_data);\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_memory(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nint i, ae;\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nstruct icp_qat_uof_initmem *initmem = obj_handle->init_mem_tab.init_mem;\r\nfor (i = 0; i < obj_handle->init_mem_tab.entry_num; i++) {\r\nif (initmem->num_in_bytes) {\r\nif (qat_uclo_init_ae_memory(handle, initmem))\r\nreturn -EINVAL;\r\n}\r\ninitmem = (struct icp_qat_uof_initmem *)((uintptr_t)(\r\n(uintptr_t)initmem +\r\nsizeof(struct icp_qat_uof_initmem)) +\r\n(sizeof(struct icp_qat_uof_memvar_attr) *\r\ninitmem->val_attr_num));\r\n}\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (qat_hal_batch_wr_lm(handle, ae,\r\nobj_handle->lm_init_tab[ae])) {\r\npr_err("QAT: fail to batch init lmem for AE %d\n", ae);\r\nreturn -EINVAL;\r\n}\r\nqat_uclo_cleanup_batch_init_list(handle,\r\n&obj_handle->lm_init_tab[ae]);\r\nqat_uclo_batch_wr_umem(handle, ae,\r\nobj_handle->umem_init_tab[ae]);\r\nqat_uclo_cleanup_batch_init_list(handle,\r\n&obj_handle->\r\numem_init_tab[ae]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void *qat_uclo_find_chunk(struct icp_qat_uof_objhdr *obj_hdr,\r\nchar *chunk_id, void *cur)\r\n{\r\nint i;\r\nstruct icp_qat_uof_chunkhdr *chunk_hdr =\r\n(struct icp_qat_uof_chunkhdr *)\r\n((uintptr_t)obj_hdr + sizeof(struct icp_qat_uof_objhdr));\r\nfor (i = 0; i < obj_hdr->num_chunks; i++) {\r\nif ((cur < (void *)&chunk_hdr[i]) &&\r\n!strncmp(chunk_hdr[i].chunk_id, chunk_id,\r\nICP_QAT_UOF_OBJID_LEN)) {\r\nreturn &chunk_hdr[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int qat_uclo_calc_checksum(unsigned int reg, int ch)\r\n{\r\nint i;\r\nunsigned int topbit = 1 << 0xF;\r\nunsigned int inbyte = (unsigned int)((reg >> 0x18) ^ ch);\r\nreg ^= inbyte << 0x8;\r\nfor (i = 0; i < 0x8; i++) {\r\nif (reg & topbit)\r\nreg = (reg << 1) ^ 0x1021;\r\nelse\r\nreg <<= 1;\r\n}\r\nreturn reg & 0xFFFF;\r\n}\r\nstatic unsigned int qat_uclo_calc_str_checksum(char *ptr, int num)\r\n{\r\nunsigned int chksum = 0;\r\nif (ptr)\r\nwhile (num--)\r\nchksum = qat_uclo_calc_checksum(chksum, *ptr++);\r\nreturn chksum;\r\n}\r\nstatic struct icp_qat_uclo_objhdr *\r\nqat_uclo_map_chunk(char *buf, struct icp_qat_uof_filehdr *file_hdr,\r\nchar *chunk_id)\r\n{\r\nstruct icp_qat_uof_filechunkhdr *file_chunk;\r\nstruct icp_qat_uclo_objhdr *obj_hdr;\r\nchar *chunk;\r\nint i;\r\nfile_chunk = (struct icp_qat_uof_filechunkhdr *)\r\n(buf + sizeof(struct icp_qat_uof_filehdr));\r\nfor (i = 0; i < file_hdr->num_chunks; i++) {\r\nif (!strncmp(file_chunk->chunk_id, chunk_id,\r\nICP_QAT_UOF_OBJID_LEN)) {\r\nchunk = buf + file_chunk->offset;\r\nif (file_chunk->checksum != qat_uclo_calc_str_checksum(\r\nchunk, file_chunk->size))\r\nbreak;\r\nobj_hdr = kzalloc(sizeof(*obj_hdr), GFP_KERNEL);\r\nif (!obj_hdr)\r\nbreak;\r\nobj_hdr->file_buff = chunk;\r\nobj_hdr->checksum = file_chunk->checksum;\r\nobj_hdr->size = file_chunk->size;\r\nreturn obj_hdr;\r\n}\r\nfile_chunk++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int\r\nqat_uclo_check_image_compat(struct icp_qat_uof_encap_obj *encap_uof_obj,\r\nstruct icp_qat_uof_image *image)\r\n{\r\nstruct icp_qat_uof_objtable *uc_var_tab, *imp_var_tab, *imp_expr_tab;\r\nstruct icp_qat_uof_objtable *neigh_reg_tab;\r\nstruct icp_qat_uof_code_page *code_page;\r\ncode_page = (struct icp_qat_uof_code_page *)\r\n((char *)image + sizeof(struct icp_qat_uof_image));\r\nuc_var_tab = (struct icp_qat_uof_objtable *)(encap_uof_obj->beg_uof +\r\ncode_page->uc_var_tab_offset);\r\nimp_var_tab = (struct icp_qat_uof_objtable *)(encap_uof_obj->beg_uof +\r\ncode_page->imp_var_tab_offset);\r\nimp_expr_tab = (struct icp_qat_uof_objtable *)\r\n(encap_uof_obj->beg_uof +\r\ncode_page->imp_expr_tab_offset);\r\nif (uc_var_tab->entry_num || imp_var_tab->entry_num ||\r\nimp_expr_tab->entry_num) {\r\npr_err("QAT: UOF can't contain imported variable to be parsed");\r\nreturn -EINVAL;\r\n}\r\nneigh_reg_tab = (struct icp_qat_uof_objtable *)\r\n(encap_uof_obj->beg_uof +\r\ncode_page->neigh_reg_tab_offset);\r\nif (neigh_reg_tab->entry_num) {\r\npr_err("QAT: UOF can't contain shared control store feature");\r\nreturn -EINVAL;\r\n}\r\nif (image->numpages > 1) {\r\npr_err("QAT: UOF can't contain multiple pages");\r\nreturn -EINVAL;\r\n}\r\nif (ICP_QAT_SHARED_USTORE_MODE(image->ae_mode)) {\r\npr_err("QAT: UOF can't use shared control store feature");\r\nreturn -EFAULT;\r\n}\r\nif (RELOADABLE_CTX_SHARED_MODE(image->ae_mode)) {\r\npr_err("QAT: UOF can't use reloadable feature");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qat_uclo_map_image_page(struct icp_qat_uof_encap_obj\r\n*encap_uof_obj,\r\nstruct icp_qat_uof_image *img,\r\nstruct icp_qat_uclo_encap_page *page)\r\n{\r\nstruct icp_qat_uof_code_page *code_page;\r\nstruct icp_qat_uof_code_area *code_area;\r\nstruct icp_qat_uof_objtable *uword_block_tab;\r\nstruct icp_qat_uof_uword_block *uwblock;\r\nint i;\r\ncode_page = (struct icp_qat_uof_code_page *)\r\n((char *)img + sizeof(struct icp_qat_uof_image));\r\npage->def_page = code_page->def_page;\r\npage->page_region = code_page->page_region;\r\npage->beg_addr_v = code_page->beg_addr_v;\r\npage->beg_addr_p = code_page->beg_addr_p;\r\ncode_area = (struct icp_qat_uof_code_area *)(encap_uof_obj->beg_uof +\r\ncode_page->code_area_offset);\r\npage->micro_words_num = code_area->micro_words_num;\r\nuword_block_tab = (struct icp_qat_uof_objtable *)\r\n(encap_uof_obj->beg_uof +\r\ncode_area->uword_block_tab);\r\npage->uwblock_num = uword_block_tab->entry_num;\r\nuwblock = (struct icp_qat_uof_uword_block *)((char *)uword_block_tab +\r\nsizeof(struct icp_qat_uof_objtable));\r\npage->uwblock = (struct icp_qat_uclo_encap_uwblock *)uwblock;\r\nfor (i = 0; i < uword_block_tab->entry_num; i++)\r\npage->uwblock[i].micro_words =\r\n(uintptr_t)encap_uof_obj->beg_uof + uwblock[i].uword_offset;\r\n}\r\nstatic int qat_uclo_map_uimage(struct icp_qat_uclo_objhandle *obj_handle,\r\nstruct icp_qat_uclo_encapme *ae_uimage,\r\nint max_image)\r\n{\r\nint i, j;\r\nstruct icp_qat_uof_chunkhdr *chunk_hdr = NULL;\r\nstruct icp_qat_uof_image *image;\r\nstruct icp_qat_uof_objtable *ae_regtab;\r\nstruct icp_qat_uof_objtable *init_reg_sym_tab;\r\nstruct icp_qat_uof_objtable *sbreak_tab;\r\nstruct icp_qat_uof_encap_obj *encap_uof_obj =\r\n&obj_handle->encap_uof_obj;\r\nfor (j = 0; j < max_image; j++) {\r\nchunk_hdr = qat_uclo_find_chunk(encap_uof_obj->obj_hdr,\r\nICP_QAT_UOF_IMAG, chunk_hdr);\r\nif (!chunk_hdr)\r\nbreak;\r\nimage = (struct icp_qat_uof_image *)(encap_uof_obj->beg_uof +\r\nchunk_hdr->offset);\r\nae_regtab = (struct icp_qat_uof_objtable *)\r\n(image->reg_tab_offset +\r\nobj_handle->obj_hdr->file_buff);\r\nae_uimage[j].ae_reg_num = ae_regtab->entry_num;\r\nae_uimage[j].ae_reg = (struct icp_qat_uof_ae_reg *)\r\n(((char *)ae_regtab) +\r\nsizeof(struct icp_qat_uof_objtable));\r\ninit_reg_sym_tab = (struct icp_qat_uof_objtable *)\r\n(image->init_reg_sym_tab +\r\nobj_handle->obj_hdr->file_buff);\r\nae_uimage[j].init_regsym_num = init_reg_sym_tab->entry_num;\r\nae_uimage[j].init_regsym = (struct icp_qat_uof_init_regsym *)\r\n(((char *)init_reg_sym_tab) +\r\nsizeof(struct icp_qat_uof_objtable));\r\nsbreak_tab = (struct icp_qat_uof_objtable *)\r\n(image->sbreak_tab + obj_handle->obj_hdr->file_buff);\r\nae_uimage[j].sbreak_num = sbreak_tab->entry_num;\r\nae_uimage[j].sbreak = (struct icp_qat_uof_sbreak *)\r\n(((char *)sbreak_tab) +\r\nsizeof(struct icp_qat_uof_objtable));\r\nae_uimage[j].img_ptr = image;\r\nif (qat_uclo_check_image_compat(encap_uof_obj, image))\r\ngoto out_err;\r\nae_uimage[j].page =\r\nkzalloc(sizeof(struct icp_qat_uclo_encap_page),\r\nGFP_KERNEL);\r\nif (!ae_uimage[j].page)\r\ngoto out_err;\r\nqat_uclo_map_image_page(encap_uof_obj, image,\r\nae_uimage[j].page);\r\n}\r\nreturn j;\r\nout_err:\r\nfor (i = 0; i < j; i++)\r\nkfree(ae_uimage[i].page);\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_map_ae(struct icp_qat_fw_loader_handle *handle, int max_ae)\r\n{\r\nint i, ae;\r\nint mflag = 0;\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nfor (ae = 0; ae < max_ae; ae++) {\r\nif (!test_bit(ae,\r\n(unsigned long *)&handle->hal_handle->ae_mask))\r\ncontinue;\r\nfor (i = 0; i < obj_handle->uimage_num; i++) {\r\nif (!test_bit(ae, (unsigned long *)\r\n&obj_handle->ae_uimage[i].img_ptr->ae_assigned))\r\ncontinue;\r\nmflag = 1;\r\nif (qat_uclo_init_ae_data(obj_handle, ae, i))\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!mflag) {\r\npr_err("QAT: uimage uses AE not set");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct icp_qat_uof_strtable *\r\nqat_uclo_map_str_table(struct icp_qat_uclo_objhdr *obj_hdr,\r\nchar *tab_name, struct icp_qat_uof_strtable *str_table)\r\n{\r\nstruct icp_qat_uof_chunkhdr *chunk_hdr;\r\nchunk_hdr = qat_uclo_find_chunk((struct icp_qat_uof_objhdr *)\r\nobj_hdr->file_buff, tab_name, NULL);\r\nif (chunk_hdr) {\r\nint hdr_size;\r\nmemcpy(&str_table->table_len, obj_hdr->file_buff +\r\nchunk_hdr->offset, sizeof(str_table->table_len));\r\nhdr_size = (char *)&str_table->strings - (char *)str_table;\r\nstr_table->strings = (uintptr_t)obj_hdr->file_buff +\r\nchunk_hdr->offset + hdr_size;\r\nreturn str_table;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nqat_uclo_map_initmem_table(struct icp_qat_uof_encap_obj *encap_uof_obj,\r\nstruct icp_qat_uclo_init_mem_table *init_mem_tab)\r\n{\r\nstruct icp_qat_uof_chunkhdr *chunk_hdr;\r\nchunk_hdr = qat_uclo_find_chunk(encap_uof_obj->obj_hdr,\r\nICP_QAT_UOF_IMEM, NULL);\r\nif (chunk_hdr) {\r\nmemmove(&init_mem_tab->entry_num, encap_uof_obj->beg_uof +\r\nchunk_hdr->offset, sizeof(unsigned int));\r\ninit_mem_tab->init_mem = (struct icp_qat_uof_initmem *)\r\n(encap_uof_obj->beg_uof + chunk_hdr->offset +\r\nsizeof(unsigned int));\r\n}\r\n}\r\nstatic unsigned int\r\nqat_uclo_get_dev_type(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nswitch (handle->pci_dev->device) {\r\ncase ADF_DH895XCC_PCI_DEVICE_ID:\r\nreturn ICP_QAT_AC_895XCC_DEV_TYPE;\r\ncase ADF_C62X_PCI_DEVICE_ID:\r\nreturn ICP_QAT_AC_C62X_DEV_TYPE;\r\ncase ADF_C3XXX_PCI_DEVICE_ID:\r\nreturn ICP_QAT_AC_C3XXX_DEV_TYPE;\r\ndefault:\r\npr_err("QAT: unsupported device 0x%x\n",\r\nhandle->pci_dev->device);\r\nreturn 0;\r\n}\r\n}\r\nstatic int qat_uclo_check_uof_compat(struct icp_qat_uclo_objhandle *obj_handle)\r\n{\r\nunsigned int maj_ver, prod_type = obj_handle->prod_type;\r\nif (!(prod_type & obj_handle->encap_uof_obj.obj_hdr->ac_dev_type)) {\r\npr_err("QAT: UOF type 0x%x doesn't match with platform 0x%x\n",\r\nobj_handle->encap_uof_obj.obj_hdr->ac_dev_type,\r\nprod_type);\r\nreturn -EINVAL;\r\n}\r\nmaj_ver = obj_handle->prod_rev & 0xff;\r\nif ((obj_handle->encap_uof_obj.obj_hdr->max_cpu_ver < maj_ver) ||\r\n(obj_handle->encap_uof_obj.obj_hdr->min_cpu_ver > maj_ver)) {\r\npr_err("QAT: UOF majVer 0x%x out of range\n", maj_ver);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_reg(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx_mask,\r\nenum icp_qat_uof_regtype reg_type,\r\nunsigned short reg_addr, unsigned int value)\r\n{\r\nswitch (reg_type) {\r\ncase ICP_GPA_ABS:\r\ncase ICP_GPB_ABS:\r\nctx_mask = 0;\r\ncase ICP_GPA_REL:\r\ncase ICP_GPB_REL:\r\nreturn qat_hal_init_gpr(handle, ae, ctx_mask, reg_type,\r\nreg_addr, value);\r\ncase ICP_SR_ABS:\r\ncase ICP_DR_ABS:\r\ncase ICP_SR_RD_ABS:\r\ncase ICP_DR_RD_ABS:\r\nctx_mask = 0;\r\ncase ICP_SR_REL:\r\ncase ICP_DR_REL:\r\ncase ICP_SR_RD_REL:\r\ncase ICP_DR_RD_REL:\r\nreturn qat_hal_init_rd_xfer(handle, ae, ctx_mask, reg_type,\r\nreg_addr, value);\r\ncase ICP_SR_WR_ABS:\r\ncase ICP_DR_WR_ABS:\r\nctx_mask = 0;\r\ncase ICP_SR_WR_REL:\r\ncase ICP_DR_WR_REL:\r\nreturn qat_hal_init_wr_xfer(handle, ae, ctx_mask, reg_type,\r\nreg_addr, value);\r\ncase ICP_NEIGH_REL:\r\nreturn qat_hal_init_nn(handle, ae, ctx_mask, reg_addr, value);\r\ndefault:\r\npr_err("QAT: UOF uses not supported reg type 0x%x\n", reg_type);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_reg_sym(struct icp_qat_fw_loader_handle *handle,\r\nunsigned int ae,\r\nstruct icp_qat_uclo_encapme *encap_ae)\r\n{\r\nunsigned int i;\r\nunsigned char ctx_mask;\r\nstruct icp_qat_uof_init_regsym *init_regsym;\r\nif (ICP_QAT_CTX_MODE(encap_ae->img_ptr->ae_mode) ==\r\nICP_QAT_UCLO_MAX_CTX)\r\nctx_mask = 0xff;\r\nelse\r\nctx_mask = 0x55;\r\nfor (i = 0; i < encap_ae->init_regsym_num; i++) {\r\nunsigned int exp_res;\r\ninit_regsym = &encap_ae->init_regsym[i];\r\nexp_res = init_regsym->value;\r\nswitch (init_regsym->init_type) {\r\ncase ICP_QAT_UOF_INIT_REG:\r\nqat_uclo_init_reg(handle, ae, ctx_mask,\r\n(enum icp_qat_uof_regtype)\r\ninit_regsym->reg_type,\r\n(unsigned short)init_regsym->reg_addr,\r\nexp_res);\r\nbreak;\r\ncase ICP_QAT_UOF_INIT_REG_CTX:\r\nif (!((1 << init_regsym->ctx) & ctx_mask)) {\r\npr_err("QAT: invalid ctx num = 0x%x\n",\r\ninit_regsym->ctx);\r\nreturn -EINVAL;\r\n}\r\nqat_uclo_init_reg(handle, ae,\r\n(unsigned char)\r\n(1 << init_regsym->ctx),\r\n(enum icp_qat_uof_regtype)\r\ninit_regsym->reg_type,\r\n(unsigned short)init_regsym->reg_addr,\r\nexp_res);\r\nbreak;\r\ncase ICP_QAT_UOF_INIT_EXPR:\r\npr_err("QAT: INIT_EXPR feature not supported\n");\r\nreturn -EINVAL;\r\ncase ICP_QAT_UOF_INIT_EXPR_ENDIAN_SWAP:\r\npr_err("QAT: INIT_EXPR_ENDIAN_SWAP feature not supported\n");\r\nreturn -EINVAL;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_globals(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int s, ae;\r\nif (obj_handle->global_inited)\r\nreturn 0;\r\nif (obj_handle->init_mem_tab.entry_num) {\r\nif (qat_uclo_init_memory(handle)) {\r\npr_err("QAT: initialize memory failed\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nfor (s = 0; s < obj_handle->ae_data[ae].slice_num; s++) {\r\nif (!obj_handle->ae_data[ae].ae_slices[s].encap_image)\r\ncontinue;\r\nif (qat_uclo_init_reg_sym(handle, ae,\r\nobj_handle->ae_data[ae].\r\nae_slices[s].encap_image))\r\nreturn -EINVAL;\r\n}\r\n}\r\nobj_handle->global_inited = 1;\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_set_ae_mode(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nunsigned char ae, nn_mode, s;\r\nstruct icp_qat_uof_image *uof_image;\r\nstruct icp_qat_uclo_aedata *ae_data;\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!test_bit(ae,\r\n(unsigned long *)&handle->hal_handle->ae_mask))\r\ncontinue;\r\nae_data = &obj_handle->ae_data[ae];\r\nfor (s = 0; s < min_t(unsigned int, ae_data->slice_num,\r\nICP_QAT_UCLO_MAX_CTX); s++) {\r\nif (!obj_handle->ae_data[ae].ae_slices[s].encap_image)\r\ncontinue;\r\nuof_image = ae_data->ae_slices[s].encap_image->img_ptr;\r\nif (qat_hal_set_ae_ctx_mode(handle, ae,\r\n(char)ICP_QAT_CTX_MODE\r\n(uof_image->ae_mode))) {\r\npr_err("QAT: qat_hal_set_ae_ctx_mode error\n");\r\nreturn -EFAULT;\r\n}\r\nnn_mode = ICP_QAT_NN_MODE(uof_image->ae_mode);\r\nif (qat_hal_set_ae_nn_mode(handle, ae, nn_mode)) {\r\npr_err("QAT: qat_hal_set_ae_nn_mode error\n");\r\nreturn -EFAULT;\r\n}\r\nif (qat_hal_set_ae_lm_mode(handle, ae, ICP_LMEM0,\r\n(char)ICP_QAT_LOC_MEM0_MODE\r\n(uof_image->ae_mode))) {\r\npr_err("QAT: qat_hal_set_ae_lm_mode LMEM0 error\n");\r\nreturn -EFAULT;\r\n}\r\nif (qat_hal_set_ae_lm_mode(handle, ae, ICP_LMEM1,\r\n(char)ICP_QAT_LOC_MEM1_MODE\r\n(uof_image->ae_mode))) {\r\npr_err("QAT: qat_hal_set_ae_lm_mode LMEM1 error\n");\r\nreturn -EFAULT;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void qat_uclo_init_uword_num(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nstruct icp_qat_uclo_encapme *image;\r\nint a;\r\nfor (a = 0; a < obj_handle->uimage_num; a++) {\r\nimage = &obj_handle->ae_uimage[a];\r\nimage->uwords_num = image->page->beg_addr_p +\r\nimage->page->micro_words_num;\r\n}\r\n}\r\nstatic int qat_uclo_parse_uof_obj(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int ae;\r\nobj_handle->uword_buf = kcalloc(UWORD_CPYBUF_SIZE, sizeof(uint64_t),\r\nGFP_KERNEL);\r\nif (!obj_handle->uword_buf)\r\nreturn -ENOMEM;\r\nobj_handle->encap_uof_obj.beg_uof = obj_handle->obj_hdr->file_buff;\r\nobj_handle->encap_uof_obj.obj_hdr = (struct icp_qat_uof_objhdr *)\r\nobj_handle->obj_hdr->file_buff;\r\nobj_handle->uword_in_bytes = 6;\r\nobj_handle->prod_type = qat_uclo_get_dev_type(handle);\r\nobj_handle->prod_rev = PID_MAJOR_REV |\r\n(PID_MINOR_REV & handle->hal_handle->revision_id);\r\nif (qat_uclo_check_uof_compat(obj_handle)) {\r\npr_err("QAT: UOF incompatible\n");\r\nreturn -EINVAL;\r\n}\r\nobj_handle->ustore_phy_size = ICP_QAT_UCLO_MAX_USTORE;\r\nif (!obj_handle->obj_hdr->file_buff ||\r\n!qat_uclo_map_str_table(obj_handle->obj_hdr, ICP_QAT_UOF_STRT,\r\n&obj_handle->str_table)) {\r\npr_err("QAT: UOF doesn't have effective images\n");\r\ngoto out_err;\r\n}\r\nobj_handle->uimage_num =\r\nqat_uclo_map_uimage(obj_handle, obj_handle->ae_uimage,\r\nICP_QAT_UCLO_MAX_AE * ICP_QAT_UCLO_MAX_CTX);\r\nif (!obj_handle->uimage_num)\r\ngoto out_err;\r\nif (qat_uclo_map_ae(handle, handle->hal_handle->ae_max_num)) {\r\npr_err("QAT: Bad object\n");\r\ngoto out_check_uof_aemask_err;\r\n}\r\nqat_uclo_init_uword_num(handle);\r\nqat_uclo_map_initmem_table(&obj_handle->encap_uof_obj,\r\n&obj_handle->init_mem_tab);\r\nif (qat_uclo_set_ae_mode(handle))\r\ngoto out_check_uof_aemask_err;\r\nreturn 0;\r\nout_check_uof_aemask_err:\r\nfor (ae = 0; ae < obj_handle->uimage_num; ae++)\r\nkfree(obj_handle->ae_uimage[ae].page);\r\nout_err:\r\nkfree(obj_handle->uword_buf);\r\nreturn -EFAULT;\r\n}\r\nstatic int qat_uclo_map_suof_file_hdr(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_suof_filehdr *suof_ptr,\r\nint suof_size)\r\n{\r\nunsigned int check_sum = 0;\r\nunsigned int min_ver_offset = 0;\r\nstruct icp_qat_suof_handle *suof_handle = handle->sobj_handle;\r\nsuof_handle->file_id = ICP_QAT_SUOF_FID;\r\nsuof_handle->suof_buf = (char *)suof_ptr;\r\nsuof_handle->suof_size = suof_size;\r\nmin_ver_offset = suof_size - offsetof(struct icp_qat_suof_filehdr,\r\nmin_ver);\r\ncheck_sum = qat_uclo_calc_str_checksum((char *)&suof_ptr->min_ver,\r\nmin_ver_offset);\r\nif (check_sum != suof_ptr->check_sum) {\r\npr_err("QAT: incorrect SUOF checksum\n");\r\nreturn -EINVAL;\r\n}\r\nsuof_handle->check_sum = suof_ptr->check_sum;\r\nsuof_handle->min_ver = suof_ptr->min_ver;\r\nsuof_handle->maj_ver = suof_ptr->maj_ver;\r\nsuof_handle->fw_type = suof_ptr->fw_type;\r\nreturn 0;\r\n}\r\nstatic void qat_uclo_map_simg(struct icp_qat_suof_handle *suof_handle,\r\nstruct icp_qat_suof_img_hdr *suof_img_hdr,\r\nstruct icp_qat_suof_chunk_hdr *suof_chunk_hdr)\r\n{\r\nstruct icp_qat_simg_ae_mode *ae_mode;\r\nstruct icp_qat_suof_objhdr *suof_objhdr;\r\nsuof_img_hdr->simg_buf = (suof_handle->suof_buf +\r\nsuof_chunk_hdr->offset +\r\nsizeof(*suof_objhdr));\r\nsuof_img_hdr->simg_len = ((struct icp_qat_suof_objhdr *)(uintptr_t)\r\n(suof_handle->suof_buf +\r\nsuof_chunk_hdr->offset))->img_length;\r\nsuof_img_hdr->css_header = suof_img_hdr->simg_buf;\r\nsuof_img_hdr->css_key = (suof_img_hdr->css_header +\r\nsizeof(struct icp_qat_css_hdr));\r\nsuof_img_hdr->css_signature = suof_img_hdr->css_key +\r\nICP_QAT_CSS_FWSK_MODULUS_LEN +\r\nICP_QAT_CSS_FWSK_EXPONENT_LEN;\r\nsuof_img_hdr->css_simg = suof_img_hdr->css_signature +\r\nICP_QAT_CSS_SIGNATURE_LEN;\r\nae_mode = (struct icp_qat_simg_ae_mode *)(suof_img_hdr->css_simg);\r\nsuof_img_hdr->ae_mask = ae_mode->ae_mask;\r\nsuof_img_hdr->simg_name = (unsigned long)&ae_mode->simg_name;\r\nsuof_img_hdr->appmeta_data = (unsigned long)&ae_mode->appmeta_data;\r\nsuof_img_hdr->fw_type = ae_mode->fw_type;\r\n}\r\nstatic void\r\nqat_uclo_map_suof_symobjs(struct icp_qat_suof_handle *suof_handle,\r\nstruct icp_qat_suof_chunk_hdr *suof_chunk_hdr)\r\n{\r\nchar **sym_str = (char **)&suof_handle->sym_str;\r\nunsigned int *sym_size = &suof_handle->sym_size;\r\nstruct icp_qat_suof_strtable *str_table_obj;\r\n*sym_size = *(unsigned int *)(uintptr_t)\r\n(suof_chunk_hdr->offset + suof_handle->suof_buf);\r\n*sym_str = (char *)(uintptr_t)\r\n(suof_handle->suof_buf + suof_chunk_hdr->offset +\r\nsizeof(str_table_obj->tab_length));\r\n}\r\nstatic int qat_uclo_check_simg_compat(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_suof_img_hdr *img_hdr)\r\n{\r\nstruct icp_qat_simg_ae_mode *img_ae_mode = NULL;\r\nunsigned int prod_rev, maj_ver, prod_type;\r\nprod_type = qat_uclo_get_dev_type(handle);\r\nimg_ae_mode = (struct icp_qat_simg_ae_mode *)img_hdr->css_simg;\r\nprod_rev = PID_MAJOR_REV |\r\n(PID_MINOR_REV & handle->hal_handle->revision_id);\r\nif (img_ae_mode->dev_type != prod_type) {\r\npr_err("QAT: incompatible product type %x\n",\r\nimg_ae_mode->dev_type);\r\nreturn -EINVAL;\r\n}\r\nmaj_ver = prod_rev & 0xff;\r\nif ((maj_ver > img_ae_mode->devmax_ver) ||\r\n(maj_ver < img_ae_mode->devmin_ver)) {\r\npr_err("QAT: incompatible device majver 0x%x\n", maj_ver);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qat_uclo_del_suof(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_suof_handle *sobj_handle = handle->sobj_handle;\r\nkfree(sobj_handle->img_table.simg_hdr);\r\nsobj_handle->img_table.simg_hdr = NULL;\r\nkfree(handle->sobj_handle);\r\nhandle->sobj_handle = NULL;\r\n}\r\nstatic void qat_uclo_tail_img(struct icp_qat_suof_img_hdr *suof_img_hdr,\r\nunsigned int img_id, unsigned int num_simgs)\r\n{\r\nstruct icp_qat_suof_img_hdr img_header;\r\nif (img_id != num_simgs - 1) {\r\nmemcpy(&img_header, &suof_img_hdr[num_simgs - 1],\r\nsizeof(*suof_img_hdr));\r\nmemcpy(&suof_img_hdr[num_simgs - 1], &suof_img_hdr[img_id],\r\nsizeof(*suof_img_hdr));\r\nmemcpy(&suof_img_hdr[img_id], &img_header,\r\nsizeof(*suof_img_hdr));\r\n}\r\n}\r\nstatic int qat_uclo_map_suof(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_suof_filehdr *suof_ptr,\r\nint suof_size)\r\n{\r\nstruct icp_qat_suof_handle *suof_handle = handle->sobj_handle;\r\nstruct icp_qat_suof_chunk_hdr *suof_chunk_hdr = NULL;\r\nstruct icp_qat_suof_img_hdr *suof_img_hdr = NULL;\r\nint ret = 0, ae0_img = ICP_QAT_UCLO_MAX_AE;\r\nunsigned int i = 0;\r\nstruct icp_qat_suof_img_hdr img_header;\r\nif (!suof_ptr || (suof_size == 0)) {\r\npr_err("QAT: input parameter SUOF pointer/size is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nif (qat_uclo_check_suof_format(suof_ptr))\r\nreturn -EINVAL;\r\nret = qat_uclo_map_suof_file_hdr(handle, suof_ptr, suof_size);\r\nif (ret)\r\nreturn ret;\r\nsuof_chunk_hdr = (struct icp_qat_suof_chunk_hdr *)\r\n((uintptr_t)suof_ptr + sizeof(*suof_ptr));\r\nqat_uclo_map_suof_symobjs(suof_handle, suof_chunk_hdr);\r\nsuof_handle->img_table.num_simgs = suof_ptr->num_chunks - 1;\r\nif (suof_handle->img_table.num_simgs != 0) {\r\nsuof_img_hdr = kzalloc(suof_handle->img_table.num_simgs *\r\nsizeof(img_header), GFP_KERNEL);\r\nif (!suof_img_hdr)\r\nreturn -ENOMEM;\r\nsuof_handle->img_table.simg_hdr = suof_img_hdr;\r\n}\r\nfor (i = 0; i < suof_handle->img_table.num_simgs; i++) {\r\nqat_uclo_map_simg(handle->sobj_handle, &suof_img_hdr[i],\r\n&suof_chunk_hdr[1 + i]);\r\nret = qat_uclo_check_simg_compat(handle,\r\n&suof_img_hdr[i]);\r\nif (ret)\r\nreturn ret;\r\nif ((suof_img_hdr[i].ae_mask & 0x1) != 0)\r\nae0_img = i;\r\n}\r\nqat_uclo_tail_img(suof_img_hdr, ae0_img,\r\nsuof_handle->img_table.num_simgs);\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_auth_fw(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_fw_auth_desc *desc)\r\n{\r\nunsigned int fcu_sts, retry = 0;\r\nu64 bus_addr;\r\nbus_addr = ADD_ADDR(desc->css_hdr_high, desc->css_hdr_low)\r\n- sizeof(struct icp_qat_auth_chunk);\r\nSET_CAP_CSR(handle, FCU_DRAM_ADDR_HI, (bus_addr >> BITS_IN_DWORD));\r\nSET_CAP_CSR(handle, FCU_DRAM_ADDR_LO, bus_addr);\r\nSET_CAP_CSR(handle, FCU_CONTROL, FCU_CTRL_CMD_AUTH);\r\ndo {\r\nmsleep(FW_AUTH_WAIT_PERIOD);\r\nfcu_sts = GET_CAP_CSR(handle, FCU_STATUS);\r\nif ((fcu_sts & FCU_AUTH_STS_MASK) == FCU_STS_VERI_FAIL)\r\ngoto auth_fail;\r\nif (((fcu_sts >> FCU_STS_AUTHFWLD_POS) & 0x1))\r\nif ((fcu_sts & FCU_AUTH_STS_MASK) == FCU_STS_VERI_DONE)\r\nreturn 0;\r\n} while (retry++ < FW_AUTH_MAX_RETRY);\r\nauth_fail:\r\npr_err("QAT: authentication error (FCU_STATUS = 0x%x),retry = %d\n",\r\nfcu_sts & FCU_AUTH_STS_MASK, retry);\r\nreturn -EINVAL;\r\n}\r\nstatic int qat_uclo_simg_alloc(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_firml_dram_desc *dram_desc,\r\nunsigned int size)\r\n{\r\nvoid *vptr;\r\ndma_addr_t ptr;\r\nvptr = dma_alloc_coherent(&handle->pci_dev->dev,\r\nsize, &ptr, GFP_KERNEL);\r\nif (!vptr)\r\nreturn -ENOMEM;\r\ndram_desc->dram_base_addr_v = vptr;\r\ndram_desc->dram_bus_addr = ptr;\r\ndram_desc->dram_size = size;\r\nreturn 0;\r\n}\r\nstatic void qat_uclo_simg_free(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_firml_dram_desc *dram_desc)\r\n{\r\ndma_free_coherent(&handle->pci_dev->dev,\r\n(size_t)(dram_desc->dram_size),\r\n(dram_desc->dram_base_addr_v),\r\ndram_desc->dram_bus_addr);\r\nmemset(dram_desc, 0, sizeof(*dram_desc));\r\n}\r\nstatic void qat_uclo_ummap_auth_fw(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_fw_auth_desc **desc)\r\n{\r\nstruct icp_firml_dram_desc dram_desc;\r\ndram_desc.dram_base_addr_v = *desc;\r\ndram_desc.dram_bus_addr = ((struct icp_qat_auth_chunk *)\r\n(*desc))->chunk_bus_addr;\r\ndram_desc.dram_size = ((struct icp_qat_auth_chunk *)\r\n(*desc))->chunk_size;\r\nqat_uclo_simg_free(handle, &dram_desc);\r\n}\r\nstatic int qat_uclo_map_auth_fw(struct icp_qat_fw_loader_handle *handle,\r\nchar *image, unsigned int size,\r\nstruct icp_qat_fw_auth_desc **desc)\r\n{\r\nstruct icp_qat_css_hdr *css_hdr = (struct icp_qat_css_hdr *)image;\r\nstruct icp_qat_fw_auth_desc *auth_desc;\r\nstruct icp_qat_auth_chunk *auth_chunk;\r\nu64 virt_addr, bus_addr, virt_base;\r\nunsigned int length, simg_offset = sizeof(*auth_chunk);\r\nstruct icp_firml_dram_desc img_desc;\r\nif (size > (ICP_QAT_AE_IMG_OFFSET + ICP_QAT_CSS_MAX_IMAGE_LEN)) {\r\npr_err("QAT: error, input image size overflow %d\n", size);\r\nreturn -EINVAL;\r\n}\r\nlength = (css_hdr->fw_type == CSS_AE_FIRMWARE) ?\r\nICP_QAT_CSS_AE_SIMG_LEN + simg_offset :\r\nsize + ICP_QAT_CSS_FWSK_PAD_LEN + simg_offset;\r\nif (qat_uclo_simg_alloc(handle, &img_desc, length)) {\r\npr_err("QAT: error, allocate continuous dram fail\n");\r\nreturn -ENOMEM;\r\n}\r\nauth_chunk = img_desc.dram_base_addr_v;\r\nauth_chunk->chunk_size = img_desc.dram_size;\r\nauth_chunk->chunk_bus_addr = img_desc.dram_bus_addr;\r\nvirt_base = (uintptr_t)img_desc.dram_base_addr_v + simg_offset;\r\nbus_addr = img_desc.dram_bus_addr + simg_offset;\r\nauth_desc = img_desc.dram_base_addr_v;\r\nauth_desc->css_hdr_high = (unsigned int)(bus_addr >> BITS_IN_DWORD);\r\nauth_desc->css_hdr_low = (unsigned int)bus_addr;\r\nvirt_addr = virt_base;\r\nmemcpy((void *)(uintptr_t)virt_addr, image, sizeof(*css_hdr));\r\nbus_addr = ADD_ADDR(auth_desc->css_hdr_high, auth_desc->css_hdr_low) +\r\nsizeof(*css_hdr);\r\nvirt_addr = virt_addr + sizeof(*css_hdr);\r\nauth_desc->fwsk_pub_high = (unsigned int)(bus_addr >> BITS_IN_DWORD);\r\nauth_desc->fwsk_pub_low = (unsigned int)bus_addr;\r\nmemcpy((void *)(uintptr_t)virt_addr,\r\n(void *)(image + sizeof(*css_hdr)),\r\nICP_QAT_CSS_FWSK_MODULUS_LEN);\r\nmemset((void *)(uintptr_t)(virt_addr + ICP_QAT_CSS_FWSK_MODULUS_LEN),\r\n0, ICP_QAT_CSS_FWSK_PAD_LEN);\r\nmemcpy((void *)(uintptr_t)(virt_addr + ICP_QAT_CSS_FWSK_MODULUS_LEN +\r\nICP_QAT_CSS_FWSK_PAD_LEN),\r\n(void *)(image + sizeof(*css_hdr) +\r\nICP_QAT_CSS_FWSK_MODULUS_LEN),\r\nsizeof(unsigned int));\r\nbus_addr = ADD_ADDR(auth_desc->fwsk_pub_high,\r\nauth_desc->fwsk_pub_low) +\r\nICP_QAT_CSS_FWSK_PUB_LEN;\r\nvirt_addr = virt_addr + ICP_QAT_CSS_FWSK_PUB_LEN;\r\nauth_desc->signature_high = (unsigned int)(bus_addr >> BITS_IN_DWORD);\r\nauth_desc->signature_low = (unsigned int)bus_addr;\r\nmemcpy((void *)(uintptr_t)virt_addr,\r\n(void *)(image + sizeof(*css_hdr) +\r\nICP_QAT_CSS_FWSK_MODULUS_LEN +\r\nICP_QAT_CSS_FWSK_EXPONENT_LEN),\r\nICP_QAT_CSS_SIGNATURE_LEN);\r\nbus_addr = ADD_ADDR(auth_desc->signature_high,\r\nauth_desc->signature_low) +\r\nICP_QAT_CSS_SIGNATURE_LEN;\r\nvirt_addr += ICP_QAT_CSS_SIGNATURE_LEN;\r\nauth_desc->img_high = (unsigned int)(bus_addr >> BITS_IN_DWORD);\r\nauth_desc->img_low = (unsigned int)bus_addr;\r\nauth_desc->img_len = size - ICP_QAT_AE_IMG_OFFSET;\r\nmemcpy((void *)(uintptr_t)virt_addr,\r\n(void *)(image + ICP_QAT_AE_IMG_OFFSET),\r\nauth_desc->img_len);\r\nvirt_addr = virt_base;\r\nif (((struct icp_qat_css_hdr *)(uintptr_t)virt_addr)->fw_type ==\r\nCSS_AE_FIRMWARE) {\r\nauth_desc->img_ae_mode_data_high = auth_desc->img_high;\r\nauth_desc->img_ae_mode_data_low = auth_desc->img_low;\r\nbus_addr = ADD_ADDR(auth_desc->img_ae_mode_data_high,\r\nauth_desc->img_ae_mode_data_low) +\r\nsizeof(struct icp_qat_simg_ae_mode);\r\nauth_desc->img_ae_init_data_high = (unsigned int)\r\n(bus_addr >> BITS_IN_DWORD);\r\nauth_desc->img_ae_init_data_low = (unsigned int)bus_addr;\r\nbus_addr += ICP_QAT_SIMG_AE_INIT_SEQ_LEN;\r\nauth_desc->img_ae_insts_high = (unsigned int)\r\n(bus_addr >> BITS_IN_DWORD);\r\nauth_desc->img_ae_insts_low = (unsigned int)bus_addr;\r\n} else {\r\nauth_desc->img_ae_insts_high = auth_desc->img_high;\r\nauth_desc->img_ae_insts_low = auth_desc->img_low;\r\n}\r\n*desc = auth_desc;\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_load_fw(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_fw_auth_desc *desc)\r\n{\r\nunsigned int i;\r\nunsigned int fcu_sts;\r\nstruct icp_qat_simg_ae_mode *virt_addr;\r\nunsigned int fcu_loaded_ae_pos = FCU_LOADED_AE_POS;\r\nvirt_addr = (void *)((uintptr_t)desc +\r\nsizeof(struct icp_qat_auth_chunk) +\r\nsizeof(struct icp_qat_css_hdr) +\r\nICP_QAT_CSS_FWSK_PUB_LEN +\r\nICP_QAT_CSS_SIGNATURE_LEN);\r\nfor (i = 0; i < handle->hal_handle->ae_max_num; i++) {\r\nint retry = 0;\r\nif (!((virt_addr->ae_mask >> i) & 0x1))\r\ncontinue;\r\nif (qat_hal_check_ae_active(handle, i)) {\r\npr_err("QAT: AE %d is active\n", i);\r\nreturn -EINVAL;\r\n}\r\nSET_CAP_CSR(handle, FCU_CONTROL,\r\n(FCU_CTRL_CMD_LOAD | (i << FCU_CTRL_AE_POS)));\r\ndo {\r\nmsleep(FW_AUTH_WAIT_PERIOD);\r\nfcu_sts = GET_CAP_CSR(handle, FCU_STATUS);\r\nif (((fcu_sts & FCU_AUTH_STS_MASK) ==\r\nFCU_STS_LOAD_DONE) &&\r\n((fcu_sts >> fcu_loaded_ae_pos) & (1 << i)))\r\nbreak;\r\n} while (retry++ < FW_AUTH_MAX_RETRY);\r\nif (retry > FW_AUTH_MAX_RETRY) {\r\npr_err("QAT: firmware load failed timeout %x\n", retry);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_map_suof_obj(struct icp_qat_fw_loader_handle *handle,\r\nvoid *addr_ptr, int mem_size)\r\n{\r\nstruct icp_qat_suof_handle *suof_handle;\r\nsuof_handle = kzalloc(sizeof(*suof_handle), GFP_KERNEL);\r\nif (!suof_handle)\r\nreturn -ENOMEM;\r\nhandle->sobj_handle = suof_handle;\r\nif (qat_uclo_map_suof(handle, addr_ptr, mem_size)) {\r\nqat_uclo_del_suof(handle);\r\npr_err("QAT: map SUOF failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint qat_uclo_wr_mimage(struct icp_qat_fw_loader_handle *handle,\r\nvoid *addr_ptr, int mem_size)\r\n{\r\nstruct icp_qat_fw_auth_desc *desc = NULL;\r\nint status = 0;\r\nif (handle->fw_auth) {\r\nif (!qat_uclo_map_auth_fw(handle, addr_ptr, mem_size, &desc))\r\nstatus = qat_uclo_auth_fw(handle, desc);\r\nqat_uclo_ummap_auth_fw(handle, &desc);\r\n} else {\r\nif (handle->pci_dev->device == ADF_C3XXX_PCI_DEVICE_ID) {\r\npr_err("QAT: C3XXX doesn't support unsigned MMP\n");\r\nreturn -EINVAL;\r\n}\r\nqat_uclo_wr_sram_by_words(handle, 0, addr_ptr, mem_size);\r\n}\r\nreturn status;\r\n}\r\nstatic int qat_uclo_map_uof_obj(struct icp_qat_fw_loader_handle *handle,\r\nvoid *addr_ptr, int mem_size)\r\n{\r\nstruct icp_qat_uof_filehdr *filehdr;\r\nstruct icp_qat_uclo_objhandle *objhdl;\r\nobjhdl = kzalloc(sizeof(*objhdl), GFP_KERNEL);\r\nif (!objhdl)\r\nreturn -ENOMEM;\r\nobjhdl->obj_buf = kmemdup(addr_ptr, mem_size, GFP_KERNEL);\r\nif (!objhdl->obj_buf)\r\ngoto out_objbuf_err;\r\nfilehdr = (struct icp_qat_uof_filehdr *)objhdl->obj_buf;\r\nif (qat_uclo_check_uof_format(filehdr))\r\ngoto out_objhdr_err;\r\nobjhdl->obj_hdr = qat_uclo_map_chunk((char *)objhdl->obj_buf, filehdr,\r\nICP_QAT_UOF_OBJS);\r\nif (!objhdl->obj_hdr) {\r\npr_err("QAT: object file chunk is null\n");\r\ngoto out_objhdr_err;\r\n}\r\nhandle->obj_handle = objhdl;\r\nif (qat_uclo_parse_uof_obj(handle))\r\ngoto out_overlay_obj_err;\r\nreturn 0;\r\nout_overlay_obj_err:\r\nhandle->obj_handle = NULL;\r\nkfree(objhdl->obj_hdr);\r\nout_objhdr_err:\r\nkfree(objhdl->obj_buf);\r\nout_objbuf_err:\r\nkfree(objhdl);\r\nreturn -ENOMEM;\r\n}\r\nint qat_uclo_map_obj(struct icp_qat_fw_loader_handle *handle,\r\nvoid *addr_ptr, int mem_size)\r\n{\r\nBUILD_BUG_ON(ICP_QAT_UCLO_MAX_AE >=\r\n(sizeof(handle->hal_handle->ae_mask) * 8));\r\nif (!handle || !addr_ptr || mem_size < 24)\r\nreturn -EINVAL;\r\nreturn (handle->fw_auth) ?\r\nqat_uclo_map_suof_obj(handle, addr_ptr, mem_size) :\r\nqat_uclo_map_uof_obj(handle, addr_ptr, mem_size);\r\n}\r\nvoid qat_uclo_del_uof_obj(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int a;\r\nif (handle->sobj_handle)\r\nqat_uclo_del_suof(handle);\r\nif (!obj_handle)\r\nreturn;\r\nkfree(obj_handle->uword_buf);\r\nfor (a = 0; a < obj_handle->uimage_num; a++)\r\nkfree(obj_handle->ae_uimage[a].page);\r\nfor (a = 0; a < handle->hal_handle->ae_max_num; a++)\r\nqat_uclo_free_ae_data(&obj_handle->ae_data[a]);\r\nkfree(obj_handle->obj_hdr);\r\nkfree(obj_handle->obj_buf);\r\nkfree(obj_handle);\r\nhandle->obj_handle = NULL;\r\n}\r\nstatic void qat_uclo_fill_uwords(struct icp_qat_uclo_objhandle *obj_handle,\r\nstruct icp_qat_uclo_encap_page *encap_page,\r\nuint64_t *uword, unsigned int addr_p,\r\nunsigned int raddr, uint64_t fill)\r\n{\r\nuint64_t uwrd = 0;\r\nunsigned int i;\r\nif (!encap_page) {\r\n*uword = fill;\r\nreturn;\r\n}\r\nfor (i = 0; i < encap_page->uwblock_num; i++) {\r\nif (raddr >= encap_page->uwblock[i].start_addr &&\r\nraddr <= encap_page->uwblock[i].start_addr +\r\nencap_page->uwblock[i].words_num - 1) {\r\nraddr -= encap_page->uwblock[i].start_addr;\r\nraddr *= obj_handle->uword_in_bytes;\r\nmemcpy(&uwrd, (void *)(((uintptr_t)\r\nencap_page->uwblock[i].micro_words) + raddr),\r\nobj_handle->uword_in_bytes);\r\nuwrd = uwrd & 0xbffffffffffull;\r\n}\r\n}\r\n*uword = uwrd;\r\nif (*uword == INVLD_UWORD)\r\n*uword = fill;\r\n}\r\nstatic void qat_uclo_wr_uimage_raw_page(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uclo_encap_page\r\n*encap_page, unsigned int ae)\r\n{\r\nunsigned int uw_physical_addr, uw_relative_addr, i, words_num, cpylen;\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nuint64_t fill_pat;\r\nmemcpy(&fill_pat, obj_handle->ae_uimage[0].img_ptr->fill_pattern,\r\nsizeof(uint64_t));\r\nuw_physical_addr = encap_page->beg_addr_p;\r\nuw_relative_addr = 0;\r\nwords_num = encap_page->micro_words_num;\r\nwhile (words_num) {\r\nif (words_num < UWORD_CPYBUF_SIZE)\r\ncpylen = words_num;\r\nelse\r\ncpylen = UWORD_CPYBUF_SIZE;\r\nfor (i = 0; i < cpylen; i++)\r\nqat_uclo_fill_uwords(obj_handle, encap_page,\r\n&obj_handle->uword_buf[i],\r\nuw_physical_addr + i,\r\nuw_relative_addr + i, fill_pat);\r\nqat_hal_wr_uwords(handle, (unsigned char)ae,\r\nuw_physical_addr, cpylen,\r\nobj_handle->uword_buf);\r\nuw_physical_addr += cpylen;\r\nuw_relative_addr += cpylen;\r\nwords_num -= cpylen;\r\n}\r\n}\r\nstatic void qat_uclo_wr_uimage_page(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_image *image)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int ctx_mask, s;\r\nstruct icp_qat_uclo_page *page;\r\nunsigned char ae;\r\nint ctx;\r\nif (ICP_QAT_CTX_MODE(image->ae_mode) == ICP_QAT_UCLO_MAX_CTX)\r\nctx_mask = 0xff;\r\nelse\r\nctx_mask = 0x55;\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!test_bit(ae, (unsigned long *)&image->ae_assigned))\r\ncontinue;\r\nfor (s = 0; s < obj_handle->ae_data[ae].slice_num; s++) {\r\nif (image->ctx_assigned & obj_handle->ae_data[ae].\r\nae_slices[s].ctx_mask_assigned)\r\nbreak;\r\n}\r\nif (s >= obj_handle->ae_data[ae].slice_num)\r\ncontinue;\r\npage = obj_handle->ae_data[ae].ae_slices[s].page;\r\nif (!page->encap_page->def_page)\r\ncontinue;\r\nqat_uclo_wr_uimage_raw_page(handle, page->encap_page, ae);\r\npage = obj_handle->ae_data[ae].ae_slices[s].page;\r\nfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++)\r\nobj_handle->ae_data[ae].ae_slices[s].cur_page[ctx] =\r\n(ctx_mask & (1 << ctx)) ? page : NULL;\r\nqat_hal_set_live_ctx(handle, (unsigned char)ae,\r\nimage->ctx_assigned);\r\nqat_hal_set_pc(handle, (unsigned char)ae, image->ctx_assigned,\r\nimage->entry_address);\r\n}\r\n}\r\nstatic int qat_uclo_wr_suof_img(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nunsigned int i;\r\nstruct icp_qat_fw_auth_desc *desc = NULL;\r\nstruct icp_qat_suof_handle *sobj_handle = handle->sobj_handle;\r\nstruct icp_qat_suof_img_hdr *simg_hdr = sobj_handle->img_table.simg_hdr;\r\nfor (i = 0; i < sobj_handle->img_table.num_simgs; i++) {\r\nif (qat_uclo_map_auth_fw(handle,\r\n(char *)simg_hdr[i].simg_buf,\r\n(unsigned int)\r\n(simg_hdr[i].simg_len),\r\n&desc))\r\ngoto wr_err;\r\nif (qat_uclo_auth_fw(handle, desc))\r\ngoto wr_err;\r\nif (qat_uclo_load_fw(handle, desc))\r\ngoto wr_err;\r\nqat_uclo_ummap_auth_fw(handle, &desc);\r\n}\r\nreturn 0;\r\nwr_err:\r\nqat_uclo_ummap_auth_fw(handle, &desc);\r\nreturn -EINVAL;\r\n}\r\nstatic int qat_uclo_wr_uof_img(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int i;\r\nif (qat_uclo_init_globals(handle))\r\nreturn -EINVAL;\r\nfor (i = 0; i < obj_handle->uimage_num; i++) {\r\nif (!obj_handle->ae_uimage[i].img_ptr)\r\nreturn -EINVAL;\r\nif (qat_uclo_init_ustore(handle, &obj_handle->ae_uimage[i]))\r\nreturn -EINVAL;\r\nqat_uclo_wr_uimage_page(handle,\r\nobj_handle->ae_uimage[i].img_ptr);\r\n}\r\nreturn 0;\r\n}\r\nint qat_uclo_wr_all_uimage(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nreturn (handle->fw_auth) ? qat_uclo_wr_suof_img(handle) :\r\nqat_uclo_wr_uof_img(handle);\r\n}
