static int\r\nefx_mcdi_get_phy_cfg(struct efx_nic *efx, struct efx_mcdi_phy_data *cfg)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_PHY_CFG_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_GET_PHY_CFG_IN_LEN != 0);\r\nBUILD_BUG_ON(MC_CMD_GET_PHY_CFG_OUT_NAME_LEN != sizeof(cfg->name));\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_PHY_CFG, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_GET_PHY_CFG_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\ncfg->flags = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_FLAGS);\r\ncfg->type = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_TYPE);\r\ncfg->supported_cap =\r\nMCDI_DWORD(outbuf, GET_PHY_CFG_OUT_SUPPORTED_CAP);\r\ncfg->channel = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_CHANNEL);\r\ncfg->port = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_PRT);\r\ncfg->stats_mask = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_STATS_MASK);\r\nmemcpy(cfg->name, MCDI_PTR(outbuf, GET_PHY_CFG_OUT_NAME),\r\nsizeof(cfg->name));\r\ncfg->media = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_MEDIA_TYPE);\r\ncfg->mmd_mask = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_MMD_MASK);\r\nmemcpy(cfg->revision, MCDI_PTR(outbuf, GET_PHY_CFG_OUT_REVISION),\r\nsizeof(cfg->revision));\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_set_link(struct efx_nic *efx, u32 capabilities,\r\nu32 flags, u32 loopback_mode,\r\nu32 loopback_speed)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_SET_LINK_IN_LEN);\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_SET_LINK_OUT_LEN != 0);\r\nMCDI_SET_DWORD(inbuf, SET_LINK_IN_CAP, capabilities);\r\nMCDI_SET_DWORD(inbuf, SET_LINK_IN_FLAGS, flags);\r\nMCDI_SET_DWORD(inbuf, SET_LINK_IN_LOOPBACK_MODE, loopback_mode);\r\nMCDI_SET_DWORD(inbuf, SET_LINK_IN_LOOPBACK_SPEED, loopback_speed);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_SET_LINK, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_loopback_modes(struct efx_nic *efx, u64 *loopback_modes)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_LOOPBACK_MODES_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_LOOPBACK_MODES, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < (MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_OFST +\r\nMC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_LEN)) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n*loopback_modes = MCDI_QWORD(outbuf, GET_LOOPBACK_MODES_OUT_SUGGESTED);\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_mdio_read(struct net_device *net_dev,\r\nint prtad, int devad, u16 addr)\r\n{\r\nstruct efx_nic *efx = netdev_priv(net_dev);\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_MDIO_READ_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_MDIO_READ_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, MDIO_READ_IN_BUS, efx->mdio_bus);\r\nMCDI_SET_DWORD(inbuf, MDIO_READ_IN_PRTAD, prtad);\r\nMCDI_SET_DWORD(inbuf, MDIO_READ_IN_DEVAD, devad);\r\nMCDI_SET_DWORD(inbuf, MDIO_READ_IN_ADDR, addr);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_MDIO_READ, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\nreturn rc;\r\nif (MCDI_DWORD(outbuf, MDIO_READ_OUT_STATUS) !=\r\nMC_CMD_MDIO_STATUS_GOOD)\r\nreturn -EIO;\r\nreturn (u16)MCDI_DWORD(outbuf, MDIO_READ_OUT_VALUE);\r\n}\r\nstatic int efx_mcdi_mdio_write(struct net_device *net_dev,\r\nint prtad, int devad, u16 addr, u16 value)\r\n{\r\nstruct efx_nic *efx = netdev_priv(net_dev);\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_MDIO_WRITE_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_MDIO_WRITE_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_BUS, efx->mdio_bus);\r\nMCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_PRTAD, prtad);\r\nMCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_DEVAD, devad);\r\nMCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_ADDR, addr);\r\nMCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_VALUE, value);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_MDIO_WRITE, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\nreturn rc;\r\nif (MCDI_DWORD(outbuf, MDIO_WRITE_OUT_STATUS) !=\r\nMC_CMD_MDIO_STATUS_GOOD)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic u32 mcdi_to_ethtool_cap(u32 media, u32 cap)\r\n{\r\nu32 result = 0;\r\nswitch (media) {\r\ncase MC_CMD_MEDIA_KX4:\r\nresult |= SUPPORTED_Backplane;\r\nif (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))\r\nresult |= SUPPORTED_1000baseKX_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))\r\nresult |= SUPPORTED_10000baseKX4_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_40000FDX_LBN))\r\nresult |= SUPPORTED_40000baseKR4_Full;\r\nbreak;\r\ncase MC_CMD_MEDIA_XFP:\r\ncase MC_CMD_MEDIA_SFP_PLUS:\r\ncase MC_CMD_MEDIA_QSFP_PLUS:\r\nresult |= SUPPORTED_FIBRE;\r\nif (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))\r\nresult |= SUPPORTED_1000baseT_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))\r\nresult |= SUPPORTED_10000baseT_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_40000FDX_LBN))\r\nresult |= SUPPORTED_40000baseCR4_Full;\r\nbreak;\r\ncase MC_CMD_MEDIA_BASE_T:\r\nresult |= SUPPORTED_TP;\r\nif (cap & (1 << MC_CMD_PHY_CAP_10HDX_LBN))\r\nresult |= SUPPORTED_10baseT_Half;\r\nif (cap & (1 << MC_CMD_PHY_CAP_10FDX_LBN))\r\nresult |= SUPPORTED_10baseT_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_100HDX_LBN))\r\nresult |= SUPPORTED_100baseT_Half;\r\nif (cap & (1 << MC_CMD_PHY_CAP_100FDX_LBN))\r\nresult |= SUPPORTED_100baseT_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_1000HDX_LBN))\r\nresult |= SUPPORTED_1000baseT_Half;\r\nif (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))\r\nresult |= SUPPORTED_1000baseT_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))\r\nresult |= SUPPORTED_10000baseT_Full;\r\nbreak;\r\n}\r\nif (cap & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))\r\nresult |= SUPPORTED_Pause;\r\nif (cap & (1 << MC_CMD_PHY_CAP_ASYM_LBN))\r\nresult |= SUPPORTED_Asym_Pause;\r\nif (cap & (1 << MC_CMD_PHY_CAP_AN_LBN))\r\nresult |= SUPPORTED_Autoneg;\r\nreturn result;\r\n}\r\nstatic u32 ethtool_to_mcdi_cap(u32 cap)\r\n{\r\nu32 result = 0;\r\nif (cap & SUPPORTED_10baseT_Half)\r\nresult |= (1 << MC_CMD_PHY_CAP_10HDX_LBN);\r\nif (cap & SUPPORTED_10baseT_Full)\r\nresult |= (1 << MC_CMD_PHY_CAP_10FDX_LBN);\r\nif (cap & SUPPORTED_100baseT_Half)\r\nresult |= (1 << MC_CMD_PHY_CAP_100HDX_LBN);\r\nif (cap & SUPPORTED_100baseT_Full)\r\nresult |= (1 << MC_CMD_PHY_CAP_100FDX_LBN);\r\nif (cap & SUPPORTED_1000baseT_Half)\r\nresult |= (1 << MC_CMD_PHY_CAP_1000HDX_LBN);\r\nif (cap & (SUPPORTED_1000baseT_Full | SUPPORTED_1000baseKX_Full))\r\nresult |= (1 << MC_CMD_PHY_CAP_1000FDX_LBN);\r\nif (cap & (SUPPORTED_10000baseT_Full | SUPPORTED_10000baseKX4_Full))\r\nresult |= (1 << MC_CMD_PHY_CAP_10000FDX_LBN);\r\nif (cap & (SUPPORTED_40000baseCR4_Full | SUPPORTED_40000baseKR4_Full))\r\nresult |= (1 << MC_CMD_PHY_CAP_40000FDX_LBN);\r\nif (cap & SUPPORTED_Pause)\r\nresult |= (1 << MC_CMD_PHY_CAP_PAUSE_LBN);\r\nif (cap & SUPPORTED_Asym_Pause)\r\nresult |= (1 << MC_CMD_PHY_CAP_ASYM_LBN);\r\nif (cap & SUPPORTED_Autoneg)\r\nresult |= (1 << MC_CMD_PHY_CAP_AN_LBN);\r\nreturn result;\r\n}\r\nstatic u32 efx_get_mcdi_phy_flags(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nenum efx_phy_mode mode, supported;\r\nu32 flags;\r\nsupported = 0;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_TXDIS_LBN))\r\nsupported |= PHY_MODE_TX_DISABLED;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_LOWPOWER_LBN))\r\nsupported |= PHY_MODE_LOW_POWER;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_POWEROFF_LBN))\r\nsupported |= PHY_MODE_OFF;\r\nmode = efx->phy_mode & supported;\r\nflags = 0;\r\nif (mode & PHY_MODE_TX_DISABLED)\r\nflags |= (1 << MC_CMD_SET_LINK_IN_TXDIS_LBN);\r\nif (mode & PHY_MODE_LOW_POWER)\r\nflags |= (1 << MC_CMD_SET_LINK_IN_LOWPOWER_LBN);\r\nif (mode & PHY_MODE_OFF)\r\nflags |= (1 << MC_CMD_SET_LINK_IN_POWEROFF_LBN);\r\nreturn flags;\r\n}\r\nstatic u32 mcdi_to_ethtool_media(u32 media)\r\n{\r\nswitch (media) {\r\ncase MC_CMD_MEDIA_XAUI:\r\ncase MC_CMD_MEDIA_CX4:\r\ncase MC_CMD_MEDIA_KX4:\r\nreturn PORT_OTHER;\r\ncase MC_CMD_MEDIA_XFP:\r\ncase MC_CMD_MEDIA_SFP_PLUS:\r\ncase MC_CMD_MEDIA_QSFP_PLUS:\r\nreturn PORT_FIBRE;\r\ncase MC_CMD_MEDIA_BASE_T:\r\nreturn PORT_TP;\r\ndefault:\r\nreturn PORT_OTHER;\r\n}\r\n}\r\nstatic void efx_mcdi_phy_decode_link(struct efx_nic *efx,\r\nstruct efx_link_state *link_state,\r\nu32 speed, u32 flags, u32 fcntl)\r\n{\r\nswitch (fcntl) {\r\ncase MC_CMD_FCNTL_AUTO:\r\nWARN_ON(1);\r\nlink_state->fc = EFX_FC_AUTO | EFX_FC_TX | EFX_FC_RX;\r\nbreak;\r\ncase MC_CMD_FCNTL_BIDIR:\r\nlink_state->fc = EFX_FC_TX | EFX_FC_RX;\r\nbreak;\r\ncase MC_CMD_FCNTL_RESPOND:\r\nlink_state->fc = EFX_FC_RX;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\ncase MC_CMD_FCNTL_OFF:\r\nlink_state->fc = 0;\r\nbreak;\r\n}\r\nlink_state->up = !!(flags & (1 << MC_CMD_GET_LINK_OUT_LINK_UP_LBN));\r\nlink_state->fd = !!(flags & (1 << MC_CMD_GET_LINK_OUT_FULL_DUPLEX_LBN));\r\nlink_state->speed = speed;\r\n}\r\nstatic int efx_mcdi_phy_probe(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_phy_data *phy_data;\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_LINK_OUT_LEN);\r\nu32 caps;\r\nint rc;\r\nphy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);\r\nif (phy_data == NULL)\r\nreturn -ENOMEM;\r\nrc = efx_mcdi_get_phy_cfg(efx, phy_data);\r\nif (rc != 0)\r\ngoto fail;\r\nBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc)\r\ngoto fail;\r\nefx->phy_data = phy_data;\r\nefx->phy_type = phy_data->type;\r\nefx->mdio_bus = phy_data->channel;\r\nefx->mdio.prtad = phy_data->port;\r\nefx->mdio.mmds = phy_data->mmd_mask & ~(1 << MC_CMD_MMD_CLAUSE22);\r\nefx->mdio.mode_support = 0;\r\nif (phy_data->mmd_mask & (1 << MC_CMD_MMD_CLAUSE22))\r\nefx->mdio.mode_support |= MDIO_SUPPORTS_C22;\r\nif (phy_data->mmd_mask & ~(1 << MC_CMD_MMD_CLAUSE22))\r\nefx->mdio.mode_support |= MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\r\ncaps = MCDI_DWORD(outbuf, GET_LINK_OUT_CAP);\r\nif (caps & (1 << MC_CMD_PHY_CAP_AN_LBN))\r\nefx->link_advertising =\r\nmcdi_to_ethtool_cap(phy_data->media, caps);\r\nelse\r\nphy_data->forced_cap = caps;\r\nBUILD_BUG_ON(LOOPBACK_NONE != MC_CMD_LOOPBACK_NONE);\r\nBUILD_BUG_ON(LOOPBACK_DATA != MC_CMD_LOOPBACK_DATA);\r\nBUILD_BUG_ON(LOOPBACK_GMAC != MC_CMD_LOOPBACK_GMAC);\r\nBUILD_BUG_ON(LOOPBACK_XGMII != MC_CMD_LOOPBACK_XGMII);\r\nBUILD_BUG_ON(LOOPBACK_XGXS != MC_CMD_LOOPBACK_XGXS);\r\nBUILD_BUG_ON(LOOPBACK_XAUI != MC_CMD_LOOPBACK_XAUI);\r\nBUILD_BUG_ON(LOOPBACK_GMII != MC_CMD_LOOPBACK_GMII);\r\nBUILD_BUG_ON(LOOPBACK_SGMII != MC_CMD_LOOPBACK_SGMII);\r\nBUILD_BUG_ON(LOOPBACK_XGBR != MC_CMD_LOOPBACK_XGBR);\r\nBUILD_BUG_ON(LOOPBACK_XFI != MC_CMD_LOOPBACK_XFI);\r\nBUILD_BUG_ON(LOOPBACK_XAUI_FAR != MC_CMD_LOOPBACK_XAUI_FAR);\r\nBUILD_BUG_ON(LOOPBACK_GMII_FAR != MC_CMD_LOOPBACK_GMII_FAR);\r\nBUILD_BUG_ON(LOOPBACK_SGMII_FAR != MC_CMD_LOOPBACK_SGMII_FAR);\r\nBUILD_BUG_ON(LOOPBACK_XFI_FAR != MC_CMD_LOOPBACK_XFI_FAR);\r\nBUILD_BUG_ON(LOOPBACK_GPHY != MC_CMD_LOOPBACK_GPHY);\r\nBUILD_BUG_ON(LOOPBACK_PHYXS != MC_CMD_LOOPBACK_PHYXS);\r\nBUILD_BUG_ON(LOOPBACK_PCS != MC_CMD_LOOPBACK_PCS);\r\nBUILD_BUG_ON(LOOPBACK_PMAPMD != MC_CMD_LOOPBACK_PMAPMD);\r\nBUILD_BUG_ON(LOOPBACK_XPORT != MC_CMD_LOOPBACK_XPORT);\r\nBUILD_BUG_ON(LOOPBACK_XGMII_WS != MC_CMD_LOOPBACK_XGMII_WS);\r\nBUILD_BUG_ON(LOOPBACK_XAUI_WS != MC_CMD_LOOPBACK_XAUI_WS);\r\nBUILD_BUG_ON(LOOPBACK_XAUI_WS_FAR != MC_CMD_LOOPBACK_XAUI_WS_FAR);\r\nBUILD_BUG_ON(LOOPBACK_XAUI_WS_NEAR != MC_CMD_LOOPBACK_XAUI_WS_NEAR);\r\nBUILD_BUG_ON(LOOPBACK_GMII_WS != MC_CMD_LOOPBACK_GMII_WS);\r\nBUILD_BUG_ON(LOOPBACK_XFI_WS != MC_CMD_LOOPBACK_XFI_WS);\r\nBUILD_BUG_ON(LOOPBACK_XFI_WS_FAR != MC_CMD_LOOPBACK_XFI_WS_FAR);\r\nBUILD_BUG_ON(LOOPBACK_PHYXS_WS != MC_CMD_LOOPBACK_PHYXS_WS);\r\nrc = efx_mcdi_loopback_modes(efx, &efx->loopback_modes);\r\nif (rc != 0)\r\ngoto fail;\r\nefx->loopback_modes &= ~(1 << LOOPBACK_NONE);\r\nefx_mcdi_phy_decode_link(\r\nefx, &efx->link_state,\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_LINK_SPEED),\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_FLAGS),\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_FCNTL));\r\nefx->wanted_fc = EFX_FC_RX | EFX_FC_TX;\r\nif (phy_data->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))\r\nefx->wanted_fc |= EFX_FC_AUTO;\r\nefx_link_set_wanted_fc(efx, efx->wanted_fc);\r\nreturn 0;\r\nfail:\r\nkfree(phy_data);\r\nreturn rc;\r\n}\r\nint efx_mcdi_port_reconfigure(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nu32 caps = (efx->link_advertising ?\r\nethtool_to_mcdi_cap(efx->link_advertising) :\r\nphy_cfg->forced_cap);\r\nreturn efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),\r\nefx->loopback_mode, 0);\r\n}\r\nstatic void efx_mcdi_phy_check_fcntl(struct efx_nic *efx, u32 lpa)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nu32 rmtadv;\r\nif (~phy_cfg->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))\r\nreturn;\r\nif (efx->wanted_fc & EFX_FC_AUTO)\r\nreturn;\r\nrmtadv = 0;\r\nif (lpa & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))\r\nrmtadv |= ADVERTISED_Pause;\r\nif (lpa & (1 << MC_CMD_PHY_CAP_ASYM_LBN))\r\nrmtadv |= ADVERTISED_Asym_Pause;\r\nif ((efx->wanted_fc & EFX_FC_TX) && rmtadv == ADVERTISED_Asym_Pause)\r\nnetif_err(efx, link, efx->net_dev,\r\n"warning: link partner doesn't support pause frames");\r\n}\r\nstatic bool efx_mcdi_phy_poll(struct efx_nic *efx)\r\n{\r\nstruct efx_link_state old_state = efx->link_state;\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_LINK_OUT_LEN);\r\nint rc;\r\nWARN_ON(!mutex_is_locked(&efx->mac_lock));\r\nBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc)\r\nefx->link_state.up = false;\r\nelse\r\nefx_mcdi_phy_decode_link(\r\nefx, &efx->link_state,\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_LINK_SPEED),\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_FLAGS),\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_FCNTL));\r\nreturn !efx_link_state_equal(&efx->link_state, &old_state);\r\n}\r\nstatic void efx_mcdi_phy_remove(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_phy_data *phy_data = efx->phy_data;\r\nefx->phy_data = NULL;\r\nkfree(phy_data);\r\n}\r\nstatic void efx_mcdi_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_LINK_OUT_LEN);\r\nint rc;\r\necmd->supported =\r\nmcdi_to_ethtool_cap(phy_cfg->media, phy_cfg->supported_cap);\r\necmd->advertising = efx->link_advertising;\r\nethtool_cmd_speed_set(ecmd, efx->link_state.speed);\r\necmd->duplex = efx->link_state.fd;\r\necmd->port = mcdi_to_ethtool_media(phy_cfg->media);\r\necmd->phy_address = phy_cfg->port;\r\necmd->transceiver = XCVR_INTERNAL;\r\necmd->autoneg = !!(efx->link_advertising & ADVERTISED_Autoneg);\r\necmd->mdio_support = (efx->mdio.mode_support &\r\n(MDIO_SUPPORTS_C45 | MDIO_SUPPORTS_C22));\r\nBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc)\r\nreturn;\r\necmd->lp_advertising =\r\nmcdi_to_ethtool_cap(phy_cfg->media,\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_LP_CAP));\r\n}\r\nstatic int efx_mcdi_phy_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nu32 caps;\r\nint rc;\r\nif (ecmd->autoneg) {\r\ncaps = (ethtool_to_mcdi_cap(ecmd->advertising) |\r\n1 << MC_CMD_PHY_CAP_AN_LBN);\r\n} else if (ecmd->duplex) {\r\nswitch (ethtool_cmd_speed(ecmd)) {\r\ncase 10: caps = 1 << MC_CMD_PHY_CAP_10FDX_LBN; break;\r\ncase 100: caps = 1 << MC_CMD_PHY_CAP_100FDX_LBN; break;\r\ncase 1000: caps = 1 << MC_CMD_PHY_CAP_1000FDX_LBN; break;\r\ncase 10000: caps = 1 << MC_CMD_PHY_CAP_10000FDX_LBN; break;\r\ncase 40000: caps = 1 << MC_CMD_PHY_CAP_40000FDX_LBN; break;\r\ndefault: return -EINVAL;\r\n}\r\n} else {\r\nswitch (ethtool_cmd_speed(ecmd)) {\r\ncase 10: caps = 1 << MC_CMD_PHY_CAP_10HDX_LBN; break;\r\ncase 100: caps = 1 << MC_CMD_PHY_CAP_100HDX_LBN; break;\r\ncase 1000: caps = 1 << MC_CMD_PHY_CAP_1000HDX_LBN; break;\r\ndefault: return -EINVAL;\r\n}\r\n}\r\nrc = efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),\r\nefx->loopback_mode, 0);\r\nif (rc)\r\nreturn rc;\r\nif (ecmd->autoneg) {\r\nefx_link_set_advertising(\r\nefx, ecmd->advertising | ADVERTISED_Autoneg);\r\nphy_cfg->forced_cap = 0;\r\n} else {\r\nefx_link_set_advertising(efx, 0);\r\nphy_cfg->forced_cap = caps;\r\n}\r\nreturn 0;\r\n}\r\nstatic int efx_mcdi_phy_test_alive(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_PHY_STATE_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_GET_PHY_STATE_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_PHY_STATE, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\nreturn rc;\r\nif (outlen < MC_CMD_GET_PHY_STATE_OUT_LEN)\r\nreturn -EIO;\r\nif (MCDI_DWORD(outbuf, GET_PHY_STATE_OUT_STATE) != MC_CMD_PHY_STATE_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int efx_mcdi_bist(struct efx_nic *efx, unsigned int bist_mode,\r\nint *results)\r\n{\r\nunsigned int retry, i, count = 0;\r\nsize_t outlen;\r\nu32 status;\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_START_BIST_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_POLL_BIST_OUT_SFT9001_LEN);\r\nu8 *ptr;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_START_BIST_OUT_LEN != 0);\r\nMCDI_SET_DWORD(inbuf, START_BIST_IN_TYPE, bist_mode);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_START_BIST,\r\ninbuf, MC_CMD_START_BIST_IN_LEN, NULL, 0, NULL);\r\nif (rc)\r\ngoto out;\r\nfor (retry = 0; retry < 100; ++retry) {\r\nBUILD_BUG_ON(MC_CMD_POLL_BIST_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_POLL_BIST, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto out;\r\nstatus = MCDI_DWORD(outbuf, POLL_BIST_OUT_RESULT);\r\nif (status != MC_CMD_POLL_BIST_RUNNING)\r\ngoto finished;\r\nmsleep(100);\r\n}\r\nrc = -ETIMEDOUT;\r\ngoto out;\r\nfinished:\r\nresults[count++] = (status == MC_CMD_POLL_BIST_PASSED) ? 1 : -1;\r\nif (efx->phy_type == PHY_TYPE_SFT9001B &&\r\n(bist_mode == MC_CMD_PHY_BIST_CABLE_SHORT ||\r\nbist_mode == MC_CMD_PHY_BIST_CABLE_LONG)) {\r\nptr = MCDI_PTR(outbuf, POLL_BIST_OUT_SFT9001_CABLE_LENGTH_A);\r\nif (status == MC_CMD_POLL_BIST_PASSED &&\r\noutlen >= MC_CMD_POLL_BIST_OUT_SFT9001_LEN) {\r\nfor (i = 0; i < 8; i++) {\r\nresults[count + i] =\r\nEFX_DWORD_FIELD(((efx_dword_t *)ptr)[i],\r\nEFX_DWORD_0);\r\n}\r\n}\r\ncount += 8;\r\n}\r\nrc = count;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_phy_run_tests(struct efx_nic *efx, int *results,\r\nunsigned flags)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nu32 mode;\r\nint rc;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_LBN)) {\r\nrc = efx_mcdi_bist(efx, MC_CMD_PHY_BIST, results);\r\nif (rc < 0)\r\nreturn rc;\r\nresults += rc;\r\n}\r\nmode = 0;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_LBN)) {\r\nif ((flags & ETH_TEST_FL_OFFLINE) &&\r\n(phy_cfg->flags &\r\n(1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN)))\r\nmode = MC_CMD_PHY_BIST_CABLE_LONG;\r\nelse\r\nmode = MC_CMD_PHY_BIST_CABLE_SHORT;\r\n} else if (phy_cfg->flags &\r\n(1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN))\r\nmode = MC_CMD_PHY_BIST_CABLE_LONG;\r\nif (mode != 0) {\r\nrc = efx_mcdi_bist(efx, mode, results);\r\nif (rc < 0)\r\nreturn rc;\r\nresults += rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *efx_mcdi_phy_test_name(struct efx_nic *efx,\r\nunsigned int index)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_LBN)) {\r\nif (index == 0)\r\nreturn "bist";\r\n--index;\r\n}\r\nif (phy_cfg->flags & ((1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_LBN) |\r\n(1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN))) {\r\nif (index == 0)\r\nreturn "cable";\r\n--index;\r\nif (efx->phy_type == PHY_TYPE_SFT9001B) {\r\nif (index < ARRAY_SIZE(mcdi_sft9001_cable_diag_names))\r\nreturn mcdi_sft9001_cable_diag_names[index];\r\nindex -= ARRAY_SIZE(mcdi_sft9001_cable_diag_names);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int efx_mcdi_phy_get_module_eeprom(struct efx_nic *efx,\r\nstruct ethtool_eeprom *ee, u8 *data)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_PHY_MEDIA_INFO_OUT_LENMAX);\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_GET_PHY_MEDIA_INFO_IN_LEN);\r\nsize_t outlen;\r\nint rc;\r\nunsigned int payload_len;\r\nunsigned int space_remaining = ee->len;\r\nunsigned int page;\r\nunsigned int page_off;\r\nunsigned int to_copy;\r\nu8 *user_data = data;\r\nBUILD_BUG_ON(SFP_PAGE_SIZE * SFP_NUM_PAGES != ETH_MODULE_SFF_8079_LEN);\r\npage_off = ee->offset % SFP_PAGE_SIZE;\r\npage = ee->offset / SFP_PAGE_SIZE;\r\nwhile (space_remaining && (page < SFP_NUM_PAGES)) {\r\nMCDI_SET_DWORD(inbuf, GET_PHY_MEDIA_INFO_IN_PAGE, page);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_PHY_MEDIA_INFO,\r\ninbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf),\r\n&outlen);\r\nif (rc)\r\nreturn rc;\r\nif (outlen < (MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATA_OFST +\r\nSFP_PAGE_SIZE))\r\nreturn -EIO;\r\npayload_len = MCDI_DWORD(outbuf,\r\nGET_PHY_MEDIA_INFO_OUT_DATALEN);\r\nif (payload_len != SFP_PAGE_SIZE)\r\nreturn -EIO;\r\npayload_len -= page_off;\r\nto_copy = (space_remaining < payload_len) ?\r\nspace_remaining : payload_len;\r\nmemcpy(user_data,\r\nMCDI_PTR(outbuf, GET_PHY_MEDIA_INFO_OUT_DATA) + page_off,\r\nto_copy);\r\nspace_remaining -= to_copy;\r\nuser_data += to_copy;\r\npage_off = 0;\r\npage++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int efx_mcdi_phy_get_module_info(struct efx_nic *efx,\r\nstruct ethtool_modinfo *modinfo)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nswitch (phy_cfg->media) {\r\ncase MC_CMD_MEDIA_SFP_PLUS:\r\nmodinfo->type = ETH_MODULE_SFF_8079;\r\nmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nu32 efx_mcdi_phy_get_caps(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_phy_data *phy_data = efx->phy_data;\r\nreturn phy_data->supported_cap;\r\n}\r\nvoid efx_mcdi_process_link_change(struct efx_nic *efx, efx_qword_t *ev)\r\n{\r\nu32 flags, fcntl, speed, lpa;\r\nspeed = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_SPEED);\r\nEFX_BUG_ON_PARANOID(speed >= ARRAY_SIZE(efx_mcdi_event_link_speed));\r\nspeed = efx_mcdi_event_link_speed[speed];\r\nflags = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_LINK_FLAGS);\r\nfcntl = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_FCNTL);\r\nlpa = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_LP_CAP);\r\nefx_mcdi_phy_decode_link(efx, &efx->link_state, speed, flags, fcntl);\r\nefx_mcdi_phy_check_fcntl(efx, lpa);\r\nefx_link_status_changed(efx);\r\n}\r\nint efx_mcdi_set_mac(struct efx_nic *efx)\r\n{\r\nu32 fcntl;\r\nMCDI_DECLARE_BUF(cmdbytes, MC_CMD_SET_MAC_IN_LEN);\r\nBUILD_BUG_ON(MC_CMD_SET_MAC_OUT_LEN != 0);\r\nether_addr_copy(MCDI_PTR(cmdbytes, SET_MAC_IN_ADDR),\r\nefx->net_dev->dev_addr);\r\nMCDI_SET_DWORD(cmdbytes, SET_MAC_IN_MTU,\r\nEFX_MAX_FRAME_LEN(efx->net_dev->mtu));\r\nMCDI_SET_DWORD(cmdbytes, SET_MAC_IN_DRAIN, 0);\r\nMCDI_POPULATE_DWORD_1(cmdbytes, SET_MAC_IN_REJECT,\r\nSET_MAC_IN_REJECT_UNCST, efx->unicast_filter);\r\nswitch (efx->wanted_fc) {\r\ncase EFX_FC_RX | EFX_FC_TX:\r\nfcntl = MC_CMD_FCNTL_BIDIR;\r\nbreak;\r\ncase EFX_FC_RX:\r\nfcntl = MC_CMD_FCNTL_RESPOND;\r\nbreak;\r\ndefault:\r\nfcntl = MC_CMD_FCNTL_OFF;\r\nbreak;\r\n}\r\nif (efx->wanted_fc & EFX_FC_AUTO)\r\nfcntl = MC_CMD_FCNTL_AUTO;\r\nif (efx->fc_disable)\r\nfcntl = MC_CMD_FCNTL_OFF;\r\nMCDI_SET_DWORD(cmdbytes, SET_MAC_IN_FCNTL, fcntl);\r\nreturn efx_mcdi_rpc(efx, MC_CMD_SET_MAC, cmdbytes, sizeof(cmdbytes),\r\nNULL, 0, NULL);\r\n}\r\nbool efx_mcdi_mac_check_fault(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_LINK_OUT_LEN);\r\nsize_t outlength;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlength);\r\nif (rc)\r\nreturn true;\r\nreturn MCDI_DWORD(outbuf, GET_LINK_OUT_MAC_FAULT) != 0;\r\n}\r\nstatic int efx_mcdi_mac_stats(struct efx_nic *efx,\r\nenum efx_stats_action action, int clear)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_MAC_STATS_IN_LEN);\r\nint rc;\r\nint change = action == EFX_STATS_PULL ? 0 : 1;\r\nint enable = action == EFX_STATS_ENABLE ? 1 : 0;\r\nint period = action == EFX_STATS_ENABLE ? 1000 : 0;\r\ndma_addr_t dma_addr = efx->stats_buffer.dma_addr;\r\nu32 dma_len = action != EFX_STATS_DISABLE ?\r\nMC_CMD_MAC_NSTATS * sizeof(u64) : 0;\r\nBUILD_BUG_ON(MC_CMD_MAC_STATS_OUT_DMA_LEN != 0);\r\nMCDI_SET_QWORD(inbuf, MAC_STATS_IN_DMA_ADDR, dma_addr);\r\nMCDI_POPULATE_DWORD_7(inbuf, MAC_STATS_IN_CMD,\r\nMAC_STATS_IN_DMA, !!enable,\r\nMAC_STATS_IN_CLEAR, clear,\r\nMAC_STATS_IN_PERIODIC_CHANGE, change,\r\nMAC_STATS_IN_PERIODIC_ENABLE, enable,\r\nMAC_STATS_IN_PERIODIC_CLEAR, 0,\r\nMAC_STATS_IN_PERIODIC_NOEVENT, 1,\r\nMAC_STATS_IN_PERIOD_MS, period);\r\nMCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_LEN, dma_len);\r\nMCDI_SET_DWORD(inbuf, MAC_STATS_IN_PORT_ID, nic_data->vport_id);\r\nrc = efx_mcdi_rpc_quiet(efx, MC_CMD_MAC_STATS, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc && (rc != -ENOENT || atomic_read(&efx->active_queues)))\r\nefx_mcdi_display_error(efx, MC_CMD_MAC_STATS, sizeof(inbuf),\r\nNULL, 0, rc);\r\nreturn rc;\r\n}\r\nvoid efx_mcdi_mac_start_stats(struct efx_nic *efx)\r\n{\r\n__le64 *dma_stats = efx->stats_buffer.addr;\r\ndma_stats[MC_CMD_MAC_GENERATION_END] = EFX_MC_STATS_GENERATION_INVALID;\r\nefx_mcdi_mac_stats(efx, EFX_STATS_ENABLE, 0);\r\n}\r\nvoid efx_mcdi_mac_stop_stats(struct efx_nic *efx)\r\n{\r\nefx_mcdi_mac_stats(efx, EFX_STATS_DISABLE, 0);\r\n}\r\nvoid efx_mcdi_mac_pull_stats(struct efx_nic *efx)\r\n{\r\n__le64 *dma_stats = efx->stats_buffer.addr;\r\nint attempts = EFX_MAC_STATS_WAIT_ATTEMPTS;\r\ndma_stats[MC_CMD_MAC_GENERATION_END] = EFX_MC_STATS_GENERATION_INVALID;\r\nefx_mcdi_mac_stats(efx, EFX_STATS_PULL, 0);\r\nwhile (dma_stats[MC_CMD_MAC_GENERATION_END] ==\r\nEFX_MC_STATS_GENERATION_INVALID &&\r\nattempts-- != 0)\r\nudelay(EFX_MAC_STATS_WAIT_US);\r\n}\r\nint efx_mcdi_port_probe(struct efx_nic *efx)\r\n{\r\nint rc;\r\nefx->phy_op = &efx_mcdi_phy_ops;\r\nefx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\r\nefx->mdio.mdio_read = efx_mcdi_mdio_read;\r\nefx->mdio.mdio_write = efx_mcdi_mdio_write;\r\nrc = efx->phy_op->probe(efx);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = efx_nic_alloc_buffer(efx, &efx->stats_buffer,\r\nMC_CMD_MAC_NSTATS * sizeof(u64), GFP_KERNEL);\r\nif (rc)\r\nreturn rc;\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"stats buffer at %llx (virt %p phys %llx)\n",\r\n(u64)efx->stats_buffer.dma_addr,\r\nefx->stats_buffer.addr,\r\n(u64)virt_to_phys(efx->stats_buffer.addr));\r\nefx_mcdi_mac_stats(efx, EFX_STATS_DISABLE, 1);\r\nreturn 0;\r\n}\r\nvoid efx_mcdi_port_remove(struct efx_nic *efx)\r\n{\r\nefx->phy_op->remove(efx);\r\nefx_nic_free_buffer(efx, &efx->stats_buffer);\r\n}\r\nint efx_mcdi_port_get_number(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_PORT_ASSIGNMENT_OUT_LEN);\r\nint rc;\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_PORT_ASSIGNMENT, NULL, 0,\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc)\r\nreturn rc;\r\nreturn MCDI_DWORD(outbuf, GET_PORT_ASSIGNMENT_OUT_PORT);\r\n}
