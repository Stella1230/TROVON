static inline unsigned uts_reg(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->uts_reg;\r\n}\r\nstatic inline int is_imx1_uart(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->devtype == IMX1_UART;\r\n}\r\nstatic inline int is_imx21_uart(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->devtype == IMX21_UART;\r\n}\r\nstatic inline int is_imx6q_uart(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->devtype == IMX6Q_UART;\r\n}\r\nstatic void imx_port_ucrs_save(struct uart_port *port,\r\nstruct imx_port_ucrs *ucr)\r\n{\r\nucr->ucr1 = readl(port->membase + UCR1);\r\nucr->ucr2 = readl(port->membase + UCR2);\r\nucr->ucr3 = readl(port->membase + UCR3);\r\n}\r\nstatic void imx_port_ucrs_restore(struct uart_port *port,\r\nstruct imx_port_ucrs *ucr)\r\n{\r\nwritel(ucr->ucr1, port->membase + UCR1);\r\nwritel(ucr->ucr2, port->membase + UCR2);\r\nwritel(ucr->ucr3, port->membase + UCR3);\r\n}\r\nstatic void imx_port_rts_active(struct imx_port *sport, unsigned long *ucr2)\r\n{\r\n*ucr2 &= ~UCR2_CTSC;\r\n*ucr2 |= UCR2_CTS;\r\nmctrl_gpio_set(sport->gpios, sport->port.mctrl | TIOCM_RTS);\r\n}\r\nstatic void imx_port_rts_inactive(struct imx_port *sport, unsigned long *ucr2)\r\n{\r\n*ucr2 &= ~(UCR2_CTSC | UCR2_CTS);\r\nmctrl_gpio_set(sport->gpios, sport->port.mctrl & ~TIOCM_RTS);\r\n}\r\nstatic void imx_port_rts_auto(struct imx_port *sport, unsigned long *ucr2)\r\n{\r\n*ucr2 |= UCR2_CTSC;\r\n}\r\nstatic void imx_stop_tx(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nif (sport->dma_is_enabled && sport->dma_is_txing)\r\nreturn;\r\ntemp = readl(port->membase + UCR1);\r\nwritel(temp & ~UCR1_TXMPTYEN, port->membase + UCR1);\r\nif (port->rs485.flags & SER_RS485_ENABLED &&\r\nreadl(port->membase + USR2) & USR2_TXDC) {\r\ntemp = readl(port->membase + UCR2);\r\nif (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)\r\nimx_port_rts_inactive(sport, &temp);\r\nelse\r\nimx_port_rts_active(sport, &temp);\r\ntemp |= UCR2_RXEN;\r\nwritel(temp, port->membase + UCR2);\r\ntemp = readl(port->membase + UCR4);\r\ntemp &= ~UCR4_TCEN;\r\nwritel(temp, port->membase + UCR4);\r\n}\r\n}\r\nstatic void imx_stop_rx(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nif (sport->dma_is_enabled && sport->dma_is_rxing) {\r\nif (sport->port.suspended) {\r\ndmaengine_terminate_all(sport->dma_chan_rx);\r\nsport->dma_is_rxing = 0;\r\n} else {\r\nreturn;\r\n}\r\n}\r\ntemp = readl(sport->port.membase + UCR2);\r\nwritel(temp & ~UCR2_RXEN, sport->port.membase + UCR2);\r\ntemp = readl(sport->port.membase + UCR1);\r\nwritel(temp & ~UCR1_RRDYEN, sport->port.membase + UCR1);\r\n}\r\nstatic void imx_enable_ms(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nmod_timer(&sport->timer, jiffies);\r\nmctrl_gpio_enable_ms(sport->gpios);\r\n}\r\nstatic inline void imx_transmit_buffer(struct imx_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long temp;\r\nif (sport->port.x_char) {\r\nwritel(sport->port.x_char, sport->port.membase + URTX0);\r\nsport->port.icount.tx++;\r\nsport->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {\r\nimx_stop_tx(&sport->port);\r\nreturn;\r\n}\r\nif (sport->dma_is_enabled) {\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~UCR1_TXMPTYEN;\r\nif (sport->dma_is_txing) {\r\ntemp |= UCR1_TDMAEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\n} else {\r\nwritel(temp, sport->port.membase + UCR1);\r\nimx_dma_tx(sport);\r\n}\r\n}\r\nwhile (!uart_circ_empty(xmit) &&\r\n!(readl(sport->port.membase + uts_reg(sport)) & UTS_TXFULL)) {\r\nwritel(xmit->buf[xmit->tail], sport->port.membase + URTX0);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nif (uart_circ_empty(xmit))\r\nimx_stop_tx(&sport->port);\r\n}\r\nstatic void dma_tx_callback(void *data)\r\n{\r\nstruct imx_port *sport = data;\r\nstruct scatterlist *sgl = &sport->tx_sgl[0];\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long flags;\r\nunsigned long temp;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ndma_unmap_sg(sport->port.dev, sgl, sport->dma_tx_nents, DMA_TO_DEVICE);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~UCR1_TDMAEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\nxmit->tail = (xmit->tail + sport->tx_bytes) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx += sport->tx_bytes;\r\ndev_dbg(sport->port.dev, "we finish the TX DMA.\n");\r\nsport->dma_is_txing = 0;\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nif (waitqueue_active(&sport->dma_wait)) {\r\nwake_up(&sport->dma_wait);\r\ndev_dbg(sport->port.dev, "exit in %s.\n", __func__);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nif (!uart_circ_empty(xmit) && !uart_tx_stopped(&sport->port))\r\nimx_dma_tx(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic void imx_dma_tx(struct imx_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nstruct scatterlist *sgl = sport->tx_sgl;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_chan *chan = sport->dma_chan_tx;\r\nstruct device *dev = sport->port.dev;\r\nunsigned long temp;\r\nint ret;\r\nif (sport->dma_is_txing)\r\nreturn;\r\nsport->tx_bytes = uart_circ_chars_pending(xmit);\r\nif (xmit->tail < xmit->head) {\r\nsport->dma_tx_nents = 1;\r\nsg_init_one(sgl, xmit->buf + xmit->tail, sport->tx_bytes);\r\n} else {\r\nsport->dma_tx_nents = 2;\r\nsg_init_table(sgl, 2);\r\nsg_set_buf(sgl, xmit->buf + xmit->tail,\r\nUART_XMIT_SIZE - xmit->tail);\r\nsg_set_buf(sgl + 1, xmit->buf, xmit->head);\r\n}\r\nret = dma_map_sg(dev, sgl, sport->dma_tx_nents, DMA_TO_DEVICE);\r\nif (ret == 0) {\r\ndev_err(dev, "DMA mapping error for TX.\n");\r\nreturn;\r\n}\r\ndesc = dmaengine_prep_slave_sg(chan, sgl, sport->dma_tx_nents,\r\nDMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\r\nif (!desc) {\r\ndma_unmap_sg(dev, sgl, sport->dma_tx_nents,\r\nDMA_TO_DEVICE);\r\ndev_err(dev, "We cannot prepare for the TX slave dma!\n");\r\nreturn;\r\n}\r\ndesc->callback = dma_tx_callback;\r\ndesc->callback_param = sport;\r\ndev_dbg(dev, "TX: prepare to send %lu bytes by DMA.\n",\r\nuart_circ_chars_pending(xmit));\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_TDMAEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\nsport->dma_is_txing = 1;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(chan);\r\nreturn;\r\n}\r\nstatic void imx_start_tx(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nif (port->rs485.flags & SER_RS485_ENABLED) {\r\ntemp = readl(port->membase + UCR2);\r\nif (port->rs485.flags & SER_RS485_RTS_ON_SEND)\r\nimx_port_rts_inactive(sport, &temp);\r\nelse\r\nimx_port_rts_active(sport, &temp);\r\nif (!(port->rs485.flags & SER_RS485_RX_DURING_TX))\r\ntemp &= ~UCR2_RXEN;\r\nwritel(temp, port->membase + UCR2);\r\ntemp = readl(port->membase + UCR4);\r\ntemp |= UCR4_TCEN;\r\nwritel(temp, port->membase + UCR4);\r\n}\r\nif (!sport->dma_is_enabled) {\r\ntemp = readl(sport->port.membase + UCR1);\r\nwritel(temp | UCR1_TXMPTYEN, sport->port.membase + UCR1);\r\n}\r\nif (sport->dma_is_enabled) {\r\nif (sport->port.x_char) {\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~UCR1_TDMAEN;\r\ntemp |= UCR1_TXMPTYEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\nreturn;\r\n}\r\nif (!uart_circ_empty(&port->state->xmit) &&\r\n!uart_tx_stopped(port))\r\nimx_dma_tx(sport);\r\nreturn;\r\n}\r\n}\r\nstatic irqreturn_t imx_rtsint(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nunsigned int val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwritel(USR1_RTSD, sport->port.membase + USR1);\r\nval = readl(sport->port.membase + USR1) & USR1_RTSS;\r\nuart_handle_cts_change(&sport->port, !!val);\r\nwake_up_interruptible(&sport->port.state->port.delta_msr_wait);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t imx_txint(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nimx_transmit_buffer(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t imx_rxint(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nunsigned int rx, flg, ignored = 0;\r\nstruct tty_port *port = &sport->port.state->port;\r\nunsigned long flags, temp;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwhile (readl(sport->port.membase + USR2) & USR2_RDR) {\r\nflg = TTY_NORMAL;\r\nsport->port.icount.rx++;\r\nrx = readl(sport->port.membase + URXD0);\r\ntemp = readl(sport->port.membase + USR2);\r\nif (temp & USR2_BRCD) {\r\nwritel(USR2_BRCD, sport->port.membase + USR2);\r\nif (uart_handle_break(&sport->port))\r\ncontinue;\r\n}\r\nif (uart_handle_sysrq_char(&sport->port, (unsigned char)rx))\r\ncontinue;\r\nif (unlikely(rx & URXD_ERR)) {\r\nif (rx & URXD_BRK)\r\nsport->port.icount.brk++;\r\nelse if (rx & URXD_PRERR)\r\nsport->port.icount.parity++;\r\nelse if (rx & URXD_FRMERR)\r\nsport->port.icount.frame++;\r\nif (rx & URXD_OVRRUN)\r\nsport->port.icount.overrun++;\r\nif (rx & sport->port.ignore_status_mask) {\r\nif (++ignored > 100)\r\ngoto out;\r\ncontinue;\r\n}\r\nrx &= (sport->port.read_status_mask | 0xFF);\r\nif (rx & URXD_BRK)\r\nflg = TTY_BREAK;\r\nelse if (rx & URXD_PRERR)\r\nflg = TTY_PARITY;\r\nelse if (rx & URXD_FRMERR)\r\nflg = TTY_FRAME;\r\nif (rx & URXD_OVRRUN)\r\nflg = TTY_OVERRUN;\r\n#ifdef SUPPORT_SYSRQ\r\nsport->port.sysrq = 0;\r\n#endif\r\n}\r\nif (sport->port.ignore_status_mask & URXD_DUMMY_READ)\r\ngoto out;\r\nif (tty_insert_flip_char(port, rx, flg) == 0)\r\nsport->port.icount.buf_overrun++;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\ntty_flip_buffer_push(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void imx_dma_rxint(struct imx_port *sport)\r\n{\r\nunsigned long temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + USR2);\r\nif ((temp & USR2_RDR) && !sport->dma_is_rxing) {\r\nsport->dma_is_rxing = 1;\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_RRDYEN);\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~(UCR2_ATEN);\r\nwritel(temp, sport->port.membase + UCR2);\r\nstart_rx_dma(sport);\r\n}\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic unsigned int imx_get_hwmctrl(struct imx_port *sport)\r\n{\r\nunsigned int tmp = TIOCM_DSR;\r\nunsigned usr1 = readl(sport->port.membase + USR1);\r\nif (usr1 & USR1_RTSS)\r\ntmp |= TIOCM_CTS;\r\nif (!(usr1 & USR2_DCDIN))\r\ntmp |= TIOCM_CAR;\r\nif (sport->dte_mode)\r\nif (!(readl(sport->port.membase + USR2) & USR2_RIIN))\r\ntmp |= TIOCM_RI;\r\nreturn tmp;\r\n}\r\nstatic void imx_mctrl_check(struct imx_port *sport)\r\n{\r\nunsigned int status, changed;\r\nstatus = imx_get_hwmctrl(sport);\r\nchanged = status ^ sport->old_status;\r\nif (changed == 0)\r\nreturn;\r\nsport->old_status = status;\r\nif (changed & TIOCM_RI && status & TIOCM_RI)\r\nsport->port.icount.rng++;\r\nif (changed & TIOCM_DSR)\r\nsport->port.icount.dsr++;\r\nif (changed & TIOCM_CAR)\r\nuart_handle_dcd_change(&sport->port, status & TIOCM_CAR);\r\nif (changed & TIOCM_CTS)\r\nuart_handle_cts_change(&sport->port, status & TIOCM_CTS);\r\nwake_up_interruptible(&sport->port.state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t imx_int(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nunsigned int sts;\r\nunsigned int sts2;\r\nirqreturn_t ret = IRQ_NONE;\r\nsts = readl(sport->port.membase + USR1);\r\nsts2 = readl(sport->port.membase + USR2);\r\nif (sts & (USR1_RRDY | USR1_AGTIM)) {\r\nif (sport->dma_is_enabled)\r\nimx_dma_rxint(sport);\r\nelse\r\nimx_rxint(irq, dev_id);\r\nret = IRQ_HANDLED;\r\n}\r\nif ((sts & USR1_TRDY &&\r\nreadl(sport->port.membase + UCR1) & UCR1_TXMPTYEN) ||\r\n(sts2 & USR2_TXDC &&\r\nreadl(sport->port.membase + UCR4) & UCR4_TCEN)) {\r\nimx_txint(irq, dev_id);\r\nret = IRQ_HANDLED;\r\n}\r\nif (sts & USR1_DTRD) {\r\nunsigned long flags;\r\nif (sts & USR1_DTRD)\r\nwritel(USR1_DTRD, sport->port.membase + USR1);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nimx_mctrl_check(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nret = IRQ_HANDLED;\r\n}\r\nif (sts & USR1_RTSD) {\r\nimx_rtsint(irq, dev_id);\r\nret = IRQ_HANDLED;\r\n}\r\nif (sts & USR1_AWAKE) {\r\nwritel(USR1_AWAKE, sport->port.membase + USR1);\r\nret = IRQ_HANDLED;\r\n}\r\nif (sts2 & USR2_ORE) {\r\nsport->port.icount.overrun++;\r\nwritel(USR2_ORE, sport->port.membase + USR2);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int imx_tx_empty(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned int ret;\r\nret = (readl(sport->port.membase + USR2) & USR2_TXDC) ? TIOCSER_TEMT : 0;\r\nif (sport->dma_is_enabled && sport->dma_is_txing)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic unsigned int imx_get_mctrl(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned int ret = imx_get_hwmctrl(sport);\r\nmctrl_gpio_get(sport->gpios, &ret);\r\nreturn ret;\r\n}\r\nstatic void imx_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nif (!(port->rs485.flags & SER_RS485_ENABLED)) {\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~(UCR2_CTS | UCR2_CTSC);\r\nif (mctrl & TIOCM_RTS)\r\ntemp |= UCR2_CTS | UCR2_CTSC;\r\nwritel(temp, sport->port.membase + UCR2);\r\n}\r\ntemp = readl(sport->port.membase + UCR3) & ~UCR3_DSR;\r\nif (!(mctrl & TIOCM_DTR))\r\ntemp |= UCR3_DSR;\r\nwritel(temp, sport->port.membase + UCR3);\r\ntemp = readl(sport->port.membase + uts_reg(sport)) & ~UTS_LOOP;\r\nif (mctrl & TIOCM_LOOP)\r\ntemp |= UTS_LOOP;\r\nwritel(temp, sport->port.membase + uts_reg(sport));\r\nmctrl_gpio_set(sport->gpios, mctrl);\r\n}\r\nstatic void imx_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long flags, temp;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR1) & ~UCR1_SNDBRK;\r\nif (break_state != 0)\r\ntemp |= UCR1_SNDBRK;\r\nwritel(temp, sport->port.membase + UCR1);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic void imx_timeout(unsigned long data)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)data;\r\nunsigned long flags;\r\nif (sport->port.state) {\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nimx_mctrl_check(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nmod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);\r\n}\r\n}\r\nstatic void imx_rx_dma_done(struct imx_port *sport)\r\n{\r\nunsigned long temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_RRDYEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp |= UCR2_ATEN;\r\nwritel(temp, sport->port.membase + UCR2);\r\nsport->dma_is_rxing = 0;\r\nif (waitqueue_active(&sport->dma_wait))\r\nwake_up(&sport->dma_wait);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic void dma_rx_callback(void *data)\r\n{\r\nstruct imx_port *sport = data;\r\nstruct dma_chan *chan = sport->dma_chan_rx;\r\nstruct scatterlist *sgl = &sport->rx_sgl;\r\nstruct tty_port *port = &sport->port.state->port;\r\nstruct dma_tx_state state;\r\nenum dma_status status;\r\nunsigned int count;\r\ndma_unmap_sg(sport->port.dev, sgl, 1, DMA_FROM_DEVICE);\r\nstatus = dmaengine_tx_status(chan, (dma_cookie_t)0, &state);\r\ncount = RX_BUF_SIZE - state.residue;\r\ndev_dbg(sport->port.dev, "We get %d bytes.\n", count);\r\nif (count) {\r\nif (!(sport->port.ignore_status_mask & URXD_DUMMY_READ)) {\r\nint bytes = tty_insert_flip_string(port, sport->rx_buf,\r\ncount);\r\nif (bytes != count)\r\nsport->port.icount.buf_overrun++;\r\n}\r\ntty_flip_buffer_push(port);\r\nsport->port.icount.rx += count;\r\n}\r\nif (readl(sport->port.membase + USR2) & USR2_RDR)\r\nstart_rx_dma(sport);\r\nelse\r\nimx_rx_dma_done(sport);\r\n}\r\nstatic int start_rx_dma(struct imx_port *sport)\r\n{\r\nstruct scatterlist *sgl = &sport->rx_sgl;\r\nstruct dma_chan *chan = sport->dma_chan_rx;\r\nstruct device *dev = sport->port.dev;\r\nstruct dma_async_tx_descriptor *desc;\r\nint ret;\r\nsg_init_one(sgl, sport->rx_buf, RX_BUF_SIZE);\r\nret = dma_map_sg(dev, sgl, 1, DMA_FROM_DEVICE);\r\nif (ret == 0) {\r\ndev_err(dev, "DMA mapping error for RX.\n");\r\nreturn -EINVAL;\r\n}\r\ndesc = dmaengine_prep_slave_sg(chan, sgl, 1, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT);\r\nif (!desc) {\r\ndma_unmap_sg(dev, sgl, 1, DMA_FROM_DEVICE);\r\ndev_err(dev, "We cannot prepare for the RX slave dma!\n");\r\nreturn -EINVAL;\r\n}\r\ndesc->callback = dma_rx_callback;\r\ndesc->callback_param = sport;\r\ndev_dbg(dev, "RX: prepare for the DMA.\n");\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(chan);\r\nreturn 0;\r\n}\r\nstatic void imx_setup_ufcr(struct imx_port *sport,\r\nunsigned char txwl, unsigned char rxwl)\r\n{\r\nunsigned int val;\r\nval = readl(sport->port.membase + UFCR) & (UFCR_RFDIV | UFCR_DCEDTE);\r\nval |= txwl << UFCR_TXTL_SHF | rxwl;\r\nwritel(val, sport->port.membase + UFCR);\r\n}\r\nstatic void imx_uart_dma_exit(struct imx_port *sport)\r\n{\r\nif (sport->dma_chan_rx) {\r\ndma_release_channel(sport->dma_chan_rx);\r\nsport->dma_chan_rx = NULL;\r\nkfree(sport->rx_buf);\r\nsport->rx_buf = NULL;\r\n}\r\nif (sport->dma_chan_tx) {\r\ndma_release_channel(sport->dma_chan_tx);\r\nsport->dma_chan_tx = NULL;\r\n}\r\nsport->dma_is_inited = 0;\r\n}\r\nstatic int imx_uart_dma_init(struct imx_port *sport)\r\n{\r\nstruct dma_slave_config slave_config = {};\r\nstruct device *dev = sport->port.dev;\r\nint ret;\r\nsport->dma_chan_rx = dma_request_slave_channel(dev, "rx");\r\nif (!sport->dma_chan_rx) {\r\ndev_dbg(dev, "cannot get the DMA channel.\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nslave_config.direction = DMA_DEV_TO_MEM;\r\nslave_config.src_addr = sport->port.mapbase + URXD0;\r\nslave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nslave_config.src_maxburst = RXTL_DMA - 1;\r\nret = dmaengine_slave_config(sport->dma_chan_rx, &slave_config);\r\nif (ret) {\r\ndev_err(dev, "error in RX dma configuration.\n");\r\ngoto err;\r\n}\r\nsport->rx_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!sport->rx_buf) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsport->dma_chan_tx = dma_request_slave_channel(dev, "tx");\r\nif (!sport->dma_chan_tx) {\r\ndev_err(dev, "cannot get the TX DMA channel!\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nslave_config.direction = DMA_MEM_TO_DEV;\r\nslave_config.dst_addr = sport->port.mapbase + URTX0;\r\nslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nslave_config.dst_maxburst = TXTL_DMA;\r\nret = dmaengine_slave_config(sport->dma_chan_tx, &slave_config);\r\nif (ret) {\r\ndev_err(dev, "error in TX dma configuration.");\r\ngoto err;\r\n}\r\nsport->dma_is_inited = 1;\r\nreturn 0;\r\nerr:\r\nimx_uart_dma_exit(sport);\r\nreturn ret;\r\n}\r\nstatic void imx_enable_dma(struct imx_port *sport)\r\n{\r\nunsigned long temp;\r\ninit_waitqueue_head(&sport->dma_wait);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_RDMAEN | UCR1_TDMAEN | UCR1_ATDMAEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp |= UCR2_ATEN;\r\nwritel(temp, sport->port.membase + UCR2);\r\nimx_setup_ufcr(sport, TXTL_DMA, RXTL_DMA);\r\nsport->dma_is_enabled = 1;\r\n}\r\nstatic void imx_disable_dma(struct imx_port *sport)\r\n{\r\nunsigned long temp;\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_RDMAEN | UCR1_TDMAEN | UCR1_ATDMAEN);\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~(UCR2_CTSC | UCR2_CTS | UCR2_ATEN);\r\nwritel(temp, sport->port.membase + UCR2);\r\nimx_setup_ufcr(sport, TXTL_DEFAULT, RXTL_DEFAULT);\r\nsport->dma_is_enabled = 0;\r\n}\r\nstatic int imx_startup(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nint retval, i;\r\nunsigned long flags, temp;\r\nretval = clk_prepare_enable(sport->clk_per);\r\nif (retval)\r\nreturn retval;\r\nretval = clk_prepare_enable(sport->clk_ipg);\r\nif (retval) {\r\nclk_disable_unprepare(sport->clk_per);\r\nreturn retval;\r\n}\r\nimx_setup_ufcr(sport, TXTL_DEFAULT, RXTL_DEFAULT);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp &= ~(UCR4_CTSTL_MASK << UCR4_CTSTL_SHF);\r\ntemp |= CTSTL << UCR4_CTSTL_SHF;\r\nwritel(temp & ~UCR4_DREN, sport->port.membase + UCR4);\r\nif (is_imx6q_uart(sport) && !uart_console(port) &&\r\n!sport->dma_is_inited)\r\nimx_uart_dma_init(sport);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ni = 100;\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~UCR2_SRST;\r\nwritel(temp, sport->port.membase + UCR2);\r\nwhile (!(readl(sport->port.membase + UCR2) & UCR2_SRST) && (--i > 0))\r\nudelay(1);\r\nwritel(USR1_RTSD | USR1_DTRD, sport->port.membase + USR1);\r\nwritel(USR2_ORE, sport->port.membase + USR2);\r\nif (sport->dma_is_inited && !sport->dma_is_enabled)\r\nimx_enable_dma(sport);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_RRDYEN | UCR1_RTSDEN | UCR1_UARTEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp |= UCR4_OREN;\r\nwritel(temp, sport->port.membase + UCR4);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp |= (UCR2_RXEN | UCR2_TXEN);\r\nif (!sport->have_rtscts)\r\ntemp |= UCR2_IRTS;\r\nif (!is_imx1_uart(sport))\r\ntemp &= ~UCR2_RTSEN;\r\nwritel(temp, sport->port.membase + UCR2);\r\nif (!is_imx1_uart(sport)) {\r\ntemp = readl(sport->port.membase + UCR3);\r\ntemp |= IMX21_UCR3_RXDMUXSEL | UCR3_ADNIMP |\r\nUCR3_DTRDEN | UCR3_RI | UCR3_DCD;\r\nif (sport->dte_mode)\r\ntemp &= ~(UCR3_RI | UCR3_DCD);\r\nwritel(temp, sport->port.membase + UCR3);\r\n}\r\nimx_enable_ms(&sport->port);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void imx_shutdown(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nunsigned long flags;\r\nif (sport->dma_is_enabled) {\r\nint ret;\r\nret = wait_event_interruptible(sport->dma_wait,\r\n!sport->dma_is_rxing && !sport->dma_is_txing);\r\nif (ret != 0) {\r\nsport->dma_is_rxing = 0;\r\nsport->dma_is_txing = 0;\r\ndmaengine_terminate_all(sport->dma_chan_tx);\r\ndmaengine_terminate_all(sport->dma_chan_rx);\r\n}\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nimx_stop_tx(port);\r\nimx_stop_rx(port);\r\nimx_disable_dma(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nimx_uart_dma_exit(sport);\r\n}\r\nmctrl_gpio_disable_ms(sport->gpios);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~(UCR2_TXEN);\r\nwritel(temp, sport->port.membase + UCR2);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\ndel_timer_sync(&sport->timer);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_RTSDEN | UCR1_UARTEN);\r\nwritel(temp, sport->port.membase + UCR1);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nclk_disable_unprepare(sport->clk_per);\r\nclk_disable_unprepare(sport->clk_ipg);\r\n}\r\nstatic void imx_flush_buffer(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nstruct scatterlist *sgl = &sport->tx_sgl[0];\r\nunsigned long temp;\r\nint i = 100, ubir, ubmr, uts;\r\nif (!sport->dma_chan_tx)\r\nreturn;\r\nsport->tx_bytes = 0;\r\ndmaengine_terminate_all(sport->dma_chan_tx);\r\nif (sport->dma_is_txing) {\r\ndma_unmap_sg(sport->port.dev, sgl, sport->dma_tx_nents,\r\nDMA_TO_DEVICE);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~UCR1_TDMAEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\nsport->dma_is_txing = false;\r\n}\r\nubir = readl(sport->port.membase + UBIR);\r\nubmr = readl(sport->port.membase + UBMR);\r\nuts = readl(sport->port.membase + IMX21_UTS);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~UCR2_SRST;\r\nwritel(temp, sport->port.membase + UCR2);\r\nwhile (!(readl(sport->port.membase + UCR2) & UCR2_SRST) && (--i > 0))\r\nudelay(1);\r\nwritel(ubir, sport->port.membase + UBIR);\r\nwritel(ubmr, sport->port.membase + UBMR);\r\nwritel(uts, sport->port.membase + IMX21_UTS);\r\n}\r\nstatic void\r\nimx_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long flags;\r\nunsigned long ucr2, old_ucr1, old_ucr2;\r\nunsigned int baud, quot;\r\nunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\r\nunsigned long div, ufcr;\r\nunsigned long num, denom;\r\nuint64_t tdiv64;\r\nwhile ((termios->c_cflag & CSIZE) != CS7 &&\r\n(termios->c_cflag & CSIZE) != CS8) {\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= old_csize;\r\nold_csize = CS8;\r\n}\r\nif ((termios->c_cflag & CSIZE) == CS8)\r\nucr2 = UCR2_WS | UCR2_SRST | UCR2_IRTS;\r\nelse\r\nucr2 = UCR2_SRST | UCR2_IRTS;\r\nif (termios->c_cflag & CRTSCTS) {\r\nif (sport->have_rtscts) {\r\nucr2 &= ~UCR2_IRTS;\r\nif (port->rs485.flags & SER_RS485_ENABLED) {\r\nif (port->rs485.flags &\r\nSER_RS485_RTS_AFTER_SEND)\r\nimx_port_rts_inactive(sport, &ucr2);\r\nelse\r\nimx_port_rts_active(sport, &ucr2);\r\n} else {\r\nimx_port_rts_auto(sport, &ucr2);\r\n}\r\n} else {\r\ntermios->c_cflag &= ~CRTSCTS;\r\n}\r\n} else if (port->rs485.flags & SER_RS485_ENABLED) {\r\nif (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)\r\nimx_port_rts_inactive(sport, &ucr2);\r\nelse\r\nimx_port_rts_active(sport, &ucr2);\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nucr2 |= UCR2_STPB;\r\nif (termios->c_cflag & PARENB) {\r\nucr2 |= UCR2_PREN;\r\nif (termios->c_cflag & PARODD)\r\nucr2 |= UCR2_PROE;\r\n}\r\ndel_timer_sync(&sport->timer);\r\nbaud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 16);\r\nquot = uart_get_divisor(port, baud);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nsport->port.read_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nsport->port.read_status_mask |= (URXD_FRMERR | URXD_PRERR);\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nsport->port.read_status_mask |= URXD_BRK;\r\nsport->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= URXD_PRERR | URXD_FRMERR;\r\nif (termios->c_iflag & IGNBRK) {\r\nsport->port.ignore_status_mask |= URXD_BRK;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= URXD_OVRRUN;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nsport->port.ignore_status_mask |= URXD_DUMMY_READ;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nold_ucr1 = readl(sport->port.membase + UCR1);\r\nwritel(old_ucr1 & ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_RTSDEN),\r\nsport->port.membase + UCR1);\r\nwhile (!(readl(sport->port.membase + USR2) & USR2_TXDC))\r\nbarrier();\r\nold_ucr2 = readl(sport->port.membase + UCR2);\r\nwritel(old_ucr2 & ~(UCR2_TXEN | UCR2_RXEN),\r\nsport->port.membase + UCR2);\r\nold_ucr2 &= (UCR2_TXEN | UCR2_RXEN | UCR2_ATEN);\r\ndiv = sport->port.uartclk / (baud * 16);\r\nif (baud == 38400 && quot != div)\r\nbaud = sport->port.uartclk / (quot * 16);\r\ndiv = sport->port.uartclk / (baud * 16);\r\nif (div > 7)\r\ndiv = 7;\r\nif (!div)\r\ndiv = 1;\r\nrational_best_approximation(16 * div * baud, sport->port.uartclk,\r\n1 << 16, 1 << 16, &num, &denom);\r\ntdiv64 = sport->port.uartclk;\r\ntdiv64 *= num;\r\ndo_div(tdiv64, denom * 16 * div);\r\ntty_termios_encode_baud_rate(termios,\r\n(speed_t)tdiv64, (speed_t)tdiv64);\r\nnum -= 1;\r\ndenom -= 1;\r\nufcr = readl(sport->port.membase + UFCR);\r\nufcr = (ufcr & (~UFCR_RFDIV)) | UFCR_RFDIV_REG(div);\r\nif (sport->dte_mode)\r\nufcr |= UFCR_DCEDTE;\r\nwritel(ufcr, sport->port.membase + UFCR);\r\nwritel(num, sport->port.membase + UBIR);\r\nwritel(denom, sport->port.membase + UBMR);\r\nif (!is_imx1_uart(sport))\r\nwritel(sport->port.uartclk / div / 1000,\r\nsport->port.membase + IMX21_ONEMS);\r\nwritel(old_ucr1, sport->port.membase + UCR1);\r\nwritel(ucr2 | old_ucr2, sport->port.membase + UCR2);\r\nif (UART_ENABLE_MS(&sport->port, termios->c_cflag))\r\nimx_enable_ms(&sport->port);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic const char *imx_type(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nreturn sport->port.type == PORT_IMX ? "IMX" : NULL;\r\n}\r\nstatic void imx_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nif (flags & UART_CONFIG_TYPE)\r\nsport->port.type = PORT_IMX;\r\n}\r\nstatic int\r\nimx_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_IMX)\r\nret = -EINVAL;\r\nif (sport->port.irq != ser->irq)\r\nret = -EINVAL;\r\nif (ser->io_type != UPIO_MEM)\r\nret = -EINVAL;\r\nif (sport->port.uartclk / 16 != ser->baud_base)\r\nret = -EINVAL;\r\nif (sport->port.mapbase != (unsigned long)ser->iomem_base)\r\nret = -EINVAL;\r\nif (sport->port.iobase != ser->port)\r\nret = -EINVAL;\r\nif (ser->hub6 != 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int imx_poll_init(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long flags;\r\nunsigned long temp;\r\nint retval;\r\nretval = clk_prepare_enable(sport->clk_ipg);\r\nif (retval)\r\nreturn retval;\r\nretval = clk_prepare_enable(sport->clk_per);\r\nif (retval)\r\nclk_disable_unprepare(sport->clk_ipg);\r\nimx_setup_ufcr(sport, TXTL_DEFAULT, RXTL_DEFAULT);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR1);\r\nif (is_imx1_uart(sport))\r\ntemp |= IMX1_UCR1_UARTCLKEN;\r\ntemp |= UCR1_UARTEN | UCR1_RRDYEN;\r\ntemp &= ~(UCR1_TXMPTYEN | UCR1_RTSDEN);\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp |= UCR2_RXEN;\r\nwritel(temp, sport->port.membase + UCR2);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int imx_poll_get_char(struct uart_port *port)\r\n{\r\nif (!(readl_relaxed(port->membase + USR2) & USR2_RDR))\r\nreturn NO_POLL_CHAR;\r\nreturn readl_relaxed(port->membase + URXD0) & URXD_RX_DATA;\r\n}\r\nstatic void imx_poll_put_char(struct uart_port *port, unsigned char c)\r\n{\r\nunsigned int status;\r\ndo {\r\nstatus = readl_relaxed(port->membase + USR1);\r\n} while (~status & USR1_TRDY);\r\nwritel_relaxed(c, port->membase + URTX0);\r\ndo {\r\nstatus = readl_relaxed(port->membase + USR2);\r\n} while (~status & USR2_TXDC);\r\n}\r\nstatic int imx_rs485_config(struct uart_port *port,\r\nstruct serial_rs485 *rs485conf)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nrs485conf->delay_rts_before_send = 0;\r\nrs485conf->delay_rts_after_send = 0;\r\nif (!sport->have_rtscts)\r\nrs485conf->flags &= ~SER_RS485_ENABLED;\r\nif (rs485conf->flags & SER_RS485_ENABLED) {\r\ntemp = readl(sport->port.membase + UCR2);\r\nif (rs485conf->flags & SER_RS485_RTS_AFTER_SEND)\r\nimx_port_rts_inactive(sport, &temp);\r\nelse\r\nimx_port_rts_active(sport, &temp);\r\nwritel(temp, sport->port.membase + UCR2);\r\n}\r\nif (!(rs485conf->flags & SER_RS485_ENABLED) ||\r\nrs485conf->flags & SER_RS485_RX_DURING_TX) {\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp |= UCR2_RXEN;\r\nwritel(temp, sport->port.membase + UCR2);\r\n}\r\nport->rs485 = *rs485conf;\r\nreturn 0;\r\n}\r\nstatic void imx_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nwhile (readl(sport->port.membase + uts_reg(sport)) & UTS_TXFULL)\r\nbarrier();\r\nwritel(ch, sport->port.membase + URTX0);\r\n}\r\nstatic void\r\nimx_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct imx_port *sport = imx_ports[co->index];\r\nstruct imx_port_ucrs old_ucr;\r\nunsigned int ucr1;\r\nunsigned long flags = 0;\r\nint locked = 1;\r\nint retval;\r\nretval = clk_enable(sport->clk_per);\r\nif (retval)\r\nreturn;\r\nretval = clk_enable(sport->clk_ipg);\r\nif (retval) {\r\nclk_disable(sport->clk_per);\r\nreturn;\r\n}\r\nif (sport->port.sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock_irqsave(&sport->port.lock, flags);\r\nelse\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nimx_port_ucrs_save(&sport->port, &old_ucr);\r\nucr1 = old_ucr.ucr1;\r\nif (is_imx1_uart(sport))\r\nucr1 |= IMX1_UCR1_UARTCLKEN;\r\nucr1 |= UCR1_UARTEN;\r\nucr1 &= ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_RTSDEN);\r\nwritel(ucr1, sport->port.membase + UCR1);\r\nwritel(old_ucr.ucr2 | UCR2_TXEN, sport->port.membase + UCR2);\r\nuart_console_write(&sport->port, s, count, imx_console_putchar);\r\nwhile (!(readl(sport->port.membase + USR2) & USR2_TXDC));\r\nimx_port_ucrs_restore(&sport->port, &old_ucr);\r\nif (locked)\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nclk_disable(sport->clk_ipg);\r\nclk_disable(sport->clk_per);\r\n}\r\nstatic void __init\r\nimx_console_get_options(struct imx_port *sport, int *baud,\r\nint *parity, int *bits)\r\n{\r\nif (readl(sport->port.membase + UCR1) & UCR1_UARTEN) {\r\nunsigned int ucr2, ubir, ubmr, uartclk;\r\nunsigned int baud_raw;\r\nunsigned int ucfr_rfdiv;\r\nucr2 = readl(sport->port.membase + UCR2);\r\n*parity = 'n';\r\nif (ucr2 & UCR2_PREN) {\r\nif (ucr2 & UCR2_PROE)\r\n*parity = 'o';\r\nelse\r\n*parity = 'e';\r\n}\r\nif (ucr2 & UCR2_WS)\r\n*bits = 8;\r\nelse\r\n*bits = 7;\r\nubir = readl(sport->port.membase + UBIR) & 0xffff;\r\nubmr = readl(sport->port.membase + UBMR) & 0xffff;\r\nucfr_rfdiv = (readl(sport->port.membase + UFCR) & UFCR_RFDIV) >> 7;\r\nif (ucfr_rfdiv == 6)\r\nucfr_rfdiv = 7;\r\nelse\r\nucfr_rfdiv = 6 - ucfr_rfdiv;\r\nuartclk = clk_get_rate(sport->clk_per);\r\nuartclk /= ucfr_rfdiv;\r\n{\r\nunsigned int mul = ubir + 1;\r\nunsigned int div = 16 * (ubmr + 1);\r\nunsigned int rem = uartclk % div;\r\nbaud_raw = (uartclk / div) * mul;\r\nbaud_raw += (rem * mul + div / 2) / div;\r\n*baud = (baud_raw + 50) / 100 * 100;\r\n}\r\nif (*baud != baud_raw)\r\npr_info("Console IMX rounded baud rate from %d to %d\n",\r\nbaud_raw, *baud);\r\n}\r\n}\r\nstatic int __init\r\nimx_console_setup(struct console *co, char *options)\r\n{\r\nstruct imx_port *sport;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint retval;\r\nif (co->index == -1 || co->index >= ARRAY_SIZE(imx_ports))\r\nco->index = 0;\r\nsport = imx_ports[co->index];\r\nif (sport == NULL)\r\nreturn -ENODEV;\r\nretval = clk_prepare_enable(sport->clk_ipg);\r\nif (retval)\r\ngoto error_console;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nimx_console_get_options(sport, &baud, &parity, &bits);\r\nimx_setup_ufcr(sport, TXTL_DEFAULT, RXTL_DEFAULT);\r\nretval = uart_set_options(&sport->port, co, baud, parity, bits, flow);\r\nclk_disable(sport->clk_ipg);\r\nif (retval) {\r\nclk_unprepare(sport->clk_ipg);\r\ngoto error_console;\r\n}\r\nretval = clk_prepare(sport->clk_per);\r\nif (retval)\r\nclk_disable_unprepare(sport->clk_ipg);\r\nerror_console:\r\nreturn retval;\r\n}\r\nstatic void imx_console_early_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (readl_relaxed(port->membase + IMX21_UTS) & UTS_TXFULL)\r\ncpu_relax();\r\nwritel_relaxed(ch, port->membase + URTX0);\r\n}\r\nstatic void imx_console_early_write(struct console *con, const char *s,\r\nunsigned count)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\nuart_console_write(&dev->port, s, count, imx_console_early_putchar);\r\n}\r\nstatic int __init\r\nimx_console_early_setup(struct earlycon_device *dev, const char *opt)\r\n{\r\nif (!dev->port.membase)\r\nreturn -ENODEV;\r\ndev->con->write = imx_console_early_write;\r\nreturn 0;\r\n}\r\nstatic int serial_imx_probe_dt(struct imx_port *sport,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nsport->devdata = of_device_get_match_data(&pdev->dev);\r\nif (!sport->devdata)\r\nreturn 1;\r\nret = of_alias_get_id(np, "serial");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id, errno %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->port.line = ret;\r\nif (of_get_property(np, "uart-has-rtscts", NULL) ||\r\nof_get_property(np, "fsl,uart-has-rtscts", NULL) )\r\nsport->have_rtscts = 1;\r\nif (of_get_property(np, "fsl,dte-mode", NULL))\r\nsport->dte_mode = 1;\r\nreturn 0;\r\n}\r\nstatic inline int serial_imx_probe_dt(struct imx_port *sport,\r\nstruct platform_device *pdev)\r\n{\r\nreturn 1;\r\n}\r\nstatic void serial_imx_probe_pdata(struct imx_port *sport,\r\nstruct platform_device *pdev)\r\n{\r\nstruct imxuart_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nsport->port.line = pdev->id;\r\nsport->devdata = (struct imx_uart_data *) pdev->id_entry->driver_data;\r\nif (!pdata)\r\nreturn;\r\nif (pdata->flags & IMXUART_HAVE_RTSCTS)\r\nsport->have_rtscts = 1;\r\n}\r\nstatic int serial_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct imx_port *sport;\r\nvoid __iomem *base;\r\nint ret = 0, reg;\r\nstruct resource *res;\r\nint txirq, rxirq, rtsirq;\r\nsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\r\nif (!sport)\r\nreturn -ENOMEM;\r\nret = serial_imx_probe_dt(sport, pdev);\r\nif (ret > 0)\r\nserial_imx_probe_pdata(sport, pdev);\r\nelse if (ret < 0)\r\nreturn ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nrxirq = platform_get_irq(pdev, 0);\r\ntxirq = platform_get_irq(pdev, 1);\r\nrtsirq = platform_get_irq(pdev, 2);\r\nsport->port.dev = &pdev->dev;\r\nsport->port.mapbase = res->start;\r\nsport->port.membase = base;\r\nsport->port.type = PORT_IMX,\r\nsport->port.iotype = UPIO_MEM;\r\nsport->port.irq = rxirq;\r\nsport->port.fifosize = 32;\r\nsport->port.ops = &imx_pops;\r\nsport->port.rs485_config = imx_rs485_config;\r\nsport->port.rs485.flags =\r\nSER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX;\r\nsport->port.flags = UPF_BOOT_AUTOCONF;\r\ninit_timer(&sport->timer);\r\nsport->timer.function = imx_timeout;\r\nsport->timer.data = (unsigned long)sport;\r\nsport->gpios = mctrl_gpio_init(&sport->port, 0);\r\nif (IS_ERR(sport->gpios))\r\nreturn PTR_ERR(sport->gpios);\r\nsport->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(sport->clk_ipg)) {\r\nret = PTR_ERR(sport->clk_ipg);\r\ndev_err(&pdev->dev, "failed to get ipg clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(sport->clk_per)) {\r\nret = PTR_ERR(sport->clk_per);\r\ndev_err(&pdev->dev, "failed to get per clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->port.uartclk = clk_get_rate(sport->clk_per);\r\nret = clk_prepare_enable(sport->clk_ipg);\r\nif (ret)\r\nreturn ret;\r\nreg = readl_relaxed(sport->port.membase + UCR1);\r\nreg &= ~(UCR1_ADEN | UCR1_TRDYEN | UCR1_IDEN | UCR1_RRDYEN |\r\nUCR1_TXMPTYEN | UCR1_RTSDEN);\r\nwritel_relaxed(reg, sport->port.membase + UCR1);\r\nclk_disable_unprepare(sport->clk_ipg);\r\nif (txirq > 0) {\r\nret = devm_request_irq(&pdev->dev, rxirq, imx_rxint, 0,\r\ndev_name(&pdev->dev), sport);\r\nif (ret)\r\nreturn ret;\r\nret = devm_request_irq(&pdev->dev, txirq, imx_txint, 0,\r\ndev_name(&pdev->dev), sport);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = devm_request_irq(&pdev->dev, rxirq, imx_int, 0,\r\ndev_name(&pdev->dev), sport);\r\nif (ret)\r\nreturn ret;\r\n}\r\nimx_ports[sport->port.line] = sport;\r\nplatform_set_drvdata(pdev, sport);\r\nreturn uart_add_one_port(&imx_reg, &sport->port);\r\n}\r\nstatic int serial_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_port *sport = platform_get_drvdata(pdev);\r\nreturn uart_remove_one_port(&imx_reg, &sport->port);\r\n}\r\nstatic void serial_imx_restore_context(struct imx_port *sport)\r\n{\r\nif (!sport->context_saved)\r\nreturn;\r\nwritel(sport->saved_reg[4], sport->port.membase + UFCR);\r\nwritel(sport->saved_reg[5], sport->port.membase + UESC);\r\nwritel(sport->saved_reg[6], sport->port.membase + UTIM);\r\nwritel(sport->saved_reg[7], sport->port.membase + UBIR);\r\nwritel(sport->saved_reg[8], sport->port.membase + UBMR);\r\nwritel(sport->saved_reg[9], sport->port.membase + IMX21_UTS);\r\nwritel(sport->saved_reg[0], sport->port.membase + UCR1);\r\nwritel(sport->saved_reg[1] | UCR2_SRST, sport->port.membase + UCR2);\r\nwritel(sport->saved_reg[2], sport->port.membase + UCR3);\r\nwritel(sport->saved_reg[3], sport->port.membase + UCR4);\r\nsport->context_saved = false;\r\n}\r\nstatic void serial_imx_save_context(struct imx_port *sport)\r\n{\r\nsport->saved_reg[0] = readl(sport->port.membase + UCR1);\r\nsport->saved_reg[1] = readl(sport->port.membase + UCR2);\r\nsport->saved_reg[2] = readl(sport->port.membase + UCR3);\r\nsport->saved_reg[3] = readl(sport->port.membase + UCR4);\r\nsport->saved_reg[4] = readl(sport->port.membase + UFCR);\r\nsport->saved_reg[5] = readl(sport->port.membase + UESC);\r\nsport->saved_reg[6] = readl(sport->port.membase + UTIM);\r\nsport->saved_reg[7] = readl(sport->port.membase + UBIR);\r\nsport->saved_reg[8] = readl(sport->port.membase + UBMR);\r\nsport->saved_reg[9] = readl(sport->port.membase + IMX21_UTS);\r\nsport->context_saved = true;\r\n}\r\nstatic void serial_imx_enable_wakeup(struct imx_port *sport, bool on)\r\n{\r\nunsigned int val;\r\nval = readl(sport->port.membase + UCR3);\r\nif (on)\r\nval |= UCR3_AWAKEN;\r\nelse\r\nval &= ~UCR3_AWAKEN;\r\nwritel(val, sport->port.membase + UCR3);\r\nval = readl(sport->port.membase + UCR1);\r\nif (on)\r\nval |= UCR1_RTSDEN;\r\nelse\r\nval &= ~UCR1_RTSDEN;\r\nwritel(val, sport->port.membase + UCR1);\r\n}\r\nstatic int imx_serial_port_suspend_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct imx_port *sport = platform_get_drvdata(pdev);\r\nint ret;\r\nret = clk_enable(sport->clk_ipg);\r\nif (ret)\r\nreturn ret;\r\nserial_imx_save_context(sport);\r\nclk_disable(sport->clk_ipg);\r\nreturn 0;\r\n}\r\nstatic int imx_serial_port_resume_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct imx_port *sport = platform_get_drvdata(pdev);\r\nint ret;\r\nret = clk_enable(sport->clk_ipg);\r\nif (ret)\r\nreturn ret;\r\nserial_imx_restore_context(sport);\r\nclk_disable(sport->clk_ipg);\r\nreturn 0;\r\n}\r\nstatic int imx_serial_port_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct imx_port *sport = platform_get_drvdata(pdev);\r\nserial_imx_enable_wakeup(sport, true);\r\nuart_suspend_port(&imx_reg, &sport->port);\r\nreturn clk_prepare(sport->clk_ipg);\r\n}\r\nstatic int imx_serial_port_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct imx_port *sport = platform_get_drvdata(pdev);\r\nserial_imx_enable_wakeup(sport, false);\r\nuart_resume_port(&imx_reg, &sport->port);\r\nclk_unprepare(sport->clk_ipg);\r\nreturn 0;\r\n}\r\nstatic int __init imx_serial_init(void)\r\n{\r\nint ret = uart_register_driver(&imx_reg);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&serial_imx_driver);\r\nif (ret != 0)\r\nuart_unregister_driver(&imx_reg);\r\nreturn ret;\r\n}\r\nstatic void __exit imx_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&serial_imx_driver);\r\nuart_unregister_driver(&imx_reg);\r\n}
