static int fuel_gauge_reg_readb(struct axp288_fg_info *info, int reg)\r\n{\r\nint ret, i;\r\nunsigned int val;\r\nfor (i = 0; i < NR_RETRY_CNT; i++) {\r\nret = regmap_read(info->regmap, reg, &val);\r\nif (ret == -EBUSY)\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "axp288 reg read err:%d\n", ret);\r\nreturn val;\r\n}\r\nstatic int fuel_gauge_reg_writeb(struct axp288_fg_info *info, int reg, u8 val)\r\n{\r\nint ret;\r\nret = regmap_write(info->regmap, reg, (unsigned int)val);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "axp288 reg write err:%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int pmic_read_adc_val(const char *name, int *raw_val,\r\nstruct axp288_fg_info *info)\r\n{\r\nint ret, val = 0;\r\nstruct iio_channel *indio_chan;\r\nindio_chan = iio_channel_get(NULL, name);\r\nif (IS_ERR_OR_NULL(indio_chan)) {\r\nret = PTR_ERR(indio_chan);\r\ngoto exit;\r\n}\r\nret = iio_read_channel_raw(indio_chan, &val);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev,\r\n"IIO channel read error: %x, %x\n", ret, val);\r\ngoto err_exit;\r\n}\r\ndev_dbg(&info->pdev->dev, "adc raw val=%x\n", val);\r\n*raw_val = val;\r\nerr_exit:\r\niio_channel_release(indio_chan);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_debug_show(struct seq_file *s, void *data)\r\n{\r\nstruct axp288_fg_info *info = s->private;\r\nint raw_val, ret;\r\nseq_printf(s, " PWR_STATUS[%02x] : %02x\n",\r\nAXP20X_PWR_INPUT_STATUS,\r\nfuel_gauge_reg_readb(info, AXP20X_PWR_INPUT_STATUS));\r\nseq_printf(s, "PWR_OP_MODE[%02x] : %02x\n",\r\nAXP20X_PWR_OP_MODE,\r\nfuel_gauge_reg_readb(info, AXP20X_PWR_OP_MODE));\r\nseq_printf(s, " CHRG_CTRL1[%02x] : %02x\n",\r\nAXP20X_CHRG_CTRL1,\r\nfuel_gauge_reg_readb(info, AXP20X_CHRG_CTRL1));\r\nseq_printf(s, " VLTF[%02x] : %02x\n",\r\nAXP20X_V_LTF_DISCHRG,\r\nfuel_gauge_reg_readb(info, AXP20X_V_LTF_DISCHRG));\r\nseq_printf(s, " VHTF[%02x] : %02x\n",\r\nAXP20X_V_HTF_DISCHRG,\r\nfuel_gauge_reg_readb(info, AXP20X_V_HTF_DISCHRG));\r\nseq_printf(s, " CC_CTRL[%02x] : %02x\n",\r\nAXP20X_CC_CTRL,\r\nfuel_gauge_reg_readb(info, AXP20X_CC_CTRL));\r\nseq_printf(s, "BATTERY CAP[%02x] : %02x\n",\r\nAXP20X_FG_RES,\r\nfuel_gauge_reg_readb(info, AXP20X_FG_RES));\r\nseq_printf(s, " FG_RDC1[%02x] : %02x\n",\r\nAXP288_FG_RDC1_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_RDC1_REG));\r\nseq_printf(s, " FG_RDC0[%02x] : %02x\n",\r\nAXP288_FG_RDC0_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_RDC0_REG));\r\nseq_printf(s, " FG_OCVH[%02x] : %02x\n",\r\nAXP288_FG_OCVH_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_OCVH_REG));\r\nseq_printf(s, " FG_OCVL[%02x] : %02x\n",\r\nAXP288_FG_OCVL_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_OCVL_REG));\r\nseq_printf(s, "FG_DES_CAP1[%02x] : %02x\n",\r\nAXP288_FG_DES_CAP1_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_DES_CAP1_REG));\r\nseq_printf(s, "FG_DES_CAP0[%02x] : %02x\n",\r\nAXP288_FG_DES_CAP0_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_DES_CAP0_REG));\r\nseq_printf(s, " FG_CC_MTR1[%02x] : %02x\n",\r\nAXP288_FG_CC_MTR1_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_CC_MTR1_REG));\r\nseq_printf(s, " FG_CC_MTR0[%02x] : %02x\n",\r\nAXP288_FG_CC_MTR0_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_CC_MTR0_REG));\r\nseq_printf(s, " FG_OCV_CAP[%02x] : %02x\n",\r\nAXP288_FG_OCV_CAP_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_OCV_CAP_REG));\r\nseq_printf(s, " FG_CC_CAP[%02x] : %02x\n",\r\nAXP288_FG_CC_CAP_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_CC_CAP_REG));\r\nseq_printf(s, " FG_LOW_CAP[%02x] : %02x\n",\r\nAXP288_FG_LOW_CAP_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_LOW_CAP_REG));\r\nseq_printf(s, "TUNING_CTL0[%02x] : %02x\n",\r\nAXP288_FG_TUNE0,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE0));\r\nseq_printf(s, "TUNING_CTL1[%02x] : %02x\n",\r\nAXP288_FG_TUNE1,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE1));\r\nseq_printf(s, "TUNING_CTL2[%02x] : %02x\n",\r\nAXP288_FG_TUNE2,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE2));\r\nseq_printf(s, "TUNING_CTL3[%02x] : %02x\n",\r\nAXP288_FG_TUNE3,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE3));\r\nseq_printf(s, "TUNING_CTL4[%02x] : %02x\n",\r\nAXP288_FG_TUNE4,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE4));\r\nseq_printf(s, "TUNING_CTL5[%02x] : %02x\n",\r\nAXP288_FG_TUNE5,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE5));\r\nret = pmic_read_adc_val("axp288-batt-temp", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-batttemp : %d\n", raw_val);\r\nret = pmic_read_adc_val("axp288-pmic-temp", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-pmictemp : %d\n", raw_val);\r\nret = pmic_read_adc_val("axp288-system-temp", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-systtemp : %d\n", raw_val);\r\nret = pmic_read_adc_val("axp288-chrg-curr", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-chrgcurr : %d\n", raw_val);\r\nret = pmic_read_adc_val("axp288-chrg-d-curr", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-dchrgcur : %d\n", raw_val);\r\nret = pmic_read_adc_val("axp288-batt-volt", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-battvolt : %d\n", raw_val);\r\nreturn 0;\r\n}\r\nstatic int debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fuel_gauge_debug_show, inode->i_private);\r\n}\r\nstatic void fuel_gauge_create_debugfs(struct axp288_fg_info *info)\r\n{\r\ninfo->debug_file = debugfs_create_file("fuelgauge", 0666, NULL,\r\ninfo, &fg_debug_fops);\r\n}\r\nstatic void fuel_gauge_remove_debugfs(struct axp288_fg_info *info)\r\n{\r\ndebugfs_remove(info->debug_file);\r\n}\r\nstatic inline void fuel_gauge_create_debugfs(struct axp288_fg_info *info)\r\n{\r\n}\r\nstatic inline void fuel_gauge_remove_debugfs(struct axp288_fg_info *info)\r\n{\r\n}\r\nstatic void fuel_gauge_get_status(struct axp288_fg_info *info)\r\n{\r\nint pwr_stat, ret;\r\nint charge, discharge;\r\npwr_stat = fuel_gauge_reg_readb(info, AXP20X_PWR_INPUT_STATUS);\r\nif (pwr_stat < 0) {\r\ndev_err(&info->pdev->dev,\r\n"PWR STAT read failed:%d\n", pwr_stat);\r\nreturn;\r\n}\r\nret = pmic_read_adc_val("axp288-chrg-curr", &charge, info);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev,\r\n"ADC charge current read failed:%d\n", ret);\r\nreturn;\r\n}\r\nret = pmic_read_adc_val("axp288-chrg-d-curr", &discharge, info);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev,\r\n"ADC discharge current read failed:%d\n", ret);\r\nreturn;\r\n}\r\nif (charge > 0)\r\ninfo->status = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (discharge > 0)\r\ninfo->status = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse {\r\nif (pwr_stat & CHRG_STAT_BAT_PRESENT)\r\ninfo->status = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\ninfo->status = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\n}\r\n}\r\nstatic int fuel_gauge_get_vbatt(struct axp288_fg_info *info, int *vbatt)\r\n{\r\nint ret = 0, raw_val;\r\nret = pmic_read_adc_val("axp288-batt-volt", &raw_val, info);\r\nif (ret < 0)\r\ngoto vbatt_read_fail;\r\n*vbatt = VOLTAGE_FROM_ADC(raw_val);\r\nvbatt_read_fail:\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_get_current(struct axp288_fg_info *info, int *cur)\r\n{\r\nint ret, value = 0;\r\nint charge, discharge;\r\nret = pmic_read_adc_val("axp288-chrg-curr", &charge, info);\r\nif (ret < 0)\r\ngoto current_read_fail;\r\nret = pmic_read_adc_val("axp288-chrg-d-curr", &discharge, info);\r\nif (ret < 0)\r\ngoto current_read_fail;\r\nif (charge > 0)\r\nvalue = charge;\r\nelse if (discharge > 0)\r\nvalue = -1 * discharge;\r\n*cur = value;\r\ncurrent_read_fail:\r\nreturn ret;\r\n}\r\nstatic int temp_to_adc(struct axp288_fg_info *info, int tval)\r\n{\r\nint rntc = 0, i, ret, adc_val;\r\nint rmin, rmax, tmin, tmax;\r\nint tcsz = info->pdata->tcsz;\r\nif (tval > info->pdata->thermistor_curve[0][1]) {\r\nrntc = info->pdata->thermistor_curve[0][0];\r\n} else if (tval <= info->pdata->thermistor_curve[tcsz-1][1]) {\r\nrntc = info->pdata->thermistor_curve[tcsz-1][0];\r\n} else {\r\nfor (i = 1; i < tcsz; i++) {\r\nif (tval > info->pdata->thermistor_curve[i][1]) {\r\nrmin = info->pdata->thermistor_curve[i-1][0];\r\nrmax = info->pdata->thermistor_curve[i][0];\r\ntmin = info->pdata->thermistor_curve[i-1][1];\r\ntmax = info->pdata->thermistor_curve[i][1];\r\nrntc = rmin + ((rmax - rmin) *\r\n(tval - tmin) / (tmax - tmin));\r\nbreak;\r\n}\r\n}\r\n}\r\nret = fuel_gauge_reg_readb(info, AXP20X_ADC_RATE);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "%s:read err:%d\n", __func__, ret);\r\nret = 0x30;\r\n}\r\nadc_val = rntc * (20 + (20 * ((ret >> 4) & 0x3))) / 800;\r\nreturn adc_val;\r\n}\r\nstatic int adc_to_temp(struct axp288_fg_info *info, int adc_val)\r\n{\r\nint ret, r, i, tval = 0;\r\nint rmin, rmax, tmin, tmax;\r\nint tcsz = info->pdata->tcsz;\r\nret = fuel_gauge_reg_readb(info, AXP20X_ADC_RATE);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "%s:read err:%d\n", __func__, ret);\r\nret = 0x30;\r\n}\r\nr = adc_val * 800 / (20 + (20 * ((ret >> 4) & 0x3)));\r\nif (r < info->pdata->thermistor_curve[0][0]) {\r\ntval = info->pdata->thermistor_curve[0][1];\r\n} else if (r >= info->pdata->thermistor_curve[tcsz-1][0]) {\r\ntval = info->pdata->thermistor_curve[tcsz-1][1];\r\n} else {\r\nfor (i = 1; i < tcsz; i++) {\r\nif (r < info->pdata->thermistor_curve[i][0]) {\r\nrmin = info->pdata->thermistor_curve[i-1][0];\r\nrmax = info->pdata->thermistor_curve[i][0];\r\ntmin = info->pdata->thermistor_curve[i-1][1];\r\ntmax = info->pdata->thermistor_curve[i][1];\r\ntval = tmin + ((tmax - tmin) *\r\n(r - rmin) / (rmax - rmin));\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn tval;\r\n}\r\nstatic int fuel_gauge_get_btemp(struct axp288_fg_info *info, int *btemp)\r\n{\r\nint ret, raw_val = 0;\r\nret = pmic_read_adc_val("axp288-batt-temp", &raw_val, info);\r\nif (ret < 0)\r\ngoto temp_read_fail;\r\n*btemp = adc_to_temp(info, raw_val);\r\ntemp_read_fail:\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_get_vocv(struct axp288_fg_info *info, int *vocv)\r\n{\r\nint ret, value;\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_OCVH_REG);\r\nif (ret < 0)\r\ngoto vocv_read_fail;\r\nvalue = ret << 4;\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_OCVL_REG);\r\nif (ret < 0)\r\ngoto vocv_read_fail;\r\nvalue |= (ret & 0xf);\r\n*vocv = VOLTAGE_FROM_ADC(value);\r\nvocv_read_fail:\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_battery_health(struct axp288_fg_info *info)\r\n{\r\nint temp, vocv;\r\nint ret, health = POWER_SUPPLY_HEALTH_UNKNOWN;\r\nret = fuel_gauge_get_btemp(info, &temp);\r\nif (ret < 0)\r\ngoto health_read_fail;\r\nret = fuel_gauge_get_vocv(info, &vocv);\r\nif (ret < 0)\r\ngoto health_read_fail;\r\nif (vocv > info->pdata->max_volt)\r\nhealth = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\r\nelse if (temp > info->pdata->max_temp)\r\nhealth = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse if (temp < info->pdata->min_temp)\r\nhealth = POWER_SUPPLY_HEALTH_COLD;\r\nelse if (vocv < info->pdata->min_volt)\r\nhealth = POWER_SUPPLY_HEALTH_DEAD;\r\nelse\r\nhealth = POWER_SUPPLY_HEALTH_GOOD;\r\nhealth_read_fail:\r\nreturn health;\r\n}\r\nstatic int fuel_gauge_set_high_btemp_alert(struct axp288_fg_info *info)\r\n{\r\nint ret, adc_val;\r\nadc_val = temp_to_adc(info, info->pdata->max_temp);\r\nret = fuel_gauge_reg_writeb(info, AXP20X_V_HTF_DISCHRG, adc_val >> 4);\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_set_low_btemp_alert(struct axp288_fg_info *info)\r\n{\r\nint ret, adc_val;\r\nadc_val = temp_to_adc(info, info->pdata->min_temp);\r\nret = fuel_gauge_reg_writeb(info, AXP20X_V_LTF_DISCHRG, adc_val >> 4);\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_get_property(struct power_supply *ps,\r\nenum power_supply_property prop,\r\nunion power_supply_propval *val)\r\n{\r\nstruct axp288_fg_info *info = power_supply_get_drvdata(ps);\r\nint ret = 0, value;\r\nmutex_lock(&info->lock);\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nfuel_gauge_get_status(info);\r\nval->intval = info->status;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nval->intval = fuel_gauge_battery_health(info);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = fuel_gauge_get_vbatt(info, &value);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = PROP_VOLT(value);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_OCV:\r\nret = fuel_gauge_get_vocv(info, &value);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = PROP_VOLT(value);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nret = fuel_gauge_get_current(info, &value);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = PROP_CURR(value);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nret = fuel_gauge_reg_readb(info, AXP20X_PWR_OP_MODE);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nif (ret & CHRG_STAT_BAT_PRESENT)\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = fuel_gauge_reg_readb(info, AXP20X_FG_RES);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nif (!(ret & FG_REP_CAP_VALID))\r\ndev_err(&info->pdev->dev,\r\n"capacity measurement not valid\n");\r\nval->intval = (ret & FG_REP_CAP_VAL_MASK);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_LOW_CAP_REG);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = (ret & 0x0f);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nret = fuel_gauge_get_btemp(info, &value);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = PROP_TEMP(value);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP_MAX:\r\ncase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\r\nval->intval = PROP_TEMP(info->pdata->max_temp);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP_MIN:\r\ncase POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\r\nval->intval = PROP_TEMP(info->pdata->min_temp);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_CC_MTR1_REG);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nvalue = (ret & FG_CC_MTR1_VAL_MASK) << 8;\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_CC_MTR0_REG);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nvalue |= (ret & FG_CC_MTR0_VAL_MASK);\r\nval->intval = value * FG_DES_CAP_RES_LSB;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_DES_CAP1_REG);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nvalue = (ret & FG_DES_CAP1_VAL_MASK) << 8;\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_DES_CAP0_REG);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nvalue |= (ret & FG_DES_CAP0_VAL_MASK);\r\nval->intval = value * FG_DES_CAP_RES_LSB;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval = PROP_CURR(info->pdata->design_cap);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nval->intval = PROP_VOLT(info->pdata->max_volt);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nval->intval = PROP_VOLT(info->pdata->min_volt);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = info->pdata->battid;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&info->lock);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn 0;\r\nfuel_gauge_read_err:\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_set_property(struct power_supply *ps,\r\nenum power_supply_property prop,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct axp288_fg_info *info = power_supply_get_drvdata(ps);\r\nint ret = 0;\r\nmutex_lock(&info->lock);\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\ninfo->status = val->intval;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP_MIN:\r\ncase POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\r\nif ((val->intval < PD_DEF_MIN_TEMP) ||\r\n(val->intval > PD_DEF_MAX_TEMP)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ninfo->pdata->min_temp = UNPROP_TEMP(val->intval);\r\nret = fuel_gauge_set_low_btemp_alert(info);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev,\r\n"temp alert min set fail:%d\n", ret);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP_MAX:\r\ncase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\r\nif ((val->intval < PD_DEF_MIN_TEMP) ||\r\n(val->intval > PD_DEF_MAX_TEMP)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ninfo->pdata->max_temp = UNPROP_TEMP(val->intval);\r\nret = fuel_gauge_set_high_btemp_alert(info);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev,\r\n"temp alert max set fail:%d\n", ret);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\r\nif ((val->intval < 0) || (val->intval > 15)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_LOW_CAP_REG);\r\nif (ret < 0)\r\nbreak;\r\nret &= 0xf0;\r\nret |= (val->intval & 0xf);\r\nret = fuel_gauge_reg_writeb(info, AXP288_FG_LOW_CAP_REG, ret);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_property_is_writeable(struct power_supply *psy,\r\nenum power_supply_property psp)\r\n{\r\nint ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\ncase POWER_SUPPLY_PROP_TEMP_MIN:\r\ncase POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\r\ncase POWER_SUPPLY_PROP_TEMP_MAX:\r\ncase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\r\ncase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\r\nret = 1;\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fuel_gauge_status_monitor(struct work_struct *work)\r\n{\r\nstruct axp288_fg_info *info = container_of(work,\r\nstruct axp288_fg_info, status_monitor.work);\r\nfuel_gauge_get_status(info);\r\npower_supply_changed(info->bat);\r\nschedule_delayed_work(&info->status_monitor, STATUS_MON_DELAY_JIFFIES);\r\n}\r\nstatic irqreturn_t fuel_gauge_thread_handler(int irq, void *dev)\r\n{\r\nstruct axp288_fg_info *info = dev;\r\nint i;\r\nfor (i = 0; i < AXP288_FG_INTR_NUM; i++) {\r\nif (info->irq[i] == irq)\r\nbreak;\r\n}\r\nif (i >= AXP288_FG_INTR_NUM) {\r\ndev_warn(&info->pdev->dev, "spurious interrupt!!\n");\r\nreturn IRQ_NONE;\r\n}\r\nswitch (i) {\r\ncase QWBTU_IRQ:\r\ndev_info(&info->pdev->dev,\r\n"Quit Battery under temperature in work mode IRQ (QWBTU)\n");\r\nbreak;\r\ncase WBTU_IRQ:\r\ndev_info(&info->pdev->dev,\r\n"Battery under temperature in work mode IRQ (WBTU)\n");\r\nbreak;\r\ncase QWBTO_IRQ:\r\ndev_info(&info->pdev->dev,\r\n"Quit Battery over temperature in work mode IRQ (QWBTO)\n");\r\nbreak;\r\ncase WBTO_IRQ:\r\ndev_info(&info->pdev->dev,\r\n"Battery over temperature in work mode IRQ (WBTO)\n");\r\nbreak;\r\ncase WL2_IRQ:\r\ndev_info(&info->pdev->dev, "Low Batt Warning(2) INTR\n");\r\nbreak;\r\ncase WL1_IRQ:\r\ndev_info(&info->pdev->dev, "Low Batt Warning(1) INTR\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&info->pdev->dev, "Spurious Interrupt!!!\n");\r\n}\r\npower_supply_changed(info->bat);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fuel_gauge_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct axp288_fg_info *info = power_supply_get_drvdata(psy);\r\npower_supply_changed(info->bat);\r\n}\r\nstatic int fuel_gauge_set_lowbatt_thresholds(struct axp288_fg_info *info)\r\n{\r\nint ret;\r\nu8 reg_val;\r\nret = fuel_gauge_reg_readb(info, AXP20X_FG_RES);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "%s:read err:%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nret = (ret & FG_REP_CAP_VAL_MASK);\r\nif (ret > FG_LOW_CAP_WARN_THR)\r\nreg_val = FG_LOW_CAP_WARN_THR;\r\nelse if (ret > FG_LOW_CAP_CRIT_THR)\r\nreg_val = FG_LOW_CAP_CRIT_THR;\r\nelse\r\nreg_val = FG_LOW_CAP_SHDN_THR;\r\nreg_val |= FG_LOW_CAP_THR1_VAL;\r\nret = fuel_gauge_reg_writeb(info, AXP288_FG_LOW_CAP_REG, reg_val);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "%s:write err:%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_program_vbatt_full(struct axp288_fg_info *info)\r\n{\r\nint ret;\r\nu8 val;\r\nret = fuel_gauge_reg_readb(info, AXP20X_CHRG_CTRL1);\r\nif (ret < 0)\r\ngoto fg_prog_ocv_fail;\r\nelse\r\nval = (ret & ~CHRG_CCCV_CV_MASK);\r\nswitch (info->pdata->max_volt) {\r\ncase CV_4100:\r\nval |= (CHRG_CCCV_CV_4100MV << CHRG_CCCV_CV_BIT_POS);\r\nbreak;\r\ncase CV_4150:\r\nval |= (CHRG_CCCV_CV_4150MV << CHRG_CCCV_CV_BIT_POS);\r\nbreak;\r\ncase CV_4200:\r\nval |= (CHRG_CCCV_CV_4200MV << CHRG_CCCV_CV_BIT_POS);\r\nbreak;\r\ncase CV_4350:\r\nval |= (CHRG_CCCV_CV_4350MV << CHRG_CCCV_CV_BIT_POS);\r\nbreak;\r\ndefault:\r\nval |= (CHRG_CCCV_CV_4200MV << CHRG_CCCV_CV_BIT_POS);\r\nbreak;\r\n}\r\nret = fuel_gauge_reg_writeb(info, AXP20X_CHRG_CTRL1, val);\r\nfg_prog_ocv_fail:\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_program_design_cap(struct axp288_fg_info *info)\r\n{\r\nint ret;\r\nret = fuel_gauge_reg_writeb(info,\r\nAXP288_FG_DES_CAP1_REG, info->pdata->cap1);\r\nif (ret < 0)\r\ngoto fg_prog_descap_fail;\r\nret = fuel_gauge_reg_writeb(info,\r\nAXP288_FG_DES_CAP0_REG, info->pdata->cap0);\r\nfg_prog_descap_fail:\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_program_ocv_curve(struct axp288_fg_info *info)\r\n{\r\nint ret = 0, i;\r\nfor (i = 0; i < OCV_CURVE_SIZE; i++) {\r\nret = fuel_gauge_reg_writeb(info,\r\nAXP288_FG_OCV_CURVE_REG + i, info->pdata->ocv_curve[i]);\r\nif (ret < 0)\r\ngoto fg_prog_ocv_fail;\r\n}\r\nfg_prog_ocv_fail:\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_program_rdc_vals(struct axp288_fg_info *info)\r\n{\r\nint ret;\r\nret = fuel_gauge_reg_writeb(info,\r\nAXP288_FG_RDC1_REG, info->pdata->rdc1);\r\nif (ret < 0)\r\ngoto fg_prog_ocv_fail;\r\nret = fuel_gauge_reg_writeb(info,\r\nAXP288_FG_RDC0_REG, info->pdata->rdc0);\r\nfg_prog_ocv_fail:\r\nreturn ret;\r\n}\r\nstatic void fuel_gauge_init_config_regs(struct axp288_fg_info *info)\r\n{\r\nint ret;\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_DES_CAP1_REG);\r\nif (ret < 0) {\r\ndev_warn(&info->pdev->dev, "CAP1 reg read err!!\n");\r\n} else if (!(ret & FG_DES_CAP1_VALID)) {\r\ndev_info(&info->pdev->dev, "FG data needs to be initialized\n");\r\n} else {\r\ndev_info(&info->pdev->dev, "FG data is already initialized\n");\r\nreturn;\r\n}\r\nret = fuel_gauge_program_vbatt_full(info);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "set vbatt full fail:%d\n", ret);\r\nret = fuel_gauge_program_design_cap(info);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "set design cap fail:%d\n", ret);\r\nret = fuel_gauge_program_rdc_vals(info);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "set rdc fail:%d\n", ret);\r\nret = fuel_gauge_program_ocv_curve(info);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "set ocv curve fail:%d\n", ret);\r\nret = fuel_gauge_set_lowbatt_thresholds(info);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "lowbatt thr set fail:%d\n", ret);\r\nret = fuel_gauge_reg_writeb(info, AXP20X_CC_CTRL, 0xef);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "gauge cntl set fail:%d\n", ret);\r\n}\r\nstatic void fuel_gauge_init_irq(struct axp288_fg_info *info)\r\n{\r\nint ret, i, pirq;\r\nfor (i = 0; i < AXP288_FG_INTR_NUM; i++) {\r\npirq = platform_get_irq(info->pdev, i);\r\ninfo->irq[i] = regmap_irq_get_virq(info->regmap_irqc, pirq);\r\nif (info->irq[i] < 0) {\r\ndev_warn(&info->pdev->dev,\r\n"regmap_irq get virq failed for IRQ %d: %d\n",\r\npirq, info->irq[i]);\r\ninfo->irq[i] = -1;\r\ngoto intr_failed;\r\n}\r\nret = request_threaded_irq(info->irq[i],\r\nNULL, fuel_gauge_thread_handler,\r\nIRQF_ONESHOT, DEV_NAME, info);\r\nif (ret) {\r\ndev_warn(&info->pdev->dev,\r\n"request irq failed for IRQ %d: %d\n",\r\npirq, info->irq[i]);\r\ninfo->irq[i] = -1;\r\ngoto intr_failed;\r\n} else {\r\ndev_info(&info->pdev->dev, "HW IRQ %d -> VIRQ %d\n",\r\npirq, info->irq[i]);\r\n}\r\n}\r\nreturn;\r\nintr_failed:\r\nfor (; i > 0; i--) {\r\nfree_irq(info->irq[i - 1], info);\r\ninfo->irq[i - 1] = -1;\r\n}\r\n}\r\nstatic void fuel_gauge_init_hw_regs(struct axp288_fg_info *info)\r\n{\r\nint ret;\r\nunsigned int val;\r\nret = fuel_gauge_set_high_btemp_alert(info);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "high batt temp set fail:%d\n", ret);\r\nret = fuel_gauge_set_low_btemp_alert(info);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "low batt temp set fail:%d\n", ret);\r\nval = fuel_gauge_reg_readb(info, AXP20X_IRQ3_EN);\r\nval |= TEMP_IRQ_CFG_MASK;\r\nfuel_gauge_reg_writeb(info, AXP20X_IRQ3_EN, val);\r\nval = fuel_gauge_reg_readb(info, AXP20X_IRQ4_EN);\r\nval |= FG_IRQ_CFG_LOWBATT_MASK;\r\nval = fuel_gauge_reg_writeb(info, AXP20X_IRQ4_EN, val);\r\n}\r\nstatic int axp288_fuel_gauge_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct axp288_fg_info *info;\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nstruct power_supply_config psy_cfg = {};\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->pdev = pdev;\r\ninfo->regmap = axp20x->regmap;\r\ninfo->regmap_irqc = axp20x->regmap_irqc;\r\ninfo->status = POWER_SUPPLY_STATUS_UNKNOWN;\r\ninfo->pdata = pdev->dev.platform_data;\r\nif (!info->pdata)\r\nreturn -ENODEV;\r\nplatform_set_drvdata(pdev, info);\r\nmutex_init(&info->lock);\r\nINIT_DELAYED_WORK(&info->status_monitor, fuel_gauge_status_monitor);\r\npsy_cfg.drv_data = info;\r\ninfo->bat = power_supply_register(&pdev->dev, &fuel_gauge_desc, &psy_cfg);\r\nif (IS_ERR(info->bat)) {\r\nret = PTR_ERR(info->bat);\r\ndev_err(&pdev->dev, "failed to register battery: %d\n", ret);\r\nreturn ret;\r\n}\r\nfuel_gauge_create_debugfs(info);\r\nfuel_gauge_init_config_regs(info);\r\nfuel_gauge_init_irq(info);\r\nfuel_gauge_init_hw_regs(info);\r\nschedule_delayed_work(&info->status_monitor, STATUS_MON_DELAY_JIFFIES);\r\nreturn ret;\r\n}\r\nstatic int axp288_fuel_gauge_remove(struct platform_device *pdev)\r\n{\r\nstruct axp288_fg_info *info = platform_get_drvdata(pdev);\r\nint i;\r\ncancel_delayed_work_sync(&info->status_monitor);\r\npower_supply_unregister(info->bat);\r\nfuel_gauge_remove_debugfs(info);\r\nfor (i = 0; i < AXP288_FG_INTR_NUM; i++)\r\nif (info->irq[i] >= 0)\r\nfree_irq(info->irq[i], info);\r\nreturn 0;\r\n}
