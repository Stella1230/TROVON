acpi_status acpi_update_all_gpes(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_update_all_gpes);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_all_gpes_initialized) {\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_ev_walk_gpe_list(acpi_ev_initialize_gpe_block, NULL);\r\nif (ACPI_SUCCESS(status)) {\r\nacpi_gbl_all_gpes_initialized = TRUE;\r\n}\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_enable_gpe(acpi_handle gpe_device, u32 gpe_number)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_enable_gpe);\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (gpe_event_info) {\r\nif (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) !=\r\nACPI_GPE_DISPATCH_NONE) {\r\nstatus = acpi_ev_add_gpe_reference(gpe_event_info);\r\n} else {\r\nstatus = AE_NO_HANDLER;\r\n}\r\n}\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_disable_gpe(acpi_handle gpe_device, u32 gpe_number)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_disable_gpe);\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (gpe_event_info) {\r\nstatus = acpi_ev_remove_gpe_reference(gpe_event_info) ;\r\n}\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_set_gpe(acpi_handle gpe_device, u32 gpe_number, u8 action)\r\n{\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_set_gpe);\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (!gpe_event_info) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nswitch (action) {\r\ncase ACPI_GPE_ENABLE:\r\nstatus = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_ENABLE);\r\nbreak;\r\ncase ACPI_GPE_DISABLE:\r\nstatus = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);\r\nbreak;\r\ndefault:\r\nstatus = AE_BAD_PARAMETER;\r\nbreak;\r\n}\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_mark_gpe_for_wake(acpi_handle gpe_device, u32 gpe_number)\r\n{\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nacpi_status status = AE_BAD_PARAMETER;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_mark_gpe_for_wake);\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (gpe_event_info) {\r\ngpe_event_info->flags |= ACPI_GPE_CAN_WAKE;\r\nstatus = AE_OK;\r\n}\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_setup_gpe_for_wake(acpi_handle wake_device,\r\nacpi_handle gpe_device, u32 gpe_number)\r\n{\r\nacpi_status status;\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nstruct acpi_namespace_node *device_node;\r\nstruct acpi_gpe_notify_info *notify;\r\nstruct acpi_gpe_notify_info *new_notify;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_setup_gpe_for_wake);\r\nif (!wake_device) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (wake_device == ACPI_ROOT_OBJECT) {\r\ndevice_node = acpi_gbl_root_node;\r\n} else {\r\ndevice_node =\r\nACPI_CAST_PTR(struct acpi_namespace_node, wake_device);\r\n}\r\nif (device_node->type != ACPI_TYPE_DEVICE) {\r\nreturn_ACPI_STATUS (AE_BAD_PARAMETER);\r\n}\r\nnew_notify = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_notify_info));\r\nif (!new_notify) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (!gpe_event_info) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nif (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_NONE) {\r\ngpe_event_info->flags =\r\n(ACPI_GPE_DISPATCH_NOTIFY | ACPI_GPE_LEVEL_TRIGGERED);\r\n}\r\nif (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_NOTIFY) {\r\nnotify = gpe_event_info->dispatch.notify_list;\r\nwhile (notify) {\r\nif (notify->device_node == device_node) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto unlock_and_exit;\r\n}\r\nnotify = notify->next;\r\n}\r\nnew_notify->device_node = device_node;\r\nnew_notify->next = gpe_event_info->dispatch.notify_list;\r\ngpe_event_info->dispatch.notify_list = new_notify;\r\nnew_notify = NULL;\r\n}\r\ngpe_event_info->flags |= ACPI_GPE_CAN_WAKE;\r\nstatus = AE_OK;\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nif (new_notify) {\r\nACPI_FREE(new_notify);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_set_gpe_wake_mask(acpi_handle gpe_device, u32 gpe_number, u8 action)\r\n{\r\nacpi_status status = AE_OK;\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nstruct acpi_gpe_register_info *gpe_register_info;\r\nacpi_cpu_flags flags;\r\nu32 register_bit;\r\nACPI_FUNCTION_TRACE(acpi_set_gpe_wake_mask);\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (!gpe_event_info) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nif (!(gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {\r\nstatus = AE_TYPE;\r\ngoto unlock_and_exit;\r\n}\r\ngpe_register_info = gpe_event_info->register_info;\r\nif (!gpe_register_info) {\r\nstatus = AE_NOT_EXIST;\r\ngoto unlock_and_exit;\r\n}\r\nregister_bit = acpi_hw_get_gpe_register_bit(gpe_event_info);\r\nswitch (action) {\r\ncase ACPI_GPE_ENABLE:\r\nACPI_SET_BIT(gpe_register_info->enable_for_wake,\r\n(u8)register_bit);\r\nbreak;\r\ncase ACPI_GPE_DISABLE:\r\nACPI_CLEAR_BIT(gpe_register_info->enable_for_wake,\r\n(u8)register_bit);\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO, "%u, Invalid action", action));\r\nstatus = AE_BAD_PARAMETER;\r\nbreak;\r\n}\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_clear_gpe(acpi_handle gpe_device, u32 gpe_number)\r\n{\r\nacpi_status status = AE_OK;\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_clear_gpe);\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (!gpe_event_info) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_hw_clear_gpe(gpe_event_info);\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_get_gpe_status(acpi_handle gpe_device,\r\nu32 gpe_number, acpi_event_status *event_status)\r\n{\r\nacpi_status status = AE_OK;\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_get_gpe_status);\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (!gpe_event_info) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_hw_get_gpe_status(gpe_event_info, event_status);\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_finish_gpe(acpi_handle gpe_device, u32 gpe_number)\r\n{\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_finish_gpe);\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (!gpe_event_info) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_ev_finish_gpe(gpe_event_info);\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_disable_all_gpes(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_disable_all_gpes);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_hw_disable_all_gpes();\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_enable_all_runtime_gpes(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_enable_all_runtime_gpes);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_hw_enable_all_runtime_gpes();\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_enable_all_wakeup_gpes(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_enable_all_wakeup_gpes);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_hw_enable_all_wakeup_gpes();\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_install_gpe_block(acpi_handle gpe_device,\r\nstruct acpi_generic_address *gpe_block_address,\r\nu32 register_count, u32 interrupt_number)\r\n{\r\nacpi_status status;\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_namespace_node *node;\r\nstruct acpi_gpe_block_info *gpe_block;\r\nACPI_FUNCTION_TRACE(acpi_install_gpe_block);\r\nif ((!gpe_device) || (!gpe_block_address) || (!register_count)) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nnode = acpi_ns_validate_handle(gpe_device);\r\nif (!node) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nif (node->type != ACPI_TYPE_DEVICE) {\r\nstatus = AE_TYPE;\r\ngoto unlock_and_exit;\r\n}\r\nif (node->object) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_ev_create_gpe_block(node, gpe_block_address->address,\r\ngpe_block_address->space_id,\r\nregister_count, 0, interrupt_number,\r\n&gpe_block);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (!obj_desc) {\r\nobj_desc = acpi_ut_create_internal_object(ACPI_TYPE_DEVICE);\r\nif (!obj_desc) {\r\nstatus = AE_NO_MEMORY;\r\ngoto unlock_and_exit;\r\n}\r\nstatus =\r\nacpi_ns_attach_object(node, obj_desc, ACPI_TYPE_DEVICE);\r\nacpi_ut_remove_reference(obj_desc);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\n}\r\nobj_desc->device.gpe_block = gpe_block;\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_remove_gpe_block(acpi_handle gpe_device)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nacpi_status status;\r\nstruct acpi_namespace_node *node;\r\nACPI_FUNCTION_TRACE(acpi_remove_gpe_block);\r\nif (!gpe_device) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nnode = acpi_ns_validate_handle(gpe_device);\r\nif (!node) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nif (node->type != ACPI_TYPE_DEVICE) {\r\nstatus = AE_TYPE;\r\ngoto unlock_and_exit;\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (!obj_desc || !obj_desc->device.gpe_block) {\r\nreturn_ACPI_STATUS(AE_NULL_OBJECT);\r\n}\r\nstatus = acpi_ev_delete_gpe_block(obj_desc->device.gpe_block);\r\nif (ACPI_SUCCESS(status)) {\r\nobj_desc->device.gpe_block = NULL;\r\n}\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_get_gpe_device(u32 index, acpi_handle *gpe_device)\r\n{\r\nstruct acpi_gpe_device_info info;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_get_gpe_device);\r\nif (!gpe_device) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (index >= acpi_current_gpe_count) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\ninfo.index = index;\r\ninfo.status = AE_NOT_EXIST;\r\ninfo.gpe_device = NULL;\r\ninfo.next_block_base_index = 0;\r\nstatus = acpi_ev_walk_gpe_list(acpi_ev_get_gpe_device, &info);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n*gpe_device = ACPI_CAST_PTR(acpi_handle, info.gpe_device);\r\nreturn_ACPI_STATUS(info.status);\r\n}
