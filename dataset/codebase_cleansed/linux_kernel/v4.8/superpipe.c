static void marshal_rele_to_resize(struct dk_cxlflash_release *release,\r\nstruct dk_cxlflash_resize *resize)\r\n{\r\nresize->hdr = release->hdr;\r\nresize->context_id = release->context_id;\r\nresize->rsrc_handle = release->rsrc_handle;\r\n}\r\nstatic void marshal_det_to_rele(struct dk_cxlflash_detach *detach,\r\nstruct dk_cxlflash_release *release)\r\n{\r\nrelease->hdr = detach->hdr;\r\nrelease->context_id = detach->context_id;\r\n}\r\nvoid cxlflash_free_errpage(void)\r\n{\r\nmutex_lock(&global.mutex);\r\nif (global.err_page) {\r\n__free_page(global.err_page);\r\nglobal.err_page = NULL;\r\n}\r\nmutex_unlock(&global.mutex);\r\n}\r\nvoid cxlflash_stop_term_user_contexts(struct cxlflash_cfg *cfg)\r\n{\r\nstruct device *dev = &cfg->dev->dev;\r\nint i, found;\r\ncxlflash_mark_contexts_error(cfg);\r\nwhile (true) {\r\nfound = false;\r\nfor (i = 0; i < MAX_CONTEXT; i++)\r\nif (cfg->ctx_tbl[i]) {\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found && list_empty(&cfg->ctx_err_recovery))\r\nreturn;\r\ndev_dbg(dev, "%s: Wait for user contexts to quiesce...\n",\r\n__func__);\r\nwake_up_all(&cfg->reset_waitq);\r\nssleep(1);\r\n}\r\n}\r\nstatic struct ctx_info *find_error_context(struct cxlflash_cfg *cfg, u64 rctxid,\r\nstruct file *file)\r\n{\r\nstruct ctx_info *ctxi;\r\nlist_for_each_entry(ctxi, &cfg->ctx_err_recovery, list)\r\nif ((ctxi->ctxid == rctxid) || (ctxi->file == file))\r\nreturn ctxi;\r\nreturn NULL;\r\n}\r\nstruct ctx_info *get_context(struct cxlflash_cfg *cfg, u64 rctxid,\r\nvoid *arg, enum ctx_ctrl ctx_ctrl)\r\n{\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct ctx_info *ctxi = NULL;\r\nstruct lun_access *lun_access = NULL;\r\nstruct file *file = NULL;\r\nstruct llun_info *lli = arg;\r\nu64 ctxid = DECODE_CTXID(rctxid);\r\nint rc;\r\npid_t pid = current->tgid, ctxpid = 0;\r\nif (ctx_ctrl & CTX_CTRL_FILE) {\r\nlli = NULL;\r\nfile = (struct file *)arg;\r\n}\r\nif (ctx_ctrl & CTX_CTRL_CLONE)\r\npid = current->parent->tgid;\r\nif (likely(ctxid < MAX_CONTEXT)) {\r\nwhile (true) {\r\nmutex_lock(&cfg->ctx_tbl_list_mutex);\r\nctxi = cfg->ctx_tbl[ctxid];\r\nif (ctxi)\r\nif ((file && (ctxi->file != file)) ||\r\n(!file && (ctxi->ctxid != rctxid)))\r\nctxi = NULL;\r\nif ((ctx_ctrl & CTX_CTRL_ERR) ||\r\n(!ctxi && (ctx_ctrl & CTX_CTRL_ERR_FALLBACK)))\r\nctxi = find_error_context(cfg, rctxid, file);\r\nif (!ctxi) {\r\nmutex_unlock(&cfg->ctx_tbl_list_mutex);\r\ngoto out;\r\n}\r\nrc = mutex_trylock(&ctxi->mutex);\r\nmutex_unlock(&cfg->ctx_tbl_list_mutex);\r\nif (rc)\r\nbreak;\r\n}\r\nif (ctxi->unavail)\r\ngoto denied;\r\nctxpid = ctxi->pid;\r\nif (likely(!(ctx_ctrl & CTX_CTRL_NOPID)))\r\nif (pid != ctxpid)\r\ngoto denied;\r\nif (lli) {\r\nlist_for_each_entry(lun_access, &ctxi->luns, list)\r\nif (lun_access->lli == lli)\r\ngoto out;\r\ngoto denied;\r\n}\r\n}\r\nout:\r\ndev_dbg(dev, "%s: rctxid=%016llX ctxinfo=%p ctxpid=%u pid=%u "\r\n"ctx_ctrl=%u\n", __func__, rctxid, ctxi, ctxpid, pid,\r\nctx_ctrl);\r\nreturn ctxi;\r\ndenied:\r\nmutex_unlock(&ctxi->mutex);\r\nctxi = NULL;\r\ngoto out;\r\n}\r\nvoid put_context(struct ctx_info *ctxi)\r\n{\r\nmutex_unlock(&ctxi->mutex);\r\n}\r\nstatic int afu_attach(struct cxlflash_cfg *cfg, struct ctx_info *ctxi)\r\n{\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct afu *afu = cfg->afu;\r\nstruct sisl_ctrl_map __iomem *ctrl_map = ctxi->ctrl_map;\r\nint rc = 0;\r\nu64 val;\r\nreadq_be(&ctrl_map->mbox_r);\r\nval = (SISL_CTX_CAP_READ_CMD | SISL_CTX_CAP_WRITE_CMD);\r\nwriteq_be(val, &ctrl_map->ctx_cap);\r\nval = readq_be(&ctrl_map->ctx_cap);\r\nif (val != (SISL_CTX_CAP_READ_CMD | SISL_CTX_CAP_WRITE_CMD)) {\r\ndev_err(dev, "%s: ctx may be closed val=%016llX\n",\r\n__func__, val);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nwriteq_be((u64)ctxi->rht_start, &ctrl_map->rht_start);\r\nval = SISL_RHT_CNT_ID((u64)MAX_RHT_PER_CONTEXT, (u64)(afu->ctx_hndl));\r\nwriteq_be(val, &ctrl_map->rht_cnt_id);\r\nout:\r\ndev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int read_cap16(struct scsi_device *sdev, struct llun_info *lli)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct glun_info *gli = lli->parent;\r\nu8 *cmd_buf = NULL;\r\nu8 *scsi_cmd = NULL;\r\nu8 *sense_buf = NULL;\r\nint rc = 0;\r\nint result = 0;\r\nint retry_cnt = 0;\r\nu32 to = CMD_TIMEOUT * HZ;\r\nretry:\r\ncmd_buf = kzalloc(CMD_BUFSIZE, GFP_KERNEL);\r\nscsi_cmd = kzalloc(MAX_COMMAND_SIZE, GFP_KERNEL);\r\nsense_buf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);\r\nif (unlikely(!cmd_buf || !scsi_cmd || !sense_buf)) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nscsi_cmd[0] = SERVICE_ACTION_IN_16;\r\nscsi_cmd[1] = SAI_READ_CAPACITY_16;\r\nput_unaligned_be32(CMD_BUFSIZE, &scsi_cmd[10]);\r\ndev_dbg(dev, "%s: %ssending cmd(0x%x)\n", __func__,\r\nretry_cnt ? "re" : "", scsi_cmd[0]);\r\nup_read(&cfg->ioctl_rwsem);\r\nresult = scsi_execute(sdev, scsi_cmd, DMA_FROM_DEVICE, cmd_buf,\r\nCMD_BUFSIZE, sense_buf, to, CMD_RETRIES, 0, NULL);\r\ndown_read(&cfg->ioctl_rwsem);\r\nrc = check_state(cfg);\r\nif (rc) {\r\ndev_err(dev, "%s: Failed state! result=0x08%X\n",\r\n__func__, result);\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nif (driver_byte(result) == DRIVER_SENSE) {\r\nresult &= ~(0xFF<<24);\r\nif (result & SAM_STAT_CHECK_CONDITION) {\r\nstruct scsi_sense_hdr sshdr;\r\nscsi_normalize_sense(sense_buf, SCSI_SENSE_BUFFERSIZE,\r\n&sshdr);\r\nswitch (sshdr.sense_key) {\r\ncase NO_SENSE:\r\ncase RECOVERED_ERROR:\r\ncase NOT_READY:\r\nresult &= ~SAM_STAT_CHECK_CONDITION;\r\nbreak;\r\ncase UNIT_ATTENTION:\r\nswitch (sshdr.asc) {\r\ncase 0x29:\r\ncase 0x2A:\r\ncase 0x3F:\r\nif (retry_cnt++ < 1) {\r\nkfree(cmd_buf);\r\nkfree(scsi_cmd);\r\nkfree(sense_buf);\r\ngoto retry;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nif (result) {\r\ndev_err(dev, "%s: command failed, result=0x%x\n",\r\n__func__, result);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nmutex_lock(&gli->mutex);\r\ngli->max_lba = be64_to_cpu(*((__be64 *)&cmd_buf[0]));\r\ngli->blk_len = be32_to_cpu(*((__be32 *)&cmd_buf[8]));\r\nmutex_unlock(&gli->mutex);\r\nout:\r\nkfree(cmd_buf);\r\nkfree(scsi_cmd);\r\nkfree(sense_buf);\r\ndev_dbg(dev, "%s: maxlba=%lld blklen=%d rc=%d\n",\r\n__func__, gli->max_lba, gli->blk_len, rc);\r\nreturn rc;\r\n}\r\nstruct sisl_rht_entry *get_rhte(struct ctx_info *ctxi, res_hndl_t rhndl,\r\nstruct llun_info *lli)\r\n{\r\nstruct sisl_rht_entry *rhte = NULL;\r\nif (unlikely(!ctxi->rht_start)) {\r\npr_debug("%s: Context does not have allocated RHT!\n",\r\n__func__);\r\ngoto out;\r\n}\r\nif (unlikely(rhndl >= MAX_RHT_PER_CONTEXT)) {\r\npr_debug("%s: Bad resource handle! (%d)\n", __func__, rhndl);\r\ngoto out;\r\n}\r\nif (unlikely(ctxi->rht_lun[rhndl] != lli)) {\r\npr_debug("%s: Bad resource handle LUN! (%d)\n",\r\n__func__, rhndl);\r\ngoto out;\r\n}\r\nrhte = &ctxi->rht_start[rhndl];\r\nif (unlikely(rhte->nmask == 0)) {\r\npr_debug("%s: Unopened resource handle! (%d)\n",\r\n__func__, rhndl);\r\nrhte = NULL;\r\ngoto out;\r\n}\r\nout:\r\nreturn rhte;\r\n}\r\nstruct sisl_rht_entry *rhte_checkout(struct ctx_info *ctxi,\r\nstruct llun_info *lli)\r\n{\r\nstruct sisl_rht_entry *rhte = NULL;\r\nint i;\r\nfor (i = 0; i < MAX_RHT_PER_CONTEXT; i++)\r\nif (ctxi->rht_start[i].nmask == 0) {\r\nrhte = &ctxi->rht_start[i];\r\nctxi->rht_out++;\r\nbreak;\r\n}\r\nif (likely(rhte))\r\nctxi->rht_lun[i] = lli;\r\npr_debug("%s: returning rhte=%p (%d)\n", __func__, rhte, i);\r\nreturn rhte;\r\n}\r\nvoid rhte_checkin(struct ctx_info *ctxi,\r\nstruct sisl_rht_entry *rhte)\r\n{\r\nu32 rsrc_handle = rhte - ctxi->rht_start;\r\nrhte->nmask = 0;\r\nrhte->fp = 0;\r\nctxi->rht_out--;\r\nctxi->rht_lun[rsrc_handle] = NULL;\r\nctxi->rht_needs_ws[rsrc_handle] = false;\r\n}\r\nstatic void rht_format1(struct sisl_rht_entry *rhte, u64 lun_id, u32 perm,\r\nu32 port_sel)\r\n{\r\nstruct sisl_rht_entry_f1 dummy = { 0 };\r\nstruct sisl_rht_entry_f1 *rhte_f1 = (struct sisl_rht_entry_f1 *)rhte;\r\nmemset(rhte_f1, 0, sizeof(*rhte_f1));\r\nrhte_f1->fp = SISL_RHT_FP(1U, 0);\r\ndma_wmb();\r\nrhte_f1->lun_id = lun_id;\r\ndma_wmb();\r\ndummy.valid = 0x80;\r\ndummy.fp = SISL_RHT_FP(1U, perm);\r\ndummy.port_sel = port_sel;\r\nrhte_f1->dw = dummy.dw;\r\ndma_wmb();\r\n}\r\nint cxlflash_lun_attach(struct glun_info *gli, enum lun_mode mode, bool locked)\r\n{\r\nint rc = 0;\r\nif (!locked)\r\nmutex_lock(&gli->mutex);\r\nif (gli->mode == MODE_NONE)\r\ngli->mode = mode;\r\nelse if (gli->mode != mode) {\r\npr_debug("%s: LUN operating in mode %d, requested mode %d\n",\r\n__func__, gli->mode, mode);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ngli->users++;\r\nWARN_ON(gli->users <= 0);\r\nout:\r\npr_debug("%s: Returning rc=%d gli->mode=%u gli->users=%u\n",\r\n__func__, rc, gli->mode, gli->users);\r\nif (!locked)\r\nmutex_unlock(&gli->mutex);\r\nreturn rc;\r\n}\r\nvoid cxlflash_lun_detach(struct glun_info *gli)\r\n{\r\nmutex_lock(&gli->mutex);\r\nWARN_ON(gli->mode == MODE_NONE);\r\nif (--gli->users == 0) {\r\ngli->mode = MODE_NONE;\r\ncxlflash_ba_terminate(&gli->blka.ba_lun);\r\n}\r\npr_debug("%s: gli->users=%u\n", __func__, gli->users);\r\nWARN_ON(gli->users < 0);\r\nmutex_unlock(&gli->mutex);\r\n}\r\nint _cxlflash_disk_release(struct scsi_device *sdev,\r\nstruct ctx_info *ctxi,\r\nstruct dk_cxlflash_release *release)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct glun_info *gli = lli->parent;\r\nstruct afu *afu = cfg->afu;\r\nbool put_ctx = false;\r\nstruct dk_cxlflash_resize size;\r\nres_hndl_t rhndl = release->rsrc_handle;\r\nint rc = 0;\r\nu64 ctxid = DECODE_CTXID(release->context_id),\r\nrctxid = release->context_id;\r\nstruct sisl_rht_entry *rhte;\r\nstruct sisl_rht_entry_f1 *rhte_f1;\r\ndev_dbg(dev, "%s: ctxid=%llu rhndl=0x%llx gli->mode=%u gli->users=%u\n",\r\n__func__, ctxid, release->rsrc_handle, gli->mode, gli->users);\r\nif (!ctxi) {\r\nctxi = get_context(cfg, rctxid, lli, CTX_CTRL_ERR_FALLBACK);\r\nif (unlikely(!ctxi)) {\r\ndev_dbg(dev, "%s: Bad context! (%llu)\n",\r\n__func__, ctxid);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nput_ctx = true;\r\n}\r\nrhte = get_rhte(ctxi, rhndl, lli);\r\nif (unlikely(!rhte)) {\r\ndev_dbg(dev, "%s: Bad resource handle! (%d)\n",\r\n__func__, rhndl);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (gli->mode) {\r\ncase MODE_VIRTUAL:\r\nmarshal_rele_to_resize(release, &size);\r\nsize.req_size = 0;\r\nrc = _cxlflash_vlun_resize(sdev, ctxi, &size);\r\nif (rc) {\r\ndev_dbg(dev, "%s: resize failed rc %d\n", __func__, rc);\r\ngoto out;\r\n}\r\nbreak;\r\ncase MODE_PHYSICAL:\r\nrhte_f1 = (struct sisl_rht_entry_f1 *)rhte;\r\nrhte_f1->valid = 0;\r\ndma_wmb();\r\nrhte_f1->lun_id = 0;\r\ndma_wmb();\r\nrhte_f1->dw = 0;\r\ndma_wmb();\r\nif (!ctxi->err_recovery_active)\r\ncxlflash_afu_sync(afu, ctxid, rhndl, AFU_HW_SYNC);\r\nbreak;\r\ndefault:\r\nWARN(1, "Unsupported LUN mode!");\r\ngoto out;\r\n}\r\nrhte_checkin(ctxi, rhte);\r\ncxlflash_lun_detach(gli);\r\nout:\r\nif (put_ctx)\r\nput_context(ctxi);\r\ndev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint cxlflash_disk_release(struct scsi_device *sdev,\r\nstruct dk_cxlflash_release *release)\r\n{\r\nreturn _cxlflash_disk_release(sdev, NULL, release);\r\n}\r\nstatic void destroy_context(struct cxlflash_cfg *cfg,\r\nstruct ctx_info *ctxi)\r\n{\r\nstruct afu *afu = cfg->afu;\r\nif (ctxi->initialized) {\r\nWARN_ON(!list_empty(&ctxi->luns));\r\nif (afu->afu_map && ctxi->ctrl_map) {\r\nwriteq_be(0, &ctxi->ctrl_map->rht_start);\r\nwriteq_be(0, &ctxi->ctrl_map->rht_cnt_id);\r\nwriteq_be(0, &ctxi->ctrl_map->ctx_cap);\r\n}\r\nif (mutex_is_locked(&ctxi->mutex))\r\nmutex_unlock(&ctxi->mutex);\r\n}\r\nfree_page((ulong)ctxi->rht_start);\r\nkfree(ctxi->rht_needs_ws);\r\nkfree(ctxi->rht_lun);\r\nkfree(ctxi);\r\n}\r\nstatic struct ctx_info *create_context(struct cxlflash_cfg *cfg)\r\n{\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct ctx_info *ctxi = NULL;\r\nstruct llun_info **lli = NULL;\r\nu8 *ws = NULL;\r\nstruct sisl_rht_entry *rhte;\r\nctxi = kzalloc(sizeof(*ctxi), GFP_KERNEL);\r\nlli = kzalloc((MAX_RHT_PER_CONTEXT * sizeof(*lli)), GFP_KERNEL);\r\nws = kzalloc((MAX_RHT_PER_CONTEXT * sizeof(*ws)), GFP_KERNEL);\r\nif (unlikely(!ctxi || !lli || !ws)) {\r\ndev_err(dev, "%s: Unable to allocate context!\n", __func__);\r\ngoto err;\r\n}\r\nrhte = (struct sisl_rht_entry *)get_zeroed_page(GFP_KERNEL);\r\nif (unlikely(!rhte)) {\r\ndev_err(dev, "%s: Unable to allocate RHT!\n", __func__);\r\ngoto err;\r\n}\r\nctxi->rht_lun = lli;\r\nctxi->rht_needs_ws = ws;\r\nctxi->rht_start = rhte;\r\nout:\r\nreturn ctxi;\r\nerr:\r\nkfree(ws);\r\nkfree(lli);\r\nkfree(ctxi);\r\nctxi = NULL;\r\ngoto out;\r\n}\r\nstatic void init_context(struct ctx_info *ctxi, struct cxlflash_cfg *cfg,\r\nstruct cxl_context *ctx, int ctxid, int adap_fd,\r\nstruct file *file, u32 perms)\r\n{\r\nstruct afu *afu = cfg->afu;\r\nctxi->rht_perms = perms;\r\nctxi->ctrl_map = &afu->afu_map->ctrls[ctxid].ctrl;\r\nctxi->ctxid = ENCODE_CTXID(ctxi, ctxid);\r\nctxi->lfd = adap_fd;\r\nctxi->pid = current->tgid;\r\nctxi->ctx = ctx;\r\nctxi->file = file;\r\nctxi->initialized = true;\r\nmutex_init(&ctxi->mutex);\r\nINIT_LIST_HEAD(&ctxi->luns);\r\nINIT_LIST_HEAD(&ctxi->list);\r\nmutex_lock(&ctxi->mutex);\r\n}\r\nstatic int _cxlflash_disk_detach(struct scsi_device *sdev,\r\nstruct ctx_info *ctxi,\r\nstruct dk_cxlflash_detach *detach)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct lun_access *lun_access, *t;\r\nstruct dk_cxlflash_release rel;\r\nbool put_ctx = false;\r\nint i;\r\nint rc = 0;\r\nint lfd;\r\nu64 ctxid = DECODE_CTXID(detach->context_id),\r\nrctxid = detach->context_id;\r\ndev_dbg(dev, "%s: ctxid=%llu\n", __func__, ctxid);\r\nif (!ctxi) {\r\nctxi = get_context(cfg, rctxid, lli, CTX_CTRL_ERR_FALLBACK);\r\nif (unlikely(!ctxi)) {\r\ndev_dbg(dev, "%s: Bad context! (%llu)\n",\r\n__func__, ctxid);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nput_ctx = true;\r\n}\r\nif (ctxi->rht_out) {\r\nmarshal_det_to_rele(detach, &rel);\r\nfor (i = 0; i < MAX_RHT_PER_CONTEXT; i++) {\r\nif (ctxi->rht_lun[i] == lli) {\r\nrel.rsrc_handle = i;\r\n_cxlflash_disk_release(sdev, ctxi, &rel);\r\n}\r\nif (ctxi->rht_out == 0)\r\nbreak;\r\n}\r\n}\r\nlist_for_each_entry_safe(lun_access, t, &ctxi->luns, list)\r\nif (lun_access->lli == lli) {\r\nlist_del(&lun_access->list);\r\nkfree(lun_access);\r\nlun_access = NULL;\r\nbreak;\r\n}\r\nif (list_empty(&ctxi->luns)) {\r\nctxi->unavail = true;\r\nmutex_unlock(&ctxi->mutex);\r\nmutex_lock(&cfg->ctx_tbl_list_mutex);\r\nmutex_lock(&ctxi->mutex);\r\nif (!list_empty(&ctxi->list))\r\nlist_del(&ctxi->list);\r\ncfg->ctx_tbl[ctxid] = NULL;\r\nmutex_unlock(&cfg->ctx_tbl_list_mutex);\r\nmutex_unlock(&ctxi->mutex);\r\nlfd = ctxi->lfd;\r\ndestroy_context(cfg, ctxi);\r\nctxi = NULL;\r\nput_ctx = false;\r\nif (lfd != -1)\r\nsys_close(lfd);\r\n}\r\nscsi_device_put(sdev);\r\nout:\r\nif (put_ctx)\r\nput_context(ctxi);\r\ndev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int cxlflash_disk_detach(struct scsi_device *sdev,\r\nstruct dk_cxlflash_detach *detach)\r\n{\r\nreturn _cxlflash_disk_detach(sdev, NULL, detach);\r\n}\r\nstatic int cxlflash_cxl_release(struct inode *inode, struct file *file)\r\n{\r\nstruct cxl_context *ctx = cxl_fops_get_context(file);\r\nstruct cxlflash_cfg *cfg = container_of(file->f_op, struct cxlflash_cfg,\r\ncxl_fops);\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct ctx_info *ctxi = NULL;\r\nstruct dk_cxlflash_detach detach = { { 0 }, 0 };\r\nstruct lun_access *lun_access, *t;\r\nenum ctx_ctrl ctrl = CTX_CTRL_ERR_FALLBACK | CTX_CTRL_FILE;\r\nint ctxid;\r\nctxid = cxl_process_element(ctx);\r\nif (unlikely(ctxid < 0)) {\r\ndev_err(dev, "%s: Context %p was closed! (%d)\n",\r\n__func__, ctx, ctxid);\r\ngoto out;\r\n}\r\nctxi = get_context(cfg, ctxid, file, ctrl);\r\nif (unlikely(!ctxi)) {\r\nctxi = get_context(cfg, ctxid, file, ctrl | CTX_CTRL_CLONE);\r\nif (!ctxi) {\r\ndev_dbg(dev, "%s: Context %d already free!\n",\r\n__func__, ctxid);\r\ngoto out_release;\r\n}\r\ndev_dbg(dev, "%s: Another process owns context %d!\n",\r\n__func__, ctxid);\r\nput_context(ctxi);\r\ngoto out;\r\n}\r\ndev_dbg(dev, "%s: close(%d) for context %d\n",\r\n__func__, ctxi->lfd, ctxid);\r\nctxi->lfd = -1;\r\ndetach.context_id = ctxi->ctxid;\r\nlist_for_each_entry_safe(lun_access, t, &ctxi->luns, list)\r\n_cxlflash_disk_detach(lun_access->sdev, ctxi, &detach);\r\nout_release:\r\ncxl_fd_release(inode, file);\r\nout:\r\ndev_dbg(dev, "%s: returning\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void unmap_context(struct ctx_info *ctxi)\r\n{\r\nunmap_mapping_range(ctxi->file->f_mapping, 0, 0, 1);\r\n}\r\nstatic struct page *get_err_page(void)\r\n{\r\nstruct page *err_page = global.err_page;\r\nif (unlikely(!err_page)) {\r\nerr_page = alloc_page(GFP_KERNEL);\r\nif (unlikely(!err_page)) {\r\npr_err("%s: Unable to allocate err_page!\n", __func__);\r\ngoto out;\r\n}\r\nmemset(page_address(err_page), -1, PAGE_SIZE);\r\nmutex_lock(&global.mutex);\r\nif (likely(!global.err_page))\r\nglobal.err_page = err_page;\r\nelse {\r\n__free_page(err_page);\r\nerr_page = global.err_page;\r\n}\r\nmutex_unlock(&global.mutex);\r\n}\r\nout:\r\npr_debug("%s: returning err_page=%p\n", __func__, err_page);\r\nreturn err_page;\r\n}\r\nstatic int cxlflash_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct cxl_context *ctx = cxl_fops_get_context(file);\r\nstruct cxlflash_cfg *cfg = container_of(file->f_op, struct cxlflash_cfg,\r\ncxl_fops);\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct ctx_info *ctxi = NULL;\r\nstruct page *err_page = NULL;\r\nenum ctx_ctrl ctrl = CTX_CTRL_ERR_FALLBACK | CTX_CTRL_FILE;\r\nint rc = 0;\r\nint ctxid;\r\nctxid = cxl_process_element(ctx);\r\nif (unlikely(ctxid < 0)) {\r\ndev_err(dev, "%s: Context %p was closed! (%d)\n",\r\n__func__, ctx, ctxid);\r\ngoto err;\r\n}\r\nctxi = get_context(cfg, ctxid, file, ctrl);\r\nif (unlikely(!ctxi)) {\r\ndev_dbg(dev, "%s: Bad context! (%d)\n", __func__, ctxid);\r\ngoto err;\r\n}\r\ndev_dbg(dev, "%s: fault(%d) for context %d\n",\r\n__func__, ctxi->lfd, ctxid);\r\nif (likely(!ctxi->err_recovery_active)) {\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nrc = ctxi->cxl_mmap_vmops->fault(vma, vmf);\r\n} else {\r\ndev_dbg(dev, "%s: err recovery active, use err_page!\n",\r\n__func__);\r\nerr_page = get_err_page();\r\nif (unlikely(!err_page)) {\r\ndev_err(dev, "%s: Could not obtain error page!\n",\r\n__func__);\r\nrc = VM_FAULT_RETRY;\r\ngoto out;\r\n}\r\nget_page(err_page);\r\nvmf->page = err_page;\r\nvma->vm_page_prot = pgprot_cached(vma->vm_page_prot);\r\n}\r\nout:\r\nif (likely(ctxi))\r\nput_context(ctxi);\r\ndev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);\r\nreturn rc;\r\nerr:\r\nrc = VM_FAULT_SIGBUS;\r\ngoto out;\r\n}\r\nstatic int cxlflash_cxl_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct cxl_context *ctx = cxl_fops_get_context(file);\r\nstruct cxlflash_cfg *cfg = container_of(file->f_op, struct cxlflash_cfg,\r\ncxl_fops);\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct ctx_info *ctxi = NULL;\r\nenum ctx_ctrl ctrl = CTX_CTRL_ERR_FALLBACK | CTX_CTRL_FILE;\r\nint ctxid;\r\nint rc = 0;\r\nctxid = cxl_process_element(ctx);\r\nif (unlikely(ctxid < 0)) {\r\ndev_err(dev, "%s: Context %p was closed! (%d)\n",\r\n__func__, ctx, ctxid);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nctxi = get_context(cfg, ctxid, file, ctrl);\r\nif (unlikely(!ctxi)) {\r\ndev_dbg(dev, "%s: Bad context! (%d)\n", __func__, ctxid);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\ndev_dbg(dev, "%s: mmap(%d) for context %d\n",\r\n__func__, ctxi->lfd, ctxid);\r\nrc = cxl_fd_mmap(file, vma);\r\nif (likely(!rc)) {\r\nctxi->cxl_mmap_vmops = vma->vm_ops;\r\nvma->vm_ops = &cxlflash_mmap_vmops;\r\n}\r\nout:\r\nif (likely(ctxi))\r\nput_context(ctxi);\r\nreturn rc;\r\n}\r\nint cxlflash_mark_contexts_error(struct cxlflash_cfg *cfg)\r\n{\r\nint i, rc = 0;\r\nstruct ctx_info *ctxi = NULL;\r\nmutex_lock(&cfg->ctx_tbl_list_mutex);\r\nfor (i = 0; i < MAX_CONTEXT; i++) {\r\nctxi = cfg->ctx_tbl[i];\r\nif (ctxi) {\r\nmutex_lock(&ctxi->mutex);\r\ncfg->ctx_tbl[i] = NULL;\r\nlist_add(&ctxi->list, &cfg->ctx_err_recovery);\r\nctxi->err_recovery_active = true;\r\nctxi->ctrl_map = NULL;\r\nunmap_context(ctxi);\r\nmutex_unlock(&ctxi->mutex);\r\n}\r\n}\r\nmutex_unlock(&cfg->ctx_tbl_list_mutex);\r\nreturn rc;\r\n}\r\nint check_state(struct cxlflash_cfg *cfg)\r\n{\r\nstruct device *dev = &cfg->dev->dev;\r\nint rc = 0;\r\nretry:\r\nswitch (cfg->state) {\r\ncase STATE_RESET:\r\ndev_dbg(dev, "%s: Reset state, going to wait...\n", __func__);\r\nup_read(&cfg->ioctl_rwsem);\r\nrc = wait_event_interruptible(cfg->reset_waitq,\r\ncfg->state != STATE_RESET);\r\ndown_read(&cfg->ioctl_rwsem);\r\nif (unlikely(rc))\r\nbreak;\r\ngoto retry;\r\ncase STATE_FAILTERM:\r\ndev_dbg(dev, "%s: Failed/Terminating!\n", __func__);\r\nrc = -ENODEV;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int cxlflash_disk_attach(struct scsi_device *sdev,\r\nstruct dk_cxlflash_attach *attach)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct afu *afu = cfg->afu;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct glun_info *gli = lli->parent;\r\nstruct cxl_ioctl_start_work *work;\r\nstruct ctx_info *ctxi = NULL;\r\nstruct lun_access *lun_access = NULL;\r\nint rc = 0;\r\nu32 perms;\r\nint ctxid = -1;\r\nu64 rctxid = 0UL;\r\nstruct file *file = NULL;\r\nstruct cxl_context *ctx = NULL;\r\nint fd = -1;\r\nif (attach->num_interrupts > 4) {\r\ndev_dbg(dev, "%s: Cannot support this many interrupts %llu\n",\r\n__func__, attach->num_interrupts);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (gli->max_lba == 0) {\r\ndev_dbg(dev, "%s: No capacity info for this LUN (%016llX)\n",\r\n__func__, lli->lun_id[sdev->channel]);\r\nrc = read_cap16(sdev, lli);\r\nif (rc) {\r\ndev_err(dev, "%s: Invalid device! (%d)\n",\r\n__func__, rc);\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\ndev_dbg(dev, "%s: LBA = %016llX\n", __func__, gli->max_lba);\r\ndev_dbg(dev, "%s: BLK_LEN = %08X\n", __func__, gli->blk_len);\r\n}\r\nif (attach->hdr.flags & DK_CXLFLASH_ATTACH_REUSE_CONTEXT) {\r\nrctxid = attach->context_id;\r\nctxi = get_context(cfg, rctxid, NULL, 0);\r\nif (!ctxi) {\r\ndev_dbg(dev, "%s: Bad context! (%016llX)\n",\r\n__func__, rctxid);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlist_for_each_entry(lun_access, &ctxi->luns, list)\r\nif (lun_access->lli == lli) {\r\ndev_dbg(dev, "%s: Already attached!\n",\r\n__func__);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nrc = scsi_device_get(sdev);\r\nif (unlikely(rc)) {\r\ndev_err(dev, "%s: Unable to get sdev reference!\n", __func__);\r\ngoto out;\r\n}\r\nlun_access = kzalloc(sizeof(*lun_access), GFP_KERNEL);\r\nif (unlikely(!lun_access)) {\r\ndev_err(dev, "%s: Unable to allocate lun_access!\n", __func__);\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\nlun_access->lli = lli;\r\nlun_access->sdev = sdev;\r\nif (ctxi) {\r\ndev_dbg(dev, "%s: Reusing context for LUN! (%016llX)\n",\r\n__func__, rctxid);\r\nlist_add(&lun_access->list, &ctxi->luns);\r\nfd = ctxi->lfd;\r\ngoto out_attach;\r\n}\r\nctxi = create_context(cfg);\r\nif (unlikely(!ctxi)) {\r\ndev_err(dev, "%s: Failed to create context! (%d)\n",\r\n__func__, ctxid);\r\ngoto err;\r\n}\r\nctx = cxl_dev_context_init(cfg->dev);\r\nif (IS_ERR_OR_NULL(ctx)) {\r\ndev_err(dev, "%s: Could not initialize context %p\n",\r\n__func__, ctx);\r\nrc = -ENODEV;\r\ngoto err;\r\n}\r\nwork = &ctxi->work;\r\nwork->num_interrupts = attach->num_interrupts;\r\nwork->flags = CXL_START_WORK_NUM_IRQS;\r\nrc = cxl_start_work(ctx, work);\r\nif (unlikely(rc)) {\r\ndev_dbg(dev, "%s: Could not start context rc=%d\n",\r\n__func__, rc);\r\ngoto err;\r\n}\r\nctxid = cxl_process_element(ctx);\r\nif (unlikely((ctxid >= MAX_CONTEXT) || (ctxid < 0))) {\r\ndev_err(dev, "%s: ctxid (%d) invalid!\n", __func__, ctxid);\r\nrc = -EPERM;\r\ngoto err;\r\n}\r\nfile = cxl_get_fd(ctx, &cfg->cxl_fops, &fd);\r\nif (unlikely(fd < 0)) {\r\nrc = -ENODEV;\r\ndev_err(dev, "%s: Could not get file descriptor\n", __func__);\r\ngoto err;\r\n}\r\nperms = SISL_RHT_PERM(attach->hdr.flags + 1);\r\ninit_context(ctxi, cfg, ctx, ctxid, fd, file, perms);\r\nrc = afu_attach(cfg, ctxi);\r\nif (unlikely(rc)) {\r\ndev_err(dev, "%s: Could not attach AFU rc %d\n", __func__, rc);\r\ngoto err;\r\n}\r\nlist_add(&lun_access->list, &ctxi->luns);\r\nmutex_unlock(&ctxi->mutex);\r\nmutex_lock(&cfg->ctx_tbl_list_mutex);\r\nmutex_lock(&ctxi->mutex);\r\ncfg->ctx_tbl[ctxid] = ctxi;\r\nmutex_unlock(&cfg->ctx_tbl_list_mutex);\r\nfd_install(fd, file);\r\nout_attach:\r\nattach->hdr.return_flags = 0;\r\nattach->context_id = ctxi->ctxid;\r\nattach->block_size = gli->blk_len;\r\nattach->mmio_size = sizeof(afu->afu_map->hosts[0].harea);\r\nattach->last_lba = gli->max_lba;\r\nattach->max_xfer = sdev->host->max_sectors * MAX_SECTOR_UNIT;\r\nattach->max_xfer /= gli->blk_len;\r\nout:\r\nattach->adap_fd = fd;\r\nif (ctxi)\r\nput_context(ctxi);\r\ndev_dbg(dev, "%s: returning ctxid=%d fd=%d bs=%lld rc=%d llba=%lld\n",\r\n__func__, ctxid, fd, attach->block_size, rc, attach->last_lba);\r\nreturn rc;\r\nerr:\r\nif (!IS_ERR_OR_NULL(ctx)) {\r\ncxl_stop_context(ctx);\r\ncxl_release_context(ctx);\r\nctx = NULL;\r\n}\r\nif (fd > 0) {\r\nfile->f_op = &null_fops;\r\nfput(file);\r\nput_unused_fd(fd);\r\nfd = -1;\r\nfile = NULL;\r\n}\r\nif (ctxi) {\r\ndestroy_context(cfg, ctxi);\r\nctxi = NULL;\r\n}\r\nkfree(lun_access);\r\nscsi_device_put(sdev);\r\ngoto out;\r\n}\r\nstatic int recover_context(struct cxlflash_cfg *cfg, struct ctx_info *ctxi)\r\n{\r\nstruct device *dev = &cfg->dev->dev;\r\nint rc = 0;\r\nint old_fd, fd = -1;\r\nint ctxid = -1;\r\nstruct file *file;\r\nstruct cxl_context *ctx;\r\nstruct afu *afu = cfg->afu;\r\nctx = cxl_dev_context_init(cfg->dev);\r\nif (IS_ERR_OR_NULL(ctx)) {\r\ndev_err(dev, "%s: Could not initialize context %p\n",\r\n__func__, ctx);\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nrc = cxl_start_work(ctx, &ctxi->work);\r\nif (unlikely(rc)) {\r\ndev_dbg(dev, "%s: Could not start context rc=%d\n",\r\n__func__, rc);\r\ngoto err1;\r\n}\r\nctxid = cxl_process_element(ctx);\r\nif (unlikely((ctxid >= MAX_CONTEXT) || (ctxid < 0))) {\r\ndev_err(dev, "%s: ctxid (%d) invalid!\n", __func__, ctxid);\r\nrc = -EPERM;\r\ngoto err2;\r\n}\r\nfile = cxl_get_fd(ctx, &cfg->cxl_fops, &fd);\r\nif (unlikely(fd < 0)) {\r\nrc = -ENODEV;\r\ndev_err(dev, "%s: Could not get file descriptor\n", __func__);\r\ngoto err2;\r\n}\r\nctxi->ctrl_map = &afu->afu_map->ctrls[ctxid].ctrl;\r\nrc = afu_attach(cfg, ctxi);\r\nif (rc) {\r\ndev_err(dev, "%s: Could not attach AFU rc %d\n", __func__, rc);\r\ngoto err3;\r\n}\r\nold_fd = ctxi->lfd;\r\nctxi->ctxid = ENCODE_CTXID(ctxi, ctxid);\r\nctxi->lfd = fd;\r\nctxi->ctx = ctx;\r\nctxi->file = file;\r\nmutex_unlock(&ctxi->mutex);\r\nmutex_lock(&cfg->ctx_tbl_list_mutex);\r\nmutex_lock(&ctxi->mutex);\r\nlist_del_init(&ctxi->list);\r\ncfg->ctx_tbl[ctxid] = ctxi;\r\nmutex_unlock(&cfg->ctx_tbl_list_mutex);\r\nfd_install(fd, file);\r\nsys_close(old_fd);\r\nout:\r\ndev_dbg(dev, "%s: returning ctxid=%d fd=%d rc=%d\n",\r\n__func__, ctxid, fd, rc);\r\nreturn rc;\r\nerr3:\r\nfput(file);\r\nput_unused_fd(fd);\r\nerr2:\r\ncxl_stop_context(ctx);\r\nerr1:\r\ncxl_release_context(ctx);\r\ngoto out;\r\n}\r\nstatic int cxlflash_afu_recover(struct scsi_device *sdev,\r\nstruct dk_cxlflash_recover_afu *recover)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct afu *afu = cfg->afu;\r\nstruct ctx_info *ctxi = NULL;\r\nstruct mutex *mutex = &cfg->ctx_recovery_mutex;\r\nu64 ctxid = DECODE_CTXID(recover->context_id),\r\nrctxid = recover->context_id;\r\nlong reg;\r\nint lretry = 20;\r\nint rc = 0;\r\natomic_inc(&cfg->recovery_threads);\r\nup_read(&cfg->ioctl_rwsem);\r\nrc = mutex_lock_interruptible(mutex);\r\ndown_read(&cfg->ioctl_rwsem);\r\nif (rc)\r\ngoto out;\r\nrc = check_state(cfg);\r\nif (rc) {\r\ndev_err(dev, "%s: Failed state! rc=%d\n", __func__, rc);\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\ndev_dbg(dev, "%s: reason 0x%016llX rctxid=%016llX\n",\r\n__func__, recover->reason, rctxid);\r\nretry:\r\nctxi = get_context(cfg, rctxid, lli, CTX_CTRL_ERR_FALLBACK);\r\nif (unlikely(!ctxi)) {\r\ndev_dbg(dev, "%s: Bad context! (%llu)\n", __func__, ctxid);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (ctxi->err_recovery_active) {\r\nretry_recover:\r\nrc = recover_context(cfg, ctxi);\r\nif (unlikely(rc)) {\r\ndev_err(dev, "%s: Recovery failed for context %llu (rc=%d)\n",\r\n__func__, ctxid, rc);\r\nif ((rc == -ENODEV) &&\r\n((atomic_read(&cfg->recovery_threads) > 1) ||\r\n(lretry--))) {\r\ndev_dbg(dev, "%s: Going to try again!\n",\r\n__func__);\r\nmutex_unlock(mutex);\r\nmsleep(100);\r\nrc = mutex_lock_interruptible(mutex);\r\nif (rc)\r\ngoto out;\r\ngoto retry_recover;\r\n}\r\ngoto out;\r\n}\r\nctxi->err_recovery_active = false;\r\nrecover->context_id = ctxi->ctxid;\r\nrecover->adap_fd = ctxi->lfd;\r\nrecover->mmio_size = sizeof(afu->afu_map->hosts[0].harea);\r\nrecover->hdr.return_flags |=\r\nDK_CXLFLASH_RECOVER_AFU_CONTEXT_RESET;\r\ngoto out;\r\n}\r\nreg = readq_be(&afu->ctrl_map->mbox_r);\r\nif (reg == -1) {\r\ndev_dbg(dev, "%s: MMIO fail, wait for recovery.\n", __func__);\r\nput_context(ctxi);\r\nctxi = NULL;\r\nssleep(1);\r\nrc = check_state(cfg);\r\nif (unlikely(rc))\r\ngoto out;\r\ngoto retry;\r\n}\r\ndev_dbg(dev, "%s: MMIO working, no recovery required!\n", __func__);\r\nout:\r\nif (likely(ctxi))\r\nput_context(ctxi);\r\nmutex_unlock(mutex);\r\natomic_dec_if_positive(&cfg->recovery_threads);\r\nreturn rc;\r\n}\r\nstatic int process_sense(struct scsi_device *sdev,\r\nstruct dk_cxlflash_verify *verify)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct glun_info *gli = lli->parent;\r\nu64 prev_lba = gli->max_lba;\r\nstruct scsi_sense_hdr sshdr = { 0 };\r\nint rc = 0;\r\nrc = scsi_normalize_sense((const u8 *)&verify->sense_data,\r\nDK_CXLFLASH_VERIFY_SENSE_LEN, &sshdr);\r\nif (!rc) {\r\ndev_err(dev, "%s: Failed to normalize sense data!\n", __func__);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (sshdr.sense_key) {\r\ncase NO_SENSE:\r\ncase RECOVERED_ERROR:\r\ncase NOT_READY:\r\nbreak;\r\ncase UNIT_ATTENTION:\r\nswitch (sshdr.asc) {\r\ncase 0x29:\r\ncase 0x2A:\r\nrc = read_cap16(sdev, lli);\r\nif (rc) {\r\nrc = -ENODEV;\r\nbreak;\r\n}\r\nif (prev_lba != gli->max_lba)\r\ndev_dbg(dev, "%s: Capacity changed old=%lld "\r\n"new=%lld\n", __func__, prev_lba,\r\ngli->max_lba);\r\nbreak;\r\ncase 0x3F:\r\nscsi_scan_host(cfg->host);\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\nbreak;\r\n}\r\nout:\r\ndev_dbg(dev, "%s: sense_key %x asc %x ascq %x rc %d\n", __func__,\r\nsshdr.sense_key, sshdr.asc, sshdr.ascq, rc);\r\nreturn rc;\r\n}\r\nstatic int cxlflash_disk_verify(struct scsi_device *sdev,\r\nstruct dk_cxlflash_verify *verify)\r\n{\r\nint rc = 0;\r\nstruct ctx_info *ctxi = NULL;\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct glun_info *gli = lli->parent;\r\nstruct sisl_rht_entry *rhte = NULL;\r\nres_hndl_t rhndl = verify->rsrc_handle;\r\nu64 ctxid = DECODE_CTXID(verify->context_id),\r\nrctxid = verify->context_id;\r\nu64 last_lba = 0;\r\ndev_dbg(dev, "%s: ctxid=%llu rhndl=%016llX, hint=%016llX, "\r\n"flags=%016llX\n", __func__, ctxid, verify->rsrc_handle,\r\nverify->hint, verify->hdr.flags);\r\nctxi = get_context(cfg, rctxid, lli, 0);\r\nif (unlikely(!ctxi)) {\r\ndev_dbg(dev, "%s: Bad context! (%llu)\n", __func__, ctxid);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrhte = get_rhte(ctxi, rhndl, lli);\r\nif (unlikely(!rhte)) {\r\ndev_dbg(dev, "%s: Bad resource handle! (%d)\n",\r\n__func__, rhndl);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (verify->hint & DK_CXLFLASH_VERIFY_HINT_SENSE) {\r\nctxi->unavail = true;\r\nmutex_unlock(&ctxi->mutex);\r\nrc = process_sense(sdev, verify);\r\nif (unlikely(rc)) {\r\ndev_err(dev, "%s: Failed to validate sense data (%d)\n",\r\n__func__, rc);\r\nmutex_lock(&ctxi->mutex);\r\nctxi->unavail = false;\r\ngoto out;\r\n}\r\nmutex_lock(&ctxi->mutex);\r\nctxi->unavail = false;\r\n}\r\nswitch (gli->mode) {\r\ncase MODE_PHYSICAL:\r\nlast_lba = gli->max_lba;\r\nbreak;\r\ncase MODE_VIRTUAL:\r\nlast_lba = ((u64)rhte->lxt_cnt * MC_CHUNK_SIZE * gli->blk_len);\r\nlast_lba /= CXLFLASH_BLOCK_SIZE;\r\nlast_lba--;\r\nbreak;\r\ndefault:\r\nWARN(1, "Unsupported LUN mode!");\r\n}\r\nverify->last_lba = last_lba;\r\nout:\r\nif (likely(ctxi))\r\nput_context(ctxi);\r\ndev_dbg(dev, "%s: returning rc=%d llba=%llX\n",\r\n__func__, rc, verify->last_lba);\r\nreturn rc;\r\n}\r\nstatic char *decode_ioctl(int cmd)\r\n{\r\nswitch (cmd) {\r\ncase DK_CXLFLASH_ATTACH:\r\nreturn __stringify_1(DK_CXLFLASH_ATTACH);\r\ncase DK_CXLFLASH_USER_DIRECT:\r\nreturn __stringify_1(DK_CXLFLASH_USER_DIRECT);\r\ncase DK_CXLFLASH_USER_VIRTUAL:\r\nreturn __stringify_1(DK_CXLFLASH_USER_VIRTUAL);\r\ncase DK_CXLFLASH_VLUN_RESIZE:\r\nreturn __stringify_1(DK_CXLFLASH_VLUN_RESIZE);\r\ncase DK_CXLFLASH_RELEASE:\r\nreturn __stringify_1(DK_CXLFLASH_RELEASE);\r\ncase DK_CXLFLASH_DETACH:\r\nreturn __stringify_1(DK_CXLFLASH_DETACH);\r\ncase DK_CXLFLASH_VERIFY:\r\nreturn __stringify_1(DK_CXLFLASH_VERIFY);\r\ncase DK_CXLFLASH_VLUN_CLONE:\r\nreturn __stringify_1(DK_CXLFLASH_VLUN_CLONE);\r\ncase DK_CXLFLASH_RECOVER_AFU:\r\nreturn __stringify_1(DK_CXLFLASH_RECOVER_AFU);\r\ncase DK_CXLFLASH_MANAGE_LUN:\r\nreturn __stringify_1(DK_CXLFLASH_MANAGE_LUN);\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nstatic int cxlflash_disk_direct_open(struct scsi_device *sdev, void *arg)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct afu *afu = cfg->afu;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct glun_info *gli = lli->parent;\r\nstruct dk_cxlflash_udirect *pphys = (struct dk_cxlflash_udirect *)arg;\r\nu64 ctxid = DECODE_CTXID(pphys->context_id),\r\nrctxid = pphys->context_id;\r\nu64 lun_size = 0;\r\nu64 last_lba = 0;\r\nu64 rsrc_handle = -1;\r\nu32 port = CHAN2PORT(sdev->channel);\r\nint rc = 0;\r\nstruct ctx_info *ctxi = NULL;\r\nstruct sisl_rht_entry *rhte = NULL;\r\npr_debug("%s: ctxid=%llu ls=0x%llx\n", __func__, ctxid, lun_size);\r\nrc = cxlflash_lun_attach(gli, MODE_PHYSICAL, false);\r\nif (unlikely(rc)) {\r\ndev_dbg(dev, "%s: Failed to attach to LUN! (PHYSICAL)\n",\r\n__func__);\r\ngoto out;\r\n}\r\nctxi = get_context(cfg, rctxid, lli, 0);\r\nif (unlikely(!ctxi)) {\r\ndev_dbg(dev, "%s: Bad context! (%llu)\n", __func__, ctxid);\r\nrc = -EINVAL;\r\ngoto err1;\r\n}\r\nrhte = rhte_checkout(ctxi, lli);\r\nif (unlikely(!rhte)) {\r\ndev_dbg(dev, "%s: too many opens for this context\n", __func__);\r\nrc = -EMFILE;\r\ngoto err1;\r\n}\r\nrsrc_handle = (rhte - ctxi->rht_start);\r\nrht_format1(rhte, lli->lun_id[sdev->channel], ctxi->rht_perms, port);\r\ncxlflash_afu_sync(afu, ctxid, rsrc_handle, AFU_LW_SYNC);\r\nlast_lba = gli->max_lba;\r\npphys->hdr.return_flags = 0;\r\npphys->last_lba = last_lba;\r\npphys->rsrc_handle = rsrc_handle;\r\nout:\r\nif (likely(ctxi))\r\nput_context(ctxi);\r\ndev_dbg(dev, "%s: returning handle 0x%llx rc=%d llba %lld\n",\r\n__func__, rsrc_handle, rc, last_lba);\r\nreturn rc;\r\nerr1:\r\ncxlflash_lun_detach(gli);\r\ngoto out;\r\n}\r\nstatic int ioctl_common(struct scsi_device *sdev, int cmd)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct llun_info *lli = sdev->hostdata;\r\nint rc = 0;\r\nif (unlikely(!lli)) {\r\ndev_dbg(dev, "%s: Unknown LUN\n", __func__);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = check_state(cfg);\r\nif (unlikely(rc) && (cfg->state == STATE_FAILTERM)) {\r\nswitch (cmd) {\r\ncase DK_CXLFLASH_VLUN_RESIZE:\r\ncase DK_CXLFLASH_RELEASE:\r\ncase DK_CXLFLASH_DETACH:\r\ndev_dbg(dev, "%s: Command override! (%d)\n",\r\n__func__, rc);\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint cxlflash_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\r\n{\r\ntypedef int (*sioctl) (struct scsi_device *, void *);\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct afu *afu = cfg->afu;\r\nstruct dk_cxlflash_hdr *hdr;\r\nchar buf[sizeof(union cxlflash_ioctls)];\r\nsize_t size = 0;\r\nbool known_ioctl = false;\r\nint idx;\r\nint rc = 0;\r\nstruct Scsi_Host *shost = sdev->host;\r\nsioctl do_ioctl = NULL;\r\nstatic const struct {\r\nsize_t size;\r\nsioctl ioctl;\r\n} ioctl_tbl[] = {\r\n{sizeof(struct dk_cxlflash_attach), (sioctl)cxlflash_disk_attach},\r\n{sizeof(struct dk_cxlflash_udirect), cxlflash_disk_direct_open},\r\n{sizeof(struct dk_cxlflash_release), (sioctl)cxlflash_disk_release},\r\n{sizeof(struct dk_cxlflash_detach), (sioctl)cxlflash_disk_detach},\r\n{sizeof(struct dk_cxlflash_verify), (sioctl)cxlflash_disk_verify},\r\n{sizeof(struct dk_cxlflash_recover_afu), (sioctl)cxlflash_afu_recover},\r\n{sizeof(struct dk_cxlflash_manage_lun), (sioctl)cxlflash_manage_lun},\r\n{sizeof(struct dk_cxlflash_uvirtual), cxlflash_disk_virtual_open},\r\n{sizeof(struct dk_cxlflash_resize), (sioctl)cxlflash_vlun_resize},\r\n{sizeof(struct dk_cxlflash_clone), (sioctl)cxlflash_disk_clone},\r\n};\r\ndown_read(&cfg->ioctl_rwsem);\r\nif (afu->internal_lun)\r\nswitch (cmd) {\r\ncase DK_CXLFLASH_RELEASE:\r\ncase DK_CXLFLASH_USER_VIRTUAL:\r\ncase DK_CXLFLASH_VLUN_RESIZE:\r\ncase DK_CXLFLASH_VLUN_CLONE:\r\ndev_dbg(dev, "%s: %s not supported for lun_mode=%d\n",\r\n__func__, decode_ioctl(cmd), afu->internal_lun);\r\nrc = -EINVAL;\r\ngoto cxlflash_ioctl_exit;\r\n}\r\nswitch (cmd) {\r\ncase DK_CXLFLASH_ATTACH:\r\ncase DK_CXLFLASH_USER_DIRECT:\r\ncase DK_CXLFLASH_RELEASE:\r\ncase DK_CXLFLASH_DETACH:\r\ncase DK_CXLFLASH_VERIFY:\r\ncase DK_CXLFLASH_RECOVER_AFU:\r\ncase DK_CXLFLASH_USER_VIRTUAL:\r\ncase DK_CXLFLASH_VLUN_RESIZE:\r\ncase DK_CXLFLASH_VLUN_CLONE:\r\ndev_dbg(dev, "%s: %s (%08X) on dev(%d/%d/%d/%llu)\n",\r\n__func__, decode_ioctl(cmd), cmd, shost->host_no,\r\nsdev->channel, sdev->id, sdev->lun);\r\nrc = ioctl_common(sdev, cmd);\r\nif (unlikely(rc))\r\ngoto cxlflash_ioctl_exit;\r\ncase DK_CXLFLASH_MANAGE_LUN:\r\nknown_ioctl = true;\r\nidx = _IOC_NR(cmd) - _IOC_NR(DK_CXLFLASH_ATTACH);\r\nsize = ioctl_tbl[idx].size;\r\ndo_ioctl = ioctl_tbl[idx].ioctl;\r\nif (likely(do_ioctl))\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\ngoto cxlflash_ioctl_exit;\r\n}\r\nif (unlikely(copy_from_user(&buf, arg, size))) {\r\ndev_err(dev, "%s: copy_from_user() fail! "\r\n"size=%lu cmd=%d (%s) arg=%p\n",\r\n__func__, size, cmd, decode_ioctl(cmd), arg);\r\nrc = -EFAULT;\r\ngoto cxlflash_ioctl_exit;\r\n}\r\nhdr = (struct dk_cxlflash_hdr *)&buf;\r\nif (hdr->version != DK_CXLFLASH_VERSION_0) {\r\ndev_dbg(dev, "%s: Version %u not supported for %s\n",\r\n__func__, hdr->version, decode_ioctl(cmd));\r\nrc = -EINVAL;\r\ngoto cxlflash_ioctl_exit;\r\n}\r\nif (hdr->rsvd[0] || hdr->rsvd[1] || hdr->rsvd[2] || hdr->return_flags) {\r\ndev_dbg(dev, "%s: Reserved/rflags populated!\n", __func__);\r\nrc = -EINVAL;\r\ngoto cxlflash_ioctl_exit;\r\n}\r\nrc = do_ioctl(sdev, (void *)&buf);\r\nif (likely(!rc))\r\nif (unlikely(copy_to_user(arg, &buf, size))) {\r\ndev_err(dev, "%s: copy_to_user() fail! "\r\n"size=%lu cmd=%d (%s) arg=%p\n",\r\n__func__, size, cmd, decode_ioctl(cmd), arg);\r\nrc = -EFAULT;\r\n}\r\ncxlflash_ioctl_exit:\r\nup_read(&cfg->ioctl_rwsem);\r\nif (unlikely(rc && known_ioctl))\r\ndev_err(dev, "%s: ioctl %s (%08X) on dev(%d/%d/%d/%llu) "\r\n"returned rc %d\n", __func__,\r\ndecode_ioctl(cmd), cmd, shost->host_no,\r\nsdev->channel, sdev->id, sdev->lun, rc);\r\nelse\r\ndev_dbg(dev, "%s: ioctl %s (%08X) on dev(%d/%d/%d/%llu) "\r\n"returned rc %d\n", __func__, decode_ioctl(cmd),\r\ncmd, shost->host_no, sdev->channel, sdev->id,\r\nsdev->lun, rc);\r\nreturn rc;\r\n}
