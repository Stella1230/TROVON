int\r\ni915_verify_lists(struct drm_device *dev)\r\n{\r\nstatic int warned;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct drm_i915_gem_object *obj;\r\nstruct intel_engine_cs *engine;\r\nint err = 0;\r\nif (warned)\r\nreturn 0;\r\nfor_each_engine(engine, dev_priv) {\r\nlist_for_each_entry(obj, &engine->active_list,\r\nengine_list[engine->id]) {\r\nif (obj->base.dev != dev ||\r\n!atomic_read(&obj->base.refcount.refcount)) {\r\nDRM_ERROR("%s: freed active obj %p\n",\r\nengine->name, obj);\r\nerr++;\r\nbreak;\r\n} else if (!obj->active ||\r\nobj->last_read_req[engine->id] == NULL) {\r\nDRM_ERROR("%s: invalid active obj %p\n",\r\nengine->name, obj);\r\nerr++;\r\n} else if (obj->base.write_domain) {\r\nDRM_ERROR("%s: invalid write obj %p (w %x)\n",\r\nengine->name,\r\nobj, obj->base.write_domain);\r\nerr++;\r\n}\r\n}\r\n}\r\nreturn warned = err;\r\n}
