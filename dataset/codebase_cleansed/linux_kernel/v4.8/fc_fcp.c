static struct fc_fcp_pkt *fc_fcp_pkt_alloc(struct fc_lport *lport, gfp_t gfp)\r\n{\r\nstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\r\nstruct fc_fcp_pkt *fsp;\r\nfsp = mempool_alloc(si->scsi_pkt_pool, gfp);\r\nif (fsp) {\r\nmemset(fsp, 0, sizeof(*fsp));\r\nfsp->lp = lport;\r\nfsp->xfer_ddp = FC_XID_UNKNOWN;\r\natomic_set(&fsp->ref_cnt, 1);\r\ninit_timer(&fsp->timer);\r\nfsp->timer.data = (unsigned long)fsp;\r\nINIT_LIST_HEAD(&fsp->list);\r\nspin_lock_init(&fsp->scsi_pkt_lock);\r\n} else {\r\nper_cpu_ptr(lport->stats, get_cpu())->FcpPktAllocFails++;\r\nput_cpu();\r\n}\r\nreturn fsp;\r\n}\r\nstatic void fc_fcp_pkt_release(struct fc_fcp_pkt *fsp)\r\n{\r\nif (atomic_dec_and_test(&fsp->ref_cnt)) {\r\nstruct fc_fcp_internal *si = fc_get_scsi_internal(fsp->lp);\r\nmempool_free(fsp, si->scsi_pkt_pool);\r\n}\r\n}\r\nstatic void fc_fcp_pkt_hold(struct fc_fcp_pkt *fsp)\r\n{\r\natomic_inc(&fsp->ref_cnt);\r\n}\r\nstatic void fc_fcp_pkt_destroy(struct fc_seq *seq, void *fsp)\r\n{\r\nfc_fcp_pkt_release(fsp);\r\n}\r\nstatic inline int fc_fcp_lock_pkt(struct fc_fcp_pkt *fsp)\r\n{\r\nspin_lock_bh(&fsp->scsi_pkt_lock);\r\nif (fsp->state & FC_SRB_COMPL) {\r\nspin_unlock_bh(&fsp->scsi_pkt_lock);\r\nreturn -EPERM;\r\n}\r\nfc_fcp_pkt_hold(fsp);\r\nreturn 0;\r\n}\r\nstatic inline void fc_fcp_unlock_pkt(struct fc_fcp_pkt *fsp)\r\n{\r\nspin_unlock_bh(&fsp->scsi_pkt_lock);\r\nfc_fcp_pkt_release(fsp);\r\n}\r\nstatic void fc_fcp_timer_set(struct fc_fcp_pkt *fsp, unsigned long delay)\r\n{\r\nif (!(fsp->state & FC_SRB_COMPL))\r\nmod_timer(&fsp->timer, jiffies + delay);\r\n}\r\nstatic int fc_fcp_send_abort(struct fc_fcp_pkt *fsp)\r\n{\r\nif (!fsp->seq_ptr)\r\nreturn -EINVAL;\r\nper_cpu_ptr(fsp->lp->stats, get_cpu())->FcpPktAborts++;\r\nput_cpu();\r\nfsp->state |= FC_SRB_ABORT_PENDING;\r\nreturn fsp->lp->tt.seq_exch_abort(fsp->seq_ptr, 0);\r\n}\r\nstatic void fc_fcp_retry_cmd(struct fc_fcp_pkt *fsp)\r\n{\r\nif (fsp->seq_ptr) {\r\nfsp->lp->tt.exch_done(fsp->seq_ptr);\r\nfsp->seq_ptr = NULL;\r\n}\r\nfsp->state &= ~FC_SRB_ABORT_PENDING;\r\nfsp->io_status = 0;\r\nfsp->status_code = FC_ERROR;\r\nfc_fcp_complete_locked(fsp);\r\n}\r\nvoid fc_fcp_ddp_setup(struct fc_fcp_pkt *fsp, u16 xid)\r\n{\r\nstruct fc_lport *lport;\r\nlport = fsp->lp;\r\nif ((fsp->req_flags & FC_SRB_READ) &&\r\n(lport->lro_enabled) && (lport->tt.ddp_setup)) {\r\nif (lport->tt.ddp_setup(lport, xid, scsi_sglist(fsp->cmd),\r\nscsi_sg_count(fsp->cmd)))\r\nfsp->xfer_ddp = xid;\r\n}\r\n}\r\nvoid fc_fcp_ddp_done(struct fc_fcp_pkt *fsp)\r\n{\r\nstruct fc_lport *lport;\r\nif (!fsp)\r\nreturn;\r\nif (fsp->xfer_ddp == FC_XID_UNKNOWN)\r\nreturn;\r\nlport = fsp->lp;\r\nif (lport->tt.ddp_done) {\r\nfsp->xfer_len = lport->tt.ddp_done(lport, fsp->xfer_ddp);\r\nfsp->xfer_ddp = FC_XID_UNKNOWN;\r\n}\r\n}\r\nstatic void fc_fcp_can_queue_ramp_up(struct fc_lport *lport)\r\n{\r\nstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\r\nunsigned long flags;\r\nint can_queue;\r\nspin_lock_irqsave(lport->host->host_lock, flags);\r\nif (si->last_can_queue_ramp_up_time &&\r\n(time_before(jiffies, si->last_can_queue_ramp_up_time +\r\nFC_CAN_QUEUE_PERIOD)))\r\ngoto unlock;\r\nif (time_before(jiffies, si->last_can_queue_ramp_down_time +\r\nFC_CAN_QUEUE_PERIOD))\r\ngoto unlock;\r\nsi->last_can_queue_ramp_up_time = jiffies;\r\ncan_queue = lport->host->can_queue << 1;\r\nif (can_queue >= si->max_can_queue) {\r\ncan_queue = si->max_can_queue;\r\nsi->last_can_queue_ramp_down_time = 0;\r\n}\r\nlport->host->can_queue = can_queue;\r\nshost_printk(KERN_ERR, lport->host, "libfc: increased "\r\n"can_queue to %d.\n", can_queue);\r\nunlock:\r\nspin_unlock_irqrestore(lport->host->host_lock, flags);\r\n}\r\nstatic void fc_fcp_can_queue_ramp_down(struct fc_lport *lport)\r\n{\r\nstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\r\nunsigned long flags;\r\nint can_queue;\r\nspin_lock_irqsave(lport->host->host_lock, flags);\r\nif (si->last_can_queue_ramp_down_time &&\r\n(time_before(jiffies, si->last_can_queue_ramp_down_time +\r\nFC_CAN_QUEUE_PERIOD)))\r\ngoto unlock;\r\nsi->last_can_queue_ramp_down_time = jiffies;\r\ncan_queue = lport->host->can_queue;\r\ncan_queue >>= 1;\r\nif (!can_queue)\r\ncan_queue = 1;\r\nlport->host->can_queue = can_queue;\r\nshost_printk(KERN_ERR, lport->host, "libfc: Could not allocate frame.\n"\r\n"Reducing can_queue to %d.\n", can_queue);\r\nunlock:\r\nspin_unlock_irqrestore(lport->host->host_lock, flags);\r\n}\r\nstatic inline struct fc_frame *fc_fcp_frame_alloc(struct fc_lport *lport,\r\nsize_t len)\r\n{\r\nstruct fc_frame *fp;\r\nfp = fc_frame_alloc(lport, len);\r\nif (likely(fp))\r\nreturn fp;\r\nper_cpu_ptr(lport->stats, get_cpu())->FcpFrameAllocFails++;\r\nput_cpu();\r\nfc_fcp_can_queue_ramp_down(lport);\r\nreturn NULL;\r\n}\r\nstatic void fc_fcp_recv_data(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\r\n{\r\nstruct scsi_cmnd *sc = fsp->cmd;\r\nstruct fc_lport *lport = fsp->lp;\r\nstruct fc_stats *stats;\r\nstruct fc_frame_header *fh;\r\nsize_t start_offset;\r\nsize_t offset;\r\nu32 crc;\r\nu32 copy_len = 0;\r\nsize_t len;\r\nvoid *buf;\r\nstruct scatterlist *sg;\r\nu32 nents;\r\nu8 host_bcode = FC_COMPLETE;\r\nfh = fc_frame_header_get(fp);\r\noffset = ntohl(fh->fh_parm_offset);\r\nstart_offset = offset;\r\nlen = fr_len(fp) - sizeof(*fh);\r\nbuf = fc_frame_payload_get(fp, 0);\r\nif (fsp->xfer_ddp != FC_XID_UNKNOWN) {\r\nfc_fcp_ddp_done(fsp);\r\nFC_FCP_DBG(fsp, "DDP I/O in fc_fcp_recv_data set ERROR\n");\r\nhost_bcode = FC_ERROR;\r\ngoto err;\r\n}\r\nif (offset + len > fsp->data_len) {\r\nif ((fr_flags(fp) & FCPHF_CRC_UNCHECKED) &&\r\nfc_frame_crc_check(fp))\r\ngoto crc_err;\r\nFC_FCP_DBG(fsp, "data received past end. len %zx offset %zx "\r\n"data_len %x\n", len, offset, fsp->data_len);\r\nhost_bcode = FC_DATA_OVRRUN;\r\ngoto err;\r\n}\r\nif (offset != fsp->xfer_len)\r\nfsp->state |= FC_SRB_DISCONTIG;\r\nsg = scsi_sglist(sc);\r\nnents = scsi_sg_count(sc);\r\nif (!(fr_flags(fp) & FCPHF_CRC_UNCHECKED)) {\r\ncopy_len = fc_copy_buffer_to_sglist(buf, len, sg, &nents,\r\n&offset, NULL);\r\n} else {\r\ncrc = crc32(~0, (u8 *) fh, sizeof(*fh));\r\ncopy_len = fc_copy_buffer_to_sglist(buf, len, sg, &nents,\r\n&offset, &crc);\r\nbuf = fc_frame_payload_get(fp, 0);\r\nif (len % 4)\r\ncrc = crc32(crc, buf + len, 4 - (len % 4));\r\nif (~crc != le32_to_cpu(fr_crc(fp))) {\r\ncrc_err:\r\nstats = per_cpu_ptr(lport->stats, get_cpu());\r\nstats->ErrorFrames++;\r\nif (stats->InvalidCRCCount++ < FC_MAX_ERROR_CNT)\r\nprintk(KERN_WARNING "libfc: CRC error on data "\r\n"frame for port (%6.6x)\n",\r\nlport->port_id);\r\nput_cpu();\r\nif (fsp->state & FC_SRB_DISCONTIG) {\r\nhost_bcode = FC_CRC_ERROR;\r\ngoto err;\r\n}\r\nreturn;\r\n}\r\n}\r\nif (fsp->xfer_contig_end == start_offset)\r\nfsp->xfer_contig_end += copy_len;\r\nfsp->xfer_len += copy_len;\r\nif (unlikely(fsp->state & FC_SRB_RCV_STATUS) &&\r\nfsp->xfer_len == fsp->data_len - fsp->scsi_resid)\r\nfc_fcp_complete_locked(fsp);\r\nreturn;\r\nerr:\r\nfc_fcp_recovery(fsp, host_bcode);\r\n}\r\nstatic int fc_fcp_send_data(struct fc_fcp_pkt *fsp, struct fc_seq *seq,\r\nsize_t offset, size_t seq_blen)\r\n{\r\nstruct fc_exch *ep;\r\nstruct scsi_cmnd *sc;\r\nstruct scatterlist *sg;\r\nstruct fc_frame *fp = NULL;\r\nstruct fc_lport *lport = fsp->lp;\r\nstruct page *page;\r\nsize_t remaining;\r\nsize_t t_blen;\r\nsize_t tlen;\r\nsize_t sg_bytes;\r\nsize_t frame_offset, fh_parm_offset;\r\nsize_t off;\r\nint error;\r\nvoid *data = NULL;\r\nvoid *page_addr;\r\nint using_sg = lport->sg_supp;\r\nu32 f_ctl;\r\nWARN_ON(seq_blen <= 0);\r\nif (unlikely(offset + seq_blen > fsp->data_len)) {\r\nFC_FCP_DBG(fsp, "xfer-ready past end. seq_blen %zx "\r\n"offset %zx\n", seq_blen, offset);\r\nfc_fcp_send_abort(fsp);\r\nreturn 0;\r\n} else if (offset != fsp->xfer_len) {\r\nFC_FCP_DBG(fsp, "xfer-ready non-contiguous. "\r\n"seq_blen %zx offset %zx\n", seq_blen, offset);\r\n}\r\nt_blen = fsp->max_payload;\r\nif (lport->seq_offload) {\r\nt_blen = min(seq_blen, (size_t)lport->lso_max);\r\nFC_FCP_DBG(fsp, "fsp=%p:lso:blen=%zx lso_max=0x%x t_blen=%zx\n",\r\nfsp, seq_blen, lport->lso_max, t_blen);\r\n}\r\nif (t_blen > 512)\r\nt_blen &= ~(512 - 1);\r\nsc = fsp->cmd;\r\nremaining = seq_blen;\r\nfh_parm_offset = frame_offset = offset;\r\ntlen = 0;\r\nseq = lport->tt.seq_start_next(seq);\r\nf_ctl = FC_FC_REL_OFF;\r\nWARN_ON(!seq);\r\nsg = scsi_sglist(sc);\r\nwhile (remaining > 0 && sg) {\r\nif (offset >= sg->length) {\r\noffset -= sg->length;\r\nsg = sg_next(sg);\r\ncontinue;\r\n}\r\nif (!fp) {\r\ntlen = min(t_blen, remaining);\r\nif (tlen % 4)\r\nusing_sg = 0;\r\nfp = fc_frame_alloc(lport, using_sg ? 0 : tlen);\r\nif (!fp)\r\nreturn -ENOMEM;\r\ndata = fc_frame_header_get(fp) + 1;\r\nfh_parm_offset = frame_offset;\r\nfr_max_payload(fp) = fsp->max_payload;\r\n}\r\noff = offset + sg->offset;\r\nsg_bytes = min(tlen, sg->length - offset);\r\nsg_bytes = min(sg_bytes,\r\n(size_t) (PAGE_SIZE - (off & ~PAGE_MASK)));\r\npage = sg_page(sg) + (off >> PAGE_SHIFT);\r\nif (using_sg) {\r\nget_page(page);\r\nskb_fill_page_desc(fp_skb(fp),\r\nskb_shinfo(fp_skb(fp))->nr_frags,\r\npage, off & ~PAGE_MASK, sg_bytes);\r\nfp_skb(fp)->data_len += sg_bytes;\r\nfr_len(fp) += sg_bytes;\r\nfp_skb(fp)->truesize += PAGE_SIZE;\r\n} else {\r\npage_addr = kmap_atomic(page);\r\nmemcpy(data, (char *)page_addr + (off & ~PAGE_MASK),\r\nsg_bytes);\r\nkunmap_atomic(page_addr);\r\ndata += sg_bytes;\r\n}\r\noffset += sg_bytes;\r\nframe_offset += sg_bytes;\r\ntlen -= sg_bytes;\r\nremaining -= sg_bytes;\r\nif ((skb_shinfo(fp_skb(fp))->nr_frags < FC_FRAME_SG_LEN) &&\r\n(tlen))\r\ncontinue;\r\nif (remaining == 0)\r\nf_ctl |= FC_FC_SEQ_INIT | FC_FC_END_SEQ;\r\nep = fc_seq_exch(seq);\r\nfc_fill_fc_hdr(fp, FC_RCTL_DD_SOL_DATA, ep->did, ep->sid,\r\nFC_TYPE_FCP, f_ctl, fh_parm_offset);\r\nerror = lport->tt.seq_send(lport, seq, fp);\r\nif (error) {\r\nWARN_ON(1);\r\nreturn error;\r\n}\r\nfp = NULL;\r\n}\r\nfsp->xfer_len += seq_blen;\r\nreturn 0;\r\n}\r\nstatic void fc_fcp_abts_resp(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\r\n{\r\nint ba_done = 1;\r\nstruct fc_ba_rjt *brp;\r\nstruct fc_frame_header *fh;\r\nfh = fc_frame_header_get(fp);\r\nswitch (fh->fh_r_ctl) {\r\ncase FC_RCTL_BA_ACC:\r\nbreak;\r\ncase FC_RCTL_BA_RJT:\r\nbrp = fc_frame_payload_get(fp, sizeof(*brp));\r\nif (brp && brp->br_reason == FC_BA_RJT_LOG_ERR)\r\nbreak;\r\ndefault:\r\nba_done = 0;\r\n}\r\nif (ba_done) {\r\nfsp->state |= FC_SRB_ABORTED;\r\nfsp->state &= ~FC_SRB_ABORT_PENDING;\r\nif (fsp->wait_for_comp)\r\ncomplete(&fsp->tm_done);\r\nelse\r\nfc_fcp_complete_locked(fsp);\r\n}\r\n}\r\nstatic void fc_fcp_recv(struct fc_seq *seq, struct fc_frame *fp, void *arg)\r\n{\r\nstruct fc_fcp_pkt *fsp = (struct fc_fcp_pkt *)arg;\r\nstruct fc_lport *lport = fsp->lp;\r\nstruct fc_frame_header *fh;\r\nstruct fcp_txrdy *dd;\r\nu8 r_ctl;\r\nint rc = 0;\r\nif (IS_ERR(fp)) {\r\nfc_fcp_error(fsp, fp);\r\nreturn;\r\n}\r\nfh = fc_frame_header_get(fp);\r\nr_ctl = fh->fh_r_ctl;\r\nif (lport->state != LPORT_ST_READY)\r\ngoto out;\r\nif (fc_fcp_lock_pkt(fsp))\r\ngoto out;\r\nif (fh->fh_type == FC_TYPE_BLS) {\r\nfc_fcp_abts_resp(fsp, fp);\r\ngoto unlock;\r\n}\r\nif (fsp->state & (FC_SRB_ABORTED | FC_SRB_ABORT_PENDING))\r\ngoto unlock;\r\nif (r_ctl == FC_RCTL_DD_DATA_DESC) {\r\nWARN_ON(fr_flags(fp) & FCPHF_CRC_UNCHECKED);\r\ndd = fc_frame_payload_get(fp, sizeof(*dd));\r\nWARN_ON(!dd);\r\nrc = fc_fcp_send_data(fsp, seq,\r\n(size_t) ntohl(dd->ft_data_ro),\r\n(size_t) ntohl(dd->ft_burst_len));\r\nif (!rc)\r\nseq->rec_data = fsp->xfer_len;\r\n} else if (r_ctl == FC_RCTL_DD_SOL_DATA) {\r\nWARN_ON(fr_len(fp) < sizeof(*fh));\r\nfc_fcp_recv_data(fsp, fp);\r\nseq->rec_data = fsp->xfer_contig_end;\r\n} else if (r_ctl == FC_RCTL_DD_CMD_STATUS) {\r\nWARN_ON(fr_flags(fp) & FCPHF_CRC_UNCHECKED);\r\nfc_fcp_resp(fsp, fp);\r\n} else {\r\nFC_FCP_DBG(fsp, "unexpected frame. r_ctl %x\n", r_ctl);\r\n}\r\nunlock:\r\nfc_fcp_unlock_pkt(fsp);\r\nout:\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_fcp_resp(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh;\r\nstruct fcp_resp *fc_rp;\r\nstruct fcp_resp_ext *rp_ex;\r\nstruct fcp_resp_rsp_info *fc_rp_info;\r\nu32 plen;\r\nu32 expected_len;\r\nu32 respl = 0;\r\nu32 snsl = 0;\r\nu8 flags = 0;\r\nplen = fr_len(fp);\r\nfh = (struct fc_frame_header *)fr_hdr(fp);\r\nif (unlikely(plen < sizeof(*fh) + sizeof(*fc_rp)))\r\ngoto len_err;\r\nplen -= sizeof(*fh);\r\nfc_rp = (struct fcp_resp *)(fh + 1);\r\nfsp->cdb_status = fc_rp->fr_status;\r\nflags = fc_rp->fr_flags;\r\nfsp->scsi_comp_flags = flags;\r\nexpected_len = fsp->data_len;\r\nfc_fcp_ddp_done(fsp);\r\nif (unlikely((flags & ~FCP_CONF_REQ) || fc_rp->fr_status)) {\r\nrp_ex = (void *)(fc_rp + 1);\r\nif (flags & (FCP_RSP_LEN_VAL | FCP_SNS_LEN_VAL)) {\r\nif (plen < sizeof(*fc_rp) + sizeof(*rp_ex))\r\ngoto len_err;\r\nfc_rp_info = (struct fcp_resp_rsp_info *)(rp_ex + 1);\r\nif (flags & FCP_RSP_LEN_VAL) {\r\nrespl = ntohl(rp_ex->fr_rsp_len);\r\nif ((respl != FCP_RESP_RSP_INFO_LEN4) &&\r\n(respl != FCP_RESP_RSP_INFO_LEN8))\r\ngoto len_err;\r\nif (fsp->wait_for_comp) {\r\nfsp->cdb_status = fc_rp_info->rsp_code;\r\ncomplete(&fsp->tm_done);\r\nreturn;\r\n}\r\n}\r\nif (flags & FCP_SNS_LEN_VAL) {\r\nsnsl = ntohl(rp_ex->fr_sns_len);\r\nif (snsl > SCSI_SENSE_BUFFERSIZE)\r\nsnsl = SCSI_SENSE_BUFFERSIZE;\r\nmemcpy(fsp->cmd->sense_buffer,\r\n(char *)fc_rp_info + respl, snsl);\r\n}\r\n}\r\nif (flags & (FCP_RESID_UNDER | FCP_RESID_OVER)) {\r\nif (plen < sizeof(*fc_rp) + sizeof(rp_ex->fr_resid))\r\ngoto len_err;\r\nif (flags & FCP_RESID_UNDER) {\r\nfsp->scsi_resid = ntohl(rp_ex->fr_resid);\r\nif (!(flags & FCP_SNS_LEN_VAL) &&\r\n(fc_rp->fr_status == 0) &&\r\n(scsi_bufflen(fsp->cmd) -\r\nfsp->scsi_resid) < fsp->cmd->underflow)\r\ngoto err;\r\nexpected_len -= fsp->scsi_resid;\r\n} else {\r\nfsp->status_code = FC_ERROR;\r\n}\r\n}\r\n}\r\nfsp->state |= FC_SRB_RCV_STATUS;\r\nif (unlikely(fsp->cdb_status == SAM_STAT_GOOD &&\r\nfsp->xfer_len != expected_len)) {\r\nif (fsp->xfer_len < expected_len) {\r\nfc_fcp_timer_set(fsp, 2);\r\nreturn;\r\n}\r\nfsp->status_code = FC_DATA_OVRRUN;\r\nFC_FCP_DBG(fsp, "tgt %6.6x xfer len %zx greater than expected, "\r\n"len %x, data len %x\n",\r\nfsp->rport->port_id,\r\nfsp->xfer_len, expected_len, fsp->data_len);\r\n}\r\nfc_fcp_complete_locked(fsp);\r\nreturn;\r\nlen_err:\r\nFC_FCP_DBG(fsp, "short FCP response. flags 0x%x len %u respl %u "\r\n"snsl %u\n", flags, fr_len(fp), respl, snsl);\r\nerr:\r\nfsp->status_code = FC_ERROR;\r\nfc_fcp_complete_locked(fsp);\r\n}\r\nstatic void fc_fcp_complete_locked(struct fc_fcp_pkt *fsp)\r\n{\r\nstruct fc_lport *lport = fsp->lp;\r\nstruct fc_seq *seq;\r\nstruct fc_exch *ep;\r\nu32 f_ctl;\r\nif (fsp->state & FC_SRB_ABORT_PENDING)\r\nreturn;\r\nif (fsp->state & FC_SRB_ABORTED) {\r\nif (!fsp->status_code)\r\nfsp->status_code = FC_CMD_ABORTED;\r\n} else {\r\nif (fsp->cdb_status == SAM_STAT_GOOD &&\r\nfsp->xfer_len < fsp->data_len && !fsp->io_status &&\r\n(!(fsp->scsi_comp_flags & FCP_RESID_UNDER) ||\r\nfsp->xfer_len < fsp->data_len - fsp->scsi_resid))\r\nfsp->status_code = FC_DATA_UNDRUN;\r\n}\r\nseq = fsp->seq_ptr;\r\nif (seq) {\r\nfsp->seq_ptr = NULL;\r\nif (unlikely(fsp->scsi_comp_flags & FCP_CONF_REQ)) {\r\nstruct fc_frame *conf_frame;\r\nstruct fc_seq *csp;\r\ncsp = lport->tt.seq_start_next(seq);\r\nconf_frame = fc_fcp_frame_alloc(fsp->lp, 0);\r\nif (conf_frame) {\r\nf_ctl = FC_FC_SEQ_INIT;\r\nf_ctl |= FC_FC_LAST_SEQ | FC_FC_END_SEQ;\r\nep = fc_seq_exch(seq);\r\nfc_fill_fc_hdr(conf_frame, FC_RCTL_DD_SOL_CTL,\r\nep->did, ep->sid,\r\nFC_TYPE_FCP, f_ctl, 0);\r\nlport->tt.seq_send(lport, csp, conf_frame);\r\n}\r\n}\r\nlport->tt.exch_done(seq);\r\n}\r\nif (fsp->cmd)\r\nfc_io_compl(fsp);\r\n}\r\nstatic void fc_fcp_cleanup_cmd(struct fc_fcp_pkt *fsp, int error)\r\n{\r\nstruct fc_lport *lport = fsp->lp;\r\nif (fsp->seq_ptr) {\r\nlport->tt.exch_done(fsp->seq_ptr);\r\nfsp->seq_ptr = NULL;\r\n}\r\nfsp->status_code = error;\r\n}\r\nstatic void fc_fcp_cleanup_each_cmd(struct fc_lport *lport, unsigned int id,\r\nunsigned int lun, int error)\r\n{\r\nstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\r\nstruct fc_fcp_pkt *fsp;\r\nstruct scsi_cmnd *sc_cmd;\r\nunsigned long flags;\r\nspin_lock_irqsave(&si->scsi_queue_lock, flags);\r\nrestart:\r\nlist_for_each_entry(fsp, &si->scsi_pkt_queue, list) {\r\nsc_cmd = fsp->cmd;\r\nif (id != -1 && scmd_id(sc_cmd) != id)\r\ncontinue;\r\nif (lun != -1 && sc_cmd->device->lun != lun)\r\ncontinue;\r\nfc_fcp_pkt_hold(fsp);\r\nspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\r\nspin_lock_bh(&fsp->scsi_pkt_lock);\r\nif (!(fsp->state & FC_SRB_COMPL)) {\r\nfsp->state |= FC_SRB_COMPL;\r\nspin_unlock_bh(&fsp->scsi_pkt_lock);\r\nfc_fcp_cleanup_cmd(fsp, error);\r\nspin_lock_bh(&fsp->scsi_pkt_lock);\r\nfc_io_compl(fsp);\r\n}\r\nspin_unlock_bh(&fsp->scsi_pkt_lock);\r\nfc_fcp_pkt_release(fsp);\r\nspin_lock_irqsave(&si->scsi_queue_lock, flags);\r\ngoto restart;\r\n}\r\nspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\r\n}\r\nstatic void fc_fcp_abort_io(struct fc_lport *lport)\r\n{\r\nfc_fcp_cleanup_each_cmd(lport, -1, -1, FC_HRD_ERROR);\r\n}\r\nstatic int fc_fcp_pkt_send(struct fc_lport *lport, struct fc_fcp_pkt *fsp)\r\n{\r\nstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\r\nunsigned long flags;\r\nint rc;\r\nfsp->cmd->SCp.ptr = (char *)fsp;\r\nfsp->cdb_cmd.fc_dl = htonl(fsp->data_len);\r\nfsp->cdb_cmd.fc_flags = fsp->req_flags & ~FCP_CFL_LEN_MASK;\r\nint_to_scsilun(fsp->cmd->device->lun, &fsp->cdb_cmd.fc_lun);\r\nmemcpy(fsp->cdb_cmd.fc_cdb, fsp->cmd->cmnd, fsp->cmd->cmd_len);\r\nspin_lock_irqsave(&si->scsi_queue_lock, flags);\r\nlist_add_tail(&fsp->list, &si->scsi_pkt_queue);\r\nspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\r\nrc = lport->tt.fcp_cmd_send(lport, fsp, fc_fcp_recv);\r\nif (unlikely(rc)) {\r\nspin_lock_irqsave(&si->scsi_queue_lock, flags);\r\nfsp->cmd->SCp.ptr = NULL;\r\nlist_del(&fsp->list);\r\nspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\r\n}\r\nreturn rc;\r\n}\r\nstatic inline unsigned int get_fsp_rec_tov(struct fc_fcp_pkt *fsp)\r\n{\r\nstruct fc_rport_libfc_priv *rpriv = fsp->rport->dd_data;\r\nreturn msecs_to_jiffies(rpriv->e_d_tov) + HZ;\r\n}\r\nstatic int fc_fcp_cmd_send(struct fc_lport *lport, struct fc_fcp_pkt *fsp,\r\nvoid (*resp)(struct fc_seq *,\r\nstruct fc_frame *fp,\r\nvoid *arg))\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_seq *seq;\r\nstruct fc_rport *rport;\r\nstruct fc_rport_libfc_priv *rpriv;\r\nconst size_t len = sizeof(fsp->cdb_cmd);\r\nint rc = 0;\r\nif (fc_fcp_lock_pkt(fsp))\r\nreturn 0;\r\nfp = fc_fcp_frame_alloc(lport, sizeof(fsp->cdb_cmd));\r\nif (!fp) {\r\nrc = -1;\r\ngoto unlock;\r\n}\r\nmemcpy(fc_frame_payload_get(fp, len), &fsp->cdb_cmd, len);\r\nfr_fsp(fp) = fsp;\r\nrport = fsp->rport;\r\nfsp->max_payload = rport->maxframe_size;\r\nrpriv = rport->dd_data;\r\nfc_fill_fc_hdr(fp, FC_RCTL_DD_UNSOL_CMD, rport->port_id,\r\nrpriv->local_port->port_id, FC_TYPE_FCP,\r\nFC_FCTL_REQ, 0);\r\nseq = lport->tt.exch_seq_send(lport, fp, resp, fc_fcp_pkt_destroy,\r\nfsp, 0);\r\nif (!seq) {\r\nrc = -1;\r\ngoto unlock;\r\n}\r\nfsp->seq_ptr = seq;\r\nfc_fcp_pkt_hold(fsp);\r\nsetup_timer(&fsp->timer, fc_fcp_timeout, (unsigned long)fsp);\r\nif (rpriv->flags & FC_RP_FLAGS_REC_SUPPORTED)\r\nfc_fcp_timer_set(fsp, get_fsp_rec_tov(fsp));\r\nunlock:\r\nfc_fcp_unlock_pkt(fsp);\r\nreturn rc;\r\n}\r\nstatic void fc_fcp_error(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\r\n{\r\nint error = PTR_ERR(fp);\r\nif (fc_fcp_lock_pkt(fsp))\r\nreturn;\r\nif (error == -FC_EX_CLOSED) {\r\nfc_fcp_retry_cmd(fsp);\r\ngoto unlock;\r\n}\r\nfsp->state &= ~FC_SRB_ABORT_PENDING;\r\nfsp->status_code = FC_CMD_PLOGO;\r\nfc_fcp_complete_locked(fsp);\r\nunlock:\r\nfc_fcp_unlock_pkt(fsp);\r\n}\r\nstatic int fc_fcp_pkt_abort(struct fc_fcp_pkt *fsp)\r\n{\r\nint rc = FAILED;\r\nunsigned long ticks_left;\r\nif (fc_fcp_send_abort(fsp))\r\nreturn FAILED;\r\ninit_completion(&fsp->tm_done);\r\nfsp->wait_for_comp = 1;\r\nspin_unlock_bh(&fsp->scsi_pkt_lock);\r\nticks_left = wait_for_completion_timeout(&fsp->tm_done,\r\nFC_SCSI_TM_TOV);\r\nspin_lock_bh(&fsp->scsi_pkt_lock);\r\nfsp->wait_for_comp = 0;\r\nif (!ticks_left) {\r\nFC_FCP_DBG(fsp, "target abort cmd failed\n");\r\n} else if (fsp->state & FC_SRB_ABORTED) {\r\nFC_FCP_DBG(fsp, "target abort cmd passed\n");\r\nrc = SUCCESS;\r\nfc_fcp_complete_locked(fsp);\r\n}\r\nreturn rc;\r\n}\r\nstatic void fc_lun_reset_send(unsigned long data)\r\n{\r\nstruct fc_fcp_pkt *fsp = (struct fc_fcp_pkt *)data;\r\nstruct fc_lport *lport = fsp->lp;\r\nif (lport->tt.fcp_cmd_send(lport, fsp, fc_tm_done)) {\r\nif (fsp->recov_retry++ >= FC_MAX_RECOV_RETRY)\r\nreturn;\r\nif (fc_fcp_lock_pkt(fsp))\r\nreturn;\r\nsetup_timer(&fsp->timer, fc_lun_reset_send, (unsigned long)fsp);\r\nfc_fcp_timer_set(fsp, get_fsp_rec_tov(fsp));\r\nfc_fcp_unlock_pkt(fsp);\r\n}\r\n}\r\nstatic int fc_lun_reset(struct fc_lport *lport, struct fc_fcp_pkt *fsp,\r\nunsigned int id, unsigned int lun)\r\n{\r\nint rc;\r\nfsp->cdb_cmd.fc_dl = htonl(fsp->data_len);\r\nfsp->cdb_cmd.fc_tm_flags = FCP_TMF_LUN_RESET;\r\nint_to_scsilun(lun, &fsp->cdb_cmd.fc_lun);\r\nfsp->wait_for_comp = 1;\r\ninit_completion(&fsp->tm_done);\r\nfc_lun_reset_send((unsigned long)fsp);\r\nrc = wait_for_completion_timeout(&fsp->tm_done, FC_SCSI_TM_TOV);\r\nspin_lock_bh(&fsp->scsi_pkt_lock);\r\nfsp->state |= FC_SRB_COMPL;\r\nspin_unlock_bh(&fsp->scsi_pkt_lock);\r\ndel_timer_sync(&fsp->timer);\r\nspin_lock_bh(&fsp->scsi_pkt_lock);\r\nif (fsp->seq_ptr) {\r\nlport->tt.exch_done(fsp->seq_ptr);\r\nfsp->seq_ptr = NULL;\r\n}\r\nfsp->wait_for_comp = 0;\r\nspin_unlock_bh(&fsp->scsi_pkt_lock);\r\nif (!rc) {\r\nFC_SCSI_DBG(lport, "lun reset failed\n");\r\nreturn FAILED;\r\n}\r\nif (fsp->cdb_status != FCP_TMF_CMPL)\r\nreturn FAILED;\r\nFC_SCSI_DBG(lport, "lun reset to lun %u completed\n", lun);\r\nfc_fcp_cleanup_each_cmd(lport, id, lun, FC_CMD_ABORTED);\r\nreturn SUCCESS;\r\n}\r\nstatic void fc_tm_done(struct fc_seq *seq, struct fc_frame *fp, void *arg)\r\n{\r\nstruct fc_fcp_pkt *fsp = arg;\r\nstruct fc_frame_header *fh;\r\nif (IS_ERR(fp)) {\r\nreturn;\r\n}\r\nif (fc_fcp_lock_pkt(fsp))\r\ngoto out;\r\nif (!fsp->seq_ptr || !fsp->wait_for_comp)\r\ngoto out_unlock;\r\nfh = fc_frame_header_get(fp);\r\nif (fh->fh_type != FC_TYPE_BLS)\r\nfc_fcp_resp(fsp, fp);\r\nfsp->seq_ptr = NULL;\r\nfsp->lp->tt.exch_done(seq);\r\nout_unlock:\r\nfc_fcp_unlock_pkt(fsp);\r\nout:\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_fcp_cleanup(struct fc_lport *lport)\r\n{\r\nfc_fcp_cleanup_each_cmd(lport, -1, -1, FC_ERROR);\r\n}\r\nstatic void fc_fcp_timeout(unsigned long data)\r\n{\r\nstruct fc_fcp_pkt *fsp = (struct fc_fcp_pkt *)data;\r\nstruct fc_rport *rport = fsp->rport;\r\nstruct fc_rport_libfc_priv *rpriv = rport->dd_data;\r\nif (fc_fcp_lock_pkt(fsp))\r\nreturn;\r\nif (fsp->cdb_cmd.fc_tm_flags)\r\ngoto unlock;\r\nfsp->state |= FC_SRB_FCP_PROCESSING_TMO;\r\nif (rpriv->flags & FC_RP_FLAGS_REC_SUPPORTED)\r\nfc_fcp_rec(fsp);\r\nelse if (fsp->state & FC_SRB_RCV_STATUS)\r\nfc_fcp_complete_locked(fsp);\r\nelse\r\nfc_fcp_recovery(fsp, FC_TIMED_OUT);\r\nfsp->state &= ~FC_SRB_FCP_PROCESSING_TMO;\r\nunlock:\r\nfc_fcp_unlock_pkt(fsp);\r\n}\r\nstatic void fc_fcp_rec(struct fc_fcp_pkt *fsp)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_frame *fp;\r\nstruct fc_rport *rport;\r\nstruct fc_rport_libfc_priv *rpriv;\r\nlport = fsp->lp;\r\nrport = fsp->rport;\r\nrpriv = rport->dd_data;\r\nif (!fsp->seq_ptr || rpriv->rp_state != RPORT_ST_READY) {\r\nfsp->status_code = FC_HRD_ERROR;\r\nfsp->io_status = 0;\r\nfc_fcp_complete_locked(fsp);\r\nreturn;\r\n}\r\nfp = fc_fcp_frame_alloc(lport, sizeof(struct fc_els_rec));\r\nif (!fp)\r\ngoto retry;\r\nfr_seq(fp) = fsp->seq_ptr;\r\nfc_fill_fc_hdr(fp, FC_RCTL_ELS_REQ, rport->port_id,\r\nrpriv->local_port->port_id, FC_TYPE_ELS,\r\nFC_FCTL_REQ, 0);\r\nif (lport->tt.elsct_send(lport, rport->port_id, fp, ELS_REC,\r\nfc_fcp_rec_resp, fsp,\r\n2 * lport->r_a_tov)) {\r\nfc_fcp_pkt_hold(fsp);\r\nreturn;\r\n}\r\nretry:\r\nif (fsp->recov_retry++ < FC_MAX_RECOV_RETRY)\r\nfc_fcp_timer_set(fsp, get_fsp_rec_tov(fsp));\r\nelse\r\nfc_fcp_recovery(fsp, FC_TIMED_OUT);\r\n}\r\nstatic void fc_fcp_rec_resp(struct fc_seq *seq, struct fc_frame *fp, void *arg)\r\n{\r\nstruct fc_fcp_pkt *fsp = (struct fc_fcp_pkt *)arg;\r\nstruct fc_els_rec_acc *recp;\r\nstruct fc_els_ls_rjt *rjt;\r\nu32 e_stat;\r\nu8 opcode;\r\nu32 offset;\r\nenum dma_data_direction data_dir;\r\nenum fc_rctl r_ctl;\r\nstruct fc_rport_libfc_priv *rpriv;\r\nif (IS_ERR(fp)) {\r\nfc_fcp_rec_error(fsp, fp);\r\nreturn;\r\n}\r\nif (fc_fcp_lock_pkt(fsp))\r\ngoto out;\r\nfsp->recov_retry = 0;\r\nopcode = fc_frame_payload_op(fp);\r\nif (opcode == ELS_LS_RJT) {\r\nrjt = fc_frame_payload_get(fp, sizeof(*rjt));\r\nswitch (rjt->er_reason) {\r\ndefault:\r\nFC_FCP_DBG(fsp, "device %x unexpected REC reject "\r\n"reason %d expl %d\n",\r\nfsp->rport->port_id, rjt->er_reason,\r\nrjt->er_explan);\r\ncase ELS_RJT_UNSUP:\r\nFC_FCP_DBG(fsp, "device does not support REC\n");\r\nrpriv = fsp->rport->dd_data;\r\nrpriv->flags &= ~FC_RP_FLAGS_REC_SUPPORTED;\r\nbreak;\r\ncase ELS_RJT_LOGIC:\r\ncase ELS_RJT_UNAB:\r\nif (rjt->er_explan == ELS_EXPL_OXID_RXID &&\r\nfsp->xfer_len == 0) {\r\nfc_fcp_retry_cmd(fsp);\r\nbreak;\r\n}\r\nfc_fcp_recovery(fsp, FC_ERROR);\r\nbreak;\r\n}\r\n} else if (opcode == ELS_LS_ACC) {\r\nif (fsp->state & FC_SRB_ABORTED)\r\ngoto unlock_out;\r\ndata_dir = fsp->cmd->sc_data_direction;\r\nrecp = fc_frame_payload_get(fp, sizeof(*recp));\r\noffset = ntohl(recp->reca_fc4value);\r\ne_stat = ntohl(recp->reca_e_stat);\r\nif (e_stat & ESB_ST_COMPLETE) {\r\nif (data_dir == DMA_TO_DEVICE) {\r\nr_ctl = FC_RCTL_DD_CMD_STATUS;\r\n} else if (fsp->xfer_contig_end == offset) {\r\nr_ctl = FC_RCTL_DD_CMD_STATUS;\r\n} else {\r\noffset = fsp->xfer_contig_end;\r\nr_ctl = FC_RCTL_DD_SOL_DATA;\r\n}\r\nfc_fcp_srr(fsp, r_ctl, offset);\r\n} else if (e_stat & ESB_ST_SEQ_INIT) {\r\nfc_fcp_timer_set(fsp, get_fsp_rec_tov(fsp));\r\n} else {\r\nr_ctl = FC_RCTL_DD_SOL_DATA;\r\nif (data_dir == DMA_TO_DEVICE) {\r\nr_ctl = FC_RCTL_DD_CMD_STATUS;\r\nif (offset < fsp->data_len)\r\nr_ctl = FC_RCTL_DD_DATA_DESC;\r\n} else if (offset == fsp->xfer_contig_end) {\r\nr_ctl = FC_RCTL_DD_CMD_STATUS;\r\n} else if (fsp->xfer_contig_end < offset) {\r\noffset = fsp->xfer_contig_end;\r\n}\r\nfc_fcp_srr(fsp, r_ctl, offset);\r\n}\r\n}\r\nunlock_out:\r\nfc_fcp_unlock_pkt(fsp);\r\nout:\r\nfc_fcp_pkt_release(fsp);\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_fcp_rec_error(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\r\n{\r\nint error = PTR_ERR(fp);\r\nif (fc_fcp_lock_pkt(fsp))\r\ngoto out;\r\nswitch (error) {\r\ncase -FC_EX_CLOSED:\r\nfc_fcp_retry_cmd(fsp);\r\nbreak;\r\ndefault:\r\nFC_FCP_DBG(fsp, "REC %p fid %6.6x error unexpected error %d\n",\r\nfsp, fsp->rport->port_id, error);\r\nfsp->status_code = FC_CMD_PLOGO;\r\ncase -FC_EX_TIMEOUT:\r\nFC_FCP_DBG(fsp, "REC fid %6.6x error error %d retry %d/%d\n",\r\nfsp->rport->port_id, error, fsp->recov_retry,\r\nFC_MAX_RECOV_RETRY);\r\nif (fsp->recov_retry++ < FC_MAX_RECOV_RETRY)\r\nfc_fcp_rec(fsp);\r\nelse\r\nfc_fcp_recovery(fsp, FC_ERROR);\r\nbreak;\r\n}\r\nfc_fcp_unlock_pkt(fsp);\r\nout:\r\nfc_fcp_pkt_release(fsp);\r\n}\r\nstatic void fc_fcp_recovery(struct fc_fcp_pkt *fsp, u8 code)\r\n{\r\nfsp->status_code = code;\r\nfsp->cdb_status = 0;\r\nfsp->io_status = 0;\r\nfc_fcp_send_abort(fsp);\r\n}\r\nstatic void fc_fcp_srr(struct fc_fcp_pkt *fsp, enum fc_rctl r_ctl, u32 offset)\r\n{\r\nstruct fc_lport *lport = fsp->lp;\r\nstruct fc_rport *rport;\r\nstruct fc_rport_libfc_priv *rpriv;\r\nstruct fc_exch *ep = fc_seq_exch(fsp->seq_ptr);\r\nstruct fc_seq *seq;\r\nstruct fcp_srr *srr;\r\nstruct fc_frame *fp;\r\nunsigned int rec_tov;\r\nrport = fsp->rport;\r\nrpriv = rport->dd_data;\r\nif (!(rpriv->flags & FC_RP_FLAGS_RETRY) ||\r\nrpriv->rp_state != RPORT_ST_READY)\r\ngoto retry;\r\nfp = fc_fcp_frame_alloc(lport, sizeof(*srr));\r\nif (!fp)\r\ngoto retry;\r\nsrr = fc_frame_payload_get(fp, sizeof(*srr));\r\nmemset(srr, 0, sizeof(*srr));\r\nsrr->srr_op = ELS_SRR;\r\nsrr->srr_ox_id = htons(ep->oxid);\r\nsrr->srr_rx_id = htons(ep->rxid);\r\nsrr->srr_r_ctl = r_ctl;\r\nsrr->srr_rel_off = htonl(offset);\r\nfc_fill_fc_hdr(fp, FC_RCTL_ELS4_REQ, rport->port_id,\r\nrpriv->local_port->port_id, FC_TYPE_FCP,\r\nFC_FCTL_REQ, 0);\r\nrec_tov = get_fsp_rec_tov(fsp);\r\nseq = lport->tt.exch_seq_send(lport, fp, fc_fcp_srr_resp,\r\nfc_fcp_pkt_destroy,\r\nfsp, jiffies_to_msecs(rec_tov));\r\nif (!seq)\r\ngoto retry;\r\nfsp->recov_seq = seq;\r\nfsp->xfer_len = offset;\r\nfsp->xfer_contig_end = offset;\r\nfsp->state &= ~FC_SRB_RCV_STATUS;\r\nfc_fcp_pkt_hold(fsp);\r\nreturn;\r\nretry:\r\nfc_fcp_retry_cmd(fsp);\r\n}\r\nstatic void fc_fcp_srr_resp(struct fc_seq *seq, struct fc_frame *fp, void *arg)\r\n{\r\nstruct fc_fcp_pkt *fsp = arg;\r\nstruct fc_frame_header *fh;\r\nif (IS_ERR(fp)) {\r\nfc_fcp_srr_error(fsp, fp);\r\nreturn;\r\n}\r\nif (fc_fcp_lock_pkt(fsp))\r\ngoto out;\r\nfh = fc_frame_header_get(fp);\r\nif (fh->fh_type == FC_TYPE_BLS) {\r\nfc_fcp_unlock_pkt(fsp);\r\nreturn;\r\n}\r\nswitch (fc_frame_payload_op(fp)) {\r\ncase ELS_LS_ACC:\r\nfsp->recov_retry = 0;\r\nfc_fcp_timer_set(fsp, get_fsp_rec_tov(fsp));\r\nbreak;\r\ncase ELS_LS_RJT:\r\ndefault:\r\nfc_fcp_recovery(fsp, FC_ERROR);\r\nbreak;\r\n}\r\nfc_fcp_unlock_pkt(fsp);\r\nout:\r\nfsp->lp->tt.exch_done(seq);\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_fcp_srr_error(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\r\n{\r\nif (fc_fcp_lock_pkt(fsp))\r\ngoto out;\r\nswitch (PTR_ERR(fp)) {\r\ncase -FC_EX_TIMEOUT:\r\nif (fsp->recov_retry++ < FC_MAX_RECOV_RETRY)\r\nfc_fcp_rec(fsp);\r\nelse\r\nfc_fcp_recovery(fsp, FC_TIMED_OUT);\r\nbreak;\r\ncase -FC_EX_CLOSED:\r\ndefault:\r\nfc_fcp_retry_cmd(fsp);\r\nbreak;\r\n}\r\nfc_fcp_unlock_pkt(fsp);\r\nout:\r\nfsp->lp->tt.exch_done(fsp->recov_seq);\r\n}\r\nstatic inline int fc_fcp_lport_queue_ready(struct fc_lport *lport)\r\n{\r\nreturn (lport->state == LPORT_ST_READY) &&\r\nlport->link_up && !lport->qfull;\r\n}\r\nint fc_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *sc_cmd)\r\n{\r\nstruct fc_lport *lport = shost_priv(shost);\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sc_cmd->device));\r\nstruct fc_fcp_pkt *fsp;\r\nstruct fc_rport_libfc_priv *rpriv;\r\nint rval;\r\nint rc = 0;\r\nstruct fc_stats *stats;\r\nrval = fc_remote_port_chkready(rport);\r\nif (rval) {\r\nsc_cmd->result = rval;\r\nsc_cmd->scsi_done(sc_cmd);\r\nreturn 0;\r\n}\r\nif (!*(struct fc_remote_port **)rport->dd_data) {\r\nsc_cmd->result = DID_IMM_RETRY << 16;\r\nsc_cmd->scsi_done(sc_cmd);\r\ngoto out;\r\n}\r\nrpriv = rport->dd_data;\r\nif (!fc_fcp_lport_queue_ready(lport)) {\r\nif (lport->qfull)\r\nfc_fcp_can_queue_ramp_down(lport);\r\nrc = SCSI_MLQUEUE_HOST_BUSY;\r\ngoto out;\r\n}\r\nfsp = fc_fcp_pkt_alloc(lport, GFP_ATOMIC);\r\nif (fsp == NULL) {\r\nrc = SCSI_MLQUEUE_HOST_BUSY;\r\ngoto out;\r\n}\r\nfsp->cmd = sc_cmd;\r\nfsp->rport = rport;\r\nfsp->data_len = scsi_bufflen(sc_cmd);\r\nfsp->xfer_len = 0;\r\nstats = per_cpu_ptr(lport->stats, get_cpu());\r\nif (sc_cmd->sc_data_direction == DMA_FROM_DEVICE) {\r\nfsp->req_flags = FC_SRB_READ;\r\nstats->InputRequests++;\r\nstats->InputBytes += fsp->data_len;\r\n} else if (sc_cmd->sc_data_direction == DMA_TO_DEVICE) {\r\nfsp->req_flags = FC_SRB_WRITE;\r\nstats->OutputRequests++;\r\nstats->OutputBytes += fsp->data_len;\r\n} else {\r\nfsp->req_flags = 0;\r\nstats->ControlRequests++;\r\n}\r\nput_cpu();\r\nrval = fc_fcp_pkt_send(lport, fsp);\r\nif (rval != 0) {\r\nfsp->state = FC_SRB_FREE;\r\nfc_fcp_pkt_release(fsp);\r\nrc = SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic void fc_io_compl(struct fc_fcp_pkt *fsp)\r\n{\r\nstruct fc_fcp_internal *si;\r\nstruct scsi_cmnd *sc_cmd;\r\nstruct fc_lport *lport;\r\nunsigned long flags;\r\nfc_fcp_ddp_done(fsp);\r\nfsp->state |= FC_SRB_COMPL;\r\nif (!(fsp->state & FC_SRB_FCP_PROCESSING_TMO)) {\r\nspin_unlock_bh(&fsp->scsi_pkt_lock);\r\ndel_timer_sync(&fsp->timer);\r\nspin_lock_bh(&fsp->scsi_pkt_lock);\r\n}\r\nlport = fsp->lp;\r\nsi = fc_get_scsi_internal(lport);\r\nif (si->last_can_queue_ramp_down_time)\r\nfc_fcp_can_queue_ramp_up(lport);\r\nsc_cmd = fsp->cmd;\r\nCMD_SCSI_STATUS(sc_cmd) = fsp->cdb_status;\r\nswitch (fsp->status_code) {\r\ncase FC_COMPLETE:\r\nif (fsp->cdb_status == 0) {\r\nsc_cmd->result = DID_OK << 16;\r\nif (fsp->scsi_resid)\r\nCMD_RESID_LEN(sc_cmd) = fsp->scsi_resid;\r\n} else {\r\nsc_cmd->result = (DID_OK << 16) | fsp->cdb_status;\r\n}\r\nbreak;\r\ncase FC_ERROR:\r\nFC_FCP_DBG(fsp, "Returning DID_ERROR to scsi-ml "\r\n"due to FC_ERROR\n");\r\nsc_cmd->result = DID_ERROR << 16;\r\nbreak;\r\ncase FC_DATA_UNDRUN:\r\nif ((fsp->cdb_status == 0) && !(fsp->req_flags & FC_SRB_READ)) {\r\nif (fsp->state & FC_SRB_RCV_STATUS) {\r\nsc_cmd->result = DID_OK << 16;\r\n} else {\r\nFC_FCP_DBG(fsp, "Returning DID_ERROR to scsi-ml"\r\n" due to FC_DATA_UNDRUN (trans)\n");\r\nsc_cmd->result = DID_ERROR << 16;\r\n}\r\n} else {\r\nFC_FCP_DBG(fsp, "Returning DID_ERROR to scsi-ml "\r\n"due to FC_DATA_UNDRUN (scsi)\n");\r\nCMD_RESID_LEN(sc_cmd) = fsp->scsi_resid;\r\nsc_cmd->result = (DID_ERROR << 16) | fsp->cdb_status;\r\n}\r\nbreak;\r\ncase FC_DATA_OVRRUN:\r\nFC_FCP_DBG(fsp, "Returning DID_ERROR to scsi-ml "\r\n"due to FC_DATA_OVRRUN\n");\r\nsc_cmd->result = (DID_ERROR << 16) | fsp->cdb_status;\r\nbreak;\r\ncase FC_CMD_ABORTED:\r\nFC_FCP_DBG(fsp, "Returning DID_ERROR to scsi-ml "\r\n"due to FC_CMD_ABORTED\n");\r\nsc_cmd->result = (DID_ERROR << 16) | fsp->io_status;\r\nbreak;\r\ncase FC_CMD_RESET:\r\nFC_FCP_DBG(fsp, "Returning DID_RESET to scsi-ml "\r\n"due to FC_CMD_RESET\n");\r\nsc_cmd->result = (DID_RESET << 16);\r\nbreak;\r\ncase FC_HRD_ERROR:\r\nFC_FCP_DBG(fsp, "Returning DID_NO_CONNECT to scsi-ml "\r\n"due to FC_HRD_ERROR\n");\r\nsc_cmd->result = (DID_NO_CONNECT << 16);\r\nbreak;\r\ncase FC_CRC_ERROR:\r\nFC_FCP_DBG(fsp, "Returning DID_PARITY to scsi-ml "\r\n"due to FC_CRC_ERROR\n");\r\nsc_cmd->result = (DID_PARITY << 16);\r\nbreak;\r\ncase FC_TIMED_OUT:\r\nFC_FCP_DBG(fsp, "Returning DID_BUS_BUSY to scsi-ml "\r\n"due to FC_TIMED_OUT\n");\r\nsc_cmd->result = (DID_BUS_BUSY << 16) | fsp->io_status;\r\nbreak;\r\ndefault:\r\nFC_FCP_DBG(fsp, "Returning DID_ERROR to scsi-ml "\r\n"due to unknown error\n");\r\nsc_cmd->result = (DID_ERROR << 16);\r\nbreak;\r\n}\r\nif (lport->state != LPORT_ST_READY && fsp->status_code != FC_COMPLETE)\r\nsc_cmd->result = (DID_TRANSPORT_DISRUPTED << 16);\r\nspin_lock_irqsave(&si->scsi_queue_lock, flags);\r\nlist_del(&fsp->list);\r\nsc_cmd->SCp.ptr = NULL;\r\nspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\r\nsc_cmd->scsi_done(sc_cmd);\r\nfc_fcp_pkt_release(fsp);\r\n}\r\nint fc_eh_abort(struct scsi_cmnd *sc_cmd)\r\n{\r\nstruct fc_fcp_pkt *fsp;\r\nstruct fc_lport *lport;\r\nstruct fc_fcp_internal *si;\r\nint rc = FAILED;\r\nunsigned long flags;\r\nint rval;\r\nrval = fc_block_scsi_eh(sc_cmd);\r\nif (rval)\r\nreturn rval;\r\nlport = shost_priv(sc_cmd->device->host);\r\nif (lport->state != LPORT_ST_READY)\r\nreturn rc;\r\nelse if (!lport->link_up)\r\nreturn rc;\r\nsi = fc_get_scsi_internal(lport);\r\nspin_lock_irqsave(&si->scsi_queue_lock, flags);\r\nfsp = CMD_SP(sc_cmd);\r\nif (!fsp) {\r\nspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nfc_fcp_pkt_hold(fsp);\r\nspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\r\nif (fc_fcp_lock_pkt(fsp)) {\r\nrc = SUCCESS;\r\ngoto release_pkt;\r\n}\r\nrc = fc_fcp_pkt_abort(fsp);\r\nfc_fcp_unlock_pkt(fsp);\r\nrelease_pkt:\r\nfc_fcp_pkt_release(fsp);\r\nreturn rc;\r\n}\r\nint fc_eh_device_reset(struct scsi_cmnd *sc_cmd)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_fcp_pkt *fsp;\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sc_cmd->device));\r\nint rc = FAILED;\r\nint rval;\r\nrval = fc_block_scsi_eh(sc_cmd);\r\nif (rval)\r\nreturn rval;\r\nlport = shost_priv(sc_cmd->device->host);\r\nif (lport->state != LPORT_ST_READY)\r\nreturn rc;\r\nFC_SCSI_DBG(lport, "Resetting rport (%6.6x)\n", rport->port_id);\r\nfsp = fc_fcp_pkt_alloc(lport, GFP_NOIO);\r\nif (fsp == NULL) {\r\nprintk(KERN_WARNING "libfc: could not allocate scsi_pkt\n");\r\ngoto out;\r\n}\r\nfsp->rport = rport;\r\nrc = fc_lun_reset(lport, fsp, scmd_id(sc_cmd), sc_cmd->device->lun);\r\nfsp->state = FC_SRB_FREE;\r\nfc_fcp_pkt_release(fsp);\r\nout:\r\nreturn rc;\r\n}\r\nint fc_eh_host_reset(struct scsi_cmnd *sc_cmd)\r\n{\r\nstruct Scsi_Host *shost = sc_cmd->device->host;\r\nstruct fc_lport *lport = shost_priv(shost);\r\nunsigned long wait_tmo;\r\nFC_SCSI_DBG(lport, "Resetting host\n");\r\nfc_block_scsi_eh(sc_cmd);\r\nlport->tt.lport_reset(lport);\r\nwait_tmo = jiffies + FC_HOST_RESET_TIMEOUT;\r\nwhile (!fc_fcp_lport_queue_ready(lport) && time_before(jiffies,\r\nwait_tmo))\r\nmsleep(1000);\r\nif (fc_fcp_lport_queue_ready(lport)) {\r\nshost_printk(KERN_INFO, shost, "libfc: Host reset succeeded "\r\n"on port (%6.6x)\n", lport->port_id);\r\nreturn SUCCESS;\r\n} else {\r\nshost_printk(KERN_INFO, shost, "libfc: Host reset failed, "\r\n"port (%6.6x) is not ready.\n",\r\nlport->port_id);\r\nreturn FAILED;\r\n}\r\n}\r\nint fc_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nif (!rport || fc_remote_port_chkready(rport))\r\nreturn -ENXIO;\r\nscsi_change_queue_depth(sdev, FC_FCP_DFLT_QUEUE_DEPTH);\r\nreturn 0;\r\n}\r\nvoid fc_fcp_destroy(struct fc_lport *lport)\r\n{\r\nstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\r\nif (!list_empty(&si->scsi_pkt_queue))\r\nprintk(KERN_ERR "libfc: Leaked SCSI packets when destroying "\r\n"port (%6.6x)\n", lport->port_id);\r\nmempool_destroy(si->scsi_pkt_pool);\r\nkfree(si);\r\nlport->scsi_priv = NULL;\r\n}\r\nint fc_setup_fcp(void)\r\n{\r\nint rc = 0;\r\nscsi_pkt_cachep = kmem_cache_create("libfc_fcp_pkt",\r\nsizeof(struct fc_fcp_pkt),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (!scsi_pkt_cachep) {\r\nprintk(KERN_ERR "libfc: Unable to allocate SRB cache, "\r\n"module load failed!");\r\nrc = -ENOMEM;\r\n}\r\nreturn rc;\r\n}\r\nvoid fc_destroy_fcp(void)\r\n{\r\nif (scsi_pkt_cachep)\r\nkmem_cache_destroy(scsi_pkt_cachep);\r\n}\r\nint fc_fcp_init(struct fc_lport *lport)\r\n{\r\nint rc;\r\nstruct fc_fcp_internal *si;\r\nif (!lport->tt.fcp_cmd_send)\r\nlport->tt.fcp_cmd_send = fc_fcp_cmd_send;\r\nif (!lport->tt.fcp_cleanup)\r\nlport->tt.fcp_cleanup = fc_fcp_cleanup;\r\nif (!lport->tt.fcp_abort_io)\r\nlport->tt.fcp_abort_io = fc_fcp_abort_io;\r\nsi = kzalloc(sizeof(struct fc_fcp_internal), GFP_KERNEL);\r\nif (!si)\r\nreturn -ENOMEM;\r\nlport->scsi_priv = si;\r\nsi->max_can_queue = lport->host->can_queue;\r\nINIT_LIST_HEAD(&si->scsi_pkt_queue);\r\nspin_lock_init(&si->scsi_queue_lock);\r\nsi->scsi_pkt_pool = mempool_create_slab_pool(2, scsi_pkt_cachep);\r\nif (!si->scsi_pkt_pool) {\r\nrc = -ENOMEM;\r\ngoto free_internal;\r\n}\r\nreturn 0;\r\nfree_internal:\r\nkfree(si);\r\nreturn rc;\r\n}
