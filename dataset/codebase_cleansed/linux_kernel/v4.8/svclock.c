static const char *nlmdbg_cookie2a(const struct nlm_cookie *cookie)\r\n{\r\nstatic char buf[2*NLM_MAXCOOKIELEN+1];\r\nunsigned int i, len = sizeof(buf);\r\nchar *p = buf;\r\nlen--;\r\nif (len < 3)\r\nreturn "???";\r\nfor (i = 0 ; i < cookie->len ; i++) {\r\nif (len < 2) {\r\nstrcpy(p-3, "...");\r\nbreak;\r\n}\r\nsprintf(p, "%02x", cookie->data[i]);\r\np += 2;\r\nlen -= 2;\r\n}\r\n*p = '\0';\r\nreturn buf;\r\n}\r\nstatic void\r\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\r\n{\r\nstruct nlm_block *b;\r\nstruct list_head *pos;\r\ndprintk("lockd: nlmsvc_insert_block(%p, %ld)\n", block, when);\r\nif (list_empty(&block->b_list)) {\r\nkref_get(&block->b_count);\r\n} else {\r\nlist_del_init(&block->b_list);\r\n}\r\npos = &nlm_blocked;\r\nif (when != NLM_NEVER) {\r\nif ((when += jiffies) == NLM_NEVER)\r\nwhen ++;\r\nlist_for_each(pos, &nlm_blocked) {\r\nb = list_entry(pos, struct nlm_block, b_list);\r\nif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\r\nbreak;\r\n}\r\n}\r\nlist_add_tail(&block->b_list, pos);\r\nblock->b_when = when;\r\n}\r\nstatic void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\r\n{\r\nspin_lock(&nlm_blocked_lock);\r\nnlmsvc_insert_block_locked(block, when);\r\nspin_unlock(&nlm_blocked_lock);\r\n}\r\nstatic inline void\r\nnlmsvc_remove_block(struct nlm_block *block)\r\n{\r\nif (!list_empty(&block->b_list)) {\r\nspin_lock(&nlm_blocked_lock);\r\nlist_del_init(&block->b_list);\r\nspin_unlock(&nlm_blocked_lock);\r\nnlmsvc_release_block(block);\r\n}\r\n}\r\nstatic struct nlm_block *\r\nnlmsvc_lookup_block(struct nlm_file *file, struct nlm_lock *lock)\r\n{\r\nstruct nlm_block *block;\r\nstruct file_lock *fl;\r\ndprintk("lockd: nlmsvc_lookup_block f=%p pd=%d %Ld-%Ld ty=%d\n",\r\nfile, lock->fl.fl_pid,\r\n(long long)lock->fl.fl_start,\r\n(long long)lock->fl.fl_end, lock->fl.fl_type);\r\nlist_for_each_entry(block, &nlm_blocked, b_list) {\r\nfl = &block->b_call->a_args.lock.fl;\r\ndprintk("lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%s\n",\r\nblock->b_file, fl->fl_pid,\r\n(long long)fl->fl_start,\r\n(long long)fl->fl_end, fl->fl_type,\r\nnlmdbg_cookie2a(&block->b_call->a_args.cookie));\r\nif (block->b_file == file && nlm_compare_locks(fl, &lock->fl)) {\r\nkref_get(&block->b_count);\r\nreturn block;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline int nlm_cookie_match(struct nlm_cookie *a, struct nlm_cookie *b)\r\n{\r\nif (a->len != b->len)\r\nreturn 0;\r\nif (memcmp(a->data, b->data, a->len))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline struct nlm_block *\r\nnlmsvc_find_block(struct nlm_cookie *cookie)\r\n{\r\nstruct nlm_block *block;\r\nlist_for_each_entry(block, &nlm_blocked, b_list) {\r\nif (nlm_cookie_match(&block->b_call->a_args.cookie,cookie))\r\ngoto found;\r\n}\r\nreturn NULL;\r\nfound:\r\ndprintk("nlmsvc_find_block(%s): block=%p\n", nlmdbg_cookie2a(cookie), block);\r\nkref_get(&block->b_count);\r\nreturn block;\r\n}\r\nstatic struct nlm_block *\r\nnlmsvc_create_block(struct svc_rqst *rqstp, struct nlm_host *host,\r\nstruct nlm_file *file, struct nlm_lock *lock,\r\nstruct nlm_cookie *cookie)\r\n{\r\nstruct nlm_block *block;\r\nstruct nlm_rqst *call = NULL;\r\ncall = nlm_alloc_call(host);\r\nif (call == NULL)\r\nreturn NULL;\r\nblock = kzalloc(sizeof(*block), GFP_KERNEL);\r\nif (block == NULL)\r\ngoto failed;\r\nkref_init(&block->b_count);\r\nINIT_LIST_HEAD(&block->b_list);\r\nINIT_LIST_HEAD(&block->b_flist);\r\nif (!nlmsvc_setgrantargs(call, lock))\r\ngoto failed_free;\r\ncall->a_args.lock.fl.fl_flags |= FL_SLEEP;\r\ncall->a_args.lock.fl.fl_lmops = &nlmsvc_lock_operations;\r\nnlmclnt_next_cookie(&call->a_args.cookie);\r\ndprintk("lockd: created block %p...\n", block);\r\nblock->b_daemon = rqstp->rq_server;\r\nblock->b_host = host;\r\nblock->b_file = file;\r\nfile->f_count++;\r\nlist_add(&block->b_flist, &file->f_blocks);\r\nblock->b_call = call;\r\ncall->a_flags = RPC_TASK_ASYNC;\r\ncall->a_block = block;\r\nreturn block;\r\nfailed_free:\r\nkfree(block);\r\nfailed:\r\nnlmsvc_release_call(call);\r\nreturn NULL;\r\n}\r\nstatic int nlmsvc_unlink_block(struct nlm_block *block)\r\n{\r\nint status;\r\ndprintk("lockd: unlinking block %p...\n", block);\r\nstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\r\nnlmsvc_remove_block(block);\r\nreturn status;\r\n}\r\nstatic void nlmsvc_free_block(struct kref *kref)\r\n{\r\nstruct nlm_block *block = container_of(kref, struct nlm_block, b_count);\r\nstruct nlm_file *file = block->b_file;\r\ndprintk("lockd: freeing block %p...\n", block);\r\nlist_del_init(&block->b_flist);\r\nmutex_unlock(&file->f_mutex);\r\nnlmsvc_freegrantargs(block->b_call);\r\nnlmsvc_release_call(block->b_call);\r\nnlm_release_file(block->b_file);\r\nkfree(block);\r\n}\r\nstatic void nlmsvc_release_block(struct nlm_block *block)\r\n{\r\nif (block != NULL)\r\nkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\r\n}\r\nvoid nlmsvc_traverse_blocks(struct nlm_host *host,\r\nstruct nlm_file *file,\r\nnlm_host_match_fn_t match)\r\n{\r\nstruct nlm_block *block, *next;\r\nrestart:\r\nmutex_lock(&file->f_mutex);\r\nlist_for_each_entry_safe(block, next, &file->f_blocks, b_flist) {\r\nif (!match(block->b_host, host))\r\ncontinue;\r\nif (list_empty(&block->b_list))\r\ncontinue;\r\nkref_get(&block->b_count);\r\nmutex_unlock(&file->f_mutex);\r\nnlmsvc_unlink_block(block);\r\nnlmsvc_release_block(block);\r\ngoto restart;\r\n}\r\nmutex_unlock(&file->f_mutex);\r\n}\r\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock)\r\n{\r\nlocks_copy_lock(&call->a_args.lock.fl, &lock->fl);\r\nmemcpy(&call->a_args.lock.fh, &lock->fh, sizeof(call->a_args.lock.fh));\r\ncall->a_args.lock.caller = utsname()->nodename;\r\ncall->a_args.lock.oh.len = lock->oh.len;\r\ncall->a_args.lock.oh.data = call->a_owner;\r\ncall->a_args.lock.svid = lock->fl.fl_pid;\r\nif (lock->oh.len > NLMCLNT_OHSIZE) {\r\nvoid *data = kmalloc(lock->oh.len, GFP_KERNEL);\r\nif (!data)\r\nreturn 0;\r\ncall->a_args.lock.oh.data = (u8 *) data;\r\n}\r\nmemcpy(call->a_args.lock.oh.data, lock->oh.data, lock->oh.len);\r\nreturn 1;\r\n}\r\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call)\r\n{\r\nif (call->a_args.lock.oh.data != call->a_owner)\r\nkfree(call->a_args.lock.oh.data);\r\nlocks_release_private(&call->a_args.lock.fl);\r\n}\r\nstatic __be32\r\nnlmsvc_defer_lock_rqst(struct svc_rqst *rqstp, struct nlm_block *block)\r\n{\r\n__be32 status = nlm_lck_denied_nolocks;\r\nblock->b_flags |= B_QUEUED;\r\nnlmsvc_insert_block(block, NLM_TIMEOUT);\r\nblock->b_cache_req = &rqstp->rq_chandle;\r\nif (rqstp->rq_chandle.defer) {\r\nblock->b_deferred_req =\r\nrqstp->rq_chandle.defer(block->b_cache_req);\r\nif (block->b_deferred_req != NULL)\r\nstatus = nlm_drop_reply;\r\n}\r\ndprintk("lockd: nlmsvc_defer_lock_rqst block %p flags %d status %d\n",\r\nblock, block->b_flags, ntohl(status));\r\nreturn status;\r\n}\r\n__be32\r\nnlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,\r\nstruct nlm_host *host, struct nlm_lock *lock, int wait,\r\nstruct nlm_cookie *cookie, int reclaim)\r\n{\r\nstruct nlm_block *block = NULL;\r\nint error;\r\n__be32 ret;\r\ndprintk("lockd: nlmsvc_lock(%s/%ld, ty=%d, pi=%d, %Ld-%Ld, bl=%d)\n",\r\nfile_inode(file->f_file)->i_sb->s_id,\r\nfile_inode(file->f_file)->i_ino,\r\nlock->fl.fl_type, lock->fl.fl_pid,\r\n(long long)lock->fl.fl_start,\r\n(long long)lock->fl.fl_end,\r\nwait);\r\nmutex_lock(&file->f_mutex);\r\nblock = nlmsvc_lookup_block(file, lock);\r\nif (block == NULL) {\r\nblock = nlmsvc_create_block(rqstp, host, file, lock, cookie);\r\nret = nlm_lck_denied_nolocks;\r\nif (block == NULL)\r\ngoto out;\r\nlock = &block->b_call->a_args.lock;\r\n} else\r\nlock->fl.fl_flags &= ~FL_SLEEP;\r\nif (block->b_flags & B_QUEUED) {\r\ndprintk("lockd: nlmsvc_lock deferred block %p flags %d\n",\r\nblock, block->b_flags);\r\nif (block->b_granted) {\r\nnlmsvc_unlink_block(block);\r\nret = nlm_granted;\r\ngoto out;\r\n}\r\nif (block->b_flags & B_TIMED_OUT) {\r\nnlmsvc_unlink_block(block);\r\nret = nlm_lck_denied;\r\ngoto out;\r\n}\r\nret = nlm_drop_reply;\r\ngoto out;\r\n}\r\nif (locks_in_grace(SVC_NET(rqstp)) && !reclaim) {\r\nret = nlm_lck_denied_grace_period;\r\ngoto out;\r\n}\r\nif (reclaim && !locks_in_grace(SVC_NET(rqstp))) {\r\nret = nlm_lck_denied_grace_period;\r\ngoto out;\r\n}\r\nif (!wait)\r\nlock->fl.fl_flags &= ~FL_SLEEP;\r\nerror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\r\nlock->fl.fl_flags &= ~FL_SLEEP;\r\ndprintk("lockd: vfs_lock_file returned %d\n", error);\r\nswitch (error) {\r\ncase 0:\r\nret = nlm_granted;\r\ngoto out;\r\ncase -EAGAIN:\r\nif (wait)\r\nbreak;\r\nret = nlm_lck_denied;\r\ngoto out;\r\ncase FILE_LOCK_DEFERRED:\r\nif (wait)\r\nbreak;\r\nret = nlmsvc_defer_lock_rqst(rqstp, block);\r\ngoto out;\r\ncase -EDEADLK:\r\nret = nlm_deadlock;\r\ngoto out;\r\ndefault:\r\nret = nlm_lck_denied_nolocks;\r\ngoto out;\r\n}\r\nret = nlm_lck_blocked;\r\nnlmsvc_insert_block(block, NLM_NEVER);\r\nout:\r\nmutex_unlock(&file->f_mutex);\r\nnlmsvc_release_block(block);\r\ndprintk("lockd: nlmsvc_lock returned %u\n", ret);\r\nreturn ret;\r\n}\r\n__be32\r\nnlmsvc_testlock(struct svc_rqst *rqstp, struct nlm_file *file,\r\nstruct nlm_host *host, struct nlm_lock *lock,\r\nstruct nlm_lock *conflock, struct nlm_cookie *cookie)\r\n{\r\nint error;\r\n__be32 ret;\r\ndprintk("lockd: nlmsvc_testlock(%s/%ld, ty=%d, %Ld-%Ld)\n",\r\nfile_inode(file->f_file)->i_sb->s_id,\r\nfile_inode(file->f_file)->i_ino,\r\nlock->fl.fl_type,\r\n(long long)lock->fl.fl_start,\r\n(long long)lock->fl.fl_end);\r\nif (locks_in_grace(SVC_NET(rqstp))) {\r\nret = nlm_lck_denied_grace_period;\r\ngoto out;\r\n}\r\nerror = vfs_test_lock(file->f_file, &lock->fl);\r\nif (error) {\r\nif (error == FILE_LOCK_DEFERRED)\r\nWARN_ON_ONCE(1);\r\nret = nlm_lck_denied_nolocks;\r\ngoto out;\r\n}\r\nif (lock->fl.fl_type == F_UNLCK) {\r\nret = nlm_granted;\r\ngoto out;\r\n}\r\ndprintk("lockd: conflicting lock(ty=%d, %Ld-%Ld)\n",\r\nlock->fl.fl_type, (long long)lock->fl.fl_start,\r\n(long long)lock->fl.fl_end);\r\nconflock->caller = "somehost";\r\nconflock->len = strlen(conflock->caller);\r\nconflock->oh.len = 0;\r\nconflock->svid = lock->fl.fl_pid;\r\nconflock->fl.fl_type = lock->fl.fl_type;\r\nconflock->fl.fl_start = lock->fl.fl_start;\r\nconflock->fl.fl_end = lock->fl.fl_end;\r\nlocks_release_private(&lock->fl);\r\nret = nlm_lck_denied;\r\nout:\r\nreturn ret;\r\n}\r\n__be32\r\nnlmsvc_unlock(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\r\n{\r\nint error;\r\ndprintk("lockd: nlmsvc_unlock(%s/%ld, pi=%d, %Ld-%Ld)\n",\r\nfile_inode(file->f_file)->i_sb->s_id,\r\nfile_inode(file->f_file)->i_ino,\r\nlock->fl.fl_pid,\r\n(long long)lock->fl.fl_start,\r\n(long long)lock->fl.fl_end);\r\nnlmsvc_cancel_blocked(net, file, lock);\r\nlock->fl.fl_type = F_UNLCK;\r\nerror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\r\nreturn (error < 0)? nlm_lck_denied_nolocks : nlm_granted;\r\n}\r\n__be32\r\nnlmsvc_cancel_blocked(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\r\n{\r\nstruct nlm_block *block;\r\nint status = 0;\r\ndprintk("lockd: nlmsvc_cancel(%s/%ld, pi=%d, %Ld-%Ld)\n",\r\nfile_inode(file->f_file)->i_sb->s_id,\r\nfile_inode(file->f_file)->i_ino,\r\nlock->fl.fl_pid,\r\n(long long)lock->fl.fl_start,\r\n(long long)lock->fl.fl_end);\r\nif (locks_in_grace(net))\r\nreturn nlm_lck_denied_grace_period;\r\nmutex_lock(&file->f_mutex);\r\nblock = nlmsvc_lookup_block(file, lock);\r\nmutex_unlock(&file->f_mutex);\r\nif (block != NULL) {\r\nvfs_cancel_lock(block->b_file->f_file,\r\n&block->b_call->a_args.lock.fl);\r\nstatus = nlmsvc_unlink_block(block);\r\nnlmsvc_release_block(block);\r\n}\r\nreturn status ? nlm_lck_denied : nlm_granted;\r\n}\r\nstatic void\r\nnlmsvc_update_deferred_block(struct nlm_block *block, int result)\r\n{\r\nblock->b_flags |= B_GOT_CALLBACK;\r\nif (result == 0)\r\nblock->b_granted = 1;\r\nelse\r\nblock->b_flags |= B_TIMED_OUT;\r\n}\r\nstatic int nlmsvc_grant_deferred(struct file_lock *fl, int result)\r\n{\r\nstruct nlm_block *block;\r\nint rc = -ENOENT;\r\nspin_lock(&nlm_blocked_lock);\r\nlist_for_each_entry(block, &nlm_blocked, b_list) {\r\nif (nlm_compare_locks(&block->b_call->a_args.lock.fl, fl)) {\r\ndprintk("lockd: nlmsvc_notify_blocked block %p flags %d\n",\r\nblock, block->b_flags);\r\nif (block->b_flags & B_QUEUED) {\r\nif (block->b_flags & B_TIMED_OUT) {\r\nrc = -ENOLCK;\r\nbreak;\r\n}\r\nnlmsvc_update_deferred_block(block, result);\r\n} else if (result == 0)\r\nblock->b_granted = 1;\r\nnlmsvc_insert_block_locked(block, 0);\r\nsvc_wake_up(block->b_daemon);\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&nlm_blocked_lock);\r\nif (rc == -ENOENT)\r\nprintk(KERN_WARNING "lockd: grant for unknown block\n");\r\nreturn rc;\r\n}\r\nstatic void\r\nnlmsvc_notify_blocked(struct file_lock *fl)\r\n{\r\nstruct nlm_block *block;\r\ndprintk("lockd: VFS unblock notification for block %p\n", fl);\r\nspin_lock(&nlm_blocked_lock);\r\nlist_for_each_entry(block, &nlm_blocked, b_list) {\r\nif (nlm_compare_locks(&block->b_call->a_args.lock.fl, fl)) {\r\nnlmsvc_insert_block_locked(block, 0);\r\nspin_unlock(&nlm_blocked_lock);\r\nsvc_wake_up(block->b_daemon);\r\nreturn;\r\n}\r\n}\r\nspin_unlock(&nlm_blocked_lock);\r\nprintk(KERN_WARNING "lockd: notification for unknown block!\n");\r\n}\r\nstatic int nlmsvc_same_owner(struct file_lock *fl1, struct file_lock *fl2)\r\n{\r\nreturn fl1->fl_owner == fl2->fl_owner && fl1->fl_pid == fl2->fl_pid;\r\n}\r\nstatic unsigned long\r\nnlmsvc_owner_key(struct file_lock *fl)\r\n{\r\nreturn (unsigned long)fl->fl_owner ^ (unsigned long)fl->fl_pid;\r\n}\r\nstatic void\r\nnlmsvc_grant_blocked(struct nlm_block *block)\r\n{\r\nstruct nlm_file *file = block->b_file;\r\nstruct nlm_lock *lock = &block->b_call->a_args.lock;\r\nint error;\r\nloff_t fl_start, fl_end;\r\ndprintk("lockd: grant blocked lock %p\n", block);\r\nkref_get(&block->b_count);\r\nnlmsvc_unlink_block(block);\r\nif (block->b_granted) {\r\nnlm_rebind_host(block->b_host);\r\ngoto callback;\r\n}\r\nlock->fl.fl_flags |= FL_SLEEP;\r\nfl_start = lock->fl.fl_start;\r\nfl_end = lock->fl.fl_end;\r\nerror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\r\nlock->fl.fl_flags &= ~FL_SLEEP;\r\nlock->fl.fl_start = fl_start;\r\nlock->fl.fl_end = fl_end;\r\nswitch (error) {\r\ncase 0:\r\nbreak;\r\ncase FILE_LOCK_DEFERRED:\r\ndprintk("lockd: lock still blocked error %d\n", error);\r\nnlmsvc_insert_block(block, NLM_NEVER);\r\nnlmsvc_release_block(block);\r\nreturn;\r\ndefault:\r\nprintk(KERN_WARNING "lockd: unexpected error %d in %s!\n",\r\n-error, __func__);\r\nnlmsvc_insert_block(block, 10 * HZ);\r\nnlmsvc_release_block(block);\r\nreturn;\r\n}\r\ncallback:\r\ndprintk("lockd: GRANTing blocked lock.\n");\r\nblock->b_granted = 1;\r\nnlmsvc_insert_block(block, NLM_NEVER);\r\nerror = nlm_async_call(block->b_call, NLMPROC_GRANTED_MSG,\r\n&nlmsvc_grant_ops);\r\nif (error < 0)\r\nnlmsvc_insert_block(block, 10 * HZ);\r\n}\r\nstatic void nlmsvc_grant_callback(struct rpc_task *task, void *data)\r\n{\r\nstruct nlm_rqst *call = data;\r\nstruct nlm_block *block = call->a_block;\r\nunsigned long timeout;\r\ndprintk("lockd: GRANT_MSG RPC callback\n");\r\nspin_lock(&nlm_blocked_lock);\r\nif (list_empty(&block->b_list))\r\ngoto out;\r\nif (task->tk_status < 0) {\r\ntimeout = 10 * HZ;\r\n} else {\r\ntimeout = 60 * HZ;\r\n}\r\nnlmsvc_insert_block_locked(block, timeout);\r\nsvc_wake_up(block->b_daemon);\r\nout:\r\nspin_unlock(&nlm_blocked_lock);\r\n}\r\nstatic void nlmsvc_grant_release(void *data)\r\n{\r\nstruct nlm_rqst *call = data;\r\nnlmsvc_release_block(call->a_block);\r\n}\r\nvoid\r\nnlmsvc_grant_reply(struct nlm_cookie *cookie, __be32 status)\r\n{\r\nstruct nlm_block *block;\r\ndprintk("grant_reply: looking for cookie %x, s=%d \n",\r\n*(unsigned int *)(cookie->data), status);\r\nif (!(block = nlmsvc_find_block(cookie)))\r\nreturn;\r\nif (block) {\r\nif (status == nlm_lck_denied_grace_period) {\r\nnlmsvc_insert_block(block, 10 * HZ);\r\n} else {\r\nnlmsvc_unlink_block(block);\r\n}\r\n}\r\nnlmsvc_release_block(block);\r\n}\r\nstatic void\r\nretry_deferred_block(struct nlm_block *block)\r\n{\r\nif (!(block->b_flags & B_GOT_CALLBACK))\r\nblock->b_flags |= B_TIMED_OUT;\r\nnlmsvc_insert_block(block, NLM_TIMEOUT);\r\ndprintk("revisit block %p flags %d\n", block, block->b_flags);\r\nif (block->b_deferred_req) {\r\nblock->b_deferred_req->revisit(block->b_deferred_req, 0);\r\nblock->b_deferred_req = NULL;\r\n}\r\n}\r\nunsigned long\r\nnlmsvc_retry_blocked(void)\r\n{\r\nunsigned long timeout = MAX_SCHEDULE_TIMEOUT;\r\nstruct nlm_block *block;\r\nspin_lock(&nlm_blocked_lock);\r\nwhile (!list_empty(&nlm_blocked) && !kthread_should_stop()) {\r\nblock = list_entry(nlm_blocked.next, struct nlm_block, b_list);\r\nif (block->b_when == NLM_NEVER)\r\nbreak;\r\nif (time_after(block->b_when, jiffies)) {\r\ntimeout = block->b_when - jiffies;\r\nbreak;\r\n}\r\nspin_unlock(&nlm_blocked_lock);\r\ndprintk("nlmsvc_retry_blocked(%p, when=%ld)\n",\r\nblock, block->b_when);\r\nif (block->b_flags & B_QUEUED) {\r\ndprintk("nlmsvc_retry_blocked delete block (%p, granted=%d, flags=%d)\n",\r\nblock, block->b_granted, block->b_flags);\r\nretry_deferred_block(block);\r\n} else\r\nnlmsvc_grant_blocked(block);\r\nspin_lock(&nlm_blocked_lock);\r\n}\r\nspin_unlock(&nlm_blocked_lock);\r\nreturn timeout;\r\n}
