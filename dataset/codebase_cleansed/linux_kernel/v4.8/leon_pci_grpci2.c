static int grpci2_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstruct grpci2_priv *priv = dev->bus->sysdata;\r\nint irq_group;\r\nirq_group = slot & 0x3;\r\npin = ((pin - 1) + irq_group) & 0x3;\r\nreturn priv->irq_map[pin];\r\n}\r\nstatic int grpci2_cfg_r32(struct grpci2_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 *val)\r\n{\r\nunsigned int *pci_conf;\r\nunsigned long flags;\r\nu32 tmp;\r\nif (where & 0x3)\r\nreturn -EINVAL;\r\nif (bus == 0) {\r\ndevfn += (0x8 * 6);\r\n} else if (bus == TGT) {\r\nbus = 0;\r\ndevfn = 0;\r\n}\r\nspin_lock_irqsave(&grpci2_dev_lock, flags);\r\nREGSTORE(priv->regs->ctrl, (REGLOAD(priv->regs->ctrl) & ~(0xff << 16)) |\r\n(bus << 16));\r\nspin_unlock_irqrestore(&grpci2_dev_lock, flags);\r\nREGSTORE(priv->regs->sts_cap, (STS_CFGERR | STS_CFGERRVALID));\r\npci_conf = (unsigned int *) (priv->pci_conf |\r\n(devfn << 8) | (where & 0xfc));\r\ntmp = LEON3_BYPASS_LOAD_PA(pci_conf);\r\nwhile ((REGLOAD(priv->regs->sts_cap) & STS_CFGERRVALID) == 0)\r\n;\r\nif (REGLOAD(priv->regs->sts_cap) & STS_CFGERR) {\r\n*val = 0xffffffff;\r\n} else {\r\n*val = swab32(tmp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int grpci2_cfg_r16(struct grpci2_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 *val)\r\n{\r\nu32 v;\r\nint ret;\r\nif (where & 0x1)\r\nreturn -EINVAL;\r\nret = grpci2_cfg_r32(priv, bus, devfn, where & ~0x3, &v);\r\n*val = 0xffff & (v >> (8 * (where & 0x3)));\r\nreturn ret;\r\n}\r\nstatic int grpci2_cfg_r8(struct grpci2_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 *val)\r\n{\r\nu32 v;\r\nint ret;\r\nret = grpci2_cfg_r32(priv, bus, devfn, where & ~0x3, &v);\r\n*val = 0xff & (v >> (8 * (where & 3)));\r\nreturn ret;\r\n}\r\nstatic int grpci2_cfg_w32(struct grpci2_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 val)\r\n{\r\nunsigned int *pci_conf;\r\nunsigned long flags;\r\nif (where & 0x3)\r\nreturn -EINVAL;\r\nif (bus == 0) {\r\ndevfn += (0x8 * 6);\r\n} else if (bus == TGT) {\r\nbus = 0;\r\ndevfn = 0;\r\n}\r\nspin_lock_irqsave(&grpci2_dev_lock, flags);\r\nREGSTORE(priv->regs->ctrl, (REGLOAD(priv->regs->ctrl) & ~(0xff << 16)) |\r\n(bus << 16));\r\nspin_unlock_irqrestore(&grpci2_dev_lock, flags);\r\nREGSTORE(priv->regs->sts_cap, (STS_CFGERR | STS_CFGERRVALID));\r\npci_conf = (unsigned int *) (priv->pci_conf |\r\n(devfn << 8) | (where & 0xfc));\r\nLEON3_BYPASS_STORE_PA(pci_conf, swab32(val));\r\nwhile ((REGLOAD(priv->regs->sts_cap) & STS_CFGERRVALID) == 0)\r\n;\r\nreturn 0;\r\n}\r\nstatic int grpci2_cfg_w16(struct grpci2_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 val)\r\n{\r\nint ret;\r\nu32 v;\r\nif (where & 0x1)\r\nreturn -EINVAL;\r\nret = grpci2_cfg_r32(priv, bus, devfn, where&~3, &v);\r\nif (ret)\r\nreturn ret;\r\nv = (v & ~(0xffff << (8 * (where & 0x3)))) |\r\n((0xffff & val) << (8 * (where & 0x3)));\r\nreturn grpci2_cfg_w32(priv, bus, devfn, where & ~0x3, v);\r\n}\r\nstatic int grpci2_cfg_w8(struct grpci2_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 val)\r\n{\r\nint ret;\r\nu32 v;\r\nret = grpci2_cfg_r32(priv, bus, devfn, where & ~0x3, &v);\r\nif (ret != 0)\r\nreturn ret;\r\nv = (v & ~(0xff << (8 * (where & 0x3)))) |\r\n((0xff & val) << (8 * (where & 0x3)));\r\nreturn grpci2_cfg_w32(priv, bus, devfn, where & ~0x3, v);\r\n}\r\nstatic int grpci2_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nstruct grpci2_priv *priv = grpci2priv;\r\nunsigned int busno = bus->number;\r\nint ret;\r\nif (PCI_SLOT(devfn) > 15 || busno > 255) {\r\n*val = ~0;\r\nreturn 0;\r\n}\r\nswitch (size) {\r\ncase 1:\r\nret = grpci2_cfg_r8(priv, busno, devfn, where, val);\r\nbreak;\r\ncase 2:\r\nret = grpci2_cfg_r16(priv, busno, devfn, where, val);\r\nbreak;\r\ncase 4:\r\nret = grpci2_cfg_r32(priv, busno, devfn, where, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n#ifdef GRPCI2_DEBUG_CFGACCESS\r\nprintk(KERN_INFO "grpci2_read_config: [%02x:%02x:%x] ofs=%d val=%x "\r\n"size=%d\n", busno, PCI_SLOT(devfn), PCI_FUNC(devfn), where,\r\n*val, size);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int grpci2_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct grpci2_priv *priv = grpci2priv;\r\nunsigned int busno = bus->number;\r\nif (PCI_SLOT(devfn) > 15 || busno > 255)\r\nreturn 0;\r\n#ifdef GRPCI2_DEBUG_CFGACCESS\r\nprintk(KERN_INFO "grpci2_write_config: [%02x:%02x:%x] ofs=%d size=%d "\r\n"val=%x\n", busno, PCI_SLOT(devfn), PCI_FUNC(devfn),\r\nwhere, size, val);\r\n#endif\r\nswitch (size) {\r\ndefault:\r\nreturn -EINVAL;\r\ncase 1:\r\nreturn grpci2_cfg_w8(priv, busno, devfn, where, val);\r\ncase 2:\r\nreturn grpci2_cfg_w16(priv, busno, devfn, where, val);\r\ncase 4:\r\nreturn grpci2_cfg_w32(priv, busno, devfn, where, val);\r\n}\r\n}\r\nstatic void grpci2_mask_irq(struct irq_data *data)\r\n{\r\nunsigned long flags;\r\nunsigned int irqidx;\r\nstruct grpci2_priv *priv = grpci2priv;\r\nirqidx = (unsigned int)data->chip_data - 1;\r\nif (irqidx > 3)\r\nreturn;\r\nspin_lock_irqsave(&grpci2_dev_lock, flags);\r\nREGSTORE(priv->regs->ctrl, REGLOAD(priv->regs->ctrl) & ~(1 << irqidx));\r\nspin_unlock_irqrestore(&grpci2_dev_lock, flags);\r\n}\r\nstatic void grpci2_unmask_irq(struct irq_data *data)\r\n{\r\nunsigned long flags;\r\nunsigned int irqidx;\r\nstruct grpci2_priv *priv = grpci2priv;\r\nirqidx = (unsigned int)data->chip_data - 1;\r\nif (irqidx > 3)\r\nreturn;\r\nspin_lock_irqsave(&grpci2_dev_lock, flags);\r\nREGSTORE(priv->regs->ctrl, REGLOAD(priv->regs->ctrl) | (1 << irqidx));\r\nspin_unlock_irqrestore(&grpci2_dev_lock, flags);\r\n}\r\nstatic unsigned int grpci2_startup_irq(struct irq_data *data)\r\n{\r\ngrpci2_unmask_irq(data);\r\nreturn 0;\r\n}\r\nstatic void grpci2_shutdown_irq(struct irq_data *data)\r\n{\r\ngrpci2_mask_irq(data);\r\n}\r\nstatic void grpci2_pci_flow_irq(struct irq_desc *desc)\r\n{\r\nstruct grpci2_priv *priv = grpci2priv;\r\nint i, ack = 0;\r\nunsigned int ctrl, sts_cap, pci_ints;\r\nctrl = REGLOAD(priv->regs->ctrl);\r\nsts_cap = REGLOAD(priv->regs->sts_cap);\r\nif (sts_cap & STS_ERR_IRQ) {\r\ngeneric_handle_irq(priv->virq_err);\r\nack = 1;\r\n}\r\npci_ints = ((~sts_cap) >> STS_INTSTS_BIT) & ctrl & CTRL_HOSTINT;\r\nif (pci_ints) {\r\nfor (i = 0; i < 4; i++) {\r\nif (pci_ints & (1 << i))\r\ngeneric_handle_irq(priv->irq_map[i]);\r\n}\r\nack = 1;\r\n}\r\nif ((priv->irq_mode == 0) && (sts_cap & (STS_IDMA | STS_IDMAERR))) {\r\ngeneric_handle_irq(priv->virq_dma);\r\nack = 1;\r\n}\r\nif (ack)\r\ndesc->irq_data.chip->irq_eoi(&desc->irq_data);\r\n}\r\nstatic unsigned int grpci2_build_device_irq(unsigned int irq)\r\n{\r\nunsigned int virq = 0, pil;\r\npil = 1 << 8;\r\nvirq = irq_alloc(irq, pil);\r\nif (virq == 0)\r\ngoto out;\r\nirq_set_chip_and_handler_name(virq, &grpci2_irq, handle_simple_irq,\r\n"pcilvl");\r\nirq_set_chip_data(virq, (void *)irq);\r\nout:\r\nreturn virq;\r\n}\r\nstatic void grpci2_hw_init(struct grpci2_priv *priv)\r\n{\r\nu32 ahbadr, pciadr, bar_sz, capptr, io_map, data;\r\nstruct grpci2_regs __iomem *regs = priv->regs;\r\nint i;\r\nstruct grpci2_barcfg *barcfg = priv->tgtbars;\r\nif (priv->do_reset) {\r\nprintk(KERN_INFO "GRPCI2: Resetting PCI bus\n");\r\nREGSTORE(regs->ctrl, CTRL_RESET);\r\nssleep(1);\r\n}\r\nREGSTORE(regs->ctrl, 0);\r\nREGSTORE(regs->sts_cap, ~0);\r\nREGSTORE(regs->dma_ctrl, 0);\r\nREGSTORE(regs->dma_bdbase, 0);\r\nREGSTORE(regs->io_map, REGLOAD(regs->io_map) & 0x0000ffff);\r\nfor (i = 0; i < 16; i++)\r\nREGSTORE(regs->ahbmst_map[i], priv->pci_area);\r\ngrpci2_cfg_r32(priv, TGT, 0, PCI_VENDOR_ID, &priv->pciid);\r\ngrpci2_cfg_r8(priv, TGT, 0, PCI_CAPABILITY_LIST, &capptr);\r\ngrpci2_cfg_r32(priv, TGT, 0, capptr+CAP9_IOMAP_OFS, &io_map);\r\nio_map = (io_map & ~0x1) | (priv->bt_enabled ? 1 : 0);\r\ngrpci2_cfg_w32(priv, TGT, 0, capptr+CAP9_IOMAP_OFS, io_map);\r\nfor (i = 0; i < 6; i++) {\r\nif (barcfg[i].pciadr != ~0 && barcfg[i].ahbadr != ~0) {\r\nahbadr = barcfg[i].ahbadr;\r\npciadr = barcfg[i].pciadr;\r\nbar_sz = ((pciadr - 1) & ~pciadr) + 1;\r\n} else {\r\nif (i == 0) {\r\nbar_sz = 0xf0000008;\r\nahbadr = 0xf0000000 & (u32)__pa(PAGE_ALIGN(\r\n(unsigned long) &_end));\r\npciadr = ahbadr;\r\n} else {\r\nbar_sz = 0;\r\nahbadr = 0;\r\npciadr = 0;\r\n}\r\n}\r\ngrpci2_cfg_w32(priv, TGT, 0, capptr+CAP9_BARSIZE_OFS+i*4,\r\nbar_sz);\r\ngrpci2_cfg_w32(priv, TGT, 0, PCI_BASE_ADDRESS_0+i*4, pciadr);\r\ngrpci2_cfg_w32(priv, TGT, 0, capptr+CAP9_BAR_OFS+i*4, ahbadr);\r\nprintk(KERN_INFO " TGT BAR[%d]: 0x%08x (PCI)-> 0x%08x\n",\r\ni, pciadr, ahbadr);\r\n}\r\ngrpci2_cfg_r32(priv, TGT, 0, PCI_COMMAND, &data);\r\ndata |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\r\ngrpci2_cfg_w32(priv, TGT, 0, PCI_COMMAND, data);\r\nREGSTORE(regs->ctrl, CTRL_ER | CTRL_PE);\r\n}\r\nstatic irqreturn_t grpci2_jump_interrupt(int irq, void *arg)\r\n{\r\nprintk(KERN_ERR "GRPCI2: Jump IRQ happened\n");\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t grpci2_err_interrupt(int irq, void *arg)\r\n{\r\nstruct grpci2_priv *priv = arg;\r\nstruct grpci2_regs __iomem *regs = priv->regs;\r\nunsigned int status;\r\nstatus = REGLOAD(regs->sts_cap);\r\nif ((status & STS_ERR_IRQ) == 0)\r\nreturn IRQ_NONE;\r\nif (status & STS_IPARERR)\r\nprintk(KERN_ERR "GRPCI2: Parity Error\n");\r\nif (status & STS_ITGTABRT)\r\nprintk(KERN_ERR "GRPCI2: Target Abort\n");\r\nif (status & STS_IMSTABRT)\r\nprintk(KERN_ERR "GRPCI2: Master Abort\n");\r\nif (status & STS_ISYSERR)\r\nprintk(KERN_ERR "GRPCI2: System Error\n");\r\nREGSTORE(regs->sts_cap, status & STS_ERR_IRQ);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int grpci2_of_probe(struct platform_device *ofdev)\r\n{\r\nstruct grpci2_regs __iomem *regs;\r\nstruct grpci2_priv *priv;\r\nint err, i, len;\r\nconst int *tmp;\r\nunsigned int capability;\r\nif (grpci2priv) {\r\nprintk(KERN_ERR "GRPCI2: only one GRPCI2 core supported\n");\r\nreturn -ENODEV;\r\n}\r\nif (ofdev->num_resources < 3) {\r\nprintk(KERN_ERR "GRPCI2: not enough APB/AHB resources\n");\r\nreturn -EIO;\r\n}\r\nregs = of_ioremap(&ofdev->resource[0], 0,\r\nresource_size(&ofdev->resource[0]),\r\n"grlib-grpci2 regs");\r\nif (regs == NULL) {\r\nprintk(KERN_ERR "GRPCI2: ioremap failed\n");\r\nreturn -EIO;\r\n}\r\ncapability = REGLOAD(regs->sts_cap);\r\nif ((capability & STS_HOST) || !(capability & STS_MST)) {\r\nprintk(KERN_INFO "GRPCI2: not in host system slot\n");\r\nerr = -EIO;\r\ngoto err1;\r\n}\r\npriv = grpci2priv = kzalloc(sizeof(struct grpci2_priv), GFP_KERNEL);\r\nif (grpci2priv == NULL) {\r\nerr = -ENOMEM;\r\ngoto err1;\r\n}\r\npriv->regs = regs;\r\npriv->irq = ofdev->archdata.irqs[0];\r\npriv->irq_mode = (capability & STS_IRQMODE) >> STS_IRQMODE_BIT;\r\nprintk(KERN_INFO "GRPCI2: host found at %p, irq%d\n", regs, priv->irq);\r\npriv->bt_enabled = 1;\r\ntmp = of_get_property(ofdev->dev.of_node, "barcfg", &len);\r\nif (tmp && (len == 2*4*6))\r\nmemcpy(priv->tgtbars, tmp, 2*4*6);\r\nelse\r\nmemset(priv->tgtbars, -1, 2*4*6);\r\ntmp = of_get_property(ofdev->dev.of_node, "irq_mask", &len);\r\nif (tmp && (len == 4))\r\npriv->do_reset = *tmp;\r\nelse\r\npriv->irq_mask = 0xf;\r\ntmp = of_get_property(ofdev->dev.of_node, "reset", &len);\r\nif (tmp && (len == 4))\r\npriv->do_reset = *tmp;\r\nelse\r\npriv->do_reset = 0;\r\npriv->pci_area = ofdev->resource[1].start;\r\npriv->pci_area_end = ofdev->resource[1].end+1;\r\npriv->pci_io = ofdev->resource[2].start;\r\npriv->pci_conf = ofdev->resource[2].start + 0x10000;\r\npriv->pci_conf_end = priv->pci_conf + 0x10000;\r\npriv->pci_io_va = (unsigned long)ioremap(priv->pci_io, 0x10000);\r\nif (!priv->pci_io_va) {\r\nerr = -EIO;\r\ngoto err2;\r\n}\r\nprintk(KERN_INFO\r\n"GRPCI2: MEMORY SPACE [0x%08lx - 0x%08lx]\n"\r\n" I/O SPACE [0x%08lx - 0x%08lx]\n"\r\n" CONFIG SPACE [0x%08lx - 0x%08lx]\n",\r\npriv->pci_area, priv->pci_area_end-1,\r\npriv->pci_io, priv->pci_conf-1,\r\npriv->pci_conf, priv->pci_conf_end-1);\r\nmemset(&priv->info.io_space, 0, sizeof(struct resource));\r\npriv->info.io_space.name = "GRPCI2 PCI I/O Space";\r\npriv->info.io_space.start = priv->pci_io_va + 0x1000;\r\npriv->info.io_space.end = priv->pci_io_va + 0x10000 - 1;\r\npriv->info.io_space.flags = IORESOURCE_IO;\r\nmemset(&priv->info.mem_space, 0, sizeof(struct resource));\r\npriv->info.mem_space.name = "GRPCI2 PCI MEM Space";\r\npriv->info.mem_space.start = priv->pci_area;\r\npriv->info.mem_space.end = priv->pci_area_end - 1;\r\npriv->info.mem_space.flags = IORESOURCE_MEM;\r\nif (request_resource(&iomem_resource, &priv->info.mem_space) < 0)\r\ngoto err3;\r\nif (request_resource(&ioport_resource, &priv->info.io_space) < 0)\r\ngoto err4;\r\npriv->info.busn.name = "GRPCI2 busn";\r\npriv->info.busn.start = 0;\r\npriv->info.busn.end = 255;\r\ngrpci2_hw_init(priv);\r\nif (priv->irq_mode < 2) {\r\nleon_update_virq_handling(priv->irq, grpci2_pci_flow_irq,\r\n"pcilvl", 0);\r\npriv->irq_map[0] = grpci2_build_device_irq(1);\r\npriv->irq_map[1] = grpci2_build_device_irq(2);\r\npriv->irq_map[2] = grpci2_build_device_irq(3);\r\npriv->irq_map[3] = grpci2_build_device_irq(4);\r\npriv->virq_err = grpci2_build_device_irq(5);\r\nif (priv->irq_mode & 1)\r\npriv->virq_dma = ofdev->archdata.irqs[1];\r\nelse\r\npriv->virq_dma = grpci2_build_device_irq(6);\r\nerr = request_irq(priv->irq, grpci2_jump_interrupt, 0,\r\n"GRPCI2_JUMP", priv);\r\nif (err)\r\nprintk(KERN_ERR "GRPCI2: ERR IRQ request failed\n");\r\n} else {\r\nfor (i = 0; i < 4; i++) {\r\nleon_update_virq_handling(ofdev->archdata.irqs[i],\r\nhandle_fasteoi_irq, "pcilvl",\r\n1);\r\npriv->irq_map[i] = ofdev->archdata.irqs[i];\r\n}\r\npriv->virq_err = priv->irq_map[0];\r\nif (priv->irq_mode & 1)\r\npriv->virq_dma = ofdev->archdata.irqs[4];\r\nelse\r\npriv->virq_dma = priv->irq_map[0];\r\nREGSTORE(regs->ctrl, REGLOAD(regs->ctrl)|(priv->irq_mask&0xf));\r\n}\r\nerr = request_irq(priv->virq_err, grpci2_err_interrupt, IRQF_SHARED,\r\n"GRPCI2_ERR", priv);\r\nif (err) {\r\nprintk(KERN_DEBUG "GRPCI2: ERR VIRQ request failed: %d\n", err);\r\ngoto err5;\r\n}\r\nREGSTORE(regs->ctrl, REGLOAD(regs->ctrl) | CTRL_EI | CTRL_SI);\r\npriv->info.ops = &grpci2_ops;\r\npriv->info.map_irq = grpci2_map_irq;\r\nleon_pci_init(ofdev, &priv->info);\r\nreturn 0;\r\nerr5:\r\nrelease_resource(&priv->info.io_space);\r\nerr4:\r\nrelease_resource(&priv->info.mem_space);\r\nerr3:\r\nerr = -ENOMEM;\r\niounmap((void __iomem *)priv->pci_io_va);\r\nerr2:\r\nkfree(priv);\r\nerr1:\r\nof_iounmap(&ofdev->resource[0], regs,\r\nresource_size(&ofdev->resource[0]));\r\nreturn err;\r\n}\r\nstatic int __init grpci2_init(void)\r\n{\r\nreturn platform_driver_register(&grpci2_of_driver);\r\n}
