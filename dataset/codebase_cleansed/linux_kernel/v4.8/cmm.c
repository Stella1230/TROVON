static long cmm_alloc_pages(long nr, long *counter,\r\nstruct cmm_page_array **list)\r\n{\r\nstruct cmm_page_array *pa, *npa;\r\nunsigned long addr;\r\nwhile (nr) {\r\naddr = __get_free_page(GFP_NOIO);\r\nif (!addr)\r\nbreak;\r\nspin_lock(&cmm_lock);\r\npa = *list;\r\nif (!pa || pa->index >= CMM_NR_PAGES) {\r\nspin_unlock(&cmm_lock);\r\nnpa = (struct cmm_page_array *)\r\n__get_free_page(GFP_NOIO);\r\nif (!npa) {\r\nfree_page(addr);\r\nbreak;\r\n}\r\nspin_lock(&cmm_lock);\r\npa = *list;\r\nif (!pa || pa->index >= CMM_NR_PAGES) {\r\nnpa->next = pa;\r\nnpa->index = 0;\r\npa = npa;\r\n*list = pa;\r\n} else\r\nfree_page((unsigned long) npa);\r\n}\r\ndiag10_range(addr >> PAGE_SHIFT, 1);\r\npa->pages[pa->index++] = addr;\r\n(*counter)++;\r\nspin_unlock(&cmm_lock);\r\nnr--;\r\n}\r\nreturn nr;\r\n}\r\nstatic long cmm_free_pages(long nr, long *counter, struct cmm_page_array **list)\r\n{\r\nstruct cmm_page_array *pa;\r\nunsigned long addr;\r\nspin_lock(&cmm_lock);\r\npa = *list;\r\nwhile (nr) {\r\nif (!pa || pa->index <= 0)\r\nbreak;\r\naddr = pa->pages[--pa->index];\r\nif (pa->index == 0) {\r\npa = pa->next;\r\nfree_page((unsigned long) *list);\r\n*list = pa;\r\n}\r\nfree_page(addr);\r\n(*counter)--;\r\nnr--;\r\n}\r\nspin_unlock(&cmm_lock);\r\nreturn nr;\r\n}\r\nstatic int cmm_oom_notify(struct notifier_block *self,\r\nunsigned long dummy, void *parm)\r\n{\r\nunsigned long *freed = parm;\r\nlong nr = 256;\r\nnr = cmm_free_pages(nr, &cmm_timed_pages, &cmm_timed_page_list);\r\nif (nr > 0)\r\nnr = cmm_free_pages(nr, &cmm_pages, &cmm_page_list);\r\ncmm_pages_target = cmm_pages;\r\ncmm_timed_pages_target = cmm_timed_pages;\r\n*freed += 256 - nr;\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int cmm_thread(void *dummy)\r\n{\r\nint rc;\r\nwhile (1) {\r\nrc = wait_event_interruptible(cmm_thread_wait,\r\n(!cmm_suspended && (cmm_pages != cmm_pages_target ||\r\ncmm_timed_pages != cmm_timed_pages_target)) ||\r\nkthread_should_stop());\r\nif (kthread_should_stop() || rc == -ERESTARTSYS) {\r\ncmm_pages_target = cmm_pages;\r\ncmm_timed_pages_target = cmm_timed_pages;\r\nbreak;\r\n}\r\nif (cmm_pages_target > cmm_pages) {\r\nif (cmm_alloc_pages(1, &cmm_pages, &cmm_page_list))\r\ncmm_pages_target = cmm_pages;\r\n} else if (cmm_pages_target < cmm_pages) {\r\ncmm_free_pages(1, &cmm_pages, &cmm_page_list);\r\n}\r\nif (cmm_timed_pages_target > cmm_timed_pages) {\r\nif (cmm_alloc_pages(1, &cmm_timed_pages,\r\n&cmm_timed_page_list))\r\ncmm_timed_pages_target = cmm_timed_pages;\r\n} else if (cmm_timed_pages_target < cmm_timed_pages) {\r\ncmm_free_pages(1, &cmm_timed_pages,\r\n&cmm_timed_page_list);\r\n}\r\nif (cmm_timed_pages > 0 && !timer_pending(&cmm_timer))\r\ncmm_set_timer();\r\n}\r\nreturn 0;\r\n}\r\nstatic void cmm_kick_thread(void)\r\n{\r\nwake_up(&cmm_thread_wait);\r\n}\r\nstatic void cmm_set_timer(void)\r\n{\r\nif (cmm_timed_pages_target <= 0 || cmm_timeout_seconds <= 0) {\r\nif (timer_pending(&cmm_timer))\r\ndel_timer(&cmm_timer);\r\nreturn;\r\n}\r\nif (timer_pending(&cmm_timer)) {\r\nif (mod_timer(&cmm_timer, jiffies + cmm_timeout_seconds*HZ))\r\nreturn;\r\n}\r\ncmm_timer.function = cmm_timer_fn;\r\ncmm_timer.data = 0;\r\ncmm_timer.expires = jiffies + cmm_timeout_seconds*HZ;\r\nadd_timer(&cmm_timer);\r\n}\r\nstatic void cmm_timer_fn(unsigned long ignored)\r\n{\r\nlong nr;\r\nnr = cmm_timed_pages_target - cmm_timeout_pages;\r\nif (nr < 0)\r\ncmm_timed_pages_target = 0;\r\nelse\r\ncmm_timed_pages_target = nr;\r\ncmm_kick_thread();\r\ncmm_set_timer();\r\n}\r\nstatic void cmm_set_pages(long nr)\r\n{\r\ncmm_pages_target = nr;\r\ncmm_kick_thread();\r\n}\r\nstatic long cmm_get_pages(void)\r\n{\r\nreturn cmm_pages;\r\n}\r\nstatic void cmm_add_timed_pages(long nr)\r\n{\r\ncmm_timed_pages_target += nr;\r\ncmm_kick_thread();\r\n}\r\nstatic long cmm_get_timed_pages(void)\r\n{\r\nreturn cmm_timed_pages;\r\n}\r\nstatic void cmm_set_timeout(long nr, long seconds)\r\n{\r\ncmm_timeout_pages = nr;\r\ncmm_timeout_seconds = seconds;\r\ncmm_set_timer();\r\n}\r\nstatic int cmm_skip_blanks(char *cp, char **endp)\r\n{\r\nchar *str;\r\nfor (str = cp; *str == ' ' || *str == '\t'; str++)\r\n;\r\n*endp = str;\r\nreturn str != cp;\r\n}\r\nstatic int cmm_pages_handler(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nchar buf[16], *p;\r\nunsigned int len;\r\nlong nr;\r\nif (!*lenp || (*ppos && !write)) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (write) {\r\nlen = *lenp;\r\nif (copy_from_user(buf, buffer,\r\nlen > sizeof(buf) ? sizeof(buf) : len))\r\nreturn -EFAULT;\r\nbuf[sizeof(buf) - 1] = '\0';\r\ncmm_skip_blanks(buf, &p);\r\nnr = simple_strtoul(p, &p, 0);\r\nif (ctl == &cmm_table[0])\r\ncmm_set_pages(nr);\r\nelse\r\ncmm_add_timed_pages(nr);\r\n} else {\r\nif (ctl == &cmm_table[0])\r\nnr = cmm_get_pages();\r\nelse\r\nnr = cmm_get_timed_pages();\r\nlen = sprintf(buf, "%ld\n", nr);\r\nif (len > *lenp)\r\nlen = *lenp;\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\n}\r\n*lenp = len;\r\n*ppos += len;\r\nreturn 0;\r\n}\r\nstatic int cmm_timeout_handler(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nchar buf[64], *p;\r\nlong nr, seconds;\r\nunsigned int len;\r\nif (!*lenp || (*ppos && !write)) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (write) {\r\nlen = *lenp;\r\nif (copy_from_user(buf, buffer,\r\nlen > sizeof(buf) ? sizeof(buf) : len))\r\nreturn -EFAULT;\r\nbuf[sizeof(buf) - 1] = '\0';\r\ncmm_skip_blanks(buf, &p);\r\nnr = simple_strtoul(p, &p, 0);\r\ncmm_skip_blanks(p, &p);\r\nseconds = simple_strtoul(p, &p, 0);\r\ncmm_set_timeout(nr, seconds);\r\n} else {\r\nlen = sprintf(buf, "%ld %ld\n",\r\ncmm_timeout_pages, cmm_timeout_seconds);\r\nif (len > *lenp)\r\nlen = *lenp;\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\n}\r\n*lenp = len;\r\n*ppos += len;\r\nreturn 0;\r\n}\r\nstatic void cmm_smsg_target(const char *from, char *msg)\r\n{\r\nlong nr, seconds;\r\nif (strlen(sender) > 0 && strcmp(from, sender) != 0)\r\nreturn;\r\nif (!cmm_skip_blanks(msg + strlen(SMSG_PREFIX), &msg))\r\nreturn;\r\nif (strncmp(msg, "SHRINK", 6) == 0) {\r\nif (!cmm_skip_blanks(msg + 6, &msg))\r\nreturn;\r\nnr = simple_strtoul(msg, &msg, 0);\r\ncmm_skip_blanks(msg, &msg);\r\nif (*msg == '\0')\r\ncmm_set_pages(nr);\r\n} else if (strncmp(msg, "RELEASE", 7) == 0) {\r\nif (!cmm_skip_blanks(msg + 7, &msg))\r\nreturn;\r\nnr = simple_strtoul(msg, &msg, 0);\r\ncmm_skip_blanks(msg, &msg);\r\nif (*msg == '\0')\r\ncmm_add_timed_pages(nr);\r\n} else if (strncmp(msg, "REUSE", 5) == 0) {\r\nif (!cmm_skip_blanks(msg + 5, &msg))\r\nreturn;\r\nnr = simple_strtoul(msg, &msg, 0);\r\nif (!cmm_skip_blanks(msg, &msg))\r\nreturn;\r\nseconds = simple_strtoul(msg, &msg, 0);\r\ncmm_skip_blanks(msg, &msg);\r\nif (*msg == '\0')\r\ncmm_set_timeout(nr, seconds);\r\n}\r\n}\r\nstatic int cmm_suspend(void)\r\n{\r\ncmm_suspended = 1;\r\ncmm_free_pages(cmm_pages, &cmm_pages, &cmm_page_list);\r\ncmm_free_pages(cmm_timed_pages, &cmm_timed_pages, &cmm_timed_page_list);\r\nreturn 0;\r\n}\r\nstatic int cmm_resume(void)\r\n{\r\ncmm_suspended = 0;\r\ncmm_kick_thread();\r\nreturn 0;\r\n}\r\nstatic int cmm_power_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nswitch (event) {\r\ncase PM_POST_HIBERNATION:\r\nreturn cmm_resume();\r\ncase PM_HIBERNATION_PREPARE:\r\nreturn cmm_suspend();\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nstatic int __init cmm_init(void)\r\n{\r\nint rc = -ENOMEM;\r\ncmm_sysctl_header = register_sysctl_table(cmm_dir_table);\r\nif (!cmm_sysctl_header)\r\ngoto out_sysctl;\r\n#ifdef CONFIG_CMM_IUCV\r\nif (sender) {\r\nint len = strlen(sender);\r\nwhile (len--)\r\nsender[len] = toupper(sender[len]);\r\n} else {\r\nsender = cmm_default_sender;\r\n}\r\nrc = smsg_register_callback(SMSG_PREFIX, cmm_smsg_target);\r\nif (rc < 0)\r\ngoto out_smsg;\r\n#endif\r\nrc = register_oom_notifier(&cmm_oom_nb);\r\nif (rc < 0)\r\ngoto out_oom_notify;\r\nrc = register_pm_notifier(&cmm_power_notifier);\r\nif (rc)\r\ngoto out_pm;\r\ncmm_thread_ptr = kthread_run(cmm_thread, NULL, "cmmthread");\r\nif (!IS_ERR(cmm_thread_ptr))\r\nreturn 0;\r\nrc = PTR_ERR(cmm_thread_ptr);\r\nunregister_pm_notifier(&cmm_power_notifier);\r\nout_pm:\r\nunregister_oom_notifier(&cmm_oom_nb);\r\nout_oom_notify:\r\n#ifdef CONFIG_CMM_IUCV\r\nsmsg_unregister_callback(SMSG_PREFIX, cmm_smsg_target);\r\nout_smsg:\r\n#endif\r\nunregister_sysctl_table(cmm_sysctl_header);\r\nout_sysctl:\r\ndel_timer_sync(&cmm_timer);\r\nreturn rc;\r\n}\r\nstatic void __exit cmm_exit(void)\r\n{\r\nunregister_sysctl_table(cmm_sysctl_header);\r\n#ifdef CONFIG_CMM_IUCV\r\nsmsg_unregister_callback(SMSG_PREFIX, cmm_smsg_target);\r\n#endif\r\nunregister_pm_notifier(&cmm_power_notifier);\r\nunregister_oom_notifier(&cmm_oom_nb);\r\nkthread_stop(cmm_thread_ptr);\r\ndel_timer_sync(&cmm_timer);\r\ncmm_free_pages(cmm_pages, &cmm_pages, &cmm_page_list);\r\ncmm_free_pages(cmm_timed_pages, &cmm_timed_pages, &cmm_timed_page_list);\r\n}
