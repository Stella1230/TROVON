static unsigned long pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct pll_clock *pll_clock = to_pll_clock(hw);\r\nint mul = 1 << (readb(pll_clock->pllcr) & 3);\r\nreturn parent_rate * mul;\r\n}\r\nstatic long pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nint i, m = -1;\r\nlong offset[3];\r\nif (rate > MAX_FREQ)\r\nrate = MAX_FREQ;\r\nif (rate < MIN_FREQ)\r\nrate = MIN_FREQ;\r\nfor (i = 0; i < 3; i++)\r\noffset[i] = abs(rate - (*prate * (1 << i)));\r\nfor (i = 0; i < 3; i++)\r\nif (m < 0)\r\nm = i;\r\nelse\r\nm = (offset[i] < offset[m])?i:m;\r\nreturn *prate * (1 << m);\r\n}\r\nstatic int pll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nint pll;\r\nunsigned char val;\r\nunsigned long flags;\r\nstruct pll_clock *pll_clock = to_pll_clock(hw);\r\npll = ((rate / parent_rate) / 2) & 0x03;\r\nspin_lock_irqsave(&clklock, flags);\r\nval = readb(pll_clock->sckcr);\r\nval |= 0x08;\r\nwriteb(val, pll_clock->sckcr);\r\nval = readb(pll_clock->pllcr);\r\nval &= ~0x03;\r\nval |= pll;\r\nwriteb(val, pll_clock->pllcr);\r\nspin_unlock_irqrestore(&clklock, flags);\r\nreturn 0;\r\n}\r\nstatic void __init h8s2678_pll_clk_setup(struct device_node *node)\r\n{\r\nunsigned int num_parents;\r\nstruct clk *clk;\r\nconst char *clk_name = node->name;\r\nconst char *parent_name;\r\nstruct pll_clock *pll_clock;\r\nstruct clk_init_data init;\r\nnum_parents = of_clk_get_parent_count(node);\r\nif (!num_parents) {\r\npr_err("%s: no parent found", clk_name);\r\nreturn;\r\n}\r\npll_clock = kzalloc(sizeof(*pll_clock), GFP_KERNEL);\r\nif (!pll_clock)\r\nreturn;\r\npll_clock->sckcr = of_iomap(node, 0);\r\nif (pll_clock->sckcr == NULL) {\r\npr_err("%s: failed to map divide register", clk_name);\r\ngoto free_clock;\r\n}\r\npll_clock->pllcr = of_iomap(node, 1);\r\nif (pll_clock->pllcr == NULL) {\r\npr_err("%s: failed to map multiply register", clk_name);\r\ngoto unmap_sckcr;\r\n}\r\nparent_name = of_clk_get_parent_name(node, 0);\r\ninit.name = clk_name;\r\ninit.ops = &pll_ops;\r\ninit.flags = CLK_IS_BASIC;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\npll_clock->hw.init = &init;\r\nclk = clk_register(NULL, &pll_clock->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: failed to register %s div clock (%ld)\n",\r\n__func__, clk_name, PTR_ERR(clk));\r\ngoto unmap_pllcr;\r\n}\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nreturn;\r\nunmap_pllcr:\r\niounmap(pll_clock->pllcr);\r\nunmap_sckcr:\r\niounmap(pll_clock->sckcr);\r\nfree_clock:\r\nkfree(pll_clock);\r\n}
