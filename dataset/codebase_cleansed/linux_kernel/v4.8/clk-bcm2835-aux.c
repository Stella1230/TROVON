static int bcm2835_aux_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct clk_onecell_data *onecell;\r\nconst char *parent;\r\nstruct clk *parent_clk;\r\nstruct resource *res;\r\nvoid __iomem *reg, *gate;\r\nparent_clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(parent_clk))\r\nreturn PTR_ERR(parent_clk);\r\nparent = __clk_get_name(parent_clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nonecell = devm_kmalloc(dev, sizeof(*onecell), GFP_KERNEL);\r\nif (!onecell)\r\nreturn -ENOMEM;\r\nonecell->clk_num = BCM2835_AUX_CLOCK_COUNT;\r\nonecell->clks = devm_kcalloc(dev, BCM2835_AUX_CLOCK_COUNT,\r\nsizeof(*onecell->clks), GFP_KERNEL);\r\nif (!onecell->clks)\r\nreturn -ENOMEM;\r\ngate = reg + BCM2835_AUXENB;\r\nonecell->clks[BCM2835_AUX_CLOCK_UART] =\r\nclk_register_gate(dev, "aux_uart", parent, 0, gate, 0, 0, NULL);\r\nonecell->clks[BCM2835_AUX_CLOCK_SPI1] =\r\nclk_register_gate(dev, "aux_spi1", parent, 0, gate, 1, 0, NULL);\r\nonecell->clks[BCM2835_AUX_CLOCK_SPI2] =\r\nclk_register_gate(dev, "aux_spi2", parent, 0, gate, 2, 0, NULL);\r\nof_clk_add_provider(pdev->dev.of_node, of_clk_src_onecell_get, onecell);\r\nreturn 0;\r\n}
