static int offb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nstruct offb_par *par = (struct offb_par *) info->par;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 *pal = info->pseudo_palette;\r\nu32 cr = red >> (16 - info->var.red.length);\r\nu32 cg = green >> (16 - info->var.green.length);\r\nu32 cb = blue >> (16 - info->var.blue.length);\r\nu32 value;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nvalue = (cr << info->var.red.offset) |\r\n(cg << info->var.green.offset) |\r\n(cb << info->var.blue.offset);\r\nif (info->var.transp.length > 0) {\r\nu32 mask = (1 << info->var.transp.length) - 1;\r\nmask <<= info->var.transp.offset;\r\nvalue |= mask;\r\n}\r\npal[regno] = value;\r\nreturn 0;\r\n}\r\nif (regno > 255)\r\nreturn -EINVAL;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nif (!par->cmap_adr)\r\nreturn 0;\r\nswitch (par->cmap_type) {\r\ncase cmap_simple:\r\nwriteb(regno, par->cmap_adr);\r\nwriteb(red, par->cmap_data);\r\nwriteb(green, par->cmap_data);\r\nwriteb(blue, par->cmap_data);\r\nbreak;\r\ncase cmap_M3A:\r\nout_le32(par->cmap_adr + 0x58,\r\nin_le32(par->cmap_adr + 0x58) & ~0x20);\r\ncase cmap_r128:\r\nout_8(par->cmap_adr + 0xb0, regno);\r\nout_le32(par->cmap_adr + 0xb4,\r\n(red << 16 | green << 8 | blue));\r\nbreak;\r\ncase cmap_M3B:\r\nout_le32(par->cmap_adr + 0x58,\r\nin_le32(par->cmap_adr + 0x58) | 0x20);\r\nout_8(par->cmap_adr + 0xb0, regno);\r\nout_le32(par->cmap_adr + 0xb4, (red << 16 | green << 8 | blue));\r\nbreak;\r\ncase cmap_radeon:\r\nout_8(par->cmap_adr + 0xb0, regno);\r\nout_le32(par->cmap_adr + 0xb4, (red << 16 | green << 8 | blue));\r\nbreak;\r\ncase cmap_gxt2000:\r\nout_le32(((unsigned __iomem *) par->cmap_adr) + regno,\r\n(red << 16 | green << 8 | blue));\r\nbreak;\r\ncase cmap_avivo:\r\nwritel(1, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\r\nwriteb(regno, par->cmap_adr + AVIVO_DC_LUT_RW_INDEX);\r\nwritel(((red) << 22) | ((green) << 12) | ((blue) << 2),\r\npar->cmap_adr + AVIVO_DC_LUT_30_COLOR);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\r\nwriteb(regno, par->cmap_adr + AVIVO_DC_LUT_RW_INDEX);\r\nwritel(((red) << 22) | ((green) << 12) | ((blue) << 2),\r\npar->cmap_adr + AVIVO_DC_LUT_30_COLOR);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int offb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct offb_par *par = (struct offb_par *) info->par;\r\nint i, j;\r\nif (!par->cmap_adr)\r\nreturn 0;\r\nif (!par->blanked)\r\nif (!blank)\r\nreturn 0;\r\npar->blanked = blank;\r\nif (blank)\r\nfor (i = 0; i < 256; i++) {\r\nswitch (par->cmap_type) {\r\ncase cmap_simple:\r\nwriteb(i, par->cmap_adr);\r\nfor (j = 0; j < 3; j++)\r\nwriteb(0, par->cmap_data);\r\nbreak;\r\ncase cmap_M3A:\r\nout_le32(par->cmap_adr + 0x58,\r\nin_le32(par->cmap_adr + 0x58) & ~0x20);\r\ncase cmap_r128:\r\nout_8(par->cmap_adr + 0xb0, i);\r\nout_le32(par->cmap_adr + 0xb4, 0);\r\nbreak;\r\ncase cmap_M3B:\r\nout_le32(par->cmap_adr + 0x58,\r\nin_le32(par->cmap_adr + 0x58) | 0x20);\r\nout_8(par->cmap_adr + 0xb0, i);\r\nout_le32(par->cmap_adr + 0xb4, 0);\r\nbreak;\r\ncase cmap_radeon:\r\nout_8(par->cmap_adr + 0xb0, i);\r\nout_le32(par->cmap_adr + 0xb4, 0);\r\nbreak;\r\ncase cmap_gxt2000:\r\nout_le32(((unsigned __iomem *) par->cmap_adr) + i,\r\n0);\r\nbreak;\r\ncase cmap_avivo:\r\nwritel(1, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\r\nwriteb(i, par->cmap_adr + AVIVO_DC_LUT_RW_INDEX);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUT_30_COLOR);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\r\nwriteb(i, par->cmap_adr + AVIVO_DC_LUT_RW_INDEX);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUT_30_COLOR);\r\nbreak;\r\n}\r\n} else\r\nfb_set_cmap(&info->cmap, info);\r\nreturn 0;\r\n}\r\nstatic int offb_set_par(struct fb_info *info)\r\n{\r\nstruct offb_par *par = (struct offb_par *) info->par;\r\nif (par->cmap_type == cmap_avivo) {\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUTA_CONTROL);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUTA_BLACK_OFFSET_BLUE);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUTA_BLACK_OFFSET_GREEN);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUTA_BLACK_OFFSET_RED);\r\nwritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTA_WHITE_OFFSET_BLUE);\r\nwritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTA_WHITE_OFFSET_GREEN);\r\nwritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTA_WHITE_OFFSET_RED);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUTB_CONTROL);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUTB_BLACK_OFFSET_BLUE);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUTB_BLACK_OFFSET_GREEN);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUTB_BLACK_OFFSET_RED);\r\nwritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTB_WHITE_OFFSET_BLUE);\r\nwritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTB_WHITE_OFFSET_GREEN);\r\nwritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTB_WHITE_OFFSET_RED);\r\nwritel(1, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUT_RW_MODE);\r\nwritel(0x0000003f, par->cmap_adr + AVIVO_DC_LUT_WRITE_EN_MASK);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\r\nwritel(0, par->cmap_adr + AVIVO_DC_LUT_RW_MODE);\r\nwritel(0x0000003f, par->cmap_adr + AVIVO_DC_LUT_WRITE_EN_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic void offb_destroy(struct fb_info *info)\r\n{\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\nrelease_mem_region(info->apertures->ranges[0].base, info->apertures->ranges[0].size);\r\nframebuffer_release(info);\r\n}\r\nstatic void __iomem *offb_map_reg(struct device_node *np, int index,\r\nunsigned long offset, unsigned long size)\r\n{\r\nconst __be32 *addrp;\r\nu64 asize, taddr;\r\nunsigned int flags;\r\naddrp = of_get_pci_address(np, index, &asize, &flags);\r\nif (addrp == NULL)\r\naddrp = of_get_address(np, index, &asize, &flags);\r\nif (addrp == NULL)\r\nreturn NULL;\r\nif ((flags & (IORESOURCE_IO | IORESOURCE_MEM)) == 0)\r\nreturn NULL;\r\nif ((offset + size) > asize)\r\nreturn NULL;\r\ntaddr = of_translate_address(np, addrp);\r\nif (taddr == OF_BAD_ADDR)\r\nreturn NULL;\r\nreturn ioremap(taddr + offset, size);\r\n}\r\nstatic void offb_init_palette_hacks(struct fb_info *info, struct device_node *dp,\r\nconst char *name, unsigned long address)\r\n{\r\nstruct offb_par *par = (struct offb_par *) info->par;\r\nif (dp && !strncmp(name, "ATY,Rage128", 11)) {\r\npar->cmap_adr = offb_map_reg(dp, 2, 0, 0x1fff);\r\nif (par->cmap_adr)\r\npar->cmap_type = cmap_r128;\r\n} else if (dp && (!strncmp(name, "ATY,RageM3pA", 12)\r\n|| !strncmp(name, "ATY,RageM3p12A", 14))) {\r\npar->cmap_adr = offb_map_reg(dp, 2, 0, 0x1fff);\r\nif (par->cmap_adr)\r\npar->cmap_type = cmap_M3A;\r\n} else if (dp && !strncmp(name, "ATY,RageM3pB", 12)) {\r\npar->cmap_adr = offb_map_reg(dp, 2, 0, 0x1fff);\r\nif (par->cmap_adr)\r\npar->cmap_type = cmap_M3B;\r\n} else if (dp && !strncmp(name, "ATY,Rage6", 9)) {\r\npar->cmap_adr = offb_map_reg(dp, 1, 0, 0x1fff);\r\nif (par->cmap_adr)\r\npar->cmap_type = cmap_radeon;\r\n} else if (!strncmp(name, "ATY,", 4)) {\r\nunsigned long base = address & 0xff000000UL;\r\npar->cmap_adr =\r\nioremap(base + 0x7ff000, 0x1000) + 0xcc0;\r\npar->cmap_data = par->cmap_adr + 1;\r\npar->cmap_type = cmap_simple;\r\n} else if (dp && (of_device_is_compatible(dp, "pci1014,b7") ||\r\nof_device_is_compatible(dp, "pci1014,21c"))) {\r\npar->cmap_adr = offb_map_reg(dp, 0, 0x6000, 0x1000);\r\nif (par->cmap_adr)\r\npar->cmap_type = cmap_gxt2000;\r\n} else if (dp && !strncmp(name, "vga,Display-", 12)) {\r\nstruct device_node *pciparent = of_get_parent(dp);\r\nconst u32 *vid, *did;\r\nvid = of_get_property(pciparent, "vendor-id", NULL);\r\ndid = of_get_property(pciparent, "device-id", NULL);\r\nif (vid && did && *vid == 0x1002 &&\r\n((*did >= 0x7100 && *did < 0x7800) ||\r\n(*did >= 0x9400))) {\r\npar->cmap_adr = offb_map_reg(pciparent, 2, 0, 0x10000);\r\nif (par->cmap_adr)\r\npar->cmap_type = cmap_avivo;\r\n}\r\nof_node_put(pciparent);\r\n} else if (dp && of_device_is_compatible(dp, "qemu,std-vga")) {\r\n#ifdef __BIG_ENDIAN\r\nconst __be32 io_of_addr[3] = { 0x01000000, 0x0, 0x0 };\r\n#else\r\nconst __be32 io_of_addr[3] = { 0x00000001, 0x0, 0x0 };\r\n#endif\r\nu64 io_addr = of_translate_address(dp, io_of_addr);\r\nif (io_addr != OF_BAD_ADDR) {\r\npar->cmap_adr = ioremap(io_addr + 0x3c8, 2);\r\nif (par->cmap_adr) {\r\npar->cmap_type = cmap_simple;\r\npar->cmap_data = par->cmap_adr + 1;\r\n}\r\n}\r\n}\r\ninfo->fix.visual = (par->cmap_type != cmap_unknown) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_STATIC_PSEUDOCOLOR;\r\n}\r\nstatic void __init offb_init_fb(const char *name, const char *full_name,\r\nint width, int height, int depth,\r\nint pitch, unsigned long address,\r\nint foreign_endian, struct device_node *dp)\r\n{\r\nunsigned long res_size = pitch * height;\r\nstruct offb_par *par = &default_par;\r\nunsigned long res_start = address;\r\nstruct fb_fix_screeninfo *fix;\r\nstruct fb_var_screeninfo *var;\r\nstruct fb_info *info;\r\nif (!request_mem_region(res_start, res_size, "offb"))\r\nreturn;\r\nprintk(KERN_INFO\r\n"Using unsupported %dx%d %s at %lx, depth=%d, pitch=%d\n",\r\nwidth, height, name, address, depth, pitch);\r\nif (depth != 8 && depth != 15 && depth != 16 && depth != 32) {\r\nprintk(KERN_ERR "%s: can't use depth = %d\n", full_name,\r\ndepth);\r\nrelease_mem_region(res_start, res_size);\r\nreturn;\r\n}\r\ninfo = framebuffer_alloc(sizeof(u32) * 16, NULL);\r\nif (info == 0) {\r\nrelease_mem_region(res_start, res_size);\r\nreturn;\r\n}\r\nfix = &info->fix;\r\nvar = &info->var;\r\ninfo->par = par;\r\nstrcpy(fix->id, "OFfb ");\r\nstrncat(fix->id, name, sizeof(fix->id) - sizeof("OFfb "));\r\nfix->id[sizeof(fix->id) - 1] = '\0';\r\nvar->xres = var->xres_virtual = width;\r\nvar->yres = var->yres_virtual = height;\r\nfix->line_length = pitch;\r\nfix->smem_start = address;\r\nfix->smem_len = pitch * height;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->type_aux = 0;\r\npar->cmap_type = cmap_unknown;\r\nif (depth == 8)\r\noffb_init_palette_hacks(info, dp, name, address);\r\nelse\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nvar->xoffset = var->yoffset = 0;\r\nswitch (depth) {\r\ncase 8:\r\nvar->bits_per_pixel = 8;\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 15:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 32:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nbreak;\r\n}\r\nvar->red.msb_right = var->green.msb_right = var->blue.msb_right =\r\nvar->transp.msb_right = 0;\r\nvar->grayscale = 0;\r\nvar->nonstd = 0;\r\nvar->activate = 0;\r\nvar->height = var->width = -1;\r\nvar->pixclock = 10000;\r\nvar->left_margin = var->right_margin = 16;\r\nvar->upper_margin = var->lower_margin = 16;\r\nvar->hsync_len = var->vsync_len = 8;\r\nvar->sync = 0;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures)\r\ngoto out_aper;\r\ninfo->apertures->ranges[0].base = address;\r\ninfo->apertures->ranges[0].size = fix->smem_len;\r\ninfo->fbops = &offb_ops;\r\ninfo->screen_base = ioremap(address, fix->smem_len);\r\ninfo->pseudo_palette = (void *) (info + 1);\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_MISC_FIRMWARE | foreign_endian;\r\nfb_alloc_cmap(&info->cmap, 256, 0);\r\nif (register_framebuffer(info) < 0)\r\ngoto out_err;\r\nfb_info(info, "Open Firmware frame buffer device on %s\n", full_name);\r\nreturn;\r\nout_err:\r\niounmap(info->screen_base);\r\nout_aper:\r\niounmap(par->cmap_adr);\r\npar->cmap_adr = NULL;\r\nframebuffer_release(info);\r\nrelease_mem_region(res_start, res_size);\r\n}\r\nstatic void __init offb_init_nodriver(struct device_node *dp, int no_real_node)\r\n{\r\nunsigned int len;\r\nint i, width = 640, height = 480, depth = 8, pitch = 640;\r\nunsigned int flags, rsize, addr_prop = 0;\r\nunsigned long max_size = 0;\r\nu64 rstart, address = OF_BAD_ADDR;\r\nconst __be32 *pp, *addrp, *up;\r\nu64 asize;\r\nint foreign_endian = 0;\r\n#ifdef __BIG_ENDIAN\r\nif (of_get_property(dp, "little-endian", NULL))\r\nforeign_endian = FBINFO_FOREIGN_ENDIAN;\r\n#else\r\nif (of_get_property(dp, "big-endian", NULL))\r\nforeign_endian = FBINFO_FOREIGN_ENDIAN;\r\n#endif\r\npp = of_get_property(dp, "linux,bootx-depth", &len);\r\nif (pp == NULL)\r\npp = of_get_property(dp, "depth", &len);\r\nif (pp && len == sizeof(u32))\r\ndepth = be32_to_cpup(pp);\r\npp = of_get_property(dp, "linux,bootx-width", &len);\r\nif (pp == NULL)\r\npp = of_get_property(dp, "width", &len);\r\nif (pp && len == sizeof(u32))\r\nwidth = be32_to_cpup(pp);\r\npp = of_get_property(dp, "linux,bootx-height", &len);\r\nif (pp == NULL)\r\npp = of_get_property(dp, "height", &len);\r\nif (pp && len == sizeof(u32))\r\nheight = be32_to_cpup(pp);\r\npp = of_get_property(dp, "linux,bootx-linebytes", &len);\r\nif (pp == NULL)\r\npp = of_get_property(dp, "linebytes", &len);\r\nif (pp && len == sizeof(u32) && (*pp != 0xffffffffu))\r\npitch = be32_to_cpup(pp);\r\nelse\r\npitch = width * ((depth + 7) / 8);\r\nrsize = (unsigned long)pitch * (unsigned long)height;\r\nup = of_get_property(dp, "linux,bootx-addr", &len);\r\nif (up == NULL)\r\nup = of_get_property(dp, "address", &len);\r\nif (up && len == sizeof(u32))\r\naddr_prop = *up;\r\nif (no_real_node)\r\ngoto skip_addr;\r\nfor (i = 0; (addrp = of_get_address(dp, i, &asize, &flags))\r\n!= NULL; i++) {\r\nint match_addrp = 0;\r\nif (!(flags & IORESOURCE_MEM))\r\ncontinue;\r\nif (asize < rsize)\r\ncontinue;\r\nrstart = of_translate_address(dp, addrp);\r\nif (rstart == OF_BAD_ADDR)\r\ncontinue;\r\nif (addr_prop && (rstart <= addr_prop) &&\r\n((rstart + asize) >= (addr_prop + rsize)))\r\nmatch_addrp = 1;\r\nif (match_addrp) {\r\naddress = addr_prop;\r\nbreak;\r\n}\r\nif (rsize > max_size) {\r\nmax_size = rsize;\r\naddress = OF_BAD_ADDR;\r\n}\r\nif (address == OF_BAD_ADDR)\r\naddress = rstart;\r\n}\r\nskip_addr:\r\nif (address == OF_BAD_ADDR && addr_prop)\r\naddress = (u64)addr_prop;\r\nif (address != OF_BAD_ADDR) {\r\nif (strcmp(dp->name, "valkyrie") == 0)\r\naddress += 0x1000;\r\noffb_init_fb(no_real_node ? "bootx" : dp->name,\r\nno_real_node ? "display" : dp->full_name,\r\nwidth, height, depth, pitch, address,\r\nforeign_endian, no_real_node ? NULL : dp);\r\n}\r\n}\r\nstatic int __init offb_init(void)\r\n{\r\nstruct device_node *dp = NULL, *boot_disp = NULL;\r\nif (fb_get_options("offb", NULL))\r\nreturn -ENODEV;\r\nif (of_get_property(of_chosen, "linux,bootx-noscreen", NULL) != NULL) {\r\noffb_init_nodriver(of_chosen, 1);\r\n}\r\nfor (dp = NULL; (dp = of_find_node_by_type(dp, "display"));) {\r\nif (of_get_property(dp, "linux,opened", NULL) &&\r\nof_get_property(dp, "linux,boot-display", NULL)) {\r\nboot_disp = dp;\r\noffb_init_nodriver(dp, 0);\r\n}\r\n}\r\nfor (dp = NULL; (dp = of_find_node_by_type(dp, "display"));) {\r\nif (of_get_property(dp, "linux,opened", NULL) &&\r\ndp != boot_disp)\r\noffb_init_nodriver(dp, 0);\r\n}\r\nreturn 0;\r\n}
