static u16 hv_get_dev_type(const uuid_le *guid)\r\n{\r\nu16 i;\r\nfor (i = HV_IDE; i < HV_UNKOWN; i++) {\r\nif (!uuid_le_cmp(*guid, vmbus_devs[i].guid))\r\nreturn i;\r\n}\r\npr_info("Unknown GUID: %pUl\n", guid);\r\nreturn i;\r\n}\r\nbool vmbus_prep_negotiate_resp(struct icmsg_hdr *icmsghdrp,\r\nstruct icmsg_negotiate *negop, u8 *buf,\r\nint fw_version, int srv_version)\r\n{\r\nint icframe_major, icframe_minor;\r\nint icmsg_major, icmsg_minor;\r\nint fw_major, fw_minor;\r\nint srv_major, srv_minor;\r\nint i;\r\nbool found_match = false;\r\nicmsghdrp->icmsgsize = 0x10;\r\nfw_major = (fw_version >> 16);\r\nfw_minor = (fw_version & 0xFFFF);\r\nsrv_major = (srv_version >> 16);\r\nsrv_minor = (srv_version & 0xFFFF);\r\nnegop = (struct icmsg_negotiate *)&buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nicframe_major = negop->icframe_vercnt;\r\nicframe_minor = 0;\r\nicmsg_major = negop->icmsg_vercnt;\r\nicmsg_minor = 0;\r\nfor (i = 0; i < negop->icframe_vercnt; i++) {\r\nif ((negop->icversion_data[i].major == fw_major) &&\r\n(negop->icversion_data[i].minor == fw_minor)) {\r\nicframe_major = negop->icversion_data[i].major;\r\nicframe_minor = negop->icversion_data[i].minor;\r\nfound_match = true;\r\n}\r\n}\r\nif (!found_match)\r\ngoto fw_error;\r\nfound_match = false;\r\nfor (i = negop->icframe_vercnt;\r\n(i < negop->icframe_vercnt + negop->icmsg_vercnt); i++) {\r\nif ((negop->icversion_data[i].major == srv_major) &&\r\n(negop->icversion_data[i].minor == srv_minor)) {\r\nicmsg_major = negop->icversion_data[i].major;\r\nicmsg_minor = negop->icversion_data[i].minor;\r\nfound_match = true;\r\n}\r\n}\r\nfw_error:\r\nif (!found_match) {\r\nnegop->icframe_vercnt = 0;\r\nnegop->icmsg_vercnt = 0;\r\n} else {\r\nnegop->icframe_vercnt = 1;\r\nnegop->icmsg_vercnt = 1;\r\n}\r\nnegop->icversion_data[0].major = icframe_major;\r\nnegop->icversion_data[0].minor = icframe_minor;\r\nnegop->icversion_data[1].major = icmsg_major;\r\nnegop->icversion_data[1].minor = icmsg_minor;\r\nreturn found_match;\r\n}\r\nstatic struct vmbus_channel *alloc_channel(void)\r\n{\r\nstatic atomic_t chan_num = ATOMIC_INIT(0);\r\nstruct vmbus_channel *channel;\r\nchannel = kzalloc(sizeof(*channel), GFP_ATOMIC);\r\nif (!channel)\r\nreturn NULL;\r\nchannel->id = atomic_inc_return(&chan_num);\r\nchannel->acquire_ring_lock = true;\r\nspin_lock_init(&channel->inbound_lock);\r\nspin_lock_init(&channel->lock);\r\nINIT_LIST_HEAD(&channel->sc_list);\r\nINIT_LIST_HEAD(&channel->percpu_list);\r\nreturn channel;\r\n}\r\nstatic void free_channel(struct vmbus_channel *channel)\r\n{\r\nkfree(channel);\r\n}\r\nstatic void percpu_channel_enq(void *arg)\r\n{\r\nstruct vmbus_channel *channel = arg;\r\nint cpu = smp_processor_id();\r\nlist_add_tail(&channel->percpu_list, &hv_context.percpu_list[cpu]);\r\n}\r\nstatic void percpu_channel_deq(void *arg)\r\n{\r\nstruct vmbus_channel *channel = arg;\r\nlist_del(&channel->percpu_list);\r\n}\r\nstatic void vmbus_release_relid(u32 relid)\r\n{\r\nstruct vmbus_channel_relid_released msg;\r\nmemset(&msg, 0, sizeof(struct vmbus_channel_relid_released));\r\nmsg.child_relid = relid;\r\nmsg.header.msgtype = CHANNELMSG_RELID_RELEASED;\r\nvmbus_post_msg(&msg, sizeof(struct vmbus_channel_relid_released));\r\n}\r\nvoid hv_process_channel_removal(struct vmbus_channel *channel, u32 relid)\r\n{\r\nunsigned long flags;\r\nstruct vmbus_channel *primary_channel;\r\nvmbus_release_relid(relid);\r\nBUG_ON(!channel->rescind);\r\nBUG_ON(!mutex_is_locked(&vmbus_connection.channel_mutex));\r\nif (channel->target_cpu != get_cpu()) {\r\nput_cpu();\r\nsmp_call_function_single(channel->target_cpu,\r\npercpu_channel_deq, channel, true);\r\n} else {\r\npercpu_channel_deq(channel);\r\nput_cpu();\r\n}\r\nif (channel->primary_channel == NULL) {\r\nlist_del(&channel->listentry);\r\nprimary_channel = channel;\r\n} else {\r\nprimary_channel = channel->primary_channel;\r\nspin_lock_irqsave(&primary_channel->lock, flags);\r\nlist_del(&channel->sc_list);\r\nprimary_channel->num_sc--;\r\nspin_unlock_irqrestore(&primary_channel->lock, flags);\r\n}\r\ncpumask_clear_cpu(channel->target_cpu,\r\n&primary_channel->alloced_cpus_in_node);\r\nfree_channel(channel);\r\n}\r\nvoid vmbus_free_channels(void)\r\n{\r\nstruct vmbus_channel *channel, *tmp;\r\nlist_for_each_entry_safe(channel, tmp, &vmbus_connection.chn_list,\r\nlistentry) {\r\nchannel->rescind = true;\r\nvmbus_device_unregister(channel->device_obj);\r\n}\r\n}\r\nstatic void vmbus_process_offer(struct vmbus_channel *newchannel)\r\n{\r\nstruct vmbus_channel *channel;\r\nbool fnew = true;\r\nunsigned long flags;\r\nu16 dev_type;\r\nint ret;\r\nmutex_lock(&vmbus_connection.channel_mutex);\r\nlist_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {\r\nif (!uuid_le_cmp(channel->offermsg.offer.if_type,\r\nnewchannel->offermsg.offer.if_type) &&\r\n!uuid_le_cmp(channel->offermsg.offer.if_instance,\r\nnewchannel->offermsg.offer.if_instance)) {\r\nfnew = false;\r\nbreak;\r\n}\r\n}\r\nif (fnew)\r\nlist_add_tail(&newchannel->listentry,\r\n&vmbus_connection.chn_list);\r\nmutex_unlock(&vmbus_connection.channel_mutex);\r\nif (!fnew) {\r\nif (newchannel->offermsg.offer.sub_channel_index != 0) {\r\nnewchannel->primary_channel = channel;\r\nspin_lock_irqsave(&channel->lock, flags);\r\nlist_add_tail(&newchannel->sc_list, &channel->sc_list);\r\nchannel->num_sc++;\r\nspin_unlock_irqrestore(&channel->lock, flags);\r\n} else\r\ngoto err_free_chan;\r\n}\r\ndev_type = hv_get_dev_type(&newchannel->offermsg.offer.if_type);\r\ninit_vp_index(newchannel, dev_type);\r\nif (newchannel->target_cpu != get_cpu()) {\r\nput_cpu();\r\nsmp_call_function_single(newchannel->target_cpu,\r\npercpu_channel_enq,\r\nnewchannel, true);\r\n} else {\r\npercpu_channel_enq(newchannel);\r\nput_cpu();\r\n}\r\nnewchannel->state = CHANNEL_OPEN_STATE;\r\nif (!fnew) {\r\nif (channel->sc_creation_callback != NULL)\r\nchannel->sc_creation_callback(newchannel);\r\nreturn;\r\n}\r\nnewchannel->device_obj = vmbus_device_create(\r\n&newchannel->offermsg.offer.if_type,\r\n&newchannel->offermsg.offer.if_instance,\r\nnewchannel);\r\nif (!newchannel->device_obj)\r\ngoto err_deq_chan;\r\nnewchannel->device_obj->device_id = dev_type;\r\nmutex_lock(&vmbus_connection.channel_mutex);\r\nret = vmbus_device_register(newchannel->device_obj);\r\nmutex_unlock(&vmbus_connection.channel_mutex);\r\nif (ret != 0) {\r\npr_err("unable to add child device object (relid %d)\n",\r\nnewchannel->offermsg.child_relid);\r\nkfree(newchannel->device_obj);\r\ngoto err_deq_chan;\r\n}\r\nreturn;\r\nerr_deq_chan:\r\nvmbus_release_relid(newchannel->offermsg.child_relid);\r\nmutex_lock(&vmbus_connection.channel_mutex);\r\nlist_del(&newchannel->listentry);\r\nmutex_unlock(&vmbus_connection.channel_mutex);\r\nif (newchannel->target_cpu != get_cpu()) {\r\nput_cpu();\r\nsmp_call_function_single(newchannel->target_cpu,\r\npercpu_channel_deq, newchannel, true);\r\n} else {\r\npercpu_channel_deq(newchannel);\r\nput_cpu();\r\n}\r\nerr_free_chan:\r\nfree_channel(newchannel);\r\n}\r\nstatic void init_vp_index(struct vmbus_channel *channel, u16 dev_type)\r\n{\r\nu32 cur_cpu;\r\nbool perf_chn = vmbus_devs[dev_type].perf_device;\r\nstruct vmbus_channel *primary = channel->primary_channel;\r\nint next_node;\r\nstruct cpumask available_mask;\r\nstruct cpumask *alloced_mask;\r\nif ((vmbus_proto_version == VERSION_WS2008) ||\r\n(vmbus_proto_version == VERSION_WIN7) || (!perf_chn)) {\r\nchannel->numa_node = 0;\r\nchannel->target_cpu = 0;\r\nchannel->target_vp = hv_context.vp_index[0];\r\nreturn;\r\n}\r\nif (!primary) {\r\nwhile (true) {\r\nnext_node = next_numa_node_id++;\r\nif (next_node == nr_node_ids)\r\nnext_node = next_numa_node_id = 0;\r\nif (cpumask_empty(cpumask_of_node(next_node)))\r\ncontinue;\r\nbreak;\r\n}\r\nchannel->numa_node = next_node;\r\nprimary = channel;\r\n}\r\nalloced_mask = &hv_context.hv_numa_map[primary->numa_node];\r\nif (cpumask_weight(alloced_mask) ==\r\ncpumask_weight(cpumask_of_node(primary->numa_node))) {\r\ncpumask_clear(alloced_mask);\r\n}\r\ncpumask_xor(&available_mask, alloced_mask,\r\ncpumask_of_node(primary->numa_node));\r\ncur_cpu = -1;\r\nif (cpumask_equal(&primary->alloced_cpus_in_node,\r\ncpumask_of_node(primary->numa_node)))\r\ncpumask_clear(&primary->alloced_cpus_in_node);\r\nwhile (true) {\r\ncur_cpu = cpumask_next(cur_cpu, &available_mask);\r\nif (cur_cpu >= nr_cpu_ids) {\r\ncur_cpu = -1;\r\ncpumask_copy(&available_mask,\r\ncpumask_of_node(primary->numa_node));\r\ncontinue;\r\n}\r\nif (!cpumask_test_cpu(cur_cpu,\r\n&primary->alloced_cpus_in_node)) {\r\ncpumask_set_cpu(cur_cpu,\r\n&primary->alloced_cpus_in_node);\r\ncpumask_set_cpu(cur_cpu, alloced_mask);\r\nbreak;\r\n}\r\n}\r\nchannel->target_cpu = cur_cpu;\r\nchannel->target_vp = hv_context.vp_index[cur_cpu];\r\n}\r\nstatic void vmbus_wait_for_unload(void)\r\n{\r\nint cpu;\r\nvoid *page_addr;\r\nstruct hv_message *msg;\r\nstruct vmbus_channel_message_header *hdr;\r\nu32 message_type;\r\nwhile (1) {\r\nif (completion_done(&vmbus_connection.unload_event))\r\nbreak;\r\nfor_each_online_cpu(cpu) {\r\npage_addr = hv_context.synic_message_page[cpu];\r\nmsg = (struct hv_message *)page_addr +\r\nVMBUS_MESSAGE_SINT;\r\nmessage_type = READ_ONCE(msg->header.message_type);\r\nif (message_type == HVMSG_NONE)\r\ncontinue;\r\nhdr = (struct vmbus_channel_message_header *)\r\nmsg->u.payload;\r\nif (hdr->msgtype == CHANNELMSG_UNLOAD_RESPONSE)\r\ncomplete(&vmbus_connection.unload_event);\r\nvmbus_signal_eom(msg, message_type);\r\n}\r\nmdelay(10);\r\n}\r\nfor_each_online_cpu(cpu) {\r\npage_addr = hv_context.synic_message_page[cpu];\r\nmsg = (struct hv_message *)page_addr + VMBUS_MESSAGE_SINT;\r\nmsg->header.message_type = HVMSG_NONE;\r\n}\r\n}\r\nstatic void vmbus_unload_response(struct vmbus_channel_message_header *hdr)\r\n{\r\ncomplete(&vmbus_connection.unload_event);\r\n}\r\nvoid vmbus_initiate_unload(bool crash)\r\n{\r\nstruct vmbus_channel_message_header hdr;\r\nif (vmbus_proto_version < VERSION_WIN8_1)\r\nreturn;\r\ninit_completion(&vmbus_connection.unload_event);\r\nmemset(&hdr, 0, sizeof(struct vmbus_channel_message_header));\r\nhdr.msgtype = CHANNELMSG_UNLOAD;\r\nvmbus_post_msg(&hdr, sizeof(struct vmbus_channel_message_header));\r\nif (!crash)\r\nwait_for_completion(&vmbus_connection.unload_event);\r\nelse\r\nvmbus_wait_for_unload();\r\n}\r\nstatic void vmbus_onoffer(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_offer_channel *offer;\r\nstruct vmbus_channel *newchannel;\r\noffer = (struct vmbus_channel_offer_channel *)hdr;\r\nnewchannel = alloc_channel();\r\nif (!newchannel) {\r\npr_err("Unable to allocate channel object\n");\r\nreturn;\r\n}\r\nnewchannel->batched_reading = true;\r\nnewchannel->sig_event = (struct hv_input_signal_event *)\r\n(ALIGN((unsigned long)\r\n&newchannel->sig_buf,\r\nHV_HYPERCALL_PARAM_ALIGN));\r\nnewchannel->sig_event->connectionid.asu32 = 0;\r\nnewchannel->sig_event->connectionid.u.id = VMBUS_EVENT_CONNECTION_ID;\r\nnewchannel->sig_event->flag_number = 0;\r\nnewchannel->sig_event->rsvdz = 0;\r\nif (vmbus_proto_version != VERSION_WS2008) {\r\nnewchannel->is_dedicated_interrupt =\r\n(offer->is_dedicated_interrupt != 0);\r\nnewchannel->sig_event->connectionid.u.id =\r\noffer->connection_id;\r\n}\r\nmemcpy(&newchannel->offermsg, offer,\r\nsizeof(struct vmbus_channel_offer_channel));\r\nnewchannel->monitor_grp = (u8)offer->monitorid / 32;\r\nnewchannel->monitor_bit = (u8)offer->monitorid % 32;\r\nvmbus_process_offer(newchannel);\r\n}\r\nstatic void vmbus_onoffer_rescind(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_rescind_offer *rescind;\r\nstruct vmbus_channel *channel;\r\nunsigned long flags;\r\nstruct device *dev;\r\nrescind = (struct vmbus_channel_rescind_offer *)hdr;\r\nmutex_lock(&vmbus_connection.channel_mutex);\r\nchannel = relid2channel(rescind->child_relid);\r\nif (channel == NULL) {\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&channel->lock, flags);\r\nchannel->rescind = true;\r\nspin_unlock_irqrestore(&channel->lock, flags);\r\nif (channel->device_obj) {\r\nif (channel->chn_rescind_callback) {\r\nchannel->chn_rescind_callback(channel);\r\ngoto out;\r\n}\r\ndev = get_device(&channel->device_obj->device);\r\nif (dev) {\r\nvmbus_device_unregister(channel->device_obj);\r\nput_device(dev);\r\n}\r\n} else {\r\nhv_process_channel_removal(channel,\r\nchannel->offermsg.child_relid);\r\n}\r\nout:\r\nmutex_unlock(&vmbus_connection.channel_mutex);\r\n}\r\nvoid vmbus_hvsock_device_unregister(struct vmbus_channel *channel)\r\n{\r\nmutex_lock(&vmbus_connection.channel_mutex);\r\nBUG_ON(!is_hvsock_channel(channel));\r\nchannel->rescind = true;\r\nvmbus_device_unregister(channel->device_obj);\r\nmutex_unlock(&vmbus_connection.channel_mutex);\r\n}\r\nstatic void vmbus_onoffers_delivered(\r\nstruct vmbus_channel_message_header *hdr)\r\n{\r\n}\r\nstatic void vmbus_onopen_result(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_open_result *result;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_open_channel *openmsg;\r\nunsigned long flags;\r\nresult = (struct vmbus_channel_open_result *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype == CHANNELMSG_OPENCHANNEL) {\r\nopenmsg =\r\n(struct vmbus_channel_open_channel *)msginfo->msg;\r\nif (openmsg->child_relid == result->child_relid &&\r\nopenmsg->openid == result->openid) {\r\nmemcpy(&msginfo->response.open_result,\r\nresult,\r\nsizeof(\r\nstruct vmbus_channel_open_result));\r\ncomplete(&msginfo->waitevent);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nstatic void vmbus_ongpadl_created(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_gpadl_created *gpadlcreated;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_gpadl_header *gpadlheader;\r\nunsigned long flags;\r\ngpadlcreated = (struct vmbus_channel_gpadl_created *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype == CHANNELMSG_GPADL_HEADER) {\r\ngpadlheader =\r\n(struct vmbus_channel_gpadl_header *)requestheader;\r\nif ((gpadlcreated->child_relid ==\r\ngpadlheader->child_relid) &&\r\n(gpadlcreated->gpadl == gpadlheader->gpadl)) {\r\nmemcpy(&msginfo->response.gpadl_created,\r\ngpadlcreated,\r\nsizeof(\r\nstruct vmbus_channel_gpadl_created));\r\ncomplete(&msginfo->waitevent);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nstatic void vmbus_ongpadl_torndown(\r\nstruct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_gpadl_torndown *gpadl_torndown;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_gpadl_teardown *gpadl_teardown;\r\nunsigned long flags;\r\ngpadl_torndown = (struct vmbus_channel_gpadl_torndown *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype == CHANNELMSG_GPADL_TEARDOWN) {\r\ngpadl_teardown =\r\n(struct vmbus_channel_gpadl_teardown *)requestheader;\r\nif (gpadl_torndown->gpadl == gpadl_teardown->gpadl) {\r\nmemcpy(&msginfo->response.gpadl_torndown,\r\ngpadl_torndown,\r\nsizeof(\r\nstruct vmbus_channel_gpadl_torndown));\r\ncomplete(&msginfo->waitevent);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nstatic void vmbus_onversion_response(\r\nstruct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_version_response *version_response;\r\nunsigned long flags;\r\nversion_response = (struct vmbus_channel_version_response *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype ==\r\nCHANNELMSG_INITIATE_CONTACT) {\r\nmemcpy(&msginfo->response.version_response,\r\nversion_response,\r\nsizeof(struct vmbus_channel_version_response));\r\ncomplete(&msginfo->waitevent);\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nvoid vmbus_onmessage(void *context)\r\n{\r\nstruct hv_message *msg = context;\r\nstruct vmbus_channel_message_header *hdr;\r\nint size;\r\nhdr = (struct vmbus_channel_message_header *)msg->u.payload;\r\nsize = msg->header.payload_size;\r\nif (hdr->msgtype >= CHANNELMSG_COUNT) {\r\npr_err("Received invalid channel message type %d size %d\n",\r\nhdr->msgtype, size);\r\nprint_hex_dump_bytes("", DUMP_PREFIX_NONE,\r\n(unsigned char *)msg->u.payload, size);\r\nreturn;\r\n}\r\nif (channel_message_table[hdr->msgtype].message_handler)\r\nchannel_message_table[hdr->msgtype].message_handler(hdr);\r\nelse\r\npr_err("Unhandled channel message type %d\n", hdr->msgtype);\r\n}\r\nint vmbus_request_offers(void)\r\n{\r\nstruct vmbus_channel_message_header *msg;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nint ret;\r\nmsginfo = kmalloc(sizeof(*msginfo) +\r\nsizeof(struct vmbus_channel_message_header),\r\nGFP_KERNEL);\r\nif (!msginfo)\r\nreturn -ENOMEM;\r\nmsg = (struct vmbus_channel_message_header *)msginfo->msg;\r\nmsg->msgtype = CHANNELMSG_REQUESTOFFERS;\r\nret = vmbus_post_msg(msg,\r\nsizeof(struct vmbus_channel_message_header));\r\nif (ret != 0) {\r\npr_err("Unable to request offers - %d\n", ret);\r\ngoto cleanup;\r\n}\r\ncleanup:\r\nkfree(msginfo);\r\nreturn ret;\r\n}\r\nstruct vmbus_channel *vmbus_get_outgoing_channel(struct vmbus_channel *primary)\r\n{\r\nstruct list_head *cur, *tmp;\r\nint cur_cpu;\r\nstruct vmbus_channel *cur_channel;\r\nstruct vmbus_channel *outgoing_channel = primary;\r\nint next_channel;\r\nint i = 1;\r\nif (list_empty(&primary->sc_list))\r\nreturn outgoing_channel;\r\nnext_channel = primary->next_oc++;\r\nif (next_channel > (primary->num_sc)) {\r\nprimary->next_oc = 0;\r\nreturn outgoing_channel;\r\n}\r\ncur_cpu = hv_context.vp_index[get_cpu()];\r\nput_cpu();\r\nlist_for_each_safe(cur, tmp, &primary->sc_list) {\r\ncur_channel = list_entry(cur, struct vmbus_channel, sc_list);\r\nif (cur_channel->state != CHANNEL_OPENED_STATE)\r\ncontinue;\r\nif (cur_channel->target_vp == cur_cpu)\r\nreturn cur_channel;\r\nif (i == next_channel)\r\nreturn cur_channel;\r\ni++;\r\n}\r\nreturn outgoing_channel;\r\n}\r\nstatic void invoke_sc_cb(struct vmbus_channel *primary_channel)\r\n{\r\nstruct list_head *cur, *tmp;\r\nstruct vmbus_channel *cur_channel;\r\nif (primary_channel->sc_creation_callback == NULL)\r\nreturn;\r\nlist_for_each_safe(cur, tmp, &primary_channel->sc_list) {\r\ncur_channel = list_entry(cur, struct vmbus_channel, sc_list);\r\nprimary_channel->sc_creation_callback(cur_channel);\r\n}\r\n}\r\nvoid vmbus_set_sc_create_callback(struct vmbus_channel *primary_channel,\r\nvoid (*sc_cr_cb)(struct vmbus_channel *new_sc))\r\n{\r\nprimary_channel->sc_creation_callback = sc_cr_cb;\r\n}\r\nbool vmbus_are_subchannels_present(struct vmbus_channel *primary)\r\n{\r\nbool ret;\r\nret = !list_empty(&primary->sc_list);\r\nif (ret) {\r\ninvoke_sc_cb(primary);\r\n}\r\nreturn ret;\r\n}\r\nvoid vmbus_set_chn_rescind_callback(struct vmbus_channel *channel,\r\nvoid (*chn_rescind_cb)(struct vmbus_channel *))\r\n{\r\nchannel->chn_rescind_callback = chn_rescind_cb;\r\n}
