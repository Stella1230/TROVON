static int arc4_set_key(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct arc4_ctx *ctx = crypto_tfm_ctx(tfm);\r\nint i, j = 0, k = 0;\r\nctx->x = 1;\r\nctx->y = 0;\r\nfor (i = 0; i < 256; i++)\r\nctx->S[i] = i;\r\nfor (i = 0; i < 256; i++) {\r\nu32 a = ctx->S[i];\r\nj = (j + in_key[k] + a) & 0xff;\r\nctx->S[i] = ctx->S[j];\r\nctx->S[j] = a;\r\nif (++k >= key_len)\r\nk = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void arc4_crypt(struct arc4_ctx *ctx, u8 *out, const u8 *in,\r\nunsigned int len)\r\n{\r\nu32 *const S = ctx->S;\r\nu32 x, y, a, b;\r\nu32 ty, ta, tb;\r\nif (len == 0)\r\nreturn;\r\nx = ctx->x;\r\ny = ctx->y;\r\na = S[x];\r\ny = (y + a) & 0xff;\r\nb = S[y];\r\ndo {\r\nS[y] = a;\r\na = (a + b) & 0xff;\r\nS[x] = b;\r\nx = (x + 1) & 0xff;\r\nta = S[x];\r\nty = (y + ta) & 0xff;\r\ntb = S[ty];\r\n*out++ = *in++ ^ S[a];\r\nif (--len == 0)\r\nbreak;\r\ny = ty;\r\na = ta;\r\nb = tb;\r\n} while (true);\r\nctx->x = x;\r\nctx->y = y;\r\n}\r\nstatic void arc4_crypt_one(struct crypto_tfm *tfm, u8 *out, const u8 *in)\r\n{\r\narc4_crypt(crypto_tfm_ctx(tfm), out, in, 1);\r\n}\r\nstatic int ecb_arc4_crypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct arc4_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\nwhile (walk.nbytes > 0) {\r\nu8 *wsrc = walk.src.virt.addr;\r\nu8 *wdst = walk.dst.virt.addr;\r\narc4_crypt(ctx, wdst, wsrc, walk.nbytes);\r\nerr = blkcipher_walk_done(desc, &walk, 0);\r\n}\r\nreturn err;\r\n}\r\nstatic int __init arc4_init(void)\r\n{\r\nreturn crypto_register_algs(arc4_algs, ARRAY_SIZE(arc4_algs));\r\n}\r\nstatic void __exit arc4_exit(void)\r\n{\r\ncrypto_unregister_algs(arc4_algs, ARRAY_SIZE(arc4_algs));\r\n}
