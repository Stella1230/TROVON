static\r\nu64 whci_capdata_quirks(struct whci_card *card, u64 capdata)\r\n{\r\nu64 capdata_orig = capdata;\r\nstruct pci_dev *pci_dev = card->pci;\r\nif (pci_dev->vendor == PCI_VENDOR_ID_INTEL\r\n&& (pci_dev->device == 0x0c3b || pci_dev->device == 0004)\r\n&& pci_dev->class == 0x0d1010) {\r\nswitch (UWBCAPDATA_TO_CAP_ID(capdata)) {\r\ncase 0x80:\r\ncapdata |= 0x40 << 8; break;\r\ncase 0x02:\r\ncapdata &= ~0xffff;\r\ncapdata |= 0x2001;\r\nbreak;\r\n}\r\n}\r\nif (capdata_orig != capdata)\r\ndev_warn(&pci_dev->dev,\r\n"PCI v%04x d%04x c%06x#%02x: "\r\n"corrected capdata from %016Lx to %016Lx\n",\r\npci_dev->vendor, pci_dev->device, pci_dev->class,\r\n(unsigned)UWBCAPDATA_TO_CAP_ID(capdata),\r\n(unsigned long long)capdata_orig,\r\n(unsigned long long)capdata);\r\nreturn capdata;\r\n}\r\nint whci_wait_for(struct device *dev, u32 __iomem *reg, u32 mask, u32 result,\r\nunsigned long max_ms, const char *tag)\r\n{\r\nunsigned t = 0;\r\nu32 val;\r\nfor (;;) {\r\nval = le_readl(reg);\r\nif ((val & mask) == result)\r\nbreak;\r\nif (t >= max_ms) {\r\ndev_err(dev, "%s timed out\n", tag);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(10);\r\nt += 10;\r\n}\r\nreturn 0;\r\n}\r\nstatic int whci_add_cap(struct whci_card *card, int n)\r\n{\r\nstruct umc_dev *umc;\r\nu64 capdata;\r\nint bar, err;\r\numc = umc_device_create(&card->pci->dev, n);\r\nif (umc == NULL)\r\nreturn -ENOMEM;\r\ncapdata = le_readq(card->uwbbase + UWBCAPDATA(n));\r\nbar = UWBCAPDATA_TO_BAR(capdata) << 1;\r\ncapdata = whci_capdata_quirks(card, capdata);\r\numc->version = UWBCAPDATA_TO_VERSION(capdata);\r\numc->cap_id = n == 0 ? 0 : UWBCAPDATA_TO_CAP_ID(capdata);\r\numc->bar = bar;\r\numc->resource.start = pci_resource_start(card->pci, bar)\r\n+ UWBCAPDATA_TO_OFFSET(capdata);\r\numc->resource.end = umc->resource.start\r\n+ (n == 0 ? 0x20 : UWBCAPDATA_TO_SIZE(capdata)) - 1;\r\numc->resource.name = dev_name(&umc->dev);\r\numc->resource.flags = card->pci->resource[bar].flags;\r\numc->resource.parent = &card->pci->resource[bar];\r\numc->irq = card->pci->irq;\r\nerr = umc_device_register(umc);\r\nif (err < 0)\r\ngoto error;\r\ncard->devs[n] = umc;\r\nreturn 0;\r\nerror:\r\nkfree(umc);\r\nreturn err;\r\n}\r\nstatic void whci_del_cap(struct whci_card *card, int n)\r\n{\r\nstruct umc_dev *umc = card->devs[n];\r\numc_device_unregister(umc);\r\n}\r\nstatic int whci_n_caps(struct pci_dev *pci)\r\n{\r\nvoid __iomem *uwbbase;\r\nu64 capinfo;\r\nuwbbase = pci_iomap(pci, 0, 8);\r\nif (!uwbbase)\r\nreturn -ENOMEM;\r\ncapinfo = le_readq(uwbbase + UWBCAPINFO);\r\npci_iounmap(pci, uwbbase);\r\nreturn UWBCAPINFO_TO_N_CAPS(capinfo);\r\n}\r\nstatic int whci_probe(struct pci_dev *pci, const struct pci_device_id *id)\r\n{\r\nstruct whci_card *card;\r\nint err, n_caps, n;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\ngoto error;\r\npci_enable_msi(pci);\r\npci_set_master(pci);\r\nerr = -ENXIO;\r\nif (!pci_set_dma_mask(pci, DMA_BIT_MASK(64)))\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(64));\r\nelse if (!pci_set_dma_mask(pci, DMA_BIT_MASK(32)))\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(32));\r\nelse\r\ngoto error_dma;\r\nerr = n_caps = whci_n_caps(pci);\r\nif (n_caps < 0)\r\ngoto error_ncaps;\r\nerr = -ENOMEM;\r\ncard = kzalloc(sizeof(struct whci_card)\r\n+ sizeof(struct umc_dev *) * (n_caps + 1),\r\nGFP_KERNEL);\r\nif (card == NULL)\r\ngoto error_kzalloc;\r\ncard->pci = pci;\r\ncard->n_caps = n_caps;\r\nerr = -EBUSY;\r\nif (!request_mem_region(pci_resource_start(pci, 0),\r\nUWBCAPDATA_SIZE(card->n_caps),\r\n"whci (capability data)"))\r\ngoto error_request_memregion;\r\nerr = -ENOMEM;\r\ncard->uwbbase = pci_iomap(pci, 0, UWBCAPDATA_SIZE(card->n_caps));\r\nif (!card->uwbbase)\r\ngoto error_iomap;\r\nfor (n = 0; n <= card->n_caps; n++) {\r\nerr = whci_add_cap(card, n);\r\nif (err < 0 && n == 0) {\r\ndev_err(&pci->dev, "cannot bind UWB radio controller:"\r\n" %d\n", err);\r\ngoto error_bind;\r\n}\r\nif (err < 0)\r\ndev_warn(&pci->dev, "warning: cannot bind capability "\r\n"#%u: %d\n", n, err);\r\n}\r\npci_set_drvdata(pci, card);\r\nreturn 0;\r\nerror_bind:\r\npci_iounmap(pci, card->uwbbase);\r\nerror_iomap:\r\nrelease_mem_region(pci_resource_start(pci, 0), UWBCAPDATA_SIZE(card->n_caps));\r\nerror_request_memregion:\r\nkfree(card);\r\nerror_kzalloc:\r\nerror_ncaps:\r\nerror_dma:\r\npci_disable_msi(pci);\r\npci_disable_device(pci);\r\nerror:\r\nreturn err;\r\n}\r\nstatic void whci_remove(struct pci_dev *pci)\r\n{\r\nstruct whci_card *card = pci_get_drvdata(pci);\r\nint n;\r\npci_set_drvdata(pci, NULL);\r\nfor (n = card->n_caps; n >= 0 ; n--)\r\nwhci_del_cap(card, n);\r\npci_iounmap(pci, card->uwbbase);\r\nrelease_mem_region(pci_resource_start(pci, 0), UWBCAPDATA_SIZE(card->n_caps));\r\nkfree(card);\r\npci_disable_msi(pci);\r\npci_disable_device(pci);\r\n}
