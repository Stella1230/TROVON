static void mlx4_en_cq_event(struct mlx4_cq *cq, enum mlx4_event event)\r\n{\r\nreturn;\r\n}\r\nint mlx4_en_create_cq(struct mlx4_en_priv *priv,\r\nstruct mlx4_en_cq **pcq,\r\nint entries, int ring, enum cq_type mode,\r\nint node)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nstruct mlx4_en_cq *cq;\r\nint err;\r\ncq = kzalloc_node(sizeof(*cq), GFP_KERNEL, node);\r\nif (!cq) {\r\ncq = kzalloc(sizeof(*cq), GFP_KERNEL);\r\nif (!cq) {\r\nen_err(priv, "Failed to allocate CQ structure\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ncq->size = entries;\r\ncq->buf_size = cq->size * mdev->dev->caps.cqe_size;\r\ncq->ring = ring;\r\ncq->is_tx = mode;\r\ncq->vector = mdev->dev->caps.num_comp_vectors;\r\nset_dev_node(&mdev->dev->persist->pdev->dev, node);\r\nerr = mlx4_alloc_hwq_res(mdev->dev, &cq->wqres,\r\ncq->buf_size);\r\nset_dev_node(&mdev->dev->persist->pdev->dev, mdev->dev->numa_node);\r\nif (err)\r\ngoto err_cq;\r\ncq->buf = (struct mlx4_cqe *)cq->wqres.buf.direct.buf;\r\n*pcq = cq;\r\nreturn 0;\r\nerr_cq:\r\nkfree(cq);\r\n*pcq = NULL;\r\nreturn err;\r\n}\r\nint mlx4_en_activate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq,\r\nint cq_idx)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err = 0;\r\nint timestamp_en = 0;\r\nbool assigned_eq = false;\r\ncq->dev = mdev->pndev[priv->port];\r\ncq->mcq.set_ci_db = cq->wqres.db.db;\r\ncq->mcq.arm_db = cq->wqres.db.db + 1;\r\n*cq->mcq.set_ci_db = 0;\r\n*cq->mcq.arm_db = 0;\r\nmemset(cq->buf, 0, cq->buf_size);\r\nif (cq->is_tx == RX) {\r\nif (!mlx4_is_eq_vector_valid(mdev->dev, priv->port,\r\ncq->vector)) {\r\ncq->vector = cpumask_first(priv->rx_ring[cq->ring]->affinity_mask);\r\nerr = mlx4_assign_eq(mdev->dev, priv->port,\r\n&cq->vector);\r\nif (err) {\r\nmlx4_err(mdev, "Failed assigning an EQ to CQ vector %d\n",\r\ncq->vector);\r\ngoto free_eq;\r\n}\r\nassigned_eq = true;\r\n}\r\ncq->irq_desc =\r\nirq_to_desc(mlx4_eq_get_irq(mdev->dev,\r\ncq->vector));\r\n} else {\r\nstruct mlx4_en_cq *rx_cq;\r\ncq_idx = cq_idx % priv->rx_ring_num;\r\nrx_cq = priv->rx_cq[cq_idx];\r\ncq->vector = rx_cq->vector;\r\n}\r\nif (!cq->is_tx)\r\ncq->size = priv->rx_ring[cq->ring]->actual_size;\r\nif ((cq->is_tx && priv->hwtstamp_config.tx_type) ||\r\n(!cq->is_tx && priv->hwtstamp_config.rx_filter))\r\ntimestamp_en = 1;\r\nerr = mlx4_cq_alloc(mdev->dev, cq->size, &cq->wqres.mtt,\r\n&mdev->priv_uar, cq->wqres.db.dma, &cq->mcq,\r\ncq->vector, 0, timestamp_en);\r\nif (err)\r\ngoto free_eq;\r\ncq->mcq.comp = cq->is_tx ? mlx4_en_tx_irq : mlx4_en_rx_irq;\r\ncq->mcq.event = mlx4_en_cq_event;\r\nif (cq->is_tx)\r\nnetif_tx_napi_add(cq->dev, &cq->napi, mlx4_en_poll_tx_cq,\r\nNAPI_POLL_WEIGHT);\r\nelse\r\nnetif_napi_add(cq->dev, &cq->napi, mlx4_en_poll_rx_cq, 64);\r\nnapi_enable(&cq->napi);\r\nreturn 0;\r\nfree_eq:\r\nif (assigned_eq)\r\nmlx4_release_eq(mdev->dev, cq->vector);\r\ncq->vector = mdev->dev->caps.num_comp_vectors;\r\nreturn err;\r\n}\r\nvoid mlx4_en_destroy_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq **pcq)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nstruct mlx4_en_cq *cq = *pcq;\r\nmlx4_free_hwq_res(mdev->dev, &cq->wqres, cq->buf_size);\r\nif (mlx4_is_eq_vector_valid(mdev->dev, priv->port, cq->vector) &&\r\ncq->is_tx == RX)\r\nmlx4_release_eq(priv->mdev->dev, cq->vector);\r\ncq->vector = 0;\r\ncq->buf_size = 0;\r\ncq->buf = NULL;\r\nkfree(cq);\r\n*pcq = NULL;\r\n}\r\nvoid mlx4_en_deactivate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\r\n{\r\nnapi_disable(&cq->napi);\r\nif (!cq->is_tx) {\r\nnapi_hash_del(&cq->napi);\r\nsynchronize_rcu();\r\n}\r\nnetif_napi_del(&cq->napi);\r\nmlx4_cq_free(priv->mdev->dev, &cq->mcq);\r\n}\r\nint mlx4_en_set_cq_moder(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\r\n{\r\nreturn mlx4_cq_modify(priv->mdev->dev, &cq->mcq,\r\ncq->moder_cnt, cq->moder_time);\r\n}\r\nint mlx4_en_arm_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\r\n{\r\nmlx4_cq_arm(&cq->mcq, MLX4_CQ_DB_REQ_NOT, priv->mdev->uar_map,\r\n&priv->mdev->uar_lock);\r\nreturn 0;\r\n}
