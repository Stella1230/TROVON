acpi_status\r\nacpi_ds_result_pop(union acpi_operand_object **object,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\nu32 index;\r\nunion acpi_generic_state *state;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(ds_result_pop);\r\nstate = walk_state->results;\r\nif (state && !walk_state->result_count) {\r\nACPI_ERROR((AE_INFO, "No results on result stack"));\r\nreturn (AE_AML_INTERNAL);\r\n}\r\nif (!state && walk_state->result_count) {\r\nACPI_ERROR((AE_INFO, "No result state for result stack"));\r\nreturn (AE_AML_INTERNAL);\r\n}\r\nif (!state) {\r\nACPI_ERROR((AE_INFO, "Result stack is empty! State=%p",\r\nwalk_state));\r\nreturn (AE_AML_NO_RETURN_VALUE);\r\n}\r\nwalk_state->result_count--;\r\nindex = (u32)walk_state->result_count % ACPI_RESULTS_FRAME_OBJ_NUM;\r\n*object = state->results.obj_desc[index];\r\nif (!*object) {\r\nACPI_ERROR((AE_INFO,\r\n"No result objects on result stack, State=%p",\r\nwalk_state));\r\nreturn (AE_AML_NO_RETURN_VALUE);\r\n}\r\nstate->results.obj_desc[index] = NULL;\r\nif (index == 0) {\r\nstatus = acpi_ds_result_stack_pop(walk_state);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Obj=%p [%s] Index=%X State=%p Num=%X\n", *object,\r\nacpi_ut_get_object_type_name(*object),\r\nindex, walk_state, walk_state->result_count));\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_ds_result_push(union acpi_operand_object *object,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\nunion acpi_generic_state *state;\r\nacpi_status status;\r\nu32 index;\r\nACPI_FUNCTION_NAME(ds_result_push);\r\nif (walk_state->result_count > walk_state->result_size) {\r\nACPI_ERROR((AE_INFO, "Result stack is full"));\r\nreturn (AE_AML_INTERNAL);\r\n} else if (walk_state->result_count == walk_state->result_size) {\r\nstatus = acpi_ds_result_stack_push(walk_state);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO,\r\n"Failed to extend the result stack"));\r\nreturn (status);\r\n}\r\n}\r\nif (!(walk_state->result_count < walk_state->result_size)) {\r\nACPI_ERROR((AE_INFO, "No free elements in result stack"));\r\nreturn (AE_AML_INTERNAL);\r\n}\r\nstate = walk_state->results;\r\nif (!state) {\r\nACPI_ERROR((AE_INFO, "No result stack frame during push"));\r\nreturn (AE_AML_INTERNAL);\r\n}\r\nif (!object) {\r\nACPI_ERROR((AE_INFO,\r\n"Null Object! Obj=%p State=%p Num=%u",\r\nobject, walk_state, walk_state->result_count));\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nindex = (u32)walk_state->result_count % ACPI_RESULTS_FRAME_OBJ_NUM;\r\nstate->results.obj_desc[index] = object;\r\nwalk_state->result_count++;\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Obj=%p [%s] State=%p Num=%X Cur=%X\n",\r\nobject,\r\nacpi_ut_get_object_type_name((union\r\nacpi_operand_object *)\r\nobject), walk_state,\r\nwalk_state->result_count,\r\nwalk_state->current_result));\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status acpi_ds_result_stack_push(struct acpi_walk_state *walk_state)\r\n{\r\nunion acpi_generic_state *state;\r\nACPI_FUNCTION_NAME(ds_result_stack_push);\r\nif (((u32) walk_state->result_size + ACPI_RESULTS_FRAME_OBJ_NUM) >\r\nACPI_RESULTS_OBJ_NUM_MAX) {\r\nACPI_ERROR((AE_INFO, "Result stack overflow: State=%p Num=%u",\r\nwalk_state, walk_state->result_size));\r\nreturn (AE_STACK_OVERFLOW);\r\n}\r\nstate = acpi_ut_create_generic_state();\r\nif (!state) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nstate->common.descriptor_type = ACPI_DESC_TYPE_STATE_RESULT;\r\nacpi_ut_push_generic_state(&walk_state->results, state);\r\nwalk_state->result_size += ACPI_RESULTS_FRAME_OBJ_NUM;\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Results=%p State=%p\n",\r\nstate, walk_state));\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status acpi_ds_result_stack_pop(struct acpi_walk_state *walk_state)\r\n{\r\nunion acpi_generic_state *state;\r\nACPI_FUNCTION_NAME(ds_result_stack_pop);\r\nif (walk_state->results == NULL) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Result stack underflow - State=%p\n",\r\nwalk_state));\r\nreturn (AE_AML_NO_OPERAND);\r\n}\r\nif (walk_state->result_size < ACPI_RESULTS_FRAME_OBJ_NUM) {\r\nACPI_ERROR((AE_INFO, "Insufficient result stack size"));\r\nreturn (AE_AML_INTERNAL);\r\n}\r\nstate = acpi_ut_pop_generic_state(&walk_state->results);\r\nacpi_ut_delete_generic_state(state);\r\nwalk_state->result_size -= ACPI_RESULTS_FRAME_OBJ_NUM;\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Result=%p RemainingResults=%X State=%p\n",\r\nstate, walk_state->result_count, walk_state));\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_ds_obj_stack_push(void *object, struct acpi_walk_state *walk_state)\r\n{\r\nACPI_FUNCTION_NAME(ds_obj_stack_push);\r\nif (walk_state->num_operands >= ACPI_OBJ_NUM_OPERANDS) {\r\nACPI_ERROR((AE_INFO,\r\n"Object stack overflow! Obj=%p State=%p #Ops=%u",\r\nobject, walk_state, walk_state->num_operands));\r\nreturn (AE_STACK_OVERFLOW);\r\n}\r\nwalk_state->operands[walk_state->operand_index] = object;\r\nwalk_state->num_operands++;\r\nwalk_state->operand_index++;\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Obj=%p [%s] State=%p #Ops=%X\n",\r\nobject,\r\nacpi_ut_get_object_type_name((union\r\nacpi_operand_object *)\r\nobject), walk_state,\r\nwalk_state->num_operands));\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_ds_obj_stack_pop(u32 pop_count, struct acpi_walk_state *walk_state)\r\n{\r\nu32 i;\r\nACPI_FUNCTION_NAME(ds_obj_stack_pop);\r\nfor (i = 0; i < pop_count; i++) {\r\nif (walk_state->num_operands == 0) {\r\nACPI_ERROR((AE_INFO,\r\n"Object stack underflow! Count=%X State=%p #Ops=%u",\r\npop_count, walk_state,\r\nwalk_state->num_operands));\r\nreturn (AE_STACK_UNDERFLOW);\r\n}\r\nwalk_state->num_operands--;\r\nwalk_state->operands[walk_state->num_operands] = NULL;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Count=%X State=%p #Ops=%u\n",\r\npop_count, walk_state, walk_state->num_operands));\r\nreturn (AE_OK);\r\n}\r\nvoid\r\nacpi_ds_obj_stack_pop_and_delete(u32 pop_count,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\ns32 i;\r\nunion acpi_operand_object *obj_desc;\r\nACPI_FUNCTION_NAME(ds_obj_stack_pop_and_delete);\r\nif (pop_count == 0) {\r\nreturn;\r\n}\r\nfor (i = (s32)pop_count - 1; i >= 0; i--) {\r\nif (walk_state->num_operands == 0) {\r\nreturn;\r\n}\r\nwalk_state->num_operands--;\r\nobj_desc = walk_state->operands[i];\r\nif (obj_desc) {\r\nacpi_ut_remove_reference(walk_state->operands[i]);\r\nwalk_state->operands[i] = NULL;\r\n}\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Count=%X State=%p #Ops=%X\n",\r\npop_count, walk_state, walk_state->num_operands));\r\n}\r\nstruct acpi_walk_state *acpi_ds_get_current_walk_state(struct acpi_thread_state\r\n*thread)\r\n{\r\nACPI_FUNCTION_NAME(ds_get_current_walk_state);\r\nif (!thread) {\r\nreturn (NULL);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE, "Current WalkState %p\n",\r\nthread->walk_state_list));\r\nreturn (thread->walk_state_list);\r\n}\r\nvoid\r\nacpi_ds_push_walk_state(struct acpi_walk_state *walk_state,\r\nstruct acpi_thread_state *thread)\r\n{\r\nACPI_FUNCTION_TRACE(ds_push_walk_state);\r\nwalk_state->next = thread->walk_state_list;\r\nthread->walk_state_list = walk_state;\r\nreturn_VOID;\r\n}\r\nstruct acpi_walk_state *acpi_ds_pop_walk_state(struct acpi_thread_state *thread)\r\n{\r\nstruct acpi_walk_state *walk_state;\r\nACPI_FUNCTION_TRACE(ds_pop_walk_state);\r\nwalk_state = thread->walk_state_list;\r\nif (walk_state) {\r\nthread->walk_state_list = walk_state->next;\r\n}\r\nreturn_PTR(walk_state);\r\n}\r\nstruct acpi_walk_state *acpi_ds_create_walk_state(acpi_owner_id owner_id,\r\nunion acpi_parse_object\r\n*origin,\r\nunion acpi_operand_object\r\n*method_desc,\r\nstruct acpi_thread_state\r\n*thread)\r\n{\r\nstruct acpi_walk_state *walk_state;\r\nACPI_FUNCTION_TRACE(ds_create_walk_state);\r\nwalk_state = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_walk_state));\r\nif (!walk_state) {\r\nreturn_PTR(NULL);\r\n}\r\nwalk_state->descriptor_type = ACPI_DESC_TYPE_WALK;\r\nwalk_state->method_desc = method_desc;\r\nwalk_state->owner_id = owner_id;\r\nwalk_state->origin = origin;\r\nwalk_state->thread = thread;\r\nwalk_state->parser_state.start_op = origin;\r\n#if (!defined (ACPI_NO_METHOD_EXECUTION) && !defined (ACPI_CONSTANT_EVAL_ONLY))\r\nacpi_ds_method_data_init(walk_state);\r\n#endif\r\nif (thread) {\r\nacpi_ds_push_walk_state(walk_state, thread);\r\n}\r\nreturn_PTR(walk_state);\r\n}\r\nacpi_status\r\nacpi_ds_init_aml_walk(struct acpi_walk_state *walk_state,\r\nunion acpi_parse_object *op,\r\nstruct acpi_namespace_node *method_node,\r\nu8 * aml_start,\r\nu32 aml_length,\r\nstruct acpi_evaluate_info *info, u8 pass_number)\r\n{\r\nacpi_status status;\r\nstruct acpi_parse_state *parser_state = &walk_state->parser_state;\r\nunion acpi_parse_object *extra_op;\r\nACPI_FUNCTION_TRACE(ds_init_aml_walk);\r\nwalk_state->parser_state.aml =\r\nwalk_state->parser_state.aml_start = aml_start;\r\nwalk_state->parser_state.aml_end =\r\nwalk_state->parser_state.pkg_end = aml_start + aml_length;\r\nwalk_state->next_op = NULL;\r\nwalk_state->pass_number = pass_number;\r\nif (info) {\r\nwalk_state->params = info->parameters;\r\nwalk_state->caller_return_desc = &info->return_object;\r\n}\r\nstatus = acpi_ps_init_scope(&walk_state->parser_state, op);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (method_node) {\r\nwalk_state->parser_state.start_node = method_node;\r\nwalk_state->walk_type = ACPI_WALK_METHOD;\r\nwalk_state->method_node = method_node;\r\nwalk_state->method_desc =\r\nacpi_ns_get_attached_object(method_node);\r\nstatus =\r\nacpi_ds_scope_stack_push(method_node, ACPI_TYPE_METHOD,\r\nwalk_state);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_ds_method_data_init_args(walk_state->params,\r\nACPI_METHOD_NUM_ARGS,\r\nwalk_state);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n} else {\r\nextra_op = parser_state->start_op;\r\nwhile (extra_op && !extra_op->common.node) {\r\nextra_op = extra_op->common.parent;\r\n}\r\nif (!extra_op) {\r\nparser_state->start_node = NULL;\r\n} else {\r\nparser_state->start_node = extra_op->common.node;\r\n}\r\nif (parser_state->start_node) {\r\nstatus =\r\nacpi_ds_scope_stack_push(parser_state->start_node,\r\nparser_state->start_node->\r\ntype, walk_state);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\n}\r\nstatus = acpi_ds_init_callbacks(walk_state, pass_number);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvoid acpi_ds_delete_walk_state(struct acpi_walk_state *walk_state)\r\n{\r\nunion acpi_generic_state *state;\r\nACPI_FUNCTION_TRACE_PTR(ds_delete_walk_state, walk_state);\r\nif (!walk_state) {\r\nreturn_VOID;\r\n}\r\nif (walk_state->descriptor_type != ACPI_DESC_TYPE_WALK) {\r\nACPI_ERROR((AE_INFO, "%p is not a valid walk state",\r\nwalk_state));\r\nreturn_VOID;\r\n}\r\nif (walk_state->parser_state.scope) {\r\nACPI_ERROR((AE_INFO, "%p walk still has a scope list",\r\nwalk_state));\r\nacpi_ps_cleanup_scope(&walk_state->parser_state);\r\n}\r\nwhile (walk_state->control_state) {\r\nstate = walk_state->control_state;\r\nwalk_state->control_state = state->common.next;\r\nacpi_ut_delete_generic_state(state);\r\n}\r\nwhile (walk_state->scope_info) {\r\nstate = walk_state->scope_info;\r\nwalk_state->scope_info = state->common.next;\r\nacpi_ut_delete_generic_state(state);\r\n}\r\nwhile (walk_state->results) {\r\nstate = walk_state->results;\r\nwalk_state->results = state->common.next;\r\nacpi_ut_delete_generic_state(state);\r\n}\r\nACPI_FREE(walk_state);\r\nreturn_VOID;\r\n}
