static int control_read(struct usbnet *dev,\r\nunsigned char request, unsigned short value,\r\nunsigned short index, void *data, unsigned short size,\r\nint timeout)\r\n{\r\nunsigned char *buf = NULL;\r\nunsigned char request_type;\r\nint err = 0;\r\nif (request == REQUEST_READ)\r\nrequest_type = (USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_OTHER);\r\nelse\r\nrequest_type = (USB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE);\r\nnetdev_dbg(dev->net, "Control_read() index=0x%02x size=%d\n",\r\nindex, size);\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nerr = usb_control_msg(dev->udev,\r\nusb_rcvctrlpipe(dev->udev, 0),\r\nrequest, request_type, value, index, buf, size,\r\ntimeout);\r\nif (err == size)\r\nmemcpy(data, buf, size);\r\nelse if (err >= 0)\r\nerr = -EINVAL;\r\nkfree(buf);\r\nreturn err;\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int control_write(struct usbnet *dev, unsigned char request,\r\nunsigned short value, unsigned short index,\r\nvoid *data, unsigned short size, int timeout)\r\n{\r\nunsigned char *buf = NULL;\r\nunsigned char request_type;\r\nint err = 0;\r\nif (request == REQUEST_WRITE)\r\nrequest_type = (USB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_OTHER);\r\nelse\r\nrequest_type = (USB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE);\r\nnetdev_dbg(dev->net, "Control_write() index=0x%02x size=%d\n",\r\nindex, size);\r\nif (data) {\r\nbuf = kmemdup(data, size, GFP_KERNEL);\r\nif (!buf) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\n}\r\nerr = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\nrequest, request_type, value, index, buf, size,\r\ntimeout);\r\nif (err >= 0 && err < size)\r\nerr = -EINVAL;\r\nkfree(buf);\r\nreturn 0;\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int ch9200_mdio_read(struct net_device *netdev, int phy_id, int loc)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nunsigned char buff[2];\r\nnetdev_dbg(netdev, "ch9200_mdio_read phy_id:%02x loc:%02x\n",\r\nphy_id, loc);\r\nif (phy_id != 0)\r\nreturn -ENODEV;\r\ncontrol_read(dev, REQUEST_READ, 0, loc * 2, buff, 0x02,\r\nCONTROL_TIMEOUT_MS);\r\nreturn (buff[0] | buff[1] << 8);\r\n}\r\nstatic void ch9200_mdio_write(struct net_device *netdev,\r\nint phy_id, int loc, int val)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nunsigned char buff[2];\r\nnetdev_dbg(netdev, "ch9200_mdio_write() phy_id=%02x loc:%02x\n",\r\nphy_id, loc);\r\nif (phy_id != 0)\r\nreturn;\r\nbuff[0] = (unsigned char)val;\r\nbuff[1] = (unsigned char)(val >> 8);\r\ncontrol_write(dev, REQUEST_WRITE, 0, loc * 2, buff, 0x02,\r\nCONTROL_TIMEOUT_MS);\r\n}\r\nstatic int ch9200_link_reset(struct usbnet *dev)\r\n{\r\nstruct ethtool_cmd ecmd;\r\nmii_check_media(&dev->mii, 1, 1);\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nnetdev_dbg(dev->net, "link_reset() speed:%d duplex:%d\n",\r\necmd.speed, ecmd.duplex);\r\nreturn 0;\r\n}\r\nstatic void ch9200_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nint link;\r\nunsigned char *buf;\r\nif (urb->actual_length < 16)\r\nreturn;\r\nbuf = urb->transfer_buffer;\r\nlink = !!(buf[0] & 0x01);\r\nif (link) {\r\nnetif_carrier_on(dev->net);\r\nusbnet_defer_kevent(dev, EVENT_LINK_RESET);\r\n} else {\r\nnetif_carrier_off(dev->net);\r\n}\r\n}\r\nstatic struct sk_buff *ch9200_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\r\ngfp_t flags)\r\n{\r\nint i = 0;\r\nint len = 0;\r\nint tx_overhead = 0;\r\ntx_overhead = 0x40;\r\nlen = skb->len;\r\nif (skb_headroom(skb) < tx_overhead) {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_copy_expand(skb, tx_overhead, 0, flags);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (!skb)\r\nreturn NULL;\r\n}\r\n__skb_push(skb, tx_overhead);\r\nif ((skb->len % dev->maxpacket) == 0)\r\nlen++;\r\nskb->data[0] = len;\r\nskb->data[1] = len >> 8;\r\nskb->data[2] = 0x00;\r\nskb->data[3] = 0x80;\r\nfor (i = 4; i < 48; i++)\r\nskb->data[i] = 0x00;\r\nskb->data[48] = len;\r\nskb->data[49] = len >> 8;\r\nskb->data[50] = 0x00;\r\nskb->data[51] = 0x80;\r\nfor (i = 52; i < 64; i++)\r\nskb->data[i] = 0x00;\r\nreturn skb;\r\n}\r\nstatic int ch9200_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nint len = 0;\r\nint rx_overhead = 0;\r\nrx_overhead = 64;\r\nif (unlikely(skb->len < rx_overhead)) {\r\ndev_err(&dev->udev->dev, "unexpected tiny rx frame\n");\r\nreturn 0;\r\n}\r\nlen = (skb->data[skb->len - 16] | skb->data[skb->len - 15] << 8);\r\nskb_trim(skb, len);\r\nreturn 1;\r\n}\r\nstatic int get_mac_address(struct usbnet *dev, unsigned char *data)\r\n{\r\nint err = 0;\r\nunsigned char mac_addr[0x06];\r\nint rd_mac_len = 0;\r\nnetdev_dbg(dev->net, "get_mac_address:\n\tusbnet VID:%0x PID:%0x\n",\r\ndev->udev->descriptor.idVendor,\r\ndev->udev->descriptor.idProduct);\r\nmemset(mac_addr, 0, sizeof(mac_addr));\r\nrd_mac_len = control_read(dev, REQUEST_READ, 0,\r\nMAC_REG_STATION_L, mac_addr, 0x02,\r\nCONTROL_TIMEOUT_MS);\r\nrd_mac_len += control_read(dev, REQUEST_READ, 0, MAC_REG_STATION_M,\r\nmac_addr + 2, 0x02, CONTROL_TIMEOUT_MS);\r\nrd_mac_len += control_read(dev, REQUEST_READ, 0, MAC_REG_STATION_H,\r\nmac_addr + 4, 0x02, CONTROL_TIMEOUT_MS);\r\nif (rd_mac_len != ETH_ALEN)\r\nerr = -EINVAL;\r\ndata[0] = mac_addr[5];\r\ndata[1] = mac_addr[4];\r\ndata[2] = mac_addr[3];\r\ndata[3] = mac_addr[2];\r\ndata[4] = mac_addr[1];\r\ndata[5] = mac_addr[0];\r\nreturn err;\r\n}\r\nstatic int ch9200_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint retval = 0;\r\nunsigned char data[2];\r\nretval = usbnet_get_endpoints(dev, intf);\r\nif (retval)\r\nreturn retval;\r\ndev->mii.dev = dev->net;\r\ndev->mii.mdio_read = ch9200_mdio_read;\r\ndev->mii.mdio_write = ch9200_mdio_write;\r\ndev->mii.reg_num_mask = 0x1f;\r\ndev->mii.phy_id_mask = 0x1f;\r\ndev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\r\ndev->rx_urb_size = 24 * 64 + 16;\r\nmii_nway_restart(&dev->mii);\r\ndata[0] = 0x01;\r\ndata[1] = 0x0F;\r\nretval = control_write(dev, REQUEST_WRITE, 0, MAC_REG_THRESHOLD, data,\r\n0x02, CONTROL_TIMEOUT_MS);\r\ndata[0] = 0xA0;\r\ndata[1] = 0x90;\r\nretval = control_write(dev, REQUEST_WRITE, 0, MAC_REG_FIFO_DEPTH, data,\r\n0x02, CONTROL_TIMEOUT_MS);\r\ndata[0] = 0x30;\r\ndata[1] = 0x00;\r\nretval = control_write(dev, REQUEST_WRITE, 0, MAC_REG_PAUSE, data,\r\n0x02, CONTROL_TIMEOUT_MS);\r\ndata[0] = 0x17;\r\ndata[1] = 0xD8;\r\nretval = control_write(dev, REQUEST_WRITE, 0, MAC_REG_FLOW_CONTROL,\r\ndata, 0x02, CONTROL_TIMEOUT_MS);\r\ndata[0] = 0x01;\r\ndata[1] = 0x00;\r\nretval = control_write(dev, REQUEST_WRITE, 0, 254, data, 0x02,\r\nCONTROL_TIMEOUT_MS);\r\ndata[0] = 0x5F;\r\ndata[1] = 0x0D;\r\nretval = control_write(dev, REQUEST_WRITE, 0, MAC_REG_CTRL, data, 0x02,\r\nCONTROL_TIMEOUT_MS);\r\nretval = get_mac_address(dev, dev->net->dev_addr);\r\nreturn retval;\r\n}
