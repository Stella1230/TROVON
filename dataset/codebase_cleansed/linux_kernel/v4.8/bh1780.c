static int bh1780_write(struct bh1780_data *bh1780, u8 reg, u8 val)\r\n{\r\nint ret = i2c_smbus_write_byte_data(bh1780->client,\r\nBH1780_CMD_BIT | reg,\r\nval);\r\nif (ret < 0)\r\ndev_err(&bh1780->client->dev,\r\n"i2c_smbus_write_byte_data failed error "\r\n"%d, register %01x\n",\r\nret, reg);\r\nreturn ret;\r\n}\r\nstatic int bh1780_read(struct bh1780_data *bh1780, u8 reg)\r\n{\r\nint ret = i2c_smbus_read_byte_data(bh1780->client,\r\nBH1780_CMD_BIT | reg);\r\nif (ret < 0)\r\ndev_err(&bh1780->client->dev,\r\n"i2c_smbus_read_byte_data failed error "\r\n"%d, register %01x\n",\r\nret, reg);\r\nreturn ret;\r\n}\r\nstatic int bh1780_read_word(struct bh1780_data *bh1780, u8 reg)\r\n{\r\nint ret = i2c_smbus_read_word_data(bh1780->client,\r\nBH1780_CMD_BIT | reg);\r\nif (ret < 0)\r\ndev_err(&bh1780->client->dev,\r\n"i2c_smbus_read_word_data failed error "\r\n"%d, register %01x\n",\r\nret, reg);\r\nreturn ret;\r\n}\r\nstatic int bh1780_debugfs_reg_access(struct iio_dev *indio_dev,\r\nunsigned int reg, unsigned int writeval,\r\nunsigned int *readval)\r\n{\r\nstruct bh1780_data *bh1780 = iio_priv(indio_dev);\r\nint ret;\r\nif (!readval)\r\nreturn bh1780_write(bh1780, (u8)reg, (u8)writeval);\r\nret = bh1780_read(bh1780, (u8)reg);\r\nif (ret < 0)\r\nreturn ret;\r\n*readval = ret;\r\nreturn 0;\r\n}\r\nstatic int bh1780_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct bh1780_data *bh1780 = iio_priv(indio_dev);\r\nint value;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\npm_runtime_get_sync(&bh1780->client->dev);\r\nvalue = bh1780_read_word(bh1780, BH1780_REG_DLOW);\r\nif (value < 0)\r\nreturn value;\r\npm_runtime_mark_last_busy(&bh1780->client->dev);\r\npm_runtime_put_autosuspend(&bh1780->client->dev);\r\n*val = value;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_INT_TIME:\r\n*val = 0;\r\n*val2 = BH1780_INTERVAL * 1000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bh1780_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct bh1780_data *bh1780;\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct iio_dev *indio_dev;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))\r\nreturn -EIO;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*bh1780));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nbh1780 = iio_priv(indio_dev);\r\nbh1780->client = client;\r\ni2c_set_clientdata(client, indio_dev);\r\nret = bh1780_write(bh1780, BH1780_REG_CONTROL, BH1780_PON);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(BH1780_PON_DELAY);\r\npm_runtime_get_noresume(&client->dev);\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_enable(&client->dev);\r\nret = bh1780_read(bh1780, BH1780_REG_PARTID);\r\nif (ret < 0)\r\ngoto out_disable_pm;\r\ndev_info(&client->dev,\r\n"Ambient Light Sensor, Rev : %lu\n",\r\n(ret & BH1780_REVMASK));\r\npm_runtime_set_autosuspend_delay(&client->dev, 5000);\r\npm_runtime_use_autosuspend(&client->dev);\r\npm_runtime_put(&client->dev);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &bh1780_info;\r\nindio_dev->name = "bh1780";\r\nindio_dev->channels = bh1780_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(bh1780_channels);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto out_disable_pm;\r\nreturn 0;\r\nout_disable_pm:\r\npm_runtime_put_noidle(&client->dev);\r\npm_runtime_disable(&client->dev);\r\nreturn ret;\r\n}\r\nstatic int bh1780_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct bh1780_data *bh1780 = iio_priv(indio_dev);\r\nint ret;\r\niio_device_unregister(indio_dev);\r\npm_runtime_get_sync(&client->dev);\r\npm_runtime_put_noidle(&client->dev);\r\npm_runtime_disable(&client->dev);\r\nret = bh1780_write(bh1780, BH1780_REG_CONTROL, BH1780_POFF);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed to power off\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bh1780_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct bh1780_data *bh1780 = iio_priv(indio_dev);\r\nint ret;\r\nret = bh1780_write(bh1780, BH1780_REG_CONTROL, BH1780_POFF);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to runtime suspend\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bh1780_runtime_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct bh1780_data *bh1780 = iio_priv(indio_dev);\r\nint ret;\r\nret = bh1780_write(bh1780, BH1780_REG_CONTROL, BH1780_PON);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to runtime resume\n");\r\nreturn ret;\r\n}\r\nmsleep(BH1780_PON_DELAY + BH1780_INTERVAL);\r\nreturn 0;\r\n}
