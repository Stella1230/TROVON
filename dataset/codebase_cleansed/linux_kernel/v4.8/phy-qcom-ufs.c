int ufs_qcom_phy_calibrate(struct ufs_qcom_phy *ufs_qcom_phy,\r\nstruct ufs_qcom_phy_calibration *tbl_A,\r\nint tbl_size_A,\r\nstruct ufs_qcom_phy_calibration *tbl_B,\r\nint tbl_size_B, bool is_rate_B)\r\n{\r\nint i;\r\nint ret = 0;\r\nif (!tbl_A) {\r\ndev_err(ufs_qcom_phy->dev, "%s: tbl_A is NULL", __func__);\r\nret = EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < tbl_size_A; i++)\r\nwritel_relaxed(tbl_A[i].cfg_value,\r\nufs_qcom_phy->mmio + tbl_A[i].reg_offset);\r\nif (is_rate_B) {\r\nif (!tbl_B) {\r\ndev_err(ufs_qcom_phy->dev, "%s: tbl_B is NULL",\r\n__func__);\r\nret = EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < tbl_size_B; i++)\r\nwritel_relaxed(tbl_B[i].cfg_value,\r\nufs_qcom_phy->mmio + tbl_B[i].reg_offset);\r\n}\r\nmb();\r\nout:\r\nreturn ret;\r\n}\r\nstruct phy *ufs_qcom_phy_generic_probe(struct platform_device *pdev,\r\nstruct ufs_qcom_phy *common_cfg,\r\nconst struct phy_ops *ufs_qcom_phy_gen_ops,\r\nstruct ufs_qcom_phy_specific_ops *phy_spec_ops)\r\n{\r\nint err;\r\nstruct device *dev = &pdev->dev;\r\nstruct phy *generic_phy = NULL;\r\nstruct phy_provider *phy_provider;\r\nerr = ufs_qcom_phy_base_init(pdev, common_cfg);\r\nif (err) {\r\ndev_err(dev, "%s: phy base init failed %d\n", __func__, err);\r\ngoto out;\r\n}\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (IS_ERR(phy_provider)) {\r\nerr = PTR_ERR(phy_provider);\r\ndev_err(dev, "%s: failed to register phy %d\n", __func__, err);\r\ngoto out;\r\n}\r\ngeneric_phy = devm_phy_create(dev, NULL, ufs_qcom_phy_gen_ops);\r\nif (IS_ERR(generic_phy)) {\r\nerr = PTR_ERR(generic_phy);\r\ndev_err(dev, "%s: failed to create phy %d\n", __func__, err);\r\ngeneric_phy = NULL;\r\ngoto out;\r\n}\r\ncommon_cfg->phy_spec_ops = phy_spec_ops;\r\ncommon_cfg->dev = dev;\r\nout:\r\nreturn generic_phy;\r\n}\r\nstruct ufs_qcom_phy *get_ufs_qcom_phy(struct phy *generic_phy)\r\n{\r\nreturn (struct ufs_qcom_phy *)phy_get_drvdata(generic_phy);\r\n}\r\nstatic\r\nint ufs_qcom_phy_base_init(struct platform_device *pdev,\r\nstruct ufs_qcom_phy *phy_common)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nint err = 0;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy_mem");\r\nphy_common->mmio = devm_ioremap_resource(dev, res);\r\nif (IS_ERR((void const *)phy_common->mmio)) {\r\nerr = PTR_ERR((void const *)phy_common->mmio);\r\nphy_common->mmio = NULL;\r\ndev_err(dev, "%s: ioremap for phy_mem resource failed %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"dev_ref_clk_ctrl_mem");\r\nphy_common->dev_ref_clk_ctrl_mmio = devm_ioremap_resource(dev, res);\r\nif (IS_ERR((void const *)phy_common->dev_ref_clk_ctrl_mmio))\r\nphy_common->dev_ref_clk_ctrl_mmio = NULL;\r\nreturn 0;\r\n}\r\nstatic int __ufs_qcom_phy_clk_get(struct phy *phy,\r\nconst char *name, struct clk **clk_out, bool err_print)\r\n{\r\nstruct clk *clk;\r\nint err = 0;\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(phy);\r\nstruct device *dev = ufs_qcom_phy->dev;\r\nclk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk)) {\r\nerr = PTR_ERR(clk);\r\nif (err_print)\r\ndev_err(dev, "failed to get %s err %d", name, err);\r\n} else {\r\n*clk_out = clk;\r\n}\r\nreturn err;\r\n}\r\nstatic\r\nint ufs_qcom_phy_clk_get(struct phy *phy,\r\nconst char *name, struct clk **clk_out)\r\n{\r\nreturn __ufs_qcom_phy_clk_get(phy, name, clk_out, true);\r\n}\r\nint\r\nufs_qcom_phy_init_clks(struct phy *generic_phy,\r\nstruct ufs_qcom_phy *phy_common)\r\n{\r\nint err;\r\nerr = ufs_qcom_phy_clk_get(generic_phy, "tx_iface_clk",\r\n&phy_common->tx_iface_clk);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_phy_clk_get(generic_phy, "rx_iface_clk",\r\n&phy_common->rx_iface_clk);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_phy_clk_get(generic_phy, "ref_clk_src",\r\n&phy_common->ref_clk_src);\r\nif (err)\r\ngoto out;\r\n__ufs_qcom_phy_clk_get(generic_phy, "ref_clk_parent",\r\n&phy_common->ref_clk_parent, false);\r\nerr = ufs_qcom_phy_clk_get(generic_phy, "ref_clk",\r\n&phy_common->ref_clk);\r\nout:\r\nreturn err;\r\n}\r\nint\r\nufs_qcom_phy_init_vregulators(struct phy *generic_phy,\r\nstruct ufs_qcom_phy *phy_common)\r\n{\r\nint err;\r\nerr = ufs_qcom_phy_init_vreg(generic_phy, &phy_common->vdda_pll,\r\n"vdda-pll");\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_phy_init_vreg(generic_phy, &phy_common->vdda_phy,\r\n"vdda-phy");\r\nif (err)\r\ngoto out;\r\n__ufs_qcom_phy_init_vreg(generic_phy, &phy_common->vddp_ref_clk,\r\n"vddp-ref-clk", true);\r\nout:\r\nreturn err;\r\n}\r\nstatic int __ufs_qcom_phy_init_vreg(struct phy *phy,\r\nstruct ufs_qcom_phy_vreg *vreg, const char *name, bool optional)\r\n{\r\nint err = 0;\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(phy);\r\nstruct device *dev = ufs_qcom_phy->dev;\r\nchar prop_name[MAX_PROP_NAME];\r\nvreg->name = kstrdup(name, GFP_KERNEL);\r\nif (!vreg->name) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nvreg->reg = devm_regulator_get(dev, name);\r\nif (IS_ERR(vreg->reg)) {\r\nerr = PTR_ERR(vreg->reg);\r\nvreg->reg = NULL;\r\nif (!optional)\r\ndev_err(dev, "failed to get %s, %d\n", name, err);\r\ngoto out;\r\n}\r\nif (dev->of_node) {\r\nsnprintf(prop_name, MAX_PROP_NAME, "%s-max-microamp", name);\r\nerr = of_property_read_u32(dev->of_node,\r\nprop_name, &vreg->max_uA);\r\nif (err && err != -EINVAL) {\r\ndev_err(dev, "%s: failed to read %s\n",\r\n__func__, prop_name);\r\ngoto out;\r\n} else if (err == -EINVAL || !vreg->max_uA) {\r\nif (regulator_count_voltages(vreg->reg) > 0) {\r\ndev_err(dev, "%s: %s is mandatory\n",\r\n__func__, prop_name);\r\ngoto out;\r\n}\r\nerr = 0;\r\n}\r\nsnprintf(prop_name, MAX_PROP_NAME, "%s-always-on", name);\r\nif (of_get_property(dev->of_node, prop_name, NULL))\r\nvreg->is_always_on = true;\r\nelse\r\nvreg->is_always_on = false;\r\n}\r\nif (!strcmp(name, "vdda-pll")) {\r\nvreg->max_uV = VDDA_PLL_MAX_UV;\r\nvreg->min_uV = VDDA_PLL_MIN_UV;\r\n} else if (!strcmp(name, "vdda-phy")) {\r\nvreg->max_uV = VDDA_PHY_MAX_UV;\r\nvreg->min_uV = VDDA_PHY_MIN_UV;\r\n} else if (!strcmp(name, "vddp-ref-clk")) {\r\nvreg->max_uV = VDDP_REF_CLK_MAX_UV;\r\nvreg->min_uV = VDDP_REF_CLK_MIN_UV;\r\n}\r\nout:\r\nif (err)\r\nkfree(vreg->name);\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_phy_init_vreg(struct phy *phy,\r\nstruct ufs_qcom_phy_vreg *vreg, const char *name)\r\n{\r\nreturn __ufs_qcom_phy_init_vreg(phy, vreg, name, false);\r\n}\r\nstatic\r\nint ufs_qcom_phy_cfg_vreg(struct phy *phy,\r\nstruct ufs_qcom_phy_vreg *vreg, bool on)\r\n{\r\nint ret = 0;\r\nstruct regulator *reg = vreg->reg;\r\nconst char *name = vreg->name;\r\nint min_uV;\r\nint uA_load;\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(phy);\r\nstruct device *dev = ufs_qcom_phy->dev;\r\nBUG_ON(!vreg);\r\nif (regulator_count_voltages(reg) > 0) {\r\nmin_uV = on ? vreg->min_uV : 0;\r\nret = regulator_set_voltage(reg, min_uV, vreg->max_uV);\r\nif (ret) {\r\ndev_err(dev, "%s: %s set voltage failed, err=%d\n",\r\n__func__, name, ret);\r\ngoto out;\r\n}\r\nuA_load = on ? vreg->max_uA : 0;\r\nret = regulator_set_load(reg, uA_load);\r\nif (ret >= 0) {\r\nret = 0;\r\n} else {\r\ndev_err(dev, "%s: %s set optimum mode(uA_load=%d) failed, err=%d\n",\r\n__func__, name, uA_load, ret);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic\r\nint ufs_qcom_phy_enable_vreg(struct phy *phy,\r\nstruct ufs_qcom_phy_vreg *vreg)\r\n{\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(phy);\r\nstruct device *dev = ufs_qcom_phy->dev;\r\nint ret = 0;\r\nif (!vreg || vreg->enabled)\r\ngoto out;\r\nret = ufs_qcom_phy_cfg_vreg(phy, vreg, true);\r\nif (ret) {\r\ndev_err(dev, "%s: ufs_qcom_phy_cfg_vreg() failed, err=%d\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nret = regulator_enable(vreg->reg);\r\nif (ret) {\r\ndev_err(dev, "%s: enable failed, err=%d\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nvreg->enabled = true;\r\nout:\r\nreturn ret;\r\n}\r\nint ufs_qcom_phy_enable_ref_clk(struct phy *generic_phy)\r\n{\r\nint ret = 0;\r\nstruct ufs_qcom_phy *phy = get_ufs_qcom_phy(generic_phy);\r\nif (phy->is_ref_clk_enabled)\r\ngoto out;\r\nret = clk_prepare_enable(phy->ref_clk_src);\r\nif (ret) {\r\ndev_err(phy->dev, "%s: ref_clk_src enable failed %d\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nif (phy->ref_clk_parent) {\r\nret = clk_prepare_enable(phy->ref_clk_parent);\r\nif (ret) {\r\ndev_err(phy->dev, "%s: ref_clk_parent enable failed %d\n",\r\n__func__, ret);\r\ngoto out_disable_src;\r\n}\r\n}\r\nret = clk_prepare_enable(phy->ref_clk);\r\nif (ret) {\r\ndev_err(phy->dev, "%s: ref_clk enable failed %d\n",\r\n__func__, ret);\r\ngoto out_disable_parent;\r\n}\r\nphy->is_ref_clk_enabled = true;\r\ngoto out;\r\nout_disable_parent:\r\nif (phy->ref_clk_parent)\r\nclk_disable_unprepare(phy->ref_clk_parent);\r\nout_disable_src:\r\nclk_disable_unprepare(phy->ref_clk_src);\r\nout:\r\nreturn ret;\r\n}\r\nstatic\r\nint ufs_qcom_phy_disable_vreg(struct phy *phy,\r\nstruct ufs_qcom_phy_vreg *vreg)\r\n{\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(phy);\r\nstruct device *dev = ufs_qcom_phy->dev;\r\nint ret = 0;\r\nif (!vreg || !vreg->enabled || vreg->is_always_on)\r\ngoto out;\r\nret = regulator_disable(vreg->reg);\r\nif (!ret) {\r\nufs_qcom_phy_cfg_vreg(phy, vreg, false);\r\nvreg->enabled = false;\r\n} else {\r\ndev_err(dev, "%s: %s disable failed, err=%d\n",\r\n__func__, vreg->name, ret);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nvoid ufs_qcom_phy_disable_ref_clk(struct phy *generic_phy)\r\n{\r\nstruct ufs_qcom_phy *phy = get_ufs_qcom_phy(generic_phy);\r\nif (phy->is_ref_clk_enabled) {\r\nclk_disable_unprepare(phy->ref_clk);\r\nif (phy->ref_clk_parent)\r\nclk_disable_unprepare(phy->ref_clk_parent);\r\nclk_disable_unprepare(phy->ref_clk_src);\r\nphy->is_ref_clk_enabled = false;\r\n}\r\n}\r\nstatic void ufs_qcom_phy_dev_ref_clk_ctrl(struct phy *generic_phy, bool enable)\r\n{\r\nstruct ufs_qcom_phy *phy = get_ufs_qcom_phy(generic_phy);\r\nif (phy->dev_ref_clk_ctrl_mmio &&\r\n(enable ^ phy->is_dev_ref_clk_enabled)) {\r\nu32 temp = readl_relaxed(phy->dev_ref_clk_ctrl_mmio);\r\nif (enable)\r\ntemp |= UFS_REF_CLK_EN;\r\nelse\r\ntemp &= ~UFS_REF_CLK_EN;\r\nif (!enable)\r\nudelay(1);\r\nwritel_relaxed(temp, phy->dev_ref_clk_ctrl_mmio);\r\nwmb();\r\nif (enable)\r\nudelay(1);\r\nphy->is_dev_ref_clk_enabled = enable;\r\n}\r\n}\r\nvoid ufs_qcom_phy_enable_dev_ref_clk(struct phy *generic_phy)\r\n{\r\nufs_qcom_phy_dev_ref_clk_ctrl(generic_phy, true);\r\n}\r\nvoid ufs_qcom_phy_disable_dev_ref_clk(struct phy *generic_phy)\r\n{\r\nufs_qcom_phy_dev_ref_clk_ctrl(generic_phy, false);\r\n}\r\nint ufs_qcom_phy_enable_iface_clk(struct phy *generic_phy)\r\n{\r\nstruct ufs_qcom_phy *phy = get_ufs_qcom_phy(generic_phy);\r\nint ret = 0;\r\nif (phy->is_iface_clk_enabled)\r\ngoto out;\r\nret = clk_prepare_enable(phy->tx_iface_clk);\r\nif (ret) {\r\ndev_err(phy->dev, "%s: tx_iface_clk enable failed %d\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nret = clk_prepare_enable(phy->rx_iface_clk);\r\nif (ret) {\r\nclk_disable_unprepare(phy->tx_iface_clk);\r\ndev_err(phy->dev, "%s: rx_iface_clk enable failed %d. disabling also tx_iface_clk\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nphy->is_iface_clk_enabled = true;\r\nout:\r\nreturn ret;\r\n}\r\nvoid ufs_qcom_phy_disable_iface_clk(struct phy *generic_phy)\r\n{\r\nstruct ufs_qcom_phy *phy = get_ufs_qcom_phy(generic_phy);\r\nif (phy->is_iface_clk_enabled) {\r\nclk_disable_unprepare(phy->tx_iface_clk);\r\nclk_disable_unprepare(phy->rx_iface_clk);\r\nphy->is_iface_clk_enabled = false;\r\n}\r\n}\r\nint ufs_qcom_phy_start_serdes(struct phy *generic_phy)\r\n{\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(generic_phy);\r\nint ret = 0;\r\nif (!ufs_qcom_phy->phy_spec_ops->start_serdes) {\r\ndev_err(ufs_qcom_phy->dev, "%s: start_serdes() callback is not supported\n",\r\n__func__);\r\nret = -ENOTSUPP;\r\n} else {\r\nufs_qcom_phy->phy_spec_ops->start_serdes(ufs_qcom_phy);\r\n}\r\nreturn ret;\r\n}\r\nint ufs_qcom_phy_set_tx_lane_enable(struct phy *generic_phy, u32 tx_lanes)\r\n{\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(generic_phy);\r\nint ret = 0;\r\nif (!ufs_qcom_phy->phy_spec_ops->set_tx_lane_enable) {\r\ndev_err(ufs_qcom_phy->dev, "%s: set_tx_lane_enable() callback is not supported\n",\r\n__func__);\r\nret = -ENOTSUPP;\r\n} else {\r\nufs_qcom_phy->phy_spec_ops->set_tx_lane_enable(ufs_qcom_phy,\r\ntx_lanes);\r\n}\r\nreturn ret;\r\n}\r\nvoid ufs_qcom_phy_save_controller_version(struct phy *generic_phy,\r\nu8 major, u16 minor, u16 step)\r\n{\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(generic_phy);\r\nufs_qcom_phy->host_ctrl_rev_major = major;\r\nufs_qcom_phy->host_ctrl_rev_minor = minor;\r\nufs_qcom_phy->host_ctrl_rev_step = step;\r\n}\r\nint ufs_qcom_phy_calibrate_phy(struct phy *generic_phy, bool is_rate_B)\r\n{\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(generic_phy);\r\nint ret = 0;\r\nif (!ufs_qcom_phy->phy_spec_ops->calibrate_phy) {\r\ndev_err(ufs_qcom_phy->dev, "%s: calibrate_phy() callback is not supported\n",\r\n__func__);\r\nret = -ENOTSUPP;\r\n} else {\r\nret = ufs_qcom_phy->phy_spec_ops->\r\ncalibrate_phy(ufs_qcom_phy, is_rate_B);\r\nif (ret)\r\ndev_err(ufs_qcom_phy->dev, "%s: calibrate_phy() failed %d\n",\r\n__func__, ret);\r\n}\r\nreturn ret;\r\n}\r\nint ufs_qcom_phy_remove(struct phy *generic_phy,\r\nstruct ufs_qcom_phy *ufs_qcom_phy)\r\n{\r\nphy_power_off(generic_phy);\r\nkfree(ufs_qcom_phy->vdda_pll.name);\r\nkfree(ufs_qcom_phy->vdda_phy.name);\r\nreturn 0;\r\n}\r\nint ufs_qcom_phy_exit(struct phy *generic_phy)\r\n{\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(generic_phy);\r\nif (ufs_qcom_phy->is_powered_on)\r\nphy_power_off(generic_phy);\r\nreturn 0;\r\n}\r\nint ufs_qcom_phy_is_pcs_ready(struct phy *generic_phy)\r\n{\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(generic_phy);\r\nif (!ufs_qcom_phy->phy_spec_ops->is_physical_coding_sublayer_ready) {\r\ndev_err(ufs_qcom_phy->dev, "%s: is_physical_coding_sublayer_ready() callback is not supported\n",\r\n__func__);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn ufs_qcom_phy->phy_spec_ops->\r\nis_physical_coding_sublayer_ready(ufs_qcom_phy);\r\n}\r\nint ufs_qcom_phy_power_on(struct phy *generic_phy)\r\n{\r\nstruct ufs_qcom_phy *phy_common = get_ufs_qcom_phy(generic_phy);\r\nstruct device *dev = phy_common->dev;\r\nint err;\r\nerr = ufs_qcom_phy_enable_vreg(generic_phy, &phy_common->vdda_phy);\r\nif (err) {\r\ndev_err(dev, "%s enable vdda_phy failed, err=%d\n",\r\n__func__, err);\r\ngoto out;\r\n}\r\nphy_common->phy_spec_ops->power_control(phy_common, true);\r\nerr = ufs_qcom_phy_enable_vreg(generic_phy, &phy_common->vdda_pll);\r\nif (err) {\r\ndev_err(dev, "%s enable vdda_pll failed, err=%d\n",\r\n__func__, err);\r\ngoto out_disable_phy;\r\n}\r\nerr = ufs_qcom_phy_enable_ref_clk(generic_phy);\r\nif (err) {\r\ndev_err(dev, "%s enable phy ref clock failed, err=%d\n",\r\n__func__, err);\r\ngoto out_disable_pll;\r\n}\r\nif (phy_common->vddp_ref_clk.reg) {\r\nerr = ufs_qcom_phy_enable_vreg(generic_phy,\r\n&phy_common->vddp_ref_clk);\r\nif (err) {\r\ndev_err(dev, "%s enable vddp_ref_clk failed, err=%d\n",\r\n__func__, err);\r\ngoto out_disable_ref_clk;\r\n}\r\n}\r\nphy_common->is_powered_on = true;\r\ngoto out;\r\nout_disable_ref_clk:\r\nufs_qcom_phy_disable_ref_clk(generic_phy);\r\nout_disable_pll:\r\nufs_qcom_phy_disable_vreg(generic_phy, &phy_common->vdda_pll);\r\nout_disable_phy:\r\nufs_qcom_phy_disable_vreg(generic_phy, &phy_common->vdda_phy);\r\nout:\r\nreturn err;\r\n}\r\nint ufs_qcom_phy_power_off(struct phy *generic_phy)\r\n{\r\nstruct ufs_qcom_phy *phy_common = get_ufs_qcom_phy(generic_phy);\r\nphy_common->phy_spec_ops->power_control(phy_common, false);\r\nif (phy_common->vddp_ref_clk.reg)\r\nufs_qcom_phy_disable_vreg(generic_phy,\r\n&phy_common->vddp_ref_clk);\r\nufs_qcom_phy_disable_ref_clk(generic_phy);\r\nufs_qcom_phy_disable_vreg(generic_phy, &phy_common->vdda_pll);\r\nufs_qcom_phy_disable_vreg(generic_phy, &phy_common->vdda_phy);\r\nphy_common->is_powered_on = false;\r\nreturn 0;\r\n}
