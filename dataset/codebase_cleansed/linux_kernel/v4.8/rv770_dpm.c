struct rv7xx_ps *rv770_get_ps(struct radeon_ps *rps)\r\n{\r\nstruct rv7xx_ps *ps = rps->ps_priv;\r\nreturn ps;\r\n}\r\nstruct rv7xx_power_info *rv770_get_pi(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rdev->pm.dpm.priv;\r\nreturn pi;\r\n}\r\nstruct evergreen_power_info *evergreen_get_pi(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *pi = rdev->pm.dpm.priv;\r\nreturn pi;\r\n}\r\nstatic void rv770_enable_bif_dynamic_pcie_gen2(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 tmp;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\r\nif (enable) {\r\ntmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\r\ntmp |= LC_HW_VOLTAGE_IF_CONTROL(1);\r\ntmp |= LC_GEN2_EN_STRAP;\r\n} else {\r\nif (!pi->boot_in_gen2) {\r\ntmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\r\ntmp &= ~LC_GEN2_EN_STRAP;\r\n}\r\n}\r\nif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) ||\r\n(tmp & LC_OTHER_SIDE_SUPPORTS_GEN2))\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\n}\r\nstatic void rv770_enable_l0s(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_CNTL) & ~LC_L0S_INACTIVITY_MASK;\r\ntmp |= LC_L0S_INACTIVITY(3);\r\nWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\r\n}\r\nstatic void rv770_enable_l1(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_CNTL);\r\ntmp &= ~LC_L1_INACTIVITY_MASK;\r\ntmp |= LC_L1_INACTIVITY(4);\r\ntmp &= ~LC_PMI_TO_L1_DIS;\r\ntmp &= ~LC_ASPM_TO_L1_DIS;\r\nWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\r\n}\r\nstatic void rv770_enable_pll_sleep_in_l1(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_CNTL) & ~LC_L1_INACTIVITY_MASK;\r\ntmp |= LC_L1_INACTIVITY(8);\r\nWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\r\ntmp = RREG32_PCIE(PCIE_P_CNTL);\r\ntmp |= P_PLL_PWRDN_IN_L1L23;\r\ntmp &= ~P_PLL_BUF_PDNB;\r\ntmp &= ~P_PLL_PDNB;\r\ntmp |= P_ALLOW_PRX_FRONTEND_SHUTOFF;\r\nWREG32_PCIE(PCIE_P_CNTL, tmp);\r\n}\r\nstatic void rv770_gfx_clock_gating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\r\nelse {\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\r\nWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\r\nRREG32(GB_TILING_CONFIG);\r\n}\r\n}\r\nstatic void rv770_mg_clock_gating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nif (enable) {\r\nu32 mgcg_cgtt_local0;\r\nif (rdev->family == CHIP_RV770)\r\nmgcg_cgtt_local0 = RV770_MGCGTTLOCAL0_DFLT;\r\nelse\r\nmgcg_cgtt_local0 = RV7XX_MGCGTTLOCAL0_DFLT;\r\nWREG32(CG_CGTT_LOCAL_0, mgcg_cgtt_local0);\r\nWREG32(CG_CGTT_LOCAL_1, (RV770_MGCGTTLOCAL1_DFLT & 0xFFFFCFFF));\r\nif (pi->mgcgtssm)\r\nWREG32(CGTS_SM_CTRL_REG, RV770_MGCGCGTSSMCTRL_DFLT);\r\n} else {\r\nWREG32(CG_CGTT_LOCAL_0, 0xFFFFFFFF);\r\nWREG32(CG_CGTT_LOCAL_1, 0xFFFFCFFF);\r\n}\r\n}\r\nvoid rv770_restore_cgcg(struct radeon_device *rdev)\r\n{\r\nbool dpm_en = false, cg_en = false;\r\nif (RREG32(GENERAL_PWRMGT) & GLOBAL_PWRMGT_EN)\r\ndpm_en = true;\r\nif (RREG32(SCLK_PWRMGT_CNTL) & DYN_GFX_CLK_OFF_EN)\r\ncg_en = true;\r\nif (dpm_en && !cg_en)\r\nWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\r\n}\r\nstatic void rv770_start_dpm(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~SCLK_PWRMGT_OFF);\r\nWREG32_P(MCLK_PWRMGT_CNTL, 0, ~MPLL_PWRMGT_OFF);\r\nWREG32_P(GENERAL_PWRMGT, GLOBAL_PWRMGT_EN, ~GLOBAL_PWRMGT_EN);\r\n}\r\nvoid rv770_stop_dpm(struct radeon_device *rdev)\r\n{\r\nPPSMC_Result result;\r\nresult = rv770_send_msg_to_smc(rdev, PPSMC_MSG_TwoLevelsDisabled);\r\nif (result != PPSMC_Result_OK)\r\nDRM_DEBUG("Could not force DPM to low.\n");\r\nWREG32_P(GENERAL_PWRMGT, 0, ~GLOBAL_PWRMGT_EN);\r\nWREG32_P(SCLK_PWRMGT_CNTL, SCLK_PWRMGT_OFF, ~SCLK_PWRMGT_OFF);\r\nWREG32_P(MCLK_PWRMGT_CNTL, MPLL_PWRMGT_OFF, ~MPLL_PWRMGT_OFF);\r\n}\r\nbool rv770_dpm_enabled(struct radeon_device *rdev)\r\n{\r\nif (RREG32(GENERAL_PWRMGT) & GLOBAL_PWRMGT_EN)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nvoid rv770_enable_thermal_protection(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, 0, ~THERMAL_PROTECTION_DIS);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, THERMAL_PROTECTION_DIS, ~THERMAL_PROTECTION_DIS);\r\n}\r\nvoid rv770_enable_acpi_pm(struct radeon_device *rdev)\r\n{\r\nWREG32_P(GENERAL_PWRMGT, STATIC_PM_EN, ~STATIC_PM_EN);\r\n}\r\nu8 rv770_get_seq_value(struct radeon_device *rdev,\r\nstruct rv7xx_pl *pl)\r\n{\r\nreturn (pl->flags & ATOM_PPLIB_R600_FLAGS_LOWPOWER) ?\r\nMC_CG_SEQ_DRAMCONF_S0 : MC_CG_SEQ_DRAMCONF_S1;\r\n}\r\nint rv770_write_smc_soft_register(struct radeon_device *rdev,\r\nu16 reg_offset, u32 value)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nreturn rv770_write_smc_sram_dword(rdev,\r\npi->soft_regs_start + reg_offset,\r\nvalue, pi->sram_end);\r\n}\r\nint rv770_populate_smc_t(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state,\r\nRV770_SMC_SWSTATE *smc_state)\r\n{\r\nstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nint i;\r\nint a_n;\r\nint a_d;\r\nu8 l[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE];\r\nu8 r[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE];\r\nu32 a_t;\r\nl[0] = 0;\r\nr[2] = 100;\r\na_n = (int)state->medium.sclk * pi->lmp +\r\n(int)state->low.sclk * (R600_AH_DFLT - pi->rlp);\r\na_d = (int)state->low.sclk * (100 - (int)pi->rlp) +\r\n(int)state->medium.sclk * pi->lmp;\r\nl[1] = (u8)(pi->lmp - (int)pi->lmp * a_n / a_d);\r\nr[0] = (u8)(pi->rlp + (100 - (int)pi->rlp) * a_n / a_d);\r\na_n = (int)state->high.sclk * pi->lhp + (int)state->medium.sclk *\r\n(R600_AH_DFLT - pi->rmp);\r\na_d = (int)state->medium.sclk * (100 - (int)pi->rmp) +\r\n(int)state->high.sclk * pi->lhp;\r\nl[2] = (u8)(pi->lhp - (int)pi->lhp * a_n / a_d);\r\nr[1] = (u8)(pi->rmp + (100 - (int)pi->rmp) * a_n / a_d);\r\nfor (i = 0; i < (RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1); i++) {\r\na_t = CG_R(r[i] * pi->bsp / 200) | CG_L(l[i] * pi->bsp / 200);\r\nsmc_state->levels[i].aT = cpu_to_be32(a_t);\r\n}\r\na_t = CG_R(r[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1] * pi->pbsp / 200) |\r\nCG_L(l[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1] * pi->pbsp / 200);\r\nsmc_state->levels[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1].aT =\r\ncpu_to_be32(a_t);\r\nreturn 0;\r\n}\r\nint rv770_populate_smc_sp(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state,\r\nRV770_SMC_SWSTATE *smc_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nint i;\r\nfor (i = 0; i < (RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1); i++)\r\nsmc_state->levels[i].bSP = cpu_to_be32(pi->dsp);\r\nsmc_state->levels[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1].bSP =\r\ncpu_to_be32(pi->psp);\r\nreturn 0;\r\n}\r\nstatic void rv770_calculate_fractional_mpll_feedback_divider(u32 memory_clock,\r\nu32 reference_clock,\r\nbool gddr5,\r\nstruct atom_clock_dividers *dividers,\r\nu32 *clkf,\r\nu32 *clkfrac)\r\n{\r\nu32 post_divider, reference_divider, feedback_divider8;\r\nu32 fyclk;\r\nif (gddr5)\r\nfyclk = (memory_clock * 8) / 2;\r\nelse\r\nfyclk = (memory_clock * 4) / 2;\r\npost_divider = dividers->post_div;\r\nreference_divider = dividers->ref_div;\r\nfeedback_divider8 =\r\n(8 * fyclk * reference_divider * post_divider) / reference_clock;\r\n*clkf = feedback_divider8 / 8;\r\n*clkfrac = feedback_divider8 % 8;\r\n}\r\nstatic int rv770_encode_yclk_post_div(u32 postdiv, u32 *encoded_postdiv)\r\n{\r\nint ret = 0;\r\nswitch (postdiv) {\r\ncase 1:\r\n*encoded_postdiv = 0;\r\nbreak;\r\ncase 2:\r\n*encoded_postdiv = 1;\r\nbreak;\r\ncase 4:\r\n*encoded_postdiv = 2;\r\nbreak;\r\ncase 8:\r\n*encoded_postdiv = 3;\r\nbreak;\r\ncase 16:\r\n*encoded_postdiv = 4;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nu32 rv770_map_clkf_to_ibias(struct radeon_device *rdev, u32 clkf)\r\n{\r\nif (clkf <= 0x10)\r\nreturn 0x4B;\r\nif (clkf <= 0x19)\r\nreturn 0x5B;\r\nif (clkf <= 0x21)\r\nreturn 0x2B;\r\nif (clkf <= 0x27)\r\nreturn 0x6C;\r\nif (clkf <= 0x31)\r\nreturn 0x9D;\r\nreturn 0xC6;\r\n}\r\nstatic int rv770_populate_mclk_value(struct radeon_device *rdev,\r\nu32 engine_clock, u32 memory_clock,\r\nRV7XX_SMC_MCLK_VALUE *mclk)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu8 encoded_reference_dividers[] = { 0, 16, 17, 20, 21 };\r\nu32 mpll_ad_func_cntl =\r\npi->clk_regs.rv770.mpll_ad_func_cntl;\r\nu32 mpll_ad_func_cntl_2 =\r\npi->clk_regs.rv770.mpll_ad_func_cntl_2;\r\nu32 mpll_dq_func_cntl =\r\npi->clk_regs.rv770.mpll_dq_func_cntl;\r\nu32 mpll_dq_func_cntl_2 =\r\npi->clk_regs.rv770.mpll_dq_func_cntl_2;\r\nu32 mclk_pwrmgt_cntl =\r\npi->clk_regs.rv770.mclk_pwrmgt_cntl;\r\nu32 dll_cntl = pi->clk_regs.rv770.dll_cntl;\r\nstruct atom_clock_dividers dividers;\r\nu32 reference_clock = rdev->clock.mpll.reference_freq;\r\nu32 clkf, clkfrac;\r\nu32 postdiv_yclk;\r\nu32 ibias;\r\nint ret;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM,\r\nmemory_clock, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\nif ((dividers.ref_div < 1) || (dividers.ref_div > 5))\r\nreturn -EINVAL;\r\nrv770_calculate_fractional_mpll_feedback_divider(memory_clock, reference_clock,\r\npi->mem_gddr5,\r\n&dividers, &clkf, &clkfrac);\r\nret = rv770_encode_yclk_post_div(dividers.post_div, &postdiv_yclk);\r\nif (ret)\r\nreturn ret;\r\nibias = rv770_map_clkf_to_ibias(rdev, clkf);\r\nmpll_ad_func_cntl &= ~(CLKR_MASK |\r\nYCLK_POST_DIV_MASK |\r\nCLKF_MASK |\r\nCLKFRAC_MASK |\r\nIBIAS_MASK);\r\nmpll_ad_func_cntl |= CLKR(encoded_reference_dividers[dividers.ref_div - 1]);\r\nmpll_ad_func_cntl |= YCLK_POST_DIV(postdiv_yclk);\r\nmpll_ad_func_cntl |= CLKF(clkf);\r\nmpll_ad_func_cntl |= CLKFRAC(clkfrac);\r\nmpll_ad_func_cntl |= IBIAS(ibias);\r\nif (dividers.vco_mode)\r\nmpll_ad_func_cntl_2 |= VCO_MODE;\r\nelse\r\nmpll_ad_func_cntl_2 &= ~VCO_MODE;\r\nif (pi->mem_gddr5) {\r\nrv770_calculate_fractional_mpll_feedback_divider(memory_clock,\r\nreference_clock,\r\npi->mem_gddr5,\r\n&dividers, &clkf, &clkfrac);\r\nibias = rv770_map_clkf_to_ibias(rdev, clkf);\r\nret = rv770_encode_yclk_post_div(dividers.post_div, &postdiv_yclk);\r\nif (ret)\r\nreturn ret;\r\nmpll_dq_func_cntl &= ~(CLKR_MASK |\r\nYCLK_POST_DIV_MASK |\r\nCLKF_MASK |\r\nCLKFRAC_MASK |\r\nIBIAS_MASK);\r\nmpll_dq_func_cntl |= CLKR(encoded_reference_dividers[dividers.ref_div - 1]);\r\nmpll_dq_func_cntl |= YCLK_POST_DIV(postdiv_yclk);\r\nmpll_dq_func_cntl |= CLKF(clkf);\r\nmpll_dq_func_cntl |= CLKFRAC(clkfrac);\r\nmpll_dq_func_cntl |= IBIAS(ibias);\r\nif (dividers.vco_mode)\r\nmpll_dq_func_cntl_2 |= VCO_MODE;\r\nelse\r\nmpll_dq_func_cntl_2 &= ~VCO_MODE;\r\n}\r\nmclk->mclk770.mclk_value = cpu_to_be32(memory_clock);\r\nmclk->mclk770.vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\r\nmclk->mclk770.vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);\r\nmclk->mclk770.vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\r\nmclk->mclk770.vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);\r\nmclk->mclk770.vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\r\nmclk->mclk770.vDLL_CNTL = cpu_to_be32(dll_cntl);\r\nreturn 0;\r\n}\r\nstatic int rv770_populate_sclk_value(struct radeon_device *rdev,\r\nu32 engine_clock,\r\nRV770_SMC_SCLK_VALUE *sclk)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct atom_clock_dividers dividers;\r\nu32 spll_func_cntl =\r\npi->clk_regs.rv770.cg_spll_func_cntl;\r\nu32 spll_func_cntl_2 =\r\npi->clk_regs.rv770.cg_spll_func_cntl_2;\r\nu32 spll_func_cntl_3 =\r\npi->clk_regs.rv770.cg_spll_func_cntl_3;\r\nu32 cg_spll_spread_spectrum =\r\npi->clk_regs.rv770.cg_spll_spread_spectrum;\r\nu32 cg_spll_spread_spectrum_2 =\r\npi->clk_regs.rv770.cg_spll_spread_spectrum_2;\r\nu64 tmp;\r\nu32 reference_clock = rdev->clock.spll.reference_freq;\r\nu32 reference_divider, post_divider;\r\nu32 fbdiv;\r\nint ret;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\nengine_clock, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\nreference_divider = 1 + dividers.ref_div;\r\nif (dividers.enable_post_div)\r\npost_divider = (0x0f & (dividers.post_div >> 4)) + (0x0f & dividers.post_div) + 2;\r\nelse\r\npost_divider = 1;\r\ntmp = (u64) engine_clock * reference_divider * post_divider * 16384;\r\ndo_div(tmp, reference_clock);\r\nfbdiv = (u32) tmp;\r\nif (dividers.enable_post_div)\r\nspll_func_cntl |= SPLL_DIVEN;\r\nelse\r\nspll_func_cntl &= ~SPLL_DIVEN;\r\nspll_func_cntl &= ~(SPLL_HILEN_MASK | SPLL_LOLEN_MASK | SPLL_REF_DIV_MASK);\r\nspll_func_cntl |= SPLL_REF_DIV(dividers.ref_div);\r\nspll_func_cntl |= SPLL_HILEN((dividers.post_div >> 4) & 0xf);\r\nspll_func_cntl |= SPLL_LOLEN(dividers.post_div & 0xf);\r\nspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\r\nspll_func_cntl_2 |= SCLK_MUX_SEL(2);\r\nspll_func_cntl_3 &= ~SPLL_FB_DIV_MASK;\r\nspll_func_cntl_3 |= SPLL_FB_DIV(fbdiv);\r\nspll_func_cntl_3 |= SPLL_DITHEN;\r\nif (pi->sclk_ss) {\r\nstruct radeon_atom_ss ss;\r\nu32 vco_freq = engine_clock * post_divider;\r\nif (radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_ENGINE_SS, vco_freq)) {\r\nu32 clk_s = reference_clock * 5 / (reference_divider * ss.rate);\r\nu32 clk_v = ss.percentage * fbdiv / (clk_s * 10000);\r\ncg_spll_spread_spectrum &= ~CLKS_MASK;\r\ncg_spll_spread_spectrum |= CLKS(clk_s);\r\ncg_spll_spread_spectrum |= SSEN;\r\ncg_spll_spread_spectrum_2 &= ~CLKV_MASK;\r\ncg_spll_spread_spectrum_2 |= CLKV(clk_v);\r\n}\r\n}\r\nsclk->sclk_value = cpu_to_be32(engine_clock);\r\nsclk->vCG_SPLL_FUNC_CNTL = cpu_to_be32(spll_func_cntl);\r\nsclk->vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(spll_func_cntl_2);\r\nsclk->vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(spll_func_cntl_3);\r\nsclk->vCG_SPLL_SPREAD_SPECTRUM = cpu_to_be32(cg_spll_spread_spectrum);\r\nsclk->vCG_SPLL_SPREAD_SPECTRUM_2 = cpu_to_be32(cg_spll_spread_spectrum_2);\r\nreturn 0;\r\n}\r\nint rv770_populate_vddc_value(struct radeon_device *rdev, u16 vddc,\r\nRV770_SMC_VOLTAGE_VALUE *voltage)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nint i;\r\nif (!pi->voltage_control) {\r\nvoltage->index = 0;\r\nvoltage->value = 0;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < pi->valid_vddc_entries; i++) {\r\nif (vddc <= pi->vddc_table[i].vddc) {\r\nvoltage->index = pi->vddc_table[i].vddc_index;\r\nvoltage->value = cpu_to_be16(vddc);\r\nbreak;\r\n}\r\n}\r\nif (i == pi->valid_vddc_entries)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint rv770_populate_mvdd_value(struct radeon_device *rdev, u32 mclk,\r\nRV770_SMC_VOLTAGE_VALUE *voltage)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nif (!pi->mvdd_control) {\r\nvoltage->index = MVDD_HIGH_INDEX;\r\nvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\r\nreturn 0;\r\n}\r\nif (mclk <= pi->mvdd_split_frequency) {\r\nvoltage->index = MVDD_LOW_INDEX;\r\nvoltage->value = cpu_to_be16(MVDD_LOW_VALUE);\r\n} else {\r\nvoltage->index = MVDD_HIGH_INDEX;\r\nvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rv770_convert_power_level_to_smc(struct radeon_device *rdev,\r\nstruct rv7xx_pl *pl,\r\nRV770_SMC_HW_PERFORMANCE_LEVEL *level,\r\nu8 watermark_level)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nint ret;\r\nlevel->gen2PCIE = pi->pcie_gen2 ?\r\n((pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? 1 : 0) : 0;\r\nlevel->gen2XSP = (pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? 1 : 0;\r\nlevel->backbias = (pl->flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? 1 : 0;\r\nlevel->displayWatermark = watermark_level;\r\nif (rdev->family == CHIP_RV740)\r\nret = rv740_populate_sclk_value(rdev, pl->sclk,\r\n&level->sclk);\r\nelse if ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\r\nret = rv730_populate_sclk_value(rdev, pl->sclk,\r\n&level->sclk);\r\nelse\r\nret = rv770_populate_sclk_value(rdev, pl->sclk,\r\n&level->sclk);\r\nif (ret)\r\nreturn ret;\r\nif (rdev->family == CHIP_RV740) {\r\nif (pi->mem_gddr5) {\r\nif (pl->mclk <= pi->mclk_strobe_mode_threshold)\r\nlevel->strobeMode =\r\nrv740_get_mclk_frequency_ratio(pl->mclk) | 0x10;\r\nelse\r\nlevel->strobeMode = 0;\r\nif (pl->mclk > pi->mclk_edc_enable_threshold)\r\nlevel->mcFlags = SMC_MC_EDC_RD_FLAG | SMC_MC_EDC_WR_FLAG;\r\nelse\r\nlevel->mcFlags = 0;\r\n}\r\nret = rv740_populate_mclk_value(rdev, pl->sclk,\r\npl->mclk, &level->mclk);\r\n} else if ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\r\nret = rv730_populate_mclk_value(rdev, pl->sclk,\r\npl->mclk, &level->mclk);\r\nelse\r\nret = rv770_populate_mclk_value(rdev, pl->sclk,\r\npl->mclk, &level->mclk);\r\nif (ret)\r\nreturn ret;\r\nret = rv770_populate_vddc_value(rdev, pl->vddc,\r\n&level->vddc);\r\nif (ret)\r\nreturn ret;\r\nret = rv770_populate_mvdd_value(rdev, pl->mclk, &level->mvdd);\r\nreturn ret;\r\n}\r\nstatic int rv770_convert_power_state_to_smc(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state,\r\nRV770_SMC_SWSTATE *smc_state)\r\n{\r\nstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\r\nint ret;\r\nif (!(radeon_state->caps & ATOM_PPLIB_DISALLOW_ON_DC))\r\nsmc_state->flags |= PPSMC_SWSTATE_FLAG_DC;\r\nret = rv770_convert_power_level_to_smc(rdev,\r\n&state->low,\r\n&smc_state->levels[0],\r\nPPSMC_DISPLAY_WATERMARK_LOW);\r\nif (ret)\r\nreturn ret;\r\nret = rv770_convert_power_level_to_smc(rdev,\r\n&state->medium,\r\n&smc_state->levels[1],\r\nPPSMC_DISPLAY_WATERMARK_LOW);\r\nif (ret)\r\nreturn ret;\r\nret = rv770_convert_power_level_to_smc(rdev,\r\n&state->high,\r\n&smc_state->levels[2],\r\nPPSMC_DISPLAY_WATERMARK_HIGH);\r\nif (ret)\r\nreturn ret;\r\nsmc_state->levels[0].arbValue = MC_CG_ARB_FREQ_F1;\r\nsmc_state->levels[1].arbValue = MC_CG_ARB_FREQ_F2;\r\nsmc_state->levels[2].arbValue = MC_CG_ARB_FREQ_F3;\r\nsmc_state->levels[0].seqValue = rv770_get_seq_value(rdev,\r\n&state->low);\r\nsmc_state->levels[1].seqValue = rv770_get_seq_value(rdev,\r\n&state->medium);\r\nsmc_state->levels[2].seqValue = rv770_get_seq_value(rdev,\r\n&state->high);\r\nrv770_populate_smc_sp(rdev, radeon_state, smc_state);\r\nreturn rv770_populate_smc_t(rdev, radeon_state, smc_state);\r\n}\r\nu32 rv770_calculate_memory_refresh_rate(struct radeon_device *rdev,\r\nu32 engine_clock)\r\n{\r\nu32 dram_rows;\r\nu32 dram_refresh_rate;\r\nu32 mc_arb_rfsh_rate;\r\nu32 tmp;\r\ntmp = (RREG32(MC_ARB_RAMCFG) & NOOFROWS_MASK) >> NOOFROWS_SHIFT;\r\ndram_rows = 1 << (tmp + 10);\r\ntmp = RREG32(MC_SEQ_MISC0) & 3;\r\ndram_refresh_rate = 1 << (tmp + 3);\r\nmc_arb_rfsh_rate = ((engine_clock * 10) * dram_refresh_rate / dram_rows - 32) / 64;\r\nreturn mc_arb_rfsh_rate;\r\n}\r\nstatic void rv770_program_memory_timing_parameters(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state)\r\n{\r\nstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 sqm_ratio;\r\nu32 arb_refresh_rate;\r\nu32 high_clock;\r\nif (state->high.sclk < (state->low.sclk * 0xFF / 0x40))\r\nhigh_clock = state->high.sclk;\r\nelse\r\nhigh_clock = (state->low.sclk * 0xFF / 0x40);\r\nradeon_atom_set_engine_dram_timings(rdev, high_clock,\r\nstate->high.mclk);\r\nsqm_ratio =\r\nSTATE0(64 * high_clock / pi->boot_sclk) |\r\nSTATE1(64 * high_clock / state->low.sclk) |\r\nSTATE2(64 * high_clock / state->medium.sclk) |\r\nSTATE3(64 * high_clock / state->high.sclk);\r\nWREG32(MC_ARB_SQM_RATIO, sqm_ratio);\r\narb_refresh_rate =\r\nPOWERMODE0(rv770_calculate_memory_refresh_rate(rdev, pi->boot_sclk)) |\r\nPOWERMODE1(rv770_calculate_memory_refresh_rate(rdev, state->low.sclk)) |\r\nPOWERMODE2(rv770_calculate_memory_refresh_rate(rdev, state->medium.sclk)) |\r\nPOWERMODE3(rv770_calculate_memory_refresh_rate(rdev, state->high.sclk));\r\nWREG32(MC_ARB_RFSH_RATE, arb_refresh_rate);\r\n}\r\nvoid rv770_enable_backbias(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, BACKBIAS_PAD_EN, ~BACKBIAS_PAD_EN);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~(BACKBIAS_VALUE | BACKBIAS_PAD_EN));\r\n}\r\nstatic void rv770_enable_spread_spectrum(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nif (enable) {\r\nif (pi->sclk_ss)\r\nWREG32_P(GENERAL_PWRMGT, DYN_SPREAD_SPECTRUM_EN, ~DYN_SPREAD_SPECTRUM_EN);\r\nif (pi->mclk_ss) {\r\nif (rdev->family == CHIP_RV740)\r\nrv740_enable_mclk_spread_spectrum(rdev, true);\r\n}\r\n} else {\r\nWREG32_P(CG_SPLL_SPREAD_SPECTRUM, 0, ~SSEN);\r\nWREG32_P(GENERAL_PWRMGT, 0, ~DYN_SPREAD_SPECTRUM_EN);\r\nWREG32_P(CG_MPLL_SPREAD_SPECTRUM, 0, ~SSEN);\r\nif (rdev->family == CHIP_RV740)\r\nrv740_enable_mclk_spread_spectrum(rdev, false);\r\n}\r\n}\r\nstatic void rv770_program_mpll_timing_parameters(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nif ((rdev->family == CHIP_RV770) && !pi->mem_gddr5) {\r\nWREG32(MPLL_TIME,\r\n(MPLL_LOCK_TIME(R600_MPLLLOCKTIME_DFLT * pi->ref_div) |\r\nMPLL_RESET_TIME(R600_MPLLRESETTIME_DFLT)));\r\n}\r\n}\r\nvoid rv770_setup_bsp(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 xclk = radeon_get_xclk(rdev);\r\nr600_calculate_u_and_p(pi->asi,\r\nxclk,\r\n16,\r\n&pi->bsp,\r\n&pi->bsu);\r\nr600_calculate_u_and_p(pi->pasi,\r\nxclk,\r\n16,\r\n&pi->pbsp,\r\n&pi->pbsu);\r\npi->dsp = BSP(pi->bsp) | BSU(pi->bsu);\r\npi->psp = BSP(pi->pbsp) | BSU(pi->pbsu);\r\nWREG32(CG_BSP, pi->dsp);\r\n}\r\nvoid rv770_program_git(struct radeon_device *rdev)\r\n{\r\nWREG32_P(CG_GIT, CG_GICST(R600_GICST_DFLT), ~CG_GICST_MASK);\r\n}\r\nvoid rv770_program_tp(struct radeon_device *rdev)\r\n{\r\nint i;\r\nenum r600_td td = R600_TD_DFLT;\r\nfor (i = 0; i < R600_PM_NUMBER_OF_TC; i++)\r\nWREG32(CG_FFCT_0 + (i * 4), (UTC_0(r600_utc[i]) | DTC_0(r600_dtc[i])));\r\nif (td == R600_TD_AUTO)\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_FORCE_TREND_SEL);\r\nelse\r\nWREG32_P(SCLK_PWRMGT_CNTL, FIR_FORCE_TREND_SEL, ~FIR_FORCE_TREND_SEL);\r\nif (td == R600_TD_UP)\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_TREND_MODE);\r\nif (td == R600_TD_DOWN)\r\nWREG32_P(SCLK_PWRMGT_CNTL, FIR_TREND_MODE, ~FIR_TREND_MODE);\r\n}\r\nvoid rv770_program_tpp(struct radeon_device *rdev)\r\n{\r\nWREG32(CG_TPC, R600_TPC_DFLT);\r\n}\r\nvoid rv770_program_sstp(struct radeon_device *rdev)\r\n{\r\nWREG32(CG_SSP, (SSTU(R600_SSTU_DFLT) | SST(R600_SST_DFLT)));\r\n}\r\nvoid rv770_program_engine_speed_parameters(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SPLL_CNTL_MODE, SPLL_DIV_SYNC, ~SPLL_DIV_SYNC);\r\n}\r\nstatic void rv770_enable_display_gap(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32(CG_DISPLAY_GAP_CNTL);\r\ntmp &= ~(DISP1_GAP_MCHG_MASK | DISP2_GAP_MCHG_MASK);\r\ntmp |= (DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE) |\r\nDISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE));\r\nWREG32(CG_DISPLAY_GAP_CNTL, tmp);\r\n}\r\nvoid rv770_program_vc(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nWREG32(CG_FTV, pi->vrc);\r\n}\r\nvoid rv770_clear_vc(struct radeon_device *rdev)\r\n{\r\nWREG32(CG_FTV, 0);\r\n}\r\nint rv770_upload_firmware(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nint ret;\r\nrv770_reset_smc(rdev);\r\nrv770_stop_smc_clock(rdev);\r\nret = rv770_load_smc_ucode(rdev, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rv770_populate_smc_acpi_state(struct radeon_device *rdev,\r\nRV770_SMC_STATETABLE *table)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 mpll_ad_func_cntl =\r\npi->clk_regs.rv770.mpll_ad_func_cntl;\r\nu32 mpll_ad_func_cntl_2 =\r\npi->clk_regs.rv770.mpll_ad_func_cntl_2;\r\nu32 mpll_dq_func_cntl =\r\npi->clk_regs.rv770.mpll_dq_func_cntl;\r\nu32 mpll_dq_func_cntl_2 =\r\npi->clk_regs.rv770.mpll_dq_func_cntl_2;\r\nu32 spll_func_cntl =\r\npi->clk_regs.rv770.cg_spll_func_cntl;\r\nu32 spll_func_cntl_2 =\r\npi->clk_regs.rv770.cg_spll_func_cntl_2;\r\nu32 spll_func_cntl_3 =\r\npi->clk_regs.rv770.cg_spll_func_cntl_3;\r\nu32 mclk_pwrmgt_cntl;\r\nu32 dll_cntl;\r\ntable->ACPIState = table->initialState;\r\ntable->ACPIState.flags &= ~PPSMC_SWSTATE_FLAG_DC;\r\nif (pi->acpi_vddc) {\r\nrv770_populate_vddc_value(rdev, pi->acpi_vddc,\r\n&table->ACPIState.levels[0].vddc);\r\nif (pi->pcie_gen2) {\r\nif (pi->acpi_pcie_gen2)\r\ntable->ACPIState.levels[0].gen2PCIE = 1;\r\nelse\r\ntable->ACPIState.levels[0].gen2PCIE = 0;\r\n} else\r\ntable->ACPIState.levels[0].gen2PCIE = 0;\r\nif (pi->acpi_pcie_gen2)\r\ntable->ACPIState.levels[0].gen2XSP = 1;\r\nelse\r\ntable->ACPIState.levels[0].gen2XSP = 0;\r\n} else {\r\nrv770_populate_vddc_value(rdev, pi->min_vddc_in_table,\r\n&table->ACPIState.levels[0].vddc);\r\ntable->ACPIState.levels[0].gen2PCIE = 0;\r\n}\r\nmpll_ad_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN;\r\nmpll_dq_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN;\r\nmclk_pwrmgt_cntl = (MRDCKA0_RESET |\r\nMRDCKA1_RESET |\r\nMRDCKB0_RESET |\r\nMRDCKB1_RESET |\r\nMRDCKC0_RESET |\r\nMRDCKC1_RESET |\r\nMRDCKD0_RESET |\r\nMRDCKD1_RESET);\r\ndll_cntl = 0xff000000;\r\nspll_func_cntl |= SPLL_RESET | SPLL_SLEEP | SPLL_BYPASS_EN;\r\nspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\r\nspll_func_cntl_2 |= SCLK_MUX_SEL(4);\r\ntable->ACPIState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\r\ntable->ACPIState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);\r\ntable->ACPIState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\r\ntable->ACPIState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);\r\ntable->ACPIState.levels[0].mclk.mclk770.vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\r\ntable->ACPIState.levels[0].mclk.mclk770.vDLL_CNTL = cpu_to_be32(dll_cntl);\r\ntable->ACPIState.levels[0].mclk.mclk770.mclk_value = 0;\r\ntable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL = cpu_to_be32(spll_func_cntl);\r\ntable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(spll_func_cntl_2);\r\ntable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(spll_func_cntl_3);\r\ntable->ACPIState.levels[0].sclk.sclk_value = 0;\r\nrv770_populate_mvdd_value(rdev, 0, &table->ACPIState.levels[0].mvdd);\r\ntable->ACPIState.levels[1] = table->ACPIState.levels[0];\r\ntable->ACPIState.levels[2] = table->ACPIState.levels[0];\r\nreturn 0;\r\n}\r\nint rv770_populate_initial_mvdd_value(struct radeon_device *rdev,\r\nRV770_SMC_VOLTAGE_VALUE *voltage)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nif ((pi->s0_vid_lower_smio_cntl & pi->mvdd_mask_low) ==\r\n(pi->mvdd_low_smio[MVDD_LOW_INDEX] & pi->mvdd_mask_low) ) {\r\nvoltage->index = MVDD_LOW_INDEX;\r\nvoltage->value = cpu_to_be16(MVDD_LOW_VALUE);\r\n} else {\r\nvoltage->index = MVDD_HIGH_INDEX;\r\nvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rv770_populate_smc_initial_state(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state,\r\nRV770_SMC_STATETABLE *table)\r\n{\r\nstruct rv7xx_ps *initial_state = rv770_get_ps(radeon_state);\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 a_t;\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_ad_func_cntl);\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL_2 =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_ad_func_cntl_2);\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_dq_func_cntl);\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL_2 =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_dq_func_cntl_2);\r\ntable->initialState.levels[0].mclk.mclk770.vMCLK_PWRMGT_CNTL =\r\ncpu_to_be32(pi->clk_regs.rv770.mclk_pwrmgt_cntl);\r\ntable->initialState.levels[0].mclk.mclk770.vDLL_CNTL =\r\ncpu_to_be32(pi->clk_regs.rv770.dll_cntl);\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_SS =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_ss1);\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_SS2 =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_ss2);\r\ntable->initialState.levels[0].mclk.mclk770.mclk_value =\r\ncpu_to_be32(initial_state->low.mclk);\r\ntable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL =\r\ncpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl);\r\ntable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_2 =\r\ncpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl_2);\r\ntable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_3 =\r\ncpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl_3);\r\ntable->initialState.levels[0].sclk.vCG_SPLL_SPREAD_SPECTRUM =\r\ncpu_to_be32(pi->clk_regs.rv770.cg_spll_spread_spectrum);\r\ntable->initialState.levels[0].sclk.vCG_SPLL_SPREAD_SPECTRUM_2 =\r\ncpu_to_be32(pi->clk_regs.rv770.cg_spll_spread_spectrum_2);\r\ntable->initialState.levels[0].sclk.sclk_value =\r\ncpu_to_be32(initial_state->low.sclk);\r\ntable->initialState.levels[0].arbValue = MC_CG_ARB_FREQ_F0;\r\ntable->initialState.levels[0].seqValue =\r\nrv770_get_seq_value(rdev, &initial_state->low);\r\nrv770_populate_vddc_value(rdev,\r\ninitial_state->low.vddc,\r\n&table->initialState.levels[0].vddc);\r\nrv770_populate_initial_mvdd_value(rdev,\r\n&table->initialState.levels[0].mvdd);\r\na_t = CG_R(0xffff) | CG_L(0);\r\ntable->initialState.levels[0].aT = cpu_to_be32(a_t);\r\ntable->initialState.levels[0].bSP = cpu_to_be32(pi->dsp);\r\nif (pi->boot_in_gen2)\r\ntable->initialState.levels[0].gen2PCIE = 1;\r\nelse\r\ntable->initialState.levels[0].gen2PCIE = 0;\r\nif (initial_state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2)\r\ntable->initialState.levels[0].gen2XSP = 1;\r\nelse\r\ntable->initialState.levels[0].gen2XSP = 0;\r\nif (rdev->family == CHIP_RV740) {\r\nif (pi->mem_gddr5) {\r\nif (initial_state->low.mclk <= pi->mclk_strobe_mode_threshold)\r\ntable->initialState.levels[0].strobeMode =\r\nrv740_get_mclk_frequency_ratio(initial_state->low.mclk) | 0x10;\r\nelse\r\ntable->initialState.levels[0].strobeMode = 0;\r\nif (initial_state->low.mclk >= pi->mclk_edc_enable_threshold)\r\ntable->initialState.levels[0].mcFlags = SMC_MC_EDC_RD_FLAG | SMC_MC_EDC_WR_FLAG;\r\nelse\r\ntable->initialState.levels[0].mcFlags = 0;\r\n}\r\n}\r\ntable->initialState.levels[1] = table->initialState.levels[0];\r\ntable->initialState.levels[2] = table->initialState.levels[0];\r\ntable->initialState.flags |= PPSMC_SWSTATE_FLAG_DC;\r\nreturn 0;\r\n}\r\nstatic int rv770_populate_smc_vddc_table(struct radeon_device *rdev,\r\nRV770_SMC_STATETABLE *table)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nint i;\r\nfor (i = 0; i < pi->valid_vddc_entries; i++) {\r\ntable->highSMIO[pi->vddc_table[i].vddc_index] =\r\npi->vddc_table[i].high_smio;\r\ntable->lowSMIO[pi->vddc_table[i].vddc_index] =\r\ncpu_to_be32(pi->vddc_table[i].low_smio);\r\n}\r\ntable->voltageMaskTable.highMask[RV770_SMC_VOLTAGEMASK_VDDC] = 0;\r\ntable->voltageMaskTable.lowMask[RV770_SMC_VOLTAGEMASK_VDDC] =\r\ncpu_to_be32(pi->vddc_mask_low);\r\nfor (i = 0;\r\n((i < pi->valid_vddc_entries) &&\r\n(pi->max_vddc_in_table >\r\npi->vddc_table[i].vddc));\r\ni++);\r\ntable->maxVDDCIndexInPPTable =\r\npi->vddc_table[i].vddc_index;\r\nreturn 0;\r\n}\r\nstatic int rv770_populate_smc_mvdd_table(struct radeon_device *rdev,\r\nRV770_SMC_STATETABLE *table)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nif (pi->mvdd_control) {\r\ntable->lowSMIO[MVDD_HIGH_INDEX] |=\r\ncpu_to_be32(pi->mvdd_low_smio[MVDD_HIGH_INDEX]);\r\ntable->lowSMIO[MVDD_LOW_INDEX] |=\r\ncpu_to_be32(pi->mvdd_low_smio[MVDD_LOW_INDEX]);\r\ntable->voltageMaskTable.highMask[RV770_SMC_VOLTAGEMASK_MVDD] = 0;\r\ntable->voltageMaskTable.lowMask[RV770_SMC_VOLTAGEMASK_MVDD] =\r\ncpu_to_be32(pi->mvdd_mask_low);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rv770_init_smc_table(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_boot_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct rv7xx_ps *boot_state = rv770_get_ps(radeon_boot_state);\r\nRV770_SMC_STATETABLE *table = &pi->smc_statetable;\r\nint ret;\r\nmemset(table, 0, sizeof(RV770_SMC_STATETABLE));\r\npi->boot_sclk = boot_state->low.sclk;\r\nrv770_populate_smc_vddc_table(rdev, table);\r\nrv770_populate_smc_mvdd_table(rdev, table);\r\nswitch (rdev->pm.int_thermal_type) {\r\ncase THERMAL_TYPE_RV770:\r\ncase THERMAL_TYPE_ADT7473_WITH_INTERNAL:\r\ntable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_INTERNAL;\r\nbreak;\r\ncase THERMAL_TYPE_NONE:\r\ntable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_NONE;\r\nbreak;\r\ncase THERMAL_TYPE_EXTERNAL_GPIO:\r\ndefault:\r\ntable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_EXTERNAL;\r\nbreak;\r\n}\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC) {\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_DONT_WAIT_FOR_VBLANK_ON_ALERT)\r\ntable->extraFlags |= PPSMC_EXTRAFLAGS_AC2DC_DONT_WAIT_FOR_VBLANK;\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_GOTO_BOOT_ON_ALERT)\r\ntable->extraFlags |= PPSMC_EXTRAFLAGS_AC2DC_ACTION_GOTOINITIALSTATE;\r\n}\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\r\nif (pi->mem_gddr5)\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\r\nif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\r\nret = rv730_populate_smc_initial_state(rdev, radeon_boot_state, table);\r\nelse\r\nret = rv770_populate_smc_initial_state(rdev, radeon_boot_state, table);\r\nif (ret)\r\nreturn ret;\r\nif (rdev->family == CHIP_RV740)\r\nret = rv740_populate_smc_acpi_state(rdev, table);\r\nelse if ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\r\nret = rv730_populate_smc_acpi_state(rdev, table);\r\nelse\r\nret = rv770_populate_smc_acpi_state(rdev, table);\r\nif (ret)\r\nreturn ret;\r\ntable->driverState = table->initialState;\r\nreturn rv770_copy_bytes_to_smc(rdev,\r\npi->state_table_start,\r\n(const u8 *)table,\r\nsizeof(RV770_SMC_STATETABLE),\r\npi->sram_end);\r\n}\r\nstatic int rv770_construct_vddc_table(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu16 min, max, step;\r\nu32 steps = 0;\r\nu8 vddc_index = 0;\r\nu32 i;\r\nradeon_atom_get_min_voltage(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, &min);\r\nradeon_atom_get_max_voltage(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, &max);\r\nradeon_atom_get_voltage_step(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, &step);\r\nsteps = (max - min) / step + 1;\r\nif (steps > MAX_NO_VREG_STEPS)\r\nreturn -EINVAL;\r\nfor (i = 0; i < steps; i++) {\r\nu32 gpio_pins, gpio_mask;\r\npi->vddc_table[i].vddc = (u16)(min + i * step);\r\nradeon_atom_get_voltage_gpio_settings(rdev,\r\npi->vddc_table[i].vddc,\r\nSET_VOLTAGE_TYPE_ASIC_VDDC,\r\n&gpio_pins, &gpio_mask);\r\npi->vddc_table[i].low_smio = gpio_pins & gpio_mask;\r\npi->vddc_table[i].high_smio = 0;\r\npi->vddc_mask_low = gpio_mask;\r\nif (i > 0) {\r\nif ((pi->vddc_table[i].low_smio !=\r\npi->vddc_table[i - 1].low_smio ) ||\r\n(pi->vddc_table[i].high_smio !=\r\npi->vddc_table[i - 1].high_smio))\r\nvddc_index++;\r\n}\r\npi->vddc_table[i].vddc_index = vddc_index;\r\n}\r\npi->valid_vddc_entries = (u8)steps;\r\nreturn 0;\r\n}\r\nstatic u32 rv770_get_mclk_split_point(struct atom_memory_info *memory_info)\r\n{\r\nif (memory_info->mem_type == MEM_TYPE_GDDR3)\r\nreturn 30000;\r\nreturn 0;\r\n}\r\nstatic int rv770_get_mvdd_pin_configuration(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 gpio_pins, gpio_mask;\r\nradeon_atom_get_voltage_gpio_settings(rdev,\r\nMVDD_HIGH_VALUE, SET_VOLTAGE_TYPE_ASIC_MVDDC,\r\n&gpio_pins, &gpio_mask);\r\npi->mvdd_mask_low = gpio_mask;\r\npi->mvdd_low_smio[MVDD_HIGH_INDEX] =\r\ngpio_pins & gpio_mask;\r\nradeon_atom_get_voltage_gpio_settings(rdev,\r\nMVDD_LOW_VALUE, SET_VOLTAGE_TYPE_ASIC_MVDDC,\r\n&gpio_pins, &gpio_mask);\r\npi->mvdd_low_smio[MVDD_LOW_INDEX] =\r\ngpio_pins & gpio_mask;\r\nreturn 0;\r\n}\r\nu8 rv770_get_memory_module_index(struct radeon_device *rdev)\r\n{\r\nreturn (u8) ((RREG32(BIOS_SCRATCH_4) >> 16) & 0xff);\r\n}\r\nstatic int rv770_get_mvdd_configuration(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu8 memory_module_index;\r\nstruct atom_memory_info memory_info;\r\nmemory_module_index = rv770_get_memory_module_index(rdev);\r\nif (radeon_atom_get_memory_info(rdev, memory_module_index, &memory_info)) {\r\npi->mvdd_control = false;\r\nreturn 0;\r\n}\r\npi->mvdd_split_frequency =\r\nrv770_get_mclk_split_point(&memory_info);\r\nif (pi->mvdd_split_frequency == 0) {\r\npi->mvdd_control = false;\r\nreturn 0;\r\n}\r\nreturn rv770_get_mvdd_pin_configuration(rdev);\r\n}\r\nvoid rv770_enable_voltage_control(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, VOLT_PWRMGT_EN, ~VOLT_PWRMGT_EN);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~VOLT_PWRMGT_EN);\r\n}\r\nstatic void rv770_program_display_gap(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32(CG_DISPLAY_GAP_CNTL);\r\ntmp &= ~(DISP1_GAP_MCHG_MASK | DISP2_GAP_MCHG_MASK);\r\nif (rdev->pm.dpm.new_active_crtcs & 1) {\r\ntmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK);\r\ntmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\r\n} else if (rdev->pm.dpm.new_active_crtcs & 2) {\r\ntmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\r\ntmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK);\r\n} else {\r\ntmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\r\ntmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\r\n}\r\nWREG32(CG_DISPLAY_GAP_CNTL, tmp);\r\n}\r\nstatic void rv770_enable_dynamic_pcie_gen2(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nrv770_enable_bif_dynamic_pcie_gen2(rdev, enable);\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, ENABLE_GEN2PCIE, ~ENABLE_GEN2PCIE);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~ENABLE_GEN2PCIE);\r\n}\r\nstatic void r7xx_program_memory_timing_parameters(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state)\r\n{\r\nif ((rdev->family == CHIP_RV730) ||\r\n(rdev->family == CHIP_RV710) ||\r\n(rdev->family == CHIP_RV740))\r\nrv730_program_memory_timing_parameters(rdev, radeon_new_state);\r\nelse\r\nrv770_program_memory_timing_parameters(rdev, radeon_new_state);\r\n}\r\nstatic int rv770_upload_sw_state(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu16 address = pi->state_table_start +\r\noffsetof(RV770_SMC_STATETABLE, driverState);\r\nRV770_SMC_SWSTATE state = { 0 };\r\nint ret;\r\nret = rv770_convert_power_state_to_smc(rdev, radeon_new_state, &state);\r\nif (ret)\r\nreturn ret;\r\nreturn rv770_copy_bytes_to_smc(rdev, address, (const u8 *)&state,\r\nsizeof(RV770_SMC_SWSTATE),\r\npi->sram_end);\r\n}\r\nint rv770_halt_smc(struct radeon_device *rdev)\r\n{\r\nif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_Halt) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nif (rv770_wait_for_smc_inactive(rdev) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint rv770_resume_smc(struct radeon_device *rdev)\r\n{\r\nif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_Resume) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint rv770_set_sw_state(struct radeon_device *rdev)\r\n{\r\nif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_SwitchToSwState) != PPSMC_Result_OK)\r\nDRM_DEBUG("rv770_set_sw_state failed\n");\r\nreturn 0;\r\n}\r\nint rv770_set_boot_state(struct radeon_device *rdev)\r\n{\r\nif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_SwitchToInitialState) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid rv770_set_uvd_clock_before_set_eng_clock(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv7xx_ps *new_state = rv770_get_ps(new_ps);\r\nstruct rv7xx_ps *current_state = rv770_get_ps(old_ps);\r\nif ((new_ps->vclk == old_ps->vclk) &&\r\n(new_ps->dclk == old_ps->dclk))\r\nreturn;\r\nif (new_state->high.sclk >= current_state->high.sclk)\r\nreturn;\r\nradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\r\n}\r\nvoid rv770_set_uvd_clock_after_set_eng_clock(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv7xx_ps *new_state = rv770_get_ps(new_ps);\r\nstruct rv7xx_ps *current_state = rv770_get_ps(old_ps);\r\nif ((new_ps->vclk == old_ps->vclk) &&\r\n(new_ps->dclk == old_ps->dclk))\r\nreturn;\r\nif (new_state->high.sclk < current_state->high.sclk)\r\nreturn;\r\nradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\r\n}\r\nint rv770_restrict_performance_levels_before_switch(struct radeon_device *rdev)\r\n{\r\nif (rv770_send_msg_to_smc(rdev, (PPSMC_Msg)(PPSMC_MSG_NoForcedLevel)) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nif (rv770_send_msg_to_smc(rdev, (PPSMC_Msg)(PPSMC_MSG_TwoLevelsDisabled)) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint rv770_dpm_force_performance_level(struct radeon_device *rdev,\r\nenum radeon_dpm_forced_level level)\r\n{\r\nPPSMC_Msg msg;\r\nif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\r\nif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_ZeroLevelsDisabled) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nmsg = PPSMC_MSG_ForceHigh;\r\n} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\r\nif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_NoForcedLevel) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nmsg = (PPSMC_Msg)(PPSMC_MSG_TwoLevelsDisabled);\r\n} else {\r\nif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_NoForcedLevel) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nmsg = (PPSMC_Msg)(PPSMC_MSG_ZeroLevelsDisabled);\r\n}\r\nif (rv770_send_msg_to_smc(rdev, msg) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nrdev->pm.dpm.forced_level = level;\r\nreturn 0;\r\n}\r\nvoid r7xx_start_smc(struct radeon_device *rdev)\r\n{\r\nrv770_start_smc(rdev);\r\nrv770_start_smc_clock(rdev);\r\n}\r\nvoid r7xx_stop_smc(struct radeon_device *rdev)\r\n{\r\nrv770_reset_smc(rdev);\r\nrv770_stop_smc_clock(rdev);\r\n}\r\nstatic void rv770_read_clock_registers(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\npi->clk_regs.rv770.cg_spll_func_cntl =\r\nRREG32(CG_SPLL_FUNC_CNTL);\r\npi->clk_regs.rv770.cg_spll_func_cntl_2 =\r\nRREG32(CG_SPLL_FUNC_CNTL_2);\r\npi->clk_regs.rv770.cg_spll_func_cntl_3 =\r\nRREG32(CG_SPLL_FUNC_CNTL_3);\r\npi->clk_regs.rv770.cg_spll_spread_spectrum =\r\nRREG32(CG_SPLL_SPREAD_SPECTRUM);\r\npi->clk_regs.rv770.cg_spll_spread_spectrum_2 =\r\nRREG32(CG_SPLL_SPREAD_SPECTRUM_2);\r\npi->clk_regs.rv770.mpll_ad_func_cntl =\r\nRREG32(MPLL_AD_FUNC_CNTL);\r\npi->clk_regs.rv770.mpll_ad_func_cntl_2 =\r\nRREG32(MPLL_AD_FUNC_CNTL_2);\r\npi->clk_regs.rv770.mpll_dq_func_cntl =\r\nRREG32(MPLL_DQ_FUNC_CNTL);\r\npi->clk_regs.rv770.mpll_dq_func_cntl_2 =\r\nRREG32(MPLL_DQ_FUNC_CNTL_2);\r\npi->clk_regs.rv770.mclk_pwrmgt_cntl =\r\nRREG32(MCLK_PWRMGT_CNTL);\r\npi->clk_regs.rv770.dll_cntl = RREG32(DLL_CNTL);\r\n}\r\nstatic void r7xx_read_clock_registers(struct radeon_device *rdev)\r\n{\r\nif (rdev->family == CHIP_RV740)\r\nrv740_read_clock_registers(rdev);\r\nelse if ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\r\nrv730_read_clock_registers(rdev);\r\nelse\r\nrv770_read_clock_registers(rdev);\r\n}\r\nvoid rv770_read_voltage_smio_registers(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\npi->s0_vid_lower_smio_cntl =\r\nRREG32(S0_VID_LOWER_SMIO_CNTL);\r\n}\r\nvoid rv770_reset_smio_status(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 sw_smio_index, vid_smio_cntl;\r\nsw_smio_index =\r\n(RREG32(GENERAL_PWRMGT) & SW_SMIO_INDEX_MASK) >> SW_SMIO_INDEX_SHIFT;\r\nswitch (sw_smio_index) {\r\ncase 3:\r\nvid_smio_cntl = RREG32(S3_VID_LOWER_SMIO_CNTL);\r\nbreak;\r\ncase 2:\r\nvid_smio_cntl = RREG32(S2_VID_LOWER_SMIO_CNTL);\r\nbreak;\r\ncase 1:\r\nvid_smio_cntl = RREG32(S1_VID_LOWER_SMIO_CNTL);\r\nbreak;\r\ncase 0:\r\nreturn;\r\ndefault:\r\nvid_smio_cntl = pi->s0_vid_lower_smio_cntl;\r\nbreak;\r\n}\r\nWREG32(S0_VID_LOWER_SMIO_CNTL, vid_smio_cntl);\r\nWREG32_P(GENERAL_PWRMGT, SW_SMIO_INDEX(0), ~SW_SMIO_INDEX_MASK);\r\n}\r\nvoid rv770_get_memory_type(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 tmp;\r\ntmp = RREG32(MC_SEQ_MISC0);\r\nif (((tmp & MC_SEQ_MISC0_GDDR5_MASK) >> MC_SEQ_MISC0_GDDR5_SHIFT) ==\r\nMC_SEQ_MISC0_GDDR5_VALUE)\r\npi->mem_gddr5 = true;\r\nelse\r\npi->mem_gddr5 = false;\r\n}\r\nvoid rv770_get_pcie_gen2_status(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 tmp;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\r\nif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\r\n(tmp & LC_OTHER_SIDE_SUPPORTS_GEN2))\r\npi->pcie_gen2 = true;\r\nelse\r\npi->pcie_gen2 = false;\r\nif (pi->pcie_gen2) {\r\nif (tmp & LC_CURRENT_DATA_RATE)\r\npi->boot_in_gen2 = true;\r\nelse\r\npi->boot_in_gen2 = false;\r\n} else\r\npi->boot_in_gen2 = false;\r\n}\r\nstatic void rv770_get_mclk_odt_threshold(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu8 memory_module_index;\r\nstruct atom_memory_info memory_info;\r\npi->mclk_odt_threshold = 0;\r\nif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710)) {\r\nmemory_module_index = rv770_get_memory_module_index(rdev);\r\nif (radeon_atom_get_memory_info(rdev, memory_module_index, &memory_info))\r\nreturn;\r\nif (memory_info.mem_type == MEM_TYPE_DDR2 ||\r\nmemory_info.mem_type == MEM_TYPE_DDR3)\r\npi->mclk_odt_threshold = 30000;\r\n}\r\n}\r\nvoid rv770_get_max_vddc(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu16 vddc;\r\nif (radeon_atom_get_max_vddc(rdev, 0, 0, &vddc))\r\npi->max_vddc = 0;\r\nelse\r\npi->max_vddc = vddc;\r\n}\r\nvoid rv770_program_response_times(struct radeon_device *rdev)\r\n{\r\nu32 voltage_response_time, backbias_response_time;\r\nu32 acpi_delay_time, vbi_time_out;\r\nu32 vddc_dly, bb_dly, acpi_dly, vbi_dly;\r\nu32 reference_clock;\r\nvoltage_response_time = (u32)rdev->pm.dpm.voltage_response_time;\r\nbackbias_response_time = (u32)rdev->pm.dpm.backbias_response_time;\r\nif (voltage_response_time == 0)\r\nvoltage_response_time = 1000;\r\nif (backbias_response_time == 0)\r\nbackbias_response_time = 1000;\r\nacpi_delay_time = 15000;\r\nvbi_time_out = 100000;\r\nreference_clock = radeon_get_xclk(rdev);\r\nvddc_dly = (voltage_response_time * reference_clock) / 1600;\r\nbb_dly = (backbias_response_time * reference_clock) / 1600;\r\nacpi_dly = (acpi_delay_time * reference_clock) / 1600;\r\nvbi_dly = (vbi_time_out * reference_clock) / 1600;\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_delay_vreg, vddc_dly);\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_delay_bbias, bb_dly);\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_delay_acpi, acpi_dly);\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_mclk_chg_timeout, vbi_dly);\r\n#if 0\r\nif (WEKIVA_A21)\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_baby_step_timer,\r\n0x10);\r\n#endif\r\n}\r\nstatic void rv770_program_dcodt_before_state_switch(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state,\r\nstruct radeon_ps *radeon_current_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct rv7xx_ps *new_state = rv770_get_ps(radeon_new_state);\r\nstruct rv7xx_ps *current_state = rv770_get_ps(radeon_current_state);\r\nbool current_use_dc = false;\r\nbool new_use_dc = false;\r\nif (pi->mclk_odt_threshold == 0)\r\nreturn;\r\nif (current_state->high.mclk <= pi->mclk_odt_threshold)\r\ncurrent_use_dc = true;\r\nif (new_state->high.mclk <= pi->mclk_odt_threshold)\r\nnew_use_dc = true;\r\nif (current_use_dc == new_use_dc)\r\nreturn;\r\nif (!current_use_dc && new_use_dc)\r\nreturn;\r\nif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\r\nrv730_program_dcodt(rdev, new_use_dc);\r\n}\r\nstatic void rv770_program_dcodt_after_state_switch(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state,\r\nstruct radeon_ps *radeon_current_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct rv7xx_ps *new_state = rv770_get_ps(radeon_new_state);\r\nstruct rv7xx_ps *current_state = rv770_get_ps(radeon_current_state);\r\nbool current_use_dc = false;\r\nbool new_use_dc = false;\r\nif (pi->mclk_odt_threshold == 0)\r\nreturn;\r\nif (current_state->high.mclk <= pi->mclk_odt_threshold)\r\ncurrent_use_dc = true;\r\nif (new_state->high.mclk <= pi->mclk_odt_threshold)\r\nnew_use_dc = true;\r\nif (current_use_dc == new_use_dc)\r\nreturn;\r\nif (current_use_dc && !new_use_dc)\r\nreturn;\r\nif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\r\nrv730_program_dcodt(rdev, new_use_dc);\r\n}\r\nstatic void rv770_retrieve_odt_values(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nif (pi->mclk_odt_threshold == 0)\r\nreturn;\r\nif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\r\nrv730_get_odt_values(rdev);\r\n}\r\nstatic void rv770_set_dpm_event_sources(struct radeon_device *rdev, u32 sources)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nbool want_thermal_protection;\r\nenum radeon_dpm_event_src dpm_event_src;\r\nswitch (sources) {\r\ncase 0:\r\ndefault:\r\nwant_thermal_protection = false;\r\nbreak;\r\ncase (1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL):\r\nwant_thermal_protection = true;\r\ndpm_event_src = RADEON_DPM_EVENT_SRC_DIGITAL;\r\nbreak;\r\ncase (1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL):\r\nwant_thermal_protection = true;\r\ndpm_event_src = RADEON_DPM_EVENT_SRC_EXTERNAL;\r\nbreak;\r\ncase ((1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL) |\r\n(1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL)):\r\nwant_thermal_protection = true;\r\ndpm_event_src = RADEON_DPM_EVENT_SRC_DIGIAL_OR_EXTERNAL;\r\nbreak;\r\n}\r\nif (want_thermal_protection) {\r\nWREG32_P(CG_THERMAL_CTRL, DPM_EVENT_SRC(dpm_event_src), ~DPM_EVENT_SRC_MASK);\r\nif (pi->thermal_protection)\r\nWREG32_P(GENERAL_PWRMGT, 0, ~THERMAL_PROTECTION_DIS);\r\n} else {\r\nWREG32_P(GENERAL_PWRMGT, THERMAL_PROTECTION_DIS, ~THERMAL_PROTECTION_DIS);\r\n}\r\n}\r\nvoid rv770_enable_auto_throttle_source(struct radeon_device *rdev,\r\nenum radeon_dpm_auto_throttle_src source,\r\nbool enable)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nif (enable) {\r\nif (!(pi->active_auto_throttle_sources & (1 << source))) {\r\npi->active_auto_throttle_sources |= 1 << source;\r\nrv770_set_dpm_event_sources(rdev, pi->active_auto_throttle_sources);\r\n}\r\n} else {\r\nif (pi->active_auto_throttle_sources & (1 << source)) {\r\npi->active_auto_throttle_sources &= ~(1 << source);\r\nrv770_set_dpm_event_sources(rdev, pi->active_auto_throttle_sources);\r\n}\r\n}\r\n}\r\nstatic int rv770_set_thermal_temperature_range(struct radeon_device *rdev,\r\nint min_temp, int max_temp)\r\n{\r\nint low_temp = 0 * 1000;\r\nint high_temp = 255 * 1000;\r\nif (low_temp < min_temp)\r\nlow_temp = min_temp;\r\nif (high_temp > max_temp)\r\nhigh_temp = max_temp;\r\nif (high_temp < low_temp) {\r\nDRM_ERROR("invalid thermal range: %d - %d\n", low_temp, high_temp);\r\nreturn -EINVAL;\r\n}\r\nWREG32_P(CG_THERMAL_INT, DIG_THERM_INTH(high_temp / 1000), ~DIG_THERM_INTH_MASK);\r\nWREG32_P(CG_THERMAL_INT, DIG_THERM_INTL(low_temp / 1000), ~DIG_THERM_INTL_MASK);\r\nWREG32_P(CG_THERMAL_CTRL, DIG_THERM_DPM(high_temp / 1000), ~DIG_THERM_DPM_MASK);\r\nrdev->pm.dpm.thermal.min_temp = low_temp;\r\nrdev->pm.dpm.thermal.max_temp = high_temp;\r\nreturn 0;\r\n}\r\nint rv770_dpm_enable(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\r\nint ret;\r\nif (pi->gfx_clock_gating)\r\nrv770_restore_cgcg(rdev);\r\nif (rv770_dpm_enabled(rdev))\r\nreturn -EINVAL;\r\nif (pi->voltage_control) {\r\nrv770_enable_voltage_control(rdev, true);\r\nret = rv770_construct_vddc_table(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_construct_vddc_table failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (pi->dcodt)\r\nrv770_retrieve_odt_values(rdev);\r\nif (pi->mvdd_control) {\r\nret = rv770_get_mvdd_configuration(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_get_mvdd_configuration failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\r\nrv770_enable_backbias(rdev, true);\r\nrv770_enable_spread_spectrum(rdev, true);\r\nif (pi->thermal_protection)\r\nrv770_enable_thermal_protection(rdev, true);\r\nrv770_program_mpll_timing_parameters(rdev);\r\nrv770_setup_bsp(rdev);\r\nrv770_program_git(rdev);\r\nrv770_program_tp(rdev);\r\nrv770_program_tpp(rdev);\r\nrv770_program_sstp(rdev);\r\nrv770_program_engine_speed_parameters(rdev);\r\nrv770_enable_display_gap(rdev);\r\nrv770_program_vc(rdev);\r\nif (pi->dynamic_pcie_gen2)\r\nrv770_enable_dynamic_pcie_gen2(rdev, true);\r\nret = rv770_upload_firmware(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_upload_firmware failed\n");\r\nreturn ret;\r\n}\r\nret = rv770_init_smc_table(rdev, boot_ps);\r\nif (ret) {\r\nDRM_ERROR("rv770_init_smc_table failed\n");\r\nreturn ret;\r\n}\r\nrv770_program_response_times(rdev);\r\nr7xx_start_smc(rdev);\r\nif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\r\nrv730_start_dpm(rdev);\r\nelse\r\nrv770_start_dpm(rdev);\r\nif (pi->gfx_clock_gating)\r\nrv770_gfx_clock_gating_enable(rdev, true);\r\nif (pi->mg_clock_gating)\r\nrv770_mg_clock_gating_enable(rdev, true);\r\nrv770_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\r\nreturn 0;\r\n}\r\nint rv770_dpm_late_enable(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nPPSMC_Result result;\r\nret = rv770_set_thermal_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\r\nif (ret)\r\nreturn ret;\r\nrdev->irq.dpm_thermal = true;\r\nradeon_irq_set(rdev);\r\nresult = rv770_send_msg_to_smc(rdev, PPSMC_MSG_EnableThermalInterrupt);\r\nif (result != PPSMC_Result_OK)\r\nDRM_DEBUG_KMS("Could not enable thermal interrupts.\n");\r\n}\r\nreturn 0;\r\n}\r\nvoid rv770_dpm_disable(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nif (!rv770_dpm_enabled(rdev))\r\nreturn;\r\nrv770_clear_vc(rdev);\r\nif (pi->thermal_protection)\r\nrv770_enable_thermal_protection(rdev, false);\r\nrv770_enable_spread_spectrum(rdev, false);\r\nif (pi->dynamic_pcie_gen2)\r\nrv770_enable_dynamic_pcie_gen2(rdev, false);\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nrdev->irq.dpm_thermal = false;\r\nradeon_irq_set(rdev);\r\n}\r\nif (pi->gfx_clock_gating)\r\nrv770_gfx_clock_gating_enable(rdev, false);\r\nif (pi->mg_clock_gating)\r\nrv770_mg_clock_gating_enable(rdev, false);\r\nif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\r\nrv730_stop_dpm(rdev);\r\nelse\r\nrv770_stop_dpm(rdev);\r\nr7xx_stop_smc(rdev);\r\nrv770_reset_smio_status(rdev);\r\n}\r\nint rv770_dpm_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct radeon_ps *new_ps = rdev->pm.dpm.requested_ps;\r\nstruct radeon_ps *old_ps = rdev->pm.dpm.current_ps;\r\nint ret;\r\nret = rv770_restrict_performance_levels_before_switch(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_restrict_performance_levels_before_switch failed\n");\r\nreturn ret;\r\n}\r\nrv770_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\r\nret = rv770_halt_smc(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_halt_smc failed\n");\r\nreturn ret;\r\n}\r\nret = rv770_upload_sw_state(rdev, new_ps);\r\nif (ret) {\r\nDRM_ERROR("rv770_upload_sw_state failed\n");\r\nreturn ret;\r\n}\r\nr7xx_program_memory_timing_parameters(rdev, new_ps);\r\nif (pi->dcodt)\r\nrv770_program_dcodt_before_state_switch(rdev, new_ps, old_ps);\r\nret = rv770_resume_smc(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_resume_smc failed\n");\r\nreturn ret;\r\n}\r\nret = rv770_set_sw_state(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_set_sw_state failed\n");\r\nreturn ret;\r\n}\r\nif (pi->dcodt)\r\nrv770_program_dcodt_after_state_switch(rdev, new_ps, old_ps);\r\nrv770_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\r\nreturn 0;\r\n}\r\nvoid rv770_dpm_setup_asic(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nr7xx_read_clock_registers(rdev);\r\nrv770_read_voltage_smio_registers(rdev);\r\nrv770_get_memory_type(rdev);\r\nif (pi->dcodt)\r\nrv770_get_mclk_odt_threshold(rdev);\r\nrv770_get_pcie_gen2_status(rdev);\r\nrv770_enable_acpi_pm(rdev);\r\nif (radeon_aspm != 0) {\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_ASPM_L0s)\r\nrv770_enable_l0s(rdev);\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_ASPM_L1)\r\nrv770_enable_l1(rdev);\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_TURNOFFPLL_ASPML1)\r\nrv770_enable_pll_sleep_in_l1(rdev);\r\n}\r\n}\r\nvoid rv770_dpm_display_configuration_changed(struct radeon_device *rdev)\r\n{\r\nrv770_program_display_gap(rdev);\r\n}\r\nstatic void rv7xx_parse_pplib_non_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps,\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\r\nu8 table_rev)\r\n{\r\nrps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\r\nrps->class = le16_to_cpu(non_clock_info->usClassification);\r\nrps->class2 = le16_to_cpu(non_clock_info->usClassification2);\r\nif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\r\nrps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\r\nrps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\r\n} else {\r\nrps->vclk = 0;\r\nrps->dclk = 0;\r\n}\r\nif (r600_is_uvd_state(rps->class, rps->class2)) {\r\nif ((rps->vclk == 0) || (rps->dclk == 0)) {\r\nrps->vclk = RV770_DEFAULT_VCLK_FREQ;\r\nrps->dclk = RV770_DEFAULT_DCLK_FREQ;\r\n}\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)\r\nrdev->pm.dpm.boot_ps = rps;\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nrdev->pm.dpm.uvd_ps = rps;\r\n}\r\nstatic void rv7xx_parse_pplib_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps, int index,\r\nunion pplib_clock_info *clock_info)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct rv7xx_ps *ps = rv770_get_ps(rps);\r\nu32 sclk, mclk;\r\nstruct rv7xx_pl *pl;\r\nswitch (index) {\r\ncase 0:\r\npl = &ps->low;\r\nbreak;\r\ncase 1:\r\npl = &ps->medium;\r\nbreak;\r\ncase 2:\r\ndefault:\r\npl = &ps->high;\r\nbreak;\r\n}\r\nif (rdev->family >= CHIP_CEDAR) {\r\nsclk = le16_to_cpu(clock_info->evergreen.usEngineClockLow);\r\nsclk |= clock_info->evergreen.ucEngineClockHigh << 16;\r\nmclk = le16_to_cpu(clock_info->evergreen.usMemoryClockLow);\r\nmclk |= clock_info->evergreen.ucMemoryClockHigh << 16;\r\npl->vddc = le16_to_cpu(clock_info->evergreen.usVDDC);\r\npl->vddci = le16_to_cpu(clock_info->evergreen.usVDDCI);\r\npl->flags = le32_to_cpu(clock_info->evergreen.ulFlags);\r\n} else {\r\nsclk = le16_to_cpu(clock_info->r600.usEngineClockLow);\r\nsclk |= clock_info->r600.ucEngineClockHigh << 16;\r\nmclk = le16_to_cpu(clock_info->r600.usMemoryClockLow);\r\nmclk |= clock_info->r600.ucMemoryClockHigh << 16;\r\npl->vddc = le16_to_cpu(clock_info->r600.usVDDC);\r\npl->flags = le32_to_cpu(clock_info->r600.ulFlags);\r\n}\r\npl->mclk = mclk;\r\npl->sclk = sclk;\r\nif (pl->vddc == 0xff01) {\r\nif (pi->max_vddc)\r\npl->vddc = pi->max_vddc;\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_ACPI) {\r\npi->acpi_vddc = pl->vddc;\r\nif (rdev->family >= CHIP_CEDAR)\r\neg_pi->acpi_vddci = pl->vddci;\r\nif (ps->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2)\r\npi->acpi_pcie_gen2 = true;\r\nelse\r\npi->acpi_pcie_gen2 = false;\r\n}\r\nif (rps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV) {\r\nif (rdev->family >= CHIP_BARTS) {\r\neg_pi->ulv.supported = true;\r\neg_pi->ulv.pl = pl;\r\n}\r\n}\r\nif (pi->min_vddc_in_table > pl->vddc)\r\npi->min_vddc_in_table = pl->vddc;\r\nif (pi->max_vddc_in_table < pl->vddc)\r\npi->max_vddc_in_table = pl->vddc;\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\r\nu16 vddc, vddci, mvdd;\r\nradeon_atombios_get_default_voltages(rdev, &vddc, &vddci, &mvdd);\r\npl->mclk = rdev->clock.default_mclk;\r\npl->sclk = rdev->clock.default_sclk;\r\npl->vddc = vddc;\r\npl->vddci = vddci;\r\n}\r\nif ((rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) ==\r\nATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE) {\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.sclk = pl->sclk;\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.mclk = pl->mclk;\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddc = pl->vddc;\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddci = pl->vddci;\r\n}\r\n}\r\nint rv7xx_parse_power_table(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\r\nunion pplib_power_state *power_state;\r\nint i, j;\r\nunion pplib_clock_info *clock_info;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nstruct rv7xx_ps *ps;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nrdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *\r\npower_info->pplib.ucNumStates, GFP_KERNEL);\r\nif (!rdev->pm.dpm.ps)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < power_info->pplib.ucNumStates; i++) {\r\npower_state = (union pplib_power_state *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usStateArrayOffset) +\r\ni * power_info->pplib.ucStateEntrySize);\r\nnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset) +\r\n(power_state->v1.ucNonClockStateIndex *\r\npower_info->pplib.ucNonClockSize));\r\nif (power_info->pplib.ucStateEntrySize - 1) {\r\nu8 *idx;\r\nps = kzalloc(sizeof(struct rv7xx_ps), GFP_KERNEL);\r\nif (ps == NULL) {\r\nkfree(rdev->pm.dpm.ps);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.ps[i].ps_priv = ps;\r\nrv7xx_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\r\nnon_clock_info,\r\npower_info->pplib.ucNonClockSize);\r\nidx = (u8 *)&power_state->v1.ucClockStateIndices[0];\r\nfor (j = 0; j < (power_info->pplib.ucStateEntrySize - 1); j++) {\r\nclock_info = (union pplib_clock_info *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usClockInfoArrayOffset) +\r\n(idx[j] * power_info->pplib.ucClockInfoSize));\r\nrv7xx_parse_pplib_clock_info(rdev,\r\n&rdev->pm.dpm.ps[i], j,\r\nclock_info);\r\n}\r\n}\r\n}\r\nrdev->pm.dpm.num_ps = power_info->pplib.ucNumStates;\r\nreturn 0;\r\n}\r\nvoid rv770_get_engine_memory_ss(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct radeon_atom_ss ss;\r\npi->sclk_ss = radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_ENGINE_SS, 0);\r\npi->mclk_ss = radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_MEMORY_SS, 0);\r\nif (pi->sclk_ss || pi->mclk_ss)\r\npi->dynamic_ss = true;\r\nelse\r\npi->dynamic_ss = false;\r\n}\r\nint rv770_dpm_init(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi;\r\nstruct atom_clock_dividers dividers;\r\nint ret;\r\npi = kzalloc(sizeof(struct rv7xx_power_info), GFP_KERNEL);\r\nif (pi == NULL)\r\nreturn -ENOMEM;\r\nrdev->pm.dpm.priv = pi;\r\nrv770_get_max_vddc(rdev);\r\npi->acpi_vddc = 0;\r\npi->min_vddc_in_table = 0;\r\npi->max_vddc_in_table = 0;\r\nret = r600_get_platform_caps(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = rv7xx_parse_power_table(rdev);\r\nif (ret)\r\nreturn ret;\r\nif (rdev->pm.dpm.voltage_response_time == 0)\r\nrdev->pm.dpm.voltage_response_time = R600_VOLTAGERESPONSETIME_DFLT;\r\nif (rdev->pm.dpm.backbias_response_time == 0)\r\nrdev->pm.dpm.backbias_response_time = R600_BACKBIASRESPONSETIME_DFLT;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\n0, false, &dividers);\r\nif (ret)\r\npi->ref_div = dividers.ref_div + 1;\r\nelse\r\npi->ref_div = R600_REFERENCEDIVIDER_DFLT;\r\npi->mclk_strobe_mode_threshold = 30000;\r\npi->mclk_edc_enable_threshold = 30000;\r\npi->rlp = RV770_RLP_DFLT;\r\npi->rmp = RV770_RMP_DFLT;\r\npi->lhp = RV770_LHP_DFLT;\r\npi->lmp = RV770_LMP_DFLT;\r\npi->voltage_control =\r\nradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0);\r\npi->mvdd_control =\r\nradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_MVDDC, 0);\r\nrv770_get_engine_memory_ss(rdev);\r\npi->asi = RV770_ASI_DFLT;\r\npi->pasi = RV770_HASI_DFLT;\r\npi->vrc = RV770_VRC_DFLT;\r\npi->power_gating = false;\r\npi->gfx_clock_gating = true;\r\npi->mg_clock_gating = true;\r\npi->mgcgtssm = true;\r\npi->dynamic_pcie_gen2 = true;\r\nif (rdev->pm.int_thermal_type != THERMAL_TYPE_NONE)\r\npi->thermal_protection = true;\r\nelse\r\npi->thermal_protection = false;\r\npi->display_gap = true;\r\nif (rdev->flags & RADEON_IS_MOBILITY)\r\npi->dcodt = true;\r\nelse\r\npi->dcodt = false;\r\npi->ulps = true;\r\npi->mclk_stutter_mode_threshold = 0;\r\npi->sram_end = SMC_RAM_END;\r\npi->state_table_start = RV770_SMC_TABLE_ADDRESS;\r\npi->soft_regs_start = RV770_SMC_SOFT_REGISTERS_START;\r\nreturn 0;\r\n}\r\nvoid rv770_dpm_print_power_state(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct rv7xx_ps *ps = rv770_get_ps(rps);\r\nstruct rv7xx_pl *pl;\r\nr600_dpm_print_class_info(rps->class, rps->class2);\r\nr600_dpm_print_cap_info(rps->caps);\r\nprintk("\tuvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nif (rdev->family >= CHIP_CEDAR) {\r\npl = &ps->low;\r\nprintk("\t\tpower level 0 sclk: %u mclk: %u vddc: %u vddci: %u\n",\r\npl->sclk, pl->mclk, pl->vddc, pl->vddci);\r\npl = &ps->medium;\r\nprintk("\t\tpower level 1 sclk: %u mclk: %u vddc: %u vddci: %u\n",\r\npl->sclk, pl->mclk, pl->vddc, pl->vddci);\r\npl = &ps->high;\r\nprintk("\t\tpower level 2 sclk: %u mclk: %u vddc: %u vddci: %u\n",\r\npl->sclk, pl->mclk, pl->vddc, pl->vddci);\r\n} else {\r\npl = &ps->low;\r\nprintk("\t\tpower level 0 sclk: %u mclk: %u vddc: %u\n",\r\npl->sclk, pl->mclk, pl->vddc);\r\npl = &ps->medium;\r\nprintk("\t\tpower level 1 sclk: %u mclk: %u vddc: %u\n",\r\npl->sclk, pl->mclk, pl->vddc);\r\npl = &ps->high;\r\nprintk("\t\tpower level 2 sclk: %u mclk: %u vddc: %u\n",\r\npl->sclk, pl->mclk, pl->vddc);\r\n}\r\nr600_dpm_print_ps_status(rdev, rps);\r\n}\r\nvoid rv770_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\r\nstruct seq_file *m)\r\n{\r\nstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\r\nstruct rv7xx_ps *ps = rv770_get_ps(rps);\r\nstruct rv7xx_pl *pl;\r\nu32 current_index =\r\n(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\r\nCURRENT_PROFILE_INDEX_SHIFT;\r\nif (current_index > 2) {\r\nseq_printf(m, "invalid dpm profile %d\n", current_index);\r\n} else {\r\nif (current_index == 0)\r\npl = &ps->low;\r\nelse if (current_index == 1)\r\npl = &ps->medium;\r\nelse\r\npl = &ps->high;\r\nseq_printf(m, "uvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nif (rdev->family >= CHIP_CEDAR) {\r\nseq_printf(m, "power level %d sclk: %u mclk: %u vddc: %u vddci: %u\n",\r\ncurrent_index, pl->sclk, pl->mclk, pl->vddc, pl->vddci);\r\n} else {\r\nseq_printf(m, "power level %d sclk: %u mclk: %u vddc: %u\n",\r\ncurrent_index, pl->sclk, pl->mclk, pl->vddc);\r\n}\r\n}\r\n}\r\nu32 rv770_dpm_get_current_sclk(struct radeon_device *rdev)\r\n{\r\nstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\r\nstruct rv7xx_ps *ps = rv770_get_ps(rps);\r\nstruct rv7xx_pl *pl;\r\nu32 current_index =\r\n(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\r\nCURRENT_PROFILE_INDEX_SHIFT;\r\nif (current_index > 2) {\r\nreturn 0;\r\n} else {\r\nif (current_index == 0)\r\npl = &ps->low;\r\nelse if (current_index == 1)\r\npl = &ps->medium;\r\nelse\r\npl = &ps->high;\r\nreturn pl->sclk;\r\n}\r\n}\r\nu32 rv770_dpm_get_current_mclk(struct radeon_device *rdev)\r\n{\r\nstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\r\nstruct rv7xx_ps *ps = rv770_get_ps(rps);\r\nstruct rv7xx_pl *pl;\r\nu32 current_index =\r\n(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\r\nCURRENT_PROFILE_INDEX_SHIFT;\r\nif (current_index > 2) {\r\nreturn 0;\r\n} else {\r\nif (current_index == 0)\r\npl = &ps->low;\r\nelse if (current_index == 1)\r\npl = &ps->medium;\r\nelse\r\npl = &ps->high;\r\nreturn pl->mclk;\r\n}\r\n}\r\nvoid rv770_dpm_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\r\nkfree(rdev->pm.dpm.ps[i].ps_priv);\r\n}\r\nkfree(rdev->pm.dpm.ps);\r\nkfree(rdev->pm.dpm.priv);\r\n}\r\nu32 rv770_dpm_get_sclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct rv7xx_ps *requested_state = rv770_get_ps(rdev->pm.dpm.requested_ps);\r\nif (low)\r\nreturn requested_state->low.sclk;\r\nelse\r\nreturn requested_state->high.sclk;\r\n}\r\nu32 rv770_dpm_get_mclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct rv7xx_ps *requested_state = rv770_get_ps(rdev->pm.dpm.requested_ps);\r\nif (low)\r\nreturn requested_state->low.mclk;\r\nelse\r\nreturn requested_state->high.mclk;\r\n}\r\nbool rv770_dpm_vblank_too_short(struct radeon_device *rdev)\r\n{\r\nu32 vblank_time = r600_dpm_get_vblank_time(rdev);\r\nu32 switch_limit = 200;\r\nif ((rdev->family == CHIP_RV770) &&\r\n!(rdev->flags & RADEON_IS_MOBILITY))\r\nswitch_limit = 0xffffffff;\r\nif (vblank_time < switch_limit)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}
