int mlx5_cmd_alloc_uar(struct mlx5_core_dev *dev, u32 *uarn)\r\n{\r\nstruct mlx5_alloc_uar_mbox_in in;\r\nstruct mlx5_alloc_uar_mbox_out out;\r\nint err;\r\nmemset(&in, 0, sizeof(in));\r\nmemset(&out, 0, sizeof(out));\r\nin.hdr.opcode = cpu_to_be16(MLX5_CMD_OP_ALLOC_UAR);\r\nerr = mlx5_cmd_exec(dev, &in, sizeof(in), &out, sizeof(out));\r\nif (err)\r\ngoto ex;\r\nif (out.hdr.status) {\r\nerr = mlx5_cmd_status_to_err(&out.hdr);\r\ngoto ex;\r\n}\r\n*uarn = be32_to_cpu(out.uarn) & 0xffffff;\r\nex:\r\nreturn err;\r\n}\r\nint mlx5_cmd_free_uar(struct mlx5_core_dev *dev, u32 uarn)\r\n{\r\nstruct mlx5_free_uar_mbox_in in;\r\nstruct mlx5_free_uar_mbox_out out;\r\nint err;\r\nmemset(&in, 0, sizeof(in));\r\nmemset(&out, 0, sizeof(out));\r\nin.hdr.opcode = cpu_to_be16(MLX5_CMD_OP_DEALLOC_UAR);\r\nin.uarn = cpu_to_be32(uarn);\r\nerr = mlx5_cmd_exec(dev, &in, sizeof(in), &out, sizeof(out));\r\nif (err)\r\ngoto ex;\r\nif (out.hdr.status)\r\nerr = mlx5_cmd_status_to_err(&out.hdr);\r\nex:\r\nreturn err;\r\n}\r\nstatic int need_uuar_lock(int uuarn)\r\n{\r\nint tot_uuars = NUM_DRIVER_UARS * MLX5_BF_REGS_PER_PAGE;\r\nif (uuarn == 0 || tot_uuars - NUM_LOW_LAT_UUARS)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint mlx5_alloc_uuars(struct mlx5_core_dev *dev, struct mlx5_uuar_info *uuari)\r\n{\r\nint tot_uuars = NUM_DRIVER_UARS * MLX5_BF_REGS_PER_PAGE;\r\nstruct mlx5_bf *bf;\r\nphys_addr_t addr;\r\nint err;\r\nint i;\r\nuuari->num_uars = NUM_DRIVER_UARS;\r\nuuari->num_low_latency_uuars = NUM_LOW_LAT_UUARS;\r\nmutex_init(&uuari->lock);\r\nuuari->uars = kcalloc(uuari->num_uars, sizeof(*uuari->uars), GFP_KERNEL);\r\nif (!uuari->uars)\r\nreturn -ENOMEM;\r\nuuari->bfs = kcalloc(tot_uuars, sizeof(*uuari->bfs), GFP_KERNEL);\r\nif (!uuari->bfs) {\r\nerr = -ENOMEM;\r\ngoto out_uars;\r\n}\r\nuuari->bitmap = kcalloc(BITS_TO_LONGS(tot_uuars), sizeof(*uuari->bitmap),\r\nGFP_KERNEL);\r\nif (!uuari->bitmap) {\r\nerr = -ENOMEM;\r\ngoto out_bfs;\r\n}\r\nuuari->count = kcalloc(tot_uuars, sizeof(*uuari->count), GFP_KERNEL);\r\nif (!uuari->count) {\r\nerr = -ENOMEM;\r\ngoto out_bitmap;\r\n}\r\nfor (i = 0; i < uuari->num_uars; i++) {\r\nerr = mlx5_cmd_alloc_uar(dev, &uuari->uars[i].index);\r\nif (err)\r\ngoto out_count;\r\naddr = dev->iseg_base + ((phys_addr_t)(uuari->uars[i].index) << PAGE_SHIFT);\r\nuuari->uars[i].map = ioremap(addr, PAGE_SIZE);\r\nif (!uuari->uars[i].map) {\r\nmlx5_cmd_free_uar(dev, uuari->uars[i].index);\r\nerr = -ENOMEM;\r\ngoto out_count;\r\n}\r\nmlx5_core_dbg(dev, "allocated uar index 0x%x, mmaped at %p\n",\r\nuuari->uars[i].index, uuari->uars[i].map);\r\n}\r\nfor (i = 0; i < tot_uuars; i++) {\r\nbf = &uuari->bfs[i];\r\nbf->buf_size = (1 << MLX5_CAP_GEN(dev, log_bf_reg_size)) / 2;\r\nbf->uar = &uuari->uars[i / MLX5_BF_REGS_PER_PAGE];\r\nbf->regreg = uuari->uars[i / MLX5_BF_REGS_PER_PAGE].map;\r\nbf->reg = NULL;\r\nbf->offset = (i % MLX5_BF_REGS_PER_PAGE) *\r\n(1 << MLX5_CAP_GEN(dev, log_bf_reg_size)) +\r\nMLX5_BF_OFFSET;\r\nbf->need_lock = need_uuar_lock(i);\r\nspin_lock_init(&bf->lock);\r\nspin_lock_init(&bf->lock32);\r\nbf->uuarn = i;\r\n}\r\nreturn 0;\r\nout_count:\r\nfor (i--; i >= 0; i--) {\r\niounmap(uuari->uars[i].map);\r\nmlx5_cmd_free_uar(dev, uuari->uars[i].index);\r\n}\r\nkfree(uuari->count);\r\nout_bitmap:\r\nkfree(uuari->bitmap);\r\nout_bfs:\r\nkfree(uuari->bfs);\r\nout_uars:\r\nkfree(uuari->uars);\r\nreturn err;\r\n}\r\nint mlx5_free_uuars(struct mlx5_core_dev *dev, struct mlx5_uuar_info *uuari)\r\n{\r\nint i = uuari->num_uars;\r\nfor (i--; i >= 0; i--) {\r\niounmap(uuari->uars[i].map);\r\nmlx5_cmd_free_uar(dev, uuari->uars[i].index);\r\n}\r\nkfree(uuari->count);\r\nkfree(uuari->bitmap);\r\nkfree(uuari->bfs);\r\nkfree(uuari->uars);\r\nreturn 0;\r\n}\r\nint mlx5_alloc_map_uar(struct mlx5_core_dev *mdev, struct mlx5_uar *uar,\r\nbool map_wc)\r\n{\r\nphys_addr_t pfn;\r\nphys_addr_t uar_bar_start;\r\nint err;\r\nerr = mlx5_cmd_alloc_uar(mdev, &uar->index);\r\nif (err) {\r\nmlx5_core_warn(mdev, "mlx5_cmd_alloc_uar() failed, %d\n", err);\r\nreturn err;\r\n}\r\nuar_bar_start = pci_resource_start(mdev->pdev, 0);\r\npfn = (uar_bar_start >> PAGE_SHIFT) + uar->index;\r\nif (map_wc) {\r\nuar->bf_map = ioremap_wc(pfn << PAGE_SHIFT, PAGE_SIZE);\r\nif (!uar->bf_map) {\r\nmlx5_core_warn(mdev, "ioremap_wc() failed\n");\r\nuar->map = ioremap(pfn << PAGE_SHIFT, PAGE_SIZE);\r\nif (!uar->map)\r\ngoto err_free_uar;\r\n}\r\n} else {\r\nuar->map = ioremap(pfn << PAGE_SHIFT, PAGE_SIZE);\r\nif (!uar->map)\r\ngoto err_free_uar;\r\n}\r\nreturn 0;\r\nerr_free_uar:\r\nmlx5_core_warn(mdev, "ioremap() failed\n");\r\nerr = -ENOMEM;\r\nmlx5_cmd_free_uar(mdev, uar->index);\r\nreturn err;\r\n}\r\nvoid mlx5_unmap_free_uar(struct mlx5_core_dev *mdev, struct mlx5_uar *uar)\r\n{\r\nif (uar->map)\r\niounmap(uar->map);\r\nelse\r\niounmap(uar->bf_map);\r\nmlx5_cmd_free_uar(mdev, uar->index);\r\n}
