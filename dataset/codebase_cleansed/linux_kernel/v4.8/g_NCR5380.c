static void __init internal_setup(int board, char *str, int *ints)\r\n{\r\nstatic int commandline_current;\r\nswitch (board) {\r\ncase BOARD_NCR5380:\r\nif (ints[0] != 2 && ints[0] != 3) {\r\nprintk(KERN_ERR "generic_NCR5380_setup : usage ncr5380=" STRVAL(NCR5380_map_name) ",irq,dma\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase BOARD_NCR53C400:\r\nif (ints[0] != 2) {\r\nprintk(KERN_ERR "generic_NCR53C400_setup : usage ncr53c400=" STRVAL(NCR5380_map_name) ",irq\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase BOARD_NCR53C400A:\r\nif (ints[0] != 2) {\r\nprintk(KERN_ERR "generic_NCR53C400A_setup : usage ncr53c400a=" STRVAL(NCR5380_map_name) ",irq\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase BOARD_DTC3181E:\r\nif (ints[0] != 2) {\r\nprintk("generic_DTC3181E_setup : usage dtc3181e=" STRVAL(NCR5380_map_name) ",irq\n");\r\nreturn;\r\n}\r\nbreak;\r\n}\r\nif (commandline_current < NO_OVERRIDES) {\r\noverrides[commandline_current].NCR5380_map_name = (NCR5380_map_type) ints[1];\r\noverrides[commandline_current].irq = ints[2];\r\nif (ints[0] == 3)\r\noverrides[commandline_current].dma = ints[3];\r\nelse\r\noverrides[commandline_current].dma = DMA_NONE;\r\noverrides[commandline_current].board = board;\r\n++commandline_current;\r\n}\r\n}\r\nstatic int __init do_NCR5380_setup(char *str)\r\n{\r\nint ints[10];\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\ninternal_setup(BOARD_NCR5380, str, ints);\r\nreturn 1;\r\n}\r\nstatic int __init do_NCR53C400_setup(char *str)\r\n{\r\nint ints[10];\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\ninternal_setup(BOARD_NCR53C400, str, ints);\r\nreturn 1;\r\n}\r\nstatic int __init do_NCR53C400A_setup(char *str)\r\n{\r\nint ints[10];\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\ninternal_setup(BOARD_NCR53C400A, str, ints);\r\nreturn 1;\r\n}\r\nstatic int __init do_DTC3181E_setup(char *str)\r\n{\r\nint ints[10];\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\ninternal_setup(BOARD_DTC3181E, str, ints);\r\nreturn 1;\r\n}\r\nstatic void magic_configure(int idx, u8 irq, u8 magic[])\r\n{\r\nu8 cfg = 0;\r\noutb(magic[0], 0x779);\r\noutb(magic[1], 0x379);\r\noutb(magic[2], 0x379);\r\noutb(magic[3], 0x379);\r\noutb(magic[4], 0x379);\r\nif (irq != 2 && irq != 3 && irq != 4 && irq != 5 && irq != 7)\r\nirq = 0;\r\nif (idx >= 0 && idx <= 7)\r\ncfg = 0x80 | idx | (irq << 4);\r\noutb(cfg, 0x379);\r\n}\r\nstatic int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)\r\n{\r\nstatic int current_override;\r\nint count;\r\nunsigned int *ports;\r\nu8 *magic = NULL;\r\n#ifndef SCSI_G_NCR5380_MEM\r\nint i;\r\nint port_idx = -1;\r\nunsigned long region_size;\r\n#endif\r\nstatic unsigned int __initdata ncr_53c400a_ports[] = {\r\n0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0\r\n};\r\nstatic unsigned int __initdata dtc_3181e_ports[] = {\r\n0x220, 0x240, 0x280, 0x2a0, 0x2c0, 0x300, 0x320, 0x340, 0\r\n};\r\nstatic u8 ncr_53c400a_magic[] __initdata = {\r\n0x59, 0xb9, 0xc5, 0xae, 0xa6\r\n};\r\nstatic u8 hp_c2502_magic[] __initdata = {\r\n0x0f, 0x22, 0xf0, 0x20, 0x80\r\n};\r\nint flags;\r\nstruct Scsi_Host *instance;\r\nstruct NCR5380_hostdata *hostdata;\r\n#ifdef SCSI_G_NCR5380_MEM\r\nunsigned long base;\r\nvoid __iomem *iomem;\r\nresource_size_t iomem_size;\r\n#endif\r\nif (ncr_irq)\r\noverrides[0].irq = ncr_irq;\r\nif (ncr_dma)\r\noverrides[0].dma = ncr_dma;\r\nif (ncr_addr)\r\noverrides[0].NCR5380_map_name = (NCR5380_map_type) ncr_addr;\r\nif (ncr_5380)\r\noverrides[0].board = BOARD_NCR5380;\r\nelse if (ncr_53c400)\r\noverrides[0].board = BOARD_NCR53C400;\r\nelse if (ncr_53c400a)\r\noverrides[0].board = BOARD_NCR53C400A;\r\nelse if (dtc_3181e)\r\noverrides[0].board = BOARD_DTC3181E;\r\nelse if (hp_c2502)\r\noverrides[0].board = BOARD_HP_C2502;\r\n#ifndef SCSI_G_NCR5380_MEM\r\nif (!current_override && isapnp_present()) {\r\nstruct pnp_dev *dev = NULL;\r\ncount = 0;\r\nwhile ((dev = pnp_find_dev(NULL, ISAPNP_VENDOR('D', 'T', 'C'), ISAPNP_FUNCTION(0x436e), dev))) {\r\nif (count >= NO_OVERRIDES)\r\nbreak;\r\nif (pnp_device_attach(dev) < 0)\r\ncontinue;\r\nif (pnp_activate_dev(dev) < 0) {\r\nprintk(KERN_ERR "dtc436e probe: activate failed\n");\r\npnp_device_detach(dev);\r\ncontinue;\r\n}\r\nif (!pnp_port_valid(dev, 0)) {\r\nprintk(KERN_ERR "dtc436e probe: no valid port\n");\r\npnp_device_detach(dev);\r\ncontinue;\r\n}\r\nif (pnp_irq_valid(dev, 0))\r\noverrides[count].irq = pnp_irq(dev, 0);\r\nelse\r\noverrides[count].irq = NO_IRQ;\r\nif (pnp_dma_valid(dev, 0))\r\noverrides[count].dma = pnp_dma(dev, 0);\r\nelse\r\noverrides[count].dma = DMA_NONE;\r\noverrides[count].NCR5380_map_name = (NCR5380_map_type) pnp_port_start(dev, 0);\r\noverrides[count].board = BOARD_DTC3181E;\r\ncount++;\r\n}\r\n}\r\n#endif\r\nfor (count = 0; current_override < NO_OVERRIDES; ++current_override) {\r\nif (!(overrides[current_override].NCR5380_map_name))\r\ncontinue;\r\nports = NULL;\r\nflags = 0;\r\nswitch (overrides[current_override].board) {\r\ncase BOARD_NCR5380:\r\nflags = FLAG_NO_PSEUDO_DMA | FLAG_DMA_FIXUP;\r\nbreak;\r\ncase BOARD_NCR53C400A:\r\nports = ncr_53c400a_ports;\r\nmagic = ncr_53c400a_magic;\r\nbreak;\r\ncase BOARD_HP_C2502:\r\nports = ncr_53c400a_ports;\r\nmagic = hp_c2502_magic;\r\nbreak;\r\ncase BOARD_DTC3181E:\r\nports = dtc_3181e_ports;\r\nmagic = ncr_53c400a_magic;\r\nbreak;\r\n}\r\n#ifndef SCSI_G_NCR5380_MEM\r\nif (ports && magic) {\r\nmagic_configure(-1, 0, magic);\r\nregion_size = 16;\r\nif (overrides[current_override].NCR5380_map_name != PORT_AUTO)\r\nfor (i = 0; ports[i]; i++) {\r\nif (!request_region(ports[i], region_size, "ncr53c80"))\r\ncontinue;\r\nif (overrides[current_override].NCR5380_map_name == ports[i])\r\nbreak;\r\nrelease_region(ports[i], region_size);\r\n} else\r\nfor (i = 0; ports[i]; i++) {\r\nif (!request_region(ports[i], region_size, "ncr53c80"))\r\ncontinue;\r\nif (inb(ports[i]) == 0xff)\r\nbreak;\r\nrelease_region(ports[i], region_size);\r\n}\r\nif (ports[i]) {\r\nmagic_configure(i, 0, magic);\r\noutb(0xc0, ports[i] + 9);\r\nif (inb(ports[i] + 9) != 0x80)\r\ncontinue;\r\noverrides[current_override].NCR5380_map_name = ports[i];\r\nport_idx = i;\r\n} else\r\ncontinue;\r\n}\r\nelse\r\n{\r\nregion_size = 8;\r\nif (!request_region(overrides[current_override].NCR5380_map_name,\r\nregion_size, "ncr5380"))\r\ncontinue;\r\n}\r\n#else\r\nbase = overrides[current_override].NCR5380_map_name;\r\niomem_size = NCR53C400_region_size;\r\nif (!request_mem_region(base, iomem_size, "ncr5380"))\r\ncontinue;\r\niomem = ioremap(base, iomem_size);\r\nif (!iomem) {\r\nrelease_mem_region(base, iomem_size);\r\ncontinue;\r\n}\r\n#endif\r\ninstance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));\r\nif (instance == NULL)\r\ngoto out_release;\r\nhostdata = shost_priv(instance);\r\n#ifndef SCSI_G_NCR5380_MEM\r\ninstance->io_port = overrides[current_override].NCR5380_map_name;\r\ninstance->n_io_port = region_size;\r\nhostdata->io_width = 1;\r\nswitch (overrides[current_override].board) {\r\ncase BOARD_NCR53C400:\r\ninstance->io_port += 8;\r\nhostdata->c400_ctl_status = 0;\r\nhostdata->c400_blk_cnt = 1;\r\nhostdata->c400_host_buf = 4;\r\nbreak;\r\ncase BOARD_DTC3181E:\r\nhostdata->io_width = 2;\r\ncase BOARD_NCR53C400A:\r\ncase BOARD_HP_C2502:\r\nhostdata->c400_ctl_status = 9;\r\nhostdata->c400_blk_cnt = 10;\r\nhostdata->c400_host_buf = 8;\r\nbreak;\r\n}\r\n#else\r\ninstance->base = overrides[current_override].NCR5380_map_name;\r\nhostdata->iomem = iomem;\r\nhostdata->iomem_size = iomem_size;\r\nswitch (overrides[current_override].board) {\r\ncase BOARD_NCR53C400:\r\nhostdata->c400_ctl_status = 0x100;\r\nhostdata->c400_blk_cnt = 0x101;\r\nhostdata->c400_host_buf = 0x104;\r\nbreak;\r\ncase BOARD_DTC3181E:\r\ncase BOARD_NCR53C400A:\r\ncase BOARD_HP_C2502:\r\npr_err(DRV_MODULE_NAME ": unknown register offsets\n");\r\ngoto out_unregister;\r\n}\r\n#endif\r\nif (NCR5380_init(instance, flags | FLAG_LATE_DMA_SETUP))\r\ngoto out_unregister;\r\nswitch (overrides[current_override].board) {\r\ncase BOARD_NCR53C400:\r\ncase BOARD_DTC3181E:\r\ncase BOARD_NCR53C400A:\r\ncase BOARD_HP_C2502:\r\nNCR5380_write(hostdata->c400_ctl_status, CSR_BASE);\r\n}\r\nNCR5380_maybe_reset_bus(instance);\r\nif (overrides[current_override].irq != IRQ_AUTO)\r\ninstance->irq = overrides[current_override].irq;\r\nelse\r\ninstance->irq = NCR5380_probe_irq(instance, 0xffff);\r\nif (instance->irq == 255)\r\ninstance->irq = NO_IRQ;\r\nif (instance->irq != NO_IRQ) {\r\n#ifndef SCSI_G_NCR5380_MEM\r\nif (overrides[current_override].board == BOARD_HP_C2502)\r\nmagic_configure(port_idx, instance->irq, magic);\r\n#endif\r\nif (request_irq(instance->irq, generic_NCR5380_intr,\r\n0, "NCR5380", instance)) {\r\nprintk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);\r\ninstance->irq = NO_IRQ;\r\n}\r\n}\r\nif (instance->irq == NO_IRQ) {\r\nprintk(KERN_INFO "scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);\r\nprintk(KERN_INFO "scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);\r\n}\r\n++current_override;\r\n++count;\r\n}\r\nreturn count;\r\nout_unregister:\r\nscsi_unregister(instance);\r\nout_release:\r\n#ifndef SCSI_G_NCR5380_MEM\r\nrelease_region(overrides[current_override].NCR5380_map_name, region_size);\r\n#else\r\niounmap(iomem);\r\nrelease_mem_region(base, iomem_size);\r\n#endif\r\nreturn count;\r\n}\r\nstatic int generic_NCR5380_release_resources(struct Scsi_Host *instance)\r\n{\r\nif (instance->irq != NO_IRQ)\r\nfree_irq(instance->irq, instance);\r\nNCR5380_exit(instance);\r\n#ifndef SCSI_G_NCR5380_MEM\r\nrelease_region(instance->io_port, instance->n_io_port);\r\n#else\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\niounmap(hostdata->iomem);\r\nrelease_mem_region(instance->base, hostdata->iomem_size);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline int generic_NCR5380_pread(struct Scsi_Host *instance,\r\nunsigned char *dst, int len)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint blocks = len / 128;\r\nint start = 0;\r\nNCR5380_write(hostdata->c400_ctl_status, CSR_BASE | CSR_TRANS_DIR);\r\nNCR5380_write(hostdata->c400_blk_cnt, blocks);\r\nwhile (1) {\r\nif (NCR5380_read(hostdata->c400_blk_cnt) == 0)\r\nbreak;\r\nif (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ) {\r\nprintk(KERN_ERR "53C400r: Got 53C80_IRQ start=%d, blocks=%d\n", start, blocks);\r\nreturn -1;\r\n}\r\nwhile (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)\r\n;\r\n#ifndef SCSI_G_NCR5380_MEM\r\nif (hostdata->io_width == 2)\r\ninsw(instance->io_port + hostdata->c400_host_buf,\r\ndst + start, 64);\r\nelse\r\ninsb(instance->io_port + hostdata->c400_host_buf,\r\ndst + start, 128);\r\n#else\r\nmemcpy_fromio(dst + start,\r\nhostdata->iomem + NCR53C400_host_buffer, 128);\r\n#endif\r\nstart += 128;\r\nblocks--;\r\n}\r\nif (blocks) {\r\nwhile (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)\r\n;\r\n#ifndef SCSI_G_NCR5380_MEM\r\nif (hostdata->io_width == 2)\r\ninsw(instance->io_port + hostdata->c400_host_buf,\r\ndst + start, 64);\r\nelse\r\ninsb(instance->io_port + hostdata->c400_host_buf,\r\ndst + start, 128);\r\n#else\r\nmemcpy_fromio(dst + start,\r\nhostdata->iomem + NCR53C400_host_buffer, 128);\r\n#endif\r\nstart += 128;\r\nblocks--;\r\n}\r\nif (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ))\r\nprintk("53C400r: no 53C80 gated irq after transfer");\r\nwhile (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG))\r\n;\r\nif (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER))\r\nprintk(KERN_ERR "53C400r: no end dma signal\n");\r\nreturn 0;\r\n}\r\nstatic inline int generic_NCR5380_pwrite(struct Scsi_Host *instance,\r\nunsigned char *src, int len)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint blocks = len / 128;\r\nint start = 0;\r\nNCR5380_write(hostdata->c400_ctl_status, CSR_BASE);\r\nNCR5380_write(hostdata->c400_blk_cnt, blocks);\r\nwhile (1) {\r\nif (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ) {\r\nprintk(KERN_ERR "53C400w: Got 53C80_IRQ start=%d, blocks=%d\n", start, blocks);\r\nreturn -1;\r\n}\r\nif (NCR5380_read(hostdata->c400_blk_cnt) == 0)\r\nbreak;\r\nwhile (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)\r\n;\r\n#ifndef SCSI_G_NCR5380_MEM\r\nif (hostdata->io_width == 2)\r\noutsw(instance->io_port + hostdata->c400_host_buf,\r\nsrc + start, 64);\r\nelse\r\noutsb(instance->io_port + hostdata->c400_host_buf,\r\nsrc + start, 128);\r\n#else\r\nmemcpy_toio(hostdata->iomem + NCR53C400_host_buffer,\r\nsrc + start, 128);\r\n#endif\r\nstart += 128;\r\nblocks--;\r\n}\r\nif (blocks) {\r\nwhile (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)\r\n;\r\n#ifndef SCSI_G_NCR5380_MEM\r\nif (hostdata->io_width == 2)\r\noutsw(instance->io_port + hostdata->c400_host_buf,\r\nsrc + start, 64);\r\nelse\r\noutsb(instance->io_port + hostdata->c400_host_buf,\r\nsrc + start, 128);\r\n#else\r\nmemcpy_toio(hostdata->iomem + NCR53C400_host_buffer,\r\nsrc + start, 128);\r\n#endif\r\nstart += 128;\r\nblocks--;\r\n}\r\nwhile (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG)) {\r\nudelay(4);\r\n}\r\nif (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER)) {\r\nprintk(KERN_ERR "53C400w: no end dma signal\n");\r\n}\r\nwhile (!(NCR5380_read(TARGET_COMMAND_REG) & TCR_LAST_BYTE_SENT))\r\n;\r\nreturn 0;\r\n}\r\nstatic int generic_NCR5380_dma_xfer_len(struct Scsi_Host *instance,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint transfersize = cmd->transfersize;\r\nif (hostdata->flags & FLAG_NO_PSEUDO_DMA)\r\nreturn 0;\r\nif (transfersize > 32 * 1024 && cmd->SCp.this_residual &&\r\n!(cmd->SCp.this_residual % transfersize))\r\ntransfersize = 32 * 1024;\r\nif (transfersize % 128)\r\ntransfersize = 0;\r\nreturn transfersize;\r\n}
