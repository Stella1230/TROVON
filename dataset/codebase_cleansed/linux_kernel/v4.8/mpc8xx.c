u32 mpc885_get_clock(u32 crystal)\r\n{\r\nu32 *immr;\r\nu32 plprcr;\r\nint mfi, mfn, mfd, pdf, div;\r\nu32 ret;\r\nimmr = fsl_get_immr();\r\nif (!immr) {\r\nprintf("mpc885_get_clock: Couldn't get IMMR base.\r\n");\r\nreturn 0;\r\n}\r\nplprcr = in_be32(&immr[MPC8XX_PLPRCR]);\r\nmfi = (plprcr >> 16) & 15;\r\nif (mfi < 5) {\r\nprintf("Warning: PLPRCR[MFI] value of %d out-of-bounds\r\n",\r\nmfi);\r\nmfi = 5;\r\n}\r\npdf = (plprcr >> 1) & 0xf;\r\ndiv = (plprcr >> 20) & 3;\r\nmfd = (plprcr >> 22) & 0x1f;\r\nmfn = (plprcr >> 27) & 0x1f;\r\nret = crystal * mfi;\r\nif (mfn != 0)\r\nret += crystal * mfn / (mfd + 1);\r\nreturn ret / (pdf + 1);\r\n}\r\nvoid mpc8xx_set_clocks(u32 sysclk)\r\n{\r\nvoid *node;\r\ndt_fixup_cpu_clocks(sysclk, sysclk / 16, sysclk);\r\nnode = finddevice("/soc/cpm");\r\nif (node)\r\nsetprop(node, "clock-frequency", &sysclk, 4);\r\nnode = finddevice("/soc/cpm/brg");\r\nif (node)\r\nsetprop(node, "clock-frequency", &sysclk, 4);\r\n}\r\nint mpc885_fixup_clocks(u32 crystal)\r\n{\r\nu32 sysclk = mpc885_get_clock(crystal);\r\nif (!sysclk)\r\nreturn 0;\r\nmpc8xx_set_clocks(sysclk);\r\nreturn 1;\r\n}
