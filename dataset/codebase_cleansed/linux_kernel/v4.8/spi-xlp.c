static inline u32 xlp_spi_reg_read(struct xlp_spi_priv *priv,\r\nint cs, int regoff)\r\n{\r\nreturn readl(priv->base + regoff + cs * SPI_CS_OFFSET);\r\n}\r\nstatic inline void xlp_spi_reg_write(struct xlp_spi_priv *priv, int cs,\r\nint regoff, u32 val)\r\n{\r\nwritel(val, priv->base + regoff + cs * SPI_CS_OFFSET);\r\n}\r\nstatic inline void xlp_spi_sysctl_write(struct xlp_spi_priv *priv,\r\nint regoff, u32 val)\r\n{\r\nwritel(val, priv->base + regoff);\r\n}\r\nstatic void xlp_spi_sysctl_setup(struct xlp_spi_priv *xspi)\r\n{\r\nint cs;\r\nfor (cs = 0; cs < XLP_SPI_MAX_CS; cs++)\r\nxlp_spi_sysctl_write(xspi, XLP_SPI_SYSCTRL,\r\nXLP_SPI_SYS_RESET << cs);\r\nxlp_spi_sysctl_write(xspi, XLP_SPI_SYSCTRL, XLP_SPI_SYS_PMEN);\r\n}\r\nstatic int xlp_spi_setup(struct spi_device *spi)\r\n{\r\nstruct xlp_spi_priv *xspi;\r\nu32 fdiv, cfg;\r\nint cs;\r\nxspi = spi_master_get_devdata(spi->master);\r\ncs = spi->chip_select;\r\nfdiv = DIV_ROUND_UP(xspi->spi_clk, spi->max_speed_hz);\r\nif (fdiv > XLP_SPI_FDIV_MAX)\r\nfdiv = XLP_SPI_FDIV_MAX;\r\nelse if (fdiv < XLP_SPI_FDIV_MIN)\r\nfdiv = XLP_SPI_FDIV_MIN;\r\nxlp_spi_reg_write(xspi, cs, XLP_SPI_FDIV, fdiv);\r\nxlp_spi_reg_write(xspi, cs, XLP_SPI_FIFO_THRESH, XLP_SPI_TXRXTH);\r\ncfg = xlp_spi_reg_read(xspi, cs, XLP_SPI_CONFIG);\r\nif (spi->mode & SPI_CPHA)\r\ncfg |= XLP_SPI_CPHA;\r\nelse\r\ncfg &= ~XLP_SPI_CPHA;\r\nif (spi->mode & SPI_CPOL)\r\ncfg |= XLP_SPI_CPOL;\r\nelse\r\ncfg &= ~XLP_SPI_CPOL;\r\nif (!(spi->mode & SPI_CS_HIGH))\r\ncfg |= XLP_SPI_CS_POL;\r\nelse\r\ncfg &= ~XLP_SPI_CS_POL;\r\nif (spi->mode & SPI_LSB_FIRST)\r\ncfg |= XLP_SPI_CS_LSBFE;\r\nelse\r\ncfg &= ~XLP_SPI_CS_LSBFE;\r\ncfg |= XLP_SPI_TXMOSI_EN | XLP_SPI_RXMISO_EN;\r\nif (fdiv == 4)\r\ncfg |= XLP_SPI_RXCAP_EN;\r\nxlp_spi_reg_write(xspi, cs, XLP_SPI_CONFIG, cfg);\r\nreturn 0;\r\n}\r\nstatic void xlp_spi_read_rxfifo(struct xlp_spi_priv *xspi)\r\n{\r\nu32 rx_data, rxfifo_cnt;\r\nint i, j, nbytes;\r\nrxfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_FIFO_WCNT);\r\nrxfifo_cnt &= XLP_SPI_RXFIFO_WCNT_MASK;\r\nwhile (rxfifo_cnt) {\r\nrx_data = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_RXDATA_FIFO);\r\nj = 0;\r\nnbytes = min(xspi->rx_len, 4);\r\nfor (i = nbytes - 1; i >= 0; i--, j++)\r\nxspi->rx_buf[i] = (rx_data >> (j * 8)) & 0xff;\r\nxspi->rx_len -= nbytes;\r\nxspi->rx_buf += nbytes;\r\nrxfifo_cnt--;\r\n}\r\n}\r\nstatic void xlp_spi_fill_txfifo(struct xlp_spi_priv *xspi)\r\n{\r\nu32 tx_data, txfifo_cnt;\r\nint i, j, nbytes;\r\ntxfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_FIFO_WCNT);\r\ntxfifo_cnt &= XLP_SPI_TXFIFO_WCNT_MASK;\r\ntxfifo_cnt >>= XLP_SPI_TXFIFO_WCNT_SHIFT;\r\nwhile (xspi->tx_len && (txfifo_cnt < XLP_SPI_FIFO_SIZE)) {\r\nj = 0;\r\ntx_data = 0;\r\nnbytes = min(xspi->tx_len, 4);\r\nfor (i = nbytes - 1; i >= 0; i--, j++)\r\ntx_data |= xspi->tx_buf[i] << (j * 8);\r\nxlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_TXDATA_FIFO, tx_data);\r\nxspi->tx_len -= nbytes;\r\nxspi->tx_buf += nbytes;\r\ntxfifo_cnt++;\r\n}\r\n}\r\nstatic irqreturn_t xlp_spi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct xlp_spi_priv *xspi = dev_id;\r\nu32 stat;\r\nstat = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_STATUS) &\r\nXLP_SPI_STAT_MASK;\r\nif (!stat)\r\nreturn IRQ_NONE;\r\nif (stat & XLP_SPI_TX_INT) {\r\nif (xspi->tx_len)\r\nxlp_spi_fill_txfifo(xspi);\r\nif (stat & XLP_SPI_TX_UF)\r\nxspi->txerrors++;\r\n}\r\nif (stat & XLP_SPI_RX_INT) {\r\nif (xspi->rx_len)\r\nxlp_spi_read_rxfifo(xspi);\r\nif (stat & XLP_SPI_RX_OF)\r\nxspi->rxerrors++;\r\n}\r\nxlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_STATUS, stat);\r\nif (stat & XLP_SPI_XFR_DONE)\r\ncomplete(&xspi->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void xlp_spi_send_cmd(struct xlp_spi_priv *xspi, int xfer_len,\r\nint cmd_cont)\r\n{\r\nu32 cmd = 0;\r\nif (xspi->tx_buf)\r\ncmd |= XLP_SPI_CMD_TX_MASK;\r\nif (xspi->rx_buf)\r\ncmd |= XLP_SPI_CMD_RX_MASK;\r\nif (cmd_cont)\r\ncmd |= XLP_SPI_CMD_CONT;\r\ncmd |= ((xfer_len * 8 - 1) << XLP_SPI_XFR_BITCNT_SHIFT);\r\nxlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_CMD, cmd);\r\n}\r\nstatic int xlp_spi_xfer_block(struct xlp_spi_priv *xs,\r\nconst unsigned char *tx_buf,\r\nunsigned char *rx_buf, int xfer_len, int cmd_cont)\r\n{\r\nint timeout;\r\nu32 intr_mask = 0;\r\nxs->tx_buf = tx_buf;\r\nxs->rx_buf = rx_buf;\r\nxs->tx_len = (xs->tx_buf == NULL) ? 0 : xfer_len;\r\nxs->rx_len = (xs->rx_buf == NULL) ? 0 : xfer_len;\r\nxs->txerrors = xs->rxerrors = 0;\r\nif (xs->tx_len)\r\nxlp_spi_fill_txfifo(xs);\r\nxlp_spi_send_cmd(xs, xfer_len, cmd_cont);\r\nif (xs->tx_len)\r\nintr_mask |= XLP_SPI_INTR_TXTH | XLP_SPI_INTR_TXUF |\r\nXLP_SPI_INTR_RXTH | XLP_SPI_INTR_RXOF;\r\nelse\r\nintr_mask |= XLP_SPI_INTR_RXTH | XLP_SPI_INTR_RXOF;\r\nintr_mask |= XLP_SPI_INTR_DONE;\r\nxlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, intr_mask);\r\ntimeout = wait_for_completion_timeout(&xs->done,\r\nmsecs_to_jiffies(1000));\r\nxlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, 0x0);\r\nif (!timeout) {\r\ndev_err(&xs->dev, "xfer timedout!\n");\r\ngoto out;\r\n}\r\nif (xs->txerrors || xs->rxerrors)\r\ndev_err(&xs->dev, "Over/Underflow rx %d tx %d xfer %d!\n",\r\nxs->rxerrors, xs->txerrors, xfer_len);\r\nreturn xfer_len;\r\nout:\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int xlp_spi_txrx_bufs(struct xlp_spi_priv *xs, struct spi_transfer *t)\r\n{\r\nint bytesleft, sz;\r\nunsigned char *rx_buf;\r\nconst unsigned char *tx_buf;\r\ntx_buf = t->tx_buf;\r\nrx_buf = t->rx_buf;\r\nbytesleft = t->len;\r\nwhile (bytesleft) {\r\nif (bytesleft > XLP_SPI_XFER_SIZE)\r\nsz = xlp_spi_xfer_block(xs, tx_buf, rx_buf,\r\nXLP_SPI_XFER_SIZE, 1);\r\nelse\r\nsz = xlp_spi_xfer_block(xs, tx_buf, rx_buf,\r\nbytesleft, xs->cmd_cont);\r\nif (sz < 0)\r\nreturn sz;\r\nbytesleft -= sz;\r\nif (tx_buf)\r\ntx_buf += sz;\r\nif (rx_buf)\r\nrx_buf += sz;\r\n}\r\nreturn bytesleft;\r\n}\r\nstatic int xlp_spi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct xlp_spi_priv *xspi = spi_master_get_devdata(master);\r\nint ret = 0;\r\nxspi->cs = spi->chip_select;\r\nxspi->dev = spi->dev;\r\nif (spi_transfer_is_last(master, t))\r\nxspi->cmd_cont = 0;\r\nelse\r\nxspi->cmd_cont = 1;\r\nif (xlp_spi_txrx_bufs(xspi, t))\r\nret = -EIO;\r\nspi_finalize_current_transfer(master);\r\nreturn ret;\r\n}\r\nstatic int xlp_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct xlp_spi_priv *xspi;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nint irq, err;\r\nxspi = devm_kzalloc(&pdev->dev, sizeof(*xspi), GFP_KERNEL);\r\nif (!xspi)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nxspi->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(xspi->base))\r\nreturn PTR_ERR(xspi->base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no IRQ resource found\n");\r\nreturn -EINVAL;\r\n}\r\nerr = devm_request_irq(&pdev->dev, irq, xlp_spi_interrupt, 0,\r\npdev->name, xspi);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to request irq %d\n", irq);\r\nreturn err;\r\n}\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "could not get spi clock\n");\r\nreturn -ENODEV;\r\n}\r\nxspi->spi_clk = clk_get_rate(clk);\r\nmaster = spi_alloc_master(&pdev->dev, 0);\r\nif (!master) {\r\ndev_err(&pdev->dev, "could not alloc master\n");\r\nreturn -ENOMEM;\r\n}\r\nmaster->bus_num = 0;\r\nmaster->num_chipselect = XLP_SPI_MAX_CS;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->setup = xlp_spi_setup;\r\nmaster->transfer_one = xlp_spi_transfer_one;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\ninit_completion(&xspi->done);\r\nspi_master_set_devdata(master, xspi);\r\nxlp_spi_sysctl_setup(xspi);\r\nerr = devm_spi_register_master(&pdev->dev, master);\r\nif (err) {\r\ndev_err(&pdev->dev, "spi register master failed!\n");\r\nspi_master_put(master);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
