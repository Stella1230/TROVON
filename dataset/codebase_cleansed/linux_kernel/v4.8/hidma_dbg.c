static void hidma_ll_chstats(struct seq_file *s, void *llhndl, u32 tre_ch)\r\n{\r\nstruct hidma_lldev *lldev = llhndl;\r\nstruct hidma_tre *tre;\r\nu32 length;\r\ndma_addr_t src_start;\r\ndma_addr_t dest_start;\r\nu32 *tre_local;\r\nif (tre_ch >= lldev->nr_tres) {\r\ndev_err(lldev->dev, "invalid TRE number in chstats:%d", tre_ch);\r\nreturn;\r\n}\r\ntre = &lldev->trepool[tre_ch];\r\nseq_printf(s, "------Channel %d -----\n", tre_ch);\r\nseq_printf(s, "allocated=%d\n", atomic_read(&tre->allocated));\r\nseq_printf(s, "queued = 0x%x\n", tre->queued);\r\nseq_printf(s, "err_info = 0x%x\n", tre->err_info);\r\nseq_printf(s, "err_code = 0x%x\n", tre->err_code);\r\nseq_printf(s, "status = 0x%x\n", tre->status);\r\nseq_printf(s, "idx = 0x%x\n", tre->idx);\r\nseq_printf(s, "dma_sig = 0x%x\n", tre->dma_sig);\r\nseq_printf(s, "dev_name=%s\n", tre->dev_name);\r\nseq_printf(s, "callback=%p\n", tre->callback);\r\nseq_printf(s, "data=%p\n", tre->data);\r\nseq_printf(s, "tre_index = 0x%x\n", tre->tre_index);\r\ntre_local = &tre->tre_local[0];\r\nsrc_start = tre_local[HIDMA_TRE_SRC_LOW_IDX];\r\nsrc_start = ((u64) (tre_local[HIDMA_TRE_SRC_HI_IDX]) << 32) + src_start;\r\ndest_start = tre_local[HIDMA_TRE_DEST_LOW_IDX];\r\ndest_start += ((u64) (tre_local[HIDMA_TRE_DEST_HI_IDX]) << 32);\r\nlength = tre_local[HIDMA_TRE_LEN_IDX];\r\nseq_printf(s, "src=%pap\n", &src_start);\r\nseq_printf(s, "dest=%pap\n", &dest_start);\r\nseq_printf(s, "length = 0x%x\n", length);\r\n}\r\nstatic void hidma_ll_devstats(struct seq_file *s, void *llhndl)\r\n{\r\nstruct hidma_lldev *lldev = llhndl;\r\nseq_puts(s, "------Device -----\n");\r\nseq_printf(s, "lldev init = 0x%x\n", lldev->initialized);\r\nseq_printf(s, "trch_state = 0x%x\n", lldev->trch_state);\r\nseq_printf(s, "evch_state = 0x%x\n", lldev->evch_state);\r\nseq_printf(s, "chidx = 0x%x\n", lldev->chidx);\r\nseq_printf(s, "nr_tres = 0x%x\n", lldev->nr_tres);\r\nseq_printf(s, "trca=%p\n", lldev->trca);\r\nseq_printf(s, "tre_ring=%p\n", lldev->tre_ring);\r\nseq_printf(s, "tre_ring_handle=%pap\n", &lldev->tre_dma);\r\nseq_printf(s, "tre_ring_size = 0x%x\n", lldev->tre_ring_size);\r\nseq_printf(s, "tre_processed_off = 0x%x\n", lldev->tre_processed_off);\r\nseq_printf(s, "pending_tre_count=%d\n", lldev->pending_tre_count);\r\nseq_printf(s, "evca=%p\n", lldev->evca);\r\nseq_printf(s, "evre_ring=%p\n", lldev->evre_ring);\r\nseq_printf(s, "evre_ring_handle=%pap\n", &lldev->evre_dma);\r\nseq_printf(s, "evre_ring_size = 0x%x\n", lldev->evre_ring_size);\r\nseq_printf(s, "evre_processed_off = 0x%x\n", lldev->evre_processed_off);\r\nseq_printf(s, "tre_write_offset = 0x%x\n", lldev->tre_write_offset);\r\n}\r\nstatic int hidma_chan_stats(struct seq_file *s, void *unused)\r\n{\r\nstruct hidma_chan *mchan = s->private;\r\nstruct hidma_desc *mdesc;\r\nstruct hidma_dev *dmadev = mchan->dmadev;\r\npm_runtime_get_sync(dmadev->ddev.dev);\r\nseq_printf(s, "paused=%u\n", mchan->paused);\r\nseq_printf(s, "dma_sig=%u\n", mchan->dma_sig);\r\nseq_puts(s, "prepared\n");\r\nlist_for_each_entry(mdesc, &mchan->prepared, node)\r\nhidma_ll_chstats(s, mchan->dmadev->lldev, mdesc->tre_ch);\r\nseq_puts(s, "active\n");\r\nlist_for_each_entry(mdesc, &mchan->active, node)\r\nhidma_ll_chstats(s, mchan->dmadev->lldev, mdesc->tre_ch);\r\nseq_puts(s, "completed\n");\r\nlist_for_each_entry(mdesc, &mchan->completed, node)\r\nhidma_ll_chstats(s, mchan->dmadev->lldev, mdesc->tre_ch);\r\nhidma_ll_devstats(s, mchan->dmadev->lldev);\r\npm_runtime_mark_last_busy(dmadev->ddev.dev);\r\npm_runtime_put_autosuspend(dmadev->ddev.dev);\r\nreturn 0;\r\n}\r\nstatic int hidma_dma_info(struct seq_file *s, void *unused)\r\n{\r\nstruct hidma_dev *dmadev = s->private;\r\nresource_size_t sz;\r\nseq_printf(s, "nr_descriptors=%d\n", dmadev->nr_descriptors);\r\nseq_printf(s, "dev_trca=%p\n", &dmadev->dev_trca);\r\nseq_printf(s, "dev_trca_phys=%pa\n", &dmadev->trca_resource->start);\r\nsz = resource_size(dmadev->trca_resource);\r\nseq_printf(s, "dev_trca_size=%pa\n", &sz);\r\nseq_printf(s, "dev_evca=%p\n", &dmadev->dev_evca);\r\nseq_printf(s, "dev_evca_phys=%pa\n", &dmadev->evca_resource->start);\r\nsz = resource_size(dmadev->evca_resource);\r\nseq_printf(s, "dev_evca_size=%pa\n", &sz);\r\nreturn 0;\r\n}\r\nstatic int hidma_chan_stats_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, hidma_chan_stats, inode->i_private);\r\n}\r\nstatic int hidma_dma_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, hidma_dma_info, inode->i_private);\r\n}\r\nvoid hidma_debug_uninit(struct hidma_dev *dmadev)\r\n{\r\ndebugfs_remove_recursive(dmadev->debugfs);\r\ndebugfs_remove_recursive(dmadev->stats);\r\n}\r\nint hidma_debug_init(struct hidma_dev *dmadev)\r\n{\r\nint rc = 0;\r\nint chidx = 0;\r\nstruct list_head *position = NULL;\r\ndmadev->debugfs = debugfs_create_dir(dev_name(dmadev->ddev.dev), NULL);\r\nif (!dmadev->debugfs) {\r\nrc = -ENODEV;\r\nreturn rc;\r\n}\r\nlist_for_each(position, &dmadev->ddev.channels) {\r\nstruct hidma_chan *chan;\r\nchan = list_entry(position, struct hidma_chan,\r\nchan.device_node);\r\nsprintf(chan->dbg_name, "chan%d", chidx);\r\nchan->debugfs = debugfs_create_dir(chan->dbg_name,\r\ndmadev->debugfs);\r\nif (!chan->debugfs) {\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nchan->stats = debugfs_create_file("stats", S_IRUGO,\r\nchan->debugfs, chan,\r\n&hidma_chan_fops);\r\nif (!chan->stats) {\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nchidx++;\r\n}\r\ndmadev->stats = debugfs_create_file("stats", S_IRUGO,\r\ndmadev->debugfs, dmadev,\r\n&hidma_dma_fops);\r\nif (!dmadev->stats) {\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nreturn 0;\r\ncleanup:\r\nhidma_debug_uninit(dmadev);\r\nreturn rc;\r\n}
