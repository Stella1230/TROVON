static int syscfg_reset_program_hw(struct reset_controller_dev *rcdev,\r\nunsigned long idx, int assert)\r\n{\r\nstruct syscfg_reset_controller *rst = to_syscfg_reset_controller(rcdev);\r\nconst struct syscfg_reset_channel *ch;\r\nu32 ctrl_val = rst->active_low ? !assert : !!assert;\r\nint err;\r\nif (idx >= rcdev->nr_resets)\r\nreturn -EINVAL;\r\nch = &rst->channels[idx];\r\nerr = regmap_field_write(ch->reset, ctrl_val);\r\nif (err)\r\nreturn err;\r\nif (ch->ack) {\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nu32 ack_val;\r\nwhile (true) {\r\nerr = regmap_field_read(ch->ack, &ack_val);\r\nif (err)\r\nreturn err;\r\nif (ack_val == ctrl_val)\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIME;\r\ncpu_relax();\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int syscfg_reset_assert(struct reset_controller_dev *rcdev,\r\nunsigned long idx)\r\n{\r\nreturn syscfg_reset_program_hw(rcdev, idx, true);\r\n}\r\nstatic int syscfg_reset_deassert(struct reset_controller_dev *rcdev,\r\nunsigned long idx)\r\n{\r\nreturn syscfg_reset_program_hw(rcdev, idx, false);\r\n}\r\nstatic int syscfg_reset_dev(struct reset_controller_dev *rcdev,\r\nunsigned long idx)\r\n{\r\nint err;\r\nerr = syscfg_reset_assert(rcdev, idx);\r\nif (err)\r\nreturn err;\r\nreturn syscfg_reset_deassert(rcdev, idx);\r\n}\r\nstatic int syscfg_reset_status(struct reset_controller_dev *rcdev,\r\nunsigned long idx)\r\n{\r\nstruct syscfg_reset_controller *rst = to_syscfg_reset_controller(rcdev);\r\nconst struct syscfg_reset_channel *ch;\r\nu32 ret_val = 0;\r\nint err;\r\nif (idx >= rcdev->nr_resets)\r\nreturn -EINVAL;\r\nch = &rst->channels[idx];\r\nif (ch->ack)\r\nerr = regmap_field_read(ch->ack, &ret_val);\r\nelse\r\nerr = regmap_field_read(ch->reset, &ret_val);\r\nif (err)\r\nreturn err;\r\nreturn rst->active_low ? !ret_val : !!ret_val;\r\n}\r\nstatic int syscfg_reset_controller_register(struct device *dev,\r\nconst struct syscfg_reset_controller_data *data)\r\n{\r\nstruct syscfg_reset_controller *rc;\r\nsize_t size;\r\nint i, err;\r\nrc = devm_kzalloc(dev, sizeof(*rc), GFP_KERNEL);\r\nif (!rc)\r\nreturn -ENOMEM;\r\nsize = sizeof(struct syscfg_reset_channel) * data->nr_channels;\r\nrc->channels = devm_kzalloc(dev, size, GFP_KERNEL);\r\nif (!rc->channels)\r\nreturn -ENOMEM;\r\nrc->rst.ops = &syscfg_reset_ops,\r\nrc->rst.of_node = dev->of_node;\r\nrc->rst.nr_resets = data->nr_channels;\r\nrc->active_low = data->active_low;\r\nfor (i = 0; i < data->nr_channels; i++) {\r\nstruct regmap *map;\r\nstruct regmap_field *f;\r\nconst char *compatible = data->channels[i].compatible;\r\nmap = syscon_regmap_lookup_by_compatible(compatible);\r\nif (IS_ERR(map))\r\nreturn PTR_ERR(map);\r\nf = devm_regmap_field_alloc(dev, map, data->channels[i].reset);\r\nif (IS_ERR(f))\r\nreturn PTR_ERR(f);\r\nrc->channels[i].reset = f;\r\nif (!data->wait_for_ack)\r\ncontinue;\r\nf = devm_regmap_field_alloc(dev, map, data->channels[i].ack);\r\nif (IS_ERR(f))\r\nreturn PTR_ERR(f);\r\nrc->channels[i].ack = f;\r\n}\r\nerr = reset_controller_register(&rc->rst);\r\nif (!err)\r\ndev_info(dev, "registered\n");\r\nreturn err;\r\n}\r\nint syscfg_reset_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = pdev ? &pdev->dev : NULL;\r\nconst struct of_device_id *match;\r\nif (!dev || !dev->driver)\r\nreturn -ENODEV;\r\nmatch = of_match_device(dev->driver->of_match_table, dev);\r\nif (!match || !match->data)\r\nreturn -EINVAL;\r\nreturn syscfg_reset_controller_register(dev, match->data);\r\n}
