static bool ofdpa_vlan_id_is_internal(__be16 vlan_id)\r\n{\r\nu16 start = OFDPA_INTERNAL_VLAN_ID_BASE;\r\nu16 end = 0xffe;\r\nu16 _vlan_id = ntohs(vlan_id);\r\nreturn (_vlan_id >= start && _vlan_id <= end);\r\n}\r\nstatic __be16 ofdpa_port_vid_to_vlan(const struct ofdpa_port *ofdpa_port,\r\nu16 vid, bool *pop_vlan)\r\n{\r\n__be16 vlan_id;\r\nif (pop_vlan)\r\n*pop_vlan = false;\r\nvlan_id = htons(vid);\r\nif (!vlan_id) {\r\nvlan_id = ofdpa_port->internal_vlan_id;\r\nif (pop_vlan)\r\n*pop_vlan = true;\r\n}\r\nreturn vlan_id;\r\n}\r\nstatic u16 ofdpa_port_vlan_to_vid(const struct ofdpa_port *ofdpa_port,\r\n__be16 vlan_id)\r\n{\r\nif (ofdpa_vlan_id_is_internal(vlan_id))\r\nreturn 0;\r\nreturn ntohs(vlan_id);\r\n}\r\nstatic bool ofdpa_port_is_slave(const struct ofdpa_port *ofdpa_port,\r\nconst char *kind)\r\n{\r\nreturn ofdpa_port->bridge_dev &&\r\n!strcmp(ofdpa_port->bridge_dev->rtnl_link_ops->kind, kind);\r\n}\r\nstatic bool ofdpa_port_is_bridged(const struct ofdpa_port *ofdpa_port)\r\n{\r\nreturn ofdpa_port_is_slave(ofdpa_port, "bridge");\r\n}\r\nstatic bool ofdpa_port_is_ovsed(const struct ofdpa_port *ofdpa_port)\r\n{\r\nreturn ofdpa_port_is_slave(ofdpa_port, "openvswitch");\r\n}\r\nstatic bool ofdpa_flags_nowait(int flags)\r\n{\r\nreturn flags & OFDPA_OP_FLAG_NOWAIT;\r\n}\r\nstatic void *__ofdpa_mem_alloc(struct switchdev_trans *trans, int flags,\r\nsize_t size)\r\n{\r\nstruct switchdev_trans_item *elem = NULL;\r\ngfp_t gfp_flags = (flags & OFDPA_OP_FLAG_NOWAIT) ?\r\nGFP_ATOMIC : GFP_KERNEL;\r\nif (!trans) {\r\nelem = kzalloc(size + sizeof(*elem), gfp_flags);\r\n} else if (switchdev_trans_ph_prepare(trans)) {\r\nelem = kzalloc(size + sizeof(*elem), gfp_flags);\r\nif (!elem)\r\nreturn NULL;\r\nswitchdev_trans_item_enqueue(trans, elem, kfree, elem);\r\n} else {\r\nelem = switchdev_trans_item_dequeue(trans);\r\n}\r\nreturn elem ? elem + 1 : NULL;\r\n}\r\nstatic void *ofdpa_kzalloc(struct switchdev_trans *trans, int flags,\r\nsize_t size)\r\n{\r\nreturn __ofdpa_mem_alloc(trans, flags, size);\r\n}\r\nstatic void *ofdpa_kcalloc(struct switchdev_trans *trans, int flags,\r\nsize_t n, size_t size)\r\n{\r\nreturn __ofdpa_mem_alloc(trans, flags, n * size);\r\n}\r\nstatic void ofdpa_kfree(struct switchdev_trans *trans, const void *mem)\r\n{\r\nstruct switchdev_trans_item *elem;\r\nif (switchdev_trans_ph_prepare(trans))\r\nreturn;\r\nelem = (struct switchdev_trans_item *) mem - 1;\r\nkfree(elem);\r\n}\r\nstatic int\r\nofdpa_cmd_flow_tbl_add_ig_port(struct rocker_desc_info *desc_info,\r\nconst struct ofdpa_flow_tbl_entry *entry)\r\n{\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT,\r\nentry->key.ig_port.in_pport))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT_MASK,\r\nentry->key.ig_port.in_pport_mask))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GOTO_TABLE_ID,\r\nentry->key.ig_port.goto_tbl))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int\r\nofdpa_cmd_flow_tbl_add_vlan(struct rocker_desc_info *desc_info,\r\nconst struct ofdpa_flow_tbl_entry *entry)\r\n{\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT,\r\nentry->key.vlan.in_pport))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\r\nentry->key.vlan.vlan_id))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID_MASK,\r\nentry->key.vlan.vlan_id_mask))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GOTO_TABLE_ID,\r\nentry->key.vlan.goto_tbl))\r\nreturn -EMSGSIZE;\r\nif (entry->key.vlan.untagged &&\r\nrocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_NEW_VLAN_ID,\r\nentry->key.vlan.new_vlan_id))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int\r\nofdpa_cmd_flow_tbl_add_term_mac(struct rocker_desc_info *desc_info,\r\nconst struct ofdpa_flow_tbl_entry *entry)\r\n{\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT,\r\nentry->key.term_mac.in_pport))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT_MASK,\r\nentry->key.term_mac.in_pport_mask))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_ETHERTYPE,\r\nentry->key.term_mac.eth_type))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC,\r\nETH_ALEN, entry->key.term_mac.eth_dst))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC_MASK,\r\nETH_ALEN, entry->key.term_mac.eth_dst_mask))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\r\nentry->key.term_mac.vlan_id))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID_MASK,\r\nentry->key.term_mac.vlan_id_mask))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GOTO_TABLE_ID,\r\nentry->key.term_mac.goto_tbl))\r\nreturn -EMSGSIZE;\r\nif (entry->key.term_mac.copy_to_cpu &&\r\nrocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_COPY_CPU_ACTION,\r\nentry->key.term_mac.copy_to_cpu))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int\r\nofdpa_cmd_flow_tbl_add_ucast_routing(struct rocker_desc_info *desc_info,\r\nconst struct ofdpa_flow_tbl_entry *entry)\r\n{\r\nif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_ETHERTYPE,\r\nentry->key.ucast_routing.eth_type))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_be32(desc_info, ROCKER_TLV_OF_DPA_DST_IP,\r\nentry->key.ucast_routing.dst4))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_be32(desc_info, ROCKER_TLV_OF_DPA_DST_IP_MASK,\r\nentry->key.ucast_routing.dst4_mask))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GOTO_TABLE_ID,\r\nentry->key.ucast_routing.goto_tbl))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID,\r\nentry->key.ucast_routing.group_id))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int\r\nofdpa_cmd_flow_tbl_add_bridge(struct rocker_desc_info *desc_info,\r\nconst struct ofdpa_flow_tbl_entry *entry)\r\n{\r\nif (entry->key.bridge.has_eth_dst &&\r\nrocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC,\r\nETH_ALEN, entry->key.bridge.eth_dst))\r\nreturn -EMSGSIZE;\r\nif (entry->key.bridge.has_eth_dst_mask &&\r\nrocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC_MASK,\r\nETH_ALEN, entry->key.bridge.eth_dst_mask))\r\nreturn -EMSGSIZE;\r\nif (entry->key.bridge.vlan_id &&\r\nrocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\r\nentry->key.bridge.vlan_id))\r\nreturn -EMSGSIZE;\r\nif (entry->key.bridge.tunnel_id &&\r\nrocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_TUNNEL_ID,\r\nentry->key.bridge.tunnel_id))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GOTO_TABLE_ID,\r\nentry->key.bridge.goto_tbl))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID,\r\nentry->key.bridge.group_id))\r\nreturn -EMSGSIZE;\r\nif (entry->key.bridge.copy_to_cpu &&\r\nrocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_COPY_CPU_ACTION,\r\nentry->key.bridge.copy_to_cpu))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int\r\nofdpa_cmd_flow_tbl_add_acl(struct rocker_desc_info *desc_info,\r\nconst struct ofdpa_flow_tbl_entry *entry)\r\n{\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT,\r\nentry->key.acl.in_pport))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT_MASK,\r\nentry->key.acl.in_pport_mask))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_SRC_MAC,\r\nETH_ALEN, entry->key.acl.eth_src))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_SRC_MAC_MASK,\r\nETH_ALEN, entry->key.acl.eth_src_mask))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC,\r\nETH_ALEN, entry->key.acl.eth_dst))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC_MASK,\r\nETH_ALEN, entry->key.acl.eth_dst_mask))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_ETHERTYPE,\r\nentry->key.acl.eth_type))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\r\nentry->key.acl.vlan_id))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID_MASK,\r\nentry->key.acl.vlan_id_mask))\r\nreturn -EMSGSIZE;\r\nswitch (ntohs(entry->key.acl.eth_type)) {\r\ncase ETH_P_IP:\r\ncase ETH_P_IPV6:\r\nif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_IP_PROTO,\r\nentry->key.acl.ip_proto))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u8(desc_info,\r\nROCKER_TLV_OF_DPA_IP_PROTO_MASK,\r\nentry->key.acl.ip_proto_mask))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_IP_DSCP,\r\nentry->key.acl.ip_tos & 0x3f))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u8(desc_info,\r\nROCKER_TLV_OF_DPA_IP_DSCP_MASK,\r\nentry->key.acl.ip_tos_mask & 0x3f))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_IP_ECN,\r\n(entry->key.acl.ip_tos & 0xc0) >> 6))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u8(desc_info,\r\nROCKER_TLV_OF_DPA_IP_ECN_MASK,\r\n(entry->key.acl.ip_tos_mask & 0xc0) >> 6))\r\nreturn -EMSGSIZE;\r\nbreak;\r\n}\r\nif (entry->key.acl.group_id != ROCKER_GROUP_NONE &&\r\nrocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID,\r\nentry->key.acl.group_id))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int ofdpa_cmd_flow_tbl_add(const struct rocker_port *rocker_port,\r\nstruct rocker_desc_info *desc_info,\r\nvoid *priv)\r\n{\r\nconst struct ofdpa_flow_tbl_entry *entry = priv;\r\nstruct rocker_tlv *cmd_info;\r\nint err = 0;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE, entry->cmd))\r\nreturn -EMSGSIZE;\r\ncmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\r\nif (!cmd_info)\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_TABLE_ID,\r\nentry->key.tbl_id))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_PRIORITY,\r\nentry->key.priority))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_HARDTIME, 0))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u64(desc_info, ROCKER_TLV_OF_DPA_COOKIE,\r\nentry->cookie))\r\nreturn -EMSGSIZE;\r\nswitch (entry->key.tbl_id) {\r\ncase ROCKER_OF_DPA_TABLE_ID_INGRESS_PORT:\r\nerr = ofdpa_cmd_flow_tbl_add_ig_port(desc_info, entry);\r\nbreak;\r\ncase ROCKER_OF_DPA_TABLE_ID_VLAN:\r\nerr = ofdpa_cmd_flow_tbl_add_vlan(desc_info, entry);\r\nbreak;\r\ncase ROCKER_OF_DPA_TABLE_ID_TERMINATION_MAC:\r\nerr = ofdpa_cmd_flow_tbl_add_term_mac(desc_info, entry);\r\nbreak;\r\ncase ROCKER_OF_DPA_TABLE_ID_UNICAST_ROUTING:\r\nerr = ofdpa_cmd_flow_tbl_add_ucast_routing(desc_info, entry);\r\nbreak;\r\ncase ROCKER_OF_DPA_TABLE_ID_BRIDGING:\r\nerr = ofdpa_cmd_flow_tbl_add_bridge(desc_info, entry);\r\nbreak;\r\ncase ROCKER_OF_DPA_TABLE_ID_ACL_POLICY:\r\nerr = ofdpa_cmd_flow_tbl_add_acl(desc_info, entry);\r\nbreak;\r\ndefault:\r\nerr = -ENOTSUPP;\r\nbreak;\r\n}\r\nif (err)\r\nreturn err;\r\nrocker_tlv_nest_end(desc_info, cmd_info);\r\nreturn 0;\r\n}\r\nstatic int ofdpa_cmd_flow_tbl_del(const struct rocker_port *rocker_port,\r\nstruct rocker_desc_info *desc_info,\r\nvoid *priv)\r\n{\r\nconst struct ofdpa_flow_tbl_entry *entry = priv;\r\nstruct rocker_tlv *cmd_info;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE, entry->cmd))\r\nreturn -EMSGSIZE;\r\ncmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\r\nif (!cmd_info)\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u64(desc_info, ROCKER_TLV_OF_DPA_COOKIE,\r\nentry->cookie))\r\nreturn -EMSGSIZE;\r\nrocker_tlv_nest_end(desc_info, cmd_info);\r\nreturn 0;\r\n}\r\nstatic int\r\nofdpa_cmd_group_tbl_add_l2_interface(struct rocker_desc_info *desc_info,\r\nstruct ofdpa_group_tbl_entry *entry)\r\n{\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_OUT_PPORT,\r\nROCKER_GROUP_PORT_GET(entry->group_id)))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_POP_VLAN,\r\nentry->l2_interface.pop_vlan))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int\r\nofdpa_cmd_group_tbl_add_l2_rewrite(struct rocker_desc_info *desc_info,\r\nconst struct ofdpa_group_tbl_entry *entry)\r\n{\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID_LOWER,\r\nentry->l2_rewrite.group_id))\r\nreturn -EMSGSIZE;\r\nif (!is_zero_ether_addr(entry->l2_rewrite.eth_src) &&\r\nrocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_SRC_MAC,\r\nETH_ALEN, entry->l2_rewrite.eth_src))\r\nreturn -EMSGSIZE;\r\nif (!is_zero_ether_addr(entry->l2_rewrite.eth_dst) &&\r\nrocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC,\r\nETH_ALEN, entry->l2_rewrite.eth_dst))\r\nreturn -EMSGSIZE;\r\nif (entry->l2_rewrite.vlan_id &&\r\nrocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\r\nentry->l2_rewrite.vlan_id))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int\r\nofdpa_cmd_group_tbl_add_group_ids(struct rocker_desc_info *desc_info,\r\nconst struct ofdpa_group_tbl_entry *entry)\r\n{\r\nint i;\r\nstruct rocker_tlv *group_ids;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GROUP_COUNT,\r\nentry->group_count))\r\nreturn -EMSGSIZE;\r\ngroup_ids = rocker_tlv_nest_start(desc_info,\r\nROCKER_TLV_OF_DPA_GROUP_IDS);\r\nif (!group_ids)\r\nreturn -EMSGSIZE;\r\nfor (i = 0; i < entry->group_count; i++)\r\nif (rocker_tlv_put_u32(desc_info, i + 1, entry->group_ids[i]))\r\nreturn -EMSGSIZE;\r\nrocker_tlv_nest_end(desc_info, group_ids);\r\nreturn 0;\r\n}\r\nstatic int\r\nofdpa_cmd_group_tbl_add_l3_unicast(struct rocker_desc_info *desc_info,\r\nconst struct ofdpa_group_tbl_entry *entry)\r\n{\r\nif (!is_zero_ether_addr(entry->l3_unicast.eth_src) &&\r\nrocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_SRC_MAC,\r\nETH_ALEN, entry->l3_unicast.eth_src))\r\nreturn -EMSGSIZE;\r\nif (!is_zero_ether_addr(entry->l3_unicast.eth_dst) &&\r\nrocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC,\r\nETH_ALEN, entry->l3_unicast.eth_dst))\r\nreturn -EMSGSIZE;\r\nif (entry->l3_unicast.vlan_id &&\r\nrocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\r\nentry->l3_unicast.vlan_id))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_TTL_CHECK,\r\nentry->l3_unicast.ttl_check))\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID_LOWER,\r\nentry->l3_unicast.group_id))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int ofdpa_cmd_group_tbl_add(const struct rocker_port *rocker_port,\r\nstruct rocker_desc_info *desc_info,\r\nvoid *priv)\r\n{\r\nstruct ofdpa_group_tbl_entry *entry = priv;\r\nstruct rocker_tlv *cmd_info;\r\nint err = 0;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE, entry->cmd))\r\nreturn -EMSGSIZE;\r\ncmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\r\nif (!cmd_info)\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID,\r\nentry->group_id))\r\nreturn -EMSGSIZE;\r\nswitch (ROCKER_GROUP_TYPE_GET(entry->group_id)) {\r\ncase ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE:\r\nerr = ofdpa_cmd_group_tbl_add_l2_interface(desc_info, entry);\r\nbreak;\r\ncase ROCKER_OF_DPA_GROUP_TYPE_L2_REWRITE:\r\nerr = ofdpa_cmd_group_tbl_add_l2_rewrite(desc_info, entry);\r\nbreak;\r\ncase ROCKER_OF_DPA_GROUP_TYPE_L2_FLOOD:\r\ncase ROCKER_OF_DPA_GROUP_TYPE_L2_MCAST:\r\nerr = ofdpa_cmd_group_tbl_add_group_ids(desc_info, entry);\r\nbreak;\r\ncase ROCKER_OF_DPA_GROUP_TYPE_L3_UCAST:\r\nerr = ofdpa_cmd_group_tbl_add_l3_unicast(desc_info, entry);\r\nbreak;\r\ndefault:\r\nerr = -ENOTSUPP;\r\nbreak;\r\n}\r\nif (err)\r\nreturn err;\r\nrocker_tlv_nest_end(desc_info, cmd_info);\r\nreturn 0;\r\n}\r\nstatic int ofdpa_cmd_group_tbl_del(const struct rocker_port *rocker_port,\r\nstruct rocker_desc_info *desc_info,\r\nvoid *priv)\r\n{\r\nconst struct ofdpa_group_tbl_entry *entry = priv;\r\nstruct rocker_tlv *cmd_info;\r\nif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE, entry->cmd))\r\nreturn -EMSGSIZE;\r\ncmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\r\nif (!cmd_info)\r\nreturn -EMSGSIZE;\r\nif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID,\r\nentry->group_id))\r\nreturn -EMSGSIZE;\r\nrocker_tlv_nest_end(desc_info, cmd_info);\r\nreturn 0;\r\n}\r\nstatic struct ofdpa_flow_tbl_entry *\r\nofdpa_flow_tbl_find(const struct ofdpa *ofdpa,\r\nconst struct ofdpa_flow_tbl_entry *match)\r\n{\r\nstruct ofdpa_flow_tbl_entry *found;\r\nsize_t key_len = match->key_len ? match->key_len : sizeof(found->key);\r\nhash_for_each_possible(ofdpa->flow_tbl, found,\r\nentry, match->key_crc32) {\r\nif (memcmp(&found->key, &match->key, key_len) == 0)\r\nreturn found;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ofdpa_flow_tbl_add(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nstruct ofdpa_flow_tbl_entry *match)\r\n{\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_flow_tbl_entry *found;\r\nsize_t key_len = match->key_len ? match->key_len : sizeof(found->key);\r\nunsigned long lock_flags;\r\nmatch->key_crc32 = crc32(~0, &match->key, key_len);\r\nspin_lock_irqsave(&ofdpa->flow_tbl_lock, lock_flags);\r\nfound = ofdpa_flow_tbl_find(ofdpa, match);\r\nif (found) {\r\nmatch->cookie = found->cookie;\r\nif (!switchdev_trans_ph_prepare(trans))\r\nhash_del(&found->entry);\r\nofdpa_kfree(trans, found);\r\nfound = match;\r\nfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_FLOW_MOD;\r\n} else {\r\nfound = match;\r\nfound->cookie = ofdpa->flow_tbl_next_cookie++;\r\nfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_FLOW_ADD;\r\n}\r\nif (!switchdev_trans_ph_prepare(trans))\r\nhash_add(ofdpa->flow_tbl, &found->entry, found->key_crc32);\r\nspin_unlock_irqrestore(&ofdpa->flow_tbl_lock, lock_flags);\r\nif (!switchdev_trans_ph_prepare(trans))\r\nreturn rocker_cmd_exec(ofdpa_port->rocker_port,\r\nofdpa_flags_nowait(flags),\r\nofdpa_cmd_flow_tbl_add,\r\nfound, NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic int ofdpa_flow_tbl_del(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nstruct ofdpa_flow_tbl_entry *match)\r\n{\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_flow_tbl_entry *found;\r\nsize_t key_len = match->key_len ? match->key_len : sizeof(found->key);\r\nunsigned long lock_flags;\r\nint err = 0;\r\nmatch->key_crc32 = crc32(~0, &match->key, key_len);\r\nspin_lock_irqsave(&ofdpa->flow_tbl_lock, lock_flags);\r\nfound = ofdpa_flow_tbl_find(ofdpa, match);\r\nif (found) {\r\nif (!switchdev_trans_ph_prepare(trans))\r\nhash_del(&found->entry);\r\nfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_FLOW_DEL;\r\n}\r\nspin_unlock_irqrestore(&ofdpa->flow_tbl_lock, lock_flags);\r\nofdpa_kfree(trans, match);\r\nif (found) {\r\nif (!switchdev_trans_ph_prepare(trans))\r\nerr = rocker_cmd_exec(ofdpa_port->rocker_port,\r\nofdpa_flags_nowait(flags),\r\nofdpa_cmd_flow_tbl_del,\r\nfound, NULL, NULL);\r\nofdpa_kfree(trans, found);\r\n}\r\nreturn err;\r\n}\r\nstatic int ofdpa_flow_tbl_do(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nstruct ofdpa_flow_tbl_entry *entry)\r\n{\r\nif (flags & OFDPA_OP_FLAG_REMOVE)\r\nreturn ofdpa_flow_tbl_del(ofdpa_port, trans, flags, entry);\r\nelse\r\nreturn ofdpa_flow_tbl_add(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic int ofdpa_flow_tbl_ig_port(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nu32 in_pport, u32 in_pport_mask,\r\nenum rocker_of_dpa_table_id goto_tbl)\r\n{\r\nstruct ofdpa_flow_tbl_entry *entry;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->key.priority = OFDPA_PRIORITY_IG_PORT;\r\nentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_INGRESS_PORT;\r\nentry->key.ig_port.in_pport = in_pport;\r\nentry->key.ig_port.in_pport_mask = in_pport_mask;\r\nentry->key.ig_port.goto_tbl = goto_tbl;\r\nreturn ofdpa_flow_tbl_do(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic int ofdpa_flow_tbl_vlan(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nu32 in_pport, __be16 vlan_id,\r\n__be16 vlan_id_mask,\r\nenum rocker_of_dpa_table_id goto_tbl,\r\nbool untagged, __be16 new_vlan_id)\r\n{\r\nstruct ofdpa_flow_tbl_entry *entry;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->key.priority = OFDPA_PRIORITY_VLAN;\r\nentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_VLAN;\r\nentry->key.vlan.in_pport = in_pport;\r\nentry->key.vlan.vlan_id = vlan_id;\r\nentry->key.vlan.vlan_id_mask = vlan_id_mask;\r\nentry->key.vlan.goto_tbl = goto_tbl;\r\nentry->key.vlan.untagged = untagged;\r\nentry->key.vlan.new_vlan_id = new_vlan_id;\r\nreturn ofdpa_flow_tbl_do(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic int ofdpa_flow_tbl_term_mac(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans,\r\nu32 in_pport, u32 in_pport_mask,\r\n__be16 eth_type, const u8 *eth_dst,\r\nconst u8 *eth_dst_mask, __be16 vlan_id,\r\n__be16 vlan_id_mask, bool copy_to_cpu,\r\nint flags)\r\n{\r\nstruct ofdpa_flow_tbl_entry *entry;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\nif (is_multicast_ether_addr(eth_dst)) {\r\nentry->key.priority = OFDPA_PRIORITY_TERM_MAC_MCAST;\r\nentry->key.term_mac.goto_tbl =\r\nROCKER_OF_DPA_TABLE_ID_MULTICAST_ROUTING;\r\n} else {\r\nentry->key.priority = OFDPA_PRIORITY_TERM_MAC_UCAST;\r\nentry->key.term_mac.goto_tbl =\r\nROCKER_OF_DPA_TABLE_ID_UNICAST_ROUTING;\r\n}\r\nentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_TERMINATION_MAC;\r\nentry->key.term_mac.in_pport = in_pport;\r\nentry->key.term_mac.in_pport_mask = in_pport_mask;\r\nentry->key.term_mac.eth_type = eth_type;\r\nether_addr_copy(entry->key.term_mac.eth_dst, eth_dst);\r\nether_addr_copy(entry->key.term_mac.eth_dst_mask, eth_dst_mask);\r\nentry->key.term_mac.vlan_id = vlan_id;\r\nentry->key.term_mac.vlan_id_mask = vlan_id_mask;\r\nentry->key.term_mac.copy_to_cpu = copy_to_cpu;\r\nreturn ofdpa_flow_tbl_do(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic int ofdpa_flow_tbl_bridge(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nconst u8 *eth_dst, const u8 *eth_dst_mask,\r\n__be16 vlan_id, u32 tunnel_id,\r\nenum rocker_of_dpa_table_id goto_tbl,\r\nu32 group_id, bool copy_to_cpu)\r\n{\r\nstruct ofdpa_flow_tbl_entry *entry;\r\nu32 priority;\r\nbool vlan_bridging = !!vlan_id;\r\nbool dflt = !eth_dst || (eth_dst && eth_dst_mask);\r\nbool wild = false;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_BRIDGING;\r\nif (eth_dst) {\r\nentry->key.bridge.has_eth_dst = 1;\r\nether_addr_copy(entry->key.bridge.eth_dst, eth_dst);\r\n}\r\nif (eth_dst_mask) {\r\nentry->key.bridge.has_eth_dst_mask = 1;\r\nether_addr_copy(entry->key.bridge.eth_dst_mask, eth_dst_mask);\r\nif (!ether_addr_equal(eth_dst_mask, ff_mac))\r\nwild = true;\r\n}\r\npriority = OFDPA_PRIORITY_UNKNOWN;\r\nif (vlan_bridging && dflt && wild)\r\npriority = OFDPA_PRIORITY_BRIDGING_VLAN_DFLT_WILD;\r\nelse if (vlan_bridging && dflt && !wild)\r\npriority = OFDPA_PRIORITY_BRIDGING_VLAN_DFLT_EXACT;\r\nelse if (vlan_bridging && !dflt)\r\npriority = OFDPA_PRIORITY_BRIDGING_VLAN;\r\nelse if (!vlan_bridging && dflt && wild)\r\npriority = OFDPA_PRIORITY_BRIDGING_TENANT_DFLT_WILD;\r\nelse if (!vlan_bridging && dflt && !wild)\r\npriority = OFDPA_PRIORITY_BRIDGING_TENANT_DFLT_EXACT;\r\nelse if (!vlan_bridging && !dflt)\r\npriority = OFDPA_PRIORITY_BRIDGING_TENANT;\r\nentry->key.priority = priority;\r\nentry->key.bridge.vlan_id = vlan_id;\r\nentry->key.bridge.tunnel_id = tunnel_id;\r\nentry->key.bridge.goto_tbl = goto_tbl;\r\nentry->key.bridge.group_id = group_id;\r\nentry->key.bridge.copy_to_cpu = copy_to_cpu;\r\nreturn ofdpa_flow_tbl_do(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic int ofdpa_flow_tbl_ucast4_routing(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans,\r\n__be16 eth_type, __be32 dst,\r\n__be32 dst_mask, u32 priority,\r\nenum rocker_of_dpa_table_id goto_tbl,\r\nu32 group_id, int flags)\r\n{\r\nstruct ofdpa_flow_tbl_entry *entry;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_UNICAST_ROUTING;\r\nentry->key.priority = priority;\r\nentry->key.ucast_routing.eth_type = eth_type;\r\nentry->key.ucast_routing.dst4 = dst;\r\nentry->key.ucast_routing.dst4_mask = dst_mask;\r\nentry->key.ucast_routing.goto_tbl = goto_tbl;\r\nentry->key.ucast_routing.group_id = group_id;\r\nentry->key_len = offsetof(struct ofdpa_flow_tbl_key,\r\nucast_routing.group_id);\r\nreturn ofdpa_flow_tbl_do(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic int ofdpa_flow_tbl_acl(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nu32 in_pport, u32 in_pport_mask,\r\nconst u8 *eth_src, const u8 *eth_src_mask,\r\nconst u8 *eth_dst, const u8 *eth_dst_mask,\r\n__be16 eth_type, __be16 vlan_id,\r\n__be16 vlan_id_mask, u8 ip_proto,\r\nu8 ip_proto_mask, u8 ip_tos, u8 ip_tos_mask,\r\nu32 group_id)\r\n{\r\nu32 priority;\r\nstruct ofdpa_flow_tbl_entry *entry;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\npriority = OFDPA_PRIORITY_ACL_NORMAL;\r\nif (eth_dst && eth_dst_mask) {\r\nif (ether_addr_equal(eth_dst_mask, mcast_mac))\r\npriority = OFDPA_PRIORITY_ACL_DFLT;\r\nelse if (is_link_local_ether_addr(eth_dst))\r\npriority = OFDPA_PRIORITY_ACL_CTRL;\r\n}\r\nentry->key.priority = priority;\r\nentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_ACL_POLICY;\r\nentry->key.acl.in_pport = in_pport;\r\nentry->key.acl.in_pport_mask = in_pport_mask;\r\nif (eth_src)\r\nether_addr_copy(entry->key.acl.eth_src, eth_src);\r\nif (eth_src_mask)\r\nether_addr_copy(entry->key.acl.eth_src_mask, eth_src_mask);\r\nif (eth_dst)\r\nether_addr_copy(entry->key.acl.eth_dst, eth_dst);\r\nif (eth_dst_mask)\r\nether_addr_copy(entry->key.acl.eth_dst_mask, eth_dst_mask);\r\nentry->key.acl.eth_type = eth_type;\r\nentry->key.acl.vlan_id = vlan_id;\r\nentry->key.acl.vlan_id_mask = vlan_id_mask;\r\nentry->key.acl.ip_proto = ip_proto;\r\nentry->key.acl.ip_proto_mask = ip_proto_mask;\r\nentry->key.acl.ip_tos = ip_tos;\r\nentry->key.acl.ip_tos_mask = ip_tos_mask;\r\nentry->key.acl.group_id = group_id;\r\nreturn ofdpa_flow_tbl_do(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic struct ofdpa_group_tbl_entry *\r\nofdpa_group_tbl_find(const struct ofdpa *ofdpa,\r\nconst struct ofdpa_group_tbl_entry *match)\r\n{\r\nstruct ofdpa_group_tbl_entry *found;\r\nhash_for_each_possible(ofdpa->group_tbl, found,\r\nentry, match->group_id) {\r\nif (found->group_id == match->group_id)\r\nreturn found;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ofdpa_group_tbl_entry_free(struct switchdev_trans *trans,\r\nstruct ofdpa_group_tbl_entry *entry)\r\n{\r\nswitch (ROCKER_GROUP_TYPE_GET(entry->group_id)) {\r\ncase ROCKER_OF_DPA_GROUP_TYPE_L2_FLOOD:\r\ncase ROCKER_OF_DPA_GROUP_TYPE_L2_MCAST:\r\nofdpa_kfree(trans, entry->group_ids);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nofdpa_kfree(trans, entry);\r\n}\r\nstatic int ofdpa_group_tbl_add(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nstruct ofdpa_group_tbl_entry *match)\r\n{\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_group_tbl_entry *found;\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(&ofdpa->group_tbl_lock, lock_flags);\r\nfound = ofdpa_group_tbl_find(ofdpa, match);\r\nif (found) {\r\nif (!switchdev_trans_ph_prepare(trans))\r\nhash_del(&found->entry);\r\nofdpa_group_tbl_entry_free(trans, found);\r\nfound = match;\r\nfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_GROUP_MOD;\r\n} else {\r\nfound = match;\r\nfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_GROUP_ADD;\r\n}\r\nif (!switchdev_trans_ph_prepare(trans))\r\nhash_add(ofdpa->group_tbl, &found->entry, found->group_id);\r\nspin_unlock_irqrestore(&ofdpa->group_tbl_lock, lock_flags);\r\nif (!switchdev_trans_ph_prepare(trans))\r\nreturn rocker_cmd_exec(ofdpa_port->rocker_port,\r\nofdpa_flags_nowait(flags),\r\nofdpa_cmd_group_tbl_add,\r\nfound, NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic int ofdpa_group_tbl_del(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nstruct ofdpa_group_tbl_entry *match)\r\n{\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_group_tbl_entry *found;\r\nunsigned long lock_flags;\r\nint err = 0;\r\nspin_lock_irqsave(&ofdpa->group_tbl_lock, lock_flags);\r\nfound = ofdpa_group_tbl_find(ofdpa, match);\r\nif (found) {\r\nif (!switchdev_trans_ph_prepare(trans))\r\nhash_del(&found->entry);\r\nfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_GROUP_DEL;\r\n}\r\nspin_unlock_irqrestore(&ofdpa->group_tbl_lock, lock_flags);\r\nofdpa_group_tbl_entry_free(trans, match);\r\nif (found) {\r\nif (!switchdev_trans_ph_prepare(trans))\r\nerr = rocker_cmd_exec(ofdpa_port->rocker_port,\r\nofdpa_flags_nowait(flags),\r\nofdpa_cmd_group_tbl_del,\r\nfound, NULL, NULL);\r\nofdpa_group_tbl_entry_free(trans, found);\r\n}\r\nreturn err;\r\n}\r\nstatic int ofdpa_group_tbl_do(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nstruct ofdpa_group_tbl_entry *entry)\r\n{\r\nif (flags & OFDPA_OP_FLAG_REMOVE)\r\nreturn ofdpa_group_tbl_del(ofdpa_port, trans, flags, entry);\r\nelse\r\nreturn ofdpa_group_tbl_add(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic int ofdpa_group_l2_interface(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\n__be16 vlan_id, u32 out_pport,\r\nint pop_vlan)\r\n{\r\nstruct ofdpa_group_tbl_entry *entry;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->group_id = ROCKER_GROUP_L2_INTERFACE(vlan_id, out_pport);\r\nentry->l2_interface.pop_vlan = pop_vlan;\r\nreturn ofdpa_group_tbl_do(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic int ofdpa_group_l2_fan_out(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans,\r\nint flags, u8 group_count,\r\nconst u32 *group_ids, u32 group_id)\r\n{\r\nstruct ofdpa_group_tbl_entry *entry;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->group_id = group_id;\r\nentry->group_count = group_count;\r\nentry->group_ids = ofdpa_kcalloc(trans, flags,\r\ngroup_count, sizeof(u32));\r\nif (!entry->group_ids) {\r\nofdpa_kfree(trans, entry);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(entry->group_ids, group_ids, group_count * sizeof(u32));\r\nreturn ofdpa_group_tbl_do(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic int ofdpa_group_l2_flood(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\n__be16 vlan_id, u8 group_count,\r\nconst u32 *group_ids, u32 group_id)\r\n{\r\nreturn ofdpa_group_l2_fan_out(ofdpa_port, trans, flags,\r\ngroup_count, group_ids,\r\ngroup_id);\r\n}\r\nstatic int ofdpa_group_l3_unicast(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nu32 index, const u8 *src_mac, const u8 *dst_mac,\r\n__be16 vlan_id, bool ttl_check, u32 pport)\r\n{\r\nstruct ofdpa_group_tbl_entry *entry;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->group_id = ROCKER_GROUP_L3_UNICAST(index);\r\nif (src_mac)\r\nether_addr_copy(entry->l3_unicast.eth_src, src_mac);\r\nif (dst_mac)\r\nether_addr_copy(entry->l3_unicast.eth_dst, dst_mac);\r\nentry->l3_unicast.vlan_id = vlan_id;\r\nentry->l3_unicast.ttl_check = ttl_check;\r\nentry->l3_unicast.group_id = ROCKER_GROUP_L2_INTERFACE(vlan_id, pport);\r\nreturn ofdpa_group_tbl_do(ofdpa_port, trans, flags, entry);\r\n}\r\nstatic struct ofdpa_neigh_tbl_entry *\r\nofdpa_neigh_tbl_find(const struct ofdpa *ofdpa, __be32 ip_addr)\r\n{\r\nstruct ofdpa_neigh_tbl_entry *found;\r\nhash_for_each_possible(ofdpa->neigh_tbl, found,\r\nentry, be32_to_cpu(ip_addr))\r\nif (found->ip_addr == ip_addr)\r\nreturn found;\r\nreturn NULL;\r\n}\r\nstatic void ofdpa_neigh_add(struct ofdpa *ofdpa,\r\nstruct switchdev_trans *trans,\r\nstruct ofdpa_neigh_tbl_entry *entry)\r\n{\r\nif (!switchdev_trans_ph_commit(trans))\r\nentry->index = ofdpa->neigh_tbl_next_index++;\r\nif (switchdev_trans_ph_prepare(trans))\r\nreturn;\r\nentry->ref_count++;\r\nhash_add(ofdpa->neigh_tbl, &entry->entry,\r\nbe32_to_cpu(entry->ip_addr));\r\n}\r\nstatic void ofdpa_neigh_del(struct switchdev_trans *trans,\r\nstruct ofdpa_neigh_tbl_entry *entry)\r\n{\r\nif (switchdev_trans_ph_prepare(trans))\r\nreturn;\r\nif (--entry->ref_count == 0) {\r\nhash_del(&entry->entry);\r\nofdpa_kfree(trans, entry);\r\n}\r\n}\r\nstatic void ofdpa_neigh_update(struct ofdpa_neigh_tbl_entry *entry,\r\nstruct switchdev_trans *trans,\r\nconst u8 *eth_dst, bool ttl_check)\r\n{\r\nif (eth_dst) {\r\nether_addr_copy(entry->eth_dst, eth_dst);\r\nentry->ttl_check = ttl_check;\r\n} else if (!switchdev_trans_ph_prepare(trans)) {\r\nentry->ref_count++;\r\n}\r\n}\r\nstatic int ofdpa_port_ipv4_neigh(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans,\r\nint flags, __be32 ip_addr, const u8 *eth_dst)\r\n{\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_neigh_tbl_entry *entry;\r\nstruct ofdpa_neigh_tbl_entry *found;\r\nunsigned long lock_flags;\r\n__be16 eth_type = htons(ETH_P_IP);\r\nenum rocker_of_dpa_table_id goto_tbl =\r\nROCKER_OF_DPA_TABLE_ID_ACL_POLICY;\r\nu32 group_id;\r\nu32 priority = 0;\r\nbool adding = !(flags & OFDPA_OP_FLAG_REMOVE);\r\nbool updating;\r\nbool removing;\r\nint err = 0;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&ofdpa->neigh_tbl_lock, lock_flags);\r\nfound = ofdpa_neigh_tbl_find(ofdpa, ip_addr);\r\nupdating = found && adding;\r\nremoving = found && !adding;\r\nadding = !found && adding;\r\nif (adding) {\r\nentry->ip_addr = ip_addr;\r\nentry->dev = ofdpa_port->dev;\r\nether_addr_copy(entry->eth_dst, eth_dst);\r\nentry->ttl_check = true;\r\nofdpa_neigh_add(ofdpa, trans, entry);\r\n} else if (removing) {\r\nmemcpy(entry, found, sizeof(*entry));\r\nofdpa_neigh_del(trans, found);\r\n} else if (updating) {\r\nofdpa_neigh_update(found, trans, eth_dst, true);\r\nmemcpy(entry, found, sizeof(*entry));\r\n} else {\r\nerr = -ENOENT;\r\n}\r\nspin_unlock_irqrestore(&ofdpa->neigh_tbl_lock, lock_flags);\r\nif (err)\r\ngoto err_out;\r\nerr = ofdpa_group_l3_unicast(ofdpa_port, trans, flags,\r\nentry->index,\r\nofdpa_port->dev->dev_addr,\r\nentry->eth_dst,\r\nofdpa_port->internal_vlan_id,\r\nentry->ttl_check,\r\nofdpa_port->pport);\r\nif (err) {\r\nnetdev_err(ofdpa_port->dev, "Error (%d) L3 unicast group index %d\n",\r\nerr, entry->index);\r\ngoto err_out;\r\n}\r\nif (adding || removing) {\r\ngroup_id = ROCKER_GROUP_L3_UNICAST(entry->index);\r\nerr = ofdpa_flow_tbl_ucast4_routing(ofdpa_port, trans,\r\neth_type, ip_addr,\r\ninet_make_mask(32),\r\npriority, goto_tbl,\r\ngroup_id, flags);\r\nif (err)\r\nnetdev_err(ofdpa_port->dev, "Error (%d) /32 unicast route %pI4 group 0x%08x\n",\r\nerr, &entry->ip_addr, group_id);\r\n}\r\nerr_out:\r\nif (!adding)\r\nofdpa_kfree(trans, entry);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_ipv4_resolve(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans,\r\n__be32 ip_addr)\r\n{\r\nstruct net_device *dev = ofdpa_port->dev;\r\nstruct neighbour *n = __ipv4_neigh_lookup(dev, (__force u32)ip_addr);\r\nint err = 0;\r\nif (!n) {\r\nn = neigh_create(&arp_tbl, &ip_addr, dev);\r\nif (IS_ERR(n))\r\nreturn PTR_ERR(n);\r\n}\r\nif (n->nud_state & NUD_VALID)\r\nerr = ofdpa_port_ipv4_neigh(ofdpa_port, trans, 0,\r\nip_addr, n->ha);\r\nelse\r\nneigh_event_send(n, NULL);\r\nneigh_release(n);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_ipv4_nh(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\n__be32 ip_addr, u32 *index)\r\n{\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_neigh_tbl_entry *entry;\r\nstruct ofdpa_neigh_tbl_entry *found;\r\nunsigned long lock_flags;\r\nbool adding = !(flags & OFDPA_OP_FLAG_REMOVE);\r\nbool updating;\r\nbool removing;\r\nbool resolved = true;\r\nint err = 0;\r\nentry = ofdpa_kzalloc(trans, flags, sizeof(*entry));\r\nif (!entry)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&ofdpa->neigh_tbl_lock, lock_flags);\r\nfound = ofdpa_neigh_tbl_find(ofdpa, ip_addr);\r\nif (found)\r\n*index = found->index;\r\nupdating = found && adding;\r\nremoving = found && !adding;\r\nadding = !found && adding;\r\nif (adding) {\r\nentry->ip_addr = ip_addr;\r\nentry->dev = ofdpa_port->dev;\r\nofdpa_neigh_add(ofdpa, trans, entry);\r\n*index = entry->index;\r\nresolved = false;\r\n} else if (removing) {\r\nofdpa_neigh_del(trans, found);\r\n} else if (updating) {\r\nofdpa_neigh_update(found, trans, NULL, false);\r\nresolved = !is_zero_ether_addr(found->eth_dst);\r\n} else {\r\nerr = -ENOENT;\r\n}\r\nspin_unlock_irqrestore(&ofdpa->neigh_tbl_lock, lock_flags);\r\nif (!adding)\r\nofdpa_kfree(trans, entry);\r\nif (err)\r\nreturn err;\r\nif (!resolved)\r\nerr = ofdpa_port_ipv4_resolve(ofdpa_port, trans, ip_addr);\r\nreturn err;\r\n}\r\nstatic struct ofdpa_port *ofdpa_port_get(const struct ofdpa *ofdpa,\r\nint port_index)\r\n{\r\nstruct rocker_port *rocker_port;\r\nrocker_port = ofdpa->rocker->ports[port_index];\r\nreturn rocker_port ? rocker_port->wpriv : NULL;\r\n}\r\nstatic int ofdpa_port_vlan_flood_group(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans,\r\nint flags, __be16 vlan_id)\r\n{\r\nstruct ofdpa_port *p;\r\nconst struct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nunsigned int port_count = ofdpa->rocker->port_count;\r\nu32 group_id = ROCKER_GROUP_L2_FLOOD(vlan_id, 0);\r\nu32 *group_ids;\r\nu8 group_count = 0;\r\nint err = 0;\r\nint i;\r\ngroup_ids = ofdpa_kcalloc(trans, flags, port_count, sizeof(u32));\r\nif (!group_ids)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < port_count; i++) {\r\np = ofdpa_port_get(ofdpa, i);\r\nif (!p)\r\ncontinue;\r\nif (!ofdpa_port_is_bridged(p))\r\ncontinue;\r\nif (test_bit(ntohs(vlan_id), p->vlan_bitmap)) {\r\ngroup_ids[group_count++] =\r\nROCKER_GROUP_L2_INTERFACE(vlan_id, p->pport);\r\n}\r\n}\r\nif (group_count == 0)\r\ngoto no_ports_in_vlan;\r\nerr = ofdpa_group_l2_flood(ofdpa_port, trans, flags, vlan_id,\r\ngroup_count, group_ids, group_id);\r\nif (err)\r\nnetdev_err(ofdpa_port->dev, "Error (%d) port VLAN l2 flood group\n", err);\r\nno_ports_in_vlan:\r\nofdpa_kfree(trans, group_ids);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_vlan_l2_groups(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\n__be16 vlan_id, bool pop_vlan)\r\n{\r\nconst struct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nunsigned int port_count = ofdpa->rocker->port_count;\r\nstruct ofdpa_port *p;\r\nbool adding = !(flags & OFDPA_OP_FLAG_REMOVE);\r\nu32 out_pport;\r\nint ref = 0;\r\nint err;\r\nint i;\r\nif (ofdpa_port->stp_state == BR_STATE_LEARNING ||\r\nofdpa_port->stp_state == BR_STATE_FORWARDING) {\r\nout_pport = ofdpa_port->pport;\r\nerr = ofdpa_group_l2_interface(ofdpa_port, trans, flags,\r\nvlan_id, out_pport, pop_vlan);\r\nif (err) {\r\nnetdev_err(ofdpa_port->dev, "Error (%d) port VLAN l2 group for pport %d\n",\r\nerr, out_pport);\r\nreturn err;\r\n}\r\n}\r\nfor (i = 0; i < port_count; i++) {\r\np = ofdpa_port_get(ofdpa, i);\r\nif (p && test_bit(ntohs(vlan_id), p->vlan_bitmap))\r\nref++;\r\n}\r\nif ((!adding || ref != 1) && (adding || ref != 0))\r\nreturn 0;\r\nout_pport = 0;\r\nerr = ofdpa_group_l2_interface(ofdpa_port, trans, flags,\r\nvlan_id, out_pport, pop_vlan);\r\nif (err) {\r\nnetdev_err(ofdpa_port->dev, "Error (%d) port VLAN l2 group for CPU port\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ofdpa_port_ctrl_vlan_acl(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nconst struct ofdpa_ctrl *ctrl, __be16 vlan_id)\r\n{\r\nu32 in_pport = ofdpa_port->pport;\r\nu32 in_pport_mask = 0xffffffff;\r\nu32 out_pport = 0;\r\nconst u8 *eth_src = NULL;\r\nconst u8 *eth_src_mask = NULL;\r\n__be16 vlan_id_mask = htons(0xffff);\r\nu8 ip_proto = 0;\r\nu8 ip_proto_mask = 0;\r\nu8 ip_tos = 0;\r\nu8 ip_tos_mask = 0;\r\nu32 group_id = ROCKER_GROUP_L2_INTERFACE(vlan_id, out_pport);\r\nint err;\r\nerr = ofdpa_flow_tbl_acl(ofdpa_port, trans, flags,\r\nin_pport, in_pport_mask,\r\neth_src, eth_src_mask,\r\nctrl->eth_dst, ctrl->eth_dst_mask,\r\nctrl->eth_type,\r\nvlan_id, vlan_id_mask,\r\nip_proto, ip_proto_mask,\r\nip_tos, ip_tos_mask,\r\ngroup_id);\r\nif (err)\r\nnetdev_err(ofdpa_port->dev, "Error (%d) ctrl ACL\n", err);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_ctrl_vlan_bridge(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans,\r\nint flags,\r\nconst struct ofdpa_ctrl *ctrl,\r\n__be16 vlan_id)\r\n{\r\nenum rocker_of_dpa_table_id goto_tbl =\r\nROCKER_OF_DPA_TABLE_ID_ACL_POLICY;\r\nu32 group_id = ROCKER_GROUP_L2_FLOOD(vlan_id, 0);\r\nu32 tunnel_id = 0;\r\nint err;\r\nif (!ofdpa_port_is_bridged(ofdpa_port))\r\nreturn 0;\r\nerr = ofdpa_flow_tbl_bridge(ofdpa_port, trans, flags,\r\nctrl->eth_dst, ctrl->eth_dst_mask,\r\nvlan_id, tunnel_id,\r\ngoto_tbl, group_id, ctrl->copy_to_cpu);\r\nif (err)\r\nnetdev_err(ofdpa_port->dev, "Error (%d) ctrl FLOOD\n", err);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_ctrl_vlan_term(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nconst struct ofdpa_ctrl *ctrl, __be16 vlan_id)\r\n{\r\nu32 in_pport_mask = 0xffffffff;\r\n__be16 vlan_id_mask = htons(0xffff);\r\nint err;\r\nif (ntohs(vlan_id) == 0)\r\nvlan_id = ofdpa_port->internal_vlan_id;\r\nerr = ofdpa_flow_tbl_term_mac(ofdpa_port, trans,\r\nofdpa_port->pport, in_pport_mask,\r\nctrl->eth_type, ctrl->eth_dst,\r\nctrl->eth_dst_mask, vlan_id,\r\nvlan_id_mask, ctrl->copy_to_cpu,\r\nflags);\r\nif (err)\r\nnetdev_err(ofdpa_port->dev, "Error (%d) ctrl term\n", err);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_ctrl_vlan(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nconst struct ofdpa_ctrl *ctrl, __be16 vlan_id)\r\n{\r\nif (ctrl->acl)\r\nreturn ofdpa_port_ctrl_vlan_acl(ofdpa_port, trans, flags,\r\nctrl, vlan_id);\r\nif (ctrl->bridge)\r\nreturn ofdpa_port_ctrl_vlan_bridge(ofdpa_port, trans, flags,\r\nctrl, vlan_id);\r\nif (ctrl->term)\r\nreturn ofdpa_port_ctrl_vlan_term(ofdpa_port, trans, flags,\r\nctrl, vlan_id);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int ofdpa_port_ctrl_vlan_add(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\n__be16 vlan_id)\r\n{\r\nint err = 0;\r\nint i;\r\nfor (i = 0; i < OFDPA_CTRL_MAX; i++) {\r\nif (ofdpa_port->ctrls[i]) {\r\nerr = ofdpa_port_ctrl_vlan(ofdpa_port, trans, flags,\r\n&ofdpa_ctrls[i], vlan_id);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_ctrl(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nconst struct ofdpa_ctrl *ctrl)\r\n{\r\nu16 vid;\r\nint err = 0;\r\nfor (vid = 1; vid < VLAN_N_VID; vid++) {\r\nif (!test_bit(vid, ofdpa_port->vlan_bitmap))\r\ncontinue;\r\nerr = ofdpa_port_ctrl_vlan(ofdpa_port, trans, flags,\r\nctrl, htons(vid));\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_vlan(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags, u16 vid)\r\n{\r\nenum rocker_of_dpa_table_id goto_tbl =\r\nROCKER_OF_DPA_TABLE_ID_TERMINATION_MAC;\r\nu32 in_pport = ofdpa_port->pport;\r\n__be16 vlan_id = htons(vid);\r\n__be16 vlan_id_mask = htons(0xffff);\r\n__be16 internal_vlan_id;\r\nbool untagged;\r\nbool adding = !(flags & OFDPA_OP_FLAG_REMOVE);\r\nint err;\r\ninternal_vlan_id = ofdpa_port_vid_to_vlan(ofdpa_port, vid, &untagged);\r\nif (adding &&\r\ntest_bit(ntohs(internal_vlan_id), ofdpa_port->vlan_bitmap))\r\nreturn 0;\r\nelse if (!adding &&\r\n!test_bit(ntohs(internal_vlan_id), ofdpa_port->vlan_bitmap))\r\nreturn 0;\r\nchange_bit(ntohs(internal_vlan_id), ofdpa_port->vlan_bitmap);\r\nif (adding) {\r\nerr = ofdpa_port_ctrl_vlan_add(ofdpa_port, trans, flags,\r\ninternal_vlan_id);\r\nif (err) {\r\nnetdev_err(ofdpa_port->dev, "Error (%d) port ctrl vlan add\n", err);\r\ngoto err_out;\r\n}\r\n}\r\nerr = ofdpa_port_vlan_l2_groups(ofdpa_port, trans, flags,\r\ninternal_vlan_id, untagged);\r\nif (err) {\r\nnetdev_err(ofdpa_port->dev, "Error (%d) port VLAN l2 groups\n", err);\r\ngoto err_out;\r\n}\r\nerr = ofdpa_port_vlan_flood_group(ofdpa_port, trans, flags,\r\ninternal_vlan_id);\r\nif (err) {\r\nnetdev_err(ofdpa_port->dev, "Error (%d) port VLAN l2 flood group\n", err);\r\ngoto err_out;\r\n}\r\nerr = ofdpa_flow_tbl_vlan(ofdpa_port, trans, flags,\r\nin_pport, vlan_id, vlan_id_mask,\r\ngoto_tbl, untagged, internal_vlan_id);\r\nif (err)\r\nnetdev_err(ofdpa_port->dev, "Error (%d) port VLAN table\n", err);\r\nerr_out:\r\nif (switchdev_trans_ph_prepare(trans))\r\nchange_bit(ntohs(internal_vlan_id), ofdpa_port->vlan_bitmap);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_ig_tbl(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags)\r\n{\r\nenum rocker_of_dpa_table_id goto_tbl;\r\nu32 in_pport;\r\nu32 in_pport_mask;\r\nint err;\r\nin_pport = 0;\r\nin_pport_mask = 0xffff0000;\r\ngoto_tbl = ROCKER_OF_DPA_TABLE_ID_VLAN;\r\nerr = ofdpa_flow_tbl_ig_port(ofdpa_port, trans, flags,\r\nin_pport, in_pport_mask,\r\ngoto_tbl);\r\nif (err)\r\nnetdev_err(ofdpa_port->dev, "Error (%d) ingress port table entry\n", err);\r\nreturn err;\r\n}\r\nstatic void ofdpa_port_fdb_learn_work(struct work_struct *work)\r\n{\r\nconst struct ofdpa_fdb_learn_work *lw =\r\ncontainer_of(work, struct ofdpa_fdb_learn_work, work);\r\nbool removing = (lw->flags & OFDPA_OP_FLAG_REMOVE);\r\nbool learned = (lw->flags & OFDPA_OP_FLAG_LEARNED);\r\nstruct switchdev_notifier_fdb_info info;\r\ninfo.addr = lw->addr;\r\ninfo.vid = lw->vid;\r\nrtnl_lock();\r\nif (learned && removing)\r\ncall_switchdev_notifiers(SWITCHDEV_FDB_DEL,\r\nlw->ofdpa_port->dev, &info.info);\r\nelse if (learned && !removing)\r\ncall_switchdev_notifiers(SWITCHDEV_FDB_ADD,\r\nlw->ofdpa_port->dev, &info.info);\r\nrtnl_unlock();\r\nofdpa_kfree(lw->trans, work);\r\n}\r\nstatic int ofdpa_port_fdb_learn(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\nconst u8 *addr, __be16 vlan_id)\r\n{\r\nstruct ofdpa_fdb_learn_work *lw;\r\nenum rocker_of_dpa_table_id goto_tbl =\r\nROCKER_OF_DPA_TABLE_ID_ACL_POLICY;\r\nu32 out_pport = ofdpa_port->pport;\r\nu32 tunnel_id = 0;\r\nu32 group_id = ROCKER_GROUP_NONE;\r\nbool syncing = !!(ofdpa_port->brport_flags & BR_LEARNING_SYNC);\r\nbool copy_to_cpu = false;\r\nint err;\r\nif (ofdpa_port_is_bridged(ofdpa_port))\r\ngroup_id = ROCKER_GROUP_L2_INTERFACE(vlan_id, out_pport);\r\nif (!(flags & OFDPA_OP_FLAG_REFRESH)) {\r\nerr = ofdpa_flow_tbl_bridge(ofdpa_port, trans, flags, addr,\r\nNULL, vlan_id, tunnel_id, goto_tbl,\r\ngroup_id, copy_to_cpu);\r\nif (err)\r\nreturn err;\r\n}\r\nif (!syncing)\r\nreturn 0;\r\nif (!ofdpa_port_is_bridged(ofdpa_port))\r\nreturn 0;\r\nlw = ofdpa_kzalloc(trans, flags, sizeof(*lw));\r\nif (!lw)\r\nreturn -ENOMEM;\r\nINIT_WORK(&lw->work, ofdpa_port_fdb_learn_work);\r\nlw->ofdpa_port = ofdpa_port;\r\nlw->trans = trans;\r\nlw->flags = flags;\r\nether_addr_copy(lw->addr, addr);\r\nlw->vid = ofdpa_port_vlan_to_vid(ofdpa_port, vlan_id);\r\nif (switchdev_trans_ph_prepare(trans))\r\nofdpa_kfree(trans, lw);\r\nelse\r\nschedule_work(&lw->work);\r\nreturn 0;\r\n}\r\nstatic struct ofdpa_fdb_tbl_entry *\r\nofdpa_fdb_tbl_find(const struct ofdpa *ofdpa,\r\nconst struct ofdpa_fdb_tbl_entry *match)\r\n{\r\nstruct ofdpa_fdb_tbl_entry *found;\r\nhash_for_each_possible(ofdpa->fdb_tbl, found, entry, match->key_crc32)\r\nif (memcmp(&found->key, &match->key, sizeof(found->key)) == 0)\r\nreturn found;\r\nreturn NULL;\r\n}\r\nstatic int ofdpa_port_fdb(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans,\r\nconst unsigned char *addr,\r\n__be16 vlan_id, int flags)\r\n{\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_fdb_tbl_entry *fdb;\r\nstruct ofdpa_fdb_tbl_entry *found;\r\nbool removing = (flags & OFDPA_OP_FLAG_REMOVE);\r\nunsigned long lock_flags;\r\nfdb = ofdpa_kzalloc(trans, flags, sizeof(*fdb));\r\nif (!fdb)\r\nreturn -ENOMEM;\r\nfdb->learned = (flags & OFDPA_OP_FLAG_LEARNED);\r\nfdb->touched = jiffies;\r\nfdb->key.ofdpa_port = ofdpa_port;\r\nether_addr_copy(fdb->key.addr, addr);\r\nfdb->key.vlan_id = vlan_id;\r\nfdb->key_crc32 = crc32(~0, &fdb->key, sizeof(fdb->key));\r\nspin_lock_irqsave(&ofdpa->fdb_tbl_lock, lock_flags);\r\nfound = ofdpa_fdb_tbl_find(ofdpa, fdb);\r\nif (found) {\r\nfound->touched = jiffies;\r\nif (removing) {\r\nofdpa_kfree(trans, fdb);\r\nif (!switchdev_trans_ph_prepare(trans))\r\nhash_del(&found->entry);\r\n}\r\n} else if (!removing) {\r\nif (!switchdev_trans_ph_prepare(trans))\r\nhash_add(ofdpa->fdb_tbl, &fdb->entry,\r\nfdb->key_crc32);\r\n}\r\nspin_unlock_irqrestore(&ofdpa->fdb_tbl_lock, lock_flags);\r\nif (!found != !removing) {\r\nofdpa_kfree(trans, fdb);\r\nif (!found && removing)\r\nreturn 0;\r\nflags |= OFDPA_OP_FLAG_REFRESH;\r\n}\r\nreturn ofdpa_port_fdb_learn(ofdpa_port, trans, flags, addr, vlan_id);\r\n}\r\nstatic int ofdpa_port_fdb_flush(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags)\r\n{\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_fdb_tbl_entry *found;\r\nunsigned long lock_flags;\r\nstruct hlist_node *tmp;\r\nint bkt;\r\nint err = 0;\r\nif (ofdpa_port->stp_state == BR_STATE_LEARNING ||\r\nofdpa_port->stp_state == BR_STATE_FORWARDING)\r\nreturn 0;\r\nflags |= OFDPA_OP_FLAG_NOWAIT | OFDPA_OP_FLAG_REMOVE;\r\nspin_lock_irqsave(&ofdpa->fdb_tbl_lock, lock_flags);\r\nhash_for_each_safe(ofdpa->fdb_tbl, bkt, tmp, found, entry) {\r\nif (found->key.ofdpa_port != ofdpa_port)\r\ncontinue;\r\nif (!found->learned)\r\ncontinue;\r\nerr = ofdpa_port_fdb_learn(ofdpa_port, trans, flags,\r\nfound->key.addr,\r\nfound->key.vlan_id);\r\nif (err)\r\ngoto err_out;\r\nif (!switchdev_trans_ph_prepare(trans))\r\nhash_del(&found->entry);\r\n}\r\nerr_out:\r\nspin_unlock_irqrestore(&ofdpa->fdb_tbl_lock, lock_flags);\r\nreturn err;\r\n}\r\nstatic void ofdpa_fdb_cleanup(unsigned long data)\r\n{\r\nstruct ofdpa *ofdpa = (struct ofdpa *)data;\r\nstruct ofdpa_port *ofdpa_port;\r\nstruct ofdpa_fdb_tbl_entry *entry;\r\nstruct hlist_node *tmp;\r\nunsigned long next_timer = jiffies + ofdpa->ageing_time;\r\nunsigned long expires;\r\nunsigned long lock_flags;\r\nint flags = OFDPA_OP_FLAG_NOWAIT | OFDPA_OP_FLAG_REMOVE |\r\nOFDPA_OP_FLAG_LEARNED;\r\nint bkt;\r\nspin_lock_irqsave(&ofdpa->fdb_tbl_lock, lock_flags);\r\nhash_for_each_safe(ofdpa->fdb_tbl, bkt, tmp, entry, entry) {\r\nif (!entry->learned)\r\ncontinue;\r\nofdpa_port = entry->key.ofdpa_port;\r\nexpires = entry->touched + ofdpa_port->ageing_time;\r\nif (time_before_eq(expires, jiffies)) {\r\nofdpa_port_fdb_learn(ofdpa_port, NULL,\r\nflags, entry->key.addr,\r\nentry->key.vlan_id);\r\nhash_del(&entry->entry);\r\n} else if (time_before(expires, next_timer)) {\r\nnext_timer = expires;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ofdpa->fdb_tbl_lock, lock_flags);\r\nmod_timer(&ofdpa->fdb_cleanup_timer, round_jiffies_up(next_timer));\r\n}\r\nstatic int ofdpa_port_router_mac(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags,\r\n__be16 vlan_id)\r\n{\r\nu32 in_pport_mask = 0xffffffff;\r\n__be16 eth_type;\r\nconst u8 *dst_mac_mask = ff_mac;\r\n__be16 vlan_id_mask = htons(0xffff);\r\nbool copy_to_cpu = false;\r\nint err;\r\nif (ntohs(vlan_id) == 0)\r\nvlan_id = ofdpa_port->internal_vlan_id;\r\neth_type = htons(ETH_P_IP);\r\nerr = ofdpa_flow_tbl_term_mac(ofdpa_port, trans,\r\nofdpa_port->pport, in_pport_mask,\r\neth_type, ofdpa_port->dev->dev_addr,\r\ndst_mac_mask, vlan_id, vlan_id_mask,\r\ncopy_to_cpu, flags);\r\nif (err)\r\nreturn err;\r\neth_type = htons(ETH_P_IPV6);\r\nerr = ofdpa_flow_tbl_term_mac(ofdpa_port, trans,\r\nofdpa_port->pport, in_pport_mask,\r\neth_type, ofdpa_port->dev->dev_addr,\r\ndst_mac_mask, vlan_id, vlan_id_mask,\r\ncopy_to_cpu, flags);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_fwding(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, int flags)\r\n{\r\nbool pop_vlan;\r\nu32 out_pport;\r\n__be16 vlan_id;\r\nu16 vid;\r\nint err;\r\nif (ofdpa_port->stp_state != BR_STATE_LEARNING &&\r\nofdpa_port->stp_state != BR_STATE_FORWARDING)\r\nflags |= OFDPA_OP_FLAG_REMOVE;\r\nout_pport = ofdpa_port->pport;\r\nfor (vid = 1; vid < VLAN_N_VID; vid++) {\r\nif (!test_bit(vid, ofdpa_port->vlan_bitmap))\r\ncontinue;\r\nvlan_id = htons(vid);\r\npop_vlan = ofdpa_vlan_id_is_internal(vlan_id);\r\nerr = ofdpa_group_l2_interface(ofdpa_port, trans, flags,\r\nvlan_id, out_pport, pop_vlan);\r\nif (err) {\r\nnetdev_err(ofdpa_port->dev, "Error (%d) port VLAN l2 group for pport %d\n",\r\nerr, out_pport);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ofdpa_port_stp_update(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans,\r\nint flags, u8 state)\r\n{\r\nbool want[OFDPA_CTRL_MAX] = { 0, };\r\nbool prev_ctrls[OFDPA_CTRL_MAX];\r\nu8 uninitialized_var(prev_state);\r\nint err;\r\nint i;\r\nif (switchdev_trans_ph_prepare(trans)) {\r\nmemcpy(prev_ctrls, ofdpa_port->ctrls, sizeof(prev_ctrls));\r\nprev_state = ofdpa_port->stp_state;\r\n}\r\nif (ofdpa_port->stp_state == state)\r\nreturn 0;\r\nofdpa_port->stp_state = state;\r\nswitch (state) {\r\ncase BR_STATE_DISABLED:\r\nbreak;\r\ncase BR_STATE_LISTENING:\r\ncase BR_STATE_BLOCKING:\r\nwant[OFDPA_CTRL_LINK_LOCAL_MCAST] = true;\r\nbreak;\r\ncase BR_STATE_LEARNING:\r\ncase BR_STATE_FORWARDING:\r\nif (!ofdpa_port_is_ovsed(ofdpa_port))\r\nwant[OFDPA_CTRL_LINK_LOCAL_MCAST] = true;\r\nwant[OFDPA_CTRL_IPV4_MCAST] = true;\r\nwant[OFDPA_CTRL_IPV6_MCAST] = true;\r\nif (ofdpa_port_is_bridged(ofdpa_port))\r\nwant[OFDPA_CTRL_DFLT_BRIDGING] = true;\r\nelse if (ofdpa_port_is_ovsed(ofdpa_port))\r\nwant[OFDPA_CTRL_DFLT_OVS] = true;\r\nelse\r\nwant[OFDPA_CTRL_LOCAL_ARP] = true;\r\nbreak;\r\n}\r\nfor (i = 0; i < OFDPA_CTRL_MAX; i++) {\r\nif (want[i] != ofdpa_port->ctrls[i]) {\r\nint ctrl_flags = flags |\r\n(want[i] ? 0 : OFDPA_OP_FLAG_REMOVE);\r\nerr = ofdpa_port_ctrl(ofdpa_port, trans, ctrl_flags,\r\n&ofdpa_ctrls[i]);\r\nif (err)\r\ngoto err_out;\r\nofdpa_port->ctrls[i] = want[i];\r\n}\r\n}\r\nerr = ofdpa_port_fdb_flush(ofdpa_port, trans, flags);\r\nif (err)\r\ngoto err_out;\r\nerr = ofdpa_port_fwding(ofdpa_port, trans, flags);\r\nerr_out:\r\nif (switchdev_trans_ph_prepare(trans)) {\r\nmemcpy(ofdpa_port->ctrls, prev_ctrls, sizeof(prev_ctrls));\r\nofdpa_port->stp_state = prev_state;\r\n}\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_fwd_enable(struct ofdpa_port *ofdpa_port, int flags)\r\n{\r\nif (ofdpa_port_is_bridged(ofdpa_port))\r\nreturn 0;\r\nreturn ofdpa_port_stp_update(ofdpa_port, NULL, flags,\r\nBR_STATE_FORWARDING);\r\n}\r\nstatic int ofdpa_port_fwd_disable(struct ofdpa_port *ofdpa_port, int flags)\r\n{\r\nif (ofdpa_port_is_bridged(ofdpa_port))\r\nreturn 0;\r\nreturn ofdpa_port_stp_update(ofdpa_port, NULL, flags,\r\nBR_STATE_DISABLED);\r\n}\r\nstatic int ofdpa_port_vlan_add(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans,\r\nu16 vid, u16 flags)\r\n{\r\nint err;\r\nerr = ofdpa_port_vlan(ofdpa_port, trans, 0, vid);\r\nif (err)\r\nreturn err;\r\nerr = ofdpa_port_router_mac(ofdpa_port, trans, 0, htons(vid));\r\nif (err)\r\nofdpa_port_vlan(ofdpa_port, trans,\r\nOFDPA_OP_FLAG_REMOVE, vid);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_vlan_del(struct ofdpa_port *ofdpa_port,\r\nu16 vid, u16 flags)\r\n{\r\nint err;\r\nerr = ofdpa_port_router_mac(ofdpa_port, NULL,\r\nOFDPA_OP_FLAG_REMOVE, htons(vid));\r\nif (err)\r\nreturn err;\r\nreturn ofdpa_port_vlan(ofdpa_port, NULL,\r\nOFDPA_OP_FLAG_REMOVE, vid);\r\n}\r\nstatic struct ofdpa_internal_vlan_tbl_entry *\r\nofdpa_internal_vlan_tbl_find(const struct ofdpa *ofdpa, int ifindex)\r\n{\r\nstruct ofdpa_internal_vlan_tbl_entry *found;\r\nhash_for_each_possible(ofdpa->internal_vlan_tbl, found,\r\nentry, ifindex) {\r\nif (found->ifindex == ifindex)\r\nreturn found;\r\n}\r\nreturn NULL;\r\n}\r\nstatic __be16 ofdpa_port_internal_vlan_id_get(struct ofdpa_port *ofdpa_port,\r\nint ifindex)\r\n{\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_internal_vlan_tbl_entry *entry;\r\nstruct ofdpa_internal_vlan_tbl_entry *found;\r\nunsigned long lock_flags;\r\nint i;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn 0;\r\nentry->ifindex = ifindex;\r\nspin_lock_irqsave(&ofdpa->internal_vlan_tbl_lock, lock_flags);\r\nfound = ofdpa_internal_vlan_tbl_find(ofdpa, ifindex);\r\nif (found) {\r\nkfree(entry);\r\ngoto found;\r\n}\r\nfound = entry;\r\nhash_add(ofdpa->internal_vlan_tbl, &found->entry, found->ifindex);\r\nfor (i = 0; i < OFDPA_N_INTERNAL_VLANS; i++) {\r\nif (test_and_set_bit(i, ofdpa->internal_vlan_bitmap))\r\ncontinue;\r\nfound->vlan_id = htons(OFDPA_INTERNAL_VLAN_ID_BASE + i);\r\ngoto found;\r\n}\r\nnetdev_err(ofdpa_port->dev, "Out of internal VLAN IDs\n");\r\nfound:\r\nfound->ref_count++;\r\nspin_unlock_irqrestore(&ofdpa->internal_vlan_tbl_lock, lock_flags);\r\nreturn found->vlan_id;\r\n}\r\nstatic int ofdpa_port_fib_ipv4(struct ofdpa_port *ofdpa_port,\r\nstruct switchdev_trans *trans, __be32 dst,\r\nint dst_len, const struct fib_info *fi,\r\nu32 tb_id, int flags)\r\n{\r\nconst struct fib_nh *nh;\r\n__be16 eth_type = htons(ETH_P_IP);\r\n__be32 dst_mask = inet_make_mask(dst_len);\r\n__be16 internal_vlan_id = ofdpa_port->internal_vlan_id;\r\nu32 priority = fi->fib_priority;\r\nenum rocker_of_dpa_table_id goto_tbl =\r\nROCKER_OF_DPA_TABLE_ID_ACL_POLICY;\r\nu32 group_id;\r\nbool nh_on_port;\r\nbool has_gw;\r\nu32 index;\r\nint err;\r\nnh = fi->fib_nh;\r\nnh_on_port = (fi->fib_dev == ofdpa_port->dev);\r\nhas_gw = !!nh->nh_gw;\r\nif (has_gw && nh_on_port) {\r\nerr = ofdpa_port_ipv4_nh(ofdpa_port, trans, flags,\r\nnh->nh_gw, &index);\r\nif (err)\r\nreturn err;\r\ngroup_id = ROCKER_GROUP_L3_UNICAST(index);\r\n} else {\r\ngroup_id = ROCKER_GROUP_L2_INTERFACE(internal_vlan_id, 0);\r\n}\r\nerr = ofdpa_flow_tbl_ucast4_routing(ofdpa_port, trans, eth_type, dst,\r\ndst_mask, priority, goto_tbl,\r\ngroup_id, flags);\r\nif (err)\r\nnetdev_err(ofdpa_port->dev, "Error (%d) IPv4 route %pI4\n",\r\nerr, &dst);\r\nreturn err;\r\n}\r\nstatic void\r\nofdpa_port_internal_vlan_id_put(const struct ofdpa_port *ofdpa_port,\r\nint ifindex)\r\n{\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_internal_vlan_tbl_entry *found;\r\nunsigned long lock_flags;\r\nunsigned long bit;\r\nspin_lock_irqsave(&ofdpa->internal_vlan_tbl_lock, lock_flags);\r\nfound = ofdpa_internal_vlan_tbl_find(ofdpa, ifindex);\r\nif (!found) {\r\nnetdev_err(ofdpa_port->dev,\r\n"ifindex (%d) not found in internal VLAN tbl\n",\r\nifindex);\r\ngoto not_found;\r\n}\r\nif (--found->ref_count <= 0) {\r\nbit = ntohs(found->vlan_id) - OFDPA_INTERNAL_VLAN_ID_BASE;\r\nclear_bit(bit, ofdpa->internal_vlan_bitmap);\r\nhash_del(&found->entry);\r\nkfree(found);\r\n}\r\nnot_found:\r\nspin_unlock_irqrestore(&ofdpa->internal_vlan_tbl_lock, lock_flags);\r\n}\r\nstatic int ofdpa_init(struct rocker *rocker)\r\n{\r\nstruct ofdpa *ofdpa = rocker->wpriv;\r\nofdpa->rocker = rocker;\r\nhash_init(ofdpa->flow_tbl);\r\nspin_lock_init(&ofdpa->flow_tbl_lock);\r\nhash_init(ofdpa->group_tbl);\r\nspin_lock_init(&ofdpa->group_tbl_lock);\r\nhash_init(ofdpa->fdb_tbl);\r\nspin_lock_init(&ofdpa->fdb_tbl_lock);\r\nhash_init(ofdpa->internal_vlan_tbl);\r\nspin_lock_init(&ofdpa->internal_vlan_tbl_lock);\r\nhash_init(ofdpa->neigh_tbl);\r\nspin_lock_init(&ofdpa->neigh_tbl_lock);\r\nsetup_timer(&ofdpa->fdb_cleanup_timer, ofdpa_fdb_cleanup,\r\n(unsigned long) ofdpa);\r\nmod_timer(&ofdpa->fdb_cleanup_timer, jiffies);\r\nofdpa->ageing_time = BR_DEFAULT_AGEING_TIME;\r\nreturn 0;\r\n}\r\nstatic void ofdpa_fini(struct rocker *rocker)\r\n{\r\nstruct ofdpa *ofdpa = rocker->wpriv;\r\nunsigned long flags;\r\nstruct ofdpa_flow_tbl_entry *flow_entry;\r\nstruct ofdpa_group_tbl_entry *group_entry;\r\nstruct ofdpa_fdb_tbl_entry *fdb_entry;\r\nstruct ofdpa_internal_vlan_tbl_entry *internal_vlan_entry;\r\nstruct ofdpa_neigh_tbl_entry *neigh_entry;\r\nstruct hlist_node *tmp;\r\nint bkt;\r\ndel_timer_sync(&ofdpa->fdb_cleanup_timer);\r\nspin_lock_irqsave(&ofdpa->flow_tbl_lock, flags);\r\nhash_for_each_safe(ofdpa->flow_tbl, bkt, tmp, flow_entry, entry)\r\nhash_del(&flow_entry->entry);\r\nspin_unlock_irqrestore(&ofdpa->flow_tbl_lock, flags);\r\nspin_lock_irqsave(&ofdpa->group_tbl_lock, flags);\r\nhash_for_each_safe(ofdpa->group_tbl, bkt, tmp, group_entry, entry)\r\nhash_del(&group_entry->entry);\r\nspin_unlock_irqrestore(&ofdpa->group_tbl_lock, flags);\r\nspin_lock_irqsave(&ofdpa->fdb_tbl_lock, flags);\r\nhash_for_each_safe(ofdpa->fdb_tbl, bkt, tmp, fdb_entry, entry)\r\nhash_del(&fdb_entry->entry);\r\nspin_unlock_irqrestore(&ofdpa->fdb_tbl_lock, flags);\r\nspin_lock_irqsave(&ofdpa->internal_vlan_tbl_lock, flags);\r\nhash_for_each_safe(ofdpa->internal_vlan_tbl, bkt,\r\ntmp, internal_vlan_entry, entry)\r\nhash_del(&internal_vlan_entry->entry);\r\nspin_unlock_irqrestore(&ofdpa->internal_vlan_tbl_lock, flags);\r\nspin_lock_irqsave(&ofdpa->neigh_tbl_lock, flags);\r\nhash_for_each_safe(ofdpa->neigh_tbl, bkt, tmp, neigh_entry, entry)\r\nhash_del(&neigh_entry->entry);\r\nspin_unlock_irqrestore(&ofdpa->neigh_tbl_lock, flags);\r\n}\r\nstatic int ofdpa_port_pre_init(struct rocker_port *rocker_port)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nofdpa_port->ofdpa = rocker_port->rocker->wpriv;\r\nofdpa_port->rocker_port = rocker_port;\r\nofdpa_port->dev = rocker_port->dev;\r\nofdpa_port->pport = rocker_port->pport;\r\nofdpa_port->brport_flags = BR_LEARNING | BR_LEARNING_SYNC;\r\nofdpa_port->ageing_time = BR_DEFAULT_AGEING_TIME;\r\nreturn 0;\r\n}\r\nstatic int ofdpa_port_init(struct rocker_port *rocker_port)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nint err;\r\nswitchdev_port_fwd_mark_set(ofdpa_port->dev, NULL, false);\r\nrocker_port_set_learning(rocker_port,\r\n!!(ofdpa_port->brport_flags & BR_LEARNING));\r\nerr = ofdpa_port_ig_tbl(ofdpa_port, NULL, 0);\r\nif (err) {\r\nnetdev_err(ofdpa_port->dev, "install ig port table failed\n");\r\nreturn err;\r\n}\r\nofdpa_port->internal_vlan_id =\r\nofdpa_port_internal_vlan_id_get(ofdpa_port,\r\nofdpa_port->dev->ifindex);\r\nerr = ofdpa_port_vlan_add(ofdpa_port, NULL, OFDPA_UNTAGGED_VID, 0);\r\nif (err) {\r\nnetdev_err(ofdpa_port->dev, "install untagged VLAN failed\n");\r\ngoto err_untagged_vlan;\r\n}\r\nreturn 0;\r\nerr_untagged_vlan:\r\nofdpa_port_ig_tbl(ofdpa_port, NULL, OFDPA_OP_FLAG_REMOVE);\r\nreturn err;\r\n}\r\nstatic void ofdpa_port_fini(struct rocker_port *rocker_port)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nofdpa_port_ig_tbl(ofdpa_port, NULL, OFDPA_OP_FLAG_REMOVE);\r\n}\r\nstatic int ofdpa_port_open(struct rocker_port *rocker_port)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nreturn ofdpa_port_fwd_enable(ofdpa_port, 0);\r\n}\r\nstatic void ofdpa_port_stop(struct rocker_port *rocker_port)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nofdpa_port_fwd_disable(ofdpa_port, OFDPA_OP_FLAG_NOWAIT);\r\n}\r\nstatic int ofdpa_port_attr_stp_state_set(struct rocker_port *rocker_port,\r\nu8 state,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nreturn ofdpa_port_stp_update(ofdpa_port, trans, 0, state);\r\n}\r\nstatic int ofdpa_port_attr_bridge_flags_set(struct rocker_port *rocker_port,\r\nunsigned long brport_flags,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nunsigned long orig_flags;\r\nint err = 0;\r\norig_flags = ofdpa_port->brport_flags;\r\nofdpa_port->brport_flags = brport_flags;\r\nif ((orig_flags ^ ofdpa_port->brport_flags) & BR_LEARNING &&\r\n!switchdev_trans_ph_prepare(trans))\r\nerr = rocker_port_set_learning(ofdpa_port->rocker_port,\r\n!!(ofdpa_port->brport_flags & BR_LEARNING));\r\nif (switchdev_trans_ph_prepare(trans))\r\nofdpa_port->brport_flags = orig_flags;\r\nreturn err;\r\n}\r\nstatic int\r\nofdpa_port_attr_bridge_flags_get(const struct rocker_port *rocker_port,\r\nunsigned long *p_brport_flags)\r\n{\r\nconst struct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\n*p_brport_flags = ofdpa_port->brport_flags;\r\nreturn 0;\r\n}\r\nstatic int\r\nofdpa_port_attr_bridge_ageing_time_set(struct rocker_port *rocker_port,\r\nu32 ageing_time,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nif (!switchdev_trans_ph_prepare(trans)) {\r\nofdpa_port->ageing_time = clock_t_to_jiffies(ageing_time);\r\nif (ofdpa_port->ageing_time < ofdpa->ageing_time)\r\nofdpa->ageing_time = ofdpa_port->ageing_time;\r\nmod_timer(&ofdpa_port->ofdpa->fdb_cleanup_timer, jiffies);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ofdpa_port_obj_vlan_add(struct rocker_port *rocker_port,\r\nconst struct switchdev_obj_port_vlan *vlan,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nu16 vid;\r\nint err;\r\nfor (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++) {\r\nerr = ofdpa_port_vlan_add(ofdpa_port, trans, vid, vlan->flags);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ofdpa_port_obj_vlan_del(struct rocker_port *rocker_port,\r\nconst struct switchdev_obj_port_vlan *vlan)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nu16 vid;\r\nint err;\r\nfor (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++) {\r\nerr = ofdpa_port_vlan_del(ofdpa_port, vid, vlan->flags);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ofdpa_port_obj_vlan_dump(const struct rocker_port *rocker_port,\r\nstruct switchdev_obj_port_vlan *vlan,\r\nswitchdev_obj_dump_cb_t *cb)\r\n{\r\nconst struct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nu16 vid;\r\nint err = 0;\r\nfor (vid = 1; vid < VLAN_N_VID; vid++) {\r\nif (!test_bit(vid, ofdpa_port->vlan_bitmap))\r\ncontinue;\r\nvlan->flags = 0;\r\nif (ofdpa_vlan_id_is_internal(htons(vid)))\r\nvlan->flags |= BRIDGE_VLAN_INFO_PVID;\r\nvlan->vid_begin = vlan->vid_end = vid;\r\nerr = cb(&vlan->obj);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_obj_fib4_add(struct rocker_port *rocker_port,\r\nconst struct switchdev_obj_ipv4_fib *fib4,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nreturn ofdpa_port_fib_ipv4(ofdpa_port, trans,\r\nhtonl(fib4->dst), fib4->dst_len,\r\nfib4->fi, fib4->tb_id, 0);\r\n}\r\nstatic int ofdpa_port_obj_fib4_del(struct rocker_port *rocker_port,\r\nconst struct switchdev_obj_ipv4_fib *fib4)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nreturn ofdpa_port_fib_ipv4(ofdpa_port, NULL,\r\nhtonl(fib4->dst), fib4->dst_len,\r\nfib4->fi, fib4->tb_id,\r\nOFDPA_OP_FLAG_REMOVE);\r\n}\r\nstatic int ofdpa_port_obj_fdb_add(struct rocker_port *rocker_port,\r\nconst struct switchdev_obj_port_fdb *fdb,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\n__be16 vlan_id = ofdpa_port_vid_to_vlan(ofdpa_port, fdb->vid, NULL);\r\nif (!ofdpa_port_is_bridged(ofdpa_port))\r\nreturn -EINVAL;\r\nreturn ofdpa_port_fdb(ofdpa_port, trans, fdb->addr, vlan_id, 0);\r\n}\r\nstatic int ofdpa_port_obj_fdb_del(struct rocker_port *rocker_port,\r\nconst struct switchdev_obj_port_fdb *fdb)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\n__be16 vlan_id = ofdpa_port_vid_to_vlan(ofdpa_port, fdb->vid, NULL);\r\nint flags = OFDPA_OP_FLAG_REMOVE;\r\nif (!ofdpa_port_is_bridged(ofdpa_port))\r\nreturn -EINVAL;\r\nreturn ofdpa_port_fdb(ofdpa_port, NULL, fdb->addr, vlan_id, flags);\r\n}\r\nstatic int ofdpa_port_obj_fdb_dump(const struct rocker_port *rocker_port,\r\nstruct switchdev_obj_port_fdb *fdb,\r\nswitchdev_obj_dump_cb_t *cb)\r\n{\r\nconst struct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\r\nstruct ofdpa_fdb_tbl_entry *found;\r\nstruct hlist_node *tmp;\r\nunsigned long lock_flags;\r\nint bkt;\r\nint err = 0;\r\nspin_lock_irqsave(&ofdpa->fdb_tbl_lock, lock_flags);\r\nhash_for_each_safe(ofdpa->fdb_tbl, bkt, tmp, found, entry) {\r\nif (found->key.ofdpa_port != ofdpa_port)\r\ncontinue;\r\nether_addr_copy(fdb->addr, found->key.addr);\r\nfdb->ndm_state = NUD_REACHABLE;\r\nfdb->vid = ofdpa_port_vlan_to_vid(ofdpa_port,\r\nfound->key.vlan_id);\r\nerr = cb(&fdb->obj);\r\nif (err)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ofdpa->fdb_tbl_lock, lock_flags);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_bridge_join(struct ofdpa_port *ofdpa_port,\r\nstruct net_device *bridge)\r\n{\r\nint err;\r\nerr = ofdpa_port_vlan_del(ofdpa_port, OFDPA_UNTAGGED_VID, 0);\r\nif (err)\r\nreturn err;\r\nofdpa_port_internal_vlan_id_put(ofdpa_port,\r\nofdpa_port->dev->ifindex);\r\nofdpa_port->internal_vlan_id =\r\nofdpa_port_internal_vlan_id_get(ofdpa_port, bridge->ifindex);\r\nofdpa_port->bridge_dev = bridge;\r\nswitchdev_port_fwd_mark_set(ofdpa_port->dev, bridge, true);\r\nreturn ofdpa_port_vlan_add(ofdpa_port, NULL, OFDPA_UNTAGGED_VID, 0);\r\n}\r\nstatic int ofdpa_port_bridge_leave(struct ofdpa_port *ofdpa_port)\r\n{\r\nint err;\r\nerr = ofdpa_port_vlan_del(ofdpa_port, OFDPA_UNTAGGED_VID, 0);\r\nif (err)\r\nreturn err;\r\nofdpa_port_internal_vlan_id_put(ofdpa_port,\r\nofdpa_port->bridge_dev->ifindex);\r\nofdpa_port->internal_vlan_id =\r\nofdpa_port_internal_vlan_id_get(ofdpa_port,\r\nofdpa_port->dev->ifindex);\r\nswitchdev_port_fwd_mark_set(ofdpa_port->dev, ofdpa_port->bridge_dev,\r\nfalse);\r\nofdpa_port->bridge_dev = NULL;\r\nerr = ofdpa_port_vlan_add(ofdpa_port, NULL, OFDPA_UNTAGGED_VID, 0);\r\nif (err)\r\nreturn err;\r\nif (ofdpa_port->dev->flags & IFF_UP)\r\nerr = ofdpa_port_fwd_enable(ofdpa_port, 0);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_ovs_changed(struct ofdpa_port *ofdpa_port,\r\nstruct net_device *master)\r\n{\r\nint err;\r\nofdpa_port->bridge_dev = master;\r\nerr = ofdpa_port_fwd_disable(ofdpa_port, 0);\r\nif (err)\r\nreturn err;\r\nerr = ofdpa_port_fwd_enable(ofdpa_port, 0);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_master_linked(struct rocker_port *rocker_port,\r\nstruct net_device *master)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nint err = 0;\r\nif (netif_is_bridge_master(master))\r\nerr = ofdpa_port_bridge_join(ofdpa_port, master);\r\nelse if (netif_is_ovs_master(master))\r\nerr = ofdpa_port_ovs_changed(ofdpa_port, master);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_master_unlinked(struct rocker_port *rocker_port,\r\nstruct net_device *master)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nint err = 0;\r\nif (ofdpa_port_is_bridged(ofdpa_port))\r\nerr = ofdpa_port_bridge_leave(ofdpa_port);\r\nelse if (ofdpa_port_is_ovsed(ofdpa_port))\r\nerr = ofdpa_port_ovs_changed(ofdpa_port, NULL);\r\nreturn err;\r\n}\r\nstatic int ofdpa_port_neigh_update(struct rocker_port *rocker_port,\r\nstruct neighbour *n)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nint flags = (n->nud_state & NUD_VALID ? 0 : OFDPA_OP_FLAG_REMOVE) |\r\nOFDPA_OP_FLAG_NOWAIT;\r\n__be32 ip_addr = *(__be32 *) n->primary_key;\r\nreturn ofdpa_port_ipv4_neigh(ofdpa_port, NULL, flags, ip_addr, n->ha);\r\n}\r\nstatic int ofdpa_port_neigh_destroy(struct rocker_port *rocker_port,\r\nstruct neighbour *n)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nint flags = OFDPA_OP_FLAG_REMOVE | OFDPA_OP_FLAG_NOWAIT;\r\n__be32 ip_addr = *(__be32 *) n->primary_key;\r\nreturn ofdpa_port_ipv4_neigh(ofdpa_port, NULL, flags, ip_addr, n->ha);\r\n}\r\nstatic int ofdpa_port_ev_mac_vlan_seen(struct rocker_port *rocker_port,\r\nconst unsigned char *addr,\r\n__be16 vlan_id)\r\n{\r\nstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\r\nint flags = OFDPA_OP_FLAG_NOWAIT | OFDPA_OP_FLAG_LEARNED;\r\nif (ofdpa_port->stp_state != BR_STATE_LEARNING &&\r\nofdpa_port->stp_state != BR_STATE_FORWARDING)\r\nreturn 0;\r\nreturn ofdpa_port_fdb(ofdpa_port, NULL, addr, vlan_id, flags);\r\n}
