static bool sg_dwiter_next(struct sg_mapping_iter *miter)\r\n{\r\nif (sg_miter_next(miter)) {\r\nmiter->consumed = 0;\r\nreturn true;\r\n} else\r\nreturn false;\r\n}\r\nstatic bool sg_dwiter_is_at_end(struct sg_mapping_iter *miter)\r\n{\r\nreturn miter->length == miter->consumed && !sg_dwiter_next(miter);\r\n}\r\nstatic uint32_t sg_dwiter_read_buffer(struct sg_mapping_iter *miter)\r\n{\r\nsize_t len, left = 4;\r\nuint32_t data;\r\nvoid *addr = &data;\r\ndo {\r\nlen = min(miter->length - miter->consumed, left);\r\nmemcpy(addr, miter->addr + miter->consumed, len);\r\nmiter->consumed += len;\r\nleft -= len;\r\nif (!left)\r\nreturn data;\r\naddr += len;\r\n} while (sg_dwiter_next(miter));\r\nmemset(addr, 0, left);\r\nreturn data;\r\n}\r\nstatic inline bool needs_unaligned_copy(const void *ptr)\r\n{\r\n#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\r\nreturn false;\r\n#else\r\nreturn ((ptr - NULL) & 3) != 0;\r\n#endif\r\n}\r\nstatic bool sg_dwiter_get_next_block(struct sg_mapping_iter *miter, uint32_t **ptr)\r\n{\r\nsize_t len;\r\nif (sg_dwiter_is_at_end(miter))\r\nreturn true;\r\nlen = miter->length - miter->consumed;\r\nif (likely(len >= 4 && !needs_unaligned_copy(\r\nmiter->addr + miter->consumed))) {\r\n*ptr = miter->addr + miter->consumed;\r\nmiter->consumed += 4;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nuint32_t cb710_sg_dwiter_read_next_block(struct sg_mapping_iter *miter)\r\n{\r\nuint32_t *ptr = NULL;\r\nif (likely(sg_dwiter_get_next_block(miter, &ptr)))\r\nreturn ptr ? *ptr : 0;\r\nreturn sg_dwiter_read_buffer(miter);\r\n}\r\nstatic void sg_dwiter_write_slow(struct sg_mapping_iter *miter, uint32_t data)\r\n{\r\nsize_t len, left = 4;\r\nvoid *addr = &data;\r\ndo {\r\nlen = min(miter->length - miter->consumed, left);\r\nmemcpy(miter->addr, addr, len);\r\nmiter->consumed += len;\r\nleft -= len;\r\nif (!left)\r\nreturn;\r\naddr += len;\r\n} while (sg_dwiter_next(miter));\r\n}\r\nvoid cb710_sg_dwiter_write_next_block(struct sg_mapping_iter *miter, uint32_t data)\r\n{\r\nuint32_t *ptr = NULL;\r\nif (likely(sg_dwiter_get_next_block(miter, &ptr))) {\r\nif (ptr)\r\n*ptr = data;\r\nelse\r\nreturn;\r\n} else\r\nsg_dwiter_write_slow(miter, data);\r\n}
