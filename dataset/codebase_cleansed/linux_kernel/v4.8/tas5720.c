static int tas5720_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int rate = params_rate(params);\r\nbool ssz_ds;\r\nint ret;\r\nswitch (rate) {\r\ncase 44100:\r\ncase 48000:\r\nssz_ds = false;\r\nbreak;\r\ncase 88200:\r\ncase 96000:\r\nssz_ds = true;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported sample rate: %u\n", rate);\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_update_bits(codec, TAS5720_DIGITAL_CTRL1_REG,\r\nTAS5720_SSZ_DS, ssz_ds);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "error setting sample rate: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas5720_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 serial_format;\r\nint ret;\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS) {\r\ndev_vdbg(codec->dev, "DAI Format master is not found\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK |\r\nSND_SOC_DAIFMT_INV_MASK)) {\r\ncase (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF):\r\nserial_format = TAS5720_SAIF_I2S;\r\nbreak;\r\ncase (SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_NB_NF):\r\nserial_format = TAS5720_SAIF_I2S;\r\nbreak;\r\ncase (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF):\r\nserial_format = TAS5720_SAIF_LEFTJ;\r\nbreak;\r\ncase (SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF):\r\nserial_format = TAS5720_SAIF_LEFTJ;\r\nbreak;\r\ndefault:\r\ndev_vdbg(codec->dev, "DAI Format is not found\n");\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_update_bits(codec, TAS5720_DIGITAL_CTRL1_REG,\r\nTAS5720_SAIF_FORMAT_MASK,\r\nserial_format);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "error setting SAIF format: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas5720_set_dai_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask,\r\nint slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int first_slot;\r\nint ret;\r\nif (!tx_mask) {\r\ndev_err(codec->dev, "tx masks must not be 0\n");\r\nreturn -EINVAL;\r\n}\r\nfirst_slot = __ffs(tx_mask);\r\nif (first_slot > 7) {\r\ndev_err(codec->dev, "slot selection out of bounds (%u)\n",\r\nfirst_slot);\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_update_bits(codec, TAS5720_DIGITAL_CTRL1_REG,\r\nTAS5720_TDM_CFG_SRC, TAS5720_TDM_CFG_SRC);\r\nif (ret < 0)\r\ngoto error_snd_soc_update_bits;\r\nret = snd_soc_update_bits(codec, TAS5720_DIGITAL_CTRL2_REG,\r\nTAS5720_TDM_SLOT_SEL_MASK, first_slot);\r\nif (ret < 0)\r\ngoto error_snd_soc_update_bits;\r\nreturn 0;\r\nerror_snd_soc_update_bits:\r\ndev_err(codec->dev, "error configuring TDM mode: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tas5720_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint ret;\r\nret = snd_soc_update_bits(codec, TAS5720_DIGITAL_CTRL2_REG,\r\nTAS5720_MUTE, mute ? TAS5720_MUTE : 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "error (un-)muting device: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tas5720_fault_check_work(struct work_struct *work)\r\n{\r\nstruct tas5720_data *tas5720 = container_of(work, struct tas5720_data,\r\nfault_check_work.work);\r\nstruct device *dev = tas5720->codec->dev;\r\nunsigned int curr_fault;\r\nint ret;\r\nret = regmap_read(tas5720->regmap, TAS5720_FAULT_REG, &curr_fault);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to read FAULT register: %d\n", ret);\r\ngoto out;\r\n}\r\ncurr_fault &= TAS5720_OCE | TAS5720_DCE | TAS5720_OTE;\r\nif ((curr_fault & TAS5720_OCE) && !(tas5720->last_fault & TAS5720_OCE))\r\ndev_crit(dev, "experienced an over current hardware fault\n");\r\nif ((curr_fault & TAS5720_DCE) && !(tas5720->last_fault & TAS5720_DCE))\r\ndev_crit(dev, "experienced a DC detection fault\n");\r\nif ((curr_fault & TAS5720_OTE) && !(tas5720->last_fault & TAS5720_OTE))\r\ndev_crit(dev, "experienced an over temperature fault\n");\r\ntas5720->last_fault = curr_fault;\r\nif (!curr_fault)\r\ngoto out;\r\nret = regmap_write_bits(tas5720->regmap, TAS5720_POWER_CTRL_REG,\r\nTAS5720_SDZ, 0);\r\nif (ret < 0)\r\ndev_err(dev, "failed to write POWER_CTRL register: %d\n", ret);\r\nret = regmap_write_bits(tas5720->regmap, TAS5720_POWER_CTRL_REG,\r\nTAS5720_SDZ, TAS5720_SDZ);\r\nif (ret < 0)\r\ndev_err(dev, "failed to write POWER_CTRL register: %d\n", ret);\r\nout:\r\nschedule_delayed_work(&tas5720->fault_check_work,\r\nmsecs_to_jiffies(TAS5720_FAULT_CHECK_INTERVAL));\r\n}\r\nstatic int tas5720_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct tas5720_data *tas5720 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int device_id;\r\nint ret;\r\ntas5720->codec = codec;\r\nret = regulator_bulk_enable(ARRAY_SIZE(tas5720->supplies),\r\ntas5720->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(tas5720->regmap, TAS5720_DEVICE_ID_REG, &device_id);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "failed to read device ID register: %d\n",\r\nret);\r\ngoto probe_fail;\r\n}\r\nif (device_id != TAS5720_DEVICE_ID) {\r\ndev_err(codec->dev, "wrong device ID. expected: %u read: %u\n",\r\nTAS5720_DEVICE_ID, device_id);\r\nret = -ENODEV;\r\ngoto probe_fail;\r\n}\r\nret = snd_soc_update_bits(codec, TAS5720_DIGITAL_CTRL2_REG,\r\nTAS5720_MUTE, TAS5720_MUTE);\r\nif (ret < 0)\r\ngoto error_snd_soc_update_bits;\r\nret = snd_soc_update_bits(codec, TAS5720_POWER_CTRL_REG,\r\nTAS5720_SDZ, 0);\r\nif (ret < 0)\r\ngoto error_snd_soc_update_bits;\r\nINIT_DELAYED_WORK(&tas5720->fault_check_work, tas5720_fault_check_work);\r\nreturn 0;\r\nerror_snd_soc_update_bits:\r\ndev_err(codec->dev, "error configuring device registers: %d\n", ret);\r\nprobe_fail:\r\nregulator_bulk_disable(ARRAY_SIZE(tas5720->supplies),\r\ntas5720->supplies);\r\nreturn ret;\r\n}\r\nstatic int tas5720_codec_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct tas5720_data *tas5720 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncancel_delayed_work_sync(&tas5720->fault_check_work);\r\nret = regulator_bulk_disable(ARRAY_SIZE(tas5720->supplies),\r\ntas5720->supplies);\r\nif (ret < 0)\r\ndev_err(codec->dev, "failed to disable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tas5720_dac_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct tas5720_data *tas5720 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nif (event & SND_SOC_DAPM_POST_PMU) {\r\nret = snd_soc_update_bits(codec, TAS5720_POWER_CTRL_REG,\r\nTAS5720_SDZ, TAS5720_SDZ);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "error waking codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nmsleep(25);\r\ntas5720->last_fault = 0;\r\nschedule_delayed_work(&tas5720->fault_check_work,\r\nmsecs_to_jiffies(TAS5720_FAULT_CHECK_INTERVAL));\r\n} else if (event & SND_SOC_DAPM_PRE_PMD) {\r\ncancel_delayed_work_sync(&tas5720->fault_check_work);\r\nret = snd_soc_update_bits(codec, TAS5720_POWER_CTRL_REG,\r\nTAS5720_SDZ, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "error shutting down codec: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas5720_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct tas5720_data *tas5720 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nregcache_cache_only(tas5720->regmap, true);\r\nregcache_mark_dirty(tas5720->regmap);\r\nret = regulator_bulk_disable(ARRAY_SIZE(tas5720->supplies),\r\ntas5720->supplies);\r\nif (ret < 0)\r\ndev_err(codec->dev, "failed to disable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tas5720_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct tas5720_data *tas5720 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(tas5720->supplies),\r\ntas5720->supplies);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(tas5720->regmap, false);\r\nret = regcache_sync(tas5720->regmap);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "failed to sync regcache: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool tas5720_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TAS5720_DEVICE_ID_REG:\r\ncase TAS5720_FAULT_REG:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int tas5720_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct tas5720_data *data;\r\nint ret;\r\nint i;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->tas5720_client = client;\r\ndata->regmap = devm_regmap_init_i2c(client, &tas5720_regmap_config);\r\nif (IS_ERR(data->regmap)) {\r\nret = PTR_ERR(data->regmap);\r\ndev_err(dev, "failed to allocate register map: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->supplies); i++)\r\ndata->supplies[i].supply = tas5720_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(data->supplies),\r\ndata->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(dev, data);\r\nret = snd_soc_register_codec(&client->dev,\r\n&soc_codec_dev_tas5720,\r\ntas5720_dai, ARRAY_SIZE(tas5720_dai));\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas5720_remove(struct i2c_client *client)\r\n{\r\nstruct device *dev = &client->dev;\r\nsnd_soc_unregister_codec(dev);\r\nreturn 0;\r\n}
