static inline void INIT_LIST_HEAD(struct list_head *list)\r\n{\r\nlist->next = list;\r\nlist->prev = list;\r\n}\r\nstatic inline void __list_add(struct list_head *new,\r\nstruct list_head *prev, struct list_head *next)\r\n{\r\nnext->prev = new;\r\nnew->next = next;\r\nnew->prev = prev;\r\nprev->next = new;\r\n}\r\nstatic inline void list_add(struct list_head *new, struct list_head *head)\r\n{\r\n__list_add(new, head, head->next);\r\n}\r\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head)\r\n{\r\n__list_add(new, head->prev, head);\r\n}\r\nstatic inline void __list_del(struct list_head *prev, struct list_head *next)\r\n{\r\nnext->prev = prev;\r\nprev->next = next;\r\n}\r\nstatic inline void list_del(struct list_head *entry)\r\n{\r\n__list_del(entry->prev, entry->next);\r\nentry->next = (void *)0xDEADBEEF;\r\nentry->prev = (void *)0xBEEFDEAD;\r\n}\r\nstatic inline void list_replace(struct list_head *old, struct list_head *new)\r\n{\r\nnew->next = old->next;\r\nnew->next->prev = new;\r\nnew->prev = old->prev;\r\nnew->prev->next = new;\r\n}\r\nstatic inline void list_replace_init(struct list_head *old,\r\nstruct list_head *new)\r\n{\r\nlist_replace(old, new);\r\nINIT_LIST_HEAD(old);\r\n}\r\nstatic inline void list_del_init(struct list_head *entry)\r\n{\r\n__list_del(entry->prev, entry->next);\r\nINIT_LIST_HEAD(entry);\r\n}\r\nstatic inline void list_move(struct list_head *list, struct list_head *head)\r\n{\r\n__list_del(list->prev, list->next);\r\nlist_add(list, head);\r\n}\r\nstatic inline void list_move_tail(struct list_head *list,\r\nstruct list_head *head)\r\n{\r\n__list_del(list->prev, list->next);\r\nlist_add_tail(list, head);\r\n}\r\nstatic inline int list_is_last(const struct list_head *list,\r\nconst struct list_head *head)\r\n{\r\nreturn list->next == head;\r\n}\r\nstatic inline int list_empty(const struct list_head *head)\r\n{\r\nreturn head->next == head;\r\n}\r\nstatic inline int list_empty_careful(const struct list_head *head)\r\n{\r\nstruct list_head *next = head->next;\r\nreturn (next == head) && (next == head->prev);\r\n}\r\nstatic inline int list_is_singular(const struct list_head *head)\r\n{\r\nreturn !list_empty(head) && (head->next == head->prev);\r\n}\r\nstatic inline void __list_cut_position(struct list_head *list,\r\nstruct list_head *head,\r\nstruct list_head *entry)\r\n{\r\nstruct list_head *new_first = entry->next;\r\nlist->next = head->next;\r\nlist->next->prev = list;\r\nlist->prev = entry;\r\nentry->next = list;\r\nhead->next = new_first;\r\nnew_first->prev = head;\r\n}\r\nstatic inline void list_cut_position(struct list_head *list,\r\nstruct list_head *head,\r\nstruct list_head *entry)\r\n{\r\nif (list_empty(head))\r\nreturn;\r\nif (list_is_singular(head) && (head->next != entry && head != entry))\r\nreturn;\r\nif (entry == head)\r\nINIT_LIST_HEAD(list);\r\nelse\r\n__list_cut_position(list, head, entry);\r\n}\r\nstatic inline void __list_splice(const struct list_head *list,\r\nstruct list_head *prev, struct list_head *next)\r\n{\r\nstruct list_head *first = list->next;\r\nstruct list_head *last = list->prev;\r\nfirst->prev = prev;\r\nprev->next = first;\r\nlast->next = next;\r\nnext->prev = last;\r\n}\r\nstatic inline void list_splice(const struct list_head *list,\r\nstruct list_head *head)\r\n{\r\nif (!list_empty(list))\r\n__list_splice(list, head, head->next);\r\n}\r\nstatic inline void list_splice_tail(struct list_head *list,\r\nstruct list_head *head)\r\n{\r\nif (!list_empty(list))\r\n__list_splice(list, head->prev, head);\r\n}\r\nstatic inline void list_splice_init(struct list_head *list,\r\nstruct list_head *head)\r\n{\r\nif (!list_empty(list)) {\r\n__list_splice(list, head, head->next);\r\nINIT_LIST_HEAD(list);\r\n}\r\n}\r\nstatic inline void list_splice_tail_init(struct list_head *list,\r\nstruct list_head *head)\r\n{\r\nif (!list_empty(list)) {\r\n__list_splice(list, head->prev, head);\r\nINIT_LIST_HEAD(list);\r\n}\r\n}\r\nstatic struct offset *offset_new(unsigned o)\r\n{\r\nstruct offset *offset;\r\noffset = (struct offset *)malloc(sizeof(struct offset));\r\nif (offset) {\r\nINIT_LIST_HEAD(&offset->list);\r\noffset->offset = o;\r\n}\r\nreturn offset;\r\n}\r\nstatic void table_offset_add(struct table *t, struct offset *offset)\r\n{\r\nlist_add_tail(&offset->list, &t->offsets);\r\n}\r\nstatic void table_init(struct table *t)\r\n{\r\nINIT_LIST_HEAD(&t->offsets);\r\nt->offset_max = 0;\r\nt->nentry = 0;\r\nt->table = NULL;\r\n}\r\nstatic void table_print(struct table *t)\r\n{\r\nunsigned nlloop, i, j, n, c, id;\r\nnlloop = (t->nentry + 3) / 4;\r\nc = t->nentry;\r\nprintf("static const unsigned %s_reg_safe_bm[%d] = {\n", t->gpu_prefix,\r\nt->nentry);\r\nfor (i = 0, id = 0; i < nlloop; i++) {\r\nn = 4;\r\nif (n > c)\r\nn = c;\r\nc -= n;\r\nfor (j = 0; j < n; j++) {\r\nif (j == 0)\r\nprintf("\t");\r\nelse\r\nprintf(" ");\r\nprintf("0x%08X,", t->table[id++]);\r\n}\r\nprintf("\n");\r\n}\r\nprintf("};\n");\r\n}\r\nstatic int table_build(struct table *t)\r\n{\r\nstruct offset *offset;\r\nunsigned i, m;\r\nt->nentry = ((t->offset_max >> 2) + 31) / 32;\r\nt->table = (unsigned *)malloc(sizeof(unsigned) * t->nentry);\r\nif (t->table == NULL)\r\nreturn -1;\r\nmemset(t->table, 0xff, sizeof(unsigned) * t->nentry);\r\nlist_for_each_entry(offset, &t->offsets, list) {\r\ni = (offset->offset >> 2) / 32;\r\nm = (offset->offset >> 2) & 31;\r\nm = 1 << m;\r\nt->table[i] ^= m;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parser_auth(struct table *t, const char *filename)\r\n{\r\nFILE *file;\r\nregex_t mask_rex;\r\nregmatch_t match[4];\r\nchar buf[1024];\r\nsize_t end;\r\nint len;\r\nint done = 0;\r\nint r;\r\nunsigned o;\r\nstruct offset *offset;\r\nchar last_reg_s[10];\r\nint last_reg;\r\nif (regcomp\r\n(&mask_rex, "(0x[0-9a-fA-F]*) *([_a-zA-Z0-9]*)", REG_EXTENDED)) {\r\nfprintf(stderr, "Failed to compile regular expression\n");\r\nreturn -1;\r\n}\r\nfile = fopen(filename, "r");\r\nif (file == NULL) {\r\nfprintf(stderr, "Failed to open: %s\n", filename);\r\nreturn -1;\r\n}\r\nfseek(file, 0, SEEK_END);\r\nend = ftell(file);\r\nfseek(file, 0, SEEK_SET);\r\nif (fgets(buf, 1024, file) == NULL) {\r\nfclose(file);\r\nreturn -1;\r\n}\r\nsscanf(buf, "%9s %9s", gpu_name, last_reg_s);\r\nt->gpu_prefix = gpu_name;\r\nlast_reg = strtol(last_reg_s, NULL, 16);\r\ndo {\r\nif (fgets(buf, 1024, file) == NULL) {\r\nfclose(file);\r\nreturn -1;\r\n}\r\nlen = strlen(buf);\r\nif (ftell(file) == end)\r\ndone = 1;\r\nif (len) {\r\nr = regexec(&mask_rex, buf, 4, match, 0);\r\nif (r == REG_NOMATCH) {\r\n} else if (r) {\r\nfprintf(stderr,\r\n"Error matching regular expression %d in %s\n",\r\nr, filename);\r\nfclose(file);\r\nreturn -1;\r\n} else {\r\nbuf[match[0].rm_eo] = 0;\r\nbuf[match[1].rm_eo] = 0;\r\nbuf[match[2].rm_eo] = 0;\r\no = strtol(&buf[match[1].rm_so], NULL, 16);\r\noffset = offset_new(o);\r\ntable_offset_add(t, offset);\r\nif (o > t->offset_max)\r\nt->offset_max = o;\r\n}\r\n}\r\n} while (!done);\r\nfclose(file);\r\nif (t->offset_max < last_reg)\r\nt->offset_max = last_reg;\r\nreturn table_build(t);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nstruct table t;\r\nif (argc != 2) {\r\nfprintf(stderr, "Usage: %s <authfile>\n", argv[0]);\r\nexit(1);\r\n}\r\ntable_init(&t);\r\nif (parser_auth(&t, argv[1])) {\r\nfprintf(stderr, "Failed to parse file %s\n", argv[1]);\r\nreturn -1;\r\n}\r\ntable_print(&t);\r\nreturn 0;\r\n}
