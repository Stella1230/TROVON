static void dw_apb_ictl_handler(struct irq_desc *desc)\r\n{\r\nstruct irq_domain *d = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nint n;\r\nchained_irq_enter(chip, desc);\r\nfor (n = 0; n < d->revmap_size; n += 32) {\r\nstruct irq_chip_generic *gc = irq_get_domain_generic_chip(d, n);\r\nu32 stat = readl_relaxed(gc->reg_base + APB_INT_FINALSTATUS_L);\r\nwhile (stat) {\r\nu32 hwirq = ffs(stat) - 1;\r\nu32 virq = irq_find_mapping(d, gc->irq_base + hwirq);\r\ngeneric_handle_irq(virq);\r\nstat &= ~(1 << hwirq);\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void dw_apb_ictl_resume(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nirq_gc_lock(gc);\r\nwritel_relaxed(~0, gc->reg_base + ct->regs.enable);\r\nwritel_relaxed(*ct->mask_cache, gc->reg_base + ct->regs.mask);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic int __init dw_apb_ictl_init(struct device_node *np,\r\nstruct device_node *parent)\r\n{\r\nunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\r\nstruct resource r;\r\nstruct irq_domain *domain;\r\nstruct irq_chip_generic *gc;\r\nvoid __iomem *iobase;\r\nint ret, nrirqs, irq, i;\r\nu32 reg;\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq <= 0) {\r\npr_err("%s: unable to parse irq\n", np->full_name);\r\nreturn -EINVAL;\r\n}\r\nret = of_address_to_resource(np, 0, &r);\r\nif (ret) {\r\npr_err("%s: unable to get resource\n", np->full_name);\r\nreturn ret;\r\n}\r\nif (!request_mem_region(r.start, resource_size(&r), np->full_name)) {\r\npr_err("%s: unable to request mem region\n", np->full_name);\r\nreturn -ENOMEM;\r\n}\r\niobase = ioremap(r.start, resource_size(&r));\r\nif (!iobase) {\r\npr_err("%s: unable to map resource\n", np->full_name);\r\nret = -ENOMEM;\r\ngoto err_release;\r\n}\r\nwritel_relaxed(~0, iobase + APB_INT_MASK_L);\r\nwritel_relaxed(~0, iobase + APB_INT_MASK_H);\r\nwritel_relaxed(~0, iobase + APB_INT_ENABLE_L);\r\nwritel_relaxed(~0, iobase + APB_INT_ENABLE_H);\r\nreg = readl_relaxed(iobase + APB_INT_ENABLE_H);\r\nif (reg)\r\nnrirqs = 32 + fls(reg);\r\nelse\r\nnrirqs = fls(readl_relaxed(iobase + APB_INT_ENABLE_L));\r\ndomain = irq_domain_add_linear(np, nrirqs,\r\n&irq_generic_chip_ops, NULL);\r\nif (!domain) {\r\npr_err("%s: unable to add irq domain\n", np->full_name);\r\nret = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\nret = irq_alloc_domain_generic_chips(domain, 32, 1, np->name,\r\nhandle_level_irq, clr, 0,\r\nIRQ_GC_INIT_MASK_CACHE);\r\nif (ret) {\r\npr_err("%s: unable to alloc irq domain gc\n", np->full_name);\r\ngoto err_unmap;\r\n}\r\nfor (i = 0; i < DIV_ROUND_UP(nrirqs, 32); i++) {\r\ngc = irq_get_domain_generic_chip(domain, i * 32);\r\ngc->reg_base = iobase + i * APB_INT_BASE_OFFSET;\r\ngc->chip_types[0].regs.mask = APB_INT_MASK_L;\r\ngc->chip_types[0].regs.enable = APB_INT_ENABLE_L;\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_set_bit;\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_mask_clr_bit;\r\ngc->chip_types[0].chip.irq_resume = dw_apb_ictl_resume;\r\n}\r\nirq_set_chained_handler_and_data(irq, dw_apb_ictl_handler, domain);\r\nreturn 0;\r\nerr_unmap:\r\niounmap(iobase);\r\nerr_release:\r\nrelease_mem_region(r.start, resource_size(&r));\r\nreturn ret;\r\n}
