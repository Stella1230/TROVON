static inline u_int32_t gpi_i_bit(int i)\r\n{\r\nif (i < 10)\r\nreturn 1 << i;\r\nelse\r\nreturn 1 << (i + 14);\r\n}\r\nstatic inline u_int32_t gpo_o_bit(int i)\r\n{\r\nif (i < 11)\r\nreturn 1 << i;\r\nelse\r\nreturn 1 << (i + 14);\r\n}\r\nstatic inline u_int32_t gpio_i_bit(int i)\r\n{\r\nif (i < 14)\r\nreturn 1 << (i + 10);\r\nelse\r\nreturn 1 << (i + 14);\r\n}\r\nstatic inline u_int32_t gpio_o_bit(int i)\r\n{\r\nif (i < 14)\r\nreturn 1 << (i + 11);\r\nelse\r\nreturn 1 << (i + 13);\r\n}\r\nstatic int vx855gpio_direction_input(struct gpio_chip *gpio,\r\nunsigned int nr)\r\n{\r\nstruct vx855_gpio *vg = gpiochip_get_data(gpio);\r\nunsigned long flags;\r\nu_int32_t reg_out;\r\nif (nr < NR_VX855_GPI)\r\nreturn 0;\r\nif (nr < NR_VX855_GPInO)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&vg->lock, flags);\r\nreg_out = inl(vg->io_gpo);\r\nreg_out |= gpio_o_bit(nr - NR_VX855_GPInO);\r\noutl(reg_out, vg->io_gpo);\r\nspin_unlock_irqrestore(&vg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vx855gpio_get(struct gpio_chip *gpio, unsigned int nr)\r\n{\r\nstruct vx855_gpio *vg = gpiochip_get_data(gpio);\r\nu_int32_t reg_in;\r\nint ret = 0;\r\nif (nr < NR_VX855_GPI) {\r\nreg_in = inl(vg->io_gpi);\r\nif (reg_in & gpi_i_bit(nr))\r\nret = 1;\r\n} else if (nr < NR_VX855_GPInO) {\r\nreg_in = inl(vg->io_gpo);\r\nif (reg_in & gpo_o_bit(nr - NR_VX855_GPI))\r\nret = 1;\r\n} else {\r\nreg_in = inl(vg->io_gpi);\r\nif (reg_in & gpio_i_bit(nr - NR_VX855_GPInO))\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic void vx855gpio_set(struct gpio_chip *gpio, unsigned int nr,\r\nint val)\r\n{\r\nstruct vx855_gpio *vg = gpiochip_get_data(gpio);\r\nunsigned long flags;\r\nu_int32_t reg_out;\r\nif (nr < NR_VX855_GPI)\r\nreturn;\r\nspin_lock_irqsave(&vg->lock, flags);\r\nreg_out = inl(vg->io_gpo);\r\nif (nr < NR_VX855_GPInO) {\r\nif (val)\r\nreg_out |= gpo_o_bit(nr - NR_VX855_GPI);\r\nelse\r\nreg_out &= ~gpo_o_bit(nr - NR_VX855_GPI);\r\n} else {\r\nif (val)\r\nreg_out |= gpio_o_bit(nr - NR_VX855_GPInO);\r\nelse\r\nreg_out &= ~gpio_o_bit(nr - NR_VX855_GPInO);\r\n}\r\noutl(reg_out, vg->io_gpo);\r\nspin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic int vx855gpio_direction_output(struct gpio_chip *gpio,\r\nunsigned int nr, int val)\r\n{\r\nif (nr < NR_VX855_GPI)\r\nreturn -EINVAL;\r\nvx855gpio_set(gpio, nr, val);\r\nreturn 0;\r\n}\r\nstatic int vx855gpio_set_single_ended(struct gpio_chip *gpio,\r\nunsigned int nr,\r\nenum single_ended_mode mode)\r\n{\r\nif (nr < NR_VX855_GPI)\r\nreturn -EINVAL;\r\nif (nr < NR_VX855_GPInO) {\r\nif (mode != LINE_MODE_PUSH_PULL)\r\nreturn -ENOTSUPP;\r\nreturn 0;\r\n}\r\nif (mode != LINE_MODE_OPEN_DRAIN)\r\nreturn -ENOTSUPP;\r\nreturn 0;\r\n}\r\nstatic void vx855gpio_gpio_setup(struct vx855_gpio *vg)\r\n{\r\nstruct gpio_chip *c = &vg->gpio;\r\nc->label = "VX855 South Bridge";\r\nc->owner = THIS_MODULE;\r\nc->direction_input = vx855gpio_direction_input;\r\nc->direction_output = vx855gpio_direction_output;\r\nc->get = vx855gpio_get;\r\nc->set = vx855gpio_set;\r\nc->set_single_ended = vx855gpio_set_single_ended;\r\nc->dbg_show = NULL;\r\nc->base = 0;\r\nc->ngpio = NR_VX855_GP;\r\nc->can_sleep = false;\r\nc->names = vx855gpio_names;\r\n}\r\nstatic int vx855gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res_gpi;\r\nstruct resource *res_gpo;\r\nstruct vx855_gpio *vg;\r\nres_gpi = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nres_gpo = platform_get_resource(pdev, IORESOURCE_IO, 1);\r\nif (!res_gpi || !res_gpo)\r\nreturn -EBUSY;\r\nvg = devm_kzalloc(&pdev->dev, sizeof(*vg), GFP_KERNEL);\r\nif (!vg)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, vg);\r\ndev_info(&pdev->dev, "found VX855 GPIO controller\n");\r\nvg->io_gpi = res_gpi->start;\r\nvg->io_gpo = res_gpo->start;\r\nspin_lock_init(&vg->lock);\r\nif (!devm_request_region(&pdev->dev, res_gpi->start,\r\nresource_size(res_gpi), MODULE_NAME "_gpi"))\r\ndev_warn(&pdev->dev,\r\n"GPI I/O resource busy, probably claimed by ACPI\n");\r\nif (!devm_request_region(&pdev->dev, res_gpo->start,\r\nresource_size(res_gpo), MODULE_NAME "_gpo"))\r\ndev_warn(&pdev->dev,\r\n"GPO I/O resource busy, probably claimed by ACPI\n");\r\nvx855gpio_gpio_setup(vg);\r\nreturn devm_gpiochip_add_data(&pdev->dev, &vg->gpio, vg);\r\n}
