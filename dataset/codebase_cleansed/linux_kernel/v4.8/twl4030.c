static void tw4030_init_ctl_cache(struct twl4030_priv *twl4030)\r\n{\r\nint i;\r\nu8 byte;\r\nfor (i = TWL4030_REG_EAR_CTL; i <= TWL4030_REG_PRECKR_CTL; i++) {\r\ntwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE, &byte, i);\r\ntwl4030->ctl_cache[i - TWL4030_REG_EAR_CTL] = byte;\r\n}\r\n}\r\nstatic unsigned int twl4030_read(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nu8 value = 0;\r\nif (reg >= TWL4030_CACHEREGNUM)\r\nreturn -EIO;\r\nswitch (reg) {\r\ncase TWL4030_REG_EAR_CTL:\r\ncase TWL4030_REG_PREDL_CTL:\r\ncase TWL4030_REG_PREDR_CTL:\r\ncase TWL4030_REG_PRECKL_CTL:\r\ncase TWL4030_REG_PRECKR_CTL:\r\ncase TWL4030_REG_HS_GAIN_SET:\r\nvalue = twl4030->ctl_cache[reg - TWL4030_REG_EAR_CTL];\r\nbreak;\r\ndefault:\r\ntwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE, &value, reg);\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic bool twl4030_can_write_to_chip(struct twl4030_priv *twl4030,\r\nunsigned int reg)\r\n{\r\nbool write_to_reg = false;\r\nswitch (reg) {\r\ncase TWL4030_REG_EAR_CTL:\r\nif (twl4030->earpiece_enabled)\r\nwrite_to_reg = true;\r\nbreak;\r\ncase TWL4030_REG_PREDL_CTL:\r\nif (twl4030->predrivel_enabled)\r\nwrite_to_reg = true;\r\nbreak;\r\ncase TWL4030_REG_PREDR_CTL:\r\nif (twl4030->predriver_enabled)\r\nwrite_to_reg = true;\r\nbreak;\r\ncase TWL4030_REG_PRECKL_CTL:\r\nif (twl4030->carkitl_enabled)\r\nwrite_to_reg = true;\r\nbreak;\r\ncase TWL4030_REG_PRECKR_CTL:\r\nif (twl4030->carkitr_enabled)\r\nwrite_to_reg = true;\r\nbreak;\r\ncase TWL4030_REG_HS_GAIN_SET:\r\nif (twl4030->hsl_enabled || twl4030->hsr_enabled)\r\nwrite_to_reg = true;\r\nbreak;\r\ndefault:\r\nwrite_to_reg = true;\r\nbreak;\r\n}\r\nreturn write_to_reg;\r\n}\r\nstatic int twl4030_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nswitch (reg) {\r\ncase TWL4030_REG_EAR_CTL:\r\ncase TWL4030_REG_PREDL_CTL:\r\ncase TWL4030_REG_PREDR_CTL:\r\ncase TWL4030_REG_PRECKL_CTL:\r\ncase TWL4030_REG_PRECKR_CTL:\r\ncase TWL4030_REG_HS_GAIN_SET:\r\ntwl4030->ctl_cache[reg - TWL4030_REG_EAR_CTL] = value;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (twl4030_can_write_to_chip(twl4030, reg))\r\nreturn twl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE, value, reg);\r\nreturn 0;\r\n}\r\nstatic inline void twl4030_wait_ms(int time)\r\n{\r\nif (time < 60) {\r\ntime *= 1000;\r\nusleep_range(time, time + 500);\r\n} else {\r\nmsleep(time);\r\n}\r\n}\r\nstatic void twl4030_codec_enable(struct snd_soc_codec *codec, int enable)\r\n{\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nint mode;\r\nif (enable == twl4030->codec_powered)\r\nreturn;\r\nif (enable)\r\nmode = twl4030_audio_enable_resource(TWL4030_AUDIO_RES_POWER);\r\nelse\r\nmode = twl4030_audio_disable_resource(TWL4030_AUDIO_RES_POWER);\r\nif (mode >= 0)\r\ntwl4030->codec_powered = enable;\r\nudelay(10);\r\n}\r\nstatic void twl4030_setup_pdata_of(struct twl4030_codec_data *pdata,\r\nstruct device_node *node)\r\n{\r\nint value;\r\nof_property_read_u32(node, "ti,digimic_delay",\r\n&pdata->digimic_delay);\r\nof_property_read_u32(node, "ti,ramp_delay_value",\r\n&pdata->ramp_delay_value);\r\nof_property_read_u32(node, "ti,offset_cncl_path",\r\n&pdata->offset_cncl_path);\r\nif (!of_property_read_u32(node, "ti,hs_extmute", &value))\r\npdata->hs_extmute = value;\r\npdata->hs_extmute_gpio = of_get_named_gpio(node,\r\n"ti,hs_extmute_gpio", 0);\r\nif (gpio_is_valid(pdata->hs_extmute_gpio))\r\npdata->hs_extmute = 1;\r\n}\r\nstatic struct twl4030_codec_data *twl4030_get_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct twl4030_codec_data *pdata = dev_get_platdata(codec->dev);\r\nstruct device_node *twl4030_codec_node = NULL;\r\ntwl4030_codec_node = of_find_node_by_name(codec->dev->parent->of_node,\r\n"codec");\r\nif (!pdata && twl4030_codec_node) {\r\npdata = devm_kzalloc(codec->dev,\r\nsizeof(struct twl4030_codec_data),\r\nGFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(codec->dev, "Can not allocate memory\n");\r\nreturn NULL;\r\n}\r\ntwl4030_setup_pdata_of(pdata, twl4030_codec_node);\r\n}\r\nreturn pdata;\r\n}\r\nstatic void twl4030_init_chip(struct snd_soc_codec *codec)\r\n{\r\nstruct twl4030_codec_data *pdata;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nu8 reg, byte;\r\nint i = 0;\r\npdata = twl4030_get_pdata(codec);\r\nif (pdata && pdata->hs_extmute) {\r\nif (gpio_is_valid(pdata->hs_extmute_gpio)) {\r\nint ret;\r\nif (!pdata->hs_extmute_gpio)\r\ndev_warn(codec->dev,\r\n"Extmute GPIO is 0 is this correct?\n");\r\nret = gpio_request_one(pdata->hs_extmute_gpio,\r\nGPIOF_OUT_INIT_LOW,\r\n"hs_extmute");\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to get hs_extmute GPIO\n");\r\npdata->hs_extmute_gpio = -1;\r\n}\r\n} else {\r\nu8 pin_mux;\r\ntwl_i2c_read_u8(TWL4030_MODULE_INTBR, &pin_mux,\r\nTWL4030_PMBR1_REG);\r\npin_mux &= ~TWL4030_GPIO6_PWM0_MUTE(0x03);\r\npin_mux |= TWL4030_GPIO6_PWM0_MUTE(0x02);\r\ntwl_i2c_write_u8(TWL4030_MODULE_INTBR, pin_mux,\r\nTWL4030_PMBR1_REG);\r\n}\r\n}\r\ntw4030_init_ctl_cache(twl4030);\r\nreg = twl4030_read(codec, TWL4030_REG_MISC_SET_1);\r\ntwl4030_write(codec, TWL4030_REG_MISC_SET_1,\r\nreg | TWL4030_SMOOTH_ANAVOL_EN);\r\ntwl4030_write(codec, TWL4030_REG_OPTION,\r\nTWL4030_ATXL1_EN | TWL4030_ATXR1_EN |\r\nTWL4030_ARXL2_EN | TWL4030_ARXR2_EN);\r\ntwl4030_write(codec, TWL4030_REG_ARXR2_APGA_CTL, 0x32);\r\nif (!pdata)\r\nreturn;\r\ntwl4030->pdata = pdata;\r\nreg = twl4030_read(codec, TWL4030_REG_HS_POPN_SET);\r\nreg &= ~TWL4030_RAMP_DELAY;\r\nreg |= (pdata->ramp_delay_value << 2);\r\ntwl4030_write(codec, TWL4030_REG_HS_POPN_SET, reg);\r\ntwl4030_codec_enable(codec, 1);\r\nreg = twl4030_read(codec, TWL4030_REG_ANAMICL);\r\nreg &= ~TWL4030_OFFSET_CNCL_SEL;\r\nreg |= pdata->offset_cncl_path;\r\ntwl4030_write(codec, TWL4030_REG_ANAMICL,\r\nreg | TWL4030_CNCL_OFFSET_START);\r\nmsleep(20);\r\ndo {\r\nusleep_range(1000, 2000);\r\ntwl_set_regcache_bypass(TWL4030_MODULE_AUDIO_VOICE, true);\r\ntwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE, &byte,\r\nTWL4030_REG_ANAMICL);\r\ntwl_set_regcache_bypass(TWL4030_MODULE_AUDIO_VOICE, false);\r\n} while ((i++ < 100) &&\r\n((byte & TWL4030_CNCL_OFFSET_START) ==\r\nTWL4030_CNCL_OFFSET_START));\r\ntwl4030_codec_enable(codec, 0);\r\n}\r\nstatic void twl4030_apll_enable(struct snd_soc_codec *codec, int enable)\r\n{\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nif (enable) {\r\ntwl4030->apll_enabled++;\r\nif (twl4030->apll_enabled == 1)\r\ntwl4030_audio_enable_resource(\r\nTWL4030_AUDIO_RES_APLL);\r\n} else {\r\ntwl4030->apll_enabled--;\r\nif (!twl4030->apll_enabled)\r\ntwl4030_audio_disable_resource(\r\nTWL4030_AUDIO_RES_APLL);\r\n}\r\n}\r\nstatic void handsfree_ramp(struct snd_soc_codec *codec, int reg, int ramp)\r\n{\r\nunsigned char hs_ctl;\r\nhs_ctl = twl4030_read(codec, reg);\r\nif (ramp) {\r\nhs_ctl |= TWL4030_HF_CTL_REF_EN;\r\ntwl4030_write(codec, reg, hs_ctl);\r\nudelay(10);\r\nhs_ctl |= TWL4030_HF_CTL_RAMP_EN;\r\ntwl4030_write(codec, reg, hs_ctl);\r\nudelay(40);\r\nhs_ctl |= TWL4030_HF_CTL_LOOP_EN;\r\nhs_ctl |= TWL4030_HF_CTL_HB_EN;\r\ntwl4030_write(codec, reg, hs_ctl);\r\n} else {\r\nhs_ctl &= ~TWL4030_HF_CTL_LOOP_EN;\r\nhs_ctl &= ~TWL4030_HF_CTL_HB_EN;\r\ntwl4030_write(codec, reg, hs_ctl);\r\nhs_ctl &= ~TWL4030_HF_CTL_RAMP_EN;\r\ntwl4030_write(codec, reg, hs_ctl);\r\nudelay(40);\r\nhs_ctl &= ~TWL4030_HF_CTL_REF_EN;\r\ntwl4030_write(codec, reg, hs_ctl);\r\n}\r\n}\r\nstatic int handsfreelpga_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nhandsfree_ramp(codec, TWL4030_REG_HFL_CTL, 1);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nhandsfree_ramp(codec, TWL4030_REG_HFL_CTL, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int handsfreerpga_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nhandsfree_ramp(codec, TWL4030_REG_HFR_CTL, 1);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nhandsfree_ramp(codec, TWL4030_REG_HFR_CTL, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vibramux_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\ntwl4030_write(codec, TWL4030_REG_VIBRA_SET, 0xff);\r\nreturn 0;\r\n}\r\nstatic int apll_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\ntwl4030_apll_enable(codec, 1);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\ntwl4030_apll_enable(codec, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aif_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nu8 audio_if;\r\naudio_if = twl4030_read(codec, TWL4030_REG_AUDIO_IF);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\ntwl4030_apll_enable(codec, 1);\r\ntwl4030_write(codec, TWL4030_REG_AUDIO_IF,\r\naudio_if | TWL4030_AIF_EN);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\ntwl4030_write(codec, TWL4030_REG_AUDIO_IF,\r\naudio_if & ~TWL4030_AIF_EN);\r\ntwl4030_apll_enable(codec, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void headset_ramp(struct snd_soc_codec *codec, int ramp)\r\n{\r\nunsigned char hs_gain, hs_pop;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nstruct twl4030_codec_data *pdata = twl4030->pdata;\r\nunsigned int ramp_base[] = {524288, 1048576, 2097152, 4194304,\r\n8388608, 16777216, 33554432, 67108864};\r\nunsigned int delay;\r\nhs_gain = twl4030_read(codec, TWL4030_REG_HS_GAIN_SET);\r\nhs_pop = twl4030_read(codec, TWL4030_REG_HS_POPN_SET);\r\ndelay = (ramp_base[(hs_pop & TWL4030_RAMP_DELAY) >> 2] /\r\ntwl4030->sysclk) + 1;\r\nif (pdata && pdata->hs_extmute) {\r\nif (gpio_is_valid(pdata->hs_extmute_gpio)) {\r\ngpio_set_value(pdata->hs_extmute_gpio, 1);\r\n} else {\r\nhs_pop |= TWL4030_EXTMUTE;\r\ntwl4030_write(codec, TWL4030_REG_HS_POPN_SET, hs_pop);\r\n}\r\n}\r\nif (ramp) {\r\nhs_pop |= TWL4030_VMID_EN;\r\ntwl4030_write(codec, TWL4030_REG_HS_POPN_SET, hs_pop);\r\ntwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE, hs_gain,\r\nTWL4030_REG_HS_GAIN_SET);\r\nhs_pop |= TWL4030_RAMP_EN;\r\ntwl4030_write(codec, TWL4030_REG_HS_POPN_SET, hs_pop);\r\ntwl4030_wait_ms(delay);\r\n} else {\r\nhs_pop &= ~TWL4030_RAMP_EN;\r\ntwl4030_write(codec, TWL4030_REG_HS_POPN_SET, hs_pop);\r\ntwl4030_wait_ms(delay);\r\ntwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE, hs_gain & (~0x0f),\r\nTWL4030_REG_HS_GAIN_SET);\r\nhs_pop &= ~TWL4030_VMID_EN;\r\ntwl4030_write(codec, TWL4030_REG_HS_POPN_SET, hs_pop);\r\n}\r\nif (pdata && pdata->hs_extmute) {\r\nif (gpio_is_valid(pdata->hs_extmute_gpio)) {\r\ngpio_set_value(pdata->hs_extmute_gpio, 0);\r\n} else {\r\nhs_pop &= ~TWL4030_EXTMUTE;\r\ntwl4030_write(codec, TWL4030_REG_HS_POPN_SET, hs_pop);\r\n}\r\n}\r\n}\r\nstatic int headsetlpga_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (!twl4030->hsr_enabled)\r\nheadset_ramp(codec, 1);\r\ntwl4030->hsl_enabled = 1;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nif (!twl4030->hsr_enabled)\r\nheadset_ramp(codec, 0);\r\ntwl4030->hsl_enabled = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int headsetrpga_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (!twl4030->hsl_enabled)\r\nheadset_ramp(codec, 1);\r\ntwl4030->hsr_enabled = 1;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nif (!twl4030->hsl_enabled)\r\nheadset_ramp(codec, 0);\r\ntwl4030->hsr_enabled = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int digimic_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nstruct twl4030_codec_data *pdata = twl4030->pdata;\r\nif (pdata && pdata->digimic_delay)\r\ntwl4030_wait_ms(pdata->digimic_delay);\r\nreturn 0;\r\n}\r\nstatic int snd_soc_get_volsw_twl4030(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned int reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nunsigned int rshift = mc->rshift;\r\nint max = mc->max;\r\nint mask = (1 << fls(max)) - 1;\r\nucontrol->value.integer.value[0] =\r\n(snd_soc_read(codec, reg) >> shift) & mask;\r\nif (ucontrol->value.integer.value[0])\r\nucontrol->value.integer.value[0] =\r\nmax + 1 - ucontrol->value.integer.value[0];\r\nif (shift != rshift) {\r\nucontrol->value.integer.value[1] =\r\n(snd_soc_read(codec, reg) >> rshift) & mask;\r\nif (ucontrol->value.integer.value[1])\r\nucontrol->value.integer.value[1] =\r\nmax + 1 - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_soc_put_volsw_twl4030(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned int reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nunsigned int rshift = mc->rshift;\r\nint max = mc->max;\r\nint mask = (1 << fls(max)) - 1;\r\nunsigned short val, val2, val_mask;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nval_mask = mask << shift;\r\nif (val)\r\nval = max + 1 - val;\r\nval = val << shift;\r\nif (shift != rshift) {\r\nval2 = (ucontrol->value.integer.value[1] & mask);\r\nval_mask |= mask << rshift;\r\nif (val2)\r\nval2 = max + 1 - val2;\r\nval |= val2 << rshift;\r\n}\r\nreturn snd_soc_update_bits(codec, reg, val_mask, val);\r\n}\r\nstatic int snd_soc_get_volsw_r2_twl4030(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nunsigned int shift = mc->shift;\r\nint max = mc->max;\r\nint mask = (1<<fls(max))-1;\r\nucontrol->value.integer.value[0] =\r\n(snd_soc_read(codec, reg) >> shift) & mask;\r\nucontrol->value.integer.value[1] =\r\n(snd_soc_read(codec, reg2) >> shift) & mask;\r\nif (ucontrol->value.integer.value[0])\r\nucontrol->value.integer.value[0] =\r\nmax + 1 - ucontrol->value.integer.value[0];\r\nif (ucontrol->value.integer.value[1])\r\nucontrol->value.integer.value[1] =\r\nmax + 1 - ucontrol->value.integer.value[1];\r\nreturn 0;\r\n}\r\nstatic int snd_soc_put_volsw_r2_twl4030(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nunsigned int shift = mc->shift;\r\nint max = mc->max;\r\nint mask = (1 << fls(max)) - 1;\r\nint err;\r\nunsigned short val, val2, val_mask;\r\nval_mask = mask << shift;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nval2 = (ucontrol->value.integer.value[1] & mask);\r\nif (val)\r\nval = max + 1 - val;\r\nif (val2)\r\nval2 = max + 1 - val2;\r\nval = val << shift;\r\nval2 = val2 << shift;\r\nerr = snd_soc_update_bits(codec, reg, val_mask, val);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_soc_update_bits(codec, reg2, val_mask, val2);\r\nreturn err;\r\n}\r\nstatic int snd_soc_put_twl4030_opmode_enum_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nif (twl4030->configured) {\r\ndev_err(codec->dev,\r\n"operation mode cannot be changed on-the-fly\n");\r\nreturn -EBUSY;\r\n}\r\nreturn snd_soc_put_enum_double(kcontrol, ucontrol);\r\n}\r\nstatic int twl4030_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF)\r\ntwl4030_codec_enable(codec, 1);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\ntwl4030_codec_enable(codec, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void twl4030_constraints(struct twl4030_priv *twl4030,\r\nstruct snd_pcm_substream *mst_substream)\r\n{\r\nstruct snd_pcm_substream *slv_substream;\r\nif (mst_substream == twl4030->master_substream)\r\nslv_substream = twl4030->slave_substream;\r\nelse if (mst_substream == twl4030->slave_substream)\r\nslv_substream = twl4030->master_substream;\r\nelse\r\nreturn;\r\nsnd_pcm_hw_constraint_single(slv_substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\ntwl4030->rate);\r\nsnd_pcm_hw_constraint_single(slv_substream->runtime,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS,\r\ntwl4030->sample_bits);\r\nsnd_pcm_hw_constraint_single(slv_substream->runtime,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\ntwl4030->channels);\r\n}\r\nstatic void twl4030_tdm_enable(struct snd_soc_codec *codec, int direction,\r\nint enable)\r\n{\r\nu8 reg, mask;\r\nreg = twl4030_read(codec, TWL4030_REG_OPTION);\r\nif (direction == SNDRV_PCM_STREAM_PLAYBACK)\r\nmask = TWL4030_ARXL1_VRX_EN | TWL4030_ARXR1_EN;\r\nelse\r\nmask = TWL4030_ATXL2_VTXL_EN | TWL4030_ATXR2_VTXR_EN;\r\nif (enable)\r\nreg |= mask;\r\nelse\r\nreg &= ~mask;\r\ntwl4030_write(codec, TWL4030_REG_OPTION, reg);\r\n}\r\nstatic int twl4030_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nif (twl4030->master_substream) {\r\ntwl4030->slave_substream = substream;\r\nif (twl4030->configured)\r\ntwl4030_constraints(twl4030, twl4030->master_substream);\r\n} else {\r\nif (!(twl4030_read(codec, TWL4030_REG_CODEC_MODE) &\r\nTWL4030_OPTION_1)) {\r\nsnd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n2);\r\n}\r\ntwl4030->master_substream = substream;\r\n}\r\nreturn 0;\r\n}\r\nstatic void twl4030_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nif (twl4030->master_substream == substream)\r\ntwl4030->master_substream = twl4030->slave_substream;\r\ntwl4030->slave_substream = NULL;\r\nif (!twl4030->master_substream)\r\ntwl4030->configured = 0;\r\nelse if (!twl4030->master_substream->runtime->channels)\r\ntwl4030->configured = 0;\r\nif (substream->runtime->channels == 4)\r\ntwl4030_tdm_enable(codec, substream->stream, 0);\r\n}\r\nstatic int twl4030_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nu8 mode, old_mode, format, old_format;\r\nif (params_channels(params) == 4) {\r\nformat = twl4030_read(codec, TWL4030_REG_AUDIO_IF);\r\nmode = twl4030_read(codec, TWL4030_REG_CODEC_MODE);\r\nif ((mode & TWL4030_OPTION_1) &&\r\n((format & TWL4030_AIF_FORMAT) == TWL4030_AIF_FORMAT_TDM))\r\ntwl4030_tdm_enable(codec, substream->stream, 1);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (twl4030->configured)\r\nreturn 0;\r\nold_mode = twl4030_read(codec,\r\nTWL4030_REG_CODEC_MODE) & ~TWL4030_CODECPDZ;\r\nmode = old_mode & ~TWL4030_APLL_RATE;\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nmode |= TWL4030_APLL_RATE_8000;\r\nbreak;\r\ncase 11025:\r\nmode |= TWL4030_APLL_RATE_11025;\r\nbreak;\r\ncase 12000:\r\nmode |= TWL4030_APLL_RATE_12000;\r\nbreak;\r\ncase 16000:\r\nmode |= TWL4030_APLL_RATE_16000;\r\nbreak;\r\ncase 22050:\r\nmode |= TWL4030_APLL_RATE_22050;\r\nbreak;\r\ncase 24000:\r\nmode |= TWL4030_APLL_RATE_24000;\r\nbreak;\r\ncase 32000:\r\nmode |= TWL4030_APLL_RATE_32000;\r\nbreak;\r\ncase 44100:\r\nmode |= TWL4030_APLL_RATE_44100;\r\nbreak;\r\ncase 48000:\r\nmode |= TWL4030_APLL_RATE_48000;\r\nbreak;\r\ncase 96000:\r\nmode |= TWL4030_APLL_RATE_96000;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "%s: unknown rate %d\n", __func__,\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nold_format = twl4030_read(codec, TWL4030_REG_AUDIO_IF);\r\nformat = old_format;\r\nformat &= ~TWL4030_DATA_WIDTH;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nformat |= TWL4030_DATA_WIDTH_16S_16W;\r\nbreak;\r\ncase 32:\r\nformat |= TWL4030_DATA_WIDTH_32S_24W;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "%s: unsupported bits/sample %d\n",\r\n__func__, params_width(params));\r\nreturn -EINVAL;\r\n}\r\nif (format != old_format || mode != old_mode) {\r\nif (twl4030->codec_powered) {\r\ntwl4030_codec_enable(codec, 0);\r\ntwl4030_write(codec, TWL4030_REG_CODEC_MODE, mode);\r\ntwl4030_write(codec, TWL4030_REG_AUDIO_IF, format);\r\ntwl4030_codec_enable(codec, 1);\r\n} else {\r\ntwl4030_write(codec, TWL4030_REG_CODEC_MODE, mode);\r\ntwl4030_write(codec, TWL4030_REG_AUDIO_IF, format);\r\n}\r\n}\r\ntwl4030->configured = 1;\r\ntwl4030->rate = params_rate(params);\r\ntwl4030->sample_bits = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min;\r\ntwl4030->channels = params_channels(params);\r\nif (twl4030->slave_substream)\r\ntwl4030_constraints(twl4030, substream);\r\nreturn 0;\r\n}\r\nstatic int twl4030_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nswitch (freq) {\r\ncase 19200000:\r\ncase 26000000:\r\ncase 38400000:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported HFCLKIN: %u\n", freq);\r\nreturn -EINVAL;\r\n}\r\nif ((freq / 1000) != twl4030->sysclk) {\r\ndev_err(codec->dev,\r\n"Mismatch in HFCLKIN: %u (configured: %u)\n",\r\nfreq, twl4030->sysclk * 1000);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nu8 old_format, format;\r\nold_format = twl4030_read(codec, TWL4030_REG_AUDIO_IF);\r\nformat = old_format;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nformat &= ~(TWL4030_AIF_SLAVE_EN);\r\nformat &= ~(TWL4030_CLK256FS_EN);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nformat |= TWL4030_AIF_SLAVE_EN;\r\nformat |= TWL4030_CLK256FS_EN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nformat &= ~TWL4030_AIF_FORMAT;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nformat |= TWL4030_AIF_FORMAT_CODEC;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nformat |= TWL4030_AIF_FORMAT_TDM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (format != old_format) {\r\nif (twl4030->codec_powered) {\r\ntwl4030_codec_enable(codec, 0);\r\ntwl4030_write(codec, TWL4030_REG_AUDIO_IF, format);\r\ntwl4030_codec_enable(codec, 1);\r\n} else {\r\ntwl4030_write(codec, TWL4030_REG_AUDIO_IF, format);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 reg = twl4030_read(codec, TWL4030_REG_AUDIO_IF);\r\nif (tristate)\r\nreg |= TWL4030_AIF_TRI_EN;\r\nelse\r\nreg &= ~TWL4030_AIF_TRI_EN;\r\nreturn twl4030_write(codec, TWL4030_REG_AUDIO_IF, reg);\r\n}\r\nstatic void twl4030_voice_enable(struct snd_soc_codec *codec, int direction,\r\nint enable)\r\n{\r\nu8 reg, mask;\r\nreg = twl4030_read(codec, TWL4030_REG_OPTION);\r\nif (direction == SNDRV_PCM_STREAM_PLAYBACK)\r\nmask = TWL4030_ARXL1_VRX_EN;\r\nelse\r\nmask = TWL4030_ATXL2_VTXL_EN | TWL4030_ATXR2_VTXR_EN;\r\nif (enable)\r\nreg |= mask;\r\nelse\r\nreg &= ~mask;\r\ntwl4030_write(codec, TWL4030_REG_OPTION, reg);\r\n}\r\nstatic int twl4030_voice_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nu8 mode;\r\nif (twl4030->sysclk != 26000) {\r\ndev_err(codec->dev,\r\n"%s: HFCLKIN is %u KHz, voice interface needs 26MHz\n",\r\n__func__, twl4030->sysclk);\r\nreturn -EINVAL;\r\n}\r\nmode = twl4030_read(codec, TWL4030_REG_CODEC_MODE)\r\n& TWL4030_OPT_MODE;\r\nif (mode != TWL4030_OPTION_2) {\r\ndev_err(codec->dev, "%s: the codec mode is not option2\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void twl4030_voice_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\ntwl4030_voice_enable(codec, substream->stream, 0);\r\n}\r\nstatic int twl4030_voice_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nu8 old_mode, mode;\r\ntwl4030_voice_enable(codec, substream->stream, 1);\r\nold_mode = twl4030_read(codec,\r\nTWL4030_REG_CODEC_MODE) & ~TWL4030_CODECPDZ;\r\nmode = old_mode;\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nmode &= ~(TWL4030_SEL_16K);\r\nbreak;\r\ncase 16000:\r\nmode |= TWL4030_SEL_16K;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "%s: unknown rate %d\n", __func__,\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nif (mode != old_mode) {\r\nif (twl4030->codec_powered) {\r\ntwl4030_codec_enable(codec, 0);\r\ntwl4030_write(codec, TWL4030_REG_CODEC_MODE, mode);\r\ntwl4030_codec_enable(codec, 1);\r\n} else {\r\ntwl4030_write(codec, TWL4030_REG_CODEC_MODE, mode);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_voice_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nif (freq != 26000000) {\r\ndev_err(codec->dev,\r\n"%s: HFCLKIN is %u KHz, voice interface needs 26MHz\n",\r\n__func__, freq / 1000);\r\nreturn -EINVAL;\r\n}\r\nif ((freq / 1000) != twl4030->sysclk) {\r\ndev_err(codec->dev,\r\n"Mismatch in HFCLKIN: %u (configured: %u)\n",\r\nfreq, twl4030->sysclk * 1000);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_voice_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nu8 old_format, format;\r\nold_format = twl4030_read(codec, TWL4030_REG_VOICE_IF);\r\nformat = old_format;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nformat &= ~(TWL4030_VIF_SLAVE_EN);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nformat |= TWL4030_VIF_SLAVE_EN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nformat &= ~(TWL4030_VIF_FORMAT);\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nformat |= TWL4030_VIF_FORMAT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (format != old_format) {\r\nif (twl4030->codec_powered) {\r\ntwl4030_codec_enable(codec, 0);\r\ntwl4030_write(codec, TWL4030_REG_VOICE_IF, format);\r\ntwl4030_codec_enable(codec, 1);\r\n} else {\r\ntwl4030_write(codec, TWL4030_REG_VOICE_IF, format);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_voice_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 reg = twl4030_read(codec, TWL4030_REG_VOICE_IF);\r\nif (tristate)\r\nreg |= TWL4030_VIF_TRI_EN;\r\nelse\r\nreg &= ~TWL4030_VIF_TRI_EN;\r\nreturn twl4030_write(codec, TWL4030_REG_VOICE_IF, reg);\r\n}\r\nstatic int twl4030_soc_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct twl4030_priv *twl4030;\r\ntwl4030 = devm_kzalloc(codec->dev, sizeof(struct twl4030_priv),\r\nGFP_KERNEL);\r\nif (!twl4030)\r\nreturn -ENOMEM;\r\nsnd_soc_codec_set_drvdata(codec, twl4030);\r\ntwl4030->sysclk = twl4030_audio_get_mclk() / 1000;\r\ntwl4030_init_chip(codec);\r\nreturn 0;\r\n}\r\nstatic int twl4030_soc_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\r\nstruct twl4030_codec_data *pdata = twl4030->pdata;\r\nif (pdata && pdata->hs_extmute && gpio_is_valid(pdata->hs_extmute_gpio))\r\ngpio_free(pdata->hs_extmute_gpio);\r\nreturn 0;\r\n}\r\nstatic int twl4030_codec_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev, &soc_codec_dev_twl4030,\r\ntwl4030_dai, ARRAY_SIZE(twl4030_dai));\r\n}\r\nstatic int twl4030_codec_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
