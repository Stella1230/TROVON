static inline bool i2c_safe_reg(unsigned char reg)\r\n{\r\nswitch (reg) {\r\ncase DA9052_STATUS_A_REG:\r\ncase DA9052_STATUS_B_REG:\r\ncase DA9052_STATUS_C_REG:\r\ncase DA9052_STATUS_D_REG:\r\ncase DA9052_ADC_RES_L_REG:\r\ncase DA9052_ADC_RES_H_REG:\r\ncase DA9052_VDD_RES_REG:\r\ncase DA9052_ICHG_AV_REG:\r\ncase DA9052_TBAT_RES_REG:\r\ncase DA9052_ADCIN4_RES_REG:\r\ncase DA9052_ADCIN5_RES_REG:\r\ncase DA9052_ADCIN6_RES_REG:\r\ncase DA9052_TJUNC_RES_REG:\r\ncase DA9052_TSI_X_MSB_REG:\r\ncase DA9052_TSI_Y_MSB_REG:\r\ncase DA9052_TSI_LSB_REG:\r\ncase DA9052_TSI_Z_MSB_REG:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int da9052_i2c_fix(struct da9052 *da9052, unsigned char reg)\r\n{\r\nint val;\r\nswitch (da9052->chip_id) {\r\ncase DA9052:\r\ncase DA9053_AA:\r\ncase DA9053_BA:\r\ncase DA9053_BB:\r\nif (!i2c_safe_reg(reg))\r\nreturn regmap_read(da9052->regmap,\r\nDA9052_PARK_REGISTER,\r\n&val);\r\nbreak;\r\ncase DA9053_BC:\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da9052_i2c_disable_multiwrite(struct da9052 *da9052)\r\n{\r\nint reg_val, ret;\r\nret = regmap_read(da9052->regmap, DA9052_CONTROL_B_REG, &reg_val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(reg_val & DA9052_CONTROL_B_WRITEMODE)) {\r\nreg_val |= DA9052_CONTROL_B_WRITEMODE;\r\nret = regmap_write(da9052->regmap, DA9052_CONTROL_B_REG,\r\nreg_val);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da9052_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct da9052 *da9052;\r\nint ret;\r\nda9052 = devm_kzalloc(&client->dev, sizeof(struct da9052), GFP_KERNEL);\r\nif (!da9052)\r\nreturn -ENOMEM;\r\nda9052->dev = &client->dev;\r\nda9052->chip_irq = client->irq;\r\nda9052->fix_io = da9052_i2c_fix;\r\ni2c_set_clientdata(client, da9052);\r\nda9052->regmap = devm_regmap_init_i2c(client, &da9052_regmap_config);\r\nif (IS_ERR(da9052->regmap)) {\r\nret = PTR_ERR(da9052->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = da9052_i2c_disable_multiwrite(da9052);\r\nif (ret < 0)\r\nreturn ret;\r\n#ifdef CONFIG_OF\r\nif (!id) {\r\nstruct device_node *np = client->dev.of_node;\r\nconst struct of_device_id *deviceid;\r\ndeviceid = of_match_node(dialog_dt_ids, np);\r\nid = deviceid->data;\r\n}\r\n#endif\r\nif (!id) {\r\nret = -ENODEV;\r\ndev_err(&client->dev, "id is null.\n");\r\nreturn ret;\r\n}\r\nreturn da9052_device_init(da9052, id->driver_data);\r\n}\r\nstatic int da9052_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct da9052 *da9052 = i2c_get_clientdata(client);\r\nda9052_device_exit(da9052);\r\nreturn 0;\r\n}\r\nstatic int __init da9052_i2c_init(void)\r\n{\r\nint ret;\r\nret = i2c_add_driver(&da9052_i2c_driver);\r\nif (ret != 0) {\r\npr_err("DA9052 I2C registration failed %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit da9052_i2c_exit(void)\r\n{\r\ni2c_del_driver(&da9052_i2c_driver);\r\n}
