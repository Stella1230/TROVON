static irqreturn_t uni_reader_irq_handler(int irq, void *dev_id)\r\n{\r\nirqreturn_t ret = IRQ_NONE;\r\nstruct uniperif *reader = dev_id;\r\nunsigned int status;\r\nif (reader->state == UNIPERIF_STATE_STOPPED) {\r\ndev_warn(reader->dev, "unexpected IRQ ");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatus = GET_UNIPERIF_ITS(reader);\r\nSET_UNIPERIF_ITS_BCLR(reader, status);\r\nif (unlikely(status & UNIPERIF_ITS_FIFO_ERROR_MASK(reader))) {\r\ndev_err(reader->dev, "FIFO error detected");\r\nsnd_pcm_stream_lock(reader->substream);\r\nsnd_pcm_stop(reader->substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock(reader->substream);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int uni_reader_prepare_pcm(struct snd_pcm_runtime *runtime,\r\nstruct uniperif *reader)\r\n{\r\nint slot_width;\r\nif ((reader->daifmt & SND_SOC_DAIFMT_FORMAT_MASK)\r\n== SND_SOC_DAIFMT_I2S) {\r\nslot_width = 32;\r\n} else {\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nslot_width = 16;\r\nbreak;\r\ndefault:\r\nslot_width = 32;\r\nbreak;\r\n}\r\n}\r\nswitch (slot_width) {\r\ncase 32:\r\nSET_UNIPERIF_I2S_FMT_NBIT_32(reader);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_32(reader);\r\nbreak;\r\ncase 16:\r\nSET_UNIPERIF_I2S_FMT_NBIT_16(reader);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_16(reader);\r\nbreak;\r\ndefault:\r\ndev_err(reader->dev, "subframe format not supported");\r\nreturn -EINVAL;\r\n}\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_16(reader);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_0(reader);\r\nbreak;\r\ndefault:\r\ndev_err(reader->dev, "format not supported");\r\nreturn -EINVAL;\r\n}\r\nif ((runtime->channels % 2) || (runtime->channels < 2) ||\r\n(runtime->channels > 10)) {\r\ndev_err(reader->dev, "%s: invalid nb of channels", __func__);\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_I2S_FMT_NUM_CH(reader, runtime->channels / 2);\r\nSET_UNIPERIF_I2S_FMT_ORDER_MSB(reader);\r\nreturn 0;\r\n}\r\nstatic int uni_reader_prepare_tdm(struct snd_pcm_runtime *runtime,\r\nstruct uniperif *reader)\r\n{\r\nint frame_size;\r\nunsigned int word_pos[4] = {\r\n0x04060002, 0x0C0E080A, 0x14161012, 0x1C1E181A};\r\nframe_size = sti_uniperiph_get_user_frame_size(runtime);\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_0(reader);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_32(reader);\r\nSET_UNIPERIF_I2S_FMT_NUM_CH(reader, frame_size / 4 / 2);\r\nSET_UNIPERIF_I2S_FMT_ORDER_MSB(reader);\r\nSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(reader);\r\nSET_UNIPERIF_TDM_ENABLE_TDM_ENABLE(reader);\r\nsti_uniperiph_get_tdm_word_pos(reader, word_pos);\r\nSET_UNIPERIF_TDM_WORD_POS(reader, 1_2, word_pos[WORD_1_2]);\r\nSET_UNIPERIF_TDM_WORD_POS(reader, 3_4, word_pos[WORD_3_4]);\r\nSET_UNIPERIF_TDM_WORD_POS(reader, 5_6, word_pos[WORD_5_6]);\r\nSET_UNIPERIF_TDM_WORD_POS(reader, 7_8, word_pos[WORD_7_8]);\r\nreturn 0;\r\n}\r\nstatic int uni_reader_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *reader = priv->dai_data.uni;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint transfer_size, trigger_limit, ret;\r\nint count = 10;\r\nif (reader->state != UNIPERIF_STATE_STOPPED) {\r\ndev_err(reader->dev, "%s: invalid reader state %d", __func__,\r\nreader->state);\r\nreturn -EINVAL;\r\n}\r\nif (reader->info->type == SND_ST_UNIPERIF_TYPE_TDM) {\r\ntransfer_size =\r\nsti_uniperiph_get_user_frame_size(runtime) / 4;\r\n} else {\r\ntransfer_size = runtime->channels * UNIPERIF_FIFO_FRAMES;\r\n}\r\nif (reader->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\ntrigger_limit = UNIPERIF_FIFO_SIZE - transfer_size;\r\nelse\r\ntrigger_limit = transfer_size;\r\nif ((!trigger_limit % 2) ||\r\n(trigger_limit != 1 && transfer_size % 2) ||\r\n(trigger_limit > UNIPERIF_CONFIG_DMA_TRIG_LIMIT_MASK(reader))) {\r\ndev_err(reader->dev, "invalid trigger limit %d", trigger_limit);\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_CONFIG_DMA_TRIG_LIMIT(reader, trigger_limit);\r\nif (UNIPERIF_TYPE_IS_TDM(reader))\r\nret = uni_reader_prepare_tdm(runtime, reader);\r\nelse\r\nret = uni_reader_prepare_pcm(runtime, reader);\r\nif (ret)\r\nreturn ret;\r\nswitch (reader->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(reader);\r\nSET_UNIPERIF_I2S_FMT_PADDING_I2S_MODE(reader);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(reader);\r\nSET_UNIPERIF_I2S_FMT_PADDING_SONY_MODE(reader);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nSET_UNIPERIF_I2S_FMT_ALIGN_RIGHT(reader);\r\nSET_UNIPERIF_I2S_FMT_PADDING_SONY_MODE(reader);\r\nbreak;\r\ndefault:\r\ndev_err(reader->dev, "format not supported");\r\nreturn -EINVAL;\r\n}\r\nswitch (reader->daifmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_LOW(reader);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_RISING(reader);\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_HIG(reader);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_RISING(reader);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_LOW(reader);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(reader);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_HIG(reader);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(reader);\r\nbreak;\r\n}\r\nSET_UNIPERIF_ITS_BCLR(reader, GET_UNIPERIF_ITS(reader));\r\nSET_UNIPERIF_I2S_FMT_NO_OF_SAMPLES_TO_READ(reader, 0);\r\nSET_UNIPERIF_ITM_BSET_DMA_ERROR(reader);\r\nSET_UNIPERIF_ITM_BSET_FIFO_ERROR(reader);\r\nSET_UNIPERIF_ITM_BSET_MEM_BLK_READ(reader);\r\nif (reader->info->underflow_enabled) {\r\nSET_UNIPERIF_ITM_BSET_UNDERFLOW_REC_DONE(reader);\r\nSET_UNIPERIF_ITM_BSET_UNDERFLOW_REC_FAILED(reader);\r\n}\r\nSET_UNIPERIF_SOFT_RST_SOFT_RST(reader);\r\nwhile (GET_UNIPERIF_SOFT_RST_SOFT_RST(reader)) {\r\nudelay(5);\r\ncount--;\r\n}\r\nif (!count) {\r\ndev_err(reader->dev, "Failed to reset uniperif");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uni_reader_start(struct uniperif *reader)\r\n{\r\nif (reader->state != UNIPERIF_STATE_STOPPED) {\r\ndev_err(reader->dev, "%s: invalid reader state", __func__);\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_ITS_BCLR_FIFO_ERROR(reader);\r\nSET_UNIPERIF_ITM_BSET_FIFO_ERROR(reader);\r\nSET_UNIPERIF_CTRL_OPERATION_PCM_DATA(reader);\r\nreader->state = UNIPERIF_STATE_STARTED;\r\nreturn 0;\r\n}\r\nstatic int uni_reader_stop(struct uniperif *reader)\r\n{\r\nif (reader->state == UNIPERIF_STATE_STOPPED) {\r\ndev_err(reader->dev, "%s: invalid reader state", __func__);\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_CTRL_OPERATION_OFF(reader);\r\nSET_UNIPERIF_ITM_BCLR(reader, GET_UNIPERIF_ITM(reader));\r\nreader->state = UNIPERIF_STATE_STOPPED;\r\nreturn 0;\r\n}\r\nstatic int uni_reader_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *reader = priv->dai_data.uni;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nreturn uni_reader_start(reader);\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nreturn uni_reader_stop(reader);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int uni_reader_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *reader = priv->dai_data.uni;\r\nint ret;\r\nif (!UNIPERIF_TYPE_IS_TDM(reader))\r\nreturn 0;\r\nret = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nsti_uniperiph_fix_tdm_chan,\r\nreader, SNDRV_PCM_HW_PARAM_CHANNELS,\r\n-1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_FORMAT,\r\nsti_uniperiph_fix_tdm_format,\r\nreader, SNDRV_PCM_HW_PARAM_FORMAT,\r\n-1);\r\n}\r\nstatic void uni_reader_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *reader = priv->dai_data.uni;\r\nif (reader->state != UNIPERIF_STATE_STOPPED) {\r\nuni_reader_stop(reader);\r\n}\r\n}\r\nstatic int uni_reader_parse_dt(struct platform_device *pdev,\r\nstruct uniperif *reader)\r\n{\r\nstruct uniperif_info *info;\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst char *mode;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(node, "st,version", &reader->ver) ||\r\nreader->ver == SND_ST_UNIPERIF_VERSION_UNKNOWN) {\r\ndev_err(&pdev->dev, "Unknown uniperipheral version ");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_string(node, "st,mode", &mode)) {\r\ndev_err(&pdev->dev, "uniperipheral mode not defined");\r\nreturn -EINVAL;\r\n}\r\nif (strcasecmp(mode, "tdm") == 0)\r\ninfo->type = SND_ST_UNIPERIF_TYPE_TDM;\r\nelse\r\ninfo->type = SND_ST_UNIPERIF_TYPE_PCM;\r\nreader->info = info;\r\nreturn 0;\r\n}\r\nint uni_reader_init(struct platform_device *pdev,\r\nstruct uniperif *reader)\r\n{\r\nint ret = 0;\r\nreader->dev = &pdev->dev;\r\nreader->state = UNIPERIF_STATE_STOPPED;\r\nreader->dai_ops = &uni_reader_dai_ops;\r\nret = uni_reader_parse_dt(pdev, reader);\r\nif (ret < 0) {\r\ndev_err(reader->dev, "Failed to parse DeviceTree");\r\nreturn ret;\r\n}\r\nif (UNIPERIF_TYPE_IS_TDM(reader))\r\nreader->hw = &uni_tdm_hw;\r\nelse\r\nreader->hw = &uni_reader_pcm_hw;\r\nret = devm_request_irq(&pdev->dev, reader->irq,\r\nuni_reader_irq_handler, IRQF_SHARED,\r\ndev_name(&pdev->dev), reader);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to request IRQ");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}
