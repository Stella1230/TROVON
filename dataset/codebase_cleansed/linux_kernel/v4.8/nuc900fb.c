static void nuc900fb_set_lcdaddr(struct fb_info *info)\r\n{\r\nstruct nuc900fb_info *fbi = info->par;\r\nvoid __iomem *regs = fbi->io;\r\nunsigned long vbaddr1, vbaddr2;\r\nvbaddr1 = info->fix.smem_start;\r\nvbaddr2 = info->fix.smem_start;\r\nvbaddr2 += info->fix.line_length * info->var.yres;\r\nwritel(vbaddr1, regs + REG_LCM_VA_BADDR0);\r\nwritel(vbaddr2, regs + REG_LCM_VA_BADDR1);\r\nwritel(fbi->regs.lcd_va_fbctrl, regs + REG_LCM_VA_FBCTRL);\r\nwritel(fbi->regs.lcd_va_scale, regs + REG_LCM_VA_SCALE);\r\n}\r\nstatic unsigned int nuc900fb_calc_pixclk(struct nuc900fb_info *fbi,\r\nunsigned long pixclk)\r\n{\r\nunsigned long clk = fbi->clk_rate;\r\nunsigned long long div;\r\ndiv = (unsigned long long)clk * pixclk;\r\ndiv >>= 12;\r\ndo_div(div, 625 * 625UL * 625);\r\ndev_dbg(fbi->dev, "pixclk %ld, divisor is %lld\n", pixclk, div);\r\nreturn div;\r\n}\r\nstatic int nuc900fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct nuc900fb_info *fbi = info->par;\r\nstruct nuc900fb_mach_info *mach_info = dev_get_platdata(fbi->dev);\r\nstruct nuc900fb_display *display = NULL;\r\nstruct nuc900fb_display *default_display = mach_info->displays +\r\nmach_info->default_display;\r\nint i;\r\ndev_dbg(fbi->dev, "check_var(var=%p, info=%p)\n", var, info);\r\nif (var->xres == default_display->xres &&\r\nvar->yres == default_display->yres &&\r\nvar->bits_per_pixel == default_display->bpp)\r\ndisplay = default_display;\r\nelse\r\nfor (i = 0; i < mach_info->num_displays; i++)\r\nif (var->xres == mach_info->displays[i].xres &&\r\nvar->yres == mach_info->displays[i].yres &&\r\nvar->bits_per_pixel == mach_info->displays[i].bpp) {\r\ndisplay = mach_info->displays + i;\r\nbreak;\r\n}\r\nif (display == NULL) {\r\nprintk(KERN_ERR "wrong resolution or depth %dx%d at %d bit per pixel\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nvar->xres_virtual = display->xres;\r\nvar->yres_virtual = display->yres;\r\nvar->height = display->height;\r\nvar->width = display->width;\r\nvar->pixclock = display->pixclock;\r\nvar->left_margin = display->left_margin;\r\nvar->right_margin = display->right_margin;\r\nvar->upper_margin = display->upper_margin;\r\nvar->lower_margin = display->lower_margin;\r\nvar->vsync_len = display->vsync_len;\r\nvar->hsync_len = display->hsync_len;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nfbi->regs.lcd_dccs = display->dccs;\r\nfbi->regs.lcd_device_ctrl = display->devctl;\r\nfbi->regs.lcd_va_fbctrl = display->fbctrl;\r\nfbi->regs.lcd_va_scale = display->scale;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\ndefault:\r\nvar->red.offset = 0;\r\nvar->red.length = var->bits_per_pixel;\r\nvar->green = var->red;\r\nvar->blue = var->red;\r\nbreak;\r\ncase 12:\r\nvar->red.length = 4;\r\nvar->green.length = 4;\r\nvar->blue.length = 4;\r\nvar->red.offset = 8;\r\nvar->green.offset = 4;\r\nvar->blue.offset = 0;\r\nbreak;\r\ncase 16:\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nbreak;\r\ncase 18:\r\nvar->red.length = 6;\r\nvar->green.length = 6;\r\nvar->blue.length = 6;\r\nvar->red.offset = 12;\r\nvar->green.offset = 6;\r\nvar->blue.offset = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nuc900fb_calculate_lcd_regs(const struct fb_info *info,\r\nstruct nuc900fb_hw *regs)\r\n{\r\nconst struct fb_var_screeninfo *var = &info->var;\r\nint vtt = var->height + var->upper_margin + var->lower_margin;\r\nint htt = var->width + var->left_margin + var->right_margin;\r\nint hsync = var->width + var->right_margin;\r\nint vsync = var->height + var->lower_margin;\r\nregs->lcd_crtc_size = LCM_CRTC_SIZE_VTTVAL(vtt) |\r\nLCM_CRTC_SIZE_HTTVAL(htt);\r\nregs->lcd_crtc_dend = LCM_CRTC_DEND_VDENDVAL(var->height) |\r\nLCM_CRTC_DEND_HDENDVAL(var->width);\r\nregs->lcd_crtc_hr = LCM_CRTC_HR_EVAL(var->width + 5) |\r\nLCM_CRTC_HR_SVAL(var->width + 1);\r\nregs->lcd_crtc_hsync = LCM_CRTC_HSYNC_EVAL(hsync + var->hsync_len) |\r\nLCM_CRTC_HSYNC_SVAL(hsync);\r\nregs->lcd_crtc_vr = LCM_CRTC_VR_EVAL(vsync + var->vsync_len) |\r\nLCM_CRTC_VR_SVAL(vsync);\r\n}\r\nstatic void nuc900fb_activate_var(struct fb_info *info)\r\n{\r\nstruct nuc900fb_info *fbi = info->par;\r\nvoid __iomem *regs = fbi->io;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nint clkdiv;\r\nclkdiv = nuc900fb_calc_pixclk(fbi, var->pixclock) - 1;\r\nif (clkdiv < 0)\r\nclkdiv = 0;\r\nnuc900fb_calculate_lcd_regs(info, &fbi->regs);\r\ndev_dbg(fbi->dev, "new lcd register set:\n");\r\ndev_dbg(fbi->dev, "dccs = 0x%08x\n", fbi->regs.lcd_dccs);\r\ndev_dbg(fbi->dev, "dev_ctl = 0x%08x\n", fbi->regs.lcd_device_ctrl);\r\ndev_dbg(fbi->dev, "crtc_size = 0x%08x\n", fbi->regs.lcd_crtc_size);\r\ndev_dbg(fbi->dev, "crtc_dend = 0x%08x\n", fbi->regs.lcd_crtc_dend);\r\ndev_dbg(fbi->dev, "crtc_hr = 0x%08x\n", fbi->regs.lcd_crtc_hr);\r\ndev_dbg(fbi->dev, "crtc_hsync = 0x%08x\n", fbi->regs.lcd_crtc_hsync);\r\ndev_dbg(fbi->dev, "crtc_vr = 0x%08x\n", fbi->regs.lcd_crtc_vr);\r\nwritel(fbi->regs.lcd_device_ctrl, regs + REG_LCM_DEV_CTRL);\r\nwritel(fbi->regs.lcd_crtc_size, regs + REG_LCM_CRTC_SIZE);\r\nwritel(fbi->regs.lcd_crtc_dend, regs + REG_LCM_CRTC_DEND);\r\nwritel(fbi->regs.lcd_crtc_hr, regs + REG_LCM_CRTC_HR);\r\nwritel(fbi->regs.lcd_crtc_hsync, regs + REG_LCM_CRTC_HSYNC);\r\nwritel(fbi->regs.lcd_crtc_vr, regs + REG_LCM_CRTC_VR);\r\nnuc900fb_set_lcdaddr(info);\r\nwritel(fbi->regs.lcd_dccs, regs + REG_LCM_DCCS);\r\n}\r\nstatic int nuc900fb_set_par(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nswitch (var->bits_per_pixel) {\r\ncase 32:\r\ncase 24:\r\ncase 18:\r\ncase 16:\r\ncase 12:\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ncase 1:\r\ninfo->fix.visual = FB_VISUAL_MONO01;\r\nbreak;\r\ndefault:\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\n}\r\ninfo->fix.line_length = (var->xres_virtual * var->bits_per_pixel) / 8;\r\nnuc900fb_activate_var(info);\r\nreturn 0;\r\n}\r\nstatic inline unsigned int chan_to_field(unsigned int chan,\r\nstruct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int nuc900fb_setcolreg(unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nunsigned int val;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = info->pseudo_palette;\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = val;\r\n}\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nuc900fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void modify_gpio(void __iomem *reg,\r\nunsigned long set, unsigned long mask)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(reg) & ~mask;\r\nwritel(tmp | set, reg);\r\n}\r\nstatic int nuc900fb_init_registers(struct fb_info *info)\r\n{\r\nstruct nuc900fb_info *fbi = info->par;\r\nstruct nuc900fb_mach_info *mach_info = dev_get_platdata(fbi->dev);\r\nvoid __iomem *regs = fbi->io;\r\nwritel(0, regs + REG_LCM_DCCS);\r\nwritel(readl(regs + REG_LCM_DCCS) | LCM_DCCS_ENG_RST,\r\nregs + REG_LCM_DCCS);\r\nndelay(100);\r\nwritel(readl(regs + REG_LCM_DCCS) & (~LCM_DCCS_ENG_RST),\r\nregs + REG_LCM_DCCS);\r\nndelay(100);\r\nwritel(0, regs + REG_LCM_DEV_CTRL);\r\nmodify_gpio(W90X900_VA_GPIO + 0x54, mach_info->gpio_dir,\r\nmach_info->gpio_dir_mask);\r\nmodify_gpio(W90X900_VA_GPIO + 0x58, mach_info->gpio_data,\r\nmach_info->gpio_data_mask);\r\nreturn 0;\r\n}\r\nstatic int nuc900fb_map_video_memory(struct fb_info *info)\r\n{\r\nstruct nuc900fb_info *fbi = info->par;\r\ndma_addr_t map_dma;\r\nunsigned long map_size = PAGE_ALIGN(info->fix.smem_len);\r\ndev_dbg(fbi->dev, "nuc900fb_map_video_memory(fbi=%p) map_size %lu\n",\r\nfbi, map_size);\r\ninfo->screen_base = dma_alloc_wc(fbi->dev, map_size, &map_dma,\r\nGFP_KERNEL);\r\nif (!info->screen_base)\r\nreturn -ENOMEM;\r\nmemset(info->screen_base, 0x00, map_size);\r\ninfo->fix.smem_start = map_dma;\r\nreturn 0;\r\n}\r\nstatic inline void nuc900fb_unmap_video_memory(struct fb_info *info)\r\n{\r\nstruct nuc900fb_info *fbi = info->par;\r\ndma_free_wc(fbi->dev, PAGE_ALIGN(info->fix.smem_len),\r\ninfo->screen_base, info->fix.smem_start);\r\n}\r\nstatic irqreturn_t nuc900fb_irqhandler(int irq, void *dev_id)\r\n{\r\nstruct nuc900fb_info *fbi = dev_id;\r\nvoid __iomem *regs = fbi->io;\r\nvoid __iomem *irq_base = fbi->irq_base;\r\nunsigned long lcdirq = readl(regs + REG_LCM_INT_CS);\r\nif (lcdirq & LCM_INT_CS_DISP_F_STATUS) {\r\nwritel(readl(irq_base) | 1<<30, irq_base);\r\nif ((readl(regs + REG_LCM_DCCS) &\r\nLCM_DCCS_SINGLE) == LCM_DCCS_SINGLE)\r\nwhile ((readl(regs + REG_LCM_DCCS) &\r\nLCM_DCCS_VA_EN) == LCM_DCCS_VA_EN)\r\n;\r\nwritel(readl(regs + REG_LCM_DCCS) | LCM_DCCS_DISP_OUT_EN,\r\nregs + REG_LCM_DCCS);\r\nwritel(readl(regs + REG_LCM_DCCS) | LCM_DCCS_VA_EN,\r\nregs + REG_LCM_DCCS);\r\n} else if (lcdirq & LCM_INT_CS_UNDERRUN_INT) {\r\nwritel(readl(irq_base) | LCM_INT_CS_UNDERRUN_INT, irq_base);\r\n} else if (lcdirq & LCM_INT_CS_BUS_ERROR_INT) {\r\nwritel(readl(irq_base) | LCM_INT_CS_BUS_ERROR_INT, irq_base);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int nuc900fb_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct nuc900fb_info *info;\r\nstruct fb_info *fbinfo;\r\nlong delta_f;\r\ninfo = container_of(nb, struct nuc900fb_info, freq_transition);\r\nfbinfo = platform_get_drvdata(to_platform_device(info->dev));\r\ndelta_f = info->clk_rate - clk_get_rate(info->clk);\r\nif ((val == CPUFREQ_POSTCHANGE && delta_f > 0) ||\r\n(val == CPUFREQ_PRECHANGE && delta_f < 0)) {\r\ninfo->clk_rate = clk_get_rate(info->clk);\r\nnuc900fb_activate_var(fbinfo);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int nuc900fb_cpufreq_register(struct nuc900fb_info *fbi)\r\n{\r\nfbi->freq_transition.notifier_call = nuc900fb_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&fbi->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void nuc900fb_cpufreq_deregister(struct nuc900fb_info *fbi)\r\n{\r\ncpufreq_unregister_notifier(&fbi->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline int nuc900fb_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int nuc900fb_cpufreq_register(struct nuc900fb_info *fbi)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void nuc900fb_cpufreq_deregister(struct nuc900fb_info *info)\r\n{\r\n}\r\nstatic int nuc900fb_probe(struct platform_device *pdev)\r\n{\r\nstruct nuc900fb_info *fbi;\r\nstruct nuc900fb_display *display;\r\nstruct fb_info *fbinfo;\r\nstruct nuc900fb_mach_info *mach_info;\r\nstruct resource *res;\r\nint ret;\r\nint irq;\r\nint i;\r\nint size;\r\ndev_dbg(&pdev->dev, "devinit\n");\r\nmach_info = dev_get_platdata(&pdev->dev);\r\nif (mach_info == NULL) {\r\ndev_err(&pdev->dev,\r\n"no platform data for lcd, cannot attach\n");\r\nreturn -EINVAL;\r\n}\r\nif (mach_info->default_display > mach_info->num_displays) {\r\ndev_err(&pdev->dev,\r\n"default display No. is %d but only %d displays \n",\r\nmach_info->default_display, mach_info->num_displays);\r\nreturn -EINVAL;\r\n}\r\ndisplay = mach_info->displays + mach_info->default_display;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq for device\n");\r\nreturn -ENOENT;\r\n}\r\nfbinfo = framebuffer_alloc(sizeof(struct nuc900fb_info), &pdev->dev);\r\nif (!fbinfo)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, fbinfo);\r\nfbi = fbinfo->par;\r\nfbi->dev = &pdev->dev;\r\n#ifdef CONFIG_CPU_NUC950\r\nfbi->drv_type = LCDDRV_NUC950;\r\n#endif\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsize = resource_size(res);\r\nfbi->mem = request_mem_region(res->start, size, pdev->name);\r\nif (fbi->mem == NULL) {\r\ndev_err(&pdev->dev, "failed to alloc memory region\n");\r\nret = -ENOENT;\r\ngoto free_fb;\r\n}\r\nfbi->io = ioremap(res->start, size);\r\nif (fbi->io == NULL) {\r\ndev_err(&pdev->dev, "ioremap() of lcd registers failed\n");\r\nret = -ENXIO;\r\ngoto release_mem_region;\r\n}\r\nfbi->irq_base = fbi->io + REG_LCM_INT_CS;\r\nwritel(0, fbi->io + REG_LCM_DCCS);\r\nstrcpy(fbinfo->fix.id, driver_name);\r\nfbinfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfbinfo->fix.type_aux = 0;\r\nfbinfo->fix.xpanstep = 0;\r\nfbinfo->fix.ypanstep = 0;\r\nfbinfo->fix.ywrapstep = 0;\r\nfbinfo->fix.accel = FB_ACCEL_NONE;\r\nfbinfo->var.nonstd = 0;\r\nfbinfo->var.activate = FB_ACTIVATE_NOW;\r\nfbinfo->var.accel_flags = 0;\r\nfbinfo->var.vmode = FB_VMODE_NONINTERLACED;\r\nfbinfo->fbops = &nuc900fb_ops;\r\nfbinfo->flags = FBINFO_FLAG_DEFAULT;\r\nfbinfo->pseudo_palette = &fbi->pseudo_pal;\r\nret = request_irq(irq, nuc900fb_irqhandler, 0, pdev->name, fbi);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot register irq handler %d -err %d\n",\r\nirq, ret);\r\nret = -EBUSY;\r\ngoto release_regs;\r\n}\r\nfbi->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(fbi->clk)) {\r\nprintk(KERN_ERR "nuc900-lcd:failed to get lcd clock source\n");\r\nret = PTR_ERR(fbi->clk);\r\ngoto release_irq;\r\n}\r\nclk_enable(fbi->clk);\r\ndev_dbg(&pdev->dev, "got and enabled clock\n");\r\nfbi->clk_rate = clk_get_rate(fbi->clk);\r\nfor (i = 0; i < mach_info->num_displays; i++) {\r\nunsigned long smem_len = mach_info->displays[i].xres;\r\nsmem_len *= mach_info->displays[i].yres;\r\nsmem_len *= mach_info->displays[i].bpp;\r\nsmem_len >>= 3;\r\nif (fbinfo->fix.smem_len < smem_len)\r\nfbinfo->fix.smem_len = smem_len;\r\n}\r\nret = nuc900fb_map_video_memory(fbinfo);\r\nif (ret) {\r\nprintk(KERN_ERR "Failed to allocate video RAM: %x\n", ret);\r\ngoto release_clock;\r\n}\r\ndev_dbg(&pdev->dev, "got video memory\n");\r\nfbinfo->var.xres = display->xres;\r\nfbinfo->var.yres = display->yres;\r\nfbinfo->var.bits_per_pixel = display->bpp;\r\nnuc900fb_init_registers(fbinfo);\r\nnuc900fb_check_var(&fbinfo->var, fbinfo);\r\nret = nuc900fb_cpufreq_register(fbi);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register cpufreq\n");\r\ngoto free_video_memory;\r\n}\r\nret = register_framebuffer(fbinfo);\r\nif (ret) {\r\nprintk(KERN_ERR "failed to register framebuffer device: %d\n",\r\nret);\r\ngoto free_cpufreq;\r\n}\r\nfb_info(fbinfo, "%s frame buffer device\n", fbinfo->fix.id);\r\nreturn 0;\r\nfree_cpufreq:\r\nnuc900fb_cpufreq_deregister(fbi);\r\nfree_video_memory:\r\nnuc900fb_unmap_video_memory(fbinfo);\r\nrelease_clock:\r\nclk_disable(fbi->clk);\r\nclk_put(fbi->clk);\r\nrelease_irq:\r\nfree_irq(irq, fbi);\r\nrelease_regs:\r\niounmap(fbi->io);\r\nrelease_mem_region:\r\nrelease_mem_region(res->start, size);\r\nfree_fb:\r\nframebuffer_release(fbinfo);\r\nreturn ret;\r\n}\r\nstatic void nuc900fb_stop_lcd(struct fb_info *info)\r\n{\r\nstruct nuc900fb_info *fbi = info->par;\r\nvoid __iomem *regs = fbi->io;\r\nwritel((~LCM_DCCS_DISP_INT_EN) | (~LCM_DCCS_VA_EN) | (~LCM_DCCS_OSD_EN),\r\nregs + REG_LCM_DCCS);\r\n}\r\nstatic int nuc900fb_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *fbinfo = platform_get_drvdata(pdev);\r\nstruct nuc900fb_info *fbi = fbinfo->par;\r\nint irq;\r\nnuc900fb_stop_lcd(fbinfo);\r\nmsleep(1);\r\nunregister_framebuffer(fbinfo);\r\nnuc900fb_cpufreq_deregister(fbi);\r\nnuc900fb_unmap_video_memory(fbinfo);\r\niounmap(fbi->io);\r\nirq = platform_get_irq(pdev, 0);\r\nfree_irq(irq, fbi);\r\nrelease_resource(fbi->mem);\r\nkfree(fbi->mem);\r\nframebuffer_release(fbinfo);\r\nreturn 0;\r\n}\r\nstatic int nuc900fb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct fb_info *fbinfo = platform_get_drvdata(dev);\r\nstruct nuc900fb_info *info = fbinfo->par;\r\nnuc900fb_stop_lcd(fbinfo);\r\nmsleep(1);\r\nclk_disable(info->clk);\r\nreturn 0;\r\n}\r\nstatic int nuc900fb_resume(struct platform_device *dev)\r\n{\r\nstruct fb_info *fbinfo = platform_get_drvdata(dev);\r\nstruct nuc900fb_info *fbi = fbinfo->par;\r\nprintk(KERN_INFO "nuc900fb resume\n");\r\nclk_enable(fbi->clk);\r\nmsleep(1);\r\nnuc900fb_init_registers(fbinfo);\r\nnuc900fb_activate_var(fbinfo);\r\nreturn 0;\r\n}
