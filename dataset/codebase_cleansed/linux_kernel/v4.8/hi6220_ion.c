static int get_type_by_name(const char *name, enum ion_heap_type *type)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ion_type_table); i++) {\r\nif (strncmp(name, ion_type_table[i].name, strlen(name)))\r\ncontinue;\r\n*type = ion_type_table[i].type;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int hi6220_set_platform_data(struct platform_device *pdev)\r\n{\r\nunsigned int base;\r\nunsigned int size;\r\nunsigned int id;\r\nconst char *heap_name;\r\nconst char *type_name;\r\nenum ion_heap_type type;\r\nint ret;\r\nstruct device_node *np;\r\nstruct ion_platform_heap *p_data;\r\nconst struct device_node *dt_node = pdev->dev.of_node;\r\nint index = 0;\r\nfor_each_child_of_node(dt_node, np)\r\nnum_heaps++;\r\nheaps_data = devm_kzalloc(&pdev->dev,\r\nsizeof(struct ion_platform_heap *) *\r\nnum_heaps,\r\nGFP_KERNEL);\r\nif (!heaps_data)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(dt_node, np) {\r\nret = of_property_read_string(np, "heap-name", &heap_name);\r\nif (ret < 0) {\r\npr_err("check the name of node %s\n", np->name);\r\ncontinue;\r\n}\r\nret = of_property_read_u32(np, "heap-id", &id);\r\nif (ret < 0) {\r\npr_err("check the id %s\n", np->name);\r\ncontinue;\r\n}\r\nret = of_property_read_u32(np, "heap-base", &base);\r\nif (ret < 0) {\r\npr_err("check the base of node %s\n", np->name);\r\ncontinue;\r\n}\r\nret = of_property_read_u32(np, "heap-size", &size);\r\nif (ret < 0) {\r\npr_err("check the size of node %s\n", np->name);\r\ncontinue;\r\n}\r\nret = of_property_read_string(np, "heap-type", &type_name);\r\nif (ret < 0) {\r\npr_err("check the type of node %s\n", np->name);\r\ncontinue;\r\n}\r\nret = get_type_by_name(type_name, &type);\r\nif (ret < 0) {\r\npr_err("type name error %s!\n", type_name);\r\ncontinue;\r\n}\r\npr_info("heap index %d : name %s base 0x%x size 0x%x id %d type %d\n",\r\nindex, heap_name, base, size, id, type);\r\np_data = devm_kzalloc(&pdev->dev,\r\nsizeof(struct ion_platform_heap),\r\nGFP_KERNEL);\r\nif (!p_data)\r\nreturn -ENOMEM;\r\np_data->name = heap_name;\r\np_data->base = base;\r\np_data->size = size;\r\np_data->id = id;\r\np_data->type = type;\r\nheaps_data[index] = p_data;\r\nindex++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hi6220_ion_probe(struct platform_device *pdev)\r\n{\r\nint i;\r\nint err;\r\nstatic struct ion_platform_heap *p_heap;\r\nidev = ion_device_create(NULL);\r\nerr = hi6220_set_platform_data(pdev);\r\nif (err) {\r\npr_err("ion set platform data error!\n");\r\ngoto err_free_idev;\r\n}\r\nheaps = devm_kzalloc(&pdev->dev,\r\nsizeof(struct ion_heap *) * num_heaps,\r\nGFP_KERNEL);\r\nif (!heaps) {\r\nerr = -ENOMEM;\r\ngoto err_free_idev;\r\n}\r\nfor (i = 0; i < num_heaps; i++) {\r\np_heap = heaps_data[i];\r\nheaps[i] = ion_heap_create(p_heap);\r\nif (IS_ERR_OR_NULL(heaps[i])) {\r\nerr = PTR_ERR(heaps[i]);\r\ngoto err_free_heaps;\r\n}\r\nion_device_add_heap(idev, heaps[i]);\r\npr_info("%s: adding heap %s of type %d with %lx@%lx\n",\r\n__func__, p_heap->name, p_heap->type,\r\np_heap->base, (unsigned long)p_heap->size);\r\n}\r\nreturn err;\r\nerr_free_heaps:\r\nfor (i = 0; i < num_heaps; ++i) {\r\nion_heap_destroy(heaps[i]);\r\nheaps[i] = NULL;\r\n}\r\nerr_free_idev:\r\nion_device_destroy(idev);\r\nreturn err;\r\n}\r\nstatic int hi6220_ion_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nfor (i = 0; i < num_heaps; i++) {\r\nion_heap_destroy(heaps[i]);\r\nheaps[i] = NULL;\r\n}\r\nion_device_destroy(idev);\r\nreturn 0;\r\n}\r\nstatic int __init hi6220_ion_init(void)\r\n{\r\nreturn platform_driver_register(&hi6220_ion_driver);\r\n}
