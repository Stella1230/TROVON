static uint32_t drm_crtc_port_mask(struct drm_device *dev,\r\nstruct device_node *port)\r\n{\r\nunsigned int index = 0;\r\nstruct drm_crtc *tmp;\r\ndrm_for_each_crtc(tmp, dev) {\r\nif (tmp->port == port)\r\nreturn 1 << index;\r\nindex++;\r\n}\r\nreturn 0;\r\n}\r\nuint32_t drm_of_find_possible_crtcs(struct drm_device *dev,\r\nstruct device_node *port)\r\n{\r\nstruct device_node *remote_port, *ep;\r\nuint32_t possible_crtcs = 0;\r\nfor_each_endpoint_of_node(port, ep) {\r\nremote_port = of_graph_get_remote_port(ep);\r\nif (!remote_port) {\r\nof_node_put(ep);\r\nreturn 0;\r\n}\r\npossible_crtcs |= drm_crtc_port_mask(dev, remote_port);\r\nof_node_put(remote_port);\r\n}\r\nreturn possible_crtcs;\r\n}\r\nint drm_of_component_probe(struct device *dev,\r\nint (*compare_of)(struct device *, void *),\r\nconst struct component_master_ops *m_ops)\r\n{\r\nstruct device_node *ep, *port, *remote;\r\nstruct component_match *match = NULL;\r\nint i;\r\nif (!dev->of_node)\r\nreturn -EINVAL;\r\nfor (i = 0; ; i++) {\r\nport = of_parse_phandle(dev->of_node, "ports", i);\r\nif (!port)\r\nbreak;\r\nif (!of_device_is_available(port->parent)) {\r\nof_node_put(port);\r\ncontinue;\r\n}\r\ncomponent_match_add(dev, &match, compare_of, port);\r\nof_node_put(port);\r\n}\r\nif (i == 0) {\r\ndev_err(dev, "missing 'ports' property\n");\r\nreturn -ENODEV;\r\n}\r\nif (!match) {\r\ndev_err(dev, "no available port\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; ; i++) {\r\nport = of_parse_phandle(dev->of_node, "ports", i);\r\nif (!port)\r\nbreak;\r\nif (!of_device_is_available(port->parent)) {\r\nof_node_put(port);\r\ncontinue;\r\n}\r\nfor_each_child_of_node(port, ep) {\r\nremote = of_graph_get_remote_port_parent(ep);\r\nif (!remote || !of_device_is_available(remote)) {\r\nof_node_put(remote);\r\ncontinue;\r\n} else if (!of_device_is_available(remote->parent)) {\r\ndev_warn(dev, "parent device of %s is not available\n",\r\nremote->full_name);\r\nof_node_put(remote);\r\ncontinue;\r\n}\r\ncomponent_match_add(dev, &match, compare_of, remote);\r\nof_node_put(remote);\r\n}\r\nof_node_put(port);\r\n}\r\nreturn component_master_add_with_match(dev, m_ops, match);\r\n}\r\nint drm_of_encoder_active_endpoint(struct device_node *node,\r\nstruct drm_encoder *encoder,\r\nstruct of_endpoint *endpoint)\r\n{\r\nstruct device_node *ep;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct device_node *port;\r\nint ret;\r\nif (!node || !crtc)\r\nreturn -EINVAL;\r\nfor_each_endpoint_of_node(node, ep) {\r\nport = of_graph_get_remote_port(ep);\r\nof_node_put(port);\r\nif (port == crtc->port) {\r\nret = of_graph_parse_endpoint(ep, endpoint);\r\nof_node_put(ep);\r\nreturn ret;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}
