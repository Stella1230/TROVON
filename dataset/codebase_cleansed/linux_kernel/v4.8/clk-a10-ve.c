static int sunxi_ve_reset_assert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct ve_reset_data *data = container_of(rcdev,\r\nstruct ve_reset_data,\r\nrcdev);\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(data->lock, flags);\r\nreg = readl(data->reg);\r\nwritel(reg & ~BIT(SUN4I_VE_RESET), data->reg);\r\nspin_unlock_irqrestore(data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sunxi_ve_reset_deassert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct ve_reset_data *data = container_of(rcdev,\r\nstruct ve_reset_data,\r\nrcdev);\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(data->lock, flags);\r\nreg = readl(data->reg);\r\nwritel(reg | BIT(SUN4I_VE_RESET), data->reg);\r\nspin_unlock_irqrestore(data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sunxi_ve_of_xlate(struct reset_controller_dev *rcdev,\r\nconst struct of_phandle_args *reset_spec)\r\n{\r\nif (WARN_ON(reset_spec->args_count != 0))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void __init sun4i_ve_clk_setup(struct device_node *node)\r\n{\r\nstruct clk *clk;\r\nstruct clk_divider *div;\r\nstruct clk_gate *gate;\r\nstruct ve_reset_data *reset_data;\r\nconst char *parent;\r\nconst char *clk_name = node->name;\r\nvoid __iomem *reg;\r\nint err;\r\nreg = of_io_request_and_map(node, 0, of_node_full_name(node));\r\nif (IS_ERR(reg))\r\nreturn;\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\ngoto err_unmap;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate)\r\ngoto err_free_div;\r\nof_property_read_string(node, "clock-output-names", &clk_name);\r\nparent = of_clk_get_parent_name(node, 0);\r\ngate->reg = reg;\r\ngate->bit_idx = SUN4I_VE_ENABLE;\r\ngate->lock = &ve_lock;\r\ndiv->reg = reg;\r\ndiv->shift = SUN4I_VE_DIVIDER_SHIFT;\r\ndiv->width = SUN4I_VE_DIVIDER_WIDTH;\r\ndiv->lock = &ve_lock;\r\nclk = clk_register_composite(NULL, clk_name, &parent, 1,\r\nNULL, NULL,\r\n&div->hw, &clk_divider_ops,\r\n&gate->hw, &clk_gate_ops,\r\nCLK_SET_RATE_PARENT);\r\nif (IS_ERR(clk))\r\ngoto err_free_gate;\r\nerr = of_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nif (err)\r\ngoto err_unregister_clk;\r\nreset_data = kzalloc(sizeof(*reset_data), GFP_KERNEL);\r\nif (!reset_data)\r\ngoto err_del_provider;\r\nreset_data->reg = reg;\r\nreset_data->lock = &ve_lock;\r\nreset_data->rcdev.nr_resets = 1;\r\nreset_data->rcdev.ops = &sunxi_ve_reset_ops;\r\nreset_data->rcdev.of_node = node;\r\nreset_data->rcdev.of_xlate = sunxi_ve_of_xlate;\r\nreset_data->rcdev.of_reset_n_cells = 0;\r\nerr = reset_controller_register(&reset_data->rcdev);\r\nif (err)\r\ngoto err_free_reset;\r\nreturn;\r\nerr_free_reset:\r\nkfree(reset_data);\r\nerr_del_provider:\r\nof_clk_del_provider(node);\r\nerr_unregister_clk:\r\nclk_unregister(clk);\r\nerr_free_gate:\r\nkfree(gate);\r\nerr_free_div:\r\nkfree(div);\r\nerr_unmap:\r\niounmap(reg);\r\n}
