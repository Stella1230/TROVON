static int lpass_platform_pcmops_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nint ret;\r\nsnd_soc_set_runtime_hwparams(substream, &lpass_platform_pcm_hardware);\r\nruntime->dma_bytes = lpass_platform_pcm_hardware.buffer_bytes_max;\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0) {\r\ndev_err(soc_runtime->dev, "%s() setting constraints failed: %d\n",\r\n__func__, ret);\r\nreturn -EINVAL;\r\n}\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nreturn 0;\r\n}\r\nstatic int lpass_platform_pcmops_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nsnd_pcm_format_t format = params_format(params);\r\nunsigned int channels = params_channels(params);\r\nunsigned int regval;\r\nint ch, dir = substream->stream;\r\nint bitwidth;\r\nint ret, dma_port = pcm_data->i2s_port + v->dmactl_audif_start;\r\nif (dir == SNDRV_PCM_STREAM_PLAYBACK)\r\nch = pcm_data->rdma_ch;\r\nelse\r\nch = pcm_data->wrdma_ch;\r\nbitwidth = snd_pcm_format_width(format);\r\nif (bitwidth < 0) {\r\ndev_err(soc_runtime->dev, "%s() invalid bit width given: %d\n",\r\n__func__, bitwidth);\r\nreturn bitwidth;\r\n}\r\nregval = LPAIF_DMACTL_BURSTEN_INCR4 |\r\nLPAIF_DMACTL_AUDINTF(dma_port) |\r\nLPAIF_DMACTL_FIFOWM_8;\r\nswitch (bitwidth) {\r\ncase 16:\r\nswitch (channels) {\r\ncase 1:\r\ncase 2:\r\nregval |= LPAIF_DMACTL_WPSCNT_ONE;\r\nbreak;\r\ncase 4:\r\nregval |= LPAIF_DMACTL_WPSCNT_TWO;\r\nbreak;\r\ncase 6:\r\nregval |= LPAIF_DMACTL_WPSCNT_THREE;\r\nbreak;\r\ncase 8:\r\nregval |= LPAIF_DMACTL_WPSCNT_FOUR;\r\nbreak;\r\ndefault:\r\ndev_err(soc_runtime->dev, "%s() invalid PCM config given: bw=%d, ch=%u\n",\r\n__func__, bitwidth, channels);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nswitch (channels) {\r\ncase 1:\r\nregval |= LPAIF_DMACTL_WPSCNT_ONE;\r\nbreak;\r\ncase 2:\r\nregval |= LPAIF_DMACTL_WPSCNT_TWO;\r\nbreak;\r\ncase 4:\r\nregval |= LPAIF_DMACTL_WPSCNT_FOUR;\r\nbreak;\r\ncase 6:\r\nregval |= LPAIF_DMACTL_WPSCNT_SIX;\r\nbreak;\r\ncase 8:\r\nregval |= LPAIF_DMACTL_WPSCNT_EIGHT;\r\nbreak;\r\ndefault:\r\ndev_err(soc_runtime->dev, "%s() invalid PCM config given: bw=%d, ch=%u\n",\r\n__func__, bitwidth, channels);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(soc_runtime->dev, "%s() invalid PCM config given: bw=%d, ch=%u\n",\r\n__func__, bitwidth, channels);\r\nreturn -EINVAL;\r\n}\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_DMACTL_REG(v, ch, dir), regval);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpass_platform_pcmops_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nunsigned int reg;\r\nint ret;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreg = LPAIF_RDMACTL_REG(v, pcm_data->rdma_ch);\r\nelse\r\nreg = LPAIF_WRDMACTL_REG(v, pcm_data->wrdma_ch);\r\nret = regmap_write(drvdata->lpaif_map, reg, 0);\r\nif (ret)\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int lpass_platform_pcmops_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint ret, ch, dir = substream->stream;\r\nif (dir == SNDRV_PCM_STREAM_PLAYBACK)\r\nch = pcm_data->rdma_ch;\r\nelse\r\nch = pcm_data->wrdma_ch;\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_DMABASE_REG(v, ch, dir),\r\nruntime->dma_addr);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmabase reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_DMABUFF_REG(v, ch, dir),\r\n(snd_pcm_lib_buffer_bytes(substream) >> 2) - 1);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmabuff reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_DMAPER_REG(v, ch, dir),\r\n(snd_pcm_lib_period_bytes(substream) >> 2) - 1);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmaper reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_DMACTL_REG(v, ch, dir),\r\nLPAIF_DMACTL_ENABLE_MASK, LPAIF_DMACTL_ENABLE_ON);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpass_platform_pcmops_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint ret, ch, dir = substream->stream;\r\nif (dir == SNDRV_PCM_STREAM_PLAYBACK)\r\nch = pcm_data->rdma_ch;\r\nelse\r\nch = pcm_data->wrdma_ch;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_ALL(ch));\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqclear reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_ALL(ch),\r\nLPAIF_IRQ_ALL(ch));\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqen reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_DMACTL_REG(v, ch, dir),\r\nLPAIF_DMACTL_ENABLE_MASK,\r\nLPAIF_DMACTL_ENABLE_ON);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_DMACTL_REG(v, ch, dir),\r\nLPAIF_DMACTL_ENABLE_MASK,\r\nLPAIF_DMACTL_ENABLE_OFF);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_ALL(ch), 0);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqen reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t lpass_platform_pcmops_pointer(\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nunsigned int base_addr, curr_addr;\r\nint ret, ch, dir = substream->stream;\r\nif (dir == SNDRV_PCM_STREAM_PLAYBACK)\r\nch = pcm_data->rdma_ch;\r\nelse\r\nch = pcm_data->wrdma_ch;\r\nret = regmap_read(drvdata->lpaif_map,\r\nLPAIF_DMABASE_REG(v, ch, dir), &base_addr);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error reading from rdmabase reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(drvdata->lpaif_map,\r\nLPAIF_DMACURR_REG(v, ch, dir), &curr_addr);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error reading from rdmacurr reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn bytes_to_frames(substream->runtime, curr_addr - base_addr);\r\n}\r\nstatic int lpass_platform_pcmops_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nreturn dma_mmap_coherent(substream->pcm->card->dev, vma,\r\nruntime->dma_area, runtime->dma_addr,\r\nruntime->dma_bytes);\r\n}\r\nstatic irqreturn_t lpass_dma_interrupt_handler(\r\nstruct snd_pcm_substream *substream,\r\nstruct lpass_data *drvdata,\r\nint chan, u32 interrupts)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_variant *v = drvdata->variant;\r\nirqreturn_t ret = IRQ_NONE;\r\nint rv;\r\nif (interrupts & LPAIF_IRQ_PER(chan)) {\r\nrv = regmap_write(drvdata->lpaif_map,\r\nLPAIF_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_PER(chan));\r\nif (rv) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqclear reg: %d\n",\r\n__func__, rv);\r\nreturn IRQ_NONE;\r\n}\r\nsnd_pcm_period_elapsed(substream);\r\nret = IRQ_HANDLED;\r\n}\r\nif (interrupts & LPAIF_IRQ_XRUN(chan)) {\r\nrv = regmap_write(drvdata->lpaif_map,\r\nLPAIF_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_XRUN(chan));\r\nif (rv) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqclear reg: %d\n",\r\n__func__, rv);\r\nreturn IRQ_NONE;\r\n}\r\ndev_warn(soc_runtime->dev, "%s() xrun warning\n", __func__);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nret = IRQ_HANDLED;\r\n}\r\nif (interrupts & LPAIF_IRQ_ERR(chan)) {\r\nrv = regmap_write(drvdata->lpaif_map,\r\nLPAIF_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_ERR(chan));\r\nif (rv) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqclear reg: %d\n",\r\n__func__, rv);\r\nreturn IRQ_NONE;\r\n}\r\ndev_err(soc_runtime->dev, "%s() bus access error\n", __func__);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_DISCONNECTED);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t lpass_platform_lpaif_irq(int irq, void *data)\r\n{\r\nstruct lpass_data *drvdata = data;\r\nstruct lpass_variant *v = drvdata->variant;\r\nunsigned int irqs;\r\nint rv, chan;\r\nrv = regmap_read(drvdata->lpaif_map,\r\nLPAIF_IRQSTAT_REG(v, LPAIF_IRQ_PORT_HOST), &irqs);\r\nif (rv) {\r\npr_err("%s() error reading from irqstat reg: %d\n",\r\n__func__, rv);\r\nreturn IRQ_NONE;\r\n}\r\nfor (chan = 0; chan < LPASS_MAX_DMA_CHANNELS; chan++) {\r\nif (irqs & LPAIF_IRQ_ALL(chan) && drvdata->substream[chan]) {\r\nrv = lpass_dma_interrupt_handler(\r\ndrvdata->substream[chan],\r\ndrvdata, chan, irqs);\r\nif (rv != IRQ_HANDLED)\r\nreturn rv;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lpass_platform_pcm_new(struct snd_soc_pcm_runtime *soc_runtime)\r\n{\r\nstruct snd_pcm *pcm = soc_runtime->pcm;\r\nstruct snd_pcm_substream *psubstream, *csubstream;\r\nstruct snd_soc_dai *cpu_dai = soc_runtime->cpu_dai;\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint ret = -EINVAL;\r\nstruct lpass_pcm_data *data;\r\nsize_t size = lpass_platform_pcm_hardware.buffer_bytes_max;\r\ndata = devm_kzalloc(soc_runtime->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->i2s_port = cpu_dai->driver->id;\r\nsnd_soc_pcm_set_drvdata(soc_runtime, data);\r\npsubstream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\r\nif (psubstream) {\r\nif (v->alloc_dma_channel)\r\ndata->rdma_ch = v->alloc_dma_channel(drvdata,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (data->rdma_ch < 0)\r\nreturn data->rdma_ch;\r\ndrvdata->substream[data->rdma_ch] = psubstream;\r\nret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\r\nsoc_runtime->platform->dev,\r\nsize, &psubstream->dma_buffer);\r\nif (ret)\r\ngoto playback_alloc_err;\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_RDMACTL_REG(v, data->rdma_ch), 0);\r\nif (ret) {\r\ndev_err(soc_runtime->dev,\r\n"%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\ngoto capture_alloc_err;\r\n}\r\n}\r\ncsubstream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\r\nif (csubstream) {\r\nif (v->alloc_dma_channel)\r\ndata->wrdma_ch = v->alloc_dma_channel(drvdata,\r\nSNDRV_PCM_STREAM_CAPTURE);\r\nif (data->wrdma_ch < 0) {\r\nret = data->wrdma_ch;\r\ngoto capture_alloc_err;\r\n}\r\ndrvdata->substream[data->wrdma_ch] = csubstream;\r\nret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\r\nsoc_runtime->platform->dev,\r\nsize, &csubstream->dma_buffer);\r\nif (ret)\r\ngoto capture_alloc_err;\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_WRDMACTL_REG(v, data->wrdma_ch), 0);\r\nif (ret) {\r\ndev_err(soc_runtime->dev,\r\n"%s() error writing to wrdmactl reg: %d\n",\r\n__func__, ret);\r\ngoto capture_reg_err;\r\n}\r\n}\r\nreturn 0;\r\ncapture_reg_err:\r\nif (csubstream)\r\nsnd_dma_free_pages(&csubstream->dma_buffer);\r\ncapture_alloc_err:\r\nif (psubstream)\r\nsnd_dma_free_pages(&psubstream->dma_buffer);\r\nplayback_alloc_err:\r\ndev_err(soc_runtime->dev, "Cannot allocate buffer(s)\n");\r\nreturn ret;\r\n}\r\nstatic void lpass_platform_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_soc_pcm_runtime *rt;\r\nstruct lpass_data *drvdata;\r\nstruct lpass_pcm_data *data;\r\nstruct lpass_variant *v;\r\nstruct snd_pcm_substream *substream;\r\nint ch, i;\r\nfor (i = 0; i < ARRAY_SIZE(pcm->streams); i++) {\r\nsubstream = pcm->streams[i].substream;\r\nif (substream) {\r\nrt = substream->private_data;\r\ndata = snd_soc_pcm_get_drvdata(rt);\r\ndrvdata = snd_soc_platform_get_drvdata(rt->platform);\r\nch = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\n? data->rdma_ch\r\n: data->wrdma_ch;\r\nv = drvdata->variant;\r\ndrvdata->substream[ch] = NULL;\r\nif (v->free_dma_channel)\r\nv->free_dma_channel(drvdata, ch);\r\nsnd_dma_free_pages(&substream->dma_buffer);\r\nsubstream->dma_buffer.area = NULL;\r\nsubstream->dma_buffer.addr = 0;\r\n}\r\n}\r\n}\r\nint asoc_qcom_lpass_platform_register(struct platform_device *pdev)\r\n{\r\nstruct lpass_data *drvdata = platform_get_drvdata(pdev);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint ret;\r\ndrvdata->lpaif_irq = platform_get_irq_byname(pdev, "lpass-irq-lpaif");\r\nif (drvdata->lpaif_irq < 0) {\r\ndev_err(&pdev->dev, "%s() error getting irq handle: %d\n",\r\n__func__, drvdata->lpaif_irq);\r\nreturn -ENODEV;\r\n}\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST), 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s() error writing to irqen reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, drvdata->lpaif_irq,\r\nlpass_platform_lpaif_irq, IRQF_TRIGGER_RISING,\r\n"lpass-irq-lpaif", drvdata);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s() irq request failed: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn devm_snd_soc_register_platform(&pdev->dev,\r\n&lpass_platform_driver);\r\n}
