static int snd_soc_dapm_put_volsw_aic3x(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_kcontrol_codec(kcontrol);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nint max = mc->max;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nunsigned short val;\r\nstruct snd_soc_dapm_update update;\r\nint connect, change;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nmask = 0xf;\r\nif (val)\r\nval = mask;\r\nconnect = !!val;\r\nif (invert)\r\nval = mask - val;\r\nmask <<= shift;\r\nval <<= shift;\r\nchange = snd_soc_test_bits(codec, reg, mask, val);\r\nif (change) {\r\nupdate.kcontrol = kcontrol;\r\nupdate.reg = reg;\r\nupdate.mask = mask;\r\nupdate.val = val;\r\nsnd_soc_dapm_mixer_update_power(dapm, kcontrol, connect,\r\n&update);\r\n}\r\nreturn change;\r\n}\r\nstatic int mic_bias_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, MICBIAS_CTRL,\r\nMICBIAS_LEVEL_MASK,\r\naic3x->micbias_vg << MICBIAS_LEVEL_SHIFT);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, MICBIAS_CTRL,\r\nMICBIAS_LEVEL_MASK, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic3x_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nswitch (aic3x->model) {\r\ncase AIC3X_MODEL_3X:\r\ncase AIC3X_MODEL_33:\r\nsnd_soc_dapm_new_controls(dapm, aic3x_extra_dapm_widgets,\r\nARRAY_SIZE(aic3x_extra_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, intercon_extra,\r\nARRAY_SIZE(intercon_extra));\r\nsnd_soc_dapm_new_controls(dapm, aic3x_dapm_mono_widgets,\r\nARRAY_SIZE(aic3x_dapm_mono_widgets));\r\nsnd_soc_dapm_add_routes(dapm, intercon_mono,\r\nARRAY_SIZE(intercon_mono));\r\nbreak;\r\ncase AIC3X_MODEL_3007:\r\nsnd_soc_dapm_new_controls(dapm, aic3x_extra_dapm_widgets,\r\nARRAY_SIZE(aic3x_extra_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, intercon_extra,\r\nARRAY_SIZE(intercon_extra));\r\nsnd_soc_dapm_new_controls(dapm, aic3007_dapm_widgets,\r\nARRAY_SIZE(aic3007_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, intercon_3007,\r\nARRAY_SIZE(intercon_3007));\r\nbreak;\r\ncase AIC3X_MODEL_3104:\r\nsnd_soc_dapm_new_controls(dapm, aic3104_extra_dapm_widgets,\r\nARRAY_SIZE(aic3104_extra_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, intercon_extra_3104,\r\nARRAY_SIZE(intercon_extra_3104));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic3x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nint codec_clk = 0, bypass_pll = 0, fsref, last_clk = 0;\r\nu8 data, j, r, p, pll_q, pll_p = 1, pll_r = 1, pll_j = 1;\r\nu16 d, pll_d = 1;\r\nint clk;\r\nint width = aic3x->slot_width;\r\nif (!width)\r\nwidth = params_width(params);\r\ndata = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLB) & (~(0x3 << 4));\r\nswitch (width) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\ndata |= (0x01 << 4);\r\nbreak;\r\ncase 24:\r\ndata |= (0x02 << 4);\r\nbreak;\r\ncase 32:\r\ndata |= (0x03 << 4);\r\nbreak;\r\n}\r\nsnd_soc_write(codec, AIC3X_ASD_INTF_CTRLB, data);\r\nfsref = (params_rate(params) % 11025 == 0) ? 44100 : 48000;\r\nfor (pll_q = 2; pll_q < 18; pll_q++)\r\nif (aic3x->sysclk / (128 * pll_q) == fsref) {\r\nbypass_pll = 1;\r\nbreak;\r\n}\r\nif (bypass_pll) {\r\npll_q &= 0xf;\r\nsnd_soc_write(codec, AIC3X_PLL_PROGA_REG, pll_q << PLLQ_SHIFT);\r\nsnd_soc_write(codec, AIC3X_GPIOB_REG, CODEC_CLKIN_CLKDIV);\r\nsnd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG, PLL_ENABLE, 0);\r\n} else {\r\nsnd_soc_write(codec, AIC3X_GPIOB_REG, CODEC_CLKIN_PLLDIV);\r\nsnd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG,\r\nPLL_ENABLE, PLL_ENABLE);\r\n}\r\ndata = (LDAC2LCH | RDAC2RCH);\r\ndata |= (fsref == 44100) ? FSREF_44100 : FSREF_48000;\r\nif (params_rate(params) >= 64000)\r\ndata |= DUAL_RATE_MODE;\r\nsnd_soc_write(codec, AIC3X_CODEC_DATAPATH_REG, data);\r\ndata = (fsref * 20) / params_rate(params);\r\nif (params_rate(params) < 64000)\r\ndata /= 2;\r\ndata /= 5;\r\ndata -= 2;\r\ndata |= (data << 4);\r\nsnd_soc_write(codec, AIC3X_SAMPLE_RATE_SEL_REG, data);\r\nif (bypass_pll)\r\nreturn 0;\r\ncodec_clk = (2048 * fsref) / (aic3x->sysclk / 1000);\r\nfor (r = 1; r <= 16; r++)\r\nfor (p = 1; p <= 8; p++) {\r\nfor (j = 4; j <= 55; j++) {\r\nint tmp_clk = (1000 * j * r) / p;\r\nif (abs(codec_clk - tmp_clk) <\r\nabs(codec_clk - last_clk)) {\r\npll_j = j; pll_d = 0;\r\npll_r = r; pll_p = p;\r\nlast_clk = tmp_clk;\r\n}\r\nif (tmp_clk == codec_clk)\r\ngoto found;\r\n}\r\n}\r\nfor (p = 1; p <= 8; p++) {\r\nj = codec_clk * p / 1000;\r\nif (j < 4 || j > 11)\r\ncontinue;\r\nd = ((2048 * p * fsref) - j * aic3x->sysclk)\r\n* 100 / (aic3x->sysclk/100);\r\nclk = (10000 * j + d) / (10 * p);\r\nif (abs(codec_clk - clk) < abs(codec_clk - last_clk)) {\r\npll_j = j; pll_d = d; pll_r = 1; pll_p = p;\r\nlast_clk = clk;\r\n}\r\nif (clk == codec_clk)\r\ngoto found;\r\n}\r\nif (last_clk == 0) {\r\nprintk(KERN_ERR "%s(): unable to setup PLL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nfound:\r\nsnd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG, PLLP_MASK, pll_p);\r\nsnd_soc_write(codec, AIC3X_OVRF_STATUS_AND_PLLR_REG,\r\npll_r << PLLR_SHIFT);\r\nsnd_soc_write(codec, AIC3X_PLL_PROGB_REG, pll_j << PLLJ_SHIFT);\r\nsnd_soc_write(codec, AIC3X_PLL_PROGC_REG,\r\n(pll_d >> 6) << PLLD_MSB_SHIFT);\r\nsnd_soc_write(codec, AIC3X_PLL_PROGD_REG,\r\n(pll_d & 0x3F) << PLLD_LSB_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int aic3x_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nint delay = 0;\r\nint width = aic3x->slot_width;\r\nif (!width)\r\nwidth = substream->runtime->sample_bits;\r\nif (aic3x->dai_fmt == SND_SOC_DAIFMT_DSP_A)\r\ndelay += (aic3x->tdm_delay*width + 1);\r\nelse if (aic3x->dai_fmt == SND_SOC_DAIFMT_DSP_B)\r\ndelay += aic3x->tdm_delay*width;\r\nsnd_soc_write(codec, AIC3X_ASD_INTF_CTRLC, delay);\r\nreturn 0;\r\n}\r\nstatic int aic3x_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 ldac_reg = snd_soc_read(codec, LDAC_VOL) & ~MUTE_ON;\r\nu8 rdac_reg = snd_soc_read(codec, RDAC_VOL) & ~MUTE_ON;\r\nif (mute) {\r\nsnd_soc_write(codec, LDAC_VOL, ldac_reg | MUTE_ON);\r\nsnd_soc_write(codec, RDAC_VOL, rdac_reg | MUTE_ON);\r\n} else {\r\nsnd_soc_write(codec, LDAC_VOL, ldac_reg);\r\nsnd_soc_write(codec, RDAC_VOL, rdac_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic3x_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_update_bits(codec, AIC3X_CLKGEN_CTRL_REG, PLLCLK_IN_MASK,\r\nclk_id << PLLCLK_IN_SHIFT);\r\nsnd_soc_update_bits(codec, AIC3X_CLKGEN_CTRL_REG, CLKDIV_IN_MASK,\r\nclk_id << CLKDIV_IN_SHIFT);\r\naic3x->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int aic3x_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nu8 iface_areg, iface_breg;\r\niface_areg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLA) & 0x3f;\r\niface_breg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLB) & 0x3f;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naic3x->master = 1;\r\niface_areg |= BIT_CLK_MASTER | WORD_CLK_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\naic3x->master = 0;\r\niface_areg &= ~(BIT_CLK_MASTER | WORD_CLK_MASTER);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK |\r\nSND_SOC_DAIFMT_INV_MASK)) {\r\ncase (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF):\r\nbreak;\r\ncase (SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_IB_NF):\r\ncase (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF):\r\niface_breg |= (0x01 << 6);\r\nbreak;\r\ncase (SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_NB_NF):\r\niface_breg |= (0x02 << 6);\r\nbreak;\r\ncase (SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF):\r\niface_breg |= (0x03 << 6);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\naic3x->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nsnd_soc_write(codec, AIC3X_ASD_INTF_CTRLA, iface_areg);\r\nsnd_soc_write(codec, AIC3X_ASD_INTF_CTRLB, iface_breg);\r\nreturn 0;\r\n}\r\nstatic int aic3x_set_dai_tdm_slot(struct snd_soc_dai *codec_dai,\r\nunsigned int tx_mask, unsigned int rx_mask,\r\nint slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int lsb;\r\nif (tx_mask != rx_mask) {\r\ndev_err(codec->dev, "tx and rx masks must be symmetric\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!tx_mask)) {\r\ndev_err(codec->dev, "tx and rx masks need to be non 0\n");\r\nreturn -EINVAL;\r\n}\r\nlsb = __ffs(tx_mask);\r\nif ((lsb + 1) != __fls(tx_mask)) {\r\ndev_err(codec->dev, "Invalid mask, slots must be adjacent\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (slot_width) {\r\ncase 16:\r\ncase 20:\r\ncase 24:\r\ncase 32:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported slot width %d\n", slot_width);\r\nreturn -EINVAL;\r\n}\r\naic3x->tdm_delay = lsb;\r\naic3x->slot_width = slot_width;\r\nsnd_soc_update_bits(codec, AIC3X_ASD_INTF_CTRLA,\r\nDOUT_TRISTATE, DOUT_TRISTATE);\r\nreturn 0;\r\n}\r\nstatic int aic3x_regulator_event(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct aic3x_disable_nb *disable_nb =\r\ncontainer_of(nb, struct aic3x_disable_nb, nb);\r\nstruct aic3x_priv *aic3x = disable_nb->aic3x;\r\nif (event & REGULATOR_EVENT_DISABLE) {\r\nif (gpio_is_valid(aic3x->gpio_reset))\r\ngpio_set_value(aic3x->gpio_reset, 0);\r\nregcache_mark_dirty(aic3x->regmap);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic3x_set_power(struct snd_soc_codec *codec, int power)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int pll_c, pll_d;\r\nint ret;\r\nif (power) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(aic3x->supplies),\r\naic3x->supplies);\r\nif (ret)\r\ngoto out;\r\naic3x->power = 1;\r\nif (gpio_is_valid(aic3x->gpio_reset)) {\r\nudelay(1);\r\ngpio_set_value(aic3x->gpio_reset, 1);\r\n}\r\nregcache_cache_only(aic3x->regmap, false);\r\nregcache_sync(aic3x->regmap);\r\npll_c = snd_soc_read(codec, AIC3X_PLL_PROGC_REG);\r\npll_d = snd_soc_read(codec, AIC3X_PLL_PROGD_REG);\r\nif (pll_c == aic3x_reg[AIC3X_PLL_PROGC_REG].def ||\r\npll_d == aic3x_reg[AIC3X_PLL_PROGD_REG].def) {\r\nsnd_soc_write(codec, AIC3X_PLL_PROGC_REG, pll_c);\r\nsnd_soc_write(codec, AIC3X_PLL_PROGD_REG, pll_d);\r\n}\r\n} else {\r\nsnd_soc_write(codec, AIC3X_RESET, SOFT_RESET);\r\nregcache_mark_dirty(aic3x->regmap);\r\naic3x->power = 0;\r\nregcache_cache_only(aic3x->regmap, true);\r\nret = regulator_bulk_disable(ARRAY_SIZE(aic3x->supplies),\r\naic3x->supplies);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int aic3x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_STANDBY &&\r\naic3x->master) {\r\nsnd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG,\r\nPLL_ENABLE, PLL_ENABLE);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (!aic3x->power)\r\naic3x_set_power(codec, 1);\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_PREPARE &&\r\naic3x->master) {\r\nsnd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG,\r\nPLL_ENABLE, 0);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (aic3x->power)\r\naic3x_set_power(codec, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void aic3x_mono_init(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_write(codec, DACL1_2_MONOLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACR1_2_MONOLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_update_bits(codec, MONOLOPM_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_write(codec, PGAL_2_MONOLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAR_2_MONOLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2L_2_MONOLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2R_2_MONOLOPM_VOL, DEFAULT_VOL);\r\n}\r\nstatic int aic3x_init(struct snd_soc_codec *codec)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_write(codec, AIC3X_PAGE_SELECT, PAGE0_SELECT);\r\nsnd_soc_write(codec, AIC3X_RESET, SOFT_RESET);\r\nsnd_soc_write(codec, LDAC_VOL, DEFAULT_VOL | MUTE_ON);\r\nsnd_soc_write(codec, RDAC_VOL, DEFAULT_VOL | MUTE_ON);\r\nsnd_soc_write(codec, DACL1_2_HPLOUT_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACR1_2_HPROUT_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACL1_2_HPLCOM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACR1_2_HPRCOM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACL1_2_LLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACR1_2_RLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_update_bits(codec, LLOPM_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, RLOPM_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, HPLOUT_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, HPROUT_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, HPLCOM_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, HPRCOM_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_write(codec, LADC_VOL, DEFAULT_GAIN);\r\nsnd_soc_write(codec, RADC_VOL, DEFAULT_GAIN);\r\nsnd_soc_write(codec, LINE1L_2_LADC_CTRL, 0x0);\r\nsnd_soc_write(codec, LINE1R_2_RADC_CTRL, 0x0);\r\nsnd_soc_write(codec, PGAL_2_HPLOUT_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAR_2_HPROUT_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAL_2_HPLCOM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAR_2_HPRCOM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAL_2_LLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAR_2_RLOPM_VOL, DEFAULT_VOL);\r\nif (aic3x->model != AIC3X_MODEL_3104) {\r\nsnd_soc_write(codec, LINE2L_2_HPLOUT_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2R_2_HPROUT_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2L_2_HPLCOM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2R_2_HPRCOM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2L_2_LLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2R_2_RLOPM_VOL, DEFAULT_VOL);\r\n}\r\nswitch (aic3x->model) {\r\ncase AIC3X_MODEL_3X:\r\ncase AIC3X_MODEL_33:\r\naic3x_mono_init(codec);\r\nbreak;\r\ncase AIC3X_MODEL_3007:\r\nsnd_soc_write(codec, CLASSD_CTRL, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool aic3x_is_shared_reset(struct aic3x_priv *aic3x)\r\n{\r\nstruct aic3x_priv *a;\r\nlist_for_each_entry(a, &reset_list, list) {\r\nif (gpio_is_valid(aic3x->gpio_reset) &&\r\naic3x->gpio_reset == a->gpio_reset)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int aic3x_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nint ret, i;\r\nINIT_LIST_HEAD(&aic3x->list);\r\naic3x->codec = codec;\r\nfor (i = 0; i < ARRAY_SIZE(aic3x->supplies); i++) {\r\naic3x->disable_nb[i].nb.notifier_call = aic3x_regulator_event;\r\naic3x->disable_nb[i].aic3x = aic3x;\r\nret = regulator_register_notifier(aic3x->supplies[i].consumer,\r\n&aic3x->disable_nb[i].nb);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to request regulator notifier: %d\n",\r\nret);\r\ngoto err_notif;\r\n}\r\n}\r\nregcache_mark_dirty(aic3x->regmap);\r\naic3x_init(codec);\r\nif (aic3x->setup) {\r\nif (aic3x->model != AIC3X_MODEL_3104) {\r\nsnd_soc_write(codec, AIC3X_GPIO1_REG,\r\n(aic3x->setup->gpio_func[0] & 0xf) << 4);\r\nsnd_soc_write(codec, AIC3X_GPIO2_REG,\r\n(aic3x->setup->gpio_func[1] & 0xf) << 4);\r\n} else {\r\ndev_warn(codec->dev, "GPIO functionality is not supported on tlv320aic3104\n");\r\n}\r\n}\r\nswitch (aic3x->model) {\r\ncase AIC3X_MODEL_3X:\r\ncase AIC3X_MODEL_33:\r\nsnd_soc_add_codec_controls(codec, aic3x_extra_snd_controls,\r\nARRAY_SIZE(aic3x_extra_snd_controls));\r\nsnd_soc_add_codec_controls(codec, aic3x_mono_controls,\r\nARRAY_SIZE(aic3x_mono_controls));\r\nbreak;\r\ncase AIC3X_MODEL_3007:\r\nsnd_soc_add_codec_controls(codec, aic3x_extra_snd_controls,\r\nARRAY_SIZE(aic3x_extra_snd_controls));\r\nsnd_soc_add_codec_controls(codec,\r\n&aic3x_classd_amp_gain_ctrl, 1);\r\nbreak;\r\ncase AIC3X_MODEL_3104:\r\nbreak;\r\n}\r\nswitch (aic3x->micbias_vg) {\r\ncase AIC3X_MICBIAS_2_0V:\r\ncase AIC3X_MICBIAS_2_5V:\r\ncase AIC3X_MICBIAS_AVDDV:\r\nsnd_soc_update_bits(codec, MICBIAS_CTRL,\r\nMICBIAS_LEVEL_MASK,\r\n(aic3x->micbias_vg) << MICBIAS_LEVEL_SHIFT);\r\nbreak;\r\ncase AIC3X_MICBIAS_OFF:\r\nbreak;\r\n}\r\naic3x_add_widgets(codec);\r\nreturn 0;\r\nerr_notif:\r\nwhile (i--)\r\nregulator_unregister_notifier(aic3x->supplies[i].consumer,\r\n&aic3x->disable_nb[i].nb);\r\nreturn ret;\r\n}\r\nstatic int aic3x_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nlist_del(&aic3x->list);\r\nfor (i = 0; i < ARRAY_SIZE(aic3x->supplies); i++)\r\nregulator_unregister_notifier(aic3x->supplies[i].consumer,\r\n&aic3x->disable_nb[i].nb);\r\nreturn 0;\r\n}\r\nstatic int aic3x_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct aic3x_pdata *pdata = i2c->dev.platform_data;\r\nstruct aic3x_priv *aic3x;\r\nstruct aic3x_setup_data *ai3x_setup;\r\nstruct device_node *np = i2c->dev.of_node;\r\nint ret, i;\r\nu32 value;\r\naic3x = devm_kzalloc(&i2c->dev, sizeof(struct aic3x_priv), GFP_KERNEL);\r\nif (!aic3x)\r\nreturn -ENOMEM;\r\naic3x->regmap = devm_regmap_init_i2c(i2c, &aic3x_regmap);\r\nif (IS_ERR(aic3x->regmap)) {\r\nret = PTR_ERR(aic3x->regmap);\r\nreturn ret;\r\n}\r\nregcache_cache_only(aic3x->regmap, true);\r\ni2c_set_clientdata(i2c, aic3x);\r\nif (pdata) {\r\naic3x->gpio_reset = pdata->gpio_reset;\r\naic3x->setup = pdata->setup;\r\naic3x->micbias_vg = pdata->micbias_vg;\r\n} else if (np) {\r\nai3x_setup = devm_kzalloc(&i2c->dev, sizeof(*ai3x_setup),\r\nGFP_KERNEL);\r\nif (!ai3x_setup)\r\nreturn -ENOMEM;\r\nret = of_get_named_gpio(np, "gpio-reset", 0);\r\nif (ret >= 0)\r\naic3x->gpio_reset = ret;\r\nelse\r\naic3x->gpio_reset = -1;\r\nif (of_property_read_u32_array(np, "ai3x-gpio-func",\r\nai3x_setup->gpio_func, 2) >= 0) {\r\naic3x->setup = ai3x_setup;\r\n}\r\nif (!of_property_read_u32(np, "ai3x-micbias-vg", &value)) {\r\nswitch (value) {\r\ncase 1 :\r\naic3x->micbias_vg = AIC3X_MICBIAS_2_0V;\r\nbreak;\r\ncase 2 :\r\naic3x->micbias_vg = AIC3X_MICBIAS_2_5V;\r\nbreak;\r\ncase 3 :\r\naic3x->micbias_vg = AIC3X_MICBIAS_AVDDV;\r\nbreak;\r\ndefault :\r\naic3x->micbias_vg = AIC3X_MICBIAS_OFF;\r\ndev_err(&i2c->dev, "Unsuitable MicBias voltage "\r\n"found in DT\n");\r\n}\r\n} else {\r\naic3x->micbias_vg = AIC3X_MICBIAS_OFF;\r\n}\r\n} else {\r\naic3x->gpio_reset = -1;\r\n}\r\naic3x->model = id->driver_data;\r\nif (gpio_is_valid(aic3x->gpio_reset) &&\r\n!aic3x_is_shared_reset(aic3x)) {\r\nret = gpio_request(aic3x->gpio_reset, "tlv320aic3x reset");\r\nif (ret != 0)\r\ngoto err;\r\ngpio_direction_output(aic3x->gpio_reset, 0);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(aic3x->supplies); i++)\r\naic3x->supplies[i].supply = aic3x_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(aic3x->supplies),\r\naic3x->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to request supplies: %d\n", ret);\r\ngoto err_gpio;\r\n}\r\nif (aic3x->model == AIC3X_MODEL_3007) {\r\nret = regmap_register_patch(aic3x->regmap, aic3007_class_d,\r\nARRAY_SIZE(aic3007_class_d));\r\nif (ret != 0)\r\ndev_err(&i2c->dev, "Failed to init class D: %d\n",\r\nret);\r\n}\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_aic3x, &aic3x_dai, 1);\r\nif (ret != 0)\r\ngoto err_gpio;\r\nlist_add(&aic3x->list, &reset_list);\r\nreturn 0;\r\nerr_gpio:\r\nif (gpio_is_valid(aic3x->gpio_reset) &&\r\n!aic3x_is_shared_reset(aic3x))\r\ngpio_free(aic3x->gpio_reset);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int aic3x_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct aic3x_priv *aic3x = i2c_get_clientdata(client);\r\nsnd_soc_unregister_codec(&client->dev);\r\nif (gpio_is_valid(aic3x->gpio_reset) &&\r\n!aic3x_is_shared_reset(aic3x)) {\r\ngpio_set_value(aic3x->gpio_reset, 0);\r\ngpio_free(aic3x->gpio_reset);\r\n}\r\nreturn 0;\r\n}
