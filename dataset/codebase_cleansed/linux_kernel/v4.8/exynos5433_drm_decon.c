static inline void decon_set_bits(struct decon_context *ctx, u32 reg, u32 mask,\r\nu32 val)\r\n{\r\nval = (val & mask) | (readl(ctx->addr + reg) & ~mask);\r\nwritel(val, ctx->addr + reg);\r\n}\r\nstatic int decon_enable_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nu32 val;\r\nif (test_bit(BIT_SUSPENDED, &ctx->flags))\r\nreturn -EPERM;\r\nif (!test_and_set_bit(BIT_IRQS_ENABLED, &ctx->flags)) {\r\nval = VIDINTCON0_INTEN;\r\nif (ctx->out_type & IFTYPE_I80)\r\nval |= VIDINTCON0_FRAMEDONE;\r\nelse\r\nval |= VIDINTCON0_INTFRMEN;\r\nwritel(val, ctx->addr + DECON_VIDINTCON0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void decon_disable_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nif (test_bit(BIT_SUSPENDED, &ctx->flags))\r\nreturn;\r\nif (test_and_clear_bit(BIT_IRQS_ENABLED, &ctx->flags))\r\nwritel(0, ctx->addr + DECON_VIDINTCON0);\r\n}\r\nstatic void decon_setup_trigger(struct decon_context *ctx)\r\n{\r\nu32 val = !(ctx->out_type & I80_HW_TRG)\r\n? TRIGCON_TRIGEN_PER_F | TRIGCON_TRIGEN_F |\r\nTRIGCON_TE_AUTO_MASK | TRIGCON_SWTRIGEN\r\n: TRIGCON_TRIGEN_PER_F | TRIGCON_TRIGEN_F |\r\nTRIGCON_HWTRIGMASK | TRIGCON_HWTRIGEN;\r\nwritel(val, ctx->addr + DECON_TRIGCON);\r\n}\r\nstatic void decon_commit(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nstruct drm_display_mode *m = &crtc->base.mode;\r\nu32 val;\r\nif (test_bit(BIT_SUSPENDED, &ctx->flags))\r\nreturn;\r\nif (ctx->out_type & IFTYPE_HDMI) {\r\nm->crtc_hsync_start = m->crtc_hdisplay + 10;\r\nm->crtc_hsync_end = m->crtc_htotal - 92;\r\nm->crtc_vsync_start = m->crtc_vdisplay + 1;\r\nm->crtc_vsync_end = m->crtc_vsync_start + 1;\r\n}\r\ndecon_set_bits(ctx, DECON_VIDCON0, VIDCON0_ENVID, 0);\r\nval = CMU_CLKGAGE_MODE_SFR_F | CMU_CLKGAGE_MODE_MEM_F;\r\nwritel(val, ctx->addr + DECON_CMU);\r\nif (ctx->out_type & (IFTYPE_I80 | I80_HW_TRG))\r\ndecon_setup_trigger(ctx);\r\nval = VIDOUT_LCD_ON;\r\nif (ctx->out_type & IFTYPE_I80) {\r\nval |= VIDOUT_COMMAND_IF;\r\n} else {\r\nval |= VIDOUT_RGB_IF;\r\n}\r\nwritel(val, ctx->addr + DECON_VIDOUTCON0);\r\nval = VIDTCON2_LINEVAL(m->vdisplay - 1) |\r\nVIDTCON2_HOZVAL(m->hdisplay - 1);\r\nwritel(val, ctx->addr + DECON_VIDTCON2);\r\nif (!(ctx->out_type & IFTYPE_I80)) {\r\nval = VIDTCON00_VBPD_F(\r\nm->crtc_vtotal - m->crtc_vsync_end - 1) |\r\nVIDTCON00_VFPD_F(\r\nm->crtc_vsync_start - m->crtc_vdisplay - 1);\r\nwritel(val, ctx->addr + DECON_VIDTCON00);\r\nval = VIDTCON01_VSPW_F(\r\nm->crtc_vsync_end - m->crtc_vsync_start - 1);\r\nwritel(val, ctx->addr + DECON_VIDTCON01);\r\nval = VIDTCON10_HBPD_F(\r\nm->crtc_htotal - m->crtc_hsync_end - 1) |\r\nVIDTCON10_HFPD_F(\r\nm->crtc_hsync_start - m->crtc_hdisplay - 1);\r\nwritel(val, ctx->addr + DECON_VIDTCON10);\r\nval = VIDTCON11_HSPW_F(\r\nm->crtc_hsync_end - m->crtc_hsync_start - 1);\r\nwritel(val, ctx->addr + DECON_VIDTCON11);\r\n}\r\ndecon_set_bits(ctx, DECON_VIDCON0, VIDCON0_ENVID | VIDCON0_ENVID_F, ~0);\r\ndecon_set_bits(ctx, DECON_UPDATE, STANDALONE_UPDATE_F, ~0);\r\n}\r\nstatic void decon_win_set_pixfmt(struct decon_context *ctx, unsigned int win,\r\nstruct drm_framebuffer *fb)\r\n{\r\nunsigned long val;\r\nval = readl(ctx->addr + DECON_WINCONx(win));\r\nval &= ~WINCONx_BPPMODE_MASK;\r\nswitch (fb->pixel_format) {\r\ncase DRM_FORMAT_XRGB1555:\r\nval |= WINCONx_BPPMODE_16BPP_I1555;\r\nval |= WINCONx_HAWSWP_F;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_RGB565:\r\nval |= WINCONx_BPPMODE_16BPP_565;\r\nval |= WINCONx_HAWSWP_F;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\nval |= WINCONx_BPPMODE_24BPP_888;\r\nval |= WINCONx_WSWP_F;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_ARGB8888:\r\nval |= WINCONx_BPPMODE_32BPP_A8888;\r\nval |= WINCONx_WSWP_F | WINCONx_BLD_PIX_F | WINCONx_ALPHA_SEL_F;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Proper pixel format is not set\n");\r\nreturn;\r\n}\r\nDRM_DEBUG_KMS("bpp = %u\n", fb->bits_per_pixel);\r\nif (fb->width < MIN_FB_WIDTH_FOR_16WORD_BURST) {\r\nval &= ~WINCONx_BURSTLEN_MASK;\r\nval |= WINCONx_BURSTLEN_8WORD;\r\n}\r\nwritel(val, ctx->addr + DECON_WINCONx(win));\r\n}\r\nstatic void decon_shadow_protect_win(struct decon_context *ctx, int win,\r\nbool protect)\r\n{\r\ndecon_set_bits(ctx, DECON_SHADOWCON, SHADOWCON_Wx_PROTECT(win),\r\nprotect ? ~0 : 0);\r\n}\r\nstatic void decon_atomic_begin(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nint i;\r\nif (test_bit(BIT_SUSPENDED, &ctx->flags))\r\nreturn;\r\nfor (i = ctx->first_win; i < WINDOWS_NR; i++)\r\ndecon_shadow_protect_win(ctx, i, true);\r\n}\r\nstatic void decon_update_plane(struct exynos_drm_crtc *crtc,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct exynos_drm_plane_state *state =\r\nto_exynos_plane_state(plane->base.state);\r\nstruct decon_context *ctx = crtc->ctx;\r\nstruct drm_framebuffer *fb = state->base.fb;\r\nunsigned int win = plane->index;\r\nunsigned int bpp = fb->bits_per_pixel >> 3;\r\nunsigned int pitch = fb->pitches[0];\r\ndma_addr_t dma_addr = exynos_drm_fb_dma_addr(fb, 0);\r\nu32 val;\r\nif (test_bit(BIT_SUSPENDED, &ctx->flags))\r\nreturn;\r\nval = COORDINATE_X(state->crtc.x) | COORDINATE_Y(state->crtc.y);\r\nwritel(val, ctx->addr + DECON_VIDOSDxA(win));\r\nval = COORDINATE_X(state->crtc.x + state->crtc.w - 1) |\r\nCOORDINATE_Y(state->crtc.y + state->crtc.h - 1);\r\nwritel(val, ctx->addr + DECON_VIDOSDxB(win));\r\nval = VIDOSD_Wx_ALPHA_R_F(0x0) | VIDOSD_Wx_ALPHA_G_F(0x0) |\r\nVIDOSD_Wx_ALPHA_B_F(0x0);\r\nwritel(val, ctx->addr + DECON_VIDOSDxC(win));\r\nval = VIDOSD_Wx_ALPHA_R_F(0x0) | VIDOSD_Wx_ALPHA_G_F(0x0) |\r\nVIDOSD_Wx_ALPHA_B_F(0x0);\r\nwritel(val, ctx->addr + DECON_VIDOSDxD(win));\r\nwritel(dma_addr, ctx->addr + DECON_VIDW0xADD0B0(win));\r\nval = dma_addr + pitch * state->src.h;\r\nwritel(val, ctx->addr + DECON_VIDW0xADD1B0(win));\r\nif (!(ctx->out_type & IFTYPE_HDMI))\r\nval = BIT_VAL(pitch - state->crtc.w * bpp, 27, 14)\r\n| BIT_VAL(state->crtc.w * bpp, 13, 0);\r\nelse\r\nval = BIT_VAL(pitch - state->crtc.w * bpp, 29, 15)\r\n| BIT_VAL(state->crtc.w * bpp, 14, 0);\r\nwritel(val, ctx->addr + DECON_VIDW0xADD2(win));\r\ndecon_win_set_pixfmt(ctx, win, fb);\r\ndecon_set_bits(ctx, DECON_WINCONx(win), WINCONx_ENWIN_F, ~0);\r\n}\r\nstatic void decon_disable_plane(struct exynos_drm_crtc *crtc,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nunsigned int win = plane->index;\r\nif (test_bit(BIT_SUSPENDED, &ctx->flags))\r\nreturn;\r\ndecon_set_bits(ctx, DECON_WINCONx(win), WINCONx_ENWIN_F, 0);\r\n}\r\nstatic void decon_atomic_flush(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nint i;\r\nif (test_bit(BIT_SUSPENDED, &ctx->flags))\r\nreturn;\r\nfor (i = ctx->first_win; i < WINDOWS_NR; i++)\r\ndecon_shadow_protect_win(ctx, i, false);\r\ndecon_set_bits(ctx, DECON_UPDATE, STANDALONE_UPDATE_F, ~0);\r\nif (ctx->out_type & IFTYPE_I80)\r\nset_bit(BIT_WIN_UPDATED, &ctx->flags);\r\n}\r\nstatic void decon_swreset(struct decon_context *ctx)\r\n{\r\nunsigned int tries;\r\nwritel(0, ctx->addr + DECON_VIDCON0);\r\nfor (tries = 2000; tries; --tries) {\r\nif (~readl(ctx->addr + DECON_VIDCON0) & VIDCON0_STOP_STATUS)\r\nbreak;\r\nudelay(10);\r\n}\r\nWARN(tries == 0, "failed to disable DECON\n");\r\nwritel(VIDCON0_SWRESET, ctx->addr + DECON_VIDCON0);\r\nfor (tries = 2000; tries; --tries) {\r\nif (~readl(ctx->addr + DECON_VIDCON0) & VIDCON0_SWRESET)\r\nbreak;\r\nudelay(10);\r\n}\r\nWARN(tries == 0, "failed to software reset DECON\n");\r\nif (!(ctx->out_type & IFTYPE_HDMI))\r\nreturn;\r\nwritel(VIDCON0_CLKVALUP | VIDCON0_VLCKFREE, ctx->addr + DECON_VIDCON0);\r\ndecon_set_bits(ctx, DECON_CMU,\r\nCMU_CLKGAGE_MODE_SFR_F | CMU_CLKGAGE_MODE_MEM_F, ~0);\r\nwritel(VIDCON1_VCLK_RUN_VDEN_DISABLE, ctx->addr + DECON_VIDCON1);\r\nwritel(CRCCTRL_CRCEN | CRCCTRL_CRCSTART_F | CRCCTRL_CRCCLKEN,\r\nctx->addr + DECON_CRCCTRL);\r\n}\r\nstatic void decon_enable(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nif (!test_and_clear_bit(BIT_SUSPENDED, &ctx->flags))\r\nreturn;\r\npm_runtime_get_sync(ctx->dev);\r\nexynos_drm_pipe_clk_enable(crtc, true);\r\nset_bit(BIT_CLKS_ENABLED, &ctx->flags);\r\ndecon_swreset(ctx);\r\nif (test_and_clear_bit(BIT_IRQS_ENABLED, &ctx->flags))\r\ndecon_enable_vblank(ctx->crtc);\r\ndecon_commit(ctx->crtc);\r\n}\r\nstatic void decon_disable(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nint i;\r\nif (test_bit(BIT_SUSPENDED, &ctx->flags))\r\nreturn;\r\nfor (i = ctx->first_win; i < WINDOWS_NR; i++)\r\ndecon_disable_plane(crtc, &ctx->planes[i]);\r\ndecon_swreset(ctx);\r\nclear_bit(BIT_CLKS_ENABLED, &ctx->flags);\r\nexynos_drm_pipe_clk_enable(crtc, false);\r\npm_runtime_put_sync(ctx->dev);\r\nset_bit(BIT_SUSPENDED, &ctx->flags);\r\n}\r\nstatic void decon_te_irq_handler(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nif (!test_bit(BIT_CLKS_ENABLED, &ctx->flags) ||\r\n(ctx->out_type & I80_HW_TRG))\r\nreturn;\r\nif (test_and_clear_bit(BIT_WIN_UPDATED, &ctx->flags))\r\ndecon_set_bits(ctx, DECON_TRIGCON, TRIGCON_SWTRIGCMD, ~0);\r\n}\r\nstatic void decon_clear_channels(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nint win, i, ret;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nfor (i = 0; i < ARRAY_SIZE(decon_clks_name); i++) {\r\nret = clk_prepare_enable(ctx->clks[i]);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nfor (win = 0; win < WINDOWS_NR; win++) {\r\ndecon_shadow_protect_win(ctx, win, true);\r\ndecon_set_bits(ctx, DECON_WINCONx(win), WINCONx_ENWIN_F, 0);\r\ndecon_shadow_protect_win(ctx, win, false);\r\n}\r\ndecon_set_bits(ctx, DECON_UPDATE, STANDALONE_UPDATE_F, ~0);\r\nmsleep(50);\r\nerr:\r\nwhile (--i >= 0)\r\nclk_disable_unprepare(ctx->clks[i]);\r\n}\r\nstatic int decon_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct decon_context *ctx = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct exynos_drm_private *priv = drm_dev->dev_private;\r\nstruct exynos_drm_plane *exynos_plane;\r\nenum exynos_drm_output_type out_type;\r\nunsigned int win;\r\nint ret;\r\nctx->drm_dev = drm_dev;\r\nctx->pipe = priv->pipe++;\r\nfor (win = ctx->first_win; win < WINDOWS_NR; win++) {\r\nint tmp = (win == ctx->first_win) ? 0 : win;\r\nctx->configs[win].pixel_formats = decon_formats;\r\nctx->configs[win].num_pixel_formats = ARRAY_SIZE(decon_formats);\r\nctx->configs[win].zpos = win;\r\nctx->configs[win].type = decon_win_types[tmp];\r\nret = exynos_plane_init(drm_dev, &ctx->planes[win], win,\r\n1 << ctx->pipe, &ctx->configs[win]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nexynos_plane = &ctx->planes[ctx->first_win];\r\nout_type = (ctx->out_type & IFTYPE_HDMI) ? EXYNOS_DISPLAY_TYPE_HDMI\r\n: EXYNOS_DISPLAY_TYPE_LCD;\r\nctx->crtc = exynos_drm_crtc_create(drm_dev, &exynos_plane->base,\r\nctx->pipe, out_type,\r\n&decon_crtc_ops, ctx);\r\nif (IS_ERR(ctx->crtc)) {\r\nret = PTR_ERR(ctx->crtc);\r\ngoto err;\r\n}\r\ndecon_clear_channels(ctx->crtc);\r\nret = drm_iommu_attach_device(drm_dev, dev);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\npriv->pipe--;\r\nreturn ret;\r\n}\r\nstatic void decon_unbind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct decon_context *ctx = dev_get_drvdata(dev);\r\ndecon_disable(ctx->crtc);\r\ndrm_iommu_detach_device(ctx->drm_dev, ctx->dev);\r\n}\r\nstatic irqreturn_t decon_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct decon_context *ctx = dev_id;\r\nu32 val;\r\nint win;\r\nif (!test_bit(BIT_CLKS_ENABLED, &ctx->flags))\r\ngoto out;\r\nval = readl(ctx->addr + DECON_VIDINTCON1);\r\nval &= VIDINTCON1_INTFRMDONEPEND | VIDINTCON1_INTFRMPEND;\r\nif (val) {\r\nfor (win = ctx->first_win; win < WINDOWS_NR ; win++) {\r\nstruct exynos_drm_plane *plane = &ctx->planes[win];\r\nif (!plane->pending_fb)\r\ncontinue;\r\nexynos_drm_crtc_finish_update(ctx->crtc, plane);\r\n}\r\nwritel(val, ctx->addr + DECON_VIDINTCON1);\r\ndrm_crtc_handle_vblank(&ctx->crtc->base);\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int exynos5433_decon_suspend(struct device *dev)\r\n{\r\nstruct decon_context *ctx = dev_get_drvdata(dev);\r\nint i = ARRAY_SIZE(decon_clks_name);\r\nwhile (--i >= 0)\r\nclk_disable_unprepare(ctx->clks[i]);\r\nreturn 0;\r\n}\r\nstatic int exynos5433_decon_resume(struct device *dev)\r\n{\r\nstruct decon_context *ctx = dev_get_drvdata(dev);\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(decon_clks_name); i++) {\r\nret = clk_prepare_enable(ctx->clks[i]);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nwhile (--i >= 0)\r\nclk_disable_unprepare(ctx->clks[i]);\r\nreturn ret;\r\n}\r\nstatic int exynos5433_decon_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct decon_context *ctx;\r\nstruct resource *res;\r\nint ret;\r\nint i;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\n__set_bit(BIT_SUSPENDED, &ctx->flags);\r\nctx->dev = dev;\r\nctx->out_type = (unsigned long)of_device_get_match_data(dev);\r\nif (ctx->out_type & IFTYPE_HDMI) {\r\nctx->first_win = 1;\r\n} else if (of_get_child_by_name(dev->of_node, "i80-if-timings")) {\r\nctx->out_type |= IFTYPE_I80;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(decon_clks_name); i++) {\r\nstruct clk *clk;\r\nclk = devm_clk_get(ctx->dev, decon_clks_name[i]);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nctx->clks[i] = clk;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "cannot find IO resource\n");\r\nreturn -ENXIO;\r\n}\r\nctx->addr = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ctx->addr)) {\r\ndev_err(dev, "ioremap failed\n");\r\nreturn PTR_ERR(ctx->addr);\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_IRQ,\r\n(ctx->out_type & IFTYPE_I80) ? "lcd_sys" : "vsync");\r\nif (!res) {\r\ndev_err(dev, "cannot find IRQ resource\n");\r\nreturn -ENXIO;\r\n}\r\nret = devm_request_irq(dev, res->start, decon_irq_handler, 0,\r\n"drm_decon", ctx);\r\nif (ret < 0) {\r\ndev_err(dev, "lcd_sys irq request failed\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, ctx);\r\npm_runtime_enable(dev);\r\nret = component_add(dev, &decon_component_ops);\r\nif (ret)\r\ngoto err_disable_pm_runtime;\r\nreturn 0;\r\nerr_disable_pm_runtime:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int exynos5433_decon_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\ncomponent_del(&pdev->dev, &decon_component_ops);\r\nreturn 0;\r\n}
