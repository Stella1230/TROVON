static u32 hisi_sas_read32(struct hisi_hba *hisi_hba, u32 off)\r\n{\r\nvoid __iomem *regs = hisi_hba->regs + off;\r\nreturn readl(regs);\r\n}\r\nstatic u32 hisi_sas_read32_relaxed(struct hisi_hba *hisi_hba, u32 off)\r\n{\r\nvoid __iomem *regs = hisi_hba->regs + off;\r\nreturn readl_relaxed(regs);\r\n}\r\nstatic void hisi_sas_write32(struct hisi_hba *hisi_hba,\r\nu32 off, u32 val)\r\n{\r\nvoid __iomem *regs = hisi_hba->regs + off;\r\nwritel(val, regs);\r\n}\r\nstatic void hisi_sas_phy_write32(struct hisi_hba *hisi_hba,\r\nint phy_no, u32 off, u32 val)\r\n{\r\nvoid __iomem *regs = hisi_hba->regs + (0x400 * phy_no) + off;\r\nwritel(val, regs);\r\n}\r\nstatic u32 hisi_sas_phy_read32(struct hisi_hba *hisi_hba,\r\nint phy_no, u32 off)\r\n{\r\nvoid __iomem *regs = hisi_hba->regs + (0x400 * phy_no) + off;\r\nreturn readl(regs);\r\n}\r\nstatic void config_phy_opt_mode_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\r\n{\r\nu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\r\ncfg &= ~PHY_CFG_DC_OPT_MSK;\r\ncfg |= 1 << PHY_CFG_DC_OPT_OFF;\r\nhisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\r\n}\r\nstatic void config_tx_tfe_autoneg_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\r\n{\r\nu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CONFIG2);\r\ncfg &= ~PHY_CONFIG2_FORCE_TXDEEMPH_MSK;\r\nhisi_sas_phy_write32(hisi_hba, phy_no, PHY_CONFIG2, cfg);\r\n}\r\nstatic void config_id_frame_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\r\n{\r\nstruct sas_identify_frame identify_frame;\r\nu32 *identify_buffer;\r\nmemset(&identify_frame, 0, sizeof(identify_frame));\r\nidentify_frame.dev_type = SAS_END_DEVICE;\r\nidentify_frame.frame_type = 0;\r\nidentify_frame._un1 = 1;\r\nidentify_frame.initiator_bits = SAS_PROTOCOL_ALL;\r\nidentify_frame.target_bits = SAS_PROTOCOL_NONE;\r\nmemcpy(&identify_frame._un4_11[0], hisi_hba->sas_addr, SAS_ADDR_SIZE);\r\nmemcpy(&identify_frame.sas_addr[0], hisi_hba->sas_addr, SAS_ADDR_SIZE);\r\nidentify_frame.phy_id = phy_no;\r\nidentify_buffer = (u32 *)(&identify_frame);\r\nhisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD0,\r\n__swab32(identify_buffer[0]));\r\nhisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD1,\r\nidentify_buffer[2]);\r\nhisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD2,\r\nidentify_buffer[1]);\r\nhisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD3,\r\nidentify_buffer[4]);\r\nhisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD4,\r\nidentify_buffer[3]);\r\nhisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD5,\r\n__swab32(identify_buffer[5]));\r\n}\r\nstatic void init_id_frame_v1_hw(struct hisi_hba *hisi_hba)\r\n{\r\nint i;\r\nfor (i = 0; i < hisi_hba->n_phy; i++)\r\nconfig_id_frame_v1_hw(hisi_hba, i);\r\n}\r\nstatic void setup_itct_v1_hw(struct hisi_hba *hisi_hba,\r\nstruct hisi_sas_device *sas_dev)\r\n{\r\nstruct domain_device *device = sas_dev->sas_device;\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nu64 qw0, device_id = sas_dev->device_id;\r\nstruct hisi_sas_itct *itct = &hisi_hba->itct[device_id];\r\nmemset(itct, 0, sizeof(*itct));\r\nqw0 = 0;\r\nswitch (sas_dev->dev_type) {\r\ncase SAS_END_DEVICE:\r\ncase SAS_EDGE_EXPANDER_DEVICE:\r\ncase SAS_FANOUT_EXPANDER_DEVICE:\r\nqw0 = HISI_SAS_DEV_TYPE_SSP << ITCT_HDR_DEV_TYPE_OFF;\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "setup itct: unsupported dev type (%d)\n",\r\nsas_dev->dev_type);\r\n}\r\nqw0 |= ((1 << ITCT_HDR_VALID_OFF) |\r\n(1 << ITCT_HDR_AWT_CONTROL_OFF) |\r\n(device->max_linkrate << ITCT_HDR_MAX_CONN_RATE_OFF) |\r\n(1 << ITCT_HDR_VALID_LINK_NUM_OFF) |\r\n(device->port->id << ITCT_HDR_PORT_ID_OFF));\r\nitct->qw0 = cpu_to_le64(qw0);\r\nmemcpy(&itct->sas_addr, device->sas_addr, SAS_ADDR_SIZE);\r\nitct->sas_addr = __swab64(itct->sas_addr);\r\nitct->qw2 = cpu_to_le64((500ULL << ITCT_HDR_IT_NEXUS_LOSS_TL_OFF) |\r\n(0xff00ULL << ITCT_HDR_BUS_INACTIVE_TL_OFF) |\r\n(0xff00ULL << ITCT_HDR_MAX_CONN_TL_OFF) |\r\n(0xff00ULL << ITCT_HDR_REJ_OPEN_TL_OFF));\r\n}\r\nstatic void free_device_v1_hw(struct hisi_hba *hisi_hba,\r\nstruct hisi_sas_device *sas_dev)\r\n{\r\nu64 dev_id = sas_dev->device_id;\r\nstruct hisi_sas_itct *itct = &hisi_hba->itct[dev_id];\r\nu64 qw0;\r\nu32 reg_val = hisi_sas_read32(hisi_hba, CFG_AGING_TIME);\r\nreg_val |= CFG_AGING_TIME_ITCT_REL_MSK;\r\nhisi_sas_write32(hisi_hba, CFG_AGING_TIME, reg_val);\r\nudelay(1);\r\nreg_val = hisi_sas_read32(hisi_hba, CFG_AGING_TIME);\r\nreg_val &= ~CFG_AGING_TIME_ITCT_REL_MSK;\r\nhisi_sas_write32(hisi_hba, CFG_AGING_TIME, reg_val);\r\nqw0 = cpu_to_le64(itct->qw0);\r\nqw0 &= ~ITCT_HDR_VALID_MSK;\r\nitct->qw0 = cpu_to_le64(qw0);\r\n}\r\nstatic int reset_hw_v1_hw(struct hisi_hba *hisi_hba)\r\n{\r\nint i;\r\nunsigned long end_time;\r\nu32 val;\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nfor (i = 0; i < hisi_hba->n_phy; i++) {\r\nu32 phy_ctrl = hisi_sas_phy_read32(hisi_hba, i, PHY_CTRL);\r\nphy_ctrl |= PHY_CTRL_RESET_MSK;\r\nhisi_sas_phy_write32(hisi_hba, i, PHY_CTRL, phy_ctrl);\r\n}\r\nmsleep(1);\r\nfor (i = 0; i < hisi_hba->n_phy; i++) {\r\nu32 dma_tx_status, dma_rx_status;\r\nend_time = jiffies + msecs_to_jiffies(1000);\r\nwhile (1) {\r\ndma_tx_status = hisi_sas_phy_read32(hisi_hba, i,\r\nDMA_TX_STATUS);\r\ndma_rx_status = hisi_sas_phy_read32(hisi_hba, i,\r\nDMA_RX_STATUS);\r\nif (!(dma_tx_status & DMA_TX_STATUS_BUSY_MSK) &&\r\n!(dma_rx_status & DMA_RX_STATUS_BUSY_MSK))\r\nbreak;\r\nmsleep(20);\r\nif (time_after(jiffies, end_time))\r\nreturn -EIO;\r\n}\r\n}\r\nend_time = jiffies + msecs_to_jiffies(1000);\r\nwhile (1) {\r\nu32 axi_status =\r\nhisi_sas_read32(hisi_hba, AXI_CFG);\r\nif (axi_status == 0)\r\nbreak;\r\nmsleep(20);\r\nif (time_after(jiffies, end_time))\r\nreturn -EIO;\r\n}\r\nif (ACPI_HANDLE(dev)) {\r\nacpi_status s;\r\ns = acpi_evaluate_object(ACPI_HANDLE(dev), "_RST", NULL, NULL);\r\nif (ACPI_FAILURE(s)) {\r\ndev_err(dev, "Reset failed\n");\r\nreturn -EIO;\r\n}\r\n} else if (hisi_hba->ctrl) {\r\nregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_reset_reg,\r\nRESET_VALUE);\r\nregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_clock_ena_reg + 4,\r\nRESET_VALUE);\r\nmsleep(1);\r\nregmap_read(hisi_hba->ctrl, hisi_hba->ctrl_reset_sts_reg, &val);\r\nif (RESET_VALUE != (val & RESET_VALUE)) {\r\ndev_err(dev, "Reset failed\n");\r\nreturn -EIO;\r\n}\r\nregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_reset_reg + 4,\r\nRESET_VALUE);\r\nregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_clock_ena_reg,\r\nRESET_VALUE);\r\nmsleep(1);\r\nregmap_read(hisi_hba->ctrl, hisi_hba->ctrl_reset_sts_reg, &val);\r\nif (val & RESET_VALUE) {\r\ndev_err(dev, "De-reset failed\n");\r\nreturn -EIO;\r\n}\r\n} else\r\ndev_warn(dev, "no reset method\n");\r\nreturn 0;\r\n}\r\nstatic void init_reg_v1_hw(struct hisi_hba *hisi_hba)\r\n{\r\nint i;\r\nhisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE,\r\n(u32)((1ULL << hisi_hba->queue_count) - 1));\r\nhisi_sas_write32(hisi_hba, HGC_TRANS_TASK_CNT_LIMIT, 0x11);\r\nhisi_sas_write32(hisi_hba, DEVICE_MSG_WORK_MODE, 0x1);\r\nhisi_sas_write32(hisi_hba, HGC_SAS_TXFAIL_RETRY_CTRL, 0x1ff);\r\nhisi_sas_write32(hisi_hba, HGC_ERR_STAT_EN, 0x401);\r\nhisi_sas_write32(hisi_hba, CFG_1US_TIMER_TRSH, 0x64);\r\nhisi_sas_write32(hisi_hba, HGC_GET_ITV_TIME, 0x1);\r\nhisi_sas_write32(hisi_hba, I_T_NEXUS_LOSS_TIME, 0x64);\r\nhisi_sas_write32(hisi_hba, BUS_INACTIVE_LIMIT_TIME, 0x2710);\r\nhisi_sas_write32(hisi_hba, REJECT_TO_OPEN_LIMIT_TIME, 0x1);\r\nhisi_sas_write32(hisi_hba, CFG_AGING_TIME, 0x7a12);\r\nhisi_sas_write32(hisi_hba, HGC_DFX_CFG2, 0x9c40);\r\nhisi_sas_write32(hisi_hba, FIS_LIST_BADDR_L, 0x2);\r\nhisi_sas_write32(hisi_hba, INT_COAL_EN, 0xc);\r\nhisi_sas_write32(hisi_hba, OQ_INT_COAL_TIME, 0x186a0);\r\nhisi_sas_write32(hisi_hba, OQ_INT_COAL_CNT, 1);\r\nhisi_sas_write32(hisi_hba, ENT_INT_COAL_TIME, 0x1);\r\nhisi_sas_write32(hisi_hba, ENT_INT_COAL_CNT, 0x1);\r\nhisi_sas_write32(hisi_hba, OQ_INT_SRC, 0xffffffff);\r\nhisi_sas_write32(hisi_hba, OQ_INT_SRC_MSK, 0);\r\nhisi_sas_write32(hisi_hba, ENT_INT_SRC1, 0xffffffff);\r\nhisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK1, 0);\r\nhisi_sas_write32(hisi_hba, ENT_INT_SRC2, 0xffffffff);\r\nhisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK2, 0);\r\nhisi_sas_write32(hisi_hba, SAS_ECC_INTR_MSK, 0);\r\nhisi_sas_write32(hisi_hba, AXI_AHB_CLK_CFG, 0x2);\r\nhisi_sas_write32(hisi_hba, CFG_SAS_CONFIG, 0x22000000);\r\nfor (i = 0; i < hisi_hba->n_phy; i++) {\r\nhisi_sas_phy_write32(hisi_hba, i, PROG_PHY_LINK_RATE, 0x88a);\r\nhisi_sas_phy_write32(hisi_hba, i, PHY_CONFIG2, 0x7c080);\r\nhisi_sas_phy_write32(hisi_hba, i, PHY_RATE_NEGO, 0x415ee00);\r\nhisi_sas_phy_write32(hisi_hba, i, PHY_PCN, 0x80a80000);\r\nhisi_sas_phy_write32(hisi_hba, i, SL_TOUT_CFG, 0x7d7d7d7d);\r\nhisi_sas_phy_write32(hisi_hba, i, DONE_RECEIVED_TIME, 0x0);\r\nhisi_sas_phy_write32(hisi_hba, i, RXOP_CHECK_CFG_H, 0x1000);\r\nhisi_sas_phy_write32(hisi_hba, i, DONE_RECEIVED_TIME, 0);\r\nhisi_sas_phy_write32(hisi_hba, i, CON_CFG_DRIVER, 0x13f0a);\r\nhisi_sas_phy_write32(hisi_hba, i, CHL_INT_COAL_EN, 3);\r\nhisi_sas_phy_write32(hisi_hba, i, DONE_RECEIVED_TIME, 8);\r\n}\r\nfor (i = 0; i < hisi_hba->queue_count; i++) {\r\nhisi_sas_write32(hisi_hba,\r\nDLVRY_Q_0_BASE_ADDR_HI + (i * 0x14),\r\nupper_32_bits(hisi_hba->cmd_hdr_dma[i]));\r\nhisi_sas_write32(hisi_hba,\r\nDLVRY_Q_0_BASE_ADDR_LO + (i * 0x14),\r\nlower_32_bits(hisi_hba->cmd_hdr_dma[i]));\r\nhisi_sas_write32(hisi_hba,\r\nDLVRY_Q_0_DEPTH + (i * 0x14),\r\nHISI_SAS_QUEUE_SLOTS);\r\nhisi_sas_write32(hisi_hba,\r\nCOMPL_Q_0_BASE_ADDR_HI + (i * 0x14),\r\nupper_32_bits(hisi_hba->complete_hdr_dma[i]));\r\nhisi_sas_write32(hisi_hba,\r\nCOMPL_Q_0_BASE_ADDR_LO + (i * 0x14),\r\nlower_32_bits(hisi_hba->complete_hdr_dma[i]));\r\nhisi_sas_write32(hisi_hba, COMPL_Q_0_DEPTH + (i * 0x14),\r\nHISI_SAS_QUEUE_SLOTS);\r\n}\r\nhisi_sas_write32(hisi_hba, ITCT_BASE_ADDR_LO,\r\nlower_32_bits(hisi_hba->itct_dma));\r\nhisi_sas_write32(hisi_hba, ITCT_BASE_ADDR_HI,\r\nupper_32_bits(hisi_hba->itct_dma));\r\nhisi_sas_write32(hisi_hba, IOST_BASE_ADDR_LO,\r\nlower_32_bits(hisi_hba->iost_dma));\r\nhisi_sas_write32(hisi_hba, IOST_BASE_ADDR_HI,\r\nupper_32_bits(hisi_hba->iost_dma));\r\nhisi_sas_write32(hisi_hba, BROKEN_MSG_ADDR_LO,\r\nlower_32_bits(hisi_hba->breakpoint_dma));\r\nhisi_sas_write32(hisi_hba, BROKEN_MSG_ADDR_HI,\r\nupper_32_bits(hisi_hba->breakpoint_dma));\r\n}\r\nstatic int hw_init_v1_hw(struct hisi_hba *hisi_hba)\r\n{\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nint rc;\r\nrc = reset_hw_v1_hw(hisi_hba);\r\nif (rc) {\r\ndev_err(dev, "hisi_sas_reset_hw failed, rc=%d", rc);\r\nreturn rc;\r\n}\r\nmsleep(100);\r\ninit_reg_v1_hw(hisi_hba);\r\ninit_id_frame_v1_hw(hisi_hba);\r\nreturn 0;\r\n}\r\nstatic void enable_phy_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\r\n{\r\nu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\r\ncfg |= PHY_CFG_ENA_MSK;\r\nhisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\r\n}\r\nstatic void disable_phy_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\r\n{\r\nu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\r\ncfg &= ~PHY_CFG_ENA_MSK;\r\nhisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\r\n}\r\nstatic void start_phy_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\r\n{\r\nconfig_id_frame_v1_hw(hisi_hba, phy_no);\r\nconfig_phy_opt_mode_v1_hw(hisi_hba, phy_no);\r\nconfig_tx_tfe_autoneg_v1_hw(hisi_hba, phy_no);\r\nenable_phy_v1_hw(hisi_hba, phy_no);\r\n}\r\nstatic void stop_phy_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\r\n{\r\ndisable_phy_v1_hw(hisi_hba, phy_no);\r\n}\r\nstatic void phy_hard_reset_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\r\n{\r\nstop_phy_v1_hw(hisi_hba, phy_no);\r\nmsleep(100);\r\nstart_phy_v1_hw(hisi_hba, phy_no);\r\n}\r\nstatic void start_phys_v1_hw(unsigned long data)\r\n{\r\nstruct hisi_hba *hisi_hba = (struct hisi_hba *)data;\r\nint i;\r\nfor (i = 0; i < hisi_hba->n_phy; i++) {\r\nhisi_sas_phy_write32(hisi_hba, i, CHL_INT2_MSK, 0x12a);\r\nstart_phy_v1_hw(hisi_hba, i);\r\n}\r\n}\r\nstatic void phys_init_v1_hw(struct hisi_hba *hisi_hba)\r\n{\r\nint i;\r\nstruct timer_list *timer = &hisi_hba->timer;\r\nfor (i = 0; i < hisi_hba->n_phy; i++) {\r\nhisi_sas_phy_write32(hisi_hba, i, CHL_INT2_MSK, 0x6a);\r\nhisi_sas_phy_read32(hisi_hba, i, CHL_INT2_MSK);\r\n}\r\nsetup_timer(timer, start_phys_v1_hw, (unsigned long)hisi_hba);\r\nmod_timer(timer, jiffies + HZ);\r\n}\r\nstatic void sl_notify_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\r\n{\r\nu32 sl_control;\r\nsl_control = hisi_sas_phy_read32(hisi_hba, phy_no, SL_CONTROL);\r\nsl_control |= SL_CONTROL_NOTIFY_EN_MSK;\r\nhisi_sas_phy_write32(hisi_hba, phy_no, SL_CONTROL, sl_control);\r\nmsleep(1);\r\nsl_control = hisi_sas_phy_read32(hisi_hba, phy_no, SL_CONTROL);\r\nsl_control &= ~SL_CONTROL_NOTIFY_EN_MSK;\r\nhisi_sas_phy_write32(hisi_hba, phy_no, SL_CONTROL, sl_control);\r\n}\r\nstatic int get_wideport_bitmap_v1_hw(struct hisi_hba *hisi_hba, int port_id)\r\n{\r\nint i, bitmap = 0;\r\nu32 phy_port_num_ma = hisi_sas_read32(hisi_hba, PHY_PORT_NUM_MA);\r\nfor (i = 0; i < hisi_hba->n_phy; i++)\r\nif (((phy_port_num_ma >> (i * 4)) & 0xf) == port_id)\r\nbitmap |= 1 << i;\r\nreturn bitmap;\r\n}\r\nstatic int get_free_slot_v1_hw(struct hisi_hba *hisi_hba, int *q, int *s)\r\n{\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nu32 r, w;\r\nint queue = hisi_hba->queue;\r\nwhile (1) {\r\nw = hisi_sas_read32_relaxed(hisi_hba,\r\nDLVRY_Q_0_WR_PTR + (queue * 0x14));\r\nr = hisi_sas_read32_relaxed(hisi_hba,\r\nDLVRY_Q_0_RD_PTR + (queue * 0x14));\r\nif (r == (w+1) % HISI_SAS_QUEUE_SLOTS) {\r\nqueue = (queue + 1) % hisi_hba->queue_count;\r\nif (queue == hisi_hba->queue) {\r\ndev_warn(dev, "could not find free slot\n");\r\nreturn -EAGAIN;\r\n}\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nhisi_hba->queue = (queue + 1) % hisi_hba->queue_count;\r\n*q = queue;\r\n*s = w;\r\nreturn 0;\r\n}\r\nstatic void start_delivery_v1_hw(struct hisi_hba *hisi_hba)\r\n{\r\nint dlvry_queue = hisi_hba->slot_prep->dlvry_queue;\r\nint dlvry_queue_slot = hisi_hba->slot_prep->dlvry_queue_slot;\r\nhisi_sas_write32(hisi_hba,\r\nDLVRY_Q_0_WR_PTR + (dlvry_queue * 0x14),\r\n++dlvry_queue_slot % HISI_SAS_QUEUE_SLOTS);\r\n}\r\nstatic int prep_prd_sge_v1_hw(struct hisi_hba *hisi_hba,\r\nstruct hisi_sas_slot *slot,\r\nstruct hisi_sas_cmd_hdr *hdr,\r\nstruct scatterlist *scatter,\r\nint n_elem)\r\n{\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nstruct scatterlist *sg;\r\nint i;\r\nif (n_elem > HISI_SAS_SGE_PAGE_CNT) {\r\ndev_err(dev, "prd err: n_elem(%d) > HISI_SAS_SGE_PAGE_CNT",\r\nn_elem);\r\nreturn -EINVAL;\r\n}\r\nslot->sge_page = dma_pool_alloc(hisi_hba->sge_page_pool, GFP_ATOMIC,\r\n&slot->sge_page_dma);\r\nif (!slot->sge_page)\r\nreturn -ENOMEM;\r\nfor_each_sg(scatter, sg, n_elem, i) {\r\nstruct hisi_sas_sge *entry = &slot->sge_page->sge[i];\r\nentry->addr = cpu_to_le64(sg_dma_address(sg));\r\nentry->page_ctrl_0 = entry->page_ctrl_1 = 0;\r\nentry->data_len = cpu_to_le32(sg_dma_len(sg));\r\nentry->data_off = 0;\r\n}\r\nhdr->prd_table_addr = cpu_to_le64(slot->sge_page_dma);\r\nhdr->sg_len = cpu_to_le32(n_elem << CMD_HDR_DATA_SGL_LEN_OFF);\r\nreturn 0;\r\n}\r\nstatic int prep_smp_v1_hw(struct hisi_hba *hisi_hba,\r\nstruct hisi_sas_slot *slot)\r\n{\r\nstruct sas_task *task = slot->task;\r\nstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\r\nstruct domain_device *device = task->dev;\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nstruct hisi_sas_port *port = slot->port;\r\nstruct scatterlist *sg_req, *sg_resp;\r\nstruct hisi_sas_device *sas_dev = device->lldd_dev;\r\ndma_addr_t req_dma_addr;\r\nunsigned int req_len, resp_len;\r\nint elem, rc;\r\nsg_req = &task->smp_task.smp_req;\r\nelem = dma_map_sg(dev, sg_req, 1, DMA_TO_DEVICE);\r\nif (!elem)\r\nreturn -ENOMEM;\r\nreq_len = sg_dma_len(sg_req);\r\nreq_dma_addr = sg_dma_address(sg_req);\r\nsg_resp = &task->smp_task.smp_resp;\r\nelem = dma_map_sg(dev, sg_resp, 1, DMA_FROM_DEVICE);\r\nif (!elem) {\r\nrc = -ENOMEM;\r\ngoto err_out_req;\r\n}\r\nresp_len = sg_dma_len(sg_resp);\r\nif ((req_len & 0x3) || (resp_len & 0x3)) {\r\nrc = -EINVAL;\r\ngoto err_out_resp;\r\n}\r\nhdr->dw0 = cpu_to_le32((port->id << CMD_HDR_PORT_OFF) |\r\n(1 << CMD_HDR_PRIORITY_OFF) |\r\n(1 << CMD_HDR_MODE_OFF) |\r\n(2 << CMD_HDR_CMD_OFF));\r\nhdr->dw1 = cpu_to_le32(sas_dev->device_id << CMD_HDR_DEVICE_ID_OFF);\r\nhdr->dw2 = cpu_to_le32((((req_len-4)/4) << CMD_HDR_CFL_OFF) |\r\n(HISI_SAS_MAX_SMP_RESP_SZ/4 <<\r\nCMD_HDR_MRFL_OFF));\r\nhdr->transfer_tags = cpu_to_le32(slot->idx << CMD_HDR_IPTT_OFF);\r\nhdr->cmd_table_addr = cpu_to_le64(req_dma_addr);\r\nhdr->sts_buffer_addr = cpu_to_le64(slot->status_buffer_dma);\r\nreturn 0;\r\nerr_out_resp:\r\ndma_unmap_sg(dev, &slot->task->smp_task.smp_resp, 1,\r\nDMA_FROM_DEVICE);\r\nerr_out_req:\r\ndma_unmap_sg(dev, &slot->task->smp_task.smp_req, 1,\r\nDMA_TO_DEVICE);\r\nreturn rc;\r\n}\r\nstatic int prep_ssp_v1_hw(struct hisi_hba *hisi_hba,\r\nstruct hisi_sas_slot *slot, int is_tmf,\r\nstruct hisi_sas_tmf_task *tmf)\r\n{\r\nstruct sas_task *task = slot->task;\r\nstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\r\nstruct domain_device *device = task->dev;\r\nstruct hisi_sas_device *sas_dev = device->lldd_dev;\r\nstruct hisi_sas_port *port = slot->port;\r\nstruct sas_ssp_task *ssp_task = &task->ssp_task;\r\nstruct scsi_cmnd *scsi_cmnd = ssp_task->cmd;\r\nint has_data = 0, rc, priority = is_tmf;\r\nu8 *buf_cmd, fburst = 0;\r\nu32 dw1, dw2;\r\nhdr->dw0 = cpu_to_le32((1 << CMD_HDR_RESP_REPORT_OFF) |\r\n(0x2 << CMD_HDR_TLR_CTRL_OFF) |\r\n(port->id << CMD_HDR_PORT_OFF) |\r\n(priority << CMD_HDR_PRIORITY_OFF) |\r\n(1 << CMD_HDR_MODE_OFF) |\r\n(1 << CMD_HDR_CMD_OFF));\r\ndw1 = 1 << CMD_HDR_VERIFY_DTL_OFF;\r\nif (is_tmf) {\r\ndw1 |= 3 << CMD_HDR_SSP_FRAME_TYPE_OFF;\r\n} else {\r\nswitch (scsi_cmnd->sc_data_direction) {\r\ncase DMA_TO_DEVICE:\r\ndw1 |= 2 << CMD_HDR_SSP_FRAME_TYPE_OFF;\r\nhas_data = 1;\r\nbreak;\r\ncase DMA_FROM_DEVICE:\r\ndw1 |= 1 << CMD_HDR_SSP_FRAME_TYPE_OFF;\r\nhas_data = 1;\r\nbreak;\r\ndefault:\r\ndw1 |= 0 << CMD_HDR_SSP_FRAME_TYPE_OFF;\r\n}\r\n}\r\ndw1 |= sas_dev->device_id << CMD_HDR_DEVICE_ID_OFF;\r\nhdr->dw1 = cpu_to_le32(dw1);\r\nif (is_tmf) {\r\ndw2 = ((sizeof(struct ssp_tmf_iu) +\r\nsizeof(struct ssp_frame_hdr)+3)/4) <<\r\nCMD_HDR_CFL_OFF;\r\n} else {\r\ndw2 = ((sizeof(struct ssp_command_iu) +\r\nsizeof(struct ssp_frame_hdr)+3)/4) <<\r\nCMD_HDR_CFL_OFF;\r\n}\r\ndw2 |= (HISI_SAS_MAX_SSP_RESP_SZ/4) << CMD_HDR_MRFL_OFF;\r\nhdr->transfer_tags = cpu_to_le32(slot->idx << CMD_HDR_IPTT_OFF);\r\nif (has_data) {\r\nrc = prep_prd_sge_v1_hw(hisi_hba, slot, hdr, task->scatter,\r\nslot->n_elem);\r\nif (rc)\r\nreturn rc;\r\n}\r\nhdr->data_transfer_len = cpu_to_le32(task->total_xfer_len);\r\nhdr->cmd_table_addr = cpu_to_le64(slot->command_table_dma);\r\nhdr->sts_buffer_addr = cpu_to_le64(slot->status_buffer_dma);\r\nbuf_cmd = slot->command_table + sizeof(struct ssp_frame_hdr);\r\nif (task->ssp_task.enable_first_burst) {\r\nfburst = (1 << 7);\r\ndw2 |= 1 << CMD_HDR_FIRST_BURST_OFF;\r\n}\r\nhdr->dw2 = cpu_to_le32(dw2);\r\nmemcpy(buf_cmd, &task->ssp_task.LUN, 8);\r\nif (!is_tmf) {\r\nbuf_cmd[9] = fburst | task->ssp_task.task_attr |\r\n(task->ssp_task.task_prio << 3);\r\nmemcpy(buf_cmd + 12, task->ssp_task.cmd->cmnd,\r\ntask->ssp_task.cmd->cmd_len);\r\n} else {\r\nbuf_cmd[10] = tmf->tmf;\r\nswitch (tmf->tmf) {\r\ncase TMF_ABORT_TASK:\r\ncase TMF_QUERY_TASK:\r\nbuf_cmd[12] =\r\n(tmf->tag_of_task_to_be_managed >> 8) & 0xff;\r\nbuf_cmd[13] =\r\ntmf->tag_of_task_to_be_managed & 0xff;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void slot_err_v1_hw(struct hisi_hba *hisi_hba,\r\nstruct sas_task *task,\r\nstruct hisi_sas_slot *slot)\r\n{\r\nstruct task_status_struct *ts = &task->task_status;\r\nstruct hisi_sas_err_record_v1 *err_record = slot->status_buffer;\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SSP:\r\n{\r\nint error = -1;\r\nu32 dma_err_type = cpu_to_le32(err_record->dma_err_type);\r\nu32 dma_tx_err_type = ((dma_err_type &\r\nERR_HDR_DMA_TX_ERR_TYPE_MSK)) >>\r\nERR_HDR_DMA_TX_ERR_TYPE_OFF;\r\nu32 dma_rx_err_type = ((dma_err_type &\r\nERR_HDR_DMA_RX_ERR_TYPE_MSK)) >>\r\nERR_HDR_DMA_RX_ERR_TYPE_OFF;\r\nu32 trans_tx_fail_type =\r\ncpu_to_le32(err_record->trans_tx_fail_type);\r\nu32 trans_rx_fail_type =\r\ncpu_to_le32(err_record->trans_rx_fail_type);\r\nif (dma_tx_err_type) {\r\nerror = ffs(dma_tx_err_type)\r\n- 1 + DMA_TX_ERR_BASE;\r\n} else if (dma_rx_err_type) {\r\nerror = ffs(dma_rx_err_type)\r\n- 1 + DMA_RX_ERR_BASE;\r\n} else if (trans_tx_fail_type) {\r\nerror = ffs(trans_tx_fail_type)\r\n- 1 + TRANS_TX_FAIL_BASE;\r\n} else if (trans_rx_fail_type) {\r\nerror = ffs(trans_rx_fail_type)\r\n- 1 + TRANS_RX_FAIL_BASE;\r\n}\r\nswitch (error) {\r\ncase DMA_TX_DATA_UNDERFLOW_ERR:\r\ncase DMA_RX_DATA_UNDERFLOW_ERR:\r\n{\r\nts->residual = 0;\r\nts->stat = SAS_DATA_UNDERRUN;\r\nbreak;\r\n}\r\ncase DMA_TX_DATA_SGL_OVERFLOW_ERR:\r\ncase DMA_TX_DIF_SGL_OVERFLOW_ERR:\r\ncase DMA_TX_XFER_RDY_LENGTH_OVERFLOW_ERR:\r\ncase DMA_RX_DATA_OVERFLOW_ERR:\r\ncase TRANS_RX_FRAME_OVERRUN_ERR:\r\ncase TRANS_RX_LINK_BUF_OVERRUN_ERR:\r\n{\r\nts->stat = SAS_DATA_OVERRUN;\r\nts->residual = 0;\r\nbreak;\r\n}\r\ncase TRANS_TX_PHY_NOT_ENABLE_ERR:\r\n{\r\nts->stat = SAS_PHY_DOWN;\r\nbreak;\r\n}\r\ncase TRANS_TX_OPEN_REJCT_WRONG_DEST_ERR:\r\ncase TRANS_TX_OPEN_REJCT_ZONE_VIOLATION_ERR:\r\ncase TRANS_TX_OPEN_REJCT_BY_OTHER_ERR:\r\ncase TRANS_TX_OPEN_REJCT_AIP_TIMEOUT_ERR:\r\ncase TRANS_TX_OPEN_REJCT_STP_BUSY_ERR:\r\ncase TRANS_TX_OPEN_REJCT_PROTOCOL_NOT_SUPPORT_ERR:\r\ncase TRANS_TX_OPEN_REJCT_RATE_NOT_SUPPORT_ERR:\r\ncase TRANS_TX_OPEN_REJCT_BAD_DEST_ERR:\r\ncase TRANS_TX_OPEN_BREAK_RECEIVE_ERR:\r\ncase TRANS_TX_OPEN_REJCT_PATHWAY_BLOCKED_ERR:\r\ncase TRANS_TX_OPEN_REJCT_NO_DEST_ERR:\r\ncase TRANS_TX_OPEN_RETRY_ERR:\r\n{\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\n}\r\ncase TRANS_TX_OPEN_TIMEOUT_ERR:\r\n{\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\n}\r\ncase TRANS_TX_NAK_RECEIVE_ERR:\r\ncase TRANS_TX_ACK_NAK_TIMEOUT_ERR:\r\n{\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\n}\r\ncase TRANS_TX_CREDIT_TIMEOUT_ERR:\r\ncase TRANS_TX_CLOSE_NORMAL_ERR:\r\n{\r\nts->stat = SAS_QUEUE_FULL;\r\nslot->abort = 1;\r\nbreak;\r\n}\r\ndefault:\r\n{\r\nts->stat = SAM_STAT_CHECK_CONDITION;\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase SAS_PROTOCOL_SMP:\r\nts->stat = SAM_STAT_CHECK_CONDITION;\r\nbreak;\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\ncase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\r\n{\r\ndev_err(dev, "slot err: SATA/STP not supported");\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int slot_complete_v1_hw(struct hisi_hba *hisi_hba,\r\nstruct hisi_sas_slot *slot, int abort)\r\n{\r\nstruct sas_task *task = slot->task;\r\nstruct hisi_sas_device *sas_dev;\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nstruct task_status_struct *ts;\r\nstruct domain_device *device;\r\nenum exec_status sts;\r\nstruct hisi_sas_complete_v1_hdr *complete_queue =\r\nhisi_hba->complete_hdr[slot->cmplt_queue];\r\nstruct hisi_sas_complete_v1_hdr *complete_hdr;\r\nu32 cmplt_hdr_data;\r\ncomplete_hdr = &complete_queue[slot->cmplt_queue_slot];\r\ncmplt_hdr_data = le32_to_cpu(complete_hdr->data);\r\nif (unlikely(!task || !task->lldd_task || !task->dev))\r\nreturn -EINVAL;\r\nts = &task->task_status;\r\ndevice = task->dev;\r\nsas_dev = device->lldd_dev;\r\ntask->task_state_flags &=\r\n~(SAS_TASK_STATE_PENDING | SAS_TASK_AT_INITIATOR);\r\ntask->task_state_flags |= SAS_TASK_STATE_DONE;\r\nmemset(ts, 0, sizeof(*ts));\r\nts->resp = SAS_TASK_COMPLETE;\r\nif (unlikely(!sas_dev || abort)) {\r\nif (!sas_dev)\r\ndev_dbg(dev, "slot complete: port has not device\n");\r\nts->stat = SAS_PHY_DOWN;\r\ngoto out;\r\n}\r\nif (cmplt_hdr_data & CMPLT_HDR_IO_CFG_ERR_MSK) {\r\nu32 info_reg = hisi_sas_read32(hisi_hba, HGC_INVLD_DQE_INFO);\r\nif (info_reg & HGC_INVLD_DQE_INFO_DQ_MSK)\r\ndev_err(dev, "slot complete: [%d:%d] has dq IPTT err",\r\nslot->cmplt_queue, slot->cmplt_queue_slot);\r\nif (info_reg & HGC_INVLD_DQE_INFO_TYPE_MSK)\r\ndev_err(dev, "slot complete: [%d:%d] has dq type err",\r\nslot->cmplt_queue, slot->cmplt_queue_slot);\r\nif (info_reg & HGC_INVLD_DQE_INFO_FORCE_MSK)\r\ndev_err(dev, "slot complete: [%d:%d] has dq force phy err",\r\nslot->cmplt_queue, slot->cmplt_queue_slot);\r\nif (info_reg & HGC_INVLD_DQE_INFO_PHY_MSK)\r\ndev_err(dev, "slot complete: [%d:%d] has dq phy id err",\r\nslot->cmplt_queue, slot->cmplt_queue_slot);\r\nif (info_reg & HGC_INVLD_DQE_INFO_ABORT_MSK)\r\ndev_err(dev, "slot complete: [%d:%d] has dq abort flag err",\r\nslot->cmplt_queue, slot->cmplt_queue_slot);\r\nif (info_reg & HGC_INVLD_DQE_INFO_IPTT_OF_MSK)\r\ndev_err(dev, "slot complete: [%d:%d] has dq IPTT or ICT err",\r\nslot->cmplt_queue, slot->cmplt_queue_slot);\r\nif (info_reg & HGC_INVLD_DQE_INFO_SSP_ERR_MSK)\r\ndev_err(dev, "slot complete: [%d:%d] has dq SSP frame type err",\r\nslot->cmplt_queue, slot->cmplt_queue_slot);\r\nif (info_reg & HGC_INVLD_DQE_INFO_OFL_MSK)\r\ndev_err(dev, "slot complete: [%d:%d] has dq order frame len err",\r\nslot->cmplt_queue, slot->cmplt_queue_slot);\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\ngoto out;\r\n}\r\nif (cmplt_hdr_data & CMPLT_HDR_ERR_RCRD_XFRD_MSK &&\r\n!(cmplt_hdr_data & CMPLT_HDR_RSPNS_XFRD_MSK)) {\r\nslot_err_v1_hw(hisi_hba, task, slot);\r\nif (unlikely(slot->abort)) {\r\nqueue_work(hisi_hba->wq, &slot->abort_slot);\r\nreturn ts->stat;\r\n}\r\ngoto out;\r\n}\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SSP:\r\n{\r\nstruct ssp_response_iu *iu = slot->status_buffer +\r\nsizeof(struct hisi_sas_err_record);\r\nsas_ssp_task_response(dev, task, iu);\r\nbreak;\r\n}\r\ncase SAS_PROTOCOL_SMP:\r\n{\r\nvoid *to;\r\nstruct scatterlist *sg_resp = &task->smp_task.smp_resp;\r\nts->stat = SAM_STAT_GOOD;\r\nto = kmap_atomic(sg_page(sg_resp));\r\ndma_unmap_sg(dev, &task->smp_task.smp_resp, 1,\r\nDMA_FROM_DEVICE);\r\ndma_unmap_sg(dev, &task->smp_task.smp_req, 1,\r\nDMA_TO_DEVICE);\r\nmemcpy(to + sg_resp->offset,\r\nslot->status_buffer +\r\nsizeof(struct hisi_sas_err_record),\r\nsg_dma_len(sg_resp));\r\nkunmap_atomic(to);\r\nbreak;\r\n}\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\ncase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\r\ndev_err(dev, "slot complete: SATA/STP not supported");\r\nbreak;\r\ndefault:\r\nts->stat = SAM_STAT_CHECK_CONDITION;\r\nbreak;\r\n}\r\nif (!slot->port->port_attached) {\r\ndev_err(dev, "slot complete: port %d has removed\n",\r\nslot->port->sas_port.id);\r\nts->stat = SAS_PHY_DOWN;\r\n}\r\nout:\r\nif (sas_dev && sas_dev->running_req)\r\nsas_dev->running_req--;\r\nhisi_sas_slot_task_free(hisi_hba, task, slot);\r\nsts = ts->stat;\r\nif (task->task_done)\r\ntask->task_done(task);\r\nreturn sts;\r\n}\r\nstatic irqreturn_t int_phyup_v1_hw(int irq_no, void *p)\r\n{\r\nstruct hisi_sas_phy *phy = p;\r\nstruct hisi_hba *hisi_hba = phy->hisi_hba;\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nint i, phy_no = sas_phy->id;\r\nu32 irq_value, context, port_id, link_rate;\r\nu32 *frame_rcvd = (u32 *)sas_phy->frame_rcvd;\r\nstruct sas_identify_frame *id = (struct sas_identify_frame *)frame_rcvd;\r\nirqreturn_t res = IRQ_HANDLED;\r\nirq_value = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT2);\r\nif (!(irq_value & CHL_INT2_SL_PHY_ENA_MSK)) {\r\ndev_dbg(dev, "phyup: irq_value = %x not set enable bit\n",\r\nirq_value);\r\nres = IRQ_NONE;\r\ngoto end;\r\n}\r\ncontext = hisi_sas_read32(hisi_hba, PHY_CONTEXT);\r\nif (context & 1 << phy_no) {\r\ndev_err(dev, "phyup: phy%d SATA attached equipment\n",\r\nphy_no);\r\ngoto end;\r\n}\r\nport_id = (hisi_sas_read32(hisi_hba, PHY_PORT_NUM_MA) >> (4 * phy_no))\r\n& 0xf;\r\nif (port_id == 0xf) {\r\ndev_err(dev, "phyup: phy%d invalid portid\n", phy_no);\r\nres = IRQ_NONE;\r\ngoto end;\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nu32 idaf = hisi_sas_phy_read32(hisi_hba, phy_no,\r\nRX_IDAF_DWORD0 + (i * 4));\r\nframe_rcvd[i] = __swab32(idaf);\r\n}\r\nlink_rate = hisi_sas_read32(hisi_hba, PHY_CONN_RATE);\r\nlink_rate = (link_rate >> (phy_no * 4)) & 0xf;\r\nsas_phy->linkrate = link_rate;\r\nsas_phy->oob_mode = SAS_OOB_MODE;\r\nmemcpy(sas_phy->attached_sas_addr,\r\n&id->sas_addr, SAS_ADDR_SIZE);\r\ndev_info(dev, "phyup: phy%d link_rate=%d\n",\r\nphy_no, link_rate);\r\nphy->port_id = port_id;\r\nphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\r\nphy->phy_type |= PORT_TYPE_SAS;\r\nphy->phy_attached = 1;\r\nphy->identify.device_type = id->dev_type;\r\nphy->frame_rcvd_size = sizeof(struct sas_identify_frame);\r\nif (phy->identify.device_type == SAS_END_DEVICE)\r\nphy->identify.target_port_protocols =\r\nSAS_PROTOCOL_SSP;\r\nelse if (phy->identify.device_type != SAS_PHY_UNUSED)\r\nphy->identify.target_port_protocols =\r\nSAS_PROTOCOL_SMP;\r\nqueue_work(hisi_hba->wq, &phy->phyup_ws);\r\nend:\r\nhisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT2,\r\nCHL_INT2_SL_PHY_ENA_MSK);\r\nif (irq_value & CHL_INT2_SL_PHY_ENA_MSK) {\r\nu32 chl_int0 = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT0);\r\nchl_int0 &= ~CHL_INT0_PHYCTRL_NOTRDY_MSK;\r\nhisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0, chl_int0);\r\nhisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0_MSK, 0x3ce3ee);\r\n}\r\nreturn res;\r\n}\r\nstatic irqreturn_t int_bcast_v1_hw(int irq, void *p)\r\n{\r\nstruct hisi_sas_phy *phy = p;\r\nstruct hisi_hba *hisi_hba = phy->hisi_hba;\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nstruct sas_ha_struct *sha = &hisi_hba->sha;\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nint phy_no = sas_phy->id;\r\nu32 irq_value;\r\nirqreturn_t res = IRQ_HANDLED;\r\nirq_value = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT2);\r\nif (!(irq_value & CHL_INT2_SL_RX_BC_ACK_MSK)) {\r\ndev_err(dev, "bcast: irq_value = %x not set enable bit",\r\nirq_value);\r\nres = IRQ_NONE;\r\ngoto end;\r\n}\r\nsha->notify_port_event(sas_phy, PORTE_BROADCAST_RCVD);\r\nend:\r\nhisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT2,\r\nCHL_INT2_SL_RX_BC_ACK_MSK);\r\nreturn res;\r\n}\r\nstatic irqreturn_t int_abnormal_v1_hw(int irq, void *p)\r\n{\r\nstruct hisi_sas_phy *phy = p;\r\nstruct hisi_hba *hisi_hba = phy->hisi_hba;\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nu32 irq_value, irq_mask_old;\r\nint phy_no = sas_phy->id;\r\nirq_mask_old = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT0_MSK);\r\nhisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0_MSK, 0x3fffff);\r\nirq_value = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT0);\r\nif (irq_value & CHL_INT0_PHYCTRL_NOTRDY_MSK) {\r\nu32 phy_state = hisi_sas_read32(hisi_hba, PHY_STATE);\r\nhisi_sas_phy_down(hisi_hba, phy_no,\r\n(phy_state & 1 << phy_no) ? 1 : 0);\r\n}\r\nif (irq_value & CHL_INT0_ID_TIMEOUT_MSK)\r\ndev_dbg(dev, "abnormal: ID_TIMEOUT phy%d identify timeout\n",\r\nphy_no);\r\nif (irq_value & CHL_INT0_DWS_LOST_MSK)\r\ndev_dbg(dev, "abnormal: DWS_LOST phy%d dws lost\n", phy_no);\r\nif (irq_value & CHL_INT0_SN_FAIL_NGR_MSK)\r\ndev_dbg(dev, "abnormal: SN_FAIL_NGR phy%d sn fail ngr\n",\r\nphy_no);\r\nif (irq_value & CHL_INT0_SL_IDAF_FAIL_MSK ||\r\nirq_value & CHL_INT0_SL_OPAF_FAIL_MSK)\r\ndev_dbg(dev, "abnormal: SL_ID/OPAF_FAIL phy%d check adr frm err\n",\r\nphy_no);\r\nif (irq_value & CHL_INT0_SL_PS_FAIL_OFF)\r\ndev_dbg(dev, "abnormal: SL_PS_FAIL phy%d fail\n", phy_no);\r\nhisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0, irq_value);\r\nif (irq_value & CHL_INT0_PHYCTRL_NOTRDY_MSK)\r\nhisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0_MSK,\r\n0x3fffff & ~CHL_INT0_MSK_PHYCTRL_NOTRDY_MSK);\r\nelse\r\nhisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0_MSK,\r\nirq_mask_old);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t cq_interrupt_v1_hw(int irq, void *p)\r\n{\r\nstruct hisi_sas_cq *cq = p;\r\nstruct hisi_hba *hisi_hba = cq->hisi_hba;\r\nstruct hisi_sas_slot *slot;\r\nint queue = cq->id;\r\nstruct hisi_sas_complete_v1_hdr *complete_queue =\r\n(struct hisi_sas_complete_v1_hdr *)\r\nhisi_hba->complete_hdr[queue];\r\nu32 irq_value, rd_point, wr_point;\r\nirq_value = hisi_sas_read32(hisi_hba, OQ_INT_SRC);\r\nhisi_sas_write32(hisi_hba, OQ_INT_SRC, 1 << queue);\r\nrd_point = hisi_sas_read32(hisi_hba,\r\nCOMPL_Q_0_RD_PTR + (0x14 * queue));\r\nwr_point = hisi_sas_read32(hisi_hba,\r\nCOMPL_Q_0_WR_PTR + (0x14 * queue));\r\nwhile (rd_point != wr_point) {\r\nstruct hisi_sas_complete_v1_hdr *complete_hdr;\r\nint idx;\r\nu32 cmplt_hdr_data;\r\ncomplete_hdr = &complete_queue[rd_point];\r\ncmplt_hdr_data = cpu_to_le32(complete_hdr->data);\r\nidx = (cmplt_hdr_data & CMPLT_HDR_IPTT_MSK) >>\r\nCMPLT_HDR_IPTT_OFF;\r\nslot = &hisi_hba->slot_info[idx];\r\nslot->cmplt_queue_slot = rd_point;\r\nslot->cmplt_queue = queue;\r\nslot_complete_v1_hw(hisi_hba, slot, 0);\r\nif (++rd_point >= HISI_SAS_QUEUE_SLOTS)\r\nrd_point = 0;\r\n}\r\nhisi_sas_write32(hisi_hba, COMPL_Q_0_RD_PTR + (0x14 * queue), rd_point);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t fatal_ecc_int_v1_hw(int irq, void *p)\r\n{\r\nstruct hisi_hba *hisi_hba = p;\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nu32 ecc_int = hisi_sas_read32(hisi_hba, SAS_ECC_INTR);\r\nif (ecc_int & SAS_ECC_INTR_DQ_ECC1B_MSK) {\r\nu32 ecc_err = hisi_sas_read32(hisi_hba, HGC_ECC_ERR);\r\npanic("%s: Fatal DQ 1b ECC interrupt (0x%x)\n",\r\ndev_name(dev), ecc_err);\r\n}\r\nif (ecc_int & SAS_ECC_INTR_DQ_ECCBAD_MSK) {\r\nu32 addr = (hisi_sas_read32(hisi_hba, HGC_DQ_ECC_ADDR) &\r\nHGC_DQ_ECC_ADDR_BAD_MSK) >>\r\nHGC_DQ_ECC_ADDR_BAD_OFF;\r\npanic("%s: Fatal DQ RAM ECC interrupt @ 0x%08x\n",\r\ndev_name(dev), addr);\r\n}\r\nif (ecc_int & SAS_ECC_INTR_IOST_ECC1B_MSK) {\r\nu32 ecc_err = hisi_sas_read32(hisi_hba, HGC_ECC_ERR);\r\npanic("%s: Fatal IOST 1b ECC interrupt (0x%x)\n",\r\ndev_name(dev), ecc_err);\r\n}\r\nif (ecc_int & SAS_ECC_INTR_IOST_ECCBAD_MSK) {\r\nu32 addr = (hisi_sas_read32(hisi_hba, HGC_IOST_ECC_ADDR) &\r\nHGC_IOST_ECC_ADDR_BAD_MSK) >>\r\nHGC_IOST_ECC_ADDR_BAD_OFF;\r\npanic("%s: Fatal IOST RAM ECC interrupt @ 0x%08x\n",\r\ndev_name(dev), addr);\r\n}\r\nif (ecc_int & SAS_ECC_INTR_ITCT_ECCBAD_MSK) {\r\nu32 addr = (hisi_sas_read32(hisi_hba, HGC_ITCT_ECC_ADDR) &\r\nHGC_ITCT_ECC_ADDR_BAD_MSK) >>\r\nHGC_ITCT_ECC_ADDR_BAD_OFF;\r\npanic("%s: Fatal TCT RAM ECC interrupt @ 0x%08x\n",\r\ndev_name(dev), addr);\r\n}\r\nif (ecc_int & SAS_ECC_INTR_ITCT_ECC1B_MSK) {\r\nu32 ecc_err = hisi_sas_read32(hisi_hba, HGC_ECC_ERR);\r\npanic("%s: Fatal ITCT 1b ECC interrupt (0x%x)\n",\r\ndev_name(dev), ecc_err);\r\n}\r\nhisi_sas_write32(hisi_hba, SAS_ECC_INTR, ecc_int | 0x3f);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t fatal_axi_int_v1_hw(int irq, void *p)\r\n{\r\nstruct hisi_hba *hisi_hba = p;\r\nstruct device *dev = &hisi_hba->pdev->dev;\r\nu32 axi_int = hisi_sas_read32(hisi_hba, ENT_INT_SRC2);\r\nu32 axi_info = hisi_sas_read32(hisi_hba, HGC_AXI_FIFO_ERR_INFO);\r\nif (axi_int & ENT_INT_SRC2_DQ_CFG_ERR_MSK)\r\npanic("%s: Fatal DQ_CFG_ERR interrupt (0x%x)\n",\r\ndev_name(dev), axi_info);\r\nif (axi_int & ENT_INT_SRC2_CQ_CFG_ERR_MSK)\r\npanic("%s: Fatal CQ_CFG_ERR interrupt (0x%x)\n",\r\ndev_name(dev), axi_info);\r\nif (axi_int & ENT_INT_SRC2_AXI_WRONG_INT_MSK)\r\npanic("%s: Fatal AXI_WRONG_INT interrupt (0x%x)\n",\r\ndev_name(dev), axi_info);\r\nif (axi_int & ENT_INT_SRC2_AXI_OVERLF_INT_MSK)\r\npanic("%s: Fatal AXI_OVERLF_INT incorrect interrupt (0x%x)\n",\r\ndev_name(dev), axi_info);\r\nhisi_sas_write32(hisi_hba, ENT_INT_SRC2, axi_int | 0x30000000);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int interrupt_init_v1_hw(struct hisi_hba *hisi_hba)\r\n{\r\nstruct platform_device *pdev = hisi_hba->pdev;\r\nstruct device *dev = &pdev->dev;\r\nint i, j, irq, rc, idx;\r\nfor (i = 0; i < hisi_hba->n_phy; i++) {\r\nstruct hisi_sas_phy *phy = &hisi_hba->phy[i];\r\nidx = i * HISI_SAS_PHY_INT_NR;\r\nfor (j = 0; j < HISI_SAS_PHY_INT_NR; j++, idx++) {\r\nirq = platform_get_irq(pdev, idx);\r\nif (!irq) {\r\ndev_err(dev,\r\n"irq init: fail map phy interrupt %d\n",\r\nidx);\r\nreturn -ENOENT;\r\n}\r\nrc = devm_request_irq(dev, irq, phy_interrupts[j], 0,\r\nDRV_NAME " phy", phy);\r\nif (rc) {\r\ndev_err(dev, "irq init: could not request "\r\n"phy interrupt %d, rc=%d\n",\r\nirq, rc);\r\nreturn -ENOENT;\r\n}\r\n}\r\n}\r\nidx = hisi_hba->n_phy * HISI_SAS_PHY_INT_NR;\r\nfor (i = 0; i < hisi_hba->queue_count; i++, idx++) {\r\nirq = platform_get_irq(pdev, idx);\r\nif (!irq) {\r\ndev_err(dev, "irq init: could not map cq interrupt %d\n",\r\nidx);\r\nreturn -ENOENT;\r\n}\r\nrc = devm_request_irq(dev, irq, cq_interrupt_v1_hw, 0,\r\nDRV_NAME " cq", &hisi_hba->cq[i]);\r\nif (rc) {\r\ndev_err(dev, "irq init: could not request cq interrupt %d, rc=%d\n",\r\nirq, rc);\r\nreturn -ENOENT;\r\n}\r\n}\r\nidx = (hisi_hba->n_phy * HISI_SAS_PHY_INT_NR) + hisi_hba->queue_count;\r\nfor (i = 0; i < HISI_SAS_FATAL_INT_NR; i++, idx++) {\r\nirq = platform_get_irq(pdev, idx);\r\nif (!irq) {\r\ndev_err(dev, "irq init: could not map fatal interrupt %d\n",\r\nidx);\r\nreturn -ENOENT;\r\n}\r\nrc = devm_request_irq(dev, irq, fatal_interrupts[i], 0,\r\nDRV_NAME " fatal", hisi_hba);\r\nif (rc) {\r\ndev_err(dev,\r\n"irq init: could not request fatal interrupt %d, rc=%d\n",\r\nirq, rc);\r\nreturn -ENOENT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int interrupt_openall_v1_hw(struct hisi_hba *hisi_hba)\r\n{\r\nint i;\r\nu32 val;\r\nfor (i = 0; i < hisi_hba->n_phy; i++) {\r\nval = hisi_sas_phy_read32(hisi_hba, i, CHL_INT0);\r\nhisi_sas_phy_write32(hisi_hba, i, CHL_INT0, val);\r\nval = hisi_sas_phy_read32(hisi_hba, i, CHL_INT1);\r\nhisi_sas_phy_write32(hisi_hba, i, CHL_INT1, val);\r\nval = hisi_sas_phy_read32(hisi_hba, i, CHL_INT2);\r\nhisi_sas_phy_write32(hisi_hba, i, CHL_INT2, val);\r\nhisi_sas_phy_write32(hisi_hba, i, CHL_INT0_MSK, 0x3ce3ee);\r\nhisi_sas_phy_write32(hisi_hba, i, CHL_INT1_MSK, 0x17fff);\r\nhisi_sas_phy_write32(hisi_hba, i, CHL_INT2_MSK, 0x8000012a);\r\nhisi_sas_phy_write32(hisi_hba, i, CHL_INT0_MSK,\r\n0x3fffff & ~CHL_INT0_MSK_PHYCTRL_NOTRDY_MSK);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hisi_sas_v1_init(struct hisi_hba *hisi_hba)\r\n{\r\nint rc;\r\nrc = hw_init_v1_hw(hisi_hba);\r\nif (rc)\r\nreturn rc;\r\nrc = interrupt_init_v1_hw(hisi_hba);\r\nif (rc)\r\nreturn rc;\r\nrc = interrupt_openall_v1_hw(hisi_hba);\r\nif (rc)\r\nreturn rc;\r\nphys_init_v1_hw(hisi_hba);\r\nreturn 0;\r\n}\r\nstatic int hisi_sas_v1_probe(struct platform_device *pdev)\r\n{\r\nreturn hisi_sas_probe(pdev, &hisi_sas_v1_hw);\r\n}\r\nstatic int hisi_sas_v1_remove(struct platform_device *pdev)\r\n{\r\nreturn hisi_sas_remove(pdev);\r\n}
