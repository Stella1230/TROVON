static void PRINT_PKT(u_char *buf, int length)\r\n{\r\nint i;\r\nint remainder;\r\nint lines;\r\nlines = length / 16;\r\nremainder = length % 16;\r\nfor (i = 0; i < lines ; i ++) {\r\nint cur;\r\nprintk(KERN_DEBUG);\r\nfor (cur = 0; cur < 8; cur++) {\r\nu_char a, b;\r\na = *buf++;\r\nb = *buf++;\r\npr_cont("%02x%02x ", a, b);\r\n}\r\npr_cont("\n");\r\n}\r\nprintk(KERN_DEBUG);\r\nfor (i = 0; i < remainder/2 ; i++) {\r\nu_char a, b;\r\na = *buf++;\r\nb = *buf++;\r\npr_cont("%02x%02x ", a, b);\r\n}\r\npr_cont("\n");\r\n}\r\nstatic void smc911x_reset(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned int reg, timeout=0, resets=1, irq_cfg;\r\nunsigned long flags;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nif ((SMC_GET_PMT_CTRL(lp) & PMT_CTRL_READY_) == 0) {\r\nSMC_SET_BYTE_TEST(lp, 0);\r\ntimeout=10;\r\ndo {\r\nudelay(10);\r\nreg = SMC_GET_PMT_CTRL(lp) & PMT_CTRL_READY_;\r\n} while (--timeout && !reg);\r\nif (timeout == 0) {\r\nPRINTK(dev, "smc911x_reset timeout waiting for PM restore\n");\r\nreturn;\r\n}\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nSMC_SET_INT_EN(lp, 0);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nwhile (resets--) {\r\nSMC_SET_HW_CFG(lp, HW_CFG_SRST_);\r\ntimeout=10;\r\ndo {\r\nudelay(10);\r\nreg = SMC_GET_HW_CFG(lp);\r\nif (reg & HW_CFG_SRST_TO_) {\r\nPRINTK(dev, "chip reset timeout, retrying...\n");\r\nresets++;\r\nbreak;\r\n}\r\n} while (--timeout && (reg & HW_CFG_SRST_));\r\n}\r\nif (timeout == 0) {\r\nPRINTK(dev, "smc911x_reset timeout waiting for reset\n");\r\nreturn;\r\n}\r\ntimeout=1000;\r\nwhile (--timeout && (SMC_GET_E2P_CMD(lp) & E2P_CMD_EPC_BUSY_))\r\nudelay(10);\r\nif (timeout == 0){\r\nPRINTK(dev, "smc911x_reset timeout waiting for EEPROM busy\n");\r\nreturn;\r\n}\r\nSMC_SET_INT_EN(lp, 0);\r\nSMC_ACK_INT(lp, -1);\r\nSMC_SET_HW_CFG(lp, (lp->tx_fifo_kb & 0xF) << 16);\r\nSMC_SET_FLOW(lp, FLOW_FCPT_ | FLOW_FCEN_);\r\nSMC_SET_AFC_CFG(lp, lp->afc_cfg);\r\nSMC_SET_GPIO_CFG(lp, 0x70070000);\r\nirq_cfg = (1 << 24) | INT_CFG_IRQ_EN_ | INT_CFG_IRQ_TYPE_;\r\n#ifdef SMC_DYNAMIC_BUS_CONFIG\r\nif (lp->cfg.irq_polarity)\r\nirq_cfg |= INT_CFG_IRQ_POL_;\r\n#endif\r\nSMC_SET_IRQ_CFG(lp, irq_cfg);\r\nif (lp->pending_tx_skb != NULL) {\r\ndev_kfree_skb (lp->pending_tx_skb);\r\nlp->pending_tx_skb = NULL;\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\n}\r\n}\r\nstatic void smc911x_enable(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned mask, cfg, cr;\r\nunsigned long flags;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nSMC_SET_MAC_ADDR(lp, dev->dev_addr);\r\ncfg = SMC_GET_HW_CFG(lp);\r\ncfg &= HW_CFG_TX_FIF_SZ_ | 0xFFF;\r\ncfg |= HW_CFG_SF_;\r\nSMC_SET_HW_CFG(lp, cfg);\r\nSMC_SET_FIFO_TDA(lp, 0xFF);\r\nSMC_SET_FIFO_TSL(lp, 64);\r\nSMC_SET_GPT_CFG(lp, GPT_CFG_TIMER_EN_ | 10000);\r\nSMC_GET_MAC_CR(lp, cr);\r\ncr |= MAC_CR_TXEN_ | MAC_CR_HBDIS_;\r\nSMC_SET_MAC_CR(lp, cr);\r\nSMC_SET_TX_CFG(lp, TX_CFG_TX_ON_);\r\nSMC_SET_RX_CFG(lp, (2<<8) & RX_CFG_RXDOFF_);\r\nif (cr & MAC_CR_RXEN_)\r\nDBG(SMC_DEBUG_RX, dev, "Receiver already enabled\n");\r\nSMC_SET_MAC_CR(lp, cr | MAC_CR_RXEN_);\r\nSMC_SET_FIFO_RSA(lp, 0x01);\r\nSMC_SET_FIFO_RSL(lp, 0x00);\r\nmask = INT_EN_TDFA_EN_ | INT_EN_TSFL_EN_ | INT_EN_RSFL_EN_ |\r\nINT_EN_GPT_INT_EN_ | INT_EN_RXDFH_INT_EN_ | INT_EN_RXE_EN_ |\r\nINT_EN_PHY_INT_EN_;\r\nif (IS_REV_A(lp->revision))\r\nmask|=INT_EN_RDFL_EN_;\r\nelse {\r\nmask|=INT_EN_RDFO_EN_;\r\n}\r\nSMC_ENABLE_INT(lp, mask);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic void smc911x_shutdown(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned cr;\r\nunsigned long flags;\r\nDBG(SMC_DEBUG_FUNC, dev, "%s: --> %s\n", CARDNAME, __func__);\r\nSMC_SET_INT_EN(lp, 0);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nSMC_GET_MAC_CR(lp, cr);\r\ncr &= ~(MAC_CR_TXEN_ | MAC_CR_RXEN_ | MAC_CR_HBDIS_);\r\nSMC_SET_MAC_CR(lp, cr);\r\nSMC_SET_TX_CFG(lp, TX_CFG_STOP_TX_);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic inline void smc911x_drop_pkt(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned int fifo_count, timeout, reg;\r\nDBG(SMC_DEBUG_FUNC | SMC_DEBUG_RX, dev, "%s: --> %s\n",\r\nCARDNAME, __func__);\r\nfifo_count = SMC_GET_RX_FIFO_INF(lp) & 0xFFFF;\r\nif (fifo_count <= 4) {\r\nwhile (fifo_count--)\r\nSMC_GET_RX_FIFO(lp);\r\n} else {\r\nSMC_SET_RX_DP_CTRL(lp, RX_DP_CTRL_FFWD_BUSY_);\r\ntimeout=50;\r\ndo {\r\nudelay(10);\r\nreg = SMC_GET_RX_DP_CTRL(lp) & RX_DP_CTRL_FFWD_BUSY_;\r\n} while (--timeout && reg);\r\nif (timeout == 0) {\r\nPRINTK(dev, "timeout waiting for RX fast forward\n");\r\n}\r\n}\r\n}\r\nstatic inline void smc911x_rcv(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned int pkt_len, status;\r\nstruct sk_buff *skb;\r\nunsigned char *data;\r\nDBG(SMC_DEBUG_FUNC | SMC_DEBUG_RX, dev, "--> %s\n",\r\n__func__);\r\nstatus = SMC_GET_RX_STS_FIFO(lp);\r\nDBG(SMC_DEBUG_RX, dev, "Rx pkt len %d status 0x%08x\n",\r\n(status & 0x3fff0000) >> 16, status & 0xc000ffff);\r\npkt_len = (status & RX_STS_PKT_LEN_) >> 16;\r\nif (status & RX_STS_ES_) {\r\ndev->stats.rx_errors++;\r\nif (status & RX_STS_CRC_ERR_)\r\ndev->stats.rx_crc_errors++;\r\nelse {\r\nif (status & RX_STS_LEN_ERR_)\r\ndev->stats.rx_length_errors++;\r\nif (status & RX_STS_MCAST_)\r\ndev->stats.multicast++;\r\n}\r\nsmc911x_drop_pkt(dev);\r\n} else {\r\nskb = netdev_alloc_skb(dev, pkt_len+32);\r\nif (unlikely(skb == NULL)) {\r\nPRINTK(dev, "Low memory, rcvd packet dropped.\n");\r\ndev->stats.rx_dropped++;\r\nsmc911x_drop_pkt(dev);\r\nreturn;\r\n}\r\ndata = skb->data;\r\nskb_reserve(skb, 2);\r\nskb_put(skb,pkt_len-4);\r\n#ifdef SMC_USE_DMA\r\n{\r\nunsigned int fifo;\r\nfifo = SMC_GET_FIFO_INT(lp);\r\nif (fifo & 0xFF) fifo--;\r\nDBG(SMC_DEBUG_RX, dev, "Setting RX stat FIFO threshold to %d\n",\r\nfifo & 0xff);\r\nSMC_SET_FIFO_INT(lp, fifo);\r\nSMC_SET_RX_CFG(lp, RX_CFG_RX_END_ALGN16_ | ((2<<8) & RX_CFG_RXDOFF_));\r\nlp->rxdma_active = 1;\r\nlp->current_rx_skb = skb;\r\nSMC_PULL_DATA(lp, data, (pkt_len+2+15) & ~15);\r\n}\r\n#else\r\nSMC_SET_RX_CFG(lp, RX_CFG_RX_END_ALGN4_ | ((2<<8) & RX_CFG_RXDOFF_));\r\nSMC_PULL_DATA(lp, data, pkt_len+2+3);\r\nDBG(SMC_DEBUG_PKTS, dev, "Received packet\n");\r\nPRINT_PKT(data, ((pkt_len - 4) <= 64) ? pkt_len - 4 : 64);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len-4;\r\n#endif\r\n}\r\n}\r\nstatic void smc911x_hardware_send_pkt(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nunsigned int cmdA, cmdB, len;\r\nunsigned char *buf;\r\nDBG(SMC_DEBUG_FUNC | SMC_DEBUG_TX, dev, "--> %s\n", __func__);\r\nBUG_ON(lp->pending_tx_skb == NULL);\r\nskb = lp->pending_tx_skb;\r\nlp->pending_tx_skb = NULL;\r\n#ifdef SMC_USE_DMA\r\nbuf = (char*)((u32)(skb->data) & ~0xF);\r\nlen = (skb->len + 0xF + ((u32)skb->data & 0xF)) & ~0xF;\r\ncmdA = (1<<24) | (((u32)skb->data & 0xF)<<16) |\r\nTX_CMD_A_INT_FIRST_SEG_ | TX_CMD_A_INT_LAST_SEG_ |\r\nskb->len;\r\n#else\r\nbuf = (char*)((u32)skb->data & ~0x3);\r\nlen = (skb->len + 3 + ((u32)skb->data & 3)) & ~0x3;\r\ncmdA = (((u32)skb->data & 0x3) << 16) |\r\nTX_CMD_A_INT_FIRST_SEG_ | TX_CMD_A_INT_LAST_SEG_ |\r\nskb->len;\r\n#endif\r\ncmdB = (skb->len << 16) | (skb->len & 0x7FF);\r\nDBG(SMC_DEBUG_TX, dev, "TX PKT LENGTH 0x%04x (%d) BUF 0x%p CMDA 0x%08x CMDB 0x%08x\n",\r\nlen, len, buf, cmdA, cmdB);\r\nSMC_SET_TX_FIFO(lp, cmdA);\r\nSMC_SET_TX_FIFO(lp, cmdB);\r\nDBG(SMC_DEBUG_PKTS, dev, "Transmitted packet\n");\r\nPRINT_PKT(buf, len <= 64 ? len : 64);\r\n#ifdef SMC_USE_DMA\r\nlp->current_tx_skb = skb;\r\nSMC_PUSH_DATA(lp, buf, len);\r\n#else\r\nSMC_PUSH_DATA(lp, buf, len);\r\nnetif_trans_update(dev);\r\ndev_kfree_skb_irq(skb);\r\n#endif\r\nif (!lp->tx_throttle) {\r\nnetif_wake_queue(dev);\r\n}\r\nSMC_ENABLE_INT(lp, INT_EN_TDFA_EN_ | INT_EN_TSFL_EN_);\r\n}\r\nstatic int smc911x_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned int free;\r\nunsigned long flags;\r\nDBG(SMC_DEBUG_FUNC | SMC_DEBUG_TX, dev, "--> %s\n",\r\n__func__);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nBUG_ON(lp->pending_tx_skb != NULL);\r\nfree = SMC_GET_TX_FIFO_INF(lp) & TX_FIFO_INF_TDFREE_;\r\nDBG(SMC_DEBUG_TX, dev, "TX free space %d\n", free);\r\nif (free <= SMC911X_TX_FIFO_LOW_THRESHOLD) {\r\nDBG(SMC_DEBUG_TX, dev, "Disabling data flow due to low FIFO space (%d)\n",\r\nfree);\r\nSMC_SET_FIFO_TDA(lp, (SMC911X_TX_FIFO_LOW_THRESHOLD)/64);\r\nlp->tx_throttle = 1;\r\nnetif_stop_queue(dev);\r\n}\r\nif (unlikely(free < (skb->len + 8 + 15 + 15))) {\r\nnetdev_warn(dev, "No Tx free space %d < %d\n",\r\nfree, skb->len);\r\nlp->pending_tx_skb = NULL;\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_dropped++;\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\n#ifdef SMC_USE_DMA\r\n{\r\nif (lp->txdma_active) {\r\nDBG(SMC_DEBUG_TX | SMC_DEBUG_DMA, dev, "Tx DMA running, deferring packet\n");\r\nlp->pending_tx_skb = skb;\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n} else {\r\nDBG(SMC_DEBUG_TX | SMC_DEBUG_DMA, dev, "Activating Tx DMA\n");\r\nlp->txdma_active = 1;\r\n}\r\n}\r\n#endif\r\nlp->pending_tx_skb = skb;\r\nsmc911x_hardware_send_pkt(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void smc911x_tx(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned int tx_status;\r\nDBG(SMC_DEBUG_FUNC | SMC_DEBUG_TX, dev, "--> %s\n",\r\n__func__);\r\nwhile (((SMC_GET_TX_FIFO_INF(lp) & TX_FIFO_INF_TSUSED_) >> 16) != 0) {\r\nDBG(SMC_DEBUG_TX, dev, "Tx stat FIFO used 0x%04x\n",\r\n(SMC_GET_TX_FIFO_INF(lp) & TX_FIFO_INF_TSUSED_) >> 16);\r\ntx_status = SMC_GET_TX_STS_FIFO(lp);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes+=tx_status>>16;\r\nDBG(SMC_DEBUG_TX, dev, "Tx FIFO tag 0x%04x status 0x%04x\n",\r\n(tx_status & 0xffff0000) >> 16,\r\ntx_status & 0x0000ffff);\r\nif ((tx_status & TX_STS_ES_) && !(lp->ctl_rfduplx &&\r\n!(tx_status & 0x00000306))) {\r\ndev->stats.tx_errors++;\r\n}\r\nif (tx_status & TX_STS_MANY_COLL_) {\r\ndev->stats.collisions+=16;\r\ndev->stats.tx_aborted_errors++;\r\n} else {\r\ndev->stats.collisions+=(tx_status & TX_STS_COLL_CNT_) >> 3;\r\n}\r\nif ((tx_status & (TX_STS_LOC_ | TX_STS_NO_CARR_)) &&\r\n!lp->ctl_rfduplx) {\r\ndev->stats.tx_carrier_errors++;\r\n}\r\nif (tx_status & TX_STS_LATE_COLL_) {\r\ndev->stats.collisions++;\r\ndev->stats.tx_aborted_errors++;\r\n}\r\n}\r\n}\r\nstatic int smc911x_phy_read(struct net_device *dev, int phyaddr, int phyreg)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned int phydata;\r\nSMC_GET_MII(lp, phyreg, phyaddr, phydata);\r\nDBG(SMC_DEBUG_MISC, dev, "%s: phyaddr=0x%x, phyreg=0x%02x, phydata=0x%04x\n",\r\n__func__, phyaddr, phyreg, phydata);\r\nreturn phydata;\r\n}\r\nstatic void smc911x_phy_write(struct net_device *dev, int phyaddr, int phyreg,\r\nint phydata)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nDBG(SMC_DEBUG_MISC, dev, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",\r\n__func__, phyaddr, phyreg, phydata);\r\nSMC_SET_MII(lp, phyreg, phyaddr, phydata);\r\n}\r\nstatic void smc911x_phy_detect(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint phyaddr;\r\nunsigned int cfg, id1, id2;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nlp->phy_type = 0;\r\nswitch(lp->version) {\r\ncase CHIP_9115:\r\ncase CHIP_9117:\r\ncase CHIP_9215:\r\ncase CHIP_9217:\r\ncfg = SMC_GET_HW_CFG(lp);\r\nif (cfg & HW_CFG_EXT_PHY_DET_) {\r\ncfg &= ~HW_CFG_PHY_CLK_SEL_;\r\ncfg |= HW_CFG_PHY_CLK_SEL_CLK_DIS_;\r\nSMC_SET_HW_CFG(lp, cfg);\r\nudelay(10);\r\ncfg |= HW_CFG_EXT_PHY_EN_;\r\nSMC_SET_HW_CFG(lp, cfg);\r\nudelay(10);\r\ncfg &= ~HW_CFG_PHY_CLK_SEL_;\r\ncfg |= HW_CFG_PHY_CLK_SEL_EXT_PHY_;\r\nSMC_SET_HW_CFG(lp, cfg);\r\nudelay(10);\r\ncfg |= HW_CFG_SMI_SEL_;\r\nSMC_SET_HW_CFG(lp, cfg);\r\nfor (phyaddr = 1; phyaddr < 32; ++phyaddr) {\r\nSMC_GET_PHY_ID1(lp, phyaddr & 31, id1);\r\nSMC_GET_PHY_ID2(lp, phyaddr & 31, id2);\r\nif (id1 != 0x0000 && id1 != 0xffff &&\r\nid1 != 0x8000 && id2 != 0x0000 &&\r\nid2 != 0xffff && id2 != 0x8000) {\r\nlp->mii.phy_id = phyaddr & 31;\r\nlp->phy_type = id1 << 16 | id2;\r\nbreak;\r\n}\r\n}\r\nif (phyaddr < 32)\r\nbreak;\r\n}\r\ndefault:\r\nSMC_GET_PHY_ID1(lp, 1, id1);\r\nSMC_GET_PHY_ID2(lp, 1, id2);\r\nlp->mii.phy_id = 1;\r\nlp->phy_type = id1 << 16 | id2;\r\n}\r\nDBG(SMC_DEBUG_MISC, dev, "phy_id1=0x%x, phy_id2=0x%x phyaddr=0x%x\n",\r\nid1, id2, lp->mii.phy_id);\r\n}\r\nstatic int smc911x_phy_fixed(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint phyaddr = lp->mii.phy_id;\r\nint bmcr;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nSMC_GET_PHY_BMCR(lp, phyaddr, bmcr);\r\nbmcr |= BMCR_PDOWN;\r\nSMC_SET_PHY_BMCR(lp, phyaddr, bmcr);\r\nbmcr &= ~BMCR_ANENABLE;\r\nif (lp->ctl_rfduplx)\r\nbmcr |= BMCR_FULLDPLX;\r\nif (lp->ctl_rspeed == 100)\r\nbmcr |= BMCR_SPEED100;\r\nSMC_SET_PHY_BMCR(lp, phyaddr, bmcr);\r\nbmcr &= ~BMCR_PDOWN;\r\nSMC_SET_PHY_BMCR(lp, phyaddr, bmcr);\r\nreturn 1;\r\n}\r\nstatic int smc911x_phy_reset(struct net_device *dev, int phy)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint timeout;\r\nunsigned long flags;\r\nunsigned int reg;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s()\n", __func__);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nreg = SMC_GET_PMT_CTRL(lp);\r\nreg &= ~0xfffff030;\r\nreg |= PMT_CTRL_PHY_RST_;\r\nSMC_SET_PMT_CTRL(lp, reg);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nfor (timeout = 2; timeout; timeout--) {\r\nmsleep(50);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nreg = SMC_GET_PMT_CTRL(lp);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (!(reg & PMT_CTRL_PHY_RST_)) {\r\nudelay(500);\r\nbreak;\r\n}\r\n}\r\nreturn reg & PMT_CTRL_PHY_RST_;\r\n}\r\nstatic void smc911x_phy_powerdown(struct net_device *dev, int phy)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned int bmcr;\r\nSMC_GET_PHY_BMCR(lp, phy, bmcr);\r\nbmcr |= BMCR_PDOWN;\r\nSMC_SET_PHY_BMCR(lp, phy, bmcr);\r\n}\r\nstatic void smc911x_phy_check_media(struct net_device *dev, int init)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint phyaddr = lp->mii.phy_id;\r\nunsigned int bmcr, cr;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nif (mii_check_media(&lp->mii, netif_msg_link(lp), init)) {\r\nSMC_GET_PHY_BMCR(lp, phyaddr, bmcr);\r\nSMC_GET_MAC_CR(lp, cr);\r\nif (lp->mii.full_duplex) {\r\nDBG(SMC_DEBUG_MISC, dev, "Configuring for full-duplex mode\n");\r\nbmcr |= BMCR_FULLDPLX;\r\ncr |= MAC_CR_RCVOWN_;\r\n} else {\r\nDBG(SMC_DEBUG_MISC, dev, "Configuring for half-duplex mode\n");\r\nbmcr &= ~BMCR_FULLDPLX;\r\ncr &= ~MAC_CR_RCVOWN_;\r\n}\r\nSMC_SET_PHY_BMCR(lp, phyaddr, bmcr);\r\nSMC_SET_MAC_CR(lp, cr);\r\n}\r\n}\r\nstatic void smc911x_phy_configure(struct work_struct *work)\r\n{\r\nstruct smc911x_local *lp = container_of(work, struct smc911x_local,\r\nphy_configure);\r\nstruct net_device *dev = lp->netdev;\r\nint phyaddr = lp->mii.phy_id;\r\nint my_phy_caps;\r\nint my_ad_caps;\r\nint status;\r\nunsigned long flags;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s()\n", __func__);\r\nif (lp->phy_type == 0)\r\nreturn;\r\nif (smc911x_phy_reset(dev, phyaddr)) {\r\nnetdev_info(dev, "PHY reset timed out\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nSMC_SET_PHY_INT_MASK(lp, phyaddr, PHY_INT_MASK_ENERGY_ON_ |\r\nPHY_INT_MASK_ANEG_COMP_ | PHY_INT_MASK_REMOTE_FAULT_ |\r\nPHY_INT_MASK_LINK_DOWN_);\r\nif (lp->mii.force_media) {\r\nsmc911x_phy_fixed(dev);\r\ngoto smc911x_phy_configure_exit;\r\n}\r\nSMC_GET_PHY_BMSR(lp, phyaddr, my_phy_caps);\r\nif (!(my_phy_caps & BMSR_ANEGCAPABLE)) {\r\nnetdev_info(dev, "Auto negotiation NOT supported\n");\r\nsmc911x_phy_fixed(dev);\r\ngoto smc911x_phy_configure_exit;\r\n}\r\nmy_ad_caps = ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\r\nif (my_phy_caps & BMSR_100BASE4)\r\nmy_ad_caps |= ADVERTISE_100BASE4;\r\nif (my_phy_caps & BMSR_100FULL)\r\nmy_ad_caps |= ADVERTISE_100FULL;\r\nif (my_phy_caps & BMSR_100HALF)\r\nmy_ad_caps |= ADVERTISE_100HALF;\r\nif (my_phy_caps & BMSR_10FULL)\r\nmy_ad_caps |= ADVERTISE_10FULL;\r\nif (my_phy_caps & BMSR_10HALF)\r\nmy_ad_caps |= ADVERTISE_10HALF;\r\nif (lp->ctl_rspeed != 100)\r\nmy_ad_caps &= ~(ADVERTISE_100BASE4|ADVERTISE_100FULL|ADVERTISE_100HALF);\r\nif (!lp->ctl_rfduplx)\r\nmy_ad_caps &= ~(ADVERTISE_100FULL|ADVERTISE_10FULL);\r\nSMC_SET_PHY_MII_ADV(lp, phyaddr, my_ad_caps);\r\nlp->mii.advertising = my_ad_caps;\r\nudelay(10);\r\nSMC_GET_PHY_MII_ADV(lp, phyaddr, status);\r\nDBG(SMC_DEBUG_MISC, dev, "phy caps=0x%04x\n", my_phy_caps);\r\nDBG(SMC_DEBUG_MISC, dev, "phy advertised caps=0x%04x\n", my_ad_caps);\r\nSMC_SET_PHY_BMCR(lp, phyaddr, BMCR_ANENABLE | BMCR_ANRESTART);\r\nsmc911x_phy_check_media(dev, 1);\r\nsmc911x_phy_configure_exit:\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic void smc911x_phy_interrupt(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint phyaddr = lp->mii.phy_id;\r\nint status;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nif (lp->phy_type == 0)\r\nreturn;\r\nsmc911x_phy_check_media(dev, 0);\r\nSMC_GET_PHY_INT_SRC(lp, phyaddr,status);\r\nDBG(SMC_DEBUG_MISC, dev, "PHY interrupt status 0x%04x\n",\r\nstatus & 0xffff);\r\nDBG(SMC_DEBUG_MISC, dev, "AFC_CFG 0x%08x\n",\r\nSMC_GET_AFC_CFG(lp));\r\n}\r\nstatic irqreturn_t smc911x_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned int status, mask, timeout;\r\nunsigned int rx_overrun=0, cr, pkts;\r\nunsigned long flags;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif ((SMC_GET_IRQ_CFG(lp) & (INT_CFG_IRQ_INT_ | INT_CFG_IRQ_EN_)) !=\r\n(INT_CFG_IRQ_INT_ | INT_CFG_IRQ_EN_)) {\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nmask = SMC_GET_INT_EN(lp);\r\nSMC_SET_INT_EN(lp, 0);\r\ntimeout = 8;\r\ndo {\r\nstatus = SMC_GET_INT(lp);\r\nDBG(SMC_DEBUG_MISC, dev, "INT 0x%08x MASK 0x%08x OUTSIDE MASK 0x%08x\n",\r\nstatus, mask, status & ~mask);\r\nstatus &= mask;\r\nif (!status)\r\nbreak;\r\nif (status & INT_STS_SW_INT_) {\r\nSMC_ACK_INT(lp, INT_STS_SW_INT_);\r\nmask &= ~INT_EN_SW_INT_EN_;\r\n}\r\nif (status & INT_STS_RXE_) {\r\nSMC_ACK_INT(lp, INT_STS_RXE_);\r\ndev->stats.rx_errors++;\r\n}\r\nif (status & INT_STS_RXDFH_INT_) {\r\nSMC_ACK_INT(lp, INT_STS_RXDFH_INT_);\r\ndev->stats.rx_dropped+=SMC_GET_RX_DROP(lp);\r\n}\r\nif (status & INT_STS_RXDF_INT_) {\r\nSMC_ACK_INT(lp, INT_STS_RXDF_INT_);\r\n}\r\nif (status & INT_STS_RDFL_) {\r\nif (IS_REV_A(lp->revision)) {\r\nrx_overrun=1;\r\nSMC_GET_MAC_CR(lp, cr);\r\ncr &= ~MAC_CR_RXEN_;\r\nSMC_SET_MAC_CR(lp, cr);\r\nDBG(SMC_DEBUG_RX, dev, "RX overrun\n");\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_fifo_errors++;\r\n}\r\nSMC_ACK_INT(lp, INT_STS_RDFL_);\r\n}\r\nif (status & INT_STS_RDFO_) {\r\nif (!IS_REV_A(lp->revision)) {\r\nSMC_GET_MAC_CR(lp, cr);\r\ncr &= ~MAC_CR_RXEN_;\r\nSMC_SET_MAC_CR(lp, cr);\r\nrx_overrun=1;\r\nDBG(SMC_DEBUG_RX, dev, "RX overrun\n");\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_fifo_errors++;\r\n}\r\nSMC_ACK_INT(lp, INT_STS_RDFO_);\r\n}\r\nif ((status & INT_STS_RSFL_) || rx_overrun) {\r\nunsigned int fifo;\r\nDBG(SMC_DEBUG_RX, dev, "RX irq\n");\r\nfifo = SMC_GET_RX_FIFO_INF(lp);\r\npkts = (fifo & RX_FIFO_INF_RXSUSED_) >> 16;\r\nDBG(SMC_DEBUG_RX, dev, "Rx FIFO pkts %d, bytes %d\n",\r\npkts, fifo & 0xFFFF);\r\nif (pkts != 0) {\r\n#ifdef SMC_USE_DMA\r\nunsigned int fifo;\r\nif (lp->rxdma_active){\r\nDBG(SMC_DEBUG_RX | SMC_DEBUG_DMA, dev,\r\n"RX DMA active\n");\r\nfifo = SMC_GET_FIFO_INT(lp) & ~0xFF;\r\nfifo |= pkts & 0xFF;\r\nDBG(SMC_DEBUG_RX, dev,\r\n"Setting RX stat FIFO threshold to %d\n",\r\nfifo & 0xff);\r\nSMC_SET_FIFO_INT(lp, fifo);\r\n} else\r\n#endif\r\nsmc911x_rcv(dev);\r\n}\r\nSMC_ACK_INT(lp, INT_STS_RSFL_);\r\n}\r\nif (status & INT_STS_TDFA_) {\r\nDBG(SMC_DEBUG_TX, dev, "TX data FIFO space available irq\n");\r\nSMC_SET_FIFO_TDA(lp, 0xFF);\r\nlp->tx_throttle = 0;\r\n#ifdef SMC_USE_DMA\r\nif (!lp->txdma_active)\r\n#endif\r\nnetif_wake_queue(dev);\r\nSMC_ACK_INT(lp, INT_STS_TDFA_);\r\n}\r\n#if 1\r\nif (status & (INT_STS_TSFL_ | INT_STS_GPT_INT_)) {\r\nDBG(SMC_DEBUG_TX | SMC_DEBUG_MISC, dev,\r\n"Tx stat FIFO limit (%d) /GPT irq\n",\r\n(SMC_GET_FIFO_INT(lp) & 0x00ff0000) >> 16);\r\nsmc911x_tx(dev);\r\nSMC_SET_GPT_CFG(lp, GPT_CFG_TIMER_EN_ | 10000);\r\nSMC_ACK_INT(lp, INT_STS_TSFL_);\r\nSMC_ACK_INT(lp, INT_STS_TSFL_ | INT_STS_GPT_INT_);\r\n}\r\n#else\r\nif (status & INT_STS_TSFL_) {\r\nDBG(SMC_DEBUG_TX, dev, "TX status FIFO limit (%d) irq\n", ?);\r\nsmc911x_tx(dev);\r\nSMC_ACK_INT(lp, INT_STS_TSFL_);\r\n}\r\nif (status & INT_STS_GPT_INT_) {\r\nDBG(SMC_DEBUG_RX, dev, "IRQ_CFG 0x%08x FIFO_INT 0x%08x RX_CFG 0x%08x\n",\r\nSMC_GET_IRQ_CFG(lp),\r\nSMC_GET_FIFO_INT(lp),\r\nSMC_GET_RX_CFG(lp));\r\nDBG(SMC_DEBUG_RX, dev, "Rx Stat FIFO Used 0x%02x Data FIFO Used 0x%04x Stat FIFO 0x%08x\n",\r\n(SMC_GET_RX_FIFO_INF(lp) & 0x00ff0000) >> 16,\r\nSMC_GET_RX_FIFO_INF(lp) & 0xffff,\r\nSMC_GET_RX_STS_FIFO_PEEK(lp));\r\nSMC_SET_GPT_CFG(lp, GPT_CFG_TIMER_EN_ | 10000);\r\nSMC_ACK_INT(lp, INT_STS_GPT_INT_);\r\n}\r\n#endif\r\nif (status & INT_STS_PHY_INT_) {\r\nDBG(SMC_DEBUG_MISC, dev, "PHY irq\n");\r\nsmc911x_phy_interrupt(dev);\r\nSMC_ACK_INT(lp, INT_STS_PHY_INT_);\r\n}\r\n} while (--timeout);\r\nSMC_SET_INT_EN(lp, mask);\r\nDBG(SMC_DEBUG_MISC, dev, "Interrupt done (%d loops)\n",\r\n8-timeout);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nsmc911x_tx_dma_irq(void *data)\r\n{\r\nstruct smc911x_local *lp = data;\r\nstruct net_device *dev = lp->netdev;\r\nstruct sk_buff *skb = lp->current_tx_skb;\r\nunsigned long flags;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nDBG(SMC_DEBUG_TX | SMC_DEBUG_DMA, dev, "TX DMA irq handler\n");\r\nBUG_ON(skb == NULL);\r\ndma_unmap_single(NULL, tx_dmabuf, tx_dmalen, DMA_TO_DEVICE);\r\nnetif_trans_update(dev);\r\ndev_kfree_skb_irq(skb);\r\nlp->current_tx_skb = NULL;\r\nif (lp->pending_tx_skb != NULL)\r\nsmc911x_hardware_send_pkt(dev);\r\nelse {\r\nDBG(SMC_DEBUG_TX | SMC_DEBUG_DMA, dev,\r\n"No pending Tx packets. DMA disabled\n");\r\nspin_lock_irqsave(&lp->lock, flags);\r\nlp->txdma_active = 0;\r\nif (!lp->tx_throttle) {\r\nnetif_wake_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nDBG(SMC_DEBUG_TX | SMC_DEBUG_DMA, dev,\r\n"TX DMA irq completed\n");\r\n}\r\nstatic void\r\nsmc911x_rx_dma_irq(void *data)\r\n{\r\nstruct smc911x_local *lp = data;\r\nstruct net_device *dev = lp->netdev;\r\nstruct sk_buff *skb = lp->current_rx_skb;\r\nunsigned long flags;\r\nunsigned int pkts;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nDBG(SMC_DEBUG_RX | SMC_DEBUG_DMA, dev, "RX DMA irq handler\n");\r\ndma_unmap_single(NULL, rx_dmabuf, rx_dmalen, DMA_FROM_DEVICE);\r\nBUG_ON(skb == NULL);\r\nlp->current_rx_skb = NULL;\r\nPRINT_PKT(skb->data, skb->len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\nspin_lock_irqsave(&lp->lock, flags);\r\npkts = (SMC_GET_RX_FIFO_INF(lp) & RX_FIFO_INF_RXSUSED_) >> 16;\r\nif (pkts != 0) {\r\nsmc911x_rcv(dev);\r\n}else {\r\nlp->rxdma_active = 0;\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nDBG(SMC_DEBUG_RX | SMC_DEBUG_DMA, dev,\r\n"RX DMA irq completed. DMA RX FIFO PKTS %d\n",\r\npkts);\r\n}\r\nstatic void smc911x_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nsmc911x_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic void smc911x_timeout(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint status, mask;\r\nunsigned long flags;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nstatus = SMC_GET_INT(lp);\r\nmask = SMC_GET_INT_EN(lp);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nDBG(SMC_DEBUG_MISC, dev, "INT 0x%02x MASK 0x%02x\n",\r\nstatus, mask);\r\nmask = SMC_GET_TX_CFG(lp);\r\nSMC_SET_TX_CFG(lp, mask | TX_CFG_TXS_DUMP_ | TX_CFG_TXD_DUMP_);\r\nif (lp->phy_type != 0)\r\nschedule_work(&lp->phy_configure);\r\nnetif_trans_update(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void smc911x_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned int multicast_table[2];\r\nunsigned int mcr, update_multicast = 0;\r\nunsigned long flags;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nSMC_GET_MAC_CR(lp, mcr);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (dev->flags & IFF_PROMISC) {\r\nDBG(SMC_DEBUG_MISC, dev, "RCR_PRMS\n");\r\nmcr |= MAC_CR_PRMS_;\r\n}\r\nelse if (dev->flags & IFF_ALLMULTI || netdev_mc_count(dev) > 16) {\r\nDBG(SMC_DEBUG_MISC, dev, "RCR_ALMUL\n");\r\nmcr |= MAC_CR_MCPAS_;\r\n}\r\nelse if (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nmcr |= MAC_CR_HPFILT_;\r\nmemset(multicast_table, 0, sizeof(multicast_table));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nu32 position;\r\nposition = ether_crc(ETH_ALEN, ha->addr)>>26;\r\nmulticast_table[position>>5] |= 1 << (position&0x1f);\r\n}\r\nmcr &= ~(MAC_CR_PRMS_ | MAC_CR_MCPAS_);\r\nupdate_multicast = 1;\r\n} else {\r\nDBG(SMC_DEBUG_MISC, dev, "~(MAC_CR_PRMS_|MAC_CR_MCPAS_)\n");\r\nmcr &= ~(MAC_CR_PRMS_ | MAC_CR_MCPAS_);\r\nmemset(multicast_table, 0, sizeof(multicast_table));\r\nupdate_multicast = 1;\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nSMC_SET_MAC_CR(lp, mcr);\r\nif (update_multicast) {\r\nDBG(SMC_DEBUG_MISC, dev,\r\n"update mcast hash table 0x%08x 0x%08x\n",\r\nmulticast_table[0], multicast_table[1]);\r\nSMC_SET_HASHL(lp, multicast_table[0]);\r\nSMC_SET_HASHH(lp, multicast_table[1]);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic int\r\nsmc911x_open(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nsmc911x_reset(dev);\r\nsmc911x_phy_configure(&lp->phy_configure);\r\nsmc911x_enable(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int smc911x_close(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\nsmc911x_shutdown(dev);\r\nif (lp->phy_type != 0) {\r\ncancel_work_sync(&lp->phy_configure);\r\nsmc911x_phy_powerdown(dev, lp->mii.phy_id);\r\n}\r\nif (lp->pending_tx_skb) {\r\ndev_kfree_skb(lp->pending_tx_skb);\r\nlp->pending_tx_skb = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsmc911x_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint ret, status;\r\nunsigned long flags;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\ncmd->maxtxpkt = 1;\r\ncmd->maxrxpkt = 1;\r\nif (lp->phy_type != 0) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nret = mii_ethtool_gset(&lp->mii, cmd);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n} else {\r\ncmd->supported = SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_TP | SUPPORTED_AUI;\r\nif (lp->ctl_rspeed == 10)\r\nethtool_cmd_speed_set(cmd, SPEED_10);\r\nelse if (lp->ctl_rspeed == 100)\r\nethtool_cmd_speed_set(cmd, SPEED_100);\r\ncmd->autoneg = AUTONEG_DISABLE;\r\nif (lp->mii.phy_id==1)\r\ncmd->transceiver = XCVR_INTERNAL;\r\nelse\r\ncmd->transceiver = XCVR_EXTERNAL;\r\ncmd->port = 0;\r\nSMC_GET_PHY_SPECIAL(lp, lp->mii.phy_id, status);\r\ncmd->duplex =\r\n(status & (PHY_SPECIAL_SPD_10FULL_ | PHY_SPECIAL_SPD_100FULL_)) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nsmc911x_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint ret;\r\nunsigned long flags;\r\nif (lp->phy_type != 0) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nret = mii_ethtool_sset(&lp->mii, cmd);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n} else {\r\nif (cmd->autoneg != AUTONEG_DISABLE ||\r\ncmd->speed != SPEED_10 ||\r\n(cmd->duplex != DUPLEX_HALF && cmd->duplex != DUPLEX_FULL) ||\r\n(cmd->port != PORT_TP && cmd->port != PORT_AUI))\r\nreturn -EINVAL;\r\nlp->ctl_rfduplx = cmd->duplex == DUPLEX_FULL;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nsmc911x_ethtool_getdrvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, CARDNAME, sizeof(info->driver));\r\nstrlcpy(info->version, version, sizeof(info->version));\r\nstrlcpy(info->bus_info, dev_name(dev->dev.parent),\r\nsizeof(info->bus_info));\r\n}\r\nstatic int smc911x_ethtool_nwayreset(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint ret = -EINVAL;\r\nunsigned long flags;\r\nif (lp->phy_type != 0) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nret = mii_nway_restart(&lp->mii);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 smc911x_ethtool_getmsglevel(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nreturn lp->msg_enable;\r\n}\r\nstatic void smc911x_ethtool_setmsglevel(struct net_device *dev, u32 level)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nlp->msg_enable = level;\r\n}\r\nstatic int smc911x_ethtool_getregslen(struct net_device *dev)\r\n{\r\nreturn (((E2P_CMD - ID_REV)/4 + 1) +\r\n(WUCSR - MAC_CR)+1 + 32) * sizeof(u32);\r\n}\r\nstatic void smc911x_ethtool_getregs(struct net_device *dev,\r\nstruct ethtool_regs* regs, void *buf)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nu32 reg,i,j=0;\r\nu32 *data = (u32*)buf;\r\nregs->version = lp->version;\r\nfor(i=ID_REV;i<=E2P_CMD;i+=4) {\r\ndata[j++] = SMC_inl(lp, i);\r\n}\r\nfor(i=MAC_CR;i<=WUCSR;i++) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nSMC_GET_MAC_CSR(lp, i, reg);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndata[j++] = reg;\r\n}\r\nfor(i=0;i<=31;i++) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nSMC_GET_MII(lp, i, lp->mii.phy_id, reg);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndata[j++] = reg & 0xFFFF;\r\n}\r\n}\r\nstatic int smc911x_ethtool_wait_eeprom_ready(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nunsigned int timeout;\r\nint e2p_cmd;\r\ne2p_cmd = SMC_GET_E2P_CMD(lp);\r\nfor(timeout=10;(e2p_cmd & E2P_CMD_EPC_BUSY_) && timeout; timeout--) {\r\nif (e2p_cmd & E2P_CMD_EPC_TIMEOUT_) {\r\nPRINTK(dev, "%s timeout waiting for EEPROM to respond\n",\r\n__func__);\r\nreturn -EFAULT;\r\n}\r\nmdelay(1);\r\ne2p_cmd = SMC_GET_E2P_CMD(lp);\r\n}\r\nif (timeout == 0) {\r\nPRINTK(dev, "%s timeout waiting for EEPROM CMD not busy\n",\r\n__func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int smc911x_ethtool_write_eeprom_cmd(struct net_device *dev,\r\nint cmd, int addr)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint ret;\r\nif ((ret = smc911x_ethtool_wait_eeprom_ready(dev))!=0)\r\nreturn ret;\r\nSMC_SET_E2P_CMD(lp, E2P_CMD_EPC_BUSY_ |\r\n((cmd) & (0x7<<28)) |\r\n((addr) & 0xFF));\r\nreturn 0;\r\n}\r\nstatic inline int smc911x_ethtool_read_eeprom_byte(struct net_device *dev,\r\nu8 *data)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint ret;\r\nif ((ret = smc911x_ethtool_wait_eeprom_ready(dev))!=0)\r\nreturn ret;\r\n*data = SMC_GET_E2P_DATA(lp);\r\nreturn 0;\r\n}\r\nstatic inline int smc911x_ethtool_write_eeprom_byte(struct net_device *dev,\r\nu8 data)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint ret;\r\nif ((ret = smc911x_ethtool_wait_eeprom_ready(dev))!=0)\r\nreturn ret;\r\nSMC_SET_E2P_DATA(lp, data);\r\nreturn 0;\r\n}\r\nstatic int smc911x_ethtool_geteeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nu8 eebuf[SMC911X_EEPROM_LEN];\r\nint i, ret;\r\nfor(i=0;i<SMC911X_EEPROM_LEN;i++) {\r\nif ((ret=smc911x_ethtool_write_eeprom_cmd(dev, E2P_CMD_EPC_CMD_READ_, i ))!=0)\r\nreturn ret;\r\nif ((ret=smc911x_ethtool_read_eeprom_byte(dev, &eebuf[i]))!=0)\r\nreturn ret;\r\n}\r\nmemcpy(data, eebuf+eeprom->offset, eeprom->len);\r\nreturn 0;\r\n}\r\nstatic int smc911x_ethtool_seteeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nint i, ret;\r\nif ((ret=smc911x_ethtool_write_eeprom_cmd(dev, E2P_CMD_EPC_CMD_EWEN_, 0 ))!=0)\r\nreturn ret;\r\nfor(i=eeprom->offset;i<(eeprom->offset+eeprom->len);i++) {\r\nif ((ret=smc911x_ethtool_write_eeprom_cmd(dev, E2P_CMD_EPC_CMD_ERASE_, i ))!=0)\r\nreturn ret;\r\nif ((ret=smc911x_ethtool_write_eeprom_byte(dev, *data))!=0)\r\nreturn ret;\r\nif ((ret=smc911x_ethtool_write_eeprom_cmd(dev, E2P_CMD_EPC_CMD_WRITE_, i ))!=0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smc911x_ethtool_geteeprom_len(struct net_device *dev)\r\n{\r\nreturn SMC911X_EEPROM_LEN;\r\n}\r\nstatic int smc911x_findirq(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint timeout = 20;\r\nunsigned long cookie;\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\ncookie = probe_irq_on();\r\nSMC_SET_INT_EN(lp, INT_EN_SW_INT_EN_);\r\ndo {\r\nint int_status;\r\nudelay(10);\r\nint_status = SMC_GET_INT_EN(lp);\r\nif (int_status & INT_EN_SW_INT_EN_)\r\nbreak;\r\n} while (--timeout);\r\nSMC_SET_INT_EN(lp, 0);\r\nreturn probe_irq_off(cookie);\r\n}\r\nstatic int smc911x_probe(struct net_device *dev)\r\n{\r\nstruct smc911x_local *lp = netdev_priv(dev);\r\nint i, retval;\r\nunsigned int val, chip_id, revision;\r\nconst char *version_string;\r\nunsigned long irq_flags;\r\n#ifdef SMC_USE_DMA\r\nstruct dma_slave_config config;\r\ndma_cap_mask_t mask;\r\nstruct pxad_param param;\r\n#endif\r\nDBG(SMC_DEBUG_FUNC, dev, "--> %s\n", __func__);\r\nval = SMC_GET_BYTE_TEST(lp);\r\nDBG(SMC_DEBUG_MISC, dev, "%s: endian probe returned 0x%04x\n",\r\nCARDNAME, val);\r\nif (val != 0x87654321) {\r\nnetdev_err(dev, "Invalid chip endian 0x%08x\n", val);\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\nchip_id = SMC_GET_PN(lp);\r\nDBG(SMC_DEBUG_MISC, dev, "%s: id probe returned 0x%04x\n",\r\nCARDNAME, chip_id);\r\nfor(i=0;chip_ids[i].id != 0; i++) {\r\nif (chip_ids[i].id == chip_id) break;\r\n}\r\nif (!chip_ids[i].id) {\r\nnetdev_err(dev, "Unknown chip ID %04x\n", chip_id);\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\nversion_string = chip_ids[i].name;\r\nrevision = SMC_GET_REV(lp);\r\nDBG(SMC_DEBUG_MISC, dev, "%s: revision = 0x%04x\n", CARDNAME, revision);\r\nDBG(SMC_DEBUG_MISC, dev, "%s: Found a %s\n",\r\nCARDNAME, chip_ids[i].name);\r\nif ((tx_fifo_kb < 2) || (tx_fifo_kb > 14)) {\r\nnetdev_err(dev, "Invalid TX FIFO size requested %d\n",\r\ntx_fifo_kb);\r\nretval = -EINVAL;\r\ngoto err_out;\r\n}\r\nlp->version = chip_ids[i].id;\r\nlp->revision = revision;\r\nlp->tx_fifo_kb = tx_fifo_kb;\r\nlp->tx_fifo_size=(lp->tx_fifo_kb<<10) - 512;\r\nlp->rx_fifo_size= ((0x4000 - 512 - lp->tx_fifo_size) / 16) * 15;\r\nswitch(lp->tx_fifo_kb) {\r\ncase 2:\r\nlp->afc_cfg=0x008C46AF;break;\r\ncase 3:\r\nlp->afc_cfg=0x0082419F;break;\r\ncase 4:\r\nlp->afc_cfg=0x00783C9F;break;\r\ncase 5:\r\nlp->afc_cfg=0x006E374F;break;\r\ncase 6:\r\nlp->afc_cfg=0x0064328F;break;\r\ncase 7:\r\nlp->afc_cfg=0x005A2D7F;break;\r\ncase 8:\r\nlp->afc_cfg=0x0050287F;break;\r\ncase 9:\r\nlp->afc_cfg=0x0046236F;break;\r\ncase 10:\r\nlp->afc_cfg=0x003C1E6F;break;\r\ncase 11:\r\nlp->afc_cfg=0x0032195F;break;\r\ncase 12:\r\nlp->afc_cfg=0x0024124F;break;\r\ncase 13:\r\nlp->afc_cfg=0x0015073F;break;\r\ncase 14:\r\nlp->afc_cfg=0x0006032F;break;\r\ndefault:\r\nPRINTK(dev, "ERROR -- no AFC_CFG setting found");\r\nbreak;\r\n}\r\nDBG(SMC_DEBUG_MISC | SMC_DEBUG_TX | SMC_DEBUG_RX, dev,\r\n"%s: tx_fifo %d rx_fifo %d afc_cfg 0x%08x\n", CARDNAME,\r\nlp->tx_fifo_size, lp->rx_fifo_size, lp->afc_cfg);\r\nspin_lock_init(&lp->lock);\r\nSMC_GET_MAC_ADDR(lp, dev->dev_addr);\r\nsmc911x_reset(dev);\r\nif (dev->irq < 1) {\r\nint trials;\r\ntrials = 3;\r\nwhile (trials--) {\r\ndev->irq = smc911x_findirq(dev);\r\nif (dev->irq)\r\nbreak;\r\nsmc911x_reset(dev);\r\n}\r\n}\r\nif (dev->irq == 0) {\r\nnetdev_warn(dev, "Couldn't autodetect your IRQ. Use irq=xx.\n");\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\ndev->irq = irq_canonicalize(dev->irq);\r\ndev->netdev_ops = &smc911x_netdev_ops;\r\ndev->watchdog_timeo = msecs_to_jiffies(watchdog);\r\ndev->ethtool_ops = &smc911x_ethtool_ops;\r\nINIT_WORK(&lp->phy_configure, smc911x_phy_configure);\r\nlp->mii.phy_id_mask = 0x1f;\r\nlp->mii.reg_num_mask = 0x1f;\r\nlp->mii.force_media = 0;\r\nlp->mii.full_duplex = 0;\r\nlp->mii.dev = dev;\r\nlp->mii.mdio_read = smc911x_phy_read;\r\nlp->mii.mdio_write = smc911x_phy_write;\r\nsmc911x_phy_detect(dev);\r\nlp->msg_enable = NETIF_MSG_LINK;\r\nlp->ctl_rfduplx = 1;\r\nlp->ctl_rspeed = 100;\r\n#ifdef SMC_DYNAMIC_BUS_CONFIG\r\nirq_flags = lp->cfg.irq_flags;\r\n#else\r\nirq_flags = IRQF_SHARED | SMC_IRQ_SENSE;\r\n#endif\r\nretval = request_irq(dev->irq, smc911x_interrupt,\r\nirq_flags, dev->name, dev);\r\nif (retval)\r\ngoto err_out;\r\n#ifdef SMC_USE_DMA\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nparam.prio = PXAD_PRIO_LOWEST;\r\nparam.drcmr = -1UL;\r\nlp->rxdma =\r\ndma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&param, &dev->dev, "rx");\r\nlp->txdma =\r\ndma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&param, &dev->dev, "tx");\r\nlp->rxdma_active = 0;\r\nlp->txdma_active = 0;\r\nmemset(&config, 0, sizeof(config));\r\nconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nconfig.src_addr = lp->physaddr + RX_DATA_FIFO;\r\nconfig.dst_addr = lp->physaddr + TX_DATA_FIFO;\r\nconfig.src_maxburst = 32;\r\nconfig.dst_maxburst = 32;\r\nretval = dmaengine_slave_config(lp->rxdma, &config);\r\nif (retval) {\r\ndev_err(lp->dev, "dma rx channel configuration failed: %d\n",\r\nretval);\r\ngoto err_out;\r\n}\r\nretval = dmaengine_slave_config(lp->txdma, &config);\r\nif (retval) {\r\ndev_err(lp->dev, "dma tx channel configuration failed: %d\n",\r\nretval);\r\ngoto err_out;\r\n}\r\n#endif\r\nretval = register_netdev(dev);\r\nif (retval == 0) {\r\nnetdev_info(dev, "%s (rev %d) at %#lx IRQ %d",\r\nversion_string, lp->revision,\r\ndev->base_addr, dev->irq);\r\n#ifdef SMC_USE_DMA\r\nif (lp->rxdma)\r\npr_cont(" RXDMA %p", lp->rxdma);\r\nif (lp->txdma)\r\npr_cont(" TXDMA %p", lp->txdma);\r\n#endif\r\npr_cont("\n");\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nnetdev_warn(dev, "Invalid ethernet MAC address. Please set using ifconfig\n");\r\n} else {\r\nnetdev_info(dev, "Ethernet addr: %pM\n",\r\ndev->dev_addr);\r\n}\r\nif (lp->phy_type == 0) {\r\nPRINTK(dev, "No PHY found\n");\r\n} else if ((lp->phy_type & ~0xff) == LAN911X_INTERNAL_PHY_ID) {\r\nPRINTK(dev, "LAN911x Internal PHY\n");\r\n} else {\r\nPRINTK(dev, "External PHY 0x%08x\n", lp->phy_type);\r\n}\r\n}\r\nerr_out:\r\n#ifdef SMC_USE_DMA\r\nif (retval) {\r\nif (lp->rxdma)\r\ndma_release_channel(lp->rxdma);\r\nif (lp->txdma)\r\ndma_release_channel(lp->txdma);\r\n}\r\n#endif\r\nreturn retval;\r\n}\r\nstatic int smc911x_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev;\r\nstruct resource *res;\r\nstruct smc911x_local *lp;\r\nvoid __iomem *addr;\r\nint ret;\r\nDBG(SMC_DEBUG_FUNC, "--> %s\n", __func__);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (!request_mem_region(res->start, SMC911X_IO_EXTENT, CARDNAME)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nndev = alloc_etherdev(sizeof(struct smc911x_local));\r\nif (!ndev) {\r\nret = -ENOMEM;\r\ngoto release_1;\r\n}\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nndev->dma = (unsigned char)-1;\r\nndev->irq = platform_get_irq(pdev, 0);\r\nlp = netdev_priv(ndev);\r\nlp->netdev = ndev;\r\n#ifdef SMC_DYNAMIC_BUS_CONFIG\r\n{\r\nstruct smc911x_platdata *pd = dev_get_platdata(&pdev->dev);\r\nif (!pd) {\r\nret = -EINVAL;\r\ngoto release_both;\r\n}\r\nmemcpy(&lp->cfg, pd, sizeof(lp->cfg));\r\n}\r\n#endif\r\naddr = ioremap(res->start, SMC911X_IO_EXTENT);\r\nif (!addr) {\r\nret = -ENOMEM;\r\ngoto release_both;\r\n}\r\nplatform_set_drvdata(pdev, ndev);\r\nlp->base = addr;\r\nndev->base_addr = res->start;\r\nret = smc911x_probe(ndev);\r\nif (ret != 0) {\r\niounmap(addr);\r\nrelease_both:\r\nfree_netdev(ndev);\r\nrelease_1:\r\nrelease_mem_region(res->start, SMC911X_IO_EXTENT);\r\nout:\r\npr_info("%s: not found (%d).\n", CARDNAME, ret);\r\n}\r\n#ifdef SMC_USE_DMA\r\nelse {\r\nlp->physaddr = res->start;\r\nlp->dev = &pdev->dev;\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int smc911x_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct smc911x_local *lp = netdev_priv(ndev);\r\nstruct resource *res;\r\nDBG(SMC_DEBUG_FUNC, ndev, "--> %s\n", __func__);\r\nunregister_netdev(ndev);\r\nfree_irq(ndev->irq, ndev);\r\n#ifdef SMC_USE_DMA\r\n{\r\nif (lp->rxdma)\r\ndma_release_channel(lp->rxdma);\r\nif (lp->txdma)\r\ndma_release_channel(lp->txdma);\r\n}\r\n#endif\r\niounmap(lp->base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, SMC911X_IO_EXTENT);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}\r\nstatic int smc911x_drv_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(dev);\r\nstruct smc911x_local *lp = netdev_priv(ndev);\r\nDBG(SMC_DEBUG_FUNC, ndev, "--> %s\n", __func__);\r\nif (ndev) {\r\nif (netif_running(ndev)) {\r\nnetif_device_detach(ndev);\r\nsmc911x_shutdown(ndev);\r\n#if POWER_DOWN\r\nSMC_SET_PMT_CTRL(lp, 2<<12);\r\n#endif\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int smc911x_drv_resume(struct platform_device *dev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(dev);\r\nDBG(SMC_DEBUG_FUNC, ndev, "--> %s\n", __func__);\r\nif (ndev) {\r\nstruct smc911x_local *lp = netdev_priv(ndev);\r\nif (netif_running(ndev)) {\r\nsmc911x_reset(ndev);\r\nif (lp->phy_type != 0)\r\nsmc911x_phy_configure(&lp->phy_configure);\r\nsmc911x_enable(ndev);\r\nnetif_device_attach(ndev);\r\n}\r\n}\r\nreturn 0;\r\n}
