static void no_printf(unsigned char *x, ...)\r\n{\r\n}\r\nstatic void stop_dbg(void)\r\n{\r\nDbgDeregister();\r\nmemset(&MAdapter, 0, sizeof(MAdapter));\r\ndprintf = no_printf;\r\n}\r\nstatic udiva_card *find_card_in_list(DESCRIPTOR *d)\r\n{\r\nudiva_card *card;\r\nstruct list_head *tmp;\r\ndiva_os_spin_lock_magic_t old_irql;\r\ndiva_os_enter_spin_lock(&ll_lock, &old_irql, "find card");\r\nlist_for_each(tmp, &cards) {\r\ncard = list_entry(tmp, udiva_card, list);\r\nif (card->d.request == d->request) {\r\ndiva_os_leave_spin_lock(&ll_lock, &old_irql,\r\n"find card");\r\nreturn (card);\r\n}\r\n}\r\ndiva_os_leave_spin_lock(&ll_lock, &old_irql, "find card");\r\nreturn ((udiva_card *) NULL);\r\n}\r\nstatic void um_new_card(DESCRIPTOR *d)\r\n{\r\nint adapter_nr = 0;\r\nudiva_card *card = NULL;\r\nIDI_SYNC_REQ sync_req;\r\ndiva_os_spin_lock_magic_t old_irql;\r\nif (!(card = diva_os_malloc(0, sizeof(udiva_card)))) {\r\nDBG_ERR(("cannot get buffer for card"));\r\nreturn;\r\n}\r\nmemcpy(&card->d, d, sizeof(DESCRIPTOR));\r\nsync_req.xdi_logical_adapter_number.Req = 0;\r\nsync_req.xdi_logical_adapter_number.Rc =\r\nIDI_SYNC_REQ_XDI_GET_LOGICAL_ADAPTER_NUMBER;\r\ncard->d.request((ENTITY *)&sync_req);\r\nadapter_nr =\r\nsync_req.xdi_logical_adapter_number.info.logical_adapter_number;\r\ncard->Id = adapter_nr;\r\nif (!(diva_user_mode_idi_create_adapter(d, adapter_nr))) {\r\ndiva_os_enter_spin_lock(&ll_lock, &old_irql, "add card");\r\nlist_add_tail(&card->list, &cards);\r\ndiva_os_leave_spin_lock(&ll_lock, &old_irql, "add card");\r\n} else {\r\nDBG_ERR(("could not create user mode idi card %d",\r\nadapter_nr));\r\ndiva_os_free(0, card);\r\n}\r\n}\r\nstatic void um_remove_card(DESCRIPTOR *d)\r\n{\r\ndiva_os_spin_lock_magic_t old_irql;\r\nudiva_card *card = NULL;\r\nif (!(card = find_card_in_list(d))) {\r\nDBG_ERR(("cannot find card to remove"));\r\nreturn;\r\n}\r\ndiva_user_mode_idi_remove_adapter(card->Id);\r\ndiva_os_enter_spin_lock(&ll_lock, &old_irql, "remove card");\r\nlist_del(&card->list);\r\ndiva_os_leave_spin_lock(&ll_lock, &old_irql, "remove card");\r\nDBG_LOG(("idi proc entry removed for card %d", card->Id));\r\ndiva_os_free(0, card);\r\n}\r\nstatic void __exit remove_all_idi_proc(void)\r\n{\r\nudiva_card *card;\r\ndiva_os_spin_lock_magic_t old_irql;\r\nrescan:\r\ndiva_os_enter_spin_lock(&ll_lock, &old_irql, "remove all");\r\nif (!list_empty(&cards)) {\r\ncard = list_entry(cards.next, udiva_card, list);\r\nlist_del(&card->list);\r\ndiva_os_leave_spin_lock(&ll_lock, &old_irql, "remove all");\r\ndiva_user_mode_idi_remove_adapter(card->Id);\r\ndiva_os_free(0, card);\r\ngoto rescan;\r\n}\r\ndiva_os_leave_spin_lock(&ll_lock, &old_irql, "remove all");\r\n}\r\nstatic void *didd_callback(void *context, DESCRIPTOR *adapter,\r\nint removal)\r\n{\r\nif (adapter->type == IDI_DADAPTER) {\r\nDBG_ERR(("Notification about IDI_DADAPTER change ! Oops."));\r\nreturn (NULL);\r\n} else if (adapter->type == IDI_DIMAINT) {\r\nif (removal) {\r\nstop_dbg();\r\n} else {\r\nmemcpy(&MAdapter, adapter, sizeof(MAdapter));\r\ndprintf = (DIVA_DI_PRINTF) MAdapter.request;\r\nDbgRegister("User IDI", DRIVERRELEASE_IDI, DBG_DEFAULT);\r\n}\r\n} else if ((adapter->type > 0) && (adapter->type < 16)) {\r\nif (removal) {\r\num_remove_card(adapter);\r\n} else {\r\num_new_card(adapter);\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nstatic int __init connect_didd(void)\r\n{\r\nint x = 0;\r\nint dadapter = 0;\r\nIDI_SYNC_REQ req;\r\nDESCRIPTOR DIDD_Table[MAX_DESCRIPTORS];\r\nDIVA_DIDD_Read(DIDD_Table, sizeof(DIDD_Table));\r\nfor (x = 0; x < MAX_DESCRIPTORS; x++) {\r\nif (DIDD_Table[x].type == IDI_DADAPTER) {\r\ndadapter = 1;\r\nmemcpy(&DAdapter, &DIDD_Table[x], sizeof(DAdapter));\r\nreq.didd_notify.e.Req = 0;\r\nreq.didd_notify.e.Rc =\r\nIDI_SYNC_REQ_DIDD_REGISTER_ADAPTER_NOTIFY;\r\nreq.didd_notify.info.callback = (void *)didd_callback;\r\nreq.didd_notify.info.context = NULL;\r\nDAdapter.request((ENTITY *)&req);\r\nif (req.didd_notify.e.Rc != 0xff) {\r\nstop_dbg();\r\nreturn (0);\r\n}\r\nnotify_handle = req.didd_notify.info.handle;\r\n} else if (DIDD_Table[x].type == IDI_DIMAINT) {\r\nmemcpy(&MAdapter, &DIDD_Table[x], sizeof(DAdapter));\r\ndprintf = (DIVA_DI_PRINTF) MAdapter.request;\r\nDbgRegister("User IDI", DRIVERRELEASE_IDI, DBG_DEFAULT);\r\n} else if ((DIDD_Table[x].type > 0)\r\n&& (DIDD_Table[x].type < 16)) {\r\num_new_card(&DIDD_Table[x]);\r\n}\r\n}\r\nif (!dadapter) {\r\nstop_dbg();\r\n}\r\nreturn (dadapter);\r\n}\r\nstatic void __exit disconnect_didd(void)\r\n{\r\nIDI_SYNC_REQ req;\r\nstop_dbg();\r\nreq.didd_notify.e.Req = 0;\r\nreq.didd_notify.e.Rc = IDI_SYNC_REQ_DIDD_REMOVE_ADAPTER_NOTIFY;\r\nreq.didd_notify.info.handle = notify_handle;\r\nDAdapter.request((ENTITY *)&req);\r\n}\r\nint __init idifunc_init(void)\r\n{\r\ndiva_os_initialize_spin_lock(&ll_lock, "idifunc");\r\nif (diva_user_mode_idi_init()) {\r\nDBG_ERR(("init: init failed."));\r\nreturn (0);\r\n}\r\nif (!connect_didd()) {\r\ndiva_user_mode_idi_finit();\r\nDBG_ERR(("init: failed to connect to DIDD."));\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nvoid __exit idifunc_finit(void)\r\n{\r\ndiva_user_mode_idi_finit();\r\ndisconnect_didd();\r\nremove_all_idi_proc();\r\n}
