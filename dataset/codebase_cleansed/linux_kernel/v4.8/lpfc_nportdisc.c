static int\r\nlpfc_check_adisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nstruct lpfc_name *nn, struct lpfc_name *pn)\r\n{\r\nif (!(ndlp->nlp_flag & NLP_RPI_REGISTERED))\r\nreturn 0;\r\nif (memcmp(nn, &ndlp->nlp_nodename, sizeof (struct lpfc_name)))\r\nreturn 0;\r\nif (memcmp(pn, &ndlp->nlp_portname, sizeof (struct lpfc_name)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint\r\nlpfc_check_sparm(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nstruct serv_parm *sp, uint32_t class, int flogi)\r\n{\r\nvolatile struct serv_parm *hsp = &vport->fc_sparam;\r\nuint16_t hsp_value, ssp_value = 0;\r\nif (sp->cls1.classValid) {\r\nif (!flogi) {\r\nhsp_value = ((hsp->cls1.rcvDataSizeMsb << 8) |\r\nhsp->cls1.rcvDataSizeLsb);\r\nssp_value = ((sp->cls1.rcvDataSizeMsb << 8) |\r\nsp->cls1.rcvDataSizeLsb);\r\nif (!ssp_value)\r\ngoto bad_service_param;\r\nif (ssp_value > hsp_value) {\r\nsp->cls1.rcvDataSizeLsb =\r\nhsp->cls1.rcvDataSizeLsb;\r\nsp->cls1.rcvDataSizeMsb =\r\nhsp->cls1.rcvDataSizeMsb;\r\n}\r\n}\r\n} else if (class == CLASS1)\r\ngoto bad_service_param;\r\nif (sp->cls2.classValid) {\r\nif (!flogi) {\r\nhsp_value = ((hsp->cls2.rcvDataSizeMsb << 8) |\r\nhsp->cls2.rcvDataSizeLsb);\r\nssp_value = ((sp->cls2.rcvDataSizeMsb << 8) |\r\nsp->cls2.rcvDataSizeLsb);\r\nif (!ssp_value)\r\ngoto bad_service_param;\r\nif (ssp_value > hsp_value) {\r\nsp->cls2.rcvDataSizeLsb =\r\nhsp->cls2.rcvDataSizeLsb;\r\nsp->cls2.rcvDataSizeMsb =\r\nhsp->cls2.rcvDataSizeMsb;\r\n}\r\n}\r\n} else if (class == CLASS2)\r\ngoto bad_service_param;\r\nif (sp->cls3.classValid) {\r\nif (!flogi) {\r\nhsp_value = ((hsp->cls3.rcvDataSizeMsb << 8) |\r\nhsp->cls3.rcvDataSizeLsb);\r\nssp_value = ((sp->cls3.rcvDataSizeMsb << 8) |\r\nsp->cls3.rcvDataSizeLsb);\r\nif (!ssp_value)\r\ngoto bad_service_param;\r\nif (ssp_value > hsp_value) {\r\nsp->cls3.rcvDataSizeLsb =\r\nhsp->cls3.rcvDataSizeLsb;\r\nsp->cls3.rcvDataSizeMsb =\r\nhsp->cls3.rcvDataSizeMsb;\r\n}\r\n}\r\n} else if (class == CLASS3)\r\ngoto bad_service_param;\r\nhsp_value = (hsp->cmn.bbRcvSizeMsb << 8) | hsp->cmn.bbRcvSizeLsb;\r\nssp_value = (sp->cmn.bbRcvSizeMsb << 8) | sp->cmn.bbRcvSizeLsb;\r\nif (ssp_value > hsp_value) {\r\nsp->cmn.bbRcvSizeLsb = hsp->cmn.bbRcvSizeLsb;\r\nsp->cmn.bbRcvSizeMsb = (sp->cmn.bbRcvSizeMsb & 0xF0) |\r\n(hsp->cmn.bbRcvSizeMsb & 0x0F);\r\n}\r\nmemcpy(&ndlp->nlp_nodename, &sp->nodeName, sizeof (struct lpfc_name));\r\nmemcpy(&ndlp->nlp_portname, &sp->portName, sizeof (struct lpfc_name));\r\nreturn 1;\r\nbad_service_param:\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0207 Device %x "\r\n"(%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x) sent "\r\n"invalid service parameters. Ignoring device.\n",\r\nndlp->nlp_DID,\r\nsp->nodeName.u.wwn[0], sp->nodeName.u.wwn[1],\r\nsp->nodeName.u.wwn[2], sp->nodeName.u.wwn[3],\r\nsp->nodeName.u.wwn[4], sp->nodeName.u.wwn[5],\r\nsp->nodeName.u.wwn[6], sp->nodeName.u.wwn[7]);\r\nreturn 0;\r\n}\r\nstatic void *\r\nlpfc_check_elscmpl_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_dmabuf *pcmd, *prsp;\r\nuint32_t *lp;\r\nvoid *ptr = NULL;\r\nIOCB_t *irsp;\r\nirsp = &rspiocb->iocb;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nif (pcmd) {\r\nprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf,\r\nlist);\r\nif (prsp) {\r\nlp = (uint32_t *) prsp->virt;\r\nptr = (void *)((uint8_t *)lp + sizeof(uint32_t));\r\n}\r\n} else {\r\nif (!(irsp->ulpStatus)) {\r\nirsp->ulpStatus = IOSTAT_LOCAL_REJECT;\r\nirsp->un.ulpWord[4] = IOERR_SLI_ABORTED;\r\n}\r\nptr = NULL;\r\n}\r\nreturn ptr;\r\n}\r\nint\r\nlpfc_els_abort(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp)\r\n{\r\nLIST_HEAD(abort_list);\r\nstruct lpfc_sli *psli = &phba->sli;\r\nstruct lpfc_sli_ring *pring = &psli->ring[LPFC_ELS_RING];\r\nstruct lpfc_iocbq *iocb, *next_iocb;\r\nlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_DISCOVERY,\r\n"2819 Abort outstanding I/O on NPort x%x "\r\n"Data: x%x x%x x%x\n",\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi);\r\nlpfc_fabric_abort_nport(ndlp);\r\nspin_lock_irq(&phba->hbalock);\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nspin_lock(&pring->ring_lock);\r\nlist_for_each_entry_safe(iocb, next_iocb, &pring->txcmplq, list) {\r\nif (lpfc_check_sli_ndlp(phba, pring, iocb, ndlp))\r\nlist_add_tail(&iocb->dlist, &abort_list);\r\n}\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nspin_unlock(&pring->ring_lock);\r\nspin_unlock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(iocb, next_iocb, &abort_list, dlist) {\r\nspin_lock_irq(&phba->hbalock);\r\nlist_del_init(&iocb->dlist);\r\nlpfc_sli_issue_abort_iotag(phba, pring, iocb);\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\nINIT_LIST_HEAD(&abort_list);\r\nspin_lock_irq(&phba->hbalock);\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nspin_lock(&pring->ring_lock);\r\nlist_for_each_entry_safe(iocb, next_iocb, &pring->txq, list) {\r\nif (lpfc_check_sli_ndlp(phba, pring, iocb, ndlp)) {\r\nlist_del_init(&iocb->list);\r\nlist_add_tail(&iocb->list, &abort_list);\r\n}\r\n}\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nspin_unlock(&pring->ring_lock);\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli_cancel_iocbs(phba, &abort_list,\r\nIOSTAT_LOCAL_REJECT, IOERR_SLI_ABORTED);\r\nlpfc_cancel_retry_delay_tmo(phba->pport, ndlp);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_rcv_plogi(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nstruct lpfc_iocbq *cmdiocb)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_dmabuf *pcmd;\r\nuint64_t nlp_portwwn = 0;\r\nuint32_t *lp;\r\nIOCB_t *icmd;\r\nstruct serv_parm *sp;\r\nuint32_t ed_tov;\r\nLPFC_MBOXQ_t *mbox;\r\nstruct ls_rjt stat;\r\nint rc;\r\nmemset(&stat, 0, sizeof (struct ls_rjt));\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nlp = (uint32_t *) pcmd->virt;\r\nsp = (struct serv_parm *) ((uint8_t *) lp + sizeof (uint32_t));\r\nif (wwn_to_u64(sp->portName.u.wwn) == 0) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0140 PLOGI Reject: invalid nname\n");\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_INVALID_PNAME;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\r\nNULL);\r\nreturn 0;\r\n}\r\nif (wwn_to_u64(sp->nodeName.u.wwn) == 0) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0141 PLOGI Reject: invalid pname\n");\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_INVALID_NNAME;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\r\nNULL);\r\nreturn 0;\r\n}\r\nnlp_portwwn = wwn_to_u64(ndlp->nlp_portname.u.wwn);\r\nif ((lpfc_check_sparm(vport, ndlp, sp, CLASS3, 0) == 0)) {\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\r\nNULL);\r\nreturn 0;\r\n}\r\nicmd = &cmdiocb->iocb;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0114 PLOGI chkparm OK Data: x%x x%x x%x "\r\n"x%x x%x x%x\n",\r\nndlp->nlp_DID, ndlp->nlp_state, ndlp->nlp_flag,\r\nndlp->nlp_rpi, vport->port_state,\r\nvport->fc_flag);\r\nif (vport->cfg_fcp_class == 2 && sp->cls2.classValid)\r\nndlp->nlp_fcp_info |= CLASS2;\r\nelse\r\nndlp->nlp_fcp_info |= CLASS3;\r\nndlp->nlp_class_sup = 0;\r\nif (sp->cls1.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS1;\r\nif (sp->cls2.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS2;\r\nif (sp->cls3.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS3;\r\nif (sp->cls4.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS4;\r\nndlp->nlp_maxframe =\r\n((sp->cmn.bbRcvSizeMsb & 0x0F) << 8) | sp->cmn.bbRcvSizeLsb;\r\nswitch (ndlp->nlp_state) {\r\ncase NLP_STE_NPR_NODE:\r\nif (!(ndlp->nlp_flag & NLP_NPR_ADISC))\r\nbreak;\r\ncase NLP_STE_REG_LOGIN_ISSUE:\r\ncase NLP_STE_PRLI_ISSUE:\r\ncase NLP_STE_UNMAPPED_NODE:\r\ncase NLP_STE_MAPPED_NODE:\r\nif (!(ndlp->nlp_type & NLP_FABRIC)) {\r\nlpfc_els_rsp_acc(vport, ELS_CMD_PLOGI, cmdiocb,\r\nndlp, NULL);\r\nreturn 1;\r\n}\r\nif (nlp_portwwn != 0 &&\r\nnlp_portwwn != wwn_to_u64(sp->portName.u.wwn))\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0143 PLOGI recv'd from DID: x%x "\r\n"WWPN changed: old %llx new %llx\n",\r\nndlp->nlp_DID,\r\n(unsigned long long)nlp_portwwn,\r\n(unsigned long long)\r\nwwn_to_u64(sp->portName.u.wwn));\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nbreak;\r\n}\r\nif ((vport->fc_flag & FC_PT2PT) &&\r\n!(vport->fc_flag & FC_PT2PT_PLOGI)) {\r\nvport->fc_myDID = icmd->un.rcvels.parmRo;\r\ned_tov = be32_to_cpu(sp->cmn.e_d_tov);\r\nif (sp->cmn.edtovResolution) {\r\ned_tov = (phba->fc_edtov + 999999) / 1000000;\r\n}\r\nif (ed_tov > phba->fc_edtov)\r\nphba->fc_edtov = ed_tov;\r\nphba->fc_ratov = (2 * phba->fc_edtov) / 1000;\r\nmemcpy(&phba->fc_fabparam, sp, sizeof(struct serv_parm));\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nlpfc_issue_reg_vfi(vport);\r\nelse {\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (mbox == NULL)\r\ngoto out;\r\nlpfc_config_link(phba, mbox);\r\nmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nmbox->vport = vport;\r\nrc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED) {\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\ngoto out;\r\n}\r\n}\r\nlpfc_can_disctmo(vport);\r\n}\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mbox)\r\ngoto out;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nlpfc_unreg_rpi(vport, ndlp);\r\nrc = lpfc_reg_rpi(phba, vport->vpi, icmd->un.rcvels.remoteID,\r\n(uint8_t *) sp, mbox, ndlp->nlp_rpi);\r\nif (rc) {\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\ngoto out;\r\n}\r\nmbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;\r\nmbox->vport = vport;\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= (NLP_ACC_REGLOGIN | NLP_RCV_PLOGI);\r\nspin_unlock_irq(shost->host_lock);\r\nif (ndlp->nlp_state == NLP_STE_PLOGI_ISSUE) {\r\nlpfc_els_abort(phba, ndlp);\r\n}\r\nif ((vport->port_type == LPFC_NPIV_PORT &&\r\nvport->cfg_restrict_login)) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_RM_DFLT_RPI;\r\nspin_unlock_irq(shost->host_lock);\r\nstat.un.b.lsRjtRsnCode = LSRJT_INVALID_CMD;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\r\nrc = lpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb,\r\nndlp, mbox);\r\nif (rc)\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nreturn 1;\r\n}\r\nrc = lpfc_els_rsp_acc(vport, ELS_CMD_PLOGI, cmdiocb, ndlp, mbox);\r\nif (rc)\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nreturn 1;\r\nout:\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_OUT_OF_RESOURCE;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_mbx_cmpl_resume_rpi(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\r\n{\r\nstruct lpfc_vport *vport;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_nodelist *ndlp;\r\nuint32_t cmd;\r\nelsiocb = (struct lpfc_iocbq *)mboxq->context1;\r\nndlp = (struct lpfc_nodelist *) mboxq->context2;\r\nvport = mboxq->vport;\r\ncmd = elsiocb->drvrTimeout;\r\nif (cmd == ELS_CMD_ADISC) {\r\nlpfc_els_rsp_adisc_acc(vport, elsiocb, ndlp);\r\n} else {\r\nlpfc_els_rsp_acc(vport, ELS_CMD_PLOGI, elsiocb,\r\nndlp, NULL);\r\n}\r\nkfree(elsiocb);\r\nmempool_free(mboxq, phba->mbox_mem_pool);\r\n}\r\nstatic int\r\nlpfc_rcv_padisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nstruct lpfc_iocbq *cmdiocb)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_dmabuf *pcmd;\r\nstruct serv_parm *sp;\r\nstruct lpfc_name *pnn, *ppn;\r\nstruct ls_rjt stat;\r\nADISC *ap;\r\nIOCB_t *icmd;\r\nuint32_t *lp;\r\nuint32_t cmd;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nlp = (uint32_t *) pcmd->virt;\r\ncmd = *lp++;\r\nif (cmd == ELS_CMD_ADISC) {\r\nap = (ADISC *) lp;\r\npnn = (struct lpfc_name *) & ap->nodeName;\r\nppn = (struct lpfc_name *) & ap->portName;\r\n} else {\r\nsp = (struct serv_parm *) lp;\r\npnn = (struct lpfc_name *) & sp->nodeName;\r\nppn = (struct lpfc_name *) & sp->portName;\r\n}\r\nicmd = &cmdiocb->iocb;\r\nif (icmd->ulpStatus == 0 && lpfc_check_adisc(vport, ndlp, pnn, ppn)) {\r\nif (vport->phba->sli_rev == LPFC_SLI_REV4) {\r\nelsiocb = kmalloc(sizeof(struct lpfc_iocbq),\r\nGFP_KERNEL);\r\nif (elsiocb) {\r\nmemcpy((uint8_t *)elsiocb, (uint8_t *)cmdiocb,\r\nsizeof(struct lpfc_iocbq));\r\nelsiocb->drvrTimeout = cmd;\r\nlpfc_sli4_resume_rpi(ndlp,\r\nlpfc_mbx_cmpl_resume_rpi, elsiocb);\r\ngoto out;\r\n}\r\n}\r\nif (cmd == ELS_CMD_ADISC) {\r\nlpfc_els_rsp_adisc_acc(vport, cmdiocb, ndlp);\r\n} else {\r\nlpfc_els_rsp_acc(vport, ELS_CMD_PLOGI, cmdiocb,\r\nndlp, NULL);\r\n}\r\nout:\r\nif (ndlp->nlp_type & NLP_FCP_TARGET)\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_MAPPED_NODE);\r\nelse\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\r\nreturn 1;\r\n}\r\nstat.un.b.lsRjtRsvd0 = 0;\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;\r\nstat.un.b.vendorUnique = 0;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nmod_timer(&ndlp->nlp_delayfunc, jiffies + msecs_to_jiffies(1000));\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_rcv_logo(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nstruct lpfc_iocbq *cmdiocb, uint32_t els_cmd)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_vport **vports;\r\nint i, active_vlink_present = 0 ;\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_LOGO_ACC;\r\nspin_unlock_irq(shost->host_lock);\r\nif (els_cmd == ELS_CMD_PRLO)\r\nlpfc_els_rsp_acc(vport, ELS_CMD_PRLO, cmdiocb, ndlp, NULL);\r\nelse\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\nif (ndlp->nlp_DID == Fabric_DID) {\r\nif (vport->port_state <= LPFC_FDISC)\r\ngoto out;\r\nlpfc_linkdown_port(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_VPORT_LOGO_RCVD;\r\nspin_unlock_irq(shost->host_lock);\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports) {\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL;\r\ni++) {\r\nif ((!(vports[i]->fc_flag &\r\nFC_VPORT_LOGO_RCVD)) &&\r\n(vports[i]->port_state > LPFC_FDISC)) {\r\nactive_vlink_present = 1;\r\nbreak;\r\n}\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\n}\r\nif (!(vport->load_flag & FC_UNLOADING) &&\r\nactive_vlink_present) {\r\nmod_timer(&ndlp->nlp_delayfunc,\r\njiffies + msecs_to_jiffies(1000));\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_last_elscmd = ELS_CMD_FDISC;\r\nvport->port_state = LPFC_FDISC;\r\n} else {\r\nspin_lock_irq(shost->host_lock);\r\nphba->pport->fc_flag &= ~FC_LOGO_RCVD_DID_CHNG;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_retry_pport_discovery(phba);\r\n}\r\n} else if ((!(ndlp->nlp_type & NLP_FABRIC) &&\r\n((ndlp->nlp_type & NLP_FCP_TARGET) ||\r\n!(ndlp->nlp_type & NLP_FCP_INITIATOR))) ||\r\n(ndlp->nlp_state == NLP_STE_ADISC_ISSUE)) {\r\nmod_timer(&ndlp->nlp_delayfunc,\r\njiffies + msecs_to_jiffies(1000 * 1));\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\r\n}\r\nout:\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_NPR_ADISC;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_rcv_prli(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nstruct lpfc_iocbq *cmdiocb)\r\n{\r\nstruct lpfc_dmabuf *pcmd;\r\nuint32_t *lp;\r\nPRLI *npr;\r\nstruct fc_rport *rport = ndlp->rport;\r\nu32 roles;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nlp = (uint32_t *) pcmd->virt;\r\nnpr = (PRLI *) ((uint8_t *) lp + sizeof (uint32_t));\r\nndlp->nlp_type &= ~(NLP_FCP_TARGET | NLP_FCP_INITIATOR);\r\nndlp->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\r\nndlp->nlp_flag &= ~NLP_FIRSTBURST;\r\nif (npr->prliType == PRLI_FCP_TYPE) {\r\nif (npr->initiatorFunc)\r\nndlp->nlp_type |= NLP_FCP_INITIATOR;\r\nif (npr->targetFunc) {\r\nndlp->nlp_type |= NLP_FCP_TARGET;\r\nif (npr->writeXferRdyDis)\r\nndlp->nlp_flag |= NLP_FIRSTBURST;\r\n}\r\nif (npr->Retry)\r\nndlp->nlp_fcp_info |= NLP_FCP_2_DEVICE;\r\n}\r\nif (rport) {\r\nroles = FC_RPORT_ROLE_UNKNOWN;\r\nif (ndlp->nlp_type & NLP_FCP_INITIATOR)\r\nroles |= FC_RPORT_ROLE_FCP_INITIATOR;\r\nif (ndlp->nlp_type & NLP_FCP_TARGET)\r\nroles |= FC_RPORT_ROLE_FCP_TARGET;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_RPORT,\r\n"rport rolechg: role:x%x did:x%x flg:x%x",\r\nroles, ndlp->nlp_DID, ndlp->nlp_flag);\r\nfc_remote_port_rolechg(rport, roles);\r\n}\r\n}\r\nstatic uint32_t\r\nlpfc_disc_set_adisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (!(ndlp->nlp_flag & NLP_RPI_REGISTERED)) {\r\nndlp->nlp_flag &= ~NLP_NPR_ADISC;\r\nreturn 0;\r\n}\r\nif (!(vport->fc_flag & FC_PT2PT)) {\r\nif ((vport->cfg_use_adisc && (vport->fc_flag & FC_RSCN_MODE)) ||\r\n((ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) &&\r\n(ndlp->nlp_type & NLP_FCP_TARGET))) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NPR_ADISC;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn 1;\r\n}\r\n}\r\nndlp->nlp_flag &= ~NLP_NPR_ADISC;\r\nlpfc_unreg_rpi(vport, ndlp);\r\nreturn 0;\r\n}\r\nvoid\r\nlpfc_release_rpi(struct lpfc_hba *phba,\r\nstruct lpfc_vport *vport,\r\nuint16_t rpi)\r\n{\r\nLPFC_MBOXQ_t *pmb;\r\nint rc;\r\npmb = (LPFC_MBOXQ_t *) mempool_alloc(phba->mbox_mem_pool,\r\nGFP_KERNEL);\r\nif (!pmb)\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_MBOX,\r\n"2796 mailbox memory allocation failed \n");\r\nelse {\r\nlpfc_unreg_login(phba, vport->vpi, rpi, pmb);\r\npmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED)\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\n}\r\n}\r\nstatic uint32_t\r\nlpfc_disc_illegal(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_hba *phba;\r\nLPFC_MBOXQ_t *pmb = (LPFC_MBOXQ_t *) arg;\r\nuint16_t rpi;\r\nphba = vport->phba;\r\nif (!(phba->pport->load_flag & FC_UNLOADING) &&\r\n(evt == NLP_EVT_CMPL_REG_LOGIN) &&\r\n(!pmb->u.mb.mbxStatus)) {\r\nrpi = pmb->u.mb.un.varWords[0];\r\nlpfc_release_rpi(phba, vport, rpi);\r\n}\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0271 Illegal State Transition: node x%x "\r\n"event x%x, state x%x Data: x%x x%x\n",\r\nndlp->nlp_DID, evt, ndlp->nlp_state, ndlp->nlp_rpi,\r\nndlp->nlp_flag);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_plogi_illegal(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nif (!(ndlp->nlp_flag & NLP_RCV_PLOGI)) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0272 Illegal State Transition: node x%x "\r\n"event x%x, state x%x Data: x%x x%x\n",\r\nndlp->nlp_DID, evt, ndlp->nlp_state, ndlp->nlp_rpi,\r\nndlp->nlp_flag);\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_plogi_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nif (lpfc_rcv_plogi(vport, ndlp, cmdiocb)) {\r\nreturn ndlp->nlp_state;\r\n}\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_els_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nlpfc_issue_els_logo(vport, ndlp, 0);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_logo_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_LOGO_ACC;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_logo_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\nstatic uint32_t\r\nlpfc_device_rm_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\nstatic uint32_t\r\nlpfc_device_recov_unused_node(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_plogi_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *cmdiocb = arg;\r\nstruct lpfc_dmabuf *pcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nuint32_t *lp = (uint32_t *) pcmd->virt;\r\nstruct serv_parm *sp = (struct serv_parm *) (lp + 1);\r\nstruct ls_rjt stat;\r\nint port_cmp;\r\nmemset(&stat, 0, sizeof (struct ls_rjt));\r\nphba->fc_stat.elsLogiCol++;\r\nport_cmp = memcmp(&vport->fc_portname, &sp->portName,\r\nsizeof(struct lpfc_name));\r\nif (port_cmp >= 0) {\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_CMD_IN_PROGRESS;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\r\nNULL);\r\n} else {\r\nif (lpfc_rcv_plogi(vport, ndlp, cmdiocb) &&\r\n(ndlp->nlp_flag & NLP_NPR_2B_DISC) &&\r\n(vport->num_disc_nodes)) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_more_plogi(vport);\r\nif (vport->num_disc_nodes == 0) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_NDISC_ACTIVE;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_can_disctmo(vport);\r\nlpfc_end_rscn(vport);\r\n}\r\n}\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prli_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nstruct ls_rjt stat;\r\nmemset(&stat, 0, sizeof (struct ls_rjt));\r\nstat.un.b.lsRjtRsnCode = LSRJT_LOGICAL_BSY;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_logo_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_abort(vport->phba, ndlp);\r\nlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_els_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_abort(phba, ndlp);\r\nif (evt == NLP_EVT_RCV_LOGO) {\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\n} else {\r\nlpfc_issue_els_logo(vport, ndlp, 0);\r\n}\r\nmod_timer(&ndlp->nlp_delayfunc, jiffies + msecs_to_jiffies(1000 * 1));\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\r\nndlp->nlp_prev_state = NLP_STE_PLOGI_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_plogi_plogi_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_iocbq *cmdiocb, *rspiocb;\r\nstruct lpfc_dmabuf *pcmd, *prsp, *mp;\r\nuint32_t *lp;\r\nIOCB_t *irsp;\r\nstruct serv_parm *sp;\r\nuint32_t ed_tov;\r\nLPFC_MBOXQ_t *mbox;\r\nint rc;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nrspiocb = cmdiocb->context_un.rsp_iocb;\r\nif (ndlp->nlp_flag & NLP_ACC_REGLOGIN) {\r\nreturn ndlp->nlp_state;\r\n}\r\nirsp = &rspiocb->iocb;\r\nif (irsp->ulpStatus)\r\ngoto out;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\r\nif (!prsp)\r\ngoto out;\r\nlp = (uint32_t *) prsp->virt;\r\nsp = (struct serv_parm *) ((uint8_t *) lp + sizeof (uint32_t));\r\nif ((ndlp->nlp_DID != FDMI_DID) &&\r\n(wwn_to_u64(sp->portName.u.wwn) == 0 ||\r\nwwn_to_u64(sp->nodeName.u.wwn) == 0)) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0142 PLOGI RSP: Invalid WWN.\n");\r\ngoto out;\r\n}\r\nif (!lpfc_check_sparm(vport, ndlp, sp, CLASS3, 0))\r\ngoto out;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0121 PLOGI chkparm OK Data: x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, ndlp->nlp_state,\r\nndlp->nlp_flag, ndlp->nlp_rpi);\r\nif (vport->cfg_fcp_class == 2 && (sp->cls2.classValid))\r\nndlp->nlp_fcp_info |= CLASS2;\r\nelse\r\nndlp->nlp_fcp_info |= CLASS3;\r\nndlp->nlp_class_sup = 0;\r\nif (sp->cls1.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS1;\r\nif (sp->cls2.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS2;\r\nif (sp->cls3.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS3;\r\nif (sp->cls4.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS4;\r\nndlp->nlp_maxframe =\r\n((sp->cmn.bbRcvSizeMsb & 0x0F) << 8) | sp->cmn.bbRcvSizeLsb;\r\nif ((vport->fc_flag & FC_PT2PT) &&\r\n(vport->fc_flag & FC_PT2PT_PLOGI)) {\r\ned_tov = be32_to_cpu(sp->cmn.e_d_tov);\r\nif (sp->cmn.edtovResolution) {\r\ned_tov = (phba->fc_edtov + 999999) / 1000000;\r\n}\r\nif (ed_tov > phba->fc_edtov)\r\nphba->fc_edtov = ed_tov;\r\nphba->fc_ratov = (2 * phba->fc_edtov) / 1000;\r\nmemcpy(&phba->fc_fabparam, sp, sizeof(struct serv_parm));\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nlpfc_issue_reg_vfi(vport);\r\n} else {\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mbox) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0133 PLOGI: no memory "\r\n"for config_link "\r\n"Data: x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, ndlp->nlp_state,\r\nndlp->nlp_flag, ndlp->nlp_rpi);\r\ngoto out;\r\n}\r\nlpfc_config_link(phba, mbox);\r\nmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nmbox->vport = vport;\r\nrc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED) {\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\ngoto out;\r\n}\r\n}\r\n}\r\nlpfc_unreg_rpi(vport, ndlp);\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mbox) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0018 PLOGI: no memory for reg_login "\r\n"Data: x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, ndlp->nlp_state,\r\nndlp->nlp_flag, ndlp->nlp_rpi);\r\ngoto out;\r\n}\r\nif (lpfc_reg_rpi(phba, vport->vpi, irsp->un.elsreq64.remoteID,\r\n(uint8_t *) sp, mbox, ndlp->nlp_rpi) == 0) {\r\nswitch (ndlp->nlp_DID) {\r\ncase NameServer_DID:\r\nmbox->mbox_cmpl = lpfc_mbx_cmpl_ns_reg_login;\r\nbreak;\r\ncase FDMI_DID:\r\nmbox->mbox_cmpl = lpfc_mbx_cmpl_fdmi_reg_login;\r\nbreak;\r\ndefault:\r\nndlp->nlp_flag |= NLP_REG_LOGIN_SEND;\r\nmbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;\r\n}\r\nmbox->context2 = lpfc_nlp_get(ndlp);\r\nmbox->vport = vport;\r\nif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\r\n!= MBX_NOT_FINISHED) {\r\nlpfc_nlp_set_state(vport, ndlp,\r\nNLP_STE_REG_LOGIN_ISSUE);\r\nreturn ndlp->nlp_state;\r\n}\r\nif (ndlp->nlp_flag & NLP_REG_LOGIN_SEND)\r\nndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\r\nlpfc_nlp_put(ndlp);\r\nmp = (struct lpfc_dmabuf *) mbox->context1;\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nkfree(mp);\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0134 PLOGI: cannot issue reg_login "\r\n"Data: x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, ndlp->nlp_state,\r\nndlp->nlp_flag, ndlp->nlp_rpi);\r\n} else {\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0135 PLOGI: cannot format reg_login "\r\n"Data: x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, ndlp->nlp_state,\r\nndlp->nlp_flag, ndlp->nlp_rpi);\r\n}\r\nout:\r\nif (ndlp->nlp_DID == NameServer_DID) {\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0261 Cannot Register NameServer login\n");\r\n}\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DEFER_RM;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_logo_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_reglogin_plogi_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp, void *arg, uint32_t evt)\r\n{\r\nstruct lpfc_hba *phba;\r\nLPFC_MBOXQ_t *pmb = (LPFC_MBOXQ_t *) arg;\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nuint16_t rpi;\r\nphba = vport->phba;\r\nif (!(phba->pport->load_flag & FC_UNLOADING) &&\r\n!mb->mbxStatus) {\r\nrpi = pmb->u.mb.un.varWords[0];\r\nlpfc_release_rpi(phba, vport, rpi);\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_device_rm_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NODEV_REMOVE;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn ndlp->nlp_state;\r\n} else {\r\nlpfc_els_abort(vport->phba, ndlp);\r\nlpfc_drop_node(vport, ndlp);\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\n}\r\nstatic uint32_t\r\nlpfc_device_recov_plogi_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nif (vport->fc_flag & FC_RSCN_DEFERRED)\r\nreturn ndlp->nlp_state;\r\nlpfc_els_abort(phba, ndlp);\r\nndlp->nlp_prev_state = NLP_STE_PLOGI_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\r\nspin_unlock_irq(shost->host_lock);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_plogi_adisc_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *cmdiocb;\r\nlpfc_els_abort(phba, ndlp);\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nif (lpfc_rcv_plogi(vport, ndlp, cmdiocb)) {\r\nif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\r\nspin_unlock_irq(shost->host_lock);\r\nif (vport->num_disc_nodes)\r\nlpfc_more_adisc(vport);\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\r\nlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prli_adisc_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_logo_adisc_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *cmdiocb;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_abort(phba, ndlp);\r\nlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_padisc_adisc_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_padisc(vport, ndlp, cmdiocb);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prlo_adisc_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_PRLO);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_adisc_adisc_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *cmdiocb, *rspiocb;\r\nIOCB_t *irsp;\r\nADISC *ap;\r\nint rc;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nrspiocb = cmdiocb->context_un.rsp_iocb;\r\nap = (ADISC *)lpfc_check_elscmpl_iocb(phba, cmdiocb, rspiocb);\r\nirsp = &rspiocb->iocb;\r\nif ((irsp->ulpStatus) ||\r\n(!lpfc_check_adisc(vport, ndlp, &ap->nodeName, &ap->portName))) {\r\nmod_timer(&ndlp->nlp_delayfunc,\r\njiffies + msecs_to_jiffies(1000));\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\r\nmemset(&ndlp->nlp_nodename, 0, sizeof(struct lpfc_name));\r\nmemset(&ndlp->nlp_portname, 0, sizeof(struct lpfc_name));\r\nndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nlpfc_unreg_rpi(vport, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nrc = lpfc_sli4_resume_rpi(ndlp, NULL, NULL);\r\nif (rc) {\r\nndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\r\nreturn ndlp->nlp_state;\r\n}\r\n}\r\nif (ndlp->nlp_type & NLP_FCP_TARGET) {\r\nndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_MAPPED_NODE);\r\n} else {\r\nndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_device_rm_adisc_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NODEV_REMOVE;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn ndlp->nlp_state;\r\n} else {\r\nlpfc_els_abort(vport->phba, ndlp);\r\nlpfc_drop_node(vport, ndlp);\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\n}\r\nstatic uint32_t\r\nlpfc_device_recov_adisc_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nif (vport->fc_flag & FC_RSCN_DEFERRED)\r\nreturn ndlp->nlp_state;\r\nlpfc_els_abort(phba, ndlp);\r\nndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_disc_set_adisc(vport, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_plogi_reglogin_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_plogi(vport, ndlp, cmdiocb);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prli_reglogin_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_logo_reglogin_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nLPFC_MBOXQ_t *mb;\r\nLPFC_MBOXQ_t *nextmb;\r\nstruct lpfc_dmabuf *mp;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nif ((mb = phba->sli.mbox_active)) {\r\nif ((mb->u.mb.mbxCommand == MBX_REG_LOGIN64) &&\r\n(ndlp == (struct lpfc_nodelist *) mb->context2)) {\r\nndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\r\nlpfc_nlp_put(ndlp);\r\nmb->context2 = NULL;\r\nmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\n}\r\n}\r\nspin_lock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(mb, nextmb, &phba->sli.mboxq, list) {\r\nif ((mb->u.mb.mbxCommand == MBX_REG_LOGIN64) &&\r\n(ndlp == (struct lpfc_nodelist *) mb->context2)) {\r\nmp = (struct lpfc_dmabuf *) (mb->context1);\r\nif (mp) {\r\n__lpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nkfree(mp);\r\n}\r\nndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\r\nlpfc_nlp_put(ndlp);\r\nlist_del(&mb->list);\r\nphba->sli.mboxq_cnt--;\r\nmempool_free(mb, phba->mbox_mem_pool);\r\n}\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_padisc_reglogin_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_padisc(vport, ndlp, cmdiocb);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prlo_reglogin_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_rsp_acc(vport, ELS_CMD_PRLO, cmdiocb, ndlp, NULL);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_reglogin_reglogin_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nLPFC_MBOXQ_t *pmb = (LPFC_MBOXQ_t *) arg;\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nuint32_t did = mb->un.varWords[1];\r\nif (mb->mbxStatus) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0246 RegLogin failed Data: x%x x%x x%x x%x "\r\n"x%x\n",\r\ndid, mb->mbxStatus, vport->port_state,\r\nmb->un.varRegLogin.vpi,\r\nmb->un.varRegLogin.rpi);\r\nif (mb->mbxStatus == MBXERR_RPI_FULL) {\r\nndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nreturn ndlp->nlp_state;\r\n}\r\nmod_timer(&ndlp->nlp_delayfunc,\r\njiffies + msecs_to_jiffies(1000 * 1));\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\r\nlpfc_issue_els_logo(vport, ndlp, 0);\r\nndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nreturn ndlp->nlp_state;\r\n}\r\nif (vport->phba->sli_rev < LPFC_SLI_REV4)\r\nndlp->nlp_rpi = mb->un.varWords[0];\r\nndlp->nlp_flag |= NLP_RPI_REGISTERED;\r\nif (!(ndlp->nlp_type & NLP_FABRIC)) {\r\nndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);\r\nlpfc_issue_els_prli(vport, ndlp, 0);\r\n} else {\r\nndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_device_rm_reglogin_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NODEV_REMOVE;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn ndlp->nlp_state;\r\n} else {\r\nlpfc_drop_node(vport, ndlp);\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\n}\r\nstatic uint32_t\r\nlpfc_device_recov_reglogin_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (vport->fc_flag & FC_RSCN_DEFERRED)\r\nreturn ndlp->nlp_state;\r\nndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_IGNR_REG_CMPL;\r\nndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_disc_set_adisc(vport, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_plogi_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_plogi(vport, ndlp, cmdiocb);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prli_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_logo_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_abort(vport->phba, ndlp);\r\nlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_padisc_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_padisc(vport, ndlp, cmdiocb);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prlo_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_rsp_acc(vport, ELS_CMD_PRLO, cmdiocb, ndlp, NULL);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_prli_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_iocbq *cmdiocb, *rspiocb;\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *irsp;\r\nPRLI *npr;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nrspiocb = cmdiocb->context_un.rsp_iocb;\r\nnpr = (PRLI *)lpfc_check_elscmpl_iocb(phba, cmdiocb, rspiocb);\r\nirsp = &rspiocb->iocb;\r\nif (irsp->ulpStatus) {\r\nif ((vport->port_type == LPFC_NPIV_PORT) &&\r\nvport->cfg_restrict_login) {\r\ngoto out;\r\n}\r\nndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\r\nreturn ndlp->nlp_state;\r\n}\r\nndlp->nlp_type &= ~(NLP_FCP_TARGET | NLP_FCP_INITIATOR);\r\nndlp->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\r\nndlp->nlp_flag &= ~NLP_FIRSTBURST;\r\nif ((npr->acceptRspCode == PRLI_REQ_EXECUTED) &&\r\n(npr->prliType == PRLI_FCP_TYPE)) {\r\nif (npr->initiatorFunc)\r\nndlp->nlp_type |= NLP_FCP_INITIATOR;\r\nif (npr->targetFunc) {\r\nndlp->nlp_type |= NLP_FCP_TARGET;\r\nif (npr->writeXferRdyDis)\r\nndlp->nlp_flag |= NLP_FIRSTBURST;\r\n}\r\nif (npr->Retry)\r\nndlp->nlp_fcp_info |= NLP_FCP_2_DEVICE;\r\n}\r\nif (!(ndlp->nlp_type & NLP_FCP_TARGET) &&\r\n(vport->port_type == LPFC_NPIV_PORT) &&\r\nvport->cfg_restrict_login) {\r\nout:\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_TARGET_REMOVE;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_issue_els_logo(vport, ndlp, 0);\r\nndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nreturn ndlp->nlp_state;\r\n}\r\nndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;\r\nif (ndlp->nlp_type & NLP_FCP_TARGET)\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_MAPPED_NODE);\r\nelse\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_device_rm_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NODEV_REMOVE;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn ndlp->nlp_state;\r\n} else {\r\nlpfc_els_abort(vport->phba, ndlp);\r\nlpfc_drop_node(vport, ndlp);\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\n}\r\nstatic uint32_t\r\nlpfc_device_recov_prli_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nif (vport->fc_flag & FC_RSCN_DEFERRED)\r\nreturn ndlp->nlp_state;\r\nlpfc_els_abort(phba, ndlp);\r\nndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_disc_set_adisc(vport, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_plogi_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)arg;\r\nstruct ls_rjt stat;\r\nmemset(&stat, 0, sizeof(struct ls_rjt));\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prli_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)arg;\r\nstruct ls_rjt stat;\r\nmemset(&stat, 0, sizeof(struct ls_rjt));\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_logo_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)arg;\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_LOGO_ACC;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_padisc_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)arg;\r\nstruct ls_rjt stat;\r\nmemset(&stat, 0, sizeof(struct ls_rjt));\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prlo_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)arg;\r\nstruct ls_rjt stat;\r\nmemset(&stat, 0, sizeof(struct ls_rjt));\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_logo_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nndlp->nlp_prev_state = NLP_STE_LOGO_ISSUE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_disc_set_adisc(vport, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_device_rm_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_device_recov_logo_issue(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_plogi_unmap_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_plogi(vport, ndlp, cmdiocb);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prli_unmap_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_prli(vport, ndlp, cmdiocb);\r\nlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_logo_unmap_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_padisc_unmap_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_padisc(vport, ndlp, cmdiocb);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prlo_unmap_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_rsp_acc(vport, ELS_CMD_PRLO, cmdiocb, ndlp, NULL);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_device_recov_unmap_node(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nndlp->nlp_prev_state = NLP_STE_UNMAPPED_NODE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_disc_set_adisc(vport, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_plogi_mapped_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_plogi(vport, ndlp, cmdiocb);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prli_mapped_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_logo_mapped_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_padisc_mapped_node(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_padisc(vport, ndlp, cmdiocb);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prlo_mapped_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_sli_abort_iocb(vport, &phba->sli.ring[phba->sli.fcp_ring],\r\nndlp->nlp_sid, 0, LPFC_CTX_TGT);\r\nlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_PRLO);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_device_recov_mapped_node(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg,\r\nuint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nndlp->nlp_prev_state = NLP_STE_MAPPED_NODE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_disc_set_adisc(vport, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_plogi_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nif (ndlp->nlp_flag & (NLP_LOGO_SND | NLP_LOGO_ACC))\r\nreturn ndlp->nlp_state;\r\nif (lpfc_rcv_plogi(vport, ndlp, cmdiocb)) {\r\nlpfc_cancel_retry_delay_tmo(vport, ndlp);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~(NLP_NPR_ADISC | NLP_NPR_2B_DISC);\r\nspin_unlock_irq(shost->host_lock);\r\n} else if (!(ndlp->nlp_flag & NLP_NPR_2B_DISC)) {\r\nif (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {\r\nndlp->nlp_prev_state = NLP_STE_NPR_NODE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\r\nlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\r\n}\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prli_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nstruct ls_rjt stat;\r\nmemset(&stat, 0, sizeof (struct ls_rjt));\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nif (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {\r\nif (ndlp->nlp_flag & NLP_NPR_ADISC) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_NPR_ADISC;\r\nndlp->nlp_prev_state = NLP_STE_NPR_NODE;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\r\nlpfc_issue_els_adisc(vport, ndlp, 0);\r\n} else {\r\nndlp->nlp_prev_state = NLP_STE_NPR_NODE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\r\nlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\r\n}\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_logo_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_padisc_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nlpfc_rcv_padisc(vport, ndlp, cmdiocb);\r\nif (!(ndlp->nlp_flag & NLP_DELAY_TMO) &&\r\n!(ndlp->nlp_flag & NLP_NPR_2B_DISC)) {\r\nif (ndlp->nlp_flag & NLP_NPR_ADISC) {\r\nndlp->nlp_flag &= ~NLP_NPR_ADISC;\r\nndlp->nlp_prev_state = NLP_STE_NPR_NODE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\r\nlpfc_issue_els_adisc(vport, ndlp, 0);\r\n} else {\r\nndlp->nlp_prev_state = NLP_STE_NPR_NODE;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\r\nlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\r\n}\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_rcv_prlo_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_LOGO_ACC;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\nif ((ndlp->nlp_flag & NLP_DELAY_TMO) == 0) {\r\nmod_timer(&ndlp->nlp_delayfunc,\r\njiffies + msecs_to_jiffies(1000 * 1));\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DELAY_TMO;\r\nndlp->nlp_flag &= ~NLP_NPR_ADISC;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\r\n} else {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_NPR_ADISC;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_plogi_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb, *rspiocb;\r\nIOCB_t *irsp;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nrspiocb = cmdiocb->context_un.rsp_iocb;\r\nirsp = &rspiocb->iocb;\r\nif (irsp->ulpStatus) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DEFER_RM;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_prli_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb, *rspiocb;\r\nIOCB_t *irsp;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nrspiocb = cmdiocb->context_un.rsp_iocb;\r\nirsp = &rspiocb->iocb;\r\nif (irsp->ulpStatus && (ndlp->nlp_flag & NLP_NODEV_REMOVE)) {\r\nlpfc_drop_node(vport, ndlp);\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_logo_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (ndlp->nlp_DID == Fabric_DID) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nlpfc_unreg_rpi(vport, ndlp);\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_adisc_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct lpfc_iocbq *cmdiocb, *rspiocb;\r\nIOCB_t *irsp;\r\ncmdiocb = (struct lpfc_iocbq *) arg;\r\nrspiocb = cmdiocb->context_un.rsp_iocb;\r\nirsp = &rspiocb->iocb;\r\nif (irsp->ulpStatus && (ndlp->nlp_flag & NLP_NODEV_REMOVE)) {\r\nlpfc_drop_node(vport, ndlp);\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_cmpl_reglogin_npr_node(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nLPFC_MBOXQ_t *pmb = (LPFC_MBOXQ_t *) arg;\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nif (!mb->mbxStatus) {\r\nif (vport->phba->sli_rev < LPFC_SLI_REV4)\r\nndlp->nlp_rpi = mb->un.varWords[0];\r\nndlp->nlp_flag |= NLP_RPI_REGISTERED;\r\nif (ndlp->nlp_flag & NLP_LOGO_ACC) {\r\nlpfc_unreg_rpi(vport, ndlp);\r\n}\r\n} else {\r\nif (ndlp->nlp_flag & NLP_NODEV_REMOVE) {\r\nlpfc_drop_node(vport, ndlp);\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\n}\r\nreturn ndlp->nlp_state;\r\n}\r\nstatic uint32_t\r\nlpfc_device_rm_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NODEV_REMOVE;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn ndlp->nlp_state;\r\n}\r\nlpfc_drop_node(vport, ndlp);\r\nreturn NLP_STE_FREED_NODE;\r\n}\r\nstatic uint32_t\r\nlpfc_device_recov_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (vport->fc_flag & FC_RSCN_DEFERRED)\r\nreturn ndlp->nlp_state;\r\nlpfc_cancel_retry_delay_tmo(vport, ndlp);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\r\nspin_unlock_irq(shost->host_lock);\r\nreturn ndlp->nlp_state;\r\n}\r\nint\r\nlpfc_disc_state_machine(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nvoid *arg, uint32_t evt)\r\n{\r\nuint32_t cur_state, rc;\r\nuint32_t(*func) (struct lpfc_vport *, struct lpfc_nodelist *, void *,\r\nuint32_t);\r\nuint32_t got_ndlp = 0;\r\nif (lpfc_nlp_get(ndlp))\r\ngot_ndlp = 1;\r\ncur_state = ndlp->nlp_state;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0211 DSM in event x%x on NPort x%x in "\r\n"state %d Data: x%x\n",\r\nevt, ndlp->nlp_DID, cur_state, ndlp->nlp_flag);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_DSM,\r\n"DSM in: evt:%d ste:%d did:x%x",\r\nevt, cur_state, ndlp->nlp_DID);\r\nfunc = lpfc_disc_action[(cur_state * NLP_EVT_MAX_EVENT) + evt];\r\nrc = (func) (vport, ndlp, arg, evt);\r\nif (got_ndlp) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0212 DSM out state %d on NPort x%x Data: x%x\n",\r\nrc, ndlp->nlp_DID, ndlp->nlp_flag);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_DSM,\r\n"DSM out: ste:%d did:x%x flg:x%x",\r\nrc, ndlp->nlp_DID, ndlp->nlp_flag);\r\nlpfc_nlp_put(ndlp);\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0213 DSM out state %d on NPort free\n", rc);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_DSM,\r\n"DSM out: ste:%d did:x%x flg:x%x",\r\nrc, 0, 0);\r\n}\r\nreturn rc;\r\n}
