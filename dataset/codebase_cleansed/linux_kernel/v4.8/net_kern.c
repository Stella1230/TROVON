static int update_drop_skb(int max)\r\n{\r\nstruct sk_buff *new;\r\nunsigned long flags;\r\nint err = 0;\r\nspin_lock_irqsave(&drop_lock, flags);\r\nif (max <= drop_max)\r\ngoto out;\r\nerr = -ENOMEM;\r\nnew = dev_alloc_skb(max);\r\nif (new == NULL)\r\ngoto out;\r\nskb_put(new, max);\r\nkfree_skb(drop_skb);\r\ndrop_skb = new;\r\ndrop_max = max;\r\nerr = 0;\r\nout:\r\nspin_unlock_irqrestore(&drop_lock, flags);\r\nreturn err;\r\n}\r\nstatic int uml_net_rx(struct net_device *dev)\r\n{\r\nstruct uml_net_private *lp = netdev_priv(dev);\r\nint pkt_len;\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(lp->max_packet);\r\nif (skb == NULL) {\r\ndrop_skb->dev = dev;\r\n(*lp->read)(lp->fd, drop_skb, lp);\r\ndev->stats.rx_dropped++;\r\nreturn 0;\r\n}\r\nskb->dev = dev;\r\nskb_put(skb, lp->max_packet);\r\nskb_reset_mac_header(skb);\r\npkt_len = (*lp->read)(lp->fd, skb, lp);\r\nif (pkt_len > 0) {\r\nskb_trim(skb, pkt_len);\r\nskb->protocol = (*lp->protocol)(skb);\r\ndev->stats.rx_bytes += skb->len;\r\ndev->stats.rx_packets++;\r\nnetif_rx(skb);\r\nreturn pkt_len;\r\n}\r\nkfree_skb(skb);\r\nreturn pkt_len;\r\n}\r\nstatic void uml_dev_close(struct work_struct *work)\r\n{\r\nstruct uml_net_private *lp =\r\ncontainer_of(work, struct uml_net_private, work);\r\ndev_close(lp->dev);\r\n}\r\nstatic irqreturn_t uml_net_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct uml_net_private *lp = netdev_priv(dev);\r\nint err;\r\nif (!netif_running(dev))\r\nreturn IRQ_NONE;\r\nspin_lock(&lp->lock);\r\nwhile ((err = uml_net_rx(dev)) > 0) ;\r\nif (err < 0) {\r\nprintk(KERN_ERR\r\n"Device '%s' read returned %d, shutting it down\n",\r\ndev->name, err);\r\nschedule_work(&lp->work);\r\ngoto out;\r\n}\r\nreactivate_fd(lp->fd, UM_ETH_IRQ);\r\nout:\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int uml_net_open(struct net_device *dev)\r\n{\r\nstruct uml_net_private *lp = netdev_priv(dev);\r\nint err;\r\nif (lp->fd >= 0) {\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\nlp->fd = (*lp->open)(&lp->user);\r\nif (lp->fd < 0) {\r\nerr = lp->fd;\r\ngoto out;\r\n}\r\nerr = um_request_irq(dev->irq, lp->fd, IRQ_READ, uml_net_interrupt,\r\nIRQF_SHARED, dev->name, dev);\r\nif (err != 0) {\r\nprintk(KERN_ERR "uml_net_open: failed to get irq(%d)\n", err);\r\nerr = -ENETUNREACH;\r\ngoto out_close;\r\n}\r\nlp->tl.data = (unsigned long) &lp->user;\r\nnetif_start_queue(dev);\r\nwhile ((err = uml_net_rx(dev)) > 0) ;\r\nspin_lock(&opened_lock);\r\nlist_add(&lp->list, &opened);\r\nspin_unlock(&opened_lock);\r\nreturn 0;\r\nout_close:\r\nif (lp->close != NULL) (*lp->close)(lp->fd, &lp->user);\r\nlp->fd = -1;\r\nout:\r\nreturn err;\r\n}\r\nstatic int uml_net_close(struct net_device *dev)\r\n{\r\nstruct uml_net_private *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\num_free_irq(dev->irq, dev);\r\nif (lp->close != NULL)\r\n(*lp->close)(lp->fd, &lp->user);\r\nlp->fd = -1;\r\nspin_lock(&opened_lock);\r\nlist_del(&lp->list);\r\nspin_unlock(&opened_lock);\r\nreturn 0;\r\n}\r\nstatic int uml_net_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct uml_net_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nint len;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nlen = (*lp->write)(lp->fd, skb, lp);\r\nskb_tx_timestamp(skb);\r\nif (len == skb->len) {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nnetif_trans_update(dev);\r\nnetif_start_queue(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nelse if (len == 0) {\r\nnetif_start_queue(dev);\r\ndev->stats.tx_dropped++;\r\n}\r\nelse {\r\nnetif_start_queue(dev);\r\nprintk(KERN_ERR "uml_net_start_xmit: failed(%d)\n", len);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndev_consume_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void uml_net_set_multicast_list(struct net_device *dev)\r\n{\r\nreturn;\r\n}\r\nstatic void uml_net_tx_timeout(struct net_device *dev)\r\n{\r\nnetif_trans_update(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int uml_net_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void uml_net_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\numl_net_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic void uml_net_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRIVER_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, "42", sizeof(info->version));\r\n}\r\nstatic void uml_net_user_timer_expire(unsigned long _conn)\r\n{\r\n#ifdef undef\r\nstruct connection *conn = (struct connection *)_conn;\r\ndprintk(KERN_INFO "uml_net_user_timer_expire [%p]\n", conn);\r\ndo_connect(conn);\r\n#endif\r\n}\r\nstatic void setup_etheraddr(struct net_device *dev, char *str)\r\n{\r\nunsigned char *addr = dev->dev_addr;\r\nchar *end;\r\nint i;\r\nif (str == NULL)\r\ngoto random;\r\nfor (i = 0; i < 6; i++) {\r\naddr[i] = simple_strtoul(str, &end, 16);\r\nif ((end == str) ||\r\n((*end != ':') && (*end != ',') && (*end != '\0'))) {\r\nprintk(KERN_ERR\r\n"setup_etheraddr: failed to parse '%s' "\r\n"as an ethernet address\n", str);\r\ngoto random;\r\n}\r\nstr = end + 1;\r\n}\r\nif (is_multicast_ether_addr(addr)) {\r\nprintk(KERN_ERR\r\n"Attempt to assign a multicast ethernet address to a "\r\n"device disallowed\n");\r\ngoto random;\r\n}\r\nif (!is_valid_ether_addr(addr)) {\r\nprintk(KERN_ERR\r\n"Attempt to assign an invalid ethernet address to a "\r\n"device disallowed\n");\r\ngoto random;\r\n}\r\nif (!is_local_ether_addr(addr)) {\r\nprintk(KERN_WARNING\r\n"Warning: Assigning a globally valid ethernet "\r\n"address to a device\n");\r\nprintk(KERN_WARNING "You should set the 2nd rightmost bit in "\r\n"the first byte of the MAC,\n");\r\nprintk(KERN_WARNING "i.e. %02x:%02x:%02x:%02x:%02x:%02x\n",\r\naddr[0] | 0x02, addr[1], addr[2], addr[3], addr[4],\r\naddr[5]);\r\n}\r\nreturn;\r\nrandom:\r\nprintk(KERN_INFO\r\n"Choosing a random ethernet address for device %s\n", dev->name);\r\neth_hw_addr_random(dev);\r\n}\r\nstatic void net_device_release(struct device *dev)\r\n{\r\nstruct uml_net *device = dev_get_drvdata(dev);\r\nstruct net_device *netdev = device->dev;\r\nstruct uml_net_private *lp = netdev_priv(netdev);\r\nif (lp->remove != NULL)\r\n(*lp->remove)(&lp->user);\r\nlist_del(&device->list);\r\nkfree(device);\r\nfree_netdev(netdev);\r\n}\r\nstatic void eth_configure(int n, void *init, char *mac,\r\nstruct transport *transport, gfp_t gfp_mask)\r\n{\r\nstruct uml_net *device;\r\nstruct net_device *dev;\r\nstruct uml_net_private *lp;\r\nint err, size;\r\nsize = transport->private_size + sizeof(struct uml_net_private);\r\ndevice = kzalloc(sizeof(*device), gfp_mask);\r\nif (device == NULL) {\r\nprintk(KERN_ERR "eth_configure failed to allocate struct "\r\n"uml_net\n");\r\nreturn;\r\n}\r\ndev = alloc_etherdev(size);\r\nif (dev == NULL) {\r\nprintk(KERN_ERR "eth_configure: failed to allocate struct "\r\n"net_device for eth%d\n", n);\r\ngoto out_free_device;\r\n}\r\nINIT_LIST_HEAD(&device->list);\r\ndevice->index = n;\r\nsnprintf(dev->name, sizeof(dev->name), "eth%d", n);\r\nsetup_etheraddr(dev, mac);\r\nprintk(KERN_INFO "Netdevice %d (%pM) : ", n, dev->dev_addr);\r\nlp = netdev_priv(dev);\r\nmemset(lp, 0, size);\r\nINIT_WORK(&lp->work, uml_dev_close);\r\nif (!driver_registered) {\r\nplatform_driver_register(&uml_net_driver);\r\ndriver_registered = 1;\r\n}\r\ndevice->pdev.id = n;\r\ndevice->pdev.name = DRIVER_NAME;\r\ndevice->pdev.dev.release = net_device_release;\r\ndev_set_drvdata(&device->pdev.dev, device);\r\nif (platform_device_register(&device->pdev))\r\ngoto out_free_netdev;\r\nSET_NETDEV_DEV(dev,&device->pdev.dev);\r\ndevice->dev = dev;\r\n(*transport->kern->init)(dev, init);\r\n*lp = ((struct uml_net_private)\r\n{ .list = LIST_HEAD_INIT(lp->list),\r\n.dev = dev,\r\n.fd = -1,\r\n.mac = { 0xfe, 0xfd, 0x0, 0x0, 0x0, 0x0},\r\n.max_packet = transport->user->max_packet,\r\n.protocol = transport->kern->protocol,\r\n.open = transport->user->open,\r\n.close = transport->user->close,\r\n.remove = transport->user->remove,\r\n.read = transport->kern->read,\r\n.write = transport->kern->write,\r\n.add_address = transport->user->add_address,\r\n.delete_address = transport->user->delete_address });\r\ninit_timer(&lp->tl);\r\nspin_lock_init(&lp->lock);\r\nlp->tl.function = uml_net_user_timer_expire;\r\nmemcpy(lp->mac, dev->dev_addr, sizeof(lp->mac));\r\nif ((transport->user->init != NULL) &&\r\n((*transport->user->init)(&lp->user, dev) != 0))\r\ngoto out_unregister;\r\ndev->mtu = transport->user->mtu;\r\ndev->netdev_ops = &uml_netdev_ops;\r\ndev->ethtool_ops = &uml_net_ethtool_ops;\r\ndev->watchdog_timeo = (HZ >> 1);\r\ndev->irq = UM_ETH_IRQ;\r\nerr = update_drop_skb(lp->max_packet);\r\nif (err)\r\ngoto out_undo_user_init;\r\nrtnl_lock();\r\nerr = register_netdevice(dev);\r\nrtnl_unlock();\r\nif (err)\r\ngoto out_undo_user_init;\r\nspin_lock(&devices_lock);\r\nlist_add(&device->list, &devices);\r\nspin_unlock(&devices_lock);\r\nreturn;\r\nout_undo_user_init:\r\nif (transport->user->remove != NULL)\r\n(*transport->user->remove)(&lp->user);\r\nout_unregister:\r\nplatform_device_unregister(&device->pdev);\r\nreturn;\r\nout_free_netdev:\r\nfree_netdev(dev);\r\nout_free_device:\r\nkfree(device);\r\n}\r\nstatic struct uml_net *find_device(int n)\r\n{\r\nstruct uml_net *device;\r\nstruct list_head *ele;\r\nspin_lock(&devices_lock);\r\nlist_for_each(ele, &devices) {\r\ndevice = list_entry(ele, struct uml_net, list);\r\nif (device->index == n)\r\ngoto out;\r\n}\r\ndevice = NULL;\r\nout:\r\nspin_unlock(&devices_lock);\r\nreturn device;\r\n}\r\nstatic int eth_parse(char *str, int *index_out, char **str_out,\r\nchar **error_out)\r\n{\r\nchar *end;\r\nint n, err = -EINVAL;\r\nn = simple_strtoul(str, &end, 0);\r\nif (end == str) {\r\n*error_out = "Bad device number";\r\nreturn err;\r\n}\r\nstr = end;\r\nif (*str != '=') {\r\n*error_out = "Expected '=' after device number";\r\nreturn err;\r\n}\r\nstr++;\r\nif (find_device(n)) {\r\n*error_out = "Device already configured";\r\nreturn err;\r\n}\r\n*index_out = n;\r\n*str_out = str;\r\nreturn 0;\r\n}\r\nstatic int check_transport(struct transport *transport, char *eth, int n,\r\nvoid **init_out, char **mac_out, gfp_t gfp_mask)\r\n{\r\nint len;\r\nlen = strlen(transport->name);\r\nif (strncmp(eth, transport->name, len))\r\nreturn 0;\r\neth += len;\r\nif (*eth == ',')\r\neth++;\r\nelse if (*eth != '\0')\r\nreturn 0;\r\n*init_out = kmalloc(transport->setup_size, gfp_mask);\r\nif (*init_out == NULL)\r\nreturn 1;\r\nif (!transport->setup(eth, mac_out, *init_out)) {\r\nkfree(*init_out);\r\n*init_out = NULL;\r\n}\r\nreturn 1;\r\n}\r\nvoid register_transport(struct transport *new)\r\n{\r\nstruct list_head *ele, *next;\r\nstruct eth_init *eth;\r\nvoid *init;\r\nchar *mac = NULL;\r\nint match;\r\nspin_lock(&transports_lock);\r\nBUG_ON(!list_empty(&new->list));\r\nlist_add(&new->list, &transports);\r\nspin_unlock(&transports_lock);\r\nlist_for_each_safe(ele, next, &eth_cmd_line) {\r\neth = list_entry(ele, struct eth_init, list);\r\nmatch = check_transport(new, eth->init, eth->index, &init,\r\n&mac, GFP_KERNEL);\r\nif (!match)\r\ncontinue;\r\nelse if (init != NULL) {\r\neth_configure(eth->index, init, mac, new, GFP_KERNEL);\r\nkfree(init);\r\n}\r\nlist_del(&eth->list);\r\n}\r\n}\r\nstatic int eth_setup_common(char *str, int index)\r\n{\r\nstruct list_head *ele;\r\nstruct transport *transport;\r\nvoid *init;\r\nchar *mac = NULL;\r\nint found = 0;\r\nspin_lock(&transports_lock);\r\nlist_for_each(ele, &transports) {\r\ntransport = list_entry(ele, struct transport, list);\r\nif (!check_transport(transport, str, index, &init,\r\n&mac, GFP_ATOMIC))\r\ncontinue;\r\nif (init != NULL) {\r\neth_configure(index, init, mac, transport, GFP_ATOMIC);\r\nkfree(init);\r\n}\r\nfound = 1;\r\nbreak;\r\n}\r\nspin_unlock(&transports_lock);\r\nreturn found;\r\n}\r\nstatic int __init eth_setup(char *str)\r\n{\r\nstruct eth_init *new;\r\nchar *error;\r\nint n, err;\r\nerr = eth_parse(str, &n, &str, &error);\r\nif (err) {\r\nprintk(KERN_ERR "eth_setup - Couldn't parse '%s' : %s\n",\r\nstr, error);\r\nreturn 1;\r\n}\r\nnew = alloc_bootmem(sizeof(*new));\r\nINIT_LIST_HEAD(&new->list);\r\nnew->index = n;\r\nnew->init = str;\r\nlist_add_tail(&new->list, &eth_cmd_line);\r\nreturn 1;\r\n}\r\nstatic int net_config(char *str, char **error_out)\r\n{\r\nint n, err;\r\nerr = eth_parse(str, &n, &str, error_out);\r\nif (err)\r\nreturn err;\r\nstr = kstrdup(str, GFP_KERNEL);\r\nif (str == NULL) {\r\n*error_out = "net_config failed to strdup string";\r\nreturn -ENOMEM;\r\n}\r\nerr = !eth_setup_common(str, n);\r\nif (err)\r\nkfree(str);\r\nreturn err;\r\n}\r\nstatic int net_id(char **str, int *start_out, int *end_out)\r\n{\r\nchar *end;\r\nint n;\r\nn = simple_strtoul(*str, &end, 0);\r\nif ((*end != '\0') || (end == *str))\r\nreturn -1;\r\n*start_out = n;\r\n*end_out = n;\r\n*str = end;\r\nreturn n;\r\n}\r\nstatic int net_remove(int n, char **error_out)\r\n{\r\nstruct uml_net *device;\r\nstruct net_device *dev;\r\nstruct uml_net_private *lp;\r\ndevice = find_device(n);\r\nif (device == NULL)\r\nreturn -ENODEV;\r\ndev = device->dev;\r\nlp = netdev_priv(dev);\r\nif (lp->fd > 0)\r\nreturn -EBUSY;\r\nunregister_netdev(dev);\r\nplatform_device_unregister(&device->pdev);\r\nreturn 0;\r\n}\r\nstatic int uml_inetaddr_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct in_ifaddr *ifa = ptr;\r\nstruct net_device *dev = ifa->ifa_dev->dev;\r\nstruct uml_net_private *lp;\r\nvoid (*proc)(unsigned char *, unsigned char *, void *);\r\nunsigned char addr_buf[4], netmask_buf[4];\r\nif (dev->netdev_ops->ndo_open != uml_net_open)\r\nreturn NOTIFY_DONE;\r\nlp = netdev_priv(dev);\r\nproc = NULL;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nproc = lp->add_address;\r\nbreak;\r\ncase NETDEV_DOWN:\r\nproc = lp->delete_address;\r\nbreak;\r\n}\r\nif (proc != NULL) {\r\nmemcpy(addr_buf, &ifa->ifa_address, sizeof(addr_buf));\r\nmemcpy(netmask_buf, &ifa->ifa_mask, sizeof(netmask_buf));\r\n(*proc)(addr_buf, netmask_buf, &lp->user);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void inet_register(void)\r\n{\r\nstruct list_head *ele;\r\nstruct uml_net_private *lp;\r\nstruct in_device *ip;\r\nstruct in_ifaddr *in;\r\nregister_inetaddr_notifier(&uml_inetaddr_notifier);\r\nspin_lock(&opened_lock);\r\nlist_for_each(ele, &opened) {\r\nlp = list_entry(ele, struct uml_net_private, list);\r\nip = lp->dev->ip_ptr;\r\nif (ip == NULL)\r\ncontinue;\r\nin = ip->ifa_list;\r\nwhile (in != NULL) {\r\numl_inetaddr_event(NULL, NETDEV_UP, in);\r\nin = in->ifa_next;\r\n}\r\n}\r\nspin_unlock(&opened_lock);\r\n}\r\nstatic inline void inet_register(void)\r\n{\r\n}\r\nstatic int uml_net_init(void)\r\n{\r\nmconsole_register_dev(&net_mc);\r\ninet_register();\r\nreturn 0;\r\n}\r\nstatic void close_devices(void)\r\n{\r\nstruct list_head *ele;\r\nstruct uml_net_private *lp;\r\nspin_lock(&opened_lock);\r\nlist_for_each(ele, &opened) {\r\nlp = list_entry(ele, struct uml_net_private, list);\r\num_free_irq(lp->dev->irq, lp->dev);\r\nif ((lp->close != NULL) && (lp->fd >= 0))\r\n(*lp->close)(lp->fd, &lp->user);\r\nif (lp->remove != NULL)\r\n(*lp->remove)(&lp->user);\r\n}\r\nspin_unlock(&opened_lock);\r\n}\r\nvoid iter_addresses(void *d, void (*cb)(unsigned char *, unsigned char *,\r\nvoid *),\r\nvoid *arg)\r\n{\r\nstruct net_device *dev = d;\r\nstruct in_device *ip = dev->ip_ptr;\r\nstruct in_ifaddr *in;\r\nunsigned char address[4], netmask[4];\r\nif (ip == NULL) return;\r\nin = ip->ifa_list;\r\nwhile (in != NULL) {\r\nmemcpy(address, &in->ifa_address, sizeof(address));\r\nmemcpy(netmask, &in->ifa_mask, sizeof(netmask));\r\n(*cb)(address, netmask, arg);\r\nin = in->ifa_next;\r\n}\r\n}\r\nint dev_netmask(void *d, void *m)\r\n{\r\nstruct net_device *dev = d;\r\nstruct in_device *ip = dev->ip_ptr;\r\nstruct in_ifaddr *in;\r\n__be32 *mask_out = m;\r\nif (ip == NULL)\r\nreturn 1;\r\nin = ip->ifa_list;\r\nif (in == NULL)\r\nreturn 1;\r\n*mask_out = in->ifa_mask;\r\nreturn 0;\r\n}\r\nvoid *get_output_buffer(int *len_out)\r\n{\r\nvoid *ret;\r\nret = (void *) __get_free_pages(GFP_KERNEL, 0);\r\nif (ret) *len_out = PAGE_SIZE;\r\nelse *len_out = 0;\r\nreturn ret;\r\n}\r\nvoid free_output_buffer(void *buffer)\r\n{\r\nfree_pages((unsigned long) buffer, 0);\r\n}\r\nint tap_setup_common(char *str, char *type, char **dev_name, char **mac_out,\r\nchar **gate_addr)\r\n{\r\nchar *remain;\r\nremain = split_if_spec(str, dev_name, mac_out, gate_addr, NULL);\r\nif (remain != NULL) {\r\nprintk(KERN_ERR "tap_setup_common - Extra garbage on "\r\n"specification : '%s'\n", remain);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nunsigned short eth_protocol(struct sk_buff *skb)\r\n{\r\nreturn eth_type_trans(skb, skb->dev);\r\n}
