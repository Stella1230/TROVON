static u32 rk_tsadcv2_temp_to_code(struct chip_tsadc_table table,\r\nint temp)\r\n{\r\nint high, low, mid;\r\nlow = 0;\r\nhigh = table.length - 1;\r\nmid = (high + low) / 2;\r\nif (temp < table.id[low].temp || temp > table.id[high].temp)\r\nreturn 0;\r\nwhile (low <= high) {\r\nif (temp == table.id[mid].temp)\r\nreturn table.id[mid].code;\r\nelse if (temp < table.id[mid].temp)\r\nhigh = mid - 1;\r\nelse\r\nlow = mid + 1;\r\nmid = (low + high) / 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rk_tsadcv2_code_to_temp(struct chip_tsadc_table table, u32 code,\r\nint *temp)\r\n{\r\nunsigned int low = 1;\r\nunsigned int high = table.length - 1;\r\nunsigned int mid = (low + high) / 2;\r\nunsigned int num;\r\nunsigned long denom;\r\nWARN_ON(table.length < 2);\r\nswitch (table.mode) {\r\ncase ADC_DECREMENT:\r\ncode &= table.data_mask;\r\nif (code < table.id[high].code)\r\nreturn -EAGAIN;\r\nwhile (low <= high) {\r\nif (code >= table.id[mid].code &&\r\ncode < table.id[mid - 1].code)\r\nbreak;\r\nelse if (code < table.id[mid].code)\r\nlow = mid + 1;\r\nelse\r\nhigh = mid - 1;\r\nmid = (low + high) / 2;\r\n}\r\nbreak;\r\ncase ADC_INCREMENT:\r\ncode &= table.data_mask;\r\nif (code < table.id[low].code)\r\nreturn -EAGAIN;\r\nwhile (low <= high) {\r\nif (code <= table.id[mid].code &&\r\ncode > table.id[mid - 1].code)\r\nbreak;\r\nelse if (code > table.id[mid].code)\r\nlow = mid + 1;\r\nelse\r\nhigh = mid - 1;\r\nmid = (low + high) / 2;\r\n}\r\nbreak;\r\ndefault:\r\npr_err("Invalid the conversion table\n");\r\n}\r\nnum = table.id[mid].temp - table.id[mid - 1].temp;\r\nnum *= abs(table.id[mid - 1].code - code);\r\ndenom = abs(table.id[mid - 1].code - table.id[mid].code);\r\n*temp = table.id[mid - 1].temp + (num / denom);\r\nreturn 0;\r\n}\r\nstatic void rk_tsadcv2_initialize(struct regmap *grf, void __iomem *regs,\r\nenum tshut_polarity tshut_polarity)\r\n{\r\nif (tshut_polarity == TSHUT_HIGH_ACTIVE)\r\nwritel_relaxed(0U | TSADCV2_AUTO_TSHUT_POLARITY_HIGH,\r\nregs + TSADCV2_AUTO_CON);\r\nelse\r\nwritel_relaxed(0U & ~TSADCV2_AUTO_TSHUT_POLARITY_HIGH,\r\nregs + TSADCV2_AUTO_CON);\r\nwritel_relaxed(TSADCV2_AUTO_PERIOD_TIME, regs + TSADCV2_AUTO_PERIOD);\r\nwritel_relaxed(TSADCV2_HIGHT_INT_DEBOUNCE_COUNT,\r\nregs + TSADCV2_HIGHT_INT_DEBOUNCE);\r\nwritel_relaxed(TSADCV2_AUTO_PERIOD_HT_TIME,\r\nregs + TSADCV2_AUTO_PERIOD_HT);\r\nwritel_relaxed(TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT,\r\nregs + TSADCV2_HIGHT_TSHUT_DEBOUNCE);\r\nif (IS_ERR(grf)) {\r\npr_warn("%s: Missing rockchip,grf property\n", __func__);\r\nreturn;\r\n}\r\n}\r\nstatic void rk_tsadcv3_initialize(struct regmap *grf, void __iomem *regs,\r\nenum tshut_polarity tshut_polarity)\r\n{\r\nif (IS_ERR(grf)) {\r\nwritel_relaxed(TSADCV2_USER_INTER_PD_SOC, regs +\r\nTSADCV2_USER_CON);\r\n} else {\r\nregmap_write(grf, GRF_TSADC_TESTBIT_L, GRF_TSADC_TSEN_PD_ON);\r\nmdelay(10);\r\nregmap_write(grf, GRF_TSADC_TESTBIT_L, GRF_TSADC_TSEN_PD_OFF);\r\nusleep_range(15, 100);\r\nregmap_write(grf, GRF_SARADC_TESTBIT, GRF_SARADC_TESTBIT_ON);\r\nregmap_write(grf, GRF_TSADC_TESTBIT_H, GRF_TSADC_TESTBIT_H_ON);\r\nusleep_range(90, 200);\r\n}\r\nif (tshut_polarity == TSHUT_HIGH_ACTIVE)\r\nwritel_relaxed(0U | TSADCV2_AUTO_TSHUT_POLARITY_HIGH,\r\nregs + TSADCV2_AUTO_CON);\r\nelse\r\nwritel_relaxed(0U & ~TSADCV2_AUTO_TSHUT_POLARITY_HIGH,\r\nregs + TSADCV2_AUTO_CON);\r\nwritel_relaxed(TSADCV2_AUTO_PERIOD_TIME, regs + TSADCV2_AUTO_PERIOD);\r\nwritel_relaxed(TSADCV2_HIGHT_INT_DEBOUNCE_COUNT,\r\nregs + TSADCV2_HIGHT_INT_DEBOUNCE);\r\nwritel_relaxed(TSADCV2_AUTO_PERIOD_HT_TIME,\r\nregs + TSADCV2_AUTO_PERIOD_HT);\r\nwritel_relaxed(TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT,\r\nregs + TSADCV2_HIGHT_TSHUT_DEBOUNCE);\r\n}\r\nstatic void rk_tsadcv2_irq_ack(void __iomem *regs)\r\n{\r\nu32 val;\r\nval = readl_relaxed(regs + TSADCV2_INT_PD);\r\nwritel_relaxed(val & TSADCV2_INT_PD_CLEAR_MASK, regs + TSADCV2_INT_PD);\r\n}\r\nstatic void rk_tsadcv3_irq_ack(void __iomem *regs)\r\n{\r\nu32 val;\r\nval = readl_relaxed(regs + TSADCV2_INT_PD);\r\nwritel_relaxed(val & TSADCV3_INT_PD_CLEAR_MASK, regs + TSADCV2_INT_PD);\r\n}\r\nstatic void rk_tsadcv2_control(void __iomem *regs, bool enable)\r\n{\r\nu32 val;\r\nval = readl_relaxed(regs + TSADCV2_AUTO_CON);\r\nif (enable)\r\nval |= TSADCV2_AUTO_EN;\r\nelse\r\nval &= ~TSADCV2_AUTO_EN;\r\nwritel_relaxed(val, regs + TSADCV2_AUTO_CON);\r\n}\r\nstatic void rk_tsadcv3_control(void __iomem *regs, bool enable)\r\n{\r\nu32 val;\r\nval = readl_relaxed(regs + TSADCV2_AUTO_CON);\r\nif (enable)\r\nval |= TSADCV2_AUTO_EN | TSADCV3_AUTO_Q_SEL_EN;\r\nelse\r\nval &= ~TSADCV2_AUTO_EN;\r\nwritel_relaxed(val, regs + TSADCV2_AUTO_CON);\r\n}\r\nstatic int rk_tsadcv2_get_temp(struct chip_tsadc_table table,\r\nint chn, void __iomem *regs, int *temp)\r\n{\r\nu32 val;\r\nval = readl_relaxed(regs + TSADCV2_DATA(chn));\r\nreturn rk_tsadcv2_code_to_temp(table, val, temp);\r\n}\r\nstatic void rk_tsadcv2_tshut_temp(struct chip_tsadc_table table,\r\nint chn, void __iomem *regs, int temp)\r\n{\r\nu32 tshut_value, val;\r\ntshut_value = rk_tsadcv2_temp_to_code(table, temp);\r\nwritel_relaxed(tshut_value, regs + TSADCV2_COMP_SHUT(chn));\r\nval = readl_relaxed(regs + TSADCV2_AUTO_CON);\r\nwritel_relaxed(val | TSADCV2_AUTO_SRC_EN(chn), regs + TSADCV2_AUTO_CON);\r\n}\r\nstatic void rk_tsadcv2_tshut_mode(int chn, void __iomem *regs,\r\nenum tshut_mode mode)\r\n{\r\nu32 val;\r\nval = readl_relaxed(regs + TSADCV2_INT_EN);\r\nif (mode == TSHUT_MODE_GPIO) {\r\nval &= ~TSADCV2_SHUT_2CRU_SRC_EN(chn);\r\nval |= TSADCV2_SHUT_2GPIO_SRC_EN(chn);\r\n} else {\r\nval &= ~TSADCV2_SHUT_2GPIO_SRC_EN(chn);\r\nval |= TSADCV2_SHUT_2CRU_SRC_EN(chn);\r\n}\r\nwritel_relaxed(val, regs + TSADCV2_INT_EN);\r\n}\r\nstatic void\r\nrockchip_thermal_toggle_sensor(struct rockchip_thermal_sensor *sensor, bool on)\r\n{\r\nstruct thermal_zone_device *tzd = sensor->tzd;\r\ntzd->ops->set_mode(tzd,\r\non ? THERMAL_DEVICE_ENABLED : THERMAL_DEVICE_DISABLED);\r\n}\r\nstatic irqreturn_t rockchip_thermal_alarm_irq_thread(int irq, void *dev)\r\n{\r\nstruct rockchip_thermal_data *thermal = dev;\r\nint i;\r\ndev_dbg(&thermal->pdev->dev, "thermal alarm\n");\r\nthermal->chip->irq_ack(thermal->regs);\r\nfor (i = 0; i < thermal->chip->chn_num; i++)\r\nthermal_zone_device_update(thermal->sensors[i].tzd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rockchip_thermal_get_temp(void *_sensor, int *out_temp)\r\n{\r\nstruct rockchip_thermal_sensor *sensor = _sensor;\r\nstruct rockchip_thermal_data *thermal = sensor->thermal;\r\nconst struct rockchip_tsadc_chip *tsadc = sensor->thermal->chip;\r\nint retval;\r\nretval = tsadc->get_temp(tsadc->table,\r\nsensor->id, thermal->regs, out_temp);\r\ndev_dbg(&thermal->pdev->dev, "sensor %d - temp: %d, retval: %d\n",\r\nsensor->id, *out_temp, retval);\r\nreturn retval;\r\n}\r\nstatic int rockchip_configure_from_dt(struct device *dev,\r\nstruct device_node *np,\r\nstruct rockchip_thermal_data *thermal)\r\n{\r\nu32 shut_temp, tshut_mode, tshut_polarity;\r\nif (of_property_read_u32(np, "rockchip,hw-tshut-temp", &shut_temp)) {\r\ndev_warn(dev,\r\n"Missing tshut temp property, using default %d\n",\r\nthermal->chip->tshut_temp);\r\nthermal->tshut_temp = thermal->chip->tshut_temp;\r\n} else {\r\nif (shut_temp > INT_MAX) {\r\ndev_err(dev, "Invalid tshut temperature specified: %d\n",\r\nshut_temp);\r\nreturn -ERANGE;\r\n}\r\nthermal->tshut_temp = shut_temp;\r\n}\r\nif (of_property_read_u32(np, "rockchip,hw-tshut-mode", &tshut_mode)) {\r\ndev_warn(dev,\r\n"Missing tshut mode property, using default (%s)\n",\r\nthermal->chip->tshut_mode == TSHUT_MODE_GPIO ?\r\n"gpio" : "cru");\r\nthermal->tshut_mode = thermal->chip->tshut_mode;\r\n} else {\r\nthermal->tshut_mode = tshut_mode;\r\n}\r\nif (thermal->tshut_mode > 1) {\r\ndev_err(dev, "Invalid tshut mode specified: %d\n",\r\nthermal->tshut_mode);\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(np, "rockchip,hw-tshut-polarity",\r\n&tshut_polarity)) {\r\ndev_warn(dev,\r\n"Missing tshut-polarity property, using default (%s)\n",\r\nthermal->chip->tshut_polarity == TSHUT_LOW_ACTIVE ?\r\n"low" : "high");\r\nthermal->tshut_polarity = thermal->chip->tshut_polarity;\r\n} else {\r\nthermal->tshut_polarity = tshut_polarity;\r\n}\r\nif (thermal->tshut_polarity > 1) {\r\ndev_err(dev, "Invalid tshut-polarity specified: %d\n",\r\nthermal->tshut_polarity);\r\nreturn -EINVAL;\r\n}\r\nthermal->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");\r\nreturn 0;\r\n}\r\nstatic int\r\nrockchip_thermal_register_sensor(struct platform_device *pdev,\r\nstruct rockchip_thermal_data *thermal,\r\nstruct rockchip_thermal_sensor *sensor,\r\nint id)\r\n{\r\nconst struct rockchip_tsadc_chip *tsadc = thermal->chip;\r\nint error;\r\ntsadc->set_tshut_mode(id, thermal->regs, thermal->tshut_mode);\r\ntsadc->set_tshut_temp(tsadc->table, id, thermal->regs,\r\nthermal->tshut_temp);\r\nsensor->thermal = thermal;\r\nsensor->id = id;\r\nsensor->tzd = devm_thermal_zone_of_sensor_register(&pdev->dev, id,\r\nsensor, &rockchip_of_thermal_ops);\r\nif (IS_ERR(sensor->tzd)) {\r\nerror = PTR_ERR(sensor->tzd);\r\ndev_err(&pdev->dev, "failed to register sensor %d: %d\n",\r\nid, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rockchip_thermal_reset_controller(struct reset_control *reset)\r\n{\r\nreset_control_assert(reset);\r\nusleep_range(10, 20);\r\nreset_control_deassert(reset);\r\n}\r\nstatic int rockchip_thermal_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct rockchip_thermal_data *thermal;\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nint irq;\r\nint i;\r\nint error;\r\nmatch = of_match_node(of_rockchip_thermal_match, np);\r\nif (!match)\r\nreturn -ENXIO;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn -EINVAL;\r\n}\r\nthermal = devm_kzalloc(&pdev->dev, sizeof(struct rockchip_thermal_data),\r\nGFP_KERNEL);\r\nif (!thermal)\r\nreturn -ENOMEM;\r\nthermal->pdev = pdev;\r\nthermal->chip = (const struct rockchip_tsadc_chip *)match->data;\r\nif (!thermal->chip)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nthermal->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(thermal->regs))\r\nreturn PTR_ERR(thermal->regs);\r\nthermal->reset = devm_reset_control_get(&pdev->dev, "tsadc-apb");\r\nif (IS_ERR(thermal->reset)) {\r\nerror = PTR_ERR(thermal->reset);\r\ndev_err(&pdev->dev, "failed to get tsadc reset: %d\n", error);\r\nreturn error;\r\n}\r\nthermal->clk = devm_clk_get(&pdev->dev, "tsadc");\r\nif (IS_ERR(thermal->clk)) {\r\nerror = PTR_ERR(thermal->clk);\r\ndev_err(&pdev->dev, "failed to get tsadc clock: %d\n", error);\r\nreturn error;\r\n}\r\nthermal->pclk = devm_clk_get(&pdev->dev, "apb_pclk");\r\nif (IS_ERR(thermal->pclk)) {\r\nerror = PTR_ERR(thermal->pclk);\r\ndev_err(&pdev->dev, "failed to get apb_pclk clock: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = clk_prepare_enable(thermal->clk);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to enable converter clock: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = clk_prepare_enable(thermal->pclk);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to enable pclk: %d\n", error);\r\ngoto err_disable_clk;\r\n}\r\nrockchip_thermal_reset_controller(thermal->reset);\r\nerror = rockchip_configure_from_dt(&pdev->dev, np, thermal);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to parse device tree data: %d\n",\r\nerror);\r\ngoto err_disable_pclk;\r\n}\r\nthermal->chip->initialize(thermal->grf, thermal->regs,\r\nthermal->tshut_polarity);\r\nfor (i = 0; i < thermal->chip->chn_num; i++) {\r\nerror = rockchip_thermal_register_sensor(pdev, thermal,\r\n&thermal->sensors[i],\r\nthermal->chip->chn_id[i]);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"failed to register sensor[%d] : error = %d\n",\r\ni, error);\r\ngoto err_disable_pclk;\r\n}\r\n}\r\nerror = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\n&rockchip_thermal_alarm_irq_thread,\r\nIRQF_ONESHOT,\r\n"rockchip_thermal", thermal);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"failed to request tsadc irq: %d\n", error);\r\ngoto err_disable_pclk;\r\n}\r\nthermal->chip->control(thermal->regs, true);\r\nfor (i = 0; i < thermal->chip->chn_num; i++)\r\nrockchip_thermal_toggle_sensor(&thermal->sensors[i], true);\r\nplatform_set_drvdata(pdev, thermal);\r\nreturn 0;\r\nerr_disable_pclk:\r\nclk_disable_unprepare(thermal->pclk);\r\nerr_disable_clk:\r\nclk_disable_unprepare(thermal->clk);\r\nreturn error;\r\n}\r\nstatic int rockchip_thermal_remove(struct platform_device *pdev)\r\n{\r\nstruct rockchip_thermal_data *thermal = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < thermal->chip->chn_num; i++) {\r\nstruct rockchip_thermal_sensor *sensor = &thermal->sensors[i];\r\nrockchip_thermal_toggle_sensor(sensor, false);\r\n}\r\nthermal->chip->control(thermal->regs, false);\r\nclk_disable_unprepare(thermal->pclk);\r\nclk_disable_unprepare(thermal->clk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rockchip_thermal_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rockchip_thermal_data *thermal = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < thermal->chip->chn_num; i++)\r\nrockchip_thermal_toggle_sensor(&thermal->sensors[i], false);\r\nthermal->chip->control(thermal->regs, false);\r\nclk_disable(thermal->pclk);\r\nclk_disable(thermal->clk);\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rockchip_thermal_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rockchip_thermal_data *thermal = platform_get_drvdata(pdev);\r\nint i;\r\nint error;\r\nerror = clk_enable(thermal->clk);\r\nif (error)\r\nreturn error;\r\nerror = clk_enable(thermal->pclk);\r\nif (error) {\r\nclk_disable(thermal->clk);\r\nreturn error;\r\n}\r\nrockchip_thermal_reset_controller(thermal->reset);\r\nthermal->chip->initialize(thermal->grf, thermal->regs,\r\nthermal->tshut_polarity);\r\nfor (i = 0; i < thermal->chip->chn_num; i++) {\r\nint id = thermal->sensors[i].id;\r\nthermal->chip->set_tshut_mode(id, thermal->regs,\r\nthermal->tshut_mode);\r\nthermal->chip->set_tshut_temp(thermal->chip->table,\r\nid, thermal->regs,\r\nthermal->tshut_temp);\r\n}\r\nthermal->chip->control(thermal->regs, true);\r\nfor (i = 0; i < thermal->chip->chn_num; i++)\r\nrockchip_thermal_toggle_sensor(&thermal->sensors[i], true);\r\npinctrl_pm_select_default_state(dev);\r\nreturn 0;\r\n}
