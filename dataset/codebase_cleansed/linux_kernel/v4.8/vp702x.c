static int vp702x_usb_in_op_unlocked(struct dvb_usb_device *d, u8 req,\r\nu16 value, u16 index, u8 *b, int blen)\r\n{\r\nint ret;\r\nret = usb_control_msg(d->udev,\r\nusb_rcvctrlpipe(d->udev, 0),\r\nreq,\r\nUSB_TYPE_VENDOR | USB_DIR_IN,\r\nvalue, index, b, blen,\r\n2000);\r\nif (ret < 0) {\r\nwarn("usb in operation failed. (%d)", ret);\r\nret = -EIO;\r\n} else\r\nret = 0;\r\ndeb_xfer("in: req. %02x, val: %04x, ind: %04x, buffer: ",req,value,index);\r\ndebug_dump(b,blen,deb_xfer);\r\nreturn ret;\r\n}\r\nint vp702x_usb_in_op(struct dvb_usb_device *d, u8 req, u16 value,\r\nu16 index, u8 *b, int blen)\r\n{\r\nint ret;\r\nmutex_lock(&d->usb_mutex);\r\nret = vp702x_usb_in_op_unlocked(d, req, value, index, b, blen);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int vp702x_usb_out_op_unlocked(struct dvb_usb_device *d, u8 req,\r\nu16 value, u16 index, u8 *b, int blen)\r\n{\r\nint ret;\r\ndeb_xfer("out: req. %02x, val: %04x, ind: %04x, buffer: ",req,value,index);\r\ndebug_dump(b,blen,deb_xfer);\r\nif ((ret = usb_control_msg(d->udev,\r\nusb_sndctrlpipe(d->udev,0),\r\nreq,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\nvalue,index,b,blen,\r\n2000)) != blen) {\r\nwarn("usb out operation failed. (%d)",ret);\r\nreturn -EIO;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int vp702x_usb_out_op(struct dvb_usb_device *d, u8 req, u16 value,\r\nu16 index, u8 *b, int blen)\r\n{\r\nint ret;\r\nmutex_lock(&d->usb_mutex);\r\nret = vp702x_usb_out_op_unlocked(d, req, value, index, b, blen);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nint vp702x_usb_inout_op(struct dvb_usb_device *d, u8 *o, int olen, u8 *i, int ilen, int msec)\r\n{\r\nint ret;\r\nif ((ret = mutex_lock_interruptible(&d->usb_mutex)))\r\nreturn ret;\r\nret = vp702x_usb_out_op_unlocked(d, REQUEST_OUT, 0, 0, o, olen);\r\nmsleep(msec);\r\nret = vp702x_usb_in_op_unlocked(d, REQUEST_IN, 0, 0, i, ilen);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int vp702x_usb_inout_cmd(struct dvb_usb_device *d, u8 cmd, u8 *o,\r\nint olen, u8 *i, int ilen, int msec)\r\n{\r\nstruct vp702x_device_state *st = d->priv;\r\nint ret = 0;\r\nu8 *buf;\r\nint buflen = max(olen + 2, ilen + 1);\r\nret = mutex_lock_interruptible(&st->buf_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nif (buflen > st->buf_len) {\r\nbuf = kmalloc(buflen, GFP_KERNEL);\r\nif (!buf) {\r\nmutex_unlock(&st->buf_mutex);\r\nreturn -ENOMEM;\r\n}\r\ninfo("successfully reallocated a bigger buffer");\r\nkfree(st->buf);\r\nst->buf = buf;\r\nst->buf_len = buflen;\r\n} else {\r\nbuf = st->buf;\r\n}\r\nbuf[0] = 0x00;\r\nbuf[1] = cmd;\r\nmemcpy(&buf[2], o, olen);\r\nret = vp702x_usb_inout_op(d, buf, olen+2, buf, ilen+1, msec);\r\nif (ret == 0)\r\nmemcpy(i, &buf[1], ilen);\r\nmutex_unlock(&st->buf_mutex);\r\nreturn ret;\r\n}\r\nstatic int vp702x_set_pld_mode(struct dvb_usb_adapter *adap, u8 bypass)\r\n{\r\nint ret;\r\nstruct vp702x_device_state *st = adap->dev->priv;\r\nu8 *buf;\r\nmutex_lock(&st->buf_mutex);\r\nbuf = st->buf;\r\nmemset(buf, 0, 16);\r\nret = vp702x_usb_in_op(adap->dev, 0xe0, (bypass << 8) | 0x0e,\r\n0, buf, 16);\r\nmutex_unlock(&st->buf_mutex);\r\nreturn ret;\r\n}\r\nstatic int vp702x_set_pld_state(struct dvb_usb_adapter *adap, u8 state)\r\n{\r\nint ret;\r\nstruct vp702x_device_state *st = adap->dev->priv;\r\nu8 *buf;\r\nmutex_lock(&st->buf_mutex);\r\nbuf = st->buf;\r\nmemset(buf, 0, 16);\r\nret = vp702x_usb_in_op(adap->dev, 0xe0, (state << 8) | 0x0f,\r\n0, buf, 16);\r\nmutex_unlock(&st->buf_mutex);\r\nreturn ret;\r\n}\r\nstatic int vp702x_set_pid(struct dvb_usb_adapter *adap, u16 pid, u8 id, int onoff)\r\n{\r\nstruct vp702x_adapter_state *st = adap->priv;\r\nstruct vp702x_device_state *dst = adap->dev->priv;\r\nu8 *buf;\r\nif (onoff)\r\nst->pid_filter_state |= (1 << id);\r\nelse {\r\nst->pid_filter_state &= ~(1 << id);\r\npid = 0xffff;\r\n}\r\nid = 0x10 + id*2;\r\nvp702x_set_pld_state(adap, st->pid_filter_state);\r\nmutex_lock(&dst->buf_mutex);\r\nbuf = dst->buf;\r\nmemset(buf, 0, 16);\r\nvp702x_usb_in_op(adap->dev, 0xe0, (((pid >> 8) & 0xff) << 8) | (id), 0, buf, 16);\r\nvp702x_usb_in_op(adap->dev, 0xe0, (((pid ) & 0xff) << 8) | (id+1), 0, buf, 16);\r\nmutex_unlock(&dst->buf_mutex);\r\nreturn 0;\r\n}\r\nstatic int vp702x_init_pid_filter(struct dvb_usb_adapter *adap)\r\n{\r\nstruct vp702x_adapter_state *st = adap->priv;\r\nstruct vp702x_device_state *dst = adap->dev->priv;\r\nint i;\r\nu8 *b;\r\nst->pid_filter_count = 8;\r\nst->pid_filter_can_bypass = 1;\r\nst->pid_filter_state = 0x00;\r\nvp702x_set_pld_mode(adap, 1);\r\nfor (i = 0; i < st->pid_filter_count; i++)\r\nvp702x_set_pid(adap, 0xffff, i, 1);\r\nmutex_lock(&dst->buf_mutex);\r\nb = dst->buf;\r\nmemset(b, 0, 10);\r\nvp702x_usb_in_op(adap->dev, 0xb5, 3, 0, b, 10);\r\nvp702x_usb_in_op(adap->dev, 0xb5, 0, 0, b, 10);\r\nvp702x_usb_in_op(adap->dev, 0xb5, 1, 0, b, 10);\r\nmutex_unlock(&dst->buf_mutex);\r\nreturn 0;\r\n}\r\nstatic int vp702x_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vp702x_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\n#if 0\r\nu8 *key;\r\nint i;\r\nkey = kmalloc(10, GFP_KERNEL);\r\nif (!key)\r\nreturn -ENOMEM;\r\nvp702x_usb_in_op(d,READ_REMOTE_REQ,0,0,key,10);\r\ndeb_rc("remote query key: %x %d\n",key[1],key[1]);\r\nif (key[1] == 0x44) {\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nkfree(key);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(rc_map_vp702x_table); i++)\r\nif (rc5_custom(&rc_map_vp702x_table[i]) == key[1]) {\r\n*state = REMOTE_KEY_PRESSED;\r\n*event = rc_map_vp702x_table[i].keycode;\r\nbreak;\r\n}\r\nkfree(key);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int vp702x_read_mac_addr(struct dvb_usb_device *d,u8 mac[6])\r\n{\r\nu8 i, *buf;\r\nstruct vp702x_device_state *st = d->priv;\r\nmutex_lock(&st->buf_mutex);\r\nbuf = st->buf;\r\nfor (i = 6; i < 12; i++)\r\nvp702x_usb_in_op(d, READ_EEPROM_REQ, i, 1, &buf[i - 6], 1);\r\nmemcpy(mac, buf, 6);\r\nmutex_unlock(&st->buf_mutex);\r\nreturn 0;\r\n}\r\nstatic int vp702x_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nu8 buf[10] = { 0 };\r\nvp702x_usb_out_op(adap->dev, SET_TUNER_POWER_REQ, 0, 7, NULL, 0);\r\nif (vp702x_usb_inout_cmd(adap->dev, GET_SYSTEM_STRING, NULL, 0,\r\nbuf, 10, 10))\r\nreturn -EIO;\r\nbuf[9] = '\0';\r\ninfo("system string: %s",&buf[1]);\r\nvp702x_init_pid_filter(adap);\r\nadap->fe_adap[0].fe = vp702x_fe_attach(adap->dev);\r\nvp702x_usb_out_op(adap->dev, SET_TUNER_POWER_REQ, 1, 7, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic int vp702x_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct dvb_usb_device *d;\r\nstruct vp702x_device_state *st;\r\nint ret;\r\nret = dvb_usb_device_init(intf, &vp702x_properties,\r\nTHIS_MODULE, &d, adapter_nr);\r\nif (ret)\r\ngoto out;\r\nst = d->priv;\r\nst->buf_len = 16;\r\nst->buf = kmalloc(st->buf_len, GFP_KERNEL);\r\nif (!st->buf) {\r\nret = -ENOMEM;\r\ndvb_usb_device_exit(intf);\r\ngoto out;\r\n}\r\nmutex_init(&st->buf_mutex);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void vp702x_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\nstruct vp702x_device_state *st = d->priv;\r\nmutex_lock(&st->buf_mutex);\r\nkfree(st->buf);\r\nmutex_unlock(&st->buf_mutex);\r\ndvb_usb_device_exit(intf);\r\n}
