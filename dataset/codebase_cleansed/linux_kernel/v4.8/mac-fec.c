static int whack_reset(struct fec __iomem *fecp)\r\n{\r\nint i;\r\nFW(fecp, ecntrl, FEC_ECNTRL_PINMUX | FEC_ECNTRL_RESET);\r\nfor (i = 0; i < FEC_RESET_DELAY; i++) {\r\nif ((FR(fecp, ecntrl) & FEC_ECNTRL_RESET) == 0)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic int do_pd_setup(struct fs_enet_private *fep)\r\n{\r\nstruct platform_device *ofdev = to_platform_device(fep->dev);\r\nfep->interrupt = irq_of_parse_and_map(ofdev->dev.of_node, 0);\r\nif (fep->interrupt == NO_IRQ)\r\nreturn -EINVAL;\r\nfep->fec.fecp = of_iomap(ofdev->dev.of_node, 0);\r\nif (!fep->fcc.fccp)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int setup_data(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nif (do_pd_setup(fep) != 0)\r\nreturn -EINVAL;\r\nfep->fec.hthi = 0;\r\nfep->fec.htlo = 0;\r\nfep->ev_napi_rx = FEC_NAPI_RX_EVENT_MSK;\r\nfep->ev_napi_tx = FEC_NAPI_TX_EVENT_MSK;\r\nfep->ev_rx = FEC_RX_EVENT;\r\nfep->ev_tx = FEC_TX_EVENT;\r\nfep->ev_err = FEC_ERR_EVENT_MSK;\r\nreturn 0;\r\n}\r\nstatic int allocate_bd(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nfep->ring_base = (void __force __iomem *)dma_alloc_coherent(fep->dev,\r\n(fpi->tx_ring + fpi->rx_ring) *\r\nsizeof(cbd_t), &fep->ring_mem_addr,\r\nGFP_KERNEL);\r\nif (fep->ring_base == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void free_bd(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nif(fep->ring_base)\r\ndma_free_coherent(fep->dev, (fpi->tx_ring + fpi->rx_ring)\r\n* sizeof(cbd_t),\r\n(void __force *)fep->ring_base,\r\nfep->ring_mem_addr);\r\n}\r\nstatic void cleanup_data(struct net_device *dev)\r\n{\r\n}\r\nstatic void set_promiscuous_mode(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nFS(fecp, r_cntrl, FEC_RCNTRL_PROM);\r\n}\r\nstatic void set_multicast_start(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfep->fec.hthi = 0;\r\nfep->fec.htlo = 0;\r\n}\r\nstatic void set_multicast_one(struct net_device *dev, const u8 *mac)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nint temp, hash_index, i, j;\r\nu32 crc, csrVal;\r\nu8 byte, msb;\r\ncrc = 0xffffffff;\r\nfor (i = 0; i < 6; i++) {\r\nbyte = mac[i];\r\nfor (j = 0; j < 8; j++) {\r\nmsb = crc >> 31;\r\ncrc <<= 1;\r\nif (msb ^ (byte & 0x1))\r\ncrc ^= FEC_CRC_POLY;\r\nbyte >>= 1;\r\n}\r\n}\r\ntemp = (crc & 0x3f) >> 1;\r\nhash_index = ((temp & 0x01) << 4) |\r\n((temp & 0x02) << 2) |\r\n((temp & 0x04)) |\r\n((temp & 0x08) >> 2) |\r\n((temp & 0x10) >> 4);\r\ncsrVal = 1 << hash_index;\r\nif (crc & 1)\r\nfep->fec.hthi |= csrVal;\r\nelse\r\nfep->fec.htlo |= csrVal;\r\n}\r\nstatic void set_multicast_finish(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nif ((dev->flags & IFF_ALLMULTI) != 0 ||\r\nnetdev_mc_count(dev) > FEC_MAX_MULTICAST_ADDRS) {\r\nfep->fec.hthi = 0xffffffffU;\r\nfep->fec.htlo = 0xffffffffU;\r\n}\r\nFC(fecp, r_cntrl, FEC_RCNTRL_PROM);\r\nFW(fecp, grp_hash_table_high, fep->fec.hthi);\r\nFW(fecp, grp_hash_table_low, fep->fec.htlo);\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nif ((dev->flags & IFF_PROMISC) == 0) {\r\nset_multicast_start(dev);\r\nnetdev_for_each_mc_addr(ha, dev)\r\nset_multicast_one(dev, ha->addr);\r\nset_multicast_finish(dev);\r\n} else\r\nset_promiscuous_mode(dev);\r\n}\r\nstatic void restart(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\ndma_addr_t rx_bd_base_phys, tx_bd_base_phys;\r\nint r;\r\nu32 addrhi, addrlo;\r\nstruct mii_bus *mii = dev->phydev->mdio.bus;\r\nstruct fec_info* fec_inf = mii->priv;\r\nr = whack_reset(fep->fec.fecp);\r\nif (r != 0)\r\ndev_err(fep->dev, "FEC Reset FAILED!\n");\r\naddrhi = ((u32) dev->dev_addr[0] << 24) |\r\n((u32) dev->dev_addr[1] << 16) |\r\n((u32) dev->dev_addr[2] << 8) |\r\n(u32) dev->dev_addr[3];\r\naddrlo = ((u32) dev->dev_addr[4] << 24) |\r\n((u32) dev->dev_addr[5] << 16);\r\nFW(fecp, addr_low, addrhi);\r\nFW(fecp, addr_high, addrlo);\r\nFW(fecp, grp_hash_table_high, fep->fec.hthi);\r\nFW(fecp, grp_hash_table_low, fep->fec.htlo);\r\nFW(fecp, r_buff_size, PKT_MAXBLR_SIZE);\r\n#ifdef CONFIG_FS_ENET_MPC5121_FEC\r\nFW(fecp, r_cntrl, PKT_MAXBUF_SIZE << 16);\r\n#else\r\nFW(fecp, r_hash, PKT_MAXBUF_SIZE);\r\n#endif\r\nrx_bd_base_phys = fep->ring_mem_addr;\r\ntx_bd_base_phys = rx_bd_base_phys + sizeof(cbd_t) * fpi->rx_ring;\r\nFW(fecp, r_des_start, rx_bd_base_phys);\r\nFW(fecp, x_des_start, tx_bd_base_phys);\r\nfs_init_bds(dev);\r\n#ifdef CONFIG_FS_ENET_MPC5121_FEC\r\nFS(fecp, dma_control, 0xC0000000);\r\n#else\r\nFW(fecp, fun_code, 0x78000000);\r\n#endif\r\nFW(fecp, mii_speed, fec_inf->mii_speed);\r\nFW(fecp, ievent, 0xffc0);\r\n#ifndef CONFIG_FS_ENET_MPC5121_FEC\r\nFW(fecp, ivec, (virq_to_hw(fep->interrupt) / 2) << 29);\r\nFW(fecp, r_cntrl, FEC_RCNTRL_MII_MODE);\r\n#else\r\nFS(fecp, r_cntrl, fpi->use_rmii ?\r\nFEC_RCNTRL_RMII_MODE : FEC_RCNTRL_MII_MODE);\r\n#endif\r\nif (dev->phydev->duplex) {\r\nFC(fecp, r_cntrl, FEC_RCNTRL_DRT);\r\nFS(fecp, x_cntrl, FEC_TCNTRL_FDEN);\r\n} else {\r\nFS(fecp, r_cntrl, FEC_RCNTRL_DRT);\r\nFC(fecp, x_cntrl, FEC_TCNTRL_FDEN);\r\n}\r\nset_multicast_list(dev);\r\nFW(fecp, imask, FEC_ENET_TXF | FEC_ENET_TXB |\r\nFEC_ENET_RXF | FEC_ENET_RXB);\r\nFW(fecp, ecntrl, FEC_ECNTRL_PINMUX | FEC_ECNTRL_ETHER_EN);\r\nFW(fecp, r_des_active, 0x01000000);\r\n}\r\nstatic void stop(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nstruct fec_info *feci = dev->phydev->mdio.bus->priv;\r\nint i;\r\nif ((FR(fecp, ecntrl) & FEC_ECNTRL_ETHER_EN) == 0)\r\nreturn;\r\nFW(fecp, x_cntrl, 0x01);\r\nfor (i = 0; ((FR(fecp, ievent) & 0x10000000) == 0) &&\r\ni < FEC_RESET_DELAY; i++)\r\nudelay(1);\r\nif (i == FEC_RESET_DELAY)\r\ndev_warn(fep->dev, "FEC timeout on graceful transmit stop\n");\r\nFW(fecp, imask, 0);\r\nFC(fecp, ecntrl, FEC_ECNTRL_ETHER_EN);\r\nfs_cleanup_bds(dev);\r\nif (fpi->has_phy) {\r\nFS(fecp, r_cntrl, fpi->use_rmii ?\r\nFEC_RCNTRL_RMII_MODE :\r\nFEC_RCNTRL_MII_MODE);\r\nFS(fecp, ecntrl, FEC_ECNTRL_PINMUX | FEC_ECNTRL_ETHER_EN);\r\nFW(fecp, ievent, FEC_ENET_MII);\r\nFW(fecp, mii_speed, feci->mii_speed);\r\n}\r\n}\r\nstatic void napi_clear_rx_event(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nFW(fecp, ievent, FEC_NAPI_RX_EVENT_MSK);\r\n}\r\nstatic void napi_enable_rx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nFS(fecp, imask, FEC_NAPI_RX_EVENT_MSK);\r\n}\r\nstatic void napi_disable_rx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nFC(fecp, imask, FEC_NAPI_RX_EVENT_MSK);\r\n}\r\nstatic void napi_clear_tx_event(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nFW(fecp, ievent, FEC_NAPI_TX_EVENT_MSK);\r\n}\r\nstatic void napi_enable_tx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nFS(fecp, imask, FEC_NAPI_TX_EVENT_MSK);\r\n}\r\nstatic void napi_disable_tx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nFC(fecp, imask, FEC_NAPI_TX_EVENT_MSK);\r\n}\r\nstatic void rx_bd_done(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nFW(fecp, r_des_active, 0x01000000);\r\n}\r\nstatic void tx_kickstart(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nFW(fecp, x_des_active, 0x01000000);\r\n}\r\nstatic u32 get_int_events(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nreturn FR(fecp, ievent) & FR(fecp, imask);\r\n}\r\nstatic void clear_int_events(struct net_device *dev, u32 int_events)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nstruct fec __iomem *fecp = fep->fec.fecp;\r\nFW(fecp, ievent, int_events);\r\n}\r\nstatic void ev_error(struct net_device *dev, u32 int_events)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\ndev_warn(fep->dev, "FEC ERROR(s) 0x%x\n", int_events);\r\n}\r\nstatic int get_regs(struct net_device *dev, void *p, int *sizep)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nif (*sizep < sizeof(struct fec))\r\nreturn -EINVAL;\r\nmemcpy_fromio(p, fep->fec.fecp, sizeof(struct fec));\r\nreturn 0;\r\n}\r\nstatic int get_regs_len(struct net_device *dev)\r\n{\r\nreturn sizeof(struct fec);\r\n}\r\nstatic void tx_restart(struct net_device *dev)\r\n{\r\n}
