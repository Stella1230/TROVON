static struct ktd2692_context *fled_cdev_to_led(\r\nstruct led_classdev_flash *fled_cdev)\r\n{\r\nreturn container_of(fled_cdev, struct ktd2692_context, fled_cdev);\r\n}\r\nstatic void ktd2692_expresswire_start(struct ktd2692_context *led)\r\n{\r\ngpiod_direction_output(led->ctrl_gpio, KTD2692_HIGH);\r\nudelay(KTD2692_TIME_DATA_START_TIME_US);\r\n}\r\nstatic void ktd2692_expresswire_reset(struct ktd2692_context *led)\r\n{\r\ngpiod_direction_output(led->ctrl_gpio, KTD2692_LOW);\r\nudelay(KTD2692_TIME_RESET_US);\r\n}\r\nstatic void ktd2692_expresswire_end(struct ktd2692_context *led)\r\n{\r\ngpiod_direction_output(led->ctrl_gpio, KTD2692_LOW);\r\nudelay(KTD2692_TIME_LOW_END_OF_DATA_US);\r\ngpiod_direction_output(led->ctrl_gpio, KTD2692_HIGH);\r\nudelay(KTD2692_TIME_HIGH_END_OF_DATA_US);\r\n}\r\nstatic void ktd2692_expresswire_set_bit(struct ktd2692_context *led, bool bit)\r\n{\r\nif (bit) {\r\ngpiod_direction_output(led->ctrl_gpio, KTD2692_LOW);\r\nudelay(KTD2692_TIME_SHORT_BITSET_US);\r\ngpiod_direction_output(led->ctrl_gpio, KTD2692_HIGH);\r\nudelay(KTD2692_TIME_LONG_BITSET_US);\r\n} else {\r\ngpiod_direction_output(led->ctrl_gpio, KTD2692_LOW);\r\nudelay(KTD2692_TIME_LONG_BITSET_US);\r\ngpiod_direction_output(led->ctrl_gpio, KTD2692_HIGH);\r\nudelay(KTD2692_TIME_SHORT_BITSET_US);\r\n}\r\n}\r\nstatic void ktd2692_expresswire_write(struct ktd2692_context *led, u8 value)\r\n{\r\nint i;\r\nktd2692_expresswire_start(led);\r\nfor (i = 7; i >= 0; i--)\r\nktd2692_expresswire_set_bit(led, value & BIT(i));\r\nktd2692_expresswire_end(led);\r\n}\r\nstatic int ktd2692_led_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\r\nstruct ktd2692_context *led = fled_cdev_to_led(fled_cdev);\r\nmutex_lock(&led->lock);\r\nif (brightness == LED_OFF) {\r\nled->mode = KTD2692_MODE_DISABLE;\r\ngpiod_direction_output(led->aux_gpio, KTD2692_LOW);\r\n} else {\r\nktd2692_expresswire_write(led, brightness |\r\nKTD2692_REG_MOVIE_CURRENT_BASE);\r\nled->mode = KTD2692_MODE_MOVIE;\r\n}\r\nktd2692_expresswire_write(led, led->mode | KTD2692_REG_MODE_BASE);\r\nmutex_unlock(&led->lock);\r\nreturn 0;\r\n}\r\nstatic int ktd2692_led_flash_strobe_set(struct led_classdev_flash *fled_cdev,\r\nbool state)\r\n{\r\nstruct ktd2692_context *led = fled_cdev_to_led(fled_cdev);\r\nstruct led_flash_setting *timeout = &fled_cdev->timeout;\r\nu32 flash_tm_reg;\r\nmutex_lock(&led->lock);\r\nif (state) {\r\nflash_tm_reg = GET_TIMEOUT_OFFSET(timeout->val, timeout->step);\r\nktd2692_expresswire_write(led, flash_tm_reg\r\n| KTD2692_REG_FLASH_TIMEOUT_BASE);\r\nled->mode = KTD2692_MODE_FLASH;\r\ngpiod_direction_output(led->aux_gpio, KTD2692_HIGH);\r\n} else {\r\nled->mode = KTD2692_MODE_DISABLE;\r\ngpiod_direction_output(led->aux_gpio, KTD2692_LOW);\r\n}\r\nktd2692_expresswire_write(led, led->mode | KTD2692_REG_MODE_BASE);\r\nfled_cdev->led_cdev.brightness = LED_OFF;\r\nled->mode = KTD2692_MODE_DISABLE;\r\nmutex_unlock(&led->lock);\r\nreturn 0;\r\n}\r\nstatic int ktd2692_led_flash_timeout_set(struct led_classdev_flash *fled_cdev,\r\nu32 timeout)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ktd2692_init_movie_current_max(struct ktd2692_led_config_data *cfg)\r\n{\r\nu32 offset, step;\r\nu32 movie_current_microamp;\r\noffset = KTD2692_MOVIE_MODE_CURRENT_LEVELS;\r\nstep = KTD2692_MM_TO_FL_RATIO(cfg->flash_max_microamp)\r\n/ KTD2692_MOVIE_MODE_CURRENT_LEVELS;\r\ndo {\r\nmovie_current_microamp = step * offset;\r\noffset--;\r\n} while ((movie_current_microamp > cfg->movie_max_microamp) &&\r\n(offset > 0));\r\ncfg->max_brightness = offset;\r\n}\r\nstatic void ktd2692_init_flash_timeout(struct led_classdev_flash *fled_cdev,\r\nstruct ktd2692_led_config_data *cfg)\r\n{\r\nstruct led_flash_setting *setting;\r\nsetting = &fled_cdev->timeout;\r\nsetting->min = KTD2692_FLASH_MODE_TIMEOUT_DISABLE;\r\nsetting->max = cfg->flash_max_timeout;\r\nsetting->step = cfg->flash_max_timeout\r\n/ (KTD2692_FLASH_MODE_TIMEOUT_LEVELS - 1);\r\nsetting->val = cfg->flash_max_timeout;\r\n}\r\nstatic void ktd2692_setup(struct ktd2692_context *led)\r\n{\r\nled->mode = KTD2692_MODE_DISABLE;\r\nktd2692_expresswire_reset(led);\r\ngpiod_direction_output(led->aux_gpio, KTD2692_LOW);\r\nktd2692_expresswire_write(led, (KTD2962_MM_MIN_CURR_THRESHOLD_SCALE - 1)\r\n| KTD2692_REG_MM_MIN_CURR_THRESHOLD_BASE);\r\nktd2692_expresswire_write(led, KTD2692_FLASH_MODE_CURR_PERCENT(45)\r\n| KTD2692_REG_FLASH_CURRENT_BASE);\r\n}\r\nstatic int ktd2692_parse_dt(struct ktd2692_context *led, struct device *dev,\r\nstruct ktd2692_led_config_data *cfg)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *child_node;\r\nint ret;\r\nif (!dev->of_node)\r\nreturn -ENXIO;\r\nled->ctrl_gpio = devm_gpiod_get(dev, "ctrl", GPIOD_ASIS);\r\nif (IS_ERR(led->ctrl_gpio)) {\r\nret = PTR_ERR(led->ctrl_gpio);\r\ndev_err(dev, "cannot get ctrl-gpios %d\n", ret);\r\nreturn ret;\r\n}\r\nled->aux_gpio = devm_gpiod_get(dev, "aux", GPIOD_ASIS);\r\nif (IS_ERR(led->aux_gpio)) {\r\nret = PTR_ERR(led->aux_gpio);\r\ndev_err(dev, "cannot get aux-gpios %d\n", ret);\r\nreturn ret;\r\n}\r\nled->regulator = devm_regulator_get(dev, "vin");\r\nif (IS_ERR(led->regulator))\r\nled->regulator = NULL;\r\nif (led->regulator) {\r\nret = regulator_enable(led->regulator);\r\nif (ret)\r\ndev_err(dev, "Failed to enable supply: %d\n", ret);\r\n}\r\nchild_node = of_get_next_available_child(np, NULL);\r\nif (!child_node) {\r\ndev_err(dev, "No DT child node found for connected LED.\n");\r\nreturn -EINVAL;\r\n}\r\nled->fled_cdev.led_cdev.name =\r\nof_get_property(child_node, "label", NULL) ? : child_node->name;\r\nret = of_property_read_u32(child_node, "led-max-microamp",\r\n&cfg->movie_max_microamp);\r\nif (ret) {\r\ndev_err(dev, "failed to parse led-max-microamp\n");\r\ngoto err_parse_dt;\r\n}\r\nret = of_property_read_u32(child_node, "flash-max-microamp",\r\n&cfg->flash_max_microamp);\r\nif (ret) {\r\ndev_err(dev, "failed to parse flash-max-microamp\n");\r\ngoto err_parse_dt;\r\n}\r\nret = of_property_read_u32(child_node, "flash-max-timeout-us",\r\n&cfg->flash_max_timeout);\r\nif (ret) {\r\ndev_err(dev, "failed to parse flash-max-timeout-us\n");\r\ngoto err_parse_dt;\r\n}\r\nerr_parse_dt:\r\nof_node_put(child_node);\r\nreturn ret;\r\n}\r\nstatic int ktd2692_probe(struct platform_device *pdev)\r\n{\r\nstruct ktd2692_context *led;\r\nstruct led_classdev *led_cdev;\r\nstruct led_classdev_flash *fled_cdev;\r\nstruct ktd2692_led_config_data led_cfg;\r\nint ret;\r\nled = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nfled_cdev = &led->fled_cdev;\r\nled_cdev = &fled_cdev->led_cdev;\r\nret = ktd2692_parse_dt(led, &pdev->dev, &led_cfg);\r\nif (ret)\r\nreturn ret;\r\nktd2692_init_flash_timeout(fled_cdev, &led_cfg);\r\nktd2692_init_movie_current_max(&led_cfg);\r\nfled_cdev->ops = &flash_ops;\r\nled_cdev->max_brightness = led_cfg.max_brightness;\r\nled_cdev->brightness_set_blocking = ktd2692_led_brightness_set;\r\nled_cdev->flags |= LED_CORE_SUSPENDRESUME | LED_DEV_CAP_FLASH;\r\nmutex_init(&led->lock);\r\nplatform_set_drvdata(pdev, led);\r\nret = led_classdev_flash_register(&pdev->dev, fled_cdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't register LED %s\n", led_cdev->name);\r\nmutex_destroy(&led->lock);\r\nreturn ret;\r\n}\r\nktd2692_setup(led);\r\nreturn 0;\r\n}\r\nstatic int ktd2692_remove(struct platform_device *pdev)\r\n{\r\nstruct ktd2692_context *led = platform_get_drvdata(pdev);\r\nint ret;\r\nled_classdev_flash_unregister(&led->fled_cdev);\r\nif (led->regulator) {\r\nret = regulator_disable(led->regulator);\r\nif (ret)\r\ndev_err(&pdev->dev,\r\n"Failed to disable supply: %d\n", ret);\r\n}\r\nmutex_destroy(&led->lock);\r\nreturn 0;\r\n}
