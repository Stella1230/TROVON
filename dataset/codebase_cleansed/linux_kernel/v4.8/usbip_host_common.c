static int32_t read_attr_usbip_status(struct usbip_usb_device *udev)\r\n{\r\nchar status_attr_path[SYSFS_PATH_MAX];\r\nint fd;\r\nint length;\r\nchar status;\r\nint value = 0;\r\nsnprintf(status_attr_path, SYSFS_PATH_MAX, "%s/usbip_status",\r\nudev->path);\r\nfd = open(status_attr_path, O_RDONLY);\r\nif (fd < 0) {\r\nerr("error opening attribute %s", status_attr_path);\r\nreturn -1;\r\n}\r\nlength = read(fd, &status, 1);\r\nif (length < 0) {\r\nerr("error reading attribute %s", status_attr_path);\r\nclose(fd);\r\nreturn -1;\r\n}\r\nvalue = atoi(&status);\r\nreturn value;\r\n}\r\nstatic\r\nstruct usbip_exported_device *usbip_exported_device_new(\r\nstruct usbip_host_driver *hdriver, const char *sdevpath)\r\n{\r\nstruct usbip_exported_device *edev = NULL;\r\nstruct usbip_exported_device *edev_old;\r\nsize_t size;\r\nint i;\r\nedev = calloc(1, sizeof(struct usbip_exported_device));\r\nedev->sudev =\r\nudev_device_new_from_syspath(udev_context, sdevpath);\r\nif (!edev->sudev) {\r\nerr("udev_device_new_from_syspath: %s", sdevpath);\r\ngoto err;\r\n}\r\nif (hdriver->ops.read_device(edev->sudev, &edev->udev) < 0)\r\ngoto err;\r\nedev->status = read_attr_usbip_status(&edev->udev);\r\nif (edev->status < 0)\r\ngoto err;\r\nsize = sizeof(struct usbip_exported_device) +\r\nedev->udev.bNumInterfaces * sizeof(struct usbip_usb_interface);\r\nedev_old = edev;\r\nedev = realloc(edev, size);\r\nif (!edev) {\r\nedev = edev_old;\r\ndbg("realloc failed");\r\ngoto err;\r\n}\r\nfor (i = 0; i < edev->udev.bNumInterfaces; i++) {\r\nif (!hdriver->ops.read_interface)\r\nbreak;\r\nhdriver->ops.read_interface(&edev->udev, i, &edev->uinf[i]);\r\n}\r\nreturn edev;\r\nerr:\r\nif (edev->sudev)\r\nudev_device_unref(edev->sudev);\r\nif (edev)\r\nfree(edev);\r\nreturn NULL;\r\n}\r\nstatic int refresh_exported_devices(struct usbip_host_driver *hdriver)\r\n{\r\nstruct usbip_exported_device *edev;\r\nstruct udev_enumerate *enumerate;\r\nstruct udev_list_entry *devices, *dev_list_entry;\r\nstruct udev_device *dev;\r\nconst char *path;\r\nenumerate = udev_enumerate_new(udev_context);\r\nudev_enumerate_add_match_subsystem(enumerate, hdriver->udev_subsystem);\r\nudev_enumerate_scan_devices(enumerate);\r\ndevices = udev_enumerate_get_list_entry(enumerate);\r\nudev_list_entry_foreach(dev_list_entry, devices) {\r\npath = udev_list_entry_get_name(dev_list_entry);\r\ndev = udev_device_new_from_syspath(udev_context,\r\npath);\r\nif (dev == NULL)\r\ncontinue;\r\nif (hdriver->ops.is_my_device(dev)) {\r\nedev = usbip_exported_device_new(hdriver, path);\r\nif (!edev) {\r\ndbg("usbip_exported_device_new failed");\r\ncontinue;\r\n}\r\nlist_add(&edev->node, &hdriver->edev_list);\r\nhdriver->ndevs++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void usbip_exported_device_destroy(struct list_head *devs)\r\n{\r\nstruct list_head *i, *tmp;\r\nstruct usbip_exported_device *edev;\r\nlist_for_each_safe(i, tmp, devs) {\r\nedev = list_entry(i, struct usbip_exported_device, node);\r\nlist_del(i);\r\nfree(edev);\r\n}\r\n}\r\nint usbip_generic_driver_open(struct usbip_host_driver *hdriver)\r\n{\r\nint rc;\r\nudev_context = udev_new();\r\nif (!udev_context) {\r\nerr("udev_new failed");\r\nreturn -1;\r\n}\r\nrc = refresh_exported_devices(hdriver);\r\nif (rc < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nudev_unref(udev_context);\r\nreturn -1;\r\n}\r\nvoid usbip_generic_driver_close(struct usbip_host_driver *hdriver)\r\n{\r\nif (!hdriver)\r\nreturn;\r\nusbip_exported_device_destroy(&hdriver->edev_list);\r\nudev_unref(udev_context);\r\n}\r\nint usbip_generic_refresh_device_list(struct usbip_host_driver *hdriver)\r\n{\r\nint rc;\r\nusbip_exported_device_destroy(&hdriver->edev_list);\r\nhdriver->ndevs = 0;\r\nINIT_LIST_HEAD(&hdriver->edev_list);\r\nrc = refresh_exported_devices(hdriver);\r\nif (rc < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint usbip_export_device(struct usbip_exported_device *edev, int sockfd)\r\n{\r\nchar attr_name[] = "usbip_sockfd";\r\nchar sockfd_attr_path[SYSFS_PATH_MAX];\r\nchar sockfd_buff[30];\r\nint ret;\r\nif (edev->status != SDEV_ST_AVAILABLE) {\r\ndbg("device not available: %s", edev->udev.busid);\r\nswitch (edev->status) {\r\ncase SDEV_ST_ERROR:\r\ndbg("status SDEV_ST_ERROR");\r\nbreak;\r\ncase SDEV_ST_USED:\r\ndbg("status SDEV_ST_USED");\r\nbreak;\r\ndefault:\r\ndbg("status unknown: 0x%x", edev->status);\r\n}\r\nreturn -1;\r\n}\r\nsnprintf(sockfd_attr_path, sizeof(sockfd_attr_path), "%s/%s",\r\nedev->udev.path, attr_name);\r\nsnprintf(sockfd_buff, sizeof(sockfd_buff), "%d\n", sockfd);\r\nret = write_sysfs_attribute(sockfd_attr_path, sockfd_buff,\r\nstrlen(sockfd_buff));\r\nif (ret < 0) {\r\nerr("write_sysfs_attribute failed: sockfd %s to %s",\r\nsockfd_buff, sockfd_attr_path);\r\nreturn ret;\r\n}\r\ninfo("connect: %s", edev->udev.busid);\r\nreturn ret;\r\n}\r\nstruct usbip_exported_device *usbip_generic_get_device(\r\nstruct usbip_host_driver *hdriver, int num)\r\n{\r\nstruct list_head *i;\r\nstruct usbip_exported_device *edev;\r\nint cnt = 0;\r\nlist_for_each(i, &hdriver->edev_list) {\r\nedev = list_entry(i, struct usbip_exported_device, node);\r\nif (num == cnt)\r\nreturn edev;\r\ncnt++;\r\n}\r\nreturn NULL;\r\n}
