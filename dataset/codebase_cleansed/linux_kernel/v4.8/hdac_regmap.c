static int codec_pm_lock(struct hdac_device *codec)\r\n{\r\nreturn snd_hdac_keep_power_up(codec);\r\n}\r\nstatic void codec_pm_unlock(struct hdac_device *codec, int lock)\r\n{\r\nif (lock == 1)\r\nsnd_hdac_power_down_pm(codec);\r\n}\r\nstatic bool hda_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nstruct hdac_device *codec = dev_to_hdac_dev(dev);\r\nunsigned int verb = get_verb(reg);\r\nswitch (verb) {\r\ncase AC_VERB_GET_PROC_COEF:\r\nreturn !codec->cache_coef;\r\ncase AC_VERB_GET_COEF_INDEX:\r\ncase AC_VERB_GET_PROC_STATE:\r\ncase AC_VERB_GET_POWER_STATE:\r\ncase AC_VERB_GET_PIN_SENSE:\r\ncase AC_VERB_GET_HDMI_DIP_SIZE:\r\ncase AC_VERB_GET_HDMI_ELDD:\r\ncase AC_VERB_GET_HDMI_DIP_INDEX:\r\ncase AC_VERB_GET_HDMI_DIP_DATA:\r\ncase AC_VERB_GET_HDMI_DIP_XMIT:\r\ncase AC_VERB_GET_HDMI_CP_CTRL:\r\ncase AC_VERB_GET_HDMI_CHAN_SLOT:\r\ncase AC_VERB_GET_DEVICE_SEL:\r\ncase AC_VERB_GET_DEVICE_LIST:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool hda_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nstruct hdac_device *codec = dev_to_hdac_dev(dev);\r\nunsigned int verb = get_verb(reg);\r\nint i;\r\nfor (i = 0; i < codec->vendor_verbs.used; i++) {\r\nunsigned int *v = snd_array_elem(&codec->vendor_verbs, i);\r\nif (verb == *v)\r\nreturn true;\r\n}\r\nif (codec->caps_overwriting)\r\nreturn true;\r\nswitch (verb & 0xf00) {\r\ncase AC_VERB_GET_STREAM_FORMAT:\r\ncase AC_VERB_GET_AMP_GAIN_MUTE:\r\nreturn true;\r\ncase AC_VERB_GET_PROC_COEF:\r\nreturn codec->cache_coef;\r\ncase 0xf00:\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nswitch (verb) {\r\ncase AC_VERB_GET_CONNECT_SEL:\r\ncase AC_VERB_GET_SDI_SELECT:\r\ncase AC_VERB_GET_PIN_WIDGET_CONTROL:\r\ncase AC_VERB_GET_UNSOLICITED_RESPONSE:\r\ncase AC_VERB_GET_BEEP_CONTROL:\r\ncase AC_VERB_GET_EAPD_BTLENABLE:\r\ncase AC_VERB_GET_DIGI_CONVERT_1:\r\ncase AC_VERB_GET_DIGI_CONVERT_2:\r\ncase AC_VERB_GET_VOLUME_KNOB_CONTROL:\r\ncase AC_VERB_GET_GPIO_MASK:\r\ncase AC_VERB_GET_GPIO_DIRECTION:\r\ncase AC_VERB_GET_GPIO_DATA:\r\ncase AC_VERB_GET_GPIO_WAKE_MASK:\r\ncase AC_VERB_GET_GPIO_UNSOLICITED_RSP_MASK:\r\ncase AC_VERB_GET_GPIO_STICKY_MASK:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool hda_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nstruct hdac_device *codec = dev_to_hdac_dev(dev);\r\nunsigned int verb = get_verb(reg);\r\nif (codec->caps_overwriting)\r\nreturn true;\r\nswitch (verb) {\r\ncase AC_VERB_PARAMETERS:\r\ncase AC_VERB_GET_CONNECT_LIST:\r\ncase AC_VERB_GET_SUBSYSTEM_ID:\r\nreturn true;\r\ncase AC_VERB_GET_CONFIG_DEFAULT:\r\ncase AC_VERB_GET_CONV:\r\ncase AC_VERB_GET_CVT_CHAN_COUNT:\r\nreturn true;\r\n}\r\nreturn hda_writeable_reg(dev, reg);\r\n}\r\nstatic bool is_stereo_amp_verb(unsigned int reg)\r\n{\r\nif (((reg >> 8) & 0x700) != AC_VERB_SET_AMP_GAIN_MUTE)\r\nreturn false;\r\nreturn (reg & (AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT)) ==\r\n(AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT);\r\n}\r\nstatic int hda_reg_read_stereo_amp(struct hdac_device *codec,\r\nunsigned int reg, unsigned int *val)\r\n{\r\nunsigned int left, right;\r\nint err;\r\nreg &= ~(AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT);\r\nerr = snd_hdac_exec_verb(codec, reg | AC_AMP_GET_LEFT, 0, &left);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hdac_exec_verb(codec, reg | AC_AMP_GET_RIGHT, 0, &right);\r\nif (err < 0)\r\nreturn err;\r\n*val = left | (right << 8);\r\nreturn 0;\r\n}\r\nstatic int hda_reg_write_stereo_amp(struct hdac_device *codec,\r\nunsigned int reg, unsigned int val)\r\n{\r\nint err;\r\nunsigned int verb, left, right;\r\nverb = AC_VERB_SET_AMP_GAIN_MUTE << 8;\r\nif (reg & AC_AMP_GET_OUTPUT)\r\nverb |= AC_AMP_SET_OUTPUT;\r\nelse\r\nverb |= AC_AMP_SET_INPUT | ((reg & 0xf) << 8);\r\nreg = (reg & ~0xfffff) | verb;\r\nleft = val & 0xff;\r\nright = (val >> 8) & 0xff;\r\nif (left == right) {\r\nreg |= AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT;\r\nreturn snd_hdac_exec_verb(codec, reg | left, 0, NULL);\r\n}\r\nerr = snd_hdac_exec_verb(codec, reg | AC_AMP_SET_LEFT | left, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hdac_exec_verb(codec, reg | AC_AMP_SET_RIGHT | right, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int hda_reg_read_coef(struct hdac_device *codec, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nunsigned int verb;\r\nint err;\r\nif (!codec->cache_coef)\r\nreturn -EINVAL;\r\nverb = (reg & ~0xfff00) | (AC_VERB_SET_COEF_INDEX << 8);\r\nerr = snd_hdac_exec_verb(codec, verb, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nverb = (reg & ~0xfffff) | (AC_VERB_GET_COEF_INDEX << 8);\r\nreturn snd_hdac_exec_verb(codec, verb, 0, val);\r\n}\r\nstatic int hda_reg_write_coef(struct hdac_device *codec, unsigned int reg,\r\nunsigned int val)\r\n{\r\nunsigned int verb;\r\nint err;\r\nif (!codec->cache_coef)\r\nreturn -EINVAL;\r\nverb = (reg & ~0xfff00) | (AC_VERB_SET_COEF_INDEX << 8);\r\nerr = snd_hdac_exec_verb(codec, verb, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nverb = (reg & ~0xfffff) | (AC_VERB_GET_COEF_INDEX << 8) |\r\n(val & 0xffff);\r\nreturn snd_hdac_exec_verb(codec, verb, 0, NULL);\r\n}\r\nstatic int hda_reg_read(void *context, unsigned int reg, unsigned int *val)\r\n{\r\nstruct hdac_device *codec = context;\r\nint verb = get_verb(reg);\r\nint err;\r\nint pm_lock = 0;\r\nif (verb != AC_VERB_GET_POWER_STATE) {\r\npm_lock = codec_pm_lock(codec);\r\nif (pm_lock < 0)\r\nreturn -EAGAIN;\r\n}\r\nreg |= (codec->addr << 28);\r\nif (is_stereo_amp_verb(reg)) {\r\nerr = hda_reg_read_stereo_amp(codec, reg, val);\r\ngoto out;\r\n}\r\nif (verb == AC_VERB_GET_PROC_COEF) {\r\nerr = hda_reg_read_coef(codec, reg, val);\r\ngoto out;\r\n}\r\nif ((verb & 0x700) == AC_VERB_SET_AMP_GAIN_MUTE)\r\nreg &= ~AC_AMP_FAKE_MUTE;\r\nerr = snd_hdac_exec_verb(codec, reg, 0, val);\r\nif (err < 0)\r\ngoto out;\r\nif (verb == AC_VERB_GET_POWER_STATE) {\r\nif (*val & AC_PWRST_ERROR)\r\n*val = -1;\r\nelse\r\n*val = (*val >> 4) & 0x0f;\r\n}\r\nout:\r\ncodec_pm_unlock(codec, pm_lock);\r\nreturn err;\r\n}\r\nstatic int hda_reg_write(void *context, unsigned int reg, unsigned int val)\r\n{\r\nstruct hdac_device *codec = context;\r\nunsigned int verb;\r\nint i, bytes, err;\r\nint pm_lock = 0;\r\nif (codec->caps_overwriting)\r\nreturn 0;\r\nreg &= ~0x00080000U;\r\nreg |= (codec->addr << 28);\r\nverb = get_verb(reg);\r\nif (verb != AC_VERB_SET_POWER_STATE) {\r\npm_lock = codec_pm_lock(codec);\r\nif (pm_lock < 0)\r\nreturn codec->lazy_cache ? 0 : -EAGAIN;\r\n}\r\nif (is_stereo_amp_verb(reg)) {\r\nerr = hda_reg_write_stereo_amp(codec, reg, val);\r\ngoto out;\r\n}\r\nif (verb == AC_VERB_SET_PROC_COEF) {\r\nerr = hda_reg_write_coef(codec, reg, val);\r\ngoto out;\r\n}\r\nswitch (verb & 0xf00) {\r\ncase AC_VERB_SET_AMP_GAIN_MUTE:\r\nif ((reg & AC_AMP_FAKE_MUTE) && (val & AC_AMP_MUTE))\r\nval = 0;\r\nverb = AC_VERB_SET_AMP_GAIN_MUTE;\r\nif (reg & AC_AMP_GET_LEFT)\r\nverb |= AC_AMP_SET_LEFT >> 8;\r\nelse\r\nverb |= AC_AMP_SET_RIGHT >> 8;\r\nif (reg & AC_AMP_GET_OUTPUT) {\r\nverb |= AC_AMP_SET_OUTPUT >> 8;\r\n} else {\r\nverb |= AC_AMP_SET_INPUT >> 8;\r\nverb |= reg & 0xf;\r\n}\r\nbreak;\r\n}\r\nswitch (verb) {\r\ncase AC_VERB_SET_DIGI_CONVERT_1:\r\nbytes = 2;\r\nbreak;\r\ncase AC_VERB_SET_CONFIG_DEFAULT_BYTES_0:\r\nbytes = 4;\r\nbreak;\r\ndefault:\r\nbytes = 1;\r\nbreak;\r\n}\r\nfor (i = 0; i < bytes; i++) {\r\nreg &= ~0xfffff;\r\nreg |= (verb + i) << 8 | ((val >> (8 * i)) & 0xff);\r\nerr = snd_hdac_exec_verb(codec, reg, 0, NULL);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nout:\r\ncodec_pm_unlock(codec, pm_lock);\r\nreturn err;\r\n}\r\nint snd_hdac_regmap_init(struct hdac_device *codec)\r\n{\r\nstruct regmap *regmap;\r\nregmap = regmap_init(&codec->dev, NULL, codec, &hda_regmap_cfg);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\ncodec->regmap = regmap;\r\nsnd_array_init(&codec->vendor_verbs, sizeof(unsigned int), 8);\r\nreturn 0;\r\n}\r\nvoid snd_hdac_regmap_exit(struct hdac_device *codec)\r\n{\r\nif (codec->regmap) {\r\nregmap_exit(codec->regmap);\r\ncodec->regmap = NULL;\r\nsnd_array_free(&codec->vendor_verbs);\r\n}\r\n}\r\nint snd_hdac_regmap_add_vendor_verb(struct hdac_device *codec,\r\nunsigned int verb)\r\n{\r\nunsigned int *p = snd_array_new(&codec->vendor_verbs);\r\nif (!p)\r\nreturn -ENOMEM;\r\n*p = verb | 0x800;\r\nreturn 0;\r\n}\r\nstatic int reg_raw_write(struct hdac_device *codec, unsigned int reg,\r\nunsigned int val)\r\n{\r\nif (!codec->regmap)\r\nreturn hda_reg_write(codec, reg, val);\r\nelse\r\nreturn regmap_write(codec->regmap, reg, val);\r\n}\r\nint snd_hdac_regmap_write_raw(struct hdac_device *codec, unsigned int reg,\r\nunsigned int val)\r\n{\r\nint err;\r\nerr = reg_raw_write(codec, reg, val);\r\nif (err == -EAGAIN) {\r\nerr = snd_hdac_power_up_pm(codec);\r\nif (err >= 0)\r\nerr = reg_raw_write(codec, reg, val);\r\nsnd_hdac_power_down_pm(codec);\r\n}\r\nreturn err;\r\n}\r\nstatic int reg_raw_read(struct hdac_device *codec, unsigned int reg,\r\nunsigned int *val, bool uncached)\r\n{\r\nif (uncached || !codec->regmap)\r\nreturn hda_reg_read(codec, reg, val);\r\nelse\r\nreturn regmap_read(codec->regmap, reg, val);\r\n}\r\nstatic int __snd_hdac_regmap_read_raw(struct hdac_device *codec,\r\nunsigned int reg, unsigned int *val,\r\nbool uncached)\r\n{\r\nint err;\r\nerr = reg_raw_read(codec, reg, val, uncached);\r\nif (err == -EAGAIN) {\r\nerr = snd_hdac_power_up_pm(codec);\r\nif (err >= 0)\r\nerr = reg_raw_read(codec, reg, val, uncached);\r\nsnd_hdac_power_down_pm(codec);\r\n}\r\nreturn err;\r\n}\r\nint snd_hdac_regmap_read_raw(struct hdac_device *codec, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nreturn __snd_hdac_regmap_read_raw(codec, reg, val, false);\r\n}\r\nint snd_hdac_regmap_read_raw_uncached(struct hdac_device *codec,\r\nunsigned int reg, unsigned int *val)\r\n{\r\nreturn __snd_hdac_regmap_read_raw(codec, reg, val, true);\r\n}\r\nint snd_hdac_regmap_update_raw(struct hdac_device *codec, unsigned int reg,\r\nunsigned int mask, unsigned int val)\r\n{\r\nunsigned int orig;\r\nint err;\r\nval &= mask;\r\nerr = snd_hdac_regmap_read_raw(codec, reg, &orig);\r\nif (err < 0)\r\nreturn err;\r\nval |= orig & ~mask;\r\nif (val == orig)\r\nreturn 0;\r\nerr = snd_hdac_regmap_write_raw(codec, reg, val);\r\nif (err < 0)\r\nreturn err;\r\nreturn 1;\r\n}
