static struct mtk_cpu_dvfs_info *mtk_cpu_dvfs_info_lookup(int cpu)\r\n{\r\nstruct mtk_cpu_dvfs_info *info;\r\nlist_for_each_entry(info, &dvfs_info_list, list_head) {\r\nif (cpumask_test_cpu(cpu, &info->cpus))\r\nreturn info;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int mtk_cpufreq_voltage_tracking(struct mtk_cpu_dvfs_info *info,\r\nint new_vproc)\r\n{\r\nstruct regulator *proc_reg = info->proc_reg;\r\nstruct regulator *sram_reg = info->sram_reg;\r\nint old_vproc, old_vsram, new_vsram, vsram, vproc, ret;\r\nold_vproc = regulator_get_voltage(proc_reg);\r\nif (old_vproc < 0) {\r\npr_err("%s: invalid Vproc value: %d\n", __func__, old_vproc);\r\nreturn old_vproc;\r\n}\r\nnew_vsram = min(new_vproc + MIN_VOLT_SHIFT, MAX_VOLT_LIMIT);\r\nif (old_vproc < new_vproc) {\r\ndo {\r\nold_vsram = regulator_get_voltage(sram_reg);\r\nif (old_vsram < 0) {\r\npr_err("%s: invalid Vsram value: %d\n",\r\n__func__, old_vsram);\r\nreturn old_vsram;\r\n}\r\nold_vproc = regulator_get_voltage(proc_reg);\r\nif (old_vproc < 0) {\r\npr_err("%s: invalid Vproc value: %d\n",\r\n__func__, old_vproc);\r\nreturn old_vproc;\r\n}\r\nvsram = min(new_vsram, old_vproc + MAX_VOLT_SHIFT);\r\nif (vsram + VOLT_TOL >= MAX_VOLT_LIMIT) {\r\nvsram = MAX_VOLT_LIMIT;\r\nret = regulator_set_voltage(sram_reg, vsram,\r\nvsram);\r\nif (ret)\r\nret = regulator_set_voltage(sram_reg,\r\nvsram - VOLT_TOL,\r\nvsram);\r\nvproc = new_vproc;\r\n} else {\r\nret = regulator_set_voltage(sram_reg, vsram,\r\nvsram + VOLT_TOL);\r\nvproc = vsram - MIN_VOLT_SHIFT;\r\n}\r\nif (ret)\r\nreturn ret;\r\nret = regulator_set_voltage(proc_reg, vproc,\r\nvproc + VOLT_TOL);\r\nif (ret) {\r\nregulator_set_voltage(sram_reg, old_vsram,\r\nold_vsram);\r\nreturn ret;\r\n}\r\n} while (vproc < new_vproc || vsram < new_vsram);\r\n} else if (old_vproc > new_vproc) {\r\ndo {\r\nold_vproc = regulator_get_voltage(proc_reg);\r\nif (old_vproc < 0) {\r\npr_err("%s: invalid Vproc value: %d\n",\r\n__func__, old_vproc);\r\nreturn old_vproc;\r\n}\r\nold_vsram = regulator_get_voltage(sram_reg);\r\nif (old_vsram < 0) {\r\npr_err("%s: invalid Vsram value: %d\n",\r\n__func__, old_vsram);\r\nreturn old_vsram;\r\n}\r\nvproc = max(new_vproc, old_vsram - MAX_VOLT_SHIFT);\r\nret = regulator_set_voltage(proc_reg, vproc,\r\nvproc + VOLT_TOL);\r\nif (ret)\r\nreturn ret;\r\nif (vproc == new_vproc)\r\nvsram = new_vsram;\r\nelse\r\nvsram = max(new_vsram, vproc + MIN_VOLT_SHIFT);\r\nif (vsram + VOLT_TOL >= MAX_VOLT_LIMIT) {\r\nvsram = MAX_VOLT_LIMIT;\r\nret = regulator_set_voltage(sram_reg, vsram,\r\nvsram);\r\nif (ret)\r\nret = regulator_set_voltage(sram_reg,\r\nvsram - VOLT_TOL,\r\nvsram);\r\n} else {\r\nret = regulator_set_voltage(sram_reg, vsram,\r\nvsram + VOLT_TOL);\r\n}\r\nif (ret) {\r\nregulator_set_voltage(proc_reg, old_vproc,\r\nold_vproc);\r\nreturn ret;\r\n}\r\n} while (vproc > new_vproc + VOLT_TOL ||\r\nvsram > new_vsram + VOLT_TOL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_cpufreq_set_voltage(struct mtk_cpu_dvfs_info *info, int vproc)\r\n{\r\nif (info->need_voltage_tracking)\r\nreturn mtk_cpufreq_voltage_tracking(info, vproc);\r\nelse\r\nreturn regulator_set_voltage(info->proc_reg, vproc,\r\nvproc + VOLT_TOL);\r\n}\r\nstatic int mtk_cpufreq_set_target(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nstruct cpufreq_frequency_table *freq_table = policy->freq_table;\r\nstruct clk *cpu_clk = policy->clk;\r\nstruct clk *armpll = clk_get_parent(cpu_clk);\r\nstruct mtk_cpu_dvfs_info *info = policy->driver_data;\r\nstruct device *cpu_dev = info->cpu_dev;\r\nstruct dev_pm_opp *opp;\r\nlong freq_hz, old_freq_hz;\r\nint vproc, old_vproc, inter_vproc, target_vproc, ret;\r\ninter_vproc = info->intermediate_voltage;\r\nold_freq_hz = clk_get_rate(cpu_clk);\r\nold_vproc = regulator_get_voltage(info->proc_reg);\r\nif (old_vproc < 0) {\r\npr_err("%s: invalid Vproc value: %d\n", __func__, old_vproc);\r\nreturn old_vproc;\r\n}\r\nfreq_hz = freq_table[index].frequency * 1000;\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_hz);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\npr_err("cpu%d: failed to find OPP for %ld\n",\r\npolicy->cpu, freq_hz);\r\nreturn PTR_ERR(opp);\r\n}\r\nvproc = dev_pm_opp_get_voltage(opp);\r\nrcu_read_unlock();\r\ntarget_vproc = (inter_vproc > vproc) ? inter_vproc : vproc;\r\nif (old_vproc < target_vproc) {\r\nret = mtk_cpufreq_set_voltage(info, target_vproc);\r\nif (ret) {\r\npr_err("cpu%d: failed to scale up voltage!\n",\r\npolicy->cpu);\r\nmtk_cpufreq_set_voltage(info, old_vproc);\r\nreturn ret;\r\n}\r\n}\r\nret = clk_set_parent(cpu_clk, info->inter_clk);\r\nif (ret) {\r\npr_err("cpu%d: failed to re-parent cpu clock!\n",\r\npolicy->cpu);\r\nmtk_cpufreq_set_voltage(info, old_vproc);\r\nWARN_ON(1);\r\nreturn ret;\r\n}\r\nret = clk_set_rate(armpll, freq_hz);\r\nif (ret) {\r\npr_err("cpu%d: failed to scale cpu clock rate!\n",\r\npolicy->cpu);\r\nclk_set_parent(cpu_clk, armpll);\r\nmtk_cpufreq_set_voltage(info, old_vproc);\r\nreturn ret;\r\n}\r\nret = clk_set_parent(cpu_clk, armpll);\r\nif (ret) {\r\npr_err("cpu%d: failed to re-parent cpu clock!\n",\r\npolicy->cpu);\r\nmtk_cpufreq_set_voltage(info, inter_vproc);\r\nWARN_ON(1);\r\nreturn ret;\r\n}\r\nif (vproc < inter_vproc || vproc < old_vproc) {\r\nret = mtk_cpufreq_set_voltage(info, vproc);\r\nif (ret) {\r\npr_err("cpu%d: failed to scale down voltage!\n",\r\npolicy->cpu);\r\nclk_set_parent(cpu_clk, info->inter_clk);\r\nclk_set_rate(armpll, old_freq_hz);\r\nclk_set_parent(cpu_clk, armpll);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mtk_cpufreq_ready(struct cpufreq_policy *policy)\r\n{\r\nstruct mtk_cpu_dvfs_info *info = policy->driver_data;\r\nstruct device_node *np = of_node_get(info->cpu_dev->of_node);\r\nu32 capacitance = 0;\r\nif (WARN_ON(!np))\r\nreturn;\r\nif (of_find_property(np, "#cooling-cells", NULL)) {\r\nof_property_read_u32(np, DYNAMIC_POWER, &capacitance);\r\ninfo->cdev = of_cpufreq_power_cooling_register(np,\r\npolicy->related_cpus,\r\ncapacitance,\r\nNULL);\r\nif (IS_ERR(info->cdev)) {\r\ndev_err(info->cpu_dev,\r\n"running cpufreq without cooling device: %ld\n",\r\nPTR_ERR(info->cdev));\r\ninfo->cdev = NULL;\r\n}\r\n}\r\nof_node_put(np);\r\n}\r\nstatic int mtk_cpu_dvfs_info_init(struct mtk_cpu_dvfs_info *info, int cpu)\r\n{\r\nstruct device *cpu_dev;\r\nstruct regulator *proc_reg = ERR_PTR(-ENODEV);\r\nstruct regulator *sram_reg = ERR_PTR(-ENODEV);\r\nstruct clk *cpu_clk = ERR_PTR(-ENODEV);\r\nstruct clk *inter_clk = ERR_PTR(-ENODEV);\r\nstruct dev_pm_opp *opp;\r\nunsigned long rate;\r\nint ret;\r\ncpu_dev = get_cpu_device(cpu);\r\nif (!cpu_dev) {\r\npr_err("failed to get cpu%d device\n", cpu);\r\nreturn -ENODEV;\r\n}\r\ncpu_clk = clk_get(cpu_dev, "cpu");\r\nif (IS_ERR(cpu_clk)) {\r\nif (PTR_ERR(cpu_clk) == -EPROBE_DEFER)\r\npr_warn("cpu clk for cpu%d not ready, retry.\n", cpu);\r\nelse\r\npr_err("failed to get cpu clk for cpu%d\n", cpu);\r\nret = PTR_ERR(cpu_clk);\r\nreturn ret;\r\n}\r\ninter_clk = clk_get(cpu_dev, "intermediate");\r\nif (IS_ERR(inter_clk)) {\r\nif (PTR_ERR(inter_clk) == -EPROBE_DEFER)\r\npr_warn("intermediate clk for cpu%d not ready, retry.\n",\r\ncpu);\r\nelse\r\npr_err("failed to get intermediate clk for cpu%d\n",\r\ncpu);\r\nret = PTR_ERR(inter_clk);\r\ngoto out_free_resources;\r\n}\r\nproc_reg = regulator_get_exclusive(cpu_dev, "proc");\r\nif (IS_ERR(proc_reg)) {\r\nif (PTR_ERR(proc_reg) == -EPROBE_DEFER)\r\npr_warn("proc regulator for cpu%d not ready, retry.\n",\r\ncpu);\r\nelse\r\npr_err("failed to get proc regulator for cpu%d\n",\r\ncpu);\r\nret = PTR_ERR(proc_reg);\r\ngoto out_free_resources;\r\n}\r\nsram_reg = regulator_get_exclusive(cpu_dev, "sram");\r\nret = dev_pm_opp_of_get_sharing_cpus(cpu_dev, &info->cpus);\r\nif (ret) {\r\npr_err("failed to get OPP-sharing information for cpu%d\n",\r\ncpu);\r\ngoto out_free_resources;\r\n}\r\nret = dev_pm_opp_of_cpumask_add_table(&info->cpus);\r\nif (ret) {\r\npr_warn("no OPP table for cpu%d\n", cpu);\r\ngoto out_free_resources;\r\n}\r\nrate = clk_get_rate(inter_clk);\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_ceil(cpu_dev, &rate);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\npr_err("failed to get intermediate opp for cpu%d\n", cpu);\r\nret = PTR_ERR(opp);\r\ngoto out_free_opp_table;\r\n}\r\ninfo->intermediate_voltage = dev_pm_opp_get_voltage(opp);\r\nrcu_read_unlock();\r\ninfo->cpu_dev = cpu_dev;\r\ninfo->proc_reg = proc_reg;\r\ninfo->sram_reg = IS_ERR(sram_reg) ? NULL : sram_reg;\r\ninfo->cpu_clk = cpu_clk;\r\ninfo->inter_clk = inter_clk;\r\ninfo->need_voltage_tracking = !IS_ERR(sram_reg);\r\nreturn 0;\r\nout_free_opp_table:\r\ndev_pm_opp_of_cpumask_remove_table(&info->cpus);\r\nout_free_resources:\r\nif (!IS_ERR(proc_reg))\r\nregulator_put(proc_reg);\r\nif (!IS_ERR(sram_reg))\r\nregulator_put(sram_reg);\r\nif (!IS_ERR(cpu_clk))\r\nclk_put(cpu_clk);\r\nif (!IS_ERR(inter_clk))\r\nclk_put(inter_clk);\r\nreturn ret;\r\n}\r\nstatic void mtk_cpu_dvfs_info_release(struct mtk_cpu_dvfs_info *info)\r\n{\r\nif (!IS_ERR(info->proc_reg))\r\nregulator_put(info->proc_reg);\r\nif (!IS_ERR(info->sram_reg))\r\nregulator_put(info->sram_reg);\r\nif (!IS_ERR(info->cpu_clk))\r\nclk_put(info->cpu_clk);\r\nif (!IS_ERR(info->inter_clk))\r\nclk_put(info->inter_clk);\r\ndev_pm_opp_of_cpumask_remove_table(&info->cpus);\r\n}\r\nstatic int mtk_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\nstruct mtk_cpu_dvfs_info *info;\r\nstruct cpufreq_frequency_table *freq_table;\r\nint ret;\r\ninfo = mtk_cpu_dvfs_info_lookup(policy->cpu);\r\nif (!info) {\r\npr_err("dvfs info for cpu%d is not initialized.\n",\r\npolicy->cpu);\r\nreturn -EINVAL;\r\n}\r\nret = dev_pm_opp_init_cpufreq_table(info->cpu_dev, &freq_table);\r\nif (ret) {\r\npr_err("failed to init cpufreq table for cpu%d: %d\n",\r\npolicy->cpu, ret);\r\nreturn ret;\r\n}\r\nret = cpufreq_table_validate_and_show(policy, freq_table);\r\nif (ret) {\r\npr_err("%s: invalid frequency table: %d\n", __func__, ret);\r\ngoto out_free_cpufreq_table;\r\n}\r\ncpumask_copy(policy->cpus, &info->cpus);\r\npolicy->driver_data = info;\r\npolicy->clk = info->cpu_clk;\r\nreturn 0;\r\nout_free_cpufreq_table:\r\ndev_pm_opp_free_cpufreq_table(info->cpu_dev, &freq_table);\r\nreturn ret;\r\n}\r\nstatic int mtk_cpufreq_exit(struct cpufreq_policy *policy)\r\n{\r\nstruct mtk_cpu_dvfs_info *info = policy->driver_data;\r\ncpufreq_cooling_unregister(info->cdev);\r\ndev_pm_opp_free_cpufreq_table(info->cpu_dev, &policy->freq_table);\r\nreturn 0;\r\n}\r\nstatic int mt8173_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct mtk_cpu_dvfs_info *info, *tmp;\r\nint cpu, ret;\r\nfor_each_possible_cpu(cpu) {\r\ninfo = mtk_cpu_dvfs_info_lookup(cpu);\r\nif (info)\r\ncontinue;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto release_dvfs_info_list;\r\n}\r\nret = mtk_cpu_dvfs_info_init(info, cpu);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"failed to initialize dvfs info for cpu%d\n",\r\ncpu);\r\ngoto release_dvfs_info_list;\r\n}\r\nlist_add(&info->list_head, &dvfs_info_list);\r\n}\r\nret = cpufreq_register_driver(&mt8173_cpufreq_driver);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register mtk cpufreq driver\n");\r\ngoto release_dvfs_info_list;\r\n}\r\nreturn 0;\r\nrelease_dvfs_info_list:\r\nlist_for_each_entry_safe(info, tmp, &dvfs_info_list, list_head) {\r\nmtk_cpu_dvfs_info_release(info);\r\nlist_del(&info->list_head);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt8173_cpufreq_driver_init(void)\r\n{\r\nstruct platform_device *pdev;\r\nint err;\r\nif (!of_machine_is_compatible("mediatek,mt8173"))\r\nreturn -ENODEV;\r\nerr = platform_driver_register(&mt8173_cpufreq_platdrv);\r\nif (err)\r\nreturn err;\r\npdev = platform_device_register_simple("mt8173-cpufreq", -1, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\npr_err("failed to register mtk-cpufreq platform device\n");\r\nreturn PTR_ERR(pdev);\r\n}\r\nreturn 0;\r\n}
