static int bcma_wait_bits(struct bcma_device *dev, u16 reg, u32 bitmask,\r\nint timeout)\r\n{\r\nint i;\r\nu32 val;\r\nfor (i = 0; i < timeout; i++) {\r\nval = bcma_read32(dev, reg);\r\nif ((val & bitmask) == bitmask)\r\nreturn 0;\r\nudelay(10);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void bcma_hcd_4716wa(struct bcma_device *dev)\r\n{\r\n#ifdef CONFIG_BCMA_DRIVER_MIPS\r\nif (dev->bus->chipinfo.id == 0x4716) {\r\nu32 tmp;\r\ntmp = bcma_cpu_clock(&dev->bus->drv_mips);\r\nif (tmp >= 480000000)\r\ntmp = 0x1846b;\r\nelse if (tmp == 453000000)\r\ntmp = 0x1046b;\r\nelse\r\ntmp = 0;\r\nif (tmp) {\r\nbcma_write32(dev, 0x524, 0x1);\r\nudelay(500);\r\nbcma_write32(dev, 0x524, tmp);\r\nudelay(500);\r\nbcma_write32(dev, 0x524, 0x4ab);\r\nudelay(500);\r\nbcma_read32(dev, 0x528);\r\nbcma_write32(dev, 0x528, 0x80000000);\r\n}\r\n}\r\n#endif\r\n}\r\nstatic void bcma_hcd_init_chip_mips(struct bcma_device *dev)\r\n{\r\nu32 tmp;\r\nif (!bcma_core_is_enabled(dev)) {\r\nbcma_core_enable(dev, 0);\r\nmdelay(10);\r\nif (dev->id.rev >= 5) {\r\ntmp = bcma_read32(dev, 0x1e0);\r\ntmp |= 0x100;\r\nbcma_write32(dev, 0x1e0, tmp);\r\nif (bcma_wait_bits(dev, 0x1e0, 1 << 24, 100))\r\nprintk(KERN_EMERG "Failed to enable misc PPL!\n");\r\nbcma_write32(dev, 0x200, 0x4ff);\r\nudelay(25);\r\nbcma_write32(dev, 0x200, 0x6ff);\r\nudelay(25);\r\nbcma_write32(dev, 0x524, 0x6b);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nudelay(50);\r\nbcma_write32(dev, 0x524, 0xab);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nudelay(50);\r\nbcma_write32(dev, 0x524, 0x2b);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nudelay(50);\r\nbcma_write32(dev, 0x524, 0x10ab);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nif (bcma_wait_bits(dev, 0x528, 0xc000, 10000)) {\r\ntmp = bcma_read32(dev, 0x528);\r\nprintk(KERN_EMERG\r\n"USB20H mdio_rddata 0x%08x\n", tmp);\r\n}\r\nbcma_write32(dev, 0x528, 0x80000000);\r\ntmp = bcma_read32(dev, 0x314);\r\nudelay(265);\r\nbcma_write32(dev, 0x200, 0x7ff);\r\nudelay(10);\r\nbcma_write32(dev, 0x510, 0);\r\n} else {\r\nbcma_write32(dev, 0x200, 0x7ff);\r\nudelay(1);\r\n}\r\nbcma_hcd_4716wa(dev);\r\n}\r\n}\r\nstatic void bcma_hcd_init_chip_arm_phy(struct bcma_device *dev)\r\n{\r\nstruct bcma_device *arm_core;\r\nvoid __iomem *dmu;\r\narm_core = bcma_find_core(dev->bus, BCMA_CORE_ARMCA9);\r\nif (!arm_core) {\r\ndev_err(&dev->dev, "can not find ARM Cortex A9 ihost core\n");\r\nreturn;\r\n}\r\ndmu = ioremap_nocache(arm_core->addr_s[0], 0x1000);\r\nif (!dmu) {\r\ndev_err(&dev->dev, "can not map ARM Cortex A9 ihost core\n");\r\nreturn;\r\n}\r\niowrite32(0x0000ea68, dmu + 0x180);\r\niowrite32(0x00dd10c3, dmu + 0x164);\r\niowrite32(0x00000000, dmu + 0x180);\r\niounmap(dmu);\r\n}\r\nstatic void bcma_hcd_init_chip_arm_hc(struct bcma_device *dev)\r\n{\r\nu32 val;\r\nusleep_range(1000, 2000);\r\nval = bcma_read32(dev, 0x94);\r\nval &= 0xffff;\r\nval |= 0x80 << 16;\r\nbcma_write32(dev, 0x94, val);\r\nval = bcma_read32(dev, 0x9c);\r\nval |= 1;\r\nbcma_write32(dev, 0x9c, val);\r\n}\r\nstatic void bcma_hcd_init_chip_arm(struct bcma_device *dev)\r\n{\r\nbcma_core_enable(dev, 0);\r\nif (dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM4707 ||\r\ndev->bus->chipinfo.id == BCMA_CHIP_ID_BCM53018) {\r\nif (dev->bus->chipinfo.pkg == BCMA_PKG_ID_BCM4707 ||\r\ndev->bus->chipinfo.pkg == BCMA_PKG_ID_BCM4708)\r\nbcma_hcd_init_chip_arm_phy(dev);\r\nbcma_hcd_init_chip_arm_hc(dev);\r\n}\r\n}\r\nstatic void bcma_hci_platform_power_gpio(struct bcma_device *dev, bool val)\r\n{\r\nstruct bcma_hcd_device *usb_dev = bcma_get_drvdata(dev);\r\nif (IS_ERR_OR_NULL(usb_dev->gpio_desc))\r\nreturn;\r\ngpiod_set_value(usb_dev->gpio_desc, val);\r\n}\r\nstatic struct platform_device *bcma_hcd_create_pdev(struct bcma_device *dev,\r\nconst char *name, u32 addr,\r\nconst void *data,\r\nsize_t size)\r\n{\r\nstruct platform_device *hci_dev;\r\nstruct resource hci_res[2];\r\nint ret;\r\nmemset(hci_res, 0, sizeof(hci_res));\r\nhci_res[0].start = addr;\r\nhci_res[0].end = hci_res[0].start + 0x1000 - 1;\r\nhci_res[0].flags = IORESOURCE_MEM;\r\nhci_res[1].start = dev->irq;\r\nhci_res[1].flags = IORESOURCE_IRQ;\r\nhci_dev = platform_device_alloc(name, 0);\r\nif (!hci_dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nhci_dev->dev.parent = &dev->dev;\r\nhci_dev->dev.dma_mask = &hci_dev->dev.coherent_dma_mask;\r\nret = platform_device_add_resources(hci_dev, hci_res,\r\nARRAY_SIZE(hci_res));\r\nif (ret)\r\ngoto err_alloc;\r\nif (data)\r\nret = platform_device_add_data(hci_dev, data, size);\r\nif (ret)\r\ngoto err_alloc;\r\nret = platform_device_add(hci_dev);\r\nif (ret)\r\ngoto err_alloc;\r\nreturn hci_dev;\r\nerr_alloc:\r\nplatform_device_put(hci_dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int bcma_hcd_usb20_init(struct bcma_hcd_device *usb_dev)\r\n{\r\nstruct bcma_device *dev = usb_dev->core;\r\nstruct bcma_chipinfo *chipinfo = &dev->bus->chipinfo;\r\nu32 ohci_addr;\r\nint err;\r\nif (dma_set_mask_and_coherent(dev->dma_dev, DMA_BIT_MASK(32)))\r\nreturn -EOPNOTSUPP;\r\nswitch (dev->id.id) {\r\ncase BCMA_CORE_NS_USB20:\r\nbcma_hcd_init_chip_arm(dev);\r\nbreak;\r\ncase BCMA_CORE_USB20_HOST:\r\nbcma_hcd_init_chip_mips(dev);\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nohci_addr = dev->addr_s[0];\r\nif ((chipinfo->id == BCMA_CHIP_ID_BCM5357 ||\r\nchipinfo->id == BCMA_CHIP_ID_BCM4749)\r\n&& chipinfo->rev == 0)\r\nohci_addr = 0x18009000;\r\nusb_dev->ohci_dev = bcma_hcd_create_pdev(dev, "ohci-platform",\r\nohci_addr, &ohci_pdata,\r\nsizeof(ohci_pdata));\r\nif (IS_ERR(usb_dev->ohci_dev))\r\nreturn PTR_ERR(usb_dev->ohci_dev);\r\nusb_dev->ehci_dev = bcma_hcd_create_pdev(dev, "ehci-platform",\r\ndev->addr, &ehci_pdata,\r\nsizeof(ehci_pdata));\r\nif (IS_ERR(usb_dev->ehci_dev)) {\r\nerr = PTR_ERR(usb_dev->ehci_dev);\r\ngoto err_unregister_ohci_dev;\r\n}\r\nreturn 0;\r\nerr_unregister_ohci_dev:\r\nplatform_device_unregister(usb_dev->ohci_dev);\r\nreturn err;\r\n}\r\nstatic int bcma_hcd_probe(struct bcma_device *core)\r\n{\r\nint err;\r\nstruct bcma_hcd_device *usb_dev;\r\nusb_dev = devm_kzalloc(&core->dev, sizeof(struct bcma_hcd_device),\r\nGFP_KERNEL);\r\nif (!usb_dev)\r\nreturn -ENOMEM;\r\nusb_dev->core = core;\r\nif (core->dev.of_node)\r\nusb_dev->gpio_desc = devm_gpiod_get(&core->dev, "vcc",\r\nGPIOD_OUT_HIGH);\r\nswitch (core->id.id) {\r\ncase BCMA_CORE_USB20_HOST:\r\ncase BCMA_CORE_NS_USB20:\r\nerr = bcma_hcd_usb20_init(usb_dev);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nbcma_set_drvdata(core, usb_dev);\r\nreturn 0;\r\n}\r\nstatic void bcma_hcd_remove(struct bcma_device *dev)\r\n{\r\nstruct bcma_hcd_device *usb_dev = bcma_get_drvdata(dev);\r\nstruct platform_device *ohci_dev = usb_dev->ohci_dev;\r\nstruct platform_device *ehci_dev = usb_dev->ehci_dev;\r\nif (ohci_dev)\r\nplatform_device_unregister(ohci_dev);\r\nif (ehci_dev)\r\nplatform_device_unregister(ehci_dev);\r\nbcma_core_disable(dev, 0);\r\n}\r\nstatic void bcma_hcd_shutdown(struct bcma_device *dev)\r\n{\r\nbcma_hci_platform_power_gpio(dev, false);\r\nbcma_core_disable(dev, 0);\r\n}\r\nstatic int bcma_hcd_suspend(struct bcma_device *dev)\r\n{\r\nbcma_hci_platform_power_gpio(dev, false);\r\nbcma_core_disable(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int bcma_hcd_resume(struct bcma_device *dev)\r\n{\r\nbcma_hci_platform_power_gpio(dev, true);\r\nbcma_core_enable(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int __init bcma_hcd_init(void)\r\n{\r\nreturn bcma_driver_register(&bcma_hcd_driver);\r\n}\r\nstatic void __exit bcma_hcd_exit(void)\r\n{\r\nbcma_driver_unregister(&bcma_hcd_driver);\r\n}
