static unsigned int\r\nlegacy_dvb_usb_get_keymap_index(const struct input_keymap_entry *ke,\r\nstruct rc_map_table *keymap,\r\nunsigned int keymap_size)\r\n{\r\nunsigned int index;\r\nunsigned int scancode;\r\nif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\r\nindex = ke->index;\r\n} else {\r\nif (input_scancode_to_scalar(ke, &scancode))\r\nreturn keymap_size;\r\nfor (index = 0; index < keymap_size; index++)\r\nif (keymap[index].scancode == scancode)\r\nbreak;\r\nif (index >= keymap_size) {\r\nfor (index = 0; index < keymap_size; index++) {\r\nif (keymap[index].keycode == KEY_RESERVED ||\r\nkeymap[index].keycode == KEY_UNKNOWN) {\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nreturn index;\r\n}\r\nstatic int legacy_dvb_usb_getkeycode(struct input_dev *dev,\r\nstruct input_keymap_entry *ke)\r\n{\r\nstruct dvb_usb_device *d = input_get_drvdata(dev);\r\nstruct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;\r\nunsigned int keymap_size = d->props.rc.legacy.rc_map_size;\r\nunsigned int index;\r\nindex = legacy_dvb_usb_get_keymap_index(ke, keymap, keymap_size);\r\nif (index >= keymap_size)\r\nreturn -EINVAL;\r\nke->keycode = keymap[index].keycode;\r\nif (ke->keycode == KEY_UNKNOWN)\r\nke->keycode = KEY_RESERVED;\r\nke->len = sizeof(keymap[index].scancode);\r\nmemcpy(&ke->scancode, &keymap[index].scancode, ke->len);\r\nke->index = index;\r\nreturn 0;\r\n}\r\nstatic int legacy_dvb_usb_setkeycode(struct input_dev *dev,\r\nconst struct input_keymap_entry *ke,\r\nunsigned int *old_keycode)\r\n{\r\nstruct dvb_usb_device *d = input_get_drvdata(dev);\r\nstruct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;\r\nunsigned int keymap_size = d->props.rc.legacy.rc_map_size;\r\nunsigned int index;\r\nindex = legacy_dvb_usb_get_keymap_index(ke, keymap, keymap_size);\r\nif (index >= keymap_size)\r\nreturn -EINVAL;\r\n*old_keycode = keymap[index].keycode;\r\nkeymap->keycode = ke->keycode;\r\n__set_bit(ke->keycode, dev->keybit);\r\nif (*old_keycode != KEY_RESERVED) {\r\n__clear_bit(*old_keycode, dev->keybit);\r\nfor (index = 0; index < keymap_size; index++) {\r\nif (keymap[index].keycode == *old_keycode) {\r\n__set_bit(*old_keycode, dev->keybit);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void legacy_dvb_usb_read_remote_control(struct work_struct *work)\r\n{\r\nstruct dvb_usb_device *d =\r\ncontainer_of(work, struct dvb_usb_device, rc_query_work.work);\r\nu32 event;\r\nint state;\r\nif (dvb_usb_disable_rc_polling)\r\nreturn;\r\nif (d->props.rc.legacy.rc_query(d,&event,&state)) {\r\nerr("error while querying for an remote control event.");\r\ngoto schedule;\r\n}\r\nswitch (state) {\r\ncase REMOTE_NO_KEY_PRESSED:\r\nbreak;\r\ncase REMOTE_KEY_PRESSED:\r\ndeb_rc("key pressed\n");\r\nd->last_event = event;\r\ncase REMOTE_KEY_REPEAT:\r\ndeb_rc("key repeated\n");\r\ninput_event(d->input_dev, EV_KEY, event, 1);\r\ninput_sync(d->input_dev);\r\ninput_event(d->input_dev, EV_KEY, d->last_event, 0);\r\ninput_sync(d->input_dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nschedule:\r\nschedule_delayed_work(&d->rc_query_work,msecs_to_jiffies(d->props.rc.legacy.rc_interval));\r\n}\r\nstatic int legacy_dvb_usb_remote_init(struct dvb_usb_device *d)\r\n{\r\nint i, err, rc_interval;\r\nstruct input_dev *input_dev;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY);\r\ninput_dev->name = "IR-receiver inside an USB DVB receiver";\r\ninput_dev->phys = d->rc_phys;\r\nusb_to_input_id(d->udev, &input_dev->id);\r\ninput_dev->dev.parent = &d->udev->dev;\r\nd->input_dev = input_dev;\r\nd->rc_dev = NULL;\r\ninput_dev->getkeycode = legacy_dvb_usb_getkeycode;\r\ninput_dev->setkeycode = legacy_dvb_usb_setkeycode;\r\ndeb_rc("key map size: %d\n", d->props.rc.legacy.rc_map_size);\r\nfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++) {\r\ndeb_rc("setting bit for event %d item %d\n",\r\nd->props.rc.legacy.rc_map_table[i].keycode, i);\r\nset_bit(d->props.rc.legacy.rc_map_table[i].keycode, input_dev->keybit);\r\n}\r\ninput_dev->rep[REP_PERIOD] = d->props.rc.legacy.rc_interval;\r\ninput_dev->rep[REP_DELAY] = d->props.rc.legacy.rc_interval + 150;\r\ninput_set_drvdata(input_dev, d);\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ninput_free_device(input_dev);\r\nrc_interval = d->props.rc.legacy.rc_interval;\r\nINIT_DELAYED_WORK(&d->rc_query_work, legacy_dvb_usb_read_remote_control);\r\ninfo("schedule remote query interval to %d msecs.", rc_interval);\r\nschedule_delayed_work(&d->rc_query_work,\r\nmsecs_to_jiffies(rc_interval));\r\nd->state |= DVB_USB_STATE_REMOTE;\r\nreturn err;\r\n}\r\nstatic void dvb_usb_read_remote_control(struct work_struct *work)\r\n{\r\nstruct dvb_usb_device *d =\r\ncontainer_of(work, struct dvb_usb_device, rc_query_work.work);\r\nint err;\r\nif (dvb_usb_disable_rc_polling || d->props.rc.core.bulk_mode)\r\nreturn;\r\nerr = d->props.rc.core.rc_query(d);\r\nif (err)\r\nerr("error %d while querying for an remote control event.", err);\r\nschedule_delayed_work(&d->rc_query_work,\r\nmsecs_to_jiffies(d->props.rc.core.rc_interval));\r\n}\r\nstatic int rc_core_dvb_usb_remote_init(struct dvb_usb_device *d)\r\n{\r\nint err, rc_interval;\r\nstruct rc_dev *dev;\r\ndev = rc_allocate_device();\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->driver_name = d->props.rc.core.module_name;\r\ndev->map_name = d->props.rc.core.rc_codes;\r\ndev->change_protocol = d->props.rc.core.change_protocol;\r\ndev->allowed_protocols = d->props.rc.core.allowed_protos;\r\ndev->driver_type = d->props.rc.core.driver_type;\r\nusb_to_input_id(d->udev, &dev->input_id);\r\ndev->input_name = "IR-receiver inside an USB DVB receiver";\r\ndev->input_phys = d->rc_phys;\r\ndev->dev.parent = &d->udev->dev;\r\ndev->priv = d;\r\nerr = rc_register_device(dev);\r\nif (err < 0) {\r\nrc_free_device(dev);\r\nreturn err;\r\n}\r\nd->input_dev = NULL;\r\nd->rc_dev = dev;\r\nif (!d->props.rc.core.rc_query || d->props.rc.core.bulk_mode)\r\nreturn 0;\r\nINIT_DELAYED_WORK(&d->rc_query_work, dvb_usb_read_remote_control);\r\nrc_interval = d->props.rc.core.rc_interval;\r\ninfo("schedule remote query interval to %d msecs.", rc_interval);\r\nschedule_delayed_work(&d->rc_query_work,\r\nmsecs_to_jiffies(rc_interval));\r\nreturn 0;\r\n}\r\nint dvb_usb_remote_init(struct dvb_usb_device *d)\r\n{\r\nint err;\r\nif (dvb_usb_disable_rc_polling)\r\nreturn 0;\r\nif (d->props.rc.legacy.rc_map_table && d->props.rc.legacy.rc_query)\r\nd->props.rc.mode = DVB_RC_LEGACY;\r\nelse if (d->props.rc.core.rc_codes)\r\nd->props.rc.mode = DVB_RC_CORE;\r\nelse\r\nreturn 0;\r\nusb_make_path(d->udev, d->rc_phys, sizeof(d->rc_phys));\r\nstrlcat(d->rc_phys, "/ir0", sizeof(d->rc_phys));\r\nif (d->props.rc.legacy.rc_interval < 40)\r\nd->props.rc.legacy.rc_interval = 100;\r\nif (d->props.rc.mode == DVB_RC_LEGACY)\r\nerr = legacy_dvb_usb_remote_init(d);\r\nelse\r\nerr = rc_core_dvb_usb_remote_init(d);\r\nif (err)\r\nreturn err;\r\nd->state |= DVB_USB_STATE_REMOTE;\r\nreturn 0;\r\n}\r\nint dvb_usb_remote_exit(struct dvb_usb_device *d)\r\n{\r\nif (d->state & DVB_USB_STATE_REMOTE) {\r\ncancel_delayed_work_sync(&d->rc_query_work);\r\nif (d->props.rc.mode == DVB_RC_LEGACY)\r\ninput_unregister_device(d->input_dev);\r\nelse\r\nrc_unregister_device(d->rc_dev);\r\n}\r\nd->state &= ~DVB_USB_STATE_REMOTE;\r\nreturn 0;\r\n}\r\nint dvb_usb_nec_rc_key_to_event(struct dvb_usb_device *d,\r\nu8 keybuf[5], u32 *event, int *state)\r\n{\r\nint i;\r\nstruct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;\r\n*event = 0;\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nswitch (keybuf[0]) {\r\ncase DVB_USB_RC_NEC_EMPTY:\r\nbreak;\r\ncase DVB_USB_RC_NEC_KEY_PRESSED:\r\nif ((u8) ~keybuf[1] != keybuf[2] ||\r\n(u8) ~keybuf[3] != keybuf[4]) {\r\ndeb_err("remote control checksum failed.\n");\r\nbreak;\r\n}\r\nfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++)\r\nif (rc5_custom(&keymap[i]) == keybuf[1] &&\r\nrc5_data(&keymap[i]) == keybuf[3]) {\r\n*event = keymap[i].keycode;\r\n*state = REMOTE_KEY_PRESSED;\r\nreturn 0;\r\n}\r\ndeb_err("key mapping failed - no appropriate key found in keymapping\n");\r\nbreak;\r\ncase DVB_USB_RC_NEC_KEY_REPEATED:\r\n*state = REMOTE_KEY_REPEAT;\r\nbreak;\r\ndefault:\r\ndeb_err("unknown type of remote status: %d\n",keybuf[0]);\r\nbreak;\r\n}\r\nreturn 0;\r\n}
