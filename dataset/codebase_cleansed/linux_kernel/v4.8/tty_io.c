static void free_tty_struct(struct tty_struct *tty)\r\n{\r\ntty_ldisc_deinit(tty);\r\nput_device(tty->dev);\r\nkfree(tty->write_buf);\r\ntty->magic = 0xDEADDEAD;\r\nkfree(tty);\r\n}\r\nstatic inline struct tty_struct *file_tty(struct file *file)\r\n{\r\nreturn ((struct tty_file_private *)file->private_data)->tty;\r\n}\r\nint tty_alloc_file(struct file *file)\r\n{\r\nstruct tty_file_private *priv;\r\npriv = kmalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nfile->private_data = priv;\r\nreturn 0;\r\n}\r\nvoid tty_add_file(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct tty_file_private *priv = file->private_data;\r\npriv->tty = tty;\r\npriv->file = file;\r\nspin_lock(&tty->files_lock);\r\nlist_add(&priv->list, &tty->tty_files);\r\nspin_unlock(&tty->files_lock);\r\n}\r\nvoid tty_free_file(struct file *file)\r\n{\r\nstruct tty_file_private *priv = file->private_data;\r\nfile->private_data = NULL;\r\nkfree(priv);\r\n}\r\nstatic void tty_del_file(struct file *file)\r\n{\r\nstruct tty_file_private *priv = file->private_data;\r\nstruct tty_struct *tty = priv->tty;\r\nspin_lock(&tty->files_lock);\r\nlist_del(&priv->list);\r\nspin_unlock(&tty->files_lock);\r\ntty_free_file(file);\r\n}\r\nconst char *tty_name(const struct tty_struct *tty)\r\n{\r\nif (!tty)\r\nreturn "NULL tty";\r\nreturn tty->name;\r\n}\r\nconst char *tty_driver_name(const struct tty_struct *tty)\r\n{\r\nif (!tty || !tty->driver)\r\nreturn "";\r\nreturn tty->driver->name;\r\n}\r\nstatic int tty_paranoia_check(struct tty_struct *tty, struct inode *inode,\r\nconst char *routine)\r\n{\r\n#ifdef TTY_PARANOIA_CHECK\r\nif (!tty) {\r\npr_warn("(%d:%d): %s: NULL tty\n",\r\nimajor(inode), iminor(inode), routine);\r\nreturn 1;\r\n}\r\nif (tty->magic != TTY_MAGIC) {\r\npr_warn("(%d:%d): %s: bad magic number\n",\r\nimajor(inode), iminor(inode), routine);\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int check_tty_count(struct tty_struct *tty, const char *routine)\r\n{\r\n#ifdef CHECK_TTY_COUNT\r\nstruct list_head *p;\r\nint count = 0;\r\nspin_lock(&tty->files_lock);\r\nlist_for_each(p, &tty->tty_files) {\r\ncount++;\r\n}\r\nspin_unlock(&tty->files_lock);\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\r\ntty->driver->subtype == PTY_TYPE_SLAVE &&\r\ntty->link && tty->link->count)\r\ncount++;\r\nif (tty->count != count) {\r\ntty_warn(tty, "%s: tty->count(%d) != #fd's(%d)\n",\r\nroutine, tty->count, count);\r\nreturn count;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic struct tty_driver *get_tty_driver(dev_t device, int *index)\r\n{\r\nstruct tty_driver *p;\r\nlist_for_each_entry(p, &tty_drivers, tty_drivers) {\r\ndev_t base = MKDEV(p->major, p->minor_start);\r\nif (device < base || device >= base + p->num)\r\ncontinue;\r\n*index = device - base;\r\nreturn tty_driver_kref_get(p);\r\n}\r\nreturn NULL;\r\n}\r\nstruct tty_driver *tty_find_polling_driver(char *name, int *line)\r\n{\r\nstruct tty_driver *p, *res = NULL;\r\nint tty_line = 0;\r\nint len;\r\nchar *str, *stp;\r\nfor (str = name; *str; str++)\r\nif ((*str >= '0' && *str <= '9') || *str == ',')\r\nbreak;\r\nif (!*str)\r\nreturn NULL;\r\nlen = str - name;\r\ntty_line = simple_strtoul(str, &str, 10);\r\nmutex_lock(&tty_mutex);\r\nlist_for_each_entry(p, &tty_drivers, tty_drivers) {\r\nif (strncmp(name, p->name, len) != 0)\r\ncontinue;\r\nstp = str;\r\nif (*stp == ',')\r\nstp++;\r\nif (*stp == '\0')\r\nstp = NULL;\r\nif (tty_line >= 0 && tty_line < p->num && p->ops &&\r\np->ops->poll_init && !p->ops->poll_init(p, tty_line, stp)) {\r\nres = tty_driver_kref_get(p);\r\n*line = tty_line;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&tty_mutex);\r\nreturn res;\r\n}\r\nstatic int is_ignored(int sig)\r\n{\r\nreturn (sigismember(&current->blocked, sig) ||\r\ncurrent->sighand->action[sig-1].sa.sa_handler == SIG_IGN);\r\n}\r\nint __tty_check_change(struct tty_struct *tty, int sig)\r\n{\r\nunsigned long flags;\r\nstruct pid *pgrp, *tty_pgrp;\r\nint ret = 0;\r\nif (current->signal->tty != tty)\r\nreturn 0;\r\nrcu_read_lock();\r\npgrp = task_pgrp(current);\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\ntty_pgrp = tty->pgrp;\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nif (tty_pgrp && pgrp != tty->pgrp) {\r\nif (is_ignored(sig)) {\r\nif (sig == SIGTTIN)\r\nret = -EIO;\r\n} else if (is_current_pgrp_orphaned())\r\nret = -EIO;\r\nelse {\r\nkill_pgrp(pgrp, sig, 1);\r\nset_thread_flag(TIF_SIGPENDING);\r\nret = -ERESTARTSYS;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (!tty_pgrp)\r\ntty_warn(tty, "sig=%d, tty->pgrp == NULL!\n", sig);\r\nreturn ret;\r\n}\r\nint tty_check_change(struct tty_struct *tty)\r\n{\r\nreturn __tty_check_change(tty, SIGTTOU);\r\n}\r\nstatic ssize_t hung_up_tty_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t hung_up_tty_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn -EIO;\r\n}\r\nstatic unsigned int hung_up_tty_poll(struct file *filp, poll_table *wait)\r\n{\r\nreturn POLLIN | POLLOUT | POLLERR | POLLHUP | POLLRDNORM | POLLWRNORM;\r\n}\r\nstatic long hung_up_tty_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn cmd == TIOCSPGRP ? -ENOTTY : -EIO;\r\n}\r\nstatic long hung_up_tty_compat_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn cmd == TIOCSPGRP ? -ENOTTY : -EIO;\r\n}\r\nstatic int hung_up_tty_fasync(int fd, struct file *file, int on)\r\n{\r\nreturn -ENOTTY;\r\n}\r\nvoid proc_clear_tty(struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nstruct tty_struct *tty;\r\nspin_lock_irqsave(&p->sighand->siglock, flags);\r\ntty = p->signal->tty;\r\np->signal->tty = NULL;\r\nspin_unlock_irqrestore(&p->sighand->siglock, flags);\r\ntty_kref_put(tty);\r\n}\r\nstatic void __proc_set_tty(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nput_pid(tty->session);\r\nput_pid(tty->pgrp);\r\ntty->pgrp = get_pid(task_pgrp(current));\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\ntty->session = get_pid(task_session(current));\r\nif (current->signal->tty) {\r\ntty_debug(tty, "current tty %s not NULL!!\n",\r\ncurrent->signal->tty->name);\r\ntty_kref_put(current->signal->tty);\r\n}\r\nput_pid(current->signal->tty_old_pgrp);\r\ncurrent->signal->tty = tty_kref_get(tty);\r\ncurrent->signal->tty_old_pgrp = NULL;\r\n}\r\nstatic void proc_set_tty(struct tty_struct *tty)\r\n{\r\nspin_lock_irq(&current->sighand->siglock);\r\n__proc_set_tty(tty);\r\nspin_unlock_irq(&current->sighand->siglock);\r\n}\r\nstruct tty_struct *get_current_tty(void)\r\n{\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nspin_lock_irqsave(&current->sighand->siglock, flags);\r\ntty = tty_kref_get(current->signal->tty);\r\nspin_unlock_irqrestore(&current->sighand->siglock, flags);\r\nreturn tty;\r\n}\r\nstatic void session_clear_tty(struct pid *session)\r\n{\r\nstruct task_struct *p;\r\ndo_each_pid_task(session, PIDTYPE_SID, p) {\r\nproc_clear_tty(p);\r\n} while_each_pid_task(session, PIDTYPE_SID, p);\r\n}\r\nvoid tty_wakeup(struct tty_struct *tty)\r\n{\r\nstruct tty_ldisc *ld;\r\nif (test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) {\r\nld = tty_ldisc_ref(tty);\r\nif (ld) {\r\nif (ld->ops->write_wakeup)\r\nld->ops->write_wakeup(tty);\r\ntty_ldisc_deref(ld);\r\n}\r\n}\r\nwake_up_interruptible_poll(&tty->write_wait, POLLOUT);\r\n}\r\nstatic int tty_signal_session_leader(struct tty_struct *tty, int exit_session)\r\n{\r\nstruct task_struct *p;\r\nint refs = 0;\r\nstruct pid *tty_pgrp = NULL;\r\nread_lock(&tasklist_lock);\r\nif (tty->session) {\r\ndo_each_pid_task(tty->session, PIDTYPE_SID, p) {\r\nspin_lock_irq(&p->sighand->siglock);\r\nif (p->signal->tty == tty) {\r\np->signal->tty = NULL;\r\nrefs++;\r\n}\r\nif (!p->signal->leader) {\r\nspin_unlock_irq(&p->sighand->siglock);\r\ncontinue;\r\n}\r\n__group_send_sig_info(SIGHUP, SEND_SIG_PRIV, p);\r\n__group_send_sig_info(SIGCONT, SEND_SIG_PRIV, p);\r\nput_pid(p->signal->tty_old_pgrp);\r\nspin_lock(&tty->ctrl_lock);\r\ntty_pgrp = get_pid(tty->pgrp);\r\nif (tty->pgrp)\r\np->signal->tty_old_pgrp = get_pid(tty->pgrp);\r\nspin_unlock(&tty->ctrl_lock);\r\nspin_unlock_irq(&p->sighand->siglock);\r\n} while_each_pid_task(tty->session, PIDTYPE_SID, p);\r\n}\r\nread_unlock(&tasklist_lock);\r\nif (tty_pgrp) {\r\nif (exit_session)\r\nkill_pgrp(tty_pgrp, SIGHUP, exit_session);\r\nput_pid(tty_pgrp);\r\n}\r\nreturn refs;\r\n}\r\nstatic void __tty_hangup(struct tty_struct *tty, int exit_session)\r\n{\r\nstruct file *cons_filp = NULL;\r\nstruct file *filp, *f = NULL;\r\nstruct tty_file_private *priv;\r\nint closecount = 0, n;\r\nint refs;\r\nif (!tty)\r\nreturn;\r\nspin_lock(&redirect_lock);\r\nif (redirect && file_tty(redirect) == tty) {\r\nf = redirect;\r\nredirect = NULL;\r\n}\r\nspin_unlock(&redirect_lock);\r\ntty_lock(tty);\r\nif (test_bit(TTY_HUPPED, &tty->flags)) {\r\ntty_unlock(tty);\r\nreturn;\r\n}\r\ncheck_tty_count(tty, "tty_hangup");\r\nspin_lock(&tty->files_lock);\r\nlist_for_each_entry(priv, &tty->tty_files, list) {\r\nfilp = priv->file;\r\nif (filp->f_op->write == redirected_tty_write)\r\ncons_filp = filp;\r\nif (filp->f_op->write != tty_write)\r\ncontinue;\r\nclosecount++;\r\n__tty_fasync(-1, filp, 0);\r\nfilp->f_op = &hung_up_tty_fops;\r\n}\r\nspin_unlock(&tty->files_lock);\r\nrefs = tty_signal_session_leader(tty, exit_session);\r\nwhile (refs--)\r\ntty_kref_put(tty);\r\ntty_ldisc_hangup(tty, cons_filp != NULL);\r\nspin_lock_irq(&tty->ctrl_lock);\r\nclear_bit(TTY_THROTTLED, &tty->flags);\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nput_pid(tty->session);\r\nput_pid(tty->pgrp);\r\ntty->session = NULL;\r\ntty->pgrp = NULL;\r\ntty->ctrl_status = 0;\r\nspin_unlock_irq(&tty->ctrl_lock);\r\nif (cons_filp) {\r\nif (tty->ops->close)\r\nfor (n = 0; n < closecount; n++)\r\ntty->ops->close(tty, cons_filp);\r\n} else if (tty->ops->hangup)\r\ntty->ops->hangup(tty);\r\nset_bit(TTY_HUPPED, &tty->flags);\r\ntty_unlock(tty);\r\nif (f)\r\nfput(f);\r\n}\r\nstatic void do_tty_hangup(struct work_struct *work)\r\n{\r\nstruct tty_struct *tty =\r\ncontainer_of(work, struct tty_struct, hangup_work);\r\n__tty_hangup(tty, 0);\r\n}\r\nvoid tty_hangup(struct tty_struct *tty)\r\n{\r\ntty_debug_hangup(tty, "hangup\n");\r\nschedule_work(&tty->hangup_work);\r\n}\r\nvoid tty_vhangup(struct tty_struct *tty)\r\n{\r\ntty_debug_hangup(tty, "vhangup\n");\r\n__tty_hangup(tty, 0);\r\n}\r\nvoid tty_vhangup_self(void)\r\n{\r\nstruct tty_struct *tty;\r\ntty = get_current_tty();\r\nif (tty) {\r\ntty_vhangup(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic void tty_vhangup_session(struct tty_struct *tty)\r\n{\r\ntty_debug_hangup(tty, "session hangup\n");\r\n__tty_hangup(tty, 1);\r\n}\r\nint tty_hung_up_p(struct file *filp)\r\n{\r\nreturn (filp->f_op == &hung_up_tty_fops);\r\n}\r\nvoid disassociate_ctty(int on_exit)\r\n{\r\nstruct tty_struct *tty;\r\nif (!current->signal->leader)\r\nreturn;\r\ntty = get_current_tty();\r\nif (tty) {\r\nif (on_exit && tty->driver->type != TTY_DRIVER_TYPE_PTY) {\r\ntty_vhangup_session(tty);\r\n} else {\r\nstruct pid *tty_pgrp = tty_get_pgrp(tty);\r\nif (tty_pgrp) {\r\nkill_pgrp(tty_pgrp, SIGHUP, on_exit);\r\nif (!on_exit)\r\nkill_pgrp(tty_pgrp, SIGCONT, on_exit);\r\nput_pid(tty_pgrp);\r\n}\r\n}\r\ntty_kref_put(tty);\r\n} else if (on_exit) {\r\nstruct pid *old_pgrp;\r\nspin_lock_irq(&current->sighand->siglock);\r\nold_pgrp = current->signal->tty_old_pgrp;\r\ncurrent->signal->tty_old_pgrp = NULL;\r\nspin_unlock_irq(&current->sighand->siglock);\r\nif (old_pgrp) {\r\nkill_pgrp(old_pgrp, SIGHUP, on_exit);\r\nkill_pgrp(old_pgrp, SIGCONT, on_exit);\r\nput_pid(old_pgrp);\r\n}\r\nreturn;\r\n}\r\nspin_lock_irq(&current->sighand->siglock);\r\nput_pid(current->signal->tty_old_pgrp);\r\ncurrent->signal->tty_old_pgrp = NULL;\r\ntty = tty_kref_get(current->signal->tty);\r\nif (tty) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nput_pid(tty->session);\r\nput_pid(tty->pgrp);\r\ntty->session = NULL;\r\ntty->pgrp = NULL;\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\ntty_kref_put(tty);\r\n} else\r\ntty_debug_hangup(tty, "no current tty\n");\r\nspin_unlock_irq(&current->sighand->siglock);\r\nread_lock(&tasklist_lock);\r\nsession_clear_tty(task_session(current));\r\nread_unlock(&tasklist_lock);\r\n}\r\nvoid no_tty(void)\r\n{\r\nstruct task_struct *tsk = current;\r\ndisassociate_ctty(0);\r\nproc_clear_tty(tsk);\r\n}\r\nvoid __stop_tty(struct tty_struct *tty)\r\n{\r\nif (tty->stopped)\r\nreturn;\r\ntty->stopped = 1;\r\nif (tty->ops->stop)\r\ntty->ops->stop(tty);\r\n}\r\nvoid stop_tty(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->flow_lock, flags);\r\n__stop_tty(tty);\r\nspin_unlock_irqrestore(&tty->flow_lock, flags);\r\n}\r\nvoid __start_tty(struct tty_struct *tty)\r\n{\r\nif (!tty->stopped || tty->flow_stopped)\r\nreturn;\r\ntty->stopped = 0;\r\nif (tty->ops->start)\r\ntty->ops->start(tty);\r\ntty_wakeup(tty);\r\n}\r\nvoid start_tty(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->flow_lock, flags);\r\n__start_tty(tty);\r\nspin_unlock_irqrestore(&tty->flow_lock, flags);\r\n}\r\nstatic void tty_update_time(struct timespec *time)\r\n{\r\nunsigned long sec = get_seconds();\r\nif ((sec ^ time->tv_sec) & ~7)\r\ntime->tv_sec = sec;\r\n}\r\nstatic ssize_t tty_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nint i;\r\nstruct inode *inode = file_inode(file);\r\nstruct tty_struct *tty = file_tty(file);\r\nstruct tty_ldisc *ld;\r\nif (tty_paranoia_check(tty, inode, "tty_read"))\r\nreturn -EIO;\r\nif (!tty || tty_io_error(tty))\r\nreturn -EIO;\r\nld = tty_ldisc_ref_wait(tty);\r\nif (!ld)\r\nreturn hung_up_tty_read(file, buf, count, ppos);\r\nif (ld->ops->read)\r\ni = ld->ops->read(tty, file, buf, count);\r\nelse\r\ni = -EIO;\r\ntty_ldisc_deref(ld);\r\nif (i > 0)\r\ntty_update_time(&inode->i_atime);\r\nreturn i;\r\n}\r\nstatic void tty_write_unlock(struct tty_struct *tty)\r\n{\r\nmutex_unlock(&tty->atomic_write_lock);\r\nwake_up_interruptible_poll(&tty->write_wait, POLLOUT);\r\n}\r\nstatic int tty_write_lock(struct tty_struct *tty, int ndelay)\r\n{\r\nif (!mutex_trylock(&tty->atomic_write_lock)) {\r\nif (ndelay)\r\nreturn -EAGAIN;\r\nif (mutex_lock_interruptible(&tty->atomic_write_lock))\r\nreturn -ERESTARTSYS;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline ssize_t do_tty_write(\r\nssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t),\r\nstruct tty_struct *tty,\r\nstruct file *file,\r\nconst char __user *buf,\r\nsize_t count)\r\n{\r\nssize_t ret, written = 0;\r\nunsigned int chunk;\r\nret = tty_write_lock(tty, file->f_flags & O_NDELAY);\r\nif (ret < 0)\r\nreturn ret;\r\nchunk = 2048;\r\nif (test_bit(TTY_NO_WRITE_SPLIT, &tty->flags))\r\nchunk = 65536;\r\nif (count < chunk)\r\nchunk = count;\r\nif (tty->write_cnt < chunk) {\r\nunsigned char *buf_chunk;\r\nif (chunk < 1024)\r\nchunk = 1024;\r\nbuf_chunk = kmalloc(chunk, GFP_KERNEL);\r\nif (!buf_chunk) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nkfree(tty->write_buf);\r\ntty->write_cnt = chunk;\r\ntty->write_buf = buf_chunk;\r\n}\r\nfor (;;) {\r\nsize_t size = count;\r\nif (size > chunk)\r\nsize = chunk;\r\nret = -EFAULT;\r\nif (copy_from_user(tty->write_buf, buf, size))\r\nbreak;\r\nret = write(tty, file, tty->write_buf, size);\r\nif (ret <= 0)\r\nbreak;\r\nwritten += ret;\r\nbuf += ret;\r\ncount -= ret;\r\nif (!count)\r\nbreak;\r\nret = -ERESTARTSYS;\r\nif (signal_pending(current))\r\nbreak;\r\ncond_resched();\r\n}\r\nif (written) {\r\ntty_update_time(&file_inode(file)->i_mtime);\r\nret = written;\r\n}\r\nout:\r\ntty_write_unlock(tty);\r\nreturn ret;\r\n}\r\nvoid tty_write_message(struct tty_struct *tty, char *msg)\r\n{\r\nif (tty) {\r\nmutex_lock(&tty->atomic_write_lock);\r\ntty_lock(tty);\r\nif (tty->ops->write && tty->count > 0)\r\ntty->ops->write(tty, msg, strlen(msg));\r\ntty_unlock(tty);\r\ntty_write_unlock(tty);\r\n}\r\nreturn;\r\n}\r\nstatic ssize_t tty_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct tty_struct *tty = file_tty(file);\r\nstruct tty_ldisc *ld;\r\nssize_t ret;\r\nif (tty_paranoia_check(tty, file_inode(file), "tty_write"))\r\nreturn -EIO;\r\nif (!tty || !tty->ops->write || tty_io_error(tty))\r\nreturn -EIO;\r\nif (tty->ops->write_room == NULL)\r\ntty_err(tty, "missing write_room method\n");\r\nld = tty_ldisc_ref_wait(tty);\r\nif (!ld)\r\nreturn hung_up_tty_write(file, buf, count, ppos);\r\nif (!ld->ops->write)\r\nret = -EIO;\r\nelse\r\nret = do_tty_write(ld->ops->write, tty, file, buf, count);\r\ntty_ldisc_deref(ld);\r\nreturn ret;\r\n}\r\nssize_t redirected_tty_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct file *p = NULL;\r\nspin_lock(&redirect_lock);\r\nif (redirect)\r\np = get_file(redirect);\r\nspin_unlock(&redirect_lock);\r\nif (p) {\r\nssize_t res;\r\nres = vfs_write(p, buf, count, &p->f_pos);\r\nfput(p);\r\nreturn res;\r\n}\r\nreturn tty_write(file, buf, count, ppos);\r\n}\r\nint tty_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nint was_stopped = tty->stopped;\r\nif (tty->ops->send_xchar) {\r\ndown_read(&tty->termios_rwsem);\r\ntty->ops->send_xchar(tty, ch);\r\nup_read(&tty->termios_rwsem);\r\nreturn 0;\r\n}\r\nif (tty_write_lock(tty, 0) < 0)\r\nreturn -ERESTARTSYS;\r\ndown_read(&tty->termios_rwsem);\r\nif (was_stopped)\r\nstart_tty(tty);\r\ntty->ops->write(tty, &ch, 1);\r\nif (was_stopped)\r\nstop_tty(tty);\r\nup_read(&tty->termios_rwsem);\r\ntty_write_unlock(tty);\r\nreturn 0;\r\n}\r\nstatic void pty_line_name(struct tty_driver *driver, int index, char *p)\r\n{\r\nint i = index + driver->name_base;\r\nsprintf(p, "%s%c%x",\r\ndriver->subtype == PTY_TYPE_SLAVE ? "tty" : driver->name,\r\nptychar[i >> 4 & 0xf], i & 0xf);\r\n}\r\nstatic ssize_t tty_line_name(struct tty_driver *driver, int index, char *p)\r\n{\r\nif (driver->flags & TTY_DRIVER_UNNUMBERED_NODE)\r\nreturn sprintf(p, "%s", driver->name);\r\nelse\r\nreturn sprintf(p, "%s%d", driver->name,\r\nindex + driver->name_base);\r\n}\r\nstatic struct tty_struct *tty_driver_lookup_tty(struct tty_driver *driver,\r\nstruct file *file, int idx)\r\n{\r\nstruct tty_struct *tty;\r\nif (driver->ops->lookup)\r\ntty = driver->ops->lookup(driver, file, idx);\r\nelse\r\ntty = driver->ttys[idx];\r\nif (!IS_ERR(tty))\r\ntty_kref_get(tty);\r\nreturn tty;\r\n}\r\nvoid tty_init_termios(struct tty_struct *tty)\r\n{\r\nstruct ktermios *tp;\r\nint idx = tty->index;\r\nif (tty->driver->flags & TTY_DRIVER_RESET_TERMIOS)\r\ntty->termios = tty->driver->init_termios;\r\nelse {\r\ntp = tty->driver->termios[idx];\r\nif (tp != NULL) {\r\ntty->termios = *tp;\r\ntty->termios.c_line = tty->driver->init_termios.c_line;\r\n} else\r\ntty->termios = tty->driver->init_termios;\r\n}\r\ntty->termios.c_ispeed = tty_termios_input_baud_rate(&tty->termios);\r\ntty->termios.c_ospeed = tty_termios_baud_rate(&tty->termios);\r\n}\r\nint tty_standard_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\ntty_init_termios(tty);\r\ntty_driver_kref_get(driver);\r\ntty->count++;\r\ndriver->ttys[tty->index] = tty;\r\nreturn 0;\r\n}\r\nstatic int tty_driver_install_tty(struct tty_driver *driver,\r\nstruct tty_struct *tty)\r\n{\r\nreturn driver->ops->install ? driver->ops->install(driver, tty) :\r\ntty_standard_install(driver, tty);\r\n}\r\nstatic void tty_driver_remove_tty(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nif (driver->ops->remove)\r\ndriver->ops->remove(driver, tty);\r\nelse\r\ndriver->ttys[tty->index] = NULL;\r\n}\r\nstatic int tty_reopen(struct tty_struct *tty)\r\n{\r\nstruct tty_driver *driver = tty->driver;\r\nif (driver->type == TTY_DRIVER_TYPE_PTY &&\r\ndriver->subtype == PTY_TYPE_MASTER)\r\nreturn -EIO;\r\nif (!tty->count)\r\nreturn -EAGAIN;\r\nif (test_bit(TTY_EXCLUSIVE, &tty->flags) && !capable(CAP_SYS_ADMIN))\r\nreturn -EBUSY;\r\ntty->count++;\r\nif (!tty->ldisc)\r\nreturn tty_ldisc_reinit(tty, tty->termios.c_line);\r\nreturn 0;\r\n}\r\nstruct tty_struct *tty_init_dev(struct tty_driver *driver, int idx)\r\n{\r\nstruct tty_struct *tty;\r\nint retval;\r\nif (!try_module_get(driver->owner))\r\nreturn ERR_PTR(-ENODEV);\r\ntty = alloc_tty_struct(driver, idx);\r\nif (!tty) {\r\nretval = -ENOMEM;\r\ngoto err_module_put;\r\n}\r\ntty_lock(tty);\r\nretval = tty_driver_install_tty(driver, tty);\r\nif (retval < 0)\r\ngoto err_free_tty;\r\nif (!tty->port)\r\ntty->port = driver->ports[idx];\r\nWARN_RATELIMIT(!tty->port,\r\n"%s: %s driver does not set tty->port. This will crash the kernel later. Fix the driver!\n",\r\n__func__, tty->driver->name);\r\ntty->port->itty = tty;\r\nretval = tty_ldisc_setup(tty, tty->link);\r\nif (retval)\r\ngoto err_release_tty;\r\nreturn tty;\r\nerr_free_tty:\r\ntty_unlock(tty);\r\nfree_tty_struct(tty);\r\nerr_module_put:\r\nmodule_put(driver->owner);\r\nreturn ERR_PTR(retval);\r\nerr_release_tty:\r\ntty_unlock(tty);\r\ntty_info_ratelimited(tty, "ldisc open failed (%d), clearing slot %d\n",\r\nretval, idx);\r\nrelease_tty(tty, idx);\r\nreturn ERR_PTR(retval);\r\n}\r\nstatic void tty_free_termios(struct tty_struct *tty)\r\n{\r\nstruct ktermios *tp;\r\nint idx = tty->index;\r\nif (tty->driver->flags & TTY_DRIVER_RESET_TERMIOS)\r\nreturn;\r\ntp = tty->driver->termios[idx];\r\nif (tp == NULL) {\r\ntp = kmalloc(sizeof(struct ktermios), GFP_KERNEL);\r\nif (tp == NULL)\r\nreturn;\r\ntty->driver->termios[idx] = tp;\r\n}\r\n*tp = tty->termios;\r\n}\r\nstatic void tty_flush_works(struct tty_struct *tty)\r\n{\r\nflush_work(&tty->SAK_work);\r\nflush_work(&tty->hangup_work);\r\nif (tty->link) {\r\nflush_work(&tty->link->SAK_work);\r\nflush_work(&tty->link->hangup_work);\r\n}\r\n}\r\nstatic void release_one_tty(struct work_struct *work)\r\n{\r\nstruct tty_struct *tty =\r\ncontainer_of(work, struct tty_struct, hangup_work);\r\nstruct tty_driver *driver = tty->driver;\r\nstruct module *owner = driver->owner;\r\nif (tty->ops->cleanup)\r\ntty->ops->cleanup(tty);\r\ntty->magic = 0;\r\ntty_driver_kref_put(driver);\r\nmodule_put(owner);\r\nspin_lock(&tty->files_lock);\r\nlist_del_init(&tty->tty_files);\r\nspin_unlock(&tty->files_lock);\r\nput_pid(tty->pgrp);\r\nput_pid(tty->session);\r\nfree_tty_struct(tty);\r\n}\r\nstatic void queue_release_one_tty(struct kref *kref)\r\n{\r\nstruct tty_struct *tty = container_of(kref, struct tty_struct, kref);\r\nINIT_WORK(&tty->hangup_work, release_one_tty);\r\nschedule_work(&tty->hangup_work);\r\n}\r\nvoid tty_kref_put(struct tty_struct *tty)\r\n{\r\nif (tty)\r\nkref_put(&tty->kref, queue_release_one_tty);\r\n}\r\nstatic void release_tty(struct tty_struct *tty, int idx)\r\n{\r\nWARN_ON(tty->index != idx);\r\nWARN_ON(!mutex_is_locked(&tty_mutex));\r\nif (tty->ops->shutdown)\r\ntty->ops->shutdown(tty);\r\ntty_free_termios(tty);\r\ntty_driver_remove_tty(tty->driver, tty);\r\ntty->port->itty = NULL;\r\nif (tty->link)\r\ntty->link->port->itty = NULL;\r\ntty_buffer_cancel_work(tty->port);\r\ntty_kref_put(tty->link);\r\ntty_kref_put(tty);\r\n}\r\nstatic int tty_release_checks(struct tty_struct *tty, int idx)\r\n{\r\n#ifdef TTY_PARANOIA_CHECK\r\nif (idx < 0 || idx >= tty->driver->num) {\r\ntty_debug(tty, "bad idx %d\n", idx);\r\nreturn -1;\r\n}\r\nif (tty->driver->flags & TTY_DRIVER_DEVPTS_MEM)\r\nreturn 0;\r\nif (tty != tty->driver->ttys[idx]) {\r\ntty_debug(tty, "bad driver table[%d] = %p\n",\r\nidx, tty->driver->ttys[idx]);\r\nreturn -1;\r\n}\r\nif (tty->driver->other) {\r\nstruct tty_struct *o_tty = tty->link;\r\nif (o_tty != tty->driver->other->ttys[idx]) {\r\ntty_debug(tty, "bad other table[%d] = %p\n",\r\nidx, tty->driver->other->ttys[idx]);\r\nreturn -1;\r\n}\r\nif (o_tty->link != tty) {\r\ntty_debug(tty, "bad link = %p\n", o_tty->link);\r\nreturn -1;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint tty_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct tty_struct *tty = file_tty(filp);\r\nstruct tty_struct *o_tty = NULL;\r\nint do_sleep, final;\r\nint idx;\r\nlong timeout = 0;\r\nint once = 1;\r\nif (tty_paranoia_check(tty, inode, __func__))\r\nreturn 0;\r\ntty_lock(tty);\r\ncheck_tty_count(tty, __func__);\r\n__tty_fasync(-1, filp, 0);\r\nidx = tty->index;\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\r\ntty->driver->subtype == PTY_TYPE_MASTER)\r\no_tty = tty->link;\r\nif (tty_release_checks(tty, idx)) {\r\ntty_unlock(tty);\r\nreturn 0;\r\n}\r\ntty_debug_hangup(tty, "releasing (count=%d)\n", tty->count);\r\nif (tty->ops->close)\r\ntty->ops->close(tty, filp);\r\ntty_lock_slave(o_tty);\r\nwhile (1) {\r\ndo_sleep = 0;\r\nif (tty->count <= 1) {\r\nif (waitqueue_active(&tty->read_wait)) {\r\nwake_up_poll(&tty->read_wait, POLLIN);\r\ndo_sleep++;\r\n}\r\nif (waitqueue_active(&tty->write_wait)) {\r\nwake_up_poll(&tty->write_wait, POLLOUT);\r\ndo_sleep++;\r\n}\r\n}\r\nif (o_tty && o_tty->count <= 1) {\r\nif (waitqueue_active(&o_tty->read_wait)) {\r\nwake_up_poll(&o_tty->read_wait, POLLIN);\r\ndo_sleep++;\r\n}\r\nif (waitqueue_active(&o_tty->write_wait)) {\r\nwake_up_poll(&o_tty->write_wait, POLLOUT);\r\ndo_sleep++;\r\n}\r\n}\r\nif (!do_sleep)\r\nbreak;\r\nif (once) {\r\nonce = 0;\r\ntty_warn(tty, "read/write wait queue active!\n");\r\n}\r\nschedule_timeout_killable(timeout);\r\nif (timeout < 120 * HZ)\r\ntimeout = 2 * timeout + 1;\r\nelse\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\n}\r\nif (o_tty) {\r\nif (--o_tty->count < 0) {\r\ntty_warn(tty, "bad slave count (%d)\n", o_tty->count);\r\no_tty->count = 0;\r\n}\r\n}\r\nif (--tty->count < 0) {\r\ntty_warn(tty, "bad tty->count (%d)\n", tty->count);\r\ntty->count = 0;\r\n}\r\ntty_del_file(filp);\r\nif (!tty->count) {\r\nread_lock(&tasklist_lock);\r\nsession_clear_tty(tty->session);\r\nif (o_tty)\r\nsession_clear_tty(o_tty->session);\r\nread_unlock(&tasklist_lock);\r\n}\r\nfinal = !tty->count && !(o_tty && o_tty->count);\r\ntty_unlock_slave(o_tty);\r\ntty_unlock(tty);\r\nif (!final)\r\nreturn 0;\r\ntty_debug_hangup(tty, "final close\n");\r\ntty_ldisc_release(tty);\r\ntty_flush_works(tty);\r\ntty_debug_hangup(tty, "freeing structure\n");\r\nmutex_lock(&tty_mutex);\r\nrelease_tty(tty, idx);\r\nmutex_unlock(&tty_mutex);\r\nreturn 0;\r\n}\r\nstatic struct tty_struct *tty_open_current_tty(dev_t device, struct file *filp)\r\n{\r\nstruct tty_struct *tty;\r\nint retval;\r\nif (device != MKDEV(TTYAUX_MAJOR, 0))\r\nreturn NULL;\r\ntty = get_current_tty();\r\nif (!tty)\r\nreturn ERR_PTR(-ENXIO);\r\nfilp->f_flags |= O_NONBLOCK;\r\ntty_lock(tty);\r\ntty_kref_put(tty);\r\nretval = tty_reopen(tty);\r\nif (retval < 0) {\r\ntty_unlock(tty);\r\ntty = ERR_PTR(retval);\r\n}\r\nreturn tty;\r\n}\r\nstatic struct tty_driver *tty_lookup_driver(dev_t device, struct file *filp,\r\nint *index)\r\n{\r\nstruct tty_driver *driver;\r\nswitch (device) {\r\n#ifdef CONFIG_VT\r\ncase MKDEV(TTY_MAJOR, 0): {\r\nextern struct tty_driver *console_driver;\r\ndriver = tty_driver_kref_get(console_driver);\r\n*index = fg_console;\r\nbreak;\r\n}\r\n#endif\r\ncase MKDEV(TTYAUX_MAJOR, 1): {\r\nstruct tty_driver *console_driver = console_device(index);\r\nif (console_driver) {\r\ndriver = tty_driver_kref_get(console_driver);\r\nif (driver) {\r\nfilp->f_flags |= O_NONBLOCK;\r\nbreak;\r\n}\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\ndefault:\r\ndriver = get_tty_driver(device, index);\r\nif (!driver)\r\nreturn ERR_PTR(-ENODEV);\r\nbreak;\r\n}\r\nreturn driver;\r\n}\r\nstatic struct tty_struct *tty_open_by_driver(dev_t device, struct inode *inode,\r\nstruct file *filp)\r\n{\r\nstruct tty_struct *tty;\r\nstruct tty_driver *driver = NULL;\r\nint index = -1;\r\nint retval;\r\nmutex_lock(&tty_mutex);\r\ndriver = tty_lookup_driver(device, filp, &index);\r\nif (IS_ERR(driver)) {\r\nmutex_unlock(&tty_mutex);\r\nreturn ERR_CAST(driver);\r\n}\r\ntty = tty_driver_lookup_tty(driver, filp, index);\r\nif (IS_ERR(tty)) {\r\nmutex_unlock(&tty_mutex);\r\ngoto out;\r\n}\r\nif (tty) {\r\nmutex_unlock(&tty_mutex);\r\nretval = tty_lock_interruptible(tty);\r\ntty_kref_put(tty);\r\nif (retval) {\r\nif (retval == -EINTR)\r\nretval = -ERESTARTSYS;\r\ntty = ERR_PTR(retval);\r\ngoto out;\r\n}\r\nretval = tty_reopen(tty);\r\nif (retval < 0) {\r\ntty_unlock(tty);\r\ntty = ERR_PTR(retval);\r\n}\r\n} else {\r\ntty = tty_init_dev(driver, index);\r\nmutex_unlock(&tty_mutex);\r\n}\r\nout:\r\ntty_driver_kref_put(driver);\r\nreturn tty;\r\n}\r\nstatic int tty_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct tty_struct *tty;\r\nint noctty, retval;\r\ndev_t device = inode->i_rdev;\r\nunsigned saved_flags = filp->f_flags;\r\nnonseekable_open(inode, filp);\r\nretry_open:\r\nretval = tty_alloc_file(filp);\r\nif (retval)\r\nreturn -ENOMEM;\r\ntty = tty_open_current_tty(device, filp);\r\nif (!tty)\r\ntty = tty_open_by_driver(device, inode, filp);\r\nif (IS_ERR(tty)) {\r\ntty_free_file(filp);\r\nretval = PTR_ERR(tty);\r\nif (retval != -EAGAIN || signal_pending(current))\r\nreturn retval;\r\nschedule();\r\ngoto retry_open;\r\n}\r\ntty_add_file(tty, filp);\r\ncheck_tty_count(tty, __func__);\r\ntty_debug_hangup(tty, "opening (count=%d)\n", tty->count);\r\nif (tty->ops->open)\r\nretval = tty->ops->open(tty, filp);\r\nelse\r\nretval = -ENODEV;\r\nfilp->f_flags = saved_flags;\r\nif (retval) {\r\ntty_debug_hangup(tty, "open error %d, releasing\n", retval);\r\ntty_unlock(tty);\r\ntty_release(inode, filp);\r\nif (retval != -ERESTARTSYS)\r\nreturn retval;\r\nif (signal_pending(current))\r\nreturn retval;\r\nschedule();\r\nif (tty_hung_up_p(filp))\r\nfilp->f_op = &tty_fops;\r\ngoto retry_open;\r\n}\r\nclear_bit(TTY_HUPPED, &tty->flags);\r\nread_lock(&tasklist_lock);\r\nspin_lock_irq(&current->sighand->siglock);\r\nnoctty = (filp->f_flags & O_NOCTTY) ||\r\n(IS_ENABLED(CONFIG_VT) && device == MKDEV(TTY_MAJOR, 0)) ||\r\ndevice == MKDEV(TTYAUX_MAJOR, 1) ||\r\n(tty->driver->type == TTY_DRIVER_TYPE_PTY &&\r\ntty->driver->subtype == PTY_TYPE_MASTER);\r\nif (!noctty &&\r\ncurrent->signal->leader &&\r\n!current->signal->tty &&\r\ntty->session == NULL) {\r\nif (filp->f_mode & FMODE_READ)\r\n__proc_set_tty(tty);\r\n}\r\nspin_unlock_irq(&current->sighand->siglock);\r\nread_unlock(&tasklist_lock);\r\ntty_unlock(tty);\r\nreturn 0;\r\n}\r\nstatic unsigned int tty_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct tty_struct *tty = file_tty(filp);\r\nstruct tty_ldisc *ld;\r\nint ret = 0;\r\nif (tty_paranoia_check(tty, file_inode(filp), "tty_poll"))\r\nreturn 0;\r\nld = tty_ldisc_ref_wait(tty);\r\nif (!ld)\r\nreturn hung_up_tty_poll(filp, wait);\r\nif (ld->ops->poll)\r\nret = ld->ops->poll(tty, filp, wait);\r\ntty_ldisc_deref(ld);\r\nreturn ret;\r\n}\r\nstatic int __tty_fasync(int fd, struct file *filp, int on)\r\n{\r\nstruct tty_struct *tty = file_tty(filp);\r\nunsigned long flags;\r\nint retval = 0;\r\nif (tty_paranoia_check(tty, file_inode(filp), "tty_fasync"))\r\ngoto out;\r\nretval = fasync_helper(fd, filp, on, &tty->fasync);\r\nif (retval <= 0)\r\ngoto out;\r\nif (on) {\r\nenum pid_type type;\r\nstruct pid *pid;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nif (tty->pgrp) {\r\npid = tty->pgrp;\r\ntype = PIDTYPE_PGID;\r\n} else {\r\npid = task_pid(current);\r\ntype = PIDTYPE_PID;\r\n}\r\nget_pid(pid);\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\n__f_setown(filp, pid, type, 0);\r\nput_pid(pid);\r\nretval = 0;\r\n}\r\nout:\r\nreturn retval;\r\n}\r\nstatic int tty_fasync(int fd, struct file *filp, int on)\r\n{\r\nstruct tty_struct *tty = file_tty(filp);\r\nint retval = -ENOTTY;\r\ntty_lock(tty);\r\nif (!tty_hung_up_p(filp))\r\nretval = __tty_fasync(fd, filp, on);\r\ntty_unlock(tty);\r\nreturn retval;\r\n}\r\nstatic int tiocsti(struct tty_struct *tty, char __user *p)\r\n{\r\nchar ch, mbz = 0;\r\nstruct tty_ldisc *ld;\r\nif ((current->signal->tty != tty) && !capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (get_user(ch, p))\r\nreturn -EFAULT;\r\ntty_audit_tiocsti(tty, ch);\r\nld = tty_ldisc_ref_wait(tty);\r\nif (!ld)\r\nreturn -EIO;\r\nld->ops->receive_buf(tty, &ch, &mbz, 1);\r\ntty_ldisc_deref(ld);\r\nreturn 0;\r\n}\r\nstatic int tiocgwinsz(struct tty_struct *tty, struct winsize __user *arg)\r\n{\r\nint err;\r\nmutex_lock(&tty->winsize_mutex);\r\nerr = copy_to_user(arg, &tty->winsize, sizeof(*arg));\r\nmutex_unlock(&tty->winsize_mutex);\r\nreturn err ? -EFAULT: 0;\r\n}\r\nint tty_do_resize(struct tty_struct *tty, struct winsize *ws)\r\n{\r\nstruct pid *pgrp;\r\nmutex_lock(&tty->winsize_mutex);\r\nif (!memcmp(ws, &tty->winsize, sizeof(*ws)))\r\ngoto done;\r\npgrp = tty_get_pgrp(tty);\r\nif (pgrp)\r\nkill_pgrp(pgrp, SIGWINCH, 1);\r\nput_pid(pgrp);\r\ntty->winsize = *ws;\r\ndone:\r\nmutex_unlock(&tty->winsize_mutex);\r\nreturn 0;\r\n}\r\nstatic int tiocswinsz(struct tty_struct *tty, struct winsize __user *arg)\r\n{\r\nstruct winsize tmp_ws;\r\nif (copy_from_user(&tmp_ws, arg, sizeof(*arg)))\r\nreturn -EFAULT;\r\nif (tty->ops->resize)\r\nreturn tty->ops->resize(tty, &tmp_ws);\r\nelse\r\nreturn tty_do_resize(tty, &tmp_ws);\r\n}\r\nstatic int tioccons(struct file *file)\r\n{\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (file->f_op->write == redirected_tty_write) {\r\nstruct file *f;\r\nspin_lock(&redirect_lock);\r\nf = redirect;\r\nredirect = NULL;\r\nspin_unlock(&redirect_lock);\r\nif (f)\r\nfput(f);\r\nreturn 0;\r\n}\r\nspin_lock(&redirect_lock);\r\nif (redirect) {\r\nspin_unlock(&redirect_lock);\r\nreturn -EBUSY;\r\n}\r\nredirect = get_file(file);\r\nspin_unlock(&redirect_lock);\r\nreturn 0;\r\n}\r\nstatic int fionbio(struct file *file, int __user *p)\r\n{\r\nint nonblock;\r\nif (get_user(nonblock, p))\r\nreturn -EFAULT;\r\nspin_lock(&file->f_lock);\r\nif (nonblock)\r\nfile->f_flags |= O_NONBLOCK;\r\nelse\r\nfile->f_flags &= ~O_NONBLOCK;\r\nspin_unlock(&file->f_lock);\r\nreturn 0;\r\n}\r\nstatic int tiocsctty(struct tty_struct *tty, struct file *file, int arg)\r\n{\r\nint ret = 0;\r\ntty_lock(tty);\r\nread_lock(&tasklist_lock);\r\nif (current->signal->leader && (task_session(current) == tty->session))\r\ngoto unlock;\r\nif (!current->signal->leader || current->signal->tty) {\r\nret = -EPERM;\r\ngoto unlock;\r\n}\r\nif (tty->session) {\r\nif (arg == 1 && capable(CAP_SYS_ADMIN)) {\r\nsession_clear_tty(tty->session);\r\n} else {\r\nret = -EPERM;\r\ngoto unlock;\r\n}\r\n}\r\nif ((file->f_mode & FMODE_READ) == 0 && !capable(CAP_SYS_ADMIN)) {\r\nret = -EPERM;\r\ngoto unlock;\r\n}\r\nproc_set_tty(tty);\r\nunlock:\r\nread_unlock(&tasklist_lock);\r\ntty_unlock(tty);\r\nreturn ret;\r\n}\r\nstruct pid *tty_get_pgrp(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nstruct pid *pgrp;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\npgrp = get_pid(tty->pgrp);\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nreturn pgrp;\r\n}\r\nstatic struct pid *session_of_pgrp(struct pid *pgrp)\r\n{\r\nstruct task_struct *p;\r\nstruct pid *sid = NULL;\r\np = pid_task(pgrp, PIDTYPE_PGID);\r\nif (p == NULL)\r\np = pid_task(pgrp, PIDTYPE_PID);\r\nif (p != NULL)\r\nsid = task_session(p);\r\nreturn sid;\r\n}\r\nstatic int tiocgpgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\r\n{\r\nstruct pid *pid;\r\nint ret;\r\nif (tty == real_tty && current->signal->tty != real_tty)\r\nreturn -ENOTTY;\r\npid = tty_get_pgrp(real_tty);\r\nret = put_user(pid_vnr(pid), p);\r\nput_pid(pid);\r\nreturn ret;\r\n}\r\nstatic int tiocspgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\r\n{\r\nstruct pid *pgrp;\r\npid_t pgrp_nr;\r\nint retval = tty_check_change(real_tty);\r\nif (retval == -EIO)\r\nreturn -ENOTTY;\r\nif (retval)\r\nreturn retval;\r\nif (!current->signal->tty ||\r\n(current->signal->tty != real_tty) ||\r\n(real_tty->session != task_session(current)))\r\nreturn -ENOTTY;\r\nif (get_user(pgrp_nr, p))\r\nreturn -EFAULT;\r\nif (pgrp_nr < 0)\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\npgrp = find_vpid(pgrp_nr);\r\nretval = -ESRCH;\r\nif (!pgrp)\r\ngoto out_unlock;\r\nretval = -EPERM;\r\nif (session_of_pgrp(pgrp) != task_session(current))\r\ngoto out_unlock;\r\nretval = 0;\r\nspin_lock_irq(&tty->ctrl_lock);\r\nput_pid(real_tty->pgrp);\r\nreal_tty->pgrp = get_pid(pgrp);\r\nspin_unlock_irq(&tty->ctrl_lock);\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn retval;\r\n}\r\nstatic int tiocgsid(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\r\n{\r\nif (tty == real_tty && current->signal->tty != real_tty)\r\nreturn -ENOTTY;\r\nif (!real_tty->session)\r\nreturn -ENOTTY;\r\nreturn put_user(pid_vnr(real_tty->session), p);\r\n}\r\nstatic int tiocsetd(struct tty_struct *tty, int __user *p)\r\n{\r\nint disc;\r\nint ret;\r\nif (get_user(disc, p))\r\nreturn -EFAULT;\r\nret = tty_set_ldisc(tty, disc);\r\nreturn ret;\r\n}\r\nstatic int tiocgetd(struct tty_struct *tty, int __user *p)\r\n{\r\nstruct tty_ldisc *ld;\r\nint ret;\r\nld = tty_ldisc_ref_wait(tty);\r\nif (!ld)\r\nreturn -EIO;\r\nret = put_user(ld->ops->num, p);\r\ntty_ldisc_deref(ld);\r\nreturn ret;\r\n}\r\nstatic int send_break(struct tty_struct *tty, unsigned int duration)\r\n{\r\nint retval;\r\nif (tty->ops->break_ctl == NULL)\r\nreturn 0;\r\nif (tty->driver->flags & TTY_DRIVER_HARDWARE_BREAK)\r\nretval = tty->ops->break_ctl(tty, duration);\r\nelse {\r\nif (tty_write_lock(tty, 0) < 0)\r\nreturn -EINTR;\r\nretval = tty->ops->break_ctl(tty, -1);\r\nif (retval)\r\ngoto out;\r\nif (!signal_pending(current))\r\nmsleep_interruptible(duration);\r\nretval = tty->ops->break_ctl(tty, 0);\r\nout:\r\ntty_write_unlock(tty);\r\nif (signal_pending(current))\r\nretval = -EINTR;\r\n}\r\nreturn retval;\r\n}\r\nstatic int tty_tiocmget(struct tty_struct *tty, int __user *p)\r\n{\r\nint retval = -EINVAL;\r\nif (tty->ops->tiocmget) {\r\nretval = tty->ops->tiocmget(tty);\r\nif (retval >= 0)\r\nretval = put_user(retval, p);\r\n}\r\nreturn retval;\r\n}\r\nstatic int tty_tiocmset(struct tty_struct *tty, unsigned int cmd,\r\nunsigned __user *p)\r\n{\r\nint retval;\r\nunsigned int set, clear, val;\r\nif (tty->ops->tiocmset == NULL)\r\nreturn -EINVAL;\r\nretval = get_user(val, p);\r\nif (retval)\r\nreturn retval;\r\nset = clear = 0;\r\nswitch (cmd) {\r\ncase TIOCMBIS:\r\nset = val;\r\nbreak;\r\ncase TIOCMBIC:\r\nclear = val;\r\nbreak;\r\ncase TIOCMSET:\r\nset = val;\r\nclear = ~val;\r\nbreak;\r\n}\r\nset &= TIOCM_DTR|TIOCM_RTS|TIOCM_OUT1|TIOCM_OUT2|TIOCM_LOOP;\r\nclear &= TIOCM_DTR|TIOCM_RTS|TIOCM_OUT1|TIOCM_OUT2|TIOCM_LOOP;\r\nreturn tty->ops->tiocmset(tty, set, clear);\r\n}\r\nstatic int tty_tiocgicount(struct tty_struct *tty, void __user *arg)\r\n{\r\nint retval = -EINVAL;\r\nstruct serial_icounter_struct icount;\r\nmemset(&icount, 0, sizeof(icount));\r\nif (tty->ops->get_icount)\r\nretval = tty->ops->get_icount(tty, &icount);\r\nif (retval != 0)\r\nreturn retval;\r\nif (copy_to_user(arg, &icount, sizeof(icount)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void tty_warn_deprecated_flags(struct serial_struct __user *ss)\r\n{\r\nstatic DEFINE_RATELIMIT_STATE(depr_flags,\r\nDEFAULT_RATELIMIT_INTERVAL,\r\nDEFAULT_RATELIMIT_BURST);\r\nchar comm[TASK_COMM_LEN];\r\nint flags;\r\nif (get_user(flags, &ss->flags))\r\nreturn;\r\nflags &= ASYNC_DEPRECATED;\r\nif (flags && __ratelimit(&depr_flags))\r\npr_warning("%s: '%s' is using deprecated serial flags (with no effect): %.8x\n",\r\n__func__, get_task_comm(comm, current), flags);\r\n}\r\nstatic struct tty_struct *tty_pair_get_tty(struct tty_struct *tty)\r\n{\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\r\ntty->driver->subtype == PTY_TYPE_MASTER)\r\ntty = tty->link;\r\nreturn tty;\r\n}\r\nlong tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct tty_struct *tty = file_tty(file);\r\nstruct tty_struct *real_tty;\r\nvoid __user *p = (void __user *)arg;\r\nint retval;\r\nstruct tty_ldisc *ld;\r\nif (tty_paranoia_check(tty, file_inode(file), "tty_ioctl"))\r\nreturn -EINVAL;\r\nreal_tty = tty_pair_get_tty(tty);\r\nswitch (cmd) {\r\ncase TIOCSETD:\r\ncase TIOCSBRK:\r\ncase TIOCCBRK:\r\ncase TCSBRK:\r\ncase TCSBRKP:\r\nretval = tty_check_change(tty);\r\nif (retval)\r\nreturn retval;\r\nif (cmd != TIOCCBRK) {\r\ntty_wait_until_sent(tty, 0);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\n}\r\nbreak;\r\n}\r\nswitch (cmd) {\r\ncase TIOCSTI:\r\nreturn tiocsti(tty, p);\r\ncase TIOCGWINSZ:\r\nreturn tiocgwinsz(real_tty, p);\r\ncase TIOCSWINSZ:\r\nreturn tiocswinsz(real_tty, p);\r\ncase TIOCCONS:\r\nreturn real_tty != tty ? -EINVAL : tioccons(file);\r\ncase FIONBIO:\r\nreturn fionbio(file, p);\r\ncase TIOCEXCL:\r\nset_bit(TTY_EXCLUSIVE, &tty->flags);\r\nreturn 0;\r\ncase TIOCNXCL:\r\nclear_bit(TTY_EXCLUSIVE, &tty->flags);\r\nreturn 0;\r\ncase TIOCGEXCL:\r\n{\r\nint excl = test_bit(TTY_EXCLUSIVE, &tty->flags);\r\nreturn put_user(excl, (int __user *)p);\r\n}\r\ncase TIOCNOTTY:\r\nif (current->signal->tty != tty)\r\nreturn -ENOTTY;\r\nno_tty();\r\nreturn 0;\r\ncase TIOCSCTTY:\r\nreturn tiocsctty(real_tty, file, arg);\r\ncase TIOCGPGRP:\r\nreturn tiocgpgrp(tty, real_tty, p);\r\ncase TIOCSPGRP:\r\nreturn tiocspgrp(tty, real_tty, p);\r\ncase TIOCGSID:\r\nreturn tiocgsid(tty, real_tty, p);\r\ncase TIOCGETD:\r\nreturn tiocgetd(tty, p);\r\ncase TIOCSETD:\r\nreturn tiocsetd(tty, p);\r\ncase TIOCVHANGUP:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\ntty_vhangup(tty);\r\nreturn 0;\r\ncase TIOCGDEV:\r\n{\r\nunsigned int ret = new_encode_dev(tty_devnum(real_tty));\r\nreturn put_user(ret, (unsigned int __user *)p);\r\n}\r\ncase TIOCSBRK:\r\nif (tty->ops->break_ctl)\r\nreturn tty->ops->break_ctl(tty, -1);\r\nreturn 0;\r\ncase TIOCCBRK:\r\nif (tty->ops->break_ctl)\r\nreturn tty->ops->break_ctl(tty, 0);\r\nreturn 0;\r\ncase TCSBRK:\r\nif (!arg)\r\nreturn send_break(tty, 250);\r\nreturn 0;\r\ncase TCSBRKP:\r\nreturn send_break(tty, arg ? arg*100 : 250);\r\ncase TIOCMGET:\r\nreturn tty_tiocmget(tty, p);\r\ncase TIOCMSET:\r\ncase TIOCMBIC:\r\ncase TIOCMBIS:\r\nreturn tty_tiocmset(tty, cmd, p);\r\ncase TIOCGICOUNT:\r\nretval = tty_tiocgicount(tty, p);\r\nif (retval != -EINVAL)\r\nreturn retval;\r\nbreak;\r\ncase TCFLSH:\r\nswitch (arg) {\r\ncase TCIFLUSH:\r\ncase TCIOFLUSH:\r\ntty_buffer_flush(tty, NULL);\r\nbreak;\r\n}\r\nbreak;\r\ncase TIOCSSERIAL:\r\ntty_warn_deprecated_flags(p);\r\nbreak;\r\n}\r\nif (tty->ops->ioctl) {\r\nretval = tty->ops->ioctl(tty, cmd, arg);\r\nif (retval != -ENOIOCTLCMD)\r\nreturn retval;\r\n}\r\nld = tty_ldisc_ref_wait(tty);\r\nif (!ld)\r\nreturn hung_up_tty_ioctl(file, cmd, arg);\r\nretval = -EINVAL;\r\nif (ld->ops->ioctl) {\r\nretval = ld->ops->ioctl(tty, file, cmd, arg);\r\nif (retval == -ENOIOCTLCMD)\r\nretval = -ENOTTY;\r\n}\r\ntty_ldisc_deref(ld);\r\nreturn retval;\r\n}\r\nstatic long tty_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct tty_struct *tty = file_tty(file);\r\nstruct tty_ldisc *ld;\r\nint retval = -ENOIOCTLCMD;\r\nif (tty_paranoia_check(tty, file_inode(file), "tty_ioctl"))\r\nreturn -EINVAL;\r\nif (tty->ops->compat_ioctl) {\r\nretval = tty->ops->compat_ioctl(tty, cmd, arg);\r\nif (retval != -ENOIOCTLCMD)\r\nreturn retval;\r\n}\r\nld = tty_ldisc_ref_wait(tty);\r\nif (!ld)\r\nreturn hung_up_tty_compat_ioctl(file, cmd, arg);\r\nif (ld->ops->compat_ioctl)\r\nretval = ld->ops->compat_ioctl(tty, file, cmd, arg);\r\nelse\r\nretval = n_tty_compat_ioctl_helper(tty, file, cmd, arg);\r\ntty_ldisc_deref(ld);\r\nreturn retval;\r\n}\r\nstatic int this_tty(const void *t, struct file *file, unsigned fd)\r\n{\r\nif (likely(file->f_op->read != tty_read))\r\nreturn 0;\r\nreturn file_tty(file) != t ? 0 : fd + 1;\r\n}\r\nvoid __do_SAK(struct tty_struct *tty)\r\n{\r\n#ifdef TTY_SOFT_SAK\r\ntty_hangup(tty);\r\n#else\r\nstruct task_struct *g, *p;\r\nstruct pid *session;\r\nint i;\r\nif (!tty)\r\nreturn;\r\nsession = tty->session;\r\ntty_ldisc_flush(tty);\r\ntty_driver_flush_buffer(tty);\r\nread_lock(&tasklist_lock);\r\ndo_each_pid_task(session, PIDTYPE_SID, p) {\r\ntty_notice(tty, "SAK: killed process %d (%s): by session\n",\r\ntask_pid_nr(p), p->comm);\r\nsend_sig(SIGKILL, p, 1);\r\n} while_each_pid_task(session, PIDTYPE_SID, p);\r\ndo_each_thread(g, p) {\r\nif (p->signal->tty == tty) {\r\ntty_notice(tty, "SAK: killed process %d (%s): by controlling tty\n",\r\ntask_pid_nr(p), p->comm);\r\nsend_sig(SIGKILL, p, 1);\r\ncontinue;\r\n}\r\ntask_lock(p);\r\ni = iterate_fd(p->files, 0, this_tty, tty);\r\nif (i != 0) {\r\ntty_notice(tty, "SAK: killed process %d (%s): by fd#%d\n",\r\ntask_pid_nr(p), p->comm, i - 1);\r\nforce_sig(SIGKILL, p);\r\n}\r\ntask_unlock(p);\r\n} while_each_thread(g, p);\r\nread_unlock(&tasklist_lock);\r\n#endif\r\n}\r\nstatic void do_SAK_work(struct work_struct *work)\r\n{\r\nstruct tty_struct *tty =\r\ncontainer_of(work, struct tty_struct, SAK_work);\r\n__do_SAK(tty);\r\n}\r\nvoid do_SAK(struct tty_struct *tty)\r\n{\r\nif (!tty)\r\nreturn;\r\nschedule_work(&tty->SAK_work);\r\n}\r\nstatic int dev_match_devt(struct device *dev, const void *data)\r\n{\r\nconst dev_t *devt = data;\r\nreturn dev->devt == *devt;\r\n}\r\nstatic struct device *tty_get_device(struct tty_struct *tty)\r\n{\r\ndev_t devt = tty_devnum(tty);\r\nreturn class_find_device(tty_class, NULL, &devt, dev_match_devt);\r\n}\r\nstruct tty_struct *alloc_tty_struct(struct tty_driver *driver, int idx)\r\n{\r\nstruct tty_struct *tty;\r\ntty = kzalloc(sizeof(*tty), GFP_KERNEL);\r\nif (!tty)\r\nreturn NULL;\r\nkref_init(&tty->kref);\r\ntty->magic = TTY_MAGIC;\r\ntty_ldisc_init(tty);\r\ntty->session = NULL;\r\ntty->pgrp = NULL;\r\nmutex_init(&tty->legacy_mutex);\r\nmutex_init(&tty->throttle_mutex);\r\ninit_rwsem(&tty->termios_rwsem);\r\nmutex_init(&tty->winsize_mutex);\r\ninit_ldsem(&tty->ldisc_sem);\r\ninit_waitqueue_head(&tty->write_wait);\r\ninit_waitqueue_head(&tty->read_wait);\r\nINIT_WORK(&tty->hangup_work, do_tty_hangup);\r\nmutex_init(&tty->atomic_write_lock);\r\nspin_lock_init(&tty->ctrl_lock);\r\nspin_lock_init(&tty->flow_lock);\r\nspin_lock_init(&tty->files_lock);\r\nINIT_LIST_HEAD(&tty->tty_files);\r\nINIT_WORK(&tty->SAK_work, do_SAK_work);\r\ntty->driver = driver;\r\ntty->ops = driver->ops;\r\ntty->index = idx;\r\ntty_line_name(driver, idx, tty->name);\r\ntty->dev = tty_get_device(tty);\r\nreturn tty;\r\n}\r\nint tty_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nif (tty->ops->put_char)\r\nreturn tty->ops->put_char(tty, ch);\r\nreturn tty->ops->write(tty, &ch, 1);\r\n}\r\nstatic int tty_cdev_add(struct tty_driver *driver, dev_t dev,\r\nunsigned int index, unsigned int count)\r\n{\r\nint err;\r\ndriver->cdevs[index] = cdev_alloc();\r\nif (!driver->cdevs[index])\r\nreturn -ENOMEM;\r\ndriver->cdevs[index]->ops = &tty_fops;\r\ndriver->cdevs[index]->owner = driver->owner;\r\nerr = cdev_add(driver->cdevs[index], dev, count);\r\nif (err)\r\nkobject_put(&driver->cdevs[index]->kobj);\r\nreturn err;\r\n}\r\nstruct device *tty_register_device(struct tty_driver *driver, unsigned index,\r\nstruct device *device)\r\n{\r\nreturn tty_register_device_attr(driver, index, device, NULL, NULL);\r\n}\r\nstatic void tty_device_create_release(struct device *dev)\r\n{\r\ndev_dbg(dev, "releasing...\n");\r\nkfree(dev);\r\n}\r\nstruct device *tty_register_device_attr(struct tty_driver *driver,\r\nunsigned index, struct device *device,\r\nvoid *drvdata,\r\nconst struct attribute_group **attr_grp)\r\n{\r\nchar name[64];\r\ndev_t devt = MKDEV(driver->major, driver->minor_start) + index;\r\nstruct device *dev = NULL;\r\nint retval = -ENODEV;\r\nbool cdev = false;\r\nif (index >= driver->num) {\r\npr_err("%s: Attempt to register invalid tty line number (%d)\n",\r\ndriver->name, index);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (driver->type == TTY_DRIVER_TYPE_PTY)\r\npty_line_name(driver, index, name);\r\nelse\r\ntty_line_name(driver, index, name);\r\nif (!(driver->flags & TTY_DRIVER_DYNAMIC_ALLOC)) {\r\nretval = tty_cdev_add(driver, devt, index, 1);\r\nif (retval)\r\ngoto error;\r\ncdev = true;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\ndev->devt = devt;\r\ndev->class = tty_class;\r\ndev->parent = device;\r\ndev->release = tty_device_create_release;\r\ndev_set_name(dev, "%s", name);\r\ndev->groups = attr_grp;\r\ndev_set_drvdata(dev, drvdata);\r\nretval = device_register(dev);\r\nif (retval)\r\ngoto error;\r\nreturn dev;\r\nerror:\r\nput_device(dev);\r\nif (cdev) {\r\ncdev_del(driver->cdevs[index]);\r\ndriver->cdevs[index] = NULL;\r\n}\r\nreturn ERR_PTR(retval);\r\n}\r\nvoid tty_unregister_device(struct tty_driver *driver, unsigned index)\r\n{\r\ndevice_destroy(tty_class,\r\nMKDEV(driver->major, driver->minor_start) + index);\r\nif (!(driver->flags & TTY_DRIVER_DYNAMIC_ALLOC)) {\r\ncdev_del(driver->cdevs[index]);\r\ndriver->cdevs[index] = NULL;\r\n}\r\n}\r\nstruct tty_driver *__tty_alloc_driver(unsigned int lines, struct module *owner,\r\nunsigned long flags)\r\n{\r\nstruct tty_driver *driver;\r\nunsigned int cdevs = 1;\r\nint err;\r\nif (!lines || (flags & TTY_DRIVER_UNNUMBERED_NODE && lines > 1))\r\nreturn ERR_PTR(-EINVAL);\r\ndriver = kzalloc(sizeof(struct tty_driver), GFP_KERNEL);\r\nif (!driver)\r\nreturn ERR_PTR(-ENOMEM);\r\nkref_init(&driver->kref);\r\ndriver->magic = TTY_DRIVER_MAGIC;\r\ndriver->num = lines;\r\ndriver->owner = owner;\r\ndriver->flags = flags;\r\nif (!(flags & TTY_DRIVER_DEVPTS_MEM)) {\r\ndriver->ttys = kcalloc(lines, sizeof(*driver->ttys),\r\nGFP_KERNEL);\r\ndriver->termios = kcalloc(lines, sizeof(*driver->termios),\r\nGFP_KERNEL);\r\nif (!driver->ttys || !driver->termios) {\r\nerr = -ENOMEM;\r\ngoto err_free_all;\r\n}\r\n}\r\nif (!(flags & TTY_DRIVER_DYNAMIC_ALLOC)) {\r\ndriver->ports = kcalloc(lines, sizeof(*driver->ports),\r\nGFP_KERNEL);\r\nif (!driver->ports) {\r\nerr = -ENOMEM;\r\ngoto err_free_all;\r\n}\r\ncdevs = lines;\r\n}\r\ndriver->cdevs = kcalloc(cdevs, sizeof(*driver->cdevs), GFP_KERNEL);\r\nif (!driver->cdevs) {\r\nerr = -ENOMEM;\r\ngoto err_free_all;\r\n}\r\nreturn driver;\r\nerr_free_all:\r\nkfree(driver->ports);\r\nkfree(driver->ttys);\r\nkfree(driver->termios);\r\nkfree(driver->cdevs);\r\nkfree(driver);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void destruct_tty_driver(struct kref *kref)\r\n{\r\nstruct tty_driver *driver = container_of(kref, struct tty_driver, kref);\r\nint i;\r\nstruct ktermios *tp;\r\nif (driver->flags & TTY_DRIVER_INSTALLED) {\r\nfor (i = 0; i < driver->num; i++) {\r\ntp = driver->termios[i];\r\nif (tp) {\r\ndriver->termios[i] = NULL;\r\nkfree(tp);\r\n}\r\nif (!(driver->flags & TTY_DRIVER_DYNAMIC_DEV))\r\ntty_unregister_device(driver, i);\r\n}\r\nproc_tty_unregister_driver(driver);\r\nif (driver->flags & TTY_DRIVER_DYNAMIC_ALLOC)\r\ncdev_del(driver->cdevs[0]);\r\n}\r\nkfree(driver->cdevs);\r\nkfree(driver->ports);\r\nkfree(driver->termios);\r\nkfree(driver->ttys);\r\nkfree(driver);\r\n}\r\nvoid tty_driver_kref_put(struct tty_driver *driver)\r\n{\r\nkref_put(&driver->kref, destruct_tty_driver);\r\n}\r\nvoid tty_set_operations(struct tty_driver *driver,\r\nconst struct tty_operations *op)\r\n{\r\ndriver->ops = op;\r\n}\r\nvoid put_tty_driver(struct tty_driver *d)\r\n{\r\ntty_driver_kref_put(d);\r\n}\r\nint tty_register_driver(struct tty_driver *driver)\r\n{\r\nint error;\r\nint i;\r\ndev_t dev;\r\nstruct device *d;\r\nif (!driver->major) {\r\nerror = alloc_chrdev_region(&dev, driver->minor_start,\r\ndriver->num, driver->name);\r\nif (!error) {\r\ndriver->major = MAJOR(dev);\r\ndriver->minor_start = MINOR(dev);\r\n}\r\n} else {\r\ndev = MKDEV(driver->major, driver->minor_start);\r\nerror = register_chrdev_region(dev, driver->num, driver->name);\r\n}\r\nif (error < 0)\r\ngoto err;\r\nif (driver->flags & TTY_DRIVER_DYNAMIC_ALLOC) {\r\nerror = tty_cdev_add(driver, dev, 0, driver->num);\r\nif (error)\r\ngoto err_unreg_char;\r\n}\r\nmutex_lock(&tty_mutex);\r\nlist_add(&driver->tty_drivers, &tty_drivers);\r\nmutex_unlock(&tty_mutex);\r\nif (!(driver->flags & TTY_DRIVER_DYNAMIC_DEV)) {\r\nfor (i = 0; i < driver->num; i++) {\r\nd = tty_register_device(driver, i, NULL);\r\nif (IS_ERR(d)) {\r\nerror = PTR_ERR(d);\r\ngoto err_unreg_devs;\r\n}\r\n}\r\n}\r\nproc_tty_register_driver(driver);\r\ndriver->flags |= TTY_DRIVER_INSTALLED;\r\nreturn 0;\r\nerr_unreg_devs:\r\nfor (i--; i >= 0; i--)\r\ntty_unregister_device(driver, i);\r\nmutex_lock(&tty_mutex);\r\nlist_del(&driver->tty_drivers);\r\nmutex_unlock(&tty_mutex);\r\nerr_unreg_char:\r\nunregister_chrdev_region(dev, driver->num);\r\nerr:\r\nreturn error;\r\n}\r\nint tty_unregister_driver(struct tty_driver *driver)\r\n{\r\n#if 0\r\nif (driver->refcount)\r\nreturn -EBUSY;\r\n#endif\r\nunregister_chrdev_region(MKDEV(driver->major, driver->minor_start),\r\ndriver->num);\r\nmutex_lock(&tty_mutex);\r\nlist_del(&driver->tty_drivers);\r\nmutex_unlock(&tty_mutex);\r\nreturn 0;\r\n}\r\ndev_t tty_devnum(struct tty_struct *tty)\r\n{\r\nreturn MKDEV(tty->driver->major, tty->driver->minor_start) + tty->index;\r\n}\r\nvoid tty_default_fops(struct file_operations *fops)\r\n{\r\n*fops = tty_fops;\r\n}\r\nvoid __init console_init(void)\r\n{\r\ninitcall_t *call;\r\nn_tty_init();\r\ncall = __con_initcall_start;\r\nwhile (call < __con_initcall_end) {\r\n(*call)();\r\ncall++;\r\n}\r\n}\r\nstatic char *tty_devnode(struct device *dev, umode_t *mode)\r\n{\r\nif (!mode)\r\nreturn NULL;\r\nif (dev->devt == MKDEV(TTYAUX_MAJOR, 0) ||\r\ndev->devt == MKDEV(TTYAUX_MAJOR, 2))\r\n*mode = 0666;\r\nreturn NULL;\r\n}\r\nstatic int __init tty_class_init(void)\r\n{\r\ntty_class = class_create(THIS_MODULE, "tty");\r\nif (IS_ERR(tty_class))\r\nreturn PTR_ERR(tty_class);\r\ntty_class->devnode = tty_devnode;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_cons_active(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct console *cs[16];\r\nint i = 0;\r\nstruct console *c;\r\nssize_t count = 0;\r\nconsole_lock();\r\nfor_each_console(c) {\r\nif (!c->device)\r\ncontinue;\r\nif (!c->write)\r\ncontinue;\r\nif ((c->flags & CON_ENABLED) == 0)\r\ncontinue;\r\ncs[i++] = c;\r\nif (i >= ARRAY_SIZE(cs))\r\nbreak;\r\n}\r\nwhile (i--) {\r\nint index = cs[i]->index;\r\nstruct tty_driver *drv = cs[i]->device(cs[i], &index);\r\nif (drv && (cs[i]->index > 0 || drv->major != TTY_MAJOR))\r\ncount += tty_line_name(drv, index, buf + count);\r\nelse\r\ncount += sprintf(buf + count, "%s%d",\r\ncs[i]->name, cs[i]->index);\r\ncount += sprintf(buf + count, "%c", i ? ' ':'\n');\r\n}\r\nconsole_unlock();\r\nreturn count;\r\n}\r\nvoid console_sysfs_notify(void)\r\n{\r\nif (consdev)\r\nsysfs_notify(&consdev->kobj, NULL, "active");\r\n}\r\nint __init tty_init(void)\r\n{\r\ncdev_init(&tty_cdev, &tty_fops);\r\nif (cdev_add(&tty_cdev, MKDEV(TTYAUX_MAJOR, 0), 1) ||\r\nregister_chrdev_region(MKDEV(TTYAUX_MAJOR, 0), 1, "/dev/tty") < 0)\r\npanic("Couldn't register /dev/tty driver\n");\r\ndevice_create(tty_class, NULL, MKDEV(TTYAUX_MAJOR, 0), NULL, "tty");\r\ncdev_init(&console_cdev, &console_fops);\r\nif (cdev_add(&console_cdev, MKDEV(TTYAUX_MAJOR, 1), 1) ||\r\nregister_chrdev_region(MKDEV(TTYAUX_MAJOR, 1), 1, "/dev/console") < 0)\r\npanic("Couldn't register /dev/console driver\n");\r\nconsdev = device_create_with_groups(tty_class, NULL,\r\nMKDEV(TTYAUX_MAJOR, 1), NULL,\r\ncons_dev_groups, "console");\r\nif (IS_ERR(consdev))\r\nconsdev = NULL;\r\n#ifdef CONFIG_VT\r\nvty_init(&console_fops);\r\n#endif\r\nreturn 0;\r\n}
