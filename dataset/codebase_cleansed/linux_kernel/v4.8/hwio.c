static int __cw1200_reg_read(struct cw1200_common *priv, u16 addr,\r\nvoid *buf, size_t buf_len, int buf_id)\r\n{\r\nu16 addr_sdio;\r\nu32 sdio_reg_addr_17bit;\r\nif (WARN_ON(((unsigned long)buf & 3) && (buf_len > 4))) {\r\npr_err("buffer is not aligned.\n");\r\nreturn -EINVAL;\r\n}\r\naddr_sdio = SPI_REG_ADDR_TO_SDIO(addr);\r\nsdio_reg_addr_17bit = SDIO_ADDR17BIT(buf_id, 0, 0, addr_sdio);\r\nreturn priv->hwbus_ops->hwbus_memcpy_fromio(priv->hwbus_priv,\r\nsdio_reg_addr_17bit,\r\nbuf, buf_len);\r\n}\r\nstatic int __cw1200_reg_write(struct cw1200_common *priv, u16 addr,\r\nconst void *buf, size_t buf_len, int buf_id)\r\n{\r\nu16 addr_sdio;\r\nu32 sdio_reg_addr_17bit;\r\naddr_sdio = SPI_REG_ADDR_TO_SDIO(addr);\r\nsdio_reg_addr_17bit = SDIO_ADDR17BIT(buf_id, 0, 0, addr_sdio);\r\nreturn priv->hwbus_ops->hwbus_memcpy_toio(priv->hwbus_priv,\r\nsdio_reg_addr_17bit,\r\nbuf, buf_len);\r\n}\r\nstatic inline int __cw1200_reg_read_32(struct cw1200_common *priv,\r\nu16 addr, u32 *val)\r\n{\r\n__le32 tmp;\r\nint i = __cw1200_reg_read(priv, addr, &tmp, sizeof(tmp), 0);\r\n*val = le32_to_cpu(tmp);\r\nreturn i;\r\n}\r\nstatic inline int __cw1200_reg_write_32(struct cw1200_common *priv,\r\nu16 addr, u32 val)\r\n{\r\n__le32 tmp = cpu_to_le32(val);\r\nreturn __cw1200_reg_write(priv, addr, &tmp, sizeof(tmp), 0);\r\n}\r\nstatic inline int __cw1200_reg_read_16(struct cw1200_common *priv,\r\nu16 addr, u16 *val)\r\n{\r\n__le16 tmp;\r\nint i = __cw1200_reg_read(priv, addr, &tmp, sizeof(tmp), 0);\r\n*val = le16_to_cpu(tmp);\r\nreturn i;\r\n}\r\nstatic inline int __cw1200_reg_write_16(struct cw1200_common *priv,\r\nu16 addr, u16 val)\r\n{\r\n__le16 tmp = cpu_to_le16(val);\r\nreturn __cw1200_reg_write(priv, addr, &tmp, sizeof(tmp), 0);\r\n}\r\nint cw1200_reg_read(struct cw1200_common *priv, u16 addr, void *buf,\r\nsize_t buf_len)\r\n{\r\nint ret;\r\npriv->hwbus_ops->lock(priv->hwbus_priv);\r\nret = __cw1200_reg_read(priv, addr, buf, buf_len, 0);\r\npriv->hwbus_ops->unlock(priv->hwbus_priv);\r\nreturn ret;\r\n}\r\nint cw1200_reg_write(struct cw1200_common *priv, u16 addr, const void *buf,\r\nsize_t buf_len)\r\n{\r\nint ret;\r\npriv->hwbus_ops->lock(priv->hwbus_priv);\r\nret = __cw1200_reg_write(priv, addr, buf, buf_len, 0);\r\npriv->hwbus_ops->unlock(priv->hwbus_priv);\r\nreturn ret;\r\n}\r\nint cw1200_data_read(struct cw1200_common *priv, void *buf, size_t buf_len)\r\n{\r\nint ret, retry = 1;\r\nint buf_id_rx = priv->buf_id_rx;\r\npriv->hwbus_ops->lock(priv->hwbus_priv);\r\nwhile (retry <= MAX_RETRY) {\r\nret = __cw1200_reg_read(priv,\r\nST90TDS_IN_OUT_QUEUE_REG_ID, buf,\r\nbuf_len, buf_id_rx + 1);\r\nif (!ret) {\r\nbuf_id_rx = (buf_id_rx + 1) & 3;\r\npriv->buf_id_rx = buf_id_rx;\r\nbreak;\r\n} else {\r\nretry++;\r\nmdelay(1);\r\npr_err("error :[%d]\n", ret);\r\n}\r\n}\r\npriv->hwbus_ops->unlock(priv->hwbus_priv);\r\nreturn ret;\r\n}\r\nint cw1200_data_write(struct cw1200_common *priv, const void *buf,\r\nsize_t buf_len)\r\n{\r\nint ret, retry = 1;\r\nint buf_id_tx = priv->buf_id_tx;\r\npriv->hwbus_ops->lock(priv->hwbus_priv);\r\nwhile (retry <= MAX_RETRY) {\r\nret = __cw1200_reg_write(priv,\r\nST90TDS_IN_OUT_QUEUE_REG_ID, buf,\r\nbuf_len, buf_id_tx);\r\nif (!ret) {\r\nbuf_id_tx = (buf_id_tx + 1) & 31;\r\npriv->buf_id_tx = buf_id_tx;\r\nbreak;\r\n} else {\r\nretry++;\r\nmdelay(1);\r\npr_err("error :[%d]\n", ret);\r\n}\r\n}\r\npriv->hwbus_ops->unlock(priv->hwbus_priv);\r\nreturn ret;\r\n}\r\nint cw1200_indirect_read(struct cw1200_common *priv, u32 addr, void *buf,\r\nsize_t buf_len, u32 prefetch, u16 port_addr)\r\n{\r\nu32 val32 = 0;\r\nint i, ret;\r\nif ((buf_len / 2) >= 0x1000) {\r\npr_err("Can't read more than 0xfff words.\n");\r\nreturn -EINVAL;\r\n}\r\npriv->hwbus_ops->lock(priv->hwbus_priv);\r\nret = __cw1200_reg_write_32(priv, ST90TDS_SRAM_BASE_ADDR_REG_ID, addr);\r\nif (ret < 0) {\r\npr_err("Can't write address register.\n");\r\ngoto out;\r\n}\r\nret = __cw1200_reg_read_32(priv, ST90TDS_CONFIG_REG_ID, &val32);\r\nif (ret < 0) {\r\npr_err("Can't read config register.\n");\r\ngoto out;\r\n}\r\nret = __cw1200_reg_write_32(priv, ST90TDS_CONFIG_REG_ID,\r\nval32 | prefetch);\r\nif (ret < 0) {\r\npr_err("Can't write prefetch bit.\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < 20; i++) {\r\nret = __cw1200_reg_read_32(priv, ST90TDS_CONFIG_REG_ID, &val32);\r\nif (ret < 0) {\r\npr_err("Can't check prefetch bit.\n");\r\ngoto out;\r\n}\r\nif (!(val32 & prefetch))\r\nbreak;\r\nmdelay(i);\r\n}\r\nif (val32 & prefetch) {\r\npr_err("Prefetch bit is not cleared.\n");\r\ngoto out;\r\n}\r\nret = __cw1200_reg_read(priv, port_addr, buf, buf_len, 0);\r\nif (ret < 0) {\r\npr_err("Can't read data port.\n");\r\ngoto out;\r\n}\r\nout:\r\npriv->hwbus_ops->unlock(priv->hwbus_priv);\r\nreturn ret;\r\n}\r\nint cw1200_apb_write(struct cw1200_common *priv, u32 addr, const void *buf,\r\nsize_t buf_len)\r\n{\r\nint ret;\r\nif ((buf_len / 2) >= 0x1000) {\r\npr_err("Can't write more than 0xfff words.\n");\r\nreturn -EINVAL;\r\n}\r\npriv->hwbus_ops->lock(priv->hwbus_priv);\r\nret = __cw1200_reg_write_32(priv, ST90TDS_SRAM_BASE_ADDR_REG_ID, addr);\r\nif (ret < 0) {\r\npr_err("Can't write address register.\n");\r\ngoto out;\r\n}\r\nret = __cw1200_reg_write(priv, ST90TDS_SRAM_DPORT_REG_ID,\r\nbuf, buf_len, 0);\r\nif (ret < 0) {\r\npr_err("Can't write data port.\n");\r\ngoto out;\r\n}\r\nout:\r\npriv->hwbus_ops->unlock(priv->hwbus_priv);\r\nreturn ret;\r\n}\r\nint __cw1200_irq_enable(struct cw1200_common *priv, int enable)\r\n{\r\nu32 val32;\r\nu16 val16;\r\nint ret;\r\nif (HIF_8601_SILICON == priv->hw_type) {\r\nret = __cw1200_reg_read_32(priv, ST90TDS_CONFIG_REG_ID, &val32);\r\nif (ret < 0) {\r\npr_err("Can't read config register.\n");\r\nreturn ret;\r\n}\r\nif (enable)\r\nval32 |= ST90TDS_CONF_IRQ_RDY_ENABLE;\r\nelse\r\nval32 &= ~ST90TDS_CONF_IRQ_RDY_ENABLE;\r\nret = __cw1200_reg_write_32(priv, ST90TDS_CONFIG_REG_ID, val32);\r\nif (ret < 0) {\r\npr_err("Can't write config register.\n");\r\nreturn ret;\r\n}\r\n} else {\r\nret = __cw1200_reg_read_16(priv, ST90TDS_CONFIG_REG_ID, &val16);\r\nif (ret < 0) {\r\npr_err("Can't read control register.\n");\r\nreturn ret;\r\n}\r\nif (enable)\r\nval16 |= ST90TDS_CONT_IRQ_RDY_ENABLE;\r\nelse\r\nval16 &= ~ST90TDS_CONT_IRQ_RDY_ENABLE;\r\nret = __cw1200_reg_write_16(priv, ST90TDS_CONFIG_REG_ID, val16);\r\nif (ret < 0) {\r\npr_err("Can't write control register.\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
