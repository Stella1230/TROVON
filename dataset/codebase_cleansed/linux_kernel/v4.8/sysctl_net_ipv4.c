static void set_local_port_range(struct net *net, int range[2])\r\n{\r\nbool same_parity = !((range[0] ^ range[1]) & 1);\r\nwrite_seqlock_bh(&net->ipv4.ip_local_ports.lock);\r\nif (same_parity && !net->ipv4.ip_local_ports.warned) {\r\nnet->ipv4.ip_local_ports.warned = true;\r\npr_err_ratelimited("ip_local_port_range: prefer different parity for start/end values.\n");\r\n}\r\nnet->ipv4.ip_local_ports.range[0] = range[0];\r\nnet->ipv4.ip_local_ports.range[1] = range[1];\r\nwrite_sequnlock_bh(&net->ipv4.ip_local_ports.lock);\r\n}\r\nstatic int ipv4_local_port_range(struct ctl_table *table, int write,\r\nvoid __user *buffer,\r\nsize_t *lenp, loff_t *ppos)\r\n{\r\nstruct net *net =\r\ncontainer_of(table->data, struct net, ipv4.ip_local_ports.range);\r\nint ret;\r\nint range[2];\r\nstruct ctl_table tmp = {\r\n.data = &range,\r\n.maxlen = sizeof(range),\r\n.mode = table->mode,\r\n.extra1 = &ip_local_port_range_min,\r\n.extra2 = &ip_local_port_range_max,\r\n};\r\ninet_get_local_port_range(net, &range[0], &range[1]);\r\nret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\r\nif (write && ret == 0) {\r\nif (range[1] < range[0])\r\nret = -EINVAL;\r\nelse\r\nset_local_port_range(net, range);\r\n}\r\nreturn ret;\r\n}\r\nstatic void inet_get_ping_group_range_table(struct ctl_table *table, kgid_t *low, kgid_t *high)\r\n{\r\nkgid_t *data = table->data;\r\nstruct net *net =\r\ncontainer_of(table->data, struct net, ipv4.ping_group_range.range);\r\nunsigned int seq;\r\ndo {\r\nseq = read_seqbegin(&net->ipv4.ip_local_ports.lock);\r\n*low = data[0];\r\n*high = data[1];\r\n} while (read_seqretry(&net->ipv4.ip_local_ports.lock, seq));\r\n}\r\nstatic void set_ping_group_range(struct ctl_table *table, kgid_t low, kgid_t high)\r\n{\r\nkgid_t *data = table->data;\r\nstruct net *net =\r\ncontainer_of(table->data, struct net, ipv4.ping_group_range.range);\r\nwrite_seqlock(&net->ipv4.ip_local_ports.lock);\r\ndata[0] = low;\r\ndata[1] = high;\r\nwrite_sequnlock(&net->ipv4.ip_local_ports.lock);\r\n}\r\nstatic int ipv4_ping_group_range(struct ctl_table *table, int write,\r\nvoid __user *buffer,\r\nsize_t *lenp, loff_t *ppos)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nint ret;\r\ngid_t urange[2];\r\nkgid_t low, high;\r\nstruct ctl_table tmp = {\r\n.data = &urange,\r\n.maxlen = sizeof(urange),\r\n.mode = table->mode,\r\n.extra1 = &ip_ping_group_range_min,\r\n.extra2 = &ip_ping_group_range_max,\r\n};\r\ninet_get_ping_group_range_table(table, &low, &high);\r\nurange[0] = from_kgid_munged(user_ns, low);\r\nurange[1] = from_kgid_munged(user_ns, high);\r\nret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\r\nif (write && ret == 0) {\r\nlow = make_kgid(user_ns, urange[0]);\r\nhigh = make_kgid(user_ns, urange[1]);\r\nif (!gid_valid(low) || !gid_valid(high) ||\r\n(urange[1] < urange[0]) || gid_lt(high, low)) {\r\nlow = make_kgid(&init_user_ns, 1);\r\nhigh = make_kgid(&init_user_ns, 0);\r\n}\r\nset_ping_group_range(table, low, high);\r\n}\r\nreturn ret;\r\n}\r\nstatic int proc_tcp_congestion_control(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nchar val[TCP_CA_NAME_MAX];\r\nstruct ctl_table tbl = {\r\n.data = val,\r\n.maxlen = TCP_CA_NAME_MAX,\r\n};\r\nint ret;\r\ntcp_get_default_congestion_control(val);\r\nret = proc_dostring(&tbl, write, buffer, lenp, ppos);\r\nif (write && ret == 0)\r\nret = tcp_set_default_congestion_control(val);\r\nreturn ret;\r\n}\r\nstatic int proc_tcp_available_congestion_control(struct ctl_table *ctl,\r\nint write,\r\nvoid __user *buffer, size_t *lenp,\r\nloff_t *ppos)\r\n{\r\nstruct ctl_table tbl = { .maxlen = TCP_CA_BUF_MAX, };\r\nint ret;\r\ntbl.data = kmalloc(tbl.maxlen, GFP_USER);\r\nif (!tbl.data)\r\nreturn -ENOMEM;\r\ntcp_get_available_congestion_control(tbl.data, TCP_CA_BUF_MAX);\r\nret = proc_dostring(&tbl, write, buffer, lenp, ppos);\r\nkfree(tbl.data);\r\nreturn ret;\r\n}\r\nstatic int proc_allowed_congestion_control(struct ctl_table *ctl,\r\nint write,\r\nvoid __user *buffer, size_t *lenp,\r\nloff_t *ppos)\r\n{\r\nstruct ctl_table tbl = { .maxlen = TCP_CA_BUF_MAX };\r\nint ret;\r\ntbl.data = kmalloc(tbl.maxlen, GFP_USER);\r\nif (!tbl.data)\r\nreturn -ENOMEM;\r\ntcp_get_allowed_congestion_control(tbl.data, tbl.maxlen);\r\nret = proc_dostring(&tbl, write, buffer, lenp, ppos);\r\nif (write && ret == 0)\r\nret = tcp_set_allowed_congestion_control(tbl.data);\r\nkfree(tbl.data);\r\nreturn ret;\r\n}\r\nstatic int proc_tcp_fastopen_key(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp,\r\nloff_t *ppos)\r\n{\r\nstruct ctl_table tbl = { .maxlen = (TCP_FASTOPEN_KEY_LENGTH * 2 + 10) };\r\nstruct tcp_fastopen_context *ctxt;\r\nint ret;\r\nu32 user_key[4];\r\ntbl.data = kmalloc(tbl.maxlen, GFP_KERNEL);\r\nif (!tbl.data)\r\nreturn -ENOMEM;\r\nrcu_read_lock();\r\nctxt = rcu_dereference(tcp_fastopen_ctx);\r\nif (ctxt)\r\nmemcpy(user_key, ctxt->key, TCP_FASTOPEN_KEY_LENGTH);\r\nelse\r\nmemset(user_key, 0, sizeof(user_key));\r\nrcu_read_unlock();\r\nsnprintf(tbl.data, tbl.maxlen, "%08x-%08x-%08x-%08x",\r\nuser_key[0], user_key[1], user_key[2], user_key[3]);\r\nret = proc_dostring(&tbl, write, buffer, lenp, ppos);\r\nif (write && ret == 0) {\r\nif (sscanf(tbl.data, "%x-%x-%x-%x", user_key, user_key + 1,\r\nuser_key + 2, user_key + 3) != 4) {\r\nret = -EINVAL;\r\ngoto bad_key;\r\n}\r\ntcp_fastopen_init_key_once(false);\r\ntcp_fastopen_reset_cipher(user_key, TCP_FASTOPEN_KEY_LENGTH);\r\n}\r\nbad_key:\r\npr_debug("proc FO key set 0x%x-%x-%x-%x <- 0x%s: %u\n",\r\nuser_key[0], user_key[1], user_key[2], user_key[3],\r\n(char *)tbl.data, ret);\r\nkfree(tbl.data);\r\nreturn ret;\r\n}\r\nstatic __net_init int ipv4_sysctl_init_net(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = ipv4_net_table;\r\nif (!net_eq(net, &init_net)) {\r\nint i;\r\ntable = kmemdup(table, sizeof(ipv4_net_table), GFP_KERNEL);\r\nif (!table)\r\ngoto err_alloc;\r\nfor (i = 0; i < ARRAY_SIZE(ipv4_net_table) - 1; i++)\r\ntable[i].data += (void *)net - (void *)&init_net;\r\n}\r\nnet->ipv4.ipv4_hdr = register_net_sysctl(net, "net/ipv4", table);\r\nif (!net->ipv4.ipv4_hdr)\r\ngoto err_reg;\r\nnet->ipv4.sysctl_local_reserved_ports = kzalloc(65536 / 8, GFP_KERNEL);\r\nif (!net->ipv4.sysctl_local_reserved_ports)\r\ngoto err_ports;\r\nreturn 0;\r\nerr_ports:\r\nunregister_net_sysctl_table(net->ipv4.ipv4_hdr);\r\nerr_reg:\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\nerr_alloc:\r\nreturn -ENOMEM;\r\n}\r\nstatic __net_exit void ipv4_sysctl_exit_net(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\nkfree(net->ipv4.sysctl_local_reserved_ports);\r\ntable = net->ipv4.ipv4_hdr->ctl_table_arg;\r\nunregister_net_sysctl_table(net->ipv4.ipv4_hdr);\r\nkfree(table);\r\n}\r\nstatic __init int sysctl_ipv4_init(void)\r\n{\r\nstruct ctl_table_header *hdr;\r\nhdr = register_net_sysctl(&init_net, "net/ipv4", ipv4_table);\r\nif (!hdr)\r\nreturn -ENOMEM;\r\nif (register_pernet_subsys(&ipv4_sysctl_ops)) {\r\nunregister_net_sysctl_table(hdr);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}
