static void\r\natmel_hlcdc_layer_fb_flip_release(struct drm_flip_work *work, void *val)\r\n{\r\nstruct atmel_hlcdc_layer_fb_flip *flip = val;\r\nif (flip->fb)\r\ndrm_framebuffer_unreference(flip->fb);\r\nkfree(flip);\r\n}\r\nstatic void\r\natmel_hlcdc_layer_fb_flip_destroy(struct atmel_hlcdc_layer_fb_flip *flip)\r\n{\r\nif (flip->fb)\r\ndrm_framebuffer_unreference(flip->fb);\r\nkfree(flip->task);\r\nkfree(flip);\r\n}\r\nstatic void\r\natmel_hlcdc_layer_fb_flip_release_queue(struct atmel_hlcdc_layer *layer,\r\nstruct atmel_hlcdc_layer_fb_flip *flip)\r\n{\r\nint i;\r\nif (!flip)\r\nreturn;\r\nfor (i = 0; i < layer->max_planes; i++) {\r\nif (!flip->dscrs[i])\r\nbreak;\r\nflip->dscrs[i]->status = 0;\r\nflip->dscrs[i] = NULL;\r\n}\r\ndrm_flip_work_queue_task(&layer->gc, flip->task);\r\ndrm_flip_work_commit(&layer->gc, layer->wq);\r\n}\r\nstatic void atmel_hlcdc_layer_update_reset(struct atmel_hlcdc_layer *layer,\r\nint id)\r\n{\r\nstruct atmel_hlcdc_layer_update *upd = &layer->update;\r\nstruct atmel_hlcdc_layer_update_slot *slot;\r\nif (id < 0 || id > 1)\r\nreturn;\r\nslot = &upd->slots[id];\r\nbitmap_clear(slot->updated_configs, 0, layer->desc->nconfigs);\r\nmemset(slot->configs, 0,\r\nsizeof(*slot->configs) * layer->desc->nconfigs);\r\nif (slot->fb_flip) {\r\natmel_hlcdc_layer_fb_flip_release_queue(layer, slot->fb_flip);\r\nslot->fb_flip = NULL;\r\n}\r\n}\r\nstatic void atmel_hlcdc_layer_update_apply(struct atmel_hlcdc_layer *layer)\r\n{\r\nstruct atmel_hlcdc_layer_dma_channel *dma = &layer->dma;\r\nconst struct atmel_hlcdc_layer_desc *desc = layer->desc;\r\nstruct atmel_hlcdc_layer_update *upd = &layer->update;\r\nstruct regmap *regmap = layer->hlcdc->regmap;\r\nstruct atmel_hlcdc_layer_update_slot *slot;\r\nstruct atmel_hlcdc_layer_fb_flip *fb_flip;\r\nstruct atmel_hlcdc_dma_channel_dscr *dscr;\r\nunsigned int cfg;\r\nu32 action = 0;\r\nint i = 0;\r\nif (upd->pending < 0 || upd->pending > 1)\r\nreturn;\r\nslot = &upd->slots[upd->pending];\r\nfor_each_set_bit(cfg, slot->updated_configs, layer->desc->nconfigs) {\r\nregmap_write(regmap,\r\ndesc->regs_offset +\r\nATMEL_HLCDC_LAYER_CFG(layer, cfg),\r\nslot->configs[cfg]);\r\naction |= ATMEL_HLCDC_LAYER_UPDATE;\r\n}\r\nfb_flip = slot->fb_flip;\r\nif (!fb_flip->fb)\r\ngoto apply;\r\nif (dma->status == ATMEL_HLCDC_LAYER_DISABLED) {\r\nfor (i = 0; i < fb_flip->ngems; i++) {\r\ndscr = fb_flip->dscrs[i];\r\ndscr->ctrl = ATMEL_HLCDC_LAYER_DFETCH |\r\nATMEL_HLCDC_LAYER_DMA_IRQ |\r\nATMEL_HLCDC_LAYER_ADD_IRQ |\r\nATMEL_HLCDC_LAYER_DONE_IRQ;\r\nregmap_write(regmap,\r\ndesc->regs_offset +\r\nATMEL_HLCDC_LAYER_PLANE_ADDR(i),\r\ndscr->addr);\r\nregmap_write(regmap,\r\ndesc->regs_offset +\r\nATMEL_HLCDC_LAYER_PLANE_CTRL(i),\r\ndscr->ctrl);\r\nregmap_write(regmap,\r\ndesc->regs_offset +\r\nATMEL_HLCDC_LAYER_PLANE_NEXT(i),\r\ndscr->next);\r\n}\r\naction |= ATMEL_HLCDC_LAYER_DMA_CHAN;\r\ndma->status = ATMEL_HLCDC_LAYER_ENABLED;\r\n} else {\r\nfor (i = 0; i < fb_flip->ngems; i++) {\r\ndscr = fb_flip->dscrs[i];\r\ndscr->ctrl = ATMEL_HLCDC_LAYER_DFETCH |\r\nATMEL_HLCDC_LAYER_DMA_IRQ |\r\nATMEL_HLCDC_LAYER_DSCR_IRQ |\r\nATMEL_HLCDC_LAYER_DONE_IRQ;\r\nregmap_write(regmap,\r\ndesc->regs_offset +\r\nATMEL_HLCDC_LAYER_PLANE_HEAD(i),\r\ndscr->next);\r\n}\r\naction |= ATMEL_HLCDC_LAYER_A2Q;\r\n}\r\nfor (i = fb_flip->ngems; i < layer->max_planes; i++) {\r\nfb_flip->dscrs[i]->status = 0;\r\nfb_flip->dscrs[i] = NULL;\r\n}\r\ndma->queue = fb_flip;\r\nslot->fb_flip = NULL;\r\napply:\r\nif (action)\r\nregmap_write(regmap,\r\ndesc->regs_offset + ATMEL_HLCDC_LAYER_CHER,\r\naction);\r\natmel_hlcdc_layer_update_reset(layer, upd->pending);\r\nupd->pending = -1;\r\n}\r\nvoid atmel_hlcdc_layer_irq(struct atmel_hlcdc_layer *layer)\r\n{\r\nstruct atmel_hlcdc_layer_dma_channel *dma = &layer->dma;\r\nconst struct atmel_hlcdc_layer_desc *desc = layer->desc;\r\nstruct regmap *regmap = layer->hlcdc->regmap;\r\nstruct atmel_hlcdc_layer_fb_flip *flip;\r\nunsigned long flags;\r\nunsigned int isr, imr;\r\nunsigned int status;\r\nunsigned int plane_status;\r\nu32 flip_status;\r\nint i;\r\nregmap_read(regmap, desc->regs_offset + ATMEL_HLCDC_LAYER_IMR, &imr);\r\nregmap_read(regmap, desc->regs_offset + ATMEL_HLCDC_LAYER_ISR, &isr);\r\nstatus = imr & isr;\r\nif (!status)\r\nreturn;\r\nspin_lock_irqsave(&layer->lock, flags);\r\nflip = dma->queue ? dma->queue : dma->cur;\r\nif (!flip) {\r\nspin_unlock_irqrestore(&layer->lock, flags);\r\nreturn;\r\n}\r\nflip_status = ATMEL_HLCDC_DMA_CHANNEL_DSCR_LOADED |\r\nATMEL_HLCDC_DMA_CHANNEL_DSCR_DONE;\r\nfor (i = 0; i < flip->ngems; i++) {\r\nplane_status = (status >> (8 * i));\r\nif (plane_status &\r\n(ATMEL_HLCDC_LAYER_ADD_IRQ |\r\nATMEL_HLCDC_LAYER_DSCR_IRQ) &\r\n~flip->dscrs[i]->ctrl) {\r\nflip->dscrs[i]->status |=\r\nATMEL_HLCDC_DMA_CHANNEL_DSCR_LOADED;\r\nflip->dscrs[i]->ctrl |=\r\nATMEL_HLCDC_LAYER_ADD_IRQ |\r\nATMEL_HLCDC_LAYER_DSCR_IRQ;\r\n}\r\nif (plane_status &\r\nATMEL_HLCDC_LAYER_DONE_IRQ &\r\n~flip->dscrs[i]->ctrl) {\r\nflip->dscrs[i]->status |=\r\nATMEL_HLCDC_DMA_CHANNEL_DSCR_DONE;\r\nflip->dscrs[i]->ctrl |=\r\nATMEL_HLCDC_LAYER_DONE_IRQ;\r\n}\r\nif (plane_status & ATMEL_HLCDC_LAYER_OVR_IRQ)\r\nflip->dscrs[i]->status |=\r\nATMEL_HLCDC_DMA_CHANNEL_DSCR_OVERRUN;\r\nif (!(flip->dscrs[i]->status &\r\nATMEL_HLCDC_DMA_CHANNEL_DSCR_LOADED))\r\nflip_status &= ~ATMEL_HLCDC_DMA_CHANNEL_DSCR_LOADED;\r\nif (!(flip->dscrs[i]->status &\r\nATMEL_HLCDC_DMA_CHANNEL_DSCR_DONE))\r\nflip_status &= ~ATMEL_HLCDC_DMA_CHANNEL_DSCR_DONE;\r\nflip_status |= flip->dscrs[i]->status &\r\nATMEL_HLCDC_DMA_CHANNEL_DSCR_OVERRUN;\r\n}\r\nflip_status ^= flip->status;\r\nflip->status |= flip_status;\r\nif (flip_status & ATMEL_HLCDC_DMA_CHANNEL_DSCR_LOADED) {\r\natmel_hlcdc_layer_fb_flip_release_queue(layer, dma->cur);\r\ndma->cur = dma->queue;\r\ndma->queue = NULL;\r\n}\r\nif (flip_status & ATMEL_HLCDC_DMA_CHANNEL_DSCR_DONE) {\r\natmel_hlcdc_layer_fb_flip_release_queue(layer, dma->cur);\r\ndma->cur = NULL;\r\n}\r\nif (flip_status & ATMEL_HLCDC_DMA_CHANNEL_DSCR_OVERRUN) {\r\nregmap_write(regmap,\r\ndesc->regs_offset + ATMEL_HLCDC_LAYER_CHDR,\r\nATMEL_HLCDC_LAYER_RST);\r\nif (dma->queue)\r\natmel_hlcdc_layer_fb_flip_release_queue(layer,\r\ndma->queue);\r\nif (dma->cur)\r\natmel_hlcdc_layer_fb_flip_release_queue(layer,\r\ndma->cur);\r\ndma->cur = NULL;\r\ndma->queue = NULL;\r\n}\r\nif (!dma->queue) {\r\natmel_hlcdc_layer_update_apply(layer);\r\nif (!dma->cur)\r\ndma->status = ATMEL_HLCDC_LAYER_DISABLED;\r\n}\r\nspin_unlock_irqrestore(&layer->lock, flags);\r\n}\r\nvoid atmel_hlcdc_layer_disable(struct atmel_hlcdc_layer *layer)\r\n{\r\nstruct atmel_hlcdc_layer_dma_channel *dma = &layer->dma;\r\nstruct atmel_hlcdc_layer_update *upd = &layer->update;\r\nstruct regmap *regmap = layer->hlcdc->regmap;\r\nconst struct atmel_hlcdc_layer_desc *desc = layer->desc;\r\nunsigned long flags;\r\nunsigned int isr;\r\nspin_lock_irqsave(&layer->lock, flags);\r\nregmap_write(regmap, desc->regs_offset + ATMEL_HLCDC_LAYER_CHDR,\r\nATMEL_HLCDC_LAYER_RST | ATMEL_HLCDC_LAYER_A2Q |\r\nATMEL_HLCDC_LAYER_UPDATE);\r\nregmap_read(regmap, desc->regs_offset + ATMEL_HLCDC_LAYER_ISR, &isr);\r\nif (dma->cur) {\r\natmel_hlcdc_layer_fb_flip_release_queue(layer, dma->cur);\r\ndma->cur = NULL;\r\n}\r\nif (dma->queue) {\r\natmel_hlcdc_layer_fb_flip_release_queue(layer, dma->queue);\r\ndma->queue = NULL;\r\n}\r\nif (upd->pending >= 0) {\r\natmel_hlcdc_layer_update_reset(layer, upd->pending);\r\nupd->pending = -1;\r\n}\r\ndma->status = ATMEL_HLCDC_LAYER_DISABLED;\r\nspin_unlock_irqrestore(&layer->lock, flags);\r\n}\r\nint atmel_hlcdc_layer_update_start(struct atmel_hlcdc_layer *layer)\r\n{\r\nstruct atmel_hlcdc_layer_dma_channel *dma = &layer->dma;\r\nstruct atmel_hlcdc_layer_update *upd = &layer->update;\r\nstruct regmap *regmap = layer->hlcdc->regmap;\r\nstruct atmel_hlcdc_layer_fb_flip *fb_flip;\r\nstruct atmel_hlcdc_layer_update_slot *slot;\r\nunsigned long flags;\r\nint i, j = 0;\r\nfb_flip = kzalloc(sizeof(*fb_flip), GFP_KERNEL);\r\nif (!fb_flip)\r\nreturn -ENOMEM;\r\nfb_flip->task = drm_flip_work_allocate_task(fb_flip, GFP_KERNEL);\r\nif (!fb_flip->task) {\r\nkfree(fb_flip);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&layer->lock, flags);\r\nupd->next = upd->pending ? 0 : 1;\r\nslot = &upd->slots[upd->next];\r\nfor (i = 0; i < layer->max_planes * 4; i++) {\r\nif (!dma->dscrs[i].status) {\r\nfb_flip->dscrs[j++] = &dma->dscrs[i];\r\ndma->dscrs[i].status =\r\nATMEL_HLCDC_DMA_CHANNEL_DSCR_RESERVED;\r\nif (j == layer->max_planes)\r\nbreak;\r\n}\r\n}\r\nif (j < layer->max_planes) {\r\nfor (i = 0; i < j; i++)\r\nfb_flip->dscrs[i]->status = 0;\r\n}\r\nif (j < layer->max_planes) {\r\nspin_unlock_irqrestore(&layer->lock, flags);\r\natmel_hlcdc_layer_fb_flip_destroy(fb_flip);\r\nreturn -EBUSY;\r\n}\r\nslot->fb_flip = fb_flip;\r\nif (upd->pending >= 0) {\r\nmemcpy(slot->configs,\r\nupd->slots[upd->pending].configs,\r\nlayer->desc->nconfigs * sizeof(u32));\r\nmemcpy(slot->updated_configs,\r\nupd->slots[upd->pending].updated_configs,\r\nDIV_ROUND_UP(layer->desc->nconfigs,\r\nBITS_PER_BYTE * sizeof(unsigned long)) *\r\nsizeof(unsigned long));\r\nslot->fb_flip->fb = upd->slots[upd->pending].fb_flip->fb;\r\nif (upd->slots[upd->pending].fb_flip->fb) {\r\nslot->fb_flip->fb =\r\nupd->slots[upd->pending].fb_flip->fb;\r\nslot->fb_flip->ngems =\r\nupd->slots[upd->pending].fb_flip->ngems;\r\ndrm_framebuffer_reference(slot->fb_flip->fb);\r\n}\r\n} else {\r\nregmap_bulk_read(regmap,\r\nlayer->desc->regs_offset +\r\nATMEL_HLCDC_LAYER_CFG(layer, 0),\r\nupd->slots[upd->next].configs,\r\nlayer->desc->nconfigs);\r\n}\r\nspin_unlock_irqrestore(&layer->lock, flags);\r\nreturn 0;\r\n}\r\nvoid atmel_hlcdc_layer_update_rollback(struct atmel_hlcdc_layer *layer)\r\n{\r\nstruct atmel_hlcdc_layer_update *upd = &layer->update;\r\natmel_hlcdc_layer_update_reset(layer, upd->next);\r\nupd->next = -1;\r\n}\r\nvoid atmel_hlcdc_layer_update_set_fb(struct atmel_hlcdc_layer *layer,\r\nstruct drm_framebuffer *fb,\r\nunsigned int *offsets)\r\n{\r\nstruct atmel_hlcdc_layer_update *upd = &layer->update;\r\nstruct atmel_hlcdc_layer_fb_flip *fb_flip;\r\nstruct atmel_hlcdc_layer_update_slot *slot;\r\nstruct atmel_hlcdc_dma_channel_dscr *dscr;\r\nstruct drm_framebuffer *old_fb;\r\nint nplanes = 0;\r\nint i;\r\nif (upd->next < 0 || upd->next > 1)\r\nreturn;\r\nif (fb)\r\nnplanes = drm_format_num_planes(fb->pixel_format);\r\nif (nplanes > layer->max_planes)\r\nreturn;\r\nslot = &upd->slots[upd->next];\r\nfb_flip = slot->fb_flip;\r\nold_fb = slot->fb_flip->fb;\r\nfor (i = 0; i < nplanes; i++) {\r\nstruct drm_gem_cma_object *gem;\r\ndscr = slot->fb_flip->dscrs[i];\r\ngem = drm_fb_cma_get_gem_obj(fb, i);\r\ndscr->addr = gem->paddr + offsets[i];\r\n}\r\nfb_flip->ngems = nplanes;\r\nfb_flip->fb = fb;\r\nif (fb)\r\ndrm_framebuffer_reference(fb);\r\nif (old_fb)\r\ndrm_framebuffer_unreference(old_fb);\r\n}\r\nvoid atmel_hlcdc_layer_update_cfg(struct atmel_hlcdc_layer *layer, int cfg,\r\nu32 mask, u32 val)\r\n{\r\nstruct atmel_hlcdc_layer_update *upd = &layer->update;\r\nstruct atmel_hlcdc_layer_update_slot *slot;\r\nif (upd->next < 0 || upd->next > 1)\r\nreturn;\r\nif (cfg >= layer->desc->nconfigs)\r\nreturn;\r\nslot = &upd->slots[upd->next];\r\nslot->configs[cfg] &= ~mask;\r\nslot->configs[cfg] |= (val & mask);\r\nset_bit(cfg, slot->updated_configs);\r\n}\r\nvoid atmel_hlcdc_layer_update_commit(struct atmel_hlcdc_layer *layer)\r\n{\r\nstruct atmel_hlcdc_layer_dma_channel *dma = &layer->dma;\r\nstruct atmel_hlcdc_layer_update *upd = &layer->update;\r\nstruct atmel_hlcdc_layer_update_slot *slot;\r\nunsigned long flags;\r\nif (upd->next < 0 || upd->next > 1)\r\nreturn;\r\nslot = &upd->slots[upd->next];\r\nspin_lock_irqsave(&layer->lock, flags);\r\nif (upd->pending >= 0)\r\natmel_hlcdc_layer_update_reset(layer, upd->pending);\r\nupd->pending = upd->next;\r\nupd->next = -1;\r\nif (!dma->queue)\r\natmel_hlcdc_layer_update_apply(layer);\r\nspin_unlock_irqrestore(&layer->lock, flags);\r\nupd->next = -1;\r\n}\r\nstatic int atmel_hlcdc_layer_dma_init(struct drm_device *dev,\r\nstruct atmel_hlcdc_layer *layer)\r\n{\r\nstruct atmel_hlcdc_layer_dma_channel *dma = &layer->dma;\r\ndma_addr_t dma_addr;\r\nint i;\r\ndma->dscrs = dma_alloc_coherent(dev->dev,\r\nlayer->max_planes * 4 *\r\nsizeof(*dma->dscrs),\r\n&dma_addr, GFP_KERNEL);\r\nif (!dma->dscrs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < layer->max_planes * 4; i++) {\r\nstruct atmel_hlcdc_dma_channel_dscr *dscr = &dma->dscrs[i];\r\ndscr->next = dma_addr + (i * sizeof(*dscr));\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_hlcdc_layer_dma_cleanup(struct drm_device *dev,\r\nstruct atmel_hlcdc_layer *layer)\r\n{\r\nstruct atmel_hlcdc_layer_dma_channel *dma = &layer->dma;\r\nint i;\r\nfor (i = 0; i < layer->max_planes * 4; i++) {\r\nstruct atmel_hlcdc_dma_channel_dscr *dscr = &dma->dscrs[i];\r\ndscr->status = 0;\r\n}\r\ndma_free_coherent(dev->dev, layer->max_planes * 4 *\r\nsizeof(*dma->dscrs), dma->dscrs,\r\ndma->dscrs[0].next);\r\n}\r\nstatic int atmel_hlcdc_layer_update_init(struct drm_device *dev,\r\nstruct atmel_hlcdc_layer *layer,\r\nconst struct atmel_hlcdc_layer_desc *desc)\r\n{\r\nstruct atmel_hlcdc_layer_update *upd = &layer->update;\r\nint updated_size;\r\nvoid *buffer;\r\nint i;\r\nupdated_size = DIV_ROUND_UP(desc->nconfigs,\r\nBITS_PER_BYTE *\r\nsizeof(unsigned long));\r\nbuffer = devm_kzalloc(dev->dev,\r\n((desc->nconfigs * sizeof(u32)) +\r\n(updated_size * sizeof(unsigned long))) * 2,\r\nGFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 2; i++) {\r\nupd->slots[i].updated_configs = buffer;\r\nbuffer += updated_size * sizeof(unsigned long);\r\nupd->slots[i].configs = buffer;\r\nbuffer += desc->nconfigs * sizeof(u32);\r\n}\r\nupd->pending = -1;\r\nupd->next = -1;\r\nreturn 0;\r\n}\r\nint atmel_hlcdc_layer_init(struct drm_device *dev,\r\nstruct atmel_hlcdc_layer *layer,\r\nconst struct atmel_hlcdc_layer_desc *desc)\r\n{\r\nstruct atmel_hlcdc_dc *dc = dev->dev_private;\r\nstruct regmap *regmap = dc->hlcdc->regmap;\r\nunsigned int tmp;\r\nint ret;\r\nint i;\r\nlayer->hlcdc = dc->hlcdc;\r\nlayer->wq = dc->wq;\r\nlayer->desc = desc;\r\nregmap_write(regmap, desc->regs_offset + ATMEL_HLCDC_LAYER_CHDR,\r\nATMEL_HLCDC_LAYER_RST);\r\nfor (i = 0; i < desc->formats->nformats; i++) {\r\nint nplanes = drm_format_num_planes(desc->formats->formats[i]);\r\nif (nplanes > layer->max_planes)\r\nlayer->max_planes = nplanes;\r\n}\r\nspin_lock_init(&layer->lock);\r\ndrm_flip_work_init(&layer->gc, desc->name,\r\natmel_hlcdc_layer_fb_flip_release);\r\nret = atmel_hlcdc_layer_dma_init(dev, layer);\r\nif (ret)\r\nreturn ret;\r\nret = atmel_hlcdc_layer_update_init(dev, layer, desc);\r\nif (ret)\r\nreturn ret;\r\nregmap_write(regmap, desc->regs_offset + ATMEL_HLCDC_LAYER_IDR,\r\n0xffffffff);\r\nregmap_read(regmap, desc->regs_offset + ATMEL_HLCDC_LAYER_ISR,\r\n&tmp);\r\ntmp = 0;\r\nfor (i = 0; i < layer->max_planes; i++)\r\ntmp |= (ATMEL_HLCDC_LAYER_DMA_IRQ |\r\nATMEL_HLCDC_LAYER_DSCR_IRQ |\r\nATMEL_HLCDC_LAYER_ADD_IRQ |\r\nATMEL_HLCDC_LAYER_DONE_IRQ |\r\nATMEL_HLCDC_LAYER_OVR_IRQ) << (8 * i);\r\nregmap_write(regmap, desc->regs_offset + ATMEL_HLCDC_LAYER_IER, tmp);\r\nreturn 0;\r\n}\r\nvoid atmel_hlcdc_layer_cleanup(struct drm_device *dev,\r\nstruct atmel_hlcdc_layer *layer)\r\n{\r\nconst struct atmel_hlcdc_layer_desc *desc = layer->desc;\r\nstruct regmap *regmap = layer->hlcdc->regmap;\r\nregmap_write(regmap, desc->regs_offset + ATMEL_HLCDC_LAYER_IDR,\r\n0xffffffff);\r\nregmap_write(regmap, desc->regs_offset + ATMEL_HLCDC_LAYER_CHDR,\r\nATMEL_HLCDC_LAYER_RST);\r\natmel_hlcdc_layer_dma_cleanup(dev, layer);\r\ndrm_flip_work_cleanup(&layer->gc);\r\n}
