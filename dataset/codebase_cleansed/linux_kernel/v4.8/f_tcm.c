static inline struct f_uas *to_f_uas(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_uas, function);\r\n}\r\nstatic int bot_enqueue_cmd_cbw(struct f_uas *fu)\r\n{\r\nint ret;\r\nif (fu->flags & USBG_BOT_CMD_PEND)\r\nreturn 0;\r\nret = usb_ep_queue(fu->ep_out, fu->cmd.req, GFP_ATOMIC);\r\nif (!ret)\r\nfu->flags |= USBG_BOT_CMD_PEND;\r\nreturn ret;\r\n}\r\nstatic void bot_status_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbg_cmd *cmd = req->context;\r\nstruct f_uas *fu = cmd->fu;\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\nif (req->status < 0) {\r\npr_err("ERR %s(%d)\n", __func__, __LINE__);\r\nreturn;\r\n}\r\nbot_enqueue_cmd_cbw(fu);\r\n}\r\nstatic void bot_enqueue_sense_code(struct f_uas *fu, struct usbg_cmd *cmd)\r\n{\r\nstruct bulk_cs_wrap *csw = &fu->bot_status.csw;\r\nint ret;\r\nunsigned int csw_stat;\r\ncsw_stat = cmd->csw_code;\r\ncsw->Tag = cmd->bot_tag;\r\ncsw->Status = csw_stat;\r\nfu->bot_status.req->context = cmd;\r\nret = usb_ep_queue(fu->ep_in, fu->bot_status.req, GFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d) ERR: %d\n", __func__, __LINE__, ret);\r\n}\r\nstatic void bot_err_compl(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbg_cmd *cmd = req->context;\r\nstruct f_uas *fu = cmd->fu;\r\nif (req->status < 0)\r\npr_err("ERR %s(%d)\n", __func__, __LINE__);\r\nif (cmd->data_len) {\r\nif (cmd->data_len > ep->maxpacket) {\r\nreq->length = ep->maxpacket;\r\ncmd->data_len -= ep->maxpacket;\r\n} else {\r\nreq->length = cmd->data_len;\r\ncmd->data_len = 0;\r\n}\r\nusb_ep_queue(ep, req, GFP_ATOMIC);\r\nreturn;\r\n}\r\nbot_enqueue_sense_code(fu, cmd);\r\n}\r\nstatic void bot_send_bad_status(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct bulk_cs_wrap *csw = &fu->bot_status.csw;\r\nstruct usb_request *req;\r\nstruct usb_ep *ep;\r\ncsw->Residue = cpu_to_le32(cmd->data_len);\r\nif (cmd->data_len) {\r\nif (cmd->is_read) {\r\nep = fu->ep_in;\r\nreq = fu->bot_req_in;\r\n} else {\r\nep = fu->ep_out;\r\nreq = fu->bot_req_out;\r\n}\r\nif (cmd->data_len > fu->ep_in->maxpacket) {\r\nreq->length = ep->maxpacket;\r\ncmd->data_len -= ep->maxpacket;\r\n} else {\r\nreq->length = cmd->data_len;\r\ncmd->data_len = 0;\r\n}\r\nreq->complete = bot_err_compl;\r\nreq->context = cmd;\r\nreq->buf = fu->cmd.buf;\r\nusb_ep_queue(ep, req, GFP_KERNEL);\r\n} else {\r\nbot_enqueue_sense_code(fu, cmd);\r\n}\r\n}\r\nstatic int bot_send_status(struct usbg_cmd *cmd, bool moved_data)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct bulk_cs_wrap *csw = &fu->bot_status.csw;\r\nint ret;\r\nif (cmd->se_cmd.scsi_status == SAM_STAT_GOOD) {\r\nif (!moved_data && cmd->data_len) {\r\ncmd->csw_code = US_BULK_STAT_OK;\r\nbot_send_bad_status(cmd);\r\nreturn 0;\r\n}\r\ncsw->Tag = cmd->bot_tag;\r\ncsw->Residue = cpu_to_le32(0);\r\ncsw->Status = US_BULK_STAT_OK;\r\nfu->bot_status.req->context = cmd;\r\nret = usb_ep_queue(fu->ep_in, fu->bot_status.req, GFP_KERNEL);\r\nif (ret)\r\npr_err("%s(%d) ERR: %d\n", __func__, __LINE__, ret);\r\n} else {\r\ncmd->csw_code = US_BULK_STAT_FAIL;\r\nbot_send_bad_status(cmd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bot_send_status_response(struct usbg_cmd *cmd)\r\n{\r\nbool moved_data = false;\r\nif (!cmd->is_read)\r\nmoved_data = true;\r\nreturn bot_send_status(cmd, moved_data);\r\n}\r\nstatic void bot_read_compl(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbg_cmd *cmd = req->context;\r\nif (req->status < 0)\r\npr_err("ERR %s(%d)\n", __func__, __LINE__);\r\nbot_send_status(cmd, true);\r\n}\r\nstatic int bot_send_read_response(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct usb_gadget *gadget = fuas_to_gadget(fu);\r\nint ret;\r\nif (!cmd->data_len) {\r\ncmd->csw_code = US_BULK_STAT_PHASE;\r\nbot_send_bad_status(cmd);\r\nreturn 0;\r\n}\r\nif (!gadget->sg_supported) {\r\ncmd->data_buf = kmalloc(se_cmd->data_length, GFP_ATOMIC);\r\nif (!cmd->data_buf)\r\nreturn -ENOMEM;\r\nsg_copy_to_buffer(se_cmd->t_data_sg,\r\nse_cmd->t_data_nents,\r\ncmd->data_buf,\r\nse_cmd->data_length);\r\nfu->bot_req_in->buf = cmd->data_buf;\r\n} else {\r\nfu->bot_req_in->buf = NULL;\r\nfu->bot_req_in->num_sgs = se_cmd->t_data_nents;\r\nfu->bot_req_in->sg = se_cmd->t_data_sg;\r\n}\r\nfu->bot_req_in->complete = bot_read_compl;\r\nfu->bot_req_in->length = se_cmd->data_length;\r\nfu->bot_req_in->context = cmd;\r\nret = usb_ep_queue(fu->ep_in, fu->bot_req_in, GFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d)\n", __func__, __LINE__);\r\nreturn 0;\r\n}\r\nstatic int bot_send_write_request(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct usb_gadget *gadget = fuas_to_gadget(fu);\r\nint ret;\r\ninit_completion(&cmd->write_complete);\r\ncmd->fu = fu;\r\nif (!cmd->data_len) {\r\ncmd->csw_code = US_BULK_STAT_PHASE;\r\nreturn -EINVAL;\r\n}\r\nif (!gadget->sg_supported) {\r\ncmd->data_buf = kmalloc(se_cmd->data_length, GFP_KERNEL);\r\nif (!cmd->data_buf)\r\nreturn -ENOMEM;\r\nfu->bot_req_out->buf = cmd->data_buf;\r\n} else {\r\nfu->bot_req_out->buf = NULL;\r\nfu->bot_req_out->num_sgs = se_cmd->t_data_nents;\r\nfu->bot_req_out->sg = se_cmd->t_data_sg;\r\n}\r\nfu->bot_req_out->complete = usbg_data_write_cmpl;\r\nfu->bot_req_out->length = se_cmd->data_length;\r\nfu->bot_req_out->context = cmd;\r\nret = usbg_prepare_w_request(cmd, fu->bot_req_out);\r\nif (ret)\r\ngoto cleanup;\r\nret = usb_ep_queue(fu->ep_out, fu->bot_req_out, GFP_KERNEL);\r\nif (ret)\r\npr_err("%s(%d)\n", __func__, __LINE__);\r\nwait_for_completion(&cmd->write_complete);\r\ntarget_execute_cmd(se_cmd);\r\ncleanup:\r\nreturn ret;\r\n}\r\nstatic void bot_cmd_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_uas *fu = req->context;\r\nint ret;\r\nfu->flags &= ~USBG_BOT_CMD_PEND;\r\nif (req->status < 0)\r\nreturn;\r\nret = bot_submit_command(fu, req->buf, req->actual);\r\nif (ret)\r\npr_err("%s(%d): %d\n", __func__, __LINE__, ret);\r\n}\r\nstatic int bot_prepare_reqs(struct f_uas *fu)\r\n{\r\nint ret;\r\nfu->bot_req_in = usb_ep_alloc_request(fu->ep_in, GFP_KERNEL);\r\nif (!fu->bot_req_in)\r\ngoto err;\r\nfu->bot_req_out = usb_ep_alloc_request(fu->ep_out, GFP_KERNEL);\r\nif (!fu->bot_req_out)\r\ngoto err_out;\r\nfu->cmd.req = usb_ep_alloc_request(fu->ep_out, GFP_KERNEL);\r\nif (!fu->cmd.req)\r\ngoto err_cmd;\r\nfu->bot_status.req = usb_ep_alloc_request(fu->ep_in, GFP_KERNEL);\r\nif (!fu->bot_status.req)\r\ngoto err_sts;\r\nfu->bot_status.req->buf = &fu->bot_status.csw;\r\nfu->bot_status.req->length = US_BULK_CS_WRAP_LEN;\r\nfu->bot_status.req->complete = bot_status_complete;\r\nfu->bot_status.csw.Signature = cpu_to_le32(US_BULK_CS_SIGN);\r\nfu->cmd.buf = kmalloc(fu->ep_out->maxpacket, GFP_KERNEL);\r\nif (!fu->cmd.buf)\r\ngoto err_buf;\r\nfu->cmd.req->complete = bot_cmd_complete;\r\nfu->cmd.req->buf = fu->cmd.buf;\r\nfu->cmd.req->length = fu->ep_out->maxpacket;\r\nfu->cmd.req->context = fu;\r\nret = bot_enqueue_cmd_cbw(fu);\r\nif (ret)\r\ngoto err_queue;\r\nreturn 0;\r\nerr_queue:\r\nkfree(fu->cmd.buf);\r\nfu->cmd.buf = NULL;\r\nerr_buf:\r\nusb_ep_free_request(fu->ep_in, fu->bot_status.req);\r\nerr_sts:\r\nusb_ep_free_request(fu->ep_out, fu->cmd.req);\r\nfu->cmd.req = NULL;\r\nerr_cmd:\r\nusb_ep_free_request(fu->ep_out, fu->bot_req_out);\r\nfu->bot_req_out = NULL;\r\nerr_out:\r\nusb_ep_free_request(fu->ep_in, fu->bot_req_in);\r\nfu->bot_req_in = NULL;\r\nerr:\r\npr_err("BOT: endpoint setup failed\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic void bot_cleanup_old_alt(struct f_uas *fu)\r\n{\r\nif (!(fu->flags & USBG_ENABLED))\r\nreturn;\r\nusb_ep_disable(fu->ep_in);\r\nusb_ep_disable(fu->ep_out);\r\nif (!fu->bot_req_in)\r\nreturn;\r\nusb_ep_free_request(fu->ep_in, fu->bot_req_in);\r\nusb_ep_free_request(fu->ep_out, fu->bot_req_out);\r\nusb_ep_free_request(fu->ep_out, fu->cmd.req);\r\nusb_ep_free_request(fu->ep_out, fu->bot_status.req);\r\nkfree(fu->cmd.buf);\r\nfu->bot_req_in = NULL;\r\nfu->bot_req_out = NULL;\r\nfu->cmd.req = NULL;\r\nfu->bot_status.req = NULL;\r\nfu->cmd.buf = NULL;\r\n}\r\nstatic void bot_set_alt(struct f_uas *fu)\r\n{\r\nstruct usb_function *f = &fu->function;\r\nstruct usb_gadget *gadget = f->config->cdev->gadget;\r\nint ret;\r\nfu->flags = USBG_IS_BOT;\r\nconfig_ep_by_speed(gadget, f, fu->ep_in);\r\nret = usb_ep_enable(fu->ep_in);\r\nif (ret)\r\ngoto err_b_in;\r\nconfig_ep_by_speed(gadget, f, fu->ep_out);\r\nret = usb_ep_enable(fu->ep_out);\r\nif (ret)\r\ngoto err_b_out;\r\nret = bot_prepare_reqs(fu);\r\nif (ret)\r\ngoto err_wq;\r\nfu->flags |= USBG_ENABLED;\r\npr_info("Using the BOT protocol\n");\r\nreturn;\r\nerr_wq:\r\nusb_ep_disable(fu->ep_out);\r\nerr_b_out:\r\nusb_ep_disable(fu->ep_in);\r\nerr_b_in:\r\nfu->flags = USBG_IS_BOT;\r\n}\r\nstatic int usbg_bot_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nint luns;\r\nu8 *ret_lun;\r\nswitch (ctrl->bRequest) {\r\ncase US_BULK_GET_MAX_LUN:\r\nif (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE))\r\nreturn -ENOTSUPP;\r\nif (w_length < 1)\r\nreturn -EINVAL;\r\nif (w_value != 0)\r\nreturn -EINVAL;\r\nluns = atomic_read(&fu->tpg->tpg_port_count);\r\nif (!luns) {\r\npr_err("No LUNs configured?\n");\r\nreturn -EINVAL;\r\n}\r\nluns--;\r\nif (luns > 0xf) {\r\npr_info_once("Limiting the number of luns to 16\n");\r\nluns = 0xf;\r\n}\r\nret_lun = cdev->req->buf;\r\n*ret_lun = luns;\r\ncdev->req->length = 1;\r\nreturn usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);\r\ncase US_BULK_RESET_REQUEST:\r\nbot_enqueue_cmd_cbw(fu);\r\nreturn 0;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic void uasp_cleanup_one_stream(struct f_uas *fu, struct uas_stream *stream)\r\n{\r\nif (!stream->req_in)\r\nreturn;\r\nusb_ep_free_request(fu->ep_in, stream->req_in);\r\nusb_ep_free_request(fu->ep_out, stream->req_out);\r\nusb_ep_free_request(fu->ep_status, stream->req_status);\r\nstream->req_in = NULL;\r\nstream->req_out = NULL;\r\nstream->req_status = NULL;\r\n}\r\nstatic void uasp_free_cmdreq(struct f_uas *fu)\r\n{\r\nusb_ep_free_request(fu->ep_cmd, fu->cmd.req);\r\nkfree(fu->cmd.buf);\r\nfu->cmd.req = NULL;\r\nfu->cmd.buf = NULL;\r\n}\r\nstatic void uasp_cleanup_old_alt(struct f_uas *fu)\r\n{\r\nint i;\r\nif (!(fu->flags & USBG_ENABLED))\r\nreturn;\r\nusb_ep_disable(fu->ep_in);\r\nusb_ep_disable(fu->ep_out);\r\nusb_ep_disable(fu->ep_status);\r\nusb_ep_disable(fu->ep_cmd);\r\nfor (i = 0; i < UASP_SS_EP_COMP_NUM_STREAMS; i++)\r\nuasp_cleanup_one_stream(fu, &fu->stream[i]);\r\nuasp_free_cmdreq(fu);\r\n}\r\nstatic int uasp_prepare_r_request(struct usbg_cmd *cmd)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct f_uas *fu = cmd->fu;\r\nstruct usb_gadget *gadget = fuas_to_gadget(fu);\r\nstruct uas_stream *stream = cmd->stream;\r\nif (!gadget->sg_supported) {\r\ncmd->data_buf = kmalloc(se_cmd->data_length, GFP_ATOMIC);\r\nif (!cmd->data_buf)\r\nreturn -ENOMEM;\r\nsg_copy_to_buffer(se_cmd->t_data_sg,\r\nse_cmd->t_data_nents,\r\ncmd->data_buf,\r\nse_cmd->data_length);\r\nstream->req_in->buf = cmd->data_buf;\r\n} else {\r\nstream->req_in->buf = NULL;\r\nstream->req_in->num_sgs = se_cmd->t_data_nents;\r\nstream->req_in->sg = se_cmd->t_data_sg;\r\n}\r\nstream->req_in->complete = uasp_status_data_cmpl;\r\nstream->req_in->length = se_cmd->data_length;\r\nstream->req_in->context = cmd;\r\ncmd->state = UASP_SEND_STATUS;\r\nreturn 0;\r\n}\r\nstatic void uasp_prepare_status(struct usbg_cmd *cmd)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct sense_iu *iu = &cmd->sense_iu;\r\nstruct uas_stream *stream = cmd->stream;\r\ncmd->state = UASP_QUEUE_COMMAND;\r\niu->iu_id = IU_ID_STATUS;\r\niu->tag = cpu_to_be16(cmd->tag);\r\niu->len = cpu_to_be16(se_cmd->scsi_sense_length);\r\niu->status = se_cmd->scsi_status;\r\nstream->req_status->context = cmd;\r\nstream->req_status->length = se_cmd->scsi_sense_length + 16;\r\nstream->req_status->buf = iu;\r\nstream->req_status->complete = uasp_status_data_cmpl;\r\n}\r\nstatic void uasp_status_data_cmpl(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbg_cmd *cmd = req->context;\r\nstruct uas_stream *stream = cmd->stream;\r\nstruct f_uas *fu = cmd->fu;\r\nint ret;\r\nif (req->status < 0)\r\ngoto cleanup;\r\nswitch (cmd->state) {\r\ncase UASP_SEND_DATA:\r\nret = uasp_prepare_r_request(cmd);\r\nif (ret)\r\ngoto cleanup;\r\nret = usb_ep_queue(fu->ep_in, stream->req_in, GFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d) => %d\n", __func__, __LINE__, ret);\r\nbreak;\r\ncase UASP_RECEIVE_DATA:\r\nret = usbg_prepare_w_request(cmd, stream->req_out);\r\nif (ret)\r\ngoto cleanup;\r\nret = usb_ep_queue(fu->ep_out, stream->req_out, GFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d) => %d\n", __func__, __LINE__, ret);\r\nbreak;\r\ncase UASP_SEND_STATUS:\r\nuasp_prepare_status(cmd);\r\nret = usb_ep_queue(fu->ep_status, stream->req_status,\r\nGFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d) => %d\n", __func__, __LINE__, ret);\r\nbreak;\r\ncase UASP_QUEUE_COMMAND:\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\nusb_ep_queue(fu->ep_cmd, fu->cmd.req, GFP_ATOMIC);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn;\r\ncleanup:\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\n}\r\nstatic int uasp_send_status_response(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct uas_stream *stream = cmd->stream;\r\nstruct sense_iu *iu = &cmd->sense_iu;\r\niu->tag = cpu_to_be16(cmd->tag);\r\nstream->req_status->complete = uasp_status_data_cmpl;\r\nstream->req_status->context = cmd;\r\ncmd->fu = fu;\r\nuasp_prepare_status(cmd);\r\nreturn usb_ep_queue(fu->ep_status, stream->req_status, GFP_ATOMIC);\r\n}\r\nstatic int uasp_send_read_response(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct uas_stream *stream = cmd->stream;\r\nstruct sense_iu *iu = &cmd->sense_iu;\r\nint ret;\r\ncmd->fu = fu;\r\niu->tag = cpu_to_be16(cmd->tag);\r\nif (fu->flags & USBG_USE_STREAMS) {\r\nret = uasp_prepare_r_request(cmd);\r\nif (ret)\r\ngoto out;\r\nret = usb_ep_queue(fu->ep_in, stream->req_in, GFP_ATOMIC);\r\nif (ret) {\r\npr_err("%s(%d) => %d\n", __func__, __LINE__, ret);\r\nkfree(cmd->data_buf);\r\ncmd->data_buf = NULL;\r\n}\r\n} else {\r\niu->iu_id = IU_ID_READ_READY;\r\niu->tag = cpu_to_be16(cmd->tag);\r\nstream->req_status->complete = uasp_status_data_cmpl;\r\nstream->req_status->context = cmd;\r\ncmd->state = UASP_SEND_DATA;\r\nstream->req_status->buf = iu;\r\nstream->req_status->length = sizeof(struct iu);\r\nret = usb_ep_queue(fu->ep_status, stream->req_status,\r\nGFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d) => %d\n", __func__, __LINE__, ret);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int uasp_send_write_request(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct uas_stream *stream = cmd->stream;\r\nstruct sense_iu *iu = &cmd->sense_iu;\r\nint ret;\r\ninit_completion(&cmd->write_complete);\r\ncmd->fu = fu;\r\niu->tag = cpu_to_be16(cmd->tag);\r\nif (fu->flags & USBG_USE_STREAMS) {\r\nret = usbg_prepare_w_request(cmd, stream->req_out);\r\nif (ret)\r\ngoto cleanup;\r\nret = usb_ep_queue(fu->ep_out, stream->req_out, GFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d)\n", __func__, __LINE__);\r\n} else {\r\niu->iu_id = IU_ID_WRITE_READY;\r\niu->tag = cpu_to_be16(cmd->tag);\r\nstream->req_status->complete = uasp_status_data_cmpl;\r\nstream->req_status->context = cmd;\r\ncmd->state = UASP_RECEIVE_DATA;\r\nstream->req_status->buf = iu;\r\nstream->req_status->length = sizeof(struct iu);\r\nret = usb_ep_queue(fu->ep_status, stream->req_status,\r\nGFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d)\n", __func__, __LINE__);\r\n}\r\nwait_for_completion(&cmd->write_complete);\r\ntarget_execute_cmd(se_cmd);\r\ncleanup:\r\nreturn ret;\r\n}\r\nstatic void uasp_cmd_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_uas *fu = req->context;\r\nint ret;\r\nif (req->status < 0)\r\nreturn;\r\nret = usbg_submit_command(fu, req->buf, req->actual);\r\nif (!ret)\r\nreturn;\r\nusb_ep_queue(fu->ep_cmd, fu->cmd.req, GFP_ATOMIC);\r\n}\r\nstatic int uasp_alloc_stream_res(struct f_uas *fu, struct uas_stream *stream)\r\n{\r\nstream->req_in = usb_ep_alloc_request(fu->ep_in, GFP_KERNEL);\r\nif (!stream->req_in)\r\ngoto out;\r\nstream->req_out = usb_ep_alloc_request(fu->ep_out, GFP_KERNEL);\r\nif (!stream->req_out)\r\ngoto err_out;\r\nstream->req_status = usb_ep_alloc_request(fu->ep_status, GFP_KERNEL);\r\nif (!stream->req_status)\r\ngoto err_sts;\r\nreturn 0;\r\nerr_sts:\r\nusb_ep_free_request(fu->ep_status, stream->req_status);\r\nstream->req_status = NULL;\r\nerr_out:\r\nusb_ep_free_request(fu->ep_out, stream->req_out);\r\nstream->req_out = NULL;\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nstatic int uasp_alloc_cmd(struct f_uas *fu)\r\n{\r\nfu->cmd.req = usb_ep_alloc_request(fu->ep_cmd, GFP_KERNEL);\r\nif (!fu->cmd.req)\r\ngoto err;\r\nfu->cmd.buf = kmalloc(fu->ep_cmd->maxpacket, GFP_KERNEL);\r\nif (!fu->cmd.buf)\r\ngoto err_buf;\r\nfu->cmd.req->complete = uasp_cmd_complete;\r\nfu->cmd.req->buf = fu->cmd.buf;\r\nfu->cmd.req->length = fu->ep_cmd->maxpacket;\r\nfu->cmd.req->context = fu;\r\nreturn 0;\r\nerr_buf:\r\nusb_ep_free_request(fu->ep_cmd, fu->cmd.req);\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic void uasp_setup_stream_res(struct f_uas *fu, int max_streams)\r\n{\r\nint i;\r\nfor (i = 0; i < max_streams; i++) {\r\nstruct uas_stream *s = &fu->stream[i];\r\ns->req_in->stream_id = i + 1;\r\ns->req_out->stream_id = i + 1;\r\ns->req_status->stream_id = i + 1;\r\n}\r\n}\r\nstatic int uasp_prepare_reqs(struct f_uas *fu)\r\n{\r\nint ret;\r\nint i;\r\nint max_streams;\r\nif (fu->flags & USBG_USE_STREAMS)\r\nmax_streams = UASP_SS_EP_COMP_NUM_STREAMS;\r\nelse\r\nmax_streams = 1;\r\nfor (i = 0; i < max_streams; i++) {\r\nret = uasp_alloc_stream_res(fu, &fu->stream[i]);\r\nif (ret)\r\ngoto err_cleanup;\r\n}\r\nret = uasp_alloc_cmd(fu);\r\nif (ret)\r\ngoto err_free_stream;\r\nuasp_setup_stream_res(fu, max_streams);\r\nret = usb_ep_queue(fu->ep_cmd, fu->cmd.req, GFP_ATOMIC);\r\nif (ret)\r\ngoto err_free_stream;\r\nreturn 0;\r\nerr_free_stream:\r\nuasp_free_cmdreq(fu);\r\nerr_cleanup:\r\nif (i) {\r\ndo {\r\nuasp_cleanup_one_stream(fu, &fu->stream[i - 1]);\r\ni--;\r\n} while (i);\r\n}\r\npr_err("UASP: endpoint setup failed\n");\r\nreturn ret;\r\n}\r\nstatic void uasp_set_alt(struct f_uas *fu)\r\n{\r\nstruct usb_function *f = &fu->function;\r\nstruct usb_gadget *gadget = f->config->cdev->gadget;\r\nint ret;\r\nfu->flags = USBG_IS_UAS;\r\nif (gadget->speed == USB_SPEED_SUPER)\r\nfu->flags |= USBG_USE_STREAMS;\r\nconfig_ep_by_speed(gadget, f, fu->ep_in);\r\nret = usb_ep_enable(fu->ep_in);\r\nif (ret)\r\ngoto err_b_in;\r\nconfig_ep_by_speed(gadget, f, fu->ep_out);\r\nret = usb_ep_enable(fu->ep_out);\r\nif (ret)\r\ngoto err_b_out;\r\nconfig_ep_by_speed(gadget, f, fu->ep_cmd);\r\nret = usb_ep_enable(fu->ep_cmd);\r\nif (ret)\r\ngoto err_cmd;\r\nconfig_ep_by_speed(gadget, f, fu->ep_status);\r\nret = usb_ep_enable(fu->ep_status);\r\nif (ret)\r\ngoto err_status;\r\nret = uasp_prepare_reqs(fu);\r\nif (ret)\r\ngoto err_wq;\r\nfu->flags |= USBG_ENABLED;\r\npr_info("Using the UAS protocol\n");\r\nreturn;\r\nerr_wq:\r\nusb_ep_disable(fu->ep_status);\r\nerr_status:\r\nusb_ep_disable(fu->ep_cmd);\r\nerr_cmd:\r\nusb_ep_disable(fu->ep_out);\r\nerr_b_out:\r\nusb_ep_disable(fu->ep_in);\r\nerr_b_in:\r\nfu->flags = 0;\r\n}\r\nstatic int get_cmd_dir(const unsigned char *cdb)\r\n{\r\nint ret;\r\nswitch (cdb[0]) {\r\ncase READ_6:\r\ncase READ_10:\r\ncase READ_12:\r\ncase READ_16:\r\ncase INQUIRY:\r\ncase MODE_SENSE:\r\ncase MODE_SENSE_10:\r\ncase SERVICE_ACTION_IN_16:\r\ncase MAINTENANCE_IN:\r\ncase PERSISTENT_RESERVE_IN:\r\ncase SECURITY_PROTOCOL_IN:\r\ncase ACCESS_CONTROL_IN:\r\ncase REPORT_LUNS:\r\ncase READ_BLOCK_LIMITS:\r\ncase READ_POSITION:\r\ncase READ_CAPACITY:\r\ncase READ_TOC:\r\ncase READ_FORMAT_CAPACITIES:\r\ncase REQUEST_SENSE:\r\nret = DMA_FROM_DEVICE;\r\nbreak;\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_12:\r\ncase WRITE_16:\r\ncase MODE_SELECT:\r\ncase MODE_SELECT_10:\r\ncase WRITE_VERIFY:\r\ncase WRITE_VERIFY_12:\r\ncase PERSISTENT_RESERVE_OUT:\r\ncase MAINTENANCE_OUT:\r\ncase SECURITY_PROTOCOL_OUT:\r\ncase ACCESS_CONTROL_OUT:\r\nret = DMA_TO_DEVICE;\r\nbreak;\r\ncase ALLOW_MEDIUM_REMOVAL:\r\ncase TEST_UNIT_READY:\r\ncase SYNCHRONIZE_CACHE:\r\ncase START_STOP:\r\ncase ERASE:\r\ncase REZERO_UNIT:\r\ncase SEEK_10:\r\ncase SPACE:\r\ncase VERIFY:\r\ncase WRITE_FILEMARKS:\r\nret = DMA_NONE;\r\nbreak;\r\ndefault:\r\n#define CMD_DIR_MSG "target: Unknown data direction for SCSI Opcode 0x%02x\n"\r\npr_warn(CMD_DIR_MSG, cdb[0]);\r\n#undef CMD_DIR_MSG\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void usbg_data_write_cmpl(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbg_cmd *cmd = req->context;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nif (req->status < 0) {\r\npr_err("%s() state %d transfer failed\n", __func__, cmd->state);\r\ngoto cleanup;\r\n}\r\nif (req->num_sgs == 0) {\r\nsg_copy_from_buffer(se_cmd->t_data_sg,\r\nse_cmd->t_data_nents,\r\ncmd->data_buf,\r\nse_cmd->data_length);\r\n}\r\ncomplete(&cmd->write_complete);\r\nreturn;\r\ncleanup:\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\n}\r\nstatic int usbg_prepare_w_request(struct usbg_cmd *cmd, struct usb_request *req)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct f_uas *fu = cmd->fu;\r\nstruct usb_gadget *gadget = fuas_to_gadget(fu);\r\nif (!gadget->sg_supported) {\r\ncmd->data_buf = kmalloc(se_cmd->data_length, GFP_ATOMIC);\r\nif (!cmd->data_buf)\r\nreturn -ENOMEM;\r\nreq->buf = cmd->data_buf;\r\n} else {\r\nreq->buf = NULL;\r\nreq->num_sgs = se_cmd->t_data_nents;\r\nreq->sg = se_cmd->t_data_sg;\r\n}\r\nreq->complete = usbg_data_write_cmpl;\r\nreq->length = se_cmd->data_length;\r\nreq->context = cmd;\r\nreturn 0;\r\n}\r\nstatic int usbg_send_status_response(struct se_cmd *se_cmd)\r\n{\r\nstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\r\nse_cmd);\r\nstruct f_uas *fu = cmd->fu;\r\nif (fu->flags & USBG_IS_BOT)\r\nreturn bot_send_status_response(cmd);\r\nelse\r\nreturn uasp_send_status_response(cmd);\r\n}\r\nstatic int usbg_send_write_request(struct se_cmd *se_cmd)\r\n{\r\nstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\r\nse_cmd);\r\nstruct f_uas *fu = cmd->fu;\r\nif (fu->flags & USBG_IS_BOT)\r\nreturn bot_send_write_request(cmd);\r\nelse\r\nreturn uasp_send_write_request(cmd);\r\n}\r\nstatic int usbg_send_read_response(struct se_cmd *se_cmd)\r\n{\r\nstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\r\nse_cmd);\r\nstruct f_uas *fu = cmd->fu;\r\nif (fu->flags & USBG_IS_BOT)\r\nreturn bot_send_read_response(cmd);\r\nelse\r\nreturn uasp_send_read_response(cmd);\r\n}\r\nstatic void usbg_cmd_work(struct work_struct *work)\r\n{\r\nstruct usbg_cmd *cmd = container_of(work, struct usbg_cmd, work);\r\nstruct se_cmd *se_cmd;\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nstruct usbg_tpg *tpg;\r\nint dir, flags = (TARGET_SCF_UNKNOWN_SIZE | TARGET_SCF_ACK_KREF);\r\nse_cmd = &cmd->se_cmd;\r\ntpg = cmd->fu->tpg;\r\ntv_nexus = tpg->tpg_nexus;\r\ndir = get_cmd_dir(cmd->cmd_buf);\r\nif (dir < 0) {\r\ntransport_init_se_cmd(se_cmd,\r\ntv_nexus->tvn_se_sess->se_tpg->se_tpg_tfo,\r\ntv_nexus->tvn_se_sess, cmd->data_len, DMA_NONE,\r\ncmd->prio_attr, cmd->sense_iu.sense);\r\ngoto out;\r\n}\r\nif (target_submit_cmd(se_cmd, tv_nexus->tvn_se_sess, cmd->cmd_buf,\r\ncmd->sense_iu.sense, cmd->unpacked_lun, 0,\r\ncmd->prio_attr, dir, flags) < 0)\r\ngoto out;\r\nreturn;\r\nout:\r\ntransport_send_check_condition_and_sense(se_cmd,\r\nTCM_UNSUPPORTED_SCSI_OPCODE, 1);\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\n}\r\nstatic struct usbg_cmd *usbg_get_cmd(struct f_uas *fu,\r\nstruct tcm_usbg_nexus *tv_nexus, u32 scsi_tag)\r\n{\r\nstruct se_session *se_sess = tv_nexus->tvn_se_sess;\r\nstruct usbg_cmd *cmd;\r\nint tag;\r\ntag = percpu_ida_alloc(&se_sess->sess_tag_pool, GFP_ATOMIC);\r\nif (tag < 0)\r\nreturn ERR_PTR(-ENOMEM);\r\ncmd = &((struct usbg_cmd *)se_sess->sess_cmd_map)[tag];\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->se_cmd.map_tag = tag;\r\ncmd->se_cmd.tag = cmd->tag = scsi_tag;\r\ncmd->fu = fu;\r\nreturn cmd;\r\n}\r\nstatic int usbg_submit_command(struct f_uas *fu,\r\nvoid *cmdbuf, unsigned int len)\r\n{\r\nstruct command_iu *cmd_iu = cmdbuf;\r\nstruct usbg_cmd *cmd;\r\nstruct usbg_tpg *tpg = fu->tpg;\r\nstruct tcm_usbg_nexus *tv_nexus = tpg->tpg_nexus;\r\nu32 cmd_len;\r\nu16 scsi_tag;\r\nif (cmd_iu->iu_id != IU_ID_COMMAND) {\r\npr_err("Unsupported type %d\n", cmd_iu->iu_id);\r\nreturn -EINVAL;\r\n}\r\ntv_nexus = tpg->tpg_nexus;\r\nif (!tv_nexus) {\r\npr_err("Missing nexus, ignoring command\n");\r\nreturn -EINVAL;\r\n}\r\ncmd_len = (cmd_iu->len & ~0x3) + 16;\r\nif (cmd_len > USBG_MAX_CMD)\r\nreturn -EINVAL;\r\nscsi_tag = be16_to_cpup(&cmd_iu->tag);\r\ncmd = usbg_get_cmd(fu, tv_nexus, scsi_tag);\r\nif (IS_ERR(cmd)) {\r\npr_err("usbg_get_cmd failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(cmd->cmd_buf, cmd_iu->cdb, cmd_len);\r\nif (fu->flags & USBG_USE_STREAMS) {\r\nif (cmd->tag > UASP_SS_EP_COMP_NUM_STREAMS)\r\ngoto err;\r\nif (!cmd->tag)\r\ncmd->stream = &fu->stream[0];\r\nelse\r\ncmd->stream = &fu->stream[cmd->tag - 1];\r\n} else {\r\ncmd->stream = &fu->stream[0];\r\n}\r\nswitch (cmd_iu->prio_attr & 0x7) {\r\ncase UAS_HEAD_TAG:\r\ncmd->prio_attr = TCM_HEAD_TAG;\r\nbreak;\r\ncase UAS_ORDERED_TAG:\r\ncmd->prio_attr = TCM_ORDERED_TAG;\r\nbreak;\r\ncase UAS_ACA:\r\ncmd->prio_attr = TCM_ACA_TAG;\r\nbreak;\r\ndefault:\r\npr_debug_once("Unsupported prio_attr: %02x.\n",\r\ncmd_iu->prio_attr);\r\ncase UAS_SIMPLE_TAG:\r\ncmd->prio_attr = TCM_SIMPLE_TAG;\r\nbreak;\r\n}\r\ncmd->unpacked_lun = scsilun_to_int(&cmd_iu->lun);\r\nINIT_WORK(&cmd->work, usbg_cmd_work);\r\nqueue_work(tpg->workqueue, &cmd->work);\r\nreturn 0;\r\nerr:\r\nusbg_release_cmd(&cmd->se_cmd);\r\nreturn -EINVAL;\r\n}\r\nstatic void bot_cmd_work(struct work_struct *work)\r\n{\r\nstruct usbg_cmd *cmd = container_of(work, struct usbg_cmd, work);\r\nstruct se_cmd *se_cmd;\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nstruct usbg_tpg *tpg;\r\nint dir;\r\nse_cmd = &cmd->se_cmd;\r\ntpg = cmd->fu->tpg;\r\ntv_nexus = tpg->tpg_nexus;\r\ndir = get_cmd_dir(cmd->cmd_buf);\r\nif (dir < 0) {\r\ntransport_init_se_cmd(se_cmd,\r\ntv_nexus->tvn_se_sess->se_tpg->se_tpg_tfo,\r\ntv_nexus->tvn_se_sess, cmd->data_len, DMA_NONE,\r\ncmd->prio_attr, cmd->sense_iu.sense);\r\ngoto out;\r\n}\r\nif (target_submit_cmd(se_cmd, tv_nexus->tvn_se_sess,\r\ncmd->cmd_buf, cmd->sense_iu.sense, cmd->unpacked_lun,\r\ncmd->data_len, cmd->prio_attr, dir, 0) < 0)\r\ngoto out;\r\nreturn;\r\nout:\r\ntransport_send_check_condition_and_sense(se_cmd,\r\nTCM_UNSUPPORTED_SCSI_OPCODE, 1);\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\n}\r\nstatic int bot_submit_command(struct f_uas *fu,\r\nvoid *cmdbuf, unsigned int len)\r\n{\r\nstruct bulk_cb_wrap *cbw = cmdbuf;\r\nstruct usbg_cmd *cmd;\r\nstruct usbg_tpg *tpg = fu->tpg;\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nu32 cmd_len;\r\nif (cbw->Signature != cpu_to_le32(US_BULK_CB_SIGN)) {\r\npr_err("Wrong signature on CBW\n");\r\nreturn -EINVAL;\r\n}\r\nif (len != 31) {\r\npr_err("Wrong length for CBW\n");\r\nreturn -EINVAL;\r\n}\r\ncmd_len = cbw->Length;\r\nif (cmd_len < 1 || cmd_len > 16)\r\nreturn -EINVAL;\r\ntv_nexus = tpg->tpg_nexus;\r\nif (!tv_nexus) {\r\npr_err("Missing nexus, ignoring command\n");\r\nreturn -ENODEV;\r\n}\r\ncmd = usbg_get_cmd(fu, tv_nexus, cbw->Tag);\r\nif (IS_ERR(cmd)) {\r\npr_err("usbg_get_cmd failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(cmd->cmd_buf, cbw->CDB, cmd_len);\r\ncmd->bot_tag = cbw->Tag;\r\ncmd->prio_attr = TCM_SIMPLE_TAG;\r\ncmd->unpacked_lun = cbw->Lun;\r\ncmd->is_read = cbw->Flags & US_BULK_FLAG_IN ? 1 : 0;\r\ncmd->data_len = le32_to_cpu(cbw->DataTransferLength);\r\ncmd->se_cmd.tag = le32_to_cpu(cmd->bot_tag);\r\nINIT_WORK(&cmd->work, bot_cmd_work);\r\nqueue_work(tpg->workqueue, &cmd->work);\r\nreturn 0;\r\n}\r\nstatic int usbg_check_true(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic int usbg_check_false(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic char *usbg_get_fabric_name(void)\r\n{\r\nreturn "usb_gadget";\r\n}\r\nstatic char *usbg_get_fabric_wwn(struct se_portal_group *se_tpg)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\nstruct usbg_tport *tport = tpg->tport;\r\nreturn &tport->tport_name[0];\r\n}\r\nstatic u16 usbg_get_tag(struct se_portal_group *se_tpg)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\nreturn tpg->tport_tpgt;\r\n}\r\nstatic u32 usbg_tpg_get_inst_index(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic void usbg_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\r\nse_cmd);\r\nstruct se_session *se_sess = se_cmd->se_sess;\r\nkfree(cmd->data_buf);\r\npercpu_ida_free(&se_sess->sess_tag_pool, se_cmd->map_tag);\r\n}\r\nstatic u32 usbg_sess_get_index(struct se_session *se_sess)\r\n{\r\nreturn 0;\r\n}\r\nstatic int usbg_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void usbg_set_default_node_attrs(struct se_node_acl *nacl)\r\n{\r\n}\r\nstatic int usbg_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void usbg_queue_tm_rsp(struct se_cmd *se_cmd)\r\n{\r\n}\r\nstatic void usbg_aborted_task(struct se_cmd *se_cmd)\r\n{\r\n}\r\nstatic const char *usbg_check_wwn(const char *name)\r\n{\r\nconst char *n;\r\nunsigned int len;\r\nn = strstr(name, "naa.");\r\nif (!n)\r\nreturn NULL;\r\nn += 4;\r\nlen = strlen(n);\r\nif (len == 0 || len > USBG_NAMELEN - 1)\r\nreturn NULL;\r\nreturn n;\r\n}\r\nstatic int usbg_init_nodeacl(struct se_node_acl *se_nacl, const char *name)\r\n{\r\nif (!usbg_check_wwn(name))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic struct se_portal_group *usbg_make_tpg(\r\nstruct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct usbg_tport *tport = container_of(wwn, struct usbg_tport,\r\ntport_wwn);\r\nstruct usbg_tpg *tpg;\r\nunsigned long tpgt;\r\nint ret;\r\nstruct f_tcm_opts *opts;\r\nunsigned i;\r\nif (strstr(name, "tpgt_") != name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (kstrtoul(name + 5, 0, &tpgt) || tpgt > UINT_MAX)\r\nreturn ERR_PTR(-EINVAL);\r\nret = -ENODEV;\r\nmutex_lock(&tpg_instances_lock);\r\nfor (i = 0; i < TPG_INSTANCES; ++i)\r\nif (tpg_instances[i].func_inst && !tpg_instances[i].tpg)\r\nbreak;\r\nif (i == TPG_INSTANCES)\r\ngoto unlock_inst;\r\nopts = container_of(tpg_instances[i].func_inst, struct f_tcm_opts,\r\nfunc_inst);\r\nmutex_lock(&opts->dep_lock);\r\nif (!opts->ready)\r\ngoto unlock_dep;\r\nif (opts->has_dep) {\r\nif (!try_module_get(opts->dependent))\r\ngoto unlock_dep;\r\n} else {\r\nret = configfs_depend_item_unlocked(\r\ngroup->cg_subsys,\r\n&opts->func_inst.group.cg_item);\r\nif (ret)\r\ngoto unlock_dep;\r\n}\r\ntpg = kzalloc(sizeof(struct usbg_tpg), GFP_KERNEL);\r\nret = -ENOMEM;\r\nif (!tpg)\r\ngoto unref_dep;\r\nmutex_init(&tpg->tpg_mutex);\r\natomic_set(&tpg->tpg_port_count, 0);\r\ntpg->workqueue = alloc_workqueue("tcm_usb_gadget", 0, 1);\r\nif (!tpg->workqueue)\r\ngoto free_tpg;\r\ntpg->tport = tport;\r\ntpg->tport_tpgt = tpgt;\r\nret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_SAS);\r\nif (ret < 0)\r\ngoto free_workqueue;\r\ntpg_instances[i].tpg = tpg;\r\ntpg->fi = tpg_instances[i].func_inst;\r\nmutex_unlock(&opts->dep_lock);\r\nmutex_unlock(&tpg_instances_lock);\r\nreturn &tpg->se_tpg;\r\nfree_workqueue:\r\ndestroy_workqueue(tpg->workqueue);\r\nfree_tpg:\r\nkfree(tpg);\r\nunref_dep:\r\nif (opts->has_dep)\r\nmodule_put(opts->dependent);\r\nelse\r\nconfigfs_undepend_item_unlocked(&opts->func_inst.group.cg_item);\r\nunlock_dep:\r\nmutex_unlock(&opts->dep_lock);\r\nunlock_inst:\r\nmutex_unlock(&tpg_instances_lock);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void usbg_drop_tpg(struct se_portal_group *se_tpg)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\nunsigned i;\r\nstruct f_tcm_opts *opts;\r\ntcm_usbg_drop_nexus(tpg);\r\ncore_tpg_deregister(se_tpg);\r\ndestroy_workqueue(tpg->workqueue);\r\nmutex_lock(&tpg_instances_lock);\r\nfor (i = 0; i < TPG_INSTANCES; ++i)\r\nif (tpg_instances[i].tpg == tpg)\r\nbreak;\r\nif (i < TPG_INSTANCES) {\r\ntpg_instances[i].tpg = NULL;\r\nopts = container_of(tpg_instances[i].func_inst,\r\nstruct f_tcm_opts, func_inst);\r\nmutex_lock(&opts->dep_lock);\r\nif (opts->has_dep)\r\nmodule_put(opts->dependent);\r\nelse\r\nconfigfs_undepend_item_unlocked(\r\n&opts->func_inst.group.cg_item);\r\nmutex_unlock(&opts->dep_lock);\r\n}\r\nmutex_unlock(&tpg_instances_lock);\r\nkfree(tpg);\r\n}\r\nstatic struct se_wwn *usbg_make_tport(\r\nstruct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct usbg_tport *tport;\r\nconst char *wnn_name;\r\nu64 wwpn = 0;\r\nwnn_name = usbg_check_wwn(name);\r\nif (!wnn_name)\r\nreturn ERR_PTR(-EINVAL);\r\ntport = kzalloc(sizeof(struct usbg_tport), GFP_KERNEL);\r\nif (!(tport))\r\nreturn ERR_PTR(-ENOMEM);\r\ntport->tport_wwpn = wwpn;\r\nsnprintf(tport->tport_name, sizeof(tport->tport_name), "%s", wnn_name);\r\nreturn &tport->tport_wwn;\r\n}\r\nstatic void usbg_drop_tport(struct se_wwn *wwn)\r\n{\r\nstruct usbg_tport *tport = container_of(wwn,\r\nstruct usbg_tport, tport_wwn);\r\nkfree(tport);\r\n}\r\nstatic ssize_t usbg_wwn_version_show(struct config_item *item, char *page)\r\n{\r\nreturn sprintf(page, "usb-gadget fabric module\n");\r\n}\r\nstatic ssize_t tcm_usbg_tpg_enable_show(struct config_item *item, char *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\nreturn snprintf(page, PAGE_SIZE, "%u\n", tpg->gadget_connect);\r\n}\r\nstatic ssize_t tcm_usbg_tpg_enable_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\nbool op;\r\nssize_t ret;\r\nret = strtobool(page, &op);\r\nif (ret)\r\nreturn ret;\r\nif ((op && tpg->gadget_connect) || (!op && !tpg->gadget_connect))\r\nreturn -EINVAL;\r\nif (op)\r\nret = usbg_attach(tpg);\r\nelse\r\nusbg_detach(tpg);\r\nif (ret)\r\nreturn ret;\r\ntpg->gadget_connect = op;\r\nreturn count;\r\n}\r\nstatic ssize_t tcm_usbg_tpg_nexus_show(struct config_item *item, char *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nssize_t ret;\r\nmutex_lock(&tpg->tpg_mutex);\r\ntv_nexus = tpg->tpg_nexus;\r\nif (!tv_nexus) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = snprintf(page, PAGE_SIZE, "%s\n",\r\ntv_nexus->tvn_se_sess->se_node_acl->initiatorname);\r\nout:\r\nmutex_unlock(&tpg->tpg_mutex);\r\nreturn ret;\r\n}\r\nstatic int usbg_alloc_sess_cb(struct se_portal_group *se_tpg,\r\nstruct se_session *se_sess, void *p)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\ntpg->tpg_nexus = p;\r\nreturn 0;\r\n}\r\nstatic int tcm_usbg_make_nexus(struct usbg_tpg *tpg, char *name)\r\n{\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nint ret = 0;\r\nmutex_lock(&tpg->tpg_mutex);\r\nif (tpg->tpg_nexus) {\r\nret = -EEXIST;\r\npr_debug("tpg->tpg_nexus already exists\n");\r\ngoto out_unlock;\r\n}\r\ntv_nexus = kzalloc(sizeof(*tv_nexus), GFP_KERNEL);\r\nif (!tv_nexus) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\ntv_nexus->tvn_se_sess = target_alloc_session(&tpg->se_tpg,\r\nUSB_G_DEFAULT_SESSION_TAGS,\r\nsizeof(struct usbg_cmd),\r\nTARGET_PROT_NORMAL, name,\r\ntv_nexus, usbg_alloc_sess_cb);\r\nif (IS_ERR(tv_nexus->tvn_se_sess)) {\r\n#define MAKE_NEXUS_MSG "core_tpg_check_initiator_node_acl() failed for %s\n"\r\npr_debug(MAKE_NEXUS_MSG, name);\r\n#undef MAKE_NEXUS_MSG\r\nret = PTR_ERR(tv_nexus->tvn_se_sess);\r\nkfree(tv_nexus);\r\n}\r\nout_unlock:\r\nmutex_unlock(&tpg->tpg_mutex);\r\nreturn ret;\r\n}\r\nstatic int tcm_usbg_drop_nexus(struct usbg_tpg *tpg)\r\n{\r\nstruct se_session *se_sess;\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nint ret = -ENODEV;\r\nmutex_lock(&tpg->tpg_mutex);\r\ntv_nexus = tpg->tpg_nexus;\r\nif (!tv_nexus)\r\ngoto out;\r\nse_sess = tv_nexus->tvn_se_sess;\r\nif (!se_sess)\r\ngoto out;\r\nif (atomic_read(&tpg->tpg_port_count)) {\r\nret = -EPERM;\r\n#define MSG "Unable to remove Host I_T Nexus with active TPG port count: %d\n"\r\npr_err(MSG, atomic_read(&tpg->tpg_port_count));\r\n#undef MSG\r\ngoto out;\r\n}\r\npr_debug("Removing I_T Nexus to Initiator Port: %s\n",\r\ntv_nexus->tvn_se_sess->se_node_acl->initiatorname);\r\ntransport_deregister_session(tv_nexus->tvn_se_sess);\r\ntpg->tpg_nexus = NULL;\r\nkfree(tv_nexus);\r\nret = 0;\r\nout:\r\nmutex_unlock(&tpg->tpg_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t tcm_usbg_tpg_nexus_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\nunsigned char i_port[USBG_NAMELEN], *ptr;\r\nint ret;\r\nif (!strncmp(page, "NULL", 4)) {\r\nret = tcm_usbg_drop_nexus(tpg);\r\nreturn (!ret) ? count : ret;\r\n}\r\nif (strlen(page) >= USBG_NAMELEN) {\r\n#define NEXUS_STORE_MSG "Emulated NAA Sas Address: %s, exceeds max: %d\n"\r\npr_err(NEXUS_STORE_MSG, page, USBG_NAMELEN);\r\n#undef NEXUS_STORE_MSG\r\nreturn -EINVAL;\r\n}\r\nsnprintf(i_port, USBG_NAMELEN, "%s", page);\r\nptr = strstr(i_port, "naa.");\r\nif (!ptr) {\r\npr_err("Missing 'naa.' prefix\n");\r\nreturn -EINVAL;\r\n}\r\nif (i_port[strlen(i_port) - 1] == '\n')\r\ni_port[strlen(i_port) - 1] = '\0';\r\nret = tcm_usbg_make_nexus(tpg, &i_port[0]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int usbg_port_link(struct se_portal_group *se_tpg, struct se_lun *lun)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\natomic_inc(&tpg->tpg_port_count);\r\nsmp_mb__after_atomic();\r\nreturn 0;\r\n}\r\nstatic void usbg_port_unlink(struct se_portal_group *se_tpg,\r\nstruct se_lun *se_lun)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\natomic_dec(&tpg->tpg_port_count);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic int usbg_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nreturn target_put_sess_cmd(se_cmd);\r\n}\r\nstatic int tcm_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nstruct usb_string *us;\r\nstruct usb_gadget *gadget = c->cdev->gadget;\r\nstruct usb_ep *ep;\r\nstruct f_tcm_opts *opts;\r\nint iface;\r\nint ret;\r\nopts = container_of(f->fi, struct f_tcm_opts, func_inst);\r\nmutex_lock(&opts->dep_lock);\r\nif (!opts->can_attach) {\r\nmutex_unlock(&opts->dep_lock);\r\nreturn -ENODEV;\r\n}\r\nmutex_unlock(&opts->dep_lock);\r\nus = usb_gstrings_attach(c->cdev, tcm_strings,\r\nARRAY_SIZE(tcm_us_strings));\r\nif (IS_ERR(us))\r\nreturn PTR_ERR(us);\r\nbot_intf_desc.iInterface = us[USB_G_STR_INT_BBB].id;\r\nuasp_intf_desc.iInterface = us[USB_G_STR_INT_UAS].id;\r\niface = usb_interface_id(c, f);\r\nif (iface < 0)\r\nreturn iface;\r\nbot_intf_desc.bInterfaceNumber = iface;\r\nuasp_intf_desc.bInterfaceNumber = iface;\r\nfu->iface = iface;\r\nep = usb_ep_autoconfig_ss(gadget, &uasp_ss_bi_desc,\r\n&uasp_bi_ep_comp_desc);\r\nif (!ep)\r\ngoto ep_fail;\r\nfu->ep_in = ep;\r\nep = usb_ep_autoconfig_ss(gadget, &uasp_ss_bo_desc,\r\n&uasp_bo_ep_comp_desc);\r\nif (!ep)\r\ngoto ep_fail;\r\nfu->ep_out = ep;\r\nep = usb_ep_autoconfig_ss(gadget, &uasp_ss_status_desc,\r\n&uasp_status_in_ep_comp_desc);\r\nif (!ep)\r\ngoto ep_fail;\r\nfu->ep_status = ep;\r\nep = usb_ep_autoconfig_ss(gadget, &uasp_ss_cmd_desc,\r\n&uasp_cmd_comp_desc);\r\nif (!ep)\r\ngoto ep_fail;\r\nfu->ep_cmd = ep;\r\nuasp_bi_desc.bEndpointAddress = uasp_ss_bi_desc.bEndpointAddress;\r\nuasp_bo_desc.bEndpointAddress = uasp_ss_bo_desc.bEndpointAddress;\r\nuasp_status_desc.bEndpointAddress =\r\nuasp_ss_status_desc.bEndpointAddress;\r\nuasp_cmd_desc.bEndpointAddress = uasp_ss_cmd_desc.bEndpointAddress;\r\nuasp_fs_bi_desc.bEndpointAddress = uasp_ss_bi_desc.bEndpointAddress;\r\nuasp_fs_bo_desc.bEndpointAddress = uasp_ss_bo_desc.bEndpointAddress;\r\nuasp_fs_status_desc.bEndpointAddress =\r\nuasp_ss_status_desc.bEndpointAddress;\r\nuasp_fs_cmd_desc.bEndpointAddress = uasp_ss_cmd_desc.bEndpointAddress;\r\nret = usb_assign_descriptors(f, uasp_fs_function_desc,\r\nuasp_hs_function_desc, uasp_ss_function_desc, NULL);\r\nif (ret)\r\ngoto ep_fail;\r\nreturn 0;\r\nep_fail:\r\npr_err("Can't claim all required eps\n");\r\nreturn -ENOTSUPP;\r\n}\r\nstatic void tcm_delayed_set_alt(struct work_struct *wq)\r\n{\r\nstruct guas_setup_wq *work = container_of(wq, struct guas_setup_wq,\r\nwork);\r\nstruct f_uas *fu = work->fu;\r\nint alt = work->alt;\r\nkfree(work);\r\nif (fu->flags & USBG_IS_BOT)\r\nbot_cleanup_old_alt(fu);\r\nif (fu->flags & USBG_IS_UAS)\r\nuasp_cleanup_old_alt(fu);\r\nif (alt == USB_G_ALT_INT_BBB)\r\nbot_set_alt(fu);\r\nelse if (alt == USB_G_ALT_INT_UAS)\r\nuasp_set_alt(fu);\r\nusb_composite_setup_continue(fu->function.config->cdev);\r\n}\r\nstatic int tcm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nif ((alt == USB_G_ALT_INT_BBB) || (alt == USB_G_ALT_INT_UAS)) {\r\nstruct guas_setup_wq *work;\r\nwork = kmalloc(sizeof(*work), GFP_ATOMIC);\r\nif (!work)\r\nreturn -ENOMEM;\r\nINIT_WORK(&work->work, tcm_delayed_set_alt);\r\nwork->fu = fu;\r\nwork->alt = alt;\r\nschedule_work(&work->work);\r\nreturn USB_GADGET_DELAYED_STATUS;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void tcm_disable(struct usb_function *f)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nif (fu->flags & USBG_IS_UAS)\r\nuasp_cleanup_old_alt(fu);\r\nelse if (fu->flags & USBG_IS_BOT)\r\nbot_cleanup_old_alt(fu);\r\nfu->flags = 0;\r\n}\r\nstatic int tcm_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nif (!(fu->flags & USBG_IS_BOT))\r\nreturn -EOPNOTSUPP;\r\nreturn usbg_bot_setup(f, ctrl);\r\n}\r\nstatic inline struct f_tcm_opts *to_f_tcm_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_tcm_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void tcm_attr_release(struct config_item *item)\r\n{\r\nstruct f_tcm_opts *opts = to_f_tcm_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic void tcm_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_tcm_opts *opts;\r\nunsigned i;\r\nopts = container_of(f, struct f_tcm_opts, func_inst);\r\nmutex_lock(&tpg_instances_lock);\r\nfor (i = 0; i < TPG_INSTANCES; ++i)\r\nif (tpg_instances[i].func_inst == f)\r\nbreak;\r\nif (i < TPG_INSTANCES)\r\ntpg_instances[i].func_inst = NULL;\r\nmutex_unlock(&tpg_instances_lock);\r\nkfree(opts);\r\n}\r\nstatic int tcm_register_callback(struct usb_function_instance *f)\r\n{\r\nstruct f_tcm_opts *opts = container_of(f, struct f_tcm_opts, func_inst);\r\nmutex_lock(&opts->dep_lock);\r\nopts->can_attach = true;\r\nmutex_unlock(&opts->dep_lock);\r\nreturn 0;\r\n}\r\nstatic void tcm_unregister_callback(struct usb_function_instance *f)\r\n{\r\nstruct f_tcm_opts *opts = container_of(f, struct f_tcm_opts, func_inst);\r\nmutex_lock(&opts->dep_lock);\r\nunregister_gadget_item(opts->\r\nfunc_inst.group.cg_item.ci_parent->ci_parent);\r\nopts->can_attach = false;\r\nmutex_unlock(&opts->dep_lock);\r\n}\r\nstatic int usbg_attach(struct usbg_tpg *tpg)\r\n{\r\nstruct usb_function_instance *f = tpg->fi;\r\nstruct f_tcm_opts *opts = container_of(f, struct f_tcm_opts, func_inst);\r\nif (opts->tcm_register_callback)\r\nreturn opts->tcm_register_callback(f);\r\nreturn 0;\r\n}\r\nstatic void usbg_detach(struct usbg_tpg *tpg)\r\n{\r\nstruct usb_function_instance *f = tpg->fi;\r\nstruct f_tcm_opts *opts = container_of(f, struct f_tcm_opts, func_inst);\r\nif (opts->tcm_unregister_callback)\r\nopts->tcm_unregister_callback(f);\r\n}\r\nstatic int tcm_set_name(struct usb_function_instance *f, const char *name)\r\n{\r\nstruct f_tcm_opts *opts = container_of(f, struct f_tcm_opts, func_inst);\r\npr_debug("tcm: Activating %s\n", name);\r\nmutex_lock(&opts->dep_lock);\r\nopts->ready = true;\r\nmutex_unlock(&opts->dep_lock);\r\nreturn 0;\r\n}\r\nstatic struct usb_function_instance *tcm_alloc_inst(void)\r\n{\r\nstruct f_tcm_opts *opts;\r\nint i;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_lock(&tpg_instances_lock);\r\nfor (i = 0; i < TPG_INSTANCES; ++i)\r\nif (!tpg_instances[i].func_inst)\r\nbreak;\r\nif (i == TPG_INSTANCES) {\r\nmutex_unlock(&tpg_instances_lock);\r\nkfree(opts);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\ntpg_instances[i].func_inst = &opts->func_inst;\r\nmutex_unlock(&tpg_instances_lock);\r\nmutex_init(&opts->dep_lock);\r\nopts->func_inst.set_inst_name = tcm_set_name;\r\nopts->func_inst.free_func_inst = tcm_free_inst;\r\nopts->tcm_register_callback = tcm_register_callback;\r\nopts->tcm_unregister_callback = tcm_unregister_callback;\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&tcm_func_type);\r\nreturn &opts->func_inst;\r\n}\r\nstatic void tcm_free(struct usb_function *f)\r\n{\r\nstruct f_uas *tcm = to_f_uas(f);\r\nkfree(tcm);\r\n}\r\nstatic void tcm_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nusb_free_all_descriptors(f);\r\n}\r\nstatic struct usb_function *tcm_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_uas *fu;\r\nunsigned i;\r\nmutex_lock(&tpg_instances_lock);\r\nfor (i = 0; i < TPG_INSTANCES; ++i)\r\nif (tpg_instances[i].func_inst == fi)\r\nbreak;\r\nif (i == TPG_INSTANCES) {\r\nmutex_unlock(&tpg_instances_lock);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nfu = kzalloc(sizeof(*fu), GFP_KERNEL);\r\nif (!fu) {\r\nmutex_unlock(&tpg_instances_lock);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfu->function.name = "Target Function";\r\nfu->function.bind = tcm_bind;\r\nfu->function.unbind = tcm_unbind;\r\nfu->function.set_alt = tcm_set_alt;\r\nfu->function.setup = tcm_setup;\r\nfu->function.disable = tcm_disable;\r\nfu->function.free_func = tcm_free;\r\nfu->tpg = tpg_instances[i].tpg;\r\nmutex_unlock(&tpg_instances_lock);\r\nreturn &fu->function;\r\n}\r\nstatic int tcm_init(void)\r\n{\r\nint ret;\r\nret = usb_function_register(&tcmusb_func);\r\nif (ret)\r\nreturn ret;\r\nret = target_register_template(&usbg_ops);\r\nif (ret)\r\nusb_function_unregister(&tcmusb_func);\r\nreturn ret;\r\n}\r\nstatic void tcm_exit(void)\r\n{\r\ntarget_unregister_template(&usbg_ops);\r\nusb_function_unregister(&tcmusb_func);\r\n}
