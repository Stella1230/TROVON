static void amba_register_dummy_clk(void)\r\n{\r\nstatic struct clk *amba_dummy_clk;\r\nif (amba_dummy_clk)\r\nreturn;\r\namba_dummy_clk = clk_register_fixed_rate(NULL, "apb_pclk", NULL, 0, 0);\r\nclk_register_clkdev(amba_dummy_clk, "apb_pclk", NULL);\r\n}\r\nstatic int amba_handler_attach(struct acpi_device *adev,\r\nconst struct acpi_device_id *id)\r\n{\r\nstruct amba_device *dev;\r\nstruct resource_entry *rentry;\r\nstruct list_head resource_list;\r\nbool address_found = false;\r\nint irq_no = 0;\r\nint ret;\r\nif (adev->physical_node_count)\r\nreturn 0;\r\ndev = amba_device_alloc(dev_name(&adev->dev), 0, 0);\r\nif (!dev) {\r\ndev_err(&adev->dev, "%s(): amba_device_alloc() failed\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&resource_list);\r\nret = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);\r\nif (ret < 0)\r\ngoto err_free;\r\nlist_for_each_entry(rentry, &resource_list, node) {\r\nswitch (resource_type(rentry->res)) {\r\ncase IORESOURCE_MEM:\r\nif (!address_found) {\r\ndev->res = *rentry->res;\r\naddress_found = true;\r\n}\r\nbreak;\r\ncase IORESOURCE_IRQ:\r\nif (irq_no < AMBA_NR_IRQS)\r\ndev->irq[irq_no++] = rentry->res->start;\r\nbreak;\r\ndefault:\r\ndev_warn(&adev->dev, "Invalid resource\n");\r\nbreak;\r\n}\r\n}\r\nacpi_dev_free_resource_list(&resource_list);\r\nif (adev->parent)\r\ndev->dev.parent = acpi_get_first_physical_node(adev->parent);\r\nACPI_COMPANION_SET(&dev->dev, adev);\r\nret = amba_device_add(dev, &iomem_resource);\r\nif (ret) {\r\ndev_err(&adev->dev, "%s(): amba_device_add() failed (%d)\n",\r\n__func__, ret);\r\ngoto err_free;\r\n}\r\nreturn 1;\r\nerr_free:\r\namba_device_put(dev);\r\nreturn ret;\r\n}\r\nvoid __init acpi_amba_init(void)\r\n{\r\namba_register_dummy_clk();\r\nacpi_scan_add_handler(&amba_handler);\r\n}
