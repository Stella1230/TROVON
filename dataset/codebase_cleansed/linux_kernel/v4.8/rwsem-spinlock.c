int rwsem_is_locked(struct rw_semaphore *sem)\r\n{\r\nint ret = 1;\r\nunsigned long flags;\r\nif (raw_spin_trylock_irqsave(&sem->wait_lock, flags)) {\r\nret = (sem->count != 0);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nvoid __init_rwsem(struct rw_semaphore *sem, const char *name,\r\nstruct lock_class_key *key)\r\n{\r\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\r\ndebug_check_no_locks_freed((void *)sem, sizeof(*sem));\r\nlockdep_init_map(&sem->dep_map, name, key, 0);\r\n#endif\r\nsem->count = 0;\r\nraw_spin_lock_init(&sem->wait_lock);\r\nINIT_LIST_HEAD(&sem->wait_list);\r\n}\r\nstatic inline struct rw_semaphore *\r\n__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)\r\n{\r\nstruct rwsem_waiter *waiter;\r\nstruct task_struct *tsk;\r\nint woken;\r\nwaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\r\nif (waiter->type == RWSEM_WAITING_FOR_WRITE) {\r\nif (wakewrite)\r\nwake_up_process(waiter->task);\r\ngoto out;\r\n}\r\nwoken = 0;\r\ndo {\r\nstruct list_head *next = waiter->list.next;\r\nlist_del(&waiter->list);\r\ntsk = waiter->task;\r\nsmp_mb();\r\nwaiter->task = NULL;\r\nwake_up_process(tsk);\r\nput_task_struct(tsk);\r\nwoken++;\r\nif (next == &sem->wait_list)\r\nbreak;\r\nwaiter = list_entry(next, struct rwsem_waiter, list);\r\n} while (waiter->type != RWSEM_WAITING_FOR_WRITE);\r\nsem->count += woken;\r\nout:\r\nreturn sem;\r\n}\r\nstatic inline struct rw_semaphore *\r\n__rwsem_wake_one_writer(struct rw_semaphore *sem)\r\n{\r\nstruct rwsem_waiter *waiter;\r\nwaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\r\nwake_up_process(waiter->task);\r\nreturn sem;\r\n}\r\nvoid __sched __down_read(struct rw_semaphore *sem)\r\n{\r\nstruct rwsem_waiter waiter;\r\nstruct task_struct *tsk;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (sem->count >= 0 && list_empty(&sem->wait_list)) {\r\nsem->count++;\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\ngoto out;\r\n}\r\ntsk = current;\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\nwaiter.task = tsk;\r\nwaiter.type = RWSEM_WAITING_FOR_READ;\r\nget_task_struct(tsk);\r\nlist_add_tail(&waiter.list, &sem->wait_list);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nfor (;;) {\r\nif (!waiter.task)\r\nbreak;\r\nschedule();\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\n}\r\n__set_task_state(tsk, TASK_RUNNING);\r\nout:\r\n;\r\n}\r\nint __down_read_trylock(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (sem->count >= 0 && list_empty(&sem->wait_list)) {\r\nsem->count++;\r\nret = 1;\r\n}\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nreturn ret;\r\n}\r\nint __sched __down_write_common(struct rw_semaphore *sem, int state)\r\n{\r\nstruct rwsem_waiter waiter;\r\nstruct task_struct *tsk;\r\nunsigned long flags;\r\nint ret = 0;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\ntsk = current;\r\nwaiter.task = tsk;\r\nwaiter.type = RWSEM_WAITING_FOR_WRITE;\r\nlist_add_tail(&waiter.list, &sem->wait_list);\r\nfor (;;) {\r\nif (sem->count == 0)\r\nbreak;\r\nif (signal_pending_state(state, current)) {\r\nret = -EINTR;\r\ngoto out;\r\n}\r\nset_task_state(tsk, state);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nschedule();\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\n}\r\nsem->count = -1;\r\nout:\r\nlist_del(&waiter.list);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nreturn ret;\r\n}\r\nvoid __sched __down_write(struct rw_semaphore *sem)\r\n{\r\n__down_write_common(sem, TASK_UNINTERRUPTIBLE);\r\n}\r\nint __sched __down_write_killable(struct rw_semaphore *sem)\r\n{\r\nreturn __down_write_common(sem, TASK_KILLABLE);\r\n}\r\nint __down_write_trylock(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (sem->count == 0) {\r\nsem->count = -1;\r\nret = 1;\r\n}\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nreturn ret;\r\n}\r\nvoid __up_read(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (--sem->count == 0 && !list_empty(&sem->wait_list))\r\nsem = __rwsem_wake_one_writer(sem);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\n}\r\nvoid __up_write(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nsem->count = 0;\r\nif (!list_empty(&sem->wait_list))\r\nsem = __rwsem_do_wake(sem, 1);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\n}\r\nvoid __downgrade_write(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nsem->count = 1;\r\nif (!list_empty(&sem->wait_list))\r\nsem = __rwsem_do_wake(sem, 0);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\n}
