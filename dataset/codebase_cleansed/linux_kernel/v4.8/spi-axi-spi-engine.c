static void spi_engine_program_add_cmd(struct spi_engine_program *p,\r\nbool dry, uint16_t cmd)\r\n{\r\nif (!dry)\r\np->instructions[p->length] = cmd;\r\np->length++;\r\n}\r\nstatic unsigned int spi_engine_get_config(struct spi_device *spi)\r\n{\r\nunsigned int config = 0;\r\nif (spi->mode & SPI_CPOL)\r\nconfig |= SPI_ENGINE_CONFIG_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\nconfig |= SPI_ENGINE_CONFIG_CPHA;\r\nif (spi->mode & SPI_3WIRE)\r\nconfig |= SPI_ENGINE_CONFIG_3WIRE;\r\nreturn config;\r\n}\r\nstatic unsigned int spi_engine_get_clk_div(struct spi_engine *spi_engine,\r\nstruct spi_device *spi, struct spi_transfer *xfer)\r\n{\r\nunsigned int clk_div;\r\nclk_div = DIV_ROUND_UP(clk_get_rate(spi_engine->ref_clk),\r\nxfer->speed_hz * 2);\r\nif (clk_div > 255)\r\nclk_div = 255;\r\nelse if (clk_div > 0)\r\nclk_div -= 1;\r\nreturn clk_div;\r\n}\r\nstatic void spi_engine_gen_xfer(struct spi_engine_program *p, bool dry,\r\nstruct spi_transfer *xfer)\r\n{\r\nunsigned int len = xfer->len;\r\nwhile (len) {\r\nunsigned int n = min(len, 256U);\r\nunsigned int flags = 0;\r\nif (xfer->tx_buf)\r\nflags |= SPI_ENGINE_TRANSFER_WRITE;\r\nif (xfer->rx_buf)\r\nflags |= SPI_ENGINE_TRANSFER_READ;\r\nspi_engine_program_add_cmd(p, dry,\r\nSPI_ENGINE_CMD_TRANSFER(flags, n - 1));\r\nlen -= n;\r\n}\r\n}\r\nstatic void spi_engine_gen_sleep(struct spi_engine_program *p, bool dry,\r\nstruct spi_engine *spi_engine, unsigned int clk_div, unsigned int delay)\r\n{\r\nunsigned int spi_clk = clk_get_rate(spi_engine->ref_clk);\r\nunsigned int t;\r\nif (delay == 0)\r\nreturn;\r\nt = DIV_ROUND_UP(delay * spi_clk, (clk_div + 1) * 2);\r\nwhile (t) {\r\nunsigned int n = min(t, 256U);\r\nspi_engine_program_add_cmd(p, dry, SPI_ENGINE_CMD_SLEEP(n - 1));\r\nt -= n;\r\n}\r\n}\r\nstatic void spi_engine_gen_cs(struct spi_engine_program *p, bool dry,\r\nstruct spi_device *spi, bool assert)\r\n{\r\nunsigned int mask = 0xff;\r\nif (assert)\r\nmask ^= BIT(spi->chip_select);\r\nspi_engine_program_add_cmd(p, dry, SPI_ENGINE_CMD_ASSERT(1, mask));\r\n}\r\nstatic int spi_engine_compile_message(struct spi_engine *spi_engine,\r\nstruct spi_message *msg, bool dry, struct spi_engine_program *p)\r\n{\r\nstruct spi_device *spi = msg->spi;\r\nstruct spi_transfer *xfer;\r\nint clk_div, new_clk_div;\r\nbool cs_change = true;\r\nclk_div = -1;\r\nspi_engine_program_add_cmd(p, dry,\r\nSPI_ENGINE_CMD_WRITE(SPI_ENGINE_CMD_REG_CONFIG,\r\nspi_engine_get_config(spi)));\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nnew_clk_div = spi_engine_get_clk_div(spi_engine, spi, xfer);\r\nif (new_clk_div != clk_div) {\r\nclk_div = new_clk_div;\r\nspi_engine_program_add_cmd(p, dry,\r\nSPI_ENGINE_CMD_WRITE(SPI_ENGINE_CMD_REG_CLK_DIV,\r\nclk_div));\r\n}\r\nif (cs_change)\r\nspi_engine_gen_cs(p, dry, spi, true);\r\nspi_engine_gen_xfer(p, dry, xfer);\r\nspi_engine_gen_sleep(p, dry, spi_engine, clk_div,\r\nxfer->delay_usecs);\r\ncs_change = xfer->cs_change;\r\nif (list_is_last(&xfer->transfer_list, &msg->transfers))\r\ncs_change = !cs_change;\r\nif (cs_change)\r\nspi_engine_gen_cs(p, dry, spi, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic void spi_engine_xfer_next(struct spi_engine *spi_engine,\r\nstruct spi_transfer **_xfer)\r\n{\r\nstruct spi_message *msg = spi_engine->msg;\r\nstruct spi_transfer *xfer = *_xfer;\r\nif (!xfer) {\r\nxfer = list_first_entry(&msg->transfers,\r\nstruct spi_transfer, transfer_list);\r\n} else if (list_is_last(&xfer->transfer_list, &msg->transfers)) {\r\nxfer = NULL;\r\n} else {\r\nxfer = list_next_entry(xfer, transfer_list);\r\n}\r\n*_xfer = xfer;\r\n}\r\nstatic void spi_engine_tx_next(struct spi_engine *spi_engine)\r\n{\r\nstruct spi_transfer *xfer = spi_engine->tx_xfer;\r\ndo {\r\nspi_engine_xfer_next(spi_engine, &xfer);\r\n} while (xfer && !xfer->tx_buf);\r\nspi_engine->tx_xfer = xfer;\r\nif (xfer) {\r\nspi_engine->tx_length = xfer->len;\r\nspi_engine->tx_buf = xfer->tx_buf;\r\n} else {\r\nspi_engine->tx_buf = NULL;\r\n}\r\n}\r\nstatic void spi_engine_rx_next(struct spi_engine *spi_engine)\r\n{\r\nstruct spi_transfer *xfer = spi_engine->rx_xfer;\r\ndo {\r\nspi_engine_xfer_next(spi_engine, &xfer);\r\n} while (xfer && !xfer->rx_buf);\r\nspi_engine->rx_xfer = xfer;\r\nif (xfer) {\r\nspi_engine->rx_length = xfer->len;\r\nspi_engine->rx_buf = xfer->rx_buf;\r\n} else {\r\nspi_engine->rx_buf = NULL;\r\n}\r\n}\r\nstatic bool spi_engine_write_cmd_fifo(struct spi_engine *spi_engine)\r\n{\r\nvoid __iomem *addr = spi_engine->base + SPI_ENGINE_REG_CMD_FIFO;\r\nunsigned int n, m, i;\r\nconst uint16_t *buf;\r\nn = readl_relaxed(spi_engine->base + SPI_ENGINE_REG_CMD_FIFO_ROOM);\r\nwhile (n && spi_engine->cmd_length) {\r\nm = min(n, spi_engine->cmd_length);\r\nbuf = spi_engine->cmd_buf;\r\nfor (i = 0; i < m; i++)\r\nwritel_relaxed(buf[i], addr);\r\nspi_engine->cmd_buf += m;\r\nspi_engine->cmd_length -= m;\r\nn -= m;\r\n}\r\nreturn spi_engine->cmd_length != 0;\r\n}\r\nstatic bool spi_engine_write_tx_fifo(struct spi_engine *spi_engine)\r\n{\r\nvoid __iomem *addr = spi_engine->base + SPI_ENGINE_REG_SDO_DATA_FIFO;\r\nunsigned int n, m, i;\r\nconst uint8_t *buf;\r\nn = readl_relaxed(spi_engine->base + SPI_ENGINE_REG_SDO_FIFO_ROOM);\r\nwhile (n && spi_engine->tx_length) {\r\nm = min(n, spi_engine->tx_length);\r\nbuf = spi_engine->tx_buf;\r\nfor (i = 0; i < m; i++)\r\nwritel_relaxed(buf[i], addr);\r\nspi_engine->tx_buf += m;\r\nspi_engine->tx_length -= m;\r\nn -= m;\r\nif (spi_engine->tx_length == 0)\r\nspi_engine_tx_next(spi_engine);\r\n}\r\nreturn spi_engine->tx_length != 0;\r\n}\r\nstatic bool spi_engine_read_rx_fifo(struct spi_engine *spi_engine)\r\n{\r\nvoid __iomem *addr = spi_engine->base + SPI_ENGINE_REG_SDI_DATA_FIFO;\r\nunsigned int n, m, i;\r\nuint8_t *buf;\r\nn = readl_relaxed(spi_engine->base + SPI_ENGINE_REG_SDI_FIFO_LEVEL);\r\nwhile (n && spi_engine->rx_length) {\r\nm = min(n, spi_engine->rx_length);\r\nbuf = spi_engine->rx_buf;\r\nfor (i = 0; i < m; i++)\r\nbuf[i] = readl_relaxed(addr);\r\nspi_engine->rx_buf += m;\r\nspi_engine->rx_length -= m;\r\nn -= m;\r\nif (spi_engine->rx_length == 0)\r\nspi_engine_rx_next(spi_engine);\r\n}\r\nreturn spi_engine->rx_length != 0;\r\n}\r\nstatic irqreturn_t spi_engine_irq(int irq, void *devid)\r\n{\r\nstruct spi_master *master = devid;\r\nstruct spi_engine *spi_engine = spi_master_get_devdata(master);\r\nunsigned int disable_int = 0;\r\nunsigned int pending;\r\npending = readl_relaxed(spi_engine->base + SPI_ENGINE_REG_INT_PENDING);\r\nif (pending & SPI_ENGINE_INT_SYNC) {\r\nwritel_relaxed(SPI_ENGINE_INT_SYNC,\r\nspi_engine->base + SPI_ENGINE_REG_INT_PENDING);\r\nspi_engine->completed_id = readl_relaxed(\r\nspi_engine->base + SPI_ENGINE_REG_SYNC_ID);\r\n}\r\nspin_lock(&spi_engine->lock);\r\nif (pending & SPI_ENGINE_INT_CMD_ALMOST_EMPTY) {\r\nif (!spi_engine_write_cmd_fifo(spi_engine))\r\ndisable_int |= SPI_ENGINE_INT_CMD_ALMOST_EMPTY;\r\n}\r\nif (pending & SPI_ENGINE_INT_SDO_ALMOST_EMPTY) {\r\nif (!spi_engine_write_tx_fifo(spi_engine))\r\ndisable_int |= SPI_ENGINE_INT_SDO_ALMOST_EMPTY;\r\n}\r\nif (pending & (SPI_ENGINE_INT_SDI_ALMOST_FULL | SPI_ENGINE_INT_SYNC)) {\r\nif (!spi_engine_read_rx_fifo(spi_engine))\r\ndisable_int |= SPI_ENGINE_INT_SDI_ALMOST_FULL;\r\n}\r\nif (pending & SPI_ENGINE_INT_SYNC) {\r\nif (spi_engine->msg &&\r\nspi_engine->completed_id == spi_engine->sync_id) {\r\nstruct spi_message *msg = spi_engine->msg;\r\nkfree(spi_engine->p);\r\nmsg->status = 0;\r\nmsg->actual_length = msg->frame_length;\r\nspi_engine->msg = NULL;\r\nspi_finalize_current_message(master);\r\ndisable_int |= SPI_ENGINE_INT_SYNC;\r\n}\r\n}\r\nif (disable_int) {\r\nspi_engine->int_enable &= ~disable_int;\r\nwritel_relaxed(spi_engine->int_enable,\r\nspi_engine->base + SPI_ENGINE_REG_INT_ENABLE);\r\n}\r\nspin_unlock(&spi_engine->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int spi_engine_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct spi_engine_program p_dry, *p;\r\nstruct spi_engine *spi_engine = spi_master_get_devdata(master);\r\nunsigned int int_enable = 0;\r\nunsigned long flags;\r\nsize_t size;\r\np_dry.length = 0;\r\nspi_engine_compile_message(spi_engine, msg, true, &p_dry);\r\nsize = sizeof(*p->instructions) * (p_dry.length + 1);\r\np = kzalloc(sizeof(*p) + size, GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nspi_engine_compile_message(spi_engine, msg, false, p);\r\nspin_lock_irqsave(&spi_engine->lock, flags);\r\nspi_engine->sync_id = (spi_engine->sync_id + 1) & 0xff;\r\nspi_engine_program_add_cmd(p, false,\r\nSPI_ENGINE_CMD_SYNC(spi_engine->sync_id));\r\nspi_engine->msg = msg;\r\nspi_engine->p = p;\r\nspi_engine->cmd_buf = p->instructions;\r\nspi_engine->cmd_length = p->length;\r\nif (spi_engine_write_cmd_fifo(spi_engine))\r\nint_enable |= SPI_ENGINE_INT_CMD_ALMOST_EMPTY;\r\nspi_engine_tx_next(spi_engine);\r\nif (spi_engine_write_tx_fifo(spi_engine))\r\nint_enable |= SPI_ENGINE_INT_SDO_ALMOST_EMPTY;\r\nspi_engine_rx_next(spi_engine);\r\nif (spi_engine->rx_length != 0)\r\nint_enable |= SPI_ENGINE_INT_SDI_ALMOST_FULL;\r\nint_enable |= SPI_ENGINE_INT_SYNC;\r\nwritel_relaxed(int_enable,\r\nspi_engine->base + SPI_ENGINE_REG_INT_ENABLE);\r\nspi_engine->int_enable = int_enable;\r\nspin_unlock_irqrestore(&spi_engine->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int spi_engine_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_engine *spi_engine;\r\nstruct spi_master *master;\r\nunsigned int version;\r\nstruct resource *res;\r\nint irq;\r\nint ret;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn -ENXIO;\r\nspi_engine = devm_kzalloc(&pdev->dev, sizeof(*spi_engine), GFP_KERNEL);\r\nif (!spi_engine)\r\nreturn -ENOMEM;\r\nmaster = spi_alloc_master(&pdev->dev, 0);\r\nif (!master)\r\nreturn -ENOMEM;\r\nspi_master_set_devdata(master, spi_engine);\r\nspin_lock_init(&spi_engine->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nspi_engine->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(spi_engine->base)) {\r\nret = PTR_ERR(spi_engine->base);\r\ngoto err_put_master;\r\n}\r\nversion = readl(spi_engine->base + SPI_ENGINE_REG_VERSION);\r\nif (SPI_ENGINE_VERSION_MAJOR(version) != 1) {\r\ndev_err(&pdev->dev, "Unsupported peripheral version %u.%u.%c\n",\r\nSPI_ENGINE_VERSION_MAJOR(version),\r\nSPI_ENGINE_VERSION_MINOR(version),\r\nSPI_ENGINE_VERSION_PATCH(version));\r\nreturn -ENODEV;\r\n}\r\nspi_engine->clk = devm_clk_get(&pdev->dev, "s_axi_aclk");\r\nif (IS_ERR(spi_engine->clk)) {\r\nret = PTR_ERR(spi_engine->clk);\r\ngoto err_put_master;\r\n}\r\nspi_engine->ref_clk = devm_clk_get(&pdev->dev, "spi_clk");\r\nif (IS_ERR(spi_engine->ref_clk)) {\r\nret = PTR_ERR(spi_engine->ref_clk);\r\ngoto err_put_master;\r\n}\r\nret = clk_prepare_enable(spi_engine->clk);\r\nif (ret)\r\ngoto err_put_master;\r\nret = clk_prepare_enable(spi_engine->ref_clk);\r\nif (ret)\r\ngoto err_clk_disable;\r\nwritel_relaxed(0x00, spi_engine->base + SPI_ENGINE_REG_RESET);\r\nwritel_relaxed(0xff, spi_engine->base + SPI_ENGINE_REG_INT_PENDING);\r\nwritel_relaxed(0x00, spi_engine->base + SPI_ENGINE_REG_INT_ENABLE);\r\nret = request_irq(irq, spi_engine_irq, 0, pdev->name, master);\r\nif (ret)\r\ngoto err_ref_clk_disable;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_3WIRE;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->max_speed_hz = clk_get_rate(spi_engine->ref_clk) / 2;\r\nmaster->transfer_one_message = spi_engine_transfer_one_message;\r\nmaster->num_chipselect = 8;\r\nret = spi_register_master(master);\r\nif (ret)\r\ngoto err_free_irq;\r\nplatform_set_drvdata(pdev, master);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(irq, master);\r\nerr_ref_clk_disable:\r\nclk_disable_unprepare(spi_engine->ref_clk);\r\nerr_clk_disable:\r\nclk_disable_unprepare(spi_engine->clk);\r\nerr_put_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int spi_engine_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct spi_engine *spi_engine = spi_master_get_devdata(master);\r\nint irq = platform_get_irq(pdev, 0);\r\nspi_unregister_master(master);\r\nfree_irq(irq, master);\r\nwritel_relaxed(0xff, spi_engine->base + SPI_ENGINE_REG_INT_PENDING);\r\nwritel_relaxed(0x00, spi_engine->base + SPI_ENGINE_REG_INT_ENABLE);\r\nwritel_relaxed(0x01, spi_engine->base + SPI_ENGINE_REG_RESET);\r\nclk_disable_unprepare(spi_engine->ref_clk);\r\nclk_disable_unprepare(spi_engine->clk);\r\nreturn 0;\r\n}
