static inline volatile unsigned long *\r\nmk_tig_addr(int offset)\r\n{\r\nreturn (volatile unsigned long *)(TITAN_TIG_SPACE + (offset << 6));\r\n}\r\nstatic inline u8\r\ntitan_read_tig(int offset, u8 value)\r\n{\r\nvolatile unsigned long *tig_addr = mk_tig_addr(offset);\r\nreturn (u8)(*tig_addr & 0xff);\r\n}\r\nstatic inline void\r\ntitan_write_tig(int offset, u8 value)\r\n{\r\nvolatile unsigned long *tig_addr = mk_tig_addr(offset);\r\n*tig_addr = (unsigned long)value;\r\n}\r\nstatic int\r\nmk_conf_addr(struct pci_bus *pbus, unsigned int device_fn, int where,\r\nunsigned long *pci_addr, unsigned char *type1)\r\n{\r\nstruct pci_controller *hose = pbus->sysdata;\r\nunsigned long addr;\r\nu8 bus = pbus->number;\r\nDBG_CFG(("mk_conf_addr(bus=%d ,device_fn=0x%x, where=0x%x, "\r\n"pci_addr=0x%p, type1=0x%p)\n",\r\nbus, device_fn, where, pci_addr, type1));\r\nif (!pbus->parent)\r\nbus = 0;\r\n*type1 = (bus != 0);\r\naddr = (bus << 16) | (device_fn << 8) | where;\r\naddr |= hose->config_space_base;\r\n*pci_addr = addr;\r\nDBG_CFG(("mk_conf_addr: returning pci_addr 0x%lx\n", addr));\r\nreturn 0;\r\n}\r\nstatic int\r\ntitan_read_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *value)\r\n{\r\nunsigned long addr;\r\nunsigned char type1;\r\nif (mk_conf_addr(bus, devfn, where, &addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\n*value = __kernel_ldbu(*(vucp)addr);\r\nbreak;\r\ncase 2:\r\n*value = __kernel_ldwu(*(vusp)addr);\r\nbreak;\r\ncase 4:\r\n*value = *(vuip)addr;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\ntitan_write_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 value)\r\n{\r\nunsigned long addr;\r\nunsigned char type1;\r\nif (mk_conf_addr(bus, devfn, where, &addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\n__kernel_stb(value, *(vucp)addr);\r\nmb();\r\n__kernel_ldbu(*(vucp)addr);\r\nbreak;\r\ncase 2:\r\n__kernel_stw(value, *(vusp)addr);\r\nmb();\r\n__kernel_ldwu(*(vusp)addr);\r\nbreak;\r\ncase 4:\r\n*(vuip)addr = value;\r\nmb();\r\n*(vuip)addr;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid\r\ntitan_pci_tbi(struct pci_controller *hose, dma_addr_t start, dma_addr_t end)\r\n{\r\ntitan_pachip *pachip =\r\n(hose->index & 1) ? TITAN_pachip1 : TITAN_pachip0;\r\ntitan_pachip_port *port;\r\nvolatile unsigned long *csr;\r\nunsigned long value;\r\nport = &pachip->g_port;\r\nif (hose->index & 2)\r\nport = &pachip->a_port;\r\ncsr = &port->port_specific.g.gtlbia.csr;\r\nif (((start ^ end) & 0xffff0000) == 0)\r\ncsr = &port->port_specific.g.gtlbiv.csr;\r\nvalue = (start & 0xffff0000) >> 12;\r\nwmb();\r\n*csr = value;\r\nmb();\r\n*csr;\r\n}\r\nstatic int\r\ntitan_query_agp(titan_pachip_port *port)\r\n{\r\nunion TPAchipPCTL pctl;\r\npctl.pctl_q_whole = port->pctl.csr;\r\nreturn pctl.pctl_r_bits.apctl_v_agp_present;\r\n}\r\nstatic void __init\r\ntitan_init_one_pachip_port(titan_pachip_port *port, int index)\r\n{\r\nstruct pci_controller *hose;\r\nhose = alloc_pci_controller();\r\nif (index == 0)\r\npci_isa_hose = hose;\r\nhose->io_space = alloc_resource();\r\nhose->mem_space = alloc_resource();\r\nhose->sparse_mem_base = 0;\r\nhose->sparse_io_base = 0;\r\nhose->dense_mem_base\r\n= (TITAN_MEM(index) & 0xffffffffffUL) | 0x80000000000UL;\r\nhose->dense_io_base\r\n= (TITAN_IO(index) & 0xffffffffffUL) | 0x80000000000UL;\r\nhose->config_space_base = TITAN_CONF(index);\r\nhose->index = index;\r\nhose->io_space->start = TITAN_IO(index) - TITAN_IO_BIAS;\r\nhose->io_space->end = hose->io_space->start + TITAN_IO_SPACE - 1;\r\nhose->io_space->name = pci_io_names[index];\r\nhose->io_space->flags = IORESOURCE_IO;\r\nhose->mem_space->start = TITAN_MEM(index) - TITAN_MEM_BIAS;\r\nhose->mem_space->end = hose->mem_space->start + 0xffffffff;\r\nhose->mem_space->name = pci_mem_names[index];\r\nhose->mem_space->flags = IORESOURCE_MEM;\r\nif (request_resource(&ioport_resource, hose->io_space) < 0)\r\nprintk(KERN_ERR "Failed to request IO on hose %d\n", index);\r\nif (request_resource(&iomem_resource, hose->mem_space) < 0)\r\nprintk(KERN_ERR "Failed to request MEM on hose %d\n", index);\r\nsaved_config[index].wsba[0] = port->wsba[0].csr;\r\nsaved_config[index].wsm[0] = port->wsm[0].csr;\r\nsaved_config[index].tba[0] = port->tba[0].csr;\r\nsaved_config[index].wsba[1] = port->wsba[1].csr;\r\nsaved_config[index].wsm[1] = port->wsm[1].csr;\r\nsaved_config[index].tba[1] = port->tba[1].csr;\r\nsaved_config[index].wsba[2] = port->wsba[2].csr;\r\nsaved_config[index].wsm[2] = port->wsm[2].csr;\r\nsaved_config[index].tba[2] = port->tba[2].csr;\r\nsaved_config[index].wsba[3] = port->wsba[3].csr;\r\nsaved_config[index].wsm[3] = port->wsm[3].csr;\r\nsaved_config[index].tba[3] = port->tba[3].csr;\r\nhose->sg_isa = iommu_arena_new(hose, 0x00800000, 0x00800000, 0);\r\nhose->sg_isa->align_entry = 8;\r\nhose->sg_pci = iommu_arena_new(hose, 0xc0000000, 0x40000000, 0);\r\nhose->sg_pci->align_entry = 4;\r\nport->wsba[0].csr = hose->sg_isa->dma_base | 3;\r\nport->wsm[0].csr = (hose->sg_isa->size - 1) & 0xfff00000;\r\nport->tba[0].csr = virt_to_phys(hose->sg_isa->ptes);\r\nport->wsba[1].csr = __direct_map_base | 1;\r\nport->wsm[1].csr = (__direct_map_size - 1) & 0xfff00000;\r\nport->tba[1].csr = 0;\r\nport->wsba[2].csr = hose->sg_pci->dma_base | 3;\r\nport->wsm[2].csr = (hose->sg_pci->size - 1) & 0xfff00000;\r\nport->tba[2].csr = virt_to_phys(hose->sg_pci->ptes);\r\nport->wsba[3].csr = 0;\r\nport->pctl.csr |= pctl_m_mwin;\r\nif (titan_query_agp(port))\r\nport->port_specific.a.agplastwr.csr = __direct_map_base;\r\ntitan_pci_tbi(hose, 0, -1);\r\n}\r\nstatic void __init\r\ntitan_init_pachips(titan_pachip *pachip0, titan_pachip *pachip1)\r\n{\r\ntitan_pchip1_present = TITAN_cchip->csc.csr & 1L<<14;\r\ntitan_init_one_pachip_port(&pachip0->g_port, 0);\r\nif (titan_pchip1_present)\r\ntitan_init_one_pachip_port(&pachip1->g_port, 1);\r\ntitan_init_one_pachip_port(&pachip0->a_port, 2);\r\nif (titan_pchip1_present)\r\ntitan_init_one_pachip_port(&pachip1->a_port, 3);\r\n}\r\nvoid __init\r\ntitan_init_arch(void)\r\n{\r\n#if 0\r\nprintk("%s: titan_init_arch()\n", __func__);\r\nprintk("%s: CChip registers:\n", __func__);\r\nprintk("%s: CSR_CSC 0x%lx\n", __func__, TITAN_cchip->csc.csr);\r\nprintk("%s: CSR_MTR 0x%lx\n", __func__, TITAN_cchip->mtr.csr);\r\nprintk("%s: CSR_MISC 0x%lx\n", __func__, TITAN_cchip->misc.csr);\r\nprintk("%s: CSR_DIM0 0x%lx\n", __func__, TITAN_cchip->dim0.csr);\r\nprintk("%s: CSR_DIM1 0x%lx\n", __func__, TITAN_cchip->dim1.csr);\r\nprintk("%s: CSR_DIR0 0x%lx\n", __func__, TITAN_cchip->dir0.csr);\r\nprintk("%s: CSR_DIR1 0x%lx\n", __func__, TITAN_cchip->dir1.csr);\r\nprintk("%s: CSR_DRIR 0x%lx\n", __func__, TITAN_cchip->drir.csr);\r\nprintk("%s: DChip registers:\n", __func__);\r\nprintk("%s: CSR_DSC 0x%lx\n", __func__, TITAN_dchip->dsc.csr);\r\nprintk("%s: CSR_STR 0x%lx\n", __func__, TITAN_dchip->str.csr);\r\nprintk("%s: CSR_DREV 0x%lx\n", __func__, TITAN_dchip->drev.csr);\r\n#endif\r\nboot_cpuid = __hard_smp_processor_id();\r\nioport_resource.end = ~0UL;\r\niomem_resource.end = ~0UL;\r\n__direct_map_base = 0x80000000;\r\n__direct_map_size = 0x40000000;\r\ntitan_init_pachips(TITAN_pachip0, TITAN_pachip1);\r\nfind_console_vga_hose();\r\n}\r\nstatic void\r\ntitan_kill_one_pachip_port(titan_pachip_port *port, int index)\r\n{\r\nport->wsba[0].csr = saved_config[index].wsba[0];\r\nport->wsm[0].csr = saved_config[index].wsm[0];\r\nport->tba[0].csr = saved_config[index].tba[0];\r\nport->wsba[1].csr = saved_config[index].wsba[1];\r\nport->wsm[1].csr = saved_config[index].wsm[1];\r\nport->tba[1].csr = saved_config[index].tba[1];\r\nport->wsba[2].csr = saved_config[index].wsba[2];\r\nport->wsm[2].csr = saved_config[index].wsm[2];\r\nport->tba[2].csr = saved_config[index].tba[2];\r\nport->wsba[3].csr = saved_config[index].wsba[3];\r\nport->wsm[3].csr = saved_config[index].wsm[3];\r\nport->tba[3].csr = saved_config[index].tba[3];\r\n}\r\nstatic void\r\ntitan_kill_pachips(titan_pachip *pachip0, titan_pachip *pachip1)\r\n{\r\nif (titan_pchip1_present) {\r\ntitan_kill_one_pachip_port(&pachip1->g_port, 1);\r\ntitan_kill_one_pachip_port(&pachip1->a_port, 3);\r\n}\r\ntitan_kill_one_pachip_port(&pachip0->g_port, 0);\r\ntitan_kill_one_pachip_port(&pachip0->a_port, 2);\r\n}\r\nvoid\r\ntitan_kill_arch(int mode)\r\n{\r\ntitan_kill_pachips(TITAN_pachip0, TITAN_pachip1);\r\n}\r\nvoid __iomem *\r\ntitan_ioportmap(unsigned long addr)\r\n{\r\nFIXUP_IOADDR_VGA(addr);\r\nreturn (void __iomem *)(addr + TITAN_IO_BIAS);\r\n}\r\nvoid __iomem *\r\ntitan_ioremap(unsigned long addr, unsigned long size)\r\n{\r\nint h = (addr & TITAN_HOSE_MASK) >> TITAN_HOSE_SHIFT;\r\nunsigned long baddr = addr & ~TITAN_HOSE_MASK;\r\nunsigned long last = baddr + size - 1;\r\nstruct pci_controller *hose;\r\nstruct vm_struct *area;\r\nunsigned long vaddr;\r\nunsigned long *ptes;\r\nunsigned long pfn;\r\nif (pci_vga_hose && __is_mem_vga(addr)) {\r\nh = pci_vga_hose->index;\r\naddr += pci_vga_hose->mem_space->start;\r\n}\r\nfor (hose = hose_head; hose; hose = hose->next)\r\nif (hose->index == h)\r\nbreak;\r\nif (!hose)\r\nreturn NULL;\r\nif ((baddr >= __direct_map_base) &&\r\n((baddr + size - 1) < __direct_map_base + __direct_map_size)) {\r\nvaddr = addr - __direct_map_base + TITAN_MEM_BIAS;\r\nreturn (void __iomem *) vaddr;\r\n}\r\nif (hose->sg_pci &&\r\nbaddr >= (unsigned long)hose->sg_pci->dma_base &&\r\nlast < (unsigned long)hose->sg_pci->dma_base + hose->sg_pci->size){\r\nbaddr -= hose->sg_pci->dma_base;\r\nlast -= hose->sg_pci->dma_base;\r\nbaddr &= PAGE_MASK;\r\nsize = PAGE_ALIGN(last) - baddr;\r\narea = get_vm_area(size, VM_IOREMAP);\r\nif (!area) {\r\nprintk("ioremap failed... no vm_area...\n");\r\nreturn NULL;\r\n}\r\nptes = hose->sg_pci->ptes;\r\nfor (vaddr = (unsigned long)area->addr;\r\nbaddr <= last;\r\nbaddr += PAGE_SIZE, vaddr += PAGE_SIZE) {\r\npfn = ptes[baddr >> PAGE_SHIFT];\r\nif (!(pfn & 1)) {\r\nprintk("ioremap failed... pte not valid...\n");\r\nvfree(area->addr);\r\nreturn NULL;\r\n}\r\npfn >>= 1;\r\nif (__alpha_remap_area_pages(vaddr,\r\npfn << PAGE_SHIFT,\r\nPAGE_SIZE, 0)) {\r\nprintk("FAILED to remap_area_pages...\n");\r\nvfree(area->addr);\r\nreturn NULL;\r\n}\r\n}\r\nflush_tlb_all();\r\nvaddr = (unsigned long)area->addr + (addr & ~PAGE_MASK);\r\nreturn (void __iomem *) vaddr;\r\n}\r\nreturn (void __iomem *)(addr + TITAN_MEM_BIAS);\r\n}\r\nvoid\r\ntitan_iounmap(volatile void __iomem *xaddr)\r\n{\r\nunsigned long addr = (unsigned long) xaddr;\r\nif (addr >= VMALLOC_START)\r\nvfree((void *)(PAGE_MASK & addr));\r\n}\r\nint\r\ntitan_is_mmio(const volatile void __iomem *xaddr)\r\n{\r\nunsigned long addr = (unsigned long) xaddr;\r\nif (addr >= VMALLOC_START)\r\nreturn 1;\r\nelse\r\nreturn (addr & 0x100000000UL) == 0;\r\n}\r\nstatic int\r\ntitan_agp_setup(alpha_agp_info *agp)\r\n{\r\nstruct titan_agp_aperture *aper;\r\nif (!alpha_agpgart_size)\r\nreturn -ENOMEM;\r\naper = kmalloc(sizeof(struct titan_agp_aperture), GFP_KERNEL);\r\nif (aper == NULL)\r\nreturn -ENOMEM;\r\naper->arena = agp->hose->sg_pci;\r\naper->pg_count = alpha_agpgart_size / PAGE_SIZE;\r\naper->pg_start = iommu_reserve(aper->arena, aper->pg_count,\r\naper->pg_count - 1);\r\nif (aper->pg_start < 0) {\r\nprintk(KERN_ERR "Failed to reserve AGP memory\n");\r\nkfree(aper);\r\nreturn -ENOMEM;\r\n}\r\nagp->aperture.bus_base =\r\naper->arena->dma_base + aper->pg_start * PAGE_SIZE;\r\nagp->aperture.size = aper->pg_count * PAGE_SIZE;\r\nagp->aperture.sysdata = aper;\r\nreturn 0;\r\n}\r\nstatic void\r\ntitan_agp_cleanup(alpha_agp_info *agp)\r\n{\r\nstruct titan_agp_aperture *aper = agp->aperture.sysdata;\r\nint status;\r\nstatus = iommu_release(aper->arena, aper->pg_start, aper->pg_count);\r\nif (status == -EBUSY) {\r\nprintk(KERN_WARNING\r\n"Attempted to release bound AGP memory - unbinding\n");\r\niommu_unbind(aper->arena, aper->pg_start, aper->pg_count);\r\nstatus = iommu_release(aper->arena, aper->pg_start,\r\naper->pg_count);\r\n}\r\nif (status < 0)\r\nprintk(KERN_ERR "Failed to release AGP memory\n");\r\nkfree(aper);\r\nkfree(agp);\r\n}\r\nstatic int\r\ntitan_agp_configure(alpha_agp_info *agp)\r\n{\r\nunion TPAchipPCTL pctl;\r\ntitan_pachip_port *port = agp->private;\r\npctl.pctl_q_whole = port->pctl.csr;\r\npctl.pctl_r_bits.apctl_v_agp_sba_en = agp->mode.bits.sba;\r\npctl.pctl_r_bits.apctl_v_agp_rate = 0;\r\nif (agp->mode.bits.rate & 2)\r\npctl.pctl_r_bits.apctl_v_agp_rate = 1;\r\n#if 0\r\nif (agp->mode.bits.rate & 4)\r\npctl.pctl_r_bits.apctl_v_agp_rate = 2;\r\n#endif\r\npctl.pctl_r_bits.apctl_v_agp_hp_rd = 2;\r\npctl.pctl_r_bits.apctl_v_agp_lp_rd = 7;\r\npctl.pctl_r_bits.apctl_v_agp_en = agp->mode.bits.enable;\r\nprintk("Enabling AGP: %dX%s\n",\r\n1 << pctl.pctl_r_bits.apctl_v_agp_rate,\r\npctl.pctl_r_bits.apctl_v_agp_sba_en ? " - SBA" : "");\r\nport->pctl.csr = pctl.pctl_q_whole;\r\nudelay(100);\r\nreturn 0;\r\n}\r\nstatic int\r\ntitan_agp_bind_memory(alpha_agp_info *agp, off_t pg_start, struct agp_memory *mem)\r\n{\r\nstruct titan_agp_aperture *aper = agp->aperture.sysdata;\r\nreturn iommu_bind(aper->arena, aper->pg_start + pg_start,\r\nmem->page_count, mem->pages);\r\n}\r\nstatic int\r\ntitan_agp_unbind_memory(alpha_agp_info *agp, off_t pg_start, struct agp_memory *mem)\r\n{\r\nstruct titan_agp_aperture *aper = agp->aperture.sysdata;\r\nreturn iommu_unbind(aper->arena, aper->pg_start + pg_start,\r\nmem->page_count);\r\n}\r\nstatic unsigned long\r\ntitan_agp_translate(alpha_agp_info *agp, dma_addr_t addr)\r\n{\r\nstruct titan_agp_aperture *aper = agp->aperture.sysdata;\r\nunsigned long baddr = addr - aper->arena->dma_base;\r\nunsigned long pte;\r\nif (addr < agp->aperture.bus_base ||\r\naddr >= agp->aperture.bus_base + agp->aperture.size) {\r\nprintk("%s: addr out of range\n", __func__);\r\nreturn -EINVAL;\r\n}\r\npte = aper->arena->ptes[baddr >> PAGE_SHIFT];\r\nif (!(pte & 1)) {\r\nprintk("%s: pte not valid\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn (pte >> 1) << PAGE_SHIFT;\r\n}\r\nalpha_agp_info *\r\ntitan_agp_info(void)\r\n{\r\nalpha_agp_info *agp;\r\nstruct pci_controller *hose;\r\ntitan_pachip_port *port;\r\nint hosenum = -1;\r\nunion TPAchipPCTL pctl;\r\nport = &TITAN_pachip0->a_port;\r\nif (titan_query_agp(port))\r\nhosenum = 2;\r\nif (hosenum < 0 &&\r\ntitan_pchip1_present &&\r\ntitan_query_agp(port = &TITAN_pachip1->a_port))\r\nhosenum = 3;\r\nfor (hose = hose_head; hose; hose = hose->next)\r\nif (hose->index == hosenum)\r\nbreak;\r\nif (!hose || !hose->sg_pci)\r\nreturn NULL;\r\nagp = kmalloc(sizeof(*agp), GFP_KERNEL);\r\nif (!agp)\r\nreturn NULL;\r\nagp->hose = hose;\r\nagp->private = port;\r\nagp->ops = &titan_agp_ops;\r\nagp->aperture.bus_base = 0;\r\nagp->aperture.size = 0;\r\nagp->aperture.sysdata = NULL;\r\nagp->capability.lw = 0;\r\nagp->capability.bits.rate = 3;\r\nagp->capability.bits.sba = 1;\r\nagp->capability.bits.rq = 7;\r\npctl.pctl_q_whole = port->pctl.csr;\r\nagp->mode.lw = 0;\r\nagp->mode.bits.rate = 1 << pctl.pctl_r_bits.apctl_v_agp_rate;\r\nagp->mode.bits.sba = pctl.pctl_r_bits.apctl_v_agp_sba_en;\r\nagp->mode.bits.rq = 7;\r\nagp->mode.bits.enable = pctl.pctl_r_bits.apctl_v_agp_en;\r\nreturn agp;\r\n}
