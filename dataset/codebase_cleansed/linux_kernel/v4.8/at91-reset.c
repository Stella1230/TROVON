static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,\r\nvoid *cmd)\r\n{\r\nasm volatile(\r\n".balign 32\n\t"\r\n"str %2, [%0, #" __stringify(AT91_SDRAMC_TR) "]\n\t"\r\n"str %3, [%0, #" __stringify(AT91_SDRAMC_LPR) "]\n\t"\r\n"str %4, [%1, #" __stringify(AT91_RSTC_CR) "]\n\t"\r\n"b .\n\t"\r\n:\r\n: "r" (at91_ramc_base[0]),\r\n"r" (at91_rstc_base),\r\n"r" (1),\r\n"r" cpu_to_le32(AT91_SDRAMC_LPCB_POWER_DOWN),\r\n"r" cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST));\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,\r\nvoid *cmd)\r\n{\r\nasm volatile(\r\n"cmp %1, #0\n\t"\r\n"beq 1f\n\t"\r\n"ldr r0, [%1]\n\t"\r\n"cmp r0, #0\n\t"\r\n".balign 32\n\t"\r\n"1: str %3, [%0, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"\r\n" str %4, [%0, #" __stringify(AT91_DDRSDRC_LPR) "]\n\t"\r\n" strne %3, [%1, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"\r\n" strne %4, [%1, #" __stringify(AT91_DDRSDRC_LPR) "]\n\t"\r\n" str %5, [%2, #" __stringify(AT91_RSTC_CR) "]\n\t"\r\n" b .\n\t"\r\n:\r\n: "r" (at91_ramc_base[0]),\r\n"r" (at91_ramc_base[1]),\r\n"r" (at91_rstc_base),\r\n"r" (1),\r\n"r" cpu_to_le32(AT91_DDRSDRC_LPCB_POWER_DOWN),\r\n"r" cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST)\r\n: "r0");\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int sama5d3_restart(struct notifier_block *this, unsigned long mode,\r\nvoid *cmd)\r\n{\r\nwritel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST),\r\nat91_rstc_base);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void __init at91_reset_status(struct platform_device *pdev)\r\n{\r\nu32 reg = readl(at91_rstc_base + AT91_RSTC_SR);\r\nchar *reason;\r\nswitch ((reg & AT91_RSTC_RSTTYP) >> 8) {\r\ncase RESET_TYPE_GENERAL:\r\nreason = "general reset";\r\nbreak;\r\ncase RESET_TYPE_WAKEUP:\r\nreason = "wakeup";\r\nbreak;\r\ncase RESET_TYPE_WATCHDOG:\r\nreason = "watchdog reset";\r\nbreak;\r\ncase RESET_TYPE_SOFTWARE:\r\nreason = "software reset";\r\nbreak;\r\ncase RESET_TYPE_USER:\r\nreason = "user reset";\r\nbreak;\r\ndefault:\r\nreason = "unknown reset";\r\nbreak;\r\n}\r\npr_info("AT91: Starting after %s\n", reason);\r\n}\r\nstatic int __init at91_reset_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device_node *np;\r\nint ret, idx = 0;\r\nat91_rstc_base = of_iomap(pdev->dev.of_node, 0);\r\nif (!at91_rstc_base) {\r\ndev_err(&pdev->dev, "Could not map reset controller address\n");\r\nreturn -ENODEV;\r\n}\r\nif (!of_device_is_compatible(pdev->dev.of_node, "atmel,sama5d3-rstc")) {\r\nfor_each_matching_node(np, at91_ramc_of_match) {\r\nat91_ramc_base[idx] = of_iomap(np, 0);\r\nif (!at91_ramc_base[idx]) {\r\ndev_err(&pdev->dev, "Could not map ram controller address\n");\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\nidx++;\r\n}\r\n}\r\nmatch = of_match_node(at91_reset_of_match, pdev->dev.of_node);\r\nat91_restart_nb.notifier_call = match->data;\r\nsclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(sclk))\r\nreturn PTR_ERR(sclk);\r\nret = clk_prepare_enable(sclk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not enable slow clock\n");\r\nreturn ret;\r\n}\r\nret = register_restart_handler(&at91_restart_nb);\r\nif (ret) {\r\nclk_disable_unprepare(sclk);\r\nreturn ret;\r\n}\r\nat91_reset_status(pdev);\r\nreturn 0;\r\n}\r\nstatic int __exit at91_reset_remove(struct platform_device *pdev)\r\n{\r\nunregister_restart_handler(&at91_restart_nb);\r\nclk_disable_unprepare(sclk);\r\nreturn 0;\r\n}
