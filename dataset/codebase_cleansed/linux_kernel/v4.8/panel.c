static void lcd_get_bits(unsigned int port, int *val)\r\n{\r\nunsigned int bit, state;\r\nfor (bit = 0; bit < LCD_BITS; bit++) {\r\nstate = test_bit(bit, bits) ? BIT_SET : BIT_CLR;\r\n*val &= lcd_bits[port][bit][BIT_MSK];\r\n*val |= lcd_bits[port][bit][state];\r\n}\r\n}\r\nstatic int set_data_bits(void)\r\n{\r\nint val;\r\nval = r_dtr(pprt);\r\nlcd_get_bits(LCD_PORT_D, &val);\r\nw_dtr(pprt, val);\r\nreturn val;\r\n}\r\nstatic int set_ctrl_bits(void)\r\n{\r\nint val;\r\nval = r_ctr(pprt);\r\nlcd_get_bits(LCD_PORT_C, &val);\r\nw_ctr(pprt, val);\r\nreturn val;\r\n}\r\nstatic void panel_set_bits(void)\r\n{\r\nset_data_bits();\r\nset_ctrl_bits();\r\n}\r\nstatic void pin_to_bits(int pin, unsigned char *d_val, unsigned char *c_val)\r\n{\r\nint d_bit, c_bit, inv;\r\nd_val[0] = 0;\r\nc_val[0] = 0;\r\nd_val[1] = 0;\r\nc_val[1] = 0;\r\nd_val[2] = 0xFF;\r\nc_val[2] = 0xFF;\r\nif (pin == 0)\r\nreturn;\r\ninv = (pin < 0);\r\nif (inv)\r\npin = -pin;\r\nd_bit = 0;\r\nc_bit = 0;\r\nswitch (pin) {\r\ncase PIN_STROBE:\r\nc_bit = PNL_PSTROBE;\r\ninv = !inv;\r\nbreak;\r\ncase PIN_D0...PIN_D7:\r\nd_bit = 1 << (pin - 2);\r\nbreak;\r\ncase PIN_AUTOLF:\r\nc_bit = PNL_PAUTOLF;\r\ninv = !inv;\r\nbreak;\r\ncase PIN_INITP:\r\nc_bit = PNL_PINITP;\r\nbreak;\r\ncase PIN_SELECP:\r\nc_bit = PNL_PSELECP;\r\ninv = !inv;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (c_bit) {\r\nc_val[2] &= ~c_bit;\r\nc_val[!inv] = c_bit;\r\n} else if (d_bit) {\r\nd_val[2] &= ~d_bit;\r\nd_val[!inv] = d_bit;\r\n}\r\n}\r\nstatic void long_sleep(int ms)\r\n{\r\nif (in_interrupt())\r\nmdelay(ms);\r\nelse\r\nschedule_timeout_interruptible(msecs_to_jiffies(ms));\r\n}\r\nstatic void lcd_send_serial(int byte)\r\n{\r\nint bit;\r\nfor (bit = 0; bit < 8; bit++) {\r\nclear_bit(LCD_BIT_CL, bits);\r\npanel_set_bits();\r\nif (byte & 1) {\r\nset_bit(LCD_BIT_DA, bits);\r\n} else {\r\nclear_bit(LCD_BIT_DA, bits);\r\n}\r\npanel_set_bits();\r\nudelay(2);\r\nset_bit(LCD_BIT_CL, bits);\r\npanel_set_bits();\r\nudelay(1);\r\nbyte >>= 1;\r\n}\r\n}\r\nstatic void lcd_backlight(int on)\r\n{\r\nif (lcd.pins.bl == PIN_NONE)\r\nreturn;\r\nspin_lock_irq(&pprt_lock);\r\nif (on)\r\nset_bit(LCD_BIT_BL, bits);\r\nelse\r\nclear_bit(LCD_BIT_BL, bits);\r\npanel_set_bits();\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_cmd_s(int cmd)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nlcd_send_serial(0x1F);\r\nlcd_send_serial(cmd & 0x0F);\r\nlcd_send_serial((cmd >> 4) & 0x0F);\r\nudelay(40);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_data_s(int data)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nlcd_send_serial(0x5F);\r\nlcd_send_serial(data & 0x0F);\r\nlcd_send_serial((data >> 4) & 0x0F);\r\nudelay(40);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_cmd_p8(int cmd)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nw_dtr(pprt, cmd);\r\nudelay(20);\r\nset_bit(LCD_BIT_E, bits);\r\nclear_bit(LCD_BIT_RS, bits);\r\nclear_bit(LCD_BIT_RW, bits);\r\nset_ctrl_bits();\r\nudelay(40);\r\nclear_bit(LCD_BIT_E, bits);\r\nset_ctrl_bits();\r\nudelay(120);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_data_p8(int data)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nw_dtr(pprt, data);\r\nudelay(20);\r\nset_bit(LCD_BIT_E, bits);\r\nset_bit(LCD_BIT_RS, bits);\r\nclear_bit(LCD_BIT_RW, bits);\r\nset_ctrl_bits();\r\nudelay(40);\r\nclear_bit(LCD_BIT_E, bits);\r\nset_ctrl_bits();\r\nudelay(45);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_cmd_tilcd(int cmd)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nw_ctr(pprt, cmd);\r\nudelay(60);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_data_tilcd(int data)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nw_dtr(pprt, data);\r\nudelay(60);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_gotoxy(void)\r\n{\r\nlcd_write_cmd(LCD_CMD_SET_DDRAM_ADDR\r\n| (lcd.addr.y ? lcd.hwidth : 0)\r\n| ((lcd.addr.x < lcd.bwidth) ? lcd.addr.x &\r\n(lcd.hwidth - 1) : lcd.bwidth - 1));\r\n}\r\nstatic void lcd_print(char c)\r\n{\r\nif (lcd.addr.x < lcd.bwidth) {\r\nif (lcd_char_conv)\r\nc = lcd_char_conv[(unsigned char)c];\r\nlcd_write_data(c);\r\nlcd.addr.x++;\r\n}\r\nif (lcd.addr.x == lcd.bwidth)\r\nlcd_gotoxy();\r\n}\r\nstatic void lcd_clear_fast_s(void)\r\n{\r\nint pos;\r\nlcd.addr.x = 0;\r\nlcd.addr.y = 0;\r\nlcd_gotoxy();\r\nspin_lock_irq(&pprt_lock);\r\nfor (pos = 0; pos < lcd.height * lcd.hwidth; pos++) {\r\nlcd_send_serial(0x5F);\r\nlcd_send_serial(' ' & 0x0F);\r\nlcd_send_serial((' ' >> 4) & 0x0F);\r\nudelay(40);\r\n}\r\nspin_unlock_irq(&pprt_lock);\r\nlcd.addr.x = 0;\r\nlcd.addr.y = 0;\r\nlcd_gotoxy();\r\n}\r\nstatic void lcd_clear_fast_p8(void)\r\n{\r\nint pos;\r\nlcd.addr.x = 0;\r\nlcd.addr.y = 0;\r\nlcd_gotoxy();\r\nspin_lock_irq(&pprt_lock);\r\nfor (pos = 0; pos < lcd.height * lcd.hwidth; pos++) {\r\nw_dtr(pprt, ' ');\r\nudelay(20);\r\nset_bit(LCD_BIT_E, bits);\r\nset_bit(LCD_BIT_RS, bits);\r\nclear_bit(LCD_BIT_RW, bits);\r\nset_ctrl_bits();\r\nudelay(40);\r\nclear_bit(LCD_BIT_E, bits);\r\nset_ctrl_bits();\r\nudelay(45);\r\n}\r\nspin_unlock_irq(&pprt_lock);\r\nlcd.addr.x = 0;\r\nlcd.addr.y = 0;\r\nlcd_gotoxy();\r\n}\r\nstatic void lcd_clear_fast_tilcd(void)\r\n{\r\nint pos;\r\nlcd.addr.x = 0;\r\nlcd.addr.y = 0;\r\nlcd_gotoxy();\r\nspin_lock_irq(&pprt_lock);\r\nfor (pos = 0; pos < lcd.height * lcd.hwidth; pos++) {\r\nw_dtr(pprt, ' ');\r\nudelay(60);\r\n}\r\nspin_unlock_irq(&pprt_lock);\r\nlcd.addr.x = 0;\r\nlcd.addr.y = 0;\r\nlcd_gotoxy();\r\n}\r\nstatic void lcd_clear_display(void)\r\n{\r\nlcd_write_cmd(LCD_CMD_DISPLAY_CLEAR);\r\nlcd.addr.x = 0;\r\nlcd.addr.y = 0;\r\nlong_sleep(15);\r\n}\r\nstatic void lcd_init_display(void)\r\n{\r\nlcd.flags = ((lcd.height > 1) ? LCD_FLAG_N : 0)\r\n| LCD_FLAG_D | LCD_FLAG_C | LCD_FLAG_B;\r\nlong_sleep(20);\r\nlcd_write_cmd(LCD_CMD_FUNCTION_SET | LCD_CMD_DATA_LEN_8BITS);\r\nlong_sleep(10);\r\nlcd_write_cmd(LCD_CMD_FUNCTION_SET | LCD_CMD_DATA_LEN_8BITS);\r\nlong_sleep(10);\r\nlcd_write_cmd(LCD_CMD_FUNCTION_SET | LCD_CMD_DATA_LEN_8BITS);\r\nlong_sleep(10);\r\nlcd_write_cmd(LCD_CMD_FUNCTION_SET | LCD_CMD_DATA_LEN_8BITS\r\n| ((lcd.flags & LCD_FLAG_F) ? LCD_CMD_FONT_5X10_DOTS : 0)\r\n| ((lcd.flags & LCD_FLAG_N) ? LCD_CMD_TWO_LINES : 0)\r\n);\r\nlong_sleep(10);\r\nlcd_write_cmd(LCD_CMD_DISPLAY_CTRL);\r\nlong_sleep(10);\r\nlcd_write_cmd(LCD_CMD_DISPLAY_CTRL\r\n| ((lcd.flags & LCD_FLAG_D) ? LCD_CMD_DISPLAY_ON : 0)\r\n| ((lcd.flags & LCD_FLAG_C) ? LCD_CMD_CURSOR_ON : 0)\r\n| ((lcd.flags & LCD_FLAG_B) ? LCD_CMD_BLINK_ON : 0)\r\n);\r\nlcd_backlight((lcd.flags & LCD_FLAG_L) ? 1 : 0);\r\nlong_sleep(10);\r\nlcd_write_cmd(LCD_CMD_ENTRY_MODE | LCD_CMD_CURSOR_INC);\r\nlcd_clear_display();\r\n}\r\nstatic inline int handle_lcd_special_code(void)\r\n{\r\nint processed = 0;\r\nchar *esc = lcd.esc_seq.buf + 2;\r\nint oldflags = lcd.flags;\r\nswitch (*esc) {\r\ncase 'D':\r\nlcd.flags |= LCD_FLAG_D;\r\nprocessed = 1;\r\nbreak;\r\ncase 'd':\r\nlcd.flags &= ~LCD_FLAG_D;\r\nprocessed = 1;\r\nbreak;\r\ncase 'C':\r\nlcd.flags |= LCD_FLAG_C;\r\nprocessed = 1;\r\nbreak;\r\ncase 'c':\r\nlcd.flags &= ~LCD_FLAG_C;\r\nprocessed = 1;\r\nbreak;\r\ncase 'B':\r\nlcd.flags |= LCD_FLAG_B;\r\nprocessed = 1;\r\nbreak;\r\ncase 'b':\r\nlcd.flags &= ~LCD_FLAG_B;\r\nprocessed = 1;\r\nbreak;\r\ncase '+':\r\nlcd.flags |= LCD_FLAG_L;\r\nprocessed = 1;\r\nbreak;\r\ncase '-':\r\nlcd.flags &= ~LCD_FLAG_L;\r\nprocessed = 1;\r\nbreak;\r\ncase '*':\r\nif (scan_timer.function) {\r\nif (lcd.light_tempo == 0 &&\r\n((lcd.flags & LCD_FLAG_L) == 0))\r\nlcd_backlight(1);\r\nlcd.light_tempo = FLASH_LIGHT_TEMPO;\r\n}\r\nprocessed = 1;\r\nbreak;\r\ncase 'f':\r\nlcd.flags &= ~LCD_FLAG_F;\r\nprocessed = 1;\r\nbreak;\r\ncase 'F':\r\nlcd.flags |= LCD_FLAG_F;\r\nprocessed = 1;\r\nbreak;\r\ncase 'n':\r\nlcd.flags &= ~LCD_FLAG_N;\r\nprocessed = 1;\r\nbreak;\r\ncase 'N':\r\nlcd.flags |= LCD_FLAG_N;\r\nbreak;\r\ncase 'l':\r\nif (lcd.addr.x > 0) {\r\nif (lcd.addr.x < lcd.bwidth)\r\nlcd_write_cmd(LCD_CMD_SHIFT);\r\nlcd.addr.x--;\r\n}\r\nprocessed = 1;\r\nbreak;\r\ncase 'r':\r\nif (lcd.addr.x < lcd.width) {\r\nif (lcd.addr.x < (lcd.bwidth - 1))\r\nlcd_write_cmd(LCD_CMD_SHIFT |\r\nLCD_CMD_SHIFT_RIGHT);\r\nlcd.addr.x++;\r\n}\r\nprocessed = 1;\r\nbreak;\r\ncase 'L':\r\nlcd_write_cmd(LCD_CMD_SHIFT | LCD_CMD_DISPLAY_SHIFT);\r\nprocessed = 1;\r\nbreak;\r\ncase 'R':\r\nlcd_write_cmd(LCD_CMD_SHIFT | LCD_CMD_DISPLAY_SHIFT |\r\nLCD_CMD_SHIFT_RIGHT);\r\nprocessed = 1;\r\nbreak;\r\ncase 'k': {\r\nint x;\r\nfor (x = lcd.addr.x; x < lcd.bwidth; x++)\r\nlcd_write_data(' ');\r\nlcd_gotoxy();\r\nprocessed = 1;\r\nbreak;\r\n}\r\ncase 'I':\r\nlcd_init_display();\r\nprocessed = 1;\r\nbreak;\r\ncase 'G': {\r\nunsigned char cgbytes[8];\r\nunsigned char cgaddr;\r\nint cgoffset;\r\nint shift;\r\nchar value;\r\nint addr;\r\nif (!strchr(esc, ';'))\r\nbreak;\r\nesc++;\r\ncgaddr = *(esc++) - '0';\r\nif (cgaddr > 7) {\r\nprocessed = 1;\r\nbreak;\r\n}\r\ncgoffset = 0;\r\nshift = 0;\r\nvalue = 0;\r\nwhile (*esc && cgoffset < 8) {\r\nshift ^= 4;\r\nif (*esc >= '0' && *esc <= '9') {\r\nvalue |= (*esc - '0') << shift;\r\n} else if (*esc >= 'A' && *esc <= 'Z') {\r\nvalue |= (*esc - 'A' + 10) << shift;\r\n} else if (*esc >= 'a' && *esc <= 'z') {\r\nvalue |= (*esc - 'a' + 10) << shift;\r\n} else {\r\nesc++;\r\ncontinue;\r\n}\r\nif (shift == 0) {\r\ncgbytes[cgoffset++] = value;\r\nvalue = 0;\r\n}\r\nesc++;\r\n}\r\nlcd_write_cmd(LCD_CMD_SET_CGRAM_ADDR | (cgaddr * 8));\r\nfor (addr = 0; addr < cgoffset; addr++)\r\nlcd_write_data(cgbytes[addr]);\r\nlcd_gotoxy();\r\nprocessed = 1;\r\nbreak;\r\n}\r\ncase 'x':\r\ncase 'y':\r\nif (!strchr(esc, ';'))\r\nbreak;\r\nwhile (*esc) {\r\nif (*esc == 'x') {\r\nesc++;\r\nif (kstrtoul(esc, 10, &lcd.addr.x) < 0)\r\nbreak;\r\n} else if (*esc == 'y') {\r\nesc++;\r\nif (kstrtoul(esc, 10, &lcd.addr.y) < 0)\r\nbreak;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nlcd_gotoxy();\r\nprocessed = 1;\r\nbreak;\r\n}\r\nif (oldflags != lcd.flags) {\r\nif ((oldflags ^ lcd.flags) &\r\n(LCD_FLAG_B | LCD_FLAG_C | LCD_FLAG_D))\r\nlcd_write_cmd(LCD_CMD_DISPLAY_CTRL\r\n| ((lcd.flags & LCD_FLAG_D)\r\n? LCD_CMD_DISPLAY_ON : 0)\r\n| ((lcd.flags & LCD_FLAG_C)\r\n? LCD_CMD_CURSOR_ON : 0)\r\n| ((lcd.flags & LCD_FLAG_B)\r\n? LCD_CMD_BLINK_ON : 0));\r\nelse if ((oldflags ^ lcd.flags) & (LCD_FLAG_F | LCD_FLAG_N))\r\nlcd_write_cmd(LCD_CMD_FUNCTION_SET\r\n| LCD_CMD_DATA_LEN_8BITS\r\n| ((lcd.flags & LCD_FLAG_F)\r\n? LCD_CMD_TWO_LINES : 0)\r\n| ((lcd.flags & LCD_FLAG_N)\r\n? LCD_CMD_FONT_5X10_DOTS\r\n: 0));\r\nelse if ((oldflags ^ lcd.flags) & (LCD_FLAG_L)) {\r\nif (lcd.flags & (LCD_FLAG_L))\r\nlcd_backlight(1);\r\nelse if (lcd.light_tempo == 0)\r\nlcd_backlight(0);\r\n}\r\n}\r\nreturn processed;\r\n}\r\nstatic void lcd_write_char(char c)\r\n{\r\nif ((c != '\n') && lcd.esc_seq.len >= 0) {\r\nlcd.esc_seq.buf[lcd.esc_seq.len++] = c;\r\nlcd.esc_seq.buf[lcd.esc_seq.len] = 0;\r\n} else {\r\nlcd.esc_seq.len = -1;\r\nswitch (c) {\r\ncase LCD_ESCAPE_CHAR:\r\nlcd.esc_seq.len = 0;\r\nlcd.esc_seq.buf[lcd.esc_seq.len] = 0;\r\nbreak;\r\ncase '\b':\r\nif (lcd.addr.x > 0) {\r\nif (lcd.addr.x < lcd.bwidth)\r\nlcd_write_cmd(LCD_CMD_SHIFT);\r\nlcd.addr.x--;\r\n}\r\nlcd_write_data(' ');\r\nlcd_write_cmd(LCD_CMD_SHIFT);\r\nbreak;\r\ncase '\014':\r\nlcd_clear_fast();\r\nbreak;\r\ncase '\n':\r\nfor (; lcd.addr.x < lcd.bwidth; lcd.addr.x++)\r\nlcd_write_data(' ');\r\nlcd.addr.x = 0;\r\nlcd.addr.y = (lcd.addr.y + 1) % lcd.height;\r\nlcd_gotoxy();\r\nbreak;\r\ncase '\r':\r\nlcd.addr.x = 0;\r\nlcd_gotoxy();\r\nbreak;\r\ncase '\t':\r\nlcd_print(' ');\r\nbreak;\r\ndefault:\r\nlcd_print(c);\r\nbreak;\r\n}\r\n}\r\nif (lcd.esc_seq.len >= 2) {\r\nint processed = 0;\r\nif (!strcmp(lcd.esc_seq.buf, "[2J")) {\r\nlcd_clear_fast();\r\nprocessed = 1;\r\n} else if (!strcmp(lcd.esc_seq.buf, "[H")) {\r\nlcd.addr.x = 0;\r\nlcd.addr.y = 0;\r\nlcd_gotoxy();\r\nprocessed = 1;\r\n}\r\nelse if ((lcd.esc_seq.len >= 3) &&\r\n(lcd.esc_seq.buf[0] == '[') &&\r\n(lcd.esc_seq.buf[1] == 'L')) {\r\nprocessed = handle_lcd_special_code();\r\n}\r\nif (processed || (lcd.esc_seq.len >= LCD_ESCAPE_LEN))\r\nlcd.esc_seq.len = -1;\r\n}\r\n}\r\nstatic ssize_t lcd_write(struct file *file,\r\nconst char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nconst char __user *tmp = buf;\r\nchar c;\r\nfor (; count-- > 0; (*ppos)++, tmp++) {\r\nif (!in_interrupt() && (((count + 1) & 0x1f) == 0))\r\nschedule();\r\nif (get_user(c, tmp))\r\nreturn -EFAULT;\r\nlcd_write_char(c);\r\n}\r\nreturn tmp - buf;\r\n}\r\nstatic int lcd_open(struct inode *inode, struct file *file)\r\n{\r\nif (!atomic_dec_and_test(&lcd_available))\r\nreturn -EBUSY;\r\nif (file->f_mode & FMODE_READ)\r\nreturn -EPERM;\r\nif (lcd.must_clear) {\r\nlcd_clear_display();\r\nlcd.must_clear = false;\r\n}\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int lcd_release(struct inode *inode, struct file *file)\r\n{\r\natomic_inc(&lcd_available);\r\nreturn 0;\r\n}\r\nstatic void panel_lcd_print(const char *s)\r\n{\r\nconst char *tmp = s;\r\nint count = strlen(s);\r\nif (lcd.enabled && lcd.initialized) {\r\nfor (; count-- > 0; tmp++) {\r\nif (!in_interrupt() && (((count + 1) & 0x1f) == 0))\r\nschedule();\r\nlcd_write_char(*tmp);\r\n}\r\n}\r\n}\r\nstatic void lcd_init(void)\r\n{\r\nswitch (selected_lcd_type) {\r\ncase LCD_TYPE_OLD:\r\nlcd.proto = LCD_PROTO_PARALLEL;\r\nlcd.charset = LCD_CHARSET_NORMAL;\r\nlcd.pins.e = PIN_STROBE;\r\nlcd.pins.rs = PIN_AUTOLF;\r\nlcd.width = 40;\r\nlcd.bwidth = 40;\r\nlcd.hwidth = 64;\r\nlcd.height = 2;\r\nbreak;\r\ncase LCD_TYPE_KS0074:\r\nlcd.proto = LCD_PROTO_SERIAL;\r\nlcd.charset = LCD_CHARSET_KS0074;\r\nlcd.pins.bl = PIN_AUTOLF;\r\nlcd.pins.cl = PIN_STROBE;\r\nlcd.pins.da = PIN_D0;\r\nlcd.width = 16;\r\nlcd.bwidth = 40;\r\nlcd.hwidth = 16;\r\nlcd.height = 2;\r\nbreak;\r\ncase LCD_TYPE_NEXCOM:\r\nlcd.proto = LCD_PROTO_PARALLEL;\r\nlcd.charset = LCD_CHARSET_NORMAL;\r\nlcd.pins.e = PIN_AUTOLF;\r\nlcd.pins.rs = PIN_SELECP;\r\nlcd.pins.rw = PIN_INITP;\r\nlcd.width = 16;\r\nlcd.bwidth = 40;\r\nlcd.hwidth = 64;\r\nlcd.height = 2;\r\nbreak;\r\ncase LCD_TYPE_CUSTOM:\r\nlcd.proto = DEFAULT_LCD_PROTO;\r\nlcd.charset = DEFAULT_LCD_CHARSET;\r\nbreak;\r\ncase LCD_TYPE_HANTRONIX:\r\ndefault:\r\nlcd.proto = LCD_PROTO_PARALLEL;\r\nlcd.charset = LCD_CHARSET_NORMAL;\r\nlcd.pins.e = PIN_STROBE;\r\nlcd.pins.rs = PIN_SELECP;\r\nlcd.width = 16;\r\nlcd.bwidth = 40;\r\nlcd.hwidth = 64;\r\nlcd.height = 2;\r\nbreak;\r\n}\r\nif (lcd_height != NOT_SET)\r\nlcd.height = lcd_height;\r\nif (lcd_width != NOT_SET)\r\nlcd.width = lcd_width;\r\nif (lcd_bwidth != NOT_SET)\r\nlcd.bwidth = lcd_bwidth;\r\nif (lcd_hwidth != NOT_SET)\r\nlcd.hwidth = lcd_hwidth;\r\nif (lcd_charset != NOT_SET)\r\nlcd.charset = lcd_charset;\r\nif (lcd_proto != NOT_SET)\r\nlcd.proto = lcd_proto;\r\nif (lcd_e_pin != PIN_NOT_SET)\r\nlcd.pins.e = lcd_e_pin;\r\nif (lcd_rs_pin != PIN_NOT_SET)\r\nlcd.pins.rs = lcd_rs_pin;\r\nif (lcd_rw_pin != PIN_NOT_SET)\r\nlcd.pins.rw = lcd_rw_pin;\r\nif (lcd_cl_pin != PIN_NOT_SET)\r\nlcd.pins.cl = lcd_cl_pin;\r\nif (lcd_da_pin != PIN_NOT_SET)\r\nlcd.pins.da = lcd_da_pin;\r\nif (lcd_bl_pin != PIN_NOT_SET)\r\nlcd.pins.bl = lcd_bl_pin;\r\nif (lcd.width <= 0)\r\nlcd.width = DEFAULT_LCD_WIDTH;\r\nif (lcd.bwidth <= 0)\r\nlcd.bwidth = DEFAULT_LCD_BWIDTH;\r\nif (lcd.hwidth <= 0)\r\nlcd.hwidth = DEFAULT_LCD_HWIDTH;\r\nif (lcd.height <= 0)\r\nlcd.height = DEFAULT_LCD_HEIGHT;\r\nif (lcd.proto == LCD_PROTO_SERIAL) {\r\nlcd_write_cmd = lcd_write_cmd_s;\r\nlcd_write_data = lcd_write_data_s;\r\nlcd_clear_fast = lcd_clear_fast_s;\r\nif (lcd.pins.cl == PIN_NOT_SET)\r\nlcd.pins.cl = DEFAULT_LCD_PIN_SCL;\r\nif (lcd.pins.da == PIN_NOT_SET)\r\nlcd.pins.da = DEFAULT_LCD_PIN_SDA;\r\n} else if (lcd.proto == LCD_PROTO_PARALLEL) {\r\nlcd_write_cmd = lcd_write_cmd_p8;\r\nlcd_write_data = lcd_write_data_p8;\r\nlcd_clear_fast = lcd_clear_fast_p8;\r\nif (lcd.pins.e == PIN_NOT_SET)\r\nlcd.pins.e = DEFAULT_LCD_PIN_E;\r\nif (lcd.pins.rs == PIN_NOT_SET)\r\nlcd.pins.rs = DEFAULT_LCD_PIN_RS;\r\nif (lcd.pins.rw == PIN_NOT_SET)\r\nlcd.pins.rw = DEFAULT_LCD_PIN_RW;\r\n} else {\r\nlcd_write_cmd = lcd_write_cmd_tilcd;\r\nlcd_write_data = lcd_write_data_tilcd;\r\nlcd_clear_fast = lcd_clear_fast_tilcd;\r\n}\r\nif (lcd.pins.bl == PIN_NOT_SET)\r\nlcd.pins.bl = DEFAULT_LCD_PIN_BL;\r\nif (lcd.pins.e == PIN_NOT_SET)\r\nlcd.pins.e = PIN_NONE;\r\nif (lcd.pins.rs == PIN_NOT_SET)\r\nlcd.pins.rs = PIN_NONE;\r\nif (lcd.pins.rw == PIN_NOT_SET)\r\nlcd.pins.rw = PIN_NONE;\r\nif (lcd.pins.bl == PIN_NOT_SET)\r\nlcd.pins.bl = PIN_NONE;\r\nif (lcd.pins.cl == PIN_NOT_SET)\r\nlcd.pins.cl = PIN_NONE;\r\nif (lcd.pins.da == PIN_NOT_SET)\r\nlcd.pins.da = PIN_NONE;\r\nif (lcd.charset == NOT_SET)\r\nlcd.charset = DEFAULT_LCD_CHARSET;\r\nif (lcd.charset == LCD_CHARSET_KS0074)\r\nlcd_char_conv = lcd_char_conv_ks0074;\r\nelse\r\nlcd_char_conv = NULL;\r\nif (lcd.pins.bl != PIN_NONE)\r\ninit_scan_timer();\r\npin_to_bits(lcd.pins.e, lcd_bits[LCD_PORT_D][LCD_BIT_E],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_E]);\r\npin_to_bits(lcd.pins.rs, lcd_bits[LCD_PORT_D][LCD_BIT_RS],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_RS]);\r\npin_to_bits(lcd.pins.rw, lcd_bits[LCD_PORT_D][LCD_BIT_RW],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_RW]);\r\npin_to_bits(lcd.pins.bl, lcd_bits[LCD_PORT_D][LCD_BIT_BL],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_BL]);\r\npin_to_bits(lcd.pins.cl, lcd_bits[LCD_PORT_D][LCD_BIT_CL],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_CL]);\r\npin_to_bits(lcd.pins.da, lcd_bits[LCD_PORT_D][LCD_BIT_DA],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_DA]);\r\nlcd.initialized = true;\r\nlcd_init_display();\r\n#ifdef CONFIG_PANEL_CHANGE_MESSAGE\r\n#ifdef CONFIG_PANEL_BOOT_MESSAGE\r\npanel_lcd_print("\x1b[Lc\x1b[Lb\x1b[L*" CONFIG_PANEL_BOOT_MESSAGE);\r\n#endif\r\n#else\r\npanel_lcd_print("\x1b[Lc\x1b[Lb\x1b[L*Linux-" UTS_RELEASE "\nPanel-"\r\nPANEL_VERSION);\r\n#endif\r\nlcd.addr.x = 0;\r\nlcd.addr.y = 0;\r\nlcd.must_clear = true;\r\nlcd_gotoxy();\r\n}\r\nstatic ssize_t keypad_read(struct file *file,\r\nchar __user *buf, size_t count, loff_t *ppos)\r\n{\r\nunsigned i = *ppos;\r\nchar __user *tmp = buf;\r\nif (keypad_buflen == 0) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(keypad_read_wait,\r\nkeypad_buflen != 0))\r\nreturn -EINTR;\r\n}\r\nfor (; count-- > 0 && (keypad_buflen > 0);\r\n++i, ++tmp, --keypad_buflen) {\r\nput_user(keypad_buffer[keypad_start], tmp);\r\nkeypad_start = (keypad_start + 1) % KEYPAD_BUFFER;\r\n}\r\n*ppos = i;\r\nreturn tmp - buf;\r\n}\r\nstatic int keypad_open(struct inode *inode, struct file *file)\r\n{\r\nif (!atomic_dec_and_test(&keypad_available))\r\nreturn -EBUSY;\r\nif (file->f_mode & FMODE_WRITE)\r\nreturn -EPERM;\r\nkeypad_buflen = 0;\r\nreturn 0;\r\n}\r\nstatic int keypad_release(struct inode *inode, struct file *file)\r\n{\r\natomic_inc(&keypad_available);\r\nreturn 0;\r\n}\r\nstatic void keypad_send_key(const char *string, int max_len)\r\n{\r\nif (!atomic_read(&keypad_available)) {\r\nwhile (max_len-- && keypad_buflen < KEYPAD_BUFFER && *string) {\r\nkeypad_buffer[(keypad_start + keypad_buflen++) %\r\nKEYPAD_BUFFER] = *string++;\r\n}\r\nwake_up_interruptible(&keypad_read_wait);\r\n}\r\n}\r\nstatic void phys_scan_contacts(void)\r\n{\r\nint bit, bitval;\r\nchar oldval;\r\nchar bitmask;\r\nchar gndmask;\r\nphys_prev = phys_curr;\r\nphys_read_prev = phys_read;\r\nphys_read = 0;\r\noldval = r_dtr(pprt) | scan_mask_o;\r\nw_dtr(pprt, oldval & ~scan_mask_o);\r\nbitmask = PNL_PINPUT(r_str(pprt)) & scan_mask_i;\r\nw_dtr(pprt, oldval);\r\ngndmask = PNL_PINPUT(r_str(pprt)) & scan_mask_i;\r\nphys_read |= (__u64)gndmask << 40;\r\nif (bitmask != gndmask) {\r\nfor (bit = 0; bit < 8; bit++) {\r\nbitval = BIT(bit);\r\nif (!(scan_mask_o & bitval))\r\ncontinue;\r\nw_dtr(pprt, oldval & ~bitval);\r\nbitmask = PNL_PINPUT(r_str(pprt)) & ~gndmask;\r\nphys_read |= (__u64)bitmask << (5 * bit);\r\n}\r\nw_dtr(pprt, oldval);\r\n}\r\nphys_curr = (phys_prev & (phys_read ^ phys_read_prev)) |\r\n(phys_read & ~(phys_read ^ phys_read_prev));\r\n}\r\nstatic inline int input_state_high(struct logical_input *input)\r\n{\r\n#if 0\r\nif (((phys_prev & input->mask) == input->value) &&\r\n((phys_curr & input->mask) > input->value)) {\r\ninput->state = INPUT_ST_LOW;\r\nreturn 1;\r\n}\r\n#endif\r\nif ((phys_curr & input->mask) == input->value) {\r\nif ((input->type == INPUT_TYPE_STD) &&\r\n(input->high_timer == 0)) {\r\ninput->high_timer++;\r\nif (input->u.std.press_fct)\r\ninput->u.std.press_fct(input->u.std.press_data);\r\n} else if (input->type == INPUT_TYPE_KBD) {\r\nkeypressed = 1;\r\nif (input->high_timer == 0) {\r\nchar *press_str = input->u.kbd.press_str;\r\nif (press_str[0]) {\r\nint s = sizeof(input->u.kbd.press_str);\r\nkeypad_send_key(press_str, s);\r\n}\r\n}\r\nif (input->u.kbd.repeat_str[0]) {\r\nchar *repeat_str = input->u.kbd.repeat_str;\r\nif (input->high_timer >= KEYPAD_REP_START) {\r\nint s = sizeof(input->u.kbd.repeat_str);\r\ninput->high_timer -= KEYPAD_REP_DELAY;\r\nkeypad_send_key(repeat_str, s);\r\n}\r\ninputs_stable = 0;\r\n}\r\nif (input->high_timer < 255)\r\ninput->high_timer++;\r\n}\r\nreturn 1;\r\n}\r\ninput->state = INPUT_ST_FALLING;\r\ninput->fall_timer = 0;\r\nreturn 0;\r\n}\r\nstatic inline void input_state_falling(struct logical_input *input)\r\n{\r\n#if 0\r\nif (((phys_prev & input->mask) == input->value) &&\r\n((phys_curr & input->mask) > input->value)) {\r\ninput->state = INPUT_ST_LOW;\r\nreturn;\r\n}\r\n#endif\r\nif ((phys_curr & input->mask) == input->value) {\r\nif (input->type == INPUT_TYPE_KBD) {\r\nkeypressed = 1;\r\nif (input->u.kbd.repeat_str[0]) {\r\nchar *repeat_str = input->u.kbd.repeat_str;\r\nif (input->high_timer >= KEYPAD_REP_START) {\r\nint s = sizeof(input->u.kbd.repeat_str);\r\ninput->high_timer -= KEYPAD_REP_DELAY;\r\nkeypad_send_key(repeat_str, s);\r\n}\r\ninputs_stable = 0;\r\n}\r\nif (input->high_timer < 255)\r\ninput->high_timer++;\r\n}\r\ninput->state = INPUT_ST_HIGH;\r\n} else if (input->fall_timer >= input->fall_time) {\r\nif (input->type == INPUT_TYPE_STD) {\r\nvoid (*release_fct)(int) = input->u.std.release_fct;\r\nif (release_fct)\r\nrelease_fct(input->u.std.release_data);\r\n} else if (input->type == INPUT_TYPE_KBD) {\r\nchar *release_str = input->u.kbd.release_str;\r\nif (release_str[0]) {\r\nint s = sizeof(input->u.kbd.release_str);\r\nkeypad_send_key(release_str, s);\r\n}\r\n}\r\ninput->state = INPUT_ST_LOW;\r\n} else {\r\ninput->fall_timer++;\r\ninputs_stable = 0;\r\n}\r\n}\r\nstatic void panel_process_inputs(void)\r\n{\r\nstruct list_head *item;\r\nstruct logical_input *input;\r\nkeypressed = 0;\r\ninputs_stable = 1;\r\nlist_for_each(item, &logical_inputs) {\r\ninput = list_entry(item, struct logical_input, list);\r\nswitch (input->state) {\r\ncase INPUT_ST_LOW:\r\nif ((phys_curr & input->mask) != input->value)\r\nbreak;\r\nif ((phys_prev & input->mask) == input->value)\r\nbreak;\r\ninput->rise_timer = 0;\r\ninput->state = INPUT_ST_RISING;\r\ncase INPUT_ST_RISING:\r\nif ((phys_curr & input->mask) != input->value) {\r\ninput->state = INPUT_ST_LOW;\r\nbreak;\r\n}\r\nif (input->rise_timer < input->rise_time) {\r\ninputs_stable = 0;\r\ninput->rise_timer++;\r\nbreak;\r\n}\r\ninput->high_timer = 0;\r\ninput->state = INPUT_ST_HIGH;\r\ncase INPUT_ST_HIGH:\r\nif (input_state_high(input))\r\nbreak;\r\ncase INPUT_ST_FALLING:\r\ninput_state_falling(input);\r\n}\r\n}\r\n}\r\nstatic void panel_scan_timer(void)\r\n{\r\nif (keypad.enabled && keypad_initialized) {\r\nif (spin_trylock_irq(&pprt_lock)) {\r\nphys_scan_contacts();\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nif (!inputs_stable || phys_curr != phys_prev)\r\npanel_process_inputs();\r\n}\r\nif (lcd.enabled && lcd.initialized) {\r\nif (keypressed) {\r\nif (lcd.light_tempo == 0 &&\r\n((lcd.flags & LCD_FLAG_L) == 0))\r\nlcd_backlight(1);\r\nlcd.light_tempo = FLASH_LIGHT_TEMPO;\r\n} else if (lcd.light_tempo > 0) {\r\nlcd.light_tempo--;\r\nif (lcd.light_tempo == 0 &&\r\n((lcd.flags & LCD_FLAG_L) == 0))\r\nlcd_backlight(0);\r\n}\r\n}\r\nmod_timer(&scan_timer, jiffies + INPUT_POLL_TIME);\r\n}\r\nstatic void init_scan_timer(void)\r\n{\r\nif (scan_timer.function)\r\nreturn;\r\nsetup_timer(&scan_timer, (void *)&panel_scan_timer, 0);\r\nscan_timer.expires = jiffies + INPUT_POLL_TIME;\r\nadd_timer(&scan_timer);\r\n}\r\nstatic u8 input_name2mask(const char *name, __u64 *mask, __u64 *value,\r\nu8 *imask, u8 *omask)\r\n{\r\nconst char sigtab[] = "EeSsPpAaBb";\r\nu8 im, om;\r\n__u64 m, v;\r\nom = 0;\r\nim = 0;\r\nm = 0ULL;\r\nv = 0ULL;\r\nwhile (*name) {\r\nint in, out, bit, neg;\r\nconst char *idx;\r\nidx = strchr(sigtab, *name);\r\nif (!idx)\r\nreturn 0;\r\nin = idx - sigtab;\r\nneg = (in & 1);\r\nin >>= 1;\r\nim |= BIT(in);\r\nname++;\r\nif (*name >= '0' && *name <= '7') {\r\nout = *name - '0';\r\nom |= BIT(out);\r\n} else if (*name == '-') {\r\nout = 8;\r\n} else {\r\nreturn 0;\r\n}\r\nbit = (out * 5) + in;\r\nm |= 1ULL << bit;\r\nif (!neg)\r\nv |= 1ULL << bit;\r\nname++;\r\n}\r\n*mask = m;\r\n*value = v;\r\nif (imask)\r\n*imask |= im;\r\nif (omask)\r\n*omask |= om;\r\nreturn 1;\r\n}\r\nstatic struct logical_input *panel_bind_key(const char *name, const char *press,\r\nconst char *repeat,\r\nconst char *release)\r\n{\r\nstruct logical_input *key;\r\nkey = kzalloc(sizeof(*key), GFP_KERNEL);\r\nif (!key)\r\nreturn NULL;\r\nif (!input_name2mask(name, &key->mask, &key->value, &scan_mask_i,\r\n&scan_mask_o)) {\r\nkfree(key);\r\nreturn NULL;\r\n}\r\nkey->type = INPUT_TYPE_KBD;\r\nkey->state = INPUT_ST_LOW;\r\nkey->rise_time = 1;\r\nkey->fall_time = 1;\r\nstrncpy(key->u.kbd.press_str, press, sizeof(key->u.kbd.press_str));\r\nstrncpy(key->u.kbd.repeat_str, repeat, sizeof(key->u.kbd.repeat_str));\r\nstrncpy(key->u.kbd.release_str, release,\r\nsizeof(key->u.kbd.release_str));\r\nlist_add(&key->list, &logical_inputs);\r\nreturn key;\r\n}\r\nstatic void keypad_init(void)\r\n{\r\nint keynum;\r\ninit_waitqueue_head(&keypad_read_wait);\r\nkeypad_buflen = 0;\r\nfor (keynum = 0; keypad_profile[keynum][0][0]; keynum++) {\r\npanel_bind_key(keypad_profile[keynum][0],\r\nkeypad_profile[keynum][1],\r\nkeypad_profile[keynum][2],\r\nkeypad_profile[keynum][3]);\r\n}\r\ninit_scan_timer();\r\nkeypad_initialized = 1;\r\n}\r\nstatic int panel_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (lcd.enabled && lcd.initialized) {\r\nswitch (code) {\r\ncase SYS_DOWN:\r\npanel_lcd_print\r\n("\x0cReloading\nSystem...\x1b[Lc\x1b[Lb\x1b[L+");\r\nbreak;\r\ncase SYS_HALT:\r\npanel_lcd_print\r\n("\x0cSystem Halted.\x1b[Lc\x1b[Lb\x1b[L+");\r\nbreak;\r\ncase SYS_POWER_OFF:\r\npanel_lcd_print("\x0cPower off.\x1b[Lc\x1b[Lb\x1b[L+");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void panel_attach(struct parport *port)\r\n{\r\nstruct pardev_cb panel_cb;\r\nif (port->number != parport)\r\nreturn;\r\nif (pprt) {\r\npr_err("%s: port->number=%d parport=%d, already registered!\n",\r\n__func__, port->number, parport);\r\nreturn;\r\n}\r\nmemset(&panel_cb, 0, sizeof(panel_cb));\r\npanel_cb.private = &pprt;\r\npprt = parport_register_dev_model(port, "panel", &panel_cb, 0);\r\nif (!pprt) {\r\npr_err("%s: port->number=%d parport=%d, parport_register_device() failed\n",\r\n__func__, port->number, parport);\r\nreturn;\r\n}\r\nif (parport_claim(pprt)) {\r\npr_err("could not claim access to parport%d. Aborting.\n",\r\nparport);\r\ngoto err_unreg_device;\r\n}\r\nif (lcd.enabled) {\r\nlcd_init();\r\nif (misc_register(&lcd_dev))\r\ngoto err_unreg_device;\r\n}\r\nif (keypad.enabled) {\r\nkeypad_init();\r\nif (misc_register(&keypad_dev))\r\ngoto err_lcd_unreg;\r\n}\r\nregister_reboot_notifier(&panel_notifier);\r\nreturn;\r\nerr_lcd_unreg:\r\nif (lcd.enabled)\r\nmisc_deregister(&lcd_dev);\r\nerr_unreg_device:\r\nparport_unregister_device(pprt);\r\npprt = NULL;\r\n}\r\nstatic void panel_detach(struct parport *port)\r\n{\r\nif (port->number != parport)\r\nreturn;\r\nif (!pprt) {\r\npr_err("%s: port->number=%d parport=%d, nothing to unregister.\n",\r\n__func__, port->number, parport);\r\nreturn;\r\n}\r\nif (scan_timer.function)\r\ndel_timer_sync(&scan_timer);\r\nif (pprt) {\r\nif (keypad.enabled) {\r\nmisc_deregister(&keypad_dev);\r\nkeypad_initialized = 0;\r\n}\r\nif (lcd.enabled) {\r\npanel_lcd_print("\x0cLCD driver " PANEL_VERSION\r\n"\nunloaded.\x1b[Lc\x1b[Lb\x1b[L-");\r\nmisc_deregister(&lcd_dev);\r\nlcd.initialized = false;\r\n}\r\nparport_release(pprt);\r\nparport_unregister_device(pprt);\r\npprt = NULL;\r\nunregister_reboot_notifier(&panel_notifier);\r\n}\r\n}\r\nstatic int __init panel_init_module(void)\r\n{\r\nint selected_keypad_type = NOT_SET, err;\r\nswitch (profile) {\r\ncase PANEL_PROFILE_CUSTOM:\r\nselected_keypad_type = DEFAULT_KEYPAD_TYPE;\r\nselected_lcd_type = DEFAULT_LCD_TYPE;\r\nbreak;\r\ncase PANEL_PROFILE_OLD:\r\nselected_keypad_type = KEYPAD_TYPE_OLD;\r\nselected_lcd_type = LCD_TYPE_OLD;\r\nif (lcd_width == NOT_SET)\r\nlcd_width = 16;\r\nif (lcd_hwidth == NOT_SET)\r\nlcd_hwidth = 16;\r\nbreak;\r\ncase PANEL_PROFILE_NEW:\r\nselected_keypad_type = KEYPAD_TYPE_NEW;\r\nselected_lcd_type = LCD_TYPE_KS0074;\r\nbreak;\r\ncase PANEL_PROFILE_HANTRONIX:\r\nselected_keypad_type = KEYPAD_TYPE_NONE;\r\nselected_lcd_type = LCD_TYPE_HANTRONIX;\r\nbreak;\r\ncase PANEL_PROFILE_NEXCOM:\r\nselected_keypad_type = KEYPAD_TYPE_NEXCOM;\r\nselected_lcd_type = LCD_TYPE_NEXCOM;\r\nbreak;\r\ncase PANEL_PROFILE_LARGE:\r\nselected_keypad_type = KEYPAD_TYPE_OLD;\r\nselected_lcd_type = LCD_TYPE_OLD;\r\nbreak;\r\n}\r\nif (keypad_enabled != NOT_SET)\r\nselected_keypad_type = keypad_enabled;\r\nif (keypad_type != NOT_SET)\r\nselected_keypad_type = keypad_type;\r\nkeypad.enabled = (selected_keypad_type > 0);\r\nif (lcd_enabled != NOT_SET)\r\nselected_lcd_type = lcd_enabled;\r\nif (lcd_type != NOT_SET)\r\nselected_lcd_type = lcd_type;\r\nlcd.enabled = (selected_lcd_type > 0);\r\nif (lcd.enabled) {\r\nlcd.height = lcd_height;\r\nlcd.width = lcd_width;\r\nlcd.bwidth = lcd_bwidth;\r\nlcd.hwidth = lcd_hwidth;\r\nlcd.charset = lcd_charset;\r\nlcd.proto = lcd_proto;\r\nlcd.pins.e = lcd_e_pin;\r\nlcd.pins.rs = lcd_rs_pin;\r\nlcd.pins.rw = lcd_rw_pin;\r\nlcd.pins.cl = lcd_cl_pin;\r\nlcd.pins.da = lcd_da_pin;\r\nlcd.pins.bl = lcd_bl_pin;\r\nlcd.esc_seq.len = -1;\r\n}\r\nswitch (selected_keypad_type) {\r\ncase KEYPAD_TYPE_OLD:\r\nkeypad_profile = old_keypad_profile;\r\nbreak;\r\ncase KEYPAD_TYPE_NEW:\r\nkeypad_profile = new_keypad_profile;\r\nbreak;\r\ncase KEYPAD_TYPE_NEXCOM:\r\nkeypad_profile = nexcom_keypad_profile;\r\nbreak;\r\ndefault:\r\nkeypad_profile = NULL;\r\nbreak;\r\n}\r\nif (!lcd.enabled && !keypad.enabled) {\r\npr_err("driver version " PANEL_VERSION " disabled.\n");\r\nreturn -ENODEV;\r\n}\r\nerr = parport_register_driver(&panel_driver);\r\nif (err) {\r\npr_err("could not register with parport. Aborting.\n");\r\nreturn err;\r\n}\r\nif (pprt)\r\npr_info("driver version " PANEL_VERSION\r\n" registered on parport%d (io=0x%lx).\n", parport,\r\npprt->port->base);\r\nelse\r\npr_info("driver version " PANEL_VERSION\r\n" not yet registered\n");\r\nreturn 0;\r\n}\r\nstatic void __exit panel_cleanup_module(void)\r\n{\r\nparport_unregister_driver(&panel_driver);\r\n}
