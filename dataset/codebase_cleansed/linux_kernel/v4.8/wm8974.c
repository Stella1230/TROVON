static void pll_factors(struct pll_ *pll_div,\r\nunsigned int target, unsigned int source)\r\n{\r\nunsigned long long Kpart;\r\nunsigned int K, Ndiv, Nmod;\r\ntarget *= 4;\r\nNdiv = target / source;\r\nif (Ndiv < 6) {\r\nsource /= 2;\r\npll_div->pre_div = 1;\r\nNdiv = target / source;\r\n} else\r\npll_div->pre_div = 0;\r\nif ((Ndiv < 6) || (Ndiv > 12))\r\nprintk(KERN_WARNING\r\n"WM8974 N value %u outwith recommended range!\n",\r\nNdiv);\r\npll_div->n = Ndiv;\r\nNmod = target % source;\r\nKpart = FIXED_PLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, source);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nK /= 10;\r\npll_div->k = K;\r\n}\r\nstatic int wm8974_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct pll_ pll_div;\r\nu16 reg;\r\nif (freq_in == 0 || freq_out == 0) {\r\nreg = snd_soc_read(codec, WM8974_CLOCK);\r\nsnd_soc_write(codec, WM8974_CLOCK, reg & 0x0ff);\r\nreg = snd_soc_read(codec, WM8974_POWER1);\r\nsnd_soc_write(codec, WM8974_POWER1, reg & 0x1df);\r\nreturn 0;\r\n}\r\npll_factors(&pll_div, freq_out, freq_in);\r\nsnd_soc_write(codec, WM8974_PLLN, (pll_div.pre_div << 4) | pll_div.n);\r\nsnd_soc_write(codec, WM8974_PLLK1, pll_div.k >> 18);\r\nsnd_soc_write(codec, WM8974_PLLK2, (pll_div.k >> 9) & 0x1ff);\r\nsnd_soc_write(codec, WM8974_PLLK3, pll_div.k & 0x1ff);\r\nreg = snd_soc_read(codec, WM8974_POWER1);\r\nsnd_soc_write(codec, WM8974_POWER1, reg | 0x020);\r\nreg = snd_soc_read(codec, WM8974_CLOCK);\r\nsnd_soc_write(codec, WM8974_CLOCK, reg | 0x100);\r\nreturn 0;\r\n}\r\nstatic int wm8974_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 reg;\r\nswitch (div_id) {\r\ncase WM8974_OPCLKDIV:\r\nreg = snd_soc_read(codec, WM8974_GPIO) & 0x1cf;\r\nsnd_soc_write(codec, WM8974_GPIO, reg | div);\r\nbreak;\r\ncase WM8974_MCLKDIV:\r\nreg = snd_soc_read(codec, WM8974_CLOCK) & 0x11f;\r\nsnd_soc_write(codec, WM8974_CLOCK, reg | div);\r\nbreak;\r\ncase WM8974_BCLKDIV:\r\nreg = snd_soc_read(codec, WM8974_CLOCK) & 0x1e3;\r\nsnd_soc_write(codec, WM8974_CLOCK, reg | div);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int wm8974_get_mclkdiv(unsigned int f_in, unsigned int f_out,\r\nint *mclkdiv)\r\n{\r\nunsigned int ratio = 2 * f_in / f_out;\r\nif (ratio <= 2) {\r\n*mclkdiv = WM8974_MCLKDIV_1;\r\nratio = 2;\r\n} else if (ratio == 3) {\r\n*mclkdiv = WM8974_MCLKDIV_1_5;\r\n} else if (ratio == 4) {\r\n*mclkdiv = WM8974_MCLKDIV_2;\r\n} else if (ratio <= 6) {\r\n*mclkdiv = WM8974_MCLKDIV_3;\r\nratio = 6;\r\n} else if (ratio <= 8) {\r\n*mclkdiv = WM8974_MCLKDIV_4;\r\nratio = 8;\r\n} else if (ratio <= 12) {\r\n*mclkdiv = WM8974_MCLKDIV_6;\r\nratio = 12;\r\n} else if (ratio <= 16) {\r\n*mclkdiv = WM8974_MCLKDIV_8;\r\nratio = 16;\r\n} else {\r\n*mclkdiv = WM8974_MCLKDIV_12;\r\nratio = 24;\r\n}\r\nreturn f_out * ratio / 2;\r\n}\r\nstatic int wm8974_update_clocks(struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8974_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int fs256;\r\nunsigned int fpll = 0;\r\nunsigned int f;\r\nint mclkdiv;\r\nif (!priv->mclk || !priv->fs)\r\nreturn 0;\r\nfs256 = 256 * priv->fs;\r\nf = wm8974_get_mclkdiv(priv->mclk, fs256, &mclkdiv);\r\nif (f != priv->mclk) {\r\nfpll = wm8974_get_mclkdiv(22500000, fs256, &mclkdiv);\r\n}\r\nwm8974_set_dai_pll(dai, 0, 0, priv->mclk, fpll);\r\nwm8974_set_dai_clkdiv(dai, WM8974_MCLKDIV, mclkdiv);\r\nreturn 0;\r\n}\r\nstatic int wm8974_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8974_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nif (dir != SND_SOC_CLOCK_IN)\r\nreturn -EINVAL;\r\npriv->mclk = freq;\r\nreturn wm8974_update_clocks(dai);\r\n}\r\nstatic int wm8974_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 iface = 0;\r\nu16 clk = snd_soc_read(codec, WM8974_CLOCK) & 0x1fe;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nclk |= 0x0001;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= 0x0010;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= 0x0008;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= 0x00018;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= 0x0180;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= 0x0100;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\niface |= 0x0080;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8974_IFACE, iface);\r\nsnd_soc_write(codec, WM8974_CLOCK, clk);\r\nreturn 0;\r\n}\r\nstatic int wm8974_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8974_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nu16 iface = snd_soc_read(codec, WM8974_IFACE) & 0x19f;\r\nu16 adn = snd_soc_read(codec, WM8974_ADD) & 0x1f1;\r\nint err;\r\npriv->fs = params_rate(params);\r\nerr = wm8974_update_clocks(dai);\r\nif (err)\r\nreturn err;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\niface |= 0x0020;\r\nbreak;\r\ncase 24:\r\niface |= 0x0040;\r\nbreak;\r\ncase 32:\r\niface |= 0x0060;\r\nbreak;\r\n}\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nadn |= 0x5 << 1;\r\nbreak;\r\ncase 11025:\r\nadn |= 0x4 << 1;\r\nbreak;\r\ncase 16000:\r\nadn |= 0x3 << 1;\r\nbreak;\r\ncase 22050:\r\nadn |= 0x2 << 1;\r\nbreak;\r\ncase 32000:\r\nadn |= 0x1 << 1;\r\nbreak;\r\ncase 44100:\r\ncase 48000:\r\nbreak;\r\n}\r\nsnd_soc_write(codec, WM8974_IFACE, iface);\r\nsnd_soc_write(codec, WM8974_ADD, adn);\r\nreturn 0;\r\n}\r\nstatic int wm8974_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 mute_reg = snd_soc_read(codec, WM8974_DAC) & 0xffbf;\r\nif (mute)\r\nsnd_soc_write(codec, WM8974_DAC, mute_reg | 0x40);\r\nelse\r\nsnd_soc_write(codec, WM8974_DAC, mute_reg);\r\nreturn 0;\r\n}\r\nstatic int wm8974_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 power1 = snd_soc_read(codec, WM8974_POWER1) & ~0x3;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\npower1 |= 0x1;\r\nsnd_soc_write(codec, WM8974_POWER1, power1);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\npower1 |= WM8974_POWER1_BIASEN | WM8974_POWER1_BUFIOEN;\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nregcache_sync(dev_get_regmap(codec->dev, NULL));\r\nsnd_soc_write(codec, WM8974_POWER1, power1 | 0x3);\r\nmdelay(100);\r\n}\r\npower1 |= 0x2;\r\nsnd_soc_write(codec, WM8974_POWER1, power1);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, WM8974_POWER1, 0);\r\nsnd_soc_write(codec, WM8974_POWER2, 0);\r\nsnd_soc_write(codec, WM8974_POWER3, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8974_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret = 0;\r\nret = wm8974_reset(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8974_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8974_priv *priv;\r\nstruct regmap *regmap;\r\nint ret;\r\npriv = devm_kzalloc(&i2c->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, priv);\r\nregmap = devm_regmap_init_i2c(i2c, &wm8974_regmap);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8974, &wm8974_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int wm8974_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
