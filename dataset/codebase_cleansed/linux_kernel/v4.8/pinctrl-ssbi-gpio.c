static int pm8xxx_read_bank(struct pm8xxx_gpio *pctrl,\r\nstruct pm8xxx_pin_data *pin, int bank)\r\n{\r\nunsigned int val = bank << 4;\r\nint ret;\r\nret = regmap_write(pctrl->regmap, pin->reg, val);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to select bank %d\n", bank);\r\nreturn ret;\r\n}\r\nret = regmap_read(pctrl->regmap, pin->reg, &val);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to read register %d\n", bank);\r\nreturn ret;\r\n}\r\nreturn val;\r\n}\r\nstatic int pm8xxx_write_bank(struct pm8xxx_gpio *pctrl,\r\nstruct pm8xxx_pin_data *pin,\r\nint bank,\r\nu8 val)\r\n{\r\nint ret;\r\nval |= PM8XXX_BANK_WRITE;\r\nval |= bank << 4;\r\nret = regmap_write(pctrl->regmap, pin->reg, val);\r\nif (ret)\r\ndev_err(pctrl->dev, "failed to write register\n");\r\nreturn ret;\r\n}\r\nstatic int pm8xxx_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->npins;\r\n}\r\nstatic const char *pm8xxx_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nreturn pm8xxx_groups[group];\r\n}\r\nstatic int pm8xxx_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = &pctrl->desc.pins[group].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(pm8xxx_gpio_functions);\r\n}\r\nstatic const char *pm8xxx_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nreturn pm8xxx_gpio_functions[function];\r\n}\r\nstatic int pm8xxx_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pm8xxx_groups;\r\n*num_groups = pctrl->npins;\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_pinmux_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nunsigned group)\r\n{\r\nstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[group].drv_data;\r\nu8 val;\r\npin->function = function;\r\nval = pin->function << 1;\r\npm8xxx_write_bank(pctrl, pin, 4, val);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_pin_config_get(struct pinctrl_dev *pctldev,\r\nunsigned int offset,\r\nunsigned long *config)\r\n{\r\nstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nunsigned param = pinconf_to_config_param(*config);\r\nunsigned arg;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\narg = pin->bias == PM8XXX_GPIO_BIAS_NP;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\narg = pin->bias == PM8XXX_GPIO_BIAS_PD;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\narg = pin->bias <= PM8XXX_GPIO_BIAS_PU_1P5_30;\r\nbreak;\r\ncase PM8XXX_QCOM_PULL_UP_STRENGTH:\r\narg = pin->pull_up_strength;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\narg = pin->disable;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\narg = pin->mode == PM8XXX_GPIO_MODE_INPUT;\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\nif (pin->mode & PM8XXX_GPIO_MODE_OUTPUT)\r\narg = pin->output_value;\r\nelse\r\narg = 0;\r\nbreak;\r\ncase PIN_CONFIG_POWER_SOURCE:\r\narg = pin->power_source;\r\nbreak;\r\ncase PM8XXX_QCOM_DRIVE_STRENGH:\r\narg = pin->output_strength;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_PUSH_PULL:\r\narg = !pin->open_drain;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\narg = pin->open_drain;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_pin_config_set(struct pinctrl_dev *pctldev,\r\nunsigned int offset,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nunsigned param;\r\nunsigned arg;\r\nunsigned i;\r\nu8 banks = 0;\r\nu8 val;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\npin->bias = PM8XXX_GPIO_BIAS_NP;\r\nbanks |= BIT(2);\r\npin->disable = 0;\r\nbanks |= BIT(3);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\npin->bias = PM8XXX_GPIO_BIAS_PD;\r\nbanks |= BIT(2);\r\npin->disable = 0;\r\nbanks |= BIT(3);\r\nbreak;\r\ncase PM8XXX_QCOM_PULL_UP_STRENGTH:\r\nif (arg > PM8XXX_GPIO_BIAS_PU_1P5_30) {\r\ndev_err(pctrl->dev, "invalid pull-up strength\n");\r\nreturn -EINVAL;\r\n}\r\npin->pull_up_strength = arg;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\npin->bias = pin->pull_up_strength;\r\nbanks |= BIT(2);\r\npin->disable = 0;\r\nbanks |= BIT(3);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\npin->disable = 1;\r\nbanks |= BIT(3);\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\npin->mode = PM8XXX_GPIO_MODE_INPUT;\r\nbanks |= BIT(0) | BIT(1);\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\npin->mode = PM8XXX_GPIO_MODE_OUTPUT;\r\npin->output_value = !!arg;\r\nbanks |= BIT(0) | BIT(1);\r\nbreak;\r\ncase PIN_CONFIG_POWER_SOURCE:\r\npin->power_source = arg;\r\nbanks |= BIT(0);\r\nbreak;\r\ncase PM8XXX_QCOM_DRIVE_STRENGH:\r\nif (arg > PMIC_GPIO_STRENGTH_LOW) {\r\ndev_err(pctrl->dev, "invalid drive strength\n");\r\nreturn -EINVAL;\r\n}\r\npin->output_strength = arg;\r\nbanks |= BIT(3);\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_PUSH_PULL:\r\npin->open_drain = 0;\r\nbanks |= BIT(1);\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\npin->open_drain = 1;\r\nbanks |= BIT(1);\r\nbreak;\r\ndefault:\r\ndev_err(pctrl->dev,\r\n"unsupported config parameter: %x\n",\r\nparam);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (banks & BIT(0)) {\r\nval = pin->power_source << 1;\r\nval |= PM8XXX_GPIO_MODE_ENABLED;\r\npm8xxx_write_bank(pctrl, pin, 0, val);\r\n}\r\nif (banks & BIT(1)) {\r\nval = pin->mode << 2;\r\nval |= pin->open_drain << 1;\r\nval |= pin->output_value;\r\npm8xxx_write_bank(pctrl, pin, 1, val);\r\n}\r\nif (banks & BIT(2)) {\r\nval = pin->bias << 1;\r\npm8xxx_write_bank(pctrl, pin, 2, val);\r\n}\r\nif (banks & BIT(3)) {\r\nval = pin->output_strength << 2;\r\nval |= pin->disable;\r\npm8xxx_write_bank(pctrl, pin, 3, val);\r\n}\r\nif (banks & BIT(4)) {\r\nval = pin->function << 1;\r\npm8xxx_write_bank(pctrl, pin, 4, val);\r\n}\r\nif (banks & BIT(5)) {\r\nval = 0;\r\nif (!pin->inverted)\r\nval |= BIT(3);\r\npm8xxx_write_bank(pctrl, pin, 5, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nu8 val;\r\npin->mode = PM8XXX_GPIO_MODE_INPUT;\r\nval = pin->mode << 2;\r\npm8xxx_write_bank(pctrl, pin, 1, val);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset,\r\nint value)\r\n{\r\nstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nu8 val;\r\npin->mode = PM8XXX_GPIO_MODE_OUTPUT;\r\npin->output_value = !!value;\r\nval = pin->mode << 2;\r\nval |= pin->open_drain << 1;\r\nval |= pin->output_value;\r\npm8xxx_write_bank(pctrl, pin, 1, val);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nbool state;\r\nint ret;\r\nif (pin->mode == PM8XXX_GPIO_MODE_OUTPUT) {\r\nret = pin->output_value;\r\n} else {\r\nret = irq_get_irqchip_state(pin->irq, IRQCHIP_STATE_LINE_LEVEL, &state);\r\nif (!ret)\r\nret = !!state;\r\n}\r\nreturn ret;\r\n}\r\nstatic void pm8xxx_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nu8 val;\r\npin->output_value = !!value;\r\nval = pin->mode << 2;\r\nval |= pin->open_drain << 1;\r\nval |= pin->output_value;\r\npm8xxx_write_bank(pctrl, pin, 1, val);\r\n}\r\nstatic int pm8xxx_gpio_of_xlate(struct gpio_chip *chip,\r\nconst struct of_phandle_args *gpio_desc,\r\nu32 *flags)\r\n{\r\nif (chip->of_gpio_n_cells < 2)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpio_desc->args[1];\r\nreturn gpio_desc->args[0] - 1;\r\n}\r\nstatic int pm8xxx_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nreturn pin->irq;\r\n}\r\nstatic void pm8xxx_gpio_dbg_show_one(struct seq_file *s,\r\nstruct pinctrl_dev *pctldev,\r\nstruct gpio_chip *chip,\r\nunsigned offset,\r\nunsigned gpio)\r\n{\r\nstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nstatic const char * const modes[] = {\r\n"in", "both", "out", "off"\r\n};\r\nstatic const char * const biases[] = {\r\n"pull-up 30uA", "pull-up 1.5uA", "pull-up 31.5uA",\r\n"pull-up 1.5uA + 30uA boost", "pull-down 10uA", "no pull"\r\n};\r\nstatic const char * const buffer_types[] = {\r\n"push-pull", "open-drain"\r\n};\r\nstatic const char * const strengths[] = {\r\n"no", "high", "medium", "low"\r\n};\r\nseq_printf(s, " gpio%-2d:", offset + 1);\r\nif (pin->disable) {\r\nseq_puts(s, " ---");\r\n} else {\r\nseq_printf(s, " %-4s", modes[pin->mode]);\r\nseq_printf(s, " %-7s", pm8xxx_gpio_functions[pin->function]);\r\nseq_printf(s, " VIN%d", pin->power_source);\r\nseq_printf(s, " %-27s", biases[pin->bias]);\r\nseq_printf(s, " %-10s", buffer_types[pin->open_drain]);\r\nseq_printf(s, " %-4s", pin->output_value ? "high" : "low");\r\nseq_printf(s, " %-7s", strengths[pin->output_strength]);\r\nif (pin->inverted)\r\nseq_puts(s, " inverted");\r\n}\r\n}\r\nstatic void pm8xxx_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nunsigned gpio = chip->base;\r\nunsigned i;\r\nfor (i = 0; i < chip->ngpio; i++, gpio++) {\r\npm8xxx_gpio_dbg_show_one(s, NULL, chip, i, gpio);\r\nseq_puts(s, "\n");\r\n}\r\n}\r\nstatic int pm8xxx_pin_populate(struct pm8xxx_gpio *pctrl,\r\nstruct pm8xxx_pin_data *pin)\r\n{\r\nint val;\r\nval = pm8xxx_read_bank(pctrl, pin, 0);\r\nif (val < 0)\r\nreturn val;\r\npin->power_source = (val >> 1) & 0x7;\r\nval = pm8xxx_read_bank(pctrl, pin, 1);\r\nif (val < 0)\r\nreturn val;\r\npin->mode = (val >> 2) & 0x3;\r\npin->open_drain = !!(val & BIT(1));\r\npin->output_value = val & BIT(0);\r\nval = pm8xxx_read_bank(pctrl, pin, 2);\r\nif (val < 0)\r\nreturn val;\r\npin->bias = (val >> 1) & 0x7;\r\nif (pin->bias <= PM8XXX_GPIO_BIAS_PU_1P5_30)\r\npin->pull_up_strength = pin->bias;\r\nelse\r\npin->pull_up_strength = PM8XXX_GPIO_BIAS_PU_30;\r\nval = pm8xxx_read_bank(pctrl, pin, 3);\r\nif (val < 0)\r\nreturn val;\r\npin->output_strength = (val >> 2) & 0x3;\r\npin->disable = val & BIT(0);\r\nval = pm8xxx_read_bank(pctrl, pin, 4);\r\nif (val < 0)\r\nreturn val;\r\npin->function = (val >> 1) & 0x7;\r\nval = pm8xxx_read_bank(pctrl, pin, 5);\r\nif (val < 0)\r\nreturn val;\r\npin->inverted = !(val & BIT(3));\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct pm8xxx_pin_data *pin_data;\r\nstruct pinctrl_pin_desc *pins;\r\nstruct pm8xxx_gpio *pctrl;\r\nint ret;\r\nint i, npins;\r\npctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\r\nif (!pctrl)\r\nreturn -ENOMEM;\r\npctrl->dev = &pdev->dev;\r\nnpins = platform_irq_count(pdev);\r\nif (!npins)\r\nreturn -EINVAL;\r\nif (npins < 0)\r\nreturn npins;\r\npctrl->npins = npins;\r\npctrl->regmap = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!pctrl->regmap) {\r\ndev_err(&pdev->dev, "parent regmap unavailable\n");\r\nreturn -ENXIO;\r\n}\r\npctrl->desc = pm8xxx_pinctrl_desc;\r\npctrl->desc.npins = pctrl->npins;\r\npins = devm_kcalloc(&pdev->dev,\r\npctrl->desc.npins,\r\nsizeof(struct pinctrl_pin_desc),\r\nGFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\npin_data = devm_kcalloc(&pdev->dev,\r\npctrl->desc.npins,\r\nsizeof(struct pm8xxx_pin_data),\r\nGFP_KERNEL);\r\nif (!pin_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctrl->desc.npins; i++) {\r\npin_data[i].reg = SSBI_REG_ADDR_GPIO(i);\r\npin_data[i].irq = platform_get_irq(pdev, i);\r\nif (pin_data[i].irq < 0) {\r\ndev_err(&pdev->dev,\r\n"missing interrupts for pin %d\n", i);\r\nreturn pin_data[i].irq;\r\n}\r\nret = pm8xxx_pin_populate(pctrl, &pin_data[i]);\r\nif (ret)\r\nreturn ret;\r\npins[i].number = i;\r\npins[i].name = pm8xxx_groups[i];\r\npins[i].drv_data = &pin_data[i];\r\n}\r\npctrl->desc.pins = pins;\r\npctrl->desc.num_custom_params = ARRAY_SIZE(pm8xxx_gpio_bindings);\r\npctrl->desc.custom_params = pm8xxx_gpio_bindings;\r\n#ifdef CONFIG_DEBUG_FS\r\npctrl->desc.custom_conf_items = pm8xxx_conf_items;\r\n#endif\r\npctrl->pctrl = devm_pinctrl_register(&pdev->dev, &pctrl->desc, pctrl);\r\nif (IS_ERR(pctrl->pctrl)) {\r\ndev_err(&pdev->dev, "couldn't register pm8xxx gpio driver\n");\r\nreturn PTR_ERR(pctrl->pctrl);\r\n}\r\npctrl->chip = pm8xxx_gpio_template;\r\npctrl->chip.base = -1;\r\npctrl->chip.parent = &pdev->dev;\r\npctrl->chip.of_node = pdev->dev.of_node;\r\npctrl->chip.of_gpio_n_cells = 2;\r\npctrl->chip.label = dev_name(pctrl->dev);\r\npctrl->chip.ngpio = pctrl->npins;\r\nret = gpiochip_add_data(&pctrl->chip, pctrl);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed register gpiochip\n");\r\nreturn ret;\r\n}\r\nret = gpiochip_add_pin_range(&pctrl->chip,\r\ndev_name(pctrl->dev),\r\n0, 0, pctrl->chip.ngpio);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to add pin range\n");\r\ngoto unregister_gpiochip;\r\n}\r\nplatform_set_drvdata(pdev, pctrl);\r\ndev_dbg(&pdev->dev, "Qualcomm pm8xxx gpio driver probed\n");\r\nreturn 0;\r\nunregister_gpiochip:\r\ngpiochip_remove(&pctrl->chip);\r\nreturn ret;\r\n}\r\nstatic int pm8xxx_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct pm8xxx_gpio *pctrl = platform_get_drvdata(pdev);\r\ngpiochip_remove(&pctrl->chip);\r\nreturn 0;\r\n}
