static int __init t128_setup(char *str)\r\n{\r\nstatic int commandline_current;\r\nint i;\r\nint ints[10];\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\nif (ints[0] != 2)\r\nprintk("t128_setup : usage t128=address,irq\n");\r\nelse\r\nif (commandline_current < NO_OVERRIDES) {\r\noverrides[commandline_current].address = ints[1];\r\noverrides[commandline_current].irq = ints[2];\r\nfor (i = 0; i < NO_BASES; ++i)\r\nif (bases[i].address == ints[1]) {\r\nbases[i].noauto = 1;\r\nbreak;\r\n}\r\n++commandline_current;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init t128_detect(struct scsi_host_template *tpnt)\r\n{\r\nstatic int current_override, current_base;\r\nstruct Scsi_Host *instance;\r\nunsigned long base;\r\nvoid __iomem *p;\r\nint sig, count;\r\nfor (count = 0; current_override < NO_OVERRIDES; ++current_override) {\r\nbase = 0;\r\np = NULL;\r\nif (overrides[current_override].address) {\r\nbase = overrides[current_override].address;\r\np = ioremap(bases[current_base].address, 0x2000);\r\nif (!p)\r\nbase = 0;\r\n} else\r\nfor (; !base && (current_base < NO_BASES); ++current_base) {\r\ndprintk(NDEBUG_INIT, "t128: probing address 0x%08x\n",\r\nbases[current_base].address);\r\nif (bases[current_base].noauto)\r\ncontinue;\r\np = ioremap(bases[current_base].address, 0x2000);\r\nif (!p)\r\ncontinue;\r\nfor (sig = 0; sig < NO_SIGNATURES; ++sig)\r\nif (check_signature(p + signatures[sig].offset,\r\nsignatures[sig].string,\r\nstrlen(signatures[sig].string))) {\r\nbase = bases[current_base].address;\r\ndprintk(NDEBUG_INIT, "t128: detected board\n");\r\ngoto found;\r\n}\r\niounmap(p);\r\n}\r\ndprintk(NDEBUG_INIT, "t128: base = 0x%08x\n", (unsigned int)base);\r\nif (!base)\r\nbreak;\r\nfound:\r\ninstance = scsi_register (tpnt, sizeof(struct NCR5380_hostdata));\r\nif(instance == NULL)\r\ngoto out_unmap;\r\ninstance->base = base;\r\n((struct NCR5380_hostdata *)instance->hostdata)->base = p;\r\nif (NCR5380_init(instance, FLAG_DMA_FIXUP | FLAG_LATE_DMA_SETUP))\r\ngoto out_unregister;\r\nNCR5380_maybe_reset_bus(instance);\r\nif (overrides[current_override].irq != IRQ_AUTO)\r\ninstance->irq = overrides[current_override].irq;\r\nelse\r\ninstance->irq = NCR5380_probe_irq(instance, T128_IRQS);\r\nif (instance->irq == 255)\r\ninstance->irq = NO_IRQ;\r\nif (instance->irq != NO_IRQ)\r\nif (request_irq(instance->irq, t128_intr, 0, "t128",\r\ninstance)) {\r\nprintk("scsi%d : IRQ%d not free, interrupts disabled\n",\r\ninstance->host_no, instance->irq);\r\ninstance->irq = NO_IRQ;\r\n}\r\nif (instance->irq == NO_IRQ) {\r\nprintk("scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);\r\nprintk("scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);\r\n}\r\ndprintk(NDEBUG_INIT, "scsi%d: irq = %d\n",\r\ninstance->host_no, instance->irq);\r\n++current_override;\r\n++count;\r\n}\r\nreturn count;\r\nout_unregister:\r\nscsi_unregister(instance);\r\nout_unmap:\r\niounmap(p);\r\nreturn count;\r\n}\r\nstatic int t128_release(struct Scsi_Host *shost)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(shost);\r\nif (shost->irq != NO_IRQ)\r\nfree_irq(shost->irq, shost);\r\nNCR5380_exit(shost);\r\nscsi_unregister(shost);\r\niounmap(hostdata->base);\r\nreturn 0;\r\n}\r\nstatic int t128_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int *ip)\r\n{\r\nip[0] = 64;\r\nip[1] = 32;\r\nip[2] = capacity >> 11;\r\nreturn 0;\r\n}\r\nstatic inline int t128_pread(struct Scsi_Host *instance,\r\nunsigned char *dst, int len)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nvoid __iomem *reg, *base = hostdata->base;\r\nunsigned char *d = dst;\r\nregister int i = len;\r\nreg = base + T_DATA_REG_OFFSET;\r\n#if 0\r\nfor (; i; --i) {\r\nwhile (!(readb(base+T_STATUS_REG_OFFSET) & T_ST_RDY)) barrier();\r\n#else\r\nwhile (!(readb(base+T_STATUS_REG_OFFSET) & T_ST_RDY)) barrier();\r\nfor (; i; --i) {\r\n#endif\r\n*d++ = readb(reg);\r\n}\r\nif (readb(base + T_STATUS_REG_OFFSET) & T_ST_TIM) {\r\nunsigned char tmp;\r\nvoid __iomem *foo = base + T_CONTROL_REG_OFFSET;\r\ntmp = readb(foo);\r\nwriteb(tmp | T_CR_CT, foo);\r\nwriteb(tmp, foo);\r\nprintk("scsi%d : watchdog timer fired in NCR5380_pread()\n",\r\ninstance->host_no);\r\nreturn -1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic inline int t128_pwrite(struct Scsi_Host *instance,\r\nunsigned char *src, int len)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nvoid __iomem *reg, *base = hostdata->base;\r\nunsigned char *s = src;\r\nregister int i = len;\r\nreg = base + T_DATA_REG_OFFSET;\r\n#if 0\r\nfor (; i; --i) {\r\nwhile (!(readb(base+T_STATUS_REG_OFFSET) & T_ST_RDY)) barrier();\r\n#else\r\nwhile (!(readb(base+T_STATUS_REG_OFFSET) & T_ST_RDY)) barrier();\r\nfor (; i; --i) {\r\n#endif\r\nwriteb(*s++, reg);\r\n}\r\nif (readb(base + T_STATUS_REG_OFFSET) & T_ST_TIM) {\r\nunsigned char tmp;\r\nvoid __iomem *foo = base + T_CONTROL_REG_OFFSET;\r\ntmp = readb(foo);\r\nwriteb(tmp | T_CR_CT, foo);\r\nwriteb(tmp, foo);\r\nprintk("scsi%d : watchdog timer fired in NCR5380_pwrite()\n",\r\ninstance->host_no);\r\nreturn -1;\r\n} else\r\nreturn 0;\r\n}
