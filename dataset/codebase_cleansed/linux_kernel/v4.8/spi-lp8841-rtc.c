static inline void\r\nsetsck(struct spi_lp8841_rtc *data, int is_on)\r\n{\r\nif (is_on)\r\ndata->state |= SPI_LP8841_RTC_CLK;\r\nelse\r\ndata->state &= ~SPI_LP8841_RTC_CLK;\r\nwriteb(data->state, data->iomem);\r\n}\r\nstatic inline void\r\nsetmosi(struct spi_lp8841_rtc *data, int is_on)\r\n{\r\nif (is_on)\r\ndata->state |= SPI_LP8841_RTC_MOSI;\r\nelse\r\ndata->state &= ~SPI_LP8841_RTC_MOSI;\r\nwriteb(data->state, data->iomem);\r\n}\r\nstatic inline int\r\ngetmiso(struct spi_lp8841_rtc *data)\r\n{\r\nreturn ioread8(data->iomem) & SPI_LP8841_RTC_MISO;\r\n}\r\nstatic inline u32\r\nbitbang_txrx_be_cpha0_lsb(struct spi_lp8841_rtc *data,\r\nunsigned usecs, unsigned cpol, unsigned flags,\r\nu32 word, u8 bits)\r\n{\r\nu32 shift = 32 - bits;\r\nfor (; likely(bits); bits--) {\r\nif ((flags & SPI_MASTER_NO_TX) == 0)\r\nsetmosi(data, (word & 1));\r\nusleep_range(usecs, usecs + 1);\r\nword >>= 1;\r\nif ((flags & SPI_MASTER_NO_RX) == 0)\r\nword |= (getmiso(data) << 31);\r\nsetsck(data, !cpol);\r\nusleep_range(usecs, usecs + 1);\r\nsetsck(data, cpol);\r\n}\r\nword >>= shift;\r\nreturn word;\r\n}\r\nstatic int\r\nspi_lp8841_rtc_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct spi_lp8841_rtc *data = spi_master_get_devdata(master);\r\nunsigned count = t->len;\r\nconst u8 *tx = t->tx_buf;\r\nu8 *rx = t->rx_buf;\r\nu8 word = 0;\r\nint ret = 0;\r\nif (tx) {\r\ndata->state &= ~SPI_LP8841_RTC_nWE;\r\nwriteb(data->state, data->iomem);\r\nwhile (likely(count > 0)) {\r\nword = *tx++;\r\nbitbang_txrx_be_cpha0_lsb(data, 1, 0,\r\nSPI_MASTER_NO_RX, word, 8);\r\ncount--;\r\n}\r\n} else if (rx) {\r\ndata->state |= SPI_LP8841_RTC_nWE;\r\nwriteb(data->state, data->iomem);\r\nwhile (likely(count > 0)) {\r\nword = bitbang_txrx_be_cpha0_lsb(data, 1, 0,\r\nSPI_MASTER_NO_TX, word, 8);\r\n*rx++ = word;\r\ncount--;\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\nspi_finalize_current_transfer(master);\r\nreturn ret;\r\n}\r\nstatic void\r\nspi_lp8841_rtc_set_cs(struct spi_device *spi, bool enable)\r\n{\r\nstruct spi_lp8841_rtc *data = spi_master_get_devdata(spi->master);\r\ndata->state = 0;\r\nwriteb(data->state, data->iomem);\r\nif (enable) {\r\nusleep_range(4, 5);\r\ndata->state |= SPI_LP8841_RTC_CE;\r\nwriteb(data->state, data->iomem);\r\nusleep_range(4, 5);\r\n}\r\n}\r\nstatic int\r\nspi_lp8841_rtc_setup(struct spi_device *spi)\r\n{\r\nif ((spi->mode & SPI_CS_HIGH) == 0) {\r\ndev_err(&spi->dev, "unsupported active low chip select\n");\r\nreturn -EINVAL;\r\n}\r\nif ((spi->mode & SPI_LSB_FIRST) == 0) {\r\ndev_err(&spi->dev, "unsupported MSB first mode\n");\r\nreturn -EINVAL;\r\n}\r\nif ((spi->mode & SPI_3WIRE) == 0) {\r\ndev_err(&spi->dev, "unsupported wiring. 3 wires required\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nspi_lp8841_rtc_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct spi_master *master;\r\nstruct spi_lp8841_rtc *data;\r\nvoid *iomem;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*data));\r\nif (!master)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, master);\r\nmaster->flags = SPI_MASTER_HALF_DUPLEX;\r\nmaster->mode_bits = SPI_CS_HIGH | SPI_3WIRE | SPI_LSB_FIRST;\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = 1;\r\nmaster->setup = spi_lp8841_rtc_setup;\r\nmaster->set_cs = spi_lp8841_rtc_set_cs;\r\nmaster->transfer_one = spi_lp8841_rtc_transfer_one;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\n#ifdef CONFIG_OF\r\nmaster->dev.of_node = pdev->dev.of_node;\r\n#endif\r\ndata = spi_master_get_devdata(master);\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->iomem = devm_ioremap_resource(&pdev->dev, iomem);\r\nret = PTR_ERR_OR_ZERO(data->iomem);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get IO address\n");\r\ngoto err_put_master;\r\n}\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot register spi master\n");\r\ngoto err_put_master;\r\n}\r\nreturn ret;\r\nerr_put_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}
