static unsigned int mtk_ddp_mout_en(enum mtk_ddp_comp_id cur,\r\nenum mtk_ddp_comp_id next,\r\nunsigned int *addr)\r\n{\r\nunsigned int value;\r\nif (cur == DDP_COMPONENT_OVL0 && next == DDP_COMPONENT_COLOR0) {\r\n*addr = DISP_REG_CONFIG_DISP_OVL0_MOUT_EN;\r\nvalue = OVL0_MOUT_EN_COLOR0;\r\n} else if (cur == DDP_COMPONENT_OD && next == DDP_COMPONENT_RDMA0) {\r\n*addr = DISP_REG_CONFIG_DISP_OD_MOUT_EN;\r\nvalue = OD_MOUT_EN_RDMA0;\r\n} else if (cur == DDP_COMPONENT_UFOE && next == DDP_COMPONENT_DSI0) {\r\n*addr = DISP_REG_CONFIG_DISP_UFOE_MOUT_EN;\r\nvalue = UFOE_MOUT_EN_DSI0;\r\n} else if (cur == DDP_COMPONENT_OVL1 && next == DDP_COMPONENT_COLOR1) {\r\n*addr = DISP_REG_CONFIG_DISP_OVL1_MOUT_EN;\r\nvalue = OVL1_MOUT_EN_COLOR1;\r\n} else if (cur == DDP_COMPONENT_GAMMA && next == DDP_COMPONENT_RDMA1) {\r\n*addr = DISP_REG_CONFIG_DISP_GAMMA_MOUT_EN;\r\nvalue = GAMMA_MOUT_EN_RDMA1;\r\n} else if (cur == DDP_COMPONENT_RDMA1 && next == DDP_COMPONENT_DPI0) {\r\n*addr = DISP_REG_CONFIG_DISP_RDMA1_MOUT_EN;\r\nvalue = RDMA1_MOUT_DPI0;\r\n} else {\r\nvalue = 0;\r\n}\r\nreturn value;\r\n}\r\nstatic unsigned int mtk_ddp_sel_in(enum mtk_ddp_comp_id cur,\r\nenum mtk_ddp_comp_id next,\r\nunsigned int *addr)\r\n{\r\nunsigned int value;\r\nif (cur == DDP_COMPONENT_OVL0 && next == DDP_COMPONENT_COLOR0) {\r\n*addr = DISP_REG_CONFIG_DISP_COLOR0_SEL_IN;\r\nvalue = COLOR0_SEL_IN_OVL0;\r\n} else if (cur == DDP_COMPONENT_RDMA1 && next == DDP_COMPONENT_DPI0) {\r\n*addr = DISP_REG_CONFIG_DPI_SEL_IN;\r\nvalue = DPI0_SEL_IN_RDMA1;\r\n} else if (cur == DDP_COMPONENT_OVL1 && next == DDP_COMPONENT_COLOR1) {\r\n*addr = DISP_REG_CONFIG_DISP_COLOR1_SEL_IN;\r\nvalue = COLOR1_SEL_IN_OVL1;\r\n} else {\r\nvalue = 0;\r\n}\r\nreturn value;\r\n}\r\nvoid mtk_ddp_add_comp_to_path(void __iomem *config_regs,\r\nenum mtk_ddp_comp_id cur,\r\nenum mtk_ddp_comp_id next)\r\n{\r\nunsigned int addr, value, reg;\r\nvalue = mtk_ddp_mout_en(cur, next, &addr);\r\nif (value) {\r\nreg = readl_relaxed(config_regs + addr) | value;\r\nwritel_relaxed(reg, config_regs + addr);\r\n}\r\nvalue = mtk_ddp_sel_in(cur, next, &addr);\r\nif (value) {\r\nreg = readl_relaxed(config_regs + addr) | value;\r\nwritel_relaxed(reg, config_regs + addr);\r\n}\r\n}\r\nvoid mtk_ddp_remove_comp_from_path(void __iomem *config_regs,\r\nenum mtk_ddp_comp_id cur,\r\nenum mtk_ddp_comp_id next)\r\n{\r\nunsigned int addr, value, reg;\r\nvalue = mtk_ddp_mout_en(cur, next, &addr);\r\nif (value) {\r\nreg = readl_relaxed(config_regs + addr) & ~value;\r\nwritel_relaxed(reg, config_regs + addr);\r\n}\r\nvalue = mtk_ddp_sel_in(cur, next, &addr);\r\nif (value) {\r\nreg = readl_relaxed(config_regs + addr) & ~value;\r\nwritel_relaxed(reg, config_regs + addr);\r\n}\r\n}\r\nstruct mtk_disp_mutex *mtk_disp_mutex_get(struct device *dev, unsigned int id)\r\n{\r\nstruct mtk_ddp *ddp = dev_get_drvdata(dev);\r\nif (id >= 10)\r\nreturn ERR_PTR(-EINVAL);\r\nif (ddp->mutex[id].claimed)\r\nreturn ERR_PTR(-EBUSY);\r\nddp->mutex[id].claimed = true;\r\nreturn &ddp->mutex[id];\r\n}\r\nvoid mtk_disp_mutex_put(struct mtk_disp_mutex *mutex)\r\n{\r\nstruct mtk_ddp *ddp = container_of(mutex, struct mtk_ddp,\r\nmutex[mutex->id]);\r\nWARN_ON(&ddp->mutex[mutex->id] != mutex);\r\nmutex->claimed = false;\r\n}\r\nint mtk_disp_mutex_prepare(struct mtk_disp_mutex *mutex)\r\n{\r\nstruct mtk_ddp *ddp = container_of(mutex, struct mtk_ddp,\r\nmutex[mutex->id]);\r\nreturn clk_prepare_enable(ddp->clk);\r\n}\r\nvoid mtk_disp_mutex_unprepare(struct mtk_disp_mutex *mutex)\r\n{\r\nstruct mtk_ddp *ddp = container_of(mutex, struct mtk_ddp,\r\nmutex[mutex->id]);\r\nclk_disable_unprepare(ddp->clk);\r\n}\r\nvoid mtk_disp_mutex_add_comp(struct mtk_disp_mutex *mutex,\r\nenum mtk_ddp_comp_id id)\r\n{\r\nstruct mtk_ddp *ddp = container_of(mutex, struct mtk_ddp,\r\nmutex[mutex->id]);\r\nunsigned int reg;\r\nWARN_ON(&ddp->mutex[mutex->id] != mutex);\r\nswitch (id) {\r\ncase DDP_COMPONENT_DSI0:\r\nreg = MUTEX_SOF_DSI0;\r\nbreak;\r\ncase DDP_COMPONENT_DSI1:\r\nreg = MUTEX_SOF_DSI0;\r\nbreak;\r\ncase DDP_COMPONENT_DPI0:\r\nreg = MUTEX_SOF_DPI0;\r\nbreak;\r\ndefault:\r\nreg = readl_relaxed(ddp->regs + DISP_REG_MUTEX_MOD(mutex->id));\r\nreg |= mutex_mod[id];\r\nwritel_relaxed(reg, ddp->regs + DISP_REG_MUTEX_MOD(mutex->id));\r\nreturn;\r\n}\r\nwritel_relaxed(reg, ddp->regs + DISP_REG_MUTEX_SOF(mutex->id));\r\n}\r\nvoid mtk_disp_mutex_remove_comp(struct mtk_disp_mutex *mutex,\r\nenum mtk_ddp_comp_id id)\r\n{\r\nstruct mtk_ddp *ddp = container_of(mutex, struct mtk_ddp,\r\nmutex[mutex->id]);\r\nunsigned int reg;\r\nWARN_ON(&ddp->mutex[mutex->id] != mutex);\r\nswitch (id) {\r\ncase DDP_COMPONENT_DSI0:\r\ncase DDP_COMPONENT_DSI1:\r\ncase DDP_COMPONENT_DPI0:\r\nwritel_relaxed(MUTEX_SOF_SINGLE_MODE,\r\nddp->regs + DISP_REG_MUTEX_SOF(mutex->id));\r\nbreak;\r\ndefault:\r\nreg = readl_relaxed(ddp->regs + DISP_REG_MUTEX_MOD(mutex->id));\r\nreg &= ~mutex_mod[id];\r\nwritel_relaxed(reg, ddp->regs + DISP_REG_MUTEX_MOD(mutex->id));\r\nbreak;\r\n}\r\n}\r\nvoid mtk_disp_mutex_enable(struct mtk_disp_mutex *mutex)\r\n{\r\nstruct mtk_ddp *ddp = container_of(mutex, struct mtk_ddp,\r\nmutex[mutex->id]);\r\nWARN_ON(&ddp->mutex[mutex->id] != mutex);\r\nwritel(1, ddp->regs + DISP_REG_MUTEX_EN(mutex->id));\r\n}\r\nvoid mtk_disp_mutex_disable(struct mtk_disp_mutex *mutex)\r\n{\r\nstruct mtk_ddp *ddp = container_of(mutex, struct mtk_ddp,\r\nmutex[mutex->id]);\r\nWARN_ON(&ddp->mutex[mutex->id] != mutex);\r\nwritel(0, ddp->regs + DISP_REG_MUTEX_EN(mutex->id));\r\n}\r\nstatic int mtk_ddp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mtk_ddp *ddp;\r\nstruct resource *regs;\r\nint i;\r\nddp = devm_kzalloc(dev, sizeof(*ddp), GFP_KERNEL);\r\nif (!ddp)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 10; i++)\r\nddp->mutex[i].id = i;\r\nddp->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(ddp->clk)) {\r\ndev_err(dev, "Failed to get clock\n");\r\nreturn PTR_ERR(ddp->clk);\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nddp->regs = devm_ioremap_resource(dev, regs);\r\nif (IS_ERR(ddp->regs)) {\r\ndev_err(dev, "Failed to map mutex registers\n");\r\nreturn PTR_ERR(ddp->regs);\r\n}\r\nplatform_set_drvdata(pdev, ddp);\r\nreturn 0;\r\n}\r\nstatic int mtk_ddp_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}
