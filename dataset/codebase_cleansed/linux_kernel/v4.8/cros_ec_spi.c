static void debug_packet(struct device *dev, const char *name, u8 *ptr,\r\nint len)\r\n{\r\n#ifdef DEBUG\r\nint i;\r\ndev_dbg(dev, "%s: ", name);\r\nfor (i = 0; i < len; i++)\r\npr_cont(" %02x", ptr[i]);\r\npr_cont("\n");\r\n#endif\r\n}\r\nstatic int terminate_request(struct cros_ec_device *ec_dev)\r\n{\r\nstruct cros_ec_spi *ec_spi = ec_dev->priv;\r\nstruct spi_message msg;\r\nstruct spi_transfer trans;\r\nint ret;\r\nspi_message_init(&msg);\r\nmemset(&trans, 0, sizeof(trans));\r\ntrans.delay_usecs = ec_spi->end_of_msg_delay;\r\nspi_message_add_tail(&trans, &msg);\r\nret = spi_sync_locked(ec_spi->spi, &msg);\r\nec_spi->last_transfer_ns = ktime_get_ns();\r\nif (ret < 0) {\r\ndev_err(ec_dev->dev,\r\n"cs-deassert spi transfer failed: %d\n",\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int receive_n_bytes(struct cros_ec_device *ec_dev, u8 *buf, int n)\r\n{\r\nstruct cros_ec_spi *ec_spi = ec_dev->priv;\r\nstruct spi_transfer trans;\r\nstruct spi_message msg;\r\nint ret;\r\nBUG_ON(buf - ec_dev->din + n > ec_dev->din_size);\r\nmemset(&trans, 0, sizeof(trans));\r\ntrans.cs_change = 1;\r\ntrans.rx_buf = buf;\r\ntrans.len = n;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&trans, &msg);\r\nret = spi_sync_locked(ec_spi->spi, &msg);\r\nif (ret < 0)\r\ndev_err(ec_dev->dev, "spi transfer failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_spi_receive_packet(struct cros_ec_device *ec_dev,\r\nint need_len)\r\n{\r\nstruct ec_host_response *response;\r\nu8 *ptr, *end;\r\nint ret;\r\nunsigned long deadline;\r\nint todo;\r\nBUG_ON(ec_dev->din_size < EC_MSG_PREAMBLE_COUNT);\r\ndeadline = jiffies + msecs_to_jiffies(EC_MSG_DEADLINE_MS);\r\nwhile (true) {\r\nunsigned long start_jiffies = jiffies;\r\nret = receive_n_bytes(ec_dev,\r\nec_dev->din,\r\nEC_MSG_PREAMBLE_COUNT);\r\nif (ret < 0)\r\nreturn ret;\r\nptr = ec_dev->din;\r\nfor (end = ptr + EC_MSG_PREAMBLE_COUNT; ptr != end; ptr++) {\r\nif (*ptr == EC_SPI_FRAME_START) {\r\ndev_dbg(ec_dev->dev, "msg found at %zd\n",\r\nptr - ec_dev->din);\r\nbreak;\r\n}\r\n}\r\nif (ptr != end)\r\nbreak;\r\nif (time_after(start_jiffies, deadline)) {\r\ndev_warn(ec_dev->dev, "EC failed to respond in time\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\ntodo = end - ++ptr;\r\nBUG_ON(todo < 0 || todo > ec_dev->din_size);\r\ntodo = min(todo, need_len);\r\nmemmove(ec_dev->din, ptr, todo);\r\nptr = ec_dev->din + todo;\r\ndev_dbg(ec_dev->dev, "need %d, got %d bytes from preamble\n",\r\nneed_len, todo);\r\nneed_len -= todo;\r\nif (todo < sizeof(*response)) {\r\nret = receive_n_bytes(ec_dev, ptr, sizeof(*response) - todo);\r\nif (ret < 0)\r\nreturn -EBADMSG;\r\nptr += (sizeof(*response) - todo);\r\ntodo = sizeof(*response);\r\n}\r\nresponse = (struct ec_host_response *)ec_dev->din;\r\nif (response->data_len > ec_dev->din_size)\r\nreturn -EMSGSIZE;\r\nwhile (need_len > 0) {\r\ntodo = min(need_len, 256);\r\ndev_dbg(ec_dev->dev, "loop, todo=%d, need_len=%d, ptr=%zd\n",\r\ntodo, need_len, ptr - ec_dev->din);\r\nret = receive_n_bytes(ec_dev, ptr, todo);\r\nif (ret < 0)\r\nreturn ret;\r\nptr += todo;\r\nneed_len -= todo;\r\n}\r\ndev_dbg(ec_dev->dev, "loop done, ptr=%zd\n", ptr - ec_dev->din);\r\nreturn 0;\r\n}\r\nstatic int cros_ec_spi_receive_response(struct cros_ec_device *ec_dev,\r\nint need_len)\r\n{\r\nu8 *ptr, *end;\r\nint ret;\r\nunsigned long deadline;\r\nint todo;\r\nBUG_ON(ec_dev->din_size < EC_MSG_PREAMBLE_COUNT);\r\ndeadline = jiffies + msecs_to_jiffies(EC_MSG_DEADLINE_MS);\r\nwhile (true) {\r\nunsigned long start_jiffies = jiffies;\r\nret = receive_n_bytes(ec_dev,\r\nec_dev->din,\r\nEC_MSG_PREAMBLE_COUNT);\r\nif (ret < 0)\r\nreturn ret;\r\nptr = ec_dev->din;\r\nfor (end = ptr + EC_MSG_PREAMBLE_COUNT; ptr != end; ptr++) {\r\nif (*ptr == EC_SPI_FRAME_START) {\r\ndev_dbg(ec_dev->dev, "msg found at %zd\n",\r\nptr - ec_dev->din);\r\nbreak;\r\n}\r\n}\r\nif (ptr != end)\r\nbreak;\r\nif (time_after(start_jiffies, deadline)) {\r\ndev_warn(ec_dev->dev, "EC failed to respond in time\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\ntodo = end - ++ptr;\r\nBUG_ON(todo < 0 || todo > ec_dev->din_size);\r\ntodo = min(todo, need_len);\r\nmemmove(ec_dev->din, ptr, todo);\r\nptr = ec_dev->din + todo;\r\ndev_dbg(ec_dev->dev, "need %d, got %d bytes from preamble\n",\r\nneed_len, todo);\r\nneed_len -= todo;\r\nwhile (need_len > 0) {\r\ntodo = min(need_len, 256);\r\ndev_dbg(ec_dev->dev, "loop, todo=%d, need_len=%d, ptr=%zd\n",\r\ntodo, need_len, ptr - ec_dev->din);\r\nret = receive_n_bytes(ec_dev, ptr, todo);\r\nif (ret < 0)\r\nreturn ret;\r\ndebug_packet(ec_dev->dev, "interim", ptr, todo);\r\nptr += todo;\r\nneed_len -= todo;\r\n}\r\ndev_dbg(ec_dev->dev, "loop done, ptr=%zd\n", ptr - ec_dev->din);\r\nreturn 0;\r\n}\r\nstatic int cros_ec_pkt_xfer_spi(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *ec_msg)\r\n{\r\nstruct ec_host_request *request;\r\nstruct ec_host_response *response;\r\nstruct cros_ec_spi *ec_spi = ec_dev->priv;\r\nstruct spi_transfer trans, trans_delay;\r\nstruct spi_message msg;\r\nint i, len;\r\nu8 *ptr;\r\nu8 *rx_buf;\r\nu8 sum;\r\nint ret = 0, final_ret;\r\nlen = cros_ec_prepare_tx(ec_dev, ec_msg);\r\nrequest = (struct ec_host_request *)ec_dev->dout;\r\ndev_dbg(ec_dev->dev, "prepared, len=%d\n", len);\r\nif (ec_spi->last_transfer_ns) {\r\nunsigned long delay;\r\ndelay = ktime_get_ns() - ec_spi->last_transfer_ns;\r\nif (delay < EC_SPI_RECOVERY_TIME_NS)\r\nndelay(EC_SPI_RECOVERY_TIME_NS - delay);\r\n}\r\nrx_buf = kzalloc(len, GFP_KERNEL);\r\nif (!rx_buf)\r\nreturn -ENOMEM;\r\nspi_bus_lock(ec_spi->spi->master);\r\nspi_message_init(&msg);\r\nif (ec_spi->start_of_msg_delay) {\r\nmemset(&trans_delay, 0, sizeof(trans_delay));\r\ntrans_delay.delay_usecs = ec_spi->start_of_msg_delay;\r\nspi_message_add_tail(&trans_delay, &msg);\r\n}\r\nmemset(&trans, 0, sizeof(trans));\r\ntrans.tx_buf = ec_dev->dout;\r\ntrans.rx_buf = rx_buf;\r\ntrans.len = len;\r\ntrans.cs_change = 1;\r\nspi_message_add_tail(&trans, &msg);\r\nret = spi_sync_locked(ec_spi->spi, &msg);\r\nif (!ret) {\r\nfor (i = 0; i < len; i++) {\r\nswitch (rx_buf[i]) {\r\ncase EC_SPI_PAST_END:\r\ncase EC_SPI_RX_BAD_DATA:\r\ncase EC_SPI_NOT_READY:\r\nret = -EAGAIN;\r\nec_msg->result = EC_RES_IN_PROGRESS;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret)\r\nbreak;\r\n}\r\nif (!ret)\r\nret = cros_ec_spi_receive_packet(ec_dev,\r\nec_msg->insize + sizeof(*response));\r\n} else {\r\ndev_err(ec_dev->dev, "spi transfer failed: %d\n", ret);\r\n}\r\nfinal_ret = terminate_request(ec_dev);\r\nspi_bus_unlock(ec_spi->spi->master);\r\nif (!ret)\r\nret = final_ret;\r\nif (ret < 0)\r\ngoto exit;\r\nptr = ec_dev->din;\r\nresponse = (struct ec_host_response *)ptr;\r\nec_msg->result = response->result;\r\nret = cros_ec_check_result(ec_dev, ec_msg);\r\nif (ret)\r\ngoto exit;\r\nlen = response->data_len;\r\nsum = 0;\r\nif (len > ec_msg->insize) {\r\ndev_err(ec_dev->dev, "packet too long (%d bytes, expected %d)",\r\nlen, ec_msg->insize);\r\nret = -EMSGSIZE;\r\ngoto exit;\r\n}\r\nfor (i = 0; i < sizeof(*response); i++)\r\nsum += ptr[i];\r\nmemcpy(ec_msg->data, ptr + sizeof(*response), len);\r\nfor (i = 0; i < len; i++)\r\nsum += ec_msg->data[i];\r\nif (sum) {\r\ndev_err(ec_dev->dev,\r\n"bad packet checksum, calculated %x\n",\r\nsum);\r\nret = -EBADMSG;\r\ngoto exit;\r\n}\r\nret = len;\r\nexit:\r\nkfree(rx_buf);\r\nif (ec_msg->command == EC_CMD_REBOOT_EC)\r\nmsleep(EC_REBOOT_DELAY_MS);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_cmd_xfer_spi(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *ec_msg)\r\n{\r\nstruct cros_ec_spi *ec_spi = ec_dev->priv;\r\nstruct spi_transfer trans;\r\nstruct spi_message msg;\r\nint i, len;\r\nu8 *ptr;\r\nu8 *rx_buf;\r\nint sum;\r\nint ret = 0, final_ret;\r\nlen = cros_ec_prepare_tx(ec_dev, ec_msg);\r\ndev_dbg(ec_dev->dev, "prepared, len=%d\n", len);\r\nif (ec_spi->last_transfer_ns) {\r\nunsigned long delay;\r\ndelay = ktime_get_ns() - ec_spi->last_transfer_ns;\r\nif (delay < EC_SPI_RECOVERY_TIME_NS)\r\nndelay(EC_SPI_RECOVERY_TIME_NS - delay);\r\n}\r\nrx_buf = kzalloc(len, GFP_KERNEL);\r\nif (!rx_buf)\r\nreturn -ENOMEM;\r\nspi_bus_lock(ec_spi->spi->master);\r\ndebug_packet(ec_dev->dev, "out", ec_dev->dout, len);\r\nmemset(&trans, 0, sizeof(trans));\r\ntrans.tx_buf = ec_dev->dout;\r\ntrans.rx_buf = rx_buf;\r\ntrans.len = len;\r\ntrans.cs_change = 1;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&trans, &msg);\r\nret = spi_sync_locked(ec_spi->spi, &msg);\r\nif (!ret) {\r\nfor (i = 0; i < len; i++) {\r\nswitch (rx_buf[i]) {\r\ncase EC_SPI_PAST_END:\r\ncase EC_SPI_RX_BAD_DATA:\r\ncase EC_SPI_NOT_READY:\r\nret = -EAGAIN;\r\nec_msg->result = EC_RES_IN_PROGRESS;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret)\r\nbreak;\r\n}\r\nif (!ret)\r\nret = cros_ec_spi_receive_response(ec_dev,\r\nec_msg->insize + EC_MSG_TX_PROTO_BYTES);\r\n} else {\r\ndev_err(ec_dev->dev, "spi transfer failed: %d\n", ret);\r\n}\r\nfinal_ret = terminate_request(ec_dev);\r\nspi_bus_unlock(ec_spi->spi->master);\r\nif (!ret)\r\nret = final_ret;\r\nif (ret < 0)\r\ngoto exit;\r\nptr = ec_dev->din;\r\nec_msg->result = ptr[0];\r\nret = cros_ec_check_result(ec_dev, ec_msg);\r\nif (ret)\r\ngoto exit;\r\nlen = ptr[1];\r\nsum = ptr[0] + ptr[1];\r\nif (len > ec_msg->insize) {\r\ndev_err(ec_dev->dev, "packet too long (%d bytes, expected %d)",\r\nlen, ec_msg->insize);\r\nret = -ENOSPC;\r\ngoto exit;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nsum += ptr[i + 2];\r\nif (ec_msg->insize)\r\nec_msg->data[i] = ptr[i + 2];\r\n}\r\nsum &= 0xff;\r\ndebug_packet(ec_dev->dev, "in", ptr, len + 3);\r\nif (sum != ptr[len + 2]) {\r\ndev_err(ec_dev->dev,\r\n"bad packet checksum, expected %02x, got %02x\n",\r\nsum, ptr[len + 2]);\r\nret = -EBADMSG;\r\ngoto exit;\r\n}\r\nret = len;\r\nexit:\r\nkfree(rx_buf);\r\nif (ec_msg->command == EC_CMD_REBOOT_EC)\r\nmsleep(EC_REBOOT_DELAY_MS);\r\nreturn ret;\r\n}\r\nstatic void cros_ec_spi_dt_probe(struct cros_ec_spi *ec_spi, struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nu32 val;\r\nint ret;\r\nret = of_property_read_u32(np, "google,cros-ec-spi-pre-delay", &val);\r\nif (!ret)\r\nec_spi->start_of_msg_delay = val;\r\nret = of_property_read_u32(np, "google,cros-ec-spi-msg-delay", &val);\r\nif (!ret)\r\nec_spi->end_of_msg_delay = val;\r\n}\r\nstatic int cros_ec_spi_probe(struct spi_device *spi)\r\n{\r\nstruct device *dev = &spi->dev;\r\nstruct cros_ec_device *ec_dev;\r\nstruct cros_ec_spi *ec_spi;\r\nint err;\r\nspi->bits_per_word = 8;\r\nspi->mode = SPI_MODE_0;\r\nerr = spi_setup(spi);\r\nif (err < 0)\r\nreturn err;\r\nec_spi = devm_kzalloc(dev, sizeof(*ec_spi), GFP_KERNEL);\r\nif (ec_spi == NULL)\r\nreturn -ENOMEM;\r\nec_spi->spi = spi;\r\nec_dev = devm_kzalloc(dev, sizeof(*ec_dev), GFP_KERNEL);\r\nif (!ec_dev)\r\nreturn -ENOMEM;\r\ncros_ec_spi_dt_probe(ec_spi, dev);\r\nspi_set_drvdata(spi, ec_dev);\r\nec_dev->dev = dev;\r\nec_dev->priv = ec_spi;\r\nec_dev->irq = spi->irq;\r\nec_dev->cmd_xfer = cros_ec_cmd_xfer_spi;\r\nec_dev->pkt_xfer = cros_ec_pkt_xfer_spi;\r\nec_dev->phys_name = dev_name(&ec_spi->spi->dev);\r\nec_dev->din_size = EC_MSG_PREAMBLE_COUNT +\r\nsizeof(struct ec_host_response) +\r\nsizeof(struct ec_response_get_protocol_info);\r\nec_dev->dout_size = sizeof(struct ec_host_request);\r\nerr = cros_ec_register(ec_dev);\r\nif (err) {\r\ndev_err(dev, "cannot register EC\n");\r\nreturn err;\r\n}\r\ndevice_init_wakeup(&spi->dev, true);\r\nreturn 0;\r\n}\r\nstatic int cros_ec_spi_remove(struct spi_device *spi)\r\n{\r\nstruct cros_ec_device *ec_dev;\r\nec_dev = spi_get_drvdata(spi);\r\ncros_ec_remove(ec_dev);\r\nreturn 0;\r\n}\r\nstatic int cros_ec_spi_suspend(struct device *dev)\r\n{\r\nstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\r\nreturn cros_ec_suspend(ec_dev);\r\n}\r\nstatic int cros_ec_spi_resume(struct device *dev)\r\n{\r\nstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\r\nreturn cros_ec_resume(ec_dev);\r\n}
