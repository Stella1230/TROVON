static void wacom_notify_battery(struct wacom_wac *wacom_wac,\r\nint bat_capacity, bool bat_charging, bool bat_connected,\r\nbool ps_connected)\r\n{\r\nstruct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);\r\nbool changed = wacom_wac->battery_capacity != bat_capacity ||\r\nwacom_wac->bat_charging != bat_charging ||\r\nwacom_wac->bat_connected != bat_connected ||\r\nwacom_wac->ps_connected != ps_connected;\r\nif (changed) {\r\nwacom_wac->battery_capacity = bat_capacity;\r\nwacom_wac->bat_charging = bat_charging;\r\nwacom_wac->bat_connected = bat_connected;\r\nwacom_wac->ps_connected = ps_connected;\r\nif (wacom->battery)\r\npower_supply_changed(wacom->battery);\r\n}\r\n}\r\nstatic int wacom_penpartner_irq(struct wacom_wac *wacom)\r\n{\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->pen_input;\r\nswitch (data[0]) {\r\ncase 1:\r\nif (data[5] & 0x80) {\r\nwacom->tool[0] = (data[5] & 0x20) ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\r\nwacom->id[0] = (data[5] & 0x20) ? ERASER_DEVICE_ID : STYLUS_DEVICE_ID;\r\ninput_report_key(input, wacom->tool[0], 1);\r\ninput_report_abs(input, ABS_MISC, wacom->id[0]);\r\ninput_report_abs(input, ABS_X, get_unaligned_le16(&data[1]));\r\ninput_report_abs(input, ABS_Y, get_unaligned_le16(&data[3]));\r\ninput_report_abs(input, ABS_PRESSURE, (signed char)data[6] + 127);\r\ninput_report_key(input, BTN_TOUCH, ((signed char)data[6] > -127));\r\ninput_report_key(input, BTN_STYLUS, (data[5] & 0x40));\r\n} else {\r\ninput_report_key(input, wacom->tool[0], 0);\r\ninput_report_abs(input, ABS_MISC, 0);\r\ninput_report_abs(input, ABS_PRESSURE, -1);\r\ninput_report_key(input, BTN_TOUCH, 0);\r\n}\r\nbreak;\r\ncase 2:\r\ninput_report_key(input, BTN_TOOL_PEN, 1);\r\ninput_report_abs(input, ABS_MISC, STYLUS_DEVICE_ID);\r\ninput_report_abs(input, ABS_X, get_unaligned_le16(&data[1]));\r\ninput_report_abs(input, ABS_Y, get_unaligned_le16(&data[3]));\r\ninput_report_abs(input, ABS_PRESSURE, (signed char)data[6] + 127);\r\ninput_report_key(input, BTN_TOUCH, ((signed char)data[6] > -80) && !(data[5] & 0x20));\r\ninput_report_key(input, BTN_STYLUS, (data[5] & 0x40));\r\nbreak;\r\ndefault:\r\ndev_dbg(input->dev.parent,\r\n"%s: received unknown report #%d\n", __func__, data[0]);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int wacom_pl_irq(struct wacom_wac *wacom)\r\n{\r\nstruct wacom_features *features = &wacom->features;\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->pen_input;\r\nint prox, pressure;\r\nif (data[0] != WACOM_REPORT_PENABLED) {\r\ndev_dbg(input->dev.parent,\r\n"%s: received unknown report #%d\n", __func__, data[0]);\r\nreturn 0;\r\n}\r\nprox = data[1] & 0x40;\r\nif (!wacom->id[0]) {\r\nif ((data[0] & 0x10) || (data[4] & 0x20)) {\r\nwacom->tool[0] = BTN_TOOL_RUBBER;\r\nwacom->id[0] = ERASER_DEVICE_ID;\r\n}\r\nelse {\r\nwacom->tool[0] = BTN_TOOL_PEN;\r\nwacom->id[0] = STYLUS_DEVICE_ID;\r\n}\r\n}\r\nif (wacom->tool[0] == BTN_TOOL_RUBBER && !(data[4] & 0x20)) {\r\ninput_report_key(input, BTN_TOOL_RUBBER, 0);\r\ninput_report_abs(input, ABS_MISC, 0);\r\ninput_sync(input);\r\nwacom->tool[0] = BTN_TOOL_PEN;\r\nwacom->id[0] = STYLUS_DEVICE_ID;\r\n}\r\npressure = (signed char)((data[7] << 1) | ((data[4] >> 2) & 1));\r\nif (features->pressure_max > 255)\r\npressure = (pressure << 1) | ((data[4] >> 6) & 1);\r\npressure += (features->pressure_max + 1) / 2;\r\ninput_report_abs(input, ABS_X, data[3] | (data[2] << 7) | ((data[1] & 0x03) << 14));\r\ninput_report_abs(input, ABS_Y, data[6] | (data[5] << 7) | ((data[4] & 0x03) << 14));\r\ninput_report_abs(input, ABS_PRESSURE, pressure);\r\ninput_report_key(input, BTN_TOUCH, data[4] & 0x08);\r\ninput_report_key(input, BTN_STYLUS, data[4] & 0x10);\r\ninput_report_key(input, BTN_STYLUS2, (wacom->tool[0] == BTN_TOOL_PEN) && (data[4] & 0x20));\r\nif (!prox)\r\nwacom->id[0] = 0;\r\ninput_report_key(input, wacom->tool[0], prox);\r\ninput_report_abs(input, ABS_MISC, wacom->id[0]);\r\nreturn 1;\r\n}\r\nstatic int wacom_ptu_irq(struct wacom_wac *wacom)\r\n{\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->pen_input;\r\nif (data[0] != WACOM_REPORT_PENABLED) {\r\ndev_dbg(input->dev.parent,\r\n"%s: received unknown report #%d\n", __func__, data[0]);\r\nreturn 0;\r\n}\r\nif (data[1] & 0x04) {\r\ninput_report_key(input, BTN_TOOL_RUBBER, data[1] & 0x20);\r\ninput_report_key(input, BTN_TOUCH, data[1] & 0x08);\r\nwacom->id[0] = ERASER_DEVICE_ID;\r\n} else {\r\ninput_report_key(input, BTN_TOOL_PEN, data[1] & 0x20);\r\ninput_report_key(input, BTN_TOUCH, data[1] & 0x01);\r\nwacom->id[0] = STYLUS_DEVICE_ID;\r\n}\r\ninput_report_abs(input, ABS_MISC, wacom->id[0]);\r\ninput_report_abs(input, ABS_X, le16_to_cpup((__le16 *)&data[2]));\r\ninput_report_abs(input, ABS_Y, le16_to_cpup((__le16 *)&data[4]));\r\ninput_report_abs(input, ABS_PRESSURE, le16_to_cpup((__le16 *)&data[6]));\r\ninput_report_key(input, BTN_STYLUS, data[1] & 0x02);\r\ninput_report_key(input, BTN_STYLUS2, data[1] & 0x10);\r\nreturn 1;\r\n}\r\nstatic int wacom_dtu_irq(struct wacom_wac *wacom)\r\n{\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->pen_input;\r\nint prox = data[1] & 0x20;\r\ndev_dbg(input->dev.parent,\r\n"%s: received report #%d", __func__, data[0]);\r\nif (prox) {\r\nwacom->tool[0] = (data[1] & 0x0c) ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\r\nif (wacom->tool[0] == BTN_TOOL_PEN)\r\nwacom->id[0] = STYLUS_DEVICE_ID;\r\nelse\r\nwacom->id[0] = ERASER_DEVICE_ID;\r\n}\r\ninput_report_key(input, BTN_STYLUS, data[1] & 0x02);\r\ninput_report_key(input, BTN_STYLUS2, data[1] & 0x10);\r\ninput_report_abs(input, ABS_X, le16_to_cpup((__le16 *)&data[2]));\r\ninput_report_abs(input, ABS_Y, le16_to_cpup((__le16 *)&data[4]));\r\ninput_report_abs(input, ABS_PRESSURE, ((data[7] & 0x01) << 8) | data[6]);\r\ninput_report_key(input, BTN_TOUCH, data[1] & 0x05);\r\nif (!prox)\r\nwacom->id[0] = 0;\r\ninput_report_key(input, wacom->tool[0], prox);\r\ninput_report_abs(input, ABS_MISC, wacom->id[0]);\r\nreturn 1;\r\n}\r\nstatic int wacom_dtus_irq(struct wacom_wac *wacom)\r\n{\r\nchar *data = wacom->data;\r\nstruct input_dev *input = wacom->pen_input;\r\nunsigned short prox, pressure = 0;\r\nif (data[0] != WACOM_REPORT_DTUS && data[0] != WACOM_REPORT_DTUSPAD) {\r\ndev_dbg(input->dev.parent,\r\n"%s: received unknown report #%d", __func__, data[0]);\r\nreturn 0;\r\n} else if (data[0] == WACOM_REPORT_DTUSPAD) {\r\ninput = wacom->pad_input;\r\ninput_report_key(input, BTN_0, (data[1] & 0x01));\r\ninput_report_key(input, BTN_1, (data[1] & 0x02));\r\ninput_report_key(input, BTN_2, (data[1] & 0x04));\r\ninput_report_key(input, BTN_3, (data[1] & 0x08));\r\ninput_report_abs(input, ABS_MISC,\r\ndata[1] & 0x0f ? PAD_DEVICE_ID : 0);\r\nreturn 1;\r\n} else {\r\nprox = data[1] & 0x80;\r\nif (prox) {\r\nswitch ((data[1] >> 3) & 3) {\r\ncase 1:\r\nwacom->tool[0] = BTN_TOOL_RUBBER;\r\nwacom->id[0] = ERASER_DEVICE_ID;\r\nbreak;\r\ncase 2:\r\nwacom->tool[0] = BTN_TOOL_PEN;\r\nwacom->id[0] = STYLUS_DEVICE_ID;\r\nbreak;\r\n}\r\n}\r\ninput_report_key(input, BTN_STYLUS, data[1] & 0x20);\r\ninput_report_key(input, BTN_STYLUS2, data[1] & 0x40);\r\ninput_report_abs(input, ABS_X, get_unaligned_be16(&data[3]));\r\ninput_report_abs(input, ABS_Y, get_unaligned_be16(&data[5]));\r\npressure = ((data[1] & 0x03) << 8) | (data[2] & 0xff);\r\ninput_report_abs(input, ABS_PRESSURE, pressure);\r\ninput_report_key(input, BTN_TOUCH, pressure > 10);\r\nif (!prox)\r\nwacom->id[0] = 0;\r\ninput_report_key(input, wacom->tool[0], prox);\r\ninput_report_abs(input, ABS_MISC, wacom->id[0]);\r\nreturn 1;\r\n}\r\n}\r\nstatic int wacom_graphire_irq(struct wacom_wac *wacom)\r\n{\r\nstruct wacom_features *features = &wacom->features;\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->pen_input;\r\nstruct input_dev *pad_input = wacom->pad_input;\r\nint battery_capacity, ps_connected;\r\nint prox;\r\nint rw = 0;\r\nint retval = 0;\r\nif (features->type == GRAPHIRE_BT) {\r\nif (data[0] != WACOM_REPORT_PENABLED_BT) {\r\ndev_dbg(input->dev.parent,\r\n"%s: received unknown report #%d\n", __func__,\r\ndata[0]);\r\ngoto exit;\r\n}\r\n} else if (data[0] != WACOM_REPORT_PENABLED) {\r\ndev_dbg(input->dev.parent,\r\n"%s: received unknown report #%d\n", __func__, data[0]);\r\ngoto exit;\r\n}\r\nprox = data[1] & 0x80;\r\nif (prox || wacom->id[0]) {\r\nif (prox) {\r\nswitch ((data[1] >> 5) & 3) {\r\ncase 0:\r\nwacom->tool[0] = BTN_TOOL_PEN;\r\nwacom->id[0] = STYLUS_DEVICE_ID;\r\nbreak;\r\ncase 1:\r\nwacom->tool[0] = BTN_TOOL_RUBBER;\r\nwacom->id[0] = ERASER_DEVICE_ID;\r\nbreak;\r\ncase 2:\r\ninput_report_key(input, BTN_MIDDLE, data[1] & 0x04);\r\ncase 3:\r\nwacom->tool[0] = BTN_TOOL_MOUSE;\r\nwacom->id[0] = CURSOR_DEVICE_ID;\r\nbreak;\r\n}\r\n}\r\ninput_report_abs(input, ABS_X, le16_to_cpup((__le16 *)&data[2]));\r\ninput_report_abs(input, ABS_Y, le16_to_cpup((__le16 *)&data[4]));\r\nif (wacom->tool[0] != BTN_TOOL_MOUSE) {\r\nif (features->type == GRAPHIRE_BT)\r\ninput_report_abs(input, ABS_PRESSURE, data[6] |\r\n(((__u16) (data[1] & 0x08)) << 5));\r\nelse\r\ninput_report_abs(input, ABS_PRESSURE, data[6] |\r\n((data[7] & 0x03) << 8));\r\ninput_report_key(input, BTN_TOUCH, data[1] & 0x01);\r\ninput_report_key(input, BTN_STYLUS, data[1] & 0x02);\r\ninput_report_key(input, BTN_STYLUS2, data[1] & 0x04);\r\n} else {\r\ninput_report_key(input, BTN_LEFT, data[1] & 0x01);\r\ninput_report_key(input, BTN_RIGHT, data[1] & 0x02);\r\nif (features->type == WACOM_G4 ||\r\nfeatures->type == WACOM_MO) {\r\ninput_report_abs(input, ABS_DISTANCE, data[6] & 0x3f);\r\nrw = (data[7] & 0x04) - (data[7] & 0x03);\r\n} else if (features->type == GRAPHIRE_BT) {\r\nrw = 44 - (data[6] >> 2);\r\nrw = clamp_val(rw, 0, 31);\r\ninput_report_abs(input, ABS_DISTANCE, rw);\r\nif (((data[1] >> 5) & 3) == 2) {\r\ninput_report_key(input, BTN_MIDDLE,\r\ndata[1] & 0x04);\r\nrw = (data[6] & 0x01) ? -1 :\r\n(data[6] & 0x02) ? 1 : 0;\r\n} else {\r\nrw = 0;\r\n}\r\n} else {\r\ninput_report_abs(input, ABS_DISTANCE, data[7] & 0x3f);\r\nrw = -(signed char)data[6];\r\n}\r\ninput_report_rel(input, REL_WHEEL, rw);\r\n}\r\nif (!prox)\r\nwacom->id[0] = 0;\r\ninput_report_abs(input, ABS_MISC, wacom->id[0]);\r\ninput_report_key(input, wacom->tool[0], prox);\r\ninput_sync(input);\r\n}\r\nswitch (features->type) {\r\ncase WACOM_G4:\r\nprox = data[7] & 0xf8;\r\nif (prox || wacom->id[1]) {\r\nwacom->id[1] = PAD_DEVICE_ID;\r\ninput_report_key(pad_input, BTN_BACK, (data[7] & 0x40));\r\ninput_report_key(pad_input, BTN_FORWARD, (data[7] & 0x80));\r\nrw = ((data[7] & 0x18) >> 3) - ((data[7] & 0x20) >> 3);\r\ninput_report_rel(pad_input, REL_WHEEL, rw);\r\nif (!prox)\r\nwacom->id[1] = 0;\r\ninput_report_abs(pad_input, ABS_MISC, wacom->id[1]);\r\nretval = 1;\r\n}\r\nbreak;\r\ncase WACOM_MO:\r\nprox = (data[7] & 0xf8) || data[8];\r\nif (prox || wacom->id[1]) {\r\nwacom->id[1] = PAD_DEVICE_ID;\r\ninput_report_key(pad_input, BTN_BACK, (data[7] & 0x08));\r\ninput_report_key(pad_input, BTN_LEFT, (data[7] & 0x20));\r\ninput_report_key(pad_input, BTN_FORWARD, (data[7] & 0x10));\r\ninput_report_key(pad_input, BTN_RIGHT, (data[7] & 0x40));\r\ninput_report_abs(pad_input, ABS_WHEEL, (data[8] & 0x7f));\r\nif (!prox)\r\nwacom->id[1] = 0;\r\ninput_report_abs(pad_input, ABS_MISC, wacom->id[1]);\r\nretval = 1;\r\n}\r\nbreak;\r\ncase GRAPHIRE_BT:\r\nprox = data[7] & 0x03;\r\nif (prox || wacom->id[1]) {\r\nwacom->id[1] = PAD_DEVICE_ID;\r\ninput_report_key(pad_input, BTN_0, (data[7] & 0x02));\r\ninput_report_key(pad_input, BTN_1, (data[7] & 0x01));\r\nif (!prox)\r\nwacom->id[1] = 0;\r\ninput_report_abs(pad_input, ABS_MISC, wacom->id[1]);\r\nretval = 1;\r\n}\r\nbreak;\r\n}\r\nif (features->type == GRAPHIRE_BT) {\r\nrw = (data[7] >> 2 & 0x07);\r\nbattery_capacity = batcap_gr[rw];\r\nps_connected = rw == 7;\r\nwacom_notify_battery(wacom, battery_capacity, ps_connected,\r\n1, ps_connected);\r\n}\r\nexit:\r\nreturn retval;\r\n}\r\nstatic void wacom_intuos_schedule_prox_event(struct wacom_wac *wacom_wac)\r\n{\r\nstruct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);\r\nstruct wacom_features *features = &wacom_wac->features;\r\nstruct hid_report *r;\r\nstruct hid_report_enum *re;\r\nre = &(wacom->hdev->report_enum[HID_FEATURE_REPORT]);\r\nif (features->type == INTUOSHT2)\r\nr = re->report_id_hash[WACOM_REPORT_INTUOSHT2_ID];\r\nelse\r\nr = re->report_id_hash[WACOM_REPORT_INTUOS_ID1];\r\nif (r) {\r\nhid_hw_request(wacom->hdev, r, HID_REQ_GET_REPORT);\r\n}\r\n}\r\nstatic int wacom_intuos_pad(struct wacom_wac *wacom)\r\n{\r\nstruct wacom_features *features = &wacom->features;\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->pad_input;\r\nint i;\r\nint buttons = 0, nbuttons = features->numbered_buttons;\r\nint keys = 0, nkeys = 0;\r\nint ring1 = 0, ring2 = 0;\r\nint strip1 = 0, strip2 = 0;\r\nbool prox = false;\r\nif (!(data[0] == WACOM_REPORT_INTUOSPAD || data[0] == WACOM_REPORT_INTUOS5PAD ||\r\ndata[0] == WACOM_REPORT_CINTIQPAD))\r\nreturn 0;\r\nif (features->type >= INTUOS4S && features->type <= INTUOS4L) {\r\nbuttons = (data[3] << 1) | (data[2] & 0x01);\r\nring1 = data[1];\r\n} else if (features->type == DTK) {\r\nbuttons = data[6];\r\n} else if (features->type == WACOM_13HD) {\r\nbuttons = (data[4] << 1) | (data[3] & 0x01);\r\n} else if (features->type == WACOM_24HD) {\r\nbuttons = (data[8] << 8) | data[6];\r\nring1 = data[1];\r\nring2 = data[2];\r\nnkeys = 3;\r\nkeys = ((data[3] & 0x1C) ? 1<<2 : 0) |\r\n((data[4] & 0xE0) ? 1<<1 : 0) |\r\n((data[4] & 0x07) ? 1<<0 : 0);\r\n} else if (features->type == WACOM_27QHD) {\r\nnkeys = 3;\r\nkeys = data[2] & 0x07;\r\ninput_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[4]));\r\ninput_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[6]));\r\ninput_report_abs(input, ABS_Z, be16_to_cpup((__be16 *)&data[8]));\r\n} else if (features->type == CINTIQ_HYBRID) {\r\nbuttons = (data[4] << 1) | (data[3] & 0x01);\r\n} else if (features->type == CINTIQ_COMPANION_2) {\r\nbuttons = ((data[2] >> 4) << 7) |\r\n((data[1] & 0x04) << 6) |\r\n((data[2] & 0x0F) << 2) |\r\n(data[1] & 0x03);\r\n} else if (features->type >= INTUOS5S && features->type <= INTUOSPL) {\r\nbuttons = (data[4] << 1) | (data[3] & 0x01);\r\nring1 = data[2];\r\n} else {\r\nif (features->type == WACOM_21UX2 || features->type == WACOM_22HD) {\r\nbuttons = (data[8] << 10) | ((data[7] & 0x01) << 9) |\r\n(data[6] << 1) | (data[5] & 0x01);\r\nif (features->type == WACOM_22HD) {\r\nnkeys = 3;\r\nkeys = data[9] & 0x07;\r\n}\r\n} else {\r\nbuttons = ((data[6] & 0x10) << 10) |\r\n((data[5] & 0x10) << 9) |\r\n((data[6] & 0x0F) << 4) |\r\n(data[5] & 0x0F);\r\n}\r\nstrip1 = ((data[1] & 0x1f) << 8) | data[2];\r\nstrip2 = ((data[3] & 0x1f) << 8) | data[4];\r\n}\r\nprox = (buttons & ~(~0 << nbuttons)) | (keys & ~(~0 << nkeys)) |\r\n(ring1 & 0x80) | (ring2 & 0x80) | strip1 | strip2;\r\nwacom_report_numbered_buttons(input, nbuttons, buttons);\r\nfor (i = 0; i < nkeys; i++)\r\ninput_report_key(input, KEY_PROG1 + i, keys & (1 << i));\r\ninput_report_abs(input, ABS_RX, strip1);\r\ninput_report_abs(input, ABS_RY, strip2);\r\ninput_report_abs(input, ABS_WHEEL, (ring1 & 0x80) ? (ring1 & 0x7f) : 0);\r\ninput_report_abs(input, ABS_THROTTLE, (ring2 & 0x80) ? (ring2 & 0x7f) : 0);\r\ninput_report_key(input, wacom->tool[1], prox ? 1 : 0);\r\ninput_report_abs(input, ABS_MISC, prox ? PAD_DEVICE_ID : 0);\r\ninput_event(input, EV_MSC, MSC_SERIAL, 0xffffffff);\r\nreturn 1;\r\n}\r\nstatic int wacom_intuos_get_tool_type(int tool_id)\r\n{\r\nint tool_type;\r\nswitch (tool_id) {\r\ncase 0x812:\r\ncase 0x801:\r\ncase 0x120802:\r\ncase 0x012:\r\ntool_type = BTN_TOOL_PENCIL;\r\nbreak;\r\ncase 0x822:\r\ncase 0x842:\r\ncase 0x852:\r\ncase 0x823:\r\ncase 0x813:\r\ncase 0x885:\r\ncase 0x802:\r\ncase 0x804:\r\ncase 0x8e2:\r\ncase 0x022:\r\ncase 0x100804:\r\ncase 0x140802:\r\ncase 0x160802:\r\ncase 0x180802:\r\ncase 0x100802:\r\ntool_type = BTN_TOOL_PEN;\r\nbreak;\r\ncase 0x832:\r\ncase 0x032:\r\ntool_type = BTN_TOOL_BRUSH;\r\nbreak;\r\ncase 0x007:\r\ncase 0x09c:\r\ncase 0x094:\r\ncase 0x017:\r\ncase 0x806:\r\ntool_type = BTN_TOOL_MOUSE;\r\nbreak;\r\ncase 0x096:\r\ncase 0x097:\r\ncase 0x006:\r\ntool_type = BTN_TOOL_LENS;\r\nbreak;\r\ncase 0x82a:\r\ncase 0x85a:\r\ncase 0x91a:\r\ncase 0xd1a:\r\ncase 0x0fa:\r\ncase 0x82b:\r\ncase 0x81b:\r\ncase 0x91b:\r\ncase 0x80c:\r\ncase 0x80a:\r\ncase 0x90a:\r\ncase 0x14080a:\r\ncase 0x10090a:\r\ncase 0x10080c:\r\ncase 0x16080a:\r\ncase 0x18080a:\r\ncase 0x10080a:\r\ntool_type = BTN_TOOL_RUBBER;\r\nbreak;\r\ncase 0xd12:\r\ncase 0x912:\r\ncase 0x112:\r\ncase 0x913:\r\ncase 0x902:\r\ncase 0x100902:\r\ntool_type = BTN_TOOL_AIRBRUSH;\r\nbreak;\r\ndefault:\r\ntool_type = BTN_TOOL_PEN;\r\nbreak;\r\n}\r\nreturn tool_type;\r\n}\r\nstatic int wacom_intuos_inout(struct wacom_wac *wacom)\r\n{\r\nstruct wacom_features *features = &wacom->features;\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->pen_input;\r\nint idx = (features->type == INTUOS) ? (data[1] & 0x01) : 0;\r\nif (!(((data[1] & 0xfc) == 0xc0) ||\r\n((data[1] & 0xfe) == 0x20) ||\r\n((data[1] & 0xfe) == 0x80)))\r\nreturn 0;\r\nif ((data[1] & 0xfc) == 0xc0) {\r\nwacom->serial[idx] = ((data[3] & 0x0f) << 28) +\r\n(data[4] << 20) + (data[5] << 12) +\r\n(data[6] << 4) + (data[7] >> 4);\r\nwacom->id[idx] = (data[2] << 4) | (data[3] >> 4) |\r\n((data[7] & 0x0f) << 20) | ((data[8] & 0xf0) << 12);\r\nwacom->tool[idx] = wacom_intuos_get_tool_type(wacom->id[idx]);\r\nwacom->shared->stylus_in_proximity = true;\r\nreturn 1;\r\n}\r\nif ((data[1] & 0xfe) == 0x20) {\r\nif (features->type != INTUOSHT2)\r\nwacom->shared->stylus_in_proximity = true;\r\nif (wacom->reporting_data) {\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_report_abs(input, ABS_PRESSURE, 0);\r\ninput_report_abs(input, ABS_DISTANCE, wacom->features.distance_max);\r\nreturn 2;\r\n}\r\nreturn 1;\r\n}\r\nif ((data[1] & 0xfe) == 0x80) {\r\nwacom->shared->stylus_in_proximity = false;\r\nwacom->reporting_data = false;\r\nif (!wacom->id[idx])\r\nreturn 1;\r\ninput_report_abs(input, ABS_X, 0);\r\ninput_report_abs(input, ABS_Y, 0);\r\ninput_report_abs(input, ABS_DISTANCE, 0);\r\ninput_report_abs(input, ABS_TILT_X, 0);\r\ninput_report_abs(input, ABS_TILT_Y, 0);\r\nif (wacom->tool[idx] >= BTN_TOOL_MOUSE) {\r\ninput_report_key(input, BTN_LEFT, 0);\r\ninput_report_key(input, BTN_MIDDLE, 0);\r\ninput_report_key(input, BTN_RIGHT, 0);\r\ninput_report_key(input, BTN_SIDE, 0);\r\ninput_report_key(input, BTN_EXTRA, 0);\r\ninput_report_abs(input, ABS_THROTTLE, 0);\r\ninput_report_abs(input, ABS_RZ, 0);\r\n} else {\r\ninput_report_abs(input, ABS_PRESSURE, 0);\r\ninput_report_key(input, BTN_STYLUS, 0);\r\ninput_report_key(input, BTN_STYLUS2, 0);\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_report_abs(input, ABS_WHEEL, 0);\r\nif (features->type >= INTUOS3S)\r\ninput_report_abs(input, ABS_Z, 0);\r\n}\r\ninput_report_key(input, wacom->tool[idx], 0);\r\ninput_report_abs(input, ABS_MISC, 0);\r\ninput_event(input, EV_MSC, MSC_SERIAL, wacom->serial[idx]);\r\nwacom->id[idx] = 0;\r\nreturn 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wacom_remote_irq(struct wacom_wac *wacom_wac, size_t len)\r\n{\r\nunsigned char *data = wacom_wac->data;\r\nstruct input_dev *input = wacom_wac->pad_input;\r\nstruct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);\r\nstruct wacom_features *features = &wacom_wac->features;\r\nint bat_charging, bat_percent, touch_ring_mode;\r\n__u32 serial;\r\nint i;\r\nif (data[0] != WACOM_REPORT_REMOTE) {\r\ndev_dbg(input->dev.parent,\r\n"%s: received unknown report #%d", __func__, data[0]);\r\nreturn 0;\r\n}\r\nserial = data[3] + (data[4] << 8) + (data[5] << 16);\r\nwacom_wac->id[0] = PAD_DEVICE_ID;\r\ninput_report_key(input, BTN_0, (data[9] & 0x01));\r\ninput_report_key(input, BTN_1, (data[9] & 0x02));\r\ninput_report_key(input, BTN_2, (data[9] & 0x04));\r\ninput_report_key(input, BTN_3, (data[9] & 0x08));\r\ninput_report_key(input, BTN_4, (data[9] & 0x10));\r\ninput_report_key(input, BTN_5, (data[9] & 0x20));\r\ninput_report_key(input, BTN_6, (data[9] & 0x40));\r\ninput_report_key(input, BTN_7, (data[9] & 0x80));\r\ninput_report_key(input, BTN_8, (data[10] & 0x01));\r\ninput_report_key(input, BTN_9, (data[10] & 0x02));\r\ninput_report_key(input, BTN_A, (data[10] & 0x04));\r\ninput_report_key(input, BTN_B, (data[10] & 0x08));\r\ninput_report_key(input, BTN_C, (data[10] & 0x10));\r\ninput_report_key(input, BTN_X, (data[10] & 0x20));\r\ninput_report_key(input, BTN_Y, (data[10] & 0x40));\r\ninput_report_key(input, BTN_Z, (data[10] & 0x80));\r\ninput_report_key(input, BTN_BASE, (data[11] & 0x01));\r\ninput_report_key(input, BTN_BASE2, (data[11] & 0x02));\r\nif (data[12] & 0x80)\r\ninput_report_abs(input, ABS_WHEEL, (data[12] & 0x7f));\r\nelse\r\ninput_report_abs(input, ABS_WHEEL, 0);\r\nbat_percent = data[7] & 0x7f;\r\nbat_charging = !!(data[7] & 0x80);\r\nif (data[9] | data[10] | (data[11] & 0x03) | data[12])\r\ninput_report_abs(input, ABS_MISC, PAD_DEVICE_ID);\r\nelse\r\ninput_report_abs(input, ABS_MISC, 0);\r\ninput_event(input, EV_MSC, MSC_SERIAL, serial);\r\ntouch_ring_mode = (data[11] & 0xC0) >> 6;\r\nfor (i = 0; i < WACOM_MAX_REMOTES; i++) {\r\nif (wacom_wac->serial[i] == serial)\r\nwacom->led.select[i] = touch_ring_mode;\r\n}\r\nif (!wacom->battery &&\r\n!(features->quirks & WACOM_QUIRK_BATTERY)) {\r\nfeatures->quirks |= WACOM_QUIRK_BATTERY;\r\nINIT_WORK(&wacom->work, wacom_battery_work);\r\nwacom_schedule_work(wacom_wac);\r\n}\r\nwacom_notify_battery(wacom_wac, bat_percent, bat_charging, 1,\r\nbat_charging);\r\nreturn 1;\r\n}\r\nstatic int wacom_remote_status_irq(struct wacom_wac *wacom_wac, size_t len)\r\n{\r\nstruct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);\r\nunsigned char *data = wacom_wac->data;\r\nint i;\r\nif (data[0] != WACOM_REPORT_DEVICE_LIST)\r\nreturn 0;\r\nfor (i = 0; i < WACOM_MAX_REMOTES; i++) {\r\nint j = i * 6;\r\nint serial = (data[j+6] << 16) + (data[j+5] << 8) + data[j+4];\r\nbool connected = data[j+2];\r\nif (connected) {\r\nint k;\r\nif (wacom_wac->serial[i] == serial)\r\ncontinue;\r\nif (wacom_wac->serial[i]) {\r\nwacom_remote_destroy_attr_group(wacom,\r\nwacom_wac->serial[i]);\r\n}\r\nfor (k = 0; k < WACOM_MAX_REMOTES; k++) {\r\nif (wacom_wac->serial[k] == serial)\r\nbreak;\r\n}\r\nif (k < WACOM_MAX_REMOTES) {\r\nwacom_wac->serial[i] = serial;\r\ncontinue;\r\n}\r\nwacom_remote_create_attr_group(wacom, serial, i);\r\n} else if (wacom_wac->serial[i]) {\r\nwacom_remote_destroy_attr_group(wacom,\r\nwacom_wac->serial[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int wacom_intuos_general(struct wacom_wac *wacom)\r\n{\r\nstruct wacom_features *features = &wacom->features;\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->pen_input;\r\nint idx = (features->type == INTUOS) ? (data[1] & 0x01) : 0;\r\nunsigned char type = (data[1] >> 1) & 0x0F;\r\nunsigned int x, y, distance, t;\r\nif (data[0] != WACOM_REPORT_PENABLED && data[0] != WACOM_REPORT_CINTIQ &&\r\ndata[0] != WACOM_REPORT_INTUOS_PEN)\r\nreturn 0;\r\nif (wacom->shared->touch_down)\r\nreturn 1;\r\nif (!wacom->id[idx]) {\r\nwacom_intuos_schedule_prox_event(wacom);\r\nreturn 1;\r\n}\r\nif ((!((wacom->id[idx] >> 20) & 0x01) &&\r\n(features->type == WACOM_21UX2)) ||\r\n(wacom->tool[idx] == BTN_TOOL_LENS &&\r\n(features->type == INTUOS3 ||\r\nfeatures->type == INTUOS3S ||\r\nfeatures->type == INTUOS4 ||\r\nfeatures->type == INTUOS4S ||\r\nfeatures->type == INTUOS5 ||\r\nfeatures->type == INTUOS5S ||\r\nfeatures->type == INTUOSPM ||\r\nfeatures->type == INTUOSPS)) ||\r\n(features->type == CINTIQ && !(data[1] & 0x40)))\r\nreturn 1;\r\nx = (be16_to_cpup((__be16 *)&data[2]) << 1) | ((data[9] >> 1) & 1);\r\ny = (be16_to_cpup((__be16 *)&data[4]) << 1) | (data[9] & 1);\r\ndistance = data[9] >> 2;\r\nif (features->type < INTUOS3S) {\r\nx >>= 1;\r\ny >>= 1;\r\ndistance >>= 1;\r\n}\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\ninput_report_abs(input, ABS_DISTANCE, distance);\r\nswitch (type) {\r\ncase 0x00:\r\ncase 0x01:\r\ncase 0x02:\r\ncase 0x03:\r\nt = (data[6] << 3) | ((data[7] & 0xC0) >> 5) | (data[1] & 1);\r\nif (features->pressure_max < 2047)\r\nt >>= 1;\r\ninput_report_abs(input, ABS_PRESSURE, t);\r\nif (features->type != INTUOSHT2) {\r\ninput_report_abs(input, ABS_TILT_X,\r\n(((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);\r\ninput_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);\r\n}\r\ninput_report_key(input, BTN_STYLUS, data[1] & 2);\r\ninput_report_key(input, BTN_STYLUS2, data[1] & 4);\r\ninput_report_key(input, BTN_TOUCH, t > 10);\r\nbreak;\r\ncase 0x0a:\r\ninput_report_abs(input, ABS_WHEEL,\r\n(data[6] << 2) | ((data[7] >> 6) & 3));\r\ninput_report_abs(input, ABS_TILT_X,\r\n(((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);\r\ninput_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);\r\nbreak;\r\ncase 0x05:\r\nif (features->type >= INTUOS3S) {\r\nt = (data[6] << 3) | ((data[7] >> 5) & 7);\r\nt = (data[7] & 0x20) ? ((t > 900) ? ((t-1) / 2 - 1350) :\r\n((t-1) / 2 + 450)) : (450 - t / 2) ;\r\ninput_report_abs(input, ABS_Z, t);\r\n} else {\r\nt = (data[6] << 3) | ((data[7] >> 5) & 7);\r\ninput_report_abs(input, ABS_RZ, (data[7] & 0x20) ?\r\n((t - 1) / 2) : -t / 2);\r\n}\r\nbreak;\r\ncase 0x04:\r\ninput_report_key(input, BTN_LEFT, data[8] & 0x01);\r\ninput_report_key(input, BTN_MIDDLE, data[8] & 0x02);\r\ninput_report_key(input, BTN_RIGHT, data[8] & 0x04);\r\ninput_report_key(input, BTN_SIDE, data[8] & 0x20);\r\ninput_report_key(input, BTN_EXTRA, data[8] & 0x10);\r\nt = (data[6] << 2) | ((data[7] >> 6) & 3);\r\ninput_report_abs(input, ABS_THROTTLE, (data[8] & 0x08) ? -t : t);\r\nbreak;\r\ncase 0x06:\r\ninput_report_key(input, BTN_LEFT, data[6] & 0x01);\r\ninput_report_key(input, BTN_MIDDLE, data[6] & 0x02);\r\ninput_report_key(input, BTN_RIGHT, data[6] & 0x04);\r\ninput_report_rel(input, REL_WHEEL, ((data[7] & 0x80) >> 7)\r\n- ((data[7] & 0x40) >> 6));\r\ninput_report_key(input, BTN_SIDE, data[6] & 0x08);\r\ninput_report_key(input, BTN_EXTRA, data[6] & 0x10);\r\ninput_report_abs(input, ABS_TILT_X,\r\n(((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);\r\ninput_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);\r\nbreak;\r\ncase 0x08:\r\nif (wacom->tool[idx] == BTN_TOOL_MOUSE) {\r\ninput_report_key(input, BTN_LEFT, data[8] & 0x04);\r\ninput_report_key(input, BTN_MIDDLE, data[8] & 0x08);\r\ninput_report_key(input, BTN_RIGHT, data[8] & 0x10);\r\ninput_report_rel(input, REL_WHEEL, (data[8] & 0x01)\r\n- ((data[8] & 0x02) >> 1));\r\nif (features->type >= INTUOS3S && features->type <= INTUOS3L) {\r\ninput_report_key(input, BTN_SIDE, data[8] & 0x40);\r\ninput_report_key(input, BTN_EXTRA, data[8] & 0x20);\r\n}\r\n}\r\nelse if (wacom->tool[idx] == BTN_TOOL_LENS) {\r\ninput_report_key(input, BTN_LEFT, data[8] & 0x01);\r\ninput_report_key(input, BTN_MIDDLE, data[8] & 0x02);\r\ninput_report_key(input, BTN_RIGHT, data[8] & 0x04);\r\ninput_report_key(input, BTN_SIDE, data[8] & 0x10);\r\ninput_report_key(input, BTN_EXTRA, data[8] & 0x08);\r\n}\r\nbreak;\r\ncase 0x07:\r\ncase 0x09:\r\ncase 0x0b:\r\ncase 0x0c:\r\ncase 0x0d:\r\ncase 0x0e:\r\ncase 0x0f:\r\nbreak;\r\n}\r\ninput_report_abs(input, ABS_MISC, wacom->id[idx]);\r\ninput_report_key(input, wacom->tool[idx], 1);\r\ninput_event(input, EV_MSC, MSC_SERIAL, wacom->serial[idx]);\r\nwacom->reporting_data = true;\r\nreturn 2;\r\n}\r\nstatic int wacom_intuos_irq(struct wacom_wac *wacom)\r\n{\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->pen_input;\r\nint result;\r\nif (data[0] != WACOM_REPORT_PENABLED &&\r\ndata[0] != WACOM_REPORT_INTUOS_ID1 &&\r\ndata[0] != WACOM_REPORT_INTUOS_ID2 &&\r\ndata[0] != WACOM_REPORT_INTUOSPAD &&\r\ndata[0] != WACOM_REPORT_INTUOS_PEN &&\r\ndata[0] != WACOM_REPORT_CINTIQ &&\r\ndata[0] != WACOM_REPORT_CINTIQPAD &&\r\ndata[0] != WACOM_REPORT_INTUOS5PAD) {\r\ndev_dbg(input->dev.parent,\r\n"%s: received unknown report #%d\n", __func__, data[0]);\r\nreturn 0;\r\n}\r\nresult = wacom_intuos_pad(wacom);\r\nif (result)\r\nreturn result;\r\nresult = wacom_intuos_inout(wacom);\r\nif (result)\r\nreturn result - 1;\r\nresult = wacom_intuos_general(wacom);\r\nif (result)\r\nreturn result - 1;\r\nreturn 0;\r\n}\r\nstatic int int_dist(int x1, int y1, int x2, int y2)\r\n{\r\nint x = x2 - x1;\r\nint y = y2 - y1;\r\nreturn int_sqrt(x*x + y*y);\r\n}\r\nstatic void wacom_intuos_bt_process_data(struct wacom_wac *wacom,\r\nunsigned char *data)\r\n{\r\nmemcpy(wacom->data, data, 10);\r\nwacom_intuos_irq(wacom);\r\ninput_sync(wacom->pen_input);\r\nif (wacom->pad_input)\r\ninput_sync(wacom->pad_input);\r\n}\r\nstatic int wacom_intuos_bt_irq(struct wacom_wac *wacom, size_t len)\r\n{\r\nunsigned char data[WACOM_PKGLEN_MAX];\r\nint i = 1;\r\nunsigned power_raw, battery_capacity, bat_charging, ps_connected;\r\nmemcpy(data, wacom->data, len);\r\nswitch (data[0]) {\r\ncase 0x04:\r\nwacom_intuos_bt_process_data(wacom, data + i);\r\ni += 10;\r\ncase 0x03:\r\nwacom_intuos_bt_process_data(wacom, data + i);\r\ni += 10;\r\nwacom_intuos_bt_process_data(wacom, data + i);\r\ni += 10;\r\npower_raw = data[i];\r\nbat_charging = (power_raw & 0x08) ? 1 : 0;\r\nps_connected = (power_raw & 0x10) ? 1 : 0;\r\nbattery_capacity = batcap_i4[power_raw & 0x07];\r\nwacom_notify_battery(wacom, battery_capacity, bat_charging,\r\nbattery_capacity || bat_charging,\r\nps_connected);\r\nbreak;\r\ndefault:\r\ndev_dbg(wacom->pen_input->dev.parent,\r\n"Unknown report: %d,%d size:%zu\n",\r\ndata[0], data[1], len);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wacom_wac_finger_count_touches(struct wacom_wac *wacom)\r\n{\r\nstruct input_dev *input = wacom->touch_input;\r\nunsigned touch_max = wacom->features.touch_max;\r\nint count = 0;\r\nint i;\r\nif (!touch_max)\r\nreturn 0;\r\nif (touch_max == 1)\r\nreturn test_bit(BTN_TOUCH, input->key) &&\r\n!wacom->shared->stylus_in_proximity;\r\nfor (i = 0; i < input->mt->num_slots; i++) {\r\nstruct input_mt_slot *ps = &input->mt->slots[i];\r\nint id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);\r\nif (id >= 0)\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic int wacom_24hdt_irq(struct wacom_wac *wacom)\r\n{\r\nstruct input_dev *input = wacom->touch_input;\r\nunsigned char *data = wacom->data;\r\nint i;\r\nint current_num_contacts = data[61];\r\nint contacts_to_send = 0;\r\nint num_contacts_left = 4;\r\nint byte_per_packet = WACOM_BYTES_PER_24HDT_PACKET;\r\nint y_offset = 2;\r\nif (wacom->features.type == WACOM_27QHDT) {\r\ncurrent_num_contacts = data[63];\r\nnum_contacts_left = 10;\r\nbyte_per_packet = WACOM_BYTES_PER_QHDTHID_PACKET;\r\ny_offset = 0;\r\n}\r\nif (current_num_contacts)\r\nwacom->num_contacts_left = current_num_contacts;\r\ncontacts_to_send = min(num_contacts_left, wacom->num_contacts_left);\r\nfor (i = 0; i < contacts_to_send; i++) {\r\nint offset = (byte_per_packet * i) + 1;\r\nbool touch = (data[offset] & 0x1) && !wacom->shared->stylus_in_proximity;\r\nint slot = input_mt_get_slot_by_key(input, data[offset + 1]);\r\nif (slot < 0)\r\ncontinue;\r\ninput_mt_slot(input, slot);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\r\nif (touch) {\r\nint t_x = get_unaligned_le16(&data[offset + 2]);\r\nint t_y = get_unaligned_le16(&data[offset + 4 + y_offset]);\r\ninput_report_abs(input, ABS_MT_POSITION_X, t_x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, t_y);\r\nif (wacom->features.type != WACOM_27QHDT) {\r\nint c_x = get_unaligned_le16(&data[offset + 4]);\r\nint c_y = get_unaligned_le16(&data[offset + 8]);\r\nint w = get_unaligned_le16(&data[offset + 10]);\r\nint h = get_unaligned_le16(&data[offset + 12]);\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR, min(w,h));\r\ninput_report_abs(input, ABS_MT_WIDTH_MAJOR,\r\nmin(w, h) + int_dist(t_x, t_y, c_x, c_y));\r\ninput_report_abs(input, ABS_MT_WIDTH_MINOR, min(w, h));\r\ninput_report_abs(input, ABS_MT_ORIENTATION, w > h);\r\n}\r\n}\r\n}\r\ninput_mt_sync_frame(input);\r\nwacom->num_contacts_left -= contacts_to_send;\r\nif (wacom->num_contacts_left <= 0) {\r\nwacom->num_contacts_left = 0;\r\nwacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\r\n}\r\nreturn 1;\r\n}\r\nstatic int wacom_mt_touch(struct wacom_wac *wacom)\r\n{\r\nstruct input_dev *input = wacom->touch_input;\r\nunsigned char *data = wacom->data;\r\nint i;\r\nint current_num_contacts = data[2];\r\nint contacts_to_send = 0;\r\nint x_offset = 0;\r\nif (wacom->features.type == MTTPC || wacom->features.type == MTTPC_B)\r\nx_offset = -4;\r\nif (current_num_contacts)\r\nwacom->num_contacts_left = current_num_contacts;\r\ncontacts_to_send = min(5, wacom->num_contacts_left);\r\nfor (i = 0; i < contacts_to_send; i++) {\r\nint offset = (WACOM_BYTES_PER_MT_PACKET + x_offset) * i + 3;\r\nbool touch = (data[offset] & 0x1) && !wacom->shared->stylus_in_proximity;\r\nint id = get_unaligned_le16(&data[offset + 1]);\r\nint slot = input_mt_get_slot_by_key(input, id);\r\nif (slot < 0)\r\ncontinue;\r\ninput_mt_slot(input, slot);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\r\nif (touch) {\r\nint x = get_unaligned_le16(&data[offset + x_offset + 7]);\r\nint y = get_unaligned_le16(&data[offset + x_offset + 9]);\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\n}\r\n}\r\ninput_mt_sync_frame(input);\r\nwacom->num_contacts_left -= contacts_to_send;\r\nif (wacom->num_contacts_left <= 0) {\r\nwacom->num_contacts_left = 0;\r\nwacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\r\n}\r\nreturn 1;\r\n}\r\nstatic int wacom_tpc_mt_touch(struct wacom_wac *wacom)\r\n{\r\nstruct input_dev *input = wacom->touch_input;\r\nunsigned char *data = wacom->data;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nint p = data[1] & (1 << i);\r\nbool touch = p && !wacom->shared->stylus_in_proximity;\r\ninput_mt_slot(input, i);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\r\nif (touch) {\r\nint x = le16_to_cpup((__le16 *)&data[i * 2 + 2]) & 0x7fff;\r\nint y = le16_to_cpup((__le16 *)&data[i * 2 + 6]) & 0x7fff;\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\n}\r\n}\r\ninput_mt_sync_frame(input);\r\nwacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\r\nreturn 1;\r\n}\r\nstatic int wacom_tpc_single_touch(struct wacom_wac *wacom, size_t len)\r\n{\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->touch_input;\r\nbool prox = !wacom->shared->stylus_in_proximity;\r\nint x = 0, y = 0;\r\nif (wacom->features.touch_max > 1 || len > WACOM_PKGLEN_TPC2FG)\r\nreturn 0;\r\nif (len == WACOM_PKGLEN_TPC1FG) {\r\nprox = prox && (data[0] & 0x01);\r\nx = get_unaligned_le16(&data[1]);\r\ny = get_unaligned_le16(&data[3]);\r\n} else if (len == WACOM_PKGLEN_TPC1FG_B) {\r\nprox = prox && (data[2] & 0x01);\r\nx = get_unaligned_le16(&data[3]);\r\ny = get_unaligned_le16(&data[5]);\r\n} else {\r\nprox = prox && (data[1] & 0x01);\r\nx = le16_to_cpup((__le16 *)&data[2]);\r\ny = le16_to_cpup((__le16 *)&data[4]);\r\n}\r\nif (prox) {\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\n}\r\ninput_report_key(input, BTN_TOUCH, prox);\r\nwacom->shared->touch_down = prox;\r\nreturn 1;\r\n}\r\nstatic int wacom_tpc_pen(struct wacom_wac *wacom)\r\n{\r\nunsigned char *data = wacom->data;\r\nstruct input_dev *input = wacom->pen_input;\r\nbool prox = data[1] & 0x20;\r\nif (!wacom->shared->stylus_in_proximity)\r\nwacom->tool[0] = (data[1] & 0x0c) ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\r\nwacom->shared->stylus_in_proximity = prox;\r\nif (!wacom->shared->touch_down) {\r\ninput_report_key(input, BTN_STYLUS, data[1] & 0x02);\r\ninput_report_key(input, BTN_STYLUS2, data[1] & 0x10);\r\ninput_report_abs(input, ABS_X, le16_to_cpup((__le16 *)&data[2]));\r\ninput_report_abs(input, ABS_Y, le16_to_cpup((__le16 *)&data[4]));\r\ninput_report_abs(input, ABS_PRESSURE, ((data[7] & 0x07) << 8) | data[6]);\r\ninput_report_key(input, BTN_TOUCH, data[1] & 0x05);\r\ninput_report_key(input, wacom->tool[0], prox);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wacom_tpc_irq(struct wacom_wac *wacom, size_t len)\r\n{\r\nunsigned char *data = wacom->data;\r\nif (wacom->pen_input)\r\ndev_dbg(wacom->pen_input->dev.parent,\r\n"%s: received report #%d\n", __func__, data[0]);\r\nelse if (wacom->touch_input)\r\ndev_dbg(wacom->touch_input->dev.parent,\r\n"%s: received report #%d\n", __func__, data[0]);\r\nswitch (len) {\r\ncase WACOM_PKGLEN_TPC1FG:\r\nreturn wacom_tpc_single_touch(wacom, len);\r\ncase WACOM_PKGLEN_TPC2FG:\r\nreturn wacom_tpc_mt_touch(wacom);\r\ncase WACOM_PKGLEN_PENABLED:\r\nreturn wacom_tpc_pen(wacom);\r\ndefault:\r\nswitch (data[0]) {\r\ncase WACOM_REPORT_TPC1FG:\r\ncase WACOM_REPORT_TPCHID:\r\ncase WACOM_REPORT_TPCST:\r\ncase WACOM_REPORT_TPC1FGE:\r\nreturn wacom_tpc_single_touch(wacom, len);\r\ncase WACOM_REPORT_TPCMT:\r\ncase WACOM_REPORT_TPCMT2:\r\nreturn wacom_mt_touch(wacom);\r\ncase WACOM_REPORT_PENABLED:\r\nreturn wacom_tpc_pen(wacom);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void wacom_map_usage(struct input_dev *input, struct hid_usage *usage,\r\nstruct hid_field *field, __u8 type, __u16 code, int fuzz)\r\n{\r\nint fmin = field->logical_minimum;\r\nint fmax = field->logical_maximum;\r\nusage->type = type;\r\nusage->code = code;\r\nset_bit(type, input->evbit);\r\nswitch (type) {\r\ncase EV_ABS:\r\ninput_set_abs_params(input, code, fmin, fmax, fuzz, 0);\r\ninput_abs_set_res(input, code,\r\nhidinput_calc_abs_res(field, code));\r\nbreak;\r\ncase EV_KEY:\r\ninput_set_capability(input, EV_KEY, code);\r\nbreak;\r\ncase EV_MSC:\r\ninput_set_capability(input, EV_MSC, code);\r\nbreak;\r\n}\r\n}\r\nstatic void wacom_wac_pen_usage_mapping(struct hid_device *hdev,\r\nstruct hid_field *field, struct hid_usage *usage)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct input_dev *input = wacom_wac->pen_input;\r\nswitch (usage->hid) {\r\ncase HID_GD_X:\r\nwacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);\r\nbreak;\r\ncase HID_GD_Y:\r\nwacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);\r\nbreak;\r\ncase HID_DG_TIPPRESSURE:\r\nwacom_map_usage(input, usage, field, EV_ABS, ABS_PRESSURE, 0);\r\nbreak;\r\ncase HID_DG_INRANGE:\r\nwacom_map_usage(input, usage, field, EV_KEY, BTN_TOOL_PEN, 0);\r\nbreak;\r\ncase HID_DG_INVERT:\r\nwacom_map_usage(input, usage, field, EV_KEY,\r\nBTN_TOOL_RUBBER, 0);\r\nbreak;\r\ncase HID_DG_ERASER:\r\ncase HID_DG_TIPSWITCH:\r\nwacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);\r\nbreak;\r\ncase HID_DG_BARRELSWITCH:\r\nwacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS, 0);\r\nbreak;\r\ncase HID_DG_BARRELSWITCH2:\r\nwacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS2, 0);\r\nbreak;\r\ncase HID_DG_TOOLSERIALNUMBER:\r\nwacom_map_usage(input, usage, field, EV_MSC, MSC_SERIAL, 0);\r\nbreak;\r\n}\r\n}\r\nstatic int wacom_wac_pen_event(struct hid_device *hdev, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct input_dev *input = wacom_wac->pen_input;\r\nswitch (usage->hid) {\r\ncase HID_DG_INRANGE:\r\nwacom_wac->hid_data.inrange_state = value;\r\nreturn 0;\r\ncase HID_DG_INVERT:\r\nwacom_wac->hid_data.invert_state = value;\r\nreturn 0;\r\ncase HID_DG_ERASER:\r\ncase HID_DG_TIPSWITCH:\r\nwacom_wac->hid_data.tipswitch |= value;\r\nreturn 0;\r\n}\r\nif (!usage->type || wacom_wac->shared->touch_down)\r\nreturn 0;\r\ninput_event(input, usage->type, usage->code, value);\r\nreturn 0;\r\n}\r\nstatic void wacom_wac_pen_pre_report(struct hid_device *hdev,\r\nstruct hid_report *report)\r\n{\r\nreturn;\r\n}\r\nstatic void wacom_wac_pen_report(struct hid_device *hdev,\r\nstruct hid_report *report)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct input_dev *input = wacom_wac->pen_input;\r\nbool prox = wacom_wac->hid_data.inrange_state;\r\nif (!wacom_wac->shared->stylus_in_proximity)\r\nwacom_wac->tool[0] = wacom_wac->hid_data.invert_state ?\r\nBTN_TOOL_RUBBER : BTN_TOOL_PEN;\r\nwacom_wac->shared->stylus_in_proximity = prox;\r\nif (!wacom_wac->shared->touch_down) {\r\ninput_report_key(input, BTN_TOUCH,\r\nwacom_wac->hid_data.tipswitch);\r\ninput_report_key(input, wacom_wac->tool[0], prox);\r\nwacom_wac->hid_data.tipswitch = false;\r\ninput_sync(input);\r\n}\r\n}\r\nstatic void wacom_wac_finger_usage_mapping(struct hid_device *hdev,\r\nstruct hid_field *field, struct hid_usage *usage)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct wacom_features *features = &wacom_wac->features;\r\nstruct input_dev *input = wacom_wac->touch_input;\r\nunsigned touch_max = wacom_wac->features.touch_max;\r\nswitch (usage->hid) {\r\ncase HID_GD_X:\r\nfeatures->last_slot_field = usage->hid;\r\nif (touch_max == 1)\r\nwacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);\r\nelse\r\nwacom_map_usage(input, usage, field, EV_ABS,\r\nABS_MT_POSITION_X, 4);\r\nbreak;\r\ncase HID_GD_Y:\r\nfeatures->last_slot_field = usage->hid;\r\nif (touch_max == 1)\r\nwacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);\r\nelse\r\nwacom_map_usage(input, usage, field, EV_ABS,\r\nABS_MT_POSITION_Y, 4);\r\nbreak;\r\ncase HID_DG_WIDTH:\r\ncase HID_DG_HEIGHT:\r\nfeatures->last_slot_field = usage->hid;\r\nwacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);\r\nwacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MINOR, 0);\r\ninput_set_abs_params(input, ABS_MT_ORIENTATION, 0, 1, 0, 0);\r\nbreak;\r\ncase HID_DG_CONTACTID:\r\nfeatures->last_slot_field = usage->hid;\r\nbreak;\r\ncase HID_DG_INRANGE:\r\nfeatures->last_slot_field = usage->hid;\r\nbreak;\r\ncase HID_DG_INVERT:\r\nfeatures->last_slot_field = usage->hid;\r\nbreak;\r\ncase HID_DG_TIPSWITCH:\r\nfeatures->last_slot_field = usage->hid;\r\nwacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);\r\nbreak;\r\ncase HID_DG_CONTACTCOUNT:\r\nwacom_wac->hid_data.cc_report = field->report->id;\r\nwacom_wac->hid_data.cc_index = field->index;\r\nwacom_wac->hid_data.cc_value_index = usage->usage_index;\r\nbreak;\r\n}\r\n}\r\nstatic void wacom_wac_finger_slot(struct wacom_wac *wacom_wac,\r\nstruct input_dev *input)\r\n{\r\nstruct hid_data *hid_data = &wacom_wac->hid_data;\r\nbool mt = wacom_wac->features.touch_max > 1;\r\nbool prox = hid_data->tipswitch &&\r\n!wacom_wac->shared->stylus_in_proximity;\r\nwacom_wac->hid_data.num_received++;\r\nif (wacom_wac->hid_data.num_received > wacom_wac->hid_data.num_expected)\r\nreturn;\r\nif (mt) {\r\nint slot;\r\nslot = input_mt_get_slot_by_key(input, hid_data->id);\r\ninput_mt_slot(input, slot);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, prox);\r\n}\r\nelse {\r\ninput_report_key(input, BTN_TOUCH, prox);\r\n}\r\nif (prox) {\r\ninput_report_abs(input, mt ? ABS_MT_POSITION_X : ABS_X,\r\nhid_data->x);\r\ninput_report_abs(input, mt ? ABS_MT_POSITION_Y : ABS_Y,\r\nhid_data->y);\r\nif (test_bit(ABS_MT_TOUCH_MAJOR, input->absbit)) {\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR, max(hid_data->width, hid_data->height));\r\ninput_report_abs(input, ABS_MT_TOUCH_MINOR, min(hid_data->width, hid_data->height));\r\nif (hid_data->width != hid_data->height)\r\ninput_report_abs(input, ABS_MT_ORIENTATION, hid_data->width <= hid_data->height ? 0 : 1);\r\n}\r\n}\r\n}\r\nstatic int wacom_wac_finger_event(struct hid_device *hdev,\r\nstruct hid_field *field, struct hid_usage *usage, __s32 value)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nswitch (usage->hid) {\r\ncase HID_GD_X:\r\nwacom_wac->hid_data.x = value;\r\nbreak;\r\ncase HID_GD_Y:\r\nwacom_wac->hid_data.y = value;\r\nbreak;\r\ncase HID_DG_WIDTH:\r\nwacom_wac->hid_data.width = value;\r\nbreak;\r\ncase HID_DG_HEIGHT:\r\nwacom_wac->hid_data.height = value;\r\nbreak;\r\ncase HID_DG_CONTACTID:\r\nwacom_wac->hid_data.id = value;\r\nbreak;\r\ncase HID_DG_TIPSWITCH:\r\nwacom_wac->hid_data.tipswitch = value;\r\nbreak;\r\n}\r\nif (usage->usage_index + 1 == field->report_count) {\r\nif (usage->hid == wacom_wac->features.last_slot_field)\r\nwacom_wac_finger_slot(wacom_wac, wacom_wac->touch_input);\r\n}\r\nreturn 0;\r\n}\r\nstatic void wacom_wac_finger_pre_report(struct hid_device *hdev,\r\nstruct hid_report *report)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct hid_data* hid_data = &wacom_wac->hid_data;\r\nif (hid_data->cc_report != 0 &&\r\nhid_data->cc_report != report->id) {\r\nint i;\r\nhid_data->cc_report = report->id;\r\nhid_data->cc_index = -1;\r\nhid_data->cc_value_index = -1;\r\nfor (i = 0; i < report->maxfield; i++) {\r\nstruct hid_field *field = report->field[i];\r\nint j;\r\nfor (j = 0; j < field->maxusage; j++) {\r\nif (field->usage[j].hid == HID_DG_CONTACTCOUNT) {\r\nhid_data->cc_index = i;\r\nhid_data->cc_value_index = j;\r\ni = report->maxfield;\r\nj = field->maxusage;\r\n}\r\n}\r\n}\r\n}\r\nif (hid_data->cc_report != 0 &&\r\nhid_data->cc_index >= 0) {\r\nstruct hid_field *field = report->field[hid_data->cc_index];\r\nint value = field->value[hid_data->cc_value_index];\r\nif (value)\r\nhid_data->num_expected = value;\r\n}\r\nelse {\r\nhid_data->num_expected = wacom_wac->features.touch_max;\r\n}\r\n}\r\nstatic void wacom_wac_finger_report(struct hid_device *hdev,\r\nstruct hid_report *report)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct input_dev *input = wacom_wac->touch_input;\r\nunsigned touch_max = wacom_wac->features.touch_max;\r\nif (wacom_wac->hid_data.num_received < wacom_wac->hid_data.num_expected)\r\nreturn;\r\nif (touch_max > 1)\r\ninput_mt_sync_frame(input);\r\ninput_sync(input);\r\nwacom_wac->hid_data.num_received = 0;\r\nwacom_wac->shared->touch_down = wacom_wac_finger_count_touches(wacom_wac);\r\n}\r\nvoid wacom_wac_usage_mapping(struct hid_device *hdev,\r\nstruct hid_field *field, struct hid_usage *usage)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\n__set_bit(INPUT_PROP_DIRECT, wacom_wac->pen_input->propbit);\r\n__set_bit(INPUT_PROP_DIRECT, wacom_wac->touch_input->propbit);\r\nif (WACOM_PEN_FIELD(field))\r\nreturn wacom_wac_pen_usage_mapping(hdev, field, usage);\r\nif (WACOM_FINGER_FIELD(field))\r\nreturn wacom_wac_finger_usage_mapping(hdev, field, usage);\r\n}\r\nint wacom_wac_event(struct hid_device *hdev, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nif (wacom->wacom_wac.features.type != HID_GENERIC)\r\nreturn 0;\r\nif (WACOM_PEN_FIELD(field))\r\nreturn wacom_wac_pen_event(hdev, field, usage, value);\r\nif (WACOM_FINGER_FIELD(field))\r\nreturn wacom_wac_finger_event(hdev, field, usage, value);\r\nreturn 0;\r\n}\r\nstatic void wacom_report_events(struct hid_device *hdev, struct hid_report *report)\r\n{\r\nint r;\r\nfor (r = 0; r < report->maxfield; r++) {\r\nstruct hid_field *field;\r\nunsigned count, n;\r\nfield = report->field[r];\r\ncount = field->report_count;\r\nif (!(HID_MAIN_ITEM_VARIABLE & field->flags))\r\ncontinue;\r\nfor (n = 0; n < count; n++)\r\nwacom_wac_event(hdev, field, &field->usage[n], field->value[n]);\r\n}\r\n}\r\nvoid wacom_wac_report(struct hid_device *hdev, struct hid_report *report)\r\n{\r\nstruct wacom *wacom = hid_get_drvdata(hdev);\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct hid_field *field = report->field[0];\r\nif (wacom_wac->features.type != HID_GENERIC)\r\nreturn;\r\nif (WACOM_PEN_FIELD(field))\r\nwacom_wac_pen_pre_report(hdev, report);\r\nif (WACOM_FINGER_FIELD(field))\r\nwacom_wac_finger_pre_report(hdev, report);\r\nwacom_report_events(hdev, report);\r\nif (WACOM_PEN_FIELD(field))\r\nreturn wacom_wac_pen_report(hdev, report);\r\nif (WACOM_FINGER_FIELD(field))\r\nreturn wacom_wac_finger_report(hdev, report);\r\n}\r\nstatic int wacom_bpt_touch(struct wacom_wac *wacom)\r\n{\r\nstruct wacom_features *features = &wacom->features;\r\nstruct input_dev *input = wacom->touch_input;\r\nstruct input_dev *pad_input = wacom->pad_input;\r\nunsigned char *data = wacom->data;\r\nint i;\r\nif (data[0] != 0x02)\r\nreturn 0;\r\nfor (i = 0; i < 2; i++) {\r\nint offset = (data[1] & 0x80) ? (8 * i) : (9 * i);\r\nbool touch = data[offset + 3] & 0x80;\r\ntouch = touch && !wacom->shared->stylus_in_proximity;\r\ninput_mt_slot(input, i);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\r\nif (touch) {\r\nint x = get_unaligned_be16(&data[offset + 3]) & 0x7ff;\r\nint y = get_unaligned_be16(&data[offset + 5]) & 0x7ff;\r\nif (features->quirks & WACOM_QUIRK_BBTOUCH_LOWRES) {\r\nx <<= 5;\r\ny <<= 5;\r\n}\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\n}\r\n}\r\ninput_mt_sync_frame(input);\r\ninput_report_key(pad_input, BTN_LEFT, (data[1] & 0x08) != 0);\r\ninput_report_key(pad_input, BTN_FORWARD, (data[1] & 0x04) != 0);\r\ninput_report_key(pad_input, BTN_BACK, (data[1] & 0x02) != 0);\r\ninput_report_key(pad_input, BTN_RIGHT, (data[1] & 0x01) != 0);\r\nwacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\r\nreturn 1;\r\n}\r\nstatic void wacom_bpt3_touch_msg(struct wacom_wac *wacom, unsigned char *data)\r\n{\r\nstruct wacom_features *features = &wacom->features;\r\nstruct input_dev *input = wacom->touch_input;\r\nbool touch = data[1] & 0x80;\r\nint slot = input_mt_get_slot_by_key(input, data[0]);\r\nif (slot < 0)\r\nreturn;\r\ntouch = touch && !wacom->shared->stylus_in_proximity;\r\ninput_mt_slot(input, slot);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\r\nif (touch) {\r\nint x = (data[2] << 4) | (data[4] >> 4);\r\nint y = (data[3] << 4) | (data[4] & 0x0f);\r\nint width, height;\r\nif (features->type >= INTUOSPS && features->type <= INTUOSHT2) {\r\nwidth = data[5] * 100;\r\nheight = data[6] * 100;\r\n} else {\r\nint a = data[5];\r\nint x_res = input_abs_get_res(input, ABS_MT_POSITION_X);\r\nint y_res = input_abs_get_res(input, ABS_MT_POSITION_Y);\r\nwidth = 2 * int_sqrt(a * WACOM_CONTACT_AREA_SCALE);\r\nheight = width * y_res / x_res;\r\n}\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR, width);\r\ninput_report_abs(input, ABS_MT_TOUCH_MINOR, height);\r\n}\r\n}\r\nstatic void wacom_bpt3_button_msg(struct wacom_wac *wacom, unsigned char *data)\r\n{\r\nstruct input_dev *input = wacom->pad_input;\r\nstruct wacom_features *features = &wacom->features;\r\nif (features->type == INTUOSHT || features->type == INTUOSHT2) {\r\ninput_report_key(input, BTN_LEFT, (data[1] & 0x02) != 0);\r\ninput_report_key(input, BTN_BACK, (data[1] & 0x08) != 0);\r\n} else {\r\ninput_report_key(input, BTN_BACK, (data[1] & 0x02) != 0);\r\ninput_report_key(input, BTN_LEFT, (data[1] & 0x08) != 0);\r\n}\r\ninput_report_key(input, BTN_FORWARD, (data[1] & 0x04) != 0);\r\ninput_report_key(input, BTN_RIGHT, (data[1] & 0x01) != 0);\r\n}\r\nstatic int wacom_bpt3_touch(struct wacom_wac *wacom)\r\n{\r\nunsigned char *data = wacom->data;\r\nint count = data[1] & 0x07;\r\nint touch_changed = 0, i;\r\nif (data[0] != 0x02)\r\nreturn 0;\r\nfor (i = 0; i < count; i++) {\r\nint offset = (8 * i) + 2;\r\nint msg_id = data[offset];\r\nif (msg_id >= 2 && msg_id <= 17) {\r\nwacom_bpt3_touch_msg(wacom, data + offset);\r\ntouch_changed++;\r\n} else if (msg_id == 128)\r\nwacom_bpt3_button_msg(wacom, data + offset);\r\n}\r\nif (wacom->touch_registered && touch_changed) {\r\ninput_mt_sync_frame(wacom->touch_input);\r\nwacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\r\n}\r\nreturn 1;\r\n}\r\nstatic int wacom_bpt_pen(struct wacom_wac *wacom)\r\n{\r\nstruct wacom_features *features = &wacom->features;\r\nstruct input_dev *input = wacom->pen_input;\r\nunsigned char *data = wacom->data;\r\nint prox = 0, x = 0, y = 0, p = 0, d = 0, pen = 0, btn1 = 0, btn2 = 0;\r\nif (data[0] != WACOM_REPORT_PENABLED)\r\nreturn 0;\r\nprox = (data[1] & 0x20) == 0x20;\r\nif (!wacom->shared->stylus_in_proximity) {\r\nif (data[1] & 0x08) {\r\nwacom->tool[0] = BTN_TOOL_RUBBER;\r\nwacom->id[0] = ERASER_DEVICE_ID;\r\n} else {\r\nwacom->tool[0] = BTN_TOOL_PEN;\r\nwacom->id[0] = STYLUS_DEVICE_ID;\r\n}\r\n}\r\nwacom->shared->stylus_in_proximity = prox;\r\nif (wacom->shared->touch_down)\r\nreturn 0;\r\nif (prox) {\r\nx = le16_to_cpup((__le16 *)&data[2]);\r\ny = le16_to_cpup((__le16 *)&data[4]);\r\np = le16_to_cpup((__le16 *)&data[6]);\r\nif (data[8] <= features->distance_max)\r\nd = features->distance_max - data[8];\r\npen = data[1] & 0x01;\r\nbtn1 = data[1] & 0x02;\r\nbtn2 = data[1] & 0x04;\r\n} else {\r\nwacom->id[0] = 0;\r\n}\r\ninput_report_key(input, BTN_TOUCH, pen);\r\ninput_report_key(input, BTN_STYLUS, btn1);\r\ninput_report_key(input, BTN_STYLUS2, btn2);\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\ninput_report_abs(input, ABS_PRESSURE, p);\r\ninput_report_abs(input, ABS_DISTANCE, d);\r\ninput_report_key(input, wacom->tool[0], prox);\r\ninput_report_abs(input, ABS_MISC, wacom->id[0]);\r\nreturn 1;\r\n}\r\nstatic int wacom_bpt_irq(struct wacom_wac *wacom, size_t len)\r\n{\r\nstruct wacom_features *features = &wacom->features;\r\nif ((features->type == INTUOSHT2) &&\r\n(features->device_type & WACOM_DEVICETYPE_PEN))\r\nreturn wacom_intuos_irq(wacom);\r\nelse if (len == WACOM_PKGLEN_BBTOUCH)\r\nreturn wacom_bpt_touch(wacom);\r\nelse if (len == WACOM_PKGLEN_BBTOUCH3)\r\nreturn wacom_bpt3_touch(wacom);\r\nelse if (len == WACOM_PKGLEN_BBFUN || len == WACOM_PKGLEN_BBPEN)\r\nreturn wacom_bpt_pen(wacom);\r\nreturn 0;\r\n}\r\nstatic void wacom_bamboo_pad_pen_event(struct wacom_wac *wacom,\r\nunsigned char *data)\r\n{\r\nunsigned char prefix;\r\nprefix = data[0];\r\ndata[0] = WACOM_REPORT_BPAD_PEN;\r\nhid_input_report(wacom->shared->pen, HID_INPUT_REPORT, data,\r\nWACOM_PKGLEN_PENABLED, 1);\r\ndata[0] = prefix;\r\n}\r\nstatic int wacom_bamboo_pad_touch_event(struct wacom_wac *wacom,\r\nunsigned char *data)\r\n{\r\nstruct input_dev *input = wacom->touch_input;\r\nunsigned char *finger_data, prefix;\r\nunsigned id;\r\nint x, y;\r\nbool valid;\r\nprefix = data[0];\r\nfor (id = 0; id < wacom->features.touch_max; id++) {\r\nvalid = !!(prefix & BIT(id)) &&\r\n!wacom->shared->stylus_in_proximity;\r\ninput_mt_slot(input, id);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, valid);\r\nif (!valid)\r\ncontinue;\r\nfinger_data = data + 1 + id * 3;\r\nx = finger_data[0] | ((finger_data[1] & 0x0f) << 8);\r\ny = (finger_data[2] << 4) | (finger_data[1] >> 4);\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\n}\r\ninput_mt_sync_frame(input);\r\ninput_report_key(input, BTN_LEFT, prefix & 0x40);\r\ninput_report_key(input, BTN_RIGHT, prefix & 0x80);\r\nwacom->shared->touch_down = !!prefix &&\r\n!wacom->shared->stylus_in_proximity;\r\nreturn 1;\r\n}\r\nstatic int wacom_bamboo_pad_irq(struct wacom_wac *wacom, size_t len)\r\n{\r\nunsigned char *data = wacom->data;\r\nif (!((len == WACOM_PKGLEN_BPAD_TOUCH) ||\r\n(len == WACOM_PKGLEN_BPAD_TOUCH_USB)) ||\r\n(data[0] != WACOM_REPORT_BPAD_TOUCH))\r\nreturn 0;\r\nif (data[1] & 0x01)\r\nwacom_bamboo_pad_pen_event(wacom, &data[1]);\r\nif (data[1] & 0x02)\r\nreturn wacom_bamboo_pad_touch_event(wacom, &data[9]);\r\nreturn 0;\r\n}\r\nstatic int wacom_wireless_irq(struct wacom_wac *wacom, size_t len)\r\n{\r\nunsigned char *data = wacom->data;\r\nint connected;\r\nif (len != WACOM_PKGLEN_WIRELESS || data[0] != WACOM_REPORT_WL)\r\nreturn 0;\r\nconnected = data[1] & 0x01;\r\nif (connected) {\r\nint pid, battery, charging;\r\nif ((wacom->shared->type == INTUOSHT ||\r\nwacom->shared->type == INTUOSHT2) &&\r\nwacom->shared->touch_input &&\r\nwacom->shared->touch_max) {\r\ninput_report_switch(wacom->shared->touch_input,\r\nSW_MUTE_DEVICE, data[5] & 0x40);\r\ninput_sync(wacom->shared->touch_input);\r\n}\r\npid = get_unaligned_be16(&data[6]);\r\nbattery = (data[5] & 0x3f) * 100 / 31;\r\ncharging = !!(data[5] & 0x80);\r\nif (wacom->pid != pid) {\r\nwacom->pid = pid;\r\nwacom_schedule_work(wacom);\r\n}\r\nif (wacom->shared->type)\r\nwacom_notify_battery(wacom, battery, charging, 1, 0);\r\n} else if (wacom->pid != 0) {\r\nwacom->pid = 0;\r\nwacom_schedule_work(wacom);\r\nwacom_notify_battery(wacom, 0, 0, 0, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wacom_status_irq(struct wacom_wac *wacom_wac, size_t len)\r\n{\r\nstruct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);\r\nstruct wacom_features *features = &wacom_wac->features;\r\nunsigned char *data = wacom_wac->data;\r\nif (data[0] != WACOM_REPORT_USB)\r\nreturn 0;\r\nif ((features->type == INTUOSHT ||\r\nfeatures->type == INTUOSHT2) &&\r\nwacom_wac->shared->touch_input &&\r\nfeatures->touch_max) {\r\ninput_report_switch(wacom_wac->shared->touch_input,\r\nSW_MUTE_DEVICE, data[8] & 0x40);\r\ninput_sync(wacom_wac->shared->touch_input);\r\n}\r\nif (data[9] & 0x02) {\r\nint battery = (data[8] & 0x3f) * 100 / 31;\r\nbool charging = !!(data[8] & 0x80);\r\nwacom_notify_battery(wacom_wac, battery, charging,\r\nbattery || charging, 1);\r\nif (!wacom->battery &&\r\n!(features->quirks & WACOM_QUIRK_BATTERY)) {\r\nfeatures->quirks |= WACOM_QUIRK_BATTERY;\r\nINIT_WORK(&wacom->work, wacom_battery_work);\r\nwacom_schedule_work(wacom_wac);\r\n}\r\n}\r\nelse if ((features->quirks & WACOM_QUIRK_BATTERY) &&\r\nwacom->battery) {\r\nfeatures->quirks &= ~WACOM_QUIRK_BATTERY;\r\nINIT_WORK(&wacom->work, wacom_battery_work);\r\nwacom_schedule_work(wacom_wac);\r\nwacom_notify_battery(wacom_wac, 0, 0, 0, 0);\r\n}\r\nreturn 0;\r\n}\r\nvoid wacom_wac_irq(struct wacom_wac *wacom_wac, size_t len)\r\n{\r\nbool sync;\r\nswitch (wacom_wac->features.type) {\r\ncase PENPARTNER:\r\nsync = wacom_penpartner_irq(wacom_wac);\r\nbreak;\r\ncase PL:\r\nsync = wacom_pl_irq(wacom_wac);\r\nbreak;\r\ncase WACOM_G4:\r\ncase GRAPHIRE:\r\ncase GRAPHIRE_BT:\r\ncase WACOM_MO:\r\nsync = wacom_graphire_irq(wacom_wac);\r\nbreak;\r\ncase PTU:\r\nsync = wacom_ptu_irq(wacom_wac);\r\nbreak;\r\ncase DTU:\r\nsync = wacom_dtu_irq(wacom_wac);\r\nbreak;\r\ncase DTUS:\r\ncase DTUSX:\r\nsync = wacom_dtus_irq(wacom_wac);\r\nbreak;\r\ncase INTUOS:\r\ncase INTUOS3S:\r\ncase INTUOS3:\r\ncase INTUOS3L:\r\ncase INTUOS4S:\r\ncase INTUOS4:\r\ncase INTUOS4L:\r\ncase CINTIQ:\r\ncase WACOM_BEE:\r\ncase WACOM_13HD:\r\ncase WACOM_21UX2:\r\ncase WACOM_22HD:\r\ncase WACOM_24HD:\r\ncase WACOM_27QHD:\r\ncase DTK:\r\ncase CINTIQ_HYBRID:\r\ncase CINTIQ_COMPANION_2:\r\nsync = wacom_intuos_irq(wacom_wac);\r\nbreak;\r\ncase INTUOS4WL:\r\nsync = wacom_intuos_bt_irq(wacom_wac, len);\r\nbreak;\r\ncase WACOM_24HDT:\r\ncase WACOM_27QHDT:\r\nsync = wacom_24hdt_irq(wacom_wac);\r\nbreak;\r\ncase INTUOS5S:\r\ncase INTUOS5:\r\ncase INTUOS5L:\r\ncase INTUOSPS:\r\ncase INTUOSPM:\r\ncase INTUOSPL:\r\nif (len == WACOM_PKGLEN_BBTOUCH3)\r\nsync = wacom_bpt3_touch(wacom_wac);\r\nelse if (wacom_wac->data[0] == WACOM_REPORT_USB)\r\nsync = wacom_status_irq(wacom_wac, len);\r\nelse\r\nsync = wacom_intuos_irq(wacom_wac);\r\nbreak;\r\ncase TABLETPC:\r\ncase TABLETPCE:\r\ncase TABLETPC2FG:\r\ncase MTSCREEN:\r\ncase MTTPC:\r\ncase MTTPC_B:\r\nsync = wacom_tpc_irq(wacom_wac, len);\r\nbreak;\r\ncase BAMBOO_PT:\r\ncase BAMBOO_PEN:\r\ncase BAMBOO_TOUCH:\r\ncase INTUOSHT:\r\ncase INTUOSHT2:\r\nif (wacom_wac->data[0] == WACOM_REPORT_USB)\r\nsync = wacom_status_irq(wacom_wac, len);\r\nelse\r\nsync = wacom_bpt_irq(wacom_wac, len);\r\nbreak;\r\ncase BAMBOO_PAD:\r\nsync = wacom_bamboo_pad_irq(wacom_wac, len);\r\nbreak;\r\ncase WIRELESS:\r\nsync = wacom_wireless_irq(wacom_wac, len);\r\nbreak;\r\ncase REMOTE:\r\nif (wacom_wac->data[0] == WACOM_REPORT_DEVICE_LIST)\r\nsync = wacom_remote_status_irq(wacom_wac, len);\r\nelse\r\nsync = wacom_remote_irq(wacom_wac, len);\r\nbreak;\r\ndefault:\r\nsync = false;\r\nbreak;\r\n}\r\nif (sync) {\r\nif (wacom_wac->pen_input)\r\ninput_sync(wacom_wac->pen_input);\r\nif (wacom_wac->touch_input)\r\ninput_sync(wacom_wac->touch_input);\r\nif (wacom_wac->pad_input)\r\ninput_sync(wacom_wac->pad_input);\r\n}\r\n}\r\nstatic void wacom_setup_basic_pro_pen(struct wacom_wac *wacom_wac)\r\n{\r\nstruct input_dev *input_dev = wacom_wac->pen_input;\r\ninput_set_capability(input_dev, EV_MSC, MSC_SERIAL);\r\n__set_bit(BTN_TOOL_PEN, input_dev->keybit);\r\n__set_bit(BTN_STYLUS, input_dev->keybit);\r\n__set_bit(BTN_STYLUS2, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_DISTANCE,\r\n0, wacom_wac->features.distance_max, wacom_wac->features.distance_fuzz, 0);\r\n}\r\nstatic void wacom_setup_cintiq(struct wacom_wac *wacom_wac)\r\n{\r\nstruct input_dev *input_dev = wacom_wac->pen_input;\r\nstruct wacom_features *features = &wacom_wac->features;\r\nwacom_setup_basic_pro_pen(wacom_wac);\r\n__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);\r\n__set_bit(BTN_TOOL_BRUSH, input_dev->keybit);\r\n__set_bit(BTN_TOOL_PENCIL, input_dev->keybit);\r\n__set_bit(BTN_TOOL_AIRBRUSH, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_WHEEL, 0, 1023, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_TILT_X, -64, 63, features->tilt_fuzz, 0);\r\ninput_abs_set_res(input_dev, ABS_TILT_X, 57);\r\ninput_set_abs_params(input_dev, ABS_TILT_Y, -64, 63, features->tilt_fuzz, 0);\r\ninput_abs_set_res(input_dev, ABS_TILT_Y, 57);\r\n}\r\nstatic void wacom_setup_intuos(struct wacom_wac *wacom_wac)\r\n{\r\nstruct input_dev *input_dev = wacom_wac->pen_input;\r\ninput_set_capability(input_dev, EV_REL, REL_WHEEL);\r\nwacom_setup_cintiq(wacom_wac);\r\n__set_bit(BTN_LEFT, input_dev->keybit);\r\n__set_bit(BTN_RIGHT, input_dev->keybit);\r\n__set_bit(BTN_MIDDLE, input_dev->keybit);\r\n__set_bit(BTN_SIDE, input_dev->keybit);\r\n__set_bit(BTN_EXTRA, input_dev->keybit);\r\n__set_bit(BTN_TOOL_MOUSE, input_dev->keybit);\r\n__set_bit(BTN_TOOL_LENS, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_RZ, -900, 899, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_RZ, 287);\r\ninput_set_abs_params(input_dev, ABS_THROTTLE, -1023, 1023, 0, 0);\r\n}\r\nvoid wacom_setup_device_quirks(struct wacom *wacom)\r\n{\r\nstruct wacom_features *features = &wacom->wacom_wac.features;\r\nif (features->type == GRAPHIRE_BT || features->type == WACOM_G4 ||\r\nfeatures->type == DTUS ||\r\n(features->type >= INTUOS3S && features->type <= WACOM_MO)) {\r\nif (features->device_type & WACOM_DEVICETYPE_PEN)\r\nfeatures->device_type |= WACOM_DEVICETYPE_PAD;\r\n}\r\nif (features->device_type & WACOM_DEVICETYPE_TOUCH && !features->x_max) {\r\nfeatures->x_max = 1023;\r\nfeatures->y_max = 1023;\r\n}\r\nif ((features->type >= INTUOS5S && features->type <= INTUOSPL) ||\r\n(features->type >= INTUOSHT && features->type <= BAMBOO_PT)) {\r\nif (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {\r\nif (features->touch_max)\r\nfeatures->device_type |= WACOM_DEVICETYPE_TOUCH;\r\nif (features->type >= INTUOSHT && features->type <= BAMBOO_PT)\r\nfeatures->device_type |= WACOM_DEVICETYPE_PAD;\r\nfeatures->x_max = 4096;\r\nfeatures->y_max = 4096;\r\n}\r\nelse if (features->pktlen == WACOM_PKGLEN_BBTOUCH) {\r\nfeatures->device_type |= WACOM_DEVICETYPE_PAD;\r\n}\r\n}\r\nif (features->type == BAMBOO_PEN &&\r\nfeatures->pktlen == WACOM_PKGLEN_BBTOUCH3)\r\nfeatures->device_type |= WACOM_DEVICETYPE_PAD;\r\nif (features->type == BAMBOO_PAD)\r\nfeatures->device_type = WACOM_DEVICETYPE_TOUCH;\r\nif (features->type == REMOTE)\r\nfeatures->device_type = WACOM_DEVICETYPE_PAD;\r\nif (wacom->hdev->bus == BUS_BLUETOOTH)\r\nfeatures->quirks |= WACOM_QUIRK_BATTERY;\r\nif ((features->type == BAMBOO_PT || features->type == BAMBOO_TOUCH) &&\r\nfeatures->pktlen == WACOM_PKGLEN_BBTOUCH) {\r\nfeatures->x_max <<= 5;\r\nfeatures->y_max <<= 5;\r\nfeatures->x_fuzz <<= 5;\r\nfeatures->y_fuzz <<= 5;\r\nfeatures->quirks |= WACOM_QUIRK_BBTOUCH_LOWRES;\r\n}\r\nif (features->type == WIRELESS) {\r\nif (features->device_type == WACOM_DEVICETYPE_WL_MONITOR) {\r\nfeatures->quirks |= WACOM_QUIRK_BATTERY;\r\n}\r\n}\r\n}\r\nint wacom_setup_pen_input_capabilities(struct input_dev *input_dev,\r\nstruct wacom_wac *wacom_wac)\r\n{\r\nstruct wacom_features *features = &wacom_wac->features;\r\ninput_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nif (!(features->device_type & WACOM_DEVICETYPE_PEN))\r\nreturn -ENODEV;\r\nif (features->type == HID_GENERIC)\r\nreturn 0;\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\n__set_bit(ABS_MISC, input_dev->absbit);\r\ninput_set_abs_params(input_dev, ABS_X, features->x_min,\r\nfeatures->x_max, features->x_fuzz, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, features->y_min,\r\nfeatures->y_max, features->y_fuzz, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0,\r\nfeatures->pressure_max, features->pressure_fuzz, 0);\r\ninput_abs_set_res(input_dev, ABS_X, features->x_resolution);\r\ninput_abs_set_res(input_dev, ABS_Y, features->y_resolution);\r\nswitch (features->type) {\r\ncase GRAPHIRE_BT:\r\n__clear_bit(ABS_MISC, input_dev->absbit);\r\ncase WACOM_MO:\r\ncase WACOM_G4:\r\ninput_set_abs_params(input_dev, ABS_DISTANCE, 0,\r\nfeatures->distance_max,\r\nfeatures->distance_fuzz, 0);\r\ncase GRAPHIRE:\r\ninput_set_capability(input_dev, EV_REL, REL_WHEEL);\r\n__set_bit(BTN_LEFT, input_dev->keybit);\r\n__set_bit(BTN_RIGHT, input_dev->keybit);\r\n__set_bit(BTN_MIDDLE, input_dev->keybit);\r\n__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);\r\n__set_bit(BTN_TOOL_PEN, input_dev->keybit);\r\n__set_bit(BTN_TOOL_MOUSE, input_dev->keybit);\r\n__set_bit(BTN_STYLUS, input_dev->keybit);\r\n__set_bit(BTN_STYLUS2, input_dev->keybit);\r\n__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\nbreak;\r\ncase WACOM_27QHD:\r\ncase WACOM_24HD:\r\ncase DTK:\r\ncase WACOM_22HD:\r\ncase WACOM_21UX2:\r\ncase WACOM_BEE:\r\ncase CINTIQ:\r\ncase WACOM_13HD:\r\ncase CINTIQ_HYBRID:\r\ncase CINTIQ_COMPANION_2:\r\ninput_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_Z, 287);\r\n__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);\r\nwacom_setup_cintiq(wacom_wac);\r\nbreak;\r\ncase INTUOS3:\r\ncase INTUOS3L:\r\ncase INTUOS3S:\r\ncase INTUOS4:\r\ncase INTUOS4WL:\r\ncase INTUOS4L:\r\ncase INTUOS4S:\r\ninput_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_Z, 287);\r\ncase INTUOS:\r\n__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\nwacom_setup_intuos(wacom_wac);\r\nbreak;\r\ncase INTUOS5:\r\ncase INTUOS5L:\r\ncase INTUOSPM:\r\ncase INTUOSPL:\r\ncase INTUOS5S:\r\ncase INTUOSPS:\r\n__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\ninput_set_abs_params(input_dev, ABS_DISTANCE, 0,\r\nfeatures->distance_max,\r\nfeatures->distance_fuzz, 0);\r\ninput_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_Z, 287);\r\nwacom_setup_intuos(wacom_wac);\r\nbreak;\r\ncase WACOM_24HDT:\r\ncase WACOM_27QHDT:\r\ncase MTSCREEN:\r\ncase MTTPC:\r\ncase MTTPC_B:\r\ncase TABLETPC2FG:\r\ncase TABLETPC:\r\ncase TABLETPCE:\r\n__clear_bit(ABS_MISC, input_dev->absbit);\r\ncase DTUS:\r\ncase DTUSX:\r\ncase PL:\r\ncase DTU:\r\n__set_bit(BTN_TOOL_PEN, input_dev->keybit);\r\n__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);\r\n__set_bit(BTN_STYLUS, input_dev->keybit);\r\n__set_bit(BTN_STYLUS2, input_dev->keybit);\r\n__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);\r\nbreak;\r\ncase PTU:\r\n__set_bit(BTN_STYLUS2, input_dev->keybit);\r\ncase PENPARTNER:\r\n__set_bit(BTN_TOOL_PEN, input_dev->keybit);\r\n__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);\r\n__set_bit(BTN_STYLUS, input_dev->keybit);\r\n__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\nbreak;\r\ncase INTUOSHT:\r\ncase BAMBOO_PT:\r\ncase BAMBOO_PEN:\r\ncase INTUOSHT2:\r\n__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\nif (features->type == INTUOSHT2) {\r\nwacom_setup_basic_pro_pen(wacom_wac);\r\n} else {\r\n__clear_bit(ABS_MISC, input_dev->absbit);\r\n__set_bit(BTN_TOOL_PEN, input_dev->keybit);\r\n__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);\r\n__set_bit(BTN_STYLUS, input_dev->keybit);\r\n__set_bit(BTN_STYLUS2, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_DISTANCE, 0,\r\nfeatures->distance_max,\r\nfeatures->distance_fuzz, 0);\r\n}\r\nbreak;\r\ncase BAMBOO_PAD:\r\n__clear_bit(ABS_MISC, input_dev->absbit);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint wacom_setup_touch_input_capabilities(struct input_dev *input_dev,\r\nstruct wacom_wac *wacom_wac)\r\n{\r\nstruct wacom_features *features = &wacom_wac->features;\r\ninput_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nif (!(features->device_type & WACOM_DEVICETYPE_TOUCH))\r\nreturn -ENODEV;\r\nif (features->type == HID_GENERIC)\r\nreturn 0;\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\nif (features->touch_max == 1) {\r\ninput_set_abs_params(input_dev, ABS_X, 0,\r\nfeatures->x_max, features->x_fuzz, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0,\r\nfeatures->y_max, features->y_fuzz, 0);\r\ninput_abs_set_res(input_dev, ABS_X,\r\nfeatures->x_resolution);\r\ninput_abs_set_res(input_dev, ABS_Y,\r\nfeatures->y_resolution);\r\n}\r\nelse if (features->touch_max > 1) {\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,\r\nfeatures->x_max, features->x_fuzz, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,\r\nfeatures->y_max, features->y_fuzz, 0);\r\ninput_abs_set_res(input_dev, ABS_MT_POSITION_X,\r\nfeatures->x_resolution);\r\ninput_abs_set_res(input_dev, ABS_MT_POSITION_Y,\r\nfeatures->y_resolution);\r\n}\r\nswitch (features->type) {\r\ncase INTUOS5:\r\ncase INTUOS5L:\r\ncase INTUOSPM:\r\ncase INTUOSPL:\r\ncase INTUOS5S:\r\ncase INTUOSPS:\r\n__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, features->y_max, 0, 0);\r\ninput_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);\r\nbreak;\r\ncase WACOM_24HDT:\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);\r\ncase WACOM_27QHDT:\r\ncase MTSCREEN:\r\ncase MTTPC:\r\ncase MTTPC_B:\r\ncase TABLETPC2FG:\r\ninput_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);\r\ncase TABLETPC:\r\ncase TABLETPCE:\r\n__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);\r\nbreak;\r\ncase INTUOSHT:\r\ncase INTUOSHT2:\r\ninput_dev->evbit[0] |= BIT_MASK(EV_SW);\r\n__set_bit(SW_MUTE_DEVICE, input_dev->swbit);\r\ncase BAMBOO_PT:\r\ncase BAMBOO_TOUCH:\r\nif (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {\r\ninput_set_abs_params(input_dev,\r\nABS_MT_TOUCH_MAJOR,\r\n0, features->x_max, 0, 0);\r\ninput_set_abs_params(input_dev,\r\nABS_MT_TOUCH_MINOR,\r\n0, features->y_max, 0, 0);\r\n}\r\ninput_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);\r\nbreak;\r\ncase BAMBOO_PAD:\r\ninput_mt_init_slots(input_dev, features->touch_max,\r\nINPUT_MT_POINTER);\r\n__set_bit(BTN_LEFT, input_dev->keybit);\r\n__set_bit(BTN_RIGHT, input_dev->keybit);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void wacom_setup_numbered_buttons(struct input_dev *input_dev,\r\nint button_count)\r\n{\r\nint i;\r\nfor (i = 0; i < button_count && i < 10; i++)\r\n__set_bit(BTN_0 + i, input_dev->keybit);\r\nfor (i = 10; i < button_count && i < 16; i++)\r\n__set_bit(BTN_A + (i-10), input_dev->keybit);\r\nfor (i = 16; i < button_count && i < 18; i++)\r\n__set_bit(BTN_BASE + (i-16), input_dev->keybit);\r\n}\r\nstatic void wacom_report_numbered_buttons(struct input_dev *input_dev,\r\nint button_count, int mask)\r\n{\r\nint i;\r\nfor (i = 0; i < button_count && i < 10; i++)\r\ninput_report_key(input_dev, BTN_0 + i, mask & (1 << i));\r\nfor (i = 10; i < button_count && i < 16; i++)\r\ninput_report_key(input_dev, BTN_A + (i-10), mask & (1 << i));\r\nfor (i = 16; i < button_count && i < 18; i++)\r\ninput_report_key(input_dev, BTN_BASE + (i-16), mask & (1 << i));\r\n}\r\nint wacom_setup_pad_input_capabilities(struct input_dev *input_dev,\r\nstruct wacom_wac *wacom_wac)\r\n{\r\nstruct wacom_features *features = &wacom_wac->features;\r\nif (!(features->device_type & WACOM_DEVICETYPE_PAD))\r\nreturn -ENODEV;\r\ninput_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\n__set_bit(ABS_MISC, input_dev->absbit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);\r\n__set_bit(BTN_STYLUS, input_dev->keybit);\r\nwacom_setup_numbered_buttons(input_dev, features->numbered_buttons);\r\nswitch (features->type) {\r\ncase CINTIQ_HYBRID:\r\ncase CINTIQ_COMPANION_2:\r\ncase DTK:\r\ncase DTUS:\r\ncase GRAPHIRE_BT:\r\nbreak;\r\ncase WACOM_MO:\r\n__set_bit(BTN_BACK, input_dev->keybit);\r\n__set_bit(BTN_LEFT, input_dev->keybit);\r\n__set_bit(BTN_FORWARD, input_dev->keybit);\r\n__set_bit(BTN_RIGHT, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\r\nbreak;\r\ncase WACOM_G4:\r\n__set_bit(BTN_BACK, input_dev->keybit);\r\n__set_bit(BTN_FORWARD, input_dev->keybit);\r\ninput_set_capability(input_dev, EV_REL, REL_WHEEL);\r\nbreak;\r\ncase WACOM_24HD:\r\n__set_bit(KEY_PROG1, input_dev->keybit);\r\n__set_bit(KEY_PROG2, input_dev->keybit);\r\n__set_bit(KEY_PROG3, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);\r\nbreak;\r\ncase WACOM_27QHD:\r\n__set_bit(KEY_PROG1, input_dev->keybit);\r\n__set_bit(KEY_PROG2, input_dev->keybit);\r\n__set_bit(KEY_PROG3, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X, -2048, 2048, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_X, 1024);\r\ninput_set_abs_params(input_dev, ABS_Y, -2048, 2048, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_Y, 1024);\r\ninput_set_abs_params(input_dev, ABS_Z, -2048, 2048, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_Z, 1024);\r\n__set_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);\r\nbreak;\r\ncase WACOM_22HD:\r\n__set_bit(KEY_PROG1, input_dev->keybit);\r\n__set_bit(KEY_PROG2, input_dev->keybit);\r\n__set_bit(KEY_PROG3, input_dev->keybit);\r\ncase WACOM_21UX2:\r\ncase WACOM_BEE:\r\ncase CINTIQ:\r\ninput_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);\r\nbreak;\r\ncase WACOM_13HD:\r\ninput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\r\nbreak;\r\ncase INTUOS3:\r\ncase INTUOS3L:\r\ninput_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);\r\ncase INTUOS3S:\r\ninput_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);\r\nbreak;\r\ncase INTUOS5:\r\ncase INTUOS5L:\r\ncase INTUOSPM:\r\ncase INTUOSPL:\r\ncase INTUOS5S:\r\ncase INTUOSPS:\r\ninput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\r\nbreak;\r\ncase INTUOS4WL:\r\n__set_bit(BTN_STYLUS, input_dev->keybit);\r\ncase INTUOS4:\r\ncase INTUOS4L:\r\ncase INTUOS4S:\r\ninput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\r\nbreak;\r\ncase INTUOSHT:\r\ncase BAMBOO_PT:\r\ncase BAMBOO_TOUCH:\r\ncase INTUOSHT2:\r\n__clear_bit(ABS_MISC, input_dev->absbit);\r\n__set_bit(BTN_LEFT, input_dev->keybit);\r\n__set_bit(BTN_FORWARD, input_dev->keybit);\r\n__set_bit(BTN_BACK, input_dev->keybit);\r\n__set_bit(BTN_RIGHT, input_dev->keybit);\r\nbreak;\r\ncase REMOTE:\r\ninput_set_capability(input_dev, EV_MSC, MSC_SERIAL);\r\ninput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}
