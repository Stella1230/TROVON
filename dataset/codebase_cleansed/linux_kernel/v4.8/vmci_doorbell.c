int vmci_dbell_get_priv_flags(struct vmci_handle handle, u32 *priv_flags)\r\n{\r\nif (priv_flags == NULL || handle.context == VMCI_INVALID_ID)\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nif (handle.context == VMCI_HOST_CONTEXT_ID) {\r\nstruct dbell_entry *entry;\r\nstruct vmci_resource *resource;\r\nresource = vmci_resource_by_handle(handle,\r\nVMCI_RESOURCE_TYPE_DOORBELL);\r\nif (!resource)\r\nreturn VMCI_ERROR_NOT_FOUND;\r\nentry = container_of(resource, struct dbell_entry, resource);\r\n*priv_flags = entry->priv_flags;\r\nvmci_resource_put(resource);\r\n} else if (handle.context == VMCI_HYPERVISOR_CONTEXT_ID) {\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\n} else {\r\n*priv_flags = vmci_context_get_priv_flags(handle.context);\r\n}\r\nreturn VMCI_SUCCESS;\r\n}\r\nstatic struct dbell_entry *dbell_index_table_find(u32 idx)\r\n{\r\nu32 bucket = VMCI_DOORBELL_HASH(idx);\r\nstruct dbell_entry *dbell;\r\nhlist_for_each_entry(dbell, &vmci_doorbell_it.entries[bucket],\r\nnode) {\r\nif (idx == dbell->idx)\r\nreturn dbell;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void dbell_index_table_add(struct dbell_entry *entry)\r\n{\r\nu32 bucket;\r\nu32 new_notify_idx;\r\nvmci_resource_get(&entry->resource);\r\nspin_lock_bh(&vmci_doorbell_it.lock);\r\nif (max_notify_idx < PAGE_SIZE || notify_idx_count < PAGE_SIZE) {\r\nif (last_notify_idx_released < max_notify_idx &&\r\n!dbell_index_table_find(last_notify_idx_released)) {\r\nnew_notify_idx = last_notify_idx_released;\r\nlast_notify_idx_released = PAGE_SIZE;\r\n} else {\r\nbool reused = false;\r\nnew_notify_idx = last_notify_idx_reserved;\r\nif (notify_idx_count + 1 < max_notify_idx) {\r\ndo {\r\nif (!dbell_index_table_find\r\n(new_notify_idx)) {\r\nreused = true;\r\nbreak;\r\n}\r\nnew_notify_idx = (new_notify_idx + 1) %\r\nmax_notify_idx;\r\n} while (new_notify_idx !=\r\nlast_notify_idx_released);\r\n}\r\nif (!reused) {\r\nnew_notify_idx = max_notify_idx;\r\nmax_notify_idx++;\r\n}\r\n}\r\n} else {\r\nnew_notify_idx = (last_notify_idx_reserved + 1) % PAGE_SIZE;\r\n}\r\nlast_notify_idx_reserved = new_notify_idx;\r\nnotify_idx_count++;\r\nentry->idx = new_notify_idx;\r\nbucket = VMCI_DOORBELL_HASH(entry->idx);\r\nhlist_add_head(&entry->node, &vmci_doorbell_it.entries[bucket]);\r\nspin_unlock_bh(&vmci_doorbell_it.lock);\r\n}\r\nstatic void dbell_index_table_remove(struct dbell_entry *entry)\r\n{\r\nspin_lock_bh(&vmci_doorbell_it.lock);\r\nhlist_del_init(&entry->node);\r\nnotify_idx_count--;\r\nif (entry->idx == max_notify_idx - 1) {\r\nwhile (max_notify_idx > 0 &&\r\n!dbell_index_table_find(max_notify_idx - 1))\r\nmax_notify_idx--;\r\n}\r\nlast_notify_idx_released = entry->idx;\r\nspin_unlock_bh(&vmci_doorbell_it.lock);\r\nvmci_resource_put(&entry->resource);\r\n}\r\nstatic int dbell_link(struct vmci_handle handle, u32 notify_idx)\r\n{\r\nstruct vmci_doorbell_link_msg link_msg;\r\nlink_msg.hdr.dst = vmci_make_handle(VMCI_HYPERVISOR_CONTEXT_ID,\r\nVMCI_DOORBELL_LINK);\r\nlink_msg.hdr.src = VMCI_ANON_SRC_HANDLE;\r\nlink_msg.hdr.payload_size = sizeof(link_msg) - VMCI_DG_HEADERSIZE;\r\nlink_msg.handle = handle;\r\nlink_msg.notify_idx = notify_idx;\r\nreturn vmci_send_datagram(&link_msg.hdr);\r\n}\r\nstatic int dbell_unlink(struct vmci_handle handle)\r\n{\r\nstruct vmci_doorbell_unlink_msg unlink_msg;\r\nunlink_msg.hdr.dst = vmci_make_handle(VMCI_HYPERVISOR_CONTEXT_ID,\r\nVMCI_DOORBELL_UNLINK);\r\nunlink_msg.hdr.src = VMCI_ANON_SRC_HANDLE;\r\nunlink_msg.hdr.payload_size = sizeof(unlink_msg) - VMCI_DG_HEADERSIZE;\r\nunlink_msg.handle = handle;\r\nreturn vmci_send_datagram(&unlink_msg.hdr);\r\n}\r\nstatic int dbell_notify_as_guest(struct vmci_handle handle, u32 priv_flags)\r\n{\r\nstruct vmci_doorbell_notify_msg notify_msg;\r\nnotify_msg.hdr.dst = vmci_make_handle(VMCI_HYPERVISOR_CONTEXT_ID,\r\nVMCI_DOORBELL_NOTIFY);\r\nnotify_msg.hdr.src = VMCI_ANON_SRC_HANDLE;\r\nnotify_msg.hdr.payload_size = sizeof(notify_msg) - VMCI_DG_HEADERSIZE;\r\nnotify_msg.handle = handle;\r\nreturn vmci_send_datagram(&notify_msg.hdr);\r\n}\r\nstatic void dbell_delayed_dispatch(struct work_struct *work)\r\n{\r\nstruct dbell_entry *entry = container_of(work,\r\nstruct dbell_entry, work);\r\nentry->notify_cb(entry->client_data);\r\nvmci_resource_put(&entry->resource);\r\n}\r\nint vmci_dbell_host_context_notify(u32 src_cid, struct vmci_handle handle)\r\n{\r\nstruct dbell_entry *entry;\r\nstruct vmci_resource *resource;\r\nif (vmci_handle_is_invalid(handle)) {\r\npr_devel("Notifying an invalid doorbell (handle=0x%x:0x%x)\n",\r\nhandle.context, handle.resource);\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\n}\r\nresource = vmci_resource_by_handle(handle,\r\nVMCI_RESOURCE_TYPE_DOORBELL);\r\nif (!resource) {\r\npr_devel("Notifying an unknown doorbell (handle=0x%x:0x%x)\n",\r\nhandle.context, handle.resource);\r\nreturn VMCI_ERROR_NOT_FOUND;\r\n}\r\nentry = container_of(resource, struct dbell_entry, resource);\r\nif (entry->run_delayed) {\r\nschedule_work(&entry->work);\r\n} else {\r\nentry->notify_cb(entry->client_data);\r\nvmci_resource_put(resource);\r\n}\r\nreturn VMCI_SUCCESS;\r\n}\r\nbool vmci_dbell_register_notification_bitmap(u32 bitmap_ppn)\r\n{\r\nint result;\r\nstruct vmci_notify_bm_set_msg bitmap_set_msg;\r\nbitmap_set_msg.hdr.dst = vmci_make_handle(VMCI_HYPERVISOR_CONTEXT_ID,\r\nVMCI_SET_NOTIFY_BITMAP);\r\nbitmap_set_msg.hdr.src = VMCI_ANON_SRC_HANDLE;\r\nbitmap_set_msg.hdr.payload_size = sizeof(bitmap_set_msg) -\r\nVMCI_DG_HEADERSIZE;\r\nbitmap_set_msg.bitmap_ppn = bitmap_ppn;\r\nresult = vmci_send_datagram(&bitmap_set_msg.hdr);\r\nif (result != VMCI_SUCCESS) {\r\npr_devel("Failed to register (PPN=%u) as notification bitmap (error=%d)\n",\r\nbitmap_ppn, result);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void dbell_fire_entries(u32 notify_idx)\r\n{\r\nu32 bucket = VMCI_DOORBELL_HASH(notify_idx);\r\nstruct dbell_entry *dbell;\r\nspin_lock_bh(&vmci_doorbell_it.lock);\r\nhlist_for_each_entry(dbell, &vmci_doorbell_it.entries[bucket], node) {\r\nif (dbell->idx == notify_idx &&\r\natomic_read(&dbell->active) == 1) {\r\nif (dbell->run_delayed) {\r\nvmci_resource_get(&dbell->resource);\r\nschedule_work(&dbell->work);\r\n} else {\r\ndbell->notify_cb(dbell->client_data);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&vmci_doorbell_it.lock);\r\n}\r\nvoid vmci_dbell_scan_notification_entries(u8 *bitmap)\r\n{\r\nu32 idx;\r\nfor (idx = 0; idx < max_notify_idx; idx++) {\r\nif (bitmap[idx] & 0x1) {\r\nbitmap[idx] &= ~1;\r\ndbell_fire_entries(idx);\r\n}\r\n}\r\n}\r\nint vmci_doorbell_create(struct vmci_handle *handle,\r\nu32 flags,\r\nu32 priv_flags,\r\nvmci_callback notify_cb, void *client_data)\r\n{\r\nstruct dbell_entry *entry;\r\nstruct vmci_handle new_handle;\r\nint result;\r\nif (!handle || !notify_cb || flags & ~VMCI_FLAG_DELAYED_CB ||\r\npriv_flags & ~VMCI_PRIVILEGE_ALL_FLAGS)\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (entry == NULL) {\r\npr_warn("Failed allocating memory for datagram entry\n");\r\nreturn VMCI_ERROR_NO_MEM;\r\n}\r\nif (vmci_handle_is_invalid(*handle)) {\r\nu32 context_id = vmci_get_context_id();\r\nnew_handle = vmci_make_handle(context_id, VMCI_INVALID_ID);\r\n} else {\r\nbool valid_context = false;\r\nif (handle->context == VMCI_HOST_CONTEXT_ID ||\r\n(vmci_guest_code_active() &&\r\nvmci_get_context_id() == handle->context)) {\r\nvalid_context = true;\r\n}\r\nif (!valid_context || handle->resource == VMCI_INVALID_ID) {\r\npr_devel("Invalid argument (handle=0x%x:0x%x)\n",\r\nhandle->context, handle->resource);\r\nresult = VMCI_ERROR_INVALID_ARGS;\r\ngoto free_mem;\r\n}\r\nnew_handle = *handle;\r\n}\r\nentry->idx = 0;\r\nINIT_HLIST_NODE(&entry->node);\r\nentry->priv_flags = priv_flags;\r\nINIT_WORK(&entry->work, dbell_delayed_dispatch);\r\nentry->run_delayed = flags & VMCI_FLAG_DELAYED_CB;\r\nentry->notify_cb = notify_cb;\r\nentry->client_data = client_data;\r\natomic_set(&entry->active, 0);\r\nresult = vmci_resource_add(&entry->resource,\r\nVMCI_RESOURCE_TYPE_DOORBELL,\r\nnew_handle);\r\nif (result != VMCI_SUCCESS) {\r\npr_warn("Failed to add new resource (handle=0x%x:0x%x), error: %d\n",\r\nnew_handle.context, new_handle.resource, result);\r\ngoto free_mem;\r\n}\r\nnew_handle = vmci_resource_handle(&entry->resource);\r\nif (vmci_guest_code_active()) {\r\ndbell_index_table_add(entry);\r\nresult = dbell_link(new_handle, entry->idx);\r\nif (VMCI_SUCCESS != result)\r\ngoto destroy_resource;\r\natomic_set(&entry->active, 1);\r\n}\r\n*handle = new_handle;\r\nreturn result;\r\ndestroy_resource:\r\ndbell_index_table_remove(entry);\r\nvmci_resource_remove(&entry->resource);\r\nfree_mem:\r\nkfree(entry);\r\nreturn result;\r\n}\r\nint vmci_doorbell_destroy(struct vmci_handle handle)\r\n{\r\nstruct dbell_entry *entry;\r\nstruct vmci_resource *resource;\r\nif (vmci_handle_is_invalid(handle))\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nresource = vmci_resource_by_handle(handle,\r\nVMCI_RESOURCE_TYPE_DOORBELL);\r\nif (!resource) {\r\npr_devel("Failed to destroy doorbell (handle=0x%x:0x%x)\n",\r\nhandle.context, handle.resource);\r\nreturn VMCI_ERROR_NOT_FOUND;\r\n}\r\nentry = container_of(resource, struct dbell_entry, resource);\r\nif (vmci_guest_code_active()) {\r\nint result;\r\ndbell_index_table_remove(entry);\r\nresult = dbell_unlink(handle);\r\nif (VMCI_SUCCESS != result) {\r\npr_devel("Unlink of doorbell (handle=0x%x:0x%x) unknown by hypervisor (error=%d)\n",\r\nhandle.context, handle.resource, result);\r\n}\r\n}\r\nvmci_resource_put(&entry->resource);\r\nvmci_resource_remove(&entry->resource);\r\nkfree(entry);\r\nreturn VMCI_SUCCESS;\r\n}\r\nint vmci_doorbell_notify(struct vmci_handle dst, u32 priv_flags)\r\n{\r\nint retval;\r\nenum vmci_route route;\r\nstruct vmci_handle src;\r\nif (vmci_handle_is_invalid(dst) ||\r\n(priv_flags & ~VMCI_PRIVILEGE_ALL_FLAGS))\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nsrc = VMCI_INVALID_HANDLE;\r\nretval = vmci_route(&src, &dst, false, &route);\r\nif (retval < VMCI_SUCCESS)\r\nreturn retval;\r\nif (VMCI_ROUTE_AS_HOST == route)\r\nreturn vmci_ctx_notify_dbell(VMCI_HOST_CONTEXT_ID,\r\ndst, priv_flags);\r\nif (VMCI_ROUTE_AS_GUEST == route)\r\nreturn dbell_notify_as_guest(dst, priv_flags);\r\npr_warn("Unknown route (%d) for doorbell\n", route);\r\nreturn VMCI_ERROR_DST_UNREACHABLE;\r\n}
