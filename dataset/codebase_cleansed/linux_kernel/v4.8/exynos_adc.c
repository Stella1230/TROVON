static void exynos_adc_unprepare_clk(struct exynos_adc *info)\r\n{\r\nif (info->data->needs_sclk)\r\nclk_unprepare(info->sclk);\r\nclk_unprepare(info->clk);\r\n}\r\nstatic int exynos_adc_prepare_clk(struct exynos_adc *info)\r\n{\r\nint ret;\r\nret = clk_prepare(info->clk);\r\nif (ret) {\r\ndev_err(info->dev, "failed preparing adc clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (info->data->needs_sclk) {\r\nret = clk_prepare(info->sclk);\r\nif (ret) {\r\nclk_unprepare(info->clk);\r\ndev_err(info->dev,\r\n"failed preparing sclk_adc clock: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void exynos_adc_disable_clk(struct exynos_adc *info)\r\n{\r\nif (info->data->needs_sclk)\r\nclk_disable(info->sclk);\r\nclk_disable(info->clk);\r\n}\r\nstatic int exynos_adc_enable_clk(struct exynos_adc *info)\r\n{\r\nint ret;\r\nret = clk_enable(info->clk);\r\nif (ret) {\r\ndev_err(info->dev, "failed enabling adc clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (info->data->needs_sclk) {\r\nret = clk_enable(info->sclk);\r\nif (ret) {\r\nclk_disable(info->clk);\r\ndev_err(info->dev,\r\n"failed enabling sclk_adc clock: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void exynos_adc_v1_init_hw(struct exynos_adc *info)\r\n{\r\nu32 con1;\r\nif (info->data->needs_adc_phy)\r\nregmap_write(info->pmu_map, info->data->phy_offset, 1);\r\ncon1 = ADC_V1_CON_PRSCLV(49) | ADC_V1_CON_PRSCEN;\r\ncon1 |= ADC_V1_CON_RES;\r\nwritel(con1, ADC_V1_CON(info->regs));\r\nwritel(info->delay, ADC_V1_DLY(info->regs));\r\n}\r\nstatic void exynos_adc_v1_exit_hw(struct exynos_adc *info)\r\n{\r\nu32 con;\r\nif (info->data->needs_adc_phy)\r\nregmap_write(info->pmu_map, info->data->phy_offset, 0);\r\ncon = readl(ADC_V1_CON(info->regs));\r\ncon |= ADC_V1_CON_STANDBY;\r\nwritel(con, ADC_V1_CON(info->regs));\r\n}\r\nstatic void exynos_adc_v1_clear_irq(struct exynos_adc *info)\r\n{\r\nwritel(1, ADC_V1_INTCLR(info->regs));\r\n}\r\nstatic void exynos_adc_v1_start_conv(struct exynos_adc *info,\r\nunsigned long addr)\r\n{\r\nu32 con1;\r\nwritel(addr, ADC_V1_MUX(info->regs));\r\ncon1 = readl(ADC_V1_CON(info->regs));\r\nwritel(con1 | ADC_CON_EN_START, ADC_V1_CON(info->regs));\r\n}\r\nstatic void exynos_adc_s3c2416_start_conv(struct exynos_adc *info,\r\nunsigned long addr)\r\n{\r\nu32 con1;\r\ncon1 = readl(ADC_V1_CON(info->regs));\r\ncon1 |= ADC_S3C2416_CON_RES_SEL;\r\nwritel(con1, ADC_V1_CON(info->regs));\r\nwritel(addr, ADC_S3C2410_MUX(info->regs));\r\ncon1 = readl(ADC_V1_CON(info->regs));\r\nwritel(con1 | ADC_CON_EN_START, ADC_V1_CON(info->regs));\r\n}\r\nstatic void exynos_adc_s3c2443_start_conv(struct exynos_adc *info,\r\nunsigned long addr)\r\n{\r\nu32 con1;\r\nwritel(addr, ADC_S3C2410_MUX(info->regs));\r\ncon1 = readl(ADC_V1_CON(info->regs));\r\nwritel(con1 | ADC_CON_EN_START, ADC_V1_CON(info->regs));\r\n}\r\nstatic void exynos_adc_s3c64xx_start_conv(struct exynos_adc *info,\r\nunsigned long addr)\r\n{\r\nu32 con1;\r\ncon1 = readl(ADC_V1_CON(info->regs));\r\ncon1 &= ~ADC_S3C2410_CON_SELMUX(0x7);\r\ncon1 |= ADC_S3C2410_CON_SELMUX(addr);\r\nwritel(con1 | ADC_CON_EN_START, ADC_V1_CON(info->regs));\r\n}\r\nstatic void exynos_adc_v2_init_hw(struct exynos_adc *info)\r\n{\r\nu32 con1, con2;\r\nif (info->data->needs_adc_phy)\r\nregmap_write(info->pmu_map, info->data->phy_offset, 1);\r\ncon1 = ADC_V2_CON1_SOFT_RESET;\r\nwritel(con1, ADC_V2_CON1(info->regs));\r\ncon2 = ADC_V2_CON2_OSEL | ADC_V2_CON2_ESEL |\r\nADC_V2_CON2_HIGHF | ADC_V2_CON2_C_TIME(0);\r\nwritel(con2, ADC_V2_CON2(info->regs));\r\nwritel(1, ADC_V2_INT_EN(info->regs));\r\n}\r\nstatic void exynos_adc_v2_exit_hw(struct exynos_adc *info)\r\n{\r\nu32 con;\r\nif (info->data->needs_adc_phy)\r\nregmap_write(info->pmu_map, info->data->phy_offset, 0);\r\ncon = readl(ADC_V2_CON1(info->regs));\r\ncon &= ~ADC_CON_EN_START;\r\nwritel(con, ADC_V2_CON1(info->regs));\r\n}\r\nstatic void exynos_adc_v2_clear_irq(struct exynos_adc *info)\r\n{\r\nwritel(1, ADC_V2_INT_ST(info->regs));\r\n}\r\nstatic void exynos_adc_v2_start_conv(struct exynos_adc *info,\r\nunsigned long addr)\r\n{\r\nu32 con1, con2;\r\ncon2 = readl(ADC_V2_CON2(info->regs));\r\ncon2 &= ~ADC_V2_CON2_ACH_MASK;\r\ncon2 |= ADC_V2_CON2_ACH_SEL(addr);\r\nwritel(con2, ADC_V2_CON2(info->regs));\r\ncon1 = readl(ADC_V2_CON1(info->regs));\r\nwritel(con1 | ADC_CON_EN_START, ADC_V2_CON1(info->regs));\r\n}\r\nstatic void exynos_adc_exynos7_init_hw(struct exynos_adc *info)\r\n{\r\nu32 con1, con2;\r\nif (info->data->needs_adc_phy)\r\nregmap_write(info->pmu_map, info->data->phy_offset, 1);\r\ncon1 = ADC_V2_CON1_SOFT_RESET;\r\nwritel(con1, ADC_V2_CON1(info->regs));\r\ncon2 = readl(ADC_V2_CON2(info->regs));\r\ncon2 &= ~ADC_V2_CON2_C_TIME(7);\r\ncon2 |= ADC_V2_CON2_C_TIME(0);\r\nwritel(con2, ADC_V2_CON2(info->regs));\r\nwritel(1, ADC_V2_INT_EN(info->regs));\r\n}\r\nstatic struct exynos_adc_data *exynos_adc_get_data(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(exynos_adc_match, pdev->dev.of_node);\r\nreturn (struct exynos_adc_data *)match->data;\r\n}\r\nstatic int exynos_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\nunsigned long timeout;\r\nint ret;\r\nif (mask != IIO_CHAN_INFO_RAW)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nreinit_completion(&info->completion);\r\nif (info->data->start_conv)\r\ninfo->data->start_conv(info, chan->address);\r\ntimeout = wait_for_completion_timeout(&info->completion,\r\nEXYNOS_ADC_TIMEOUT);\r\nif (timeout == 0) {\r\ndev_warn(&indio_dev->dev, "Conversion timed out! Resetting\n");\r\nif (info->data->init_hw)\r\ninfo->data->init_hw(info);\r\nret = -ETIMEDOUT;\r\n} else {\r\n*val = info->value;\r\n*val2 = 0;\r\nret = IIO_VAL_INT;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int exynos_read_s3c64xx_ts(struct iio_dev *indio_dev, int *x, int *y)\r\n{\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\nunsigned long timeout;\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\ninfo->read_ts = true;\r\nreinit_completion(&info->completion);\r\nwritel(ADC_S3C2410_TSC_PULL_UP_DISABLE | ADC_TSC_AUTOPST,\r\nADC_V1_TSC(info->regs));\r\ninfo->data->start_conv(info, ADC_S3C2410_MUX_TS);\r\ntimeout = wait_for_completion_timeout(&info->completion,\r\nEXYNOS_ADC_TIMEOUT);\r\nif (timeout == 0) {\r\ndev_warn(&indio_dev->dev, "Conversion timed out! Resetting\n");\r\nif (info->data->init_hw)\r\ninfo->data->init_hw(info);\r\nret = -ETIMEDOUT;\r\n} else {\r\n*x = info->ts_x;\r\n*y = info->ts_y;\r\nret = 0;\r\n}\r\ninfo->read_ts = false;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t exynos_adc_isr(int irq, void *dev_id)\r\n{\r\nstruct exynos_adc *info = (struct exynos_adc *)dev_id;\r\nu32 mask = info->data->mask;\r\nif (info->read_ts) {\r\ninfo->ts_x = readl(ADC_V1_DATX(info->regs));\r\ninfo->ts_y = readl(ADC_V1_DATY(info->regs));\r\nwritel(ADC_TSC_WAIT4INT | ADC_S3C2443_TSC_UD_SEN, ADC_V1_TSC(info->regs));\r\n} else {\r\ninfo->value = readl(ADC_V1_DATX(info->regs)) & mask;\r\n}\r\nif (info->data->clear_irq)\r\ninfo->data->clear_irq(info);\r\ncomplete(&info->completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t exynos_ts_isr(int irq, void *dev_id)\r\n{\r\nstruct exynos_adc *info = dev_id;\r\nstruct iio_dev *dev = dev_get_drvdata(info->dev);\r\nu32 x, y;\r\nbool pressed;\r\nint ret;\r\nwhile (info->input->users) {\r\nret = exynos_read_s3c64xx_ts(dev, &x, &y);\r\nif (ret == -ETIMEDOUT)\r\nbreak;\r\npressed = x & y & ADC_DATX_PRESSED;\r\nif (!pressed) {\r\ninput_report_key(info->input, BTN_TOUCH, 0);\r\ninput_sync(info->input);\r\nbreak;\r\n}\r\ninput_report_abs(info->input, ABS_X, x & ADC_DATX_MASK);\r\ninput_report_abs(info->input, ABS_Y, y & ADC_DATY_MASK);\r\ninput_report_key(info->input, BTN_TOUCH, 1);\r\ninput_sync(info->input);\r\nmsleep(1);\r\n};\r\nwritel(0, ADC_V1_CLRINTPNDNUP(info->regs));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int exynos_adc_reg_access(struct iio_dev *indio_dev,\r\nunsigned reg, unsigned writeval,\r\nunsigned *readval)\r\n{\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\nif (readval == NULL)\r\nreturn -EINVAL;\r\n*readval = readl(info->regs + reg);\r\nreturn 0;\r\n}\r\nstatic int exynos_adc_remove_devices(struct device *dev, void *c)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nplatform_device_unregister(pdev);\r\nreturn 0;\r\n}\r\nstatic int exynos_adc_ts_open(struct input_dev *dev)\r\n{\r\nstruct exynos_adc *info = input_get_drvdata(dev);\r\nenable_irq(info->tsirq);\r\nreturn 0;\r\n}\r\nstatic void exynos_adc_ts_close(struct input_dev *dev)\r\n{\r\nstruct exynos_adc *info = input_get_drvdata(dev);\r\ndisable_irq(info->tsirq);\r\n}\r\nstatic int exynos_adc_ts_init(struct exynos_adc *info)\r\n{\r\nint ret;\r\nif (info->tsirq <= 0)\r\nreturn -ENODEV;\r\ninfo->input = input_allocate_device();\r\nif (!info->input)\r\nreturn -ENOMEM;\r\ninfo->input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninfo->input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(info->input, ABS_X, 0, 0x3FF, 0, 0);\r\ninput_set_abs_params(info->input, ABS_Y, 0, 0x3FF, 0, 0);\r\ninfo->input->name = "S3C24xx TouchScreen";\r\ninfo->input->id.bustype = BUS_HOST;\r\ninfo->input->open = exynos_adc_ts_open;\r\ninfo->input->close = exynos_adc_ts_close;\r\ninput_set_drvdata(info->input, info);\r\nret = input_register_device(info->input);\r\nif (ret) {\r\ninput_free_device(info->input);\r\nreturn ret;\r\n}\r\ndisable_irq(info->tsirq);\r\nret = request_threaded_irq(info->tsirq, NULL, exynos_ts_isr,\r\nIRQF_ONESHOT, "touchscreen", info);\r\nif (ret)\r\ninput_unregister_device(info->input);\r\nreturn ret;\r\n}\r\nstatic int exynos_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct exynos_adc *info = NULL;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct s3c2410_ts_mach_info *pdata = dev_get_platdata(&pdev->dev);\r\nstruct iio_dev *indio_dev = NULL;\r\nstruct resource *mem;\r\nbool has_ts = false;\r\nint ret = -ENODEV;\r\nint irq;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(struct exynos_adc));\r\nif (!indio_dev) {\r\ndev_err(&pdev->dev, "failed allocating iio device\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo = iio_priv(indio_dev);\r\ninfo->data = exynos_adc_get_data(pdev);\r\nif (!info->data) {\r\ndev_err(&pdev->dev, "failed getting exynos_adc_data\n");\r\nreturn -EINVAL;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(info->regs))\r\nreturn PTR_ERR(info->regs);\r\nif (info->data->needs_adc_phy) {\r\ninfo->pmu_map = syscon_regmap_lookup_by_phandle(\r\npdev->dev.of_node,\r\n"samsung,syscon-phandle");\r\nif (IS_ERR(info->pmu_map)) {\r\ndev_err(&pdev->dev, "syscon regmap lookup failed.\n");\r\nreturn PTR_ERR(info->pmu_map);\r\n}\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn irq;\r\n}\r\ninfo->irq = irq;\r\nirq = platform_get_irq(pdev, 1);\r\nif (irq == -EPROBE_DEFER)\r\nreturn irq;\r\ninfo->tsirq = irq;\r\ninfo->dev = &pdev->dev;\r\ninit_completion(&info->completion);\r\ninfo->clk = devm_clk_get(&pdev->dev, "adc");\r\nif (IS_ERR(info->clk)) {\r\ndev_err(&pdev->dev, "failed getting clock, err = %ld\n",\r\nPTR_ERR(info->clk));\r\nreturn PTR_ERR(info->clk);\r\n}\r\nif (info->data->needs_sclk) {\r\ninfo->sclk = devm_clk_get(&pdev->dev, "sclk");\r\nif (IS_ERR(info->sclk)) {\r\ndev_err(&pdev->dev,\r\n"failed getting sclk clock, err = %ld\n",\r\nPTR_ERR(info->sclk));\r\nreturn PTR_ERR(info->sclk);\r\n}\r\n}\r\ninfo->vdd = devm_regulator_get(&pdev->dev, "vdd");\r\nif (IS_ERR(info->vdd)) {\r\ndev_err(&pdev->dev, "failed getting regulator, err = %ld\n",\r\nPTR_ERR(info->vdd));\r\nreturn PTR_ERR(info->vdd);\r\n}\r\nret = regulator_enable(info->vdd);\r\nif (ret)\r\nreturn ret;\r\nret = exynos_adc_prepare_clk(info);\r\nif (ret)\r\ngoto err_disable_reg;\r\nret = exynos_adc_enable_clk(info);\r\nif (ret)\r\ngoto err_unprepare_clk;\r\nplatform_set_drvdata(pdev, indio_dev);\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nindio_dev->info = &exynos_adc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = exynos_adc_iio_channels;\r\nindio_dev->num_channels = info->data->num_channels;\r\nret = request_irq(info->irq, exynos_adc_isr,\r\n0, dev_name(&pdev->dev), info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed requesting irq, irq = %d\n",\r\ninfo->irq);\r\ngoto err_disable_clk;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto err_irq;\r\nif (info->data->init_hw)\r\ninfo->data->init_hw(info);\r\nif (IS_REACHABLE(CONFIG_INPUT)) {\r\nhas_ts = of_property_read_bool(pdev->dev.of_node,\r\n"has-touchscreen") || pdata;\r\n}\r\nif (pdata)\r\ninfo->delay = pdata->delay;\r\nelse\r\ninfo->delay = 10000;\r\nif (has_ts)\r\nret = exynos_adc_ts_init(info);\r\nif (ret)\r\ngoto err_iio;\r\nret = of_platform_populate(np, exynos_adc_match, NULL, &indio_dev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed adding child nodes\n");\r\ngoto err_of_populate;\r\n}\r\nreturn 0;\r\nerr_of_populate:\r\ndevice_for_each_child(&indio_dev->dev, NULL,\r\nexynos_adc_remove_devices);\r\nif (has_ts) {\r\ninput_unregister_device(info->input);\r\nfree_irq(info->tsirq, info);\r\n}\r\nerr_iio:\r\niio_device_unregister(indio_dev);\r\nerr_irq:\r\nfree_irq(info->irq, info);\r\nerr_disable_clk:\r\nif (info->data->exit_hw)\r\ninfo->data->exit_hw(info);\r\nexynos_adc_disable_clk(info);\r\nerr_unprepare_clk:\r\nexynos_adc_unprepare_clk(info);\r\nerr_disable_reg:\r\nregulator_disable(info->vdd);\r\nreturn ret;\r\n}\r\nstatic int exynos_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\nif (IS_REACHABLE(CONFIG_INPUT)) {\r\nfree_irq(info->tsirq, info);\r\ninput_unregister_device(info->input);\r\n}\r\ndevice_for_each_child(&indio_dev->dev, NULL,\r\nexynos_adc_remove_devices);\r\niio_device_unregister(indio_dev);\r\nfree_irq(info->irq, info);\r\nif (info->data->exit_hw)\r\ninfo->data->exit_hw(info);\r\nexynos_adc_disable_clk(info);\r\nexynos_adc_unprepare_clk(info);\r\nregulator_disable(info->vdd);\r\nreturn 0;\r\n}\r\nstatic int exynos_adc_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\nif (info->data->exit_hw)\r\ninfo->data->exit_hw(info);\r\nexynos_adc_disable_clk(info);\r\nregulator_disable(info->vdd);\r\nreturn 0;\r\n}\r\nstatic int exynos_adc_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\nint ret;\r\nret = regulator_enable(info->vdd);\r\nif (ret)\r\nreturn ret;\r\nret = exynos_adc_enable_clk(info);\r\nif (ret)\r\nreturn ret;\r\nif (info->data->init_hw)\r\ninfo->data->init_hw(info);\r\nreturn 0;\r\n}
