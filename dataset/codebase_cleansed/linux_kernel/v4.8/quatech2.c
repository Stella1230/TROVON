static void qt2_release(struct usb_serial *serial)\r\n{\r\nstruct qt2_serial_private *serial_priv;\r\nserial_priv = usb_get_serial_data(serial);\r\nusb_kill_urb(serial_priv->read_urb);\r\nusb_free_urb(serial_priv->read_urb);\r\nkfree(serial_priv->read_buffer);\r\nkfree(serial_priv);\r\n}\r\nstatic inline int calc_baud_divisor(int baudrate)\r\n{\r\nint divisor, rem;\r\ndivisor = MAX_BAUD_RATE / baudrate;\r\nrem = MAX_BAUD_RATE % baudrate;\r\nif (((rem * 2) >= baudrate) && (baudrate != 110))\r\ndivisor++;\r\nreturn divisor;\r\n}\r\nstatic inline int qt2_set_port_config(struct usb_device *dev,\r\nunsigned char port_number,\r\nu16 baudrate, u16 lcr)\r\n{\r\nint divisor = calc_baud_divisor(baudrate);\r\nu16 index = ((u16) (lcr << 8) | (u16) (port_number));\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nQT2_GET_SET_UART, 0x40,\r\ndivisor, index, NULL, 0, QT2_USB_TIMEOUT);\r\n}\r\nstatic inline int qt2_control_msg(struct usb_device *dev,\r\nu8 request, u16 data, u16 index)\r\n{\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nrequest, 0x40, data, index,\r\nNULL, 0, QT2_USB_TIMEOUT);\r\n}\r\nstatic inline int qt2_setdevice(struct usb_device *dev, u8 *data)\r\n{\r\nu16 x = ((u16) (data[1] << 8) | (u16) (data[0]));\r\nreturn qt2_control_msg(dev, QT_SET_GET_DEVICE, x, 0);\r\n}\r\nstatic inline int qt2_getdevice(struct usb_device *dev, u8 *data)\r\n{\r\nreturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nQT_SET_GET_DEVICE, 0xc0, 0, 0,\r\ndata, 3, QT2_USB_TIMEOUT);\r\n}\r\nstatic inline int qt2_getregister(struct usb_device *dev,\r\nu8 uart,\r\nu8 reg,\r\nu8 *data)\r\n{\r\nreturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nQT_SET_GET_REGISTER, 0xc0, reg,\r\nuart, data, sizeof(*data), QT2_USB_TIMEOUT);\r\n}\r\nstatic inline int qt2_setregister(struct usb_device *dev,\r\nu8 uart, u8 reg, u16 data)\r\n{\r\nu16 value = (data << 8) | reg;\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nQT_SET_GET_REGISTER, 0x40, value, uart,\r\nNULL, 0, QT2_USB_TIMEOUT);\r\n}\r\nstatic inline int update_mctrl(struct qt2_port_private *port_priv,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = port_priv->port;\r\nstruct usb_device *dev = port->serial->dev;\r\nunsigned urb_value;\r\nint status;\r\nif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0) {\r\ndev_dbg(&port->dev,\r\n"update_mctrl - DTR|RTS not being set|cleared\n");\r\nreturn 0;\r\n}\r\nclear &= ~set;\r\nurb_value = 0;\r\nif (set & TIOCM_DTR)\r\nurb_value |= UART_MCR_DTR;\r\nif (set & TIOCM_RTS)\r\nurb_value |= UART_MCR_RTS;\r\nstatus = qt2_setregister(dev, port_priv->device_port, UART_MCR,\r\nurb_value);\r\nif (status < 0)\r\ndev_err(&port->dev,\r\n"update_mctrl - Error from MODEM_CTRL urb: %i\n",\r\nstatus);\r\nreturn status;\r\n}\r\nstatic int qt2_calc_num_ports(struct usb_serial *serial)\r\n{\r\nstruct qt2_device_detail d;\r\nint i;\r\nfor (i = 0; d = qt2_device_details[i], d.product_id != 0; i++) {\r\nif (d.product_id == le16_to_cpu(serial->dev->descriptor.idProduct))\r\nreturn d.num_ports;\r\n}\r\ndev_err(&serial->dev->dev,\r\n"don't know the number of ports, assuming 1\n");\r\nreturn 1;\r\n}\r\nstatic void qt2_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nstruct qt2_port_private *port_priv;\r\nstruct ktermios *termios = &tty->termios;\r\nu16 baud;\r\nunsigned int cflag = termios->c_cflag;\r\nu16 new_lcr = 0;\r\nint status;\r\nport_priv = usb_get_serial_port_data(port);\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\nnew_lcr |= UART_LCR_PARITY;\r\nelse\r\nnew_lcr |= SERIAL_EVEN_PARITY;\r\n}\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nnew_lcr |= UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\nnew_lcr |= UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\nnew_lcr |= UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nnew_lcr |= UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\nstatus = qt2_set_port_config(dev, port_priv->device_port, baud,\r\nnew_lcr);\r\nif (status < 0)\r\ndev_err(&port->dev, "%s - qt2_set_port_config failed: %i\n",\r\n__func__, status);\r\nif (cflag & CRTSCTS)\r\nstatus = qt2_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,\r\nSERIAL_CRTSCTS,\r\nport_priv->device_port);\r\nelse\r\nstatus = qt2_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,\r\n0, port_priv->device_port);\r\nif (status < 0)\r\ndev_err(&port->dev, "%s - set HW flow control failed: %i\n",\r\n__func__, status);\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\nu16 x = ((u16) (START_CHAR(tty) << 8) | (u16) (STOP_CHAR(tty)));\r\nstatus = qt2_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,\r\nx, port_priv->device_port);\r\n} else\r\nstatus = qt2_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,\r\n0, port_priv->device_port);\r\nif (status < 0)\r\ndev_err(&port->dev, "%s - set SW flow control failed: %i\n",\r\n__func__, status);\r\n}\r\nstatic int qt2_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct qt2_port_private *port_priv;\r\nu8 *data;\r\nu16 device_port;\r\nint status;\r\nunsigned long flags;\r\ndevice_port = port->port_number;\r\nserial = port->serial;\r\nport_priv = usb_get_serial_port_data(port);\r\nstatus = qt2_control_msg(serial->dev, QT2_GET_SET_QMCR,\r\nQT2_QMCR_RS232, device_port);\r\nif (status < 0) {\r\ndev_err(&port->dev,\r\n"%s failed to set RS232 mode for port %i error %i\n",\r\n__func__, device_port, status);\r\nreturn status;\r\n}\r\ndata = kzalloc(2, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nstatus = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0),\r\nQT_OPEN_CLOSE_CHANNEL,\r\n0xc0, 0,\r\ndevice_port, data, 2, QT2_USB_TIMEOUT);\r\nif (status < 0) {\r\ndev_err(&port->dev, "%s - open port failed %i\n", __func__,\r\nstatus);\r\nkfree(data);\r\nreturn status;\r\n}\r\nspin_lock_irqsave(&port_priv->lock, flags);\r\nport_priv->shadowLSR = data[0];\r\nport_priv->shadowMSR = data[1];\r\nspin_unlock_irqrestore(&port_priv->lock, flags);\r\nkfree(data);\r\nstatus = qt2_set_port_config(serial->dev, device_port,\r\nDEFAULT_BAUD_RATE, UART_LCR_WLEN8);\r\nif (status < 0) {\r\ndev_err(&port->dev, "%s - initial setup failed (%i)\n",\r\n__func__, device_port);\r\nreturn status;\r\n}\r\nport_priv->device_port = (u8) device_port;\r\nif (tty)\r\nqt2_set_termios(tty, port, &tty->termios);\r\nreturn 0;\r\n}\r\nstatic void qt2_close(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct qt2_port_private *port_priv;\r\nunsigned long flags;\r\nint i;\r\nserial = port->serial;\r\nport_priv = usb_get_serial_port_data(port);\r\nspin_lock_irqsave(&port_priv->urb_lock, flags);\r\nusb_kill_urb(port_priv->write_urb);\r\nport_priv->urb_in_use = false;\r\nspin_unlock_irqrestore(&port_priv->urb_lock, flags);\r\ni = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0),\r\nQT2_FLUSH_DEVICE, 0x40, 1,\r\nport_priv->device_port, NULL, 0, QT2_USB_TIMEOUT);\r\nif (i < 0)\r\ndev_err(&port->dev, "%s - transmit buffer flush failed: %i\n",\r\n__func__, i);\r\ni = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0),\r\nQT2_FLUSH_DEVICE, 0x40, 0,\r\nport_priv->device_port, NULL, 0, QT2_USB_TIMEOUT);\r\nif (i < 0)\r\ndev_err(&port->dev, "%s - receive buffer flush failed: %i\n",\r\n__func__, i);\r\ni = usb_control_msg(serial->dev,\r\nusb_sndctrlpipe(serial->dev, 0),\r\nQT_OPEN_CLOSE_CHANNEL,\r\n0x40, 0,\r\nport_priv->device_port, NULL, 0, QT2_USB_TIMEOUT);\r\nif (i < 0)\r\ndev_err(&port->dev, "%s - close port failed %i\n",\r\n__func__, i);\r\n}\r\nstatic void qt2_disconnect(struct usb_serial *serial)\r\n{\r\nstruct qt2_serial_private *serial_priv = usb_get_serial_data(serial);\r\nusb_kill_urb(serial_priv->read_urb);\r\n}\r\nstatic int get_serial_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.line = port->minor;\r\ntmp.port = 0;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = port->bulk_out_size;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5*HZ;\r\ntmp.closing_wait = 30*HZ;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int qt2_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(port,\r\n(struct serial_struct __user *)arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void qt2_process_status(struct usb_serial_port *port, unsigned char *ch)\r\n{\r\nswitch (*ch) {\r\ncase QT2_LINE_STATUS:\r\nqt2_update_lsr(port, ch + 1);\r\nbreak;\r\ncase QT2_MODEM_STATUS:\r\nqt2_update_msr(port, ch + 1);\r\nbreak;\r\n}\r\n}\r\nstatic void qt2_process_xmit_empty(struct usb_serial_port *port,\r\nunsigned char *ch)\r\n{\r\nint bytes_written;\r\nbytes_written = (int)(*ch) + (int)(*(ch + 1) << 4);\r\n}\r\nstatic void qt2_process_flush(struct usb_serial_port *port, unsigned char *ch)\r\n{\r\nreturn;\r\n}\r\nstatic void qt2_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial *serial;\r\nstruct qt2_serial_private *serial_priv;\r\nstruct usb_serial_port *port;\r\nstruct qt2_port_private *port_priv;\r\nbool escapeflag;\r\nunsigned char *ch;\r\nint i;\r\nunsigned char newport;\r\nint len = urb->actual_length;\r\nif (!len)\r\nreturn;\r\nch = urb->transfer_buffer;\r\nserial = urb->context;\r\nserial_priv = usb_get_serial_data(serial);\r\nport = serial->port[serial_priv->current_port];\r\nport_priv = usb_get_serial_port_data(port);\r\nfor (i = 0; i < urb->actual_length; i++) {\r\nch = (unsigned char *)urb->transfer_buffer + i;\r\nif ((i <= (len - 3)) &&\r\n(*ch == QT2_CONTROL_BYTE) &&\r\n(*(ch + 1) == QT2_CONTROL_BYTE)) {\r\nescapeflag = false;\r\nswitch (*(ch + 2)) {\r\ncase QT2_LINE_STATUS:\r\ncase QT2_MODEM_STATUS:\r\nif (i > (len - 4)) {\r\ndev_warn(&port->dev,\r\n"%s - status message too short\n",\r\n__func__);\r\nbreak;\r\n}\r\nqt2_process_status(port, ch + 2);\r\ni += 3;\r\nescapeflag = true;\r\nbreak;\r\ncase QT2_XMIT_HOLD:\r\nif (i > (len - 5)) {\r\ndev_warn(&port->dev,\r\n"%s - xmit_empty message too short\n",\r\n__func__);\r\nbreak;\r\n}\r\nqt2_process_xmit_empty(port, ch + 3);\r\ni += 4;\r\nescapeflag = true;\r\nbreak;\r\ncase QT2_CHANGE_PORT:\r\nif (i > (len - 4)) {\r\ndev_warn(&port->dev,\r\n"%s - change_port message too short\n",\r\n__func__);\r\nbreak;\r\n}\r\ntty_flip_buffer_push(&port->port);\r\nnewport = *(ch + 3);\r\nif (newport > serial->num_ports) {\r\ndev_err(&port->dev,\r\n"%s - port change to invalid port: %i\n",\r\n__func__, newport);\r\nbreak;\r\n}\r\nserial_priv->current_port = newport;\r\nport = serial->port[serial_priv->current_port];\r\nport_priv = usb_get_serial_port_data(port);\r\ni += 3;\r\nescapeflag = true;\r\nbreak;\r\ncase QT2_REC_FLUSH:\r\ncase QT2_XMIT_FLUSH:\r\nqt2_process_flush(port, ch + 2);\r\ni += 2;\r\nescapeflag = true;\r\nbreak;\r\ncase QT2_CONTROL_ESCAPE:\r\ntty_buffer_request_room(&port->port, 2);\r\ntty_insert_flip_string(&port->port, ch, 2);\r\ni += 2;\r\nescapeflag = true;\r\nbreak;\r\ndefault:\r\ndev_warn(&port->dev,\r\n"%s - unsupported command %i\n",\r\n__func__, *(ch + 2));\r\nbreak;\r\n}\r\nif (escapeflag)\r\ncontinue;\r\n}\r\ntty_buffer_request_room(&port->port, 1);\r\ntty_insert_flip_string(&port->port, ch, 1);\r\n}\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic void qt2_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct qt2_port_private *port_priv;\r\nport = urb->context;\r\nport_priv = usb_get_serial_port_data(port);\r\nspin_lock(&port_priv->urb_lock);\r\nport_priv->urb_in_use = false;\r\nusb_serial_port_softint(port);\r\nspin_unlock(&port_priv->urb_lock);\r\n}\r\nstatic void qt2_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial *serial = urb->context;\r\nint status;\r\nif (urb->status) {\r\ndev_warn(&serial->dev->dev,\r\n"%s - non-zero urb status: %i\n", __func__,\r\nurb->status);\r\nreturn;\r\n}\r\nqt2_process_read_urb(urb);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status != 0)\r\ndev_err(&serial->dev->dev,\r\n"%s - resubmit read urb failed: %i\n",\r\n__func__, status);\r\n}\r\nstatic int qt2_setup_urbs(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port0;\r\nstruct qt2_serial_private *serial_priv;\r\nint status;\r\nport0 = serial->port[0];\r\nserial_priv = usb_get_serial_data(serial);\r\nserial_priv->read_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!serial_priv->read_urb)\r\nreturn -ENOMEM;\r\nusb_fill_bulk_urb(serial_priv->read_urb, serial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport0->bulk_in_endpointAddress),\r\nserial_priv->read_buffer,\r\nQT2_READ_BUFFER_SIZE,\r\nqt2_read_bulk_callback, serial);\r\nstatus = usb_submit_urb(serial_priv->read_urb, GFP_KERNEL);\r\nif (status != 0) {\r\ndev_err(&serial->dev->dev,\r\n"%s - submit read urb failed %i\n", __func__, status);\r\nusb_free_urb(serial_priv->read_urb);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qt2_attach(struct usb_serial *serial)\r\n{\r\nstruct qt2_serial_private *serial_priv;\r\nint status;\r\nstatus = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\n0xc2, 0x40, 0x8000, 0, NULL, 0,\r\nQT2_USB_TIMEOUT);\r\nif (status < 0) {\r\ndev_err(&serial->dev->dev,\r\n"%s - failed to power on unit: %i\n", __func__, status);\r\nreturn status;\r\n}\r\nserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\r\nif (!serial_priv)\r\nreturn -ENOMEM;\r\nserial_priv->read_buffer = kmalloc(QT2_READ_BUFFER_SIZE, GFP_KERNEL);\r\nif (!serial_priv->read_buffer) {\r\nstatus = -ENOMEM;\r\ngoto err_buf;\r\n}\r\nusb_set_serial_data(serial, serial_priv);\r\nstatus = qt2_setup_urbs(serial);\r\nif (status != 0)\r\ngoto attach_failed;\r\nreturn 0;\r\nattach_failed:\r\nkfree(serial_priv->read_buffer);\r\nerr_buf:\r\nkfree(serial_priv);\r\nreturn status;\r\n}\r\nstatic int qt2_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct qt2_port_private *port_priv;\r\nu8 bEndpointAddress;\r\nport_priv = kzalloc(sizeof(*port_priv), GFP_KERNEL);\r\nif (!port_priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&port_priv->lock);\r\nspin_lock_init(&port_priv->urb_lock);\r\nport_priv->port = port;\r\nport_priv->write_buffer = kmalloc(QT2_WRITE_BUFFER_SIZE, GFP_KERNEL);\r\nif (!port_priv->write_buffer)\r\ngoto err_buf;\r\nport_priv->write_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!port_priv->write_urb)\r\ngoto err_urb;\r\nbEndpointAddress = serial->port[0]->bulk_out_endpointAddress;\r\nusb_fill_bulk_urb(port_priv->write_urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev, bEndpointAddress),\r\nport_priv->write_buffer,\r\nQT2_WRITE_BUFFER_SIZE,\r\nqt2_write_bulk_callback, port);\r\nusb_set_serial_port_data(port, port_priv);\r\nreturn 0;\r\nerr_urb:\r\nkfree(port_priv->write_buffer);\r\nerr_buf:\r\nkfree(port_priv);\r\nreturn -ENOMEM;\r\n}\r\nstatic int qt2_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct qt2_port_private *port_priv;\r\nport_priv = usb_get_serial_port_data(port);\r\nusb_free_urb(port_priv->write_urb);\r\nkfree(port_priv->write_buffer);\r\nkfree(port_priv);\r\nreturn 0;\r\n}\r\nstatic int qt2_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_device *dev = port->serial->dev;\r\nstruct qt2_port_private *port_priv = usb_get_serial_port_data(port);\r\nu8 *d;\r\nint r;\r\nd = kzalloc(2, GFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nr = qt2_getregister(dev, port_priv->device_port, UART_MCR, d);\r\nif (r < 0)\r\ngoto mget_out;\r\nr = qt2_getregister(dev, port_priv->device_port, UART_MSR, d + 1);\r\nif (r < 0)\r\ngoto mget_out;\r\nr = (d[0] & UART_MCR_DTR ? TIOCM_DTR : 0) |\r\n(d[0] & UART_MCR_RTS ? TIOCM_RTS : 0) |\r\n(d[1] & UART_MSR_CTS ? TIOCM_CTS : 0) |\r\n(d[1] & UART_MSR_DCD ? TIOCM_CAR : 0) |\r\n(d[1] & UART_MSR_RI ? TIOCM_RI : 0) |\r\n(d[1] & UART_MSR_DSR ? TIOCM_DSR : 0);\r\nmget_out:\r\nkfree(d);\r\nreturn r;\r\n}\r\nstatic int qt2_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct qt2_port_private *port_priv;\r\nport_priv = usb_get_serial_port_data(tty->driver_data);\r\nreturn update_mctrl(port_priv, set, clear);\r\n}\r\nstatic void qt2_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct qt2_port_private *port_priv;\r\nint status;\r\nu16 val;\r\nport_priv = usb_get_serial_port_data(port);\r\nval = (break_state == -1) ? 1 : 0;\r\nstatus = qt2_control_msg(port->serial->dev, QT2_BREAK_CONTROL,\r\nval, port_priv->device_port);\r\nif (status < 0)\r\ndev_warn(&port->dev,\r\n"%s - failed to send control message: %i\n", __func__,\r\nstatus);\r\n}\r\nstatic void qt2_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nstruct qt2_port_private *port_priv = usb_get_serial_port_data(port);\r\nif (!on) {\r\nif (qt2_setregister(dev, port_priv->device_port,\r\nUART_MCR, 0) < 0)\r\ndev_warn(&port->dev, "error from flowcontrol urb\n");\r\n}\r\nif (on)\r\nupdate_mctrl(port_priv, TIOCM_DTR | TIOCM_RTS, 0);\r\nelse\r\nupdate_mctrl(port_priv, 0, TIOCM_DTR | TIOCM_RTS);\r\n}\r\nstatic void qt2_update_msr(struct usb_serial_port *port, unsigned char *ch)\r\n{\r\nstruct qt2_port_private *port_priv;\r\nu8 newMSR = (u8) *ch;\r\nunsigned long flags;\r\nport_priv = usb_get_serial_port_data(port);\r\nspin_lock_irqsave(&port_priv->lock, flags);\r\nport_priv->shadowMSR = newMSR;\r\nspin_unlock_irqrestore(&port_priv->lock, flags);\r\nif (newMSR & UART_MSR_ANY_DELTA) {\r\nif (newMSR & UART_MSR_DCTS)\r\nport->icount.cts++;\r\nif (newMSR & UART_MSR_DDSR)\r\nport->icount.dsr++;\r\nif (newMSR & UART_MSR_DDCD)\r\nport->icount.dcd++;\r\nif (newMSR & UART_MSR_TERI)\r\nport->icount.rng++;\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\n}\r\n}\r\nstatic void qt2_update_lsr(struct usb_serial_port *port, unsigned char *ch)\r\n{\r\nstruct qt2_port_private *port_priv;\r\nstruct async_icount *icount;\r\nunsigned long flags;\r\nu8 newLSR = (u8) *ch;\r\nport_priv = usb_get_serial_port_data(port);\r\nif (newLSR & UART_LSR_BI)\r\nnewLSR &= (u8) (UART_LSR_OE | UART_LSR_BI);\r\nspin_lock_irqsave(&port_priv->lock, flags);\r\nport_priv->shadowLSR = newLSR;\r\nspin_unlock_irqrestore(&port_priv->lock, flags);\r\nicount = &port->icount;\r\nif (newLSR & UART_LSR_BRK_ERROR_BITS) {\r\nif (newLSR & UART_LSR_BI)\r\nicount->brk++;\r\nif (newLSR & UART_LSR_OE)\r\nicount->overrun++;\r\nif (newLSR & UART_LSR_PE)\r\nicount->parity++;\r\nif (newLSR & UART_LSR_FE)\r\nicount->frame++;\r\n}\r\n}\r\nstatic int qt2_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct qt2_port_private *port_priv;\r\nunsigned long flags = 0;\r\nint r;\r\nport_priv = usb_get_serial_port_data(port);\r\nspin_lock_irqsave(&port_priv->urb_lock, flags);\r\nif (port_priv->urb_in_use)\r\nr = 0;\r\nelse\r\nr = QT2_WRITE_BUFFER_SIZE - QT2_WRITE_CONTROL_SIZE;\r\nspin_unlock_irqrestore(&port_priv->urb_lock, flags);\r\nreturn r;\r\n}\r\nstatic int qt2_write(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct qt2_port_private *port_priv;\r\nstruct urb *write_urb;\r\nunsigned char *data;\r\nunsigned long flags;\r\nint status;\r\nint bytes_out = 0;\r\nport_priv = usb_get_serial_port_data(port);\r\nif (port_priv->write_urb == NULL) {\r\ndev_err(&port->dev, "%s - no output urb\n", __func__);\r\nreturn 0;\r\n}\r\nwrite_urb = port_priv->write_urb;\r\ncount = min(count, QT2_WRITE_BUFFER_SIZE - QT2_WRITE_CONTROL_SIZE);\r\ndata = write_urb->transfer_buffer;\r\nspin_lock_irqsave(&port_priv->urb_lock, flags);\r\nif (port_priv->urb_in_use) {\r\ndev_err(&port->dev, "qt2_write - urb is in use\n");\r\ngoto write_out;\r\n}\r\n*data++ = QT2_CONTROL_BYTE;\r\n*data++ = QT2_CONTROL_BYTE;\r\n*data++ = port_priv->device_port;\r\nput_unaligned_le16(count, data);\r\ndata += 2;\r\nmemcpy(data, buf, count);\r\nwrite_urb->transfer_buffer_length = count + QT2_WRITE_CONTROL_SIZE;\r\nstatus = usb_submit_urb(write_urb, GFP_ATOMIC);\r\nif (status == 0) {\r\nport_priv->urb_in_use = true;\r\nbytes_out += count;\r\n}\r\nwrite_out:\r\nspin_unlock_irqrestore(&port_priv->urb_lock, flags);\r\nreturn bytes_out;\r\n}
