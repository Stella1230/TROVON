static int s5p_mfc_alloc_dec_temp_buffers_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf_size_v5 *buf_size = dev->variant->buf_size->priv;\r\nint ret;\r\nctx->dsc.size = buf_size->dsc;\r\nret = s5p_mfc_alloc_priv_buf(dev->mem_dev_l, &ctx->dsc);\r\nif (ret) {\r\nmfc_err("Failed to allocate temporary buffer\n");\r\nreturn ret;\r\n}\r\nBUG_ON(ctx->dsc.dma & ((1 << MFC_BANK1_ALIGN_ORDER) - 1));\r\nmemset(ctx->dsc.virt, 0, ctx->dsc.size);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_release_dec_desc_buffer_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\ns5p_mfc_release_priv_buf(ctx->dev->mem_dev_l, &ctx->dsc);\r\n}\r\nstatic int s5p_mfc_alloc_codec_buffers_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned int enc_ref_y_size = 0;\r\nunsigned int enc_ref_c_size = 0;\r\nunsigned int guard_width, guard_height;\r\nint ret;\r\nif (ctx->type == MFCINST_DECODER) {\r\nmfc_debug(2, "Luma size:%d Chroma size:%d MV size:%d\n",\r\nctx->luma_size, ctx->chroma_size, ctx->mv_size);\r\nmfc_debug(2, "Totals bufs: %d\n", ctx->total_dpb_count);\r\n} else if (ctx->type == MFCINST_ENCODER) {\r\nenc_ref_y_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\r\n* ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_y_size = ALIGN(enc_ref_y_size, S5P_FIMV_NV12MT_SALIGN);\r\nif (ctx->codec_mode == S5P_MFC_CODEC_H264_ENC) {\r\nenc_ref_c_size = ALIGN(ctx->img_width,\r\nS5P_FIMV_NV12MT_HALIGN)\r\n* ALIGN(ctx->img_height >> 1,\r\nS5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_c_size = ALIGN(enc_ref_c_size,\r\nS5P_FIMV_NV12MT_SALIGN);\r\n} else {\r\nguard_width = ALIGN(ctx->img_width + 16,\r\nS5P_FIMV_NV12MT_HALIGN);\r\nguard_height = ALIGN((ctx->img_height >> 1) + 4,\r\nS5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_c_size = ALIGN(guard_width * guard_height,\r\nS5P_FIMV_NV12MT_SALIGN);\r\n}\r\nmfc_debug(2, "recon luma size: %d chroma size: %d\n",\r\nenc_ref_y_size, enc_ref_c_size);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nswitch (ctx->codec_mode) {\r\ncase S5P_MFC_CODEC_H264_DEC:\r\nctx->bank1.size =\r\nALIGN(S5P_FIMV_DEC_NB_IP_SIZE +\r\nS5P_FIMV_DEC_VERT_NB_MV_SIZE,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->bank2.size = ctx->total_dpb_count * ctx->mv_size;\r\nbreak;\r\ncase S5P_MFC_CODEC_MPEG4_DEC:\r\nctx->bank1.size =\r\nALIGN(S5P_FIMV_DEC_NB_DCAC_SIZE +\r\nS5P_FIMV_DEC_UPNB_MV_SIZE +\r\nS5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE +\r\nS5P_FIMV_DEC_STX_PARSER_SIZE +\r\nS5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->bank2.size = 0;\r\nbreak;\r\ncase S5P_MFC_CODEC_VC1RCV_DEC:\r\ncase S5P_MFC_CODEC_VC1_DEC:\r\nctx->bank1.size =\r\nALIGN(S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE +\r\nS5P_FIMV_DEC_UPNB_MV_SIZE +\r\nS5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE +\r\nS5P_FIMV_DEC_NB_DCAC_SIZE +\r\n3 * S5P_FIMV_DEC_VC1_BITPLANE_SIZE,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->bank2.size = 0;\r\nbreak;\r\ncase S5P_MFC_CODEC_MPEG2_DEC:\r\nctx->bank1.size = 0;\r\nctx->bank2.size = 0;\r\nbreak;\r\ncase S5P_MFC_CODEC_H263_DEC:\r\nctx->bank1.size =\r\nALIGN(S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE +\r\nS5P_FIMV_DEC_UPNB_MV_SIZE +\r\nS5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE +\r\nS5P_FIMV_DEC_NB_DCAC_SIZE,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->bank2.size = 0;\r\nbreak;\r\ncase S5P_MFC_CODEC_H264_ENC:\r\nctx->bank1.size = (enc_ref_y_size * 2) +\r\nS5P_FIMV_ENC_UPMV_SIZE +\r\nS5P_FIMV_ENC_COLFLG_SIZE +\r\nS5P_FIMV_ENC_INTRAMD_SIZE +\r\nS5P_FIMV_ENC_NBORINFO_SIZE;\r\nctx->bank2.size = (enc_ref_y_size * 2) +\r\n(enc_ref_c_size * 4) +\r\nS5P_FIMV_ENC_INTRAPRED_SIZE;\r\nbreak;\r\ncase S5P_MFC_CODEC_MPEG4_ENC:\r\nctx->bank1.size = (enc_ref_y_size * 2) +\r\nS5P_FIMV_ENC_UPMV_SIZE +\r\nS5P_FIMV_ENC_COLFLG_SIZE +\r\nS5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nctx->bank2.size = (enc_ref_y_size * 2) +\r\n(enc_ref_c_size * 4);\r\nbreak;\r\ncase S5P_MFC_CODEC_H263_ENC:\r\nctx->bank1.size = (enc_ref_y_size * 2) +\r\nS5P_FIMV_ENC_UPMV_SIZE +\r\nS5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nctx->bank2.size = (enc_ref_y_size * 2) +\r\n(enc_ref_c_size * 4);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ctx->bank1.size > 0) {\r\nret = s5p_mfc_alloc_priv_buf(dev->mem_dev_l, &ctx->bank1);\r\nif (ret) {\r\nmfc_err("Failed to allocate Bank1 temporary buffer\n");\r\nreturn ret;\r\n}\r\nBUG_ON(ctx->bank1.dma & ((1 << MFC_BANK1_ALIGN_ORDER) - 1));\r\n}\r\nif (ctx->bank2.size > 0) {\r\nret = s5p_mfc_alloc_priv_buf(dev->mem_dev_r, &ctx->bank2);\r\nif (ret) {\r\nmfc_err("Failed to allocate Bank2 temporary buffer\n");\r\ns5p_mfc_release_priv_buf(ctx->dev->mem_dev_l, &ctx->bank1);\r\nreturn ret;\r\n}\r\nBUG_ON(ctx->bank2.dma & ((1 << MFC_BANK2_ALIGN_ORDER) - 1));\r\n}\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_release_codec_buffers_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\ns5p_mfc_release_priv_buf(ctx->dev->mem_dev_l, &ctx->bank1);\r\ns5p_mfc_release_priv_buf(ctx->dev->mem_dev_r, &ctx->bank2);\r\n}\r\nstatic int s5p_mfc_alloc_instance_buffer_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf_size_v5 *buf_size = dev->variant->buf_size->priv;\r\nint ret;\r\nif (ctx->codec_mode == S5P_MFC_CODEC_H264_DEC ||\r\nctx->codec_mode == S5P_MFC_CODEC_H264_ENC)\r\nctx->ctx.size = buf_size->h264_ctx;\r\nelse\r\nctx->ctx.size = buf_size->non_h264_ctx;\r\nret = s5p_mfc_alloc_priv_buf(dev->mem_dev_l, &ctx->ctx);\r\nif (ret) {\r\nmfc_err("Failed to allocate instance buffer\n");\r\nreturn ret;\r\n}\r\nctx->ctx.ofs = OFFSETA(ctx->ctx.dma);\r\nmemset(ctx->ctx.virt, 0, ctx->ctx.size);\r\nwmb();\r\nctx->shm.size = buf_size->shm;\r\nret = s5p_mfc_alloc_priv_buf(dev->mem_dev_l, &ctx->shm);\r\nif (ret) {\r\nmfc_err("Failed to allocate shared memory buffer\n");\r\nreturn ret;\r\n}\r\nctx->shm.ofs = ctx->shm.dma - dev->bank1;\r\nBUG_ON(ctx->shm.ofs & ((1 << MFC_BANK1_ALIGN_ORDER) - 1));\r\nmemset(ctx->shm.virt, 0, buf_size->shm);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_release_instance_buffer_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\ns5p_mfc_release_priv_buf(ctx->dev->mem_dev_l, &ctx->ctx);\r\ns5p_mfc_release_priv_buf(ctx->dev->mem_dev_l, &ctx->shm);\r\n}\r\nstatic int s5p_mfc_alloc_dev_context_buffer_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_release_dev_context_buffer_v5(struct s5p_mfc_dev *dev)\r\n{\r\n}\r\nstatic void s5p_mfc_write_info_v5(struct s5p_mfc_ctx *ctx, unsigned int data,\r\nunsigned int ofs)\r\n{\r\nwritel(data, (ctx->shm.virt + ofs));\r\nwmb();\r\n}\r\nstatic unsigned int s5p_mfc_read_info_v5(struct s5p_mfc_ctx *ctx,\r\nunsigned int ofs)\r\n{\r\nrmb();\r\nreturn readl(ctx->shm.virt + ofs);\r\n}\r\nstatic void s5p_mfc_dec_calc_dpb_size_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nunsigned int guard_width, guard_height;\r\nctx->buf_width = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN);\r\nctx->buf_height = ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN);\r\nmfc_debug(2,\r\n"SEQ Done: Movie dimensions %dx%d, buffer dimensions: %dx%d\n",\r\nctx->img_width, ctx->img_height, ctx->buf_width,\r\nctx->buf_height);\r\nif (ctx->codec_mode == S5P_MFC_CODEC_H264_DEC) {\r\nctx->luma_size = ALIGN(ctx->buf_width * ctx->buf_height,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->chroma_size = ALIGN(ctx->buf_width *\r\nALIGN((ctx->img_height >> 1),\r\nS5P_FIMV_NV12MT_VALIGN),\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->mv_size = ALIGN(ctx->buf_width *\r\nALIGN((ctx->buf_height >> 2),\r\nS5P_FIMV_NV12MT_VALIGN),\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\n} else {\r\nguard_width =\r\nALIGN(ctx->img_width + 24, S5P_FIMV_NV12MT_HALIGN);\r\nguard_height =\r\nALIGN(ctx->img_height + 16, S5P_FIMV_NV12MT_VALIGN);\r\nctx->luma_size = ALIGN(guard_width * guard_height,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nguard_width =\r\nALIGN(ctx->img_width + 16, S5P_FIMV_NV12MT_HALIGN);\r\nguard_height =\r\nALIGN((ctx->img_height >> 1) + 4,\r\nS5P_FIMV_NV12MT_VALIGN);\r\nctx->chroma_size = ALIGN(guard_width * guard_height,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->mv_size = 0;\r\n}\r\n}\r\nstatic void s5p_mfc_enc_calc_src_size_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12M) {\r\nctx->buf_width = ALIGN(ctx->img_width, S5P_FIMV_NV12M_HALIGN);\r\nctx->luma_size = ALIGN(ctx->img_width, S5P_FIMV_NV12M_HALIGN)\r\n* ALIGN(ctx->img_height, S5P_FIMV_NV12M_LVALIGN);\r\nctx->chroma_size = ALIGN(ctx->img_width, S5P_FIMV_NV12M_HALIGN)\r\n* ALIGN((ctx->img_height >> 1), S5P_FIMV_NV12M_CVALIGN);\r\nctx->luma_size = ALIGN(ctx->luma_size, S5P_FIMV_NV12M_SALIGN);\r\nctx->chroma_size =\r\nALIGN(ctx->chroma_size, S5P_FIMV_NV12M_SALIGN);\r\n} else if (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12MT) {\r\nctx->buf_width = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN);\r\nctx->luma_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\r\n* ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN);\r\nctx->chroma_size =\r\nALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\r\n* ALIGN((ctx->img_height >> 1), S5P_FIMV_NV12MT_VALIGN);\r\nctx->luma_size = ALIGN(ctx->luma_size, S5P_FIMV_NV12MT_SALIGN);\r\nctx->chroma_size =\r\nALIGN(ctx->chroma_size, S5P_FIMV_NV12MT_SALIGN);\r\n}\r\n}\r\nstatic void s5p_mfc_set_dec_desc_buffer(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf_size_v5 *buf_size = dev->variant->buf_size->priv;\r\nmfc_write(dev, OFFSETA(ctx->dsc.dma), S5P_FIMV_SI_CH0_DESC_ADR);\r\nmfc_write(dev, buf_size->dsc, S5P_FIMV_SI_CH0_DESC_SIZE);\r\n}\r\nstatic void s5p_mfc_set_shared_buffer(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, ctx->shm.ofs, S5P_FIMV_SI_CH0_HOST_WR_ADR);\r\n}\r\nstatic int s5p_mfc_set_dec_stream_buffer_v5(struct s5p_mfc_ctx *ctx,\r\nint buf_addr, unsigned int start_num_byte,\r\nunsigned int buf_size)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, OFFSETA(buf_addr), S5P_FIMV_SI_CH0_SB_ST_ADR);\r\nmfc_write(dev, ctx->dec_src_buf_size, S5P_FIMV_SI_CH0_CPB_SIZE);\r\nmfc_write(dev, buf_size, S5P_FIMV_SI_CH0_SB_FRM_SIZE);\r\ns5p_mfc_write_info_v5(ctx, start_num_byte, START_BYTE_NUM);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_set_dec_frame_buffer_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nunsigned int frame_size, i;\r\nunsigned int frame_size_ch, frame_size_mv;\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned int dpb;\r\nsize_t buf_addr1, buf_addr2;\r\nint buf_size1, buf_size2;\r\nbuf_addr1 = ctx->bank1.dma;\r\nbuf_size1 = ctx->bank1.size;\r\nbuf_addr2 = ctx->bank2.dma;\r\nbuf_size2 = ctx->bank2.size;\r\ndpb = mfc_read(dev, S5P_FIMV_SI_CH0_DPB_CONF_CTRL) &\r\n~S5P_FIMV_DPB_COUNT_MASK;\r\nmfc_write(dev, ctx->total_dpb_count | dpb,\r\nS5P_FIMV_SI_CH0_DPB_CONF_CTRL);\r\ns5p_mfc_set_shared_buffer(ctx);\r\nswitch (ctx->codec_mode) {\r\ncase S5P_MFC_CODEC_H264_DEC:\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_H264_VERT_NB_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_VERT_NB_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_VERT_NB_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H264_NB_IP_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_NB_IP_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_NB_IP_SIZE;\r\nbreak;\r\ncase S5P_MFC_CODEC_MPEG4_DEC:\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_NB_DCAC_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_UP_NB_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_SA_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_SP_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_STX_PARSER_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_STX_PARSER_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_OT_LINE_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nbreak;\r\ncase S5P_MFC_CODEC_H263_DEC:\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_OT_LINE_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_UP_NB_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_SA_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_NB_DCAC_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nbreak;\r\ncase S5P_MFC_CODEC_VC1_DEC:\r\ncase S5P_MFC_CODEC_VC1RCV_DEC:\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_NB_DCAC_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_OT_LINE_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_UP_NB_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_SA_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_BITPLANE3_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_BITPLANE2_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_BITPLANE1_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nbreak;\r\ncase S5P_MFC_CODEC_MPEG2_DEC:\r\nbreak;\r\ndefault:\r\nmfc_err("Unknown codec for decoding (%x)\n",\r\nctx->codec_mode);\r\nreturn -EINVAL;\r\n}\r\nframe_size = ctx->luma_size;\r\nframe_size_ch = ctx->chroma_size;\r\nframe_size_mv = ctx->mv_size;\r\nmfc_debug(2, "Frm size: %d ch: %d mv: %d\n", frame_size, frame_size_ch,\r\nframe_size_mv);\r\nfor (i = 0; i < ctx->total_dpb_count; i++) {\r\nmfc_debug(2, "Luma %d: %x\n", i,\r\nctx->dst_bufs[i].cookie.raw.luma);\r\nmfc_write(dev, OFFSETB(ctx->dst_bufs[i].cookie.raw.luma),\r\nS5P_FIMV_DEC_LUMA_ADR + i * 4);\r\nmfc_debug(2, "\tChroma %d: %x\n", i,\r\nctx->dst_bufs[i].cookie.raw.chroma);\r\nmfc_write(dev, OFFSETA(ctx->dst_bufs[i].cookie.raw.chroma),\r\nS5P_FIMV_DEC_CHROMA_ADR + i * 4);\r\nif (ctx->codec_mode == S5P_MFC_CODEC_H264_DEC) {\r\nmfc_debug(2, "\tBuf2: %x, size: %d\n",\r\nbuf_addr2, buf_size2);\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_H264_MV_ADR + i * 4);\r\nbuf_addr2 += frame_size_mv;\r\nbuf_size2 -= frame_size_mv;\r\n}\r\n}\r\nmfc_debug(2, "Buf1: %u, buf_size1: %d\n", buf_addr1, buf_size1);\r\nmfc_debug(2, "Buf 1/2 size after: %d/%d (frames %d)\n",\r\nbuf_size1, buf_size2, ctx->total_dpb_count);\r\nif (buf_size1 < 0 || buf_size2 < 0) {\r\nmfc_debug(2, "Not enough memory has been allocated\n");\r\nreturn -ENOMEM;\r\n}\r\ns5p_mfc_write_info_v5(ctx, frame_size, ALLOC_LUMA_DPB_SIZE);\r\ns5p_mfc_write_info_v5(ctx, frame_size_ch, ALLOC_CHROMA_DPB_SIZE);\r\nif (ctx->codec_mode == S5P_MFC_CODEC_H264_DEC)\r\ns5p_mfc_write_info_v5(ctx, frame_size_mv, ALLOC_MV_SIZE);\r\nmfc_write(dev, ((S5P_FIMV_CH_INIT_BUFS & S5P_FIMV_CH_MASK)\r\n<< S5P_FIMV_CH_SHIFT) | (ctx->inst_no),\r\nS5P_FIMV_SI_CH0_INST_ID);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_set_enc_stream_buffer_v5(struct s5p_mfc_ctx *ctx,\r\nunsigned long addr, unsigned int size)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, OFFSETA(addr), S5P_FIMV_ENC_SI_CH0_SB_ADR);\r\nmfc_write(dev, size, S5P_FIMV_ENC_SI_CH0_SB_SIZE);\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_set_enc_frame_buffer_v5(struct s5p_mfc_ctx *ctx,\r\nunsigned long y_addr, unsigned long c_addr)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, OFFSETB(y_addr), S5P_FIMV_ENC_SI_CH0_CUR_Y_ADR);\r\nmfc_write(dev, OFFSETB(c_addr), S5P_FIMV_ENC_SI_CH0_CUR_C_ADR);\r\n}\r\nstatic void s5p_mfc_get_enc_frame_buffer_v5(struct s5p_mfc_ctx *ctx,\r\nunsigned long *y_addr, unsigned long *c_addr)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\n*y_addr = dev->bank2 + (mfc_read(dev, S5P_FIMV_ENCODED_Y_ADDR)\r\n<< MFC_OFFSET_SHIFT);\r\n*c_addr = dev->bank2 + (mfc_read(dev, S5P_FIMV_ENCODED_C_ADDR)\r\n<< MFC_OFFSET_SHIFT);\r\n}\r\nstatic int s5p_mfc_set_enc_ref_buffer_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nsize_t buf_addr1, buf_addr2;\r\nsize_t buf_size1, buf_size2;\r\nunsigned int enc_ref_y_size, enc_ref_c_size;\r\nunsigned int guard_width, guard_height;\r\nint i;\r\nbuf_addr1 = ctx->bank1.dma;\r\nbuf_size1 = ctx->bank1.size;\r\nbuf_addr2 = ctx->bank2.dma;\r\nbuf_size2 = ctx->bank2.size;\r\nenc_ref_y_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\r\n* ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_y_size = ALIGN(enc_ref_y_size, S5P_FIMV_NV12MT_SALIGN);\r\nif (ctx->codec_mode == S5P_MFC_CODEC_H264_ENC) {\r\nenc_ref_c_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\r\n* ALIGN((ctx->img_height >> 1), S5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_c_size = ALIGN(enc_ref_c_size, S5P_FIMV_NV12MT_SALIGN);\r\n} else {\r\nguard_width = ALIGN(ctx->img_width + 16,\r\nS5P_FIMV_NV12MT_HALIGN);\r\nguard_height = ALIGN((ctx->img_height >> 1) + 4,\r\nS5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_c_size = ALIGN(guard_width * guard_height,\r\nS5P_FIMV_NV12MT_SALIGN);\r\n}\r\nmfc_debug(2, "buf_size1: %d, buf_size2: %d\n", buf_size1, buf_size2);\r\nswitch (ctx->codec_mode) {\r\ncase S5P_MFC_CODEC_H264_ENC:\r\nfor (i = 0; i < 2; i++) {\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_ENC_REF0_LUMA_ADR + (4 * i));\r\nbuf_addr1 += enc_ref_y_size;\r\nbuf_size1 -= enc_ref_y_size;\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF2_LUMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_y_size;\r\nbuf_size2 -= enc_ref_y_size;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF0_CHROMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_c_size;\r\nbuf_size2 -= enc_ref_c_size;\r\n}\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H264_UP_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_UPMV_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_UPMV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_H264_COZERO_FLAG_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_COLFLG_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_COLFLG_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_H264_UP_INTRA_MD_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_INTRAMD_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_INTRAMD_SIZE;\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_H264_UP_INTRA_PRED_ADR);\r\nbuf_addr2 += S5P_FIMV_ENC_INTRAPRED_SIZE;\r\nbuf_size2 -= S5P_FIMV_ENC_INTRAPRED_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_H264_NBOR_INFO_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_NBORINFO_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_NBORINFO_SIZE;\r\nmfc_debug(2, "buf_size1: %d, buf_size2: %d\n",\r\nbuf_size1, buf_size2);\r\nbreak;\r\ncase S5P_MFC_CODEC_MPEG4_ENC:\r\nfor (i = 0; i < 2; i++) {\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_ENC_REF0_LUMA_ADR + (4 * i));\r\nbuf_addr1 += enc_ref_y_size;\r\nbuf_size1 -= enc_ref_y_size;\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF2_LUMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_y_size;\r\nbuf_size2 -= enc_ref_y_size;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF0_CHROMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_c_size;\r\nbuf_size2 -= enc_ref_c_size;\r\n}\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_UP_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_UPMV_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_UPMV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_MPEG4_COZERO_FLAG_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_COLFLG_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_COLFLG_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_MPEG4_ACDC_COEF_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nmfc_debug(2, "buf_size1: %d, buf_size2: %d\n",\r\nbuf_size1, buf_size2);\r\nbreak;\r\ncase S5P_MFC_CODEC_H263_ENC:\r\nfor (i = 0; i < 2; i++) {\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_ENC_REF0_LUMA_ADR + (4 * i));\r\nbuf_addr1 += enc_ref_y_size;\r\nbuf_size1 -= enc_ref_y_size;\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF2_LUMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_y_size;\r\nbuf_size2 -= enc_ref_y_size;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF0_CHROMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_c_size;\r\nbuf_size2 -= enc_ref_c_size;\r\n}\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_UP_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_UPMV_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_UPMV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_ACDC_COEF_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nmfc_debug(2, "buf_size1: %d, buf_size2: %d\n",\r\nbuf_size1, buf_size2);\r\nbreak;\r\ndefault:\r\nmfc_err("Unknown codec set for encoding: %d\n",\r\nctx->codec_mode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_set_enc_params(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_enc_params *p = &ctx->enc_params;\r\nunsigned int reg;\r\nunsigned int shm;\r\nmfc_write(dev, ctx->img_width, S5P_FIMV_ENC_HSIZE_PX);\r\nmfc_write(dev, ctx->img_height, S5P_FIMV_ENC_VSIZE_PX);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nreg |= (1 << 18);\r\nreg &= ~(0xFFFF);\r\nreg |= p->gop_size;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nmfc_write(dev, 0, S5P_FIMV_ENC_B_RECON_WRITE_ON);\r\nmfc_write(dev, p->slice_mode, S5P_FIMV_ENC_MSLICE_CTRL);\r\nif (p->slice_mode == V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_MB) {\r\nmfc_write(dev, p->slice_mb, S5P_FIMV_ENC_MSLICE_MB);\r\n} else if (p->slice_mode == V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES) {\r\nmfc_write(dev, p->slice_bit, S5P_FIMV_ENC_MSLICE_BIT);\r\n} else {\r\nmfc_write(dev, 0, S5P_FIMV_ENC_MSLICE_MB);\r\nmfc_write(dev, 0, S5P_FIMV_ENC_MSLICE_BIT);\r\n}\r\nmfc_write(dev, p->intra_refresh_mb, S5P_FIMV_ENC_CIR_CTRL);\r\nif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12M)\r\nmfc_write(dev, 0, S5P_FIMV_ENC_MAP_FOR_CUR);\r\nelse if (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12MT)\r\nmfc_write(dev, 3, S5P_FIMV_ENC_MAP_FOR_CUR);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PADDING_CTRL);\r\nif (p->pad) {\r\nreg |= (1 << 31);\r\nreg &= ~(0xFF << 16);\r\nreg |= (p->pad_cr << 16);\r\nreg &= ~(0xFF << 8);\r\nreg |= (p->pad_cb << 8);\r\nreg &= ~(0xFF);\r\nreg |= (p->pad_luma);\r\n} else {\r\nreg = 0;\r\n}\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PADDING_CTRL);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\r\nreg &= ~(0x1 << 9);\r\nreg |= (p->rc_frame << 9);\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\r\nif (p->rc_frame)\r\nmfc_write(dev, p->rc_bitrate,\r\nS5P_FIMV_ENC_RC_BIT_RATE);\r\nelse\r\nmfc_write(dev, 0, S5P_FIMV_ENC_RC_BIT_RATE);\r\nif (p->rc_frame)\r\nmfc_write(dev, p->rc_reaction_coeff, S5P_FIMV_ENC_RC_RPARA);\r\nshm = s5p_mfc_read_info_v5(ctx, EXT_ENC_CONTROL);\r\nshm &= ~(0x1 << 3);\r\nshm |= (p->seq_hdr_mode << 3);\r\nshm &= ~(0x3 << 1);\r\nshm |= (p->frame_skip_mode << 1);\r\ns5p_mfc_write_info_v5(ctx, shm, EXT_ENC_CONTROL);\r\ns5p_mfc_write_info_v5(ctx, p->fixed_target_bit, RC_CONTROL_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_set_enc_params_h264(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_enc_params *p = &ctx->enc_params;\r\nstruct s5p_mfc_h264_enc_params *p_264 = &p->codec.h264;\r\nunsigned int reg;\r\nunsigned int shm;\r\ns5p_mfc_set_enc_params(ctx);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nreg &= ~(0x3 << 16);\r\nreg |= (p->num_b_frame << 16);\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PROFILE);\r\nreg &= ~(0xFF << 8);\r\nreg |= (p_264->level << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_264->profile;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PROFILE);\r\nmfc_write(dev, p_264->interlace, S5P_FIMV_ENC_PIC_STRUCT);\r\nif (p_264->interlace)\r\nmfc_write(dev, ctx->img_height >> 1, S5P_FIMV_ENC_VSIZE_PX);\r\nmfc_write(dev, p_264->loop_filter_mode, S5P_FIMV_ENC_LF_CTRL);\r\nif (p_264->loop_filter_alpha < 0) {\r\nreg = 0x10;\r\nreg |= (0xFF - p_264->loop_filter_alpha) + 1;\r\n} else {\r\nreg = 0x00;\r\nreg |= (p_264->loop_filter_alpha & 0xF);\r\n}\r\nmfc_write(dev, reg, S5P_FIMV_ENC_ALPHA_OFF);\r\nif (p_264->loop_filter_beta < 0) {\r\nreg = 0x10;\r\nreg |= (0xFF - p_264->loop_filter_beta) + 1;\r\n} else {\r\nreg = 0x00;\r\nreg |= (p_264->loop_filter_beta & 0xF);\r\n}\r\nmfc_write(dev, reg, S5P_FIMV_ENC_BETA_OFF);\r\nif (p_264->entropy_mode == V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC)\r\nmfc_write(dev, 1, S5P_FIMV_ENC_H264_ENTROPY_MODE);\r\nelse\r\nmfc_write(dev, 0, S5P_FIMV_ENC_H264_ENTROPY_MODE);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_H264_NUM_OF_REF);\r\nreg &= ~(0x3 << 5);\r\nreg |= (p_264->num_ref_pic_4p << 5);\r\nreg &= ~(0x1F);\r\nreg |= p_264->max_ref_pic;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_H264_NUM_OF_REF);\r\nmfc_write(dev, p_264->_8x8_transform, S5P_FIMV_ENC_H264_TRANS_FLAG);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\r\nreg &= ~(0x1 << 8);\r\nreg |= (p->rc_mb << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_264->rc_frame_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\r\nif (p->rc_frame && p->rc_framerate_denom)\r\nmfc_write(dev, p->rc_framerate_num * 1000\r\n/ p->rc_framerate_denom, S5P_FIMV_ENC_RC_FRAME_RATE);\r\nelse\r\nmfc_write(dev, 0, S5P_FIMV_ENC_RC_FRAME_RATE);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_QBOUND);\r\nreg &= ~(0x3F << 8);\r\nreg |= (p_264->rc_max_qp << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_264->rc_min_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_QBOUND);\r\nif (p->rc_mb) {\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_MB_CTRL);\r\nreg &= ~(0x1 << 3);\r\nreg |= (p_264->rc_mb_dark << 3);\r\nreg &= ~(0x1 << 2);\r\nreg |= (p_264->rc_mb_smooth << 2);\r\nreg &= ~(0x1 << 1);\r\nreg |= (p_264->rc_mb_static << 1);\r\nreg &= ~(0x1);\r\nreg |= p_264->rc_mb_activity;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_MB_CTRL);\r\n}\r\nif (!p->rc_frame && !p->rc_mb) {\r\nshm = s5p_mfc_read_info_v5(ctx, P_B_FRAME_QP);\r\nshm &= ~(0xFFF);\r\nshm |= ((p_264->rc_b_frame_qp & 0x3F) << 6);\r\nshm |= (p_264->rc_p_frame_qp & 0x3F);\r\ns5p_mfc_write_info_v5(ctx, shm, P_B_FRAME_QP);\r\n}\r\nshm = s5p_mfc_read_info_v5(ctx, EXT_ENC_CONTROL);\r\nshm &= ~(0x1 << 15);\r\nshm |= (p_264->vui_sar << 1);\r\ns5p_mfc_write_info_v5(ctx, shm, EXT_ENC_CONTROL);\r\nif (p_264->vui_sar) {\r\nshm = s5p_mfc_read_info_v5(ctx, SAMPLE_ASPECT_RATIO_IDC);\r\nshm &= ~(0xFF);\r\nshm |= p_264->vui_sar_idc;\r\ns5p_mfc_write_info_v5(ctx, shm, SAMPLE_ASPECT_RATIO_IDC);\r\nif (p_264->vui_sar_idc == 0xFF) {\r\nshm = s5p_mfc_read_info_v5(ctx, EXTENDED_SAR);\r\nshm &= ~(0xFFFFFFFF);\r\nshm |= p_264->vui_ext_sar_width << 16;\r\nshm |= p_264->vui_ext_sar_height;\r\ns5p_mfc_write_info_v5(ctx, shm, EXTENDED_SAR);\r\n}\r\n}\r\nshm = s5p_mfc_read_info_v5(ctx, H264_I_PERIOD);\r\nshm &= ~(0x1 << 16);\r\nshm |= (p_264->open_gop << 16);\r\nif (p_264->open_gop) {\r\nshm &= ~(0xFFFF);\r\nshm |= p_264->open_gop_size;\r\n}\r\ns5p_mfc_write_info_v5(ctx, shm, H264_I_PERIOD);\r\nshm = s5p_mfc_read_info_v5(ctx, EXT_ENC_CONTROL);\r\nif (p->frame_skip_mode ==\r\nV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\r\nshm &= ~(0xFFFF << 16);\r\nshm |= (p_264->cpb_size << 16);\r\n}\r\ns5p_mfc_write_info_v5(ctx, shm, EXT_ENC_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_set_enc_params_mpeg4(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_enc_params *p = &ctx->enc_params;\r\nstruct s5p_mfc_mpeg4_enc_params *p_mpeg4 = &p->codec.mpeg4;\r\nunsigned int reg;\r\nunsigned int shm;\r\nunsigned int framerate;\r\ns5p_mfc_set_enc_params(ctx);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nreg &= ~(0x3 << 16);\r\nreg |= (p->num_b_frame << 16);\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PROFILE);\r\nreg &= ~(0xFF << 8);\r\nreg |= (p_mpeg4->level << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_mpeg4->profile;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PROFILE);\r\nmfc_write(dev, p_mpeg4->quarter_pixel, S5P_FIMV_ENC_MPEG4_QUART_PXL);\r\nif (!p->rc_frame) {\r\nshm = s5p_mfc_read_info_v5(ctx, P_B_FRAME_QP);\r\nshm &= ~(0xFFF);\r\nshm |= ((p_mpeg4->rc_b_frame_qp & 0x3F) << 6);\r\nshm |= (p_mpeg4->rc_p_frame_qp & 0x3F);\r\ns5p_mfc_write_info_v5(ctx, shm, P_B_FRAME_QP);\r\n}\r\nif (p->rc_frame) {\r\nif (p->rc_framerate_denom > 0) {\r\nframerate = p->rc_framerate_num * 1000 /\r\np->rc_framerate_denom;\r\nmfc_write(dev, framerate,\r\nS5P_FIMV_ENC_RC_FRAME_RATE);\r\nshm = s5p_mfc_read_info_v5(ctx, RC_VOP_TIMING);\r\nshm &= ~(0xFFFFFFFF);\r\nshm |= (1 << 31);\r\nshm |= ((p->rc_framerate_num & 0x7FFF) << 16);\r\nshm |= (p->rc_framerate_denom & 0xFFFF);\r\ns5p_mfc_write_info_v5(ctx, shm, RC_VOP_TIMING);\r\n}\r\n} else {\r\nmfc_write(dev, 0, S5P_FIMV_ENC_RC_FRAME_RATE);\r\n}\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\r\nreg &= ~(0x3F);\r\nreg |= p_mpeg4->rc_frame_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_QBOUND);\r\nreg &= ~(0x3F << 8);\r\nreg |= (p_mpeg4->rc_max_qp << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_mpeg4->rc_min_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_QBOUND);\r\nshm = s5p_mfc_read_info_v5(ctx, EXT_ENC_CONTROL);\r\nif (p->frame_skip_mode ==\r\nV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\r\nshm &= ~(0xFFFF << 16);\r\nshm |= (p->vbv_size << 16);\r\n}\r\ns5p_mfc_write_info_v5(ctx, shm, EXT_ENC_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_set_enc_params_h263(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_enc_params *p = &ctx->enc_params;\r\nstruct s5p_mfc_mpeg4_enc_params *p_h263 = &p->codec.mpeg4;\r\nunsigned int reg;\r\nunsigned int shm;\r\ns5p_mfc_set_enc_params(ctx);\r\nif (!p->rc_frame) {\r\nshm = s5p_mfc_read_info_v5(ctx, P_B_FRAME_QP);\r\nshm &= ~(0xFFF);\r\nshm |= (p_h263->rc_p_frame_qp & 0x3F);\r\ns5p_mfc_write_info_v5(ctx, shm, P_B_FRAME_QP);\r\n}\r\nif (p->rc_frame && p->rc_framerate_denom)\r\nmfc_write(dev, p->rc_framerate_num * 1000\r\n/ p->rc_framerate_denom, S5P_FIMV_ENC_RC_FRAME_RATE);\r\nelse\r\nmfc_write(dev, 0, S5P_FIMV_ENC_RC_FRAME_RATE);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\r\nreg &= ~(0x3F);\r\nreg |= p_h263->rc_frame_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_QBOUND);\r\nreg &= ~(0x3F << 8);\r\nreg |= (p_h263->rc_max_qp << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_h263->rc_min_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_QBOUND);\r\nshm = s5p_mfc_read_info_v5(ctx, EXT_ENC_CONTROL);\r\nif (p->frame_skip_mode ==\r\nV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\r\nshm &= ~(0xFFFF << 16);\r\nshm |= (p->vbv_size << 16);\r\n}\r\ns5p_mfc_write_info_v5(ctx, shm, EXT_ENC_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_init_decode_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\ns5p_mfc_set_shared_buffer(ctx);\r\nif (ctx->codec_mode == S5P_MFC_CODEC_MPEG4_DEC)\r\nmfc_write(dev, ctx->loop_filter_mpeg4, S5P_FIMV_ENC_LF_CTRL);\r\nelse\r\nmfc_write(dev, 0, S5P_FIMV_ENC_LF_CTRL);\r\nmfc_write(dev, ((ctx->slice_interface & S5P_FIMV_SLICE_INT_MASK) <<\r\nS5P_FIMV_SLICE_INT_SHIFT) | (ctx->display_delay_enable <<\r\nS5P_FIMV_DDELAY_ENA_SHIFT) | ((ctx->display_delay &\r\nS5P_FIMV_DDELAY_VAL_MASK) << S5P_FIMV_DDELAY_VAL_SHIFT),\r\nS5P_FIMV_SI_CH0_DPB_CONF_CTRL);\r\nmfc_write(dev,\r\n((S5P_FIMV_CH_SEQ_HEADER & S5P_FIMV_CH_MASK) << S5P_FIMV_CH_SHIFT)\r\n| (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_set_flush(struct s5p_mfc_ctx *ctx, int flush)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned int dpb;\r\nif (flush)\r\ndpb = mfc_read(dev, S5P_FIMV_SI_CH0_DPB_CONF_CTRL) | (\r\nS5P_FIMV_DPB_FLUSH_MASK << S5P_FIMV_DPB_FLUSH_SHIFT);\r\nelse\r\ndpb = mfc_read(dev, S5P_FIMV_SI_CH0_DPB_CONF_CTRL) &\r\n~(S5P_FIMV_DPB_FLUSH_MASK << S5P_FIMV_DPB_FLUSH_SHIFT);\r\nmfc_write(dev, dpb, S5P_FIMV_SI_CH0_DPB_CONF_CTRL);\r\n}\r\nstatic int s5p_mfc_decode_one_frame_v5(struct s5p_mfc_ctx *ctx,\r\nenum s5p_mfc_decode_arg last_frame)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, ctx->dec_dst_flag, S5P_FIMV_SI_CH0_RELEASE_BUF);\r\ns5p_mfc_set_shared_buffer(ctx);\r\ns5p_mfc_set_flush(ctx, ctx->dpb_flush_flag);\r\nswitch (last_frame) {\r\ncase MFC_DEC_FRAME:\r\nmfc_write(dev, ((S5P_FIMV_CH_FRAME_START & S5P_FIMV_CH_MASK) <<\r\nS5P_FIMV_CH_SHIFT) | (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\r\nbreak;\r\ncase MFC_DEC_LAST_FRAME:\r\nmfc_write(dev, ((S5P_FIMV_CH_LAST_FRAME & S5P_FIMV_CH_MASK) <<\r\nS5P_FIMV_CH_SHIFT) | (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\r\nbreak;\r\ncase MFC_DEC_RES_CHANGE:\r\nmfc_write(dev, ((S5P_FIMV_CH_FRAME_START_REALLOC &\r\nS5P_FIMV_CH_MASK) << S5P_FIMV_CH_SHIFT) | (ctx->inst_no),\r\nS5P_FIMV_SI_CH0_INST_ID);\r\nbreak;\r\n}\r\nmfc_debug(2, "Decoding a usual frame\n");\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_init_encode_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nif (ctx->codec_mode == S5P_MFC_CODEC_H264_ENC)\r\ns5p_mfc_set_enc_params_h264(ctx);\r\nelse if (ctx->codec_mode == S5P_MFC_CODEC_MPEG4_ENC)\r\ns5p_mfc_set_enc_params_mpeg4(ctx);\r\nelse if (ctx->codec_mode == S5P_MFC_CODEC_H263_ENC)\r\ns5p_mfc_set_enc_params_h263(ctx);\r\nelse {\r\nmfc_err("Unknown codec for encoding (%x)\n",\r\nctx->codec_mode);\r\nreturn -EINVAL;\r\n}\r\ns5p_mfc_set_shared_buffer(ctx);\r\nmfc_write(dev, ((S5P_FIMV_CH_SEQ_HEADER << 16) & 0x70000) |\r\n(ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_encode_one_frame_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nint cmd;\r\nif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12M)\r\nmfc_write(dev, 0, S5P_FIMV_ENC_MAP_FOR_CUR);\r\nelse if (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12MT)\r\nmfc_write(dev, 3, S5P_FIMV_ENC_MAP_FOR_CUR);\r\ns5p_mfc_set_shared_buffer(ctx);\r\nif (ctx->state == MFCINST_FINISHING)\r\ncmd = S5P_FIMV_CH_LAST_FRAME;\r\nelse\r\ncmd = S5P_FIMV_CH_FRAME_START;\r\nmfc_write(dev, ((cmd & S5P_FIMV_CH_MASK) << S5P_FIMV_CH_SHIFT)\r\n| (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_get_new_ctx(struct s5p_mfc_dev *dev)\r\n{\r\nunsigned long flags;\r\nint new_ctx;\r\nint cnt;\r\nspin_lock_irqsave(&dev->condlock, flags);\r\nnew_ctx = (dev->curr_ctx + 1) % MFC_NUM_CONTEXTS;\r\ncnt = 0;\r\nwhile (!test_bit(new_ctx, &dev->ctx_work_bits)) {\r\nnew_ctx = (new_ctx + 1) % MFC_NUM_CONTEXTS;\r\nif (++cnt > MFC_NUM_CONTEXTS) {\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\nreturn new_ctx;\r\n}\r\nstatic void s5p_mfc_run_res_change(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\ns5p_mfc_set_dec_stream_buffer_v5(ctx, 0, 0, 0);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_decode_one_frame_v5(ctx, MFC_DEC_RES_CHANGE);\r\n}\r\nstatic int s5p_mfc_run_dec_frame(struct s5p_mfc_ctx *ctx, int last_frame)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *temp_vb;\r\nunsigned long flags;\r\nunsigned int index;\r\nif (ctx->state == MFCINST_FINISHING) {\r\nlast_frame = MFC_DEC_LAST_FRAME;\r\ns5p_mfc_set_dec_stream_buffer_v5(ctx, 0, 0, 0);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_decode_one_frame_v5(ctx, last_frame);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (list_empty(&ctx->src_queue)) {\r\nmfc_debug(2, "No src buffers\n");\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nreturn -EAGAIN;\r\n}\r\ntemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\r\ntemp_vb->flags |= MFC_BUF_FLAG_USED;\r\ns5p_mfc_set_dec_stream_buffer_v5(ctx,\r\nvb2_dma_contig_plane_dma_addr(temp_vb->b, 0),\r\nctx->consumed_stream, temp_vb->b->v4l2_planes[0].bytesused);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nindex = temp_vb->b->v4l2_buf.index;\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nif (temp_vb->b->v4l2_planes[0].bytesused == 0) {\r\nlast_frame = MFC_DEC_LAST_FRAME;\r\nmfc_debug(2, "Setting ctx->state to FINISHING\n");\r\nctx->state = MFCINST_FINISHING;\r\n}\r\ns5p_mfc_decode_one_frame_v5(ctx, last_frame);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_run_enc_frame(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *dst_mb;\r\nstruct s5p_mfc_buf *src_mb;\r\nunsigned long src_y_addr, src_c_addr, dst_addr;\r\nunsigned int dst_size;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (list_empty(&ctx->src_queue) && ctx->state != MFCINST_FINISHING) {\r\nmfc_debug(2, "no src buffers\n");\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nreturn -EAGAIN;\r\n}\r\nif (list_empty(&ctx->dst_queue)) {\r\nmfc_debug(2, "no dst buffers\n");\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nreturn -EAGAIN;\r\n}\r\nif (list_empty(&ctx->src_queue)) {\r\ns5p_mfc_set_enc_frame_buffer_v5(ctx, dev->bank2, dev->bank2);\r\nsrc_mb = NULL;\r\n} else {\r\nsrc_mb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf,\r\nlist);\r\nsrc_mb->flags |= MFC_BUF_FLAG_USED;\r\nif (src_mb->b->v4l2_planes[0].bytesused == 0) {\r\ns5p_mfc_set_enc_frame_buffer_v5(ctx, dev->bank2,\r\ndev->bank2);\r\nctx->state = MFCINST_FINISHING;\r\n} else {\r\nsrc_y_addr = vb2_dma_contig_plane_dma_addr(src_mb->b,\r\n0);\r\nsrc_c_addr = vb2_dma_contig_plane_dma_addr(src_mb->b,\r\n1);\r\ns5p_mfc_set_enc_frame_buffer_v5(ctx, src_y_addr,\r\nsrc_c_addr);\r\nif (src_mb->flags & MFC_BUF_FLAG_EOS)\r\nctx->state = MFCINST_FINISHING;\r\n}\r\n}\r\ndst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\r\ndst_mb->flags |= MFC_BUF_FLAG_USED;\r\ndst_addr = vb2_dma_contig_plane_dma_addr(dst_mb->b, 0);\r\ndst_size = vb2_plane_size(dst_mb->b, 0);\r\ns5p_mfc_set_enc_stream_buffer_v5(ctx, dst_addr, dst_size);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nmfc_debug(2, "encoding buffer with index=%d state=%d\n",\r\nsrc_mb ? src_mb->b->v4l2_buf.index : -1, ctx->state);\r\ns5p_mfc_encode_one_frame_v5(ctx);\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_run_init_dec(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *temp_vb;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nmfc_debug(2, "Preparing to init decoding\n");\r\ntemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\r\ns5p_mfc_set_dec_desc_buffer(ctx);\r\nmfc_debug(2, "Header size: %d\n", temp_vb->b->v4l2_planes[0].bytesused);\r\ns5p_mfc_set_dec_stream_buffer_v5(ctx,\r\nvb2_dma_contig_plane_dma_addr(temp_vb->b, 0),\r\n0, temp_vb->b->v4l2_planes[0].bytesused);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_init_decode_v5(ctx);\r\n}\r\nstatic void s5p_mfc_run_init_enc(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *dst_mb;\r\nunsigned long dst_addr;\r\nunsigned int dst_size;\r\ns5p_mfc_set_enc_ref_buffer_v5(ctx);\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\ndst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\r\ndst_addr = vb2_dma_contig_plane_dma_addr(dst_mb->b, 0);\r\ndst_size = vb2_plane_size(dst_mb->b, 0);\r\ns5p_mfc_set_enc_stream_buffer_v5(ctx, dst_addr, dst_size);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_init_encode_v5(ctx);\r\n}\r\nstatic int s5p_mfc_run_init_dec_buffers(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *temp_vb;\r\nint ret;\r\nif (ctx->capture_state != QUEUE_BUFS_MMAPED) {\r\nmfc_err("It seems that not all destionation buffers were "\r\n"mmaped\nMFC requires that all destination are mmaped "\r\n"before starting processing\n");\r\nreturn -EAGAIN;\r\n}\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (list_empty(&ctx->src_queue)) {\r\nmfc_err("Header has been deallocated in the middle of"\r\n" initialization\n");\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nreturn -EIO;\r\n}\r\ntemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\r\nmfc_debug(2, "Header size: %d\n", temp_vb->b->v4l2_planes[0].bytesused);\r\ns5p_mfc_set_dec_stream_buffer_v5(ctx,\r\nvb2_dma_contig_plane_dma_addr(temp_vb->b, 0),\r\n0, temp_vb->b->v4l2_planes[0].bytesused);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nret = s5p_mfc_set_dec_frame_buffer_v5(ctx);\r\nif (ret) {\r\nmfc_err("Failed to alloc frame mem\n");\r\nctx->state = MFCINST_ERROR;\r\n}\r\nreturn ret;\r\n}\r\nstatic void s5p_mfc_try_run_v5(struct s5p_mfc_dev *dev)\r\n{\r\nstruct s5p_mfc_ctx *ctx;\r\nint new_ctx;\r\nunsigned int ret = 0;\r\nif (test_bit(0, &dev->enter_suspend)) {\r\nmfc_debug(1, "Entering suspend so do not schedule any jobs\n");\r\nreturn;\r\n}\r\nif (test_and_set_bit(0, &dev->hw_lock) != 0) {\r\nmfc_debug(1, "Couldn't lock HW\n");\r\nreturn;\r\n}\r\nnew_ctx = s5p_mfc_get_new_ctx(dev);\r\nif (new_ctx < 0) {\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0) {\r\nmfc_err("Failed to unlock hardware\n");\r\nreturn;\r\n}\r\nmfc_debug(1, "No ctx is scheduled to be run\n");\r\nreturn;\r\n}\r\nctx = dev->ctx[new_ctx];\r\ns5p_mfc_clock_on();\r\nif (ctx->type == MFCINST_DECODER) {\r\ns5p_mfc_set_dec_desc_buffer(ctx);\r\nswitch (ctx->state) {\r\ncase MFCINST_FINISHING:\r\ns5p_mfc_run_dec_frame(ctx, MFC_DEC_LAST_FRAME);\r\nbreak;\r\ncase MFCINST_RUNNING:\r\nret = s5p_mfc_run_dec_frame(ctx, MFC_DEC_FRAME);\r\nbreak;\r\ncase MFCINST_INIT:\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nret = s5p_mfc_hw_call(dev->mfc_cmds, open_inst_cmd,\r\nctx);\r\nbreak;\r\ncase MFCINST_RETURN_INST:\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nret = s5p_mfc_hw_call(dev->mfc_cmds, close_inst_cmd,\r\nctx);\r\nbreak;\r\ncase MFCINST_GOT_INST:\r\ns5p_mfc_run_init_dec(ctx);\r\nbreak;\r\ncase MFCINST_HEAD_PARSED:\r\nret = s5p_mfc_run_init_dec_buffers(ctx);\r\nmfc_debug(1, "head parsed\n");\r\nbreak;\r\ncase MFCINST_RES_CHANGE_INIT:\r\ns5p_mfc_run_res_change(ctx);\r\nbreak;\r\ncase MFCINST_RES_CHANGE_FLUSH:\r\ns5p_mfc_run_dec_frame(ctx, MFC_DEC_FRAME);\r\nbreak;\r\ncase MFCINST_RES_CHANGE_END:\r\nmfc_debug(2, "Finished remaining frames after resolution change\n");\r\nctx->capture_state = QUEUE_FREE;\r\nmfc_debug(2, "Will re-init the codec\n");\r\ns5p_mfc_run_init_dec(ctx);\r\nbreak;\r\ndefault:\r\nret = -EAGAIN;\r\n}\r\n} else if (ctx->type == MFCINST_ENCODER) {\r\nswitch (ctx->state) {\r\ncase MFCINST_FINISHING:\r\ncase MFCINST_RUNNING:\r\nret = s5p_mfc_run_enc_frame(ctx);\r\nbreak;\r\ncase MFCINST_INIT:\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nret = s5p_mfc_hw_call(dev->mfc_cmds, open_inst_cmd,\r\nctx);\r\nbreak;\r\ncase MFCINST_RETURN_INST:\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nret = s5p_mfc_hw_call(dev->mfc_cmds, close_inst_cmd,\r\nctx);\r\nbreak;\r\ncase MFCINST_GOT_INST:\r\ns5p_mfc_run_init_enc(ctx);\r\nbreak;\r\ndefault:\r\nret = -EAGAIN;\r\n}\r\n} else {\r\nmfc_err("Invalid context type: %d\n", ctx->type);\r\nret = -EAGAIN;\r\n}\r\nif (ret) {\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nmfc_err("Failed to unlock hardware\n");\r\ns5p_mfc_clock_off();\r\n}\r\n}\r\nstatic void s5p_mfc_cleanup_queue_v5(struct list_head *lh, struct vb2_queue *vq)\r\n{\r\nstruct s5p_mfc_buf *b;\r\nint i;\r\nwhile (!list_empty(lh)) {\r\nb = list_entry(lh->next, struct s5p_mfc_buf, list);\r\nfor (i = 0; i < b->b->num_planes; i++)\r\nvb2_set_plane_payload(b->b, i, 0);\r\nvb2_buffer_done(b->b, VB2_BUF_STATE_ERROR);\r\nlist_del(&b->list);\r\n}\r\n}\r\nstatic void s5p_mfc_clear_int_flags_v5(struct s5p_mfc_dev *dev)\r\n{\r\nmfc_write(dev, 0, S5P_FIMV_RISC_HOST_INT);\r\nmfc_write(dev, 0, S5P_FIMV_RISC2HOST_CMD);\r\nmfc_write(dev, 0xffff, S5P_FIMV_SI_RTN_CHID);\r\n}\r\nstatic int s5p_mfc_get_dspl_y_adr_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_SI_DISPLAY_Y_ADR) << MFC_OFFSET_SHIFT;\r\n}\r\nstatic int s5p_mfc_get_dec_y_adr_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_SI_DECODE_Y_ADR) << MFC_OFFSET_SHIFT;\r\n}\r\nstatic int s5p_mfc_get_dspl_status_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_SI_DISPLAY_STATUS);\r\n}\r\nstatic int s5p_mfc_get_dec_status_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_SI_DECODE_STATUS);\r\n}\r\nstatic int s5p_mfc_get_dec_frame_type_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_DECODE_FRAME_TYPE) &\r\nS5P_FIMV_DECODE_FRAME_MASK;\r\n}\r\nstatic int s5p_mfc_get_disp_frame_type_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nreturn (s5p_mfc_read_info_v5(ctx, DISP_PIC_FRAME_TYPE) >>\r\nS5P_FIMV_SHARED_DISP_FRAME_TYPE_SHIFT) &\r\nS5P_FIMV_DECODE_FRAME_MASK;\r\n}\r\nstatic int s5p_mfc_get_consumed_stream_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_SI_CONSUMED_BYTES);\r\n}\r\nstatic int s5p_mfc_get_int_reason_v5(struct s5p_mfc_dev *dev)\r\n{\r\nint reason;\r\nreason = mfc_read(dev, S5P_FIMV_RISC2HOST_CMD) &\r\nS5P_FIMV_RISC2HOST_CMD_MASK;\r\nswitch (reason) {\r\ncase S5P_FIMV_R2H_CMD_OPEN_INSTANCE_RET:\r\nreason = S5P_MFC_R2H_CMD_OPEN_INSTANCE_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_CLOSE_INSTANCE_RET:\r\nreason = S5P_MFC_R2H_CMD_CLOSE_INSTANCE_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_SEQ_DONE_RET:\r\nreason = S5P_MFC_R2H_CMD_SEQ_DONE_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_FRAME_DONE_RET:\r\nreason = S5P_MFC_R2H_CMD_FRAME_DONE_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_SLICE_DONE_RET:\r\nreason = S5P_MFC_R2H_CMD_SLICE_DONE_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_SYS_INIT_RET:\r\nreason = S5P_MFC_R2H_CMD_SYS_INIT_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_FW_STATUS_RET:\r\nreason = S5P_MFC_R2H_CMD_FW_STATUS_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_SLEEP_RET:\r\nreason = S5P_MFC_R2H_CMD_SLEEP_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_WAKEUP_RET:\r\nreason = S5P_MFC_R2H_CMD_WAKEUP_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_INIT_BUFFERS_RET:\r\nreason = S5P_MFC_R2H_CMD_INIT_BUFFERS_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_ENC_COMPLETE_RET:\r\nreason = S5P_MFC_R2H_CMD_COMPLETE_SEQ_RET;\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_ERR_RET:\r\nreason = S5P_MFC_R2H_CMD_ERR_RET;\r\nbreak;\r\ndefault:\r\nreason = S5P_MFC_R2H_CMD_EMPTY;\r\n}\r\nreturn reason;\r\n}\r\nstatic int s5p_mfc_get_int_err_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_RISC2HOST_ARG2);\r\n}\r\nstatic int s5p_mfc_err_dec_v5(unsigned int err)\r\n{\r\nreturn (err & S5P_FIMV_ERR_DEC_MASK) >> S5P_FIMV_ERR_DEC_SHIFT;\r\n}\r\nstatic int s5p_mfc_err_dspl_v5(unsigned int err)\r\n{\r\nreturn (err & S5P_FIMV_ERR_DSPL_MASK) >> S5P_FIMV_ERR_DSPL_SHIFT;\r\n}\r\nstatic int s5p_mfc_get_img_width_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_SI_HRESOL);\r\n}\r\nstatic int s5p_mfc_get_img_height_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_SI_VRESOL);\r\n}\r\nstatic int s5p_mfc_get_dpb_count_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_SI_BUF_NUMBER);\r\n}\r\nstatic int s5p_mfc_get_mv_count_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn -1;\r\n}\r\nstatic int s5p_mfc_get_inst_no_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_RISC2HOST_ARG1);\r\n}\r\nstatic int s5p_mfc_get_enc_strm_size_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_ENC_SI_STRM_SIZE);\r\n}\r\nstatic int s5p_mfc_get_enc_slice_type_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_ENC_SI_SLICE_TYPE);\r\n}\r\nstatic int s5p_mfc_get_enc_dpb_count_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn -1;\r\n}\r\nstatic int s5p_mfc_get_enc_pic_count_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn mfc_read(dev, S5P_FIMV_ENC_SI_PIC_CNT);\r\n}\r\nstatic int s5p_mfc_get_sei_avail_status_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nreturn s5p_mfc_read_info_v5(ctx, FRAME_PACK_SEI_AVAIL);\r\n}\r\nstatic int s5p_mfc_get_mvc_num_views_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn -1;\r\n}\r\nstatic int s5p_mfc_get_mvc_view_id_v5(struct s5p_mfc_dev *dev)\r\n{\r\nreturn -1;\r\n}\r\nstatic unsigned int s5p_mfc_get_pic_type_top_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nreturn s5p_mfc_read_info_v5(ctx, PIC_TIME_TOP);\r\n}\r\nstatic unsigned int s5p_mfc_get_pic_type_bot_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nreturn s5p_mfc_read_info_v5(ctx, PIC_TIME_BOT);\r\n}\r\nstatic unsigned int s5p_mfc_get_crop_info_h_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nreturn s5p_mfc_read_info_v5(ctx, CROP_INFO_H);\r\n}\r\nstatic unsigned int s5p_mfc_get_crop_info_v_v5(struct s5p_mfc_ctx *ctx)\r\n{\r\nreturn s5p_mfc_read_info_v5(ctx, CROP_INFO_V);\r\n}\r\nstruct s5p_mfc_hw_ops *s5p_mfc_init_hw_ops_v5(void)\r\n{\r\nreturn &s5p_mfc_ops_v5;\r\n}
