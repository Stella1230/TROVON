void omap_control_phy_power(struct device *dev, int on)\r\n{\r\nu32 val;\r\nunsigned long rate;\r\nstruct omap_control_phy *control_phy;\r\nif (IS_ERR(dev) || !dev) {\r\npr_err("%s: invalid device\n", __func__);\r\nreturn;\r\n}\r\ncontrol_phy = dev_get_drvdata(dev);\r\nif (!control_phy) {\r\ndev_err(dev, "%s: invalid control phy device\n", __func__);\r\nreturn;\r\n}\r\nif (control_phy->type == OMAP_CTRL_TYPE_OTGHS)\r\nreturn;\r\nval = readl(control_phy->power);\r\nswitch (control_phy->type) {\r\ncase OMAP_CTRL_TYPE_USB2:\r\nif (on)\r\nval &= ~OMAP_CTRL_DEV_PHY_PD;\r\nelse\r\nval |= OMAP_CTRL_DEV_PHY_PD;\r\nbreak;\r\ncase OMAP_CTRL_TYPE_PIPE3:\r\nrate = clk_get_rate(control_phy->sys_clk);\r\nrate = rate/1000000;\r\nif (on) {\r\nval &= ~(OMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_CMD_MASK |\r\nOMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_FREQ_MASK);\r\nval |= OMAP_CTRL_PIPE3_PHY_TX_RX_POWERON <<\r\nOMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_CMD_SHIFT;\r\nval |= rate <<\r\nOMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_FREQ_SHIFT;\r\n} else {\r\nval &= ~OMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_CMD_MASK;\r\nval |= OMAP_CTRL_PIPE3_PHY_TX_RX_POWEROFF <<\r\nOMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_CMD_SHIFT;\r\n}\r\nbreak;\r\ncase OMAP_CTRL_TYPE_DRA7USB2:\r\nif (on)\r\nval &= ~OMAP_CTRL_USB2_PHY_PD;\r\nelse\r\nval |= OMAP_CTRL_USB2_PHY_PD;\r\nbreak;\r\ncase OMAP_CTRL_TYPE_AM437USB2:\r\nif (on) {\r\nval &= ~(AM437X_CTRL_USB2_PHY_PD |\r\nAM437X_CTRL_USB2_OTG_PD);\r\nval |= (AM437X_CTRL_USB2_OTGVDET_EN |\r\nAM437X_CTRL_USB2_OTGSESSEND_EN);\r\n} else {\r\nval &= ~(AM437X_CTRL_USB2_OTGVDET_EN |\r\nAM437X_CTRL_USB2_OTGSESSEND_EN);\r\nval |= (AM437X_CTRL_USB2_PHY_PD |\r\nAM437X_CTRL_USB2_OTG_PD);\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s: type %d not recognized\n",\r\n__func__, control_phy->type);\r\nbreak;\r\n}\r\nwritel(val, control_phy->power);\r\n}\r\nstatic void omap_control_usb_host_mode(struct omap_control_phy *ctrl_phy)\r\n{\r\nu32 val;\r\nval = readl(ctrl_phy->otghs_control);\r\nval &= ~(OMAP_CTRL_DEV_IDDIG | OMAP_CTRL_DEV_SESSEND);\r\nval |= OMAP_CTRL_DEV_AVALID | OMAP_CTRL_DEV_VBUSVALID;\r\nwritel(val, ctrl_phy->otghs_control);\r\n}\r\nstatic void omap_control_usb_device_mode(struct omap_control_phy *ctrl_phy)\r\n{\r\nu32 val;\r\nval = readl(ctrl_phy->otghs_control);\r\nval &= ~OMAP_CTRL_DEV_SESSEND;\r\nval |= OMAP_CTRL_DEV_IDDIG | OMAP_CTRL_DEV_AVALID |\r\nOMAP_CTRL_DEV_VBUSVALID;\r\nwritel(val, ctrl_phy->otghs_control);\r\n}\r\nstatic void omap_control_usb_set_sessionend(struct omap_control_phy *ctrl_phy)\r\n{\r\nu32 val;\r\nval = readl(ctrl_phy->otghs_control);\r\nval &= ~(OMAP_CTRL_DEV_AVALID | OMAP_CTRL_DEV_VBUSVALID);\r\nval |= OMAP_CTRL_DEV_IDDIG | OMAP_CTRL_DEV_SESSEND;\r\nwritel(val, ctrl_phy->otghs_control);\r\n}\r\nvoid omap_control_usb_set_mode(struct device *dev,\r\nenum omap_control_usb_mode mode)\r\n{\r\nstruct omap_control_phy *ctrl_phy;\r\nif (IS_ERR(dev) || !dev)\r\nreturn;\r\nctrl_phy = dev_get_drvdata(dev);\r\nif (!ctrl_phy) {\r\ndev_err(dev, "Invalid control phy device\n");\r\nreturn;\r\n}\r\nif (ctrl_phy->type != OMAP_CTRL_TYPE_OTGHS)\r\nreturn;\r\nswitch (mode) {\r\ncase USB_MODE_HOST:\r\nomap_control_usb_host_mode(ctrl_phy);\r\nbreak;\r\ncase USB_MODE_DEVICE:\r\nomap_control_usb_device_mode(ctrl_phy);\r\nbreak;\r\ncase USB_MODE_DISCONNECT:\r\nomap_control_usb_set_sessionend(ctrl_phy);\r\nbreak;\r\ndefault:\r\ndev_vdbg(dev, "invalid omap control usb mode\n");\r\n}\r\n}\r\nstatic int omap_control_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nconst struct of_device_id *of_id;\r\nstruct omap_control_phy *control_phy;\r\nof_id = of_match_device(of_match_ptr(omap_control_phy_id_table),\r\n&pdev->dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\ncontrol_phy = devm_kzalloc(&pdev->dev, sizeof(*control_phy),\r\nGFP_KERNEL);\r\nif (!control_phy) {\r\ndev_err(&pdev->dev, "unable to alloc memory for control phy\n");\r\nreturn -ENOMEM;\r\n}\r\ncontrol_phy->dev = &pdev->dev;\r\ncontrol_phy->type = *(enum omap_control_phy_type *)of_id->data;\r\nif (control_phy->type == OMAP_CTRL_TYPE_OTGHS) {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"otghs_control");\r\ncontrol_phy->otghs_control = devm_ioremap_resource(\r\n&pdev->dev, res);\r\nif (IS_ERR(control_phy->otghs_control))\r\nreturn PTR_ERR(control_phy->otghs_control);\r\n} else {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"power");\r\ncontrol_phy->power = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(control_phy->power)) {\r\ndev_err(&pdev->dev, "Couldn't get power register\n");\r\nreturn PTR_ERR(control_phy->power);\r\n}\r\n}\r\nif (control_phy->type == OMAP_CTRL_TYPE_PIPE3) {\r\ncontrol_phy->sys_clk = devm_clk_get(control_phy->dev,\r\n"sys_clkin");\r\nif (IS_ERR(control_phy->sys_clk)) {\r\npr_err("%s: unable to get sys_clkin\n", __func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev_set_drvdata(control_phy->dev, control_phy);\r\nreturn 0;\r\n}\r\nstatic int __init omap_control_phy_init(void)\r\n{\r\nreturn platform_driver_register(&omap_control_phy_driver);\r\n}\r\nstatic void __exit omap_control_phy_exit(void)\r\n{\r\nplatform_driver_unregister(&omap_control_phy_driver);\r\n}
