struct dasd_device *dasd_alloc_device(void)\r\n{\r\nstruct dasd_device *device;\r\ndevice = kzalloc(sizeof(struct dasd_device), GFP_ATOMIC);\r\nif (!device)\r\nreturn ERR_PTR(-ENOMEM);\r\ndevice->ccw_mem = (void *) __get_free_pages(GFP_ATOMIC | GFP_DMA, 1);\r\nif (!device->ccw_mem) {\r\nkfree(device);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndevice->erp_mem = (void *) get_zeroed_page(GFP_ATOMIC | GFP_DMA);\r\nif (!device->erp_mem) {\r\nfree_pages((unsigned long) device->ccw_mem, 1);\r\nkfree(device);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndasd_init_chunklist(&device->ccw_chunks, device->ccw_mem, PAGE_SIZE*2);\r\ndasd_init_chunklist(&device->erp_chunks, device->erp_mem, PAGE_SIZE);\r\nspin_lock_init(&device->mem_lock);\r\natomic_set(&device->tasklet_scheduled, 0);\r\ntasklet_init(&device->tasklet,\r\n(void (*)(unsigned long)) dasd_device_tasklet,\r\n(unsigned long) device);\r\nINIT_LIST_HEAD(&device->ccw_queue);\r\ninit_timer(&device->timer);\r\ndevice->timer.function = dasd_device_timeout;\r\ndevice->timer.data = (unsigned long) device;\r\nINIT_WORK(&device->kick_work, do_kick_device);\r\nINIT_WORK(&device->restore_device, do_restore_device);\r\nINIT_WORK(&device->reload_device, do_reload_device);\r\ndevice->state = DASD_STATE_NEW;\r\ndevice->target = DASD_STATE_NEW;\r\nmutex_init(&device->state_mutex);\r\nspin_lock_init(&device->profile.lock);\r\nreturn device;\r\n}\r\nvoid dasd_free_device(struct dasd_device *device)\r\n{\r\nkfree(device->private);\r\nfree_page((unsigned long) device->erp_mem);\r\nfree_pages((unsigned long) device->ccw_mem, 1);\r\nkfree(device);\r\n}\r\nstruct dasd_block *dasd_alloc_block(void)\r\n{\r\nstruct dasd_block *block;\r\nblock = kzalloc(sizeof(*block), GFP_ATOMIC);\r\nif (!block)\r\nreturn ERR_PTR(-ENOMEM);\r\natomic_set(&block->open_count, -1);\r\nspin_lock_init(&block->request_queue_lock);\r\natomic_set(&block->tasklet_scheduled, 0);\r\ntasklet_init(&block->tasklet,\r\n(void (*)(unsigned long)) dasd_block_tasklet,\r\n(unsigned long) block);\r\nINIT_LIST_HEAD(&block->ccw_queue);\r\nspin_lock_init(&block->queue_lock);\r\ninit_timer(&block->timer);\r\nblock->timer.function = dasd_block_timeout;\r\nblock->timer.data = (unsigned long) block;\r\nspin_lock_init(&block->profile.lock);\r\nreturn block;\r\n}\r\nvoid dasd_free_block(struct dasd_block *block)\r\n{\r\nkfree(block);\r\n}\r\nstatic int dasd_state_new_to_known(struct dasd_device *device)\r\n{\r\nint rc;\r\ndasd_get_device(device);\r\nif (device->block) {\r\nrc = dasd_alloc_queue(device->block);\r\nif (rc) {\r\ndasd_put_device(device);\r\nreturn rc;\r\n}\r\n}\r\ndevice->state = DASD_STATE_KNOWN;\r\nreturn 0;\r\n}\r\nstatic int dasd_state_known_to_new(struct dasd_device *device)\r\n{\r\ndasd_eer_disable(device);\r\nif (device->discipline) {\r\nif (device->discipline->uncheck_device)\r\ndevice->discipline->uncheck_device(device);\r\nmodule_put(device->discipline->owner);\r\n}\r\ndevice->discipline = NULL;\r\nif (device->base_discipline)\r\nmodule_put(device->base_discipline->owner);\r\ndevice->base_discipline = NULL;\r\ndevice->state = DASD_STATE_NEW;\r\nif (device->block)\r\ndasd_free_queue(device->block);\r\ndasd_put_device(device);\r\nreturn 0;\r\n}\r\nstatic struct dentry *dasd_debugfs_setup(const char *name,\r\nstruct dentry *base_dentry)\r\n{\r\nstruct dentry *pde;\r\nif (!base_dentry)\r\nreturn NULL;\r\npde = debugfs_create_dir(name, base_dentry);\r\nif (!pde || IS_ERR(pde))\r\nreturn NULL;\r\nreturn pde;\r\n}\r\nstatic int dasd_state_known_to_basic(struct dasd_device *device)\r\n{\r\nstruct dasd_block *block = device->block;\r\nint rc = 0;\r\nif (block) {\r\nrc = dasd_gendisk_alloc(block);\r\nif (rc)\r\nreturn rc;\r\nblock->debugfs_dentry =\r\ndasd_debugfs_setup(block->gdp->disk_name,\r\ndasd_debugfs_root_entry);\r\ndasd_profile_init(&block->profile, block->debugfs_dentry);\r\nif (dasd_global_profile_level == DASD_PROFILE_ON)\r\ndasd_profile_on(&device->block->profile);\r\n}\r\ndevice->debugfs_dentry =\r\ndasd_debugfs_setup(dev_name(&device->cdev->dev),\r\ndasd_debugfs_root_entry);\r\ndasd_profile_init(&device->profile, device->debugfs_dentry);\r\ndevice->debug_area = debug_register(dev_name(&device->cdev->dev), 4, 1,\r\n8 * sizeof(long));\r\ndebug_register_view(device->debug_area, &debug_sprintf_view);\r\ndebug_set_level(device->debug_area, DBF_WARNING);\r\nDBF_DEV_EVENT(DBF_EMERG, device, "%s", "debug area created");\r\ndevice->state = DASD_STATE_BASIC;\r\nreturn rc;\r\n}\r\nstatic int dasd_state_basic_to_known(struct dasd_device *device)\r\n{\r\nint rc;\r\nif (device->block) {\r\ndasd_profile_exit(&device->block->profile);\r\nif (device->block->debugfs_dentry)\r\ndebugfs_remove(device->block->debugfs_dentry);\r\ndasd_gendisk_free(device->block);\r\ndasd_block_clear_timer(device->block);\r\n}\r\nrc = dasd_flush_device_queue(device);\r\nif (rc)\r\nreturn rc;\r\ndasd_device_clear_timer(device);\r\ndasd_profile_exit(&device->profile);\r\nif (device->debugfs_dentry)\r\ndebugfs_remove(device->debugfs_dentry);\r\nDBF_DEV_EVENT(DBF_EMERG, device, "%p debug area deleted", device);\r\nif (device->debug_area != NULL) {\r\ndebug_unregister(device->debug_area);\r\ndevice->debug_area = NULL;\r\n}\r\ndevice->state = DASD_STATE_KNOWN;\r\nreturn 0;\r\n}\r\nstatic int dasd_state_basic_to_ready(struct dasd_device *device)\r\n{\r\nint rc;\r\nstruct dasd_block *block;\r\nrc = 0;\r\nblock = device->block;\r\nif (block) {\r\nif (block->base->discipline->do_analysis != NULL)\r\nrc = block->base->discipline->do_analysis(block);\r\nif (rc) {\r\nif (rc != -EAGAIN) {\r\ndevice->state = DASD_STATE_UNFMT;\r\ngoto out;\r\n}\r\nreturn rc;\r\n}\r\ndasd_setup_queue(block);\r\nset_capacity(block->gdp,\r\nblock->blocks << block->s2b_shift);\r\ndevice->state = DASD_STATE_READY;\r\nrc = dasd_scan_partitions(block);\r\nif (rc) {\r\ndevice->state = DASD_STATE_BASIC;\r\nreturn rc;\r\n}\r\n} else {\r\ndevice->state = DASD_STATE_READY;\r\n}\r\nout:\r\nif (device->discipline->basic_to_ready)\r\nrc = device->discipline->basic_to_ready(device);\r\nreturn rc;\r\n}\r\nstatic inline\r\nint _wait_for_empty_queues(struct dasd_device *device)\r\n{\r\nif (device->block)\r\nreturn list_empty(&device->ccw_queue) &&\r\nlist_empty(&device->block->ccw_queue);\r\nelse\r\nreturn list_empty(&device->ccw_queue);\r\n}\r\nstatic int dasd_state_ready_to_basic(struct dasd_device *device)\r\n{\r\nint rc;\r\nif (device->discipline->ready_to_basic) {\r\nrc = device->discipline->ready_to_basic(device);\r\nif (rc)\r\nreturn rc;\r\n}\r\ndevice->state = DASD_STATE_BASIC;\r\nif (device->block) {\r\nstruct dasd_block *block = device->block;\r\nrc = dasd_flush_block_queue(block);\r\nif (rc) {\r\ndevice->state = DASD_STATE_READY;\r\nreturn rc;\r\n}\r\ndasd_flush_request_queue(block);\r\ndasd_destroy_partitions(block);\r\nblock->blocks = 0;\r\nblock->bp_block = 0;\r\nblock->s2b_shift = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dasd_state_unfmt_to_basic(struct dasd_device *device)\r\n{\r\ndevice->state = DASD_STATE_BASIC;\r\nreturn 0;\r\n}\r\nstatic int\r\ndasd_state_ready_to_online(struct dasd_device * device)\r\n{\r\nstruct gendisk *disk;\r\nstruct disk_part_iter piter;\r\nstruct hd_struct *part;\r\ndevice->state = DASD_STATE_ONLINE;\r\nif (device->block) {\r\ndasd_schedule_block_bh(device->block);\r\nif ((device->features & DASD_FEATURE_USERAW)) {\r\ndisk = device->block->gdp;\r\nkobject_uevent(&disk_to_dev(disk)->kobj, KOBJ_CHANGE);\r\nreturn 0;\r\n}\r\ndisk = device->block->bdev->bd_disk;\r\ndisk_part_iter_init(&piter, disk, DISK_PITER_INCL_PART0);\r\nwhile ((part = disk_part_iter_next(&piter)))\r\nkobject_uevent(&part_to_dev(part)->kobj, KOBJ_CHANGE);\r\ndisk_part_iter_exit(&piter);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dasd_state_online_to_ready(struct dasd_device *device)\r\n{\r\nint rc;\r\nstruct gendisk *disk;\r\nstruct disk_part_iter piter;\r\nstruct hd_struct *part;\r\nif (device->discipline->online_to_ready) {\r\nrc = device->discipline->online_to_ready(device);\r\nif (rc)\r\nreturn rc;\r\n}\r\ndevice->state = DASD_STATE_READY;\r\nif (device->block && !(device->features & DASD_FEATURE_USERAW)) {\r\ndisk = device->block->bdev->bd_disk;\r\ndisk_part_iter_init(&piter, disk, DISK_PITER_INCL_PART0);\r\nwhile ((part = disk_part_iter_next(&piter)))\r\nkobject_uevent(&part_to_dev(part)->kobj, KOBJ_CHANGE);\r\ndisk_part_iter_exit(&piter);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dasd_increase_state(struct dasd_device *device)\r\n{\r\nint rc;\r\nrc = 0;\r\nif (device->state == DASD_STATE_NEW &&\r\ndevice->target >= DASD_STATE_KNOWN)\r\nrc = dasd_state_new_to_known(device);\r\nif (!rc &&\r\ndevice->state == DASD_STATE_KNOWN &&\r\ndevice->target >= DASD_STATE_BASIC)\r\nrc = dasd_state_known_to_basic(device);\r\nif (!rc &&\r\ndevice->state == DASD_STATE_BASIC &&\r\ndevice->target >= DASD_STATE_READY)\r\nrc = dasd_state_basic_to_ready(device);\r\nif (!rc &&\r\ndevice->state == DASD_STATE_UNFMT &&\r\ndevice->target > DASD_STATE_UNFMT)\r\nrc = -EPERM;\r\nif (!rc &&\r\ndevice->state == DASD_STATE_READY &&\r\ndevice->target >= DASD_STATE_ONLINE)\r\nrc = dasd_state_ready_to_online(device);\r\nreturn rc;\r\n}\r\nstatic int dasd_decrease_state(struct dasd_device *device)\r\n{\r\nint rc;\r\nrc = 0;\r\nif (device->state == DASD_STATE_ONLINE &&\r\ndevice->target <= DASD_STATE_READY)\r\nrc = dasd_state_online_to_ready(device);\r\nif (!rc &&\r\ndevice->state == DASD_STATE_READY &&\r\ndevice->target <= DASD_STATE_BASIC)\r\nrc = dasd_state_ready_to_basic(device);\r\nif (!rc &&\r\ndevice->state == DASD_STATE_UNFMT &&\r\ndevice->target <= DASD_STATE_BASIC)\r\nrc = dasd_state_unfmt_to_basic(device);\r\nif (!rc &&\r\ndevice->state == DASD_STATE_BASIC &&\r\ndevice->target <= DASD_STATE_KNOWN)\r\nrc = dasd_state_basic_to_known(device);\r\nif (!rc &&\r\ndevice->state == DASD_STATE_KNOWN &&\r\ndevice->target <= DASD_STATE_NEW)\r\nrc = dasd_state_known_to_new(device);\r\nreturn rc;\r\n}\r\nstatic void dasd_change_state(struct dasd_device *device)\r\n{\r\nint rc;\r\nif (device->state == device->target)\r\nreturn;\r\nif (device->state < device->target)\r\nrc = dasd_increase_state(device);\r\nelse\r\nrc = dasd_decrease_state(device);\r\nif (rc == -EAGAIN)\r\nreturn;\r\nif (rc)\r\ndevice->target = device->state;\r\nkobject_uevent(&device->cdev->dev.kobj, KOBJ_CHANGE);\r\nif (device->state == device->target)\r\nwake_up(&dasd_init_waitq);\r\n}\r\nstatic void do_kick_device(struct work_struct *work)\r\n{\r\nstruct dasd_device *device = container_of(work, struct dasd_device, kick_work);\r\nmutex_lock(&device->state_mutex);\r\ndasd_change_state(device);\r\nmutex_unlock(&device->state_mutex);\r\ndasd_schedule_device_bh(device);\r\ndasd_put_device(device);\r\n}\r\nvoid dasd_kick_device(struct dasd_device *device)\r\n{\r\ndasd_get_device(device);\r\nschedule_work(&device->kick_work);\r\n}\r\nstatic void do_reload_device(struct work_struct *work)\r\n{\r\nstruct dasd_device *device = container_of(work, struct dasd_device,\r\nreload_device);\r\ndevice->discipline->reload(device);\r\ndasd_put_device(device);\r\n}\r\nvoid dasd_reload_device(struct dasd_device *device)\r\n{\r\ndasd_get_device(device);\r\nschedule_work(&device->reload_device);\r\n}\r\nstatic void do_restore_device(struct work_struct *work)\r\n{\r\nstruct dasd_device *device = container_of(work, struct dasd_device,\r\nrestore_device);\r\ndevice->cdev->drv->restore(device->cdev);\r\ndasd_put_device(device);\r\n}\r\nvoid dasd_restore_device(struct dasd_device *device)\r\n{\r\ndasd_get_device(device);\r\nschedule_work(&device->restore_device);\r\n}\r\nvoid dasd_set_target_state(struct dasd_device *device, int target)\r\n{\r\ndasd_get_device(device);\r\nmutex_lock(&device->state_mutex);\r\nif (dasd_probeonly && target > DASD_STATE_READY)\r\ntarget = DASD_STATE_READY;\r\nif (device->target != target) {\r\nif (device->state == target)\r\nwake_up(&dasd_init_waitq);\r\ndevice->target = target;\r\n}\r\nif (device->state != device->target)\r\ndasd_change_state(device);\r\nmutex_unlock(&device->state_mutex);\r\ndasd_put_device(device);\r\n}\r\nstatic inline int _wait_for_device(struct dasd_device *device)\r\n{\r\nreturn (device->state == device->target);\r\n}\r\nvoid dasd_enable_device(struct dasd_device *device)\r\n{\r\ndasd_set_target_state(device, DASD_STATE_ONLINE);\r\nif (device->state <= DASD_STATE_KNOWN)\r\ndasd_set_target_state(device, DASD_STATE_NEW);\r\nwait_event(dasd_init_waitq, _wait_for_device(device));\r\ndasd_reload_device(device);\r\nif (device->discipline->kick_validate)\r\ndevice->discipline->kick_validate(device);\r\n}\r\nstatic void dasd_profile_start(struct dasd_block *block,\r\nstruct dasd_ccw_req *cqr,\r\nstruct request *req)\r\n{\r\nstruct list_head *l;\r\nunsigned int counter;\r\nstruct dasd_device *device;\r\ncounter = 0;\r\nif (dasd_global_profile_level || block->profile.data)\r\nlist_for_each(l, &block->ccw_queue)\r\nif (++counter >= 31)\r\nbreak;\r\nif (dasd_global_profile_level) {\r\ndasd_global_profile_data.dasd_io_nr_req[counter]++;\r\nif (rq_data_dir(req) == READ)\r\ndasd_global_profile_data.dasd_read_nr_req[counter]++;\r\n}\r\nspin_lock(&block->profile.lock);\r\nif (block->profile.data) {\r\nblock->profile.data->dasd_io_nr_req[counter]++;\r\nif (rq_data_dir(req) == READ)\r\nblock->profile.data->dasd_read_nr_req[counter]++;\r\n}\r\nspin_unlock(&block->profile.lock);\r\ndevice = cqr->startdev;\r\nif (device->profile.data) {\r\ncounter = 1;\r\nlist_for_each(l, &device->ccw_queue)\r\nif (++counter >= 31)\r\nbreak;\r\n}\r\nspin_lock(&device->profile.lock);\r\nif (device->profile.data) {\r\ndevice->profile.data->dasd_io_nr_req[counter]++;\r\nif (rq_data_dir(req) == READ)\r\ndevice->profile.data->dasd_read_nr_req[counter]++;\r\n}\r\nspin_unlock(&device->profile.lock);\r\n}\r\nstatic void dasd_profile_end_add_data(struct dasd_profile_info *data,\r\nint is_alias,\r\nint is_tpm,\r\nint is_read,\r\nlong sectors,\r\nint sectors_ind,\r\nint tottime_ind,\r\nint tottimeps_ind,\r\nint strtime_ind,\r\nint irqtime_ind,\r\nint irqtimeps_ind,\r\nint endtime_ind)\r\n{\r\nif (data->dasd_io_reqs == UINT_MAX) {\r\nmemset(data, 0, sizeof(*data));\r\ngetnstimeofday(&data->starttod);\r\n}\r\ndata->dasd_io_reqs++;\r\ndata->dasd_io_sects += sectors;\r\nif (is_alias)\r\ndata->dasd_io_alias++;\r\nif (is_tpm)\r\ndata->dasd_io_tpm++;\r\ndata->dasd_io_secs[sectors_ind]++;\r\ndata->dasd_io_times[tottime_ind]++;\r\ndata->dasd_io_timps[tottimeps_ind]++;\r\ndata->dasd_io_time1[strtime_ind]++;\r\ndata->dasd_io_time2[irqtime_ind]++;\r\ndata->dasd_io_time2ps[irqtimeps_ind]++;\r\ndata->dasd_io_time3[endtime_ind]++;\r\nif (is_read) {\r\ndata->dasd_read_reqs++;\r\ndata->dasd_read_sects += sectors;\r\nif (is_alias)\r\ndata->dasd_read_alias++;\r\nif (is_tpm)\r\ndata->dasd_read_tpm++;\r\ndata->dasd_read_secs[sectors_ind]++;\r\ndata->dasd_read_times[tottime_ind]++;\r\ndata->dasd_read_time1[strtime_ind]++;\r\ndata->dasd_read_time2[irqtime_ind]++;\r\ndata->dasd_read_time3[endtime_ind]++;\r\n}\r\n}\r\nstatic void dasd_profile_end(struct dasd_block *block,\r\nstruct dasd_ccw_req *cqr,\r\nstruct request *req)\r\n{\r\nlong strtime, irqtime, endtime, tottime;\r\nlong tottimeps, sectors;\r\nstruct dasd_device *device;\r\nint sectors_ind, tottime_ind, tottimeps_ind, strtime_ind;\r\nint irqtime_ind, irqtimeps_ind, endtime_ind;\r\ndevice = cqr->startdev;\r\nif (!(dasd_global_profile_level ||\r\nblock->profile.data ||\r\ndevice->profile.data))\r\nreturn;\r\nsectors = blk_rq_sectors(req);\r\nif (!cqr->buildclk || !cqr->startclk ||\r\n!cqr->stopclk || !cqr->endclk ||\r\n!sectors)\r\nreturn;\r\nstrtime = ((cqr->startclk - cqr->buildclk) >> 12);\r\nirqtime = ((cqr->stopclk - cqr->startclk) >> 12);\r\nendtime = ((cqr->endclk - cqr->stopclk) >> 12);\r\ntottime = ((cqr->endclk - cqr->buildclk) >> 12);\r\ntottimeps = tottime / sectors;\r\ndasd_profile_counter(sectors, sectors_ind);\r\ndasd_profile_counter(tottime, tottime_ind);\r\ndasd_profile_counter(tottimeps, tottimeps_ind);\r\ndasd_profile_counter(strtime, strtime_ind);\r\ndasd_profile_counter(irqtime, irqtime_ind);\r\ndasd_profile_counter(irqtime / sectors, irqtimeps_ind);\r\ndasd_profile_counter(endtime, endtime_ind);\r\nif (dasd_global_profile_level) {\r\ndasd_profile_end_add_data(&dasd_global_profile_data,\r\ncqr->startdev != block->base,\r\ncqr->cpmode == 1,\r\nrq_data_dir(req) == READ,\r\nsectors, sectors_ind, tottime_ind,\r\ntottimeps_ind, strtime_ind,\r\nirqtime_ind, irqtimeps_ind,\r\nendtime_ind);\r\n}\r\nspin_lock(&block->profile.lock);\r\nif (block->profile.data)\r\ndasd_profile_end_add_data(block->profile.data,\r\ncqr->startdev != block->base,\r\ncqr->cpmode == 1,\r\nrq_data_dir(req) == READ,\r\nsectors, sectors_ind, tottime_ind,\r\ntottimeps_ind, strtime_ind,\r\nirqtime_ind, irqtimeps_ind,\r\nendtime_ind);\r\nspin_unlock(&block->profile.lock);\r\nspin_lock(&device->profile.lock);\r\nif (device->profile.data)\r\ndasd_profile_end_add_data(device->profile.data,\r\ncqr->startdev != block->base,\r\ncqr->cpmode == 1,\r\nrq_data_dir(req) == READ,\r\nsectors, sectors_ind, tottime_ind,\r\ntottimeps_ind, strtime_ind,\r\nirqtime_ind, irqtimeps_ind,\r\nendtime_ind);\r\nspin_unlock(&device->profile.lock);\r\n}\r\nvoid dasd_profile_reset(struct dasd_profile *profile)\r\n{\r\nstruct dasd_profile_info *data;\r\nspin_lock_bh(&profile->lock);\r\ndata = profile->data;\r\nif (!data) {\r\nspin_unlock_bh(&profile->lock);\r\nreturn;\r\n}\r\nmemset(data, 0, sizeof(*data));\r\ngetnstimeofday(&data->starttod);\r\nspin_unlock_bh(&profile->lock);\r\n}\r\nvoid dasd_global_profile_reset(void)\r\n{\r\nmemset(&dasd_global_profile_data, 0, sizeof(dasd_global_profile_data));\r\ngetnstimeofday(&dasd_global_profile_data.starttod);\r\n}\r\nint dasd_profile_on(struct dasd_profile *profile)\r\n{\r\nstruct dasd_profile_info *data;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspin_lock_bh(&profile->lock);\r\nif (profile->data) {\r\nspin_unlock_bh(&profile->lock);\r\nkfree(data);\r\nreturn 0;\r\n}\r\ngetnstimeofday(&data->starttod);\r\nprofile->data = data;\r\nspin_unlock_bh(&profile->lock);\r\nreturn 0;\r\n}\r\nvoid dasd_profile_off(struct dasd_profile *profile)\r\n{\r\nspin_lock_bh(&profile->lock);\r\nkfree(profile->data);\r\nprofile->data = NULL;\r\nspin_unlock_bh(&profile->lock);\r\n}\r\nchar *dasd_get_user_string(const char __user *user_buf, size_t user_len)\r\n{\r\nchar *buffer;\r\nbuffer = vmalloc(user_len + 1);\r\nif (buffer == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (copy_from_user(buffer, user_buf, user_len) != 0) {\r\nvfree(buffer);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nif (buffer[user_len - 1] == '\n')\r\nbuffer[user_len - 1] = 0;\r\nelse\r\nbuffer[user_len] = 0;\r\nreturn buffer;\r\n}\r\nstatic ssize_t dasd_stats_write(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t user_len, loff_t *pos)\r\n{\r\nchar *buffer, *str;\r\nint rc;\r\nstruct seq_file *m = (struct seq_file *)file->private_data;\r\nstruct dasd_profile *prof = m->private;\r\nif (user_len > 65536)\r\nuser_len = 65536;\r\nbuffer = dasd_get_user_string(user_buf, user_len);\r\nif (IS_ERR(buffer))\r\nreturn PTR_ERR(buffer);\r\nstr = skip_spaces(buffer);\r\nrc = user_len;\r\nif (strncmp(str, "reset", 5) == 0) {\r\ndasd_profile_reset(prof);\r\n} else if (strncmp(str, "on", 2) == 0) {\r\nrc = dasd_profile_on(prof);\r\nif (!rc)\r\nrc = user_len;\r\n} else if (strncmp(str, "off", 3) == 0) {\r\ndasd_profile_off(prof);\r\n} else\r\nrc = -EINVAL;\r\nvfree(buffer);\r\nreturn rc;\r\n}\r\nstatic void dasd_stats_array(struct seq_file *m, unsigned int *array)\r\n{\r\nint i;\r\nfor (i = 0; i < 32; i++)\r\nseq_printf(m, "%u ", array[i]);\r\nseq_putc(m, '\n');\r\n}\r\nstatic void dasd_stats_seq_print(struct seq_file *m,\r\nstruct dasd_profile_info *data)\r\n{\r\nseq_printf(m, "start_time %ld.%09ld\n",\r\ndata->starttod.tv_sec, data->starttod.tv_nsec);\r\nseq_printf(m, "total_requests %u\n", data->dasd_io_reqs);\r\nseq_printf(m, "total_sectors %u\n", data->dasd_io_sects);\r\nseq_printf(m, "total_pav %u\n", data->dasd_io_alias);\r\nseq_printf(m, "total_hpf %u\n", data->dasd_io_tpm);\r\nseq_printf(m, "histogram_sectors ");\r\ndasd_stats_array(m, data->dasd_io_secs);\r\nseq_printf(m, "histogram_io_times ");\r\ndasd_stats_array(m, data->dasd_io_times);\r\nseq_printf(m, "histogram_io_times_weighted ");\r\ndasd_stats_array(m, data->dasd_io_timps);\r\nseq_printf(m, "histogram_time_build_to_ssch ");\r\ndasd_stats_array(m, data->dasd_io_time1);\r\nseq_printf(m, "histogram_time_ssch_to_irq ");\r\ndasd_stats_array(m, data->dasd_io_time2);\r\nseq_printf(m, "histogram_time_ssch_to_irq_weighted ");\r\ndasd_stats_array(m, data->dasd_io_time2ps);\r\nseq_printf(m, "histogram_time_irq_to_end ");\r\ndasd_stats_array(m, data->dasd_io_time3);\r\nseq_printf(m, "histogram_ccw_queue_length ");\r\ndasd_stats_array(m, data->dasd_io_nr_req);\r\nseq_printf(m, "total_read_requests %u\n", data->dasd_read_reqs);\r\nseq_printf(m, "total_read_sectors %u\n", data->dasd_read_sects);\r\nseq_printf(m, "total_read_pav %u\n", data->dasd_read_alias);\r\nseq_printf(m, "total_read_hpf %u\n", data->dasd_read_tpm);\r\nseq_printf(m, "histogram_read_sectors ");\r\ndasd_stats_array(m, data->dasd_read_secs);\r\nseq_printf(m, "histogram_read_times ");\r\ndasd_stats_array(m, data->dasd_read_times);\r\nseq_printf(m, "histogram_read_time_build_to_ssch ");\r\ndasd_stats_array(m, data->dasd_read_time1);\r\nseq_printf(m, "histogram_read_time_ssch_to_irq ");\r\ndasd_stats_array(m, data->dasd_read_time2);\r\nseq_printf(m, "histogram_read_time_irq_to_end ");\r\ndasd_stats_array(m, data->dasd_read_time3);\r\nseq_printf(m, "histogram_read_ccw_queue_length ");\r\ndasd_stats_array(m, data->dasd_read_nr_req);\r\n}\r\nstatic int dasd_stats_show(struct seq_file *m, void *v)\r\n{\r\nstruct dasd_profile *profile;\r\nstruct dasd_profile_info *data;\r\nprofile = m->private;\r\nspin_lock_bh(&profile->lock);\r\ndata = profile->data;\r\nif (!data) {\r\nspin_unlock_bh(&profile->lock);\r\nseq_printf(m, "disabled\n");\r\nreturn 0;\r\n}\r\ndasd_stats_seq_print(m, data);\r\nspin_unlock_bh(&profile->lock);\r\nreturn 0;\r\n}\r\nstatic int dasd_stats_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dasd_profile *profile = inode->i_private;\r\nreturn single_open(file, dasd_stats_show, profile);\r\n}\r\nstatic ssize_t dasd_stats_global_write(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t user_len, loff_t *pos)\r\n{\r\nchar *buffer, *str;\r\nssize_t rc;\r\nif (user_len > 65536)\r\nuser_len = 65536;\r\nbuffer = dasd_get_user_string(user_buf, user_len);\r\nif (IS_ERR(buffer))\r\nreturn PTR_ERR(buffer);\r\nstr = skip_spaces(buffer);\r\nrc = user_len;\r\nif (strncmp(str, "reset", 5) == 0) {\r\ndasd_global_profile_reset();\r\n} else if (strncmp(str, "on", 2) == 0) {\r\ndasd_global_profile_reset();\r\ndasd_global_profile_level = DASD_PROFILE_GLOBAL_ONLY;\r\n} else if (strncmp(str, "off", 3) == 0) {\r\ndasd_global_profile_level = DASD_PROFILE_OFF;\r\n} else\r\nrc = -EINVAL;\r\nvfree(buffer);\r\nreturn rc;\r\n}\r\nstatic int dasd_stats_global_show(struct seq_file *m, void *v)\r\n{\r\nif (!dasd_global_profile_level) {\r\nseq_printf(m, "disabled\n");\r\nreturn 0;\r\n}\r\ndasd_stats_seq_print(m, &dasd_global_profile_data);\r\nreturn 0;\r\n}\r\nstatic int dasd_stats_global_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dasd_stats_global_show, NULL);\r\n}\r\nstatic void dasd_profile_init(struct dasd_profile *profile,\r\nstruct dentry *base_dentry)\r\n{\r\numode_t mode;\r\nstruct dentry *pde;\r\nif (!base_dentry)\r\nreturn;\r\nprofile->dentry = NULL;\r\nprofile->data = NULL;\r\nmode = (S_IRUSR | S_IWUSR | S_IFREG);\r\npde = debugfs_create_file("statistics", mode, base_dentry,\r\nprofile, &dasd_stats_raw_fops);\r\nif (pde && !IS_ERR(pde))\r\nprofile->dentry = pde;\r\nreturn;\r\n}\r\nstatic void dasd_profile_exit(struct dasd_profile *profile)\r\n{\r\ndasd_profile_off(profile);\r\nif (profile->dentry) {\r\ndebugfs_remove(profile->dentry);\r\nprofile->dentry = NULL;\r\n}\r\n}\r\nstatic void dasd_statistics_removeroot(void)\r\n{\r\ndasd_global_profile_level = DASD_PROFILE_OFF;\r\nif (dasd_global_profile_dentry) {\r\ndebugfs_remove(dasd_global_profile_dentry);\r\ndasd_global_profile_dentry = NULL;\r\n}\r\nif (dasd_debugfs_global_entry)\r\ndebugfs_remove(dasd_debugfs_global_entry);\r\nif (dasd_debugfs_root_entry)\r\ndebugfs_remove(dasd_debugfs_root_entry);\r\n}\r\nstatic void dasd_statistics_createroot(void)\r\n{\r\numode_t mode;\r\nstruct dentry *pde;\r\ndasd_debugfs_root_entry = NULL;\r\ndasd_debugfs_global_entry = NULL;\r\ndasd_global_profile_dentry = NULL;\r\npde = debugfs_create_dir("dasd", NULL);\r\nif (!pde || IS_ERR(pde))\r\ngoto error;\r\ndasd_debugfs_root_entry = pde;\r\npde = debugfs_create_dir("global", dasd_debugfs_root_entry);\r\nif (!pde || IS_ERR(pde))\r\ngoto error;\r\ndasd_debugfs_global_entry = pde;\r\nmode = (S_IRUSR | S_IWUSR | S_IFREG);\r\npde = debugfs_create_file("statistics", mode, dasd_debugfs_global_entry,\r\nNULL, &dasd_stats_global_fops);\r\nif (!pde || IS_ERR(pde))\r\ngoto error;\r\ndasd_global_profile_dentry = pde;\r\nreturn;\r\nerror:\r\nDBF_EVENT(DBF_ERR, "%s",\r\n"Creation of the dasd debugfs interface failed");\r\ndasd_statistics_removeroot();\r\nreturn;\r\n}\r\nstatic void dasd_statistics_createroot(void)\r\n{\r\nreturn;\r\n}\r\nstatic void dasd_statistics_removeroot(void)\r\n{\r\nreturn;\r\n}\r\nint dasd_stats_generic_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "Statistics are not activated in this kernel\n");\r\nreturn 0;\r\n}\r\nstatic void dasd_profile_init(struct dasd_profile *profile,\r\nstruct dentry *base_dentry)\r\n{\r\nreturn;\r\n}\r\nstatic void dasd_profile_exit(struct dasd_profile *profile)\r\n{\r\nreturn;\r\n}\r\nint dasd_profile_on(struct dasd_profile *profile)\r\n{\r\nreturn 0;\r\n}\r\nstruct dasd_ccw_req *dasd_kmalloc_request(int magic, int cplength,\r\nint datasize,\r\nstruct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nBUG_ON(datasize > PAGE_SIZE ||\r\n(cplength*sizeof(struct ccw1)) > PAGE_SIZE);\r\ncqr = kzalloc(sizeof(struct dasd_ccw_req), GFP_ATOMIC);\r\nif (cqr == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ncqr->cpaddr = NULL;\r\nif (cplength > 0) {\r\ncqr->cpaddr = kcalloc(cplength, sizeof(struct ccw1),\r\nGFP_ATOMIC | GFP_DMA);\r\nif (cqr->cpaddr == NULL) {\r\nkfree(cqr);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\ncqr->data = NULL;\r\nif (datasize > 0) {\r\ncqr->data = kzalloc(datasize, GFP_ATOMIC | GFP_DMA);\r\nif (cqr->data == NULL) {\r\nkfree(cqr->cpaddr);\r\nkfree(cqr);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\ncqr->magic = magic;\r\nset_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\ndasd_get_device(device);\r\nreturn cqr;\r\n}\r\nstruct dasd_ccw_req *dasd_smalloc_request(int magic, int cplength,\r\nint datasize,\r\nstruct dasd_device *device)\r\n{\r\nunsigned long flags;\r\nstruct dasd_ccw_req *cqr;\r\nchar *data;\r\nint size;\r\nsize = (sizeof(struct dasd_ccw_req) + 7L) & -8L;\r\nif (cplength > 0)\r\nsize += cplength * sizeof(struct ccw1);\r\nif (datasize > 0)\r\nsize += datasize;\r\nspin_lock_irqsave(&device->mem_lock, flags);\r\ncqr = (struct dasd_ccw_req *)\r\ndasd_alloc_chunk(&device->ccw_chunks, size);\r\nspin_unlock_irqrestore(&device->mem_lock, flags);\r\nif (cqr == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemset(cqr, 0, sizeof(struct dasd_ccw_req));\r\ndata = (char *) cqr + ((sizeof(struct dasd_ccw_req) + 7L) & -8L);\r\ncqr->cpaddr = NULL;\r\nif (cplength > 0) {\r\ncqr->cpaddr = (struct ccw1 *) data;\r\ndata += cplength*sizeof(struct ccw1);\r\nmemset(cqr->cpaddr, 0, cplength*sizeof(struct ccw1));\r\n}\r\ncqr->data = NULL;\r\nif (datasize > 0) {\r\ncqr->data = data;\r\nmemset(cqr->data, 0, datasize);\r\n}\r\ncqr->magic = magic;\r\nset_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\ndasd_get_device(device);\r\nreturn cqr;\r\n}\r\nvoid dasd_kfree_request(struct dasd_ccw_req *cqr, struct dasd_device *device)\r\n{\r\n#ifdef CONFIG_64BIT\r\nstruct ccw1 *ccw;\r\nccw = cqr->cpaddr;\r\ndo {\r\nclear_normalized_cda(ccw);\r\n} while (ccw++->flags & (CCW_FLAG_CC | CCW_FLAG_DC));\r\n#endif\r\nkfree(cqr->cpaddr);\r\nkfree(cqr->data);\r\nkfree(cqr);\r\ndasd_put_device(device);\r\n}\r\nvoid dasd_sfree_request(struct dasd_ccw_req *cqr, struct dasd_device *device)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&device->mem_lock, flags);\r\ndasd_free_chunk(&device->ccw_chunks, cqr);\r\nspin_unlock_irqrestore(&device->mem_lock, flags);\r\ndasd_put_device(device);\r\n}\r\nstatic inline int dasd_check_cqr(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device;\r\nif (cqr == NULL)\r\nreturn -EINVAL;\r\ndevice = cqr->startdev;\r\nif (strncmp((char *) &cqr->magic, device->discipline->ebcname, 4)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device,\r\n" dasd_ccw_req 0x%08x magic doesn't match"\r\n" discipline 0x%08x",\r\ncqr->magic,\r\n*(unsigned int *) device->discipline->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint dasd_term_IO(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device;\r\nint retries, rc;\r\nchar errorstring[ERRORLENGTH];\r\nrc = dasd_check_cqr(cqr);\r\nif (rc)\r\nreturn rc;\r\nretries = 0;\r\ndevice = (struct dasd_device *) cqr->startdev;\r\nwhile ((retries < 5) && (cqr->status == DASD_CQR_IN_IO)) {\r\nrc = ccw_device_clear(device->cdev, (long) cqr);\r\nswitch (rc) {\r\ncase 0:\r\ncqr->status = DASD_CQR_CLEAR_PENDING;\r\ncqr->stopclk = get_tod_clock();\r\ncqr->starttime = 0;\r\nDBF_DEV_EVENT(DBF_DEBUG, device,\r\n"terminate cqr %p successful",\r\ncqr);\r\nbreak;\r\ncase -ENODEV:\r\nDBF_DEV_EVENT(DBF_ERR, device, "%s",\r\n"device gone, retry");\r\nbreak;\r\ncase -EIO:\r\nDBF_DEV_EVENT(DBF_ERR, device, "%s",\r\n"I/O error, retry");\r\nbreak;\r\ncase -EINVAL:\r\ncase -EBUSY:\r\nDBF_DEV_EVENT(DBF_ERR, device, "%s",\r\n"device busy, retry later");\r\nbreak;\r\ndefault:\r\nsnprintf(errorstring, ERRORLENGTH, "10 %d", rc);\r\ndev_err(&device->cdev->dev, "An error occurred in the "\r\n"DASD device driver, reason=%s\n", errorstring);\r\nBUG();\r\nbreak;\r\n}\r\nretries++;\r\n}\r\ndasd_schedule_device_bh(device);\r\nreturn rc;\r\n}\r\nint dasd_start_IO(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device;\r\nint rc;\r\nchar errorstring[ERRORLENGTH];\r\nrc = dasd_check_cqr(cqr);\r\nif (rc) {\r\ncqr->intrc = rc;\r\nreturn rc;\r\n}\r\ndevice = (struct dasd_device *) cqr->startdev;\r\nif (((cqr->block &&\r\ntest_bit(DASD_FLAG_LOCK_STOLEN, &cqr->block->base->flags)) ||\r\ntest_bit(DASD_FLAG_LOCK_STOLEN, &device->flags)) &&\r\n!test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)) {\r\nDBF_DEV_EVENT(DBF_DEBUG, device, "start_IO: return request %p "\r\n"because of stolen lock", cqr);\r\ncqr->status = DASD_CQR_ERROR;\r\ncqr->intrc = -EPERM;\r\nreturn -EPERM;\r\n}\r\nif (cqr->retries < 0) {\r\nsprintf(errorstring, "14 %p", cqr);\r\ndev_err(&device->cdev->dev, "An error occurred in the DASD "\r\n"device driver, reason=%s\n", errorstring);\r\ncqr->status = DASD_CQR_ERROR;\r\nreturn -EIO;\r\n}\r\ncqr->startclk = get_tod_clock();\r\ncqr->starttime = jiffies;\r\ncqr->retries--;\r\nif (!test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags)) {\r\ncqr->lpm &= device->path_data.opm;\r\nif (!cqr->lpm)\r\ncqr->lpm = device->path_data.opm;\r\n}\r\nif (cqr->cpmode == 1) {\r\nrc = ccw_device_tm_start(device->cdev, cqr->cpaddr,\r\n(long) cqr, cqr->lpm);\r\n} else {\r\nrc = ccw_device_start(device->cdev, cqr->cpaddr,\r\n(long) cqr, cqr->lpm, 0);\r\n}\r\nswitch (rc) {\r\ncase 0:\r\ncqr->status = DASD_CQR_IN_IO;\r\nbreak;\r\ncase -EBUSY:\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"start_IO: device busy, retry later");\r\nbreak;\r\ncase -ETIMEDOUT:\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"start_IO: request timeout, retry later");\r\nbreak;\r\ncase -EACCES:\r\nif (test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device,\r\n"start_IO: selected paths gone (%x)",\r\ncqr->lpm);\r\n} else if (cqr->lpm != device->path_data.opm) {\r\ncqr->lpm = device->path_data.opm;\r\nDBF_DEV_EVENT(DBF_DEBUG, device, "%s",\r\n"start_IO: selected paths gone,"\r\n" retry on all paths");\r\n} else {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"start_IO: all paths in opm gone,"\r\n" do path verification");\r\ndasd_generic_last_path_gone(device);\r\ndevice->path_data.opm = 0;\r\ndevice->path_data.ppm = 0;\r\ndevice->path_data.npm = 0;\r\ndevice->path_data.tbvpm =\r\nccw_device_get_path_mask(device->cdev);\r\n}\r\nbreak;\r\ncase -ENODEV:\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"start_IO: -ENODEV device gone, retry");\r\nbreak;\r\ncase -EIO:\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"start_IO: -EIO device gone, retry");\r\nbreak;\r\ncase -EINVAL:\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"start_IO: -EINVAL device currently "\r\n"not accessible");\r\nbreak;\r\ndefault:\r\nsnprintf(errorstring, ERRORLENGTH, "11 %d", rc);\r\ndev_err(&device->cdev->dev,\r\n"An error occurred in the DASD device driver, "\r\n"reason=%s\n", errorstring);\r\nBUG();\r\nbreak;\r\n}\r\ncqr->intrc = rc;\r\nreturn rc;\r\n}\r\nstatic void dasd_device_timeout(unsigned long ptr)\r\n{\r\nunsigned long flags;\r\nstruct dasd_device *device;\r\ndevice = (struct dasd_device *) ptr;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\ndasd_device_remove_stop_bits(device, DASD_STOPPED_PENDING);\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\ndasd_schedule_device_bh(device);\r\n}\r\nvoid dasd_device_set_timer(struct dasd_device *device, int expires)\r\n{\r\nif (expires == 0)\r\ndel_timer(&device->timer);\r\nelse\r\nmod_timer(&device->timer, jiffies + expires);\r\n}\r\nvoid dasd_device_clear_timer(struct dasd_device *device)\r\n{\r\ndel_timer(&device->timer);\r\n}\r\nstatic void dasd_handle_killed_request(struct ccw_device *cdev,\r\nunsigned long intparm)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nstruct dasd_device *device;\r\nif (!intparm)\r\nreturn;\r\ncqr = (struct dasd_ccw_req *) intparm;\r\nif (cqr->status != DASD_CQR_IN_IO) {\r\nDBF_EVENT_DEVID(DBF_DEBUG, cdev,\r\n"invalid status in handle_killed_request: "\r\n"%02x", cqr->status);\r\nreturn;\r\n}\r\ndevice = dasd_device_from_cdev_locked(cdev);\r\nif (IS_ERR(device)) {\r\nDBF_EVENT_DEVID(DBF_DEBUG, cdev, "%s",\r\n"unable to get device from cdev");\r\nreturn;\r\n}\r\nif (!cqr->startdev ||\r\ndevice != cqr->startdev ||\r\nstrncmp(cqr->startdev->discipline->ebcname,\r\n(char *) &cqr->magic, 4)) {\r\nDBF_EVENT_DEVID(DBF_DEBUG, cdev, "%s",\r\n"invalid device in request");\r\ndasd_put_device(device);\r\nreturn;\r\n}\r\ncqr->status = DASD_CQR_QUEUED;\r\ndasd_device_clear_timer(device);\r\ndasd_schedule_device_bh(device);\r\ndasd_put_device(device);\r\n}\r\nvoid dasd_generic_handle_state_change(struct dasd_device *device)\r\n{\r\ndasd_eer_snss(device);\r\ndasd_device_remove_stop_bits(device, DASD_STOPPED_PENDING);\r\ndasd_schedule_device_bh(device);\r\nif (device->block)\r\ndasd_schedule_block_bh(device->block);\r\n}\r\nvoid dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,\r\nstruct irb *irb)\r\n{\r\nstruct dasd_ccw_req *cqr, *next;\r\nstruct dasd_device *device;\r\nunsigned long long now;\r\nint expires;\r\nif (IS_ERR(irb)) {\r\nswitch (PTR_ERR(irb)) {\r\ncase -EIO:\r\nbreak;\r\ncase -ETIMEDOUT:\r\nDBF_EVENT_DEVID(DBF_WARNING, cdev, "%s: "\r\n"request timed out\n", __func__);\r\nbreak;\r\ndefault:\r\nDBF_EVENT_DEVID(DBF_WARNING, cdev, "%s: "\r\n"unknown error %ld\n", __func__,\r\nPTR_ERR(irb));\r\n}\r\ndasd_handle_killed_request(cdev, intparm);\r\nreturn;\r\n}\r\nnow = get_tod_clock();\r\ncqr = (struct dasd_ccw_req *) intparm;\r\nif (!cqr ||\r\n!(scsw_dstat(&irb->scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &&\r\nscsw_cstat(&irb->scsw) == 0)) {\r\nif (cqr)\r\nmemcpy(&cqr->irb, irb, sizeof(*irb));\r\ndevice = dasd_device_from_cdev_locked(cdev);\r\nif (IS_ERR(device))\r\nreturn;\r\nif (device->discipline == dasd_diag_discipline_pointer) {\r\ndasd_put_device(device);\r\nreturn;\r\n}\r\ndevice->discipline->dump_sense_dbf(device, irb, "int");\r\nif (device->features & DASD_FEATURE_ERPLOG)\r\ndevice->discipline->dump_sense(device, cqr, irb);\r\ndevice->discipline->check_for_device_change(device, cqr, irb);\r\ndasd_put_device(device);\r\n}\r\nif (!cqr)\r\nreturn;\r\ndevice = (struct dasd_device *) cqr->startdev;\r\nif (!device ||\r\nstrncmp(device->discipline->ebcname, (char *) &cqr->magic, 4)) {\r\nDBF_EVENT_DEVID(DBF_DEBUG, cdev, "%s",\r\n"invalid device in request");\r\nreturn;\r\n}\r\nif (cqr->status == DASD_CQR_CLEAR_PENDING &&\r\nscsw_fctl(&irb->scsw) & SCSW_FCTL_CLEAR_FUNC) {\r\ncqr->status = DASD_CQR_CLEARED;\r\ndasd_device_clear_timer(device);\r\nwake_up(&dasd_flush_wq);\r\ndasd_schedule_device_bh(device);\r\nreturn;\r\n}\r\nif (cqr->status != DASD_CQR_IN_IO) {\r\nDBF_DEV_EVENT(DBF_DEBUG, device, "invalid status: bus_id %s, "\r\n"status %02x", dev_name(&cdev->dev), cqr->status);\r\nreturn;\r\n}\r\nnext = NULL;\r\nexpires = 0;\r\nif (scsw_dstat(&irb->scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &&\r\nscsw_cstat(&irb->scsw) == 0) {\r\ncqr->status = DASD_CQR_SUCCESS;\r\ncqr->stopclk = now;\r\nif (cqr->devlist.next != &device->ccw_queue) {\r\nnext = list_entry(cqr->devlist.next,\r\nstruct dasd_ccw_req, devlist);\r\n}\r\n} else {\r\nif (!test_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags) &&\r\ncqr->retries > 0) {\r\nif (cqr->lpm == device->path_data.opm)\r\nDBF_DEV_EVENT(DBF_DEBUG, device,\r\n"default ERP in fastpath "\r\n"(%i retries left)",\r\ncqr->retries);\r\nif (!test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags))\r\ncqr->lpm = device->path_data.opm;\r\ncqr->status = DASD_CQR_QUEUED;\r\nnext = cqr;\r\n} else\r\ncqr->status = DASD_CQR_ERROR;\r\n}\r\nif (next && (next->status == DASD_CQR_QUEUED) &&\r\n(!device->stopped)) {\r\nif (device->discipline->start_IO(next) == 0)\r\nexpires = next->expires;\r\n}\r\nif (expires != 0)\r\ndasd_device_set_timer(device, expires);\r\nelse\r\ndasd_device_clear_timer(device);\r\ndasd_schedule_device_bh(device);\r\n}\r\nenum uc_todo dasd_generic_uc_handler(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nstruct dasd_device *device;\r\ndevice = dasd_device_from_cdev_locked(cdev);\r\nif (IS_ERR(device))\r\ngoto out;\r\nif (test_bit(DASD_FLAG_OFFLINE, &device->flags) ||\r\ndevice->state != device->target ||\r\n!device->discipline->check_for_device_change){\r\ndasd_put_device(device);\r\ngoto out;\r\n}\r\nif (device->discipline->dump_sense_dbf)\r\ndevice->discipline->dump_sense_dbf(device, irb, "uc");\r\ndevice->discipline->check_for_device_change(device, NULL, irb);\r\ndasd_put_device(device);\r\nout:\r\nreturn UC_TODO_RETRY;\r\n}\r\nstatic void __dasd_device_recovery(struct dasd_device *device,\r\nstruct dasd_ccw_req *ref_cqr)\r\n{\r\nstruct list_head *l, *n;\r\nstruct dasd_ccw_req *cqr;\r\nif (!ref_cqr->block)\r\nreturn;\r\nlist_for_each_safe(l, n, &device->ccw_queue) {\r\ncqr = list_entry(l, struct dasd_ccw_req, devlist);\r\nif (cqr->status == DASD_CQR_QUEUED &&\r\nref_cqr->block == cqr->block) {\r\ncqr->status = DASD_CQR_CLEARED;\r\n}\r\n}\r\n}\r\nstatic void __dasd_device_process_ccw_queue(struct dasd_device *device,\r\nstruct list_head *final_queue)\r\n{\r\nstruct list_head *l, *n;\r\nstruct dasd_ccw_req *cqr;\r\nlist_for_each_safe(l, n, &device->ccw_queue) {\r\ncqr = list_entry(l, struct dasd_ccw_req, devlist);\r\nif (cqr->status == DASD_CQR_QUEUED ||\r\ncqr->status == DASD_CQR_IN_IO ||\r\ncqr->status == DASD_CQR_CLEAR_PENDING)\r\ncontinue;\r\nif (cqr->status == DASD_CQR_ERROR) {\r\n__dasd_device_recovery(device, cqr);\r\n}\r\nlist_move_tail(&cqr->devlist, final_queue);\r\n}\r\n}\r\nstatic void __dasd_device_process_final_queue(struct dasd_device *device,\r\nstruct list_head *final_queue)\r\n{\r\nstruct list_head *l, *n;\r\nstruct dasd_ccw_req *cqr;\r\nstruct dasd_block *block;\r\nvoid (*callback)(struct dasd_ccw_req *, void *data);\r\nvoid *callback_data;\r\nchar errorstring[ERRORLENGTH];\r\nlist_for_each_safe(l, n, final_queue) {\r\ncqr = list_entry(l, struct dasd_ccw_req, devlist);\r\nlist_del_init(&cqr->devlist);\r\nblock = cqr->block;\r\ncallback = cqr->callback;\r\ncallback_data = cqr->callback_data;\r\nif (block)\r\nspin_lock_bh(&block->queue_lock);\r\nswitch (cqr->status) {\r\ncase DASD_CQR_SUCCESS:\r\ncqr->status = DASD_CQR_DONE;\r\nbreak;\r\ncase DASD_CQR_ERROR:\r\ncqr->status = DASD_CQR_NEED_ERP;\r\nbreak;\r\ncase DASD_CQR_CLEARED:\r\ncqr->status = DASD_CQR_TERMINATED;\r\nbreak;\r\ndefault:\r\nsnprintf(errorstring, ERRORLENGTH, "12 %p %x02", cqr, cqr->status);\r\ndev_err(&device->cdev->dev,\r\n"An error occurred in the DASD device driver, "\r\n"reason=%s\n", errorstring);\r\nBUG();\r\n}\r\nif (cqr->callback != NULL)\r\n(callback)(cqr, callback_data);\r\nif (block)\r\nspin_unlock_bh(&block->queue_lock);\r\n}\r\n}\r\nstatic void __dasd_device_check_expire(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nif (list_empty(&device->ccw_queue))\r\nreturn;\r\ncqr = list_entry(device->ccw_queue.next, struct dasd_ccw_req, devlist);\r\nif ((cqr->status == DASD_CQR_IN_IO && cqr->expires != 0) &&\r\n(time_after_eq(jiffies, cqr->expires + cqr->starttime))) {\r\nif (test_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\r\ncqr->retries++;\r\n}\r\nif (device->discipline->term_IO(cqr) != 0) {\r\ndev_err(&device->cdev->dev,\r\n"cqr %p timed out (%lus) but cannot be "\r\n"ended, retrying in 5 s\n",\r\ncqr, (cqr->expires/HZ));\r\ncqr->expires += 5*HZ;\r\ndasd_device_set_timer(device, 5*HZ);\r\n} else {\r\ndev_err(&device->cdev->dev,\r\n"cqr %p timed out (%lus), %i retries "\r\n"remaining\n", cqr, (cqr->expires/HZ),\r\ncqr->retries);\r\n}\r\n}\r\n}\r\nstatic void __dasd_device_start_head(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nint rc;\r\nif (list_empty(&device->ccw_queue))\r\nreturn;\r\ncqr = list_entry(device->ccw_queue.next, struct dasd_ccw_req, devlist);\r\nif (cqr->status != DASD_CQR_QUEUED)\r\nreturn;\r\nif (device->stopped &&\r\n!(!(device->stopped & ~(DASD_STOPPED_DC_WAIT | DASD_UNRESUMED_PM))\r\n&& test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags))) {\r\ncqr->intrc = -EAGAIN;\r\ncqr->status = DASD_CQR_CLEARED;\r\ndasd_schedule_device_bh(device);\r\nreturn;\r\n}\r\nrc = device->discipline->start_IO(cqr);\r\nif (rc == 0)\r\ndasd_device_set_timer(device, cqr->expires);\r\nelse if (rc == -EACCES) {\r\ndasd_schedule_device_bh(device);\r\n} else\r\ndasd_device_set_timer(device, 50);\r\n}\r\nstatic void __dasd_device_check_path_events(struct dasd_device *device)\r\n{\r\nint rc;\r\nif (device->path_data.tbvpm) {\r\nif (device->stopped & ~(DASD_STOPPED_DC_WAIT |\r\nDASD_UNRESUMED_PM))\r\nreturn;\r\nrc = device->discipline->verify_path(\r\ndevice, device->path_data.tbvpm);\r\nif (rc)\r\ndasd_device_set_timer(device, 50);\r\nelse\r\ndevice->path_data.tbvpm = 0;\r\n}\r\n}\r\nint dasd_flush_device_queue(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr, *n;\r\nint rc;\r\nstruct list_head flush_queue;\r\nINIT_LIST_HEAD(&flush_queue);\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nrc = 0;\r\nlist_for_each_entry_safe(cqr, n, &device->ccw_queue, devlist) {\r\nswitch (cqr->status) {\r\ncase DASD_CQR_IN_IO:\r\nrc = device->discipline->term_IO(cqr);\r\nif (rc) {\r\ndev_err(&device->cdev->dev,\r\n"Flushing the DASD request queue "\r\n"failed for request %p\n", cqr);\r\ngoto finished;\r\n}\r\nbreak;\r\ncase DASD_CQR_QUEUED:\r\ncqr->stopclk = get_tod_clock();\r\ncqr->status = DASD_CQR_CLEARED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlist_move_tail(&cqr->devlist, &flush_queue);\r\n}\r\nfinished:\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nlist_for_each_entry_safe(cqr, n, &flush_queue, devlist)\r\nwait_event(dasd_flush_wq,\r\n(cqr->status != DASD_CQR_CLEAR_PENDING));\r\n__dasd_device_process_final_queue(device, &flush_queue);\r\nreturn rc;\r\n}\r\nstatic void dasd_device_tasklet(struct dasd_device *device)\r\n{\r\nstruct list_head final_queue;\r\natomic_set (&device->tasklet_scheduled, 0);\r\nINIT_LIST_HEAD(&final_queue);\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\n__dasd_device_check_expire(device);\r\n__dasd_device_process_ccw_queue(device, &final_queue);\r\n__dasd_device_check_path_events(device);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\n__dasd_device_process_final_queue(device, &final_queue);\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\n__dasd_device_start_head(device);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nif (waitqueue_active(&shutdown_waitq))\r\nwake_up(&shutdown_waitq);\r\ndasd_put_device(device);\r\n}\r\nvoid dasd_schedule_device_bh(struct dasd_device *device)\r\n{\r\nif (atomic_cmpxchg (&device->tasklet_scheduled, 0, 1) != 0)\r\nreturn;\r\ndasd_get_device(device);\r\ntasklet_hi_schedule(&device->tasklet);\r\n}\r\nvoid dasd_device_set_stop_bits(struct dasd_device *device, int bits)\r\n{\r\ndevice->stopped |= bits;\r\n}\r\nvoid dasd_device_remove_stop_bits(struct dasd_device *device, int bits)\r\n{\r\ndevice->stopped &= ~bits;\r\nif (!device->stopped)\r\nwake_up(&generic_waitq);\r\n}\r\nvoid dasd_add_request_head(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device;\r\nunsigned long flags;\r\ndevice = cqr->startdev;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\ncqr->status = DASD_CQR_QUEUED;\r\nlist_add(&cqr->devlist, &device->ccw_queue);\r\ndasd_schedule_device_bh(device);\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\n}\r\nvoid dasd_add_request_tail(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device;\r\nunsigned long flags;\r\ndevice = cqr->startdev;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\ncqr->status = DASD_CQR_QUEUED;\r\nlist_add_tail(&cqr->devlist, &device->ccw_queue);\r\ndasd_schedule_device_bh(device);\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\n}\r\nvoid dasd_wakeup_cb(struct dasd_ccw_req *cqr, void *data)\r\n{\r\nspin_lock_irq(get_ccwdev_lock(cqr->startdev->cdev));\r\ncqr->callback_data = DASD_SLEEPON_END_TAG;\r\nspin_unlock_irq(get_ccwdev_lock(cqr->startdev->cdev));\r\nwake_up(&generic_waitq);\r\n}\r\nstatic inline int _wait_for_wakeup(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device;\r\nint rc;\r\ndevice = cqr->startdev;\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nrc = (cqr->callback_data == DASD_SLEEPON_END_TAG);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nreturn rc;\r\n}\r\nstatic int __dasd_sleep_on_erp(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device;\r\ndasd_erp_fn_t erp_fn;\r\nif (cqr->status == DASD_CQR_FILLED)\r\nreturn 0;\r\ndevice = cqr->startdev;\r\nif (test_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags)) {\r\nif (cqr->status == DASD_CQR_TERMINATED) {\r\ndevice->discipline->handle_terminated_request(cqr);\r\nreturn 1;\r\n}\r\nif (cqr->status == DASD_CQR_NEED_ERP) {\r\nerp_fn = device->discipline->erp_action(cqr);\r\nerp_fn(cqr);\r\nreturn 1;\r\n}\r\nif (cqr->status == DASD_CQR_FAILED)\r\ndasd_log_sense(cqr, &cqr->irb);\r\nif (cqr->refers) {\r\n__dasd_process_erp(device, cqr);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __dasd_sleep_on_loop_condition(struct dasd_ccw_req *cqr)\r\n{\r\nif (test_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags)) {\r\nif (cqr->refers)\r\nreturn 1;\r\nreturn ((cqr->status != DASD_CQR_DONE) &&\r\n(cqr->status != DASD_CQR_FAILED));\r\n} else\r\nreturn (cqr->status == DASD_CQR_FILLED);\r\n}\r\nstatic int _dasd_sleep_on(struct dasd_ccw_req *maincqr, int interruptible)\r\n{\r\nstruct dasd_device *device;\r\nint rc;\r\nstruct list_head ccw_queue;\r\nstruct dasd_ccw_req *cqr;\r\nINIT_LIST_HEAD(&ccw_queue);\r\nmaincqr->status = DASD_CQR_FILLED;\r\ndevice = maincqr->startdev;\r\nlist_add(&maincqr->blocklist, &ccw_queue);\r\nfor (cqr = maincqr; __dasd_sleep_on_loop_condition(cqr);\r\ncqr = list_first_entry(&ccw_queue,\r\nstruct dasd_ccw_req, blocklist)) {\r\nif (__dasd_sleep_on_erp(cqr))\r\ncontinue;\r\nif (cqr->status != DASD_CQR_FILLED)\r\ncontinue;\r\nif (test_bit(DASD_FLAG_LOCK_STOLEN, &device->flags) &&\r\n!test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)) {\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->intrc = -EPERM;\r\ncontinue;\r\n}\r\nif (device->stopped & ~DASD_STOPPED_PENDING &&\r\ntest_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&\r\n(!dasd_eer_enabled(device))) {\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->intrc = -ENOLINK;\r\ncontinue;\r\n}\r\nif (interruptible) {\r\nrc = wait_event_interruptible(\r\ngeneric_waitq, !(device->stopped));\r\nif (rc == -ERESTARTSYS) {\r\ncqr->status = DASD_CQR_FAILED;\r\nmaincqr->intrc = rc;\r\ncontinue;\r\n}\r\n} else\r\nwait_event(generic_waitq, !(device->stopped));\r\nif (!cqr->callback)\r\ncqr->callback = dasd_wakeup_cb;\r\ncqr->callback_data = DASD_SLEEPON_START_TAG;\r\ndasd_add_request_tail(cqr);\r\nif (interruptible) {\r\nrc = wait_event_interruptible(\r\ngeneric_waitq, _wait_for_wakeup(cqr));\r\nif (rc == -ERESTARTSYS) {\r\ndasd_cancel_req(cqr);\r\nwait_event(generic_waitq,\r\n_wait_for_wakeup(cqr));\r\ncqr->status = DASD_CQR_FAILED;\r\nmaincqr->intrc = rc;\r\ncontinue;\r\n}\r\n} else\r\nwait_event(generic_waitq, _wait_for_wakeup(cqr));\r\n}\r\nmaincqr->endclk = get_tod_clock();\r\nif ((maincqr->status != DASD_CQR_DONE) &&\r\n(maincqr->intrc != -ERESTARTSYS))\r\ndasd_log_sense(maincqr, &maincqr->irb);\r\nif (maincqr->status == DASD_CQR_DONE)\r\nrc = 0;\r\nelse if (maincqr->intrc)\r\nrc = maincqr->intrc;\r\nelse\r\nrc = -EIO;\r\nreturn rc;\r\n}\r\nstatic inline int _wait_for_wakeup_queue(struct list_head *ccw_queue)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nlist_for_each_entry(cqr, ccw_queue, blocklist) {\r\nif (cqr->callback_data != DASD_SLEEPON_END_TAG)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int _dasd_sleep_on_queue(struct list_head *ccw_queue, int interruptible)\r\n{\r\nstruct dasd_device *device;\r\nint rc;\r\nstruct dasd_ccw_req *cqr, *n;\r\nretry:\r\nlist_for_each_entry_safe(cqr, n, ccw_queue, blocklist) {\r\ndevice = cqr->startdev;\r\nif (cqr->status != DASD_CQR_FILLED)\r\ncontinue;\r\nif (test_bit(DASD_FLAG_LOCK_STOLEN, &device->flags) &&\r\n!test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)) {\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->intrc = -EPERM;\r\ncontinue;\r\n}\r\nif (device->stopped & ~DASD_STOPPED_PENDING &&\r\ntest_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&\r\n!dasd_eer_enabled(device)) {\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->intrc = -EAGAIN;\r\ncontinue;\r\n}\r\nif (interruptible) {\r\nrc = wait_event_interruptible(\r\ngeneric_waitq, !device->stopped);\r\nif (rc == -ERESTARTSYS) {\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->intrc = rc;\r\ncontinue;\r\n}\r\n} else\r\nwait_event(generic_waitq, !(device->stopped));\r\nif (!cqr->callback)\r\ncqr->callback = dasd_wakeup_cb;\r\ncqr->callback_data = DASD_SLEEPON_START_TAG;\r\ndasd_add_request_tail(cqr);\r\n}\r\nwait_event(generic_waitq, _wait_for_wakeup_queue(ccw_queue));\r\nrc = 0;\r\nlist_for_each_entry_safe(cqr, n, ccw_queue, blocklist) {\r\nif (__dasd_sleep_on_erp(cqr))\r\nrc = 1;\r\n}\r\nif (rc)\r\ngoto retry;\r\nreturn 0;\r\n}\r\nint dasd_sleep_on(struct dasd_ccw_req *cqr)\r\n{\r\nreturn _dasd_sleep_on(cqr, 0);\r\n}\r\nint dasd_sleep_on_queue(struct list_head *ccw_queue)\r\n{\r\nreturn _dasd_sleep_on_queue(ccw_queue, 0);\r\n}\r\nint dasd_sleep_on_interruptible(struct dasd_ccw_req *cqr)\r\n{\r\nreturn _dasd_sleep_on(cqr, 1);\r\n}\r\nstatic inline int _dasd_term_running_cqr(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nint rc;\r\nif (list_empty(&device->ccw_queue))\r\nreturn 0;\r\ncqr = list_entry(device->ccw_queue.next, struct dasd_ccw_req, devlist);\r\nrc = device->discipline->term_IO(cqr);\r\nif (!rc)\r\ncqr->retries++;\r\nreturn rc;\r\n}\r\nint dasd_sleep_on_immediatly(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device;\r\nint rc;\r\ndevice = cqr->startdev;\r\nif (test_bit(DASD_FLAG_LOCK_STOLEN, &device->flags) &&\r\n!test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)) {\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->intrc = -EPERM;\r\nreturn -EIO;\r\n}\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nrc = _dasd_term_running_cqr(device);\r\nif (rc) {\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nreturn rc;\r\n}\r\ncqr->callback = dasd_wakeup_cb;\r\ncqr->callback_data = DASD_SLEEPON_START_TAG;\r\ncqr->status = DASD_CQR_QUEUED;\r\nlist_add(&cqr->devlist, device->ccw_queue.next);\r\ndasd_schedule_device_bh(device);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nwait_event(generic_waitq, _wait_for_wakeup(cqr));\r\nif (cqr->status == DASD_CQR_DONE)\r\nrc = 0;\r\nelse if (cqr->intrc)\r\nrc = cqr->intrc;\r\nelse\r\nrc = -EIO;\r\ndasd_schedule_device_bh(device);\r\nif (device->block)\r\ndasd_schedule_block_bh(device->block);\r\nreturn rc;\r\n}\r\nint dasd_cancel_req(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device = cqr->startdev;\r\nunsigned long flags;\r\nint rc;\r\nrc = 0;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\nswitch (cqr->status) {\r\ncase DASD_CQR_QUEUED:\r\ncqr->status = DASD_CQR_CLEARED;\r\nbreak;\r\ncase DASD_CQR_IN_IO:\r\nrc = device->discipline->term_IO(cqr);\r\nif (rc) {\r\ndev_err(&device->cdev->dev,\r\n"Cancelling request %p failed with rc=%d\n",\r\ncqr, rc);\r\n} else {\r\ncqr->stopclk = get_tod_clock();\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\ndasd_schedule_device_bh(device);\r\nreturn rc;\r\n}\r\nstatic void dasd_block_timeout(unsigned long ptr)\r\n{\r\nunsigned long flags;\r\nstruct dasd_block *block;\r\nblock = (struct dasd_block *) ptr;\r\nspin_lock_irqsave(get_ccwdev_lock(block->base->cdev), flags);\r\ndasd_device_remove_stop_bits(block->base, DASD_STOPPED_PENDING);\r\nspin_unlock_irqrestore(get_ccwdev_lock(block->base->cdev), flags);\r\ndasd_schedule_block_bh(block);\r\n}\r\nvoid dasd_block_set_timer(struct dasd_block *block, int expires)\r\n{\r\nif (expires == 0)\r\ndel_timer(&block->timer);\r\nelse\r\nmod_timer(&block->timer, jiffies + expires);\r\n}\r\nvoid dasd_block_clear_timer(struct dasd_block *block)\r\n{\r\ndel_timer(&block->timer);\r\n}\r\nstatic void __dasd_process_erp(struct dasd_device *device,\r\nstruct dasd_ccw_req *cqr)\r\n{\r\ndasd_erp_fn_t erp_fn;\r\nif (cqr->status == DASD_CQR_DONE)\r\nDBF_DEV_EVENT(DBF_NOTICE, device, "%s", "ERP successful");\r\nelse\r\ndev_err(&device->cdev->dev, "ERP failed for the DASD\n");\r\nerp_fn = device->discipline->erp_postaction(cqr);\r\nerp_fn(cqr);\r\n}\r\nstatic void __dasd_process_request_queue(struct dasd_block *block)\r\n{\r\nstruct request_queue *queue;\r\nstruct request *req;\r\nstruct dasd_ccw_req *cqr;\r\nstruct dasd_device *basedev;\r\nunsigned long flags;\r\nqueue = block->request_queue;\r\nbasedev = block->base;\r\nif (queue == NULL)\r\nreturn;\r\nif (basedev->state < DASD_STATE_READY) {\r\nwhile ((req = blk_fetch_request(block->request_queue)))\r\n__blk_end_request_all(req, -EIO);\r\nreturn;\r\n}\r\nwhile ((req = blk_peek_request(queue))) {\r\nif (basedev->features & DASD_FEATURE_READONLY &&\r\nrq_data_dir(req) == WRITE) {\r\nDBF_DEV_EVENT(DBF_ERR, basedev,\r\n"Rejecting write request %p",\r\nreq);\r\nblk_start_request(req);\r\n__blk_end_request_all(req, -EIO);\r\ncontinue;\r\n}\r\nif (test_bit(DASD_FLAG_ABORTALL, &basedev->flags) &&\r\n(basedev->features & DASD_FEATURE_FAILFAST ||\r\nblk_noretry_request(req))) {\r\nDBF_DEV_EVENT(DBF_ERR, basedev,\r\n"Rejecting failfast request %p",\r\nreq);\r\nblk_start_request(req);\r\n__blk_end_request_all(req, -ETIMEDOUT);\r\ncontinue;\r\n}\r\ncqr = basedev->discipline->build_cp(basedev, block, req);\r\nif (IS_ERR(cqr)) {\r\nif (PTR_ERR(cqr) == -EBUSY)\r\nbreak;\r\nif (PTR_ERR(cqr) == -ENOMEM)\r\nbreak;\r\nif (PTR_ERR(cqr) == -EAGAIN) {\r\nif (!list_empty(&block->ccw_queue))\r\nbreak;\r\nspin_lock_irqsave(\r\nget_ccwdev_lock(basedev->cdev), flags);\r\ndasd_device_set_stop_bits(basedev,\r\nDASD_STOPPED_PENDING);\r\nspin_unlock_irqrestore(\r\nget_ccwdev_lock(basedev->cdev), flags);\r\ndasd_block_set_timer(block, HZ/2);\r\nbreak;\r\n}\r\nDBF_DEV_EVENT(DBF_ERR, basedev,\r\n"CCW creation failed (rc=%ld) "\r\n"on request %p",\r\nPTR_ERR(cqr), req);\r\nblk_start_request(req);\r\n__blk_end_request_all(req, -EIO);\r\ncontinue;\r\n}\r\ncqr->callback_data = (void *) req;\r\ncqr->status = DASD_CQR_FILLED;\r\nreq->completion_data = cqr;\r\nblk_start_request(req);\r\nlist_add_tail(&cqr->blocklist, &block->ccw_queue);\r\nINIT_LIST_HEAD(&cqr->devlist);\r\ndasd_profile_start(block, cqr, req);\r\n}\r\n}\r\nstatic void __dasd_cleanup_cqr(struct dasd_ccw_req *cqr)\r\n{\r\nstruct request *req;\r\nint status;\r\nint error = 0;\r\nreq = (struct request *) cqr->callback_data;\r\ndasd_profile_end(cqr->block, cqr, req);\r\nstatus = cqr->block->base->discipline->free_cp(cqr, req);\r\nif (status < 0)\r\nerror = status;\r\nelse if (status == 0) {\r\nif (cqr->intrc == -EPERM)\r\nerror = -EBADE;\r\nelse if (cqr->intrc == -ENOLINK ||\r\ncqr->intrc == -ETIMEDOUT)\r\nerror = cqr->intrc;\r\nelse\r\nerror = -EIO;\r\n}\r\n__blk_end_request_all(req, error);\r\n}\r\nstatic void __dasd_process_block_ccw_queue(struct dasd_block *block,\r\nstruct list_head *final_queue)\r\n{\r\nstruct list_head *l, *n;\r\nstruct dasd_ccw_req *cqr;\r\ndasd_erp_fn_t erp_fn;\r\nunsigned long flags;\r\nstruct dasd_device *base = block->base;\r\nrestart:\r\nlist_for_each_safe(l, n, &block->ccw_queue) {\r\ncqr = list_entry(l, struct dasd_ccw_req, blocklist);\r\nif (cqr->status != DASD_CQR_DONE &&\r\ncqr->status != DASD_CQR_FAILED &&\r\ncqr->status != DASD_CQR_NEED_ERP &&\r\ncqr->status != DASD_CQR_TERMINATED)\r\ncontinue;\r\nif (cqr->status == DASD_CQR_TERMINATED) {\r\nbase->discipline->handle_terminated_request(cqr);\r\ngoto restart;\r\n}\r\nif (cqr->status == DASD_CQR_NEED_ERP) {\r\nerp_fn = base->discipline->erp_action(cqr);\r\nif (IS_ERR(erp_fn(cqr)))\r\ncontinue;\r\ngoto restart;\r\n}\r\nif (cqr->status == DASD_CQR_FAILED) {\r\ndasd_log_sense(cqr, &cqr->irb);\r\n}\r\nif (dasd_eer_enabled(base) &&\r\ncqr->status == DASD_CQR_FAILED) {\r\ndasd_eer_write(base, cqr, DASD_EER_FATALERROR);\r\ncqr->status = DASD_CQR_FILLED;\r\ncqr->retries = 255;\r\nspin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);\r\ndasd_device_set_stop_bits(base, DASD_STOPPED_QUIESCE);\r\nspin_unlock_irqrestore(get_ccwdev_lock(base->cdev),\r\nflags);\r\ngoto restart;\r\n}\r\nif (cqr->refers) {\r\n__dasd_process_erp(base, cqr);\r\ngoto restart;\r\n}\r\ncqr->endclk = get_tod_clock();\r\nlist_move_tail(&cqr->blocklist, final_queue);\r\n}\r\n}\r\nstatic void dasd_return_cqr_cb(struct dasd_ccw_req *cqr, void *data)\r\n{\r\ndasd_schedule_block_bh(cqr->block);\r\n}\r\nstatic void __dasd_block_start_head(struct dasd_block *block)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nif (list_empty(&block->ccw_queue))\r\nreturn;\r\nlist_for_each_entry(cqr, &block->ccw_queue, blocklist) {\r\nif (cqr->status != DASD_CQR_FILLED)\r\ncontinue;\r\nif (test_bit(DASD_FLAG_LOCK_STOLEN, &block->base->flags) &&\r\n!test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)) {\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->intrc = -EPERM;\r\ndasd_schedule_block_bh(block);\r\ncontinue;\r\n}\r\nif (block->base->stopped & ~DASD_STOPPED_PENDING &&\r\ntest_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&\r\n(!dasd_eer_enabled(block->base))) {\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->intrc = -ENOLINK;\r\ndasd_schedule_block_bh(block);\r\ncontinue;\r\n}\r\nif (block->base->stopped)\r\nreturn;\r\nif (!cqr->startdev)\r\ncqr->startdev = block->base;\r\ncqr->callback = dasd_return_cqr_cb;\r\ndasd_add_request_tail(cqr);\r\n}\r\n}\r\nstatic void dasd_block_tasklet(struct dasd_block *block)\r\n{\r\nstruct list_head final_queue;\r\nstruct list_head *l, *n;\r\nstruct dasd_ccw_req *cqr;\r\natomic_set(&block->tasklet_scheduled, 0);\r\nINIT_LIST_HEAD(&final_queue);\r\nspin_lock(&block->queue_lock);\r\n__dasd_process_block_ccw_queue(block, &final_queue);\r\nspin_unlock(&block->queue_lock);\r\nspin_lock_irq(&block->request_queue_lock);\r\nlist_for_each_safe(l, n, &final_queue) {\r\ncqr = list_entry(l, struct dasd_ccw_req, blocklist);\r\nlist_del_init(&cqr->blocklist);\r\n__dasd_cleanup_cqr(cqr);\r\n}\r\nspin_lock(&block->queue_lock);\r\n__dasd_process_request_queue(block);\r\n__dasd_block_start_head(block);\r\nspin_unlock(&block->queue_lock);\r\nspin_unlock_irq(&block->request_queue_lock);\r\nif (waitqueue_active(&shutdown_waitq))\r\nwake_up(&shutdown_waitq);\r\ndasd_put_device(block->base);\r\n}\r\nstatic void _dasd_wake_block_flush_cb(struct dasd_ccw_req *cqr, void *data)\r\n{\r\nwake_up(&dasd_flush_wq);\r\n}\r\nstatic int _dasd_requeue_request(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_block *block = cqr->block;\r\nstruct request *req;\r\nunsigned long flags;\r\nif (!block)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&block->queue_lock, flags);\r\nreq = (struct request *) cqr->callback_data;\r\nblk_requeue_request(block->request_queue, req);\r\nspin_unlock_irqrestore(&block->queue_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dasd_flush_block_queue(struct dasd_block *block)\r\n{\r\nstruct dasd_ccw_req *cqr, *n;\r\nint rc, i;\r\nstruct list_head flush_queue;\r\nINIT_LIST_HEAD(&flush_queue);\r\nspin_lock_bh(&block->queue_lock);\r\nrc = 0;\r\nrestart:\r\nlist_for_each_entry_safe(cqr, n, &block->ccw_queue, blocklist) {\r\nif (cqr->status >= DASD_CQR_QUEUED)\r\nrc = dasd_cancel_req(cqr);\r\nif (rc < 0)\r\nbreak;\r\ncqr->callback = _dasd_wake_block_flush_cb;\r\nfor (i = 0; cqr != NULL; cqr = cqr->refers, i++)\r\nlist_move_tail(&cqr->blocklist, &flush_queue);\r\nif (i > 1)\r\ngoto restart;\r\n}\r\nspin_unlock_bh(&block->queue_lock);\r\nrestart_cb:\r\nlist_for_each_entry_safe(cqr, n, &flush_queue, blocklist) {\r\nwait_event(dasd_flush_wq, (cqr->status < DASD_CQR_QUEUED));\r\nif (cqr->refers) {\r\nspin_lock_bh(&block->queue_lock);\r\n__dasd_process_erp(block->base, cqr);\r\nspin_unlock_bh(&block->queue_lock);\r\ngoto restart_cb;\r\n}\r\nspin_lock_irq(&block->request_queue_lock);\r\ncqr->endclk = get_tod_clock();\r\nlist_del_init(&cqr->blocklist);\r\n__dasd_cleanup_cqr(cqr);\r\nspin_unlock_irq(&block->request_queue_lock);\r\n}\r\nreturn rc;\r\n}\r\nvoid dasd_schedule_block_bh(struct dasd_block *block)\r\n{\r\nif (atomic_cmpxchg(&block->tasklet_scheduled, 0, 1) != 0)\r\nreturn;\r\ndasd_get_device(block->base);\r\ntasklet_hi_schedule(&block->tasklet);\r\n}\r\nstatic void do_dasd_request(struct request_queue *queue)\r\n{\r\nstruct dasd_block *block;\r\nblock = queue->queuedata;\r\nspin_lock(&block->queue_lock);\r\n__dasd_process_request_queue(block);\r\n__dasd_block_start_head(block);\r\nspin_unlock(&block->queue_lock);\r\n}\r\nenum blk_eh_timer_return dasd_times_out(struct request *req)\r\n{\r\nstruct dasd_ccw_req *cqr = req->completion_data;\r\nstruct dasd_block *block = req->q->queuedata;\r\nstruct dasd_device *device;\r\nint rc = 0;\r\nif (!cqr)\r\nreturn BLK_EH_NOT_HANDLED;\r\ndevice = cqr->startdev ? cqr->startdev : block->base;\r\nif (!device->blk_timeout)\r\nreturn BLK_EH_RESET_TIMER;\r\nDBF_DEV_EVENT(DBF_WARNING, device,\r\n" dasd_times_out cqr %p status %x",\r\ncqr, cqr->status);\r\nspin_lock(&block->queue_lock);\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\ncqr->retries = -1;\r\ncqr->intrc = -ETIMEDOUT;\r\nif (cqr->status >= DASD_CQR_QUEUED) {\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\nrc = dasd_cancel_req(cqr);\r\n} else if (cqr->status == DASD_CQR_FILLED ||\r\ncqr->status == DASD_CQR_NEED_ERP) {\r\ncqr->status = DASD_CQR_TERMINATED;\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\n} else if (cqr->status == DASD_CQR_IN_ERP) {\r\nstruct dasd_ccw_req *searchcqr, *nextcqr, *tmpcqr;\r\nlist_for_each_entry_safe(searchcqr, nextcqr,\r\n&block->ccw_queue, blocklist) {\r\ntmpcqr = searchcqr;\r\nwhile (tmpcqr->refers)\r\ntmpcqr = tmpcqr->refers;\r\nif (tmpcqr != cqr)\r\ncontinue;\r\nsearchcqr->retries = -1;\r\nsearchcqr->intrc = -ETIMEDOUT;\r\nif (searchcqr->status >= DASD_CQR_QUEUED) {\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\nrc = dasd_cancel_req(searchcqr);\r\nspin_lock(get_ccwdev_lock(device->cdev));\r\n} else if ((searchcqr->status == DASD_CQR_FILLED) ||\r\n(searchcqr->status == DASD_CQR_NEED_ERP)) {\r\nsearchcqr->status = DASD_CQR_TERMINATED;\r\nrc = 0;\r\n} else if (searchcqr->status == DASD_CQR_IN_ERP) {\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nspin_unlock(get_ccwdev_lock(device->cdev));\r\n}\r\ndasd_schedule_block_bh(block);\r\nspin_unlock(&block->queue_lock);\r\nreturn rc ? BLK_EH_RESET_TIMER : BLK_EH_NOT_HANDLED;\r\n}\r\nstatic int dasd_alloc_queue(struct dasd_block *block)\r\n{\r\nint rc;\r\nblock->request_queue = blk_init_queue(do_dasd_request,\r\n&block->request_queue_lock);\r\nif (block->request_queue == NULL)\r\nreturn -ENOMEM;\r\nblock->request_queue->queuedata = block;\r\nelevator_exit(block->request_queue->elevator);\r\nblock->request_queue->elevator = NULL;\r\nmutex_lock(&block->request_queue->sysfs_lock);\r\nrc = elevator_init(block->request_queue, "deadline");\r\nif (rc)\r\nblk_cleanup_queue(block->request_queue);\r\nmutex_unlock(&block->request_queue->sysfs_lock);\r\nreturn rc;\r\n}\r\nstatic void dasd_setup_queue(struct dasd_block *block)\r\n{\r\nint max;\r\nif (block->base->features & DASD_FEATURE_USERAW) {\r\nmax = 2048;\r\n} else {\r\nmax = block->base->discipline->max_blocks << block->s2b_shift;\r\n}\r\nblk_queue_logical_block_size(block->request_queue,\r\nblock->bp_block);\r\nblk_queue_max_hw_sectors(block->request_queue, max);\r\nblk_queue_max_segments(block->request_queue, -1L);\r\nblk_queue_max_segment_size(block->request_queue, PAGE_SIZE);\r\nblk_queue_segment_boundary(block->request_queue, PAGE_SIZE - 1);\r\n}\r\nstatic void dasd_free_queue(struct dasd_block *block)\r\n{\r\nif (block->request_queue) {\r\nblk_cleanup_queue(block->request_queue);\r\nblock->request_queue = NULL;\r\n}\r\n}\r\nstatic void dasd_flush_request_queue(struct dasd_block *block)\r\n{\r\nstruct request *req;\r\nif (!block->request_queue)\r\nreturn;\r\nspin_lock_irq(&block->request_queue_lock);\r\nwhile ((req = blk_fetch_request(block->request_queue)))\r\n__blk_end_request_all(req, -EIO);\r\nspin_unlock_irq(&block->request_queue_lock);\r\n}\r\nstatic int dasd_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct dasd_device *base;\r\nint rc;\r\nbase = dasd_device_from_gendisk(bdev->bd_disk);\r\nif (!base)\r\nreturn -ENODEV;\r\natomic_inc(&base->block->open_count);\r\nif (test_bit(DASD_FLAG_OFFLINE, &base->flags)) {\r\nrc = -ENODEV;\r\ngoto unlock;\r\n}\r\nif (!try_module_get(base->discipline->owner)) {\r\nrc = -EINVAL;\r\ngoto unlock;\r\n}\r\nif (dasd_probeonly) {\r\ndev_info(&base->cdev->dev,\r\n"Accessing the DASD failed because it is in "\r\n"probeonly mode\n");\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nif (base->state <= DASD_STATE_BASIC) {\r\nDBF_DEV_EVENT(DBF_ERR, base, " %s",\r\n" Cannot open unrecognized device");\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nif ((mode & FMODE_WRITE) &&\r\n(test_bit(DASD_FLAG_DEVICE_RO, &base->flags) ||\r\n(base->features & DASD_FEATURE_READONLY))) {\r\nrc = -EROFS;\r\ngoto out;\r\n}\r\ndasd_put_device(base);\r\nreturn 0;\r\nout:\r\nmodule_put(base->discipline->owner);\r\nunlock:\r\natomic_dec(&base->block->open_count);\r\ndasd_put_device(base);\r\nreturn rc;\r\n}\r\nstatic void dasd_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct dasd_device *base = dasd_device_from_gendisk(disk);\r\nif (base) {\r\natomic_dec(&base->block->open_count);\r\nmodule_put(base->discipline->owner);\r\ndasd_put_device(base);\r\n}\r\n}\r\nstatic int dasd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct dasd_device *base;\r\nbase = dasd_device_from_gendisk(bdev->bd_disk);\r\nif (!base)\r\nreturn -ENODEV;\r\nif (!base->discipline ||\r\n!base->discipline->fill_geometry) {\r\ndasd_put_device(base);\r\nreturn -EINVAL;\r\n}\r\nbase->discipline->fill_geometry(base->block, geo);\r\ngeo->start = get_start_sect(bdev) >> base->block->s2b_shift;\r\ndasd_put_device(base);\r\nreturn 0;\r\n}\r\nstatic void\r\ndasd_exit(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\ndasd_proc_exit();\r\n#endif\r\ndasd_eer_exit();\r\nif (dasd_page_cache != NULL) {\r\nkmem_cache_destroy(dasd_page_cache);\r\ndasd_page_cache = NULL;\r\n}\r\ndasd_gendisk_exit();\r\ndasd_devmap_exit();\r\nif (dasd_debug_area != NULL) {\r\ndebug_unregister(dasd_debug_area);\r\ndasd_debug_area = NULL;\r\n}\r\ndasd_statistics_removeroot();\r\n}\r\nint dasd_device_is_ro(struct dasd_device *device)\r\n{\r\nstruct ccw_dev_id dev_id;\r\nstruct diag210 diag_data;\r\nint rc;\r\nif (!MACHINE_IS_VM)\r\nreturn 0;\r\nccw_device_get_id(device->cdev, &dev_id);\r\nmemset(&diag_data, 0, sizeof(diag_data));\r\ndiag_data.vrdcdvno = dev_id.devno;\r\ndiag_data.vrdclen = sizeof(diag_data);\r\nrc = diag210(&diag_data);\r\nif (rc == 0 || rc == 2) {\r\nreturn diag_data.vrdcvfla & 0x80;\r\n} else {\r\nDBF_EVENT(DBF_WARNING, "diag210 failed for dev=%04x with rc=%d",\r\ndev_id.devno, rc);\r\nreturn 0;\r\n}\r\n}\r\nstatic void dasd_generic_auto_online(void *data, async_cookie_t cookie)\r\n{\r\nstruct ccw_device *cdev = data;\r\nint ret;\r\nret = ccw_device_set_online(cdev);\r\nif (ret)\r\npr_warning("%s: Setting the DASD online failed with rc=%d\n",\r\ndev_name(&cdev->dev), ret);\r\n}\r\nint dasd_generic_probe(struct ccw_device *cdev,\r\nstruct dasd_discipline *discipline)\r\n{\r\nint ret;\r\nret = dasd_add_sysfs_files(cdev);\r\nif (ret) {\r\nDBF_EVENT_DEVID(DBF_WARNING, cdev, "%s",\r\n"dasd_generic_probe: could not add "\r\n"sysfs entries");\r\nreturn ret;\r\n}\r\ncdev->handler = &dasd_int_handler;\r\nif ((dasd_get_feature(cdev, DASD_FEATURE_INITIAL_ONLINE) > 0 ) ||\r\n(dasd_autodetect && dasd_busid_known(dev_name(&cdev->dev)) != 0))\r\nasync_schedule(dasd_generic_auto_online, cdev);\r\nreturn 0;\r\n}\r\nvoid dasd_generic_remove(struct ccw_device *cdev)\r\n{\r\nstruct dasd_device *device;\r\nstruct dasd_block *block;\r\ncdev->handler = NULL;\r\ndevice = dasd_device_from_cdev(cdev);\r\nif (IS_ERR(device)) {\r\ndasd_remove_sysfs_files(cdev);\r\nreturn;\r\n}\r\nif (test_and_set_bit(DASD_FLAG_OFFLINE, &device->flags) &&\r\n!test_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\r\ndasd_put_device(device);\r\ndasd_remove_sysfs_files(cdev);\r\nreturn;\r\n}\r\ndasd_set_target_state(device, DASD_STATE_NEW);\r\nblock = device->block;\r\ndasd_delete_device(device);\r\nif (block)\r\ndasd_free_block(block);\r\ndasd_remove_sysfs_files(cdev);\r\n}\r\nint dasd_generic_set_online(struct ccw_device *cdev,\r\nstruct dasd_discipline *base_discipline)\r\n{\r\nstruct dasd_discipline *discipline;\r\nstruct dasd_device *device;\r\nint rc;\r\ndasd_set_feature(cdev, DASD_FEATURE_INITIAL_ONLINE, 0);\r\ndevice = dasd_create_device(cdev);\r\nif (IS_ERR(device))\r\nreturn PTR_ERR(device);\r\ndiscipline = base_discipline;\r\nif (device->features & DASD_FEATURE_USEDIAG) {\r\nif (!dasd_diag_discipline_pointer) {\r\npr_warning("%s Setting the DASD online failed because "\r\n"of missing DIAG discipline\n",\r\ndev_name(&cdev->dev));\r\ndasd_delete_device(device);\r\nreturn -ENODEV;\r\n}\r\ndiscipline = dasd_diag_discipline_pointer;\r\n}\r\nif (!try_module_get(base_discipline->owner)) {\r\ndasd_delete_device(device);\r\nreturn -EINVAL;\r\n}\r\nif (!try_module_get(discipline->owner)) {\r\nmodule_put(base_discipline->owner);\r\ndasd_delete_device(device);\r\nreturn -EINVAL;\r\n}\r\ndevice->base_discipline = base_discipline;\r\ndevice->discipline = discipline;\r\nrc = discipline->check_device(device);\r\nif (rc) {\r\npr_warning("%s Setting the DASD online with discipline %s "\r\n"failed with rc=%i\n",\r\ndev_name(&cdev->dev), discipline->name, rc);\r\nmodule_put(discipline->owner);\r\nmodule_put(base_discipline->owner);\r\ndasd_delete_device(device);\r\nreturn rc;\r\n}\r\ndasd_set_target_state(device, DASD_STATE_ONLINE);\r\nif (device->state <= DASD_STATE_KNOWN) {\r\npr_warning("%s Setting the DASD online failed because of a "\r\n"missing discipline\n", dev_name(&cdev->dev));\r\nrc = -ENODEV;\r\ndasd_set_target_state(device, DASD_STATE_NEW);\r\nif (device->block)\r\ndasd_free_block(device->block);\r\ndasd_delete_device(device);\r\n} else\r\npr_debug("dasd_generic device %s found\n",\r\ndev_name(&cdev->dev));\r\nwait_event(dasd_init_waitq, _wait_for_device(device));\r\ndasd_put_device(device);\r\nreturn rc;\r\n}\r\nint dasd_generic_set_offline(struct ccw_device *cdev)\r\n{\r\nstruct dasd_device *device;\r\nstruct dasd_block *block;\r\nint max_count, open_count, rc;\r\nrc = 0;\r\ndevice = dasd_device_from_cdev(cdev);\r\nif (IS_ERR(device))\r\nreturn PTR_ERR(device);\r\nif (device->block) {\r\nmax_count = device->block->bdev ? 0 : -1;\r\nopen_count = atomic_read(&device->block->open_count);\r\nif (open_count > max_count) {\r\nif (open_count > 0)\r\npr_warning("%s: The DASD cannot be set offline "\r\n"with open count %i\n",\r\ndev_name(&cdev->dev), open_count);\r\nelse\r\npr_warning("%s: The DASD cannot be set offline "\r\n"while it is in use\n",\r\ndev_name(&cdev->dev));\r\nclear_bit(DASD_FLAG_OFFLINE, &device->flags);\r\ndasd_put_device(device);\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (test_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\r\nif (test_and_set_bit(DASD_FLAG_OFFLINE, &device->flags)) {\r\ndasd_put_device(device);\r\nreturn -EBUSY;\r\n} else\r\nclear_bit(DASD_FLAG_SAFE_OFFLINE, &device->flags);\r\n} else\r\nif (test_bit(DASD_FLAG_OFFLINE, &device->flags)) {\r\ndasd_put_device(device);\r\nreturn -EBUSY;\r\n}\r\nif (test_and_clear_bit(DASD_FLAG_SAFE_OFFLINE, &device->flags) &&\r\n!test_and_set_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\r\nrc = fsync_bdev(device->block->bdev);\r\nif (rc != 0)\r\ngoto interrupted;\r\ndasd_schedule_device_bh(device);\r\nrc = wait_event_interruptible(shutdown_waitq,\r\n_wait_for_empty_queues(device));\r\nif (rc != 0)\r\ngoto interrupted;\r\n}\r\nset_bit(DASD_FLAG_OFFLINE, &device->flags);\r\ndasd_set_target_state(device, DASD_STATE_NEW);\r\nblock = device->block;\r\ndasd_delete_device(device);\r\nif (block)\r\ndasd_free_block(block);\r\nreturn 0;\r\ninterrupted:\r\nclear_bit(DASD_FLAG_SAFE_OFFLINE, &device->flags);\r\nclear_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags);\r\nclear_bit(DASD_FLAG_OFFLINE, &device->flags);\r\ndasd_put_device(device);\r\nreturn rc;\r\n}\r\nint dasd_generic_last_path_gone(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\ndev_warn(&device->cdev->dev, "No operational channel path is left "\r\n"for the device\n");\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s", "last path gone");\r\ndasd_eer_write(device, NULL, DASD_EER_NOPATH);\r\nif (device->state < DASD_STATE_BASIC)\r\nreturn 0;\r\nlist_for_each_entry(cqr, &device->ccw_queue, devlist)\r\nif ((cqr->status == DASD_CQR_IN_IO) ||\r\n(cqr->status == DASD_CQR_CLEAR_PENDING)) {\r\ncqr->status = DASD_CQR_QUEUED;\r\ncqr->retries++;\r\n}\r\ndasd_device_set_stop_bits(device, DASD_STOPPED_DC_WAIT);\r\ndasd_device_clear_timer(device);\r\ndasd_schedule_device_bh(device);\r\nreturn 1;\r\n}\r\nint dasd_generic_path_operational(struct dasd_device *device)\r\n{\r\ndev_info(&device->cdev->dev, "A channel path to the device has become "\r\n"operational\n");\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s", "path operational");\r\ndasd_device_remove_stop_bits(device, DASD_STOPPED_DC_WAIT);\r\nif (device->stopped & DASD_UNRESUMED_PM) {\r\ndasd_device_remove_stop_bits(device, DASD_UNRESUMED_PM);\r\ndasd_restore_device(device);\r\nreturn 1;\r\n}\r\ndasd_schedule_device_bh(device);\r\nif (device->block)\r\ndasd_schedule_block_bh(device->block);\r\nreturn 1;\r\n}\r\nint dasd_generic_notify(struct ccw_device *cdev, int event)\r\n{\r\nstruct dasd_device *device;\r\nint ret;\r\ndevice = dasd_device_from_cdev_locked(cdev);\r\nif (IS_ERR(device))\r\nreturn 0;\r\nret = 0;\r\nswitch (event) {\r\ncase CIO_GONE:\r\ncase CIO_BOXED:\r\ncase CIO_NO_PATH:\r\ndevice->path_data.opm = 0;\r\ndevice->path_data.ppm = 0;\r\ndevice->path_data.npm = 0;\r\nret = dasd_generic_last_path_gone(device);\r\nbreak;\r\ncase CIO_OPER:\r\nret = 1;\r\nif (device->path_data.opm)\r\nret = dasd_generic_path_operational(device);\r\nbreak;\r\n}\r\ndasd_put_device(device);\r\nreturn ret;\r\n}\r\nvoid dasd_generic_path_event(struct ccw_device *cdev, int *path_event)\r\n{\r\nint chp;\r\n__u8 oldopm, eventlpm;\r\nstruct dasd_device *device;\r\ndevice = dasd_device_from_cdev_locked(cdev);\r\nif (IS_ERR(device))\r\nreturn;\r\nfor (chp = 0; chp < 8; chp++) {\r\neventlpm = 0x80 >> chp;\r\nif (path_event[chp] & PE_PATH_GONE) {\r\noldopm = device->path_data.opm;\r\ndevice->path_data.opm &= ~eventlpm;\r\ndevice->path_data.ppm &= ~eventlpm;\r\ndevice->path_data.npm &= ~eventlpm;\r\nif (oldopm && !device->path_data.opm) {\r\ndev_warn(&device->cdev->dev,\r\n"No verified channel paths remain "\r\n"for the device\n");\r\nDBF_DEV_EVENT(DBF_WARNING, device,\r\n"%s", "last verified path gone");\r\ndasd_eer_write(device, NULL, DASD_EER_NOPATH);\r\ndasd_device_set_stop_bits(device,\r\nDASD_STOPPED_DC_WAIT);\r\n}\r\n}\r\nif (path_event[chp] & PE_PATH_AVAILABLE) {\r\ndevice->path_data.opm &= ~eventlpm;\r\ndevice->path_data.ppm &= ~eventlpm;\r\ndevice->path_data.npm &= ~eventlpm;\r\ndevice->path_data.tbvpm |= eventlpm;\r\ndasd_schedule_device_bh(device);\r\n}\r\nif (path_event[chp] & PE_PATHGROUP_ESTABLISHED) {\r\nif (!(device->path_data.opm & eventlpm) &&\r\n!(device->path_data.tbvpm & eventlpm)) {\r\ndevice->path_data.tbvpm |= eventlpm;\r\ndasd_schedule_device_bh(device);\r\n}\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Pathgroup re-established\n");\r\nif (device->discipline->kick_validate)\r\ndevice->discipline->kick_validate(device);\r\n}\r\n}\r\ndasd_put_device(device);\r\n}\r\nint dasd_generic_verify_path(struct dasd_device *device, __u8 lpm)\r\n{\r\nif (!device->path_data.opm && lpm) {\r\ndevice->path_data.opm = lpm;\r\ndasd_generic_path_operational(device);\r\n} else\r\ndevice->path_data.opm |= lpm;\r\nreturn 0;\r\n}\r\nint dasd_generic_pm_freeze(struct ccw_device *cdev)\r\n{\r\nstruct dasd_device *device = dasd_device_from_cdev(cdev);\r\nstruct list_head freeze_queue;\r\nstruct dasd_ccw_req *cqr, *n;\r\nstruct dasd_ccw_req *refers;\r\nint rc;\r\nif (IS_ERR(device))\r\nreturn PTR_ERR(device);\r\nset_bit(DASD_FLAG_SUSPENDED, &device->flags);\r\nif (device->discipline->freeze)\r\nrc = device->discipline->freeze(device);\r\ndasd_device_set_stop_bits(device, DASD_STOPPED_PM);\r\nINIT_LIST_HEAD(&freeze_queue);\r\nspin_lock_irq(get_ccwdev_lock(cdev));\r\nrc = 0;\r\nlist_for_each_entry_safe(cqr, n, &device->ccw_queue, devlist) {\r\nif (cqr->status == DASD_CQR_IN_IO) {\r\nrc = device->discipline->term_IO(cqr);\r\nif (rc) {\r\ndev_err(&device->cdev->dev,\r\n"Unable to terminate request %p "\r\n"on suspend\n", cqr);\r\nspin_unlock_irq(get_ccwdev_lock(cdev));\r\ndasd_put_device(device);\r\nreturn rc;\r\n}\r\n}\r\nlist_move_tail(&cqr->devlist, &freeze_queue);\r\n}\r\nspin_unlock_irq(get_ccwdev_lock(cdev));\r\nlist_for_each_entry_safe(cqr, n, &freeze_queue, devlist) {\r\nwait_event(dasd_flush_wq,\r\n(cqr->status != DASD_CQR_CLEAR_PENDING));\r\nif (cqr->status == DASD_CQR_CLEARED)\r\ncqr->status = DASD_CQR_QUEUED;\r\nif (_dasd_requeue_request(cqr))\r\ncontinue;\r\nlist_del_init(&cqr->devlist);\r\nwhile (cqr->refers != NULL) {\r\nrefers = cqr->refers;\r\nlist_del(&cqr->blocklist);\r\ndasd_free_erp_request(cqr, cqr->memdev);\r\ncqr = refers;\r\n}\r\nif (cqr->block)\r\nlist_del_init(&cqr->blocklist);\r\ncqr->block->base->discipline->free_cp(\r\ncqr, (struct request *) cqr->callback_data);\r\n}\r\nif (!list_empty(&freeze_queue)) {\r\nspin_lock_irq(get_ccwdev_lock(cdev));\r\nlist_splice_tail(&freeze_queue, &device->ccw_queue);\r\nspin_unlock_irq(get_ccwdev_lock(cdev));\r\n}\r\ndasd_put_device(device);\r\nreturn rc;\r\n}\r\nint dasd_generic_restore_device(struct ccw_device *cdev)\r\n{\r\nstruct dasd_device *device = dasd_device_from_cdev(cdev);\r\nint rc = 0;\r\nif (IS_ERR(device))\r\nreturn PTR_ERR(device);\r\ndasd_device_remove_stop_bits(device,\r\n(DASD_STOPPED_PM | DASD_UNRESUMED_PM));\r\ndasd_schedule_device_bh(device);\r\nif (device->discipline->restore && !(device->stopped))\r\nrc = device->discipline->restore(device);\r\nif (rc || device->stopped)\r\ndevice->stopped |= DASD_UNRESUMED_PM;\r\nif (device->block)\r\ndasd_schedule_block_bh(device->block);\r\nclear_bit(DASD_FLAG_SUSPENDED, &device->flags);\r\ndasd_put_device(device);\r\nreturn 0;\r\n}\r\nstatic struct dasd_ccw_req *dasd_generic_build_rdc(struct dasd_device *device,\r\nvoid *rdc_buffer,\r\nint rdc_buffer_size,\r\nint magic)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nunsigned long *idaw;\r\ncqr = dasd_smalloc_request(magic, 1 , rdc_buffer_size, device);\r\nif (IS_ERR(cqr)) {\r\ndev_err(&device->cdev->dev,\r\n"An error occurred in the DASD device driver, "\r\n"reason=%s\n", "13");\r\nreturn cqr;\r\n}\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = CCW_CMD_RDC;\r\nif (idal_is_needed(rdc_buffer, rdc_buffer_size)) {\r\nidaw = (unsigned long *) (cqr->data);\r\nccw->cda = (__u32)(addr_t) idaw;\r\nccw->flags = CCW_FLAG_IDA;\r\nidaw = idal_create_words(idaw, rdc_buffer, rdc_buffer_size);\r\n} else {\r\nccw->cda = (__u32)(addr_t) rdc_buffer;\r\nccw->flags = 0;\r\n}\r\nccw->count = rdc_buffer_size;\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\ncqr->expires = 10*HZ;\r\ncqr->retries = 256;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nreturn cqr;\r\n}\r\nint dasd_generic_read_dev_chars(struct dasd_device *device, int magic,\r\nvoid *rdc_buffer, int rdc_buffer_size)\r\n{\r\nint ret;\r\nstruct dasd_ccw_req *cqr;\r\ncqr = dasd_generic_build_rdc(device, rdc_buffer, rdc_buffer_size,\r\nmagic);\r\nif (IS_ERR(cqr))\r\nreturn PTR_ERR(cqr);\r\nret = dasd_sleep_on(cqr);\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn ret;\r\n}\r\nchar *dasd_get_sense(struct irb *irb)\r\n{\r\nstruct tsb *tsb = NULL;\r\nchar *sense = NULL;\r\nif (scsw_is_tm(&irb->scsw) && (irb->scsw.tm.fcxs == 0x01)) {\r\nif (irb->scsw.tm.tcw)\r\ntsb = tcw_get_tsb((struct tcw *)(unsigned long)\r\nirb->scsw.tm.tcw);\r\nif (tsb && tsb->length == 64 && tsb->flags)\r\nswitch (tsb->flags & 0x07) {\r\ncase 1:\r\nsense = tsb->tsa.iostat.sense;\r\nbreak;\r\ncase 2:\r\nsense = tsb->tsa.ddpc.sense;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else if (irb->esw.esw0.erw.cons) {\r\nsense = irb->ecw;\r\n}\r\nreturn sense;\r\n}\r\nvoid dasd_generic_shutdown(struct ccw_device *cdev)\r\n{\r\nstruct dasd_device *device;\r\ndevice = dasd_device_from_cdev(cdev);\r\nif (IS_ERR(device))\r\nreturn;\r\nif (device->block)\r\ndasd_schedule_block_bh(device->block);\r\ndasd_schedule_device_bh(device);\r\nwait_event(shutdown_waitq, _wait_for_empty_queues(device));\r\n}\r\nstatic int __init dasd_init(void)\r\n{\r\nint rc;\r\ninit_waitqueue_head(&dasd_init_waitq);\r\ninit_waitqueue_head(&dasd_flush_wq);\r\ninit_waitqueue_head(&generic_waitq);\r\ninit_waitqueue_head(&shutdown_waitq);\r\ndasd_debug_area = debug_register("dasd", 1, 1, 8 * sizeof(long));\r\nif (dasd_debug_area == NULL) {\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\ndebug_register_view(dasd_debug_area, &debug_sprintf_view);\r\ndebug_set_level(dasd_debug_area, DBF_WARNING);\r\nDBF_EVENT(DBF_EMERG, "%s", "debug area created");\r\ndasd_diag_discipline_pointer = NULL;\r\ndasd_statistics_createroot();\r\nrc = dasd_devmap_init();\r\nif (rc)\r\ngoto failed;\r\nrc = dasd_gendisk_init();\r\nif (rc)\r\ngoto failed;\r\nrc = dasd_parse();\r\nif (rc)\r\ngoto failed;\r\nrc = dasd_eer_init();\r\nif (rc)\r\ngoto failed;\r\n#ifdef CONFIG_PROC_FS\r\nrc = dasd_proc_init();\r\nif (rc)\r\ngoto failed;\r\n#endif\r\nreturn 0;\r\nfailed:\r\npr_info("The DASD device driver could not be initialized\n");\r\ndasd_exit();\r\nreturn rc;\r\n}
