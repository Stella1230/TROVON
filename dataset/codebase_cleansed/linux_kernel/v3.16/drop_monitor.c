static struct sk_buff *reset_per_cpu_data(struct per_cpu_dm_data *data)\r\n{\r\nsize_t al;\r\nstruct net_dm_alert_msg *msg;\r\nstruct nlattr *nla;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nal = sizeof(struct net_dm_alert_msg);\r\nal += dm_hit_limit * sizeof(struct net_dm_drop_point);\r\nal += sizeof(struct nlattr);\r\nskb = genlmsg_new(al, GFP_KERNEL);\r\nif (skb) {\r\ngenlmsg_put(skb, 0, 0, &net_drop_monitor_family,\r\n0, NET_DM_CMD_ALERT);\r\nnla = nla_reserve(skb, NLA_UNSPEC,\r\nsizeof(struct net_dm_alert_msg));\r\nmsg = nla_data(nla);\r\nmemset(msg, 0, al);\r\n} else {\r\nmod_timer(&data->send_timer, jiffies + HZ / 10);\r\n}\r\nspin_lock_irqsave(&data->lock, flags);\r\nswap(data->skb, skb);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn skb;\r\n}\r\nstatic void send_dm_alert(struct work_struct *work)\r\n{\r\nstruct sk_buff *skb;\r\nstruct per_cpu_dm_data *data;\r\ndata = container_of(work, struct per_cpu_dm_data, dm_alert_work);\r\nskb = reset_per_cpu_data(data);\r\nif (skb)\r\ngenlmsg_multicast(&net_drop_monitor_family, skb, 0,\r\n0, GFP_KERNEL);\r\n}\r\nstatic void sched_send_work(unsigned long _data)\r\n{\r\nstruct per_cpu_dm_data *data = (struct per_cpu_dm_data *)_data;\r\nschedule_work(&data->dm_alert_work);\r\n}\r\nstatic void trace_drop_common(struct sk_buff *skb, void *location)\r\n{\r\nstruct net_dm_alert_msg *msg;\r\nstruct nlmsghdr *nlh;\r\nstruct nlattr *nla;\r\nint i;\r\nstruct sk_buff *dskb;\r\nstruct per_cpu_dm_data *data;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ndata = &__get_cpu_var(dm_cpu_data);\r\nspin_lock(&data->lock);\r\ndskb = data->skb;\r\nif (!dskb)\r\ngoto out;\r\nnlh = (struct nlmsghdr *)dskb->data;\r\nnla = genlmsg_data(nlmsg_data(nlh));\r\nmsg = nla_data(nla);\r\nfor (i = 0; i < msg->entries; i++) {\r\nif (!memcmp(&location, msg->points[i].pc, sizeof(void *))) {\r\nmsg->points[i].count++;\r\ngoto out;\r\n}\r\n}\r\nif (msg->entries == dm_hit_limit)\r\ngoto out;\r\n__nla_reserve_nohdr(dskb, sizeof(struct net_dm_drop_point));\r\nnla->nla_len += NLA_ALIGN(sizeof(struct net_dm_drop_point));\r\nmemcpy(msg->points[msg->entries].pc, &location, sizeof(void *));\r\nmsg->points[msg->entries].count = 1;\r\nmsg->entries++;\r\nif (!timer_pending(&data->send_timer)) {\r\ndata->send_timer.expires = jiffies + dm_delay * HZ;\r\nadd_timer(&data->send_timer);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n}\r\nstatic void trace_kfree_skb_hit(void *ignore, struct sk_buff *skb, void *location)\r\n{\r\ntrace_drop_common(skb, location);\r\n}\r\nstatic void trace_napi_poll_hit(void *ignore, struct napi_struct *napi)\r\n{\r\nstruct dm_hw_stat_delta *new_stat;\r\nif (!napi->dev)\r\nreturn;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(new_stat, &hw_stats_list, list) {\r\nif ((new_stat->dev == napi->dev) &&\r\n(time_after(jiffies, new_stat->last_rx + dm_hw_check_delta)) &&\r\n(napi->dev->stats.rx_dropped != new_stat->last_drop_val)) {\r\ntrace_drop_common(NULL, NULL);\r\nnew_stat->last_drop_val = napi->dev->stats.rx_dropped;\r\nnew_stat->last_rx = jiffies;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int set_all_monitor_traces(int state)\r\n{\r\nint rc = 0;\r\nstruct dm_hw_stat_delta *new_stat = NULL;\r\nstruct dm_hw_stat_delta *temp;\r\nmutex_lock(&trace_state_mutex);\r\nif (state == trace_state) {\r\nrc = -EAGAIN;\r\ngoto out_unlock;\r\n}\r\nswitch (state) {\r\ncase TRACE_ON:\r\nif (!try_module_get(THIS_MODULE)) {\r\nrc = -ENODEV;\r\nbreak;\r\n}\r\nrc |= register_trace_kfree_skb(trace_kfree_skb_hit, NULL);\r\nrc |= register_trace_napi_poll(trace_napi_poll_hit, NULL);\r\nbreak;\r\ncase TRACE_OFF:\r\nrc |= unregister_trace_kfree_skb(trace_kfree_skb_hit, NULL);\r\nrc |= unregister_trace_napi_poll(trace_napi_poll_hit, NULL);\r\ntracepoint_synchronize_unregister();\r\nlist_for_each_entry_safe(new_stat, temp, &hw_stats_list, list) {\r\nif (new_stat->dev == NULL) {\r\nlist_del_rcu(&new_stat->list);\r\nkfree_rcu(new_stat, rcu);\r\n}\r\n}\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\ndefault:\r\nrc = 1;\r\nbreak;\r\n}\r\nif (!rc)\r\ntrace_state = state;\r\nelse\r\nrc = -EINPROGRESS;\r\nout_unlock:\r\nmutex_unlock(&trace_state_mutex);\r\nreturn rc;\r\n}\r\nstatic int net_dm_cmd_config(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int net_dm_cmd_trace(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nswitch (info->genlhdr->cmd) {\r\ncase NET_DM_CMD_START:\r\nreturn set_all_monitor_traces(TRACE_ON);\r\nbreak;\r\ncase NET_DM_CMD_STOP:\r\nreturn set_all_monitor_traces(TRACE_OFF);\r\nbreak;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int dropmon_net_event(struct notifier_block *ev_block,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct dm_hw_stat_delta *new_stat = NULL;\r\nstruct dm_hw_stat_delta *tmp;\r\nswitch (event) {\r\ncase NETDEV_REGISTER:\r\nnew_stat = kzalloc(sizeof(struct dm_hw_stat_delta), GFP_KERNEL);\r\nif (!new_stat)\r\ngoto out;\r\nnew_stat->dev = dev;\r\nnew_stat->last_rx = jiffies;\r\nmutex_lock(&trace_state_mutex);\r\nlist_add_rcu(&new_stat->list, &hw_stats_list);\r\nmutex_unlock(&trace_state_mutex);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nmutex_lock(&trace_state_mutex);\r\nlist_for_each_entry_safe(new_stat, tmp, &hw_stats_list, list) {\r\nif (new_stat->dev == dev) {\r\nnew_stat->dev = NULL;\r\nif (trace_state == TRACE_OFF) {\r\nlist_del_rcu(&new_stat->list);\r\nkfree_rcu(new_stat, rcu);\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_unlock(&trace_state_mutex);\r\nbreak;\r\n}\r\nout:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init init_net_drop_monitor(void)\r\n{\r\nstruct per_cpu_dm_data *data;\r\nint cpu, rc;\r\npr_info("Initializing network drop monitor service\n");\r\nif (sizeof(void *) > 8) {\r\npr_err("Unable to store program counters on this arch, Drop monitor failed\n");\r\nreturn -ENOSPC;\r\n}\r\nrc = genl_register_family_with_ops_groups(&net_drop_monitor_family,\r\ndropmon_ops, dropmon_mcgrps);\r\nif (rc) {\r\npr_err("Could not create drop monitor netlink family\n");\r\nreturn rc;\r\n}\r\nWARN_ON(net_drop_monitor_family.mcgrp_offset != NET_DM_GRP_ALERT);\r\nrc = register_netdevice_notifier(&dropmon_net_notifier);\r\nif (rc < 0) {\r\npr_crit("Failed to register netdevice notifier\n");\r\ngoto out_unreg;\r\n}\r\nrc = 0;\r\nfor_each_possible_cpu(cpu) {\r\ndata = &per_cpu(dm_cpu_data, cpu);\r\nINIT_WORK(&data->dm_alert_work, send_dm_alert);\r\ninit_timer(&data->send_timer);\r\ndata->send_timer.data = (unsigned long)data;\r\ndata->send_timer.function = sched_send_work;\r\nspin_lock_init(&data->lock);\r\nreset_per_cpu_data(data);\r\n}\r\ngoto out;\r\nout_unreg:\r\ngenl_unregister_family(&net_drop_monitor_family);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void exit_net_drop_monitor(void)\r\n{\r\nstruct per_cpu_dm_data *data;\r\nint cpu;\r\nBUG_ON(unregister_netdevice_notifier(&dropmon_net_notifier));\r\nfor_each_possible_cpu(cpu) {\r\ndata = &per_cpu(dm_cpu_data, cpu);\r\ndel_timer_sync(&data->send_timer);\r\ncancel_work_sync(&data->dm_alert_work);\r\nkfree_skb(data->skb);\r\n}\r\nBUG_ON(genl_unregister_family(&net_drop_monitor_family));\r\n}
