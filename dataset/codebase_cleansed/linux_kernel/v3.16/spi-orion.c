static inline void __iomem *spi_reg(struct orion_spi *orion_spi, u32 reg)\r\n{\r\nreturn orion_spi->base + reg;\r\n}\r\nstatic inline void\r\norion_spi_setbits(struct orion_spi *orion_spi, u32 reg, u32 mask)\r\n{\r\nvoid __iomem *reg_addr = spi_reg(orion_spi, reg);\r\nu32 val;\r\nval = readl(reg_addr);\r\nval |= mask;\r\nwritel(val, reg_addr);\r\n}\r\nstatic inline void\r\norion_spi_clrbits(struct orion_spi *orion_spi, u32 reg, u32 mask)\r\n{\r\nvoid __iomem *reg_addr = spi_reg(orion_spi, reg);\r\nu32 val;\r\nval = readl(reg_addr);\r\nval &= ~mask;\r\nwritel(val, reg_addr);\r\n}\r\nstatic int orion_spi_baudrate_set(struct spi_device *spi, unsigned int speed)\r\n{\r\nu32 tclk_hz;\r\nu32 rate;\r\nu32 prescale;\r\nu32 reg;\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\ntclk_hz = clk_get_rate(orion_spi->clk);\r\nrate = DIV_ROUND_UP(tclk_hz, speed);\r\nrate = roundup(rate, 2);\r\nif (rate > 30)\r\nreturn -EINVAL;\r\nif (rate < 4)\r\nrate = 4;\r\nprescale = 0x10 + rate/2;\r\nreg = readl(spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\r\nreg = ((reg & ~ORION_SPI_CLK_PRESCALE_MASK) | prescale);\r\nwritel(reg, spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\r\nreturn 0;\r\n}\r\nstatic void\r\norion_spi_mode_set(struct spi_device *spi)\r\n{\r\nu32 reg;\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\nreg = readl(spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\r\nreg &= ~ORION_SPI_MODE_MASK;\r\nif (spi->mode & SPI_CPOL)\r\nreg |= ORION_SPI_MODE_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\nreg |= ORION_SPI_MODE_CPHA;\r\nwritel(reg, spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\r\n}\r\nstatic int\r\norion_spi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct orion_spi *orion_spi;\r\nunsigned int speed = spi->max_speed_hz;\r\nunsigned int bits_per_word = spi->bits_per_word;\r\nint rc;\r\norion_spi = spi_master_get_devdata(spi->master);\r\nif ((t != NULL) && t->speed_hz)\r\nspeed = t->speed_hz;\r\nif ((t != NULL) && t->bits_per_word)\r\nbits_per_word = t->bits_per_word;\r\norion_spi_mode_set(spi);\r\nrc = orion_spi_baudrate_set(spi, speed);\r\nif (rc)\r\nreturn rc;\r\nif (bits_per_word == 16)\r\norion_spi_setbits(orion_spi, ORION_SPI_IF_CONFIG_REG,\r\nORION_SPI_IF_8_16_BIT_MODE);\r\nelse\r\norion_spi_clrbits(orion_spi, ORION_SPI_IF_CONFIG_REG,\r\nORION_SPI_IF_8_16_BIT_MODE);\r\nreturn 0;\r\n}\r\nstatic void orion_spi_set_cs(struct orion_spi *orion_spi, int enable)\r\n{\r\nif (enable)\r\norion_spi_setbits(orion_spi, ORION_SPI_IF_CTRL_REG, 0x1);\r\nelse\r\norion_spi_clrbits(orion_spi, ORION_SPI_IF_CTRL_REG, 0x1);\r\n}\r\nstatic inline int orion_spi_wait_till_ready(struct orion_spi *orion_spi)\r\n{\r\nint i;\r\nfor (i = 0; i < ORION_SPI_WAIT_RDY_MAX_LOOP; i++) {\r\nif (readl(spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG)))\r\nreturn 1;\r\nelse\r\nudelay(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic inline int\r\norion_spi_write_read_8bit(struct spi_device *spi,\r\nconst u8 **tx_buf, u8 **rx_buf)\r\n{\r\nvoid __iomem *tx_reg, *rx_reg, *int_reg;\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\ntx_reg = spi_reg(orion_spi, ORION_SPI_DATA_OUT_REG);\r\nrx_reg = spi_reg(orion_spi, ORION_SPI_DATA_IN_REG);\r\nint_reg = spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG);\r\nwritel(0x0, int_reg);\r\nif (tx_buf && *tx_buf)\r\nwritel(*(*tx_buf)++, tx_reg);\r\nelse\r\nwritel(0, tx_reg);\r\nif (orion_spi_wait_till_ready(orion_spi) < 0) {\r\ndev_err(&spi->dev, "TXS timed out\n");\r\nreturn -1;\r\n}\r\nif (rx_buf && *rx_buf)\r\n*(*rx_buf)++ = readl(rx_reg);\r\nreturn 1;\r\n}\r\nstatic inline int\r\norion_spi_write_read_16bit(struct spi_device *spi,\r\nconst u16 **tx_buf, u16 **rx_buf)\r\n{\r\nvoid __iomem *tx_reg, *rx_reg, *int_reg;\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\ntx_reg = spi_reg(orion_spi, ORION_SPI_DATA_OUT_REG);\r\nrx_reg = spi_reg(orion_spi, ORION_SPI_DATA_IN_REG);\r\nint_reg = spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG);\r\nwritel(0x0, int_reg);\r\nif (tx_buf && *tx_buf)\r\nwritel(__cpu_to_le16(get_unaligned((*tx_buf)++)), tx_reg);\r\nelse\r\nwritel(0, tx_reg);\r\nif (orion_spi_wait_till_ready(orion_spi) < 0) {\r\ndev_err(&spi->dev, "TXS timed out\n");\r\nreturn -1;\r\n}\r\nif (rx_buf && *rx_buf)\r\nput_unaligned(__le16_to_cpu(readl(rx_reg)), (*rx_buf)++);\r\nreturn 1;\r\n}\r\nstatic unsigned int\r\norion_spi_write_read(struct spi_device *spi, struct spi_transfer *xfer)\r\n{\r\nunsigned int count;\r\nint word_len;\r\nword_len = spi->bits_per_word;\r\ncount = xfer->len;\r\nif (word_len == 8) {\r\nconst u8 *tx = xfer->tx_buf;\r\nu8 *rx = xfer->rx_buf;\r\ndo {\r\nif (orion_spi_write_read_8bit(spi, &tx, &rx) < 0)\r\ngoto out;\r\ncount--;\r\n} while (count);\r\n} else if (word_len == 16) {\r\nconst u16 *tx = xfer->tx_buf;\r\nu16 *rx = xfer->rx_buf;\r\ndo {\r\nif (orion_spi_write_read_16bit(spi, &tx, &rx) < 0)\r\ngoto out;\r\ncount -= 2;\r\n} while (count);\r\n}\r\nout:\r\nreturn xfer->len - count;\r\n}\r\nstatic int orion_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct orion_spi *orion_spi = spi_master_get_devdata(master);\r\nstruct spi_device *spi = m->spi;\r\nstruct spi_transfer *t = NULL;\r\nint par_override = 0;\r\nint status = 0;\r\nint cs_active = 0;\r\nstatus = orion_spi_setup_transfer(spi, NULL);\r\nif (status < 0)\r\ngoto msg_done;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (par_override || t->speed_hz || t->bits_per_word) {\r\npar_override = 1;\r\nstatus = orion_spi_setup_transfer(spi, t);\r\nif (status < 0)\r\nbreak;\r\nif (!t->speed_hz && !t->bits_per_word)\r\npar_override = 0;\r\n}\r\nif (!cs_active) {\r\norion_spi_set_cs(orion_spi, 1);\r\ncs_active = 1;\r\n}\r\nif (t->len)\r\nm->actual_length += orion_spi_write_read(spi, t);\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (t->cs_change) {\r\norion_spi_set_cs(orion_spi, 0);\r\ncs_active = 0;\r\n}\r\n}\r\nmsg_done:\r\nif (cs_active)\r\norion_spi_set_cs(orion_spi, 0);\r\nm->status = status;\r\nspi_finalize_current_message(master);\r\nreturn 0;\r\n}\r\nstatic int orion_spi_reset(struct orion_spi *orion_spi)\r\n{\r\norion_spi_set_cs(orion_spi, 0);\r\nreturn 0;\r\n}\r\nstatic int orion_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct orion_spi *spi;\r\nstruct resource *r;\r\nunsigned long tclk_hz;\r\nint status = 0;\r\nconst u32 *iprop;\r\nint size;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*spi));\r\nif (master == NULL) {\r\ndev_dbg(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (pdev->id != -1)\r\nmaster->bus_num = pdev->id;\r\nif (pdev->dev.of_node) {\r\niprop = of_get_property(pdev->dev.of_node, "cell-index",\r\n&size);\r\nif (iprop && size == sizeof(*iprop))\r\nmaster->bus_num = *iprop;\r\n}\r\nmaster->mode_bits = SPI_CPHA | SPI_CPOL;\r\nmaster->transfer_one_message = orion_spi_transfer_one_message;\r\nmaster->num_chipselect = ORION_NUM_CHIPSELECTS;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\r\nplatform_set_drvdata(pdev, master);\r\nspi = spi_master_get_devdata(master);\r\nspi->master = master;\r\nspi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(spi->clk)) {\r\nstatus = PTR_ERR(spi->clk);\r\ngoto out;\r\n}\r\nclk_prepare(spi->clk);\r\nclk_enable(spi->clk);\r\ntclk_hz = clk_get_rate(spi->clk);\r\nmaster->max_speed_hz = DIV_ROUND_UP(tclk_hz, 4);\r\nmaster->min_speed_hz = DIV_ROUND_UP(tclk_hz, 30);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nspi->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(spi->base)) {\r\nstatus = PTR_ERR(spi->base);\r\ngoto out_rel_clk;\r\n}\r\nif (orion_spi_reset(spi) < 0)\r\ngoto out_rel_clk;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nstatus = devm_spi_register_master(&pdev->dev, master);\r\nif (status < 0)\r\ngoto out_rel_clk;\r\nreturn status;\r\nout_rel_clk:\r\nclk_disable_unprepare(spi->clk);\r\nout:\r\nspi_master_put(master);\r\nreturn status;\r\n}\r\nstatic int orion_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct orion_spi *spi;\r\nmaster = platform_get_drvdata(pdev);\r\nspi = spi_master_get_devdata(master);\r\nclk_disable_unprepare(spi->clk);\r\nreturn 0;\r\n}
