void i2c_transfer_trace_reg(void)\r\n{\r\nstatic_key_slow_inc(&i2c_trace_msg);\r\n}\r\nvoid i2c_transfer_trace_unreg(void)\r\n{\r\nstatic_key_slow_dec(&i2c_trace_msg);\r\n}\r\nstatic const struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,\r\nconst struct i2c_client *client)\r\n{\r\nwhile (id->name[0]) {\r\nif (strcmp(client->name, id->name) == 0)\r\nreturn id;\r\nid++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int i2c_device_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_driver *driver;\r\nif (!client)\r\nreturn 0;\r\nif (of_driver_match_device(dev, drv))\r\nreturn 1;\r\nif (acpi_driver_match_device(dev, drv))\r\nreturn 1;\r\ndriver = to_i2c_driver(drv);\r\nif (driver->id_table)\r\nreturn i2c_match_id(driver->id_table, client) != NULL;\r\nreturn 0;\r\n}\r\nstatic int i2c_device_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint rc;\r\nrc = acpi_device_uevent_modalias(dev, env);\r\nif (rc != -ENODEV)\r\nreturn rc;\r\nif (add_uevent_var(env, "MODALIAS=%s%s",\r\nI2C_MODULE_PREFIX, client->name))\r\nreturn -ENOMEM;\r\ndev_dbg(dev, "uevent\n");\r\nreturn 0;\r\n}\r\nstatic int get_scl_gpio_value(struct i2c_adapter *adap)\r\n{\r\nreturn gpio_get_value(adap->bus_recovery_info->scl_gpio);\r\n}\r\nstatic void set_scl_gpio_value(struct i2c_adapter *adap, int val)\r\n{\r\ngpio_set_value(adap->bus_recovery_info->scl_gpio, val);\r\n}\r\nstatic int get_sda_gpio_value(struct i2c_adapter *adap)\r\n{\r\nreturn gpio_get_value(adap->bus_recovery_info->sda_gpio);\r\n}\r\nstatic int i2c_get_gpios_for_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\r\nstruct device *dev = &adap->dev;\r\nint ret = 0;\r\nret = gpio_request_one(bri->scl_gpio, GPIOF_OPEN_DRAIN |\r\nGPIOF_OUT_INIT_HIGH, "i2c-scl");\r\nif (ret) {\r\ndev_warn(dev, "Can't get SCL gpio: %d\n", bri->scl_gpio);\r\nreturn ret;\r\n}\r\nif (bri->get_sda) {\r\nif (gpio_request_one(bri->sda_gpio, GPIOF_IN, "i2c-sda")) {\r\ndev_warn(dev, "Can't get SDA gpio: %d. Not using SDA polling\n",\r\nbri->sda_gpio);\r\nbri->get_sda = NULL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void i2c_put_gpios_for_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\r\nif (bri->get_sda)\r\ngpio_free(bri->sda_gpio);\r\ngpio_free(bri->scl_gpio);\r\n}\r\nstatic int i2c_generic_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\r\nint i = 0, val = 1, ret = 0;\r\nif (bri->prepare_recovery)\r\nbri->prepare_recovery(bri);\r\nwhile (i++ < RECOVERY_CLK_CNT * 2) {\r\nif (val) {\r\nif (bri->get_sda && bri->get_sda(adap))\r\nbreak;\r\nif (!bri->get_scl(adap)) {\r\ndev_err(&adap->dev,\r\n"SCL is stuck low, exit recovery\n");\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n}\r\nval = !val;\r\nbri->set_scl(adap, val);\r\nndelay(RECOVERY_NDELAY);\r\n}\r\nif (bri->unprepare_recovery)\r\nbri->unprepare_recovery(bri);\r\nreturn ret;\r\n}\r\nint i2c_generic_scl_recovery(struct i2c_adapter *adap)\r\n{\r\nadap->bus_recovery_info->set_scl(adap, 1);\r\nreturn i2c_generic_recovery(adap);\r\n}\r\nint i2c_generic_gpio_recovery(struct i2c_adapter *adap)\r\n{\r\nint ret;\r\nret = i2c_get_gpios_for_recovery(adap);\r\nif (ret)\r\nreturn ret;\r\nret = i2c_generic_recovery(adap);\r\ni2c_put_gpios_for_recovery(adap);\r\nreturn ret;\r\n}\r\nint i2c_recover_bus(struct i2c_adapter *adap)\r\n{\r\nif (!adap->bus_recovery_info)\r\nreturn -EOPNOTSUPP;\r\ndev_dbg(&adap->dev, "Trying i2c bus recovery\n");\r\nreturn adap->bus_recovery_info->recover_bus(adap);\r\n}\r\nstatic int i2c_device_probe(struct device *dev)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_driver *driver;\r\nint status;\r\nif (!client)\r\nreturn 0;\r\ndriver = to_i2c_driver(dev->driver);\r\nif (!driver->probe || !driver->id_table)\r\nreturn -ENODEV;\r\nif (!device_can_wakeup(&client->dev))\r\ndevice_init_wakeup(&client->dev,\r\nclient->flags & I2C_CLIENT_WAKE);\r\ndev_dbg(dev, "probe\n");\r\nacpi_dev_pm_attach(&client->dev, true);\r\nstatus = driver->probe(client, i2c_match_id(driver->id_table, client));\r\nif (status)\r\nacpi_dev_pm_detach(&client->dev, true);\r\nreturn status;\r\n}\r\nstatic int i2c_device_remove(struct device *dev)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_driver *driver;\r\nint status = 0;\r\nif (!client || !dev->driver)\r\nreturn 0;\r\ndriver = to_i2c_driver(dev->driver);\r\nif (driver->remove) {\r\ndev_dbg(dev, "remove\n");\r\nstatus = driver->remove(client);\r\n}\r\nacpi_dev_pm_detach(&client->dev, true);\r\nreturn status;\r\n}\r\nstatic void i2c_device_shutdown(struct device *dev)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_driver *driver;\r\nif (!client || !dev->driver)\r\nreturn;\r\ndriver = to_i2c_driver(dev->driver);\r\nif (driver->shutdown)\r\ndriver->shutdown(client);\r\n}\r\nstatic int i2c_legacy_suspend(struct device *dev, pm_message_t mesg)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_driver *driver;\r\nif (!client || !dev->driver)\r\nreturn 0;\r\ndriver = to_i2c_driver(dev->driver);\r\nif (!driver->suspend)\r\nreturn 0;\r\nreturn driver->suspend(client, mesg);\r\n}\r\nstatic int i2c_legacy_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_driver *driver;\r\nif (!client || !dev->driver)\r\nreturn 0;\r\ndriver = to_i2c_driver(dev->driver);\r\nif (!driver->resume)\r\nreturn 0;\r\nreturn driver->resume(client);\r\n}\r\nstatic int i2c_device_pm_suspend(struct device *dev)\r\n{\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pm)\r\nreturn pm_generic_suspend(dev);\r\nelse\r\nreturn i2c_legacy_suspend(dev, PMSG_SUSPEND);\r\n}\r\nstatic int i2c_device_pm_resume(struct device *dev)\r\n{\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pm)\r\nreturn pm_generic_resume(dev);\r\nelse\r\nreturn i2c_legacy_resume(dev);\r\n}\r\nstatic int i2c_device_pm_freeze(struct device *dev)\r\n{\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pm)\r\nreturn pm_generic_freeze(dev);\r\nelse\r\nreturn i2c_legacy_suspend(dev, PMSG_FREEZE);\r\n}\r\nstatic int i2c_device_pm_thaw(struct device *dev)\r\n{\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pm)\r\nreturn pm_generic_thaw(dev);\r\nelse\r\nreturn i2c_legacy_resume(dev);\r\n}\r\nstatic int i2c_device_pm_poweroff(struct device *dev)\r\n{\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pm)\r\nreturn pm_generic_poweroff(dev);\r\nelse\r\nreturn i2c_legacy_suspend(dev, PMSG_HIBERNATE);\r\n}\r\nstatic int i2c_device_pm_restore(struct device *dev)\r\n{\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pm)\r\nreturn pm_generic_restore(dev);\r\nelse\r\nreturn i2c_legacy_resume(dev);\r\n}\r\nstatic void i2c_client_dev_release(struct device *dev)\r\n{\r\nkfree(to_i2c_client(dev));\r\n}\r\nstatic ssize_t\r\nshow_name(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", dev->type == &i2c_client_type ?\r\nto_i2c_client(dev)->name : to_i2c_adapter(dev)->name);\r\n}\r\nstatic ssize_t\r\nshow_modalias(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint len;\r\nlen = acpi_device_modalias(dev, buf, PAGE_SIZE -1);\r\nif (len != -ENODEV)\r\nreturn len;\r\nreturn sprintf(buf, "%s%s\n", I2C_MODULE_PREFIX, client->name);\r\n}\r\nstruct i2c_client *i2c_verify_client(struct device *dev)\r\n{\r\nreturn (dev->type == &i2c_client_type)\r\n? to_i2c_client(dev)\r\n: NULL;\r\n}\r\nstatic int i2c_check_client_addr_validity(const struct i2c_client *client)\r\n{\r\nif (client->flags & I2C_CLIENT_TEN) {\r\nif (client->addr > 0x3ff)\r\nreturn -EINVAL;\r\n} else {\r\nif (client->addr == 0x00 || client->addr > 0x7f)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_check_addr_validity(unsigned short addr)\r\n{\r\nif (addr < 0x08 || addr > 0x77)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __i2c_check_addr_busy(struct device *dev, void *addrp)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nint addr = *(int *)addrp;\r\nif (client && client->addr == addr)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int i2c_check_mux_parents(struct i2c_adapter *adapter, int addr)\r\n{\r\nstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\r\nint result;\r\nresult = device_for_each_child(&adapter->dev, &addr,\r\n__i2c_check_addr_busy);\r\nif (!result && parent)\r\nresult = i2c_check_mux_parents(parent, addr);\r\nreturn result;\r\n}\r\nstatic int i2c_check_mux_children(struct device *dev, void *addrp)\r\n{\r\nint result;\r\nif (dev->type == &i2c_adapter_type)\r\nresult = device_for_each_child(dev, addrp,\r\ni2c_check_mux_children);\r\nelse\r\nresult = __i2c_check_addr_busy(dev, addrp);\r\nreturn result;\r\n}\r\nstatic int i2c_check_addr_busy(struct i2c_adapter *adapter, int addr)\r\n{\r\nstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\r\nint result = 0;\r\nif (parent)\r\nresult = i2c_check_mux_parents(parent, addr);\r\nif (!result)\r\nresult = device_for_each_child(&adapter->dev, &addr,\r\ni2c_check_mux_children);\r\nreturn result;\r\n}\r\nvoid i2c_lock_adapter(struct i2c_adapter *adapter)\r\n{\r\nstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\r\nif (parent)\r\ni2c_lock_adapter(parent);\r\nelse\r\nrt_mutex_lock(&adapter->bus_lock);\r\n}\r\nstatic int i2c_trylock_adapter(struct i2c_adapter *adapter)\r\n{\r\nstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\r\nif (parent)\r\nreturn i2c_trylock_adapter(parent);\r\nelse\r\nreturn rt_mutex_trylock(&adapter->bus_lock);\r\n}\r\nvoid i2c_unlock_adapter(struct i2c_adapter *adapter)\r\n{\r\nstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\r\nif (parent)\r\ni2c_unlock_adapter(parent);\r\nelse\r\nrt_mutex_unlock(&adapter->bus_lock);\r\n}\r\nstatic void i2c_dev_set_name(struct i2c_adapter *adap,\r\nstruct i2c_client *client)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\r\nif (adev) {\r\ndev_set_name(&client->dev, "i2c-%s", acpi_dev_name(adev));\r\nreturn;\r\n}\r\ndev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),\r\nclient->addr | ((client->flags & I2C_CLIENT_TEN)\r\n? 0xa000 : 0));\r\n}\r\nstruct i2c_client *\r\ni2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)\r\n{\r\nstruct i2c_client *client;\r\nint status;\r\nclient = kzalloc(sizeof *client, GFP_KERNEL);\r\nif (!client)\r\nreturn NULL;\r\nclient->adapter = adap;\r\nclient->dev.platform_data = info->platform_data;\r\nif (info->archdata)\r\nclient->dev.archdata = *info->archdata;\r\nclient->flags = info->flags;\r\nclient->addr = info->addr;\r\nclient->irq = info->irq;\r\nstrlcpy(client->name, info->type, sizeof(client->name));\r\nstatus = i2c_check_client_addr_validity(client);\r\nif (status) {\r\ndev_err(&adap->dev, "Invalid %d-bit I2C address 0x%02hx\n",\r\nclient->flags & I2C_CLIENT_TEN ? 10 : 7, client->addr);\r\ngoto out_err_silent;\r\n}\r\nstatus = i2c_check_addr_busy(adap, client->addr);\r\nif (status)\r\ngoto out_err;\r\nclient->dev.parent = &client->adapter->dev;\r\nclient->dev.bus = &i2c_bus_type;\r\nclient->dev.type = &i2c_client_type;\r\nclient->dev.of_node = info->of_node;\r\nACPI_COMPANION_SET(&client->dev, info->acpi_node.companion);\r\ni2c_dev_set_name(adap, client);\r\nstatus = device_register(&client->dev);\r\nif (status)\r\ngoto out_err;\r\ndev_dbg(&adap->dev, "client [%s] registered with bus id %s\n",\r\nclient->name, dev_name(&client->dev));\r\nreturn client;\r\nout_err:\r\ndev_err(&adap->dev, "Failed to register i2c client %s at 0x%02x "\r\n"(%d)\n", client->name, client->addr, status);\r\nout_err_silent:\r\nkfree(client);\r\nreturn NULL;\r\n}\r\nvoid i2c_unregister_device(struct i2c_client *client)\r\n{\r\ndevice_unregister(&client->dev);\r\n}\r\nstatic int dummy_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dummy_remove(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstruct i2c_client *i2c_new_dummy(struct i2c_adapter *adapter, u16 address)\r\n{\r\nstruct i2c_board_info info = {\r\nI2C_BOARD_INFO("dummy", address),\r\n};\r\nreturn i2c_new_device(adapter, &info);\r\n}\r\nstatic void i2c_adapter_dev_release(struct device *dev)\r\n{\r\nstruct i2c_adapter *adap = to_i2c_adapter(dev);\r\ncomplete(&adap->dev_released);\r\n}\r\nstatic inline unsigned int i2c_adapter_depth(struct i2c_adapter *adapter)\r\n{\r\nunsigned int depth = 0;\r\nwhile ((adapter = i2c_parent_is_i2c_adapter(adapter)))\r\ndepth++;\r\nreturn depth;\r\n}\r\nstatic ssize_t\r\ni2c_sysfs_new_device(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_adapter *adap = to_i2c_adapter(dev);\r\nstruct i2c_board_info info;\r\nstruct i2c_client *client;\r\nchar *blank, end;\r\nint res;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nblank = strchr(buf, ' ');\r\nif (!blank) {\r\ndev_err(dev, "%s: Missing parameters\n", "new_device");\r\nreturn -EINVAL;\r\n}\r\nif (blank - buf > I2C_NAME_SIZE - 1) {\r\ndev_err(dev, "%s: Invalid device name\n", "new_device");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(info.type, buf, blank - buf);\r\nres = sscanf(++blank, "%hi%c", &info.addr, &end);\r\nif (res < 1) {\r\ndev_err(dev, "%s: Can't parse I2C address\n", "new_device");\r\nreturn -EINVAL;\r\n}\r\nif (res > 1 && end != '\n') {\r\ndev_err(dev, "%s: Extra parameters\n", "new_device");\r\nreturn -EINVAL;\r\n}\r\nclient = i2c_new_device(adap, &info);\r\nif (!client)\r\nreturn -EINVAL;\r\nmutex_lock(&adap->userspace_clients_lock);\r\nlist_add_tail(&client->detected, &adap->userspace_clients);\r\nmutex_unlock(&adap->userspace_clients_lock);\r\ndev_info(dev, "%s: Instantiated device %s at 0x%02hx\n", "new_device",\r\ninfo.type, info.addr);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ni2c_sysfs_delete_device(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_adapter *adap = to_i2c_adapter(dev);\r\nstruct i2c_client *client, *next;\r\nunsigned short addr;\r\nchar end;\r\nint res;\r\nres = sscanf(buf, "%hi%c", &addr, &end);\r\nif (res < 1) {\r\ndev_err(dev, "%s: Can't parse I2C address\n", "delete_device");\r\nreturn -EINVAL;\r\n}\r\nif (res > 1 && end != '\n') {\r\ndev_err(dev, "%s: Extra parameters\n", "delete_device");\r\nreturn -EINVAL;\r\n}\r\nres = -ENOENT;\r\nmutex_lock_nested(&adap->userspace_clients_lock,\r\ni2c_adapter_depth(adap));\r\nlist_for_each_entry_safe(client, next, &adap->userspace_clients,\r\ndetected) {\r\nif (client->addr == addr) {\r\ndev_info(dev, "%s: Deleting device %s at 0x%02hx\n",\r\n"delete_device", client->name, client->addr);\r\nlist_del(&client->detected);\r\ni2c_unregister_device(client);\r\nres = count;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&adap->userspace_clients_lock);\r\nif (res < 0)\r\ndev_err(dev, "%s: Can't find device in list\n",\r\n"delete_device");\r\nreturn res;\r\n}\r\nstruct i2c_adapter *i2c_verify_adapter(struct device *dev)\r\n{\r\nreturn (dev->type == &i2c_adapter_type)\r\n? to_i2c_adapter(dev)\r\n: NULL;\r\n}\r\nstatic void i2c_scan_static_board_info(struct i2c_adapter *adapter)\r\n{\r\nstruct i2c_devinfo *devinfo;\r\ndown_read(&__i2c_board_lock);\r\nlist_for_each_entry(devinfo, &__i2c_board_list, list) {\r\nif (devinfo->busnum == adapter->nr\r\n&& !i2c_new_device(adapter,\r\n&devinfo->board_info))\r\ndev_err(&adapter->dev,\r\n"Can't create device at 0x%02x\n",\r\ndevinfo->board_info.addr);\r\n}\r\nup_read(&__i2c_board_lock);\r\n}\r\nstatic void of_i2c_register_devices(struct i2c_adapter *adap)\r\n{\r\nvoid *result;\r\nstruct device_node *node;\r\nif (!adap->dev.of_node)\r\nreturn;\r\ndev_dbg(&adap->dev, "of_i2c: walking child nodes\n");\r\nfor_each_available_child_of_node(adap->dev.of_node, node) {\r\nstruct i2c_board_info info = {};\r\nstruct dev_archdata dev_ad = {};\r\nconst __be32 *addr;\r\nint len;\r\ndev_dbg(&adap->dev, "of_i2c: register %s\n", node->full_name);\r\nif (of_modalias_node(node, info.type, sizeof(info.type)) < 0) {\r\ndev_err(&adap->dev, "of_i2c: modalias failure on %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\naddr = of_get_property(node, "reg", &len);\r\nif (!addr || (len < sizeof(int))) {\r\ndev_err(&adap->dev, "of_i2c: invalid reg on %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\ninfo.addr = be32_to_cpup(addr);\r\nif (info.addr > (1 << 10) - 1) {\r\ndev_err(&adap->dev, "of_i2c: invalid addr=%x on %s\n",\r\ninfo.addr, node->full_name);\r\ncontinue;\r\n}\r\ninfo.irq = irq_of_parse_and_map(node, 0);\r\ninfo.of_node = of_node_get(node);\r\ninfo.archdata = &dev_ad;\r\nif (of_get_property(node, "wakeup-source", NULL))\r\ninfo.flags |= I2C_CLIENT_WAKE;\r\nrequest_module("%s%s", I2C_MODULE_PREFIX, info.type);\r\nresult = i2c_new_device(adap, &info);\r\nif (result == NULL) {\r\ndev_err(&adap->dev, "of_i2c: Failure registering %s\n",\r\nnode->full_name);\r\nof_node_put(node);\r\nirq_dispose_mapping(info.irq);\r\ncontinue;\r\n}\r\n}\r\n}\r\nstatic int of_dev_node_match(struct device *dev, void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nstruct i2c_client *of_find_i2c_device_by_node(struct device_node *node)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device(&i2c_bus_type, NULL, node,\r\nof_dev_node_match);\r\nif (!dev)\r\nreturn NULL;\r\nreturn i2c_verify_client(dev);\r\n}\r\nstruct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device(&i2c_bus_type, NULL, node,\r\nof_dev_node_match);\r\nif (!dev)\r\nreturn NULL;\r\nreturn i2c_verify_adapter(dev);\r\n}\r\nstatic void of_i2c_register_devices(struct i2c_adapter *adap) { }\r\nstatic int acpi_i2c_add_resource(struct acpi_resource *ares, void *data)\r\n{\r\nstruct i2c_board_info *info = data;\r\nif (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {\r\nstruct acpi_resource_i2c_serialbus *sb;\r\nsb = &ares->data.i2c_serial_bus;\r\nif (sb->type == ACPI_RESOURCE_SERIAL_TYPE_I2C) {\r\ninfo->addr = sb->slave_address;\r\nif (sb->access_mode == ACPI_I2C_10BIT_MODE)\r\ninfo->flags |= I2C_CLIENT_TEN;\r\n}\r\n} else if (info->irq < 0) {\r\nstruct resource r;\r\nif (acpi_dev_resource_interrupt(ares, 0, &r))\r\ninfo->irq = r.start;\r\n}\r\nreturn 1;\r\n}\r\nstatic acpi_status acpi_i2c_add_device(acpi_handle handle, u32 level,\r\nvoid *data, void **return_value)\r\n{\r\nstruct i2c_adapter *adapter = data;\r\nstruct list_head resource_list;\r\nstruct i2c_board_info info;\r\nstruct acpi_device *adev;\r\nint ret;\r\nif (acpi_bus_get_device(handle, &adev))\r\nreturn AE_OK;\r\nif (acpi_bus_get_status(adev) || !adev->status.present)\r\nreturn AE_OK;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.acpi_node.companion = adev;\r\ninfo.irq = -1;\r\nINIT_LIST_HEAD(&resource_list);\r\nret = acpi_dev_get_resources(adev, &resource_list,\r\nacpi_i2c_add_resource, &info);\r\nacpi_dev_free_resource_list(&resource_list);\r\nif (ret < 0 || !info.addr)\r\nreturn AE_OK;\r\nadev->power.flags.ignore_parent = true;\r\nstrlcpy(info.type, dev_name(&adev->dev), sizeof(info.type));\r\nif (!i2c_new_device(adapter, &info)) {\r\nadev->power.flags.ignore_parent = false;\r\ndev_err(&adapter->dev,\r\n"failed to add I2C device %s from ACPI\n",\r\ndev_name(&adev->dev));\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic void acpi_i2c_register_devices(struct i2c_adapter *adap)\r\n{\r\nacpi_handle handle;\r\nacpi_status status;\r\nif (!adap->dev.parent)\r\nreturn;\r\nhandle = ACPI_HANDLE(adap->dev.parent);\r\nif (!handle)\r\nreturn;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,\r\nacpi_i2c_add_device, NULL,\r\nadap, NULL);\r\nif (ACPI_FAILURE(status))\r\ndev_warn(&adap->dev, "failed to enumerate I2C slaves\n");\r\n}\r\nstatic inline void acpi_i2c_register_devices(struct i2c_adapter *adap) {}\r\nstatic int i2c_do_add_adapter(struct i2c_driver *driver,\r\nstruct i2c_adapter *adap)\r\n{\r\ni2c_detect(adap, driver);\r\nif (driver->attach_adapter) {\r\ndev_warn(&adap->dev, "%s: attach_adapter method is deprecated\n",\r\ndriver->driver.name);\r\ndev_warn(&adap->dev, "Please use another way to instantiate "\r\n"your i2c_client\n");\r\ndriver->attach_adapter(adap);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __process_new_adapter(struct device_driver *d, void *data)\r\n{\r\nreturn i2c_do_add_adapter(to_i2c_driver(d), data);\r\n}\r\nstatic int i2c_register_adapter(struct i2c_adapter *adap)\r\n{\r\nint res = 0;\r\nif (unlikely(WARN_ON(!i2c_bus_type.p))) {\r\nres = -EAGAIN;\r\ngoto out_list;\r\n}\r\nif (unlikely(adap->name[0] == '\0')) {\r\npr_err("i2c-core: Attempt to register an adapter with "\r\n"no name!\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!adap->algo)) {\r\npr_err("i2c-core: Attempt to register adapter '%s' with "\r\n"no algo!\n", adap->name);\r\nreturn -EINVAL;\r\n}\r\nrt_mutex_init(&adap->bus_lock);\r\nmutex_init(&adap->userspace_clients_lock);\r\nINIT_LIST_HEAD(&adap->userspace_clients);\r\nif (adap->timeout == 0)\r\nadap->timeout = HZ;\r\ndev_set_name(&adap->dev, "i2c-%d", adap->nr);\r\nadap->dev.bus = &i2c_bus_type;\r\nadap->dev.type = &i2c_adapter_type;\r\nres = device_register(&adap->dev);\r\nif (res)\r\ngoto out_list;\r\ndev_dbg(&adap->dev, "adapter [%s] registered\n", adap->name);\r\n#ifdef CONFIG_I2C_COMPAT\r\nres = class_compat_create_link(i2c_adapter_compat_class, &adap->dev,\r\nadap->dev.parent);\r\nif (res)\r\ndev_warn(&adap->dev,\r\n"Failed to create compatibility class link\n");\r\n#endif\r\nif (adap->bus_recovery_info) {\r\nstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\r\nif (!bri->recover_bus) {\r\ndev_err(&adap->dev, "No recover_bus() found, not using recovery\n");\r\nadap->bus_recovery_info = NULL;\r\ngoto exit_recovery;\r\n}\r\nif (bri->recover_bus == i2c_generic_gpio_recovery) {\r\nif (!gpio_is_valid(bri->scl_gpio)) {\r\ndev_err(&adap->dev, "Invalid SCL gpio, not using recovery\n");\r\nadap->bus_recovery_info = NULL;\r\ngoto exit_recovery;\r\n}\r\nif (gpio_is_valid(bri->sda_gpio))\r\nbri->get_sda = get_sda_gpio_value;\r\nelse\r\nbri->get_sda = NULL;\r\nbri->get_scl = get_scl_gpio_value;\r\nbri->set_scl = set_scl_gpio_value;\r\n} else if (!bri->set_scl || !bri->get_scl) {\r\ndev_err(&adap->dev, "No {get|set}_gpio() found, not using recovery\n");\r\nadap->bus_recovery_info = NULL;\r\n}\r\n}\r\nexit_recovery:\r\nof_i2c_register_devices(adap);\r\nacpi_i2c_register_devices(adap);\r\nif (adap->nr < __i2c_first_dynamic_bus_num)\r\ni2c_scan_static_board_info(adap);\r\nmutex_lock(&core_lock);\r\nbus_for_each_drv(&i2c_bus_type, NULL, adap, __process_new_adapter);\r\nmutex_unlock(&core_lock);\r\nreturn 0;\r\nout_list:\r\nmutex_lock(&core_lock);\r\nidr_remove(&i2c_adapter_idr, adap->nr);\r\nmutex_unlock(&core_lock);\r\nreturn res;\r\n}\r\nstatic int __i2c_add_numbered_adapter(struct i2c_adapter *adap)\r\n{\r\nint id;\r\nmutex_lock(&core_lock);\r\nid = idr_alloc(&i2c_adapter_idr, adap, adap->nr, adap->nr + 1,\r\nGFP_KERNEL);\r\nmutex_unlock(&core_lock);\r\nif (id < 0)\r\nreturn id == -ENOSPC ? -EBUSY : id;\r\nreturn i2c_register_adapter(adap);\r\n}\r\nint i2c_add_adapter(struct i2c_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->dev;\r\nint id;\r\nif (dev->of_node) {\r\nid = of_alias_get_id(dev->of_node, "i2c");\r\nif (id >= 0) {\r\nadapter->nr = id;\r\nreturn __i2c_add_numbered_adapter(adapter);\r\n}\r\n}\r\nmutex_lock(&core_lock);\r\nid = idr_alloc(&i2c_adapter_idr, adapter,\r\n__i2c_first_dynamic_bus_num, 0, GFP_KERNEL);\r\nmutex_unlock(&core_lock);\r\nif (id < 0)\r\nreturn id;\r\nadapter->nr = id;\r\nreturn i2c_register_adapter(adapter);\r\n}\r\nint i2c_add_numbered_adapter(struct i2c_adapter *adap)\r\n{\r\nif (adap->nr == -1)\r\nreturn i2c_add_adapter(adap);\r\nreturn __i2c_add_numbered_adapter(adap);\r\n}\r\nstatic void i2c_do_del_adapter(struct i2c_driver *driver,\r\nstruct i2c_adapter *adapter)\r\n{\r\nstruct i2c_client *client, *_n;\r\nlist_for_each_entry_safe(client, _n, &driver->clients, detected) {\r\nif (client->adapter == adapter) {\r\ndev_dbg(&adapter->dev, "Removing %s at 0x%x\n",\r\nclient->name, client->addr);\r\nlist_del(&client->detected);\r\ni2c_unregister_device(client);\r\n}\r\n}\r\n}\r\nstatic int __unregister_client(struct device *dev, void *dummy)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nif (client && strcmp(client->name, "dummy"))\r\ni2c_unregister_device(client);\r\nreturn 0;\r\n}\r\nstatic int __unregister_dummy(struct device *dev, void *dummy)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nif (client)\r\ni2c_unregister_device(client);\r\nreturn 0;\r\n}\r\nstatic int __process_removed_adapter(struct device_driver *d, void *data)\r\n{\r\ni2c_do_del_adapter(to_i2c_driver(d), data);\r\nreturn 0;\r\n}\r\nvoid i2c_del_adapter(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_adapter *found;\r\nstruct i2c_client *client, *next;\r\nmutex_lock(&core_lock);\r\nfound = idr_find(&i2c_adapter_idr, adap->nr);\r\nmutex_unlock(&core_lock);\r\nif (found != adap) {\r\npr_debug("i2c-core: attempting to delete unregistered "\r\n"adapter [%s]\n", adap->name);\r\nreturn;\r\n}\r\nmutex_lock(&core_lock);\r\nbus_for_each_drv(&i2c_bus_type, NULL, adap,\r\n__process_removed_adapter);\r\nmutex_unlock(&core_lock);\r\nmutex_lock_nested(&adap->userspace_clients_lock,\r\ni2c_adapter_depth(adap));\r\nlist_for_each_entry_safe(client, next, &adap->userspace_clients,\r\ndetected) {\r\ndev_dbg(&adap->dev, "Removing %s at 0x%x\n", client->name,\r\nclient->addr);\r\nlist_del(&client->detected);\r\ni2c_unregister_device(client);\r\n}\r\nmutex_unlock(&adap->userspace_clients_lock);\r\ndevice_for_each_child(&adap->dev, NULL, __unregister_client);\r\ndevice_for_each_child(&adap->dev, NULL, __unregister_dummy);\r\n#ifdef CONFIG_I2C_COMPAT\r\nclass_compat_remove_link(i2c_adapter_compat_class, &adap->dev,\r\nadap->dev.parent);\r\n#endif\r\ndev_dbg(&adap->dev, "adapter [%s] unregistered\n", adap->name);\r\ninit_completion(&adap->dev_released);\r\ndevice_unregister(&adap->dev);\r\nwait_for_completion(&adap->dev_released);\r\nmutex_lock(&core_lock);\r\nidr_remove(&i2c_adapter_idr, adap->nr);\r\nmutex_unlock(&core_lock);\r\nmemset(&adap->dev, 0, sizeof(adap->dev));\r\n}\r\nint i2c_for_each_dev(void *data, int (*fn)(struct device *, void *))\r\n{\r\nint res;\r\nmutex_lock(&core_lock);\r\nres = bus_for_each_dev(&i2c_bus_type, NULL, data, fn);\r\nmutex_unlock(&core_lock);\r\nreturn res;\r\n}\r\nstatic int __process_new_driver(struct device *dev, void *data)\r\n{\r\nif (dev->type != &i2c_adapter_type)\r\nreturn 0;\r\nreturn i2c_do_add_adapter(data, to_i2c_adapter(dev));\r\n}\r\nint i2c_register_driver(struct module *owner, struct i2c_driver *driver)\r\n{\r\nint res;\r\nif (unlikely(WARN_ON(!i2c_bus_type.p)))\r\nreturn -EAGAIN;\r\ndriver->driver.owner = owner;\r\ndriver->driver.bus = &i2c_bus_type;\r\nres = driver_register(&driver->driver);\r\nif (res)\r\nreturn res;\r\nif (driver->suspend)\r\npr_warn("i2c-core: driver [%s] using legacy suspend method\n",\r\ndriver->driver.name);\r\nif (driver->resume)\r\npr_warn("i2c-core: driver [%s] using legacy resume method\n",\r\ndriver->driver.name);\r\npr_debug("i2c-core: driver [%s] registered\n", driver->driver.name);\r\nINIT_LIST_HEAD(&driver->clients);\r\ni2c_for_each_dev(driver, __process_new_driver);\r\nreturn 0;\r\n}\r\nstatic int __process_removed_driver(struct device *dev, void *data)\r\n{\r\nif (dev->type == &i2c_adapter_type)\r\ni2c_do_del_adapter(data, to_i2c_adapter(dev));\r\nreturn 0;\r\n}\r\nvoid i2c_del_driver(struct i2c_driver *driver)\r\n{\r\ni2c_for_each_dev(driver, __process_removed_driver);\r\ndriver_unregister(&driver->driver);\r\npr_debug("i2c-core: driver [%s] unregistered\n", driver->driver.name);\r\n}\r\nstruct i2c_client *i2c_use_client(struct i2c_client *client)\r\n{\r\nif (client && get_device(&client->dev))\r\nreturn client;\r\nreturn NULL;\r\n}\r\nvoid i2c_release_client(struct i2c_client *client)\r\n{\r\nif (client)\r\nput_device(&client->dev);\r\n}\r\nstatic int i2c_cmd(struct device *dev, void *_arg)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_cmd_arg *arg = _arg;\r\nstruct i2c_driver *driver;\r\nif (!client || !client->dev.driver)\r\nreturn 0;\r\ndriver = to_i2c_driver(client->dev.driver);\r\nif (driver->command)\r\ndriver->command(client, arg->cmd, arg->arg);\r\nreturn 0;\r\n}\r\nvoid i2c_clients_command(struct i2c_adapter *adap, unsigned int cmd, void *arg)\r\n{\r\nstruct i2c_cmd_arg cmd_arg;\r\ncmd_arg.cmd = cmd;\r\ncmd_arg.arg = arg;\r\ndevice_for_each_child(&adap->dev, &cmd_arg, i2c_cmd);\r\n}\r\nstatic int __init i2c_init(void)\r\n{\r\nint retval;\r\nretval = bus_register(&i2c_bus_type);\r\nif (retval)\r\nreturn retval;\r\n#ifdef CONFIG_I2C_COMPAT\r\ni2c_adapter_compat_class = class_compat_register("i2c-adapter");\r\nif (!i2c_adapter_compat_class) {\r\nretval = -ENOMEM;\r\ngoto bus_err;\r\n}\r\n#endif\r\nretval = i2c_add_driver(&dummy_driver);\r\nif (retval)\r\ngoto class_err;\r\nreturn 0;\r\nclass_err:\r\n#ifdef CONFIG_I2C_COMPAT\r\nclass_compat_unregister(i2c_adapter_compat_class);\r\nbus_err:\r\n#endif\r\nbus_unregister(&i2c_bus_type);\r\nreturn retval;\r\n}\r\nstatic void __exit i2c_exit(void)\r\n{\r\ni2c_del_driver(&dummy_driver);\r\n#ifdef CONFIG_I2C_COMPAT\r\nclass_compat_unregister(i2c_adapter_compat_class);\r\n#endif\r\nbus_unregister(&i2c_bus_type);\r\ntracepoint_synchronize_unregister();\r\n}\r\nint __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nunsigned long orig_jiffies;\r\nint ret, try;\r\nif (static_key_false(&i2c_trace_msg)) {\r\nint i;\r\nfor (i = 0; i < num; i++)\r\nif (msgs[i].flags & I2C_M_RD)\r\ntrace_i2c_read(adap, &msgs[i], i);\r\nelse\r\ntrace_i2c_write(adap, &msgs[i], i);\r\n}\r\norig_jiffies = jiffies;\r\nfor (ret = 0, try = 0; try <= adap->retries; try++) {\r\nret = adap->algo->master_xfer(adap, msgs, num);\r\nif (ret != -EAGAIN)\r\nbreak;\r\nif (time_after(jiffies, orig_jiffies + adap->timeout))\r\nbreak;\r\n}\r\nif (static_key_false(&i2c_trace_msg)) {\r\nint i;\r\nfor (i = 0; i < ret; i++)\r\nif (msgs[i].flags & I2C_M_RD)\r\ntrace_i2c_reply(adap, &msgs[i], i);\r\ntrace_i2c_result(adap, i, ret);\r\n}\r\nreturn ret;\r\n}\r\nint i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nint ret;\r\nif (adap->algo->master_xfer) {\r\n#ifdef DEBUG\r\nfor (ret = 0; ret < num; ret++) {\r\ndev_dbg(&adap->dev, "master_xfer[%d] %c, addr=0x%02x, "\r\n"len=%d%s\n", ret, (msgs[ret].flags & I2C_M_RD)\r\n? 'R' : 'W', msgs[ret].addr, msgs[ret].len,\r\n(msgs[ret].flags & I2C_M_RECV_LEN) ? "+" : "");\r\n}\r\n#endif\r\nif (in_atomic() || irqs_disabled()) {\r\nret = i2c_trylock_adapter(adap);\r\nif (!ret)\r\nreturn -EAGAIN;\r\n} else {\r\ni2c_lock_adapter(adap);\r\n}\r\nret = __i2c_transfer(adap, msgs, num);\r\ni2c_unlock_adapter(adap);\r\nreturn ret;\r\n} else {\r\ndev_dbg(&adap->dev, "I2C level transfers not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nint i2c_master_send(const struct i2c_client *client, const char *buf, int count)\r\n{\r\nint ret;\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg;\r\nmsg.addr = client->addr;\r\nmsg.flags = client->flags & I2C_M_TEN;\r\nmsg.len = count;\r\nmsg.buf = (char *)buf;\r\nret = i2c_transfer(adap, &msg, 1);\r\nreturn (ret == 1) ? count : ret;\r\n}\r\nint i2c_master_recv(const struct i2c_client *client, char *buf, int count)\r\n{\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg;\r\nint ret;\r\nmsg.addr = client->addr;\r\nmsg.flags = client->flags & I2C_M_TEN;\r\nmsg.flags |= I2C_M_RD;\r\nmsg.len = count;\r\nmsg.buf = buf;\r\nret = i2c_transfer(adap, &msg, 1);\r\nreturn (ret == 1) ? count : ret;\r\n}\r\nstatic int i2c_default_probe(struct i2c_adapter *adap, unsigned short addr)\r\n{\r\nint err;\r\nunion i2c_smbus_data dummy;\r\n#ifdef CONFIG_X86\r\nif (addr == 0x73 && (adap->class & I2C_CLASS_HWMON)\r\n&& i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE_DATA))\r\nerr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\r\nI2C_SMBUS_BYTE_DATA, &dummy);\r\nelse\r\n#endif\r\nif (!((addr & ~0x07) == 0x30 || (addr & ~0x0f) == 0x50)\r\n&& i2c_check_functionality(adap, I2C_FUNC_SMBUS_QUICK))\r\nerr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_WRITE, 0,\r\nI2C_SMBUS_QUICK, NULL);\r\nelse if (i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE))\r\nerr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\r\nI2C_SMBUS_BYTE, &dummy);\r\nelse {\r\ndev_warn(&adap->dev, "No suitable probing method supported for address 0x%02X\n",\r\naddr);\r\nerr = -EOPNOTSUPP;\r\n}\r\nreturn err >= 0;\r\n}\r\nstatic int i2c_detect_address(struct i2c_client *temp_client,\r\nstruct i2c_driver *driver)\r\n{\r\nstruct i2c_board_info info;\r\nstruct i2c_adapter *adapter = temp_client->adapter;\r\nint addr = temp_client->addr;\r\nint err;\r\nerr = i2c_check_addr_validity(addr);\r\nif (err) {\r\ndev_warn(&adapter->dev, "Invalid probe address 0x%02x\n",\r\naddr);\r\nreturn err;\r\n}\r\nif (i2c_check_addr_busy(adapter, addr))\r\nreturn 0;\r\nif (!i2c_default_probe(adapter, addr))\r\nreturn 0;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = addr;\r\nerr = driver->detect(temp_client, &info);\r\nif (err) {\r\nreturn err == -ENODEV ? 0 : err;\r\n}\r\nif (info.type[0] == '\0') {\r\ndev_err(&adapter->dev, "%s detection function provided "\r\n"no name for 0x%x\n", driver->driver.name,\r\naddr);\r\n} else {\r\nstruct i2c_client *client;\r\nif (adapter->class & I2C_CLASS_DEPRECATED)\r\ndev_warn(&adapter->dev,\r\n"This adapter will soon drop class based instantiation of devices. "\r\n"Please make sure client 0x%02x gets instantiated by other means. "\r\n"Check 'Documentation/i2c/instantiating-devices' for details.\n",\r\ninfo.addr);\r\ndev_dbg(&adapter->dev, "Creating %s at 0x%02x\n",\r\ninfo.type, info.addr);\r\nclient = i2c_new_device(adapter, &info);\r\nif (client)\r\nlist_add_tail(&client->detected, &driver->clients);\r\nelse\r\ndev_err(&adapter->dev, "Failed creating %s at 0x%02x\n",\r\ninfo.type, info.addr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver)\r\n{\r\nconst unsigned short *address_list;\r\nstruct i2c_client *temp_client;\r\nint i, err = 0;\r\nint adap_id = i2c_adapter_id(adapter);\r\naddress_list = driver->address_list;\r\nif (!driver->detect || !address_list)\r\nreturn 0;\r\nif (!(adapter->class & driver->class))\r\nreturn 0;\r\ntemp_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);\r\nif (!temp_client)\r\nreturn -ENOMEM;\r\ntemp_client->adapter = adapter;\r\nfor (i = 0; address_list[i] != I2C_CLIENT_END; i += 1) {\r\ndev_dbg(&adapter->dev, "found normal entry for adapter %d, "\r\n"addr 0x%02x\n", adap_id, address_list[i]);\r\ntemp_client->addr = address_list[i];\r\nerr = i2c_detect_address(temp_client, driver);\r\nif (unlikely(err))\r\nbreak;\r\n}\r\nkfree(temp_client);\r\nreturn err;\r\n}\r\nint i2c_probe_func_quick_read(struct i2c_adapter *adap, unsigned short addr)\r\n{\r\nreturn i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\r\nI2C_SMBUS_QUICK, NULL) >= 0;\r\n}\r\nstruct i2c_client *\r\ni2c_new_probed_device(struct i2c_adapter *adap,\r\nstruct i2c_board_info *info,\r\nunsigned short const *addr_list,\r\nint (*probe)(struct i2c_adapter *, unsigned short addr))\r\n{\r\nint i;\r\nif (!probe)\r\nprobe = i2c_default_probe;\r\nfor (i = 0; addr_list[i] != I2C_CLIENT_END; i++) {\r\nif (i2c_check_addr_validity(addr_list[i]) < 0) {\r\ndev_warn(&adap->dev, "Invalid 7-bit address "\r\n"0x%02x\n", addr_list[i]);\r\ncontinue;\r\n}\r\nif (i2c_check_addr_busy(adap, addr_list[i])) {\r\ndev_dbg(&adap->dev, "Address 0x%02x already in "\r\n"use, not probing\n", addr_list[i]);\r\ncontinue;\r\n}\r\nif (probe(adap, addr_list[i]))\r\nbreak;\r\n}\r\nif (addr_list[i] == I2C_CLIENT_END) {\r\ndev_dbg(&adap->dev, "Probing failed, no device found\n");\r\nreturn NULL;\r\n}\r\ninfo->addr = addr_list[i];\r\nreturn i2c_new_device(adap, info);\r\n}\r\nstruct i2c_adapter *i2c_get_adapter(int nr)\r\n{\r\nstruct i2c_adapter *adapter;\r\nmutex_lock(&core_lock);\r\nadapter = idr_find(&i2c_adapter_idr, nr);\r\nif (adapter && !try_module_get(adapter->owner))\r\nadapter = NULL;\r\nmutex_unlock(&core_lock);\r\nreturn adapter;\r\n}\r\nvoid i2c_put_adapter(struct i2c_adapter *adap)\r\n{\r\nif (adap)\r\nmodule_put(adap->owner);\r\n}\r\nstatic u8 crc8(u16 data)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nif (data & 0x8000)\r\ndata = data ^ POLY;\r\ndata = data << 1;\r\n}\r\nreturn (u8)(data >> 8);\r\n}\r\nstatic u8 i2c_smbus_pec(u8 crc, u8 *p, size_t count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\ncrc = crc8((crc ^ p[i]) << 8);\r\nreturn crc;\r\n}\r\nstatic u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg)\r\n{\r\nu8 addr = (msg->addr << 1) | !!(msg->flags & I2C_M_RD);\r\npec = i2c_smbus_pec(pec, &addr, 1);\r\nreturn i2c_smbus_pec(pec, msg->buf, msg->len);\r\n}\r\nstatic inline void i2c_smbus_add_pec(struct i2c_msg *msg)\r\n{\r\nmsg->buf[msg->len] = i2c_smbus_msg_pec(0, msg);\r\nmsg->len++;\r\n}\r\nstatic int i2c_smbus_check_pec(u8 cpec, struct i2c_msg *msg)\r\n{\r\nu8 rpec = msg->buf[--msg->len];\r\ncpec = i2c_smbus_msg_pec(cpec, msg);\r\nif (rpec != cpec) {\r\npr_debug("i2c-core: Bad PEC 0x%02x vs. 0x%02x\n",\r\nrpec, cpec);\r\nreturn -EBADMSG;\r\n}\r\nreturn 0;\r\n}\r\ns32 i2c_smbus_read_byte(const struct i2c_client *client)\r\n{\r\nunion i2c_smbus_data data;\r\nint status;\r\nstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, 0,\r\nI2C_SMBUS_BYTE, &data);\r\nreturn (status < 0) ? status : data.byte;\r\n}\r\ns32 i2c_smbus_write_byte(const struct i2c_client *client, u8 value)\r\n{\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);\r\n}\r\ns32 i2c_smbus_read_byte_data(const struct i2c_client *client, u8 command)\r\n{\r\nunion i2c_smbus_data data;\r\nint status;\r\nstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_BYTE_DATA, &data);\r\nreturn (status < 0) ? status : data.byte;\r\n}\r\ns32 i2c_smbus_write_byte_data(const struct i2c_client *client, u8 command,\r\nu8 value)\r\n{\r\nunion i2c_smbus_data data;\r\ndata.byte = value;\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_BYTE_DATA, &data);\r\n}\r\ns32 i2c_smbus_read_word_data(const struct i2c_client *client, u8 command)\r\n{\r\nunion i2c_smbus_data data;\r\nint status;\r\nstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_WORD_DATA, &data);\r\nreturn (status < 0) ? status : data.word;\r\n}\r\ns32 i2c_smbus_write_word_data(const struct i2c_client *client, u8 command,\r\nu16 value)\r\n{\r\nunion i2c_smbus_data data;\r\ndata.word = value;\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_WORD_DATA, &data);\r\n}\r\ns32 i2c_smbus_read_block_data(const struct i2c_client *client, u8 command,\r\nu8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nint status;\r\nstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_BLOCK_DATA, &data);\r\nif (status)\r\nreturn status;\r\nmemcpy(values, &data.block[1], data.block[0]);\r\nreturn data.block[0];\r\n}\r\ns32 i2c_smbus_write_block_data(const struct i2c_client *client, u8 command,\r\nu8 length, const u8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\ndata.block[0] = length;\r\nmemcpy(&data.block[1], values, length);\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_BLOCK_DATA, &data);\r\n}\r\ns32 i2c_smbus_read_i2c_block_data(const struct i2c_client *client, u8 command,\r\nu8 length, u8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nint status;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\ndata.block[0] = length;\r\nstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_I2C_BLOCK_DATA, &data);\r\nif (status < 0)\r\nreturn status;\r\nmemcpy(values, &data.block[1], data.block[0]);\r\nreturn data.block[0];\r\n}\r\ns32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client, u8 command,\r\nu8 length, const u8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\ndata.block[0] = length;\r\nmemcpy(data.block + 1, values, length);\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_I2C_BLOCK_DATA, &data);\r\n}\r\nstatic s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,\r\nunsigned short flags,\r\nchar read_write, u8 command, int size,\r\nunion i2c_smbus_data *data)\r\n{\r\nunsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];\r\nunsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];\r\nint num = read_write == I2C_SMBUS_READ ? 2 : 1;\r\nint i;\r\nu8 partial_pec = 0;\r\nint status;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = addr,\r\n.flags = flags,\r\n.len = 1,\r\n.buf = msgbuf0,\r\n}, {\r\n.addr = addr,\r\n.flags = flags | I2C_M_RD,\r\n.len = 0,\r\n.buf = msgbuf1,\r\n},\r\n};\r\nmsgbuf0[0] = command;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nmsg[0].len = 0;\r\nmsg[0].flags = flags | (read_write == I2C_SMBUS_READ ?\r\nI2C_M_RD : 0);\r\nnum = 1;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nif (read_write == I2C_SMBUS_READ) {\r\nmsg[0].flags = I2C_M_RD | flags;\r\nnum = 1;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nif (read_write == I2C_SMBUS_READ)\r\nmsg[1].len = 1;\r\nelse {\r\nmsg[0].len = 2;\r\nmsgbuf0[1] = data->byte;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nif (read_write == I2C_SMBUS_READ)\r\nmsg[1].len = 2;\r\nelse {\r\nmsg[0].len = 3;\r\nmsgbuf0[1] = data->word & 0xff;\r\nmsgbuf0[2] = data->word >> 8;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_PROC_CALL:\r\nnum = 2;\r\nread_write = I2C_SMBUS_READ;\r\nmsg[0].len = 3;\r\nmsg[1].len = 2;\r\nmsgbuf0[1] = data->word & 0xff;\r\nmsgbuf0[2] = data->word >> 8;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nif (read_write == I2C_SMBUS_READ) {\r\nmsg[1].flags |= I2C_M_RECV_LEN;\r\nmsg[1].len = 1;\r\n} else {\r\nmsg[0].len = data->block[0] + 2;\r\nif (msg[0].len > I2C_SMBUS_BLOCK_MAX + 2) {\r\ndev_err(&adapter->dev,\r\n"Invalid block write size %d\n",\r\ndata->block[0]);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 1; i < msg[0].len; i++)\r\nmsgbuf0[i] = data->block[i-1];\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_PROC_CALL:\r\nnum = 2;\r\nread_write = I2C_SMBUS_READ;\r\nif (data->block[0] > I2C_SMBUS_BLOCK_MAX) {\r\ndev_err(&adapter->dev,\r\n"Invalid block write size %d\n",\r\ndata->block[0]);\r\nreturn -EINVAL;\r\n}\r\nmsg[0].len = data->block[0] + 2;\r\nfor (i = 1; i < msg[0].len; i++)\r\nmsgbuf0[i] = data->block[i-1];\r\nmsg[1].flags |= I2C_M_RECV_LEN;\r\nmsg[1].len = 1;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nif (read_write == I2C_SMBUS_READ) {\r\nmsg[1].len = data->block[0];\r\n} else {\r\nmsg[0].len = data->block[0] + 1;\r\nif (msg[0].len > I2C_SMBUS_BLOCK_MAX + 1) {\r\ndev_err(&adapter->dev,\r\n"Invalid block write size %d\n",\r\ndata->block[0]);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 1; i <= data->block[0]; i++)\r\nmsgbuf0[i] = data->block[i];\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&adapter->dev, "Unsupported transaction %d\n", size);\r\nreturn -EOPNOTSUPP;\r\n}\r\ni = ((flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK\r\n&& size != I2C_SMBUS_I2C_BLOCK_DATA);\r\nif (i) {\r\nif (!(msg[0].flags & I2C_M_RD)) {\r\nif (num == 1)\r\ni2c_smbus_add_pec(&msg[0]);\r\nelse\r\npartial_pec = i2c_smbus_msg_pec(0, &msg[0]);\r\n}\r\nif (msg[num-1].flags & I2C_M_RD)\r\nmsg[num-1].len++;\r\n}\r\nstatus = i2c_transfer(adapter, msg, num);\r\nif (status < 0)\r\nreturn status;\r\nif (i && (msg[num-1].flags & I2C_M_RD)) {\r\nstatus = i2c_smbus_check_pec(partial_pec, &msg[num-1]);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nif (read_write == I2C_SMBUS_READ)\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\ndata->byte = msgbuf0[0];\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\ndata->byte = msgbuf1[0];\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\ncase I2C_SMBUS_PROC_CALL:\r\ndata->word = msgbuf1[0] | (msgbuf1[1] << 8);\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nfor (i = 0; i < data->block[0]; i++)\r\ndata->block[i+1] = msgbuf1[i];\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\ncase I2C_SMBUS_BLOCK_PROC_CALL:\r\nfor (i = 0; i < msgbuf1[0] + 1; i++)\r\ndata->block[i] = msgbuf1[i];\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\ns32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,\r\nchar read_write, u8 command, int protocol,\r\nunion i2c_smbus_data *data)\r\n{\r\nunsigned long orig_jiffies;\r\nint try;\r\ns32 res;\r\ntrace_smbus_write(adapter, addr, flags, read_write,\r\ncommand, protocol, data);\r\ntrace_smbus_read(adapter, addr, flags, read_write,\r\ncommand, protocol);\r\nflags &= I2C_M_TEN | I2C_CLIENT_PEC | I2C_CLIENT_SCCB;\r\nif (adapter->algo->smbus_xfer) {\r\ni2c_lock_adapter(adapter);\r\norig_jiffies = jiffies;\r\nfor (res = 0, try = 0; try <= adapter->retries; try++) {\r\nres = adapter->algo->smbus_xfer(adapter, addr, flags,\r\nread_write, command,\r\nprotocol, data);\r\nif (res != -EAGAIN)\r\nbreak;\r\nif (time_after(jiffies,\r\norig_jiffies + adapter->timeout))\r\nbreak;\r\n}\r\ni2c_unlock_adapter(adapter);\r\nif (res != -EOPNOTSUPP || !adapter->algo->master_xfer)\r\ngoto trace;\r\n}\r\nres = i2c_smbus_xfer_emulated(adapter, addr, flags, read_write,\r\ncommand, protocol, data);\r\ntrace:\r\ntrace_smbus_reply(adapter, addr, flags, read_write,\r\ncommand, protocol, data);\r\ntrace_smbus_result(adapter, addr, flags, read_write,\r\ncommand, protocol, res);\r\nreturn res;\r\n}
