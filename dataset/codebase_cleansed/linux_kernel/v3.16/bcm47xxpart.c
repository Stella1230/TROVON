static void bcm47xxpart_add_part(struct mtd_partition *part, char *name,\r\nu64 offset, uint32_t mask_flags)\r\n{\r\npart->name = name;\r\npart->offset = offset;\r\npart->mask_flags = mask_flags;\r\n}\r\nstatic int bcm47xxpart_parse(struct mtd_info *master,\r\nstruct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct mtd_partition *parts;\r\nuint8_t i, curr_part = 0;\r\nuint32_t *buf;\r\nsize_t bytes_read;\r\nuint32_t offset;\r\nuint32_t blocksize = master->erasesize;\r\nstruct trx_header *trx;\r\nint trx_part = -1;\r\nint last_trx_part = -1;\r\nint possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };\r\nif (blocksize <= 0x10000)\r\nblocksize = 0x10000;\r\nparts = kzalloc(sizeof(struct mtd_partition) * BCM47XXPART_MAX_PARTS,\r\nGFP_KERNEL);\r\nif (!parts)\r\nreturn -ENOMEM;\r\nbuf = kzalloc(BCM47XXPART_BYTES_TO_READ, GFP_KERNEL);\r\nif (!buf) {\r\nkfree(parts);\r\nreturn -ENOMEM;\r\n}\r\nfor (offset = 0; offset <= master->size - blocksize;\r\noffset += blocksize) {\r\nif (offset >= 0x2000000)\r\nbreak;\r\nif (curr_part >= BCM47XXPART_MAX_PARTS) {\r\npr_warn("Reached maximum number of partitions, scanning stopped!\n");\r\nbreak;\r\n}\r\nif (mtd_read(master, offset, BCM47XXPART_BYTES_TO_READ,\r\n&bytes_read, (uint8_t *)buf) < 0) {\r\npr_err("mtd_read error while parsing (offset: 0x%X)!\n",\r\noffset);\r\ncontinue;\r\n}\r\nif ((buf[0x4e0 / 4] == CFE_MAGIC && buf[0x4e4 / 4] == CFE_MAGIC) ||\r\n(buf[0x400 / 4] == NVRAM_HEADER)) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "boot",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x100 / 4] == BOARD_DATA_MAGIC) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "board_data",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == FACTORY_MAGIC) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "factory",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == POT_MAGIC1 &&\r\n(buf[0x004 / 4] & 0xFFFF) == POT_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "POT", offset,\r\nMTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x010 / 4] == ML_MAGIC1 &&\r\nbuf[0x014 / 4] == ML_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "ML", offset,\r\nMTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == TRX_MAGIC) {\r\nif (BCM47XXPART_MAX_PARTS - curr_part < 4) {\r\npr_warn("Not enough partitions left to register trx, scanning stopped!\n");\r\nbreak;\r\n}\r\ntrx = (struct trx_header *)buf;\r\ntrx_part = curr_part;\r\nbcm47xxpart_add_part(&parts[curr_part++], "firmware",\r\noffset, 0);\r\ni = 0;\r\nif (trx->offset[2]) {\r\nbcm47xxpart_add_part(&parts[curr_part++],\r\n"loader",\r\noffset + trx->offset[i],\r\n0);\r\ni++;\r\n}\r\nbcm47xxpart_add_part(&parts[curr_part++], "linux",\r\noffset + trx->offset[i], 0);\r\ni++;\r\nbcm47xxpart_add_part(&parts[curr_part++], "rootfs",\r\noffset + trx->offset[i], 0);\r\ni++;\r\nlast_trx_part = curr_part - 1;\r\noffset = rounddown(offset + trx->length, blocksize);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == SQSH_MAGIC) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "rootfs",\r\noffset, 0);\r\ncontinue;\r\n}\r\nif (mtd_read(master, offset + 0x8000, 0x4,\r\n&bytes_read, (uint8_t *)buf) < 0) {\r\npr_err("mtd_read error while parsing (offset: 0x%X)!\n",\r\noffset);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == BOARD_DATA_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "board_data",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(possible_nvram_sizes); i++) {\r\nif (curr_part >= BCM47XXPART_MAX_PARTS) {\r\npr_warn("Reached maximum number of partitions, scanning stopped!\n");\r\nbreak;\r\n}\r\noffset = master->size - possible_nvram_sizes[i];\r\nif (mtd_read(master, offset, 0x4, &bytes_read,\r\n(uint8_t *)buf) < 0) {\r\npr_err("mtd_read error while reading at offset 0x%X!\n",\r\noffset);\r\ncontinue;\r\n}\r\nif (buf[0] == NVRAM_HEADER) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "nvram",\r\nmaster->size - blocksize, 0);\r\nbreak;\r\n}\r\n}\r\nkfree(buf);\r\nfor (i = 0; i < curr_part; i++) {\r\nu64 next_part_offset = (i < curr_part - 1) ?\r\nparts[i + 1].offset : master->size;\r\nparts[i].size = next_part_offset - parts[i].offset;\r\nif (i == last_trx_part && trx_part >= 0)\r\nparts[trx_part].size = next_part_offset -\r\nparts[trx_part].offset;\r\n}\r\n*pparts = parts;\r\nreturn curr_part;\r\n}\r\nstatic int __init bcm47xxpart_init(void)\r\n{\r\nregister_mtd_parser(&bcm47xxpart_mtd_parser);\r\nreturn 0;\r\n}\r\nstatic void __exit bcm47xxpart_exit(void)\r\n{\r\nderegister_mtd_parser(&bcm47xxpart_mtd_parser);\r\n}
