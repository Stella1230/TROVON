static int\r\nmwifiex_cmd_append_generic_ie(struct mwifiex_private *priv, u8 **buffer)\r\n{\r\nint ret_len = 0;\r\nstruct mwifiex_ie_types_header ie_header;\r\nif (!buffer)\r\nreturn 0;\r\nif (!(*buffer))\r\nreturn 0;\r\nif (priv->gen_ie_buf_len) {\r\ndev_dbg(priv->adapter->dev,\r\n"info: %s: append generic ie len %d to %p\n",\r\n__func__, priv->gen_ie_buf_len, *buffer);\r\nie_header.type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);\r\nie_header.len = cpu_to_le16(priv->gen_ie_buf_len);\r\nmemcpy(*buffer, &ie_header, sizeof(ie_header));\r\n*buffer += sizeof(ie_header);\r\nret_len += sizeof(ie_header);\r\nmemcpy(*buffer, priv->gen_ie_buf, priv->gen_ie_buf_len);\r\n*buffer += priv->gen_ie_buf_len;\r\nret_len += priv->gen_ie_buf_len;\r\npriv->gen_ie_buf_len = 0;\r\n}\r\nreturn ret_len;\r\n}\r\nstatic int\r\nmwifiex_cmd_append_tsf_tlv(struct mwifiex_private *priv, u8 **buffer,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nstruct mwifiex_ie_types_tsf_timestamp tsf_tlv;\r\n__le64 tsf_val;\r\nif (buffer == NULL)\r\nreturn 0;\r\nif (*buffer == NULL)\r\nreturn 0;\r\nmemset(&tsf_tlv, 0x00, sizeof(struct mwifiex_ie_types_tsf_timestamp));\r\ntsf_tlv.header.type = cpu_to_le16(TLV_TYPE_TSFTIMESTAMP);\r\ntsf_tlv.header.len = cpu_to_le16(2 * sizeof(tsf_val));\r\nmemcpy(*buffer, &tsf_tlv, sizeof(tsf_tlv.header));\r\n*buffer += sizeof(tsf_tlv.header);\r\ntsf_val = cpu_to_le64(bss_desc->fw_tsf);\r\nmemcpy(*buffer, &tsf_val, sizeof(tsf_val));\r\n*buffer += sizeof(tsf_val);\r\ntsf_val = cpu_to_le64(bss_desc->timestamp);\r\ndev_dbg(priv->adapter->dev,\r\n"info: %s: TSF offset calc: %016llx - %016llx\n",\r\n__func__, bss_desc->timestamp, bss_desc->fw_tsf);\r\nmemcpy(*buffer, &tsf_val, sizeof(tsf_val));\r\n*buffer += sizeof(tsf_val);\r\nreturn sizeof(tsf_tlv.header) + (2 * sizeof(tsf_val));\r\n}\r\nstatic int mwifiex_get_common_rates(struct mwifiex_private *priv, u8 *rate1,\r\nu32 rate1_size, u8 *rate2, u32 rate2_size)\r\n{\r\nint ret;\r\nu8 *ptr = rate1, *tmp;\r\nu32 i, j;\r\ntmp = kmemdup(rate1, rate1_size, GFP_KERNEL);\r\nif (!tmp) {\r\ndev_err(priv->adapter->dev, "failed to alloc tmp buf\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(rate1, 0, rate1_size);\r\nfor (i = 0; i < rate2_size && rate2[i]; i++) {\r\nfor (j = 0; j < rate1_size && tmp[j]; j++) {\r\nif ((rate2[i] & 0x7F) == (tmp[j] & 0x7F)) {\r\n*rate1++ = tmp[j];\r\nbreak;\r\n}\r\n}\r\n}\r\ndev_dbg(priv->adapter->dev, "info: Tx data rate set to %#x\n",\r\npriv->data_rate);\r\nif (!priv->is_data_rate_auto) {\r\nwhile (*ptr) {\r\nif ((*ptr & 0x7f) == priv->data_rate) {\r\nret = 0;\r\ngoto done;\r\n}\r\nptr++;\r\n}\r\ndev_err(priv->adapter->dev, "previously set fixed data rate %#x"\r\n" is not compatible with the network\n",\r\npriv->data_rate);\r\nret = -1;\r\ngoto done;\r\n}\r\nret = 0;\r\ndone:\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic int\r\nmwifiex_setup_rates_from_bssdesc(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc,\r\nu8 *out_rates, u32 *out_rates_size)\r\n{\r\nu8 card_rates[MWIFIEX_SUPPORTED_RATES];\r\nu32 card_rates_size;\r\nmemcpy(out_rates, bss_desc->supported_rates, MWIFIEX_SUPPORTED_RATES);\r\ncard_rates_size = mwifiex_get_active_data_rates(priv, card_rates);\r\nif (mwifiex_get_common_rates(priv, out_rates, MWIFIEX_SUPPORTED_RATES,\r\ncard_rates, card_rates_size)) {\r\n*out_rates_size = 0;\r\ndev_err(priv->adapter->dev, "%s: cannot get common rates\n",\r\n__func__);\r\nreturn -1;\r\n}\r\n*out_rates_size =\r\nmin_t(size_t, strlen(out_rates), MWIFIEX_SUPPORTED_RATES);\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_append_wps_ie(struct mwifiex_private *priv, u8 **buffer)\r\n{\r\nint retLen = 0;\r\nstruct mwifiex_ie_types_header ie_header;\r\nif (!buffer || !*buffer)\r\nreturn 0;\r\nif (priv->wps_ie_len) {\r\ndev_dbg(priv->adapter->dev, "cmd: append wps ie %d to %p\n",\r\npriv->wps_ie_len, *buffer);\r\nie_header.type = cpu_to_le16(TLV_TYPE_MGMT_IE);\r\nie_header.len = cpu_to_le16(priv->wps_ie_len);\r\nmemcpy(*buffer, &ie_header, sizeof(ie_header));\r\n*buffer += sizeof(ie_header);\r\nretLen += sizeof(ie_header);\r\nmemcpy(*buffer, priv->wps_ie, priv->wps_ie_len);\r\n*buffer += priv->wps_ie_len;\r\nretLen += priv->wps_ie_len;\r\n}\r\nkfree(priv->wps_ie);\r\npriv->wps_ie_len = 0;\r\nreturn retLen;\r\n}\r\nstatic int\r\nmwifiex_cmd_append_wapi_ie(struct mwifiex_private *priv, u8 **buffer)\r\n{\r\nint retLen = 0;\r\nstruct mwifiex_ie_types_header ie_header;\r\nif (buffer == NULL)\r\nreturn 0;\r\nif (*buffer == NULL)\r\nreturn 0;\r\nif (priv->wapi_ie_len) {\r\ndev_dbg(priv->adapter->dev, "cmd: append wapi ie %d to %p\n",\r\npriv->wapi_ie_len, *buffer);\r\nie_header.type = cpu_to_le16(TLV_TYPE_WAPI_IE);\r\nie_header.len = cpu_to_le16(priv->wapi_ie_len);\r\nmemcpy(*buffer, &ie_header, sizeof(ie_header));\r\n*buffer += sizeof(ie_header);\r\nretLen += sizeof(ie_header);\r\nmemcpy(*buffer, priv->wapi_ie, priv->wapi_ie_len);\r\n*buffer += priv->wapi_ie_len;\r\nretLen += priv->wapi_ie_len;\r\n}\r\nreturn retLen;\r\n}\r\nstatic int mwifiex_append_rsn_ie_wpa_wpa2(struct mwifiex_private *priv,\r\nu8 **buffer)\r\n{\r\nstruct mwifiex_ie_types_rsn_param_set *rsn_ie_tlv;\r\nint rsn_ie_len;\r\nif (!buffer || !(*buffer))\r\nreturn 0;\r\nrsn_ie_tlv = (struct mwifiex_ie_types_rsn_param_set *) (*buffer);\r\nrsn_ie_tlv->header.type = cpu_to_le16((u16) priv->wpa_ie[0]);\r\nrsn_ie_tlv->header.type = cpu_to_le16(\r\nle16_to_cpu(rsn_ie_tlv->header.type) & 0x00FF);\r\nrsn_ie_tlv->header.len = cpu_to_le16((u16) priv->wpa_ie[1]);\r\nrsn_ie_tlv->header.len = cpu_to_le16(le16_to_cpu(rsn_ie_tlv->header.len)\r\n& 0x00FF);\r\nif (le16_to_cpu(rsn_ie_tlv->header.len) <= (sizeof(priv->wpa_ie) - 2))\r\nmemcpy(rsn_ie_tlv->rsn_ie, &priv->wpa_ie[2],\r\nle16_to_cpu(rsn_ie_tlv->header.len));\r\nelse\r\nreturn -1;\r\nrsn_ie_len = sizeof(rsn_ie_tlv->header) +\r\nle16_to_cpu(rsn_ie_tlv->header.len);\r\n*buffer += rsn_ie_len;\r\nreturn rsn_ie_len;\r\n}\r\nint mwifiex_cmd_802_11_associate(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nstruct host_cmd_ds_802_11_associate *assoc = &cmd->params.associate;\r\nstruct mwifiex_ie_types_ssid_param_set *ssid_tlv;\r\nstruct mwifiex_ie_types_phy_param_set *phy_tlv;\r\nstruct mwifiex_ie_types_ss_param_set *ss_tlv;\r\nstruct mwifiex_ie_types_rates_param_set *rates_tlv;\r\nstruct mwifiex_ie_types_auth_type *auth_tlv;\r\nstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\r\nu8 rates[MWIFIEX_SUPPORTED_RATES];\r\nu32 rates_size;\r\nu16 tmp_cap;\r\nu8 *pos;\r\nint rsn_ie_len = 0;\r\npos = (u8 *) assoc;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_ASSOCIATE);\r\npriv->attempted_bss_desc = bss_desc;\r\nmemcpy(assoc->peer_sta_addr,\r\nbss_desc->mac_address, sizeof(assoc->peer_sta_addr));\r\npos += sizeof(assoc->peer_sta_addr);\r\nassoc->listen_interval = cpu_to_le16(priv->listen_interval);\r\nassoc->beacon_period = cpu_to_le16(bss_desc->beacon_period);\r\npos += sizeof(assoc->cap_info_bitmap);\r\npos += sizeof(assoc->listen_interval);\r\npos += sizeof(assoc->beacon_period);\r\npos += sizeof(assoc->dtim_period);\r\nssid_tlv = (struct mwifiex_ie_types_ssid_param_set *) pos;\r\nssid_tlv->header.type = cpu_to_le16(WLAN_EID_SSID);\r\nssid_tlv->header.len = cpu_to_le16((u16) bss_desc->ssid.ssid_len);\r\nmemcpy(ssid_tlv->ssid, bss_desc->ssid.ssid,\r\nle16_to_cpu(ssid_tlv->header.len));\r\npos += sizeof(ssid_tlv->header) + le16_to_cpu(ssid_tlv->header.len);\r\nphy_tlv = (struct mwifiex_ie_types_phy_param_set *) pos;\r\nphy_tlv->header.type = cpu_to_le16(WLAN_EID_DS_PARAMS);\r\nphy_tlv->header.len = cpu_to_le16(sizeof(phy_tlv->fh_ds.ds_param_set));\r\nmemcpy(&phy_tlv->fh_ds.ds_param_set,\r\n&bss_desc->phy_param_set.ds_param_set.current_chan,\r\nsizeof(phy_tlv->fh_ds.ds_param_set));\r\npos += sizeof(phy_tlv->header) + le16_to_cpu(phy_tlv->header.len);\r\nss_tlv = (struct mwifiex_ie_types_ss_param_set *) pos;\r\nss_tlv->header.type = cpu_to_le16(WLAN_EID_CF_PARAMS);\r\nss_tlv->header.len = cpu_to_le16(sizeof(ss_tlv->cf_ibss.cf_param_set));\r\npos += sizeof(ss_tlv->header) + le16_to_cpu(ss_tlv->header.len);\r\nif (mwifiex_setup_rates_from_bssdesc\r\n(priv, bss_desc, rates, &rates_size))\r\nreturn -1;\r\npriv->curr_bss_params.num_of_rates = rates_size;\r\nmemcpy(&priv->curr_bss_params.data_rates, rates, rates_size);\r\nrates_tlv = (struct mwifiex_ie_types_rates_param_set *) pos;\r\nrates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);\r\nrates_tlv->header.len = cpu_to_le16((u16) rates_size);\r\nmemcpy(rates_tlv->rates, rates, rates_size);\r\npos += sizeof(rates_tlv->header) + rates_size;\r\ndev_dbg(priv->adapter->dev, "info: ASSOC_CMD: rates size = %d\n",\r\nrates_size);\r\nauth_tlv = (struct mwifiex_ie_types_auth_type *) pos;\r\nauth_tlv->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);\r\nauth_tlv->header.len = cpu_to_le16(sizeof(auth_tlv->auth_type));\r\nif (priv->sec_info.wep_enabled)\r\nauth_tlv->auth_type = cpu_to_le16(\r\n(u16) priv->sec_info.authentication_mode);\r\nelse\r\nauth_tlv->auth_type = cpu_to_le16(NL80211_AUTHTYPE_OPEN_SYSTEM);\r\npos += sizeof(auth_tlv->header) + le16_to_cpu(auth_tlv->header.len);\r\nif (IS_SUPPORT_MULTI_BANDS(priv->adapter) &&\r\n!(ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\r\n(!bss_desc->disable_11n) &&\r\n(priv->adapter->config_bands & BAND_GN ||\r\npriv->adapter->config_bands & BAND_AN) &&\r\n(bss_desc->bcn_ht_cap)\r\n)\r\n) {\r\nchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\r\nchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\r\nchan_tlv->header.len =\r\ncpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\r\nmemset(chan_tlv->chan_scan_param, 0x00,\r\nsizeof(struct mwifiex_chan_scan_param_set));\r\nchan_tlv->chan_scan_param[0].chan_number =\r\n(bss_desc->phy_param_set.ds_param_set.current_chan);\r\ndev_dbg(priv->adapter->dev, "info: Assoc: TLV Chan = %d\n",\r\nchan_tlv->chan_scan_param[0].chan_number);\r\nchan_tlv->chan_scan_param[0].radio_type =\r\nmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\r\ndev_dbg(priv->adapter->dev, "info: Assoc: TLV Band = %d\n",\r\nchan_tlv->chan_scan_param[0].radio_type);\r\npos += sizeof(chan_tlv->header) +\r\nsizeof(struct mwifiex_chan_scan_param_set);\r\n}\r\nif (!priv->wps.session_enable) {\r\nif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\r\nrsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\r\nif (rsn_ie_len == -1)\r\nreturn -1;\r\n}\r\nif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\r\n(!bss_desc->disable_11n) &&\r\n(priv->adapter->config_bands & BAND_GN ||\r\npriv->adapter->config_bands & BAND_AN))\r\nmwifiex_cmd_append_11n_tlv(priv, bss_desc, &pos);\r\nif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\r\n!bss_desc->disable_11n && !bss_desc->disable_11ac &&\r\npriv->adapter->config_bands & BAND_AAC)\r\nmwifiex_cmd_append_11ac_tlv(priv, bss_desc, &pos);\r\nmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_ASSOC, &pos);\r\nmwifiex_wmm_process_association_req(priv, &pos, &bss_desc->wmm_ie,\r\nbss_desc->bcn_ht_cap);\r\nif (priv->sec_info.wapi_enabled && priv->wapi_ie_len)\r\nmwifiex_cmd_append_wapi_ie(priv, &pos);\r\nif (priv->wps.session_enable && priv->wps_ie_len)\r\nmwifiex_cmd_append_wps_ie(priv, &pos);\r\nmwifiex_cmd_append_generic_ie(priv, &pos);\r\nmwifiex_cmd_append_tsf_tlv(priv, &pos, bss_desc);\r\nmwifiex_11h_process_join(priv, &pos, bss_desc);\r\ncmd->size = cpu_to_le16((u16) (pos - (u8 *) assoc) + S_DS_GEN);\r\ntmp_cap = bss_desc->cap_info_bitmap;\r\nif (priv->adapter->config_bands == BAND_B)\r\ntmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\r\ntmp_cap &= CAPINFO_MASK;\r\ndev_dbg(priv->adapter->dev, "info: ASSOC_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\n",\r\ntmp_cap, CAPINFO_MASK);\r\nassoc->cap_info_bitmap = cpu_to_le16(tmp_cap);\r\nreturn 0;\r\n}\r\nint mwifiex_ret_802_11_associate(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret = 0;\r\nstruct ieee_types_assoc_rsp *assoc_rsp;\r\nstruct mwifiex_bssdescriptor *bss_desc;\r\nbool enable_data = true;\r\nu16 cap_info, status_code;\r\nassoc_rsp = (struct ieee_types_assoc_rsp *) &resp->params;\r\ncap_info = le16_to_cpu(assoc_rsp->cap_info_bitmap);\r\nstatus_code = le16_to_cpu(assoc_rsp->status_code);\r\npriv->assoc_rsp_size = min(le16_to_cpu(resp->size) - S_DS_GEN,\r\nsizeof(priv->assoc_rsp_buf));\r\nmemcpy(priv->assoc_rsp_buf, &resp->params, priv->assoc_rsp_size);\r\nif (status_code) {\r\npriv->adapter->dbg.num_cmd_assoc_failure++;\r\ndev_err(priv->adapter->dev,\r\n"ASSOC_RESP: failed, status code=%d err=%#x a_id=%#x\n",\r\nstatus_code, cap_info, le16_to_cpu(assoc_rsp->a_id));\r\nif (cap_info == MWIFIEX_TIMEOUT_FOR_AP_RESP) {\r\nif (status_code == MWIFIEX_STATUS_CODE_AUTH_TIMEOUT)\r\nret = WLAN_STATUS_AUTH_TIMEOUT;\r\nelse\r\nret = WLAN_STATUS_UNSPECIFIED_FAILURE;\r\n} else {\r\nret = status_code;\r\n}\r\ngoto done;\r\n}\r\npriv->media_connected = true;\r\npriv->adapter->ps_state = PS_STATE_AWAKE;\r\npriv->adapter->pps_uapsd_mode = false;\r\npriv->adapter->tx_lock_flag = false;\r\nbss_desc = priv->attempted_bss_desc;\r\ndev_dbg(priv->adapter->dev, "info: ASSOC_RESP: %s\n",\r\nbss_desc->ssid.ssid);\r\nmemcpy(&priv->curr_bss_params.bss_descriptor,\r\nbss_desc, sizeof(struct mwifiex_bssdescriptor));\r\npriv->curr_bss_params.bss_descriptor.channel\r\n= bss_desc->phy_param_set.ds_param_set.current_chan;\r\npriv->curr_bss_params.band = (u8) bss_desc->bss_band;\r\nif (bss_desc->wmm_ie.vend_hdr.element_id == WLAN_EID_VENDOR_SPECIFIC)\r\npriv->curr_bss_params.wmm_enabled = true;\r\nelse\r\npriv->curr_bss_params.wmm_enabled = false;\r\nif ((priv->wmm_required || bss_desc->bcn_ht_cap) &&\r\npriv->curr_bss_params.wmm_enabled)\r\npriv->wmm_enabled = true;\r\nelse\r\npriv->wmm_enabled = false;\r\npriv->curr_bss_params.wmm_uapsd_enabled = false;\r\nif (priv->wmm_enabled)\r\npriv->curr_bss_params.wmm_uapsd_enabled\r\n= ((bss_desc->wmm_ie.qos_info_bitmap &\r\nIEEE80211_WMM_IE_AP_QOSINFO_UAPSD) ? 1 : 0);\r\ndev_dbg(priv->adapter->dev, "info: ASSOC_RESP: curr_pkt_filter is %#x\n",\r\npriv->curr_pkt_filter);\r\nif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\r\npriv->wpa_is_gtk_set = false;\r\nif (priv->wmm_enabled) {\r\nenable_data = false;\r\n} else {\r\nmwifiex_wmm_setup_queue_priorities(priv, NULL);\r\nmwifiex_wmm_setup_ac_downgrade(priv);\r\n}\r\nif (enable_data)\r\ndev_dbg(priv->adapter->dev,\r\n"info: post association, re-enabling data flow\n");\r\npriv->data_rssi_last = 0;\r\npriv->data_nf_last = 0;\r\npriv->data_rssi_avg = 0;\r\npriv->data_nf_avg = 0;\r\npriv->bcn_rssi_last = 0;\r\npriv->bcn_nf_last = 0;\r\npriv->bcn_rssi_avg = 0;\r\npriv->bcn_nf_avg = 0;\r\npriv->rxpd_rate = 0;\r\npriv->rxpd_htinfo = 0;\r\nmwifiex_save_curr_bcn(priv);\r\npriv->adapter->dbg.num_cmd_assoc_success++;\r\ndev_dbg(priv->adapter->dev, "info: ASSOC_RESP: associated\n");\r\nmwifiex_ralist_add(priv,\r\npriv->curr_bss_params.bss_descriptor.mac_address);\r\nif (!netif_carrier_ok(priv->netdev))\r\nnetif_carrier_on(priv->netdev);\r\nmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\r\nif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\r\npriv->scan_block = true;\r\ndone:\r\nif (adapter->curr_cmd->wait_q_enabled) {\r\nif (ret)\r\nadapter->cmd_wait_q.status = -1;\r\nelse\r\nadapter->cmd_wait_q.status = 0;\r\n}\r\nreturn ret;\r\n}\r\nint\r\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nstruct cfg80211_ssid *req_ssid)\r\n{\r\nint rsn_ie_len = 0;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\r\n&cmd->params.adhoc_start;\r\nstruct mwifiex_bssdescriptor *bss_desc;\r\nu32 cmd_append_size = 0;\r\nu32 i;\r\nu16 tmp_cap;\r\nstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\r\nu8 radio_type;\r\nstruct mwifiex_ie_types_htcap *ht_cap;\r\nstruct mwifiex_ie_types_htinfo *ht_info;\r\nu8 *pos = (u8 *) adhoc_start +\r\nsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\r\nif (!adapter)\r\nreturn -1;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\r\nbss_desc = &priv->curr_bss_params.bss_descriptor;\r\npriv->attempted_bss_desc = bss_desc;\r\nmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\r\nmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\r\ndev_dbg(adapter->dev, "info: ADHOC_S_CMD: SSID = %s\n",\r\nadhoc_start->ssid);\r\nmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\r\nmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\r\nbss_desc->ssid.ssid_len = req_ssid->ssid_len;\r\nadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\r\nbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\r\nadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\r\nbss_desc->beacon_period = priv->beacon_period;\r\n#define DS_PARA_IE_ID 3\r\n#define DS_PARA_IE_LEN 1\r\nadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\r\nadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\r\nif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\r\n(u16) priv->adhoc_channel, 0)) {\r\nstruct mwifiex_chan_freq_power *cfp;\r\ncfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\r\nFIRST_VALID_CHANNEL, 0);\r\nif (cfp)\r\npriv->adhoc_channel = (u8) cfp->channel;\r\n}\r\nif (!priv->adhoc_channel) {\r\ndev_err(adapter->dev, "ADHOC_S_CMD: adhoc_channel cannot be 0\n");\r\nreturn -1;\r\n}\r\ndev_dbg(adapter->dev, "info: ADHOC_S_CMD: creating ADHOC on channel %d\n",\r\npriv->adhoc_channel);\r\npriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\r\npriv->curr_bss_params.band = adapter->adhoc_start_band;\r\nbss_desc->channel = priv->adhoc_channel;\r\nadhoc_start->phy_param_set.ds_param_set.current_chan =\r\npriv->adhoc_channel;\r\nmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\r\nsizeof(union ieee_types_phy_param_set));\r\n#define IBSS_PARA_IE_ID 6\r\n#define IBSS_PARA_IE_LEN 2\r\nadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\r\nadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\r\nadhoc_start->ss_param_set.ibss_param_set.atim_window\r\n= cpu_to_le16(priv->atim_window);\r\nmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\r\nsizeof(union ieee_types_ss_param_set));\r\nbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\r\ntmp_cap = le16_to_cpu(adhoc_start->cap_info_bitmap);\r\ntmp_cap &= ~WLAN_CAPABILITY_ESS;\r\ntmp_cap |= WLAN_CAPABILITY_IBSS;\r\nif (priv->sec_info.encryption_mode) {\r\ndev_dbg(adapter->dev,\r\n"info: ADHOC_S_CMD: wep_status set privacy to WEP\n");\r\nbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\r\ntmp_cap |= WLAN_CAPABILITY_PRIVACY;\r\n} else {\r\ndev_dbg(adapter->dev, "info: ADHOC_S_CMD: wep_status NOT set,"\r\n" setting privacy to ACCEPT ALL\n");\r\nbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\r\n}\r\nmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\r\nmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\r\nif ((adapter->adhoc_start_band & BAND_G) &&\r\n(priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\r\nHostCmd_ACT_GEN_SET, 0,\r\n&priv->curr_pkt_filter, false)) {\r\ndev_err(adapter->dev,\r\n"ADHOC_S_CMD: G Protection config failed\n");\r\nreturn -1;\r\n}\r\n}\r\nfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\r\nif (!adhoc_start->data_rate[i])\r\nbreak;\r\npriv->curr_bss_params.num_of_rates = i;\r\nmemcpy(&priv->curr_bss_params.data_rates,\r\n&adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\r\ndev_dbg(adapter->dev, "info: ADHOC_S_CMD: rates=%4ph\n",\r\nadhoc_start->data_rate);\r\ndev_dbg(adapter->dev, "info: ADHOC_S_CMD: AD-HOC Start command is ready\n");\r\nif (IS_SUPPORT_MULTI_BANDS(adapter)) {\r\nchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\r\nchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\r\nchan_tlv->header.len =\r\ncpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\r\nmemset(chan_tlv->chan_scan_param, 0x00,\r\nsizeof(struct mwifiex_chan_scan_param_set));\r\nchan_tlv->chan_scan_param[0].chan_number =\r\n(u8) priv->curr_bss_params.bss_descriptor.channel;\r\ndev_dbg(adapter->dev, "info: ADHOC_S_CMD: TLV Chan = %d\n",\r\nchan_tlv->chan_scan_param[0].chan_number);\r\nchan_tlv->chan_scan_param[0].radio_type\r\n= mwifiex_band_to_radio_type(priv->curr_bss_params.band);\r\nif (adapter->adhoc_start_band & BAND_GN ||\r\nadapter->adhoc_start_band & BAND_AN) {\r\nif (adapter->sec_chan_offset ==\r\nIEEE80211_HT_PARAM_CHA_SEC_ABOVE)\r\nchan_tlv->chan_scan_param[0].radio_type |=\r\n(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\r\nelse if (adapter->sec_chan_offset ==\r\nIEEE80211_HT_PARAM_CHA_SEC_ABOVE)\r\nchan_tlv->chan_scan_param[0].radio_type |=\r\n(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\r\n}\r\ndev_dbg(adapter->dev, "info: ADHOC_S_CMD: TLV Band = %d\n",\r\nchan_tlv->chan_scan_param[0].radio_type);\r\npos += sizeof(chan_tlv->header) +\r\nsizeof(struct mwifiex_chan_scan_param_set);\r\ncmd_append_size +=\r\nsizeof(chan_tlv->header) +\r\nsizeof(struct mwifiex_chan_scan_param_set);\r\n}\r\ncmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\r\nMWIFIEX_VSIE_MASK_ADHOC, &pos);\r\nif (priv->sec_info.wpa_enabled) {\r\nrsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\r\nif (rsn_ie_len == -1)\r\nreturn -1;\r\ncmd_append_size += rsn_ie_len;\r\n}\r\nif (adapter->adhoc_11n_enabled) {\r\nht_cap = (struct mwifiex_ie_types_htcap *) pos;\r\nmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\r\nht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\r\nht_cap->header.len =\r\ncpu_to_le16(sizeof(struct ieee80211_ht_cap));\r\nradio_type = mwifiex_band_to_radio_type(\r\npriv->adapter->config_bands);\r\nmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\r\nif (adapter->sec_chan_offset ==\r\nIEEE80211_HT_PARAM_CHA_SEC_NONE) {\r\nu16 tmp_ht_cap;\r\ntmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\r\ntmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\r\ntmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\r\nht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\r\n}\r\npos += sizeof(struct mwifiex_ie_types_htcap);\r\ncmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\r\nht_info = (struct mwifiex_ie_types_htinfo *) pos;\r\nmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\r\nht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\r\nht_info->header.len =\r\ncpu_to_le16(sizeof(struct ieee80211_ht_operation));\r\nht_info->ht_oper.primary_chan =\r\n(u8) priv->curr_bss_params.bss_descriptor.channel;\r\nif (adapter->sec_chan_offset) {\r\nht_info->ht_oper.ht_param = adapter->sec_chan_offset;\r\nht_info->ht_oper.ht_param |=\r\nIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\r\n}\r\nht_info->ht_oper.operation_mode =\r\ncpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\r\nht_info->ht_oper.basic_set[0] = 0xff;\r\npos += sizeof(struct mwifiex_ie_types_htinfo);\r\ncmd_append_size +=\r\nsizeof(struct mwifiex_ie_types_htinfo);\r\n}\r\ncmd->size =\r\ncpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\r\n+ S_DS_GEN + cmd_append_size));\r\nif (adapter->adhoc_start_band == BAND_B)\r\ntmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\r\nelse\r\ntmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\r\nadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\r\nreturn 0;\r\n}\r\nint\r\nmwifiex_cmd_802_11_ad_hoc_join(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nint rsn_ie_len = 0;\r\nstruct host_cmd_ds_802_11_ad_hoc_join *adhoc_join =\r\n&cmd->params.adhoc_join;\r\nstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\r\nu32 cmd_append_size = 0;\r\nu16 tmp_cap;\r\nu32 i, rates_size = 0;\r\nu16 curr_pkt_filter;\r\nu8 *pos =\r\n(u8 *) adhoc_join +\r\nsizeof(struct host_cmd_ds_802_11_ad_hoc_join);\r\n#define USE_G_PROTECTION 0x02\r\nif (bss_desc->erp_flags & USE_G_PROTECTION) {\r\ncurr_pkt_filter =\r\npriv->\r\ncurr_pkt_filter | HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\r\nHostCmd_ACT_GEN_SET, 0,\r\n&curr_pkt_filter, false)) {\r\ndev_err(priv->adapter->dev,\r\n"ADHOC_J_CMD: G Protection config failed\n");\r\nreturn -1;\r\n}\r\n}\r\npriv->attempted_bss_desc = bss_desc;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_JOIN);\r\nadhoc_join->bss_descriptor.bss_mode = HostCmd_BSS_MODE_IBSS;\r\nadhoc_join->bss_descriptor.beacon_period\r\n= cpu_to_le16(bss_desc->beacon_period);\r\nmemcpy(&adhoc_join->bss_descriptor.bssid,\r\n&bss_desc->mac_address, ETH_ALEN);\r\nmemcpy(&adhoc_join->bss_descriptor.ssid,\r\n&bss_desc->ssid.ssid, bss_desc->ssid.ssid_len);\r\nmemcpy(&adhoc_join->bss_descriptor.phy_param_set,\r\n&bss_desc->phy_param_set,\r\nsizeof(union ieee_types_phy_param_set));\r\nmemcpy(&adhoc_join->bss_descriptor.ss_param_set,\r\n&bss_desc->ss_param_set, sizeof(union ieee_types_ss_param_set));\r\ntmp_cap = bss_desc->cap_info_bitmap;\r\ntmp_cap &= CAPINFO_MASK;\r\ndev_dbg(priv->adapter->dev,\r\n"info: ADHOC_J_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\n",\r\ntmp_cap, CAPINFO_MASK);\r\ndev_dbg(priv->adapter->dev, "info: ADHOC_J_CMD: BSSID=%pM, SSID='%s'\n",\r\nadhoc_join->bss_descriptor.bssid,\r\nadhoc_join->bss_descriptor.ssid);\r\nfor (i = 0; i < MWIFIEX_SUPPORTED_RATES &&\r\nbss_desc->supported_rates[i]; i++)\r\n;\r\nrates_size = i;\r\nmemset(adhoc_join->bss_descriptor.data_rates, 0,\r\nsizeof(adhoc_join->bss_descriptor.data_rates));\r\nmemcpy(adhoc_join->bss_descriptor.data_rates,\r\nbss_desc->supported_rates, rates_size);\r\npriv->curr_bss_params.num_of_rates = rates_size;\r\nmemcpy(&priv->curr_bss_params.data_rates, bss_desc->supported_rates,\r\nrates_size);\r\npriv->curr_bss_params.bss_descriptor.channel = bss_desc->channel;\r\npriv->curr_bss_params.band = (u8) bss_desc->bss_band;\r\nif (priv->sec_info.wep_enabled || priv->sec_info.wpa_enabled)\r\ntmp_cap |= WLAN_CAPABILITY_PRIVACY;\r\nif (IS_SUPPORT_MULTI_BANDS(priv->adapter)) {\r\nchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\r\nchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\r\nchan_tlv->header.len =\r\ncpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\r\nmemset(chan_tlv->chan_scan_param, 0x00,\r\nsizeof(struct mwifiex_chan_scan_param_set));\r\nchan_tlv->chan_scan_param[0].chan_number =\r\n(bss_desc->phy_param_set.ds_param_set.current_chan);\r\ndev_dbg(priv->adapter->dev, "info: ADHOC_J_CMD: TLV Chan=%d\n",\r\nchan_tlv->chan_scan_param[0].chan_number);\r\nchan_tlv->chan_scan_param[0].radio_type =\r\nmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\r\ndev_dbg(priv->adapter->dev, "info: ADHOC_J_CMD: TLV Band=%d\n",\r\nchan_tlv->chan_scan_param[0].radio_type);\r\npos += sizeof(chan_tlv->header) +\r\nsizeof(struct mwifiex_chan_scan_param_set);\r\ncmd_append_size += sizeof(chan_tlv->header) +\r\nsizeof(struct mwifiex_chan_scan_param_set);\r\n}\r\nif (priv->sec_info.wpa_enabled)\r\nrsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\r\nif (rsn_ie_len == -1)\r\nreturn -1;\r\ncmd_append_size += rsn_ie_len;\r\nif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info))\r\ncmd_append_size += mwifiex_cmd_append_11n_tlv(priv,\r\nbss_desc, &pos);\r\ncmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\r\nMWIFIEX_VSIE_MASK_ADHOC, &pos);\r\ncmd->size = cpu_to_le16\r\n((u16) (sizeof(struct host_cmd_ds_802_11_ad_hoc_join)\r\n+ S_DS_GEN + cmd_append_size));\r\nadhoc_join->bss_descriptor.cap_info_bitmap = cpu_to_le16(tmp_cap);\r\nreturn 0;\r\n}\r\nint mwifiex_ret_802_11_ad_hoc(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nint ret = 0;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11_ad_hoc_result *adhoc_result;\r\nstruct mwifiex_bssdescriptor *bss_desc;\r\nu16 reason_code;\r\nadhoc_result = &resp->params.adhoc_result;\r\nbss_desc = priv->attempted_bss_desc;\r\nreason_code = le16_to_cpu(resp->result);\r\nif (reason_code) {\r\ndev_err(priv->adapter->dev, "ADHOC_RESP: failed\n");\r\nif (priv->media_connected)\r\nmwifiex_reset_connect_state(priv, reason_code);\r\nmemset(&priv->curr_bss_params.bss_descriptor,\r\n0x00, sizeof(struct mwifiex_bssdescriptor));\r\nret = -1;\r\ngoto done;\r\n}\r\npriv->media_connected = true;\r\nif (le16_to_cpu(resp->command) == HostCmd_CMD_802_11_AD_HOC_START) {\r\ndev_dbg(priv->adapter->dev, "info: ADHOC_S_RESP %s\n",\r\nbss_desc->ssid.ssid);\r\nmemcpy(bss_desc->mac_address,\r\nadhoc_result->bssid, ETH_ALEN);\r\npriv->adhoc_state = ADHOC_STARTED;\r\n} else {\r\ndev_dbg(priv->adapter->dev, "info: ADHOC_J_RESP %s\n",\r\nbss_desc->ssid.ssid);\r\nmemcpy(&priv->curr_bss_params.bss_descriptor,\r\nbss_desc, sizeof(struct mwifiex_bssdescriptor));\r\npriv->adhoc_state = ADHOC_JOINED;\r\n}\r\ndev_dbg(priv->adapter->dev, "info: ADHOC_RESP: channel = %d\n",\r\npriv->adhoc_channel);\r\ndev_dbg(priv->adapter->dev, "info: ADHOC_RESP: BSSID = %pM\n",\r\npriv->curr_bss_params.bss_descriptor.mac_address);\r\nif (!netif_carrier_ok(priv->netdev))\r\nnetif_carrier_on(priv->netdev);\r\nmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\r\nmwifiex_save_curr_bcn(priv);\r\ndone:\r\nif (adapter->curr_cmd->wait_q_enabled) {\r\nif (ret)\r\nadapter->cmd_wait_q.status = -1;\r\nelse\r\nadapter->cmd_wait_q.status = 0;\r\n}\r\nreturn ret;\r\n}\r\nint mwifiex_associate(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nu8 current_bssid[ETH_ALEN];\r\nif ((GET_BSS_ROLE(priv) != MWIFIEX_BSS_ROLE_STA) ||\r\n(bss_desc->bss_mode != NL80211_IFTYPE_STATION))\r\nreturn -1;\r\nif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\r\n!bss_desc->disable_11n && !bss_desc->disable_11ac &&\r\npriv->adapter->config_bands & BAND_AAC)\r\nmwifiex_set_11ac_ba_params(priv);\r\nelse\r\nmwifiex_set_ba_params(priv);\r\nmemcpy(&current_bssid,\r\n&priv->curr_bss_params.bss_descriptor.mac_address,\r\nsizeof(current_bssid));\r\npriv->assoc_rsp_size = 0;\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_ASSOCIATE,\r\nHostCmd_ACT_GEN_SET, 0, bss_desc, true);\r\n}\r\nint\r\nmwifiex_adhoc_start(struct mwifiex_private *priv,\r\nstruct cfg80211_ssid *adhoc_ssid)\r\n{\r\ndev_dbg(priv->adapter->dev, "info: Adhoc Channel = %d\n",\r\npriv->adhoc_channel);\r\ndev_dbg(priv->adapter->dev, "info: curr_bss_params.channel = %d\n",\r\npriv->curr_bss_params.bss_descriptor.channel);\r\ndev_dbg(priv->adapter->dev, "info: curr_bss_params.band = %d\n",\r\npriv->curr_bss_params.band);\r\nif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\r\npriv->adapter->config_bands & BAND_AAC)\r\nmwifiex_set_11ac_ba_params(priv);\r\nelse\r\nmwifiex_set_ba_params(priv);\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_START,\r\nHostCmd_ACT_GEN_SET, 0, adhoc_ssid, true);\r\n}\r\nint mwifiex_adhoc_join(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\ndev_dbg(priv->adapter->dev, "info: adhoc join: curr_bss ssid =%s\n",\r\npriv->curr_bss_params.bss_descriptor.ssid.ssid);\r\ndev_dbg(priv->adapter->dev, "info: adhoc join: curr_bss ssid_len =%u\n",\r\npriv->curr_bss_params.bss_descriptor.ssid.ssid_len);\r\ndev_dbg(priv->adapter->dev, "info: adhoc join: ssid =%s\n",\r\nbss_desc->ssid.ssid);\r\ndev_dbg(priv->adapter->dev, "info: adhoc join: ssid_len =%u\n",\r\nbss_desc->ssid.ssid_len);\r\nif (priv->curr_bss_params.bss_descriptor.ssid.ssid_len &&\r\n!mwifiex_ssid_cmp(&bss_desc->ssid,\r\n&priv->curr_bss_params.bss_descriptor.ssid) &&\r\n(priv->curr_bss_params.bss_descriptor.bss_mode ==\r\nNL80211_IFTYPE_ADHOC)) {\r\ndev_dbg(priv->adapter->dev, "info: ADHOC_J_CMD: new ad-hoc SSID"\r\n" is the same as current; not attempting to re-join\n");\r\nreturn -1;\r\n}\r\nif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\r\n!bss_desc->disable_11n && !bss_desc->disable_11ac &&\r\npriv->adapter->config_bands & BAND_AAC)\r\nmwifiex_set_11ac_ba_params(priv);\r\nelse\r\nmwifiex_set_ba_params(priv);\r\ndev_dbg(priv->adapter->dev, "info: curr_bss_params.channel = %d\n",\r\npriv->curr_bss_params.bss_descriptor.channel);\r\ndev_dbg(priv->adapter->dev, "info: curr_bss_params.band = %c\n",\r\npriv->curr_bss_params.band);\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_JOIN,\r\nHostCmd_ACT_GEN_SET, 0, bss_desc, true);\r\n}\r\nstatic int mwifiex_deauthenticate_infra(struct mwifiex_private *priv, u8 *mac)\r\n{\r\nu8 mac_address[ETH_ALEN];\r\nint ret;\r\nif (!mac || is_zero_ether_addr(mac))\r\nmemcpy(mac_address,\r\npriv->curr_bss_params.bss_descriptor.mac_address,\r\nETH_ALEN);\r\nelse\r\nmemcpy(mac_address, mac, ETH_ALEN);\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,\r\nHostCmd_ACT_GEN_SET, 0, mac_address, true);\r\nreturn ret;\r\n}\r\nint mwifiex_deauthenticate(struct mwifiex_private *priv, u8 *mac)\r\n{\r\nint ret = 0;\r\nif (!priv->media_connected)\r\nreturn 0;\r\nswitch (priv->bss_mode) {\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\nret = mwifiex_deauthenticate_infra(priv, mac);\r\nif (ret)\r\ncfg80211_disconnected(priv->netdev, 0, NULL, 0,\r\nGFP_KERNEL);\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_STOP,\r\nHostCmd_ACT_GEN_SET, 0, NULL, true);\r\ncase NL80211_IFTYPE_AP:\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_STOP,\r\nHostCmd_ACT_GEN_SET, 0, NULL, true);\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid mwifiex_deauthenticate_all(struct mwifiex_adapter *adapter)\r\n{\r\nstruct mwifiex_private *priv;\r\nint i;\r\nfor (i = 0; i < adapter->priv_num; i++) {\r\npriv = adapter->priv[i];\r\nif (priv)\r\nmwifiex_deauthenticate(priv, NULL);\r\n}\r\n}\r\nu8\r\nmwifiex_band_to_radio_type(u8 band)\r\n{\r\nswitch (band) {\r\ncase BAND_A:\r\ncase BAND_AN:\r\ncase BAND_A | BAND_AN:\r\ncase BAND_A | BAND_AN | BAND_AAC:\r\nreturn HostCmd_SCAN_RADIO_TYPE_A;\r\ncase BAND_B:\r\ncase BAND_G:\r\ncase BAND_B | BAND_G:\r\ndefault:\r\nreturn HostCmd_SCAN_RADIO_TYPE_BG;\r\n}\r\n}
