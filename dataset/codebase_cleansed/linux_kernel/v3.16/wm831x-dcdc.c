static unsigned int wm831x_dcdc_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\r\nint val;\r\nval = wm831x_reg_read(wm831x, reg);\r\nif (val < 0)\r\nreturn val;\r\nval = (val & WM831X_DC1_ON_MODE_MASK) >> WM831X_DC1_ON_MODE_SHIFT;\r\nswitch (val) {\r\ncase WM831X_DCDC_MODE_FAST:\r\nreturn REGULATOR_MODE_FAST;\r\ncase WM831X_DCDC_MODE_NORMAL:\r\nreturn REGULATOR_MODE_NORMAL;\r\ncase WM831X_DCDC_MODE_STANDBY:\r\nreturn REGULATOR_MODE_STANDBY;\r\ncase WM831X_DCDC_MODE_IDLE:\r\nreturn REGULATOR_MODE_IDLE;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int wm831x_dcdc_set_mode_int(struct wm831x *wm831x, int reg,\r\nunsigned int mode)\r\n{\r\nint val;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = WM831X_DCDC_MODE_FAST;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = WM831X_DCDC_MODE_NORMAL;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = WM831X_DCDC_MODE_STANDBY;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nval = WM831X_DCDC_MODE_IDLE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn wm831x_set_bits(wm831x, reg, WM831X_DC1_ON_MODE_MASK,\r\nval << WM831X_DC1_ON_MODE_SHIFT);\r\n}\r\nstatic int wm831x_dcdc_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\r\nreturn wm831x_dcdc_set_mode_int(wm831x, reg, mode);\r\n}\r\nstatic int wm831x_dcdc_set_suspend_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;\r\nreturn wm831x_dcdc_set_mode_int(wm831x, reg, mode);\r\n}\r\nstatic int wm831x_dcdc_get_status(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint ret;\r\nret = wm831x_reg_read(wm831x, WM831X_DCDC_UV_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & (1 << rdev_get_id(rdev))) {\r\ndev_dbg(wm831x->dev, "DCDC%d under voltage\n",\r\nrdev_get_id(rdev) + 1);\r\nreturn REGULATOR_STATUS_ERROR;\r\n}\r\nif (rdev_get_id(rdev) < 2) {\r\nif (ret & (WM831X_DC1_OV_STS << rdev_get_id(rdev))) {\r\ndev_dbg(wm831x->dev, "DCDC%d over voltage\n",\r\nrdev_get_id(rdev) + 1);\r\nreturn REGULATOR_STATUS_ERROR;\r\n}\r\nif (ret & (WM831X_DC1_HC_STS << rdev_get_id(rdev))) {\r\ndev_dbg(wm831x->dev, "DCDC%d over current\n",\r\nrdev_get_id(rdev) + 1);\r\nreturn REGULATOR_STATUS_ERROR;\r\n}\r\n}\r\nret = wm831x_reg_read(wm831x, WM831X_DCDC_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & (1 << rdev_get_id(rdev))))\r\nreturn REGULATOR_STATUS_OFF;\r\nreturn REGULATOR_STATUS_ON;\r\n}\r\nstatic irqreturn_t wm831x_dcdc_uv_irq(int irq, void *data)\r\n{\r\nstruct wm831x_dcdc *dcdc = data;\r\nregulator_notifier_call_chain(dcdc->regulator,\r\nREGULATOR_EVENT_UNDER_VOLTAGE,\r\nNULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wm831x_dcdc_oc_irq(int irq, void *data)\r\n{\r\nstruct wm831x_dcdc *dcdc = data;\r\nregulator_notifier_call_chain(dcdc->regulator,\r\nREGULATOR_EVENT_OVER_CURRENT,\r\nNULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm831x_buckv_list_voltage(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nif (selector <= 0x8)\r\nreturn 600000;\r\nif (selector <= WM831X_BUCKV_MAX_SELECTOR)\r\nreturn 600000 + ((selector - 0x8) * 12500);\r\nreturn -EINVAL;\r\n}\r\nstatic int wm831x_buckv_map_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nu16 vsel;\r\nif (min_uV < 600000)\r\nvsel = 0;\r\nelse if (min_uV <= 1800000)\r\nvsel = DIV_ROUND_UP(min_uV - 600000, 12500) + 8;\r\nelse\r\nreturn -EINVAL;\r\nif (wm831x_buckv_list_voltage(rdev, vsel) > max_uV)\r\nreturn -EINVAL;\r\nreturn vsel;\r\n}\r\nstatic int wm831x_buckv_set_dvs(struct regulator_dev *rdev, int state)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nif (state == dcdc->dvs_gpio_state)\r\nreturn 0;\r\ndcdc->dvs_gpio_state = state;\r\ngpio_set_value(dcdc->dvs_gpio, state);\r\nreturn 0;\r\n}\r\nstatic int wm831x_buckv_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned vsel)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint on_reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\r\nint dvs_reg = dcdc->base + WM831X_DCDC_DVS_CONTROL;\r\nint ret;\r\nif (dcdc->dvs_gpio && dcdc->on_vsel == vsel)\r\nreturn wm831x_buckv_set_dvs(rdev, 0);\r\nif (dcdc->dvs_gpio && dcdc->dvs_vsel == vsel)\r\nreturn wm831x_buckv_set_dvs(rdev, 1);\r\nret = wm831x_set_bits(wm831x, on_reg, WM831X_DC1_ON_VSEL_MASK, vsel);\r\nif (ret < 0)\r\nreturn ret;\r\ndcdc->on_vsel = vsel;\r\nif (!dcdc->dvs_gpio)\r\nreturn ret;\r\nret = wm831x_buckv_set_dvs(rdev, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (vsel > dcdc->dvs_vsel) {\r\nret = wm831x_set_bits(wm831x, dvs_reg,\r\nWM831X_DC1_DVS_VSEL_MASK,\r\nvsel);\r\nif (ret == 0)\r\ndcdc->dvs_vsel = vsel;\r\nelse\r\ndev_warn(wm831x->dev,\r\n"Failed to set DCDC DVS VSEL: %d\n", ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm831x_buckv_set_suspend_voltage(struct regulator_dev *rdev,\r\nint uV)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;\r\nint vsel;\r\nvsel = wm831x_buckv_map_voltage(rdev, uV, uV);\r\nif (vsel < 0)\r\nreturn vsel;\r\nreturn wm831x_set_bits(wm831x, reg, WM831X_DC1_SLP_VSEL_MASK, vsel);\r\n}\r\nstatic int wm831x_buckv_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nif (dcdc->dvs_gpio && dcdc->dvs_gpio_state)\r\nreturn dcdc->dvs_vsel;\r\nelse\r\nreturn dcdc->on_vsel;\r\n}\r\nstatic int wm831x_buckv_set_current_limit(struct regulator_dev *rdev,\r\nint min_uA, int max_uA)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_CONTROL_2;\r\nint i;\r\nfor (i = ARRAY_SIZE(wm831x_dcdc_ilim) - 1; i >= 0; i--) {\r\nif ((min_uA <= wm831x_dcdc_ilim[i]) &&\r\n(wm831x_dcdc_ilim[i] <= max_uA))\r\nreturn wm831x_set_bits(wm831x, reg,\r\nWM831X_DC1_HC_THR_MASK,\r\ni << WM831X_DC1_HC_THR_SHIFT);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int wm831x_buckv_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_CONTROL_2;\r\nint val;\r\nval = wm831x_reg_read(wm831x, reg);\r\nif (val < 0)\r\nreturn val;\r\nval = (val & WM831X_DC1_HC_THR_MASK) >> WM831X_DC1_HC_THR_SHIFT;\r\nreturn wm831x_dcdc_ilim[val];\r\n}\r\nstatic void wm831x_buckv_dvs_init(struct platform_device *pdev,\r\nstruct wm831x_dcdc *dcdc,\r\nstruct wm831x_buckv_pdata *pdata)\r\n{\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint ret;\r\nu16 ctrl;\r\nif (!pdata || !pdata->dvs_gpio)\r\nreturn;\r\ndcdc->dvs_gpio_state = pdata->dvs_init_state;\r\nret = devm_gpio_request_one(&pdev->dev, pdata->dvs_gpio,\r\ndcdc->dvs_gpio_state ? GPIOF_INIT_HIGH : 0,\r\n"DCDC DVS");\r\nif (ret < 0) {\r\ndev_err(wm831x->dev, "Failed to get %s DVS GPIO: %d\n",\r\ndcdc->name, ret);\r\nreturn;\r\n}\r\ndcdc->dvs_gpio = pdata->dvs_gpio;\r\nswitch (pdata->dvs_control_src) {\r\ncase 1:\r\nctrl = 2 << WM831X_DC1_DVS_SRC_SHIFT;\r\nbreak;\r\ncase 2:\r\nctrl = 3 << WM831X_DC1_DVS_SRC_SHIFT;\r\nbreak;\r\ndefault:\r\ndev_err(wm831x->dev, "Invalid DVS control source %d for %s\n",\r\npdata->dvs_control_src, dcdc->name);\r\nreturn;\r\n}\r\nif (!dcdc->dvs_vsel) {\r\nret = wm831x_set_bits(wm831x,\r\ndcdc->base + WM831X_DCDC_DVS_CONTROL,\r\nWM831X_DC1_DVS_VSEL_MASK, dcdc->on_vsel);\r\nif (ret == 0)\r\ndcdc->dvs_vsel = dcdc->on_vsel;\r\nelse\r\ndev_warn(wm831x->dev, "Failed to set DVS_VSEL: %d\n",\r\nret);\r\n}\r\nret = wm831x_set_bits(wm831x, dcdc->base + WM831X_DCDC_DVS_CONTROL,\r\nWM831X_DC1_DVS_SRC_MASK, ctrl);\r\nif (ret < 0) {\r\ndev_err(wm831x->dev, "Failed to set %s DVS source: %d\n",\r\ndcdc->name, ret);\r\n}\r\n}\r\nstatic int wm831x_buckv_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\r\nstruct regulator_config config = { };\r\nint id;\r\nstruct wm831x_dcdc *dcdc;\r\nstruct resource *res;\r\nint ret, irq;\r\nif (pdata && pdata->wm831x_num)\r\nid = (pdata->wm831x_num * 10) + 1;\r\nelse\r\nid = 0;\r\nid = pdev->id - id;\r\ndev_dbg(&pdev->dev, "Probing DCDC%d\n", id + 1);\r\ndcdc = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_dcdc),\r\nGFP_KERNEL);\r\nif (!dcdc)\r\nreturn -ENOMEM;\r\ndcdc->wm831x = wm831x;\r\nres = platform_get_resource(pdev, IORESOURCE_REG, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No REG resource\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndcdc->base = res->start;\r\nsnprintf(dcdc->name, sizeof(dcdc->name), "DCDC%d", id + 1);\r\ndcdc->desc.name = dcdc->name;\r\nsnprintf(dcdc->supply_name, sizeof(dcdc->supply_name),\r\n"DC%dVDD", id + 1);\r\ndcdc->desc.supply_name = dcdc->supply_name;\r\ndcdc->desc.id = id;\r\ndcdc->desc.type = REGULATOR_VOLTAGE;\r\ndcdc->desc.n_voltages = WM831X_BUCKV_MAX_SELECTOR + 1;\r\ndcdc->desc.ops = &wm831x_buckv_ops;\r\ndcdc->desc.owner = THIS_MODULE;\r\ndcdc->desc.enable_reg = WM831X_DCDC_ENABLE;\r\ndcdc->desc.enable_mask = 1 << id;\r\nret = wm831x_reg_read(wm831x, dcdc->base + WM831X_DCDC_ON_CONFIG);\r\nif (ret < 0) {\r\ndev_err(wm831x->dev, "Failed to read ON VSEL: %d\n", ret);\r\ngoto err;\r\n}\r\ndcdc->on_vsel = ret & WM831X_DC1_ON_VSEL_MASK;\r\nret = wm831x_reg_read(wm831x, dcdc->base + WM831X_DCDC_DVS_CONTROL);\r\nif (ret < 0) {\r\ndev_err(wm831x->dev, "Failed to read DVS VSEL: %d\n", ret);\r\ngoto err;\r\n}\r\ndcdc->dvs_vsel = ret & WM831X_DC1_DVS_VSEL_MASK;\r\nif (pdata && pdata->dcdc[id])\r\nwm831x_buckv_dvs_init(pdev, dcdc,\r\npdata->dcdc[id]->driver_data);\r\nconfig.dev = pdev->dev.parent;\r\nif (pdata)\r\nconfig.init_data = pdata->dcdc[id];\r\nconfig.driver_data = dcdc;\r\nconfig.regmap = wm831x->regmap;\r\ndcdc->regulator = devm_regulator_register(&pdev->dev, &dcdc->desc,\r\n&config);\r\nif (IS_ERR(dcdc->regulator)) {\r\nret = PTR_ERR(dcdc->regulator);\r\ndev_err(wm831x->dev, "Failed to register DCDC%d: %d\n",\r\nid + 1, ret);\r\ngoto err;\r\n}\r\nirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, "UV"));\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nwm831x_dcdc_uv_irq,\r\nIRQF_TRIGGER_RISING, dcdc->name, dcdc);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err;\r\n}\r\nirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, "HC"));\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nwm831x_dcdc_oc_irq,\r\nIRQF_TRIGGER_RISING, dcdc->name, dcdc);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request HC IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, dcdc);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int wm831x_buckp_set_suspend_voltage(struct regulator_dev *rdev, int uV)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;\r\nint sel;\r\nsel = regulator_map_voltage_linear(rdev, uV, uV);\r\nif (sel < 0)\r\nreturn sel;\r\nreturn wm831x_set_bits(wm831x, reg, WM831X_DC3_ON_VSEL_MASK, sel);\r\n}\r\nstatic int wm831x_buckp_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\r\nstruct regulator_config config = { };\r\nint id;\r\nstruct wm831x_dcdc *dcdc;\r\nstruct resource *res;\r\nint ret, irq;\r\nif (pdata && pdata->wm831x_num)\r\nid = (pdata->wm831x_num * 10) + 1;\r\nelse\r\nid = 0;\r\nid = pdev->id - id;\r\ndev_dbg(&pdev->dev, "Probing DCDC%d\n", id + 1);\r\ndcdc = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_dcdc),\r\nGFP_KERNEL);\r\nif (!dcdc)\r\nreturn -ENOMEM;\r\ndcdc->wm831x = wm831x;\r\nres = platform_get_resource(pdev, IORESOURCE_REG, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No REG resource\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndcdc->base = res->start;\r\nsnprintf(dcdc->name, sizeof(dcdc->name), "DCDC%d", id + 1);\r\ndcdc->desc.name = dcdc->name;\r\nsnprintf(dcdc->supply_name, sizeof(dcdc->supply_name),\r\n"DC%dVDD", id + 1);\r\ndcdc->desc.supply_name = dcdc->supply_name;\r\ndcdc->desc.id = id;\r\ndcdc->desc.type = REGULATOR_VOLTAGE;\r\ndcdc->desc.n_voltages = WM831X_BUCKP_MAX_SELECTOR + 1;\r\ndcdc->desc.ops = &wm831x_buckp_ops;\r\ndcdc->desc.owner = THIS_MODULE;\r\ndcdc->desc.vsel_reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\r\ndcdc->desc.vsel_mask = WM831X_DC3_ON_VSEL_MASK;\r\ndcdc->desc.enable_reg = WM831X_DCDC_ENABLE;\r\ndcdc->desc.enable_mask = 1 << id;\r\ndcdc->desc.min_uV = 850000;\r\ndcdc->desc.uV_step = 25000;\r\nconfig.dev = pdev->dev.parent;\r\nif (pdata)\r\nconfig.init_data = pdata->dcdc[id];\r\nconfig.driver_data = dcdc;\r\nconfig.regmap = wm831x->regmap;\r\ndcdc->regulator = devm_regulator_register(&pdev->dev, &dcdc->desc,\r\n&config);\r\nif (IS_ERR(dcdc->regulator)) {\r\nret = PTR_ERR(dcdc->regulator);\r\ndev_err(wm831x->dev, "Failed to register DCDC%d: %d\n",\r\nid + 1, ret);\r\ngoto err;\r\n}\r\nirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, "UV"));\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nwm831x_dcdc_uv_irq,\r\nIRQF_TRIGGER_RISING, dcdc->name, dcdc);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, dcdc);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int wm831x_boostp_get_status(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint ret;\r\nret = wm831x_reg_read(wm831x, WM831X_DCDC_UV_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & (1 << rdev_get_id(rdev))) {\r\ndev_dbg(wm831x->dev, "DCDC%d under voltage\n",\r\nrdev_get_id(rdev) + 1);\r\nreturn REGULATOR_STATUS_ERROR;\r\n}\r\nret = wm831x_reg_read(wm831x, WM831X_DCDC_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & (1 << rdev_get_id(rdev)))\r\nreturn REGULATOR_STATUS_ON;\r\nelse\r\nreturn REGULATOR_STATUS_OFF;\r\n}\r\nstatic int wm831x_boostp_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\r\nstruct regulator_config config = { };\r\nint id = pdev->id % ARRAY_SIZE(pdata->dcdc);\r\nstruct wm831x_dcdc *dcdc;\r\nstruct resource *res;\r\nint ret, irq;\r\ndev_dbg(&pdev->dev, "Probing DCDC%d\n", id + 1);\r\nif (pdata == NULL || pdata->dcdc[id] == NULL)\r\nreturn -ENODEV;\r\ndcdc = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_dcdc), GFP_KERNEL);\r\nif (!dcdc)\r\nreturn -ENOMEM;\r\ndcdc->wm831x = wm831x;\r\nres = platform_get_resource(pdev, IORESOURCE_REG, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No REG resource\n");\r\nreturn -EINVAL;\r\n}\r\ndcdc->base = res->start;\r\nsnprintf(dcdc->name, sizeof(dcdc->name), "DCDC%d", id + 1);\r\ndcdc->desc.name = dcdc->name;\r\ndcdc->desc.id = id;\r\ndcdc->desc.type = REGULATOR_VOLTAGE;\r\ndcdc->desc.ops = &wm831x_boostp_ops;\r\ndcdc->desc.owner = THIS_MODULE;\r\ndcdc->desc.enable_reg = WM831X_DCDC_ENABLE;\r\ndcdc->desc.enable_mask = 1 << id;\r\nconfig.dev = pdev->dev.parent;\r\nif (pdata)\r\nconfig.init_data = pdata->dcdc[id];\r\nconfig.driver_data = dcdc;\r\nconfig.regmap = wm831x->regmap;\r\ndcdc->regulator = devm_regulator_register(&pdev->dev, &dcdc->desc,\r\n&config);\r\nif (IS_ERR(dcdc->regulator)) {\r\nret = PTR_ERR(dcdc->regulator);\r\ndev_err(wm831x->dev, "Failed to register DCDC%d: %d\n",\r\nid + 1, ret);\r\nreturn ret;\r\n}\r\nirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, "UV"));\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nwm831x_dcdc_uv_irq,\r\nIRQF_TRIGGER_RISING, dcdc->name,\r\ndcdc);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",\r\nirq, ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, dcdc);\r\nreturn 0;\r\n}\r\nstatic int wm831x_epe_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\r\nstruct regulator_config config = { };\r\nint id = pdev->id % ARRAY_SIZE(pdata->epe);\r\nstruct wm831x_dcdc *dcdc;\r\nint ret;\r\ndev_dbg(&pdev->dev, "Probing EPE%d\n", id + 1);\r\ndcdc = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_dcdc), GFP_KERNEL);\r\nif (!dcdc)\r\nreturn -ENOMEM;\r\ndcdc->wm831x = wm831x;\r\nsnprintf(dcdc->name, sizeof(dcdc->name), "EPE%d", id + 1);\r\ndcdc->desc.name = dcdc->name;\r\ndcdc->desc.id = id + WM831X_EPE_BASE;\r\ndcdc->desc.ops = &wm831x_epe_ops;\r\ndcdc->desc.type = REGULATOR_VOLTAGE;\r\ndcdc->desc.owner = THIS_MODULE;\r\ndcdc->desc.enable_reg = WM831X_DCDC_ENABLE;\r\ndcdc->desc.enable_mask = 1 << dcdc->desc.id;\r\nconfig.dev = pdev->dev.parent;\r\nif (pdata)\r\nconfig.init_data = pdata->epe[id];\r\nconfig.driver_data = dcdc;\r\nconfig.regmap = wm831x->regmap;\r\ndcdc->regulator = devm_regulator_register(&pdev->dev, &dcdc->desc,\r\n&config);\r\nif (IS_ERR(dcdc->regulator)) {\r\nret = PTR_ERR(dcdc->regulator);\r\ndev_err(wm831x->dev, "Failed to register EPE%d: %d\n",\r\nid + 1, ret);\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, dcdc);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int __init wm831x_dcdc_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&wm831x_buckv_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x BUCKV driver: %d\n", ret);\r\nret = platform_driver_register(&wm831x_buckp_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x BUCKP driver: %d\n", ret);\r\nret = platform_driver_register(&wm831x_boostp_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x BOOST driver: %d\n", ret);\r\nret = platform_driver_register(&wm831x_epe_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x EPE driver: %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic void __exit wm831x_dcdc_exit(void)\r\n{\r\nplatform_driver_unregister(&wm831x_epe_driver);\r\nplatform_driver_unregister(&wm831x_boostp_driver);\r\nplatform_driver_unregister(&wm831x_buckp_driver);\r\nplatform_driver_unregister(&wm831x_buckv_driver);\r\n}
