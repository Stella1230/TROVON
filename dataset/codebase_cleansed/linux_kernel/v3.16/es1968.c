static void __maestro_write(struct es1968 *chip, u16 reg, u16 data)\r\n{\r\noutw(reg, chip->io_port + ESM_INDEX);\r\noutw(data, chip->io_port + ESM_DATA);\r\nchip->maestro_map[reg] = data;\r\n}\r\nstatic inline void maestro_write(struct es1968 *chip, u16 reg, u16 data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\n__maestro_write(chip, reg, data);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic u16 __maestro_read(struct es1968 *chip, u16 reg)\r\n{\r\nif (READABLE_MAP & (1 << reg)) {\r\noutw(reg, chip->io_port + ESM_INDEX);\r\nchip->maestro_map[reg] = inw(chip->io_port + ESM_DATA);\r\n}\r\nreturn chip->maestro_map[reg];\r\n}\r\nstatic inline u16 maestro_read(struct es1968 *chip, u16 reg)\r\n{\r\nunsigned long flags;\r\nu16 result;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nresult = __maestro_read(chip, reg);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn result;\r\n}\r\nstatic int snd_es1968_ac97_wait(struct es1968 *chip)\r\n{\r\nint timeout = 100000;\r\nwhile (timeout-- > 0) {\r\nif (!(inb(chip->io_port + ESM_AC97_INDEX) & 1))\r\nreturn 0;\r\ncond_resched();\r\n}\r\ndev_dbg(chip->card->dev, "ac97 timeout\n");\r\nreturn 1;\r\n}\r\nstatic int snd_es1968_ac97_wait_poll(struct es1968 *chip)\r\n{\r\nint timeout = 100000;\r\nwhile (timeout-- > 0) {\r\nif (!(inb(chip->io_port + ESM_AC97_INDEX) & 1))\r\nreturn 0;\r\n}\r\ndev_dbg(chip->card->dev, "ac97 timeout\n");\r\nreturn 1;\r\n}\r\nstatic void snd_es1968_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)\r\n{\r\nstruct es1968 *chip = ac97->private_data;\r\nsnd_es1968_ac97_wait(chip);\r\noutw(val, chip->io_port + ESM_AC97_DATA);\r\noutb(reg, chip->io_port + ESM_AC97_INDEX);\r\n}\r\nstatic unsigned short snd_es1968_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nu16 data = 0;\r\nstruct es1968 *chip = ac97->private_data;\r\nsnd_es1968_ac97_wait(chip);\r\noutb(reg | 0x80, chip->io_port + ESM_AC97_INDEX);\r\nif (!snd_es1968_ac97_wait_poll(chip)) {\r\ndata = inw(chip->io_port + ESM_AC97_DATA);\r\n}\r\nreturn data;\r\n}\r\nstatic void apu_index_set(struct es1968 *chip, u16 index)\r\n{\r\nint i;\r\n__maestro_write(chip, IDR1_CRAM_POINTER, index);\r\nfor (i = 0; i < 1000; i++)\r\nif (__maestro_read(chip, IDR1_CRAM_POINTER) == index)\r\nreturn;\r\ndev_dbg(chip->card->dev, "APU register select failed. (Timeout)\n");\r\n}\r\nstatic void apu_data_set(struct es1968 *chip, u16 data)\r\n{\r\nint i;\r\nfor (i = 0; i < 1000; i++) {\r\nif (__maestro_read(chip, IDR0_DATA_PORT) == data)\r\nreturn;\r\n__maestro_write(chip, IDR0_DATA_PORT, data);\r\n}\r\ndev_dbg(chip->card->dev, "APU register set probably failed (Timeout)!\n");\r\n}\r\nstatic void __apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 data)\r\n{\r\nif (snd_BUG_ON(channel >= NR_APUS))\r\nreturn;\r\n#ifdef CONFIG_PM_SLEEP\r\nchip->apu_map[channel][reg] = data;\r\n#endif\r\nreg |= (channel << 4);\r\napu_index_set(chip, reg);\r\napu_data_set(chip, data);\r\n}\r\nstatic void apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\n__apu_set_register(chip, channel, reg, data);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic u16 __apu_get_register(struct es1968 *chip, u16 channel, u8 reg)\r\n{\r\nif (snd_BUG_ON(channel >= NR_APUS))\r\nreturn 0;\r\nreg |= (channel << 4);\r\napu_index_set(chip, reg);\r\nreturn __maestro_read(chip, IDR0_DATA_PORT);\r\n}\r\nstatic u16 apu_get_register(struct es1968 *chip, u16 channel, u8 reg)\r\n{\r\nunsigned long flags;\r\nu16 v;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nv = __apu_get_register(chip, channel, reg);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn v;\r\n}\r\nstatic void wave_set_register(struct es1968 *chip, u16 reg, u16 value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\noutw(reg, chip->io_port + WC_INDEX);\r\noutw(value, chip->io_port + WC_DATA);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic u16 wave_get_register(struct es1968 *chip, u16 reg)\r\n{\r\nunsigned long flags;\r\nu16 value;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\noutw(reg, chip->io_port + WC_INDEX);\r\nvalue = inw(chip->io_port + WC_DATA);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn value;\r\n}\r\nstatic void snd_es1968_bob_stop(struct es1968 *chip)\r\n{\r\nu16 reg;\r\nreg = __maestro_read(chip, 0x11);\r\nreg &= ~ESM_BOB_ENABLE;\r\n__maestro_write(chip, 0x11, reg);\r\nreg = __maestro_read(chip, 0x17);\r\nreg &= ~ESM_BOB_START;\r\n__maestro_write(chip, 0x17, reg);\r\n}\r\nstatic void snd_es1968_bob_start(struct es1968 *chip)\r\n{\r\nint prescale;\r\nint divide;\r\nfor (prescale = 5; prescale < 12; prescale++)\r\nif (chip->bob_freq > (ESS_SYSCLK >> (prescale + 9)))\r\nbreak;\r\ndivide = 1;\r\nwhile ((prescale > 5) && (divide < 32)) {\r\nprescale--;\r\ndivide <<= 1;\r\n}\r\ndivide >>= 1;\r\nfor (; divide < 31; divide++)\r\nif (chip->bob_freq >\r\n((ESS_SYSCLK >> (prescale + 9)) / (divide + 1))) break;\r\nif (divide == 0) {\r\ndivide++;\r\nif (prescale > 5)\r\nprescale--;\r\n} else if (divide > 1)\r\ndivide--;\r\n__maestro_write(chip, 6, 0x9000 | (prescale << 5) | divide);\r\n__maestro_write(chip, 0x11, __maestro_read(chip, 0x11) | 1);\r\n__maestro_write(chip, 0x17, __maestro_read(chip, 0x17) | 1);\r\n}\r\nstatic void snd_es1968_bob_inc(struct es1968 *chip, int freq)\r\n{\r\nchip->bobclient++;\r\nif (chip->bobclient == 1) {\r\nchip->bob_freq = freq;\r\nsnd_es1968_bob_start(chip);\r\n} else if (chip->bob_freq < freq) {\r\nsnd_es1968_bob_stop(chip);\r\nchip->bob_freq = freq;\r\nsnd_es1968_bob_start(chip);\r\n}\r\n}\r\nstatic void snd_es1968_bob_dec(struct es1968 *chip)\r\n{\r\nchip->bobclient--;\r\nif (chip->bobclient <= 0)\r\nsnd_es1968_bob_stop(chip);\r\nelse if (chip->bob_freq > ESM_BOB_FREQ) {\r\nint max_freq = ESM_BOB_FREQ;\r\nstruct esschan *es;\r\nlist_for_each_entry(es, &chip->substream_list, list) {\r\nif (max_freq < es->bob_freq)\r\nmax_freq = es->bob_freq;\r\n}\r\nif (max_freq != chip->bob_freq) {\r\nsnd_es1968_bob_stop(chip);\r\nchip->bob_freq = max_freq;\r\nsnd_es1968_bob_start(chip);\r\n}\r\n}\r\n}\r\nstatic int\r\nsnd_es1968_calc_bob_rate(struct es1968 *chip, struct esschan *es,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint freq = runtime->rate * 4;\r\nif (es->fmt & ESS_FMT_STEREO)\r\nfreq <<= 1;\r\nif (es->fmt & ESS_FMT_16BIT)\r\nfreq <<= 1;\r\nfreq /= es->frag_size;\r\nif (freq < ESM_BOB_FREQ)\r\nfreq = ESM_BOB_FREQ;\r\nelse if (freq > ESM_BOB_FREQ_MAX)\r\nfreq = ESM_BOB_FREQ_MAX;\r\nreturn freq;\r\n}\r\nstatic u32 snd_es1968_compute_rate(struct es1968 *chip, u32 freq)\r\n{\r\nu32 rate = (freq << 16) / chip->clock;\r\n#if 0\r\nif (rate > 0x10000)\r\nrate = 0x10000;\r\n#endif\r\nreturn rate;\r\n}\r\nstatic inline unsigned int\r\nsnd_es1968_get_dma_ptr(struct es1968 *chip, struct esschan *es)\r\n{\r\nunsigned int offset;\r\noffset = apu_get_register(chip, es->apu[0], 5);\r\noffset -= es->base[0];\r\nreturn (offset & 0xFFFE);\r\n}\r\nstatic void snd_es1968_apu_set_freq(struct es1968 *chip, int apu, int freq)\r\n{\r\napu_set_register(chip, apu, 2,\r\n(apu_get_register(chip, apu, 2) & 0x00FF) |\r\n((freq & 0xff) << 8) | 0x10);\r\napu_set_register(chip, apu, 3, freq >> 8);\r\n}\r\nstatic inline void snd_es1968_trigger_apu(struct es1968 *esm, int apu, int mode)\r\n{\r\n__apu_set_register(esm, apu, 0,\r\n(__apu_get_register(esm, apu, 0) & 0xff0f) |\r\n(mode << 4));\r\n}\r\nstatic void snd_es1968_pcm_start(struct es1968 *chip, struct esschan *es)\r\n{\r\nspin_lock(&chip->reg_lock);\r\n__apu_set_register(chip, es->apu[0], 5, es->base[0]);\r\nsnd_es1968_trigger_apu(chip, es->apu[0], es->apu_mode[0]);\r\nif (es->mode == ESM_MODE_CAPTURE) {\r\n__apu_set_register(chip, es->apu[2], 5, es->base[2]);\r\nsnd_es1968_trigger_apu(chip, es->apu[2], es->apu_mode[2]);\r\n}\r\nif (es->fmt & ESS_FMT_STEREO) {\r\n__apu_set_register(chip, es->apu[1], 5, es->base[1]);\r\nsnd_es1968_trigger_apu(chip, es->apu[1], es->apu_mode[1]);\r\nif (es->mode == ESM_MODE_CAPTURE) {\r\n__apu_set_register(chip, es->apu[3], 5, es->base[3]);\r\nsnd_es1968_trigger_apu(chip, es->apu[3], es->apu_mode[3]);\r\n}\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n}\r\nstatic void snd_es1968_pcm_stop(struct es1968 *chip, struct esschan *es)\r\n{\r\nspin_lock(&chip->reg_lock);\r\nsnd_es1968_trigger_apu(chip, es->apu[0], 0);\r\nsnd_es1968_trigger_apu(chip, es->apu[1], 0);\r\nif (es->mode == ESM_MODE_CAPTURE) {\r\nsnd_es1968_trigger_apu(chip, es->apu[2], 0);\r\nsnd_es1968_trigger_apu(chip, es->apu[3], 0);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n}\r\nstatic void snd_es1968_program_wavecache(struct es1968 *chip, struct esschan *es,\r\nint channel, u32 addr, int capture)\r\n{\r\nu32 tmpval = (addr - 0x10) & 0xFFF8;\r\nif (! capture) {\r\nif (!(es->fmt & ESS_FMT_16BIT))\r\ntmpval |= 4;\r\nif (es->fmt & ESS_FMT_STEREO)\r\ntmpval |= 2;\r\n}\r\nwave_set_register(chip, es->apu[channel] << 3, tmpval);\r\n#ifdef CONFIG_PM_SLEEP\r\nes->wc_map[channel] = tmpval;\r\n#endif\r\n}\r\nstatic void snd_es1968_playback_setup(struct es1968 *chip, struct esschan *es,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nu32 pa;\r\nint high_apu = 0;\r\nint channel, apu;\r\nint i, size;\r\nunsigned long flags;\r\nu32 freq;\r\nsize = es->dma_size >> es->wav_shift;\r\nif (es->fmt & ESS_FMT_STEREO)\r\nhigh_apu++;\r\nfor (channel = 0; channel <= high_apu; channel++) {\r\napu = es->apu[channel];\r\nsnd_es1968_program_wavecache(chip, es, channel, es->memory->buf.addr, 0);\r\npa = es->memory->buf.addr;\r\npa -= chip->dma.addr;\r\npa >>= 1;\r\npa |= 0x00400000;\r\nif (es->fmt & ESS_FMT_STEREO) {\r\nif (channel)\r\npa |= 0x00800000;\r\nif (es->fmt & ESS_FMT_16BIT)\r\npa >>= 1;\r\n}\r\nes->base[channel] = pa & 0xFFFF;\r\nfor (i = 0; i < 16; i++)\r\napu_set_register(chip, apu, i, 0x0000);\r\napu_set_register(chip, apu, 4, ((pa >> 16) & 0xFF) << 8);\r\napu_set_register(chip, apu, 5, pa & 0xFFFF);\r\napu_set_register(chip, apu, 6, (pa + size) & 0xFFFF);\r\napu_set_register(chip, apu, 7, size);\r\napu_set_register(chip, apu, 8, 0x0000);\r\napu_set_register(chip, apu, 9, 0xD000);\r\napu_set_register(chip, apu, 11, 0x0000);\r\napu_set_register(chip, apu, 0, 0x400F);\r\nif (es->fmt & ESS_FMT_16BIT)\r\nes->apu_mode[channel] = ESM_APU_16BITLINEAR;\r\nelse\r\nes->apu_mode[channel] = ESM_APU_8BITLINEAR;\r\nif (es->fmt & ESS_FMT_STEREO) {\r\napu_set_register(chip, apu, 10,\r\n0x8F00 | (channel ? 0 : 0x10));\r\nes->apu_mode[channel] += 1;\r\n} else\r\napu_set_register(chip, apu, 10, 0x8F08);\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\noutw(1, chip->io_port + 0x04);\r\noutw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nfreq = runtime->rate;\r\nif (freq > 48000)\r\nfreq = 48000;\r\nif (freq < 4000)\r\nfreq = 4000;\r\nif (!(es->fmt & ESS_FMT_16BIT) && !(es->fmt & ESS_FMT_STEREO))\r\nfreq >>= 1;\r\nfreq = snd_es1968_compute_rate(chip, freq);\r\nsnd_es1968_apu_set_freq(chip, es->apu[0], freq);\r\nsnd_es1968_apu_set_freq(chip, es->apu[1], freq);\r\n}\r\nstatic void init_capture_apu(struct es1968 *chip, struct esschan *es, int channel,\r\nunsigned int pa, unsigned int bsize,\r\nint mode, int route)\r\n{\r\nint i, apu = es->apu[channel];\r\nes->apu_mode[channel] = mode;\r\nsnd_es1968_program_wavecache(chip, es, channel, pa, 1);\r\npa -= chip->dma.addr;\r\npa >>= 1;\r\nes->base[channel] = pa & 0xFFFF;\r\npa |= 0x00400000;\r\nfor (i = 0; i < 16; i++)\r\napu_set_register(chip, apu, i, 0x0000);\r\napu_set_register(chip, apu, 2, 0x8);\r\napu_set_register(chip, apu, 4, ((pa >> 16) & 0xFF) << 8);\r\napu_set_register(chip, apu, 5, pa & 0xFFFF);\r\napu_set_register(chip, apu, 6, (pa + bsize) & 0xFFFF);\r\napu_set_register(chip, apu, 7, bsize);\r\napu_set_register(chip, apu, 8, 0x00F0);\r\napu_set_register(chip, apu, 9, 0x0000);\r\napu_set_register(chip, apu, 10, 0x8F08);\r\napu_set_register(chip, apu, 11, route);\r\napu_set_register(chip, apu, 0, 0x400F);\r\n}\r\nstatic void snd_es1968_capture_setup(struct es1968 *chip, struct esschan *es,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint size;\r\nu32 freq;\r\nunsigned long flags;\r\nsize = es->dma_size >> es->wav_shift;\r\ninit_capture_apu(chip, es, 2,\r\nes->mixbuf->buf.addr, ESM_MIXBUF_SIZE/4,\r\nESM_APU_INPUTMIXER, 0x14);\r\ninit_capture_apu(chip, es, 0, es->memory->buf.addr, size,\r\nESM_APU_SRCONVERTOR, es->apu[2]);\r\nif (es->fmt & ESS_FMT_STEREO) {\r\ninit_capture_apu(chip, es, 3,\r\nes->mixbuf->buf.addr + ESM_MIXBUF_SIZE/2,\r\nESM_MIXBUF_SIZE/4,\r\nESM_APU_INPUTMIXER, 0x15);\r\ninit_capture_apu(chip, es, 1,\r\nes->memory->buf.addr + size*2, size,\r\nESM_APU_SRCONVERTOR, es->apu[3]);\r\n}\r\nfreq = runtime->rate;\r\nif (freq > 47999)\r\nfreq = 47999;\r\nif (freq < 4000)\r\nfreq = 4000;\r\nfreq = snd_es1968_compute_rate(chip, freq);\r\nsnd_es1968_apu_set_freq(chip, es->apu[0], freq);\r\nsnd_es1968_apu_set_freq(chip, es->apu[1], freq);\r\nfreq = 0x10000;\r\nsnd_es1968_apu_set_freq(chip, es->apu[2], freq);\r\nsnd_es1968_apu_set_freq(chip, es->apu[3], freq);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\noutw(1, chip->io_port + 0x04);\r\noutw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic int snd_es1968_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1968 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct esschan *es = runtime->private_data;\r\nes->dma_size = snd_pcm_lib_buffer_bytes(substream);\r\nes->frag_size = snd_pcm_lib_period_bytes(substream);\r\nes->wav_shift = 1;\r\nes->fmt = 0;\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\nes->fmt |= ESS_FMT_16BIT;\r\nif (runtime->channels > 1) {\r\nes->fmt |= ESS_FMT_STEREO;\r\nif (es->fmt & ESS_FMT_16BIT)\r\nes->wav_shift++;\r\n}\r\nes->bob_freq = snd_es1968_calc_bob_rate(chip, es, runtime);\r\nswitch (es->mode) {\r\ncase ESM_MODE_PLAY:\r\nsnd_es1968_playback_setup(chip, es, runtime);\r\nbreak;\r\ncase ESM_MODE_CAPTURE:\r\nsnd_es1968_capture_setup(chip, es, runtime);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es1968_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct es1968 *chip = snd_pcm_substream_chip(substream);\r\nstruct esschan *es = substream->runtime->private_data;\r\nspin_lock(&chip->substream_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (es->running)\r\nbreak;\r\nsnd_es1968_bob_inc(chip, es->bob_freq);\r\nes->count = 0;\r\nes->hwptr = 0;\r\nsnd_es1968_pcm_start(chip, es);\r\nes->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (! es->running)\r\nbreak;\r\nsnd_es1968_pcm_stop(chip, es);\r\nes->running = 0;\r\nsnd_es1968_bob_dec(chip);\r\nbreak;\r\n}\r\nspin_unlock(&chip->substream_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_es1968_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1968 *chip = snd_pcm_substream_chip(substream);\r\nstruct esschan *es = substream->runtime->private_data;\r\nunsigned int ptr;\r\nptr = snd_es1968_get_dma_ptr(chip, es) << es->wav_shift;\r\nreturn bytes_to_frames(substream->runtime, ptr % es->dma_size);\r\n}\r\nstatic int calc_available_memory_size(struct es1968 *chip)\r\n{\r\nint max_size = 0;\r\nstruct esm_memory *buf;\r\nmutex_lock(&chip->memory_mutex);\r\nlist_for_each_entry(buf, &chip->buf_list, list) {\r\nif (buf->empty && buf->buf.bytes > max_size)\r\nmax_size = buf->buf.bytes;\r\n}\r\nmutex_unlock(&chip->memory_mutex);\r\nif (max_size >= 128*1024)\r\nmax_size = 127*1024;\r\nreturn max_size;\r\n}\r\nstatic struct esm_memory *snd_es1968_new_memory(struct es1968 *chip, int size)\r\n{\r\nstruct esm_memory *buf;\r\nsize = ALIGN(size, ESM_MEM_ALIGN);\r\nmutex_lock(&chip->memory_mutex);\r\nlist_for_each_entry(buf, &chip->buf_list, list) {\r\nif (buf->empty && buf->buf.bytes >= size)\r\ngoto __found;\r\n}\r\nmutex_unlock(&chip->memory_mutex);\r\nreturn NULL;\r\n__found:\r\nif (buf->buf.bytes > size) {\r\nstruct esm_memory *chunk = kmalloc(sizeof(*chunk), GFP_KERNEL);\r\nif (chunk == NULL) {\r\nmutex_unlock(&chip->memory_mutex);\r\nreturn NULL;\r\n}\r\nchunk->buf = buf->buf;\r\nchunk->buf.bytes -= size;\r\nchunk->buf.area += size;\r\nchunk->buf.addr += size;\r\nchunk->empty = 1;\r\nbuf->buf.bytes = size;\r\nlist_add(&chunk->list, &buf->list);\r\n}\r\nbuf->empty = 0;\r\nmutex_unlock(&chip->memory_mutex);\r\nreturn buf;\r\n}\r\nstatic void snd_es1968_free_memory(struct es1968 *chip, struct esm_memory *buf)\r\n{\r\nstruct esm_memory *chunk;\r\nmutex_lock(&chip->memory_mutex);\r\nbuf->empty = 1;\r\nif (buf->list.prev != &chip->buf_list) {\r\nchunk = list_entry(buf->list.prev, struct esm_memory, list);\r\nif (chunk->empty) {\r\nchunk->buf.bytes += buf->buf.bytes;\r\nlist_del(&buf->list);\r\nkfree(buf);\r\nbuf = chunk;\r\n}\r\n}\r\nif (buf->list.next != &chip->buf_list) {\r\nchunk = list_entry(buf->list.next, struct esm_memory, list);\r\nif (chunk->empty) {\r\nbuf->buf.bytes += chunk->buf.bytes;\r\nlist_del(&chunk->list);\r\nkfree(chunk);\r\n}\r\n}\r\nmutex_unlock(&chip->memory_mutex);\r\n}\r\nstatic void snd_es1968_free_dmabuf(struct es1968 *chip)\r\n{\r\nstruct list_head *p;\r\nif (! chip->dma.area)\r\nreturn;\r\nsnd_dma_free_pages(&chip->dma);\r\nwhile ((p = chip->buf_list.next) != &chip->buf_list) {\r\nstruct esm_memory *chunk = list_entry(p, struct esm_memory, list);\r\nlist_del(p);\r\nkfree(chunk);\r\n}\r\n}\r\nstatic int\r\nsnd_es1968_init_dmabuf(struct es1968 *chip)\r\n{\r\nint err;\r\nstruct esm_memory *chunk;\r\nchip->dma.dev.type = SNDRV_DMA_TYPE_DEV;\r\nchip->dma.dev.dev = snd_dma_pci_data(chip->pci);\r\nerr = snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nchip->total_bufsize, &chip->dma);\r\nif (err < 0 || ! chip->dma.area) {\r\ndev_err(chip->card->dev,\r\n"can't allocate dma pages for size %d\n",\r\nchip->total_bufsize);\r\nreturn -ENOMEM;\r\n}\r\nif ((chip->dma.addr + chip->dma.bytes - 1) & ~((1 << 28) - 1)) {\r\nsnd_dma_free_pages(&chip->dma);\r\ndev_err(chip->card->dev, "DMA buffer beyond 256MB.\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&chip->buf_list);\r\nchunk = kmalloc(sizeof(*chunk), GFP_KERNEL);\r\nif (chunk == NULL) {\r\nsnd_es1968_free_dmabuf(chip);\r\nreturn -ENOMEM;\r\n}\r\nmemset(chip->dma.area, 0, ESM_MEM_ALIGN);\r\nchunk->buf = chip->dma;\r\nchunk->buf.area += ESM_MEM_ALIGN;\r\nchunk->buf.addr += ESM_MEM_ALIGN;\r\nchunk->buf.bytes -= ESM_MEM_ALIGN;\r\nchunk->empty = 1;\r\nlist_add(&chunk->list, &chip->buf_list);\r\nreturn 0;\r\n}\r\nstatic int snd_es1968_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct es1968 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct esschan *chan = runtime->private_data;\r\nint size = params_buffer_bytes(hw_params);\r\nif (chan->memory) {\r\nif (chan->memory->buf.bytes >= size) {\r\nruntime->dma_bytes = size;\r\nreturn 0;\r\n}\r\nsnd_es1968_free_memory(chip, chan->memory);\r\n}\r\nchan->memory = snd_es1968_new_memory(chip, size);\r\nif (chan->memory == NULL) {\r\ndev_dbg(chip->card->dev,\r\n"cannot allocate dma buffer: size = %d\n", size);\r\nreturn -ENOMEM;\r\n}\r\nsnd_pcm_set_runtime_buffer(substream, &chan->memory->buf);\r\nreturn 1;\r\n}\r\nstatic int snd_es1968_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1968 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct esschan *chan;\r\nif (runtime->private_data == NULL)\r\nreturn 0;\r\nchan = runtime->private_data;\r\nif (chan->memory) {\r\nsnd_es1968_free_memory(chip, chan->memory);\r\nchan->memory = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es1968_alloc_apu_pair(struct es1968 *chip, int type)\r\n{\r\nint apu;\r\nfor (apu = 0; apu < NR_APUS; apu += 2) {\r\nif (chip->apu[apu] == ESM_APU_FREE &&\r\nchip->apu[apu + 1] == ESM_APU_FREE) {\r\nchip->apu[apu] = chip->apu[apu + 1] = type;\r\nreturn apu;\r\n}\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic void snd_es1968_free_apu_pair(struct es1968 *chip, int apu)\r\n{\r\nchip->apu[apu] = chip->apu[apu + 1] = ESM_APU_FREE;\r\n}\r\nstatic int snd_es1968_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1968 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct esschan *es;\r\nint apu1;\r\napu1 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_PLAY);\r\nif (apu1 < 0)\r\nreturn apu1;\r\nes = kzalloc(sizeof(*es), GFP_KERNEL);\r\nif (!es) {\r\nsnd_es1968_free_apu_pair(chip, apu1);\r\nreturn -ENOMEM;\r\n}\r\nes->apu[0] = apu1;\r\nes->apu[1] = apu1 + 1;\r\nes->apu_mode[0] = 0;\r\nes->apu_mode[1] = 0;\r\nes->running = 0;\r\nes->substream = substream;\r\nes->mode = ESM_MODE_PLAY;\r\nruntime->private_data = es;\r\nruntime->hw = snd_es1968_playback;\r\nruntime->hw.buffer_bytes_max = runtime->hw.period_bytes_max =\r\ncalc_available_memory_size(chip);\r\nspin_lock_irq(&chip->substream_lock);\r\nlist_add(&es->list, &chip->substream_list);\r\nspin_unlock_irq(&chip->substream_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_es1968_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct es1968 *chip = snd_pcm_substream_chip(substream);\r\nstruct esschan *es;\r\nint apu1, apu2;\r\napu1 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_CAPTURE);\r\nif (apu1 < 0)\r\nreturn apu1;\r\napu2 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_RATECONV);\r\nif (apu2 < 0) {\r\nsnd_es1968_free_apu_pair(chip, apu1);\r\nreturn apu2;\r\n}\r\nes = kzalloc(sizeof(*es), GFP_KERNEL);\r\nif (!es) {\r\nsnd_es1968_free_apu_pair(chip, apu1);\r\nsnd_es1968_free_apu_pair(chip, apu2);\r\nreturn -ENOMEM;\r\n}\r\nes->apu[0] = apu1;\r\nes->apu[1] = apu1 + 1;\r\nes->apu[2] = apu2;\r\nes->apu[3] = apu2 + 1;\r\nes->apu_mode[0] = 0;\r\nes->apu_mode[1] = 0;\r\nes->apu_mode[2] = 0;\r\nes->apu_mode[3] = 0;\r\nes->running = 0;\r\nes->substream = substream;\r\nes->mode = ESM_MODE_CAPTURE;\r\nif ((es->mixbuf = snd_es1968_new_memory(chip, ESM_MIXBUF_SIZE)) == NULL) {\r\nsnd_es1968_free_apu_pair(chip, apu1);\r\nsnd_es1968_free_apu_pair(chip, apu2);\r\nkfree(es);\r\nreturn -ENOMEM;\r\n}\r\nmemset(es->mixbuf->buf.area, 0, ESM_MIXBUF_SIZE);\r\nruntime->private_data = es;\r\nruntime->hw = snd_es1968_capture;\r\nruntime->hw.buffer_bytes_max = runtime->hw.period_bytes_max =\r\ncalc_available_memory_size(chip) - 1024;\r\nsnd_pcm_hw_constraint_pow2(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES);\r\nspin_lock_irq(&chip->substream_lock);\r\nlist_add(&es->list, &chip->substream_list);\r\nspin_unlock_irq(&chip->substream_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_es1968_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1968 *chip = snd_pcm_substream_chip(substream);\r\nstruct esschan *es;\r\nif (substream->runtime->private_data == NULL)\r\nreturn 0;\r\nes = substream->runtime->private_data;\r\nspin_lock_irq(&chip->substream_lock);\r\nlist_del(&es->list);\r\nspin_unlock_irq(&chip->substream_lock);\r\nsnd_es1968_free_apu_pair(chip, es->apu[0]);\r\nkfree(es);\r\nreturn 0;\r\n}\r\nstatic int snd_es1968_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1968 *chip = snd_pcm_substream_chip(substream);\r\nstruct esschan *es;\r\nif (substream->runtime->private_data == NULL)\r\nreturn 0;\r\nes = substream->runtime->private_data;\r\nspin_lock_irq(&chip->substream_lock);\r\nlist_del(&es->list);\r\nspin_unlock_irq(&chip->substream_lock);\r\nsnd_es1968_free_memory(chip, es->mixbuf);\r\nsnd_es1968_free_apu_pair(chip, es->apu[0]);\r\nsnd_es1968_free_apu_pair(chip, es->apu[2]);\r\nkfree(es);\r\nreturn 0;\r\n}\r\nstatic void es1968_measure_clock(struct es1968 *chip)\r\n{\r\nint i, apu;\r\nunsigned int pa, offset, t;\r\nstruct esm_memory *memory;\r\nstruct timeval start_time, stop_time;\r\nif (chip->clock == 0)\r\nchip->clock = 48000;\r\nif ((apu = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_PLAY)) < 0) {\r\ndev_err(chip->card->dev, "Hmm, cannot find empty APU pair!?\n");\r\nreturn;\r\n}\r\nif ((memory = snd_es1968_new_memory(chip, CLOCK_MEASURE_BUFSIZE)) == NULL) {\r\ndev_warn(chip->card->dev,\r\n"cannot allocate dma buffer - using default clock %d\n",\r\nchip->clock);\r\nsnd_es1968_free_apu_pair(chip, apu);\r\nreturn;\r\n}\r\nmemset(memory->buf.area, 0, CLOCK_MEASURE_BUFSIZE);\r\nwave_set_register(chip, apu << 3, (memory->buf.addr - 0x10) & 0xfff8);\r\npa = (unsigned int)((memory->buf.addr - chip->dma.addr) >> 1);\r\npa |= 0x00400000;\r\nfor (i = 0; i < 16; i++)\r\napu_set_register(chip, apu, i, 0x0000);\r\napu_set_register(chip, apu, 0, 0x400f);\r\napu_set_register(chip, apu, 4, ((pa >> 16) & 0xff) << 8);\r\napu_set_register(chip, apu, 5, pa & 0xffff);\r\napu_set_register(chip, apu, 6, (pa + CLOCK_MEASURE_BUFSIZE/2) & 0xffff);\r\napu_set_register(chip, apu, 7, CLOCK_MEASURE_BUFSIZE/2);\r\napu_set_register(chip, apu, 8, 0x0000);\r\napu_set_register(chip, apu, 9, 0xD000);\r\napu_set_register(chip, apu, 10, 0x8F08);\r\napu_set_register(chip, apu, 11, 0x0000);\r\nspin_lock_irq(&chip->reg_lock);\r\noutw(1, chip->io_port + 0x04);\r\noutw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);\r\nspin_unlock_irq(&chip->reg_lock);\r\nsnd_es1968_apu_set_freq(chip, apu, ((unsigned int)48000 << 16) / chip->clock);\r\nchip->in_measurement = 1;\r\nchip->measure_apu = apu;\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_es1968_bob_inc(chip, ESM_BOB_FREQ);\r\n__apu_set_register(chip, apu, 5, pa & 0xffff);\r\nsnd_es1968_trigger_apu(chip, apu, ESM_APU_16BITLINEAR);\r\ndo_gettimeofday(&start_time);\r\nspin_unlock_irq(&chip->reg_lock);\r\nmsleep(50);\r\nspin_lock_irq(&chip->reg_lock);\r\noffset = __apu_get_register(chip, apu, 5);\r\ndo_gettimeofday(&stop_time);\r\nsnd_es1968_trigger_apu(chip, apu, 0);\r\nsnd_es1968_bob_dec(chip);\r\nchip->in_measurement = 0;\r\nspin_unlock_irq(&chip->reg_lock);\r\noffset -= (pa & 0xffff);\r\noffset &= 0xfffe;\r\noffset += chip->measure_count * (CLOCK_MEASURE_BUFSIZE/2);\r\nt = stop_time.tv_sec - start_time.tv_sec;\r\nt *= 1000000;\r\nif (stop_time.tv_usec < start_time.tv_usec)\r\nt -= start_time.tv_usec - stop_time.tv_usec;\r\nelse\r\nt += stop_time.tv_usec - start_time.tv_usec;\r\nif (t == 0) {\r\ndev_err(chip->card->dev, "?? calculation error..\n");\r\n} else {\r\noffset *= 1000;\r\noffset = (offset / t) * 1000 + ((offset % t) * 1000) / t;\r\nif (offset < 47500 || offset > 48500) {\r\nif (offset >= 40000 && offset <= 50000)\r\nchip->clock = (chip->clock * offset) / 48000;\r\n}\r\ndev_info(chip->card->dev, "clocking to %d\n", chip->clock);\r\n}\r\nsnd_es1968_free_memory(chip, memory);\r\nsnd_es1968_free_apu_pair(chip, apu);\r\n}\r\nstatic void snd_es1968_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct es1968 *esm = pcm->private_data;\r\nsnd_es1968_free_dmabuf(esm);\r\nesm->pcm = NULL;\r\n}\r\nstatic int\r\nsnd_es1968_pcm(struct es1968 *chip, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_es1968_init_dmabuf(chip)) < 0)\r\nreturn err;\r\nwave_set_register(chip, 0x01FC, chip->dma.addr >> 12);\r\nwave_set_register(chip, 0x01FD, chip->dma.addr >> 12);\r\nwave_set_register(chip, 0x01FE, chip->dma.addr >> 12);\r\nwave_set_register(chip, 0x01FF, chip->dma.addr >> 12);\r\nif ((err = snd_pcm_new(chip->card, "ESS Maestro", device,\r\nchip->playback_streams,\r\nchip->capture_streams, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\npcm->private_free = snd_es1968_pcm_free;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_es1968_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_es1968_capture_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "ESS Maestro");\r\nchip->pcm = pcm;\r\nreturn 0;\r\n}\r\nstatic void snd_es1968_suppress_jitter(struct es1968 *chip, struct esschan *es)\r\n{\r\nunsigned int cp1;\r\nunsigned int cp2;\r\nunsigned int diff;\r\ncp1 = __apu_get_register(chip, 0, 5);\r\ncp2 = __apu_get_register(chip, 1, 5);\r\ndiff = (cp1 > cp2 ? cp1 - cp2 : cp2 - cp1);\r\nif (diff > 1)\r\n__maestro_write(chip, IDR0_DATA_PORT, cp1);\r\n}\r\nstatic void snd_es1968_update_pcm(struct es1968 *chip, struct esschan *es)\r\n{\r\nunsigned int hwptr;\r\nunsigned int diff;\r\nstruct snd_pcm_substream *subs = es->substream;\r\nif (subs == NULL || !es->running)\r\nreturn;\r\nhwptr = snd_es1968_get_dma_ptr(chip, es) << es->wav_shift;\r\nhwptr %= es->dma_size;\r\ndiff = (es->dma_size + hwptr - es->hwptr) % es->dma_size;\r\nes->hwptr = hwptr;\r\nes->count += diff;\r\nif (es->count > es->frag_size) {\r\nspin_unlock(&chip->substream_lock);\r\nsnd_pcm_period_elapsed(subs);\r\nspin_lock(&chip->substream_lock);\r\nes->count %= es->frag_size;\r\n}\r\n}\r\nstatic void es1968_update_hw_volume(struct work_struct *work)\r\n{\r\nstruct es1968 *chip = container_of(work, struct es1968, hwvol_work);\r\nint x, val;\r\nx = inb(chip->io_port + 0x1c) & 0xee;\r\noutb(0x88, chip->io_port + 0x1c);\r\noutb(0x88, chip->io_port + 0x1d);\r\noutb(0x88, chip->io_port + 0x1e);\r\noutb(0x88, chip->io_port + 0x1f);\r\nif (chip->in_suspend)\r\nreturn;\r\n#ifndef CONFIG_SND_ES1968_INPUT\r\nif (! chip->master_switch || ! chip->master_volume)\r\nreturn;\r\nval = snd_ac97_read(chip->ac97, AC97_MASTER);\r\nswitch (x) {\r\ncase 0x88:\r\nval ^= 0x8000;\r\nbreak;\r\ncase 0xaa:\r\nif ((val & 0x7f) > 0)\r\nval--;\r\nif ((val & 0x7f00) > 0)\r\nval -= 0x0100;\r\nbreak;\r\ncase 0x66:\r\nif ((val & 0x7f) < 0x1f)\r\nval++;\r\nif ((val & 0x7f00) < 0x1f00)\r\nval += 0x0100;\r\nbreak;\r\n}\r\nif (snd_ac97_update(chip->ac97, AC97_MASTER, val))\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->master_volume->id);\r\n#else\r\nif (!chip->input_dev)\r\nreturn;\r\nval = 0;\r\nswitch (x) {\r\ncase 0x88:\r\nval = KEY_MUTE;\r\nbreak;\r\ncase 0xaa:\r\nval = KEY_VOLUMEUP;\r\nbreak;\r\ncase 0x66:\r\nval = KEY_VOLUMEDOWN;\r\nbreak;\r\n}\r\nif (val) {\r\ninput_report_key(chip->input_dev, val, 1);\r\ninput_sync(chip->input_dev);\r\ninput_report_key(chip->input_dev, val, 0);\r\ninput_sync(chip->input_dev);\r\n}\r\n#endif\r\n}\r\nstatic irqreturn_t snd_es1968_interrupt(int irq, void *dev_id)\r\n{\r\nstruct es1968 *chip = dev_id;\r\nu32 event;\r\nif (!(event = inb(chip->io_port + 0x1A)))\r\nreturn IRQ_NONE;\r\noutw(inw(chip->io_port + 4) & 1, chip->io_port + 4);\r\nif (event & ESM_HWVOL_IRQ)\r\nschedule_work(&chip->hwvol_work);\r\noutb(0xFF, chip->io_port + 0x1A);\r\nif ((event & ESM_MPU401_IRQ) && chip->rmidi) {\r\nsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\r\n}\r\nif (event & ESM_SOUND_IRQ) {\r\nstruct esschan *es;\r\nspin_lock(&chip->substream_lock);\r\nlist_for_each_entry(es, &chip->substream_list, list) {\r\nif (es->running) {\r\nsnd_es1968_update_pcm(chip, es);\r\nif (es->fmt & ESS_FMT_STEREO)\r\nsnd_es1968_suppress_jitter(chip, es);\r\n}\r\n}\r\nspin_unlock(&chip->substream_lock);\r\nif (chip->in_measurement) {\r\nunsigned int curp = __apu_get_register(chip, chip->measure_apu, 5);\r\nif (curp < chip->measure_lastpos)\r\nchip->measure_count++;\r\nchip->measure_lastpos = curp;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nsnd_es1968_mixer(struct es1968 *chip)\r\n{\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\n#ifndef CONFIG_SND_ES1968_INPUT\r\nstruct snd_ctl_elem_id elem_id;\r\n#endif\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_es1968_ac97_write,\r\n.read = snd_es1968_ac97_read,\r\n};\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)\r\nreturn err;\r\npbus->no_vra = 1;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nif ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97)) < 0)\r\nreturn err;\r\n#ifndef CONFIG_SND_ES1968_INPUT\r\nmemset(&elem_id, 0, sizeof(elem_id));\r\nelem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(elem_id.name, "Master Playback Switch");\r\nchip->master_switch = snd_ctl_find_id(chip->card, &elem_id);\r\nmemset(&elem_id, 0, sizeof(elem_id));\r\nelem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(elem_id.name, "Master Playback Volume");\r\nchip->master_volume = snd_ctl_find_id(chip->card, &elem_id);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void snd_es1968_ac97_reset(struct es1968 *chip)\r\n{\r\nunsigned long ioaddr = chip->io_port;\r\nunsigned short save_ringbus_a;\r\nunsigned short save_68;\r\nunsigned short w;\r\nunsigned int vend;\r\nsave_ringbus_a = inw(ioaddr + 0x36);\r\noutw(inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);\r\noutw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);\r\noutw(0x0000, ioaddr + 0x36);\r\nsave_68 = inw(ioaddr + 0x68);\r\npci_read_config_word(chip->pci, 0x58, &w);\r\npci_read_config_dword(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);\r\nif (w & 1)\r\nsave_68 |= 0x10;\r\noutw(0xfffe, ioaddr + 0x64);\r\noutw(0x0001, ioaddr + 0x68);\r\noutw(0x0000, ioaddr + 0x60);\r\nudelay(20);\r\noutw(0x0001, ioaddr + 0x60);\r\nmsleep(20);\r\noutw(save_68 | 0x1, ioaddr + 0x68);\r\noutw((inw(ioaddr + 0x38) & 0xfffc) | 0x1, ioaddr + 0x38);\r\noutw((inw(ioaddr + 0x3a) & 0xfffc) | 0x1, ioaddr + 0x3a);\r\noutw((inw(ioaddr + 0x3c) & 0xfffc) | 0x1, ioaddr + 0x3c);\r\noutw(0x0000, ioaddr + 0x36);\r\noutw(0xfff7, ioaddr + 0x64);\r\nsave_68 = inw(ioaddr + 0x68);\r\noutw(0x0009, ioaddr + 0x68);\r\noutw(0x0001, ioaddr + 0x60);\r\nudelay(20);\r\noutw(0x0009, ioaddr + 0x60);\r\nmsleep(500);\r\noutw(inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);\r\noutw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);\r\n#if 0\r\ndev_info(chip->card->dev, "trying software reset\n");\r\noutb(0x80 | 0x7c, ioaddr + 0x30);\r\nfor (w = 0;; w++) {\r\nif ((inw(ioaddr + 0x30) & 1) == 0) {\r\nif (inb(ioaddr + 0x32) != 0)\r\nbreak;\r\noutb(0x80 | 0x7d, ioaddr + 0x30);\r\nif (((inw(ioaddr + 0x30) & 1) == 0)\r\n&& (inb(ioaddr + 0x32) != 0))\r\nbreak;\r\noutb(0x80 | 0x7f, ioaddr + 0x30);\r\nif (((inw(ioaddr + 0x30) & 1) == 0)\r\n&& (inb(ioaddr + 0x32) != 0))\r\nbreak;\r\n}\r\nif (w > 10000) {\r\noutb(inb(ioaddr + 0x37) | 0x08, ioaddr + 0x37);\r\nmsleep(500);\r\noutb(inb(ioaddr + 0x37) & ~0x08,\r\nioaddr + 0x37);\r\nudelay(1);\r\noutw(0x80, ioaddr + 0x30);\r\nfor (w = 0; w < 10000; w++) {\r\nif ((inw(ioaddr + 0x30) & 1) == 0)\r\nbreak;\r\n}\r\n}\r\n}\r\n#endif\r\nif (vend == NEC_VERSA_SUBID1 || vend == NEC_VERSA_SUBID2) {\r\noutw(0xf9ff, ioaddr + 0x64);\r\noutw(inw(ioaddr + 0x68) | 0x600, ioaddr + 0x68);\r\noutw(0x0209, ioaddr + 0x60);\r\n}\r\noutw(save_ringbus_a, ioaddr + 0x36);\r\noutb(inb(ioaddr+0xc0)|(1<<5), ioaddr+0xc0);\r\noutb(0xff, ioaddr+0xc3);\r\noutb(0xff, ioaddr+0xc4);\r\noutb(0xff, ioaddr+0xc6);\r\noutb(0xff, ioaddr+0xc8);\r\noutb(0x3f, ioaddr+0xcf);\r\noutb(0x3f, ioaddr+0xd0);\r\n}\r\nstatic void snd_es1968_reset(struct es1968 *chip)\r\n{\r\noutw(ESM_RESET_MAESTRO | ESM_RESET_DIRECTSOUND,\r\nchip->io_port + ESM_PORT_HOST_IRQ);\r\nudelay(10);\r\noutw(0x0000, chip->io_port + ESM_PORT_HOST_IRQ);\r\nudelay(10);\r\n}\r\nstatic void snd_es1968_chip_init(struct es1968 *chip)\r\n{\r\nstruct pci_dev *pci = chip->pci;\r\nint i;\r\nunsigned long iobase = chip->io_port;\r\nu16 w;\r\nu32 n;\r\npci_read_config_word(pci, ESM_CONFIG_A, &w);\r\nw &= ~DMA_CLEAR;\r\nw &= ~(PIC_SNOOP1 | PIC_SNOOP2);\r\nw &= ~SAFEGUARD;\r\nw |= POST_WRITE;\r\nw |= PCI_TIMING;\r\nw &= ~SWAP_LR;\r\nw &= ~SUBTR_DECODE;\r\npci_write_config_word(pci, ESM_CONFIG_A, w);\r\npci_read_config_word(pci, ESM_CONFIG_B, &w);\r\nw &= ~(1 << 15);\r\nw &= ~(1 << 14);\r\nw &= ~SPDIF_CONFB;\r\nw |= HWV_CONFB;\r\nw |= DEBOUNCE;\r\nw &= ~GPIO_CONFB;\r\nw |= CHI_CONFB;\r\nw &= ~IDMA_CONFB;\r\nw &= ~MIDI_FIX;\r\nw &= ~(1 << 1);\r\nw &= ~IRQ_TO_ISA;\r\npci_write_config_word(pci, ESM_CONFIG_B, w);\r\npci_read_config_word(pci, ESM_DDMA, &w);\r\nw &= ~(1 << 0);\r\npci_write_config_word(pci, ESM_DDMA, w);\r\npci_read_config_word(pci, ESM_LEGACY_AUDIO_CONTROL, &w);\r\nw |= ESS_DISABLE_AUDIO;\r\nw &= ~ESS_ENABLE_SERIAL_IRQ;\r\nw &= ~(0x1f);\r\npci_write_config_word(pci, ESM_LEGACY_AUDIO_CONTROL, w);\r\npci_read_config_word(pci, 0x58, &w);\r\nw|=1<<2;\r\nw|=1<<3;\r\nw&=~(1<<11);\r\npci_write_config_word(pci, 0x58, w);\r\nsnd_es1968_reset(chip);\r\noutw(0xC090, iobase + ESM_RING_BUS_DEST);\r\nudelay(20);\r\noutw(0x3000, iobase + ESM_RING_BUS_CONTR_A);\r\nudelay(20);\r\nsnd_es1968_ac97_reset(chip);\r\nn = inl(iobase + ESM_RING_BUS_CONTR_B);\r\nn &= ~RINGB_EN_SPDIF;\r\noutl(n, iobase + ESM_RING_BUS_CONTR_B);\r\noutb(0x88, iobase+0x1c);\r\noutb(0x88, iobase+0x1d);\r\noutb(0x88, iobase+0x1e);\r\noutb(0x88, iobase+0x1f);\r\noutb(0, iobase + ASSP_CONTROL_B);\r\noutb(3, iobase + ASSP_CONTROL_A);\r\noutb(0, iobase + ASSP_CONTROL_C);\r\nfor (i = 0; i < 16; i++) {\r\noutw(0x01E0 + i, iobase + WC_INDEX);\r\noutw(0x0000, iobase + WC_DATA);\r\noutw(0x01D0 + i, iobase + WC_INDEX);\r\noutw(0x0000, iobase + WC_DATA);\r\n}\r\nwave_set_register(chip, IDR7_WAVE_ROMRAM,\r\n(wave_get_register(chip, IDR7_WAVE_ROMRAM) & 0xFF00));\r\nwave_set_register(chip, IDR7_WAVE_ROMRAM,\r\nwave_get_register(chip, IDR7_WAVE_ROMRAM) | 0x100);\r\nwave_set_register(chip, IDR7_WAVE_ROMRAM,\r\nwave_get_register(chip, IDR7_WAVE_ROMRAM) & ~0x200);\r\nwave_set_register(chip, IDR7_WAVE_ROMRAM,\r\nwave_get_register(chip, IDR7_WAVE_ROMRAM) | ~0x400);\r\nmaestro_write(chip, IDR2_CRAM_DATA, 0x0000);\r\nmaestro_write(chip, 0x08, 0xB004);\r\nmaestro_write(chip, 0x09, 0x001B);\r\nmaestro_write(chip, 0x0A, 0x8000);\r\nmaestro_write(chip, 0x0B, 0x3F37);\r\nmaestro_write(chip, 0x0C, 0x0098);\r\nmaestro_write(chip, 0x0C,\r\n(maestro_read(chip, 0x0C) & ~0xF000) | 0x8000);\r\nmaestro_write(chip, 0x0C,\r\n(maestro_read(chip, 0x0C) & ~0x0F00) | 0x0500);\r\nmaestro_write(chip, 0x0D, 0x7632);\r\nw = inw(iobase + WC_CONTROL);\r\nw &= ~0xFA00;\r\nw |= 0xA000;\r\nw &= ~0x0200;\r\nw |= 0x0100;\r\nw |= 0x0080;\r\nw &= ~0x0060;\r\nw |= 0x0020;\r\nw &= ~0x000C;\r\nw &= ~0x0001;\r\noutw(w, iobase + WC_CONTROL);\r\nfor (i = 0; i < NR_APUS; i++) {\r\nfor (w = 0; w < NR_APU_REGS; w++)\r\napu_set_register(chip, i, w, 0);\r\n}\r\n}\r\nstatic void snd_es1968_start_irq(struct es1968 *chip)\r\n{\r\nunsigned short w;\r\nw = ESM_HIRQ_DSIE | ESM_HIRQ_HW_VOLUME;\r\nif (chip->rmidi)\r\nw |= ESM_HIRQ_MPU401;\r\noutb(w, chip->io_port + 0x1A);\r\noutw(w, chip->io_port + ESM_PORT_HOST_IRQ);\r\n}\r\nstatic int es1968_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct es1968 *chip = card->private_data;\r\nif (! chip->do_pm)\r\nreturn 0;\r\nchip->in_suspend = 1;\r\ncancel_work_sync(&chip->hwvol_work);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_ac97_suspend(chip->ac97);\r\nsnd_es1968_bob_stop(chip);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int es1968_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct es1968 *chip = card->private_data;\r\nstruct esschan *es;\r\nif (! chip->do_pm)\r\nreturn 0;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\ndev_err(dev, "pci_enable_device failed, disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nsnd_es1968_chip_init(chip);\r\nif (chip->dma.addr) {\r\nwave_set_register(chip, 0x01FC, chip->dma.addr >> 12);\r\n}\r\nsnd_es1968_start_irq(chip);\r\nsnd_ac97_resume(chip->ac97);\r\nlist_for_each_entry(es, &chip->substream_list, list) {\r\nswitch (es->mode) {\r\ncase ESM_MODE_PLAY:\r\nsnd_es1968_playback_setup(chip, es, es->substream->runtime);\r\nbreak;\r\ncase ESM_MODE_CAPTURE:\r\nsnd_es1968_capture_setup(chip, es, es->substream->runtime);\r\nbreak;\r\n}\r\n}\r\nif (chip->bobclient)\r\nsnd_es1968_bob_start(chip);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nchip->in_suspend = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_es1968_create_gameport(struct es1968 *chip, int dev)\r\n{\r\nstruct gameport *gp;\r\nstruct resource *r;\r\nu16 val;\r\nif (!joystick[dev])\r\nreturn -ENODEV;\r\nr = request_region(JOYSTICK_ADDR, 8, "ES1968 gameport");\r\nif (!r)\r\nreturn -EBUSY;\r\nchip->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\ndev_err(chip->card->dev,\r\n"cannot allocate memory for gameport\n");\r\nrelease_and_free_resource(r);\r\nreturn -ENOMEM;\r\n}\r\npci_read_config_word(chip->pci, ESM_LEGACY_AUDIO_CONTROL, &val);\r\npci_write_config_word(chip->pci, ESM_LEGACY_AUDIO_CONTROL, val | 0x04);\r\ngameport_set_name(gp, "ES1968 Gameport");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));\r\ngameport_set_dev_parent(gp, &chip->pci->dev);\r\ngp->io = JOYSTICK_ADDR;\r\ngameport_set_port_data(gp, r);\r\ngameport_register_port(gp);\r\nreturn 0;\r\n}\r\nstatic void snd_es1968_free_gameport(struct es1968 *chip)\r\n{\r\nif (chip->gameport) {\r\nstruct resource *r = gameport_get_port_data(chip->gameport);\r\ngameport_unregister_port(chip->gameport);\r\nchip->gameport = NULL;\r\nrelease_and_free_resource(r);\r\n}\r\n}\r\nstatic inline int snd_es1968_create_gameport(struct es1968 *chip, int dev) { return -ENOSYS; }\r\nstatic inline void snd_es1968_free_gameport(struct es1968 *chip) { }\r\nstatic int snd_es1968_input_register(struct es1968 *chip)\r\n{\r\nstruct input_dev *input_dev;\r\nint err;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nsnprintf(chip->phys, sizeof(chip->phys), "pci-%s/input0",\r\npci_name(chip->pci));\r\ninput_dev->name = chip->card->driver;\r\ninput_dev->phys = chip->phys;\r\ninput_dev->id.bustype = BUS_PCI;\r\ninput_dev->id.vendor = chip->pci->vendor;\r\ninput_dev->id.product = chip->pci->device;\r\ninput_dev->dev.parent = &chip->pci->dev;\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(KEY_MUTE, input_dev->keybit);\r\n__set_bit(KEY_VOLUMEDOWN, input_dev->keybit);\r\n__set_bit(KEY_VOLUMEUP, input_dev->keybit);\r\nerr = input_register_device(input_dev);\r\nif (err) {\r\ninput_free_device(input_dev);\r\nreturn err;\r\n}\r\nchip->input_dev = input_dev;\r\nreturn 0;\r\n}\r\nstatic void snd_es1968_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)\r\n{\r\nstruct es1968 *chip = tea->private_data;\r\nstruct snd_es1968_tea575x_gpio gpio = *get_tea575x_gpio(chip);\r\nu16 val = 0;\r\nval |= (pins & TEA575X_DATA) ? (1 << gpio.data) : 0;\r\nval |= (pins & TEA575X_CLK) ? (1 << gpio.clk) : 0;\r\nval |= (pins & TEA575X_WREN) ? (1 << gpio.wren) : 0;\r\noutw(val, chip->io_port + GPIO_DATA);\r\n}\r\nstatic u8 snd_es1968_tea575x_get_pins(struct snd_tea575x *tea)\r\n{\r\nstruct es1968 *chip = tea->private_data;\r\nstruct snd_es1968_tea575x_gpio gpio = *get_tea575x_gpio(chip);\r\nu16 val = inw(chip->io_port + GPIO_DATA);\r\nu8 ret = 0;\r\nif (val & (1 << gpio.data))\r\nret |= TEA575X_DATA;\r\nif (val & (1 << gpio.most))\r\nret |= TEA575X_MOST;\r\nreturn ret;\r\n}\r\nstatic void snd_es1968_tea575x_set_direction(struct snd_tea575x *tea, bool output)\r\n{\r\nstruct es1968 *chip = tea->private_data;\r\nunsigned long io = chip->io_port + GPIO_DATA;\r\nu16 odir = inw(io + IO_DIR);\r\nstruct snd_es1968_tea575x_gpio gpio = *get_tea575x_gpio(chip);\r\nif (output) {\r\noutw(~((1 << gpio.data) | (1 << gpio.clk) | (1 << gpio.wren)),\r\nio + IO_MASK);\r\noutw(odir | (1 << gpio.data) | (1 << gpio.clk) | (1 << gpio.wren),\r\nio + IO_DIR);\r\n} else {\r\noutw(~((1 << gpio.clk) | (1 << gpio.wren) | (1 << gpio.data) | (1 << gpio.most)),\r\nio + IO_MASK);\r\noutw((odir & ~((1 << gpio.data) | (1 << gpio.most)))\r\n| (1 << gpio.clk) | (1 << gpio.wren), io + IO_DIR);\r\n}\r\n}\r\nstatic int snd_es1968_free(struct es1968 *chip)\r\n{\r\ncancel_work_sync(&chip->hwvol_work);\r\n#ifdef CONFIG_SND_ES1968_INPUT\r\nif (chip->input_dev)\r\ninput_unregister_device(chip->input_dev);\r\n#endif\r\nif (chip->io_port) {\r\nif (chip->irq >= 0)\r\nsynchronize_irq(chip->irq);\r\noutw(1, chip->io_port + 0x04);\r\noutw(0, chip->io_port + ESM_PORT_HOST_IRQ);\r\n}\r\n#ifdef CONFIG_SND_ES1968_RADIO\r\nsnd_tea575x_exit(&chip->tea);\r\nv4l2_device_unregister(&chip->v4l2_dev);\r\n#endif\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nsnd_es1968_free_gameport(chip);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_es1968_dev_free(struct snd_device *device)\r\n{\r\nstruct es1968 *chip = device->device_data;\r\nreturn snd_es1968_free(chip);\r\n}\r\nstatic int snd_es1968_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nint total_bufsize,\r\nint play_streams,\r\nint capt_streams,\r\nint chip_type,\r\nint do_pm,\r\nint radio_nr,\r\nstruct es1968 **chip_ret)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_es1968_dev_free,\r\n};\r\nstruct es1968 *chip;\r\nint i, err;\r\n*chip_ret = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {\r\ndev_err(card->dev,\r\n"architecture does not support 28bit PCI busmaster DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (! chip) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip->type = chip_type;\r\nspin_lock_init(&chip->reg_lock);\r\nspin_lock_init(&chip->substream_lock);\r\nINIT_LIST_HEAD(&chip->buf_list);\r\nINIT_LIST_HEAD(&chip->substream_list);\r\nmutex_init(&chip->memory_mutex);\r\nINIT_WORK(&chip->hwvol_work, es1968_update_hw_volume);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nchip->total_bufsize = total_bufsize;\r\nchip->playback_streams = play_streams;\r\nchip->capture_streams = capt_streams;\r\nif ((err = pci_request_regions(pci, "ESS Maestro")) < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nchip->io_port = pci_resource_start(pci, 0);\r\nif (request_irq(pci->irq, snd_es1968_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_es1968_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nfor (i = 0; i < 32; i++)\r\nchip->maestro_map[i] = 0;\r\nfor (i = 0; i < NR_APUS; i++)\r\nchip->apu[i] = ESM_APU_FREE;\r\npci_set_master(pci);\r\nif (do_pm > 1) {\r\nunsigned short vend;\r\npci_read_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);\r\nfor (i = 0; i < (int)ARRAY_SIZE(pm_whitelist); i++) {\r\nif (chip->type == pm_whitelist[i].type &&\r\nvend == pm_whitelist[i].vendor) {\r\ndo_pm = 1;\r\nbreak;\r\n}\r\n}\r\nif (do_pm > 1) {\r\ndev_info(card->dev, "not attempting power management.\n");\r\ndo_pm = 0;\r\n}\r\n}\r\nchip->do_pm = do_pm;\r\nsnd_es1968_chip_init(chip);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_es1968_free(chip);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_SND_ES1968_RADIO\r\nif (chip->pci->subsystem_vendor != 0x125d)\r\ngoto no_radio;\r\nerr = v4l2_device_register(&pci->dev, &chip->v4l2_dev);\r\nif (err < 0) {\r\nsnd_es1968_free(chip);\r\nreturn err;\r\n}\r\nchip->tea.v4l2_dev = &chip->v4l2_dev;\r\nchip->tea.private_data = chip;\r\nchip->tea.radio_nr = radio_nr;\r\nchip->tea.ops = &snd_es1968_tea_ops;\r\nsprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));\r\nfor (i = 0; i < ARRAY_SIZE(snd_es1968_tea575x_gpios); i++) {\r\nchip->tea575x_tuner = i;\r\nif (!snd_tea575x_init(&chip->tea, THIS_MODULE)) {\r\ndev_info(card->dev, "detected TEA575x radio type %s\n",\r\nget_tea575x_gpio(chip)->name);\r\nstrlcpy(chip->tea.card, get_tea575x_gpio(chip)->name,\r\nsizeof(chip->tea.card));\r\nbreak;\r\n}\r\n}\r\nno_radio:\r\n#endif\r\n*chip_ret = chip;\r\nreturn 0;\r\n}\r\nstatic int snd_es1968_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct es1968 *chip;\r\nunsigned int i;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nif (total_bufsize[dev] < 128)\r\ntotal_bufsize[dev] = 128;\r\nif (total_bufsize[dev] > 4096)\r\ntotal_bufsize[dev] = 4096;\r\nif ((err = snd_es1968_create(card, pci,\r\ntotal_bufsize[dev] * 1024,\r\npcm_substreams_p[dev],\r\npcm_substreams_c[dev],\r\npci_id->driver_data,\r\nuse_pm[dev],\r\nradio_nr[dev],\r\n&chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = chip;\r\nswitch (chip->type) {\r\ncase TYPE_MAESTRO2E:\r\nstrcpy(card->driver, "ES1978");\r\nstrcpy(card->shortname, "ESS ES1978 (Maestro 2E)");\r\nbreak;\r\ncase TYPE_MAESTRO2:\r\nstrcpy(card->driver, "ES1968");\r\nstrcpy(card->shortname, "ESS ES1968 (Maestro 2)");\r\nbreak;\r\ncase TYPE_MAESTRO:\r\nstrcpy(card->driver, "ESM1");\r\nstrcpy(card->shortname, "ESS Maestro 1");\r\nbreak;\r\n}\r\nif ((err = snd_es1968_pcm(chip, 0)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_es1968_mixer(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif (enable_mpu[dev] == 2) {\r\nunsigned short vend;\r\npci_read_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);\r\nfor (i = 0; i < ARRAY_SIZE(mpu_blacklist); i++) {\r\nif (chip->type == mpu_blacklist[i].type &&\r\nvend == mpu_blacklist[i].vendor) {\r\nenable_mpu[dev] = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (enable_mpu[dev]) {\r\nif ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\r\nchip->io_port + ESM_MPU401_PORT,\r\nMPU401_INFO_INTEGRATED |\r\nMPU401_INFO_IRQ_HOOK,\r\n-1, &chip->rmidi)) < 0) {\r\ndev_warn(card->dev, "skipping MPU-401 MIDI support..\n");\r\n}\r\n}\r\nsnd_es1968_create_gameport(chip, dev);\r\n#ifdef CONFIG_SND_ES1968_INPUT\r\nerr = snd_es1968_input_register(chip);\r\nif (err)\r\ndev_warn(card->dev,\r\n"Input device registration failed with error %i", err);\r\n#endif\r\nsnd_es1968_start_irq(chip);\r\nchip->clock = clock[dev];\r\nif (! chip->clock)\r\nes1968_measure_clock(chip);\r\nsprintf(card->longname, "%s at 0x%lx, irq %i",\r\ncard->shortname, chip->io_port, chip->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_es1968_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
