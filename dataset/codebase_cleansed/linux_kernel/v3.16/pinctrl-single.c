static unsigned __maybe_unused pcs_readb(void __iomem *reg)\r\n{\r\nreturn readb(reg);\r\n}\r\nstatic unsigned __maybe_unused pcs_readw(void __iomem *reg)\r\n{\r\nreturn readw(reg);\r\n}\r\nstatic unsigned __maybe_unused pcs_readl(void __iomem *reg)\r\n{\r\nreturn readl(reg);\r\n}\r\nstatic void __maybe_unused pcs_writeb(unsigned val, void __iomem *reg)\r\n{\r\nwriteb(val, reg);\r\n}\r\nstatic void __maybe_unused pcs_writew(unsigned val, void __iomem *reg)\r\n{\r\nwritew(val, reg);\r\n}\r\nstatic void __maybe_unused pcs_writel(unsigned val, void __iomem *reg)\r\n{\r\nwritel(val, reg);\r\n}\r\nstatic int pcs_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pcs->ngroups;\r\n}\r\nstatic const char *pcs_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned gselector)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_pingroup *group;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\ngroup = radix_tree_lookup(&pcs->pgtree, gselector);\r\nif (!group) {\r\ndev_err(pcs->dev, "%s could not find pingroup%i\n",\r\n__func__, gselector);\r\nreturn NULL;\r\n}\r\nreturn group->name;\r\n}\r\nstatic int pcs_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned gselector,\r\nconst unsigned **pins,\r\nunsigned *npins)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_pingroup *group;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\ngroup = radix_tree_lookup(&pcs->pgtree, gselector);\r\nif (!group) {\r\ndev_err(pcs->dev, "%s could not find pingroup%i\n",\r\n__func__, gselector);\r\nreturn -EINVAL;\r\n}\r\n*pins = group->gpins;\r\n*npins = group->ngpins;\r\nreturn 0;\r\n}\r\nstatic void pcs_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned pin)\r\n{\r\nstruct pcs_device *pcs;\r\nunsigned val, mux_bytes;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nmux_bytes = pcs->width / BITS_PER_BYTE;\r\nval = pcs->read(pcs->base + pin * mux_bytes);\r\nseq_printf(s, "%08x %s " , val, DRIVER_NAME);\r\n}\r\nstatic void pcs_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\ndevm_kfree(pcs->dev, map);\r\n}\r\nstatic int pcs_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pcs->nfuncs;\r\n}\r\nstatic const char *pcs_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned fselector)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_function *func;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nfunc = radix_tree_lookup(&pcs->ftree, fselector);\r\nif (!func) {\r\ndev_err(pcs->dev, "%s could not find function%i\n",\r\n__func__, fselector);\r\nreturn NULL;\r\n}\r\nreturn func->name;\r\n}\r\nstatic int pcs_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned fselector,\r\nconst char * const **groups,\r\nunsigned * const ngroups)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_function *func;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nfunc = radix_tree_lookup(&pcs->ftree, fselector);\r\nif (!func) {\r\ndev_err(pcs->dev, "%s could not find function%i\n",\r\n__func__, fselector);\r\nreturn -EINVAL;\r\n}\r\n*groups = func->pgnames;\r\n*ngroups = func->npgnames;\r\nreturn 0;\r\n}\r\nstatic int pcs_get_function(struct pinctrl_dev *pctldev, unsigned pin,\r\nstruct pcs_function **func)\r\n{\r\nstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pin_desc *pdesc = pin_desc_get(pctldev, pin);\r\nconst struct pinctrl_setting_mux *setting;\r\nunsigned fselector;\r\nsetting = pdesc->mux_setting;\r\nif (!setting)\r\nreturn -ENOTSUPP;\r\nfselector = setting->func;\r\n*func = radix_tree_lookup(&pcs->ftree, fselector);\r\nif (!(*func)) {\r\ndev_err(pcs->dev, "%s could not find function%i\n",\r\n__func__, fselector);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcs_enable(struct pinctrl_dev *pctldev, unsigned fselector,\r\nunsigned group)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_function *func;\r\nint i;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nif (!pcs->fmask)\r\nreturn 0;\r\nfunc = radix_tree_lookup(&pcs->ftree, fselector);\r\nif (!func)\r\nreturn -EINVAL;\r\ndev_dbg(pcs->dev, "enabling %s function%i\n",\r\nfunc->name, fselector);\r\nfor (i = 0; i < func->nvals; i++) {\r\nstruct pcs_func_vals *vals;\r\nunsigned long flags;\r\nunsigned val, mask;\r\nvals = &func->vals[i];\r\nraw_spin_lock_irqsave(&pcs->lock, flags);\r\nval = pcs->read(vals->reg);\r\nif (pcs->bits_per_mux)\r\nmask = vals->mask;\r\nelse\r\nmask = pcs->fmask;\r\nval &= ~mask;\r\nval |= (vals->val & mask);\r\npcs->write(val, vals->reg);\r\nraw_spin_unlock_irqrestore(&pcs->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcs_disable(struct pinctrl_dev *pctldev, unsigned fselector,\r\nunsigned group)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_function *func;\r\nint i;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nif (!pcs->fmask)\r\nreturn;\r\nfunc = radix_tree_lookup(&pcs->ftree, fselector);\r\nif (!func) {\r\ndev_err(pcs->dev, "%s could not find function%i\n",\r\n__func__, fselector);\r\nreturn;\r\n}\r\nif (pcs->foff == PCS_OFF_DISABLED) {\r\ndev_dbg(pcs->dev, "ignoring disable for %s function%i\n",\r\nfunc->name, fselector);\r\nreturn;\r\n}\r\ndev_dbg(pcs->dev, "disabling function%i %s\n",\r\nfselector, func->name);\r\nfor (i = 0; i < func->nvals; i++) {\r\nstruct pcs_func_vals *vals;\r\nunsigned long flags;\r\nunsigned val, mask;\r\nvals = &func->vals[i];\r\nraw_spin_lock_irqsave(&pcs->lock, flags);\r\nval = pcs->read(vals->reg);\r\nif (pcs->bits_per_mux)\r\nmask = vals->mask;\r\nelse\r\nmask = pcs->fmask;\r\nval &= ~mask;\r\nval |= pcs->foff << pcs->fshift;\r\npcs->write(val, vals->reg);\r\nraw_spin_unlock_irqrestore(&pcs->lock, flags);\r\n}\r\n}\r\nstatic int pcs_request_gpio(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned pin)\r\n{\r\nstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pcs_gpiofunc_range *frange = NULL;\r\nstruct list_head *pos, *tmp;\r\nint mux_bytes = 0;\r\nunsigned data;\r\nif (!pcs->fmask)\r\nreturn -ENOTSUPP;\r\nlist_for_each_safe(pos, tmp, &pcs->gpiofuncs) {\r\nfrange = list_entry(pos, struct pcs_gpiofunc_range, node);\r\nif (pin >= frange->offset + frange->npins\r\n|| pin < frange->offset)\r\ncontinue;\r\nmux_bytes = pcs->width / BITS_PER_BYTE;\r\ndata = pcs->read(pcs->base + pin * mux_bytes) & ~pcs->fmask;\r\ndata |= frange->gpiofunc;\r\npcs->write(data, pcs->base + pin * mux_bytes);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcs_pinconf_clear_bias(struct pinctrl_dev *pctldev, unsigned pin)\r\n{\r\nunsigned long config;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pcs_bias); i++) {\r\nconfig = pinconf_to_config_packed(pcs_bias[i], 0);\r\npcs_pinconf_set(pctldev, pin, &config, 1);\r\n}\r\n}\r\nstatic bool pcs_pinconf_bias_disable(struct pinctrl_dev *pctldev, unsigned pin)\r\n{\r\nunsigned long config;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pcs_bias); i++) {\r\nconfig = pinconf_to_config_packed(pcs_bias[i], 0);\r\nif (!pcs_pinconf_get(pctldev, pin, &config))\r\ngoto out;\r\n}\r\nreturn true;\r\nout:\r\nreturn false;\r\n}\r\nstatic int pcs_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *config)\r\n{\r\nstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pcs_function *func;\r\nenum pin_config_param param;\r\nunsigned offset = 0, data = 0, i, j, ret;\r\nret = pcs_get_function(pctldev, pin, &func);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < func->nconfs; i++) {\r\nparam = pinconf_to_config_param(*config);\r\nif (param == PIN_CONFIG_BIAS_DISABLE) {\r\nif (pcs_pinconf_bias_disable(pctldev, pin)) {\r\n*config = 0;\r\nreturn 0;\r\n} else {\r\nreturn -ENOTSUPP;\r\n}\r\n} else if (param != func->conf[i].param) {\r\ncontinue;\r\n}\r\noffset = pin * (pcs->width / BITS_PER_BYTE);\r\ndata = pcs->read(pcs->base + offset) & func->conf[i].mask;\r\nswitch (func->conf[i].param) {\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nif ((data != func->conf[i].enable) ||\r\n(data == func->conf[i].disable))\r\nreturn -ENOTSUPP;\r\n*config = 0;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT:\r\nfor (j = 0; j < func->nconfs; j++) {\r\nswitch (func->conf[j].param) {\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nif (data != func->conf[j].enable)\r\nreturn -ENOTSUPP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n*config = data;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\ncase PIN_CONFIG_SLEW_RATE:\r\ncase PIN_CONFIG_LOW_POWER_MODE:\r\ndefault:\r\n*config = data;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int pcs_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pcs_function *func;\r\nunsigned offset = 0, shift = 0, i, data, ret;\r\nu16 arg;\r\nint j;\r\nret = pcs_get_function(pctldev, pin, &func);\r\nif (ret)\r\nreturn ret;\r\nfor (j = 0; j < num_configs; j++) {\r\nfor (i = 0; i < func->nconfs; i++) {\r\nif (pinconf_to_config_param(configs[j])\r\n!= func->conf[i].param)\r\ncontinue;\r\noffset = pin * (pcs->width / BITS_PER_BYTE);\r\ndata = pcs->read(pcs->base + offset);\r\narg = pinconf_to_config_argument(configs[j]);\r\nswitch (func->conf[i].param) {\r\ncase PIN_CONFIG_INPUT_SCHMITT:\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\ncase PIN_CONFIG_SLEW_RATE:\r\ncase PIN_CONFIG_LOW_POWER_MODE:\r\nshift = ffs(func->conf[i].mask) - 1;\r\ndata &= ~func->conf[i].mask;\r\ndata |= (arg << shift) & func->conf[i].mask;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\npcs_pinconf_clear_bias(pctldev, pin);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (arg)\r\npcs_pinconf_clear_bias(pctldev, pin);\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\ndata &= ~func->conf[i].mask;\r\nif (arg)\r\ndata |= func->conf[i].enable;\r\nelse\r\ndata |= func->conf[i].disable;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\npcs->write(data, pcs->base + offset);\r\nbreak;\r\n}\r\nif (i >= func->nconfs)\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcs_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *config)\r\n{\r\nconst unsigned *pins;\r\nunsigned npins, old = 0;\r\nint i, ret;\r\nret = pcs_get_group_pins(pctldev, group, &pins, &npins);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < npins; i++) {\r\nif (pcs_pinconf_get(pctldev, pins[i], config))\r\nreturn -ENOTSUPP;\r\nif (i && (old != *config))\r\nreturn -ENOTSUPP;\r\nold = *config;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcs_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nconst unsigned *pins;\r\nunsigned npins;\r\nint i, ret;\r\nret = pcs_get_group_pins(pctldev, group, &pins, &npins);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < npins; i++) {\r\nif (pcs_pinconf_set(pctldev, pins[i], configs, num_configs))\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcs_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin)\r\n{\r\n}\r\nstatic void pcs_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned selector)\r\n{\r\n}\r\nstatic void pcs_pinconf_config_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned long config)\r\n{\r\npinconf_generic_dump_config(pctldev, s, config);\r\n}\r\nstatic int pcs_add_pin(struct pcs_device *pcs, unsigned offset,\r\nunsigned pin_pos)\r\n{\r\nstruct pcs_soc_data *pcs_soc = &pcs->socdata;\r\nstruct pinctrl_pin_desc *pin;\r\nstruct pcs_name *pn;\r\nint i;\r\ni = pcs->pins.cur;\r\nif (i >= pcs->desc.npins) {\r\ndev_err(pcs->dev, "too many pins, max %i\n",\r\npcs->desc.npins);\r\nreturn -ENOMEM;\r\n}\r\nif (pcs_soc->irq_enable_mask) {\r\nunsigned val;\r\nval = pcs->read(pcs->base + offset);\r\nif (val & pcs_soc->irq_enable_mask) {\r\ndev_dbg(pcs->dev, "irq enabled at boot for pin at %lx (%x), clearing\n",\r\n(unsigned long)pcs->res->start + offset, val);\r\nval &= ~pcs_soc->irq_enable_mask;\r\npcs->write(val, pcs->base + offset);\r\n}\r\n}\r\npin = &pcs->pins.pa[i];\r\npn = &pcs->names[i];\r\nsprintf(pn->name, "%lx.%d",\r\n(unsigned long)pcs->res->start + offset, pin_pos);\r\npin->name = pn->name;\r\npin->number = i;\r\npcs->pins.cur++;\r\nreturn i;\r\n}\r\nstatic int pcs_allocate_pin_table(struct pcs_device *pcs)\r\n{\r\nint mux_bytes, nr_pins, i;\r\nint num_pins_in_register = 0;\r\nmux_bytes = pcs->width / BITS_PER_BYTE;\r\nif (pcs->bits_per_mux) {\r\npcs->bits_per_pin = fls(pcs->fmask);\r\nnr_pins = (pcs->size * BITS_PER_BYTE) / pcs->bits_per_pin;\r\nnum_pins_in_register = pcs->width / pcs->bits_per_pin;\r\n} else {\r\nnr_pins = pcs->size / mux_bytes;\r\n}\r\ndev_dbg(pcs->dev, "allocating %i pins\n", nr_pins);\r\npcs->pins.pa = devm_kzalloc(pcs->dev,\r\nsizeof(*pcs->pins.pa) * nr_pins,\r\nGFP_KERNEL);\r\nif (!pcs->pins.pa)\r\nreturn -ENOMEM;\r\npcs->names = devm_kzalloc(pcs->dev,\r\nsizeof(struct pcs_name) * nr_pins,\r\nGFP_KERNEL);\r\nif (!pcs->names)\r\nreturn -ENOMEM;\r\npcs->desc.pins = pcs->pins.pa;\r\npcs->desc.npins = nr_pins;\r\nfor (i = 0; i < pcs->desc.npins; i++) {\r\nunsigned offset;\r\nint res;\r\nint byte_num;\r\nint pin_pos = 0;\r\nif (pcs->bits_per_mux) {\r\nbyte_num = (pcs->bits_per_pin * i) / BITS_PER_BYTE;\r\noffset = (byte_num / mux_bytes) * mux_bytes;\r\npin_pos = i % num_pins_in_register;\r\n} else {\r\noffset = i * mux_bytes;\r\n}\r\nres = pcs_add_pin(pcs, offset, pin_pos);\r\nif (res < 0) {\r\ndev_err(pcs->dev, "error adding pins: %i\n", res);\r\nreturn res;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pcs_function *pcs_add_function(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nconst char *name,\r\nstruct pcs_func_vals *vals,\r\nunsigned nvals,\r\nconst char **pgnames,\r\nunsigned npgnames)\r\n{\r\nstruct pcs_function *function;\r\nfunction = devm_kzalloc(pcs->dev, sizeof(*function), GFP_KERNEL);\r\nif (!function)\r\nreturn NULL;\r\nfunction->name = name;\r\nfunction->vals = vals;\r\nfunction->nvals = nvals;\r\nfunction->pgnames = pgnames;\r\nfunction->npgnames = npgnames;\r\nmutex_lock(&pcs->mutex);\r\nlist_add_tail(&function->node, &pcs->functions);\r\nradix_tree_insert(&pcs->ftree, pcs->nfuncs, function);\r\npcs->nfuncs++;\r\nmutex_unlock(&pcs->mutex);\r\nreturn function;\r\n}\r\nstatic void pcs_remove_function(struct pcs_device *pcs,\r\nstruct pcs_function *function)\r\n{\r\nint i;\r\nmutex_lock(&pcs->mutex);\r\nfor (i = 0; i < pcs->nfuncs; i++) {\r\nstruct pcs_function *found;\r\nfound = radix_tree_lookup(&pcs->ftree, i);\r\nif (found == function)\r\nradix_tree_delete(&pcs->ftree, i);\r\n}\r\nlist_del(&function->node);\r\nmutex_unlock(&pcs->mutex);\r\n}\r\nstatic int pcs_add_pingroup(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nconst char *name,\r\nint *gpins,\r\nint ngpins)\r\n{\r\nstruct pcs_pingroup *pingroup;\r\npingroup = devm_kzalloc(pcs->dev, sizeof(*pingroup), GFP_KERNEL);\r\nif (!pingroup)\r\nreturn -ENOMEM;\r\npingroup->name = name;\r\npingroup->np = np;\r\npingroup->gpins = gpins;\r\npingroup->ngpins = ngpins;\r\nmutex_lock(&pcs->mutex);\r\nlist_add_tail(&pingroup->node, &pcs->pingroups);\r\nradix_tree_insert(&pcs->pgtree, pcs->ngroups, pingroup);\r\npcs->ngroups++;\r\nmutex_unlock(&pcs->mutex);\r\nreturn 0;\r\n}\r\nstatic int pcs_get_pin_by_offset(struct pcs_device *pcs, unsigned offset)\r\n{\r\nunsigned index;\r\nif (offset >= pcs->size) {\r\ndev_err(pcs->dev, "mux offset out of range: 0x%x (0x%x)\n",\r\noffset, pcs->size);\r\nreturn -EINVAL;\r\n}\r\nif (pcs->bits_per_mux)\r\nindex = (offset * BITS_PER_BYTE) / pcs->bits_per_pin;\r\nelse\r\nindex = offset / (pcs->width / BITS_PER_BYTE);\r\nreturn index;\r\n}\r\nstatic int pcs_config_match(unsigned data, unsigned enable, unsigned disable)\r\n{\r\nint ret = -EINVAL;\r\nif (data == enable)\r\nret = 1;\r\nelse if (data == disable)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic void add_config(struct pcs_conf_vals **conf, enum pin_config_param param,\r\nunsigned value, unsigned enable, unsigned disable,\r\nunsigned mask)\r\n{\r\n(*conf)->param = param;\r\n(*conf)->val = value;\r\n(*conf)->enable = enable;\r\n(*conf)->disable = disable;\r\n(*conf)->mask = mask;\r\n(*conf)++;\r\n}\r\nstatic void add_setting(unsigned long **setting, enum pin_config_param param,\r\nunsigned arg)\r\n{\r\n**setting = pinconf_to_config_packed(param, arg);\r\n(*setting)++;\r\n}\r\nstatic void pcs_add_conf2(struct pcs_device *pcs, struct device_node *np,\r\nconst char *name, enum pin_config_param param,\r\nstruct pcs_conf_vals **conf, unsigned long **settings)\r\n{\r\nunsigned value[2], shift;\r\nint ret;\r\nret = of_property_read_u32_array(np, name, value, 2);\r\nif (ret)\r\nreturn;\r\nvalue[0] &= value[1];\r\nshift = ffs(value[1]) - 1;\r\nadd_config(conf, param, value[0], 0, 0, value[1]);\r\nadd_setting(settings, param, value[0] >> shift);\r\n}\r\nstatic void pcs_add_conf4(struct pcs_device *pcs, struct device_node *np,\r\nconst char *name, enum pin_config_param param,\r\nstruct pcs_conf_vals **conf, unsigned long **settings)\r\n{\r\nunsigned value[4];\r\nint ret;\r\nret = of_property_read_u32_array(np, name, value, 4);\r\nif (ret)\r\nreturn;\r\nif (!value[3]) {\r\ndev_err(pcs->dev, "mask field of the property can't be 0\n");\r\nreturn;\r\n}\r\nvalue[0] &= value[3];\r\nvalue[1] &= value[3];\r\nvalue[2] &= value[3];\r\nret = pcs_config_match(value[0], value[1], value[2]);\r\nif (ret < 0)\r\ndev_dbg(pcs->dev, "failed to match enable or disable bits\n");\r\nadd_config(conf, param, value[0], value[1], value[2], value[3]);\r\nadd_setting(settings, param, ret);\r\n}\r\nstatic int pcs_parse_pinconf(struct pcs_device *pcs, struct device_node *np,\r\nstruct pcs_function *func,\r\nstruct pinctrl_map **map)\r\n{\r\nstruct pinctrl_map *m = *map;\r\nint i = 0, nconfs = 0;\r\nunsigned long *settings = NULL, *s = NULL;\r\nstruct pcs_conf_vals *conf = NULL;\r\nstruct pcs_conf_type prop2[] = {\r\n{ "pinctrl-single,drive-strength", PIN_CONFIG_DRIVE_STRENGTH, },\r\n{ "pinctrl-single,slew-rate", PIN_CONFIG_SLEW_RATE, },\r\n{ "pinctrl-single,input-schmitt", PIN_CONFIG_INPUT_SCHMITT, },\r\n{ "pinctrl-single,low-power-mode", PIN_CONFIG_LOW_POWER_MODE, },\r\n};\r\nstruct pcs_conf_type prop4[] = {\r\n{ "pinctrl-single,bias-pullup", PIN_CONFIG_BIAS_PULL_UP, },\r\n{ "pinctrl-single,bias-pulldown", PIN_CONFIG_BIAS_PULL_DOWN, },\r\n{ "pinctrl-single,input-schmitt-enable",\r\nPIN_CONFIG_INPUT_SCHMITT_ENABLE, },\r\n};\r\nif (!PCS_HAS_PINCONF)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(prop2); i++) {\r\nif (of_find_property(np, prop2[i].name, NULL))\r\nnconfs++;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(prop4); i++) {\r\nif (of_find_property(np, prop4[i].name, NULL))\r\nnconfs++;\r\n}\r\nif (!nconfs)\r\nreturn 0;\r\nfunc->conf = devm_kzalloc(pcs->dev,\r\nsizeof(struct pcs_conf_vals) * nconfs,\r\nGFP_KERNEL);\r\nif (!func->conf)\r\nreturn -ENOMEM;\r\nfunc->nconfs = nconfs;\r\nconf = &(func->conf[0]);\r\nm++;\r\nsettings = devm_kzalloc(pcs->dev, sizeof(unsigned long) * nconfs,\r\nGFP_KERNEL);\r\nif (!settings)\r\nreturn -ENOMEM;\r\ns = &settings[0];\r\nfor (i = 0; i < ARRAY_SIZE(prop2); i++)\r\npcs_add_conf2(pcs, np, prop2[i].name, prop2[i].param,\r\n&conf, &s);\r\nfor (i = 0; i < ARRAY_SIZE(prop4); i++)\r\npcs_add_conf4(pcs, np, prop4[i].name, prop4[i].param,\r\n&conf, &s);\r\nm->type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\nm->data.configs.group_or_pin = np->name;\r\nm->data.configs.configs = settings;\r\nm->data.configs.num_configs = nconfs;\r\nreturn 0;\r\n}\r\nstatic int pcs_parse_one_pinctrl_entry(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps,\r\nconst char **pgnames)\r\n{\r\nstruct pcs_func_vals *vals;\r\nconst __be32 *mux;\r\nint size, rows, *pins, index = 0, found = 0, res = -ENOMEM;\r\nstruct pcs_function *function;\r\nmux = of_get_property(np, PCS_MUX_PINS_NAME, &size);\r\nif ((!mux) || (size < sizeof(*mux) * 2)) {\r\ndev_err(pcs->dev, "bad data for mux %s\n",\r\nnp->name);\r\nreturn -EINVAL;\r\n}\r\nsize /= sizeof(*mux);\r\nrows = size / 2;\r\nvals = devm_kzalloc(pcs->dev, sizeof(*vals) * rows, GFP_KERNEL);\r\nif (!vals)\r\nreturn -ENOMEM;\r\npins = devm_kzalloc(pcs->dev, sizeof(*pins) * rows, GFP_KERNEL);\r\nif (!pins)\r\ngoto free_vals;\r\nwhile (index < size) {\r\nunsigned offset, val;\r\nint pin;\r\noffset = be32_to_cpup(mux + index++);\r\nval = be32_to_cpup(mux + index++);\r\nvals[found].reg = pcs->base + offset;\r\nvals[found].val = val;\r\npin = pcs_get_pin_by_offset(pcs, offset);\r\nif (pin < 0) {\r\ndev_err(pcs->dev,\r\n"could not add functions for %s %ux\n",\r\nnp->name, offset);\r\nbreak;\r\n}\r\npins[found++] = pin;\r\n}\r\npgnames[0] = np->name;\r\nfunction = pcs_add_function(pcs, np, np->name, vals, found, pgnames, 1);\r\nif (!function)\r\ngoto free_pins;\r\nres = pcs_add_pingroup(pcs, np, np->name, pins, found);\r\nif (res < 0)\r\ngoto free_function;\r\n(*map)->type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)->data.mux.group = np->name;\r\n(*map)->data.mux.function = np->name;\r\nif (PCS_HAS_PINCONF) {\r\nres = pcs_parse_pinconf(pcs, np, function, map);\r\nif (res)\r\ngoto free_pingroups;\r\n*num_maps = 2;\r\n} else {\r\n*num_maps = 1;\r\n}\r\nreturn 0;\r\nfree_pingroups:\r\npcs_free_pingroups(pcs);\r\n*num_maps = 1;\r\nfree_function:\r\npcs_remove_function(pcs, function);\r\nfree_pins:\r\ndevm_kfree(pcs->dev, pins);\r\nfree_vals:\r\ndevm_kfree(pcs->dev, vals);\r\nreturn res;\r\n}\r\nstatic int pcs_parse_bits_in_pinctrl_entry(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps,\r\nconst char **pgnames)\r\n{\r\nstruct pcs_func_vals *vals;\r\nconst __be32 *mux;\r\nint size, rows, *pins, index = 0, found = 0, res = -ENOMEM;\r\nint npins_in_row;\r\nstruct pcs_function *function;\r\nmux = of_get_property(np, PCS_MUX_BITS_NAME, &size);\r\nif (!mux) {\r\ndev_err(pcs->dev, "no valid property for %s\n", np->name);\r\nreturn -EINVAL;\r\n}\r\nif (size < (sizeof(*mux) * PARAMS_FOR_BITS_PER_MUX)) {\r\ndev_err(pcs->dev, "bad data for %s\n", np->name);\r\nreturn -EINVAL;\r\n}\r\nsize /= sizeof(*mux);\r\nrows = size / PARAMS_FOR_BITS_PER_MUX;\r\nnpins_in_row = pcs->width / pcs->bits_per_pin;\r\nvals = devm_kzalloc(pcs->dev, sizeof(*vals) * rows * npins_in_row,\r\nGFP_KERNEL);\r\nif (!vals)\r\nreturn -ENOMEM;\r\npins = devm_kzalloc(pcs->dev, sizeof(*pins) * rows * npins_in_row,\r\nGFP_KERNEL);\r\nif (!pins)\r\ngoto free_vals;\r\nwhile (index < size) {\r\nunsigned offset, val;\r\nunsigned mask, bit_pos, val_pos, mask_pos, submask;\r\nunsigned pin_num_from_lsb;\r\nint pin;\r\noffset = be32_to_cpup(mux + index++);\r\nval = be32_to_cpup(mux + index++);\r\nmask = be32_to_cpup(mux + index++);\r\nwhile (mask) {\r\nbit_pos = ffs(mask);\r\npin_num_from_lsb = bit_pos / pcs->bits_per_pin;\r\nmask_pos = ((pcs->fmask) << (bit_pos - 1));\r\nval_pos = val & mask_pos;\r\nsubmask = mask & mask_pos;\r\nif ((mask & mask_pos) == 0) {\r\ndev_err(pcs->dev,\r\n"Invalid mask for %s at 0x%x\n",\r\nnp->name, offset);\r\nbreak;\r\n}\r\nmask &= ~mask_pos;\r\nif (submask != mask_pos) {\r\ndev_warn(pcs->dev,\r\n"Invalid submask 0x%x for %s at 0x%x\n",\r\nsubmask, np->name, offset);\r\ncontinue;\r\n}\r\nvals[found].mask = submask;\r\nvals[found].reg = pcs->base + offset;\r\nvals[found].val = val_pos;\r\npin = pcs_get_pin_by_offset(pcs, offset);\r\nif (pin < 0) {\r\ndev_err(pcs->dev,\r\n"could not add functions for %s %ux\n",\r\nnp->name, offset);\r\nbreak;\r\n}\r\npins[found++] = pin + pin_num_from_lsb;\r\n}\r\n}\r\npgnames[0] = np->name;\r\nfunction = pcs_add_function(pcs, np, np->name, vals, found, pgnames, 1);\r\nif (!function)\r\ngoto free_pins;\r\nres = pcs_add_pingroup(pcs, np, np->name, pins, found);\r\nif (res < 0)\r\ngoto free_function;\r\n(*map)->type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)->data.mux.group = np->name;\r\n(*map)->data.mux.function = np->name;\r\nif (PCS_HAS_PINCONF) {\r\ndev_err(pcs->dev, "pinconf not supported\n");\r\ngoto free_pingroups;\r\n}\r\n*num_maps = 1;\r\nreturn 0;\r\nfree_pingroups:\r\npcs_free_pingroups(pcs);\r\n*num_maps = 1;\r\nfree_function:\r\npcs_remove_function(pcs, function);\r\nfree_pins:\r\ndevm_kfree(pcs->dev, pins);\r\nfree_vals:\r\ndevm_kfree(pcs->dev, vals);\r\nreturn res;\r\n}\r\nstatic int pcs_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct pcs_device *pcs;\r\nconst char **pgnames;\r\nint ret;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\n*map = devm_kzalloc(pcs->dev, sizeof(**map) * 2, GFP_KERNEL);\r\nif (!*map)\r\nreturn -ENOMEM;\r\n*num_maps = 0;\r\npgnames = devm_kzalloc(pcs->dev, sizeof(*pgnames), GFP_KERNEL);\r\nif (!pgnames) {\r\nret = -ENOMEM;\r\ngoto free_map;\r\n}\r\nif (pcs->bits_per_mux) {\r\nret = pcs_parse_bits_in_pinctrl_entry(pcs, np_config, map,\r\nnum_maps, pgnames);\r\nif (ret < 0) {\r\ndev_err(pcs->dev, "no pins entries for %s\n",\r\nnp_config->name);\r\ngoto free_pgnames;\r\n}\r\n} else {\r\nret = pcs_parse_one_pinctrl_entry(pcs, np_config, map,\r\nnum_maps, pgnames);\r\nif (ret < 0) {\r\ndev_err(pcs->dev, "no pins entries for %s\n",\r\nnp_config->name);\r\ngoto free_pgnames;\r\n}\r\n}\r\nreturn 0;\r\nfree_pgnames:\r\ndevm_kfree(pcs->dev, pgnames);\r\nfree_map:\r\ndevm_kfree(pcs->dev, *map);\r\nreturn ret;\r\n}\r\nstatic void pcs_free_funcs(struct pcs_device *pcs)\r\n{\r\nstruct list_head *pos, *tmp;\r\nint i;\r\nmutex_lock(&pcs->mutex);\r\nfor (i = 0; i < pcs->nfuncs; i++) {\r\nstruct pcs_function *func;\r\nfunc = radix_tree_lookup(&pcs->ftree, i);\r\nif (!func)\r\ncontinue;\r\nradix_tree_delete(&pcs->ftree, i);\r\n}\r\nlist_for_each_safe(pos, tmp, &pcs->functions) {\r\nstruct pcs_function *function;\r\nfunction = list_entry(pos, struct pcs_function, node);\r\nlist_del(&function->node);\r\n}\r\nmutex_unlock(&pcs->mutex);\r\n}\r\nstatic void pcs_free_pingroups(struct pcs_device *pcs)\r\n{\r\nstruct list_head *pos, *tmp;\r\nint i;\r\nmutex_lock(&pcs->mutex);\r\nfor (i = 0; i < pcs->ngroups; i++) {\r\nstruct pcs_pingroup *pingroup;\r\npingroup = radix_tree_lookup(&pcs->pgtree, i);\r\nif (!pingroup)\r\ncontinue;\r\nradix_tree_delete(&pcs->pgtree, i);\r\n}\r\nlist_for_each_safe(pos, tmp, &pcs->pingroups) {\r\nstruct pcs_pingroup *pingroup;\r\npingroup = list_entry(pos, struct pcs_pingroup, node);\r\nlist_del(&pingroup->node);\r\n}\r\nmutex_unlock(&pcs->mutex);\r\n}\r\nstatic void pcs_irq_free(struct pcs_device *pcs)\r\n{\r\nstruct pcs_soc_data *pcs_soc = &pcs->socdata;\r\nif (pcs_soc->irq < 0)\r\nreturn;\r\nif (pcs->domain)\r\nirq_domain_remove(pcs->domain);\r\nif (PCS_QUIRK_HAS_SHARED_IRQ)\r\nfree_irq(pcs_soc->irq, pcs_soc);\r\nelse\r\nirq_set_chained_handler(pcs_soc->irq, NULL);\r\n}\r\nstatic void pcs_free_resources(struct pcs_device *pcs)\r\n{\r\npcs_irq_free(pcs);\r\nif (pcs->pctl)\r\npinctrl_unregister(pcs->pctl);\r\npcs_free_funcs(pcs);\r\npcs_free_pingroups(pcs);\r\n}\r\nstatic int pcs_add_gpio_func(struct device_node *node, struct pcs_device *pcs)\r\n{\r\nconst char *propname = "pinctrl-single,gpio-range";\r\nconst char *cellname = "#pinctrl-single,gpio-range-cells";\r\nstruct of_phandle_args gpiospec;\r\nstruct pcs_gpiofunc_range *range;\r\nint ret, i;\r\nfor (i = 0; ; i++) {\r\nret = of_parse_phandle_with_args(node, propname, cellname,\r\ni, &gpiospec);\r\nif (ret) {\r\nret = 0;\r\nbreak;\r\n}\r\nrange = devm_kzalloc(pcs->dev, sizeof(*range), GFP_KERNEL);\r\nif (!range) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nrange->offset = gpiospec.args[0];\r\nrange->npins = gpiospec.args[1];\r\nrange->gpiofunc = gpiospec.args[2];\r\nmutex_lock(&pcs->mutex);\r\nlist_add_tail(&range->node, &pcs->gpiofuncs);\r\nmutex_unlock(&pcs->mutex);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void pcs_irq_set(struct pcs_soc_data *pcs_soc,\r\nint irq, const bool enable)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct list_head *pos;\r\nunsigned mask;\r\npcs = container_of(pcs_soc, struct pcs_device, socdata);\r\nlist_for_each(pos, &pcs->irqs) {\r\nstruct pcs_interrupt *pcswi;\r\nunsigned soc_mask;\r\npcswi = list_entry(pos, struct pcs_interrupt, node);\r\nif (irq != pcswi->irq)\r\ncontinue;\r\nsoc_mask = pcs_soc->irq_enable_mask;\r\nraw_spin_lock(&pcs->lock);\r\nmask = pcs->read(pcswi->reg);\r\nif (enable)\r\nmask |= soc_mask;\r\nelse\r\nmask &= ~soc_mask;\r\npcs->write(mask, pcswi->reg);\r\nraw_spin_unlock(&pcs->lock);\r\n}\r\nif (pcs_soc->rearm)\r\npcs_soc->rearm();\r\n}\r\nstatic void pcs_irq_mask(struct irq_data *d)\r\n{\r\nstruct pcs_soc_data *pcs_soc = irq_data_get_irq_chip_data(d);\r\npcs_irq_set(pcs_soc, d->irq, false);\r\n}\r\nstatic void pcs_irq_unmask(struct irq_data *d)\r\n{\r\nstruct pcs_soc_data *pcs_soc = irq_data_get_irq_chip_data(d);\r\npcs_irq_set(pcs_soc, d->irq, true);\r\n}\r\nstatic int pcs_irq_set_wake(struct irq_data *d, unsigned int state)\r\n{\r\nif (state)\r\npcs_irq_unmask(d);\r\nelse\r\npcs_irq_mask(d);\r\nreturn 0;\r\n}\r\nstatic int pcs_irq_handle(struct pcs_soc_data *pcs_soc)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct list_head *pos;\r\nint count = 0;\r\npcs = container_of(pcs_soc, struct pcs_device, socdata);\r\nlist_for_each(pos, &pcs->irqs) {\r\nstruct pcs_interrupt *pcswi;\r\nunsigned mask;\r\npcswi = list_entry(pos, struct pcs_interrupt, node);\r\nraw_spin_lock(&pcs->lock);\r\nmask = pcs->read(pcswi->reg);\r\nraw_spin_unlock(&pcs->lock);\r\nif (mask & pcs_soc->irq_status_mask) {\r\ngeneric_handle_irq(irq_find_mapping(pcs->domain,\r\npcswi->hwirq));\r\ncount++;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic irqreturn_t pcs_irq_handler(int irq, void *d)\r\n{\r\nstruct pcs_soc_data *pcs_soc = d;\r\nreturn pcs_irq_handle(pcs_soc) ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void pcs_irq_chain_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct pcs_soc_data *pcs_soc = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip;\r\nint res;\r\nchip = irq_get_chip(irq);\r\nchained_irq_enter(chip, desc);\r\nres = pcs_irq_handle(pcs_soc);\r\nchained_irq_exit(chip, desc);\r\nreturn;\r\n}\r\nstatic int pcs_irqdomain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct pcs_soc_data *pcs_soc = d->host_data;\r\nstruct pcs_device *pcs;\r\nstruct pcs_interrupt *pcswi;\r\npcs = container_of(pcs_soc, struct pcs_device, socdata);\r\npcswi = devm_kzalloc(pcs->dev, sizeof(*pcswi), GFP_KERNEL);\r\nif (!pcswi)\r\nreturn -ENOMEM;\r\npcswi->reg = pcs->base + hwirq;\r\npcswi->hwirq = hwirq;\r\npcswi->irq = irq;\r\nmutex_lock(&pcs->mutex);\r\nlist_add_tail(&pcswi->node, &pcs->irqs);\r\nmutex_unlock(&pcs->mutex);\r\nirq_set_chip_data(irq, pcs_soc);\r\nirq_set_chip_and_handler(irq, &pcs->chip,\r\nhandle_level_irq);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int pcs_irq_init_chained_handler(struct pcs_device *pcs,\r\nstruct device_node *np)\r\n{\r\nstruct pcs_soc_data *pcs_soc = &pcs->socdata;\r\nconst char *name = "pinctrl";\r\nint num_irqs;\r\nif (!pcs_soc->irq_enable_mask ||\r\n!pcs_soc->irq_status_mask) {\r\npcs_soc->irq = -1;\r\nreturn -EINVAL;\r\n}\r\nINIT_LIST_HEAD(&pcs->irqs);\r\npcs->chip.name = name;\r\npcs->chip.irq_ack = pcs_irq_mask;\r\npcs->chip.irq_mask = pcs_irq_mask;\r\npcs->chip.irq_unmask = pcs_irq_unmask;\r\npcs->chip.irq_set_wake = pcs_irq_set_wake;\r\nif (PCS_QUIRK_HAS_SHARED_IRQ) {\r\nint res;\r\nres = request_irq(pcs_soc->irq, pcs_irq_handler,\r\nIRQF_SHARED | IRQF_NO_SUSPEND,\r\nname, pcs_soc);\r\nif (res) {\r\npcs_soc->irq = -1;\r\nreturn res;\r\n}\r\n} else {\r\nirq_set_handler_data(pcs_soc->irq, pcs_soc);\r\nirq_set_chained_handler(pcs_soc->irq,\r\npcs_irq_chain_handler);\r\n}\r\nnum_irqs = pcs->size;\r\npcs->domain = irq_domain_add_simple(np, num_irqs, 0,\r\n&pcs_irqdomain_ops,\r\npcs_soc);\r\nif (!pcs->domain) {\r\nirq_set_chained_handler(pcs_soc->irq, NULL);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pinctrl_single_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = platform_get_drvdata(pdev);\r\nif (!pcs)\r\nreturn -EINVAL;\r\nreturn pinctrl_force_sleep(pcs->pctl);\r\n}\r\nstatic int pinctrl_single_resume(struct platform_device *pdev)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = platform_get_drvdata(pdev);\r\nif (!pcs)\r\nreturn -EINVAL;\r\nreturn pinctrl_force_default(pcs->pctl);\r\n}\r\nstatic int pcs_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nstruct pcs_pdata *pdata;\r\nstruct resource *res;\r\nstruct pcs_device *pcs;\r\nconst struct pcs_soc_data *soc;\r\nint ret;\r\nmatch = of_match_device(pcs_of_match, &pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\npcs = devm_kzalloc(&pdev->dev, sizeof(*pcs), GFP_KERNEL);\r\nif (!pcs) {\r\ndev_err(&pdev->dev, "could not allocate\n");\r\nreturn -ENOMEM;\r\n}\r\npcs->dev = &pdev->dev;\r\nraw_spin_lock_init(&pcs->lock);\r\nmutex_init(&pcs->mutex);\r\nINIT_LIST_HEAD(&pcs->pingroups);\r\nINIT_LIST_HEAD(&pcs->functions);\r\nINIT_LIST_HEAD(&pcs->gpiofuncs);\r\nsoc = match->data;\r\npcs->flags = soc->flags;\r\nmemcpy(&pcs->socdata, soc, sizeof(*soc));\r\nPCS_GET_PROP_U32("pinctrl-single,register-width", &pcs->width,\r\n"register width not specified\n");\r\nret = of_property_read_u32(np, "pinctrl-single,function-mask",\r\n&pcs->fmask);\r\nif (!ret) {\r\npcs->fshift = ffs(pcs->fmask) - 1;\r\npcs->fmax = pcs->fmask >> pcs->fshift;\r\n} else {\r\npcs->fmask = 0;\r\npcs->fshift = 0;\r\npcs->fmax = 0;\r\n}\r\nret = of_property_read_u32(np, "pinctrl-single,function-off",\r\n&pcs->foff);\r\nif (ret)\r\npcs->foff = PCS_OFF_DISABLED;\r\npcs->bits_per_mux = of_property_read_bool(np,\r\n"pinctrl-single,bit-per-mux");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(pcs->dev, "could not get resource\n");\r\nreturn -ENODEV;\r\n}\r\npcs->res = devm_request_mem_region(pcs->dev, res->start,\r\nresource_size(res), DRIVER_NAME);\r\nif (!pcs->res) {\r\ndev_err(pcs->dev, "could not get mem_region\n");\r\nreturn -EBUSY;\r\n}\r\npcs->size = resource_size(pcs->res);\r\npcs->base = devm_ioremap(pcs->dev, pcs->res->start, pcs->size);\r\nif (!pcs->base) {\r\ndev_err(pcs->dev, "could not ioremap\n");\r\nreturn -ENODEV;\r\n}\r\nINIT_RADIX_TREE(&pcs->pgtree, GFP_KERNEL);\r\nINIT_RADIX_TREE(&pcs->ftree, GFP_KERNEL);\r\nplatform_set_drvdata(pdev, pcs);\r\nswitch (pcs->width) {\r\ncase 8:\r\npcs->read = pcs_readb;\r\npcs->write = pcs_writeb;\r\nbreak;\r\ncase 16:\r\npcs->read = pcs_readw;\r\npcs->write = pcs_writew;\r\nbreak;\r\ncase 32:\r\npcs->read = pcs_readl;\r\npcs->write = pcs_writel;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npcs->desc.name = DRIVER_NAME;\r\npcs->desc.pctlops = &pcs_pinctrl_ops;\r\npcs->desc.pmxops = &pcs_pinmux_ops;\r\nif (PCS_HAS_PINCONF)\r\npcs->desc.confops = &pcs_pinconf_ops;\r\npcs->desc.owner = THIS_MODULE;\r\nret = pcs_allocate_pin_table(pcs);\r\nif (ret < 0)\r\ngoto free;\r\npcs->pctl = pinctrl_register(&pcs->desc, pcs->dev, pcs);\r\nif (!pcs->pctl) {\r\ndev_err(pcs->dev, "could not register single pinctrl driver\n");\r\nret = -EINVAL;\r\ngoto free;\r\n}\r\nret = pcs_add_gpio_func(np, pcs);\r\nif (ret < 0)\r\ngoto free;\r\npcs->socdata.irq = irq_of_parse_and_map(np, 0);\r\nif (pcs->socdata.irq)\r\npcs->flags |= PCS_FEAT_IRQ;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (pdata) {\r\nif (pdata->rearm)\r\npcs->socdata.rearm = pdata->rearm;\r\nif (pdata->irq) {\r\npcs->socdata.irq = pdata->irq;\r\npcs->flags |= PCS_FEAT_IRQ;\r\n}\r\n}\r\nif (PCS_HAS_IRQ) {\r\nret = pcs_irq_init_chained_handler(pcs, np);\r\nif (ret < 0)\r\ndev_warn(pcs->dev, "initialized with no interrupts\n");\r\n}\r\ndev_info(pcs->dev, "%i pins at pa %p size %u\n",\r\npcs->desc.npins, pcs->base, pcs->size);\r\nreturn 0;\r\nfree:\r\npcs_free_resources(pcs);\r\nreturn ret;\r\n}\r\nstatic int pcs_remove(struct platform_device *pdev)\r\n{\r\nstruct pcs_device *pcs = platform_get_drvdata(pdev);\r\nif (!pcs)\r\nreturn 0;\r\npcs_free_resources(pcs);\r\nreturn 0;\r\n}
