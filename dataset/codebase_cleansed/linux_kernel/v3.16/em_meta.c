static inline int meta_id(struct meta_value *v)\r\n{\r\nreturn TCF_META_ID(v->hdr.kind);\r\n}\r\nstatic inline int meta_type(struct meta_value *v)\r\n{\r\nreturn TCF_META_TYPE(v->hdr.kind);\r\n}\r\nstatic inline unsigned long fixed_loadavg(int load)\r\n{\r\nint rnd_load = load + (FIXED_1/200);\r\nint rnd_frac = ((rnd_load & (FIXED_1-1)) * 100) >> FSHIFT;\r\nreturn ((rnd_load >> FSHIFT) * 100) + rnd_frac;\r\n}\r\nstatic inline int int_dev(struct net_device *dev, struct meta_obj *dst)\r\n{\r\nif (unlikely(dev == NULL))\r\nreturn -1;\r\ndst->value = dev->ifindex;\r\nreturn 0;\r\n}\r\nstatic inline int var_dev(struct net_device *dev, struct meta_obj *dst)\r\n{\r\nif (unlikely(dev == NULL))\r\nreturn -1;\r\ndst->value = (unsigned long) dev->name;\r\ndst->len = strlen(dev->name);\r\nreturn 0;\r\n}\r\nstatic inline struct meta_ops *meta_ops(struct meta_value *val)\r\n{\r\nreturn &__meta_ops[meta_type(val)][meta_id(val)];\r\n}\r\nstatic int meta_var_compare(struct meta_obj *a, struct meta_obj *b)\r\n{\r\nint r = a->len - b->len;\r\nif (r == 0)\r\nr = memcmp((void *) a->value, (void *) b->value, a->len);\r\nreturn r;\r\n}\r\nstatic int meta_var_change(struct meta_value *dst, struct nlattr *nla)\r\n{\r\nint len = nla_len(nla);\r\ndst->val = (unsigned long)kmemdup(nla_data(nla), len, GFP_KERNEL);\r\nif (dst->val == 0UL)\r\nreturn -ENOMEM;\r\ndst->len = len;\r\nreturn 0;\r\n}\r\nstatic void meta_var_destroy(struct meta_value *v)\r\n{\r\nkfree((void *) v->val);\r\n}\r\nstatic void meta_var_apply_extras(struct meta_value *v,\r\nstruct meta_obj *dst)\r\n{\r\nint shift = v->hdr.shift;\r\nif (shift && shift < dst->len)\r\ndst->len -= shift;\r\n}\r\nstatic int meta_var_dump(struct sk_buff *skb, struct meta_value *v, int tlv)\r\n{\r\nif (v->val && v->len &&\r\nnla_put(skb, tlv, v->len, (void *) v->val))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int meta_int_compare(struct meta_obj *a, struct meta_obj *b)\r\n{\r\nif (unlikely(a->value == b->value))\r\nreturn 0;\r\nelse if (a->value < b->value)\r\nreturn -1;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int meta_int_change(struct meta_value *dst, struct nlattr *nla)\r\n{\r\nif (nla_len(nla) >= sizeof(unsigned long)) {\r\ndst->val = *(unsigned long *) nla_data(nla);\r\ndst->len = sizeof(unsigned long);\r\n} else if (nla_len(nla) == sizeof(u32)) {\r\ndst->val = nla_get_u32(nla);\r\ndst->len = sizeof(u32);\r\n} else\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void meta_int_apply_extras(struct meta_value *v,\r\nstruct meta_obj *dst)\r\n{\r\nif (v->hdr.shift)\r\ndst->value >>= v->hdr.shift;\r\nif (v->val)\r\ndst->value &= v->val;\r\n}\r\nstatic int meta_int_dump(struct sk_buff *skb, struct meta_value *v, int tlv)\r\n{\r\nif (v->len == sizeof(unsigned long)) {\r\nif (nla_put(skb, tlv, sizeof(unsigned long), &v->val))\r\ngoto nla_put_failure;\r\n} else if (v->len == sizeof(u32)) {\r\nif (nla_put_u32(skb, tlv, v->val))\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline struct meta_type_ops *meta_type_ops(struct meta_value *v)\r\n{\r\nreturn &__meta_type_ops[meta_type(v)];\r\n}\r\nstatic int meta_get(struct sk_buff *skb, struct tcf_pkt_info *info,\r\nstruct meta_value *v, struct meta_obj *dst)\r\n{\r\nint err = 0;\r\nif (meta_id(v) == TCF_META_ID_VALUE) {\r\ndst->value = v->val;\r\ndst->len = v->len;\r\nreturn 0;\r\n}\r\nmeta_ops(v)->get(skb, info, v, dst, &err);\r\nif (err < 0)\r\nreturn err;\r\nif (meta_type_ops(v)->apply_extras)\r\nmeta_type_ops(v)->apply_extras(v, dst);\r\nreturn 0;\r\n}\r\nstatic int em_meta_match(struct sk_buff *skb, struct tcf_ematch *m,\r\nstruct tcf_pkt_info *info)\r\n{\r\nint r;\r\nstruct meta_match *meta = (struct meta_match *) m->data;\r\nstruct meta_obj l_value, r_value;\r\nif (meta_get(skb, info, &meta->lvalue, &l_value) < 0 ||\r\nmeta_get(skb, info, &meta->rvalue, &r_value) < 0)\r\nreturn 0;\r\nr = meta_type_ops(&meta->lvalue)->compare(&l_value, &r_value);\r\nswitch (meta->lvalue.hdr.op) {\r\ncase TCF_EM_OPND_EQ:\r\nreturn !r;\r\ncase TCF_EM_OPND_LT:\r\nreturn r < 0;\r\ncase TCF_EM_OPND_GT:\r\nreturn r > 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void meta_delete(struct meta_match *meta)\r\n{\r\nif (meta) {\r\nstruct meta_type_ops *ops = meta_type_ops(&meta->lvalue);\r\nif (ops && ops->destroy) {\r\nops->destroy(&meta->lvalue);\r\nops->destroy(&meta->rvalue);\r\n}\r\n}\r\nkfree(meta);\r\n}\r\nstatic inline int meta_change_data(struct meta_value *dst, struct nlattr *nla)\r\n{\r\nif (nla) {\r\nif (nla_len(nla) == 0)\r\nreturn -EINVAL;\r\nreturn meta_type_ops(dst)->change(dst, nla);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int meta_is_supported(struct meta_value *val)\r\n{\r\nreturn !meta_id(val) || meta_ops(val)->get;\r\n}\r\nstatic int em_meta_change(struct tcf_proto *tp, void *data, int len,\r\nstruct tcf_ematch *m)\r\n{\r\nint err;\r\nstruct nlattr *tb[TCA_EM_META_MAX + 1];\r\nstruct tcf_meta_hdr *hdr;\r\nstruct meta_match *meta = NULL;\r\nerr = nla_parse(tb, TCA_EM_META_MAX, data, len, meta_policy);\r\nif (err < 0)\r\ngoto errout;\r\nerr = -EINVAL;\r\nif (tb[TCA_EM_META_HDR] == NULL)\r\ngoto errout;\r\nhdr = nla_data(tb[TCA_EM_META_HDR]);\r\nif (TCF_META_TYPE(hdr->left.kind) != TCF_META_TYPE(hdr->right.kind) ||\r\nTCF_META_TYPE(hdr->left.kind) > TCF_META_TYPE_MAX ||\r\nTCF_META_ID(hdr->left.kind) > TCF_META_ID_MAX ||\r\nTCF_META_ID(hdr->right.kind) > TCF_META_ID_MAX)\r\ngoto errout;\r\nmeta = kzalloc(sizeof(*meta), GFP_KERNEL);\r\nif (meta == NULL) {\r\nerr = -ENOMEM;\r\ngoto errout;\r\n}\r\nmemcpy(&meta->lvalue.hdr, &hdr->left, sizeof(hdr->left));\r\nmemcpy(&meta->rvalue.hdr, &hdr->right, sizeof(hdr->right));\r\nif (!meta_is_supported(&meta->lvalue) ||\r\n!meta_is_supported(&meta->rvalue)) {\r\nerr = -EOPNOTSUPP;\r\ngoto errout;\r\n}\r\nif (meta_change_data(&meta->lvalue, tb[TCA_EM_META_LVALUE]) < 0 ||\r\nmeta_change_data(&meta->rvalue, tb[TCA_EM_META_RVALUE]) < 0)\r\ngoto errout;\r\nm->datalen = sizeof(*meta);\r\nm->data = (unsigned long) meta;\r\nerr = 0;\r\nerrout:\r\nif (err && meta)\r\nmeta_delete(meta);\r\nreturn err;\r\n}\r\nstatic void em_meta_destroy(struct tcf_proto *tp, struct tcf_ematch *m)\r\n{\r\nif (m)\r\nmeta_delete((struct meta_match *) m->data);\r\n}\r\nstatic int em_meta_dump(struct sk_buff *skb, struct tcf_ematch *em)\r\n{\r\nstruct meta_match *meta = (struct meta_match *) em->data;\r\nstruct tcf_meta_hdr hdr;\r\nstruct meta_type_ops *ops;\r\nmemset(&hdr, 0, sizeof(hdr));\r\nmemcpy(&hdr.left, &meta->lvalue.hdr, sizeof(hdr.left));\r\nmemcpy(&hdr.right, &meta->rvalue.hdr, sizeof(hdr.right));\r\nif (nla_put(skb, TCA_EM_META_HDR, sizeof(hdr), &hdr))\r\ngoto nla_put_failure;\r\nops = meta_type_ops(&meta->lvalue);\r\nif (ops->dump(skb, &meta->lvalue, TCA_EM_META_LVALUE) < 0 ||\r\nops->dump(skb, &meta->rvalue, TCA_EM_META_RVALUE) < 0)\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int __init init_em_meta(void)\r\n{\r\nreturn tcf_em_register(&em_meta_ops);\r\n}\r\nstatic void __exit exit_em_meta(void)\r\n{\r\ntcf_em_unregister(&em_meta_ops);\r\n}
