static int tsl2563_set_power(struct tsl2563_chip *chip, int on)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nu8 cmd;\r\ncmd = on ? TSL2563_CMD_POWER_ON : TSL2563_CMD_POWER_OFF;\r\nreturn i2c_smbus_write_byte_data(client,\r\nTSL2563_CMD | TSL2563_REG_CTRL, cmd);\r\n}\r\nstatic int tsl2563_get_power(struct tsl2563_chip *chip)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, TSL2563_CMD | TSL2563_REG_CTRL);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (ret & TSL2563_CTRL_POWER_MASK) == TSL2563_CMD_POWER_ON;\r\n}\r\nstatic int tsl2563_configure(struct tsl2563_chip *chip)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2563_CMD | TSL2563_REG_TIMING,\r\nchip->gainlevel->gaintime);\r\nif (ret)\r\ngoto error_ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2563_CMD | TSL2563_REG_HIGHLOW,\r\nchip->high_thres & 0xFF);\r\nif (ret)\r\ngoto error_ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2563_CMD | TSL2563_REG_HIGHHIGH,\r\n(chip->high_thres >> 8) & 0xFF);\r\nif (ret)\r\ngoto error_ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2563_CMD | TSL2563_REG_LOWLOW,\r\nchip->low_thres & 0xFF);\r\nif (ret)\r\ngoto error_ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2563_CMD | TSL2563_REG_LOWHIGH,\r\n(chip->low_thres >> 8) & 0xFF);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic void tsl2563_poweroff_work(struct work_struct *work)\r\n{\r\nstruct tsl2563_chip *chip =\r\ncontainer_of(work, struct tsl2563_chip, poweroff_work.work);\r\ntsl2563_set_power(chip, 0);\r\n}\r\nstatic int tsl2563_detect(struct tsl2563_chip *chip)\r\n{\r\nint ret;\r\nret = tsl2563_set_power(chip, 1);\r\nif (ret)\r\nreturn ret;\r\nret = tsl2563_get_power(chip);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret ? 0 : -ENODEV;\r\n}\r\nstatic int tsl2563_read_id(struct tsl2563_chip *chip, u8 *id)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, TSL2563_CMD | TSL2563_REG_ID);\r\nif (ret < 0)\r\nreturn ret;\r\n*id = ret;\r\nreturn 0;\r\n}\r\nstatic int adc_shiftbits(u8 timing)\r\n{\r\nint shift = 0;\r\nswitch (timing & TSL2563_TIMING_MASK) {\r\ncase TSL2563_TIMING_13MS:\r\nshift += 5;\r\nbreak;\r\ncase TSL2563_TIMING_100MS:\r\nshift += 2;\r\nbreak;\r\ncase TSL2563_TIMING_400MS:\r\nbreak;\r\n}\r\nif (!(timing & TSL2563_TIMING_GAIN16))\r\nshift += 4;\r\nreturn shift;\r\n}\r\nstatic u32 normalize_adc(u16 adc, u8 timing)\r\n{\r\nreturn adc << adc_shiftbits(timing);\r\n}\r\nstatic void tsl2563_wait_adc(struct tsl2563_chip *chip)\r\n{\r\nunsigned int delay;\r\nswitch (chip->gainlevel->gaintime & TSL2563_TIMING_MASK) {\r\ncase TSL2563_TIMING_13MS:\r\ndelay = 14;\r\nbreak;\r\ncase TSL2563_TIMING_100MS:\r\ndelay = 101;\r\nbreak;\r\ndefault:\r\ndelay = 402;\r\n}\r\nschedule_timeout_interruptible(msecs_to_jiffies(delay) + 2);\r\n}\r\nstatic int tsl2563_adjust_gainlevel(struct tsl2563_chip *chip, u16 adc)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nif (adc > chip->gainlevel->max || adc < chip->gainlevel->min) {\r\n(adc > chip->gainlevel->max) ?\r\nchip->gainlevel++ : chip->gainlevel--;\r\ni2c_smbus_write_byte_data(client,\r\nTSL2563_CMD | TSL2563_REG_TIMING,\r\nchip->gainlevel->gaintime);\r\ntsl2563_wait_adc(chip);\r\ntsl2563_wait_adc(chip);\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int tsl2563_get_adc(struct tsl2563_chip *chip)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nu16 adc0, adc1;\r\nint retry = 1;\r\nint ret = 0;\r\nif (chip->suspended)\r\ngoto out;\r\nif (!chip->int_enabled) {\r\ncancel_delayed_work(&chip->poweroff_work);\r\nif (!tsl2563_get_power(chip)) {\r\nret = tsl2563_set_power(chip, 1);\r\nif (ret)\r\ngoto out;\r\nret = tsl2563_configure(chip);\r\nif (ret)\r\ngoto out;\r\ntsl2563_wait_adc(chip);\r\n}\r\n}\r\nwhile (retry) {\r\nret = i2c_smbus_read_word_data(client,\r\nTSL2563_CMD | TSL2563_REG_DATA0LOW);\r\nif (ret < 0)\r\ngoto out;\r\nadc0 = ret;\r\nret = i2c_smbus_read_word_data(client,\r\nTSL2563_CMD | TSL2563_REG_DATA1LOW);\r\nif (ret < 0)\r\ngoto out;\r\nadc1 = ret;\r\nretry = tsl2563_adjust_gainlevel(chip, adc0);\r\n}\r\nchip->data0 = normalize_adc(adc0, chip->gainlevel->gaintime);\r\nchip->data1 = normalize_adc(adc1, chip->gainlevel->gaintime);\r\nif (!chip->int_enabled)\r\nschedule_delayed_work(&chip->poweroff_work, 5 * HZ);\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic inline int calib_to_sysfs(u32 calib)\r\n{\r\nreturn (int) (((calib * CALIB_BASE_SYSFS) +\r\nCALIB_FRAC_HALF) >> CALIB_FRAC_BITS);\r\n}\r\nstatic inline u32 calib_from_sysfs(int value)\r\n{\r\nreturn (((u32) value) << CALIB_FRAC_BITS) / CALIB_BASE_SYSFS;\r\n}\r\nstatic unsigned int adc_to_lux(u32 adc0, u32 adc1)\r\n{\r\nconst struct tsl2563_lux_coeff *lp = lux_table;\r\nunsigned long ratio, lux, ch0 = adc0, ch1 = adc1;\r\nratio = ch0 ? ((ch1 << ADC_FRAC_BITS) / ch0) : ULONG_MAX;\r\nwhile (lp->ch_ratio < ratio)\r\nlp++;\r\nlux = ch0 * lp->ch0_coeff - ch1 * lp->ch1_coeff;\r\nreturn (unsigned int) (lux >> ADC_FRAC_BITS);\r\n}\r\nstatic u32 calib_adc(u32 adc, u32 calib)\r\n{\r\nunsigned long scaled = adc;\r\nscaled *= calib;\r\nscaled >>= CALIB_FRAC_BITS;\r\nreturn (u32) scaled;\r\n}\r\nstatic int tsl2563_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct tsl2563_chip *chip = iio_priv(indio_dev);\r\nif (mask != IIO_CHAN_INFO_CALIBSCALE)\r\nreturn -EINVAL;\r\nif (chan->channel2 == IIO_MOD_LIGHT_BOTH)\r\nchip->calib0 = calib_from_sysfs(val);\r\nelse if (chan->channel2 == IIO_MOD_LIGHT_IR)\r\nchip->calib1 = calib_from_sysfs(val);\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int tsl2563_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nint ret = -EINVAL;\r\nu32 calib0, calib1;\r\nstruct tsl2563_chip *chip = iio_priv(indio_dev);\r\nmutex_lock(&chip->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\nret = tsl2563_get_adc(chip);\r\nif (ret)\r\ngoto error_ret;\r\ncalib0 = calib_adc(chip->data0, chip->calib0) *\r\nchip->cover_comp_gain;\r\ncalib1 = calib_adc(chip->data1, chip->calib1) *\r\nchip->cover_comp_gain;\r\n*val = adc_to_lux(calib0, calib1);\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_INTENSITY:\r\nret = tsl2563_get_adc(chip);\r\nif (ret)\r\ngoto error_ret;\r\nif (chan->channel2 == IIO_MOD_LIGHT_BOTH)\r\n*val = chip->data0;\r\nelse\r\n*val = chip->data1;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (chan->channel2 == IIO_MOD_LIGHT_BOTH)\r\n*val = calib_to_sysfs(chip->calib0);\r\nelse\r\n*val = calib_to_sysfs(chip->calib1);\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error_ret;\r\n}\r\nerror_ret:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int tsl2563_read_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info, int *val,\r\nint *val2)\r\n{\r\nstruct tsl2563_chip *chip = iio_priv(indio_dev);\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\n*val = chip->high_thres;\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\n*val = chip->low_thres;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int tsl2563_write_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info, int val,\r\nint val2)\r\n{\r\nstruct tsl2563_chip *chip = iio_priv(indio_dev);\r\nint ret;\r\nu8 address;\r\nif (dir == IIO_EV_DIR_RISING)\r\naddress = TSL2563_REG_HIGHLOW;\r\nelse\r\naddress = TSL2563_REG_LOWLOW;\r\nmutex_lock(&chip->lock);\r\nret = i2c_smbus_write_byte_data(chip->client, TSL2563_CMD | address,\r\nval & 0xFF);\r\nif (ret)\r\ngoto error_ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2563_CMD | (address + 1),\r\n(val >> 8) & 0xFF);\r\nif (dir == IIO_EV_DIR_RISING)\r\nchip->high_thres = val;\r\nelse\r\nchip->low_thres = val;\r\nerror_ret:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t tsl2563_event_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *dev_info = private;\r\nstruct tsl2563_chip *chip = iio_priv(dev_info);\r\niio_push_event(dev_info,\r\nIIO_UNMOD_EVENT_CODE(IIO_LIGHT,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_EITHER),\r\niio_get_time_ns());\r\ni2c_smbus_write_byte(chip->client, TSL2563_CMD | TSL2563_CLEARINT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tsl2563_write_interrupt_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, int state)\r\n{\r\nstruct tsl2563_chip *chip = iio_priv(indio_dev);\r\nint ret = 0;\r\nmutex_lock(&chip->lock);\r\nif (state && !(chip->intr & 0x30)) {\r\nchip->intr &= ~0x30;\r\nchip->intr |= 0x10;\r\ncancel_delayed_work(&chip->poweroff_work);\r\nif (!tsl2563_get_power(chip)) {\r\nret = tsl2563_set_power(chip, 1);\r\nif (ret)\r\ngoto out;\r\nret = tsl2563_configure(chip);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2563_CMD | TSL2563_REG_INT,\r\nchip->intr);\r\nchip->int_enabled = true;\r\n}\r\nif (!state && (chip->intr & 0x30)) {\r\nchip->intr &= ~0x30;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2563_CMD | TSL2563_REG_INT,\r\nchip->intr);\r\nchip->int_enabled = false;\r\nschedule_delayed_work(&chip->poweroff_work, 5 * HZ);\r\n}\r\nout:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int tsl2563_read_interrupt_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct tsl2563_chip *chip = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = i2c_smbus_read_byte_data(chip->client,\r\nTSL2563_CMD | TSL2563_REG_INT);\r\nmutex_unlock(&chip->lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(ret & 0x30);\r\n}\r\nstatic int tsl2563_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *device_id)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct tsl2563_chip *chip;\r\nstruct tsl2563_platform_data *pdata = client->dev.platform_data;\r\nstruct device_node *np = client->dev.of_node;\r\nint err = 0;\r\nu8 id = 0;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nchip = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, chip);\r\nchip->client = client;\r\nerr = tsl2563_detect(chip);\r\nif (err) {\r\ndev_err(&client->dev, "detect error %d\n", -err);\r\nreturn err;\r\n}\r\nerr = tsl2563_read_id(chip, &id);\r\nif (err) {\r\ndev_err(&client->dev, "read id error %d\n", -err);\r\nreturn err;\r\n}\r\nmutex_init(&chip->lock);\r\nchip->low_thres = 0x0;\r\nchip->high_thres = 0xffff;\r\nchip->gainlevel = tsl2563_gainlevel_table;\r\nchip->intr = TSL2563_INT_PERSIST(4);\r\nchip->calib0 = calib_from_sysfs(CALIB_BASE_SYSFS);\r\nchip->calib1 = calib_from_sysfs(CALIB_BASE_SYSFS);\r\nif (pdata)\r\nchip->cover_comp_gain = pdata->cover_comp_gain;\r\nelse if (np)\r\nof_property_read_u32(np, "amstaos,cover-comp-gain",\r\n&chip->cover_comp_gain);\r\nelse\r\nchip->cover_comp_gain = 1;\r\ndev_info(&client->dev, "model %d, rev. %d\n", id >> 4, id & 0x0f);\r\nindio_dev->name = client->name;\r\nindio_dev->channels = tsl2563_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(tsl2563_channels);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nif (client->irq)\r\nindio_dev->info = &tsl2563_info;\r\nelse\r\nindio_dev->info = &tsl2563_info_no_irq;\r\nif (client->irq) {\r\nerr = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL,\r\n&tsl2563_event_handler,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"tsl2563_event",\r\nindio_dev);\r\nif (err) {\r\ndev_err(&client->dev, "irq request error %d\n", -err);\r\nreturn err;\r\n}\r\n}\r\nerr = tsl2563_configure(chip);\r\nif (err) {\r\ndev_err(&client->dev, "configure error %d\n", -err);\r\nreturn err;\r\n}\r\nINIT_DELAYED_WORK(&chip->poweroff_work, tsl2563_poweroff_work);\r\nschedule_delayed_work(&chip->poweroff_work, 5 * HZ);\r\nerr = iio_device_register(indio_dev);\r\nif (err) {\r\ndev_err(&client->dev, "iio registration error %d\n", -err);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\ncancel_delayed_work(&chip->poweroff_work);\r\nflush_scheduled_work();\r\nreturn err;\r\n}\r\nstatic int tsl2563_remove(struct i2c_client *client)\r\n{\r\nstruct tsl2563_chip *chip = i2c_get_clientdata(client);\r\nstruct iio_dev *indio_dev = iio_priv_to_dev(chip);\r\niio_device_unregister(indio_dev);\r\nif (!chip->int_enabled)\r\ncancel_delayed_work(&chip->poweroff_work);\r\nchip->intr &= ~0x30;\r\ni2c_smbus_write_byte_data(chip->client, TSL2563_CMD | TSL2563_REG_INT,\r\nchip->intr);\r\nflush_scheduled_work();\r\ntsl2563_set_power(chip, 0);\r\nreturn 0;\r\n}\r\nstatic int tsl2563_suspend(struct device *dev)\r\n{\r\nstruct tsl2563_chip *chip = i2c_get_clientdata(to_i2c_client(dev));\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = tsl2563_set_power(chip, 0);\r\nif (ret)\r\ngoto out;\r\nchip->suspended = true;\r\nout:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int tsl2563_resume(struct device *dev)\r\n{\r\nstruct tsl2563_chip *chip = i2c_get_clientdata(to_i2c_client(dev));\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = tsl2563_set_power(chip, 1);\r\nif (ret)\r\ngoto out;\r\nret = tsl2563_configure(chip);\r\nif (ret)\r\ngoto out;\r\nchip->suspended = false;\r\nout:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}
