static unsigned long intc_irqpin_read32(void __iomem *iomem)\r\n{\r\nreturn ioread32(iomem);\r\n}\r\nstatic unsigned long intc_irqpin_read8(void __iomem *iomem)\r\n{\r\nreturn ioread8(iomem);\r\n}\r\nstatic void intc_irqpin_write32(void __iomem *iomem, unsigned long data)\r\n{\r\niowrite32(data, iomem);\r\n}\r\nstatic void intc_irqpin_write8(void __iomem *iomem, unsigned long data)\r\n{\r\niowrite8(data, iomem);\r\n}\r\nstatic inline unsigned long intc_irqpin_read(struct intc_irqpin_priv *p,\r\nint reg)\r\n{\r\nstruct intc_irqpin_iomem *i = &p->iomem[reg];\r\nreturn i->read(i->iomem);\r\n}\r\nstatic inline void intc_irqpin_write(struct intc_irqpin_priv *p,\r\nint reg, unsigned long data)\r\n{\r\nstruct intc_irqpin_iomem *i = &p->iomem[reg];\r\ni->write(i->iomem, data);\r\n}\r\nstatic inline unsigned long intc_irqpin_hwirq_mask(struct intc_irqpin_priv *p,\r\nint reg, int hw_irq)\r\n{\r\nreturn BIT((p->iomem[reg].width - 1) - hw_irq);\r\n}\r\nstatic inline void intc_irqpin_irq_write_hwirq(struct intc_irqpin_priv *p,\r\nint reg, int hw_irq)\r\n{\r\nintc_irqpin_write(p, reg, intc_irqpin_hwirq_mask(p, reg, hw_irq));\r\n}\r\nstatic void intc_irqpin_read_modify_write(struct intc_irqpin_priv *p,\r\nint reg, int shift,\r\nint width, int value)\r\n{\r\nunsigned long flags;\r\nunsigned long tmp;\r\nraw_spin_lock_irqsave(&intc_irqpin_lock, flags);\r\ntmp = intc_irqpin_read(p, reg);\r\ntmp &= ~(((1 << width) - 1) << shift);\r\ntmp |= value << shift;\r\nintc_irqpin_write(p, reg, tmp);\r\nraw_spin_unlock_irqrestore(&intc_irqpin_lock, flags);\r\n}\r\nstatic void intc_irqpin_mask_unmask_prio(struct intc_irqpin_priv *p,\r\nint irq, int do_mask)\r\n{\r\nint bitfield_width = 4;\r\nint shift = 32 - (irq + 1) * bitfield_width;\r\nintc_irqpin_read_modify_write(p, INTC_IRQPIN_REG_PRIO,\r\nshift, bitfield_width,\r\ndo_mask ? 0 : (1 << bitfield_width) - 1);\r\n}\r\nstatic int intc_irqpin_set_sense(struct intc_irqpin_priv *p, int irq, int value)\r\n{\r\nint bitfield_width = p->config.sense_bitfield_width;\r\nint shift = 32 - (irq + 1) * bitfield_width;\r\ndev_dbg(&p->pdev->dev, "sense irq = %d, mode = %d\n", irq, value);\r\nif (value >= (1 << bitfield_width))\r\nreturn -EINVAL;\r\nintc_irqpin_read_modify_write(p, INTC_IRQPIN_REG_SENSE, shift,\r\nbitfield_width, value);\r\nreturn 0;\r\n}\r\nstatic void intc_irqpin_dbg(struct intc_irqpin_irq *i, char *str)\r\n{\r\ndev_dbg(&i->p->pdev->dev, "%s (%d:%d:%d)\n",\r\nstr, i->requested_irq, i->hw_irq, i->domain_irq);\r\n}\r\nstatic void intc_irqpin_irq_enable(struct irq_data *d)\r\n{\r\nstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\r\nint hw_irq = irqd_to_hwirq(d);\r\nintc_irqpin_dbg(&p->irq[hw_irq], "enable");\r\nintc_irqpin_irq_write_hwirq(p, INTC_IRQPIN_REG_CLEAR, hw_irq);\r\n}\r\nstatic void intc_irqpin_irq_disable(struct irq_data *d)\r\n{\r\nstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\r\nint hw_irq = irqd_to_hwirq(d);\r\nintc_irqpin_dbg(&p->irq[hw_irq], "disable");\r\nintc_irqpin_irq_write_hwirq(p, INTC_IRQPIN_REG_MASK, hw_irq);\r\n}\r\nstatic void intc_irqpin_shared_irq_enable(struct irq_data *d)\r\n{\r\nstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\r\nint hw_irq = irqd_to_hwirq(d);\r\nintc_irqpin_dbg(&p->irq[hw_irq], "shared enable");\r\nintc_irqpin_irq_write_hwirq(p, INTC_IRQPIN_REG_CLEAR, hw_irq);\r\np->shared_irq_mask &= ~BIT(hw_irq);\r\n}\r\nstatic void intc_irqpin_shared_irq_disable(struct irq_data *d)\r\n{\r\nstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\r\nint hw_irq = irqd_to_hwirq(d);\r\nintc_irqpin_dbg(&p->irq[hw_irq], "shared disable");\r\nintc_irqpin_irq_write_hwirq(p, INTC_IRQPIN_REG_MASK, hw_irq);\r\np->shared_irq_mask |= BIT(hw_irq);\r\n}\r\nstatic void intc_irqpin_irq_enable_force(struct irq_data *d)\r\n{\r\nstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\r\nint irq = p->irq[irqd_to_hwirq(d)].requested_irq;\r\nintc_irqpin_irq_enable(d);\r\nirq_get_chip(irq)->irq_unmask(irq_get_irq_data(irq));\r\n}\r\nstatic void intc_irqpin_irq_disable_force(struct irq_data *d)\r\n{\r\nstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\r\nint irq = p->irq[irqd_to_hwirq(d)].requested_irq;\r\nirq_get_chip(irq)->irq_mask(irq_get_irq_data(irq));\r\nintc_irqpin_irq_disable(d);\r\n}\r\nstatic int intc_irqpin_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nunsigned char value = intc_irqpin_sense[type & IRQ_TYPE_SENSE_MASK];\r\nstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\r\nif (!(value & INTC_IRQ_SENSE_VALID))\r\nreturn -EINVAL;\r\nreturn intc_irqpin_set_sense(p, irqd_to_hwirq(d),\r\nvalue ^ INTC_IRQ_SENSE_VALID);\r\n}\r\nstatic irqreturn_t intc_irqpin_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct intc_irqpin_irq *i = dev_id;\r\nstruct intc_irqpin_priv *p = i->p;\r\nunsigned long bit;\r\nintc_irqpin_dbg(i, "demux1");\r\nbit = intc_irqpin_hwirq_mask(p, INTC_IRQPIN_REG_SOURCE, i->hw_irq);\r\nif (intc_irqpin_read(p, INTC_IRQPIN_REG_SOURCE) & bit) {\r\nintc_irqpin_write(p, INTC_IRQPIN_REG_SOURCE, ~bit);\r\nintc_irqpin_dbg(i, "demux2");\r\ngeneric_handle_irq(i->domain_irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t intc_irqpin_shared_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct intc_irqpin_priv *p = dev_id;\r\nunsigned int reg_source = intc_irqpin_read(p, INTC_IRQPIN_REG_SOURCE);\r\nirqreturn_t status = IRQ_NONE;\r\nint k;\r\nfor (k = 0; k < 8; k++) {\r\nif (reg_source & BIT(7 - k)) {\r\nif (BIT(k) & p->shared_irq_mask)\r\ncontinue;\r\nstatus |= intc_irqpin_irq_handler(irq, &p->irq[k]);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int intc_irqpin_irq_domain_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct intc_irqpin_priv *p = h->host_data;\r\np->irq[hw].domain_irq = virq;\r\np->irq[hw].hw_irq = hw;\r\nintc_irqpin_dbg(&p->irq[hw], "map");\r\nirq_set_chip_data(virq, h->host_data);\r\nirq_set_chip_and_handler(virq, &p->irq_chip, handle_level_irq);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic int intc_irqpin_probe(struct platform_device *pdev)\r\n{\r\nstruct renesas_intc_irqpin_config *pdata = pdev->dev.platform_data;\r\nstruct intc_irqpin_priv *p;\r\nstruct intc_irqpin_iomem *i;\r\nstruct resource *io[INTC_IRQPIN_REG_NR];\r\nstruct resource *irq;\r\nstruct irq_chip *irq_chip;\r\nvoid (*enable_fn)(struct irq_data *d);\r\nvoid (*disable_fn)(struct irq_data *d);\r\nconst char *name = dev_name(&pdev->dev);\r\nint ref_irq;\r\nint ret;\r\nint k;\r\np = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\r\nif (!p) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\nif (pdata) {\r\nmemcpy(&p->config, pdata, sizeof(*pdata));\r\n} else {\r\nof_property_read_u32(pdev->dev.of_node, "sense-bitfield-width",\r\n&p->config.sense_bitfield_width);\r\np->config.control_parent = of_property_read_bool(pdev->dev.of_node,\r\n"control-parent");\r\n}\r\nif (!p->config.sense_bitfield_width)\r\np->config.sense_bitfield_width = 4;\r\np->pdev = pdev;\r\nplatform_set_drvdata(pdev, p);\r\nfor (k = 0; k < INTC_IRQPIN_REG_NR; k++) {\r\nio[k] = platform_get_resource(pdev, IORESOURCE_MEM, k);\r\nif (!io[k]) {\r\ndev_err(&pdev->dev, "not enough IOMEM resources\n");\r\nret = -EINVAL;\r\ngoto err0;\r\n}\r\n}\r\nfor (k = 0; k < INTC_IRQPIN_MAX; k++) {\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, k);\r\nif (!irq)\r\nbreak;\r\np->irq[k].p = p;\r\np->irq[k].requested_irq = irq->start;\r\n}\r\np->number_of_irqs = k;\r\nif (p->number_of_irqs < 1) {\r\ndev_err(&pdev->dev, "not enough IRQ resources\n");\r\nret = -EINVAL;\r\ngoto err0;\r\n}\r\nfor (k = 0; k < INTC_IRQPIN_REG_NR; k++) {\r\ni = &p->iomem[k];\r\nswitch (resource_size(io[k])) {\r\ncase 1:\r\ni->width = 8;\r\ni->read = intc_irqpin_read8;\r\ni->write = intc_irqpin_write8;\r\nbreak;\r\ncase 4:\r\ni->width = 32;\r\ni->read = intc_irqpin_read32;\r\ni->write = intc_irqpin_write32;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "IOMEM size mismatch\n");\r\nret = -EINVAL;\r\ngoto err0;\r\n}\r\ni->iomem = devm_ioremap_nocache(&pdev->dev, io[k]->start,\r\nresource_size(io[k]));\r\nif (!i->iomem) {\r\ndev_err(&pdev->dev, "failed to remap IOMEM\n");\r\nret = -ENXIO;\r\ngoto err0;\r\n}\r\n}\r\nfor (k = 0; k < p->number_of_irqs; k++)\r\nintc_irqpin_mask_unmask_prio(p, k, 1);\r\nintc_irqpin_write(p, INTC_IRQPIN_REG_SOURCE, 0x0);\r\nref_irq = p->irq[0].requested_irq;\r\np->shared_irqs = true;\r\nfor (k = 1; k < p->number_of_irqs; k++) {\r\nif (ref_irq != p->irq[k].requested_irq) {\r\np->shared_irqs = false;\r\nbreak;\r\n}\r\n}\r\nif (p->config.control_parent) {\r\nenable_fn = intc_irqpin_irq_enable_force;\r\ndisable_fn = intc_irqpin_irq_disable_force;\r\n} else if (!p->shared_irqs) {\r\nenable_fn = intc_irqpin_irq_enable;\r\ndisable_fn = intc_irqpin_irq_disable;\r\n} else {\r\nenable_fn = intc_irqpin_shared_irq_enable;\r\ndisable_fn = intc_irqpin_shared_irq_disable;\r\n}\r\nirq_chip = &p->irq_chip;\r\nirq_chip->name = name;\r\nirq_chip->irq_mask = disable_fn;\r\nirq_chip->irq_unmask = enable_fn;\r\nirq_chip->irq_enable = enable_fn;\r\nirq_chip->irq_disable = disable_fn;\r\nirq_chip->irq_set_type = intc_irqpin_irq_set_type;\r\nirq_chip->flags = IRQCHIP_SKIP_SET_WAKE;\r\np->irq_domain = irq_domain_add_simple(pdev->dev.of_node,\r\np->number_of_irqs,\r\np->config.irq_base,\r\n&intc_irqpin_irq_domain_ops, p);\r\nif (!p->irq_domain) {\r\nret = -ENXIO;\r\ndev_err(&pdev->dev, "cannot initialize irq domain\n");\r\ngoto err0;\r\n}\r\nif (p->shared_irqs) {\r\nif (devm_request_irq(&pdev->dev, p->irq[0].requested_irq,\r\nintc_irqpin_shared_irq_handler,\r\nIRQF_SHARED, name, p)) {\r\ndev_err(&pdev->dev, "failed to request low IRQ\n");\r\nret = -ENOENT;\r\ngoto err1;\r\n}\r\n} else {\r\nfor (k = 0; k < p->number_of_irqs; k++) {\r\nif (devm_request_irq(&pdev->dev,\r\np->irq[k].requested_irq,\r\nintc_irqpin_irq_handler,\r\n0, name, &p->irq[k])) {\r\ndev_err(&pdev->dev,\r\n"failed to request low IRQ\n");\r\nret = -ENOENT;\r\ngoto err1;\r\n}\r\n}\r\n}\r\nfor (k = 0; k < p->number_of_irqs; k++)\r\nintc_irqpin_mask_unmask_prio(p, k, 0);\r\ndev_info(&pdev->dev, "driving %d irqs\n", p->number_of_irqs);\r\nif (p->config.irq_base) {\r\nif (p->config.irq_base != p->irq[0].domain_irq)\r\ndev_warn(&pdev->dev, "irq base mismatch (%d/%d)\n",\r\np->config.irq_base, p->irq[0].domain_irq);\r\n}\r\nreturn 0;\r\nerr1:\r\nirq_domain_remove(p->irq_domain);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int intc_irqpin_remove(struct platform_device *pdev)\r\n{\r\nstruct intc_irqpin_priv *p = platform_get_drvdata(pdev);\r\nirq_domain_remove(p->irq_domain);\r\nreturn 0;\r\n}\r\nstatic int __init intc_irqpin_init(void)\r\n{\r\nreturn platform_driver_register(&intc_irqpin_device_driver);\r\n}\r\nstatic void __exit intc_irqpin_exit(void)\r\n{\r\nplatform_driver_unregister(&intc_irqpin_device_driver);\r\n}
