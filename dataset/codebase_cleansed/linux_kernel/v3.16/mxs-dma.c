static struct mxs_dma_chan *to_mxs_dma_chan(struct dma_chan *chan)\r\n{\r\nreturn container_of(chan, struct mxs_dma_chan, chan);\r\n}\r\nstatic void mxs_dma_reset_chan(struct mxs_dma_chan *mxs_chan)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint chan_id = mxs_chan->chan.chan_id;\r\nif (mxs_chan->flags & MXS_DMA_USE_SEMAPHORE &&\r\nmxs_chan->flags & MXS_DMA_SG_LOOP) {\r\nmxs_chan->reset = true;\r\n} else if (dma_is_apbh(mxs_dma) && apbh_is_old(mxs_dma)) {\r\nwritel(1 << (chan_id + BP_APBH_CTRL0_RESET_CHANNEL),\r\nmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\r\n} else {\r\nunsigned long elapsed = 0;\r\nconst unsigned long max_wait = 50000;\r\nvoid __iomem *reg_dbg1 = mxs_dma->base +\r\nHW_APBX_CHn_DEBUG1(mxs_dma, chan_id);\r\nwhile ((readl(reg_dbg1) & 0xf) == 0x8 && elapsed < max_wait) {\r\nudelay(100);\r\nelapsed += 100;\r\n}\r\nif (elapsed >= max_wait)\r\ndev_err(&mxs_chan->mxs_dma->pdev->dev,\r\n"Failed waiting for the DMA channel %d to leave state READ_FLUSH, trying to reset channel in READ_FLUSH state now\n",\r\nchan_id);\r\nwritel(1 << (chan_id + BP_APBHX_CHANNEL_CTRL_RESET_CHANNEL),\r\nmxs_dma->base + HW_APBHX_CHANNEL_CTRL + STMP_OFFSET_REG_SET);\r\n}\r\nmxs_chan->status = DMA_COMPLETE;\r\n}\r\nstatic void mxs_dma_enable_chan(struct mxs_dma_chan *mxs_chan)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint chan_id = mxs_chan->chan.chan_id;\r\nwritel(mxs_chan->ccw_phys,\r\nmxs_dma->base + HW_APBHX_CHn_NXTCMDAR(mxs_dma, chan_id));\r\nif (mxs_chan->flags & MXS_DMA_USE_SEMAPHORE &&\r\nmxs_chan->flags & MXS_DMA_SG_LOOP) {\r\nwritel(2, mxs_dma->base + HW_APBHX_CHn_SEMA(mxs_dma, chan_id));\r\n} else {\r\nwritel(1, mxs_dma->base + HW_APBHX_CHn_SEMA(mxs_dma, chan_id));\r\n}\r\nmxs_chan->reset = false;\r\n}\r\nstatic void mxs_dma_disable_chan(struct mxs_dma_chan *mxs_chan)\r\n{\r\nmxs_chan->status = DMA_COMPLETE;\r\n}\r\nstatic void mxs_dma_pause_chan(struct mxs_dma_chan *mxs_chan)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint chan_id = mxs_chan->chan.chan_id;\r\nif (dma_is_apbh(mxs_dma) && apbh_is_old(mxs_dma))\r\nwritel(1 << chan_id,\r\nmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\r\nelse\r\nwritel(1 << chan_id,\r\nmxs_dma->base + HW_APBHX_CHANNEL_CTRL + STMP_OFFSET_REG_SET);\r\nmxs_chan->status = DMA_PAUSED;\r\n}\r\nstatic void mxs_dma_resume_chan(struct mxs_dma_chan *mxs_chan)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint chan_id = mxs_chan->chan.chan_id;\r\nif (dma_is_apbh(mxs_dma) && apbh_is_old(mxs_dma))\r\nwritel(1 << chan_id,\r\nmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_CLR);\r\nelse\r\nwritel(1 << chan_id,\r\nmxs_dma->base + HW_APBHX_CHANNEL_CTRL + STMP_OFFSET_REG_CLR);\r\nmxs_chan->status = DMA_IN_PROGRESS;\r\n}\r\nstatic dma_cookie_t mxs_dma_tx_submit(struct dma_async_tx_descriptor *tx)\r\n{\r\nreturn dma_cookie_assign(tx);\r\n}\r\nstatic void mxs_dma_tasklet(unsigned long data)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = (struct mxs_dma_chan *) data;\r\nif (mxs_chan->desc.callback)\r\nmxs_chan->desc.callback(mxs_chan->desc.callback_param);\r\n}\r\nstatic int mxs_dma_irq_to_chan(struct mxs_dma_engine *mxs_dma, int irq)\r\n{\r\nint i;\r\nfor (i = 0; i != mxs_dma->nr_channels; ++i)\r\nif (mxs_dma->mxs_chans[i].chan_irq == irq)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic irqreturn_t mxs_dma_int_handler(int irq, void *dev_id)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = dev_id;\r\nstruct mxs_dma_chan *mxs_chan;\r\nu32 completed;\r\nu32 err;\r\nint chan = mxs_dma_irq_to_chan(mxs_dma, irq);\r\nif (chan < 0)\r\nreturn IRQ_NONE;\r\ncompleted = readl(mxs_dma->base + HW_APBHX_CTRL1);\r\ncompleted = (completed >> chan) & 0x1;\r\nwritel((1 << chan),\r\nmxs_dma->base + HW_APBHX_CTRL1 + STMP_OFFSET_REG_CLR);\r\nerr = readl(mxs_dma->base + HW_APBHX_CTRL2);\r\nerr &= (1 << (MXS_DMA_CHANNELS + chan)) | (1 << chan);\r\nerr = (err >> (MXS_DMA_CHANNELS + chan)) + (err >> chan);\r\nwritel((1 << chan),\r\nmxs_dma->base + HW_APBHX_CTRL2 + STMP_OFFSET_REG_CLR);\r\nerr -= err & completed;\r\nmxs_chan = &mxs_dma->mxs_chans[chan];\r\nif (err) {\r\ndev_dbg(mxs_dma->dma_device.dev,\r\n"%s: error in channel %d\n", __func__,\r\nchan);\r\nmxs_chan->status = DMA_ERROR;\r\nmxs_dma_reset_chan(mxs_chan);\r\n} else if (mxs_chan->status != DMA_COMPLETE) {\r\nif (mxs_chan->flags & MXS_DMA_SG_LOOP) {\r\nmxs_chan->status = DMA_IN_PROGRESS;\r\nif (mxs_chan->flags & MXS_DMA_USE_SEMAPHORE)\r\nwritel(1, mxs_dma->base +\r\nHW_APBHX_CHn_SEMA(mxs_dma, chan));\r\n} else {\r\nmxs_chan->status = DMA_COMPLETE;\r\n}\r\n}\r\nif (mxs_chan->status == DMA_COMPLETE) {\r\nif (mxs_chan->reset)\r\nreturn IRQ_HANDLED;\r\ndma_cookie_complete(&mxs_chan->desc);\r\n}\r\ntasklet_schedule(&mxs_chan->tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxs_dma_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint ret;\r\nmxs_chan->ccw = dma_alloc_coherent(mxs_dma->dma_device.dev,\r\nCCW_BLOCK_SIZE, &mxs_chan->ccw_phys,\r\nGFP_KERNEL);\r\nif (!mxs_chan->ccw) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nmemset(mxs_chan->ccw, 0, CCW_BLOCK_SIZE);\r\nif (mxs_chan->chan_irq != NO_IRQ) {\r\nret = request_irq(mxs_chan->chan_irq, mxs_dma_int_handler,\r\n0, "mxs-dma", mxs_dma);\r\nif (ret)\r\ngoto err_irq;\r\n}\r\nret = clk_prepare_enable(mxs_dma->clk);\r\nif (ret)\r\ngoto err_clk;\r\nmxs_dma_reset_chan(mxs_chan);\r\ndma_async_tx_descriptor_init(&mxs_chan->desc, chan);\r\nmxs_chan->desc.tx_submit = mxs_dma_tx_submit;\r\nasync_tx_ack(&mxs_chan->desc);\r\nreturn 0;\r\nerr_clk:\r\nfree_irq(mxs_chan->chan_irq, mxs_dma);\r\nerr_irq:\r\ndma_free_coherent(mxs_dma->dma_device.dev, CCW_BLOCK_SIZE,\r\nmxs_chan->ccw, mxs_chan->ccw_phys);\r\nerr_alloc:\r\nreturn ret;\r\n}\r\nstatic void mxs_dma_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nmxs_dma_disable_chan(mxs_chan);\r\nfree_irq(mxs_chan->chan_irq, mxs_dma);\r\ndma_free_coherent(mxs_dma->dma_device.dev, CCW_BLOCK_SIZE,\r\nmxs_chan->ccw, mxs_chan->ccw_phys);\r\nclk_disable_unprepare(mxs_dma->clk);\r\n}\r\nstatic struct dma_async_tx_descriptor *mxs_dma_prep_slave_sg(\r\nstruct dma_chan *chan, struct scatterlist *sgl,\r\nunsigned int sg_len, enum dma_transfer_direction direction,\r\nunsigned long flags, void *context)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nstruct mxs_dma_ccw *ccw;\r\nstruct scatterlist *sg;\r\nu32 i, j;\r\nu32 *pio;\r\nbool append = flags & DMA_PREP_INTERRUPT;\r\nint idx = append ? mxs_chan->desc_count : 0;\r\nif (mxs_chan->status == DMA_IN_PROGRESS && !append)\r\nreturn NULL;\r\nif (sg_len + (append ? idx : 0) > NUM_CCW) {\r\ndev_err(mxs_dma->dma_device.dev,\r\n"maximum number of sg exceeded: %d > %d\n",\r\nsg_len, NUM_CCW);\r\ngoto err_out;\r\n}\r\nmxs_chan->status = DMA_IN_PROGRESS;\r\nmxs_chan->flags = 0;\r\nif (append) {\r\nBUG_ON(idx < 1);\r\nccw = &mxs_chan->ccw[idx - 1];\r\nccw->next = mxs_chan->ccw_phys + sizeof(*ccw) * idx;\r\nccw->bits |= CCW_CHAIN;\r\nccw->bits &= ~CCW_IRQ;\r\nccw->bits &= ~CCW_DEC_SEM;\r\n} else {\r\nidx = 0;\r\n}\r\nif (direction == DMA_TRANS_NONE) {\r\nccw = &mxs_chan->ccw[idx++];\r\npio = (u32 *) sgl;\r\nfor (j = 0; j < sg_len;)\r\nccw->pio_words[j++] = *pio++;\r\nccw->bits = 0;\r\nccw->bits |= CCW_IRQ;\r\nccw->bits |= CCW_DEC_SEM;\r\nif (flags & DMA_CTRL_ACK)\r\nccw->bits |= CCW_WAIT4END;\r\nccw->bits |= CCW_HALT_ON_TERM;\r\nccw->bits |= CCW_TERM_FLUSH;\r\nccw->bits |= BF_CCW(sg_len, PIO_NUM);\r\nccw->bits |= BF_CCW(MXS_DMA_CMD_NO_XFER, COMMAND);\r\n} else {\r\nfor_each_sg(sgl, sg, sg_len, i) {\r\nif (sg_dma_len(sg) > MAX_XFER_BYTES) {\r\ndev_err(mxs_dma->dma_device.dev, "maximum bytes for sg entry exceeded: %d > %d\n",\r\nsg_dma_len(sg), MAX_XFER_BYTES);\r\ngoto err_out;\r\n}\r\nccw = &mxs_chan->ccw[idx++];\r\nccw->next = mxs_chan->ccw_phys + sizeof(*ccw) * idx;\r\nccw->bufaddr = sg->dma_address;\r\nccw->xfer_bytes = sg_dma_len(sg);\r\nccw->bits = 0;\r\nccw->bits |= CCW_CHAIN;\r\nccw->bits |= CCW_HALT_ON_TERM;\r\nccw->bits |= CCW_TERM_FLUSH;\r\nccw->bits |= BF_CCW(direction == DMA_DEV_TO_MEM ?\r\nMXS_DMA_CMD_WRITE : MXS_DMA_CMD_READ,\r\nCOMMAND);\r\nif (i + 1 == sg_len) {\r\nccw->bits &= ~CCW_CHAIN;\r\nccw->bits |= CCW_IRQ;\r\nccw->bits |= CCW_DEC_SEM;\r\nif (flags & DMA_CTRL_ACK)\r\nccw->bits |= CCW_WAIT4END;\r\n}\r\n}\r\n}\r\nmxs_chan->desc_count = idx;\r\nreturn &mxs_chan->desc;\r\nerr_out:\r\nmxs_chan->status = DMA_ERROR;\r\nreturn NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *mxs_dma_prep_dma_cyclic(\r\nstruct dma_chan *chan, dma_addr_t dma_addr, size_t buf_len,\r\nsize_t period_len, enum dma_transfer_direction direction,\r\nunsigned long flags, void *context)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nu32 num_periods = buf_len / period_len;\r\nu32 i = 0, buf = 0;\r\nif (mxs_chan->status == DMA_IN_PROGRESS)\r\nreturn NULL;\r\nmxs_chan->status = DMA_IN_PROGRESS;\r\nmxs_chan->flags |= MXS_DMA_SG_LOOP;\r\nmxs_chan->flags |= MXS_DMA_USE_SEMAPHORE;\r\nif (num_periods > NUM_CCW) {\r\ndev_err(mxs_dma->dma_device.dev,\r\n"maximum number of sg exceeded: %d > %d\n",\r\nnum_periods, NUM_CCW);\r\ngoto err_out;\r\n}\r\nif (period_len > MAX_XFER_BYTES) {\r\ndev_err(mxs_dma->dma_device.dev,\r\n"maximum period size exceeded: %d > %d\n",\r\nperiod_len, MAX_XFER_BYTES);\r\ngoto err_out;\r\n}\r\nwhile (buf < buf_len) {\r\nstruct mxs_dma_ccw *ccw = &mxs_chan->ccw[i];\r\nif (i + 1 == num_periods)\r\nccw->next = mxs_chan->ccw_phys;\r\nelse\r\nccw->next = mxs_chan->ccw_phys + sizeof(*ccw) * (i + 1);\r\nccw->bufaddr = dma_addr;\r\nccw->xfer_bytes = period_len;\r\nccw->bits = 0;\r\nccw->bits |= CCW_CHAIN;\r\nccw->bits |= CCW_IRQ;\r\nccw->bits |= CCW_HALT_ON_TERM;\r\nccw->bits |= CCW_TERM_FLUSH;\r\nccw->bits |= CCW_DEC_SEM;\r\nccw->bits |= BF_CCW(direction == DMA_DEV_TO_MEM ?\r\nMXS_DMA_CMD_WRITE : MXS_DMA_CMD_READ, COMMAND);\r\ndma_addr += period_len;\r\nbuf += period_len;\r\ni++;\r\n}\r\nmxs_chan->desc_count = i;\r\nreturn &mxs_chan->desc;\r\nerr_out:\r\nmxs_chan->status = DMA_ERROR;\r\nreturn NULL;\r\n}\r\nstatic int mxs_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,\r\nunsigned long arg)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase DMA_TERMINATE_ALL:\r\nmxs_dma_reset_chan(mxs_chan);\r\nmxs_dma_disable_chan(mxs_chan);\r\nbreak;\r\ncase DMA_PAUSE:\r\nmxs_dma_pause_chan(mxs_chan);\r\nbreak;\r\ncase DMA_RESUME:\r\nmxs_dma_resume_chan(mxs_chan);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\n}\r\nreturn ret;\r\n}\r\nstatic enum dma_status mxs_dma_tx_status(struct dma_chan *chan,\r\ndma_cookie_t cookie, struct dma_tx_state *txstate)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nu32 residue = 0;\r\nif (mxs_chan->status == DMA_IN_PROGRESS &&\r\nmxs_chan->flags & MXS_DMA_SG_LOOP) {\r\nstruct mxs_dma_ccw *last_ccw;\r\nu32 bar;\r\nlast_ccw = &mxs_chan->ccw[mxs_chan->desc_count - 1];\r\nresidue = last_ccw->xfer_bytes + last_ccw->bufaddr;\r\nbar = readl(mxs_dma->base +\r\nHW_APBHX_CHn_BAR(mxs_dma, chan->chan_id));\r\nresidue -= bar;\r\n}\r\ndma_set_tx_state(txstate, chan->completed_cookie, chan->cookie,\r\nresidue);\r\nreturn mxs_chan->status;\r\n}\r\nstatic void mxs_dma_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nmxs_dma_enable_chan(mxs_chan);\r\n}\r\nstatic int __init mxs_dma_init(struct mxs_dma_engine *mxs_dma)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(mxs_dma->clk);\r\nif (ret)\r\nreturn ret;\r\nret = stmp_reset_block(mxs_dma->base);\r\nif (ret)\r\ngoto err_out;\r\nif (dma_is_apbh(mxs_dma)) {\r\nwritel(BM_APBH_CTRL0_APB_BURST_EN,\r\nmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\r\nwritel(BM_APBH_CTRL0_APB_BURST8_EN,\r\nmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\r\n}\r\nwritel(MXS_DMA_CHANNELS_MASK << MXS_DMA_CHANNELS,\r\nmxs_dma->base + HW_APBHX_CTRL1 + STMP_OFFSET_REG_SET);\r\nerr_out:\r\nclk_disable_unprepare(mxs_dma->clk);\r\nreturn ret;\r\n}\r\nstatic bool mxs_dma_filter_fn(struct dma_chan *chan, void *fn_param)\r\n{\r\nstruct mxs_dma_filter_param *param = fn_param;\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint chan_irq;\r\nif (mxs_dma->dma_device.dev->of_node != param->of_node)\r\nreturn false;\r\nif (chan->chan_id != param->chan_id)\r\nreturn false;\r\nchan_irq = platform_get_irq(mxs_dma->pdev, param->chan_id);\r\nif (chan_irq < 0)\r\nreturn false;\r\nmxs_chan->chan_irq = chan_irq;\r\nreturn true;\r\n}\r\nstatic struct dma_chan *mxs_dma_xlate(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = ofdma->of_dma_data;\r\ndma_cap_mask_t mask = mxs_dma->dma_device.cap_mask;\r\nstruct mxs_dma_filter_param param;\r\nif (dma_spec->args_count != 1)\r\nreturn NULL;\r\nparam.of_node = ofdma->of_node;\r\nparam.chan_id = dma_spec->args[0];\r\nif (param.chan_id >= mxs_dma->nr_channels)\r\nreturn NULL;\r\nreturn dma_request_channel(mask, mxs_dma_filter_fn, &param);\r\n}\r\nstatic int __init mxs_dma_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct platform_device_id *id_entry;\r\nconst struct of_device_id *of_id;\r\nconst struct mxs_dma_type *dma_type;\r\nstruct mxs_dma_engine *mxs_dma;\r\nstruct resource *iores;\r\nint ret, i;\r\nmxs_dma = devm_kzalloc(&pdev->dev, sizeof(*mxs_dma), GFP_KERNEL);\r\nif (!mxs_dma)\r\nreturn -ENOMEM;\r\nret = of_property_read_u32(np, "dma-channels", &mxs_dma->nr_channels);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to read dma-channels\n");\r\nreturn ret;\r\n}\r\nof_id = of_match_device(mxs_dma_dt_ids, &pdev->dev);\r\nif (of_id)\r\nid_entry = of_id->data;\r\nelse\r\nid_entry = platform_get_device_id(pdev);\r\ndma_type = (struct mxs_dma_type *)id_entry->driver_data;\r\nmxs_dma->type = dma_type->type;\r\nmxs_dma->dev_id = dma_type->id;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmxs_dma->base = devm_ioremap_resource(&pdev->dev, iores);\r\nif (IS_ERR(mxs_dma->base))\r\nreturn PTR_ERR(mxs_dma->base);\r\nmxs_dma->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mxs_dma->clk))\r\nreturn PTR_ERR(mxs_dma->clk);\r\ndma_cap_set(DMA_SLAVE, mxs_dma->dma_device.cap_mask);\r\ndma_cap_set(DMA_CYCLIC, mxs_dma->dma_device.cap_mask);\r\nINIT_LIST_HEAD(&mxs_dma->dma_device.channels);\r\nfor (i = 0; i < MXS_DMA_CHANNELS; i++) {\r\nstruct mxs_dma_chan *mxs_chan = &mxs_dma->mxs_chans[i];\r\nmxs_chan->mxs_dma = mxs_dma;\r\nmxs_chan->chan.device = &mxs_dma->dma_device;\r\ndma_cookie_init(&mxs_chan->chan);\r\ntasklet_init(&mxs_chan->tasklet, mxs_dma_tasklet,\r\n(unsigned long) mxs_chan);\r\nlist_add_tail(&mxs_chan->chan.device_node,\r\n&mxs_dma->dma_device.channels);\r\n}\r\nret = mxs_dma_init(mxs_dma);\r\nif (ret)\r\nreturn ret;\r\nmxs_dma->pdev = pdev;\r\nmxs_dma->dma_device.dev = &pdev->dev;\r\nmxs_dma->dma_device.dev->dma_parms = &mxs_dma->dma_parms;\r\ndma_set_max_seg_size(mxs_dma->dma_device.dev, MAX_XFER_BYTES);\r\nmxs_dma->dma_device.device_alloc_chan_resources = mxs_dma_alloc_chan_resources;\r\nmxs_dma->dma_device.device_free_chan_resources = mxs_dma_free_chan_resources;\r\nmxs_dma->dma_device.device_tx_status = mxs_dma_tx_status;\r\nmxs_dma->dma_device.device_prep_slave_sg = mxs_dma_prep_slave_sg;\r\nmxs_dma->dma_device.device_prep_dma_cyclic = mxs_dma_prep_dma_cyclic;\r\nmxs_dma->dma_device.device_control = mxs_dma_control;\r\nmxs_dma->dma_device.device_issue_pending = mxs_dma_issue_pending;\r\nret = dma_async_device_register(&mxs_dma->dma_device);\r\nif (ret) {\r\ndev_err(mxs_dma->dma_device.dev, "unable to register\n");\r\nreturn ret;\r\n}\r\nret = of_dma_controller_register(np, mxs_dma_xlate, mxs_dma);\r\nif (ret) {\r\ndev_err(mxs_dma->dma_device.dev,\r\n"failed to register controller\n");\r\ndma_async_device_unregister(&mxs_dma->dma_device);\r\n}\r\ndev_info(mxs_dma->dma_device.dev, "initialized\n");\r\nreturn 0;\r\n}\r\nstatic int __init mxs_dma_module_init(void)\r\n{\r\nreturn platform_driver_probe(&mxs_dma_driver, mxs_dma_probe);\r\n}
