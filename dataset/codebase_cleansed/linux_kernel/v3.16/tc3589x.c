int tc3589x_reg_read(struct tc3589x *tc3589x, u8 reg)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(tc3589x->i2c, reg);\r\nif (ret < 0)\r\ndev_err(tc3589x->dev, "failed to read reg %#x: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nint tc3589x_reg_write(struct tc3589x *tc3589x, u8 reg, u8 data)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(tc3589x->i2c, reg, data);\r\nif (ret < 0)\r\ndev_err(tc3589x->dev, "failed to write reg %#x: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nint tc3589x_block_read(struct tc3589x *tc3589x, u8 reg, u8 length, u8 *values)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_i2c_block_data(tc3589x->i2c, reg, length, values);\r\nif (ret < 0)\r\ndev_err(tc3589x->dev, "failed to read regs %#x: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nint tc3589x_block_write(struct tc3589x *tc3589x, u8 reg, u8 length,\r\nconst u8 *values)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_i2c_block_data(tc3589x->i2c, reg, length,\r\nvalues);\r\nif (ret < 0)\r\ndev_err(tc3589x->dev, "failed to write regs %#x: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nint tc3589x_set_bits(struct tc3589x *tc3589x, u8 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nmutex_lock(&tc3589x->lock);\r\nret = tc3589x_reg_read(tc3589x, reg);\r\nif (ret < 0)\r\ngoto out;\r\nret &= ~mask;\r\nret |= val;\r\nret = tc3589x_reg_write(tc3589x, reg, ret);\r\nout:\r\nmutex_unlock(&tc3589x->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t tc3589x_irq(int irq, void *data)\r\n{\r\nstruct tc3589x *tc3589x = data;\r\nint status;\r\nagain:\r\nstatus = tc3589x_reg_read(tc3589x, TC3589x_IRQST);\r\nif (status < 0)\r\nreturn IRQ_NONE;\r\nwhile (status) {\r\nint bit = __ffs(status);\r\nint virq = irq_create_mapping(tc3589x->domain, bit);\r\nhandle_nested_irq(virq);\r\nstatus &= ~(1 << bit);\r\n}\r\nstatus = tc3589x_reg_read(tc3589x, TC3589x_IRQST);\r\nif (status)\r\ngoto again;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tc3589x_irq_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct tc3589x *tc3589x = d->host_data;\r\nirq_set_chip_data(virq, tc3589x);\r\nirq_set_chip_and_handler(virq, &dummy_irq_chip,\r\nhandle_edge_irq);\r\nirq_set_nested_thread(virq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(virq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(virq);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void tc3589x_irq_unmap(struct irq_domain *d, unsigned int virq)\r\n{\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(virq, 0);\r\n#endif\r\nirq_set_chip_and_handler(virq, NULL, NULL);\r\nirq_set_chip_data(virq, NULL);\r\n}\r\nstatic int tc3589x_irq_init(struct tc3589x *tc3589x, struct device_node *np)\r\n{\r\nint base = tc3589x->irq_base;\r\ntc3589x->domain = irq_domain_add_simple(\r\nnp, TC3589x_NR_INTERNAL_IRQS, base,\r\n&tc3589x_irq_ops, tc3589x);\r\nif (!tc3589x->domain) {\r\ndev_err(tc3589x->dev, "Failed to create irqdomain\n");\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc3589x_chip_init(struct tc3589x *tc3589x)\r\n{\r\nint manf, ver, ret;\r\nmanf = tc3589x_reg_read(tc3589x, TC3589x_MANFCODE);\r\nif (manf < 0)\r\nreturn manf;\r\nver = tc3589x_reg_read(tc3589x, TC3589x_VERSION);\r\nif (ver < 0)\r\nreturn ver;\r\nif (manf != TC3589x_MANFCODE_MAGIC) {\r\ndev_err(tc3589x->dev, "unknown manufacturer: %#x\n", manf);\r\nreturn -EINVAL;\r\n}\r\ndev_info(tc3589x->dev, "manufacturer: %#x, version: %#x\n", manf, ver);\r\nret = tc3589x_reg_write(tc3589x, TC3589x_RSTCTRL,\r\nTC3589x_RSTCTRL_TIMRST\r\n| TC3589x_RSTCTRL_ROTRST\r\n| TC3589x_RSTCTRL_KBDRST);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn tc3589x_reg_write(tc3589x, TC3589x_RSTINTCLR, 0x1);\r\n}\r\nstatic int tc3589x_device_init(struct tc3589x *tc3589x)\r\n{\r\nint ret = 0;\r\nunsigned int blocks = tc3589x->pdata->block;\r\nif (blocks & TC3589x_BLOCK_GPIO) {\r\nret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_gpio,\r\nARRAY_SIZE(tc3589x_dev_gpio), NULL,\r\ntc3589x->irq_base, tc3589x->domain);\r\nif (ret) {\r\ndev_err(tc3589x->dev, "failed to add gpio child\n");\r\nreturn ret;\r\n}\r\ndev_info(tc3589x->dev, "added gpio block\n");\r\n}\r\nif (blocks & TC3589x_BLOCK_KEYPAD) {\r\nret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_keypad,\r\nARRAY_SIZE(tc3589x_dev_keypad), NULL,\r\ntc3589x->irq_base, tc3589x->domain);\r\nif (ret) {\r\ndev_err(tc3589x->dev, "failed to keypad child\n");\r\nreturn ret;\r\n}\r\ndev_info(tc3589x->dev, "added keypad block\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic struct tc3589x_platform_data *\r\ntc3589x_of_probe(struct device *dev, enum tc3589x_version *version)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct tc3589x_platform_data *pdata;\r\nstruct device_node *child;\r\nconst struct of_device_id *of_id;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nof_id = of_match_device(tc3589x_match, dev);\r\nif (!of_id)\r\nreturn ERR_PTR(-ENODEV);\r\n*version = (enum tc3589x_version) of_id->data;\r\nfor_each_child_of_node(np, child) {\r\nif (of_device_is_compatible(child, "toshiba,tc3589x-gpio"))\r\npdata->block |= TC3589x_BLOCK_GPIO;\r\nif (of_device_is_compatible(child, "toshiba,tc3589x-keypad"))\r\npdata->block |= TC3589x_BLOCK_KEYPAD;\r\n}\r\nreturn pdata;\r\n}\r\nstatic inline struct tc3589x_platform_data *\r\ntc3589x_of_probe(struct device *dev, enum tc3589x_version *version)\r\n{\r\ndev_err(dev, "no device tree support\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int tc3589x_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device_node *np = i2c->dev.of_node;\r\nstruct tc3589x_platform_data *pdata = dev_get_platdata(&i2c->dev);\r\nstruct tc3589x *tc3589x;\r\nenum tc3589x_version version;\r\nint ret;\r\nif (!pdata) {\r\npdata = tc3589x_of_probe(&i2c->dev, &version);\r\nif (IS_ERR(pdata)) {\r\ndev_err(&i2c->dev, "No platform data or DT found\n");\r\nreturn PTR_ERR(pdata);\r\n}\r\n} else {\r\nversion = id->driver_data;\r\n}\r\nif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA\r\n| I2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -EIO;\r\ntc3589x = devm_kzalloc(&i2c->dev, sizeof(struct tc3589x),\r\nGFP_KERNEL);\r\nif (!tc3589x)\r\nreturn -ENOMEM;\r\nmutex_init(&tc3589x->lock);\r\ntc3589x->dev = &i2c->dev;\r\ntc3589x->i2c = i2c;\r\ntc3589x->pdata = pdata;\r\ntc3589x->irq_base = pdata->irq_base;\r\nswitch (version) {\r\ncase TC3589X_TC35893:\r\ncase TC3589X_TC35895:\r\ncase TC3589X_TC35896:\r\ntc3589x->num_gpio = 20;\r\nbreak;\r\ncase TC3589X_TC35890:\r\ncase TC3589X_TC35892:\r\ncase TC3589X_TC35894:\r\ncase TC3589X_UNKNOWN:\r\ndefault:\r\ntc3589x->num_gpio = 24;\r\nbreak;\r\n}\r\ni2c_set_clientdata(i2c, tc3589x);\r\nret = tc3589x_chip_init(tc3589x);\r\nif (ret)\r\nreturn ret;\r\nret = tc3589x_irq_init(tc3589x, np);\r\nif (ret)\r\nreturn ret;\r\nret = request_threaded_irq(tc3589x->i2c->irq, NULL, tc3589x_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"tc3589x", tc3589x);\r\nif (ret) {\r\ndev_err(tc3589x->dev, "failed to request IRQ: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = tc3589x_device_init(tc3589x);\r\nif (ret) {\r\ndev_err(tc3589x->dev, "failed to add child devices\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc3589x_remove(struct i2c_client *client)\r\n{\r\nstruct tc3589x *tc3589x = i2c_get_clientdata(client);\r\nmfd_remove_devices(tc3589x->dev);\r\nreturn 0;\r\n}\r\nstatic int tc3589x_suspend(struct device *dev)\r\n{\r\nstruct tc3589x *tc3589x = dev_get_drvdata(dev);\r\nstruct i2c_client *client = tc3589x->i2c;\r\nint ret = 0;\r\nif (!device_may_wakeup(&client->dev))\r\nret = tc3589x_reg_write(tc3589x, TC3589x_CLKMODE,\r\nTC3589x_CLKMODE_MODCTL_SLEEP);\r\nreturn ret;\r\n}\r\nstatic int tc3589x_resume(struct device *dev)\r\n{\r\nstruct tc3589x *tc3589x = dev_get_drvdata(dev);\r\nstruct i2c_client *client = tc3589x->i2c;\r\nint ret = 0;\r\nif (!device_may_wakeup(&client->dev))\r\nret = tc3589x_reg_write(tc3589x, TC3589x_CLKMODE,\r\nTC3589x_CLKMODE_MODCTL_OPERATION);\r\nreturn ret;\r\n}\r\nstatic int __init tc3589x_init(void)\r\n{\r\nreturn i2c_add_driver(&tc3589x_driver);\r\n}\r\nstatic void __exit tc3589x_exit(void)\r\n{\r\ni2c_del_driver(&tc3589x_driver);\r\n}
