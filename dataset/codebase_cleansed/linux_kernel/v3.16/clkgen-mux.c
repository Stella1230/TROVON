static const char ** __init clkgen_mux_get_parents(struct device_node *np,\r\nint *num_parents)\r\n{\r\nconst char **parents;\r\nint nparents, i;\r\nnparents = of_count_phandle_with_args(np, "clocks", "#clock-cells");\r\nif (WARN_ON(nparents <= 0))\r\nreturn ERR_PTR(-EINVAL);\r\nparents = kzalloc(nparents * sizeof(const char *), GFP_KERNEL);\r\nif (!parents)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < nparents; i++)\r\nparents[i] = of_clk_get_parent_name(np, i);\r\n*num_parents = nparents;\r\nreturn parents;\r\n}\r\nstatic int clkgena_divmux_is_running(struct clkgena_divmux *mux)\r\n{\r\nu32 regval = readl(mux->feedback_reg[mux->muxsel]);\r\nu32 running = regval & BIT(mux->feedback_bit_idx);\r\nreturn !!running;\r\n}\r\nstatic int clkgena_divmux_enable(struct clk_hw *hw)\r\n{\r\nstruct clkgena_divmux *genamux = to_clkgena_divmux(hw);\r\nstruct clk_hw *mux_hw = &genamux->mux.hw;\r\nunsigned long timeout;\r\nint ret = 0;\r\nmux_hw->clk = hw->clk;\r\nret = clk_mux_ops.set_parent(mux_hw, genamux->muxsel);\r\nif (ret)\r\nreturn ret;\r\ntimeout = jiffies + msecs_to_jiffies(10);\r\nwhile (!clkgena_divmux_is_running(genamux)) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic void clkgena_divmux_disable(struct clk_hw *hw)\r\n{\r\nstruct clkgena_divmux *genamux = to_clkgena_divmux(hw);\r\nstruct clk_hw *mux_hw = &genamux->mux.hw;\r\nmux_hw->clk = hw->clk;\r\nclk_mux_ops.set_parent(mux_hw, CKGAX_CLKOPSRC_SWITCH_OFF);\r\n}\r\nstatic int clkgena_divmux_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clkgena_divmux *genamux = to_clkgena_divmux(hw);\r\nstruct clk_hw *mux_hw = &genamux->mux.hw;\r\nmux_hw->clk = hw->clk;\r\nreturn (s8)clk_mux_ops.get_parent(mux_hw) > 0;\r\n}\r\nu8 clkgena_divmux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clkgena_divmux *genamux = to_clkgena_divmux(hw);\r\nstruct clk_hw *mux_hw = &genamux->mux.hw;\r\nmux_hw->clk = hw->clk;\r\ngenamux->muxsel = clk_mux_ops.get_parent(mux_hw);\r\nif ((s8)genamux->muxsel < 0) {\r\npr_debug("%s: %s: Invalid parent, setting to default.\n",\r\n__func__, __clk_get_name(hw->clk));\r\ngenamux->muxsel = 0;\r\n}\r\nreturn genamux->muxsel;\r\n}\r\nstatic int clkgena_divmux_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clkgena_divmux *genamux = to_clkgena_divmux(hw);\r\nif (index >= CKGAX_CLKOPSRC_SWITCH_OFF)\r\nreturn -EINVAL;\r\ngenamux->muxsel = index;\r\nif (clkgena_divmux_is_enabled(hw))\r\nclkgena_divmux_enable(hw);\r\nreturn 0;\r\n}\r\nunsigned long clkgena_divmux_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clkgena_divmux *genamux = to_clkgena_divmux(hw);\r\nstruct clk_hw *div_hw = &genamux->div[genamux->muxsel].hw;\r\ndiv_hw->clk = hw->clk;\r\nreturn clk_divider_ops.recalc_rate(div_hw, parent_rate);\r\n}\r\nstatic int clkgena_divmux_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clkgena_divmux *genamux = to_clkgena_divmux(hw);\r\nstruct clk_hw *div_hw = &genamux->div[genamux->muxsel].hw;\r\ndiv_hw->clk = hw->clk;\r\nreturn clk_divider_ops.set_rate(div_hw, rate, parent_rate);\r\n}\r\nstatic long clkgena_divmux_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clkgena_divmux *genamux = to_clkgena_divmux(hw);\r\nstruct clk_hw *div_hw = &genamux->div[genamux->muxsel].hw;\r\ndiv_hw->clk = hw->clk;\r\nreturn clk_divider_ops.round_rate(div_hw, rate, prate);\r\n}\r\nstruct clk *clk_register_genamux(const char *name,\r\nconst char **parent_names, u8 num_parents,\r\nvoid __iomem *reg,\r\nconst struct clkgena_divmux_data *muxdata,\r\nu32 idx)\r\n{\r\nconst int mux_width = 2;\r\nconst int divider_width = 5;\r\nstruct clkgena_divmux *genamux;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nint i;\r\ngenamux = kzalloc(sizeof(*genamux), GFP_KERNEL);\r\nif (!genamux)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &clkgena_divmux_ops;\r\ninit.flags = CLK_IS_BASIC;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ngenamux->mux.lock = &clkgena_divmux_lock;\r\ngenamux->mux.mask = BIT(mux_width) - 1;\r\ngenamux->mux.shift = muxdata->mux_start_bit + (idx * mux_width);\r\nif (genamux->mux.shift > 31) {\r\ngenamux->mux.reg = reg + muxdata->mux_offset2;\r\ngenamux->mux.shift -= 32;\r\n} else {\r\ngenamux->mux.reg = reg + muxdata->mux_offset;\r\n}\r\nfor (i = 0; i < NUM_INPUTS; i++) {\r\nvoid __iomem *divbase = reg + muxdata->div_offsets[i];\r\ngenamux->div[i].width = divider_width;\r\ngenamux->div[i].reg = divbase + (idx * sizeof(u32));\r\ngenamux->feedback_reg[i] = reg + muxdata->fb_offsets[i];\r\n}\r\ngenamux->feedback_bit_idx = muxdata->fb_start_bit_idx + idx;\r\ngenamux->hw.init = &init;\r\nclk = clk_register(NULL, &genamux->hw);\r\nif (IS_ERR(clk)) {\r\nkfree(genamux);\r\ngoto err;\r\n}\r\npr_debug("%s: parent %s rate %lu\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\nclk_get_rate(clk));\r\nerr:\r\nreturn clk;\r\n}\r\nstatic void __iomem * __init clkgen_get_register_base(\r\nstruct device_node *np)\r\n{\r\nstruct device_node *pnode;\r\nvoid __iomem *reg = NULL;\r\npnode = of_get_parent(np);\r\nif (!pnode)\r\nreturn NULL;\r\nreg = of_iomap(pnode, 0);\r\nof_node_put(pnode);\r\nreturn reg;\r\n}\r\nvoid __init st_of_clkgena_divmux_setup(struct device_node *np)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct clkgena_divmux_data *data;\r\nstruct clk_onecell_data *clk_data;\r\nvoid __iomem *reg;\r\nconst char **parents;\r\nint num_parents = 0, i;\r\nmatch = of_match_node(clkgena_divmux_of_match, np);\r\nif (WARN_ON(!match))\r\nreturn;\r\ndata = (struct clkgena_divmux_data *)match->data;\r\nreg = clkgen_get_register_base(np);\r\nif (!reg)\r\nreturn;\r\nparents = clkgen_mux_get_parents(np, &num_parents);\r\nif (IS_ERR(parents))\r\nreturn;\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\ngoto err;\r\nclk_data->clk_num = data->num_outputs;\r\nclk_data->clks = kzalloc(clk_data->clk_num * sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (!clk_data->clks)\r\ngoto err;\r\nfor (i = 0; i < clk_data->clk_num; i++) {\r\nstruct clk *clk;\r\nconst char *clk_name;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\ni, &clk_name))\r\nbreak;\r\nif (*clk_name == '\0')\r\ncontinue;\r\nclk = clk_register_genamux(clk_name, parents, num_parents,\r\nreg, data, i);\r\nif (IS_ERR(clk))\r\ngoto err;\r\nclk_data->clks[i] = clk;\r\n}\r\nkfree(parents);\r\nof_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\r\nreturn;\r\nerr:\r\nif (clk_data)\r\nkfree(clk_data->clks);\r\nkfree(clk_data);\r\nkfree(parents);\r\n}\r\nvoid __init st_of_clkgena_prediv_setup(struct device_node *np)\r\n{\r\nconst struct of_device_id *match;\r\nvoid __iomem *reg;\r\nconst char *parent_name, *clk_name;\r\nstruct clk *clk;\r\nstruct clkgena_prediv_data *data;\r\nmatch = of_match_node(clkgena_prediv_of_match, np);\r\nif (!match) {\r\npr_err("%s: No matching data\n", __func__);\r\nreturn;\r\n}\r\ndata = (struct clkgena_prediv_data *)match->data;\r\nreg = clkgen_get_register_base(np);\r\nif (!reg)\r\nreturn;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name)\r\nreturn;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\n0, &clk_name))\r\nreturn;\r\nclk = clk_register_divider_table(NULL, clk_name, parent_name, 0,\r\nreg + data->offset, data->shift, 1,\r\n0, data->table, NULL);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\npr_debug("%s: parent %s rate %u\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\n(unsigned int)clk_get_rate(clk));\r\nreturn;\r\n}\r\nvoid __init st_of_clkgen_mux_setup(struct device_node *np)\r\n{\r\nconst struct of_device_id *match;\r\nstruct clk *clk;\r\nvoid __iomem *reg;\r\nconst char **parents;\r\nint num_parents;\r\nstruct clkgen_mux_data *data;\r\nmatch = of_match_node(mux_of_match, np);\r\nif (!match) {\r\npr_err("%s: No matching data\n", __func__);\r\nreturn;\r\n}\r\ndata = (struct clkgen_mux_data *)match->data;\r\nreg = of_iomap(np, 0);\r\nif (!reg) {\r\npr_err("%s: Failed to get base address\n", __func__);\r\nreturn;\r\n}\r\nparents = clkgen_mux_get_parents(np, &num_parents);\r\nif (IS_ERR(parents)) {\r\npr_err("%s: Failed to get parents (%ld)\n",\r\n__func__, PTR_ERR(parents));\r\nreturn;\r\n}\r\nclk = clk_register_mux(NULL, np->name, parents, num_parents,\r\ndata->clk_flags | CLK_SET_RATE_PARENT,\r\nreg + data->offset,\r\ndata->shift, data->width, data->mux_flags,\r\ndata->lock);\r\nif (IS_ERR(clk))\r\ngoto err;\r\npr_debug("%s: parent %s rate %u\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\n(unsigned int)clk_get_rate(clk));\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nerr:\r\nkfree(parents);\r\nreturn;\r\n}\r\nvoid __init st_of_clkgen_vcc_setup(struct device_node *np)\r\n{\r\nconst struct of_device_id *match;\r\nvoid __iomem *reg;\r\nconst char **parents;\r\nint num_parents, i;\r\nstruct clk_onecell_data *clk_data;\r\nstruct clkgen_vcc_data *data;\r\nmatch = of_match_node(vcc_of_match, np);\r\nif (WARN_ON(!match))\r\nreturn;\r\ndata = (struct clkgen_vcc_data *)match->data;\r\nreg = of_iomap(np, 0);\r\nif (!reg)\r\nreturn;\r\nparents = clkgen_mux_get_parents(np, &num_parents);\r\nif (IS_ERR(parents))\r\nreturn;\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\ngoto err;\r\nclk_data->clk_num = VCC_MAX_CHANNELS;\r\nclk_data->clks = kzalloc(clk_data->clk_num * sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (!clk_data->clks)\r\ngoto err;\r\nfor (i = 0; i < clk_data->clk_num; i++) {\r\nstruct clk *clk;\r\nconst char *clk_name;\r\nstruct clk_gate *gate;\r\nstruct clk_divider *div;\r\nstruct clk_mux *mux;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\ni, &clk_name))\r\nbreak;\r\nif (*clk_name == '\0')\r\ncontinue;\r\ngate = kzalloc(sizeof(struct clk_gate), GFP_KERNEL);\r\nif (!gate)\r\nbreak;\r\ndiv = kzalloc(sizeof(struct clk_divider), GFP_KERNEL);\r\nif (!div) {\r\nkfree(gate);\r\nbreak;\r\n}\r\nmux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);\r\nif (!mux) {\r\nkfree(gate);\r\nkfree(div);\r\nbreak;\r\n}\r\ngate->reg = reg + VCC_GATE_OFFSET;\r\ngate->bit_idx = i;\r\ngate->flags = CLK_GATE_SET_TO_DISABLE;\r\ngate->lock = data->lock;\r\ndiv->reg = reg + VCC_DIV_OFFSET;\r\ndiv->shift = 2 * i;\r\ndiv->width = 2;\r\ndiv->flags = CLK_DIVIDER_POWER_OF_TWO;\r\nmux->reg = reg + VCC_MUX_OFFSET;\r\nmux->shift = 2 * i;\r\nmux->mask = 0x3;\r\nclk = clk_register_composite(NULL, clk_name, parents,\r\nnum_parents,\r\n&mux->hw, &clk_mux_ops,\r\n&div->hw, &clk_divider_ops,\r\n&gate->hw, &clk_gate_ops,\r\ndata->clk_flags);\r\nif (IS_ERR(clk)) {\r\nkfree(gate);\r\nkfree(div);\r\nkfree(mux);\r\ngoto err;\r\n}\r\npr_debug("%s: parent %s rate %u\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\n(unsigned int)clk_get_rate(clk));\r\nclk_data->clks[i] = clk;\r\n}\r\nkfree(parents);\r\nof_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\r\nreturn;\r\nerr:\r\nfor (i = 0; i < clk_data->clk_num; i++) {\r\nstruct clk_composite *composite;\r\nif (!clk_data->clks[i])\r\ncontinue;\r\ncomposite = container_of(__clk_get_hw(clk_data->clks[i]),\r\nstruct clk_composite, hw);\r\nkfree(container_of(composite->gate_hw, struct clk_gate, hw));\r\nkfree(container_of(composite->rate_hw, struct clk_divider, hw));\r\nkfree(container_of(composite->mux_hw, struct clk_mux, hw));\r\n}\r\nif (clk_data)\r\nkfree(clk_data->clks);\r\nkfree(clk_data);\r\nkfree(parents);\r\n}
