static void btrfs_uuid_to_key(u8 *uuid, u8 type, struct btrfs_key *key)\r\n{\r\nkey->type = type;\r\nkey->objectid = get_unaligned_le64(uuid);\r\nkey->offset = get_unaligned_le64(uuid + sizeof(u64));\r\n}\r\nstatic int btrfs_uuid_tree_lookup(struct btrfs_root *uuid_root, u8 *uuid,\r\nu8 type, u64 subid)\r\n{\r\nint ret;\r\nstruct btrfs_path *path = NULL;\r\nstruct extent_buffer *eb;\r\nint slot;\r\nu32 item_size;\r\nunsigned long offset;\r\nstruct btrfs_key key;\r\nif (WARN_ON_ONCE(!uuid_root)) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nbtrfs_uuid_to_key(uuid, type, &key);\r\nret = btrfs_search_slot(NULL, uuid_root, &key, path, 0, 0);\r\nif (ret < 0) {\r\ngoto out;\r\n} else if (ret > 0) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\neb = path->nodes[0];\r\nslot = path->slots[0];\r\nitem_size = btrfs_item_size_nr(eb, slot);\r\noffset = btrfs_item_ptr_offset(eb, slot);\r\nret = -ENOENT;\r\nif (!IS_ALIGNED(item_size, sizeof(u64))) {\r\nbtrfs_warn(uuid_root->fs_info, "uuid item with illegal size %lu!",\r\n(unsigned long)item_size);\r\ngoto out;\r\n}\r\nwhile (item_size) {\r\n__le64 data;\r\nread_extent_buffer(eb, &data, offset, sizeof(data));\r\nif (le64_to_cpu(data) == subid) {\r\nret = 0;\r\nbreak;\r\n}\r\noffset += sizeof(data);\r\nitem_size -= sizeof(data);\r\n}\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\r\nu64 subid_cpu)\r\n{\r\nint ret;\r\nstruct btrfs_path *path = NULL;\r\nstruct btrfs_key key;\r\nstruct extent_buffer *eb;\r\nint slot;\r\nunsigned long offset;\r\n__le64 subid_le;\r\nret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\r\nif (ret != -ENOENT)\r\nreturn ret;\r\nif (WARN_ON_ONCE(!uuid_root)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbtrfs_uuid_to_key(uuid, type, &key);\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\r\nsizeof(subid_le));\r\nif (ret >= 0) {\r\neb = path->nodes[0];\r\nslot = path->slots[0];\r\noffset = btrfs_item_ptr_offset(eb, slot);\r\n} else if (ret == -EEXIST) {\r\nbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\r\neb = path->nodes[0];\r\nslot = path->slots[0];\r\noffset = btrfs_item_ptr_offset(eb, slot);\r\noffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\r\n} else if (ret < 0) {\r\nbtrfs_warn(uuid_root->fs_info, "insert uuid item failed %d "\r\n"(0x%016llx, 0x%016llx) type %u!",\r\nret, (unsigned long long)key.objectid,\r\n(unsigned long long)key.offset, type);\r\ngoto out;\r\n}\r\nret = 0;\r\nsubid_le = cpu_to_le64(subid_cpu);\r\nwrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\r\nbtrfs_mark_buffer_dirty(eb);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_uuid_tree_rem(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\r\nu64 subid)\r\n{\r\nint ret;\r\nstruct btrfs_path *path = NULL;\r\nstruct btrfs_key key;\r\nstruct extent_buffer *eb;\r\nint slot;\r\nunsigned long offset;\r\nu32 item_size;\r\nunsigned long move_dst;\r\nunsigned long move_src;\r\nunsigned long move_len;\r\nif (WARN_ON_ONCE(!uuid_root)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbtrfs_uuid_to_key(uuid, type, &key);\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = btrfs_search_slot(trans, uuid_root, &key, path, -1, 1);\r\nif (ret < 0) {\r\nbtrfs_warn(uuid_root->fs_info, "error %d while searching for uuid item!",\r\nret);\r\ngoto out;\r\n}\r\nif (ret > 0) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\neb = path->nodes[0];\r\nslot = path->slots[0];\r\noffset = btrfs_item_ptr_offset(eb, slot);\r\nitem_size = btrfs_item_size_nr(eb, slot);\r\nif (!IS_ALIGNED(item_size, sizeof(u64))) {\r\nbtrfs_warn(uuid_root->fs_info, "uuid item with illegal size %lu!",\r\n(unsigned long)item_size);\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nwhile (item_size) {\r\n__le64 read_subid;\r\nread_extent_buffer(eb, &read_subid, offset, sizeof(read_subid));\r\nif (le64_to_cpu(read_subid) == subid)\r\nbreak;\r\noffset += sizeof(read_subid);\r\nitem_size -= sizeof(read_subid);\r\n}\r\nif (!item_size) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nitem_size = btrfs_item_size_nr(eb, slot);\r\nif (item_size == sizeof(subid)) {\r\nret = btrfs_del_item(trans, uuid_root, path);\r\ngoto out;\r\n}\r\nmove_dst = offset;\r\nmove_src = offset + sizeof(subid);\r\nmove_len = item_size - (move_src - btrfs_item_ptr_offset(eb, slot));\r\nmemmove_extent_buffer(eb, move_dst, move_src, move_len);\r\nbtrfs_truncate_item(uuid_root, path, item_size - sizeof(subid), 1);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int btrfs_uuid_iter_rem(struct btrfs_root *uuid_root, u8 *uuid, u8 type,\r\nu64 subid)\r\n{\r\nstruct btrfs_trans_handle *trans;\r\nint ret;\r\ntrans = btrfs_start_transaction(uuid_root, 1);\r\nif (IS_ERR(trans)) {\r\nret = PTR_ERR(trans);\r\ngoto out;\r\n}\r\nret = btrfs_uuid_tree_rem(trans, uuid_root, uuid, type, subid);\r\nbtrfs_end_transaction(trans, uuid_root);\r\nout:\r\nreturn ret;\r\n}\r\nint btrfs_uuid_tree_iterate(struct btrfs_fs_info *fs_info,\r\nint (*check_func)(struct btrfs_fs_info *, u8 *, u8,\r\nu64))\r\n{\r\nstruct btrfs_root *root = fs_info->uuid_root;\r\nstruct btrfs_key key;\r\nstruct btrfs_path *path;\r\nint ret = 0;\r\nstruct extent_buffer *leaf;\r\nint slot;\r\nu32 item_size;\r\nunsigned long offset;\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nkey.objectid = 0;\r\nkey.type = 0;\r\nkey.offset = 0;\r\nagain_search_slot:\r\npath->keep_locks = 1;\r\nret = btrfs_search_forward(root, &key, path, 0);\r\nif (ret) {\r\nif (ret > 0)\r\nret = 0;\r\ngoto out;\r\n}\r\nwhile (1) {\r\ncond_resched();\r\nleaf = path->nodes[0];\r\nslot = path->slots[0];\r\nbtrfs_item_key_to_cpu(leaf, &key, slot);\r\nif (key.type != BTRFS_UUID_KEY_SUBVOL &&\r\nkey.type != BTRFS_UUID_KEY_RECEIVED_SUBVOL)\r\ngoto skip;\r\noffset = btrfs_item_ptr_offset(leaf, slot);\r\nitem_size = btrfs_item_size_nr(leaf, slot);\r\nif (!IS_ALIGNED(item_size, sizeof(u64))) {\r\nbtrfs_warn(fs_info, "uuid item with illegal size %lu!",\r\n(unsigned long)item_size);\r\ngoto skip;\r\n}\r\nwhile (item_size) {\r\nu8 uuid[BTRFS_UUID_SIZE];\r\n__le64 subid_le;\r\nu64 subid_cpu;\r\nput_unaligned_le64(key.objectid, uuid);\r\nput_unaligned_le64(key.offset, uuid + sizeof(u64));\r\nread_extent_buffer(leaf, &subid_le, offset,\r\nsizeof(subid_le));\r\nsubid_cpu = le64_to_cpu(subid_le);\r\nret = check_func(fs_info, uuid, key.type, subid_cpu);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret > 0) {\r\nbtrfs_release_path(path);\r\nret = btrfs_uuid_iter_rem(root, uuid, key.type,\r\nsubid_cpu);\r\nif (ret == 0) {\r\ngoto again_search_slot;\r\n}\r\nif (ret < 0 && ret != -ENOENT)\r\ngoto out;\r\n}\r\nitem_size -= sizeof(subid_le);\r\noffset += sizeof(subid_le);\r\n}\r\nskip:\r\nret = btrfs_next_item(root, path);\r\nif (ret == 0)\r\ncontinue;\r\nelse if (ret > 0)\r\nret = 0;\r\nbreak;\r\n}\r\nout:\r\nbtrfs_free_path(path);\r\nif (ret)\r\nbtrfs_warn(fs_info, "btrfs_uuid_tree_iterate failed %d", ret);\r\nreturn 0;\r\n}
