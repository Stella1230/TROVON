static void atmel_pcm_dma_irq(u32 ssc_sr,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_pcm_dma_params *prtd;\r\nprtd = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (ssc_sr & prtd->mask->ssc_error) {\r\nif (snd_pcm_running(substream))\r\npr_warn("atmel-pcm: buffer %s on %s (SSC_SR=%#x)\n",\r\nsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK\r\n? "underrun" : "overrun", prtd->name,\r\nssc_sr);\r\nssc_writex(prtd->ssc->regs, SSC_CR, prtd->mask->ssc_disable);\r\nsnd_pcm_stream_lock(substream);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock(substream);\r\nssc_readx(prtd->ssc->regs, SSC_RHR);\r\nssc_readx(prtd->ssc->regs, SSC_SR);\r\n}\r\n}\r\nstatic int atmel_pcm_configure_dma(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct dma_slave_config *slave_config)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_pcm_dma_params *prtd;\r\nstruct ssc_device *ssc;\r\nint ret;\r\nprtd = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nssc = prtd->ssc;\r\nret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);\r\nif (ret) {\r\npr_err("atmel-pcm: hwparams to dma slave configure failed\n");\r\nreturn ret;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nslave_config->dst_addr = ssc->phybase + SSC_THR;\r\nslave_config->dst_maxburst = 1;\r\n} else {\r\nslave_config->src_addr = ssc->phybase + SSC_RHR;\r\nslave_config->src_maxburst = 1;\r\n}\r\nprtd->dma_intr_handler = atmel_pcm_dma_irq;\r\nreturn 0;\r\n}\r\nint atmel_pcm_dma_platform_register(struct device *dev)\r\n{\r\nreturn snd_dmaengine_pcm_register(dev, &atmel_dmaengine_pcm_config,\r\nSND_DMAENGINE_PCM_FLAG_NO_RESIDUE);\r\n}\r\nvoid atmel_pcm_dma_platform_unregister(struct device *dev)\r\n{\r\nsnd_dmaengine_pcm_unregister(dev);\r\n}
