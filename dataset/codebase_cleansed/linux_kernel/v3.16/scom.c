struct device_node *scom_find_parent(struct device_node *node)\r\n{\r\nstruct device_node *par, *tmp;\r\nconst u32 *p;\r\nfor (par = of_node_get(node); par;) {\r\nif (of_get_property(par, "scom-controller", NULL))\r\nbreak;\r\np = of_get_property(par, "scom-parent", NULL);\r\ntmp = par;\r\nif (p == NULL)\r\npar = of_get_parent(par);\r\nelse\r\npar = of_find_node_by_phandle(*p);\r\nof_node_put(tmp);\r\n}\r\nreturn par;\r\n}\r\nscom_map_t scom_map_device(struct device_node *dev, int index)\r\n{\r\nstruct device_node *parent;\r\nunsigned int cells, size;\r\nconst __be32 *prop, *sprop;\r\nu64 reg, cnt;\r\nscom_map_t ret;\r\nparent = scom_find_parent(dev);\r\nif (parent == NULL)\r\nreturn 0;\r\nprop = of_get_property(dev, "scom-reg", &size);\r\nsprop = of_get_property(parent, "#scom-cells", NULL);\r\nif (!prop && parent == dev->parent) {\r\nprop = of_get_property(dev, "reg", &size);\r\nsprop = of_get_property(parent, "#address-cells", NULL);\r\n}\r\nif (!prop)\r\nreturn NULL;\r\ncells = sprop ? be32_to_cpup(sprop) : 1;\r\nsize >>= 2;\r\nif (index >= (size / (2*cells)))\r\nreturn 0;\r\nreg = of_read_number(&prop[index * cells * 2], cells);\r\ncnt = of_read_number(&prop[index * cells * 2 + cells], cells);\r\nret = scom_map(parent, reg, cnt);\r\nof_node_put(parent);\r\nreturn ret;\r\n}\r\nstatic ssize_t scom_debug_read(struct file *filp, char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct scom_debug_entry *ent = filp->private_data;\r\nu64 __user *ubuf64 = (u64 __user *)ubuf;\r\nloff_t off = *ppos;\r\nssize_t done = 0;\r\nu64 reg, reg_cnt, val;\r\nscom_map_t map;\r\nint rc;\r\nif (off < 0 || (off & 7) || (count & 7))\r\nreturn -EINVAL;\r\nreg = off >> 3;\r\nreg_cnt = count >> 3;\r\nmap = scom_map(ent->dn, reg, reg_cnt);\r\nif (!scom_map_ok(map))\r\nreturn -ENXIO;\r\nfor (reg = 0; reg < reg_cnt; reg++) {\r\nrc = scom_read(map, reg, &val);\r\nif (!rc)\r\nrc = put_user(val, ubuf64);\r\nif (rc) {\r\nif (!done)\r\ndone = rc;\r\nbreak;\r\n}\r\nubuf64++;\r\n*ppos += 8;\r\ndone += 8;\r\n}\r\nscom_unmap(map);\r\nreturn done;\r\n}\r\nstatic ssize_t scom_debug_write(struct file* filp, const char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct scom_debug_entry *ent = filp->private_data;\r\nu64 __user *ubuf64 = (u64 __user *)ubuf;\r\nloff_t off = *ppos;\r\nssize_t done = 0;\r\nu64 reg, reg_cnt, val;\r\nscom_map_t map;\r\nint rc;\r\nif (off < 0 || (off & 7) || (count & 7))\r\nreturn -EINVAL;\r\nreg = off >> 3;\r\nreg_cnt = count >> 3;\r\nmap = scom_map(ent->dn, reg, reg_cnt);\r\nif (!scom_map_ok(map))\r\nreturn -ENXIO;\r\nfor (reg = 0; reg < reg_cnt; reg++) {\r\nrc = get_user(val, ubuf64);\r\nif (!rc)\r\nrc = scom_write(map, reg, val);\r\nif (rc) {\r\nif (!done)\r\ndone = rc;\r\nbreak;\r\n}\r\nubuf64++;\r\ndone += 8;\r\n}\r\nscom_unmap(map);\r\nreturn done;\r\n}\r\nstatic int scom_debug_init_one(struct dentry *root, struct device_node *dn,\r\nint i)\r\n{\r\nstruct scom_debug_entry *ent;\r\nstruct dentry *dir;\r\nent = kzalloc(sizeof(*ent), GFP_KERNEL);\r\nif (!ent)\r\nreturn -ENOMEM;\r\nent->dn = of_node_get(dn);\r\nsnprintf(ent->name, 16, "%08x", i);\r\nent->path.data = (void*) dn->full_name;\r\nent->path.size = strlen(dn->full_name);\r\ndir = debugfs_create_dir(ent->name, root);\r\nif (!dir) {\r\nof_node_put(dn);\r\nkfree(ent);\r\nreturn -1;\r\n}\r\ndebugfs_create_blob("devspec", 0400, dir, &ent->path);\r\ndebugfs_create_file("access", 0600, dir, ent, &scom_debug_fops);\r\nreturn 0;\r\n}\r\nstatic int scom_debug_init(void)\r\n{\r\nstruct device_node *dn;\r\nstruct dentry *root;\r\nint i, rc;\r\nroot = debugfs_create_dir("scom", powerpc_debugfs_root);\r\nif (!root)\r\nreturn -1;\r\ni = rc = 0;\r\nfor_each_node_with_property(dn, "scom-controller") {\r\nint id = of_get_ibm_chip_id(dn);\r\nif (id == -1)\r\nid = i;\r\nrc |= scom_debug_init_one(root, dn, id);\r\ni++;\r\n}\r\nreturn rc;\r\n}
