static enum hrtimer_restart snd_hrtimer_callback(struct hrtimer *hrt)\r\n{\r\nstruct imx_pcm_runtime_data *iprtd =\r\ncontainer_of(hrt, struct imx_pcm_runtime_data, hrt);\r\nstruct snd_pcm_substream *substream = iprtd->substream;\r\nstruct pt_regs regs;\r\nif (!atomic_read(&iprtd->playing) && !atomic_read(&iprtd->capturing))\r\nreturn HRTIMER_NORESTART;\r\nget_fiq_regs(&regs);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\niprtd->offset = regs.ARM_r8 & 0xffff;\r\nelse\r\niprtd->offset = regs.ARM_r9 & 0xffff;\r\nsnd_pcm_period_elapsed(substream);\r\nhrtimer_forward_now(hrt, ns_to_ktime(iprtd->poll_time_ns));\r\nreturn HRTIMER_RESTART;\r\n}\r\nstatic int snd_imx_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\niprtd->periods = params_periods(params);\r\niprtd->period = params_period_bytes(params);\r\niprtd->offset = 0;\r\niprtd->poll_time_ns = 1000000000 / params_rate(params) *\r\nparams_period_size(params);\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nreturn 0;\r\n}\r\nstatic int snd_imx_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\nstruct pt_regs regs;\r\nget_fiq_regs(&regs);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nregs.ARM_r8 = (iprtd->period * iprtd->periods - 1) << 16;\r\nelse\r\nregs.ARM_r9 = (iprtd->period * iprtd->periods - 1) << 16;\r\nset_fiq_regs(&regs);\r\nreturn 0;\r\n}\r\nstatic int snd_imx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\natomic_set(&iprtd->playing, 1);\r\nelse\r\natomic_set(&iprtd->capturing, 1);\r\nhrtimer_start(&iprtd->hrt, ns_to_ktime(iprtd->poll_time_ns),\r\nHRTIMER_MODE_REL);\r\nenable_fiq(imx_pcm_fiq);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\natomic_set(&iprtd->playing, 0);\r\nelse\r\natomic_set(&iprtd->capturing, 0);\r\nif (!atomic_read(&iprtd->playing) &&\r\n!atomic_read(&iprtd->capturing))\r\ndisable_fiq(imx_pcm_fiq);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_imx_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\nreturn bytes_to_frames(substream->runtime, iprtd->offset);\r\n}\r\nstatic int snd_imx_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd;\r\nint ret;\r\niprtd = kzalloc(sizeof(*iprtd), GFP_KERNEL);\r\nif (iprtd == NULL)\r\nreturn -ENOMEM;\r\nruntime->private_data = iprtd;\r\niprtd->substream = substream;\r\natomic_set(&iprtd->playing, 0);\r\natomic_set(&iprtd->capturing, 0);\r\nhrtimer_init(&iprtd->hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\niprtd->hrt.function = snd_hrtimer_callback;\r\nret = snd_pcm_hw_constraint_integer(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0) {\r\nkfree(iprtd);\r\nreturn ret;\r\n}\r\nsnd_soc_set_runtime_hwparams(substream, &snd_imx_hardware);\r\nreturn 0;\r\n}\r\nstatic int snd_imx_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\nhrtimer_cancel(&iprtd->hrt);\r\nkfree(iprtd);\r\nreturn 0;\r\n}\r\nstatic int snd_imx_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint ret;\r\nret = dma_mmap_writecombine(substream->pcm->card->dev, vma,\r\nruntime->dma_area, runtime->dma_addr, runtime->dma_bytes);\r\npr_debug("%s: ret: %d %p 0x%08x 0x%08x\n", __func__, ret,\r\nruntime->dma_area,\r\nruntime->dma_addr,\r\nruntime->dma_bytes);\r\nreturn ret;\r\n}\r\nstatic int imx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)\r\n{\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nsize_t size = IMX_SSI_DMABUF_SIZE;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->private_data = NULL;\r\nbuf->area = dma_alloc_writecombine(pcm->card->dev, size,\r\n&buf->addr, GFP_KERNEL);\r\nif (!buf->area)\r\nreturn -ENOMEM;\r\nbuf->bytes = size;\r\nreturn 0;\r\n}\r\nstatic int imx_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret;\r\nret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nret = imx_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nret = imx_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_CAPTURE);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_pcm_fiq_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nstruct snd_pcm_substream *substream;\r\nint ret;\r\nret = imx_pcm_new(rtd);\r\nif (ret)\r\nreturn ret;\r\nsubstream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\r\nif (substream) {\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nimx_ssi_fiq_tx_buffer = (unsigned long)buf->area;\r\n}\r\nsubstream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\r\nif (substream) {\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nimx_ssi_fiq_rx_buffer = (unsigned long)buf->area;\r\n}\r\nset_fiq_handler(&imx_ssi_fiq_start,\r\n&imx_ssi_fiq_end - &imx_ssi_fiq_start);\r\nreturn 0;\r\n}\r\nstatic void imx_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nint stream;\r\nfor (stream = 0; stream < 2; stream++) {\r\nsubstream = pcm->streams[stream].substream;\r\nif (!substream)\r\ncontinue;\r\nbuf = &substream->dma_buffer;\r\nif (!buf->area)\r\ncontinue;\r\ndma_free_writecombine(pcm->card->dev, buf->bytes,\r\nbuf->area, buf->addr);\r\nbuf->area = NULL;\r\n}\r\n}\r\nstatic void imx_pcm_fiq_free(struct snd_pcm *pcm)\r\n{\r\nmxc_set_irq_fiq(ssi_irq, 0);\r\nrelease_fiq(&fh);\r\nimx_pcm_free(pcm);\r\n}\r\nint imx_pcm_fiq_init(struct platform_device *pdev,\r\nstruct imx_pcm_fiq_params *params)\r\n{\r\nint ret;\r\nret = claim_fiq(&fh);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to claim fiq: %d", ret);\r\nreturn ret;\r\n}\r\nmxc_set_irq_fiq(params->irq, 1);\r\nssi_irq = params->irq;\r\nimx_pcm_fiq = params->irq;\r\nimx_ssi_fiq_base = (unsigned long)params->base;\r\nparams->dma_params_tx->maxburst = 4;\r\nparams->dma_params_rx->maxburst = 6;\r\nret = snd_soc_register_platform(&pdev->dev, &imx_soc_platform_fiq);\r\nif (ret)\r\ngoto failed_register;\r\nreturn 0;\r\nfailed_register:\r\nmxc_set_irq_fiq(ssi_irq, 0);\r\nrelease_fiq(&fh);\r\nreturn ret;\r\n}\r\nvoid imx_pcm_fiq_exit(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_platform(&pdev->dev);\r\n}
