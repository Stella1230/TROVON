static inline struct xfrm4_protocol __rcu **proto_handlers(u8 protocol)\r\n{\r\nswitch (protocol) {\r\ncase IPPROTO_ESP:\r\nreturn &esp4_handlers;\r\ncase IPPROTO_AH:\r\nreturn &ah4_handlers;\r\ncase IPPROTO_COMP:\r\nreturn &ipcomp4_handlers;\r\n}\r\nreturn NULL;\r\n}\r\nint xfrm4_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,\r\nint encap_type)\r\n{\r\nint ret;\r\nstruct xfrm4_protocol *handler;\r\nstruct xfrm4_protocol __rcu **head = proto_handlers(nexthdr);\r\nXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;\r\nXFRM_SPI_SKB_CB(skb)->family = AF_INET;\r\nXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);\r\nif (!head)\r\ngoto out;\r\nfor_each_protocol_rcu(*head, handler)\r\nif ((ret = handler->input_handler(skb, nexthdr, spi, encap_type)) != -EINVAL)\r\nreturn ret;\r\nout:\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int xfrm4_esp_rcv(struct sk_buff *skb)\r\n{\r\nint ret;\r\nstruct xfrm4_protocol *handler;\r\nXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;\r\nfor_each_protocol_rcu(esp4_handlers, handler)\r\nif ((ret = handler->handler(skb)) != -EINVAL)\r\nreturn ret;\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void xfrm4_esp_err(struct sk_buff *skb, u32 info)\r\n{\r\nstruct xfrm4_protocol *handler;\r\nfor_each_protocol_rcu(esp4_handlers, handler)\r\nif (!handler->err_handler(skb, info))\r\nbreak;\r\n}\r\nstatic int xfrm4_ah_rcv(struct sk_buff *skb)\r\n{\r\nint ret;\r\nstruct xfrm4_protocol *handler;\r\nXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;\r\nfor_each_protocol_rcu(ah4_handlers, handler)\r\nif ((ret = handler->handler(skb)) != -EINVAL)\r\nreturn ret;;\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void xfrm4_ah_err(struct sk_buff *skb, u32 info)\r\n{\r\nstruct xfrm4_protocol *handler;\r\nfor_each_protocol_rcu(ah4_handlers, handler)\r\nif (!handler->err_handler(skb, info))\r\nbreak;\r\n}\r\nstatic int xfrm4_ipcomp_rcv(struct sk_buff *skb)\r\n{\r\nint ret;\r\nstruct xfrm4_protocol *handler;\r\nXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;\r\nfor_each_protocol_rcu(ipcomp4_handlers, handler)\r\nif ((ret = handler->handler(skb)) != -EINVAL)\r\nreturn ret;\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void xfrm4_ipcomp_err(struct sk_buff *skb, u32 info)\r\n{\r\nstruct xfrm4_protocol *handler;\r\nfor_each_protocol_rcu(ipcomp4_handlers, handler)\r\nif (!handler->err_handler(skb, info))\r\nbreak;\r\n}\r\nstatic inline const struct net_protocol *netproto(unsigned char protocol)\r\n{\r\nswitch (protocol) {\r\ncase IPPROTO_ESP:\r\nreturn &esp4_protocol;\r\ncase IPPROTO_AH:\r\nreturn &ah4_protocol;\r\ncase IPPROTO_COMP:\r\nreturn &ipcomp4_protocol;\r\n}\r\nreturn NULL;\r\n}\r\nint xfrm4_protocol_register(struct xfrm4_protocol *handler,\r\nunsigned char protocol)\r\n{\r\nstruct xfrm4_protocol __rcu **pprev;\r\nstruct xfrm4_protocol *t;\r\nbool add_netproto = false;\r\nint ret = -EEXIST;\r\nint priority = handler->priority;\r\nif (!proto_handlers(protocol) || !netproto(protocol))\r\nreturn -EINVAL;\r\nmutex_lock(&xfrm4_protocol_mutex);\r\nif (!rcu_dereference_protected(*proto_handlers(protocol),\r\nlockdep_is_held(&xfrm4_protocol_mutex)))\r\nadd_netproto = true;\r\nfor (pprev = proto_handlers(protocol);\r\n(t = rcu_dereference_protected(*pprev,\r\nlockdep_is_held(&xfrm4_protocol_mutex))) != NULL;\r\npprev = &t->next) {\r\nif (t->priority < priority)\r\nbreak;\r\nif (t->priority == priority)\r\ngoto err;\r\n}\r\nhandler->next = *pprev;\r\nrcu_assign_pointer(*pprev, handler);\r\nret = 0;\r\nerr:\r\nmutex_unlock(&xfrm4_protocol_mutex);\r\nif (add_netproto) {\r\nif (inet_add_protocol(netproto(protocol), protocol)) {\r\npr_err("%s: can't add protocol\n", __func__);\r\nret = -EAGAIN;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint xfrm4_protocol_deregister(struct xfrm4_protocol *handler,\r\nunsigned char protocol)\r\n{\r\nstruct xfrm4_protocol __rcu **pprev;\r\nstruct xfrm4_protocol *t;\r\nint ret = -ENOENT;\r\nif (!proto_handlers(protocol) || !netproto(protocol))\r\nreturn -EINVAL;\r\nmutex_lock(&xfrm4_protocol_mutex);\r\nfor (pprev = proto_handlers(protocol);\r\n(t = rcu_dereference_protected(*pprev,\r\nlockdep_is_held(&xfrm4_protocol_mutex))) != NULL;\r\npprev = &t->next) {\r\nif (t == handler) {\r\n*pprev = handler->next;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif (!rcu_dereference_protected(*proto_handlers(protocol),\r\nlockdep_is_held(&xfrm4_protocol_mutex))) {\r\nif (inet_del_protocol(netproto(protocol), protocol) < 0) {\r\npr_err("%s: can't remove protocol\n", __func__);\r\nret = -EAGAIN;\r\n}\r\n}\r\nmutex_unlock(&xfrm4_protocol_mutex);\r\nsynchronize_net();\r\nreturn ret;\r\n}\r\nvoid __init xfrm4_protocol_init(void)\r\n{\r\nxfrm_input_register_afinfo(&xfrm4_input_afinfo);\r\n}
