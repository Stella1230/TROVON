static void cirrus_dirty_update(struct cirrus_fbdev *afbdev,\r\nint x, int y, int width, int height)\r\n{\r\nint i;\r\nstruct drm_gem_object *obj;\r\nstruct cirrus_bo *bo;\r\nint src_offset, dst_offset;\r\nint bpp = (afbdev->gfb.base.bits_per_pixel + 7)/8;\r\nint ret = -EBUSY;\r\nbool unmap = false;\r\nbool store_for_later = false;\r\nint x2, y2;\r\nunsigned long flags;\r\nobj = afbdev->gfb.obj;\r\nbo = gem_to_cirrus_bo(obj);\r\nif (drm_can_sleep())\r\nret = cirrus_bo_reserve(bo, true);\r\nif (ret) {\r\nif (ret != -EBUSY)\r\nreturn;\r\nstore_for_later = true;\r\n}\r\nx2 = x + width - 1;\r\ny2 = y + height - 1;\r\nspin_lock_irqsave(&afbdev->dirty_lock, flags);\r\nif (afbdev->y1 < y)\r\ny = afbdev->y1;\r\nif (afbdev->y2 > y2)\r\ny2 = afbdev->y2;\r\nif (afbdev->x1 < x)\r\nx = afbdev->x1;\r\nif (afbdev->x2 > x2)\r\nx2 = afbdev->x2;\r\nif (store_for_later) {\r\nafbdev->x1 = x;\r\nafbdev->x2 = x2;\r\nafbdev->y1 = y;\r\nafbdev->y2 = y2;\r\nspin_unlock_irqrestore(&afbdev->dirty_lock, flags);\r\nreturn;\r\n}\r\nafbdev->x1 = afbdev->y1 = INT_MAX;\r\nafbdev->x2 = afbdev->y2 = 0;\r\nspin_unlock_irqrestore(&afbdev->dirty_lock, flags);\r\nif (!bo->kmap.virtual) {\r\nret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &bo->kmap);\r\nif (ret) {\r\nDRM_ERROR("failed to kmap fb updates\n");\r\ncirrus_bo_unreserve(bo);\r\nreturn;\r\n}\r\nunmap = true;\r\n}\r\nfor (i = y; i < y + height; i++) {\r\nsrc_offset = dst_offset = i * afbdev->gfb.base.pitches[0] + (x * bpp);\r\nmemcpy_toio(bo->kmap.virtual + src_offset, afbdev->sysram + src_offset, width * bpp);\r\n}\r\nif (unmap)\r\nttm_bo_kunmap(&bo->kmap);\r\ncirrus_bo_unreserve(bo);\r\n}\r\nstatic void cirrus_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct cirrus_fbdev *afbdev = info->par;\r\nsys_fillrect(info, rect);\r\ncirrus_dirty_update(afbdev, rect->dx, rect->dy, rect->width,\r\nrect->height);\r\n}\r\nstatic void cirrus_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct cirrus_fbdev *afbdev = info->par;\r\nsys_copyarea(info, area);\r\ncirrus_dirty_update(afbdev, area->dx, area->dy, area->width,\r\narea->height);\r\n}\r\nstatic void cirrus_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct cirrus_fbdev *afbdev = info->par;\r\nsys_imageblit(info, image);\r\ncirrus_dirty_update(afbdev, image->dx, image->dy, image->width,\r\nimage->height);\r\n}\r\nstatic int cirrusfb_create_object(struct cirrus_fbdev *afbdev,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object **gobj_p)\r\n{\r\nstruct drm_device *dev = afbdev->helper.dev;\r\nu32 bpp, depth;\r\nu32 size;\r\nstruct drm_gem_object *gobj;\r\nint ret = 0;\r\ndrm_fb_get_bpp_depth(mode_cmd->pixel_format, &depth, &bpp);\r\nif (bpp > 24)\r\nreturn -EINVAL;\r\nsize = mode_cmd->pitches[0] * mode_cmd->height;\r\nret = cirrus_gem_create(dev, size, true, &gobj);\r\nif (ret)\r\nreturn ret;\r\n*gobj_p = gobj;\r\nreturn ret;\r\n}\r\nstatic int cirrusfb_create(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct cirrus_fbdev *gfbdev = (struct cirrus_fbdev *)helper;\r\nstruct drm_device *dev = gfbdev->helper.dev;\r\nstruct cirrus_device *cdev = gfbdev->helper.dev->dev_private;\r\nstruct fb_info *info;\r\nstruct drm_framebuffer *fb;\r\nstruct drm_mode_fb_cmd2 mode_cmd;\r\nstruct device *device = &dev->pdev->dev;\r\nvoid *sysram;\r\nstruct drm_gem_object *gobj = NULL;\r\nstruct cirrus_bo *bo = NULL;\r\nint size, ret;\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] = mode_cmd.width * ((sizes->surface_bpp + 7) / 8);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\nret = cirrusfb_create_object(gfbdev, &mode_cmd, &gobj);\r\nif (ret) {\r\nDRM_ERROR("failed to create fbcon backing object %d\n", ret);\r\nreturn ret;\r\n}\r\nbo = gem_to_cirrus_bo(gobj);\r\nsysram = vmalloc(size);\r\nif (!sysram)\r\nreturn -ENOMEM;\r\ninfo = framebuffer_alloc(0, device);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\ninfo->par = gfbdev;\r\nret = cirrus_framebuffer_init(cdev->dev, &gfbdev->gfb, &mode_cmd, gobj);\r\nif (ret)\r\nreturn ret;\r\ngfbdev->sysram = sysram;\r\ngfbdev->size = size;\r\nfb = &gfbdev->gfb.base;\r\nif (!fb) {\r\nDRM_INFO("fb is NULL\n");\r\nreturn -EINVAL;\r\n}\r\ngfbdev->helper.fb = fb;\r\ngfbdev->helper.fbdev = info;\r\nstrcpy(info->fix.id, "cirrusdrmfb");\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->fbops = &cirrusfb_ops;\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(info, &gfbdev->helper, sizes->fb_width,\r\nsizes->fb_height);\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nret = -ENOMEM;\r\ngoto out_iounmap;\r\n}\r\ninfo->apertures->ranges[0].base = cdev->dev->mode_config.fb_base;\r\ninfo->apertures->ranges[0].size = cdev->mc.vram_size;\r\ninfo->fix.smem_start = cdev->dev->mode_config.fb_base;\r\ninfo->fix.smem_len = cdev->mc.vram_size;\r\ninfo->screen_base = sysram;\r\ninfo->screen_size = size;\r\ninfo->fix.mmio_start = 0;\r\ninfo->fix.mmio_len = 0;\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret) {\r\nDRM_ERROR("%s: can't allocate color map\n", info->fix.id);\r\nret = -ENOMEM;\r\ngoto out_iounmap;\r\n}\r\nDRM_INFO("fb mappable at 0x%lX\n", info->fix.smem_start);\r\nDRM_INFO("vram aper at 0x%lX\n", (unsigned long)info->fix.smem_start);\r\nDRM_INFO("size %lu\n", (unsigned long)info->fix.smem_len);\r\nDRM_INFO("fb depth is %d\n", fb->depth);\r\nDRM_INFO(" pitch is %d\n", fb->pitches[0]);\r\nreturn 0;\r\nout_iounmap:\r\nreturn ret;\r\n}\r\nstatic int cirrus_fbdev_destroy(struct drm_device *dev,\r\nstruct cirrus_fbdev *gfbdev)\r\n{\r\nstruct fb_info *info;\r\nstruct cirrus_framebuffer *gfb = &gfbdev->gfb;\r\nif (gfbdev->helper.fbdev) {\r\ninfo = gfbdev->helper.fbdev;\r\nunregister_framebuffer(info);\r\nif (info->cmap.len)\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nif (gfb->obj) {\r\ndrm_gem_object_unreference_unlocked(gfb->obj);\r\ngfb->obj = NULL;\r\n}\r\nvfree(gfbdev->sysram);\r\ndrm_fb_helper_fini(&gfbdev->helper);\r\ndrm_framebuffer_unregister_private(&gfb->base);\r\ndrm_framebuffer_cleanup(&gfb->base);\r\nreturn 0;\r\n}\r\nint cirrus_fbdev_init(struct cirrus_device *cdev)\r\n{\r\nstruct cirrus_fbdev *gfbdev;\r\nint ret;\r\nint bpp_sel = 24;\r\ngfbdev = kzalloc(sizeof(struct cirrus_fbdev), GFP_KERNEL);\r\nif (!gfbdev)\r\nreturn -ENOMEM;\r\ncdev->mode_info.gfbdev = gfbdev;\r\ngfbdev->helper.funcs = &cirrus_fb_helper_funcs;\r\nspin_lock_init(&gfbdev->dirty_lock);\r\nret = drm_fb_helper_init(cdev->dev, &gfbdev->helper,\r\ncdev->num_crtc, CIRRUSFB_CONN_LIMIT);\r\nif (ret) {\r\nkfree(gfbdev);\r\nreturn ret;\r\n}\r\ndrm_fb_helper_single_add_all_connectors(&gfbdev->helper);\r\ndrm_helper_disable_unused_functions(cdev->dev);\r\ndrm_fb_helper_initial_config(&gfbdev->helper, bpp_sel);\r\nreturn 0;\r\n}\r\nvoid cirrus_fbdev_fini(struct cirrus_device *cdev)\r\n{\r\nif (!cdev->mode_info.gfbdev)\r\nreturn;\r\ncirrus_fbdev_destroy(cdev->dev, cdev->mode_info.gfbdev);\r\nkfree(cdev->mode_info.gfbdev);\r\ncdev->mode_info.gfbdev = NULL;\r\n}
