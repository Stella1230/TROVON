static void appldata_get_os_data(void *data)\r\n{\r\nint i, j, rc;\r\nstruct appldata_os_data *os_data;\r\nunsigned int new_size;\r\nos_data = data;\r\nos_data->sync_count_1++;\r\nos_data->nr_threads = nr_threads;\r\nos_data->nr_running = nr_running();\r\nos_data->nr_iowait = nr_iowait();\r\nos_data->avenrun[0] = avenrun[0] + (FIXED_1/200);\r\nos_data->avenrun[1] = avenrun[1] + (FIXED_1/200);\r\nos_data->avenrun[2] = avenrun[2] + (FIXED_1/200);\r\nj = 0;\r\nfor_each_online_cpu(i) {\r\nos_data->os_cpu[j].per_cpu_user =\r\ncputime_to_jiffies(kcpustat_cpu(i).cpustat[CPUTIME_USER]);\r\nos_data->os_cpu[j].per_cpu_nice =\r\ncputime_to_jiffies(kcpustat_cpu(i).cpustat[CPUTIME_NICE]);\r\nos_data->os_cpu[j].per_cpu_system =\r\ncputime_to_jiffies(kcpustat_cpu(i).cpustat[CPUTIME_SYSTEM]);\r\nos_data->os_cpu[j].per_cpu_idle =\r\ncputime_to_jiffies(kcpustat_cpu(i).cpustat[CPUTIME_IDLE]);\r\nos_data->os_cpu[j].per_cpu_irq =\r\ncputime_to_jiffies(kcpustat_cpu(i).cpustat[CPUTIME_IRQ]);\r\nos_data->os_cpu[j].per_cpu_softirq =\r\ncputime_to_jiffies(kcpustat_cpu(i).cpustat[CPUTIME_SOFTIRQ]);\r\nos_data->os_cpu[j].per_cpu_iowait =\r\ncputime_to_jiffies(kcpustat_cpu(i).cpustat[CPUTIME_IOWAIT]);\r\nos_data->os_cpu[j].per_cpu_steal =\r\ncputime_to_jiffies(kcpustat_cpu(i).cpustat[CPUTIME_STEAL]);\r\nos_data->os_cpu[j].cpu_id = i;\r\nj++;\r\n}\r\nos_data->nr_cpus = j;\r\nnew_size = sizeof(struct appldata_os_data) +\r\n(os_data->nr_cpus * sizeof(struct appldata_os_per_cpu));\r\nif (ops.size != new_size) {\r\nif (ops.active) {\r\nrc = appldata_diag(APPLDATA_RECORD_OS_ID,\r\nAPPLDATA_START_INTERVAL_REC,\r\n(unsigned long) ops.data, new_size,\r\nops.mod_lvl);\r\nif (rc != 0)\r\npr_err("Starting a new OS data collection "\r\n"failed with rc=%d\n", rc);\r\nrc = appldata_diag(APPLDATA_RECORD_OS_ID,\r\nAPPLDATA_STOP_REC,\r\n(unsigned long) ops.data, ops.size,\r\nops.mod_lvl);\r\nif (rc != 0)\r\npr_err("Stopping a faulty OS data "\r\n"collection failed with rc=%d\n", rc);\r\n}\r\nops.size = new_size;\r\n}\r\nos_data->timestamp = get_tod_clock();\r\nos_data->sync_count_2++;\r\n}\r\nstatic int __init appldata_os_init(void)\r\n{\r\nint rc, max_size;\r\nmax_size = sizeof(struct appldata_os_data) +\r\n(num_possible_cpus() * sizeof(struct appldata_os_per_cpu));\r\nif (max_size > APPLDATA_MAX_REC_SIZE) {\r\npr_err("Maximum OS record size %i exceeds the maximum "\r\n"record size %i\n", max_size, APPLDATA_MAX_REC_SIZE);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nappldata_os_data = kzalloc(max_size, GFP_KERNEL | GFP_DMA);\r\nif (appldata_os_data == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nappldata_os_data->per_cpu_size = sizeof(struct appldata_os_per_cpu);\r\nappldata_os_data->cpu_offset = offsetof(struct appldata_os_data,\r\nos_cpu);\r\nops.data = appldata_os_data;\r\nops.callback = &appldata_get_os_data;\r\nrc = appldata_register_ops(&ops);\r\nif (rc != 0)\r\nkfree(appldata_os_data);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit appldata_os_exit(void)\r\n{\r\nappldata_unregister_ops(&ops);\r\nkfree(appldata_os_data);\r\n}
