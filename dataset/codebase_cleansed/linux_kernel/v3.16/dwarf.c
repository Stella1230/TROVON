static struct dwarf_reg *dwarf_frame_alloc_reg(struct dwarf_frame *frame,\r\nunsigned int reg_num)\r\n{\r\nstruct dwarf_reg *reg;\r\nreg = mempool_alloc(dwarf_reg_pool, GFP_ATOMIC);\r\nif (!reg) {\r\nprintk(KERN_WARNING "Unable to allocate a DWARF register\n");\r\nUNWINDER_BUG();\r\n}\r\nreg->number = reg_num;\r\nreg->addr = 0;\r\nreg->flags = 0;\r\nlist_add(&reg->link, &frame->reg_list);\r\nreturn reg;\r\n}\r\nstatic void dwarf_frame_free_regs(struct dwarf_frame *frame)\r\n{\r\nstruct dwarf_reg *reg, *n;\r\nlist_for_each_entry_safe(reg, n, &frame->reg_list, link) {\r\nlist_del(&reg->link);\r\nmempool_free(reg, dwarf_reg_pool);\r\n}\r\n}\r\nstatic struct dwarf_reg *dwarf_frame_reg(struct dwarf_frame *frame,\r\nunsigned int reg_num)\r\n{\r\nstruct dwarf_reg *reg;\r\nlist_for_each_entry(reg, &frame->reg_list, link) {\r\nif (reg->number == reg_num)\r\nreturn reg;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline int dwarf_read_addr(unsigned long *src, unsigned long *dst)\r\n{\r\nu32 val = get_unaligned(src);\r\nput_unaligned(val, dst);\r\nreturn sizeof(unsigned long *);\r\n}\r\nstatic inline unsigned long dwarf_read_uleb128(char *addr, unsigned int *ret)\r\n{\r\nunsigned int result;\r\nunsigned char byte;\r\nint shift, count;\r\nresult = 0;\r\nshift = 0;\r\ncount = 0;\r\nwhile (1) {\r\nbyte = __raw_readb(addr);\r\naddr++;\r\ncount++;\r\nresult |= (byte & 0x7f) << shift;\r\nshift += 7;\r\nif (!(byte & 0x80))\r\nbreak;\r\n}\r\n*ret = result;\r\nreturn count;\r\n}\r\nstatic inline unsigned long dwarf_read_leb128(char *addr, int *ret)\r\n{\r\nunsigned char byte;\r\nint result, shift;\r\nint num_bits;\r\nint count;\r\nresult = 0;\r\nshift = 0;\r\ncount = 0;\r\nwhile (1) {\r\nbyte = __raw_readb(addr);\r\naddr++;\r\nresult |= (byte & 0x7f) << shift;\r\nshift += 7;\r\ncount++;\r\nif (!(byte & 0x80))\r\nbreak;\r\n}\r\nnum_bits = 8 * sizeof(result);\r\nif ((shift < num_bits) && (byte & 0x40))\r\nresult |= (-1 << shift);\r\n*ret = result;\r\nreturn count;\r\n}\r\nstatic int dwarf_read_encoded_value(char *addr, unsigned long *val,\r\nchar encoding)\r\n{\r\nunsigned long decoded_addr = 0;\r\nint count = 0;\r\nswitch (encoding & 0x70) {\r\ncase DW_EH_PE_absptr:\r\nbreak;\r\ncase DW_EH_PE_pcrel:\r\ndecoded_addr = (unsigned long)addr;\r\nbreak;\r\ndefault:\r\npr_debug("encoding=0x%x\n", (encoding & 0x70));\r\nUNWINDER_BUG();\r\n}\r\nif ((encoding & 0x07) == 0x00)\r\nencoding |= DW_EH_PE_udata4;\r\nswitch (encoding & 0x0f) {\r\ncase DW_EH_PE_sdata4:\r\ncase DW_EH_PE_udata4:\r\ncount += 4;\r\ndecoded_addr += get_unaligned((u32 *)addr);\r\n__raw_writel(decoded_addr, val);\r\nbreak;\r\ndefault:\r\npr_debug("encoding=0x%x\n", encoding);\r\nUNWINDER_BUG();\r\n}\r\nreturn count;\r\n}\r\nstatic inline int dwarf_entry_len(char *addr, unsigned long *len)\r\n{\r\nu32 initial_len;\r\nint count;\r\ninitial_len = get_unaligned((u32 *)addr);\r\ncount = 4;\r\nif (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {\r\nif (initial_len == DW_EXT_DWARF64) {\r\n*len = get_unaligned((u64 *)addr + 4);\r\ncount = 12;\r\n} else {\r\nprintk(KERN_WARNING "Unknown DWARF extension\n");\r\ncount = 0;\r\n}\r\n} else\r\n*len = initial_len;\r\nreturn count;\r\n}\r\nstatic struct dwarf_cie *dwarf_lookup_cie(unsigned long cie_ptr)\r\n{\r\nstruct rb_node **rb_node = &cie_root.rb_node;\r\nstruct dwarf_cie *cie = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dwarf_cie_lock, flags);\r\nif (cached_cie && cached_cie->cie_pointer == cie_ptr) {\r\ncie = cached_cie;\r\ngoto out;\r\n}\r\nwhile (*rb_node) {\r\nstruct dwarf_cie *cie_tmp;\r\ncie_tmp = rb_entry(*rb_node, struct dwarf_cie, node);\r\nBUG_ON(!cie_tmp);\r\nif (cie_ptr == cie_tmp->cie_pointer) {\r\ncie = cie_tmp;\r\ncached_cie = cie_tmp;\r\ngoto out;\r\n} else {\r\nif (cie_ptr < cie_tmp->cie_pointer)\r\nrb_node = &(*rb_node)->rb_left;\r\nelse\r\nrb_node = &(*rb_node)->rb_right;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&dwarf_cie_lock, flags);\r\nreturn cie;\r\n}\r\nstruct dwarf_fde *dwarf_lookup_fde(unsigned long pc)\r\n{\r\nstruct rb_node **rb_node = &fde_root.rb_node;\r\nstruct dwarf_fde *fde = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dwarf_fde_lock, flags);\r\nwhile (*rb_node) {\r\nstruct dwarf_fde *fde_tmp;\r\nunsigned long tmp_start, tmp_end;\r\nfde_tmp = rb_entry(*rb_node, struct dwarf_fde, node);\r\nBUG_ON(!fde_tmp);\r\ntmp_start = fde_tmp->initial_location;\r\ntmp_end = fde_tmp->initial_location + fde_tmp->address_range;\r\nif (pc < tmp_start) {\r\nrb_node = &(*rb_node)->rb_left;\r\n} else {\r\nif (pc < tmp_end) {\r\nfde = fde_tmp;\r\ngoto out;\r\n} else\r\nrb_node = &(*rb_node)->rb_right;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&dwarf_fde_lock, flags);\r\nreturn fde;\r\n}\r\nstatic int dwarf_cfa_execute_insns(unsigned char *insn_start,\r\nunsigned char *insn_end,\r\nstruct dwarf_cie *cie,\r\nstruct dwarf_fde *fde,\r\nstruct dwarf_frame *frame,\r\nunsigned long pc)\r\n{\r\nunsigned char insn;\r\nunsigned char *current_insn;\r\nunsigned int count, delta, reg, expr_len, offset;\r\nstruct dwarf_reg *regp;\r\ncurrent_insn = insn_start;\r\nwhile (current_insn < insn_end && frame->pc <= pc) {\r\ninsn = __raw_readb(current_insn++);\r\nswitch (DW_CFA_opcode(insn)) {\r\ncase DW_CFA_advance_loc:\r\ndelta = DW_CFA_operand(insn);\r\ndelta *= cie->code_alignment_factor;\r\nframe->pc += delta;\r\ncontinue;\r\ncase DW_CFA_offset:\r\nreg = DW_CFA_operand(insn);\r\ncount = dwarf_read_uleb128(current_insn, &offset);\r\ncurrent_insn += count;\r\noffset *= cie->data_alignment_factor;\r\nregp = dwarf_frame_alloc_reg(frame, reg);\r\nregp->addr = offset;\r\nregp->flags |= DWARF_REG_OFFSET;\r\ncontinue;\r\ncase DW_CFA_restore:\r\nreg = DW_CFA_operand(insn);\r\ncontinue;\r\n}\r\nswitch (insn) {\r\ncase DW_CFA_nop:\r\ncontinue;\r\ncase DW_CFA_advance_loc1:\r\ndelta = *current_insn++;\r\nframe->pc += delta * cie->code_alignment_factor;\r\nbreak;\r\ncase DW_CFA_advance_loc2:\r\ndelta = get_unaligned((u16 *)current_insn);\r\ncurrent_insn += 2;\r\nframe->pc += delta * cie->code_alignment_factor;\r\nbreak;\r\ncase DW_CFA_advance_loc4:\r\ndelta = get_unaligned((u32 *)current_insn);\r\ncurrent_insn += 4;\r\nframe->pc += delta * cie->code_alignment_factor;\r\nbreak;\r\ncase DW_CFA_offset_extended:\r\ncount = dwarf_read_uleb128(current_insn, &reg);\r\ncurrent_insn += count;\r\ncount = dwarf_read_uleb128(current_insn, &offset);\r\ncurrent_insn += count;\r\noffset *= cie->data_alignment_factor;\r\nbreak;\r\ncase DW_CFA_restore_extended:\r\ncount = dwarf_read_uleb128(current_insn, &reg);\r\ncurrent_insn += count;\r\nbreak;\r\ncase DW_CFA_undefined:\r\ncount = dwarf_read_uleb128(current_insn, &reg);\r\ncurrent_insn += count;\r\nregp = dwarf_frame_alloc_reg(frame, reg);\r\nregp->flags |= DWARF_UNDEFINED;\r\nbreak;\r\ncase DW_CFA_def_cfa:\r\ncount = dwarf_read_uleb128(current_insn,\r\n&frame->cfa_register);\r\ncurrent_insn += count;\r\ncount = dwarf_read_uleb128(current_insn,\r\n&frame->cfa_offset);\r\ncurrent_insn += count;\r\nframe->flags |= DWARF_FRAME_CFA_REG_OFFSET;\r\nbreak;\r\ncase DW_CFA_def_cfa_register:\r\ncount = dwarf_read_uleb128(current_insn,\r\n&frame->cfa_register);\r\ncurrent_insn += count;\r\nframe->flags |= DWARF_FRAME_CFA_REG_OFFSET;\r\nbreak;\r\ncase DW_CFA_def_cfa_offset:\r\ncount = dwarf_read_uleb128(current_insn, &offset);\r\ncurrent_insn += count;\r\nframe->cfa_offset = offset;\r\nbreak;\r\ncase DW_CFA_def_cfa_expression:\r\ncount = dwarf_read_uleb128(current_insn, &expr_len);\r\ncurrent_insn += count;\r\nframe->cfa_expr = current_insn;\r\nframe->cfa_expr_len = expr_len;\r\ncurrent_insn += expr_len;\r\nframe->flags |= DWARF_FRAME_CFA_REG_EXP;\r\nbreak;\r\ncase DW_CFA_offset_extended_sf:\r\ncount = dwarf_read_uleb128(current_insn, &reg);\r\ncurrent_insn += count;\r\ncount = dwarf_read_leb128(current_insn, &offset);\r\ncurrent_insn += count;\r\noffset *= cie->data_alignment_factor;\r\nregp = dwarf_frame_alloc_reg(frame, reg);\r\nregp->flags |= DWARF_REG_OFFSET;\r\nregp->addr = offset;\r\nbreak;\r\ncase DW_CFA_val_offset:\r\ncount = dwarf_read_uleb128(current_insn, &reg);\r\ncurrent_insn += count;\r\ncount = dwarf_read_leb128(current_insn, &offset);\r\noffset *= cie->data_alignment_factor;\r\nregp = dwarf_frame_alloc_reg(frame, reg);\r\nregp->flags |= DWARF_VAL_OFFSET;\r\nregp->addr = offset;\r\nbreak;\r\ncase DW_CFA_GNU_args_size:\r\ncount = dwarf_read_uleb128(current_insn, &offset);\r\ncurrent_insn += count;\r\nbreak;\r\ncase DW_CFA_GNU_negative_offset_extended:\r\ncount = dwarf_read_uleb128(current_insn, &reg);\r\ncurrent_insn += count;\r\ncount = dwarf_read_uleb128(current_insn, &offset);\r\noffset *= cie->data_alignment_factor;\r\nregp = dwarf_frame_alloc_reg(frame, reg);\r\nregp->flags |= DWARF_REG_OFFSET;\r\nregp->addr = -offset;\r\nbreak;\r\ndefault:\r\npr_debug("unhandled DWARF instruction 0x%x\n", insn);\r\nUNWINDER_BUG();\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid dwarf_free_frame(struct dwarf_frame *frame)\r\n{\r\ndwarf_frame_free_regs(frame);\r\nmempool_free(frame, dwarf_frame_pool);\r\n}\r\nstruct dwarf_frame *dwarf_unwind_stack(unsigned long pc,\r\nstruct dwarf_frame *prev)\r\n{\r\nstruct dwarf_frame *frame;\r\nstruct dwarf_cie *cie;\r\nstruct dwarf_fde *fde;\r\nstruct dwarf_reg *reg;\r\nunsigned long addr;\r\nif (!dwarf_unwinder_ready)\r\nreturn NULL;\r\nif (!pc || !prev)\r\npc = (unsigned long)current_text_addr();\r\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\r\nif (pc == (unsigned long)&return_to_handler) {\r\nint index = current->curr_ret_stack;\r\nWARN_ON(index > 0);\r\npc = current->ret_stack[index].ret;\r\n}\r\n#endif\r\nframe = mempool_alloc(dwarf_frame_pool, GFP_ATOMIC);\r\nif (!frame) {\r\nprintk(KERN_ERR "Unable to allocate a dwarf frame\n");\r\nUNWINDER_BUG();\r\n}\r\nINIT_LIST_HEAD(&frame->reg_list);\r\nframe->flags = 0;\r\nframe->prev = prev;\r\nframe->return_addr = 0;\r\nfde = dwarf_lookup_fde(pc);\r\nif (!fde) {\r\ngoto bail;\r\n}\r\ncie = dwarf_lookup_cie(fde->cie_pointer);\r\nframe->pc = fde->initial_location;\r\ndwarf_cfa_execute_insns(cie->initial_instructions,\r\ncie->instructions_end, cie, fde,\r\nframe, pc);\r\ndwarf_cfa_execute_insns(fde->instructions, fde->end, cie,\r\nfde, frame, pc);\r\nswitch (frame->flags) {\r\ncase DWARF_FRAME_CFA_REG_OFFSET:\r\nif (prev) {\r\nreg = dwarf_frame_reg(prev, frame->cfa_register);\r\nUNWINDER_BUG_ON(!reg);\r\nUNWINDER_BUG_ON(reg->flags != DWARF_REG_OFFSET);\r\naddr = prev->cfa + reg->addr;\r\nframe->cfa = __raw_readl(addr);\r\n} else {\r\nframe->cfa = dwarf_read_arch_reg(frame->cfa_register);\r\n}\r\nframe->cfa += frame->cfa_offset;\r\nbreak;\r\ndefault:\r\nUNWINDER_BUG();\r\n}\r\nreg = dwarf_frame_reg(frame, DWARF_ARCH_RA_REG);\r\nif (!reg || reg->flags == DWARF_UNDEFINED)\r\ngoto bail;\r\nUNWINDER_BUG_ON(reg->flags != DWARF_REG_OFFSET);\r\naddr = frame->cfa + reg->addr;\r\nframe->return_addr = __raw_readl(addr);\r\nif (prev && prev->pc == (unsigned long)ret_from_irq)\r\nframe->return_addr = 0;\r\nreturn frame;\r\nbail:\r\ndwarf_free_frame(frame);\r\nreturn NULL;\r\n}\r\nstatic int dwarf_parse_cie(void *entry, void *p, unsigned long len,\r\nunsigned char *end, struct module *mod)\r\n{\r\nstruct rb_node **rb_node = &cie_root.rb_node;\r\nstruct rb_node *parent = *rb_node;\r\nstruct dwarf_cie *cie;\r\nunsigned long flags;\r\nint count;\r\ncie = kzalloc(sizeof(*cie), GFP_KERNEL);\r\nif (!cie)\r\nreturn -ENOMEM;\r\ncie->length = len;\r\ncie->cie_pointer = (unsigned long)entry;\r\ncie->version = *(char *)p++;\r\nUNWINDER_BUG_ON(cie->version != 1);\r\ncie->augmentation = p;\r\np += strlen(cie->augmentation) + 1;\r\ncount = dwarf_read_uleb128(p, &cie->code_alignment_factor);\r\np += count;\r\ncount = dwarf_read_leb128(p, &cie->data_alignment_factor);\r\np += count;\r\nif (cie->version == 1) {\r\ncie->return_address_reg = __raw_readb(p);\r\np++;\r\n} else {\r\ncount = dwarf_read_uleb128(p, &cie->return_address_reg);\r\np += count;\r\n}\r\nif (cie->augmentation[0] == 'z') {\r\nunsigned int length, count;\r\ncie->flags |= DWARF_CIE_Z_AUGMENTATION;\r\ncount = dwarf_read_uleb128(p, &length);\r\np += count;\r\nUNWINDER_BUG_ON((unsigned char *)p > end);\r\ncie->initial_instructions = p + length;\r\ncie->augmentation++;\r\n}\r\nwhile (*cie->augmentation) {\r\nif (*cie->augmentation == 'L') {\r\np++;\r\ncie->augmentation++;\r\n} else if (*cie->augmentation == 'R') {\r\ncie->encoding = *(char *)p++;\r\ncie->augmentation++;\r\n} else if (*cie->augmentation == 'P') {\r\nUNWINDER_BUG();\r\n} else if (*cie->augmentation == 'S') {\r\nUNWINDER_BUG();\r\n} else {\r\np = cie->initial_instructions;\r\nUNWINDER_BUG_ON(!p);\r\nbreak;\r\n}\r\n}\r\ncie->initial_instructions = p;\r\ncie->instructions_end = end;\r\nspin_lock_irqsave(&dwarf_cie_lock, flags);\r\nwhile (*rb_node) {\r\nstruct dwarf_cie *cie_tmp;\r\ncie_tmp = rb_entry(*rb_node, struct dwarf_cie, node);\r\nparent = *rb_node;\r\nif (cie->cie_pointer < cie_tmp->cie_pointer)\r\nrb_node = &parent->rb_left;\r\nelse if (cie->cie_pointer >= cie_tmp->cie_pointer)\r\nrb_node = &parent->rb_right;\r\nelse\r\nWARN_ON(1);\r\n}\r\nrb_link_node(&cie->node, parent, rb_node);\r\nrb_insert_color(&cie->node, &cie_root);\r\n#ifdef CONFIG_MODULES\r\nif (mod != NULL)\r\nlist_add_tail(&cie->link, &mod->arch.cie_list);\r\n#endif\r\nspin_unlock_irqrestore(&dwarf_cie_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dwarf_parse_fde(void *entry, u32 entry_type,\r\nvoid *start, unsigned long len,\r\nunsigned char *end, struct module *mod)\r\n{\r\nstruct rb_node **rb_node = &fde_root.rb_node;\r\nstruct rb_node *parent = *rb_node;\r\nstruct dwarf_fde *fde;\r\nstruct dwarf_cie *cie;\r\nunsigned long flags;\r\nint count;\r\nvoid *p = start;\r\nfde = kzalloc(sizeof(*fde), GFP_KERNEL);\r\nif (!fde)\r\nreturn -ENOMEM;\r\nfde->length = len;\r\nfde->cie_pointer = (unsigned long)(p - entry_type - 4);\r\ncie = dwarf_lookup_cie(fde->cie_pointer);\r\nfde->cie = cie;\r\nif (cie->encoding)\r\ncount = dwarf_read_encoded_value(p, &fde->initial_location,\r\ncie->encoding);\r\nelse\r\ncount = dwarf_read_addr(p, &fde->initial_location);\r\np += count;\r\nif (cie->encoding)\r\ncount = dwarf_read_encoded_value(p, &fde->address_range,\r\ncie->encoding & 0x0f);\r\nelse\r\ncount = dwarf_read_addr(p, &fde->address_range);\r\np += count;\r\nif (fde->cie->flags & DWARF_CIE_Z_AUGMENTATION) {\r\nunsigned int length;\r\ncount = dwarf_read_uleb128(p, &length);\r\np += count + length;\r\n}\r\nfde->instructions = p;\r\nfde->end = end;\r\nspin_lock_irqsave(&dwarf_fde_lock, flags);\r\nwhile (*rb_node) {\r\nstruct dwarf_fde *fde_tmp;\r\nunsigned long tmp_start, tmp_end;\r\nunsigned long start, end;\r\nfde_tmp = rb_entry(*rb_node, struct dwarf_fde, node);\r\nstart = fde->initial_location;\r\nend = fde->initial_location + fde->address_range;\r\ntmp_start = fde_tmp->initial_location;\r\ntmp_end = fde_tmp->initial_location + fde_tmp->address_range;\r\nparent = *rb_node;\r\nif (start < tmp_start)\r\nrb_node = &parent->rb_left;\r\nelse if (start >= tmp_end)\r\nrb_node = &parent->rb_right;\r\nelse\r\nWARN_ON(1);\r\n}\r\nrb_link_node(&fde->node, parent, rb_node);\r\nrb_insert_color(&fde->node, &fde_root);\r\n#ifdef CONFIG_MODULES\r\nif (mod != NULL)\r\nlist_add_tail(&fde->link, &mod->arch.fde_list);\r\n#endif\r\nspin_unlock_irqrestore(&dwarf_fde_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void dwarf_unwinder_dump(struct task_struct *task,\r\nstruct pt_regs *regs,\r\nunsigned long *sp,\r\nconst struct stacktrace_ops *ops,\r\nvoid *data)\r\n{\r\nstruct dwarf_frame *frame, *_frame;\r\nunsigned long return_addr;\r\n_frame = NULL;\r\nreturn_addr = 0;\r\nwhile (1) {\r\nframe = dwarf_unwind_stack(return_addr, _frame);\r\nif (_frame)\r\ndwarf_free_frame(_frame);\r\n_frame = frame;\r\nif (!frame || !frame->return_addr)\r\nbreak;\r\nreturn_addr = frame->return_addr;\r\nops->address(data, return_addr, 1);\r\n}\r\nif (frame)\r\ndwarf_free_frame(frame);\r\n}\r\nstatic void dwarf_unwinder_cleanup(void)\r\n{\r\nstruct dwarf_fde *fde, *next_fde;\r\nstruct dwarf_cie *cie, *next_cie;\r\nrbtree_postorder_for_each_entry_safe(fde, next_fde, &fde_root, node)\r\nkfree(fde);\r\nrbtree_postorder_for_each_entry_safe(cie, next_cie, &cie_root, node)\r\nkfree(cie);\r\nkmem_cache_destroy(dwarf_reg_cachep);\r\nkmem_cache_destroy(dwarf_frame_cachep);\r\n}\r\nstatic int dwarf_parse_section(char *eh_frame_start, char *eh_frame_end,\r\nstruct module *mod)\r\n{\r\nu32 entry_type;\r\nvoid *p, *entry;\r\nint count, err = 0;\r\nunsigned long len = 0;\r\nunsigned int c_entries, f_entries;\r\nunsigned char *end;\r\nc_entries = 0;\r\nf_entries = 0;\r\nentry = eh_frame_start;\r\nwhile ((char *)entry < eh_frame_end) {\r\np = entry;\r\ncount = dwarf_entry_len(p, &len);\r\nif (count == 0) {\r\nerr = -EINVAL;\r\ngoto out;\r\n} else\r\np += count;\r\nend = p + len;\r\nentry_type = get_unaligned((u32 *)p);\r\np += 4;\r\nif (entry_type == DW_EH_FRAME_CIE) {\r\nerr = dwarf_parse_cie(entry, p, len, end, mod);\r\nif (err < 0)\r\ngoto out;\r\nelse\r\nc_entries++;\r\n} else {\r\nerr = dwarf_parse_fde(entry, entry_type, p, len,\r\nend, mod);\r\nif (err < 0)\r\ngoto out;\r\nelse\r\nf_entries++;\r\n}\r\nentry = (char *)entry + len + 4;\r\n}\r\nprintk(KERN_INFO "DWARF unwinder initialised: read %u CIEs, %u FDEs\n",\r\nc_entries, f_entries);\r\nreturn 0;\r\nout:\r\nreturn err;\r\n}\r\nint module_dwarf_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,\r\nstruct module *me)\r\n{\r\nunsigned int i, err;\r\nunsigned long start, end;\r\nchar *secstrings = (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;\r\nstart = end = 0;\r\nfor (i = 1; i < hdr->e_shnum; i++) {\r\nif ((sechdrs[i].sh_flags & SHF_ALLOC)\r\n&& !strcmp(secstrings+sechdrs[i].sh_name, ".eh_frame")) {\r\nstart = sechdrs[i].sh_addr;\r\nend = start + sechdrs[i].sh_size;\r\nbreak;\r\n}\r\n}\r\nif (i != hdr->e_shnum) {\r\nINIT_LIST_HEAD(&me->arch.cie_list);\r\nINIT_LIST_HEAD(&me->arch.fde_list);\r\nerr = dwarf_parse_section((char *)start, (char *)end, me);\r\nif (err) {\r\nprintk(KERN_WARNING "%s: failed to parse DWARF info\n",\r\nme->name);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid module_dwarf_cleanup(struct module *mod)\r\n{\r\nstruct dwarf_fde *fde, *ftmp;\r\nstruct dwarf_cie *cie, *ctmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dwarf_cie_lock, flags);\r\nlist_for_each_entry_safe(cie, ctmp, &mod->arch.cie_list, link) {\r\nlist_del(&cie->link);\r\nrb_erase(&cie->node, &cie_root);\r\nkfree(cie);\r\n}\r\nspin_unlock_irqrestore(&dwarf_cie_lock, flags);\r\nspin_lock_irqsave(&dwarf_fde_lock, flags);\r\nlist_for_each_entry_safe(fde, ftmp, &mod->arch.fde_list, link) {\r\nlist_del(&fde->link);\r\nrb_erase(&fde->node, &fde_root);\r\nkfree(fde);\r\n}\r\nspin_unlock_irqrestore(&dwarf_fde_lock, flags);\r\n}\r\nstatic int __init dwarf_unwinder_init(void)\r\n{\r\nint err = -ENOMEM;\r\ndwarf_frame_cachep = kmem_cache_create("dwarf_frames",\r\nsizeof(struct dwarf_frame), 0,\r\nSLAB_PANIC | SLAB_HWCACHE_ALIGN | SLAB_NOTRACK, NULL);\r\ndwarf_reg_cachep = kmem_cache_create("dwarf_regs",\r\nsizeof(struct dwarf_reg), 0,\r\nSLAB_PANIC | SLAB_HWCACHE_ALIGN | SLAB_NOTRACK, NULL);\r\ndwarf_frame_pool = mempool_create(DWARF_FRAME_MIN_REQ,\r\nmempool_alloc_slab,\r\nmempool_free_slab,\r\ndwarf_frame_cachep);\r\nif (!dwarf_frame_pool)\r\ngoto out;\r\ndwarf_reg_pool = mempool_create(DWARF_REG_MIN_REQ,\r\nmempool_alloc_slab,\r\nmempool_free_slab,\r\ndwarf_reg_cachep);\r\nif (!dwarf_reg_pool)\r\ngoto out;\r\nerr = dwarf_parse_section(__start_eh_frame, __stop_eh_frame, NULL);\r\nif (err)\r\ngoto out;\r\nerr = unwinder_register(&dwarf_unwinder);\r\nif (err)\r\ngoto out;\r\ndwarf_unwinder_ready = 1;\r\nreturn 0;\r\nout:\r\nprintk(KERN_ERR "Failed to initialise DWARF unwinder: %d\n", err);\r\ndwarf_unwinder_cleanup();\r\nreturn err;\r\n}
