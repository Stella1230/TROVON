void btc_get_max_clock_from_voltage_dependency_table(struct radeon_clock_voltage_dependency_table *table,\r\nu32 *max_clock)\r\n{\r\nu32 i, clock = 0;\r\nif ((table == NULL) || (table->count == 0)) {\r\n*max_clock = clock;\r\nreturn;\r\n}\r\nfor (i = 0; i < table->count; i++) {\r\nif (clock < table->entries[i].clk)\r\nclock = table->entries[i].clk;\r\n}\r\n*max_clock = clock;\r\n}\r\nvoid btc_apply_voltage_dependency_rules(struct radeon_clock_voltage_dependency_table *table,\r\nu32 clock, u16 max_voltage, u16 *voltage)\r\n{\r\nu32 i;\r\nif ((table == NULL) || (table->count == 0))\r\nreturn;\r\nfor (i= 0; i < table->count; i++) {\r\nif (clock <= table->entries[i].clk) {\r\nif (*voltage < table->entries[i].v)\r\n*voltage = (u16)((table->entries[i].v < max_voltage) ?\r\ntable->entries[i].v : max_voltage);\r\nreturn;\r\n}\r\n}\r\n*voltage = (*voltage > max_voltage) ? *voltage : max_voltage;\r\n}\r\nstatic u32 btc_find_valid_clock(struct radeon_clock_array *clocks,\r\nu32 max_clock, u32 requested_clock)\r\n{\r\nunsigned int i;\r\nif ((clocks == NULL) || (clocks->count == 0))\r\nreturn (requested_clock < max_clock) ? requested_clock : max_clock;\r\nfor (i = 0; i < clocks->count; i++) {\r\nif (clocks->values[i] >= requested_clock)\r\nreturn (clocks->values[i] < max_clock) ? clocks->values[i] : max_clock;\r\n}\r\nreturn (clocks->values[clocks->count - 1] < max_clock) ?\r\nclocks->values[clocks->count - 1] : max_clock;\r\n}\r\nstatic u32 btc_get_valid_mclk(struct radeon_device *rdev,\r\nu32 max_mclk, u32 requested_mclk)\r\n{\r\nreturn btc_find_valid_clock(&rdev->pm.dpm.dyn_state.valid_mclk_values,\r\nmax_mclk, requested_mclk);\r\n}\r\nstatic u32 btc_get_valid_sclk(struct radeon_device *rdev,\r\nu32 max_sclk, u32 requested_sclk)\r\n{\r\nreturn btc_find_valid_clock(&rdev->pm.dpm.dyn_state.valid_sclk_values,\r\nmax_sclk, requested_sclk);\r\n}\r\nvoid btc_skip_blacklist_clocks(struct radeon_device *rdev,\r\nconst u32 max_sclk, const u32 max_mclk,\r\nu32 *sclk, u32 *mclk)\r\n{\r\nint i, num_blacklist_clocks;\r\nif ((sclk == NULL) || (mclk == NULL))\r\nreturn;\r\nnum_blacklist_clocks = ARRAY_SIZE(btc_blacklist_clocks);\r\nfor (i = 0; i < num_blacklist_clocks; i++) {\r\nif ((btc_blacklist_clocks[i].sclk == *sclk) &&\r\n(btc_blacklist_clocks[i].mclk == *mclk))\r\nbreak;\r\n}\r\nif (i < num_blacklist_clocks) {\r\nif (btc_blacklist_clocks[i].action == RADEON_SCLK_UP) {\r\n*sclk = btc_get_valid_sclk(rdev, max_sclk, *sclk + 1);\r\nif (*sclk < max_sclk)\r\nbtc_skip_blacklist_clocks(rdev, max_sclk, max_mclk, sclk, mclk);\r\n}\r\n}\r\n}\r\nvoid btc_adjust_clock_combinations(struct radeon_device *rdev,\r\nconst struct radeon_clock_and_voltage_limits *max_limits,\r\nstruct rv7xx_pl *pl)\r\n{\r\nif ((pl->mclk == 0) || (pl->sclk == 0))\r\nreturn;\r\nif (pl->mclk == pl->sclk)\r\nreturn;\r\nif (pl->mclk > pl->sclk) {\r\nif (((pl->mclk + (pl->sclk - 1)) / pl->sclk) > rdev->pm.dpm.dyn_state.mclk_sclk_ratio)\r\npl->sclk = btc_get_valid_sclk(rdev,\r\nmax_limits->sclk,\r\n(pl->mclk +\r\n(rdev->pm.dpm.dyn_state.mclk_sclk_ratio - 1)) /\r\nrdev->pm.dpm.dyn_state.mclk_sclk_ratio);\r\n} else {\r\nif ((pl->sclk - pl->mclk) > rdev->pm.dpm.dyn_state.sclk_mclk_delta)\r\npl->mclk = btc_get_valid_mclk(rdev,\r\nmax_limits->mclk,\r\npl->sclk -\r\nrdev->pm.dpm.dyn_state.sclk_mclk_delta);\r\n}\r\n}\r\nstatic u16 btc_find_voltage(struct atom_voltage_table *table, u16 voltage)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < table->count; i++) {\r\nif (voltage <= table->entries[i].value)\r\nreturn table->entries[i].value;\r\n}\r\nreturn table->entries[table->count - 1].value;\r\n}\r\nvoid btc_apply_voltage_delta_rules(struct radeon_device *rdev,\r\nu16 max_vddc, u16 max_vddci,\r\nu16 *vddc, u16 *vddci)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu16 new_voltage;\r\nif ((0 == *vddc) || (0 == *vddci))\r\nreturn;\r\nif (*vddc > *vddci) {\r\nif ((*vddc - *vddci) > rdev->pm.dpm.dyn_state.vddc_vddci_delta) {\r\nnew_voltage = btc_find_voltage(&eg_pi->vddci_voltage_table,\r\n(*vddc - rdev->pm.dpm.dyn_state.vddc_vddci_delta));\r\n*vddci = (new_voltage < max_vddci) ? new_voltage : max_vddci;\r\n}\r\n} else {\r\nif ((*vddci - *vddc) > rdev->pm.dpm.dyn_state.vddc_vddci_delta) {\r\nnew_voltage = btc_find_voltage(&eg_pi->vddc_voltage_table,\r\n(*vddci - rdev->pm.dpm.dyn_state.vddc_vddci_delta));\r\n*vddc = (new_voltage < max_vddc) ? new_voltage : max_vddc;\r\n}\r\n}\r\n}\r\nstatic void btc_enable_bif_dynamic_pcie_gen2(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 tmp, bif;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\r\nif (enable) {\r\nif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\r\n(tmp & LC_OTHER_SIDE_SUPPORTS_GEN2)) {\r\nif (!pi->boot_in_gen2) {\r\nbif = RREG32(CG_BIF_REQ_AND_RSP) & ~CG_CLIENT_REQ_MASK;\r\nbif |= CG_CLIENT_REQ(0xd);\r\nWREG32(CG_BIF_REQ_AND_RSP, bif);\r\ntmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\r\ntmp |= LC_HW_VOLTAGE_IF_CONTROL(1);\r\ntmp |= LC_GEN2_EN_STRAP;\r\ntmp |= LC_CLR_FAILED_SPD_CHANGE_CNT;\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\nudelay(10);\r\ntmp &= ~LC_CLR_FAILED_SPD_CHANGE_CNT;\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\n}\r\n}\r\n} else {\r\nif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) ||\r\n(tmp & LC_OTHER_SIDE_SUPPORTS_GEN2)) {\r\nif (!pi->boot_in_gen2) {\r\nbif = RREG32(CG_BIF_REQ_AND_RSP) & ~CG_CLIENT_REQ_MASK;\r\nbif |= CG_CLIENT_REQ(0xd);\r\nWREG32(CG_BIF_REQ_AND_RSP, bif);\r\ntmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\r\ntmp &= ~LC_GEN2_EN_STRAP;\r\n}\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\n}\r\n}\r\n}\r\nstatic void btc_enable_dynamic_pcie_gen2(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nbtc_enable_bif_dynamic_pcie_gen2(rdev, enable);\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, ENABLE_GEN2PCIE, ~ENABLE_GEN2PCIE);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~ENABLE_GEN2PCIE);\r\n}\r\nstatic int btc_disable_ulv(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nif (eg_pi->ulv.supported) {\r\nif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_DisableULV) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int btc_populate_ulv_state(struct radeon_device *rdev,\r\nRV770_SMC_STATETABLE *table)\r\n{\r\nint ret = -EINVAL;\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct rv7xx_pl *ulv_pl = eg_pi->ulv.pl;\r\nif (ulv_pl->vddc) {\r\nret = cypress_convert_power_level_to_smc(rdev,\r\nulv_pl,\r\n&table->ULVState.levels[0],\r\nPPSMC_DISPLAY_WATERMARK_LOW);\r\nif (ret == 0) {\r\ntable->ULVState.levels[0].arbValue = MC_CG_ARB_FREQ_F0;\r\ntable->ULVState.levels[0].ACIndex = 1;\r\ntable->ULVState.levels[1] = table->ULVState.levels[0];\r\ntable->ULVState.levels[2] = table->ULVState.levels[0];\r\ntable->ULVState.flags |= PPSMC_SWSTATE_FLAG_DC;\r\nWREG32(CG_ULV_CONTROL, BTC_CGULVCONTROL_DFLT);\r\nWREG32(CG_ULV_PARAMETER, BTC_CGULVPARAMETER_DFLT);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int btc_populate_smc_acpi_state(struct radeon_device *rdev,\r\nRV770_SMC_STATETABLE *table)\r\n{\r\nint ret = cypress_populate_smc_acpi_state(rdev, table);\r\nif (ret == 0) {\r\ntable->ACPIState.levels[0].ACIndex = 0;\r\ntable->ACPIState.levels[1].ACIndex = 0;\r\ntable->ACPIState.levels[2].ACIndex = 0;\r\n}\r\nreturn ret;\r\n}\r\nvoid btc_program_mgcg_hw_sequence(struct radeon_device *rdev,\r\nconst u32 *sequence, u32 count)\r\n{\r\nu32 i, length = count * 3;\r\nu32 tmp;\r\nfor (i = 0; i < length; i+=3) {\r\ntmp = RREG32(sequence[i]);\r\ntmp &= ~sequence[i+2];\r\ntmp |= sequence[i+1] & sequence[i+2];\r\nWREG32(sequence[i], tmp);\r\n}\r\n}\r\nstatic void btc_cg_clock_gating_default(struct radeon_device *rdev)\r\n{\r\nu32 count;\r\nconst u32 *p = NULL;\r\nif (rdev->family == CHIP_BARTS) {\r\np = (const u32 *)&barts_cgcg_cgls_default;\r\ncount = BARTS_CGCG_CGLS_DEFAULT_LENGTH;\r\n} else if (rdev->family == CHIP_TURKS) {\r\np = (const u32 *)&turks_cgcg_cgls_default;\r\ncount = TURKS_CGCG_CGLS_DEFAULT_LENGTH;\r\n} else if (rdev->family == CHIP_CAICOS) {\r\np = (const u32 *)&caicos_cgcg_cgls_default;\r\ncount = CAICOS_CGCG_CGLS_DEFAULT_LENGTH;\r\n} else\r\nreturn;\r\nbtc_program_mgcg_hw_sequence(rdev, p, count);\r\n}\r\nstatic void btc_cg_clock_gating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nu32 count;\r\nconst u32 *p = NULL;\r\nif (enable) {\r\nif (rdev->family == CHIP_BARTS) {\r\np = (const u32 *)&barts_cgcg_cgls_enable;\r\ncount = BARTS_CGCG_CGLS_ENABLE_LENGTH;\r\n} else if (rdev->family == CHIP_TURKS) {\r\np = (const u32 *)&turks_cgcg_cgls_enable;\r\ncount = TURKS_CGCG_CGLS_ENABLE_LENGTH;\r\n} else if (rdev->family == CHIP_CAICOS) {\r\np = (const u32 *)&caicos_cgcg_cgls_enable;\r\ncount = CAICOS_CGCG_CGLS_ENABLE_LENGTH;\r\n} else\r\nreturn;\r\n} else {\r\nif (rdev->family == CHIP_BARTS) {\r\np = (const u32 *)&barts_cgcg_cgls_disable;\r\ncount = BARTS_CGCG_CGLS_DISABLE_LENGTH;\r\n} else if (rdev->family == CHIP_TURKS) {\r\np = (const u32 *)&turks_cgcg_cgls_disable;\r\ncount = TURKS_CGCG_CGLS_DISABLE_LENGTH;\r\n} else if (rdev->family == CHIP_CAICOS) {\r\np = (const u32 *)&caicos_cgcg_cgls_disable;\r\ncount = CAICOS_CGCG_CGLS_DISABLE_LENGTH;\r\n} else\r\nreturn;\r\n}\r\nbtc_program_mgcg_hw_sequence(rdev, p, count);\r\n}\r\nstatic void btc_mg_clock_gating_default(struct radeon_device *rdev)\r\n{\r\nu32 count;\r\nconst u32 *p = NULL;\r\nif (rdev->family == CHIP_BARTS) {\r\np = (const u32 *)&barts_mgcg_default;\r\ncount = BARTS_MGCG_DEFAULT_LENGTH;\r\n} else if (rdev->family == CHIP_TURKS) {\r\np = (const u32 *)&turks_mgcg_default;\r\ncount = TURKS_MGCG_DEFAULT_LENGTH;\r\n} else if (rdev->family == CHIP_CAICOS) {\r\np = (const u32 *)&caicos_mgcg_default;\r\ncount = CAICOS_MGCG_DEFAULT_LENGTH;\r\n} else\r\nreturn;\r\nbtc_program_mgcg_hw_sequence(rdev, p, count);\r\n}\r\nstatic void btc_mg_clock_gating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nu32 count;\r\nconst u32 *p = NULL;\r\nif (enable) {\r\nif (rdev->family == CHIP_BARTS) {\r\np = (const u32 *)&barts_mgcg_enable;\r\ncount = BARTS_MGCG_ENABLE_LENGTH;\r\n} else if (rdev->family == CHIP_TURKS) {\r\np = (const u32 *)&turks_mgcg_enable;\r\ncount = TURKS_MGCG_ENABLE_LENGTH;\r\n} else if (rdev->family == CHIP_CAICOS) {\r\np = (const u32 *)&caicos_mgcg_enable;\r\ncount = CAICOS_MGCG_ENABLE_LENGTH;\r\n} else\r\nreturn;\r\n} else {\r\nif (rdev->family == CHIP_BARTS) {\r\np = (const u32 *)&barts_mgcg_disable[0];\r\ncount = BARTS_MGCG_DISABLE_LENGTH;\r\n} else if (rdev->family == CHIP_TURKS) {\r\np = (const u32 *)&turks_mgcg_disable[0];\r\ncount = TURKS_MGCG_DISABLE_LENGTH;\r\n} else if (rdev->family == CHIP_CAICOS) {\r\np = (const u32 *)&caicos_mgcg_disable[0];\r\ncount = CAICOS_MGCG_DISABLE_LENGTH;\r\n} else\r\nreturn;\r\n}\r\nbtc_program_mgcg_hw_sequence(rdev, p, count);\r\n}\r\nstatic void btc_ls_clock_gating_default(struct radeon_device *rdev)\r\n{\r\nu32 count;\r\nconst u32 *p = NULL;\r\nif (rdev->family == CHIP_BARTS) {\r\np = (const u32 *)&barts_sysls_default;\r\ncount = BARTS_SYSLS_DEFAULT_LENGTH;\r\n} else if (rdev->family == CHIP_TURKS) {\r\np = (const u32 *)&turks_sysls_default;\r\ncount = TURKS_SYSLS_DEFAULT_LENGTH;\r\n} else if (rdev->family == CHIP_CAICOS) {\r\np = (const u32 *)&caicos_sysls_default;\r\ncount = CAICOS_SYSLS_DEFAULT_LENGTH;\r\n} else\r\nreturn;\r\nbtc_program_mgcg_hw_sequence(rdev, p, count);\r\n}\r\nstatic void btc_ls_clock_gating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nu32 count;\r\nconst u32 *p = NULL;\r\nif (enable) {\r\nif (rdev->family == CHIP_BARTS) {\r\np = (const u32 *)&barts_sysls_enable;\r\ncount = BARTS_SYSLS_ENABLE_LENGTH;\r\n} else if (rdev->family == CHIP_TURKS) {\r\np = (const u32 *)&turks_sysls_enable;\r\ncount = TURKS_SYSLS_ENABLE_LENGTH;\r\n} else if (rdev->family == CHIP_CAICOS) {\r\np = (const u32 *)&caicos_sysls_enable;\r\ncount = CAICOS_SYSLS_ENABLE_LENGTH;\r\n} else\r\nreturn;\r\n} else {\r\nif (rdev->family == CHIP_BARTS) {\r\np = (const u32 *)&barts_sysls_disable;\r\ncount = BARTS_SYSLS_DISABLE_LENGTH;\r\n} else if (rdev->family == CHIP_TURKS) {\r\np = (const u32 *)&turks_sysls_disable;\r\ncount = TURKS_SYSLS_DISABLE_LENGTH;\r\n} else if (rdev->family == CHIP_CAICOS) {\r\np = (const u32 *)&caicos_sysls_disable;\r\ncount = CAICOS_SYSLS_DISABLE_LENGTH;\r\n} else\r\nreturn;\r\n}\r\nbtc_program_mgcg_hw_sequence(rdev, p, count);\r\n}\r\nbool btc_dpm_enabled(struct radeon_device *rdev)\r\n{\r\nif (rv770_is_smc_running(rdev))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int btc_init_smc_table(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_boot_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nRV770_SMC_STATETABLE *table = &pi->smc_statetable;\r\nint ret;\r\nmemset(table, 0, sizeof(RV770_SMC_STATETABLE));\r\ncypress_populate_smc_voltage_tables(rdev, table);\r\nswitch (rdev->pm.int_thermal_type) {\r\ncase THERMAL_TYPE_EVERGREEN:\r\ncase THERMAL_TYPE_EMC2103_WITH_INTERNAL:\r\ntable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_INTERNAL;\r\nbreak;\r\ncase THERMAL_TYPE_NONE:\r\ntable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_NONE;\r\nbreak;\r\ndefault:\r\ntable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_EXTERNAL;\r\nbreak;\r\n}\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC)\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT)\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_REGULATOR_HOT;\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\r\nif (pi->mem_gddr5)\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\r\nret = cypress_populate_smc_initial_state(rdev, radeon_boot_state, table);\r\nif (ret)\r\nreturn ret;\r\nif (eg_pi->sclk_deep_sleep)\r\nWREG32_P(SCLK_PSKIP_CNTL, PSKIP_ON_ALLOW_STOP_HI(32),\r\n~PSKIP_ON_ALLOW_STOP_HI_MASK);\r\nret = btc_populate_smc_acpi_state(rdev, table);\r\nif (ret)\r\nreturn ret;\r\nif (eg_pi->ulv.supported) {\r\nret = btc_populate_ulv_state(rdev, table);\r\nif (ret)\r\neg_pi->ulv.supported = false;\r\n}\r\ntable->driverState = table->initialState;\r\nreturn rv770_copy_bytes_to_smc(rdev,\r\npi->state_table_start,\r\n(u8 *)table,\r\nsizeof(RV770_SMC_STATETABLE),\r\npi->sram_end);\r\n}\r\nstatic void btc_set_at_for_uvd(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nint idx = 0;\r\nif (r600_is_uvd_state(radeon_new_state->class, radeon_new_state->class2))\r\nidx = 1;\r\nif ((idx == 1) && !eg_pi->smu_uvd_hs) {\r\npi->rlp = 10;\r\npi->rmp = 100;\r\npi->lhp = 100;\r\npi->lmp = 10;\r\n} else {\r\npi->rlp = eg_pi->ats[idx].rlp;\r\npi->rmp = eg_pi->ats[idx].rmp;\r\npi->lhp = eg_pi->ats[idx].lhp;\r\npi->lmp = eg_pi->ats[idx].lmp;\r\n}\r\n}\r\nvoid btc_notify_uvd_to_smc(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nif (r600_is_uvd_state(radeon_new_state->class, radeon_new_state->class2)) {\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_uvd_enabled, 1);\r\neg_pi->uvd_enabled = true;\r\n} else {\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_uvd_enabled, 0);\r\neg_pi->uvd_enabled = false;\r\n}\r\n}\r\nint btc_reset_to_default(struct radeon_device *rdev)\r\n{\r\nif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_ResetToDefaults) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void btc_stop_smc(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (((RREG32(LB_SYNC_RESET_SEL) & LB_SYNC_RESET_SEL_MASK) >> LB_SYNC_RESET_SEL_SHIFT) != 1)\r\nbreak;\r\nudelay(1);\r\n}\r\nudelay(100);\r\nr7xx_stop_smc(rdev);\r\n}\r\nvoid btc_read_arb_registers(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct evergreen_arb_registers *arb_registers =\r\n&eg_pi->bootup_arb_registers;\r\narb_registers->mc_arb_dram_timing = RREG32(MC_ARB_DRAM_TIMING);\r\narb_registers->mc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2);\r\narb_registers->mc_arb_rfsh_rate = RREG32(MC_ARB_RFSH_RATE);\r\narb_registers->mc_arb_burst_time = RREG32(MC_ARB_BURST_TIME);\r\n}\r\nstatic void btc_set_arb0_registers(struct radeon_device *rdev,\r\nstruct evergreen_arb_registers *arb_registers)\r\n{\r\nu32 val;\r\nWREG32(MC_ARB_DRAM_TIMING, arb_registers->mc_arb_dram_timing);\r\nWREG32(MC_ARB_DRAM_TIMING2, arb_registers->mc_arb_dram_timing2);\r\nval = (arb_registers->mc_arb_rfsh_rate & POWERMODE0_MASK) >>\r\nPOWERMODE0_SHIFT;\r\nWREG32_P(MC_ARB_RFSH_RATE, POWERMODE0(val), ~POWERMODE0_MASK);\r\nval = (arb_registers->mc_arb_burst_time & STATE0_MASK) >>\r\nSTATE0_SHIFT;\r\nWREG32_P(MC_ARB_BURST_TIME, STATE0(val), ~STATE0_MASK);\r\n}\r\nstatic void btc_set_boot_state_timing(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nif (eg_pi->ulv.supported)\r\nbtc_set_arb0_registers(rdev, &eg_pi->bootup_arb_registers);\r\n}\r\nstatic bool btc_is_state_ulv_compatible(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state)\r\n{\r\nstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct rv7xx_pl *ulv_pl = eg_pi->ulv.pl;\r\nif (state->low.mclk != ulv_pl->mclk)\r\nreturn false;\r\nif (state->low.vddci != ulv_pl->vddci)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int btc_set_ulv_dram_timing(struct radeon_device *rdev)\r\n{\r\nu32 val;\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct rv7xx_pl *ulv_pl = eg_pi->ulv.pl;\r\nradeon_atom_set_engine_dram_timings(rdev,\r\nulv_pl->sclk,\r\nulv_pl->mclk);\r\nval = rv770_calculate_memory_refresh_rate(rdev, ulv_pl->sclk);\r\nWREG32_P(MC_ARB_RFSH_RATE, POWERMODE0(val), ~POWERMODE0_MASK);\r\nval = cypress_calculate_burst_time(rdev, ulv_pl->sclk, ulv_pl->mclk);\r\nWREG32_P(MC_ARB_BURST_TIME, STATE0(val), ~STATE0_MASK);\r\nreturn 0;\r\n}\r\nstatic int btc_enable_ulv(struct radeon_device *rdev)\r\n{\r\nif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_EnableULV) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int btc_set_power_state_conditionally_enable_ulv(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state)\r\n{\r\nint ret = 0;\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nif (eg_pi->ulv.supported) {\r\nif (btc_is_state_ulv_compatible(rdev, radeon_new_state)) {\r\nret = btc_set_ulv_dram_timing(rdev);\r\nif (ret == 0)\r\nret = btc_enable_ulv(rdev);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic bool btc_check_s0_mc_reg_index(u16 in_reg, u16 *out_reg)\r\n{\r\nbool result = true;\r\nswitch (in_reg) {\r\ncase MC_SEQ_RAS_TIMING >> 2:\r\n*out_reg = MC_SEQ_RAS_TIMING_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_CAS_TIMING >> 2:\r\n*out_reg = MC_SEQ_CAS_TIMING_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_MISC_TIMING >> 2:\r\n*out_reg = MC_SEQ_MISC_TIMING_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_MISC_TIMING2 >> 2:\r\n*out_reg = MC_SEQ_MISC_TIMING2_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_RD_CTL_D0 >> 2:\r\n*out_reg = MC_SEQ_RD_CTL_D0_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_RD_CTL_D1 >> 2:\r\n*out_reg = MC_SEQ_RD_CTL_D1_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_WR_CTL_D0 >> 2:\r\n*out_reg = MC_SEQ_WR_CTL_D0_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_WR_CTL_D1 >> 2:\r\n*out_reg = MC_SEQ_WR_CTL_D1_LP >> 2;\r\nbreak;\r\ncase MC_PMG_CMD_EMRS >> 2:\r\n*out_reg = MC_SEQ_PMG_CMD_EMRS_LP >> 2;\r\nbreak;\r\ncase MC_PMG_CMD_MRS >> 2:\r\n*out_reg = MC_SEQ_PMG_CMD_MRS_LP >> 2;\r\nbreak;\r\ncase MC_PMG_CMD_MRS1 >> 2:\r\n*out_reg = MC_SEQ_PMG_CMD_MRS1_LP >> 2;\r\nbreak;\r\ndefault:\r\nresult = false;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic void btc_set_valid_flag(struct evergreen_mc_reg_table *table)\r\n{\r\nu8 i, j;\r\nfor (i = 0; i < table->last; i++) {\r\nfor (j = 1; j < table->num_entries; j++) {\r\nif (table->mc_reg_table_entry[j-1].mc_data[i] !=\r\ntable->mc_reg_table_entry[j].mc_data[i]) {\r\ntable->valid_flag |= (1 << i);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic int btc_set_mc_special_registers(struct radeon_device *rdev,\r\nstruct evergreen_mc_reg_table *table)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu8 i, j, k;\r\nu32 tmp;\r\nfor (i = 0, j = table->last; i < table->last; i++) {\r\nswitch (table->mc_reg_address[i].s1) {\r\ncase MC_SEQ_MISC1 >> 2:\r\ntmp = RREG32(MC_PMG_CMD_EMRS);\r\ntable->mc_reg_address[j].s1 = MC_PMG_CMD_EMRS >> 2;\r\ntable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_EMRS_LP >> 2;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n((tmp & 0xffff0000)) |\r\n((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);\r\n}\r\nj++;\r\nif (j >= SMC_EVERGREEN_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\ntmp = RREG32(MC_PMG_CMD_MRS);\r\ntable->mc_reg_address[j].s1 = MC_PMG_CMD_MRS >> 2;\r\ntable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS_LP >> 2;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(tmp & 0xffff0000) |\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\r\nif (!pi->mem_gddr5)\r\ntable->mc_reg_table_entry[k].mc_data[j] |= 0x100;\r\n}\r\nj++;\r\nif (j >= SMC_EVERGREEN_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nbreak;\r\ncase MC_SEQ_RESERVE_M >> 2:\r\ntmp = RREG32(MC_PMG_CMD_MRS1);\r\ntable->mc_reg_address[j].s1 = MC_PMG_CMD_MRS1 >> 2;\r\ntable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS1_LP >> 2;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(tmp & 0xffff0000) |\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\r\n}\r\nj++;\r\nif (j >= SMC_EVERGREEN_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ntable->last = j;\r\nreturn 0;\r\n}\r\nstatic void btc_set_s0_mc_reg_index(struct evergreen_mc_reg_table *table)\r\n{\r\nu32 i;\r\nu16 address;\r\nfor (i = 0; i < table->last; i++) {\r\ntable->mc_reg_address[i].s0 =\r\nbtc_check_s0_mc_reg_index(table->mc_reg_address[i].s1, &address) ?\r\naddress : table->mc_reg_address[i].s1;\r\n}\r\n}\r\nstatic int btc_copy_vbios_mc_reg_table(struct atom_mc_reg_table *table,\r\nstruct evergreen_mc_reg_table *eg_table)\r\n{\r\nu8 i, j;\r\nif (table->last > SMC_EVERGREEN_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nif (table->num_entries > MAX_AC_TIMING_ENTRIES)\r\nreturn -EINVAL;\r\nfor (i = 0; i < table->last; i++)\r\neg_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;\r\neg_table->last = table->last;\r\nfor (i = 0; i < table->num_entries; i++) {\r\neg_table->mc_reg_table_entry[i].mclk_max =\r\ntable->mc_reg_table_entry[i].mclk_max;\r\nfor(j = 0; j < table->last; j++)\r\neg_table->mc_reg_table_entry[i].mc_data[j] =\r\ntable->mc_reg_table_entry[i].mc_data[j];\r\n}\r\neg_table->num_entries = table->num_entries;\r\nreturn 0;\r\n}\r\nstatic int btc_initialize_mc_reg_table(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nstruct atom_mc_reg_table *table;\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct evergreen_mc_reg_table *eg_table = &eg_pi->mc_reg_table;\r\nu8 module_index = rv770_get_memory_module_index(rdev);\r\ntable = kzalloc(sizeof(struct atom_mc_reg_table), GFP_KERNEL);\r\nif (!table)\r\nreturn -ENOMEM;\r\nWREG32(MC_SEQ_RAS_TIMING_LP, RREG32(MC_SEQ_RAS_TIMING));\r\nWREG32(MC_SEQ_CAS_TIMING_LP, RREG32(MC_SEQ_CAS_TIMING));\r\nWREG32(MC_SEQ_MISC_TIMING_LP, RREG32(MC_SEQ_MISC_TIMING));\r\nWREG32(MC_SEQ_MISC_TIMING2_LP, RREG32(MC_SEQ_MISC_TIMING2));\r\nWREG32(MC_SEQ_RD_CTL_D0_LP, RREG32(MC_SEQ_RD_CTL_D0));\r\nWREG32(MC_SEQ_RD_CTL_D1_LP, RREG32(MC_SEQ_RD_CTL_D1));\r\nWREG32(MC_SEQ_WR_CTL_D0_LP, RREG32(MC_SEQ_WR_CTL_D0));\r\nWREG32(MC_SEQ_WR_CTL_D1_LP, RREG32(MC_SEQ_WR_CTL_D1));\r\nWREG32(MC_SEQ_PMG_CMD_EMRS_LP, RREG32(MC_PMG_CMD_EMRS));\r\nWREG32(MC_SEQ_PMG_CMD_MRS_LP, RREG32(MC_PMG_CMD_MRS));\r\nWREG32(MC_SEQ_PMG_CMD_MRS1_LP, RREG32(MC_PMG_CMD_MRS1));\r\nret = radeon_atom_init_mc_reg_table(rdev, module_index, table);\r\nif (ret)\r\ngoto init_mc_done;\r\nret = btc_copy_vbios_mc_reg_table(table, eg_table);\r\nif (ret)\r\ngoto init_mc_done;\r\nbtc_set_s0_mc_reg_index(eg_table);\r\nret = btc_set_mc_special_registers(rdev, eg_table);\r\nif (ret)\r\ngoto init_mc_done;\r\nbtc_set_valid_flag(eg_table);\r\ninit_mc_done:\r\nkfree(table);\r\nreturn ret;\r\n}\r\nstatic void btc_init_stutter_mode(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 tmp;\r\nif (pi->mclk_stutter_mode_threshold) {\r\nif (pi->mem_gddr5) {\r\ntmp = RREG32(MC_PMG_AUTO_CFG);\r\nif ((0x200 & tmp) == 0) {\r\ntmp = (tmp & 0xfffffc0b) | 0x204;\r\nWREG32(MC_PMG_AUTO_CFG, tmp);\r\n}\r\n}\r\n}\r\n}\r\nbool btc_dpm_vblank_too_short(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 vblank_time = r600_dpm_get_vblank_time(rdev);\r\nu32 switch_limit = pi->mem_gddr5 ? 450 : 100;\r\nif (vblank_time < switch_limit)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void btc_apply_state_adjust_rules(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct rv7xx_ps *ps = rv770_get_ps(rps);\r\nstruct radeon_clock_and_voltage_limits *max_limits;\r\nbool disable_mclk_switching;\r\nu32 mclk, sclk;\r\nu16 vddc, vddci;\r\nu32 max_sclk_vddc, max_mclk_vddci, max_mclk_vddc;\r\nif ((rdev->pm.dpm.new_active_crtc_count > 1) ||\r\nbtc_dpm_vblank_too_short(rdev))\r\ndisable_mclk_switching = true;\r\nelse\r\ndisable_mclk_switching = false;\r\nif (rdev->pm.dpm.ac_power)\r\nmax_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\nelse\r\nmax_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc;\r\nif (rdev->pm.dpm.ac_power == false) {\r\nif (ps->high.mclk > max_limits->mclk)\r\nps->high.mclk = max_limits->mclk;\r\nif (ps->high.sclk > max_limits->sclk)\r\nps->high.sclk = max_limits->sclk;\r\nif (ps->high.vddc > max_limits->vddc)\r\nps->high.vddc = max_limits->vddc;\r\nif (ps->high.vddci > max_limits->vddci)\r\nps->high.vddci = max_limits->vddci;\r\nif (ps->medium.mclk > max_limits->mclk)\r\nps->medium.mclk = max_limits->mclk;\r\nif (ps->medium.sclk > max_limits->sclk)\r\nps->medium.sclk = max_limits->sclk;\r\nif (ps->medium.vddc > max_limits->vddc)\r\nps->medium.vddc = max_limits->vddc;\r\nif (ps->medium.vddci > max_limits->vddci)\r\nps->medium.vddci = max_limits->vddci;\r\nif (ps->low.mclk > max_limits->mclk)\r\nps->low.mclk = max_limits->mclk;\r\nif (ps->low.sclk > max_limits->sclk)\r\nps->low.sclk = max_limits->sclk;\r\nif (ps->low.vddc > max_limits->vddc)\r\nps->low.vddc = max_limits->vddc;\r\nif (ps->low.vddci > max_limits->vddci)\r\nps->low.vddci = max_limits->vddci;\r\n}\r\nbtc_get_max_clock_from_voltage_dependency_table(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\r\n&max_sclk_vddc);\r\nbtc_get_max_clock_from_voltage_dependency_table(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\r\n&max_mclk_vddci);\r\nbtc_get_max_clock_from_voltage_dependency_table(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\r\n&max_mclk_vddc);\r\nif (max_sclk_vddc) {\r\nif (ps->low.sclk > max_sclk_vddc)\r\nps->low.sclk = max_sclk_vddc;\r\nif (ps->medium.sclk > max_sclk_vddc)\r\nps->medium.sclk = max_sclk_vddc;\r\nif (ps->high.sclk > max_sclk_vddc)\r\nps->high.sclk = max_sclk_vddc;\r\n}\r\nif (max_mclk_vddci) {\r\nif (ps->low.mclk > max_mclk_vddci)\r\nps->low.mclk = max_mclk_vddci;\r\nif (ps->medium.mclk > max_mclk_vddci)\r\nps->medium.mclk = max_mclk_vddci;\r\nif (ps->high.mclk > max_mclk_vddci)\r\nps->high.mclk = max_mclk_vddci;\r\n}\r\nif (max_mclk_vddc) {\r\nif (ps->low.mclk > max_mclk_vddc)\r\nps->low.mclk = max_mclk_vddc;\r\nif (ps->medium.mclk > max_mclk_vddc)\r\nps->medium.mclk = max_mclk_vddc;\r\nif (ps->high.mclk > max_mclk_vddc)\r\nps->high.mclk = max_mclk_vddc;\r\n}\r\nif (disable_mclk_switching) {\r\nsclk = ps->low.sclk;\r\nmclk = ps->high.mclk;\r\nvddc = ps->low.vddc;\r\nvddci = ps->high.vddci;\r\n} else {\r\nsclk = ps->low.sclk;\r\nmclk = ps->low.mclk;\r\nvddc = ps->low.vddc;\r\nvddci = ps->low.vddci;\r\n}\r\nps->low.sclk = sclk;\r\nps->low.mclk = mclk;\r\nps->low.vddc = vddc;\r\nps->low.vddci = vddci;\r\nbtc_skip_blacklist_clocks(rdev, max_limits->sclk, max_limits->mclk,\r\n&ps->low.sclk, &ps->low.mclk);\r\nif (ps->medium.sclk < ps->low.sclk)\r\nps->medium.sclk = ps->low.sclk;\r\nif (ps->medium.vddc < ps->low.vddc)\r\nps->medium.vddc = ps->low.vddc;\r\nif (ps->high.sclk < ps->medium.sclk)\r\nps->high.sclk = ps->medium.sclk;\r\nif (ps->high.vddc < ps->medium.vddc)\r\nps->high.vddc = ps->medium.vddc;\r\nif (disable_mclk_switching) {\r\nmclk = ps->low.mclk;\r\nif (mclk < ps->medium.mclk)\r\nmclk = ps->medium.mclk;\r\nif (mclk < ps->high.mclk)\r\nmclk = ps->high.mclk;\r\nps->low.mclk = mclk;\r\nps->low.vddci = vddci;\r\nps->medium.mclk = mclk;\r\nps->medium.vddci = vddci;\r\nps->high.mclk = mclk;\r\nps->high.vddci = vddci;\r\n} else {\r\nif (ps->medium.mclk < ps->low.mclk)\r\nps->medium.mclk = ps->low.mclk;\r\nif (ps->medium.vddci < ps->low.vddci)\r\nps->medium.vddci = ps->low.vddci;\r\nif (ps->high.mclk < ps->medium.mclk)\r\nps->high.mclk = ps->medium.mclk;\r\nif (ps->high.vddci < ps->medium.vddci)\r\nps->high.vddci = ps->medium.vddci;\r\n}\r\nbtc_skip_blacklist_clocks(rdev, max_limits->sclk, max_limits->mclk,\r\n&ps->medium.sclk, &ps->medium.mclk);\r\nbtc_skip_blacklist_clocks(rdev, max_limits->sclk, max_limits->mclk,\r\n&ps->high.sclk, &ps->high.mclk);\r\nbtc_adjust_clock_combinations(rdev, max_limits, &ps->low);\r\nbtc_adjust_clock_combinations(rdev, max_limits, &ps->medium);\r\nbtc_adjust_clock_combinations(rdev, max_limits, &ps->high);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\r\nps->low.sclk, max_limits->vddc, &ps->low.vddc);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\r\nps->low.mclk, max_limits->vddci, &ps->low.vddci);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\r\nps->low.mclk, max_limits->vddc, &ps->low.vddc);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk,\r\nrdev->clock.current_dispclk, max_limits->vddc, &ps->low.vddc);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\r\nps->medium.sclk, max_limits->vddc, &ps->medium.vddc);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\r\nps->medium.mclk, max_limits->vddci, &ps->medium.vddci);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\r\nps->medium.mclk, max_limits->vddc, &ps->medium.vddc);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk,\r\nrdev->clock.current_dispclk, max_limits->vddc, &ps->medium.vddc);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\r\nps->high.sclk, max_limits->vddc, &ps->high.vddc);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\r\nps->high.mclk, max_limits->vddci, &ps->high.vddci);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\r\nps->high.mclk, max_limits->vddc, &ps->high.vddc);\r\nbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk,\r\nrdev->clock.current_dispclk, max_limits->vddc, &ps->high.vddc);\r\nbtc_apply_voltage_delta_rules(rdev, max_limits->vddc, max_limits->vddci,\r\n&ps->low.vddc, &ps->low.vddci);\r\nbtc_apply_voltage_delta_rules(rdev, max_limits->vddc, max_limits->vddci,\r\n&ps->medium.vddc, &ps->medium.vddci);\r\nbtc_apply_voltage_delta_rules(rdev, max_limits->vddc, max_limits->vddci,\r\n&ps->high.vddc, &ps->high.vddci);\r\nif ((ps->high.vddc <= rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddc) &&\r\n(ps->medium.vddc <= rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddc) &&\r\n(ps->low.vddc <= rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddc))\r\nps->dc_compatible = true;\r\nelse\r\nps->dc_compatible = false;\r\nif (ps->low.vddc < rdev->pm.dpm.dyn_state.min_vddc_for_pcie_gen2)\r\nps->low.flags &= ~ATOM_PPLIB_R600_FLAGS_PCIEGEN2;\r\nif (ps->medium.vddc < rdev->pm.dpm.dyn_state.min_vddc_for_pcie_gen2)\r\nps->medium.flags &= ~ATOM_PPLIB_R600_FLAGS_PCIEGEN2;\r\nif (ps->high.vddc < rdev->pm.dpm.dyn_state.min_vddc_for_pcie_gen2)\r\nps->high.flags &= ~ATOM_PPLIB_R600_FLAGS_PCIEGEN2;\r\n}\r\nstatic void btc_update_current_ps(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct rv7xx_ps *new_ps = rv770_get_ps(rps);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\neg_pi->current_rps = *rps;\r\neg_pi->current_ps = *new_ps;\r\neg_pi->current_rps.ps_priv = &eg_pi->current_ps;\r\n}\r\nstatic void btc_update_requested_ps(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct rv7xx_ps *new_ps = rv770_get_ps(rps);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\neg_pi->requested_rps = *rps;\r\neg_pi->requested_ps = *new_ps;\r\neg_pi->requested_rps.ps_priv = &eg_pi->requested_ps;\r\n}\r\nvoid btc_dpm_reset_asic(struct radeon_device *rdev)\r\n{\r\nrv770_restrict_performance_levels_before_switch(rdev);\r\nbtc_disable_ulv(rdev);\r\nbtc_set_boot_state_timing(rdev);\r\nrv770_set_boot_state(rdev);\r\n}\r\nint btc_dpm_pre_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;\r\nstruct radeon_ps *new_ps = &requested_ps;\r\nbtc_update_requested_ps(rdev, new_ps);\r\nbtc_apply_state_adjust_rules(rdev, &eg_pi->requested_rps);\r\nreturn 0;\r\n}\r\nint btc_dpm_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct radeon_ps *new_ps = &eg_pi->requested_rps;\r\nstruct radeon_ps *old_ps = &eg_pi->current_rps;\r\nint ret;\r\nret = btc_disable_ulv(rdev);\r\nbtc_set_boot_state_timing(rdev);\r\nret = rv770_restrict_performance_levels_before_switch(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_restrict_performance_levels_before_switch failed\n");\r\nreturn ret;\r\n}\r\nif (eg_pi->pcie_performance_request)\r\ncypress_notify_link_speed_change_before_state_change(rdev, new_ps, old_ps);\r\nrv770_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\r\nret = rv770_halt_smc(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_halt_smc failed\n");\r\nreturn ret;\r\n}\r\nbtc_set_at_for_uvd(rdev, new_ps);\r\nif (eg_pi->smu_uvd_hs)\r\nbtc_notify_uvd_to_smc(rdev, new_ps);\r\nret = cypress_upload_sw_state(rdev, new_ps);\r\nif (ret) {\r\nDRM_ERROR("cypress_upload_sw_state failed\n");\r\nreturn ret;\r\n}\r\nif (eg_pi->dynamic_ac_timing) {\r\nret = cypress_upload_mc_reg_table(rdev, new_ps);\r\nif (ret) {\r\nDRM_ERROR("cypress_upload_mc_reg_table failed\n");\r\nreturn ret;\r\n}\r\n}\r\ncypress_program_memory_timing_parameters(rdev, new_ps);\r\nret = rv770_resume_smc(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_resume_smc failed\n");\r\nreturn ret;\r\n}\r\nret = rv770_set_sw_state(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_set_sw_state failed\n");\r\nreturn ret;\r\n}\r\nrv770_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\r\nif (eg_pi->pcie_performance_request)\r\ncypress_notify_link_speed_change_after_state_change(rdev, new_ps, old_ps);\r\nret = btc_set_power_state_conditionally_enable_ulv(rdev, new_ps);\r\nif (ret) {\r\nDRM_ERROR("btc_set_power_state_conditionally_enable_ulv failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid btc_dpm_post_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct radeon_ps *new_ps = &eg_pi->requested_rps;\r\nbtc_update_current_ps(rdev, new_ps);\r\n}\r\nint btc_dpm_enable(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\r\nint ret;\r\nif (pi->gfx_clock_gating)\r\nbtc_cg_clock_gating_default(rdev);\r\nif (btc_dpm_enabled(rdev))\r\nreturn -EINVAL;\r\nif (pi->mg_clock_gating)\r\nbtc_mg_clock_gating_default(rdev);\r\nif (eg_pi->ls_clock_gating)\r\nbtc_ls_clock_gating_default(rdev);\r\nif (pi->voltage_control) {\r\nrv770_enable_voltage_control(rdev, true);\r\nret = cypress_construct_voltage_tables(rdev);\r\nif (ret) {\r\nDRM_ERROR("cypress_construct_voltage_tables failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (pi->mvdd_control) {\r\nret = cypress_get_mvdd_configuration(rdev);\r\nif (ret) {\r\nDRM_ERROR("cypress_get_mvdd_configuration failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (eg_pi->dynamic_ac_timing) {\r\nret = btc_initialize_mc_reg_table(rdev);\r\nif (ret)\r\neg_pi->dynamic_ac_timing = false;\r\n}\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\r\nrv770_enable_backbias(rdev, true);\r\nif (pi->dynamic_ss)\r\ncypress_enable_spread_spectrum(rdev, true);\r\nif (pi->thermal_protection)\r\nrv770_enable_thermal_protection(rdev, true);\r\nrv770_setup_bsp(rdev);\r\nrv770_program_git(rdev);\r\nrv770_program_tp(rdev);\r\nrv770_program_tpp(rdev);\r\nrv770_program_sstp(rdev);\r\nrv770_program_engine_speed_parameters(rdev);\r\ncypress_enable_display_gap(rdev);\r\nrv770_program_vc(rdev);\r\nif (pi->dynamic_pcie_gen2)\r\nbtc_enable_dynamic_pcie_gen2(rdev, true);\r\nret = rv770_upload_firmware(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_upload_firmware failed\n");\r\nreturn ret;\r\n}\r\nret = cypress_get_table_locations(rdev);\r\nif (ret) {\r\nDRM_ERROR("cypress_get_table_locations failed\n");\r\nreturn ret;\r\n}\r\nret = btc_init_smc_table(rdev, boot_ps);\r\nif (ret)\r\nreturn ret;\r\nif (eg_pi->dynamic_ac_timing) {\r\nret = cypress_populate_mc_reg_table(rdev, boot_ps);\r\nif (ret) {\r\nDRM_ERROR("cypress_populate_mc_reg_table failed\n");\r\nreturn ret;\r\n}\r\n}\r\ncypress_program_response_times(rdev);\r\nr7xx_start_smc(rdev);\r\nret = cypress_notify_smc_display_change(rdev, false);\r\nif (ret) {\r\nDRM_ERROR("cypress_notify_smc_display_change failed\n");\r\nreturn ret;\r\n}\r\ncypress_enable_sclk_control(rdev, true);\r\nif (eg_pi->memory_transition)\r\ncypress_enable_mclk_control(rdev, true);\r\ncypress_start_dpm(rdev);\r\nif (pi->gfx_clock_gating)\r\nbtc_cg_clock_gating_enable(rdev, true);\r\nif (pi->mg_clock_gating)\r\nbtc_mg_clock_gating_enable(rdev, true);\r\nif (eg_pi->ls_clock_gating)\r\nbtc_ls_clock_gating_enable(rdev, true);\r\nrv770_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\r\nbtc_init_stutter_mode(rdev);\r\nbtc_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\r\nreturn 0;\r\n}\r\nvoid btc_dpm_disable(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nif (!btc_dpm_enabled(rdev))\r\nreturn;\r\nrv770_clear_vc(rdev);\r\nif (pi->thermal_protection)\r\nrv770_enable_thermal_protection(rdev, false);\r\nif (pi->dynamic_pcie_gen2)\r\nbtc_enable_dynamic_pcie_gen2(rdev, false);\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nrdev->irq.dpm_thermal = false;\r\nradeon_irq_set(rdev);\r\n}\r\nif (pi->gfx_clock_gating)\r\nbtc_cg_clock_gating_enable(rdev, false);\r\nif (pi->mg_clock_gating)\r\nbtc_mg_clock_gating_enable(rdev, false);\r\nif (eg_pi->ls_clock_gating)\r\nbtc_ls_clock_gating_enable(rdev, false);\r\nrv770_stop_dpm(rdev);\r\nbtc_reset_to_default(rdev);\r\nbtc_stop_smc(rdev);\r\ncypress_enable_spread_spectrum(rdev, false);\r\nbtc_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\r\n}\r\nvoid btc_dpm_setup_asic(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nint r;\r\nr = ni_mc_load_microcode(rdev);\r\nif (r)\r\nDRM_ERROR("Failed to load MC firmware!\n");\r\nrv770_get_memory_type(rdev);\r\nrv740_read_clock_registers(rdev);\r\nbtc_read_arb_registers(rdev);\r\nrv770_read_voltage_smio_registers(rdev);\r\nif (eg_pi->pcie_performance_request)\r\ncypress_advertise_gen2_capability(rdev);\r\nrv770_get_pcie_gen2_status(rdev);\r\nrv770_enable_acpi_pm(rdev);\r\n}\r\nint btc_dpm_init(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi;\r\nstruct evergreen_power_info *eg_pi;\r\nstruct atom_clock_dividers dividers;\r\nint ret;\r\neg_pi = kzalloc(sizeof(struct evergreen_power_info), GFP_KERNEL);\r\nif (eg_pi == NULL)\r\nreturn -ENOMEM;\r\nrdev->pm.dpm.priv = eg_pi;\r\npi = &eg_pi->rv7xx;\r\nrv770_get_max_vddc(rdev);\r\neg_pi->ulv.supported = false;\r\npi->acpi_vddc = 0;\r\neg_pi->acpi_vddci = 0;\r\npi->min_vddc_in_table = 0;\r\npi->max_vddc_in_table = 0;\r\nret = r600_get_platform_caps(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = rv7xx_parse_power_table(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = r600_parse_extended_power_table(rdev);\r\nif (ret)\r\nreturn ret;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =\r\nkzalloc(4 * sizeof(struct radeon_clock_voltage_dependency_entry), GFP_KERNEL);\r\nif (!rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {\r\nr600_free_extended_power_table(rdev);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.count = 4;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].clk = 0;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].v = 0;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].clk = 36000;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].v = 800;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].clk = 54000;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].v = 800;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].clk = 72000;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].v = 800;\r\nif (rdev->pm.dpm.voltage_response_time == 0)\r\nrdev->pm.dpm.voltage_response_time = R600_VOLTAGERESPONSETIME_DFLT;\r\nif (rdev->pm.dpm.backbias_response_time == 0)\r\nrdev->pm.dpm.backbias_response_time = R600_BACKBIASRESPONSETIME_DFLT;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\n0, false, &dividers);\r\nif (ret)\r\npi->ref_div = dividers.ref_div + 1;\r\nelse\r\npi->ref_div = R600_REFERENCEDIVIDER_DFLT;\r\npi->mclk_strobe_mode_threshold = 40000;\r\npi->mclk_edc_enable_threshold = 40000;\r\neg_pi->mclk_edc_wr_enable_threshold = 40000;\r\npi->rlp = RV770_RLP_DFLT;\r\npi->rmp = RV770_RMP_DFLT;\r\npi->lhp = RV770_LHP_DFLT;\r\npi->lmp = RV770_LMP_DFLT;\r\neg_pi->ats[0].rlp = RV770_RLP_DFLT;\r\neg_pi->ats[0].rmp = RV770_RMP_DFLT;\r\neg_pi->ats[0].lhp = RV770_LHP_DFLT;\r\neg_pi->ats[0].lmp = RV770_LMP_DFLT;\r\neg_pi->ats[1].rlp = BTC_RLP_UVD_DFLT;\r\neg_pi->ats[1].rmp = BTC_RMP_UVD_DFLT;\r\neg_pi->ats[1].lhp = BTC_LHP_UVD_DFLT;\r\neg_pi->ats[1].lmp = BTC_LMP_UVD_DFLT;\r\neg_pi->smu_uvd_hs = true;\r\npi->voltage_control =\r\nradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0);\r\npi->mvdd_control =\r\nradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_MVDDC, 0);\r\neg_pi->vddci_control =\r\nradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDCI, 0);\r\nrv770_get_engine_memory_ss(rdev);\r\npi->asi = RV770_ASI_DFLT;\r\npi->pasi = CYPRESS_HASI_DFLT;\r\npi->vrc = CYPRESS_VRC_DFLT;\r\npi->power_gating = false;\r\npi->gfx_clock_gating = true;\r\npi->mg_clock_gating = true;\r\npi->mgcgtssm = true;\r\neg_pi->ls_clock_gating = false;\r\neg_pi->sclk_deep_sleep = false;\r\npi->dynamic_pcie_gen2 = true;\r\nif (rdev->pm.int_thermal_type != THERMAL_TYPE_NONE)\r\npi->thermal_protection = true;\r\nelse\r\npi->thermal_protection = false;\r\npi->display_gap = true;\r\nif (rdev->flags & RADEON_IS_MOBILITY)\r\npi->dcodt = true;\r\nelse\r\npi->dcodt = false;\r\npi->ulps = true;\r\neg_pi->dynamic_ac_timing = true;\r\neg_pi->abm = true;\r\neg_pi->mcls = true;\r\neg_pi->light_sleep = true;\r\neg_pi->memory_transition = true;\r\n#if defined(CONFIG_ACPI)\r\neg_pi->pcie_performance_request =\r\nradeon_acpi_is_pcie_performance_request_supported(rdev);\r\n#else\r\neg_pi->pcie_performance_request = false;\r\n#endif\r\nif (rdev->family == CHIP_BARTS)\r\neg_pi->dll_default_on = true;\r\nelse\r\neg_pi->dll_default_on = false;\r\neg_pi->sclk_deep_sleep = false;\r\nif (ASIC_IS_LOMBOK(rdev))\r\npi->mclk_stutter_mode_threshold = 30000;\r\nelse\r\npi->mclk_stutter_mode_threshold = 0;\r\npi->sram_end = SMC_RAM_END;\r\nrdev->pm.dpm.dyn_state.mclk_sclk_ratio = 4;\r\nrdev->pm.dpm.dyn_state.vddc_vddci_delta = 200;\r\nrdev->pm.dpm.dyn_state.min_vddc_for_pcie_gen2 = 900;\r\nrdev->pm.dpm.dyn_state.valid_sclk_values.count = ARRAY_SIZE(btc_valid_sclk);\r\nrdev->pm.dpm.dyn_state.valid_sclk_values.values = btc_valid_sclk;\r\nrdev->pm.dpm.dyn_state.valid_mclk_values.count = 0;\r\nrdev->pm.dpm.dyn_state.valid_mclk_values.values = NULL;\r\nif (rdev->family == CHIP_TURKS)\r\nrdev->pm.dpm.dyn_state.sclk_mclk_delta = 15000;\r\nelse\r\nrdev->pm.dpm.dyn_state.sclk_mclk_delta = 10000;\r\nif ((rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.sclk == 0) ||\r\n(rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.mclk == 0))\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_dc =\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\nreturn 0;\r\n}\r\nvoid btc_dpm_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\r\nkfree(rdev->pm.dpm.ps[i].ps_priv);\r\n}\r\nkfree(rdev->pm.dpm.ps);\r\nkfree(rdev->pm.dpm.priv);\r\nkfree(rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries);\r\nr600_free_extended_power_table(rdev);\r\n}\r\nvoid btc_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\r\nstruct seq_file *m)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct radeon_ps *rps = &eg_pi->current_rps;\r\nstruct rv7xx_ps *ps = rv770_get_ps(rps);\r\nstruct rv7xx_pl *pl;\r\nu32 current_index =\r\n(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\r\nCURRENT_PROFILE_INDEX_SHIFT;\r\nif (current_index > 2) {\r\nseq_printf(m, "invalid dpm profile %d\n", current_index);\r\n} else {\r\nif (current_index == 0)\r\npl = &ps->low;\r\nelse if (current_index == 1)\r\npl = &ps->medium;\r\nelse\r\npl = &ps->high;\r\nseq_printf(m, "uvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nif (rdev->family >= CHIP_CEDAR) {\r\nseq_printf(m, "power level %d sclk: %u mclk: %u vddc: %u vddci: %u\n",\r\ncurrent_index, pl->sclk, pl->mclk, pl->vddc, pl->vddci);\r\n} else {\r\nseq_printf(m, "power level %d sclk: %u mclk: %u vddc: %u\n",\r\ncurrent_index, pl->sclk, pl->mclk, pl->vddc);\r\n}\r\n}\r\n}\r\nu32 btc_dpm_get_sclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct rv7xx_ps *requested_state = rv770_get_ps(&eg_pi->requested_rps);\r\nif (low)\r\nreturn requested_state->low.sclk;\r\nelse\r\nreturn requested_state->high.sclk;\r\n}\r\nu32 btc_dpm_get_mclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct rv7xx_ps *requested_state = rv770_get_ps(&eg_pi->requested_rps);\r\nif (low)\r\nreturn requested_state->low.mclk;\r\nelse\r\nreturn requested_state->high.mclk;\r\n}
