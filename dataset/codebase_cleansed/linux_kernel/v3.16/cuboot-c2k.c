static void c2k_bridge_setup(u32 mem_size)\r\n{\r\nu32 i, v[30], enables, acc_bits;\r\nu32 pci_base_hi, pci_base_lo, size, buf[2];\r\nunsigned long cpu_base;\r\nint rc;\r\nvoid *devp, *mv64x60_devp;\r\nu8 *bridge_pbase, is_coherent;\r\nstruct mv64x60_cpu2pci_win *tbl;\r\nint bus;\r\nbridge_pbase = mv64x60_get_bridge_pbase();\r\nis_coherent = mv64x60_is_coherent();\r\nif (is_coherent)\r\nacc_bits = MV64x60_PCI_ACC_CNTL_SNOOP_WB\r\n| MV64x60_PCI_ACC_CNTL_SWAP_NONE\r\n| MV64x60_PCI_ACC_CNTL_MBURST_32_BYTES\r\n| MV64x60_PCI_ACC_CNTL_RDSIZE_32_BYTES;\r\nelse\r\nacc_bits = MV64x60_PCI_ACC_CNTL_SNOOP_NONE\r\n| MV64x60_PCI_ACC_CNTL_SWAP_NONE\r\n| MV64x60_PCI_ACC_CNTL_MBURST_128_BYTES\r\n| MV64x60_PCI_ACC_CNTL_RDSIZE_256_BYTES;\r\nmv64x60_config_ctlr_windows(bridge_base, bridge_pbase, is_coherent);\r\nmv64x60_devp = find_node_by_compatible(NULL, "marvell,mv64360");\r\nif (mv64x60_devp == NULL)\r\nfatal("Error: Missing marvell,mv64360 device tree node\n\r");\r\nenables = in_le32((u32 *)(bridge_base + MV64x60_CPU_BAR_ENABLE));\r\nenables |= 0x007ffe00;\r\nout_le32((u32 *)(bridge_base + MV64x60_CPU_BAR_ENABLE), enables);\r\ndevp = NULL;\r\nfor (bus = 0; ; bus++) {\r\nchar name[] = "pci ";\r\nname[strlen(name)-1] = bus+'0';\r\ndevp = find_node_by_alias(name);\r\nif (devp == NULL)\r\nbreak;\r\nif (bus >= 2)\r\nfatal("Error: Only 2 PCI controllers are supported at" \\r\n" this time.\n");\r\nmv64x60_config_pci_windows(bridge_base, bridge_pbase, bus, 0,\r\nmem_size, acc_bits);\r\nrc = getprop(devp, "ranges", v, sizeof(v));\r\nif (rc == 0)\r\nfatal("Error: Can't find marvell,mv64360-pci ranges"\r\n" property\n\r");\r\nfor (i = 0; i < rc; i += 6) {\r\nswitch (v[i] & 0xff000000) {\r\ncase 0x01000000:\r\ntbl = mv64x60_cpu2pci_io;\r\nbreak;\r\ncase 0x02000000:\r\ntbl = mv64x60_cpu2pci_mem;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\npci_base_hi = v[i+1];\r\npci_base_lo = v[i+2];\r\ncpu_base = v[i+3];\r\nsize = v[i+5];\r\nbuf[0] = cpu_base;\r\nbuf[1] = size;\r\nif (!dt_xlate_addr(devp, buf, sizeof(buf), &cpu_base))\r\nfatal("Error: Can't translate PCI address " \\r\n"0x%x\n\r", (u32)cpu_base);\r\nmv64x60_config_cpu2pci_window(bridge_base, bus,\r\npci_base_hi, pci_base_lo, cpu_base, size, tbl);\r\n}\r\nenables &= ~(3<<(9+bus*5));\r\nout_le32((u32 *)(bridge_base + MV64x60_CPU_BAR_ENABLE),\r\nenables);\r\n};\r\n}\r\nstatic void c2k_fixups(void)\r\n{\r\nu32 mem_size;\r\nmem_size = mv64x60_get_mem_size(bridge_base);\r\nc2k_bridge_setup(mem_size);\r\n}\r\nstatic void c2k_reset(void)\r\n{\r\nu32 temp;\r\nudelay(5000000);\r\nif (bridge_base != 0) {\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_MPP_CNTL_0));\r\ntemp &= 0xFFFF0FFF;\r\nout_le32((u32 *)(bridge_base + MV64x60_MPP_CNTL_0), temp);\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_GPP_LEVEL_CNTL));\r\ntemp |= 0x00000004;\r\nout_le32((u32 *)(bridge_base + MV64x60_GPP_LEVEL_CNTL), temp);\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_GPP_IO_CNTL));\r\ntemp |= 0x00000004;\r\nout_le32((u32 *)(bridge_base + MV64x60_GPP_IO_CNTL), temp);\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_MPP_CNTL_2));\r\ntemp &= 0xFFFF0FFF;\r\nout_le32((u32 *)(bridge_base + MV64x60_MPP_CNTL_2), temp);\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_GPP_LEVEL_CNTL));\r\ntemp |= 0x00080000;\r\nout_le32((u32 *)(bridge_base + MV64x60_GPP_LEVEL_CNTL), temp);\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_GPP_IO_CNTL));\r\ntemp |= 0x00080000;\r\nout_le32((u32 *)(bridge_base + MV64x60_GPP_IO_CNTL), temp);\r\nout_le32((u32 *)(bridge_base + MV64x60_GPP_VALUE_SET),\r\n0x00080004);\r\n}\r\nfor (;;);\r\n}\r\nvoid platform_init(unsigned long r3, unsigned long r4, unsigned long r5,\r\nunsigned long r6, unsigned long r7)\r\n{\r\nCUBOOT_INIT();\r\nfdt_init(_dtb_start);\r\nbridge_base = mv64x60_get_bridge_base();\r\nplatform_ops.fixups = c2k_fixups;\r\nplatform_ops.exit = c2k_reset;\r\nif (serial_console_init() < 0)\r\nexit();\r\n}
