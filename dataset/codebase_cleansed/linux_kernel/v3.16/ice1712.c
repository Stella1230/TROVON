static inline int is_spdif_master(struct snd_ice1712 *ice)\r\n{\r\nreturn (inb(ICEMT(ice, RATE)) & ICE1712_SPDIF_MASTER) ? 1 : 0;\r\n}\r\nstatic inline int is_pro_rate_locked(struct snd_ice1712 *ice)\r\n{\r\nreturn is_spdif_master(ice) || PRO_RATE_LOCKED;\r\n}\r\nstatic inline void snd_ice1712_ds_write(struct snd_ice1712 *ice, u8 channel, u8 addr, u32 data)\r\n{\r\noutb((channel << 4) | addr, ICEDS(ice, INDEX));\r\noutl(data, ICEDS(ice, DATA));\r\n}\r\nstatic inline u32 snd_ice1712_ds_read(struct snd_ice1712 *ice, u8 channel, u8 addr)\r\n{\r\noutb((channel << 4) | addr, ICEDS(ice, INDEX));\r\nreturn inl(ICEDS(ice, DATA));\r\n}\r\nstatic void snd_ice1712_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct snd_ice1712 *ice = ac97->private_data;\r\nint tm;\r\nunsigned char old_cmd = 0;\r\nfor (tm = 0; tm < 0x10000; tm++) {\r\nold_cmd = inb(ICEREG(ice, AC97_CMD));\r\nif (old_cmd & (ICE1712_AC97_WRITE | ICE1712_AC97_READ))\r\ncontinue;\r\nif (!(old_cmd & ICE1712_AC97_READY))\r\ncontinue;\r\nbreak;\r\n}\r\noutb(reg, ICEREG(ice, AC97_INDEX));\r\noutw(val, ICEREG(ice, AC97_DATA));\r\nold_cmd &= ~(ICE1712_AC97_PBK_VSR | ICE1712_AC97_CAP_VSR);\r\noutb(old_cmd | ICE1712_AC97_WRITE, ICEREG(ice, AC97_CMD));\r\nfor (tm = 0; tm < 0x10000; tm++)\r\nif ((inb(ICEREG(ice, AC97_CMD)) & ICE1712_AC97_WRITE) == 0)\r\nbreak;\r\n}\r\nstatic unsigned short snd_ice1712_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct snd_ice1712 *ice = ac97->private_data;\r\nint tm;\r\nunsigned char old_cmd = 0;\r\nfor (tm = 0; tm < 0x10000; tm++) {\r\nold_cmd = inb(ICEREG(ice, AC97_CMD));\r\nif (old_cmd & (ICE1712_AC97_WRITE | ICE1712_AC97_READ))\r\ncontinue;\r\nif (!(old_cmd & ICE1712_AC97_READY))\r\ncontinue;\r\nbreak;\r\n}\r\noutb(reg, ICEREG(ice, AC97_INDEX));\r\noutb(old_cmd | ICE1712_AC97_READ, ICEREG(ice, AC97_CMD));\r\nfor (tm = 0; tm < 0x10000; tm++)\r\nif ((inb(ICEREG(ice, AC97_CMD)) & ICE1712_AC97_READ) == 0)\r\nbreak;\r\nif (tm >= 0x10000)\r\nreturn ~0;\r\nreturn inw(ICEREG(ice, AC97_DATA));\r\n}\r\nstatic void snd_ice1712_pro_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct snd_ice1712 *ice = ac97->private_data;\r\nint tm;\r\nunsigned char old_cmd = 0;\r\nfor (tm = 0; tm < 0x10000; tm++) {\r\nold_cmd = inb(ICEMT(ice, AC97_CMD));\r\nif (old_cmd & (ICE1712_AC97_WRITE | ICE1712_AC97_READ))\r\ncontinue;\r\nif (!(old_cmd & ICE1712_AC97_READY))\r\ncontinue;\r\nbreak;\r\n}\r\noutb(reg, ICEMT(ice, AC97_INDEX));\r\noutw(val, ICEMT(ice, AC97_DATA));\r\nold_cmd &= ~(ICE1712_AC97_PBK_VSR | ICE1712_AC97_CAP_VSR);\r\noutb(old_cmd | ICE1712_AC97_WRITE, ICEMT(ice, AC97_CMD));\r\nfor (tm = 0; tm < 0x10000; tm++)\r\nif ((inb(ICEMT(ice, AC97_CMD)) & ICE1712_AC97_WRITE) == 0)\r\nbreak;\r\n}\r\nstatic unsigned short snd_ice1712_pro_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct snd_ice1712 *ice = ac97->private_data;\r\nint tm;\r\nunsigned char old_cmd = 0;\r\nfor (tm = 0; tm < 0x10000; tm++) {\r\nold_cmd = inb(ICEMT(ice, AC97_CMD));\r\nif (old_cmd & (ICE1712_AC97_WRITE | ICE1712_AC97_READ))\r\ncontinue;\r\nif (!(old_cmd & ICE1712_AC97_READY))\r\ncontinue;\r\nbreak;\r\n}\r\noutb(reg, ICEMT(ice, AC97_INDEX));\r\noutb(old_cmd | ICE1712_AC97_READ, ICEMT(ice, AC97_CMD));\r\nfor (tm = 0; tm < 0x10000; tm++)\r\nif ((inb(ICEMT(ice, AC97_CMD)) & ICE1712_AC97_READ) == 0)\r\nbreak;\r\nif (tm >= 0x10000)\r\nreturn ~0;\r\nreturn inw(ICEMT(ice, AC97_DATA));\r\n}\r\nstatic int snd_ice1712_digmix_route_ac97_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = inb(ICEMT(ice, MONITOR_ROUTECTRL)) & ICE1712_ROUTE_AC97 ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_digmix_route_ac97_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned char val, nval;\r\nspin_lock_irq(&ice->reg_lock);\r\nval = inb(ICEMT(ice, MONITOR_ROUTECTRL));\r\nnval = val & ~ICE1712_ROUTE_AC97;\r\nif (ucontrol->value.integer.value[0])\r\nnval |= ICE1712_ROUTE_AC97;\r\noutb(nval, ICEMT(ice, MONITOR_ROUTECTRL));\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn val != nval;\r\n}\r\nstatic void snd_ice1712_set_gpio_dir(struct snd_ice1712 *ice, unsigned int data)\r\n{\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION, data);\r\ninb(ICEREG(ice, DATA));\r\n}\r\nstatic unsigned int snd_ice1712_get_gpio_dir(struct snd_ice1712 *ice)\r\n{\r\nreturn snd_ice1712_read(ice, ICE1712_IREG_GPIO_DIRECTION);\r\n}\r\nstatic unsigned int snd_ice1712_get_gpio_mask(struct snd_ice1712 *ice)\r\n{\r\nreturn snd_ice1712_read(ice, ICE1712_IREG_GPIO_WRITE_MASK);\r\n}\r\nstatic void snd_ice1712_set_gpio_mask(struct snd_ice1712 *ice, unsigned int data)\r\n{\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, data);\r\ninb(ICEREG(ice, DATA));\r\n}\r\nstatic unsigned int snd_ice1712_get_gpio_data(struct snd_ice1712 *ice)\r\n{\r\nreturn snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA);\r\n}\r\nstatic void snd_ice1712_set_gpio_data(struct snd_ice1712 *ice, unsigned int val)\r\n{\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, val);\r\ninb(ICEREG(ice, DATA));\r\n}\r\nstatic int snd_ice1712_cs8427_set_input_clock(struct snd_ice1712 *ice, int spdif_clock)\r\n{\r\nunsigned char reg[2] = { 0x80 | 4, 0 };\r\nunsigned char val, nval;\r\nint res = 0;\r\nsnd_i2c_lock(ice->i2c);\r\nif (snd_i2c_sendbytes(ice->cs8427, reg, 1) != 1) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nif (snd_i2c_readbytes(ice->cs8427, &val, 1) != 1) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nnval = val & 0xf0;\r\nif (spdif_clock)\r\nnval |= 0x01;\r\nelse\r\nnval |= 0x04;\r\nif (val != nval) {\r\nreg[1] = nval;\r\nif (snd_i2c_sendbytes(ice->cs8427, reg, 2) != 2) {\r\nres = -EIO;\r\n} else {\r\nres++;\r\n}\r\n}\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn res;\r\n}\r\nstatic void open_cs8427(struct snd_ice1712 *ice, struct snd_pcm_substream *substream)\r\n{\r\nsnd_cs8427_iec958_active(ice->cs8427, 1);\r\n}\r\nstatic void close_cs8427(struct snd_ice1712 *ice, struct snd_pcm_substream *substream)\r\n{\r\nsnd_cs8427_iec958_active(ice->cs8427, 0);\r\n}\r\nstatic void setup_cs8427(struct snd_ice1712 *ice, int rate)\r\n{\r\nsnd_cs8427_iec958_pcm(ice->cs8427, rate);\r\n}\r\nint snd_ice1712_init_cs8427(struct snd_ice1712 *ice, int addr)\r\n{\r\nint err;\r\nerr = snd_cs8427_create(ice->i2c, addr,\r\n(ice->cs8427_timeout * HZ) / 1000, &ice->cs8427);\r\nif (err < 0) {\r\ndev_err(ice->card->dev, "CS8427 initialization failed\n");\r\nreturn err;\r\n}\r\nice->spdif.ops.open = open_cs8427;\r\nice->spdif.ops.close = close_cs8427;\r\nice->spdif.ops.setup_rate = setup_cs8427;\r\nreturn 0;\r\n}\r\nstatic void snd_ice1712_set_input_clock_source(struct snd_ice1712 *ice, int spdif_is_master)\r\n{\r\nif (ice->cs8427)\r\nsnd_ice1712_cs8427_set_input_clock(ice, spdif_is_master);\r\nif (spdif_is_master) {\r\nunsigned int i;\r\nfor (i = 0; i < ice->akm_codecs; i++) {\r\nif (ice->akm[i].ops.set_rate_val)\r\nice->akm[i].ops.set_rate_val(&ice->akm[i], 0);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t snd_ice1712_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_ice1712 *ice = dev_id;\r\nunsigned char status;\r\nint handled = 0;\r\nwhile (1) {\r\nstatus = inb(ICEREG(ice, IRQSTAT));\r\nif (status == 0)\r\nbreak;\r\nhandled = 1;\r\nif (status & ICE1712_IRQ_MPU1) {\r\nif (ice->rmidi[0])\r\nsnd_mpu401_uart_interrupt(irq, ice->rmidi[0]->private_data);\r\noutb(ICE1712_IRQ_MPU1, ICEREG(ice, IRQSTAT));\r\nstatus &= ~ICE1712_IRQ_MPU1;\r\n}\r\nif (status & ICE1712_IRQ_TIMER)\r\noutb(ICE1712_IRQ_TIMER, ICEREG(ice, IRQSTAT));\r\nif (status & ICE1712_IRQ_MPU2) {\r\nif (ice->rmidi[1])\r\nsnd_mpu401_uart_interrupt(irq, ice->rmidi[1]->private_data);\r\noutb(ICE1712_IRQ_MPU2, ICEREG(ice, IRQSTAT));\r\nstatus &= ~ICE1712_IRQ_MPU2;\r\n}\r\nif (status & ICE1712_IRQ_PROPCM) {\r\nunsigned char mtstat = inb(ICEMT(ice, IRQ));\r\nif (mtstat & ICE1712_MULTI_PBKSTATUS) {\r\nif (ice->playback_pro_substream)\r\nsnd_pcm_period_elapsed(ice->playback_pro_substream);\r\noutb(ICE1712_MULTI_PBKSTATUS, ICEMT(ice, IRQ));\r\n}\r\nif (mtstat & ICE1712_MULTI_CAPSTATUS) {\r\nif (ice->capture_pro_substream)\r\nsnd_pcm_period_elapsed(ice->capture_pro_substream);\r\noutb(ICE1712_MULTI_CAPSTATUS, ICEMT(ice, IRQ));\r\n}\r\n}\r\nif (status & ICE1712_IRQ_FM)\r\noutb(ICE1712_IRQ_FM, ICEREG(ice, IRQSTAT));\r\nif (status & ICE1712_IRQ_PBKDS) {\r\nu32 idx;\r\nu16 pbkstatus;\r\nstruct snd_pcm_substream *substream;\r\npbkstatus = inw(ICEDS(ice, INTSTAT));\r\nfor (idx = 0; idx < 6; idx++) {\r\nif ((pbkstatus & (3 << (idx * 2))) == 0)\r\ncontinue;\r\nsubstream = ice->playback_con_substream_ds[idx];\r\nif (substream != NULL)\r\nsnd_pcm_period_elapsed(substream);\r\noutw(3 << (idx * 2), ICEDS(ice, INTSTAT));\r\n}\r\noutb(ICE1712_IRQ_PBKDS, ICEREG(ice, IRQSTAT));\r\n}\r\nif (status & ICE1712_IRQ_CONCAP) {\r\nif (ice->capture_con_substream)\r\nsnd_pcm_period_elapsed(ice->capture_con_substream);\r\noutb(ICE1712_IRQ_CONCAP, ICEREG(ice, IRQSTAT));\r\n}\r\nif (status & ICE1712_IRQ_CONPBK) {\r\nif (ice->playback_con_substream)\r\nsnd_pcm_period_elapsed(ice->playback_con_substream);\r\noutb(ICE1712_IRQ_CONPBK, ICEREG(ice, IRQSTAT));\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int snd_ice1712_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_ice1712_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_ice1712_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\nu32 tmp;\r\nspin_lock(&ice->reg_lock);\r\ntmp = snd_ice1712_read(ice, ICE1712_IREG_PBK_CTRL);\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\ntmp |= 1;\r\n} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\ntmp &= ~1;\r\n} else if (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH) {\r\ntmp |= 2;\r\n} else if (cmd == SNDRV_PCM_TRIGGER_PAUSE_RELEASE) {\r\ntmp &= ~2;\r\n} else {\r\nresult = -EINVAL;\r\n}\r\nsnd_ice1712_write(ice, ICE1712_IREG_PBK_CTRL, tmp);\r\nspin_unlock(&ice->reg_lock);\r\nreturn result;\r\n}\r\nstatic int snd_ice1712_playback_ds_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\nu32 tmp;\r\nspin_lock(&ice->reg_lock);\r\ntmp = snd_ice1712_ds_read(ice, substream->number * 2, ICE1712_DSC_CONTROL);\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\ntmp |= 1;\r\n} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\ntmp &= ~1;\r\n} else if (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH) {\r\ntmp |= 2;\r\n} else if (cmd == SNDRV_PCM_TRIGGER_PAUSE_RELEASE) {\r\ntmp &= ~2;\r\n} else {\r\nresult = -EINVAL;\r\n}\r\nsnd_ice1712_ds_write(ice, substream->number * 2, ICE1712_DSC_CONTROL, tmp);\r\nspin_unlock(&ice->reg_lock);\r\nreturn result;\r\n}\r\nstatic int snd_ice1712_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\nu8 tmp;\r\nspin_lock(&ice->reg_lock);\r\ntmp = snd_ice1712_read(ice, ICE1712_IREG_CAP_CTRL);\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\ntmp |= 1;\r\n} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\ntmp &= ~1;\r\n} else {\r\nresult = -EINVAL;\r\n}\r\nsnd_ice1712_write(ice, ICE1712_IREG_CAP_CTRL, tmp);\r\nspin_unlock(&ice->reg_lock);\r\nreturn result;\r\n}\r\nstatic int snd_ice1712_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nu32 period_size, buf_size, rate, tmp;\r\nperiod_size = (snd_pcm_lib_period_bytes(substream) >> 2) - 1;\r\nbuf_size = snd_pcm_lib_buffer_bytes(substream) - 1;\r\ntmp = 0x0000;\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\ntmp |= 0x10;\r\nif (runtime->channels == 2)\r\ntmp |= 0x08;\r\nrate = (runtime->rate * 8192) / 375;\r\nif (rate > 0x000fffff)\r\nrate = 0x000fffff;\r\nspin_lock_irq(&ice->reg_lock);\r\noutb(0, ice->ddma_port + 15);\r\noutb(ICE1712_DMA_MODE_WRITE | ICE1712_DMA_AUTOINIT, ice->ddma_port + 0x0b);\r\noutl(runtime->dma_addr, ice->ddma_port + 0);\r\noutw(buf_size, ice->ddma_port + 4);\r\nsnd_ice1712_write(ice, ICE1712_IREG_PBK_RATE_LO, rate & 0xff);\r\nsnd_ice1712_write(ice, ICE1712_IREG_PBK_RATE_MID, (rate >> 8) & 0xff);\r\nsnd_ice1712_write(ice, ICE1712_IREG_PBK_RATE_HI, (rate >> 16) & 0xff);\r\nsnd_ice1712_write(ice, ICE1712_IREG_PBK_CTRL, tmp);\r\nsnd_ice1712_write(ice, ICE1712_IREG_PBK_COUNT_LO, period_size & 0xff);\r\nsnd_ice1712_write(ice, ICE1712_IREG_PBK_COUNT_HI, period_size >> 8);\r\nsnd_ice1712_write(ice, ICE1712_IREG_PBK_LEFT, 0);\r\nsnd_ice1712_write(ice, ICE1712_IREG_PBK_RIGHT, 0);\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_playback_ds_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nu32 period_size, buf_size, rate, tmp, chn;\r\nperiod_size = snd_pcm_lib_period_bytes(substream) - 1;\r\nbuf_size = snd_pcm_lib_buffer_bytes(substream) - 1;\r\ntmp = 0x0064;\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\ntmp &= ~0x04;\r\nif (runtime->channels == 2)\r\ntmp |= 0x08;\r\nrate = (runtime->rate * 8192) / 375;\r\nif (rate > 0x000fffff)\r\nrate = 0x000fffff;\r\nice->playback_con_active_buf[substream->number] = 0;\r\nice->playback_con_virt_addr[substream->number] = runtime->dma_addr;\r\nchn = substream->number * 2;\r\nspin_lock_irq(&ice->reg_lock);\r\nsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_ADDR0, runtime->dma_addr);\r\nsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_COUNT0, period_size);\r\nsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_ADDR1, runtime->dma_addr + (runtime->periods > 1 ? period_size + 1 : 0));\r\nsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_COUNT1, period_size);\r\nsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_RATE, rate);\r\nsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_VOLUME, 0);\r\nsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_CONTROL, tmp);\r\nif (runtime->channels == 2) {\r\nsnd_ice1712_ds_write(ice, chn + 1, ICE1712_DSC_RATE, rate);\r\nsnd_ice1712_ds_write(ice, chn + 1, ICE1712_DSC_VOLUME, 0);\r\n}\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nu32 period_size, buf_size;\r\nu8 tmp;\r\nperiod_size = (snd_pcm_lib_period_bytes(substream) >> 2) - 1;\r\nbuf_size = snd_pcm_lib_buffer_bytes(substream) - 1;\r\ntmp = 0x06;\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\ntmp &= ~0x04;\r\nif (runtime->channels == 2)\r\ntmp &= ~0x02;\r\nspin_lock_irq(&ice->reg_lock);\r\noutl(ice->capture_con_virt_addr = runtime->dma_addr, ICEREG(ice, CONCAP_ADDR));\r\noutw(buf_size, ICEREG(ice, CONCAP_COUNT));\r\nsnd_ice1712_write(ice, ICE1712_IREG_CAP_COUNT_HI, period_size >> 8);\r\nsnd_ice1712_write(ice, ICE1712_IREG_CAP_COUNT_LO, period_size & 0xff);\r\nsnd_ice1712_write(ice, ICE1712_IREG_CAP_CTRL, tmp);\r\nspin_unlock_irq(&ice->reg_lock);\r\nsnd_ac97_set_rate(ice->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_ice1712_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsize_t ptr;\r\nif (!(snd_ice1712_read(ice, ICE1712_IREG_PBK_CTRL) & 1))\r\nreturn 0;\r\nptr = runtime->buffer_size - inw(ice->ddma_port + 4);\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\nif (ptr == runtime->buffer_size)\r\nptr = 0;\r\nreturn ptr;\r\n}\r\nstatic snd_pcm_uframes_t snd_ice1712_playback_ds_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nu8 addr;\r\nsize_t ptr;\r\nif (!(snd_ice1712_ds_read(ice, substream->number * 2, ICE1712_DSC_CONTROL) & 1))\r\nreturn 0;\r\nif (ice->playback_con_active_buf[substream->number])\r\naddr = ICE1712_DSC_ADDR1;\r\nelse\r\naddr = ICE1712_DSC_ADDR0;\r\nptr = snd_ice1712_ds_read(ice, substream->number * 2, addr) -\r\nice->playback_con_virt_addr[substream->number];\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\nif (ptr == substream->runtime->buffer_size)\r\nptr = 0;\r\nreturn ptr;\r\n}\r\nstatic snd_pcm_uframes_t snd_ice1712_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(snd_ice1712_read(ice, ICE1712_IREG_CAP_CTRL) & 1))\r\nreturn 0;\r\nptr = inl(ICEREG(ice, CONCAP_ADDR)) - ice->capture_con_virt_addr;\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\nif (ptr == substream->runtime->buffer_size)\r\nptr = 0;\r\nreturn ptr;\r\n}\r\nstatic int snd_ice1712_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nice->playback_con_substream = substream;\r\nruntime->hw = snd_ice1712_playback;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_playback_ds_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nu32 tmp;\r\nice->playback_con_substream_ds[substream->number] = substream;\r\nruntime->hw = snd_ice1712_playback_ds;\r\nspin_lock_irq(&ice->reg_lock);\r\ntmp = inw(ICEDS(ice, INTMASK)) & ~(1 << (substream->number * 2));\r\noutw(tmp, ICEDS(ice, INTMASK));\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nice->capture_con_substream = substream;\r\nruntime->hw = snd_ice1712_capture;\r\nruntime->hw.rates = ice->ac97->rates[AC97_RATES_ADC];\r\nif (!(runtime->hw.rates & SNDRV_PCM_RATE_8000))\r\nruntime->hw.rate_min = 48000;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nice->playback_con_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_playback_ds_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nu32 tmp;\r\nspin_lock_irq(&ice->reg_lock);\r\ntmp = inw(ICEDS(ice, INTMASK)) | (3 << (substream->number * 2));\r\noutw(tmp, ICEDS(ice, INTMASK));\r\nspin_unlock_irq(&ice->reg_lock);\r\nice->playback_con_substream_ds[substream->number] = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nice->capture_con_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pcm(struct snd_ice1712 *ice, int device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nerr = snd_pcm_new(ice->card, "ICE1712 consumer", device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ice1712_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ice1712_capture_ops);\r\npcm->private_data = ice;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "ICE1712 consumer");\r\nice->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(ice->pci), 64*1024, 64*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\ndev_warn(ice->card->dev,\r\n"Consumer PCM code does not work well at the moment --jk\n");\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pcm_ds(struct snd_ice1712 *ice, int device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nerr = snd_pcm_new(ice->card, "ICE1712 consumer (DS)", device, 6, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ice1712_playback_ds_ops);\r\npcm->private_data = ice;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "ICE1712 consumer (DS)");\r\nice->pcm_ds = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(ice->pci), 64*1024, 128*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\n{\r\nunsigned int what;\r\nunsigned int old;\r\nif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn -EINVAL;\r\nwhat = ICE1712_PLAYBACK_PAUSE;\r\nsnd_pcm_trigger_done(substream, substream);\r\nspin_lock(&ice->reg_lock);\r\nold = inl(ICEMT(ice, PLAYBACK_CONTROL));\r\nif (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)\r\nold |= what;\r\nelse\r\nold &= ~what;\r\noutl(old, ICEMT(ice, PLAYBACK_CONTROL));\r\nspin_unlock(&ice->reg_lock);\r\nbreak;\r\n}\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\n{\r\nunsigned int what = 0;\r\nunsigned int old;\r\nstruct snd_pcm_substream *s;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == ice->playback_pro_substream) {\r\nwhat |= ICE1712_PLAYBACK_START;\r\nsnd_pcm_trigger_done(s, substream);\r\n} else if (s == ice->capture_pro_substream) {\r\nwhat |= ICE1712_CAPTURE_START_SHADOW;\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\n}\r\nspin_lock(&ice->reg_lock);\r\nold = inl(ICEMT(ice, PLAYBACK_CONTROL));\r\nif (cmd == SNDRV_PCM_TRIGGER_START)\r\nold |= what;\r\nelse\r\nold &= ~what;\r\noutl(old, ICEMT(ice, PLAYBACK_CONTROL));\r\nspin_unlock(&ice->reg_lock);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_ice1712_set_pro_rate(struct snd_ice1712 *ice, unsigned int rate, int force)\r\n{\r\nunsigned long flags;\r\nunsigned char val, old;\r\nunsigned int i;\r\nswitch (rate) {\r\ncase 8000: val = 6; break;\r\ncase 9600: val = 3; break;\r\ncase 11025: val = 10; break;\r\ncase 12000: val = 2; break;\r\ncase 16000: val = 5; break;\r\ncase 22050: val = 9; break;\r\ncase 24000: val = 1; break;\r\ncase 32000: val = 4; break;\r\ncase 44100: val = 8; break;\r\ncase 48000: val = 0; break;\r\ncase 64000: val = 15; break;\r\ncase 88200: val = 11; break;\r\ncase 96000: val = 7; break;\r\ndefault:\r\nsnd_BUG();\r\nval = 0;\r\nrate = 48000;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&ice->reg_lock, flags);\r\nif (inb(ICEMT(ice, PLAYBACK_CONTROL)) & (ICE1712_CAPTURE_START_SHADOW|\r\nICE1712_PLAYBACK_PAUSE|\r\nICE1712_PLAYBACK_START)) {\r\n__out:\r\nspin_unlock_irqrestore(&ice->reg_lock, flags);\r\nreturn;\r\n}\r\nif (!force && is_pro_rate_locked(ice))\r\ngoto __out;\r\nold = inb(ICEMT(ice, RATE));\r\nif (!force && old == val)\r\ngoto __out;\r\nice->cur_rate = rate;\r\noutb(val, ICEMT(ice, RATE));\r\nspin_unlock_irqrestore(&ice->reg_lock, flags);\r\nif (ice->gpio.set_pro_rate)\r\nice->gpio.set_pro_rate(ice, rate);\r\nfor (i = 0; i < ice->akm_codecs; i++) {\r\nif (ice->akm[i].ops.set_rate_val)\r\nice->akm[i].ops.set_rate_val(&ice->akm[i], rate);\r\n}\r\nif (ice->spdif.ops.setup_rate)\r\nice->spdif.ops.setup_rate(ice, rate);\r\n}\r\nstatic int snd_ice1712_playback_pro_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nice->playback_pro_size = snd_pcm_lib_buffer_bytes(substream);\r\nspin_lock_irq(&ice->reg_lock);\r\noutl(substream->runtime->dma_addr, ICEMT(ice, PLAYBACK_ADDR));\r\noutw((ice->playback_pro_size >> 2) - 1, ICEMT(ice, PLAYBACK_SIZE));\r\noutw((snd_pcm_lib_period_bytes(substream) >> 2) - 1, ICEMT(ice, PLAYBACK_COUNT));\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_playback_pro_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nsnd_ice1712_set_pro_rate(ice, params_rate(hw_params), 0);\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_ice1712_capture_pro_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nice->capture_pro_size = snd_pcm_lib_buffer_bytes(substream);\r\nspin_lock_irq(&ice->reg_lock);\r\noutl(substream->runtime->dma_addr, ICEMT(ice, CAPTURE_ADDR));\r\noutw((ice->capture_pro_size >> 2) - 1, ICEMT(ice, CAPTURE_SIZE));\r\noutw((snd_pcm_lib_period_bytes(substream) >> 2) - 1, ICEMT(ice, CAPTURE_COUNT));\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_capture_pro_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nsnd_ice1712_set_pro_rate(ice, params_rate(hw_params), 0);\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic snd_pcm_uframes_t snd_ice1712_playback_pro_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(inl(ICEMT(ice, PLAYBACK_CONTROL)) & ICE1712_PLAYBACK_START))\r\nreturn 0;\r\nptr = ice->playback_pro_size - (inw(ICEMT(ice, PLAYBACK_SIZE)) << 2);\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\nif (ptr == substream->runtime->buffer_size)\r\nptr = 0;\r\nreturn ptr;\r\n}\r\nstatic snd_pcm_uframes_t snd_ice1712_capture_pro_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(inl(ICEMT(ice, PLAYBACK_CONTROL)) & ICE1712_CAPTURE_START_SHADOW))\r\nreturn 0;\r\nptr = ice->capture_pro_size - (inw(ICEMT(ice, CAPTURE_SIZE)) << 2);\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\nif (ptr == substream->runtime->buffer_size)\r\nptr = 0;\r\nreturn ptr;\r\n}\r\nstatic int snd_ice1712_playback_pro_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nice->playback_pro_substream = substream;\r\nruntime->hw = snd_ice1712_playback_pro;\r\nsnd_pcm_set_sync(substream);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\r\nif (is_pro_rate_locked(ice)) {\r\nruntime->hw.rate_min = PRO_RATE_DEFAULT;\r\nruntime->hw.rate_max = PRO_RATE_DEFAULT;\r\n}\r\nif (ice->spdif.ops.open)\r\nice->spdif.ops.open(ice, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_capture_pro_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nice->capture_pro_substream = substream;\r\nruntime->hw = snd_ice1712_capture_pro;\r\nsnd_pcm_set_sync(substream);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\r\nif (is_pro_rate_locked(ice)) {\r\nruntime->hw.rate_min = PRO_RATE_DEFAULT;\r\nruntime->hw.rate_max = PRO_RATE_DEFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_playback_pro_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nif (PRO_RATE_RESET)\r\nsnd_ice1712_set_pro_rate(ice, PRO_RATE_DEFAULT, 0);\r\nice->playback_pro_substream = NULL;\r\nif (ice->spdif.ops.close)\r\nice->spdif.ops.close(ice, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_capture_pro_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nif (PRO_RATE_RESET)\r\nsnd_ice1712_set_pro_rate(ice, PRO_RATE_DEFAULT, 0);\r\nice->capture_pro_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pcm_profi(struct snd_ice1712 *ice, int device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nerr = snd_pcm_new(ice->card, "ICE1712 multi", device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ice1712_playback_pro_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ice1712_capture_pro_ops);\r\npcm->private_data = ice;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "ICE1712 multi");\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(ice->pci), 256*1024, 256*1024);\r\nice->pcm_pro = pcm;\r\nif (rpcm)\r\n*rpcm = pcm;\r\nif (ice->cs8427) {\r\nerr = snd_cs8427_iec958_build(ice->cs8427,\r\npcm->streams[0].substream,\r\npcm->streams[1].substream);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = snd_ice1712_build_pro_mixer(ice);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void snd_ice1712_update_volume(struct snd_ice1712 *ice, int index)\r\n{\r\nunsigned int vol = ice->pro_volumes[index];\r\nunsigned short val = 0;\r\nval |= (vol & 0x8000) == 0 ? (96 - (vol & 0x7f)) : 0x7f;\r\nval |= ((vol & 0x80000000) == 0 ? (96 - ((vol >> 16) & 0x7f)) : 0x7f) << 8;\r\noutb(index, ICEMT(ice, MONITOR_INDEX));\r\noutw(val, ICEMT(ice, MONITOR_VOLUME));\r\n}\r\nstatic int snd_ice1712_pro_mixer_switch_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint priv_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) +\r\nkcontrol->private_value;\r\nspin_lock_irq(&ice->reg_lock);\r\nucontrol->value.integer.value[0] =\r\n!((ice->pro_volumes[priv_idx] >> 15) & 1);\r\nucontrol->value.integer.value[1] =\r\n!((ice->pro_volumes[priv_idx] >> 31) & 1);\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_mixer_switch_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint priv_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) +\r\nkcontrol->private_value;\r\nunsigned int nval, change;\r\nnval = (ucontrol->value.integer.value[0] ? 0 : 0x00008000) |\r\n(ucontrol->value.integer.value[1] ? 0 : 0x80000000);\r\nspin_lock_irq(&ice->reg_lock);\r\nnval |= ice->pro_volumes[priv_idx] & ~0x80008000;\r\nchange = nval != ice->pro_volumes[priv_idx];\r\nice->pro_volumes[priv_idx] = nval;\r\nsnd_ice1712_update_volume(ice, priv_idx);\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ice1712_pro_mixer_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 96;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_mixer_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint priv_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) +\r\nkcontrol->private_value;\r\nspin_lock_irq(&ice->reg_lock);\r\nucontrol->value.integer.value[0] =\r\n(ice->pro_volumes[priv_idx] >> 0) & 127;\r\nucontrol->value.integer.value[1] =\r\n(ice->pro_volumes[priv_idx] >> 16) & 127;\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_mixer_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint priv_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) +\r\nkcontrol->private_value;\r\nunsigned int nval, change;\r\nnval = (ucontrol->value.integer.value[0] & 127) |\r\n((ucontrol->value.integer.value[1] & 127) << 16);\r\nspin_lock_irq(&ice->reg_lock);\r\nnval |= ice->pro_volumes[priv_idx] & ~0x007f007f;\r\nchange = nval != ice->pro_volumes[priv_idx];\r\nice->pro_volumes[priv_idx] = nval;\r\nsnd_ice1712_update_volume(ice, priv_idx);\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ice1712_build_pro_mixer(struct snd_ice1712 *ice)\r\n{\r\nstruct snd_card *card = ice->card;\r\nunsigned int idx;\r\nint err;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_ice1712_multi_playback_ctrls); idx++) {\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_ice1712_multi_playback_ctrls[idx], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (ice->num_total_adcs > 0) {\r\nstruct snd_kcontrol_new tmp = snd_ice1712_multi_capture_analog_switch;\r\ntmp.count = ice->num_total_adcs;\r\nerr = snd_ctl_add(card, snd_ctl_new1(&tmp, ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_ice1712_multi_capture_spdif_switch, ice));\r\nif (err < 0)\r\nreturn err;\r\nif (ice->num_total_adcs > 0) {\r\nstruct snd_kcontrol_new tmp = snd_ice1712_multi_capture_analog_volume;\r\ntmp.count = ice->num_total_adcs;\r\nerr = snd_ctl_add(card, snd_ctl_new1(&tmp, ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_ice1712_multi_capture_spdif_volume, ice));\r\nif (err < 0)\r\nreturn err;\r\nfor (idx = 0; idx < 10; idx++) {\r\nice->pro_volumes[idx] = 0x80008000;\r\nsnd_ice1712_update_volume(ice, idx);\r\n}\r\nfor (idx = 10; idx < 10 + ice->num_total_adcs; idx++) {\r\nice->pro_volumes[idx] = 0x80008000;\r\nsnd_ice1712_update_volume(ice, idx);\r\n}\r\nfor (idx = 18; idx < 20; idx++) {\r\nice->pro_volumes[idx] = 0x80008000;\r\nsnd_ice1712_update_volume(ice, idx);\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_ice1712_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct snd_ice1712 *ice = ac97->private_data;\r\nice->ac97 = NULL;\r\n}\r\nstatic int snd_ice1712_ac97_mixer(struct snd_ice1712 *ice)\r\n{\r\nint err, bus_num = 0;\r\nstruct snd_ac97_template ac97;\r\nstruct snd_ac97_bus *pbus;\r\nstatic struct snd_ac97_bus_ops con_ops = {\r\n.write = snd_ice1712_ac97_write,\r\n.read = snd_ice1712_ac97_read,\r\n};\r\nstatic struct snd_ac97_bus_ops pro_ops = {\r\n.write = snd_ice1712_pro_ac97_write,\r\n.read = snd_ice1712_pro_ac97_read,\r\n};\r\nif (ice_has_con_ac97(ice)) {\r\nerr = snd_ac97_bus(ice->card, bus_num++, &con_ops, NULL, &pbus);\r\nif (err < 0)\r\nreturn err;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = ice;\r\nac97.private_free = snd_ice1712_mixer_free_ac97;\r\nerr = snd_ac97_mixer(pbus, &ac97, &ice->ac97);\r\nif (err < 0)\r\ndev_warn(ice->card->dev,\r\n"cannot initialize ac97 for consumer, skipped\n");\r\nelse {\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_mixer_digmix_route_ac97, ice));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\n}\r\nif (!(ice->eeprom.data[ICE_EEP1_ACLINK] & ICE1712_CFG_PRO_I2S)) {\r\nerr = snd_ac97_bus(ice->card, bus_num, &pro_ops, NULL, &pbus);\r\nif (err < 0)\r\nreturn err;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = ice;\r\nac97.private_free = snd_ice1712_mixer_free_ac97;\r\nerr = snd_ac97_mixer(pbus, &ac97, &ice->ac97);\r\nif (err < 0)\r\ndev_warn(ice->card->dev,\r\n"cannot initialize pro ac97, skipped\n");\r\nelse\r\nreturn 0;\r\n}\r\nstrcat(ice->card->mixername, "ICE1712 - multitrack");\r\nreturn 0;\r\n}\r\nstatic inline unsigned int eeprom_double(struct snd_ice1712 *ice, int idx)\r\n{\r\nreturn (unsigned int)ice->eeprom.data[idx] | ((unsigned int)ice->eeprom.data[idx + 1] << 8);\r\n}\r\nstatic void snd_ice1712_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_ice1712 *ice = entry->private_data;\r\nunsigned int idx;\r\nsnd_iprintf(buffer, "%s\n\n", ice->card->longname);\r\nsnd_iprintf(buffer, "EEPROM:\n");\r\nsnd_iprintf(buffer, " Subvendor : 0x%x\n", ice->eeprom.subvendor);\r\nsnd_iprintf(buffer, " Size : %i bytes\n", ice->eeprom.size);\r\nsnd_iprintf(buffer, " Version : %i\n", ice->eeprom.version);\r\nsnd_iprintf(buffer, " Codec : 0x%x\n", ice->eeprom.data[ICE_EEP1_CODEC]);\r\nsnd_iprintf(buffer, " ACLink : 0x%x\n", ice->eeprom.data[ICE_EEP1_ACLINK]);\r\nsnd_iprintf(buffer, " I2S ID : 0x%x\n", ice->eeprom.data[ICE_EEP1_I2SID]);\r\nsnd_iprintf(buffer, " S/PDIF : 0x%x\n", ice->eeprom.data[ICE_EEP1_SPDIF]);\r\nsnd_iprintf(buffer, " GPIO mask : 0x%x\n", ice->eeprom.gpiomask);\r\nsnd_iprintf(buffer, " GPIO state : 0x%x\n", ice->eeprom.gpiostate);\r\nsnd_iprintf(buffer, " GPIO direction : 0x%x\n", ice->eeprom.gpiodir);\r\nsnd_iprintf(buffer, " AC'97 main : 0x%x\n", eeprom_double(ice, ICE_EEP1_AC97_MAIN_LO));\r\nsnd_iprintf(buffer, " AC'97 pcm : 0x%x\n", eeprom_double(ice, ICE_EEP1_AC97_PCM_LO));\r\nsnd_iprintf(buffer, " AC'97 record : 0x%x\n", eeprom_double(ice, ICE_EEP1_AC97_REC_LO));\r\nsnd_iprintf(buffer, " AC'97 record src : 0x%x\n", ice->eeprom.data[ICE_EEP1_AC97_RECSRC]);\r\nfor (idx = 0; idx < 4; idx++)\r\nsnd_iprintf(buffer, " DAC ID #%i : 0x%x\n", idx, ice->eeprom.data[ICE_EEP1_DAC_ID + idx]);\r\nfor (idx = 0; idx < 4; idx++)\r\nsnd_iprintf(buffer, " ADC ID #%i : 0x%x\n", idx, ice->eeprom.data[ICE_EEP1_ADC_ID + idx]);\r\nfor (idx = 0x1c; idx < ice->eeprom.size; idx++)\r\nsnd_iprintf(buffer, " Extra #%02i : 0x%x\n", idx, ice->eeprom.data[idx]);\r\nsnd_iprintf(buffer, "\nRegisters:\n");\r\nsnd_iprintf(buffer, " PSDOUT03 : 0x%04x\n", (unsigned)inw(ICEMT(ice, ROUTE_PSDOUT03)));\r\nsnd_iprintf(buffer, " CAPTURE : 0x%08x\n", inl(ICEMT(ice, ROUTE_CAPTURE)));\r\nsnd_iprintf(buffer, " SPDOUT : 0x%04x\n", (unsigned)inw(ICEMT(ice, ROUTE_SPDOUT)));\r\nsnd_iprintf(buffer, " RATE : 0x%02x\n", (unsigned)inb(ICEMT(ice, RATE)));\r\nsnd_iprintf(buffer, " GPIO_DATA : 0x%02x\n", (unsigned)snd_ice1712_get_gpio_data(ice));\r\nsnd_iprintf(buffer, " GPIO_WRITE_MASK : 0x%02x\n", (unsigned)snd_ice1712_read(ice, ICE1712_IREG_GPIO_WRITE_MASK));\r\nsnd_iprintf(buffer, " GPIO_DIRECTION : 0x%02x\n", (unsigned)snd_ice1712_read(ice, ICE1712_IREG_GPIO_DIRECTION));\r\n}\r\nstatic void snd_ice1712_proc_init(struct snd_ice1712 *ice)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(ice->card, "ice1712", &entry))\r\nsnd_info_set_text_ops(entry, ice, snd_ice1712_proc_read);\r\n}\r\nstatic int snd_ice1712_eeprom_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = sizeof(struct snd_ice1712_eeprom);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_eeprom_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nmemcpy(ucontrol->value.bytes.data, &ice->eeprom, sizeof(ice->eeprom));\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nif (ice->spdif.ops.default_get)\r\nice->spdif.ops.default_get(ice, ucontrol);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nif (ice->spdif.ops.default_put)\r\nreturn ice->spdif.ops.default_put(ice, ucontrol);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_spdif_maskc_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nif (ice->spdif.ops.default_get) {\r\nucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO |\r\nIEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_CON_NOT_COPYRIGHT |\r\nIEC958_AES0_CON_EMPHASIS;\r\nucontrol->value.iec958.status[1] = IEC958_AES1_CON_ORIGINAL |\r\nIEC958_AES1_CON_CATEGORY;\r\nucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS;\r\n} else {\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nucontrol->value.iec958.status[4] = 0xff;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_spdif_maskp_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nif (ice->spdif.ops.default_get) {\r\nucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO |\r\nIEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_PRO_FS |\r\nIEC958_AES0_PRO_EMPHASIS;\r\nucontrol->value.iec958.status[1] = IEC958_AES1_PRO_MODE;\r\n} else {\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nucontrol->value.iec958.status[4] = 0xff;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_spdif_stream_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nif (ice->spdif.ops.stream_get)\r\nice->spdif.ops.stream_get(ice, ucontrol);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_spdif_stream_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nif (ice->spdif.ops.stream_put)\r\nreturn ice->spdif.ops.stream_put(ice, ucontrol);\r\nreturn 0;\r\n}\r\nint snd_ice1712_gpio_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned char mask = kcontrol->private_value & 0xff;\r\nint invert = (kcontrol->private_value & (1<<24)) ? 1 : 0;\r\nsnd_ice1712_save_gpio_status(ice);\r\nucontrol->value.integer.value[0] =\r\n(snd_ice1712_gpio_read(ice) & mask ? 1 : 0) ^ invert;\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn 0;\r\n}\r\nint snd_ice1712_gpio_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned char mask = kcontrol->private_value & 0xff;\r\nint invert = (kcontrol->private_value & (1<<24)) ? mask : 0;\r\nunsigned int val, nval;\r\nif (kcontrol->private_value & (1 << 31))\r\nreturn -EPERM;\r\nnval = (ucontrol->value.integer.value[0] ? mask : 0) ^ invert;\r\nsnd_ice1712_save_gpio_status(ice);\r\nval = snd_ice1712_gpio_read(ice);\r\nnval |= val & ~mask;\r\nif (val != nval)\r\nsnd_ice1712_gpio_write(ice, nval);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn val != nval;\r\n}\r\nstatic int snd_ice1712_pro_internal_clock_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[] = {\r\n"8000",\r\n"9600",\r\n"11025",\r\n"12000",\r\n"16000",\r\n"22050",\r\n"24000",\r\n"32000",\r\n"44100",\r\n"48000",\r\n"64000",\r\n"88200",\r\n"96000",\r\n"IEC958 Input",\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 14;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_internal_clock_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstatic const unsigned char xlate[16] = {\r\n9, 6, 3, 1, 7, 4, 0, 12, 8, 5, 2, 11, 255, 255, 255, 10\r\n};\r\nunsigned char val;\r\nspin_lock_irq(&ice->reg_lock);\r\nif (is_spdif_master(ice)) {\r\nucontrol->value.enumerated.item[0] = 13;\r\n} else {\r\nval = xlate[inb(ICEMT(ice, RATE)) & 15];\r\nif (val == 255) {\r\nsnd_BUG();\r\nval = 0;\r\n}\r\nucontrol->value.enumerated.item[0] = val;\r\n}\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_internal_clock_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstatic const unsigned int xrate[13] = {\r\n8000, 9600, 11025, 12000, 16000, 22050, 24000,\r\n32000, 44100, 48000, 64000, 88200, 96000\r\n};\r\nunsigned char oval;\r\nint change = 0;\r\nspin_lock_irq(&ice->reg_lock);\r\noval = inb(ICEMT(ice, RATE));\r\nif (ucontrol->value.enumerated.item[0] == 13) {\r\noutb(oval | ICE1712_SPDIF_MASTER, ICEMT(ice, RATE));\r\n} else {\r\nPRO_RATE_DEFAULT = xrate[ucontrol->value.integer.value[0] % 13];\r\nspin_unlock_irq(&ice->reg_lock);\r\nsnd_ice1712_set_pro_rate(ice, PRO_RATE_DEFAULT, 1);\r\nspin_lock_irq(&ice->reg_lock);\r\n}\r\nchange = inb(ICEMT(ice, RATE)) != oval;\r\nspin_unlock_irq(&ice->reg_lock);\r\nif ((oval & ICE1712_SPDIF_MASTER) !=\r\n(inb(ICEMT(ice, RATE)) & ICE1712_SPDIF_MASTER))\r\nsnd_ice1712_set_input_clock_source(ice, is_spdif_master(ice));\r\nreturn change;\r\n}\r\nstatic int snd_ice1712_pro_internal_clock_default_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[] = {\r\n"8000",\r\n"9600",\r\n"11025",\r\n"12000",\r\n"16000",\r\n"22050",\r\n"24000",\r\n"32000",\r\n"44100",\r\n"48000",\r\n"64000",\r\n"88200",\r\n"96000",\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 13;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_internal_clock_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint val;\r\nstatic const unsigned int xrate[13] = {\r\n8000, 9600, 11025, 12000, 16000, 22050, 24000,\r\n32000, 44100, 48000, 64000, 88200, 96000\r\n};\r\nfor (val = 0; val < 13; val++) {\r\nif (xrate[val] == PRO_RATE_DEFAULT)\r\nbreak;\r\n}\r\nucontrol->value.enumerated.item[0] = val;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_internal_clock_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstatic const unsigned int xrate[13] = {\r\n8000, 9600, 11025, 12000, 16000, 22050, 24000,\r\n32000, 44100, 48000, 64000, 88200, 96000\r\n};\r\nunsigned char oval;\r\nint change = 0;\r\noval = PRO_RATE_DEFAULT;\r\nPRO_RATE_DEFAULT = xrate[ucontrol->value.integer.value[0] % 13];\r\nchange = PRO_RATE_DEFAULT != oval;\r\nreturn change;\r\n}\r\nstatic int snd_ice1712_pro_rate_locking_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = PRO_RATE_LOCKED;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_rate_locking_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint change = 0, nval;\r\nnval = ucontrol->value.integer.value[0] ? 1 : 0;\r\nspin_lock_irq(&ice->reg_lock);\r\nchange = PRO_RATE_LOCKED != nval;\r\nPRO_RATE_LOCKED = nval;\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ice1712_pro_rate_reset_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = PRO_RATE_RESET;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_rate_reset_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint change = 0, nval;\r\nnval = ucontrol->value.integer.value[0] ? 1 : 0;\r\nspin_lock_irq(&ice->reg_lock);\r\nchange = PRO_RATE_RESET != nval;\r\nPRO_RATE_RESET = nval;\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ice1712_pro_route_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[] = {\r\n"PCM Out",\r\n"H/W In 0", "H/W In 1", "H/W In 2", "H/W In 3",\r\n"H/W In 4", "H/W In 5", "H/W In 6", "H/W In 7",\r\n"IEC958 In L", "IEC958 In R",\r\n"Digital Mixer",\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items =\r\nsnd_ctl_get_ioffidx(kcontrol, &uinfo->id) < 2 ? 12 : 11;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_route_analog_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nunsigned int val, cval;\r\nspin_lock_irq(&ice->reg_lock);\r\nval = inw(ICEMT(ice, ROUTE_PSDOUT03));\r\ncval = inl(ICEMT(ice, ROUTE_CAPTURE));\r\nspin_unlock_irq(&ice->reg_lock);\r\nval >>= ((idx % 2) * 8) + ((idx / 2) * 2);\r\nval &= 3;\r\ncval >>= ((idx / 2) * 8) + ((idx % 2) * 4);\r\nif (val == 1 && idx < 2)\r\nucontrol->value.enumerated.item[0] = 11;\r\nelse if (val == 2)\r\nucontrol->value.enumerated.item[0] = (cval & 7) + 1;\r\nelse if (val == 3)\r\nucontrol->value.enumerated.item[0] = ((cval >> 3) & 1) + 9;\r\nelse\r\nucontrol->value.enumerated.item[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_route_analog_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint change, shift;\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nunsigned int val, old_val, nval;\r\nif (ucontrol->value.enumerated.item[0] >= 11)\r\nnval = idx < 2 ? 1 : 0;\r\nelse if (ucontrol->value.enumerated.item[0] >= 9)\r\nnval = 3;\r\nelse if (ucontrol->value.enumerated.item[0] >= 1)\r\nnval = 2;\r\nelse\r\nnval = 0;\r\nshift = ((idx % 2) * 8) + ((idx / 2) * 2);\r\nspin_lock_irq(&ice->reg_lock);\r\nval = old_val = inw(ICEMT(ice, ROUTE_PSDOUT03));\r\nval &= ~(0x03 << shift);\r\nval |= nval << shift;\r\nchange = val != old_val;\r\nif (change)\r\noutw(val, ICEMT(ice, ROUTE_PSDOUT03));\r\nspin_unlock_irq(&ice->reg_lock);\r\nif (nval < 2)\r\nreturn change;\r\nspin_lock_irq(&ice->reg_lock);\r\nval = old_val = inl(ICEMT(ice, ROUTE_CAPTURE));\r\nshift = ((idx / 2) * 8) + ((idx % 2) * 4);\r\nif (nval == 2) {\r\nnval = ucontrol->value.enumerated.item[0] - 1;\r\nval &= ~(0x07 << shift);\r\nval |= nval << shift;\r\n} else {\r\nnval = (ucontrol->value.enumerated.item[0] - 9) << 3;\r\nval &= ~(0x08 << shift);\r\nval |= nval << shift;\r\n}\r\nif (val != old_val) {\r\nchange = 1;\r\noutl(val, ICEMT(ice, ROUTE_CAPTURE));\r\n}\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ice1712_pro_route_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nunsigned int val, cval;\r\nval = inw(ICEMT(ice, ROUTE_SPDOUT));\r\ncval = (val >> (idx * 4 + 8)) & 0x0f;\r\nval = (val >> (idx * 2)) & 0x03;\r\nif (val == 1)\r\nucontrol->value.enumerated.item[0] = 11;\r\nelse if (val == 2)\r\nucontrol->value.enumerated.item[0] = (cval & 7) + 1;\r\nelse if (val == 3)\r\nucontrol->value.enumerated.item[0] = ((cval >> 3) & 1) + 9;\r\nelse\r\nucontrol->value.enumerated.item[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_route_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint change, shift;\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nunsigned int val, old_val, nval;\r\nspin_lock_irq(&ice->reg_lock);\r\nval = old_val = inw(ICEMT(ice, ROUTE_SPDOUT));\r\nif (ucontrol->value.enumerated.item[0] >= 11)\r\nnval = 1;\r\nelse if (ucontrol->value.enumerated.item[0] >= 9)\r\nnval = 3;\r\nelse if (ucontrol->value.enumerated.item[0] >= 1)\r\nnval = 2;\r\nelse\r\nnval = 0;\r\nshift = idx * 2;\r\nval &= ~(0x03 << shift);\r\nval |= nval << shift;\r\nshift = idx * 4 + 8;\r\nif (nval == 2) {\r\nnval = ucontrol->value.enumerated.item[0] - 1;\r\nval &= ~(0x07 << shift);\r\nval |= nval << shift;\r\n} else if (nval == 3) {\r\nnval = (ucontrol->value.enumerated.item[0] - 9) << 3;\r\nval &= ~(0x08 << shift);\r\nval |= nval << shift;\r\n}\r\nchange = val != old_val;\r\nif (change)\r\noutw(val, ICEMT(ice, ROUTE_SPDOUT));\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ice1712_pro_volume_rate_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_volume_rate_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = inb(ICEMT(ice, MONITOR_RATE));\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_volume_rate_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nspin_lock_irq(&ice->reg_lock);\r\nchange = inb(ICEMT(ice, MONITOR_RATE)) != ucontrol->value.integer.value[0];\r\noutb(ucontrol->value.integer.value[0], ICEMT(ice, MONITOR_RATE));\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ice1712_pro_peak_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 22;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_pro_peak_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint idx;\r\nspin_lock_irq(&ice->reg_lock);\r\nfor (idx = 0; idx < 22; idx++) {\r\noutb(idx, ICEMT(ice, MONITOR_PEAKINDEX));\r\nucontrol->value.integer.value[idx] = inb(ICEMT(ice, MONITOR_PEAKDATA));\r\n}\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic unsigned char snd_ice1712_read_i2c(struct snd_ice1712 *ice,\r\nunsigned char dev,\r\nunsigned char addr)\r\n{\r\nlong t = 0x10000;\r\noutb(addr, ICEREG(ice, I2C_BYTE_ADDR));\r\noutb(dev & ~ICE1712_I2C_WRITE, ICEREG(ice, I2C_DEV_ADDR));\r\nwhile (t-- > 0 && (inb(ICEREG(ice, I2C_CTRL)) & ICE1712_I2C_BUSY)) ;\r\nreturn inb(ICEREG(ice, I2C_DATA));\r\n}\r\nstatic int snd_ice1712_read_eeprom(struct snd_ice1712 *ice,\r\nconst char *modelname)\r\n{\r\nint dev = 0xa0;\r\nunsigned int i, size;\r\nstruct snd_ice1712_card_info * const *tbl, *c;\r\nif (!modelname || !*modelname) {\r\nice->eeprom.subvendor = 0;\r\nif ((inb(ICEREG(ice, I2C_CTRL)) & ICE1712_I2C_EEPROM) != 0)\r\nice->eeprom.subvendor = (snd_ice1712_read_i2c(ice, dev, 0x00) << 0) |\r\n(snd_ice1712_read_i2c(ice, dev, 0x01) << 8) |\r\n(snd_ice1712_read_i2c(ice, dev, 0x02) << 16) |\r\n(snd_ice1712_read_i2c(ice, dev, 0x03) << 24);\r\nif (ice->eeprom.subvendor == 0 ||\r\nice->eeprom.subvendor == (unsigned int)-1) {\r\nu16 vendor, device;\r\npci_read_config_word(ice->pci, PCI_SUBSYSTEM_VENDOR_ID, &vendor);\r\npci_read_config_word(ice->pci, PCI_SUBSYSTEM_ID, &device);\r\nice->eeprom.subvendor = ((unsigned int)swab16(vendor) << 16) | swab16(device);\r\nif (ice->eeprom.subvendor == 0 || ice->eeprom.subvendor == (unsigned int)-1) {\r\ndev_err(ice->card->dev,\r\n"No valid ID is found\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\n}\r\nfor (tbl = card_tables; *tbl; tbl++) {\r\nfor (c = *tbl; c->subvendor; c++) {\r\nif (modelname && c->model && !strcmp(modelname, c->model)) {\r\ndev_info(ice->card->dev,\r\n"Using board model %s\n", c->name);\r\nice->eeprom.subvendor = c->subvendor;\r\n} else if (c->subvendor != ice->eeprom.subvendor)\r\ncontinue;\r\nif (!c->eeprom_size || !c->eeprom_data)\r\ngoto found;\r\ndev_dbg(ice->card->dev, "using the defined eeprom..\n");\r\nice->eeprom.version = 1;\r\nice->eeprom.size = c->eeprom_size + 6;\r\nmemcpy(ice->eeprom.data, c->eeprom_data, c->eeprom_size);\r\ngoto read_skipped;\r\n}\r\n}\r\ndev_warn(ice->card->dev, "No matching model found for ID 0x%x\n",\r\nice->eeprom.subvendor);\r\nfound:\r\nice->eeprom.size = snd_ice1712_read_i2c(ice, dev, 0x04);\r\nif (ice->eeprom.size < 6)\r\nice->eeprom.size = 32;\r\nelse if (ice->eeprom.size > 32) {\r\ndev_err(ice->card->dev,\r\n"invalid EEPROM (size = %i)\n", ice->eeprom.size);\r\nreturn -EIO;\r\n}\r\nice->eeprom.version = snd_ice1712_read_i2c(ice, dev, 0x05);\r\nif (ice->eeprom.version != 1) {\r\ndev_err(ice->card->dev, "invalid EEPROM version %i\n",\r\nice->eeprom.version);\r\n}\r\nsize = ice->eeprom.size - 6;\r\nfor (i = 0; i < size; i++)\r\nice->eeprom.data[i] = snd_ice1712_read_i2c(ice, dev, i + 6);\r\nread_skipped:\r\nice->eeprom.gpiomask = ice->eeprom.data[ICE_EEP1_GPIO_MASK];\r\nice->eeprom.gpiostate = ice->eeprom.data[ICE_EEP1_GPIO_STATE];\r\nice->eeprom.gpiodir = ice->eeprom.data[ICE_EEP1_GPIO_DIR];\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_chip_init(struct snd_ice1712 *ice)\r\n{\r\noutb(ICE1712_RESET | ICE1712_NATIVE, ICEREG(ice, CONTROL));\r\nudelay(200);\r\noutb(ICE1712_NATIVE, ICEREG(ice, CONTROL));\r\nudelay(200);\r\nif (ice->eeprom.subvendor == ICE1712_SUBDEVICE_DMX6FIRE &&\r\n!ice->dxr_enable)\r\nice->eeprom.data[ICE_EEP1_CODEC] = 0x3a;\r\npci_write_config_byte(ice->pci, 0x60, ice->eeprom.data[ICE_EEP1_CODEC]);\r\npci_write_config_byte(ice->pci, 0x61, ice->eeprom.data[ICE_EEP1_ACLINK]);\r\npci_write_config_byte(ice->pci, 0x62, ice->eeprom.data[ICE_EEP1_I2SID]);\r\npci_write_config_byte(ice->pci, 0x63, ice->eeprom.data[ICE_EEP1_SPDIF]);\r\nif (ice->eeprom.subvendor != ICE1712_SUBDEVICE_STDSP24) {\r\nice->gpio.write_mask = ice->eeprom.gpiomask;\r\nice->gpio.direction = ice->eeprom.gpiodir;\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK,\r\nice->eeprom.gpiomask);\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION,\r\nice->eeprom.gpiodir);\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA,\r\nice->eeprom.gpiostate);\r\n} else {\r\nice->gpio.write_mask = 0xc0;\r\nice->gpio.direction = 0xff;\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, 0xc0);\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION, 0xff);\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA,\r\nICE1712_STDSP24_CLOCK_BIT);\r\n}\r\nsnd_ice1712_write(ice, ICE1712_IREG_PRO_POWERDOWN, 0);\r\nif (!(ice->eeprom.data[ICE_EEP1_CODEC] & ICE1712_CFG_NO_CON_AC97)) {\r\noutb(ICE1712_AC97_WARM, ICEREG(ice, AC97_CMD));\r\nudelay(100);\r\noutb(0, ICEREG(ice, AC97_CMD));\r\nudelay(200);\r\nsnd_ice1712_write(ice, ICE1712_IREG_CONSUMER_POWERDOWN, 0);\r\n}\r\nsnd_ice1712_set_pro_rate(ice, 48000, 1);\r\noutb(((ice->eeprom.data[ICE_EEP1_CODEC] & ICE1712_CFG_2xMPU401) == 0 ?\r\nICE1712_IRQ_MPU2 : 0) |\r\n((ice->eeprom.data[ICE_EEP1_CODEC] & ICE1712_CFG_NO_CON_AC97) ?\r\nICE1712_IRQ_PBKDS | ICE1712_IRQ_CONCAP | ICE1712_IRQ_CONPBK : 0),\r\nICEREG(ice, IRQMASK));\r\noutb(0x00, ICEMT(ice, IRQ));\r\nreturn 0;\r\n}\r\nint snd_ice1712_spdif_build_controls(struct snd_ice1712 *ice)\r\n{\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nif (snd_BUG_ON(!ice->pcm_pro))\r\nreturn -EIO;\r\nerr = snd_ctl_add(ice->card, kctl = snd_ctl_new1(&snd_ice1712_spdif_default, ice));\r\nif (err < 0)\r\nreturn err;\r\nkctl->id.device = ice->pcm_pro->device;\r\nerr = snd_ctl_add(ice->card, kctl = snd_ctl_new1(&snd_ice1712_spdif_maskc, ice));\r\nif (err < 0)\r\nreturn err;\r\nkctl->id.device = ice->pcm_pro->device;\r\nerr = snd_ctl_add(ice->card, kctl = snd_ctl_new1(&snd_ice1712_spdif_maskp, ice));\r\nif (err < 0)\r\nreturn err;\r\nkctl->id.device = ice->pcm_pro->device;\r\nerr = snd_ctl_add(ice->card, kctl = snd_ctl_new1(&snd_ice1712_spdif_stream, ice));\r\nif (err < 0)\r\nreturn err;\r\nkctl->id.device = ice->pcm_pro->device;\r\nice->spdif.stream_ctl = kctl;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_build_controls(struct snd_ice1712 *ice)\r\n{\r\nint err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_eeprom, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_pro_internal_clock, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_pro_internal_clock_default, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_pro_rate_locking, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_pro_rate_reset, ice));\r\nif (err < 0)\r\nreturn err;\r\nif (ice->num_total_dacs > 0) {\r\nstruct snd_kcontrol_new tmp = snd_ice1712_mixer_pro_analog_route;\r\ntmp.count = ice->num_total_dacs;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&tmp, ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_mixer_pro_spdif_route, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_mixer_pro_volume_rate, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_mixer_pro_peak, ice));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_free(struct snd_ice1712 *ice)\r\n{\r\nif (!ice->port)\r\ngoto __hw_end;\r\noutb(0xc0, ICEMT(ice, IRQ));\r\noutb(0xff, ICEREG(ice, IRQMASK));\r\n__hw_end:\r\nif (ice->irq >= 0)\r\nfree_irq(ice->irq, ice);\r\nif (ice->port)\r\npci_release_regions(ice->pci);\r\nsnd_ice1712_akm4xxx_free(ice);\r\npci_disable_device(ice->pci);\r\nkfree(ice->spec);\r\nkfree(ice);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_ice1712 *ice = device->device_data;\r\nreturn snd_ice1712_free(ice);\r\n}\r\nstatic int snd_ice1712_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nconst char *modelname,\r\nint omni,\r\nint cs8427_timeout,\r\nint dxr_enable,\r\nstruct snd_ice1712 **r_ice1712)\r\n{\r\nstruct snd_ice1712 *ice;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ice1712_dev_free,\r\n};\r\n*r_ice1712 = NULL;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {\r\ndev_err(card->dev,\r\n"architecture does not support 28bit PCI busmaster DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nice = kzalloc(sizeof(*ice), GFP_KERNEL);\r\nif (ice == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nice->omni = omni ? 1 : 0;\r\nif (cs8427_timeout < 1)\r\ncs8427_timeout = 1;\r\nelse if (cs8427_timeout > 1000)\r\ncs8427_timeout = 1000;\r\nice->cs8427_timeout = cs8427_timeout;\r\nice->dxr_enable = dxr_enable;\r\nspin_lock_init(&ice->reg_lock);\r\nmutex_init(&ice->gpio_mutex);\r\nmutex_init(&ice->i2c_mutex);\r\nmutex_init(&ice->open_mutex);\r\nice->gpio.set_mask = snd_ice1712_set_gpio_mask;\r\nice->gpio.get_mask = snd_ice1712_get_gpio_mask;\r\nice->gpio.set_dir = snd_ice1712_set_gpio_dir;\r\nice->gpio.get_dir = snd_ice1712_get_gpio_dir;\r\nice->gpio.set_data = snd_ice1712_set_gpio_data;\r\nice->gpio.get_data = snd_ice1712_get_gpio_data;\r\nice->spdif.cs8403_bits =\r\nice->spdif.cs8403_stream_bits = (0x01 |\r\n0x10 |\r\n0x20);\r\nice->card = card;\r\nice->pci = pci;\r\nice->irq = -1;\r\npci_set_master(pci);\r\npci_write_config_word(ice->pci, 0x40, 0x807f);\r\npci_write_config_word(ice->pci, 0x42, 0x0006);\r\nsnd_ice1712_proc_init(ice);\r\nsynchronize_irq(pci->irq);\r\ncard->private_data = ice;\r\nerr = pci_request_regions(pci, "ICE1712");\r\nif (err < 0) {\r\nkfree(ice);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nice->port = pci_resource_start(pci, 0);\r\nice->ddma_port = pci_resource_start(pci, 1);\r\nice->dmapath_port = pci_resource_start(pci, 2);\r\nice->profi_port = pci_resource_start(pci, 3);\r\nif (request_irq(pci->irq, snd_ice1712_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, ice)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_ice1712_free(ice);\r\nreturn -EIO;\r\n}\r\nice->irq = pci->irq;\r\nif (snd_ice1712_read_eeprom(ice, modelname) < 0) {\r\nsnd_ice1712_free(ice);\r\nreturn -EIO;\r\n}\r\nif (snd_ice1712_chip_init(ice) < 0) {\r\nsnd_ice1712_free(ice);\r\nreturn -EIO;\r\n}\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, ice, &ops);\r\nif (err < 0) {\r\nsnd_ice1712_free(ice);\r\nreturn err;\r\n}\r\n*r_ice1712 = ice;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct snd_ice1712 *ice;\r\nint pcm_dev = 0, err;\r\nstruct snd_ice1712_card_info * const *tbl, *c;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nstrcpy(card->driver, "ICE1712");\r\nstrcpy(card->shortname, "ICEnsemble ICE1712");\r\nerr = snd_ice1712_create(card, pci, model[dev], omni[dev],\r\ncs8427_timeout[dev], dxr_enable[dev], &ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nfor (tbl = card_tables; *tbl; tbl++) {\r\nfor (c = *tbl; c->subvendor; c++) {\r\nif (c->subvendor == ice->eeprom.subvendor) {\r\nice->card_info = c;\r\nstrcpy(card->shortname, c->name);\r\nif (c->driver)\r\nstrcpy(card->driver, c->driver);\r\nif (c->chip_init) {\r\nerr = c->chip_init(ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n}\r\ngoto __found;\r\n}\r\n}\r\n}\r\nc = &no_matched;\r\n__found:\r\nerr = snd_ice1712_pcm_profi(ice, pcm_dev++, NULL);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif (ice_has_con_ac97(ice)) {\r\nerr = snd_ice1712_pcm(ice, pcm_dev++, NULL);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n}\r\nerr = snd_ice1712_ac97_mixer(ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_ice1712_build_controls(ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif (c->build_controls) {\r\nerr = c->build_controls(ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n}\r\nif (ice_has_con_ac97(ice)) {\r\nerr = snd_ice1712_pcm_ds(ice, pcm_dev++, NULL);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n}\r\nif (!c->no_mpu401) {\r\nerr = snd_mpu401_uart_new(card, 0, MPU401_HW_ICE1712,\r\nICEREG(ice, MPU1_CTRL),\r\nc->mpu401_1_info_flags |\r\nMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK,\r\n-1, &ice->rmidi[0]);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif (c->mpu401_1_name)\r\nsnprintf(ice->rmidi[0]->name,\r\nsizeof(ice->rmidi[0]->name),\r\n"%s %d", c->mpu401_1_name, card->number);\r\nif (ice->eeprom.data[ICE_EEP1_CODEC] & ICE1712_CFG_2xMPU401) {\r\nerr = snd_mpu401_uart_new(card, 1, MPU401_HW_ICE1712,\r\nICEREG(ice, MPU2_CTRL),\r\nc->mpu401_2_info_flags |\r\nMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK,\r\n-1, &ice->rmidi[1]);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif (c->mpu401_2_name)\r\nsnprintf(ice->rmidi[1]->name,\r\nsizeof(ice->rmidi[1]->name),\r\n"%s %d", c->mpu401_2_name,\r\ncard->number);\r\n}\r\n}\r\nsnd_ice1712_set_input_clock_source(ice, 0);\r\nsprintf(card->longname, "%s at 0x%lx, irq %i",\r\ncard->shortname, ice->port, ice->irq);\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_ice1712_remove(struct pci_dev *pci)\r\n{\r\nstruct snd_card *card = pci_get_drvdata(pci);\r\nstruct snd_ice1712 *ice = card->private_data;\r\nif (ice->card_info && ice->card_info->chip_exit)\r\nice->card_info->chip_exit(ice);\r\nsnd_card_free(card);\r\n}\r\nstatic int snd_ice1712_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_ice1712 *ice = card->private_data;\r\nif (!ice->pm_suspend_enabled)\r\nreturn 0;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(ice->pcm);\r\nsnd_pcm_suspend_all(ice->pcm_pro);\r\nsnd_pcm_suspend_all(ice->pcm_ds);\r\nsnd_ac97_suspend(ice->ac97);\r\nspin_lock_irq(&ice->reg_lock);\r\nice->pm_saved_is_spdif_master = is_spdif_master(ice);\r\nice->pm_saved_spdif_ctrl = inw(ICEMT(ice, ROUTE_SPDOUT));\r\nice->pm_saved_route = inw(ICEMT(ice, ROUTE_PSDOUT03));\r\nspin_unlock_irq(&ice->reg_lock);\r\nif (ice->pm_suspend)\r\nice->pm_suspend(ice);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_ice1712 *ice = card->private_data;\r\nint rate;\r\nif (!ice->pm_suspend_enabled)\r\nreturn 0;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nif (ice->cur_rate)\r\nrate = ice->cur_rate;\r\nelse\r\nrate = PRO_RATE_DEFAULT;\r\nif (snd_ice1712_chip_init(ice) < 0) {\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\nice->cur_rate = rate;\r\nif (ice->pm_resume)\r\nice->pm_resume(ice);\r\nif (ice->pm_saved_is_spdif_master) {\r\nspin_lock_irq(&ice->reg_lock);\r\noutb(inb(ICEMT(ice, RATE)) | ICE1712_SPDIF_MASTER,\r\nICEMT(ice, RATE));\r\nspin_unlock_irq(&ice->reg_lock);\r\nsnd_ice1712_set_input_clock_source(ice, 1);\r\n} else {\r\nsnd_ice1712_set_pro_rate(ice, rate, 1);\r\nsnd_ice1712_set_input_clock_source(ice, 0);\r\n}\r\noutw(ice->pm_saved_spdif_ctrl, ICEMT(ice, ROUTE_SPDOUT));\r\noutw(ice->pm_saved_route, ICEMT(ice, ROUTE_PSDOUT03));\r\nif (ice->ac97)\r\nsnd_ac97_resume(ice->ac97);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}
