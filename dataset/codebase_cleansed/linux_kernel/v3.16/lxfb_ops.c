static void lx_set_dotpll(u32 pllval)\r\n{\r\nu32 dotpll_lo, dotpll_hi;\r\nint i;\r\nrdmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\r\nif ((dotpll_lo & MSR_GLCP_DOTPLL_LOCK) && (dotpll_hi == pllval))\r\nreturn;\r\ndotpll_hi = pllval;\r\ndotpll_lo &= ~(MSR_GLCP_DOTPLL_BYPASS | MSR_GLCP_DOTPLL_HALFPIX);\r\ndotpll_lo |= MSR_GLCP_DOTPLL_DOTRESET;\r\nwrmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\r\nudelay(100);\r\nfor (i = 0; i < 1000; i++) {\r\nrdmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\r\nif (dotpll_lo & MSR_GLCP_DOTPLL_LOCK)\r\nbreak;\r\n}\r\ndotpll_lo &= ~MSR_GLCP_DOTPLL_DOTRESET;\r\nwrmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\r\n}\r\nstatic void lx_set_clock(struct fb_info *info)\r\n{\r\nunsigned int diff, min, best = 0;\r\nunsigned int freq, i;\r\nfreq = (unsigned int) (1000000000 / info->var.pixclock);\r\nmin = abs(pll_table[0].freq - freq);\r\nfor (i = 0; i < ARRAY_SIZE(pll_table); i++) {\r\ndiff = abs(pll_table[i].freq - freq);\r\nif (diff < min) {\r\nmin = diff;\r\nbest = i;\r\n}\r\n}\r\nlx_set_dotpll(pll_table[best].pllval & 0x00017FFF);\r\n}\r\nstatic void lx_graphics_disable(struct fb_info *info)\r\n{\r\nstruct lxfb_par *par = info->par;\r\nunsigned int val, gcfg;\r\nwrite_vp(par, VP_A1T, 0);\r\nwrite_vp(par, VP_A2T, 0);\r\nwrite_vp(par, VP_A3T, 0);\r\nval = read_dc(par, DC_GENERAL_CFG) & ~(DC_GENERAL_CFG_VGAE |\r\nDC_GENERAL_CFG_VIDE);\r\nwrite_dc(par, DC_GENERAL_CFG, val);\r\nval = read_vp(par, VP_VCFG) & ~VP_VCFG_VID_EN;\r\nwrite_vp(par, VP_VCFG, val);\r\nwrite_dc(par, DC_IRQ, DC_IRQ_MASK | DC_IRQ_VIP_VSYNC_LOSS_IRQ_MASK |\r\nDC_IRQ_STATUS | DC_IRQ_VIP_VSYNC_IRQ_STATUS);\r\nval = read_dc(par, DC_GENLK_CTL) & ~DC_GENLK_CTL_GENLK_EN;\r\nwrite_dc(par, DC_GENLK_CTL, val);\r\nval = read_dc(par, DC_CLR_KEY);\r\nwrite_dc(par, DC_CLR_KEY, val & ~DC_CLR_KEY_CLR_KEY_EN);\r\nwrite_fp(par, FP_PM, read_fp(par, FP_PM) & ~FP_PM_P);\r\nval = read_vp(par, VP_MISC) | VP_MISC_DACPWRDN;\r\nwrite_vp(par, VP_MISC, val);\r\nval = read_vp(par, VP_DCFG);\r\nwrite_vp(par, VP_DCFG, val & ~(VP_DCFG_CRT_EN | VP_DCFG_HSYNC_EN |\r\nVP_DCFG_VSYNC_EN | VP_DCFG_DAC_BL_EN));\r\ngcfg = read_dc(par, DC_GENERAL_CFG);\r\ngcfg &= ~(DC_GENERAL_CFG_CMPE | DC_GENERAL_CFG_DECE);\r\nwrite_dc(par, DC_GENERAL_CFG, gcfg);\r\nval = read_dc(par, DC_DISPLAY_CFG);\r\nval &= ~DC_DISPLAY_CFG_TGEN;\r\nwrite_dc(par, DC_DISPLAY_CFG, val);\r\nudelay(1000);\r\ngcfg &= ~DC_GENERAL_CFG_DFLE;\r\nwrite_dc(par, DC_GENERAL_CFG, gcfg);\r\ndo {\r\nval = read_gp(par, GP_BLT_STATUS);\r\n} while ((val & GP_BLT_STATUS_PB) || !(val & GP_BLT_STATUS_CE));\r\n}\r\nstatic void lx_graphics_enable(struct fb_info *info)\r\n{\r\nstruct lxfb_par *par = info->par;\r\nu32 temp, config;\r\nwrite_vp(par, VP_VRR, 0);\r\nconfig = read_vp(par, VP_DCFG);\r\nconfig &= ~(VP_DCFG_CRT_SYNC_SKW | VP_DCFG_PWR_SEQ_DELAY |\r\nVP_DCFG_CRT_HSYNC_POL | VP_DCFG_CRT_VSYNC_POL);\r\nconfig |= (VP_DCFG_CRT_SYNC_SKW_DEFAULT | VP_DCFG_PWR_SEQ_DELAY_DEFAULT\r\n| VP_DCFG_GV_GAM);\r\nif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\r\nconfig |= VP_DCFG_CRT_HSYNC_POL;\r\nif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\r\nconfig |= VP_DCFG_CRT_VSYNC_POL;\r\nif (par->output & OUTPUT_PANEL) {\r\nu32 msrlo, msrhi;\r\nwrite_fp(par, FP_PT1, 0);\r\ntemp = FP_PT2_SCRC;\r\nif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\r\ntemp |= FP_PT2_HSP;\r\nif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\r\ntemp |= FP_PT2_VSP;\r\nwrite_fp(par, FP_PT2, temp);\r\nwrite_fp(par, FP_DFC, FP_DFC_BC);\r\nmsrlo = MSR_LX_MSR_PADSEL_TFT_SEL_LOW;\r\nmsrhi = MSR_LX_MSR_PADSEL_TFT_SEL_HIGH;\r\nwrmsr(MSR_LX_MSR_PADSEL, msrlo, msrhi);\r\n}\r\nif (par->output & OUTPUT_CRT) {\r\nconfig |= VP_DCFG_CRT_EN | VP_DCFG_HSYNC_EN |\r\nVP_DCFG_VSYNC_EN | VP_DCFG_DAC_BL_EN;\r\n}\r\nwrite_vp(par, VP_DCFG, config);\r\nif (par->output & OUTPUT_CRT) {\r\ntemp = read_vp(par, VP_MISC);\r\ntemp &= ~(VP_MISC_DACPWRDN | VP_MISC_APWRDN);\r\nwrite_vp(par, VP_MISC, temp);\r\n}\r\nif (par->output & OUTPUT_PANEL)\r\nwrite_fp(par, FP_PM, read_fp(par, FP_PM) | FP_PM_P);\r\n}\r\nunsigned int lx_framebuffer_size(void)\r\n{\r\nunsigned int val;\r\nif (!cs5535_has_vsa2()) {\r\nuint32_t hi, lo;\r\nrdmsr(MSR_GLIU_P2D_RO0, lo, hi);\r\nval = ((hi & 0xff) << 12) | ((lo & 0xfff00000) >> 20);\r\nval -= (lo & 0x000fffff);\r\nval += 1;\r\nreturn (val << 12);\r\n}\r\noutw(VSA_VR_UNLOCK, VSA_VRC_INDEX);\r\noutw(VSA_VR_MEM_SIZE, VSA_VRC_INDEX);\r\nval = (unsigned int)(inw(VSA_VRC_DATA)) & 0xFE;\r\nreturn (val << 20);\r\n}\r\nvoid lx_set_mode(struct fb_info *info)\r\n{\r\nstruct lxfb_par *par = info->par;\r\nu64 msrval;\r\nunsigned int max, dv, val, size;\r\nunsigned int gcfg, dcfg;\r\nint hactive, hblankstart, hsyncstart, hsyncend, hblankend, htotal;\r\nint vactive, vblankstart, vsyncstart, vsyncend, vblankend, vtotal;\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\r\nlx_graphics_disable(info);\r\nlx_set_clock(info);\r\nrdmsrl(MSR_LX_GLD_MSR_CONFIG, msrval);\r\nmsrval &= ~MSR_LX_GLD_MSR_CONFIG_FMT;\r\nif (par->output & OUTPUT_PANEL) {\r\nmsrval |= MSR_LX_GLD_MSR_CONFIG_FMT_FP;\r\nif (par->output & OUTPUT_CRT)\r\nmsrval |= MSR_LX_GLD_MSR_CONFIG_FPC;\r\nelse\r\nmsrval &= ~MSR_LX_GLD_MSR_CONFIG_FPC;\r\n} else\r\nmsrval |= MSR_LX_GLD_MSR_CONFIG_FMT_CRT;\r\nwrmsrl(MSR_LX_GLD_MSR_CONFIG, msrval);\r\nwrite_dc(par, DC_FB_ST_OFFSET, 0);\r\nwrite_dc(par, DC_CB_ST_OFFSET, 0);\r\nwrite_dc(par, DC_CURS_ST_OFFSET, 0);\r\nval = read_dc(par, DC_GENLK_CTL);\r\nval &= ~(DC_GENLK_CTL_ALPHA_FLICK_EN | DC_GENLK_CTL_FLICK_EN |\r\nDC_GENLK_CTL_FLICK_SEL_MASK);\r\nwrite_dc(par, DC_GFX_SCALE, (0x4000 << 16) | 0x4000);\r\nwrite_dc(par, DC_IRQ_FILT_CTL, 0);\r\nwrite_dc(par, DC_GENLK_CTL, val);\r\nif (info->fix.line_length > 4096)\r\ndv = DC_DV_CTL_DV_LINE_SIZE_8K;\r\nelse if (info->fix.line_length > 2048)\r\ndv = DC_DV_CTL_DV_LINE_SIZE_4K;\r\nelse if (info->fix.line_length > 1024)\r\ndv = DC_DV_CTL_DV_LINE_SIZE_2K;\r\nelse\r\ndv = DC_DV_CTL_DV_LINE_SIZE_1K;\r\nmax = info->fix.line_length * info->var.yres;\r\nmax = (max + 0x3FF) & 0xFFFFFC00;\r\nwrite_dc(par, DC_DV_TOP, max | DC_DV_TOP_DV_TOP_EN);\r\nval = read_dc(par, DC_DV_CTL) & ~DC_DV_CTL_DV_LINE_SIZE;\r\nwrite_dc(par, DC_DV_CTL, val | dv);\r\nsize = info->var.xres * (info->var.bits_per_pixel >> 3);\r\nwrite_dc(par, DC_GFX_PITCH, info->fix.line_length >> 3);\r\nwrite_dc(par, DC_LINE_SIZE, (size + 7) >> 3);\r\nrdmsrl(MSR_LX_SPARE_MSR, msrval);\r\nmsrval &= ~(MSR_LX_SPARE_MSR_DIS_CFIFO_HGO\r\n| MSR_LX_SPARE_MSR_VFIFO_ARB_SEL\r\n| MSR_LX_SPARE_MSR_LOAD_WM_LPEN_M\r\n| MSR_LX_SPARE_MSR_WM_LPEN_OVRD);\r\nmsrval |= MSR_LX_SPARE_MSR_DIS_VIFO_WM |\r\nMSR_LX_SPARE_MSR_DIS_INIT_V_PRI;\r\nwrmsrl(MSR_LX_SPARE_MSR, msrval);\r\ngcfg = DC_GENERAL_CFG_DFLE;\r\ngcfg |= (0x6 << DC_GENERAL_CFG_DFHPSL_SHIFT) |\r\n(0xb << DC_GENERAL_CFG_DFHPEL_SHIFT);\r\ngcfg |= DC_GENERAL_CFG_FDTY;\r\ndcfg = DC_DISPLAY_CFG_VDEN;\r\ndcfg |= DC_DISPLAY_CFG_GDEN;\r\ndcfg |= DC_DISPLAY_CFG_TGEN;\r\ndcfg |= DC_DISPLAY_CFG_TRUP;\r\ndcfg |= DC_DISPLAY_CFG_PALB;\r\ndcfg |= DC_DISPLAY_CFG_VISL;\r\ndcfg |= DC_DISPLAY_CFG_DCEN;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\ndcfg |= DC_DISPLAY_CFG_DISP_MODE_8BPP;\r\nbreak;\r\ncase 16:\r\ndcfg |= DC_DISPLAY_CFG_DISP_MODE_16BPP;\r\nbreak;\r\ncase 32:\r\ncase 24:\r\ndcfg |= DC_DISPLAY_CFG_DISP_MODE_24BPP;\r\nbreak;\r\n}\r\nhactive = info->var.xres;\r\nhblankstart = hactive;\r\nhsyncstart = hblankstart + info->var.right_margin;\r\nhsyncend = hsyncstart + info->var.hsync_len;\r\nhblankend = hsyncend + info->var.left_margin;\r\nhtotal = hblankend;\r\nvactive = info->var.yres;\r\nvblankstart = vactive;\r\nvsyncstart = vblankstart + info->var.lower_margin;\r\nvsyncend = vsyncstart + info->var.vsync_len;\r\nvblankend = vsyncend + info->var.upper_margin;\r\nvtotal = vblankend;\r\nwrite_dc(par, DC_H_ACTIVE_TIMING, (hactive - 1) | ((htotal - 1) << 16));\r\nwrite_dc(par, DC_H_BLANK_TIMING,\r\n(hblankstart - 1) | ((hblankend - 1) << 16));\r\nwrite_dc(par, DC_H_SYNC_TIMING,\r\n(hsyncstart - 1) | ((hsyncend - 1) << 16));\r\nwrite_dc(par, DC_V_ACTIVE_TIMING, (vactive - 1) | ((vtotal - 1) << 16));\r\nwrite_dc(par, DC_V_BLANK_TIMING,\r\n(vblankstart - 1) | ((vblankend - 1) << 16));\r\nwrite_dc(par, DC_V_SYNC_TIMING,\r\n(vsyncstart - 1) | ((vsyncend - 1) << 16));\r\nwrite_dc(par, DC_FB_ACTIVE,\r\n(info->var.xres - 1) << 16 | (info->var.yres - 1));\r\nlx_graphics_enable(info);\r\nwrite_dc(par, DC_DISPLAY_CFG, dcfg);\r\nwrite_dc(par, DC_ARB_CFG, 0);\r\nwrite_dc(par, DC_GENERAL_CFG, gcfg);\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\r\n}\r\nvoid lx_set_palette_reg(struct fb_info *info, unsigned regno,\r\nunsigned red, unsigned green, unsigned blue)\r\n{\r\nstruct lxfb_par *par = info->par;\r\nint val;\r\nval = (red << 8) & 0xff0000;\r\nval |= (green) & 0x00ff00;\r\nval |= (blue >> 8) & 0x0000ff;\r\nwrite_dc(par, DC_PAL_ADDRESS, regno);\r\nwrite_dc(par, DC_PAL_DATA, val);\r\n}\r\nint lx_blank_display(struct fb_info *info, int blank_mode)\r\n{\r\nstruct lxfb_par *par = info->par;\r\nu32 dcfg, misc, fp_pm;\r\nint blank, hsync, vsync;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nblank = 0; hsync = 1; vsync = 1;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nblank = 1; hsync = 1; vsync = 1;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nblank = 1; hsync = 1; vsync = 0;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nblank = 1; hsync = 0; vsync = 1;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nblank = 1; hsync = 0; vsync = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndcfg = read_vp(par, VP_DCFG);\r\ndcfg &= ~(VP_DCFG_DAC_BL_EN | VP_DCFG_HSYNC_EN | VP_DCFG_VSYNC_EN |\r\nVP_DCFG_CRT_EN);\r\nif (!blank)\r\ndcfg |= VP_DCFG_DAC_BL_EN | VP_DCFG_CRT_EN;\r\nif (hsync)\r\ndcfg |= VP_DCFG_HSYNC_EN;\r\nif (vsync)\r\ndcfg |= VP_DCFG_VSYNC_EN;\r\nwrite_vp(par, VP_DCFG, dcfg);\r\nmisc = read_vp(par, VP_MISC);\r\nif (vsync && hsync)\r\nmisc &= ~VP_MISC_DACPWRDN;\r\nelse\r\nmisc |= VP_MISC_DACPWRDN;\r\nwrite_vp(par, VP_MISC, misc);\r\nif (par->output & OUTPUT_PANEL) {\r\nfp_pm = read_fp(par, FP_PM);\r\nif (blank_mode == FB_BLANK_POWERDOWN)\r\nfp_pm &= ~FP_PM_P;\r\nelse\r\nfp_pm |= FP_PM_P;\r\nwrite_fp(par, FP_PM, fp_pm);\r\n}\r\nreturn 0;\r\n}\r\nstatic void lx_save_regs(struct lxfb_par *par)\r\n{\r\nuint32_t filt;\r\nint i;\r\ndo {\r\ni = read_gp(par, GP_BLT_STATUS);\r\n} while ((i & GP_BLT_STATUS_PB) || !(i & GP_BLT_STATUS_CE));\r\nrdmsrl(MSR_LX_MSR_PADSEL, par->msr.padsel);\r\nrdmsrl(MSR_GLCP_DOTPLL, par->msr.dotpll);\r\nrdmsrl(MSR_LX_GLD_MSR_CONFIG, par->msr.dfglcfg);\r\nrdmsrl(MSR_LX_SPARE_MSR, par->msr.dcspare);\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\r\nmemcpy(par->gp, par->gp_regs, sizeof(par->gp));\r\nmemcpy(par->dc, par->dc_regs, sizeof(par->dc));\r\nmemcpy(par->vp, par->vp_regs, sizeof(par->vp));\r\nmemcpy(par->fp, par->vp_regs + VP_FP_START, sizeof(par->fp));\r\nwrite_dc(par, DC_PAL_ADDRESS, 0);\r\nfor (i = 0; i < ARRAY_SIZE(par->dc_pal); i++)\r\npar->dc_pal[i] = read_dc(par, DC_PAL_DATA);\r\nwrite_vp(par, VP_PAR, 0);\r\nfor (i = 0; i < ARRAY_SIZE(par->vp_pal); i++)\r\npar->vp_pal[i] = read_vp(par, VP_PDR);\r\nfilt = par->dc[DC_IRQ_FILT_CTL] | DC_IRQ_FILT_CTL_H_FILT_SEL;\r\nfor (i = 0; i < ARRAY_SIZE(par->hcoeff); i += 2) {\r\nwrite_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);\r\npar->hcoeff[i] = read_dc(par, DC_FILT_COEFF1);\r\npar->hcoeff[i + 1] = read_dc(par, DC_FILT_COEFF2);\r\n}\r\nfilt &= ~DC_IRQ_FILT_CTL_H_FILT_SEL;\r\nfor (i = 0; i < ARRAY_SIZE(par->vcoeff); i++) {\r\nwrite_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);\r\npar->vcoeff[i] = read_dc(par, DC_FILT_COEFF1);\r\n}\r\nmemcpy(par->vp_coeff, par->vp_regs + VP_VCR, sizeof(par->vp_coeff));\r\n}\r\nstatic void lx_restore_gfx_proc(struct lxfb_par *par)\r\n{\r\nint i;\r\nwrite_gp(par, GP_RASTER_MODE, par->gp[GP_RASTER_MODE]);\r\nfor (i = 0; i < ARRAY_SIZE(par->gp); i++) {\r\nswitch (i) {\r\ncase GP_RASTER_MODE:\r\ncase GP_VECTOR_MODE:\r\ncase GP_BLT_MODE:\r\ncase GP_BLT_STATUS:\r\ncase GP_HST_SRC:\r\ncase GP_LUT_INDEX:\r\ncase GP_LUT_DATA:\r\nbreak;\r\ndefault:\r\nwrite_gp(par, i, par->gp[i]);\r\n}\r\n}\r\n}\r\nstatic void lx_restore_display_ctlr(struct lxfb_par *par)\r\n{\r\nuint32_t filt;\r\nint i;\r\nwrmsrl(MSR_LX_SPARE_MSR, par->msr.dcspare);\r\nfor (i = 0; i < ARRAY_SIZE(par->dc); i++) {\r\nswitch (i) {\r\ncase DC_UNLOCK:\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\r\nbreak;\r\ncase DC_GENERAL_CFG:\r\ncase DC_DISPLAY_CFG:\r\nwrite_dc(par, i, 0);\r\nbreak;\r\ncase DC_DV_CTL:\r\nwrite_dc(par, i, par->dc[i] | DC_DV_CTL_CLEAR_DV_RAM);\r\ncase DC_RSVD_1:\r\ncase DC_RSVD_2:\r\ncase DC_RSVD_3:\r\ncase DC_LINE_CNT:\r\ncase DC_PAL_ADDRESS:\r\ncase DC_PAL_DATA:\r\ncase DC_DFIFO_DIAG:\r\ncase DC_CFIFO_DIAG:\r\ncase DC_FILT_COEFF1:\r\ncase DC_FILT_COEFF2:\r\ncase DC_RSVD_4:\r\ncase DC_RSVD_5:\r\nbreak;\r\ndefault:\r\nwrite_dc(par, i, par->dc[i]);\r\n}\r\n}\r\nwrite_dc(par, DC_PAL_ADDRESS, 0);\r\nfor (i = 0; i < ARRAY_SIZE(par->dc_pal); i++)\r\nwrite_dc(par, DC_PAL_DATA, par->dc_pal[i]);\r\nfilt = par->dc[DC_IRQ_FILT_CTL] | DC_IRQ_FILT_CTL_H_FILT_SEL;\r\nfor (i = 0; i < ARRAY_SIZE(par->hcoeff); i += 2) {\r\nwrite_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);\r\nwrite_dc(par, DC_FILT_COEFF1, par->hcoeff[i]);\r\nwrite_dc(par, DC_FILT_COEFF2, par->hcoeff[i + 1]);\r\n}\r\nfilt &= ~DC_IRQ_FILT_CTL_H_FILT_SEL;\r\nfor (i = 0; i < ARRAY_SIZE(par->vcoeff); i++) {\r\nwrite_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);\r\nwrite_dc(par, DC_FILT_COEFF1, par->vcoeff[i]);\r\n}\r\n}\r\nstatic void lx_restore_video_proc(struct lxfb_par *par)\r\n{\r\nint i;\r\nwrmsrl(MSR_LX_GLD_MSR_CONFIG, par->msr.dfglcfg);\r\nwrmsrl(MSR_LX_MSR_PADSEL, par->msr.padsel);\r\nfor (i = 0; i < ARRAY_SIZE(par->vp); i++) {\r\nswitch (i) {\r\ncase VP_VCFG:\r\ncase VP_DCFG:\r\ncase VP_PAR:\r\ncase VP_PDR:\r\ncase VP_CCS:\r\ncase VP_RSVD_0:\r\ncase VP_RSVD_1:\r\ncase VP_CRC32:\r\nbreak;\r\ndefault:\r\nwrite_vp(par, i, par->vp[i]);\r\n}\r\n}\r\nwrite_vp(par, VP_PAR, 0);\r\nfor (i = 0; i < ARRAY_SIZE(par->vp_pal); i++)\r\nwrite_vp(par, VP_PDR, par->vp_pal[i]);\r\nmemcpy(par->vp_regs + VP_VCR, par->vp_coeff, sizeof(par->vp_coeff));\r\n}\r\nstatic void lx_restore_regs(struct lxfb_par *par)\r\n{\r\nint i;\r\nlx_set_dotpll((u32) (par->msr.dotpll >> 32));\r\nlx_restore_gfx_proc(par);\r\nlx_restore_display_ctlr(par);\r\nlx_restore_video_proc(par);\r\nfor (i = 0; i < ARRAY_SIZE(par->fp); i++) {\r\nswitch (i) {\r\ncase FP_PM:\r\ncase FP_RSVD_0:\r\ncase FP_RSVD_1:\r\ncase FP_RSVD_2:\r\ncase FP_RSVD_3:\r\ncase FP_RSVD_4:\r\nbreak;\r\ndefault:\r\nwrite_fp(par, i, par->fp[i]);\r\n}\r\n}\r\nif (par->fp[FP_PM] & FP_PM_P) {\r\nif (!(read_fp(par, FP_PM) &\r\n(FP_PM_PANEL_ON|FP_PM_PANEL_PWR_UP)))\r\nwrite_fp(par, FP_PM, par->fp[FP_PM]);\r\n} else {\r\nif (!(read_fp(par, FP_PM) &\r\n(FP_PM_PANEL_OFF|FP_PM_PANEL_PWR_DOWN)))\r\nwrite_fp(par, FP_PM, par->fp[FP_PM]);\r\n}\r\nwrite_vp(par, VP_VCFG, par->vp[VP_VCFG]);\r\nwrite_vp(par, VP_DCFG, par->vp[VP_DCFG]);\r\nwrite_dc(par, DC_DISPLAY_CFG, par->dc[DC_DISPLAY_CFG]);\r\nwrite_dc(par, DC_GENERAL_CFG, par->dc[DC_GENERAL_CFG]);\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\r\n}\r\nint lx_powerdown(struct fb_info *info)\r\n{\r\nstruct lxfb_par *par = info->par;\r\nif (par->powered_down)\r\nreturn 0;\r\nlx_save_regs(par);\r\nlx_graphics_disable(info);\r\npar->powered_down = 1;\r\nreturn 0;\r\n}\r\nint lx_powerup(struct fb_info *info)\r\n{\r\nstruct lxfb_par *par = info->par;\r\nif (!par->powered_down)\r\nreturn 0;\r\nlx_restore_regs(par);\r\npar->powered_down = 0;\r\nreturn 0;\r\n}
