static char *split_if_spec(char *str, ...)\r\n{\r\nchar **arg, *end;\r\nva_list ap;\r\nva_start(ap, str);\r\nwhile ((arg = va_arg(ap, char**)) != NULL) {\r\nif (*str == '\0')\r\nreturn NULL;\r\nend = strchr(str, ',');\r\nif (end != str)\r\n*arg = str;\r\nif (end == NULL)\r\nreturn NULL;\r\n*end++ = '\0';\r\nstr = end;\r\n}\r\nva_end(ap);\r\nreturn str;\r\n}\r\nstatic void setup_etheraddr(struct net_device *dev, char *str)\r\n{\r\nunsigned char *addr = dev->dev_addr;\r\nif (str == NULL)\r\ngoto random;\r\nif (!mac_pton(str, addr)) {\r\npr_err("%s: failed to parse '%s' as an ethernet address\n",\r\ndev->name, str);\r\ngoto random;\r\n}\r\nif (is_multicast_ether_addr(addr)) {\r\npr_err("%s: attempt to assign a multicast ethernet address\n",\r\ndev->name);\r\ngoto random;\r\n}\r\nif (!is_valid_ether_addr(addr)) {\r\npr_err("%s: attempt to assign an invalid ethernet address\n",\r\ndev->name);\r\ngoto random;\r\n}\r\nif (!is_local_ether_addr(addr))\r\npr_warn("%s: assigning a globally valid ethernet address\n",\r\ndev->name);\r\nreturn;\r\nrandom:\r\npr_info("%s: choosing a random ethernet address\n",\r\ndev->name);\r\neth_hw_addr_random(dev);\r\n}\r\nstatic int tuntap_open(struct iss_net_private *lp)\r\n{\r\nstruct ifreq ifr;\r\nchar *dev_name = lp->tp.info.tuntap.dev_name;\r\nint err = -EINVAL;\r\nint fd;\r\nfd = simc_open("/dev/net/tun", 02, 0);\r\nif (fd < 0) {\r\npr_err("%s: failed to open /dev/net/tun, returned %d (errno = %d)\n",\r\nlp->dev->name, fd, errno);\r\nreturn fd;\r\n}\r\nmemset(&ifr, 0, sizeof(ifr));\r\nifr.ifr_flags = IFF_TAP | IFF_NO_PI;\r\nstrlcpy(ifr.ifr_name, dev_name, sizeof(ifr.ifr_name));\r\nerr = simc_ioctl(fd, TUNSETIFF, &ifr);\r\nif (err < 0) {\r\npr_err("%s: failed to set interface %s, returned %d (errno = %d)\n",\r\nlp->dev->name, dev_name, err, errno);\r\nsimc_close(fd);\r\nreturn err;\r\n}\r\nlp->tp.info.tuntap.fd = fd;\r\nreturn err;\r\n}\r\nstatic void tuntap_close(struct iss_net_private *lp)\r\n{\r\nsimc_close(lp->tp.info.tuntap.fd);\r\nlp->tp.info.tuntap.fd = -1;\r\n}\r\nstatic int tuntap_read(struct iss_net_private *lp, struct sk_buff **skb)\r\n{\r\nreturn simc_read(lp->tp.info.tuntap.fd,\r\n(*skb)->data, (*skb)->dev->mtu + ETH_HEADER_OTHER);\r\n}\r\nstatic int tuntap_write(struct iss_net_private *lp, struct sk_buff **skb)\r\n{\r\nreturn simc_write(lp->tp.info.tuntap.fd, (*skb)->data, (*skb)->len);\r\n}\r\nunsigned short tuntap_protocol(struct sk_buff *skb)\r\n{\r\nreturn eth_type_trans(skb, skb->dev);\r\n}\r\nstatic int tuntap_poll(struct iss_net_private *lp)\r\n{\r\nreturn simc_poll(lp->tp.info.tuntap.fd);\r\n}\r\nstatic int tuntap_probe(struct iss_net_private *lp, int index, char *init)\r\n{\r\nstruct net_device *dev = lp->dev;\r\nchar *dev_name = NULL, *mac_str = NULL, *rem = NULL;\r\nif (strncmp(init, TRANSPORT_TUNTAP_NAME,\r\nsizeof(TRANSPORT_TUNTAP_NAME) - 1))\r\nreturn 0;\r\ninit += sizeof(TRANSPORT_TUNTAP_NAME) - 1;\r\nif (*init == ',') {\r\nrem = split_if_spec(init + 1, &mac_str, &dev_name);\r\nif (rem != NULL) {\r\npr_err("%s: extra garbage on specification : '%s'\n",\r\ndev->name, rem);\r\nreturn 0;\r\n}\r\n} else if (*init != '\0') {\r\npr_err("%s: invalid argument: %s. Skipping device!\n",\r\ndev->name, init);\r\nreturn 0;\r\n}\r\nif (!dev_name) {\r\npr_err("%s: missing tuntap device name\n", dev->name);\r\nreturn 0;\r\n}\r\nstrlcpy(lp->tp.info.tuntap.dev_name, dev_name,\r\nsizeof(lp->tp.info.tuntap.dev_name));\r\nsetup_etheraddr(dev, mac_str);\r\nlp->mtu = TRANSPORT_TUNTAP_MTU;\r\nlp->tp.info.tuntap.fd = -1;\r\nlp->tp.open = tuntap_open;\r\nlp->tp.close = tuntap_close;\r\nlp->tp.read = tuntap_read;\r\nlp->tp.write = tuntap_write;\r\nlp->tp.protocol = tuntap_protocol;\r\nlp->tp.poll = tuntap_poll;\r\nreturn 1;\r\n}\r\nstatic int iss_net_rx(struct net_device *dev)\r\n{\r\nstruct iss_net_private *lp = netdev_priv(dev);\r\nint pkt_len;\r\nstruct sk_buff *skb;\r\nif (lp->tp.poll(lp) == 0)\r\nreturn 0;\r\nskb = dev_alloc_skb(dev->mtu + 2 + ETH_HEADER_OTHER);\r\nif (skb == NULL) {\r\nlp->stats.rx_dropped++;\r\nreturn 0;\r\n}\r\nskb_reserve(skb, 2);\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\npkt_len = lp->tp.read(lp, &skb);\r\nskb_put(skb, pkt_len);\r\nif (pkt_len > 0) {\r\nskb_trim(skb, pkt_len);\r\nskb->protocol = lp->tp.protocol(skb);\r\nlp->stats.rx_bytes += skb->len;\r\nlp->stats.rx_packets++;\r\nnetif_rx_ni(skb);\r\nreturn pkt_len;\r\n}\r\nkfree_skb(skb);\r\nreturn pkt_len;\r\n}\r\nstatic int iss_net_poll(void)\r\n{\r\nstruct list_head *ele;\r\nint err, ret = 0;\r\nspin_lock(&opened_lock);\r\nlist_for_each(ele, &opened) {\r\nstruct iss_net_private *lp;\r\nlp = list_entry(ele, struct iss_net_private, opened_list);\r\nif (!netif_running(lp->dev))\r\nbreak;\r\nspin_lock(&lp->lock);\r\nwhile ((err = iss_net_rx(lp->dev)) > 0)\r\nret++;\r\nspin_unlock(&lp->lock);\r\nif (err < 0) {\r\npr_err("Device '%s' read returned %d, shutting it down\n",\r\nlp->dev->name, err);\r\ndev_close(lp->dev);\r\n} else {\r\n}\r\n}\r\nspin_unlock(&opened_lock);\r\nreturn ret;\r\n}\r\nstatic void iss_net_timer(unsigned long priv)\r\n{\r\nstruct iss_net_private *lp = (struct iss_net_private *)priv;\r\nspin_lock(&lp->lock);\r\niss_net_poll();\r\nmod_timer(&lp->timer, jiffies + lp->timer_val);\r\nspin_unlock(&lp->lock);\r\n}\r\nstatic int iss_net_open(struct net_device *dev)\r\n{\r\nstruct iss_net_private *lp = netdev_priv(dev);\r\nint err;\r\nspin_lock(&lp->lock);\r\nerr = lp->tp.open(lp);\r\nif (err < 0)\r\ngoto out;\r\nnetif_start_queue(dev);\r\nwhile ((err = iss_net_rx(dev)) > 0)\r\n;\r\nspin_lock(&opened_lock);\r\nlist_add(&lp->opened_list, &opened);\r\nspin_unlock(&opened_lock);\r\ninit_timer(&lp->timer);\r\nlp->timer_val = ISS_NET_TIMER_VALUE;\r\nlp->timer.data = (unsigned long) lp;\r\nlp->timer.function = iss_net_timer;\r\nmod_timer(&lp->timer, jiffies + lp->timer_val);\r\nout:\r\nspin_unlock(&lp->lock);\r\nreturn err;\r\n}\r\nstatic int iss_net_close(struct net_device *dev)\r\n{\r\nstruct iss_net_private *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nspin_lock(&lp->lock);\r\nspin_lock(&opened_lock);\r\nlist_del(&opened);\r\nspin_unlock(&opened_lock);\r\ndel_timer_sync(&lp->timer);\r\nlp->tp.close(lp);\r\nspin_unlock(&lp->lock);\r\nreturn 0;\r\n}\r\nstatic int iss_net_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct iss_net_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nint len;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nlen = lp->tp.write(lp, &skb);\r\nif (len == skb->len) {\r\nlp->stats.tx_packets++;\r\nlp->stats.tx_bytes += skb->len;\r\ndev->trans_start = jiffies;\r\nnetif_start_queue(dev);\r\nnetif_wake_queue(dev);\r\n} else if (len == 0) {\r\nnetif_start_queue(dev);\r\nlp->stats.tx_dropped++;\r\n} else {\r\nnetif_start_queue(dev);\r\npr_err("%s: %s failed(%d)\n", dev->name, __func__, len);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *iss_net_get_stats(struct net_device *dev)\r\n{\r\nstruct iss_net_private *lp = netdev_priv(dev);\r\nreturn &lp->stats;\r\n}\r\nstatic void iss_net_set_multicast_list(struct net_device *dev)\r\n{\r\n}\r\nstatic void iss_net_tx_timeout(struct net_device *dev)\r\n{\r\n}\r\nstatic int iss_net_set_mac(struct net_device *dev, void *addr)\r\n{\r\nstruct iss_net_private *lp = netdev_priv(dev);\r\nstruct sockaddr *hwaddr = addr;\r\nif (!is_valid_ether_addr(hwaddr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nspin_lock(&lp->lock);\r\nmemcpy(dev->dev_addr, hwaddr->sa_data, ETH_ALEN);\r\nspin_unlock(&lp->lock);\r\nreturn 0;\r\n}\r\nstatic int iss_net_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid iss_net_user_timer_expire(unsigned long _conn)\r\n{\r\n}\r\nstatic int iss_net_configure(int index, char *init)\r\n{\r\nstruct net_device *dev;\r\nstruct iss_net_private *lp;\r\nint err;\r\ndev = alloc_etherdev(sizeof(*lp));\r\nif (dev == NULL) {\r\npr_err("eth_configure: failed to allocate device\n");\r\nreturn 1;\r\n}\r\nlp = netdev_priv(dev);\r\n*lp = (struct iss_net_private) {\r\n.device_list = LIST_HEAD_INIT(lp->device_list),\r\n.opened_list = LIST_HEAD_INIT(lp->opened_list),\r\n.lock = __SPIN_LOCK_UNLOCKED(lp.lock),\r\n.dev = dev,\r\n.index = index,\r\n};\r\nsnprintf(dev->name, sizeof(dev->name), "eth%d", index);\r\nif (!tuntap_probe(lp, index, init)) {\r\npr_err("%s: invalid arguments. Skipping device!\n",\r\ndev->name);\r\ngoto errout;\r\n}\r\npr_info("Netdevice %d (%pM)\n", index, dev->dev_addr);\r\nif (!driver_registered) {\r\nplatform_driver_register(&iss_net_driver);\r\ndriver_registered = 1;\r\n}\r\nspin_lock(&devices_lock);\r\nlist_add(&lp->device_list, &devices);\r\nspin_unlock(&devices_lock);\r\nlp->pdev.id = index;\r\nlp->pdev.name = DRIVER_NAME;\r\nplatform_device_register(&lp->pdev);\r\nSET_NETDEV_DEV(dev, &lp->pdev.dev);\r\ndev->netdev_ops = &iss_netdev_ops;\r\ndev->mtu = lp->mtu;\r\ndev->watchdog_timeo = (HZ >> 1);\r\ndev->irq = -1;\r\nrtnl_lock();\r\nerr = register_netdevice(dev);\r\nrtnl_unlock();\r\nif (err) {\r\npr_err("%s: error registering net device!\n", dev->name);\r\nfree_netdev(dev);\r\nreturn 1;\r\n}\r\ninit_timer(&lp->tl);\r\nlp->tl.function = iss_net_user_timer_expire;\r\nreturn 0;\r\nerrout:\r\nreturn -EIO;\r\n}\r\nstatic int __init iss_net_setup(char *str)\r\n{\r\nstruct iss_net_private *device = NULL;\r\nstruct iss_net_init *new;\r\nstruct list_head *ele;\r\nchar *end;\r\nint rc;\r\nunsigned n;\r\nend = strchr(str, '=');\r\nif (!end) {\r\nprintk(ERR "Expected '=' after device number\n");\r\nreturn 1;\r\n}\r\n*end = 0;\r\nrc = kstrtouint(str, 0, &n);\r\n*end = '=';\r\nif (rc < 0) {\r\nprintk(ERR "Failed to parse '%s'\n", str);\r\nreturn 1;\r\n}\r\nstr = end;\r\nspin_lock(&devices_lock);\r\nlist_for_each(ele, &devices) {\r\ndevice = list_entry(ele, struct iss_net_private, device_list);\r\nif (device->index == n)\r\nbreak;\r\n}\r\nspin_unlock(&devices_lock);\r\nif (device && device->index == n) {\r\nprintk(ERR "Device %u already configured\n", n);\r\nreturn 1;\r\n}\r\nnew = alloc_bootmem(sizeof(*new));\r\nif (new == NULL) {\r\nprintk(ERR "Alloc_bootmem failed\n");\r\nreturn 1;\r\n}\r\nINIT_LIST_HEAD(&new->list);\r\nnew->index = n;\r\nnew->init = str + 1;\r\nlist_add_tail(&new->list, &eth_cmd_line);\r\nreturn 1;\r\n}\r\nstatic int iss_net_init(void)\r\n{\r\nstruct list_head *ele, *next;\r\nlist_for_each_safe(ele, next, &eth_cmd_line) {\r\nstruct iss_net_init *eth;\r\neth = list_entry(ele, struct iss_net_init, list);\r\niss_net_configure(eth->index, eth->init);\r\n}\r\nreturn 1;\r\n}
