static inline int set_av_attr(struct ocrdma_dev *dev, struct ocrdma_ah *ah,\r\nstruct ib_ah_attr *attr, int pdid)\r\n{\r\nint status = 0;\r\nu16 vlan_tag; bool vlan_enabled = false;\r\nstruct ocrdma_eth_vlan eth;\r\nstruct ocrdma_grh grh;\r\nint eth_sz;\r\nmemset(&eth, 0, sizeof(eth));\r\nmemset(&grh, 0, sizeof(grh));\r\nah->sgid_index = attr->grh.sgid_index;\r\nvlan_tag = attr->vlan_id;\r\nif (!vlan_tag || (vlan_tag > 0xFFF))\r\nvlan_tag = dev->pvid;\r\nif (vlan_tag && (vlan_tag < 0x1000)) {\r\neth.eth_type = cpu_to_be16(0x8100);\r\neth.roce_eth_type = cpu_to_be16(OCRDMA_ROCE_ETH_TYPE);\r\nvlan_tag |= (attr->sl & 7) << 13;\r\neth.vlan_tag = cpu_to_be16(vlan_tag);\r\neth_sz = sizeof(struct ocrdma_eth_vlan);\r\nvlan_enabled = true;\r\n} else {\r\neth.eth_type = cpu_to_be16(OCRDMA_ROCE_ETH_TYPE);\r\neth_sz = sizeof(struct ocrdma_eth_basic);\r\n}\r\nmemcpy(&eth.smac[0], &dev->nic_info.mac_addr[0], ETH_ALEN);\r\nmemcpy(&eth.dmac[0], attr->dmac, ETH_ALEN);\r\nstatus = ocrdma_resolve_dmac(dev, attr, &eth.dmac[0]);\r\nif (status)\r\nreturn status;\r\nstatus = ocrdma_query_gid(&dev->ibdev, 1, attr->grh.sgid_index,\r\n(union ib_gid *)&grh.sgid[0]);\r\nif (status)\r\nreturn status;\r\ngrh.tclass_flow = cpu_to_be32((6 << 28) |\r\n(attr->grh.traffic_class << 24) |\r\nattr->grh.flow_label);\r\ngrh.pdid_hoplimit = cpu_to_be32((pdid << 16) |\r\n(0x1b << 8) | attr->grh.hop_limit);\r\nmemcpy(&grh.dgid[0], attr->grh.dgid.raw, sizeof(attr->grh.dgid.raw));\r\nmemcpy(&ah->av->eth_hdr, &eth, eth_sz);\r\nmemcpy((u8 *)ah->av + eth_sz, &grh, sizeof(struct ocrdma_grh));\r\nif (vlan_enabled)\r\nah->av->valid |= OCRDMA_AV_VLAN_VALID;\r\nah->av->valid = cpu_to_le32(ah->av->valid);\r\nreturn status;\r\n}\r\nstruct ib_ah *ocrdma_create_ah(struct ib_pd *ibpd, struct ib_ah_attr *attr)\r\n{\r\nu32 *ahid_addr;\r\nint status;\r\nstruct ocrdma_ah *ah;\r\nstruct ocrdma_pd *pd = get_ocrdma_pd(ibpd);\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(ibpd->device);\r\nif (!(attr->ah_flags & IB_AH_GRH))\r\nreturn ERR_PTR(-EINVAL);\r\nah = kzalloc(sizeof(*ah), GFP_ATOMIC);\r\nif (!ah)\r\nreturn ERR_PTR(-ENOMEM);\r\nstatus = ocrdma_alloc_av(dev, ah);\r\nif (status)\r\ngoto av_err;\r\nstatus = set_av_attr(dev, ah, attr, pd->id);\r\nif (status)\r\ngoto av_conf_err;\r\nif ((pd->uctx) && (pd->uctx->ah_tbl.va)) {\r\nahid_addr = pd->uctx->ah_tbl.va + attr->dlid;\r\n*ahid_addr = ah->id;\r\n}\r\nreturn &ah->ibah;\r\nav_conf_err:\r\nocrdma_free_av(dev, ah);\r\nav_err:\r\nkfree(ah);\r\nreturn ERR_PTR(status);\r\n}\r\nint ocrdma_destroy_ah(struct ib_ah *ibah)\r\n{\r\nstruct ocrdma_ah *ah = get_ocrdma_ah(ibah);\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(ibah->device);\r\nocrdma_free_av(dev, ah);\r\nkfree(ah);\r\nreturn 0;\r\n}\r\nint ocrdma_query_ah(struct ib_ah *ibah, struct ib_ah_attr *attr)\r\n{\r\nstruct ocrdma_ah *ah = get_ocrdma_ah(ibah);\r\nstruct ocrdma_av *av = ah->av;\r\nstruct ocrdma_grh *grh;\r\nattr->ah_flags |= IB_AH_GRH;\r\nif (ah->av->valid & Bit(1)) {\r\ngrh = (struct ocrdma_grh *)((u8 *)ah->av +\r\nsizeof(struct ocrdma_eth_vlan));\r\nattr->sl = be16_to_cpu(av->eth_hdr.vlan_tag) >> 13;\r\n} else {\r\ngrh = (struct ocrdma_grh *)((u8 *)ah->av +\r\nsizeof(struct ocrdma_eth_basic));\r\nattr->sl = 0;\r\n}\r\nmemcpy(&attr->grh.dgid.raw[0], &grh->dgid[0], sizeof(grh->dgid));\r\nattr->grh.sgid_index = ah->sgid_index;\r\nattr->grh.hop_limit = be32_to_cpu(grh->pdid_hoplimit) & 0xff;\r\nattr->grh.traffic_class = be32_to_cpu(grh->tclass_flow) >> 24;\r\nattr->grh.flow_label = be32_to_cpu(grh->tclass_flow) & 0x00ffffffff;\r\nreturn 0;\r\n}\r\nint ocrdma_modify_ah(struct ib_ah *ibah, struct ib_ah_attr *attr)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint ocrdma_process_mad(struct ib_device *ibdev,\r\nint process_mad_flags,\r\nu8 port_num,\r\nstruct ib_wc *in_wc,\r\nstruct ib_grh *in_grh,\r\nstruct ib_mad *in_mad, struct ib_mad *out_mad)\r\n{\r\nreturn IB_MAD_RESULT_SUCCESS;\r\n}
