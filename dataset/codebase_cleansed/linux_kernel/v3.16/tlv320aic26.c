static int aic26_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct aic26 *aic26 = snd_soc_codec_get_drvdata(codec);\r\nint fsref, divisor, wlen, pval, jval, dval, qval;\r\nu16 reg;\r\ndev_dbg(&aic26->spi->dev, "aic26_hw_params(substream=%p, params=%p)\n",\r\nsubstream, params);\r\ndev_dbg(&aic26->spi->dev, "rate=%i format=%i\n", params_rate(params),\r\nparams_format(params));\r\nswitch (params_rate(params)) {\r\ncase 8000: fsref = 48000; divisor = AIC26_DIV_6; break;\r\ncase 11025: fsref = 44100; divisor = AIC26_DIV_4; break;\r\ncase 12000: fsref = 48000; divisor = AIC26_DIV_4; break;\r\ncase 16000: fsref = 48000; divisor = AIC26_DIV_3; break;\r\ncase 22050: fsref = 44100; divisor = AIC26_DIV_2; break;\r\ncase 24000: fsref = 48000; divisor = AIC26_DIV_2; break;\r\ncase 32000: fsref = 48000; divisor = AIC26_DIV_1_5; break;\r\ncase 44100: fsref = 44100; divisor = AIC26_DIV_1; break;\r\ncase 48000: fsref = 48000; divisor = AIC26_DIV_1; break;\r\ndefault:\r\ndev_dbg(&aic26->spi->dev, "bad rate\n"); return -EINVAL;\r\n}\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8: wlen = AIC26_WLEN_16; break;\r\ncase SNDRV_PCM_FORMAT_S16_BE: wlen = AIC26_WLEN_16; break;\r\ncase SNDRV_PCM_FORMAT_S24_BE: wlen = AIC26_WLEN_24; break;\r\ncase SNDRV_PCM_FORMAT_S32_BE: wlen = AIC26_WLEN_32; break;\r\ndefault:\r\ndev_dbg(&aic26->spi->dev, "bad format\n"); return -EINVAL;\r\n}\r\npval = 1;\r\njval = fsref / (aic26->mclk / 2048);\r\ndval = fsref - (jval * (aic26->mclk / 2048));\r\ndval = (10000 * dval) / (aic26->mclk / 2048);\r\ndev_dbg(&aic26->spi->dev, "Setting PLLM to %d.%04d\n", jval, dval);\r\nqval = 0;\r\nreg = 0x8000 | qval << 11 | pval << 8 | jval << 2;\r\nsnd_soc_write(codec, AIC26_REG_PLL_PROG1, reg);\r\nreg = dval << 2;\r\nsnd_soc_write(codec, AIC26_REG_PLL_PROG2, reg);\r\nif (aic26->master)\r\nreg = 0x0800;\r\nif (fsref == 48000)\r\nreg = 0x2000;\r\nsnd_soc_update_bits(codec, AIC26_REG_AUDIO_CTRL3, 0xf800, reg);\r\nreg = wlen | aic26->datfm | (divisor << 3) | divisor;\r\nsnd_soc_update_bits(codec, AIC26_REG_AUDIO_CTRL1, 0xfff, reg);\r\nreturn 0;\r\n}\r\nstatic int aic26_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct aic26 *aic26 = snd_soc_codec_get_drvdata(codec);\r\nu16 reg;\r\ndev_dbg(&aic26->spi->dev, "aic26_mute(dai=%p, mute=%i)\n",\r\ndai, mute);\r\nif (mute)\r\nreg = 0x8080;\r\nelse\r\nreg = 0;\r\nsnd_soc_update_bits(codec, AIC26_REG_DAC_GAIN, 0x8000, reg);\r\nreturn 0;\r\n}\r\nstatic int aic26_set_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic26 *aic26 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(&aic26->spi->dev, "aic26_set_sysclk(dai=%p, clk_id==%i,"\r\n" freq=%i, dir=%i)\n",\r\ncodec_dai, clk_id, freq, dir);\r\nif ((freq < 2000000) || (freq > 50000000))\r\nreturn -EINVAL;\r\naic26->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int aic26_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic26 *aic26 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(&aic26->spi->dev, "aic26_set_fmt(dai=%p, fmt==%i)\n",\r\ncodec_dai, fmt);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM: aic26->master = 1; break;\r\ncase SND_SOC_DAIFMT_CBS_CFS: aic26->master = 0; break;\r\ndefault:\r\ndev_dbg(&aic26->spi->dev, "bad master\n"); return -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S: aic26->datfm = AIC26_DATFM_I2S; break;\r\ncase SND_SOC_DAIFMT_DSP_A: aic26->datfm = AIC26_DATFM_DSP; break;\r\ncase SND_SOC_DAIFMT_RIGHT_J: aic26->datfm = AIC26_DATFM_RIGHTJ; break;\r\ncase SND_SOC_DAIFMT_LEFT_J: aic26->datfm = AIC26_DATFM_LEFTJ; break;\r\ndefault:\r\ndev_dbg(&aic26->spi->dev, "bad format\n"); return -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t aic26_keyclick_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct aic26 *aic26 = dev_get_drvdata(dev);\r\nint val, amp, freq, len;\r\nval = snd_soc_read(aic26->codec, AIC26_REG_AUDIO_CTRL2);\r\namp = (val >> 12) & 0x7;\r\nfreq = (125 << ((val >> 8) & 0x7)) >> 1;\r\nlen = 2 * (1 + ((val >> 4) & 0xf));\r\nreturn sprintf(buf, "amp=%x freq=%iHz len=%iclks\n", amp, freq, len);\r\n}\r\nstatic ssize_t aic26_keyclick_set(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct aic26 *aic26 = dev_get_drvdata(dev);\r\nsnd_soc_update_bits(aic26->codec, AIC26_REG_AUDIO_CTRL2,\r\n0x8000, 0x800);\r\nreturn count;\r\n}\r\nstatic int aic26_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct aic26 *aic26 = dev_get_drvdata(codec->dev);\r\nint ret, reg;\r\naic26->codec = codec;\r\nsnd_soc_write(codec, AIC26_REG_RESET, 0xBB00);\r\nsnd_soc_write(codec, AIC26_REG_POWER_CTRL, 0);\r\nreg = snd_soc_read(codec, AIC26_REG_AUDIO_CTRL3);\r\nreg &= ~0xf800;\r\nreg |= 0x0800;\r\nsnd_soc_write(codec, AIC26_REG_AUDIO_CTRL3, reg);\r\nret = device_create_file(codec->dev, &dev_attr_keyclick);\r\nif (ret)\r\ndev_info(codec->dev, "error creating sysfs files\n");\r\nreturn 0;\r\n}\r\nstatic int aic26_spi_probe(struct spi_device *spi)\r\n{\r\nstruct aic26 *aic26;\r\nint ret;\r\ndev_dbg(&spi->dev, "probing tlv320aic26 spi device\n");\r\naic26 = devm_kzalloc(&spi->dev, sizeof *aic26, GFP_KERNEL);\r\nif (!aic26)\r\nreturn -ENOMEM;\r\naic26->regmap = devm_regmap_init_spi(spi, &aic26_regmap);\r\nif (IS_ERR(aic26->regmap))\r\nreturn PTR_ERR(aic26->regmap);\r\naic26->spi = spi;\r\ndev_set_drvdata(&spi->dev, aic26);\r\naic26->master = 1;\r\nret = snd_soc_register_codec(&spi->dev,\r\n&aic26_soc_codec_dev, &aic26_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int aic26_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nreturn 0;\r\n}
