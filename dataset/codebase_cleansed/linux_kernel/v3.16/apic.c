static inline void imcr_pic_to_apic(void)\r\n{\r\noutb(0x70, 0x22);\r\noutb(0x01, 0x23);\r\n}\r\nstatic inline void imcr_apic_to_pic(void)\r\n{\r\noutb(0x70, 0x22);\r\noutb(0x00, 0x23);\r\n}\r\nstatic int __init parse_lapic(char *arg)\r\n{\r\nif (config_enabled(CONFIG_X86_32) && !arg)\r\nforce_enable_local_apic = 1;\r\nelse if (arg && !strncmp(arg, "notscdeadline", 13))\r\nsetup_clear_cpu_cap(X86_FEATURE_TSC_DEADLINE_TIMER);\r\nreturn 0;\r\n}\r\nstatic __init int setup_apicpmtimer(char *s)\r\n{\r\napic_calibrate_pmtmr = 1;\r\nnotsc_setup(NULL);\r\nreturn 0;\r\n}\r\nstatic int __init setup_nox2apic(char *str)\r\n{\r\nif (x2apic_enabled()) {\r\nint apicid = native_apic_msr_read(APIC_ID);\r\nif (apicid >= 255) {\r\npr_warning("Apicid: %08x, cannot enforce nox2apic\n",\r\napicid);\r\nreturn 0;\r\n}\r\npr_warning("x2apic already enabled. will disable it\n");\r\n} else\r\nsetup_clear_cpu_cap(X86_FEATURE_X2APIC);\r\nnox2apic = true;\r\nreturn 0;\r\n}\r\nstatic inline int lapic_get_version(void)\r\n{\r\nreturn GET_APIC_VERSION(apic_read(APIC_LVR));\r\n}\r\nstatic inline int lapic_is_integrated(void)\r\n{\r\n#ifdef CONFIG_X86_64\r\nreturn 1;\r\n#else\r\nreturn APIC_INTEGRATED(lapic_get_version());\r\n#endif\r\n}\r\nstatic int modern_apic(void)\r\n{\r\nif (boot_cpu_data.x86_vendor == X86_VENDOR_AMD &&\r\nboot_cpu_data.x86 >= 0xf)\r\nreturn 1;\r\nreturn lapic_get_version() >= 0x14;\r\n}\r\nstatic void __init apic_disable(void)\r\n{\r\npr_info("APIC: switched to apic NOOP\n");\r\napic = &apic_noop;\r\n}\r\nvoid native_apic_wait_icr_idle(void)\r\n{\r\nwhile (apic_read(APIC_ICR) & APIC_ICR_BUSY)\r\ncpu_relax();\r\n}\r\nu32 native_safe_apic_wait_icr_idle(void)\r\n{\r\nu32 send_status;\r\nint timeout;\r\ntimeout = 0;\r\ndo {\r\nsend_status = apic_read(APIC_ICR) & APIC_ICR_BUSY;\r\nif (!send_status)\r\nbreak;\r\ninc_irq_stat(icr_read_retry_count);\r\nudelay(100);\r\n} while (timeout++ < 1000);\r\nreturn send_status;\r\n}\r\nvoid native_apic_icr_write(u32 low, u32 id)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\napic_write(APIC_ICR2, SET_APIC_DEST_FIELD(id));\r\napic_write(APIC_ICR, low);\r\nlocal_irq_restore(flags);\r\n}\r\nu64 native_apic_icr_read(void)\r\n{\r\nu32 icr1, icr2;\r\nicr2 = apic_read(APIC_ICR2);\r\nicr1 = apic_read(APIC_ICR);\r\nreturn icr1 | ((u64)icr2 << 32);\r\n}\r\nint get_physical_broadcast(void)\r\n{\r\nreturn modern_apic() ? 0xff : 0xf;\r\n}\r\nint lapic_get_maxlvt(void)\r\n{\r\nunsigned int v;\r\nv = apic_read(APIC_LVR);\r\nreturn APIC_INTEGRATED(GET_APIC_VERSION(v)) ? GET_APIC_MAXLVT(v) : 2;\r\n}\r\nstatic void __setup_APIC_LVTT(unsigned int clocks, int oneshot, int irqen)\r\n{\r\nunsigned int lvtt_value, tmp_value;\r\nlvtt_value = LOCAL_TIMER_VECTOR;\r\nif (!oneshot)\r\nlvtt_value |= APIC_LVT_TIMER_PERIODIC;\r\nelse if (boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER))\r\nlvtt_value |= APIC_LVT_TIMER_TSCDEADLINE;\r\nif (!lapic_is_integrated())\r\nlvtt_value |= SET_APIC_TIMER_BASE(APIC_TIMER_BASE_DIV);\r\nif (!irqen)\r\nlvtt_value |= APIC_LVT_MASKED;\r\napic_write(APIC_LVTT, lvtt_value);\r\nif (lvtt_value & APIC_LVT_TIMER_TSCDEADLINE) {\r\nprintk_once(KERN_DEBUG "TSC deadline timer enabled\n");\r\nreturn;\r\n}\r\ntmp_value = apic_read(APIC_TDCR);\r\napic_write(APIC_TDCR,\r\n(tmp_value & ~(APIC_TDR_DIV_1 | APIC_TDR_DIV_TMBASE)) |\r\nAPIC_TDR_DIV_16);\r\nif (!oneshot)\r\napic_write(APIC_TMICT, clocks / APIC_DIVISOR);\r\n}\r\nstatic inline int eilvt_entry_is_changeable(unsigned int old, unsigned int new)\r\n{\r\nreturn (old & APIC_EILVT_MASKED)\r\n|| (new == APIC_EILVT_MASKED)\r\n|| ((new & ~APIC_EILVT_MASKED) == old);\r\n}\r\nstatic unsigned int reserve_eilvt_offset(int offset, unsigned int new)\r\n{\r\nunsigned int rsvd, vector;\r\nif (offset >= APIC_EILVT_NR_MAX)\r\nreturn ~0;\r\nrsvd = atomic_read(&eilvt_offsets[offset]);\r\ndo {\r\nvector = rsvd & ~APIC_EILVT_MASKED;\r\nif (vector && !eilvt_entry_is_changeable(vector, new))\r\nreturn rsvd;\r\nrsvd = atomic_cmpxchg(&eilvt_offsets[offset], rsvd, new);\r\n} while (rsvd != new);\r\nrsvd &= ~APIC_EILVT_MASKED;\r\nif (rsvd && rsvd != vector)\r\npr_info("LVT offset %d assigned for vector 0x%02x\n",\r\noffset, rsvd);\r\nreturn new;\r\n}\r\nint setup_APIC_eilvt(u8 offset, u8 vector, u8 msg_type, u8 mask)\r\n{\r\nunsigned long reg = APIC_EILVTn(offset);\r\nunsigned int new, old, reserved;\r\nnew = (mask << 16) | (msg_type << 8) | vector;\r\nold = apic_read(reg);\r\nreserved = reserve_eilvt_offset(offset, new);\r\nif (reserved != new) {\r\npr_err(FW_BUG "cpu %d, try to use APIC%lX (LVT offset %d) for "\r\n"vector 0x%x, but the register is already in use for "\r\n"vector 0x%x on another cpu\n",\r\nsmp_processor_id(), reg, offset, new, reserved);\r\nreturn -EINVAL;\r\n}\r\nif (!eilvt_entry_is_changeable(old, new)) {\r\npr_err(FW_BUG "cpu %d, try to use APIC%lX (LVT offset %d) for "\r\n"vector 0x%x, but the register is already in use for "\r\n"vector 0x%x on this cpu\n",\r\nsmp_processor_id(), reg, offset, new, old);\r\nreturn -EBUSY;\r\n}\r\napic_write(reg, new);\r\nreturn 0;\r\n}\r\nstatic int lapic_next_event(unsigned long delta,\r\nstruct clock_event_device *evt)\r\n{\r\napic_write(APIC_TMICT, delta);\r\nreturn 0;\r\n}\r\nstatic int lapic_next_deadline(unsigned long delta,\r\nstruct clock_event_device *evt)\r\n{\r\nu64 tsc;\r\nrdtscll(tsc);\r\nwrmsrl(MSR_IA32_TSC_DEADLINE, tsc + (((u64) delta) * TSC_DIVISOR));\r\nreturn 0;\r\n}\r\nstatic void lapic_timer_setup(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long flags;\r\nunsigned int v;\r\nif (evt->features & CLOCK_EVT_FEAT_DUMMY)\r\nreturn;\r\nlocal_irq_save(flags);\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\n__setup_APIC_LVTT(lapic_timer_frequency,\r\nmode != CLOCK_EVT_MODE_PERIODIC, 1);\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\nv = apic_read(APIC_LVTT);\r\nv |= (APIC_LVT_MASKED | LOCAL_TIMER_VECTOR);\r\napic_write(APIC_LVTT, v);\r\napic_write(APIC_TMICT, 0);\r\nbreak;\r\ncase CLOCK_EVT_MODE_RESUME:\r\nbreak;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void lapic_timer_broadcast(const struct cpumask *mask)\r\n{\r\n#ifdef CONFIG_SMP\r\napic->send_IPI_mask(mask, LOCAL_TIMER_VECTOR);\r\n#endif\r\n}\r\nstatic void setup_APIC_timer(void)\r\n{\r\nstruct clock_event_device *levt = &__get_cpu_var(lapic_events);\r\nif (this_cpu_has(X86_FEATURE_ARAT)) {\r\nlapic_clockevent.features &= ~CLOCK_EVT_FEAT_C3STOP;\r\nlapic_clockevent.rating = 150;\r\n}\r\nmemcpy(levt, &lapic_clockevent, sizeof(*levt));\r\nlevt->cpumask = cpumask_of(smp_processor_id());\r\nif (this_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER)) {\r\nlevt->features &= ~(CLOCK_EVT_FEAT_PERIODIC |\r\nCLOCK_EVT_FEAT_DUMMY);\r\nlevt->set_next_event = lapic_next_deadline;\r\nclockevents_config_and_register(levt,\r\n(tsc_khz / TSC_DIVISOR) * 1000,\r\n0xF, ~0UL);\r\n} else\r\nclockevents_register_device(levt);\r\n}\r\nstatic void __init lapic_cal_handler(struct clock_event_device *dev)\r\n{\r\nunsigned long long tsc = 0;\r\nlong tapic = apic_read(APIC_TMCCT);\r\nunsigned long pm = acpi_pm_read_early();\r\nif (cpu_has_tsc)\r\nrdtscll(tsc);\r\nswitch (lapic_cal_loops++) {\r\ncase 0:\r\nlapic_cal_t1 = tapic;\r\nlapic_cal_tsc1 = tsc;\r\nlapic_cal_pm1 = pm;\r\nlapic_cal_j1 = jiffies;\r\nbreak;\r\ncase LAPIC_CAL_LOOPS:\r\nlapic_cal_t2 = tapic;\r\nlapic_cal_tsc2 = tsc;\r\nif (pm < lapic_cal_pm1)\r\npm += ACPI_PM_OVRRUN;\r\nlapic_cal_pm2 = pm;\r\nlapic_cal_j2 = jiffies;\r\nbreak;\r\n}\r\n}\r\nstatic int __init\r\ncalibrate_by_pmtimer(long deltapm, long *delta, long *deltatsc)\r\n{\r\nconst long pm_100ms = PMTMR_TICKS_PER_SEC / 10;\r\nconst long pm_thresh = pm_100ms / 100;\r\nunsigned long mult;\r\nu64 res;\r\n#ifndef CONFIG_X86_PM_TIMER\r\nreturn -1;\r\n#endif\r\napic_printk(APIC_VERBOSE, "... PM-Timer delta = %ld\n", deltapm);\r\nif (!deltapm)\r\nreturn -1;\r\nmult = clocksource_hz2mult(PMTMR_TICKS_PER_SEC, 22);\r\nif (deltapm > (pm_100ms - pm_thresh) &&\r\ndeltapm < (pm_100ms + pm_thresh)) {\r\napic_printk(APIC_VERBOSE, "... PM-Timer result ok\n");\r\nreturn 0;\r\n}\r\nres = (((u64)deltapm) * mult) >> 22;\r\ndo_div(res, 1000000);\r\npr_warning("APIC calibration not consistent "\r\n"with PM-Timer: %ldms instead of 100ms\n",(long)res);\r\nres = (((u64)(*delta)) * pm_100ms);\r\ndo_div(res, deltapm);\r\npr_info("APIC delta adjusted to PM-Timer: "\r\n"%lu (%ld)\n", (unsigned long)res, *delta);\r\n*delta = (long)res;\r\nif (cpu_has_tsc) {\r\nres = (((u64)(*deltatsc)) * pm_100ms);\r\ndo_div(res, deltapm);\r\napic_printk(APIC_VERBOSE, "TSC delta adjusted to "\r\n"PM-Timer: %lu (%ld)\n",\r\n(unsigned long)res, *deltatsc);\r\n*deltatsc = (long)res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init calibrate_APIC_clock(void)\r\n{\r\nstruct clock_event_device *levt = &__get_cpu_var(lapic_events);\r\nvoid (*real_handler)(struct clock_event_device *dev);\r\nunsigned long deltaj;\r\nlong delta, deltatsc;\r\nint pm_referenced = 0;\r\nif (boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER)) {\r\nreturn 0;\r\n} else if (lapic_timer_frequency) {\r\napic_printk(APIC_VERBOSE, "lapic timer already calibrated %d\n",\r\nlapic_timer_frequency);\r\nlapic_clockevent.mult = div_sc(lapic_timer_frequency/APIC_DIVISOR,\r\nTICK_NSEC, lapic_clockevent.shift);\r\nlapic_clockevent.max_delta_ns =\r\nclockevent_delta2ns(0x7FFFFF, &lapic_clockevent);\r\nlapic_clockevent.min_delta_ns =\r\nclockevent_delta2ns(0xF, &lapic_clockevent);\r\nlapic_clockevent.features &= ~CLOCK_EVT_FEAT_DUMMY;\r\nreturn 0;\r\n}\r\napic_printk(APIC_VERBOSE, "Using local APIC timer interrupts.\n"\r\n"calibrating APIC timer ...\n");\r\nlocal_irq_disable();\r\nreal_handler = global_clock_event->event_handler;\r\nglobal_clock_event->event_handler = lapic_cal_handler;\r\n__setup_APIC_LVTT(0xffffffff, 0, 0);\r\nlocal_irq_enable();\r\nwhile (lapic_cal_loops <= LAPIC_CAL_LOOPS)\r\ncpu_relax();\r\nlocal_irq_disable();\r\nglobal_clock_event->event_handler = real_handler;\r\ndelta = lapic_cal_t1 - lapic_cal_t2;\r\napic_printk(APIC_VERBOSE, "... lapic delta = %ld\n", delta);\r\ndeltatsc = (long)(lapic_cal_tsc2 - lapic_cal_tsc1);\r\npm_referenced = !calibrate_by_pmtimer(lapic_cal_pm2 - lapic_cal_pm1,\r\n&delta, &deltatsc);\r\nlapic_clockevent.mult = div_sc(delta, TICK_NSEC * LAPIC_CAL_LOOPS,\r\nlapic_clockevent.shift);\r\nlapic_clockevent.max_delta_ns =\r\nclockevent_delta2ns(0x7FFFFFFF, &lapic_clockevent);\r\nlapic_clockevent.min_delta_ns =\r\nclockevent_delta2ns(0xF, &lapic_clockevent);\r\nlapic_timer_frequency = (delta * APIC_DIVISOR) / LAPIC_CAL_LOOPS;\r\napic_printk(APIC_VERBOSE, "..... delta %ld\n", delta);\r\napic_printk(APIC_VERBOSE, "..... mult: %u\n", lapic_clockevent.mult);\r\napic_printk(APIC_VERBOSE, "..... calibration result: %u\n",\r\nlapic_timer_frequency);\r\nif (cpu_has_tsc) {\r\napic_printk(APIC_VERBOSE, "..... CPU clock speed is "\r\n"%ld.%04ld MHz.\n",\r\n(deltatsc / LAPIC_CAL_LOOPS) / (1000000 / HZ),\r\n(deltatsc / LAPIC_CAL_LOOPS) % (1000000 / HZ));\r\n}\r\napic_printk(APIC_VERBOSE, "..... host bus clock speed is "\r\n"%u.%04u MHz.\n",\r\nlapic_timer_frequency / (1000000 / HZ),\r\nlapic_timer_frequency % (1000000 / HZ));\r\nif (lapic_timer_frequency < (1000000 / HZ)) {\r\nlocal_irq_enable();\r\npr_warning("APIC frequency too slow, disabling apic timer\n");\r\nreturn -1;\r\n}\r\nlevt->features &= ~CLOCK_EVT_FEAT_DUMMY;\r\nif (!pm_referenced) {\r\napic_printk(APIC_VERBOSE, "... verify APIC timer\n");\r\nlevt->event_handler = lapic_cal_handler;\r\nlapic_timer_setup(CLOCK_EVT_MODE_PERIODIC, levt);\r\nlapic_cal_loops = -1;\r\nlocal_irq_enable();\r\nwhile (lapic_cal_loops <= LAPIC_CAL_LOOPS)\r\ncpu_relax();\r\nlapic_timer_setup(CLOCK_EVT_MODE_SHUTDOWN, levt);\r\ndeltaj = lapic_cal_j2 - lapic_cal_j1;\r\napic_printk(APIC_VERBOSE, "... jiffies delta = %lu\n", deltaj);\r\nif (deltaj >= LAPIC_CAL_LOOPS-2 && deltaj <= LAPIC_CAL_LOOPS+2)\r\napic_printk(APIC_VERBOSE, "... jiffies result ok\n");\r\nelse\r\nlevt->features |= CLOCK_EVT_FEAT_DUMMY;\r\n} else\r\nlocal_irq_enable();\r\nif (levt->features & CLOCK_EVT_FEAT_DUMMY) {\r\npr_warning("APIC timer disabled due to verification failure\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init setup_boot_APIC_clock(void)\r\n{\r\nif (disable_apic_timer) {\r\npr_info("Disabling APIC timer\n");\r\nif (num_possible_cpus() > 1) {\r\nlapic_clockevent.mult = 1;\r\nsetup_APIC_timer();\r\n}\r\nreturn;\r\n}\r\nif (calibrate_APIC_clock()) {\r\nif (num_possible_cpus() > 1)\r\nsetup_APIC_timer();\r\nreturn;\r\n}\r\nlapic_clockevent.features &= ~CLOCK_EVT_FEAT_DUMMY;\r\nsetup_APIC_timer();\r\n}\r\nvoid setup_secondary_APIC_clock(void)\r\n{\r\nsetup_APIC_timer();\r\n}\r\nstatic void local_apic_timer_interrupt(void)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct clock_event_device *evt = &per_cpu(lapic_events, cpu);\r\nif (!evt->event_handler) {\r\npr_warning("Spurious LAPIC timer interrupt on cpu %d\n", cpu);\r\nlapic_timer_setup(CLOCK_EVT_MODE_SHUTDOWN, evt);\r\nreturn;\r\n}\r\ninc_irq_stat(apic_timer_irqs);\r\nevt->event_handler(evt);\r\n}\r\n__visible void __irq_entry smp_apic_timer_interrupt(struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs = set_irq_regs(regs);\r\nentering_ack_irq();\r\nlocal_apic_timer_interrupt();\r\nexiting_irq();\r\nset_irq_regs(old_regs);\r\n}\r\n__visible void __irq_entry smp_trace_apic_timer_interrupt(struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs = set_irq_regs(regs);\r\nentering_ack_irq();\r\ntrace_local_timer_entry(LOCAL_TIMER_VECTOR);\r\nlocal_apic_timer_interrupt();\r\ntrace_local_timer_exit(LOCAL_TIMER_VECTOR);\r\nexiting_irq();\r\nset_irq_regs(old_regs);\r\n}\r\nint setup_profiling_timer(unsigned int multiplier)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid clear_local_APIC(void)\r\n{\r\nint maxlvt;\r\nu32 v;\r\nif (!x2apic_mode && !apic_phys)\r\nreturn;\r\nmaxlvt = lapic_get_maxlvt();\r\nif (maxlvt >= 3) {\r\nv = ERROR_APIC_VECTOR;\r\napic_write(APIC_LVTERR, v | APIC_LVT_MASKED);\r\n}\r\nv = apic_read(APIC_LVTT);\r\napic_write(APIC_LVTT, v | APIC_LVT_MASKED);\r\nv = apic_read(APIC_LVT0);\r\napic_write(APIC_LVT0, v | APIC_LVT_MASKED);\r\nv = apic_read(APIC_LVT1);\r\napic_write(APIC_LVT1, v | APIC_LVT_MASKED);\r\nif (maxlvt >= 4) {\r\nv = apic_read(APIC_LVTPC);\r\napic_write(APIC_LVTPC, v | APIC_LVT_MASKED);\r\n}\r\n#ifdef CONFIG_X86_THERMAL_VECTOR\r\nif (maxlvt >= 5) {\r\nv = apic_read(APIC_LVTTHMR);\r\napic_write(APIC_LVTTHMR, v | APIC_LVT_MASKED);\r\n}\r\n#endif\r\n#ifdef CONFIG_X86_MCE_INTEL\r\nif (maxlvt >= 6) {\r\nv = apic_read(APIC_LVTCMCI);\r\nif (!(v & APIC_LVT_MASKED))\r\napic_write(APIC_LVTCMCI, v | APIC_LVT_MASKED);\r\n}\r\n#endif\r\napic_write(APIC_LVTT, APIC_LVT_MASKED);\r\napic_write(APIC_LVT0, APIC_LVT_MASKED);\r\napic_write(APIC_LVT1, APIC_LVT_MASKED);\r\nif (maxlvt >= 3)\r\napic_write(APIC_LVTERR, APIC_LVT_MASKED);\r\nif (maxlvt >= 4)\r\napic_write(APIC_LVTPC, APIC_LVT_MASKED);\r\nif (lapic_is_integrated()) {\r\nif (maxlvt > 3)\r\napic_write(APIC_ESR, 0);\r\napic_read(APIC_ESR);\r\n}\r\n}\r\nvoid disable_local_APIC(void)\r\n{\r\nunsigned int value;\r\nif (!x2apic_mode && !apic_phys)\r\nreturn;\r\nclear_local_APIC();\r\nvalue = apic_read(APIC_SPIV);\r\nvalue &= ~APIC_SPIV_APIC_ENABLED;\r\napic_write(APIC_SPIV, value);\r\n#ifdef CONFIG_X86_32\r\nif (enabled_via_apicbase) {\r\nunsigned int l, h;\r\nrdmsr(MSR_IA32_APICBASE, l, h);\r\nl &= ~MSR_IA32_APICBASE_ENABLE;\r\nwrmsr(MSR_IA32_APICBASE, l, h);\r\n}\r\n#endif\r\n}\r\nvoid lapic_shutdown(void)\r\n{\r\nunsigned long flags;\r\nif (!cpu_has_apic && !apic_from_smp_config())\r\nreturn;\r\nlocal_irq_save(flags);\r\n#ifdef CONFIG_X86_32\r\nif (!enabled_via_apicbase)\r\nclear_local_APIC();\r\nelse\r\n#endif\r\ndisable_local_APIC();\r\nlocal_irq_restore(flags);\r\n}\r\nint __init verify_local_APIC(void)\r\n{\r\nunsigned int reg0, reg1;\r\nreg0 = apic_read(APIC_LVR);\r\napic_printk(APIC_DEBUG, "Getting VERSION: %x\n", reg0);\r\napic_write(APIC_LVR, reg0 ^ APIC_LVR_MASK);\r\nreg1 = apic_read(APIC_LVR);\r\napic_printk(APIC_DEBUG, "Getting VERSION: %x\n", reg1);\r\nif (reg1 != reg0)\r\nreturn 0;\r\nreg1 = GET_APIC_VERSION(reg0);\r\nif (reg1 == 0x00 || reg1 == 0xff)\r\nreturn 0;\r\nreg1 = lapic_get_maxlvt();\r\nif (reg1 < 0x02 || reg1 == 0xff)\r\nreturn 0;\r\nreg0 = apic_read(APIC_ID);\r\napic_printk(APIC_DEBUG, "Getting ID: %x\n", reg0);\r\napic_write(APIC_ID, reg0 ^ apic->apic_id_mask);\r\nreg1 = apic_read(APIC_ID);\r\napic_printk(APIC_DEBUG, "Getting ID: %x\n", reg1);\r\napic_write(APIC_ID, reg0);\r\nif (reg1 != (reg0 ^ apic->apic_id_mask))\r\nreturn 0;\r\nreg0 = apic_read(APIC_LVT0);\r\napic_printk(APIC_DEBUG, "Getting LVT0: %x\n", reg0);\r\nreg1 = apic_read(APIC_LVT1);\r\napic_printk(APIC_DEBUG, "Getting LVT1: %x\n", reg1);\r\nreturn 1;\r\n}\r\nvoid __init sync_Arb_IDs(void)\r\n{\r\nif (modern_apic() || boot_cpu_data.x86_vendor == X86_VENDOR_AMD)\r\nreturn;\r\napic_wait_icr_idle();\r\napic_printk(APIC_DEBUG, "Synchronizing Arb IDs.\n");\r\napic_write(APIC_ICR, APIC_DEST_ALLINC |\r\nAPIC_INT_LEVELTRIG | APIC_DM_INIT);\r\n}\r\nvoid __init init_bsp_APIC(void)\r\n{\r\nunsigned int value;\r\nif (smp_found_config || !cpu_has_apic)\r\nreturn;\r\nclear_local_APIC();\r\nvalue = apic_read(APIC_SPIV);\r\nvalue &= ~APIC_VECTOR_MASK;\r\nvalue |= APIC_SPIV_APIC_ENABLED;\r\n#ifdef CONFIG_X86_32\r\nif ((boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) &&\r\n(boot_cpu_data.x86 == 15))\r\nvalue &= ~APIC_SPIV_FOCUS_DISABLED;\r\nelse\r\n#endif\r\nvalue |= APIC_SPIV_FOCUS_DISABLED;\r\nvalue |= SPURIOUS_APIC_VECTOR;\r\napic_write(APIC_SPIV, value);\r\napic_write(APIC_LVT0, APIC_DM_EXTINT);\r\nvalue = APIC_DM_NMI;\r\nif (!lapic_is_integrated())\r\nvalue |= APIC_LVT_LEVEL_TRIGGER;\r\napic_write(APIC_LVT1, value);\r\n}\r\nstatic void lapic_setup_esr(void)\r\n{\r\nunsigned int oldvalue, value, maxlvt;\r\nif (!lapic_is_integrated()) {\r\npr_info("No ESR for 82489DX.\n");\r\nreturn;\r\n}\r\nif (apic->disable_esr) {\r\npr_info("Leaving ESR disabled.\n");\r\nreturn;\r\n}\r\nmaxlvt = lapic_get_maxlvt();\r\nif (maxlvt > 3)\r\napic_write(APIC_ESR, 0);\r\noldvalue = apic_read(APIC_ESR);\r\nvalue = ERROR_APIC_VECTOR;\r\napic_write(APIC_LVTERR, value);\r\nif (maxlvt > 3)\r\napic_write(APIC_ESR, 0);\r\nvalue = apic_read(APIC_ESR);\r\nif (value != oldvalue)\r\napic_printk(APIC_VERBOSE, "ESR value before enabling "\r\n"vector: 0x%08x after: 0x%08x\n",\r\noldvalue, value);\r\n}\r\nvoid setup_local_APIC(void)\r\n{\r\nint cpu = smp_processor_id();\r\nunsigned int value, queued;\r\nint i, j, acked = 0;\r\nunsigned long long tsc = 0, ntsc;\r\nlong long max_loops = cpu_khz;\r\nif (cpu_has_tsc)\r\nrdtscll(tsc);\r\nif (disable_apic) {\r\ndisable_ioapic_support();\r\nreturn;\r\n}\r\n#ifdef CONFIG_X86_32\r\nif (lapic_is_integrated() && apic->disable_esr) {\r\napic_write(APIC_ESR, 0);\r\napic_write(APIC_ESR, 0);\r\napic_write(APIC_ESR, 0);\r\napic_write(APIC_ESR, 0);\r\n}\r\n#endif\r\nperf_events_lapic_init();\r\nBUG_ON(!apic->apic_id_registered());\r\napic->init_apic_ldr();\r\n#ifdef CONFIG_X86_32\r\ni = early_per_cpu(x86_cpu_to_logical_apicid, cpu);\r\nWARN_ON(i != BAD_APICID && i != logical_smp_processor_id());\r\nearly_per_cpu(x86_cpu_to_logical_apicid, cpu) =\r\nlogical_smp_processor_id();\r\nif (apic->x86_32_numa_cpu_node)\r\nset_apicid_to_node(early_per_cpu(x86_cpu_to_apicid, cpu),\r\napic->x86_32_numa_cpu_node(cpu));\r\n#endif\r\nvalue = apic_read(APIC_TASKPRI);\r\nvalue &= ~APIC_TPRI_MASK;\r\napic_write(APIC_TASKPRI, value);\r\ndo {\r\nqueued = 0;\r\nfor (i = APIC_ISR_NR - 1; i >= 0; i--)\r\nqueued |= apic_read(APIC_IRR + i*0x10);\r\nfor (i = APIC_ISR_NR - 1; i >= 0; i--) {\r\nvalue = apic_read(APIC_ISR + i*0x10);\r\nfor (j = 31; j >= 0; j--) {\r\nif (value & (1<<j)) {\r\nack_APIC_irq();\r\nacked++;\r\n}\r\n}\r\n}\r\nif (acked > 256) {\r\nprintk(KERN_ERR "LAPIC pending interrupts after %d EOI\n",\r\nacked);\r\nbreak;\r\n}\r\nif (queued) {\r\nif (cpu_has_tsc) {\r\nrdtscll(ntsc);\r\nmax_loops = (cpu_khz << 10) - (ntsc - tsc);\r\n} else\r\nmax_loops--;\r\n}\r\n} while (queued && max_loops > 0);\r\nWARN_ON(max_loops <= 0);\r\nvalue = apic_read(APIC_SPIV);\r\nvalue &= ~APIC_VECTOR_MASK;\r\nvalue |= APIC_SPIV_APIC_ENABLED;\r\n#ifdef CONFIG_X86_32\r\nvalue &= ~APIC_SPIV_FOCUS_DISABLED;\r\n#endif\r\nvalue |= SPURIOUS_APIC_VECTOR;\r\napic_write(APIC_SPIV, value);\r\nvalue = apic_read(APIC_LVT0) & APIC_LVT_MASKED;\r\nif (!cpu && (pic_mode || !value)) {\r\nvalue = APIC_DM_EXTINT;\r\napic_printk(APIC_VERBOSE, "enabled ExtINT on CPU#%d\n", cpu);\r\n} else {\r\nvalue = APIC_DM_EXTINT | APIC_LVT_MASKED;\r\napic_printk(APIC_VERBOSE, "masked ExtINT on CPU#%d\n", cpu);\r\n}\r\napic_write(APIC_LVT0, value);\r\nif (!cpu)\r\nvalue = APIC_DM_NMI;\r\nelse\r\nvalue = APIC_DM_NMI | APIC_LVT_MASKED;\r\nif (!lapic_is_integrated())\r\nvalue |= APIC_LVT_LEVEL_TRIGGER;\r\napic_write(APIC_LVT1, value);\r\n#ifdef CONFIG_X86_MCE_INTEL\r\nif (!cpu)\r\ncmci_recheck();\r\n#endif\r\n}\r\nvoid end_local_APIC_setup(void)\r\n{\r\nlapic_setup_esr();\r\n#ifdef CONFIG_X86_32\r\n{\r\nunsigned int value;\r\nvalue = apic_read(APIC_LVTT);\r\nvalue |= (APIC_LVT_MASKED | LOCAL_TIMER_VECTOR);\r\napic_write(APIC_LVTT, value);\r\n}\r\n#endif\r\napic_pm_activate();\r\n}\r\nvoid __init bsp_end_local_APIC_setup(void)\r\n{\r\nend_local_APIC_setup();\r\nirq_remap_enable_fault_handling();\r\n}\r\nstatic inline void __disable_x2apic(u64 msr)\r\n{\r\nwrmsrl(MSR_IA32_APICBASE,\r\nmsr & ~(X2APIC_ENABLE | XAPIC_ENABLE));\r\nwrmsrl(MSR_IA32_APICBASE, msr & ~X2APIC_ENABLE);\r\n}\r\nstatic __init void disable_x2apic(void)\r\n{\r\nu64 msr;\r\nif (!cpu_has_x2apic)\r\nreturn;\r\nrdmsrl(MSR_IA32_APICBASE, msr);\r\nif (msr & X2APIC_ENABLE) {\r\nu32 x2apic_id = read_apic_id();\r\nif (x2apic_id >= 255)\r\npanic("Cannot disable x2apic, id: %08x\n", x2apic_id);\r\npr_info("Disabling x2apic\n");\r\n__disable_x2apic(msr);\r\nif (nox2apic) {\r\nclear_cpu_cap(&cpu_data(0), X86_FEATURE_X2APIC);\r\nsetup_clear_cpu_cap(X86_FEATURE_X2APIC);\r\n}\r\nx2apic_disabled = 1;\r\nx2apic_mode = 0;\r\nregister_lapic_address(mp_lapic_addr);\r\n}\r\n}\r\nvoid check_x2apic(void)\r\n{\r\nif (x2apic_enabled()) {\r\npr_info("x2apic enabled by BIOS, switching to x2apic ops\n");\r\nx2apic_preenabled = x2apic_mode = 1;\r\n}\r\n}\r\nvoid enable_x2apic(void)\r\n{\r\nu64 msr;\r\nrdmsrl(MSR_IA32_APICBASE, msr);\r\nif (x2apic_disabled) {\r\n__disable_x2apic(msr);\r\nreturn;\r\n}\r\nif (!x2apic_mode)\r\nreturn;\r\nif (!(msr & X2APIC_ENABLE)) {\r\nprintk_once(KERN_INFO "Enabling x2apic\n");\r\nwrmsrl(MSR_IA32_APICBASE, msr | X2APIC_ENABLE);\r\n}\r\n}\r\nint __init enable_IR(void)\r\n{\r\n#ifdef CONFIG_IRQ_REMAP\r\nif (!irq_remapping_supported()) {\r\npr_debug("intr-remapping not supported\n");\r\nreturn -1;\r\n}\r\nif (!x2apic_preenabled && skip_ioapic_setup) {\r\npr_info("Skipped enabling intr-remap because of skipping "\r\n"io-apic setup\n");\r\nreturn -1;\r\n}\r\nreturn irq_remapping_enable();\r\n#endif\r\nreturn -1;\r\n}\r\nvoid __init enable_IR_x2apic(void)\r\n{\r\nunsigned long flags;\r\nint ret, x2apic_enabled = 0;\r\nint hardware_init_ret;\r\nsetup_irq_remapping_ops();\r\nhardware_init_ret = irq_remapping_prepare();\r\nif (hardware_init_ret && !x2apic_supported())\r\nreturn;\r\nret = save_ioapic_entries();\r\nif (ret) {\r\npr_info("Saving IO-APIC state failed: %d\n", ret);\r\nreturn;\r\n}\r\nlocal_irq_save(flags);\r\nlegacy_pic->mask_all();\r\nmask_ioapic_entries();\r\nif (x2apic_preenabled && nox2apic)\r\ndisable_x2apic();\r\nif (hardware_init_ret)\r\nret = -1;\r\nelse\r\nret = enable_IR();\r\nif (!x2apic_supported())\r\ngoto skip_x2apic;\r\nif (ret < 0) {\r\nif (max_physical_apicid > 255 ||\r\n!hypervisor_x2apic_available()) {\r\nif (x2apic_preenabled)\r\ndisable_x2apic();\r\ngoto skip_x2apic;\r\n}\r\nx2apic_force_phys();\r\n}\r\nif (ret == IRQ_REMAP_XAPIC_MODE) {\r\npr_info("x2apic not enabled, IRQ remapping is in xapic mode\n");\r\ngoto skip_x2apic;\r\n}\r\nx2apic_enabled = 1;\r\nif (x2apic_supported() && !x2apic_mode) {\r\nx2apic_mode = 1;\r\nenable_x2apic();\r\npr_info("Enabled x2apic\n");\r\n}\r\nskip_x2apic:\r\nif (ret < 0)\r\nrestore_ioapic_entries();\r\nlegacy_pic->restore_mask();\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init detect_init_APIC(void)\r\n{\r\nif (!cpu_has_apic) {\r\npr_info("No local APIC present\n");\r\nreturn -1;\r\n}\r\nmp_lapic_addr = APIC_DEFAULT_PHYS_BASE;\r\nreturn 0;\r\n}\r\nstatic int __init apic_verify(void)\r\n{\r\nu32 features, h, l;\r\nfeatures = cpuid_edx(1);\r\nif (!(features & (1 << X86_FEATURE_APIC))) {\r\npr_warning("Could not enable APIC!\n");\r\nreturn -1;\r\n}\r\nset_cpu_cap(&boot_cpu_data, X86_FEATURE_APIC);\r\nmp_lapic_addr = APIC_DEFAULT_PHYS_BASE;\r\nif (boot_cpu_data.x86 >= 6) {\r\nrdmsr(MSR_IA32_APICBASE, l, h);\r\nif (l & MSR_IA32_APICBASE_ENABLE)\r\nmp_lapic_addr = l & MSR_IA32_APICBASE_BASE;\r\n}\r\npr_info("Found and enabled local APIC!\n");\r\nreturn 0;\r\n}\r\nint __init apic_force_enable(unsigned long addr)\r\n{\r\nu32 h, l;\r\nif (disable_apic)\r\nreturn -1;\r\nif (boot_cpu_data.x86 >= 6) {\r\nrdmsr(MSR_IA32_APICBASE, l, h);\r\nif (!(l & MSR_IA32_APICBASE_ENABLE)) {\r\npr_info("Local APIC disabled by BIOS -- reenabling.\n");\r\nl &= ~MSR_IA32_APICBASE_BASE;\r\nl |= MSR_IA32_APICBASE_ENABLE | addr;\r\nwrmsr(MSR_IA32_APICBASE, l, h);\r\nenabled_via_apicbase = 1;\r\n}\r\n}\r\nreturn apic_verify();\r\n}\r\nstatic int __init detect_init_APIC(void)\r\n{\r\nif (disable_apic)\r\nreturn -1;\r\nswitch (boot_cpu_data.x86_vendor) {\r\ncase X86_VENDOR_AMD:\r\nif ((boot_cpu_data.x86 == 6 && boot_cpu_data.x86_model > 1) ||\r\n(boot_cpu_data.x86 >= 15))\r\nbreak;\r\ngoto no_apic;\r\ncase X86_VENDOR_INTEL:\r\nif (boot_cpu_data.x86 == 6 || boot_cpu_data.x86 == 15 ||\r\n(boot_cpu_data.x86 == 5 && cpu_has_apic))\r\nbreak;\r\ngoto no_apic;\r\ndefault:\r\ngoto no_apic;\r\n}\r\nif (!cpu_has_apic) {\r\nif (!force_enable_local_apic) {\r\npr_info("Local APIC disabled by BIOS -- "\r\n"you can enable it with \"lapic\"\n");\r\nreturn -1;\r\n}\r\nif (apic_force_enable(APIC_DEFAULT_PHYS_BASE))\r\nreturn -1;\r\n} else {\r\nif (apic_verify())\r\nreturn -1;\r\n}\r\napic_pm_activate();\r\nreturn 0;\r\nno_apic:\r\npr_info("No local APIC present or hardware disabled\n");\r\nreturn -1;\r\n}\r\nvoid __init init_apic_mappings(void)\r\n{\r\nunsigned int new_apicid;\r\nif (x2apic_mode) {\r\nboot_cpu_physical_apicid = read_apic_id();\r\nreturn;\r\n}\r\nif (!smp_found_config && detect_init_APIC()) {\r\npr_info("APIC: disable apic facility\n");\r\napic_disable();\r\n} else {\r\napic_phys = mp_lapic_addr;\r\nif (!acpi_lapic && !smp_found_config)\r\nregister_lapic_address(apic_phys);\r\n}\r\nnew_apicid = read_apic_id();\r\nif (boot_cpu_physical_apicid != new_apicid) {\r\nboot_cpu_physical_apicid = new_apicid;\r\napic_version[new_apicid] =\r\nGET_APIC_VERSION(apic_read(APIC_LVR));\r\n}\r\n}\r\nvoid __init register_lapic_address(unsigned long address)\r\n{\r\nmp_lapic_addr = address;\r\nif (!x2apic_mode) {\r\nset_fixmap_nocache(FIX_APIC_BASE, address);\r\napic_printk(APIC_VERBOSE, "mapped APIC to %16lx (%16lx)\n",\r\nAPIC_BASE, mp_lapic_addr);\r\n}\r\nif (boot_cpu_physical_apicid == -1U) {\r\nboot_cpu_physical_apicid = read_apic_id();\r\napic_version[boot_cpu_physical_apicid] =\r\nGET_APIC_VERSION(apic_read(APIC_LVR));\r\n}\r\n}\r\nint __init APIC_init_uniprocessor(void)\r\n{\r\nif (disable_apic) {\r\npr_info("Apic disabled\n");\r\nreturn -1;\r\n}\r\n#ifdef CONFIG_X86_64\r\nif (!cpu_has_apic) {\r\ndisable_apic = 1;\r\npr_info("Apic disabled by BIOS\n");\r\nreturn -1;\r\n}\r\n#else\r\nif (!smp_found_config && !cpu_has_apic)\r\nreturn -1;\r\nif (!cpu_has_apic &&\r\nAPIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {\r\npr_err("BIOS bug, local APIC 0x%x not detected!...\n",\r\nboot_cpu_physical_apicid);\r\nreturn -1;\r\n}\r\n#endif\r\ndefault_setup_apic_routing();\r\nverify_local_APIC();\r\nconnect_bsp_APIC();\r\n#ifdef CONFIG_X86_64\r\napic_write(APIC_ID, SET_APIC_ID(boot_cpu_physical_apicid));\r\n#else\r\n# ifdef CONFIG_CRASH_DUMP\r\nboot_cpu_physical_apicid = read_apic_id();\r\n# endif\r\n#endif\r\nphysid_set_mask_of_physid(boot_cpu_physical_apicid, &phys_cpu_present_map);\r\nsetup_local_APIC();\r\n#ifdef CONFIG_X86_IO_APIC\r\nif (!skip_ioapic_setup && nr_ioapics)\r\nenable_IO_APIC();\r\n#endif\r\nbsp_end_local_APIC_setup();\r\n#ifdef CONFIG_X86_IO_APIC\r\nif (smp_found_config && !skip_ioapic_setup && nr_ioapics)\r\nsetup_IO_APIC();\r\nelse {\r\nnr_ioapics = 0;\r\n}\r\n#endif\r\nx86_init.timers.setup_percpu_clockev();\r\nreturn 0;\r\n}\r\nstatic inline void __smp_spurious_interrupt(void)\r\n{\r\nu32 v;\r\nv = apic_read(APIC_ISR + ((SPURIOUS_APIC_VECTOR & ~0x1f) >> 1));\r\nif (v & (1 << (SPURIOUS_APIC_VECTOR & 0x1f)))\r\nack_APIC_irq();\r\ninc_irq_stat(irq_spurious_count);\r\npr_info("spurious APIC interrupt on CPU#%d, "\r\n"should never happen.\n", smp_processor_id());\r\n}\r\n__visible void smp_spurious_interrupt(struct pt_regs *regs)\r\n{\r\nentering_irq();\r\n__smp_spurious_interrupt();\r\nexiting_irq();\r\n}\r\n__visible void smp_trace_spurious_interrupt(struct pt_regs *regs)\r\n{\r\nentering_irq();\r\ntrace_spurious_apic_entry(SPURIOUS_APIC_VECTOR);\r\n__smp_spurious_interrupt();\r\ntrace_spurious_apic_exit(SPURIOUS_APIC_VECTOR);\r\nexiting_irq();\r\n}\r\nstatic inline void __smp_error_interrupt(struct pt_regs *regs)\r\n{\r\nu32 v;\r\nu32 i = 0;\r\nstatic const char * const error_interrupt_reason[] = {\r\n"Send CS error",\r\n"Receive CS error",\r\n"Send accept error",\r\n"Receive accept error",\r\n"Redirectable IPI",\r\n"Send illegal vector",\r\n"Received illegal vector",\r\n"Illegal register address",\r\n};\r\nif (lapic_get_maxlvt() > 3)\r\napic_write(APIC_ESR, 0);\r\nv = apic_read(APIC_ESR);\r\nack_APIC_irq();\r\natomic_inc(&irq_err_count);\r\napic_printk(APIC_DEBUG, KERN_DEBUG "APIC error on CPU%d: %02x",\r\nsmp_processor_id(), v);\r\nv &= 0xff;\r\nwhile (v) {\r\nif (v & 0x1)\r\napic_printk(APIC_DEBUG, KERN_CONT " : %s", error_interrupt_reason[i]);\r\ni++;\r\nv >>= 1;\r\n}\r\napic_printk(APIC_DEBUG, KERN_CONT "\n");\r\n}\r\n__visible void smp_error_interrupt(struct pt_regs *regs)\r\n{\r\nentering_irq();\r\n__smp_error_interrupt(regs);\r\nexiting_irq();\r\n}\r\n__visible void smp_trace_error_interrupt(struct pt_regs *regs)\r\n{\r\nentering_irq();\r\ntrace_error_apic_entry(ERROR_APIC_VECTOR);\r\n__smp_error_interrupt(regs);\r\ntrace_error_apic_exit(ERROR_APIC_VECTOR);\r\nexiting_irq();\r\n}\r\nvoid __init connect_bsp_APIC(void)\r\n{\r\n#ifdef CONFIG_X86_32\r\nif (pic_mode) {\r\nclear_local_APIC();\r\napic_printk(APIC_VERBOSE, "leaving PIC mode, "\r\n"enabling APIC mode.\n");\r\nimcr_pic_to_apic();\r\n}\r\n#endif\r\nif (apic->enable_apic_mode)\r\napic->enable_apic_mode();\r\n}\r\nvoid disconnect_bsp_APIC(int virt_wire_setup)\r\n{\r\nunsigned int value;\r\n#ifdef CONFIG_X86_32\r\nif (pic_mode) {\r\napic_printk(APIC_VERBOSE, "disabling APIC mode, "\r\n"entering PIC mode.\n");\r\nimcr_apic_to_pic();\r\nreturn;\r\n}\r\n#endif\r\nvalue = apic_read(APIC_SPIV);\r\nvalue &= ~APIC_VECTOR_MASK;\r\nvalue |= APIC_SPIV_APIC_ENABLED;\r\nvalue |= 0xf;\r\napic_write(APIC_SPIV, value);\r\nif (!virt_wire_setup) {\r\nvalue = apic_read(APIC_LVT0);\r\nvalue &= ~(APIC_MODE_MASK | APIC_SEND_PENDING |\r\nAPIC_INPUT_POLARITY | APIC_LVT_REMOTE_IRR |\r\nAPIC_LVT_LEVEL_TRIGGER | APIC_LVT_MASKED);\r\nvalue |= APIC_LVT_REMOTE_IRR | APIC_SEND_PENDING;\r\nvalue = SET_APIC_DELIVERY_MODE(value, APIC_MODE_EXTINT);\r\napic_write(APIC_LVT0, value);\r\n} else {\r\napic_write(APIC_LVT0, APIC_LVT_MASKED);\r\n}\r\nvalue = apic_read(APIC_LVT1);\r\nvalue &= ~(APIC_MODE_MASK | APIC_SEND_PENDING |\r\nAPIC_INPUT_POLARITY | APIC_LVT_REMOTE_IRR |\r\nAPIC_LVT_LEVEL_TRIGGER | APIC_LVT_MASKED);\r\nvalue |= APIC_LVT_REMOTE_IRR | APIC_SEND_PENDING;\r\nvalue = SET_APIC_DELIVERY_MODE(value, APIC_MODE_NMI);\r\napic_write(APIC_LVT1, value);\r\n}\r\nint generic_processor_info(int apicid, int version)\r\n{\r\nint cpu, max = nr_cpu_ids;\r\nbool boot_cpu_detected = physid_isset(boot_cpu_physical_apicid,\r\nphys_cpu_present_map);\r\nif (disabled_cpu_apicid != BAD_APICID &&\r\ndisabled_cpu_apicid != read_apic_id() &&\r\ndisabled_cpu_apicid == apicid) {\r\nint thiscpu = num_processors + disabled_cpus;\r\npr_warning("APIC: Disabling requested cpu."\r\n" Processor %d/0x%x ignored.\n",\r\nthiscpu, apicid);\r\ndisabled_cpus++;\r\nreturn -ENODEV;\r\n}\r\nif (!boot_cpu_detected && num_processors >= nr_cpu_ids - 1 &&\r\napicid != boot_cpu_physical_apicid) {\r\nint thiscpu = max + disabled_cpus - 1;\r\npr_warning(\r\n"ACPI: NR_CPUS/possible_cpus limit of %i almost"\r\n" reached. Keeping one slot for boot cpu."\r\n" Processor %d/0x%x ignored.\n", max, thiscpu, apicid);\r\ndisabled_cpus++;\r\nreturn -ENODEV;\r\n}\r\nif (num_processors >= nr_cpu_ids) {\r\nint thiscpu = max + disabled_cpus;\r\npr_warning(\r\n"ACPI: NR_CPUS/possible_cpus limit of %i reached."\r\n" Processor %d/0x%x ignored.\n", max, thiscpu, apicid);\r\ndisabled_cpus++;\r\nreturn -EINVAL;\r\n}\r\nnum_processors++;\r\nif (apicid == boot_cpu_physical_apicid) {\r\ncpu = 0;\r\n} else\r\ncpu = cpumask_next_zero(-1, cpu_present_mask);\r\nif (version == 0x0) {\r\npr_warning("BIOS bug: APIC version is 0 for CPU %d/0x%x, fixing up to 0x10\n",\r\ncpu, apicid);\r\nversion = 0x10;\r\n}\r\napic_version[apicid] = version;\r\nif (version != apic_version[boot_cpu_physical_apicid]) {\r\npr_warning("BIOS bug: APIC version mismatch, boot CPU: %x, CPU %d: version %x\n",\r\napic_version[boot_cpu_physical_apicid], cpu, version);\r\n}\r\nphysid_set(apicid, phys_cpu_present_map);\r\nif (apicid > max_physical_apicid)\r\nmax_physical_apicid = apicid;\r\n#if defined(CONFIG_SMP) || defined(CONFIG_X86_64)\r\nearly_per_cpu(x86_cpu_to_apicid, cpu) = apicid;\r\nearly_per_cpu(x86_bios_cpu_apicid, cpu) = apicid;\r\n#endif\r\n#ifdef CONFIG_X86_32\r\nearly_per_cpu(x86_cpu_to_logical_apicid, cpu) =\r\napic->x86_32_early_logical_apicid(cpu);\r\n#endif\r\nset_cpu_possible(cpu, true);\r\nset_cpu_present(cpu, true);\r\nreturn cpu;\r\n}\r\nint hard_smp_processor_id(void)\r\n{\r\nreturn read_apic_id();\r\n}\r\nvoid default_init_apic_ldr(void)\r\n{\r\nunsigned long val;\r\napic_write(APIC_DFR, APIC_DFR_VALUE);\r\nval = apic_read(APIC_LDR) & ~APIC_LDR_MASK;\r\nval |= SET_APIC_LOGICAL_ID(1UL << smp_processor_id());\r\napic_write(APIC_LDR, val);\r\n}\r\nint default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,\r\nconst struct cpumask *andmask,\r\nunsigned int *apicid)\r\n{\r\nunsigned int cpu;\r\nfor_each_cpu_and(cpu, cpumask, andmask) {\r\nif (cpumask_test_cpu(cpu, cpu_online_mask))\r\nbreak;\r\n}\r\nif (likely(cpu < nr_cpu_ids)) {\r\n*apicid = per_cpu(x86_cpu_to_apicid, cpu);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid __init apic_set_eoi_write(void (*eoi_write)(u32 reg, u32 v))\r\n{\r\nstruct apic **drv;\r\nfor (drv = __apicdrivers; drv < __apicdrivers_end; drv++) {\r\nWARN_ON((*drv)->eoi_write == eoi_write);\r\n(*drv)->eoi_write = eoi_write;\r\n}\r\n}\r\nstatic int lapic_suspend(void)\r\n{\r\nunsigned long flags;\r\nint maxlvt;\r\nif (!apic_pm_state.active)\r\nreturn 0;\r\nmaxlvt = lapic_get_maxlvt();\r\napic_pm_state.apic_id = apic_read(APIC_ID);\r\napic_pm_state.apic_taskpri = apic_read(APIC_TASKPRI);\r\napic_pm_state.apic_ldr = apic_read(APIC_LDR);\r\napic_pm_state.apic_dfr = apic_read(APIC_DFR);\r\napic_pm_state.apic_spiv = apic_read(APIC_SPIV);\r\napic_pm_state.apic_lvtt = apic_read(APIC_LVTT);\r\nif (maxlvt >= 4)\r\napic_pm_state.apic_lvtpc = apic_read(APIC_LVTPC);\r\napic_pm_state.apic_lvt0 = apic_read(APIC_LVT0);\r\napic_pm_state.apic_lvt1 = apic_read(APIC_LVT1);\r\napic_pm_state.apic_lvterr = apic_read(APIC_LVTERR);\r\napic_pm_state.apic_tmict = apic_read(APIC_TMICT);\r\napic_pm_state.apic_tdcr = apic_read(APIC_TDCR);\r\n#ifdef CONFIG_X86_THERMAL_VECTOR\r\nif (maxlvt >= 5)\r\napic_pm_state.apic_thmr = apic_read(APIC_LVTTHMR);\r\n#endif\r\nlocal_irq_save(flags);\r\ndisable_local_APIC();\r\nirq_remapping_disable();\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void lapic_resume(void)\r\n{\r\nunsigned int l, h;\r\nunsigned long flags;\r\nint maxlvt;\r\nif (!apic_pm_state.active)\r\nreturn;\r\nlocal_irq_save(flags);\r\nmask_ioapic_entries();\r\nlegacy_pic->mask_all();\r\nif (x2apic_mode)\r\nenable_x2apic();\r\nelse {\r\nif (boot_cpu_data.x86 >= 6) {\r\nrdmsr(MSR_IA32_APICBASE, l, h);\r\nl &= ~MSR_IA32_APICBASE_BASE;\r\nl |= MSR_IA32_APICBASE_ENABLE | mp_lapic_addr;\r\nwrmsr(MSR_IA32_APICBASE, l, h);\r\n}\r\n}\r\nmaxlvt = lapic_get_maxlvt();\r\napic_write(APIC_LVTERR, ERROR_APIC_VECTOR | APIC_LVT_MASKED);\r\napic_write(APIC_ID, apic_pm_state.apic_id);\r\napic_write(APIC_DFR, apic_pm_state.apic_dfr);\r\napic_write(APIC_LDR, apic_pm_state.apic_ldr);\r\napic_write(APIC_TASKPRI, apic_pm_state.apic_taskpri);\r\napic_write(APIC_SPIV, apic_pm_state.apic_spiv);\r\napic_write(APIC_LVT0, apic_pm_state.apic_lvt0);\r\napic_write(APIC_LVT1, apic_pm_state.apic_lvt1);\r\n#if defined(CONFIG_X86_MCE_INTEL)\r\nif (maxlvt >= 5)\r\napic_write(APIC_LVTTHMR, apic_pm_state.apic_thmr);\r\n#endif\r\nif (maxlvt >= 4)\r\napic_write(APIC_LVTPC, apic_pm_state.apic_lvtpc);\r\napic_write(APIC_LVTT, apic_pm_state.apic_lvtt);\r\napic_write(APIC_TDCR, apic_pm_state.apic_tdcr);\r\napic_write(APIC_TMICT, apic_pm_state.apic_tmict);\r\napic_write(APIC_ESR, 0);\r\napic_read(APIC_ESR);\r\napic_write(APIC_LVTERR, apic_pm_state.apic_lvterr);\r\napic_write(APIC_ESR, 0);\r\napic_read(APIC_ESR);\r\nirq_remapping_reenable(x2apic_mode);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void apic_pm_activate(void)\r\n{\r\napic_pm_state.active = 1;\r\n}\r\nstatic int __init init_lapic_sysfs(void)\r\n{\r\nif (cpu_has_apic)\r\nregister_syscore_ops(&lapic_syscore_ops);\r\nreturn 0;\r\n}\r\nstatic void apic_pm_activate(void) { }\r\nstatic int apic_cluster_num(void)\r\n{\r\nint i, clusters, zeros;\r\nunsigned id;\r\nu16 *bios_cpu_apicid;\r\nDECLARE_BITMAP(clustermap, NUM_APIC_CLUSTERS);\r\nbios_cpu_apicid = early_per_cpu_ptr(x86_bios_cpu_apicid);\r\nbitmap_zero(clustermap, NUM_APIC_CLUSTERS);\r\nfor (i = 0; i < nr_cpu_ids; i++) {\r\nif (bios_cpu_apicid) {\r\nid = bios_cpu_apicid[i];\r\n} else if (i < nr_cpu_ids) {\r\nif (cpu_present(i))\r\nid = per_cpu(x86_bios_cpu_apicid, i);\r\nelse\r\ncontinue;\r\n} else\r\nbreak;\r\nif (id != BAD_APICID)\r\n__set_bit(APIC_CLUSTERID(id), clustermap);\r\n}\r\nclusters = 0;\r\nzeros = 0;\r\nfor (i = 0; i < NUM_APIC_CLUSTERS; i++) {\r\nif (test_bit(i, clustermap)) {\r\nclusters += 1 + zeros;\r\nzeros = 0;\r\n} else\r\n++zeros;\r\n}\r\nreturn clusters;\r\n}\r\nstatic int set_multi(const struct dmi_system_id *d)\r\n{\r\nif (multi)\r\nreturn 0;\r\npr_info("APIC: %s detected, Multi Chassis\n", d->ident);\r\nmulti = 1;\r\nreturn 0;\r\n}\r\nstatic void dmi_check_multi(void)\r\n{\r\nif (multi_checked)\r\nreturn;\r\ndmi_check_system(multi_dmi_table);\r\nmulti_checked = 1;\r\n}\r\nint apic_is_clustered_box(void)\r\n{\r\ndmi_check_multi();\r\nif (multi)\r\nreturn 1;\r\nif (!is_vsmp_box())\r\nreturn 0;\r\nif (apic_cluster_num() > 1)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init setup_disableapic(char *arg)\r\n{\r\ndisable_apic = 1;\r\nsetup_clear_cpu_cap(X86_FEATURE_APIC);\r\nreturn 0;\r\n}\r\nstatic int __init setup_nolapic(char *arg)\r\n{\r\nreturn setup_disableapic(arg);\r\n}\r\nstatic int __init parse_lapic_timer_c2_ok(char *arg)\r\n{\r\nlocal_apic_timer_c2_ok = 1;\r\nreturn 0;\r\n}\r\nstatic int __init parse_disable_apic_timer(char *arg)\r\n{\r\ndisable_apic_timer = 1;\r\nreturn 0;\r\n}\r\nstatic int __init parse_nolapic_timer(char *arg)\r\n{\r\ndisable_apic_timer = 1;\r\nreturn 0;\r\n}\r\nstatic int __init apic_set_verbosity(char *arg)\r\n{\r\nif (!arg) {\r\n#ifdef CONFIG_X86_64\r\nskip_ioapic_setup = 0;\r\nreturn 0;\r\n#endif\r\nreturn -EINVAL;\r\n}\r\nif (strcmp("debug", arg) == 0)\r\napic_verbosity = APIC_DEBUG;\r\nelse if (strcmp("verbose", arg) == 0)\r\napic_verbosity = APIC_VERBOSE;\r\nelse {\r\npr_warning("APIC Verbosity level %s not recognised"\r\n" use apic=verbose or apic=debug\n", arg);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init lapic_insert_resource(void)\r\n{\r\nif (!apic_phys)\r\nreturn -1;\r\nlapic_resource.start = apic_phys;\r\nlapic_resource.end = lapic_resource.start + PAGE_SIZE - 1;\r\ninsert_resource(&iomem_resource, &lapic_resource);\r\nreturn 0;\r\n}\r\nstatic int __init apic_set_disabled_cpu_apicid(char *arg)\r\n{\r\nif (!arg || !get_option(&arg, &disabled_cpu_apicid))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}
