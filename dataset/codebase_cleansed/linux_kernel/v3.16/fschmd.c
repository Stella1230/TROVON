static void fschmd_release_resources(struct kref *ref)\r\n{\r\nstruct fschmd_data *data = container_of(ref, struct fschmd_data, kref);\r\nkfree(data);\r\n}\r\nstatic ssize_t show_in_value(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nconst int max_reading[3] = { 14200, 6600, 3300 };\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nif (data->kind == fscher || data->kind >= fschrc)\r\nreturn sprintf(buf, "%d\n", (data->volt[index] * dmi_vref *\r\ndmi_mult[index]) / 255 + dmi_offset[index]);\r\nelse\r\nreturn sprintf(buf, "%d\n", (data->volt[index] *\r\nmax_reading[index] + 128) / 255);\r\n}\r\nstatic ssize_t show_temp_value(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_act[index]));\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_max[index]));\r\n}\r\nstatic ssize_t store_temp_max(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = dev_get_drvdata(dev);\r\nlong v;\r\nint err;\r\nerr = kstrtol(buf, 10, &v);\r\nif (err)\r\nreturn err;\r\nv = clamp_val(v / 1000, -128, 127) + 128;\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nFSCHMD_REG_TEMP_LIMIT[data->kind][index], v);\r\ndata->temp_max[index] = v;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_fault(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nif (data->temp_status[index] & FSCHMD_TEMP_WORKING)\r\nreturn sprintf(buf, "0\n");\r\nelse\r\nreturn sprintf(buf, "1\n");\r\n}\r\nstatic ssize_t show_temp_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nif ((data->temp_status[index] & FSCHMD_TEMP_ALARM_MASK) ==\r\nFSCHMD_TEMP_ALARM_MASK)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_fan_value(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nreturn sprintf(buf, "%u\n", RPM_FROM_REG(data->fan_act[index]));\r\n}\r\nstatic ssize_t show_fan_div(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nreturn sprintf(buf, "%d\n", 1 << (data->fan_ripple[index] & 3));\r\n}\r\nstatic ssize_t store_fan_div(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nu8 reg;\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = dev_get_drvdata(dev);\r\nunsigned long v;\r\nint err;\r\nerr = kstrtoul(buf, 10, &v);\r\nif (err)\r\nreturn err;\r\nswitch (v) {\r\ncase 2:\r\nv = 1;\r\nbreak;\r\ncase 4:\r\nv = 2;\r\nbreak;\r\ncase 8:\r\nv = 3;\r\nbreak;\r\ndefault:\r\ndev_err(dev,\r\n"fan_div value %lu not supported. Choose one of 2, 4 or 8!\n",\r\nv);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\nreg = i2c_smbus_read_byte_data(to_i2c_client(dev),\r\nFSCHMD_REG_FAN_RIPPLE[data->kind][index]);\r\nreg &= ~0x03;\r\nreg |= v;\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nFSCHMD_REG_FAN_RIPPLE[data->kind][index], reg);\r\ndata->fan_ripple[index] = reg;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nif (data->fan_status[index] & FSCHMD_FAN_ALARM)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_fan_fault(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nif (data->fan_status[index] & FSCHMD_FAN_NOT_PRESENT)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_pwm_auto_point1_pwm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nint val = data->fan_min[index];\r\nif (val || data->kind == fscsyl)\r\nval = val / 2 + 128;\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t store_pwm_auto_point1_pwm(struct device *dev,\r\nstruct device_attribute *devattr, const char *buf, size_t count)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct fschmd_data *data = dev_get_drvdata(dev);\r\nunsigned long v;\r\nint err;\r\nerr = kstrtoul(buf, 10, &v);\r\nif (err)\r\nreturn err;\r\nif (v || data->kind == fscsyl) {\r\nv = clamp_val(v, 128, 255);\r\nv = (v - 128) * 2 + 1;\r\n}\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nFSCHMD_REG_FAN_MIN[data->kind][index], v);\r\ndata->fan_min[index] = v;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_alert_led(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct fschmd_data *data = fschmd_update_device(dev);\r\nif (data->global_control & FSCHMD_CONTROL_ALERT_LED)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t store_alert_led(struct device *dev,\r\nstruct device_attribute *devattr, const char *buf, size_t count)\r\n{\r\nu8 reg;\r\nstruct fschmd_data *data = dev_get_drvdata(dev);\r\nunsigned long v;\r\nint err;\r\nerr = kstrtoul(buf, 10, &v);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nreg = i2c_smbus_read_byte_data(to_i2c_client(dev), FSCHMD_REG_CONTROL);\r\nif (v)\r\nreg |= FSCHMD_CONTROL_ALERT_LED;\r\nelse\r\nreg &= ~FSCHMD_CONTROL_ALERT_LED;\r\ni2c_smbus_write_byte_data(to_i2c_client(dev), FSCHMD_REG_CONTROL, reg);\r\ndata->global_control = reg;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int watchdog_set_timeout(struct fschmd_data *data, int timeout)\r\n{\r\nint ret, resolution;\r\nint kind = data->kind + 1;\r\nif (timeout <= 510 || kind == fscpos || kind == fscscy)\r\nresolution = 2;\r\nelse\r\nresolution = 60;\r\nif (timeout < resolution || timeout > (resolution * 255))\r\nreturn -EINVAL;\r\nmutex_lock(&data->watchdog_lock);\r\nif (!data->client) {\r\nret = -ENODEV;\r\ngoto leave;\r\n}\r\nif (resolution == 2)\r\ndata->watchdog_control &= ~FSCHMD_WDOG_CONTROL_RESOLUTION;\r\nelse\r\ndata->watchdog_control |= FSCHMD_WDOG_CONTROL_RESOLUTION;\r\ndata->watchdog_preset = DIV_ROUND_UP(timeout, resolution);\r\ni2c_smbus_write_byte_data(data->client,\r\nFSCHMD_REG_WDOG_PRESET[data->kind], data->watchdog_preset);\r\ni2c_smbus_write_byte_data(data->client,\r\nFSCHMD_REG_WDOG_CONTROL[data->kind],\r\ndata->watchdog_control & ~FSCHMD_WDOG_CONTROL_TRIGGER);\r\nret = data->watchdog_preset * resolution;\r\nleave:\r\nmutex_unlock(&data->watchdog_lock);\r\nreturn ret;\r\n}\r\nstatic int watchdog_get_timeout(struct fschmd_data *data)\r\n{\r\nint timeout;\r\nmutex_lock(&data->watchdog_lock);\r\nif (data->watchdog_control & FSCHMD_WDOG_CONTROL_RESOLUTION)\r\ntimeout = data->watchdog_preset * 60;\r\nelse\r\ntimeout = data->watchdog_preset * 2;\r\nmutex_unlock(&data->watchdog_lock);\r\nreturn timeout;\r\n}\r\nstatic int watchdog_trigger(struct fschmd_data *data)\r\n{\r\nint ret = 0;\r\nmutex_lock(&data->watchdog_lock);\r\nif (!data->client) {\r\nret = -ENODEV;\r\ngoto leave;\r\n}\r\ndata->watchdog_control |= FSCHMD_WDOG_CONTROL_TRIGGER;\r\ni2c_smbus_write_byte_data(data->client,\r\nFSCHMD_REG_WDOG_CONTROL[data->kind],\r\ndata->watchdog_control);\r\nleave:\r\nmutex_unlock(&data->watchdog_lock);\r\nreturn ret;\r\n}\r\nstatic int watchdog_stop(struct fschmd_data *data)\r\n{\r\nint ret = 0;\r\nmutex_lock(&data->watchdog_lock);\r\nif (!data->client) {\r\nret = -ENODEV;\r\ngoto leave;\r\n}\r\ndata->watchdog_control &= ~FSCHMD_WDOG_CONTROL_STARTED;\r\ni2c_smbus_write_byte_data(data->client,\r\nFSCHMD_REG_WDOG_CONTROL[data->kind],\r\ndata->watchdog_control | FSCHMD_WDOG_CONTROL_STOP);\r\nleave:\r\nmutex_unlock(&data->watchdog_lock);\r\nreturn ret;\r\n}\r\nstatic int watchdog_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct fschmd_data *pos, *data = NULL;\r\nint watchdog_is_open;\r\nif (!mutex_trylock(&watchdog_data_mutex))\r\nreturn -ERESTARTSYS;\r\nlist_for_each_entry(pos, &watchdog_data_list, list) {\r\nif (pos->watchdog_miscdev.minor == iminor(inode)) {\r\ndata = pos;\r\nbreak;\r\n}\r\n}\r\nwatchdog_is_open = test_and_set_bit(0, &data->watchdog_is_open);\r\nif (!watchdog_is_open)\r\nkref_get(&data->kref);\r\nmutex_unlock(&watchdog_data_mutex);\r\nif (watchdog_is_open)\r\nreturn -EBUSY;\r\nwatchdog_trigger(data);\r\nfilp->private_data = data;\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int watchdog_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct fschmd_data *data = filp->private_data;\r\nif (data->watchdog_expect_close) {\r\nwatchdog_stop(data);\r\ndata->watchdog_expect_close = 0;\r\n} else {\r\nwatchdog_trigger(data);\r\ndev_crit(&data->client->dev,\r\n"unexpected close, not stopping watchdog!\n");\r\n}\r\nclear_bit(0, &data->watchdog_is_open);\r\nmutex_lock(&watchdog_data_mutex);\r\nkref_put(&data->kref, fschmd_release_resources);\r\nmutex_unlock(&watchdog_data_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t watchdog_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nint ret;\r\nstruct fschmd_data *data = filp->private_data;\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\ndata->watchdog_expect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\ndata->watchdog_expect_close = 1;\r\n}\r\n}\r\nret = watchdog_trigger(data);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn count;\r\n}\r\nstatic long watchdog_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |\r\nWDIOF_CARDRESET,\r\n.identity = "FSC watchdog"\r\n};\r\nint i, ret = 0;\r\nstruct fschmd_data *data = filp->private_data;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nident.firmware_version = data->revision;\r\nif (!nowayout)\r\nident.options |= WDIOF_MAGICCLOSE;\r\nif (copy_to_user((void __user *)arg, &ident, sizeof(ident)))\r\nret = -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nret = put_user(0, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_GETBOOTSTATUS:\r\nif (data->watchdog_state & FSCHMD_WDOG_STATE_CARDRESET)\r\nret = put_user(WDIOF_CARDRESET, (int __user *)arg);\r\nelse\r\nret = put_user(0, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nret = watchdog_trigger(data);\r\nbreak;\r\ncase WDIOC_GETTIMEOUT:\r\ni = watchdog_get_timeout(data);\r\nret = put_user(i, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(i, (int __user *)arg)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = watchdog_set_timeout(data, i);\r\nif (ret > 0)\r\nret = put_user(ret, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(i, (int __user *)arg)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (i & WDIOS_DISABLECARD)\r\nret = watchdog_stop(data);\r\nelse if (i & WDIOS_ENABLECARD)\r\nret = watchdog_trigger(data);\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = -ENOTTY;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fschmd_dmi_decode(const struct dmi_header *header, void *dummy)\r\n{\r\nint i, mult[3] = { 0 }, offset[3] = { 0 }, vref = 0, found = 0;\r\nu8 *dmi_data = (u8 *)header;\r\nif (header->type != 185)\r\nreturn;\r\nif (header->length < 5 || dmi_data[4] != 19)\r\nreturn;\r\nfor (i = 6; (i + 4) < header->length; i += 5) {\r\nif (dmi_data[i] >= 1 && dmi_data[i] <= 3) {\r\nconst int shuffle[3] = { 1, 0, 2 };\r\nint in = shuffle[dmi_data[i] - 1];\r\nif (found & (1 << in))\r\nreturn;\r\nmult[in] = dmi_data[i + 1] | (dmi_data[i + 2] << 8);\r\noffset[in] = dmi_data[i + 3] | (dmi_data[i + 4] << 8);\r\nfound |= 1 << in;\r\n}\r\nif (dmi_data[i] == 7) {\r\nif (found & 0x08)\r\nreturn;\r\nvref = dmi_data[i + 1] | (dmi_data[i + 2] << 8);\r\nfound |= 0x08;\r\n}\r\n}\r\nif (found == 0x0F) {\r\nfor (i = 0; i < 3; i++) {\r\ndmi_mult[i] = mult[i] * 10;\r\ndmi_offset[i] = offset[i] * 10;\r\n}\r\ndmi_mult[3] = dmi_mult[2];\r\ndmi_mult[4] = dmi_mult[1];\r\ndmi_mult[5] = dmi_mult[2];\r\ndmi_offset[3] = dmi_offset[2];\r\ndmi_offset[4] = dmi_offset[1];\r\ndmi_offset[5] = dmi_offset[2];\r\ndmi_vref = vref;\r\n}\r\n}\r\nstatic int fschmd_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nenum chips kind;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nchar id[4];\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nid[0] = i2c_smbus_read_byte_data(client, FSCHMD_REG_IDENT_0);\r\nid[1] = i2c_smbus_read_byte_data(client, FSCHMD_REG_IDENT_1);\r\nid[2] = i2c_smbus_read_byte_data(client, FSCHMD_REG_IDENT_2);\r\nid[3] = '\0';\r\nif (!strcmp(id, "PEG"))\r\nkind = fscpos;\r\nelse if (!strcmp(id, "HER"))\r\nkind = fscher;\r\nelse if (!strcmp(id, "SCY"))\r\nkind = fscscy;\r\nelse if (!strcmp(id, "HRC"))\r\nkind = fschrc;\r\nelse if (!strcmp(id, "HMD"))\r\nkind = fschmd;\r\nelse if (!strcmp(id, "HDS"))\r\nkind = fschds;\r\nelse if (!strcmp(id, "SYL"))\r\nkind = fscsyl;\r\nelse\r\nreturn -ENODEV;\r\nstrlcpy(info->type, fschmd_id[kind].name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int fschmd_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct fschmd_data *data;\r\nconst char * const names[7] = { "Poseidon", "Hermes", "Scylla",\r\n"Heracles", "Heimdall", "Hades", "Syleus" };\r\nconst int watchdog_minors[] = { WATCHDOG_MINOR, 212, 213, 214, 215 };\r\nint i, err;\r\nenum chips kind = id->driver_data;\r\ndata = kzalloc(sizeof(struct fschmd_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nmutex_init(&data->watchdog_lock);\r\nINIT_LIST_HEAD(&data->list);\r\nkref_init(&data->kref);\r\ndata->client = client;\r\ndata->kind = kind;\r\nif (kind == fscpos) {\r\ndata->temp_max[0] = 70 + 128;\r\ndata->temp_max[1] = 50 + 128;\r\ndata->temp_max[2] = 50 + 128;\r\n}\r\nif ((kind == fscher || kind >= fschrc) && dmi_vref == -1) {\r\ndmi_walk(fschmd_dmi_decode, NULL);\r\nif (dmi_vref == -1) {\r\ndev_warn(&client->dev,\r\n"Couldn't get voltage scaling factors from "\r\n"BIOS DMI table, using builtin defaults\n");\r\ndmi_vref = 33;\r\n}\r\n}\r\ndata->revision = i2c_smbus_read_byte_data(client, FSCHMD_REG_REVISION);\r\ndata->global_control = i2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_CONTROL);\r\ndata->watchdog_control = i2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_WDOG_CONTROL[data->kind]);\r\ndata->watchdog_state = i2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_WDOG_STATE[data->kind]);\r\ndata->watchdog_preset = i2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_WDOG_PRESET[data->kind]);\r\nerr = device_create_file(&client->dev, &dev_attr_alert_led);\r\nif (err)\r\ngoto exit_detach;\r\nfor (i = 0; i < FSCHMD_NO_VOLT_SENSORS[data->kind]; i++) {\r\nerr = device_create_file(&client->dev,\r\n&fschmd_attr[i].dev_attr);\r\nif (err)\r\ngoto exit_detach;\r\n}\r\nfor (i = 0; i < (FSCHMD_NO_TEMP_SENSORS[data->kind] * 4); i++) {\r\nif (kind == fscpos && fschmd_temp_attr[i].dev_attr.show ==\r\nshow_temp_max)\r\ncontinue;\r\nif (kind == fscsyl) {\r\nif (i % 4 == 0)\r\ndata->temp_status[i / 4] =\r\ni2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_TEMP_STATE\r\n[data->kind][i / 4]);\r\nif (data->temp_status[i / 4] & FSCHMD_TEMP_DISABLED)\r\ncontinue;\r\n}\r\nerr = device_create_file(&client->dev,\r\n&fschmd_temp_attr[i].dev_attr);\r\nif (err)\r\ngoto exit_detach;\r\n}\r\nfor (i = 0; i < (FSCHMD_NO_FAN_SENSORS[data->kind] * 5); i++) {\r\nif (kind == fscpos &&\r\n!strcmp(fschmd_fan_attr[i].dev_attr.attr.name,\r\n"pwm3_auto_point1_pwm"))\r\ncontinue;\r\nif (kind == fscsyl) {\r\nif (i % 5 == 0)\r\ndata->fan_status[i / 5] =\r\ni2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_FAN_STATE\r\n[data->kind][i / 5]);\r\nif (data->fan_status[i / 5] & FSCHMD_FAN_DISABLED)\r\ncontinue;\r\n}\r\nerr = device_create_file(&client->dev,\r\n&fschmd_fan_attr[i].dev_attr);\r\nif (err)\r\ngoto exit_detach;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndata->hwmon_dev = NULL;\r\ngoto exit_detach;\r\n}\r\nmutex_lock(&watchdog_data_mutex);\r\nfor (i = 0; i < ARRAY_SIZE(watchdog_minors); i++) {\r\nsnprintf(data->watchdog_name, sizeof(data->watchdog_name),\r\n"watchdog%c", (i == 0) ? '\0' : ('0' + i));\r\ndata->watchdog_miscdev.name = data->watchdog_name;\r\ndata->watchdog_miscdev.fops = &watchdog_fops;\r\ndata->watchdog_miscdev.minor = watchdog_minors[i];\r\nerr = misc_register(&data->watchdog_miscdev);\r\nif (err == -EBUSY)\r\ncontinue;\r\nif (err) {\r\ndata->watchdog_miscdev.minor = 0;\r\ndev_err(&client->dev,\r\n"Registering watchdog chardev: %d\n", err);\r\nbreak;\r\n}\r\nlist_add(&data->list, &watchdog_data_list);\r\nwatchdog_set_timeout(data, 60);\r\ndev_info(&client->dev,\r\n"Registered watchdog chardev major 10, minor: %d\n",\r\nwatchdog_minors[i]);\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(watchdog_minors)) {\r\ndata->watchdog_miscdev.minor = 0;\r\ndev_warn(&client->dev,\r\n"Couldn't register watchdog chardev (due to no free minor)\n");\r\n}\r\nmutex_unlock(&watchdog_data_mutex);\r\ndev_info(&client->dev, "Detected FSC %s chip, revision: %d\n",\r\nnames[data->kind], (int) data->revision);\r\nreturn 0;\r\nexit_detach:\r\nfschmd_remove(client);\r\nreturn err;\r\n}\r\nstatic int fschmd_remove(struct i2c_client *client)\r\n{\r\nstruct fschmd_data *data = i2c_get_clientdata(client);\r\nint i;\r\nif (data->watchdog_miscdev.minor) {\r\nmisc_deregister(&data->watchdog_miscdev);\r\nif (data->watchdog_is_open) {\r\ndev_warn(&client->dev,\r\n"i2c client detached with watchdog open! "\r\n"Stopping watchdog.\n");\r\nwatchdog_stop(data);\r\n}\r\nmutex_lock(&watchdog_data_mutex);\r\nlist_del(&data->list);\r\nmutex_unlock(&watchdog_data_mutex);\r\nmutex_lock(&data->watchdog_lock);\r\ndata->client = NULL;\r\nmutex_unlock(&data->watchdog_lock);\r\n}\r\nif (data->hwmon_dev)\r\nhwmon_device_unregister(data->hwmon_dev);\r\ndevice_remove_file(&client->dev, &dev_attr_alert_led);\r\nfor (i = 0; i < (FSCHMD_NO_VOLT_SENSORS[data->kind]); i++)\r\ndevice_remove_file(&client->dev, &fschmd_attr[i].dev_attr);\r\nfor (i = 0; i < (FSCHMD_NO_TEMP_SENSORS[data->kind] * 4); i++)\r\ndevice_remove_file(&client->dev,\r\n&fschmd_temp_attr[i].dev_attr);\r\nfor (i = 0; i < (FSCHMD_NO_FAN_SENSORS[data->kind] * 5); i++)\r\ndevice_remove_file(&client->dev,\r\n&fschmd_fan_attr[i].dev_attr);\r\nmutex_lock(&watchdog_data_mutex);\r\nkref_put(&data->kref, fschmd_release_resources);\r\nmutex_unlock(&watchdog_data_mutex);\r\nreturn 0;\r\n}\r\nstatic struct fschmd_data *fschmd_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct fschmd_data *data = i2c_get_clientdata(client);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + 2 * HZ) || !data->valid) {\r\nfor (i = 0; i < FSCHMD_NO_TEMP_SENSORS[data->kind]; i++) {\r\ndata->temp_act[i] = i2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_TEMP_ACT[data->kind][i]);\r\ndata->temp_status[i] = i2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_TEMP_STATE[data->kind][i]);\r\nif (FSCHMD_REG_TEMP_LIMIT[data->kind][i])\r\ndata->temp_max[i] = i2c_smbus_read_byte_data(\r\nclient,\r\nFSCHMD_REG_TEMP_LIMIT[data->kind][i]);\r\nif ((data->temp_status[i] & FSCHMD_TEMP_ALARM_MASK) ==\r\nFSCHMD_TEMP_ALARM_MASK &&\r\ndata->temp_act[i] < data->temp_max[i])\r\ni2c_smbus_write_byte_data(client,\r\nFSCHMD_REG_TEMP_STATE[data->kind][i],\r\ndata->temp_status[i]);\r\n}\r\nfor (i = 0; i < FSCHMD_NO_FAN_SENSORS[data->kind]; i++) {\r\ndata->fan_act[i] = i2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_FAN_ACT[data->kind][i]);\r\ndata->fan_status[i] = i2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_FAN_STATE[data->kind][i]);\r\ndata->fan_ripple[i] = i2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_FAN_RIPPLE[data->kind][i]);\r\nif (FSCHMD_REG_FAN_MIN[data->kind][i])\r\ndata->fan_min[i] = i2c_smbus_read_byte_data(\r\nclient,\r\nFSCHMD_REG_FAN_MIN[data->kind][i]);\r\nif ((data->fan_status[i] & FSCHMD_FAN_ALARM) &&\r\ndata->fan_act[i])\r\ni2c_smbus_write_byte_data(client,\r\nFSCHMD_REG_FAN_STATE[data->kind][i],\r\ndata->fan_status[i]);\r\n}\r\nfor (i = 0; i < FSCHMD_NO_VOLT_SENSORS[data->kind]; i++)\r\ndata->volt[i] = i2c_smbus_read_byte_data(client,\r\nFSCHMD_REG_VOLT[data->kind][i]);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}
