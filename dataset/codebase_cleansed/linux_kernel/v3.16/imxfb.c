static inline int is_imx1_fb(struct imxfb_info *fbi)\r\n{\r\nreturn fbi->devtype == IMX1_FB;\r\n}\r\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int imxfb_setpalettereg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\nu_int val, ret = 1;\r\n#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)\r\nif (regno < fbi->palette_size) {\r\nval = (CNVT_TOHW(red, 4) << 8) |\r\n(CNVT_TOHW(green,4) << 4) |\r\nCNVT_TOHW(blue, 4);\r\nwritel(val, fbi->regs + 0x800 + (regno << 2));\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int imxfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\nunsigned int val;\r\nint ret = 1;\r\nif (fbi->cmap_inverse) {\r\nred = 0xffff - red;\r\ngreen = 0xffff - green;\r\nblue = 0xffff - blue;\r\n}\r\nif (info->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = info->pseudo_palette;\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nbreak;\r\ncase FB_VISUAL_STATIC_PSEUDOCOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nret = imxfb_setpalettereg(regno, red, green, blue, trans, info);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic const struct imx_fb_videomode *imxfb_find_mode(struct imxfb_info *fbi)\r\n{\r\nstruct imx_fb_videomode *m;\r\nint i;\r\nif (!fb_mode)\r\nreturn &fbi->mode[0];\r\nfor (i = 0, m = &fbi->mode[0]; i < fbi->num_modes; i++, m++) {\r\nif (!strcmp(m->mode.name, fb_mode))\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int imxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\nstruct imxfb_rgb *rgb;\r\nconst struct imx_fb_videomode *imxfb_mode;\r\nunsigned long lcd_clk;\r\nunsigned long long tmp;\r\nu32 pcr = 0;\r\nif (var->xres < MIN_XRES)\r\nvar->xres = MIN_XRES;\r\nif (var->yres < MIN_YRES)\r\nvar->yres = MIN_YRES;\r\nimxfb_mode = imxfb_find_mode(fbi);\r\nif (!imxfb_mode)\r\nreturn -EINVAL;\r\nvar->xres = imxfb_mode->mode.xres;\r\nvar->yres = imxfb_mode->mode.yres;\r\nvar->bits_per_pixel = imxfb_mode->bpp;\r\nvar->pixclock = imxfb_mode->mode.pixclock;\r\nvar->hsync_len = imxfb_mode->mode.hsync_len;\r\nvar->left_margin = imxfb_mode->mode.left_margin;\r\nvar->right_margin = imxfb_mode->mode.right_margin;\r\nvar->vsync_len = imxfb_mode->mode.vsync_len;\r\nvar->upper_margin = imxfb_mode->mode.upper_margin;\r\nvar->lower_margin = imxfb_mode->mode.lower_margin;\r\nvar->sync = imxfb_mode->mode.sync;\r\nvar->xres_virtual = max(var->xres_virtual, var->xres);\r\nvar->yres_virtual = max(var->yres_virtual, var->yres);\r\npr_debug("var->bits_per_pixel=%d\n", var->bits_per_pixel);\r\nlcd_clk = clk_get_rate(fbi->clk_per);\r\ntmp = var->pixclock * (unsigned long long)lcd_clk;\r\ndo_div(tmp, 1000000);\r\nif (do_div(tmp, 1000000) > 500000)\r\ntmp++;\r\npcr = (unsigned int)tmp;\r\nif (--pcr > 0x3F) {\r\npcr = 0x3F;\r\nprintk(KERN_WARNING "Must limit pixel clock to %luHz\n",\r\nlcd_clk / pcr);\r\n}\r\nswitch (var->bits_per_pixel) {\r\ncase 32:\r\npcr |= PCR_BPIX_18;\r\nrgb = &def_rgb_18;\r\nbreak;\r\ncase 16:\r\ndefault:\r\nif (is_imx1_fb(fbi))\r\npcr |= PCR_BPIX_12;\r\nelse\r\npcr |= PCR_BPIX_16;\r\nif (imxfb_mode->pcr & PCR_TFT)\r\nrgb = &def_rgb_16_tft;\r\nelse\r\nrgb = &def_rgb_16_stn;\r\nbreak;\r\ncase 8:\r\npcr |= PCR_BPIX_8;\r\nrgb = &def_rgb_8;\r\nbreak;\r\n}\r\npcr |= imxfb_mode->pcr & ~(0x3f | (7 << 25));\r\nfbi->pcr = pcr;\r\nvar->red = rgb->red;\r\nvar->green = rgb->green;\r\nvar->blue = rgb->blue;\r\nvar->transp = rgb->transp;\r\npr_debug("RGBT length = %d:%d:%d:%d\n",\r\nvar->red.length, var->green.length, var->blue.length,\r\nvar->transp.length);\r\npr_debug("RGBT offset = %d:%d:%d:%d\n",\r\nvar->red.offset, var->green.offset, var->blue.offset,\r\nvar->transp.offset);\r\nreturn 0;\r\n}\r\nstatic int imxfb_set_par(struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nif (var->bits_per_pixel == 16 || var->bits_per_pixel == 32)\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nelse if (!fbi->cmap_static)\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse {\r\ninfo->fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;\r\n}\r\ninfo->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;\r\nfbi->palette_size = var->bits_per_pixel == 8 ? 256 : 16;\r\nimxfb_activate_var(var, info);\r\nreturn 0;\r\n}\r\nstatic void imxfb_enable_controller(struct imxfb_info *fbi)\r\n{\r\nif (fbi->enabled)\r\nreturn;\r\npr_debug("Enabling LCD controller\n");\r\nwritel(fbi->map_dma, fbi->regs + LCDC_SSA);\r\nwritel(0x00000000, fbi->regs + LCDC_POS);\r\nwritel(readl(fbi->regs + LCDC_CPOS) & ~(CPOS_CC0 | CPOS_CC1),\r\nfbi->regs + LCDC_CPOS);\r\nwritel(RMCR_LCDC_EN_MX1, fbi->regs + LCDC_RMCR);\r\nclk_prepare_enable(fbi->clk_ipg);\r\nclk_prepare_enable(fbi->clk_ahb);\r\nclk_prepare_enable(fbi->clk_per);\r\nfbi->enabled = true;\r\n}\r\nstatic void imxfb_disable_controller(struct imxfb_info *fbi)\r\n{\r\nif (!fbi->enabled)\r\nreturn;\r\npr_debug("Disabling LCD controller\n");\r\nclk_disable_unprepare(fbi->clk_per);\r\nclk_disable_unprepare(fbi->clk_ipg);\r\nclk_disable_unprepare(fbi->clk_ahb);\r\nfbi->enabled = false;\r\nwritel(0, fbi->regs + LCDC_RMCR);\r\n}\r\nstatic int imxfb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\npr_debug("imxfb_blank: blank=%d\n", blank);\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nimxfb_disable_controller(fbi);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nimxfb_enable_controller(fbi);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imxfb_activate_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\nu32 ymax_mask = is_imx1_fb(fbi) ? YMAX_MASK_IMX1 : YMAX_MASK_IMX21;\r\npr_debug("var: xres=%d hslen=%d lm=%d rm=%d\n",\r\nvar->xres, var->hsync_len,\r\nvar->left_margin, var->right_margin);\r\npr_debug("var: yres=%d vslen=%d um=%d bm=%d\n",\r\nvar->yres, var->vsync_len,\r\nvar->upper_margin, var->lower_margin);\r\n#if DEBUG_VAR\r\nif (var->xres < 16 || var->xres > 1024)\r\nprintk(KERN_ERR "%s: invalid xres %d\n",\r\ninfo->fix.id, var->xres);\r\nif (var->hsync_len < 1 || var->hsync_len > 64)\r\nprintk(KERN_ERR "%s: invalid hsync_len %d\n",\r\ninfo->fix.id, var->hsync_len);\r\nif (var->left_margin > 255)\r\nprintk(KERN_ERR "%s: invalid left_margin %d\n",\r\ninfo->fix.id, var->left_margin);\r\nif (var->right_margin > 255)\r\nprintk(KERN_ERR "%s: invalid right_margin %d\n",\r\ninfo->fix.id, var->right_margin);\r\nif (var->yres < 1 || var->yres > ymax_mask)\r\nprintk(KERN_ERR "%s: invalid yres %d\n",\r\ninfo->fix.id, var->yres);\r\nif (var->vsync_len > 100)\r\nprintk(KERN_ERR "%s: invalid vsync_len %d\n",\r\ninfo->fix.id, var->vsync_len);\r\nif (var->upper_margin > 63)\r\nprintk(KERN_ERR "%s: invalid upper_margin %d\n",\r\ninfo->fix.id, var->upper_margin);\r\nif (var->lower_margin > 255)\r\nprintk(KERN_ERR "%s: invalid lower_margin %d\n",\r\ninfo->fix.id, var->lower_margin);\r\n#endif\r\nwritel(VPW_VPW(var->xres * var->bits_per_pixel / 8 / 4),\r\nfbi->regs + LCDC_VPW);\r\nwritel(HCR_H_WIDTH(var->hsync_len - 1) |\r\nHCR_H_WAIT_1(var->right_margin - 1) |\r\nHCR_H_WAIT_2(var->left_margin - 3),\r\nfbi->regs + LCDC_HCR);\r\nwritel(VCR_V_WIDTH(var->vsync_len) |\r\nVCR_V_WAIT_1(var->lower_margin) |\r\nVCR_V_WAIT_2(var->upper_margin),\r\nfbi->regs + LCDC_VCR);\r\nwritel(SIZE_XMAX(var->xres) | (var->yres & ymax_mask),\r\nfbi->regs + LCDC_SIZE);\r\nwritel(fbi->pcr, fbi->regs + LCDC_PCR);\r\nif (fbi->pwmr)\r\nwritel(fbi->pwmr, fbi->regs + LCDC_PWMR);\r\nwritel(fbi->lscr1, fbi->regs + LCDC_LSCR1);\r\nif (fbi->dmacr)\r\nwritel(fbi->dmacr, fbi->regs + LCDC_DMACR);\r\nreturn 0;\r\n}\r\nstatic int imxfb_init_fbinfo(struct platform_device *pdev)\r\n{\r\nstruct imx_fb_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct fb_info *info = dev_get_drvdata(&pdev->dev);\r\nstruct imxfb_info *fbi = info->par;\r\nstruct device_node *np;\r\npr_debug("%s\n",__func__);\r\ninfo->pseudo_palette = kmalloc(sizeof(u32) * 16, GFP_KERNEL);\r\nif (!info->pseudo_palette)\r\nreturn -ENOMEM;\r\nmemset(fbi, 0, sizeof(struct imxfb_info));\r\nfbi->devtype = pdev->id_entry->driver_data;\r\nstrlcpy(info->fix.id, IMX_NAME, sizeof(info->fix.id));\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->var.nonstd = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.height = -1;\r\ninfo->var.width = -1;\r\ninfo->var.accel_flags = 0;\r\ninfo->var.vmode = FB_VMODE_NONINTERLACED;\r\ninfo->fbops = &imxfb_ops;\r\ninfo->flags = FBINFO_FLAG_DEFAULT |\r\nFBINFO_READS_FAST;\r\nif (pdata) {\r\nfbi->lscr1 = pdata->lscr1;\r\nfbi->dmacr = pdata->dmacr;\r\nfbi->pwmr = pdata->pwmr;\r\n} else {\r\nnp = pdev->dev.of_node;\r\ninfo->var.grayscale = of_property_read_bool(np,\r\n"cmap-greyscale");\r\nfbi->cmap_inverse = of_property_read_bool(np, "cmap-inverse");\r\nfbi->cmap_static = of_property_read_bool(np, "cmap-static");\r\nfbi->lscr1 = IMXFB_LSCR1_DEFAULT;\r\nof_property_read_u32(np, "fsl,lpccr", &fbi->pwmr);\r\nof_property_read_u32(np, "fsl,lscr1", &fbi->lscr1);\r\nof_property_read_u32(np, "fsl,dmacr", &fbi->dmacr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imxfb_of_read_mode(struct device *dev, struct device_node *np,\r\nstruct imx_fb_videomode *imxfb_mode)\r\n{\r\nint ret;\r\nstruct fb_videomode *of_mode = &imxfb_mode->mode;\r\nu32 bpp;\r\nu32 pcr;\r\nret = of_property_read_string(np, "model", &of_mode->name);\r\nif (ret)\r\nof_mode->name = NULL;\r\nret = of_get_fb_videomode(np, of_mode, OF_USE_NATIVE_MODE);\r\nif (ret) {\r\ndev_err(dev, "Failed to get videomode from DT\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "bits-per-pixel", &bpp);\r\nret |= of_property_read_u32(np, "fsl,pcr", &pcr);\r\nif (ret) {\r\ndev_err(dev, "Failed to read bpp and pcr from DT\n");\r\nreturn -EINVAL;\r\n}\r\nif (bpp < 1 || bpp > 255) {\r\ndev_err(dev, "Bits per pixel have to be between 1 and 255\n");\r\nreturn -EINVAL;\r\n}\r\nimxfb_mode->bpp = bpp;\r\nimxfb_mode->pcr = pcr;\r\nreturn 0;\r\n}\r\nstatic int imxfb_lcd_check_fb(struct lcd_device *lcddev, struct fb_info *fi)\r\n{\r\nstruct imxfb_info *fbi = dev_get_drvdata(&lcddev->dev);\r\nif (!fi || fi->par == fbi)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int imxfb_lcd_get_contrast(struct lcd_device *lcddev)\r\n{\r\nstruct imxfb_info *fbi = dev_get_drvdata(&lcddev->dev);\r\nreturn fbi->pwmr & 0xff;\r\n}\r\nstatic int imxfb_lcd_set_contrast(struct lcd_device *lcddev, int contrast)\r\n{\r\nstruct imxfb_info *fbi = dev_get_drvdata(&lcddev->dev);\r\nif (fbi->pwmr && fbi->enabled) {\r\nif (contrast > 255)\r\ncontrast = 255;\r\nelse if (contrast < 0)\r\ncontrast = 0;\r\nfbi->pwmr &= ~0xff;\r\nfbi->pwmr |= contrast;\r\nwritel(fbi->pwmr, fbi->regs + LCDC_PWMR);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imxfb_lcd_get_power(struct lcd_device *lcddev)\r\n{\r\nstruct imxfb_info *fbi = dev_get_drvdata(&lcddev->dev);\r\nif (!IS_ERR(fbi->lcd_pwr))\r\nreturn regulator_is_enabled(fbi->lcd_pwr);\r\nreturn 1;\r\n}\r\nstatic int imxfb_lcd_set_power(struct lcd_device *lcddev, int power)\r\n{\r\nstruct imxfb_info *fbi = dev_get_drvdata(&lcddev->dev);\r\nif (!IS_ERR(fbi->lcd_pwr)) {\r\nif (power)\r\nreturn regulator_enable(fbi->lcd_pwr);\r\nelse\r\nreturn regulator_disable(fbi->lcd_pwr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imxfb_setup(void)\r\n{\r\nchar *opt, *options = NULL;\r\nif (fb_get_options("imxfb", &options))\r\nreturn -ENODEV;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\nelse\r\nfb_mode = opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imxfb_probe(struct platform_device *pdev)\r\n{\r\nstruct imxfb_info *fbi;\r\nstruct lcd_device *lcd;\r\nstruct fb_info *info;\r\nstruct imx_fb_platform_data *pdata;\r\nstruct resource *res;\r\nstruct imx_fb_videomode *m;\r\nconst struct of_device_id *of_id;\r\nint ret, i;\r\nint bytes_per_pixel;\r\ndev_info(&pdev->dev, "i.MX Framebuffer driver\n");\r\nret = imxfb_setup();\r\nif (ret < 0)\r\nreturn ret;\r\nof_id = of_match_device(imxfb_of_dev_id, &pdev->dev);\r\nif (of_id)\r\npdev->id_entry = of_id->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\npdata = dev_get_platdata(&pdev->dev);\r\ninfo = framebuffer_alloc(sizeof(struct imxfb_info), &pdev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\nfbi = info->par;\r\nplatform_set_drvdata(pdev, info);\r\nret = imxfb_init_fbinfo(pdev);\r\nif (ret < 0)\r\ngoto failed_init;\r\nif (pdata) {\r\nif (!fb_mode)\r\nfb_mode = pdata->mode[0].mode.name;\r\nfbi->mode = pdata->mode;\r\nfbi->num_modes = pdata->num_modes;\r\n} else {\r\nstruct device_node *display_np;\r\nfb_mode = NULL;\r\ndisplay_np = of_parse_phandle(pdev->dev.of_node, "display", 0);\r\nif (!display_np) {\r\ndev_err(&pdev->dev, "No display defined in devicetree\n");\r\nret = -EINVAL;\r\ngoto failed_of_parse;\r\n}\r\nfbi->num_modes = 1;\r\nfbi->mode = devm_kzalloc(&pdev->dev,\r\nsizeof(struct imx_fb_videomode), GFP_KERNEL);\r\nif (!fbi->mode) {\r\nret = -ENOMEM;\r\ngoto failed_of_parse;\r\n}\r\nret = imxfb_of_read_mode(&pdev->dev, display_np, fbi->mode);\r\nif (ret)\r\ngoto failed_of_parse;\r\n}\r\nm = &fbi->mode[0];\r\nbytes_per_pixel = (m->bpp + 7) / 8;\r\nfor (i = 0; i < fbi->num_modes; i++, m++)\r\ninfo->fix.smem_len = max_t(size_t, info->fix.smem_len,\r\nm->mode.xres * m->mode.yres * bytes_per_pixel);\r\nres = request_mem_region(res->start, resource_size(res),\r\nDRIVER_NAME);\r\nif (!res) {\r\nret = -EBUSY;\r\ngoto failed_req;\r\n}\r\nfbi->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(fbi->clk_ipg)) {\r\nret = PTR_ERR(fbi->clk_ipg);\r\ngoto failed_getclock;\r\n}\r\nfbi->clk_ahb = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(fbi->clk_ahb)) {\r\nret = PTR_ERR(fbi->clk_ahb);\r\ngoto failed_getclock;\r\n}\r\nfbi->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(fbi->clk_per)) {\r\nret = PTR_ERR(fbi->clk_per);\r\ngoto failed_getclock;\r\n}\r\nfbi->regs = ioremap(res->start, resource_size(res));\r\nif (fbi->regs == NULL) {\r\ndev_err(&pdev->dev, "Cannot map frame buffer registers\n");\r\nret = -ENOMEM;\r\ngoto failed_ioremap;\r\n}\r\nfbi->map_size = PAGE_ALIGN(info->fix.smem_len);\r\ninfo->screen_base = dma_alloc_writecombine(&pdev->dev, fbi->map_size,\r\n&fbi->map_dma, GFP_KERNEL);\r\nif (!info->screen_base) {\r\ndev_err(&pdev->dev, "Failed to allocate video RAM: %d\n", ret);\r\nret = -ENOMEM;\r\ngoto failed_map;\r\n}\r\ninfo->fix.smem_start = fbi->map_dma;\r\nif (pdata && pdata->init) {\r\nret = pdata->init(fbi->pdev);\r\nif (ret)\r\ngoto failed_platform_init;\r\n}\r\nINIT_LIST_HEAD(&info->modelist);\r\nfor (i = 0; i < fbi->num_modes; i++)\r\nfb_add_videomode(&fbi->mode[i].mode, &info->modelist);\r\nimxfb_check_var(&info->var, info);\r\nret = fb_alloc_cmap(&info->cmap, 1 << info->var.bits_per_pixel, 0);\r\nif (ret < 0)\r\ngoto failed_cmap;\r\nimxfb_set_par(info);\r\nret = register_framebuffer(info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register framebuffer\n");\r\ngoto failed_register;\r\n}\r\nfbi->lcd_pwr = devm_regulator_get(&pdev->dev, "lcd");\r\nif (IS_ERR(fbi->lcd_pwr) && (PTR_ERR(fbi->lcd_pwr) == -EPROBE_DEFER)) {\r\nret = -EPROBE_DEFER;\r\ngoto failed_lcd;\r\n}\r\nlcd = devm_lcd_device_register(&pdev->dev, "imxfb-lcd", &pdev->dev, fbi,\r\n&imxfb_lcd_ops);\r\nif (IS_ERR(lcd)) {\r\nret = PTR_ERR(lcd);\r\ngoto failed_lcd;\r\n}\r\nlcd->props.max_contrast = 0xff;\r\nimxfb_enable_controller(fbi);\r\nfbi->pdev = pdev;\r\nreturn 0;\r\nfailed_lcd:\r\nunregister_framebuffer(info);\r\nfailed_register:\r\nfb_dealloc_cmap(&info->cmap);\r\nfailed_cmap:\r\nif (pdata && pdata->exit)\r\npdata->exit(fbi->pdev);\r\nfailed_platform_init:\r\ndma_free_writecombine(&pdev->dev, fbi->map_size, info->screen_base,\r\nfbi->map_dma);\r\nfailed_map:\r\niounmap(fbi->regs);\r\nfailed_ioremap:\r\nfailed_getclock:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfailed_req:\r\nfailed_of_parse:\r\nkfree(info->pseudo_palette);\r\nfailed_init:\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic int imxfb_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_fb_platform_data *pdata;\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct imxfb_info *fbi = info->par;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nimxfb_disable_controller(fbi);\r\nunregister_framebuffer(info);\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (pdata && pdata->exit)\r\npdata->exit(fbi->pdev);\r\nfb_dealloc_cmap(&info->cmap);\r\nkfree(info->pseudo_palette);\r\nframebuffer_release(info);\r\ndma_free_writecombine(&pdev->dev, fbi->map_size, info->screen_base,\r\nfbi->map_dma);\r\niounmap(fbi->regs);\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused imxfb_suspend(struct device *dev)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct imxfb_info *fbi = info->par;\r\nimxfb_disable_controller(fbi);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused imxfb_resume(struct device *dev)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct imxfb_info *fbi = info->par;\r\nimxfb_enable_controller(fbi);\r\nreturn 0;\r\n}
