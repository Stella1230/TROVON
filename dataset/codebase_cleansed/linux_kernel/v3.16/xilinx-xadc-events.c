static const struct iio_chan_spec *xadc_event_to_channel(\r\nstruct iio_dev *indio_dev, unsigned int event)\r\n{\r\nswitch (event) {\r\ncase XADC_THRESHOLD_OT_MAX:\r\ncase XADC_THRESHOLD_TEMP_MAX:\r\nreturn &indio_dev->channels[0];\r\ncase XADC_THRESHOLD_VCCINT_MAX:\r\ncase XADC_THRESHOLD_VCCAUX_MAX:\r\nreturn &indio_dev->channels[event];\r\ndefault:\r\nreturn &indio_dev->channels[event-1];\r\n}\r\n}\r\nstatic void xadc_handle_event(struct iio_dev *indio_dev, unsigned int event)\r\n{\r\nconst struct iio_chan_spec *chan;\r\nunsigned int offset;\r\nif (event == 0)\r\nreturn;\r\nif (event < 4)\r\noffset = event;\r\nelse\r\noffset = event + 4;\r\nchan = xadc_event_to_channel(indio_dev, event);\r\nif (chan->type == IIO_TEMP) {\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(chan->type, chan->channel,\r\nIIO_EV_TYPE_THRESH, IIO_EV_DIR_RISING),\r\niio_get_time_ns());\r\n} else {\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(chan->type, chan->channel,\r\nIIO_EV_TYPE_THRESH, IIO_EV_DIR_EITHER),\r\niio_get_time_ns());\r\n}\r\n}\r\nvoid xadc_handle_events(struct iio_dev *indio_dev, unsigned long events)\r\n{\r\nunsigned int i;\r\nfor_each_set_bit(i, &events, 8)\r\nxadc_handle_event(indio_dev, i);\r\n}\r\nstatic unsigned xadc_get_threshold_offset(const struct iio_chan_spec *chan,\r\nenum iio_event_direction dir)\r\n{\r\nunsigned int offset;\r\nif (chan->type == IIO_TEMP) {\r\noffset = XADC_THRESHOLD_OT_MAX;\r\n} else {\r\nif (chan->channel < 2)\r\noffset = chan->channel + 1;\r\nelse\r\noffset = chan->channel + 6;\r\n}\r\nif (dir == IIO_EV_DIR_FALLING)\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic unsigned int xadc_get_alarm_mask(const struct iio_chan_spec *chan)\r\n{\r\nif (chan->type == IIO_TEMP) {\r\nreturn XADC_ALARM_OT_MASK;\r\n} else {\r\nswitch (chan->channel) {\r\ncase 0:\r\nreturn XADC_ALARM_VCCINT_MASK;\r\ncase 1:\r\nreturn XADC_ALARM_VCCAUX_MASK;\r\ncase 2:\r\nreturn XADC_ALARM_VCCBRAM_MASK;\r\ncase 3:\r\nreturn XADC_ALARM_VCCPINT_MASK;\r\ncase 4:\r\nreturn XADC_ALARM_VCCPAUX_MASK;\r\ncase 5:\r\nreturn XADC_ALARM_VCCODDR_MASK;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\n}\r\nint xadc_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nreturn (bool)(xadc->alarm_mask & xadc_get_alarm_mask(chan));\r\n}\r\nint xadc_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, int state)\r\n{\r\nunsigned int alarm = xadc_get_alarm_mask(chan);\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nuint16_t cfg, old_cfg;\r\nint ret;\r\nmutex_lock(&xadc->mutex);\r\nif (state)\r\nxadc->alarm_mask |= alarm;\r\nelse\r\nxadc->alarm_mask &= ~alarm;\r\nxadc->ops->update_alarm(xadc, xadc->alarm_mask);\r\nret = _xadc_read_adc_reg(xadc, XADC_REG_CONF1, &cfg);\r\nif (ret)\r\ngoto err_out;\r\nold_cfg = cfg;\r\ncfg |= XADC_CONF1_ALARM_MASK;\r\ncfg &= ~((xadc->alarm_mask & 0xf0) << 4);\r\ncfg &= ~((xadc->alarm_mask & 0x08) >> 3);\r\ncfg &= ~((xadc->alarm_mask & 0x07) << 1);\r\nif (old_cfg != cfg)\r\nret = _xadc_write_adc_reg(xadc, XADC_REG_CONF1, cfg);\r\nerr_out:\r\nmutex_unlock(&xadc->mutex);\r\nreturn ret;\r\n}\r\nint xadc_read_event_value(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nunsigned int offset = xadc_get_threshold_offset(chan, dir);\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\n*val = xadc->threshold[offset];\r\nbreak;\r\ncase IIO_EV_INFO_HYSTERESIS:\r\n*val = xadc->temp_hysteresis;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*val >>= XADC_THRESHOLD_VALUE_SHIFT;\r\nreturn IIO_VAL_INT;\r\n}\r\nint xadc_write_event_value(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info,\r\nint val, int val2)\r\n{\r\nunsigned int offset = xadc_get_threshold_offset(chan, dir);\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nint ret = 0;\r\nval <<= XADC_THRESHOLD_VALUE_SHIFT;\r\nif (val < 0 || val > 0xffff)\r\nreturn -EINVAL;\r\nmutex_lock(&xadc->mutex);\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\nxadc->threshold[offset] = val;\r\nbreak;\r\ncase IIO_EV_INFO_HYSTERESIS:\r\nxadc->temp_hysteresis = val;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&xadc->mutex);\r\nreturn -EINVAL;\r\n}\r\nif (chan->type == IIO_TEMP) {\r\nval |= 0x3;\r\nif (xadc->threshold[offset] < xadc->temp_hysteresis)\r\nxadc->threshold[offset + 4] = 0;\r\nelse\r\nxadc->threshold[offset + 4] = xadc->threshold[offset] -\r\nxadc->temp_hysteresis;\r\nret = _xadc_write_adc_reg(xadc, XADC_REG_THRESHOLD(offset + 4),\r\nxadc->threshold[offset + 4]);\r\nif (ret)\r\ngoto out_unlock;\r\n}\r\nif (info == IIO_EV_INFO_VALUE)\r\nret = _xadc_write_adc_reg(xadc, XADC_REG_THRESHOLD(offset), val);\r\nout_unlock:\r\nmutex_unlock(&xadc->mutex);\r\nreturn ret;\r\n}
