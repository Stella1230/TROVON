static inline u16 atmel_hi(struct atmel_private *priv, u16 offset)\r\n{\r\nreturn priv->host_info_base + offset;\r\n}\r\nstatic inline u16 atmel_co(struct atmel_private *priv, u16 offset)\r\n{\r\nreturn priv->host_info.command_pos + offset;\r\n}\r\nstatic inline u16 atmel_rx(struct atmel_private *priv, u16 offset, u16 desc)\r\n{\r\nreturn priv->host_info.rx_desc_pos + (sizeof(struct rx_desc) * desc) + offset;\r\n}\r\nstatic inline u16 atmel_tx(struct atmel_private *priv, u16 offset, u16 desc)\r\n{\r\nreturn priv->host_info.tx_desc_pos + (sizeof(struct tx_desc) * desc) + offset;\r\n}\r\nstatic inline u8 atmel_read8(struct net_device *dev, u16 offset)\r\n{\r\nreturn inb(dev->base_addr + offset);\r\n}\r\nstatic inline void atmel_write8(struct net_device *dev, u16 offset, u8 data)\r\n{\r\noutb(data, dev->base_addr + offset);\r\n}\r\nstatic inline u16 atmel_read16(struct net_device *dev, u16 offset)\r\n{\r\nreturn inw(dev->base_addr + offset);\r\n}\r\nstatic inline void atmel_write16(struct net_device *dev, u16 offset, u16 data)\r\n{\r\noutw(data, dev->base_addr + offset);\r\n}\r\nstatic inline u8 atmel_rmem8(struct atmel_private *priv, u16 pos)\r\n{\r\natmel_writeAR(priv->dev, pos);\r\nreturn atmel_read8(priv->dev, DR);\r\n}\r\nstatic inline void atmel_wmem8(struct atmel_private *priv, u16 pos, u16 data)\r\n{\r\natmel_writeAR(priv->dev, pos);\r\natmel_write8(priv->dev, DR, data);\r\n}\r\nstatic inline u16 atmel_rmem16(struct atmel_private *priv, u16 pos)\r\n{\r\natmel_writeAR(priv->dev, pos);\r\nreturn atmel_read16(priv->dev, DR);\r\n}\r\nstatic inline void atmel_wmem16(struct atmel_private *priv, u16 pos, u16 data)\r\n{\r\natmel_writeAR(priv->dev, pos);\r\natmel_write16(priv->dev, DR, data);\r\n}\r\nstatic void tx_done_irq(struct atmel_private *priv)\r\n{\r\nint i;\r\nfor (i = 0;\r\natmel_rmem8(priv, atmel_tx(priv, TX_DESC_FLAGS_OFFSET, priv->tx_desc_head)) == TX_DONE &&\r\ni < priv->host_info.tx_desc_count;\r\ni++) {\r\nu8 status = atmel_rmem8(priv, atmel_tx(priv, TX_DESC_STATUS_OFFSET, priv->tx_desc_head));\r\nu16 msdu_size = atmel_rmem16(priv, atmel_tx(priv, TX_DESC_SIZE_OFFSET, priv->tx_desc_head));\r\nu8 type = atmel_rmem8(priv, atmel_tx(priv, TX_DESC_PACKET_TYPE_OFFSET, priv->tx_desc_head));\r\natmel_wmem8(priv, atmel_tx(priv, TX_DESC_FLAGS_OFFSET, priv->tx_desc_head), 0);\r\npriv->tx_free_mem += msdu_size;\r\npriv->tx_desc_free++;\r\nif (priv->tx_buff_head + msdu_size > (priv->host_info.tx_buff_pos + priv->host_info.tx_buff_size))\r\npriv->tx_buff_head = 0;\r\nelse\r\npriv->tx_buff_head += msdu_size;\r\nif (priv->tx_desc_head < (priv->host_info.tx_desc_count - 1))\r\npriv->tx_desc_head++ ;\r\nelse\r\npriv->tx_desc_head = 0;\r\nif (type == TX_PACKET_TYPE_DATA) {\r\nif (status == TX_STATUS_SUCCESS)\r\npriv->dev->stats.tx_packets++;\r\nelse\r\npriv->dev->stats.tx_errors++;\r\nnetif_wake_queue(priv->dev);\r\n}\r\n}\r\n}\r\nstatic u16 find_tx_buff(struct atmel_private *priv, u16 len)\r\n{\r\nu16 bottom_free = priv->host_info.tx_buff_size - priv->tx_buff_tail;\r\nif (priv->tx_desc_free == 3 || priv->tx_free_mem < len)\r\nreturn 0;\r\nif (bottom_free >= len)\r\nreturn priv->host_info.tx_buff_pos + priv->tx_buff_tail;\r\nif (priv->tx_free_mem - bottom_free >= len) {\r\npriv->tx_buff_tail = 0;\r\nreturn priv->host_info.tx_buff_pos;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tx_update_descriptor(struct atmel_private *priv, int is_bcast,\r\nu16 len, u16 buff, u8 type)\r\n{\r\natmel_wmem16(priv, atmel_tx(priv, TX_DESC_POS_OFFSET, priv->tx_desc_tail), buff);\r\natmel_wmem16(priv, atmel_tx(priv, TX_DESC_SIZE_OFFSET, priv->tx_desc_tail), len);\r\nif (!priv->use_wpa)\r\natmel_wmem16(priv, atmel_tx(priv, TX_DESC_HOST_LENGTH_OFFSET, priv->tx_desc_tail), len);\r\natmel_wmem8(priv, atmel_tx(priv, TX_DESC_PACKET_TYPE_OFFSET, priv->tx_desc_tail), type);\r\natmel_wmem8(priv, atmel_tx(priv, TX_DESC_RATE_OFFSET, priv->tx_desc_tail), priv->tx_rate);\r\natmel_wmem8(priv, atmel_tx(priv, TX_DESC_RETRY_OFFSET, priv->tx_desc_tail), 0);\r\nif (priv->use_wpa) {\r\nint cipher_type, cipher_length;\r\nif (is_bcast) {\r\ncipher_type = priv->group_cipher_suite;\r\nif (cipher_type == CIPHER_SUITE_WEP_64 ||\r\ncipher_type == CIPHER_SUITE_WEP_128)\r\ncipher_length = 8;\r\nelse if (cipher_type == CIPHER_SUITE_TKIP)\r\ncipher_length = 12;\r\nelse if (priv->pairwise_cipher_suite == CIPHER_SUITE_WEP_64 ||\r\npriv->pairwise_cipher_suite == CIPHER_SUITE_WEP_128) {\r\ncipher_type = priv->pairwise_cipher_suite;\r\ncipher_length = 8;\r\n} else {\r\ncipher_type = CIPHER_SUITE_NONE;\r\ncipher_length = 0;\r\n}\r\n} else {\r\ncipher_type = priv->pairwise_cipher_suite;\r\nif (cipher_type == CIPHER_SUITE_WEP_64 ||\r\ncipher_type == CIPHER_SUITE_WEP_128)\r\ncipher_length = 8;\r\nelse if (cipher_type == CIPHER_SUITE_TKIP)\r\ncipher_length = 12;\r\nelse if (priv->group_cipher_suite == CIPHER_SUITE_WEP_64 ||\r\npriv->group_cipher_suite == CIPHER_SUITE_WEP_128) {\r\ncipher_type = priv->group_cipher_suite;\r\ncipher_length = 8;\r\n} else {\r\ncipher_type = CIPHER_SUITE_NONE;\r\ncipher_length = 0;\r\n}\r\n}\r\natmel_wmem8(priv, atmel_tx(priv, TX_DESC_CIPHER_TYPE_OFFSET, priv->tx_desc_tail),\r\ncipher_type);\r\natmel_wmem8(priv, atmel_tx(priv, TX_DESC_CIPHER_LENGTH_OFFSET, priv->tx_desc_tail),\r\ncipher_length);\r\n}\r\natmel_wmem32(priv, atmel_tx(priv, TX_DESC_NEXT_OFFSET, priv->tx_desc_tail), 0x80000000L);\r\natmel_wmem8(priv, atmel_tx(priv, TX_DESC_FLAGS_OFFSET, priv->tx_desc_tail), TX_FIRM_OWN);\r\nif (priv->tx_desc_previous != priv->tx_desc_tail)\r\natmel_wmem32(priv, atmel_tx(priv, TX_DESC_NEXT_OFFSET, priv->tx_desc_previous), 0);\r\npriv->tx_desc_previous = priv->tx_desc_tail;\r\nif (priv->tx_desc_tail < (priv->host_info.tx_desc_count - 1))\r\npriv->tx_desc_tail++;\r\nelse\r\npriv->tx_desc_tail = 0;\r\npriv->tx_desc_free--;\r\npriv->tx_free_mem -= len;\r\n}\r\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstatic const u8 SNAP_RFC1024[6] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nstruct ieee80211_hdr header;\r\nunsigned long flags;\r\nu16 buff, frame_ctl, len = (ETH_ZLEN < skb->len) ? skb->len : ETH_ZLEN;\r\nif (priv->card && priv->present_callback &&\r\n!(*priv->present_callback)(priv->card)) {\r\ndev->stats.tx_errors++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (priv->station_state != STATION_STATE_READY) {\r\ndev->stats.tx_errors++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nspin_lock_bh(&priv->timerlock);\r\nspin_lock_irqsave(&priv->irqlock, flags);\r\nif (!(buff = find_tx_buff(priv, len + 18))) {\r\ndev->stats.tx_dropped++;\r\nspin_unlock_irqrestore(&priv->irqlock, flags);\r\nspin_unlock_bh(&priv->timerlock);\r\nnetif_stop_queue(dev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nframe_ctl = IEEE80211_FTYPE_DATA;\r\nheader.duration_id = 0;\r\nheader.seq_ctrl = 0;\r\nif (priv->wep_is_on)\r\nframe_ctl |= IEEE80211_FCTL_PROTECTED;\r\nif (priv->operating_mode == IW_MODE_ADHOC) {\r\nskb_copy_from_linear_data(skb, &header.addr1, ETH_ALEN);\r\nmemcpy(&header.addr2, dev->dev_addr, ETH_ALEN);\r\nmemcpy(&header.addr3, priv->BSSID, ETH_ALEN);\r\n} else {\r\nframe_ctl |= IEEE80211_FCTL_TODS;\r\nmemcpy(&header.addr1, priv->CurrentBSSID, ETH_ALEN);\r\nmemcpy(&header.addr2, dev->dev_addr, ETH_ALEN);\r\nskb_copy_from_linear_data(skb, &header.addr3, ETH_ALEN);\r\n}\r\nif (priv->use_wpa)\r\nmemcpy(&header.addr4, SNAP_RFC1024, ETH_ALEN);\r\nheader.frame_control = cpu_to_le16(frame_ctl);\r\natmel_copy_to_card(dev, buff, (unsigned char *)&header, DATA_FRAME_WS_HEADER_SIZE);\r\natmel_copy_to_card(dev, buff + DATA_FRAME_WS_HEADER_SIZE, skb->data + 12, len - 12);\r\npriv->tx_buff_tail += len - 12 + DATA_FRAME_WS_HEADER_SIZE;\r\ntx_update_descriptor(priv, *(skb->data) & 0x01, len + 18, buff, TX_PACKET_TYPE_DATA);\r\ndev->stats.tx_bytes += len;\r\nspin_unlock_irqrestore(&priv->irqlock, flags);\r\nspin_unlock_bh(&priv->timerlock);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void atmel_transmit_management_frame(struct atmel_private *priv,\r\nstruct ieee80211_hdr *header,\r\nu8 *body, int body_len)\r\n{\r\nu16 buff;\r\nint len = MGMT_FRAME_BODY_OFFSET + body_len;\r\nif (!(buff = find_tx_buff(priv, len)))\r\nreturn;\r\natmel_copy_to_card(priv->dev, buff, (u8 *)header, MGMT_FRAME_BODY_OFFSET);\r\natmel_copy_to_card(priv->dev, buff + MGMT_FRAME_BODY_OFFSET, body, body_len);\r\npriv->tx_buff_tail += len;\r\ntx_update_descriptor(priv, header->addr1[0] & 0x01, len, buff, TX_PACKET_TYPE_MGMT);\r\n}\r\nstatic void fast_rx_path(struct atmel_private *priv,\r\nstruct ieee80211_hdr *header,\r\nu16 msdu_size, u16 rx_packet_loc, u32 crc)\r\n{\r\nu8 mac4[6];\r\nstruct sk_buff *skb;\r\nunsigned char *skbp;\r\natmel_copy_to_host(priv->dev, mac4, rx_packet_loc + 24, 6);\r\nmsdu_size -= 6;\r\nif (priv->do_rx_crc) {\r\ncrc = crc32_le(crc, mac4, 6);\r\nmsdu_size -= 4;\r\n}\r\nif (!(skb = dev_alloc_skb(msdu_size + 14))) {\r\npriv->dev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nskbp = skb_put(skb, msdu_size + 12);\r\natmel_copy_to_host(priv->dev, skbp + 12, rx_packet_loc + 30, msdu_size);\r\nif (priv->do_rx_crc) {\r\nu32 netcrc;\r\ncrc = crc32_le(crc, skbp + 12, msdu_size);\r\natmel_copy_to_host(priv->dev, (void *)&netcrc, rx_packet_loc + 30 + msdu_size, 4);\r\nif ((crc ^ 0xffffffff) != netcrc) {\r\npriv->dev->stats.rx_crc_errors++;\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\n}\r\nmemcpy(skbp, header->addr1, ETH_ALEN);\r\nif (le16_to_cpu(header->frame_control) & IEEE80211_FCTL_FROMDS)\r\nmemcpy(&skbp[ETH_ALEN], header->addr3, ETH_ALEN);\r\nelse\r\nmemcpy(&skbp[ETH_ALEN], header->addr2, ETH_ALEN);\r\nskb->protocol = eth_type_trans(skb, priv->dev);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nnetif_rx(skb);\r\npriv->dev->stats.rx_bytes += 12 + msdu_size;\r\npriv->dev->stats.rx_packets++;\r\n}\r\nstatic int probe_crc(struct atmel_private *priv, u16 packet_loc, u16 msdu_size)\r\n{\r\nint i = msdu_size - 4;\r\nu32 netcrc, crc = 0xffffffff;\r\nif (msdu_size < 4)\r\nreturn 0;\r\natmel_copy_to_host(priv->dev, (void *)&netcrc, packet_loc + i, 4);\r\natmel_writeAR(priv->dev, packet_loc);\r\nwhile (i--) {\r\nu8 octet = atmel_read8(priv->dev, DR);\r\ncrc = crc32_le(crc, &octet, 1);\r\n}\r\nreturn (crc ^ 0xffffffff) == netcrc;\r\n}\r\nstatic void frag_rx_path(struct atmel_private *priv,\r\nstruct ieee80211_hdr *header,\r\nu16 msdu_size, u16 rx_packet_loc, u32 crc, u16 seq_no,\r\nu8 frag_no, int more_frags)\r\n{\r\nu8 mac4[ETH_ALEN];\r\nu8 source[ETH_ALEN];\r\nstruct sk_buff *skb;\r\nif (le16_to_cpu(header->frame_control) & IEEE80211_FCTL_FROMDS)\r\nmemcpy(source, header->addr3, ETH_ALEN);\r\nelse\r\nmemcpy(source, header->addr2, ETH_ALEN);\r\nrx_packet_loc += 24;\r\nif (priv->do_rx_crc)\r\nmsdu_size -= 4;\r\nif (frag_no == 0) {\r\natmel_copy_to_host(priv->dev, mac4, rx_packet_loc, ETH_ALEN);\r\nmsdu_size -= ETH_ALEN;\r\nrx_packet_loc += ETH_ALEN;\r\nif (priv->do_rx_crc)\r\ncrc = crc32_le(crc, mac4, 6);\r\npriv->frag_seq = seq_no;\r\npriv->frag_no = 1;\r\npriv->frag_len = msdu_size;\r\nmemcpy(priv->frag_source, source, ETH_ALEN);\r\nmemcpy(&priv->rx_buf[ETH_ALEN], source, ETH_ALEN);\r\nmemcpy(priv->rx_buf, header->addr1, ETH_ALEN);\r\natmel_copy_to_host(priv->dev, &priv->rx_buf[12], rx_packet_loc, msdu_size);\r\nif (priv->do_rx_crc) {\r\nu32 netcrc;\r\ncrc = crc32_le(crc, &priv->rx_buf[12], msdu_size);\r\natmel_copy_to_host(priv->dev, (void *)&netcrc, rx_packet_loc + msdu_size, 4);\r\nif ((crc ^ 0xffffffff) != netcrc) {\r\npriv->dev->stats.rx_crc_errors++;\r\nmemset(priv->frag_source, 0xff, ETH_ALEN);\r\n}\r\n}\r\n} else if (priv->frag_no == frag_no &&\r\npriv->frag_seq == seq_no &&\r\nmemcmp(priv->frag_source, source, ETH_ALEN) == 0) {\r\natmel_copy_to_host(priv->dev, &priv->rx_buf[12 + priv->frag_len],\r\nrx_packet_loc, msdu_size);\r\nif (priv->do_rx_crc) {\r\nu32 netcrc;\r\ncrc = crc32_le(crc,\r\n&priv->rx_buf[12 + priv->frag_len],\r\nmsdu_size);\r\natmel_copy_to_host(priv->dev, (void *)&netcrc, rx_packet_loc + msdu_size, 4);\r\nif ((crc ^ 0xffffffff) != netcrc) {\r\npriv->dev->stats.rx_crc_errors++;\r\nmemset(priv->frag_source, 0xff, ETH_ALEN);\r\nmore_frags = 1;\r\n}\r\n}\r\npriv->frag_len += msdu_size;\r\npriv->frag_no++;\r\nif (!more_frags) {\r\nmemset(priv->frag_source, 0xff, ETH_ALEN);\r\nif (!(skb = dev_alloc_skb(priv->frag_len + 14))) {\r\npriv->dev->stats.rx_dropped++;\r\n} else {\r\nskb_reserve(skb, 2);\r\nmemcpy(skb_put(skb, priv->frag_len + 12),\r\npriv->rx_buf,\r\npriv->frag_len + 12);\r\nskb->protocol = eth_type_trans(skb, priv->dev);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nnetif_rx(skb);\r\npriv->dev->stats.rx_bytes += priv->frag_len + 12;\r\npriv->dev->stats.rx_packets++;\r\n}\r\n}\r\n} else\r\npriv->wstats.discard.fragment++;\r\n}\r\nstatic void rx_done_irq(struct atmel_private *priv)\r\n{\r\nint i;\r\nstruct ieee80211_hdr header;\r\nfor (i = 0;\r\natmel_rmem8(priv, atmel_rx(priv, RX_DESC_FLAGS_OFFSET, priv->rx_desc_head)) == RX_DESC_FLAG_VALID &&\r\ni < priv->host_info.rx_desc_count;\r\ni++) {\r\nu16 msdu_size, rx_packet_loc, frame_ctl, seq_control;\r\nu8 status = atmel_rmem8(priv, atmel_rx(priv, RX_DESC_STATUS_OFFSET, priv->rx_desc_head));\r\nu32 crc = 0xffffffff;\r\nif (status != RX_STATUS_SUCCESS) {\r\nif (status == 0xc1)\r\npriv->wstats.discard.nwid++;\r\nelse\r\npriv->dev->stats.rx_errors++;\r\ngoto next;\r\n}\r\nmsdu_size = atmel_rmem16(priv, atmel_rx(priv, RX_DESC_MSDU_SIZE_OFFSET, priv->rx_desc_head));\r\nrx_packet_loc = atmel_rmem16(priv, atmel_rx(priv, RX_DESC_MSDU_POS_OFFSET, priv->rx_desc_head));\r\nif (msdu_size < 30) {\r\npriv->dev->stats.rx_errors++;\r\ngoto next;\r\n}\r\natmel_copy_to_host(priv->dev, (char *)&header, rx_packet_loc, 24);\r\nframe_ctl = le16_to_cpu(header.frame_control);\r\nseq_control = le16_to_cpu(header.seq_ctrl);\r\nif (priv->probe_crc) {\r\nif (!priv->wep_is_on || !(frame_ctl & IEEE80211_FCTL_PROTECTED)) {\r\npriv->do_rx_crc = probe_crc(priv, rx_packet_loc, msdu_size);\r\n} else {\r\npriv->do_rx_crc = probe_crc(priv, rx_packet_loc + 24, msdu_size - 24);\r\n}\r\nif (priv->do_rx_crc) {\r\nif (priv->crc_ok_cnt++ > 5)\r\npriv->probe_crc = 0;\r\n} else {\r\nif (priv->crc_ko_cnt++ > 5)\r\npriv->probe_crc = 0;\r\n}\r\n}\r\nif (priv->do_rx_crc && (!priv->wep_is_on || !(frame_ctl & IEEE80211_FCTL_PROTECTED))) {\r\ncrc = crc32_le(0xffffffff, (unsigned char *)&header, 24);\r\n}\r\nmsdu_size -= 24;\r\nif ((frame_ctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA) {\r\nint more_fragments = frame_ctl & IEEE80211_FCTL_MOREFRAGS;\r\nu8 packet_fragment_no = seq_control & IEEE80211_SCTL_FRAG;\r\nu16 packet_sequence_no = (seq_control & IEEE80211_SCTL_SEQ) >> 4;\r\nif (!more_fragments && packet_fragment_no == 0) {\r\nfast_rx_path(priv, &header, msdu_size, rx_packet_loc, crc);\r\n} else {\r\nfrag_rx_path(priv, &header, msdu_size, rx_packet_loc, crc,\r\npacket_sequence_no, packet_fragment_no, more_fragments);\r\n}\r\n}\r\nif ((frame_ctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT) {\r\natmel_copy_to_host(priv->dev, (unsigned char *)&priv->rx_buf, rx_packet_loc + 24, msdu_size);\r\nmemset(priv->frag_source, 0xff, ETH_ALEN);\r\nif (priv->do_rx_crc) {\r\nmsdu_size -= 4;\r\ncrc = crc32_le(crc, (unsigned char *)&priv->rx_buf, msdu_size);\r\nif ((crc ^ 0xffffffff) != (*((u32 *)&priv->rx_buf[msdu_size]))) {\r\npriv->dev->stats.rx_crc_errors++;\r\ngoto next;\r\n}\r\n}\r\natmel_management_frame(priv, &header, msdu_size,\r\natmel_rmem8(priv, atmel_rx(priv, RX_DESC_RSSI_OFFSET, priv->rx_desc_head)));\r\n}\r\nnext:\r\natmel_wmem8(priv, atmel_rx(priv, RX_DESC_FLAGS_OFFSET, priv->rx_desc_head), RX_DESC_FLAG_CONSUMED);\r\nif (priv->rx_desc_head < (priv->host_info.rx_desc_count - 1))\r\npriv->rx_desc_head++;\r\nelse\r\npriv->rx_desc_head = 0;\r\n}\r\n}\r\nstatic irqreturn_t service_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nu8 isr;\r\nint i = -1;\r\nstatic const u8 irq_order[] = {\r\nISR_OUT_OF_RANGE,\r\nISR_RxCOMPLETE,\r\nISR_TxCOMPLETE,\r\nISR_RxFRAMELOST,\r\nISR_FATAL_ERROR,\r\nISR_COMMAND_COMPLETE,\r\nISR_IBSS_MERGE,\r\nISR_GENERIC_IRQ\r\n};\r\nif (priv->card && priv->present_callback &&\r\n!(*priv->present_callback)(priv->card))\r\nreturn IRQ_HANDLED;\r\nif (priv->station_state == STATION_STATE_DOWN)\r\nreturn IRQ_NONE;\r\natmel_clear_gcr(dev, GCR_ENINT);\r\nwhile (1) {\r\nif (!atmel_lock_mac(priv)) {\r\nprintk(KERN_ALERT "%s: failed to contact MAC.\n", dev->name);\r\nreturn IRQ_HANDLED;\r\n}\r\nisr = atmel_rmem8(priv, atmel_hi(priv, IFACE_INT_STATUS_OFFSET));\r\natmel_wmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_MAC_OFFSET), 0);\r\nif (!isr) {\r\natmel_set_gcr(dev, GCR_ENINT);\r\nreturn i == -1 ? IRQ_NONE : IRQ_HANDLED;\r\n}\r\natmel_set_gcr(dev, GCR_ACKINT);\r\nfor (i = 0; i < ARRAY_SIZE(irq_order); i++)\r\nif (isr & irq_order[i])\r\nbreak;\r\nif (!atmel_lock_mac(priv)) {\r\nprintk(KERN_ALERT "%s: failed to contact MAC.\n", dev->name);\r\nreturn IRQ_HANDLED;\r\n}\r\nisr = atmel_rmem8(priv, atmel_hi(priv, IFACE_INT_STATUS_OFFSET));\r\nisr ^= irq_order[i];\r\natmel_wmem8(priv, atmel_hi(priv, IFACE_INT_STATUS_OFFSET), isr);\r\natmel_wmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_MAC_OFFSET), 0);\r\nswitch (irq_order[i]) {\r\ncase ISR_OUT_OF_RANGE:\r\nif (priv->operating_mode == IW_MODE_INFRA &&\r\npriv->station_state == STATION_STATE_READY) {\r\npriv->station_is_associated = 0;\r\natmel_scan(priv, 1);\r\n}\r\nbreak;\r\ncase ISR_RxFRAMELOST:\r\npriv->wstats.discard.misc++;\r\ncase ISR_RxCOMPLETE:\r\nrx_done_irq(priv);\r\nbreak;\r\ncase ISR_TxCOMPLETE:\r\ntx_done_irq(priv);\r\nbreak;\r\ncase ISR_FATAL_ERROR:\r\nprintk(KERN_ALERT "%s: *** FATAL error interrupt ***\n", dev->name);\r\natmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\r\nbreak;\r\ncase ISR_COMMAND_COMPLETE:\r\natmel_command_irq(priv);\r\nbreak;\r\ncase ISR_IBSS_MERGE:\r\natmel_get_mib(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_BSSID_POS,\r\npriv->CurrentBSSID, 6);\r\nif (priv->use_wpa)\r\nbuild_wpa_mib(priv);\r\nbreak;\r\ncase ISR_GENERIC_IRQ:\r\nprintk(KERN_INFO "%s: Generic_irq received.\n", dev->name);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic struct iw_statistics *atmel_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\natmel_smooth_qual(priv);\r\npriv->wstats.status = priv->station_state;\r\nif (priv->operating_mode == IW_MODE_INFRA) {\r\nif (priv->station_state != STATION_STATE_READY) {\r\npriv->wstats.qual.qual = 0;\r\npriv->wstats.qual.level = 0;\r\npriv->wstats.qual.updated = (IW_QUAL_QUAL_INVALID\r\n| IW_QUAL_LEVEL_INVALID);\r\n}\r\npriv->wstats.qual.noise = 0;\r\npriv->wstats.qual.updated |= IW_QUAL_NOISE_INVALID;\r\n} else {\r\npriv->wstats.qual.qual = 0;\r\npriv->wstats.qual.level = 0;\r\npriv->wstats.qual.noise = 0;\r\npriv->wstats.qual.updated = IW_QUAL_QUAL_INVALID\r\n| IW_QUAL_LEVEL_INVALID\r\n| IW_QUAL_NOISE_INVALID;\r\npriv->wstats.miss.beacon = 0;\r\n}\r\nreturn &priv->wstats;\r\n}\r\nstatic int atmel_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < 68) || (new_mtu > 2312))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int atmel_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nmemcpy (dev->dev_addr, addr->sa_data, dev->addr_len);\r\nreturn atmel_open(dev);\r\n}\r\nint atmel_open(struct net_device *dev)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nint i, channel, err;\r\ndel_timer_sync(&priv->management_timer);\r\npriv->station_state = STATION_STATE_DOWN;\r\nif (priv->new_SSID_size) {\r\nmemcpy(priv->SSID, priv->new_SSID, priv->new_SSID_size);\r\npriv->SSID_size = priv->new_SSID_size;\r\npriv->new_SSID_size = 0;\r\n}\r\npriv->BSS_list_entries = 0;\r\npriv->AuthenticationRequestRetryCnt = 0;\r\npriv->AssociationRequestRetryCnt = 0;\r\npriv->ReAssociationRequestRetryCnt = 0;\r\npriv->CurrentAuthentTransactionSeqNum = 0x0001;\r\npriv->ExpectedAuthentTransactionSeqNum = 0x0002;\r\npriv->site_survey_state = SITE_SURVEY_IDLE;\r\npriv->station_is_associated = 0;\r\nerr = reset_atmel_card(dev);\r\nif (err)\r\nreturn err;\r\nif (priv->config_reg_domain) {\r\npriv->reg_domain = priv->config_reg_domain;\r\natmel_set_mib8(priv, Phy_Mib_Type, PHY_MIB_REG_DOMAIN_POS, priv->reg_domain);\r\n} else {\r\npriv->reg_domain = atmel_get_mib8(priv, Phy_Mib_Type, PHY_MIB_REG_DOMAIN_POS);\r\nfor (i = 0; i < ARRAY_SIZE(channel_table); i++)\r\nif (priv->reg_domain == channel_table[i].reg_domain)\r\nbreak;\r\nif (i == ARRAY_SIZE(channel_table)) {\r\npriv->reg_domain = REG_DOMAIN_MKK1;\r\nprintk(KERN_ALERT "%s: failed to get regulatory domain: assuming MKK1.\n", dev->name);\r\n}\r\n}\r\nif ((channel = atmel_validate_channel(priv, priv->channel)))\r\npriv->channel = channel;\r\natmel_scan(priv, 1);\r\natmel_set_gcr(priv->dev, GCR_ENINT);\r\nreturn 0;\r\n}\r\nstatic int atmel_close(struct net_device *dev)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nif (priv->station_state == STATION_STATE_READY) {\r\nunion iwreq_data wrqu;\r\nwrqu.data.length = 0;\r\nwrqu.data.flags = 0;\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);\r\nwireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);\r\n}\r\natmel_enter_state(priv, STATION_STATE_DOWN);\r\nif (priv->bus_type == BUS_TYPE_PCCARD)\r\natmel_write16(dev, GCR, 0x0060);\r\natmel_write16(dev, GCR, 0x0040);\r\nreturn 0;\r\n}\r\nstatic int atmel_validate_channel(struct atmel_private *priv, int channel)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(channel_table); i++)\r\nif (priv->reg_domain == channel_table[i].reg_domain) {\r\nif (channel >= channel_table[i].min &&\r\nchannel <= channel_table[i].max)\r\nreturn 0;\r\nelse\r\nreturn channel_table[i].min;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct atmel_private *priv = m->private;\r\nint i;\r\nchar *s, *r, *c;\r\nseq_printf(m, "Driver version:\t\t%d.%d\n", DRIVER_MAJOR, DRIVER_MINOR);\r\nif (priv->station_state != STATION_STATE_DOWN) {\r\nseq_printf(m,\r\n"Firmware version:\t%d.%d build %d\n"\r\n"Firmware location:\t",\r\npriv->host_info.major_version,\r\npriv->host_info.minor_version,\r\npriv->host_info.build_version);\r\nif (priv->card_type != CARD_TYPE_EEPROM)\r\nseq_puts(m, "on card\n");\r\nelse if (priv->firmware)\r\nseq_printf(m, "%s loaded by host\n", priv->firmware_id);\r\nelse\r\nseq_printf(m, "%s loaded by hotplug\n", priv->firmware_id);\r\nswitch (priv->card_type) {\r\ncase CARD_TYPE_PARALLEL_FLASH:\r\nc = "Parallel flash";\r\nbreak;\r\ncase CARD_TYPE_SPI_FLASH:\r\nc = "SPI flash\n";\r\nbreak;\r\ncase CARD_TYPE_EEPROM:\r\nc = "EEPROM";\r\nbreak;\r\ndefault:\r\nc = "<unknown>";\r\n}\r\nr = "<unknown>";\r\nfor (i = 0; i < ARRAY_SIZE(channel_table); i++)\r\nif (priv->reg_domain == channel_table[i].reg_domain)\r\nr = channel_table[i].name;\r\nseq_printf(m, "MAC memory type:\t%s\n", c);\r\nseq_printf(m, "Regulatory domain:\t%s\n", r);\r\nseq_printf(m, "Host CRC checking:\t%s\n",\r\npriv->do_rx_crc ? "On" : "Off");\r\nseq_printf(m, "WPA-capable firmware:\t%s\n",\r\npriv->use_wpa ? "Yes" : "No");\r\n}\r\nswitch (priv->station_state) {\r\ncase STATION_STATE_SCANNING:\r\ns = "Scanning";\r\nbreak;\r\ncase STATION_STATE_JOINNING:\r\ns = "Joining";\r\nbreak;\r\ncase STATION_STATE_AUTHENTICATING:\r\ns = "Authenticating";\r\nbreak;\r\ncase STATION_STATE_ASSOCIATING:\r\ns = "Associating";\r\nbreak;\r\ncase STATION_STATE_READY:\r\ns = "Ready";\r\nbreak;\r\ncase STATION_STATE_REASSOCIATING:\r\ns = "Reassociating";\r\nbreak;\r\ncase STATION_STATE_MGMT_ERROR:\r\ns = "Management error";\r\nbreak;\r\ncase STATION_STATE_DOWN:\r\ns = "Down";\r\nbreak;\r\ndefault:\r\ns = "<unknown>";\r\n}\r\nseq_printf(m, "Current state:\t\t%s\n", s);\r\nreturn 0;\r\n}\r\nstatic int atmel_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, atmel_proc_show, PDE_DATA(inode));\r\n}\r\nstruct net_device *init_atmel_card(unsigned short irq, unsigned long port,\r\nconst AtmelFWType fw_type,\r\nstruct device *sys_dev,\r\nint (*card_present)(void *), void *card)\r\n{\r\nstruct net_device *dev;\r\nstruct atmel_private *priv;\r\nint rc;\r\ndev = alloc_etherdev(sizeof(*priv));\r\nif (!dev)\r\nreturn NULL;\r\nif (dev_alloc_name(dev, dev->name) < 0) {\r\nprintk(KERN_ERR "atmel: Couldn't get name!\n");\r\ngoto err_out_free;\r\n}\r\npriv = netdev_priv(dev);\r\npriv->dev = dev;\r\npriv->sys_dev = sys_dev;\r\npriv->present_callback = card_present;\r\npriv->card = card;\r\npriv->firmware = NULL;\r\npriv->firmware_id[0] = '\0';\r\npriv->firmware_type = fw_type;\r\nif (firmware)\r\nstrcpy(priv->firmware_id, firmware);\r\npriv->bus_type = card_present ? BUS_TYPE_PCCARD : BUS_TYPE_PCI;\r\npriv->station_state = STATION_STATE_DOWN;\r\npriv->do_rx_crc = 0;\r\nif (priv->bus_type == BUS_TYPE_PCCARD) {\r\npriv->probe_crc = 1;\r\npriv->crc_ok_cnt = priv->crc_ko_cnt = 0;\r\n} else\r\npriv->probe_crc = 0;\r\npriv->last_qual = jiffies;\r\npriv->last_beacon_timestamp = 0;\r\nmemset(priv->frag_source, 0xff, sizeof(priv->frag_source));\r\nmemset(priv->BSSID, 0, ETH_ALEN);\r\npriv->CurrentBSSID[0] = 0xFF;\r\npriv->station_was_associated = 0;\r\npriv->last_survey = jiffies;\r\npriv->preamble = LONG_PREAMBLE;\r\npriv->operating_mode = IW_MODE_INFRA;\r\npriv->connect_to_any_BSS = 0;\r\npriv->config_reg_domain = 0;\r\npriv->reg_domain = 0;\r\npriv->tx_rate = 3;\r\npriv->auto_tx_rate = 1;\r\npriv->channel = 4;\r\npriv->power_mode = 0;\r\npriv->SSID[0] = '\0';\r\npriv->SSID_size = 0;\r\npriv->new_SSID_size = 0;\r\npriv->frag_threshold = 2346;\r\npriv->rts_threshold = 2347;\r\npriv->short_retry = 7;\r\npriv->long_retry = 4;\r\npriv->wep_is_on = 0;\r\npriv->default_key = 0;\r\npriv->encryption_level = 0;\r\npriv->exclude_unencrypted = 0;\r\npriv->group_cipher_suite = priv->pairwise_cipher_suite = CIPHER_SUITE_NONE;\r\npriv->use_wpa = 0;\r\nmemset(priv->wep_keys, 0, sizeof(priv->wep_keys));\r\nmemset(priv->wep_key_len, 0, sizeof(priv->wep_key_len));\r\npriv->default_beacon_period = priv->beacon_period = 100;\r\npriv->listen_interval = 1;\r\ninit_timer(&priv->management_timer);\r\nspin_lock_init(&priv->irqlock);\r\nspin_lock_init(&priv->timerlock);\r\npriv->management_timer.function = atmel_management_timer;\r\npriv->management_timer.data = (unsigned long) dev;\r\ndev->netdev_ops = &atmel_netdev_ops;\r\ndev->wireless_handlers = &atmel_handler_def;\r\ndev->irq = irq;\r\ndev->base_addr = port;\r\nSET_NETDEV_DEV(dev, sys_dev);\r\nif ((rc = request_irq(dev->irq, service_interrupt, IRQF_SHARED, dev->name, dev))) {\r\nprintk(KERN_ERR "%s: register interrupt %d failed, rc %d\n", dev->name, irq, rc);\r\ngoto err_out_free;\r\n}\r\nif (!request_region(dev->base_addr, 32,\r\npriv->bus_type == BUS_TYPE_PCCARD ? "atmel_cs" : "atmel_pci")) {\r\ngoto err_out_irq;\r\n}\r\nif (register_netdev(dev))\r\ngoto err_out_res;\r\nif (!probe_atmel_card(dev)) {\r\nunregister_netdev(dev);\r\ngoto err_out_res;\r\n}\r\nnetif_carrier_off(dev);\r\nif (!proc_create_data("driver/atmel", 0, NULL, &atmel_proc_fops, priv))\r\nprintk(KERN_WARNING "atmel: unable to create /proc entry.\n");\r\nprintk(KERN_INFO "%s: Atmel at76c50x. Version %d.%d. MAC %pM\n",\r\ndev->name, DRIVER_MAJOR, DRIVER_MINOR, dev->dev_addr);\r\nreturn dev;\r\nerr_out_res:\r\nrelease_region(dev->base_addr, 32);\r\nerr_out_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_out_free:\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nvoid stop_atmel_card(struct net_device *dev)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nif (priv->bus_type == BUS_TYPE_PCCARD)\r\natmel_write16(dev, GCR, 0x0060);\r\natmel_write16(dev, GCR, 0x0040);\r\ndel_timer_sync(&priv->management_timer);\r\nunregister_netdev(dev);\r\nremove_proc_entry("driver/atmel", NULL);\r\nfree_irq(dev->irq, dev);\r\nkfree(priv->firmware);\r\nrelease_region(dev->base_addr, 32);\r\nfree_netdev(dev);\r\n}\r\nstatic int atmel_set_essid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nif (dwrq->flags == 0) {\r\npriv->connect_to_any_BSS = 1;\r\n} else {\r\nint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\npriv->connect_to_any_BSS = 0;\r\nif (dwrq->length > MAX_SSID_LENGTH)\r\nreturn -E2BIG;\r\nif (index != 0)\r\nreturn -EINVAL;\r\nmemcpy(priv->new_SSID, extra, dwrq->length);\r\npriv->new_SSID_size = dwrq->length;\r\n}\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int atmel_get_essid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nif (priv->new_SSID_size != 0) {\r\nmemcpy(extra, priv->new_SSID, priv->new_SSID_size);\r\ndwrq->length = priv->new_SSID_size;\r\n} else {\r\nmemcpy(extra, priv->SSID, priv->SSID_size);\r\ndwrq->length = priv->SSID_size;\r\n}\r\ndwrq->flags = !priv->connect_to_any_BSS;\r\nreturn 0;\r\n}\r\nstatic int atmel_get_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *awrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nmemcpy(awrq->sa_data, priv->CurrentBSSID, ETH_ALEN);\r\nawrq->sa_family = ARPHRD_ETHER;\r\nreturn 0;\r\n}\r\nstatic int atmel_set_encode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nif (dwrq->length > 0) {\r\nint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\nint current_index = priv->default_key;\r\nif (dwrq->length > 13) {\r\nreturn -EINVAL;\r\n}\r\nif (index < 0 || index >= 4)\r\nindex = current_index;\r\nelse\r\npriv->default_key = index;\r\nif (dwrq->length > 5)\r\npriv->wep_key_len[index] = 13;\r\nelse\r\nif (dwrq->length > 0)\r\npriv->wep_key_len[index] = 5;\r\nelse\r\npriv->wep_key_len[index] = 0;\r\nif (!(dwrq->flags & IW_ENCODE_NOKEY)) {\r\nmemset(priv->wep_keys[index], 0, 13);\r\nmemcpy(priv->wep_keys[index], extra, dwrq->length);\r\n}\r\nif (index == current_index &&\r\npriv->wep_key_len[index] > 0) {\r\npriv->wep_is_on = 1;\r\npriv->exclude_unencrypted = 1;\r\nif (priv->wep_key_len[index] > 5) {\r\npriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;\r\npriv->encryption_level = 2;\r\n} else {\r\npriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;\r\npriv->encryption_level = 1;\r\n}\r\n}\r\n} else {\r\nint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\nif (index >= 0 && index < 4) {\r\npriv->default_key = index;\r\n} else\r\nif (!(dwrq->flags & IW_ENCODE_MODE))\r\nreturn -EINVAL;\r\n}\r\nif (dwrq->flags & IW_ENCODE_DISABLED) {\r\npriv->wep_is_on = 0;\r\npriv->encryption_level = 0;\r\npriv->pairwise_cipher_suite = CIPHER_SUITE_NONE;\r\n} else {\r\npriv->wep_is_on = 1;\r\nif (priv->wep_key_len[priv->default_key] > 5) {\r\npriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;\r\npriv->encryption_level = 2;\r\n} else {\r\npriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;\r\npriv->encryption_level = 1;\r\n}\r\n}\r\nif (dwrq->flags & IW_ENCODE_RESTRICTED)\r\npriv->exclude_unencrypted = 1;\r\nif (dwrq->flags & IW_ENCODE_OPEN)\r\npriv->exclude_unencrypted = 0;\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int atmel_get_encode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\nif (!priv->wep_is_on)\r\ndwrq->flags = IW_ENCODE_DISABLED;\r\nelse {\r\nif (priv->exclude_unencrypted)\r\ndwrq->flags = IW_ENCODE_RESTRICTED;\r\nelse\r\ndwrq->flags = IW_ENCODE_OPEN;\r\n}\r\nif (index < 0 || index >= 4)\r\nindex = priv->default_key;\r\ndwrq->flags |= index + 1;\r\ndwrq->length = priv->wep_key_len[index];\r\nif (dwrq->length > 16) {\r\ndwrq->length = 0;\r\n} else {\r\nmemset(extra, 0, 16);\r\nmemcpy(extra, priv->wep_keys[index], dwrq->length);\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_set_encodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint idx, key_len, alg = ext->alg, set_key = 1;\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif (idx < 1 || idx > 4)\r\nreturn -EINVAL;\r\nidx--;\r\n} else\r\nidx = priv->default_key;\r\nif (encoding->flags & IW_ENCODE_DISABLED)\r\nalg = IW_ENCODE_ALG_NONE;\r\nif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\r\npriv->default_key = idx;\r\nset_key = ext->key_len > 0 ? 1 : 0;\r\n}\r\nif (set_key) {\r\nswitch (alg) {\r\ncase IW_ENCODE_ALG_NONE:\r\npriv->wep_is_on = 0;\r\npriv->encryption_level = 0;\r\npriv->pairwise_cipher_suite = CIPHER_SUITE_NONE;\r\nbreak;\r\ncase IW_ENCODE_ALG_WEP:\r\nif (ext->key_len > 5) {\r\npriv->wep_key_len[idx] = 13;\r\npriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;\r\npriv->encryption_level = 2;\r\n} else if (ext->key_len > 0) {\r\npriv->wep_key_len[idx] = 5;\r\npriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;\r\npriv->encryption_level = 1;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\npriv->wep_is_on = 1;\r\nmemset(priv->wep_keys[idx], 0, 13);\r\nkey_len = min ((int)ext->key_len, priv->wep_key_len[idx]);\r\nmemcpy(priv->wep_keys[idx], ext->key, key_len);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int atmel_get_encodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint idx, max_key_len;\r\nmax_key_len = encoding->length - sizeof(*ext);\r\nif (max_key_len < 0)\r\nreturn -EINVAL;\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif (idx < 1 || idx > 4)\r\nreturn -EINVAL;\r\nidx--;\r\n} else\r\nidx = priv->default_key;\r\nencoding->flags = idx + 1;\r\nmemset(ext, 0, sizeof(*ext));\r\nif (!priv->wep_is_on) {\r\next->alg = IW_ENCODE_ALG_NONE;\r\next->key_len = 0;\r\nencoding->flags |= IW_ENCODE_DISABLED;\r\n} else {\r\nif (priv->encryption_level > 0)\r\next->alg = IW_ENCODE_ALG_WEP;\r\nelse\r\nreturn -EINVAL;\r\next->key_len = priv->wep_key_len[idx];\r\nmemcpy(ext->key, priv->wep_keys[idx], ext->key_len);\r\nencoding->flags |= IW_ENCODE_ENABLED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_set_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nstruct iw_param *param = &wrqu->param;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\npriv->exclude_unencrypted = param->value ? 1 : 0;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG: {\r\nif (param->value & IW_AUTH_ALG_SHARED_KEY) {\r\npriv->exclude_unencrypted = 1;\r\n} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {\r\npriv->exclude_unencrypted = 0;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\ncase IW_AUTH_WPA_ENABLED:\r\nif (param->value > 0)\r\nreturn -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int atmel_get_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nstruct iw_param *param = &wrqu->param;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nparam->value = priv->exclude_unencrypted;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nif (priv->exclude_unencrypted == 1)\r\nparam->value = IW_AUTH_ALG_SHARED_KEY;\r\nelse\r\nparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nparam->value = 0;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_get_name(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nchar *cwrq,\r\nchar *extra)\r\n{\r\nstrcpy(cwrq, "IEEE 802.11-DS");\r\nreturn 0;\r\n}\r\nstatic int atmel_set_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nif (vwrq->fixed == 0) {\r\npriv->tx_rate = 3;\r\npriv->auto_tx_rate = 1;\r\n} else {\r\npriv->auto_tx_rate = 0;\r\nif ((vwrq->value < 4) && (vwrq->value >= 0)) {\r\npriv->tx_rate = vwrq->value;\r\n} else {\r\nswitch (vwrq->value) {\r\ncase 1000000:\r\npriv->tx_rate = 0;\r\nbreak;\r\ncase 2000000:\r\npriv->tx_rate = 1;\r\nbreak;\r\ncase 5500000:\r\npriv->tx_rate = 2;\r\nbreak;\r\ncase 11000000:\r\npriv->tx_rate = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int atmel_set_mode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\n__u32 *uwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nif (*uwrq != IW_MODE_ADHOC && *uwrq != IW_MODE_INFRA)\r\nreturn -EINVAL;\r\npriv->operating_mode = *uwrq;\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int atmel_get_mode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\n__u32 *uwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\n*uwrq = priv->operating_mode;\r\nreturn 0;\r\n}\r\nstatic int atmel_get_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nif (priv->auto_tx_rate) {\r\nvwrq->fixed = 0;\r\nvwrq->value = 11000000;\r\n} else {\r\nvwrq->fixed = 1;\r\nswitch (priv->tx_rate) {\r\ncase 0:\r\nvwrq->value = 1000000;\r\nbreak;\r\ncase 1:\r\nvwrq->value = 2000000;\r\nbreak;\r\ncase 2:\r\nvwrq->value = 5500000;\r\nbreak;\r\ncase 3:\r\nvwrq->value = 11000000;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_set_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\npriv->power_mode = vwrq->disabled ? 0 : 1;\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int atmel_get_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nvwrq->disabled = priv->power_mode ? 0 : 1;\r\nvwrq->flags = IW_POWER_ON;\r\nreturn 0;\r\n}\r\nstatic int atmel_set_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nif (!vwrq->disabled && (vwrq->flags & IW_RETRY_LIMIT)) {\r\nif (vwrq->flags & IW_RETRY_LONG)\r\npriv->long_retry = vwrq->value;\r\nelse if (vwrq->flags & IW_RETRY_SHORT)\r\npriv->short_retry = vwrq->value;\r\nelse {\r\npriv->long_retry = vwrq->value;\r\npriv->short_retry = vwrq->value;\r\n}\r\nreturn -EINPROGRESS;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int atmel_get_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nvwrq->disabled = 0;\r\nif (vwrq->flags & IW_RETRY_LONG) {\r\nvwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\r\nvwrq->value = priv->long_retry;\r\n} else {\r\nvwrq->flags = IW_RETRY_LIMIT;\r\nvwrq->value = priv->short_retry;\r\nif (priv->long_retry != priv->short_retry)\r\nvwrq->flags |= IW_RETRY_SHORT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_set_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nint rthr = vwrq->value;\r\nif (vwrq->disabled)\r\nrthr = 2347;\r\nif ((rthr < 0) || (rthr > 2347)) {\r\nreturn -EINVAL;\r\n}\r\npriv->rts_threshold = rthr;\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int atmel_get_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nvwrq->value = priv->rts_threshold;\r\nvwrq->disabled = (vwrq->value >= 2347);\r\nvwrq->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int atmel_set_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nint fthr = vwrq->value;\r\nif (vwrq->disabled)\r\nfthr = 2346;\r\nif ((fthr < 256) || (fthr > 2346)) {\r\nreturn -EINVAL;\r\n}\r\nfthr &= ~0x1;\r\npriv->frag_threshold = fthr;\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int atmel_get_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nvwrq->value = priv->frag_threshold;\r\nvwrq->disabled = (vwrq->value >= 2346);\r\nvwrq->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int atmel_set_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *fwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nint rc = -EINPROGRESS;\r\nif (fwrq->e == 1) {\r\nint f = fwrq->m / 100000;\r\nfwrq->e = 0;\r\nfwrq->m = ieee80211_frequency_to_channel(f);\r\n}\r\nif ((fwrq->m > 1000) || (fwrq->e > 0))\r\nrc = -EOPNOTSUPP;\r\nelse {\r\nint channel = fwrq->m;\r\nif (atmel_validate_channel(priv, channel) == 0) {\r\npriv->channel = channel;\r\n} else {\r\nrc = -EINVAL;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int atmel_get_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *fwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nfwrq->m = priv->channel;\r\nfwrq->e = 0;\r\nreturn 0;\r\n}\r\nstatic int atmel_set_scan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nif (priv->station_state == STATION_STATE_DOWN)\r\nreturn -EAGAIN;\r\nif (time_after(jiffies, priv->last_survey + 20 * HZ))\r\npriv->site_survey_state = SITE_SURVEY_IDLE;\r\npriv->last_survey = jiffies;\r\nif (priv->site_survey_state == SITE_SURVEY_IN_PROGRESS)\r\nreturn -EBUSY;\r\ndel_timer_sync(&priv->management_timer);\r\nspin_lock_irqsave(&priv->irqlock, flags);\r\npriv->site_survey_state = SITE_SURVEY_IN_PROGRESS;\r\npriv->fast_scan = 0;\r\natmel_scan(priv, 0);\r\nspin_unlock_irqrestore(&priv->irqlock, flags);\r\nreturn 0;\r\n}\r\nstatic int atmel_get_scan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nint i;\r\nchar *current_ev = extra;\r\nstruct iw_event iwe;\r\nif (priv->site_survey_state != SITE_SURVEY_COMPLETED)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < priv->BSS_list_entries; i++) {\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, priv->BSSinfo[i].BSSID, ETH_ALEN);\r\ncurrent_ev = iwe_stream_add_event(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe, IW_EV_ADDR_LEN);\r\niwe.u.data.length = priv->BSSinfo[i].SSIDsize;\r\nif (iwe.u.data.length > 32)\r\niwe.u.data.length = 32;\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.flags = 1;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe, priv->BSSinfo[i].SSID);\r\niwe.cmd = SIOCGIWMODE;\r\niwe.u.mode = priv->BSSinfo[i].BSStype;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe, IW_EV_UINT_LEN);\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = priv->BSSinfo[i].channel;\r\niwe.u.freq.e = 0;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe, IW_EV_FREQ_LEN);\r\niwe.cmd = IWEVQUAL;\r\niwe.u.qual.level = priv->BSSinfo[i].RSSI;\r\niwe.u.qual.qual = iwe.u.qual.level;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe, IW_EV_QUAL_LEN);\r\niwe.cmd = SIOCGIWENCODE;\r\nif (priv->BSSinfo[i].UsingWEP)\r\niwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\niwe.u.data.length = 0;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe, NULL);\r\n}\r\ndwrq->length = (current_ev - extra);\r\ndwrq->flags = 0;\r\nreturn 0;\r\n}\r\nstatic int atmel_get_range(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nstruct iw_range *range = (struct iw_range *) extra;\r\nint k, i, j;\r\ndwrq->length = sizeof(struct iw_range);\r\nmemset(range, 0, sizeof(struct iw_range));\r\nrange->min_nwid = 0x0000;\r\nrange->max_nwid = 0x0000;\r\nrange->num_channels = 0;\r\nfor (j = 0; j < ARRAY_SIZE(channel_table); j++)\r\nif (priv->reg_domain == channel_table[j].reg_domain) {\r\nrange->num_channels = channel_table[j].max - channel_table[j].min + 1;\r\nbreak;\r\n}\r\nif (range->num_channels != 0) {\r\nfor (k = 0, i = channel_table[j].min; i <= channel_table[j].max; i++) {\r\nrange->freq[k].i = i;\r\nrange->freq[k].m = 100000 *\r\nieee80211_channel_to_frequency(i, IEEE80211_BAND_2GHZ);\r\nrange->freq[k++].e = 1;\r\n}\r\nrange->num_frequency = k;\r\n}\r\nrange->max_qual.qual = 100;\r\nrange->max_qual.level = 100;\r\nrange->max_qual.noise = 0;\r\nrange->max_qual.updated = IW_QUAL_NOISE_INVALID;\r\nrange->avg_qual.qual = 50;\r\nrange->avg_qual.level = 50;\r\nrange->avg_qual.noise = 0;\r\nrange->avg_qual.updated = IW_QUAL_NOISE_INVALID;\r\nrange->sensitivity = 0;\r\nrange->bitrate[0] = 1000000;\r\nrange->bitrate[1] = 2000000;\r\nrange->bitrate[2] = 5500000;\r\nrange->bitrate[3] = 11000000;\r\nrange->num_bitrates = 4;\r\nrange->min_rts = 0;\r\nrange->max_rts = 2347;\r\nrange->min_frag = 256;\r\nrange->max_frag = 2346;\r\nrange->encoding_size[0] = 5;\r\nrange->encoding_size[1] = 13;\r\nrange->num_encoding_sizes = 2;\r\nrange->max_encoding_tokens = 4;\r\nrange->pmp_flags = IW_POWER_ON;\r\nrange->pmt_flags = IW_POWER_ON;\r\nrange->pm_capa = 0;\r\nrange->we_version_source = WIRELESS_EXT;\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->retry_capa = IW_RETRY_LIMIT ;\r\nrange->retry_flags = IW_RETRY_LIMIT;\r\nrange->r_time_flags = 0;\r\nrange->min_retry = 1;\r\nrange->max_retry = 65535;\r\nreturn 0;\r\n}\r\nstatic int atmel_set_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *awrq,\r\nchar *extra)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nint i;\r\nstatic const u8 any[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\r\nstatic const u8 off[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nunsigned long flags;\r\nif (awrq->sa_family != ARPHRD_ETHER)\r\nreturn -EINVAL;\r\nif (!memcmp(any, awrq->sa_data, 6) ||\r\n!memcmp(off, awrq->sa_data, 6)) {\r\ndel_timer_sync(&priv->management_timer);\r\nspin_lock_irqsave(&priv->irqlock, flags);\r\natmel_scan(priv, 1);\r\nspin_unlock_irqrestore(&priv->irqlock, flags);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < priv->BSS_list_entries; i++) {\r\nif (memcmp(priv->BSSinfo[i].BSSID, awrq->sa_data, 6) == 0) {\r\nif (!priv->wep_is_on && priv->BSSinfo[i].UsingWEP) {\r\nreturn -EINVAL;\r\n} else if (priv->wep_is_on && !priv->BSSinfo[i].UsingWEP) {\r\nreturn -EINVAL;\r\n} else {\r\ndel_timer_sync(&priv->management_timer);\r\nspin_lock_irqsave(&priv->irqlock, flags);\r\natmel_join_bss(priv, i);\r\nspin_unlock_irqrestore(&priv->irqlock, flags);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int atmel_config_commit(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *zwrq,\r\nchar *extra)\r\n{\r\nreturn atmel_open(dev);\r\n}\r\nstatic int atmel_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nint i, rc = 0;\r\nstruct atmel_private *priv = netdev_priv(dev);\r\natmel_priv_ioctl com;\r\nstruct iwreq *wrq = (struct iwreq *) rq;\r\nunsigned char *new_firmware;\r\nchar domain[REGDOMAINSZ + 1];\r\nswitch (cmd) {\r\ncase ATMELIDIFC:\r\nwrq->u.param.value = ATMELMAGIC;\r\nbreak;\r\ncase ATMELFWL:\r\nif (copy_from_user(&com, rq->ifr_data, sizeof(com))) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nif (!capable(CAP_NET_ADMIN)) {\r\nrc = -EPERM;\r\nbreak;\r\n}\r\nif (!(new_firmware = kmalloc(com.len, GFP_KERNEL))) {\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\nif (copy_from_user(new_firmware, com.data, com.len)) {\r\nkfree(new_firmware);\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nkfree(priv->firmware);\r\npriv->firmware = new_firmware;\r\npriv->firmware_length = com.len;\r\nstrncpy(priv->firmware_id, com.id, 31);\r\npriv->firmware_id[31] = '\0';\r\nbreak;\r\ncase ATMELRD:\r\nif (copy_from_user(domain, rq->ifr_data, REGDOMAINSZ)) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nif (!capable(CAP_NET_ADMIN)) {\r\nrc = -EPERM;\r\nbreak;\r\n}\r\ndomain[REGDOMAINSZ] = 0;\r\nrc = -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(channel_table); i++) {\r\nchar *a = channel_table[i].name;\r\nchar *b = domain;\r\nwhile (*a) {\r\nchar c1 = *a++;\r\nchar c2 = *b++;\r\nif (tolower(c1) != tolower(c2))\r\nbreak;\r\n}\r\nif (!*a && !*b) {\r\npriv->config_reg_domain = channel_table[i].reg_domain;\r\nrc = 0;\r\n}\r\n}\r\nif (rc == 0 && priv->station_state != STATION_STATE_DOWN)\r\nrc = atmel_open(dev);\r\nbreak;\r\ndefault:\r\nrc = -EOPNOTSUPP;\r\n}\r\nreturn rc;\r\n}\r\nstatic void atmel_enter_state(struct atmel_private *priv, int new_state)\r\n{\r\nint old_state = priv->station_state;\r\nif (new_state == old_state)\r\nreturn;\r\npriv->station_state = new_state;\r\nif (new_state == STATION_STATE_READY) {\r\nnetif_start_queue(priv->dev);\r\nnetif_carrier_on(priv->dev);\r\n}\r\nif (old_state == STATION_STATE_READY) {\r\nnetif_carrier_off(priv->dev);\r\nif (netif_running(priv->dev))\r\nnetif_stop_queue(priv->dev);\r\npriv->last_beacon_timestamp = 0;\r\n}\r\n}\r\nstatic void atmel_scan(struct atmel_private *priv, int specific_ssid)\r\n{\r\nstruct {\r\nu8 BSSID[ETH_ALEN];\r\nu8 SSID[MAX_SSID_LENGTH];\r\nu8 scan_type;\r\nu8 channel;\r\n__le16 BSS_type;\r\n__le16 min_channel_time;\r\n__le16 max_channel_time;\r\nu8 options;\r\nu8 SSID_size;\r\n} cmd;\r\nmemset(cmd.BSSID, 0xff, ETH_ALEN);\r\nif (priv->fast_scan) {\r\ncmd.SSID_size = priv->SSID_size;\r\nmemcpy(cmd.SSID, priv->SSID, priv->SSID_size);\r\ncmd.min_channel_time = cpu_to_le16(10);\r\ncmd.max_channel_time = cpu_to_le16(50);\r\n} else {\r\npriv->BSS_list_entries = 0;\r\ncmd.SSID_size = 0;\r\ncmd.min_channel_time = cpu_to_le16(10);\r\ncmd.max_channel_time = cpu_to_le16(120);\r\n}\r\ncmd.options = 0;\r\nif (!specific_ssid)\r\ncmd.options |= SCAN_OPTIONS_SITE_SURVEY;\r\ncmd.channel = (priv->channel & 0x7f);\r\ncmd.scan_type = SCAN_TYPE_ACTIVE;\r\ncmd.BSS_type = cpu_to_le16(priv->operating_mode == IW_MODE_ADHOC ?\r\nBSS_TYPE_AD_HOC : BSS_TYPE_INFRASTRUCTURE);\r\natmel_send_command(priv, CMD_Scan, &cmd, sizeof(cmd));\r\natmel_enter_state(priv, STATION_STATE_SCANNING);\r\n}\r\nstatic void join(struct atmel_private *priv, int type)\r\n{\r\nstruct {\r\nu8 BSSID[6];\r\nu8 SSID[MAX_SSID_LENGTH];\r\nu8 BSS_type;\r\nu8 channel;\r\n__le16 timeout;\r\nu8 SSID_size;\r\nu8 reserved;\r\n} cmd;\r\ncmd.SSID_size = priv->SSID_size;\r\nmemcpy(cmd.SSID, priv->SSID, priv->SSID_size);\r\nmemcpy(cmd.BSSID, priv->CurrentBSSID, ETH_ALEN);\r\ncmd.channel = (priv->channel & 0x7f);\r\ncmd.BSS_type = type;\r\ncmd.timeout = cpu_to_le16(2000);\r\natmel_send_command(priv, CMD_Join, &cmd, sizeof(cmd));\r\n}\r\nstatic void start(struct atmel_private *priv, int type)\r\n{\r\nstruct {\r\nu8 BSSID[6];\r\nu8 SSID[MAX_SSID_LENGTH];\r\nu8 BSS_type;\r\nu8 channel;\r\nu8 SSID_size;\r\nu8 reserved[3];\r\n} cmd;\r\ncmd.SSID_size = priv->SSID_size;\r\nmemcpy(cmd.SSID, priv->SSID, priv->SSID_size);\r\nmemcpy(cmd.BSSID, priv->BSSID, ETH_ALEN);\r\ncmd.BSS_type = type;\r\ncmd.channel = (priv->channel & 0x7f);\r\natmel_send_command(priv, CMD_Start, &cmd, sizeof(cmd));\r\n}\r\nstatic void handle_beacon_probe(struct atmel_private *priv, u16 capability,\r\nu8 channel)\r\n{\r\nint rejoin = 0;\r\nint new = capability & WLAN_CAPABILITY_SHORT_PREAMBLE ?\r\nSHORT_PREAMBLE : LONG_PREAMBLE;\r\nif (priv->preamble != new) {\r\npriv->preamble = new;\r\nrejoin = 1;\r\natmel_set_mib8(priv, Local_Mib_Type, LOCAL_MIB_PREAMBLE_TYPE, new);\r\n}\r\nif (priv->channel != channel) {\r\npriv->channel = channel;\r\nrejoin = 1;\r\natmel_set_mib8(priv, Phy_Mib_Type, PHY_MIB_CHANNEL_POS, channel);\r\n}\r\nif (rejoin) {\r\npriv->station_is_associated = 0;\r\natmel_enter_state(priv, STATION_STATE_JOINNING);\r\nif (priv->operating_mode == IW_MODE_INFRA)\r\njoin(priv, BSS_TYPE_INFRASTRUCTURE);\r\nelse\r\njoin(priv, BSS_TYPE_AD_HOC);\r\n}\r\n}\r\nstatic void send_authentication_request(struct atmel_private *priv, u16 system,\r\nu8 *challenge, int challenge_len)\r\n{\r\nstruct ieee80211_hdr header;\r\nstruct auth_body auth;\r\nheader.frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH);\r\nheader.duration_id = cpu_to_le16(0x8000);\r\nheader.seq_ctrl = 0;\r\nmemcpy(header.addr1, priv->CurrentBSSID, ETH_ALEN);\r\nmemcpy(header.addr2, priv->dev->dev_addr, ETH_ALEN);\r\nmemcpy(header.addr3, priv->CurrentBSSID, ETH_ALEN);\r\nif (priv->wep_is_on && priv->CurrentAuthentTransactionSeqNum != 1)\r\nheader.frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\r\nauth.alg = cpu_to_le16(system);\r\nauth.status = 0;\r\nauth.trans_seq = cpu_to_le16(priv->CurrentAuthentTransactionSeqNum);\r\npriv->ExpectedAuthentTransactionSeqNum = priv->CurrentAuthentTransactionSeqNum+1;\r\npriv->CurrentAuthentTransactionSeqNum += 2;\r\nif (challenge_len != 0) {\r\nauth.el_id = 16;\r\nauth.chall_text_len = challenge_len;\r\nmemcpy(auth.chall_text, challenge, challenge_len);\r\natmel_transmit_management_frame(priv, &header, (u8 *)&auth, 8 + challenge_len);\r\n} else {\r\natmel_transmit_management_frame(priv, &header, (u8 *)&auth, 6);\r\n}\r\n}\r\nstatic void send_association_request(struct atmel_private *priv, int is_reassoc)\r\n{\r\nu8 *ssid_el_p;\r\nint bodysize;\r\nstruct ieee80211_hdr header;\r\nstruct ass_req_format {\r\n__le16 capability;\r\n__le16 listen_interval;\r\nu8 ap[ETH_ALEN];\r\nu8 ssid_el_id;\r\nu8 ssid_len;\r\nu8 ssid[MAX_SSID_LENGTH];\r\nu8 sup_rates_el_id;\r\nu8 sup_rates_len;\r\nu8 rates[4];\r\n} body;\r\nheader.frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\n(is_reassoc ? IEEE80211_STYPE_REASSOC_REQ : IEEE80211_STYPE_ASSOC_REQ));\r\nheader.duration_id = cpu_to_le16(0x8000);\r\nheader.seq_ctrl = 0;\r\nmemcpy(header.addr1, priv->CurrentBSSID, ETH_ALEN);\r\nmemcpy(header.addr2, priv->dev->dev_addr, ETH_ALEN);\r\nmemcpy(header.addr3, priv->CurrentBSSID, ETH_ALEN);\r\nbody.capability = cpu_to_le16(WLAN_CAPABILITY_ESS);\r\nif (priv->wep_is_on)\r\nbody.capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\r\nif (priv->preamble == SHORT_PREAMBLE)\r\nbody.capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);\r\nbody.listen_interval = cpu_to_le16(priv->listen_interval * priv->beacon_period);\r\nif (is_reassoc) {\r\nmemcpy(body.ap, priv->CurrentBSSID, ETH_ALEN);\r\nssid_el_p = &body.ssid_el_id;\r\nbodysize = 18 + priv->SSID_size;\r\n} else {\r\nssid_el_p = &body.ap[0];\r\nbodysize = 12 + priv->SSID_size;\r\n}\r\nssid_el_p[0] = WLAN_EID_SSID;\r\nssid_el_p[1] = priv->SSID_size;\r\nmemcpy(ssid_el_p + 2, priv->SSID, priv->SSID_size);\r\nssid_el_p[2 + priv->SSID_size] = WLAN_EID_SUPP_RATES;\r\nssid_el_p[3 + priv->SSID_size] = 4;\r\nmemcpy(ssid_el_p + 4 + priv->SSID_size, atmel_basic_rates, 4);\r\natmel_transmit_management_frame(priv, &header, (void *)&body, bodysize);\r\n}\r\nstatic int is_frame_from_current_bss(struct atmel_private *priv,\r\nstruct ieee80211_hdr *header)\r\n{\r\nif (le16_to_cpu(header->frame_control) & IEEE80211_FCTL_FROMDS)\r\nreturn memcmp(header->addr3, priv->CurrentBSSID, 6) == 0;\r\nelse\r\nreturn memcmp(header->addr2, priv->CurrentBSSID, 6) == 0;\r\n}\r\nstatic int retrieve_bss(struct atmel_private *priv)\r\n{\r\nint i;\r\nint max_rssi = -128;\r\nint max_index = -1;\r\nif (priv->BSS_list_entries == 0)\r\nreturn -1;\r\nif (priv->connect_to_any_BSS) {\r\npriv->current_BSS = 0;\r\nfor (i = 0; i < priv->BSS_list_entries; i++) {\r\nif (priv->operating_mode == priv->BSSinfo[i].BSStype &&\r\n((!priv->wep_is_on && !priv->BSSinfo[i].UsingWEP) ||\r\n(priv->wep_is_on && priv->BSSinfo[i].UsingWEP)) &&\r\n!(priv->BSSinfo[i].channel & 0x80)) {\r\nmax_rssi = priv->BSSinfo[i].RSSI;\r\npriv->current_BSS = max_index = i;\r\n}\r\n}\r\nreturn max_index;\r\n}\r\nfor (i = 0; i < priv->BSS_list_entries; i++) {\r\nif (priv->SSID_size == priv->BSSinfo[i].SSIDsize &&\r\nmemcmp(priv->SSID, priv->BSSinfo[i].SSID, priv->SSID_size) == 0 &&\r\npriv->operating_mode == priv->BSSinfo[i].BSStype &&\r\natmel_validate_channel(priv, priv->BSSinfo[i].channel) == 0) {\r\nif (priv->BSSinfo[i].RSSI >= max_rssi) {\r\nmax_rssi = priv->BSSinfo[i].RSSI;\r\nmax_index = i;\r\n}\r\n}\r\n}\r\nreturn max_index;\r\n}\r\nstatic void store_bss_info(struct atmel_private *priv,\r\nstruct ieee80211_hdr *header, u16 capability,\r\nu16 beacon_period, u8 channel, u8 rssi, u8 ssid_len,\r\nu8 *ssid, int is_beacon)\r\n{\r\nu8 *bss = capability & WLAN_CAPABILITY_ESS ? header->addr2 : header->addr3;\r\nint i, index;\r\nfor (index = -1, i = 0; i < priv->BSS_list_entries; i++)\r\nif (memcmp(bss, priv->BSSinfo[i].BSSID, ETH_ALEN) == 0)\r\nindex = i;\r\nif (index == -1) {\r\nif (priv->BSS_list_entries == MAX_BSS_ENTRIES)\r\nreturn;\r\nindex = priv->BSS_list_entries++;\r\nmemcpy(priv->BSSinfo[index].BSSID, bss, ETH_ALEN);\r\npriv->BSSinfo[index].RSSI = rssi;\r\n} else {\r\nif (rssi > priv->BSSinfo[index].RSSI)\r\npriv->BSSinfo[index].RSSI = rssi;\r\nif (is_beacon)\r\nreturn;\r\n}\r\npriv->BSSinfo[index].channel = channel;\r\npriv->BSSinfo[index].beacon_period = beacon_period;\r\npriv->BSSinfo[index].UsingWEP = capability & WLAN_CAPABILITY_PRIVACY;\r\nmemcpy(priv->BSSinfo[index].SSID, ssid, ssid_len);\r\npriv->BSSinfo[index].SSIDsize = ssid_len;\r\nif (capability & WLAN_CAPABILITY_IBSS)\r\npriv->BSSinfo[index].BSStype = IW_MODE_ADHOC;\r\nelse if (capability & WLAN_CAPABILITY_ESS)\r\npriv->BSSinfo[index].BSStype = IW_MODE_INFRA;\r\npriv->BSSinfo[index].preamble = capability & WLAN_CAPABILITY_SHORT_PREAMBLE ?\r\nSHORT_PREAMBLE : LONG_PREAMBLE;\r\n}\r\nstatic void authenticate(struct atmel_private *priv, u16 frame_len)\r\n{\r\nstruct auth_body *auth = (struct auth_body *)priv->rx_buf;\r\nu16 status = le16_to_cpu(auth->status);\r\nu16 trans_seq_no = le16_to_cpu(auth->trans_seq);\r\nu16 system = le16_to_cpu(auth->alg);\r\nif (status == WLAN_STATUS_SUCCESS && !priv->wep_is_on) {\r\nif (priv->station_was_associated) {\r\natmel_enter_state(priv, STATION_STATE_REASSOCIATING);\r\nsend_association_request(priv, 1);\r\nreturn;\r\n} else {\r\natmel_enter_state(priv, STATION_STATE_ASSOCIATING);\r\nsend_association_request(priv, 0);\r\nreturn;\r\n}\r\n}\r\nif (status == WLAN_STATUS_SUCCESS && priv->wep_is_on) {\r\nint should_associate = 0;\r\nif (trans_seq_no != priv->ExpectedAuthentTransactionSeqNum)\r\nreturn;\r\nif (system == WLAN_AUTH_OPEN) {\r\nif (trans_seq_no == 0x0002) {\r\nshould_associate = 1;\r\n}\r\n} else if (system == WLAN_AUTH_SHARED_KEY) {\r\nif (trans_seq_no == 0x0002 &&\r\nauth->el_id == WLAN_EID_CHALLENGE) {\r\nsend_authentication_request(priv, system, auth->chall_text, auth->chall_text_len);\r\nreturn;\r\n} else if (trans_seq_no == 0x0004) {\r\nshould_associate = 1;\r\n}\r\n}\r\nif (should_associate) {\r\nif (priv->station_was_associated) {\r\natmel_enter_state(priv, STATION_STATE_REASSOCIATING);\r\nsend_association_request(priv, 1);\r\nreturn;\r\n} else {\r\natmel_enter_state(priv, STATION_STATE_ASSOCIATING);\r\nsend_association_request(priv, 0);\r\nreturn;\r\n}\r\n}\r\n}\r\nif (status == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG) {\r\nif (system == WLAN_AUTH_OPEN) {\r\npriv->CurrentAuthentTransactionSeqNum = 0x001;\r\npriv->exclude_unencrypted = 1;\r\nsend_authentication_request(priv, WLAN_AUTH_SHARED_KEY, NULL, 0);\r\nreturn;\r\n} else if (system == WLAN_AUTH_SHARED_KEY\r\n&& priv->wep_is_on) {\r\npriv->CurrentAuthentTransactionSeqNum = 0x001;\r\npriv->exclude_unencrypted = 0;\r\nsend_authentication_request(priv, WLAN_AUTH_OPEN, NULL, 0);\r\nreturn;\r\n} else if (priv->connect_to_any_BSS) {\r\nint bss_index;\r\npriv->BSSinfo[(int)(priv->current_BSS)].channel |= 0x80;\r\nif ((bss_index = retrieve_bss(priv)) != -1) {\r\natmel_join_bss(priv, bss_index);\r\nreturn;\r\n}\r\n}\r\n}\r\npriv->AuthenticationRequestRetryCnt = 0;\r\natmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\r\npriv->station_is_associated = 0;\r\n}\r\nstatic void associate(struct atmel_private *priv, u16 frame_len, u16 subtype)\r\n{\r\nstruct ass_resp_format {\r\n__le16 capability;\r\n__le16 status;\r\n__le16 ass_id;\r\nu8 el_id;\r\nu8 length;\r\nu8 rates[4];\r\n} *ass_resp = (struct ass_resp_format *)priv->rx_buf;\r\nu16 status = le16_to_cpu(ass_resp->status);\r\nu16 ass_id = le16_to_cpu(ass_resp->ass_id);\r\nu16 rates_len = ass_resp->length > 4 ? 4 : ass_resp->length;\r\nunion iwreq_data wrqu;\r\nif (frame_len < 8 + rates_len)\r\nreturn;\r\nif (status == WLAN_STATUS_SUCCESS) {\r\nif (subtype == IEEE80211_STYPE_ASSOC_RESP)\r\npriv->AssociationRequestRetryCnt = 0;\r\nelse\r\npriv->ReAssociationRequestRetryCnt = 0;\r\natmel_set_mib16(priv, Mac_Mgmt_Mib_Type,\r\nMAC_MGMT_MIB_STATION_ID_POS, ass_id & 0x3fff);\r\natmel_set_mib(priv, Phy_Mib_Type,\r\nPHY_MIB_RATE_SET_POS, ass_resp->rates, rates_len);\r\nif (priv->power_mode == 0) {\r\npriv->listen_interval = 1;\r\natmel_set_mib8(priv, Mac_Mgmt_Mib_Type,\r\nMAC_MGMT_MIB_PS_MODE_POS, ACTIVE_MODE);\r\natmel_set_mib16(priv, Mac_Mgmt_Mib_Type,\r\nMAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);\r\n} else {\r\npriv->listen_interval = 2;\r\natmel_set_mib8(priv, Mac_Mgmt_Mib_Type,\r\nMAC_MGMT_MIB_PS_MODE_POS, PS_MODE);\r\natmel_set_mib16(priv, Mac_Mgmt_Mib_Type,\r\nMAC_MGMT_MIB_LISTEN_INTERVAL_POS, 2);\r\n}\r\npriv->station_is_associated = 1;\r\npriv->station_was_associated = 1;\r\natmel_enter_state(priv, STATION_STATE_READY);\r\nwrqu.data.length = 0;\r\nwrqu.data.flags = 0;\r\nmemcpy(wrqu.ap_addr.sa_data, priv->CurrentBSSID, ETH_ALEN);\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);\r\nreturn;\r\n}\r\nif (subtype == IEEE80211_STYPE_ASSOC_RESP &&\r\nstatus != WLAN_STATUS_ASSOC_DENIED_RATES &&\r\nstatus != WLAN_STATUS_CAPS_UNSUPPORTED &&\r\npriv->AssociationRequestRetryCnt < MAX_ASSOCIATION_RETRIES) {\r\nmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\r\npriv->AssociationRequestRetryCnt++;\r\nsend_association_request(priv, 0);\r\nreturn;\r\n}\r\nif (subtype == IEEE80211_STYPE_REASSOC_RESP &&\r\nstatus != WLAN_STATUS_ASSOC_DENIED_RATES &&\r\nstatus != WLAN_STATUS_CAPS_UNSUPPORTED &&\r\npriv->ReAssociationRequestRetryCnt < MAX_ASSOCIATION_RETRIES) {\r\nmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\r\npriv->ReAssociationRequestRetryCnt++;\r\nsend_association_request(priv, 1);\r\nreturn;\r\n}\r\natmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\r\npriv->station_is_associated = 0;\r\nif (priv->connect_to_any_BSS) {\r\nint bss_index;\r\npriv->BSSinfo[(int)(priv->current_BSS)].channel |= 0x80;\r\nif ((bss_index = retrieve_bss(priv)) != -1)\r\natmel_join_bss(priv, bss_index);\r\n}\r\n}\r\nstatic void atmel_join_bss(struct atmel_private *priv, int bss_index)\r\n{\r\nstruct bss_info *bss = &priv->BSSinfo[bss_index];\r\nmemcpy(priv->CurrentBSSID, bss->BSSID, ETH_ALEN);\r\nmemcpy(priv->SSID, bss->SSID, priv->SSID_size = bss->SSIDsize);\r\nif (priv->use_wpa)\r\nbuild_wpa_mib(priv);\r\nif (bss->BSStype == IW_MODE_ADHOC &&\r\npriv->operating_mode != IW_MODE_ADHOC &&\r\npriv->power_mode) {\r\npriv->power_mode = 0;\r\npriv->listen_interval = 1;\r\natmel_set_mib8(priv, Mac_Mgmt_Mib_Type,\r\nMAC_MGMT_MIB_PS_MODE_POS, ACTIVE_MODE);\r\natmel_set_mib16(priv, Mac_Mgmt_Mib_Type,\r\nMAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);\r\n}\r\npriv->operating_mode = bss->BSStype;\r\npriv->channel = bss->channel & 0x7f;\r\npriv->beacon_period = bss->beacon_period;\r\nif (priv->preamble != bss->preamble) {\r\npriv->preamble = bss->preamble;\r\natmel_set_mib8(priv, Local_Mib_Type,\r\nLOCAL_MIB_PREAMBLE_TYPE, bss->preamble);\r\n}\r\nif (!priv->wep_is_on && bss->UsingWEP) {\r\natmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\r\npriv->station_is_associated = 0;\r\nreturn;\r\n}\r\nif (priv->wep_is_on && !bss->UsingWEP) {\r\natmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\r\npriv->station_is_associated = 0;\r\nreturn;\r\n}\r\natmel_enter_state(priv, STATION_STATE_JOINNING);\r\nif (priv->operating_mode == IW_MODE_INFRA)\r\njoin(priv, BSS_TYPE_INFRASTRUCTURE);\r\nelse\r\njoin(priv, BSS_TYPE_AD_HOC);\r\n}\r\nstatic void restart_search(struct atmel_private *priv)\r\n{\r\nint bss_index;\r\nif (!priv->connect_to_any_BSS) {\r\natmel_scan(priv, 1);\r\n} else {\r\npriv->BSSinfo[(int)(priv->current_BSS)].channel |= 0x80;\r\nif ((bss_index = retrieve_bss(priv)) != -1)\r\natmel_join_bss(priv, bss_index);\r\nelse\r\natmel_scan(priv, 0);\r\n}\r\n}\r\nstatic void smooth_rssi(struct atmel_private *priv, u8 rssi)\r\n{\r\nu8 old = priv->wstats.qual.level;\r\nu8 max_rssi = 42;\r\nswitch (priv->firmware_type) {\r\ncase ATMEL_FW_TYPE_502E:\r\nmax_rssi = 63;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrssi = rssi * 100 / max_rssi;\r\nif ((rssi + old) % 2)\r\npriv->wstats.qual.level = (rssi + old) / 2 + 1;\r\nelse\r\npriv->wstats.qual.level = (rssi + old) / 2;\r\npriv->wstats.qual.updated |= IW_QUAL_LEVEL_UPDATED;\r\npriv->wstats.qual.updated &= ~IW_QUAL_LEVEL_INVALID;\r\n}\r\nstatic void atmel_smooth_qual(struct atmel_private *priv)\r\n{\r\nunsigned long time_diff = (jiffies - priv->last_qual) / HZ;\r\nwhile (time_diff--) {\r\npriv->last_qual += HZ;\r\npriv->wstats.qual.qual = priv->wstats.qual.qual / 2;\r\npriv->wstats.qual.qual +=\r\npriv->beacons_this_sec * priv->beacon_period * (priv->wstats.qual.level + 100) / 4000;\r\npriv->beacons_this_sec = 0;\r\n}\r\npriv->wstats.qual.updated |= IW_QUAL_QUAL_UPDATED;\r\npriv->wstats.qual.updated &= ~IW_QUAL_QUAL_INVALID;\r\n}\r\nstatic void atmel_management_frame(struct atmel_private *priv,\r\nstruct ieee80211_hdr *header,\r\nu16 frame_len, u8 rssi)\r\n{\r\nu16 subtype;\r\nsubtype = le16_to_cpu(header->frame_control) & IEEE80211_FCTL_STYPE;\r\nswitch (subtype) {\r\ncase IEEE80211_STYPE_BEACON:\r\ncase IEEE80211_STYPE_PROBE_RESP:\r\n{\r\nstruct beacon_format {\r\n__le64 timestamp;\r\n__le16 interval;\r\n__le16 capability;\r\nu8 ssid_el_id;\r\nu8 ssid_length;\r\nu8 rates_el_id;\r\nu8 rates_length;\r\nu8 ds_el_id;\r\nu8 ds_length;\r\n} *beacon = (struct beacon_format *)priv->rx_buf;\r\nu8 channel, rates_length, ssid_length;\r\nu64 timestamp = le64_to_cpu(beacon->timestamp);\r\nu16 beacon_interval = le16_to_cpu(beacon->interval);\r\nu16 capability = le16_to_cpu(beacon->capability);\r\nu8 *beaconp = priv->rx_buf;\r\nssid_length = beacon->ssid_length;\r\nif (frame_len < 14 || frame_len < ssid_length + 15)\r\nreturn;\r\nrates_length = beaconp[beacon->ssid_length + 15];\r\nif (frame_len < ssid_length + rates_length + 18)\r\nreturn;\r\nif (ssid_length > MAX_SSID_LENGTH)\r\nreturn;\r\nchannel = beaconp[ssid_length + rates_length + 18];\r\nif (priv->station_state == STATION_STATE_READY) {\r\nsmooth_rssi(priv, rssi);\r\nif (is_frame_from_current_bss(priv, header)) {\r\npriv->beacons_this_sec++;\r\natmel_smooth_qual(priv);\r\nif (priv->last_beacon_timestamp) {\r\nu32 beacon_delay = timestamp - priv->last_beacon_timestamp;\r\nint beacons = beacon_delay / (beacon_interval * 1000);\r\nif (beacons > 1)\r\npriv->wstats.miss.beacon += beacons - 1;\r\n}\r\npriv->last_beacon_timestamp = timestamp;\r\nhandle_beacon_probe(priv, capability, channel);\r\n}\r\n}\r\nif (priv->station_state == STATION_STATE_SCANNING)\r\nstore_bss_info(priv, header, capability,\r\nbeacon_interval, channel, rssi,\r\nssid_length,\r\n&beacon->rates_el_id,\r\nsubtype == IEEE80211_STYPE_BEACON);\r\n}\r\nbreak;\r\ncase IEEE80211_STYPE_AUTH:\r\nif (priv->station_state == STATION_STATE_AUTHENTICATING)\r\nauthenticate(priv, frame_len);\r\nbreak;\r\ncase IEEE80211_STYPE_ASSOC_RESP:\r\ncase IEEE80211_STYPE_REASSOC_RESP:\r\nif (priv->station_state == STATION_STATE_ASSOCIATING ||\r\npriv->station_state == STATION_STATE_REASSOCIATING)\r\nassociate(priv, frame_len, subtype);\r\nbreak;\r\ncase IEEE80211_STYPE_DISASSOC:\r\nif (priv->station_is_associated &&\r\npriv->operating_mode == IW_MODE_INFRA &&\r\nis_frame_from_current_bss(priv, header)) {\r\npriv->station_was_associated = 0;\r\npriv->station_is_associated = 0;\r\natmel_enter_state(priv, STATION_STATE_JOINNING);\r\njoin(priv, BSS_TYPE_INFRASTRUCTURE);\r\n}\r\nbreak;\r\ncase IEEE80211_STYPE_DEAUTH:\r\nif (priv->operating_mode == IW_MODE_INFRA &&\r\nis_frame_from_current_bss(priv, header)) {\r\npriv->station_was_associated = 0;\r\natmel_enter_state(priv, STATION_STATE_JOINNING);\r\njoin(priv, BSS_TYPE_INFRASTRUCTURE);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void atmel_management_timer(u_long a)\r\n{\r\nstruct net_device *dev = (struct net_device *) a;\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nif (priv->card && priv->present_callback &&\r\n!(*priv->present_callback)(priv->card))\r\nreturn;\r\nspin_lock_irqsave(&priv->irqlock, flags);\r\nswitch (priv->station_state) {\r\ncase STATION_STATE_AUTHENTICATING:\r\nif (priv->AuthenticationRequestRetryCnt >= MAX_AUTHENTICATION_RETRIES) {\r\natmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\r\npriv->station_is_associated = 0;\r\npriv->AuthenticationRequestRetryCnt = 0;\r\nrestart_search(priv);\r\n} else {\r\nint auth = WLAN_AUTH_OPEN;\r\npriv->AuthenticationRequestRetryCnt++;\r\npriv->CurrentAuthentTransactionSeqNum = 0x0001;\r\nmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\r\nif (priv->wep_is_on && priv->exclude_unencrypted)\r\nauth = WLAN_AUTH_SHARED_KEY;\r\nsend_authentication_request(priv, auth, NULL, 0);\r\n}\r\nbreak;\r\ncase STATION_STATE_ASSOCIATING:\r\nif (priv->AssociationRequestRetryCnt == MAX_ASSOCIATION_RETRIES) {\r\natmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\r\npriv->station_is_associated = 0;\r\npriv->AssociationRequestRetryCnt = 0;\r\nrestart_search(priv);\r\n} else {\r\npriv->AssociationRequestRetryCnt++;\r\nmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\r\nsend_association_request(priv, 0);\r\n}\r\nbreak;\r\ncase STATION_STATE_REASSOCIATING:\r\nif (priv->ReAssociationRequestRetryCnt == MAX_ASSOCIATION_RETRIES) {\r\natmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\r\npriv->station_is_associated = 0;\r\npriv->ReAssociationRequestRetryCnt = 0;\r\nrestart_search(priv);\r\n} else {\r\npriv->ReAssociationRequestRetryCnt++;\r\nmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\r\nsend_association_request(priv, 1);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->irqlock, flags);\r\n}\r\nstatic void atmel_command_irq(struct atmel_private *priv)\r\n{\r\nu8 status = atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_STATUS_OFFSET));\r\nu8 command = atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_COMMAND_OFFSET));\r\nint fast_scan;\r\nunion iwreq_data wrqu;\r\nif (status == CMD_STATUS_IDLE ||\r\nstatus == CMD_STATUS_IN_PROGRESS)\r\nreturn;\r\nswitch (command) {\r\ncase CMD_Start:\r\nif (status == CMD_STATUS_COMPLETE) {\r\npriv->station_was_associated = priv->station_is_associated;\r\natmel_get_mib(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_BSSID_POS,\r\n(u8 *)priv->CurrentBSSID, 6);\r\natmel_enter_state(priv, STATION_STATE_READY);\r\n}\r\nbreak;\r\ncase CMD_Scan:\r\nfast_scan = priv->fast_scan;\r\npriv->fast_scan = 0;\r\nif (status != CMD_STATUS_COMPLETE) {\r\natmel_scan(priv, 1);\r\n} else {\r\nint bss_index = retrieve_bss(priv);\r\nint notify_scan_complete = 1;\r\nif (bss_index != -1) {\r\natmel_join_bss(priv, bss_index);\r\n} else if (priv->operating_mode == IW_MODE_ADHOC &&\r\npriv->SSID_size != 0) {\r\nstart(priv, BSS_TYPE_AD_HOC);\r\n} else {\r\npriv->fast_scan = !fast_scan;\r\natmel_scan(priv, 1);\r\nnotify_scan_complete = 0;\r\n}\r\npriv->site_survey_state = SITE_SURVEY_COMPLETED;\r\nif (notify_scan_complete) {\r\nwrqu.data.length = 0;\r\nwrqu.data.flags = 0;\r\nwireless_send_event(priv->dev, SIOCGIWSCAN, &wrqu, NULL);\r\n}\r\n}\r\nbreak;\r\ncase CMD_SiteSurvey:\r\npriv->fast_scan = 0;\r\nif (status != CMD_STATUS_COMPLETE)\r\nreturn;\r\npriv->site_survey_state = SITE_SURVEY_COMPLETED;\r\nif (priv->station_is_associated) {\r\natmel_enter_state(priv, STATION_STATE_READY);\r\nwrqu.data.length = 0;\r\nwrqu.data.flags = 0;\r\nwireless_send_event(priv->dev, SIOCGIWSCAN, &wrqu, NULL);\r\n} else {\r\natmel_scan(priv, 1);\r\n}\r\nbreak;\r\ncase CMD_Join:\r\nif (status == CMD_STATUS_COMPLETE) {\r\nif (priv->operating_mode == IW_MODE_ADHOC) {\r\npriv->station_was_associated = priv->station_is_associated;\r\natmel_enter_state(priv, STATION_STATE_READY);\r\n} else {\r\nint auth = WLAN_AUTH_OPEN;\r\npriv->AuthenticationRequestRetryCnt = 0;\r\natmel_enter_state(priv, STATION_STATE_AUTHENTICATING);\r\nmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\r\npriv->CurrentAuthentTransactionSeqNum = 0x0001;\r\nif (priv->wep_is_on && priv->exclude_unencrypted)\r\nauth = WLAN_AUTH_SHARED_KEY;\r\nsend_authentication_request(priv, auth, NULL, 0);\r\n}\r\nreturn;\r\n}\r\natmel_scan(priv, 1);\r\n}\r\n}\r\nstatic int atmel_wakeup_firmware(struct atmel_private *priv)\r\n{\r\nstruct host_info_struct *iface = &priv->host_info;\r\nu16 mr1, mr3;\r\nint i;\r\nif (priv->card_type == CARD_TYPE_SPI_FLASH)\r\natmel_set_gcr(priv->dev, GCR_REMAP);\r\natmel_clear_gcr(priv->dev, 0x0040);\r\natmel_write16(priv->dev, BSR, BSS_SRAM);\r\nif (priv->card_type == CARD_TYPE_SPI_FLASH)\r\nmdelay(100);\r\nfor (i = LOOP_RETRY_LIMIT; i; i--) {\r\nmr1 = atmel_read16(priv->dev, MR1);\r\nmr3 = atmel_read16(priv->dev, MR3);\r\nif (mr3 & MAC_BOOT_COMPLETE)\r\nbreak;\r\nif (mr1 & MAC_BOOT_COMPLETE &&\r\npriv->bus_type == BUS_TYPE_PCCARD)\r\nbreak;\r\n}\r\nif (i == 0) {\r\nprintk(KERN_ALERT "%s: MAC failed to boot.\n", priv->dev->name);\r\nreturn -EIO;\r\n}\r\nif ((priv->host_info_base = atmel_read16(priv->dev, MR2)) == 0xffff) {\r\nprintk(KERN_ALERT "%s: card missing.\n", priv->dev->name);\r\nreturn -ENODEV;\r\n}\r\natmel_wmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET), FUNC_CTRL_INIT_COMPLETE);\r\nfor (i = LOOP_RETRY_LIMIT; i; i--) {\r\nmr1 = atmel_read16(priv->dev, MR1);\r\nmr3 = atmel_read16(priv->dev, MR3);\r\nif (mr3 & MAC_INIT_COMPLETE)\r\nbreak;\r\nif (mr1 & MAC_INIT_COMPLETE &&\r\npriv->bus_type == BUS_TYPE_PCCARD)\r\nbreak;\r\n}\r\nif (i == 0) {\r\nprintk(KERN_ALERT "%s: MAC failed to initialise.\n",\r\npriv->dev->name);\r\nreturn -EIO;\r\n}\r\nif ((mr3 & MAC_INIT_COMPLETE) &&\r\n!(atmel_read16(priv->dev, MR3) & MAC_INIT_OK)) {\r\nprintk(KERN_ALERT "%s: MAC failed MR3 self-test.\n", priv->dev->name);\r\nreturn -EIO;\r\n}\r\nif ((mr1 & MAC_INIT_COMPLETE) &&\r\n!(atmel_read16(priv->dev, MR1) & MAC_INIT_OK)) {\r\nprintk(KERN_ALERT "%s: MAC failed MR1 self-test.\n", priv->dev->name);\r\nreturn -EIO;\r\n}\r\natmel_copy_to_host(priv->dev, (unsigned char *)iface,\r\npriv->host_info_base, sizeof(*iface));\r\niface->tx_buff_pos = le16_to_cpu(iface->tx_buff_pos);\r\niface->tx_buff_size = le16_to_cpu(iface->tx_buff_size);\r\niface->tx_desc_pos = le16_to_cpu(iface->tx_desc_pos);\r\niface->tx_desc_count = le16_to_cpu(iface->tx_desc_count);\r\niface->rx_buff_pos = le16_to_cpu(iface->rx_buff_pos);\r\niface->rx_buff_size = le16_to_cpu(iface->rx_buff_size);\r\niface->rx_desc_pos = le16_to_cpu(iface->rx_desc_pos);\r\niface->rx_desc_count = le16_to_cpu(iface->rx_desc_count);\r\niface->build_version = le16_to_cpu(iface->build_version);\r\niface->command_pos = le16_to_cpu(iface->command_pos);\r\niface->major_version = le16_to_cpu(iface->major_version);\r\niface->minor_version = le16_to_cpu(iface->minor_version);\r\niface->func_ctrl = le16_to_cpu(iface->func_ctrl);\r\niface->mac_status = le16_to_cpu(iface->mac_status);\r\nreturn 0;\r\n}\r\nstatic int probe_atmel_card(struct net_device *dev)\r\n{\r\nint rc = 0;\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nif (priv->bus_type == BUS_TYPE_PCCARD)\r\natmel_write16(dev, GCR, 0x0060);\r\natmel_write16(dev, GCR, 0x0040);\r\nmdelay(500);\r\nif (atmel_read16(dev, MR2) == 0) {\r\nint i;\r\npriv->card_type = CARD_TYPE_EEPROM;\r\natmel_write16(dev, BSR, BSS_IRAM);\r\natmel_copy_to_card(dev, 0, mac_reader, sizeof(mac_reader));\r\natmel_set_gcr(dev, GCR_REMAP);\r\natmel_clear_gcr(priv->dev, 0x0040);\r\natmel_write16(dev, BSR, BSS_SRAM);\r\nfor (i = LOOP_RETRY_LIMIT; i; i--)\r\nif (atmel_read16(dev, MR3) & MAC_BOOT_COMPLETE)\r\nbreak;\r\nif (i == 0) {\r\nprintk(KERN_ALERT "%s: MAC failed to boot MAC address reader.\n", dev->name);\r\n} else {\r\natmel_copy_to_host(dev, dev->dev_addr, atmel_read16(dev, MR2), 6);\r\nif (priv->bus_type == BUS_TYPE_PCCARD)\r\natmel_write16(dev, GCR, 0x0060);\r\natmel_write16(dev, GCR, 0x0040);\r\nrc = 1;\r\n}\r\n} else if (atmel_read16(dev, MR4) == 0) {\r\npriv->card_type = CARD_TYPE_PARALLEL_FLASH;\r\natmel_write16(dev, BSR, 1);\r\natmel_copy_to_host(dev, dev->dev_addr, 0xc000, 6);\r\natmel_write16(dev, BSR, 0x200);\r\nrc = 1;\r\n} else {\r\npriv->card_type = CARD_TYPE_SPI_FLASH;\r\nif (atmel_wakeup_firmware(priv) == 0) {\r\natmel_get_mib(priv, Mac_Address_Mib_Type, 0, dev->dev_addr, 6);\r\nif (priv->bus_type == BUS_TYPE_PCCARD)\r\natmel_write16(dev, GCR, 0x0060);\r\natmel_write16(dev, GCR, 0x0040);\r\nrc = 1;\r\n}\r\n}\r\nif (rc) {\r\nif (dev->dev_addr[0] == 0xFF) {\r\nstatic const u8 default_mac[] = {\r\n0x00, 0x04, 0x25, 0x00, 0x00, 0x00\r\n};\r\nprintk(KERN_ALERT "%s: *** Invalid MAC address. UPGRADE Firmware ****\n", dev->name);\r\nmemcpy(dev->dev_addr, default_mac, ETH_ALEN);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void build_wep_mib(struct atmel_private *priv)\r\n{\r\nstruct {\r\nu8 wep_is_on;\r\nu8 default_key;\r\nu8 reserved;\r\nu8 exclude_unencrypted;\r\nu32 WEPICV_error_count;\r\nu32 WEP_excluded_count;\r\nu8 wep_keys[MAX_ENCRYPTION_KEYS][13];\r\nu8 encryption_level;\r\nu8 reserved2[3];\r\n} mib;\r\nint i;\r\nmib.wep_is_on = priv->wep_is_on;\r\nif (priv->wep_is_on) {\r\nif (priv->wep_key_len[priv->default_key] > 5)\r\nmib.encryption_level = 2;\r\nelse\r\nmib.encryption_level = 1;\r\n} else {\r\nmib.encryption_level = 0;\r\n}\r\nmib.default_key = priv->default_key;\r\nmib.exclude_unencrypted = priv->exclude_unencrypted;\r\nfor (i = 0; i < MAX_ENCRYPTION_KEYS; i++)\r\nmemcpy(mib.wep_keys[i], priv->wep_keys[i], 13);\r\natmel_set_mib(priv, Mac_Wep_Mib_Type, 0, (u8 *)&mib, sizeof(mib));\r\n}\r\nstatic void build_wpa_mib(struct atmel_private *priv)\r\n{\r\nstruct {\r\nu8 cipher_default_key_value[MAX_ENCRYPTION_KEYS][MAX_ENCRYPTION_KEY_SIZE];\r\nu8 receiver_address[ETH_ALEN];\r\nu8 wep_is_on;\r\nu8 default_key;\r\nu8 group_key;\r\nu8 exclude_unencrypted;\r\nu8 encryption_type;\r\nu8 reserved;\r\nu32 WEPICV_error_count;\r\nu32 WEP_excluded_count;\r\nu8 key_RSC[4][8];\r\n} mib;\r\nint i;\r\nmib.wep_is_on = priv->wep_is_on;\r\nmib.exclude_unencrypted = priv->exclude_unencrypted;\r\nmemcpy(mib.receiver_address, priv->CurrentBSSID, ETH_ALEN);\r\nmemset(mib.cipher_default_key_value, 0, sizeof(mib.cipher_default_key_value));\r\nif (priv->wep_is_on) {\r\nmemset(mib.key_RSC, 0, sizeof(mib.key_RSC));\r\nmib.default_key = mib.group_key = 255;\r\nfor (i = 0; i < MAX_ENCRYPTION_KEYS; i++) {\r\nif (priv->wep_key_len[i] > 0) {\r\nmemcpy(mib.cipher_default_key_value[i], priv->wep_keys[i], MAX_ENCRYPTION_KEY_SIZE);\r\nif (i == priv->default_key) {\r\nmib.default_key = i;\r\nmib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-1] = 7;\r\nmib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->pairwise_cipher_suite;\r\n} else {\r\nmib.group_key = i;\r\npriv->group_cipher_suite = priv->pairwise_cipher_suite;\r\nmib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-1] = 1;\r\nmib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->group_cipher_suite;\r\n}\r\n}\r\n}\r\nif (mib.default_key == 255)\r\nmib.default_key = mib.group_key != 255 ? mib.group_key : 0;\r\nif (mib.group_key == 255)\r\nmib.group_key = mib.default_key;\r\n}\r\natmel_set_mib(priv, Mac_Wep_Mib_Type, 0, (u8 *)&mib, sizeof(mib));\r\n}\r\nstatic int reset_atmel_card(struct net_device *dev)\r\n{\r\nstruct atmel_private *priv = netdev_priv(dev);\r\nu8 configuration;\r\nint old_state = priv->station_state;\r\nint err = 0;\r\nstatic char *firmware_modifier[] = {\r\n"-wpa",\r\n"",\r\nNULL\r\n};\r\nif (priv->bus_type == BUS_TYPE_PCCARD)\r\natmel_write16(priv->dev, GCR, 0x0060);\r\natmel_write16(priv->dev, GCR, 0x0040);\r\nif (priv->card_type == CARD_TYPE_EEPROM) {\r\nconst struct firmware *fw_entry = NULL;\r\nconst unsigned char *fw;\r\nint len = priv->firmware_length;\r\nif (!(fw = priv->firmware)) {\r\nif (priv->firmware_type == ATMEL_FW_TYPE_NONE) {\r\nif (strlen(priv->firmware_id) == 0) {\r\nprintk(KERN_INFO\r\n"%s: card type is unknown: assuming at76c502 firmware is OK.\n",\r\ndev->name);\r\nprintk(KERN_INFO\r\n"%s: if not, use the firmware= module parameter.\n",\r\ndev->name);\r\nstrcpy(priv->firmware_id, "atmel_at76c502.bin");\r\n}\r\nerr = request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev);\r\nif (err != 0) {\r\nprintk(KERN_ALERT\r\n"%s: firmware %s is missing, cannot continue.\n",\r\ndev->name, priv->firmware_id);\r\nreturn err;\r\n}\r\n} else {\r\nint fw_index = 0;\r\nint success = 0;\r\nwhile (fw_table[fw_index].fw_type != priv->firmware_type\r\n&& fw_table[fw_index].fw_type != ATMEL_FW_TYPE_NONE)\r\nfw_index++;\r\nif (fw_table[fw_index].fw_type != ATMEL_FW_TYPE_NONE) {\r\nint i;\r\nfor (i = 0; firmware_modifier[i]; i++) {\r\nsnprintf(priv->firmware_id, 32, "%s%s.%s", fw_table[fw_index].fw_file,\r\nfirmware_modifier[i], fw_table[fw_index].fw_file_ext);\r\npriv->firmware_id[31] = '\0';\r\nif (request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev) == 0) {\r\nsuccess = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!success) {\r\nprintk(KERN_ALERT\r\n"%s: firmware %s is missing, cannot start.\n",\r\ndev->name, priv->firmware_id);\r\npriv->firmware_id[0] = '\0';\r\nreturn -ENOENT;\r\n}\r\n}\r\nfw = fw_entry->data;\r\nlen = fw_entry->size;\r\n}\r\nif (len <= 0x6000) {\r\natmel_write16(priv->dev, BSR, BSS_IRAM);\r\natmel_copy_to_card(priv->dev, 0, fw, len);\r\natmel_set_gcr(priv->dev, GCR_REMAP);\r\n} else {\r\natmel_set_gcr(priv->dev, GCR_REMAP);\r\natmel_write16(priv->dev, BSR, BSS_IRAM);\r\natmel_copy_to_card(priv->dev, 0, fw, 0x6000);\r\natmel_write16(priv->dev, BSR, 0x2ff);\r\natmel_copy_to_card(priv->dev, 0x8000, &fw[0x6000], len - 0x6000);\r\n}\r\nrelease_firmware(fw_entry);\r\n}\r\nerr = atmel_wakeup_firmware(priv);\r\nif (err != 0)\r\nreturn err;\r\npriv->use_wpa = (priv->host_info.major_version == 4);\r\npriv->radio_on_broken = (priv->host_info.major_version == 5);\r\natmel_wmem8(priv, atmel_hi(priv, IFACE_INT_MASK_OFFSET), 0xff);\r\natmel_wmem8(priv, atmel_tx(priv, TX_DESC_FLAGS_OFFSET, 0), 0);\r\natmel_wmem32(priv, atmel_tx(priv, TX_DESC_NEXT_OFFSET, 0), 0x80000000L);\r\natmel_wmem16(priv, atmel_tx(priv, TX_DESC_POS_OFFSET, 0), 0);\r\natmel_wmem16(priv, atmel_tx(priv, TX_DESC_SIZE_OFFSET, 0), 0);\r\npriv->tx_desc_free = priv->host_info.tx_desc_count;\r\npriv->tx_desc_head = 0;\r\npriv->tx_desc_tail = 0;\r\npriv->tx_desc_previous = 0;\r\npriv->tx_free_mem = priv->host_info.tx_buff_size;\r\npriv->tx_buff_head = 0;\r\npriv->tx_buff_tail = 0;\r\nconfiguration = atmel_rmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET));\r\natmel_wmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET),\r\nconfiguration | FUNC_CTRL_TxENABLE);\r\npriv->rx_desc_head = 0;\r\nconfiguration = atmel_rmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET));\r\natmel_wmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET),\r\nconfiguration | FUNC_CTRL_RxENABLE);\r\nif (!priv->radio_on_broken) {\r\nif (atmel_send_command_wait(priv, CMD_EnableRadio, NULL, 0) ==\r\nCMD_STATUS_REJECTED_RADIO_OFF) {\r\nprintk(KERN_INFO "%s: cannot turn the radio on.\n",\r\ndev->name);\r\nreturn -EIO;\r\n}\r\n}\r\natmel_set_mib8(priv, Local_Mib_Type, LOCAL_MIB_AUTO_TX_RATE_POS, priv->auto_tx_rate);\r\natmel_set_mib8(priv, Local_Mib_Type, LOCAL_MIB_TX_PROMISCUOUS_POS, PROM_MODE_OFF);\r\natmel_set_mib16(priv, Mac_Mib_Type, MAC_MIB_RTS_THRESHOLD_POS, priv->rts_threshold);\r\natmel_set_mib16(priv, Mac_Mib_Type, MAC_MIB_FRAG_THRESHOLD_POS, priv->frag_threshold);\r\natmel_set_mib8(priv, Mac_Mib_Type, MAC_MIB_SHORT_RETRY_POS, priv->short_retry);\r\natmel_set_mib8(priv, Mac_Mib_Type, MAC_MIB_LONG_RETRY_POS, priv->long_retry);\r\natmel_set_mib8(priv, Local_Mib_Type, LOCAL_MIB_PREAMBLE_TYPE, priv->preamble);\r\natmel_set_mib(priv, Mac_Address_Mib_Type, MAC_ADDR_MIB_MAC_ADDR_POS,\r\npriv->dev->dev_addr, 6);\r\natmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_PS_MODE_POS, ACTIVE_MODE);\r\natmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);\r\natmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_BEACON_PER_POS, priv->default_beacon_period);\r\natmel_set_mib(priv, Phy_Mib_Type, PHY_MIB_RATE_SET_POS, atmel_basic_rates, 4);\r\natmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_PRIVACY_POS, priv->wep_is_on);\r\nif (priv->use_wpa)\r\nbuild_wpa_mib(priv);\r\nelse\r\nbuild_wep_mib(priv);\r\nif (old_state == STATION_STATE_READY) {\r\nunion iwreq_data wrqu;\r\nwrqu.data.length = 0;\r\nwrqu.data.flags = 0;\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);\r\nwireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_send_command(struct atmel_private *priv, int command,\r\nvoid *cmd, int cmd_size)\r\n{\r\nif (cmd)\r\natmel_copy_to_card(priv->dev, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET),\r\ncmd, cmd_size);\r\natmel_wmem8(priv, atmel_co(priv, CMD_BLOCK_COMMAND_OFFSET), command);\r\natmel_wmem8(priv, atmel_co(priv, CMD_BLOCK_STATUS_OFFSET), 0);\r\n}\r\nstatic int atmel_send_command_wait(struct atmel_private *priv, int command,\r\nvoid *cmd, int cmd_size)\r\n{\r\nint i, status;\r\natmel_send_command(priv, command, cmd, cmd_size);\r\nfor (i = 5000; i; i--) {\r\nstatus = atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_STATUS_OFFSET));\r\nif (status != CMD_STATUS_IDLE &&\r\nstatus != CMD_STATUS_IN_PROGRESS)\r\nbreak;\r\nudelay(20);\r\n}\r\nif (i == 0) {\r\nprintk(KERN_ALERT "%s: failed to contact MAC.\n", priv->dev->name);\r\nstatus = CMD_STATUS_HOST_ERROR;\r\n} else {\r\nif (command != CMD_EnableRadio)\r\nstatus = CMD_STATUS_COMPLETE;\r\n}\r\nreturn status;\r\n}\r\nstatic u8 atmel_get_mib8(struct atmel_private *priv, u8 type, u8 index)\r\n{\r\nstruct get_set_mib m;\r\nm.type = type;\r\nm.size = 1;\r\nm.index = index;\r\natmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + 1);\r\nreturn atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE));\r\n}\r\nstatic void atmel_set_mib8(struct atmel_private *priv, u8 type, u8 index, u8 data)\r\n{\r\nstruct get_set_mib m;\r\nm.type = type;\r\nm.size = 1;\r\nm.index = index;\r\nm.data[0] = data;\r\natmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + 1);\r\n}\r\nstatic void atmel_set_mib16(struct atmel_private *priv, u8 type, u8 index,\r\nu16 data)\r\n{\r\nstruct get_set_mib m;\r\nm.type = type;\r\nm.size = 2;\r\nm.index = index;\r\nm.data[0] = data;\r\nm.data[1] = data >> 8;\r\natmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + 2);\r\n}\r\nstatic void atmel_set_mib(struct atmel_private *priv, u8 type, u8 index,\r\nu8 *data, int data_len)\r\n{\r\nstruct get_set_mib m;\r\nm.type = type;\r\nm.size = data_len;\r\nm.index = index;\r\nif (data_len > MIB_MAX_DATA_BYTES)\r\nprintk(KERN_ALERT "%s: MIB buffer too small.\n", priv->dev->name);\r\nmemcpy(m.data, data, data_len);\r\natmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);\r\n}\r\nstatic void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index,\r\nu8 *data, int data_len)\r\n{\r\nstruct get_set_mib m;\r\nm.type = type;\r\nm.size = data_len;\r\nm.index = index;\r\nif (data_len > MIB_MAX_DATA_BYTES)\r\nprintk(KERN_ALERT "%s: MIB buffer too small.\n", priv->dev->name);\r\natmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);\r\natmel_copy_to_host(priv->dev, data,\r\natmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE), data_len);\r\n}\r\nstatic void atmel_writeAR(struct net_device *dev, u16 data)\r\n{\r\nint i;\r\noutw(data, dev->base_addr + AR);\r\nfor (i = 0; data != inw(dev->base_addr + AR) && i < 10; i++)\r\noutw(data, dev->base_addr + AR);\r\n}\r\nstatic void atmel_copy_to_card(struct net_device *dev, u16 dest,\r\nconst unsigned char *src, u16 len)\r\n{\r\nint i;\r\natmel_writeAR(dev, dest);\r\nif (dest % 2) {\r\natmel_write8(dev, DR, *src);\r\nsrc++; len--;\r\n}\r\nfor (i = len; i > 1 ; i -= 2) {\r\nu8 lb = *src++;\r\nu8 hb = *src++;\r\natmel_write16(dev, DR, lb | (hb << 8));\r\n}\r\nif (i)\r\natmel_write8(dev, DR, *src);\r\n}\r\nstatic void atmel_copy_to_host(struct net_device *dev, unsigned char *dest,\r\nu16 src, u16 len)\r\n{\r\nint i;\r\natmel_writeAR(dev, src);\r\nif (src % 2) {\r\n*dest = atmel_read8(dev, DR);\r\ndest++; len--;\r\n}\r\nfor (i = len; i > 1 ; i -= 2) {\r\nu16 hw = atmel_read16(dev, DR);\r\n*dest++ = hw;\r\n*dest++ = hw >> 8;\r\n}\r\nif (i)\r\n*dest = atmel_read8(dev, DR);\r\n}\r\nstatic void atmel_set_gcr(struct net_device *dev, u16 mask)\r\n{\r\noutw(inw(dev->base_addr + GCR) | mask, dev->base_addr + GCR);\r\n}\r\nstatic void atmel_clear_gcr(struct net_device *dev, u16 mask)\r\n{\r\noutw(inw(dev->base_addr + GCR) & ~mask, dev->base_addr + GCR);\r\n}\r\nstatic int atmel_lock_mac(struct atmel_private *priv)\r\n{\r\nint i, j = 20;\r\nretry:\r\nfor (i = 5000; i; i--) {\r\nif (!atmel_rmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_HOST_OFFSET)))\r\nbreak;\r\nudelay(20);\r\n}\r\nif (!i)\r\nreturn 0;\r\natmel_wmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_MAC_OFFSET), 1);\r\nif (atmel_rmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_HOST_OFFSET))) {\r\natmel_wmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_MAC_OFFSET), 0);\r\nif (!j--)\r\nreturn 0;\r\ngoto retry;\r\n}\r\nreturn 1;\r\n}\r\nstatic void atmel_wmem32(struct atmel_private *priv, u16 pos, u32 data)\r\n{\r\natmel_writeAR(priv->dev, pos);\r\natmel_write16(priv->dev, DR, data);\r\natmel_write16(priv->dev, DR, data >> 16);\r\n}
