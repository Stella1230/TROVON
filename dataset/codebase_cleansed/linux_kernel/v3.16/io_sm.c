static inline void set_chnl_free(struct shm *sm, u32 chnl)\r\n{\r\nsm->host_free_mask &= ~(1 << chnl);\r\n}\r\nstatic inline void set_chnl_busy(struct shm *sm, u32 chnl)\r\n{\r\nsm->host_free_mask |= 1 << chnl;\r\n}\r\nint bridge_io_create(struct io_mgr **io_man,\r\nstruct dev_object *hdev_obj,\r\nconst struct io_attrs *mgr_attrts)\r\n{\r\nstruct io_mgr *pio_mgr = NULL;\r\nstruct bridge_dev_context *hbridge_context = NULL;\r\nstruct cfg_devnode *dev_node_obj;\r\nstruct chnl_mgr *hchnl_mgr;\r\nu8 dev_type;\r\nif (!io_man || !mgr_attrts || mgr_attrts->word_size == 0)\r\nreturn -EFAULT;\r\n*io_man = NULL;\r\ndev_get_chnl_mgr(hdev_obj, &hchnl_mgr);\r\nif (!hchnl_mgr || hchnl_mgr->iomgr)\r\nreturn -EFAULT;\r\ndev_get_bridge_context(hdev_obj, &hbridge_context);\r\nif (!hbridge_context)\r\nreturn -EFAULT;\r\ndev_get_dev_type(hdev_obj, &dev_type);\r\npio_mgr = kzalloc(sizeof(struct io_mgr), GFP_KERNEL);\r\nif (!pio_mgr)\r\nreturn -ENOMEM;\r\npio_mgr->chnl_mgr = hchnl_mgr;\r\npio_mgr->word_size = mgr_attrts->word_size;\r\nif (dev_type == DSP_UNIT) {\r\ntasklet_init(&pio_mgr->dpc_tasklet, io_dpc, (u32) pio_mgr);\r\npio_mgr->dpc_req = 0;\r\npio_mgr->dpc_sched = 0;\r\nspin_lock_init(&pio_mgr->dpc_lock);\r\nif (dev_get_dev_node(hdev_obj, &dev_node_obj)) {\r\nbridge_io_destroy(pio_mgr);\r\nreturn -EIO;\r\n}\r\n}\r\npio_mgr->bridge_context = hbridge_context;\r\npio_mgr->shared_irq = mgr_attrts->irq_shared;\r\nif (dsp_wdt_init()) {\r\nbridge_io_destroy(pio_mgr);\r\nreturn -EPERM;\r\n}\r\nhchnl_mgr->iomgr = pio_mgr;\r\n*io_man = pio_mgr;\r\nreturn 0;\r\n}\r\nint bridge_io_destroy(struct io_mgr *hio_mgr)\r\n{\r\nint status = 0;\r\nif (hio_mgr) {\r\ntasklet_kill(&hio_mgr->dpc_tasklet);\r\n#if defined(CONFIG_TIDSPBRIDGE_BACKTRACE)\r\nkfree(hio_mgr->msg);\r\n#endif\r\ndsp_wdt_exit();\r\nkfree(hio_mgr);\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nstruct shm_symbol_val *_get_shm_symbol_values(struct io_mgr *hio_mgr)\r\n{\r\nstruct shm_symbol_val *s;\r\nstruct cod_manager *cod_man;\r\nint status;\r\ns = kzalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn ERR_PTR(-ENOMEM);\r\nstatus = dev_get_cod_mgr(hio_mgr->dev_obj, &cod_man);\r\nif (status)\r\ngoto free_symbol;\r\nstatus = cod_get_sym_value(cod_man, CHNL_SHARED_BUFFER_BASE_SYM,\r\n&s->shm_base);\r\nif (status)\r\ngoto free_symbol;\r\nstatus = cod_get_sym_value(cod_man, CHNL_SHARED_BUFFER_LIMIT_SYM,\r\n&s->shm_lim);\r\nif (status)\r\ngoto free_symbol;\r\nif (s->shm_lim <= s->shm_base) {\r\nstatus = -EINVAL;\r\ngoto free_symbol;\r\n}\r\nstatus = cod_get_sym_value(cod_man, MSG_SHARED_BUFFER_BASE_SYM,\r\n&s->msg_base);\r\nif (status)\r\ngoto free_symbol;\r\nstatus = cod_get_sym_value(cod_man, MSG_SHARED_BUFFER_LIMIT_SYM,\r\n&s->msg_lim);\r\nif (status)\r\ngoto free_symbol;\r\nif (s->msg_lim <= s->msg_base) {\r\nstatus = -EINVAL;\r\ngoto free_symbol;\r\n}\r\n#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE\r\nstatus = cod_get_sym_value(cod_man, DSP_TRACESEC_END, &s->shm0_end);\r\n#else\r\nstatus = cod_get_sym_value(cod_man, SHM0_SHARED_END_SYM, &s->shm0_end);\r\n#endif\r\nif (status)\r\ngoto free_symbol;\r\nstatus = cod_get_sym_value(cod_man, DYNEXTBASE, &s->dyn_ext);\r\nif (status)\r\ngoto free_symbol;\r\nstatus = cod_get_sym_value(cod_man, EXTEND, &s->ext_end);\r\nif (status)\r\ngoto free_symbol;\r\nreturn s;\r\nfree_symbol:\r\nkfree(s);\r\nreturn ERR_PTR(status);\r\n}\r\nint bridge_io_on_loaded(struct io_mgr *hio_mgr)\r\n{\r\nstruct bridge_dev_context *dc = hio_mgr->bridge_context;\r\nstruct cfg_hostres *cfg_res = dc->resources;\r\nstruct bridge_ioctl_extproc *eproc;\r\nstruct cod_manager *cod_man;\r\nstruct chnl_mgr *hchnl_mgr;\r\nstruct msg_mgr *hmsg_mgr;\r\nstruct shm_symbol_val *s;\r\nint status;\r\nu8 num_procs;\r\ns32 ndx;\r\nu32 i;\r\nu32 mem_sz, msg_sz, pad_sz, shm_sz, shm_base_offs;\r\nu32 seg0_sz, seg1_sz;\r\nu32 pa, va, da;\r\nu32 pa_curr, va_curr, da_curr;\r\nu32 bytes;\r\nu32 all_bits = 0;\r\nu32 page_size[] = {\r\nHW_PAGE_SIZE16MB, HW_PAGE_SIZE1MB,\r\nHW_PAGE_SIZE64KB, HW_PAGE_SIZE4KB\r\n};\r\nu32 map_attrs = DSP_MAPLITTLEENDIAN | DSP_MAPPHYSICALADDR |\r\nDSP_MAPELEMSIZE32 | DSP_MAPDONOTLOCK;\r\nstatus = dev_get_cod_mgr(hio_mgr->dev_obj, &cod_man);\r\nif (status)\r\nreturn status;\r\nhchnl_mgr = hio_mgr->chnl_mgr;\r\ndev_get_msg_mgr(hio_mgr->dev_obj, &hio_mgr->msg_mgr);\r\nhmsg_mgr = hio_mgr->msg_mgr;\r\nif (!hchnl_mgr || !hmsg_mgr)\r\nreturn -EFAULT;\r\nif (hio_mgr->shared_mem)\r\nhio_mgr->shared_mem = NULL;\r\ns = _get_shm_symbol_values(hio_mgr);\r\nif (IS_ERR(s))\r\nreturn PTR_ERR(s);\r\nshm_sz = (s->shm_lim - s->shm_base + 1) * hio_mgr->word_size;\r\ndev_dbg(bridge, "%s: (proc)proccopy shmmem size: 0x%x bytes\n",\r\n__func__, shm_sz - sizeof(struct shm));\r\nmsg_sz = (s->msg_lim - s->msg_base + 1) * hio_mgr->word_size;\r\nmem_sz = shm_sz + msg_sz;\r\n(void)mgr_enum_processor_info(0,\r\n(struct dsp_processorinfo *)\r\n&hio_mgr->ext_proc_info,\r\nsizeof(struct mgr_processorextinfo),\r\n&num_procs);\r\nif (num_procs != 1) {\r\nstatus = -EINVAL;\r\ngoto free_symbol;\r\n}\r\npa = cfg_res->mem_phys[1];\r\nva = cfg_res->mem_base[1];\r\nda = hio_mgr->ext_proc_info.ty_tlb[0].dsp_virt;\r\nseg0_sz = (s->shm0_end - da) * hio_mgr->word_size;\r\nseg1_sz = (s->ext_end - s->dyn_ext) * hio_mgr->word_size;\r\nseg1_sz = (seg1_sz + 0xFFF) & (~0xFFFUL);\r\nseg0_sz = (seg0_sz + 0xFFFF) & (~0xFFFFUL);\r\npad_sz = UL_PAGE_ALIGN_SIZE - ((pa + seg1_sz) % UL_PAGE_ALIGN_SIZE);\r\nif (pad_sz == UL_PAGE_ALIGN_SIZE)\r\npad_sz = 0x0;\r\ndev_dbg(bridge, "%s: pa %x, va %x, da %x\n", __func__, pa, va, da);\r\ndev_dbg(bridge,\r\n"shm0_end %x, dyn_ext %x, ext_end %x, seg0_sz %x seg1_sz %x\n",\r\ns->shm0_end, s->dyn_ext, s->ext_end, seg0_sz, seg1_sz);\r\nif ((seg0_sz + seg1_sz + pad_sz) > cfg_res->mem_length[1]) {\r\npr_err("%s: shm Error, reserved 0x%x required 0x%x\n",\r\n__func__, cfg_res->mem_length[1],\r\nseg0_sz + seg1_sz + pad_sz);\r\nstatus = -ENOMEM;\r\ngoto free_symbol;\r\n}\r\npa_curr = pa;\r\nva_curr = s->dyn_ext * hio_mgr->word_size;\r\nda_curr = va;\r\nbytes = seg1_sz;\r\nwhile (bytes) {\r\nall_bits = pa_curr | va_curr;\r\ndev_dbg(bridge,\r\n"seg all_bits %x, pa_curr %x, va_curr %x, bytes %x\n",\r\nall_bits, pa_curr, va_curr, bytes);\r\nfor (i = 0; i < 4; i++) {\r\nif ((bytes >= page_size[i]) &&\r\n((all_bits & (page_size[i] - 1)) == 0)) {\r\nstatus = hio_mgr->intf_fxns->brd_mem_map(dc,\r\npa_curr, va_curr,\r\npage_size[i], map_attrs,\r\nNULL);\r\nif (status)\r\ngoto free_symbol;\r\npa_curr += page_size[i];\r\nva_curr += page_size[i];\r\nda_curr += page_size[i];\r\nbytes -= page_size[i];\r\nbreak;\r\n}\r\n}\r\n}\r\npa_curr += pad_sz;\r\nva_curr += pad_sz;\r\nda_curr += pad_sz;\r\nbytes = seg0_sz;\r\nva_curr = da * hio_mgr->word_size;\r\neproc = kzalloc(sizeof(*eproc) * BRDIOCTL_NUMOFMMUTLB, GFP_KERNEL);\r\nif (!eproc) {\r\nstatus = -ENOMEM;\r\ngoto free_symbol;\r\n}\r\nndx = 0;\r\nwhile (bytes) {\r\nall_bits = pa_curr | va_curr;\r\ndev_dbg(bridge,\r\n"seg1 all_bits %x, pa_curr %x, va_curr %x, bytes %x\n",\r\nall_bits, pa_curr, va_curr, bytes);\r\nfor (i = 0; i < 4; i++) {\r\nif (!(bytes >= page_size[i]) ||\r\n!((all_bits & (page_size[i] - 1)) == 0))\r\ncontinue;\r\nif (ndx >= MAX_LOCK_TLB_ENTRIES) {\r\nstatus = hio_mgr->intf_fxns->brd_mem_map(dc,\r\npa_curr, va_curr,\r\npage_size[i], map_attrs,\r\nNULL);\r\ndev_dbg(bridge,\r\n"PTE pa %x va %x dsp_va %x sz %x\n",\r\neproc[ndx].gpp_pa,\r\neproc[ndx].gpp_va,\r\neproc[ndx].dsp_va *\r\nhio_mgr->word_size, page_size[i]);\r\nif (status)\r\ngoto free_eproc;\r\n}\r\neproc[ndx].gpp_pa = pa_curr;\r\neproc[ndx].gpp_va = da_curr;\r\neproc[ndx].dsp_va = va_curr / hio_mgr->word_size;\r\neproc[ndx].size = page_size[i];\r\neproc[ndx].endianism = HW_LITTLE_ENDIAN;\r\neproc[ndx].elem_size = HW_ELEM_SIZE16BIT;\r\neproc[ndx].mixed_mode = HW_MMU_CPUES;\r\ndev_dbg(bridge, "%s: tlb pa %x va %x dsp_va %x sz %x\n",\r\n__func__, eproc[ndx].gpp_pa,\r\neproc[ndx].gpp_va,\r\neproc[ndx].dsp_va * hio_mgr->word_size,\r\npage_size[i]);\r\nndx++;\r\npa_curr += page_size[i];\r\nva_curr += page_size[i];\r\nda_curr += page_size[i];\r\nbytes -= page_size[i];\r\nbreak;\r\n}\r\n}\r\nfor (i = 3; i < 7 && ndx < BRDIOCTL_NUMOFMMUTLB; i++) {\r\nstruct mgr_processorextinfo *ep = &hio_mgr->ext_proc_info;\r\nu32 word_sz = hio_mgr->word_size;\r\nif (ep->ty_tlb[i].gpp_phys == 0)\r\ncontinue;\r\nif ((ep->ty_tlb[i].gpp_phys > pa - 0x100000 &&\r\nep->ty_tlb[i].gpp_phys <= pa + seg0_sz) ||\r\n(ep->ty_tlb[i].dsp_virt > da - 0x100000 / word_sz &&\r\nep->ty_tlb[i].dsp_virt <= da + seg0_sz / word_sz)) {\r\ndev_dbg(bridge,\r\n"err cdb%d pa %x da %x shm pa %x da %x sz %x\n",\r\ni, ep->ty_tlb[i].gpp_phys,\r\nep->ty_tlb[i].dsp_virt, pa, da, seg0_sz);\r\nstatus = -EPERM;\r\ngoto free_eproc;\r\n}\r\nif (ndx >= MAX_LOCK_TLB_ENTRIES) {\r\nstatus = hio_mgr->intf_fxns->brd_mem_map(dc,\r\nep->ty_tlb[i].gpp_phys,\r\nep->ty_tlb[i].dsp_virt,\r\n0x100000, map_attrs, NULL);\r\nif (status)\r\ngoto free_eproc;\r\n}\r\neproc[ndx].dsp_va = ep->ty_tlb[i].dsp_virt;\r\neproc[ndx].gpp_pa = ep->ty_tlb[i].gpp_phys;\r\neproc[ndx].gpp_va = 0;\r\neproc[ndx].size = 0x100000;\r\ndev_dbg(bridge, "shm MMU entry pa %x da 0x%x\n",\r\neproc[ndx].gpp_pa, eproc[ndx].dsp_va);\r\nndx++;\r\n}\r\ni = 0;\r\nwhile (l4_peripheral_table[i].phys_addr) {\r\nstatus = hio_mgr->intf_fxns->brd_mem_map(dc,\r\nl4_peripheral_table[i].phys_addr,\r\nl4_peripheral_table[i].dsp_virt_addr,\r\nHW_PAGE_SIZE4KB, map_attrs, NULL);\r\nif (status)\r\ngoto free_eproc;\r\ni++;\r\n}\r\nfor (i = ndx; i < BRDIOCTL_NUMOFMMUTLB; i++) {\r\neproc[i].dsp_va = 0;\r\neproc[i].gpp_pa = 0;\r\neproc[i].gpp_va = 0;\r\neproc[i].size = 0;\r\n}\r\nhio_mgr->ext_proc_info.ty_tlb[0].gpp_phys =\r\n(va + seg1_sz + pad_sz);\r\nif (!hio_mgr->ext_proc_info.ty_tlb[0].gpp_phys)\r\nreturn -EFAULT;\r\nif (eproc[0].dsp_va > s->shm_base)\r\nreturn -EPERM;\r\nshm_base_offs = (s->shm_base - eproc[0].dsp_va) *\r\nhio_mgr->word_size;\r\nstatus = hio_mgr->intf_fxns->dev_cntrl(hio_mgr->bridge_context,\r\nBRDIOCTL_SETMMUCONFIG, eproc);\r\nif (status)\r\ngoto free_eproc;\r\ns->shm_base = hio_mgr->ext_proc_info.ty_tlb[0].gpp_phys;\r\ns->shm_base += shm_base_offs;\r\ns->shm_base = (u32) MEM_LINEAR_ADDRESS((void *)s->shm_base,\r\nmem_sz);\r\nif (!s->shm_base) {\r\nstatus = -EFAULT;\r\ngoto free_eproc;\r\n}\r\nstatus = register_shm_segs(hio_mgr, cod_man, eproc[0].gpp_pa);\r\nhio_mgr->shared_mem = (struct shm *)s->shm_base;\r\nhio_mgr->input = (u8 *) hio_mgr->shared_mem + sizeof(struct shm);\r\nhio_mgr->output = hio_mgr->input + (shm_sz -\r\nsizeof(struct shm)) / 2;\r\nhio_mgr->sm_buf_size = hio_mgr->output - hio_mgr->input;\r\nhio_mgr->msg_input_ctrl =\r\n(struct msg_ctrl *)((u8 *) hio_mgr->shared_mem + shm_sz);\r\nhio_mgr->msg_input =\r\n(u8 *) hio_mgr->msg_input_ctrl + sizeof(struct msg_ctrl);\r\nhio_mgr->msg_output_ctrl =\r\n(struct msg_ctrl *)((u8 *) hio_mgr->msg_input_ctrl +\r\nmsg_sz / 2);\r\nhio_mgr->msg_output =\r\n(u8 *) hio_mgr->msg_output_ctrl + sizeof(struct msg_ctrl);\r\nhmsg_mgr->max_msgs =\r\n((u8 *) hio_mgr->msg_output_ctrl - hio_mgr->msg_input) /\r\nsizeof(struct msg_dspmsg);\r\ndev_dbg(bridge, "IO MGR shm details: shared_mem %p, input %p, "\r\n"output %p, msg_input_ctrl %p, msg_input %p, "\r\n"msg_output_ctrl %p, msg_output %p\n",\r\n(u8 *) hio_mgr->shared_mem, hio_mgr->input,\r\nhio_mgr->output, (u8 *) hio_mgr->msg_input_ctrl,\r\nhio_mgr->msg_input, (u8 *) hio_mgr->msg_output_ctrl,\r\nhio_mgr->msg_output);\r\ndev_dbg(bridge, "(proc) Mas msgs in shared memory: 0x%x\n",\r\nhmsg_mgr->max_msgs);\r\nmemset((void *)hio_mgr->shared_mem, 0, sizeof(struct shm));\r\n#if defined(CONFIG_TIDSPBRIDGE_BACKTRACE)\r\nstatus = cod_get_sym_value(cod_man, SYS_PUTCBEG,\r\n&hio_mgr->trace_buffer_begin);\r\nif (status)\r\ngoto free_eproc;\r\nhio_mgr->gpp_read_pointer =\r\nhio_mgr->trace_buffer_begin =\r\n(va + seg1_sz + pad_sz) +\r\n(hio_mgr->trace_buffer_begin - da);\r\nstatus = cod_get_sym_value(cod_man, SYS_PUTCEND,\r\n&hio_mgr->trace_buffer_end);\r\nif (status)\r\ngoto free_eproc;\r\nhio_mgr->trace_buffer_end =\r\n(va + seg1_sz + pad_sz) +\r\n(hio_mgr->trace_buffer_end - da);\r\nstatus = cod_get_sym_value(cod_man, BRIDGE_SYS_PUTC_CURRENT,\r\n&hio_mgr->trace_buffer_current);\r\nif (status)\r\ngoto free_eproc;\r\nhio_mgr->trace_buffer_current =\r\n(va + seg1_sz + pad_sz) +\r\n(hio_mgr->trace_buffer_current - da);\r\nkfree(hio_mgr->msg);\r\nhio_mgr->msg = kmalloc(((hio_mgr->trace_buffer_end -\r\nhio_mgr->trace_buffer_begin) *\r\nhio_mgr->word_size) + 2, GFP_KERNEL);\r\nif (!hio_mgr->msg) {\r\nstatus = -ENOMEM;\r\ngoto free_eproc;\r\n}\r\nhio_mgr->dsp_va = da;\r\nhio_mgr->gpp_va = (va + seg1_sz + pad_sz);\r\n#endif\r\nfree_eproc:\r\nkfree(eproc);\r\nfree_symbol:\r\nkfree(s);\r\nreturn status;\r\n}\r\nu32 io_buf_size(struct io_mgr *hio_mgr)\r\n{\r\nif (hio_mgr)\r\nreturn hio_mgr->sm_buf_size;\r\nelse\r\nreturn 0;\r\n}\r\nvoid io_cancel_chnl(struct io_mgr *hio_mgr, u32 chnl)\r\n{\r\nstruct io_mgr *pio_mgr = (struct io_mgr *)hio_mgr;\r\nstruct shm *sm;\r\nif (!hio_mgr)\r\ngoto func_end;\r\nsm = hio_mgr->shared_mem;\r\nset_chnl_free(sm, chnl);\r\nsm_interrupt_dsp(pio_mgr->bridge_context, MBX_PCPY_CLASS);\r\nfunc_end:\r\nreturn;\r\n}\r\nstatic void io_dispatch_pm(struct io_mgr *pio_mgr)\r\n{\r\nint status;\r\nu32 parg[2];\r\nparg[0] = pio_mgr->intr_val;\r\nif (parg[0] == MBX_PM_HIBERNATE_EN) {\r\ndev_dbg(bridge, "PM: Hibernate command\n");\r\nstatus = pio_mgr->intf_fxns->\r\ndev_cntrl(pio_mgr->bridge_context,\r\nBRDIOCTL_PWR_HIBERNATE, parg);\r\nif (status)\r\npr_err("%s: hibernate cmd failed 0x%x\n",\r\n__func__, status);\r\n} else if (parg[0] == MBX_PM_OPP_REQ) {\r\nparg[1] = pio_mgr->shared_mem->opp_request.rqst_opp_pt;\r\ndev_dbg(bridge, "PM: Requested OPP = 0x%x\n", parg[1]);\r\nstatus = pio_mgr->intf_fxns->\r\ndev_cntrl(pio_mgr->bridge_context,\r\nBRDIOCTL_CONSTRAINT_REQUEST, parg);\r\nif (status)\r\ndev_dbg(bridge, "PM: Failed to set constraint "\r\n"= 0x%x\n", parg[1]);\r\n} else {\r\ndev_dbg(bridge, "PM: clk control value of msg = 0x%x\n",\r\nparg[0]);\r\nstatus = pio_mgr->intf_fxns->\r\ndev_cntrl(pio_mgr->bridge_context,\r\nBRDIOCTL_CLK_CTRL, parg);\r\nif (status)\r\ndev_dbg(bridge, "PM: Failed to ctrl the DSP clk"\r\n"= 0x%x\n", *parg);\r\n}\r\n}\r\nvoid io_dpc(unsigned long ref_data)\r\n{\r\nstruct io_mgr *pio_mgr = (struct io_mgr *)ref_data;\r\nstruct chnl_mgr *chnl_mgr_obj;\r\nstruct msg_mgr *msg_mgr_obj;\r\nstruct deh_mgr *hdeh_mgr;\r\nu32 requested;\r\nu32 serviced;\r\nif (!pio_mgr)\r\ngoto func_end;\r\nchnl_mgr_obj = pio_mgr->chnl_mgr;\r\ndev_get_msg_mgr(pio_mgr->dev_obj, &msg_mgr_obj);\r\ndev_get_deh_mgr(pio_mgr->dev_obj, &hdeh_mgr);\r\nif (!chnl_mgr_obj)\r\ngoto func_end;\r\nrequested = pio_mgr->dpc_req;\r\nserviced = pio_mgr->dpc_sched;\r\nif (serviced == requested)\r\ngoto func_end;\r\ndo {\r\nif ((pio_mgr->intr_val > DEH_BASE) &&\r\n(pio_mgr->intr_val < DEH_LIMIT)) {\r\nif (hdeh_mgr) {\r\n#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE\r\nprint_dsp_debug_trace(pio_mgr);\r\n#endif\r\nbridge_deh_notify(hdeh_mgr, DSP_SYSERROR,\r\npio_mgr->intr_val);\r\n}\r\n}\r\ninput_chnl(pio_mgr, NULL, IO_SERVICE);\r\noutput_chnl(pio_mgr, NULL, IO_SERVICE);\r\n#ifdef CHNL_MESSAGES\r\nif (msg_mgr_obj) {\r\ninput_msg(pio_mgr, msg_mgr_obj);\r\noutput_msg(pio_mgr, msg_mgr_obj);\r\n}\r\n#endif\r\n#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE\r\nif (pio_mgr->intr_val & MBX_DBG_SYSPRINTF) {\r\nprint_dsp_debug_trace(pio_mgr);\r\n}\r\n#endif\r\nserviced++;\r\n} while (serviced != requested);\r\npio_mgr->dpc_sched = requested;\r\nfunc_end:\r\nreturn;\r\n}\r\nint io_mbox_msg(struct notifier_block *self, unsigned long len, void *msg)\r\n{\r\nstruct io_mgr *pio_mgr;\r\nstruct dev_object *dev_obj;\r\nunsigned long flags;\r\ndev_obj = dev_get_first();\r\ndev_get_io_mgr(dev_obj, &pio_mgr);\r\nif (!pio_mgr)\r\nreturn NOTIFY_BAD;\r\npio_mgr->intr_val = (u16)((u32)msg);\r\nif (pio_mgr->intr_val & MBX_PM_CLASS)\r\nio_dispatch_pm(pio_mgr);\r\nif (pio_mgr->intr_val == MBX_DEH_RESET) {\r\npio_mgr->intr_val = 0;\r\n} else {\r\nspin_lock_irqsave(&pio_mgr->dpc_lock, flags);\r\npio_mgr->dpc_req++;\r\nspin_unlock_irqrestore(&pio_mgr->dpc_lock, flags);\r\ntasklet_schedule(&pio_mgr->dpc_tasklet);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nvoid io_request_chnl(struct io_mgr *io_manager, struct chnl_object *pchnl,\r\nu8 io_mode, u16 *mbx_val)\r\n{\r\nstruct chnl_mgr *chnl_mgr_obj;\r\nstruct shm *sm;\r\nif (!pchnl || !mbx_val)\r\ngoto func_end;\r\nchnl_mgr_obj = io_manager->chnl_mgr;\r\nsm = io_manager->shared_mem;\r\nif (io_mode == IO_INPUT) {\r\nset_chnl_busy(sm, pchnl->chnl_id);\r\n*mbx_val = MBX_PCPY_CLASS;\r\n} else if (io_mode == IO_OUTPUT) {\r\nchnl_mgr_obj->output_mask |= (1 << pchnl->chnl_id);\r\n} else {\r\n}\r\nfunc_end:\r\nreturn;\r\n}\r\nvoid iosm_schedule(struct io_mgr *io_manager)\r\n{\r\nunsigned long flags;\r\nif (!io_manager)\r\nreturn;\r\nspin_lock_irqsave(&io_manager->dpc_lock, flags);\r\nio_manager->dpc_req++;\r\nspin_unlock_irqrestore(&io_manager->dpc_lock, flags);\r\ntasklet_schedule(&io_manager->dpc_tasklet);\r\n}\r\nstatic u32 find_ready_output(struct chnl_mgr *chnl_mgr_obj,\r\nstruct chnl_object *pchnl, u32 mask)\r\n{\r\nu32 ret = OUTPUTNOTREADY;\r\nu32 id, start_id;\r\nu32 shift;\r\nid = (pchnl !=\r\nNULL ? pchnl->chnl_id : (chnl_mgr_obj->last_output + 1));\r\nid = ((id == CHNL_MAXCHANNELS) ? 0 : id);\r\nif (id >= CHNL_MAXCHANNELS)\r\ngoto func_end;\r\nif (mask) {\r\nshift = (1 << id);\r\nstart_id = id;\r\ndo {\r\nif (mask & shift) {\r\nret = id;\r\nif (pchnl == NULL)\r\nchnl_mgr_obj->last_output = id;\r\nbreak;\r\n}\r\nid = id + 1;\r\nid = ((id == CHNL_MAXCHANNELS) ? 0 : id);\r\nshift = (1 << id);\r\n} while (id != start_id);\r\n}\r\nfunc_end:\r\nreturn ret;\r\n}\r\nstatic void input_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,\r\nu8 io_mode)\r\n{\r\nstruct chnl_mgr *chnl_mgr_obj;\r\nstruct shm *sm;\r\nu32 chnl_id;\r\nu32 bytes;\r\nstruct chnl_irp *chnl_packet_obj = NULL;\r\nu32 dw_arg;\r\nbool clear_chnl = false;\r\nbool notify_client = false;\r\nsm = pio_mgr->shared_mem;\r\nchnl_mgr_obj = pio_mgr->chnl_mgr;\r\nif (!sm->input_full)\r\ngoto func_end;\r\nbytes = sm->input_size * chnl_mgr_obj->word_size;\r\nchnl_id = sm->input_id;\r\ndw_arg = sm->arg;\r\nif (chnl_id >= CHNL_MAXCHANNELS) {\r\ngoto func_end;\r\n}\r\npchnl = chnl_mgr_obj->channels[chnl_id];\r\nif ((pchnl != NULL) && CHNL_IS_INPUT(pchnl->chnl_mode)) {\r\nif ((pchnl->state & ~CHNL_STATEEOS) == CHNL_STATEREADY) {\r\nif (!list_empty(&pchnl->io_requests)) {\r\nif (!pchnl->cio_reqs)\r\ngoto func_end;\r\nchnl_packet_obj = list_first_entry(\r\n&pchnl->io_requests,\r\nstruct chnl_irp, link);\r\nlist_del(&chnl_packet_obj->link);\r\npchnl->cio_reqs--;\r\nbytes = min(bytes, chnl_packet_obj->byte_size);\r\nmemcpy(chnl_packet_obj->host_sys_buf,\r\npio_mgr->input, bytes);\r\npchnl->bytes_moved += bytes;\r\nchnl_packet_obj->byte_size = bytes;\r\nchnl_packet_obj->arg = dw_arg;\r\nchnl_packet_obj->status = CHNL_IOCSTATCOMPLETE;\r\nif (bytes == 0) {\r\nif (pchnl->state & CHNL_STATEEOS)\r\ngoto func_end;\r\nchnl_packet_obj->status |=\r\nCHNL_IOCSTATEOS;\r\npchnl->state |= CHNL_STATEEOS;\r\nntfy_notify(pchnl->ntfy_obj,\r\nDSP_STREAMDONE);\r\n}\r\nif (list_empty(&pchnl->io_requests))\r\nset_chnl_free(sm, pchnl->chnl_id);\r\nclear_chnl = true;\r\nnotify_client = true;\r\n} else {\r\nclear_chnl = true;\r\n}\r\n} else {\r\nclear_chnl = true;\r\n}\r\n} else {\r\nclear_chnl = true;\r\n}\r\nif (clear_chnl) {\r\nsm->input_full = 0;\r\nsm_interrupt_dsp(pio_mgr->bridge_context, MBX_PCPY_CLASS);\r\n}\r\nif (notify_client) {\r\nnotify_chnl_complete(pchnl, chnl_packet_obj);\r\n}\r\nfunc_end:\r\nreturn;\r\n}\r\nstatic void input_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr)\r\n{\r\nu32 num_msgs;\r\nu32 i;\r\nu8 *msg_input;\r\nstruct msg_queue *msg_queue_obj;\r\nstruct msg_frame *pmsg;\r\nstruct msg_dspmsg msg;\r\nstruct msg_ctrl *msg_ctr_obj;\r\nu32 input_empty;\r\nu32 addr;\r\nmsg_ctr_obj = pio_mgr->msg_input_ctrl;\r\ninput_empty = msg_ctr_obj->buf_empty;\r\nnum_msgs = msg_ctr_obj->size;\r\nif (input_empty)\r\nreturn;\r\nmsg_input = pio_mgr->msg_input;\r\nfor (i = 0; i < num_msgs; i++) {\r\naddr = (u32) &(((struct msg_dspmsg *)msg_input)->msg.cmd);\r\nmsg.msg.cmd =\r\nread_ext32_bit_dsp_data(pio_mgr->bridge_context, addr);\r\naddr = (u32) &(((struct msg_dspmsg *)msg_input)->msg.arg1);\r\nmsg.msg.arg1 =\r\nread_ext32_bit_dsp_data(pio_mgr->bridge_context, addr);\r\naddr = (u32) &(((struct msg_dspmsg *)msg_input)->msg.arg2);\r\nmsg.msg.arg2 =\r\nread_ext32_bit_dsp_data(pio_mgr->bridge_context, addr);\r\naddr = (u32) &(((struct msg_dspmsg *)msg_input)->msgq_id);\r\nmsg.msgq_id =\r\nread_ext32_bit_dsp_data(pio_mgr->bridge_context, addr);\r\nmsg_input += sizeof(struct msg_dspmsg);\r\ndev_dbg(bridge, "input msg: cmd=0x%x arg1=0x%x "\r\n"arg2=0x%x msgq_id=0x%x\n", msg.msg.cmd,\r\nmsg.msg.arg1, msg.msg.arg2, msg.msgq_id);\r\nlist_for_each_entry(msg_queue_obj, &hmsg_mgr->queue_list,\r\nlist_elem) {\r\nif (msg.msgq_id != msg_queue_obj->msgq_id)\r\ncontinue;\r\nif (msg.msg.cmd == RMS_EXITACK) {\r\n(*hmsg_mgr->on_exit)(msg_queue_obj->arg,\r\nmsg.msg.arg1);\r\nbreak;\r\n}\r\nif (list_empty(&msg_queue_obj->msg_free_list)) {\r\npr_err("%s: no free msg frames,"\r\n" discarding msg\n",\r\n__func__);\r\nbreak;\r\n}\r\npmsg = list_first_entry(&msg_queue_obj->msg_free_list,\r\nstruct msg_frame, list_elem);\r\nlist_del(&pmsg->list_elem);\r\npmsg->msg_data = msg;\r\nlist_add_tail(&pmsg->list_elem,\r\n&msg_queue_obj->msg_used_list);\r\nntfy_notify(msg_queue_obj->ntfy_obj,\r\nDSP_NODEMESSAGEREADY);\r\nsync_set_event(msg_queue_obj->sync_event);\r\n}\r\n}\r\nif (num_msgs > 0) {\r\nmsg_ctr_obj->buf_empty = true;\r\nmsg_ctr_obj->post_swi = true;\r\nsm_interrupt_dsp(pio_mgr->bridge_context, MBX_PCPY_CLASS);\r\n}\r\n}\r\nstatic void notify_chnl_complete(struct chnl_object *pchnl,\r\nstruct chnl_irp *chnl_packet_obj)\r\n{\r\nbool signal_event;\r\nif (!pchnl || !pchnl->sync_event || !chnl_packet_obj)\r\ngoto func_end;\r\nsignal_event = list_empty(&pchnl->io_completions);\r\nlist_add_tail(&chnl_packet_obj->link, &pchnl->io_completions);\r\npchnl->cio_cs++;\r\nif (pchnl->cio_cs > pchnl->chnl_packets)\r\ngoto func_end;\r\nif (signal_event)\r\nsync_set_event(pchnl->sync_event);\r\nntfy_notify(pchnl->ntfy_obj, DSP_STREAMIOCOMPLETION);\r\nfunc_end:\r\nreturn;\r\n}\r\nstatic void output_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,\r\nu8 io_mode)\r\n{\r\nstruct chnl_mgr *chnl_mgr_obj;\r\nstruct shm *sm;\r\nu32 chnl_id;\r\nstruct chnl_irp *chnl_packet_obj;\r\nu32 dw_dsp_f_mask;\r\nchnl_mgr_obj = pio_mgr->chnl_mgr;\r\nsm = pio_mgr->shared_mem;\r\nif (sm->output_full)\r\ngoto func_end;\r\nif (pchnl && !((pchnl->state & ~CHNL_STATEEOS) == CHNL_STATEREADY))\r\ngoto func_end;\r\ndw_dsp_f_mask = sm->dsp_free_mask;\r\nchnl_id =\r\nfind_ready_output(chnl_mgr_obj, pchnl,\r\n(chnl_mgr_obj->output_mask & dw_dsp_f_mask));\r\nif (chnl_id == OUTPUTNOTREADY)\r\ngoto func_end;\r\npchnl = chnl_mgr_obj->channels[chnl_id];\r\nif (!pchnl || list_empty(&pchnl->io_requests)) {\r\ngoto func_end;\r\n}\r\nif (!pchnl->cio_reqs)\r\ngoto func_end;\r\nchnl_packet_obj = list_first_entry(&pchnl->io_requests,\r\nstruct chnl_irp, link);\r\nlist_del(&chnl_packet_obj->link);\r\npchnl->cio_reqs--;\r\nif (list_empty(&pchnl->io_requests))\r\nchnl_mgr_obj->output_mask &= ~(1 << chnl_id);\r\nchnl_packet_obj->byte_size = min(pio_mgr->sm_buf_size,\r\nchnl_packet_obj->byte_size);\r\nmemcpy(pio_mgr->output, chnl_packet_obj->host_sys_buf,\r\nchnl_packet_obj->byte_size);\r\npchnl->bytes_moved += chnl_packet_obj->byte_size;\r\nsm->arg = chnl_packet_obj->arg;\r\n#if _CHNL_WORDSIZE == 2\r\nsm->output_id = (u16) chnl_id;\r\nsm->output_size = (u16) (chnl_packet_obj->byte_size +\r\nchnl_mgr_obj->word_size - 1) /\r\n(u16) chnl_mgr_obj->word_size;\r\n#else\r\nsm->output_id = chnl_id;\r\nsm->output_size = (chnl_packet_obj->byte_size +\r\nchnl_mgr_obj->word_size - 1) / chnl_mgr_obj->word_size;\r\n#endif\r\nsm->output_full = 1;\r\nsm_interrupt_dsp(pio_mgr->bridge_context, MBX_PCPY_CLASS);\r\nchnl_packet_obj->status &= CHNL_IOCSTATEOS;\r\nnotify_chnl_complete(pchnl, chnl_packet_obj);\r\nif (chnl_packet_obj->status & CHNL_IOCSTATEOS)\r\nntfy_notify(pchnl->ntfy_obj, DSP_STREAMDONE);\r\nfunc_end:\r\nreturn;\r\n}\r\nstatic void output_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr)\r\n{\r\nu32 num_msgs = 0;\r\nu32 i;\r\nstruct msg_dspmsg *msg_output;\r\nstruct msg_frame *pmsg;\r\nstruct msg_ctrl *msg_ctr_obj;\r\nu32 val;\r\nu32 addr;\r\nmsg_ctr_obj = pio_mgr->msg_output_ctrl;\r\nif (!msg_ctr_obj->buf_empty)\r\nreturn;\r\nnum_msgs = (hmsg_mgr->msgs_pending > hmsg_mgr->max_msgs) ?\r\nhmsg_mgr->max_msgs : hmsg_mgr->msgs_pending;\r\nmsg_output = (struct msg_dspmsg *) pio_mgr->msg_output;\r\nfor (i = 0; i < num_msgs; i++) {\r\nif (list_empty(&hmsg_mgr->msg_used_list))\r\ncontinue;\r\npmsg = list_first_entry(&hmsg_mgr->msg_used_list,\r\nstruct msg_frame, list_elem);\r\nlist_del(&pmsg->list_elem);\r\nval = (pmsg->msg_data).msgq_id;\r\naddr = (u32) &msg_output->msgq_id;\r\nwrite_ext32_bit_dsp_data(pio_mgr->bridge_context, addr, val);\r\nval = (pmsg->msg_data).msg.cmd;\r\naddr = (u32) &msg_output->msg.cmd;\r\nwrite_ext32_bit_dsp_data(pio_mgr->bridge_context, addr, val);\r\nval = (pmsg->msg_data).msg.arg1;\r\naddr = (u32) &msg_output->msg.arg1;\r\nwrite_ext32_bit_dsp_data(pio_mgr->bridge_context, addr, val);\r\nval = (pmsg->msg_data).msg.arg2;\r\naddr = (u32) &msg_output->msg.arg2;\r\nwrite_ext32_bit_dsp_data(pio_mgr->bridge_context, addr, val);\r\nmsg_output++;\r\nlist_add_tail(&pmsg->list_elem, &hmsg_mgr->msg_free_list);\r\nsync_set_event(hmsg_mgr->sync_event);\r\n}\r\nif (num_msgs > 0) {\r\nhmsg_mgr->msgs_pending -= num_msgs;\r\n#if _CHNL_WORDSIZE == 2\r\nmsg_ctr_obj->size = (u16) num_msgs;\r\n#else\r\nmsg_ctr_obj->size = num_msgs;\r\n#endif\r\nmsg_ctr_obj->buf_empty = false;\r\nmsg_ctr_obj->post_swi = true;\r\nsm_interrupt_dsp(pio_mgr->bridge_context, MBX_PCPY_CLASS);\r\n}\r\n}\r\nstatic int register_shm_segs(struct io_mgr *hio_mgr,\r\nstruct cod_manager *cod_man,\r\nu32 dw_gpp_base_pa)\r\n{\r\nint status = 0;\r\nu32 ul_shm0_base = 0;\r\nu32 shm0_end = 0;\r\nu32 ul_shm0_rsrvd_start = 0;\r\nu32 ul_rsrvd_size = 0;\r\nu32 ul_gpp_phys;\r\nu32 ul_dsp_virt;\r\nu32 ul_shm_seg_id0 = 0;\r\nu32 dw_offset, dw_gpp_base_va, ul_dsp_size;\r\nstatus =\r\ncod_get_sym_value(cod_man, SHM0_SHARED_BASE_SYM, &ul_shm0_base);\r\nif (ul_shm0_base == 0) {\r\nstatus = -EPERM;\r\ngoto func_end;\r\n}\r\nif (!status) {\r\nstatus = cod_get_sym_value(cod_man, SHM0_SHARED_END_SYM,\r\n&shm0_end);\r\nif (shm0_end == 0) {\r\nstatus = -EPERM;\r\ngoto func_end;\r\n}\r\n}\r\nif (!status) {\r\nstatus =\r\ncod_get_sym_value(cod_man, SHM0_SHARED_RESERVED_BASE_SYM,\r\n&ul_shm0_rsrvd_start);\r\nif (ul_shm0_rsrvd_start == 0) {\r\nstatus = -EPERM;\r\ngoto func_end;\r\n}\r\n}\r\nif (!status) {\r\nstatus = dev_get_cmm_mgr(hio_mgr->dev_obj, &hio_mgr->cmm_mgr);\r\nif (!status) {\r\nstatus = cmm_un_register_gppsm_seg(hio_mgr->cmm_mgr,\r\nCMM_ALLSEGMENTS);\r\n}\r\n}\r\nif (!status && (shm0_end - ul_shm0_base) > 0) {\r\nul_rsrvd_size =\r\n(shm0_end - ul_shm0_rsrvd_start + 1) * hio_mgr->word_size;\r\nif (ul_rsrvd_size <= 0) {\r\nstatus = -EPERM;\r\ngoto func_end;\r\n}\r\nul_dsp_size =\r\n(ul_shm0_rsrvd_start - ul_shm0_base) * hio_mgr->word_size;\r\nif (ul_dsp_size <= 0) {\r\nstatus = -EPERM;\r\ngoto func_end;\r\n}\r\nul_gpp_phys = hio_mgr->ext_proc_info.ty_tlb[0].gpp_phys;\r\nul_dsp_virt =\r\nhio_mgr->ext_proc_info.ty_tlb[0].dsp_virt *\r\nhio_mgr->word_size;\r\nif (dw_gpp_base_pa > ul_dsp_virt)\r\ndw_offset = dw_gpp_base_pa - ul_dsp_virt;\r\nelse\r\ndw_offset = ul_dsp_virt - dw_gpp_base_pa;\r\nif (ul_shm0_rsrvd_start * hio_mgr->word_size < ul_dsp_virt) {\r\nstatus = -EPERM;\r\ngoto func_end;\r\n}\r\ndw_gpp_base_va =\r\nul_gpp_phys + ul_shm0_rsrvd_start * hio_mgr->word_size -\r\nul_dsp_virt;\r\ndw_gpp_base_pa =\r\ndw_gpp_base_pa + ul_shm0_rsrvd_start * hio_mgr->word_size -\r\nul_dsp_virt;\r\nstatus =\r\ncmm_register_gppsm_seg(hio_mgr->cmm_mgr, dw_gpp_base_pa,\r\nul_rsrvd_size, dw_offset,\r\n(dw_gpp_base_pa >\r\nul_dsp_virt) ? CMM_ADDTODSPPA :\r\nCMM_SUBFROMDSPPA,\r\n(u32) (ul_shm0_base *\r\nhio_mgr->word_size),\r\nul_dsp_size, &ul_shm_seg_id0,\r\ndw_gpp_base_va);\r\nif (ul_shm_seg_id0 != 1)\r\nstatus = -EPERM;\r\n}\r\nfunc_end:\r\nreturn status;\r\n}\r\nint io_sh_msetting(struct io_mgr *hio_mgr, u8 desc, void *pargs)\r\n{\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\nu32 i;\r\nstruct dspbridge_platform_data *pdata =\r\nomap_dspbridge_dev->dev.platform_data;\r\nswitch (desc) {\r\ncase SHM_CURROPP:\r\nif (pargs != NULL)\r\nhio_mgr->shared_mem->opp_table_struct.curr_opp_pt =\r\n*(u32 *) pargs;\r\nelse\r\nreturn -EPERM;\r\nbreak;\r\ncase SHM_OPPINFO:\r\nfor (i = 0; i <= dsp_max_opps; i++) {\r\nhio_mgr->shared_mem->opp_table_struct.opp_point[i].\r\nvoltage = vdd1_dsp_freq[i][0];\r\ndev_dbg(bridge, "OPP-shm: voltage: %d\n",\r\nvdd1_dsp_freq[i][0]);\r\nhio_mgr->shared_mem->opp_table_struct.\r\nopp_point[i].frequency = vdd1_dsp_freq[i][1];\r\ndev_dbg(bridge, "OPP-shm: frequency: %d\n",\r\nvdd1_dsp_freq[i][1]);\r\nhio_mgr->shared_mem->opp_table_struct.opp_point[i].\r\nmin_freq = vdd1_dsp_freq[i][2];\r\ndev_dbg(bridge, "OPP-shm: min freq: %d\n",\r\nvdd1_dsp_freq[i][2]);\r\nhio_mgr->shared_mem->opp_table_struct.opp_point[i].\r\nmax_freq = vdd1_dsp_freq[i][3];\r\ndev_dbg(bridge, "OPP-shm: max freq: %d\n",\r\nvdd1_dsp_freq[i][3]);\r\n}\r\nhio_mgr->shared_mem->opp_table_struct.num_opp_pts =\r\ndsp_max_opps;\r\ndev_dbg(bridge, "OPP-shm: max OPP number: %d\n", dsp_max_opps);\r\nif (pdata->dsp_get_opp)\r\ni = (*pdata->dsp_get_opp) ();\r\nhio_mgr->shared_mem->opp_table_struct.curr_opp_pt = i;\r\ndev_dbg(bridge, "OPP-shm: value programmed = %d\n", i);\r\nbreak;\r\ncase SHM_GETOPP:\r\n*(u32 *) pargs = hio_mgr->shared_mem->opp_request.rqst_opp_pt;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint bridge_io_get_proc_load(struct io_mgr *hio_mgr,\r\nstruct dsp_procloadstat *proc_lstat)\r\n{\r\nif (!hio_mgr->shared_mem)\r\nreturn -EFAULT;\r\nproc_lstat->curr_load =\r\nhio_mgr->shared_mem->load_mon_info.curr_dsp_load;\r\nproc_lstat->predicted_load =\r\nhio_mgr->shared_mem->load_mon_info.pred_dsp_load;\r\nproc_lstat->curr_dsp_freq =\r\nhio_mgr->shared_mem->load_mon_info.curr_dsp_freq;\r\nproc_lstat->predicted_freq =\r\nhio_mgr->shared_mem->load_mon_info.pred_dsp_freq;\r\ndev_dbg(bridge, "Curr Load = %d, Pred Load = %d, Curr Freq = %d, "\r\n"Pred Freq = %d\n", proc_lstat->curr_load,\r\nproc_lstat->predicted_load, proc_lstat->curr_dsp_freq,\r\nproc_lstat->predicted_freq);\r\nreturn 0;\r\n}\r\nvoid print_dsp_debug_trace(struct io_mgr *hio_mgr)\r\n{\r\nu32 ul_new_message_length = 0, ul_gpp_cur_pointer;\r\nwhile (true) {\r\nul_gpp_cur_pointer =\r\n*(u32 *) (hio_mgr->trace_buffer_current);\r\nul_gpp_cur_pointer =\r\nhio_mgr->gpp_va + (ul_gpp_cur_pointer -\r\nhio_mgr->dsp_va);\r\nif (ul_gpp_cur_pointer == hio_mgr->gpp_read_pointer) {\r\nbreak;\r\n} else if (ul_gpp_cur_pointer > hio_mgr->gpp_read_pointer) {\r\nul_new_message_length =\r\nul_gpp_cur_pointer - hio_mgr->gpp_read_pointer;\r\nmemcpy(hio_mgr->msg,\r\n(char *)hio_mgr->gpp_read_pointer,\r\nul_new_message_length);\r\nhio_mgr->msg[ul_new_message_length] = '\0';\r\nhio_mgr->gpp_read_pointer += ul_new_message_length;\r\npr_info("DSPTrace: %s\n", hio_mgr->msg);\r\n} else if (ul_gpp_cur_pointer < hio_mgr->gpp_read_pointer) {\r\nmemcpy(hio_mgr->msg,\r\n(char *)hio_mgr->gpp_read_pointer,\r\nhio_mgr->trace_buffer_end -\r\nhio_mgr->gpp_read_pointer);\r\nul_new_message_length =\r\nul_gpp_cur_pointer - hio_mgr->trace_buffer_begin;\r\nmemcpy(&hio_mgr->msg[hio_mgr->trace_buffer_end -\r\nhio_mgr->gpp_read_pointer],\r\n(char *)hio_mgr->trace_buffer_begin,\r\nul_new_message_length);\r\nhio_mgr->msg[hio_mgr->trace_buffer_end -\r\nhio_mgr->gpp_read_pointer +\r\nul_new_message_length] = '\0';\r\nhio_mgr->gpp_read_pointer =\r\nhio_mgr->trace_buffer_begin +\r\nul_new_message_length;\r\npr_info("DSPTrace: %s\n", hio_mgr->msg);\r\n}\r\n}\r\n}\r\nint print_dsp_trace_buffer(struct bridge_dev_context *hbridge_context)\r\n{\r\nint status = 0;\r\nstruct cod_manager *cod_mgr;\r\nu32 ul_trace_end;\r\nu32 ul_trace_begin;\r\nu32 trace_cur_pos;\r\nu32 ul_num_bytes = 0;\r\nu32 ul_num_words = 0;\r\nu32 ul_word_size = 2;\r\nchar *psz_buf;\r\nchar *str_beg;\r\nchar *trace_end;\r\nchar *buf_end;\r\nchar *new_line;\r\nstruct bridge_dev_context *pbridge_context = hbridge_context;\r\nstruct bridge_drv_interface *intf_fxns;\r\nstruct dev_object *dev_obj = (struct dev_object *)\r\npbridge_context->dev_obj;\r\nstatus = dev_get_cod_mgr(dev_obj, &cod_mgr);\r\nif (cod_mgr) {\r\nstatus =\r\ncod_get_sym_value(cod_mgr, COD_TRACEBEG, &ul_trace_begin);\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nif (!status)\r\nstatus =\r\ncod_get_sym_value(cod_mgr, COD_TRACEEND, &ul_trace_end);\r\nif (!status)\r\nstatus = cod_get_sym_value(cod_mgr, COD_TRACECURPOS,\r\n&trace_cur_pos);\r\nif (status)\r\ngoto func_end;\r\nul_num_bytes = (ul_trace_end - ul_trace_begin);\r\nul_num_words = ul_num_bytes * ul_word_size;\r\nstatus = dev_get_intf_fxns(dev_obj, &intf_fxns);\r\nif (status)\r\ngoto func_end;\r\npsz_buf = kzalloc(ul_num_bytes + 2, GFP_ATOMIC);\r\nif (psz_buf != NULL) {\r\nstatus = (*intf_fxns->brd_read)(pbridge_context,\r\n(u8 *)psz_buf, (u32)ul_trace_begin,\r\nul_num_bytes, 0);\r\nif (status)\r\ngoto func_end;\r\npr_debug("PrintDspTraceBuffer: "\r\n"before pack and unpack.\n");\r\npr_debug("%s: DSP Trace Buffer Begin:\n"\r\n"=======================\n%s\n",\r\n__func__, psz_buf);\r\nstatus = (*intf_fxns->brd_read)(pbridge_context,\r\n(u8 *)&trace_cur_pos, (u32)trace_cur_pos,\r\n4, 0);\r\nif (status)\r\ngoto func_end;\r\npr_info("DSP Trace Buffer Begin:\n"\r\n"=======================\n%s\n",\r\npsz_buf);\r\ntrace_cur_pos = trace_cur_pos - ul_trace_begin;\r\nif (ul_num_bytes) {\r\nbuf_end = &psz_buf[ul_num_bytes+1];\r\ntrace_end = &psz_buf[trace_cur_pos];\r\nstr_beg = trace_end;\r\nul_num_bytes = buf_end - str_beg;\r\nwhile (str_beg < buf_end) {\r\nnew_line = strnchr(str_beg, ul_num_bytes,\r\n'\n');\r\nif (new_line && new_line < buf_end) {\r\n*new_line = 0;\r\npr_debug("%s\n", str_beg);\r\nstr_beg = ++new_line;\r\nul_num_bytes = buf_end - str_beg;\r\n} else {\r\nif (*str_beg != '\0') {\r\nstr_beg[ul_num_bytes] = 0;\r\npr_debug("%s\n", str_beg);\r\n}\r\nstr_beg = buf_end;\r\nul_num_bytes = 0;\r\n}\r\n}\r\nstr_beg = psz_buf;\r\nul_num_bytes = trace_end - str_beg;\r\nwhile (str_beg < trace_end) {\r\nnew_line = strnchr(str_beg, ul_num_bytes, '\n');\r\nif (new_line != NULL && new_line < trace_end) {\r\n*new_line = 0;\r\npr_debug("%s\n", str_beg);\r\nstr_beg = ++new_line;\r\nul_num_bytes = trace_end - str_beg;\r\n} else {\r\nif (*str_beg != '\0') {\r\nstr_beg[ul_num_bytes] = 0;\r\npr_debug("%s\n", str_beg);\r\n}\r\nstr_beg = trace_end;\r\nul_num_bytes = 0;\r\n}\r\n}\r\n}\r\npr_info("\n=======================\n"\r\n"DSP Trace Buffer End:\n");\r\nkfree(psz_buf);\r\n} else {\r\nstatus = -ENOMEM;\r\n}\r\nfunc_end:\r\nif (status)\r\ndev_dbg(bridge, "%s Failed, status 0x%x\n", __func__, status);\r\nreturn status;\r\n}\r\nint dump_dsp_stack(struct bridge_dev_context *bridge_context)\r\n{\r\nint status = 0;\r\nstruct cod_manager *code_mgr;\r\nstruct node_mgr *node_mgr;\r\nu32 trace_begin;\r\nchar name[256];\r\nstruct {\r\nu32 head[2];\r\nu32 size;\r\n} mmu_fault_dbg_info;\r\nu32 *buffer;\r\nu32 *buffer_beg;\r\nu32 *buffer_end;\r\nu32 exc_type;\r\nu32 dyn_ext_base;\r\nu32 i;\r\nu32 offset_output;\r\nu32 total_size;\r\nu32 poll_cnt;\r\nconst char *dsp_regs[] = {"EFR", "IERR", "ITSR", "NTSR",\r\n"IRP", "NRP", "AMR", "SSR",\r\n"ILC", "RILC", "IER", "CSR"};\r\nconst char *exec_ctxt[] = {"Task", "SWI", "HWI", "Unknown"};\r\nstruct bridge_drv_interface *intf_fxns;\r\nstruct dev_object *dev_object = bridge_context->dev_obj;\r\nstatus = dev_get_cod_mgr(dev_object, &code_mgr);\r\nif (!code_mgr) {\r\npr_debug("%s: Failed on dev_get_cod_mgr.\n", __func__);\r\nstatus = -EFAULT;\r\n}\r\nif (!status) {\r\nstatus = dev_get_node_manager(dev_object, &node_mgr);\r\nif (!node_mgr) {\r\npr_debug("%s: Failed on dev_get_node_manager.\n",\r\n__func__);\r\nstatus = -EFAULT;\r\n}\r\n}\r\nif (!status) {\r\nstatus =\r\ncod_get_sym_value(code_mgr, COD_TRACEBEG, &trace_begin);\r\npr_debug("%s: trace_begin Value 0x%x\n",\r\n__func__, trace_begin);\r\nif (status)\r\npr_debug("%s: Failed on cod_get_sym_value.\n",\r\n__func__);\r\n}\r\nif (!status)\r\nstatus = dev_get_intf_fxns(dev_object, &intf_fxns);\r\nmmu_fault_dbg_info.head[0] = 0;\r\nmmu_fault_dbg_info.head[1] = 0;\r\nif (!status) {\r\npoll_cnt = 0;\r\nwhile ((mmu_fault_dbg_info.head[0] != MMU_FAULT_HEAD1 ||\r\nmmu_fault_dbg_info.head[1] != MMU_FAULT_HEAD2) &&\r\npoll_cnt < POLL_MAX) {\r\nstatus = (*intf_fxns->brd_read)(bridge_context,\r\n(u8 *)&mmu_fault_dbg_info, (u32)trace_begin,\r\nsizeof(mmu_fault_dbg_info), 0);\r\nif (status)\r\nbreak;\r\npoll_cnt++;\r\n}\r\nif (mmu_fault_dbg_info.head[0] != MMU_FAULT_HEAD1 &&\r\nmmu_fault_dbg_info.head[1] != MMU_FAULT_HEAD2) {\r\nstatus = -ETIME;\r\npr_err("%s:No DSP MMU-Fault information available.\n",\r\n__func__);\r\n}\r\n}\r\nif (!status) {\r\ntotal_size = mmu_fault_dbg_info.size;\r\nif (total_size > MAX_MMU_DBGBUFF)\r\ntotal_size = MAX_MMU_DBGBUFF;\r\nbuffer = kzalloc(total_size, GFP_ATOMIC);\r\nif (!buffer) {\r\nstatus = -ENOMEM;\r\npr_debug("%s: Failed to "\r\n"allocate stack dump buffer.\n", __func__);\r\ngoto func_end;\r\n}\r\nbuffer_beg = buffer;\r\nbuffer_end = buffer + total_size / 4;\r\nstatus = (*intf_fxns->brd_read)(bridge_context,\r\n(u8 *)buffer, (u32)trace_begin,\r\ntotal_size, 0);\r\nif (status) {\r\npr_debug("%s: Failed to Read Trace Buffer.\n",\r\n__func__);\r\ngoto func_end;\r\n}\r\npr_err("\nAproximate Crash Position:\n"\r\n"--------------------------\n");\r\nexc_type = buffer[3];\r\nif (!exc_type)\r\ni = buffer[79];\r\nelse\r\ni = buffer[80];\r\nstatus =\r\ncod_get_sym_value(code_mgr, DYNEXTBASE, &dyn_ext_base);\r\nif (status) {\r\nstatus = -EFAULT;\r\ngoto func_end;\r\n}\r\nif ((i > dyn_ext_base) && (node_find_addr(node_mgr, i,\r\n0x1000, &offset_output, name) == 0))\r\npr_err("0x%-8x [\"%s\" + 0x%x]\n", i, name,\r\ni - offset_output);\r\nelse\r\npr_err("0x%-8x [Unable to match to a symbol.]\n", i);\r\nbuffer += 4;\r\npr_err("\nExecution Info:\n"\r\n"---------------\n");\r\nif (*buffer < ARRAY_SIZE(exec_ctxt)) {\r\npr_err("Execution context \t%s\n",\r\nexec_ctxt[*buffer++]);\r\n} else {\r\npr_err("Execution context corrupt\n");\r\nkfree(buffer_beg);\r\nreturn -EFAULT;\r\n}\r\npr_err("Task Handle\t\t0x%x\n", *buffer++);\r\npr_err("Stack Pointer\t\t0x%x\n", *buffer++);\r\npr_err("Stack Top\t\t0x%x\n", *buffer++);\r\npr_err("Stack Bottom\t\t0x%x\n", *buffer++);\r\npr_err("Stack Size\t\t0x%x\n", *buffer++);\r\npr_err("Stack Size In Use\t0x%x\n", *buffer++);\r\npr_err("\nCPU Registers\n"\r\n"---------------\n");\r\nfor (i = 0; i < 32; i++) {\r\nif (i == 4 || i == 6 || i == 8)\r\npr_err("A%d 0x%-8x [Function Argument %d]\n",\r\ni, *buffer++, i-3);\r\nelse if (i == 15)\r\npr_err("A15 0x%-8x [Frame Pointer]\n",\r\n*buffer++);\r\nelse\r\npr_err("A%d 0x%x\n", i, *buffer++);\r\n}\r\npr_err("\nB0 0x%x\n", *buffer++);\r\npr_err("B1 0x%x\n", *buffer++);\r\npr_err("B2 0x%x\n", *buffer++);\r\nif ((*buffer > dyn_ext_base) && (node_find_addr(node_mgr,\r\n*buffer, 0x1000, &offset_output, name) == 0))\r\npr_err("B3 0x%-8x [Function Return Pointer:"\r\n" \"%s\" + 0x%x]\n", *buffer, name,\r\n*buffer - offset_output);\r\nelse\r\npr_err("B3 0x%-8x [Function Return Pointer:"\r\n"Unable to match to a symbol.]\n", *buffer);\r\nbuffer++;\r\nfor (i = 4; i < 32; i++) {\r\nif (i == 4 || i == 6 || i == 8)\r\npr_err("B%d 0x%-8x [Function Argument %d]\n",\r\ni, *buffer++, i-2);\r\nelse if (i == 14)\r\npr_err("B14 0x%-8x [Data Page Pointer]\n",\r\n*buffer++);\r\nelse\r\npr_err("B%d 0x%x\n", i, *buffer++);\r\n}\r\npr_err("\n");\r\nfor (i = 0; i < ARRAY_SIZE(dsp_regs); i++)\r\npr_err("%s 0x%x\n", dsp_regs[i], *buffer++);\r\npr_err("\nStack:\n"\r\n"------\n");\r\nfor (i = 0; buffer < buffer_end; i++, buffer++) {\r\nif ((*buffer > dyn_ext_base) && (\r\nnode_find_addr(node_mgr, *buffer , 0x600,\r\n&offset_output, name) == 0))\r\npr_err("[%d] 0x%-8x [\"%s\" + 0x%x]\n",\r\ni, *buffer, name,\r\n*buffer - offset_output);\r\nelse\r\npr_err("[%d] 0x%x\n", i, *buffer);\r\n}\r\nkfree(buffer_beg);\r\n}\r\nfunc_end:\r\nreturn status;\r\n}\r\nvoid dump_dl_modules(struct bridge_dev_context *bridge_context)\r\n{\r\nstruct cod_manager *code_mgr;\r\nstruct bridge_drv_interface *intf_fxns;\r\nstruct bridge_dev_context *bridge_ctxt = bridge_context;\r\nstruct dev_object *dev_object = bridge_ctxt->dev_obj;\r\nstruct modules_header modules_hdr;\r\nstruct dll_module *module_struct = NULL;\r\nu32 module_dsp_addr;\r\nu32 module_size;\r\nu32 module_struct_size = 0;\r\nu32 sect_ndx;\r\nchar *sect_str;\r\nint status = 0;\r\nstatus = dev_get_intf_fxns(dev_object, &intf_fxns);\r\nif (status) {\r\npr_debug("%s: Failed on dev_get_intf_fxns.\n", __func__);\r\ngoto func_end;\r\n}\r\nstatus = dev_get_cod_mgr(dev_object, &code_mgr);\r\nif (!code_mgr) {\r\npr_debug("%s: Failed on dev_get_cod_mgr.\n", __func__);\r\nstatus = -EFAULT;\r\ngoto func_end;\r\n}\r\nstatus = cod_get_sym_value(code_mgr, "_DLModules", &module_dsp_addr);\r\nif (status) {\r\npr_debug("%s: Failed on cod_get_sym_value for _DLModules.\n",\r\n__func__);\r\ngoto func_end;\r\n}\r\npr_debug("%s: _DLModules at 0x%x\n", __func__, module_dsp_addr);\r\nstatus = (*intf_fxns->brd_read)(bridge_context, (u8 *) &modules_hdr,\r\n(u32) module_dsp_addr, sizeof(modules_hdr), 0);\r\nif (status) {\r\npr_debug("%s: Failed failed to read modules header.\n",\r\n__func__);\r\ngoto func_end;\r\n}\r\nmodule_dsp_addr = modules_hdr.first_module;\r\nmodule_size = modules_hdr.first_module_size;\r\npr_debug("%s: dll_module_header 0x%x %d\n", __func__, module_dsp_addr,\r\nmodule_size);\r\npr_err("\nDynamically Loaded Modules:\n"\r\n"---------------------------\n");\r\nwhile (module_size) {\r\nif (module_size > module_struct_size) {\r\nkfree(module_struct);\r\nmodule_struct = kzalloc(module_size+128, GFP_ATOMIC);\r\nmodule_struct_size = module_size+128;\r\npr_debug("%s: allocated module struct %p %d\n",\r\n__func__, module_struct, module_struct_size);\r\nif (!module_struct)\r\ngoto func_end;\r\n}\r\nstatus = (*intf_fxns->brd_read)(bridge_context,\r\n(u8 *)module_struct, module_dsp_addr, module_size, 0);\r\nif (status) {\r\npr_debug(\r\n"%s: Failed to read dll_module struct for 0x%x.\n",\r\n__func__, module_dsp_addr);\r\nbreak;\r\n}\r\nmodule_dsp_addr = module_struct->next_module;\r\nmodule_size = module_struct->next_module_size;\r\npr_debug("%s: next module 0x%x %d, this module num sects %d\n",\r\n__func__, module_dsp_addr, module_size,\r\nmodule_struct->num_sects);\r\nsect_str = (char *) &module_struct->\r\nsects[module_struct->num_sects];\r\npr_err("%s\n", sect_str);\r\nsect_str += strlen(sect_str) + 1;\r\nfor (sect_ndx = 0;\r\nsect_ndx < module_struct->num_sects; sect_ndx++) {\r\npr_err(" Section: 0x%x ",\r\nmodule_struct->sects[sect_ndx].sect_load_adr);\r\nif (((u32) sect_str - (u32) module_struct) <\r\nmodule_struct_size) {\r\npr_err("%s\n", sect_str);\r\nsect_str += strlen(sect_str)+1;\r\n} else {\r\npr_err("<string error>\n");\r\npr_debug("%s: section name sting address "\r\n"is invalid %p\n", __func__, sect_str);\r\n}\r\n}\r\n}\r\nfunc_end:\r\nkfree(module_struct);\r\n}
