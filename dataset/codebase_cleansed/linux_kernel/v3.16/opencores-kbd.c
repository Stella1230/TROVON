static irqreturn_t opencores_kbd_isr(int irq, void *dev_id)\r\n{\r\nstruct opencores_kbd *opencores_kbd = dev_id;\r\nstruct input_dev *input = opencores_kbd->input;\r\nunsigned char c;\r\nc = readb(opencores_kbd->addr);\r\ninput_report_key(input, c & 0x7f, c & 0x80 ? 0 : 1);\r\ninput_sync(input);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int opencores_kbd_probe(struct platform_device *pdev)\r\n{\r\nstruct input_dev *input;\r\nstruct opencores_kbd *opencores_kbd;\r\nstruct resource *res;\r\nint irq, i, error;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "missing board memory resource\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "missing board IRQ resource\n");\r\nreturn -EINVAL;\r\n}\r\nopencores_kbd = kzalloc(sizeof(*opencores_kbd), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!opencores_kbd || !input) {\r\ndev_err(&pdev->dev, "failed to allocate device structures\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nopencores_kbd->addr_res = res;\r\nres = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to request I/O memory\n");\r\nerror = -EBUSY;\r\ngoto err_free_mem;\r\n}\r\nopencores_kbd->addr = ioremap(res->start, resource_size(res));\r\nif (!opencores_kbd->addr) {\r\ndev_err(&pdev->dev, "failed to remap I/O memory\n");\r\nerror = -ENXIO;\r\ngoto err_rel_mem;\r\n}\r\nopencores_kbd->input = input;\r\nopencores_kbd->irq = irq;\r\ninput->name = pdev->name;\r\ninput->phys = "opencores-kbd/input0";\r\ninput->dev.parent = &pdev->dev;\r\ninput_set_drvdata(input, opencores_kbd);\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\ninput->keycode = opencores_kbd->keycodes;\r\ninput->keycodesize = sizeof(opencores_kbd->keycodes[0]);\r\ninput->keycodemax = ARRAY_SIZE(opencores_kbd->keycodes);\r\n__set_bit(EV_KEY, input->evbit);\r\nfor (i = 0; i < ARRAY_SIZE(opencores_kbd->keycodes); i++) {\r\nopencores_kbd->keycodes[i] = i;\r\n__set_bit(opencores_kbd->keycodes[i], input->keybit);\r\n}\r\n__clear_bit(KEY_RESERVED, input->keybit);\r\nerror = request_irq(irq, &opencores_kbd_isr,\r\nIRQF_TRIGGER_RISING, pdev->name, opencores_kbd);\r\nif (error) {\r\ndev_err(&pdev->dev, "unable to claim irq %d\n", irq);\r\ngoto err_unmap_mem;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&pdev->dev, "unable to register input device\n");\r\ngoto err_free_irq;\r\n}\r\nplatform_set_drvdata(pdev, opencores_kbd);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(irq, opencores_kbd);\r\nerr_unmap_mem:\r\niounmap(opencores_kbd->addr);\r\nerr_rel_mem:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(opencores_kbd);\r\nreturn error;\r\n}\r\nstatic int opencores_kbd_remove(struct platform_device *pdev)\r\n{\r\nstruct opencores_kbd *opencores_kbd = platform_get_drvdata(pdev);\r\nfree_irq(opencores_kbd->irq, opencores_kbd);\r\niounmap(opencores_kbd->addr);\r\nrelease_mem_region(opencores_kbd->addr_res->start,\r\nresource_size(opencores_kbd->addr_res));\r\ninput_unregister_device(opencores_kbd->input);\r\nkfree(opencores_kbd);\r\nreturn 0;\r\n}
