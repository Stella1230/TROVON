static inline u32 tse_tx_avail(struct altera_tse_private *priv)\r\n{\r\nreturn priv->tx_cons + priv->tx_ring_size - priv->tx_prod - 1;\r\n}\r\nstatic int altera_tse_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\r\n{\r\nstruct net_device *ndev = bus->priv;\r\nstruct altera_tse_private *priv = netdev_priv(ndev);\r\ncsrwr32((mii_id & 0x1f), priv->mac_dev,\r\ntse_csroffs(mdio_phy0_addr));\r\nreturn csrrd32(priv->mac_dev,\r\ntse_csroffs(mdio_phy0) + regnum * 4) & 0xffff;\r\n}\r\nstatic int altera_tse_mdio_write(struct mii_bus *bus, int mii_id, int regnum,\r\nu16 value)\r\n{\r\nstruct net_device *ndev = bus->priv;\r\nstruct altera_tse_private *priv = netdev_priv(ndev);\r\ncsrwr32((mii_id & 0x1f), priv->mac_dev,\r\ntse_csroffs(mdio_phy0_addr));\r\ncsrwr32(value, priv->mac_dev, tse_csroffs(mdio_phy0) + regnum * 4);\r\nreturn 0;\r\n}\r\nstatic int altera_tse_mdio_create(struct net_device *dev, unsigned int id)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nint ret;\r\nint i;\r\nstruct device_node *mdio_node = NULL;\r\nstruct mii_bus *mdio = NULL;\r\nstruct device_node *child_node = NULL;\r\nfor_each_child_of_node(priv->device->of_node, child_node) {\r\nif (of_device_is_compatible(child_node, "altr,tse-mdio")) {\r\nmdio_node = child_node;\r\nbreak;\r\n}\r\n}\r\nif (mdio_node) {\r\nnetdev_dbg(dev, "FOUND MDIO subnode\n");\r\n} else {\r\nnetdev_dbg(dev, "NO MDIO subnode\n");\r\nreturn 0;\r\n}\r\nmdio = mdiobus_alloc();\r\nif (mdio == NULL) {\r\nnetdev_err(dev, "Error allocating MDIO bus\n");\r\nreturn -ENOMEM;\r\n}\r\nmdio->name = ALTERA_TSE_RESOURCE_NAME;\r\nmdio->read = &altera_tse_mdio_read;\r\nmdio->write = &altera_tse_mdio_write;\r\nsnprintf(mdio->id, MII_BUS_ID_SIZE, "%s-%u", mdio->name, id);\r\nmdio->irq = kcalloc(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);\r\nif (mdio->irq == NULL) {\r\nret = -ENOMEM;\r\ngoto out_free_mdio;\r\n}\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\nmdio->irq[i] = PHY_POLL;\r\nmdio->priv = dev;\r\nmdio->parent = priv->device;\r\nret = of_mdiobus_register(mdio, mdio_node);\r\nif (ret != 0) {\r\nnetdev_err(dev, "Cannot register MDIO bus %s\n",\r\nmdio->id);\r\ngoto out_free_mdio_irq;\r\n}\r\nif (netif_msg_drv(priv))\r\nnetdev_info(dev, "MDIO bus %s: created\n", mdio->id);\r\npriv->mdio = mdio;\r\nreturn 0;\r\nout_free_mdio_irq:\r\nkfree(mdio->irq);\r\nout_free_mdio:\r\nmdiobus_free(mdio);\r\nmdio = NULL;\r\nreturn ret;\r\n}\r\nstatic void altera_tse_mdio_destroy(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nif (priv->mdio == NULL)\r\nreturn;\r\nif (netif_msg_drv(priv))\r\nnetdev_info(dev, "MDIO bus %s: removed\n",\r\npriv->mdio->id);\r\nmdiobus_unregister(priv->mdio);\r\nkfree(priv->mdio->irq);\r\nmdiobus_free(priv->mdio);\r\npriv->mdio = NULL;\r\n}\r\nstatic int tse_init_rx_buffer(struct altera_tse_private *priv,\r\nstruct tse_buffer *rxbuffer, int len)\r\n{\r\nrxbuffer->skb = netdev_alloc_skb_ip_align(priv->dev, len);\r\nif (!rxbuffer->skb)\r\nreturn -ENOMEM;\r\nrxbuffer->dma_addr = dma_map_single(priv->device, rxbuffer->skb->data,\r\nlen,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(priv->device, rxbuffer->dma_addr)) {\r\nnetdev_err(priv->dev, "%s: DMA mapping error\n", __func__);\r\ndev_kfree_skb_any(rxbuffer->skb);\r\nreturn -EINVAL;\r\n}\r\nrxbuffer->dma_addr &= (dma_addr_t)~3;\r\nrxbuffer->len = len;\r\nreturn 0;\r\n}\r\nstatic void tse_free_rx_buffer(struct altera_tse_private *priv,\r\nstruct tse_buffer *rxbuffer)\r\n{\r\nstruct sk_buff *skb = rxbuffer->skb;\r\ndma_addr_t dma_addr = rxbuffer->dma_addr;\r\nif (skb != NULL) {\r\nif (dma_addr)\r\ndma_unmap_single(priv->device, dma_addr,\r\nrxbuffer->len,\r\nDMA_FROM_DEVICE);\r\ndev_kfree_skb_any(skb);\r\nrxbuffer->skb = NULL;\r\nrxbuffer->dma_addr = 0;\r\n}\r\n}\r\nstatic void tse_free_tx_buffer(struct altera_tse_private *priv,\r\nstruct tse_buffer *buffer)\r\n{\r\nif (buffer->dma_addr) {\r\nif (buffer->mapped_as_page)\r\ndma_unmap_page(priv->device, buffer->dma_addr,\r\nbuffer->len, DMA_TO_DEVICE);\r\nelse\r\ndma_unmap_single(priv->device, buffer->dma_addr,\r\nbuffer->len, DMA_TO_DEVICE);\r\nbuffer->dma_addr = 0;\r\n}\r\nif (buffer->skb) {\r\ndev_kfree_skb_any(buffer->skb);\r\nbuffer->skb = NULL;\r\n}\r\n}\r\nstatic int alloc_init_skbufs(struct altera_tse_private *priv)\r\n{\r\nunsigned int rx_descs = priv->rx_ring_size;\r\nunsigned int tx_descs = priv->tx_ring_size;\r\nint ret = -ENOMEM;\r\nint i;\r\npriv->rx_ring = kcalloc(rx_descs, sizeof(struct tse_buffer),\r\nGFP_KERNEL);\r\nif (!priv->rx_ring)\r\ngoto err_rx_ring;\r\npriv->tx_ring = kcalloc(tx_descs, sizeof(struct tse_buffer),\r\nGFP_KERNEL);\r\nif (!priv->tx_ring)\r\ngoto err_tx_ring;\r\npriv->tx_cons = 0;\r\npriv->tx_prod = 0;\r\nfor (i = 0; i < rx_descs; i++) {\r\nret = tse_init_rx_buffer(priv, &priv->rx_ring[i],\r\npriv->rx_dma_buf_sz);\r\nif (ret)\r\ngoto err_init_rx_buffers;\r\n}\r\npriv->rx_cons = 0;\r\npriv->rx_prod = 0;\r\nreturn 0;\r\nerr_init_rx_buffers:\r\nwhile (--i >= 0)\r\ntse_free_rx_buffer(priv, &priv->rx_ring[i]);\r\nkfree(priv->tx_ring);\r\nerr_tx_ring:\r\nkfree(priv->rx_ring);\r\nerr_rx_ring:\r\nreturn ret;\r\n}\r\nstatic void free_skbufs(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nunsigned int rx_descs = priv->rx_ring_size;\r\nunsigned int tx_descs = priv->tx_ring_size;\r\nint i;\r\nfor (i = 0; i < rx_descs; i++)\r\ntse_free_rx_buffer(priv, &priv->rx_ring[i]);\r\nfor (i = 0; i < tx_descs; i++)\r\ntse_free_tx_buffer(priv, &priv->tx_ring[i]);\r\nkfree(priv->tx_ring);\r\n}\r\nstatic inline void tse_rx_refill(struct altera_tse_private *priv)\r\n{\r\nunsigned int rxsize = priv->rx_ring_size;\r\nunsigned int entry;\r\nint ret;\r\nfor (; priv->rx_cons - priv->rx_prod > 0;\r\npriv->rx_prod++) {\r\nentry = priv->rx_prod % rxsize;\r\nif (likely(priv->rx_ring[entry].skb == NULL)) {\r\nret = tse_init_rx_buffer(priv, &priv->rx_ring[entry],\r\npriv->rx_dma_buf_sz);\r\nif (unlikely(ret != 0))\r\nbreak;\r\npriv->dmaops->add_rx_desc(priv, &priv->rx_ring[entry]);\r\n}\r\n}\r\n}\r\nstatic inline void tse_rx_vlan(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct ethhdr *eth_hdr;\r\nu16 vid;\r\nif ((dev->features & NETIF_F_HW_VLAN_CTAG_RX) &&\r\n!__vlan_get_tag(skb, &vid)) {\r\neth_hdr = (struct ethhdr *)skb->data;\r\nmemmove(skb->data + VLAN_HLEN, eth_hdr, ETH_ALEN * 2);\r\nskb_pull(skb, VLAN_HLEN);\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\r\n}\r\n}\r\nstatic int tse_rx(struct altera_tse_private *priv, int limit)\r\n{\r\nunsigned int count = 0;\r\nunsigned int next_entry;\r\nstruct sk_buff *skb;\r\nunsigned int entry = priv->rx_cons % priv->rx_ring_size;\r\nu32 rxstatus;\r\nu16 pktlength;\r\nu16 pktstatus;\r\nwhile ((rxstatus = priv->dmaops->get_rx_status(priv)) != 0) {\r\npktstatus = rxstatus >> 16;\r\npktlength = rxstatus & 0xffff;\r\nif ((pktstatus & 0xFF) || (pktlength == 0))\r\nnetdev_err(priv->dev,\r\n"RCV pktstatus %08X pktlength %08X\n",\r\npktstatus, pktlength);\r\ncount++;\r\nnext_entry = (++priv->rx_cons) % priv->rx_ring_size;\r\nskb = priv->rx_ring[entry].skb;\r\nif (unlikely(!skb)) {\r\nnetdev_err(priv->dev,\r\n"%s: Inconsistent Rx descriptor chain\n",\r\n__func__);\r\npriv->dev->stats.rx_dropped++;\r\nbreak;\r\n}\r\npriv->rx_ring[entry].skb = NULL;\r\nskb_put(skb, pktlength);\r\ndma_sync_single_for_cpu(priv->device,\r\npriv->rx_ring[entry].dma_addr,\r\npriv->rx_ring[entry].len,\r\nDMA_FROM_DEVICE);\r\ndma_unmap_single(priv->device, priv->rx_ring[entry].dma_addr,\r\npriv->rx_ring[entry].len, DMA_FROM_DEVICE);\r\nif (netif_msg_pktdata(priv)) {\r\nnetdev_info(priv->dev, "frame received %d bytes\n",\r\npktlength);\r\nprint_hex_dump(KERN_ERR, "data: ", DUMP_PREFIX_OFFSET,\r\n16, 1, skb->data, pktlength, true);\r\n}\r\ntse_rx_vlan(priv->dev, skb);\r\nskb->protocol = eth_type_trans(skb, priv->dev);\r\nskb_checksum_none_assert(skb);\r\nnapi_gro_receive(&priv->napi, skb);\r\npriv->dev->stats.rx_packets++;\r\npriv->dev->stats.rx_bytes += pktlength;\r\nentry = next_entry;\r\ntse_rx_refill(priv);\r\n}\r\nreturn count;\r\n}\r\nstatic int tse_tx_complete(struct altera_tse_private *priv)\r\n{\r\nunsigned int txsize = priv->tx_ring_size;\r\nu32 ready;\r\nunsigned int entry;\r\nstruct tse_buffer *tx_buff;\r\nint txcomplete = 0;\r\nspin_lock(&priv->tx_lock);\r\nready = priv->dmaops->tx_completions(priv);\r\nwhile (ready && (priv->tx_cons != priv->tx_prod)) {\r\nentry = priv->tx_cons % txsize;\r\ntx_buff = &priv->tx_ring[entry];\r\nif (netif_msg_tx_done(priv))\r\nnetdev_dbg(priv->dev, "%s: curr %d, dirty %d\n",\r\n__func__, priv->tx_prod, priv->tx_cons);\r\nif (likely(tx_buff->skb))\r\npriv->dev->stats.tx_packets++;\r\ntse_free_tx_buffer(priv, tx_buff);\r\npriv->tx_cons++;\r\ntxcomplete++;\r\nready--;\r\n}\r\nif (unlikely(netif_queue_stopped(priv->dev) &&\r\ntse_tx_avail(priv) > TSE_TX_THRESH(priv))) {\r\nnetif_tx_lock(priv->dev);\r\nif (netif_queue_stopped(priv->dev) &&\r\ntse_tx_avail(priv) > TSE_TX_THRESH(priv)) {\r\nif (netif_msg_tx_done(priv))\r\nnetdev_dbg(priv->dev, "%s: restart transmit\n",\r\n__func__);\r\nnetif_wake_queue(priv->dev);\r\n}\r\nnetif_tx_unlock(priv->dev);\r\n}\r\nspin_unlock(&priv->tx_lock);\r\nreturn txcomplete;\r\n}\r\nstatic int tse_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct altera_tse_private *priv =\r\ncontainer_of(napi, struct altera_tse_private, napi);\r\nint rxcomplete = 0;\r\nint txcomplete = 0;\r\nunsigned long int flags;\r\ntxcomplete = tse_tx_complete(priv);\r\nrxcomplete = tse_rx(priv, budget);\r\nif (rxcomplete >= budget || txcomplete > 0)\r\nreturn rxcomplete;\r\nnapi_gro_flush(napi, false);\r\n__napi_complete(napi);\r\nnetdev_dbg(priv->dev,\r\n"NAPI Complete, did %d packets with budget %d\n",\r\ntxcomplete+rxcomplete, budget);\r\nspin_lock_irqsave(&priv->rxdma_irq_lock, flags);\r\npriv->dmaops->enable_rxirq(priv);\r\npriv->dmaops->enable_txirq(priv);\r\nspin_unlock_irqrestore(&priv->rxdma_irq_lock, flags);\r\nreturn rxcomplete + txcomplete;\r\n}\r\nstatic irqreturn_t altera_isr(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct altera_tse_private *priv;\r\nunsigned long int flags;\r\nif (unlikely(!dev)) {\r\npr_err("%s: invalid dev pointer\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\npriv = netdev_priv(dev);\r\nspin_lock_irqsave(&priv->rxdma_irq_lock, flags);\r\nif (likely(napi_schedule_prep(&priv->napi))) {\r\npriv->dmaops->disable_rxirq(priv);\r\npriv->dmaops->disable_txirq(priv);\r\n__napi_schedule(&priv->napi);\r\n}\r\npriv->dmaops->clear_rxirq(priv);\r\npriv->dmaops->clear_txirq(priv);\r\nspin_unlock_irqrestore(&priv->rxdma_irq_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tse_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nunsigned int txsize = priv->tx_ring_size;\r\nunsigned int entry;\r\nstruct tse_buffer *buffer = NULL;\r\nint nfrags = skb_shinfo(skb)->nr_frags;\r\nunsigned int nopaged_len = skb_headlen(skb);\r\nenum netdev_tx ret = NETDEV_TX_OK;\r\ndma_addr_t dma_addr;\r\nspin_lock_bh(&priv->tx_lock);\r\nif (unlikely(tse_tx_avail(priv) < nfrags + 1)) {\r\nif (!netif_queue_stopped(dev)) {\r\nnetif_stop_queue(dev);\r\nnetdev_err(priv->dev,\r\n"%s: Tx list full when queue awake\n",\r\n__func__);\r\n}\r\nret = NETDEV_TX_BUSY;\r\ngoto out;\r\n}\r\nentry = priv->tx_prod % txsize;\r\nbuffer = &priv->tx_ring[entry];\r\ndma_addr = dma_map_single(priv->device, skb->data, nopaged_len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(priv->device, dma_addr)) {\r\nnetdev_err(priv->dev, "%s: DMA mapping error\n", __func__);\r\nret = NETDEV_TX_OK;\r\ngoto out;\r\n}\r\nbuffer->skb = skb;\r\nbuffer->dma_addr = dma_addr;\r\nbuffer->len = nopaged_len;\r\ndma_sync_single_for_device(priv->device, buffer->dma_addr,\r\nbuffer->len, DMA_TO_DEVICE);\r\npriv->dmaops->tx_buffer(priv, buffer);\r\nskb_tx_timestamp(skb);\r\npriv->tx_prod++;\r\ndev->stats.tx_bytes += skb->len;\r\nif (unlikely(tse_tx_avail(priv) <= TXQUEUESTOP_THRESHHOLD)) {\r\nif (netif_msg_hw(priv))\r\nnetdev_dbg(priv->dev, "%s: stop transmitted packets\n",\r\n__func__);\r\nnetif_stop_queue(dev);\r\n}\r\nout:\r\nspin_unlock_bh(&priv->tx_lock);\r\nreturn ret;\r\n}\r\nstatic void altera_tse_adjust_link(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nstruct phy_device *phydev = priv->phydev;\r\nint new_state = 0;\r\nspin_lock(&priv->mac_cfg_lock);\r\nif (phydev->link) {\r\nu32 cfg_reg = ioread32(&priv->mac_dev->command_config);\r\nif (phydev->duplex != priv->oldduplex) {\r\nnew_state = 1;\r\nif (!(phydev->duplex))\r\ncfg_reg |= MAC_CMDCFG_HD_ENA;\r\nelse\r\ncfg_reg &= ~MAC_CMDCFG_HD_ENA;\r\nnetdev_dbg(priv->dev, "%s: Link duplex = 0x%x\n",\r\ndev->name, phydev->duplex);\r\npriv->oldduplex = phydev->duplex;\r\n}\r\nif (phydev->speed != priv->oldspeed) {\r\nnew_state = 1;\r\nswitch (phydev->speed) {\r\ncase 1000:\r\ncfg_reg |= MAC_CMDCFG_ETH_SPEED;\r\ncfg_reg &= ~MAC_CMDCFG_ENA_10;\r\nbreak;\r\ncase 100:\r\ncfg_reg &= ~MAC_CMDCFG_ETH_SPEED;\r\ncfg_reg &= ~MAC_CMDCFG_ENA_10;\r\nbreak;\r\ncase 10:\r\ncfg_reg &= ~MAC_CMDCFG_ETH_SPEED;\r\ncfg_reg |= MAC_CMDCFG_ENA_10;\r\nbreak;\r\ndefault:\r\nif (netif_msg_link(priv))\r\nnetdev_warn(dev, "Speed (%d) is not 10/100/1000!\n",\r\nphydev->speed);\r\nbreak;\r\n}\r\npriv->oldspeed = phydev->speed;\r\n}\r\niowrite32(cfg_reg, &priv->mac_dev->command_config);\r\nif (!priv->oldlink) {\r\nnew_state = 1;\r\npriv->oldlink = 1;\r\n}\r\n} else if (priv->oldlink) {\r\nnew_state = 1;\r\npriv->oldlink = 0;\r\npriv->oldspeed = 0;\r\npriv->oldduplex = -1;\r\n}\r\nif (new_state && netif_msg_link(priv))\r\nphy_print_status(phydev);\r\nspin_unlock(&priv->mac_cfg_lock);\r\n}\r\nstatic struct phy_device *connect_local_phy(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nstruct phy_device *phydev = NULL;\r\nchar phy_id_fmt[MII_BUS_ID_SIZE + 3];\r\nif (priv->phy_addr != POLL_PHY) {\r\nsnprintf(phy_id_fmt, MII_BUS_ID_SIZE + 3, PHY_ID_FMT,\r\npriv->mdio->id, priv->phy_addr);\r\nnetdev_dbg(dev, "trying to attach to %s\n", phy_id_fmt);\r\nphydev = phy_connect(dev, phy_id_fmt, &altera_tse_adjust_link,\r\npriv->phy_iface);\r\nif (IS_ERR(phydev))\r\nnetdev_err(dev, "Could not attach to PHY\n");\r\n} else {\r\nint ret;\r\nphydev = phy_find_first(priv->mdio);\r\nif (phydev == NULL) {\r\nnetdev_err(dev, "No PHY found\n");\r\nreturn phydev;\r\n}\r\nret = phy_connect_direct(dev, phydev, &altera_tse_adjust_link,\r\npriv->phy_iface);\r\nif (ret != 0) {\r\nnetdev_err(dev, "Could not attach to PHY\n");\r\nphydev = NULL;\r\n}\r\n}\r\nreturn phydev;\r\n}\r\nstatic int init_phy(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nstruct phy_device *phydev;\r\nstruct device_node *phynode;\r\npriv->oldlink = 0;\r\npriv->oldspeed = 0;\r\npriv->oldduplex = -1;\r\nphynode = of_parse_phandle(priv->device->of_node, "phy-handle", 0);\r\nif (!phynode) {\r\nnetdev_dbg(dev, "no phy-handle found\n");\r\nif (!priv->mdio) {\r\nnetdev_err(dev,\r\n"No phy-handle nor local mdio specified\n");\r\nreturn -ENODEV;\r\n}\r\nphydev = connect_local_phy(dev);\r\n} else {\r\nnetdev_dbg(dev, "phy-handle found\n");\r\nphydev = of_phy_connect(dev, phynode,\r\n&altera_tse_adjust_link, 0, priv->phy_iface);\r\n}\r\nif (!phydev) {\r\nnetdev_err(dev, "Could not find the PHY\n");\r\nreturn -ENODEV;\r\n}\r\nif ((priv->phy_iface == PHY_INTERFACE_MODE_MII) ||\r\n(priv->phy_iface == PHY_INTERFACE_MODE_RMII))\r\nphydev->advertising &= ~(SUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full);\r\nif (phydev->phy_id == 0) {\r\nnetdev_err(dev, "Bad PHY UID 0x%08x\n", phydev->phy_id);\r\nphy_disconnect(phydev);\r\nreturn -ENODEV;\r\n}\r\nnetdev_dbg(dev, "attached to PHY %d UID 0x%08x Link = %d\n",\r\nphydev->addr, phydev->phy_id, phydev->link);\r\npriv->phydev = phydev;\r\nreturn 0;\r\n}\r\nstatic void tse_update_mac_addr(struct altera_tse_private *priv, u8 *addr)\r\n{\r\nu32 msb;\r\nu32 lsb;\r\nmsb = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];\r\nlsb = ((addr[5] << 8) | addr[4]) & 0xffff;\r\ncsrwr32(msb, priv->mac_dev, tse_csroffs(mac_addr_0));\r\ncsrwr32(lsb, priv->mac_dev, tse_csroffs(mac_addr_1));\r\n}\r\nstatic int reset_mac(struct altera_tse_private *priv)\r\n{\r\nint counter;\r\nu32 dat;\r\ndat = csrrd32(priv->mac_dev, tse_csroffs(command_config));\r\ndat &= ~(MAC_CMDCFG_TX_ENA | MAC_CMDCFG_RX_ENA);\r\ndat |= MAC_CMDCFG_SW_RESET | MAC_CMDCFG_CNT_RESET;\r\ncsrwr32(dat, priv->mac_dev, tse_csroffs(command_config));\r\ncounter = 0;\r\nwhile (counter++ < ALTERA_TSE_SW_RESET_WATCHDOG_CNTR) {\r\nif (tse_bit_is_clear(priv->mac_dev, tse_csroffs(command_config),\r\nMAC_CMDCFG_SW_RESET))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (counter >= ALTERA_TSE_SW_RESET_WATCHDOG_CNTR) {\r\ndat = csrrd32(priv->mac_dev, tse_csroffs(command_config));\r\ndat &= ~MAC_CMDCFG_SW_RESET;\r\ncsrwr32(dat, priv->mac_dev, tse_csroffs(command_config));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_mac(struct altera_tse_private *priv)\r\n{\r\nunsigned int cmd = 0;\r\nu32 frm_length;\r\ncsrwr32(priv->rx_fifo_depth - ALTERA_TSE_RX_SECTION_EMPTY,\r\npriv->mac_dev, tse_csroffs(rx_section_empty));\r\ncsrwr32(ALTERA_TSE_RX_SECTION_FULL, priv->mac_dev,\r\ntse_csroffs(rx_section_full));\r\ncsrwr32(ALTERA_TSE_RX_ALMOST_EMPTY, priv->mac_dev,\r\ntse_csroffs(rx_almost_empty));\r\ncsrwr32(ALTERA_TSE_RX_ALMOST_FULL, priv->mac_dev,\r\ntse_csroffs(rx_almost_full));\r\ncsrwr32(priv->tx_fifo_depth - ALTERA_TSE_TX_SECTION_EMPTY,\r\npriv->mac_dev, tse_csroffs(tx_section_empty));\r\ncsrwr32(ALTERA_TSE_TX_SECTION_FULL, priv->mac_dev,\r\ntse_csroffs(tx_section_full));\r\ncsrwr32(ALTERA_TSE_TX_ALMOST_EMPTY, priv->mac_dev,\r\ntse_csroffs(tx_almost_empty));\r\ncsrwr32(ALTERA_TSE_TX_ALMOST_FULL, priv->mac_dev,\r\ntse_csroffs(tx_almost_full));\r\ntse_update_mac_addr(priv, priv->dev->dev_addr);\r\nfrm_length = ETH_HLEN + priv->dev->mtu + ETH_FCS_LEN;\r\ncsrwr32(frm_length, priv->mac_dev, tse_csroffs(frm_length));\r\ncsrwr32(ALTERA_TSE_TX_IPG_LENGTH, priv->mac_dev,\r\ntse_csroffs(tx_ipg_length));\r\ntse_set_bit(priv->mac_dev, tse_csroffs(rx_cmd_stat),\r\nALTERA_TSE_RX_CMD_STAT_RX_SHIFT16);\r\ntse_clear_bit(priv->mac_dev, tse_csroffs(tx_cmd_stat),\r\nALTERA_TSE_TX_CMD_STAT_TX_SHIFT16 |\r\nALTERA_TSE_TX_CMD_STAT_OMIT_CRC);\r\ncmd = csrrd32(priv->mac_dev, tse_csroffs(command_config));\r\ncmd &= ~MAC_CMDCFG_PAD_EN;\r\ncmd &= ~MAC_CMDCFG_CRC_FWD;\r\ncmd |= MAC_CMDCFG_RX_ERR_DISC;\r\ncmd |= MAC_CMDCFG_CNTL_FRM_ENA;\r\ncmd &= ~MAC_CMDCFG_TX_ENA;\r\ncmd &= ~MAC_CMDCFG_RX_ENA;\r\ncmd &= ~MAC_CMDCFG_HD_ENA;\r\ncmd &= ~MAC_CMDCFG_ETH_SPEED;\r\ncmd &= ~MAC_CMDCFG_ENA_10;\r\ncsrwr32(cmd, priv->mac_dev, tse_csroffs(command_config));\r\ncsrwr32(ALTERA_TSE_PAUSE_QUANTA, priv->mac_dev,\r\ntse_csroffs(pause_quanta));\r\nif (netif_msg_hw(priv))\r\ndev_dbg(priv->device,\r\n"MAC post-initialization: CMD_CONFIG = 0x%08x\n", cmd);\r\nreturn 0;\r\n}\r\nstatic void tse_set_mac(struct altera_tse_private *priv, bool enable)\r\n{\r\nu32 value = csrrd32(priv->mac_dev, tse_csroffs(command_config));\r\nif (enable)\r\nvalue |= MAC_CMDCFG_TX_ENA | MAC_CMDCFG_RX_ENA;\r\nelse\r\nvalue &= ~(MAC_CMDCFG_TX_ENA | MAC_CMDCFG_RX_ENA);\r\ncsrwr32(value, priv->mac_dev, tse_csroffs(command_config));\r\n}\r\nstatic int tse_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nunsigned int max_mtu = priv->max_mtu;\r\nunsigned int min_mtu = ETH_ZLEN + ETH_FCS_LEN;\r\nif (netif_running(dev)) {\r\nnetdev_err(dev, "must be stopped to change its MTU\n");\r\nreturn -EBUSY;\r\n}\r\nif ((new_mtu < min_mtu) || (new_mtu > max_mtu)) {\r\nnetdev_err(dev, "invalid MTU, max MTU is: %u\n", max_mtu);\r\nreturn -EINVAL;\r\n}\r\ndev->mtu = new_mtu;\r\nnetdev_update_features(dev);\r\nreturn 0;\r\n}\r\nstatic void altera_tse_set_mcfilter(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nint i;\r\nstruct netdev_hw_addr *ha;\r\nfor (i = 0; i < 64; i++)\r\ncsrwr32(0, priv->mac_dev, tse_csroffs(hash_table) + i * 4);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nunsigned int hash = 0;\r\nint mac_octet;\r\nfor (mac_octet = 5; mac_octet >= 0; mac_octet--) {\r\nunsigned char xor_bit = 0;\r\nunsigned char octet = ha->addr[mac_octet];\r\nunsigned int bitshift;\r\nfor (bitshift = 0; bitshift < 8; bitshift++)\r\nxor_bit ^= ((octet >> bitshift) & 0x01);\r\nhash = (hash << 1) | xor_bit;\r\n}\r\ncsrwr32(1, priv->mac_dev, tse_csroffs(hash_table) + hash * 4);\r\n}\r\n}\r\nstatic void altera_tse_set_mcfilterall(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < 64; i++)\r\ncsrwr32(1, priv->mac_dev, tse_csroffs(hash_table) + i * 4);\r\n}\r\nstatic void tse_set_rx_mode_hashfilter(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nspin_lock(&priv->mac_cfg_lock);\r\nif (dev->flags & IFF_PROMISC)\r\ntse_set_bit(priv->mac_dev, tse_csroffs(command_config),\r\nMAC_CMDCFG_PROMIS_EN);\r\nif (dev->flags & IFF_ALLMULTI)\r\naltera_tse_set_mcfilterall(dev);\r\nelse\r\naltera_tse_set_mcfilter(dev);\r\nspin_unlock(&priv->mac_cfg_lock);\r\n}\r\nstatic void tse_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nspin_lock(&priv->mac_cfg_lock);\r\nif ((dev->flags & IFF_PROMISC) || (dev->flags & IFF_ALLMULTI) ||\r\n!netdev_mc_empty(dev) || !netdev_uc_empty(dev))\r\ntse_set_bit(priv->mac_dev, tse_csroffs(command_config),\r\nMAC_CMDCFG_PROMIS_EN);\r\nelse\r\ntse_clear_bit(priv->mac_dev, tse_csroffs(command_config),\r\nMAC_CMDCFG_PROMIS_EN);\r\nspin_unlock(&priv->mac_cfg_lock);\r\n}\r\nstatic int tse_open(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nint ret = 0;\r\nint i;\r\nunsigned long int flags;\r\nret = priv->dmaops->init_dma(priv);\r\nif (ret != 0) {\r\nnetdev_err(dev, "Cannot initialize DMA\n");\r\ngoto phy_error;\r\n}\r\nif (netif_msg_ifup(priv))\r\nnetdev_warn(dev, "device MAC address %pM\n",\r\ndev->dev_addr);\r\nif ((priv->revision < 0xd00) || (priv->revision > 0xe00))\r\nnetdev_warn(dev, "TSE revision %x\n", priv->revision);\r\nspin_lock(&priv->mac_cfg_lock);\r\nret = reset_mac(priv);\r\nif (ret)\r\nnetdev_err(dev, "Cannot reset MAC core (error: %d)\n", ret);\r\nret = init_mac(priv);\r\nspin_unlock(&priv->mac_cfg_lock);\r\nif (ret) {\r\nnetdev_err(dev, "Cannot init MAC core (error: %d)\n", ret);\r\ngoto alloc_skbuf_error;\r\n}\r\npriv->dmaops->reset_dma(priv);\r\npriv->rx_ring_size = dma_rx_num;\r\npriv->tx_ring_size = dma_tx_num;\r\nret = alloc_init_skbufs(priv);\r\nif (ret) {\r\nnetdev_err(dev, "DMA descriptors initialization failed\n");\r\ngoto alloc_skbuf_error;\r\n}\r\nret = request_irq(priv->rx_irq, altera_isr, IRQF_SHARED,\r\ndev->name, dev);\r\nif (ret) {\r\nnetdev_err(dev, "Unable to register RX interrupt %d\n",\r\npriv->rx_irq);\r\ngoto init_error;\r\n}\r\nret = request_irq(priv->tx_irq, altera_isr, IRQF_SHARED,\r\ndev->name, dev);\r\nif (ret) {\r\nnetdev_err(dev, "Unable to register TX interrupt %d\n",\r\npriv->tx_irq);\r\ngoto tx_request_irq_error;\r\n}\r\nspin_lock_irqsave(&priv->rxdma_irq_lock, flags);\r\npriv->dmaops->enable_rxirq(priv);\r\npriv->dmaops->enable_txirq(priv);\r\nfor (i = 0; i < priv->rx_ring_size; i++)\r\npriv->dmaops->add_rx_desc(priv, &priv->rx_ring[i]);\r\nspin_unlock_irqrestore(&priv->rxdma_irq_lock, flags);\r\nif (priv->phydev)\r\nphy_start(priv->phydev);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(dev);\r\npriv->dmaops->start_rxdma(priv);\r\nspin_lock(&priv->mac_cfg_lock);\r\ntse_set_mac(priv, true);\r\nspin_unlock(&priv->mac_cfg_lock);\r\nreturn 0;\r\ntx_request_irq_error:\r\nfree_irq(priv->rx_irq, dev);\r\ninit_error:\r\nfree_skbufs(dev);\r\nalloc_skbuf_error:\r\nif (priv->phydev) {\r\nphy_disconnect(priv->phydev);\r\npriv->phydev = NULL;\r\n}\r\nphy_error:\r\nreturn ret;\r\n}\r\nstatic int tse_shutdown(struct net_device *dev)\r\n{\r\nstruct altera_tse_private *priv = netdev_priv(dev);\r\nint ret;\r\nunsigned long int flags;\r\nif (priv->phydev) {\r\nphy_stop(priv->phydev);\r\nphy_disconnect(priv->phydev);\r\npriv->phydev = NULL;\r\n}\r\nnetif_stop_queue(dev);\r\nnapi_disable(&priv->napi);\r\nspin_lock_irqsave(&priv->rxdma_irq_lock, flags);\r\npriv->dmaops->disable_rxirq(priv);\r\npriv->dmaops->disable_txirq(priv);\r\nspin_unlock_irqrestore(&priv->rxdma_irq_lock, flags);\r\nfree_irq(priv->rx_irq, dev);\r\nfree_irq(priv->tx_irq, dev);\r\nspin_lock(&priv->mac_cfg_lock);\r\nspin_lock(&priv->tx_lock);\r\nret = reset_mac(priv);\r\nif (ret)\r\nnetdev_err(dev, "Cannot reset MAC core (error: %d)\n", ret);\r\npriv->dmaops->reset_dma(priv);\r\nfree_skbufs(dev);\r\nspin_unlock(&priv->tx_lock);\r\nspin_unlock(&priv->mac_cfg_lock);\r\npriv->dmaops->uninit_dma(priv);\r\nreturn 0;\r\n}\r\nstatic int request_and_map(struct platform_device *pdev, const char *name,\r\nstruct resource **res, void __iomem **ptr)\r\n{\r\nstruct resource *region;\r\nstruct device *device = &pdev->dev;\r\n*res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\r\nif (*res == NULL) {\r\ndev_err(device, "resource %s not defined\n", name);\r\nreturn -ENODEV;\r\n}\r\nregion = devm_request_mem_region(device, (*res)->start,\r\nresource_size(*res), dev_name(device));\r\nif (region == NULL) {\r\ndev_err(device, "unable to request %s\n", name);\r\nreturn -EBUSY;\r\n}\r\n*ptr = devm_ioremap_nocache(device, region->start,\r\nresource_size(region));\r\nif (*ptr == NULL) {\r\ndev_err(device, "ioremap_nocache of %s failed!", name);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int altera_tse_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev;\r\nint ret = -ENODEV;\r\nstruct resource *control_port;\r\nstruct resource *dma_res;\r\nstruct altera_tse_private *priv;\r\nconst unsigned char *macaddr;\r\nstruct device_node *np = pdev->dev.of_node;\r\nvoid __iomem *descmap;\r\nconst struct of_device_id *of_id = NULL;\r\nndev = alloc_etherdev(sizeof(struct altera_tse_private));\r\nif (!ndev) {\r\ndev_err(&pdev->dev, "Could not allocate network device\n");\r\nreturn -ENODEV;\r\n}\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\npriv = netdev_priv(ndev);\r\npriv->device = &pdev->dev;\r\npriv->dev = ndev;\r\npriv->msg_enable = netif_msg_init(debug, default_msg_level);\r\nof_id = of_match_device(altera_tse_ids, &pdev->dev);\r\nif (of_id)\r\npriv->dmaops = (struct altera_dmaops *)of_id->data;\r\nif (priv->dmaops &&\r\npriv->dmaops->altera_dtype == ALTERA_DTYPE_SGDMA) {\r\nret = request_and_map(pdev, "s1", &dma_res, &descmap);\r\nif (ret)\r\ngoto err_free_netdev;\r\npriv->tx_dma_desc = descmap;\r\npriv->txdescmem = resource_size(dma_res)/2;\r\npriv->txdescmem_busaddr = (dma_addr_t)dma_res->start;\r\npriv->rx_dma_desc = (void __iomem *)((uintptr_t)(descmap +\r\npriv->txdescmem));\r\npriv->rxdescmem = resource_size(dma_res)/2;\r\npriv->rxdescmem_busaddr = dma_res->start;\r\npriv->rxdescmem_busaddr += priv->txdescmem;\r\nif (upper_32_bits(priv->rxdescmem_busaddr)) {\r\ndev_dbg(priv->device,\r\n"SGDMA bus addresses greater than 32-bits\n");\r\ngoto err_free_netdev;\r\n}\r\nif (upper_32_bits(priv->txdescmem_busaddr)) {\r\ndev_dbg(priv->device,\r\n"SGDMA bus addresses greater than 32-bits\n");\r\ngoto err_free_netdev;\r\n}\r\n} else if (priv->dmaops &&\r\npriv->dmaops->altera_dtype == ALTERA_DTYPE_MSGDMA) {\r\nret = request_and_map(pdev, "rx_resp", &dma_res,\r\n&priv->rx_dma_resp);\r\nif (ret)\r\ngoto err_free_netdev;\r\nret = request_and_map(pdev, "tx_desc", &dma_res,\r\n&priv->tx_dma_desc);\r\nif (ret)\r\ngoto err_free_netdev;\r\npriv->txdescmem = resource_size(dma_res);\r\npriv->txdescmem_busaddr = dma_res->start;\r\nret = request_and_map(pdev, "rx_desc", &dma_res,\r\n&priv->rx_dma_desc);\r\nif (ret)\r\ngoto err_free_netdev;\r\npriv->rxdescmem = resource_size(dma_res);\r\npriv->rxdescmem_busaddr = dma_res->start;\r\n} else {\r\ngoto err_free_netdev;\r\n}\r\nif (!dma_set_mask(priv->device, DMA_BIT_MASK(priv->dmaops->dmamask)))\r\ndma_set_coherent_mask(priv->device,\r\nDMA_BIT_MASK(priv->dmaops->dmamask));\r\nelse if (!dma_set_mask(priv->device, DMA_BIT_MASK(32)))\r\ndma_set_coherent_mask(priv->device, DMA_BIT_MASK(32));\r\nelse\r\ngoto err_free_netdev;\r\nret = request_and_map(pdev, "control_port", &control_port,\r\n(void __iomem **)&priv->mac_dev);\r\nif (ret)\r\ngoto err_free_netdev;\r\nret = request_and_map(pdev, "rx_csr", &dma_res,\r\n&priv->rx_dma_csr);\r\nif (ret)\r\ngoto err_free_netdev;\r\nret = request_and_map(pdev, "tx_csr", &dma_res,\r\n&priv->tx_dma_csr);\r\nif (ret)\r\ngoto err_free_netdev;\r\npriv->rx_irq = platform_get_irq_byname(pdev, "rx_irq");\r\nif (priv->rx_irq == -ENXIO) {\r\ndev_err(&pdev->dev, "cannot obtain Rx IRQ\n");\r\nret = -ENXIO;\r\ngoto err_free_netdev;\r\n}\r\npriv->tx_irq = platform_get_irq_byname(pdev, "tx_irq");\r\nif (priv->tx_irq == -ENXIO) {\r\ndev_err(&pdev->dev, "cannot obtain Tx IRQ\n");\r\nret = -ENXIO;\r\ngoto err_free_netdev;\r\n}\r\nif (of_property_read_u32(pdev->dev.of_node, "rx-fifo-depth",\r\n&priv->rx_fifo_depth)) {\r\ndev_err(&pdev->dev, "cannot obtain rx-fifo-depth\n");\r\nret = -ENXIO;\r\ngoto err_free_netdev;\r\n}\r\nif (of_property_read_u32(pdev->dev.of_node, "tx-fifo-depth",\r\n&priv->rx_fifo_depth)) {\r\ndev_err(&pdev->dev, "cannot obtain tx-fifo-depth\n");\r\nret = -ENXIO;\r\ngoto err_free_netdev;\r\n}\r\npriv->hash_filter =\r\nof_property_read_bool(pdev->dev.of_node,\r\n"altr,has-hash-multicast-filter");\r\npriv->hash_filter = 0;\r\npriv->added_unicast =\r\nof_property_read_bool(pdev->dev.of_node,\r\n"altr,has-supplementary-unicast");\r\npriv->max_mtu = ETH_DATA_LEN;\r\nof_property_read_u32(pdev->dev.of_node, "max-frame-size",\r\n&priv->max_mtu);\r\npriv->rx_dma_buf_sz = ALTERA_RXDMABUFFER_SIZE;\r\nmacaddr = of_get_mac_address(pdev->dev.of_node);\r\nif (macaddr)\r\nether_addr_copy(ndev->dev_addr, macaddr);\r\nelse\r\neth_hw_addr_random(ndev);\r\npriv->phy_iface = of_get_phy_mode(np);\r\nif (of_property_read_u32(pdev->dev.of_node, "phy-addr",\r\n&priv->phy_addr)) {\r\npriv->phy_addr = POLL_PHY;\r\n}\r\nif (!((priv->phy_addr == POLL_PHY) ||\r\n((priv->phy_addr >= 0) && (priv->phy_addr < PHY_MAX_ADDR)))) {\r\ndev_err(&pdev->dev, "invalid phy-addr specified %d\n",\r\npriv->phy_addr);\r\ngoto err_free_netdev;\r\n}\r\nret = altera_tse_mdio_create(ndev,\r\natomic_add_return(1, &instance_count));\r\nif (ret)\r\ngoto err_free_netdev;\r\nether_setup(ndev);\r\nndev->mem_start = control_port->start;\r\nndev->mem_end = control_port->end;\r\nndev->netdev_ops = &altera_tse_netdev_ops;\r\naltera_tse_set_ethtool_ops(ndev);\r\naltera_tse_netdev_ops.ndo_set_rx_mode = tse_set_rx_mode;\r\nif (priv->hash_filter)\r\naltera_tse_netdev_ops.ndo_set_rx_mode =\r\ntse_set_rx_mode_hashfilter;\r\nndev->hw_features &= ~NETIF_F_SG;\r\nndev->features |= ndev->hw_features | NETIF_F_HIGHDMA;\r\nndev->features |= NETIF_F_HW_VLAN_CTAG_RX;\r\nnetif_napi_add(ndev, &priv->napi, tse_poll, NAPI_POLL_WEIGHT);\r\nspin_lock_init(&priv->mac_cfg_lock);\r\nspin_lock_init(&priv->tx_lock);\r\nspin_lock_init(&priv->rxdma_irq_lock);\r\nret = register_netdev(ndev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register TSE net device\n");\r\ngoto err_register_netdev;\r\n}\r\nplatform_set_drvdata(pdev, ndev);\r\npriv->revision = ioread32(&priv->mac_dev->megacore_revision);\r\nif (netif_msg_probe(priv))\r\ndev_info(&pdev->dev, "Altera TSE MAC version %d.%d at 0x%08lx irq %d/%d\n",\r\n(priv->revision >> 8) & 0xff,\r\npriv->revision & 0xff,\r\n(unsigned long) control_port->start, priv->rx_irq,\r\npriv->tx_irq);\r\nret = init_phy(ndev);\r\nif (ret != 0) {\r\nnetdev_err(ndev, "Cannot attach to PHY (error: %d)\n", ret);\r\ngoto err_init_phy;\r\n}\r\nreturn 0;\r\nerr_init_phy:\r\nunregister_netdev(ndev);\r\nerr_register_netdev:\r\nnetif_napi_del(&priv->napi);\r\naltera_tse_mdio_destroy(ndev);\r\nerr_free_netdev:\r\nfree_netdev(ndev);\r\nreturn ret;\r\n}\r\nstatic int altera_tse_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\naltera_tse_mdio_destroy(ndev);\r\nunregister_netdev(ndev);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}
