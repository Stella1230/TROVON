static u64 knc_pmu_event_map(int hw_event)\r\n{\r\nreturn knc_perfmon_event_map[hw_event];\r\n}\r\nstatic void knc_pmu_disable_all(void)\r\n{\r\nu64 val;\r\nrdmsrl(MSR_KNC_IA32_PERF_GLOBAL_CTRL, val);\r\nval &= ~(KNC_ENABLE_COUNTER0|KNC_ENABLE_COUNTER1);\r\nwrmsrl(MSR_KNC_IA32_PERF_GLOBAL_CTRL, val);\r\n}\r\nstatic void knc_pmu_enable_all(int added)\r\n{\r\nu64 val;\r\nrdmsrl(MSR_KNC_IA32_PERF_GLOBAL_CTRL, val);\r\nval |= (KNC_ENABLE_COUNTER0|KNC_ENABLE_COUNTER1);\r\nwrmsrl(MSR_KNC_IA32_PERF_GLOBAL_CTRL, val);\r\n}\r\nstatic inline void\r\nknc_pmu_disable_event(struct perf_event *event)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nu64 val;\r\nval = hwc->config;\r\nval &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\r\n(void)wrmsrl_safe(hwc->config_base + hwc->idx, val);\r\n}\r\nstatic void knc_pmu_enable_event(struct perf_event *event)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nu64 val;\r\nval = hwc->config;\r\nval |= ARCH_PERFMON_EVENTSEL_ENABLE;\r\n(void)wrmsrl_safe(hwc->config_base + hwc->idx, val);\r\n}\r\nstatic inline u64 knc_pmu_get_status(void)\r\n{\r\nu64 status;\r\nrdmsrl(MSR_KNC_IA32_PERF_GLOBAL_STATUS, status);\r\nreturn status;\r\n}\r\nstatic inline void knc_pmu_ack_status(u64 ack)\r\n{\r\nwrmsrl(MSR_KNC_IA32_PERF_GLOBAL_OVF_CONTROL, ack);\r\n}\r\nstatic int knc_pmu_handle_irq(struct pt_regs *regs)\r\n{\r\nstruct perf_sample_data data;\r\nstruct cpu_hw_events *cpuc;\r\nint handled = 0;\r\nint bit, loops;\r\nu64 status;\r\ncpuc = &__get_cpu_var(cpu_hw_events);\r\nknc_pmu_disable_all();\r\nstatus = knc_pmu_get_status();\r\nif (!status) {\r\nknc_pmu_enable_all(0);\r\nreturn handled;\r\n}\r\nloops = 0;\r\nagain:\r\nknc_pmu_ack_status(status);\r\nif (++loops > 100) {\r\nWARN_ONCE(1, "perf: irq loop stuck!\n");\r\nperf_event_print_debug();\r\ngoto done;\r\n}\r\ninc_irq_stat(apic_perf_irqs);\r\nfor_each_set_bit(bit, (unsigned long *)&status, X86_PMC_IDX_MAX) {\r\nstruct perf_event *event = cpuc->events[bit];\r\nhandled++;\r\nif (!test_bit(bit, cpuc->active_mask))\r\ncontinue;\r\nif (!intel_pmu_save_and_restart(event))\r\ncontinue;\r\nperf_sample_data_init(&data, 0, event->hw.last_period);\r\nif (perf_event_overflow(event, &data, regs))\r\nx86_pmu_stop(event, 0);\r\n}\r\nstatus = knc_pmu_get_status();\r\nif (status)\r\ngoto again;\r\ndone:\r\nknc_pmu_enable_all(0);\r\nreturn handled;\r\n}\r\n__init int knc_pmu_init(void)\r\n{\r\nx86_pmu = knc_pmu;\r\nmemcpy(hw_cache_event_ids, knc_hw_cache_event_ids,\r\nsizeof(hw_cache_event_ids));\r\nreturn 0;\r\n}
