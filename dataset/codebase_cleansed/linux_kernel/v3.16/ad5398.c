static int ad5398_calc_current(struct ad5398_chip_info *chip,\r\nunsigned selector)\r\n{\r\nunsigned range_uA = chip->max_uA - chip->min_uA;\r\nreturn chip->min_uA + (selector * range_uA / chip->current_level);\r\n}\r\nstatic int ad5398_read_reg(struct i2c_client *client, unsigned short *data)\r\n{\r\nunsigned short val;\r\nint ret;\r\nret = i2c_master_recv(client, (char *)&val, 2);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "I2C read error\n");\r\nreturn ret;\r\n}\r\n*data = be16_to_cpu(val);\r\nreturn ret;\r\n}\r\nstatic int ad5398_write_reg(struct i2c_client *client, const unsigned short data)\r\n{\r\nunsigned short val;\r\nint ret;\r\nval = cpu_to_be16(data);\r\nret = i2c_master_send(client, (char *)&val, 2);\r\nif (ret < 0)\r\ndev_err(&client->dev, "I2C write error\n");\r\nreturn ret;\r\n}\r\nstatic int ad5398_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct ad5398_chip_info *chip = rdev_get_drvdata(rdev);\r\nstruct i2c_client *client = chip->client;\r\nunsigned short data;\r\nint ret;\r\nret = ad5398_read_reg(client, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = (data & chip->current_mask) >> chip->current_offset;\r\nreturn ad5398_calc_current(chip, ret);\r\n}\r\nstatic int ad5398_set_current_limit(struct regulator_dev *rdev, int min_uA, int max_uA)\r\n{\r\nstruct ad5398_chip_info *chip = rdev_get_drvdata(rdev);\r\nstruct i2c_client *client = chip->client;\r\nunsigned range_uA = chip->max_uA - chip->min_uA;\r\nunsigned selector;\r\nunsigned short data;\r\nint ret;\r\nif (min_uA < chip->min_uA)\r\nmin_uA = chip->min_uA;\r\nif (max_uA > chip->max_uA)\r\nmax_uA = chip->max_uA;\r\nif (min_uA > chip->max_uA || max_uA < chip->min_uA)\r\nreturn -EINVAL;\r\nselector = DIV_ROUND_UP((min_uA - chip->min_uA) * chip->current_level,\r\nrange_uA);\r\nif (ad5398_calc_current(chip, selector) > max_uA)\r\nreturn -EINVAL;\r\ndev_dbg(&client->dev, "changing current %duA\n",\r\nad5398_calc_current(chip, selector));\r\nret = ad5398_read_reg(client, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nselector = (selector << chip->current_offset) & chip->current_mask;\r\ndata = (unsigned short)selector | (data & AD5398_CURRENT_EN_MASK);\r\nret = ad5398_write_reg(client, data);\r\nreturn ret;\r\n}\r\nstatic int ad5398_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct ad5398_chip_info *chip = rdev_get_drvdata(rdev);\r\nstruct i2c_client *client = chip->client;\r\nunsigned short data;\r\nint ret;\r\nret = ad5398_read_reg(client, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (data & AD5398_CURRENT_EN_MASK)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int ad5398_enable(struct regulator_dev *rdev)\r\n{\r\nstruct ad5398_chip_info *chip = rdev_get_drvdata(rdev);\r\nstruct i2c_client *client = chip->client;\r\nunsigned short data;\r\nint ret;\r\nret = ad5398_read_reg(client, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (data & AD5398_CURRENT_EN_MASK)\r\nreturn 0;\r\ndata |= AD5398_CURRENT_EN_MASK;\r\nret = ad5398_write_reg(client, data);\r\nreturn ret;\r\n}\r\nstatic int ad5398_disable(struct regulator_dev *rdev)\r\n{\r\nstruct ad5398_chip_info *chip = rdev_get_drvdata(rdev);\r\nstruct i2c_client *client = chip->client;\r\nunsigned short data;\r\nint ret;\r\nret = ad5398_read_reg(client, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(data & AD5398_CURRENT_EN_MASK))\r\nreturn 0;\r\ndata &= ~AD5398_CURRENT_EN_MASK;\r\nret = ad5398_write_reg(client, data);\r\nreturn ret;\r\n}\r\nstatic int ad5398_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct regulator_init_data *init_data = dev_get_platdata(&client->dev);\r\nstruct regulator_config config = { };\r\nstruct ad5398_chip_info *chip;\r\nconst struct ad5398_current_data_format *df =\r\n(struct ad5398_current_data_format *)id->driver_data;\r\nif (!init_data)\r\nreturn -EINVAL;\r\nchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nconfig.dev = &client->dev;\r\nconfig.init_data = init_data;\r\nconfig.driver_data = chip;\r\nchip->client = client;\r\nchip->min_uA = df->min_uA;\r\nchip->max_uA = df->max_uA;\r\nchip->current_level = 1 << df->current_bits;\r\nchip->current_offset = df->current_offset;\r\nchip->current_mask = (chip->current_level - 1) << chip->current_offset;\r\nchip->rdev = devm_regulator_register(&client->dev, &ad5398_reg,\r\n&config);\r\nif (IS_ERR(chip->rdev)) {\r\ndev_err(&client->dev, "failed to register %s %s\n",\r\nid->name, ad5398_reg.name);\r\nreturn PTR_ERR(chip->rdev);\r\n}\r\ni2c_set_clientdata(client, chip);\r\ndev_dbg(&client->dev, "%s regulator driver is registered.\n", id->name);\r\nreturn 0;\r\n}\r\nstatic int __init ad5398_init(void)\r\n{\r\nreturn i2c_add_driver(&ad5398_driver);\r\n}\r\nstatic void __exit ad5398_exit(void)\r\n{\r\ni2c_del_driver(&ad5398_driver);\r\n}
