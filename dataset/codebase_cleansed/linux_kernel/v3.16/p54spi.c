static void p54spi_spi_read(struct p54s_priv *priv, u8 address,\r\nvoid *buf, size_t len)\r\n{\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\n__le16 addr;\r\naddr = cpu_to_le16(address << 8 | SPI_ADRS_READ_BIT_15);\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof(t));\r\nt[0].tx_buf = &addr;\r\nt[0].len = sizeof(addr);\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = buf;\r\nt[1].len = len;\r\nspi_message_add_tail(&t[1], &m);\r\nspi_sync(priv->spi, &m);\r\n}\r\nstatic void p54spi_spi_write(struct p54s_priv *priv, u8 address,\r\nconst void *buf, size_t len)\r\n{\r\nstruct spi_transfer t[3];\r\nstruct spi_message m;\r\n__le16 addr;\r\naddr = cpu_to_le16(address << 8);\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof(t));\r\nt[0].tx_buf = &addr;\r\nt[0].len = sizeof(addr);\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].tx_buf = buf;\r\nt[1].len = len & ~1;\r\nspi_message_add_tail(&t[1], &m);\r\nif (len % 2) {\r\n__le16 last_word;\r\nlast_word = cpu_to_le16(((u8 *)buf)[len - 1]);\r\nt[2].tx_buf = &last_word;\r\nt[2].len = sizeof(last_word);\r\nspi_message_add_tail(&t[2], &m);\r\n}\r\nspi_sync(priv->spi, &m);\r\n}\r\nstatic u32 p54spi_read32(struct p54s_priv *priv, u8 addr)\r\n{\r\n__le32 val;\r\np54spi_spi_read(priv, addr, &val, sizeof(val));\r\nreturn le32_to_cpu(val);\r\n}\r\nstatic inline void p54spi_write16(struct p54s_priv *priv, u8 addr, __le16 val)\r\n{\r\np54spi_spi_write(priv, addr, &val, sizeof(val));\r\n}\r\nstatic inline void p54spi_write32(struct p54s_priv *priv, u8 addr, __le32 val)\r\n{\r\np54spi_spi_write(priv, addr, &val, sizeof(val));\r\n}\r\nstatic int p54spi_wait_bit(struct p54s_priv *priv, u16 reg, u32 bits)\r\n{\r\nint i;\r\nfor (i = 0; i < 2000; i++) {\r\nu32 buffer = p54spi_read32(priv, reg);\r\nif ((buffer & bits) == bits)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int p54spi_spi_write_dma(struct p54s_priv *priv, __le32 base,\r\nconst void *buf, size_t len)\r\n{\r\nif (!p54spi_wait_bit(priv, SPI_ADRS_DMA_WRITE_CTRL, HOST_ALLOWED)) {\r\ndev_err(&priv->spi->dev, "spi_write_dma not allowed "\r\n"to DMA write.\n");\r\nreturn -EAGAIN;\r\n}\r\np54spi_write16(priv, SPI_ADRS_DMA_WRITE_CTRL,\r\ncpu_to_le16(SPI_DMA_WRITE_CTRL_ENABLE));\r\np54spi_write16(priv, SPI_ADRS_DMA_WRITE_LEN, cpu_to_le16(len));\r\np54spi_write32(priv, SPI_ADRS_DMA_WRITE_BASE, base);\r\np54spi_spi_write(priv, SPI_ADRS_DMA_DATA, buf, len);\r\nreturn 0;\r\n}\r\nstatic int p54spi_request_firmware(struct ieee80211_hw *dev)\r\n{\r\nstruct p54s_priv *priv = dev->priv;\r\nint ret;\r\nret = request_firmware(&priv->firmware, "3826.arm", &priv->spi->dev);\r\nif (ret < 0) {\r\ndev_err(&priv->spi->dev, "request_firmware() failed: %d", ret);\r\nreturn ret;\r\n}\r\nret = p54_parse_firmware(dev, priv->firmware);\r\nif (ret) {\r\nrelease_firmware(priv->firmware);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int p54spi_request_eeprom(struct ieee80211_hw *dev)\r\n{\r\nstruct p54s_priv *priv = dev->priv;\r\nconst struct firmware *eeprom;\r\nint ret;\r\nret = request_firmware(&eeprom, "3826.eeprom", &priv->spi->dev);\r\nif (ret < 0) {\r\n#ifdef CONFIG_P54_SPI_DEFAULT_EEPROM\r\ndev_info(&priv->spi->dev, "loading default eeprom...\n");\r\nret = p54_parse_eeprom(dev, (void *) p54spi_eeprom,\r\nsizeof(p54spi_eeprom));\r\n#else\r\ndev_err(&priv->spi->dev, "Failed to request user eeprom\n");\r\n#endif\r\n} else {\r\ndev_info(&priv->spi->dev, "loading user eeprom...\n");\r\nret = p54_parse_eeprom(dev, (void *) eeprom->data,\r\n(int)eeprom->size);\r\nrelease_firmware(eeprom);\r\n}\r\nreturn ret;\r\n}\r\nstatic int p54spi_upload_firmware(struct ieee80211_hw *dev)\r\n{\r\nstruct p54s_priv *priv = dev->priv;\r\nunsigned long fw_len, _fw_len;\r\nunsigned int offset = 0;\r\nint err = 0;\r\nu8 *fw;\r\nfw_len = priv->firmware->size;\r\nfw = kmemdup(priv->firmware->data, fw_len, GFP_KERNEL);\r\nif (!fw)\r\nreturn -ENOMEM;\r\np54spi_write16(priv, SPI_ADRS_DEV_CTRL_STAT, cpu_to_le16(\r\nSPI_CTRL_STAT_HOST_OVERRIDE | SPI_CTRL_STAT_HOST_RESET |\r\nSPI_CTRL_STAT_START_HALTED));\r\nmsleep(TARGET_BOOT_SLEEP);\r\np54spi_write16(priv, SPI_ADRS_DEV_CTRL_STAT, cpu_to_le16(\r\nSPI_CTRL_STAT_HOST_OVERRIDE |\r\nSPI_CTRL_STAT_START_HALTED));\r\nmsleep(TARGET_BOOT_SLEEP);\r\nwhile (fw_len > 0) {\r\n_fw_len = min_t(long, fw_len, SPI_MAX_PACKET_SIZE);\r\nerr = p54spi_spi_write_dma(priv, cpu_to_le32(\r\nISL38XX_DEV_FIRMWARE_ADDR + offset),\r\n(fw + offset), _fw_len);\r\nif (err < 0)\r\ngoto out;\r\nfw_len -= _fw_len;\r\noffset += _fw_len;\r\n}\r\nBUG_ON(fw_len != 0);\r\np54spi_write32(priv, SPI_ADRS_HOST_INT_EN,\r\ncpu_to_le32(SPI_HOST_INTS_DEFAULT));\r\np54spi_write16(priv, SPI_ADRS_DEV_CTRL_STAT, cpu_to_le16(\r\nSPI_CTRL_STAT_HOST_OVERRIDE | SPI_CTRL_STAT_HOST_RESET |\r\nSPI_CTRL_STAT_RAM_BOOT));\r\nmsleep(TARGET_BOOT_SLEEP);\r\np54spi_write16(priv, SPI_ADRS_DEV_CTRL_STAT, cpu_to_le16(\r\nSPI_CTRL_STAT_HOST_OVERRIDE | SPI_CTRL_STAT_RAM_BOOT));\r\nmsleep(TARGET_BOOT_SLEEP);\r\nout:\r\nkfree(fw);\r\nreturn err;\r\n}\r\nstatic void p54spi_power_off(struct p54s_priv *priv)\r\n{\r\ndisable_irq(gpio_to_irq(p54spi_gpio_irq));\r\ngpio_set_value(p54spi_gpio_power, 0);\r\n}\r\nstatic void p54spi_power_on(struct p54s_priv *priv)\r\n{\r\ngpio_set_value(p54spi_gpio_power, 1);\r\nenable_irq(gpio_to_irq(p54spi_gpio_irq));\r\nmsleep(10);\r\n}\r\nstatic inline void p54spi_int_ack(struct p54s_priv *priv, u32 val)\r\n{\r\np54spi_write32(priv, SPI_ADRS_HOST_INT_ACK, cpu_to_le32(val));\r\n}\r\nstatic int p54spi_wakeup(struct p54s_priv *priv)\r\n{\r\np54spi_write32(priv, SPI_ADRS_ARM_INTERRUPTS,\r\ncpu_to_le32(SPI_TARGET_INT_WAKEUP));\r\nif (!p54spi_wait_bit(priv, SPI_ADRS_HOST_INTERRUPTS,\r\nSPI_HOST_INT_READY)) {\r\ndev_err(&priv->spi->dev, "INT_READY timeout\n");\r\nreturn -EBUSY;\r\n}\r\np54spi_int_ack(priv, SPI_HOST_INT_READY);\r\nreturn 0;\r\n}\r\nstatic inline void p54spi_sleep(struct p54s_priv *priv)\r\n{\r\np54spi_write32(priv, SPI_ADRS_ARM_INTERRUPTS,\r\ncpu_to_le32(SPI_TARGET_INT_SLEEP));\r\n}\r\nstatic void p54spi_int_ready(struct p54s_priv *priv)\r\n{\r\np54spi_write32(priv, SPI_ADRS_HOST_INT_EN, cpu_to_le32(\r\nSPI_HOST_INT_UPDATE | SPI_HOST_INT_SW_UPDATE));\r\nswitch (priv->fw_state) {\r\ncase FW_STATE_BOOTING:\r\npriv->fw_state = FW_STATE_READY;\r\ncomplete(&priv->fw_comp);\r\nbreak;\r\ncase FW_STATE_RESETTING:\r\npriv->fw_state = FW_STATE_READY;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int p54spi_rx(struct p54s_priv *priv)\r\n{\r\nstruct sk_buff *skb;\r\nu16 len;\r\nu16 rx_head[2];\r\n#define READAHEAD_SZ (sizeof(rx_head)-sizeof(u16))\r\nif (p54spi_wakeup(priv) < 0)\r\nreturn -EBUSY;\r\np54spi_spi_read(priv, SPI_ADRS_DMA_DATA, rx_head, sizeof(rx_head));\r\nlen = rx_head[0];\r\nif (len == 0) {\r\np54spi_sleep(priv);\r\ndev_err(&priv->spi->dev, "rx request of zero bytes\n");\r\nreturn 0;\r\n}\r\nskb = dev_alloc_skb(len + 4);\r\nif (!skb) {\r\np54spi_sleep(priv);\r\ndev_err(&priv->spi->dev, "could not alloc skb");\r\nreturn -ENOMEM;\r\n}\r\nif (len <= READAHEAD_SZ) {\r\nmemcpy(skb_put(skb, len), rx_head + 1, len);\r\n} else {\r\nmemcpy(skb_put(skb, READAHEAD_SZ), rx_head + 1, READAHEAD_SZ);\r\np54spi_spi_read(priv, SPI_ADRS_DMA_DATA,\r\nskb_put(skb, len - READAHEAD_SZ),\r\nlen - READAHEAD_SZ);\r\n}\r\np54spi_sleep(priv);\r\nskb_put(skb, 4);\r\nif (p54_rx(priv->hw, skb) == 0)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t p54spi_interrupt(int irq, void *config)\r\n{\r\nstruct spi_device *spi = config;\r\nstruct p54s_priv *priv = spi_get_drvdata(spi);\r\nieee80211_queue_work(priv->hw, &priv->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int p54spi_tx_frame(struct p54s_priv *priv, struct sk_buff *skb)\r\n{\r\nstruct p54_hdr *hdr = (struct p54_hdr *) skb->data;\r\nint ret = 0;\r\nif (p54spi_wakeup(priv) < 0)\r\nreturn -EBUSY;\r\nret = p54spi_spi_write_dma(priv, hdr->req_id, skb->data, skb->len);\r\nif (ret < 0)\r\ngoto out;\r\nif (!p54spi_wait_bit(priv, SPI_ADRS_HOST_INTERRUPTS,\r\nSPI_HOST_INT_WR_READY)) {\r\ndev_err(&priv->spi->dev, "WR_READY timeout\n");\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\np54spi_int_ack(priv, SPI_HOST_INT_WR_READY);\r\nif (FREE_AFTER_TX(skb))\r\np54_free_skb(priv->hw, skb);\r\nout:\r\np54spi_sleep(priv);\r\nreturn ret;\r\n}\r\nstatic int p54spi_wq_tx(struct p54s_priv *priv)\r\n{\r\nstruct p54s_tx_info *entry;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_tx_info *info;\r\nstruct p54_tx_info *minfo;\r\nstruct p54s_tx_info *dinfo;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nwhile (!list_empty(&priv->tx_pending)) {\r\nentry = list_entry(priv->tx_pending.next,\r\nstruct p54s_tx_info, tx_list);\r\nlist_del_init(&entry->tx_list);\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\ndinfo = container_of((void *) entry, struct p54s_tx_info,\r\ntx_list);\r\nminfo = container_of((void *) dinfo, struct p54_tx_info,\r\ndata);\r\ninfo = container_of((void *) minfo, struct ieee80211_tx_info,\r\nrate_driver_data);\r\nskb = container_of((void *) info, struct sk_buff, cb);\r\nret = p54spi_tx_frame(priv, skb);\r\nif (ret < 0) {\r\np54_free_skb(priv->hw, skb);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void p54spi_op_tx(struct ieee80211_hw *dev, struct sk_buff *skb)\r\n{\r\nstruct p54s_priv *priv = dev->priv;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct p54_tx_info *mi = (struct p54_tx_info *) info->rate_driver_data;\r\nstruct p54s_tx_info *di = (struct p54s_tx_info *) mi->data;\r\nunsigned long flags;\r\nBUILD_BUG_ON(sizeof(*di) > sizeof((mi->data)));\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nlist_add_tail(&di->tx_list, &priv->tx_pending);\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nieee80211_queue_work(priv->hw, &priv->work);\r\n}\r\nstatic void p54spi_work(struct work_struct *work)\r\n{\r\nstruct p54s_priv *priv = container_of(work, struct p54s_priv, work);\r\nu32 ints;\r\nint ret;\r\nmutex_lock(&priv->mutex);\r\nif (priv->fw_state == FW_STATE_OFF)\r\ngoto out;\r\nints = p54spi_read32(priv, SPI_ADRS_HOST_INTERRUPTS);\r\nif (ints & SPI_HOST_INT_READY) {\r\np54spi_int_ready(priv);\r\np54spi_int_ack(priv, SPI_HOST_INT_READY);\r\n}\r\nif (priv->fw_state != FW_STATE_READY)\r\ngoto out;\r\nif (ints & SPI_HOST_INT_UPDATE) {\r\np54spi_int_ack(priv, SPI_HOST_INT_UPDATE);\r\nret = p54spi_rx(priv);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (ints & SPI_HOST_INT_SW_UPDATE) {\r\np54spi_int_ack(priv, SPI_HOST_INT_SW_UPDATE);\r\nret = p54spi_rx(priv);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nret = p54spi_wq_tx(priv);\r\nout:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int p54spi_op_start(struct ieee80211_hw *dev)\r\n{\r\nstruct p54s_priv *priv = dev->priv;\r\nunsigned long timeout;\r\nint ret = 0;\r\nif (mutex_lock_interruptible(&priv->mutex)) {\r\nret = -EINTR;\r\ngoto out;\r\n}\r\npriv->fw_state = FW_STATE_BOOTING;\r\np54spi_power_on(priv);\r\nret = p54spi_upload_firmware(dev);\r\nif (ret < 0) {\r\np54spi_power_off(priv);\r\ngoto out_unlock;\r\n}\r\nmutex_unlock(&priv->mutex);\r\ntimeout = msecs_to_jiffies(2000);\r\ntimeout = wait_for_completion_interruptible_timeout(&priv->fw_comp,\r\ntimeout);\r\nif (!timeout) {\r\ndev_err(&priv->spi->dev, "firmware boot failed");\r\np54spi_power_off(priv);\r\nret = -1;\r\ngoto out;\r\n}\r\nif (mutex_lock_interruptible(&priv->mutex)) {\r\nret = -EINTR;\r\np54spi_power_off(priv);\r\ngoto out;\r\n}\r\nWARN_ON(priv->fw_state != FW_STATE_READY);\r\nout_unlock:\r\nmutex_unlock(&priv->mutex);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void p54spi_op_stop(struct ieee80211_hw *dev)\r\n{\r\nstruct p54s_priv *priv = dev->priv;\r\nunsigned long flags;\r\nmutex_lock(&priv->mutex);\r\nWARN_ON(priv->fw_state != FW_STATE_READY);\r\np54spi_power_off(priv);\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nINIT_LIST_HEAD(&priv->tx_pending);\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\npriv->fw_state = FW_STATE_OFF;\r\nmutex_unlock(&priv->mutex);\r\ncancel_work_sync(&priv->work);\r\n}\r\nstatic int p54spi_probe(struct spi_device *spi)\r\n{\r\nstruct p54s_priv *priv = NULL;\r\nstruct ieee80211_hw *hw;\r\nint ret = -EINVAL;\r\nhw = p54_init_common(sizeof(*priv));\r\nif (!hw) {\r\ndev_err(&spi->dev, "could not alloc ieee80211_hw");\r\nreturn -ENOMEM;\r\n}\r\npriv = hw->priv;\r\npriv->hw = hw;\r\nspi_set_drvdata(spi, priv);\r\npriv->spi = spi;\r\nspi->bits_per_word = 16;\r\nspi->max_speed_hz = 24000000;\r\nret = spi_setup(spi);\r\nif (ret < 0) {\r\ndev_err(&priv->spi->dev, "spi_setup failed");\r\ngoto err_free;\r\n}\r\nret = gpio_request(p54spi_gpio_power, "p54spi power");\r\nif (ret < 0) {\r\ndev_err(&priv->spi->dev, "power GPIO request failed: %d", ret);\r\ngoto err_free;\r\n}\r\nret = gpio_request(p54spi_gpio_irq, "p54spi irq");\r\nif (ret < 0) {\r\ndev_err(&priv->spi->dev, "irq GPIO request failed: %d", ret);\r\ngoto err_free_gpio_power;\r\n}\r\ngpio_direction_output(p54spi_gpio_power, 0);\r\ngpio_direction_input(p54spi_gpio_irq);\r\nret = request_irq(gpio_to_irq(p54spi_gpio_irq),\r\np54spi_interrupt, 0, "p54spi",\r\npriv->spi);\r\nif (ret < 0) {\r\ndev_err(&priv->spi->dev, "request_irq() failed");\r\ngoto err_free_gpio_irq;\r\n}\r\nirq_set_irq_type(gpio_to_irq(p54spi_gpio_irq), IRQ_TYPE_EDGE_RISING);\r\ndisable_irq(gpio_to_irq(p54spi_gpio_irq));\r\nINIT_WORK(&priv->work, p54spi_work);\r\ninit_completion(&priv->fw_comp);\r\nINIT_LIST_HEAD(&priv->tx_pending);\r\nmutex_init(&priv->mutex);\r\nspin_lock_init(&priv->tx_lock);\r\nSET_IEEE80211_DEV(hw, &spi->dev);\r\npriv->common.open = p54spi_op_start;\r\npriv->common.stop = p54spi_op_stop;\r\npriv->common.tx = p54spi_op_tx;\r\nret = p54spi_request_firmware(hw);\r\nif (ret < 0)\r\ngoto err_free_common;\r\nret = p54spi_request_eeprom(hw);\r\nif (ret)\r\ngoto err_free_common;\r\nret = p54_register_common(hw, &priv->spi->dev);\r\nif (ret)\r\ngoto err_free_common;\r\nreturn 0;\r\nerr_free_common:\r\nfree_irq(gpio_to_irq(p54spi_gpio_irq), spi);\r\nerr_free_gpio_irq:\r\ngpio_free(p54spi_gpio_irq);\r\nerr_free_gpio_power:\r\ngpio_free(p54spi_gpio_power);\r\nerr_free:\r\np54_free_common(priv->hw);\r\nreturn ret;\r\n}\r\nstatic int p54spi_remove(struct spi_device *spi)\r\n{\r\nstruct p54s_priv *priv = spi_get_drvdata(spi);\r\np54_unregister_common(priv->hw);\r\nfree_irq(gpio_to_irq(p54spi_gpio_irq), spi);\r\ngpio_free(p54spi_gpio_power);\r\ngpio_free(p54spi_gpio_irq);\r\nrelease_firmware(priv->firmware);\r\nmutex_destroy(&priv->mutex);\r\np54_free_common(priv->hw);\r\nreturn 0;\r\n}
