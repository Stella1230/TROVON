static inline void idle_loop_prolog(unsigned long *in_purr)\r\n{\r\nppc64_runlatch_off();\r\n*in_purr = mfspr(SPRN_PURR);\r\nget_lppaca()->idle = 1;\r\n}\r\nstatic inline void idle_loop_epilog(unsigned long in_purr)\r\n{\r\nu64 wait_cycles;\r\nwait_cycles = be64_to_cpu(get_lppaca()->wait_state_cycles);\r\nwait_cycles += mfspr(SPRN_PURR) - in_purr;\r\nget_lppaca()->wait_state_cycles = cpu_to_be64(wait_cycles);\r\nget_lppaca()->idle = 0;\r\nif (irqs_disabled())\r\nlocal_irq_enable();\r\nppc64_runlatch_on();\r\n}\r\nstatic int snooze_loop(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nunsigned long in_purr;\r\nidle_loop_prolog(&in_purr);\r\nlocal_irq_enable();\r\nset_thread_flag(TIF_POLLING_NRFLAG);\r\nwhile (!need_resched()) {\r\nHMT_low();\r\nHMT_very_low();\r\n}\r\nHMT_medium();\r\nclear_thread_flag(TIF_POLLING_NRFLAG);\r\nsmp_mb();\r\nidle_loop_epilog(in_purr);\r\nreturn index;\r\n}\r\nstatic void check_and_cede_processor(void)\r\n{\r\nif (prep_irq_for_idle()) {\r\ncede_processor();\r\n#ifdef CONFIG_TRACE_IRQFLAGS\r\nif (WARN_ON(!(mfmsr() & MSR_EE)))\r\n__hard_irq_enable();\r\n#endif\r\n}\r\n}\r\nstatic int dedicated_cede_loop(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nunsigned long in_purr;\r\nidle_loop_prolog(&in_purr);\r\nget_lppaca()->donate_dedicated_cpu = 1;\r\nHMT_medium();\r\ncheck_and_cede_processor();\r\nget_lppaca()->donate_dedicated_cpu = 0;\r\nidle_loop_epilog(in_purr);\r\nreturn index;\r\n}\r\nstatic int shared_cede_loop(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nunsigned long in_purr;\r\nidle_loop_prolog(&in_purr);\r\ncheck_and_cede_processor();\r\nidle_loop_epilog(in_purr);\r\nreturn index;\r\n}\r\nstatic int pseries_cpuidle_add_cpu_notifier(struct notifier_block *n,\r\nunsigned long action, void *hcpu)\r\n{\r\nint hotcpu = (unsigned long)hcpu;\r\nstruct cpuidle_device *dev =\r\nper_cpu(cpuidle_devices, hotcpu);\r\nif (dev && cpuidle_get_driver()) {\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\ncpuidle_pause_and_lock();\r\ncpuidle_enable_device(dev);\r\ncpuidle_resume_and_unlock();\r\nbreak;\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\ncpuidle_pause_and_lock();\r\ncpuidle_disable_device(dev);\r\ncpuidle_resume_and_unlock();\r\nbreak;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int pseries_cpuidle_driver_init(void)\r\n{\r\nint idle_state;\r\nstruct cpuidle_driver *drv = &pseries_idle_driver;\r\ndrv->state_count = 0;\r\nfor (idle_state = 0; idle_state < max_idle_state; ++idle_state) {\r\nif (cpuidle_state_table[idle_state].enter == NULL)\r\ncontinue;\r\ndrv->states[drv->state_count] =\r\ncpuidle_state_table[idle_state];\r\ndrv->state_count += 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pseries_idle_probe(void)\r\n{\r\nif (cpuidle_disable != IDLE_NO_OVERRIDE)\r\nreturn -ENODEV;\r\nif (firmware_has_feature(FW_FEATURE_SPLPAR)) {\r\nif (lppaca_shared_proc(get_lppaca())) {\r\ncpuidle_state_table = shared_states;\r\nmax_idle_state = ARRAY_SIZE(shared_states);\r\n} else {\r\ncpuidle_state_table = dedicated_states;\r\nmax_idle_state = ARRAY_SIZE(dedicated_states);\r\n}\r\n} else\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int __init pseries_processor_idle_init(void)\r\n{\r\nint retval;\r\nretval = pseries_idle_probe();\r\nif (retval)\r\nreturn retval;\r\npseries_cpuidle_driver_init();\r\nretval = cpuidle_register(&pseries_idle_driver, NULL);\r\nif (retval) {\r\nprintk(KERN_DEBUG "Registration of pseries driver failed.\n");\r\nreturn retval;\r\n}\r\nregister_cpu_notifier(&setup_hotplug_notifier);\r\nprintk(KERN_DEBUG "pseries_idle_driver registered\n");\r\nreturn 0;\r\n}
