static void aaci_ac97_select_codec(struct aaci *aaci, struct snd_ac97 *ac97)\r\n{\r\nu32 v, maincr = aaci->maincr | MAINCR_SCRA(ac97->num);\r\nv = readl(aaci->base + AACI_SLFR);\r\nif (v & SLFR_2RXV)\r\nreadl(aaci->base + AACI_SL2RX);\r\nif (v & SLFR_1RXV)\r\nreadl(aaci->base + AACI_SL1RX);\r\nif (maincr != readl(aaci->base + AACI_MAINCR)) {\r\nwritel(maincr, aaci->base + AACI_MAINCR);\r\nreadl(aaci->base + AACI_MAINCR);\r\nudelay(1);\r\n}\r\n}\r\nstatic void aaci_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct aaci *aaci = ac97->private_data;\r\nint timeout;\r\nu32 v;\r\nif (ac97->num >= 4)\r\nreturn;\r\nmutex_lock(&aaci->ac97_sem);\r\naaci_ac97_select_codec(aaci, ac97);\r\nwritel(val << 4, aaci->base + AACI_SL2TX);\r\nwritel(reg << 12, aaci->base + AACI_SL1TX);\r\nudelay(FRAME_PERIOD_US);\r\ntimeout = FRAME_PERIOD_US * 8;\r\ndo {\r\nudelay(1);\r\nv = readl(aaci->base + AACI_SLFR);\r\n} while ((v & (SLFR_1TXB|SLFR_2TXB)) && --timeout);\r\nif (v & (SLFR_1TXB|SLFR_2TXB))\r\ndev_err(&aaci->dev->dev,\r\n"timeout waiting for write to complete\n");\r\nmutex_unlock(&aaci->ac97_sem);\r\n}\r\nstatic unsigned short aaci_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct aaci *aaci = ac97->private_data;\r\nint timeout, retries = 10;\r\nu32 v;\r\nif (ac97->num >= 4)\r\nreturn ~0;\r\nmutex_lock(&aaci->ac97_sem);\r\naaci_ac97_select_codec(aaci, ac97);\r\nwritel((reg << 12) | (1 << 19), aaci->base + AACI_SL1TX);\r\nudelay(FRAME_PERIOD_US);\r\ntimeout = FRAME_PERIOD_US * 8;\r\ndo {\r\nudelay(1);\r\nv = readl(aaci->base + AACI_SLFR);\r\n} while ((v & SLFR_1TXB) && --timeout);\r\nif (v & SLFR_1TXB) {\r\ndev_err(&aaci->dev->dev, "timeout on slot 1 TX busy\n");\r\nv = ~0;\r\ngoto out;\r\n}\r\nudelay(FRAME_PERIOD_US);\r\ntimeout = FRAME_PERIOD_US * 8;\r\ndo {\r\nudelay(1);\r\ncond_resched();\r\nv = readl(aaci->base + AACI_SLFR) & (SLFR_1RXV|SLFR_2RXV);\r\n} while ((v != (SLFR_1RXV|SLFR_2RXV)) && --timeout);\r\nif (v != (SLFR_1RXV|SLFR_2RXV)) {\r\ndev_err(&aaci->dev->dev, "timeout on RX valid\n");\r\nv = ~0;\r\ngoto out;\r\n}\r\ndo {\r\nv = readl(aaci->base + AACI_SL1RX) >> 12;\r\nif (v == reg) {\r\nv = readl(aaci->base + AACI_SL2RX) >> 4;\r\nbreak;\r\n} else if (--retries) {\r\ndev_warn(&aaci->dev->dev,\r\n"ac97 read back fail. retry\n");\r\ncontinue;\r\n} else {\r\ndev_warn(&aaci->dev->dev,\r\n"wrong ac97 register read back (%x != %x)\n",\r\nv, reg);\r\nv = ~0;\r\n}\r\n} while (retries);\r\nout:\r\nmutex_unlock(&aaci->ac97_sem);\r\nreturn v;\r\n}\r\nstatic inline void\r\naaci_chan_wait_ready(struct aaci_runtime *aacirun, unsigned long mask)\r\n{\r\nu32 val;\r\nint timeout = 5000;\r\ndo {\r\nudelay(1);\r\nval = readl(aacirun->base + AACI_SR);\r\n} while (val & mask && timeout--);\r\n}\r\nstatic void aaci_fifo_irq(struct aaci *aaci, int channel, u32 mask)\r\n{\r\nif (mask & ISR_ORINTR) {\r\ndev_warn(&aaci->dev->dev, "RX overrun on chan %d\n", channel);\r\nwritel(ICLR_RXOEC1 << channel, aaci->base + AACI_INTCLR);\r\n}\r\nif (mask & ISR_RXTOINTR) {\r\ndev_warn(&aaci->dev->dev, "RX timeout on chan %d\n", channel);\r\nwritel(ICLR_RXTOFEC1 << channel, aaci->base + AACI_INTCLR);\r\n}\r\nif (mask & ISR_RXINTR) {\r\nstruct aaci_runtime *aacirun = &aaci->capture;\r\nbool period_elapsed = false;\r\nvoid *ptr;\r\nif (!aacirun->substream || !aacirun->start) {\r\ndev_warn(&aaci->dev->dev, "RX interrupt???\n");\r\nwritel(0, aacirun->base + AACI_IE);\r\nreturn;\r\n}\r\nspin_lock(&aacirun->lock);\r\nptr = aacirun->ptr;\r\ndo {\r\nunsigned int len = aacirun->fifo_bytes;\r\nu32 val;\r\nif (aacirun->bytes <= 0) {\r\naacirun->bytes += aacirun->period;\r\nperiod_elapsed = true;\r\n}\r\nif (!(aacirun->cr & CR_EN))\r\nbreak;\r\nval = readl(aacirun->base + AACI_SR);\r\nif (!(val & SR_RXHF))\r\nbreak;\r\nif (!(val & SR_RXFF))\r\nlen >>= 1;\r\naacirun->bytes -= len;\r\nfor( ; len > 0; len -= 16) {\r\nasm(\r\n"ldmia %1, {r0, r1, r2, r3}\n\t"\r\n"stmia %0!, {r0, r1, r2, r3}"\r\n: "+r" (ptr)\r\n: "r" (aacirun->fifo)\r\n: "r0", "r1", "r2", "r3", "cc");\r\nif (ptr >= aacirun->end)\r\nptr = aacirun->start;\r\n}\r\n} while(1);\r\naacirun->ptr = ptr;\r\nspin_unlock(&aacirun->lock);\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(aacirun->substream);\r\n}\r\nif (mask & ISR_URINTR) {\r\ndev_dbg(&aaci->dev->dev, "TX underrun on chan %d\n", channel);\r\nwritel(ICLR_TXUEC1 << channel, aaci->base + AACI_INTCLR);\r\n}\r\nif (mask & ISR_TXINTR) {\r\nstruct aaci_runtime *aacirun = &aaci->playback;\r\nbool period_elapsed = false;\r\nvoid *ptr;\r\nif (!aacirun->substream || !aacirun->start) {\r\ndev_warn(&aaci->dev->dev, "TX interrupt???\n");\r\nwritel(0, aacirun->base + AACI_IE);\r\nreturn;\r\n}\r\nspin_lock(&aacirun->lock);\r\nptr = aacirun->ptr;\r\ndo {\r\nunsigned int len = aacirun->fifo_bytes;\r\nu32 val;\r\nif (aacirun->bytes <= 0) {\r\naacirun->bytes += aacirun->period;\r\nperiod_elapsed = true;\r\n}\r\nif (!(aacirun->cr & CR_EN))\r\nbreak;\r\nval = readl(aacirun->base + AACI_SR);\r\nif (!(val & SR_TXHE))\r\nbreak;\r\nif (!(val & SR_TXFE))\r\nlen >>= 1;\r\naacirun->bytes -= len;\r\nfor ( ; len > 0; len -= 16) {\r\nasm(\r\n"ldmia %0!, {r0, r1, r2, r3}\n\t"\r\n"stmia %1, {r0, r1, r2, r3}"\r\n: "+r" (ptr)\r\n: "r" (aacirun->fifo)\r\n: "r0", "r1", "r2", "r3", "cc");\r\nif (ptr >= aacirun->end)\r\nptr = aacirun->start;\r\n}\r\n} while (1);\r\naacirun->ptr = ptr;\r\nspin_unlock(&aacirun->lock);\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(aacirun->substream);\r\n}\r\n}\r\nstatic irqreturn_t aaci_irq(int irq, void *devid)\r\n{\r\nstruct aaci *aaci = devid;\r\nu32 mask;\r\nint i;\r\nmask = readl(aaci->base + AACI_ALLINTS);\r\nif (mask) {\r\nu32 m = mask;\r\nfor (i = 0; i < 4; i++, m >>= 7) {\r\nif (m & 0x7f) {\r\naaci_fifo_irq(aaci, i, m);\r\n}\r\n}\r\n}\r\nreturn mask ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int aaci_rule_channels(struct snd_pcm_hw_params *p,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstatic unsigned int channel_list[] = { 2, 4, 6 };\r\nstruct aaci *aaci = rule->private;\r\nunsigned int mask = 1 << 0, slots;\r\nslots = aaci->ac97_bus->pcms[0].r[0].slots;\r\nif (slots & (1 << AC97_SLOT_PCM_SLEFT)) {\r\nmask |= 1 << 1;\r\nif (slots & (1 << AC97_SLOT_LFE))\r\nmask |= 1 << 2;\r\n}\r\nreturn snd_interval_list(hw_param_interval(p, rule->var),\r\nARRAY_SIZE(channel_list), channel_list, mask);\r\n}\r\nstatic int aaci_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct aaci *aaci = substream->private_data;\r\nstruct aaci_runtime *aacirun;\r\nint ret = 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\naacirun = &aaci->playback;\r\n} else {\r\naacirun = &aaci->capture;\r\n}\r\naacirun->substream = substream;\r\nruntime->private_data = aacirun;\r\nruntime->hw = aaci_hw_info;\r\nruntime->hw.rates = aacirun->pcm->rates;\r\nsnd_pcm_limit_hw_rates(runtime);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nruntime->hw.channels_max = 6;\r\nret = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\naaci_rule_channels, aaci,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (ret)\r\nreturn ret;\r\nif (aacirun->pcm->r[1].slots)\r\nsnd_ac97_pcm_double_rate_rules(runtime);\r\n}\r\nruntime->hw.fifo_size = aaci->fifo_depth * 2;\r\nmutex_lock(&aaci->irq_lock);\r\nif (!aaci->users++) {\r\nret = request_irq(aaci->dev->irq[0], aaci_irq,\r\nIRQF_SHARED, DRIVER_NAME, aaci);\r\nif (ret != 0)\r\naaci->users--;\r\n}\r\nmutex_unlock(&aaci->irq_lock);\r\nreturn ret;\r\n}\r\nstatic int aaci_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct aaci *aaci = substream->private_data;\r\nstruct aaci_runtime *aacirun = substream->runtime->private_data;\r\nWARN_ON(aacirun->cr & CR_EN);\r\naacirun->substream = NULL;\r\nmutex_lock(&aaci->irq_lock);\r\nif (!--aaci->users)\r\nfree_irq(aaci->dev->irq[0], aaci);\r\nmutex_unlock(&aaci->irq_lock);\r\nreturn 0;\r\n}\r\nstatic int aaci_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct aaci_runtime *aacirun = substream->runtime->private_data;\r\nWARN_ON(aacirun->cr & CR_EN);\r\nif (aacirun->pcm_open)\r\nsnd_ac97_pcm_close(aacirun->pcm);\r\naacirun->pcm_open = 0;\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int aaci_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct aaci_runtime *aacirun = substream->runtime->private_data;\r\nunsigned int channels = params_channels(params);\r\nunsigned int rate = params_rate(params);\r\nint dbl = rate > 48000;\r\nint err;\r\naaci_pcm_hw_free(substream);\r\nif (aacirun->pcm_open) {\r\nsnd_ac97_pcm_close(aacirun->pcm);\r\naacirun->pcm_open = 0;\r\n}\r\nif (dbl && channels != 2)\r\nreturn -EINVAL;\r\nerr = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(params));\r\nif (err >= 0) {\r\nstruct aaci *aaci = substream->private_data;\r\nerr = snd_ac97_pcm_open(aacirun->pcm, rate, channels,\r\naacirun->pcm->r[dbl].slots);\r\naacirun->pcm_open = err == 0;\r\naacirun->cr = CR_FEN | CR_COMPACT | CR_SZ16;\r\naacirun->cr |= channels_to_slotmask[channels + dbl * 2];\r\naacirun->fifo_bytes = aaci->fifo_depth * 4 / 2;\r\n}\r\nreturn err;\r\n}\r\nstatic int aaci_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct aaci_runtime *aacirun = runtime->private_data;\r\naacirun->period = snd_pcm_lib_period_bytes(substream);\r\naacirun->start = runtime->dma_area;\r\naacirun->end = aacirun->start + snd_pcm_lib_buffer_bytes(substream);\r\naacirun->ptr = aacirun->start;\r\naacirun->bytes = aacirun->period;\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t aaci_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct aaci_runtime *aacirun = runtime->private_data;\r\nssize_t bytes = aacirun->ptr - aacirun->start;\r\nreturn bytes_to_frames(runtime, bytes);\r\n}\r\nstatic void aaci_pcm_playback_stop(struct aaci_runtime *aacirun)\r\n{\r\nu32 ie;\r\nie = readl(aacirun->base + AACI_IE);\r\nie &= ~(IE_URIE|IE_TXIE);\r\nwritel(ie, aacirun->base + AACI_IE);\r\naacirun->cr &= ~CR_EN;\r\naaci_chan_wait_ready(aacirun, SR_TXB);\r\nwritel(aacirun->cr, aacirun->base + AACI_TXCR);\r\n}\r\nstatic void aaci_pcm_playback_start(struct aaci_runtime *aacirun)\r\n{\r\nu32 ie;\r\naaci_chan_wait_ready(aacirun, SR_TXB);\r\naacirun->cr |= CR_EN;\r\nie = readl(aacirun->base + AACI_IE);\r\nie |= IE_URIE | IE_TXIE;\r\nwritel(ie, aacirun->base + AACI_IE);\r\nwritel(aacirun->cr, aacirun->base + AACI_TXCR);\r\n}\r\nstatic int aaci_pcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct aaci_runtime *aacirun = substream->runtime->private_data;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&aacirun->lock, flags);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\naaci_pcm_playback_start(aacirun);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\naaci_pcm_playback_start(aacirun);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\naaci_pcm_playback_stop(aacirun);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\naaci_pcm_playback_stop(aacirun);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&aacirun->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void aaci_pcm_capture_stop(struct aaci_runtime *aacirun)\r\n{\r\nu32 ie;\r\naaci_chan_wait_ready(aacirun, SR_RXB);\r\nie = readl(aacirun->base + AACI_IE);\r\nie &= ~(IE_ORIE | IE_RXIE);\r\nwritel(ie, aacirun->base+AACI_IE);\r\naacirun->cr &= ~CR_EN;\r\nwritel(aacirun->cr, aacirun->base + AACI_RXCR);\r\n}\r\nstatic void aaci_pcm_capture_start(struct aaci_runtime *aacirun)\r\n{\r\nu32 ie;\r\naaci_chan_wait_ready(aacirun, SR_RXB);\r\n#ifdef DEBUG\r\naacirun->cr |= 0xf << 17;\r\n#endif\r\naacirun->cr |= CR_EN;\r\nwritel(aacirun->cr, aacirun->base + AACI_RXCR);\r\nie = readl(aacirun->base + AACI_IE);\r\nie |= IE_ORIE |IE_RXIE;\r\nwritel(ie, aacirun->base + AACI_IE);\r\n}\r\nstatic int aaci_pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct aaci_runtime *aacirun = substream->runtime->private_data;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&aacirun->lock, flags);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\naaci_pcm_capture_start(aacirun);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\naaci_pcm_capture_start(aacirun);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\naaci_pcm_capture_stop(aacirun);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\naaci_pcm_capture_stop(aacirun);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&aacirun->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int aaci_pcm_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct aaci *aaci = substream->private_data;\r\naaci_pcm_prepare(substream);\r\naaci_ac97_write(aaci->ac97, AC97_EXTENDED_STATUS, 0x0001);\r\naaci_ac97_write(aaci->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);\r\naaci_ac97_write(aaci->ac97, AC97_PCM_MIC_ADC_RATE, runtime->rate);\r\naaci_ac97_write(aaci->ac97, AC97_REC_SEL, 0x0404);\r\nreturn 0;\r\n}\r\nstatic int aaci_do_suspend(struct snd_card *card)\r\n{\r\nstruct aaci *aaci = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3cold);\r\nsnd_pcm_suspend_all(aaci->pcm);\r\nreturn 0;\r\n}\r\nstatic int aaci_do_resume(struct snd_card *card)\r\n{\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int aaci_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nreturn card ? aaci_do_suspend(card) : 0;\r\n}\r\nstatic int aaci_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nreturn card ? aaci_do_resume(card) : 0;\r\n}\r\nstatic int aaci_probe_ac97(struct aaci *aaci)\r\n{\r\nstruct snd_ac97_template ac97_template;\r\nstruct snd_ac97_bus *ac97_bus;\r\nstruct snd_ac97 *ac97;\r\nint ret;\r\nwritel(0, aaci->base + AACI_RESET);\r\nudelay(2);\r\nwritel(RESET_NRST, aaci->base + AACI_RESET);\r\nudelay(FRAME_PERIOD_US * 2);\r\nret = snd_ac97_bus(aaci->card, 0, &aaci_bus_ops, aaci, &ac97_bus);\r\nif (ret)\r\ngoto out;\r\nac97_bus->clock = 48000;\r\naaci->ac97_bus = ac97_bus;\r\nmemset(&ac97_template, 0, sizeof(struct snd_ac97_template));\r\nac97_template.private_data = aaci;\r\nac97_template.num = 0;\r\nac97_template.scaps = AC97_SCAP_SKIP_MODEM;\r\nret = snd_ac97_mixer(ac97_bus, &ac97_template, &ac97);\r\nif (ret)\r\ngoto out;\r\naaci->ac97 = ac97;\r\nif (ac97_is_audio(ac97))\r\nsnd_ac97_write_cache(ac97, AC97_PC_BEEP, 0x801e);\r\nret = snd_ac97_pcm_assign(ac97_bus, ARRAY_SIZE(ac97_defs), ac97_defs);\r\nif (ret)\r\ngoto out;\r\naaci->playback.pcm = &ac97_bus->pcms[0];\r\naaci->capture.pcm = &ac97_bus->pcms[1];\r\nout:\r\nreturn ret;\r\n}\r\nstatic void aaci_free_card(struct snd_card *card)\r\n{\r\nstruct aaci *aaci = card->private_data;\r\nif (aaci->base)\r\niounmap(aaci->base);\r\n}\r\nstatic struct aaci *aaci_init_card(struct amba_device *dev)\r\n{\r\nstruct aaci *aaci;\r\nstruct snd_card *card;\r\nint err;\r\nerr = snd_card_new(&dev->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\r\nTHIS_MODULE, sizeof(struct aaci), &card);\r\nif (err < 0)\r\nreturn NULL;\r\ncard->private_free = aaci_free_card;\r\nstrlcpy(card->driver, DRIVER_NAME, sizeof(card->driver));\r\nstrlcpy(card->shortname, "ARM AC'97 Interface", sizeof(card->shortname));\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s PL%03x rev%u at 0x%08llx, irq %d",\r\ncard->shortname, amba_part(dev), amba_rev(dev),\r\n(unsigned long long)dev->res.start, dev->irq[0]);\r\naaci = card->private_data;\r\nmutex_init(&aaci->ac97_sem);\r\nmutex_init(&aaci->irq_lock);\r\naaci->card = card;\r\naaci->dev = dev;\r\naaci->maincr = MAINCR_IE | MAINCR_SL1RXEN | MAINCR_SL1TXEN |\r\nMAINCR_SL2RXEN | MAINCR_SL2TXEN;\r\nreturn aaci;\r\n}\r\nstatic int aaci_init_pcm(struct aaci *aaci)\r\n{\r\nstruct snd_pcm *pcm;\r\nint ret;\r\nret = snd_pcm_new(aaci->card, "AACI AC'97", 0, 1, 1, &pcm);\r\nif (ret == 0) {\r\naaci->pcm = pcm;\r\npcm->private_data = aaci;\r\npcm->info_flags = 0;\r\nstrlcpy(pcm->name, DRIVER_NAME, sizeof(pcm->name));\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &aaci_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &aaci_capture_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nNULL, 0, 64 * 1024);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int aaci_size_fifo(struct aaci *aaci)\r\n{\r\nstruct aaci_runtime *aacirun = &aaci->playback;\r\nint i;\r\nwritel(CR_FEN | CR_SZ16 | CR_EN, aacirun->base + AACI_TXCR);\r\nfor (i = 0; !(readl(aacirun->base + AACI_SR) & SR_TXFF) && i < 4096; i++)\r\nwritel(0, aacirun->fifo);\r\nwritel(0, aacirun->base + AACI_TXCR);\r\nwritel(aaci->maincr & ~MAINCR_IE, aaci->base + AACI_MAINCR);\r\nreadl(aaci->base + AACI_MAINCR);\r\nudelay(1);\r\nwritel(aaci->maincr, aaci->base + AACI_MAINCR);\r\nif (i == 4096)\r\ni = 8;\r\nreturn i;\r\n}\r\nstatic int aaci_probe(struct amba_device *dev,\r\nconst struct amba_id *id)\r\n{\r\nstruct aaci *aaci;\r\nint ret, i;\r\nret = amba_request_regions(dev, NULL);\r\nif (ret)\r\nreturn ret;\r\naaci = aaci_init_card(dev);\r\nif (!aaci) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\naaci->base = ioremap(dev->res.start, resource_size(&dev->res));\r\nif (!aaci->base) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nspin_lock_init(&aaci->playback.lock);\r\naaci->playback.base = aaci->base + AACI_CSCH1;\r\naaci->playback.fifo = aaci->base + AACI_DR1;\r\nspin_lock_init(&aaci->capture.lock);\r\naaci->capture.base = aaci->base + AACI_CSCH1;\r\naaci->capture.fifo = aaci->base + AACI_DR1;\r\nfor (i = 0; i < 4; i++) {\r\nvoid __iomem *base = aaci->base + i * 0x14;\r\nwritel(0, base + AACI_IE);\r\nwritel(0, base + AACI_TXCR);\r\nwritel(0, base + AACI_RXCR);\r\n}\r\nwritel(0x1fff, aaci->base + AACI_INTCLR);\r\nwritel(aaci->maincr, aaci->base + AACI_MAINCR);\r\nreadl(aaci->base + AACI_CSCH1);\r\nret = aaci_probe_ac97(aaci);\r\nif (ret)\r\ngoto out;\r\naaci->fifo_depth = aaci_size_fifo(aaci);\r\nif (aaci->fifo_depth & 15) {\r\nprintk(KERN_WARNING "AACI: FIFO depth %d not supported\n",\r\naaci->fifo_depth);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = aaci_init_pcm(aaci);\r\nif (ret)\r\ngoto out;\r\nret = snd_card_register(aaci->card);\r\nif (ret == 0) {\r\ndev_info(&dev->dev, "%s\n", aaci->card->longname);\r\ndev_info(&dev->dev, "FIFO %u entries\n", aaci->fifo_depth);\r\namba_set_drvdata(dev, aaci->card);\r\nreturn ret;\r\n}\r\nout:\r\nif (aaci)\r\nsnd_card_free(aaci->card);\r\namba_release_regions(dev);\r\nreturn ret;\r\n}\r\nstatic int aaci_remove(struct amba_device *dev)\r\n{\r\nstruct snd_card *card = amba_get_drvdata(dev);\r\nif (card) {\r\nstruct aaci *aaci = card->private_data;\r\nwritel(0, aaci->base + AACI_MAINCR);\r\nsnd_card_free(card);\r\namba_release_regions(dev);\r\n}\r\nreturn 0;\r\n}
