int shub1_bte_error_handler(unsigned long _nodepda)\r\n{\r\nstruct nodepda_s *err_nodepda = (struct nodepda_s *)_nodepda;\r\nstruct timer_list *recovery_timer = &err_nodepda->bte_recovery_timer;\r\nnasid_t nasid;\r\nint i;\r\nint valid_crbs;\r\nii_imem_u_t imem;\r\nii_icrb0_d_u_t icrbd;\r\nii_ibcr_u_t ibcr;\r\nii_icmr_u_t icmr;\r\nii_ieclr_u_t ieclr;\r\nBTE_PRINTK(("shub1_bte_error_handler(%p) - %d\n", err_nodepda,\r\nsmp_processor_id()));\r\nif ((err_nodepda->bte_if[0].bh_error == BTE_SUCCESS) &&\r\n(err_nodepda->bte_if[1].bh_error == BTE_SUCCESS)) {\r\nBTE_PRINTK(("eh:%p:%d Nothing to do.\n", err_nodepda,\r\nsmp_processor_id()));\r\nreturn 1;\r\n}\r\nnasid = cnodeid_to_nasid(err_nodepda->bte_if[0].bte_cnode);\r\nicmr.ii_icmr_regval = REMOTE_HUB_L(nasid, IIO_ICMR);\r\nif (icmr.ii_icmr_fld_s.i_crb_mark != 0) {\r\nmod_timer(recovery_timer, jiffies + (HZ * 5));\r\nBTE_PRINTK(("eh:%p:%d Marked Giving up\n", err_nodepda,\r\nsmp_processor_id()));\r\nreturn 1;\r\n}\r\nif (icmr.ii_icmr_fld_s.i_crb_vld != 0) {\r\nvalid_crbs = icmr.ii_icmr_fld_s.i_crb_vld;\r\nfor (i = 0; i < IIO_NUM_CRBS; i++) {\r\nif (!((1 << i) & valid_crbs)) {\r\ncontinue;\r\n}\r\nicrbd.ii_icrb0_d_regval =\r\nREMOTE_HUB_L(nasid, IIO_ICRB_D(i));\r\nif (icrbd.d_bteop) {\r\nmod_timer(recovery_timer, jiffies + (HZ * 5));\r\nBTE_PRINTK(("eh:%p:%d Valid %d, Giving up\n",\r\nerr_nodepda, smp_processor_id(),\r\ni));\r\nreturn 1;\r\n}\r\n}\r\n}\r\nBTE_PRINTK(("eh:%p:%d Cleaning up\n", err_nodepda, smp_processor_id()));\r\nimem.ii_imem_regval = REMOTE_HUB_L(nasid, IIO_IMEM);\r\nimem.ii_imem_fld_s.i_b0_esd = imem.ii_imem_fld_s.i_b1_esd = 1;\r\nREMOTE_HUB_S(nasid, IIO_IMEM, imem.ii_imem_regval);\r\nieclr.ii_ieclr_regval = 0;\r\nif (err_nodepda->bte_if[0].bh_error != BTE_SUCCESS)\r\nieclr.ii_ieclr_fld_s.i_e_bte_0 = 1;\r\nif (err_nodepda->bte_if[1].bh_error != BTE_SUCCESS)\r\nieclr.ii_ieclr_fld_s.i_e_bte_1 = 1;\r\nREMOTE_HUB_S(nasid, IIO_IECLR, ieclr.ii_ieclr_regval);\r\nibcr.ii_ibcr_regval = REMOTE_HUB_L(nasid, IIO_IBCR);\r\nibcr.ii_ibcr_fld_s.i_soft_reset = 1;\r\nREMOTE_HUB_S(nasid, IIO_IBCR, ibcr.ii_ibcr_regval);\r\ndel_timer(recovery_timer);\r\nreturn 0;\r\n}\r\nint shub2_bte_error_handler(unsigned long _nodepda)\r\n{\r\nstruct nodepda_s *err_nodepda = (struct nodepda_s *)_nodepda;\r\nstruct timer_list *recovery_timer = &err_nodepda->bte_recovery_timer;\r\nstruct bteinfo_s *bte;\r\nnasid_t nasid;\r\nu64 status;\r\nint i;\r\nnasid = cnodeid_to_nasid(err_nodepda->bte_if[0].bte_cnode);\r\nfor (i = 0; i < BTES_PER_NODE; i++) {\r\nbte = &err_nodepda->bte_if[i];\r\nstatus = BTE_LNSTAT_LOAD(bte);\r\nif (status & IBLS_ERROR) {\r\nbte->bh_error = BTE_SHUB2_ERROR(status);\r\ncontinue;\r\n}\r\nif (!(status & IBLS_BUSY))\r\ncontinue;\r\nmod_timer(recovery_timer, jiffies + (HZ * 5));\r\nBTE_PRINTK(("eh:%p:%d Marked Giving up\n", err_nodepda,\r\nsmp_processor_id()));\r\nreturn 1;\r\n}\r\nif (ia64_sn_bte_recovery(nasid))\r\npanic("bte_error_handler(): Fatal BTE Error");\r\ndel_timer(recovery_timer);\r\nreturn 0;\r\n}\r\nvoid bte_error_handler(unsigned long _nodepda)\r\n{\r\nstruct nodepda_s *err_nodepda = (struct nodepda_s *)_nodepda;\r\nspinlock_t *recovery_lock = &err_nodepda->bte_recovery_lock;\r\nint i;\r\nunsigned long irq_flags;\r\nvolatile u64 *notify;\r\nbte_result_t bh_error;\r\nBTE_PRINTK(("bte_error_handler(%p) - %d\n", err_nodepda,\r\nsmp_processor_id()));\r\nspin_lock_irqsave(recovery_lock, irq_flags);\r\nfor (i = 0; i < BTES_PER_NODE; i++) {\r\nif (err_nodepda->bte_if[i].cleanup_active) {\r\ncontinue;\r\n}\r\nspin_lock(&err_nodepda->bte_if[i].spinlock);\r\nBTE_PRINTK(("eh:%p:%d locked %d\n", err_nodepda,\r\nsmp_processor_id(), i));\r\nerr_nodepda->bte_if[i].cleanup_active = 1;\r\n}\r\nif (is_shub1()) {\r\nif (shub1_bte_error_handler(_nodepda)) {\r\nspin_unlock_irqrestore(recovery_lock, irq_flags);\r\nreturn;\r\n}\r\n} else {\r\nif (shub2_bte_error_handler(_nodepda)) {\r\nspin_unlock_irqrestore(recovery_lock, irq_flags);\r\nreturn;\r\n}\r\n}\r\nfor (i = 0; i < BTES_PER_NODE; i++) {\r\nbh_error = err_nodepda->bte_if[i].bh_error;\r\nif (bh_error != BTE_SUCCESS) {\r\nnotify = err_nodepda->bte_if[i].most_rcnt_na;\r\nBTE_PRINTK(("cnode %d bte %d error=0x%lx\n",\r\nerr_nodepda->bte_if[i].bte_cnode,\r\nerr_nodepda->bte_if[i].bte_num,\r\nIBLS_ERROR | (u64) bh_error));\r\n*notify = IBLS_ERROR | bh_error;\r\nerr_nodepda->bte_if[i].bh_error = BTE_SUCCESS;\r\n}\r\nerr_nodepda->bte_if[i].cleanup_active = 0;\r\nBTE_PRINTK(("eh:%p:%d Unlocked %d\n", err_nodepda,\r\nsmp_processor_id(), i));\r\nspin_unlock(&err_nodepda->bte_if[i].spinlock);\r\n}\r\nspin_unlock_irqrestore(recovery_lock, irq_flags);\r\n}\r\nvoid\r\nbte_crb_error_handler(cnodeid_t cnode, int btenum,\r\nint crbnum, ioerror_t * ioe, int bteop)\r\n{\r\nstruct bteinfo_s *bte;\r\nbte = &(NODEPDA(cnode)->bte_if[btenum]);\r\nbte->bh_error = ioe->ie_errortype + BTEFAIL_OFFSET;\r\nbte->bte_error_count++;\r\nBTE_PRINTK(("Got an error on cnode %d bte %d: HW error type 0x%x\n",\r\nbte->bte_cnode, bte->bte_num, ioe->ie_errortype));\r\nbte_error_handler((unsigned long) NODEPDA(cnode));\r\n}
