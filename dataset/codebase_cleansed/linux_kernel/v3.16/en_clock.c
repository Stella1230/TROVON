int mlx4_en_timestamp_config(struct net_device *dev, int tx_type, int rx_filter)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint port_up = 0;\r\nint err = 0;\r\nif (priv->hwtstamp_config.tx_type == tx_type &&\r\npriv->hwtstamp_config.rx_filter == rx_filter)\r\nreturn 0;\r\nmutex_lock(&mdev->state_lock);\r\nif (priv->port_up) {\r\nport_up = 1;\r\nmlx4_en_stop_port(dev, 1);\r\n}\r\nmlx4_en_free_resources(priv);\r\nen_warn(priv, "Changing Time Stamp configuration\n");\r\npriv->hwtstamp_config.tx_type = tx_type;\r\npriv->hwtstamp_config.rx_filter = rx_filter;\r\nif (rx_filter != HWTSTAMP_FILTER_NONE)\r\ndev->features &= ~NETIF_F_HW_VLAN_CTAG_RX;\r\nelse\r\ndev->features |= NETIF_F_HW_VLAN_CTAG_RX;\r\nerr = mlx4_en_alloc_resources(priv);\r\nif (err) {\r\nen_err(priv, "Failed reallocating port resources\n");\r\ngoto out;\r\n}\r\nif (port_up) {\r\nerr = mlx4_en_start_port(dev);\r\nif (err)\r\nen_err(priv, "Failed starting port\n");\r\n}\r\nout:\r\nmutex_unlock(&mdev->state_lock);\r\nnetdev_features_change(dev);\r\nreturn err;\r\n}\r\nstatic cycle_t mlx4_en_read_clock(const struct cyclecounter *tc)\r\n{\r\nstruct mlx4_en_dev *mdev =\r\ncontainer_of(tc, struct mlx4_en_dev, cycles);\r\nstruct mlx4_dev *dev = mdev->dev;\r\nreturn mlx4_read_clock(dev) & tc->mask;\r\n}\r\nu64 mlx4_en_get_cqe_ts(struct mlx4_cqe *cqe)\r\n{\r\nu64 hi, lo;\r\nstruct mlx4_ts_cqe *ts_cqe = (struct mlx4_ts_cqe *)cqe;\r\nlo = (u64)be16_to_cpu(ts_cqe->timestamp_lo);\r\nhi = ((u64)be32_to_cpu(ts_cqe->timestamp_hi) + !lo) << 16;\r\nreturn hi | lo;\r\n}\r\nvoid mlx4_en_fill_hwtstamps(struct mlx4_en_dev *mdev,\r\nstruct skb_shared_hwtstamps *hwts,\r\nu64 timestamp)\r\n{\r\nunsigned long flags;\r\nu64 nsec;\r\nread_lock_irqsave(&mdev->clock_lock, flags);\r\nnsec = timecounter_cyc2time(&mdev->clock, timestamp);\r\nread_unlock_irqrestore(&mdev->clock_lock, flags);\r\nmemset(hwts, 0, sizeof(struct skb_shared_hwtstamps));\r\nhwts->hwtstamp = ns_to_ktime(nsec);\r\n}\r\nvoid mlx4_en_remove_timestamp(struct mlx4_en_dev *mdev)\r\n{\r\nif (mdev->ptp_clock) {\r\nptp_clock_unregister(mdev->ptp_clock);\r\nmdev->ptp_clock = NULL;\r\nmlx4_info(mdev, "removed PHC\n");\r\n}\r\n}\r\nvoid mlx4_en_ptp_overflow_check(struct mlx4_en_dev *mdev)\r\n{\r\nbool timeout = time_is_before_jiffies(mdev->last_overflow_check +\r\nmdev->overflow_period);\r\nunsigned long flags;\r\nif (timeout) {\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\ntimecounter_read(&mdev->clock);\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nmdev->last_overflow_check = jiffies;\r\n}\r\n}\r\nstatic int mlx4_en_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta)\r\n{\r\nu64 adj;\r\nu32 diff, mult;\r\nint neg_adj = 0;\r\nunsigned long flags;\r\nstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\r\nptp_clock_info);\r\nif (delta < 0) {\r\nneg_adj = 1;\r\ndelta = -delta;\r\n}\r\nmult = mdev->nominal_c_mult;\r\nadj = mult;\r\nadj *= delta;\r\ndiff = div_u64(adj, 1000000000ULL);\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\ntimecounter_read(&mdev->clock);\r\nmdev->cycles.mult = neg_adj ? mult - diff : mult + diff;\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\r\nptp_clock_info);\r\nunsigned long flags;\r\ns64 now;\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\nnow = timecounter_read(&mdev->clock);\r\nnow += delta;\r\ntimecounter_init(&mdev->clock, &mdev->cycles, now);\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_phc_gettime(struct ptp_clock_info *ptp, struct timespec *ts)\r\n{\r\nstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\r\nptp_clock_info);\r\nunsigned long flags;\r\nu32 remainder;\r\nu64 ns;\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\nns = timecounter_read(&mdev->clock);\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nts->tv_sec = div_u64_rem(ns, NSEC_PER_SEC, &remainder);\r\nts->tv_nsec = remainder;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_phc_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec *ts)\r\n{\r\nstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\r\nptp_clock_info);\r\nu64 ns = timespec_to_ns(ts);\r\nunsigned long flags;\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\ntimecounter_init(&mdev->clock, &mdev->cycles, ns);\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_phc_enable(struct ptp_clock_info __always_unused *ptp,\r\nstruct ptp_clock_request __always_unused *request,\r\nint __always_unused on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nvoid mlx4_en_init_timestamp(struct mlx4_en_dev *mdev)\r\n{\r\nstruct mlx4_dev *dev = mdev->dev;\r\nunsigned long flags;\r\nu64 ns;\r\nrwlock_init(&mdev->clock_lock);\r\nmemset(&mdev->cycles, 0, sizeof(mdev->cycles));\r\nmdev->cycles.read = mlx4_en_read_clock;\r\nmdev->cycles.mask = CLOCKSOURCE_MASK(48);\r\nmdev->cycles.shift = 14;\r\nmdev->cycles.mult =\r\nclocksource_khz2mult(1000 * dev->caps.hca_core_clock, mdev->cycles.shift);\r\nmdev->nominal_c_mult = mdev->cycles.mult;\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\ntimecounter_init(&mdev->clock, &mdev->cycles,\r\nktime_to_ns(ktime_get_real()));\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nns = cyclecounter_cyc2ns(&mdev->cycles, mdev->cycles.mask);\r\ndo_div(ns, NSEC_PER_SEC / 2 / HZ);\r\nmdev->overflow_period = ns;\r\nmdev->ptp_clock_info = mlx4_en_ptp_clock_info;\r\nsnprintf(mdev->ptp_clock_info.name, 16, "mlx4 ptp");\r\nmdev->ptp_clock = ptp_clock_register(&mdev->ptp_clock_info,\r\n&mdev->pdev->dev);\r\nif (IS_ERR(mdev->ptp_clock)) {\r\nmdev->ptp_clock = NULL;\r\nmlx4_err(mdev, "ptp_clock_register failed\n");\r\n} else {\r\nmlx4_info(mdev, "registered PHC clock\n");\r\n}\r\n}
