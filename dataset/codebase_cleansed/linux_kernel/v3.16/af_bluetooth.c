void bt_sock_reclassify_lock(struct sock *sk, int proto)\r\n{\r\nBUG_ON(!sk);\r\nBUG_ON(sock_owned_by_user(sk));\r\nsock_lock_init_class_and_name(sk,\r\nbt_slock_key_strings[proto], &bt_slock_key[proto],\r\nbt_key_strings[proto], &bt_lock_key[proto]);\r\n}\r\nint bt_sock_register(int proto, const struct net_proto_family *ops)\r\n{\r\nint err = 0;\r\nif (proto < 0 || proto >= BT_MAX_PROTO)\r\nreturn -EINVAL;\r\nwrite_lock(&bt_proto_lock);\r\nif (bt_proto[proto])\r\nerr = -EEXIST;\r\nelse\r\nbt_proto[proto] = ops;\r\nwrite_unlock(&bt_proto_lock);\r\nreturn err;\r\n}\r\nvoid bt_sock_unregister(int proto)\r\n{\r\nif (proto < 0 || proto >= BT_MAX_PROTO)\r\nreturn;\r\nwrite_lock(&bt_proto_lock);\r\nbt_proto[proto] = NULL;\r\nwrite_unlock(&bt_proto_lock);\r\n}\r\nstatic int bt_sock_create(struct net *net, struct socket *sock, int proto,\r\nint kern)\r\n{\r\nint err;\r\nif (net != &init_net)\r\nreturn -EAFNOSUPPORT;\r\nif (proto < 0 || proto >= BT_MAX_PROTO)\r\nreturn -EINVAL;\r\nif (!bt_proto[proto])\r\nrequest_module("bt-proto-%d", proto);\r\nerr = -EPROTONOSUPPORT;\r\nread_lock(&bt_proto_lock);\r\nif (bt_proto[proto] && try_module_get(bt_proto[proto]->owner)) {\r\nerr = bt_proto[proto]->create(net, sock, proto, kern);\r\nif (!err)\r\nbt_sock_reclassify_lock(sock->sk, proto);\r\nmodule_put(bt_proto[proto]->owner);\r\n}\r\nread_unlock(&bt_proto_lock);\r\nreturn err;\r\n}\r\nvoid bt_sock_link(struct bt_sock_list *l, struct sock *sk)\r\n{\r\nwrite_lock(&l->lock);\r\nsk_add_node(sk, &l->head);\r\nwrite_unlock(&l->lock);\r\n}\r\nvoid bt_sock_unlink(struct bt_sock_list *l, struct sock *sk)\r\n{\r\nwrite_lock(&l->lock);\r\nsk_del_node_init(sk);\r\nwrite_unlock(&l->lock);\r\n}\r\nvoid bt_accept_enqueue(struct sock *parent, struct sock *sk)\r\n{\r\nBT_DBG("parent %p, sk %p", parent, sk);\r\nsock_hold(sk);\r\nlist_add_tail(&bt_sk(sk)->accept_q, &bt_sk(parent)->accept_q);\r\nbt_sk(sk)->parent = parent;\r\nparent->sk_ack_backlog++;\r\n}\r\nvoid bt_accept_unlink(struct sock *sk)\r\n{\r\nBT_DBG("sk %p state %d", sk, sk->sk_state);\r\nlist_del_init(&bt_sk(sk)->accept_q);\r\nbt_sk(sk)->parent->sk_ack_backlog--;\r\nbt_sk(sk)->parent = NULL;\r\nsock_put(sk);\r\n}\r\nstruct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock)\r\n{\r\nstruct list_head *p, *n;\r\nstruct sock *sk;\r\nBT_DBG("parent %p", parent);\r\nlist_for_each_safe(p, n, &bt_sk(parent)->accept_q) {\r\nsk = (struct sock *) list_entry(p, struct bt_sock, accept_q);\r\nlock_sock(sk);\r\nif (sk->sk_state == BT_CLOSED) {\r\nrelease_sock(sk);\r\nbt_accept_unlink(sk);\r\ncontinue;\r\n}\r\nif (sk->sk_state == BT_CONNECTED || !newsock ||\r\ntest_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags)) {\r\nbt_accept_unlink(sk);\r\nif (newsock)\r\nsock_graft(sk, newsock);\r\nrelease_sock(sk);\r\nreturn sk;\r\n}\r\nrelease_sock(sk);\r\n}\r\nreturn NULL;\r\n}\r\nint bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len, int flags)\r\n{\r\nint noblock = flags & MSG_DONTWAIT;\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb;\r\nsize_t copied;\r\nint err;\r\nBT_DBG("sock %p sk %p len %zu", sock, sk, len);\r\nif (flags & (MSG_OOB))\r\nreturn -EOPNOTSUPP;\r\nskb = skb_recv_datagram(sk, flags, noblock, &err);\r\nif (!skb) {\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nreturn 0;\r\nreturn err;\r\n}\r\ncopied = skb->len;\r\nif (len < copied) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nskb_reset_transport_header(skb);\r\nerr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nif (err == 0) {\r\nsock_recv_ts_and_drops(msg, sk, skb);\r\nif (bt_sk(sk)->skb_msg_name)\r\nbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\r\n&msg->msg_namelen);\r\n}\r\nskb_free_datagram(sk, skb);\r\nreturn err ? : copied;\r\n}\r\nstatic long bt_sock_data_wait(struct sock *sk, long timeo)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(sk_sleep(sk), &wait);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!skb_queue_empty(&sk->sk_receive_queue))\r\nbreak;\r\nif (sk->sk_err || (sk->sk_shutdown & RCV_SHUTDOWN))\r\nbreak;\r\nif (signal_pending(current) || !timeo)\r\nbreak;\r\nset_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\r\nrelease_sock(sk);\r\ntimeo = schedule_timeout(timeo);\r\nlock_sock(sk);\r\nclear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nreturn timeo;\r\n}\r\nint bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nsize_t target, copied = 0;\r\nlong timeo;\r\nif (flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nBT_DBG("sk %p size %zu", sk, size);\r\nlock_sock(sk);\r\ntarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\r\ntimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\r\ndo {\r\nstruct sk_buff *skb;\r\nint chunk;\r\nskb = skb_dequeue(&sk->sk_receive_queue);\r\nif (!skb) {\r\nif (copied >= target)\r\nbreak;\r\nerr = sock_error(sk);\r\nif (err)\r\nbreak;\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nbreak;\r\nerr = -EAGAIN;\r\nif (!timeo)\r\nbreak;\r\ntimeo = bt_sock_data_wait(sk, timeo);\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeo);\r\ngoto out;\r\n}\r\ncontinue;\r\n}\r\nchunk = min_t(unsigned int, skb->len, size);\r\nif (skb_copy_datagram_iovec(skb, 0, msg->msg_iov, chunk)) {\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nif (!copied)\r\ncopied = -EFAULT;\r\nbreak;\r\n}\r\ncopied += chunk;\r\nsize -= chunk;\r\nsock_recv_ts_and_drops(msg, sk, skb);\r\nif (!(flags & MSG_PEEK)) {\r\nint skb_len = skb_headlen(skb);\r\nif (chunk <= skb_len) {\r\n__skb_pull(skb, chunk);\r\n} else {\r\nstruct sk_buff *frag;\r\n__skb_pull(skb, skb_len);\r\nchunk -= skb_len;\r\nskb_walk_frags(skb, frag) {\r\nif (chunk <= frag->len) {\r\nskb->len -= chunk;\r\nskb->data_len -= chunk;\r\n__skb_pull(frag, chunk);\r\nbreak;\r\n} else if (frag->len) {\r\nchunk -= frag->len;\r\nskb->len -= frag->len;\r\nskb->data_len -= frag->len;\r\n__skb_pull(frag, frag->len);\r\n}\r\n}\r\n}\r\nif (skb->len) {\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\n} else {\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nbreak;\r\n}\r\n} while (size);\r\nout:\r\nrelease_sock(sk);\r\nreturn copied ? : err;\r\n}\r\nstatic inline unsigned int bt_accept_poll(struct sock *parent)\r\n{\r\nstruct list_head *p, *n;\r\nstruct sock *sk;\r\nlist_for_each_safe(p, n, &bt_sk(parent)->accept_q) {\r\nsk = (struct sock *) list_entry(p, struct bt_sock, accept_q);\r\nif (sk->sk_state == BT_CONNECTED ||\r\n(test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags) &&\r\nsk->sk_state == BT_CONNECT2))\r\nreturn POLLIN | POLLRDNORM;\r\n}\r\nreturn 0;\r\n}\r\nunsigned int bt_sock_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nunsigned int mask = 0;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\npoll_wait(file, sk_sleep(sk), wait);\r\nif (sk->sk_state == BT_LISTEN)\r\nreturn bt_accept_poll(sk);\r\nif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\r\nmask |= POLLERR |\r\n(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nmask |= POLLRDHUP | POLLIN | POLLRDNORM;\r\nif (sk->sk_shutdown == SHUTDOWN_MASK)\r\nmask |= POLLHUP;\r\nif (!skb_queue_empty(&sk->sk_receive_queue))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (sk->sk_state == BT_CLOSED)\r\nmask |= POLLHUP;\r\nif (sk->sk_state == BT_CONNECT ||\r\nsk->sk_state == BT_CONNECT2 ||\r\nsk->sk_state == BT_CONFIG)\r\nreturn mask;\r\nif (!test_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags) && sock_writeable(sk))\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\nelse\r\nset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\r\nreturn mask;\r\n}\r\nint bt_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb;\r\nlong amount;\r\nint err;\r\nBT_DBG("sk %p cmd %x arg %lx", sk, cmd, arg);\r\nswitch (cmd) {\r\ncase TIOCOUTQ:\r\nif (sk->sk_state == BT_LISTEN)\r\nreturn -EINVAL;\r\namount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\r\nif (amount < 0)\r\namount = 0;\r\nerr = put_user(amount, (int __user *) arg);\r\nbreak;\r\ncase TIOCINQ:\r\nif (sk->sk_state == BT_LISTEN)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nskb = skb_peek(&sk->sk_receive_queue);\r\namount = skb ? skb->len : 0;\r\nrelease_sock(sk);\r\nerr = put_user(amount, (int __user *) arg);\r\nbreak;\r\ncase SIOCGSTAMP:\r\nerr = sock_get_timestamp(sk, (struct timeval __user *) arg);\r\nbreak;\r\ncase SIOCGSTAMPNS:\r\nerr = sock_get_timestampns(sk, (struct timespec __user *) arg);\r\nbreak;\r\ndefault:\r\nerr = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nint bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nint err = 0;\r\nBT_DBG("sk %p", sk);\r\nadd_wait_queue(sk_sleep(sk), &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (sk->sk_state != state) {\r\nif (!timeo) {\r\nerr = -EINPROGRESS;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeo);\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\ntimeo = schedule_timeout(timeo);\r\nlock_sock(sk);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nerr = sock_error(sk);\r\nif (err)\r\nbreak;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nreturn err;\r\n}\r\nint bt_sock_wait_ready(struct sock *sk, unsigned long flags)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long timeo;\r\nint err = 0;\r\nBT_DBG("sk %p", sk);\r\ntimeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\r\nadd_wait_queue(sk_sleep(sk), &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (test_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags)) {\r\nif (!timeo) {\r\nerr = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeo);\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\ntimeo = schedule_timeout(timeo);\r\nlock_sock(sk);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nerr = sock_error(sk);\r\nif (err)\r\nbreak;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nreturn err;\r\n}\r\nstatic void *bt_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(seq->private->l->lock)\r\n{\r\nstruct bt_seq_state *s = seq->private;\r\nstruct bt_sock_list *l = s->l;\r\nread_lock(&l->lock);\r\nreturn seq_hlist_start_head(&l->head, *pos);\r\n}\r\nstatic void *bt_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct bt_seq_state *s = seq->private;\r\nstruct bt_sock_list *l = s->l;\r\nreturn seq_hlist_next(v, &l->head, pos);\r\n}\r\nstatic void bt_seq_stop(struct seq_file *seq, void *v)\r\n__releases(seq->private->l->lock)\r\n{\r\nstruct bt_seq_state *s = seq->private;\r\nstruct bt_sock_list *l = s->l;\r\nread_unlock(&l->lock);\r\n}\r\nstatic int bt_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct bt_seq_state *s = seq->private;\r\nstruct bt_sock_list *l = s->l;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq ,"sk RefCnt Rmem Wmem User Inode Parent");\r\nif (l->custom_seq_show) {\r\nseq_putc(seq, ' ');\r\nl->custom_seq_show(seq, v);\r\n}\r\nseq_putc(seq, '\n');\r\n} else {\r\nstruct sock *sk = sk_entry(v);\r\nstruct bt_sock *bt = bt_sk(sk);\r\nseq_printf(seq,\r\n"%pK %-6d %-6u %-6u %-6u %-6lu %-6lu",\r\nsk,\r\natomic_read(&sk->sk_refcnt),\r\nsk_rmem_alloc_get(sk),\r\nsk_wmem_alloc_get(sk),\r\nfrom_kuid(seq_user_ns(seq), sock_i_uid(sk)),\r\nsock_i_ino(sk),\r\nbt->parent? sock_i_ino(bt->parent): 0LU);\r\nif (l->custom_seq_show) {\r\nseq_putc(seq, ' ');\r\nl->custom_seq_show(seq, v);\r\n}\r\nseq_putc(seq, '\n');\r\n}\r\nreturn 0;\r\n}\r\nstatic int bt_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct bt_sock_list *sk_list;\r\nstruct bt_seq_state *s;\r\nsk_list = PDE_DATA(inode);\r\ns = __seq_open_private(file, &bt_seq_ops,\r\nsizeof(struct bt_seq_state));\r\nif (!s)\r\nreturn -ENOMEM;\r\ns->l = sk_list;\r\nreturn 0;\r\n}\r\nint bt_procfs_init(struct net *net, const char *name,\r\nstruct bt_sock_list* sk_list,\r\nint (* seq_show)(struct seq_file *, void *))\r\n{\r\nsk_list->custom_seq_show = seq_show;\r\nif (!proc_create_data(name, 0, net->proc_net, &bt_fops, sk_list))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid bt_procfs_cleanup(struct net *net, const char *name)\r\n{\r\nremove_proc_entry(name, net->proc_net);\r\n}\r\nint bt_procfs_init(struct net *net, const char *name,\r\nstruct bt_sock_list* sk_list,\r\nint (* seq_show)(struct seq_file *, void *))\r\n{\r\nreturn 0;\r\n}\r\nvoid bt_procfs_cleanup(struct net *net, const char *name)\r\n{\r\n}\r\nstatic int __init bt_init(void)\r\n{\r\nint err;\r\nBT_INFO("Core ver %s", VERSION);\r\nbt_debugfs = debugfs_create_dir("bluetooth", NULL);\r\nerr = bt_sysfs_init();\r\nif (err < 0)\r\nreturn err;\r\nerr = sock_register(&bt_sock_family_ops);\r\nif (err < 0) {\r\nbt_sysfs_cleanup();\r\nreturn err;\r\n}\r\nBT_INFO("HCI device and connection manager initialized");\r\nerr = hci_sock_init();\r\nif (err < 0)\r\ngoto error;\r\nerr = l2cap_init();\r\nif (err < 0)\r\ngoto sock_err;\r\nerr = sco_init();\r\nif (err < 0) {\r\nl2cap_exit();\r\ngoto sock_err;\r\n}\r\nreturn 0;\r\nsock_err:\r\nhci_sock_cleanup();\r\nerror:\r\nsock_unregister(PF_BLUETOOTH);\r\nbt_sysfs_cleanup();\r\nreturn err;\r\n}\r\nstatic void __exit bt_exit(void)\r\n{\r\nsco_exit();\r\nl2cap_exit();\r\nhci_sock_cleanup();\r\nsock_unregister(PF_BLUETOOTH);\r\nbt_sysfs_cleanup();\r\ndebugfs_remove_recursive(bt_debugfs);\r\n}
