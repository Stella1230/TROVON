static inline struct msi001 *sd_to_msi001(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct msi001, sd);\r\n}\r\nstatic int msi001_wreg(struct msi001 *s, u32 data)\r\n{\r\nreturn spi_write(s->spi, &data, 3);\r\n}\r\nstatic int msi001_set_gain(struct msi001 *s, int lna_gain, int mixer_gain,\r\nint if_gain)\r\n{\r\nint ret;\r\nu32 reg;\r\ndev_dbg(&s->spi->dev, "%s: lna=%d mixer=%d if=%d\n", __func__,\r\nlna_gain, mixer_gain, if_gain);\r\nreg = 1 << 0;\r\nreg |= (59 - if_gain) << 4;\r\nreg |= 0 << 10;\r\nreg |= (1 - mixer_gain) << 12;\r\nreg |= (1 - lna_gain) << 13;\r\nreg |= 4 << 14;\r\nreg |= 0 << 17;\r\nret = msi001_wreg(s, reg);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&s->spi->dev, "%s: failed %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int msi001_set_tuner(struct msi001 *s)\r\n{\r\nint ret, i;\r\nunsigned int n, m, thresh, frac, vco_step, tmp, f_if1;\r\nu32 reg;\r\nu64 f_vco, tmp64;\r\nu8 mode, filter_mode, lo_div;\r\nstatic const struct {\r\nu32 rf;\r\nu8 mode;\r\nu8 lo_div;\r\n} band_lut[] = {\r\n{ 50000000, 0xe1, 16},\r\n{108000000, 0x42, 32},\r\n{330000000, 0x44, 16},\r\n{960000000, 0x48, 4},\r\n{ ~0U, 0x50, 2},\r\n};\r\nstatic const struct {\r\nu32 freq;\r\nu8 filter_mode;\r\n} if_freq_lut[] = {\r\n{ 0, 0x03},\r\n{ 450000, 0x02},\r\n{1620000, 0x01},\r\n{2048000, 0x00},\r\n};\r\nstatic const struct {\r\nu32 freq;\r\nu8 val;\r\n} bandwidth_lut[] = {\r\n{ 200000, 0x00},\r\n{ 300000, 0x01},\r\n{ 600000, 0x02},\r\n{1536000, 0x03},\r\n{5000000, 0x04},\r\n{6000000, 0x05},\r\n{7000000, 0x06},\r\n{8000000, 0x07},\r\n};\r\nunsigned int f_rf = s->f_tuner;\r\nunsigned int bandwidth;\r\nunsigned int f_if = 0;\r\n#define F_REF 24000000\r\n#define R_REF 4\r\n#define F_OUT_STEP 1\r\ndev_dbg(&s->spi->dev,\r\n"%s: f_rf=%d f_if=%d\n",\r\n__func__, f_rf, f_if);\r\nfor (i = 0; i < ARRAY_SIZE(band_lut); i++) {\r\nif (f_rf <= band_lut[i].rf) {\r\nmode = band_lut[i].mode;\r\nlo_div = band_lut[i].lo_div;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(band_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif ((mode >> 0) & 0x1)\r\nf_if1 = 5 * F_REF;\r\nelse\r\nf_if1 = 0;\r\nfor (i = 0; i < ARRAY_SIZE(if_freq_lut); i++) {\r\nif (f_if == if_freq_lut[i].freq) {\r\nfilter_mode = if_freq_lut[i].filter_mode;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(if_freq_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbandwidth = s->bandwidth->val;\r\nbandwidth = clamp(bandwidth, 200000U, 8000000U);\r\nfor (i = 0; i < ARRAY_SIZE(bandwidth_lut); i++) {\r\nif (bandwidth <= bandwidth_lut[i].freq) {\r\nbandwidth = bandwidth_lut[i].val;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(bandwidth_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ns->bandwidth->val = bandwidth_lut[i].freq;\r\ndev_dbg(&s->spi->dev, "%s: bandwidth selected=%d\n",\r\n__func__, bandwidth_lut[i].freq);\r\nf_vco = (u64) (f_rf + f_if + f_if1) * lo_div;\r\ntmp64 = f_vco;\r\nm = do_div(tmp64, F_REF * R_REF);\r\nn = (unsigned int) tmp64;\r\nvco_step = F_OUT_STEP * lo_div;\r\nthresh = (F_REF * R_REF) / vco_step;\r\nfrac = 1ul * thresh * m / (F_REF * R_REF);\r\ntmp = gcd(thresh, frac);\r\nthresh /= tmp;\r\nfrac /= tmp;\r\ntmp = DIV_ROUND_UP(thresh, 4095);\r\nthresh = DIV_ROUND_CLOSEST(thresh, tmp);\r\nfrac = DIV_ROUND_CLOSEST(frac, tmp);\r\ntmp = 1ul * F_REF * R_REF * n;\r\ntmp += 1ul * F_REF * R_REF * frac / thresh;\r\ntmp /= lo_div;\r\ndev_dbg(&s->spi->dev,\r\n"%s: rf=%u:%u n=%d thresh=%d frac=%d\n",\r\n__func__, f_rf, tmp, n, thresh, frac);\r\nret = msi001_wreg(s, 0x00000e);\r\nif (ret)\r\ngoto err;\r\nret = msi001_wreg(s, 0x000003);\r\nif (ret)\r\ngoto err;\r\nreg = 0 << 0;\r\nreg |= mode << 4;\r\nreg |= filter_mode << 12;\r\nreg |= bandwidth << 14;\r\nreg |= 0x02 << 17;\r\nreg |= 0x00 << 20;\r\nret = msi001_wreg(s, reg);\r\nif (ret)\r\ngoto err;\r\nreg = 5 << 0;\r\nreg |= thresh << 4;\r\nreg |= 1 << 19;\r\nreg |= 1 << 21;\r\nret = msi001_wreg(s, reg);\r\nif (ret)\r\ngoto err;\r\nreg = 2 << 0;\r\nreg |= frac << 4;\r\nreg |= n << 16;\r\nret = msi001_wreg(s, reg);\r\nif (ret)\r\ngoto err;\r\nret = msi001_set_gain(s, s->lna_gain->cur.val, s->mixer_gain->cur.val,\r\ns->if_gain->cur.val);\r\nif (ret)\r\ngoto err;\r\nreg = 6 << 0;\r\nreg |= 63 << 4;\r\nreg |= 4095 << 10;\r\nret = msi001_wreg(s, reg);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&s->spi->dev, "%s: failed %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int msi001_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct msi001 *s = sd_to_msi001(sd);\r\nint ret;\r\ndev_dbg(&s->spi->dev, "%s: on=%d\n", __func__, on);\r\nif (on)\r\nret = 0;\r\nelse\r\nret = msi001_wreg(s, 0x000000);\r\nreturn ret;\r\n}\r\nstatic int msi001_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *v)\r\n{\r\nstruct msi001 *s = sd_to_msi001(sd);\r\ndev_dbg(&s->spi->dev, "%s: index=%d\n", __func__, v->index);\r\nstrlcpy(v->name, "Mirics MSi001", sizeof(v->name));\r\nv->type = V4L2_TUNER_RF;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = 49000000;\r\nv->rangehigh = 960000000;\r\nreturn 0;\r\n}\r\nstatic int msi001_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *v)\r\n{\r\nstruct msi001 *s = sd_to_msi001(sd);\r\ndev_dbg(&s->spi->dev, "%s: index=%d\n", __func__, v->index);\r\nreturn 0;\r\n}\r\nstatic int msi001_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\r\n{\r\nstruct msi001 *s = sd_to_msi001(sd);\r\ndev_dbg(&s->spi->dev, "%s: tuner=%d\n", __func__, f->tuner);\r\nf->frequency = s->f_tuner;\r\nreturn 0;\r\n}\r\nstatic int msi001_s_frequency(struct v4l2_subdev *sd,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct msi001 *s = sd_to_msi001(sd);\r\nunsigned int band;\r\ndev_dbg(&s->spi->dev, "%s: tuner=%d type=%d frequency=%u\n",\r\n__func__, f->tuner, f->type, f->frequency);\r\nif (f->frequency < ((bands[0].rangehigh + bands[1].rangelow) / 2))\r\nband = 0;\r\nelse\r\nband = 1;\r\ns->f_tuner = clamp_t(unsigned int, f->frequency,\r\nbands[band].rangelow, bands[band].rangehigh);\r\nreturn msi001_set_tuner(s);\r\n}\r\nstatic int msi001_enum_freq_bands(struct v4l2_subdev *sd,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nstruct msi001 *s = sd_to_msi001(sd);\r\ndev_dbg(&s->spi->dev, "%s: tuner=%d type=%d index=%d\n",\r\n__func__, band->tuner, band->type, band->index);\r\nif (band->index >= ARRAY_SIZE(bands))\r\nreturn -EINVAL;\r\nband->capability = bands[band->index].capability;\r\nband->rangelow = bands[band->index].rangelow;\r\nband->rangehigh = bands[band->index].rangehigh;\r\nreturn 0;\r\n}\r\nstatic int msi001_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct msi001 *s = container_of(ctrl->handler, struct msi001, hdl);\r\nint ret;\r\ndev_dbg(&s->spi->dev,\r\n"%s: id=%d name=%s val=%d min=%d max=%d step=%d\n",\r\n__func__, ctrl->id, ctrl->name, ctrl->val,\r\nctrl->minimum, ctrl->maximum, ctrl->step);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH:\r\nret = msi001_set_tuner(s);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN:\r\nret = msi001_set_gain(s, s->lna_gain->val,\r\ns->mixer_gain->cur.val, s->if_gain->cur.val);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN:\r\nret = msi001_set_gain(s, s->lna_gain->cur.val,\r\ns->mixer_gain->val, s->if_gain->cur.val);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_IF_GAIN:\r\nret = msi001_set_gain(s, s->lna_gain->cur.val,\r\ns->mixer_gain->cur.val, s->if_gain->val);\r\nbreak;\r\ndefault:\r\ndev_dbg(&s->spi->dev, "%s: unkown control %d\n",\r\n__func__, ctrl->id);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int msi001_probe(struct spi_device *spi)\r\n{\r\nstruct msi001 *s;\r\nint ret;\r\ndev_dbg(&spi->dev, "%s:\n", __func__);\r\ns = kzalloc(sizeof(struct msi001), GFP_KERNEL);\r\nif (s == NULL) {\r\nret = -ENOMEM;\r\ndev_dbg(&spi->dev, "Could not allocate memory for msi001\n");\r\ngoto err_kfree;\r\n}\r\ns->spi = spi;\r\ns->f_tuner = bands[0].rangelow;\r\nv4l2_spi_subdev_init(&s->sd, spi, &msi001_ops);\r\nv4l2_ctrl_handler_init(&s->hdl, 5);\r\ns->bandwidth_auto = v4l2_ctrl_new_std(&s->hdl, &msi001_ctrl_ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH_AUTO, 0, 1, 1, 1);\r\ns->bandwidth = v4l2_ctrl_new_std(&s->hdl, &msi001_ctrl_ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH, 200000, 8000000, 1, 200000);\r\nv4l2_ctrl_auto_cluster(2, &s->bandwidth_auto, 0, false);\r\ns->lna_gain = v4l2_ctrl_new_std(&s->hdl, &msi001_ctrl_ops,\r\nV4L2_CID_RF_TUNER_LNA_GAIN, 0, 1, 1, 1);\r\ns->mixer_gain = v4l2_ctrl_new_std(&s->hdl, &msi001_ctrl_ops,\r\nV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 1, 1, 1);\r\ns->if_gain = v4l2_ctrl_new_std(&s->hdl, &msi001_ctrl_ops,\r\nV4L2_CID_RF_TUNER_IF_GAIN, 0, 59, 1, 0);\r\nif (s->hdl.error) {\r\nret = s->hdl.error;\r\ndev_err(&s->spi->dev, "Could not initialize controls\n");\r\ngoto err_ctrl_handler_free;\r\n}\r\ns->sd.ctrl_handler = &s->hdl;\r\nreturn 0;\r\nerr_ctrl_handler_free:\r\nv4l2_ctrl_handler_free(&s->hdl);\r\nerr_kfree:\r\nkfree(s);\r\nreturn ret;\r\n}\r\nstatic int msi001_remove(struct spi_device *spi)\r\n{\r\nstruct v4l2_subdev *sd = spi_get_drvdata(spi);\r\nstruct msi001 *s = sd_to_msi001(sd);\r\ndev_dbg(&spi->dev, "%s:\n", __func__);\r\nv4l2_device_unregister_subdev(&s->sd);\r\nv4l2_ctrl_handler_free(&s->hdl);\r\nkfree(s);\r\nreturn 0;\r\n}
