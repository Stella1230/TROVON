static struct i2c_dev *i2c_dev_get_by_minor(unsigned index)\r\n{\r\nstruct i2c_dev *i2c_dev;\r\nspin_lock(&i2c_dev_list_lock);\r\nlist_for_each_entry(i2c_dev, &i2c_dev_list, list) {\r\nif (i2c_dev->adap->nr == index)\r\ngoto found;\r\n}\r\ni2c_dev = NULL;\r\nfound:\r\nspin_unlock(&i2c_dev_list_lock);\r\nreturn i2c_dev;\r\n}\r\nstatic struct i2c_dev *get_free_i2c_dev(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_dev *i2c_dev;\r\nif (adap->nr >= I2C_MINORS) {\r\nprintk(KERN_ERR "i2c-dev: Out of device minors (%d)\n",\r\nadap->nr);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\ni2c_dev = kzalloc(sizeof(*i2c_dev), GFP_KERNEL);\r\nif (!i2c_dev)\r\nreturn ERR_PTR(-ENOMEM);\r\ni2c_dev->adap = adap;\r\nspin_lock(&i2c_dev_list_lock);\r\nlist_add_tail(&i2c_dev->list, &i2c_dev_list);\r\nspin_unlock(&i2c_dev_list_lock);\r\nreturn i2c_dev;\r\n}\r\nstatic void return_i2c_dev(struct i2c_dev *i2c_dev)\r\n{\r\nspin_lock(&i2c_dev_list_lock);\r\nlist_del(&i2c_dev->list);\r\nspin_unlock(&i2c_dev_list_lock);\r\nkfree(i2c_dev);\r\n}\r\nstatic ssize_t name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_dev *i2c_dev = i2c_dev_get_by_minor(MINOR(dev->devt));\r\nif (!i2c_dev)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%s\n", i2c_dev->adap->name);\r\n}\r\nstatic ssize_t i2cdev_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *offset)\r\n{\r\nchar *tmp;\r\nint ret;\r\nstruct i2c_client *client = file->private_data;\r\nif (count > 8192)\r\ncount = 8192;\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (tmp == NULL)\r\nreturn -ENOMEM;\r\npr_debug("i2c-dev: i2c-%d reading %zu bytes.\n",\r\niminor(file_inode(file)), count);\r\nret = i2c_master_recv(client, tmp, count);\r\nif (ret >= 0)\r\nret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic ssize_t i2cdev_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nint ret;\r\nchar *tmp;\r\nstruct i2c_client *client = file->private_data;\r\nif (count > 8192)\r\ncount = 8192;\r\ntmp = memdup_user(buf, count);\r\nif (IS_ERR(tmp))\r\nreturn PTR_ERR(tmp);\r\npr_debug("i2c-dev: i2c-%d writing %zu bytes.\n",\r\niminor(file_inode(file)), count);\r\nret = i2c_master_send(client, tmp, count);\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic int i2cdev_check(struct device *dev, void *addrp)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nif (!client || client->addr != *(unsigned int *)addrp)\r\nreturn 0;\r\nreturn dev->driver ? -EBUSY : 0;\r\n}\r\nstatic int i2cdev_check_mux_parents(struct i2c_adapter *adapter, int addr)\r\n{\r\nstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\r\nint result;\r\nresult = device_for_each_child(&adapter->dev, &addr, i2cdev_check);\r\nif (!result && parent)\r\nresult = i2cdev_check_mux_parents(parent, addr);\r\nreturn result;\r\n}\r\nstatic int i2cdev_check_mux_children(struct device *dev, void *addrp)\r\n{\r\nint result;\r\nif (dev->type == &i2c_adapter_type)\r\nresult = device_for_each_child(dev, addrp,\r\ni2cdev_check_mux_children);\r\nelse\r\nresult = i2cdev_check(dev, addrp);\r\nreturn result;\r\n}\r\nstatic int i2cdev_check_addr(struct i2c_adapter *adapter, unsigned int addr)\r\n{\r\nstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\r\nint result = 0;\r\nif (parent)\r\nresult = i2cdev_check_mux_parents(parent, addr);\r\nif (!result)\r\nresult = device_for_each_child(&adapter->dev, &addr,\r\ni2cdev_check_mux_children);\r\nreturn result;\r\n}\r\nstatic noinline int i2cdev_ioctl_rdrw(struct i2c_client *client,\r\nunsigned long arg)\r\n{\r\nstruct i2c_rdwr_ioctl_data rdwr_arg;\r\nstruct i2c_msg *rdwr_pa;\r\nu8 __user **data_ptrs;\r\nint i, res;\r\nif (copy_from_user(&rdwr_arg,\r\n(struct i2c_rdwr_ioctl_data __user *)arg,\r\nsizeof(rdwr_arg)))\r\nreturn -EFAULT;\r\nif (rdwr_arg.nmsgs > I2C_RDRW_IOCTL_MAX_MSGS)\r\nreturn -EINVAL;\r\nrdwr_pa = memdup_user(rdwr_arg.msgs,\r\nrdwr_arg.nmsgs * sizeof(struct i2c_msg));\r\nif (IS_ERR(rdwr_pa))\r\nreturn PTR_ERR(rdwr_pa);\r\ndata_ptrs = kmalloc(rdwr_arg.nmsgs * sizeof(u8 __user *), GFP_KERNEL);\r\nif (data_ptrs == NULL) {\r\nkfree(rdwr_pa);\r\nreturn -ENOMEM;\r\n}\r\nres = 0;\r\nfor (i = 0; i < rdwr_arg.nmsgs; i++) {\r\nif (rdwr_pa[i].len > 8192) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\ndata_ptrs[i] = (u8 __user *)rdwr_pa[i].buf;\r\nrdwr_pa[i].buf = memdup_user(data_ptrs[i], rdwr_pa[i].len);\r\nif (IS_ERR(rdwr_pa[i].buf)) {\r\nres = PTR_ERR(rdwr_pa[i].buf);\r\nbreak;\r\n}\r\nif (rdwr_pa[i].flags & I2C_M_RECV_LEN) {\r\nif (!(rdwr_pa[i].flags & I2C_M_RD) ||\r\nrdwr_pa[i].buf[0] < 1 ||\r\nrdwr_pa[i].len < rdwr_pa[i].buf[0] +\r\nI2C_SMBUS_BLOCK_MAX) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nrdwr_pa[i].len = rdwr_pa[i].buf[0];\r\n}\r\n}\r\nif (res < 0) {\r\nint j;\r\nfor (j = 0; j < i; ++j)\r\nkfree(rdwr_pa[j].buf);\r\nkfree(data_ptrs);\r\nkfree(rdwr_pa);\r\nreturn res;\r\n}\r\nres = i2c_transfer(client->adapter, rdwr_pa, rdwr_arg.nmsgs);\r\nwhile (i-- > 0) {\r\nif (res >= 0 && (rdwr_pa[i].flags & I2C_M_RD)) {\r\nif (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,\r\nrdwr_pa[i].len))\r\nres = -EFAULT;\r\n}\r\nkfree(rdwr_pa[i].buf);\r\n}\r\nkfree(data_ptrs);\r\nkfree(rdwr_pa);\r\nreturn res;\r\n}\r\nstatic noinline int i2cdev_ioctl_smbus(struct i2c_client *client,\r\nunsigned long arg)\r\n{\r\nstruct i2c_smbus_ioctl_data data_arg;\r\nunion i2c_smbus_data temp;\r\nint datasize, res;\r\nif (copy_from_user(&data_arg,\r\n(struct i2c_smbus_ioctl_data __user *) arg,\r\nsizeof(struct i2c_smbus_ioctl_data)))\r\nreturn -EFAULT;\r\nif ((data_arg.size != I2C_SMBUS_BYTE) &&\r\n(data_arg.size != I2C_SMBUS_QUICK) &&\r\n(data_arg.size != I2C_SMBUS_BYTE_DATA) &&\r\n(data_arg.size != I2C_SMBUS_WORD_DATA) &&\r\n(data_arg.size != I2C_SMBUS_PROC_CALL) &&\r\n(data_arg.size != I2C_SMBUS_BLOCK_DATA) &&\r\n(data_arg.size != I2C_SMBUS_I2C_BLOCK_BROKEN) &&\r\n(data_arg.size != I2C_SMBUS_I2C_BLOCK_DATA) &&\r\n(data_arg.size != I2C_SMBUS_BLOCK_PROC_CALL)) {\r\ndev_dbg(&client->adapter->dev,\r\n"size out of range (%x) in ioctl I2C_SMBUS.\n",\r\ndata_arg.size);\r\nreturn -EINVAL;\r\n}\r\nif ((data_arg.read_write != I2C_SMBUS_READ) &&\r\n(data_arg.read_write != I2C_SMBUS_WRITE)) {\r\ndev_dbg(&client->adapter->dev,\r\n"read_write out of range (%x) in ioctl I2C_SMBUS.\n",\r\ndata_arg.read_write);\r\nreturn -EINVAL;\r\n}\r\nif ((data_arg.size == I2C_SMBUS_QUICK) ||\r\n((data_arg.size == I2C_SMBUS_BYTE) &&\r\n(data_arg.read_write == I2C_SMBUS_WRITE)))\r\nreturn i2c_smbus_xfer(client->adapter, client->addr,\r\nclient->flags, data_arg.read_write,\r\ndata_arg.command, data_arg.size, NULL);\r\nif (data_arg.data == NULL) {\r\ndev_dbg(&client->adapter->dev,\r\n"data is NULL pointer in ioctl I2C_SMBUS.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((data_arg.size == I2C_SMBUS_BYTE_DATA) ||\r\n(data_arg.size == I2C_SMBUS_BYTE))\r\ndatasize = sizeof(data_arg.data->byte);\r\nelse if ((data_arg.size == I2C_SMBUS_WORD_DATA) ||\r\n(data_arg.size == I2C_SMBUS_PROC_CALL))\r\ndatasize = sizeof(data_arg.data->word);\r\nelse\r\ndatasize = sizeof(data_arg.data->block);\r\nif ((data_arg.size == I2C_SMBUS_PROC_CALL) ||\r\n(data_arg.size == I2C_SMBUS_BLOCK_PROC_CALL) ||\r\n(data_arg.size == I2C_SMBUS_I2C_BLOCK_DATA) ||\r\n(data_arg.read_write == I2C_SMBUS_WRITE)) {\r\nif (copy_from_user(&temp, data_arg.data, datasize))\r\nreturn -EFAULT;\r\n}\r\nif (data_arg.size == I2C_SMBUS_I2C_BLOCK_BROKEN) {\r\ndata_arg.size = I2C_SMBUS_I2C_BLOCK_DATA;\r\nif (data_arg.read_write == I2C_SMBUS_READ)\r\ntemp.block[0] = I2C_SMBUS_BLOCK_MAX;\r\n}\r\nres = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\ndata_arg.read_write, data_arg.command, data_arg.size, &temp);\r\nif (!res && ((data_arg.size == I2C_SMBUS_PROC_CALL) ||\r\n(data_arg.size == I2C_SMBUS_BLOCK_PROC_CALL) ||\r\n(data_arg.read_write == I2C_SMBUS_READ))) {\r\nif (copy_to_user(data_arg.data, &temp, datasize))\r\nreturn -EFAULT;\r\n}\r\nreturn res;\r\n}\r\nstatic long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct i2c_client *client = file->private_data;\r\nunsigned long funcs;\r\ndev_dbg(&client->adapter->dev, "ioctl, cmd=0x%02x, arg=0x%02lx\n",\r\ncmd, arg);\r\nswitch (cmd) {\r\ncase I2C_SLAVE:\r\ncase I2C_SLAVE_FORCE:\r\nif ((arg > 0x3ff) ||\r\n(((client->flags & I2C_M_TEN) == 0) && arg > 0x7f))\r\nreturn -EINVAL;\r\nif (cmd == I2C_SLAVE && i2cdev_check_addr(client->adapter, arg))\r\nreturn -EBUSY;\r\nclient->addr = arg;\r\nreturn 0;\r\ncase I2C_TENBIT:\r\nif (arg)\r\nclient->flags |= I2C_M_TEN;\r\nelse\r\nclient->flags &= ~I2C_M_TEN;\r\nreturn 0;\r\ncase I2C_PEC:\r\nif (arg)\r\nclient->flags |= I2C_CLIENT_PEC;\r\nelse\r\nclient->flags &= ~I2C_CLIENT_PEC;\r\nreturn 0;\r\ncase I2C_FUNCS:\r\nfuncs = i2c_get_functionality(client->adapter);\r\nreturn put_user(funcs, (unsigned long __user *)arg);\r\ncase I2C_RDWR:\r\nreturn i2cdev_ioctl_rdrw(client, arg);\r\ncase I2C_SMBUS:\r\nreturn i2cdev_ioctl_smbus(client, arg);\r\ncase I2C_RETRIES:\r\nclient->adapter->retries = arg;\r\nbreak;\r\ncase I2C_TIMEOUT:\r\nclient->adapter->timeout = msecs_to_jiffies(arg * 10);\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2cdev_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct i2c_client *client;\r\nstruct i2c_adapter *adap;\r\nstruct i2c_dev *i2c_dev;\r\ni2c_dev = i2c_dev_get_by_minor(minor);\r\nif (!i2c_dev)\r\nreturn -ENODEV;\r\nadap = i2c_get_adapter(i2c_dev->adap->nr);\r\nif (!adap)\r\nreturn -ENODEV;\r\nclient = kzalloc(sizeof(*client), GFP_KERNEL);\r\nif (!client) {\r\ni2c_put_adapter(adap);\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(client->name, I2C_NAME_SIZE, "i2c-dev %d", adap->nr);\r\nclient->adapter = adap;\r\nfile->private_data = client;\r\nreturn 0;\r\n}\r\nstatic int i2cdev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct i2c_client *client = file->private_data;\r\ni2c_put_adapter(client->adapter);\r\nkfree(client);\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int i2cdev_attach_adapter(struct device *dev, void *dummy)\r\n{\r\nstruct i2c_adapter *adap;\r\nstruct i2c_dev *i2c_dev;\r\nint res;\r\nif (dev->type != &i2c_adapter_type)\r\nreturn 0;\r\nadap = to_i2c_adapter(dev);\r\ni2c_dev = get_free_i2c_dev(adap);\r\nif (IS_ERR(i2c_dev))\r\nreturn PTR_ERR(i2c_dev);\r\ni2c_dev->dev = device_create(i2c_dev_class, &adap->dev,\r\nMKDEV(I2C_MAJOR, adap->nr), NULL,\r\n"i2c-%d", adap->nr);\r\nif (IS_ERR(i2c_dev->dev)) {\r\nres = PTR_ERR(i2c_dev->dev);\r\ngoto error;\r\n}\r\npr_debug("i2c-dev: adapter [%s] registered as minor %d\n",\r\nadap->name, adap->nr);\r\nreturn 0;\r\nerror:\r\nreturn_i2c_dev(i2c_dev);\r\nreturn res;\r\n}\r\nstatic int i2cdev_detach_adapter(struct device *dev, void *dummy)\r\n{\r\nstruct i2c_adapter *adap;\r\nstruct i2c_dev *i2c_dev;\r\nif (dev->type != &i2c_adapter_type)\r\nreturn 0;\r\nadap = to_i2c_adapter(dev);\r\ni2c_dev = i2c_dev_get_by_minor(adap->nr);\r\nif (!i2c_dev)\r\nreturn 0;\r\nreturn_i2c_dev(i2c_dev);\r\ndevice_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap->nr));\r\npr_debug("i2c-dev: adapter [%s] unregistered\n", adap->name);\r\nreturn 0;\r\n}\r\nstatic int i2cdev_notifier_call(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct device *dev = data;\r\nswitch (action) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nreturn i2cdev_attach_adapter(dev, NULL);\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\nreturn i2cdev_detach_adapter(dev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init i2c_dev_init(void)\r\n{\r\nint res;\r\nprintk(KERN_INFO "i2c /dev entries driver\n");\r\nres = register_chrdev(I2C_MAJOR, "i2c", &i2cdev_fops);\r\nif (res)\r\ngoto out;\r\ni2c_dev_class = class_create(THIS_MODULE, "i2c-dev");\r\nif (IS_ERR(i2c_dev_class)) {\r\nres = PTR_ERR(i2c_dev_class);\r\ngoto out_unreg_chrdev;\r\n}\r\ni2c_dev_class->dev_groups = i2c_groups;\r\nres = bus_register_notifier(&i2c_bus_type, &i2cdev_notifier);\r\nif (res)\r\ngoto out_unreg_class;\r\ni2c_for_each_dev(NULL, i2cdev_attach_adapter);\r\nreturn 0;\r\nout_unreg_class:\r\nclass_destroy(i2c_dev_class);\r\nout_unreg_chrdev:\r\nunregister_chrdev(I2C_MAJOR, "i2c");\r\nout:\r\nprintk(KERN_ERR "%s: Driver Initialisation failed\n", __FILE__);\r\nreturn res;\r\n}\r\nstatic void __exit i2c_dev_exit(void)\r\n{\r\nbus_unregister_notifier(&i2c_bus_type, &i2cdev_notifier);\r\ni2c_for_each_dev(NULL, i2cdev_detach_adapter);\r\nclass_destroy(i2c_dev_class);\r\nunregister_chrdev(I2C_MAJOR, "i2c");\r\n}
