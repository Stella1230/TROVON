static void index_prepare_for_write(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t block_size)\r\n{\r\nstruct disk_metadata_index *mi_le = dm_block_data(b);\r\nmi_le->blocknr = cpu_to_le64(dm_block_location(b));\r\nmi_le->csum = cpu_to_le32(dm_bm_checksum(&mi_le->padding,\r\nblock_size - sizeof(__le32),\r\nINDEX_CSUM_XOR));\r\n}\r\nstatic int index_check(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t block_size)\r\n{\r\nstruct disk_metadata_index *mi_le = dm_block_data(b);\r\n__le32 csum_disk;\r\nif (dm_block_location(b) != le64_to_cpu(mi_le->blocknr)) {\r\nDMERR_LIMIT("index_check failed: blocknr %llu != wanted %llu",\r\nle64_to_cpu(mi_le->blocknr), dm_block_location(b));\r\nreturn -ENOTBLK;\r\n}\r\ncsum_disk = cpu_to_le32(dm_bm_checksum(&mi_le->padding,\r\nblock_size - sizeof(__le32),\r\nINDEX_CSUM_XOR));\r\nif (csum_disk != mi_le->csum) {\r\nDMERR_LIMIT("index_check failed: csum %u != wanted %u",\r\nle32_to_cpu(csum_disk), le32_to_cpu(mi_le->csum));\r\nreturn -EILSEQ;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bitmap_prepare_for_write(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t block_size)\r\n{\r\nstruct disk_bitmap_header *disk_header = dm_block_data(b);\r\ndisk_header->blocknr = cpu_to_le64(dm_block_location(b));\r\ndisk_header->csum = cpu_to_le32(dm_bm_checksum(&disk_header->not_used,\r\nblock_size - sizeof(__le32),\r\nBITMAP_CSUM_XOR));\r\n}\r\nstatic int bitmap_check(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t block_size)\r\n{\r\nstruct disk_bitmap_header *disk_header = dm_block_data(b);\r\n__le32 csum_disk;\r\nif (dm_block_location(b) != le64_to_cpu(disk_header->blocknr)) {\r\nDMERR_LIMIT("bitmap check failed: blocknr %llu != wanted %llu",\r\nle64_to_cpu(disk_header->blocknr), dm_block_location(b));\r\nreturn -ENOTBLK;\r\n}\r\ncsum_disk = cpu_to_le32(dm_bm_checksum(&disk_header->not_used,\r\nblock_size - sizeof(__le32),\r\nBITMAP_CSUM_XOR));\r\nif (csum_disk != disk_header->csum) {\r\nDMERR_LIMIT("bitmap check failed: csum %u != wanted %u",\r\nle32_to_cpu(csum_disk), le32_to_cpu(disk_header->csum));\r\nreturn -EILSEQ;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *dm_bitmap_data(struct dm_block *b)\r\n{\r\nreturn dm_block_data(b) + sizeof(struct disk_bitmap_header);\r\n}\r\nstatic unsigned bitmap_word_used(void *addr, unsigned b)\r\n{\r\n__le64 *words_le = addr;\r\n__le64 *w_le = words_le + (b >> ENTRIES_SHIFT);\r\nuint64_t bits = le64_to_cpu(*w_le);\r\nuint64_t mask = (bits + WORD_MASK_HIGH + 1) & WORD_MASK_HIGH;\r\nreturn !(~bits & mask);\r\n}\r\nstatic unsigned sm_lookup_bitmap(void *addr, unsigned b)\r\n{\r\n__le64 *words_le = addr;\r\n__le64 *w_le = words_le + (b >> ENTRIES_SHIFT);\r\nunsigned hi, lo;\r\nb = (b & (ENTRIES_PER_WORD - 1)) << 1;\r\nhi = !!test_bit_le(b, (void *) w_le);\r\nlo = !!test_bit_le(b + 1, (void *) w_le);\r\nreturn (hi << 1) | lo;\r\n}\r\nstatic void sm_set_bitmap(void *addr, unsigned b, unsigned val)\r\n{\r\n__le64 *words_le = addr;\r\n__le64 *w_le = words_le + (b >> ENTRIES_SHIFT);\r\nb = (b & (ENTRIES_PER_WORD - 1)) << 1;\r\nif (val & 2)\r\n__set_bit_le(b, (void *) w_le);\r\nelse\r\n__clear_bit_le(b, (void *) w_le);\r\nif (val & 1)\r\n__set_bit_le(b + 1, (void *) w_le);\r\nelse\r\n__clear_bit_le(b + 1, (void *) w_le);\r\n}\r\nstatic int sm_find_free(void *addr, unsigned begin, unsigned end,\r\nunsigned *result)\r\n{\r\nwhile (begin < end) {\r\nif (!(begin & (ENTRIES_PER_WORD - 1)) &&\r\nbitmap_word_used(addr, begin)) {\r\nbegin += ENTRIES_PER_WORD;\r\ncontinue;\r\n}\r\nif (!sm_lookup_bitmap(addr, begin)) {\r\n*result = begin;\r\nreturn 0;\r\n}\r\nbegin++;\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic int sm_ll_init(struct ll_disk *ll, struct dm_transaction_manager *tm)\r\n{\r\nll->tm = tm;\r\nll->bitmap_info.tm = tm;\r\nll->bitmap_info.levels = 1;\r\nll->bitmap_info.value_type.size = sizeof(struct disk_index_entry);\r\nll->bitmap_info.value_type.inc = NULL;\r\nll->bitmap_info.value_type.dec = NULL;\r\nll->bitmap_info.value_type.equal = NULL;\r\nll->ref_count_info.tm = tm;\r\nll->ref_count_info.levels = 1;\r\nll->ref_count_info.value_type.size = sizeof(uint32_t);\r\nll->ref_count_info.value_type.inc = NULL;\r\nll->ref_count_info.value_type.dec = NULL;\r\nll->ref_count_info.value_type.equal = NULL;\r\nll->block_size = dm_bm_block_size(dm_tm_get_bm(tm));\r\nif (ll->block_size > (1 << 30)) {\r\nDMERR("block size too big to hold bitmaps");\r\nreturn -EINVAL;\r\n}\r\nll->entries_per_block = (ll->block_size - sizeof(struct disk_bitmap_header)) *\r\nENTRIES_PER_BYTE;\r\nll->nr_blocks = 0;\r\nll->bitmap_root = 0;\r\nll->ref_count_root = 0;\r\nll->bitmap_index_changed = false;\r\nreturn 0;\r\n}\r\nint sm_ll_extend(struct ll_disk *ll, dm_block_t extra_blocks)\r\n{\r\nint r;\r\ndm_block_t i, nr_blocks, nr_indexes;\r\nunsigned old_blocks, blocks;\r\nnr_blocks = ll->nr_blocks + extra_blocks;\r\nold_blocks = dm_sector_div_up(ll->nr_blocks, ll->entries_per_block);\r\nblocks = dm_sector_div_up(nr_blocks, ll->entries_per_block);\r\nnr_indexes = dm_sector_div_up(nr_blocks, ll->entries_per_block);\r\nif (nr_indexes > ll->max_entries(ll)) {\r\nDMERR("space map too large");\r\nreturn -EINVAL;\r\n}\r\nll->nr_blocks = nr_blocks;\r\nfor (i = old_blocks; i < blocks; i++) {\r\nstruct dm_block *b;\r\nstruct disk_index_entry idx;\r\nr = dm_tm_new_block(ll->tm, &dm_sm_bitmap_validator, &b);\r\nif (r < 0)\r\nreturn r;\r\nidx.blocknr = cpu_to_le64(dm_block_location(b));\r\nr = dm_tm_unlock(ll->tm, b);\r\nif (r < 0)\r\nreturn r;\r\nidx.nr_free = cpu_to_le32(ll->entries_per_block);\r\nidx.none_free_before = 0;\r\nr = ll->save_ie(ll, i, &idx);\r\nif (r < 0)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint sm_ll_lookup_bitmap(struct ll_disk *ll, dm_block_t b, uint32_t *result)\r\n{\r\nint r;\r\ndm_block_t index = b;\r\nstruct disk_index_entry ie_disk;\r\nstruct dm_block *blk;\r\nb = do_div(index, ll->entries_per_block);\r\nr = ll->load_ie(ll, index, &ie_disk);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_tm_read_lock(ll->tm, le64_to_cpu(ie_disk.blocknr),\r\n&dm_sm_bitmap_validator, &blk);\r\nif (r < 0)\r\nreturn r;\r\n*result = sm_lookup_bitmap(dm_bitmap_data(blk), b);\r\nreturn dm_tm_unlock(ll->tm, blk);\r\n}\r\nstatic int sm_ll_lookup_big_ref_count(struct ll_disk *ll, dm_block_t b,\r\nuint32_t *result)\r\n{\r\n__le32 le_rc;\r\nint r;\r\nr = dm_btree_lookup(&ll->ref_count_info, ll->ref_count_root, &b, &le_rc);\r\nif (r < 0)\r\nreturn r;\r\n*result = le32_to_cpu(le_rc);\r\nreturn r;\r\n}\r\nint sm_ll_lookup(struct ll_disk *ll, dm_block_t b, uint32_t *result)\r\n{\r\nint r = sm_ll_lookup_bitmap(ll, b, result);\r\nif (r)\r\nreturn r;\r\nif (*result != 3)\r\nreturn r;\r\nreturn sm_ll_lookup_big_ref_count(ll, b, result);\r\n}\r\nint sm_ll_find_free_block(struct ll_disk *ll, dm_block_t begin,\r\ndm_block_t end, dm_block_t *result)\r\n{\r\nint r;\r\nstruct disk_index_entry ie_disk;\r\ndm_block_t i, index_begin = begin;\r\ndm_block_t index_end = dm_sector_div_up(end, ll->entries_per_block);\r\nbegin = do_div(index_begin, ll->entries_per_block);\r\nend = do_div(end, ll->entries_per_block);\r\nfor (i = index_begin; i < index_end; i++, begin = 0) {\r\nstruct dm_block *blk;\r\nunsigned position;\r\nuint32_t bit_end;\r\nr = ll->load_ie(ll, i, &ie_disk);\r\nif (r < 0)\r\nreturn r;\r\nif (le32_to_cpu(ie_disk.nr_free) == 0)\r\ncontinue;\r\nr = dm_tm_read_lock(ll->tm, le64_to_cpu(ie_disk.blocknr),\r\n&dm_sm_bitmap_validator, &blk);\r\nif (r < 0)\r\nreturn r;\r\nbit_end = (i == index_end - 1) ? end : ll->entries_per_block;\r\nr = sm_find_free(dm_bitmap_data(blk),\r\nmax_t(unsigned, begin, le32_to_cpu(ie_disk.none_free_before)),\r\nbit_end, &position);\r\nif (r == -ENOSPC) {\r\ndm_tm_unlock(ll->tm, blk);\r\ncontinue;\r\n} else if (r < 0) {\r\ndm_tm_unlock(ll->tm, blk);\r\nreturn r;\r\n}\r\nr = dm_tm_unlock(ll->tm, blk);\r\nif (r < 0)\r\nreturn r;\r\n*result = i * ll->entries_per_block + (dm_block_t) position;\r\nreturn 0;\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic int sm_ll_mutate(struct ll_disk *ll, dm_block_t b,\r\nint (*mutator)(void *context, uint32_t old, uint32_t *new),\r\nvoid *context, enum allocation_event *ev)\r\n{\r\nint r;\r\nuint32_t bit, old, ref_count;\r\nstruct dm_block *nb;\r\ndm_block_t index = b;\r\nstruct disk_index_entry ie_disk;\r\nvoid *bm_le;\r\nint inc;\r\nbit = do_div(index, ll->entries_per_block);\r\nr = ll->load_ie(ll, index, &ie_disk);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_tm_shadow_block(ll->tm, le64_to_cpu(ie_disk.blocknr),\r\n&dm_sm_bitmap_validator, &nb, &inc);\r\nif (r < 0) {\r\nDMERR("dm_tm_shadow_block() failed");\r\nreturn r;\r\n}\r\nie_disk.blocknr = cpu_to_le64(dm_block_location(nb));\r\nbm_le = dm_bitmap_data(nb);\r\nold = sm_lookup_bitmap(bm_le, bit);\r\nif (old > 2) {\r\nr = sm_ll_lookup_big_ref_count(ll, b, &old);\r\nif (r < 0) {\r\ndm_tm_unlock(ll->tm, nb);\r\nreturn r;\r\n}\r\n}\r\nr = mutator(context, old, &ref_count);\r\nif (r) {\r\ndm_tm_unlock(ll->tm, nb);\r\nreturn r;\r\n}\r\nif (ref_count <= 2) {\r\nsm_set_bitmap(bm_le, bit, ref_count);\r\nr = dm_tm_unlock(ll->tm, nb);\r\nif (r < 0)\r\nreturn r;\r\nif (old > 2) {\r\nr = dm_btree_remove(&ll->ref_count_info,\r\nll->ref_count_root,\r\n&b, &ll->ref_count_root);\r\nif (r)\r\nreturn r;\r\n}\r\n} else {\r\n__le32 le_rc = cpu_to_le32(ref_count);\r\nsm_set_bitmap(bm_le, bit, 3);\r\nr = dm_tm_unlock(ll->tm, nb);\r\nif (r < 0)\r\nreturn r;\r\n__dm_bless_for_disk(&le_rc);\r\nr = dm_btree_insert(&ll->ref_count_info, ll->ref_count_root,\r\n&b, &le_rc, &ll->ref_count_root);\r\nif (r < 0) {\r\nDMERR("ref count insert failed");\r\nreturn r;\r\n}\r\n}\r\nif (ref_count && !old) {\r\n*ev = SM_ALLOC;\r\nll->nr_allocated++;\r\nle32_add_cpu(&ie_disk.nr_free, -1);\r\nif (le32_to_cpu(ie_disk.none_free_before) == bit)\r\nie_disk.none_free_before = cpu_to_le32(bit + 1);\r\n} else if (old && !ref_count) {\r\n*ev = SM_FREE;\r\nll->nr_allocated--;\r\nle32_add_cpu(&ie_disk.nr_free, 1);\r\nie_disk.none_free_before = cpu_to_le32(min(le32_to_cpu(ie_disk.none_free_before), bit));\r\n}\r\nreturn ll->save_ie(ll, index, &ie_disk);\r\n}\r\nstatic int set_ref_count(void *context, uint32_t old, uint32_t *new)\r\n{\r\n*new = *((uint32_t *) context);\r\nreturn 0;\r\n}\r\nint sm_ll_insert(struct ll_disk *ll, dm_block_t b,\r\nuint32_t ref_count, enum allocation_event *ev)\r\n{\r\nreturn sm_ll_mutate(ll, b, set_ref_count, &ref_count, ev);\r\n}\r\nstatic int inc_ref_count(void *context, uint32_t old, uint32_t *new)\r\n{\r\n*new = old + 1;\r\nreturn 0;\r\n}\r\nint sm_ll_inc(struct ll_disk *ll, dm_block_t b, enum allocation_event *ev)\r\n{\r\nreturn sm_ll_mutate(ll, b, inc_ref_count, NULL, ev);\r\n}\r\nstatic int dec_ref_count(void *context, uint32_t old, uint32_t *new)\r\n{\r\nif (!old) {\r\nDMERR_LIMIT("unable to decrement a reference count below 0");\r\nreturn -EINVAL;\r\n}\r\n*new = old - 1;\r\nreturn 0;\r\n}\r\nint sm_ll_dec(struct ll_disk *ll, dm_block_t b, enum allocation_event *ev)\r\n{\r\nreturn sm_ll_mutate(ll, b, dec_ref_count, NULL, ev);\r\n}\r\nint sm_ll_commit(struct ll_disk *ll)\r\n{\r\nint r = 0;\r\nif (ll->bitmap_index_changed) {\r\nr = ll->commit(ll);\r\nif (!r)\r\nll->bitmap_index_changed = false;\r\n}\r\nreturn r;\r\n}\r\nstatic int metadata_ll_load_ie(struct ll_disk *ll, dm_block_t index,\r\nstruct disk_index_entry *ie)\r\n{\r\nmemcpy(ie, ll->mi_le.index + index, sizeof(*ie));\r\nreturn 0;\r\n}\r\nstatic int metadata_ll_save_ie(struct ll_disk *ll, dm_block_t index,\r\nstruct disk_index_entry *ie)\r\n{\r\nll->bitmap_index_changed = true;\r\nmemcpy(ll->mi_le.index + index, ie, sizeof(*ie));\r\nreturn 0;\r\n}\r\nstatic int metadata_ll_init_index(struct ll_disk *ll)\r\n{\r\nint r;\r\nstruct dm_block *b;\r\nr = dm_tm_new_block(ll->tm, &index_validator, &b);\r\nif (r < 0)\r\nreturn r;\r\nmemcpy(dm_block_data(b), &ll->mi_le, sizeof(ll->mi_le));\r\nll->bitmap_root = dm_block_location(b);\r\nreturn dm_tm_unlock(ll->tm, b);\r\n}\r\nstatic int metadata_ll_open(struct ll_disk *ll)\r\n{\r\nint r;\r\nstruct dm_block *block;\r\nr = dm_tm_read_lock(ll->tm, ll->bitmap_root,\r\n&index_validator, &block);\r\nif (r)\r\nreturn r;\r\nmemcpy(&ll->mi_le, dm_block_data(block), sizeof(ll->mi_le));\r\nreturn dm_tm_unlock(ll->tm, block);\r\n}\r\nstatic dm_block_t metadata_ll_max_entries(struct ll_disk *ll)\r\n{\r\nreturn MAX_METADATA_BITMAPS;\r\n}\r\nstatic int metadata_ll_commit(struct ll_disk *ll)\r\n{\r\nint r, inc;\r\nstruct dm_block *b;\r\nr = dm_tm_shadow_block(ll->tm, ll->bitmap_root, &index_validator, &b, &inc);\r\nif (r)\r\nreturn r;\r\nmemcpy(dm_block_data(b), &ll->mi_le, sizeof(ll->mi_le));\r\nll->bitmap_root = dm_block_location(b);\r\nreturn dm_tm_unlock(ll->tm, b);\r\n}\r\nint sm_ll_new_metadata(struct ll_disk *ll, struct dm_transaction_manager *tm)\r\n{\r\nint r;\r\nr = sm_ll_init(ll, tm);\r\nif (r < 0)\r\nreturn r;\r\nll->load_ie = metadata_ll_load_ie;\r\nll->save_ie = metadata_ll_save_ie;\r\nll->init_index = metadata_ll_init_index;\r\nll->open_index = metadata_ll_open;\r\nll->max_entries = metadata_ll_max_entries;\r\nll->commit = metadata_ll_commit;\r\nll->nr_blocks = 0;\r\nll->nr_allocated = 0;\r\nr = ll->init_index(ll);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_btree_empty(&ll->ref_count_info, &ll->ref_count_root);\r\nif (r < 0)\r\nreturn r;\r\nreturn 0;\r\n}\r\nint sm_ll_open_metadata(struct ll_disk *ll, struct dm_transaction_manager *tm,\r\nvoid *root_le, size_t len)\r\n{\r\nint r;\r\nstruct disk_sm_root *smr = root_le;\r\nif (len < sizeof(struct disk_sm_root)) {\r\nDMERR("sm_metadata root too small");\r\nreturn -ENOMEM;\r\n}\r\nr = sm_ll_init(ll, tm);\r\nif (r < 0)\r\nreturn r;\r\nll->load_ie = metadata_ll_load_ie;\r\nll->save_ie = metadata_ll_save_ie;\r\nll->init_index = metadata_ll_init_index;\r\nll->open_index = metadata_ll_open;\r\nll->max_entries = metadata_ll_max_entries;\r\nll->commit = metadata_ll_commit;\r\nll->nr_blocks = le64_to_cpu(smr->nr_blocks);\r\nll->nr_allocated = le64_to_cpu(smr->nr_allocated);\r\nll->bitmap_root = le64_to_cpu(smr->bitmap_root);\r\nll->ref_count_root = le64_to_cpu(smr->ref_count_root);\r\nreturn ll->open_index(ll);\r\n}\r\nstatic int disk_ll_load_ie(struct ll_disk *ll, dm_block_t index,\r\nstruct disk_index_entry *ie)\r\n{\r\nreturn dm_btree_lookup(&ll->bitmap_info, ll->bitmap_root, &index, ie);\r\n}\r\nstatic int disk_ll_save_ie(struct ll_disk *ll, dm_block_t index,\r\nstruct disk_index_entry *ie)\r\n{\r\n__dm_bless_for_disk(ie);\r\nreturn dm_btree_insert(&ll->bitmap_info, ll->bitmap_root,\r\n&index, ie, &ll->bitmap_root);\r\n}\r\nstatic int disk_ll_init_index(struct ll_disk *ll)\r\n{\r\nreturn dm_btree_empty(&ll->bitmap_info, &ll->bitmap_root);\r\n}\r\nstatic int disk_ll_open(struct ll_disk *ll)\r\n{\r\nreturn 0;\r\n}\r\nstatic dm_block_t disk_ll_max_entries(struct ll_disk *ll)\r\n{\r\nreturn -1ULL;\r\n}\r\nstatic int disk_ll_commit(struct ll_disk *ll)\r\n{\r\nreturn 0;\r\n}\r\nint sm_ll_new_disk(struct ll_disk *ll, struct dm_transaction_manager *tm)\r\n{\r\nint r;\r\nr = sm_ll_init(ll, tm);\r\nif (r < 0)\r\nreturn r;\r\nll->load_ie = disk_ll_load_ie;\r\nll->save_ie = disk_ll_save_ie;\r\nll->init_index = disk_ll_init_index;\r\nll->open_index = disk_ll_open;\r\nll->max_entries = disk_ll_max_entries;\r\nll->commit = disk_ll_commit;\r\nll->nr_blocks = 0;\r\nll->nr_allocated = 0;\r\nr = ll->init_index(ll);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_btree_empty(&ll->ref_count_info, &ll->ref_count_root);\r\nif (r < 0)\r\nreturn r;\r\nreturn 0;\r\n}\r\nint sm_ll_open_disk(struct ll_disk *ll, struct dm_transaction_manager *tm,\r\nvoid *root_le, size_t len)\r\n{\r\nint r;\r\nstruct disk_sm_root *smr = root_le;\r\nif (len < sizeof(struct disk_sm_root)) {\r\nDMERR("sm_metadata root too small");\r\nreturn -ENOMEM;\r\n}\r\nr = sm_ll_init(ll, tm);\r\nif (r < 0)\r\nreturn r;\r\nll->load_ie = disk_ll_load_ie;\r\nll->save_ie = disk_ll_save_ie;\r\nll->init_index = disk_ll_init_index;\r\nll->open_index = disk_ll_open;\r\nll->max_entries = disk_ll_max_entries;\r\nll->commit = disk_ll_commit;\r\nll->nr_blocks = le64_to_cpu(smr->nr_blocks);\r\nll->nr_allocated = le64_to_cpu(smr->nr_allocated);\r\nll->bitmap_root = le64_to_cpu(smr->bitmap_root);\r\nll->ref_count_root = le64_to_cpu(smr->ref_count_root);\r\nreturn ll->open_index(ll);\r\n}
