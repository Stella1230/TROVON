static void __used dump_rtlx(void)\r\n{\r\nint i;\r\npr_info("id 0x%lx state %d\n", rtlx->id, rtlx->state);\r\nfor (i = 0; i < RTLX_CHANNELS; i++) {\r\nstruct rtlx_channel *chan = &rtlx->channel[i];\r\npr_info(" rt_state %d lx_state %d buffer_size %d\n",\r\nchan->rt_state, chan->lx_state, chan->buffer_size);\r\npr_info(" rt_read %d rt_write %d\n",\r\nchan->rt_read, chan->rt_write);\r\npr_info(" lx_read %d lx_write %d\n",\r\nchan->lx_read, chan->lx_write);\r\npr_info(" rt_buffer <%s>\n", chan->rt_buffer);\r\npr_info(" lx_buffer <%s>\n", chan->lx_buffer);\r\n}\r\n}\r\nstatic int rtlx_init(struct rtlx_info *rtlxi)\r\n{\r\nif (rtlxi->id != RTLX_ID) {\r\npr_err("no valid RTLX id at 0x%p 0x%lx\n", rtlxi, rtlxi->id);\r\nreturn -ENOEXEC;\r\n}\r\nrtlx = rtlxi;\r\nreturn 0;\r\n}\r\nvoid rtlx_starting(int vpe)\r\n{\r\nint i;\r\nsp_stopping = 0;\r\nrtlx = NULL;\r\nfor (i = 0; i < RTLX_CHANNELS; i++)\r\nwake_up_interruptible(&channel_wqs[i].lx_queue);\r\n}\r\nvoid rtlx_stopping(int vpe)\r\n{\r\nint i;\r\nsp_stopping = 1;\r\nfor (i = 0; i < RTLX_CHANNELS; i++)\r\nwake_up_interruptible(&channel_wqs[i].lx_queue);\r\n}\r\nint rtlx_open(int index, int can_sleep)\r\n{\r\nstruct rtlx_info **p;\r\nstruct rtlx_channel *chan;\r\nenum rtlx_state state;\r\nint ret = 0;\r\nif (index >= RTLX_CHANNELS) {\r\npr_debug(KERN_DEBUG "rtlx_open index out of range\n");\r\nreturn -ENOSYS;\r\n}\r\nif (atomic_inc_return(&channel_wqs[index].in_open) > 1) {\r\npr_debug(KERN_DEBUG "rtlx_open channel %d already opened\n", index);\r\nret = -EBUSY;\r\ngoto out_fail;\r\n}\r\nif (rtlx == NULL) {\r\np = vpe_get_shared(aprp_cpu_index());\r\nif (p == NULL) {\r\nif (can_sleep) {\r\nret = __wait_event_interruptible(\r\nchannel_wqs[index].lx_queue,\r\n(p = vpe_get_shared(aprp_cpu_index())));\r\nif (ret)\r\ngoto out_fail;\r\n} else {\r\npr_debug("No SP program loaded, and device opened with O_NONBLOCK\n");\r\nret = -ENOSYS;\r\ngoto out_fail;\r\n}\r\n}\r\nsmp_rmb();\r\nif (*p == NULL) {\r\nif (can_sleep) {\r\nDEFINE_WAIT(wait);\r\nfor (;;) {\r\nprepare_to_wait(\r\n&channel_wqs[index].lx_queue,\r\n&wait, TASK_INTERRUPTIBLE);\r\nsmp_rmb();\r\nif (*p != NULL)\r\nbreak;\r\nif (!signal_pending(current)) {\r\nschedule();\r\ncontinue;\r\n}\r\nret = -ERESTARTSYS;\r\ngoto out_fail;\r\n}\r\nfinish_wait(&channel_wqs[index].lx_queue,\r\n&wait);\r\n} else {\r\npr_err(" *vpe_get_shared is NULL. Has an SP program been loaded?\n");\r\nret = -ENOSYS;\r\ngoto out_fail;\r\n}\r\n}\r\nif ((unsigned int)*p < KSEG0) {\r\npr_warn("vpe_get_shared returned an invalid pointer maybe an error code %d\n",\r\n(int)*p);\r\nret = -ENOSYS;\r\ngoto out_fail;\r\n}\r\nret = rtlx_init(*p);\r\nif (ret < 0)\r\ngoto out_ret;\r\n}\r\nchan = &rtlx->channel[index];\r\nstate = xchg(&chan->lx_state, RTLX_STATE_OPENED);\r\nif (state == RTLX_STATE_OPENED) {\r\nret = -EBUSY;\r\ngoto out_fail;\r\n}\r\nout_fail:\r\nsmp_mb();\r\natomic_dec(&channel_wqs[index].in_open);\r\nsmp_mb();\r\nout_ret:\r\nreturn ret;\r\n}\r\nint rtlx_release(int index)\r\n{\r\nif (rtlx == NULL) {\r\npr_err("rtlx_release() with null rtlx\n");\r\nreturn 0;\r\n}\r\nrtlx->channel[index].lx_state = RTLX_STATE_UNUSED;\r\nreturn 0;\r\n}\r\nunsigned int rtlx_read_poll(int index, int can_sleep)\r\n{\r\nstruct rtlx_channel *chan;\r\nif (rtlx == NULL)\r\nreturn 0;\r\nchan = &rtlx->channel[index];\r\nif (chan->lx_read == chan->lx_write) {\r\nif (can_sleep) {\r\nint ret = __wait_event_interruptible(\r\nchannel_wqs[index].lx_queue,\r\n(chan->lx_read != chan->lx_write) ||\r\nsp_stopping);\r\nif (ret)\r\nreturn ret;\r\nif (sp_stopping)\r\nreturn 0;\r\n} else\r\nreturn 0;\r\n}\r\nreturn (chan->lx_write + chan->buffer_size - chan->lx_read)\r\n% chan->buffer_size;\r\n}\r\nstatic inline int write_spacefree(int read, int write, int size)\r\n{\r\nif (read == write) {\r\nreturn size - 1;\r\n}\r\nreturn ((read + size - write) % size) - 1;\r\n}\r\nunsigned int rtlx_write_poll(int index)\r\n{\r\nstruct rtlx_channel *chan = &rtlx->channel[index];\r\nreturn write_spacefree(chan->rt_read, chan->rt_write,\r\nchan->buffer_size);\r\n}\r\nssize_t rtlx_read(int index, void __user *buff, size_t count)\r\n{\r\nsize_t lx_write, fl = 0L;\r\nstruct rtlx_channel *lx;\r\nunsigned long failed;\r\nif (rtlx == NULL)\r\nreturn -ENOSYS;\r\nlx = &rtlx->channel[index];\r\nmutex_lock(&channel_wqs[index].mutex);\r\nsmp_rmb();\r\nlx_write = lx->lx_write;\r\ncount = min(count,\r\n(size_t)(lx_write + lx->buffer_size - lx->lx_read)\r\n% lx->buffer_size);\r\nfl = min(count, (size_t)lx->buffer_size - lx->lx_read);\r\nfailed = copy_to_user(buff, lx->lx_buffer + lx->lx_read, fl);\r\nif (failed)\r\ngoto out;\r\nif (count - fl)\r\nfailed = copy_to_user(buff + fl, lx->lx_buffer, count - fl);\r\nout:\r\ncount -= failed;\r\nsmp_wmb();\r\nlx->lx_read = (lx->lx_read + count) % lx->buffer_size;\r\nsmp_wmb();\r\nmutex_unlock(&channel_wqs[index].mutex);\r\nreturn count;\r\n}\r\nssize_t rtlx_write(int index, const void __user *buffer, size_t count)\r\n{\r\nstruct rtlx_channel *rt;\r\nunsigned long failed;\r\nsize_t rt_read;\r\nsize_t fl;\r\nif (rtlx == NULL)\r\nreturn -ENOSYS;\r\nrt = &rtlx->channel[index];\r\nmutex_lock(&channel_wqs[index].mutex);\r\nsmp_rmb();\r\nrt_read = rt->rt_read;\r\ncount = min_t(size_t, count, write_spacefree(rt_read, rt->rt_write,\r\nrt->buffer_size));\r\nfl = min(count, (size_t) rt->buffer_size - rt->rt_write);\r\nfailed = copy_from_user(rt->rt_buffer + rt->rt_write, buffer, fl);\r\nif (failed)\r\ngoto out;\r\nif (count - fl)\r\nfailed = copy_from_user(rt->rt_buffer, buffer + fl, count - fl);\r\nout:\r\ncount -= failed;\r\nsmp_wmb();\r\nrt->rt_write = (rt->rt_write + count) % rt->buffer_size;\r\nsmp_wmb();\r\nmutex_unlock(&channel_wqs[index].mutex);\r\n_interrupt_sp();\r\nreturn count;\r\n}\r\nstatic int file_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn rtlx_open(iminor(inode), (filp->f_flags & O_NONBLOCK) ? 0 : 1);\r\n}\r\nstatic int file_release(struct inode *inode, struct file *filp)\r\n{\r\nreturn rtlx_release(iminor(inode));\r\n}\r\nstatic unsigned int file_poll(struct file *file, poll_table *wait)\r\n{\r\nint minor = iminor(file_inode(file));\r\nunsigned int mask = 0;\r\npoll_wait(file, &channel_wqs[minor].rt_queue, wait);\r\npoll_wait(file, &channel_wqs[minor].lx_queue, wait);\r\nif (rtlx == NULL)\r\nreturn 0;\r\nif (rtlx_read_poll(minor, 0))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (rtlx_write_poll(minor))\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic ssize_t file_read(struct file *file, char __user *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nint minor = iminor(file_inode(file));\r\nif (!rtlx_read_poll(minor, (file->f_flags & O_NONBLOCK) ? 0 : 1))\r\nreturn 0;\r\nreturn rtlx_read(minor, buffer, count);\r\n}\r\nstatic ssize_t file_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint minor = iminor(file_inode(file));\r\nif (!rtlx_write_poll(minor)) {\r\nint ret;\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nret = __wait_event_interruptible(channel_wqs[minor].rt_queue,\r\nrtlx_write_poll(minor));\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn rtlx_write(minor, buffer, count);\r\n}
