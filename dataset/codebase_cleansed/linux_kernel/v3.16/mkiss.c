static unsigned short calc_crc_flex(unsigned char *cp, int size)\r\n{\r\nunsigned short crc = 0xffff;\r\nwhile (size--)\r\ncrc = (crc << 8) ^ crc_flex_table[((crc >> 8) ^ *cp++) & 0xff];\r\nreturn crc;\r\n}\r\nstatic int check_crc_flex(unsigned char *cp, int size)\r\n{\r\nunsigned short crc = 0xffff;\r\nif (size < 3)\r\nreturn -1;\r\nwhile (size--)\r\ncrc = (crc << 8) ^ crc_flex_table[((crc >> 8) ^ *cp++) & 0xff];\r\nif ((crc & 0xffff) != 0x7070)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int check_crc_16(unsigned char *cp, int size)\r\n{\r\nunsigned short crc = 0x0000;\r\nif (size < 3)\r\nreturn -1;\r\ncrc = crc16(0, cp, size);\r\nif (crc != 0x0000)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int kiss_esc(unsigned char *s, unsigned char *d, int len)\r\n{\r\nunsigned char *ptr = d;\r\nunsigned char c;\r\n*ptr++ = END;\r\nwhile (len-- > 0) {\r\nswitch (c = *s++) {\r\ncase END:\r\n*ptr++ = ESC;\r\n*ptr++ = ESC_END;\r\nbreak;\r\ncase ESC:\r\n*ptr++ = ESC;\r\n*ptr++ = ESC_ESC;\r\nbreak;\r\ndefault:\r\n*ptr++ = c;\r\nbreak;\r\n}\r\n}\r\n*ptr++ = END;\r\nreturn ptr - d;\r\n}\r\nstatic int kiss_esc_crc(unsigned char *s, unsigned char *d, unsigned short crc,\r\nint len)\r\n{\r\nunsigned char *ptr = d;\r\nunsigned char c=0;\r\n*ptr++ = END;\r\nwhile (len > 0) {\r\nif (len > 2)\r\nc = *s++;\r\nelse if (len > 1)\r\nc = crc >> 8;\r\nelse if (len > 0)\r\nc = crc & 0xff;\r\nlen--;\r\nswitch (c) {\r\ncase END:\r\n*ptr++ = ESC;\r\n*ptr++ = ESC_END;\r\nbreak;\r\ncase ESC:\r\n*ptr++ = ESC;\r\n*ptr++ = ESC_ESC;\r\nbreak;\r\ndefault:\r\n*ptr++ = c;\r\nbreak;\r\n}\r\n}\r\n*ptr++ = END;\r\nreturn ptr - d;\r\n}\r\nstatic void ax_bump(struct mkiss *ax)\r\n{\r\nstruct sk_buff *skb;\r\nint count;\r\nspin_lock_bh(&ax->buflock);\r\nif (ax->rbuff[0] > 0x0f) {\r\nif (ax->rbuff[0] & 0x80) {\r\nif (check_crc_16(ax->rbuff, ax->rcount) < 0) {\r\nax->dev->stats.rx_errors++;\r\nspin_unlock_bh(&ax->buflock);\r\nreturn;\r\n}\r\nif (ax->crcmode != CRC_MODE_SMACK && ax->crcauto) {\r\nprintk(KERN_INFO\r\n"mkiss: %s: Switching to crc-smack\n",\r\nax->dev->name);\r\nax->crcmode = CRC_MODE_SMACK;\r\n}\r\nax->rcount -= 2;\r\n*ax->rbuff &= ~0x80;\r\n} else if (ax->rbuff[0] & 0x20) {\r\nif (check_crc_flex(ax->rbuff, ax->rcount) < 0) {\r\nax->dev->stats.rx_errors++;\r\nspin_unlock_bh(&ax->buflock);\r\nreturn;\r\n}\r\nif (ax->crcmode != CRC_MODE_FLEX && ax->crcauto) {\r\nprintk(KERN_INFO\r\n"mkiss: %s: Switching to crc-flexnet\n",\r\nax->dev->name);\r\nax->crcmode = CRC_MODE_FLEX;\r\n}\r\nax->rcount -= 2;\r\n*ax->rbuff &= ~0x20;\r\n}\r\n}\r\ncount = ax->rcount;\r\nif ((skb = dev_alloc_skb(count)) == NULL) {\r\nprintk(KERN_ERR "mkiss: %s: memory squeeze, dropping packet.\n",\r\nax->dev->name);\r\nax->dev->stats.rx_dropped++;\r\nspin_unlock_bh(&ax->buflock);\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb,count), ax->rbuff, count);\r\nskb->protocol = ax25_type_trans(skb, ax->dev);\r\nnetif_rx(skb);\r\nax->dev->stats.rx_packets++;\r\nax->dev->stats.rx_bytes += count;\r\nspin_unlock_bh(&ax->buflock);\r\n}\r\nstatic void kiss_unesc(struct mkiss *ax, unsigned char s)\r\n{\r\nswitch (s) {\r\ncase END:\r\nif (test_bit(AXF_KEEPTEST, &ax->flags))\r\nclear_bit(AXF_KEEPTEST, &ax->flags);\r\nif (!test_and_clear_bit(AXF_ERROR, &ax->flags) && (ax->rcount > 2))\r\nax_bump(ax);\r\nclear_bit(AXF_ESCAPE, &ax->flags);\r\nax->rcount = 0;\r\nreturn;\r\ncase ESC:\r\nset_bit(AXF_ESCAPE, &ax->flags);\r\nreturn;\r\ncase ESC_ESC:\r\nif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\r\ns = ESC;\r\nbreak;\r\ncase ESC_END:\r\nif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\r\ns = END;\r\nbreak;\r\n}\r\nspin_lock_bh(&ax->buflock);\r\nif (!test_bit(AXF_ERROR, &ax->flags)) {\r\nif (ax->rcount < ax->buffsize) {\r\nax->rbuff[ax->rcount++] = s;\r\nspin_unlock_bh(&ax->buflock);\r\nreturn;\r\n}\r\nax->dev->stats.rx_over_errors++;\r\nset_bit(AXF_ERROR, &ax->flags);\r\n}\r\nspin_unlock_bh(&ax->buflock);\r\n}\r\nstatic int ax_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr_ax25 *sa = addr;\r\nnetif_tx_lock_bh(dev);\r\nnetif_addr_lock(dev);\r\nmemcpy(dev->dev_addr, &sa->sax25_call, AX25_ADDR_LEN);\r\nnetif_addr_unlock(dev);\r\nnetif_tx_unlock_bh(dev);\r\nreturn 0;\r\n}\r\nstatic void ax_changedmtu(struct mkiss *ax)\r\n{\r\nstruct net_device *dev = ax->dev;\r\nunsigned char *xbuff, *rbuff, *oxbuff, *orbuff;\r\nint len;\r\nlen = dev->mtu * 2;\r\nif (len < 576 * 2)\r\nlen = 576 * 2;\r\nxbuff = kmalloc(len + 4, GFP_ATOMIC);\r\nrbuff = kmalloc(len + 4, GFP_ATOMIC);\r\nif (xbuff == NULL || rbuff == NULL) {\r\nprintk(KERN_ERR "mkiss: %s: unable to grow ax25 buffers, "\r\n"MTU change cancelled.\n",\r\nax->dev->name);\r\ndev->mtu = ax->mtu;\r\nkfree(xbuff);\r\nkfree(rbuff);\r\nreturn;\r\n}\r\nspin_lock_bh(&ax->buflock);\r\noxbuff = ax->xbuff;\r\nax->xbuff = xbuff;\r\norbuff = ax->rbuff;\r\nax->rbuff = rbuff;\r\nif (ax->xleft) {\r\nif (ax->xleft <= len) {\r\nmemcpy(ax->xbuff, ax->xhead, ax->xleft);\r\n} else {\r\nax->xleft = 0;\r\ndev->stats.tx_dropped++;\r\n}\r\n}\r\nax->xhead = ax->xbuff;\r\nif (ax->rcount) {\r\nif (ax->rcount <= len) {\r\nmemcpy(ax->rbuff, orbuff, ax->rcount);\r\n} else {\r\nax->rcount = 0;\r\ndev->stats.rx_over_errors++;\r\nset_bit(AXF_ERROR, &ax->flags);\r\n}\r\n}\r\nax->mtu = dev->mtu + 73;\r\nax->buffsize = len;\r\nspin_unlock_bh(&ax->buflock);\r\nkfree(oxbuff);\r\nkfree(orbuff);\r\n}\r\nstatic void ax_encaps(struct net_device *dev, unsigned char *icp, int len)\r\n{\r\nstruct mkiss *ax = netdev_priv(dev);\r\nunsigned char *p;\r\nint actual, count;\r\nif (ax->mtu != ax->dev->mtu + 73)\r\nax_changedmtu(ax);\r\nif (len > ax->mtu) {\r\nlen = ax->mtu;\r\nprintk(KERN_ERR "mkiss: %s: truncating oversized transmit packet!\n", ax->dev->name);\r\ndev->stats.tx_dropped++;\r\nnetif_start_queue(dev);\r\nreturn;\r\n}\r\np = icp;\r\nspin_lock_bh(&ax->buflock);\r\nif ((*p & 0x0f) != 0) {\r\nswitch (*p & 0xff) {\r\ncase 0x85:\r\nif (len > 1) {\r\nint cmd = (p[1] & 0xff);\r\nswitch(cmd) {\r\ncase 3:\r\nax->crcmode = CRC_MODE_SMACK;\r\nbreak;\r\ncase 2:\r\nax->crcmode = CRC_MODE_FLEX;\r\nbreak;\r\ncase 1:\r\nax->crcmode = CRC_MODE_NONE;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nax->crcmode = CRC_MODE_SMACK_TEST;\r\ncmd = 0;\r\n}\r\nax->crcauto = (cmd ? 0 : 1);\r\nprintk(KERN_INFO "mkiss: %s: crc mode %s %d\n", ax->dev->name, (len) ? "set to" : "is", cmd);\r\n}\r\nspin_unlock_bh(&ax->buflock);\r\nnetif_start_queue(dev);\r\nreturn;\r\ndefault:\r\ncount = kiss_esc(p, ax->xbuff, len);\r\n}\r\n} else {\r\nunsigned short crc;\r\nswitch (ax->crcmode) {\r\ncase CRC_MODE_SMACK_TEST:\r\nax->crcmode = CRC_MODE_FLEX_TEST;\r\nprintk(KERN_INFO "mkiss: %s: Trying crc-smack\n", ax->dev->name);\r\ncase CRC_MODE_SMACK:\r\n*p |= 0x80;\r\ncrc = swab16(crc16(0, p, len));\r\ncount = kiss_esc_crc(p, ax->xbuff, crc, len+2);\r\nbreak;\r\ncase CRC_MODE_FLEX_TEST:\r\nax->crcmode = CRC_MODE_NONE;\r\nprintk(KERN_INFO "mkiss: %s: Trying crc-flexnet\n", ax->dev->name);\r\ncase CRC_MODE_FLEX:\r\n*p |= 0x20;\r\ncrc = calc_crc_flex(p, len);\r\ncount = kiss_esc_crc(p, ax->xbuff, crc, len+2);\r\nbreak;\r\ndefault:\r\ncount = kiss_esc(p, ax->xbuff, len);\r\n}\r\n}\r\nspin_unlock_bh(&ax->buflock);\r\nset_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags);\r\nactual = ax->tty->ops->write(ax->tty, ax->xbuff, count);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += actual;\r\nax->dev->trans_start = jiffies;\r\nax->xleft = count - actual;\r\nax->xhead = ax->xbuff + actual;\r\n}\r\nstatic netdev_tx_t ax_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct mkiss *ax = netdev_priv(dev);\r\nif (!netif_running(dev)) {\r\nprintk(KERN_ERR "mkiss: %s: xmit call when iface is down\n", dev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (netif_queue_stopped(dev)) {\r\nif (time_before(jiffies, dev->trans_start + 20 * HZ)) {\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nprintk(KERN_ERR "mkiss: %s: transmit timed out, %s?\n", dev->name,\r\n(tty_chars_in_buffer(ax->tty) || ax->xleft) ?\r\n"bad line quality" : "driver error");\r\nax->xleft = 0;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags);\r\nnetif_start_queue(dev);\r\n}\r\nif (skb != NULL) {\r\nnetif_stop_queue(dev);\r\nax_encaps(dev, skb->data, skb->len);\r\nkfree_skb(skb);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ax_open_dev(struct net_device *dev)\r\n{\r\nstruct mkiss *ax = netdev_priv(dev);\r\nif (ax->tty == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int ax_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *daddr,\r\nconst void *saddr, unsigned len)\r\n{\r\n#ifdef CONFIG_INET\r\nif (type != ETH_P_AX25)\r\nreturn ax25_hard_header(skb, dev, type, daddr, saddr, len);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int ax_rebuild_header(struct sk_buff *skb)\r\n{\r\n#ifdef CONFIG_INET\r\nreturn ax25_rebuild_header(skb);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int ax_open(struct net_device *dev)\r\n{\r\nstruct mkiss *ax = netdev_priv(dev);\r\nunsigned long len;\r\nif (ax->tty == NULL)\r\nreturn -ENODEV;\r\nlen = dev->mtu * 2;\r\nif (len < 576 * 2)\r\nlen = 576 * 2;\r\nif ((ax->rbuff = kmalloc(len + 4, GFP_KERNEL)) == NULL)\r\ngoto norbuff;\r\nif ((ax->xbuff = kmalloc(len + 4, GFP_KERNEL)) == NULL)\r\ngoto noxbuff;\r\nax->mtu = dev->mtu + 73;\r\nax->buffsize = len;\r\nax->rcount = 0;\r\nax->xleft = 0;\r\nax->flags &= (1 << AXF_INUSE);\r\nspin_lock_init(&ax->buflock);\r\nreturn 0;\r\nnoxbuff:\r\nkfree(ax->rbuff);\r\nnorbuff:\r\nreturn -ENOMEM;\r\n}\r\nstatic int ax_close(struct net_device *dev)\r\n{\r\nstruct mkiss *ax = netdev_priv(dev);\r\nif (ax->tty)\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags);\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void ax_setup(struct net_device *dev)\r\n{\r\ndev->mtu = AX_MTU;\r\ndev->hard_header_len = 0;\r\ndev->addr_len = 0;\r\ndev->type = ARPHRD_AX25;\r\ndev->tx_queue_len = 10;\r\ndev->header_ops = &ax_header_ops;\r\ndev->netdev_ops = &ax_netdev_ops;\r\nmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\r\nmemcpy(dev->dev_addr, &ax25_defaddr, AX25_ADDR_LEN);\r\ndev->flags = IFF_BROADCAST | IFF_MULTICAST;\r\n}\r\nstatic struct mkiss *mkiss_get(struct tty_struct *tty)\r\n{\r\nstruct mkiss *ax;\r\nread_lock(&disc_data_lock);\r\nax = tty->disc_data;\r\nif (ax)\r\natomic_inc(&ax->refcnt);\r\nread_unlock(&disc_data_lock);\r\nreturn ax;\r\n}\r\nstatic void mkiss_put(struct mkiss *ax)\r\n{\r\nif (atomic_dec_and_test(&ax->refcnt))\r\nup(&ax->dead_sem);\r\n}\r\nstatic int mkiss_open(struct tty_struct *tty)\r\n{\r\nstruct net_device *dev;\r\nstruct mkiss *ax;\r\nint err;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (tty->ops->write == NULL)\r\nreturn -EOPNOTSUPP;\r\ndev = alloc_netdev(sizeof(struct mkiss), "ax%d", ax_setup);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nax = netdev_priv(dev);\r\nax->dev = dev;\r\nspin_lock_init(&ax->buflock);\r\natomic_set(&ax->refcnt, 1);\r\nsema_init(&ax->dead_sem, 0);\r\nax->tty = tty;\r\ntty->disc_data = ax;\r\ntty->receive_room = 65535;\r\ntty_driver_flush_buffer(tty);\r\ndev->type = ARPHRD_AX25;\r\nif ((err = ax_open(ax->dev))) {\r\ngoto out_free_netdev;\r\n}\r\nif (register_netdev(dev))\r\ngoto out_free_buffers;\r\nswitch (crc_force) {\r\ncase 3:\r\nax->crcmode = CRC_MODE_SMACK;\r\nprintk(KERN_INFO "mkiss: %s: crc mode smack forced.\n",\r\nax->dev->name);\r\nbreak;\r\ncase 2:\r\nax->crcmode = CRC_MODE_FLEX;\r\nprintk(KERN_INFO "mkiss: %s: crc mode flexnet forced.\n",\r\nax->dev->name);\r\nbreak;\r\ncase 1:\r\nax->crcmode = CRC_MODE_NONE;\r\nprintk(KERN_INFO "mkiss: %s: crc mode disabled.\n",\r\nax->dev->name);\r\nbreak;\r\ncase 0:\r\ndefault:\r\ncrc_force = 0;\r\nprintk(KERN_INFO "mkiss: %s: crc mode is auto.\n",\r\nax->dev->name);\r\nax->crcmode = CRC_MODE_SMACK_TEST;\r\n}\r\nax->crcauto = (crc_force ? 0 : 1);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nout_free_buffers:\r\nkfree(ax->rbuff);\r\nkfree(ax->xbuff);\r\nout_free_netdev:\r\nfree_netdev(dev);\r\nout:\r\nreturn err;\r\n}\r\nstatic void mkiss_close(struct tty_struct *tty)\r\n{\r\nstruct mkiss *ax;\r\nwrite_lock_bh(&disc_data_lock);\r\nax = tty->disc_data;\r\ntty->disc_data = NULL;\r\nwrite_unlock_bh(&disc_data_lock);\r\nif (!ax)\r\nreturn;\r\nif (!atomic_dec_and_test(&ax->refcnt))\r\ndown(&ax->dead_sem);\r\nunregister_netdev(ax->dev);\r\nkfree(ax->rbuff);\r\nkfree(ax->xbuff);\r\nax->tty = NULL;\r\n}\r\nstatic int mkiss_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct mkiss *ax = mkiss_get(tty);\r\nstruct net_device *dev;\r\nunsigned int tmp, err;\r\nif (ax == NULL)\r\nreturn -ENXIO;\r\ndev = ax->dev;\r\nswitch (cmd) {\r\ncase SIOCGIFNAME:\r\nerr = copy_to_user((void __user *) arg, ax->dev->name,\r\nstrlen(ax->dev->name) + 1) ? -EFAULT : 0;\r\nbreak;\r\ncase SIOCGIFENCAP:\r\nerr = put_user(4, (int __user *) arg);\r\nbreak;\r\ncase SIOCSIFENCAP:\r\nif (get_user(tmp, (int __user *) arg)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nax->mode = tmp;\r\ndev->addr_len = AX25_ADDR_LEN;\r\ndev->hard_header_len = AX25_KISS_HEADER_LEN +\r\nAX25_MAX_HEADER_LEN + 3;\r\ndev->type = ARPHRD_AX25;\r\nerr = 0;\r\nbreak;\r\ncase SIOCSIFHWADDR: {\r\nchar addr[AX25_ADDR_LEN];\r\nif (copy_from_user(&addr,\r\n(void __user *) arg, AX25_ADDR_LEN)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nnetif_tx_lock_bh(dev);\r\nmemcpy(dev->dev_addr, addr, AX25_ADDR_LEN);\r\nnetif_tx_unlock_bh(dev);\r\nerr = 0;\r\nbreak;\r\n}\r\ndefault:\r\nerr = -ENOIOCTLCMD;\r\n}\r\nmkiss_put(ax);\r\nreturn err;\r\n}\r\nstatic long mkiss_compat_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase SIOCGIFNAME:\r\ncase SIOCGIFENCAP:\r\ncase SIOCSIFENCAP:\r\ncase SIOCSIFHWADDR:\r\nreturn mkiss_ioctl(tty, file, cmd,\r\n(unsigned long)compat_ptr(arg));\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void mkiss_receive_buf(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nstruct mkiss *ax = mkiss_get(tty);\r\nif (!ax)\r\nreturn;\r\nif (ax->mtu != ax->dev->mtu + 73)\r\nax_changedmtu(ax);\r\nwhile (count--) {\r\nif (fp != NULL && *fp++) {\r\nif (!test_and_set_bit(AXF_ERROR, &ax->flags))\r\nax->dev->stats.rx_errors++;\r\ncp++;\r\ncontinue;\r\n}\r\nkiss_unesc(ax, *cp++);\r\n}\r\nmkiss_put(ax);\r\ntty_unthrottle(tty);\r\n}\r\nstatic void mkiss_write_wakeup(struct tty_struct *tty)\r\n{\r\nstruct mkiss *ax = mkiss_get(tty);\r\nint actual;\r\nif (!ax)\r\nreturn;\r\nif (ax->xleft <= 0) {\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nnetif_wake_queue(ax->dev);\r\ngoto out;\r\n}\r\nactual = tty->ops->write(tty, ax->xhead, ax->xleft);\r\nax->xleft -= actual;\r\nax->xhead += actual;\r\nout:\r\nmkiss_put(ax);\r\n}\r\nstatic int __init mkiss_init_driver(void)\r\n{\r\nint status;\r\nprintk(banner);\r\nstatus = tty_register_ldisc(N_AX25, &ax_ldisc);\r\nif (status != 0)\r\nprintk(msg_regfail, status);\r\nreturn status;\r\n}\r\nstatic void __exit mkiss_exit_driver(void)\r\n{\r\nint ret;\r\nif ((ret = tty_unregister_ldisc(N_AX25)))\r\nprintk(msg_unregfail, ret);\r\n}
