void nmi_dump(void)\r\n{\r\nvoid cont_nmi_dump(void);\r\ncont_nmi_dump();\r\n}\r\nvoid install_cpu_nmi_handler(int slice)\r\n{\r\nnmi_t *nmi_addr;\r\nnmi_addr = (nmi_t *)NMI_ADDR(get_nasid(), slice);\r\nif (nmi_addr->call_addr)\r\nreturn;\r\nnmi_addr->magic = NMI_MAGIC;\r\nnmi_addr->call_addr = (void *)nmi_dump;\r\nnmi_addr->call_addr_c =\r\n(void *)(~((unsigned long)(nmi_addr->call_addr)));\r\nnmi_addr->call_parm = 0;\r\n}\r\nvoid nmi_cpu_eframe_save(nasid_t nasid, int slice)\r\n{\r\nstruct reg_struct *nr;\r\nint i;\r\nnr = (struct reg_struct *)\r\n(TO_UNCAC(TO_NODE(nasid, IP27_NMI_KREGS_OFFSET)) +\r\nslice * IP27_NMI_KREGS_CPU_SIZE);\r\nprintk("NMI nasid %d: slice %d\n", nasid, slice);\r\nfor (i = 0; i < 32; ) {\r\nif ((i % 4) == 0)\r\nprintk("$%2d :", i);\r\nprintk(" %016lx", nr->gpr[i]);\r\ni++;\r\nif ((i % 4) == 0)\r\nprintk("\n");\r\n}\r\nprintk("Hi : (value lost)\n");\r\nprintk("Lo : (value lost)\n");\r\nprintk("epc : %016lx %pS\n", nr->epc, (void *) nr->epc);\r\nprintk("%s\n", print_tainted());\r\nprintk("ErrEPC: %016lx %pS\n", nr->error_epc, (void *) nr->error_epc);\r\nprintk("ra : %016lx %pS\n", nr->gpr[31], (void *) nr->gpr[31]);\r\nprintk("Status: %08lx ", nr->sr);\r\nif (nr->sr & ST0_KX)\r\nprintk("KX ");\r\nif (nr->sr & ST0_SX)\r\nprintk("SX ");\r\nif (nr->sr & ST0_UX)\r\nprintk("UX ");\r\nswitch (nr->sr & ST0_KSU) {\r\ncase KSU_USER:\r\nprintk("USER ");\r\nbreak;\r\ncase KSU_SUPERVISOR:\r\nprintk("SUPERVISOR ");\r\nbreak;\r\ncase KSU_KERNEL:\r\nprintk("KERNEL ");\r\nbreak;\r\ndefault:\r\nprintk("BAD_MODE ");\r\nbreak;\r\n}\r\nif (nr->sr & ST0_ERL)\r\nprintk("ERL ");\r\nif (nr->sr & ST0_EXL)\r\nprintk("EXL ");\r\nif (nr->sr & ST0_IE)\r\nprintk("IE ");\r\nprintk("\n");\r\nprintk("Cause : %08lx\n", nr->cause);\r\nprintk("PrId : %08x\n", read_c0_prid());\r\nprintk("BadVA : %016lx\n", nr->badva);\r\nprintk("CErr : %016lx\n", nr->cache_err);\r\nprintk("NMI_SR: %016lx\n", nr->nmi_sr);\r\nprintk("\n");\r\n}\r\nvoid nmi_dump_hub_irq(nasid_t nasid, int slice)\r\n{\r\nhubreg_t mask0, mask1, pend0, pend1;\r\nif (slice == 0) {\r\nmask0 = REMOTE_HUB_L(nasid, PI_INT_MASK0_A);\r\nmask1 = REMOTE_HUB_L(nasid, PI_INT_MASK1_A);\r\n} else {\r\nmask0 = REMOTE_HUB_L(nasid, PI_INT_MASK0_B);\r\nmask1 = REMOTE_HUB_L(nasid, PI_INT_MASK1_B);\r\n}\r\npend0 = REMOTE_HUB_L(nasid, PI_INT_PEND0);\r\npend1 = REMOTE_HUB_L(nasid, PI_INT_PEND1);\r\nprintk("PI_INT_MASK0: %16Lx PI_INT_MASK1: %16Lx\n", mask0, mask1);\r\nprintk("PI_INT_PEND0: %16Lx PI_INT_PEND1: %16Lx\n", pend0, pend1);\r\nprintk("\n\n");\r\n}\r\nvoid nmi_node_eframe_save(cnodeid_t cnode)\r\n{\r\nnasid_t nasid;\r\nint slice;\r\nif (cnode == CNODEID_NONE)\r\nreturn;\r\nnasid = COMPACT_TO_NASID_NODEID(cnode);\r\nif (nasid == INVALID_NASID)\r\nreturn;\r\nfor (slice = 0; slice < NODE_NUM_CPUS(slice); slice++) {\r\nnmi_cpu_eframe_save(nasid, slice);\r\nnmi_dump_hub_irq(nasid, slice);\r\n}\r\n}\r\nvoid\r\nnmi_eframes_save(void)\r\n{\r\ncnodeid_t cnode;\r\nfor_each_online_node(cnode)\r\nnmi_node_eframe_save(cnode);\r\n}\r\nvoid\r\ncont_nmi_dump(void)\r\n{\r\n#ifndef REAL_NMI_SIGNAL\r\nstatic atomic_t nmied_cpus = ATOMIC_INIT(0);\r\natomic_inc(&nmied_cpus);\r\n#endif\r\narch_spin_lock(&nmi_lock);\r\n#ifdef REAL_NMI_SIGNAL\r\nfor (i=0; i < 1500; i++) {\r\nfor_each_online_node(node)\r\nif (NODEPDA(node)->dump_count == 0)\r\nbreak;\r\nif (node == MAX_NUMNODES)\r\nbreak;\r\nif (i == 1000) {\r\nfor_each_online_node(node)\r\nif (NODEPDA(node)->dump_count == 0) {\r\ncpu = cpumask_first(cpumask_of_node(node));\r\nfor (n=0; n < CNODE_NUM_CPUS(node); cpu++, n++) {\r\nCPUMASK_SETB(nmied_cpus, cpu);\r\nSEND_NMI((cputonasid(cpu)), (cputoslice(cpu)));\r\n}\r\n}\r\n}\r\nudelay(10000);\r\n}\r\n#else\r\nwhile (atomic_read(&nmied_cpus) != num_online_cpus());\r\n#endif\r\nnmi_eframes_save();\r\nLOCAL_HUB_S(NI_PORT_RESET, NPR_PORTRESET | NPR_LOCALRESET);\r\n}
