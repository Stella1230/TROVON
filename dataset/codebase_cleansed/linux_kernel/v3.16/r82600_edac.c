static void r82600_get_error_info(struct mem_ctl_info *mci,\r\nstruct r82600_error_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(mci->pdev);\r\npci_read_config_dword(pdev, R82600_EAP, &info->eapr);\r\nif (info->eapr & BIT(0))\r\npci_write_bits32(pdev, R82600_EAP,\r\n((u32) BIT(0) & (u32) BIT(1)),\r\n((u32) BIT(0) & (u32) BIT(1)));\r\nif (info->eapr & BIT(1))\r\npci_write_bits32(pdev, R82600_EAP,\r\n((u32) BIT(0) & (u32) BIT(1)),\r\n((u32) BIT(0) & (u32) BIT(1)));\r\n}\r\nstatic int r82600_process_error_info(struct mem_ctl_info *mci,\r\nstruct r82600_error_info *info,\r\nint handle_errors)\r\n{\r\nint error_found;\r\nu32 eapaddr, page;\r\nu32 syndrome;\r\nerror_found = 0;\r\neapaddr = ((info->eapr >> 12) & 0x7FFF) << 13;\r\nsyndrome = (info->eapr >> 4) & 0xFF;\r\npage = eapaddr >> PAGE_SHIFT;\r\nif (info->eapr & BIT(0)) {\r\nerror_found = 1;\r\nif (handle_errors)\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\npage, 0, syndrome,\r\nedac_mc_find_csrow_by_page(mci, page),\r\n0, -1,\r\nmci->ctl_name, "");\r\n}\r\nif (info->eapr & BIT(1)) {\r\nerror_found = 1;\r\nif (handle_errors)\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\npage, 0, 0,\r\nedac_mc_find_csrow_by_page(mci, page),\r\n0, -1,\r\nmci->ctl_name, "");\r\n}\r\nreturn error_found;\r\n}\r\nstatic void r82600_check(struct mem_ctl_info *mci)\r\n{\r\nstruct r82600_error_info info;\r\nedac_dbg(1, "MC%d\n", mci->mc_idx);\r\nr82600_get_error_info(mci, &info);\r\nr82600_process_error_info(mci, &info, 1);\r\n}\r\nstatic inline int ecc_enabled(u8 dramcr)\r\n{\r\nreturn dramcr & BIT(5);\r\n}\r\nstatic void r82600_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,\r\nu8 dramcr)\r\n{\r\nstruct csrow_info *csrow;\r\nstruct dimm_info *dimm;\r\nint index;\r\nu8 drbar;\r\nu32 row_high_limit, row_high_limit_last;\r\nu32 reg_sdram, ecc_on, row_base;\r\necc_on = ecc_enabled(dramcr);\r\nreg_sdram = dramcr & BIT(4);\r\nrow_high_limit_last = 0;\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\ncsrow = mci->csrows[index];\r\ndimm = csrow->channels[0]->dimm;\r\npci_read_config_byte(pdev, R82600_DRBA + index, &drbar);\r\nedac_dbg(1, "Row=%d DRBA = %#0x\n", index, drbar);\r\nrow_high_limit = ((u32) drbar << 24);\r\nedac_dbg(1, "Row=%d, Boundary Address=%#0x, Last = %#0x\n",\r\nindex, row_high_limit, row_high_limit_last);\r\nif (row_high_limit == row_high_limit_last)\r\ncontinue;\r\nrow_base = row_high_limit_last;\r\ncsrow->first_page = row_base >> PAGE_SHIFT;\r\ncsrow->last_page = (row_high_limit >> PAGE_SHIFT) - 1;\r\ndimm->nr_pages = csrow->last_page - csrow->first_page + 1;\r\ndimm->grain = 1 << 14;\r\ndimm->mtype = reg_sdram ? MEM_RDDR : MEM_DDR;\r\ndimm->dtype = DEV_UNKNOWN;\r\ndimm->edac_mode = ecc_on ? EDAC_SECDED : EDAC_NONE;\r\nrow_high_limit_last = row_high_limit;\r\n}\r\n}\r\nstatic int r82600_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nu8 dramcr;\r\nu32 eapr;\r\nu32 scrub_disabled;\r\nu32 sdram_refresh_rate;\r\nstruct r82600_error_info discard;\r\nedac_dbg(0, "\n");\r\npci_read_config_byte(pdev, R82600_DRAMC, &dramcr);\r\npci_read_config_dword(pdev, R82600_EAP, &eapr);\r\nscrub_disabled = eapr & BIT(31);\r\nsdram_refresh_rate = dramcr & (BIT(0) | BIT(1));\r\nedac_dbg(2, "sdram refresh rate = %#0x\n", sdram_refresh_rate);\r\nedac_dbg(2, "DRAMC register = %#0x\n", dramcr);\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = R82600_NR_CSROWS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = R82600_NR_CHANS;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\nedac_dbg(0, "mci = %p\n", mci);\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_RDDR | MEM_FLAG_DDR;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\r\nif (ecc_enabled(dramcr)) {\r\nif (scrub_disabled)\r\nedac_dbg(3, "mci = %p - Scrubbing disabled! EAP: %#0x\n",\r\nmci, eapr);\r\n} else\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = R82600_REVISION;\r\nmci->ctl_name = "R82600";\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = r82600_check;\r\nmci->ctl_page_to_phys = NULL;\r\nr82600_init_csrows(mci, pdev, dramcr);\r\nr82600_get_error_info(mci, &discard);\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto fail;\r\n}\r\nif (disable_hardware_scrub) {\r\nedac_dbg(3, "Disabling Hardware Scrub (scrub on error)\n");\r\npci_write_bits32(pdev, R82600_EAP, BIT(31), BIT(31));\r\n}\r\nr82600_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!r82600_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n",\r\n__func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\nedac_dbg(3, "success\n");\r\nreturn 0;\r\nfail:\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic int r82600_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nedac_dbg(0, "\n");\r\nreturn r82600_probe1(pdev, ent->driver_data);\r\n}\r\nstatic void r82600_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nedac_dbg(0, "\n");\r\nif (r82600_pci)\r\nedac_pci_release_generic_ctl(r82600_pci);\r\nif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\r\nreturn;\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init r82600_init(void)\r\n{\r\nopstate_init();\r\nreturn pci_register_driver(&r82600_driver);\r\n}\r\nstatic void __exit r82600_exit(void)\r\n{\r\npci_unregister_driver(&r82600_driver);\r\n}
