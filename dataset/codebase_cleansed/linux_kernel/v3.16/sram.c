static int sram_reserve_cmp(void *priv, struct list_head *a,\r\nstruct list_head *b)\r\n{\r\nstruct sram_reserve *ra = list_entry(a, struct sram_reserve, list);\r\nstruct sram_reserve *rb = list_entry(b, struct sram_reserve, list);\r\nreturn ra->start - rb->start;\r\n}\r\nstatic int sram_probe(struct platform_device *pdev)\r\n{\r\nvoid __iomem *virt_base;\r\nstruct sram_dev *sram;\r\nstruct resource *res;\r\nstruct device_node *np = pdev->dev.of_node, *child;\r\nunsigned long size, cur_start, cur_size;\r\nstruct sram_reserve *rblocks, *block;\r\nstruct list_head reserve_list;\r\nunsigned int nblocks;\r\nint ret;\r\nINIT_LIST_HEAD(&reserve_list);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nvirt_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(virt_base))\r\nreturn PTR_ERR(virt_base);\r\nsize = resource_size(res);\r\nsram = devm_kzalloc(&pdev->dev, sizeof(*sram), GFP_KERNEL);\r\nif (!sram)\r\nreturn -ENOMEM;\r\nsram->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(sram->clk))\r\nsram->clk = NULL;\r\nelse\r\nclk_prepare_enable(sram->clk);\r\nsram->pool = devm_gen_pool_create(&pdev->dev, ilog2(SRAM_GRANULARITY), -1);\r\nif (!sram->pool)\r\nreturn -ENOMEM;\r\nnblocks = (np) ? of_get_available_child_count(np) + 1 : 1;\r\nrblocks = kmalloc((nblocks) * sizeof(*rblocks), GFP_KERNEL);\r\nif (!rblocks) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nblock = &rblocks[0];\r\nfor_each_available_child_of_node(np, child) {\r\nstruct resource child_res;\r\nret = of_address_to_resource(child, 0, &child_res);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"could not get address for node %s\n",\r\nchild->full_name);\r\ngoto err_chunks;\r\n}\r\nif (child_res.start < res->start || child_res.end > res->end) {\r\ndev_err(&pdev->dev,\r\n"reserved block %s outside the sram area\n",\r\nchild->full_name);\r\nret = -EINVAL;\r\ngoto err_chunks;\r\n}\r\nblock->start = child_res.start - res->start;\r\nblock->size = resource_size(&child_res);\r\nlist_add_tail(&block->list, &reserve_list);\r\ndev_dbg(&pdev->dev, "found reserved block 0x%x-0x%x\n",\r\nblock->start,\r\nblock->start + block->size);\r\nblock++;\r\n}\r\nrblocks[nblocks - 1].start = size;\r\nrblocks[nblocks - 1].size = 0;\r\nlist_add_tail(&rblocks[nblocks - 1].list, &reserve_list);\r\nlist_sort(NULL, &reserve_list, sram_reserve_cmp);\r\ncur_start = 0;\r\nlist_for_each_entry(block, &reserve_list, list) {\r\nif (block->start < cur_start) {\r\ndev_err(&pdev->dev,\r\n"block at 0x%x starts after current offset 0x%lx\n",\r\nblock->start, cur_start);\r\nret = -EINVAL;\r\ngoto err_chunks;\r\n}\r\nif (block->start == cur_start) {\r\ncur_start = block->start + block->size;\r\ncontinue;\r\n}\r\ncur_size = block->start - cur_start;\r\ndev_dbg(&pdev->dev, "adding chunk 0x%lx-0x%lx\n",\r\ncur_start, cur_start + cur_size);\r\nret = gen_pool_add_virt(sram->pool,\r\n(unsigned long)virt_base + cur_start,\r\nres->start + cur_start, cur_size, -1);\r\nif (ret < 0)\r\ngoto err_chunks;\r\ncur_start = block->start + block->size;\r\n}\r\nkfree(rblocks);\r\nplatform_set_drvdata(pdev, sram);\r\ndev_dbg(&pdev->dev, "SRAM pool: %ld KiB @ 0x%p\n", size / 1024, virt_base);\r\nreturn 0;\r\nerr_chunks:\r\nkfree(rblocks);\r\nerr_alloc:\r\nif (sram->clk)\r\nclk_disable_unprepare(sram->clk);\r\nreturn ret;\r\n}\r\nstatic int sram_remove(struct platform_device *pdev)\r\n{\r\nstruct sram_dev *sram = platform_get_drvdata(pdev);\r\nif (gen_pool_avail(sram->pool) < gen_pool_size(sram->pool))\r\ndev_dbg(&pdev->dev, "removed while SRAM allocated\n");\r\nif (sram->clk)\r\nclk_disable_unprepare(sram->clk);\r\nreturn 0;\r\n}\r\nstatic int __init sram_init(void)\r\n{\r\nreturn platform_driver_register(&sram_driver);\r\n}
