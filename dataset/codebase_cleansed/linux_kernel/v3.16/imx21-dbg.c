static inline void create_debug_files(struct imx21 *imx21) { }\r\nstatic inline void remove_debug_files(struct imx21 *imx21) { }\r\nstatic inline void debug_urb_submitted(struct imx21 *imx21, struct urb *urb) {}\r\nstatic inline void debug_urb_completed(struct imx21 *imx21, struct urb *urb,\r\nint status) {}\r\nstatic inline void debug_urb_unlinked(struct imx21 *imx21, struct urb *urb) {}\r\nstatic inline void debug_urb_queued_for_etd(struct imx21 *imx21,\r\nstruct urb *urb) {}\r\nstatic inline void debug_urb_queued_for_dmem(struct imx21 *imx21,\r\nstruct urb *urb) {}\r\nstatic inline void debug_etd_allocated(struct imx21 *imx21) {}\r\nstatic inline void debug_etd_freed(struct imx21 *imx21) {}\r\nstatic inline void debug_dmem_allocated(struct imx21 *imx21, int size) {}\r\nstatic inline void debug_dmem_freed(struct imx21 *imx21, int size) {}\r\nstatic inline void debug_isoc_submitted(struct imx21 *imx21,\r\nint frame, struct td *td) {}\r\nstatic inline void debug_isoc_completed(struct imx21 *imx21,\r\nint frame, struct td *td, int cc, int len) {}\r\nstatic inline struct debug_stats *stats_for_urb(struct imx21 *imx21,\r\nstruct urb *urb)\r\n{\r\nreturn usb_pipeisoc(urb->pipe) ?\r\n&imx21->isoc_stats : &imx21->nonisoc_stats;\r\n}\r\nstatic void debug_urb_submitted(struct imx21 *imx21, struct urb *urb)\r\n{\r\nstats_for_urb(imx21, urb)->submitted++;\r\n}\r\nstatic void debug_urb_completed(struct imx21 *imx21, struct urb *urb, int st)\r\n{\r\nif (st)\r\nstats_for_urb(imx21, urb)->completed_failed++;\r\nelse\r\nstats_for_urb(imx21, urb)->completed_ok++;\r\n}\r\nstatic void debug_urb_unlinked(struct imx21 *imx21, struct urb *urb)\r\n{\r\nstats_for_urb(imx21, urb)->unlinked++;\r\n}\r\nstatic void debug_urb_queued_for_etd(struct imx21 *imx21, struct urb *urb)\r\n{\r\nstats_for_urb(imx21, urb)->queue_etd++;\r\n}\r\nstatic void debug_urb_queued_for_dmem(struct imx21 *imx21, struct urb *urb)\r\n{\r\nstats_for_urb(imx21, urb)->queue_dmem++;\r\n}\r\nstatic inline void debug_etd_allocated(struct imx21 *imx21)\r\n{\r\nimx21->etd_usage.maximum = max(\r\n++(imx21->etd_usage.value),\r\nimx21->etd_usage.maximum);\r\n}\r\nstatic inline void debug_etd_freed(struct imx21 *imx21)\r\n{\r\nimx21->etd_usage.value--;\r\n}\r\nstatic inline void debug_dmem_allocated(struct imx21 *imx21, int size)\r\n{\r\nimx21->dmem_usage.value += size;\r\nimx21->dmem_usage.maximum = max(\r\nimx21->dmem_usage.value,\r\nimx21->dmem_usage.maximum);\r\n}\r\nstatic inline void debug_dmem_freed(struct imx21 *imx21, int size)\r\n{\r\nimx21->dmem_usage.value -= size;\r\n}\r\nstatic void debug_isoc_submitted(struct imx21 *imx21,\r\nint frame, struct td *td)\r\n{\r\nstruct debug_isoc_trace *trace = &imx21->isoc_trace[\r\nimx21->isoc_trace_index++];\r\nimx21->isoc_trace_index %= ARRAY_SIZE(imx21->isoc_trace);\r\ntrace->schedule_frame = td->frame;\r\ntrace->submit_frame = frame;\r\ntrace->request_len = td->len;\r\ntrace->td = td;\r\n}\r\nstatic inline void debug_isoc_completed(struct imx21 *imx21,\r\nint frame, struct td *td, int cc, int len)\r\n{\r\nstruct debug_isoc_trace *trace, *trace_failed;\r\nint i;\r\nint found = 0;\r\ntrace = imx21->isoc_trace;\r\nfor (i = 0; i < ARRAY_SIZE(imx21->isoc_trace); i++, trace++) {\r\nif (trace->td == td) {\r\ntrace->done_frame = frame;\r\ntrace->done_len = len;\r\ntrace->cc = cc;\r\ntrace->td = NULL;\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found && cc) {\r\ntrace_failed = &imx21->isoc_trace_failed[\r\nimx21->isoc_trace_index_failed++];\r\nimx21->isoc_trace_index_failed %= ARRAY_SIZE(\r\nimx21->isoc_trace_failed);\r\n*trace_failed = *trace;\r\n}\r\n}\r\nstatic char *format_ep(struct usb_host_endpoint *ep, char *buf, int bufsize)\r\n{\r\nif (ep)\r\nsnprintf(buf, bufsize, "ep_%02x (type:%02X kaddr:%p)",\r\nep->desc.bEndpointAddress,\r\nusb_endpoint_type(&ep->desc),\r\nep);\r\nelse\r\nsnprintf(buf, bufsize, "none");\r\nreturn buf;\r\n}\r\nstatic char *format_etd_dword0(u32 value, char *buf, int bufsize)\r\n{\r\nsnprintf(buf, bufsize,\r\n"addr=%d ep=%d dir=%s speed=%s format=%s halted=%d",\r\nvalue & 0x7F,\r\n(value >> DW0_ENDPNT) & 0x0F,\r\ndir_labels[(value >> DW0_DIRECT) & 0x03],\r\nspeed_labels[(value >> DW0_SPEED) & 0x01],\r\nformat_labels[(value >> DW0_FORMAT) & 0x03],\r\n(value >> DW0_HALTED) & 0x01);\r\nreturn buf;\r\n}\r\nstatic int debug_status_show(struct seq_file *s, void *v)\r\n{\r\nstruct imx21 *imx21 = s->private;\r\nint etds_allocated = 0;\r\nint etds_sw_busy = 0;\r\nint etds_hw_busy = 0;\r\nint dmem_blocks = 0;\r\nint queued_for_etd = 0;\r\nint queued_for_dmem = 0;\r\nunsigned int dmem_bytes = 0;\r\nint i;\r\nstruct etd_priv *etd;\r\nu32 etd_enable_mask;\r\nunsigned long flags;\r\nstruct imx21_dmem_area *dmem;\r\nstruct ep_priv *ep_priv;\r\nspin_lock_irqsave(&imx21->lock, flags);\r\netd_enable_mask = readl(imx21->regs + USBH_ETDENSET);\r\nfor (i = 0, etd = imx21->etd; i < USB_NUM_ETD; i++, etd++) {\r\nif (etd->alloc)\r\netds_allocated++;\r\nif (etd->urb)\r\netds_sw_busy++;\r\nif (etd_enable_mask & (1<<i))\r\netds_hw_busy++;\r\n}\r\nlist_for_each_entry(dmem, &imx21->dmem_list, list) {\r\ndmem_bytes += dmem->size;\r\ndmem_blocks++;\r\n}\r\nlist_for_each_entry(ep_priv, &imx21->queue_for_etd, queue)\r\nqueued_for_etd++;\r\nlist_for_each_entry(etd, &imx21->queue_for_dmem, queue)\r\nqueued_for_dmem++;\r\nspin_unlock_irqrestore(&imx21->lock, flags);\r\nseq_printf(s,\r\n"Frame: %d\n"\r\n"ETDs allocated: %d/%d (max=%d)\n"\r\n"ETDs in use sw: %d\n"\r\n"ETDs in use hw: %d\n"\r\n"DMEM allocated: %d/%d (max=%d)\n"\r\n"DMEM blocks: %d\n"\r\n"Queued waiting for ETD: %d\n"\r\n"Queued waiting for DMEM: %d\n",\r\nreadl(imx21->regs + USBH_FRMNUB) & 0xFFFF,\r\netds_allocated, USB_NUM_ETD, imx21->etd_usage.maximum,\r\netds_sw_busy,\r\netds_hw_busy,\r\ndmem_bytes, DMEM_SIZE, imx21->dmem_usage.maximum,\r\ndmem_blocks,\r\nqueued_for_etd,\r\nqueued_for_dmem);\r\nreturn 0;\r\n}\r\nstatic int debug_dmem_show(struct seq_file *s, void *v)\r\n{\r\nstruct imx21 *imx21 = s->private;\r\nstruct imx21_dmem_area *dmem;\r\nunsigned long flags;\r\nchar ep_text[40];\r\nspin_lock_irqsave(&imx21->lock, flags);\r\nlist_for_each_entry(dmem, &imx21->dmem_list, list)\r\nseq_printf(s,\r\n"%04X: size=0x%X "\r\n"ep=%s\n",\r\ndmem->offset, dmem->size,\r\nformat_ep(dmem->ep, ep_text, sizeof(ep_text)));\r\nspin_unlock_irqrestore(&imx21->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int debug_etd_show(struct seq_file *s, void *v)\r\n{\r\nstruct imx21 *imx21 = s->private;\r\nstruct etd_priv *etd;\r\nchar buf[60];\r\nu32 dword;\r\nint i, j;\r\nunsigned long flags;\r\nspin_lock_irqsave(&imx21->lock, flags);\r\nfor (i = 0, etd = imx21->etd; i < USB_NUM_ETD; i++, etd++) {\r\nint state = -1;\r\nstruct urb_priv *urb_priv;\r\nif (etd->urb) {\r\nurb_priv = etd->urb->hcpriv;\r\nif (urb_priv)\r\nstate = urb_priv->state;\r\n}\r\nseq_printf(s,\r\n"etd_num: %d\n"\r\n"ep: %s\n"\r\n"alloc: %d\n"\r\n"len: %d\n"\r\n"busy sw: %d\n"\r\n"busy hw: %d\n"\r\n"urb state: %d\n"\r\n"current urb: %p\n",\r\ni,\r\nformat_ep(etd->ep, buf, sizeof(buf)),\r\netd->alloc,\r\netd->len,\r\netd->urb != NULL,\r\n(readl(imx21->regs + USBH_ETDENSET) & (1 << i)) > 0,\r\nstate,\r\netd->urb);\r\nfor (j = 0; j < 4; j++) {\r\ndword = etd_readl(imx21, i, j);\r\nswitch (j) {\r\ncase 0:\r\nformat_etd_dword0(dword, buf, sizeof(buf));\r\nbreak;\r\ncase 2:\r\nsnprintf(buf, sizeof(buf),\r\n"cc=0X%02X", dword >> DW2_COMPCODE);\r\nbreak;\r\ndefault:\r\n*buf = 0;\r\nbreak;\r\n}\r\nseq_printf(s,\r\n"dword %d: submitted=%08X cur=%08X [%s]\n",\r\nj,\r\netd->submitted_dwords[j],\r\ndword,\r\nbuf);\r\n}\r\nseq_printf(s, "\n");\r\n}\r\nspin_unlock_irqrestore(&imx21->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void debug_statistics_show_one(struct seq_file *s,\r\nconst char *name, struct debug_stats *stats)\r\n{\r\nseq_printf(s, "%s:\n"\r\n"submitted URBs: %lu\n"\r\n"completed OK: %lu\n"\r\n"completed failed: %lu\n"\r\n"unlinked: %lu\n"\r\n"queued for ETD: %lu\n"\r\n"queued for DMEM: %lu\n\n",\r\nname,\r\nstats->submitted,\r\nstats->completed_ok,\r\nstats->completed_failed,\r\nstats->unlinked,\r\nstats->queue_etd,\r\nstats->queue_dmem);\r\n}\r\nstatic int debug_statistics_show(struct seq_file *s, void *v)\r\n{\r\nstruct imx21 *imx21 = s->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&imx21->lock, flags);\r\ndebug_statistics_show_one(s, "nonisoc", &imx21->nonisoc_stats);\r\ndebug_statistics_show_one(s, "isoc", &imx21->isoc_stats);\r\nseq_printf(s, "unblock kludge triggers: %lu\n", imx21->debug_unblocks);\r\nspin_unlock_irqrestore(&imx21->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void debug_isoc_show_one(struct seq_file *s,\r\nconst char *name, int index, struct debug_isoc_trace *trace)\r\n{\r\nseq_printf(s, "%s %d:\n"\r\n"cc=0X%02X\n"\r\n"scheduled frame %d (%d)\n"\r\n"submitted frame %d (%d)\n"\r\n"completed frame %d (%d)\n"\r\n"requested length=%d\n"\r\n"completed length=%d\n\n",\r\nname, index,\r\ntrace->cc,\r\ntrace->schedule_frame, trace->schedule_frame & 0xFFFF,\r\ntrace->submit_frame, trace->submit_frame & 0xFFFF,\r\ntrace->done_frame, trace->done_frame & 0xFFFF,\r\ntrace->request_len,\r\ntrace->done_len);\r\n}\r\nstatic int debug_isoc_show(struct seq_file *s, void *v)\r\n{\r\nstruct imx21 *imx21 = s->private;\r\nstruct debug_isoc_trace *trace;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&imx21->lock, flags);\r\ntrace = imx21->isoc_trace_failed;\r\nfor (i = 0; i < ARRAY_SIZE(imx21->isoc_trace_failed); i++, trace++)\r\ndebug_isoc_show_one(s, "isoc failed", i, trace);\r\ntrace = imx21->isoc_trace;\r\nfor (i = 0; i < ARRAY_SIZE(imx21->isoc_trace); i++, trace++)\r\ndebug_isoc_show_one(s, "isoc", i, trace);\r\nspin_unlock_irqrestore(&imx21->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int debug_status_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debug_status_show, inode->i_private);\r\n}\r\nstatic int debug_dmem_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debug_dmem_show, inode->i_private);\r\n}\r\nstatic int debug_etd_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debug_etd_show, inode->i_private);\r\n}\r\nstatic int debug_statistics_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debug_statistics_show, inode->i_private);\r\n}\r\nstatic int debug_isoc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debug_isoc_show, inode->i_private);\r\n}\r\nstatic void create_debug_files(struct imx21 *imx21)\r\n{\r\nimx21->debug_root = debugfs_create_dir(dev_name(imx21->dev), NULL);\r\nif (!imx21->debug_root)\r\ngoto failed_create_rootdir;\r\nif (!debugfs_create_file("status", S_IRUGO,\r\nimx21->debug_root, imx21, &debug_status_fops))\r\ngoto failed_create;\r\nif (!debugfs_create_file("dmem", S_IRUGO,\r\nimx21->debug_root, imx21, &debug_dmem_fops))\r\ngoto failed_create;\r\nif (!debugfs_create_file("etd", S_IRUGO,\r\nimx21->debug_root, imx21, &debug_etd_fops))\r\ngoto failed_create;\r\nif (!debugfs_create_file("statistics", S_IRUGO,\r\nimx21->debug_root, imx21, &debug_statistics_fops))\r\ngoto failed_create;\r\nif (!debugfs_create_file("isoc", S_IRUGO,\r\nimx21->debug_root, imx21, &debug_isoc_fops))\r\ngoto failed_create;\r\nreturn;\r\nfailed_create:\r\ndebugfs_remove_recursive(imx21->debug_root);\r\nfailed_create_rootdir:\r\nimx21->debug_root = NULL;\r\n}\r\nstatic void remove_debug_files(struct imx21 *imx21)\r\n{\r\nif (imx21->debug_root) {\r\ndebugfs_remove_recursive(imx21->debug_root);\r\nimx21->debug_root = NULL;\r\n}\r\n}
