int c2_llp_connect(struct iw_cm_id *cm_id, struct iw_cm_conn_param *iw_param)\r\n{\r\nstruct c2_dev *c2dev = to_c2dev(cm_id->device);\r\nstruct ib_qp *ibqp;\r\nstruct c2_qp *qp;\r\nstruct c2wr_qp_connect_req *wr;\r\nstruct c2_vq_req *vq_req;\r\nint err;\r\nstruct sockaddr_in *raddr = (struct sockaddr_in *)&cm_id->remote_addr;\r\nif (cm_id->remote_addr.ss_family != AF_INET)\r\nreturn -ENOSYS;\r\nibqp = c2_get_qp(cm_id->device, iw_param->qpn);\r\nif (!ibqp)\r\nreturn -EINVAL;\r\nqp = to_c2qp(ibqp);\r\ncm_id->provider_data = qp;\r\ncm_id->add_ref(cm_id);\r\nqp->cm_id = cm_id;\r\nif (iw_param->private_data_len > C2_MAX_PRIVATE_DATA_SIZE) {\r\nerr = -EINVAL;\r\ngoto bail0;\r\n}\r\nerr = c2_qp_set_read_limits(c2dev, qp, iw_param->ord, iw_param->ird);\r\nif (err)\r\ngoto bail0;\r\nwr = kmalloc(c2dev->req_vq.msg_size, GFP_KERNEL);\r\nif (!wr) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req) {\r\nerr = -ENOMEM;\r\ngoto bail1;\r\n}\r\nc2_wr_set_id(wr, CCWR_QP_CONNECT);\r\nwr->hdr.context = 0;\r\nwr->rnic_handle = c2dev->adapter_handle;\r\nwr->qp_handle = qp->adapter_handle;\r\nwr->remote_addr = raddr->sin_addr.s_addr;\r\nwr->remote_port = raddr->sin_port;\r\nif (iw_param->private_data) {\r\nwr->private_data_length =\r\ncpu_to_be32(iw_param->private_data_len);\r\nmemcpy(&wr->private_data[0], iw_param->private_data,\r\niw_param->private_data_len);\r\n} else\r\nwr->private_data_length = 0;\r\nerr = vq_send_wr(c2dev, (union c2wr *) wr);\r\nvq_req_free(c2dev, vq_req);\r\nbail1:\r\nkfree(wr);\r\nbail0:\r\nif (err) {\r\ncm_id->provider_data = NULL;\r\nqp->cm_id = NULL;\r\ncm_id->rem_ref(cm_id);\r\n}\r\nreturn err;\r\n}\r\nint c2_llp_service_create(struct iw_cm_id *cm_id, int backlog)\r\n{\r\nstruct c2_dev *c2dev;\r\nstruct c2wr_ep_listen_create_req wr;\r\nstruct c2wr_ep_listen_create_rep *reply;\r\nstruct c2_vq_req *vq_req;\r\nint err;\r\nstruct sockaddr_in *laddr = (struct sockaddr_in *)&cm_id->local_addr;\r\nif (cm_id->local_addr.ss_family != AF_INET)\r\nreturn -ENOSYS;\r\nc2dev = to_c2dev(cm_id->device);\r\nif (c2dev == NULL)\r\nreturn -EINVAL;\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req)\r\nreturn -ENOMEM;\r\nc2_wr_set_id(&wr, CCWR_EP_LISTEN_CREATE);\r\nwr.hdr.context = (u64) (unsigned long) vq_req;\r\nwr.rnic_handle = c2dev->adapter_handle;\r\nwr.local_addr = laddr->sin_addr.s_addr;\r\nwr.local_port = laddr->sin_port;\r\nwr.backlog = cpu_to_be32(backlog);\r\nwr.user_context = (u64) (unsigned long) cm_id;\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) & wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail0;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err)\r\ngoto bail0;\r\nreply =\r\n(struct c2wr_ep_listen_create_rep *) (unsigned long) vq_req->reply_msg;\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail1;\r\n}\r\nif ((err = c2_errno(reply)) != 0)\r\ngoto bail1;\r\ncm_id->provider_data = (void*)(unsigned long) reply->ep_handle;\r\nvq_repbuf_free(c2dev, reply);\r\nvq_req_free(c2dev, vq_req);\r\nreturn 0;\r\nbail1:\r\nvq_repbuf_free(c2dev, reply);\r\nbail0:\r\nvq_req_free(c2dev, vq_req);\r\nreturn err;\r\n}\r\nint c2_llp_service_destroy(struct iw_cm_id *cm_id)\r\n{\r\nstruct c2_dev *c2dev;\r\nstruct c2wr_ep_listen_destroy_req wr;\r\nstruct c2wr_ep_listen_destroy_rep *reply;\r\nstruct c2_vq_req *vq_req;\r\nint err;\r\nc2dev = to_c2dev(cm_id->device);\r\nif (c2dev == NULL)\r\nreturn -EINVAL;\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req)\r\nreturn -ENOMEM;\r\nc2_wr_set_id(&wr, CCWR_EP_LISTEN_DESTROY);\r\nwr.hdr.context = (unsigned long) vq_req;\r\nwr.rnic_handle = c2dev->adapter_handle;\r\nwr.ep_handle = (u32)(unsigned long)cm_id->provider_data;\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) & wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail0;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err)\r\ngoto bail0;\r\nreply=(struct c2wr_ep_listen_destroy_rep *)(unsigned long)vq_req->reply_msg;\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nif ((err = c2_errno(reply)) != 0)\r\ngoto bail1;\r\nbail1:\r\nvq_repbuf_free(c2dev, reply);\r\nbail0:\r\nvq_req_free(c2dev, vq_req);\r\nreturn err;\r\n}\r\nint c2_llp_accept(struct iw_cm_id *cm_id, struct iw_cm_conn_param *iw_param)\r\n{\r\nstruct c2_dev *c2dev = to_c2dev(cm_id->device);\r\nstruct c2_qp *qp;\r\nstruct ib_qp *ibqp;\r\nstruct c2wr_cr_accept_req *wr;\r\nstruct c2_vq_req *vq_req;\r\nstruct c2wr_cr_accept_rep *reply;\r\nint err;\r\nibqp = c2_get_qp(cm_id->device, iw_param->qpn);\r\nif (!ibqp)\r\nreturn -EINVAL;\r\nqp = to_c2qp(ibqp);\r\nerr = c2_qp_set_read_limits(c2dev, qp, iw_param->ord, iw_param->ird);\r\nif (err)\r\ngoto bail0;\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nvq_req->qp = qp;\r\nvq_req->cm_id = cm_id;\r\nvq_req->event = IW_CM_EVENT_ESTABLISHED;\r\nwr = kmalloc(c2dev->req_vq.msg_size, GFP_KERNEL);\r\nif (!wr) {\r\nerr = -ENOMEM;\r\ngoto bail1;\r\n}\r\nc2_wr_set_id(wr, CCWR_CR_ACCEPT);\r\nwr->hdr.context = (unsigned long) vq_req;\r\nwr->rnic_handle = c2dev->adapter_handle;\r\nwr->ep_handle = (u32) (unsigned long) cm_id->provider_data;\r\nwr->qp_handle = qp->adapter_handle;\r\ncm_id->provider_data = qp;\r\ncm_id->add_ref(cm_id);\r\nqp->cm_id = cm_id;\r\ncm_id->provider_data = qp;\r\nif (iw_param->private_data_len > C2_MAX_PRIVATE_DATA_SIZE) {\r\nerr = -EINVAL;\r\ngoto bail1;\r\n}\r\nif (iw_param->private_data) {\r\nwr->private_data_length = cpu_to_be32(iw_param->private_data_len);\r\nmemcpy(&wr->private_data[0],\r\niw_param->private_data, iw_param->private_data_len);\r\n} else\r\nwr->private_data_length = 0;\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail1;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err)\r\ngoto bail1;\r\nreply = (struct c2wr_cr_accept_rep *) (unsigned long) vq_req->reply_msg;\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail1;\r\n}\r\nerr = c2_errno(reply);\r\nvq_repbuf_free(c2dev, reply);\r\nif (!err)\r\nc2_set_qp_state(qp, C2_QP_STATE_RTS);\r\nbail1:\r\nkfree(wr);\r\nvq_req_free(c2dev, vq_req);\r\nbail0:\r\nif (err) {\r\ncm_id->provider_data = NULL;\r\nqp->cm_id = NULL;\r\ncm_id->rem_ref(cm_id);\r\n}\r\nreturn err;\r\n}\r\nint c2_llp_reject(struct iw_cm_id *cm_id, const void *pdata, u8 pdata_len)\r\n{\r\nstruct c2_dev *c2dev;\r\nstruct c2wr_cr_reject_req wr;\r\nstruct c2_vq_req *vq_req;\r\nstruct c2wr_cr_reject_rep *reply;\r\nint err;\r\nc2dev = to_c2dev(cm_id->device);\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req)\r\nreturn -ENOMEM;\r\nc2_wr_set_id(&wr, CCWR_CR_REJECT);\r\nwr.hdr.context = (unsigned long) vq_req;\r\nwr.rnic_handle = c2dev->adapter_handle;\r\nwr.ep_handle = (u32) (unsigned long) cm_id->provider_data;\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) & wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail0;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err)\r\ngoto bail0;\r\nreply = (struct c2wr_cr_reject_rep *) (unsigned long)\r\nvq_req->reply_msg;\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nerr = c2_errno(reply);\r\nvq_repbuf_free(c2dev, reply);\r\nbail0:\r\nvq_req_free(c2dev, vq_req);\r\nreturn err;\r\n}
