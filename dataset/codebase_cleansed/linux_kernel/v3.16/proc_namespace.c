static unsigned mounts_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct proc_mounts *p = proc_mounts(file->private_data);\r\nstruct mnt_namespace *ns = p->ns;\r\nunsigned res = POLLIN | POLLRDNORM;\r\nint event;\r\npoll_wait(file, &p->ns->poll, wait);\r\nevent = ACCESS_ONCE(ns->event);\r\nif (p->m.poll_event != event) {\r\np->m.poll_event = event;\r\nres |= POLLERR | POLLPRI;\r\n}\r\nreturn res;\r\n}\r\nstatic int show_sb_opts(struct seq_file *m, struct super_block *sb)\r\n{\r\nstatic const struct proc_fs_info fs_info[] = {\r\n{ MS_SYNCHRONOUS, ",sync" },\r\n{ MS_DIRSYNC, ",dirsync" },\r\n{ MS_MANDLOCK, ",mand" },\r\n{ 0, NULL }\r\n};\r\nconst struct proc_fs_info *fs_infop;\r\nfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\r\nif (sb->s_flags & fs_infop->flag)\r\nseq_puts(m, fs_infop->str);\r\n}\r\nreturn security_sb_show_options(m, sb);\r\n}\r\nstatic void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\r\n{\r\nstatic const struct proc_fs_info mnt_info[] = {\r\n{ MNT_NOSUID, ",nosuid" },\r\n{ MNT_NODEV, ",nodev" },\r\n{ MNT_NOEXEC, ",noexec" },\r\n{ MNT_NOATIME, ",noatime" },\r\n{ MNT_NODIRATIME, ",nodiratime" },\r\n{ MNT_RELATIME, ",relatime" },\r\n{ 0, NULL }\r\n};\r\nconst struct proc_fs_info *fs_infop;\r\nfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\r\nif (mnt->mnt_flags & fs_infop->flag)\r\nseq_puts(m, fs_infop->str);\r\n}\r\n}\r\nstatic inline void mangle(struct seq_file *m, const char *s)\r\n{\r\nseq_escape(m, s, " \t\n\\");\r\n}\r\nstatic void show_type(struct seq_file *m, struct super_block *sb)\r\n{\r\nmangle(m, sb->s_type->name);\r\nif (sb->s_subtype && sb->s_subtype[0]) {\r\nseq_putc(m, '.');\r\nmangle(m, sb->s_subtype);\r\n}\r\n}\r\nstatic int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)\r\n{\r\nstruct mount *r = real_mount(mnt);\r\nint err = 0;\r\nstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\r\nstruct super_block *sb = mnt_path.dentry->d_sb;\r\nif (sb->s_op->show_devname) {\r\nerr = sb->s_op->show_devname(m, mnt_path.dentry);\r\nif (err)\r\ngoto out;\r\n} else {\r\nmangle(m, r->mnt_devname ? r->mnt_devname : "none");\r\n}\r\nseq_putc(m, ' ');\r\nseq_path(m, &mnt_path, " \t\n\\");\r\nseq_putc(m, ' ');\r\nshow_type(m, sb);\r\nseq_puts(m, __mnt_is_readonly(mnt) ? " ro" : " rw");\r\nerr = show_sb_opts(m, sb);\r\nif (err)\r\ngoto out;\r\nshow_mnt_opts(m, mnt);\r\nif (sb->s_op->show_options)\r\nerr = sb->s_op->show_options(m, mnt_path.dentry);\r\nseq_puts(m, " 0 0\n");\r\nout:\r\nreturn err;\r\n}\r\nstatic int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)\r\n{\r\nstruct proc_mounts *p = proc_mounts(m);\r\nstruct mount *r = real_mount(mnt);\r\nstruct super_block *sb = mnt->mnt_sb;\r\nstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\r\nstruct path root = p->root;\r\nint err = 0;\r\nseq_printf(m, "%i %i %u:%u ", r->mnt_id, r->mnt_parent->mnt_id,\r\nMAJOR(sb->s_dev), MINOR(sb->s_dev));\r\nif (sb->s_op->show_path)\r\nerr = sb->s_op->show_path(m, mnt->mnt_root);\r\nelse\r\nseq_dentry(m, mnt->mnt_root, " \t\n\\");\r\nif (err)\r\ngoto out;\r\nseq_putc(m, ' ');\r\nerr = seq_path_root(m, &mnt_path, &root, " \t\n\\");\r\nif (err)\r\ngoto out;\r\nseq_puts(m, mnt->mnt_flags & MNT_READONLY ? " ro" : " rw");\r\nshow_mnt_opts(m, mnt);\r\nif (IS_MNT_SHARED(r))\r\nseq_printf(m, " shared:%i", r->mnt_group_id);\r\nif (IS_MNT_SLAVE(r)) {\r\nint master = r->mnt_master->mnt_group_id;\r\nint dom = get_dominating_id(r, &p->root);\r\nseq_printf(m, " master:%i", master);\r\nif (dom && dom != master)\r\nseq_printf(m, " propagate_from:%i", dom);\r\n}\r\nif (IS_MNT_UNBINDABLE(r))\r\nseq_puts(m, " unbindable");\r\nseq_puts(m, " - ");\r\nshow_type(m, sb);\r\nseq_putc(m, ' ');\r\nif (sb->s_op->show_devname)\r\nerr = sb->s_op->show_devname(m, mnt->mnt_root);\r\nelse\r\nmangle(m, r->mnt_devname ? r->mnt_devname : "none");\r\nif (err)\r\ngoto out;\r\nseq_puts(m, sb->s_flags & MS_RDONLY ? " ro" : " rw");\r\nerr = show_sb_opts(m, sb);\r\nif (err)\r\ngoto out;\r\nif (sb->s_op->show_options)\r\nerr = sb->s_op->show_options(m, mnt->mnt_root);\r\nseq_putc(m, '\n');\r\nout:\r\nreturn err;\r\n}\r\nstatic int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)\r\n{\r\nstruct mount *r = real_mount(mnt);\r\nstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\r\nstruct super_block *sb = mnt_path.dentry->d_sb;\r\nint err = 0;\r\nif (sb->s_op->show_devname) {\r\nseq_puts(m, "device ");\r\nerr = sb->s_op->show_devname(m, mnt_path.dentry);\r\n} else {\r\nif (r->mnt_devname) {\r\nseq_puts(m, "device ");\r\nmangle(m, r->mnt_devname);\r\n} else\r\nseq_puts(m, "no device");\r\n}\r\nseq_puts(m, " mounted on ");\r\nseq_path(m, &mnt_path, " \t\n\\");\r\nseq_putc(m, ' ');\r\nseq_puts(m, "with fstype ");\r\nshow_type(m, sb);\r\nif (sb->s_op->show_stats) {\r\nseq_putc(m, ' ');\r\nif (!err)\r\nerr = sb->s_op->show_stats(m, mnt_path.dentry);\r\n}\r\nseq_putc(m, '\n');\r\nreturn err;\r\n}\r\nstatic int mounts_open_common(struct inode *inode, struct file *file,\r\nint (*show)(struct seq_file *, struct vfsmount *))\r\n{\r\nstruct task_struct *task = get_proc_task(inode);\r\nstruct nsproxy *nsp;\r\nstruct mnt_namespace *ns = NULL;\r\nstruct path root;\r\nstruct proc_mounts *p;\r\nint ret = -EINVAL;\r\nif (!task)\r\ngoto err;\r\nrcu_read_lock();\r\nnsp = task_nsproxy(task);\r\nif (!nsp || !nsp->mnt_ns) {\r\nrcu_read_unlock();\r\nput_task_struct(task);\r\ngoto err;\r\n}\r\nns = nsp->mnt_ns;\r\nget_mnt_ns(ns);\r\nrcu_read_unlock();\r\ntask_lock(task);\r\nif (!task->fs) {\r\ntask_unlock(task);\r\nput_task_struct(task);\r\nret = -ENOENT;\r\ngoto err_put_ns;\r\n}\r\nget_fs_root(task->fs, &root);\r\ntask_unlock(task);\r\nput_task_struct(task);\r\nret = -ENOMEM;\r\np = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\r\nif (!p)\r\ngoto err_put_path;\r\nfile->private_data = &p->m;\r\nret = seq_open(file, &mounts_op);\r\nif (ret)\r\ngoto err_free;\r\np->ns = ns;\r\np->root = root;\r\np->m.poll_event = ns->event;\r\np->show = show;\r\np->cached_event = ~0ULL;\r\nreturn 0;\r\nerr_free:\r\nkfree(p);\r\nerr_put_path:\r\npath_put(&root);\r\nerr_put_ns:\r\nput_mnt_ns(ns);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int mounts_release(struct inode *inode, struct file *file)\r\n{\r\nstruct proc_mounts *p = proc_mounts(file->private_data);\r\npath_put(&p->root);\r\nput_mnt_ns(p->ns);\r\nreturn seq_release(inode, file);\r\n}\r\nstatic int mounts_open(struct inode *inode, struct file *file)\r\n{\r\nreturn mounts_open_common(inode, file, show_vfsmnt);\r\n}\r\nstatic int mountinfo_open(struct inode *inode, struct file *file)\r\n{\r\nreturn mounts_open_common(inode, file, show_mountinfo);\r\n}\r\nstatic int mountstats_open(struct inode *inode, struct file *file)\r\n{\r\nreturn mounts_open_common(inode, file, show_vfsstat);\r\n}
