static void nft_payload_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nconst struct sk_buff *skb = pkt->skb;\r\nstruct nft_data *dest = &data[priv->dreg];\r\nint offset;\r\nswitch (priv->base) {\r\ncase NFT_PAYLOAD_LL_HEADER:\r\nif (!skb_mac_header_was_set(skb))\r\ngoto err;\r\noffset = skb_mac_header(skb) - skb->data;\r\nbreak;\r\ncase NFT_PAYLOAD_NETWORK_HEADER:\r\noffset = skb_network_offset(skb);\r\nbreak;\r\ncase NFT_PAYLOAD_TRANSPORT_HEADER:\r\noffset = pkt->xt.thoff;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\noffset += priv->offset;\r\nif (skb_copy_bits(skb, offset, dest->data, priv->len) < 0)\r\ngoto err;\r\nreturn;\r\nerr:\r\ndata[NFT_REG_VERDICT].verdict = NFT_BREAK;\r\n}\r\nstatic int nft_payload_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_payload *priv = nft_expr_priv(expr);\r\nint err;\r\npriv->base = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));\r\npriv->offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));\r\npriv->len = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));\r\npriv->dreg = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_DREG]));\r\nerr = nft_validate_output_register(priv->dreg);\r\nif (err < 0)\r\nreturn err;\r\nreturn nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);\r\n}\r\nstatic int nft_payload_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nif (nla_put_be32(skb, NFTA_PAYLOAD_DREG, htonl(priv->dreg)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_BASE, htonl(priv->base)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_OFFSET, htonl(priv->offset)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_LEN, htonl(priv->len)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_payload_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nenum nft_payload_bases base;\r\nunsigned int offset, len;\r\nif (tb[NFTA_PAYLOAD_DREG] == NULL ||\r\ntb[NFTA_PAYLOAD_BASE] == NULL ||\r\ntb[NFTA_PAYLOAD_OFFSET] == NULL ||\r\ntb[NFTA_PAYLOAD_LEN] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nbase = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));\r\nswitch (base) {\r\ncase NFT_PAYLOAD_LL_HEADER:\r\ncase NFT_PAYLOAD_NETWORK_HEADER:\r\ncase NFT_PAYLOAD_TRANSPORT_HEADER:\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\noffset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));\r\nlen = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));\r\nif (len == 0 || len > FIELD_SIZEOF(struct nft_data, data))\r\nreturn ERR_PTR(-EINVAL);\r\nif (len <= 4 && is_power_of_2(len) && IS_ALIGNED(offset, len) &&\r\nbase != NFT_PAYLOAD_LL_HEADER)\r\nreturn &nft_payload_fast_ops;\r\nelse\r\nreturn &nft_payload_ops;\r\n}\r\nint __init nft_payload_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_payload_type);\r\n}\r\nvoid nft_payload_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_payload_type);\r\n}
