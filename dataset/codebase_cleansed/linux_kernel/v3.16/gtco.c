static void parse_hid_report_descriptor(struct gtco *device, char * report,\r\nint length)\r\n{\r\nstruct device *ddev = &device->intf->dev;\r\nint x, i = 0;\r\n__u8 prefix;\r\n__u8 size;\r\n__u8 tag;\r\n__u8 type;\r\n__u8 data = 0;\r\n__u16 data16 = 0;\r\n__u32 data32 = 0;\r\nint inputnum = 0;\r\n__u32 usage = 0;\r\n__u32 globalval[TAG_GLOB_MAX];\r\n__u32 oldval[TAG_GLOB_MAX];\r\nchar maintype = 'x';\r\nchar globtype[12];\r\nint indent = 0;\r\nchar indentstr[10] = "";\r\ndev_dbg(ddev, "======>>>>>>PARSE<<<<<<======\n");\r\nwhile (i < length) {\r\nprefix = report[i];\r\ni++;\r\nsize = PREF_SIZE(prefix);\r\nswitch (size) {\r\ncase 1:\r\ndata = report[i];\r\nbreak;\r\ncase 2:\r\ndata16 = get_unaligned_le16(&report[i]);\r\nbreak;\r\ncase 3:\r\nsize = 4;\r\ndata32 = get_unaligned_le32(&report[i]);\r\nbreak;\r\n}\r\ni += size;\r\ntag = PREF_TAG(prefix);\r\ntype = PREF_TYPE(prefix);\r\nswitch (type) {\r\ncase TYPE_MAIN:\r\nstrcpy(globtype, "");\r\nswitch (tag) {\r\ncase TAG_MAIN_INPUT:\r\nmaintype = 'I';\r\nif (data == 2)\r\nstrcpy(globtype, "Variable");\r\nelse if (data == 3)\r\nstrcpy(globtype, "Var|Const");\r\ndev_dbg(ddev, "::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\n",\r\nglobalval[TAG_GLOB_REPORT_ID], inputnum,\r\nglobalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX],\r\nglobalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN],\r\nglobalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);\r\nswitch (inputnum) {\r\ncase 0:\r\ndev_dbg(ddev, "GER: X Usage: 0x%x\n", usage);\r\nif (device->max_X == 0) {\r\ndevice->max_X = globalval[TAG_GLOB_LOG_MAX];\r\ndevice->min_X = globalval[TAG_GLOB_LOG_MIN];\r\n}\r\nbreak;\r\ncase 1:\r\ndev_dbg(ddev, "GER: Y Usage: 0x%x\n", usage);\r\nif (device->max_Y == 0) {\r\ndevice->max_Y = globalval[TAG_GLOB_LOG_MAX];\r\ndevice->min_Y = globalval[TAG_GLOB_LOG_MIN];\r\n}\r\nbreak;\r\ndefault:\r\nif (usage == DIGITIZER_USAGE_TILT_X) {\r\nif (device->maxtilt_X == 0) {\r\ndevice->maxtilt_X = globalval[TAG_GLOB_LOG_MAX];\r\ndevice->mintilt_X = globalval[TAG_GLOB_LOG_MIN];\r\n}\r\n}\r\nif (usage == DIGITIZER_USAGE_TILT_Y) {\r\nif (device->maxtilt_Y == 0) {\r\ndevice->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX];\r\ndevice->mintilt_Y = globalval[TAG_GLOB_LOG_MIN];\r\n}\r\n}\r\nif (usage == DIGITIZER_USAGE_TIP_PRESSURE) {\r\nif (device->maxpressure == 0) {\r\ndevice->maxpressure = globalval[TAG_GLOB_LOG_MAX];\r\ndevice->minpressure = globalval[TAG_GLOB_LOG_MIN];\r\n}\r\n}\r\nbreak;\r\n}\r\ninputnum++;\r\nbreak;\r\ncase TAG_MAIN_OUTPUT:\r\nmaintype = 'O';\r\nbreak;\r\ncase TAG_MAIN_FEATURE:\r\nmaintype = 'F';\r\nbreak;\r\ncase TAG_MAIN_COL_START:\r\nmaintype = 'S';\r\nif (data == 0) {\r\ndev_dbg(ddev, "======>>>>>> Physical\n");\r\nstrcpy(globtype, "Physical");\r\n} else\r\ndev_dbg(ddev, "======>>>>>>\n");\r\nindent++;\r\nfor (x = 0; x < indent; x++)\r\nindentstr[x] = '-';\r\nindentstr[x] = 0;\r\nfor (x = 0; x < TAG_GLOB_MAX; x++)\r\noldval[x] = globalval[x];\r\nbreak;\r\ncase TAG_MAIN_COL_END:\r\ndev_dbg(ddev, "<<<<<<======\n");\r\nmaintype = 'E';\r\nindent--;\r\nfor (x = 0; x < indent; x++)\r\nindentstr[x] = '-';\r\nindentstr[x] = 0;\r\nfor (x = 0; x < TAG_GLOB_MAX; x++)\r\nglobalval[x] = oldval[x];\r\nbreak;\r\n}\r\nswitch (size) {\r\ncase 1:\r\ndev_dbg(ddev, "%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n",\r\nindentstr, tag, maintype, size, globtype, data);\r\nbreak;\r\ncase 2:\r\ndev_dbg(ddev, "%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n",\r\nindentstr, tag, maintype, size, globtype, data16);\r\nbreak;\r\ncase 4:\r\ndev_dbg(ddev, "%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n",\r\nindentstr, tag, maintype, size, globtype, data32);\r\nbreak;\r\n}\r\nbreak;\r\ncase TYPE_GLOBAL:\r\nswitch (tag) {\r\ncase TAG_GLOB_USAGE:\r\nif (device->usage == 0)\r\ndevice->usage = data;\r\nstrcpy(globtype, "USAGE");\r\nbreak;\r\ncase TAG_GLOB_LOG_MIN:\r\nstrcpy(globtype, "LOG_MIN");\r\nbreak;\r\ncase TAG_GLOB_LOG_MAX:\r\nstrcpy(globtype, "LOG_MAX");\r\nbreak;\r\ncase TAG_GLOB_PHYS_MIN:\r\nstrcpy(globtype, "PHYS_MIN");\r\nbreak;\r\ncase TAG_GLOB_PHYS_MAX:\r\nstrcpy(globtype, "PHYS_MAX");\r\nbreak;\r\ncase TAG_GLOB_UNIT_EXP:\r\nstrcpy(globtype, "EXP");\r\nbreak;\r\ncase TAG_GLOB_UNIT:\r\nstrcpy(globtype, "UNIT");\r\nbreak;\r\ncase TAG_GLOB_REPORT_SZ:\r\nstrcpy(globtype, "REPORT_SZ");\r\nbreak;\r\ncase TAG_GLOB_REPORT_ID:\r\nstrcpy(globtype, "REPORT_ID");\r\ninputnum = 0;\r\nbreak;\r\ncase TAG_GLOB_REPORT_CNT:\r\nstrcpy(globtype, "REPORT_CNT");\r\nbreak;\r\ncase TAG_GLOB_PUSH:\r\nstrcpy(globtype, "PUSH");\r\nbreak;\r\ncase TAG_GLOB_POP:\r\nstrcpy(globtype, "POP");\r\nbreak;\r\n}\r\nif (tag < TAG_GLOB_MAX) {\r\nswitch (size) {\r\ncase 1:\r\ndev_dbg(ddev, "%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n",\r\nindentstr, globtype, tag, size, data);\r\nglobalval[tag] = data;\r\nbreak;\r\ncase 2:\r\ndev_dbg(ddev, "%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n",\r\nindentstr, globtype, tag, size, data16);\r\nglobalval[tag] = data16;\r\nbreak;\r\ncase 4:\r\ndev_dbg(ddev, "%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n",\r\nindentstr, globtype, tag, size, data32);\r\nglobalval[tag] = data32;\r\nbreak;\r\n}\r\n} else {\r\ndev_dbg(ddev, "%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\n",\r\nindentstr, tag, size);\r\n}\r\nbreak;\r\ncase TYPE_LOCAL:\r\nswitch (tag) {\r\ncase TAG_GLOB_USAGE:\r\nstrcpy(globtype, "USAGE");\r\nusage = data;\r\nbreak;\r\ncase TAG_GLOB_LOG_MIN:\r\nstrcpy(globtype, "MIN");\r\nbreak;\r\ncase TAG_GLOB_LOG_MAX:\r\nstrcpy(globtype, "MAX");\r\nbreak;\r\ndefault:\r\nstrcpy(globtype, "UNKNOWN");\r\nbreak;\r\n}\r\nswitch (size) {\r\ncase 1:\r\ndev_dbg(ddev, "%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n",\r\nindentstr, tag, globtype, size, data);\r\nbreak;\r\ncase 2:\r\ndev_dbg(ddev, "%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n",\r\nindentstr, tag, globtype, size, data16);\r\nbreak;\r\ncase 4:\r\ndev_dbg(ddev, "%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n",\r\nindentstr, tag, globtype, size, data32);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int gtco_input_open(struct input_dev *inputdev)\r\n{\r\nstruct gtco *device = input_get_drvdata(inputdev);\r\ndevice->urbinfo->dev = device->usbdev;\r\nif (usb_submit_urb(device->urbinfo, GFP_KERNEL))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void gtco_input_close(struct input_dev *inputdev)\r\n{\r\nstruct gtco *device = input_get_drvdata(inputdev);\r\nusb_kill_urb(device->urbinfo);\r\n}\r\nstatic void gtco_setup_caps(struct input_dev *inputdev)\r\n{\r\nstruct gtco *device = input_get_drvdata(inputdev);\r\ninputdev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) |\r\nBIT_MASK(EV_MSC);\r\ninputdev->mscbit[0] = BIT_MASK(MSC_SCAN) | BIT_MASK(MSC_SERIAL) |\r\nBIT_MASK(MSC_RAW);\r\ninput_set_abs_params(inputdev, ABS_X, device->min_X, device->max_X,\r\n0, 0);\r\ninput_set_abs_params(inputdev, ABS_Y, device->min_Y, device->max_Y,\r\n0, 0);\r\ninput_set_abs_params(inputdev, ABS_DISTANCE, 0, 1, 0, 0);\r\ninput_set_abs_params(inputdev, ABS_TILT_X, device->mintilt_X,\r\ndevice->maxtilt_X, 0, 0);\r\ninput_set_abs_params(inputdev, ABS_TILT_Y, device->mintilt_Y,\r\ndevice->maxtilt_Y, 0, 0);\r\ninput_set_abs_params(inputdev, ABS_PRESSURE, device->minpressure,\r\ndevice->maxpressure, 0, 0);\r\ninput_set_abs_params(inputdev, ABS_MISC, 0, 0xFF, 0, 0);\r\n}\r\nstatic void gtco_urb_callback(struct urb *urbinfo)\r\n{\r\nstruct gtco *device = urbinfo->context;\r\nstruct input_dev *inputdev;\r\nint rc;\r\nu32 val = 0;\r\ns8 valsigned = 0;\r\nchar le_buffer[2];\r\ninputdev = device->inputdevice;\r\nif (urbinfo->status == -ECONNRESET ||\r\nurbinfo->status == -ENOENT ||\r\nurbinfo->status == -ESHUTDOWN) {\r\nreturn;\r\n}\r\nif (urbinfo->status != 0) {\r\ngoto resubmit;\r\n}\r\nif (inputdev->id.product == PID_1000 ||\r\ninputdev->id.product == PID_1001 ||\r\ninputdev->id.product == PID_1002) {\r\nswitch (device->buffer[0]) {\r\ncase 5:\r\nval = ((u16)(device->buffer[8]) << 1);\r\nval |= (u16)(device->buffer[7] >> 7);\r\ninput_report_abs(inputdev, ABS_PRESSURE,\r\ndevice->buffer[8]);\r\ndevice->buffer[7] = (u8)((device->buffer[7]) & 0x7F);\r\ncase 4:\r\nif (device->buffer[6] & 0x40)\r\ndevice->buffer[6] |= 0x80;\r\nif (device->buffer[7] & 0x40)\r\ndevice->buffer[7] |= 0x80;\r\nvalsigned = (device->buffer[6]);\r\ninput_report_abs(inputdev, ABS_TILT_X, (s32)valsigned);\r\nvalsigned = (device->buffer[7]);\r\ninput_report_abs(inputdev, ABS_TILT_Y, (s32)valsigned);\r\ncase 2:\r\ncase 3:\r\nval = (device->buffer[5]) & MASK_BUTTON;\r\ninput_event(inputdev, EV_MSC, MSC_SERIAL, val);\r\ncase 1:\r\nval = get_unaligned_le16(&device->buffer[1]);\r\ninput_report_abs(inputdev, ABS_X, val);\r\nval = get_unaligned_le16(&device->buffer[3]);\r\ninput_report_abs(inputdev, ABS_Y, val);\r\nval = device->buffer[5] & MASK_INRANGE ? 1 : 0;\r\ninput_report_abs(inputdev, ABS_DISTANCE, val);\r\nif (device->buffer[0] == 1) {\r\nval = device->buffer[5] & MASK_BUTTON;\r\ndev_dbg(&device->intf->dev,\r\n"======>>>>>>REPORT 1: val 0x%X(%d)\n",\r\nval, val);\r\ninput_event(inputdev, EV_MSC, MSC_SERIAL, val);\r\n}\r\nbreak;\r\ncase 7:\r\ninput_event(inputdev, EV_MSC, MSC_SCAN,\r\ndevice->buffer[1]);\r\nbreak;\r\n}\r\n}\r\nif (inputdev->id.product == PID_400 ||\r\ninputdev->id.product == PID_401) {\r\nif (device->buffer[0] == 2) {\r\ninput_event(inputdev, EV_MSC, MSC_SCAN, device->buffer[1]);\r\n}\r\nif (device->buffer[0] == 1) {\r\nchar buttonbyte;\r\nif (device->max_X > 0x10000) {\r\nval = (u16)(((u16)(device->buffer[2] << 8)) | (u8)device->buffer[1]);\r\nval |= (u32)(((u8)device->buffer[3] & 0x1) << 16);\r\ninput_report_abs(inputdev, ABS_X, val);\r\nle_buffer[0] = (u8)((u8)(device->buffer[3]) >> 1);\r\nle_buffer[0] |= (u8)((device->buffer[3] & 0x1) << 7);\r\nle_buffer[1] = (u8)(device->buffer[4] >> 1);\r\nle_buffer[1] |= (u8)((device->buffer[5] & 0x1) << 7);\r\nval = get_unaligned_le16(le_buffer);\r\ninput_report_abs(inputdev, ABS_Y, val);\r\nbuttonbyte = device->buffer[5] >> 1;\r\n} else {\r\nval = get_unaligned_le16(&device->buffer[1]);\r\ninput_report_abs(inputdev, ABS_X, val);\r\nval = get_unaligned_le16(&device->buffer[3]);\r\ninput_report_abs(inputdev, ABS_Y, val);\r\nbuttonbyte = device->buffer[5];\r\n}\r\nval = buttonbyte & MASK_INRANGE ? 1 : 0;\r\ninput_report_abs(inputdev, ABS_DISTANCE, val);\r\nval = buttonbyte & 0x0F;\r\n#ifdef USE_BUTTONS\r\nfor (i = 0; i < 5; i++)\r\ninput_report_key(inputdev, BTN_DIGI + i, val & (1 << i));\r\n#else\r\ninput_event(inputdev, EV_MSC, MSC_SERIAL, val);\r\n#endif\r\ninput_report_abs(inputdev, ABS_MISC, device->buffer[6]);\r\n}\r\n}\r\ninput_event(inputdev, EV_MSC, MSC_RAW, device->buffer[0]);\r\ninput_sync(inputdev);\r\nresubmit:\r\nrc = usb_submit_urb(urbinfo, GFP_ATOMIC);\r\nif (rc != 0)\r\ndev_err(&device->intf->dev,\r\n"usb_submit_urb failed rc=0x%x\n", rc);\r\n}\r\nstatic int gtco_probe(struct usb_interface *usbinterface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct gtco *gtco;\r\nstruct input_dev *input_dev;\r\nstruct hid_descriptor *hid_desc;\r\nchar *report;\r\nint result = 0, retry;\r\nint error;\r\nstruct usb_endpoint_descriptor *endpoint;\r\ngtco = kzalloc(sizeof(struct gtco), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!gtco || !input_dev) {\r\ndev_err(&usbinterface->dev, "No more memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_devs;\r\n}\r\ngtco->inputdevice = input_dev;\r\ngtco->usbdev = interface_to_usbdev(usbinterface);\r\ngtco->intf = usbinterface;\r\ngtco->buffer = usb_alloc_coherent(gtco->usbdev, REPORT_MAX_SIZE,\r\nGFP_KERNEL, &gtco->buf_dma);\r\nif (!gtco->buffer) {\r\ndev_err(&usbinterface->dev, "No more memory for us buffers\n");\r\nerror = -ENOMEM;\r\ngoto err_free_devs;\r\n}\r\ngtco->urbinfo = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!gtco->urbinfo) {\r\ndev_err(&usbinterface->dev, "Failed to allocate URB\n");\r\nerror = -ENOMEM;\r\ngoto err_free_buf;\r\n}\r\nendpoint = &usbinterface->altsetting[0].endpoint[0].desc;\r\ndev_dbg(&usbinterface->dev, "gtco # interfaces: %d\n", usbinterface->num_altsetting);\r\ndev_dbg(&usbinterface->dev, "num endpoints: %d\n", usbinterface->cur_altsetting->desc.bNumEndpoints);\r\ndev_dbg(&usbinterface->dev, "interface class: %d\n", usbinterface->cur_altsetting->desc.bInterfaceClass);\r\ndev_dbg(&usbinterface->dev, "endpoint: attribute:0x%x type:0x%x\n", endpoint->bmAttributes, endpoint->bDescriptorType);\r\nif (usb_endpoint_xfer_int(endpoint))\r\ndev_dbg(&usbinterface->dev, "endpoint: we have interrupt endpoint\n");\r\ndev_dbg(&usbinterface->dev, "endpoint extra len:%d\n", usbinterface->altsetting[0].extralen);\r\nif (usb_get_extra_descriptor(usbinterface->cur_altsetting,\r\nHID_DEVICE_TYPE, &hid_desc) != 0){\r\ndev_err(&usbinterface->dev,\r\n"Can't retrieve exta USB descriptor to get hid report descriptor length\n");\r\nerror = -EIO;\r\ngoto err_free_urb;\r\n}\r\ndev_dbg(&usbinterface->dev,\r\n"Extra descriptor success: type:%d len:%d\n",\r\nhid_desc->bDescriptorType, hid_desc->wDescriptorLength);\r\nreport = kzalloc(le16_to_cpu(hid_desc->wDescriptorLength), GFP_KERNEL);\r\nif (!report) {\r\ndev_err(&usbinterface->dev, "No more memory for report\n");\r\nerror = -ENOMEM;\r\ngoto err_free_urb;\r\n}\r\nfor (retry = 0; retry < 3; retry++) {\r\nresult = usb_control_msg(gtco->usbdev,\r\nusb_rcvctrlpipe(gtco->usbdev, 0),\r\nUSB_REQ_GET_DESCRIPTOR,\r\nUSB_RECIP_INTERFACE | USB_DIR_IN,\r\nREPORT_DEVICE_TYPE << 8,\r\n0,\r\nreport,\r\nle16_to_cpu(hid_desc->wDescriptorLength),\r\n5000);\r\ndev_dbg(&usbinterface->dev, "usb_control_msg result: %d\n", result);\r\nif (result == le16_to_cpu(hid_desc->wDescriptorLength)) {\r\nparse_hid_report_descriptor(gtco, report, result);\r\nbreak;\r\n}\r\n}\r\nkfree(report);\r\nif (result != le16_to_cpu(hid_desc->wDescriptorLength)) {\r\ndev_err(&usbinterface->dev,\r\n"Failed to get HID Report Descriptor of size: %d\n",\r\nhid_desc->wDescriptorLength);\r\nerror = -EIO;\r\ngoto err_free_urb;\r\n}\r\nusb_make_path(gtco->usbdev, gtco->usbpath, sizeof(gtco->usbpath));\r\nstrlcat(gtco->usbpath, "/input0", sizeof(gtco->usbpath));\r\ninput_dev->open = gtco_input_open;\r\ninput_dev->close = gtco_input_close;\r\ninput_dev->name = "GTCO_CalComp";\r\ninput_dev->phys = gtco->usbpath;\r\ninput_set_drvdata(input_dev, gtco);\r\ngtco_setup_caps(input_dev);\r\nusb_to_input_id(gtco->usbdev, &input_dev->id);\r\ninput_dev->dev.parent = &usbinterface->dev;\r\nendpoint = &usbinterface->altsetting[0].endpoint[0].desc;\r\nusb_fill_int_urb(gtco->urbinfo,\r\ngtco->usbdev,\r\nusb_rcvintpipe(gtco->usbdev,\r\nendpoint->bEndpointAddress),\r\ngtco->buffer,\r\nREPORT_MAX_SIZE,\r\ngtco_urb_callback,\r\ngtco,\r\nendpoint->bInterval);\r\ngtco->urbinfo->transfer_dma = gtco->buf_dma;\r\ngtco->urbinfo->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_set_intfdata(usbinterface, gtco);\r\nerror = input_register_device(input_dev);\r\nif (error)\r\ngoto err_free_urb;\r\nreturn 0;\r\nerr_free_urb:\r\nusb_free_urb(gtco->urbinfo);\r\nerr_free_buf:\r\nusb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE,\r\ngtco->buffer, gtco->buf_dma);\r\nerr_free_devs:\r\ninput_free_device(input_dev);\r\nkfree(gtco);\r\nreturn error;\r\n}\r\nstatic void gtco_disconnect(struct usb_interface *interface)\r\n{\r\nstruct gtco *gtco = usb_get_intfdata(interface);\r\nif (gtco) {\r\ninput_unregister_device(gtco->inputdevice);\r\nusb_kill_urb(gtco->urbinfo);\r\nusb_free_urb(gtco->urbinfo);\r\nusb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE,\r\ngtco->buffer, gtco->buf_dma);\r\nkfree(gtco);\r\n}\r\ndev_info(&interface->dev, "gtco driver disconnected\n");\r\n}
