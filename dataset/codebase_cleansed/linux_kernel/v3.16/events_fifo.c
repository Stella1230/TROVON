static inline event_word_t *event_word_from_port(unsigned port)\r\n{\r\nunsigned i = port / EVENT_WORDS_PER_PAGE;\r\nreturn event_array[i] + port % EVENT_WORDS_PER_PAGE;\r\n}\r\nstatic unsigned evtchn_fifo_max_channels(void)\r\n{\r\nreturn EVTCHN_FIFO_NR_CHANNELS;\r\n}\r\nstatic unsigned evtchn_fifo_nr_channels(void)\r\n{\r\nreturn event_array_pages * EVENT_WORDS_PER_PAGE;\r\n}\r\nstatic void free_unused_array_pages(void)\r\n{\r\nunsigned i;\r\nfor (i = event_array_pages; i < MAX_EVENT_ARRAY_PAGES; i++) {\r\nif (!event_array[i])\r\nbreak;\r\nfree_page((unsigned long)event_array[i]);\r\nevent_array[i] = NULL;\r\n}\r\n}\r\nstatic void init_array_page(event_word_t *array_page)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < EVENT_WORDS_PER_PAGE; i++)\r\narray_page[i] = 1 << EVTCHN_FIFO_MASKED;\r\n}\r\nstatic int evtchn_fifo_setup(struct irq_info *info)\r\n{\r\nunsigned port = info->evtchn;\r\nunsigned new_array_pages;\r\nint ret;\r\nnew_array_pages = port / EVENT_WORDS_PER_PAGE + 1;\r\nif (new_array_pages > MAX_EVENT_ARRAY_PAGES)\r\nreturn -EINVAL;\r\nwhile (event_array_pages < new_array_pages) {\r\nvoid *array_page;\r\nstruct evtchn_expand_array expand_array;\r\narray_page = event_array[event_array_pages];\r\nif (!array_page) {\r\narray_page = (void *)__get_free_page(GFP_KERNEL);\r\nif (array_page == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nevent_array[event_array_pages] = array_page;\r\n}\r\ninit_array_page(array_page);\r\nexpand_array.array_gfn = virt_to_mfn(array_page);\r\nret = HYPERVISOR_event_channel_op(EVTCHNOP_expand_array, &expand_array);\r\nif (ret < 0)\r\ngoto error;\r\nevent_array_pages++;\r\n}\r\nreturn 0;\r\nerror:\r\nif (event_array_pages == 0)\r\npanic("xen: unable to expand event array with initial page (%d)\n", ret);\r\nelse\r\npr_err("unable to expand event array (%d)\n", ret);\r\nfree_unused_array_pages();\r\nreturn ret;\r\n}\r\nstatic void evtchn_fifo_bind_to_cpu(struct irq_info *info, unsigned cpu)\r\n{\r\n}\r\nstatic void evtchn_fifo_clear_pending(unsigned port)\r\n{\r\nevent_word_t *word = event_word_from_port(port);\r\nsync_clear_bit(EVTCHN_FIFO_BIT(PENDING, word), BM(word));\r\n}\r\nstatic void evtchn_fifo_set_pending(unsigned port)\r\n{\r\nevent_word_t *word = event_word_from_port(port);\r\nsync_set_bit(EVTCHN_FIFO_BIT(PENDING, word), BM(word));\r\n}\r\nstatic bool evtchn_fifo_is_pending(unsigned port)\r\n{\r\nevent_word_t *word = event_word_from_port(port);\r\nreturn sync_test_bit(EVTCHN_FIFO_BIT(PENDING, word), BM(word));\r\n}\r\nstatic bool evtchn_fifo_test_and_set_mask(unsigned port)\r\n{\r\nevent_word_t *word = event_word_from_port(port);\r\nreturn sync_test_and_set_bit(EVTCHN_FIFO_BIT(MASKED, word), BM(word));\r\n}\r\nstatic void evtchn_fifo_mask(unsigned port)\r\n{\r\nevent_word_t *word = event_word_from_port(port);\r\nsync_set_bit(EVTCHN_FIFO_BIT(MASKED, word), BM(word));\r\n}\r\nstatic bool evtchn_fifo_is_masked(unsigned port)\r\n{\r\nevent_word_t *word = event_word_from_port(port);\r\nreturn sync_test_bit(EVTCHN_FIFO_BIT(MASKED, word), BM(word));\r\n}\r\nstatic void clear_masked(volatile event_word_t *word)\r\n{\r\nevent_word_t new, old, w;\r\nw = *word;\r\ndo {\r\nold = w & ~(1 << EVTCHN_FIFO_BUSY);\r\nnew = old & ~(1 << EVTCHN_FIFO_MASKED);\r\nw = sync_cmpxchg(word, old, new);\r\n} while (w != old);\r\n}\r\nstatic void evtchn_fifo_unmask(unsigned port)\r\n{\r\nevent_word_t *word = event_word_from_port(port);\r\nBUG_ON(!irqs_disabled());\r\nclear_masked(word);\r\nif (evtchn_fifo_is_pending(port)) {\r\nstruct evtchn_unmask unmask = { .port = port };\r\n(void)HYPERVISOR_event_channel_op(EVTCHNOP_unmask, &unmask);\r\n}\r\n}\r\nstatic uint32_t clear_linked(volatile event_word_t *word)\r\n{\r\nevent_word_t new, old, w;\r\nw = *word;\r\ndo {\r\nold = w;\r\nnew = (w & ~((1 << EVTCHN_FIFO_LINKED)\r\n| EVTCHN_FIFO_LINK_MASK));\r\n} while ((w = sync_cmpxchg(word, old, new)) != old);\r\nreturn w & EVTCHN_FIFO_LINK_MASK;\r\n}\r\nstatic void handle_irq_for_port(unsigned port)\r\n{\r\nint irq;\r\nirq = get_evtchn_to_irq(port);\r\nif (irq != -1)\r\ngeneric_handle_irq(irq);\r\n}\r\nstatic void consume_one_event(unsigned cpu,\r\nstruct evtchn_fifo_control_block *control_block,\r\nunsigned priority, unsigned long *ready)\r\n{\r\nstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\r\nuint32_t head;\r\nunsigned port;\r\nevent_word_t *word;\r\nhead = q->head[priority];\r\nif (head == 0) {\r\nrmb();\r\nhead = control_block->head[priority];\r\n}\r\nport = head;\r\nword = event_word_from_port(port);\r\nhead = clear_linked(word);\r\nif (head == 0)\r\nclear_bit(priority, ready);\r\nif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port))\r\nhandle_irq_for_port(port);\r\nq->head[priority] = head;\r\n}\r\nstatic void evtchn_fifo_handle_events(unsigned cpu)\r\n{\r\nstruct evtchn_fifo_control_block *control_block;\r\nunsigned long ready;\r\nunsigned q;\r\ncontrol_block = per_cpu(cpu_control_block, cpu);\r\nready = xchg(&control_block->ready, 0);\r\nwhile (ready) {\r\nq = find_first_bit(BM(&ready), EVTCHN_FIFO_MAX_QUEUES);\r\nconsume_one_event(cpu, control_block, q, &ready);\r\nready |= xchg(&control_block->ready, 0);\r\n}\r\n}\r\nstatic void evtchn_fifo_resume(void)\r\n{\r\nunsigned cpu;\r\nfor_each_possible_cpu(cpu) {\r\nvoid *control_block = per_cpu(cpu_control_block, cpu);\r\nstruct evtchn_init_control init_control;\r\nint ret;\r\nif (!control_block)\r\ncontinue;\r\nif (!cpu_online(cpu)) {\r\nfree_page((unsigned long)control_block);\r\nper_cpu(cpu_control_block, cpu) = NULL;\r\ncontinue;\r\n}\r\ninit_control.control_gfn = virt_to_mfn(control_block);\r\ninit_control.offset = 0;\r\ninit_control.vcpu = cpu;\r\nret = HYPERVISOR_event_channel_op(EVTCHNOP_init_control,\r\n&init_control);\r\nif (ret < 0)\r\nBUG();\r\n}\r\nevent_array_pages = 0;\r\n}\r\nstatic int evtchn_fifo_init_control_block(unsigned cpu)\r\n{\r\nstruct page *control_block = NULL;\r\nstruct evtchn_init_control init_control;\r\nint ret = -ENOMEM;\r\ncontrol_block = alloc_page(GFP_KERNEL|__GFP_ZERO);\r\nif (control_block == NULL)\r\ngoto error;\r\ninit_control.control_gfn = virt_to_mfn(page_address(control_block));\r\ninit_control.offset = 0;\r\ninit_control.vcpu = cpu;\r\nret = HYPERVISOR_event_channel_op(EVTCHNOP_init_control, &init_control);\r\nif (ret < 0)\r\ngoto error;\r\nper_cpu(cpu_control_block, cpu) = page_address(control_block);\r\nreturn 0;\r\nerror:\r\n__free_page(control_block);\r\nreturn ret;\r\n}\r\nstatic int evtchn_fifo_cpu_notification(struct notifier_block *self,\r\nunsigned long action,\r\nvoid *hcpu)\r\n{\r\nint cpu = (long)hcpu;\r\nint ret = 0;\r\nswitch (action) {\r\ncase CPU_UP_PREPARE:\r\nif (!per_cpu(cpu_control_block, cpu))\r\nret = evtchn_fifo_init_control_block(cpu);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret < 0 ? NOTIFY_BAD : NOTIFY_OK;\r\n}\r\nint __init xen_evtchn_fifo_init(void)\r\n{\r\nint cpu = get_cpu();\r\nint ret;\r\nret = evtchn_fifo_init_control_block(cpu);\r\nif (ret < 0)\r\ngoto out;\r\npr_info("Using FIFO-based ABI\n");\r\nevtchn_ops = &evtchn_ops_fifo;\r\nregister_cpu_notifier(&evtchn_fifo_cpu_notifier);\r\nout:\r\nput_cpu();\r\nreturn ret;\r\n}
