static int uinput_dev_event(struct input_dev *dev,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct uinput_device *udev = input_get_drvdata(dev);\r\nudev->buff[udev->head].type = type;\r\nudev->buff[udev->head].code = code;\r\nudev->buff[udev->head].value = value;\r\ndo_gettimeofday(&udev->buff[udev->head].time);\r\nudev->head = (udev->head + 1) % UINPUT_BUFFER_SIZE;\r\nwake_up_interruptible(&udev->waitq);\r\nreturn 0;\r\n}\r\nstatic bool uinput_request_alloc_id(struct uinput_device *udev,\r\nstruct uinput_request *request)\r\n{\r\nunsigned int id;\r\nbool reserved = false;\r\nspin_lock(&udev->requests_lock);\r\nfor (id = 0; id < UINPUT_NUM_REQUESTS; id++) {\r\nif (!udev->requests[id]) {\r\nrequest->id = id;\r\nudev->requests[id] = request;\r\nreserved = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&udev->requests_lock);\r\nreturn reserved;\r\n}\r\nstatic struct uinput_request *uinput_request_find(struct uinput_device *udev,\r\nunsigned int id)\r\n{\r\nif (id >= UINPUT_NUM_REQUESTS)\r\nreturn NULL;\r\nreturn udev->requests[id];\r\n}\r\nstatic int uinput_request_reserve_slot(struct uinput_device *udev,\r\nstruct uinput_request *request)\r\n{\r\nreturn wait_event_interruptible(udev->requests_waitq,\r\nuinput_request_alloc_id(udev, request));\r\n}\r\nstatic void uinput_request_done(struct uinput_device *udev,\r\nstruct uinput_request *request)\r\n{\r\nudev->requests[request->id] = NULL;\r\nwake_up(&udev->requests_waitq);\r\ncomplete(&request->done);\r\n}\r\nstatic int uinput_request_send(struct uinput_device *udev,\r\nstruct uinput_request *request)\r\n{\r\nint retval;\r\nretval = mutex_lock_interruptible(&udev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (udev->state != UIST_CREATED) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\ninit_completion(&request->done);\r\nuinput_dev_event(udev->dev, EV_UINPUT, request->code, request->id);\r\nout:\r\nmutex_unlock(&udev->mutex);\r\nreturn retval;\r\n}\r\nstatic int uinput_request_submit(struct uinput_device *udev,\r\nstruct uinput_request *request)\r\n{\r\nint error;\r\nerror = uinput_request_reserve_slot(udev, request);\r\nif (error)\r\nreturn error;\r\nerror = uinput_request_send(udev, request);\r\nif (error) {\r\nuinput_request_done(udev, request);\r\nreturn error;\r\n}\r\nwait_for_completion(&request->done);\r\nreturn request->retval;\r\n}\r\nstatic void uinput_flush_requests(struct uinput_device *udev)\r\n{\r\nstruct uinput_request *request;\r\nint i;\r\nspin_lock(&udev->requests_lock);\r\nfor (i = 0; i < UINPUT_NUM_REQUESTS; i++) {\r\nrequest = udev->requests[i];\r\nif (request) {\r\nrequest->retval = -ENODEV;\r\nuinput_request_done(udev, request);\r\n}\r\n}\r\nspin_unlock(&udev->requests_lock);\r\n}\r\nstatic void uinput_dev_set_gain(struct input_dev *dev, u16 gain)\r\n{\r\nuinput_dev_event(dev, EV_FF, FF_GAIN, gain);\r\n}\r\nstatic void uinput_dev_set_autocenter(struct input_dev *dev, u16 magnitude)\r\n{\r\nuinput_dev_event(dev, EV_FF, FF_AUTOCENTER, magnitude);\r\n}\r\nstatic int uinput_dev_playback(struct input_dev *dev, int effect_id, int value)\r\n{\r\nreturn uinput_dev_event(dev, EV_FF, effect_id, value);\r\n}\r\nstatic int uinput_dev_upload_effect(struct input_dev *dev,\r\nstruct ff_effect *effect,\r\nstruct ff_effect *old)\r\n{\r\nstruct uinput_device *udev = input_get_drvdata(dev);\r\nstruct uinput_request request;\r\nif (effect->type == FF_PERIODIC &&\r\neffect->u.periodic.waveform == FF_CUSTOM)\r\nreturn -EINVAL;\r\nrequest.code = UI_FF_UPLOAD;\r\nrequest.u.upload.effect = effect;\r\nrequest.u.upload.old = old;\r\nreturn uinput_request_submit(udev, &request);\r\n}\r\nstatic int uinput_dev_erase_effect(struct input_dev *dev, int effect_id)\r\n{\r\nstruct uinput_device *udev = input_get_drvdata(dev);\r\nstruct uinput_request request;\r\nif (!test_bit(EV_FF, dev->evbit))\r\nreturn -ENOSYS;\r\nrequest.code = UI_FF_ERASE;\r\nrequest.u.effect_id = effect_id;\r\nreturn uinput_request_submit(udev, &request);\r\n}\r\nstatic void uinput_destroy_device(struct uinput_device *udev)\r\n{\r\nconst char *name, *phys;\r\nstruct input_dev *dev = udev->dev;\r\nenum uinput_state old_state = udev->state;\r\nudev->state = UIST_NEW_DEVICE;\r\nif (dev) {\r\nname = dev->name;\r\nphys = dev->phys;\r\nif (old_state == UIST_CREATED) {\r\nuinput_flush_requests(udev);\r\ninput_unregister_device(dev);\r\n} else {\r\ninput_free_device(dev);\r\n}\r\nkfree(name);\r\nkfree(phys);\r\nudev->dev = NULL;\r\n}\r\n}\r\nstatic int uinput_create_device(struct uinput_device *udev)\r\n{\r\nstruct input_dev *dev = udev->dev;\r\nint error;\r\nif (udev->state != UIST_SETUP_COMPLETE) {\r\nprintk(KERN_DEBUG "%s: write device info first\n", UINPUT_NAME);\r\nreturn -EINVAL;\r\n}\r\nif (udev->ff_effects_max) {\r\nerror = input_ff_create(dev, udev->ff_effects_max);\r\nif (error)\r\ngoto fail1;\r\ndev->ff->upload = uinput_dev_upload_effect;\r\ndev->ff->erase = uinput_dev_erase_effect;\r\ndev->ff->playback = uinput_dev_playback;\r\ndev->ff->set_gain = uinput_dev_set_gain;\r\ndev->ff->set_autocenter = uinput_dev_set_autocenter;\r\n}\r\nerror = input_register_device(udev->dev);\r\nif (error)\r\ngoto fail2;\r\nudev->state = UIST_CREATED;\r\nreturn 0;\r\nfail2: input_ff_destroy(dev);\r\nfail1: uinput_destroy_device(udev);\r\nreturn error;\r\n}\r\nstatic int uinput_open(struct inode *inode, struct file *file)\r\n{\r\nstruct uinput_device *newdev;\r\nnewdev = kzalloc(sizeof(struct uinput_device), GFP_KERNEL);\r\nif (!newdev)\r\nreturn -ENOMEM;\r\nmutex_init(&newdev->mutex);\r\nspin_lock_init(&newdev->requests_lock);\r\ninit_waitqueue_head(&newdev->requests_waitq);\r\ninit_waitqueue_head(&newdev->waitq);\r\nnewdev->state = UIST_NEW_DEVICE;\r\nfile->private_data = newdev;\r\nnonseekable_open(inode, file);\r\nreturn 0;\r\n}\r\nstatic int uinput_validate_absbits(struct input_dev *dev)\r\n{\r\nunsigned int cnt;\r\nint retval = 0;\r\nfor (cnt = 0; cnt < ABS_CNT; cnt++) {\r\nint min, max;\r\nif (!test_bit(cnt, dev->absbit))\r\ncontinue;\r\nmin = input_abs_get_min(dev, cnt);\r\nmax = input_abs_get_max(dev, cnt);\r\nif ((min != 0 || max != 0) && max <= min) {\r\nprintk(KERN_DEBUG\r\n"%s: invalid abs[%02x] min:%d max:%d\n",\r\nUINPUT_NAME, cnt,\r\ninput_abs_get_min(dev, cnt),\r\ninput_abs_get_max(dev, cnt));\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nif (input_abs_get_flat(dev, cnt) >\r\ninput_abs_get_max(dev, cnt) - input_abs_get_min(dev, cnt)) {\r\nprintk(KERN_DEBUG\r\n"%s: abs_flat #%02x out of range: %d "\r\n"(min:%d/max:%d)\n",\r\nUINPUT_NAME, cnt,\r\ninput_abs_get_flat(dev, cnt),\r\ninput_abs_get_min(dev, cnt),\r\ninput_abs_get_max(dev, cnt));\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int uinput_allocate_device(struct uinput_device *udev)\r\n{\r\nudev->dev = input_allocate_device();\r\nif (!udev->dev)\r\nreturn -ENOMEM;\r\nudev->dev->event = uinput_dev_event;\r\ninput_set_drvdata(udev->dev, udev);\r\nreturn 0;\r\n}\r\nstatic int uinput_setup_device(struct uinput_device *udev,\r\nconst char __user *buffer, size_t count)\r\n{\r\nstruct uinput_user_dev *user_dev;\r\nstruct input_dev *dev;\r\nint i;\r\nint retval;\r\nif (count != sizeof(struct uinput_user_dev))\r\nreturn -EINVAL;\r\nif (!udev->dev) {\r\nretval = uinput_allocate_device(udev);\r\nif (retval)\r\nreturn retval;\r\n}\r\ndev = udev->dev;\r\nuser_dev = memdup_user(buffer, sizeof(struct uinput_user_dev));\r\nif (IS_ERR(user_dev))\r\nreturn PTR_ERR(user_dev);\r\nudev->ff_effects_max = user_dev->ff_effects_max;\r\nif (!user_dev->name[0]) {\r\nretval = -EINVAL;\r\ngoto exit;\r\n}\r\nkfree(dev->name);\r\ndev->name = kstrndup(user_dev->name, UINPUT_MAX_NAME_SIZE,\r\nGFP_KERNEL);\r\nif (!dev->name) {\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\ndev->id.bustype = user_dev->id.bustype;\r\ndev->id.vendor = user_dev->id.vendor;\r\ndev->id.product = user_dev->id.product;\r\ndev->id.version = user_dev->id.version;\r\nfor (i = 0; i < ABS_CNT; i++) {\r\ninput_abs_set_max(dev, i, user_dev->absmax[i]);\r\ninput_abs_set_min(dev, i, user_dev->absmin[i]);\r\ninput_abs_set_fuzz(dev, i, user_dev->absfuzz[i]);\r\ninput_abs_set_flat(dev, i, user_dev->absflat[i]);\r\n}\r\nif (test_bit(EV_ABS, dev->evbit)) {\r\nretval = uinput_validate_absbits(dev);\r\nif (retval < 0)\r\ngoto exit;\r\nif (test_bit(ABS_MT_SLOT, dev->absbit)) {\r\nint nslot = input_abs_get_max(dev, ABS_MT_SLOT) + 1;\r\ninput_mt_init_slots(dev, nslot, 0);\r\n} else if (test_bit(ABS_MT_POSITION_X, dev->absbit)) {\r\ninput_set_events_per_packet(dev, 60);\r\n}\r\n}\r\nudev->state = UIST_SETUP_COMPLETE;\r\nretval = count;\r\nexit:\r\nkfree(user_dev);\r\nreturn retval;\r\n}\r\nstatic ssize_t uinput_inject_events(struct uinput_device *udev,\r\nconst char __user *buffer, size_t count)\r\n{\r\nstruct input_event ev;\r\nsize_t bytes = 0;\r\nif (count != 0 && count < input_event_size())\r\nreturn -EINVAL;\r\nwhile (bytes + input_event_size() <= count) {\r\nif (input_event_from_user(buffer + bytes, &ev))\r\nreturn -EFAULT;\r\ninput_event(udev->dev, ev.type, ev.code, ev.value);\r\nbytes += input_event_size();\r\n}\r\nreturn bytes;\r\n}\r\nstatic ssize_t uinput_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct uinput_device *udev = file->private_data;\r\nint retval;\r\nif (count == 0)\r\nreturn 0;\r\nretval = mutex_lock_interruptible(&udev->mutex);\r\nif (retval)\r\nreturn retval;\r\nretval = udev->state == UIST_CREATED ?\r\nuinput_inject_events(udev, buffer, count) :\r\nuinput_setup_device(udev, buffer, count);\r\nmutex_unlock(&udev->mutex);\r\nreturn retval;\r\n}\r\nstatic bool uinput_fetch_next_event(struct uinput_device *udev,\r\nstruct input_event *event)\r\n{\r\nbool have_event;\r\nspin_lock_irq(&udev->dev->event_lock);\r\nhave_event = udev->head != udev->tail;\r\nif (have_event) {\r\n*event = udev->buff[udev->tail];\r\nudev->tail = (udev->tail + 1) % UINPUT_BUFFER_SIZE;\r\n}\r\nspin_unlock_irq(&udev->dev->event_lock);\r\nreturn have_event;\r\n}\r\nstatic ssize_t uinput_events_to_user(struct uinput_device *udev,\r\nchar __user *buffer, size_t count)\r\n{\r\nstruct input_event event;\r\nsize_t read = 0;\r\nwhile (read + input_event_size() <= count &&\r\nuinput_fetch_next_event(udev, &event)) {\r\nif (input_event_to_user(buffer + read, &event))\r\nreturn -EFAULT;\r\nread += input_event_size();\r\n}\r\nreturn read;\r\n}\r\nstatic ssize_t uinput_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct uinput_device *udev = file->private_data;\r\nssize_t retval;\r\nif (count != 0 && count < input_event_size())\r\nreturn -EINVAL;\r\ndo {\r\nretval = mutex_lock_interruptible(&udev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (udev->state != UIST_CREATED)\r\nretval = -ENODEV;\r\nelse if (udev->head == udev->tail &&\r\n(file->f_flags & O_NONBLOCK))\r\nretval = -EAGAIN;\r\nelse\r\nretval = uinput_events_to_user(udev, buffer, count);\r\nmutex_unlock(&udev->mutex);\r\nif (retval || count == 0)\r\nbreak;\r\nif (!(file->f_flags & O_NONBLOCK))\r\nretval = wait_event_interruptible(udev->waitq,\r\nudev->head != udev->tail ||\r\nudev->state != UIST_CREATED);\r\n} while (retval == 0);\r\nreturn retval;\r\n}\r\nstatic unsigned int uinput_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct uinput_device *udev = file->private_data;\r\npoll_wait(file, &udev->waitq, wait);\r\nif (udev->head != udev->tail)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int uinput_release(struct inode *inode, struct file *file)\r\n{\r\nstruct uinput_device *udev = file->private_data;\r\nuinput_destroy_device(udev);\r\nkfree(udev);\r\nreturn 0;\r\n}\r\nstatic int uinput_ff_upload_to_user(char __user *buffer,\r\nconst struct uinput_ff_upload *ff_up)\r\n{\r\nif (INPUT_COMPAT_TEST) {\r\nstruct uinput_ff_upload_compat ff_up_compat;\r\nff_up_compat.request_id = ff_up->request_id;\r\nff_up_compat.retval = ff_up->retval;\r\nmemcpy(&ff_up_compat.effect, &ff_up->effect,\r\nsizeof(struct ff_effect_compat));\r\nmemcpy(&ff_up_compat.old, &ff_up->old,\r\nsizeof(struct ff_effect_compat));\r\nif (copy_to_user(buffer, &ff_up_compat,\r\nsizeof(struct uinput_ff_upload_compat)))\r\nreturn -EFAULT;\r\n} else {\r\nif (copy_to_user(buffer, ff_up,\r\nsizeof(struct uinput_ff_upload)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uinput_ff_upload_from_user(const char __user *buffer,\r\nstruct uinput_ff_upload *ff_up)\r\n{\r\nif (INPUT_COMPAT_TEST) {\r\nstruct uinput_ff_upload_compat ff_up_compat;\r\nif (copy_from_user(&ff_up_compat, buffer,\r\nsizeof(struct uinput_ff_upload_compat)))\r\nreturn -EFAULT;\r\nff_up->request_id = ff_up_compat.request_id;\r\nff_up->retval = ff_up_compat.retval;\r\nmemcpy(&ff_up->effect, &ff_up_compat.effect,\r\nsizeof(struct ff_effect_compat));\r\nmemcpy(&ff_up->old, &ff_up_compat.old,\r\nsizeof(struct ff_effect_compat));\r\n} else {\r\nif (copy_from_user(ff_up, buffer,\r\nsizeof(struct uinput_ff_upload)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uinput_ff_upload_to_user(char __user *buffer,\r\nconst struct uinput_ff_upload *ff_up)\r\n{\r\nif (copy_to_user(buffer, ff_up, sizeof(struct uinput_ff_upload)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uinput_ff_upload_from_user(const char __user *buffer,\r\nstruct uinput_ff_upload *ff_up)\r\n{\r\nif (copy_from_user(ff_up, buffer, sizeof(struct uinput_ff_upload)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uinput_str_to_user(void __user *dest, const char *str,\r\nunsigned int maxlen)\r\n{\r\nchar __user *p = dest;\r\nint len, ret;\r\nif (!str)\r\nreturn -ENOENT;\r\nif (maxlen == 0)\r\nreturn -EINVAL;\r\nlen = strlen(str) + 1;\r\nif (len > maxlen)\r\nlen = maxlen;\r\nret = copy_to_user(p, str, len);\r\nif (ret)\r\nreturn -EFAULT;\r\nret = put_user(0, p + len - 1);\r\nreturn ret ? -EFAULT : len;\r\n}\r\nstatic long uinput_ioctl_handler(struct file *file, unsigned int cmd,\r\nunsigned long arg, void __user *p)\r\n{\r\nint retval;\r\nstruct uinput_device *udev = file->private_data;\r\nstruct uinput_ff_upload ff_up;\r\nstruct uinput_ff_erase ff_erase;\r\nstruct uinput_request *req;\r\nchar *phys;\r\nconst char *name;\r\nunsigned int size;\r\nretval = mutex_lock_interruptible(&udev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!udev->dev) {\r\nretval = uinput_allocate_device(udev);\r\nif (retval)\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase UI_DEV_CREATE:\r\nretval = uinput_create_device(udev);\r\ngoto out;\r\ncase UI_DEV_DESTROY:\r\nuinput_destroy_device(udev);\r\ngoto out;\r\ncase UI_SET_EVBIT:\r\nretval = uinput_set_bit(arg, evbit, EV_MAX);\r\ngoto out;\r\ncase UI_SET_KEYBIT:\r\nretval = uinput_set_bit(arg, keybit, KEY_MAX);\r\ngoto out;\r\ncase UI_SET_RELBIT:\r\nretval = uinput_set_bit(arg, relbit, REL_MAX);\r\ngoto out;\r\ncase UI_SET_ABSBIT:\r\nretval = uinput_set_bit(arg, absbit, ABS_MAX);\r\ngoto out;\r\ncase UI_SET_MSCBIT:\r\nretval = uinput_set_bit(arg, mscbit, MSC_MAX);\r\ngoto out;\r\ncase UI_SET_LEDBIT:\r\nretval = uinput_set_bit(arg, ledbit, LED_MAX);\r\ngoto out;\r\ncase UI_SET_SNDBIT:\r\nretval = uinput_set_bit(arg, sndbit, SND_MAX);\r\ngoto out;\r\ncase UI_SET_FFBIT:\r\nretval = uinput_set_bit(arg, ffbit, FF_MAX);\r\ngoto out;\r\ncase UI_SET_SWBIT:\r\nretval = uinput_set_bit(arg, swbit, SW_MAX);\r\ngoto out;\r\ncase UI_SET_PROPBIT:\r\nretval = uinput_set_bit(arg, propbit, INPUT_PROP_MAX);\r\ngoto out;\r\ncase UI_SET_PHYS:\r\nif (udev->state == UIST_CREATED) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nphys = strndup_user(p, 1024);\r\nif (IS_ERR(phys)) {\r\nretval = PTR_ERR(phys);\r\ngoto out;\r\n}\r\nkfree(udev->dev->phys);\r\nudev->dev->phys = phys;\r\ngoto out;\r\ncase UI_BEGIN_FF_UPLOAD:\r\nretval = uinput_ff_upload_from_user(p, &ff_up);\r\nif (retval)\r\ngoto out;\r\nreq = uinput_request_find(udev, ff_up.request_id);\r\nif (!req || req->code != UI_FF_UPLOAD ||\r\n!req->u.upload.effect) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nff_up.retval = 0;\r\nff_up.effect = *req->u.upload.effect;\r\nif (req->u.upload.old)\r\nff_up.old = *req->u.upload.old;\r\nelse\r\nmemset(&ff_up.old, 0, sizeof(struct ff_effect));\r\nretval = uinput_ff_upload_to_user(p, &ff_up);\r\ngoto out;\r\ncase UI_BEGIN_FF_ERASE:\r\nif (copy_from_user(&ff_erase, p, sizeof(ff_erase))) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nreq = uinput_request_find(udev, ff_erase.request_id);\r\nif (!req || req->code != UI_FF_ERASE) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nff_erase.retval = 0;\r\nff_erase.effect_id = req->u.effect_id;\r\nif (copy_to_user(p, &ff_erase, sizeof(ff_erase))) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\ngoto out;\r\ncase UI_END_FF_UPLOAD:\r\nretval = uinput_ff_upload_from_user(p, &ff_up);\r\nif (retval)\r\ngoto out;\r\nreq = uinput_request_find(udev, ff_up.request_id);\r\nif (!req || req->code != UI_FF_UPLOAD ||\r\n!req->u.upload.effect) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nreq->retval = ff_up.retval;\r\nuinput_request_done(udev, req);\r\ngoto out;\r\ncase UI_END_FF_ERASE:\r\nif (copy_from_user(&ff_erase, p, sizeof(ff_erase))) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nreq = uinput_request_find(udev, ff_erase.request_id);\r\nif (!req || req->code != UI_FF_ERASE) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nreq->retval = ff_erase.retval;\r\nuinput_request_done(udev, req);\r\ngoto out;\r\n}\r\nsize = _IOC_SIZE(cmd);\r\nswitch (cmd & ~IOCSIZE_MASK) {\r\ncase UI_GET_SYSNAME(0):\r\nif (udev->state != UIST_CREATED) {\r\nretval = -ENOENT;\r\ngoto out;\r\n}\r\nname = dev_name(&udev->dev->dev);\r\nretval = uinput_str_to_user(p, name, size);\r\ngoto out;\r\n}\r\nretval = -EINVAL;\r\nout:\r\nmutex_unlock(&udev->mutex);\r\nreturn retval;\r\n}\r\nstatic long uinput_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn uinput_ioctl_handler(file, cmd, arg, (void __user *)arg);\r\n}\r\nstatic long uinput_compat_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn uinput_ioctl_handler(file, cmd, arg, compat_ptr(arg));\r\n}\r\nstatic int __init uinput_init(void)\r\n{\r\nreturn misc_register(&uinput_misc);\r\n}\r\nstatic void __exit uinput_exit(void)\r\n{\r\nmisc_deregister(&uinput_misc);\r\n}
