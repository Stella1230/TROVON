static int uprobes_substitute_pc(unsigned long *pinsn, u32 oregs)\r\n{\r\nprobes_opcode_t insn = __mem_to_opcode_arm(*pinsn);\r\nprobes_opcode_t temp;\r\nprobes_opcode_t mask;\r\nint freereg;\r\nu32 free = 0xffff;\r\nu32 regs;\r\nfor (regs = oregs; regs; regs >>= 4, insn >>= 4) {\r\nif ((regs & 0xf) == REG_TYPE_NONE)\r\ncontinue;\r\nfree &= ~(1 << (insn & 0xf));\r\n}\r\nif (free & (1 << 15))\r\nreturn 15;\r\nif (!free)\r\nreturn -1;\r\nfreereg = free = fls(free) - 1;\r\ntemp = __mem_to_opcode_arm(*pinsn);\r\ninsn = temp;\r\nregs = oregs;\r\nmask = 0xf;\r\nfor (; regs; regs >>= 4, mask <<= 4, free <<= 4, temp >>= 4) {\r\nif ((regs & 0xf) == REG_TYPE_NONE)\r\ncontinue;\r\nif ((temp & 0xf) != 15)\r\ncontinue;\r\ninsn &= ~mask;\r\ninsn |= free & mask;\r\n}\r\n*pinsn = __opcode_to_mem_arm(insn);\r\nreturn freereg;\r\n}\r\nstatic void uprobe_set_pc(struct arch_uprobe *auprobe,\r\nstruct arch_uprobe_task *autask,\r\nstruct pt_regs *regs)\r\n{\r\nu32 pcreg = auprobe->pcreg;\r\nautask->backup = regs->uregs[pcreg];\r\nregs->uregs[pcreg] = regs->ARM_pc + 8;\r\n}\r\nstatic void uprobe_unset_pc(struct arch_uprobe *auprobe,\r\nstruct arch_uprobe_task *autask,\r\nstruct pt_regs *regs)\r\n{\r\nregs->uregs[auprobe->pcreg] = autask->backup;\r\n}\r\nstatic void uprobe_aluwrite_pc(struct arch_uprobe *auprobe,\r\nstruct arch_uprobe_task *autask,\r\nstruct pt_regs *regs)\r\n{\r\nu32 pcreg = auprobe->pcreg;\r\nalu_write_pc(regs->uregs[pcreg], regs);\r\nregs->uregs[pcreg] = autask->backup;\r\n}\r\nstatic void uprobe_write_pc(struct arch_uprobe *auprobe,\r\nstruct arch_uprobe_task *autask,\r\nstruct pt_regs *regs)\r\n{\r\nu32 pcreg = auprobe->pcreg;\r\nload_write_pc(regs->uregs[pcreg], regs);\r\nregs->uregs[pcreg] = autask->backup;\r\n}\r\nenum probes_insn\r\ndecode_pc_ro(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\nstruct arch_uprobe *auprobe = container_of(asi, struct arch_uprobe,\r\nasi);\r\nstruct decode_emulate *decode = (struct decode_emulate *) d;\r\nu32 regs = decode->header.type_regs.bits >> DECODE_TYPE_BITS;\r\nint reg;\r\nreg = uprobes_substitute_pc(&auprobe->ixol[0], regs);\r\nif (reg == 15)\r\nreturn INSN_GOOD;\r\nif (reg == -1)\r\nreturn INSN_REJECTED;\r\nauprobe->pcreg = reg;\r\nauprobe->prehandler = uprobe_set_pc;\r\nauprobe->posthandler = uprobe_unset_pc;\r\nreturn INSN_GOOD;\r\n}\r\nenum probes_insn\r\ndecode_wb_pc(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *d, bool alu)\r\n{\r\nstruct arch_uprobe *auprobe = container_of(asi, struct arch_uprobe,\r\nasi);\r\nenum probes_insn ret = decode_pc_ro(insn, asi, d);\r\nif (((insn >> 12) & 0xf) == 15)\r\nauprobe->posthandler = alu ? uprobe_aluwrite_pc\r\n: uprobe_write_pc;\r\nreturn ret;\r\n}\r\nenum probes_insn\r\ndecode_rd12rn16rm0rs8_rwflags(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\nreturn decode_wb_pc(insn, asi, d, true);\r\n}\r\nenum probes_insn\r\ndecode_ldr(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\nreturn decode_wb_pc(insn, asi, d, false);\r\n}\r\nenum probes_insn\r\nuprobe_decode_ldmstm(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\nstruct arch_uprobe *auprobe = container_of(asi, struct arch_uprobe,\r\nasi);\r\nunsigned reglist = insn & 0xffff;\r\nint rn = (insn >> 16) & 0xf;\r\nint lbit = insn & (1 << 20);\r\nunsigned used = reglist | (1 << rn);\r\nif (rn == 15)\r\nreturn INSN_REJECTED;\r\nif (!(used & (1 << 15)))\r\nreturn INSN_GOOD;\r\nif (used & (1 << 14))\r\nreturn INSN_REJECTED;\r\ninsn ^= 0xc000;\r\nauprobe->pcreg = 14;\r\nauprobe->ixol[0] = __opcode_to_mem_arm(insn);\r\nauprobe->prehandler = uprobe_set_pc;\r\nif (lbit)\r\nauprobe->posthandler = uprobe_write_pc;\r\nelse\r\nauprobe->posthandler = uprobe_unset_pc;\r\nreturn INSN_GOOD;\r\n}
