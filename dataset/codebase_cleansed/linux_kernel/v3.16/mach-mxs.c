static inline void __mxs_setl(u32 mask, void __iomem *reg)\r\n{\r\n__raw_writel(mask, reg + MXS_SET_ADDR);\r\n}\r\nstatic inline void __mxs_clrl(u32 mask, void __iomem *reg)\r\n{\r\n__raw_writel(mask, reg + MXS_CLR_ADDR);\r\n}\r\nstatic inline void __mxs_togl(u32 mask, void __iomem *reg)\r\n{\r\n__raw_writel(mask, reg + MXS_TOG_ADDR);\r\n}\r\nstatic const u32 *mxs_get_ocotp(void)\r\n{\r\nstruct device_node *np;\r\nvoid __iomem *ocotp_base;\r\nint timeout = 0x400;\r\nsize_t i;\r\nstatic int once;\r\nif (once)\r\nreturn ocotp_words;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,ocotp");\r\nocotp_base = of_iomap(np, 0);\r\nWARN_ON(!ocotp_base);\r\nmutex_lock(&ocotp_mutex);\r\n__mxs_clrl(BM_OCOTP_CTRL_ERROR, ocotp_base);\r\nwhile ((__raw_readl(ocotp_base) &\r\n(BM_OCOTP_CTRL_BUSY | BM_OCOTP_CTRL_ERROR)) && --timeout)\r\ncpu_relax();\r\nif (unlikely(!timeout))\r\ngoto error_unlock;\r\n__mxs_setl(BM_OCOTP_CTRL_RD_BANK_OPEN, ocotp_base);\r\nudelay(1);\r\ntimeout = 0x400;\r\nwhile ((__raw_readl(ocotp_base) & BM_OCOTP_CTRL_BUSY) && --timeout)\r\ncpu_relax();\r\nif (unlikely(!timeout))\r\ngoto error_unlock;\r\nfor (i = 0; i < OCOTP_WORD_COUNT; i++)\r\nocotp_words[i] = __raw_readl(ocotp_base + OCOTP_WORD_OFFSET +\r\ni * 0x10);\r\n__mxs_clrl(BM_OCOTP_CTRL_RD_BANK_OPEN, ocotp_base);\r\nonce = 1;\r\nmutex_unlock(&ocotp_mutex);\r\nreturn ocotp_words;\r\nerror_unlock:\r\nmutex_unlock(&ocotp_mutex);\r\npr_err("%s: timeout in reading OCOTP\n", __func__);\r\nreturn NULL;\r\n}\r\nstatic void __init update_fec_mac_prop(enum mac_oui oui)\r\n{\r\nstruct device_node *np, *from = NULL;\r\nstruct property *newmac;\r\nconst u32 *ocotp = mxs_get_ocotp();\r\nu8 *macaddr;\r\nu32 val;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nnp = of_find_compatible_node(from, NULL, "fsl,imx28-fec");\r\nif (!np)\r\nreturn;\r\nfrom = np;\r\nif (of_get_property(np, "local-mac-address", NULL))\r\ncontinue;\r\nnewmac = kzalloc(sizeof(*newmac) + 6, GFP_KERNEL);\r\nif (!newmac)\r\nreturn;\r\nnewmac->value = newmac + 1;\r\nnewmac->length = 6;\r\nnewmac->name = kstrdup("local-mac-address", GFP_KERNEL);\r\nif (!newmac->name) {\r\nkfree(newmac);\r\nreturn;\r\n}\r\nmacaddr = newmac->value;\r\nswitch (oui) {\r\ncase OUI_FSL:\r\nmacaddr[0] = 0x00;\r\nmacaddr[1] = 0x04;\r\nmacaddr[2] = 0x9f;\r\nbreak;\r\ncase OUI_DENX:\r\nmacaddr[0] = 0xc0;\r\nmacaddr[1] = 0xe5;\r\nmacaddr[2] = 0x4e;\r\nbreak;\r\ncase OUI_CRYSTALFONTZ:\r\nmacaddr[0] = 0x58;\r\nmacaddr[1] = 0xb9;\r\nmacaddr[2] = 0xe1;\r\nbreak;\r\ncase OUI_I2SE:\r\nmacaddr[0] = 0x00;\r\nmacaddr[1] = 0x01;\r\nmacaddr[2] = 0x87;\r\nbreak;\r\ncase OUI_ARMADEUS:\r\nmacaddr[0] = 0x00;\r\nmacaddr[1] = 0x1e;\r\nmacaddr[2] = 0xac;\r\nbreak;\r\n}\r\nval = ocotp[i];\r\nmacaddr[3] = (val >> 16) & 0xff;\r\nmacaddr[4] = (val >> 8) & 0xff;\r\nmacaddr[5] = (val >> 0) & 0xff;\r\nof_update_property(np, newmac);\r\n}\r\n}\r\nstatic inline void enable_clk_enet_out(void)\r\n{\r\nstruct clk *clk = clk_get_sys("enet_out", NULL);\r\nif (!IS_ERR(clk))\r\nclk_prepare_enable(clk);\r\n}\r\nstatic void __init imx28_evk_init(void)\r\n{\r\nupdate_fec_mac_prop(OUI_FSL);\r\nmxs_saif_clkmux_select(MXS_DIGCTL_SAIF_CLKMUX_EXTMSTR0);\r\n}\r\nstatic void __init imx28_apf28_init(void)\r\n{\r\nupdate_fec_mac_prop(OUI_ARMADEUS);\r\n}\r\nstatic int apx4devkit_phy_fixup(struct phy_device *phy)\r\n{\r\nphy->dev_flags |= MICREL_PHY_50MHZ_CLK;\r\nreturn 0;\r\n}\r\nstatic void __init apx4devkit_init(void)\r\n{\r\nenable_clk_enet_out();\r\nif (IS_BUILTIN(CONFIG_PHYLIB))\r\nphy_register_fixup_for_uid(PHY_ID_KSZ8051, MICREL_PHY_ID_MASK,\r\napx4devkit_phy_fixup);\r\n}\r\nstatic void __init tx28_post_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct platform_device *pdev;\r\nstruct pinctrl *pctl;\r\nint ret;\r\nenable_clk_enet_out();\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,imx28-fec");\r\npdev = of_find_device_by_node(np);\r\nif (!pdev) {\r\npr_err("%s: failed to find fec device\n", __func__);\r\nreturn;\r\n}\r\npctl = pinctrl_get_select(&pdev->dev, "gpio_mode");\r\nif (IS_ERR(pctl)) {\r\npr_err("%s: failed to get pinctrl state\n", __func__);\r\nreturn;\r\n}\r\nret = gpio_request_array(tx28_gpios, ARRAY_SIZE(tx28_gpios));\r\nif (ret) {\r\npr_err("%s: failed to request gpios: %d\n", __func__, ret);\r\nreturn;\r\n}\r\ngpio_set_value(TX28_FEC_PHY_POWER, 1);\r\nmsleep(26);\r\ngpio_set_value(ENET0_RX_EN__GPIO_4_2, 1);\r\ngpio_set_value(ENET0_RXD0__GPIO_4_3, 1);\r\ngpio_set_value(ENET0_RXD1__GPIO_4_4, 1);\r\nudelay(100);\r\ngpio_set_value(TX28_FEC_PHY_RESET, 1);\r\npinctrl_put(pctl);\r\n}\r\nstatic void __init crystalfontz_init(void)\r\n{\r\nupdate_fec_mac_prop(OUI_CRYSTALFONTZ);\r\n}\r\nstatic void __init duckbill_init(void)\r\n{\r\nupdate_fec_mac_prop(OUI_I2SE);\r\n}\r\nstatic void __init m28cu3_init(void)\r\n{\r\nupdate_fec_mac_prop(OUI_DENX);\r\n}\r\nstatic const char __init *mxs_get_soc_id(void)\r\n{\r\nstruct device_node *np;\r\nvoid __iomem *digctl_base;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,imx23-digctl");\r\ndigctl_base = of_iomap(np, 0);\r\nWARN_ON(!digctl_base);\r\nchipid = readl(digctl_base + HW_DIGCTL_CHIPID);\r\nsocid = chipid & HW_DIGCTL_CHIPID_MASK;\r\niounmap(digctl_base);\r\nof_node_put(np);\r\nswitch (socid) {\r\ncase HW_DIGCTL_CHIPID_MX23:\r\nreturn "i.MX23";\r\ncase HW_DIGCTL_CHIPID_MX28:\r\nreturn "i.MX28";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\n}\r\nstatic u32 __init mxs_get_cpu_rev(void)\r\n{\r\nu32 rev = chipid & HW_DIGCTL_REV_MASK;\r\nswitch (socid) {\r\ncase HW_DIGCTL_CHIPID_MX23:\r\nswitch (rev) {\r\ncase 0x0:\r\nreturn MXS_CHIP_REVISION_1_0;\r\ncase 0x1:\r\nreturn MXS_CHIP_REVISION_1_1;\r\ncase 0x2:\r\nreturn MXS_CHIP_REVISION_1_2;\r\ncase 0x3:\r\nreturn MXS_CHIP_REVISION_1_3;\r\ncase 0x4:\r\nreturn MXS_CHIP_REVISION_1_4;\r\ndefault:\r\nreturn MXS_CHIP_REV_UNKNOWN;\r\n}\r\ncase HW_DIGCTL_CHIPID_MX28:\r\nswitch (rev) {\r\ncase 0x0:\r\nreturn MXS_CHIP_REVISION_1_1;\r\ncase 0x1:\r\nreturn MXS_CHIP_REVISION_1_2;\r\ndefault:\r\nreturn MXS_CHIP_REV_UNKNOWN;\r\n}\r\ndefault:\r\nreturn MXS_CHIP_REV_UNKNOWN;\r\n}\r\n}\r\nstatic const char __init *mxs_get_revision(void)\r\n{\r\nu32 rev = mxs_get_cpu_rev();\r\nif (rev != MXS_CHIP_REV_UNKNOWN)\r\nreturn kasprintf(GFP_KERNEL, "%d.%d", (rev >> 4) & 0xf,\r\nrev & 0xf);\r\nelse\r\nreturn kasprintf(GFP_KERNEL, "%s", "Unknown");\r\n}\r\nstatic int __init mxs_restart_init(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,clkctrl");\r\nreset_addr = of_iomap(np, 0);\r\nif (!reset_addr)\r\nreturn -ENODEV;\r\nif (of_device_is_compatible(np, "fsl,imx23-clkctrl"))\r\nreset_addr += MX23_CLKCTRL_RESET_OFFSET;\r\nelse\r\nreset_addr += MX28_CLKCTRL_RESET_OFFSET;\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic void __init eukrea_mbmx283lc_init(void)\r\n{\r\nmxs_saif_clkmux_select(MXS_DIGCTL_SAIF_CLKMUX_EXTMSTR0);\r\n}\r\nstatic void __init mxs_machine_init(void)\r\n{\r\nstruct device_node *root;\r\nstruct device *parent;\r\nstruct soc_device *soc_dev;\r\nstruct soc_device_attribute *soc_dev_attr;\r\nint ret;\r\nsoc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);\r\nif (!soc_dev_attr)\r\nreturn;\r\nroot = of_find_node_by_path("/");\r\nret = of_property_read_string(root, "model", &soc_dev_attr->machine);\r\nif (ret)\r\nreturn;\r\nsoc_dev_attr->family = "Freescale MXS Family";\r\nsoc_dev_attr->soc_id = mxs_get_soc_id();\r\nsoc_dev_attr->revision = mxs_get_revision();\r\nsoc_dev = soc_device_register(soc_dev_attr);\r\nif (IS_ERR(soc_dev)) {\r\nkfree(soc_dev_attr->revision);\r\nkfree(soc_dev_attr);\r\nreturn;\r\n}\r\nparent = soc_device_to_device(soc_dev);\r\nif (of_machine_is_compatible("fsl,imx28-evk"))\r\nimx28_evk_init();\r\nif (of_machine_is_compatible("armadeus,imx28-apf28"))\r\nimx28_apf28_init();\r\nelse if (of_machine_is_compatible("bluegiga,apx4devkit"))\r\napx4devkit_init();\r\nelse if (of_machine_is_compatible("crystalfontz,cfa10036"))\r\ncrystalfontz_init();\r\nelse if (of_machine_is_compatible("eukrea,mbmx283lc"))\r\neukrea_mbmx283lc_init();\r\nelse if (of_machine_is_compatible("i2se,duckbill"))\r\nduckbill_init();\r\nelse if (of_machine_is_compatible("msr,m28cu3"))\r\nm28cu3_init();\r\nof_platform_populate(NULL, of_default_bus_match_table,\r\nNULL, parent);\r\nmxs_restart_init();\r\nif (of_machine_is_compatible("karo,tx28"))\r\ntx28_post_init();\r\n}\r\nstatic void mxs_restart(enum reboot_mode mode, const char *cmd)\r\n{\r\nif (reset_addr) {\r\n__mxs_setl(MXS_CLKCTRL_RESET_CHIP, reset_addr);\r\npr_err("Failed to assert the chip reset\n");\r\nmdelay(50);\r\n}\r\nsoft_restart(0);\r\n}
