static inline int\r\ncount_list_member(struct list_head *head)\r\n{\r\nint cnt = 0;\r\nstruct list_head *m;\r\nlist_for_each(m, head)\r\ncnt++;\r\nreturn cnt;\r\n}\r\nvoid\r\ndsp_cmx_debug(struct dsp *dsp)\r\n{\r\nstruct dsp_conf *conf;\r\nstruct dsp_conf_member *member;\r\nstruct dsp *odsp;\r\nprintk(KERN_DEBUG "-----Current DSP\n");\r\nlist_for_each_entry(odsp, &dsp_ilist, list) {\r\nprintk(KERN_DEBUG "* %s hardecho=%d softecho=%d txmix=%d",\r\nodsp->name, odsp->echo.hardware, odsp->echo.software,\r\nodsp->tx_mix);\r\nif (odsp->conf)\r\nprintk(" (Conf %d)", odsp->conf->id);\r\nif (dsp == odsp)\r\nprintk(" *this*");\r\nprintk("\n");\r\n}\r\nprintk(KERN_DEBUG "-----Current Conf:\n");\r\nlist_for_each_entry(conf, &conf_ilist, list) {\r\nprintk(KERN_DEBUG "* Conf %d (%p)\n", conf->id, conf);\r\nlist_for_each_entry(member, &conf->mlist, list) {\r\nprintk(KERN_DEBUG\r\n" - member = %s (slot_tx %d, bank_tx %d, "\r\n"slot_rx %d, bank_rx %d hfc_conf %d "\r\n"tx_data %d rx_is_off %d)%s\n",\r\nmember->dsp->name, member->dsp->pcm_slot_tx,\r\nmember->dsp->pcm_bank_tx, member->dsp->pcm_slot_rx,\r\nmember->dsp->pcm_bank_rx, member->dsp->hfc_conf,\r\nmember->dsp->tx_data, member->dsp->rx_is_off,\r\n(member->dsp == dsp) ? " *this*" : "");\r\n}\r\n}\r\nprintk(KERN_DEBUG "-----end\n");\r\n}\r\nstatic struct dsp_conf *\r\ndsp_cmx_search_conf(u32 id)\r\n{\r\nstruct dsp_conf *conf;\r\nif (!id) {\r\nprintk(KERN_WARNING "%s: conference ID is 0.\n", __func__);\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(conf, &conf_ilist, list)\r\nif (conf->id == id)\r\nreturn conf;\r\nreturn NULL;\r\n}\r\nstatic int\r\ndsp_cmx_add_conf_member(struct dsp *dsp, struct dsp_conf *conf)\r\n{\r\nstruct dsp_conf_member *member;\r\nif (!conf || !dsp) {\r\nprintk(KERN_WARNING "%s: conf or dsp is 0.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (dsp->member) {\r\nprintk(KERN_WARNING "%s: dsp is already member in a conf.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (dsp->conf) {\r\nprintk(KERN_WARNING "%s: dsp is already in a conf.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nmember = kzalloc(sizeof(struct dsp_conf_member), GFP_ATOMIC);\r\nif (!member) {\r\nprintk(KERN_ERR "kzalloc struct dsp_conf_member failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmember->dsp = dsp;\r\nmemset(dsp->rx_buff, dsp_silence, sizeof(dsp->rx_buff));\r\ndsp->rx_init = 1;\r\ndsp->rx_W = 0;\r\ndsp->rx_R = 0;\r\nlist_add_tail(&member->list, &conf->mlist);\r\ndsp->conf = conf;\r\ndsp->member = member;\r\nreturn 0;\r\n}\r\nint\r\ndsp_cmx_del_conf_member(struct dsp *dsp)\r\n{\r\nstruct dsp_conf_member *member;\r\nif (!dsp) {\r\nprintk(KERN_WARNING "%s: dsp is 0.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (!dsp->conf) {\r\nprintk(KERN_WARNING "%s: dsp is not in a conf.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (list_empty(&dsp->conf->mlist)) {\r\nprintk(KERN_WARNING "%s: dsp has linked an empty conf.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(member, &dsp->conf->mlist, list) {\r\nif (member->dsp == dsp) {\r\nlist_del(&member->list);\r\ndsp->conf = NULL;\r\ndsp->member = NULL;\r\nkfree(member);\r\nreturn 0;\r\n}\r\n}\r\nprintk(KERN_WARNING\r\n"%s: dsp is not present in its own conf_meber list.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nstatic struct dsp_conf\r\n*dsp_cmx_new_conf(u32 id)\r\n{\r\nstruct dsp_conf *conf;\r\nif (!id) {\r\nprintk(KERN_WARNING "%s: id is 0.\n",\r\n__func__);\r\nreturn NULL;\r\n}\r\nconf = kzalloc(sizeof(struct dsp_conf), GFP_ATOMIC);\r\nif (!conf) {\r\nprintk(KERN_ERR "kzalloc struct dsp_conf failed\n");\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&conf->mlist);\r\nconf->id = id;\r\nlist_add_tail(&conf->list, &conf_ilist);\r\nreturn conf;\r\n}\r\nint\r\ndsp_cmx_del_conf(struct dsp_conf *conf)\r\n{\r\nif (!conf) {\r\nprintk(KERN_WARNING "%s: conf is null.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (!list_empty(&conf->mlist)) {\r\nprintk(KERN_WARNING "%s: conf not empty.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nlist_del(&conf->list);\r\nkfree(conf);\r\nreturn 0;\r\n}\r\nstatic void\r\ndsp_cmx_hw_message(struct dsp *dsp, u32 message, u32 param1, u32 param2,\r\nu32 param3, u32 param4)\r\n{\r\nstruct mISDN_ctrl_req cq;\r\nmemset(&cq, 0, sizeof(cq));\r\ncq.op = message;\r\ncq.p1 = param1 | (param2 << 8);\r\ncq.p2 = param3 | (param4 << 8);\r\nif (dsp->ch.peer)\r\ndsp->ch.peer->ctrl(dsp->ch.peer, CONTROL_CHANNEL, &cq);\r\n}\r\nvoid\r\ndsp_cmx_hardware(struct dsp_conf *conf, struct dsp *dsp)\r\n{\r\nstruct dsp_conf_member *member, *nextm;\r\nstruct dsp *finddsp;\r\nint memb = 0, i, ii, i1, i2;\r\nint freeunits[8];\r\nu_char freeslots[256];\r\nint same_hfc = -1, same_pcm = -1, current_conf = -1,\r\nall_conf = 1, tx_data = 0;\r\nif (!conf) {\r\nif (!dsp)\r\nreturn;\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG "%s checking dsp %s\n",\r\n__func__, dsp->name);\r\none_member:\r\nif (dsp->hfc_conf >= 0) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s removing %s from HFC conf %d "\r\n"because dsp is split\n", __func__,\r\ndsp->name, dsp->hfc_conf);\r\ndsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_CONF_SPLIT,\r\n0, 0, 0, 0);\r\ndsp->hfc_conf = -1;\r\n}\r\nif (dsp->features.pcm_banks < 1)\r\nreturn;\r\nif (!dsp->echo.software && !dsp->echo.hardware) {\r\nif (dsp->pcm_slot_tx >= 0 || dsp->pcm_slot_rx >= 0) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG "%s removing %s from"\r\n" PCM slot %d (TX) %d (RX) because"\r\n" dsp is split (no echo)\n",\r\n__func__, dsp->name,\r\ndsp->pcm_slot_tx, dsp->pcm_slot_rx);\r\ndsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_PCM_DISC,\r\n0, 0, 0, 0);\r\ndsp->pcm_slot_tx = -1;\r\ndsp->pcm_bank_tx = -1;\r\ndsp->pcm_slot_rx = -1;\r\ndsp->pcm_bank_rx = -1;\r\n}\r\nreturn;\r\n}\r\ndsp->echo.software = dsp->tx_data;\r\ndsp->echo.hardware = 0;\r\nif (dsp->pcm_slot_tx >= 0 && dsp->pcm_slot_rx < 0 &&\r\ndsp->pcm_bank_tx == 2 && dsp->pcm_bank_rx == 2) {\r\ndsp->echo.hardware = 1;\r\nreturn;\r\n}\r\nif (dsp->pcm_slot_tx >= 0) {\r\ndsp->pcm_slot_rx = dsp->pcm_slot_tx;\r\ndsp->pcm_bank_tx = 2;\r\ndsp->pcm_bank_rx = 2;\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s refresh %s for echo using slot %d\n",\r\n__func__, dsp->name,\r\ndsp->pcm_slot_tx);\r\ndsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_PCM_CONN,\r\ndsp->pcm_slot_tx, 2, dsp->pcm_slot_rx, 2);\r\ndsp->echo.hardware = 1;\r\nreturn;\r\n}\r\ndsp->pcm_slot_tx = -1;\r\ndsp->pcm_slot_rx = -1;\r\nmemset(freeslots, 1, sizeof(freeslots));\r\nlist_for_each_entry(finddsp, &dsp_ilist, list) {\r\nif (finddsp->features.pcm_id == dsp->features.pcm_id) {\r\nif (finddsp->pcm_slot_rx >= 0 &&\r\nfinddsp->pcm_slot_rx < sizeof(freeslots))\r\nfreeslots[finddsp->pcm_slot_rx] = 0;\r\nif (finddsp->pcm_slot_tx >= 0 &&\r\nfinddsp->pcm_slot_tx < sizeof(freeslots))\r\nfreeslots[finddsp->pcm_slot_tx] = 0;\r\n}\r\n}\r\ni = 0;\r\nii = dsp->features.pcm_slots;\r\nwhile (i < ii) {\r\nif (freeslots[i])\r\nbreak;\r\ni++;\r\n}\r\nif (i == ii) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s no slot available for echo\n",\r\n__func__);\r\ndsp->echo.software = 1;\r\nreturn;\r\n}\r\ndsp->pcm_slot_tx = i;\r\ndsp->pcm_slot_rx = i;\r\ndsp->pcm_bank_tx = 2;\r\ndsp->pcm_bank_rx = 2;\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s assign echo for %s using slot %d\n",\r\n__func__, dsp->name, dsp->pcm_slot_tx);\r\ndsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_PCM_CONN,\r\ndsp->pcm_slot_tx, 2, dsp->pcm_slot_rx, 2);\r\ndsp->echo.hardware = 1;\r\nreturn;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG "%s checking conference %d\n",\r\n__func__, conf->id);\r\nif (list_empty(&conf->mlist)) {\r\nprintk(KERN_ERR "%s: conference whithout members\n",\r\n__func__);\r\nreturn;\r\n}\r\nmember = list_entry(conf->mlist.next, struct dsp_conf_member, list);\r\nsame_hfc = member->dsp->features.hfc_id;\r\nsame_pcm = member->dsp->features.pcm_id;\r\nlist_for_each_entry(member, &conf->mlist, list) {\r\nif (member->dsp->tx_mix) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s cannot form a conf, because "\r\n"tx_mix is turned on\n", __func__,\r\nmember->dsp->name);\r\nconf_software:\r\nlist_for_each_entry(member, &conf->mlist, list) {\r\ndsp = member->dsp;\r\nif (dsp->hfc_conf >= 0) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s removing %s from HFC "\r\n"conf %d because not "\r\n"possible with hardware\n",\r\n__func__,\r\ndsp->name,\r\ndsp->hfc_conf);\r\ndsp_cmx_hw_message(dsp,\r\nMISDN_CTRL_HFC_CONF_SPLIT,\r\n0, 0, 0, 0);\r\ndsp->hfc_conf = -1;\r\n}\r\nif (dsp->pcm_slot_tx >= 0 ||\r\ndsp->pcm_slot_rx >= 0) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG "%s removing "\r\n"%s from PCM slot %d (TX)"\r\n" slot %d (RX) because not"\r\n" possible with hardware\n",\r\n__func__,\r\ndsp->name,\r\ndsp->pcm_slot_tx,\r\ndsp->pcm_slot_rx);\r\ndsp_cmx_hw_message(dsp,\r\nMISDN_CTRL_HFC_PCM_DISC,\r\n0, 0, 0, 0);\r\ndsp->pcm_slot_tx = -1;\r\ndsp->pcm_bank_tx = -1;\r\ndsp->pcm_slot_rx = -1;\r\ndsp->pcm_bank_rx = -1;\r\n}\r\n}\r\nconf->hardware = 0;\r\nconf->software = 1;\r\nreturn;\r\n}\r\nif (member->dsp->echo.hardware || member->dsp->echo.software) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s cannot form a conf, because "\r\n"echo is turned on\n", __func__,\r\nmember->dsp->name);\r\ngoto conf_software;\r\n}\r\nif (member->dsp->tx_mix) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s cannot form a conf, because "\r\n"tx_mix is turned on\n",\r\n__func__, member->dsp->name);\r\ngoto conf_software;\r\n}\r\nif (member->dsp->tx_volume) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s cannot form a conf, because "\r\n"tx_volume is changed\n",\r\n__func__, member->dsp->name);\r\ngoto conf_software;\r\n}\r\nif (member->dsp->rx_volume) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s cannot form a conf, because "\r\n"rx_volume is changed\n",\r\n__func__, member->dsp->name);\r\ngoto conf_software;\r\n}\r\nif (member->dsp->tx_data) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s tx_data is turned on\n",\r\n__func__, member->dsp->name);\r\ntx_data = 1;\r\n}\r\nif (member->dsp->pipeline.inuse) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s cannot form a conf, because "\r\n"pipeline exists\n", __func__,\r\nmember->dsp->name);\r\ngoto conf_software;\r\n}\r\nif (member->dsp->bf_enable) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG "%s dsp %s cannot form a "\r\n"conf, because encryption is enabled\n",\r\n__func__, member->dsp->name);\r\ngoto conf_software;\r\n}\r\nif (member->dsp->features.pcm_id < 0) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s cannot form a conf, because "\r\n"dsp has no PCM bus\n",\r\n__func__, member->dsp->name);\r\ngoto conf_software;\r\n}\r\nif (member->dsp->features.pcm_id != same_pcm) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s cannot form a conf, because "\r\n"dsp is on a different PCM bus than the "\r\n"first dsp\n",\r\n__func__, member->dsp->name);\r\ngoto conf_software;\r\n}\r\nif (same_hfc != member->dsp->features.hfc_id)\r\nsame_hfc = -1;\r\nif (current_conf < 0 && member->dsp->hfc_conf >= 0)\r\ncurrent_conf = member->dsp->hfc_conf;\r\nif (member->dsp->hfc_conf < 0)\r\nall_conf = 0;\r\nmemb++;\r\n}\r\nif (memb < 1)\r\nreturn;\r\nif (memb == 1) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s conf %d cannot form a HW conference, "\r\n"because dsp is alone\n", __func__, conf->id);\r\nconf->hardware = 0;\r\nconf->software = 0;\r\nmember = list_entry(conf->mlist.next, struct dsp_conf_member,\r\nlist);\r\ndsp = member->dsp;\r\ngoto one_member;\r\n}\r\nif (memb == 2) {\r\nmember = list_entry(conf->mlist.next, struct dsp_conf_member,\r\nlist);\r\nnextm = list_entry(member->list.next, struct dsp_conf_member,\r\nlist);\r\nif (member->dsp->hfc_conf >= 0) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s removing %s from HFC conf %d because "\r\n"two parties require only a PCM slot\n",\r\n__func__, member->dsp->name,\r\nmember->dsp->hfc_conf);\r\ndsp_cmx_hw_message(member->dsp,\r\nMISDN_CTRL_HFC_CONF_SPLIT, 0, 0, 0, 0);\r\nmember->dsp->hfc_conf = -1;\r\n}\r\nif (nextm->dsp->hfc_conf >= 0) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s removing %s from HFC conf %d because "\r\n"two parties require only a PCM slot\n",\r\n__func__, nextm->dsp->name,\r\nnextm->dsp->hfc_conf);\r\ndsp_cmx_hw_message(nextm->dsp,\r\nMISDN_CTRL_HFC_CONF_SPLIT, 0, 0, 0, 0);\r\nnextm->dsp->hfc_conf = -1;\r\n}\r\nif (member->dsp->features.pcm_banks > 1 &&\r\nnextm->dsp->features.pcm_banks > 1 &&\r\nmember->dsp->features.hfc_id !=\r\nnextm->dsp->features.hfc_id) {\r\nif (member->dsp->pcm_slot_tx >= 0 &&\r\nmember->dsp->pcm_slot_rx >= 0 &&\r\nnextm->dsp->pcm_slot_tx >= 0 &&\r\nnextm->dsp->pcm_slot_rx >= 0 &&\r\nnextm->dsp->pcm_slot_tx ==\r\nmember->dsp->pcm_slot_rx &&\r\nnextm->dsp->pcm_slot_rx ==\r\nmember->dsp->pcm_slot_tx &&\r\nnextm->dsp->pcm_slot_tx ==\r\nmember->dsp->pcm_slot_tx &&\r\nmember->dsp->pcm_bank_tx !=\r\nmember->dsp->pcm_bank_rx &&\r\nnextm->dsp->pcm_bank_tx !=\r\nnextm->dsp->pcm_bank_rx) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s & %s stay joined on "\r\n"PCM slot %d bank %d (TX) bank %d "\r\n"(RX) (on different chips)\n",\r\n__func__,\r\nmember->dsp->name,\r\nnextm->dsp->name,\r\nmember->dsp->pcm_slot_tx,\r\nmember->dsp->pcm_bank_tx,\r\nmember->dsp->pcm_bank_rx);\r\nconf->hardware = 1;\r\nconf->software = tx_data;\r\nreturn;\r\n}\r\nmemset(freeslots, 1, sizeof(freeslots));\r\nlist_for_each_entry(dsp, &dsp_ilist, list) {\r\nif (dsp != member->dsp &&\r\ndsp != nextm->dsp &&\r\nmember->dsp->features.pcm_id ==\r\ndsp->features.pcm_id) {\r\nif (dsp->pcm_slot_rx >= 0 &&\r\ndsp->pcm_slot_rx <\r\nsizeof(freeslots))\r\nfreeslots[dsp->pcm_slot_rx] = 0;\r\nif (dsp->pcm_slot_tx >= 0 &&\r\ndsp->pcm_slot_tx <\r\nsizeof(freeslots))\r\nfreeslots[dsp->pcm_slot_tx] = 0;\r\n}\r\n}\r\ni = 0;\r\nii = member->dsp->features.pcm_slots;\r\nwhile (i < ii) {\r\nif (freeslots[i])\r\nbreak;\r\ni++;\r\n}\r\nif (i == ii) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s no slot available for "\r\n"%s & %s\n", __func__,\r\nmember->dsp->name,\r\nnextm->dsp->name);\r\ngoto conf_software;\r\n}\r\nmember->dsp->pcm_slot_tx = i;\r\nmember->dsp->pcm_slot_rx = i;\r\nnextm->dsp->pcm_slot_tx = i;\r\nnextm->dsp->pcm_slot_rx = i;\r\nmember->dsp->pcm_bank_rx = 0;\r\nmember->dsp->pcm_bank_tx = 1;\r\nnextm->dsp->pcm_bank_rx = 1;\r\nnextm->dsp->pcm_bank_tx = 0;\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s adding %s & %s to new PCM slot %d "\r\n"(TX and RX on different chips) because "\r\n"both members have not same slots\n",\r\n__func__,\r\nmember->dsp->name,\r\nnextm->dsp->name,\r\nmember->dsp->pcm_slot_tx);\r\ndsp_cmx_hw_message(member->dsp, MISDN_CTRL_HFC_PCM_CONN,\r\nmember->dsp->pcm_slot_tx, member->dsp->pcm_bank_tx,\r\nmember->dsp->pcm_slot_rx, member->dsp->pcm_bank_rx);\r\ndsp_cmx_hw_message(nextm->dsp, MISDN_CTRL_HFC_PCM_CONN,\r\nnextm->dsp->pcm_slot_tx, nextm->dsp->pcm_bank_tx,\r\nnextm->dsp->pcm_slot_rx, nextm->dsp->pcm_bank_rx);\r\nconf->hardware = 1;\r\nconf->software = tx_data;\r\nreturn;\r\n} else {\r\nif (member->dsp->pcm_slot_tx >= 0 &&\r\nmember->dsp->pcm_slot_rx >= 0 &&\r\nnextm->dsp->pcm_slot_tx >= 0 &&\r\nnextm->dsp->pcm_slot_rx >= 0 &&\r\nnextm->dsp->pcm_slot_tx ==\r\nmember->dsp->pcm_slot_rx &&\r\nnextm->dsp->pcm_slot_rx ==\r\nmember->dsp->pcm_slot_tx &&\r\nmember->dsp->pcm_slot_tx !=\r\nmember->dsp->pcm_slot_rx &&\r\nmember->dsp->pcm_bank_tx == 0 &&\r\nmember->dsp->pcm_bank_rx == 0 &&\r\nnextm->dsp->pcm_bank_tx == 0 &&\r\nnextm->dsp->pcm_bank_rx == 0) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s dsp %s & %s stay joined on PCM "\r\n"slot %d (TX) %d (RX) on same chip "\r\n"or one bank PCM)\n", __func__,\r\nmember->dsp->name,\r\nnextm->dsp->name,\r\nmember->dsp->pcm_slot_tx,\r\nmember->dsp->pcm_slot_rx);\r\nconf->hardware = 1;\r\nconf->software = tx_data;\r\nreturn;\r\n}\r\nmemset(freeslots, 1, sizeof(freeslots));\r\nlist_for_each_entry(dsp, &dsp_ilist, list) {\r\nif (dsp != member->dsp &&\r\ndsp != nextm->dsp &&\r\nmember->dsp->features.pcm_id ==\r\ndsp->features.pcm_id) {\r\nif (dsp->pcm_slot_rx >= 0 &&\r\ndsp->pcm_slot_rx <\r\nsizeof(freeslots))\r\nfreeslots[dsp->pcm_slot_rx] = 0;\r\nif (dsp->pcm_slot_tx >= 0 &&\r\ndsp->pcm_slot_tx <\r\nsizeof(freeslots))\r\nfreeslots[dsp->pcm_slot_tx] = 0;\r\n}\r\n}\r\ni1 = 0;\r\nii = member->dsp->features.pcm_slots;\r\nwhile (i1 < ii) {\r\nif (freeslots[i1])\r\nbreak;\r\ni1++;\r\n}\r\nif (i1 == ii) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s no slot available "\r\n"for %s & %s\n", __func__,\r\nmember->dsp->name,\r\nnextm->dsp->name);\r\ngoto conf_software;\r\n}\r\ni2 = i1 + 1;\r\nwhile (i2 < ii) {\r\nif (freeslots[i2])\r\nbreak;\r\ni2++;\r\n}\r\nif (i2 == ii) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s no slot available "\r\n"for %s & %s\n",\r\n__func__,\r\nmember->dsp->name,\r\nnextm->dsp->name);\r\ngoto conf_software;\r\n}\r\nmember->dsp->pcm_slot_tx = i1;\r\nmember->dsp->pcm_slot_rx = i2;\r\nnextm->dsp->pcm_slot_tx = i2;\r\nnextm->dsp->pcm_slot_rx = i1;\r\nmember->dsp->pcm_bank_rx = 0;\r\nmember->dsp->pcm_bank_tx = 0;\r\nnextm->dsp->pcm_bank_rx = 0;\r\nnextm->dsp->pcm_bank_tx = 0;\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s adding %s & %s to new PCM slot %d "\r\n"(TX) %d (RX) on same chip or one bank "\r\n"PCM, because both members have not "\r\n"crossed slots\n", __func__,\r\nmember->dsp->name,\r\nnextm->dsp->name,\r\nmember->dsp->pcm_slot_tx,\r\nmember->dsp->pcm_slot_rx);\r\ndsp_cmx_hw_message(member->dsp, MISDN_CTRL_HFC_PCM_CONN,\r\nmember->dsp->pcm_slot_tx, member->dsp->pcm_bank_tx,\r\nmember->dsp->pcm_slot_rx, member->dsp->pcm_bank_rx);\r\ndsp_cmx_hw_message(nextm->dsp, MISDN_CTRL_HFC_PCM_CONN,\r\nnextm->dsp->pcm_slot_tx, nextm->dsp->pcm_bank_tx,\r\nnextm->dsp->pcm_slot_rx, nextm->dsp->pcm_bank_rx);\r\nconf->hardware = 1;\r\nconf->software = tx_data;\r\nreturn;\r\n}\r\n}\r\nif (same_hfc < 0) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s conference %d cannot be formed, because "\r\n"members are on different chips or not "\r\n"on HFC chip\n",\r\n__func__, conf->id);\r\ngoto conf_software;\r\n}\r\nif (all_conf) {\r\nconf->hardware = 1;\r\nconf->software = tx_data;\r\nreturn;\r\n}\r\nif (current_conf >= 0) {\r\njoin_members:\r\nlist_for_each_entry(member, &conf->mlist, list) {\r\nif (!member->dsp->features.hfc_conf)\r\ngoto conf_software;\r\nif (member->dsp->hdlc)\r\ngoto conf_software;\r\nif (member->dsp->hfc_conf == current_conf)\r\ncontinue;\r\nmemset(freeslots, 1, sizeof(freeslots));\r\nlist_for_each_entry(dsp, &dsp_ilist, list) {\r\nif (\r\ndsp != member->dsp &&\r\nmember->dsp->features.pcm_id ==\r\ndsp->features.pcm_id) {\r\nif (dsp->pcm_slot_tx >= 0 &&\r\ndsp->pcm_slot_tx <\r\nsizeof(freeslots))\r\nfreeslots[dsp->pcm_slot_tx] = 0;\r\nif (dsp->pcm_slot_rx >= 0 &&\r\ndsp->pcm_slot_rx <\r\nsizeof(freeslots))\r\nfreeslots[dsp->pcm_slot_rx] = 0;\r\n}\r\n}\r\ni = 0;\r\nii = member->dsp->features.pcm_slots;\r\nwhile (i < ii) {\r\nif (freeslots[i])\r\nbreak;\r\ni++;\r\n}\r\nif (i == ii) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s conference %d cannot be formed,"\r\n" because no slot free\n",\r\n__func__, conf->id);\r\ngoto conf_software;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s changing dsp %s to HW conference "\r\n"%d slot %d\n", __func__,\r\nmember->dsp->name, current_conf, i);\r\nmember->dsp->pcm_slot_tx = i;\r\nmember->dsp->pcm_slot_rx = i;\r\nmember->dsp->pcm_bank_tx = 2;\r\nmember->dsp->pcm_bank_rx = 2;\r\nmember->dsp->hfc_conf = current_conf;\r\ndsp_cmx_hw_message(member->dsp, MISDN_CTRL_HFC_PCM_CONN,\r\ni, 2, i, 2);\r\ndsp_cmx_hw_message(member->dsp,\r\nMISDN_CTRL_HFC_CONF_JOIN, current_conf, 0, 0, 0);\r\n}\r\nconf->hardware = 1;\r\nconf->software = tx_data;\r\nreturn;\r\n}\r\nmemset(freeunits, 1, sizeof(freeunits));\r\nlist_for_each_entry(dsp, &dsp_ilist, list) {\r\nif (dsp->features.hfc_id == same_hfc &&\r\ndsp->hfc_conf >= 0 &&\r\ndsp->hfc_conf < 8)\r\nfreeunits[dsp->hfc_conf] = 0;\r\n}\r\ni = 0;\r\nii = 8;\r\nwhile (i < ii) {\r\nif (freeunits[i])\r\nbreak;\r\ni++;\r\n}\r\nif (i == ii) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"%s conference %d cannot be formed, because "\r\n"no conference number free\n",\r\n__func__, conf->id);\r\ngoto conf_software;\r\n}\r\ncurrent_conf = i;\r\ngoto join_members;\r\n}\r\nint\r\ndsp_cmx_conf(struct dsp *dsp, u32 conf_id)\r\n{\r\nint err;\r\nstruct dsp_conf *conf;\r\nstruct dsp_conf_member *member;\r\nif (dsp->conf_id == conf_id)\r\nreturn 0;\r\nif (dsp->conf_id) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG "removing us from conference %d\n",\r\ndsp->conf->id);\r\nconf = dsp->conf;\r\nerr = dsp_cmx_del_conf_member(dsp);\r\nif (err)\r\nreturn err;\r\ndsp->conf_id = 0;\r\ndsp_cmx_hardware(NULL, dsp);\r\nif (list_empty(&conf->mlist)) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"conference is empty, so we remove it.\n");\r\nerr = dsp_cmx_del_conf(conf);\r\nif (err)\r\nreturn err;\r\n} else {\r\ndsp_cmx_hardware(conf, NULL);\r\n}\r\n}\r\nif (!conf_id)\r\nreturn 0;\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG "searching conference %d\n",\r\nconf_id);\r\nconf = dsp_cmx_search_conf(conf_id);\r\nif (!conf) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"conference doesn't exist yet, creating.\n");\r\nconf = dsp_cmx_new_conf(conf_id);\r\nif (!conf)\r\nreturn -EINVAL;\r\n} else if (!list_empty(&conf->mlist)) {\r\nmember = list_entry(conf->mlist.next, struct dsp_conf_member,\r\nlist);\r\nif (dsp->hdlc && !member->dsp->hdlc) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"cannot join transparent conference.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!dsp->hdlc && member->dsp->hdlc) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"cannot join hdlc conference.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nerr = dsp_cmx_add_conf_member(dsp, conf);\r\nif (err)\r\nreturn err;\r\ndsp->conf_id = conf_id;\r\nif (list_empty(&conf->mlist)) {\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\nprintk(KERN_DEBUG\r\n"we are alone in this conference, so exit.\n");\r\ndsp_cmx_hardware(NULL, dsp);\r\nreturn 0;\r\n}\r\ndsp_cmx_hardware(conf, NULL);\r\nreturn 0;\r\n}\r\nstatic void\r\nshowdelay(struct dsp *dsp, int samples, int delay)\r\n{\r\nchar bar[] = "--------------------------------------------------|";\r\nint sdelay;\r\ndelaycount += samples;\r\nif (delaycount < 8000)\r\nreturn;\r\ndelaycount = 0;\r\nsdelay = delay * 50 / (dsp_poll << 2);\r\nprintk(KERN_DEBUG "DELAY (%s) %3d >%s\n", dsp->name, delay,\r\nsdelay > 50 ? "..." : bar + 50 - sdelay);\r\n}\r\nvoid\r\ndsp_cmx_receive(struct dsp *dsp, struct sk_buff *skb)\r\n{\r\nu8 *d, *p;\r\nint len = skb->len;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nint w, i, ii;\r\nif (len < 1)\r\nreturn;\r\nif (len >= CMX_BUFF_HALF) {\r\nprintk(KERN_ERR\r\n"%s line %d: packet from card is too large (%d bytes). "\r\n"please make card send smaller packets OR increase "\r\n"CMX_BUFF_SIZE\n", __FILE__, __LINE__, len);\r\nreturn;\r\n}\r\nif (dsp->rx_init) {\r\ndsp->rx_init = 0;\r\nif (dsp->features.unordered) {\r\ndsp->rx_R = (hh->id & CMX_BUFF_MASK);\r\nif (dsp->cmx_delay)\r\ndsp->rx_W = (dsp->rx_R + dsp->cmx_delay)\r\n& CMX_BUFF_MASK;\r\nelse\r\ndsp->rx_W = (dsp->rx_R + (dsp_poll >> 1))\r\n& CMX_BUFF_MASK;\r\n} else {\r\ndsp->rx_R = 0;\r\nif (dsp->cmx_delay)\r\ndsp->rx_W = dsp->cmx_delay;\r\nelse\r\ndsp->rx_W = dsp_poll >> 1;\r\n}\r\n}\r\nif (dsp->features.unordered) {\r\ndsp->rx_W = (hh->id & CMX_BUFF_MASK);\r\n}\r\nif (((dsp->rx_W-dsp->rx_R) & CMX_BUFF_MASK) >= CMX_BUFF_HALF) {\r\nif (dsp_debug & DEBUG_DSP_CLOCK)\r\nprintk(KERN_DEBUG\r\n"cmx_receive(dsp=%lx): UNDERRUN (or overrun the "\r\n"maximum delay), adjusting read pointer! "\r\n"(inst %s)\n", (u_long)dsp, dsp->name);\r\nif (dsp->features.unordered) {\r\ndsp->rx_R = (hh->id & CMX_BUFF_MASK);\r\nif (dsp->cmx_delay)\r\ndsp->rx_W = (dsp->rx_R + dsp->cmx_delay)\r\n& CMX_BUFF_MASK;\r\nelse\r\ndsp->rx_W = (dsp->rx_R + (dsp_poll >> 1))\r\n& CMX_BUFF_MASK;\r\n} else {\r\ndsp->rx_R = 0;\r\nif (dsp->cmx_delay)\r\ndsp->rx_W = dsp->cmx_delay;\r\nelse\r\ndsp->rx_W = dsp_poll >> 1;\r\n}\r\nmemset(dsp->rx_buff, dsp_silence, sizeof(dsp->rx_buff));\r\n}\r\nif (dsp->cmx_delay)\r\nif (((dsp->rx_W - dsp->rx_R) & CMX_BUFF_MASK) >=\r\n(dsp->cmx_delay << 1)) {\r\nif (dsp_debug & DEBUG_DSP_CLOCK)\r\nprintk(KERN_DEBUG\r\n"cmx_receive(dsp=%lx): OVERRUN (because "\r\n"twice the delay is reached), adjusting "\r\n"read pointer! (inst %s)\n",\r\n(u_long)dsp, dsp->name);\r\nif (dsp->features.unordered) {\r\ndsp->rx_R = (hh->id & CMX_BUFF_MASK);\r\ndsp->rx_W = (dsp->rx_R + dsp->cmx_delay)\r\n& CMX_BUFF_MASK;\r\n} else {\r\ndsp->rx_R = 0;\r\ndsp->rx_W = dsp->cmx_delay;\r\n}\r\nmemset(dsp->rx_buff, dsp_silence, sizeof(dsp->rx_buff));\r\n}\r\n#ifdef CMX_DEBUG\r\nprintk(KERN_DEBUG\r\n"cmx_receive(dsp=%lx): rx_R(dsp)=%05x rx_W(dsp)=%05x len=%d %s\n",\r\n(u_long)dsp, dsp->rx_R, dsp->rx_W, len, dsp->name);\r\n#endif\r\np = skb->data;\r\nd = dsp->rx_buff;\r\nw = dsp->rx_W;\r\ni = 0;\r\nii = len;\r\nwhile (i < ii) {\r\nd[w++ & CMX_BUFF_MASK] = *p++;\r\ni++;\r\n}\r\ndsp->rx_W = ((dsp->rx_W + len) & CMX_BUFF_MASK);\r\n#ifdef CMX_DELAY_DEBUG\r\nshowdelay(dsp, len, (dsp->rx_W-dsp->rx_R) & CMX_BUFF_MASK);\r\n#endif\r\n}\r\nstatic void\r\ndsp_cmx_send_member(struct dsp *dsp, int len, s32 *c, int members)\r\n{\r\nstruct dsp_conf *conf = dsp->conf;\r\nstruct dsp *member, *other;\r\nregister s32 sample;\r\nu8 *d, *p, *q, *o_q;\r\nstruct sk_buff *nskb, *txskb;\r\nint r, rr, t, tt, o_r, o_rr;\r\nint preload = 0;\r\nstruct mISDNhead *hh, *thh;\r\nint tx_data_only = 0;\r\nif (!dsp->b_active) {\r\ndsp->last_tx = 0;\r\nreturn;\r\n}\r\nif (((dsp->conf && dsp->conf->hardware) ||\r\ndsp->echo.hardware) &&\r\ndsp->tx_R == dsp->tx_W &&\r\n!(dsp->tone.tone && dsp->tone.software)) {\r\nif (!dsp->tx_data) {\r\ndsp->last_tx = 0;\r\nreturn;\r\n}\r\nif (dsp->conf && dsp->conf->software && dsp->conf->hardware)\r\ntx_data_only = 1;\r\nif (dsp->echo.software && dsp->echo.hardware)\r\ntx_data_only = 1;\r\n}\r\n#ifdef CMX_DEBUG\r\nprintk(KERN_DEBUG\r\n"SEND members=%d dsp=%s, conf=%p, rx_R=%05x rx_W=%05x\n",\r\nmembers, dsp->name, conf, dsp->rx_R, dsp->rx_W);\r\n#endif\r\nif (dsp->cmx_delay && !dsp->last_tx) {\r\npreload = len;\r\nif (preload < 128)\r\npreload = 128;\r\n}\r\nnskb = mI_alloc_skb(len + preload, GFP_ATOMIC);\r\nif (!nskb) {\r\nprintk(KERN_ERR\r\n"FATAL ERROR in mISDN_dsp.o: cannot alloc %d bytes\n",\r\nlen + preload);\r\nreturn;\r\n}\r\nhh = mISDN_HEAD_P(nskb);\r\nhh->prim = PH_DATA_REQ;\r\nhh->id = 0;\r\ndsp->last_tx = 1;\r\nmember = dsp;\r\np = dsp->tx_buff;\r\nq = dsp->rx_buff;\r\nd = skb_put(nskb, preload + len);\r\nt = dsp->tx_R;\r\ntt = dsp->tx_W;\r\nr = dsp->rx_R;\r\nrr = (r + len) & CMX_BUFF_MASK;\r\nif (preload) {\r\nmemset(d, dsp_silence, preload);\r\nd += preload;\r\n}\r\nif (dsp->tone.tone && dsp->tone.software) {\r\ndsp_tone_copy(dsp, d, len);\r\ndsp->tx_R = 0;\r\ndsp->tx_W = 0;\r\ngoto send_packet;\r\n}\r\nif (!dsp->tx_mix && t != tt) {\r\n#ifdef CMX_TX_DEBUG\r\nsprintf(debugbuf, "TX sending (%04x-%04x)%p: ", t, tt, p);\r\n#endif\r\nwhile (r != rr && t != tt) {\r\n#ifdef CMX_TX_DEBUG\r\nif (strlen(debugbuf) < 48)\r\nsprintf(debugbuf + strlen(debugbuf), " %02x",\r\np[t]);\r\n#endif\r\n*d++ = p[t];\r\nt = (t + 1) & CMX_BUFF_MASK;\r\nr = (r + 1) & CMX_BUFF_MASK;\r\n}\r\nif (r == rr) {\r\ndsp->tx_R = t;\r\n#ifdef CMX_TX_DEBUG\r\nprintk(KERN_DEBUG "%s\n", debugbuf);\r\n#endif\r\ngoto send_packet;\r\n}\r\n}\r\n#ifdef CMX_TX_DEBUG\r\nprintk(KERN_DEBUG "%s\n", debugbuf);\r\n#endif\r\nif (!conf || members <= 1) {\r\nif (!dsp->echo.software) {\r\nwhile (r != rr && t != tt) {\r\n*d++ = p[t];\r\nt = (t + 1) & CMX_BUFF_MASK;\r\nr = (r + 1) & CMX_BUFF_MASK;\r\n}\r\nif (r != rr) {\r\nif (dsp_debug & DEBUG_DSP_CLOCK)\r\nprintk(KERN_DEBUG "%s: RX empty\n",\r\n__func__);\r\nmemset(d, dsp_silence, (rr - r) & CMX_BUFF_MASK);\r\n}\r\n} else {\r\nwhile (r != rr && t != tt) {\r\n*d++ = dsp_audio_mix_law[(p[t] << 8) | q[r]];\r\nt = (t + 1) & CMX_BUFF_MASK;\r\nr = (r + 1) & CMX_BUFF_MASK;\r\n}\r\nwhile (r != rr) {\r\n*d++ = q[r];\r\nr = (r + 1) & CMX_BUFF_MASK;\r\n}\r\n}\r\ndsp->tx_R = t;\r\ngoto send_packet;\r\n}\r\n#ifdef CMX_CONF_DEBUG\r\nif (0) {\r\n#else\r\nif (members == 2) {\r\n#endif\r\nother = (list_entry(conf->mlist.next,\r\nstruct dsp_conf_member, list))->dsp;\r\nif (other == member)\r\nother = (list_entry(conf->mlist.prev,\r\nstruct dsp_conf_member, list))->dsp;\r\no_q = other->rx_buff;\r\no_rr = (other->rx_R + len) & CMX_BUFF_MASK;\r\no_r = (o_rr - rr + r) & CMX_BUFF_MASK;\r\nif (!dsp->echo.software) {\r\nwhile (o_r != o_rr && t != tt) {\r\n*d++ = dsp_audio_mix_law[(p[t] << 8) | o_q[o_r]];\r\nt = (t + 1) & CMX_BUFF_MASK;\r\no_r = (o_r + 1) & CMX_BUFF_MASK;\r\n}\r\nwhile (o_r != o_rr) {\r\n*d++ = o_q[o_r];\r\no_r = (o_r + 1) & CMX_BUFF_MASK;\r\n}\r\n} else {\r\nwhile (r != rr && t != tt) {\r\nsample = dsp_audio_law_to_s32[p[t]] +\r\ndsp_audio_law_to_s32[q[r]] +\r\ndsp_audio_law_to_s32[o_q[o_r]];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\n*d++ = dsp_audio_s16_to_law[sample & 0xffff];\r\nt = (t + 1) & CMX_BUFF_MASK;\r\nr = (r + 1) & CMX_BUFF_MASK;\r\no_r = (o_r + 1) & CMX_BUFF_MASK;\r\n}\r\nwhile (r != rr) {\r\n*d++ = dsp_audio_mix_law[(q[r] << 8) | o_q[o_r]];\r\nr = (r + 1) & CMX_BUFF_MASK;\r\no_r = (o_r + 1) & CMX_BUFF_MASK;\r\n}\r\n}\r\ndsp->tx_R = t;\r\ngoto send_packet;\r\n}\r\n#ifdef DSP_NEVER_DEFINED\r\n}\r\n#endif\r\nif (!dsp->echo.software) {\r\nwhile (r != rr && t != tt) {\r\nsample = dsp_audio_law_to_s32[p[t]] + *c++ -\r\ndsp_audio_law_to_s32[q[r]];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\n*d++ = dsp_audio_s16_to_law[sample & 0xffff];\r\nr = (r + 1) & CMX_BUFF_MASK;\r\nt = (t + 1) & CMX_BUFF_MASK;\r\n}\r\nwhile (r != rr) {\r\nsample = *c++ - dsp_audio_law_to_s32[q[r]];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\n*d++ = dsp_audio_s16_to_law[sample & 0xffff];\r\nr = (r + 1) & CMX_BUFF_MASK;\r\n}\r\n} else {\r\nwhile (r != rr && t != tt) {\r\nsample = dsp_audio_law_to_s32[p[t]] + *c++;\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\n*d++ = dsp_audio_s16_to_law[sample & 0xffff];\r\nt = (t + 1) & CMX_BUFF_MASK;\r\nr = (r + 1) & CMX_BUFF_MASK;\r\n}\r\nwhile (r != rr) {\r\nsample = *c++;\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\n*d++ = dsp_audio_s16_to_law[sample & 0xffff];\r\nr = (r + 1) & CMX_BUFF_MASK;\r\n}\r\n}\r\ndsp->tx_R = t;\r\ngoto send_packet;\r\nsend_packet:\r\nif (dsp->tx_data) {\r\nif (tx_data_only) {\r\nhh->prim = DL_DATA_REQ;\r\nhh->id = 0;\r\nskb_queue_tail(&dsp->sendq, nskb);\r\nschedule_work(&dsp->workq);\r\nreturn;\r\n} else {\r\ntxskb = mI_alloc_skb(len, GFP_ATOMIC);\r\nif (!txskb) {\r\nprintk(KERN_ERR\r\n"FATAL ERROR in mISDN_dsp.o: "\r\n"cannot alloc %d bytes\n", len);\r\n} else {\r\nthh = mISDN_HEAD_P(txskb);\r\nthh->prim = DL_DATA_REQ;\r\nthh->id = 0;\r\nmemcpy(skb_put(txskb, len), nskb->data + preload,\r\nlen);\r\nskb_queue_tail(&dsp->sendq, txskb);\r\n}\r\n}\r\n}\r\nif (dsp->tx_volume)\r\ndsp_change_volume(nskb, dsp->tx_volume);\r\nif (dsp->pipeline.inuse)\r\ndsp_pipeline_process_tx(&dsp->pipeline, nskb->data,\r\nnskb->len);\r\nif (dsp->bf_enable)\r\ndsp_bf_encrypt(dsp, nskb->data, nskb->len);\r\nskb_queue_tail(&dsp->sendq, nskb);\r\nschedule_work(&dsp->workq);\r\n}\r\nvoid\r\ndsp_cmx_transmit(struct dsp *dsp, struct sk_buff *skb)\r\n{\r\nu_int w, ww;\r\nu8 *d, *p;\r\nint space;\r\n#ifdef CMX_TX_DEBUG\r\nchar debugbuf[256] = "";\r\n#endif\r\nw = dsp->tx_W;\r\nww = dsp->tx_R;\r\np = dsp->tx_buff;\r\nd = skb->data;\r\nspace = (ww - w - 1) & CMX_BUFF_MASK;\r\nif (space < skb->len) {\r\nww = (ww - 1) & CMX_BUFF_MASK;\r\nif (dsp_debug & DEBUG_DSP_CLOCK)\r\nprintk(KERN_DEBUG "%s: TX overflow space=%d skb->len="\r\n"%d, w=0x%04x, ww=0x%04x\n", __func__, space,\r\nskb->len, w, ww);\r\n} else\r\nww = (w + skb->len) & CMX_BUFF_MASK;\r\ndsp->tx_W = ww;\r\n#ifdef CMX_DEBUG\r\nprintk(KERN_DEBUG\r\n"cmx_transmit(dsp=%lx) %d bytes to 0x%x-0x%x. %s\n",\r\n(u_long)dsp, (ww - w) & CMX_BUFF_MASK, w, ww, dsp->name);\r\n#endif\r\n#ifdef CMX_TX_DEBUG\r\nsprintf(debugbuf, "TX getting (%04x-%04x)%p: ", w, ww, p);\r\n#endif\r\nwhile (w != ww) {\r\n#ifdef CMX_TX_DEBUG\r\nif (strlen(debugbuf) < 48)\r\nsprintf(debugbuf + strlen(debugbuf), " %02x", *d);\r\n#endif\r\np[w] = *d++;\r\nw = (w + 1) & CMX_BUFF_MASK;\r\n}\r\n#ifdef CMX_TX_DEBUG\r\nprintk(KERN_DEBUG "%s\n", debugbuf);\r\n#endif\r\n}\r\nvoid\r\ndsp_cmx_hdlc(struct dsp *dsp, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *nskb = NULL;\r\nstruct dsp_conf_member *member;\r\nstruct mISDNhead *hh;\r\nif (!dsp->b_active)\r\nreturn;\r\nif (skb->len < 1)\r\nreturn;\r\nif (!dsp->conf) {\r\nif (dsp->echo.software) {\r\nnskb = skb_clone(skb, GFP_ATOMIC);\r\nif (nskb) {\r\nhh = mISDN_HEAD_P(nskb);\r\nhh->prim = PH_DATA_REQ;\r\nhh->id = 0;\r\nskb_queue_tail(&dsp->sendq, nskb);\r\nschedule_work(&dsp->workq);\r\n}\r\n}\r\nreturn;\r\n}\r\nif (dsp->conf->hardware)\r\nreturn;\r\nlist_for_each_entry(member, &dsp->conf->mlist, list) {\r\nif (dsp->echo.software || member->dsp != dsp) {\r\nnskb = skb_clone(skb, GFP_ATOMIC);\r\nif (nskb) {\r\nhh = mISDN_HEAD_P(nskb);\r\nhh->prim = PH_DATA_REQ;\r\nhh->id = 0;\r\nskb_queue_tail(&member->dsp->sendq, nskb);\r\nschedule_work(&member->dsp->workq);\r\n}\r\n}\r\n}\r\n}
