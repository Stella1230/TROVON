static s32 ixgbevf_start_hw_vf(struct ixgbe_hw *hw)\r\n{\r\nhw->adapter_stopped = false;\r\nreturn 0;\r\n}\r\nstatic s32 ixgbevf_init_hw_vf(struct ixgbe_hw *hw)\r\n{\r\ns32 status = hw->mac.ops.start_hw(hw);\r\nhw->mac.ops.get_mac_addr(hw, hw->mac.addr);\r\nreturn status;\r\n}\r\nstatic s32 ixgbevf_reset_hw_vf(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nu32 timeout = IXGBE_VF_INIT_TIMEOUT;\r\ns32 ret_val = IXGBE_ERR_INVALID_MAC_ADDR;\r\nu32 msgbuf[IXGBE_VF_PERMADDR_MSG_LEN];\r\nu8 *addr = (u8 *)(&msgbuf[1]);\r\nhw->mac.ops.stop_adapter(hw);\r\nhw->api_version = ixgbe_mbox_api_10;\r\nIXGBE_WRITE_REG(hw, IXGBE_VFCTRL, IXGBE_CTRL_RST);\r\nIXGBE_WRITE_FLUSH(hw);\r\nwhile (!mbx->ops.check_for_rst(hw) && timeout) {\r\ntimeout--;\r\nudelay(5);\r\n}\r\nif (!timeout)\r\nreturn IXGBE_ERR_RESET_FAILED;\r\nmbx->timeout = IXGBE_VF_MBX_INIT_TIMEOUT;\r\nmsgbuf[0] = IXGBE_VF_RESET;\r\nmbx->ops.write_posted(hw, msgbuf, 1);\r\nmdelay(10);\r\nret_val = mbx->ops.read_posted(hw, msgbuf, IXGBE_VF_PERMADDR_MSG_LEN);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (msgbuf[0] != (IXGBE_VF_RESET | IXGBE_VT_MSGTYPE_ACK) &&\r\nmsgbuf[0] != (IXGBE_VF_RESET | IXGBE_VT_MSGTYPE_NACK))\r\nreturn IXGBE_ERR_INVALID_MAC_ADDR;\r\nmemcpy(hw->mac.perm_addr, addr, ETH_ALEN);\r\nhw->mac.mc_filter_type = msgbuf[IXGBE_VF_MC_TYPE_WORD];\r\nreturn 0;\r\n}\r\nstatic s32 ixgbevf_stop_hw_vf(struct ixgbe_hw *hw)\r\n{\r\nu32 number_of_queues;\r\nu32 reg_val;\r\nu16 i;\r\nhw->adapter_stopped = true;\r\nnumber_of_queues = hw->mac.max_rx_queues;\r\nfor (i = 0; i < number_of_queues; i++) {\r\nreg_val = IXGBE_READ_REG(hw, IXGBE_VFRXDCTL(i));\r\nif (reg_val & IXGBE_RXDCTL_ENABLE) {\r\nreg_val &= ~IXGBE_RXDCTL_ENABLE;\r\nIXGBE_WRITE_REG(hw, IXGBE_VFRXDCTL(i), reg_val);\r\n}\r\n}\r\nIXGBE_WRITE_FLUSH(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_VTEIMC, IXGBE_VF_IRQ_CLEAR_MASK);\r\nIXGBE_READ_REG(hw, IXGBE_VTEICR);\r\nnumber_of_queues = hw->mac.max_tx_queues;\r\nfor (i = 0; i < number_of_queues; i++) {\r\nreg_val = IXGBE_READ_REG(hw, IXGBE_VFTXDCTL(i));\r\nif (reg_val & IXGBE_TXDCTL_ENABLE) {\r\nreg_val &= ~IXGBE_TXDCTL_ENABLE;\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTXDCTL(i), reg_val);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbevf_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)\r\n{\r\nu32 vector = 0;\r\nswitch (hw->mac.mc_filter_type) {\r\ncase 0:\r\nvector = ((mc_addr[4] >> 4) | (((u16)mc_addr[5]) << 4));\r\nbreak;\r\ncase 1:\r\nvector = ((mc_addr[4] >> 3) | (((u16)mc_addr[5]) << 5));\r\nbreak;\r\ncase 2:\r\nvector = ((mc_addr[4] >> 2) | (((u16)mc_addr[5]) << 6));\r\nbreak;\r\ncase 3:\r\nvector = ((mc_addr[4]) | (((u16)mc_addr[5]) << 8));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvector &= 0xFFF;\r\nreturn vector;\r\n}\r\nstatic s32 ixgbevf_get_mac_addr_vf(struct ixgbe_hw *hw, u8 *mac_addr)\r\n{\r\nmemcpy(mac_addr, hw->mac.perm_addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbevf_set_uc_addr_vf(struct ixgbe_hw *hw, u32 index, u8 *addr)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nu32 msgbuf[3];\r\nu8 *msg_addr = (u8 *)(&msgbuf[1]);\r\ns32 ret_val;\r\nmemset(msgbuf, 0, sizeof(msgbuf));\r\nmsgbuf[0] |= index << IXGBE_VT_MSGINFO_SHIFT;\r\nmsgbuf[0] |= IXGBE_VF_SET_MACVLAN;\r\nif (addr)\r\nmemcpy(msg_addr, addr, ETH_ALEN);\r\nret_val = mbx->ops.write_posted(hw, msgbuf, 3);\r\nif (!ret_val)\r\nret_val = mbx->ops.read_posted(hw, msgbuf, 3);\r\nmsgbuf[0] &= ~IXGBE_VT_MSGTYPE_CTS;\r\nif (!ret_val)\r\nif (msgbuf[0] ==\r\n(IXGBE_VF_SET_MACVLAN | IXGBE_VT_MSGTYPE_NACK))\r\nret_val = -ENOMEM;\r\nreturn ret_val;\r\n}\r\nstatic s32 ixgbevf_set_rar_vf(struct ixgbe_hw *hw, u32 index, u8 *addr,\r\nu32 vmdq)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nu32 msgbuf[3];\r\nu8 *msg_addr = (u8 *)(&msgbuf[1]);\r\ns32 ret_val;\r\nmemset(msgbuf, 0, sizeof(msgbuf));\r\nmsgbuf[0] = IXGBE_VF_SET_MAC_ADDR;\r\nmemcpy(msg_addr, addr, ETH_ALEN);\r\nret_val = mbx->ops.write_posted(hw, msgbuf, 3);\r\nif (!ret_val)\r\nret_val = mbx->ops.read_posted(hw, msgbuf, 3);\r\nmsgbuf[0] &= ~IXGBE_VT_MSGTYPE_CTS;\r\nif (!ret_val &&\r\n(msgbuf[0] == (IXGBE_VF_SET_MAC_ADDR | IXGBE_VT_MSGTYPE_NACK)))\r\nixgbevf_get_mac_addr_vf(hw, hw->mac.addr);\r\nreturn ret_val;\r\n}\r\nstatic void ixgbevf_write_msg_read_ack(struct ixgbe_hw *hw,\r\nu32 *msg, u16 size)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nu32 retmsg[IXGBE_VFMAILBOX_SIZE];\r\ns32 retval = mbx->ops.write_posted(hw, msg, size);\r\nif (!retval)\r\nmbx->ops.read_posted(hw, retmsg, size);\r\n}\r\nstatic s32 ixgbevf_update_mc_addr_list_vf(struct ixgbe_hw *hw,\r\nstruct net_device *netdev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nu32 msgbuf[IXGBE_VFMAILBOX_SIZE];\r\nu16 *vector_list = (u16 *)&msgbuf[1];\r\nu32 cnt, i;\r\ncnt = netdev_mc_count(netdev);\r\nif (cnt > 30)\r\ncnt = 30;\r\nmsgbuf[0] = IXGBE_VF_SET_MULTICAST;\r\nmsgbuf[0] |= cnt << IXGBE_VT_MSGINFO_SHIFT;\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nif (i == cnt)\r\nbreak;\r\nif (is_link_local_ether_addr(ha->addr))\r\ncontinue;\r\nvector_list[i++] = ixgbevf_mta_vector(hw, ha->addr);\r\n}\r\nixgbevf_write_msg_read_ack(hw, msgbuf, IXGBE_VFMAILBOX_SIZE);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbevf_set_vfta_vf(struct ixgbe_hw *hw, u32 vlan, u32 vind,\r\nbool vlan_on)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nu32 msgbuf[2];\r\ns32 err;\r\nmsgbuf[0] = IXGBE_VF_SET_VLAN;\r\nmsgbuf[1] = vlan;\r\nmsgbuf[0] |= vlan_on << IXGBE_VT_MSGINFO_SHIFT;\r\nerr = mbx->ops.write_posted(hw, msgbuf, 2);\r\nif (err)\r\ngoto mbx_err;\r\nerr = mbx->ops.read_posted(hw, msgbuf, 2);\r\nif (err)\r\ngoto mbx_err;\r\nmsgbuf[0] &= ~IXGBE_VT_MSGTYPE_CTS;\r\nmsgbuf[0] &= ~(0xFF << IXGBE_VT_MSGINFO_SHIFT);\r\nif (msgbuf[0] != (IXGBE_VF_SET_VLAN | IXGBE_VT_MSGTYPE_ACK))\r\nerr = IXGBE_ERR_INVALID_ARGUMENT;\r\nmbx_err:\r\nreturn err;\r\n}\r\nstatic s32 ixgbevf_setup_mac_link_vf(struct ixgbe_hw *hw,\r\nixgbe_link_speed speed, bool autoneg,\r\nbool autoneg_wait_to_complete)\r\n{\r\nreturn 0;\r\n}\r\nstatic s32 ixgbevf_check_mac_link_vf(struct ixgbe_hw *hw,\r\nixgbe_link_speed *speed,\r\nbool *link_up,\r\nbool autoneg_wait_to_complete)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nstruct ixgbe_mac_info *mac = &hw->mac;\r\ns32 ret_val = 0;\r\nu32 links_reg;\r\nu32 in_msg = 0;\r\nif (!mbx->ops.check_for_rst(hw) || !mbx->timeout)\r\nmac->get_link_status = true;\r\nif (!mac->get_link_status)\r\ngoto out;\r\nlinks_reg = IXGBE_READ_REG(hw, IXGBE_VFLINKS);\r\nif (!(links_reg & IXGBE_LINKS_UP))\r\ngoto out;\r\nswitch (links_reg & IXGBE_LINKS_SPEED_82599) {\r\ncase IXGBE_LINKS_SPEED_10G_82599:\r\n*speed = IXGBE_LINK_SPEED_10GB_FULL;\r\nbreak;\r\ncase IXGBE_LINKS_SPEED_1G_82599:\r\n*speed = IXGBE_LINK_SPEED_1GB_FULL;\r\nbreak;\r\ncase IXGBE_LINKS_SPEED_100_82599:\r\n*speed = IXGBE_LINK_SPEED_100_FULL;\r\nbreak;\r\n}\r\nif (mbx->ops.read(hw, &in_msg, 1))\r\ngoto out;\r\nif (!(in_msg & IXGBE_VT_MSGTYPE_CTS)) {\r\nif (in_msg & IXGBE_VT_MSGTYPE_NACK)\r\nret_val = -1;\r\ngoto out;\r\n}\r\nif (!mbx->timeout) {\r\nret_val = -1;\r\ngoto out;\r\n}\r\nmac->get_link_status = false;\r\nout:\r\n*link_up = !mac->get_link_status;\r\nreturn ret_val;\r\n}\r\nvoid ixgbevf_rlpml_set_vf(struct ixgbe_hw *hw, u16 max_size)\r\n{\r\nu32 msgbuf[2];\r\nmsgbuf[0] = IXGBE_VF_SET_LPE;\r\nmsgbuf[1] = max_size;\r\nixgbevf_write_msg_read_ack(hw, msgbuf, 2);\r\n}\r\nint ixgbevf_negotiate_api_version(struct ixgbe_hw *hw, int api)\r\n{\r\nint err;\r\nu32 msg[3];\r\nmsg[0] = IXGBE_VF_API_NEGOTIATE;\r\nmsg[1] = api;\r\nmsg[2] = 0;\r\nerr = hw->mbx.ops.write_posted(hw, msg, 3);\r\nif (!err)\r\nerr = hw->mbx.ops.read_posted(hw, msg, 3);\r\nif (!err) {\r\nmsg[0] &= ~IXGBE_VT_MSGTYPE_CTS;\r\nif (msg[0] == (IXGBE_VF_API_NEGOTIATE | IXGBE_VT_MSGTYPE_ACK)) {\r\nhw->api_version = api;\r\nreturn 0;\r\n}\r\nerr = IXGBE_ERR_INVALID_ARGUMENT;\r\n}\r\nreturn err;\r\n}\r\nint ixgbevf_get_queues(struct ixgbe_hw *hw, unsigned int *num_tcs,\r\nunsigned int *default_tc)\r\n{\r\nint err;\r\nu32 msg[5];\r\nswitch (hw->api_version) {\r\ncase ixgbe_mbox_api_11:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nmsg[0] = IXGBE_VF_GET_QUEUE;\r\nmsg[1] = msg[2] = msg[3] = msg[4] = 0;\r\nerr = hw->mbx.ops.write_posted(hw, msg, 5);\r\nif (!err)\r\nerr = hw->mbx.ops.read_posted(hw, msg, 5);\r\nif (!err) {\r\nmsg[0] &= ~IXGBE_VT_MSGTYPE_CTS;\r\nif (msg[0] != (IXGBE_VF_GET_QUEUE | IXGBE_VT_MSGTYPE_ACK))\r\nreturn IXGBE_ERR_MBX;\r\nhw->mac.max_tx_queues = msg[IXGBE_VF_TX_QUEUES];\r\nif (hw->mac.max_tx_queues == 0 ||\r\nhw->mac.max_tx_queues > IXGBE_VF_MAX_TX_QUEUES)\r\nhw->mac.max_tx_queues = IXGBE_VF_MAX_TX_QUEUES;\r\nhw->mac.max_rx_queues = msg[IXGBE_VF_RX_QUEUES];\r\nif (hw->mac.max_rx_queues == 0 ||\r\nhw->mac.max_rx_queues > IXGBE_VF_MAX_RX_QUEUES)\r\nhw->mac.max_rx_queues = IXGBE_VF_MAX_RX_QUEUES;\r\n*num_tcs = msg[IXGBE_VF_TRANS_VLAN];\r\nif (*num_tcs > hw->mac.max_rx_queues)\r\n*num_tcs = 1;\r\n*default_tc = msg[IXGBE_VF_DEF_QUEUE];\r\nif (*default_tc >= hw->mac.max_tx_queues)\r\n*default_tc = 0;\r\n}\r\nreturn err;\r\n}
