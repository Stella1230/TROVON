static void stmmac_default_data(void)\r\n{\r\nmemset(&plat_dat, 0, sizeof(struct plat_stmmacenet_data));\r\nplat_dat.bus_id = 1;\r\nplat_dat.phy_addr = 0;\r\nplat_dat.interface = PHY_INTERFACE_MODE_GMII;\r\nplat_dat.clk_csr = 2;\r\nplat_dat.has_gmac = 1;\r\nplat_dat.force_sf_dma_mode = 1;\r\nmdio_data.phy_reset = NULL;\r\nmdio_data.phy_mask = 0;\r\nplat_dat.mdio_bus_data = &mdio_data;\r\ndma_cfg.pbl = 32;\r\ndma_cfg.burst_len = DMA_AXI_BLEN_256;\r\nplat_dat.dma_cfg = &dma_cfg;\r\n}\r\nstatic int stmmac_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint ret = 0;\r\nvoid __iomem *addr = NULL;\r\nstruct stmmac_priv *priv = NULL;\r\nint i;\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\npr_err("%s : ERROR: failed to enable %s device\n", __func__,\r\npci_name(pdev));\r\nreturn ret;\r\n}\r\nif (pci_request_regions(pdev, STMMAC_RESOURCE_NAME)) {\r\npr_err("%s: ERROR: failed to get PCI region\n", __func__);\r\nret = -ENODEV;\r\ngoto err_out_req_reg_failed;\r\n}\r\nfor (i = 0; i <= 5; i++) {\r\nif (pci_resource_len(pdev, i) == 0)\r\ncontinue;\r\naddr = pci_iomap(pdev, i, 0);\r\nif (addr == NULL) {\r\npr_err("%s: ERROR: cannot map register memory aborting",\r\n__func__);\r\nret = -EIO;\r\ngoto err_out_map_failed;\r\n}\r\nbreak;\r\n}\r\npci_set_master(pdev);\r\nstmmac_default_data();\r\npriv = stmmac_dvr_probe(&(pdev->dev), &plat_dat, addr);\r\nif (IS_ERR(priv)) {\r\npr_err("%s: main driver probe failed", __func__);\r\nret = PTR_ERR(priv);\r\ngoto err_out;\r\n}\r\npriv->dev->irq = pdev->irq;\r\npriv->wol_irq = pdev->irq;\r\npci_set_drvdata(pdev, priv->dev);\r\npr_debug("STMMAC platform driver registration completed");\r\nreturn 0;\r\nerr_out:\r\npci_clear_master(pdev);\r\nerr_out_map_failed:\r\npci_release_regions(pdev);\r\nerr_out_req_reg_failed:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void stmmac_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nstmmac_dvr_remove(ndev);\r\npci_iounmap(pdev, priv->ioaddr);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int stmmac_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nint ret;\r\nret = stmmac_suspend(ndev);\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn ret;\r\n}\r\nstatic int stmmac_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nreturn stmmac_resume(ndev);\r\n}
