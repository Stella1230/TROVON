static void FlushOutBuff(DEVICE_EXTENSION *pdx)\r\n{\r\ndev_dbg(&pdx->interface->dev, "%s: currentState=%d\n",\r\n__func__, pdx->sCurrentState);\r\nif (pdx->sCurrentState == U14ERR_TIME)\r\nreturn;\r\nspin_lock_irq(&pdx->charOutLock);\r\npdx->dwNumOutput = 0;\r\npdx->dwOutBuffGet = 0;\r\npdx->dwOutBuffPut = 0;\r\nspin_unlock_irq(&pdx->charOutLock);\r\n}\r\nstatic void FlushInBuff(DEVICE_EXTENSION *pdx)\r\n{\r\ndev_dbg(&pdx->interface->dev, "%s: currentState=%d\n",\r\n__func__, pdx->sCurrentState);\r\nif (pdx->sCurrentState == U14ERR_TIME)\r\nreturn;\r\nspin_lock_irq(&pdx->charInLock);\r\npdx->dwNumInput = 0;\r\npdx->dwInBuffGet = 0;\r\npdx->dwInBuffPut = 0;\r\nspin_unlock_irq(&pdx->charInLock);\r\n}\r\nstatic int PutChars(DEVICE_EXTENSION *pdx, const char *pCh,\r\nunsigned int uCount)\r\n{\r\nint iReturn;\r\nspin_lock_irq(&pdx->charOutLock);\r\nif ((OUTBUF_SZ - pdx->dwNumOutput) >= uCount) {\r\nunsigned int u;\r\nfor (u = 0; u < uCount; u++) {\r\npdx->outputBuffer[pdx->dwOutBuffPut++] = pCh[u];\r\nif (pdx->dwOutBuffPut >= OUTBUF_SZ)\r\npdx->dwOutBuffPut = 0;\r\n}\r\npdx->dwNumOutput += uCount;\r\nspin_unlock_irq(&pdx->charOutLock);\r\niReturn = SendChars(pdx);\r\n} else {\r\niReturn = U14ERR_NOOUT;\r\nspin_unlock_irq(&pdx->charOutLock);\r\n}\r\nreturn iReturn;\r\n}\r\nint SendString(DEVICE_EXTENSION *pdx, const char __user *pData,\r\nunsigned int n)\r\n{\r\nint iReturn = U14ERR_NOERROR;\r\nchar buffer[OUTBUF_SZ + 1];\r\nif (n > OUTBUF_SZ)\r\nreturn U14ERR_NOOUT;\r\nif (copy_from_user(buffer, pData, n))\r\nreturn -EFAULT;\r\nbuffer[n] = 0;\r\nmutex_lock(&pdx->io_mutex);\r\nif (n > 0) {\r\ndev_dbg(&pdx->interface->dev, "%s: n=%d>%s<\n",\r\n__func__, n, buffer);\r\niReturn = PutChars(pdx, buffer, n);\r\n}\r\nAllowi(pdx);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint SendChar(DEVICE_EXTENSION *pdx, char c)\r\n{\r\nint iReturn;\r\nmutex_lock(&pdx->io_mutex);\r\niReturn = PutChars(pdx, &c, 1);\r\ndev_dbg(&pdx->interface->dev, "SendChar >%c< (0x%02x)\n", c, c);\r\nAllowi(pdx);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint Get1401State(DEVICE_EXTENSION *pdx, __u32 *state, __u32 *error)\r\n{\r\nint nGot;\r\ndev_dbg(&pdx->interface->dev, "%s: entry\n", __func__);\r\n*state = 0xFFFFFFFF;\r\nnGot = usb_control_msg(pdx->udev, usb_rcvctrlpipe(pdx->udev, 0),\r\nGET_STATUS, (D_TO_H | VENDOR | DEVREQ), 0, 0,\r\npdx->statBuf, sizeof(pdx->statBuf), HZ);\r\nif (nGot != sizeof(pdx->statBuf)) {\r\ndev_err(&pdx->interface->dev,\r\n"%s: FAILED, return code %d\n", __func__, nGot);\r\npdx->sCurrentState = U14ERR_TIME;\r\n*state = 0;\r\n*error = 0;\r\n} else {\r\nint nDevice;\r\ndev_dbg(&pdx->interface->dev,\r\n"%s: Success, state: 0x%x, 0x%x\n",\r\n__func__, pdx->statBuf[0], pdx->statBuf[1]);\r\n*state = pdx->statBuf[0];\r\n*error = pdx->statBuf[1];\r\nnDevice = pdx->udev->descriptor.bcdDevice >> 8;\r\nswitch (nDevice) {\r\ncase 0:\r\npdx->sCurrentState = U14ERR_U1401;\r\nbreak;\r\ndefault:\r\nif ((nDevice >= 1) && (nDevice <= 23))\r\npdx->sCurrentState = (short)(nDevice + 6);\r\nelse\r\npdx->sCurrentState = U14ERR_ILL;\r\nbreak;\r\n}\r\n}\r\nreturn pdx->sCurrentState >= 0 ? U14ERR_NOERROR : pdx->sCurrentState;\r\n}\r\nint ReadWrite_Cancel(DEVICE_EXTENSION *pdx)\r\n{\r\ndev_dbg(&pdx->interface->dev, "%s: entry %d\n",\r\n__func__, pdx->bStagedUrbPending);\r\n#ifdef NOT_WRITTEN_YET\r\nint ntStatus = STATUS_SUCCESS;\r\nbool bResult = false;\r\nunsigned int i;\r\nspin_lock_irq(&pdx->stagedLock);\r\nif (pdx->bStagedUrbPending) {\r\ndev_info(&pdx->interface - dev,\r\n"ReadWrite_Cancel about to cancel Urb\n");\r\nUSB_ASSERT(pdx->pStagedIrp != NULL);\r\nspin_unlock_irq(&pdx->stagedLock);\r\nbResult = IoCancelIrp(pdx->pStagedIrp);\r\nif (bResult) {\r\nLARGE_INTEGER timeout;\r\ntimeout.QuadPart = -10000000;\r\ndev_info(&pdx->interface - dev,\r\n"%s: about to wait till done\n", __func__);\r\nntStatus =\r\nKeWaitForSingleObject(&pdx->StagingDoneEvent,\r\nExecutive, KernelMode, FALSE,\r\n&timeout);\r\n} else {\r\ndev_info(&pdx->interface - dev,\r\n"%s: cancellation failed\n", __func__);\r\nntStatus = U14ERR_FAIL;\r\n}\r\nUSB_KdPrint(DBGLVL_DEFAULT,\r\n("ReadWrite_Cancel ntStatus = 0x%x decimal %d\n",\r\nntStatus, ntStatus));\r\n} else\r\nspin_unlock_irq(&pdx->stagedLock);\r\ndev_info(&pdx->interface - dev, "%s: done\n", __func__);\r\nreturn ntStatus;\r\n#else\r\nreturn U14ERR_NOERROR;\r\n#endif\r\n}\r\nstatic int InSelfTest(DEVICE_EXTENSION *pdx, unsigned int *pState)\r\n{\r\nunsigned int state, error;\r\nint iReturn = Get1401State(pdx, &state, &error);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = (state == (unsigned int)-1) ||\r\n((state & 0xff) == 0x80);\r\n*pState = state;\r\nreturn iReturn;\r\n}\r\nbool Is1401(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn;\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\nced_draw_down(pdx);\r\nFlushInBuff(pdx);\r\nFlushOutBuff(pdx);\r\niReturn = usb_lock_device_for_reset(pdx->udev, pdx->interface);\r\nmutex_unlock(&pdx->io_mutex);\r\nif (iReturn >= 0) {\r\niReturn = usb_reset_device(pdx->udev);\r\nusb_unlock_device(pdx->udev);\r\n}\r\nmutex_lock(&pdx->io_mutex);\r\npdx->dwDMAFlag = MODE_CHAR;\r\nif (iReturn == 0) {\r\nunsigned int state;\r\niReturn = InSelfTest(pdx, &state);\r\nif (iReturn > 0) {\r\nunsigned long ulTimeOut = jiffies + 30 * HZ;\r\nwhile ((iReturn > 0) && time_before(jiffies, ulTimeOut)) {\r\nschedule();\r\niReturn = InSelfTest(pdx, &state);\r\n}\r\n}\r\nif (iReturn == 0)\r\niReturn = state == 0;\r\n} else\r\niReturn = 0;\r\npdx->bForceReset = false;\r\nreturn iReturn > 0;\r\n}\r\nbool QuickCheck(DEVICE_EXTENSION *pdx, bool bTestBuff, bool bCanReset)\r\n{\r\nbool bRet = false;\r\nbool bShortTest;\r\nbShortTest = ((pdx->dwDMAFlag == MODE_CHAR) &&\r\n(!pdx->bForceReset) &&\r\n(pdx->sCurrentState >= U14ERR_STD));\r\ndev_dbg(&pdx->interface->dev,\r\n"%s: DMAFlag:%d, state:%d, force:%d, testBuff:%d, short:%d\n",\r\n__func__, pdx->dwDMAFlag, pdx->sCurrentState, pdx->bForceReset,\r\nbTestBuff, bShortTest);\r\nif ((bTestBuff) &&\r\n(pdx->dwNumInput || pdx->dwNumOutput)) {\r\nbShortTest = false;\r\ndev_dbg(&pdx->interface->dev,\r\n"%s: will reset as buffers not empty\n", __func__);\r\n}\r\nif (bShortTest || !bCanReset) {\r\nunsigned int state, error;\r\ndev_dbg(&pdx->interface->dev, "%s: Get1401State\n", __func__);\r\nif (Get1401State(pdx, &state, &error) == U14ERR_NOERROR) {\r\nif ((state & 0xFF) == 0)\r\nbRet = true;\r\n}\r\n}\r\nif (!bRet && bCanReset) {\r\ndev_info(&pdx->interface->dev, "%s: Is1401 %d %d %d %d\n",\r\n__func__, bShortTest, pdx->sCurrentState, bTestBuff,\r\npdx->bForceReset);\r\nbRet = Is1401(pdx);\r\n}\r\nreturn bRet;\r\n}\r\nint Reset1401(DEVICE_EXTENSION *pdx)\r\n{\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s: About to call QuickCheck\n",\r\n__func__);\r\nQuickCheck(pdx, true, true);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn U14ERR_NOERROR;\r\n}\r\nint GetChar(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn = U14ERR_NOIN;\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\nAllowi(pdx);\r\nSendChars(pdx);\r\nspin_lock_irq(&pdx->charInLock);\r\nif (pdx->dwNumInput > 0) {\r\niReturn = pdx->inputBuffer[pdx->dwInBuffGet++];\r\nif (pdx->dwInBuffGet >= INBUF_SZ)\r\npdx->dwInBuffGet = 0;\r\npdx->dwNumInput--;\r\n} else\r\niReturn = U14ERR_NOIN;\r\nspin_unlock_irq(&pdx->charInLock);\r\nAllowi(pdx);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint GetString(DEVICE_EXTENSION *pdx, char __user *pUser, int n)\r\n{\r\nint nAvailable;\r\nint iReturn = U14ERR_NOIN;\r\nif (n <= 0)\r\nreturn -ENOMEM;\r\nmutex_lock(&pdx->io_mutex);\r\nAllowi(pdx);\r\nSendChars(pdx);\r\nspin_lock_irq(&pdx->charInLock);\r\nnAvailable = pdx->dwNumInput;\r\nif (nAvailable > n)\r\nnAvailable = n;\r\nif (nAvailable > 0) {\r\nchar buffer[INBUF_SZ + 1];\r\nint nGot = 0;\r\nint nCopyToUser;\r\nchar cData;\r\ndo {\r\ncData = pdx->inputBuffer[pdx->dwInBuffGet++];\r\nif (cData == CR_CHAR)\r\ncData = (char)0;\r\nif (pdx->dwInBuffGet >= INBUF_SZ)\r\npdx->dwInBuffGet = 0;\r\nbuffer[nGot++] = cData;\r\n} while ((nGot < nAvailable) && cData);\r\nnCopyToUser = nGot;\r\nif (cData) {\r\nbuffer[nGot] = (char)0;\r\nif (nGot < n)\r\n++nCopyToUser;\r\n}\r\npdx->dwNumInput -= nGot;\r\nspin_unlock_irq(&pdx->charInLock);\r\ndev_dbg(&pdx->interface->dev, "%s: read %d characters >%s<\n",\r\n__func__, nGot, buffer);\r\nif (copy_to_user(pUser, buffer, nCopyToUser))\r\niReturn = -EFAULT;\r\nelse\r\niReturn = nGot;\r\n} else\r\nspin_unlock_irq(&pdx->charInLock);\r\nAllowi(pdx);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint Stat1401(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn;\r\nmutex_lock(&pdx->io_mutex);\r\nAllowi(pdx);\r\nSendChars(pdx);\r\niReturn = pdx->dwNumInput;\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint LineCount(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn = 0;\r\nmutex_lock(&pdx->io_mutex);\r\nAllowi(pdx);\r\nSendChars(pdx);\r\nspin_lock_irq(&pdx->charInLock);\r\nif (pdx->dwNumInput > 0) {\r\nunsigned int dwIndex = pdx->dwInBuffGet;\r\nunsigned int dwEnd = pdx->dwInBuffPut;\r\ndo {\r\nif (pdx->inputBuffer[dwIndex++] == CR_CHAR)\r\n++iReturn;\r\nif (dwIndex >= INBUF_SZ)\r\ndwIndex = 0;\r\n} while (dwIndex != dwEnd);\r\n}\r\nspin_unlock_irq(&pdx->charInLock);\r\ndev_dbg(&pdx->interface->dev, "%s: returned %d\n", __func__, iReturn);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint GetOutBufSpace(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn;\r\nmutex_lock(&pdx->io_mutex);\r\nSendChars(pdx);\r\niReturn = (int)(OUTBUF_SZ - pdx->dwNumOutput);\r\ndev_dbg(&pdx->interface->dev, "%s: %d\n", __func__, iReturn);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint ClearArea(DEVICE_EXTENSION *pdx, int nArea)\r\n{\r\nint iReturn = U14ERR_NOERROR;\r\nif ((nArea < 0) || (nArea >= MAX_TRANSAREAS)) {\r\niReturn = U14ERR_BADAREA;\r\ndev_err(&pdx->interface->dev, "%s: Attempt to clear area %d\n",\r\n__func__, nArea);\r\n} else {\r\nTRANSAREA *pTA = &pdx->rTransDef[nArea];\r\nif (!pTA->bUsed)\r\niReturn = U14ERR_NOTSET;\r\nelse {\r\nstruct page **pPages = NULL;\r\nint nPages = 0;\r\nint np;\r\ndev_dbg(&pdx->interface->dev, "%s: area %d\n",\r\n__func__, nArea);\r\nspin_lock_irq(&pdx->stagedLock);\r\nif ((pdx->StagedId == nArea)\r\n&& (pdx->dwDMAFlag > MODE_CHAR)) {\r\niReturn = U14ERR_UNLOCKFAIL;\r\ndev_err(&pdx->interface->dev,\r\n"%s: call on area %d while active\n",\r\n__func__, nArea);\r\n} else {\r\npPages = pTA->pPages;\r\nnPages = pTA->nPages;\r\nif (pTA->dwEventSz)\r\nwake_up_interruptible(&pTA->wqEvent);\r\nif (pdx->bXFerWaiting\r\n&& (pdx->rDMAInfo.wIdent == nArea))\r\npdx->bXFerWaiting = false;\r\nmemset(pTA, 0,\r\nsizeof(TRANSAREA) -\r\nsizeof(wait_queue_head_t));\r\n}\r\nspin_unlock_irq(&pdx->stagedLock);\r\nif (pPages) {\r\ndev_dbg(&pdx->interface->dev, "%s: nPages=%d\n",\r\n__func__, nPages);\r\nfor (np = 0; np < nPages; ++np) {\r\nif (pPages[np]) {\r\nSetPageDirty(pPages[np]);\r\npage_cache_release(pPages[np]);\r\n}\r\n}\r\nkfree(pPages);\r\ndev_dbg(&pdx->interface->dev,\r\n"%s: kfree(pPages) done\n", __func__);\r\n}\r\n}\r\n}\r\nreturn iReturn;\r\n}\r\nstatic int SetArea(DEVICE_EXTENSION *pdx, int nArea, char __user *puBuf,\r\nunsigned int dwLength, bool bCircular, bool bCircToHost)\r\n{\r\nunsigned long ulStart = ((unsigned long)puBuf) & PAGE_MASK;\r\nunsigned int ulOffset = ((unsigned long)puBuf) & (PAGE_SIZE - 1);\r\nint len = (dwLength + ulOffset + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nTRANSAREA *pTA = &pdx->rTransDef[nArea];\r\nstruct page **pPages = NULL;\r\nint nPages = 0;\r\nint iReturn = ClearArea(pdx, nArea);\r\nif ((iReturn != U14ERR_NOTSET) &&\r\n(iReturn != U14ERR_NOERROR))\r\nreturn iReturn;\r\nif (!access_ok(VERIFY_WRITE, puBuf, dwLength))\r\nreturn -EFAULT;\r\npPages = kmalloc(len * sizeof(struct page *), GFP_KERNEL);\r\nif (!pPages) {\r\niReturn = U14ERR_NOMEMORY;\r\ngoto error;\r\n}\r\ndev_dbg(&pdx->interface->dev, "%s: %p, length=%06x, circular %d\n",\r\n__func__, puBuf, dwLength, bCircular);\r\nnPages = get_user_pages_fast(ulStart, len, 1, pPages);\r\ndev_dbg(&pdx->interface->dev, "%s: nPages = %d\n", __func__, nPages);\r\nif (nPages > 0) {\r\nspin_lock_irq(&pdx->stagedLock);\r\npTA->lpvBuff = puBuf;\r\npTA->dwBaseOffset = ulOffset;\r\npTA->dwLength = dwLength;\r\npTA->pPages = pPages;\r\npTA->nPages = nPages;\r\npTA->bCircular = bCircular;\r\npTA->bCircToHost = bCircToHost;\r\npTA->aBlocks[0].dwOffset = 0;\r\npTA->aBlocks[0].dwSize = 0;\r\npTA->aBlocks[1].dwOffset = 0;\r\npTA->aBlocks[1].dwSize = 0;\r\npTA->bUsed = true;\r\nspin_unlock_irq(&pdx->stagedLock);\r\niReturn = U14ERR_NOERROR;\r\n} else {\r\niReturn = U14ERR_LOCKFAIL;\r\ngoto error;\r\n}\r\nreturn iReturn;\r\nerror:\r\nkfree(pPages);\r\nreturn iReturn;\r\n}\r\nint SetTransfer(DEVICE_EXTENSION *pdx, struct transfer_area_desc __user *pTD)\r\n{\r\nint iReturn;\r\nstruct transfer_area_desc td;\r\nif (copy_from_user(&td, pTD, sizeof(td)))\r\nreturn -EFAULT;\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s: area:%d, size:%08x\n",\r\n__func__, td.wAreaNum, td.dwLength);\r\niReturn =\r\nSetArea(pdx, td.wAreaNum,\r\n(char __user *)((unsigned long)td.lpvBuff), td.dwLength,\r\nfalse, false);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint UnsetTransfer(DEVICE_EXTENSION *pdx, int nArea)\r\n{\r\nint iReturn;\r\nmutex_lock(&pdx->io_mutex);\r\niReturn = ClearArea(pdx, nArea);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint SetEvent(DEVICE_EXTENSION *pdx, struct transfer_event __user *pTE)\r\n{\r\nint iReturn = U14ERR_NOERROR;\r\nstruct transfer_event te;\r\nif (copy_from_user(&te, pTE, sizeof(te)))\r\nreturn -EFAULT;\r\nif (te.wAreaNum >= MAX_TRANSAREAS)\r\nreturn U14ERR_BADAREA;\r\nelse {\r\nTRANSAREA *pTA = &pdx->rTransDef[te.wAreaNum];\r\nmutex_lock(&pdx->io_mutex);\r\nspin_lock_irq(&pdx->stagedLock);\r\nif (pTA->bUsed) {\r\npTA->dwEventSt = te.dwStart;\r\npTA->dwEventSz = te.dwLength;\r\npTA->bEventToHost = te.wFlags & 1;\r\npTA->iWakeUp = 0;\r\n} else\r\niReturn = U14ERR_NOTSET;\r\nspin_unlock_irq(&pdx->stagedLock);\r\nmutex_unlock(&pdx->io_mutex);\r\n}\r\nreturn iReturn ==\r\nU14ERR_NOERROR ? (te.iSetEvent ? 1 : U14ERR_NOERROR) : iReturn;\r\n}\r\nint WaitEvent(DEVICE_EXTENSION *pdx, int nArea, int msTimeOut)\r\n{\r\nint iReturn;\r\nif ((unsigned)nArea >= MAX_TRANSAREAS)\r\nreturn U14ERR_BADAREA;\r\nelse {\r\nint iWait;\r\nTRANSAREA *pTA = &pdx->rTransDef[nArea];\r\nmsTimeOut = (msTimeOut * HZ + 999) / 1000;\r\nmutex_lock(&pdx->io_mutex);\r\nif (!pTA->bUsed || !pTA->dwEventSz)\r\nreturn U14ERR_NOTSET;\r\nmutex_unlock(&pdx->io_mutex);\r\nif (msTimeOut)\r\niWait =\r\nwait_event_interruptible_timeout(pTA->wqEvent,\r\npTA->iWakeUp\r\n|| !pTA->bUsed,\r\nmsTimeOut);\r\nelse\r\niWait =\r\nwait_event_interruptible(pTA->wqEvent, pTA->iWakeUp\r\n|| !pTA->bUsed);\r\nif (iWait)\r\niReturn = -ERESTARTSYS;\r\nelse\r\niReturn = pTA->iWakeUp;\r\nspin_lock_irq(&pdx->stagedLock);\r\npTA->iWakeUp = 0;\r\nspin_unlock_irq(&pdx->stagedLock);\r\n}\r\nreturn iReturn;\r\n}\r\nint TestEvent(DEVICE_EXTENSION *pdx, int nArea)\r\n{\r\nint iReturn;\r\nif ((unsigned)nArea >= MAX_TRANSAREAS)\r\niReturn = U14ERR_BADAREA;\r\nelse {\r\nTRANSAREA *pTA = &pdx->rTransDef[nArea];\r\nmutex_lock(&pdx->io_mutex);\r\nspin_lock_irq(&pdx->stagedLock);\r\niReturn = pTA->iWakeUp;\r\npTA->iWakeUp = 0;\r\nspin_unlock_irq(&pdx->stagedLock);\r\nmutex_unlock(&pdx->io_mutex);\r\n}\r\nreturn iReturn;\r\n}\r\nint GetTransfer(DEVICE_EXTENSION *pdx, TGET_TX_BLOCK __user *pTX)\r\n{\r\nint iReturn = U14ERR_NOERROR;\r\nunsigned int dwIdent;\r\nmutex_lock(&pdx->io_mutex);\r\ndwIdent = pdx->StagedId;\r\nif (dwIdent >= MAX_TRANSAREAS)\r\niReturn = U14ERR_BADAREA;\r\nelse {\r\nTGET_TX_BLOCK *tx;\r\ntx = kzalloc(sizeof(*tx), GFP_KERNEL);\r\nif (!tx) {\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn -ENOMEM;\r\n}\r\ntx->size = pdx->rTransDef[dwIdent].dwLength;\r\ntx->linear = (long long)((long)pdx->rTransDef[dwIdent].lpvBuff);\r\ntx->avail = GET_TX_MAXENTRIES;\r\ntx->used = 1;\r\ntx->entries[0].physical =\r\n(long long)(tx->linear + pdx->StagedOffset);\r\ntx->entries[0].size = tx->size;\r\nif (copy_to_user(pTX, tx, sizeof(*tx)))\r\niReturn = -EFAULT;\r\nkfree(tx);\r\n}\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint KillIO1401(DEVICE_EXTENSION *pdx)\r\n{\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\nmutex_lock(&pdx->io_mutex);\r\nFlushOutBuff(pdx);\r\nFlushInBuff(pdx);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn U14ERR_NOERROR;\r\n}\r\nint BlkTransState(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn = pdx->dwDMAFlag != MODE_CHAR;\r\ndev_dbg(&pdx->interface->dev, "%s: %d\n", __func__, iReturn);\r\nreturn iReturn;\r\n}\r\nint StateOf1401(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn;\r\nmutex_lock(&pdx->io_mutex);\r\nQuickCheck(pdx, false, false);\r\niReturn = pdx->sCurrentState;\r\nmutex_unlock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s: %d\n", __func__, iReturn);\r\nreturn iReturn;\r\n}\r\nint StartSelfTest(DEVICE_EXTENSION *pdx)\r\n{\r\nint nGot;\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\nced_draw_down(pdx);\r\nFlushInBuff(pdx);\r\nFlushOutBuff(pdx);\r\npdx->dwDMAFlag = MODE_CHAR;\r\nnGot = usb_control_msg(pdx->udev, usb_rcvctrlpipe(pdx->udev, 0),\r\nDB_SELFTEST, (H_TO_D | VENDOR | DEVREQ),\r\n0, 0, NULL, 0, HZ);\r\npdx->ulSelfTestTime = jiffies + HZ * 30;\r\nmutex_unlock(&pdx->io_mutex);\r\nif (nGot < 0)\r\ndev_err(&pdx->interface->dev, "%s: err=%d\n", __func__, nGot);\r\nreturn nGot < 0 ? U14ERR_FAIL : U14ERR_NOERROR;\r\n}\r\nint CheckSelfTest(DEVICE_EXTENSION *pdx, TGET_SELFTEST __user *pGST)\r\n{\r\nunsigned int state, error;\r\nint iReturn;\r\nTGET_SELFTEST gst;\r\nmemset(&gst, 0, sizeof(gst));\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\niReturn = Get1401State(pdx, &state, &error);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = Get1401State(pdx, &state, &error);\r\nif (iReturn != U14ERR_NOERROR) {\r\ndev_err(&pdx->interface->dev,\r\n"%s: Get1401State=%d, assuming still testing\n",\r\n__func__, iReturn);\r\nstate = 0x80;\r\nerror = 0;\r\niReturn = U14ERR_NOERROR;\r\n}\r\nif ((state == -1) && (error == -1)) {\r\ndev_err(&pdx->interface->dev,\r\n"%s: Get1401State failed, assuming still testing\n",\r\n__func__);\r\nstate = 0x80;\r\nerror = 0;\r\n}\r\nif ((state & 0xFF) == 0x80) {\r\nif (state & 0x00FF0000) {\r\ngst.code = (state & 0x00FF0000) >> 16;\r\ngst.x = error & 0x0000FFFF;\r\ngst.y = (error & 0xFFFF0000) >> 16;\r\ndev_dbg(&pdx->interface->dev,\r\n"Self-test error code %d\n", gst.code);\r\n} else {\r\nunsigned long ulNow = jiffies;\r\nif (time_after(ulNow, pdx->ulSelfTestTime)) {\r\ngst.code = -2;\r\ndev_dbg(&pdx->interface->dev,\r\n"Self-test timed-out\n");\r\n} else\r\ndev_dbg(&pdx->interface->dev,\r\n"Self-test on-going\n");\r\n}\r\n} else {\r\ngst.code = -1;\r\ndev_dbg(&pdx->interface->dev, "Self-test done\n");\r\n}\r\nif (gst.code < 0) {\r\nif ((pdx->nPipes == 4) && (pdx->s1401Type <= TYPEPOWER))\r\nIs1401(pdx);\r\nelse\r\nQuickCheck(pdx, true, true);\r\n}\r\nmutex_unlock(&pdx->io_mutex);\r\nif (copy_to_user(pGST, &gst, sizeof(gst)))\r\nreturn -EFAULT;\r\nreturn iReturn;\r\n}\r\nint TypeOf1401(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn = TYPEUNKNOWN;\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\nswitch (pdx->s1401Type) {\r\ncase TYPE1401:\r\niReturn = U14ERR_STD;\r\nbreak;\r\ncase TYPEPLUS:\r\niReturn = U14ERR_PLUS;\r\nbreak;\r\ncase TYPEU1401:\r\niReturn = U14ERR_U1401;\r\nbreak;\r\ndefault:\r\nif ((pdx->s1401Type >= TYPEPOWER) && (pdx->s1401Type <= 25))\r\niReturn = pdx->s1401Type + 4;\r\nelse\r\niReturn = TYPEUNKNOWN;\r\n}\r\ndev_dbg(&pdx->interface->dev, "%s %d\n", __func__, iReturn);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint TransferFlags(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn = U14TF_MULTIA | U14TF_DIAG |\r\nU14TF_NOTIFY | U14TF_CIRCTH;\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\nmutex_lock(&pdx->io_mutex);\r\nif (pdx->bIsUSB2)\r\niReturn |= U14TF_USB2;\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nstatic int DbgCmd1401(DEVICE_EXTENSION *pdx, unsigned char cmd,\r\nunsigned int data)\r\n{\r\nint iReturn;\r\ndev_dbg(&pdx->interface->dev, "%s: entry\n", __func__);\r\niReturn = usb_control_msg(pdx->udev, usb_sndctrlpipe(pdx->udev, 0), cmd,\r\n(H_TO_D | VENDOR | DEVREQ),\r\n(unsigned short)data,\r\n(unsigned short)(data >> 16), NULL, 0, HZ);\r\nif (iReturn < 0)\r\ndev_err(&pdx->interface->dev, "%s: fail code=%d\n",\r\n__func__, iReturn);\r\nreturn iReturn;\r\n}\r\nint DbgPeek(DEVICE_EXTENSION *pdx, TDBGBLOCK __user *pDB)\r\n{\r\nint iReturn;\r\nTDBGBLOCK db;\r\nif (copy_from_user(&db, pDB, sizeof(db)))\r\nreturn -EFAULT;\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s: @ %08x\n", __func__, db.iAddr);\r\niReturn = DbgCmd1401(pdx, DB_SETADD, db.iAddr);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_WIDTH, db.iWidth);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_REPEATS, db.iRepeats);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_PEEK, 0);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint DbgPoke(DEVICE_EXTENSION *pdx, TDBGBLOCK __user *pDB)\r\n{\r\nint iReturn;\r\nTDBGBLOCK db;\r\nif (copy_from_user(&db, pDB, sizeof(db)))\r\nreturn -EFAULT;\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s: @ %08x\n", __func__, db.iAddr);\r\niReturn = DbgCmd1401(pdx, DB_SETADD, db.iAddr);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_WIDTH, db.iWidth);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_REPEATS, db.iRepeats);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_POKE, db.iData);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint DbgRampData(DEVICE_EXTENSION *pdx, TDBGBLOCK __user *pDB)\r\n{\r\nint iReturn;\r\nTDBGBLOCK db;\r\nif (copy_from_user(&db, pDB, sizeof(db)))\r\nreturn -EFAULT;\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s: @ %08x\n", __func__, db.iAddr);\r\niReturn = DbgCmd1401(pdx, DB_SETADD, db.iAddr);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_SETDEF, db.iDefault);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_SETMASK, db.iMask);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_WIDTH, db.iWidth);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_REPEATS, db.iRepeats);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_RAMPD, 0);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint DbgRampAddr(DEVICE_EXTENSION *pdx, TDBGBLOCK __user *pDB)\r\n{\r\nint iReturn;\r\nTDBGBLOCK db;\r\nif (copy_from_user(&db, pDB, sizeof(db)))\r\nreturn -EFAULT;\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\niReturn = DbgCmd1401(pdx, DB_SETDEF, db.iDefault);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_SETMASK, db.iMask);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_WIDTH, db.iWidth);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_REPEATS, db.iRepeats);\r\nif (iReturn == U14ERR_NOERROR)\r\niReturn = DbgCmd1401(pdx, DB_RAMPA, 0);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint DbgGetData(DEVICE_EXTENSION *pdx, TDBGBLOCK __user *pDB)\r\n{\r\nint iReturn;\r\nTDBGBLOCK db;\r\nmemset(&db, 0, sizeof(db));\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\niReturn = usb_control_msg(pdx->udev, usb_rcvctrlpipe(pdx->udev, 0),\r\nDB_DATA, (D_TO_H | VENDOR | DEVREQ), 0, 0,\r\n&db.iData, sizeof(db.iData), HZ);\r\nif (iReturn == sizeof(db.iData)) {\r\nif (copy_to_user(pDB, &db, sizeof(db)))\r\niReturn = -EFAULT;\r\nelse\r\niReturn = U14ERR_NOERROR;\r\n} else\r\ndev_err(&pdx->interface->dev, "%s: failed, code %d\n",\r\n__func__, iReturn);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint DbgStopLoop(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn;\r\nunsigned int uState, uErr;\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\niReturn = Get1401State(pdx, &uState, &uErr);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint SetCircular(DEVICE_EXTENSION *pdx, struct transfer_area_desc __user *pTD)\r\n{\r\nint iReturn;\r\nbool bToHost;\r\nstruct transfer_area_desc td;\r\nif (copy_from_user(&td, pTD, sizeof(td)))\r\nreturn -EFAULT;\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s: area:%d, size:%08x\n",\r\n__func__, td.wAreaNum, td.dwLength);\r\nbToHost = td.eSize != 0;\r\niReturn =\r\nSetArea(pdx, td.wAreaNum,\r\n(char __user *)((unsigned long)td.lpvBuff), td.dwLength,\r\ntrue, bToHost);\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint GetCircBlock(DEVICE_EXTENSION *pdx, TCIRCBLOCK __user *pCB)\r\n{\r\nint iReturn = U14ERR_NOERROR;\r\nunsigned int nArea;\r\nTCIRCBLOCK cb;\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\nif (copy_from_user(&cb, pCB, sizeof(cb)))\r\nreturn -EFAULT;\r\nmutex_lock(&pdx->io_mutex);\r\nnArea = cb.nArea;\r\ncb.dwOffset = 0;\r\ncb.dwSize = 0;\r\nif (nArea < MAX_TRANSAREAS) {\r\nTRANSAREA *pArea = &pdx->rTransDef[nArea];\r\nspin_lock_irq(&pdx->stagedLock);\r\nif ((pArea->bUsed) && (pArea->bCircular) &&\r\n(pArea->bCircToHost)) {\r\nif (pArea->aBlocks[0].dwSize > 0) {\r\ncb.dwOffset = pArea->aBlocks[0].dwOffset;\r\ncb.dwSize = pArea->aBlocks[0].dwSize;\r\ndev_dbg(&pdx->interface->dev,\r\n"%s: return block 0: %d bytes at %d\n",\r\n__func__, cb.dwSize, cb.dwOffset);\r\n}\r\n} else\r\niReturn = U14ERR_NOTSET;\r\nspin_unlock_irq(&pdx->stagedLock);\r\n} else\r\niReturn = U14ERR_BADAREA;\r\nif (copy_to_user(pCB, &cb, sizeof(cb)))\r\niReturn = -EFAULT;\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}\r\nint FreeCircBlock(DEVICE_EXTENSION *pdx, TCIRCBLOCK __user *pCB)\r\n{\r\nint iReturn = U14ERR_NOERROR;\r\nunsigned int nArea, uStart, uSize;\r\nTCIRCBLOCK cb;\r\ndev_dbg(&pdx->interface->dev, "%s\n", __func__);\r\nif (copy_from_user(&cb, pCB, sizeof(cb)))\r\nreturn -EFAULT;\r\nmutex_lock(&pdx->io_mutex);\r\nnArea = cb.nArea;\r\nuStart = cb.dwOffset;\r\nuSize = cb.dwSize;\r\ncb.dwOffset = 0;\r\ncb.dwSize = 0;\r\nif (nArea < MAX_TRANSAREAS) {\r\nTRANSAREA *pArea = &pdx->rTransDef[nArea];\r\nspin_lock_irq(&pdx->stagedLock);\r\nif ((pArea->bUsed) && (pArea->bCircular) &&\r\n(pArea->bCircToHost)) {\r\nbool bWaiting = false;\r\nif ((pArea->aBlocks[0].dwSize >= uSize) &&\r\n(pArea->aBlocks[0].dwOffset == uStart)) {\r\npArea->aBlocks[0].dwSize -= uSize;\r\npArea->aBlocks[0].dwOffset += uSize;\r\nif (pArea->aBlocks[0].dwSize == 0) {\r\nif (pArea->aBlocks[1].dwSize) {\r\npArea->aBlocks[0] = pArea->aBlocks[1];\r\npArea->aBlocks[1].dwSize = 0;\r\npArea->aBlocks[1].dwOffset = 0;\r\n} else\r\npArea->aBlocks[0].dwOffset = 0;\r\n}\r\ndev_dbg(&pdx->interface->dev,\r\n"%s: free %d bytes at %d, return %d bytes at %d, wait=%d\n",\r\n__func__, uSize, uStart,\r\npArea->aBlocks[0].dwSize,\r\npArea->aBlocks[0].dwOffset,\r\npdx->bXFerWaiting);\r\nif (pArea->aBlocks[0].dwSize > 0) {\r\ncb.dwOffset =\r\npArea->aBlocks[0].dwOffset;\r\ncb.dwSize = pArea->aBlocks[0].dwSize;\r\n}\r\nbWaiting = pdx->bXFerWaiting;\r\nif (bWaiting && pdx->bStagedUrbPending) {\r\ndev_err(&pdx->interface->dev,\r\n"%s: ERROR: waiting xfer and staged Urb pending!\n",\r\n__func__);\r\nbWaiting = false;\r\n}\r\n} else {\r\ndev_err(&pdx->interface->dev,\r\n"%s: ERROR: freeing %d bytes at %d, block 0 is %d bytes at %d\n",\r\n__func__, uSize, uStart,\r\npArea->aBlocks[0].dwSize,\r\npArea->aBlocks[0].dwOffset);\r\niReturn = U14ERR_NOMEMORY;\r\n}\r\nif (bWaiting) {\r\nint RWMStat =\r\nReadWriteMem(pdx, !pdx->rDMAInfo.bOutWard,\r\npdx->rDMAInfo.wIdent,\r\npdx->rDMAInfo.dwOffset,\r\npdx->rDMAInfo.dwSize);\r\nif (RWMStat != U14ERR_NOERROR)\r\ndev_err(&pdx->interface->dev,\r\n"%s: rw setup failed %d\n",\r\n__func__, RWMStat);\r\n}\r\n} else\r\niReturn = U14ERR_NOTSET;\r\nspin_unlock_irq(&pdx->stagedLock);\r\n} else\r\niReturn = U14ERR_BADAREA;\r\nif (copy_to_user(pCB, &cb, sizeof(cb)))\r\niReturn = -EFAULT;\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn iReturn;\r\n}
