static int snd_opti9xx_init(struct snd_opti9xx *chip,\r\nunsigned short hardware)\r\n{\r\nstatic int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};\r\nchip->hardware = hardware;\r\nstrcpy(chip->name, snd_opti9xx_names[hardware]);\r\nspin_lock_init(&chip->lock);\r\nchip->irq = -1;\r\n#ifndef OPTi93X\r\n#ifdef CONFIG_PNP\r\nif (isapnp && chip->mc_base)\r\nchip->mc_base |= 0xc00;\r\nelse\r\n#endif\r\n{\r\nchip->mc_base = 0xf8c;\r\nchip->mc_base_size = opti9xx_mc_size[hardware];\r\n}\r\n#else\r\nchip->mc_base_size = opti9xx_mc_size[hardware];\r\n#endif\r\nswitch (hardware) {\r\n#ifndef OPTi93X\r\ncase OPTi9XX_HW_82C928:\r\ncase OPTi9XX_HW_82C929:\r\nchip->password = (hardware == OPTi9XX_HW_82C928) ? 0xe2 : 0xe3;\r\nchip->pwd_reg = 3;\r\nbreak;\r\ncase OPTi9XX_HW_82C924:\r\ncase OPTi9XX_HW_82C925:\r\nchip->password = 0xe5;\r\nchip->pwd_reg = 3;\r\nbreak;\r\n#else\r\ncase OPTi9XX_HW_82C930:\r\ncase OPTi9XX_HW_82C931:\r\ncase OPTi9XX_HW_82C933:\r\nchip->mc_base = (hardware == OPTi9XX_HW_82C930) ? 0xf8f : 0xf8d;\r\nif (!chip->mc_indir_index)\r\nchip->mc_indir_index = 0xe0e;\r\nchip->password = 0xe4;\r\nchip->pwd_reg = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nsnd_printk(KERN_ERR "chip %d not supported\n", hardware);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char snd_opti9xx_read(struct snd_opti9xx *chip,\r\nunsigned char reg)\r\n{\r\nunsigned long flags;\r\nunsigned char retval = 0xff;\r\nspin_lock_irqsave(&chip->lock, flags);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\nswitch (chip->hardware) {\r\n#ifndef OPTi93X\r\ncase OPTi9XX_HW_82C924:\r\ncase OPTi9XX_HW_82C925:\r\nif (reg > 7) {\r\noutb(reg, chip->mc_base + 8);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\nretval = inb(chip->mc_base + 9);\r\nbreak;\r\n}\r\ncase OPTi9XX_HW_82C928:\r\ncase OPTi9XX_HW_82C929:\r\nretval = inb(chip->mc_base + reg);\r\nbreak;\r\n#else\r\ncase OPTi9XX_HW_82C930:\r\ncase OPTi9XX_HW_82C931:\r\ncase OPTi9XX_HW_82C933:\r\noutb(reg, chip->mc_indir_index);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\nretval = inb(chip->mc_indir_index + 1);\r\nbreak;\r\n#endif\r\ndefault:\r\nsnd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,\r\nunsigned char value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\nswitch (chip->hardware) {\r\n#ifndef OPTi93X\r\ncase OPTi9XX_HW_82C924:\r\ncase OPTi9XX_HW_82C925:\r\nif (reg > 7) {\r\noutb(reg, chip->mc_base + 8);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\noutb(value, chip->mc_base + 9);\r\nbreak;\r\n}\r\ncase OPTi9XX_HW_82C928:\r\ncase OPTi9XX_HW_82C929:\r\noutb(value, chip->mc_base + reg);\r\nbreak;\r\n#else\r\ncase OPTi9XX_HW_82C930:\r\ncase OPTi9XX_HW_82C931:\r\ncase OPTi9XX_HW_82C933:\r\noutb(reg, chip->mc_indir_index);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\noutb(value, chip->mc_indir_index + 1);\r\nbreak;\r\n#endif\r\ndefault:\r\nsnd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int snd_opti9xx_configure(struct snd_opti9xx *chip,\r\nlong port,\r\nint irq, int dma1, int dma2,\r\nlong mpu_port, int mpu_irq)\r\n{\r\nunsigned char wss_base_bits;\r\nunsigned char irq_bits;\r\nunsigned char dma_bits;\r\nunsigned char mpu_port_bits = 0;\r\nunsigned char mpu_irq_bits;\r\nswitch (chip->hardware) {\r\n#ifndef OPTi93X\r\ncase OPTi9XX_HW_82C924:\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0xf0, 0xfc);\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x02);\r\ncase OPTi9XX_HW_82C925:\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2), 0x00, 0x20);\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);\r\n#ifdef CS4231\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);\r\n#else\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x00, 0x02);\r\n#endif\r\nbreak;\r\ncase OPTi9XX_HW_82C928:\r\ncase OPTi9XX_HW_82C929:\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2), 0x00, 0x20);\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0x00, 0x0c);\r\n#ifdef CS4231\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);\r\n#else\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x00, 0x02);\r\n#endif\r\nbreak;\r\n#else\r\ncase OPTi9XX_HW_82C931:\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(20), 0x04, 0x0c);\r\ncase OPTi9XX_HW_82C933:\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(21), 0x82, 0xff);\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(26), 0x01, 0x01);\r\ncase OPTi9XX_HW_82C930:\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x03);\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0x00, 0xff);\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0x10 |\r\n(chip->hardware == OPTi9XX_HW_82C930 ? 0x00 : 0x04),\r\n0x34);\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x20, 0xbf);\r\nbreak;\r\n#endif\r\ndefault:\r\nsnd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);\r\nreturn -EINVAL;\r\n}\r\nswitch (port & 0x3ff) {\r\ncase 0x130:\r\nchip->wss_base = 0x530;\r\nwss_base_bits = 0x00;\r\nbreak;\r\ncase 0x204:\r\nchip->wss_base = 0x604;\r\nwss_base_bits = 0x03;\r\nbreak;\r\ncase 0x280:\r\nchip->wss_base = 0xe80;\r\nwss_base_bits = 0x01;\r\nbreak;\r\ncase 0x340:\r\nchip->wss_base = 0xf40;\r\nwss_base_bits = 0x02;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING "WSS port 0x%lx not valid\n", port);\r\ngoto __skip_base;\r\n}\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), wss_base_bits << 4, 0x30);\r\n__skip_base:\r\nswitch (irq) {\r\ncase 5:\r\nirq_bits = 0x05;\r\nbreak;\r\ncase 7:\r\nirq_bits = 0x01;\r\nbreak;\r\ncase 9:\r\nirq_bits = 0x02;\r\nbreak;\r\ncase 10:\r\nirq_bits = 0x03;\r\nbreak;\r\ncase 11:\r\nirq_bits = 0x04;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING "WSS irq # %d not valid\n", irq);\r\ngoto __skip_resources;\r\n}\r\nswitch (dma1) {\r\ncase 0:\r\ndma_bits = 0x01;\r\nbreak;\r\ncase 1:\r\ndma_bits = 0x02;\r\nbreak;\r\ncase 3:\r\ndma_bits = 0x03;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING "WSS dma1 # %d not valid\n", dma1);\r\ngoto __skip_resources;\r\n}\r\n#if defined(CS4231) || defined(OPTi93X)\r\nif (dma1 == dma2) {\r\nsnd_printk(KERN_ERR "don't want to share dmas\n");\r\nreturn -EBUSY;\r\n}\r\nswitch (dma2) {\r\ncase 0:\r\ncase 1:\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING "WSS dma2 # %d not valid\n", dma2);\r\ngoto __skip_resources;\r\n}\r\ndma_bits |= 0x04;\r\n#endif\r\n#ifndef OPTi93X\r\noutb(irq_bits << 3 | dma_bits, chip->wss_base);\r\n#else\r\nsnd_opti9xx_write(chip, OPTi9XX_MC_REG(3), (irq_bits << 3 | dma_bits));\r\n#endif\r\n__skip_resources:\r\nif (chip->hardware > OPTi9XX_HW_82C928) {\r\nswitch (mpu_port) {\r\ncase 0:\r\ncase -1:\r\nbreak;\r\ncase 0x300:\r\nmpu_port_bits = 0x03;\r\nbreak;\r\ncase 0x310:\r\nmpu_port_bits = 0x02;\r\nbreak;\r\ncase 0x320:\r\nmpu_port_bits = 0x01;\r\nbreak;\r\ncase 0x330:\r\nmpu_port_bits = 0x00;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING\r\n"MPU-401 port 0x%lx not valid\n", mpu_port);\r\ngoto __skip_mpu;\r\n}\r\nswitch (mpu_irq) {\r\ncase 5:\r\nmpu_irq_bits = 0x02;\r\nbreak;\r\ncase 7:\r\nmpu_irq_bits = 0x03;\r\nbreak;\r\ncase 9:\r\nmpu_irq_bits = 0x00;\r\nbreak;\r\ncase 10:\r\nmpu_irq_bits = 0x01;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING "MPU-401 irq # %d not valid\n",\r\nmpu_irq);\r\ngoto __skip_mpu;\r\n}\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6),\r\n(mpu_port <= 0) ? 0x00 :\r\n0x80 | mpu_port_bits << 5 | mpu_irq_bits << 3,\r\n0xf8);\r\n}\r\n__skip_mpu:\r\nreturn 0;\r\n}\r\nstatic int snd_opti93x_mixer(struct snd_wss *chip)\r\n{\r\nstruct snd_card *card;\r\nunsigned int idx;\r\nstruct snd_ctl_elem_id id1, id2;\r\nint err;\r\nif (snd_BUG_ON(!chip || !chip->pcm))\r\nreturn -EINVAL;\r\ncard = chip->card;\r\nstrcpy(card->mixername, chip->pcm->name);\r\nmemset(&id1, 0, sizeof(id1));\r\nmemset(&id2, 0, sizeof(id2));\r\nid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(id1.name, "Aux Playback Switch");\r\nstrcpy(id2.name, "CD Playback Switch");\r\nerr = snd_ctl_rename_id(card, &id1, &id2);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "Cannot rename opti93x control\n");\r\nreturn err;\r\n}\r\nstrcpy(id1.name, "Aux Playback Switch"); id1.index = 1;\r\nstrcpy(id2.name, "FM Playback Switch");\r\nerr = snd_ctl_rename_id(card, &id1, &id2);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "Cannot rename opti93x control\n");\r\nreturn err;\r\n}\r\nstrcpy(id1.name, "Aux Playback Volume"); id1.index = 1;\r\nsnd_ctl_remove_id(card, &id1);\r\nid1.index = 0;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_opti93x_controls); idx++) {\r\nstrcpy(id1.name, snd_opti93x_controls[idx].name);\r\nsnd_ctl_remove_id(card, &id1);\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_opti93x_controls[idx], chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_opti9xx *chip = dev_id;\r\nstruct snd_wss *codec = chip->codec;\r\nunsigned char status;\r\nif (!codec)\r\nreturn IRQ_HANDLED;\r\nstatus = snd_opti9xx_read(chip, OPTi9XX_MC_REG(11));\r\nif ((status & OPTi93X_IRQ_PLAYBACK) && codec->playback_substream)\r\nsnd_pcm_period_elapsed(codec->playback_substream);\r\nif ((status & OPTi93X_IRQ_CAPTURE) && codec->capture_substream) {\r\nsnd_wss_overrange(codec);\r\nsnd_pcm_period_elapsed(codec->capture_substream);\r\n}\r\noutb(0x00, OPTi93X_PORT(codec, STATUS));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_opti9xx_read_check(struct snd_opti9xx *chip)\r\n{\r\nunsigned char value;\r\n#ifdef OPTi93X\r\nunsigned long flags;\r\n#endif\r\nchip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size,\r\n"OPTi9xx MC");\r\nif (chip->res_mc_base == NULL)\r\nreturn -EBUSY;\r\n#ifndef OPTi93X\r\nvalue = snd_opti9xx_read(chip, OPTi9XX_MC_REG(1));\r\nif (value != 0xff && value != inb(chip->mc_base + OPTi9XX_MC_REG(1)))\r\nif (value == snd_opti9xx_read(chip, OPTi9XX_MC_REG(1)))\r\nreturn 0;\r\n#else\r\nchip->res_mc_indir = request_region(chip->mc_indir_index, 2,\r\n"OPTi93x MC");\r\nif (chip->res_mc_indir == NULL)\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&chip->lock, flags);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\noutb(((chip->mc_indir_index & 0x1f0) >> 4), chip->mc_base);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nvalue = snd_opti9xx_read(chip, OPTi9XX_MC_REG(7));\r\nsnd_opti9xx_write(chip, OPTi9XX_MC_REG(7), 0xff - value);\r\nif (snd_opti9xx_read(chip, OPTi9XX_MC_REG(7)) == 0xff - value)\r\nreturn 0;\r\nrelease_and_free_resource(chip->res_mc_indir);\r\nchip->res_mc_indir = NULL;\r\n#endif\r\nrelease_and_free_resource(chip->res_mc_base);\r\nchip->res_mc_base = NULL;\r\nreturn -ENODEV;\r\n}\r\nstatic int snd_card_opti9xx_pnp(struct snd_opti9xx *chip,\r\nstruct pnp_card_link *card,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstruct pnp_dev *pdev;\r\nint err;\r\nstruct pnp_dev *devmpu;\r\n#ifndef OPTi93X\r\nstruct pnp_dev *devmc;\r\n#endif\r\npdev = pnp_request_card_device(card, pid->devs[0].id, NULL);\r\nif (pdev == NULL)\r\nreturn -EBUSY;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "AUDIO pnp configure failure: %d\n", err);\r\nreturn err;\r\n}\r\n#ifdef OPTi93X\r\nport = pnp_port_start(pdev, 0) - 4;\r\nfm_port = pnp_port_start(pdev, 1) + 8;\r\nchip->mc_indir_index = (pnp_port_start(pdev, 3) & ~0xf) | 0xe;\r\n#else\r\ndevmc = pnp_request_card_device(card, pid->devs[2].id, NULL);\r\nif (devmc == NULL)\r\nreturn -EBUSY;\r\nerr = pnp_activate_dev(devmc);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "MC pnp configure failure: %d\n", err);\r\nreturn err;\r\n}\r\nport = pnp_port_start(pdev, 1);\r\nfm_port = pnp_port_start(pdev, 2) + 8;\r\nchip->mc_base = pnp_port_start(devmc, 0) - 1;\r\nchip->mc_base_size = pnp_port_len(devmc, 0) + 1;\r\n#endif\r\nirq = pnp_irq(pdev, 0);\r\ndma1 = pnp_dma(pdev, 0);\r\n#if defined(CS4231) || defined(OPTi93X)\r\ndma2 = pnp_dma(pdev, 1);\r\n#endif\r\ndevmpu = pnp_request_card_device(card, pid->devs[1].id, NULL);\r\nif (devmpu && mpu_port > 0) {\r\nerr = pnp_activate_dev(devmpu);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "MPU401 pnp configure failure\n");\r\nmpu_port = -1;\r\n} else {\r\nmpu_port = pnp_port_start(devmpu, 0);\r\nmpu_irq = pnp_irq(devmpu, 0);\r\n}\r\n}\r\nreturn pid->driver_data;\r\n}\r\nstatic void snd_card_opti9xx_free(struct snd_card *card)\r\n{\r\nstruct snd_opti9xx *chip = card->private_data;\r\nif (chip) {\r\n#ifdef OPTi93X\r\nif (chip->irq > 0) {\r\ndisable_irq(chip->irq);\r\nfree_irq(chip->irq, chip);\r\n}\r\nrelease_and_free_resource(chip->res_mc_indir);\r\n#endif\r\nrelease_and_free_resource(chip->res_mc_base);\r\n}\r\n}\r\nstatic int snd_opti9xx_probe(struct snd_card *card)\r\n{\r\nstatic long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};\r\nint error;\r\nint xdma2;\r\nstruct snd_opti9xx *chip = card->private_data;\r\nstruct snd_wss *codec;\r\n#ifdef CS4231\r\nstruct snd_timer *timer;\r\n#endif\r\nstruct snd_pcm *pcm;\r\nstruct snd_rawmidi *rmidi;\r\nstruct snd_hwdep *synth;\r\n#if defined(CS4231) || defined(OPTi93X)\r\nxdma2 = dma2;\r\n#else\r\nxdma2 = -1;\r\n#endif\r\nif (port == SNDRV_AUTO_PORT) {\r\nport = snd_legacy_find_free_ioport(possible_ports, 4);\r\nif (port < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free WSS port\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nerror = snd_opti9xx_configure(chip, port, irq, dma1, xdma2,\r\nmpu_port, mpu_irq);\r\nif (error)\r\nreturn error;\r\nerror = snd_wss_create(card, chip->wss_base + 4, -1, irq, dma1, xdma2,\r\n#ifdef OPTi93X\r\nWSS_HW_OPTI93X, WSS_HWSHARE_IRQ,\r\n#else\r\nWSS_HW_DETECT, 0,\r\n#endif\r\n&codec);\r\nif (error < 0)\r\nreturn error;\r\nchip->codec = codec;\r\nerror = snd_wss_pcm(codec, 0, &pcm);\r\nif (error < 0)\r\nreturn error;\r\nerror = snd_wss_mixer(codec);\r\nif (error < 0)\r\nreturn error;\r\n#ifdef OPTi93X\r\nerror = snd_opti93x_mixer(codec);\r\nif (error < 0)\r\nreturn error;\r\n#endif\r\n#ifdef CS4231\r\nerror = snd_wss_timer(codec, 0, &timer);\r\nif (error < 0)\r\nreturn error;\r\n#endif\r\n#ifdef OPTi93X\r\nerror = request_irq(irq, snd_opti93x_interrupt,\r\n0, DEV_NAME" - WSS", chip);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", irq);\r\nreturn error;\r\n}\r\n#endif\r\nchip->irq = irq;\r\nstrcpy(card->driver, chip->name);\r\nsprintf(card->shortname, "OPTi %s", card->driver);\r\n#if defined(CS4231) || defined(OPTi93X)\r\nsprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d&%d",\r\ncard->shortname, pcm->name,\r\nchip->wss_base + 4, irq, dma1, xdma2);\r\n#else\r\nsprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d",\r\ncard->shortname, pcm->name, chip->wss_base + 4, irq, dma1);\r\n#endif\r\nif (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)\r\nrmidi = NULL;\r\nelse {\r\nerror = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\r\nmpu_port, 0, mpu_irq, &rmidi);\r\nif (error)\r\nsnd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n",\r\nmpu_port);\r\n}\r\nif (fm_port > 0 && fm_port != SNDRV_AUTO_PORT) {\r\nstruct snd_opl3 *opl3 = NULL;\r\n#ifndef OPTi93X\r\nif (chip->hardware == OPTi9XX_HW_82C928 ||\r\nchip->hardware == OPTi9XX_HW_82C929 ||\r\nchip->hardware == OPTi9XX_HW_82C924) {\r\nstruct snd_opl4 *opl4;\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2),\r\n0x20, 0x20);\r\nif (snd_opl4_create(card, fm_port, fm_port - 8,\r\n2, &opl3, &opl4) < 0) {\r\nsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2),\r\n0x00, 0x20);\r\n}\r\n}\r\n#endif\r\nif (!opl3 && snd_opl3_create(card, fm_port, fm_port + 2,\r\nOPL3_HW_AUTO, 0, &opl3) < 0) {\r\nsnd_printk(KERN_WARNING "no OPL device at 0x%lx-0x%lx\n",\r\nfm_port, fm_port + 4 - 1);\r\n}\r\nif (opl3) {\r\nerror = snd_opl3_hwdep_new(opl3, 0, 1, &synth);\r\nif (error < 0)\r\nreturn error;\r\n}\r\n}\r\nreturn snd_card_register(card);\r\n}\r\nstatic int snd_opti9xx_card_new(struct device *pdev, struct snd_card **cardp)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nerr = snd_card_new(pdev, index, id, THIS_MODULE,\r\nsizeof(struct snd_opti9xx), &card);\r\nif (err < 0)\r\nreturn err;\r\ncard->private_free = snd_card_opti9xx_free;\r\n*cardp = card;\r\nreturn 0;\r\n}\r\nstatic int snd_opti9xx_isa_match(struct device *devptr,\r\nunsigned int dev)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (snd_opti9xx_pnp_is_probed)\r\nreturn 0;\r\nif (isapnp)\r\nreturn 0;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int snd_opti9xx_isa_probe(struct device *devptr,\r\nunsigned int dev)\r\n{\r\nstruct snd_card *card;\r\nint error;\r\nstatic long possible_mpu_ports[] = {0x300, 0x310, 0x320, 0x330, -1};\r\n#ifdef OPTi93X\r\nstatic int possible_irqs[] = {5, 9, 10, 11, 7, -1};\r\n#else\r\nstatic int possible_irqs[] = {9, 10, 11, 7, -1};\r\n#endif\r\nstatic int possible_mpu_irqs[] = {5, 9, 10, 7, -1};\r\nstatic int possible_dma1s[] = {3, 1, 0, -1};\r\n#if defined(CS4231) || defined(OPTi93X)\r\nstatic int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};\r\n#endif\r\nif (mpu_port == SNDRV_AUTO_PORT) {\r\nif ((mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2)) < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free MPU401 port\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (irq == SNDRV_AUTO_IRQ) {\r\nif ((irq = snd_legacy_find_free_irq(possible_irqs)) < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free IRQ\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (mpu_irq == SNDRV_AUTO_IRQ) {\r\nif ((mpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs)) < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free MPU401 IRQ\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma1 == SNDRV_AUTO_DMA) {\r\nif ((dma1 = snd_legacy_find_free_dma(possible_dma1s)) < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free DMA1\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\n#if defined(CS4231) || defined(OPTi93X)\r\nif (dma2 == SNDRV_AUTO_DMA) {\r\nif ((dma2 = snd_legacy_find_free_dma(possible_dma2s[dma1 % 4])) < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free DMA2\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\n#endif\r\nerror = snd_opti9xx_card_new(devptr, &card);\r\nif (error < 0)\r\nreturn error;\r\nif ((error = snd_card_opti9xx_detect(card, card->private_data)) < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\nif ((error = snd_opti9xx_probe(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\ndev_set_drvdata(devptr, card);\r\nreturn 0;\r\n}\r\nstatic int snd_opti9xx_isa_remove(struct device *devptr,\r\nunsigned int dev)\r\n{\r\nsnd_card_free(dev_get_drvdata(devptr));\r\nreturn 0;\r\n}\r\nstatic int snd_opti9xx_suspend(struct snd_card *card)\r\n{\r\nstruct snd_opti9xx *chip = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nchip->codec->suspend(chip->codec);\r\nreturn 0;\r\n}\r\nstatic int snd_opti9xx_resume(struct snd_card *card)\r\n{\r\nstruct snd_opti9xx *chip = card->private_data;\r\nint error, xdma2;\r\n#if defined(CS4231) || defined(OPTi93X)\r\nxdma2 = dma2;\r\n#else\r\nxdma2 = -1;\r\n#endif\r\nerror = snd_opti9xx_configure(chip, port, irq, dma1, xdma2,\r\nmpu_port, mpu_irq);\r\nif (error)\r\nreturn error;\r\nchip->codec->resume(chip->codec);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int snd_opti9xx_isa_suspend(struct device *dev, unsigned int n,\r\npm_message_t state)\r\n{\r\nreturn snd_opti9xx_suspend(dev_get_drvdata(dev));\r\n}\r\nstatic int snd_opti9xx_isa_resume(struct device *dev, unsigned int n)\r\n{\r\nreturn snd_opti9xx_resume(dev_get_drvdata(dev));\r\n}\r\nstatic int snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstruct snd_card *card;\r\nint error, hw;\r\nstruct snd_opti9xx *chip;\r\nif (snd_opti9xx_pnp_is_probed)\r\nreturn -EBUSY;\r\nif (! isapnp)\r\nreturn -ENODEV;\r\nerror = snd_opti9xx_card_new(&pcard->card->dev, &card);\r\nif (error < 0)\r\nreturn error;\r\nchip = card->private_data;\r\nhw = snd_card_opti9xx_pnp(chip, pcard, pid);\r\nswitch (hw) {\r\ncase 0x0924:\r\nhw = OPTi9XX_HW_82C924;\r\nbreak;\r\ncase 0x0925:\r\nhw = OPTi9XX_HW_82C925;\r\nbreak;\r\ncase 0x0931:\r\nhw = OPTi9XX_HW_82C931;\r\nbreak;\r\ndefault:\r\nsnd_card_free(card);\r\nreturn -ENODEV;\r\n}\r\nif ((error = snd_opti9xx_init(chip, hw))) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\nerror = snd_opti9xx_read_check(chip);\r\nif (error) {\r\nsnd_printk(KERN_ERR "OPTI chip not found\n");\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\nif ((error = snd_opti9xx_probe(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\npnp_set_card_drvdata(pcard, card);\r\nsnd_opti9xx_pnp_is_probed = 1;\r\nreturn 0;\r\n}\r\nstatic void snd_opti9xx_pnp_remove(struct pnp_card_link *pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\nsnd_opti9xx_pnp_is_probed = 0;\r\n}\r\nstatic int snd_opti9xx_pnp_suspend(struct pnp_card_link *pcard,\r\npm_message_t state)\r\n{\r\nreturn snd_opti9xx_suspend(pnp_get_card_drvdata(pcard));\r\n}\r\nstatic int snd_opti9xx_pnp_resume(struct pnp_card_link *pcard)\r\n{\r\nreturn snd_opti9xx_resume(pnp_get_card_drvdata(pcard));\r\n}\r\nstatic int __init alsa_card_opti9xx_init(void)\r\n{\r\n#ifdef CONFIG_PNP\r\npnp_register_card_driver(&opti9xx_pnpc_driver);\r\nif (snd_opti9xx_pnp_is_probed)\r\nreturn 0;\r\npnp_unregister_card_driver(&opti9xx_pnpc_driver);\r\n#endif\r\nreturn isa_register_driver(&snd_opti9xx_driver, 1);\r\n}\r\nstatic void __exit alsa_card_opti9xx_exit(void)\r\n{\r\nif (!snd_opti9xx_pnp_is_probed) {\r\nisa_unregister_driver(&snd_opti9xx_driver);\r\nreturn;\r\n}\r\n#ifdef CONFIG_PNP\r\npnp_unregister_card_driver(&opti9xx_pnpc_driver);\r\n#endif\r\n}
