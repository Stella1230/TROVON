int obd_connect_flags2str(char *page, int count, __u64 flags, char *sep)\r\n{\r\n__u64 mask = 1;\r\nint i, ret = 0;\r\nfor (i = 0; obd_connect_names[i] != NULL; i++, mask <<= 1) {\r\nif (flags & mask)\r\nret += snprintf(page + ret, count - ret, "%s%s",\r\nret ? sep : "", obd_connect_names[i]);\r\n}\r\nif (flags & ~(mask - 1))\r\nret += snprintf(page + ret, count - ret,\r\n"%sunknown flags "LPX64,\r\nret ? sep : "", flags & ~(mask - 1));\r\nreturn ret;\r\n}\r\nint lprocfs_read_frac_helper(char *buffer, unsigned long count, long val,\r\nint mult)\r\n{\r\nlong decimal_val, frac_val;\r\nint prtn;\r\nif (count < 10)\r\nreturn -EINVAL;\r\ndecimal_val = val / mult;\r\nprtn = snprintf(buffer, count, "%ld", decimal_val);\r\nfrac_val = val % mult;\r\nif (prtn < (count - 4) && frac_val > 0) {\r\nlong temp_frac;\r\nint i, temp_mult = 1, frac_bits = 0;\r\ntemp_frac = frac_val * 10;\r\nbuffer[prtn++] = '.';\r\nwhile (frac_bits < 2 && (temp_frac / mult) < 1) {\r\nbuffer[prtn++] = '0';\r\ntemp_frac *= 10;\r\nfrac_bits++;\r\n}\r\nfor (i = 0; i < (5 - prtn); i++)\r\ntemp_mult *= 10;\r\nfrac_bits = min((int)count - prtn, 3 - frac_bits);\r\nprtn += snprintf(buffer + prtn, frac_bits, "%ld",\r\nfrac_val * temp_mult / mult);\r\nprtn--;\r\nwhile (buffer[prtn] < '1' || buffer[prtn] > '9') {\r\nprtn--;\r\nif (buffer[prtn] == '.') {\r\nprtn--;\r\nbreak;\r\n}\r\n}\r\nprtn++;\r\n}\r\nbuffer[prtn++] = '\n';\r\nreturn prtn;\r\n}\r\nint lprocfs_write_frac_helper(const char *buffer, unsigned long count,\r\nint *val, int mult)\r\n{\r\nchar kernbuf[20], *end, *pbuf;\r\nif (count > (sizeof(kernbuf) - 1))\r\nreturn -EINVAL;\r\nif (copy_from_user(kernbuf, buffer, count))\r\nreturn -EFAULT;\r\nkernbuf[count] = '\0';\r\npbuf = kernbuf;\r\nif (*pbuf == '-') {\r\nmult = -mult;\r\npbuf++;\r\n}\r\n*val = (int)simple_strtoul(pbuf, &end, 10) * mult;\r\nif (pbuf == end)\r\nreturn -EINVAL;\r\nif (end != NULL && *end == '.') {\r\nint temp_val, pow = 1;\r\nint i;\r\npbuf = end + 1;\r\nif (strlen(pbuf) > 5)\r\npbuf[5] = '\0';\r\ntemp_val = (int)simple_strtoul(pbuf, &end, 10) * mult;\r\nif (pbuf < end) {\r\nfor (i = 0; i < (end - pbuf); i++)\r\npow *= 10;\r\n*val += temp_val / pow;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint lprocfs_single_release(struct inode *inode, struct file *file)\r\n{\r\nreturn single_release(inode, file);\r\n}\r\nint lprocfs_seq_release(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_release(inode, file);\r\n}\r\nstruct proc_dir_entry *lprocfs_add_simple(struct proc_dir_entry *root,\r\nchar *name, void *data,\r\nstruct file_operations *fops)\r\n{\r\nstruct proc_dir_entry *proc;\r\numode_t mode = 0;\r\nif (root == NULL || name == NULL || fops == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nif (fops->read)\r\nmode = 0444;\r\nif (fops->write)\r\nmode |= 0200;\r\nproc = proc_create_data(name, mode, root, fops, data);\r\nif (!proc) {\r\nCERROR("LprocFS: No memory to create /proc entry %s", name);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn proc;\r\n}\r\nstruct proc_dir_entry *lprocfs_add_symlink(const char *name,\r\nstruct proc_dir_entry *parent, const char *format, ...)\r\n{\r\nstruct proc_dir_entry *entry;\r\nchar *dest;\r\nva_list ap;\r\nif (parent == NULL || format == NULL)\r\nreturn NULL;\r\nOBD_ALLOC_WAIT(dest, MAX_STRING_SIZE + 1);\r\nif (dest == NULL)\r\nreturn NULL;\r\nva_start(ap, format);\r\nvsnprintf(dest, MAX_STRING_SIZE, format, ap);\r\nva_end(ap);\r\nentry = proc_symlink(name, parent, dest);\r\nif (entry == NULL)\r\nCERROR("LprocFS: Could not create symbolic link from %s to %s",\r\nname, dest);\r\nOBD_FREE(dest, MAX_STRING_SIZE + 1);\r\nreturn entry;\r\n}\r\nint lprocfs_add_vars(struct proc_dir_entry *root, struct lprocfs_vars *list,\r\nvoid *data)\r\n{\r\nif (root == NULL || list == NULL)\r\nreturn -EINVAL;\r\nwhile (list->name != NULL) {\r\nstruct proc_dir_entry *proc;\r\numode_t mode = 0;\r\nif (list->proc_mode != 0000) {\r\nmode = list->proc_mode;\r\n} else if (list->fops) {\r\nif (list->fops->read)\r\nmode = 0444;\r\nif (list->fops->write)\r\nmode |= 0200;\r\n}\r\nproc = proc_create_data(list->name, mode, root,\r\nlist->fops ?: &lprocfs_generic_fops,\r\nlist->data ?: data);\r\nif (proc == NULL)\r\nreturn -ENOMEM;\r\nlist++;\r\n}\r\nreturn 0;\r\n}\r\nvoid lprocfs_remove(struct proc_dir_entry **rooth)\r\n{\r\nproc_remove(*rooth);\r\n*rooth = NULL;\r\n}\r\nvoid lprocfs_remove_proc_entry(const char *name, struct proc_dir_entry *parent)\r\n{\r\nLASSERT(parent != NULL);\r\nremove_proc_entry(name, parent);\r\n}\r\nstruct proc_dir_entry *lprocfs_register(const char *name,\r\nstruct proc_dir_entry *parent,\r\nstruct lprocfs_vars *list, void *data)\r\n{\r\nstruct proc_dir_entry *entry;\r\nentry = proc_mkdir(name, parent);\r\nif (entry == NULL)\r\nGOTO(out, entry = ERR_PTR(-ENOMEM));\r\nif (list != NULL) {\r\nint rc = lprocfs_add_vars(entry, list, data);\r\nif (rc != 0) {\r\nlprocfs_remove(&entry);\r\nentry = ERR_PTR(rc);\r\n}\r\n}\r\nout:\r\nreturn entry;\r\n}\r\nint lprocfs_rd_uint(struct seq_file *m, void *data)\r\n{\r\nreturn seq_printf(m, "%u\n", *(unsigned int *)data);\r\n}\r\nint lprocfs_wr_uint(struct file *file, const char __user *buffer,\r\nunsigned long count, void *data)\r\n{\r\nunsigned *p = data;\r\nchar dummy[MAX_STRING_SIZE + 1], *end;\r\nunsigned long tmp;\r\ndummy[MAX_STRING_SIZE] = '\0';\r\nif (copy_from_user(dummy, buffer, MAX_STRING_SIZE))\r\nreturn -EFAULT;\r\ntmp = simple_strtoul(dummy, &end, 0);\r\nif (dummy == end)\r\nreturn -EINVAL;\r\n*p = (unsigned int)tmp;\r\nreturn count;\r\n}\r\nint lprocfs_rd_u64(struct seq_file *m, void *data)\r\n{\r\nreturn seq_printf(m, LPU64"\n", *(__u64 *)data);\r\n}\r\nint lprocfs_rd_atomic(struct seq_file *m, void *data)\r\n{\r\natomic_t *atom = data;\r\nLASSERT(atom != NULL);\r\nreturn seq_printf(m, "%d\n", atomic_read(atom));\r\n}\r\nint lprocfs_wr_atomic(struct file *file, const char __user *buffer,\r\nunsigned long count, void *data)\r\n{\r\natomic_t *atm = data;\r\nint val = 0;\r\nint rc;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val <= 0)\r\nreturn -ERANGE;\r\natomic_set(atm, val);\r\nreturn count;\r\n}\r\nint lprocfs_rd_uuid(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nLASSERT(obd != NULL);\r\nreturn seq_printf(m, "%s\n", obd->obd_uuid.uuid);\r\n}\r\nint lprocfs_rd_name(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *dev = data;\r\nLASSERT(dev != NULL);\r\nreturn seq_printf(m, "%s\n", dev->obd_name);\r\n}\r\nint lprocfs_rd_blksize(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nrc = seq_printf(m, "%u\n", osfs.os_bsize);\r\nreturn rc;\r\n}\r\nint lprocfs_rd_kbytestotal(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_blocks;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nrc = seq_printf(m, LPU64"\n", result);\r\n}\r\nreturn rc;\r\n}\r\nint lprocfs_rd_kbytesfree(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_bfree;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nrc = seq_printf(m, LPU64"\n", result);\r\n}\r\nreturn rc;\r\n}\r\nint lprocfs_rd_kbytesavail(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_bavail;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nrc = seq_printf(m, LPU64"\n", result);\r\n}\r\nreturn rc;\r\n}\r\nint lprocfs_rd_filestotal(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nrc = seq_printf(m, LPU64"\n", osfs.os_files);\r\nreturn rc;\r\n}\r\nint lprocfs_rd_filesfree(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nrc = seq_printf(m, LPU64"\n", osfs.os_ffree);\r\nreturn rc;\r\n}\r\nint lprocfs_rd_server_uuid(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_import *imp;\r\nchar *imp_state_name = NULL;\r\nint rc = 0;\r\nLASSERT(obd != NULL);\r\nLPROCFS_CLIMP_CHECK(obd);\r\nimp = obd->u.cli.cl_import;\r\nimp_state_name = ptlrpc_import_state_name(imp->imp_state);\r\nrc = seq_printf(m, "%s\t%s%s\n", obd2cli_tgt(obd), imp_state_name,\r\nimp->imp_deactive ? "\tDEACTIVATED" : "");\r\nLPROCFS_CLIMP_EXIT(obd);\r\nreturn rc;\r\n}\r\nint lprocfs_rd_conn_uuid(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct ptlrpc_connection *conn;\r\nint rc = 0;\r\nLASSERT(obd != NULL);\r\nLPROCFS_CLIMP_CHECK(obd);\r\nconn = obd->u.cli.cl_import->imp_connection;\r\nif (conn && obd->u.cli.cl_import)\r\nrc = seq_printf(m, "%s\n", conn->c_remote_uuid.uuid);\r\nelse\r\nrc = seq_printf(m, "%s\n", "<none>");\r\nLPROCFS_CLIMP_EXIT(obd);\r\nreturn rc;\r\n}\r\nvoid lprocfs_stats_collect(struct lprocfs_stats *stats, int idx,\r\nstruct lprocfs_counter *cnt)\r\n{\r\nunsigned int num_entry;\r\nstruct lprocfs_counter *percpu_cntr;\r\nint i;\r\nunsigned long flags = 0;\r\nmemset(cnt, 0, sizeof(*cnt));\r\nif (stats == NULL) {\r\ncnt->lc_count = 1;\r\nreturn;\r\n}\r\ncnt->lc_min = LC_MIN_INIT;\r\nnum_entry = lprocfs_stats_lock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\nfor (i = 0; i < num_entry; i++) {\r\nif (stats->ls_percpu[i] == NULL)\r\ncontinue;\r\npercpu_cntr = lprocfs_stats_counter_get(stats, i, idx);\r\ncnt->lc_count += percpu_cntr->lc_count;\r\ncnt->lc_sum += percpu_cntr->lc_sum;\r\nif (percpu_cntr->lc_min < cnt->lc_min)\r\ncnt->lc_min = percpu_cntr->lc_min;\r\nif (percpu_cntr->lc_max > cnt->lc_max)\r\ncnt->lc_max = percpu_cntr->lc_max;\r\ncnt->lc_sumsquare += percpu_cntr->lc_sumsquare;\r\n}\r\nlprocfs_stats_unlock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\n}\r\nstatic int obd_import_flags2str(struct obd_import *imp, struct seq_file *m)\r\n{\r\nbool first = true;\r\nif (imp->imp_obd->obd_no_recov) {\r\nseq_printf(m, "no_recov");\r\nfirst = false;\r\n}\r\nflag2str(invalid, first);\r\nfirst = false;\r\nflag2str(deactive, first);\r\nflag2str(replayable, first);\r\nflag2str(pingable, first);\r\nreturn 0;\r\n}\r\nstatic void obd_connect_seq_flags2str(struct seq_file *m, __u64 flags, char *sep)\r\n{\r\n__u64 mask = 1;\r\nint i;\r\nbool first = true;\r\nfor (i = 0; obd_connect_names[i] != NULL; i++, mask <<= 1) {\r\nif (flags & mask) {\r\nseq_printf(m, "%s%s",\r\nfirst ? sep : "", obd_connect_names[i]);\r\nfirst = false;\r\n}\r\n}\r\nif (flags & ~(mask - 1))\r\nseq_printf(m, "%sunknown flags "LPX64,\r\nfirst ? sep : "", flags & ~(mask - 1));\r\n}\r\nint lprocfs_rd_import(struct seq_file *m, void *data)\r\n{\r\nstruct lprocfs_counter ret;\r\nstruct lprocfs_counter_header *header;\r\nstruct obd_device *obd = (struct obd_device *)data;\r\nstruct obd_import *imp;\r\nstruct obd_import_conn *conn;\r\nint j;\r\nint k;\r\nint rw = 0;\r\nLASSERT(obd != NULL);\r\nLPROCFS_CLIMP_CHECK(obd);\r\nimp = obd->u.cli.cl_import;\r\nseq_printf(m,\r\n"import:\n"\r\n" name: %s\n"\r\n" target: %s\n"\r\n" state: %s\n"\r\n" instance: %u\n"\r\n" connect_flags: [",\r\nobd->obd_name,\r\nobd2cli_tgt(obd),\r\nptlrpc_import_state_name(imp->imp_state),\r\nimp->imp_connect_data.ocd_instance);\r\nobd_connect_seq_flags2str(m, imp->imp_connect_data.ocd_connect_flags, ", ");\r\nseq_printf(m,\r\n"]\n"\r\n" import_flags: [");\r\nobd_import_flags2str(imp, m);\r\nseq_printf(m,\r\n"]\n"\r\n" connection:\n"\r\n" failover_nids: [");\r\nspin_lock(&imp->imp_lock);\r\nj = 0;\r\nlist_for_each_entry(conn, &imp->imp_conn_list, oic_item) {\r\nseq_printf(m, "%s%s", j ? ", " : "",\r\nlibcfs_nid2str(conn->oic_conn->c_peer.nid));\r\nj++;\r\n}\r\nseq_printf(m,\r\n"]\n"\r\n" current_connection: %s\n"\r\n" connection_attempts: %u\n"\r\n" generation: %u\n"\r\n" in-progress_invalidations: %u\n",\r\nimp->imp_connection == NULL ? "<none>" :\r\nlibcfs_nid2str(imp->imp_connection->c_peer.nid),\r\nimp->imp_conn_cnt,\r\nimp->imp_generation,\r\natomic_read(&imp->imp_inval_count));\r\nspin_unlock(&imp->imp_lock);\r\nif (obd->obd_svc_stats == NULL)\r\ngoto out_climp;\r\nheader = &obd->obd_svc_stats->ls_cnt_header[PTLRPC_REQWAIT_CNTR];\r\nlprocfs_stats_collect(obd->obd_svc_stats, PTLRPC_REQWAIT_CNTR, &ret);\r\nif (ret.lc_count != 0) {\r\n__u64 sum = ret.lc_sum;\r\ndo_div(sum, ret.lc_count);\r\nret.lc_sum = sum;\r\n} else\r\nret.lc_sum = 0;\r\nseq_printf(m,\r\n" rpcs:\n"\r\n" inflight: %u\n"\r\n" unregistering: %u\n"\r\n" timeouts: %u\n"\r\n" avg_waittime: "LPU64" %s\n",\r\natomic_read(&imp->imp_inflight),\r\natomic_read(&imp->imp_unregistering),\r\natomic_read(&imp->imp_timeouts),\r\nret.lc_sum, header->lc_units);\r\nk = 0;\r\nfor(j = 0; j < IMP_AT_MAX_PORTALS; j++) {\r\nif (imp->imp_at.iat_portal[j] == 0)\r\nbreak;\r\nk = max_t(unsigned int, k,\r\nat_get(&imp->imp_at.iat_service_estimate[j]));\r\n}\r\nseq_printf(m,\r\n" service_estimates:\n"\r\n" services: %u sec\n"\r\n" network: %u sec\n",\r\nk,\r\nat_get(&imp->imp_at.iat_net_latency));\r\nseq_printf(m,\r\n" transactions:\n"\r\n" last_replay: "LPU64"\n"\r\n" peer_committed: "LPU64"\n"\r\n" last_checked: "LPU64"\n",\r\nimp->imp_last_replay_transno,\r\nimp->imp_peer_committed_transno,\r\nimp->imp_last_transno_checked);\r\nfor (rw = 0; rw <= 1; rw++) {\r\nlprocfs_stats_collect(obd->obd_svc_stats,\r\nPTLRPC_LAST_CNTR + BRW_READ_BYTES + rw,\r\n&ret);\r\nif (ret.lc_sum > 0 && ret.lc_count > 0) {\r\n__u64 sum = ret.lc_sum;\r\ndo_div(sum, ret.lc_count);\r\nret.lc_sum = sum;\r\nseq_printf(m,\r\n" %s_data_averages:\n"\r\n" bytes_per_rpc: "LPU64"\n",\r\nrw ? "write" : "read",\r\nret.lc_sum);\r\n}\r\nk = (int)ret.lc_sum;\r\nj = opcode_offset(OST_READ + rw) + EXTRA_MAX_OPCODES;\r\nheader = &obd->obd_svc_stats->ls_cnt_header[j];\r\nlprocfs_stats_collect(obd->obd_svc_stats, j, &ret);\r\nif (ret.lc_sum > 0 && ret.lc_count != 0) {\r\n__u64 sum = ret.lc_sum;\r\ndo_div(sum, ret.lc_count);\r\nret.lc_sum = sum;\r\nseq_printf(m,\r\n" %s_per_rpc: "LPU64"\n",\r\nheader->lc_units, ret.lc_sum);\r\nj = (int)ret.lc_sum;\r\nif (j > 0)\r\nseq_printf(m,\r\n" MB_per_sec: %u.%.02u\n",\r\nk / j, (100 * k / j) % 100);\r\n}\r\n}\r\nout_climp:\r\nLPROCFS_CLIMP_EXIT(obd);\r\nreturn 0;\r\n}\r\nint lprocfs_rd_state(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = (struct obd_device *)data;\r\nstruct obd_import *imp;\r\nint j, k;\r\nLASSERT(obd != NULL);\r\nLPROCFS_CLIMP_CHECK(obd);\r\nimp = obd->u.cli.cl_import;\r\nseq_printf(m, "current_state: %s\n",\r\nptlrpc_import_state_name(imp->imp_state));\r\nseq_printf(m, "state_history:\n");\r\nk = imp->imp_state_hist_idx;\r\nfor (j = 0; j < IMP_STATE_HIST_LEN; j++) {\r\nstruct import_state_hist *ish =\r\n&imp->imp_state_hist[(k + j) % IMP_STATE_HIST_LEN];\r\nif (ish->ish_state == 0)\r\ncontinue;\r\nseq_printf(m, " - ["CFS_TIME_T", %s]\n",\r\nish->ish_time,\r\nptlrpc_import_state_name(ish->ish_state));\r\n}\r\nLPROCFS_CLIMP_EXIT(obd);\r\nreturn 0;\r\n}\r\nint lprocfs_at_hist_helper(struct seq_file *m, struct adaptive_timeout *at)\r\n{\r\nint i;\r\nfor (i = 0; i < AT_BINS; i++)\r\nseq_printf(m, "%3u ", at->at_hist[i]);\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nint lprocfs_rd_timeouts(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = (struct obd_device *)data;\r\nstruct obd_import *imp;\r\nunsigned int cur, worst;\r\ntime_t now, worstt;\r\nstruct dhms ts;\r\nint i;\r\nLASSERT(obd != NULL);\r\nLPROCFS_CLIMP_CHECK(obd);\r\nimp = obd->u.cli.cl_import;\r\nnow = cfs_time_current_sec();\r\ns2dhms(&ts, now - imp->imp_last_reply_time);\r\nseq_printf(m, "%-10s : %ld, "DHMS_FMT" ago\n",\r\n"last reply", imp->imp_last_reply_time, DHMS_VARS(&ts));\r\ncur = at_get(&imp->imp_at.iat_net_latency);\r\nworst = imp->imp_at.iat_net_latency.at_worst_ever;\r\nworstt = imp->imp_at.iat_net_latency.at_worst_time;\r\ns2dhms(&ts, now - worstt);\r\nseq_printf(m, "%-10s : cur %3u worst %3u (at %ld, "DHMS_FMT" ago) ",\r\n"network", cur, worst, worstt, DHMS_VARS(&ts));\r\nlprocfs_at_hist_helper(m, &imp->imp_at.iat_net_latency);\r\nfor(i = 0; i < IMP_AT_MAX_PORTALS; i++) {\r\nif (imp->imp_at.iat_portal[i] == 0)\r\nbreak;\r\ncur = at_get(&imp->imp_at.iat_service_estimate[i]);\r\nworst = imp->imp_at.iat_service_estimate[i].at_worst_ever;\r\nworstt = imp->imp_at.iat_service_estimate[i].at_worst_time;\r\ns2dhms(&ts, now - worstt);\r\nseq_printf(m, "portal %-2d : cur %3u worst %3u (at %ld, "\r\nDHMS_FMT" ago) ", imp->imp_at.iat_portal[i],\r\ncur, worst, worstt, DHMS_VARS(&ts));\r\nlprocfs_at_hist_helper(m, &imp->imp_at.iat_service_estimate[i]);\r\n}\r\nLPROCFS_CLIMP_EXIT(obd);\r\nreturn 0;\r\n}\r\nint lprocfs_rd_connect_flags(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\n__u64 flags;\r\nLPROCFS_CLIMP_CHECK(obd);\r\nflags = obd->u.cli.cl_import->imp_connect_data.ocd_connect_flags;\r\nseq_printf(m, "flags="LPX64"\n", flags);\r\nobd_connect_seq_flags2str(m, flags, "\n");\r\nseq_printf(m, "\n");\r\nLPROCFS_CLIMP_EXIT(obd);\r\nreturn 0;\r\n}\r\nint lprocfs_rd_num_exports(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nLASSERT(obd != NULL);\r\nreturn seq_printf(m, "%u\n", obd->obd_num_exports);\r\n}\r\nint lprocfs_rd_numrefs(struct seq_file *m, void *data)\r\n{\r\nstruct obd_type *class = (struct obd_type*) data;\r\nLASSERT(class != NULL);\r\nreturn seq_printf(m, "%d\n", class->typ_refcnt);\r\n}\r\nint lprocfs_obd_setup(struct obd_device *obd, struct lprocfs_vars *list)\r\n{\r\nint rc = 0;\r\nLASSERT(obd != NULL);\r\nLASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);\r\nLASSERT(obd->obd_type->typ_procroot != NULL);\r\nobd->obd_proc_entry = lprocfs_register(obd->obd_name,\r\nobd->obd_type->typ_procroot,\r\nlist, obd);\r\nif (IS_ERR(obd->obd_proc_entry)) {\r\nrc = PTR_ERR(obd->obd_proc_entry);\r\nCERROR("error %d setting up lprocfs for %s\n",rc,obd->obd_name);\r\nobd->obd_proc_entry = NULL;\r\n}\r\nreturn rc;\r\n}\r\nint lprocfs_obd_cleanup(struct obd_device *obd)\r\n{\r\nif (!obd)\r\nreturn -EINVAL;\r\nif (obd->obd_proc_exports_entry) {\r\nlprocfs_remove(&obd->obd_proc_exports_entry);\r\nobd->obd_proc_exports_entry = NULL;\r\n}\r\nif (obd->obd_proc_entry) {\r\nlprocfs_remove(&obd->obd_proc_entry);\r\nobd->obd_proc_entry = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lprocfs_free_client_stats(struct nid_stat *client_stat)\r\n{\r\nCDEBUG(D_CONFIG, "stat %p - data %p/%p\n", client_stat,\r\nclient_stat->nid_proc, client_stat->nid_stats);\r\nLASSERTF(atomic_read(&client_stat->nid_exp_ref_count) == 0,\r\n"nid %s:count %d\n", libcfs_nid2str(client_stat->nid),\r\natomic_read(&client_stat->nid_exp_ref_count));\r\nif (client_stat->nid_proc)\r\nlprocfs_remove(&client_stat->nid_proc);\r\nif (client_stat->nid_stats)\r\nlprocfs_free_stats(&client_stat->nid_stats);\r\nif (client_stat->nid_ldlm_stats)\r\nlprocfs_free_stats(&client_stat->nid_ldlm_stats);\r\nOBD_FREE_PTR(client_stat);\r\nreturn;\r\n}\r\nvoid lprocfs_free_per_client_stats(struct obd_device *obd)\r\n{\r\nstruct cfs_hash *hash = obd->obd_nid_stats_hash;\r\nstruct nid_stat *stat;\r\nwhile (!list_empty(&obd->obd_nid_stats)) {\r\nstat = list_entry(obd->obd_nid_stats.next,\r\nstruct nid_stat, nid_list);\r\nlist_del_init(&stat->nid_list);\r\ncfs_hash_del(hash, &stat->nid, &stat->nid_hash);\r\nlprocfs_free_client_stats(stat);\r\n}\r\n}\r\nstruct lprocfs_stats *lprocfs_alloc_stats(unsigned int num,\r\nenum lprocfs_stats_flags flags)\r\n{\r\nstruct lprocfs_stats *stats;\r\nunsigned int num_entry;\r\nunsigned int percpusize = 0;\r\nint i;\r\nif (num == 0)\r\nreturn NULL;\r\nif (lprocfs_no_percpu_stats != 0)\r\nflags |= LPROCFS_STATS_FLAG_NOPERCPU;\r\nif (flags & LPROCFS_STATS_FLAG_NOPERCPU)\r\nnum_entry = 1;\r\nelse\r\nnum_entry = num_possible_cpus();\r\nLIBCFS_ALLOC(stats, offsetof(typeof(*stats), ls_percpu[num_entry]));\r\nif (stats == NULL)\r\nreturn NULL;\r\nstats->ls_num = num;\r\nstats->ls_flags = flags;\r\nspin_lock_init(&stats->ls_lock);\r\nLIBCFS_ALLOC(stats->ls_cnt_header,\r\nstats->ls_num * sizeof(struct lprocfs_counter_header));\r\nif (stats->ls_cnt_header == NULL)\r\ngoto fail;\r\nif ((flags & LPROCFS_STATS_FLAG_NOPERCPU) != 0) {\r\npercpusize = lprocfs_stats_counter_size(stats);\r\nLIBCFS_ALLOC_ATOMIC(stats->ls_percpu[0], percpusize);\r\nif (stats->ls_percpu[0] == NULL)\r\ngoto fail;\r\nstats->ls_biggest_alloc_num = 1;\r\n} else if ((flags & LPROCFS_STATS_FLAG_IRQ_SAFE) != 0) {\r\nfor (i = 0; i < num_entry; ++i)\r\nif (lprocfs_stats_alloc_one(stats, i) < 0)\r\ngoto fail;\r\n}\r\nreturn stats;\r\nfail:\r\nlprocfs_free_stats(&stats);\r\nreturn NULL;\r\n}\r\nvoid lprocfs_free_stats(struct lprocfs_stats **statsh)\r\n{\r\nstruct lprocfs_stats *stats = *statsh;\r\nunsigned int num_entry;\r\nunsigned int percpusize;\r\nunsigned int i;\r\nif (stats == NULL || stats->ls_num == 0)\r\nreturn;\r\n*statsh = NULL;\r\nif (stats->ls_flags & LPROCFS_STATS_FLAG_NOPERCPU)\r\nnum_entry = 1;\r\nelse\r\nnum_entry = num_possible_cpus();\r\npercpusize = lprocfs_stats_counter_size(stats);\r\nfor (i = 0; i < num_entry; i++)\r\nif (stats->ls_percpu[i] != NULL)\r\nLIBCFS_FREE(stats->ls_percpu[i], percpusize);\r\nif (stats->ls_cnt_header != NULL)\r\nLIBCFS_FREE(stats->ls_cnt_header, stats->ls_num *\r\nsizeof(struct lprocfs_counter_header));\r\nLIBCFS_FREE(stats, offsetof(typeof(*stats), ls_percpu[num_entry]));\r\n}\r\nvoid lprocfs_clear_stats(struct lprocfs_stats *stats)\r\n{\r\nstruct lprocfs_counter *percpu_cntr;\r\nint i;\r\nint j;\r\nunsigned int num_entry;\r\nunsigned long flags = 0;\r\nnum_entry = lprocfs_stats_lock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\nfor (i = 0; i < num_entry; i++) {\r\nif (stats->ls_percpu[i] == NULL)\r\ncontinue;\r\nfor (j = 0; j < stats->ls_num; j++) {\r\npercpu_cntr = lprocfs_stats_counter_get(stats, i, j);\r\npercpu_cntr->lc_count = 0;\r\npercpu_cntr->lc_min = LC_MIN_INIT;\r\npercpu_cntr->lc_max = 0;\r\npercpu_cntr->lc_sumsquare = 0;\r\npercpu_cntr->lc_sum = 0;\r\nif (stats->ls_flags & LPROCFS_STATS_FLAG_IRQ_SAFE)\r\npercpu_cntr->lc_sum_irq = 0;\r\n}\r\n}\r\nlprocfs_stats_unlock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\n}\r\nstatic ssize_t lprocfs_stats_seq_write(struct file *file,\r\nconst char __user *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct lprocfs_stats *stats = seq->private;\r\nlprocfs_clear_stats(stats);\r\nreturn len;\r\n}\r\nstatic void *lprocfs_stats_seq_start(struct seq_file *p, loff_t *pos)\r\n{\r\nstruct lprocfs_stats *stats = p->private;\r\nreturn (*pos < stats->ls_num) ? pos : NULL;\r\n}\r\nstatic void lprocfs_stats_seq_stop(struct seq_file *p, void *v)\r\n{\r\n}\r\nstatic void *lprocfs_stats_seq_next(struct seq_file *p, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn lprocfs_stats_seq_start(p, pos);\r\n}\r\nstatic int lprocfs_stats_seq_show(struct seq_file *p, void *v)\r\n{\r\nstruct lprocfs_stats *stats = p->private;\r\nstruct lprocfs_counter_header *hdr;\r\nstruct lprocfs_counter ctr;\r\nint idx = *(loff_t *)v;\r\nint rc = 0;\r\nif (idx == 0) {\r\nstruct timeval now;\r\ndo_gettimeofday(&now);\r\nrc = seq_printf(p, "%-25s %lu.%lu secs.usecs\n",\r\n"snapshot_time", now.tv_sec, (unsigned long)now.tv_usec);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nhdr = &stats->ls_cnt_header[idx];\r\nlprocfs_stats_collect(stats, idx, &ctr);\r\nif (ctr.lc_count == 0)\r\ngoto out;\r\nrc = seq_printf(p, "%-25s "LPD64" samples [%s]", hdr->lc_name,\r\nctr.lc_count, hdr->lc_units);\r\nif (rc < 0)\r\ngoto out;\r\nif ((hdr->lc_config & LPROCFS_CNTR_AVGMINMAX) && (ctr.lc_count > 0)) {\r\nrc = seq_printf(p, " "LPD64" "LPD64" "LPD64,\r\nctr.lc_min, ctr.lc_max, ctr.lc_sum);\r\nif (rc < 0)\r\ngoto out;\r\nif (hdr->lc_config & LPROCFS_CNTR_STDDEV)\r\nrc = seq_printf(p, " "LPD64, ctr.lc_sumsquare);\r\nif (rc < 0)\r\ngoto out;\r\n}\r\nrc = seq_printf(p, "\n");\r\nout:\r\nreturn (rc < 0) ? rc : 0;\r\n}\r\nstatic int lprocfs_stats_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint rc;\r\nrc = seq_open(file, &lprocfs_stats_seq_sops);\r\nif (rc)\r\nreturn rc;\r\nseq = file->private_data;\r\nseq->private = PDE_DATA(inode);\r\nreturn 0;\r\n}\r\nint lprocfs_register_stats(struct proc_dir_entry *root, const char *name,\r\nstruct lprocfs_stats *stats)\r\n{\r\nstruct proc_dir_entry *entry;\r\nLASSERT(root != NULL);\r\nentry = proc_create_data(name, 0644, root,\r\n&lprocfs_stats_seq_fops, stats);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid lprocfs_counter_init(struct lprocfs_stats *stats, int index,\r\nunsigned conf, const char *name, const char *units)\r\n{\r\nstruct lprocfs_counter_header *header;\r\nstruct lprocfs_counter *percpu_cntr;\r\nunsigned long flags = 0;\r\nunsigned int i;\r\nunsigned int num_cpu;\r\nLASSERT(stats != NULL);\r\nheader = &stats->ls_cnt_header[index];\r\nLASSERTF(header != NULL, "Failed to allocate stats header:[%d]%s/%s\n",\r\nindex, name, units);\r\nheader->lc_config = conf;\r\nheader->lc_name = name;\r\nheader->lc_units = units;\r\nnum_cpu = lprocfs_stats_lock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\nfor (i = 0; i < num_cpu; ++i) {\r\nif (stats->ls_percpu[i] == NULL)\r\ncontinue;\r\npercpu_cntr = lprocfs_stats_counter_get(stats, i, index);\r\npercpu_cntr->lc_count = 0;\r\npercpu_cntr->lc_min = LC_MIN_INIT;\r\npercpu_cntr->lc_max = 0;\r\npercpu_cntr->lc_sumsquare = 0;\r\npercpu_cntr->lc_sum = 0;\r\nif ((stats->ls_flags & LPROCFS_STATS_FLAG_IRQ_SAFE) != 0)\r\npercpu_cntr->lc_sum_irq = 0;\r\n}\r\nlprocfs_stats_unlock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\n}\r\nvoid lprocfs_init_ops_stats(int num_private_stats, struct lprocfs_stats *stats)\r\n{\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, iocontrol);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, get_info);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, set_info_async);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, attach);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, detach);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, setup);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, precleanup);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, cleanup);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, process_config);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, postrecov);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, add_conn);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, del_conn);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, connect);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, reconnect);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, disconnect);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, fid_init);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, fid_fini);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, fid_alloc);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, statfs);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, statfs_async);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, packmd);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, unpackmd);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, preallocate);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, precreate);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, create);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, create_async);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, destroy);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, setattr);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, setattr_async);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, getattr);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, getattr_async);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, brw);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, merge_lvb);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, adjust_kms);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, punch);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, sync);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, migrate);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, copy);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, iterate);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, preprw);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, commitrw);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, enqueue);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, change_cbdata);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, find_cbdata);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, cancel);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, cancel_unused);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, init_export);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, destroy_export);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, extent_calc);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, llog_init);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, llog_connect);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, llog_finish);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, pin);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, unpin);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, import_event);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, notify);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, health_check);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, get_uuid);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, quotacheck);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, quotactl);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, ping);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, pool_new);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, pool_rem);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, pool_add);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, pool_del);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, getref);\r\nLPROCFS_OBD_OP_INIT(num_private_stats, stats, putref);\r\n}\r\nint lprocfs_alloc_obd_stats(struct obd_device *obd, unsigned num_private_stats)\r\n{\r\nstruct lprocfs_stats *stats;\r\nunsigned int num_stats;\r\nint rc, i;\r\nLASSERT(obd->obd_stats == NULL);\r\nLASSERT(obd->obd_proc_entry != NULL);\r\nLASSERT(obd->obd_cntr_base == 0);\r\nnum_stats = ((int)sizeof(*obd->obd_type->typ_dt_ops) / sizeof(void *)) +\r\nnum_private_stats - 1 ;\r\nstats = lprocfs_alloc_stats(num_stats, 0);\r\nif (stats == NULL)\r\nreturn -ENOMEM;\r\nlprocfs_init_ops_stats(num_private_stats, stats);\r\nfor (i = num_private_stats; i < num_stats; i++) {\r\nLASSERTF(stats->ls_cnt_header[i].lc_name != NULL,\r\n"Missing obd_stat initializer obd_op "\r\n"operation at offset %d.\n", i - num_private_stats);\r\n}\r\nrc = lprocfs_register_stats(obd->obd_proc_entry, "stats", stats);\r\nif (rc < 0) {\r\nlprocfs_free_stats(&stats);\r\n} else {\r\nobd->obd_stats = stats;\r\nobd->obd_cntr_base = num_private_stats;\r\n}\r\nreturn rc;\r\n}\r\nvoid lprocfs_free_obd_stats(struct obd_device *obd)\r\n{\r\nif (obd->obd_stats)\r\nlprocfs_free_stats(&obd->obd_stats);\r\n}\r\nvoid lprocfs_init_mps_stats(int num_private_stats, struct lprocfs_stats *stats)\r\n{\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, getstatus);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, null_inode);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, find_cbdata);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, close);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, create);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, done_writing);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, enqueue);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, getattr);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, getattr_name);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, intent_lock);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, link);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, rename);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, is_subdir);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, setattr);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, sync);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, readpage);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, unlink);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, setxattr);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, getxattr);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, init_ea_size);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, get_lustre_md);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, free_lustre_md);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, set_open_replay_data);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, clear_open_replay_data);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, set_lock_data);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, lock_match);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, cancel_unused);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, renew_capa);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, unpack_capa);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, get_remote_perm);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, intent_getattr_async);\r\nLPROCFS_MD_OP_INIT(num_private_stats, stats, revalidate_lock);\r\n}\r\nint lprocfs_alloc_md_stats(struct obd_device *obd,\r\nunsigned num_private_stats)\r\n{\r\nstruct lprocfs_stats *stats;\r\nunsigned int num_stats;\r\nint rc, i;\r\nLASSERT(obd->md_stats == NULL);\r\nLASSERT(obd->obd_proc_entry != NULL);\r\nLASSERT(obd->md_cntr_base == 0);\r\nnum_stats = 1 + MD_COUNTER_OFFSET(revalidate_lock) +\r\nnum_private_stats;\r\nstats = lprocfs_alloc_stats(num_stats, 0);\r\nif (stats == NULL)\r\nreturn -ENOMEM;\r\nlprocfs_init_mps_stats(num_private_stats, stats);\r\nfor (i = num_private_stats; i < num_stats; i++) {\r\nif (stats->ls_cnt_header[i].lc_name == NULL) {\r\nCERROR("Missing md_stat initializer md_op "\r\n"operation at offset %d. Aborting.\n",\r\ni - num_private_stats);\r\nLBUG();\r\n}\r\n}\r\nrc = lprocfs_register_stats(obd->obd_proc_entry, "md_stats", stats);\r\nif (rc < 0) {\r\nlprocfs_free_stats(&stats);\r\n} else {\r\nobd->md_stats = stats;\r\nobd->md_cntr_base = num_private_stats;\r\n}\r\nreturn rc;\r\n}\r\nvoid lprocfs_free_md_stats(struct obd_device *obd)\r\n{\r\nstruct lprocfs_stats *stats = obd->md_stats;\r\nif (stats != NULL) {\r\nobd->md_stats = NULL;\r\nobd->md_cntr_base = 0;\r\nlprocfs_free_stats(&stats);\r\n}\r\n}\r\nvoid lprocfs_init_ldlm_stats(struct lprocfs_stats *ldlm_stats)\r\n{\r\nlprocfs_counter_init(ldlm_stats,\r\nLDLM_ENQUEUE - LDLM_FIRST_OPC,\r\n0, "ldlm_enqueue", "reqs");\r\nlprocfs_counter_init(ldlm_stats,\r\nLDLM_CONVERT - LDLM_FIRST_OPC,\r\n0, "ldlm_convert", "reqs");\r\nlprocfs_counter_init(ldlm_stats,\r\nLDLM_CANCEL - LDLM_FIRST_OPC,\r\n0, "ldlm_cancel", "reqs");\r\nlprocfs_counter_init(ldlm_stats,\r\nLDLM_BL_CALLBACK - LDLM_FIRST_OPC,\r\n0, "ldlm_bl_callback", "reqs");\r\nlprocfs_counter_init(ldlm_stats,\r\nLDLM_CP_CALLBACK - LDLM_FIRST_OPC,\r\n0, "ldlm_cp_callback", "reqs");\r\nlprocfs_counter_init(ldlm_stats,\r\nLDLM_GL_CALLBACK - LDLM_FIRST_OPC,\r\n0, "ldlm_gl_callback", "reqs");\r\n}\r\nint lprocfs_exp_print_uuid(struct cfs_hash *hs, struct cfs_hash_bd *bd,\r\nstruct hlist_node *hnode, void *data)\r\n{\r\nstruct obd_export *exp = cfs_hash_object(hs, hnode);\r\nstruct seq_file *m = (struct seq_file *)data;\r\nif (exp->exp_nid_stats)\r\nseq_printf(m, "%s\n", obd_uuid2str(&exp->exp_client_uuid));\r\nreturn 0;\r\n}\r\nstatic int\r\nlproc_exp_uuid_seq_show(struct seq_file *m, void *unused)\r\n{\r\nstruct nid_stat *stats = (struct nid_stat *)m->private;\r\nstruct obd_device *obd = stats->nid_obd;\r\ncfs_hash_for_each_key(obd->obd_nid_hash, &stats->nid,\r\nlprocfs_exp_print_uuid, m);\r\nreturn 0;\r\n}\r\nint lprocfs_exp_print_hash(struct cfs_hash *hs, struct cfs_hash_bd *bd,\r\nstruct hlist_node *hnode, void *cb_data)\r\n{\r\nstruct exp_hash_cb_data *data = (struct exp_hash_cb_data *)cb_data;\r\nstruct obd_export *exp = cfs_hash_object(hs, hnode);\r\nif (exp->exp_lock_hash != NULL) {\r\nif (data->first) {\r\ncfs_hash_debug_header(data->m);\r\ndata->first = false;\r\n}\r\ncfs_hash_debug_str(hs, data->m);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlproc_exp_hash_seq_show(struct seq_file *m, void *unused)\r\n{\r\nstruct nid_stat *stats = (struct nid_stat *)m->private;\r\nstruct obd_device *obd = stats->nid_obd;\r\nstruct exp_hash_cb_data cb_data = {m, true};\r\ncfs_hash_for_each_key(obd->obd_nid_hash, &stats->nid,\r\nlprocfs_exp_print_hash, &cb_data);\r\nreturn 0;\r\n}\r\nint lprocfs_nid_stats_clear_read(struct seq_file *m, void *data)\r\n{\r\nreturn seq_printf(m, "%s\n",\r\n"Write into this file to clear all nid stats and "\r\n"stale nid entries");\r\n}\r\nstatic int lprocfs_nid_stats_clear_write_cb(void *obj, void *data)\r\n{\r\nstruct nid_stat *stat = obj;\r\nCDEBUG(D_INFO,"refcnt %d\n", atomic_read(&stat->nid_exp_ref_count));\r\nif (atomic_read(&stat->nid_exp_ref_count) == 1) {\r\nspin_lock(&stat->nid_obd->obd_nid_lock);\r\nlist_move(&stat->nid_list, data);\r\nspin_unlock(&stat->nid_obd->obd_nid_lock);\r\nreturn 1;\r\n}\r\nif (stat->nid_stats)\r\nlprocfs_clear_stats(stat->nid_stats);\r\nreturn 0;\r\n}\r\nint lprocfs_nid_stats_clear_write(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nstruct obd_device *obd = (struct obd_device *)data;\r\nstruct nid_stat *client_stat;\r\nLIST_HEAD(free_list);\r\ncfs_hash_cond_del(obd->obd_nid_stats_hash,\r\nlprocfs_nid_stats_clear_write_cb, &free_list);\r\nwhile (!list_empty(&free_list)) {\r\nclient_stat = list_entry(free_list.next, struct nid_stat,\r\nnid_list);\r\nlist_del_init(&client_stat->nid_list);\r\nlprocfs_free_client_stats(client_stat);\r\n}\r\nreturn count;\r\n}\r\nint lprocfs_exp_setup(struct obd_export *exp, lnet_nid_t *nid, int *newnid)\r\n{\r\nstruct nid_stat *new_stat, *old_stat;\r\nstruct obd_device *obd = NULL;\r\nstruct proc_dir_entry *entry;\r\nchar *buffer = NULL;\r\nint rc = 0;\r\n*newnid = 0;\r\nif (!exp || !exp->exp_obd || !exp->exp_obd->obd_proc_exports_entry ||\r\n!exp->exp_obd->obd_nid_stats_hash)\r\nreturn -EINVAL;\r\nif (!nid || *nid == LNET_NID_ANY)\r\nreturn 0;\r\nobd = exp->exp_obd;\r\nCDEBUG(D_CONFIG, "using hash %p\n", obd->obd_nid_stats_hash);\r\nOBD_ALLOC_PTR(new_stat);\r\nif (new_stat == NULL)\r\nreturn -ENOMEM;\r\nnew_stat->nid = *nid;\r\nnew_stat->nid_obd = exp->exp_obd;\r\natomic_set(&new_stat->nid_exp_ref_count, 1);\r\nold_stat = cfs_hash_findadd_unique(obd->obd_nid_stats_hash,\r\nnid, &new_stat->nid_hash);\r\nCDEBUG(D_INFO, "Found stats %p for nid %s - ref %d\n",\r\nold_stat, libcfs_nid2str(*nid),\r\natomic_read(&new_stat->nid_exp_ref_count));\r\nif (exp->exp_nid_stats) {\r\nnidstat_putref(exp->exp_nid_stats);\r\nexp->exp_nid_stats = NULL;\r\n}\r\nif (old_stat != new_stat) {\r\nexp->exp_nid_stats = old_stat;\r\nGOTO(destroy_new, rc = -EALREADY);\r\n}\r\nOBD_ALLOC(buffer, LNET_NIDSTR_SIZE);\r\nif (buffer == NULL)\r\nGOTO(destroy_new, rc = -ENOMEM);\r\nmemcpy(buffer, libcfs_nid2str(*nid), LNET_NIDSTR_SIZE);\r\nnew_stat->nid_proc = lprocfs_register(buffer,\r\nobd->obd_proc_exports_entry,\r\nNULL, NULL);\r\nOBD_FREE(buffer, LNET_NIDSTR_SIZE);\r\nif (IS_ERR(new_stat->nid_proc)) {\r\nCERROR("Error making export directory for nid %s\n",\r\nlibcfs_nid2str(*nid));\r\nrc = PTR_ERR(new_stat->nid_proc);\r\nnew_stat->nid_proc = NULL;\r\nGOTO(destroy_new_ns, rc);\r\n}\r\nentry = lprocfs_add_simple(new_stat->nid_proc, "uuid",\r\nnew_stat, &lproc_exp_uuid_fops);\r\nif (IS_ERR(entry)) {\r\nCWARN("Error adding the NID stats file\n");\r\nrc = PTR_ERR(entry);\r\nGOTO(destroy_new_ns, rc);\r\n}\r\nentry = lprocfs_add_simple(new_stat->nid_proc, "hash",\r\nnew_stat, &lproc_exp_hash_fops);\r\nif (IS_ERR(entry)) {\r\nCWARN("Error adding the hash file\n");\r\nrc = PTR_ERR(entry);\r\nGOTO(destroy_new_ns, rc);\r\n}\r\nexp->exp_nid_stats = new_stat;\r\n*newnid = 1;\r\nspin_lock(&obd->obd_nid_lock);\r\nlist_add(&new_stat->nid_list, &obd->obd_nid_stats);\r\nspin_unlock(&obd->obd_nid_lock);\r\nreturn rc;\r\ndestroy_new_ns:\r\nif (new_stat->nid_proc != NULL)\r\nlprocfs_remove(&new_stat->nid_proc);\r\ncfs_hash_del(obd->obd_nid_stats_hash, nid, &new_stat->nid_hash);\r\ndestroy_new:\r\nnidstat_putref(new_stat);\r\nOBD_FREE_PTR(new_stat);\r\nreturn rc;\r\n}\r\nint lprocfs_exp_cleanup(struct obd_export *exp)\r\n{\r\nstruct nid_stat *stat = exp->exp_nid_stats;\r\nif(!stat || !exp->exp_obd)\r\nreturn 0;\r\nnidstat_putref(exp->exp_nid_stats);\r\nexp->exp_nid_stats = NULL;\r\nreturn 0;\r\n}\r\nint lprocfs_write_helper(const char *buffer, unsigned long count,\r\nint *val)\r\n{\r\nreturn lprocfs_write_frac_helper(buffer, count, val, 1);\r\n}\r\nint lprocfs_seq_read_frac_helper(struct seq_file *m, long val, int mult)\r\n{\r\nlong decimal_val, frac_val;\r\ndecimal_val = val / mult;\r\nseq_printf(m, "%ld", decimal_val);\r\nfrac_val = val % mult;\r\nif (frac_val > 0) {\r\nfrac_val *= 100;\r\nfrac_val /= mult;\r\n}\r\nif (frac_val > 0) {\r\nif ((frac_val % 10) != 0)\r\nseq_printf(m, ".%ld", frac_val);\r\nelse\r\nseq_printf(m, ".%ld", frac_val / 10);\r\n}\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nint lprocfs_write_u64_helper(const char *buffer, unsigned long count,__u64 *val)\r\n{\r\nreturn lprocfs_write_frac_u64_helper(buffer, count, val, 1);\r\n}\r\nint lprocfs_write_frac_u64_helper(const char *buffer, unsigned long count,\r\n__u64 *val, int mult)\r\n{\r\nchar kernbuf[22], *end, *pbuf;\r\n__u64 whole, frac = 0, units;\r\nunsigned frac_d = 1;\r\nif (count > (sizeof(kernbuf) - 1))\r\nreturn -EINVAL;\r\nif (copy_from_user(kernbuf, buffer, count))\r\nreturn -EFAULT;\r\nkernbuf[count] = '\0';\r\npbuf = kernbuf;\r\nif (*pbuf == '-') {\r\nmult = -mult;\r\npbuf++;\r\n}\r\nwhole = simple_strtoull(pbuf, &end, 10);\r\nif (pbuf == end)\r\nreturn -EINVAL;\r\nif (end != NULL && *end == '.') {\r\nint i;\r\npbuf = end + 1;\r\nif (strlen(pbuf) > 10)\r\npbuf[10] = '\0';\r\nfrac = simple_strtoull(pbuf, &end, 10);\r\nfor (i = 0; i < (end - pbuf); i++)\r\nfrac_d *= 10;\r\n}\r\nunits = 1;\r\nswitch(*end) {\r\ncase 'p': case 'P':\r\nunits <<= 10;\r\ncase 't': case 'T':\r\nunits <<= 10;\r\ncase 'g': case 'G':\r\nunits <<= 10;\r\ncase 'm': case 'M':\r\nunits <<= 10;\r\ncase 'k': case 'K':\r\nunits <<= 10;\r\n}\r\nif (units)\r\nmult = mult < 0 ? -units : units;\r\nfrac *= mult;\r\ndo_div(frac, frac_d);\r\n*val = whole * mult + frac;\r\nreturn 0;\r\n}\r\nstatic char *lprocfs_strnstr(const char *s1, const char *s2, size_t len)\r\n{\r\nsize_t l2;\r\nl2 = strlen(s2);\r\nif (!l2)\r\nreturn (char *)s1;\r\nwhile (len >= l2) {\r\nlen--;\r\nif (!memcmp(s1, s2, l2))\r\nreturn (char *)s1;\r\ns1++;\r\n}\r\nreturn NULL;\r\n}\r\nchar *lprocfs_find_named_value(const char *buffer, const char *name,\r\nsize_t *count)\r\n{\r\nchar *val;\r\nsize_t buflen = *count;\r\nval = lprocfs_strnstr(buffer, name, buflen);\r\nif (val == NULL)\r\nreturn (char *)buffer;\r\nval += strlen(name);\r\nwhile (val < buffer + buflen && isspace(*val))\r\nval++;\r\n*count = 0;\r\nwhile (val < buffer + buflen && isalnum(*val)) {\r\n++*count;\r\n++val;\r\n}\r\nreturn val - *count;\r\n}\r\nint lprocfs_seq_create(struct proc_dir_entry *parent,\r\nconst char *name,\r\numode_t mode,\r\nconst struct file_operations *seq_fops,\r\nvoid *data)\r\n{\r\nstruct proc_dir_entry *entry;\r\nLASSERT((seq_fops->write == NULL) == ((mode & 0222) == 0));\r\nentry = proc_create_data(name, mode, parent, seq_fops, data);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint lprocfs_obd_seq_create(struct obd_device *dev,\r\nconst char *name,\r\numode_t mode,\r\nconst struct file_operations *seq_fops,\r\nvoid *data)\r\n{\r\nreturn (lprocfs_seq_create(dev->obd_proc_entry, name,\r\nmode, seq_fops, data));\r\n}\r\nvoid lprocfs_oh_tally(struct obd_histogram *oh, unsigned int value)\r\n{\r\nif (value >= OBD_HIST_MAX)\r\nvalue = OBD_HIST_MAX - 1;\r\nspin_lock(&oh->oh_lock);\r\noh->oh_buckets[value]++;\r\nspin_unlock(&oh->oh_lock);\r\n}\r\nvoid lprocfs_oh_tally_log2(struct obd_histogram *oh, unsigned int value)\r\n{\r\nunsigned int val;\r\nfor (val = 0; ((1 << val) < value) && (val <= OBD_HIST_MAX); val++)\r\n;\r\nlprocfs_oh_tally(oh, val);\r\n}\r\nunsigned long lprocfs_oh_sum(struct obd_histogram *oh)\r\n{\r\nunsigned long ret = 0;\r\nint i;\r\nfor (i = 0; i < OBD_HIST_MAX; i++)\r\nret += oh->oh_buckets[i];\r\nreturn ret;\r\n}\r\nvoid lprocfs_oh_clear(struct obd_histogram *oh)\r\n{\r\nspin_lock(&oh->oh_lock);\r\nmemset(oh->oh_buckets, 0, sizeof(oh->oh_buckets));\r\nspin_unlock(&oh->oh_lock);\r\n}\r\nint lprocfs_obd_rd_max_pages_per_rpc(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *dev = data;\r\nstruct client_obd *cli = &dev->u.cli;\r\nint rc;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nrc = seq_printf(m, "%d\n", cli->cl_max_pages_per_rpc);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nreturn rc;\r\n}
