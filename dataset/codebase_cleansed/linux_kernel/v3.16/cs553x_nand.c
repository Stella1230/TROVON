static void cs553x_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nwhile (unlikely(len > 0x800)) {\r\nmemcpy_fromio(buf, this->IO_ADDR_R, 0x800);\r\nbuf += 0x800;\r\nlen -= 0x800;\r\n}\r\nmemcpy_fromio(buf, this->IO_ADDR_R, len);\r\n}\r\nstatic void cs553x_write_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nwhile (unlikely(len > 0x800)) {\r\nmemcpy_toio(this->IO_ADDR_R, buf, 0x800);\r\nbuf += 0x800;\r\nlen -= 0x800;\r\n}\r\nmemcpy_toio(this->IO_ADDR_R, buf, len);\r\n}\r\nstatic unsigned char cs553x_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nreturn readb(this->IO_ADDR_R);\r\n}\r\nstatic void cs553x_write_byte(struct mtd_info *mtd, u_char byte)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nint i = 100000;\r\nwhile (i && readb(this->IO_ADDR_R + MM_NAND_STS) & CS_NAND_CTLR_BUSY) {\r\nudelay(1);\r\ni--;\r\n}\r\nwriteb(byte, this->IO_ADDR_W + 0x801);\r\n}\r\nstatic void cs553x_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nvoid __iomem *mmio_base = this->IO_ADDR_R;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nunsigned char ctl = (ctrl & ~NAND_CTRL_CHANGE ) ^ 0x01;\r\nwriteb(ctl, mmio_base + MM_NAND_CTL);\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\ncs553x_write_byte(mtd, cmd);\r\n}\r\nstatic int cs553x_device_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nvoid __iomem *mmio_base = this->IO_ADDR_R;\r\nunsigned char foo = readb(mmio_base + MM_NAND_STS);\r\nreturn (foo & CS_NAND_STS_FLASH_RDY) && !(foo & CS_NAND_CTLR_BUSY);\r\n}\r\nstatic void cs_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nvoid __iomem *mmio_base = this->IO_ADDR_R;\r\nwriteb(0x07, mmio_base + MM_NAND_ECC_CTL);\r\n}\r\nstatic int cs_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)\r\n{\r\nuint32_t ecc;\r\nstruct nand_chip *this = mtd->priv;\r\nvoid __iomem *mmio_base = this->IO_ADDR_R;\r\necc = readl(mmio_base + MM_NAND_STS);\r\necc_code[1] = ecc >> 8;\r\necc_code[0] = ecc >> 16;\r\necc_code[2] = ecc >> 24;\r\nreturn 0;\r\n}\r\nstatic int __init cs553x_init_one(int cs, int mmio, unsigned long adr)\r\n{\r\nint err = 0;\r\nstruct nand_chip *this;\r\nstruct mtd_info *new_mtd;\r\nprintk(KERN_NOTICE "Probing CS553x NAND controller CS#%d at %sIO 0x%08lx\n", cs, mmio?"MM":"P", adr);\r\nif (!mmio) {\r\nprintk(KERN_NOTICE "PIO mode not yet implemented for CS553X NAND controller\n");\r\nreturn -ENXIO;\r\n}\r\nnew_mtd = kzalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);\r\nif (!new_mtd) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nthis = (struct nand_chip *)(&new_mtd[1]);\r\nnew_mtd->priv = this;\r\nnew_mtd->owner = THIS_MODULE;\r\nthis->IO_ADDR_R = this->IO_ADDR_W = ioremap(adr, 4096);\r\nif (!this->IO_ADDR_R) {\r\nprintk(KERN_WARNING "ioremap cs553x NAND @0x%08lx failed\n", adr);\r\nerr = -EIO;\r\ngoto out_mtd;\r\n}\r\nthis->cmd_ctrl = cs553x_hwcontrol;\r\nthis->dev_ready = cs553x_device_ready;\r\nthis->read_byte = cs553x_read_byte;\r\nthis->read_buf = cs553x_read_buf;\r\nthis->write_buf = cs553x_write_buf;\r\nthis->chip_delay = 0;\r\nthis->ecc.mode = NAND_ECC_HW;\r\nthis->ecc.size = 256;\r\nthis->ecc.bytes = 3;\r\nthis->ecc.hwctl = cs_enable_hwecc;\r\nthis->ecc.calculate = cs_calculate_ecc;\r\nthis->ecc.correct = nand_correct_data;\r\nthis->ecc.strength = 1;\r\nthis->bbt_options = NAND_BBT_USE_FLASH;\r\nif (nand_scan(new_mtd, 1)) {\r\nerr = -ENXIO;\r\ngoto out_ior;\r\n}\r\nnew_mtd->name = kasprintf(GFP_KERNEL, "cs553x_nand_cs%d", cs);\r\ncs553x_mtd[cs] = new_mtd;\r\ngoto out;\r\nout_ior:\r\niounmap(this->IO_ADDR_R);\r\nout_mtd:\r\nkfree(new_mtd);\r\nout:\r\nreturn err;\r\n}\r\nstatic int is_geode(void)\r\n{\r\nif (boot_cpu_data.x86_vendor == X86_VENDOR_AMD &&\r\nboot_cpu_data.x86 == 5 &&\r\nboot_cpu_data.x86_model == 10)\r\nreturn 1;\r\nif ((boot_cpu_data.x86_vendor == X86_VENDOR_NSC ||\r\nboot_cpu_data.x86_vendor == X86_VENDOR_CYRIX) &&\r\nboot_cpu_data.x86 == 5 &&\r\nboot_cpu_data.x86_model == 5)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init cs553x_init(void)\r\n{\r\nint err = -ENXIO;\r\nint i;\r\nuint64_t val;\r\nif (!is_geode())\r\nreturn -ENXIO;\r\nrdmsrl(MSR_DIVIL_GLD_CAP, val);\r\nval &= ~0xFFULL;\r\nif (val != CAP_CS5535 && val != CAP_CS5536)\r\nreturn -ENXIO;\r\nrdmsrl(MSR_DIVIL_BALL_OPTS, val);\r\nif (val & PIN_OPT_IDE) {\r\nprintk(KERN_INFO "CS553x NAND controller: Flash I/O not enabled in MSR_DIVIL_BALL_OPTS.\n");\r\nreturn -ENXIO;\r\n}\r\nfor (i = 0; i < NR_CS553X_CONTROLLERS; i++) {\r\nrdmsrl(MSR_DIVIL_LBAR_FLSH0 + i, val);\r\nif ((val & (FLSH_LBAR_EN|FLSH_NOR_NAND)) == (FLSH_LBAR_EN|FLSH_NOR_NAND))\r\nerr = cs553x_init_one(i, !!(val & FLSH_MEM_IO), val & 0xFFFFFFFF);\r\n}\r\nfor (i = 0; i < NR_CS553X_CONTROLLERS; i++) {\r\nif (cs553x_mtd[i]) {\r\nmtd_device_parse_register(cs553x_mtd[i], NULL, NULL,\r\nNULL, 0);\r\nerr = 0;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit cs553x_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NR_CS553X_CONTROLLERS; i++) {\r\nstruct mtd_info *mtd = cs553x_mtd[i];\r\nstruct nand_chip *this;\r\nvoid __iomem *mmio_base;\r\nif (!mtd)\r\ncontinue;\r\nthis = cs553x_mtd[i]->priv;\r\nmmio_base = this->IO_ADDR_R;\r\nnand_release(cs553x_mtd[i]);\r\nkfree(cs553x_mtd[i]->name);\r\ncs553x_mtd[i] = NULL;\r\niounmap(mmio_base);\r\nkfree(mtd);\r\n}\r\n}
