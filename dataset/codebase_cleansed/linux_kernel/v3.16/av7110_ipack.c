void av7110_ipack_reset(struct ipack *p)\r\n{\r\np->found = 0;\r\np->cid = 0;\r\np->plength = 0;\r\np->flag1 = 0;\r\np->flag2 = 0;\r\np->hlength = 0;\r\np->mpeg = 0;\r\np->check = 0;\r\np->which = 0;\r\np->done = 0;\r\np->count = 0;\r\n}\r\nint av7110_ipack_init(struct ipack *p, int size,\r\nvoid (*func)(u8 *buf, int size, void *priv))\r\n{\r\nif (!(p->buf = vmalloc(size*sizeof(u8)))) {\r\nprintk(KERN_WARNING "Couldn't allocate memory for ipack\n");\r\nreturn -ENOMEM;\r\n}\r\np->size = size;\r\np->func = func;\r\np->repack_subids = 0;\r\nav7110_ipack_reset(p);\r\nreturn 0;\r\n}\r\nvoid av7110_ipack_free(struct ipack *p)\r\n{\r\nvfree(p->buf);\r\n}\r\nstatic void send_ipack(struct ipack *p)\r\n{\r\nint off;\r\nstruct dvb_audio_info ai;\r\nint ac3_off = 0;\r\nint streamid = 0;\r\nint nframes = 0;\r\nint f = 0;\r\nswitch (p->mpeg) {\r\ncase 2:\r\nif (p->count < 10)\r\nreturn;\r\np->buf[3] = p->cid;\r\np->buf[4] = (u8)(((p->count - 6) & 0xff00) >> 8);\r\np->buf[5] = (u8)((p->count - 6) & 0x00ff);\r\nif (p->repack_subids && p->cid == PRIVATE_STREAM1) {\r\noff = 9 + p->buf[8];\r\nstreamid = p->buf[off];\r\nif ((streamid & 0xf8) == 0x80) {\r\nai.off = 0;\r\nac3_off = ((p->buf[off + 2] << 8)|\r\np->buf[off + 3]);\r\nif (ac3_off < p->count)\r\nf = dvb_filter_get_ac3info(p->buf + off + 3 + ac3_off,\r\np->count - ac3_off, &ai, 0);\r\nif (!f) {\r\nnframes = (p->count - off - 3 - ac3_off) /\r\nai.framesize + 1;\r\np->buf[off + 2] = (ac3_off >> 8) & 0xff;\r\np->buf[off + 3] = (ac3_off) & 0xff;\r\np->buf[off + 1] = nframes;\r\nac3_off += nframes * ai.framesize - p->count;\r\n}\r\n}\r\n}\r\np->func(p->buf, p->count, p->data);\r\np->buf[6] = 0x80;\r\np->buf[7] = 0x00;\r\np->buf[8] = 0x00;\r\np->count = 9;\r\nif (p->repack_subids && p->cid == PRIVATE_STREAM1\r\n&& (streamid & 0xf8) == 0x80) {\r\np->count += 4;\r\np->buf[9] = streamid;\r\np->buf[10] = (ac3_off >> 8) & 0xff;\r\np->buf[11] = (ac3_off) & 0xff;\r\np->buf[12] = 0;\r\n}\r\nbreak;\r\ncase 1:\r\nif (p->count < 8)\r\nreturn;\r\np->buf[3] = p->cid;\r\np->buf[4] = (u8)(((p->count - 6) & 0xff00) >> 8);\r\np->buf[5] = (u8)((p->count - 6) & 0x00ff);\r\np->func(p->buf, p->count, p->data);\r\np->buf[6] = 0x0f;\r\np->count = 7;\r\nbreak;\r\n}\r\n}\r\nvoid av7110_ipack_flush(struct ipack *p)\r\n{\r\nif (p->plength != MMAX_PLENGTH - 6 || p->found <= 6)\r\nreturn;\r\np->plength = p->found - 6;\r\np->found = 0;\r\nsend_ipack(p);\r\nav7110_ipack_reset(p);\r\n}\r\nstatic void write_ipack(struct ipack *p, const u8 *data, int count)\r\n{\r\nu8 headr[3] = { 0x00, 0x00, 0x01 };\r\nif (p->count < 6) {\r\nmemcpy(p->buf, headr, 3);\r\np->count = 6;\r\n}\r\nif (p->count + count < p->size){\r\nmemcpy(p->buf+p->count, data, count);\r\np->count += count;\r\n} else {\r\nint rest = p->size - p->count;\r\nmemcpy(p->buf+p->count, data, rest);\r\np->count += rest;\r\nsend_ipack(p);\r\nif (count - rest > 0)\r\nwrite_ipack(p, data + rest, count - rest);\r\n}\r\n}\r\nint av7110_ipack_instant_repack (const u8 *buf, int count, struct ipack *p)\r\n{\r\nint l;\r\nint c = 0;\r\nwhile (c < count && (p->mpeg == 0 ||\r\n(p->mpeg == 1 && p->found < 7) ||\r\n(p->mpeg == 2 && p->found < 9))\r\n&& (p->found < 5 || !p->done)) {\r\nswitch (p->found) {\r\ncase 0:\r\ncase 1:\r\nif (buf[c] == 0x00)\r\np->found++;\r\nelse\r\np->found = 0;\r\nc++;\r\nbreak;\r\ncase 2:\r\nif (buf[c] == 0x01)\r\np->found++;\r\nelse if (buf[c] == 0)\r\np->found = 2;\r\nelse\r\np->found = 0;\r\nc++;\r\nbreak;\r\ncase 3:\r\np->cid = 0;\r\nswitch (buf[c]) {\r\ncase PROG_STREAM_MAP:\r\ncase PRIVATE_STREAM2:\r\ncase PROG_STREAM_DIR:\r\ncase ECM_STREAM :\r\ncase EMM_STREAM :\r\ncase PADDING_STREAM :\r\ncase DSM_CC_STREAM :\r\ncase ISO13522_STREAM:\r\np->done = 1;\r\ncase PRIVATE_STREAM1:\r\ncase VIDEO_STREAM_S ... VIDEO_STREAM_E:\r\ncase AUDIO_STREAM_S ... AUDIO_STREAM_E:\r\np->found++;\r\np->cid = buf[c];\r\nc++;\r\nbreak;\r\ndefault:\r\np->found = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase 4:\r\nif (count-c > 1) {\r\np->plen[0] = buf[c];\r\nc++;\r\np->plen[1] = buf[c];\r\nc++;\r\np->found += 2;\r\np->plength = (p->plen[0] << 8) | p->plen[1];\r\n} else {\r\np->plen[0] = buf[c];\r\np->found++;\r\nreturn count;\r\n}\r\nbreak;\r\ncase 5:\r\np->plen[1] = buf[c];\r\nc++;\r\np->found++;\r\np->plength = (p->plen[0] << 8) | p->plen[1];\r\nbreak;\r\ncase 6:\r\nif (!p->done) {\r\np->flag1 = buf[c];\r\nc++;\r\np->found++;\r\nif ((p->flag1 & 0xc0) == 0x80)\r\np->mpeg = 2;\r\nelse {\r\np->hlength = 0;\r\np->which = 0;\r\np->mpeg = 1;\r\np->flag2 = 0;\r\n}\r\n}\r\nbreak;\r\ncase 7:\r\nif (!p->done && p->mpeg == 2) {\r\np->flag2 = buf[c];\r\nc++;\r\np->found++;\r\n}\r\nbreak;\r\ncase 8:\r\nif (!p->done && p->mpeg == 2) {\r\np->hlength = buf[c];\r\nc++;\r\np->found++;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (c == count)\r\nreturn count;\r\nif (!p->plength)\r\np->plength = MMAX_PLENGTH - 6;\r\nif (p->done || ((p->mpeg == 2 && p->found >= 9) ||\r\n(p->mpeg == 1 && p->found >= 7))) {\r\nswitch (p->cid) {\r\ncase AUDIO_STREAM_S ... AUDIO_STREAM_E:\r\ncase VIDEO_STREAM_S ... VIDEO_STREAM_E:\r\ncase PRIVATE_STREAM1:\r\nif (p->mpeg == 2 && p->found == 9) {\r\nwrite_ipack(p, &p->flag1, 1);\r\nwrite_ipack(p, &p->flag2, 1);\r\nwrite_ipack(p, &p->hlength, 1);\r\n}\r\nif (p->mpeg == 1 && p->found == 7)\r\nwrite_ipack(p, &p->flag1, 1);\r\nif (p->mpeg == 2 && (p->flag2 & PTS_ONLY) &&\r\np->found < 14) {\r\nwhile (c < count && p->found < 14) {\r\np->pts[p->found - 9] = buf[c];\r\nwrite_ipack(p, buf + c, 1);\r\nc++;\r\np->found++;\r\n}\r\nif (c == count)\r\nreturn count;\r\n}\r\nif (p->mpeg == 1 && p->which < 2000) {\r\nif (p->found == 7) {\r\np->check = p->flag1;\r\np->hlength = 1;\r\n}\r\nwhile (!p->which && c < count &&\r\np->check == 0xff){\r\np->check = buf[c];\r\nwrite_ipack(p, buf + c, 1);\r\nc++;\r\np->found++;\r\np->hlength++;\r\n}\r\nif (c == count)\r\nreturn count;\r\nif ((p->check & 0xc0) == 0x40 && !p->which) {\r\np->check = buf[c];\r\nwrite_ipack(p, buf + c, 1);\r\nc++;\r\np->found++;\r\np->hlength++;\r\np->which = 1;\r\nif (c == count)\r\nreturn count;\r\np->check = buf[c];\r\nwrite_ipack(p, buf + c, 1);\r\nc++;\r\np->found++;\r\np->hlength++;\r\np->which = 2;\r\nif (c == count)\r\nreturn count;\r\n}\r\nif (p->which == 1) {\r\np->check = buf[c];\r\nwrite_ipack(p, buf + c, 1);\r\nc++;\r\np->found++;\r\np->hlength++;\r\np->which = 2;\r\nif (c == count)\r\nreturn count;\r\n}\r\nif ((p->check & 0x30) && p->check != 0xff) {\r\np->flag2 = (p->check & 0xf0) << 2;\r\np->pts[0] = p->check;\r\np->which = 3;\r\n}\r\nif (c == count)\r\nreturn count;\r\nif (p->which > 2){\r\nif ((p->flag2 & PTS_DTS_FLAGS) == PTS_ONLY) {\r\nwhile (c < count && p->which < 7) {\r\np->pts[p->which - 2] = buf[c];\r\nwrite_ipack(p, buf + c, 1);\r\nc++;\r\np->found++;\r\np->which++;\r\np->hlength++;\r\n}\r\nif (c == count)\r\nreturn count;\r\n} else if ((p->flag2 & PTS_DTS_FLAGS) == PTS_DTS) {\r\nwhile (c < count && p->which < 12) {\r\nif (p->which < 7)\r\np->pts[p->which - 2] = buf[c];\r\nwrite_ipack(p, buf + c, 1);\r\nc++;\r\np->found++;\r\np->which++;\r\np->hlength++;\r\n}\r\nif (c == count)\r\nreturn count;\r\n}\r\np->which = 2000;\r\n}\r\n}\r\nwhile (c < count && p->found < p->plength + 6) {\r\nl = count - c;\r\nif (l + p->found > p->plength + 6)\r\nl = p->plength + 6 - p->found;\r\nwrite_ipack(p, buf + c, l);\r\np->found += l;\r\nc += l;\r\n}\r\nbreak;\r\n}\r\nif (p->done) {\r\nif (p->found + count - c < p->plength + 6) {\r\np->found += count - c;\r\nc = count;\r\n} else {\r\nc += p->plength + 6 - p->found;\r\np->found = p->plength + 6;\r\n}\r\n}\r\nif (p->plength && p->found == p->plength + 6) {\r\nsend_ipack(p);\r\nav7110_ipack_reset(p);\r\nif (c < count)\r\nav7110_ipack_instant_repack(buf + c, count - c, p);\r\n}\r\n}\r\nreturn count;\r\n}
