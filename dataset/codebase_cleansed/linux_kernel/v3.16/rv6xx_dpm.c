static struct rv6xx_ps *rv6xx_get_ps(struct radeon_ps *rps)\r\n{\r\nstruct rv6xx_ps *ps = rps->ps_priv;\r\nreturn ps;\r\n}\r\nstatic struct rv6xx_power_info *rv6xx_get_pi(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rdev->pm.dpm.priv;\r\nreturn pi;\r\n}\r\nstatic void rv6xx_force_pcie_gen1(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\nint i;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\r\ntmp &= LC_GEN2_EN;\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\r\ntmp |= LC_INITIATE_LINK_SPEED_CHANGE;\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (!(RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL) & LC_CURRENT_DATA_RATE))\r\nbreak;\r\nudelay(1);\r\n}\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\r\ntmp &= ~LC_INITIATE_LINK_SPEED_CHANGE;\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\n}\r\nstatic void rv6xx_enable_pcie_gen2_support(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\r\nif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\r\n(tmp & LC_OTHER_SIDE_SUPPORTS_GEN2)) {\r\ntmp |= LC_GEN2_EN;\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\n}\r\n}\r\nstatic void rv6xx_enable_bif_dynamic_pcie_gen2(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL) & ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\r\nif (enable)\r\ntmp |= LC_HW_VOLTAGE_IF_CONTROL(1);\r\nelse\r\ntmp |= LC_HW_VOLTAGE_IF_CONTROL(0);\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\n}\r\nstatic void rv6xx_enable_l0s(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_CNTL) & ~LC_L0S_INACTIVITY_MASK;\r\ntmp |= LC_L0S_INACTIVITY(3);\r\nWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\r\n}\r\nstatic void rv6xx_enable_l1(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_CNTL);\r\ntmp &= ~LC_L1_INACTIVITY_MASK;\r\ntmp |= LC_L1_INACTIVITY(4);\r\ntmp &= ~LC_PMI_TO_L1_DIS;\r\ntmp &= ~LC_ASPM_TO_L1_DIS;\r\nWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\r\n}\r\nstatic void rv6xx_enable_pll_sleep_in_l1(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_CNTL) & ~LC_L1_INACTIVITY_MASK;\r\ntmp |= LC_L1_INACTIVITY(8);\r\nWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\r\ntmp = RREG32_PCIE(PCIE_P_CNTL);\r\ntmp |= P_PLL_PWRDN_IN_L1L23;\r\ntmp &= ~P_PLL_BUF_PDNB;\r\ntmp &= ~P_PLL_PDNB;\r\ntmp |= P_ALLOW_PRX_FRONTEND_SHUTOFF;\r\nWREG32_PCIE(PCIE_P_CNTL, tmp);\r\n}\r\nstatic int rv6xx_convert_clock_to_stepping(struct radeon_device *rdev,\r\nu32 clock, struct rv6xx_sclk_stepping *step)\r\n{\r\nint ret;\r\nstruct atom_clock_dividers dividers;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\nclock, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\nif (dividers.enable_post_div)\r\nstep->post_divider = 2 + (dividers.post_div & 0xF) + (dividers.post_div >> 4);\r\nelse\r\nstep->post_divider = 1;\r\nstep->vco_frequency = clock * step->post_divider;\r\nreturn 0;\r\n}\r\nstatic void rv6xx_output_stepping(struct radeon_device *rdev,\r\nu32 step_index, struct rv6xx_sclk_stepping *step)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nu32 ref_clk = rdev->clock.spll.reference_freq;\r\nu32 fb_divider;\r\nu32 spll_step_count = rv6xx_scale_count_given_unit(rdev,\r\nR600_SPLLSTEPTIME_DFLT *\r\npi->spll_ref_div,\r\nR600_SPLLSTEPUNIT_DFLT);\r\nr600_engine_clock_entry_enable(rdev, step_index, true);\r\nr600_engine_clock_entry_enable_pulse_skipping(rdev, step_index, false);\r\nif (step->post_divider == 1)\r\nr600_engine_clock_entry_enable_post_divider(rdev, step_index, false);\r\nelse {\r\nu32 lo_len = (step->post_divider - 2) / 2;\r\nu32 hi_len = step->post_divider - 2 - lo_len;\r\nr600_engine_clock_entry_enable_post_divider(rdev, step_index, true);\r\nr600_engine_clock_entry_set_post_divider(rdev, step_index, (hi_len << 4) | lo_len);\r\n}\r\nfb_divider = ((step->vco_frequency * pi->spll_ref_div) / ref_clk) >>\r\npi->fb_div_scale;\r\nr600_engine_clock_entry_set_reference_divider(rdev, step_index,\r\npi->spll_ref_div - 1);\r\nr600_engine_clock_entry_set_feedback_divider(rdev, step_index, fb_divider);\r\nr600_engine_clock_entry_set_step_time(rdev, step_index, spll_step_count);\r\n}\r\nstatic struct rv6xx_sclk_stepping rv6xx_next_vco_step(struct radeon_device *rdev,\r\nstruct rv6xx_sclk_stepping *cur,\r\nbool increasing_vco, u32 step_size)\r\n{\r\nstruct rv6xx_sclk_stepping next;\r\nnext.post_divider = cur->post_divider;\r\nif (increasing_vco)\r\nnext.vco_frequency = (cur->vco_frequency * (100 + step_size)) / 100;\r\nelse\r\nnext.vco_frequency = (cur->vco_frequency * 100 + 99 + step_size) / (100 + step_size);\r\nreturn next;\r\n}\r\nstatic bool rv6xx_can_step_post_div(struct radeon_device *rdev,\r\nstruct rv6xx_sclk_stepping *cur,\r\nstruct rv6xx_sclk_stepping *target)\r\n{\r\nreturn (cur->post_divider > target->post_divider) &&\r\n((cur->vco_frequency * target->post_divider) <=\r\n(target->vco_frequency * (cur->post_divider - 1)));\r\n}\r\nstatic struct rv6xx_sclk_stepping rv6xx_next_post_div_step(struct radeon_device *rdev,\r\nstruct rv6xx_sclk_stepping *cur,\r\nstruct rv6xx_sclk_stepping *target)\r\n{\r\nstruct rv6xx_sclk_stepping next = *cur;\r\nwhile (rv6xx_can_step_post_div(rdev, &next, target))\r\nnext.post_divider--;\r\nreturn next;\r\n}\r\nstatic bool rv6xx_reached_stepping_target(struct radeon_device *rdev,\r\nstruct rv6xx_sclk_stepping *cur,\r\nstruct rv6xx_sclk_stepping *target,\r\nbool increasing_vco)\r\n{\r\nreturn (increasing_vco && (cur->vco_frequency >= target->vco_frequency)) ||\r\n(!increasing_vco && (cur->vco_frequency <= target->vco_frequency));\r\n}\r\nstatic void rv6xx_generate_steps(struct radeon_device *rdev,\r\nu32 low, u32 high,\r\nu32 start_index, u8 *end_index)\r\n{\r\nstruct rv6xx_sclk_stepping cur;\r\nstruct rv6xx_sclk_stepping target;\r\nbool increasing_vco;\r\nu32 step_index = start_index;\r\nrv6xx_convert_clock_to_stepping(rdev, low, &cur);\r\nrv6xx_convert_clock_to_stepping(rdev, high, &target);\r\nrv6xx_output_stepping(rdev, step_index++, &cur);\r\nincreasing_vco = (target.vco_frequency >= cur.vco_frequency);\r\nif (target.post_divider > cur.post_divider)\r\ncur.post_divider = target.post_divider;\r\nwhile (1) {\r\nstruct rv6xx_sclk_stepping next;\r\nif (rv6xx_can_step_post_div(rdev, &cur, &target))\r\nnext = rv6xx_next_post_div_step(rdev, &cur, &target);\r\nelse\r\nnext = rv6xx_next_vco_step(rdev, &cur, increasing_vco, R600_VCOSTEPPCT_DFLT);\r\nif (rv6xx_reached_stepping_target(rdev, &next, &target, increasing_vco)) {\r\nstruct rv6xx_sclk_stepping tiny =\r\nrv6xx_next_vco_step(rdev, &target, !increasing_vco, R600_ENDINGVCOSTEPPCT_DFLT);\r\ntiny.post_divider = next.post_divider;\r\nif (!rv6xx_reached_stepping_target(rdev, &tiny, &cur, !increasing_vco))\r\nrv6xx_output_stepping(rdev, step_index++, &tiny);\r\nif ((next.post_divider != target.post_divider) &&\r\n(next.vco_frequency != target.vco_frequency)) {\r\nstruct rv6xx_sclk_stepping final_vco;\r\nfinal_vco.vco_frequency = target.vco_frequency;\r\nfinal_vco.post_divider = next.post_divider;\r\nrv6xx_output_stepping(rdev, step_index++, &final_vco);\r\n}\r\nrv6xx_output_stepping(rdev, step_index++, &target);\r\nbreak;\r\n} else\r\nrv6xx_output_stepping(rdev, step_index++, &next);\r\ncur = next;\r\n}\r\n*end_index = (u8)step_index - 1;\r\n}\r\nstatic void rv6xx_generate_single_step(struct radeon_device *rdev,\r\nu32 clock, u32 index)\r\n{\r\nstruct rv6xx_sclk_stepping step;\r\nrv6xx_convert_clock_to_stepping(rdev, clock, &step);\r\nrv6xx_output_stepping(rdev, index, &step);\r\n}\r\nstatic void rv6xx_invalidate_intermediate_steps_range(struct radeon_device *rdev,\r\nu32 start_index, u32 end_index)\r\n{\r\nu32 step_index;\r\nfor (step_index = start_index + 1; step_index < end_index; step_index++)\r\nr600_engine_clock_entry_enable(rdev, step_index, false);\r\n}\r\nstatic void rv6xx_set_engine_spread_spectrum_clk_s(struct radeon_device *rdev,\r\nu32 index, u32 clk_s)\r\n{\r\nWREG32_P(CG_SPLL_SPREAD_SPECTRUM_LOW + (index * 4),\r\nCLKS(clk_s), ~CLKS_MASK);\r\n}\r\nstatic void rv6xx_set_engine_spread_spectrum_clk_v(struct radeon_device *rdev,\r\nu32 index, u32 clk_v)\r\n{\r\nWREG32_P(CG_SPLL_SPREAD_SPECTRUM_LOW + (index * 4),\r\nCLKV(clk_v), ~CLKV_MASK);\r\n}\r\nstatic void rv6xx_enable_engine_spread_spectrum(struct radeon_device *rdev,\r\nu32 index, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(CG_SPLL_SPREAD_SPECTRUM_LOW + (index * 4),\r\nSSEN, ~SSEN);\r\nelse\r\nWREG32_P(CG_SPLL_SPREAD_SPECTRUM_LOW + (index * 4),\r\n0, ~SSEN);\r\n}\r\nstatic void rv6xx_set_memory_spread_spectrum_clk_s(struct radeon_device *rdev,\r\nu32 clk_s)\r\n{\r\nWREG32_P(CG_MPLL_SPREAD_SPECTRUM, CLKS(clk_s), ~CLKS_MASK);\r\n}\r\nstatic void rv6xx_set_memory_spread_spectrum_clk_v(struct radeon_device *rdev,\r\nu32 clk_v)\r\n{\r\nWREG32_P(CG_MPLL_SPREAD_SPECTRUM, CLKV(clk_v), ~CLKV_MASK);\r\n}\r\nstatic void rv6xx_enable_memory_spread_spectrum(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nWREG32_P(CG_MPLL_SPREAD_SPECTRUM, SSEN, ~SSEN);\r\nelse\r\nWREG32_P(CG_MPLL_SPREAD_SPECTRUM, 0, ~SSEN);\r\n}\r\nstatic void rv6xx_enable_dynamic_spread_spectrum(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, DYN_SPREAD_SPECTRUM_EN, ~DYN_SPREAD_SPECTRUM_EN);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~DYN_SPREAD_SPECTRUM_EN);\r\n}\r\nstatic void rv6xx_memory_clock_entry_enable_post_divider(struct radeon_device *rdev,\r\nu32 index, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(MPLL_FREQ_LEVEL_0 + (index * 4),\r\nLEVEL0_MPLL_DIV_EN, ~LEVEL0_MPLL_DIV_EN);\r\nelse\r\nWREG32_P(MPLL_FREQ_LEVEL_0 + (index * 4), 0, ~LEVEL0_MPLL_DIV_EN);\r\n}\r\nstatic void rv6xx_memory_clock_entry_set_post_divider(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nWREG32_P(MPLL_FREQ_LEVEL_0 + (index * 4),\r\nLEVEL0_MPLL_POST_DIV(divider), ~LEVEL0_MPLL_POST_DIV_MASK);\r\n}\r\nstatic void rv6xx_memory_clock_entry_set_feedback_divider(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nWREG32_P(MPLL_FREQ_LEVEL_0 + (index * 4), LEVEL0_MPLL_FB_DIV(divider),\r\n~LEVEL0_MPLL_FB_DIV_MASK);\r\n}\r\nstatic void rv6xx_memory_clock_entry_set_reference_divider(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nWREG32_P(MPLL_FREQ_LEVEL_0 + (index * 4),\r\nLEVEL0_MPLL_REF_DIV(divider), ~LEVEL0_MPLL_REF_DIV_MASK);\r\n}\r\nstatic void rv6xx_vid_response_set_brt(struct radeon_device *rdev, u32 rt)\r\n{\r\nWREG32_P(VID_RT, BRT(rt), ~BRT_MASK);\r\n}\r\nstatic void rv6xx_enable_engine_feedback_and_reference_sync(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SPLL_CNTL_MODE, SPLL_DIV_SYNC, ~SPLL_DIV_SYNC);\r\n}\r\nstatic u32 rv6xx_clocks_per_unit(u32 unit)\r\n{\r\nu32 tmp = 1 << (2 * unit);\r\nreturn tmp;\r\n}\r\nstatic u32 rv6xx_scale_count_given_unit(struct radeon_device *rdev,\r\nu32 unscaled_count, u32 unit)\r\n{\r\nu32 count_per_unit = rv6xx_clocks_per_unit(unit);\r\nreturn (unscaled_count + count_per_unit - 1) / count_per_unit;\r\n}\r\nstatic u32 rv6xx_compute_count_for_delay(struct radeon_device *rdev,\r\nu32 delay_us, u32 unit)\r\n{\r\nu32 ref_clk = rdev->clock.spll.reference_freq;\r\nreturn rv6xx_scale_count_given_unit(rdev, delay_us * (ref_clk / 100), unit);\r\n}\r\nstatic void rv6xx_calculate_engine_speed_stepping_parameters(struct radeon_device *rdev,\r\nstruct rv6xx_ps *state)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\npi->hw.sclks[R600_POWER_LEVEL_LOW] =\r\nstate->low.sclk;\r\npi->hw.sclks[R600_POWER_LEVEL_MEDIUM] =\r\nstate->medium.sclk;\r\npi->hw.sclks[R600_POWER_LEVEL_HIGH] =\r\nstate->high.sclk;\r\npi->hw.low_sclk_index = R600_POWER_LEVEL_LOW;\r\npi->hw.medium_sclk_index = R600_POWER_LEVEL_MEDIUM;\r\npi->hw.high_sclk_index = R600_POWER_LEVEL_HIGH;\r\n}\r\nstatic void rv6xx_calculate_memory_clock_stepping_parameters(struct radeon_device *rdev,\r\nstruct rv6xx_ps *state)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\npi->hw.mclks[R600_POWER_LEVEL_CTXSW] =\r\nstate->high.mclk;\r\npi->hw.mclks[R600_POWER_LEVEL_HIGH] =\r\nstate->high.mclk;\r\npi->hw.mclks[R600_POWER_LEVEL_MEDIUM] =\r\nstate->medium.mclk;\r\npi->hw.mclks[R600_POWER_LEVEL_LOW] =\r\nstate->low.mclk;\r\npi->hw.high_mclk_index = R600_POWER_LEVEL_HIGH;\r\nif (state->high.mclk == state->medium.mclk)\r\npi->hw.medium_mclk_index =\r\npi->hw.high_mclk_index;\r\nelse\r\npi->hw.medium_mclk_index = R600_POWER_LEVEL_MEDIUM;\r\nif (state->medium.mclk == state->low.mclk)\r\npi->hw.low_mclk_index =\r\npi->hw.medium_mclk_index;\r\nelse\r\npi->hw.low_mclk_index = R600_POWER_LEVEL_LOW;\r\n}\r\nstatic void rv6xx_calculate_voltage_stepping_parameters(struct radeon_device *rdev,\r\nstruct rv6xx_ps *state)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\npi->hw.vddc[R600_POWER_LEVEL_CTXSW] = state->high.vddc;\r\npi->hw.vddc[R600_POWER_LEVEL_HIGH] = state->high.vddc;\r\npi->hw.vddc[R600_POWER_LEVEL_MEDIUM] = state->medium.vddc;\r\npi->hw.vddc[R600_POWER_LEVEL_LOW] = state->low.vddc;\r\npi->hw.backbias[R600_POWER_LEVEL_CTXSW] =\r\n(state->high.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? true : false;\r\npi->hw.backbias[R600_POWER_LEVEL_HIGH] =\r\n(state->high.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? true : false;\r\npi->hw.backbias[R600_POWER_LEVEL_MEDIUM] =\r\n(state->medium.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? true : false;\r\npi->hw.backbias[R600_POWER_LEVEL_LOW] =\r\n(state->low.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? true : false;\r\npi->hw.pcie_gen2[R600_POWER_LEVEL_HIGH] =\r\n(state->high.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? true : false;\r\npi->hw.pcie_gen2[R600_POWER_LEVEL_MEDIUM] =\r\n(state->medium.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? true : false;\r\npi->hw.pcie_gen2[R600_POWER_LEVEL_LOW] =\r\n(state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? true : false;\r\npi->hw.high_vddc_index = R600_POWER_LEVEL_HIGH;\r\nif ((state->high.vddc == state->medium.vddc) &&\r\n((state->high.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ==\r\n(state->medium.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE)))\r\npi->hw.medium_vddc_index =\r\npi->hw.high_vddc_index;\r\nelse\r\npi->hw.medium_vddc_index = R600_POWER_LEVEL_MEDIUM;\r\nif ((state->medium.vddc == state->low.vddc) &&\r\n((state->medium.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ==\r\n(state->low.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE)))\r\npi->hw.low_vddc_index =\r\npi->hw.medium_vddc_index;\r\nelse\r\npi->hw.medium_vddc_index = R600_POWER_LEVEL_LOW;\r\n}\r\nstatic inline u32 rv6xx_calculate_vco_frequency(u32 ref_clock,\r\nstruct atom_clock_dividers *dividers,\r\nu32 fb_divider_scale)\r\n{\r\nreturn ref_clock * ((dividers->fb_div & ~1) << fb_divider_scale) /\r\n(dividers->ref_div + 1);\r\n}\r\nstatic inline u32 rv6xx_calculate_spread_spectrum_clk_v(u32 vco_freq, u32 ref_freq,\r\nu32 ss_rate, u32 ss_percent,\r\nu32 fb_divider_scale)\r\n{\r\nu32 fb_divider = vco_freq / ref_freq;\r\nreturn (ss_percent * ss_rate * 4 * (fb_divider * fb_divider) /\r\n(5375 * ((vco_freq * 10) / (4096 >> fb_divider_scale))));\r\n}\r\nstatic inline u32 rv6xx_calculate_spread_spectrum_clk_s(u32 ss_rate, u32 ref_freq)\r\n{\r\nreturn (((ref_freq * 10) / (ss_rate * 2)) - 1) / 4;\r\n}\r\nstatic void rv6xx_program_engine_spread_spectrum(struct radeon_device *rdev,\r\nu32 clock, enum r600_power_level level)\r\n{\r\nu32 ref_clk = rdev->clock.spll.reference_freq;\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nstruct atom_clock_dividers dividers;\r\nstruct radeon_atom_ss ss;\r\nu32 vco_freq, clk_v, clk_s;\r\nrv6xx_enable_engine_spread_spectrum(rdev, level, false);\r\nif (clock && pi->sclk_ss) {\r\nif (radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM, clock, false, &dividers) == 0) {\r\nvco_freq = rv6xx_calculate_vco_frequency(ref_clk, &dividers,\r\npi->fb_div_scale);\r\nif (radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_ENGINE_SS, vco_freq)) {\r\nclk_v = rv6xx_calculate_spread_spectrum_clk_v(vco_freq,\r\n(ref_clk / (dividers.ref_div + 1)),\r\nss.rate,\r\nss.percentage,\r\npi->fb_div_scale);\r\nclk_s = rv6xx_calculate_spread_spectrum_clk_s(ss.rate,\r\n(ref_clk / (dividers.ref_div + 1)));\r\nrv6xx_set_engine_spread_spectrum_clk_v(rdev, level, clk_v);\r\nrv6xx_set_engine_spread_spectrum_clk_s(rdev, level, clk_s);\r\nrv6xx_enable_engine_spread_spectrum(rdev, level, true);\r\n}\r\n}\r\n}\r\n}\r\nstatic void rv6xx_program_sclk_spread_spectrum_parameters_except_lowest_entry(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nrv6xx_program_engine_spread_spectrum(rdev,\r\npi->hw.sclks[R600_POWER_LEVEL_HIGH],\r\nR600_POWER_LEVEL_HIGH);\r\nrv6xx_program_engine_spread_spectrum(rdev,\r\npi->hw.sclks[R600_POWER_LEVEL_MEDIUM],\r\nR600_POWER_LEVEL_MEDIUM);\r\n}\r\nstatic int rv6xx_program_mclk_stepping_entry(struct radeon_device *rdev,\r\nu32 entry, u32 clock)\r\n{\r\nstruct atom_clock_dividers dividers;\r\nif (radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM, clock, false, &dividers))\r\nreturn -EINVAL;\r\nrv6xx_memory_clock_entry_set_reference_divider(rdev, entry, dividers.ref_div);\r\nrv6xx_memory_clock_entry_set_feedback_divider(rdev, entry, dividers.fb_div);\r\nrv6xx_memory_clock_entry_set_post_divider(rdev, entry, dividers.post_div);\r\nif (dividers.enable_post_div)\r\nrv6xx_memory_clock_entry_enable_post_divider(rdev, entry, true);\r\nelse\r\nrv6xx_memory_clock_entry_enable_post_divider(rdev, entry, false);\r\nreturn 0;\r\n}\r\nstatic void rv6xx_program_mclk_stepping_parameters_except_lowest_entry(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nint i;\r\nfor (i = 1; i < R600_PM_NUMBER_OF_MCLKS; i++) {\r\nif (pi->hw.mclks[i])\r\nrv6xx_program_mclk_stepping_entry(rdev, i,\r\npi->hw.mclks[i]);\r\n}\r\n}\r\nstatic void rv6xx_find_memory_clock_with_highest_vco(struct radeon_device *rdev,\r\nu32 requested_memory_clock,\r\nu32 ref_clk,\r\nstruct atom_clock_dividers *dividers,\r\nu32 *vco_freq)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nstruct atom_clock_dividers req_dividers;\r\nu32 vco_freq_temp;\r\nif (radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM,\r\nrequested_memory_clock, false, &req_dividers) == 0) {\r\nvco_freq_temp = rv6xx_calculate_vco_frequency(ref_clk, &req_dividers,\r\npi->fb_div_scale);\r\nif (vco_freq_temp > *vco_freq) {\r\n*dividers = req_dividers;\r\n*vco_freq = vco_freq_temp;\r\n}\r\n}\r\n}\r\nstatic void rv6xx_program_mclk_spread_spectrum_parameters(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nu32 ref_clk = rdev->clock.mpll.reference_freq;\r\nstruct atom_clock_dividers dividers;\r\nstruct radeon_atom_ss ss;\r\nu32 vco_freq = 0, clk_v, clk_s;\r\nrv6xx_enable_memory_spread_spectrum(rdev, false);\r\nif (pi->mclk_ss) {\r\nrv6xx_find_memory_clock_with_highest_vco(rdev,\r\npi->hw.mclks[pi->hw.high_mclk_index],\r\nref_clk,\r\n&dividers,\r\n&vco_freq);\r\nrv6xx_find_memory_clock_with_highest_vco(rdev,\r\npi->hw.mclks[pi->hw.medium_mclk_index],\r\nref_clk,\r\n&dividers,\r\n&vco_freq);\r\nrv6xx_find_memory_clock_with_highest_vco(rdev,\r\npi->hw.mclks[pi->hw.low_mclk_index],\r\nref_clk,\r\n&dividers,\r\n&vco_freq);\r\nif (vco_freq) {\r\nif (radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_MEMORY_SS, vco_freq)) {\r\nclk_v = rv6xx_calculate_spread_spectrum_clk_v(vco_freq,\r\n(ref_clk / (dividers.ref_div + 1)),\r\nss.rate,\r\nss.percentage,\r\npi->fb_div_scale);\r\nclk_s = rv6xx_calculate_spread_spectrum_clk_s(ss.rate,\r\n(ref_clk / (dividers.ref_div + 1)));\r\nrv6xx_set_memory_spread_spectrum_clk_v(rdev, clk_v);\r\nrv6xx_set_memory_spread_spectrum_clk_s(rdev, clk_s);\r\nrv6xx_enable_memory_spread_spectrum(rdev, true);\r\n}\r\n}\r\n}\r\n}\r\nstatic int rv6xx_program_voltage_stepping_entry(struct radeon_device *rdev,\r\nu32 entry, u16 voltage)\r\n{\r\nu32 mask, set_pins;\r\nint ret;\r\nret = radeon_atom_get_voltage_gpio_settings(rdev, voltage,\r\nSET_VOLTAGE_TYPE_ASIC_VDDC,\r\n&set_pins, &mask);\r\nif (ret)\r\nreturn ret;\r\nr600_voltage_control_program_voltages(rdev, entry, set_pins);\r\nreturn 0;\r\n}\r\nstatic void rv6xx_program_voltage_stepping_parameters_except_lowest_entry(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nint i;\r\nfor (i = 1; i < R600_PM_NUMBER_OF_VOLTAGE_LEVELS; i++)\r\nrv6xx_program_voltage_stepping_entry(rdev, i,\r\npi->hw.vddc[i]);\r\n}\r\nstatic void rv6xx_program_backbias_stepping_parameters_except_lowest_entry(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nif (pi->hw.backbias[1])\r\nWREG32_P(VID_UPPER_GPIO_CNTL, MEDIUM_BACKBIAS_VALUE, ~MEDIUM_BACKBIAS_VALUE);\r\nelse\r\nWREG32_P(VID_UPPER_GPIO_CNTL, 0, ~MEDIUM_BACKBIAS_VALUE);\r\nif (pi->hw.backbias[2])\r\nWREG32_P(VID_UPPER_GPIO_CNTL, HIGH_BACKBIAS_VALUE, ~HIGH_BACKBIAS_VALUE);\r\nelse\r\nWREG32_P(VID_UPPER_GPIO_CNTL, 0, ~HIGH_BACKBIAS_VALUE);\r\n}\r\nstatic void rv6xx_program_sclk_spread_spectrum_parameters_lowest_entry(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nrv6xx_program_engine_spread_spectrum(rdev,\r\npi->hw.sclks[R600_POWER_LEVEL_LOW],\r\nR600_POWER_LEVEL_LOW);\r\n}\r\nstatic void rv6xx_program_mclk_stepping_parameters_lowest_entry(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nif (pi->hw.mclks[0])\r\nrv6xx_program_mclk_stepping_entry(rdev, 0,\r\npi->hw.mclks[0]);\r\n}\r\nstatic void rv6xx_program_voltage_stepping_parameters_lowest_entry(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nrv6xx_program_voltage_stepping_entry(rdev, 0,\r\npi->hw.vddc[0]);\r\n}\r\nstatic void rv6xx_program_backbias_stepping_parameters_lowest_entry(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nif (pi->hw.backbias[0])\r\nWREG32_P(VID_UPPER_GPIO_CNTL, LOW_BACKBIAS_VALUE, ~LOW_BACKBIAS_VALUE);\r\nelse\r\nWREG32_P(VID_UPPER_GPIO_CNTL, 0, ~LOW_BACKBIAS_VALUE);\r\n}\r\nstatic u32 calculate_memory_refresh_rate(struct radeon_device *rdev,\r\nu32 engine_clock)\r\n{\r\nu32 dram_rows, dram_refresh_rate;\r\nu32 tmp;\r\ntmp = (RREG32(RAMCFG) & NOOFROWS_MASK) >> NOOFROWS_SHIFT;\r\ndram_rows = 1 << (tmp + 10);\r\ndram_refresh_rate = 1 << ((RREG32(MC_SEQ_RESERVE_M) & 0x3) + 3);\r\nreturn ((engine_clock * 10) * dram_refresh_rate / dram_rows - 32) / 64;\r\n}\r\nstatic void rv6xx_program_memory_timing_parameters(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nu32 sqm_ratio;\r\nu32 arb_refresh_rate;\r\nu32 high_clock;\r\nif (pi->hw.sclks[R600_POWER_LEVEL_HIGH] <\r\n(pi->hw.sclks[R600_POWER_LEVEL_LOW] * 0xFF / 0x40))\r\nhigh_clock = pi->hw.sclks[R600_POWER_LEVEL_HIGH];\r\nelse\r\nhigh_clock =\r\npi->hw.sclks[R600_POWER_LEVEL_LOW] * 0xFF / 0x40;\r\nradeon_atom_set_engine_dram_timings(rdev, high_clock, 0);\r\nsqm_ratio = (STATE0(64 * high_clock / pi->hw.sclks[R600_POWER_LEVEL_LOW]) |\r\nSTATE1(64 * high_clock / pi->hw.sclks[R600_POWER_LEVEL_MEDIUM]) |\r\nSTATE2(64 * high_clock / pi->hw.sclks[R600_POWER_LEVEL_HIGH]) |\r\nSTATE3(64 * high_clock / pi->hw.sclks[R600_POWER_LEVEL_HIGH]));\r\nWREG32(SQM_RATIO, sqm_ratio);\r\narb_refresh_rate =\r\n(POWERMODE0(calculate_memory_refresh_rate(rdev,\r\npi->hw.sclks[R600_POWER_LEVEL_LOW])) |\r\nPOWERMODE1(calculate_memory_refresh_rate(rdev,\r\npi->hw.sclks[R600_POWER_LEVEL_MEDIUM])) |\r\nPOWERMODE2(calculate_memory_refresh_rate(rdev,\r\npi->hw.sclks[R600_POWER_LEVEL_HIGH])) |\r\nPOWERMODE3(calculate_memory_refresh_rate(rdev,\r\npi->hw.sclks[R600_POWER_LEVEL_HIGH])));\r\nWREG32(ARB_RFSH_RATE, arb_refresh_rate);\r\n}\r\nstatic void rv6xx_program_mpll_timing_parameters(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nr600_set_mpll_lock_time(rdev, R600_MPLLLOCKTIME_DFLT *\r\npi->mpll_ref_div);\r\nr600_set_mpll_reset_time(rdev, R600_MPLLRESETTIME_DFLT);\r\n}\r\nstatic void rv6xx_program_bsp(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nu32 ref_clk = rdev->clock.spll.reference_freq;\r\nr600_calculate_u_and_p(R600_ASI_DFLT,\r\nref_clk, 16,\r\n&pi->bsp,\r\n&pi->bsu);\r\nr600_set_bsp(rdev, pi->bsu, pi->bsp);\r\n}\r\nstatic void rv6xx_program_at(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nr600_set_at(rdev,\r\n(pi->hw.rp[0] * pi->bsp) / 200,\r\n(pi->hw.rp[1] * pi->bsp) / 200,\r\n(pi->hw.lp[2] * pi->bsp) / 200,\r\n(pi->hw.lp[1] * pi->bsp) / 200);\r\n}\r\nstatic void rv6xx_program_git(struct radeon_device *rdev)\r\n{\r\nr600_set_git(rdev, R600_GICST_DFLT);\r\n}\r\nstatic void rv6xx_program_tp(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < R600_PM_NUMBER_OF_TC; i++)\r\nr600_set_tc(rdev, i, r600_utc[i], r600_dtc[i]);\r\nr600_select_td(rdev, R600_TD_DFLT);\r\n}\r\nstatic void rv6xx_program_vc(struct radeon_device *rdev)\r\n{\r\nr600_set_vrc(rdev, R600_VRC_DFLT);\r\n}\r\nstatic void rv6xx_clear_vc(struct radeon_device *rdev)\r\n{\r\nr600_set_vrc(rdev, 0);\r\n}\r\nstatic void rv6xx_program_tpp(struct radeon_device *rdev)\r\n{\r\nr600_set_tpu(rdev, R600_TPU_DFLT);\r\nr600_set_tpc(rdev, R600_TPC_DFLT);\r\n}\r\nstatic void rv6xx_program_sstp(struct radeon_device *rdev)\r\n{\r\nr600_set_sstu(rdev, R600_SSTU_DFLT);\r\nr600_set_sst(rdev, R600_SST_DFLT);\r\n}\r\nstatic void rv6xx_program_fcp(struct radeon_device *rdev)\r\n{\r\nr600_set_fctu(rdev, R600_FCTU_DFLT);\r\nr600_set_fct(rdev, R600_FCT_DFLT);\r\n}\r\nstatic void rv6xx_program_vddc3d_parameters(struct radeon_device *rdev)\r\n{\r\nr600_set_vddc3d_oorsu(rdev, R600_VDDC3DOORSU_DFLT);\r\nr600_set_vddc3d_oorphc(rdev, R600_VDDC3DOORPHC_DFLT);\r\nr600_set_vddc3d_oorsdc(rdev, R600_VDDC3DOORSDC_DFLT);\r\nr600_set_ctxcgtt3d_rphc(rdev, R600_CTXCGTT3DRPHC_DFLT);\r\nr600_set_ctxcgtt3d_rsdc(rdev, R600_CTXCGTT3DRSDC_DFLT);\r\n}\r\nstatic void rv6xx_program_voltage_timing_parameters(struct radeon_device *rdev)\r\n{\r\nu32 rt;\r\nr600_vid_rt_set_vru(rdev, R600_VRU_DFLT);\r\nr600_vid_rt_set_vrt(rdev,\r\nrv6xx_compute_count_for_delay(rdev,\r\nrdev->pm.dpm.voltage_response_time,\r\nR600_VRU_DFLT));\r\nrt = rv6xx_compute_count_for_delay(rdev,\r\nrdev->pm.dpm.backbias_response_time,\r\nR600_VRU_DFLT);\r\nrv6xx_vid_response_set_brt(rdev, (rt + 0x1F) >> 5);\r\n}\r\nstatic void rv6xx_program_engine_speed_parameters(struct radeon_device *rdev)\r\n{\r\nr600_vid_rt_set_ssu(rdev, R600_SPLLSTEPUNIT_DFLT);\r\nrv6xx_enable_engine_feedback_and_reference_sync(rdev);\r\n}\r\nstatic u64 rv6xx_get_master_voltage_mask(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nu64 master_mask = 0;\r\nint i;\r\nfor (i = 0; i < R600_PM_NUMBER_OF_VOLTAGE_LEVELS; i++) {\r\nu32 tmp_mask, tmp_set_pins;\r\nint ret;\r\nret = radeon_atom_get_voltage_gpio_settings(rdev,\r\npi->hw.vddc[i],\r\nSET_VOLTAGE_TYPE_ASIC_VDDC,\r\n&tmp_set_pins, &tmp_mask);\r\nif (ret == 0)\r\nmaster_mask |= tmp_mask;\r\n}\r\nreturn master_mask;\r\n}\r\nstatic void rv6xx_program_voltage_gpio_pins(struct radeon_device *rdev)\r\n{\r\nr600_voltage_control_enable_pins(rdev,\r\nrv6xx_get_master_voltage_mask(rdev));\r\n}\r\nstatic void rv6xx_enable_static_voltage_control(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nbool enable)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nif (enable)\r\nradeon_atom_set_voltage(rdev,\r\nnew_state->low.vddc,\r\nSET_VOLTAGE_TYPE_ASIC_VDDC);\r\nelse\r\nr600_voltage_control_deactivate_static_control(rdev,\r\nrv6xx_get_master_voltage_mask(rdev));\r\n}\r\nstatic void rv6xx_enable_display_gap(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable) {\r\nu32 tmp = (DISP1_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM) |\r\nDISP2_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM) |\r\nDISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE) |\r\nDISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE) |\r\nVBI_TIMER_COUNT(0x3FFF) |\r\nVBI_TIMER_UNIT(7));\r\nWREG32(CG_DISPLAY_GAP_CNTL, tmp);\r\nWREG32_P(MCLK_PWRMGT_CNTL, USE_DISPLAY_GAP, ~USE_DISPLAY_GAP);\r\n} else\r\nWREG32_P(MCLK_PWRMGT_CNTL, 0, ~USE_DISPLAY_GAP);\r\n}\r\nstatic void rv6xx_program_power_level_enter_state(struct radeon_device *rdev)\r\n{\r\nr600_power_level_set_enter_index(rdev, R600_POWER_LEVEL_MEDIUM);\r\n}\r\nstatic void rv6xx_calculate_t(u32 l_f, u32 h_f, int h,\r\nint d_l, int d_r, u8 *l, u8 *r)\r\n{\r\nint a_n, a_d, h_r, l_r;\r\nh_r = d_l;\r\nl_r = 100 - d_r;\r\na_n = (int)h_f * d_l + (int)l_f * (h - d_r);\r\na_d = (int)l_f * l_r + (int)h_f * h_r;\r\nif (a_d != 0) {\r\n*l = d_l - h_r * a_n / a_d;\r\n*r = d_r + l_r * a_n / a_d;\r\n}\r\n}\r\nstatic void rv6xx_calculate_ap(struct radeon_device *rdev,\r\nstruct rv6xx_ps *state)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\npi->hw.lp[0] = 0;\r\npi->hw.rp[R600_PM_NUMBER_OF_ACTIVITY_LEVELS - 1]\r\n= 100;\r\nrv6xx_calculate_t(state->low.sclk,\r\nstate->medium.sclk,\r\nR600_AH_DFLT,\r\nR600_LMP_DFLT,\r\nR600_RLP_DFLT,\r\n&pi->hw.lp[1],\r\n&pi->hw.rp[0]);\r\nrv6xx_calculate_t(state->medium.sclk,\r\nstate->high.sclk,\r\nR600_AH_DFLT,\r\nR600_LHP_DFLT,\r\nR600_RMP_DFLT,\r\n&pi->hw.lp[2],\r\n&pi->hw.rp[1]);\r\n}\r\nstatic void rv6xx_calculate_stepping_parameters(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nrv6xx_calculate_engine_speed_stepping_parameters(rdev, new_state);\r\nrv6xx_calculate_memory_clock_stepping_parameters(rdev, new_state);\r\nrv6xx_calculate_voltage_stepping_parameters(rdev, new_state);\r\nrv6xx_calculate_ap(rdev, new_state);\r\n}\r\nstatic void rv6xx_program_stepping_parameters_except_lowest_entry(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nrv6xx_program_mclk_stepping_parameters_except_lowest_entry(rdev);\r\nif (pi->voltage_control)\r\nrv6xx_program_voltage_stepping_parameters_except_lowest_entry(rdev);\r\nrv6xx_program_backbias_stepping_parameters_except_lowest_entry(rdev);\r\nrv6xx_program_sclk_spread_spectrum_parameters_except_lowest_entry(rdev);\r\nrv6xx_program_mclk_spread_spectrum_parameters(rdev);\r\nrv6xx_program_memory_timing_parameters(rdev);\r\n}\r\nstatic void rv6xx_program_stepping_parameters_lowest_entry(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nrv6xx_program_mclk_stepping_parameters_lowest_entry(rdev);\r\nif (pi->voltage_control)\r\nrv6xx_program_voltage_stepping_parameters_lowest_entry(rdev);\r\nrv6xx_program_backbias_stepping_parameters_lowest_entry(rdev);\r\nrv6xx_program_sclk_spread_spectrum_parameters_lowest_entry(rdev);\r\n}\r\nstatic void rv6xx_program_power_level_low(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_LOW,\r\npi->hw.low_vddc_index);\r\nr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_LOW,\r\npi->hw.low_mclk_index);\r\nr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_LOW,\r\npi->hw.low_sclk_index);\r\nr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_LOW,\r\nR600_DISPLAY_WATERMARK_LOW);\r\nr600_power_level_set_pcie_gen2(rdev, R600_POWER_LEVEL_LOW,\r\npi->hw.pcie_gen2[R600_POWER_LEVEL_LOW]);\r\n}\r\nstatic void rv6xx_program_power_level_low_to_lowest_state(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_LOW, 0);\r\nr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_LOW, 0);\r\nr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_LOW, 0);\r\nr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_LOW,\r\nR600_DISPLAY_WATERMARK_LOW);\r\nr600_power_level_set_pcie_gen2(rdev, R600_POWER_LEVEL_LOW,\r\npi->hw.pcie_gen2[R600_POWER_LEVEL_LOW]);\r\n}\r\nstatic void rv6xx_program_power_level_medium(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_MEDIUM,\r\npi->hw.medium_vddc_index);\r\nr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_MEDIUM,\r\npi->hw.medium_mclk_index);\r\nr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_MEDIUM,\r\npi->hw.medium_sclk_index);\r\nr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_MEDIUM,\r\nR600_DISPLAY_WATERMARK_LOW);\r\nr600_power_level_set_pcie_gen2(rdev, R600_POWER_LEVEL_MEDIUM,\r\npi->hw.pcie_gen2[R600_POWER_LEVEL_MEDIUM]);\r\n}\r\nstatic void rv6xx_program_power_level_medium_for_transition(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nrv6xx_program_mclk_stepping_entry(rdev,\r\nR600_POWER_LEVEL_CTXSW,\r\npi->hw.mclks[pi->hw.low_mclk_index]);\r\nr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_MEDIUM, 1);\r\nr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_MEDIUM,\r\nR600_POWER_LEVEL_CTXSW);\r\nr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_MEDIUM,\r\npi->hw.medium_sclk_index);\r\nr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_MEDIUM,\r\nR600_DISPLAY_WATERMARK_LOW);\r\nrv6xx_enable_engine_spread_spectrum(rdev, R600_POWER_LEVEL_MEDIUM, false);\r\nr600_power_level_set_pcie_gen2(rdev, R600_POWER_LEVEL_MEDIUM,\r\npi->hw.pcie_gen2[R600_POWER_LEVEL_LOW]);\r\n}\r\nstatic void rv6xx_program_power_level_high(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_HIGH,\r\npi->hw.high_vddc_index);\r\nr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_HIGH,\r\npi->hw.high_mclk_index);\r\nr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_HIGH,\r\npi->hw.high_sclk_index);\r\nr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_HIGH,\r\nR600_DISPLAY_WATERMARK_HIGH);\r\nr600_power_level_set_pcie_gen2(rdev, R600_POWER_LEVEL_HIGH,\r\npi->hw.pcie_gen2[R600_POWER_LEVEL_HIGH]);\r\n}\r\nstatic void rv6xx_enable_backbias(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, BACKBIAS_PAD_EN | BACKBIAS_DPM_CNTL,\r\n~(BACKBIAS_PAD_EN | BACKBIAS_DPM_CNTL));\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0,\r\n~(BACKBIAS_VALUE | BACKBIAS_PAD_EN | BACKBIAS_DPM_CNTL));\r\n}\r\nstatic void rv6xx_program_display_gap(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32(CG_DISPLAY_GAP_CNTL);\r\ntmp &= ~(DISP1_GAP_MCHG_MASK | DISP2_GAP_MCHG_MASK);\r\nif (rdev->pm.dpm.new_active_crtcs & 1) {\r\ntmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK);\r\ntmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\r\n} else if (rdev->pm.dpm.new_active_crtcs & 2) {\r\ntmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\r\ntmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK);\r\n} else {\r\ntmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\r\ntmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\r\n}\r\nWREG32(CG_DISPLAY_GAP_CNTL, tmp);\r\n}\r\nstatic void rv6xx_set_sw_voltage_to_safe(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\r\nu16 safe_voltage;\r\nsafe_voltage = (new_state->low.vddc >= old_state->low.vddc) ?\r\nnew_state->low.vddc : old_state->low.vddc;\r\nrv6xx_program_voltage_stepping_entry(rdev, R600_POWER_LEVEL_CTXSW,\r\nsafe_voltage);\r\nWREG32_P(GENERAL_PWRMGT, SW_GPIO_INDEX(R600_POWER_LEVEL_CTXSW),\r\n~SW_GPIO_INDEX_MASK);\r\n}\r\nstatic void rv6xx_set_sw_voltage_to_low(struct radeon_device *rdev,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\r\nrv6xx_program_voltage_stepping_entry(rdev, R600_POWER_LEVEL_CTXSW,\r\nold_state->low.vddc);\r\nWREG32_P(GENERAL_PWRMGT, SW_GPIO_INDEX(R600_POWER_LEVEL_CTXSW),\r\n~SW_GPIO_INDEX_MASK);\r\n}\r\nstatic void rv6xx_set_safe_backbias(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\r\nif ((new_state->low.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) &&\r\n(old_state->low.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE))\r\nWREG32_P(GENERAL_PWRMGT, BACKBIAS_VALUE, ~BACKBIAS_VALUE);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~BACKBIAS_VALUE);\r\n}\r\nstatic void rv6xx_set_safe_pcie_gen2(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\r\nif ((new_state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) !=\r\n(old_state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2))\r\nrv6xx_force_pcie_gen1(rdev);\r\n}\r\nstatic void rv6xx_enable_dynamic_voltage_control(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, VOLT_PWRMGT_EN, ~VOLT_PWRMGT_EN);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~VOLT_PWRMGT_EN);\r\n}\r\nstatic void rv6xx_enable_dynamic_backbias_control(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, BACKBIAS_DPM_CNTL, ~BACKBIAS_DPM_CNTL);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~BACKBIAS_DPM_CNTL);\r\n}\r\nstatic int rv6xx_step_sw_voltage(struct radeon_device *rdev,\r\nu16 initial_voltage,\r\nu16 target_voltage)\r\n{\r\nu16 current_voltage;\r\nu16 true_target_voltage;\r\nu16 voltage_step;\r\nint signed_voltage_step;\r\nif ((radeon_atom_get_voltage_step(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC,\r\n&voltage_step)) ||\r\n(radeon_atom_round_to_true_voltage(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC,\r\ninitial_voltage, &current_voltage)) ||\r\n(radeon_atom_round_to_true_voltage(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC,\r\ntarget_voltage, &true_target_voltage)))\r\nreturn -EINVAL;\r\nif (true_target_voltage < current_voltage)\r\nsigned_voltage_step = -(int)voltage_step;\r\nelse\r\nsigned_voltage_step = voltage_step;\r\nwhile (current_voltage != true_target_voltage) {\r\ncurrent_voltage += signed_voltage_step;\r\nrv6xx_program_voltage_stepping_entry(rdev, R600_POWER_LEVEL_CTXSW,\r\ncurrent_voltage);\r\nmsleep((rdev->pm.dpm.voltage_response_time + 999) / 1000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rv6xx_step_voltage_if_increasing(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\r\nif (new_state->low.vddc > old_state->low.vddc)\r\nreturn rv6xx_step_sw_voltage(rdev,\r\nold_state->low.vddc,\r\nnew_state->low.vddc);\r\nreturn 0;\r\n}\r\nstatic int rv6xx_step_voltage_if_decreasing(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\r\nif (new_state->low.vddc < old_state->low.vddc)\r\nreturn rv6xx_step_sw_voltage(rdev,\r\nold_state->low.vddc,\r\nnew_state->low.vddc);\r\nelse\r\nreturn 0;\r\n}\r\nstatic void rv6xx_enable_high(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nif ((pi->restricted_levels < 1) ||\r\n(pi->restricted_levels == 3))\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, true);\r\n}\r\nstatic void rv6xx_enable_medium(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nif (pi->restricted_levels < 2)\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, true);\r\n}\r\nstatic void rv6xx_set_dpm_event_sources(struct radeon_device *rdev, u32 sources)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nbool want_thermal_protection;\r\nenum radeon_dpm_event_src dpm_event_src;\r\nswitch (sources) {\r\ncase 0:\r\ndefault:\r\nwant_thermal_protection = false;\r\nbreak;\r\ncase (1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL):\r\nwant_thermal_protection = true;\r\ndpm_event_src = RADEON_DPM_EVENT_SRC_DIGITAL;\r\nbreak;\r\ncase (1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL):\r\nwant_thermal_protection = true;\r\ndpm_event_src = RADEON_DPM_EVENT_SRC_EXTERNAL;\r\nbreak;\r\ncase ((1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL) |\r\n(1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL)):\r\nwant_thermal_protection = true;\r\ndpm_event_src = RADEON_DPM_EVENT_SRC_DIGIAL_OR_EXTERNAL;\r\nbreak;\r\n}\r\nif (want_thermal_protection) {\r\nWREG32_P(CG_THERMAL_CTRL, DPM_EVENT_SRC(dpm_event_src), ~DPM_EVENT_SRC_MASK);\r\nif (pi->thermal_protection)\r\nWREG32_P(GENERAL_PWRMGT, 0, ~THERMAL_PROTECTION_DIS);\r\n} else {\r\nWREG32_P(GENERAL_PWRMGT, THERMAL_PROTECTION_DIS, ~THERMAL_PROTECTION_DIS);\r\n}\r\n}\r\nstatic void rv6xx_enable_auto_throttle_source(struct radeon_device *rdev,\r\nenum radeon_dpm_auto_throttle_src source,\r\nbool enable)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nif (enable) {\r\nif (!(pi->active_auto_throttle_sources & (1 << source))) {\r\npi->active_auto_throttle_sources |= 1 << source;\r\nrv6xx_set_dpm_event_sources(rdev, pi->active_auto_throttle_sources);\r\n}\r\n} else {\r\nif (pi->active_auto_throttle_sources & (1 << source)) {\r\npi->active_auto_throttle_sources &= ~(1 << source);\r\nrv6xx_set_dpm_event_sources(rdev, pi->active_auto_throttle_sources);\r\n}\r\n}\r\n}\r\nstatic void rv6xx_enable_thermal_protection(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nif (pi->active_auto_throttle_sources)\r\nr600_enable_thermal_protection(rdev, enable);\r\n}\r\nstatic void rv6xx_generate_transition_stepping(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nrv6xx_generate_steps(rdev,\r\nold_state->low.sclk,\r\nnew_state->low.sclk,\r\n0, &pi->hw.medium_sclk_index);\r\n}\r\nstatic void rv6xx_generate_low_step(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\npi->hw.low_sclk_index = 0;\r\nrv6xx_generate_single_step(rdev,\r\nnew_state->low.sclk,\r\n0);\r\n}\r\nstatic void rv6xx_invalidate_intermediate_steps(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nrv6xx_invalidate_intermediate_steps_range(rdev, 0,\r\npi->hw.medium_sclk_index);\r\n}\r\nstatic void rv6xx_generate_stepping_table(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\npi->hw.low_sclk_index = 0;\r\nrv6xx_generate_steps(rdev,\r\nnew_state->low.sclk,\r\nnew_state->medium.sclk,\r\n0,\r\n&pi->hw.medium_sclk_index);\r\nrv6xx_generate_steps(rdev,\r\nnew_state->medium.sclk,\r\nnew_state->high.sclk,\r\npi->hw.medium_sclk_index,\r\n&pi->hw.high_sclk_index);\r\n}\r\nstatic void rv6xx_enable_spread_spectrum(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nrv6xx_enable_dynamic_spread_spectrum(rdev, true);\r\nelse {\r\nrv6xx_enable_engine_spread_spectrum(rdev, R600_POWER_LEVEL_LOW, false);\r\nrv6xx_enable_engine_spread_spectrum(rdev, R600_POWER_LEVEL_MEDIUM, false);\r\nrv6xx_enable_engine_spread_spectrum(rdev, R600_POWER_LEVEL_HIGH, false);\r\nrv6xx_enable_dynamic_spread_spectrum(rdev, false);\r\nrv6xx_enable_memory_spread_spectrum(rdev, false);\r\n}\r\n}\r\nstatic void rv6xx_reset_lvtm_data_sync(struct radeon_device *rdev)\r\n{\r\nif (ASIC_IS_DCE3(rdev))\r\nWREG32_P(DCE3_LVTMA_DATA_SYNCHRONIZATION, LVTMA_PFREQCHG, ~LVTMA_PFREQCHG);\r\nelse\r\nWREG32_P(LVTMA_DATA_SYNCHRONIZATION, LVTMA_PFREQCHG, ~LVTMA_PFREQCHG);\r\n}\r\nstatic void rv6xx_enable_dynamic_pcie_gen2(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nbool enable)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nif (enable) {\r\nrv6xx_enable_bif_dynamic_pcie_gen2(rdev, true);\r\nrv6xx_enable_pcie_gen2_support(rdev);\r\nr600_enable_dynamic_pcie_gen2(rdev, true);\r\n} else {\r\nif (!(new_state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2))\r\nrv6xx_force_pcie_gen1(rdev);\r\nrv6xx_enable_bif_dynamic_pcie_gen2(rdev, false);\r\nr600_enable_dynamic_pcie_gen2(rdev, false);\r\n}\r\n}\r\nstatic void rv6xx_set_uvd_clock_before_set_eng_clock(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nstruct rv6xx_ps *current_state = rv6xx_get_ps(old_ps);\r\nif ((new_ps->vclk == old_ps->vclk) &&\r\n(new_ps->dclk == old_ps->dclk))\r\nreturn;\r\nif (new_state->high.sclk >= current_state->high.sclk)\r\nreturn;\r\nradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\r\n}\r\nstatic void rv6xx_set_uvd_clock_after_set_eng_clock(struct radeon_device *rdev,\r\nstruct radeon_ps *new_ps,\r\nstruct radeon_ps *old_ps)\r\n{\r\nstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\r\nstruct rv6xx_ps *current_state = rv6xx_get_ps(old_ps);\r\nif ((new_ps->vclk == old_ps->vclk) &&\r\n(new_ps->dclk == old_ps->dclk))\r\nreturn;\r\nif (new_state->high.sclk < current_state->high.sclk)\r\nreturn;\r\nradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\r\n}\r\nint rv6xx_dpm_enable(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\r\nif (r600_dynamicpm_enabled(rdev))\r\nreturn -EINVAL;\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\r\nrv6xx_enable_backbias(rdev, true);\r\nif (pi->dynamic_ss)\r\nrv6xx_enable_spread_spectrum(rdev, true);\r\nrv6xx_program_mpll_timing_parameters(rdev);\r\nrv6xx_program_bsp(rdev);\r\nrv6xx_program_git(rdev);\r\nrv6xx_program_tp(rdev);\r\nrv6xx_program_tpp(rdev);\r\nrv6xx_program_sstp(rdev);\r\nrv6xx_program_fcp(rdev);\r\nrv6xx_program_vddc3d_parameters(rdev);\r\nrv6xx_program_voltage_timing_parameters(rdev);\r\nrv6xx_program_engine_speed_parameters(rdev);\r\nrv6xx_enable_display_gap(rdev, true);\r\nif (pi->display_gap == false)\r\nrv6xx_enable_display_gap(rdev, false);\r\nrv6xx_program_power_level_enter_state(rdev);\r\nrv6xx_calculate_stepping_parameters(rdev, boot_ps);\r\nif (pi->voltage_control)\r\nrv6xx_program_voltage_gpio_pins(rdev);\r\nrv6xx_generate_stepping_table(rdev, boot_ps);\r\nrv6xx_program_stepping_parameters_except_lowest_entry(rdev);\r\nrv6xx_program_stepping_parameters_lowest_entry(rdev);\r\nrv6xx_program_power_level_low(rdev);\r\nrv6xx_program_power_level_medium(rdev);\r\nrv6xx_program_power_level_high(rdev);\r\nrv6xx_program_vc(rdev);\r\nrv6xx_program_at(rdev);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, true);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, true);\r\nrv6xx_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\r\nr600_start_dpm(rdev);\r\nif (pi->voltage_control)\r\nrv6xx_enable_static_voltage_control(rdev, boot_ps, false);\r\nif (pi->dynamic_pcie_gen2)\r\nrv6xx_enable_dynamic_pcie_gen2(rdev, boot_ps, true);\r\nif (pi->gfx_clock_gating)\r\nr600_gfx_clockgating_enable(rdev, true);\r\nreturn 0;\r\n}\r\nvoid rv6xx_dpm_disable(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\r\nif (!r600_dynamicpm_enabled(rdev))\r\nreturn;\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, true);\r\nrv6xx_enable_display_gap(rdev, false);\r\nrv6xx_clear_vc(rdev);\r\nr600_set_at(rdev, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF);\r\nif (pi->thermal_protection)\r\nr600_enable_thermal_protection(rdev, false);\r\nr600_wait_for_power_level(rdev, R600_POWER_LEVEL_LOW);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, false);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, false);\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\r\nrv6xx_enable_backbias(rdev, false);\r\nrv6xx_enable_spread_spectrum(rdev, false);\r\nif (pi->voltage_control)\r\nrv6xx_enable_static_voltage_control(rdev, boot_ps, true);\r\nif (pi->dynamic_pcie_gen2)\r\nrv6xx_enable_dynamic_pcie_gen2(rdev, boot_ps, false);\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nrdev->irq.dpm_thermal = false;\r\nradeon_irq_set(rdev);\r\n}\r\nif (pi->gfx_clock_gating)\r\nr600_gfx_clockgating_enable(rdev, false);\r\nr600_stop_dpm(rdev);\r\n}\r\nint rv6xx_dpm_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nstruct radeon_ps *new_ps = rdev->pm.dpm.requested_ps;\r\nstruct radeon_ps *old_ps = rdev->pm.dpm.current_ps;\r\nint ret;\r\npi->restricted_levels = 0;\r\nrv6xx_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\r\nrv6xx_clear_vc(rdev);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\r\nr600_set_at(rdev, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF);\r\nif (pi->thermal_protection)\r\nr600_enable_thermal_protection(rdev, false);\r\nr600_wait_for_power_level(rdev, R600_POWER_LEVEL_LOW);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, false);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, false);\r\nrv6xx_generate_transition_stepping(rdev, new_ps, old_ps);\r\nrv6xx_program_power_level_medium_for_transition(rdev);\r\nif (pi->voltage_control) {\r\nrv6xx_set_sw_voltage_to_safe(rdev, new_ps, old_ps);\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\r\nrv6xx_set_sw_voltage_to_low(rdev, old_ps);\r\n}\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\r\nrv6xx_set_safe_backbias(rdev, new_ps, old_ps);\r\nif (pi->dynamic_pcie_gen2)\r\nrv6xx_set_safe_pcie_gen2(rdev, new_ps, old_ps);\r\nif (pi->voltage_control)\r\nrv6xx_enable_dynamic_voltage_control(rdev, false);\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\r\nrv6xx_enable_dynamic_backbias_control(rdev, false);\r\nif (pi->voltage_control) {\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\r\nrv6xx_step_voltage_if_increasing(rdev, new_ps, old_ps);\r\nmsleep((rdev->pm.dpm.voltage_response_time + 999) / 1000);\r\n}\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, true);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, false);\r\nr600_wait_for_power_level_unequal(rdev, R600_POWER_LEVEL_LOW);\r\nrv6xx_generate_low_step(rdev, new_ps);\r\nrv6xx_invalidate_intermediate_steps(rdev);\r\nrv6xx_calculate_stepping_parameters(rdev, new_ps);\r\nrv6xx_program_stepping_parameters_lowest_entry(rdev);\r\nrv6xx_program_power_level_low_to_lowest_state(rdev);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\r\nr600_wait_for_power_level(rdev, R600_POWER_LEVEL_LOW);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, false);\r\nif (pi->voltage_control) {\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC) {\r\nret = rv6xx_step_voltage_if_decreasing(rdev, new_ps, old_ps);\r\nif (ret)\r\nreturn ret;\r\n}\r\nrv6xx_enable_dynamic_voltage_control(rdev, true);\r\n}\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\r\nrv6xx_enable_dynamic_backbias_control(rdev, true);\r\nif (pi->dynamic_pcie_gen2)\r\nrv6xx_enable_dynamic_pcie_gen2(rdev, new_ps, true);\r\nrv6xx_reset_lvtm_data_sync(rdev);\r\nrv6xx_generate_stepping_table(rdev, new_ps);\r\nrv6xx_program_stepping_parameters_except_lowest_entry(rdev);\r\nrv6xx_program_power_level_low(rdev);\r\nrv6xx_program_power_level_medium(rdev);\r\nrv6xx_program_power_level_high(rdev);\r\nrv6xx_enable_medium(rdev);\r\nrv6xx_enable_high(rdev);\r\nif (pi->thermal_protection)\r\nrv6xx_enable_thermal_protection(rdev, true);\r\nrv6xx_program_vc(rdev);\r\nrv6xx_program_at(rdev);\r\nrv6xx_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\r\nreturn 0;\r\n}\r\nvoid rv6xx_setup_asic(struct radeon_device *rdev)\r\n{\r\nr600_enable_acpi_pm(rdev);\r\nif (radeon_aspm != 0) {\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_ASPM_L0s)\r\nrv6xx_enable_l0s(rdev);\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_ASPM_L1)\r\nrv6xx_enable_l1(rdev);\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_TURNOFFPLL_ASPML1)\r\nrv6xx_enable_pll_sleep_in_l1(rdev);\r\n}\r\n}\r\nvoid rv6xx_dpm_display_configuration_changed(struct radeon_device *rdev)\r\n{\r\nrv6xx_program_display_gap(rdev);\r\n}\r\nstatic void rv6xx_parse_pplib_non_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps,\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info)\r\n{\r\nrps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\r\nrps->class = le16_to_cpu(non_clock_info->usClassification);\r\nrps->class2 = le16_to_cpu(non_clock_info->usClassification2);\r\nif (r600_is_uvd_state(rps->class, rps->class2)) {\r\nrps->vclk = RV6XX_DEFAULT_VCLK_FREQ;\r\nrps->dclk = RV6XX_DEFAULT_DCLK_FREQ;\r\n} else {\r\nrps->vclk = 0;\r\nrps->dclk = 0;\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)\r\nrdev->pm.dpm.boot_ps = rps;\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nrdev->pm.dpm.uvd_ps = rps;\r\n}\r\nstatic void rv6xx_parse_pplib_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps, int index,\r\nunion pplib_clock_info *clock_info)\r\n{\r\nstruct rv6xx_ps *ps = rv6xx_get_ps(rps);\r\nu32 sclk, mclk;\r\nu16 vddc;\r\nstruct rv6xx_pl *pl;\r\nswitch (index) {\r\ncase 0:\r\npl = &ps->low;\r\nbreak;\r\ncase 1:\r\npl = &ps->medium;\r\nbreak;\r\ncase 2:\r\ndefault:\r\npl = &ps->high;\r\nbreak;\r\n}\r\nsclk = le16_to_cpu(clock_info->r600.usEngineClockLow);\r\nsclk |= clock_info->r600.ucEngineClockHigh << 16;\r\nmclk = le16_to_cpu(clock_info->r600.usMemoryClockLow);\r\nmclk |= clock_info->r600.ucMemoryClockHigh << 16;\r\npl->mclk = mclk;\r\npl->sclk = sclk;\r\npl->vddc = le16_to_cpu(clock_info->r600.usVDDC);\r\npl->flags = le32_to_cpu(clock_info->r600.ulFlags);\r\nif (pl->vddc == 0xff01) {\r\nif (radeon_atom_get_max_vddc(rdev, 0, 0, &vddc) == 0)\r\npl->vddc = vddc;\r\n}\r\nif (pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) {\r\nif ((rdev->family == CHIP_RV610) || (rdev->family == CHIP_RV630)) {\r\nif (pl->vddc < 1100)\r\npl->flags &= ~ATOM_PPLIB_R600_FLAGS_PCIEGEN2;\r\n}\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\r\nu16 vddc, vddci, mvdd;\r\nradeon_atombios_get_default_voltages(rdev, &vddc, &vddci, &mvdd);\r\npl->mclk = rdev->clock.default_mclk;\r\npl->sclk = rdev->clock.default_sclk;\r\npl->vddc = vddc;\r\n}\r\n}\r\nstatic int rv6xx_parse_power_table(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\r\nunion pplib_power_state *power_state;\r\nint i, j;\r\nunion pplib_clock_info *clock_info;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nstruct rv6xx_ps *ps;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nrdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *\r\npower_info->pplib.ucNumStates, GFP_KERNEL);\r\nif (!rdev->pm.dpm.ps)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < power_info->pplib.ucNumStates; i++) {\r\npower_state = (union pplib_power_state *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usStateArrayOffset) +\r\ni * power_info->pplib.ucStateEntrySize);\r\nnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset) +\r\n(power_state->v1.ucNonClockStateIndex *\r\npower_info->pplib.ucNonClockSize));\r\nif (power_info->pplib.ucStateEntrySize - 1) {\r\nu8 *idx;\r\nps = kzalloc(sizeof(struct rv6xx_ps), GFP_KERNEL);\r\nif (ps == NULL) {\r\nkfree(rdev->pm.dpm.ps);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.ps[i].ps_priv = ps;\r\nrv6xx_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\r\nnon_clock_info);\r\nidx = (u8 *)&power_state->v1.ucClockStateIndices[0];\r\nfor (j = 0; j < (power_info->pplib.ucStateEntrySize - 1); j++) {\r\nclock_info = (union pplib_clock_info *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usClockInfoArrayOffset) +\r\n(idx[j] * power_info->pplib.ucClockInfoSize));\r\nrv6xx_parse_pplib_clock_info(rdev,\r\n&rdev->pm.dpm.ps[i], j,\r\nclock_info);\r\n}\r\n}\r\n}\r\nrdev->pm.dpm.num_ps = power_info->pplib.ucNumStates;\r\nreturn 0;\r\n}\r\nint rv6xx_dpm_init(struct radeon_device *rdev)\r\n{\r\nstruct radeon_atom_ss ss;\r\nstruct atom_clock_dividers dividers;\r\nstruct rv6xx_power_info *pi;\r\nint ret;\r\npi = kzalloc(sizeof(struct rv6xx_power_info), GFP_KERNEL);\r\nif (pi == NULL)\r\nreturn -ENOMEM;\r\nrdev->pm.dpm.priv = pi;\r\nret = r600_get_platform_caps(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = rv6xx_parse_power_table(rdev);\r\nif (ret)\r\nreturn ret;\r\nif (rdev->pm.dpm.voltage_response_time == 0)\r\nrdev->pm.dpm.voltage_response_time = R600_VOLTAGERESPONSETIME_DFLT;\r\nif (rdev->pm.dpm.backbias_response_time == 0)\r\nrdev->pm.dpm.backbias_response_time = R600_BACKBIASRESPONSETIME_DFLT;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\n0, false, &dividers);\r\nif (ret)\r\npi->spll_ref_div = dividers.ref_div + 1;\r\nelse\r\npi->spll_ref_div = R600_REFERENCEDIVIDER_DFLT;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM,\r\n0, false, &dividers);\r\nif (ret)\r\npi->mpll_ref_div = dividers.ref_div + 1;\r\nelse\r\npi->mpll_ref_div = R600_REFERENCEDIVIDER_DFLT;\r\nif (rdev->family >= CHIP_RV670)\r\npi->fb_div_scale = 1;\r\nelse\r\npi->fb_div_scale = 0;\r\npi->voltage_control =\r\nradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0);\r\npi->gfx_clock_gating = true;\r\npi->sclk_ss = radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_ENGINE_SS, 0);\r\npi->mclk_ss = radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_MEMORY_SS, 0);\r\npi->sclk_ss = false;\r\nif (pi->sclk_ss || pi->mclk_ss)\r\npi->dynamic_ss = true;\r\nelse\r\npi->dynamic_ss = false;\r\npi->dynamic_pcie_gen2 = true;\r\nif (pi->gfx_clock_gating &&\r\n(rdev->pm.int_thermal_type != THERMAL_TYPE_NONE))\r\npi->thermal_protection = true;\r\nelse\r\npi->thermal_protection = false;\r\npi->display_gap = true;\r\nreturn 0;\r\n}\r\nvoid rv6xx_dpm_print_power_state(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct rv6xx_ps *ps = rv6xx_get_ps(rps);\r\nstruct rv6xx_pl *pl;\r\nr600_dpm_print_class_info(rps->class, rps->class2);\r\nr600_dpm_print_cap_info(rps->caps);\r\nprintk("\tuvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\npl = &ps->low;\r\nprintk("\t\tpower level 0 sclk: %u mclk: %u vddc: %u\n",\r\npl->sclk, pl->mclk, pl->vddc);\r\npl = &ps->medium;\r\nprintk("\t\tpower level 1 sclk: %u mclk: %u vddc: %u\n",\r\npl->sclk, pl->mclk, pl->vddc);\r\npl = &ps->high;\r\nprintk("\t\tpower level 2 sclk: %u mclk: %u vddc: %u\n",\r\npl->sclk, pl->mclk, pl->vddc);\r\nr600_dpm_print_ps_status(rdev, rps);\r\n}\r\nvoid rv6xx_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\r\nstruct seq_file *m)\r\n{\r\nstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\r\nstruct rv6xx_ps *ps = rv6xx_get_ps(rps);\r\nstruct rv6xx_pl *pl;\r\nu32 current_index =\r\n(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\r\nCURRENT_PROFILE_INDEX_SHIFT;\r\nif (current_index > 2) {\r\nseq_printf(m, "invalid dpm profile %d\n", current_index);\r\n} else {\r\nif (current_index == 0)\r\npl = &ps->low;\r\nelse if (current_index == 1)\r\npl = &ps->medium;\r\nelse\r\npl = &ps->high;\r\nseq_printf(m, "uvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nseq_printf(m, "power level %d sclk: %u mclk: %u vddc: %u\n",\r\ncurrent_index, pl->sclk, pl->mclk, pl->vddc);\r\n}\r\n}\r\nvoid rv6xx_dpm_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\r\nkfree(rdev->pm.dpm.ps[i].ps_priv);\r\n}\r\nkfree(rdev->pm.dpm.ps);\r\nkfree(rdev->pm.dpm.priv);\r\n}\r\nu32 rv6xx_dpm_get_sclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct rv6xx_ps *requested_state = rv6xx_get_ps(rdev->pm.dpm.requested_ps);\r\nif (low)\r\nreturn requested_state->low.sclk;\r\nelse\r\nreturn requested_state->high.sclk;\r\n}\r\nu32 rv6xx_dpm_get_mclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct rv6xx_ps *requested_state = rv6xx_get_ps(rdev->pm.dpm.requested_ps);\r\nif (low)\r\nreturn requested_state->low.mclk;\r\nelse\r\nreturn requested_state->high.mclk;\r\n}\r\nint rv6xx_dpm_force_performance_level(struct radeon_device *rdev,\r\nenum radeon_dpm_forced_level level)\r\n{\r\nstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\r\nif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\r\npi->restricted_levels = 3;\r\n} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\r\npi->restricted_levels = 2;\r\n} else {\r\npi->restricted_levels = 0;\r\n}\r\nrv6xx_clear_vc(rdev);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\r\nr600_set_at(rdev, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF);\r\nr600_wait_for_power_level(rdev, R600_POWER_LEVEL_LOW);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, false);\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, false);\r\nrv6xx_enable_medium(rdev);\r\nrv6xx_enable_high(rdev);\r\nif (pi->restricted_levels == 3)\r\nr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, false);\r\nrv6xx_program_vc(rdev);\r\nrv6xx_program_at(rdev);\r\nrdev->pm.dpm.forced_level = level;\r\nreturn 0;\r\n}
