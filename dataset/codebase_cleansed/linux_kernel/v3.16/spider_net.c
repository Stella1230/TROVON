static inline u32\r\nspider_net_read_reg(struct spider_net_card *card, u32 reg)\r\n{\r\nreturn in_be32(card->regs + reg);\r\n}\r\nstatic inline void\r\nspider_net_write_reg(struct spider_net_card *card, u32 reg, u32 value)\r\n{\r\nout_be32(card->regs + reg, value);\r\n}\r\nstatic void\r\nspider_net_write_phy(struct net_device *netdev, int mii_id,\r\nint reg, int val)\r\n{\r\nstruct spider_net_card *card = netdev_priv(netdev);\r\nu32 writevalue;\r\nwritevalue = ((u32)mii_id << 21) |\r\n((u32)reg << 16) | ((u32)val);\r\nspider_net_write_reg(card, SPIDER_NET_GPCWOPCMD, writevalue);\r\n}\r\nstatic int\r\nspider_net_read_phy(struct net_device *netdev, int mii_id, int reg)\r\n{\r\nstruct spider_net_card *card = netdev_priv(netdev);\r\nu32 readvalue;\r\nreadvalue = ((u32)mii_id << 21) | ((u32)reg << 16);\r\nspider_net_write_reg(card, SPIDER_NET_GPCROPCMD, readvalue);\r\ndo {\r\nreadvalue = spider_net_read_reg(card, SPIDER_NET_GPCROPCMD);\r\n} while (readvalue & SPIDER_NET_GPREXEC);\r\nreadvalue &= SPIDER_NET_GPRDAT_MASK;\r\nreturn readvalue;\r\n}\r\nstatic void\r\nspider_net_setup_aneg(struct spider_net_card *card)\r\n{\r\nstruct mii_phy *phy = &card->phy;\r\nu32 advertise = 0;\r\nu16 bmsr, estat;\r\nbmsr = spider_net_read_phy(card->netdev, phy->mii_id, MII_BMSR);\r\nestat = spider_net_read_phy(card->netdev, phy->mii_id, MII_ESTATUS);\r\nif (bmsr & BMSR_10HALF)\r\nadvertise |= ADVERTISED_10baseT_Half;\r\nif (bmsr & BMSR_10FULL)\r\nadvertise |= ADVERTISED_10baseT_Full;\r\nif (bmsr & BMSR_100HALF)\r\nadvertise |= ADVERTISED_100baseT_Half;\r\nif (bmsr & BMSR_100FULL)\r\nadvertise |= ADVERTISED_100baseT_Full;\r\nif ((bmsr & BMSR_ESTATEN) && (estat & ESTATUS_1000_TFULL))\r\nadvertise |= SUPPORTED_1000baseT_Full;\r\nif ((bmsr & BMSR_ESTATEN) && (estat & ESTATUS_1000_THALF))\r\nadvertise |= SUPPORTED_1000baseT_Half;\r\nsungem_phy_probe(phy, phy->mii_id);\r\nphy->def->ops->setup_aneg(phy, advertise);\r\n}\r\nstatic void\r\nspider_net_rx_irq_off(struct spider_net_card *card)\r\n{\r\nu32 regvalue;\r\nregvalue = SPIDER_NET_INT0_MASK_VALUE & (~SPIDER_NET_RXINT);\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT0MSK, regvalue);\r\n}\r\nstatic void\r\nspider_net_rx_irq_on(struct spider_net_card *card)\r\n{\r\nu32 regvalue;\r\nregvalue = SPIDER_NET_INT0_MASK_VALUE | SPIDER_NET_RXINT;\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT0MSK, regvalue);\r\n}\r\nstatic void\r\nspider_net_set_promisc(struct spider_net_card *card)\r\n{\r\nu32 macu, macl;\r\nstruct net_device *netdev = card->netdev;\r\nif (netdev->flags & IFF_PROMISC) {\r\nspider_net_write_reg(card, SPIDER_NET_GMRUAFILnR, 0);\r\nspider_net_write_reg(card, SPIDER_NET_GMRUAFILnR + 0x04, 0);\r\nspider_net_write_reg(card, SPIDER_NET_GMRUA0FIL15R,\r\nSPIDER_NET_PROMISC_VALUE);\r\n} else {\r\nmacu = netdev->dev_addr[0];\r\nmacu <<= 8;\r\nmacu |= netdev->dev_addr[1];\r\nmemcpy(&macl, &netdev->dev_addr[2], sizeof(macl));\r\nmacu |= SPIDER_NET_UA_DESCR_VALUE;\r\nspider_net_write_reg(card, SPIDER_NET_GMRUAFILnR, macu);\r\nspider_net_write_reg(card, SPIDER_NET_GMRUAFILnR + 0x04, macl);\r\nspider_net_write_reg(card, SPIDER_NET_GMRUA0FIL15R,\r\nSPIDER_NET_NONPROMISC_VALUE);\r\n}\r\n}\r\nstatic int\r\nspider_net_get_mac_address(struct net_device *netdev)\r\n{\r\nstruct spider_net_card *card = netdev_priv(netdev);\r\nu32 macl, macu;\r\nmacl = spider_net_read_reg(card, SPIDER_NET_GMACUNIMACL);\r\nmacu = spider_net_read_reg(card, SPIDER_NET_GMACUNIMACU);\r\nnetdev->dev_addr[0] = (macu >> 24) & 0xff;\r\nnetdev->dev_addr[1] = (macu >> 16) & 0xff;\r\nnetdev->dev_addr[2] = (macu >> 8) & 0xff;\r\nnetdev->dev_addr[3] = macu & 0xff;\r\nnetdev->dev_addr[4] = (macl >> 8) & 0xff;\r\nnetdev->dev_addr[5] = macl & 0xff;\r\nif (!is_valid_ether_addr(&netdev->dev_addr[0]))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nspider_net_get_descr_status(struct spider_net_hw_descr *hwdescr)\r\n{\r\nreturn hwdescr->dmac_cmd_status & SPIDER_NET_DESCR_IND_PROC_MASK;\r\n}\r\nstatic void\r\nspider_net_free_chain(struct spider_net_card *card,\r\nstruct spider_net_descr_chain *chain)\r\n{\r\nstruct spider_net_descr *descr;\r\ndescr = chain->ring;\r\ndo {\r\ndescr->bus_addr = 0;\r\ndescr->hwdescr->next_descr_addr = 0;\r\ndescr = descr->next;\r\n} while (descr != chain->ring);\r\ndma_free_coherent(&card->pdev->dev, chain->num_desc,\r\nchain->hwring, chain->dma_addr);\r\n}\r\nstatic int\r\nspider_net_init_chain(struct spider_net_card *card,\r\nstruct spider_net_descr_chain *chain)\r\n{\r\nint i;\r\nstruct spider_net_descr *descr;\r\nstruct spider_net_hw_descr *hwdescr;\r\ndma_addr_t buf;\r\nsize_t alloc_size;\r\nalloc_size = chain->num_desc * sizeof(struct spider_net_hw_descr);\r\nchain->hwring = dma_alloc_coherent(&card->pdev->dev, alloc_size,\r\n&chain->dma_addr, GFP_KERNEL);\r\nif (!chain->hwring)\r\nreturn -ENOMEM;\r\nmemset(chain->ring, 0, chain->num_desc * sizeof(struct spider_net_descr));\r\ndescr = chain->ring;\r\nhwdescr = chain->hwring;\r\nbuf = chain->dma_addr;\r\nfor (i=0; i < chain->num_desc; i++, descr++, hwdescr++) {\r\nhwdescr->dmac_cmd_status = SPIDER_NET_DESCR_NOT_IN_USE;\r\nhwdescr->next_descr_addr = 0;\r\ndescr->hwdescr = hwdescr;\r\ndescr->bus_addr = buf;\r\ndescr->next = descr + 1;\r\ndescr->prev = descr - 1;\r\nbuf += sizeof(struct spider_net_hw_descr);\r\n}\r\n(descr-1)->next = chain->ring;\r\nchain->ring->prev = descr-1;\r\nspin_lock_init(&chain->lock);\r\nchain->head = chain->ring;\r\nchain->tail = chain->ring;\r\nreturn 0;\r\n}\r\nstatic void\r\nspider_net_free_rx_chain_contents(struct spider_net_card *card)\r\n{\r\nstruct spider_net_descr *descr;\r\ndescr = card->rx_chain.head;\r\ndo {\r\nif (descr->skb) {\r\npci_unmap_single(card->pdev, descr->hwdescr->buf_addr,\r\nSPIDER_NET_MAX_FRAME,\r\nPCI_DMA_BIDIRECTIONAL);\r\ndev_kfree_skb(descr->skb);\r\ndescr->skb = NULL;\r\n}\r\ndescr = descr->next;\r\n} while (descr != card->rx_chain.head);\r\n}\r\nstatic int\r\nspider_net_prepare_rx_descr(struct spider_net_card *card,\r\nstruct spider_net_descr *descr)\r\n{\r\nstruct spider_net_hw_descr *hwdescr = descr->hwdescr;\r\ndma_addr_t buf;\r\nint offset;\r\nint bufsize;\r\nbufsize = (SPIDER_NET_MAX_FRAME + SPIDER_NET_RXBUF_ALIGN - 1) &\r\n(~(SPIDER_NET_RXBUF_ALIGN - 1));\r\ndescr->skb = netdev_alloc_skb(card->netdev,\r\nbufsize + SPIDER_NET_RXBUF_ALIGN - 1);\r\nif (!descr->skb) {\r\nif (netif_msg_rx_err(card) && net_ratelimit())\r\ndev_err(&card->netdev->dev,\r\n"Not enough memory to allocate rx buffer\n");\r\ncard->spider_stats.alloc_rx_skb_error++;\r\nreturn -ENOMEM;\r\n}\r\nhwdescr->buf_size = bufsize;\r\nhwdescr->result_size = 0;\r\nhwdescr->valid_size = 0;\r\nhwdescr->data_status = 0;\r\nhwdescr->data_error = 0;\r\noffset = ((unsigned long)descr->skb->data) &\r\n(SPIDER_NET_RXBUF_ALIGN - 1);\r\nif (offset)\r\nskb_reserve(descr->skb, SPIDER_NET_RXBUF_ALIGN - offset);\r\nbuf = pci_map_single(card->pdev, descr->skb->data,\r\nSPIDER_NET_MAX_FRAME, PCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(card->pdev, buf)) {\r\ndev_kfree_skb_any(descr->skb);\r\ndescr->skb = NULL;\r\nif (netif_msg_rx_err(card) && net_ratelimit())\r\ndev_err(&card->netdev->dev, "Could not iommu-map rx buffer\n");\r\ncard->spider_stats.rx_iommu_map_error++;\r\nhwdescr->dmac_cmd_status = SPIDER_NET_DESCR_NOT_IN_USE;\r\n} else {\r\nhwdescr->buf_addr = buf;\r\nwmb();\r\nhwdescr->dmac_cmd_status = SPIDER_NET_DESCR_CARDOWNED |\r\nSPIDER_NET_DMAC_NOINTR_COMPLETE;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nspider_net_enable_rxchtails(struct spider_net_card *card)\r\n{\r\nspider_net_write_reg(card, SPIDER_NET_GDADCHA ,\r\ncard->rx_chain.tail->bus_addr);\r\n}\r\nstatic inline void\r\nspider_net_enable_rxdmac(struct spider_net_card *card)\r\n{\r\nwmb();\r\nspider_net_write_reg(card, SPIDER_NET_GDADMACCNTR,\r\nSPIDER_NET_DMA_RX_VALUE);\r\n}\r\nstatic inline void\r\nspider_net_disable_rxdmac(struct spider_net_card *card)\r\n{\r\nspider_net_write_reg(card, SPIDER_NET_GDADMACCNTR,\r\nSPIDER_NET_DMA_RX_FEND_VALUE);\r\n}\r\nstatic void\r\nspider_net_refill_rx_chain(struct spider_net_card *card)\r\n{\r\nstruct spider_net_descr_chain *chain = &card->rx_chain;\r\nunsigned long flags;\r\nif (!spin_trylock_irqsave(&chain->lock, flags))\r\nreturn;\r\nwhile (spider_net_get_descr_status(chain->head->hwdescr) ==\r\nSPIDER_NET_DESCR_NOT_IN_USE) {\r\nif (spider_net_prepare_rx_descr(card, chain->head))\r\nbreak;\r\nchain->head = chain->head->next;\r\n}\r\nspin_unlock_irqrestore(&chain->lock, flags);\r\n}\r\nstatic int\r\nspider_net_alloc_rx_skbs(struct spider_net_card *card)\r\n{\r\nstruct spider_net_descr_chain *chain = &card->rx_chain;\r\nstruct spider_net_descr *start = chain->tail;\r\nstruct spider_net_descr *descr = start;\r\ndo {\r\ndescr->prev->hwdescr->next_descr_addr = descr->bus_addr;\r\ndescr = descr->next;\r\n} while (descr != start);\r\nif (spider_net_prepare_rx_descr(card, chain->head))\r\ngoto error;\r\nelse\r\nchain->head = chain->head->next;\r\nspider_net_refill_rx_chain(card);\r\nspider_net_enable_rxdmac(card);\r\nreturn 0;\r\nerror:\r\nspider_net_free_rx_chain_contents(card);\r\nreturn -ENOMEM;\r\n}\r\nstatic u8\r\nspider_net_get_multicast_hash(struct net_device *netdev, __u8 *addr)\r\n{\r\nu32 crc;\r\nu8 hash;\r\nchar addr_for_crc[ETH_ALEN] = { 0, };\r\nint i, bit;\r\nfor (i = 0; i < ETH_ALEN * 8; i++) {\r\nbit = (addr[i / 8] >> (i % 8)) & 1;\r\naddr_for_crc[ETH_ALEN - 1 - i / 8] += bit << (7 - (i % 8));\r\n}\r\ncrc = crc32_be(~0, addr_for_crc, netdev->addr_len);\r\nhash = (crc >> 27);\r\nhash <<= 3;\r\nhash |= crc & 7;\r\nhash &= 0xff;\r\nreturn hash;\r\n}\r\nstatic void\r\nspider_net_set_multi(struct net_device *netdev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nu8 hash;\r\nint i;\r\nu32 reg;\r\nstruct spider_net_card *card = netdev_priv(netdev);\r\nunsigned long bitmask[SPIDER_NET_MULTICAST_HASHES / BITS_PER_LONG] =\r\n{0, };\r\nspider_net_set_promisc(card);\r\nif (netdev->flags & IFF_ALLMULTI) {\r\nfor (i = 0; i < SPIDER_NET_MULTICAST_HASHES; i++) {\r\nset_bit(i, bitmask);\r\n}\r\ngoto write_hash;\r\n}\r\nset_bit(0xfd, bitmask);\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nhash = spider_net_get_multicast_hash(netdev, ha->addr);\r\nset_bit(hash, bitmask);\r\n}\r\nwrite_hash:\r\nfor (i = 0; i < SPIDER_NET_MULTICAST_HASHES / 4; i++) {\r\nreg = 0;\r\nif (test_bit(i * 4, bitmask))\r\nreg += 0x08;\r\nreg <<= 8;\r\nif (test_bit(i * 4 + 1, bitmask))\r\nreg += 0x08;\r\nreg <<= 8;\r\nif (test_bit(i * 4 + 2, bitmask))\r\nreg += 0x08;\r\nreg <<= 8;\r\nif (test_bit(i * 4 + 3, bitmask))\r\nreg += 0x08;\r\nspider_net_write_reg(card, SPIDER_NET_GMRMHFILnR + i * 4, reg);\r\n}\r\n}\r\nstatic int\r\nspider_net_prepare_tx_descr(struct spider_net_card *card,\r\nstruct sk_buff *skb)\r\n{\r\nstruct spider_net_descr_chain *chain = &card->tx_chain;\r\nstruct spider_net_descr *descr;\r\nstruct spider_net_hw_descr *hwdescr;\r\ndma_addr_t buf;\r\nunsigned long flags;\r\nbuf = pci_map_single(card->pdev, skb->data, skb->len, PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(card->pdev, buf)) {\r\nif (netif_msg_tx_err(card) && net_ratelimit())\r\ndev_err(&card->netdev->dev, "could not iommu-map packet (%p, %i). "\r\n"Dropping packet\n", skb->data, skb->len);\r\ncard->spider_stats.tx_iommu_map_error++;\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&chain->lock, flags);\r\ndescr = card->tx_chain.head;\r\nif (descr->next == chain->tail->prev) {\r\nspin_unlock_irqrestore(&chain->lock, flags);\r\npci_unmap_single(card->pdev, buf, skb->len, PCI_DMA_TODEVICE);\r\nreturn -ENOMEM;\r\n}\r\nhwdescr = descr->hwdescr;\r\nchain->head = descr->next;\r\ndescr->skb = skb;\r\nhwdescr->buf_addr = buf;\r\nhwdescr->buf_size = skb->len;\r\nhwdescr->next_descr_addr = 0;\r\nhwdescr->data_status = 0;\r\nhwdescr->dmac_cmd_status =\r\nSPIDER_NET_DESCR_CARDOWNED | SPIDER_NET_DMAC_TXFRMTL;\r\nspin_unlock_irqrestore(&chain->lock, flags);\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nswitch (ip_hdr(skb)->protocol) {\r\ncase IPPROTO_TCP:\r\nhwdescr->dmac_cmd_status |= SPIDER_NET_DMAC_TCP;\r\nbreak;\r\ncase IPPROTO_UDP:\r\nhwdescr->dmac_cmd_status |= SPIDER_NET_DMAC_UDP;\r\nbreak;\r\n}\r\nwmb();\r\ndescr->prev->hwdescr->next_descr_addr = descr->bus_addr;\r\ncard->netdev->trans_start = jiffies;\r\nreturn 0;\r\n}\r\nstatic int\r\nspider_net_set_low_watermark(struct spider_net_card *card)\r\n{\r\nstruct spider_net_descr *descr = card->tx_chain.tail;\r\nstruct spider_net_hw_descr *hwdescr;\r\nunsigned long flags;\r\nint status;\r\nint cnt=0;\r\nint i;\r\nwhile (descr != card->tx_chain.head) {\r\nstatus = descr->hwdescr->dmac_cmd_status & SPIDER_NET_DESCR_NOT_IN_USE;\r\nif (status == SPIDER_NET_DESCR_NOT_IN_USE)\r\nbreak;\r\ndescr = descr->next;\r\ncnt++;\r\n}\r\nif (cnt < card->tx_chain.num_desc/4)\r\nreturn cnt;\r\ndescr = card->tx_chain.tail;\r\ncnt = (cnt*3)/4;\r\nfor (i=0;i<cnt; i++)\r\ndescr = descr->next;\r\nspin_lock_irqsave(&card->tx_chain.lock, flags);\r\ndescr->hwdescr->dmac_cmd_status |= SPIDER_NET_DESCR_TXDESFLG;\r\nif (card->low_watermark && card->low_watermark != descr) {\r\nhwdescr = card->low_watermark->hwdescr;\r\nhwdescr->dmac_cmd_status =\r\nhwdescr->dmac_cmd_status & ~SPIDER_NET_DESCR_TXDESFLG;\r\n}\r\ncard->low_watermark = descr;\r\nspin_unlock_irqrestore(&card->tx_chain.lock, flags);\r\nreturn cnt;\r\n}\r\nstatic int\r\nspider_net_release_tx_chain(struct spider_net_card *card, int brutal)\r\n{\r\nstruct net_device *dev = card->netdev;\r\nstruct spider_net_descr_chain *chain = &card->tx_chain;\r\nstruct spider_net_descr *descr;\r\nstruct spider_net_hw_descr *hwdescr;\r\nstruct sk_buff *skb;\r\nu32 buf_addr;\r\nunsigned long flags;\r\nint status;\r\nwhile (1) {\r\nspin_lock_irqsave(&chain->lock, flags);\r\nif (chain->tail == chain->head) {\r\nspin_unlock_irqrestore(&chain->lock, flags);\r\nreturn 0;\r\n}\r\ndescr = chain->tail;\r\nhwdescr = descr->hwdescr;\r\nstatus = spider_net_get_descr_status(hwdescr);\r\nswitch (status) {\r\ncase SPIDER_NET_DESCR_COMPLETE:\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += descr->skb->len;\r\nbreak;\r\ncase SPIDER_NET_DESCR_CARDOWNED:\r\nif (!brutal) {\r\nspin_unlock_irqrestore(&chain->lock, flags);\r\nreturn 1;\r\n}\r\ncase SPIDER_NET_DESCR_RESPONSE_ERROR:\r\ncase SPIDER_NET_DESCR_PROTECTION_ERROR:\r\ncase SPIDER_NET_DESCR_FORCE_END:\r\nif (netif_msg_tx_err(card))\r\ndev_err(&card->netdev->dev, "forcing end of tx descriptor "\r\n"with status x%02x\n", status);\r\ndev->stats.tx_errors++;\r\nbreak;\r\ndefault:\r\ndev->stats.tx_dropped++;\r\nif (!brutal) {\r\nspin_unlock_irqrestore(&chain->lock, flags);\r\nreturn 1;\r\n}\r\n}\r\nchain->tail = descr->next;\r\nhwdescr->dmac_cmd_status |= SPIDER_NET_DESCR_NOT_IN_USE;\r\nskb = descr->skb;\r\ndescr->skb = NULL;\r\nbuf_addr = hwdescr->buf_addr;\r\nspin_unlock_irqrestore(&chain->lock, flags);\r\nif (skb) {\r\npci_unmap_single(card->pdev, buf_addr, skb->len,\r\nPCI_DMA_TODEVICE);\r\ndev_consume_skb_any(skb);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nspider_net_kick_tx_dma(struct spider_net_card *card)\r\n{\r\nstruct spider_net_descr *descr;\r\nif (spider_net_read_reg(card, SPIDER_NET_GDTDMACCNTR) &\r\nSPIDER_NET_TX_DMA_EN)\r\ngoto out;\r\ndescr = card->tx_chain.tail;\r\nfor (;;) {\r\nif (spider_net_get_descr_status(descr->hwdescr) ==\r\nSPIDER_NET_DESCR_CARDOWNED) {\r\nspider_net_write_reg(card, SPIDER_NET_GDTDCHA,\r\ndescr->bus_addr);\r\nspider_net_write_reg(card, SPIDER_NET_GDTDMACCNTR,\r\nSPIDER_NET_DMA_TX_VALUE);\r\nbreak;\r\n}\r\nif (descr == card->tx_chain.head)\r\nbreak;\r\ndescr = descr->next;\r\n}\r\nout:\r\nmod_timer(&card->tx_timer, jiffies + SPIDER_NET_TX_TIMER);\r\n}\r\nstatic int\r\nspider_net_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nint cnt;\r\nstruct spider_net_card *card = netdev_priv(netdev);\r\nspider_net_release_tx_chain(card, 0);\r\nif (spider_net_prepare_tx_descr(card, skb) != 0) {\r\nnetdev->stats.tx_dropped++;\r\nnetif_stop_queue(netdev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ncnt = spider_net_set_low_watermark(card);\r\nif (cnt < 5)\r\nspider_net_kick_tx_dma(card);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\nspider_net_cleanup_tx_ring(struct spider_net_card *card)\r\n{\r\nif ((spider_net_release_tx_chain(card, 0) != 0) &&\r\n(card->netdev->flags & IFF_UP)) {\r\nspider_net_kick_tx_dma(card);\r\nnetif_wake_queue(card->netdev);\r\n}\r\n}\r\nstatic int\r\nspider_net_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nswitch (cmd) {\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void\r\nspider_net_pass_skb_up(struct spider_net_descr *descr,\r\nstruct spider_net_card *card)\r\n{\r\nstruct spider_net_hw_descr *hwdescr = descr->hwdescr;\r\nstruct sk_buff *skb = descr->skb;\r\nstruct net_device *netdev = card->netdev;\r\nu32 data_status = hwdescr->data_status;\r\nu32 data_error = hwdescr->data_error;\r\nskb_put(skb, hwdescr->valid_size);\r\n#define SPIDER_MISALIGN 2\r\nskb_pull(skb, SPIDER_MISALIGN);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nskb_checksum_none_assert(skb);\r\nif (netdev->features & NETIF_F_RXCSUM) {\r\nif ( ( (data_status & SPIDER_NET_DATA_STATUS_CKSUM_MASK) ==\r\nSPIDER_NET_DATA_STATUS_CKSUM_MASK) &&\r\n!(data_error & SPIDER_NET_DATA_ERR_CKSUM_MASK))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nif (data_status & SPIDER_NET_VLAN_PACKET) {\r\n}\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += skb->len;\r\nnetif_receive_skb(skb);\r\n}\r\nstatic void show_rx_chain(struct spider_net_card *card)\r\n{\r\nstruct spider_net_descr_chain *chain = &card->rx_chain;\r\nstruct spider_net_descr *start= chain->tail;\r\nstruct spider_net_descr *descr= start;\r\nstruct spider_net_hw_descr *hwd = start->hwdescr;\r\nstruct device *dev = &card->netdev->dev;\r\nu32 curr_desc, next_desc;\r\nint status;\r\nint tot = 0;\r\nint cnt = 0;\r\nint off = start - chain->ring;\r\nint cstat = hwd->dmac_cmd_status;\r\ndev_info(dev, "Total number of descrs=%d\n",\r\nchain->num_desc);\r\ndev_info(dev, "Chain tail located at descr=%d, status=0x%x\n",\r\noff, cstat);\r\ncurr_desc = spider_net_read_reg(card, SPIDER_NET_GDACTDPA);\r\nnext_desc = spider_net_read_reg(card, SPIDER_NET_GDACNEXTDA);\r\nstatus = cstat;\r\ndo\r\n{\r\nhwd = descr->hwdescr;\r\noff = descr - chain->ring;\r\nstatus = hwd->dmac_cmd_status;\r\nif (descr == chain->head)\r\ndev_info(dev, "Chain head is at %d, head status=0x%x\n",\r\noff, status);\r\nif (curr_desc == descr->bus_addr)\r\ndev_info(dev, "HW curr desc (GDACTDPA) is at %d, status=0x%x\n",\r\noff, status);\r\nif (next_desc == descr->bus_addr)\r\ndev_info(dev, "HW next desc (GDACNEXTDA) is at %d, status=0x%x\n",\r\noff, status);\r\nif (hwd->next_descr_addr == 0)\r\ndev_info(dev, "chain is cut at %d\n", off);\r\nif (cstat != status) {\r\nint from = (chain->num_desc + off - cnt) % chain->num_desc;\r\nint to = (chain->num_desc + off - 1) % chain->num_desc;\r\ndev_info(dev, "Have %d (from %d to %d) descrs "\r\n"with stat=0x%08x\n", cnt, from, to, cstat);\r\ncstat = status;\r\ncnt = 0;\r\n}\r\ncnt ++;\r\ntot ++;\r\ndescr = descr->next;\r\n} while (descr != start);\r\ndev_info(dev, "Last %d descrs with stat=0x%08x "\r\n"for a total of %d descrs\n", cnt, cstat, tot);\r\n#ifdef DEBUG\r\ndescr = start;\r\ndo\r\n{\r\nstruct spider_net_hw_descr *hwd = descr->hwdescr;\r\nstatus = spider_net_get_descr_status(hwd);\r\ncnt = descr - chain->ring;\r\ndev_info(dev, "Descr %d stat=0x%08x skb=%p\n",\r\ncnt, status, descr->skb);\r\ndev_info(dev, "bus addr=%08x buf addr=%08x sz=%d\n",\r\ndescr->bus_addr, hwd->buf_addr, hwd->buf_size);\r\ndev_info(dev, "next=%08x result sz=%d valid sz=%d\n",\r\nhwd->next_descr_addr, hwd->result_size,\r\nhwd->valid_size);\r\ndev_info(dev, "dmac=%08x data stat=%08x data err=%08x\n",\r\nhwd->dmac_cmd_status, hwd->data_status,\r\nhwd->data_error);\r\ndev_info(dev, "\n");\r\ndescr = descr->next;\r\n} while (descr != start);\r\n#endif\r\n}\r\nstatic void spider_net_resync_head_ptr(struct spider_net_card *card)\r\n{\r\nunsigned long flags;\r\nstruct spider_net_descr_chain *chain = &card->rx_chain;\r\nstruct spider_net_descr *descr;\r\nint i, status;\r\ndescr = chain->head;\r\nstatus = spider_net_get_descr_status(descr->hwdescr);\r\nif (status == SPIDER_NET_DESCR_NOT_IN_USE)\r\nreturn;\r\nspin_lock_irqsave(&chain->lock, flags);\r\ndescr = chain->head;\r\nstatus = spider_net_get_descr_status(descr->hwdescr);\r\nfor (i=0; i<chain->num_desc; i++) {\r\nif (status != SPIDER_NET_DESCR_CARDOWNED) break;\r\ndescr = descr->next;\r\nstatus = spider_net_get_descr_status(descr->hwdescr);\r\n}\r\nchain->head = descr;\r\nspin_unlock_irqrestore(&chain->lock, flags);\r\n}\r\nstatic int spider_net_resync_tail_ptr(struct spider_net_card *card)\r\n{\r\nstruct spider_net_descr_chain *chain = &card->rx_chain;\r\nstruct spider_net_descr *descr;\r\nint i, status;\r\ndescr = chain->tail;\r\nstatus = spider_net_get_descr_status(descr->hwdescr);\r\nfor (i=0; i<chain->num_desc; i++) {\r\nif ((status != SPIDER_NET_DESCR_CARDOWNED) &&\r\n(status != SPIDER_NET_DESCR_NOT_IN_USE)) break;\r\ndescr = descr->next;\r\nstatus = spider_net_get_descr_status(descr->hwdescr);\r\n}\r\nchain->tail = descr;\r\nif ((i == chain->num_desc) || (i == 0))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nspider_net_decode_one_descr(struct spider_net_card *card)\r\n{\r\nstruct net_device *dev = card->netdev;\r\nstruct spider_net_descr_chain *chain = &card->rx_chain;\r\nstruct spider_net_descr *descr = chain->tail;\r\nstruct spider_net_hw_descr *hwdescr = descr->hwdescr;\r\nu32 hw_buf_addr;\r\nint status;\r\nstatus = spider_net_get_descr_status(hwdescr);\r\nif ((status == SPIDER_NET_DESCR_CARDOWNED) ||\r\n(status == SPIDER_NET_DESCR_NOT_IN_USE))\r\nreturn 0;\r\nchain->tail = descr->next;\r\nhw_buf_addr = hwdescr->buf_addr;\r\nhwdescr->buf_addr = 0xffffffff;\r\npci_unmap_single(card->pdev, hw_buf_addr,\r\nSPIDER_NET_MAX_FRAME, PCI_DMA_FROMDEVICE);\r\nif ( (status == SPIDER_NET_DESCR_RESPONSE_ERROR) ||\r\n(status == SPIDER_NET_DESCR_PROTECTION_ERROR) ||\r\n(status == SPIDER_NET_DESCR_FORCE_END) ) {\r\nif (netif_msg_rx_err(card))\r\ndev_err(&dev->dev,\r\n"dropping RX descriptor with state %d\n", status);\r\ndev->stats.rx_dropped++;\r\ngoto bad_desc;\r\n}\r\nif ( (status != SPIDER_NET_DESCR_COMPLETE) &&\r\n(status != SPIDER_NET_DESCR_FRAME_END) ) {\r\nif (netif_msg_rx_err(card))\r\ndev_err(&card->netdev->dev,\r\n"RX descriptor with unknown state %d\n", status);\r\ncard->spider_stats.rx_desc_unk_state++;\r\ngoto bad_desc;\r\n}\r\nif (hwdescr->data_error & SPIDER_NET_DESTROY_RX_FLAGS) {\r\nif (netif_msg_rx_err(card))\r\ndev_err(&card->netdev->dev,\r\n"error in received descriptor found, "\r\n"data_status=x%08x, data_error=x%08x\n",\r\nhwdescr->data_status, hwdescr->data_error);\r\ngoto bad_desc;\r\n}\r\nif (hwdescr->dmac_cmd_status & SPIDER_NET_DESCR_BAD_STATUS) {\r\ndev_err(&card->netdev->dev, "bad status, cmd_status=x%08x\n",\r\nhwdescr->dmac_cmd_status);\r\npr_err("buf_addr=x%08x\n", hw_buf_addr);\r\npr_err("buf_size=x%08x\n", hwdescr->buf_size);\r\npr_err("next_descr_addr=x%08x\n", hwdescr->next_descr_addr);\r\npr_err("result_size=x%08x\n", hwdescr->result_size);\r\npr_err("valid_size=x%08x\n", hwdescr->valid_size);\r\npr_err("data_status=x%08x\n", hwdescr->data_status);\r\npr_err("data_error=x%08x\n", hwdescr->data_error);\r\npr_err("which=%ld\n", descr - card->rx_chain.ring);\r\ncard->spider_stats.rx_desc_error++;\r\ngoto bad_desc;\r\n}\r\nspider_net_pass_skb_up(descr, card);\r\ndescr->skb = NULL;\r\nhwdescr->dmac_cmd_status = SPIDER_NET_DESCR_NOT_IN_USE;\r\nreturn 1;\r\nbad_desc:\r\nif (netif_msg_rx_err(card))\r\nshow_rx_chain(card);\r\ndev_kfree_skb_irq(descr->skb);\r\ndescr->skb = NULL;\r\nhwdescr->dmac_cmd_status = SPIDER_NET_DESCR_NOT_IN_USE;\r\nreturn 0;\r\n}\r\nstatic int spider_net_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct spider_net_card *card = container_of(napi, struct spider_net_card, napi);\r\nint packets_done = 0;\r\nwhile (packets_done < budget) {\r\nif (!spider_net_decode_one_descr(card))\r\nbreak;\r\npackets_done++;\r\n}\r\nif ((packets_done == 0) && (card->num_rx_ints != 0)) {\r\nif (!spider_net_resync_tail_ptr(card))\r\npackets_done = budget;\r\nspider_net_resync_head_ptr(card);\r\n}\r\ncard->num_rx_ints = 0;\r\nspider_net_refill_rx_chain(card);\r\nspider_net_enable_rxdmac(card);\r\nspider_net_cleanup_tx_ring(card);\r\nif (packets_done < budget) {\r\nnapi_complete(napi);\r\nspider_net_rx_irq_on(card);\r\ncard->ignore_rx_ramfull = 0;\r\n}\r\nreturn packets_done;\r\n}\r\nstatic int\r\nspider_net_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nif ( (new_mtu < SPIDER_NET_MIN_MTU ) ||\r\n(new_mtu > SPIDER_NET_MAX_MTU) )\r\nreturn -EINVAL;\r\nnetdev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int\r\nspider_net_set_mac(struct net_device *netdev, void *p)\r\n{\r\nstruct spider_net_card *card = netdev_priv(netdev);\r\nu32 macl, macu, regvalue;\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nregvalue = spider_net_read_reg(card, SPIDER_NET_GMACOPEMD);\r\nregvalue &= ~((1 << 5) | (1 << 6));\r\nspider_net_write_reg(card, SPIDER_NET_GMACOPEMD, regvalue);\r\nmacu = (addr->sa_data[0]<<24) + (addr->sa_data[1]<<16) +\r\n(addr->sa_data[2]<<8) + (addr->sa_data[3]);\r\nmacl = (addr->sa_data[4]<<8) + (addr->sa_data[5]);\r\nspider_net_write_reg(card, SPIDER_NET_GMACUNIMACU, macu);\r\nspider_net_write_reg(card, SPIDER_NET_GMACUNIMACL, macl);\r\nregvalue = spider_net_read_reg(card, SPIDER_NET_GMACOPEMD);\r\nregvalue |= ((1 << 5) | (1 << 6));\r\nspider_net_write_reg(card, SPIDER_NET_GMACOPEMD, regvalue);\r\nspider_net_set_promisc(card);\r\nif (spider_net_get_mac_address(netdev))\r\nreturn -EADDRNOTAVAIL;\r\nif (memcmp(netdev->dev_addr,addr->sa_data,netdev->addr_len))\r\nreturn -EADDRNOTAVAIL;\r\nreturn 0;\r\n}\r\nstatic void\r\nspider_net_link_reset(struct net_device *netdev)\r\n{\r\nstruct spider_net_card *card = netdev_priv(netdev);\r\ndel_timer_sync(&card->aneg_timer);\r\nspider_net_write_reg(card, SPIDER_NET_GMACST,\r\nspider_net_read_reg(card, SPIDER_NET_GMACST));\r\nspider_net_write_reg(card, SPIDER_NET_GMACINTEN, 0);\r\ncard->aneg_count = 0;\r\ncard->medium = BCM54XX_COPPER;\r\nspider_net_setup_aneg(card);\r\nmod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);\r\n}\r\nstatic void\r\nspider_net_handle_error_irq(struct spider_net_card *card, u32 status_reg,\r\nu32 error_reg1, u32 error_reg2)\r\n{\r\nu32 i;\r\nint show_error = 1;\r\nif (status_reg)\r\nfor (i = 0; i < 32; i++)\r\nif (status_reg & (1<<i))\r\nswitch (i)\r\n{\r\ncase SPIDER_NET_GIPSINT:\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GPWOPCMPINT:\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GPROPCMPINT:\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GPWFFINT:\r\nif (netif_msg_intr(card))\r\ndev_err(&card->netdev->dev, "PHY write queue full\n");\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GDTDEN0INT:\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GDDDEN0INT:\r\ncase SPIDER_NET_GDCDEN0INT:\r\ncase SPIDER_NET_GDBDEN0INT:\r\ncase SPIDER_NET_GDADEN0INT:\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GDDFDCINT:\r\ncase SPIDER_NET_GDCFDCINT:\r\ncase SPIDER_NET_GDBFDCINT:\r\ncase SPIDER_NET_GDAFDCINT:\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GDTFDCINT:\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GTTEDINT:\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GDTDCEINT:\r\nshow_error = 0;\r\nbreak;\r\n}\r\nif (error_reg1)\r\nfor (i = 0; i < 32; i++)\r\nif (error_reg1 & (1<<i))\r\nswitch (i)\r\n{\r\ncase SPIDER_NET_GTMFLLINT:\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GRFDFLLINT:\r\ncase SPIDER_NET_GRFCFLLINT:\r\ncase SPIDER_NET_GRFBFLLINT:\r\ncase SPIDER_NET_GRFAFLLINT:\r\ncase SPIDER_NET_GRMFLLINT:\r\nif (card->ignore_rx_ramfull == 0) {\r\ncard->ignore_rx_ramfull = 1;\r\nspider_net_resync_head_ptr(card);\r\nspider_net_refill_rx_chain(card);\r\nspider_net_enable_rxdmac(card);\r\ncard->num_rx_ints ++;\r\nnapi_schedule(&card->napi);\r\n}\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GDTINVDINT:\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GDDDCEINT:\r\ncase SPIDER_NET_GDCDCEINT:\r\ncase SPIDER_NET_GDBDCEINT:\r\ncase SPIDER_NET_GDADCEINT:\r\nspider_net_resync_head_ptr(card);\r\nspider_net_refill_rx_chain(card);\r\nspider_net_enable_rxdmac(card);\r\ncard->num_rx_ints ++;\r\nnapi_schedule(&card->napi);\r\nshow_error = 0;\r\nbreak;\r\ncase SPIDER_NET_GDDINVDINT:\r\ncase SPIDER_NET_GDCINVDINT:\r\ncase SPIDER_NET_GDBINVDINT:\r\ncase SPIDER_NET_GDAINVDINT:\r\nspider_net_resync_head_ptr(card);\r\nspider_net_refill_rx_chain(card);\r\nspider_net_enable_rxdmac(card);\r\ncard->num_rx_ints ++;\r\nnapi_schedule(&card->napi);\r\nshow_error = 0;\r\nbreak;\r\ndefault:\r\nshow_error = 1;\r\nbreak;\r\n}\r\nif (error_reg2)\r\nfor (i = 0; i < 32; i++)\r\nif (error_reg2 & (1<<i))\r\nswitch (i)\r\n{\r\ndefault:\r\nbreak;\r\n}\r\nif ((show_error) && (netif_msg_intr(card)) && net_ratelimit())\r\ndev_err(&card->netdev->dev, "Error interrupt, GHIINT0STS = 0x%08x, "\r\n"GHIINT1STS = 0x%08x, GHIINT2STS = 0x%08x\n",\r\nstatus_reg, error_reg1, error_reg2);\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT1STS, error_reg1);\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT2STS, error_reg2);\r\n}\r\nstatic irqreturn_t\r\nspider_net_interrupt(int irq, void *ptr)\r\n{\r\nstruct net_device *netdev = ptr;\r\nstruct spider_net_card *card = netdev_priv(netdev);\r\nu32 status_reg, error_reg1, error_reg2;\r\nstatus_reg = spider_net_read_reg(card, SPIDER_NET_GHIINT0STS);\r\nerror_reg1 = spider_net_read_reg(card, SPIDER_NET_GHIINT1STS);\r\nerror_reg2 = spider_net_read_reg(card, SPIDER_NET_GHIINT2STS);\r\nif (!(status_reg & SPIDER_NET_INT0_MASK_VALUE) &&\r\n!(error_reg1 & SPIDER_NET_INT1_MASK_VALUE) &&\r\n!(error_reg2 & SPIDER_NET_INT2_MASK_VALUE))\r\nreturn IRQ_NONE;\r\nif (status_reg & SPIDER_NET_RXINT ) {\r\nspider_net_rx_irq_off(card);\r\nnapi_schedule(&card->napi);\r\ncard->num_rx_ints ++;\r\n}\r\nif (status_reg & SPIDER_NET_TXINT)\r\nnapi_schedule(&card->napi);\r\nif (status_reg & SPIDER_NET_LINKINT)\r\nspider_net_link_reset(netdev);\r\nif (status_reg & SPIDER_NET_ERRINT )\r\nspider_net_handle_error_irq(card, status_reg,\r\nerror_reg1, error_reg2);\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT0STS, status_reg);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nspider_net_poll_controller(struct net_device *netdev)\r\n{\r\ndisable_irq(netdev->irq);\r\nspider_net_interrupt(netdev->irq, netdev);\r\nenable_irq(netdev->irq);\r\n}\r\nstatic void\r\nspider_net_enable_interrupts(struct spider_net_card *card)\r\n{\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT0MSK,\r\nSPIDER_NET_INT0_MASK_VALUE);\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT1MSK,\r\nSPIDER_NET_INT1_MASK_VALUE);\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT2MSK,\r\nSPIDER_NET_INT2_MASK_VALUE);\r\n}\r\nstatic void\r\nspider_net_disable_interrupts(struct spider_net_card *card)\r\n{\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT0MSK, 0);\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT1MSK, 0);\r\nspider_net_write_reg(card, SPIDER_NET_GHIINT2MSK, 0);\r\nspider_net_write_reg(card, SPIDER_NET_GMACINTEN, 0);\r\n}\r\nstatic void\r\nspider_net_init_card(struct spider_net_card *card)\r\n{\r\nspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\r\nSPIDER_NET_CKRCTRL_STOP_VALUE);\r\nspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\r\nSPIDER_NET_CKRCTRL_RUN_VALUE);\r\nspider_net_write_reg(card, SPIDER_NET_GMACOPEMD,\r\nspider_net_read_reg(card, SPIDER_NET_GMACOPEMD) | 0x4);\r\nspider_net_disable_interrupts(card);\r\n}\r\nstatic void\r\nspider_net_enable_card(struct spider_net_card *card)\r\n{\r\nint i;\r\nu32 regs[][2] = {\r\n{ SPIDER_NET_GRESUMINTNUM, 0 },\r\n{ SPIDER_NET_GREINTNUM, 0 },\r\n{ SPIDER_NET_GFAFRMNUM, SPIDER_NET_GFXFRAMES_VALUE },\r\n{ SPIDER_NET_GFBFRMNUM, SPIDER_NET_GFXFRAMES_VALUE },\r\n{ SPIDER_NET_GFCFRMNUM, SPIDER_NET_GFXFRAMES_VALUE },\r\n{ SPIDER_NET_GFDFRMNUM, SPIDER_NET_GFXFRAMES_VALUE },\r\n{ SPIDER_NET_GFFRMNUM, SPIDER_NET_FRAMENUM_VALUE },\r\n{ SPIDER_NET_GFREECNNUM, 0 },\r\n{ SPIDER_NET_GONETIMENUM, 0 },\r\n{ SPIDER_NET_GTOUTFRMNUM, 0 },\r\n{ SPIDER_NET_GRXMDSET, SPIDER_NET_RXMODE_VALUE },\r\n{ SPIDER_NET_GTXMDSET, SPIDER_NET_TXMODE_VALUE },\r\n{ SPIDER_NET_GIPSECINIT, SPIDER_NET_IPSECINIT_VALUE },\r\n{ SPIDER_NET_GFTRESTRT, SPIDER_NET_RESTART_VALUE },\r\n{ SPIDER_NET_GMRWOLCTRL, 0 },\r\n{ SPIDER_NET_GTESTMD, 0x10000000 },\r\n{ SPIDER_NET_GTTQMSK, 0x00400040 },\r\n{ SPIDER_NET_GMACINTEN, 0 },\r\n{ SPIDER_NET_GMACAPAUSE, SPIDER_NET_MACAPAUSE_VALUE },\r\n{ SPIDER_NET_GMACTXPAUSE, SPIDER_NET_TXPAUSE_VALUE },\r\n{ SPIDER_NET_GMACBSTLMT, SPIDER_NET_BURSTLMT_VALUE },\r\n{ 0, 0}\r\n};\r\ni = 0;\r\nwhile (regs[i][0]) {\r\nspider_net_write_reg(card, regs[i][0], regs[i][1]);\r\ni++;\r\n}\r\nfor (i = 1; i <= 14; i++) {\r\nspider_net_write_reg(card,\r\nSPIDER_NET_GMRUAFILnR + i * 8,\r\n0x00080000);\r\nspider_net_write_reg(card,\r\nSPIDER_NET_GMRUAFILnR + i * 8 + 4,\r\n0x00000000);\r\n}\r\nspider_net_write_reg(card, SPIDER_NET_GMRUA0FIL15R, 0x08080000);\r\nspider_net_write_reg(card, SPIDER_NET_ECMODE, SPIDER_NET_ECMODE_VALUE);\r\nspider_net_enable_rxchtails(card);\r\nspider_net_enable_rxdmac(card);\r\nspider_net_write_reg(card, SPIDER_NET_GRXDMAEN, SPIDER_NET_WOL_VALUE);\r\nspider_net_write_reg(card, SPIDER_NET_GMACLENLMT,\r\nSPIDER_NET_LENLMT_VALUE);\r\nspider_net_write_reg(card, SPIDER_NET_GMACOPEMD,\r\nSPIDER_NET_OPMODE_VALUE);\r\nspider_net_write_reg(card, SPIDER_NET_GDTDMACCNTR,\r\nSPIDER_NET_GDTBSTA);\r\n}\r\nstatic int\r\nspider_net_download_firmware(struct spider_net_card *card,\r\nconst void *firmware_ptr)\r\n{\r\nint sequencer, i;\r\nconst u32 *fw_ptr = firmware_ptr;\r\nspider_net_write_reg(card, SPIDER_NET_GSINIT,\r\nSPIDER_NET_STOP_SEQ_VALUE);\r\nfor (sequencer = 0; sequencer < SPIDER_NET_FIRMWARE_SEQS;\r\nsequencer++) {\r\nspider_net_write_reg(card,\r\nSPIDER_NET_GSnPRGADR + sequencer * 8, 0);\r\nfor (i = 0; i < SPIDER_NET_FIRMWARE_SEQWORDS; i++) {\r\nspider_net_write_reg(card, SPIDER_NET_GSnPRGDAT +\r\nsequencer * 8, *fw_ptr);\r\nfw_ptr++;\r\n}\r\n}\r\nif (spider_net_read_reg(card, SPIDER_NET_GSINIT))\r\nreturn -EIO;\r\nspider_net_write_reg(card, SPIDER_NET_GSINIT,\r\nSPIDER_NET_RUN_SEQ_VALUE);\r\nreturn 0;\r\n}\r\nstatic int\r\nspider_net_init_firmware(struct spider_net_card *card)\r\n{\r\nstruct firmware *firmware = NULL;\r\nstruct device_node *dn;\r\nconst u8 *fw_prop = NULL;\r\nint err = -ENOENT;\r\nint fw_size;\r\nif (request_firmware((const struct firmware **)&firmware,\r\nSPIDER_NET_FIRMWARE_NAME, &card->pdev->dev) == 0) {\r\nif ( (firmware->size != SPIDER_NET_FIRMWARE_LEN) &&\r\nnetif_msg_probe(card) ) {\r\ndev_err(&card->netdev->dev,\r\n"Incorrect size of spidernet firmware in " \\r\n"filesystem. Looking in host firmware...\n");\r\ngoto try_host_fw;\r\n}\r\nerr = spider_net_download_firmware(card, firmware->data);\r\nrelease_firmware(firmware);\r\nif (err)\r\ngoto try_host_fw;\r\ngoto done;\r\n}\r\ntry_host_fw:\r\ndn = pci_device_to_OF_node(card->pdev);\r\nif (!dn)\r\ngoto out_err;\r\nfw_prop = of_get_property(dn, "firmware", &fw_size);\r\nif (!fw_prop)\r\ngoto out_err;\r\nif ( (fw_size != SPIDER_NET_FIRMWARE_LEN) &&\r\nnetif_msg_probe(card) ) {\r\ndev_err(&card->netdev->dev,\r\n"Incorrect size of spidernet firmware in host firmware\n");\r\ngoto done;\r\n}\r\nerr = spider_net_download_firmware(card, fw_prop);\r\ndone:\r\nreturn err;\r\nout_err:\r\nif (netif_msg_probe(card))\r\ndev_err(&card->netdev->dev,\r\n"Couldn't find spidernet firmware in filesystem " \\r\n"or host firmware\n");\r\nreturn err;\r\n}\r\nint\r\nspider_net_open(struct net_device *netdev)\r\n{\r\nstruct spider_net_card *card = netdev_priv(netdev);\r\nint result;\r\nresult = spider_net_init_firmware(card);\r\nif (result)\r\ngoto init_firmware_failed;\r\ncard->aneg_count = 0;\r\ncard->medium = BCM54XX_COPPER;\r\nspider_net_setup_aneg(card);\r\nif (card->phy.def->phy_id)\r\nmod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);\r\nresult = spider_net_init_chain(card, &card->tx_chain);\r\nif (result)\r\ngoto alloc_tx_failed;\r\ncard->low_watermark = NULL;\r\nresult = spider_net_init_chain(card, &card->rx_chain);\r\nif (result)\r\ngoto alloc_rx_failed;\r\nresult = spider_net_alloc_rx_skbs(card);\r\nif (result)\r\ngoto alloc_skbs_failed;\r\nspider_net_set_multi(netdev);\r\nresult = -EBUSY;\r\nif (request_irq(netdev->irq, spider_net_interrupt,\r\nIRQF_SHARED, netdev->name, netdev))\r\ngoto register_int_failed;\r\nspider_net_enable_card(card);\r\nnetif_start_queue(netdev);\r\nnetif_carrier_on(netdev);\r\nnapi_enable(&card->napi);\r\nspider_net_enable_interrupts(card);\r\nreturn 0;\r\nregister_int_failed:\r\nspider_net_free_rx_chain_contents(card);\r\nalloc_skbs_failed:\r\nspider_net_free_chain(card, &card->rx_chain);\r\nalloc_rx_failed:\r\nspider_net_free_chain(card, &card->tx_chain);\r\nalloc_tx_failed:\r\ndel_timer_sync(&card->aneg_timer);\r\ninit_firmware_failed:\r\nreturn result;\r\n}\r\nstatic void spider_net_link_phy(unsigned long data)\r\n{\r\nstruct spider_net_card *card = (struct spider_net_card *)data;\r\nstruct mii_phy *phy = &card->phy;\r\nif (card->aneg_count > SPIDER_NET_ANEG_TIMEOUT) {\r\npr_debug("%s: link is down trying to bring it up\n",\r\ncard->netdev->name);\r\nswitch (card->medium) {\r\ncase BCM54XX_COPPER:\r\nif (phy->def->ops->enable_fiber)\r\nphy->def->ops->enable_fiber(phy, 1);\r\ncard->medium = BCM54XX_FIBER;\r\nbreak;\r\ncase BCM54XX_FIBER:\r\nif (phy->def->ops->enable_fiber)\r\nphy->def->ops->enable_fiber(phy, 0);\r\ncard->medium = BCM54XX_UNKNOWN;\r\nbreak;\r\ncase BCM54XX_UNKNOWN:\r\nspider_net_setup_aneg(card);\r\ncard->medium = BCM54XX_COPPER;\r\nbreak;\r\n}\r\ncard->aneg_count = 0;\r\nmod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);\r\nreturn;\r\n}\r\nif (!(phy->def->ops->poll_link(phy))) {\r\ncard->aneg_count++;\r\nmod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);\r\nreturn;\r\n}\r\nphy->def->ops->read_link(phy);\r\nspider_net_write_reg(card, SPIDER_NET_GMACST,\r\nspider_net_read_reg(card, SPIDER_NET_GMACST));\r\nspider_net_write_reg(card, SPIDER_NET_GMACINTEN, 0x4);\r\nif (phy->speed == 1000)\r\nspider_net_write_reg(card, SPIDER_NET_GMACMODE, 0x00000001);\r\nelse\r\nspider_net_write_reg(card, SPIDER_NET_GMACMODE, 0);\r\ncard->aneg_count = 0;\r\npr_info("%s: link up, %i Mbps, %s-duplex %sautoneg.\n",\r\ncard->netdev->name, phy->speed,\r\nphy->duplex == 1 ? "Full" : "Half",\r\nphy->autoneg == 1 ? "" : "no ");\r\n}\r\nstatic int\r\nspider_net_setup_phy(struct spider_net_card *card)\r\n{\r\nstruct mii_phy *phy = &card->phy;\r\nspider_net_write_reg(card, SPIDER_NET_GDTDMASEL,\r\nSPIDER_NET_DMASEL_VALUE);\r\nspider_net_write_reg(card, SPIDER_NET_GPCCTRL,\r\nSPIDER_NET_PHY_CTRL_VALUE);\r\nphy->dev = card->netdev;\r\nphy->mdio_read = spider_net_read_phy;\r\nphy->mdio_write = spider_net_write_phy;\r\nfor (phy->mii_id = 1; phy->mii_id <= 31; phy->mii_id++) {\r\nunsigned short id;\r\nid = spider_net_read_phy(card->netdev, phy->mii_id, MII_BMSR);\r\nif (id != 0x0000 && id != 0xffff) {\r\nif (!sungem_phy_probe(phy, phy->mii_id)) {\r\npr_info("Found %s.\n", phy->def->name);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nspider_net_workaround_rxramfull(struct spider_net_card *card)\r\n{\r\nint i, sequencer = 0;\r\nspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\r\nSPIDER_NET_CKRCTRL_RUN_VALUE);\r\nfor (sequencer = 0; sequencer < SPIDER_NET_FIRMWARE_SEQS;\r\nsequencer++) {\r\nspider_net_write_reg(card, SPIDER_NET_GSnPRGADR +\r\nsequencer * 8, 0x0);\r\nfor (i = 0; i < SPIDER_NET_FIRMWARE_SEQWORDS; i++) {\r\nspider_net_write_reg(card, SPIDER_NET_GSnPRGDAT +\r\nsequencer * 8, 0x0);\r\n}\r\n}\r\nspider_net_write_reg(card, SPIDER_NET_GSINIT, 0x000000fe);\r\nspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\r\nSPIDER_NET_CKRCTRL_STOP_VALUE);\r\n}\r\nint\r\nspider_net_stop(struct net_device *netdev)\r\n{\r\nstruct spider_net_card *card = netdev_priv(netdev);\r\nnapi_disable(&card->napi);\r\nnetif_carrier_off(netdev);\r\nnetif_stop_queue(netdev);\r\ndel_timer_sync(&card->tx_timer);\r\ndel_timer_sync(&card->aneg_timer);\r\nspider_net_disable_interrupts(card);\r\nfree_irq(netdev->irq, netdev);\r\nspider_net_write_reg(card, SPIDER_NET_GDTDMACCNTR,\r\nSPIDER_NET_DMA_TX_FEND_VALUE);\r\nspider_net_disable_rxdmac(card);\r\nspider_net_release_tx_chain(card, 1);\r\nspider_net_free_rx_chain_contents(card);\r\nspider_net_free_chain(card, &card->tx_chain);\r\nspider_net_free_chain(card, &card->rx_chain);\r\nreturn 0;\r\n}\r\nstatic void\r\nspider_net_tx_timeout_task(struct work_struct *work)\r\n{\r\nstruct spider_net_card *card =\r\ncontainer_of(work, struct spider_net_card, tx_timeout_task);\r\nstruct net_device *netdev = card->netdev;\r\nif (!(netdev->flags & IFF_UP))\r\ngoto out;\r\nnetif_device_detach(netdev);\r\nspider_net_stop(netdev);\r\nspider_net_workaround_rxramfull(card);\r\nspider_net_init_card(card);\r\nif (spider_net_setup_phy(card))\r\ngoto out;\r\nspider_net_open(netdev);\r\nspider_net_kick_tx_dma(card);\r\nnetif_device_attach(netdev);\r\nout:\r\natomic_dec(&card->tx_timeout_task_counter);\r\n}\r\nstatic void\r\nspider_net_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct spider_net_card *card;\r\ncard = netdev_priv(netdev);\r\natomic_inc(&card->tx_timeout_task_counter);\r\nif (netdev->flags & IFF_UP)\r\nschedule_work(&card->tx_timeout_task);\r\nelse\r\natomic_dec(&card->tx_timeout_task_counter);\r\ncard->spider_stats.tx_timeouts++;\r\n}\r\nstatic void\r\nspider_net_setup_netdev_ops(struct net_device *netdev)\r\n{\r\nnetdev->netdev_ops = &spider_net_ops;\r\nnetdev->watchdog_timeo = SPIDER_NET_WATCHDOG_TIMEOUT;\r\nnetdev->ethtool_ops = &spider_net_ethtool_ops;\r\n}\r\nstatic int\r\nspider_net_setup_netdev(struct spider_net_card *card)\r\n{\r\nint result;\r\nstruct net_device *netdev = card->netdev;\r\nstruct device_node *dn;\r\nstruct sockaddr addr;\r\nconst u8 *mac;\r\nSET_NETDEV_DEV(netdev, &card->pdev->dev);\r\npci_set_drvdata(card->pdev, netdev);\r\ninit_timer(&card->tx_timer);\r\ncard->tx_timer.function =\r\n(void (*)(unsigned long)) spider_net_cleanup_tx_ring;\r\ncard->tx_timer.data = (unsigned long) card;\r\nnetdev->irq = card->pdev->irq;\r\ncard->aneg_count = 0;\r\ninit_timer(&card->aneg_timer);\r\ncard->aneg_timer.function = spider_net_link_phy;\r\ncard->aneg_timer.data = (unsigned long) card;\r\nnetif_napi_add(netdev, &card->napi,\r\nspider_net_poll, SPIDER_NET_NAPI_WEIGHT);\r\nspider_net_setup_netdev_ops(netdev);\r\nnetdev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM;\r\nif (SPIDER_NET_RX_CSUM_DEFAULT)\r\nnetdev->features |= NETIF_F_RXCSUM;\r\nnetdev->features |= NETIF_F_IP_CSUM | NETIF_F_LLTX;\r\nnetdev->irq = card->pdev->irq;\r\ncard->num_rx_ints = 0;\r\ncard->ignore_rx_ramfull = 0;\r\ndn = pci_device_to_OF_node(card->pdev);\r\nif (!dn)\r\nreturn -EIO;\r\nmac = of_get_property(dn, "local-mac-address", NULL);\r\nif (!mac)\r\nreturn -EIO;\r\nmemcpy(addr.sa_data, mac, ETH_ALEN);\r\nresult = spider_net_set_mac(netdev, &addr);\r\nif ((result) && (netif_msg_probe(card)))\r\ndev_err(&card->netdev->dev,\r\n"Failed to set MAC address: %i\n", result);\r\nresult = register_netdev(netdev);\r\nif (result) {\r\nif (netif_msg_probe(card))\r\ndev_err(&card->netdev->dev,\r\n"Couldn't register net_device: %i\n", result);\r\nreturn result;\r\n}\r\nif (netif_msg_probe(card))\r\npr_info("Initialized device %s.\n", netdev->name);\r\nreturn 0;\r\n}\r\nstatic struct spider_net_card *\r\nspider_net_alloc_card(void)\r\n{\r\nstruct net_device *netdev;\r\nstruct spider_net_card *card;\r\nsize_t alloc_size;\r\nalloc_size = sizeof(struct spider_net_card) +\r\n(tx_descriptors + rx_descriptors) * sizeof(struct spider_net_descr);\r\nnetdev = alloc_etherdev(alloc_size);\r\nif (!netdev)\r\nreturn NULL;\r\ncard = netdev_priv(netdev);\r\ncard->netdev = netdev;\r\ncard->msg_enable = SPIDER_NET_DEFAULT_MSG;\r\nINIT_WORK(&card->tx_timeout_task, spider_net_tx_timeout_task);\r\ninit_waitqueue_head(&card->waitq);\r\natomic_set(&card->tx_timeout_task_counter, 0);\r\ncard->rx_chain.num_desc = rx_descriptors;\r\ncard->rx_chain.ring = card->darray;\r\ncard->tx_chain.num_desc = tx_descriptors;\r\ncard->tx_chain.ring = card->darray + rx_descriptors;\r\nreturn card;\r\n}\r\nstatic void\r\nspider_net_undo_pci_setup(struct spider_net_card *card)\r\n{\r\niounmap(card->regs);\r\npci_release_regions(card->pdev);\r\n}\r\nstatic struct spider_net_card *\r\nspider_net_setup_pci_dev(struct pci_dev *pdev)\r\n{\r\nstruct spider_net_card *card;\r\nunsigned long mmio_start, mmio_len;\r\nif (pci_enable_device(pdev)) {\r\ndev_err(&pdev->dev, "Couldn't enable PCI device\n");\r\nreturn NULL;\r\n}\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\ndev_err(&pdev->dev,\r\n"Couldn't find proper PCI device base address.\n");\r\ngoto out_disable_dev;\r\n}\r\nif (pci_request_regions(pdev, spider_net_driver_name)) {\r\ndev_err(&pdev->dev,\r\n"Couldn't obtain PCI resources, aborting.\n");\r\ngoto out_disable_dev;\r\n}\r\npci_set_master(pdev);\r\ncard = spider_net_alloc_card();\r\nif (!card) {\r\ndev_err(&pdev->dev,\r\n"Couldn't allocate net_device structure, aborting.\n");\r\ngoto out_release_regions;\r\n}\r\ncard->pdev = pdev;\r\nmmio_start = pci_resource_start(pdev, 0);\r\nmmio_len = pci_resource_len(pdev, 0);\r\ncard->netdev->mem_start = mmio_start;\r\ncard->netdev->mem_end = mmio_start + mmio_len;\r\ncard->regs = ioremap(mmio_start, mmio_len);\r\nif (!card->regs) {\r\ndev_err(&pdev->dev,\r\n"Couldn't obtain PCI resources, aborting.\n");\r\ngoto out_release_regions;\r\n}\r\nreturn card;\r\nout_release_regions:\r\npci_release_regions(pdev);\r\nout_disable_dev:\r\npci_disable_device(pdev);\r\nreturn NULL;\r\n}\r\nstatic int\r\nspider_net_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err = -EIO;\r\nstruct spider_net_card *card;\r\ncard = spider_net_setup_pci_dev(pdev);\r\nif (!card)\r\ngoto out;\r\nspider_net_workaround_rxramfull(card);\r\nspider_net_init_card(card);\r\nerr = spider_net_setup_phy(card);\r\nif (err)\r\ngoto out_undo_pci;\r\nerr = spider_net_setup_netdev(card);\r\nif (err)\r\ngoto out_undo_pci;\r\nreturn 0;\r\nout_undo_pci:\r\nspider_net_undo_pci_setup(card);\r\nfree_netdev(card->netdev);\r\nout:\r\nreturn err;\r\n}\r\nstatic void\r\nspider_net_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev;\r\nstruct spider_net_card *card;\r\nnetdev = pci_get_drvdata(pdev);\r\ncard = netdev_priv(netdev);\r\nwait_event(card->waitq,\r\natomic_read(&card->tx_timeout_task_counter) == 0);\r\nunregister_netdev(netdev);\r\nspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\r\nSPIDER_NET_CKRCTRL_STOP_VALUE);\r\nspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\r\nSPIDER_NET_CKRCTRL_RUN_VALUE);\r\nspider_net_undo_pci_setup(card);\r\nfree_netdev(netdev);\r\n}\r\nstatic int __init spider_net_init(void)\r\n{\r\nprintk(KERN_INFO "Spidernet version %s.\n", VERSION);\r\nif (rx_descriptors < SPIDER_NET_RX_DESCRIPTORS_MIN) {\r\nrx_descriptors = SPIDER_NET_RX_DESCRIPTORS_MIN;\r\npr_info("adjusting rx descriptors to %i.\n", rx_descriptors);\r\n}\r\nif (rx_descriptors > SPIDER_NET_RX_DESCRIPTORS_MAX) {\r\nrx_descriptors = SPIDER_NET_RX_DESCRIPTORS_MAX;\r\npr_info("adjusting rx descriptors to %i.\n", rx_descriptors);\r\n}\r\nif (tx_descriptors < SPIDER_NET_TX_DESCRIPTORS_MIN) {\r\ntx_descriptors = SPIDER_NET_TX_DESCRIPTORS_MIN;\r\npr_info("adjusting tx descriptors to %i.\n", tx_descriptors);\r\n}\r\nif (tx_descriptors > SPIDER_NET_TX_DESCRIPTORS_MAX) {\r\ntx_descriptors = SPIDER_NET_TX_DESCRIPTORS_MAX;\r\npr_info("adjusting tx descriptors to %i.\n", tx_descriptors);\r\n}\r\nreturn pci_register_driver(&spider_net_driver);\r\n}\r\nstatic void __exit spider_net_cleanup(void)\r\n{\r\npci_unregister_driver(&spider_net_driver);\r\n}
