static void *pack_shadow(unsigned long eviction, struct zone *zone)\r\n{\r\neviction = (eviction << NODES_SHIFT) | zone_to_nid(zone);\r\neviction = (eviction << ZONES_SHIFT) | zone_idx(zone);\r\neviction = (eviction << RADIX_TREE_EXCEPTIONAL_SHIFT);\r\nreturn (void *)(eviction | RADIX_TREE_EXCEPTIONAL_ENTRY);\r\n}\r\nstatic void unpack_shadow(void *shadow,\r\nstruct zone **zone,\r\nunsigned long *distance)\r\n{\r\nunsigned long entry = (unsigned long)shadow;\r\nunsigned long eviction;\r\nunsigned long refault;\r\nunsigned long mask;\r\nint zid, nid;\r\nentry >>= RADIX_TREE_EXCEPTIONAL_SHIFT;\r\nzid = entry & ((1UL << ZONES_SHIFT) - 1);\r\nentry >>= ZONES_SHIFT;\r\nnid = entry & ((1UL << NODES_SHIFT) - 1);\r\nentry >>= NODES_SHIFT;\r\neviction = entry;\r\n*zone = NODE_DATA(nid)->node_zones + zid;\r\nrefault = atomic_long_read(&(*zone)->inactive_age);\r\nmask = ~0UL >> (NODES_SHIFT + ZONES_SHIFT +\r\nRADIX_TREE_EXCEPTIONAL_SHIFT);\r\n*distance = (refault - eviction) & mask;\r\n}\r\nvoid *workingset_eviction(struct address_space *mapping, struct page *page)\r\n{\r\nstruct zone *zone = page_zone(page);\r\nunsigned long eviction;\r\neviction = atomic_long_inc_return(&zone->inactive_age);\r\nreturn pack_shadow(eviction, zone);\r\n}\r\nbool workingset_refault(void *shadow)\r\n{\r\nunsigned long refault_distance;\r\nstruct zone *zone;\r\nunpack_shadow(shadow, &zone, &refault_distance);\r\ninc_zone_state(zone, WORKINGSET_REFAULT);\r\nif (refault_distance <= zone_page_state(zone, NR_ACTIVE_FILE)) {\r\ninc_zone_state(zone, WORKINGSET_ACTIVATE);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid workingset_activation(struct page *page)\r\n{\r\natomic_long_inc(&page_zone(page)->inactive_age);\r\n}\r\nstatic unsigned long count_shadow_nodes(struct shrinker *shrinker,\r\nstruct shrink_control *sc)\r\n{\r\nunsigned long shadow_nodes;\r\nunsigned long max_nodes;\r\nunsigned long pages;\r\nlocal_irq_disable();\r\nshadow_nodes = list_lru_count_node(&workingset_shadow_nodes, sc->nid);\r\nlocal_irq_enable();\r\npages = node_present_pages(sc->nid);\r\nmax_nodes = pages >> (1 + RADIX_TREE_MAP_SHIFT - 3);\r\nif (shadow_nodes <= max_nodes)\r\nreturn 0;\r\nreturn shadow_nodes - max_nodes;\r\n}\r\nstatic enum lru_status shadow_lru_isolate(struct list_head *item,\r\nspinlock_t *lru_lock,\r\nvoid *arg)\r\n{\r\nstruct address_space *mapping;\r\nstruct radix_tree_node *node;\r\nunsigned int i;\r\nint ret;\r\nnode = container_of(item, struct radix_tree_node, private_list);\r\nmapping = node->private_data;\r\nif (!spin_trylock(&mapping->tree_lock)) {\r\nspin_unlock(lru_lock);\r\nret = LRU_RETRY;\r\ngoto out;\r\n}\r\nlist_del_init(item);\r\nspin_unlock(lru_lock);\r\nBUG_ON(!node->count);\r\nBUG_ON(node->count & RADIX_TREE_COUNT_MASK);\r\nfor (i = 0; i < RADIX_TREE_MAP_SIZE; i++) {\r\nif (node->slots[i]) {\r\nBUG_ON(!radix_tree_exceptional_entry(node->slots[i]));\r\nnode->slots[i] = NULL;\r\nBUG_ON(node->count < (1U << RADIX_TREE_COUNT_SHIFT));\r\nnode->count -= 1U << RADIX_TREE_COUNT_SHIFT;\r\nBUG_ON(!mapping->nrshadows);\r\nmapping->nrshadows--;\r\n}\r\n}\r\nBUG_ON(node->count);\r\ninc_zone_state(page_zone(virt_to_page(node)), WORKINGSET_NODERECLAIM);\r\nif (!__radix_tree_delete_node(&mapping->page_tree, node))\r\nBUG();\r\nspin_unlock(&mapping->tree_lock);\r\nret = LRU_REMOVED_RETRY;\r\nout:\r\nlocal_irq_enable();\r\ncond_resched();\r\nlocal_irq_disable();\r\nspin_lock(lru_lock);\r\nreturn ret;\r\n}\r\nstatic unsigned long scan_shadow_nodes(struct shrinker *shrinker,\r\nstruct shrink_control *sc)\r\n{\r\nunsigned long ret;\r\nlocal_irq_disable();\r\nret = list_lru_walk_node(&workingset_shadow_nodes, sc->nid,\r\nshadow_lru_isolate, NULL, &sc->nr_to_scan);\r\nlocal_irq_enable();\r\nreturn ret;\r\n}\r\nstatic int __init workingset_init(void)\r\n{\r\nint ret;\r\nret = list_lru_init_key(&workingset_shadow_nodes, &shadow_nodes_key);\r\nif (ret)\r\ngoto err;\r\nret = register_shrinker(&workingset_shadow_shrinker);\r\nif (ret)\r\ngoto err_list_lru;\r\nreturn 0;\r\nerr_list_lru:\r\nlist_lru_destroy(&workingset_shadow_nodes);\r\nerr:\r\nreturn ret;\r\n}
