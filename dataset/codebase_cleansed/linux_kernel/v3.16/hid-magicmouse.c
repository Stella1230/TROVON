static int param_set_scroll_speed(const char *val, struct kernel_param *kp) {\r\nunsigned long speed;\r\nif (!val || kstrtoul(val, 0, &speed) || speed > 63)\r\nreturn -EINVAL;\r\nscroll_speed = speed;\r\nreturn 0;\r\n}\r\nstatic int magicmouse_firm_touch(struct magicmouse_sc *msc)\r\n{\r\nint touch = -1;\r\nint ii;\r\nfor (ii = 0; ii < msc->ntouches; ii++) {\r\nint idx = msc->tracking_ids[ii];\r\nif (msc->touches[idx].size < 8) {\r\n} else if (touch >= 0) {\r\ntouch = -1;\r\nbreak;\r\n} else {\r\ntouch = idx;\r\n}\r\n}\r\nreturn touch;\r\n}\r\nstatic void magicmouse_emit_buttons(struct magicmouse_sc *msc, int state)\r\n{\r\nint last_state = test_bit(BTN_LEFT, msc->input->key) << 0 |\r\ntest_bit(BTN_RIGHT, msc->input->key) << 1 |\r\ntest_bit(BTN_MIDDLE, msc->input->key) << 2;\r\nif (emulate_3button) {\r\nint id;\r\nif (state == 0) {\r\n} else if (last_state != 0) {\r\nstate = last_state;\r\n} else if ((id = magicmouse_firm_touch(msc)) >= 0) {\r\nint x = msc->touches[id].x;\r\nif (x < middle_button_start)\r\nstate = 1;\r\nelse if (x > middle_button_stop)\r\nstate = 2;\r\nelse\r\nstate = 4;\r\n}\r\ninput_report_key(msc->input, BTN_MIDDLE, state & 4);\r\n}\r\ninput_report_key(msc->input, BTN_LEFT, state & 1);\r\ninput_report_key(msc->input, BTN_RIGHT, state & 2);\r\nif (state != last_state)\r\nmsc->scroll_accel = SCROLL_ACCEL_DEFAULT;\r\n}\r\nstatic void magicmouse_emit_touch(struct magicmouse_sc *msc, int raw_id, u8 *tdata)\r\n{\r\nstruct input_dev *input = msc->input;\r\nint id, x, y, size, orientation, touch_major, touch_minor, state, down;\r\nif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\r\nid = (tdata[6] << 2 | tdata[5] >> 6) & 0xf;\r\nx = (tdata[1] << 28 | tdata[0] << 20) >> 20;\r\ny = -((tdata[2] << 24 | tdata[1] << 16) >> 20);\r\nsize = tdata[5] & 0x3f;\r\norientation = (tdata[6] >> 2) - 32;\r\ntouch_major = tdata[3];\r\ntouch_minor = tdata[4];\r\nstate = tdata[7] & TOUCH_STATE_MASK;\r\ndown = state != TOUCH_STATE_NONE;\r\n} else {\r\nid = (tdata[7] << 2 | tdata[6] >> 6) & 0xf;\r\nx = (tdata[1] << 27 | tdata[0] << 19) >> 19;\r\ny = -((tdata[3] << 30 | tdata[2] << 22 | tdata[1] << 14) >> 19);\r\nsize = tdata[6] & 0x3f;\r\norientation = (tdata[7] >> 2) - 32;\r\ntouch_major = tdata[4];\r\ntouch_minor = tdata[5];\r\nstate = tdata[8] & TOUCH_STATE_MASK;\r\ndown = state != TOUCH_STATE_NONE;\r\n}\r\nmsc->tracking_ids[raw_id] = id;\r\nmsc->touches[id].x = x;\r\nmsc->touches[id].y = y;\r\nmsc->touches[id].size = size;\r\nif (emulate_scroll_wheel) {\r\nunsigned long now = jiffies;\r\nint step_x = msc->touches[id].scroll_x - x;\r\nint step_y = msc->touches[id].scroll_y - y;\r\nswitch (state) {\r\ncase TOUCH_STATE_START:\r\nmsc->touches[id].scroll_x = x;\r\nmsc->touches[id].scroll_y = y;\r\nif (scroll_acceleration && time_before(now,\r\nmsc->scroll_jiffies + HZ / 2))\r\nmsc->scroll_accel = max_t(int,\r\nmsc->scroll_accel - 1, 1);\r\nelse\r\nmsc->scroll_accel = SCROLL_ACCEL_DEFAULT;\r\nbreak;\r\ncase TOUCH_STATE_DRAG:\r\nstep_x /= (64 - (int)scroll_speed) * msc->scroll_accel;\r\nif (step_x != 0) {\r\nmsc->touches[id].scroll_x -= step_x *\r\n(64 - scroll_speed) * msc->scroll_accel;\r\nmsc->scroll_jiffies = now;\r\ninput_report_rel(input, REL_HWHEEL, -step_x);\r\n}\r\nstep_y /= (64 - (int)scroll_speed) * msc->scroll_accel;\r\nif (step_y != 0) {\r\nmsc->touches[id].scroll_y -= step_y *\r\n(64 - scroll_speed) * msc->scroll_accel;\r\nmsc->scroll_jiffies = now;\r\ninput_report_rel(input, REL_WHEEL, step_y);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (down)\r\nmsc->ntouches++;\r\ninput_mt_slot(input, id);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, down);\r\nif (down) {\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR, touch_major << 2);\r\ninput_report_abs(input, ABS_MT_TOUCH_MINOR, touch_minor << 2);\r\ninput_report_abs(input, ABS_MT_ORIENTATION, -orientation);\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\nif (report_undeciphered) {\r\nif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE)\r\ninput_event(input, EV_MSC, MSC_RAW, tdata[7]);\r\nelse\r\ninput_event(input, EV_MSC, MSC_RAW, tdata[8]);\r\n}\r\n}\r\n}\r\nstatic int magicmouse_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data, int size)\r\n{\r\nstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\r\nstruct input_dev *input = msc->input;\r\nint x = 0, y = 0, ii, clicks = 0, npoints;\r\nswitch (data[0]) {\r\ncase TRACKPAD_REPORT_ID:\r\nif (size < 4 || ((size - 4) % 9) != 0)\r\nreturn 0;\r\nnpoints = (size - 4) / 9;\r\nmsc->ntouches = 0;\r\nfor (ii = 0; ii < npoints; ii++)\r\nmagicmouse_emit_touch(msc, ii, data + ii * 9 + 4);\r\nclicks = data[1];\r\nbreak;\r\ncase MOUSE_REPORT_ID:\r\nif (size < 6 || ((size - 6) % 8) != 0)\r\nreturn 0;\r\nnpoints = (size - 6) / 8;\r\nmsc->ntouches = 0;\r\nfor (ii = 0; ii < npoints; ii++)\r\nmagicmouse_emit_touch(msc, ii, data + ii * 8 + 6);\r\nx = (int)(((data[3] & 0x0c) << 28) | (data[1] << 22)) >> 22;\r\ny = (int)(((data[3] & 0x30) << 26) | (data[2] << 22)) >> 22;\r\nclicks = data[3];\r\nbreak;\r\ncase DOUBLE_REPORT_ID:\r\nmagicmouse_raw_event(hdev, report, data + 2, data[1]);\r\nmagicmouse_raw_event(hdev, report, data + 2 + data[1],\r\nsize - 2 - data[1]);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\r\nmagicmouse_emit_buttons(msc, clicks & 3);\r\ninput_report_rel(input, REL_X, x);\r\ninput_report_rel(input, REL_Y, y);\r\n} else {\r\ninput_report_key(input, BTN_MOUSE, clicks & 1);\r\ninput_mt_report_pointer_emulation(input, true);\r\n}\r\ninput_sync(input);\r\nreturn 1;\r\n}\r\nstatic int magicmouse_setup_input(struct input_dev *input, struct hid_device *hdev)\r\n{\r\nint error;\r\n__set_bit(EV_KEY, input->evbit);\r\nif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\r\n__set_bit(BTN_LEFT, input->keybit);\r\n__set_bit(BTN_RIGHT, input->keybit);\r\nif (emulate_3button)\r\n__set_bit(BTN_MIDDLE, input->keybit);\r\n__set_bit(EV_REL, input->evbit);\r\n__set_bit(REL_X, input->relbit);\r\n__set_bit(REL_Y, input->relbit);\r\nif (emulate_scroll_wheel) {\r\n__set_bit(REL_WHEEL, input->relbit);\r\n__set_bit(REL_HWHEEL, input->relbit);\r\n}\r\n} else {\r\n__clear_bit(BTN_RIGHT, input->keybit);\r\n__clear_bit(BTN_MIDDLE, input->keybit);\r\n__set_bit(BTN_MOUSE, input->keybit);\r\n__set_bit(BTN_TOOL_FINGER, input->keybit);\r\n__set_bit(BTN_TOOL_DOUBLETAP, input->keybit);\r\n__set_bit(BTN_TOOL_TRIPLETAP, input->keybit);\r\n__set_bit(BTN_TOOL_QUADTAP, input->keybit);\r\n__set_bit(BTN_TOOL_QUINTTAP, input->keybit);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\n__set_bit(INPUT_PROP_POINTER, input->propbit);\r\n__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\r\n}\r\n__set_bit(EV_ABS, input->evbit);\r\nerror = input_mt_init_slots(input, 16, 0);\r\nif (error)\r\nreturn error;\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 255 << 2,\r\n4, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MINOR, 0, 255 << 2,\r\n4, 0);\r\ninput_set_abs_params(input, ABS_MT_ORIENTATION, -31, 32, 1, 0);\r\nif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\r\ninput_set_abs_params(input, ABS_MT_POSITION_X,\r\nMOUSE_MIN_X, MOUSE_MAX_X, 4, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y,\r\nMOUSE_MIN_Y, MOUSE_MAX_Y, 4, 0);\r\ninput_abs_set_res(input, ABS_MT_POSITION_X,\r\nMOUSE_RES_X);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y,\r\nMOUSE_RES_Y);\r\n} else {\r\ninput_set_abs_params(input, ABS_X, TRACKPAD_MIN_X,\r\nTRACKPAD_MAX_X, 4, 0);\r\ninput_set_abs_params(input, ABS_Y, TRACKPAD_MIN_Y,\r\nTRACKPAD_MAX_Y, 4, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X,\r\nTRACKPAD_MIN_X, TRACKPAD_MAX_X, 4, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y,\r\nTRACKPAD_MIN_Y, TRACKPAD_MAX_Y, 4, 0);\r\ninput_abs_set_res(input, ABS_X, TRACKPAD_RES_X);\r\ninput_abs_set_res(input, ABS_Y, TRACKPAD_RES_Y);\r\ninput_abs_set_res(input, ABS_MT_POSITION_X,\r\nTRACKPAD_RES_X);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y,\r\nTRACKPAD_RES_Y);\r\n}\r\ninput_set_events_per_packet(input, 60);\r\nif (report_undeciphered) {\r\n__set_bit(EV_MSC, input->evbit);\r\n__set_bit(MSC_RAW, input->mscbit);\r\n}\r\nreturn 0;\r\n}\r\nstatic int magicmouse_input_mapping(struct hid_device *hdev,\r\nstruct hid_input *hi, struct hid_field *field,\r\nstruct hid_usage *usage, unsigned long **bit, int *max)\r\n{\r\nstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\r\nif (!msc->input)\r\nmsc->input = hi->input;\r\nif (hi->input->id.product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD &&\r\nfield->flags & HID_MAIN_ITEM_RELATIVE)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void magicmouse_input_configured(struct hid_device *hdev,\r\nstruct hid_input *hi)\r\n{\r\nstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\r\nint ret = magicmouse_setup_input(msc->input, hdev);\r\nif (ret) {\r\nhid_err(hdev, "magicmouse setup input failed (%d)\n", ret);\r\nmsc->input = NULL;\r\n}\r\n}\r\nstatic int magicmouse_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\n__u8 feature[] = { 0xd7, 0x01 };\r\nstruct magicmouse_sc *msc;\r\nstruct hid_report *report;\r\nint ret;\r\nmsc = devm_kzalloc(&hdev->dev, sizeof(*msc), GFP_KERNEL);\r\nif (msc == NULL) {\r\nhid_err(hdev, "can't alloc magicmouse descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\nmsc->scroll_accel = SCROLL_ACCEL_DEFAULT;\r\nmsc->quirks = id->driver_data;\r\nhid_set_drvdata(hdev, msc);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "magicmouse hid parse failed\n");\r\nreturn ret;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "magicmouse hw start failed\n");\r\nreturn ret;\r\n}\r\nif (!msc->input) {\r\nhid_err(hdev, "magicmouse input not registered\n");\r\nret = -ENOMEM;\r\ngoto err_stop_hw;\r\n}\r\nif (id->product == USB_DEVICE_ID_APPLE_MAGICMOUSE)\r\nreport = hid_register_report(hdev, HID_INPUT_REPORT,\r\nMOUSE_REPORT_ID);\r\nelse {\r\nreport = hid_register_report(hdev, HID_INPUT_REPORT,\r\nTRACKPAD_REPORT_ID);\r\nreport = hid_register_report(hdev, HID_INPUT_REPORT,\r\nDOUBLE_REPORT_ID);\r\n}\r\nif (!report) {\r\nhid_err(hdev, "unable to register touch report\n");\r\nret = -ENOMEM;\r\ngoto err_stop_hw;\r\n}\r\nreport->size = 6;\r\nret = hid_hw_raw_request(hdev, feature[0], feature, sizeof(feature),\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nif (ret != -EIO && ret != sizeof(feature)) {\r\nhid_err(hdev, "unable to request touch data (%d)\n", ret);\r\ngoto err_stop_hw;\r\n}\r\nreturn 0;\r\nerr_stop_hw:\r\nhid_hw_stop(hdev);\r\nreturn ret;\r\n}
