void register_switch_driver(struct dsa_switch_driver *drv)\r\n{\r\nmutex_lock(&dsa_switch_drivers_mutex);\r\nlist_add_tail(&drv->list, &dsa_switch_drivers);\r\nmutex_unlock(&dsa_switch_drivers_mutex);\r\n}\r\nvoid unregister_switch_driver(struct dsa_switch_driver *drv)\r\n{\r\nmutex_lock(&dsa_switch_drivers_mutex);\r\nlist_del_init(&drv->list);\r\nmutex_unlock(&dsa_switch_drivers_mutex);\r\n}\r\nstatic struct dsa_switch_driver *\r\ndsa_switch_probe(struct mii_bus *bus, int sw_addr, char **_name)\r\n{\r\nstruct dsa_switch_driver *ret;\r\nstruct list_head *list;\r\nchar *name;\r\nret = NULL;\r\nname = NULL;\r\nmutex_lock(&dsa_switch_drivers_mutex);\r\nlist_for_each(list, &dsa_switch_drivers) {\r\nstruct dsa_switch_driver *drv;\r\ndrv = list_entry(list, struct dsa_switch_driver, list);\r\nname = drv->probe(bus, sw_addr);\r\nif (name != NULL) {\r\nret = drv;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&dsa_switch_drivers_mutex);\r\n*_name = name;\r\nreturn ret;\r\n}\r\nstatic struct dsa_switch *\r\ndsa_switch_setup(struct dsa_switch_tree *dst, int index,\r\nstruct device *parent, struct mii_bus *bus)\r\n{\r\nstruct dsa_chip_data *pd = dst->pd->chip + index;\r\nstruct dsa_switch_driver *drv;\r\nstruct dsa_switch *ds;\r\nint ret;\r\nchar *name;\r\nint i;\r\nbool valid_name_found = false;\r\ndrv = dsa_switch_probe(bus, pd->sw_addr, &name);\r\nif (drv == NULL) {\r\nprintk(KERN_ERR "%s[%d]: could not detect attached switch\n",\r\ndst->master_netdev->name, index);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nprintk(KERN_INFO "%s[%d]: detected a %s switch\n",\r\ndst->master_netdev->name, index, name);\r\nds = kzalloc(sizeof(*ds) + drv->priv_size, GFP_KERNEL);\r\nif (ds == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nds->dst = dst;\r\nds->index = index;\r\nds->pd = dst->pd->chip + index;\r\nds->drv = drv;\r\nds->master_mii_bus = bus;\r\nfor (i = 0; i < DSA_MAX_PORTS; i++) {\r\nchar *name;\r\nname = pd->port_names[i];\r\nif (name == NULL)\r\ncontinue;\r\nif (!strcmp(name, "cpu")) {\r\nif (dst->cpu_switch != -1) {\r\nprintk(KERN_ERR "multiple cpu ports?!\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndst->cpu_switch = index;\r\ndst->cpu_port = i;\r\n} else if (!strcmp(name, "dsa")) {\r\nds->dsa_port_mask |= 1 << i;\r\n} else {\r\nds->phys_port_mask |= 1 << i;\r\n}\r\nvalid_name_found = true;\r\n}\r\nif (!valid_name_found && i == DSA_MAX_PORTS) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (ds->dst->cpu_switch == index)\r\nds->dst->tag_protocol = drv->tag_protocol;\r\nret = drv->setup(ds);\r\nif (ret < 0)\r\ngoto out;\r\nret = drv->set_addr(ds, dst->master_netdev->dev_addr);\r\nif (ret < 0)\r\ngoto out;\r\nds->slave_mii_bus = mdiobus_alloc();\r\nif (ds->slave_mii_bus == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ndsa_slave_mii_bus_init(ds);\r\nret = mdiobus_register(ds->slave_mii_bus);\r\nif (ret < 0)\r\ngoto out_free;\r\nfor (i = 0; i < DSA_MAX_PORTS; i++) {\r\nstruct net_device *slave_dev;\r\nif (!(ds->phys_port_mask & (1 << i)))\r\ncontinue;\r\nslave_dev = dsa_slave_create(ds, parent, i, pd->port_names[i]);\r\nif (slave_dev == NULL) {\r\nprintk(KERN_ERR "%s[%d]: can't create dsa "\r\n"slave device for port %d(%s)\n",\r\ndst->master_netdev->name,\r\nindex, i, pd->port_names[i]);\r\ncontinue;\r\n}\r\nds->ports[i] = slave_dev;\r\n}\r\nreturn ds;\r\nout_free:\r\nmdiobus_free(ds->slave_mii_bus);\r\nout:\r\nkfree(ds);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void dsa_switch_destroy(struct dsa_switch *ds)\r\n{\r\n}\r\nstatic void dsa_link_poll_work(struct work_struct *ugly)\r\n{\r\nstruct dsa_switch_tree *dst;\r\nint i;\r\ndst = container_of(ugly, struct dsa_switch_tree, link_poll_work);\r\nfor (i = 0; i < dst->pd->nr_chips; i++) {\r\nstruct dsa_switch *ds = dst->ds[i];\r\nif (ds != NULL && ds->drv->poll_link != NULL)\r\nds->drv->poll_link(ds);\r\n}\r\nmod_timer(&dst->link_poll_timer, round_jiffies(jiffies + HZ));\r\n}\r\nstatic void dsa_link_poll_timer(unsigned long _dst)\r\n{\r\nstruct dsa_switch_tree *dst = (void *)_dst;\r\nschedule_work(&dst->link_poll_work);\r\n}\r\nstatic int dev_is_class(struct device *dev, void *class)\r\n{\r\nif (dev->class != NULL && !strcmp(dev->class->name, class))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct device *dev_find_class(struct device *parent, char *class)\r\n{\r\nif (dev_is_class(parent, class)) {\r\nget_device(parent);\r\nreturn parent;\r\n}\r\nreturn device_find_child(parent, class, dev_is_class);\r\n}\r\nstatic struct mii_bus *dev_to_mii_bus(struct device *dev)\r\n{\r\nstruct device *d;\r\nd = dev_find_class(dev, "mdio_bus");\r\nif (d != NULL) {\r\nstruct mii_bus *bus;\r\nbus = to_mii_bus(d);\r\nput_device(d);\r\nreturn bus;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct net_device *dev_to_net_device(struct device *dev)\r\n{\r\nstruct device *d;\r\nd = dev_find_class(dev, "net");\r\nif (d != NULL) {\r\nstruct net_device *nd;\r\nnd = to_net_dev(d);\r\ndev_hold(nd);\r\nput_device(d);\r\nreturn nd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int dsa_of_setup_routing_table(struct dsa_platform_data *pd,\r\nstruct dsa_chip_data *cd,\r\nint chip_index,\r\nstruct device_node *link)\r\n{\r\nint ret;\r\nconst __be32 *reg;\r\nint link_port_addr;\r\nint link_sw_addr;\r\nstruct device_node *parent_sw;\r\nint len;\r\nparent_sw = of_get_parent(link);\r\nif (!parent_sw)\r\nreturn -EINVAL;\r\nreg = of_get_property(parent_sw, "reg", &len);\r\nif (!reg || (len != sizeof(*reg) * 2))\r\nreturn -EINVAL;\r\nlink_sw_addr = be32_to_cpup(reg + 1);\r\nif (link_sw_addr >= pd->nr_chips)\r\nreturn -EINVAL;\r\nif (!cd->rtable) {\r\ncd->rtable = kmalloc(pd->nr_chips * sizeof(s8), GFP_KERNEL);\r\nif (!cd->rtable)\r\nreturn -ENOMEM;\r\nmemset(cd->rtable, -1, pd->nr_chips * sizeof(s8));\r\n}\r\nreg = of_get_property(link, "reg", NULL);\r\nif (!reg) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nlink_port_addr = be32_to_cpup(reg);\r\ncd->rtable[link_sw_addr] = link_port_addr;\r\nreturn 0;\r\nout:\r\nkfree(cd->rtable);\r\nreturn ret;\r\n}\r\nstatic void dsa_of_free_platform_data(struct dsa_platform_data *pd)\r\n{\r\nint i;\r\nint port_index;\r\nfor (i = 0; i < pd->nr_chips; i++) {\r\nport_index = 0;\r\nwhile (port_index < DSA_MAX_PORTS) {\r\nif (pd->chip[i].port_names[port_index])\r\nkfree(pd->chip[i].port_names[port_index]);\r\nport_index++;\r\n}\r\nkfree(pd->chip[i].rtable);\r\n}\r\nkfree(pd->chip);\r\n}\r\nstatic int dsa_of_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child, *mdio, *ethernet, *port, *link;\r\nstruct mii_bus *mdio_bus;\r\nstruct platform_device *ethernet_dev;\r\nstruct dsa_platform_data *pd;\r\nstruct dsa_chip_data *cd;\r\nconst char *port_name;\r\nint chip_index, port_index;\r\nconst unsigned int *sw_addr, *port_reg;\r\nint ret;\r\nmdio = of_parse_phandle(np, "dsa,mii-bus", 0);\r\nif (!mdio)\r\nreturn -EINVAL;\r\nmdio_bus = of_mdio_find_bus(mdio);\r\nif (!mdio_bus)\r\nreturn -EINVAL;\r\nethernet = of_parse_phandle(np, "dsa,ethernet", 0);\r\nif (!ethernet)\r\nreturn -EINVAL;\r\nethernet_dev = of_find_device_by_node(ethernet);\r\nif (!ethernet_dev)\r\nreturn -ENODEV;\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\npdev->dev.platform_data = pd;\r\npd->netdev = &ethernet_dev->dev;\r\npd->nr_chips = of_get_child_count(np);\r\nif (pd->nr_chips > DSA_MAX_SWITCHES)\r\npd->nr_chips = DSA_MAX_SWITCHES;\r\npd->chip = kzalloc(pd->nr_chips * sizeof(struct dsa_chip_data),\r\nGFP_KERNEL);\r\nif (!pd->chip) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nchip_index = -1;\r\nfor_each_available_child_of_node(np, child) {\r\nchip_index++;\r\ncd = &pd->chip[chip_index];\r\ncd->mii_bus = &mdio_bus->dev;\r\nsw_addr = of_get_property(child, "reg", NULL);\r\nif (!sw_addr)\r\ncontinue;\r\ncd->sw_addr = be32_to_cpup(sw_addr);\r\nif (cd->sw_addr > PHY_MAX_ADDR)\r\ncontinue;\r\nfor_each_available_child_of_node(child, port) {\r\nport_reg = of_get_property(port, "reg", NULL);\r\nif (!port_reg)\r\ncontinue;\r\nport_index = be32_to_cpup(port_reg);\r\nport_name = of_get_property(port, "label", NULL);\r\nif (!port_name)\r\ncontinue;\r\ncd->port_names[port_index] = kstrdup(port_name,\r\nGFP_KERNEL);\r\nif (!cd->port_names[port_index]) {\r\nret = -ENOMEM;\r\ngoto out_free_chip;\r\n}\r\nlink = of_parse_phandle(port, "link", 0);\r\nif (!strcmp(port_name, "dsa") && link &&\r\npd->nr_chips > 1) {\r\nret = dsa_of_setup_routing_table(pd, cd,\r\nchip_index, link);\r\nif (ret)\r\ngoto out_free_chip;\r\n}\r\nif (port_index == DSA_MAX_PORTS)\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nout_free_chip:\r\ndsa_of_free_platform_data(pd);\r\nout_free:\r\nkfree(pd);\r\npdev->dev.platform_data = NULL;\r\nreturn ret;\r\n}\r\nstatic void dsa_of_remove(struct platform_device *pdev)\r\n{\r\nstruct dsa_platform_data *pd = pdev->dev.platform_data;\r\nif (!pdev->dev.of_node)\r\nreturn;\r\ndsa_of_free_platform_data(pd);\r\nkfree(pd);\r\n}\r\nstatic inline int dsa_of_probe(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void dsa_of_remove(struct platform_device *pdev)\r\n{\r\n}\r\nstatic int dsa_probe(struct platform_device *pdev)\r\n{\r\nstatic int dsa_version_printed;\r\nstruct dsa_platform_data *pd = pdev->dev.platform_data;\r\nstruct net_device *dev;\r\nstruct dsa_switch_tree *dst;\r\nint i, ret;\r\nif (!dsa_version_printed++)\r\nprintk(KERN_NOTICE "Distributed Switch Architecture "\r\n"driver version %s\n", dsa_driver_version);\r\nif (pdev->dev.of_node) {\r\nret = dsa_of_probe(pdev);\r\nif (ret)\r\nreturn ret;\r\npd = pdev->dev.platform_data;\r\n}\r\nif (pd == NULL || pd->netdev == NULL)\r\nreturn -EINVAL;\r\ndev = dev_to_net_device(pd->netdev);\r\nif (dev == NULL) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (dev->dsa_ptr != NULL) {\r\ndev_put(dev);\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\ndst = kzalloc(sizeof(*dst), GFP_KERNEL);\r\nif (dst == NULL) {\r\ndev_put(dev);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nplatform_set_drvdata(pdev, dst);\r\ndst->pd = pd;\r\ndst->master_netdev = dev;\r\ndst->cpu_switch = -1;\r\ndst->cpu_port = -1;\r\nfor (i = 0; i < pd->nr_chips; i++) {\r\nstruct mii_bus *bus;\r\nstruct dsa_switch *ds;\r\nbus = dev_to_mii_bus(pd->chip[i].mii_bus);\r\nif (bus == NULL) {\r\nprintk(KERN_ERR "%s[%d]: no mii bus found for "\r\n"dsa switch\n", dev->name, i);\r\ncontinue;\r\n}\r\nds = dsa_switch_setup(dst, i, &pdev->dev, bus);\r\nif (IS_ERR(ds)) {\r\nprintk(KERN_ERR "%s[%d]: couldn't create dsa switch "\r\n"instance (error %ld)\n", dev->name, i,\r\nPTR_ERR(ds));\r\ncontinue;\r\n}\r\ndst->ds[i] = ds;\r\nif (ds->drv->poll_link != NULL)\r\ndst->link_poll_needed = 1;\r\n}\r\nwmb();\r\ndev->dsa_ptr = (void *)dst;\r\nif (dst->link_poll_needed) {\r\nINIT_WORK(&dst->link_poll_work, dsa_link_poll_work);\r\ninit_timer(&dst->link_poll_timer);\r\ndst->link_poll_timer.data = (unsigned long)dst;\r\ndst->link_poll_timer.function = dsa_link_poll_timer;\r\ndst->link_poll_timer.expires = round_jiffies(jiffies + HZ);\r\nadd_timer(&dst->link_poll_timer);\r\n}\r\nreturn 0;\r\nout:\r\ndsa_of_remove(pdev);\r\nreturn ret;\r\n}\r\nstatic int dsa_remove(struct platform_device *pdev)\r\n{\r\nstruct dsa_switch_tree *dst = platform_get_drvdata(pdev);\r\nint i;\r\nif (dst->link_poll_needed)\r\ndel_timer_sync(&dst->link_poll_timer);\r\nflush_work(&dst->link_poll_work);\r\nfor (i = 0; i < dst->pd->nr_chips; i++) {\r\nstruct dsa_switch *ds = dst->ds[i];\r\nif (ds != NULL)\r\ndsa_switch_destroy(ds);\r\n}\r\ndsa_of_remove(pdev);\r\nreturn 0;\r\n}\r\nstatic void dsa_shutdown(struct platform_device *pdev)\r\n{\r\n}\r\nstatic int __init dsa_init_module(void)\r\n{\r\nint rc;\r\nrc = platform_driver_register(&dsa_driver);\r\nif (rc)\r\nreturn rc;\r\n#ifdef CONFIG_NET_DSA_TAG_DSA\r\ndev_add_pack(&dsa_packet_type);\r\n#endif\r\n#ifdef CONFIG_NET_DSA_TAG_EDSA\r\ndev_add_pack(&edsa_packet_type);\r\n#endif\r\n#ifdef CONFIG_NET_DSA_TAG_TRAILER\r\ndev_add_pack(&trailer_packet_type);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit dsa_cleanup_module(void)\r\n{\r\n#ifdef CONFIG_NET_DSA_TAG_TRAILER\r\ndev_remove_pack(&trailer_packet_type);\r\n#endif\r\n#ifdef CONFIG_NET_DSA_TAG_EDSA\r\ndev_remove_pack(&edsa_packet_type);\r\n#endif\r\n#ifdef CONFIG_NET_DSA_TAG_DSA\r\ndev_remove_pack(&dsa_packet_type);\r\n#endif\r\nplatform_driver_unregister(&dsa_driver);\r\n}
