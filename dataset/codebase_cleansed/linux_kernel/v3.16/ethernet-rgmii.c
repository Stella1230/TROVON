static void cvm_oct_rgmii_poll(struct net_device *dev)\r\n{\r\nstruct octeon_ethernet *priv = netdev_priv(dev);\r\nunsigned long flags = 0;\r\ncvmx_helper_link_info_t link_info;\r\nint use_global_register_lock = (priv->phydev == NULL);\r\nBUG_ON(in_interrupt());\r\nif (use_global_register_lock) {\r\nspin_lock_irqsave(&global_register_lock, flags);\r\n} else {\r\nmutex_lock(&priv->phydev->bus->mdio_lock);\r\n}\r\nlink_info = cvmx_helper_link_get(priv->port);\r\nif (link_info.u64 == priv->link_info) {\r\nif (USE_10MBPS_PREAMBLE_WORKAROUND &&\r\n(link_info.s.speed == 10)) {\r\nint interface = INTERFACE(priv->port);\r\nint index = INDEX(priv->port);\r\nunion cvmx_gmxx_rxx_int_reg gmxx_rxx_int_reg;\r\ngmxx_rxx_int_reg.u64 =\r\ncvmx_read_csr(CVMX_GMXX_RXX_INT_REG\r\n(index, interface));\r\nif (gmxx_rxx_int_reg.s.pcterr) {\r\nunion cvmx_gmxx_rxx_frm_ctl gmxx_rxx_frm_ctl;\r\nunion cvmx_ipd_sub_port_fcs ipd_sub_port_fcs;\r\ngmxx_rxx_frm_ctl.u64 =\r\ncvmx_read_csr(CVMX_GMXX_RXX_FRM_CTL\r\n(index, interface));\r\ngmxx_rxx_frm_ctl.s.pre_chk = 0;\r\ncvmx_write_csr(CVMX_GMXX_RXX_FRM_CTL\r\n(index, interface),\r\ngmxx_rxx_frm_ctl.u64);\r\nipd_sub_port_fcs.u64 =\r\ncvmx_read_csr(CVMX_IPD_SUB_PORT_FCS);\r\nipd_sub_port_fcs.s.port_bit &=\r\n0xffffffffull ^ (1ull << priv->port);\r\ncvmx_write_csr(CVMX_IPD_SUB_PORT_FCS,\r\nipd_sub_port_fcs.u64);\r\ncvmx_write_csr(CVMX_GMXX_RXX_INT_REG\r\n(index, interface),\r\ngmxx_rxx_int_reg.u64);\r\nprintk_ratelimited("%s: Using 10Mbps with software "\r\n"preamble removal\n",\r\ndev->name);\r\n}\r\n}\r\nif (use_global_register_lock)\r\nspin_unlock_irqrestore(&global_register_lock, flags);\r\nelse\r\nmutex_unlock(&priv->phydev->bus->mdio_lock);\r\nreturn;\r\n}\r\nif (USE_10MBPS_PREAMBLE_WORKAROUND) {\r\nunion cvmx_gmxx_rxx_frm_ctl gmxx_rxx_frm_ctl;\r\nunion cvmx_ipd_sub_port_fcs ipd_sub_port_fcs;\r\nunion cvmx_gmxx_rxx_int_reg gmxx_rxx_int_reg;\r\nint interface = INTERFACE(priv->port);\r\nint index = INDEX(priv->port);\r\ngmxx_rxx_frm_ctl.u64 =\r\ncvmx_read_csr(CVMX_GMXX_RXX_FRM_CTL(index, interface));\r\ngmxx_rxx_frm_ctl.s.pre_chk = 1;\r\ncvmx_write_csr(CVMX_GMXX_RXX_FRM_CTL(index, interface),\r\ngmxx_rxx_frm_ctl.u64);\r\nipd_sub_port_fcs.u64 = cvmx_read_csr(CVMX_IPD_SUB_PORT_FCS);\r\nipd_sub_port_fcs.s.port_bit |= 1ull << priv->port;\r\ncvmx_write_csr(CVMX_IPD_SUB_PORT_FCS, ipd_sub_port_fcs.u64);\r\ngmxx_rxx_int_reg.u64 =\r\ncvmx_read_csr(CVMX_GMXX_RXX_INT_REG(index, interface));\r\ncvmx_write_csr(CVMX_GMXX_RXX_INT_REG(index, interface),\r\ngmxx_rxx_int_reg.u64);\r\n}\r\nif (priv->phydev == NULL) {\r\nlink_info = cvmx_helper_link_autoconf(priv->port);\r\npriv->link_info = link_info.u64;\r\n}\r\nif (use_global_register_lock)\r\nspin_unlock_irqrestore(&global_register_lock, flags);\r\nelse\r\nmutex_unlock(&priv->phydev->bus->mdio_lock);\r\nif (priv->phydev == NULL) {\r\nif (link_info.s.link_up) {\r\nif (!netif_carrier_ok(dev))\r\nnetif_carrier_on(dev);\r\nif (priv->queue != -1)\r\nprintk_ratelimited("%s: %u Mbps %s duplex, "\r\n"port %2d, queue %2d\n",\r\ndev->name, link_info.s.speed,\r\n(link_info.s.full_duplex) ?\r\n"Full" : "Half",\r\npriv->port, priv->queue);\r\nelse\r\nprintk_ratelimited("%s: %u Mbps %s duplex, "\r\n"port %2d, POW\n",\r\ndev->name, link_info.s.speed,\r\n(link_info.s.full_duplex) ?\r\n"Full" : "Half",\r\npriv->port);\r\n} else {\r\nif (netif_carrier_ok(dev))\r\nnetif_carrier_off(dev);\r\nprintk_ratelimited("%s: Link down\n", dev->name);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t cvm_oct_rgmii_rml_interrupt(int cpl, void *dev_id)\r\n{\r\nunion cvmx_npi_rsl_int_blocks rsl_int_blocks;\r\nint index;\r\nirqreturn_t return_status = IRQ_NONE;\r\nrsl_int_blocks.u64 = cvmx_read_csr(CVMX_NPI_RSL_INT_BLOCKS);\r\nif (rsl_int_blocks.s.gmx0) {\r\nint interface = 0;\r\nfor (index = 0;\r\nindex < cvmx_helper_ports_on_interface(interface);\r\nindex++) {\r\nunion cvmx_gmxx_rxx_int_reg gmx_rx_int_reg;\r\ngmx_rx_int_reg.u64 =\r\ncvmx_read_csr(CVMX_GMXX_RXX_INT_REG\r\n(index, interface));\r\ngmx_rx_int_reg.u64 &=\r\ncvmx_read_csr(CVMX_GMXX_RXX_INT_EN\r\n(index, interface));\r\nif (gmx_rx_int_reg.s.phy_dupx\r\n|| gmx_rx_int_reg.s.phy_link\r\n|| gmx_rx_int_reg.s.phy_spd) {\r\nstruct net_device *dev =\r\ncvm_oct_device[cvmx_helper_get_ipd_port\r\n(interface, index)];\r\nstruct octeon_ethernet *priv = netdev_priv(dev);\r\nif (dev &&\r\n!atomic_read(&cvm_oct_poll_queue_stopping))\r\nqueue_work(cvm_oct_poll_queue,\r\n&priv->port_work);\r\ngmx_rx_int_reg.u64 = 0;\r\ngmx_rx_int_reg.s.phy_dupx = 1;\r\ngmx_rx_int_reg.s.phy_link = 1;\r\ngmx_rx_int_reg.s.phy_spd = 1;\r\ncvmx_write_csr(CVMX_GMXX_RXX_INT_REG\r\n(index, interface),\r\ngmx_rx_int_reg.u64);\r\nreturn_status = IRQ_HANDLED;\r\n}\r\n}\r\n}\r\nif (rsl_int_blocks.s.gmx1) {\r\nint interface = 1;\r\nfor (index = 0;\r\nindex < cvmx_helper_ports_on_interface(interface);\r\nindex++) {\r\nunion cvmx_gmxx_rxx_int_reg gmx_rx_int_reg;\r\ngmx_rx_int_reg.u64 =\r\ncvmx_read_csr(CVMX_GMXX_RXX_INT_REG\r\n(index, interface));\r\ngmx_rx_int_reg.u64 &=\r\ncvmx_read_csr(CVMX_GMXX_RXX_INT_EN\r\n(index, interface));\r\nif (gmx_rx_int_reg.s.phy_dupx\r\n|| gmx_rx_int_reg.s.phy_link\r\n|| gmx_rx_int_reg.s.phy_spd) {\r\nstruct net_device *dev =\r\ncvm_oct_device[cvmx_helper_get_ipd_port\r\n(interface, index)];\r\nstruct octeon_ethernet *priv = netdev_priv(dev);\r\nif (dev &&\r\n!atomic_read(&cvm_oct_poll_queue_stopping))\r\nqueue_work(cvm_oct_poll_queue,\r\n&priv->port_work);\r\ngmx_rx_int_reg.u64 = 0;\r\ngmx_rx_int_reg.s.phy_dupx = 1;\r\ngmx_rx_int_reg.s.phy_link = 1;\r\ngmx_rx_int_reg.s.phy_spd = 1;\r\ncvmx_write_csr(CVMX_GMXX_RXX_INT_REG\r\n(index, interface),\r\ngmx_rx_int_reg.u64);\r\nreturn_status = IRQ_HANDLED;\r\n}\r\n}\r\n}\r\nreturn return_status;\r\n}\r\nint cvm_oct_rgmii_open(struct net_device *dev)\r\n{\r\nunion cvmx_gmxx_prtx_cfg gmx_cfg;\r\nstruct octeon_ethernet *priv = netdev_priv(dev);\r\nint interface = INTERFACE(priv->port);\r\nint index = INDEX(priv->port);\r\ncvmx_helper_link_info_t link_info;\r\ngmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));\r\ngmx_cfg.s.en = 1;\r\ncvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmx_cfg.u64);\r\nif (!octeon_is_simulation()) {\r\nlink_info = cvmx_helper_link_get(priv->port);\r\nif (!link_info.s.link_up)\r\nnetif_carrier_off(dev);\r\n}\r\nreturn 0;\r\n}\r\nint cvm_oct_rgmii_stop(struct net_device *dev)\r\n{\r\nunion cvmx_gmxx_prtx_cfg gmx_cfg;\r\nstruct octeon_ethernet *priv = netdev_priv(dev);\r\nint interface = INTERFACE(priv->port);\r\nint index = INDEX(priv->port);\r\ngmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));\r\ngmx_cfg.s.en = 0;\r\ncvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmx_cfg.u64);\r\nreturn 0;\r\n}\r\nstatic void cvm_oct_rgmii_immediate_poll(struct work_struct *work)\r\n{\r\nstruct octeon_ethernet *priv =\r\ncontainer_of(work, struct octeon_ethernet, port_work);\r\ncvm_oct_rgmii_poll(cvm_oct_device[priv->port]);\r\n}\r\nint cvm_oct_rgmii_init(struct net_device *dev)\r\n{\r\nstruct octeon_ethernet *priv = netdev_priv(dev);\r\nint r;\r\ncvm_oct_common_init(dev);\r\ndev->netdev_ops->ndo_stop(dev);\r\nINIT_WORK(&priv->port_work, cvm_oct_rgmii_immediate_poll);\r\nif (number_rgmii_ports == 0) {\r\nr = request_irq(OCTEON_IRQ_RML, cvm_oct_rgmii_rml_interrupt,\r\nIRQF_SHARED, "RGMII", &number_rgmii_ports);\r\nif (r != 0)\r\nreturn r;\r\n}\r\nnumber_rgmii_ports++;\r\nif (((priv->imode == CVMX_HELPER_INTERFACE_MODE_GMII)\r\n&& (priv->port == 0))\r\n|| (priv->imode == CVMX_HELPER_INTERFACE_MODE_RGMII)) {\r\nif (!octeon_is_simulation()) {\r\nunion cvmx_gmxx_rxx_int_en gmx_rx_int_en;\r\nint interface = INTERFACE(priv->port);\r\nint index = INDEX(priv->port);\r\ngmx_rx_int_en.u64 = 0;\r\ngmx_rx_int_en.s.phy_dupx = 1;\r\ngmx_rx_int_en.s.phy_link = 1;\r\ngmx_rx_int_en.s.phy_spd = 1;\r\ncvmx_write_csr(CVMX_GMXX_RXX_INT_EN(index, interface),\r\ngmx_rx_int_en.u64);\r\npriv->poll = cvm_oct_rgmii_poll;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid cvm_oct_rgmii_uninit(struct net_device *dev)\r\n{\r\nstruct octeon_ethernet *priv = netdev_priv(dev);\r\ncvm_oct_common_uninit(dev);\r\nif (((priv->imode == CVMX_HELPER_INTERFACE_MODE_GMII)\r\n&& (priv->port == 0))\r\n|| (priv->imode == CVMX_HELPER_INTERFACE_MODE_RGMII)) {\r\nif (!octeon_is_simulation()) {\r\nunion cvmx_gmxx_rxx_int_en gmx_rx_int_en;\r\nint interface = INTERFACE(priv->port);\r\nint index = INDEX(priv->port);\r\ngmx_rx_int_en.u64 =\r\ncvmx_read_csr(CVMX_GMXX_RXX_INT_EN\r\n(index, interface));\r\ngmx_rx_int_en.s.phy_dupx = 0;\r\ngmx_rx_int_en.s.phy_link = 0;\r\ngmx_rx_int_en.s.phy_spd = 0;\r\ncvmx_write_csr(CVMX_GMXX_RXX_INT_EN(index, interface),\r\ngmx_rx_int_en.u64);\r\n}\r\n}\r\nnumber_rgmii_ports--;\r\nif (number_rgmii_ports == 0)\r\nfree_irq(OCTEON_IRQ_RML, &number_rgmii_ports);\r\ncancel_work_sync(&priv->port_work);\r\n}
