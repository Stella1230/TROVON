static void\r\nanslcd_write_byte_ctrl ( unsigned char c )\r\n{\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "LCD: CTRL byte: %02x\n",c);\r\n#endif\r\nout_8(anslcd_ptr + ANSLCD_CTRL_IX, c);\r\nswitch(c) {\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nudelay(anslcd_long_delay); break;\r\ndefault: udelay(anslcd_short_delay);\r\n}\r\n}\r\nstatic void\r\nanslcd_write_byte_data ( unsigned char c )\r\n{\r\nout_8(anslcd_ptr + ANSLCD_DATA_IX, c);\r\nudelay(anslcd_short_delay);\r\n}\r\nstatic ssize_t\r\nanslcd_write( struct file * file, const char __user * buf,\r\nsize_t count, loff_t *ppos )\r\n{\r\nconst char __user *p = buf;\r\nint i;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "LCD: write\n");\r\n#endif\r\nif (!access_ok(VERIFY_READ, buf, count))\r\nreturn -EFAULT;\r\nmutex_lock(&anslcd_mutex);\r\nfor ( i = *ppos; count > 0; ++i, ++p, --count )\r\n{\r\nchar c;\r\n__get_user(c, p);\r\nanslcd_write_byte_data( c );\r\n}\r\nmutex_unlock(&anslcd_mutex);\r\n*ppos = i;\r\nreturn p - buf;\r\n}\r\nstatic long\r\nanslcd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nchar ch, __user *temp;\r\nlong ret = 0;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "LCD: ioctl(%d,%d)\n",cmd,arg);\r\n#endif\r\nmutex_lock(&anslcd_mutex);\r\nswitch ( cmd )\r\n{\r\ncase ANSLCD_CLEAR:\r\nanslcd_write_byte_ctrl ( 0x38 );\r\nanslcd_write_byte_ctrl ( 0x0f );\r\nanslcd_write_byte_ctrl ( 0x06 );\r\nanslcd_write_byte_ctrl ( 0x01 );\r\nanslcd_write_byte_ctrl ( 0x02 );\r\nbreak;\r\ncase ANSLCD_SENDCTRL:\r\ntemp = (char __user *) arg;\r\n__get_user(ch, temp);\r\nfor (; ch; temp++) {\r\nanslcd_write_byte_ctrl ( ch );\r\n__get_user(ch, temp);\r\n}\r\nbreak;\r\ncase ANSLCD_SETSHORTDELAY:\r\nif (!capable(CAP_SYS_ADMIN))\r\nret =-EACCES;\r\nelse\r\nanslcd_short_delay=arg;\r\nbreak;\r\ncase ANSLCD_SETLONGDELAY:\r\nif (!capable(CAP_SYS_ADMIN))\r\nret = -EACCES;\r\nelse\r\nanslcd_long_delay=arg;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&anslcd_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nanslcd_open( struct inode * inode, struct file * file )\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init\r\nanslcd_init(void)\r\n{\r\nint a;\r\nint retval;\r\nstruct device_node* node;\r\nnode = of_find_node_by_name(NULL, "lcd");\r\nif (!node || !node->parent || strcmp(node->parent->name, "gc")) {\r\nof_node_put(node);\r\nreturn -ENODEV;\r\n}\r\nof_node_put(node);\r\nanslcd_ptr = ioremap(ANSLCD_ADDR, 0x20);\r\nretval = misc_register(&anslcd_dev);\r\nif(retval < 0){\r\nprintk(KERN_INFO "LCD: misc_register failed\n");\r\niounmap(anslcd_ptr);\r\nreturn retval;\r\n}\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "LCD: init\n");\r\n#endif\r\nmutex_lock(&anslcd_mutex);\r\nanslcd_write_byte_ctrl ( 0x38 );\r\nanslcd_write_byte_ctrl ( 0x0c );\r\nanslcd_write_byte_ctrl ( 0x06 );\r\nanslcd_write_byte_ctrl ( 0x01 );\r\nanslcd_write_byte_ctrl ( 0x02 );\r\nfor(a=0;a<80;a++) {\r\nanslcd_write_byte_data(anslcd_logo[a]);\r\n}\r\nmutex_unlock(&anslcd_mutex);\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nanslcd_exit(void)\r\n{\r\nmisc_deregister(&anslcd_dev);\r\niounmap(anslcd_ptr);\r\n}
