static inline int tcp_probe_used(void)\r\n{\r\nreturn (tcp_probe.head - tcp_probe.tail) & (bufsize - 1);\r\n}\r\nstatic inline int tcp_probe_avail(void)\r\n{\r\nreturn bufsize - tcp_probe_used() - 1;\r\n}\r\nstatic void jtcp_rcv_established(struct sock *sk, struct sk_buff *skb,\r\nconst struct tcphdr *th, unsigned int len)\r\n{\r\nconst struct tcp_sock *tp = tcp_sk(sk);\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nif (((port == 0 && fwmark == 0) ||\r\nntohs(inet->inet_dport) == port ||\r\nntohs(inet->inet_sport) == port ||\r\n(fwmark > 0 && skb->mark == fwmark)) &&\r\n(full || tp->snd_cwnd != tcp_probe.lastcwnd)) {\r\nspin_lock(&tcp_probe.lock);\r\nif (tcp_probe_avail() > 1) {\r\nstruct tcp_log *p = tcp_probe.log + tcp_probe.head;\r\np->tstamp = ktime_get();\r\nswitch (sk->sk_family) {\r\ncase AF_INET:\r\ntcp_probe_copy_fl_to_si4(inet, p->src.v4, s);\r\ntcp_probe_copy_fl_to_si4(inet, p->dst.v4, d);\r\nbreak;\r\ncase AF_INET6:\r\nmemset(&p->src.v6, 0, sizeof(p->src.v6));\r\nmemset(&p->dst.v6, 0, sizeof(p->dst.v6));\r\n#if IS_ENABLED(CONFIG_IPV6)\r\np->src.v6.sin6_family = AF_INET6;\r\np->src.v6.sin6_port = inet->inet_sport;\r\np->src.v6.sin6_addr = inet6_sk(sk)->saddr;\r\np->dst.v6.sin6_family = AF_INET6;\r\np->dst.v6.sin6_port = inet->inet_dport;\r\np->dst.v6.sin6_addr = sk->sk_v6_daddr;\r\n#endif\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\np->length = skb->len;\r\np->snd_nxt = tp->snd_nxt;\r\np->snd_una = tp->snd_una;\r\np->snd_cwnd = tp->snd_cwnd;\r\np->snd_wnd = tp->snd_wnd;\r\np->rcv_wnd = tp->rcv_wnd;\r\np->ssthresh = tcp_current_ssthresh(sk);\r\np->srtt = tp->srtt_us >> 3;\r\ntcp_probe.head = (tcp_probe.head + 1) & (bufsize - 1);\r\n}\r\ntcp_probe.lastcwnd = tp->snd_cwnd;\r\nspin_unlock(&tcp_probe.lock);\r\nwake_up(&tcp_probe.wait);\r\n}\r\njprobe_return();\r\n}\r\nstatic int tcpprobe_open(struct inode *inode, struct file *file)\r\n{\r\nspin_lock_bh(&tcp_probe.lock);\r\ntcp_probe.head = tcp_probe.tail = 0;\r\ntcp_probe.start = ktime_get();\r\nspin_unlock_bh(&tcp_probe.lock);\r\nreturn 0;\r\n}\r\nstatic int tcpprobe_sprint(char *tbuf, int n)\r\n{\r\nconst struct tcp_log *p\r\n= tcp_probe.log + tcp_probe.tail;\r\nstruct timespec tv\r\n= ktime_to_timespec(ktime_sub(p->tstamp, tcp_probe.start));\r\nreturn scnprintf(tbuf, n,\r\n"%lu.%09lu %pISpc %pISpc %d %#x %#x %u %u %u %u %u\n",\r\n(unsigned long) tv.tv_sec,\r\n(unsigned long) tv.tv_nsec,\r\n&p->src, &p->dst, p->length, p->snd_nxt, p->snd_una,\r\np->snd_cwnd, p->ssthresh, p->snd_wnd, p->srtt, p->rcv_wnd);\r\n}\r\nstatic ssize_t tcpprobe_read(struct file *file, char __user *buf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nint error = 0;\r\nsize_t cnt = 0;\r\nif (!buf)\r\nreturn -EINVAL;\r\nwhile (cnt < len) {\r\nchar tbuf[256];\r\nint width;\r\nerror = wait_event_interruptible(tcp_probe.wait,\r\ntcp_probe_used() > 0);\r\nif (error)\r\nbreak;\r\nspin_lock_bh(&tcp_probe.lock);\r\nif (tcp_probe.head == tcp_probe.tail) {\r\nspin_unlock_bh(&tcp_probe.lock);\r\ncontinue;\r\n}\r\nwidth = tcpprobe_sprint(tbuf, sizeof(tbuf));\r\nif (cnt + width < len)\r\ntcp_probe.tail = (tcp_probe.tail + 1) & (bufsize - 1);\r\nspin_unlock_bh(&tcp_probe.lock);\r\nif (cnt + width >= len)\r\nbreak;\r\nif (copy_to_user(buf + cnt, tbuf, width))\r\nreturn -EFAULT;\r\ncnt += width;\r\n}\r\nreturn cnt == 0 ? error : cnt;\r\n}\r\nstatic __init int tcpprobe_init(void)\r\n{\r\nint ret = -ENOMEM;\r\nBUILD_BUG_ON(__same_type(tcp_rcv_established,\r\njtcp_rcv_established) == 0);\r\ninit_waitqueue_head(&tcp_probe.wait);\r\nspin_lock_init(&tcp_probe.lock);\r\nif (bufsize == 0)\r\nreturn -EINVAL;\r\nbufsize = roundup_pow_of_two(bufsize);\r\ntcp_probe.log = kcalloc(bufsize, sizeof(struct tcp_log), GFP_KERNEL);\r\nif (!tcp_probe.log)\r\ngoto err0;\r\nif (!proc_create(procname, S_IRUSR, init_net.proc_net, &tcpprobe_fops))\r\ngoto err0;\r\nret = register_jprobe(&tcp_jprobe);\r\nif (ret)\r\ngoto err1;\r\npr_info("probe registered (port=%d/fwmark=%u) bufsize=%u\n",\r\nport, fwmark, bufsize);\r\nreturn 0;\r\nerr1:\r\nremove_proc_entry(procname, init_net.proc_net);\r\nerr0:\r\nkfree(tcp_probe.log);\r\nreturn ret;\r\n}\r\nstatic __exit void tcpprobe_exit(void)\r\n{\r\nremove_proc_entry(procname, init_net.proc_net);\r\nunregister_jprobe(&tcp_jprobe);\r\nkfree(tcp_probe.log);\r\n}
