int snd_seq_queue_get_cur_queues(void)\r\n{\r\nreturn num_queues;\r\n}\r\nstatic int queue_list_add(struct snd_seq_queue *q)\r\n{\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue_list_lock, flags);\r\nfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\r\nif (! queue_list[i]) {\r\nqueue_list[i] = q;\r\nq->queue = i;\r\nnum_queues++;\r\nspin_unlock_irqrestore(&queue_list_lock, flags);\r\nreturn i;\r\n}\r\n}\r\nspin_unlock_irqrestore(&queue_list_lock, flags);\r\nreturn -1;\r\n}\r\nstatic struct snd_seq_queue *queue_list_remove(int id, int client)\r\n{\r\nstruct snd_seq_queue *q;\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue_list_lock, flags);\r\nq = queue_list[id];\r\nif (q) {\r\nspin_lock(&q->owner_lock);\r\nif (q->owner == client) {\r\nq->klocked = 1;\r\nspin_unlock(&q->owner_lock);\r\nqueue_list[id] = NULL;\r\nnum_queues--;\r\nspin_unlock_irqrestore(&queue_list_lock, flags);\r\nreturn q;\r\n}\r\nspin_unlock(&q->owner_lock);\r\n}\r\nspin_unlock_irqrestore(&queue_list_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic struct snd_seq_queue *queue_new(int owner, int locked)\r\n{\r\nstruct snd_seq_queue *q;\r\nq = kzalloc(sizeof(*q), GFP_KERNEL);\r\nif (q == NULL) {\r\npr_debug("ALSA: seq: malloc failed for snd_seq_queue_new()\n");\r\nreturn NULL;\r\n}\r\nspin_lock_init(&q->owner_lock);\r\nspin_lock_init(&q->check_lock);\r\nmutex_init(&q->timer_mutex);\r\nsnd_use_lock_init(&q->use_lock);\r\nq->queue = -1;\r\nq->tickq = snd_seq_prioq_new();\r\nq->timeq = snd_seq_prioq_new();\r\nq->timer = snd_seq_timer_new();\r\nif (q->tickq == NULL || q->timeq == NULL || q->timer == NULL) {\r\nsnd_seq_prioq_delete(&q->tickq);\r\nsnd_seq_prioq_delete(&q->timeq);\r\nsnd_seq_timer_delete(&q->timer);\r\nkfree(q);\r\nreturn NULL;\r\n}\r\nq->owner = owner;\r\nq->locked = locked;\r\nq->klocked = 0;\r\nreturn q;\r\n}\r\nstatic void queue_delete(struct snd_seq_queue *q)\r\n{\r\nsnd_seq_timer_stop(q->timer);\r\nsnd_seq_timer_close(q);\r\nsnd_use_lock_sync(&q->use_lock);\r\nsnd_seq_prioq_delete(&q->tickq);\r\nsnd_seq_prioq_delete(&q->timeq);\r\nsnd_seq_timer_delete(&q->timer);\r\nkfree(q);\r\n}\r\nint __init snd_seq_queues_init(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid __exit snd_seq_queues_delete(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\r\nif (queue_list[i])\r\nqueue_delete(queue_list[i]);\r\n}\r\n}\r\nint snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)\r\n{\r\nstruct snd_seq_queue *q;\r\nq = queue_new(client, locked);\r\nif (q == NULL)\r\nreturn -ENOMEM;\r\nq->info_flags = info_flags;\r\nif (queue_list_add(q) < 0) {\r\nqueue_delete(q);\r\nreturn -ENOMEM;\r\n}\r\nsnd_seq_queue_use(q->queue, client, 1);\r\nreturn q->queue;\r\n}\r\nint snd_seq_queue_delete(int client, int queueid)\r\n{\r\nstruct snd_seq_queue *q;\r\nif (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)\r\nreturn -EINVAL;\r\nq = queue_list_remove(queueid, client);\r\nif (q == NULL)\r\nreturn -EINVAL;\r\nqueue_delete(q);\r\nreturn 0;\r\n}\r\nstruct snd_seq_queue *queueptr(int queueid)\r\n{\r\nstruct snd_seq_queue *q;\r\nunsigned long flags;\r\nif (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)\r\nreturn NULL;\r\nspin_lock_irqsave(&queue_list_lock, flags);\r\nq = queue_list[queueid];\r\nif (q)\r\nsnd_use_lock_use(&q->use_lock);\r\nspin_unlock_irqrestore(&queue_list_lock, flags);\r\nreturn q;\r\n}\r\nstruct snd_seq_queue *snd_seq_queue_find_name(char *name)\r\n{\r\nint i;\r\nstruct snd_seq_queue *q;\r\nfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\r\nif ((q = queueptr(i)) != NULL) {\r\nif (strncmp(q->name, name, sizeof(q->name)) == 0)\r\nreturn q;\r\nqueuefree(q);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid snd_seq_check_queue(struct snd_seq_queue *q, int atomic, int hop)\r\n{\r\nunsigned long flags;\r\nstruct snd_seq_event_cell *cell;\r\nif (q == NULL)\r\nreturn;\r\nspin_lock_irqsave(&q->check_lock, flags);\r\nif (q->check_blocked) {\r\nq->check_again = 1;\r\nspin_unlock_irqrestore(&q->check_lock, flags);\r\nreturn;\r\n}\r\nq->check_blocked = 1;\r\nspin_unlock_irqrestore(&q->check_lock, flags);\r\n__again:\r\nwhile ((cell = snd_seq_prioq_cell_peek(q->tickq)) != NULL) {\r\nif (snd_seq_compare_tick_time(&q->timer->tick.cur_tick,\r\n&cell->event.time.tick)) {\r\ncell = snd_seq_prioq_cell_out(q->tickq);\r\nif (cell)\r\nsnd_seq_dispatch_event(cell, atomic, hop);\r\n} else {\r\nbreak;\r\n}\r\n}\r\nwhile ((cell = snd_seq_prioq_cell_peek(q->timeq)) != NULL) {\r\nif (snd_seq_compare_real_time(&q->timer->cur_time,\r\n&cell->event.time.time)) {\r\ncell = snd_seq_prioq_cell_out(q->timeq);\r\nif (cell)\r\nsnd_seq_dispatch_event(cell, atomic, hop);\r\n} else {\r\nbreak;\r\n}\r\n}\r\nspin_lock_irqsave(&q->check_lock, flags);\r\nif (q->check_again) {\r\nq->check_again = 0;\r\nspin_unlock_irqrestore(&q->check_lock, flags);\r\ngoto __again;\r\n}\r\nq->check_blocked = 0;\r\nspin_unlock_irqrestore(&q->check_lock, flags);\r\n}\r\nint snd_seq_enqueue_event(struct snd_seq_event_cell *cell, int atomic, int hop)\r\n{\r\nint dest, err;\r\nstruct snd_seq_queue *q;\r\nif (snd_BUG_ON(!cell))\r\nreturn -EINVAL;\r\ndest = cell->event.queue;\r\nq = queueptr(dest);\r\nif (q == NULL)\r\nreturn -EINVAL;\r\nif ((cell->event.flags & SNDRV_SEQ_TIME_MODE_MASK) == SNDRV_SEQ_TIME_MODE_REL) {\r\nswitch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {\r\ncase SNDRV_SEQ_TIME_STAMP_TICK:\r\ncell->event.time.tick += q->timer->tick.cur_tick;\r\nbreak;\r\ncase SNDRV_SEQ_TIME_STAMP_REAL:\r\nsnd_seq_inc_real_time(&cell->event.time.time,\r\n&q->timer->cur_time);\r\nbreak;\r\n}\r\ncell->event.flags &= ~SNDRV_SEQ_TIME_MODE_MASK;\r\ncell->event.flags |= SNDRV_SEQ_TIME_MODE_ABS;\r\n}\r\nswitch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {\r\ncase SNDRV_SEQ_TIME_STAMP_TICK:\r\nerr = snd_seq_prioq_cell_in(q->tickq, cell);\r\nbreak;\r\ncase SNDRV_SEQ_TIME_STAMP_REAL:\r\ndefault:\r\nerr = snd_seq_prioq_cell_in(q->timeq, cell);\r\nbreak;\r\n}\r\nif (err < 0) {\r\nqueuefree(q);\r\nreturn err;\r\n}\r\nsnd_seq_check_queue(q, atomic, hop);\r\nqueuefree(q);\r\nreturn 0;\r\n}\r\nstatic inline int check_access(struct snd_seq_queue *q, int client)\r\n{\r\nreturn (q->owner == client) || (!q->locked && !q->klocked);\r\n}\r\nstatic int queue_access_lock(struct snd_seq_queue *q, int client)\r\n{\r\nunsigned long flags;\r\nint access_ok;\r\nspin_lock_irqsave(&q->owner_lock, flags);\r\naccess_ok = check_access(q, client);\r\nif (access_ok)\r\nq->klocked = 1;\r\nspin_unlock_irqrestore(&q->owner_lock, flags);\r\nreturn access_ok;\r\n}\r\nstatic inline void queue_access_unlock(struct snd_seq_queue *q)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&q->owner_lock, flags);\r\nq->klocked = 0;\r\nspin_unlock_irqrestore(&q->owner_lock, flags);\r\n}\r\nint snd_seq_queue_check_access(int queueid, int client)\r\n{\r\nstruct snd_seq_queue *q = queueptr(queueid);\r\nint access_ok;\r\nunsigned long flags;\r\nif (! q)\r\nreturn 0;\r\nspin_lock_irqsave(&q->owner_lock, flags);\r\naccess_ok = check_access(q, client);\r\nspin_unlock_irqrestore(&q->owner_lock, flags);\r\nqueuefree(q);\r\nreturn access_ok;\r\n}\r\nint snd_seq_queue_set_owner(int queueid, int client, int locked)\r\n{\r\nstruct snd_seq_queue *q = queueptr(queueid);\r\nif (q == NULL)\r\nreturn -EINVAL;\r\nif (! queue_access_lock(q, client)) {\r\nqueuefree(q);\r\nreturn -EPERM;\r\n}\r\nq->locked = locked ? 1 : 0;\r\nq->owner = client;\r\nqueue_access_unlock(q);\r\nqueuefree(q);\r\nreturn 0;\r\n}\r\nint snd_seq_queue_timer_open(int queueid)\r\n{\r\nint result = 0;\r\nstruct snd_seq_queue *queue;\r\nstruct snd_seq_timer *tmr;\r\nqueue = queueptr(queueid);\r\nif (queue == NULL)\r\nreturn -EINVAL;\r\ntmr = queue->timer;\r\nif ((result = snd_seq_timer_open(queue)) < 0) {\r\nsnd_seq_timer_defaults(tmr);\r\nresult = snd_seq_timer_open(queue);\r\n}\r\nqueuefree(queue);\r\nreturn result;\r\n}\r\nint snd_seq_queue_timer_close(int queueid)\r\n{\r\nstruct snd_seq_queue *queue;\r\nint result = 0;\r\nqueue = queueptr(queueid);\r\nif (queue == NULL)\r\nreturn -EINVAL;\r\nsnd_seq_timer_close(queue);\r\nqueuefree(queue);\r\nreturn result;\r\n}\r\nint snd_seq_queue_timer_set_tempo(int queueid, int client,\r\nstruct snd_seq_queue_tempo *info)\r\n{\r\nstruct snd_seq_queue *q = queueptr(queueid);\r\nint result;\r\nif (q == NULL)\r\nreturn -EINVAL;\r\nif (! queue_access_lock(q, client)) {\r\nqueuefree(q);\r\nreturn -EPERM;\r\n}\r\nresult = snd_seq_timer_set_tempo(q->timer, info->tempo);\r\nif (result >= 0)\r\nresult = snd_seq_timer_set_ppq(q->timer, info->ppq);\r\nif (result >= 0 && info->skew_base > 0)\r\nresult = snd_seq_timer_set_skew(q->timer, info->skew_value,\r\ninfo->skew_base);\r\nqueue_access_unlock(q);\r\nqueuefree(q);\r\nreturn result;\r\n}\r\nint snd_seq_queue_use(int queueid, int client, int use)\r\n{\r\nstruct snd_seq_queue *queue;\r\nqueue = queueptr(queueid);\r\nif (queue == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&queue->timer_mutex);\r\nif (use) {\r\nif (!test_and_set_bit(client, queue->clients_bitmap))\r\nqueue->clients++;\r\n} else {\r\nif (test_and_clear_bit(client, queue->clients_bitmap))\r\nqueue->clients--;\r\n}\r\nif (queue->clients) {\r\nif (use && queue->clients == 1)\r\nsnd_seq_timer_defaults(queue->timer);\r\nsnd_seq_timer_open(queue);\r\n} else {\r\nsnd_seq_timer_close(queue);\r\n}\r\nmutex_unlock(&queue->timer_mutex);\r\nqueuefree(queue);\r\nreturn 0;\r\n}\r\nint snd_seq_queue_is_used(int queueid, int client)\r\n{\r\nstruct snd_seq_queue *q;\r\nint result;\r\nq = queueptr(queueid);\r\nif (q == NULL)\r\nreturn -EINVAL;\r\nresult = test_bit(client, q->clients_bitmap) ? 1 : 0;\r\nqueuefree(q);\r\nreturn result;\r\n}\r\nvoid snd_seq_queue_client_termination(int client)\r\n{\r\nunsigned long flags;\r\nint i;\r\nstruct snd_seq_queue *q;\r\nfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\r\nif ((q = queueptr(i)) == NULL)\r\ncontinue;\r\nspin_lock_irqsave(&q->owner_lock, flags);\r\nif (q->owner == client)\r\nq->klocked = 1;\r\nspin_unlock_irqrestore(&q->owner_lock, flags);\r\nif (q->owner == client) {\r\nif (q->timer->running)\r\nsnd_seq_timer_stop(q->timer);\r\nsnd_seq_timer_reset(q->timer);\r\n}\r\nqueuefree(q);\r\n}\r\n}\r\nvoid snd_seq_queue_client_leave(int client)\r\n{\r\nint i;\r\nstruct snd_seq_queue *q;\r\nfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\r\nif ((q = queue_list_remove(i, client)) != NULL)\r\nqueue_delete(q);\r\n}\r\nfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\r\nif ((q = queueptr(i)) == NULL)\r\ncontinue;\r\nif (test_bit(client, q->clients_bitmap)) {\r\nsnd_seq_prioq_leave(q->tickq, client, 0);\r\nsnd_seq_prioq_leave(q->timeq, client, 0);\r\nsnd_seq_queue_use(q->queue, client, 0);\r\n}\r\nqueuefree(q);\r\n}\r\n}\r\nvoid snd_seq_queue_client_leave_cells(int client)\r\n{\r\nint i;\r\nstruct snd_seq_queue *q;\r\nfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\r\nif ((q = queueptr(i)) == NULL)\r\ncontinue;\r\nsnd_seq_prioq_leave(q->tickq, client, 0);\r\nsnd_seq_prioq_leave(q->timeq, client, 0);\r\nqueuefree(q);\r\n}\r\n}\r\nvoid snd_seq_queue_remove_cells(int client, struct snd_seq_remove_events *info)\r\n{\r\nint i;\r\nstruct snd_seq_queue *q;\r\nfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\r\nif ((q = queueptr(i)) == NULL)\r\ncontinue;\r\nif (test_bit(client, q->clients_bitmap) &&\r\n(! (info->remove_mode & SNDRV_SEQ_REMOVE_DEST) ||\r\nq->queue == info->queue)) {\r\nsnd_seq_prioq_remove_events(q->tickq, client, info);\r\nsnd_seq_prioq_remove_events(q->timeq, client, info);\r\n}\r\nqueuefree(q);\r\n}\r\n}\r\nstatic void queue_broadcast_event(struct snd_seq_queue *q, struct snd_seq_event *ev,\r\nint atomic, int hop)\r\n{\r\nstruct snd_seq_event sev;\r\nsev = *ev;\r\nsev.flags = SNDRV_SEQ_TIME_STAMP_TICK|SNDRV_SEQ_TIME_MODE_ABS;\r\nsev.time.tick = q->timer->tick.cur_tick;\r\nsev.queue = q->queue;\r\nsev.data.queue.queue = q->queue;\r\nsev.source.client = SNDRV_SEQ_CLIENT_SYSTEM;\r\nsev.source.port = SNDRV_SEQ_PORT_SYSTEM_TIMER;\r\nsev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\r\nsnd_seq_kernel_client_dispatch(SNDRV_SEQ_CLIENT_SYSTEM, &sev, atomic, hop);\r\n}\r\nstatic void snd_seq_queue_process_event(struct snd_seq_queue *q,\r\nstruct snd_seq_event *ev,\r\nint atomic, int hop)\r\n{\r\nswitch (ev->type) {\r\ncase SNDRV_SEQ_EVENT_START:\r\nsnd_seq_prioq_leave(q->tickq, ev->source.client, 1);\r\nsnd_seq_prioq_leave(q->timeq, ev->source.client, 1);\r\nif (! snd_seq_timer_start(q->timer))\r\nqueue_broadcast_event(q, ev, atomic, hop);\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_CONTINUE:\r\nif (! snd_seq_timer_continue(q->timer))\r\nqueue_broadcast_event(q, ev, atomic, hop);\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_STOP:\r\nsnd_seq_timer_stop(q->timer);\r\nqueue_broadcast_event(q, ev, atomic, hop);\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_TEMPO:\r\nsnd_seq_timer_set_tempo(q->timer, ev->data.queue.param.value);\r\nqueue_broadcast_event(q, ev, atomic, hop);\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_SETPOS_TICK:\r\nif (snd_seq_timer_set_position_tick(q->timer, ev->data.queue.param.time.tick) == 0) {\r\nqueue_broadcast_event(q, ev, atomic, hop);\r\n}\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_SETPOS_TIME:\r\nif (snd_seq_timer_set_position_time(q->timer, ev->data.queue.param.time.time) == 0) {\r\nqueue_broadcast_event(q, ev, atomic, hop);\r\n}\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_QUEUE_SKEW:\r\nif (snd_seq_timer_set_skew(q->timer,\r\nev->data.queue.param.skew.value,\r\nev->data.queue.param.skew.base) == 0) {\r\nqueue_broadcast_event(q, ev, atomic, hop);\r\n}\r\nbreak;\r\n}\r\n}\r\nint snd_seq_control_queue(struct snd_seq_event *ev, int atomic, int hop)\r\n{\r\nstruct snd_seq_queue *q;\r\nif (snd_BUG_ON(!ev))\r\nreturn -EINVAL;\r\nq = queueptr(ev->data.queue.queue);\r\nif (q == NULL)\r\nreturn -EINVAL;\r\nif (! queue_access_lock(q, ev->source.client)) {\r\nqueuefree(q);\r\nreturn -EPERM;\r\n}\r\nsnd_seq_queue_process_event(q, ev, atomic, hop);\r\nqueue_access_unlock(q);\r\nqueuefree(q);\r\nreturn 0;\r\n}\r\nvoid snd_seq_info_queues_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nint i, bpm;\r\nstruct snd_seq_queue *q;\r\nstruct snd_seq_timer *tmr;\r\nfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\r\nif ((q = queueptr(i)) == NULL)\r\ncontinue;\r\ntmr = q->timer;\r\nif (tmr->tempo)\r\nbpm = 60000000 / tmr->tempo;\r\nelse\r\nbpm = 0;\r\nsnd_iprintf(buffer, "queue %d: [%s]\n", q->queue, q->name);\r\nsnd_iprintf(buffer, "owned by client : %d\n", q->owner);\r\nsnd_iprintf(buffer, "lock status : %s\n", q->locked ? "Locked" : "Free");\r\nsnd_iprintf(buffer, "queued time events : %d\n", snd_seq_prioq_avail(q->timeq));\r\nsnd_iprintf(buffer, "queued tick events : %d\n", snd_seq_prioq_avail(q->tickq));\r\nsnd_iprintf(buffer, "timer state : %s\n", tmr->running ? "Running" : "Stopped");\r\nsnd_iprintf(buffer, "timer PPQ : %d\n", tmr->ppq);\r\nsnd_iprintf(buffer, "current tempo : %d\n", tmr->tempo);\r\nsnd_iprintf(buffer, "current BPM : %d\n", bpm);\r\nsnd_iprintf(buffer, "current time : %d.%09d s\n", tmr->cur_time.tv_sec, tmr->cur_time.tv_nsec);\r\nsnd_iprintf(buffer, "current tick : %d\n", tmr->tick.cur_tick);\r\nsnd_iprintf(buffer, "\n");\r\nqueuefree(q);\r\n}\r\n}
