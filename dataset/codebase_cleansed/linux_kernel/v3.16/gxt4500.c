static int calc_pll(int period_ps, struct gxt4500_par *par)\r\n{\r\nint m, n, pdiv1, pdiv2, postdiv;\r\nint pll_period, best_error, t, intf;\r\nif (period_ps < 3333 || period_ps > 200000)\r\nreturn -1;\r\nbest_error = 1000000;\r\nfor (pdiv1 = 1; pdiv1 <= 8; ++pdiv1) {\r\nfor (pdiv2 = 1; pdiv2 <= pdiv1; ++pdiv2) {\r\npostdiv = pdiv1 * pdiv2;\r\npll_period = DIV_ROUND_UP(period_ps, postdiv);\r\nif (pll_period < 1666 || pll_period > 2857)\r\ncontinue;\r\nfor (m = 1; m <= 64; ++m) {\r\nintf = m * par->refclk_ps;\r\nif (intf > 500000)\r\nbreak;\r\nn = intf * postdiv / period_ps;\r\nif (n < 3 || n > 160)\r\ncontinue;\r\nt = par->refclk_ps * m * postdiv / n;\r\nt -= period_ps;\r\nif (t >= 0 && t < best_error) {\r\npar->pll_m = m;\r\npar->pll_n = n;\r\npar->pll_pd1 = pdiv1;\r\npar->pll_pd2 = pdiv2;\r\nbest_error = t;\r\n}\r\n}\r\n}\r\n}\r\nif (best_error == 1000000)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int calc_pixclock(struct gxt4500_par *par)\r\n{\r\nreturn par->refclk_ps * par->pll_m * par->pll_pd1 * par->pll_pd2\r\n/ par->pll_n;\r\n}\r\nstatic int gxt4500_var_to_par(struct fb_var_screeninfo *var,\r\nstruct gxt4500_par *par)\r\n{\r\nif (var->xres + var->xoffset > var->xres_virtual ||\r\nvar->yres + var->yoffset > var->yres_virtual ||\r\nvar->xres_virtual > 4096)\r\nreturn -EINVAL;\r\nif ((var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\r\nreturn -EINVAL;\r\nif (calc_pll(var->pixclock, par) < 0)\r\nreturn -EINVAL;\r\nswitch (var->bits_per_pixel) {\r\ncase 32:\r\nif (var->transp.length)\r\npar->pixfmt = DFA_PIX_32BIT;\r\nelse\r\npar->pixfmt = DFA_PIX_24BIT;\r\nbreak;\r\ncase 24:\r\npar->pixfmt = DFA_PIX_24BIT;\r\nbreak;\r\ncase 16:\r\nif (var->green.length == 5)\r\npar->pixfmt = DFA_PIX_16BIT_1555;\r\nelse\r\npar->pixfmt = DFA_PIX_16BIT_565;\r\nbreak;\r\ncase 8:\r\npar->pixfmt = DFA_PIX_8BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gxt4500_unpack_pixfmt(struct fb_var_screeninfo *var,\r\nint pixfmt)\r\n{\r\nvar->bits_per_pixel = pixsize[pixfmt] * 8;\r\nvar->red = eightbits;\r\nvar->green = eightbits;\r\nvar->blue = eightbits;\r\nvar->transp = nobits;\r\nswitch (pixfmt) {\r\ncase DFA_PIX_16BIT_565:\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase DFA_PIX_16BIT_1555:\r\nvar->red.length = 5;\r\nvar->green.length = 5;\r\nvar->blue.length = 5;\r\nvar->transp.length = 1;\r\nbreak;\r\ncase DFA_PIX_32BIT:\r\nvar->transp.length = 8;\r\nbreak;\r\n}\r\nif (pixfmt != DFA_PIX_8BIT) {\r\nvar->green.offset = var->red.length;\r\nvar->blue.offset = var->green.offset + var->green.length;\r\nif (var->transp.length)\r\nvar->transp.offset =\r\nvar->blue.offset + var->blue.length;\r\n}\r\n}\r\nstatic int gxt4500_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct gxt4500_par par;\r\nint err;\r\npar = *(struct gxt4500_par *)info->par;\r\nerr = gxt4500_var_to_par(var, &par);\r\nif (!err) {\r\nvar->pixclock = calc_pixclock(&par);\r\ngxt4500_unpack_pixfmt(var, par.pixfmt);\r\n}\r\nreturn err;\r\n}\r\nstatic int gxt4500_set_par(struct fb_info *info)\r\n{\r\nstruct gxt4500_par *par = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nint err;\r\nu32 ctrlreg, tmp;\r\nunsigned int dfa_ctl, pixfmt, stride;\r\nunsigned int wid_tiles, i;\r\nunsigned int prefetch_pix, htot;\r\nstruct gxt4500_par save_par;\r\nsave_par = *par;\r\nerr = gxt4500_var_to_par(var, par);\r\nif (err) {\r\n*par = save_par;\r\nreturn err;\r\n}\r\nctrlreg = readreg(par, DTG_CONTROL);\r\nctrlreg &= ~(DTG_CTL_ENABLE | DTG_CTL_SCREEN_REFRESH);\r\nwritereg(par, DTG_CONTROL, ctrlreg);\r\ntmp = readreg(par, PLL_C) & ~0x7f;\r\nif (par->pll_n < 38)\r\ntmp |= 0x29;\r\nif (par->pll_n < 69)\r\ntmp |= 0x35;\r\nelse if (par->pll_n < 100)\r\ntmp |= 0x76;\r\nelse\r\ntmp |= 0x7e;\r\nwritereg(par, PLL_C, tmp);\r\nwritereg(par, PLL_M, mdivtab[par->pll_m - 1]);\r\nwritereg(par, PLL_N, ndivtab[par->pll_n - 2]);\r\ntmp = ((8 - par->pll_pd2) << 3) | (8 - par->pll_pd1);\r\nif (par->pll_pd1 == 8 || par->pll_pd2 == 8) {\r\nwritereg(par, PLL_POSTDIV, tmp | 0x9);\r\nudelay(1);\r\n}\r\nwritereg(par, PLL_POSTDIV, tmp);\r\nmsleep(20);\r\nwritereg(par, CURSOR_MODE, CURSOR_MODE_OFF);\r\nwritereg(par, CTRL_REG0, CR0_RASTER_RESET | (CR0_RASTER_RESET << 16));\r\nudelay(10);\r\nwritereg(par, CTRL_REG0, CR0_RASTER_RESET << 16);\r\nhtot = var->xres + var->left_margin + var->right_margin +\r\nvar->hsync_len;\r\nwritereg(par, DTG_HORIZ_EXTENT, htot - 1);\r\nwritereg(par, DTG_HORIZ_DISPLAY, var->xres - 1);\r\nwritereg(par, DTG_HSYNC_START, var->xres + var->right_margin - 1);\r\nwritereg(par, DTG_HSYNC_END,\r\nvar->xres + var->right_margin + var->hsync_len - 1);\r\nwritereg(par, DTG_HSYNC_END_COMP,\r\nvar->xres + var->right_margin + var->hsync_len - 1);\r\nwritereg(par, DTG_VERT_EXTENT,\r\nvar->yres + var->upper_margin + var->lower_margin +\r\nvar->vsync_len - 1);\r\nwritereg(par, DTG_VERT_DISPLAY, var->yres - 1);\r\nwritereg(par, DTG_VSYNC_START, var->yres + var->lower_margin - 1);\r\nwritereg(par, DTG_VSYNC_END,\r\nvar->yres + var->lower_margin + var->vsync_len - 1);\r\nprefetch_pix = 3300000 / var->pixclock;\r\nif (prefetch_pix >= htot)\r\nprefetch_pix = htot - 1;\r\nwritereg(par, DTG_VERT_SHORT, htot - prefetch_pix - 1);\r\nctrlreg |= DTG_CTL_ENABLE | DTG_CTL_SCREEN_REFRESH;\r\nwritereg(par, DTG_CONTROL, ctrlreg);\r\nif (var->xres_virtual > 2048) {\r\nstride = 4096;\r\ndfa_ctl = DFA_FB_STRIDE_4k;\r\n} else if (var->xres_virtual > 1024) {\r\nstride = 2048;\r\ndfa_ctl = DFA_FB_STRIDE_2k;\r\n} else {\r\nstride = 1024;\r\ndfa_ctl = DFA_FB_STRIDE_1k;\r\n}\r\nwid_tiles = (var->xres_virtual + 63) >> 6;\r\nwritereg(par, FB_AB_CTRL, FB_CTRL_TYPE | (wid_tiles << 16) | 0);\r\nwritereg(par, REFRESH_AB_CTRL, FB_CTRL_TYPE | (wid_tiles << 16) | 0);\r\nwritereg(par, FB_CD_CTRL, FB_CTRL_TYPE | (wid_tiles << 16) | 0);\r\nwritereg(par, REFRESH_CD_CTRL, FB_CTRL_TYPE | (wid_tiles << 16) | 0);\r\nwritereg(par, REFRESH_START, (var->xoffset << 16) | var->yoffset);\r\nwritereg(par, REFRESH_SIZE, (var->xres << 16) | var->yres);\r\npixfmt = par->pixfmt;\r\ndfa_ctl |= DFA_FB_ENABLE | pixfmt;\r\nwritereg(par, DFA_FB_A, dfa_ctl);\r\nfor (i = 0; i < 32; ++i) {\r\nwritereg(par, WAT_FMT + (i << 4), watfmt[pixfmt]);\r\nwritereg(par, WAT_CMAP_OFFSET + (i << 4), 0);\r\nwritereg(par, WAT_CTRL + (i << 4), 0);\r\nwritereg(par, WAT_GAMMA_CTRL + (i << 4), WAT_GAMMA_DISABLE);\r\n}\r\nctrlreg = readreg(par, SYNC_CTL) &\r\n~(SYNC_CTL_SYNC_ON_RGB | SYNC_CTL_HSYNC_INV |\r\nSYNC_CTL_VSYNC_INV);\r\nif (var->sync & FB_SYNC_ON_GREEN)\r\nctrlreg |= SYNC_CTL_SYNC_ON_RGB;\r\nif (!(var->sync & FB_SYNC_HOR_HIGH_ACT))\r\nctrlreg |= SYNC_CTL_HSYNC_INV;\r\nif (!(var->sync & FB_SYNC_VERT_HIGH_ACT))\r\nctrlreg |= SYNC_CTL_VSYNC_INV;\r\nwritereg(par, SYNC_CTL, ctrlreg);\r\ninfo->fix.line_length = stride * pixsize[pixfmt];\r\ninfo->fix.visual = (pixfmt == DFA_PIX_8BIT)? FB_VISUAL_PSEUDOCOLOR:\r\nFB_VISUAL_DIRECTCOLOR;\r\nreturn 0;\r\n}\r\nstatic int gxt4500_setcolreg(unsigned int reg, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int transp, struct fb_info *info)\r\n{\r\nu32 cmap_entry;\r\nstruct gxt4500_par *par = info->par;\r\nif (reg > 1023)\r\nreturn 1;\r\ncmap_entry = ((transp & 0xff00) << 16) | ((red & 0xff00) << 8) |\r\n(green & 0xff00) | (blue >> 8);\r\nwritereg(par, CMAP + reg * 4, cmap_entry);\r\nif (reg < 16 && par->pixfmt != DFA_PIX_8BIT) {\r\nu32 *pal = info->pseudo_palette;\r\nu32 val = reg;\r\nswitch (par->pixfmt) {\r\ncase DFA_PIX_16BIT_565:\r\nval |= (reg << 11) | (reg << 6);\r\nbreak;\r\ncase DFA_PIX_16BIT_1555:\r\nval |= (reg << 10) | (reg << 5);\r\nbreak;\r\ncase DFA_PIX_32BIT:\r\nval |= (reg << 24);\r\ncase DFA_PIX_24BIT:\r\nval |= (reg << 16) | (reg << 8);\r\nbreak;\r\n}\r\npal[reg] = val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gxt4500_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct gxt4500_par *par = info->par;\r\nif (var->xoffset & 7)\r\nreturn -EINVAL;\r\nif (var->xoffset + info->var.xres > info->var.xres_virtual ||\r\nvar->yoffset + info->var.yres > info->var.yres_virtual)\r\nreturn -EINVAL;\r\nwritereg(par, REFRESH_START, (var->xoffset << 16) | var->yoffset);\r\nreturn 0;\r\n}\r\nstatic int gxt4500_blank(int blank, struct fb_info *info)\r\n{\r\nstruct gxt4500_par *par = info->par;\r\nint ctrl, dctl;\r\nctrl = readreg(par, SYNC_CTL);\r\nctrl &= ~(SYNC_CTL_SYNC_OFF | SYNC_CTL_HSYNC_OFF | SYNC_CTL_VSYNC_OFF);\r\ndctl = readreg(par, DISP_CTL);\r\ndctl |= DISP_CTL_OFF;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\ndctl &= ~DISP_CTL_OFF;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nctrl |= SYNC_CTL_SYNC_OFF;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nctrl |= SYNC_CTL_HSYNC_OFF;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nctrl |= SYNC_CTL_VSYNC_OFF;\r\nbreak;\r\ndefault: ;\r\n}\r\nwritereg(par, SYNC_CTL, ctrl);\r\nwritereg(par, DISP_CTL, dctl);\r\nreturn 0;\r\n}\r\nstatic int gxt4500_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err;\r\nunsigned long reg_phys, fb_phys;\r\nstruct gxt4500_par *par;\r\nstruct fb_info *info;\r\nstruct fb_var_screeninfo var;\r\nenum gxt_cards cardtype;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "gxt4500: cannot enable PCI device: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nreg_phys = pci_resource_start(pdev, 0);\r\nif (!request_mem_region(reg_phys, pci_resource_len(pdev, 0),\r\n"gxt4500 regs")) {\r\ndev_err(&pdev->dev, "gxt4500: cannot get registers\n");\r\ngoto err_nodev;\r\n}\r\nfb_phys = pci_resource_start(pdev, 1);\r\nif (!request_mem_region(fb_phys, pci_resource_len(pdev, 1),\r\n"gxt4500 FB")) {\r\ndev_err(&pdev->dev, "gxt4500: cannot get framebuffer\n");\r\ngoto err_free_regs;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct gxt4500_par), &pdev->dev);\r\nif (!info) {\r\ndev_err(&pdev->dev, "gxt4500: cannot alloc FB info record\n");\r\ngoto err_free_fb;\r\n}\r\npar = info->par;\r\ncardtype = ent->driver_data;\r\npar->refclk_ps = cardinfo[cardtype].refclk_ps;\r\ninfo->fix = gxt4500_fix;\r\nstrlcpy(info->fix.id, cardinfo[cardtype].cardname,\r\nsizeof(info->fix.id));\r\ninfo->pseudo_palette = par->pseudo_palette;\r\ninfo->fix.mmio_start = reg_phys;\r\npar->regs = pci_ioremap_bar(pdev, 0);\r\nif (!par->regs) {\r\ndev_err(&pdev->dev, "gxt4500: cannot map registers\n");\r\ngoto err_free_all;\r\n}\r\ninfo->fix.smem_start = fb_phys;\r\ninfo->fix.smem_len = pci_resource_len(pdev, 1);\r\ninfo->screen_base = pci_ioremap_bar(pdev, 1);\r\nif (!info->screen_base) {\r\ndev_err(&pdev->dev, "gxt4500: cannot map framebuffer\n");\r\ngoto err_unmap_regs;\r\n}\r\npci_set_drvdata(pdev, info);\r\npci_write_config_dword(pdev, CFG_ENDIAN0, 0x333300);\r\ninfo->fbops = &gxt4500_ops;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\nerr = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (err) {\r\ndev_err(&pdev->dev, "gxt4500: cannot allocate cmap\n");\r\ngoto err_unmap_all;\r\n}\r\ngxt4500_blank(FB_BLANK_UNBLANK, info);\r\nif (!fb_find_mode(&var, info, mode_option, NULL, 0, &defaultmode, 8)) {\r\ndev_err(&pdev->dev, "gxt4500: cannot find valid video mode\n");\r\ngoto err_free_cmap;\r\n}\r\ninfo->var = var;\r\nif (gxt4500_set_par(info)) {\r\nprintk(KERN_ERR "gxt4500: cannot set video mode\n");\r\ngoto err_free_cmap;\r\n}\r\nif (register_framebuffer(info) < 0) {\r\ndev_err(&pdev->dev, "gxt4500: cannot register framebuffer\n");\r\ngoto err_free_cmap;\r\n}\r\nfb_info(info, "%s frame buffer device\n", info->fix.id);\r\nreturn 0;\r\nerr_free_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_unmap_all:\r\niounmap(info->screen_base);\r\nerr_unmap_regs:\r\niounmap(par->regs);\r\nerr_free_all:\r\nframebuffer_release(info);\r\nerr_free_fb:\r\nrelease_mem_region(fb_phys, pci_resource_len(pdev, 1));\r\nerr_free_regs:\r\nrelease_mem_region(reg_phys, pci_resource_len(pdev, 0));\r\nerr_nodev:\r\nreturn -ENODEV;\r\n}\r\nstatic void gxt4500_remove(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct gxt4500_par *par;\r\nif (!info)\r\nreturn;\r\npar = info->par;\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\niounmap(par->regs);\r\niounmap(info->screen_base);\r\nrelease_mem_region(pci_resource_start(pdev, 0),\r\npci_resource_len(pdev, 0));\r\nrelease_mem_region(pci_resource_start(pdev, 1),\r\npci_resource_len(pdev, 1));\r\nframebuffer_release(info);\r\n}\r\nstatic int gxt4500_init(void)\r\n{\r\n#ifndef MODULE\r\nif (fb_get_options("gxt4500", &mode_option))\r\nreturn -ENODEV;\r\n#endif\r\nreturn pci_register_driver(&gxt4500_driver);\r\n}\r\nstatic void __exit gxt4500_exit(void)\r\n{\r\npci_unregister_driver(&gxt4500_driver);\r\n}
