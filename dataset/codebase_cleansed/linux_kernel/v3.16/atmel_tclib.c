struct atmel_tc *atmel_tc_alloc(unsigned block, const char *name)\r\n{\r\nstruct atmel_tc *tc;\r\nstruct platform_device *pdev = NULL;\r\nstruct resource *r;\r\nsize_t size;\r\nspin_lock(&tc_list_lock);\r\nlist_for_each_entry(tc, &tc_list, node) {\r\nif (tc->pdev->dev.of_node) {\r\nif (of_alias_get_id(tc->pdev->dev.of_node, "tcb")\r\n== block) {\r\npdev = tc->pdev;\r\nbreak;\r\n}\r\n} else if (tc->pdev->id == block) {\r\npdev = tc->pdev;\r\nbreak;\r\n}\r\n}\r\nif (!pdev || tc->iomem)\r\ngoto fail;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r)\r\ngoto fail;\r\nsize = resource_size(r);\r\nr = request_mem_region(r->start, size, name);\r\nif (!r)\r\ngoto fail;\r\ntc->regs = ioremap(r->start, size);\r\nif (!tc->regs)\r\ngoto fail_ioremap;\r\ntc->iomem = r;\r\nout:\r\nspin_unlock(&tc_list_lock);\r\nreturn tc;\r\nfail_ioremap:\r\nrelease_mem_region(r->start, size);\r\nfail:\r\ntc = NULL;\r\ngoto out;\r\n}\r\nvoid atmel_tc_free(struct atmel_tc *tc)\r\n{\r\nspin_lock(&tc_list_lock);\r\nif (tc->regs) {\r\niounmap(tc->regs);\r\nrelease_mem_region(tc->iomem->start, resource_size(tc->iomem));\r\ntc->regs = NULL;\r\ntc->iomem = NULL;\r\n}\r\nspin_unlock(&tc_list_lock);\r\n}\r\nstatic int __init tc_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_tc *tc;\r\nstruct clk *clk;\r\nint irq;\r\nif (!platform_get_resource(pdev, IORESOURCE_MEM, 0))\r\nreturn -EINVAL;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -EINVAL;\r\ntc = kzalloc(sizeof(struct atmel_tc), GFP_KERNEL);\r\nif (!tc)\r\nreturn -ENOMEM;\r\ntc->pdev = pdev;\r\nclk = clk_get(&pdev->dev, "t0_clk");\r\nif (IS_ERR(clk)) {\r\nkfree(tc);\r\nreturn -EINVAL;\r\n}\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(atmel_tcb_dt_ids, pdev->dev.of_node);\r\nif (match)\r\ntc->tcb_config = match->data;\r\n}\r\ntc->clk[0] = clk;\r\ntc->clk[1] = clk_get(&pdev->dev, "t1_clk");\r\nif (IS_ERR(tc->clk[1]))\r\ntc->clk[1] = clk;\r\ntc->clk[2] = clk_get(&pdev->dev, "t2_clk");\r\nif (IS_ERR(tc->clk[2]))\r\ntc->clk[2] = clk;\r\ntc->irq[0] = irq;\r\ntc->irq[1] = platform_get_irq(pdev, 1);\r\nif (tc->irq[1] < 0)\r\ntc->irq[1] = irq;\r\ntc->irq[2] = platform_get_irq(pdev, 2);\r\nif (tc->irq[2] < 0)\r\ntc->irq[2] = irq;\r\nspin_lock(&tc_list_lock);\r\nlist_add_tail(&tc->node, &tc_list);\r\nspin_unlock(&tc_list_lock);\r\nreturn 0;\r\n}\r\nstatic int __init tc_init(void)\r\n{\r\nreturn platform_driver_probe(&tc_driver, tc_probe);\r\n}
