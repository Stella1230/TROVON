static int twl4030_i2c_write_u8_verify(struct twl4030_usb *twl,\r\nu8 module, u8 data, u8 address)\r\n{\r\nu8 check;\r\nif ((twl_i2c_write_u8(module, data, address) >= 0) &&\r\n(twl_i2c_read_u8(module, &check, address) >= 0) &&\r\n(check == data))\r\nreturn 0;\r\ndev_dbg(twl->dev, "Write%d[%d,0x%x] wrote %02x but read %02x\n",\r\n1, module, address, check, data);\r\nif ((twl_i2c_write_u8(module, data, address) >= 0) &&\r\n(twl_i2c_read_u8(module, &check, address) >= 0) &&\r\n(check == data))\r\nreturn 0;\r\ndev_dbg(twl->dev, "Write%d[%d,0x%x] wrote %02x but read %02x\n",\r\n2, module, address, check, data);\r\nreturn -EBUSY;\r\n}\r\nstatic inline int twl4030_usb_write(struct twl4030_usb *twl,\r\nu8 address, u8 data)\r\n{\r\nint ret = 0;\r\nret = twl_i2c_write_u8(TWL_MODULE_USB, data, address);\r\nif (ret < 0)\r\ndev_dbg(twl->dev,\r\n"TWL4030:USB:Write[0x%x] Error %d\n", address, ret);\r\nreturn ret;\r\n}\r\nstatic inline int twl4030_readb(struct twl4030_usb *twl, u8 module, u8 address)\r\n{\r\nu8 data;\r\nint ret = 0;\r\nret = twl_i2c_read_u8(module, &data, address);\r\nif (ret >= 0)\r\nret = data;\r\nelse\r\ndev_dbg(twl->dev,\r\n"TWL4030:readb[0x%x,0x%x] Error %d\n",\r\nmodule, address, ret);\r\nreturn ret;\r\n}\r\nstatic inline int twl4030_usb_read(struct twl4030_usb *twl, u8 address)\r\n{\r\nreturn twl4030_readb(twl, TWL_MODULE_USB, address);\r\n}\r\nstatic inline int\r\ntwl4030_usb_set_bits(struct twl4030_usb *twl, u8 reg, u8 bits)\r\n{\r\nreturn twl4030_usb_write(twl, ULPI_SET(reg), bits);\r\n}\r\nstatic inline int\r\ntwl4030_usb_clear_bits(struct twl4030_usb *twl, u8 reg, u8 bits)\r\n{\r\nreturn twl4030_usb_write(twl, ULPI_CLR(reg), bits);\r\n}\r\nstatic bool twl4030_is_driving_vbus(struct twl4030_usb *twl)\r\n{\r\nint ret;\r\nret = twl4030_usb_read(twl, PHY_CLK_CTRL_STS);\r\nif (ret < 0 || !(ret & PHY_DPLL_CLK))\r\nreturn false;\r\nret = twl4030_usb_read(twl, ULPI_OTG_CTRL);\r\nif (ret < 0)\r\nreturn false;\r\nreturn (ret & (ULPI_OTG_DRVVBUS | ULPI_OTG_CHRGVBUS)) ? true : false;\r\n}\r\nstatic enum omap_musb_vbus_id_status\r\ntwl4030_usb_linkstat(struct twl4030_usb *twl)\r\n{\r\nint status;\r\nenum omap_musb_vbus_id_status linkstat = OMAP_MUSB_UNKNOWN;\r\ntwl->vbus_supplied = false;\r\nstatus = twl4030_readb(twl, TWL_MODULE_PM_MASTER, STS_HW_CONDITIONS);\r\nif (status < 0)\r\ndev_err(twl->dev, "USB link status err %d\n", status);\r\nelse if (status & (BIT(7) | BIT(2))) {\r\nif (status & BIT(7)) {\r\nif (twl4030_is_driving_vbus(twl))\r\nstatus &= ~BIT(7);\r\nelse\r\ntwl->vbus_supplied = true;\r\n}\r\nif (status & BIT(2))\r\nlinkstat = OMAP_MUSB_ID_GROUND;\r\nelse if (status & BIT(7))\r\nlinkstat = OMAP_MUSB_VBUS_VALID;\r\nelse\r\nlinkstat = OMAP_MUSB_VBUS_OFF;\r\n} else {\r\nif (twl->linkstat != OMAP_MUSB_UNKNOWN)\r\nlinkstat = OMAP_MUSB_VBUS_OFF;\r\n}\r\ndev_dbg(twl->dev, "HW_CONDITIONS 0x%02x/%d; link %d\n",\r\nstatus, status, linkstat);\r\nreturn linkstat;\r\n}\r\nstatic void twl4030_usb_set_mode(struct twl4030_usb *twl, int mode)\r\n{\r\ntwl->usb_mode = mode;\r\nswitch (mode) {\r\ncase T2_USB_MODE_ULPI:\r\ntwl4030_usb_clear_bits(twl, ULPI_IFC_CTRL,\r\nULPI_IFC_CTRL_CARKITMODE);\r\ntwl4030_usb_set_bits(twl, POWER_CTRL, POWER_CTRL_OTG_ENAB);\r\ntwl4030_usb_clear_bits(twl, ULPI_FUNC_CTRL,\r\nULPI_FUNC_CTRL_XCVRSEL_MASK |\r\nULPI_FUNC_CTRL_OPMODE_MASK);\r\nbreak;\r\ncase -1:\r\nbreak;\r\ndefault:\r\ndev_err(twl->dev, "unsupported T2 transceiver mode %d\n",\r\nmode);\r\nbreak;\r\n}\r\n}\r\nstatic void twl4030_i2c_access(struct twl4030_usb *twl, int on)\r\n{\r\nunsigned long timeout;\r\nint val = twl4030_usb_read(twl, PHY_CLK_CTRL);\r\nif (val >= 0) {\r\nif (on) {\r\nval |= REQ_PHY_DPLL_CLK;\r\nWARN_ON(twl4030_usb_write_verify(twl, PHY_CLK_CTRL,\r\n(u8)val) < 0);\r\ntimeout = jiffies + HZ;\r\nwhile (!(twl4030_usb_read(twl, PHY_CLK_CTRL_STS) &\r\nPHY_DPLL_CLK)\r\n&& time_before(jiffies, timeout))\r\nudelay(10);\r\nif (!(twl4030_usb_read(twl, PHY_CLK_CTRL_STS) &\r\nPHY_DPLL_CLK))\r\ndev_err(twl->dev, "Timeout setting T2 HSUSB "\r\n"PHY DPLL clock\n");\r\n} else {\r\nval &= ~REQ_PHY_DPLL_CLK;\r\nWARN_ON(twl4030_usb_write_verify(twl, PHY_CLK_CTRL,\r\n(u8)val) < 0);\r\n}\r\n}\r\n}\r\nstatic void __twl4030_phy_power(struct twl4030_usb *twl, int on)\r\n{\r\nu8 pwr = twl4030_usb_read(twl, PHY_PWR_CTRL);\r\nif (on)\r\npwr &= ~PHY_PWR_PHYPWD;\r\nelse\r\npwr |= PHY_PWR_PHYPWD;\r\nWARN_ON(twl4030_usb_write_verify(twl, PHY_PWR_CTRL, pwr) < 0);\r\n}\r\nstatic void twl4030_phy_power(struct twl4030_usb *twl, int on)\r\n{\r\nint ret;\r\nif (on) {\r\nret = regulator_enable(twl->usb3v1);\r\nif (ret)\r\ndev_err(twl->dev, "Failed to enable usb3v1\n");\r\nret = regulator_enable(twl->usb1v8);\r\nif (ret)\r\ndev_err(twl->dev, "Failed to enable usb1v8\n");\r\ntwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB_DEDICATED2);\r\nret = regulator_enable(twl->usb1v5);\r\nif (ret)\r\ndev_err(twl->dev, "Failed to enable usb1v5\n");\r\n__twl4030_phy_power(twl, 1);\r\ntwl4030_usb_write(twl, PHY_CLK_CTRL,\r\ntwl4030_usb_read(twl, PHY_CLK_CTRL) |\r\n(PHY_CLK_CTRL_CLOCKGATING_EN |\r\nPHY_CLK_CTRL_CLK32K_EN));\r\n} else {\r\n__twl4030_phy_power(twl, 0);\r\nregulator_disable(twl->usb1v5);\r\nregulator_disable(twl->usb1v8);\r\nregulator_disable(twl->usb3v1);\r\n}\r\n}\r\nstatic int twl4030_phy_power_off(struct phy *phy)\r\n{\r\nstruct twl4030_usb *twl = phy_get_drvdata(phy);\r\nif (twl->asleep)\r\nreturn 0;\r\ntwl4030_phy_power(twl, 0);\r\ntwl->asleep = 1;\r\ndev_dbg(twl->dev, "%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void __twl4030_phy_power_on(struct twl4030_usb *twl)\r\n{\r\ntwl4030_phy_power(twl, 1);\r\ntwl4030_i2c_access(twl, 1);\r\ntwl4030_usb_set_mode(twl, twl->usb_mode);\r\nif (twl->usb_mode == T2_USB_MODE_ULPI)\r\ntwl4030_i2c_access(twl, 0);\r\n}\r\nstatic int twl4030_phy_power_on(struct phy *phy)\r\n{\r\nstruct twl4030_usb *twl = phy_get_drvdata(phy);\r\nif (!twl->asleep)\r\nreturn 0;\r\n__twl4030_phy_power_on(twl);\r\ntwl->asleep = 0;\r\ndev_dbg(twl->dev, "%s\n", __func__);\r\nif (twl->linkstat == OMAP_MUSB_ID_GROUND) {\r\ncancel_delayed_work(&twl->id_workaround_work);\r\nschedule_delayed_work(&twl->id_workaround_work, HZ);\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_usb_ldo_init(struct twl4030_usb *twl)\r\n{\r\ntwl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG1,\r\nTWL4030_PM_MASTER_PROTECT_KEY);\r\ntwl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG2,\r\nTWL4030_PM_MASTER_PROTECT_KEY);\r\ntwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0x14, VUSB_DEDICATED1);\r\ntwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB3V1_DEV_GRP);\r\ntwl->usb3v1 = devm_regulator_get(twl->dev, "usb3v1");\r\nif (IS_ERR(twl->usb3v1))\r\nreturn -ENODEV;\r\ntwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB3V1_TYPE);\r\ntwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB1V5_DEV_GRP);\r\ntwl->usb1v5 = devm_regulator_get(twl->dev, "usb1v5");\r\nif (IS_ERR(twl->usb1v5))\r\nreturn -ENODEV;\r\ntwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB1V5_TYPE);\r\ntwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB1V8_DEV_GRP);\r\ntwl->usb1v8 = devm_regulator_get(twl->dev, "usb1v8");\r\nif (IS_ERR(twl->usb1v8))\r\nreturn -ENODEV;\r\ntwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB1V8_TYPE);\r\ntwl_i2c_write_u8(TWL_MODULE_PM_MASTER, 0,\r\nTWL4030_PM_MASTER_PROTECT_KEY);\r\nreturn 0;\r\n}\r\nstatic ssize_t twl4030_usb_vbus_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct twl4030_usb *twl = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&twl->lock, flags);\r\nret = sprintf(buf, "%s\n",\r\ntwl->vbus_supplied ? "on" : "off");\r\nspin_unlock_irqrestore(&twl->lock, flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t twl4030_usb_irq(int irq, void *_twl)\r\n{\r\nstruct twl4030_usb *twl = _twl;\r\nenum omap_musb_vbus_id_status status;\r\nbool status_changed = false;\r\nstatus = twl4030_usb_linkstat(twl);\r\nspin_lock_irq(&twl->lock);\r\nif (status >= 0 && status != twl->linkstat) {\r\ntwl->linkstat = status;\r\nstatus_changed = true;\r\n}\r\nspin_unlock_irq(&twl->lock);\r\nif (status_changed) {\r\nomap_musb_mailbox(status);\r\n}\r\nsysfs_notify(&twl->dev->kobj, NULL, "vbus");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void twl4030_id_workaround_work(struct work_struct *work)\r\n{\r\nstruct twl4030_usb *twl = container_of(work, struct twl4030_usb,\r\nid_workaround_work.work);\r\nenum omap_musb_vbus_id_status status;\r\nbool status_changed = false;\r\nstatus = twl4030_usb_linkstat(twl);\r\nspin_lock_irq(&twl->lock);\r\nif (status >= 0 && status != twl->linkstat) {\r\ntwl->linkstat = status;\r\nstatus_changed = true;\r\n}\r\nspin_unlock_irq(&twl->lock);\r\nif (status_changed) {\r\ndev_dbg(twl->dev, "handle missing status change to %d\n",\r\nstatus);\r\nomap_musb_mailbox(status);\r\n}\r\nif (status == OMAP_MUSB_ID_GROUND && !twl->asleep) {\r\ncancel_delayed_work(&twl->id_workaround_work);\r\nschedule_delayed_work(&twl->id_workaround_work, HZ);\r\n}\r\n}\r\nstatic int twl4030_phy_init(struct phy *phy)\r\n{\r\nstruct twl4030_usb *twl = phy_get_drvdata(phy);\r\nenum omap_musb_vbus_id_status status;\r\n__twl4030_phy_power(twl, 0);\r\ntwl->asleep = 1;\r\nstatus = twl4030_usb_linkstat(twl);\r\ntwl->linkstat = status;\r\nif (status == OMAP_MUSB_ID_GROUND || status == OMAP_MUSB_VBUS_VALID) {\r\nomap_musb_mailbox(twl->linkstat);\r\ntwl4030_phy_power_on(phy);\r\n}\r\nsysfs_notify(&twl->dev->kobj, NULL, "vbus");\r\nreturn 0;\r\n}\r\nstatic int twl4030_set_peripheral(struct usb_otg *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\nif (!otg)\r\nreturn -ENODEV;\r\notg->gadget = gadget;\r\nif (!gadget)\r\notg->phy->state = OTG_STATE_UNDEFINED;\r\nreturn 0;\r\n}\r\nstatic int twl4030_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nif (!otg)\r\nreturn -ENODEV;\r\notg->host = host;\r\nif (!host)\r\notg->phy->state = OTG_STATE_UNDEFINED;\r\nreturn 0;\r\n}\r\nstatic int twl4030_usb_probe(struct platform_device *pdev)\r\n{\r\nstruct twl4030_usb_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct twl4030_usb *twl;\r\nstruct phy *phy;\r\nint status, err;\r\nstruct usb_otg *otg;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct phy_provider *phy_provider;\r\nstruct phy_init_data *init_data = NULL;\r\ntwl = devm_kzalloc(&pdev->dev, sizeof(*twl), GFP_KERNEL);\r\nif (!twl)\r\nreturn -ENOMEM;\r\nif (np)\r\nof_property_read_u32(np, "usb_mode",\r\n(enum twl4030_usb_mode *)&twl->usb_mode);\r\nelse if (pdata) {\r\ntwl->usb_mode = pdata->usb_mode;\r\ninit_data = pdata->init_data;\r\n} else {\r\ndev_err(&pdev->dev, "twl4030 initialized without pdata\n");\r\nreturn -EINVAL;\r\n}\r\notg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\r\nif (!otg)\r\nreturn -ENOMEM;\r\ntwl->dev = &pdev->dev;\r\ntwl->irq = platform_get_irq(pdev, 0);\r\ntwl->vbus_supplied = false;\r\ntwl->asleep = 1;\r\ntwl->linkstat = OMAP_MUSB_UNKNOWN;\r\ntwl->phy.dev = twl->dev;\r\ntwl->phy.label = "twl4030";\r\ntwl->phy.otg = otg;\r\ntwl->phy.type = USB_PHY_TYPE_USB2;\r\notg->phy = &twl->phy;\r\notg->set_host = twl4030_set_host;\r\notg->set_peripheral = twl4030_set_peripheral;\r\nphy = devm_phy_create(twl->dev, &ops, init_data);\r\nif (IS_ERR(phy)) {\r\ndev_dbg(&pdev->dev, "Failed to create PHY\n");\r\nreturn PTR_ERR(phy);\r\n}\r\nphy_set_drvdata(phy, twl);\r\nphy_provider = devm_of_phy_provider_register(twl->dev,\r\nof_phy_simple_xlate);\r\nif (IS_ERR(phy_provider))\r\nreturn PTR_ERR(phy_provider);\r\nspin_lock_init(&twl->lock);\r\nINIT_DELAYED_WORK(&twl->id_workaround_work, twl4030_id_workaround_work);\r\nerr = twl4030_usb_ldo_init(twl);\r\nif (err) {\r\ndev_err(&pdev->dev, "ldo init failed\n");\r\nreturn err;\r\n}\r\nusb_add_phy_dev(&twl->phy);\r\nplatform_set_drvdata(pdev, twl);\r\nif (device_create_file(&pdev->dev, &dev_attr_vbus))\r\ndev_warn(&pdev->dev, "could not create sysfs file\n");\r\nATOMIC_INIT_NOTIFIER_HEAD(&twl->phy.notifier);\r\ntwl->irq_enabled = true;\r\nstatus = devm_request_threaded_irq(twl->dev, twl->irq, NULL,\r\ntwl4030_usb_irq, IRQF_TRIGGER_FALLING |\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT, "twl4030_usb", twl);\r\nif (status < 0) {\r\ndev_dbg(&pdev->dev, "can't get IRQ %d, err %d\n",\r\ntwl->irq, status);\r\nreturn status;\r\n}\r\ndev_info(&pdev->dev, "Initialized TWL4030 USB module\n");\r\nreturn 0;\r\n}\r\nstatic int twl4030_usb_remove(struct platform_device *pdev)\r\n{\r\nstruct twl4030_usb *twl = platform_get_drvdata(pdev);\r\nint val;\r\ncancel_delayed_work(&twl->id_workaround_work);\r\ndevice_remove_file(twl->dev, &dev_attr_vbus);\r\ntwl4030_usb_set_mode(twl, -1);\r\nval = twl4030_usb_read(twl, PHY_CLK_CTRL);\r\nif (val >= 0) {\r\nval |= PHY_CLK_CTRL_CLOCKGATING_EN;\r\nval &= ~(PHY_CLK_CTRL_CLK32K_EN | REQ_PHY_DPLL_CLK);\r\ntwl4030_usb_write(twl, PHY_CLK_CTRL, (u8)val);\r\n}\r\ntwl4030_usb_clear_bits(twl, POWER_CTRL, POWER_CTRL_OTG_ENAB);\r\nif (!twl->asleep)\r\ntwl4030_phy_power(twl, 0);\r\nreturn 0;\r\n}\r\nstatic int __init twl4030_usb_init(void)\r\n{\r\nreturn platform_driver_register(&twl4030_usb_driver);\r\n}\r\nstatic void __exit twl4030_usb_exit(void)\r\n{\r\nplatform_driver_unregister(&twl4030_usb_driver);\r\n}
