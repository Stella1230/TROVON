static u32 dsi_rr_formula(const struct drm_display_mode *mode,\r\nint pixel_format, int video_mode_format,\r\nint lane_count, bool eotp)\r\n{\r\nu32 bpp;\r\nu32 hactive, vactive, hfp, hsync, hbp, vfp, vsync, vbp;\r\nu32 hsync_bytes, hbp_bytes, hactive_bytes, hfp_bytes;\r\nu32 bytes_per_line, bytes_per_frame;\r\nu32 num_frames;\r\nu32 bytes_per_x_frames, bytes_per_x_frames_x_lanes;\r\nu32 dsi_bit_clock_hz;\r\nu32 dsi_clk;\r\nswitch (pixel_format) {\r\ndefault:\r\ncase VID_MODE_FORMAT_RGB888:\r\ncase VID_MODE_FORMAT_RGB666_LOOSE:\r\nbpp = 24;\r\nbreak;\r\ncase VID_MODE_FORMAT_RGB666:\r\nbpp = 18;\r\nbreak;\r\ncase VID_MODE_FORMAT_RGB565:\r\nbpp = 16;\r\nbreak;\r\n}\r\nhactive = mode->hdisplay;\r\nvactive = mode->vdisplay;\r\nhfp = mode->hsync_start - mode->hdisplay;\r\nhsync = mode->hsync_end - mode->hsync_start;\r\nhbp = mode->htotal - mode->hsync_end;\r\nvfp = mode->vsync_start - mode->vdisplay;\r\nvsync = mode->vsync_end - mode->vsync_start;\r\nvbp = mode->vtotal - mode->vsync_end;\r\nhsync_bytes = DIV_ROUND_UP(hsync * bpp, 8);\r\nhbp_bytes = DIV_ROUND_UP(hbp * bpp, 8);\r\nhactive_bytes = DIV_ROUND_UP(hactive * bpp, 8);\r\nhfp_bytes = DIV_ROUND_UP(hfp * bpp, 8);\r\nbytes_per_line = DSI_HSS_PACKET_SIZE + hsync_bytes +\r\nDSI_HSA_PACKET_EXTRA_SIZE + DSI_HSE_PACKET_SIZE +\r\nhbp_bytes + DSI_HBP_PACKET_EXTRA_SIZE +\r\nhactive_bytes + DSI_HACTIVE_PACKET_EXTRA_SIZE +\r\nhfp_bytes + DSI_HFP_PACKET_EXTRA_SIZE;\r\nif (eotp && video_mode_format == VIDEO_MODE_BURST)\r\nbytes_per_line += DSI_EOTP_PACKET_SIZE;\r\nbytes_per_frame = vsync * bytes_per_line + vbp * bytes_per_line +\r\nvactive * bytes_per_line + vfp * bytes_per_line;\r\nif (eotp &&\r\n(video_mode_format == VIDEO_MODE_NON_BURST_WITH_SYNC_PULSE ||\r\nvideo_mode_format == VIDEO_MODE_NON_BURST_WITH_SYNC_EVENTS))\r\nbytes_per_frame += DSI_EOTP_PACKET_SIZE;\r\nnum_frames = drm_mode_vrefresh(mode);\r\nbytes_per_x_frames = num_frames * bytes_per_frame;\r\nbytes_per_x_frames_x_lanes = bytes_per_x_frames / lane_count;\r\ndsi_bit_clock_hz = bytes_per_x_frames_x_lanes * 8;\r\ndsi_clk = dsi_bit_clock_hz / 1000;\r\nif (eotp && video_mode_format == VIDEO_MODE_BURST)\r\ndsi_clk *= 2;\r\nreturn dsi_clk;\r\n}\r\nstatic u32 dsi_clk_from_pclk(const struct drm_display_mode *mode,\r\nint pixel_format, int lane_count)\r\n{\r\nu32 dsi_clk_khz;\r\nu32 bpp;\r\nswitch (pixel_format) {\r\ndefault:\r\ncase VID_MODE_FORMAT_RGB888:\r\ncase VID_MODE_FORMAT_RGB666_LOOSE:\r\nbpp = 24;\r\nbreak;\r\ncase VID_MODE_FORMAT_RGB666:\r\nbpp = 18;\r\nbreak;\r\ncase VID_MODE_FORMAT_RGB565:\r\nbpp = 16;\r\nbreak;\r\n}\r\ndsi_clk_khz = DIV_ROUND_CLOSEST(mode->clock * bpp, lane_count);\r\nreturn dsi_clk_khz;\r\n}\r\nstatic int dsi_calc_mnp(u32 dsi_clk, struct dsi_mnp *dsi_mnp)\r\n{\r\nu32 m, n, p;\r\nu32 ref_clk;\r\nu32 error;\r\nu32 tmp_error;\r\nint target_dsi_clk;\r\nint calc_dsi_clk;\r\nu32 calc_m;\r\nu32 calc_p;\r\nu32 m_seed;\r\nif (dsi_clk < 300000 || dsi_clk > 1150000) {\r\nDRM_ERROR("DSI CLK Out of Range\n");\r\nreturn -ECHRNG;\r\n}\r\nref_clk = 25000;\r\ntarget_dsi_clk = dsi_clk;\r\nerror = 0xFFFFFFFF;\r\ntmp_error = 0xFFFFFFFF;\r\ncalc_m = 0;\r\ncalc_p = 0;\r\nfor (m = 62; m <= 92; m++) {\r\nfor (p = 2; p <= 6; p++) {\r\ncalc_dsi_clk = (m * ref_clk) / p;\r\nif (calc_dsi_clk == target_dsi_clk) {\r\ncalc_m = m;\r\ncalc_p = p;\r\nerror = 0;\r\nbreak;\r\n} else\r\ntmp_error = abs(target_dsi_clk - calc_dsi_clk);\r\nif (tmp_error < error) {\r\nerror = tmp_error;\r\ncalc_m = m;\r\ncalc_p = p;\r\n}\r\n}\r\nif (error == 0)\r\nbreak;\r\n}\r\nm_seed = lfsr_converts[calc_m - 62];\r\nn = 1;\r\ndsi_mnp->dsi_pll_ctrl = 1 << (DSI_PLL_P1_POST_DIV_SHIFT + calc_p - 2);\r\ndsi_mnp->dsi_pll_div = (n - 1) << DSI_PLL_N1_DIV_SHIFT |\r\nm_seed << DSI_PLL_M1_DIV_SHIFT;\r\nreturn 0;\r\n}\r\nstatic void vlv_configure_dsi_pll(struct intel_encoder *encoder)\r\n{\r\nstruct drm_i915_private *dev_priv = encoder->base.dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->base.crtc);\r\nconst struct drm_display_mode *mode = &intel_crtc->config.adjusted_mode;\r\nstruct intel_dsi *intel_dsi = enc_to_intel_dsi(&encoder->base);\r\nint ret;\r\nstruct dsi_mnp dsi_mnp;\r\nu32 dsi_clk;\r\ndsi_clk = dsi_clk_from_pclk(mode, intel_dsi->pixel_format,\r\nintel_dsi->lane_count);\r\nret = dsi_calc_mnp(dsi_clk, &dsi_mnp);\r\nif (ret) {\r\nDRM_DEBUG_KMS("dsi_calc_mnp failed\n");\r\nreturn;\r\n}\r\ndsi_mnp.dsi_pll_ctrl |= DSI_PLL_CLK_GATE_DSI0_DSIPLL;\r\nDRM_DEBUG_KMS("dsi pll div %08x, ctrl %08x\n",\r\ndsi_mnp.dsi_pll_div, dsi_mnp.dsi_pll_ctrl);\r\nvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL, 0);\r\nvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_DIVIDER, dsi_mnp.dsi_pll_div);\r\nvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL, dsi_mnp.dsi_pll_ctrl);\r\n}\r\nvoid vlv_enable_dsi_pll(struct intel_encoder *encoder)\r\n{\r\nstruct drm_i915_private *dev_priv = encoder->base.dev->dev_private;\r\nu32 tmp;\r\nDRM_DEBUG_KMS("\n");\r\nmutex_lock(&dev_priv->dpio_lock);\r\nvlv_configure_dsi_pll(encoder);\r\nusleep_range(1, 10);\r\ntmp = vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_CONTROL);\r\ntmp |= DSI_PLL_VCO_EN;\r\nvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL, tmp);\r\nmutex_unlock(&dev_priv->dpio_lock);\r\nif (wait_for(I915_READ(PIPECONF(PIPE_A)) & PIPECONF_DSI_PLL_LOCKED, 20)) {\r\nDRM_ERROR("DSI PLL lock failed\n");\r\nreturn;\r\n}\r\nDRM_DEBUG_KMS("DSI PLL locked\n");\r\n}\r\nvoid vlv_disable_dsi_pll(struct intel_encoder *encoder)\r\n{\r\nstruct drm_i915_private *dev_priv = encoder->base.dev->dev_private;\r\nu32 tmp;\r\nDRM_DEBUG_KMS("\n");\r\nmutex_lock(&dev_priv->dpio_lock);\r\ntmp = vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_CONTROL);\r\ntmp &= ~DSI_PLL_VCO_EN;\r\ntmp |= DSI_PLL_LDO_GATE;\r\nvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL, tmp);\r\nmutex_unlock(&dev_priv->dpio_lock);\r\n}
