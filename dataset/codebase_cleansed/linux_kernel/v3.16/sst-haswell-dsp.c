static int hsw_parse_module(struct sst_dsp *dsp, struct sst_fw *fw,\r\nstruct fw_module_header *module)\r\n{\r\nstruct dma_block_info *block;\r\nstruct sst_module *mod;\r\nstruct sst_module_data block_data;\r\nstruct sst_module_template template;\r\nint count;\r\nvoid __iomem *ram;\r\nif (module->type != SST_HSW_MODULE_BASE_FW\r\n&& module->type != SST_HSW_MODULE_PCM_SYSTEM\r\n&& module->type != SST_HSW_MODULE_PCM\r\n&& module->type != SST_HSW_MODULE_PCM_REFERENCE\r\n&& module->type != SST_HSW_MODULE_PCM_CAPTURE\r\n&& module->type != SST_HSW_MODULE_LPAL)\r\nreturn 0;\r\ndev_dbg(dsp->dev, "new module sign 0x%s size 0x%x blocks 0x%x type 0x%x\n",\r\nmodule->signature, module->mod_size,\r\nmodule->blocks, module->type);\r\ndev_dbg(dsp->dev, " entrypoint 0x%x\n", module->entry_point);\r\ndev_dbg(dsp->dev, " persistent 0x%x scratch 0x%x\n",\r\nmodule->info.persistent_size, module->info.scratch_size);\r\nmemset(&template, 0, sizeof(template));\r\ntemplate.id = module->type;\r\ntemplate.entry = module->entry_point;\r\ntemplate.p.size = module->info.persistent_size;\r\ntemplate.p.type = SST_MEM_DRAM;\r\ntemplate.p.data_type = SST_DATA_P;\r\ntemplate.s.size = module->info.scratch_size;\r\ntemplate.s.type = SST_MEM_DRAM;\r\ntemplate.s.data_type = SST_DATA_S;\r\nmod = sst_module_new(fw, &template, NULL);\r\nif (mod == NULL)\r\nreturn -ENOMEM;\r\nblock = (void *)module + sizeof(*module);\r\nfor (count = 0; count < module->blocks; count++) {\r\nif (block->size <= 0) {\r\ndev_err(dsp->dev,\r\n"error: block %d size invalid\n", count);\r\nsst_module_free(mod);\r\nreturn -EINVAL;\r\n}\r\nswitch (block->type) {\r\ncase SST_HSW_IRAM:\r\nram = dsp->addr.lpe;\r\nblock_data.offset =\r\nblock->ram_offset + dsp->addr.iram_offset;\r\nblock_data.type = SST_MEM_IRAM;\r\nbreak;\r\ncase SST_HSW_DRAM:\r\nram = dsp->addr.lpe;\r\nblock_data.offset = block->ram_offset;\r\nblock_data.type = SST_MEM_DRAM;\r\nbreak;\r\ndefault:\r\ndev_err(dsp->dev, "error: bad type 0x%x for block 0x%x\n",\r\nblock->type, count);\r\nsst_module_free(mod);\r\nreturn -EINVAL;\r\n}\r\nblock_data.size = block->size;\r\nblock_data.data_type = SST_DATA_M;\r\nblock_data.data = (void *)block + sizeof(*block);\r\nblock_data.data_offset = block_data.data - fw->dma_buf;\r\ndev_dbg(dsp->dev, "copy firmware block %d type 0x%x "\r\n"size 0x%x ==> ram %p offset 0x%x\n",\r\ncount, block->type, block->size, ram,\r\nblock->ram_offset);\r\nsst_module_insert_fixed_block(mod, &block_data);\r\nblock = (void *)block + sizeof(*block) + block->size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hsw_parse_fw_image(struct sst_fw *sst_fw)\r\n{\r\nstruct fw_header *header;\r\nstruct sst_module *scratch;\r\nstruct fw_module_header *module;\r\nstruct sst_dsp *dsp = sst_fw->dsp;\r\nstruct sst_hsw *hsw = sst_fw->private;\r\nint ret, count;\r\nheader = (struct fw_header *)sst_fw->dma_buf;\r\nif ((strncmp(header->signature, SST_HSW_FW_SIGN, 4) != 0) ||\r\n(sst_fw->size != header->file_size + sizeof(*header))) {\r\ndev_err(dsp->dev, "error: invalid fw sign/filesize mismatch\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dsp->dev, "header size=0x%x modules=0x%x fmt=0x%x size=%zu\n",\r\nheader->file_size, header->modules,\r\nheader->file_format, sizeof(*header));\r\nmodule = (void *)sst_fw->dma_buf + sizeof(*header);\r\nfor (count = 0; count < header->modules; count++) {\r\nret = hsw_parse_module(dsp, sst_fw, module);\r\nif (ret < 0) {\r\ndev_err(dsp->dev, "error: invalid module %d\n", count);\r\nreturn ret;\r\n}\r\nmodule = (void *)module + sizeof(*module) + module->mod_size;\r\n}\r\nscratch = sst_mem_block_alloc_scratch(dsp);\r\nif (scratch == NULL)\r\nreturn -ENOMEM;\r\nsst_hsw_set_scratch_module(hsw, scratch);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t hsw_irq(int irq, void *context)\r\n{\r\nstruct sst_dsp *sst = (struct sst_dsp *) context;\r\nu32 isr;\r\nint ret = IRQ_NONE;\r\nspin_lock(&sst->spinlock);\r\nisr = sst_dsp_shim_read_unlocked(sst, SST_ISRX);\r\nif (isr & SST_ISRX_DONE) {\r\ntrace_sst_irq_done(isr,\r\nsst_dsp_shim_read_unlocked(sst, SST_IMRX));\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_IMRX,\r\nSST_IMRX_DONE, SST_IMRX_DONE);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nif (isr & SST_ISRX_BUSY) {\r\ntrace_sst_irq_busy(isr,\r\nsst_dsp_shim_read_unlocked(sst, SST_IMRX));\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_IMRX,\r\nSST_IMRX_BUSY, SST_IMRX_BUSY);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nspin_unlock(&sst->spinlock);\r\nreturn ret;\r\n}\r\nstatic void hsw_boot(struct sst_dsp *sst)\r\n{\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CSR,\r\nSST_CSR_S1IOCS | SST_CSR_SBCS1 | SST_CSR_LPCS, 0x0);\r\nsst_dsp_shim_update_bits_unlocked(sst,\r\nSST_CSR, SST_CSR_STALL | SST_CSR_DCS_MASK,\r\nSST_CSR_STALL | SST_CSR_DCS(4));\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CLKCTL,\r\nSST_CLKCTL_MASK | SST_CLKCTL_DCPLCG | SST_CLKCTL_SCOE0,\r\nSST_CLKCTL_MASK | SST_CLKCTL_DCPLCG | SST_CLKCTL_SCOE0);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CSR2, SST_CSR2_SDFD_SSP1,\r\nSST_CSR2_SDFD_SSP1);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_HDMC,\r\nSST_HDMC_HDDA1(0xff) | SST_HDMC_HDDA0(0xff),\r\nSST_HDMC_HDDA1(0xff) | SST_HDMC_HDDA0(0xff));\r\nwritel(0x0, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CSR, SST_CSR_STALL, 0x0);\r\n}\r\nstatic void hsw_reset(struct sst_dsp *sst)\r\n{\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CSR,\r\nSST_CSR_RST | SST_CSR_STALL, SST_CSR_RST | SST_CSR_STALL);\r\nmdelay(10);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CSR,\r\nSST_CSR_RST | SST_CSR_STALL, SST_CSR_STALL);\r\n}\r\nstatic int hsw_acpi_resource_map(struct sst_dsp *sst, struct sst_pdata *pdata)\r\n{\r\nsst->addr.lpe_base = pdata->lpe_base;\r\nsst->addr.lpe = ioremap(pdata->lpe_base, pdata->lpe_size);\r\nif (!sst->addr.lpe)\r\nreturn -ENODEV;\r\nsst->addr.pci_cfg = ioremap(pdata->pcicfg_base, pdata->pcicfg_size);\r\nif (!sst->addr.pci_cfg) {\r\niounmap(sst->addr.lpe);\r\nreturn -ENODEV;\r\n}\r\nsst->addr.shim = sst->addr.lpe + sst->addr.shim_offset;\r\nreturn 0;\r\n}\r\nstatic u32 hsw_block_get_bit(struct sst_mem_block *block)\r\n{\r\nu32 bit = 0, shift = 0;\r\nswitch (block->type) {\r\ncase SST_MEM_DRAM:\r\nshift = 16;\r\nbreak;\r\ncase SST_MEM_IRAM:\r\nshift = 6;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nbit = 1 << (block->index + shift);\r\nreturn bit;\r\n}\r\nstatic int hsw_block_enable(struct sst_mem_block *block)\r\n{\r\nstruct sst_dsp *sst = block->dsp;\r\nu32 bit, val;\r\nif (block->users++ > 0)\r\nreturn 0;\r\ndev_dbg(block->dsp->dev, " enabled block %d:%d at offset 0x%x\n",\r\nblock->type, block->index, block->offset);\r\nval = readl(sst->addr.pci_cfg + SST_VDRTCTL0);\r\nbit = hsw_block_get_bit(block);\r\nwritel(val & ~bit, sst->addr.pci_cfg + SST_VDRTCTL0);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int hsw_block_disable(struct sst_mem_block *block)\r\n{\r\nstruct sst_dsp *sst = block->dsp;\r\nu32 bit, val;\r\nif (--block->users > 0)\r\nreturn 0;\r\ndev_dbg(block->dsp->dev, " disabled block %d:%d at offset 0x%x\n",\r\nblock->type, block->index, block->offset);\r\nval = readl(sst->addr.pci_cfg + SST_VDRTCTL0);\r\nbit = hsw_block_get_bit(block);\r\nwritel(val | bit, sst->addr.pci_cfg + SST_VDRTCTL0);\r\nreturn 0;\r\n}\r\nstatic int hsw_enable_shim(struct sst_dsp *sst)\r\n{\r\nint tries = 10;\r\nu32 reg;\r\nreg = readl(sst->addr.pci_cfg + SST_SHIM_PM_REG);\r\nwritel(reg & ~0x3, sst->addr.pci_cfg + SST_SHIM_PM_REG);\r\nwhile (tries--) {\r\nreg = sst_dsp_shim_read_unlocked(sst, SST_CSR);\r\nif (reg != 0xffffffff)\r\nreturn 0;\r\nmsleep(1);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int hsw_init(struct sst_dsp *sst, struct sst_pdata *pdata)\r\n{\r\nconst struct sst_adsp_memregion *region;\r\nstruct device *dev;\r\nint ret = -ENODEV, i, j, region_count;\r\nu32 offset, size;\r\ndev = sst->dma_dev;\r\nswitch (sst->id) {\r\ncase SST_DEV_ID_LYNX_POINT:\r\nregion = lp_region;\r\nregion_count = ARRAY_SIZE(lp_region);\r\nsst->addr.iram_offset = SST_LP_IRAM_OFFSET;\r\nsst->addr.shim_offset = SST_LP_SHIM_OFFSET;\r\nbreak;\r\ncase SST_DEV_ID_WILDCAT_POINT:\r\nregion = wpt_region;\r\nregion_count = ARRAY_SIZE(wpt_region);\r\nsst->addr.iram_offset = SST_WPT_IRAM_OFFSET;\r\nsst->addr.shim_offset = SST_WPT_SHIM_OFFSET;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "error: failed to get mem resources\n");\r\nreturn ret;\r\n}\r\nret = hsw_acpi_resource_map(sst, pdata);\r\nif (ret < 0) {\r\ndev_err(dev, "error: failed to map resources\n");\r\nreturn ret;\r\n}\r\nret = hsw_enable_shim(sst);\r\nif (ret < 0) {\r\ndev_err(dev, "error: failed to set DSP D0 and reset SHIM\n");\r\nreturn ret;\r\n}\r\nret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(31));\r\nif (ret)\r\nreturn ret;\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_IMRX, 0x3, 0x0);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_IMRD,\r\n(0x3 | 0x1 << 16 | 0x3 << 21), 0x0);\r\nfor (i = 0; i < region_count; i++) {\r\noffset = region[i].start;\r\nsize = (region[i].end - region[i].start) / region[i].blocks;\r\nfor (j = 0; j < region[i].blocks; j++) {\r\nsst_mem_block_register(sst, offset, size,\r\nregion[i].type, &sst_hsw_ops, j, sst);\r\noffset += size;\r\n}\r\n}\r\nwritel(0x0, sst->addr.pci_cfg + SST_VDRTCTL0);\r\nreturn 0;\r\n}\r\nstatic void hsw_free(struct sst_dsp *sst)\r\n{\r\nsst_mem_block_unregister_all(sst);\r\niounmap(sst->addr.lpe);\r\niounmap(sst->addr.pci_cfg);\r\n}
