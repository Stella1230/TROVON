static inline int is_imx1_dma(struct imxdma_engine *imxdma)\r\n{\r\nreturn imxdma->devtype == IMX1_DMA;\r\n}\r\nstatic inline int is_imx21_dma(struct imxdma_engine *imxdma)\r\n{\r\nreturn imxdma->devtype == IMX21_DMA;\r\n}\r\nstatic inline int is_imx27_dma(struct imxdma_engine *imxdma)\r\n{\r\nreturn imxdma->devtype == IMX27_DMA;\r\n}\r\nstatic struct imxdma_channel *to_imxdma_chan(struct dma_chan *chan)\r\n{\r\nreturn container_of(chan, struct imxdma_channel, chan);\r\n}\r\nstatic inline bool imxdma_chan_is_doing_cyclic(struct imxdma_channel *imxdmac)\r\n{\r\nstruct imxdma_desc *desc;\r\nif (!list_empty(&imxdmac->ld_active)) {\r\ndesc = list_first_entry(&imxdmac->ld_active, struct imxdma_desc,\r\nnode);\r\nif (desc->type == IMXDMA_DESC_CYCLIC)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void imx_dmav1_writel(struct imxdma_engine *imxdma, unsigned val,\r\nunsigned offset)\r\n{\r\n__raw_writel(val, imxdma->base + offset);\r\n}\r\nstatic unsigned imx_dmav1_readl(struct imxdma_engine *imxdma, unsigned offset)\r\n{\r\nreturn __raw_readl(imxdma->base + offset);\r\n}\r\nstatic int imxdma_hw_chain(struct imxdma_channel *imxdmac)\r\n{\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nif (is_imx27_dma(imxdma))\r\nreturn imxdmac->hw_chaining;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline int imxdma_sg_next(struct imxdma_desc *d)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nstruct scatterlist *sg = d->sg;\r\nunsigned long now;\r\nnow = min(d->len, sg_dma_len(sg));\r\nif (d->len != IMX_DMA_LENGTH_LOOP)\r\nd->len -= now;\r\nif (d->direction == DMA_DEV_TO_MEM)\r\nimx_dmav1_writel(imxdma, sg->dma_address,\r\nDMA_DAR(imxdmac->channel));\r\nelse\r\nimx_dmav1_writel(imxdma, sg->dma_address,\r\nDMA_SAR(imxdmac->channel));\r\nimx_dmav1_writel(imxdma, now, DMA_CNTR(imxdmac->channel));\r\ndev_dbg(imxdma->dev, " %s channel: %d dst 0x%08x, src 0x%08x, "\r\n"size 0x%08x\n", __func__, imxdmac->channel,\r\nimx_dmav1_readl(imxdma, DMA_DAR(imxdmac->channel)),\r\nimx_dmav1_readl(imxdma, DMA_SAR(imxdmac->channel)),\r\nimx_dmav1_readl(imxdma, DMA_CNTR(imxdmac->channel)));\r\nreturn now;\r\n}\r\nstatic void imxdma_enable_hw(struct imxdma_desc *d)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nint channel = imxdmac->channel;\r\nunsigned long flags;\r\ndev_dbg(imxdma->dev, "%s channel %d\n", __func__, channel);\r\nlocal_irq_save(flags);\r\nimx_dmav1_writel(imxdma, 1 << channel, DMA_DISR);\r\nimx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_DIMR) &\r\n~(1 << channel), DMA_DIMR);\r\nimx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_CCR(channel)) |\r\nCCR_CEN | CCR_ACRPT, DMA_CCR(channel));\r\nif (!is_imx1_dma(imxdma) &&\r\nd->sg && imxdma_hw_chain(imxdmac)) {\r\nd->sg = sg_next(d->sg);\r\nif (d->sg) {\r\nu32 tmp;\r\nimxdma_sg_next(d);\r\ntmp = imx_dmav1_readl(imxdma, DMA_CCR(channel));\r\nimx_dmav1_writel(imxdma, tmp | CCR_RPT | CCR_ACRPT,\r\nDMA_CCR(channel));\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void imxdma_disable_hw(struct imxdma_channel *imxdmac)\r\n{\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nint channel = imxdmac->channel;\r\nunsigned long flags;\r\ndev_dbg(imxdma->dev, "%s channel %d\n", __func__, channel);\r\nif (imxdma_hw_chain(imxdmac))\r\ndel_timer(&imxdmac->watchdog);\r\nlocal_irq_save(flags);\r\nimx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_DIMR) |\r\n(1 << channel), DMA_DIMR);\r\nimx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_CCR(channel)) &\r\n~CCR_CEN, DMA_CCR(channel));\r\nimx_dmav1_writel(imxdma, 1 << channel, DMA_DISR);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void imxdma_watchdog(unsigned long data)\r\n{\r\nstruct imxdma_channel *imxdmac = (struct imxdma_channel *)data;\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nint channel = imxdmac->channel;\r\nimx_dmav1_writel(imxdma, 0, DMA_CCR(channel));\r\ntasklet_schedule(&imxdmac->dma_tasklet);\r\ndev_dbg(imxdma->dev, "channel %d: watchdog timeout!\n",\r\nimxdmac->channel);\r\n}\r\nstatic irqreturn_t imxdma_err_handler(int irq, void *dev_id)\r\n{\r\nstruct imxdma_engine *imxdma = dev_id;\r\nunsigned int err_mask;\r\nint i, disr;\r\nint errcode;\r\ndisr = imx_dmav1_readl(imxdma, DMA_DISR);\r\nerr_mask = imx_dmav1_readl(imxdma, DMA_DBTOSR) |\r\nimx_dmav1_readl(imxdma, DMA_DRTOSR) |\r\nimx_dmav1_readl(imxdma, DMA_DSESR) |\r\nimx_dmav1_readl(imxdma, DMA_DBOSR);\r\nif (!err_mask)\r\nreturn IRQ_HANDLED;\r\nimx_dmav1_writel(imxdma, disr & err_mask, DMA_DISR);\r\nfor (i = 0; i < IMX_DMA_CHANNELS; i++) {\r\nif (!(err_mask & (1 << i)))\r\ncontinue;\r\nerrcode = 0;\r\nif (imx_dmav1_readl(imxdma, DMA_DBTOSR) & (1 << i)) {\r\nimx_dmav1_writel(imxdma, 1 << i, DMA_DBTOSR);\r\nerrcode |= IMX_DMA_ERR_BURST;\r\n}\r\nif (imx_dmav1_readl(imxdma, DMA_DRTOSR) & (1 << i)) {\r\nimx_dmav1_writel(imxdma, 1 << i, DMA_DRTOSR);\r\nerrcode |= IMX_DMA_ERR_REQUEST;\r\n}\r\nif (imx_dmav1_readl(imxdma, DMA_DSESR) & (1 << i)) {\r\nimx_dmav1_writel(imxdma, 1 << i, DMA_DSESR);\r\nerrcode |= IMX_DMA_ERR_TRANSFER;\r\n}\r\nif (imx_dmav1_readl(imxdma, DMA_DBOSR) & (1 << i)) {\r\nimx_dmav1_writel(imxdma, 1 << i, DMA_DBOSR);\r\nerrcode |= IMX_DMA_ERR_BUFFER;\r\n}\r\ntasklet_schedule(&imxdma->channel[i].dma_tasklet);\r\ndev_warn(imxdma->dev,\r\n"DMA timeout on channel %d -%s%s%s%s\n", i,\r\nerrcode & IMX_DMA_ERR_BURST ? " burst" : "",\r\nerrcode & IMX_DMA_ERR_REQUEST ? " request" : "",\r\nerrcode & IMX_DMA_ERR_TRANSFER ? " transfer" : "",\r\nerrcode & IMX_DMA_ERR_BUFFER ? " buffer" : "");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dma_irq_handle_channel(struct imxdma_channel *imxdmac)\r\n{\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nint chno = imxdmac->channel;\r\nstruct imxdma_desc *desc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&imxdma->lock, flags);\r\nif (list_empty(&imxdmac->ld_active)) {\r\nspin_unlock_irqrestore(&imxdma->lock, flags);\r\ngoto out;\r\n}\r\ndesc = list_first_entry(&imxdmac->ld_active,\r\nstruct imxdma_desc,\r\nnode);\r\nspin_unlock_irqrestore(&imxdma->lock, flags);\r\nif (desc->sg) {\r\nu32 tmp;\r\ndesc->sg = sg_next(desc->sg);\r\nif (desc->sg) {\r\nimxdma_sg_next(desc);\r\ntmp = imx_dmav1_readl(imxdma, DMA_CCR(chno));\r\nif (imxdma_hw_chain(imxdmac)) {\r\nmod_timer(&imxdmac->watchdog,\r\njiffies + msecs_to_jiffies(500));\r\ntmp |= CCR_CEN | CCR_RPT | CCR_ACRPT;\r\nimx_dmav1_writel(imxdma, tmp, DMA_CCR(chno));\r\n} else {\r\nimx_dmav1_writel(imxdma, tmp & ~CCR_CEN,\r\nDMA_CCR(chno));\r\ntmp |= CCR_CEN;\r\n}\r\nimx_dmav1_writel(imxdma, tmp, DMA_CCR(chno));\r\nif (imxdma_chan_is_doing_cyclic(imxdmac))\r\ntasklet_schedule(&imxdmac->dma_tasklet);\r\nreturn;\r\n}\r\nif (imxdma_hw_chain(imxdmac)) {\r\ndel_timer(&imxdmac->watchdog);\r\nreturn;\r\n}\r\n}\r\nout:\r\nimx_dmav1_writel(imxdma, 0, DMA_CCR(chno));\r\ntasklet_schedule(&imxdmac->dma_tasklet);\r\n}\r\nstatic irqreturn_t dma_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct imxdma_engine *imxdma = dev_id;\r\nint i, disr;\r\nif (!is_imx1_dma(imxdma))\r\nimxdma_err_handler(irq, dev_id);\r\ndisr = imx_dmav1_readl(imxdma, DMA_DISR);\r\ndev_dbg(imxdma->dev, "%s called, disr=0x%08x\n", __func__, disr);\r\nimx_dmav1_writel(imxdma, disr, DMA_DISR);\r\nfor (i = 0; i < IMX_DMA_CHANNELS; i++) {\r\nif (disr & (1 << i))\r\ndma_irq_handle_channel(&imxdma->channel[i]);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int imxdma_xfer_desc(struct imxdma_desc *d)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nint slot = -1;\r\nint i;\r\nswitch (d->type) {\r\ncase IMXDMA_DESC_INTERLEAVED:\r\nfor (i = 0; i < IMX_DMA_2D_SLOTS; i++) {\r\nif ((imxdma->slots_2d[i].count > 0) &&\r\n((imxdma->slots_2d[i].xsr != d->x) ||\r\n(imxdma->slots_2d[i].ysr != d->y) ||\r\n(imxdma->slots_2d[i].wsr != d->w)))\r\ncontinue;\r\nslot = i;\r\nbreak;\r\n}\r\nif (slot < 0)\r\nreturn -EBUSY;\r\nimxdma->slots_2d[slot].xsr = d->x;\r\nimxdma->slots_2d[slot].ysr = d->y;\r\nimxdma->slots_2d[slot].wsr = d->w;\r\nimxdma->slots_2d[slot].count++;\r\nimxdmac->slot_2d = slot;\r\nimxdmac->enabled_2d = true;\r\nif (slot == IMX_DMA_2D_SLOT_A) {\r\nd->config_mem &= ~CCR_MSEL_B;\r\nd->config_port &= ~CCR_MSEL_B;\r\nimx_dmav1_writel(imxdma, d->x, DMA_XSRA);\r\nimx_dmav1_writel(imxdma, d->y, DMA_YSRA);\r\nimx_dmav1_writel(imxdma, d->w, DMA_WSRA);\r\n} else {\r\nd->config_mem |= CCR_MSEL_B;\r\nd->config_port |= CCR_MSEL_B;\r\nimx_dmav1_writel(imxdma, d->x, DMA_XSRB);\r\nimx_dmav1_writel(imxdma, d->y, DMA_YSRB);\r\nimx_dmav1_writel(imxdma, d->w, DMA_WSRB);\r\n}\r\ncase IMXDMA_DESC_MEMCPY:\r\nimx_dmav1_writel(imxdma, d->src, DMA_SAR(imxdmac->channel));\r\nimx_dmav1_writel(imxdma, d->dest, DMA_DAR(imxdmac->channel));\r\nimx_dmav1_writel(imxdma, d->config_mem | (d->config_port << 2),\r\nDMA_CCR(imxdmac->channel));\r\nimx_dmav1_writel(imxdma, d->len, DMA_CNTR(imxdmac->channel));\r\ndev_dbg(imxdma->dev,\r\n"%s channel: %d dest=0x%08llx src=0x%08llx dma_length=%zu\n",\r\n__func__, imxdmac->channel,\r\n(unsigned long long)d->dest,\r\n(unsigned long long)d->src, d->len);\r\nbreak;\r\ncase IMXDMA_DESC_CYCLIC:\r\ncase IMXDMA_DESC_SLAVE_SG:\r\nif (d->direction == DMA_DEV_TO_MEM) {\r\nimx_dmav1_writel(imxdma, imxdmac->per_address,\r\nDMA_SAR(imxdmac->channel));\r\nimx_dmav1_writel(imxdma, imxdmac->ccr_from_device,\r\nDMA_CCR(imxdmac->channel));\r\ndev_dbg(imxdma->dev,\r\n"%s channel: %d sg=%p sgcount=%d total length=%zu dev_addr=0x%08llx (dev2mem)\n",\r\n__func__, imxdmac->channel,\r\nd->sg, d->sgcount, d->len,\r\n(unsigned long long)imxdmac->per_address);\r\n} else if (d->direction == DMA_MEM_TO_DEV) {\r\nimx_dmav1_writel(imxdma, imxdmac->per_address,\r\nDMA_DAR(imxdmac->channel));\r\nimx_dmav1_writel(imxdma, imxdmac->ccr_to_device,\r\nDMA_CCR(imxdmac->channel));\r\ndev_dbg(imxdma->dev,\r\n"%s channel: %d sg=%p sgcount=%d total length=%zu dev_addr=0x%08llx (mem2dev)\n",\r\n__func__, imxdmac->channel,\r\nd->sg, d->sgcount, d->len,\r\n(unsigned long long)imxdmac->per_address);\r\n} else {\r\ndev_err(imxdma->dev, "%s channel: %d bad dma mode\n",\r\n__func__, imxdmac->channel);\r\nreturn -EINVAL;\r\n}\r\nimxdma_sg_next(d);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nimxdma_enable_hw(d);\r\nreturn 0;\r\n}\r\nstatic void imxdma_tasklet(unsigned long data)\r\n{\r\nstruct imxdma_channel *imxdmac = (void *)data;\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nstruct imxdma_desc *desc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&imxdma->lock, flags);\r\nif (list_empty(&imxdmac->ld_active)) {\r\nspin_unlock_irqrestore(&imxdma->lock, flags);\r\nreturn;\r\n}\r\ndesc = list_first_entry(&imxdmac->ld_active, struct imxdma_desc, node);\r\nif (imxdma_chan_is_doing_cyclic(imxdmac))\r\ngoto out;\r\nelse\r\ndma_cookie_complete(&desc->desc);\r\nif (imxdmac->enabled_2d) {\r\nimxdma->slots_2d[imxdmac->slot_2d].count--;\r\nimxdmac->enabled_2d = false;\r\n}\r\nlist_move_tail(imxdmac->ld_active.next, &imxdmac->ld_free);\r\nif (!list_empty(&imxdmac->ld_queue)) {\r\ndesc = list_first_entry(&imxdmac->ld_queue, struct imxdma_desc,\r\nnode);\r\nlist_move_tail(imxdmac->ld_queue.next, &imxdmac->ld_active);\r\nif (imxdma_xfer_desc(desc) < 0)\r\ndev_warn(imxdma->dev, "%s: channel: %d couldn't xfer desc\n",\r\n__func__, imxdmac->channel);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&imxdma->lock, flags);\r\nif (desc->desc.callback)\r\ndesc->desc.callback(desc->desc.callback_param);\r\n}\r\nstatic int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,\r\nunsigned long arg)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\r\nstruct dma_slave_config *dmaengine_cfg = (void *)arg;\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nunsigned long flags;\r\nunsigned int mode = 0;\r\nswitch (cmd) {\r\ncase DMA_TERMINATE_ALL:\r\nimxdma_disable_hw(imxdmac);\r\nspin_lock_irqsave(&imxdma->lock, flags);\r\nlist_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);\r\nlist_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);\r\nspin_unlock_irqrestore(&imxdma->lock, flags);\r\nreturn 0;\r\ncase DMA_SLAVE_CONFIG:\r\nif (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {\r\nimxdmac->per_address = dmaengine_cfg->src_addr;\r\nimxdmac->watermark_level = dmaengine_cfg->src_maxburst;\r\nimxdmac->word_size = dmaengine_cfg->src_addr_width;\r\n} else {\r\nimxdmac->per_address = dmaengine_cfg->dst_addr;\r\nimxdmac->watermark_level = dmaengine_cfg->dst_maxburst;\r\nimxdmac->word_size = dmaengine_cfg->dst_addr_width;\r\n}\r\nswitch (imxdmac->word_size) {\r\ncase DMA_SLAVE_BUSWIDTH_1_BYTE:\r\nmode = IMX_DMA_MEMSIZE_8;\r\nbreak;\r\ncase DMA_SLAVE_BUSWIDTH_2_BYTES:\r\nmode = IMX_DMA_MEMSIZE_16;\r\nbreak;\r\ndefault:\r\ncase DMA_SLAVE_BUSWIDTH_4_BYTES:\r\nmode = IMX_DMA_MEMSIZE_32;\r\nbreak;\r\n}\r\nimxdmac->hw_chaining = 0;\r\nimxdmac->ccr_from_device = (mode | IMX_DMA_TYPE_FIFO) |\r\n((IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) << 2) |\r\nCCR_REN;\r\nimxdmac->ccr_to_device =\r\n(IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) |\r\n((mode | IMX_DMA_TYPE_FIFO) << 2) | CCR_REN;\r\nimx_dmav1_writel(imxdma, imxdmac->dma_request,\r\nDMA_RSSR(imxdmac->channel));\r\nimx_dmav1_writel(imxdma, imxdmac->watermark_level *\r\nimxdmac->word_size, DMA_BLR(imxdmac->channel));\r\nreturn 0;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic enum dma_status imxdma_tx_status(struct dma_chan *chan,\r\ndma_cookie_t cookie,\r\nstruct dma_tx_state *txstate)\r\n{\r\nreturn dma_cookie_status(chan, cookie, txstate);\r\n}\r\nstatic dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(tx->chan);\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\ndma_cookie_t cookie;\r\nunsigned long flags;\r\nspin_lock_irqsave(&imxdma->lock, flags);\r\nlist_move_tail(imxdmac->ld_free.next, &imxdmac->ld_queue);\r\ncookie = dma_cookie_assign(tx);\r\nspin_unlock_irqrestore(&imxdma->lock, flags);\r\nreturn cookie;\r\n}\r\nstatic int imxdma_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\r\nstruct imx_dma_data *data = chan->private;\r\nif (data != NULL)\r\nimxdmac->dma_request = data->dma_request;\r\nwhile (imxdmac->descs_allocated < IMXDMA_MAX_CHAN_DESCRIPTORS) {\r\nstruct imxdma_desc *desc;\r\ndesc = kzalloc(sizeof(*desc), GFP_KERNEL);\r\nif (!desc)\r\nbreak;\r\n__memzero(&desc->desc, sizeof(struct dma_async_tx_descriptor));\r\ndma_async_tx_descriptor_init(&desc->desc, chan);\r\ndesc->desc.tx_submit = imxdma_tx_submit;\r\ndesc->desc.flags = DMA_CTRL_ACK;\r\ndesc->status = DMA_COMPLETE;\r\nlist_add_tail(&desc->node, &imxdmac->ld_free);\r\nimxdmac->descs_allocated++;\r\n}\r\nif (!imxdmac->descs_allocated)\r\nreturn -ENOMEM;\r\nreturn imxdmac->descs_allocated;\r\n}\r\nstatic void imxdma_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nstruct imxdma_desc *desc, *_desc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&imxdma->lock, flags);\r\nimxdma_disable_hw(imxdmac);\r\nlist_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);\r\nlist_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);\r\nspin_unlock_irqrestore(&imxdma->lock, flags);\r\nlist_for_each_entry_safe(desc, _desc, &imxdmac->ld_free, node) {\r\nkfree(desc);\r\nimxdmac->descs_allocated--;\r\n}\r\nINIT_LIST_HEAD(&imxdmac->ld_free);\r\nkfree(imxdmac->sg_list);\r\nimxdmac->sg_list = NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *imxdma_prep_slave_sg(\r\nstruct dma_chan *chan, struct scatterlist *sgl,\r\nunsigned int sg_len, enum dma_transfer_direction direction,\r\nunsigned long flags, void *context)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\r\nstruct scatterlist *sg;\r\nint i, dma_length = 0;\r\nstruct imxdma_desc *desc;\r\nif (list_empty(&imxdmac->ld_free) ||\r\nimxdma_chan_is_doing_cyclic(imxdmac))\r\nreturn NULL;\r\ndesc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);\r\nfor_each_sg(sgl, sg, sg_len, i) {\r\ndma_length += sg_dma_len(sg);\r\n}\r\nswitch (imxdmac->word_size) {\r\ncase DMA_SLAVE_BUSWIDTH_4_BYTES:\r\nif (sg_dma_len(sgl) & 3 || sgl->dma_address & 3)\r\nreturn NULL;\r\nbreak;\r\ncase DMA_SLAVE_BUSWIDTH_2_BYTES:\r\nif (sg_dma_len(sgl) & 1 || sgl->dma_address & 1)\r\nreturn NULL;\r\nbreak;\r\ncase DMA_SLAVE_BUSWIDTH_1_BYTE:\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\ndesc->type = IMXDMA_DESC_SLAVE_SG;\r\ndesc->sg = sgl;\r\ndesc->sgcount = sg_len;\r\ndesc->len = dma_length;\r\ndesc->direction = direction;\r\nif (direction == DMA_DEV_TO_MEM) {\r\ndesc->src = imxdmac->per_address;\r\n} else {\r\ndesc->dest = imxdmac->per_address;\r\n}\r\ndesc->desc.callback = NULL;\r\ndesc->desc.callback_param = NULL;\r\nreturn &desc->desc;\r\n}\r\nstatic struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(\r\nstruct dma_chan *chan, dma_addr_t dma_addr, size_t buf_len,\r\nsize_t period_len, enum dma_transfer_direction direction,\r\nunsigned long flags, void *context)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nstruct imxdma_desc *desc;\r\nint i;\r\nunsigned int periods = buf_len / period_len;\r\ndev_dbg(imxdma->dev, "%s channel: %d buf_len=%zu period_len=%zu\n",\r\n__func__, imxdmac->channel, buf_len, period_len);\r\nif (list_empty(&imxdmac->ld_free) ||\r\nimxdma_chan_is_doing_cyclic(imxdmac))\r\nreturn NULL;\r\ndesc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);\r\nkfree(imxdmac->sg_list);\r\nimxdmac->sg_list = kcalloc(periods + 1,\r\nsizeof(struct scatterlist), GFP_ATOMIC);\r\nif (!imxdmac->sg_list)\r\nreturn NULL;\r\nsg_init_table(imxdmac->sg_list, periods);\r\nfor (i = 0; i < periods; i++) {\r\nimxdmac->sg_list[i].page_link = 0;\r\nimxdmac->sg_list[i].offset = 0;\r\nimxdmac->sg_list[i].dma_address = dma_addr;\r\nsg_dma_len(&imxdmac->sg_list[i]) = period_len;\r\ndma_addr += period_len;\r\n}\r\nimxdmac->sg_list[periods].offset = 0;\r\nsg_dma_len(&imxdmac->sg_list[periods]) = 0;\r\nimxdmac->sg_list[periods].page_link =\r\n((unsigned long)imxdmac->sg_list | 0x01) & ~0x02;\r\ndesc->type = IMXDMA_DESC_CYCLIC;\r\ndesc->sg = imxdmac->sg_list;\r\ndesc->sgcount = periods;\r\ndesc->len = IMX_DMA_LENGTH_LOOP;\r\ndesc->direction = direction;\r\nif (direction == DMA_DEV_TO_MEM) {\r\ndesc->src = imxdmac->per_address;\r\n} else {\r\ndesc->dest = imxdmac->per_address;\r\n}\r\ndesc->desc.callback = NULL;\r\ndesc->desc.callback_param = NULL;\r\nreturn &desc->desc;\r\n}\r\nstatic struct dma_async_tx_descriptor *imxdma_prep_dma_memcpy(\r\nstruct dma_chan *chan, dma_addr_t dest,\r\ndma_addr_t src, size_t len, unsigned long flags)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nstruct imxdma_desc *desc;\r\ndev_dbg(imxdma->dev, "%s channel: %d src=0x%llx dst=0x%llx len=%zu\n",\r\n__func__, imxdmac->channel, (unsigned long long)src,\r\n(unsigned long long)dest, len);\r\nif (list_empty(&imxdmac->ld_free) ||\r\nimxdma_chan_is_doing_cyclic(imxdmac))\r\nreturn NULL;\r\ndesc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);\r\ndesc->type = IMXDMA_DESC_MEMCPY;\r\ndesc->src = src;\r\ndesc->dest = dest;\r\ndesc->len = len;\r\ndesc->direction = DMA_MEM_TO_MEM;\r\ndesc->config_port = IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR;\r\ndesc->config_mem = IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR;\r\ndesc->desc.callback = NULL;\r\ndesc->desc.callback_param = NULL;\r\nreturn &desc->desc;\r\n}\r\nstatic struct dma_async_tx_descriptor *imxdma_prep_dma_interleaved(\r\nstruct dma_chan *chan, struct dma_interleaved_template *xt,\r\nunsigned long flags)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nstruct imxdma_desc *desc;\r\ndev_dbg(imxdma->dev, "%s channel: %d src_start=0x%llx dst_start=0x%llx\n"\r\n" src_sgl=%s dst_sgl=%s numf=%zu frame_size=%zu\n", __func__,\r\nimxdmac->channel, (unsigned long long)xt->src_start,\r\n(unsigned long long) xt->dst_start,\r\nxt->src_sgl ? "true" : "false", xt->dst_sgl ? "true" : "false",\r\nxt->numf, xt->frame_size);\r\nif (list_empty(&imxdmac->ld_free) ||\r\nimxdma_chan_is_doing_cyclic(imxdmac))\r\nreturn NULL;\r\nif (xt->frame_size != 1 || xt->numf <= 0 || xt->dir != DMA_MEM_TO_MEM)\r\nreturn NULL;\r\ndesc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);\r\ndesc->type = IMXDMA_DESC_INTERLEAVED;\r\ndesc->src = xt->src_start;\r\ndesc->dest = xt->dst_start;\r\ndesc->x = xt->sgl[0].size;\r\ndesc->y = xt->numf;\r\ndesc->w = xt->sgl[0].icg + desc->x;\r\ndesc->len = desc->x * desc->y;\r\ndesc->direction = DMA_MEM_TO_MEM;\r\ndesc->config_port = IMX_DMA_MEMSIZE_32;\r\ndesc->config_mem = IMX_DMA_MEMSIZE_32;\r\nif (xt->src_sgl)\r\ndesc->config_mem |= IMX_DMA_TYPE_2D;\r\nif (xt->dst_sgl)\r\ndesc->config_port |= IMX_DMA_TYPE_2D;\r\ndesc->desc.callback = NULL;\r\ndesc->desc.callback_param = NULL;\r\nreturn &desc->desc;\r\n}\r\nstatic void imxdma_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\r\nstruct imxdma_engine *imxdma = imxdmac->imxdma;\r\nstruct imxdma_desc *desc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&imxdma->lock, flags);\r\nif (list_empty(&imxdmac->ld_active) &&\r\n!list_empty(&imxdmac->ld_queue)) {\r\ndesc = list_first_entry(&imxdmac->ld_queue,\r\nstruct imxdma_desc, node);\r\nif (imxdma_xfer_desc(desc) < 0) {\r\ndev_warn(imxdma->dev,\r\n"%s: channel: %d couldn't issue DMA xfer\n",\r\n__func__, imxdmac->channel);\r\n} else {\r\nlist_move_tail(imxdmac->ld_queue.next,\r\n&imxdmac->ld_active);\r\n}\r\n}\r\nspin_unlock_irqrestore(&imxdma->lock, flags);\r\n}\r\nstatic bool imxdma_filter_fn(struct dma_chan *chan, void *param)\r\n{\r\nstruct imxdma_filter_data *fdata = param;\r\nstruct imxdma_channel *imxdma_chan = to_imxdma_chan(chan);\r\nif (chan->device->dev != fdata->imxdma->dev)\r\nreturn false;\r\nimxdma_chan->dma_request = fdata->request;\r\nchan->private = NULL;\r\nreturn true;\r\n}\r\nstatic struct dma_chan *imxdma_xlate(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nint count = dma_spec->args_count;\r\nstruct imxdma_engine *imxdma = ofdma->of_dma_data;\r\nstruct imxdma_filter_data fdata = {\r\n.imxdma = imxdma,\r\n};\r\nif (count != 1)\r\nreturn NULL;\r\nfdata.request = dma_spec->args[0];\r\nreturn dma_request_channel(imxdma->dma_device.cap_mask,\r\nimxdma_filter_fn, &fdata);\r\n}\r\nstatic int __init imxdma_probe(struct platform_device *pdev)\r\n{\r\nstruct imxdma_engine *imxdma;\r\nstruct resource *res;\r\nconst struct of_device_id *of_id;\r\nint ret, i;\r\nint irq, irq_err;\r\nof_id = of_match_device(imx_dma_of_dev_id, &pdev->dev);\r\nif (of_id)\r\npdev->id_entry = of_id->data;\r\nimxdma = devm_kzalloc(&pdev->dev, sizeof(*imxdma), GFP_KERNEL);\r\nif (!imxdma)\r\nreturn -ENOMEM;\r\nimxdma->dev = &pdev->dev;\r\nimxdma->devtype = pdev->id_entry->driver_data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nimxdma->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(imxdma->base))\r\nreturn PTR_ERR(imxdma->base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nimxdma->dma_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(imxdma->dma_ipg))\r\nreturn PTR_ERR(imxdma->dma_ipg);\r\nimxdma->dma_ahb = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(imxdma->dma_ahb))\r\nreturn PTR_ERR(imxdma->dma_ahb);\r\nclk_prepare_enable(imxdma->dma_ipg);\r\nclk_prepare_enable(imxdma->dma_ahb);\r\nimx_dmav1_writel(imxdma, DCR_DRST, DMA_DCR);\r\nif (is_imx1_dma(imxdma)) {\r\nret = devm_request_irq(&pdev->dev, irq,\r\ndma_irq_handler, 0, "DMA", imxdma);\r\nif (ret) {\r\ndev_warn(imxdma->dev, "Can't register IRQ for DMA\n");\r\ngoto err;\r\n}\r\nirq_err = platform_get_irq(pdev, 1);\r\nif (irq_err < 0) {\r\nret = irq_err;\r\ngoto err;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq_err,\r\nimxdma_err_handler, 0, "DMA", imxdma);\r\nif (ret) {\r\ndev_warn(imxdma->dev, "Can't register ERRIRQ for DMA\n");\r\ngoto err;\r\n}\r\n}\r\nimx_dmav1_writel(imxdma, DCR_DEN, DMA_DCR);\r\nimx_dmav1_writel(imxdma, (1 << IMX_DMA_CHANNELS) - 1, DMA_DISR);\r\nimx_dmav1_writel(imxdma, (1 << IMX_DMA_CHANNELS) - 1, DMA_DIMR);\r\nINIT_LIST_HEAD(&imxdma->dma_device.channels);\r\ndma_cap_set(DMA_SLAVE, imxdma->dma_device.cap_mask);\r\ndma_cap_set(DMA_CYCLIC, imxdma->dma_device.cap_mask);\r\ndma_cap_set(DMA_MEMCPY, imxdma->dma_device.cap_mask);\r\ndma_cap_set(DMA_INTERLEAVE, imxdma->dma_device.cap_mask);\r\nfor (i = 0; i < IMX_DMA_2D_SLOTS; i++)\r\nimxdma->slots_2d[i].count = 0;\r\nspin_lock_init(&imxdma->lock);\r\nfor (i = 0; i < IMX_DMA_CHANNELS; i++) {\r\nstruct imxdma_channel *imxdmac = &imxdma->channel[i];\r\nif (!is_imx1_dma(imxdma)) {\r\nret = devm_request_irq(&pdev->dev, irq + i,\r\ndma_irq_handler, 0, "DMA", imxdma);\r\nif (ret) {\r\ndev_warn(imxdma->dev, "Can't register IRQ %d "\r\n"for DMA channel %d\n",\r\nirq + i, i);\r\ngoto err;\r\n}\r\ninit_timer(&imxdmac->watchdog);\r\nimxdmac->watchdog.function = &imxdma_watchdog;\r\nimxdmac->watchdog.data = (unsigned long)imxdmac;\r\n}\r\nimxdmac->imxdma = imxdma;\r\nINIT_LIST_HEAD(&imxdmac->ld_queue);\r\nINIT_LIST_HEAD(&imxdmac->ld_free);\r\nINIT_LIST_HEAD(&imxdmac->ld_active);\r\ntasklet_init(&imxdmac->dma_tasklet, imxdma_tasklet,\r\n(unsigned long)imxdmac);\r\nimxdmac->chan.device = &imxdma->dma_device;\r\ndma_cookie_init(&imxdmac->chan);\r\nimxdmac->channel = i;\r\nlist_add_tail(&imxdmac->chan.device_node,\r\n&imxdma->dma_device.channels);\r\n}\r\nimxdma->dma_device.dev = &pdev->dev;\r\nimxdma->dma_device.device_alloc_chan_resources = imxdma_alloc_chan_resources;\r\nimxdma->dma_device.device_free_chan_resources = imxdma_free_chan_resources;\r\nimxdma->dma_device.device_tx_status = imxdma_tx_status;\r\nimxdma->dma_device.device_prep_slave_sg = imxdma_prep_slave_sg;\r\nimxdma->dma_device.device_prep_dma_cyclic = imxdma_prep_dma_cyclic;\r\nimxdma->dma_device.device_prep_dma_memcpy = imxdma_prep_dma_memcpy;\r\nimxdma->dma_device.device_prep_interleaved_dma = imxdma_prep_dma_interleaved;\r\nimxdma->dma_device.device_control = imxdma_control;\r\nimxdma->dma_device.device_issue_pending = imxdma_issue_pending;\r\nplatform_set_drvdata(pdev, imxdma);\r\nimxdma->dma_device.copy_align = 2;\r\nimxdma->dma_device.dev->dma_parms = &imxdma->dma_parms;\r\ndma_set_max_seg_size(imxdma->dma_device.dev, 0xffffff);\r\nret = dma_async_device_register(&imxdma->dma_device);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to register\n");\r\ngoto err;\r\n}\r\nif (pdev->dev.of_node) {\r\nret = of_dma_controller_register(pdev->dev.of_node,\r\nimxdma_xlate, imxdma);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to register of_dma_controller\n");\r\ngoto err_of_dma_controller;\r\n}\r\n}\r\nreturn 0;\r\nerr_of_dma_controller:\r\ndma_async_device_unregister(&imxdma->dma_device);\r\nerr:\r\nclk_disable_unprepare(imxdma->dma_ipg);\r\nclk_disable_unprepare(imxdma->dma_ahb);\r\nreturn ret;\r\n}\r\nstatic int imxdma_remove(struct platform_device *pdev)\r\n{\r\nstruct imxdma_engine *imxdma = platform_get_drvdata(pdev);\r\ndma_async_device_unregister(&imxdma->dma_device);\r\nif (pdev->dev.of_node)\r\nof_dma_controller_free(pdev->dev.of_node);\r\nclk_disable_unprepare(imxdma->dma_ipg);\r\nclk_disable_unprepare(imxdma->dma_ahb);\r\nreturn 0;\r\n}\r\nstatic int __init imxdma_module_init(void)\r\n{\r\nreturn platform_driver_probe(&imxdma_driver, imxdma_probe);\r\n}
