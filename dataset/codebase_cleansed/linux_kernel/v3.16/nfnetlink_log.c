static struct nfnl_log_net *nfnl_log_pernet(struct net *net)\r\n{\r\nreturn net_generic(net, nfnl_log_net_id);\r\n}\r\nstatic inline u_int8_t instance_hashfn(u_int16_t group_num)\r\n{\r\nreturn ((group_num & 0xff) % INSTANCE_BUCKETS);\r\n}\r\nstatic struct nfulnl_instance *\r\n__instance_lookup(struct nfnl_log_net *log, u_int16_t group_num)\r\n{\r\nstruct hlist_head *head;\r\nstruct nfulnl_instance *inst;\r\nhead = &log->instance_table[instance_hashfn(group_num)];\r\nhlist_for_each_entry_rcu(inst, head, hlist) {\r\nif (inst->group_num == group_num)\r\nreturn inst;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void\r\ninstance_get(struct nfulnl_instance *inst)\r\n{\r\natomic_inc(&inst->use);\r\n}\r\nstatic struct nfulnl_instance *\r\ninstance_lookup_get(struct nfnl_log_net *log, u_int16_t group_num)\r\n{\r\nstruct nfulnl_instance *inst;\r\nrcu_read_lock_bh();\r\ninst = __instance_lookup(log, group_num);\r\nif (inst && !atomic_inc_not_zero(&inst->use))\r\ninst = NULL;\r\nrcu_read_unlock_bh();\r\nreturn inst;\r\n}\r\nstatic void nfulnl_instance_free_rcu(struct rcu_head *head)\r\n{\r\nstruct nfulnl_instance *inst =\r\ncontainer_of(head, struct nfulnl_instance, rcu);\r\nput_net(inst->net);\r\nkfree(inst);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic void\r\ninstance_put(struct nfulnl_instance *inst)\r\n{\r\nif (inst && atomic_dec_and_test(&inst->use))\r\ncall_rcu_bh(&inst->rcu, nfulnl_instance_free_rcu);\r\n}\r\nstatic struct nfulnl_instance *\r\ninstance_create(struct net *net, u_int16_t group_num,\r\nint portid, struct user_namespace *user_ns)\r\n{\r\nstruct nfulnl_instance *inst;\r\nstruct nfnl_log_net *log = nfnl_log_pernet(net);\r\nint err;\r\nspin_lock_bh(&log->instances_lock);\r\nif (__instance_lookup(log, group_num)) {\r\nerr = -EEXIST;\r\ngoto out_unlock;\r\n}\r\ninst = kzalloc(sizeof(*inst), GFP_ATOMIC);\r\nif (!inst) {\r\nerr = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nif (!try_module_get(THIS_MODULE)) {\r\nkfree(inst);\r\nerr = -EAGAIN;\r\ngoto out_unlock;\r\n}\r\nINIT_HLIST_NODE(&inst->hlist);\r\nspin_lock_init(&inst->lock);\r\natomic_set(&inst->use, 2);\r\nsetup_timer(&inst->timer, nfulnl_timer, (unsigned long)inst);\r\ninst->net = get_net(net);\r\ninst->peer_user_ns = user_ns;\r\ninst->peer_portid = portid;\r\ninst->group_num = group_num;\r\ninst->qthreshold = NFULNL_QTHRESH_DEFAULT;\r\ninst->flushtimeout = NFULNL_TIMEOUT_DEFAULT;\r\ninst->nlbufsiz = NFULNL_NLBUFSIZ_DEFAULT;\r\ninst->copy_mode = NFULNL_COPY_PACKET;\r\ninst->copy_range = NFULNL_COPY_RANGE_MAX;\r\nhlist_add_head_rcu(&inst->hlist,\r\n&log->instance_table[instance_hashfn(group_num)]);\r\nspin_unlock_bh(&log->instances_lock);\r\nreturn inst;\r\nout_unlock:\r\nspin_unlock_bh(&log->instances_lock);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void\r\n__instance_destroy(struct nfulnl_instance *inst)\r\n{\r\nhlist_del_rcu(&inst->hlist);\r\nspin_lock(&inst->lock);\r\ninst->copy_mode = NFULNL_COPY_DISABLED;\r\nif (inst->skb)\r\n__nfulnl_flush(inst);\r\nspin_unlock(&inst->lock);\r\ninstance_put(inst);\r\n}\r\nstatic inline void\r\ninstance_destroy(struct nfnl_log_net *log,\r\nstruct nfulnl_instance *inst)\r\n{\r\nspin_lock_bh(&log->instances_lock);\r\n__instance_destroy(inst);\r\nspin_unlock_bh(&log->instances_lock);\r\n}\r\nstatic int\r\nnfulnl_set_mode(struct nfulnl_instance *inst, u_int8_t mode,\r\nunsigned int range)\r\n{\r\nint status = 0;\r\nspin_lock_bh(&inst->lock);\r\nswitch (mode) {\r\ncase NFULNL_COPY_NONE:\r\ncase NFULNL_COPY_META:\r\ninst->copy_mode = mode;\r\ninst->copy_range = 0;\r\nbreak;\r\ncase NFULNL_COPY_PACKET:\r\ninst->copy_mode = mode;\r\ninst->copy_range = min_t(unsigned int,\r\nrange, NFULNL_COPY_RANGE_MAX);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_bh(&inst->lock);\r\nreturn status;\r\n}\r\nstatic int\r\nnfulnl_set_nlbufsiz(struct nfulnl_instance *inst, u_int32_t nlbufsiz)\r\n{\r\nint status;\r\nspin_lock_bh(&inst->lock);\r\nif (nlbufsiz < NFULNL_NLBUFSIZ_DEFAULT)\r\nstatus = -ERANGE;\r\nelse if (nlbufsiz > 131072)\r\nstatus = -ERANGE;\r\nelse {\r\ninst->nlbufsiz = nlbufsiz;\r\nstatus = 0;\r\n}\r\nspin_unlock_bh(&inst->lock);\r\nreturn status;\r\n}\r\nstatic int\r\nnfulnl_set_timeout(struct nfulnl_instance *inst, u_int32_t timeout)\r\n{\r\nspin_lock_bh(&inst->lock);\r\ninst->flushtimeout = timeout;\r\nspin_unlock_bh(&inst->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfulnl_set_qthresh(struct nfulnl_instance *inst, u_int32_t qthresh)\r\n{\r\nspin_lock_bh(&inst->lock);\r\ninst->qthreshold = qthresh;\r\nspin_unlock_bh(&inst->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfulnl_set_flags(struct nfulnl_instance *inst, u_int16_t flags)\r\n{\r\nspin_lock_bh(&inst->lock);\r\ninst->flags = flags;\r\nspin_unlock_bh(&inst->lock);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *\r\nnfulnl_alloc_skb(struct net *net, u32 peer_portid, unsigned int inst_size,\r\nunsigned int pkt_size)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned int n;\r\nn = max(inst_size, pkt_size);\r\nskb = nfnetlink_alloc_skb(net, n, peer_portid, GFP_ATOMIC);\r\nif (!skb) {\r\nif (n > pkt_size) {\r\nskb = nfnetlink_alloc_skb(net, pkt_size,\r\npeer_portid, GFP_ATOMIC);\r\nif (!skb)\r\npr_err("nfnetlink_log: can't even alloc %u bytes\n",\r\npkt_size);\r\n}\r\n}\r\nreturn skb;\r\n}\r\nstatic int\r\n__nfulnl_send(struct nfulnl_instance *inst)\r\n{\r\nint status = -1;\r\nif (inst->qlen > 1) {\r\nstruct nlmsghdr *nlh = nlmsg_put(inst->skb, 0, 0,\r\nNLMSG_DONE,\r\nsizeof(struct nfgenmsg),\r\n0);\r\nif (!nlh)\r\ngoto out;\r\n}\r\nstatus = nfnetlink_unicast(inst->skb, inst->net, inst->peer_portid,\r\nMSG_DONTWAIT);\r\ninst->qlen = 0;\r\ninst->skb = NULL;\r\nout:\r\nreturn status;\r\n}\r\nstatic void\r\n__nfulnl_flush(struct nfulnl_instance *inst)\r\n{\r\nif (del_timer(&inst->timer))\r\ninstance_put(inst);\r\nif (inst->skb)\r\n__nfulnl_send(inst);\r\n}\r\nstatic void\r\nnfulnl_timer(unsigned long data)\r\n{\r\nstruct nfulnl_instance *inst = (struct nfulnl_instance *)data;\r\nspin_lock_bh(&inst->lock);\r\nif (inst->skb)\r\n__nfulnl_send(inst);\r\nspin_unlock_bh(&inst->lock);\r\ninstance_put(inst);\r\n}\r\nstatic inline int\r\n__build_packet_message(struct nfnl_log_net *log,\r\nstruct nfulnl_instance *inst,\r\nconst struct sk_buff *skb,\r\nunsigned int data_len,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct net_device *indev,\r\nconst struct net_device *outdev,\r\nconst char *prefix, unsigned int plen)\r\n{\r\nstruct nfulnl_msg_packet_hdr pmsg;\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nsk_buff_data_t old_tail = inst->skb->tail;\r\nstruct sock *sk;\r\nconst unsigned char *hwhdrp;\r\nnlh = nlmsg_put(inst->skb, 0, 0,\r\nNFNL_SUBSYS_ULOG << 8 | NFULNL_MSG_PACKET,\r\nsizeof(struct nfgenmsg), 0);\r\nif (!nlh)\r\nreturn -1;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = pf;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(inst->group_num);\r\nmemset(&pmsg, 0, sizeof(pmsg));\r\npmsg.hw_protocol = skb->protocol;\r\npmsg.hook = hooknum;\r\nif (nla_put(inst->skb, NFULA_PACKET_HDR, sizeof(pmsg), &pmsg))\r\ngoto nla_put_failure;\r\nif (prefix &&\r\nnla_put(inst->skb, NFULA_PREFIX, plen, prefix))\r\ngoto nla_put_failure;\r\nif (indev) {\r\n#ifndef CONFIG_BRIDGE_NETFILTER\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_INDEV,\r\nhtonl(indev->ifindex)))\r\ngoto nla_put_failure;\r\n#else\r\nif (pf == PF_BRIDGE) {\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_PHYSINDEV,\r\nhtonl(indev->ifindex)) ||\r\nnla_put_be32(inst->skb, NFULA_IFINDEX_INDEV,\r\nhtonl(br_port_get_rcu(indev)->br->dev->ifindex)))\r\ngoto nla_put_failure;\r\n} else {\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_INDEV,\r\nhtonl(indev->ifindex)))\r\ngoto nla_put_failure;\r\nif (skb->nf_bridge && skb->nf_bridge->physindev &&\r\nnla_put_be32(inst->skb, NFULA_IFINDEX_PHYSINDEV,\r\nhtonl(skb->nf_bridge->physindev->ifindex)))\r\ngoto nla_put_failure;\r\n}\r\n#endif\r\n}\r\nif (outdev) {\r\n#ifndef CONFIG_BRIDGE_NETFILTER\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_OUTDEV,\r\nhtonl(outdev->ifindex)))\r\ngoto nla_put_failure;\r\n#else\r\nif (pf == PF_BRIDGE) {\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_PHYSOUTDEV,\r\nhtonl(outdev->ifindex)) ||\r\nnla_put_be32(inst->skb, NFULA_IFINDEX_OUTDEV,\r\nhtonl(br_port_get_rcu(outdev)->br->dev->ifindex)))\r\ngoto nla_put_failure;\r\n} else {\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_OUTDEV,\r\nhtonl(outdev->ifindex)))\r\ngoto nla_put_failure;\r\nif (skb->nf_bridge && skb->nf_bridge->physoutdev &&\r\nnla_put_be32(inst->skb, NFULA_IFINDEX_PHYSOUTDEV,\r\nhtonl(skb->nf_bridge->physoutdev->ifindex)))\r\ngoto nla_put_failure;\r\n}\r\n#endif\r\n}\r\nif (skb->mark &&\r\nnla_put_be32(inst->skb, NFULA_MARK, htonl(skb->mark)))\r\ngoto nla_put_failure;\r\nif (indev && skb->dev &&\r\nskb->mac_header != skb->network_header) {\r\nstruct nfulnl_msg_packet_hw phw;\r\nint len;\r\nmemset(&phw, 0, sizeof(phw));\r\nlen = dev_parse_header(skb, phw.hw_addr);\r\nif (len > 0) {\r\nphw.hw_addrlen = htons(len);\r\nif (nla_put(inst->skb, NFULA_HWADDR, sizeof(phw), &phw))\r\ngoto nla_put_failure;\r\n}\r\n}\r\nif (indev && skb_mac_header_was_set(skb)) {\r\nif (nla_put_be16(inst->skb, NFULA_HWTYPE, htons(skb->dev->type)) ||\r\nnla_put_be16(inst->skb, NFULA_HWLEN,\r\nhtons(skb->dev->hard_header_len)))\r\ngoto nla_put_failure;\r\nhwhdrp = skb_mac_header(skb);\r\nif (skb->dev->type == ARPHRD_SIT)\r\nhwhdrp -= ETH_HLEN;\r\nif (hwhdrp >= skb->head &&\r\nnla_put(inst->skb, NFULA_HWHEADER,\r\nskb->dev->hard_header_len, hwhdrp))\r\ngoto nla_put_failure;\r\n}\r\nif (skb->tstamp.tv64) {\r\nstruct nfulnl_msg_packet_timestamp ts;\r\nstruct timeval tv = ktime_to_timeval(skb->tstamp);\r\nts.sec = cpu_to_be64(tv.tv_sec);\r\nts.usec = cpu_to_be64(tv.tv_usec);\r\nif (nla_put(inst->skb, NFULA_TIMESTAMP, sizeof(ts), &ts))\r\ngoto nla_put_failure;\r\n}\r\nsk = skb->sk;\r\nif (sk && sk->sk_state != TCP_TIME_WAIT) {\r\nread_lock_bh(&sk->sk_callback_lock);\r\nif (sk->sk_socket && sk->sk_socket->file) {\r\nstruct file *file = sk->sk_socket->file;\r\nconst struct cred *cred = file->f_cred;\r\nstruct user_namespace *user_ns = inst->peer_user_ns;\r\n__be32 uid = htonl(from_kuid_munged(user_ns, cred->fsuid));\r\n__be32 gid = htonl(from_kgid_munged(user_ns, cred->fsgid));\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nif (nla_put_be32(inst->skb, NFULA_UID, uid) ||\r\nnla_put_be32(inst->skb, NFULA_GID, gid))\r\ngoto nla_put_failure;\r\n} else\r\nread_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nif ((inst->flags & NFULNL_CFG_F_SEQ) &&\r\nnla_put_be32(inst->skb, NFULA_SEQ, htonl(inst->seq++)))\r\ngoto nla_put_failure;\r\nif ((inst->flags & NFULNL_CFG_F_SEQ_GLOBAL) &&\r\nnla_put_be32(inst->skb, NFULA_SEQ_GLOBAL,\r\nhtonl(atomic_inc_return(&log->global_seq))))\r\ngoto nla_put_failure;\r\nif (data_len) {\r\nstruct nlattr *nla;\r\nint size = nla_attr_size(data_len);\r\nif (skb_tailroom(inst->skb) < nla_total_size(data_len)) {\r\nprintk(KERN_WARNING "nfnetlink_log: no tailroom!\n");\r\nreturn -1;\r\n}\r\nnla = (struct nlattr *)skb_put(inst->skb, nla_total_size(data_len));\r\nnla->nla_type = NFULA_PAYLOAD;\r\nnla->nla_len = size;\r\nif (skb_copy_bits(skb, 0, nla_data(nla), data_len))\r\nBUG();\r\n}\r\nnlh->nlmsg_len = inst->skb->tail - old_tail;\r\nreturn 0;\r\nnla_put_failure:\r\nPRINTR(KERN_ERR "nfnetlink_log: error creating log nlmsg\n");\r\nreturn -1;\r\n}\r\nvoid\r\nnfulnl_log_packet(struct net *net,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *li_user,\r\nconst char *prefix)\r\n{\r\nunsigned int size, data_len;\r\nstruct nfulnl_instance *inst;\r\nconst struct nf_loginfo *li;\r\nunsigned int qthreshold;\r\nunsigned int plen;\r\nstruct nfnl_log_net *log = nfnl_log_pernet(net);\r\nif (li_user && li_user->type == NF_LOG_TYPE_ULOG)\r\nli = li_user;\r\nelse\r\nli = &default_loginfo;\r\ninst = instance_lookup_get(log, li->u.ulog.group);\r\nif (!inst)\r\nreturn;\r\nplen = 0;\r\nif (prefix)\r\nplen = strlen(prefix) + 1;\r\nsize = nlmsg_total_size(sizeof(struct nfgenmsg))\r\n+ nla_total_size(sizeof(struct nfulnl_msg_packet_hdr))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n#endif\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(plen)\r\n+ nla_total_size(sizeof(struct nfulnl_msg_packet_hw))\r\n+ nla_total_size(sizeof(struct nfulnl_msg_packet_timestamp));\r\nif (in && skb_mac_header_was_set(skb)) {\r\nsize += nla_total_size(skb->dev->hard_header_len)\r\n+ nla_total_size(sizeof(u_int16_t))\r\n+ nla_total_size(sizeof(u_int16_t));\r\n}\r\nspin_lock_bh(&inst->lock);\r\nif (inst->flags & NFULNL_CFG_F_SEQ)\r\nsize += nla_total_size(sizeof(u_int32_t));\r\nif (inst->flags & NFULNL_CFG_F_SEQ_GLOBAL)\r\nsize += nla_total_size(sizeof(u_int32_t));\r\nqthreshold = inst->qthreshold;\r\nif (li->u.ulog.qthreshold)\r\nif (qthreshold > li->u.ulog.qthreshold)\r\nqthreshold = li->u.ulog.qthreshold;\r\nswitch (inst->copy_mode) {\r\ncase NFULNL_COPY_META:\r\ncase NFULNL_COPY_NONE:\r\ndata_len = 0;\r\nbreak;\r\ncase NFULNL_COPY_PACKET:\r\nif (inst->copy_range == 0\r\n|| inst->copy_range > skb->len)\r\ndata_len = skb->len;\r\nelse\r\ndata_len = inst->copy_range;\r\nsize += nla_total_size(data_len);\r\nbreak;\r\ncase NFULNL_COPY_DISABLED:\r\ndefault:\r\ngoto unlock_and_release;\r\n}\r\nif (inst->skb &&\r\nsize > skb_tailroom(inst->skb) - sizeof(struct nfgenmsg)) {\r\n__nfulnl_flush(inst);\r\n}\r\nif (!inst->skb) {\r\ninst->skb = nfulnl_alloc_skb(net, inst->peer_portid,\r\ninst->nlbufsiz, size);\r\nif (!inst->skb)\r\ngoto alloc_failure;\r\n}\r\ninst->qlen++;\r\n__build_packet_message(log, inst, skb, data_len, pf,\r\nhooknum, in, out, prefix, plen);\r\nif (inst->qlen >= qthreshold)\r\n__nfulnl_flush(inst);\r\nelse if (!timer_pending(&inst->timer)) {\r\ninstance_get(inst);\r\ninst->timer.expires = jiffies + (inst->flushtimeout*HZ/100);\r\nadd_timer(&inst->timer);\r\n}\r\nunlock_and_release:\r\nspin_unlock_bh(&inst->lock);\r\ninstance_put(inst);\r\nreturn;\r\nalloc_failure:\r\ngoto unlock_and_release;\r\n}\r\nstatic int\r\nnfulnl_rcv_nl_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct netlink_notify *n = ptr;\r\nstruct nfnl_log_net *log = nfnl_log_pernet(n->net);\r\nif (event == NETLINK_URELEASE && n->protocol == NETLINK_NETFILTER) {\r\nint i;\r\nspin_lock_bh(&log->instances_lock);\r\nfor (i = 0; i < INSTANCE_BUCKETS; i++) {\r\nstruct hlist_node *t2;\r\nstruct nfulnl_instance *inst;\r\nstruct hlist_head *head = &log->instance_table[i];\r\nhlist_for_each_entry_safe(inst, t2, head, hlist) {\r\nif (n->portid == inst->peer_portid)\r\n__instance_destroy(inst);\r\n}\r\n}\r\nspin_unlock_bh(&log->instances_lock);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int\r\nnfulnl_recv_unsupp(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const nfqa[])\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int\r\nnfulnl_recv_config(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const nfula[])\r\n{\r\nstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nu_int16_t group_num = ntohs(nfmsg->res_id);\r\nstruct nfulnl_instance *inst;\r\nstruct nfulnl_msg_config_cmd *cmd = NULL;\r\nstruct net *net = sock_net(ctnl);\r\nstruct nfnl_log_net *log = nfnl_log_pernet(net);\r\nint ret = 0;\r\nif (nfula[NFULA_CFG_CMD]) {\r\nu_int8_t pf = nfmsg->nfgen_family;\r\ncmd = nla_data(nfula[NFULA_CFG_CMD]);\r\nswitch (cmd->command) {\r\ncase NFULNL_CFG_CMD_PF_BIND:\r\nreturn nf_log_bind_pf(net, pf, &nfulnl_logger);\r\ncase NFULNL_CFG_CMD_PF_UNBIND:\r\nnf_log_unbind_pf(net, pf);\r\nreturn 0;\r\n}\r\n}\r\ninst = instance_lookup_get(log, group_num);\r\nif (inst && inst->peer_portid != NETLINK_CB(skb).portid) {\r\nret = -EPERM;\r\ngoto out_put;\r\n}\r\nif (cmd != NULL) {\r\nswitch (cmd->command) {\r\ncase NFULNL_CFG_CMD_BIND:\r\nif (inst) {\r\nret = -EBUSY;\r\ngoto out_put;\r\n}\r\ninst = instance_create(net, group_num,\r\nNETLINK_CB(skb).portid,\r\nsk_user_ns(NETLINK_CB(skb).sk));\r\nif (IS_ERR(inst)) {\r\nret = PTR_ERR(inst);\r\ngoto out;\r\n}\r\nbreak;\r\ncase NFULNL_CFG_CMD_UNBIND:\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ninstance_destroy(log, inst);\r\ngoto out_put;\r\ndefault:\r\nret = -ENOTSUPP;\r\nbreak;\r\n}\r\n}\r\nif (nfula[NFULA_CFG_MODE]) {\r\nstruct nfulnl_msg_config_mode *params;\r\nparams = nla_data(nfula[NFULA_CFG_MODE]);\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnfulnl_set_mode(inst, params->copy_mode,\r\nntohl(params->copy_range));\r\n}\r\nif (nfula[NFULA_CFG_TIMEOUT]) {\r\n__be32 timeout = nla_get_be32(nfula[NFULA_CFG_TIMEOUT]);\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnfulnl_set_timeout(inst, ntohl(timeout));\r\n}\r\nif (nfula[NFULA_CFG_NLBUFSIZ]) {\r\n__be32 nlbufsiz = nla_get_be32(nfula[NFULA_CFG_NLBUFSIZ]);\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnfulnl_set_nlbufsiz(inst, ntohl(nlbufsiz));\r\n}\r\nif (nfula[NFULA_CFG_QTHRESH]) {\r\n__be32 qthresh = nla_get_be32(nfula[NFULA_CFG_QTHRESH]);\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnfulnl_set_qthresh(inst, ntohl(qthresh));\r\n}\r\nif (nfula[NFULA_CFG_FLAGS]) {\r\n__be16 flags = nla_get_be16(nfula[NFULA_CFG_FLAGS]);\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnfulnl_set_flags(inst, ntohs(flags));\r\n}\r\nout_put:\r\ninstance_put(inst);\r\nout:\r\nreturn ret;\r\n}\r\nstatic struct hlist_node *get_first(struct net *net, struct iter_state *st)\r\n{\r\nstruct nfnl_log_net *log;\r\nif (!st)\r\nreturn NULL;\r\nlog = nfnl_log_pernet(net);\r\nfor (st->bucket = 0; st->bucket < INSTANCE_BUCKETS; st->bucket++) {\r\nstruct hlist_head *head = &log->instance_table[st->bucket];\r\nif (!hlist_empty(head))\r\nreturn rcu_dereference_bh(hlist_first_rcu(head));\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hlist_node *get_next(struct net *net, struct iter_state *st,\r\nstruct hlist_node *h)\r\n{\r\nh = rcu_dereference_bh(hlist_next_rcu(h));\r\nwhile (!h) {\r\nstruct nfnl_log_net *log;\r\nstruct hlist_head *head;\r\nif (++st->bucket >= INSTANCE_BUCKETS)\r\nreturn NULL;\r\nlog = nfnl_log_pernet(net);\r\nhead = &log->instance_table[st->bucket];\r\nh = rcu_dereference_bh(hlist_first_rcu(head));\r\n}\r\nreturn h;\r\n}\r\nstatic struct hlist_node *get_idx(struct net *net, struct iter_state *st,\r\nloff_t pos)\r\n{\r\nstruct hlist_node *head;\r\nhead = get_first(net, st);\r\nif (head)\r\nwhile (pos && (head = get_next(net, st, head)))\r\npos--;\r\nreturn pos ? NULL : head;\r\n}\r\nstatic void *seq_start(struct seq_file *s, loff_t *pos)\r\n__acquires(rcu_bh)\r\n{\r\nrcu_read_lock_bh();\r\nreturn get_idx(seq_file_net(s), s->private, *pos);\r\n}\r\nstatic void *seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn get_next(seq_file_net(s), s->private, v);\r\n}\r\nstatic void seq_stop(struct seq_file *s, void *v)\r\n__releases(rcu_bh)\r\n{\r\nrcu_read_unlock_bh();\r\n}\r\nstatic int seq_show(struct seq_file *s, void *v)\r\n{\r\nconst struct nfulnl_instance *inst = v;\r\nreturn seq_printf(s, "%5d %6d %5d %1d %5d %6d %2d\n",\r\ninst->group_num,\r\ninst->peer_portid, inst->qlen,\r\ninst->copy_mode, inst->copy_range,\r\ninst->flushtimeout, atomic_read(&inst->use));\r\n}\r\nstatic int nful_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &nful_seq_ops,\r\nsizeof(struct iter_state));\r\n}\r\nstatic int __net_init nfnl_log_net_init(struct net *net)\r\n{\r\nunsigned int i;\r\nstruct nfnl_log_net *log = nfnl_log_pernet(net);\r\nfor (i = 0; i < INSTANCE_BUCKETS; i++)\r\nINIT_HLIST_HEAD(&log->instance_table[i]);\r\nspin_lock_init(&log->instances_lock);\r\n#ifdef CONFIG_PROC_FS\r\nif (!proc_create("nfnetlink_log", 0440,\r\nnet->nf.proc_netfilter, &nful_file_ops))\r\nreturn -ENOMEM;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __net_exit nfnl_log_net_exit(struct net *net)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("nfnetlink_log", net->nf.proc_netfilter);\r\n#endif\r\nnf_log_unset(net, &nfulnl_logger);\r\n}\r\nstatic int __init nfnetlink_log_init(void)\r\n{\r\nint status = -ENOMEM;\r\nnetlink_register_notifier(&nfulnl_rtnl_notifier);\r\nstatus = nfnetlink_subsys_register(&nfulnl_subsys);\r\nif (status < 0) {\r\npr_err("log: failed to create netlink socket\n");\r\ngoto cleanup_netlink_notifier;\r\n}\r\nstatus = nf_log_register(NFPROTO_UNSPEC, &nfulnl_logger);\r\nif (status < 0) {\r\npr_err("log: failed to register logger\n");\r\ngoto cleanup_subsys;\r\n}\r\nstatus = register_pernet_subsys(&nfnl_log_net_ops);\r\nif (status < 0) {\r\npr_err("log: failed to register pernet ops\n");\r\ngoto cleanup_logger;\r\n}\r\nreturn status;\r\ncleanup_logger:\r\nnf_log_unregister(&nfulnl_logger);\r\ncleanup_subsys:\r\nnfnetlink_subsys_unregister(&nfulnl_subsys);\r\ncleanup_netlink_notifier:\r\nnetlink_unregister_notifier(&nfulnl_rtnl_notifier);\r\nreturn status;\r\n}\r\nstatic void __exit nfnetlink_log_fini(void)\r\n{\r\nunregister_pernet_subsys(&nfnl_log_net_ops);\r\nnf_log_unregister(&nfulnl_logger);\r\nnfnetlink_subsys_unregister(&nfulnl_subsys);\r\nnetlink_unregister_notifier(&nfulnl_rtnl_notifier);\r\n}
