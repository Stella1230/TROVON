void scsi_show_command(struct scsi_cmnd *srb)\r\n{\r\nchar *what = NULL;\r\nint i, unknown_cmd = 0;\r\nswitch (srb->cmnd[0]) {\r\ncase TEST_UNIT_READY:\r\nwhat = "TEST_UNIT_READY";\r\nbreak;\r\ncase REZERO_UNIT:\r\nwhat = "REZERO_UNIT";\r\nbreak;\r\ncase REQUEST_SENSE:\r\nwhat = "REQUEST_SENSE";\r\nbreak;\r\ncase FORMAT_UNIT:\r\nwhat = "FORMAT_UNIT";\r\nbreak;\r\ncase READ_BLOCK_LIMITS:\r\nwhat = "READ_BLOCK_LIMITS";\r\nbreak;\r\ncase REASSIGN_BLOCKS:\r\nwhat = "REASSIGN_BLOCKS";\r\nbreak;\r\ncase READ_6:\r\nwhat = "READ_6";\r\nbreak;\r\ncase WRITE_6:\r\nwhat = "WRITE_6";\r\nbreak;\r\ncase SEEK_6:\r\nwhat = "SEEK_6";\r\nbreak;\r\ncase READ_REVERSE:\r\nwhat = "READ_REVERSE";\r\nbreak;\r\ncase WRITE_FILEMARKS:\r\nwhat = "WRITE_FILEMARKS";\r\nbreak;\r\ncase SPACE:\r\nwhat = "SPACE";\r\nbreak;\r\ncase INQUIRY:\r\nwhat = "INQUIRY";\r\nbreak;\r\ncase RECOVER_BUFFERED_DATA:\r\nwhat = "RECOVER_BUFFERED_DATA";\r\nbreak;\r\ncase MODE_SELECT:\r\nwhat = "MODE_SELECT";\r\nbreak;\r\ncase RESERVE:\r\nwhat = "RESERVE";\r\nbreak;\r\ncase RELEASE:\r\nwhat = "RELEASE";\r\nbreak;\r\ncase COPY:\r\nwhat = "COPY";\r\nbreak;\r\ncase ERASE:\r\nwhat = "ERASE";\r\nbreak;\r\ncase MODE_SENSE:\r\nwhat = "MODE_SENSE";\r\nbreak;\r\ncase START_STOP:\r\nwhat = "START_STOP";\r\nbreak;\r\ncase RECEIVE_DIAGNOSTIC:\r\nwhat = "RECEIVE_DIAGNOSTIC";\r\nbreak;\r\ncase SEND_DIAGNOSTIC:\r\nwhat = "SEND_DIAGNOSTIC";\r\nbreak;\r\ncase ALLOW_MEDIUM_REMOVAL:\r\nwhat = "ALLOW_MEDIUM_REMOVAL";\r\nbreak;\r\ncase SET_WINDOW:\r\nwhat = "SET_WINDOW";\r\nbreak;\r\ncase READ_CAPACITY:\r\nwhat = "READ_CAPACITY";\r\nbreak;\r\ncase READ_10:\r\nwhat = "READ_10";\r\nbreak;\r\ncase WRITE_10:\r\nwhat = "WRITE_10";\r\nbreak;\r\ncase SEEK_10:\r\nwhat = "SEEK_10";\r\nbreak;\r\ncase WRITE_VERIFY:\r\nwhat = "WRITE_VERIFY";\r\nbreak;\r\ncase VERIFY:\r\nwhat = "VERIFY";\r\nbreak;\r\ncase SEARCH_HIGH:\r\nwhat = "SEARCH_HIGH";\r\nbreak;\r\ncase SEARCH_EQUAL:\r\nwhat = "SEARCH_EQUAL";\r\nbreak;\r\ncase SEARCH_LOW:\r\nwhat = "SEARCH_LOW";\r\nbreak;\r\ncase SET_LIMITS:\r\nwhat = "SET_LIMITS";\r\nbreak;\r\ncase READ_POSITION:\r\nwhat = "READ_POSITION";\r\nbreak;\r\ncase SYNCHRONIZE_CACHE:\r\nwhat = "SYNCHRONIZE_CACHE";\r\nbreak;\r\ncase LOCK_UNLOCK_CACHE:\r\nwhat = "LOCK_UNLOCK_CACHE";\r\nbreak;\r\ncase READ_DEFECT_DATA:\r\nwhat = "READ_DEFECT_DATA";\r\nbreak;\r\ncase MEDIUM_SCAN:\r\nwhat = "MEDIUM_SCAN";\r\nbreak;\r\ncase COMPARE:\r\nwhat = "COMPARE";\r\nbreak;\r\ncase COPY_VERIFY:\r\nwhat = "COPY_VERIFY";\r\nbreak;\r\ncase WRITE_BUFFER:\r\nwhat = "WRITE_BUFFER";\r\nbreak;\r\ncase READ_BUFFER:\r\nwhat = "READ_BUFFER";\r\nbreak;\r\ncase UPDATE_BLOCK:\r\nwhat = "UPDATE_BLOCK";\r\nbreak;\r\ncase READ_LONG:\r\nwhat = "READ_LONG";\r\nbreak;\r\ncase WRITE_LONG:\r\nwhat = "WRITE_LONG";\r\nbreak;\r\ncase CHANGE_DEFINITION:\r\nwhat = "CHANGE_DEFINITION";\r\nbreak;\r\ncase WRITE_SAME:\r\nwhat = "WRITE_SAME";\r\nbreak;\r\ncase GPCMD_READ_SUBCHANNEL:\r\nwhat = "READ SUBCHANNEL";\r\nbreak;\r\ncase READ_TOC:\r\nwhat = "READ_TOC";\r\nbreak;\r\ncase GPCMD_READ_HEADER:\r\nwhat = "READ HEADER";\r\nbreak;\r\ncase GPCMD_PLAY_AUDIO_10:\r\nwhat = "PLAY AUDIO (10)";\r\nbreak;\r\ncase GPCMD_PLAY_AUDIO_MSF:\r\nwhat = "PLAY AUDIO MSF";\r\nbreak;\r\ncase GPCMD_GET_EVENT_STATUS_NOTIFICATION:\r\nwhat = "GET EVENT/STATUS NOTIFICATION";\r\nbreak;\r\ncase GPCMD_PAUSE_RESUME:\r\nwhat = "PAUSE/RESUME";\r\nbreak;\r\ncase LOG_SELECT:\r\nwhat = "LOG_SELECT";\r\nbreak;\r\ncase LOG_SENSE:\r\nwhat = "LOG_SENSE";\r\nbreak;\r\ncase GPCMD_STOP_PLAY_SCAN:\r\nwhat = "STOP PLAY/SCAN";\r\nbreak;\r\ncase GPCMD_READ_DISC_INFO:\r\nwhat = "READ DISC INFORMATION";\r\nbreak;\r\ncase GPCMD_READ_TRACK_RZONE_INFO:\r\nwhat = "READ TRACK INFORMATION";\r\nbreak;\r\ncase GPCMD_RESERVE_RZONE_TRACK:\r\nwhat = "RESERVE TRACK";\r\nbreak;\r\ncase GPCMD_SEND_OPC:\r\nwhat = "SEND OPC";\r\nbreak;\r\ncase MODE_SELECT_10:\r\nwhat = "MODE_SELECT_10";\r\nbreak;\r\ncase GPCMD_REPAIR_RZONE_TRACK:\r\nwhat = "REPAIR TRACK";\r\nbreak;\r\ncase 0x59:\r\nwhat = "READ MASTER CUE";\r\nbreak;\r\ncase MODE_SENSE_10:\r\nwhat = "MODE_SENSE_10";\r\nbreak;\r\ncase GPCMD_CLOSE_TRACK:\r\nwhat = "CLOSE TRACK/SESSION";\r\nbreak;\r\ncase 0x5C:\r\nwhat = "READ BUFFER CAPACITY";\r\nbreak;\r\ncase 0x5D:\r\nwhat = "SEND CUE SHEET";\r\nbreak;\r\ncase GPCMD_BLANK:\r\nwhat = "BLANK";\r\nbreak;\r\ncase REPORT_LUNS:\r\nwhat = "REPORT LUNS";\r\nbreak;\r\ncase MOVE_MEDIUM:\r\nwhat = "MOVE_MEDIUM or PLAY AUDIO (12)";\r\nbreak;\r\ncase READ_12:\r\nwhat = "READ_12";\r\nbreak;\r\ncase WRITE_12:\r\nwhat = "WRITE_12";\r\nbreak;\r\ncase WRITE_VERIFY_12:\r\nwhat = "WRITE_VERIFY_12";\r\nbreak;\r\ncase SEARCH_HIGH_12:\r\nwhat = "SEARCH_HIGH_12";\r\nbreak;\r\ncase SEARCH_EQUAL_12:\r\nwhat = "SEARCH_EQUAL_12";\r\nbreak;\r\ncase SEARCH_LOW_12:\r\nwhat = "SEARCH_LOW_12";\r\nbreak;\r\ncase SEND_VOLUME_TAG:\r\nwhat = "SEND_VOLUME_TAG";\r\nbreak;\r\ncase READ_ELEMENT_STATUS:\r\nwhat = "READ_ELEMENT_STATUS";\r\nbreak;\r\ncase GPCMD_READ_CD_MSF:\r\nwhat = "READ CD MSF";\r\nbreak;\r\ncase GPCMD_SCAN:\r\nwhat = "SCAN";\r\nbreak;\r\ncase GPCMD_SET_SPEED:\r\nwhat = "SET CD SPEED";\r\nbreak;\r\ncase GPCMD_MECHANISM_STATUS:\r\nwhat = "MECHANISM STATUS";\r\nbreak;\r\ncase GPCMD_READ_CD:\r\nwhat = "READ CD";\r\nbreak;\r\ncase 0xE1:\r\nwhat = "WRITE CONTINUE";\r\nbreak;\r\ncase WRITE_LONG_2:\r\nwhat = "WRITE_LONG_2";\r\nbreak;\r\ncase VENDOR_CMND:\r\nwhat = "Realtek's vendor command";\r\nbreak;\r\ndefault:\r\nwhat = "(unknown command)"; unknown_cmd = 1;\r\nbreak;\r\n}\r\nif (srb->cmnd[0] != TEST_UNIT_READY)\r\nRTSX_DEBUGP("Command %s (%d bytes)\n", what, srb->cmd_len);\r\nif (unknown_cmd) {\r\nRTSX_DEBUGP("");\r\nfor (i = 0; i < srb->cmd_len && i < 16; i++)\r\nRTSX_DEBUGPN(" %02x", srb->cmnd[i]);\r\nRTSX_DEBUGPN("\n");\r\n}\r\n}\r\nvoid set_sense_type(struct rtsx_chip *chip, unsigned int lun, int sense_type)\r\n{\r\nswitch (sense_type) {\r\ncase SENSE_TYPE_MEDIA_CHANGE:\r\nset_sense_data(chip, lun, CUR_ERR, 0x06, 0, 0x28, 0, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_MEDIA_NOT_PRESENT:\r\nset_sense_data(chip, lun, CUR_ERR, 0x02, 0, 0x3A, 0, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_MEDIA_LBA_OVER_RANGE:\r\nset_sense_data(chip, lun, CUR_ERR, 0x05, 0, 0x21, 0, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT:\r\nset_sense_data(chip, lun, CUR_ERR, 0x05, 0, 0x25, 0, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_MEDIA_WRITE_PROTECT:\r\nset_sense_data(chip, lun, CUR_ERR, 0x07, 0, 0x27, 0, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR:\r\nset_sense_data(chip, lun, CUR_ERR, 0x03, 0, 0x11, 0, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_MEDIA_WRITE_ERR:\r\nset_sense_data(chip, lun, CUR_ERR, 0x03, 0, 0x0C, 0x02, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_MEDIA_INVALID_CMD_FIELD:\r\nset_sense_data(chip, lun, CUR_ERR, ILGAL_REQ, 0,\r\nASC_INVLD_CDB, ASCQ_INVLD_CDB, CDB_ILLEGAL, 1);\r\nbreak;\r\ncase SENSE_TYPE_FORMAT_IN_PROGRESS:\r\nset_sense_data(chip, lun, CUR_ERR, 0x02, 0, 0x04, 0x04, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_FORMAT_CMD_FAILED:\r\nset_sense_data(chip, lun, CUR_ERR, 0x03, 0, 0x31, 0x01, 0, 0);\r\nbreak;\r\n#ifdef SUPPORT_MAGIC_GATE\r\ncase SENSE_TYPE_MG_KEY_FAIL_NOT_ESTAB:\r\nset_sense_data(chip, lun, CUR_ERR, 0x05, 0, 0x6F, 0x02, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN:\r\nset_sense_data(chip, lun, CUR_ERR, 0x05, 0, 0x6F, 0x00, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM:\r\nset_sense_data(chip, lun, CUR_ERR, 0x02, 0, 0x30, 0x00, 0, 0);\r\nbreak;\r\ncase SENSE_TYPE_MG_WRITE_ERR:\r\nset_sense_data(chip, lun, CUR_ERR, 0x03, 0, 0x0C, 0x00, 0, 0);\r\nbreak;\r\n#endif\r\n#ifdef SUPPORT_SD_LOCK\r\ncase SENSE_TYPE_MEDIA_READ_FORBIDDEN:\r\nset_sense_data(chip, lun, CUR_ERR, 0x07, 0, 0x11, 0x13, 0, 0);\r\nbreak;\r\n#endif\r\ncase SENSE_TYPE_NO_SENSE:\r\ndefault:\r\nset_sense_data(chip, lun, CUR_ERR, 0, 0, 0, 0, 0, 0);\r\nbreak;\r\n}\r\n}\r\nvoid set_sense_data(struct rtsx_chip *chip, unsigned int lun, u8 err_code,\r\nu8 sense_key, u32 info, u8 asc, u8 ascq, u8 sns_key_info0,\r\nu16 sns_key_info1)\r\n{\r\nstruct sense_data_t *sense = &(chip->sense_buffer[lun]);\r\nsense->err_code = err_code;\r\nsense->sense_key = sense_key;\r\nsense->info[0] = (u8)(info >> 24);\r\nsense->info[1] = (u8)(info >> 16);\r\nsense->info[2] = (u8)(info >> 8);\r\nsense->info[3] = (u8)info;\r\nsense->ad_sense_len = sizeof(struct sense_data_t) - 8;\r\nsense->asc = asc;\r\nsense->ascq = ascq;\r\nif (sns_key_info0 != 0) {\r\nsense->sns_key_info[0] = SKSV | sns_key_info0;\r\nsense->sns_key_info[1] = (sns_key_info1 & 0xf0) >> 8;\r\nsense->sns_key_info[2] = sns_key_info1 & 0x0f;\r\n}\r\n}\r\nstatic int test_unit_ready(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned int lun = SCSI_LUN(srb);\r\nif (!check_card_ready(chip, lun)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nreturn TRANSPORT_FAILED;\r\n}\r\nif (!(CHK_BIT(chip->lun_mc, lun))) {\r\nSET_BIT(chip->lun_mc, lun);\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_CHANGE);\r\nreturn TRANSPORT_FAILED;\r\n}\r\n#ifdef SUPPORT_SD_LOCK\r\nif (get_lun_card(chip, SCSI_LUN(srb)) == SD_CARD) {\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nif (sd_card->sd_lock_notify) {\r\nsd_card->sd_lock_notify = 0;\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_CHANGE);\r\nreturn TRANSPORT_FAILED;\r\n} else if (sd_card->sd_lock_status & SD_LOCKED) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_READ_FORBIDDEN);\r\nreturn TRANSPORT_FAILED;\r\n}\r\n}\r\n#endif\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int inquiry(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned int lun = SCSI_LUN(srb);\r\nchar *inquiry_default = (char *)"Generic-xD/SD/M.S. 1.00 ";\r\nchar *inquiry_sdms = (char *)"Generic-SD/MemoryStick 1.00 ";\r\nchar *inquiry_sd = (char *)"Generic-SD/MMC 1.00 ";\r\nchar *inquiry_ms = (char *)"Generic-MemoryStick 1.00 ";\r\nchar *inquiry_string;\r\nunsigned char sendbytes;\r\nunsigned char *buf;\r\nu8 card = get_lun_card(chip, lun);\r\nint pro_formatter_flag = 0;\r\nunsigned char inquiry_buf[] = {\r\nQULIFIRE|DRCT_ACCESS_DEV,\r\nRMB_DISC|0x0D,\r\n0x00,\r\n0x01,\r\n0x1f,\r\n0x02,\r\n0,\r\nREL_ADR|WBUS_32|WBUS_16|SYNC|LINKED|CMD_QUE|SFT_RE,\r\n};\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nif (chip->lun2card[lun] == SD_CARD)\r\ninquiry_string = inquiry_sd;\r\nelse\r\ninquiry_string = inquiry_ms;\r\n} else if (CHECK_LUN_MODE(chip, SD_MS_1LUN)) {\r\ninquiry_string = inquiry_sdms;\r\n} else {\r\ninquiry_string = inquiry_default;\r\n}\r\nbuf = vmalloc(scsi_bufflen(srb));\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\n#ifdef SUPPORT_MAGIC_GATE\r\nif ((chip->mspro_formatter_enable) &&\r\n(chip->lun2card[lun] & MS_CARD))\r\n#else\r\nif (chip->mspro_formatter_enable)\r\n#endif\r\n{\r\nif (!card || (card == MS_CARD))\r\npro_formatter_flag = 1;\r\n}\r\nif (pro_formatter_flag) {\r\nif (scsi_bufflen(srb) < 56)\r\nsendbytes = (unsigned char)(scsi_bufflen(srb));\r\nelse\r\nsendbytes = 56;\r\n} else {\r\nif (scsi_bufflen(srb) < 36)\r\nsendbytes = (unsigned char)(scsi_bufflen(srb));\r\nelse\r\nsendbytes = 36;\r\n}\r\nif (sendbytes > 8) {\r\nmemcpy(buf, inquiry_buf, 8);\r\nmemcpy(buf + 8, inquiry_string, sendbytes - 8);\r\nif (pro_formatter_flag) {\r\nbuf[4] = 0x33;\r\n}\r\n} else {\r\nmemcpy(buf, inquiry_buf, sendbytes);\r\n}\r\nif (pro_formatter_flag) {\r\nif (sendbytes > 36)\r\nmemcpy(buf + 36, formatter_inquiry_str, sendbytes - 36);\r\n}\r\nscsi_set_resid(srb, 0);\r\nrtsx_stor_set_xfer_buf(buf, scsi_bufflen(srb), srb);\r\nvfree(buf);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int start_stop_unit(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned int lun = SCSI_LUN(srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb));\r\nif (srb->cmnd[1] == 1)\r\nreturn TRANSPORT_GOOD;\r\nswitch (srb->cmnd[0x4]) {\r\ncase STOP_MEDIUM:\r\nreturn TRANSPORT_GOOD;\r\ncase UNLOAD_MEDIUM:\r\nif (check_card_ready(chip, lun))\r\neject_card(chip, lun);\r\nreturn TRANSPORT_GOOD;\r\ncase MAKE_MEDIUM_READY:\r\ncase LOAD_MEDIUM:\r\nif (check_card_ready(chip, lun)) {\r\nreturn TRANSPORT_GOOD;\r\n} else {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbreak;\r\n}\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\n}\r\nstatic int allow_medium_removal(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint prevent;\r\nprevent = srb->cmnd[4] & 0x1;\r\nscsi_set_resid(srb, 0);\r\nif (prevent) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int request_sense(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nstruct sense_data_t *sense;\r\nunsigned int lun = SCSI_LUN(srb);\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nunsigned char *tmp, *buf;\r\nsense = &(chip->sense_buffer[lun]);\r\nif ((get_lun_card(chip, lun) == MS_CARD) &&\r\nms_card->pro_under_formatting) {\r\nif (ms_card->format_status == FORMAT_SUCCESS) {\r\nset_sense_type(chip, lun, SENSE_TYPE_NO_SENSE);\r\nms_card->pro_under_formatting = 0;\r\nms_card->progress = 0;\r\n} else if (ms_card->format_status == FORMAT_IN_PROGRESS) {\r\nset_sense_data(chip, lun, CUR_ERR, 0x02, 0, 0x04, 0x04,\r\n0, (u16)(ms_card->progress));\r\n} else {\r\nset_sense_type(chip, lun, SENSE_TYPE_FORMAT_CMD_FAILED);\r\nms_card->pro_under_formatting = 0;\r\nms_card->progress = 0;\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\n}\r\nbuf = vmalloc(scsi_bufflen(srb));\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\ntmp = (unsigned char *)sense;\r\nmemcpy(buf, tmp, scsi_bufflen(srb));\r\nrtsx_stor_set_xfer_buf(buf, scsi_bufflen(srb), srb);\r\nvfree(buf);\r\nscsi_set_resid(srb, 0);\r\nset_sense_type(chip, lun, SENSE_TYPE_NO_SENSE);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic void ms_mode_sense(struct rtsx_chip *chip, u8 cmd,\r\nint lun, u8 *buf, int buf_len)\r\n{\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nint sys_info_offset;\r\nint data_size = buf_len;\r\nint support_format = 0;\r\nint i = 0;\r\nif (cmd == MODE_SENSE) {\r\nsys_info_offset = 8;\r\nif (data_size > 0x68)\r\ndata_size = 0x68;\r\nbuf[i++] = 0x67;\r\n} else {\r\nsys_info_offset = 12;\r\nif (data_size > 0x6C)\r\ndata_size = 0x6C;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x6A;\r\n}\r\nif (check_card_ready(chip, lun)) {\r\nif (CHK_MSXC(ms_card)) {\r\nsupport_format = 1;\r\nbuf[i++] = 0x40;\r\n} else if (CHK_MSPRO(ms_card)) {\r\nsupport_format = 1;\r\nbuf[i++] = 0x20;\r\n} else {\r\nbuf[i++] = 0x10;\r\n}\r\nif (check_card_wp(chip, lun))\r\nbuf[i++] = 0x80;\r\nelse\r\nbuf[i++] = 0x00;\r\n} else {\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x00;\r\n}\r\nbuf[i++] = 0x00;\r\nif (cmd == MODE_SENSE_10) {\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x00;\r\nif (data_size >= 9)\r\nbuf[i++] = 0x20;\r\nif (data_size >= 10)\r\nbuf[i++] = 0x62;\r\nif (data_size >= 11)\r\nbuf[i++] = 0x00;\r\nif (data_size >= 12) {\r\nif (support_format)\r\nbuf[i++] = 0xC0;\r\nelse\r\nbuf[i++] = 0x00;\r\n}\r\n} else {\r\nif (data_size >= 5)\r\nbuf[i++] = 0x20;\r\nif (data_size >= 6)\r\nbuf[i++] = 0x62;\r\nif (data_size >= 7)\r\nbuf[i++] = 0x00;\r\nif (data_size >= 8) {\r\nif (support_format)\r\nbuf[i++] = 0xC0;\r\nelse\r\nbuf[i++] = 0x00;\r\n}\r\n}\r\nif (data_size > sys_info_offset) {\r\nint len = data_size - sys_info_offset;\r\nlen = (len < 96) ? len : 96;\r\nmemcpy(buf + sys_info_offset, ms_card->raw_sys_info, len);\r\n}\r\n}\r\nstatic int mode_sense(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned int lun = SCSI_LUN(srb);\r\nunsigned int dataSize;\r\nint status;\r\nint pro_formatter_flag;\r\nunsigned char pageCode, *buf;\r\nu8 card = get_lun_card(chip, lun);\r\n#ifndef SUPPORT_MAGIC_GATE\r\nif (!check_card_ready(chip, lun)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nscsi_set_resid(srb, scsi_bufflen(srb));\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n#endif\r\npro_formatter_flag = 0;\r\ndataSize = 8;\r\n#ifdef SUPPORT_MAGIC_GATE\r\nif ((chip->lun2card[lun] & MS_CARD)) {\r\nif (!card || (card == MS_CARD)) {\r\ndataSize = 108;\r\nif (chip->mspro_formatter_enable)\r\npro_formatter_flag = 1;\r\n}\r\n}\r\n#else\r\nif (card == MS_CARD) {\r\nif (chip->mspro_formatter_enable) {\r\npro_formatter_flag = 1;\r\ndataSize = 108;\r\n}\r\n}\r\n#endif\r\nbuf = kmalloc(dataSize, GFP_KERNEL);\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\npageCode = srb->cmnd[2] & 0x3f;\r\nif ((pageCode == 0x3F) || (pageCode == 0x1C) ||\r\n(pageCode == 0x00) ||\r\n(pro_formatter_flag && (pageCode == 0x20))) {\r\nif (srb->cmnd[0] == MODE_SENSE) {\r\nif ((pageCode == 0x3F) || (pageCode == 0x20)) {\r\nms_mode_sense(chip, srb->cmnd[0],\r\nlun, buf, dataSize);\r\n} else {\r\ndataSize = 4;\r\nbuf[0] = 0x03;\r\nbuf[1] = 0x00;\r\nif (check_card_wp(chip, lun))\r\nbuf[2] = 0x80;\r\nelse\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\n}\r\n} else {\r\nif ((pageCode == 0x3F) || (pageCode == 0x20)) {\r\nms_mode_sense(chip, srb->cmnd[0],\r\nlun, buf, dataSize);\r\n} else {\r\ndataSize = 8;\r\nbuf[0] = 0x00;\r\nbuf[1] = 0x06;\r\nbuf[2] = 0x00;\r\nif (check_card_wp(chip, lun))\r\nbuf[3] = 0x80;\r\nelse\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x00;\r\nbuf[5] = 0x00;\r\nbuf[6] = 0x00;\r\nbuf[7] = 0x00;\r\n}\r\n}\r\nstatus = TRANSPORT_GOOD;\r\n} else {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nscsi_set_resid(srb, scsi_bufflen(srb));\r\nstatus = TRANSPORT_FAILED;\r\n}\r\nif (status == TRANSPORT_GOOD) {\r\nunsigned int len = min_t(unsigned int, scsi_bufflen(srb),\r\ndataSize);\r\nrtsx_stor_set_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\n}\r\nkfree(buf);\r\nreturn status;\r\n}\r\nstatic int read_write(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\n#ifdef SUPPORT_SD_LOCK\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\n#endif\r\nunsigned int lun = SCSI_LUN(srb);\r\nint retval;\r\nu32 start_sec;\r\nu16 sec_cnt;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nif (!check_card_ready(chip, lun) || (get_card_size(chip, lun) == 0)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (!(CHK_BIT(chip->lun_mc, lun))) {\r\nSET_BIT(chip->lun_mc, lun);\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_CHANGE);\r\nreturn TRANSPORT_FAILED;\r\n}\r\n#ifdef SUPPORT_SD_LOCK\r\nif (sd_card->sd_erase_status) {\r\nRTSX_DEBUGP("SD card being erased!\n");\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_READ_FORBIDDEN);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (get_lun_card(chip, lun) == SD_CARD) {\r\nif (sd_card->sd_lock_status & SD_LOCKED) {\r\nRTSX_DEBUGP("SD card locked!\n");\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_READ_FORBIDDEN);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\n#endif\r\nif ((srb->cmnd[0] == READ_10) || (srb->cmnd[0] == WRITE_10)) {\r\nstart_sec = ((u32)srb->cmnd[2] << 24) |\r\n((u32)srb->cmnd[3] << 16) |\r\n((u32)srb->cmnd[4] << 8) | ((u32)srb->cmnd[5]);\r\nsec_cnt = ((u16)(srb->cmnd[7]) << 8) | srb->cmnd[8];\r\n} else if ((srb->cmnd[0] == READ_6) || (srb->cmnd[0] == WRITE_6)) {\r\nstart_sec = ((u32)(srb->cmnd[1] & 0x1F) << 16) |\r\n((u32)srb->cmnd[2] << 8) | ((u32)srb->cmnd[3]);\r\nsec_cnt = srb->cmnd[4];\r\n} else if ((srb->cmnd[0] == VENDOR_CMND) &&\r\n(srb->cmnd[1] == SCSI_APP_CMD) &&\r\n((srb->cmnd[2] == PP_READ10) || (srb->cmnd[2] == PP_WRITE10))) {\r\nstart_sec = ((u32)srb->cmnd[4] << 24) |\r\n((u32)srb->cmnd[5] << 16) |\r\n((u32)srb->cmnd[6] << 8) | ((u32)srb->cmnd[7]);\r\nsec_cnt = ((u16)(srb->cmnd[9]) << 8) | srb->cmnd[10];\r\n} else {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif ((start_sec > get_card_size(chip, lun)) ||\r\n((start_sec + sec_cnt) > get_card_size(chip, lun))) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LBA_OVER_RANGE);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (sec_cnt == 0) {\r\nscsi_set_resid(srb, 0);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nif (chip->rw_fail_cnt[lun] == 3) {\r\nRTSX_DEBUGP("read/write fail three times in succession\n");\r\nif (srb->sc_data_direction == DMA_FROM_DEVICE)\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nelse\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (srb->sc_data_direction == DMA_TO_DEVICE) {\r\nif (check_card_wp(chip, lun)) {\r\nRTSX_DEBUGP("Write protected card!\n");\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_PROTECT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nretval = card_rw(srb, chip, start_sec, sec_cnt);\r\nif (retval != STATUS_SUCCESS) {\r\nif (chip->need_release & chip->lun2card[lun]) {\r\nchip->rw_fail_cnt[lun] = 0;\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\n} else {\r\nchip->rw_fail_cnt[lun]++;\r\nif (srb->sc_data_direction == DMA_FROM_DEVICE)\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nelse\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\n}\r\nretval = TRANSPORT_FAILED;\r\nTRACE_GOTO(chip, Exit);\r\n} else {\r\nchip->rw_fail_cnt[lun] = 0;\r\nretval = TRANSPORT_GOOD;\r\n}\r\nscsi_set_resid(srb, 0);\r\nExit:\r\nreturn retval;\r\n}\r\nstatic int read_format_capacity(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned char *buf;\r\nunsigned int lun = SCSI_LUN(srb);\r\nunsigned int buf_len;\r\nu8 card = get_lun_card(chip, lun);\r\nu32 card_size;\r\nint desc_cnt;\r\nint i = 0;\r\nif (!check_card_ready(chip, lun)) {\r\nif (!chip->mspro_formatter_enable) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nbuf_len = (scsi_bufflen(srb) > 12) ? 0x14 : 12;\r\nbuf = kmalloc(buf_len, GFP_KERNEL);\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nbuf[i++] = 0;\r\nbuf[i++] = 0;\r\nbuf[i++] = 0;\r\nif ((buf_len > 12) && chip->mspro_formatter_enable &&\r\n(chip->lun2card[lun] & MS_CARD) &&\r\n(!card || (card == MS_CARD))) {\r\nbuf[i++] = 0x10;\r\ndesc_cnt = 2;\r\n} else {\r\nbuf[i++] = 0x08;\r\ndesc_cnt = 1;\r\n}\r\nwhile (desc_cnt) {\r\nif (check_card_ready(chip, lun)) {\r\ncard_size = get_card_size(chip, lun);\r\nbuf[i++] = (unsigned char)(card_size >> 24);\r\nbuf[i++] = (unsigned char)(card_size >> 16);\r\nbuf[i++] = (unsigned char)(card_size >> 8);\r\nbuf[i++] = (unsigned char)card_size;\r\nif (desc_cnt == 2)\r\nbuf[i++] = 2;\r\nelse\r\nbuf[i++] = 0;\r\n} else {\r\nbuf[i++] = 0xFF;\r\nbuf[i++] = 0xFF;\r\nbuf[i++] = 0xFF;\r\nbuf[i++] = 0xFF;\r\nif (desc_cnt == 2)\r\nbuf[i++] = 3;\r\nelse\r\nbuf[i++] = 0;\r\n}\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x02;\r\nbuf[i++] = 0x00;\r\ndesc_cnt--;\r\n}\r\nbuf_len = min_t(unsigned int, scsi_bufflen(srb), buf_len);\r\nrtsx_stor_set_xfer_buf(buf, buf_len, srb);\r\nkfree(buf);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - buf_len);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int read_capacity(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned char *buf;\r\nunsigned int lun = SCSI_LUN(srb);\r\nu32 card_size;\r\nif (!check_card_ready(chip, lun)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (!(CHK_BIT(chip->lun_mc, lun))) {\r\nSET_BIT(chip->lun_mc, lun);\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_CHANGE);\r\nreturn TRANSPORT_FAILED;\r\n}\r\nbuf = kmalloc(8, GFP_KERNEL);\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\ncard_size = get_card_size(chip, lun);\r\nbuf[0] = (unsigned char)((card_size - 1) >> 24);\r\nbuf[1] = (unsigned char)((card_size - 1) >> 16);\r\nbuf[2] = (unsigned char)((card_size - 1) >> 8);\r\nbuf[3] = (unsigned char)(card_size - 1);\r\nbuf[4] = 0x00;\r\nbuf[5] = 0x00;\r\nbuf[6] = 0x02;\r\nbuf[7] = 0x00;\r\nrtsx_stor_set_xfer_buf(buf, scsi_bufflen(srb), srb);\r\nkfree(buf);\r\nscsi_set_resid(srb, 0);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int read_eeprom(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned short len, i;\r\nint retval;\r\nu8 *buf;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nlen = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\r\nbuf = vmalloc(len);\r\nif (!buf)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nfor (i = 0; i < len; i++) {\r\nretval = spi_read_eeprom(chip, i, buf + i);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\r\nrtsx_stor_set_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nvfree(buf);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int write_eeprom(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned short len, i;\r\nint retval;\r\nu8 *buf;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nlen = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (len == 511) {\r\nretval = spi_erase_eeprom_chip(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n} else {\r\nlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb),\r\nlen);\r\nbuf = vmalloc(len);\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nrtsx_stor_get_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nfor (i = 0; i < len; i++) {\r\nretval = spi_write_eeprom(chip, i, buf[i]);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nvfree(buf);\r\n}\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int read_mem(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned short addr, len, i;\r\nint retval;\r\nu8 *buf;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\naddr = ((u16)srb->cmnd[2] << 8) | srb->cmnd[3];\r\nlen = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\r\nif (addr < 0xFC00) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbuf = vmalloc(len);\r\nif (!buf)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nfor (i = 0; i < len; i++) {\r\nretval = rtsx_read_register(chip, addr + i, buf + i);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\r\nrtsx_stor_set_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nvfree(buf);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int write_mem(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned short addr, len, i;\r\nint retval;\r\nu8 *buf;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\naddr = ((u16)srb->cmnd[2] << 8) | srb->cmnd[3];\r\nlen = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\r\nif (addr < 0xFC00) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\r\nbuf = vmalloc(len);\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nrtsx_stor_get_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nfor (i = 0; i < len; i++) {\r\nretval = rtsx_write_register(chip, addr + i, 0xFF, buf[i]);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nvfree(buf);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int get_sd_csd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nunsigned int lun = SCSI_LUN(srb);\r\nif (!check_card_ready(chip, lun)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (get_lun_card(chip, lun) != SD_CARD) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nscsi_set_resid(srb, 0);\r\nrtsx_stor_set_xfer_buf(sd_card->raw_csd, scsi_bufflen(srb), srb);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int toggle_gpio_cmd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nu8 gpio = srb->cmnd[2];\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nif (gpio > 3)\r\ngpio = 1;\r\ntoggle_gpio(chip, gpio);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int trace_msg_cmd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned char *ptr, *buf = NULL;\r\nint i, msg_cnt;\r\nu8 clear;\r\nunsigned int buf_len;\r\nbuf_len = 4 + ((2 + MSG_FUNC_LEN + MSG_FILE_LEN + TIME_VAL_LEN) *\r\nTRACE_ITEM_CNT);\r\nif ((scsi_bufflen(srb) < buf_len) || (scsi_sglist(srb) == NULL)) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nclear = srb->cmnd[2];\r\nbuf = vmalloc(scsi_bufflen(srb));\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nptr = buf;\r\nif (chip->trace_msg[chip->msg_idx].valid)\r\nmsg_cnt = TRACE_ITEM_CNT;\r\nelse\r\nmsg_cnt = chip->msg_idx;\r\n*(ptr++) = (u8)(msg_cnt >> 24);\r\n*(ptr++) = (u8)(msg_cnt >> 16);\r\n*(ptr++) = (u8)(msg_cnt >> 8);\r\n*(ptr++) = (u8)msg_cnt;\r\nRTSX_DEBUGP("Trace message count is %d\n", msg_cnt);\r\nfor (i = 1; i <= msg_cnt; i++) {\r\nint j, idx;\r\nidx = chip->msg_idx - i;\r\nif (idx < 0)\r\nidx += TRACE_ITEM_CNT;\r\n*(ptr++) = (u8)(chip->trace_msg[idx].line >> 8);\r\n*(ptr++) = (u8)(chip->trace_msg[idx].line);\r\nfor (j = 0; j < MSG_FUNC_LEN; j++)\r\n*(ptr++) = chip->trace_msg[idx].func[j];\r\nfor (j = 0; j < MSG_FILE_LEN; j++)\r\n*(ptr++) = chip->trace_msg[idx].file[j];\r\nfor (j = 0; j < TIME_VAL_LEN; j++)\r\n*(ptr++) = chip->trace_msg[idx].timeval_buf[j];\r\n}\r\nrtsx_stor_set_xfer_buf(buf, scsi_bufflen(srb), srb);\r\nvfree(buf);\r\nif (clear) {\r\nchip->msg_idx = 0;\r\nfor (i = 0; i < TRACE_ITEM_CNT; i++)\r\nchip->trace_msg[i].valid = 0;\r\n}\r\nscsi_set_resid(srb, 0);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int read_host_reg(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nu8 addr, buf[4];\r\nu32 val;\r\nunsigned int len;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\naddr = srb->cmnd[4];\r\nval = rtsx_readl(chip, addr);\r\nRTSX_DEBUGP("Host register (0x%x): 0x%x\n", addr, val);\r\nbuf[0] = (u8)(val >> 24);\r\nbuf[1] = (u8)(val >> 16);\r\nbuf[2] = (u8)(val >> 8);\r\nbuf[3] = (u8)val;\r\nlen = min_t(unsigned int, scsi_bufflen(srb), 4);\r\nrtsx_stor_set_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int write_host_reg(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nu8 addr, buf[4];\r\nu32 val;\r\nunsigned int len;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\naddr = srb->cmnd[4];\r\nlen = min_t(unsigned int, scsi_bufflen(srb), 4);\r\nrtsx_stor_get_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nval = ((u32)buf[0] << 24) | ((u32)buf[1] << 16) | ((u32)buf[2]\r\n<< 8) | buf[3];\r\nrtsx_writel(chip, addr, val);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int set_variable(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned lun = SCSI_LUN(srb);\r\nif (srb->cmnd[3] == 1) {\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nswitch (srb->cmnd[4]) {\r\ncase XD_CARD:\r\nxd_card->xd_clock = srb->cmnd[5];\r\nbreak;\r\ncase SD_CARD:\r\nsd_card->sd_clock = srb->cmnd[5];\r\nbreak;\r\ncase MS_CARD:\r\nms_card->ms_clock = srb->cmnd[5];\r\nbreak;\r\ndefault:\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n} else if (srb->cmnd[3] == 2) {\r\nif (srb->cmnd[4]) {\r\nchip->blink_led = 1;\r\n} else {\r\nint retval;\r\nchip->blink_led = 0;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en &&\r\n(rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nturn_off_led(chip, LED_GPIO);\r\n}\r\n} else {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int get_variable(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned int lun = SCSI_LUN(srb);\r\nif (srb->cmnd[3] == 1) {\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nu8 tmp;\r\nswitch (srb->cmnd[4]) {\r\ncase XD_CARD:\r\ntmp = (u8)(xd_card->xd_clock);\r\nbreak;\r\ncase SD_CARD:\r\ntmp = (u8)(sd_card->sd_clock);\r\nbreak;\r\ncase MS_CARD:\r\ntmp = (u8)(ms_card->ms_clock);\r\nbreak;\r\ndefault:\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nrtsx_stor_set_xfer_buf(&tmp, 1, srb);\r\n} else if (srb->cmnd[3] == 2) {\r\nu8 tmp = chip->blink_led;\r\nrtsx_stor_set_xfer_buf(&tmp, 1, srb);\r\n} else {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int dma_access_ring_buffer(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nunsigned int lun = SCSI_LUN(srb);\r\nu16 len;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nlen = ((u16)(srb->cmnd[4]) << 8) | srb->cmnd[5];\r\nlen = min_t(u16, len, scsi_bufflen(srb));\r\nif (srb->sc_data_direction == DMA_FROM_DEVICE)\r\nRTSX_DEBUGP("Read from device\n");\r\nelse\r\nRTSX_DEBUGP("Write to device\n");\r\nretval = rtsx_transfer_data(chip, 0, scsi_sglist(srb), len,\r\nscsi_sg_count(srb), srb->sc_data_direction, 1000);\r\nif (retval < 0) {\r\nif (srb->sc_data_direction == DMA_FROM_DEVICE)\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nelse\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nscsi_set_resid(srb, 0);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int get_dev_status(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nint buf_len;\r\nunsigned int lun = SCSI_LUN(srb);\r\nu8 card = get_lun_card(chip, lun);\r\nu8 status[32];\r\n#ifdef SUPPORT_OCP\r\nu8 oc_now_mask = 0, oc_ever_mask = 0;\r\n#endif\r\nmemset(status, 0, 32);\r\nstatus[0] = (u8)(chip->product_id);\r\nstatus[1] = chip->ic_version;\r\nif (chip->auto_delink_en)\r\nstatus[2] = 0x10;\r\nelse\r\nstatus[2] = 0x00;\r\nstatus[3] = 20;\r\nstatus[4] = 10;\r\nstatus[5] = 05;\r\nstatus[6] = 21;\r\nif (chip->card_wp)\r\nstatus[7] = 0x20;\r\nelse\r\nstatus[7] = 0x00;\r\n#ifdef SUPPORT_OCP\r\nstatus[8] = 0;\r\nif (CHECK_LUN_MODE(chip,\r\nSD_MS_2LUN) && (chip->lun2card[lun] == MS_CARD)) {\r\noc_now_mask = MS_OC_NOW;\r\noc_ever_mask = MS_OC_EVER;\r\n} else {\r\noc_now_mask = SD_OC_NOW;\r\noc_ever_mask = SD_OC_EVER;\r\n}\r\nif (chip->ocp_stat & oc_now_mask)\r\nstatus[8] |= 0x02;\r\nif (chip->ocp_stat & oc_ever_mask)\r\nstatus[8] |= 0x01;\r\n#endif\r\nif (card == SD_CARD) {\r\nif (CHK_SD(sd_card)) {\r\nif (CHK_SD_HCXC(sd_card)) {\r\nif (sd_card->capacity > 0x4000000)\r\nstatus[0x0E] = 0x02;\r\nelse\r\nstatus[0x0E] = 0x01;\r\n} else {\r\nstatus[0x0E] = 0x00;\r\n}\r\nif (CHK_SD_SDR104(sd_card))\r\nstatus[0x0F] = 0x03;\r\nelse if (CHK_SD_DDR50(sd_card))\r\nstatus[0x0F] = 0x04;\r\nelse if (CHK_SD_SDR50(sd_card))\r\nstatus[0x0F] = 0x02;\r\nelse if (CHK_SD_HS(sd_card))\r\nstatus[0x0F] = 0x01;\r\nelse\r\nstatus[0x0F] = 0x00;\r\n} else {\r\nif (CHK_MMC_SECTOR_MODE(sd_card))\r\nstatus[0x0E] = 0x01;\r\nelse\r\nstatus[0x0E] = 0x00;\r\nif (CHK_MMC_DDR52(sd_card))\r\nstatus[0x0F] = 0x03;\r\nelse if (CHK_MMC_52M(sd_card))\r\nstatus[0x0F] = 0x02;\r\nelse if (CHK_MMC_26M(sd_card))\r\nstatus[0x0F] = 0x01;\r\nelse\r\nstatus[0x0F] = 0x00;\r\n}\r\n} else if (card == MS_CARD) {\r\nif (CHK_MSPRO(ms_card)) {\r\nif (CHK_MSXC(ms_card))\r\nstatus[0x0E] = 0x01;\r\nelse\r\nstatus[0x0E] = 0x00;\r\nif (CHK_HG8BIT(ms_card))\r\nstatus[0x0F] = 0x01;\r\nelse\r\nstatus[0x0F] = 0x00;\r\n}\r\n}\r\n#ifdef SUPPORT_SD_LOCK\r\nif (card == SD_CARD) {\r\nstatus[0x17] = 0x80;\r\nif (sd_card->sd_erase_status)\r\nstatus[0x17] |= 0x01;\r\nif (sd_card->sd_lock_status & SD_LOCKED) {\r\nstatus[0x17] |= 0x02;\r\nstatus[0x07] |= 0x40;\r\n}\r\nif (sd_card->sd_lock_status & SD_PWD_EXIST)\r\nstatus[0x17] |= 0x04;\r\n} else {\r\nstatus[0x17] = 0x00;\r\n}\r\nRTSX_DEBUGP("status[0x17] = 0x%x\n", status[0x17]);\r\n#endif\r\nstatus[0x18] = 0x8A;\r\nstatus[0x1A] = 0x28;\r\n#ifdef SUPPORT_SD_LOCK\r\nstatus[0x1F] = 0x01;\r\n#endif\r\nbuf_len = min_t(unsigned int, scsi_bufflen(srb), sizeof(status));\r\nrtsx_stor_set_xfer_buf(status, buf_len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - buf_len);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int set_chip_mode(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint phy_debug_mode;\r\nint retval;\r\nu16 reg;\r\nif (!CHECK_PID(chip, 0x5208)) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nphy_debug_mode = (int)(srb->cmnd[3]);\r\nif (phy_debug_mode) {\r\nchip->phy_debug_mode = 1;\r\nretval = rtsx_write_register(chip, CDRESUMECTL, 0x77, 0);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\nrtsx_disable_bus_int(chip);\r\nretval = rtsx_read_phy_register(chip, 0x1C, &reg);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\nreg |= 0x0001;\r\nretval = rtsx_write_phy_register(chip, 0x1C, reg);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n} else {\r\nchip->phy_debug_mode = 0;\r\nretval = rtsx_write_register(chip, CDRESUMECTL, 0x77, 0x77);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\nrtsx_enable_bus_int(chip);\r\nretval = rtsx_read_phy_register(chip, 0x1C, &reg);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\nreg &= 0xFFFE;\r\nretval = rtsx_write_phy_register(chip, 0x1C, reg);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int rw_mem_cmd_buf(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint retval = STATUS_SUCCESS;\r\nunsigned int lun = SCSI_LUN(srb);\r\nu8 cmd_type, mask, value, idx;\r\nu16 addr;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nswitch (srb->cmnd[3]) {\r\ncase INIT_BATCHCMD:\r\nrtsx_init_cmd(chip);\r\nbreak;\r\ncase ADD_BATCHCMD:\r\ncmd_type = srb->cmnd[4];\r\nif (cmd_type > 2) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\naddr = (srb->cmnd[5] << 8) | srb->cmnd[6];\r\nmask = srb->cmnd[7];\r\nvalue = srb->cmnd[8];\r\nrtsx_add_cmd(chip, cmd_type, addr, mask, value);\r\nbreak;\r\ncase SEND_BATCHCMD:\r\nretval = rtsx_send_cmd(chip, 0, 1000);\r\nbreak;\r\ncase GET_BATCHRSP:\r\nidx = srb->cmnd[4];\r\nvalue = *(rtsx_get_cmd_data(chip) + idx);\r\nif (scsi_bufflen(srb) < 1) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nrtsx_stor_set_xfer_buf(&value, 1, srb);\r\nscsi_set_resid(srb, 0);\r\nbreak;\r\ndefault:\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int suit_cmd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint result;\r\nswitch (srb->cmnd[3]) {\r\ncase INIT_BATCHCMD:\r\ncase ADD_BATCHCMD:\r\ncase SEND_BATCHCMD:\r\ncase GET_BATCHRSP:\r\nresult = rw_mem_cmd_buf(srb, chip);\r\nbreak;\r\ndefault:\r\nresult = TRANSPORT_ERROR;\r\n}\r\nreturn result;\r\n}\r\nstatic int read_phy_register(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned short addr, len, i;\r\nint retval;\r\nu8 *buf;\r\nu16 val;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\naddr = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\r\nlen = ((u16)srb->cmnd[6] << 8) | srb->cmnd[7];\r\nif (len % 2)\r\nlen -= len % 2;\r\nif (len) {\r\nbuf = vmalloc(len);\r\nif (!buf)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nfor (i = 0; i < len / 2; i++) {\r\nretval = rtsx_read_phy_register(chip, addr + i, &val);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbuf[2*i] = (u8)(val >> 8);\r\nbuf[2*i+1] = (u8)val;\r\n}\r\nlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb),\r\nlen);\r\nrtsx_stor_set_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nvfree(buf);\r\n}\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int write_phy_register(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned short addr, len, i;\r\nint retval;\r\nu8 *buf;\r\nu16 val;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\naddr = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\r\nlen = ((u16)srb->cmnd[6] << 8) | srb->cmnd[7];\r\nif (len % 2)\r\nlen -= len % 2;\r\nif (len) {\r\nlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb),\r\nlen);\r\nbuf = vmalloc(len);\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nrtsx_stor_get_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nfor (i = 0; i < len / 2; i++) {\r\nval = ((u16)buf[2*i] << 8) | buf[2*i+1];\r\nretval = rtsx_write_phy_register(chip, addr + i, val);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nvfree(buf);\r\n}\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int erase_eeprom2(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned short addr;\r\nint retval;\r\nu8 mode;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nmode = srb->cmnd[3];\r\naddr = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\r\nif (mode == 0) {\r\nretval = spi_erase_eeprom_chip(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n} else if (mode == 1) {\r\nretval = spi_erase_eeprom_byte(chip, addr);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n} else {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int read_eeprom2(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned short addr, len, i;\r\nint retval;\r\nu8 *buf;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\naddr = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\r\nlen = ((u16)srb->cmnd[6] << 8) | srb->cmnd[7];\r\nbuf = vmalloc(len);\r\nif (!buf)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nfor (i = 0; i < len; i++) {\r\nretval = spi_read_eeprom(chip, addr + i, buf + i);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\r\nrtsx_stor_set_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nvfree(buf);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int write_eeprom2(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned short addr, len, i;\r\nint retval;\r\nu8 *buf;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\naddr = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\r\nlen = ((u16)srb->cmnd[6] << 8) | srb->cmnd[7];\r\nlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\r\nbuf = vmalloc(len);\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nrtsx_stor_get_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nfor (i = 0; i < len; i++) {\r\nretval = spi_write_eeprom(chip, addr + i, buf[i]);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nvfree(buf);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int read_efuse(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nu8 addr, len, i;\r\nu8 *buf;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\naddr = srb->cmnd[4];\r\nlen = srb->cmnd[5];\r\nbuf = vmalloc(len);\r\nif (!buf)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nfor (i = 0; i < len; i++) {\r\nretval = rtsx_read_efuse(chip, addr + i, buf + i);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nlen = (u8)min_t(unsigned int, scsi_bufflen(srb), len);\r\nrtsx_stor_set_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nvfree(buf);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int write_efuse(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint retval, result = TRANSPORT_GOOD;\r\nu16 val;\r\nu8 addr, len, i;\r\nu8 *buf;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\naddr = srb->cmnd[4];\r\nlen = srb->cmnd[5];\r\nlen = (u8)min_t(unsigned int, scsi_bufflen(srb), len);\r\nbuf = vmalloc(len);\r\nif (buf == NULL)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nrtsx_stor_get_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\n}\r\nif (chip->asic_code) {\r\nretval = rtsx_read_phy_register(chip, 0x08, &val);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\n}\r\nretval = rtsx_write_register(chip, PWR_GATE_CTRL,\r\nLDO3318_PWR_MASK, LDO_OFF);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\n}\r\nwait_timeout(600);\r\nretval = rtsx_write_phy_register(chip, 0x08,\r\n0x4C00 | chip->phy_voltage);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\n}\r\nretval = rtsx_write_register(chip, PWR_GATE_CTRL,\r\nLDO3318_PWR_MASK, LDO_ON);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\n}\r\nwait_timeout(600);\r\n}\r\nretval = card_power_on(chip, SPI_CARD);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(buf);\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\n}\r\nwait_timeout(50);\r\nfor (i = 0; i < len; i++) {\r\nretval = rtsx_write_efuse(chip, addr + i, buf[i]);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nresult = TRANSPORT_FAILED;\r\nTRACE_GOTO(chip, Exit);\r\n}\r\n}\r\nExit:\r\nvfree(buf);\r\nretval = card_power_off(chip, SPI_CARD);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nif (chip->asic_code) {\r\nretval = rtsx_write_register(chip, PWR_GATE_CTRL,\r\nLDO3318_PWR_MASK, LDO_OFF);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nwait_timeout(600);\r\nretval = rtsx_write_phy_register(chip, 0x08, val);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nretval = rtsx_write_register(chip, PWR_GATE_CTRL,\r\nLDO3318_PWR_MASK, LDO_ON);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\n}\r\nreturn result;\r\n}\r\nstatic int read_cfg_byte(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nu8 func, func_max;\r\nu16 addr, len;\r\nu8 *buf;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nfunc = srb->cmnd[3];\r\naddr = ((u16)(srb->cmnd[4]) << 8) | srb->cmnd[5];\r\nlen = ((u16)(srb->cmnd[6]) << 8) | srb->cmnd[7];\r\nRTSX_DEBUGP("%s: func = %d, addr = 0x%x, len = %d\n", __func__, func,\r\naddr, len);\r\nif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip))\r\nfunc_max = 1;\r\nelse\r\nfunc_max = 0;\r\nif (func > func_max) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbuf = vmalloc(len);\r\nif (!buf)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nretval = rtsx_read_cfg_seq(chip, func, addr, buf, len);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nvfree(buf);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nlen = (u16)min_t(unsigned int, scsi_bufflen(srb), len);\r\nrtsx_stor_set_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nvfree(buf);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int write_cfg_byte(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nu8 func, func_max;\r\nu16 addr, len;\r\nu8 *buf;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nfunc = srb->cmnd[3];\r\naddr = ((u16)(srb->cmnd[4]) << 8) | srb->cmnd[5];\r\nlen = ((u16)(srb->cmnd[6]) << 8) | srb->cmnd[7];\r\nRTSX_DEBUGP("%s: func = %d, addr = 0x%x\n", __func__, func, addr);\r\nif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip))\r\nfunc_max = 1;\r\nelse\r\nfunc_max = 0;\r\nif (func > func_max) {\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\r\nbuf = vmalloc(len);\r\nif (!buf)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\nrtsx_stor_get_xfer_buf(buf, len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - len);\r\nretval = rtsx_write_cfg_seq(chip, func, addr, buf, len);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\r\nvfree(buf);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nvfree(buf);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int app_cmd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint result;\r\nswitch (srb->cmnd[2]) {\r\ncase PP_READ10:\r\ncase PP_WRITE10:\r\nresult = read_write(srb, chip);\r\nbreak;\r\ncase READ_HOST_REG:\r\nresult = read_host_reg(srb, chip);\r\nbreak;\r\ncase WRITE_HOST_REG:\r\nresult = write_host_reg(srb, chip);\r\nbreak;\r\ncase GET_VAR:\r\nresult = get_variable(srb, chip);\r\nbreak;\r\ncase SET_VAR:\r\nresult = set_variable(srb, chip);\r\nbreak;\r\ncase DMA_READ:\r\ncase DMA_WRITE:\r\nresult = dma_access_ring_buffer(srb, chip);\r\nbreak;\r\ncase READ_PHY:\r\nresult = read_phy_register(srb, chip);\r\nbreak;\r\ncase WRITE_PHY:\r\nresult = write_phy_register(srb, chip);\r\nbreak;\r\ncase ERASE_EEPROM2:\r\nresult = erase_eeprom2(srb, chip);\r\nbreak;\r\ncase READ_EEPROM2:\r\nresult = read_eeprom2(srb, chip);\r\nbreak;\r\ncase WRITE_EEPROM2:\r\nresult = write_eeprom2(srb, chip);\r\nbreak;\r\ncase READ_EFUSE:\r\nresult = read_efuse(srb, chip);\r\nbreak;\r\ncase WRITE_EFUSE:\r\nresult = write_efuse(srb, chip);\r\nbreak;\r\ncase READ_CFG:\r\nresult = read_cfg_byte(srb, chip);\r\nbreak;\r\ncase WRITE_CFG:\r\nresult = write_cfg_byte(srb, chip);\r\nbreak;\r\ncase SET_CHIP_MODE:\r\nresult = set_chip_mode(srb, chip);\r\nbreak;\r\ncase SUIT_CMD:\r\nresult = suit_cmd(srb, chip);\r\nbreak;\r\ncase GET_DEV_STATUS:\r\nresult = get_dev_status(srb, chip);\r\nbreak;\r\ndefault:\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nreturn result;\r\n}\r\nstatic int read_status(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nu8 rtsx_status[16];\r\nint buf_len;\r\nunsigned int lun = SCSI_LUN(srb);\r\nrtsx_status[0] = (u8)(chip->vendor_id >> 8);\r\nrtsx_status[1] = (u8)(chip->vendor_id);\r\nrtsx_status[2] = (u8)(chip->product_id >> 8);\r\nrtsx_status[3] = (u8)(chip->product_id);\r\nrtsx_status[4] = (u8)lun;\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nif (chip->lun2card[lun] == SD_CARD)\r\nrtsx_status[5] = 2;\r\nelse\r\nrtsx_status[5] = 3;\r\n} else {\r\nif (chip->card_exist) {\r\nif (chip->card_exist & XD_CARD)\r\nrtsx_status[5] = 4;\r\nelse if (chip->card_exist & SD_CARD)\r\nrtsx_status[5] = 2;\r\nelse if (chip->card_exist & MS_CARD)\r\nrtsx_status[5] = 3;\r\nelse\r\nrtsx_status[5] = 7;\r\n} else {\r\nrtsx_status[5] = 7;\r\n}\r\n}\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\r\nrtsx_status[6] = 2;\r\nelse\r\nrtsx_status[6] = 1;\r\nrtsx_status[7] = (u8)(chip->product_id);\r\nrtsx_status[8] = chip->ic_version;\r\nif (check_card_exist(chip, lun))\r\nrtsx_status[9] = 1;\r\nelse\r\nrtsx_status[9] = 0;\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\r\nrtsx_status[10] = 0;\r\nelse\r\nrtsx_status[10] = 1;\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nif (chip->lun2card[lun] == SD_CARD)\r\nrtsx_status[11] = SD_CARD;\r\nelse\r\nrtsx_status[11] = MS_CARD;\r\n} else {\r\nrtsx_status[11] = XD_CARD | SD_CARD | MS_CARD;\r\n}\r\nif (check_card_ready(chip, lun))\r\nrtsx_status[12] = 1;\r\nelse\r\nrtsx_status[12] = 0;\r\nif (get_lun_card(chip, lun) == XD_CARD) {\r\nrtsx_status[13] = 0x40;\r\n} else if (get_lun_card(chip, lun) == SD_CARD) {\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nrtsx_status[13] = 0x20;\r\nif (CHK_SD(sd_card)) {\r\nif (CHK_SD_HCXC(sd_card))\r\nrtsx_status[13] |= 0x04;\r\nif (CHK_SD_HS(sd_card))\r\nrtsx_status[13] |= 0x02;\r\n} else {\r\nrtsx_status[13] |= 0x08;\r\nif (CHK_MMC_52M(sd_card))\r\nrtsx_status[13] |= 0x02;\r\nif (CHK_MMC_SECTOR_MODE(sd_card))\r\nrtsx_status[13] |= 0x04;\r\n}\r\n} else if (get_lun_card(chip, lun) == MS_CARD) {\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nif (CHK_MSPRO(ms_card)) {\r\nrtsx_status[13] = 0x38;\r\nif (CHK_HG8BIT(ms_card))\r\nrtsx_status[13] |= 0x04;\r\n#ifdef SUPPORT_MSXC\r\nif (CHK_MSXC(ms_card))\r\nrtsx_status[13] |= 0x01;\r\n#endif\r\n} else {\r\nrtsx_status[13] = 0x30;\r\n}\r\n} else {\r\nif (CHECK_LUN_MODE(chip, DEFAULT_SINGLE)) {\r\n#ifdef SUPPORT_SDIO\r\nif (chip->sd_io && chip->sd_int)\r\nrtsx_status[13] = 0x60;\r\nelse\r\nrtsx_status[13] = 0x70;\r\n#else\r\nrtsx_status[13] = 0x70;\r\n#endif\r\n} else {\r\nif (chip->lun2card[lun] == SD_CARD)\r\nrtsx_status[13] = 0x20;\r\nelse\r\nrtsx_status[13] = 0x30;\r\n}\r\n}\r\nrtsx_status[14] = 0x78;\r\nif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip))\r\nrtsx_status[15] = 0x83;\r\nelse\r\nrtsx_status[15] = 0x82;\r\nbuf_len = min_t(unsigned int, scsi_bufflen(srb), sizeof(rtsx_status));\r\nrtsx_stor_set_xfer_buf(rtsx_status, buf_len, srb);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - buf_len);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int get_card_bus_width(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned int lun = SCSI_LUN(srb);\r\nu8 card, bus_width;\r\nif (!check_card_ready(chip, lun)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\ncard = get_lun_card(chip, lun);\r\nif ((card == SD_CARD) || (card == MS_CARD)) {\r\nbus_width = chip->card_bus_width[lun];\r\n} else {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nscsi_set_resid(srb, 0);\r\nrtsx_stor_set_xfer_buf(&bus_width, scsi_bufflen(srb), srb);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int spi_vendor_cmd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint result;\r\nunsigned int lun = SCSI_LUN(srb);\r\nu8 gpio_dir;\r\nif (CHECK_PID(chip, 0x5208) || CHECK_PID(chip, 0x5288)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nrtsx_force_power_on(chip, SSC_PDCTL);\r\nrtsx_read_register(chip, CARD_GPIO_DIR, &gpio_dir);\r\nrtsx_write_register(chip, CARD_GPIO_DIR, 0x07, gpio_dir & 0x06);\r\nswitch (srb->cmnd[2]) {\r\ncase SCSI_SPI_GETSTATUS:\r\nresult = spi_get_status(srb, chip);\r\nbreak;\r\ncase SCSI_SPI_SETPARAMETER:\r\nresult = spi_set_parameter(srb, chip);\r\nbreak;\r\ncase SCSI_SPI_READFALSHID:\r\nresult = spi_read_flash_id(srb, chip);\r\nbreak;\r\ncase SCSI_SPI_READFLASH:\r\nresult = spi_read_flash(srb, chip);\r\nbreak;\r\ncase SCSI_SPI_WRITEFLASH:\r\nresult = spi_write_flash(srb, chip);\r\nbreak;\r\ncase SCSI_SPI_WRITEFLASHSTATUS:\r\nresult = spi_write_flash_status(srb, chip);\r\nbreak;\r\ncase SCSI_SPI_ERASEFLASH:\r\nresult = spi_erase_flash(srb, chip);\r\nbreak;\r\ndefault:\r\nrtsx_write_register(chip, CARD_GPIO_DIR, 0x07, gpio_dir);\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nrtsx_write_register(chip, CARD_GPIO_DIR, 0x07, gpio_dir);\r\nif (result != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int vendor_cmnd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint result;\r\nswitch (srb->cmnd[1]) {\r\ncase READ_STATUS:\r\nresult = read_status(srb, chip);\r\nbreak;\r\ncase READ_MEM:\r\nresult = read_mem(srb, chip);\r\nbreak;\r\ncase WRITE_MEM:\r\nresult = write_mem(srb, chip);\r\nbreak;\r\ncase READ_EEPROM:\r\nresult = read_eeprom(srb, chip);\r\nbreak;\r\ncase WRITE_EEPROM:\r\nresult = write_eeprom(srb, chip);\r\nbreak;\r\ncase TOGGLE_GPIO:\r\nresult = toggle_gpio_cmd(srb, chip);\r\nbreak;\r\ncase GET_SD_CSD:\r\nresult = get_sd_csd(srb, chip);\r\nbreak;\r\ncase GET_BUS_WIDTH:\r\nresult = get_card_bus_width(srb, chip);\r\nbreak;\r\n#ifdef _MSG_TRACE\r\ncase TRACE_MSG:\r\nresult = trace_msg_cmd(srb, chip);\r\nbreak;\r\n#endif\r\ncase SCSI_APP_CMD:\r\nresult = app_cmd(srb, chip);\r\nbreak;\r\ncase SPI_VENDOR_COMMAND:\r\nresult = spi_vendor_cmd(srb, chip);\r\nbreak;\r\ndefault:\r\nset_sense_type(chip, SCSI_LUN(srb),\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nreturn result;\r\n}\r\nvoid led_shine(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned int lun = SCSI_LUN(srb);\r\nu16 sec_cnt;\r\nif ((srb->cmnd[0] == READ_10) || (srb->cmnd[0] == WRITE_10))\r\nsec_cnt = ((u16)(srb->cmnd[7]) << 8) | srb->cmnd[8];\r\nelse if ((srb->cmnd[0] == READ_6) || (srb->cmnd[0] == WRITE_6))\r\nsec_cnt = srb->cmnd[4];\r\nelse\r\nreturn;\r\nif (chip->rw_cap[lun] >= GPIO_TOGGLE_THRESHOLD) {\r\ntoggle_gpio(chip, LED_GPIO);\r\nchip->rw_cap[lun] = 0;\r\n} else {\r\nchip->rw_cap[lun] += sec_cnt;\r\n}\r\n}\r\nstatic int ms_format_cmnd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nunsigned int lun = SCSI_LUN(srb);\r\nint retval, quick_format;\r\nif (get_lun_card(chip, lun) != MS_CARD) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif ((srb->cmnd[3] != 0x4D) || (srb->cmnd[4] != 0x47) ||\r\n(srb->cmnd[5] != 0x66) || (srb->cmnd[6] != 0x6D) ||\r\n(srb->cmnd[7] != 0x74)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\nif (!check_card_ready(chip, lun) ||\r\n(get_card_size(chip, lun) == 0)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nif (srb->cmnd[8] & 0x01)\r\nquick_format = 0;\r\nelse\r\nquick_format = 1;\r\nif (!(chip->card_ready & MS_CARD)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (chip->card_wp & MS_CARD) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_WRITE_PROTECT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (!CHK_MSPRO(ms_card)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nretval = mspro_format(srb, chip, MS_SHORT_DATA_LEN, quick_format);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, lun, SENSE_TYPE_FORMAT_CMD_FAILED);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nscsi_set_resid(srb, 0);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int get_ms_information(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nunsigned int lun = SCSI_LUN(srb);\r\nu8 dev_info_id, data_len;\r\nu8 *buf;\r\nunsigned int buf_len;\r\nint i;\r\nif (!check_card_ready(chip, lun)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (get_lun_card(chip, lun) != MS_CARD) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif ((srb->cmnd[2] != 0xB0) || (srb->cmnd[4] != 0x4D) ||\r\n(srb->cmnd[5] != 0x53) || (srb->cmnd[6] != 0x49) ||\r\n(srb->cmnd[7] != 0x44)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\ndev_info_id = srb->cmnd[3];\r\nif ((CHK_MSXC(ms_card) && (dev_info_id == 0x10)) ||\r\n(!CHK_MSXC(ms_card) && (dev_info_id == 0x13)) ||\r\n!CHK_MSPRO(ms_card)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (dev_info_id == 0x15)\r\nbuf_len = data_len = 0x3A;\r\nelse\r\nbuf_len = data_len = 0x6A;\r\nbuf = kmalloc(buf_len, GFP_KERNEL);\r\nif (!buf)\r\nTRACE_RET(chip, TRANSPORT_ERROR);\r\ni = 0;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = data_len;\r\nif (CHK_MSXC(ms_card))\r\nbuf[i++] = 0x03;\r\nelse\r\nbuf[i++] = 0x02;\r\nbuf[i++] = 0x01;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = 0x01;\r\nbuf[i++] = dev_info_id;\r\nif (dev_info_id == 0x15)\r\ndata_len = 0x31;\r\nelse\r\ndata_len = 0x61;\r\nbuf[i++] = 0x00;\r\nbuf[i++] = data_len;\r\nbuf[i++] = 0x80;\r\nif ((dev_info_id == 0x10) || (dev_info_id == 0x13)) {\r\nmemcpy(buf+i, ms_card->raw_sys_info, 96);\r\n} else {\r\nmemcpy(buf+i, ms_card->raw_model_name, 48);\r\n}\r\nrtsx_stor_set_xfer_buf(buf, buf_len, srb);\r\nif (dev_info_id == 0x15)\r\nscsi_set_resid(srb, scsi_bufflen(srb)-0x3C);\r\nelse\r\nscsi_set_resid(srb, scsi_bufflen(srb)-0x6C);\r\nkfree(buf);\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int ms_sp_cmnd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint retval = TRANSPORT_ERROR;\r\nif (srb->cmnd[2] == MS_FORMAT)\r\nretval = ms_format_cmnd(srb, chip);\r\n#ifdef SUPPORT_PCGL_1P18\r\nelse if (srb->cmnd[2] == GET_MS_INFORMATION)\r\nretval = get_ms_information(srb, chip);\r\n#endif\r\nreturn retval;\r\n}\r\nstatic int sd_extention_cmnd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nunsigned int lun = SCSI_LUN(srb);\r\nint result;\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nsd_cleanup_work(chip);\r\nif (!check_card_ready(chip, lun)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (get_lun_card(chip, lun) != SD_CARD) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nswitch (srb->cmnd[0]) {\r\ncase SD_PASS_THRU_MODE:\r\nresult = sd_pass_thru_mode(srb, chip);\r\nbreak;\r\ncase SD_EXECUTE_NO_DATA:\r\nresult = sd_execute_no_data(srb, chip);\r\nbreak;\r\ncase SD_EXECUTE_READ:\r\nresult = sd_execute_read_data(srb, chip);\r\nbreak;\r\ncase SD_EXECUTE_WRITE:\r\nresult = sd_execute_write_data(srb, chip);\r\nbreak;\r\ncase SD_GET_RSP:\r\nresult = sd_get_cmd_rsp(srb, chip);\r\nbreak;\r\ncase SD_HW_RST:\r\nresult = sd_hw_rst(srb, chip);\r\nbreak;\r\ndefault:\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nreturn result;\r\n}\r\nstatic int mg_report_key(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nunsigned int lun = SCSI_LUN(srb);\r\nint retval;\r\nu8 key_format;\r\nRTSX_DEBUGP("--%s--\n", __func__);\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nms_cleanup_work(chip);\r\nif (!check_card_ready(chip, lun)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (get_lun_card(chip, lun) != MS_CARD) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (srb->cmnd[7] != KC_MG_R_PRO) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (!CHK_MSPRO(ms_card)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nkey_format = srb->cmnd[10] & 0x3F;\r\nRTSX_DEBUGP("key_format = 0x%x\n", key_format);\r\nswitch (key_format) {\r\ncase KF_GET_LOC_EKB:\r\nif ((scsi_bufflen(srb) == 0x41C) &&\r\n(srb->cmnd[8] == 0x04) &&\r\n(srb->cmnd[9] == 0x1C)) {\r\nretval = mg_get_local_EKB(srb, chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n} else {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbreak;\r\ncase KF_RSP_CHG:\r\nif ((scsi_bufflen(srb) == 0x24) &&\r\n(srb->cmnd[8] == 0x00) &&\r\n(srb->cmnd[9] == 0x24)) {\r\nretval = mg_get_rsp_chg(srb, chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n} else {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbreak;\r\ncase KF_GET_ICV:\r\nms_card->mg_entry_num = srb->cmnd[5];\r\nif ((scsi_bufflen(srb) == 0x404) &&\r\n(srb->cmnd[8] == 0x04) &&\r\n(srb->cmnd[9] == 0x04) &&\r\n(srb->cmnd[2] == 0x00) &&\r\n(srb->cmnd[3] == 0x00) &&\r\n(srb->cmnd[4] == 0x00) &&\r\n(srb->cmnd[5] < 32)) {\r\nretval = mg_get_ICV(srb, chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n} else {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbreak;\r\ndefault:\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nscsi_set_resid(srb, 0);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nstatic int mg_send_key(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nunsigned int lun = SCSI_LUN(srb);\r\nint retval;\r\nu8 key_format;\r\nRTSX_DEBUGP("--%s--\n", __func__);\r\nrtsx_disable_aspm(chip);\r\nif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\r\nrtsx_exit_ss(chip);\r\nwait_timeout(100);\r\n}\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\nms_cleanup_work(chip);\r\nif (!check_card_ready(chip, lun)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (check_card_wp(chip, lun)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_WRITE_PROTECT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (get_lun_card(chip, lun) != MS_CARD) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (srb->cmnd[7] != KC_MG_R_PRO) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nif (!CHK_MSPRO(ms_card)) {\r\nset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nkey_format = srb->cmnd[10] & 0x3F;\r\nRTSX_DEBUGP("key_format = 0x%x\n", key_format);\r\nswitch (key_format) {\r\ncase KF_SET_LEAF_ID:\r\nif ((scsi_bufflen(srb) == 0x0C) &&\r\n(srb->cmnd[8] == 0x00) &&\r\n(srb->cmnd[9] == 0x0C)) {\r\nretval = mg_set_leaf_id(srb, chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n} else {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbreak;\r\ncase KF_CHG_HOST:\r\nif ((scsi_bufflen(srb) == 0x0C) &&\r\n(srb->cmnd[8] == 0x00) &&\r\n(srb->cmnd[9] == 0x0C)) {\r\nretval = mg_chg(srb, chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n} else {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbreak;\r\ncase KF_RSP_HOST:\r\nif ((scsi_bufflen(srb) == 0x0C) &&\r\n(srb->cmnd[8] == 0x00) &&\r\n(srb->cmnd[9] == 0x0C)) {\r\nretval = mg_rsp(srb, chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n} else {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbreak;\r\ncase KF_SET_ICV:\r\nms_card->mg_entry_num = srb->cmnd[5];\r\nif ((scsi_bufflen(srb) == 0x404) &&\r\n(srb->cmnd[8] == 0x04) &&\r\n(srb->cmnd[9] == 0x04) &&\r\n(srb->cmnd[2] == 0x00) &&\r\n(srb->cmnd[3] == 0x00) &&\r\n(srb->cmnd[4] == 0x00) &&\r\n(srb->cmnd[5] < 32)) {\r\nretval = mg_set_ICV(srb, chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n} else {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nbreak;\r\ndefault:\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\nscsi_set_resid(srb, 0);\r\nreturn TRANSPORT_GOOD;\r\n}\r\nint rtsx_scsi_handler(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\n#ifdef SUPPORT_SD_LOCK\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\n#endif\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nunsigned int lun = SCSI_LUN(srb);\r\nint result;\r\n#ifdef SUPPORT_SD_LOCK\r\nif (sd_card->sd_erase_status) {\r\nif (!((srb->cmnd[0] == VENDOR_CMND) &&\r\n(srb->cmnd[1] == SCSI_APP_CMD) &&\r\n(srb->cmnd[2] == GET_DEV_STATUS)) &&\r\n(srb->cmnd[0] != REQUEST_SENSE)) {\r\nset_sense_data(chip, lun, CUR_ERR,\r\n0x02, 0, 0x04, 0x04, 0, 0);\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\n#endif\r\nif ((get_lun_card(chip, lun) == MS_CARD) &&\r\n(ms_card->format_status == FORMAT_IN_PROGRESS)) {\r\nif ((srb->cmnd[0] != REQUEST_SENSE) &&\r\n(srb->cmnd[0] != INQUIRY)) {\r\nset_sense_data(chip, lun, CUR_ERR, 0x02, 0, 0x04, 0x04,\r\n0, (u16)(ms_card->progress));\r\nTRACE_RET(chip, TRANSPORT_FAILED);\r\n}\r\n}\r\nswitch (srb->cmnd[0]) {\r\ncase READ_10:\r\ncase WRITE_10:\r\ncase READ_6:\r\ncase WRITE_6:\r\nresult = read_write(srb, chip);\r\n#if !defined(LED_AUTO_BLINK) && !defined(REGULAR_BLINK)\r\nled_shine(srb, chip);\r\n#endif\r\nbreak;\r\ncase TEST_UNIT_READY:\r\nresult = test_unit_ready(srb, chip);\r\nbreak;\r\ncase INQUIRY:\r\nresult = inquiry(srb, chip);\r\nbreak;\r\ncase READ_CAPACITY:\r\nresult = read_capacity(srb, chip);\r\nbreak;\r\ncase START_STOP:\r\nresult = start_stop_unit(srb, chip);\r\nbreak;\r\ncase ALLOW_MEDIUM_REMOVAL:\r\nresult = allow_medium_removal(srb, chip);\r\nbreak;\r\ncase REQUEST_SENSE:\r\nresult = request_sense(srb, chip);\r\nbreak;\r\ncase MODE_SENSE:\r\ncase MODE_SENSE_10:\r\nresult = mode_sense(srb, chip);\r\nbreak;\r\ncase 0x23:\r\nresult = read_format_capacity(srb, chip);\r\nbreak;\r\ncase VENDOR_CMND:\r\nresult = vendor_cmnd(srb, chip);\r\nbreak;\r\ncase MS_SP_CMND:\r\nresult = ms_sp_cmnd(srb, chip);\r\nbreak;\r\n#ifdef SUPPORT_CPRM\r\ncase SD_PASS_THRU_MODE:\r\ncase SD_EXECUTE_NO_DATA:\r\ncase SD_EXECUTE_READ:\r\ncase SD_EXECUTE_WRITE:\r\ncase SD_GET_RSP:\r\ncase SD_HW_RST:\r\nresult = sd_extention_cmnd(srb, chip);\r\nbreak;\r\n#endif\r\n#ifdef SUPPORT_MAGIC_GATE\r\ncase CMD_MSPRO_MG_RKEY:\r\nresult = mg_report_key(srb, chip);\r\nbreak;\r\ncase CMD_MSPRO_MG_SKEY:\r\nresult = mg_send_key(srb, chip);\r\nbreak;\r\n#endif\r\ncase FORMAT_UNIT:\r\ncase MODE_SELECT:\r\ncase VERIFY:\r\nresult = TRANSPORT_GOOD;\r\nbreak;\r\ndefault:\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\r\nresult = TRANSPORT_FAILED;\r\n}\r\nreturn result;\r\n}
