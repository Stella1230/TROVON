static inline struct atm_flow_data *lookup_flow(struct Qdisc *sch, u32 classid)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow;\r\nlist_for_each_entry(flow, &p->flows, list) {\r\nif (flow->classid == classid)\r\nreturn flow;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int atm_tc_graft(struct Qdisc *sch, unsigned long arg,\r\nstruct Qdisc *new, struct Qdisc **old)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow = (struct atm_flow_data *)arg;\r\npr_debug("atm_tc_graft(sch %p,[qdisc %p],flow %p,new %p,old %p)\n",\r\nsch, p, flow, new, old);\r\nif (list_empty(&flow->list))\r\nreturn -EINVAL;\r\nif (!new)\r\nnew = &noop_qdisc;\r\n*old = flow->q;\r\nflow->q = new;\r\nif (*old)\r\nqdisc_reset(*old);\r\nreturn 0;\r\n}\r\nstatic struct Qdisc *atm_tc_leaf(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct atm_flow_data *flow = (struct atm_flow_data *)cl;\r\npr_debug("atm_tc_leaf(sch %p,flow %p)\n", sch, flow);\r\nreturn flow ? flow->q : NULL;\r\n}\r\nstatic unsigned long atm_tc_get(struct Qdisc *sch, u32 classid)\r\n{\r\nstruct atm_qdisc_data *p __maybe_unused = qdisc_priv(sch);\r\nstruct atm_flow_data *flow;\r\npr_debug("atm_tc_get(sch %p,[qdisc %p],classid %x)\n", sch, p, classid);\r\nflow = lookup_flow(sch, classid);\r\nif (flow)\r\nflow->ref++;\r\npr_debug("atm_tc_get: flow %p\n", flow);\r\nreturn (unsigned long)flow;\r\n}\r\nstatic unsigned long atm_tc_bind_filter(struct Qdisc *sch,\r\nunsigned long parent, u32 classid)\r\n{\r\nreturn atm_tc_get(sch, classid);\r\n}\r\nstatic void atm_tc_put(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow = (struct atm_flow_data *)cl;\r\npr_debug("atm_tc_put(sch %p,[qdisc %p],flow %p)\n", sch, p, flow);\r\nif (--flow->ref)\r\nreturn;\r\npr_debug("atm_tc_put: destroying\n");\r\nlist_del_init(&flow->list);\r\npr_debug("atm_tc_put: qdisc %p\n", flow->q);\r\nqdisc_destroy(flow->q);\r\ntcf_destroy_chain(&flow->filter_list);\r\nif (flow->sock) {\r\npr_debug("atm_tc_put: f_count %ld\n",\r\nfile_count(flow->sock->file));\r\nflow->vcc->pop = flow->old_pop;\r\nsockfd_put(flow->sock);\r\n}\r\nif (flow->excess)\r\natm_tc_put(sch, (unsigned long)flow->excess);\r\nif (flow != &p->link)\r\nkfree(flow);\r\n}\r\nstatic void sch_atm_pop(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct atm_qdisc_data *p = VCC2FLOW(vcc)->parent;\r\npr_debug("sch_atm_pop(vcc %p,skb %p,[qdisc %p])\n", vcc, skb, p);\r\nVCC2FLOW(vcc)->old_pop(vcc, skb);\r\ntasklet_schedule(&p->task);\r\n}\r\nstatic int atm_tc_change(struct Qdisc *sch, u32 classid, u32 parent,\r\nstruct nlattr **tca, unsigned long *arg)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow = (struct atm_flow_data *)*arg;\r\nstruct atm_flow_data *excess = NULL;\r\nstruct nlattr *opt = tca[TCA_OPTIONS];\r\nstruct nlattr *tb[TCA_ATM_MAX + 1];\r\nstruct socket *sock;\r\nint fd, error, hdr_len;\r\nvoid *hdr;\r\npr_debug("atm_tc_change(sch %p,[qdisc %p],classid %x,parent %x,"\r\n"flow %p,opt %p)\n", sch, p, classid, parent, flow, opt);\r\nif (parent && parent != TC_H_ROOT && parent != sch->handle)\r\nreturn -EINVAL;\r\nif (flow)\r\nreturn -EBUSY;\r\nif (opt == NULL)\r\nreturn -EINVAL;\r\nerror = nla_parse_nested(tb, TCA_ATM_MAX, opt, atm_policy);\r\nif (error < 0)\r\nreturn error;\r\nif (!tb[TCA_ATM_FD])\r\nreturn -EINVAL;\r\nfd = nla_get_u32(tb[TCA_ATM_FD]);\r\npr_debug("atm_tc_change: fd %d\n", fd);\r\nif (tb[TCA_ATM_HDR]) {\r\nhdr_len = nla_len(tb[TCA_ATM_HDR]);\r\nhdr = nla_data(tb[TCA_ATM_HDR]);\r\n} else {\r\nhdr_len = RFC1483LLC_LEN;\r\nhdr = NULL;\r\n}\r\nif (!tb[TCA_ATM_EXCESS])\r\nexcess = NULL;\r\nelse {\r\nexcess = (struct atm_flow_data *)\r\natm_tc_get(sch, nla_get_u32(tb[TCA_ATM_EXCESS]));\r\nif (!excess)\r\nreturn -ENOENT;\r\n}\r\npr_debug("atm_tc_change: type %d, payload %d, hdr_len %d\n",\r\nopt->nla_type, nla_len(opt), hdr_len);\r\nsock = sockfd_lookup(fd, &error);\r\nif (!sock)\r\nreturn error;\r\npr_debug("atm_tc_change: f_count %ld\n", file_count(sock->file));\r\nif (sock->ops->family != PF_ATMSVC && sock->ops->family != PF_ATMPVC) {\r\nerror = -EPROTOTYPE;\r\ngoto err_out;\r\n}\r\nif (classid) {\r\nif (TC_H_MAJ(classid ^ sch->handle)) {\r\npr_debug("atm_tc_change: classid mismatch\n");\r\nerror = -EINVAL;\r\ngoto err_out;\r\n}\r\n} else {\r\nint i;\r\nunsigned long cl;\r\nfor (i = 1; i < 0x8000; i++) {\r\nclassid = TC_H_MAKE(sch->handle, 0x8000 | i);\r\ncl = atm_tc_get(sch, classid);\r\nif (!cl)\r\nbreak;\r\natm_tc_put(sch, cl);\r\n}\r\n}\r\npr_debug("atm_tc_change: new id %x\n", classid);\r\nflow = kzalloc(sizeof(struct atm_flow_data) + hdr_len, GFP_KERNEL);\r\npr_debug("atm_tc_change: flow %p\n", flow);\r\nif (!flow) {\r\nerror = -ENOBUFS;\r\ngoto err_out;\r\n}\r\nflow->filter_list = NULL;\r\nflow->q = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops, classid);\r\nif (!flow->q)\r\nflow->q = &noop_qdisc;\r\npr_debug("atm_tc_change: qdisc %p\n", flow->q);\r\nflow->sock = sock;\r\nflow->vcc = ATM_SD(sock);\r\nflow->vcc->user_back = flow;\r\npr_debug("atm_tc_change: vcc %p\n", flow->vcc);\r\nflow->old_pop = flow->vcc->pop;\r\nflow->parent = p;\r\nflow->vcc->pop = sch_atm_pop;\r\nflow->classid = classid;\r\nflow->ref = 1;\r\nflow->excess = excess;\r\nlist_add(&flow->list, &p->link.list);\r\nflow->hdr_len = hdr_len;\r\nif (hdr)\r\nmemcpy(flow->hdr, hdr, hdr_len);\r\nelse\r\nmemcpy(flow->hdr, llc_oui_ip, sizeof(llc_oui_ip));\r\n*arg = (unsigned long)flow;\r\nreturn 0;\r\nerr_out:\r\nif (excess)\r\natm_tc_put(sch, (unsigned long)excess);\r\nsockfd_put(sock);\r\nreturn error;\r\n}\r\nstatic int atm_tc_delete(struct Qdisc *sch, unsigned long arg)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow = (struct atm_flow_data *)arg;\r\npr_debug("atm_tc_delete(sch %p,[qdisc %p],flow %p)\n", sch, p, flow);\r\nif (list_empty(&flow->list))\r\nreturn -EINVAL;\r\nif (flow->filter_list || flow == &p->link)\r\nreturn -EBUSY;\r\nif (flow->ref < 2) {\r\npr_err("atm_tc_delete: flow->ref == %d\n", flow->ref);\r\nreturn -EINVAL;\r\n}\r\nif (flow->ref > 2)\r\nreturn -EBUSY;\r\natm_tc_put(sch, arg);\r\nreturn 0;\r\n}\r\nstatic void atm_tc_walk(struct Qdisc *sch, struct qdisc_walker *walker)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow;\r\npr_debug("atm_tc_walk(sch %p,[qdisc %p],walker %p)\n", sch, p, walker);\r\nif (walker->stop)\r\nreturn;\r\nlist_for_each_entry(flow, &p->flows, list) {\r\nif (walker->count >= walker->skip &&\r\nwalker->fn(sch, (unsigned long)flow, walker) < 0) {\r\nwalker->stop = 1;\r\nbreak;\r\n}\r\nwalker->count++;\r\n}\r\n}\r\nstatic struct tcf_proto **atm_tc_find_tcf(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow = (struct atm_flow_data *)cl;\r\npr_debug("atm_tc_find_tcf(sch %p,[qdisc %p],flow %p)\n", sch, p, flow);\r\nreturn flow ? &flow->filter_list : &p->link.filter_list;\r\n}\r\nstatic int atm_tc_enqueue(struct sk_buff *skb, struct Qdisc *sch)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow;\r\nstruct tcf_result res;\r\nint result;\r\nint ret = NET_XMIT_POLICED;\r\npr_debug("atm_tc_enqueue(skb %p,sch %p,[qdisc %p])\n", skb, sch, p);\r\nresult = TC_POLICE_OK;\r\nflow = NULL;\r\nif (TC_H_MAJ(skb->priority) != sch->handle ||\r\n!(flow = (struct atm_flow_data *)atm_tc_get(sch, skb->priority))) {\r\nlist_for_each_entry(flow, &p->flows, list) {\r\nif (flow->filter_list) {\r\nresult = tc_classify_compat(skb,\r\nflow->filter_list,\r\n&res);\r\nif (result < 0)\r\ncontinue;\r\nflow = (struct atm_flow_data *)res.class;\r\nif (!flow)\r\nflow = lookup_flow(sch, res.classid);\r\ngoto done;\r\n}\r\n}\r\nflow = NULL;\r\ndone:\r\n;\r\n}\r\nif (!flow) {\r\nflow = &p->link;\r\n} else {\r\nif (flow->vcc)\r\nATM_SKB(skb)->atm_options = flow->vcc->atm_options;\r\n#ifdef CONFIG_NET_CLS_ACT\r\nswitch (result) {\r\ncase TC_ACT_QUEUED:\r\ncase TC_ACT_STOLEN:\r\nkfree_skb(skb);\r\nreturn NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\r\ncase TC_ACT_SHOT:\r\nkfree_skb(skb);\r\ngoto drop;\r\ncase TC_POLICE_RECLASSIFY:\r\nif (flow->excess)\r\nflow = flow->excess;\r\nelse\r\nATM_SKB(skb)->atm_options |= ATM_ATMOPT_CLP;\r\nbreak;\r\n}\r\n#endif\r\n}\r\nret = qdisc_enqueue(skb, flow->q);\r\nif (ret != NET_XMIT_SUCCESS) {\r\ndrop: __maybe_unused\r\nif (net_xmit_drop_count(ret)) {\r\nsch->qstats.drops++;\r\nif (flow)\r\nflow->qstats.drops++;\r\n}\r\nreturn ret;\r\n}\r\nif (flow == &p->link) {\r\nsch->q.qlen++;\r\nreturn NET_XMIT_SUCCESS;\r\n}\r\ntasklet_schedule(&p->task);\r\nreturn NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\r\n}\r\nstatic void sch_atm_dequeue(unsigned long data)\r\n{\r\nstruct Qdisc *sch = (struct Qdisc *)data;\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow;\r\nstruct sk_buff *skb;\r\npr_debug("sch_atm_dequeue(sch %p,[qdisc %p])\n", sch, p);\r\nlist_for_each_entry(flow, &p->flows, list) {\r\nif (flow == &p->link)\r\ncontinue;\r\nwhile ((skb = flow->q->ops->peek(flow->q))) {\r\nif (!atm_may_send(flow->vcc, skb->truesize))\r\nbreak;\r\nskb = qdisc_dequeue_peeked(flow->q);\r\nif (unlikely(!skb))\r\nbreak;\r\nqdisc_bstats_update(sch, skb);\r\nbstats_update(&flow->bstats, skb);\r\npr_debug("atm_tc_dequeue: sending on class %p\n", flow);\r\nskb_pull(skb, skb_network_offset(skb));\r\nif (skb_headroom(skb) < flow->hdr_len) {\r\nstruct sk_buff *new;\r\nnew = skb_realloc_headroom(skb, flow->hdr_len);\r\ndev_kfree_skb(skb);\r\nif (!new)\r\ncontinue;\r\nskb = new;\r\n}\r\npr_debug("sch_atm_dequeue: ip %p, data %p\n",\r\nskb_network_header(skb), skb->data);\r\nATM_SKB(skb)->vcc = flow->vcc;\r\nmemcpy(skb_push(skb, flow->hdr_len), flow->hdr,\r\nflow->hdr_len);\r\natomic_add(skb->truesize,\r\n&sk_atm(flow->vcc)->sk_wmem_alloc);\r\nflow->vcc->send(flow->vcc, skb);\r\n}\r\n}\r\n}\r\nstatic struct sk_buff *atm_tc_dequeue(struct Qdisc *sch)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct sk_buff *skb;\r\npr_debug("atm_tc_dequeue(sch %p,[qdisc %p])\n", sch, p);\r\ntasklet_schedule(&p->task);\r\nskb = qdisc_dequeue_peeked(p->link.q);\r\nif (skb)\r\nsch->q.qlen--;\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *atm_tc_peek(struct Qdisc *sch)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\npr_debug("atm_tc_peek(sch %p,[qdisc %p])\n", sch, p);\r\nreturn p->link.q->ops->peek(p->link.q);\r\n}\r\nstatic unsigned int atm_tc_drop(struct Qdisc *sch)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow;\r\nunsigned int len;\r\npr_debug("atm_tc_drop(sch %p,[qdisc %p])\n", sch, p);\r\nlist_for_each_entry(flow, &p->flows, list) {\r\nif (flow->q->ops->drop && (len = flow->q->ops->drop(flow->q)))\r\nreturn len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atm_tc_init(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\npr_debug("atm_tc_init(sch %p,[qdisc %p],opt %p)\n", sch, p, opt);\r\nINIT_LIST_HEAD(&p->flows);\r\nINIT_LIST_HEAD(&p->link.list);\r\nlist_add(&p->link.list, &p->flows);\r\np->link.q = qdisc_create_dflt(sch->dev_queue,\r\n&pfifo_qdisc_ops, sch->handle);\r\nif (!p->link.q)\r\np->link.q = &noop_qdisc;\r\npr_debug("atm_tc_init: link (%p) qdisc %p\n", &p->link, p->link.q);\r\np->link.filter_list = NULL;\r\np->link.vcc = NULL;\r\np->link.sock = NULL;\r\np->link.classid = sch->handle;\r\np->link.ref = 1;\r\ntasklet_init(&p->task, sch_atm_dequeue, (unsigned long)sch);\r\nreturn 0;\r\n}\r\nstatic void atm_tc_reset(struct Qdisc *sch)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow;\r\npr_debug("atm_tc_reset(sch %p,[qdisc %p])\n", sch, p);\r\nlist_for_each_entry(flow, &p->flows, list)\r\nqdisc_reset(flow->q);\r\nsch->q.qlen = 0;\r\n}\r\nstatic void atm_tc_destroy(struct Qdisc *sch)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow, *tmp;\r\npr_debug("atm_tc_destroy(sch %p,[qdisc %p])\n", sch, p);\r\nlist_for_each_entry(flow, &p->flows, list)\r\ntcf_destroy_chain(&flow->filter_list);\r\nlist_for_each_entry_safe(flow, tmp, &p->flows, list) {\r\nif (flow->ref > 1)\r\npr_err("atm_destroy: %p->ref = %d\n", flow, flow->ref);\r\natm_tc_put(sch, (unsigned long)flow);\r\n}\r\ntasklet_kill(&p->task);\r\n}\r\nstatic int atm_tc_dump_class(struct Qdisc *sch, unsigned long cl,\r\nstruct sk_buff *skb, struct tcmsg *tcm)\r\n{\r\nstruct atm_qdisc_data *p = qdisc_priv(sch);\r\nstruct atm_flow_data *flow = (struct atm_flow_data *)cl;\r\nstruct nlattr *nest;\r\npr_debug("atm_tc_dump_class(sch %p,[qdisc %p],flow %p,skb %p,tcm %p)\n",\r\nsch, p, flow, skb, tcm);\r\nif (list_empty(&flow->list))\r\nreturn -EINVAL;\r\ntcm->tcm_handle = flow->classid;\r\ntcm->tcm_info = flow->q->handle;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put(skb, TCA_ATM_HDR, flow->hdr_len, flow->hdr))\r\ngoto nla_put_failure;\r\nif (flow->vcc) {\r\nstruct sockaddr_atmpvc pvc;\r\nint state;\r\nmemset(&pvc, 0, sizeof(pvc));\r\npvc.sap_family = AF_ATMPVC;\r\npvc.sap_addr.itf = flow->vcc->dev ? flow->vcc->dev->number : -1;\r\npvc.sap_addr.vpi = flow->vcc->vpi;\r\npvc.sap_addr.vci = flow->vcc->vci;\r\nif (nla_put(skb, TCA_ATM_ADDR, sizeof(pvc), &pvc))\r\ngoto nla_put_failure;\r\nstate = ATM_VF2VS(flow->vcc->flags);\r\nif (nla_put_u32(skb, TCA_ATM_STATE, state))\r\ngoto nla_put_failure;\r\n}\r\nif (flow->excess) {\r\nif (nla_put_u32(skb, TCA_ATM_EXCESS, flow->classid))\r\ngoto nla_put_failure;\r\n} else {\r\nif (nla_put_u32(skb, TCA_ATM_EXCESS, 0))\r\ngoto nla_put_failure;\r\n}\r\nreturn nla_nest_end(skb, nest);\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n}\r\nstatic int\r\natm_tc_dump_class_stats(struct Qdisc *sch, unsigned long arg,\r\nstruct gnet_dump *d)\r\n{\r\nstruct atm_flow_data *flow = (struct atm_flow_data *)arg;\r\nflow->qstats.qlen = flow->q->q.qlen;\r\nif (gnet_stats_copy_basic(d, &flow->bstats) < 0 ||\r\ngnet_stats_copy_queue(d, &flow->qstats) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int atm_tc_dump(struct Qdisc *sch, struct sk_buff *skb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init atm_init(void)\r\n{\r\nreturn register_qdisc(&atm_qdisc_ops);\r\n}\r\nstatic void __exit atm_exit(void)\r\n{\r\nunregister_qdisc(&atm_qdisc_ops);\r\n}
