static ssize_t kernel_version_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "0x%x\n", COUNTER_INFO_VERSION_CURRENT);\r\n}\r\nstatic unsigned long single_gpci_request(u32 req, u32 starting_index,\r\nu16 secondary_index, u8 version_in, u32 offset, u8 length,\r\nu64 *value)\r\n{\r\nunsigned long ret;\r\nsize_t i;\r\nu64 count;\r\nstruct {\r\nstruct hv_get_perf_counter_info_params params;\r\nuint8_t bytes[GPCI_MAX_DATA_BYTES];\r\n} __packed __aligned(sizeof(uint64_t)) arg = {\r\n.params = {\r\n.counter_request = cpu_to_be32(req),\r\n.starting_index = cpu_to_be32(starting_index),\r\n.secondary_index = cpu_to_be16(secondary_index),\r\n.counter_info_version_in = version_in,\r\n}\r\n};\r\nret = plpar_hcall_norets(H_GET_PERF_COUNTER_INFO,\r\nvirt_to_phys(&arg), sizeof(arg));\r\nif (ret) {\r\npr_devel("hcall failed: 0x%lx\n", ret);\r\nreturn ret;\r\n}\r\ncount = 0;\r\nfor (i = offset; i < offset + length; i++)\r\ncount |= arg.bytes[i] << (i - offset);\r\n*value = count;\r\nreturn ret;\r\n}\r\nstatic u64 h_gpci_get_value(struct perf_event *event)\r\n{\r\nu64 count;\r\nunsigned long ret = single_gpci_request(event_get_request(event),\r\nevent_get_starting_index(event),\r\nevent_get_secondary_index(event),\r\nevent_get_counter_info_version(event),\r\nevent_get_offset(event),\r\nevent_get_length(event),\r\n&count);\r\nif (ret)\r\nreturn 0;\r\nreturn count;\r\n}\r\nstatic void h_gpci_event_update(struct perf_event *event)\r\n{\r\ns64 prev;\r\nu64 now = h_gpci_get_value(event);\r\nprev = local64_xchg(&event->hw.prev_count, now);\r\nlocal64_add(now - prev, &event->count);\r\n}\r\nstatic void h_gpci_event_start(struct perf_event *event, int flags)\r\n{\r\nlocal64_set(&event->hw.prev_count, h_gpci_get_value(event));\r\n}\r\nstatic void h_gpci_event_stop(struct perf_event *event, int flags)\r\n{\r\nh_gpci_event_update(event);\r\n}\r\nstatic int h_gpci_event_add(struct perf_event *event, int flags)\r\n{\r\nif (flags & PERF_EF_START)\r\nh_gpci_event_start(event, flags);\r\nreturn 0;\r\n}\r\nstatic int h_gpci_event_init(struct perf_event *event)\r\n{\r\nu64 count;\r\nu8 length;\r\nif (event->attr.type != event->pmu->type)\r\nreturn -ENOENT;\r\nif (event->attr.config2) {\r\npr_devel("config2 set when reserved\n");\r\nreturn -EINVAL;\r\n}\r\nif (event->attr.exclude_user ||\r\nevent->attr.exclude_kernel ||\r\nevent->attr.exclude_hv ||\r\nevent->attr.exclude_idle ||\r\nevent->attr.exclude_host ||\r\nevent->attr.exclude_guest ||\r\nis_sampling_event(event))\r\nreturn -EINVAL;\r\nif (has_branch_stack(event))\r\nreturn -EOPNOTSUPP;\r\nlength = event_get_length(event);\r\nif (length < 1 || length > 8) {\r\npr_devel("length invalid\n");\r\nreturn -EINVAL;\r\n}\r\nif ((event_get_offset(event) + length) > GPCI_MAX_DATA_BYTES) {\r\npr_devel("request outside of buffer: %zu > %zu\n",\r\n(size_t)event_get_offset(event) + length,\r\nGPCI_MAX_DATA_BYTES);\r\nreturn -EINVAL;\r\n}\r\nif (single_gpci_request(event_get_request(event),\r\nevent_get_starting_index(event),\r\nevent_get_secondary_index(event),\r\nevent_get_counter_info_version(event),\r\nevent_get_offset(event),\r\nlength,\r\n&count)) {\r\npr_devel("gpci hcall failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int h_gpci_event_idx(struct perf_event *event)\r\n{\r\nreturn 0;\r\n}\r\nstatic int hv_gpci_init(void)\r\n{\r\nint r;\r\nunsigned long hret;\r\nstruct hv_perf_caps caps;\r\nif (!firmware_has_feature(FW_FEATURE_LPAR)) {\r\npr_debug("not a virtualized system, not enabling\n");\r\nreturn -ENODEV;\r\n}\r\nhret = hv_perf_caps_get(&caps);\r\nif (hret) {\r\npr_debug("could not obtain capabilities, not enabling, rc=%ld\n",\r\nhret);\r\nreturn -ENODEV;\r\n}\r\nr = perf_pmu_register(&h_gpci_pmu, h_gpci_pmu.name, -1);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}
