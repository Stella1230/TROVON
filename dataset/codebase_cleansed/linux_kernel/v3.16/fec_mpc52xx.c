static void mpc52xx_fec_tx_timeout(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nunsigned long flags;\r\ndev_warn(&dev->dev, "transmit timed out\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\nmpc52xx_fec_reset(dev);\r\ndev->stats.tx_errors++;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void mpc52xx_fec_set_paddr(struct net_device *dev, u8 *mac)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\nout_be32(&fec->paddr1, *(u32 *)(&mac[0]));\r\nout_be32(&fec->paddr2, (*(u16 *)(&mac[4]) << 16) | FEC_PADDR2_TYPE);\r\n}\r\nstatic int mpc52xx_fec_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sock = addr;\r\nmemcpy(dev->dev_addr, sock->sa_data, dev->addr_len);\r\nmpc52xx_fec_set_paddr(dev, sock->sa_data);\r\nreturn 0;\r\n}\r\nstatic void mpc52xx_fec_free_rx_buffers(struct net_device *dev, struct bcom_task *s)\r\n{\r\nwhile (!bcom_queue_empty(s)) {\r\nstruct bcom_fec_bd *bd;\r\nstruct sk_buff *skb;\r\nskb = bcom_retrieve_buffer(s, NULL, (struct bcom_bd **)&bd);\r\ndma_unmap_single(dev->dev.parent, bd->skb_pa, skb->len,\r\nDMA_FROM_DEVICE);\r\nkfree_skb(skb);\r\n}\r\n}\r\nstatic void\r\nmpc52xx_fec_rx_submit(struct net_device *dev, struct sk_buff *rskb)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct bcom_fec_bd *bd;\r\nbd = (struct bcom_fec_bd *) bcom_prepare_next_buffer(priv->rx_dmatsk);\r\nbd->status = FEC_RX_BUFFER_SIZE;\r\nbd->skb_pa = dma_map_single(dev->dev.parent, rskb->data,\r\nFEC_RX_BUFFER_SIZE, DMA_FROM_DEVICE);\r\nbcom_submit_next_buffer(priv->rx_dmatsk, rskb);\r\n}\r\nstatic int mpc52xx_fec_alloc_rx_buffers(struct net_device *dev, struct bcom_task *rxtsk)\r\n{\r\nstruct sk_buff *skb;\r\nwhile (!bcom_queue_full(rxtsk)) {\r\nskb = netdev_alloc_skb(dev, FEC_RX_BUFFER_SIZE);\r\nif (!skb)\r\nreturn -EAGAIN;\r\nmemset(skb->data, 0, FEC_RX_BUFFER_SIZE);\r\nmpc52xx_fec_rx_submit(dev, skb);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mpc52xx_fec_adjust_link(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phydev = priv->phydev;\r\nint new_state = 0;\r\nif (phydev->link != PHY_DOWN) {\r\nif (phydev->duplex != priv->duplex) {\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\nu32 rcntrl;\r\nu32 tcntrl;\r\nnew_state = 1;\r\npriv->duplex = phydev->duplex;\r\nrcntrl = in_be32(&fec->r_cntrl);\r\ntcntrl = in_be32(&fec->x_cntrl);\r\nrcntrl &= ~FEC_RCNTRL_DRT;\r\ntcntrl &= ~FEC_TCNTRL_FDEN;\r\nif (phydev->duplex == DUPLEX_FULL)\r\ntcntrl |= FEC_TCNTRL_FDEN;\r\nelse\r\nrcntrl |= FEC_RCNTRL_DRT;\r\nout_be32(&fec->r_cntrl, rcntrl);\r\nout_be32(&fec->x_cntrl, tcntrl);\r\n}\r\nif (phydev->speed != priv->speed) {\r\nnew_state = 1;\r\npriv->speed = phydev->speed;\r\n}\r\nif (priv->link == PHY_DOWN) {\r\nnew_state = 1;\r\npriv->link = phydev->link;\r\n}\r\n} else if (priv->link) {\r\nnew_state = 1;\r\npriv->link = PHY_DOWN;\r\npriv->speed = 0;\r\npriv->duplex = -1;\r\n}\r\nif (new_state && netif_msg_link(priv))\r\nphy_print_status(phydev);\r\n}\r\nstatic int mpc52xx_fec_open(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nint err = -EBUSY;\r\nif (priv->phy_node) {\r\npriv->phydev = of_phy_connect(priv->ndev, priv->phy_node,\r\nmpc52xx_fec_adjust_link, 0, 0);\r\nif (!priv->phydev) {\r\ndev_err(&dev->dev, "of_phy_connect failed\n");\r\nreturn -ENODEV;\r\n}\r\nphy_start(priv->phydev);\r\n}\r\nif (request_irq(dev->irq, mpc52xx_fec_interrupt, IRQF_SHARED,\r\nDRIVER_NAME "_ctrl", dev)) {\r\ndev_err(&dev->dev, "ctrl interrupt request failed\n");\r\ngoto free_phy;\r\n}\r\nif (request_irq(priv->r_irq, mpc52xx_fec_rx_interrupt, 0,\r\nDRIVER_NAME "_rx", dev)) {\r\ndev_err(&dev->dev, "rx interrupt request failed\n");\r\ngoto free_ctrl_irq;\r\n}\r\nif (request_irq(priv->t_irq, mpc52xx_fec_tx_interrupt, 0,\r\nDRIVER_NAME "_tx", dev)) {\r\ndev_err(&dev->dev, "tx interrupt request failed\n");\r\ngoto free_2irqs;\r\n}\r\nbcom_fec_rx_reset(priv->rx_dmatsk);\r\nbcom_fec_tx_reset(priv->tx_dmatsk);\r\nerr = mpc52xx_fec_alloc_rx_buffers(dev, priv->rx_dmatsk);\r\nif (err) {\r\ndev_err(&dev->dev, "mpc52xx_fec_alloc_rx_buffers failed\n");\r\ngoto free_irqs;\r\n}\r\nbcom_enable(priv->rx_dmatsk);\r\nbcom_enable(priv->tx_dmatsk);\r\nmpc52xx_fec_start(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nfree_irqs:\r\nfree_irq(priv->t_irq, dev);\r\nfree_2irqs:\r\nfree_irq(priv->r_irq, dev);\r\nfree_ctrl_irq:\r\nfree_irq(dev->irq, dev);\r\nfree_phy:\r\nif (priv->phydev) {\r\nphy_stop(priv->phydev);\r\nphy_disconnect(priv->phydev);\r\npriv->phydev = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int mpc52xx_fec_close(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nmpc52xx_fec_stop(dev);\r\nmpc52xx_fec_free_rx_buffers(dev, priv->rx_dmatsk);\r\nfree_irq(dev->irq, dev);\r\nfree_irq(priv->r_irq, dev);\r\nfree_irq(priv->t_irq, dev);\r\nif (priv->phydev) {\r\nphy_stop(priv->phydev);\r\nphy_disconnect(priv->phydev);\r\npriv->phydev = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_fec_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct bcom_fec_bd *bd;\r\nunsigned long flags;\r\nif (bcom_queue_full(priv->tx_dmatsk)) {\r\nif (net_ratelimit())\r\ndev_err(&dev->dev, "transmit queue overrun\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nbd = (struct bcom_fec_bd *)\r\nbcom_prepare_next_buffer(priv->tx_dmatsk);\r\nbd->status = skb->len | BCOM_FEC_TX_BD_TFD | BCOM_FEC_TX_BD_TC;\r\nbd->skb_pa = dma_map_single(dev->dev.parent, skb->data, skb->len,\r\nDMA_TO_DEVICE);\r\nskb_tx_timestamp(skb);\r\nbcom_submit_next_buffer(priv->tx_dmatsk, skb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (bcom_queue_full(priv->tx_dmatsk)) {\r\nnetif_stop_queue(dev);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void mpc52xx_fec_poll_controller(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\ndisable_irq(priv->t_irq);\r\nmpc52xx_fec_tx_interrupt(priv->t_irq, dev);\r\nenable_irq(priv->t_irq);\r\ndisable_irq(priv->r_irq);\r\nmpc52xx_fec_rx_interrupt(priv->r_irq, dev);\r\nenable_irq(priv->r_irq);\r\n}\r\nstatic irqreturn_t mpc52xx_fec_tx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nspin_lock(&priv->lock);\r\nwhile (bcom_buffer_done(priv->tx_dmatsk)) {\r\nstruct sk_buff *skb;\r\nstruct bcom_fec_bd *bd;\r\nskb = bcom_retrieve_buffer(priv->tx_dmatsk, NULL,\r\n(struct bcom_bd **)&bd);\r\ndma_unmap_single(dev->dev.parent, bd->skb_pa, skb->len,\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb_irq(skb);\r\n}\r\nspin_unlock(&priv->lock);\r\nnetif_wake_queue(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mpc52xx_fec_rx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct sk_buff *rskb;\r\nstruct sk_buff *skb;\r\nstruct bcom_fec_bd *bd;\r\nu32 status, physaddr;\r\nint length;\r\nspin_lock(&priv->lock);\r\nwhile (bcom_buffer_done(priv->rx_dmatsk)) {\r\nrskb = bcom_retrieve_buffer(priv->rx_dmatsk, &status,\r\n(struct bcom_bd **)&bd);\r\nphysaddr = bd->skb_pa;\r\nif (status & BCOM_FEC_RX_BD_ERRORS) {\r\nmpc52xx_fec_rx_submit(dev, rskb);\r\ndev->stats.rx_dropped++;\r\ncontinue;\r\n}\r\nskb = netdev_alloc_skb(dev, FEC_RX_BUFFER_SIZE);\r\nif (!skb) {\r\ndev_notice(&dev->dev, "Low memory - dropped packet.\n");\r\nmpc52xx_fec_rx_submit(dev, rskb);\r\ndev->stats.rx_dropped++;\r\ncontinue;\r\n}\r\nmpc52xx_fec_rx_submit(dev, skb);\r\nspin_unlock(&priv->lock);\r\ndma_unmap_single(dev->dev.parent, physaddr, rskb->len,\r\nDMA_FROM_DEVICE);\r\nlength = status & BCOM_FEC_RX_BD_LEN_MASK;\r\nskb_put(rskb, length - 4);\r\nrskb->protocol = eth_type_trans(rskb, dev);\r\nif (!skb_defer_rx_timestamp(rskb))\r\nnetif_rx(rskb);\r\nspin_lock(&priv->lock);\r\n}\r\nspin_unlock(&priv->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mpc52xx_fec_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\nu32 ievent;\r\nievent = in_be32(&fec->ievent);\r\nievent &= ~FEC_IEVENT_MII;\r\nif (!ievent)\r\nreturn IRQ_NONE;\r\nout_be32(&fec->ievent, ievent);\r\nif (ievent & (FEC_IEVENT_RFIFO_ERROR | FEC_IEVENT_XFIFO_ERROR)) {\r\nif (net_ratelimit() && (ievent & FEC_IEVENT_RFIFO_ERROR))\r\ndev_warn(&dev->dev, "FEC_IEVENT_RFIFO_ERROR\n");\r\nif (net_ratelimit() && (ievent & FEC_IEVENT_XFIFO_ERROR))\r\ndev_warn(&dev->dev, "FEC_IEVENT_XFIFO_ERROR\n");\r\nspin_lock(&priv->lock);\r\nmpc52xx_fec_reset(dev);\r\nspin_unlock(&priv->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (ievent & ~FEC_IEVENT_TFINT)\r\ndev_dbg(&dev->dev, "ievent: %08x\n", ievent);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct net_device_stats *mpc52xx_fec_get_stats(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\nstats->rx_bytes = in_be32(&fec->rmon_r_octets);\r\nstats->rx_packets = in_be32(&fec->rmon_r_packets);\r\nstats->rx_errors = in_be32(&fec->rmon_r_crc_align) +\r\nin_be32(&fec->rmon_r_undersize) +\r\nin_be32(&fec->rmon_r_oversize) +\r\nin_be32(&fec->rmon_r_frag) +\r\nin_be32(&fec->rmon_r_jab);\r\nstats->tx_bytes = in_be32(&fec->rmon_t_octets);\r\nstats->tx_packets = in_be32(&fec->rmon_t_packets);\r\nstats->tx_errors = in_be32(&fec->rmon_t_crc_align) +\r\nin_be32(&fec->rmon_t_undersize) +\r\nin_be32(&fec->rmon_t_oversize) +\r\nin_be32(&fec->rmon_t_frag) +\r\nin_be32(&fec->rmon_t_jab);\r\nstats->multicast = in_be32(&fec->rmon_r_mc_pkt);\r\nstats->collisions = in_be32(&fec->rmon_t_col);\r\nstats->rx_length_errors = in_be32(&fec->rmon_r_undersize)\r\n+ in_be32(&fec->rmon_r_oversize)\r\n+ in_be32(&fec->rmon_r_frag)\r\n+ in_be32(&fec->rmon_r_jab);\r\nstats->rx_over_errors = in_be32(&fec->r_macerr);\r\nstats->rx_crc_errors = in_be32(&fec->ieee_r_crc);\r\nstats->rx_frame_errors = in_be32(&fec->ieee_r_align);\r\nstats->rx_fifo_errors = in_be32(&fec->rmon_r_drop);\r\nstats->rx_missed_errors = in_be32(&fec->rmon_r_drop);\r\nstats->tx_aborted_errors = 0;\r\nstats->tx_carrier_errors = in_be32(&fec->ieee_t_cserr);\r\nstats->tx_fifo_errors = in_be32(&fec->rmon_t_drop);\r\nstats->tx_heartbeat_errors = in_be32(&fec->ieee_t_sqe);\r\nstats->tx_window_errors = in_be32(&fec->ieee_t_lcol);\r\nreturn stats;\r\n}\r\nstatic void mpc52xx_fec_reset_stats(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\nout_be32(&fec->mib_control, FEC_MIB_DISABLE);\r\nmemset_io(&fec->rmon_t_drop, 0,\r\noffsetof(struct mpc52xx_fec, reserved10) -\r\noffsetof(struct mpc52xx_fec, rmon_t_drop));\r\nout_be32(&fec->mib_control, 0);\r\nmemset(&dev->stats, 0, sizeof(dev->stats));\r\n}\r\nstatic void mpc52xx_fec_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\nu32 rx_control;\r\nrx_control = in_be32(&fec->r_cntrl);\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_control |= FEC_RCNTRL_PROM;\r\nout_be32(&fec->r_cntrl, rx_control);\r\n} else {\r\nrx_control &= ~FEC_RCNTRL_PROM;\r\nout_be32(&fec->r_cntrl, rx_control);\r\nif (dev->flags & IFF_ALLMULTI) {\r\nout_be32(&fec->gaddr1, 0xffffffff);\r\nout_be32(&fec->gaddr2, 0xffffffff);\r\n} else {\r\nu32 crc;\r\nstruct netdev_hw_addr *ha;\r\nu32 gaddr1 = 0x00000000;\r\nu32 gaddr2 = 0x00000000;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(6, ha->addr) >> 26;\r\nif (crc >= 32)\r\ngaddr1 |= 1 << (crc-32);\r\nelse\r\ngaddr2 |= 1 << crc;\r\n}\r\nout_be32(&fec->gaddr1, gaddr1);\r\nout_be32(&fec->gaddr2, gaddr2);\r\n}\r\n}\r\n}\r\nstatic void mpc52xx_fec_hw_init(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\nint i;\r\nout_be32(&fec->ecntrl, FEC_ECNTRL_RESET);\r\nfor (i = 0; i < FEC_RESET_DELAY; ++i) {\r\nif ((in_be32(&fec->ecntrl) & FEC_ECNTRL_RESET) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == FEC_RESET_DELAY)\r\ndev_err(&dev->dev, "FEC Reset timeout!\n");\r\nout_be32(&fec->op_pause, FEC_OP_PAUSE_OPCODE | 0x20);\r\nout_be32(&fec->rfifo_cntrl, FEC_FIFO_CNTRL_FRAME | FEC_FIFO_CNTRL_LTG_7);\r\nout_be32(&fec->tfifo_cntrl, FEC_FIFO_CNTRL_FRAME | FEC_FIFO_CNTRL_LTG_7);\r\nout_be32(&fec->rfifo_alarm, 0x0000030c);\r\nout_be32(&fec->tfifo_alarm, 0x00000100);\r\nout_be32(&fec->x_wmrk, FEC_FIFO_WMRK_256B);\r\nout_be32(&fec->xmit_fsm, FEC_XMIT_FSM_APPEND_CRC | FEC_XMIT_FSM_ENABLE_CRC);\r\nout_be32(&fec->iaddr1, 0x00000000);\r\nout_be32(&fec->iaddr2, 0x00000000);\r\nout_be32(&fec->mii_speed, priv->mdio_speed);\r\n}\r\nstatic void mpc52xx_fec_start(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\nu32 rcntrl;\r\nu32 tcntrl;\r\nu32 tmp;\r\ntmp = FEC_FIFO_STATUS_ERR | FEC_FIFO_STATUS_UF | FEC_FIFO_STATUS_OF;\r\nout_be32(&fec->rfifo_status, in_be32(&fec->rfifo_status) & tmp);\r\nout_be32(&fec->tfifo_status, in_be32(&fec->tfifo_status) & tmp);\r\nout_be32(&fec->reset_cntrl, FEC_RESET_CNTRL_ENABLE_IS_RESET);\r\nmpc52xx_fec_set_paddr(dev, dev->dev_addr);\r\nmpc52xx_fec_set_multicast_list(dev);\r\nrcntrl = FEC_RX_BUFFER_SIZE << 16;\r\nrcntrl |= FEC_RCNTRL_FCE;\r\nif (!priv->seven_wire_mode)\r\nrcntrl |= FEC_RCNTRL_MII_MODE;\r\nif (priv->duplex == DUPLEX_FULL)\r\ntcntrl = FEC_TCNTRL_FDEN;\r\nelse {\r\nrcntrl |= FEC_RCNTRL_DRT;\r\ntcntrl = 0;\r\n}\r\nout_be32(&fec->r_cntrl, rcntrl);\r\nout_be32(&fec->x_cntrl, tcntrl);\r\nout_be32(&fec->ievent, 0xffffffff);\r\nout_be32(&fec->imask, FEC_IMASK_ENABLE);\r\nout_be32(&fec->ecntrl, FEC_ECNTRL_ETHER_EN);\r\nout_be32(&fec->r_des_active, 0x01000000);\r\n}\r\nstatic void mpc52xx_fec_stop(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\nunsigned long timeout;\r\nout_be32(&fec->imask, 0);\r\nbcom_disable(priv->rx_dmatsk);\r\nif (!in_interrupt()) {\r\ntimeout = jiffies + msecs_to_jiffies(2000);\r\nwhile (time_before(jiffies, timeout) &&\r\n!bcom_queue_empty(priv->tx_dmatsk))\r\nmsleep(100);\r\nif (time_after_eq(jiffies, timeout))\r\ndev_err(&dev->dev, "queues didn't drain\n");\r\n#if 1\r\nif (time_after_eq(jiffies, timeout)) {\r\ndev_err(&dev->dev, " tx: index: %i, outdex: %i\n",\r\npriv->tx_dmatsk->index,\r\npriv->tx_dmatsk->outdex);\r\ndev_err(&dev->dev, " rx: index: %i, outdex: %i\n",\r\npriv->rx_dmatsk->index,\r\npriv->rx_dmatsk->outdex);\r\n}\r\n#endif\r\n}\r\nbcom_disable(priv->tx_dmatsk);\r\nout_be32(&fec->ecntrl, in_be32(&fec->ecntrl) & ~FEC_ECNTRL_ETHER_EN);\r\n}\r\nstatic void mpc52xx_fec_reset(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\nmpc52xx_fec_stop(dev);\r\nout_be32(&fec->rfifo_status, in_be32(&fec->rfifo_status));\r\nout_be32(&fec->reset_cntrl, FEC_RESET_CNTRL_RESET_FIFO);\r\nmpc52xx_fec_free_rx_buffers(dev, priv->rx_dmatsk);\r\nmpc52xx_fec_hw_init(dev);\r\nbcom_fec_rx_reset(priv->rx_dmatsk);\r\nbcom_fec_tx_reset(priv->tx_dmatsk);\r\nmpc52xx_fec_alloc_rx_buffers(dev, priv->rx_dmatsk);\r\nbcom_enable(priv->rx_dmatsk);\r\nbcom_enable(priv->tx_dmatsk);\r\nmpc52xx_fec_start(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int mpc52xx_fec_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nif (!priv->phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_gset(priv->phydev, cmd);\r\n}\r\nstatic int mpc52xx_fec_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nif (!priv->phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_sset(priv->phydev, cmd);\r\n}\r\nstatic u32 mpc52xx_fec_get_msglevel(struct net_device *dev)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nreturn priv->msg_enable;\r\n}\r\nstatic void mpc52xx_fec_set_msglevel(struct net_device *dev, u32 level)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\npriv->msg_enable = level;\r\n}\r\nstatic int mpc52xx_fec_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\r\nif (!priv->phydev)\r\nreturn -ENOTSUPP;\r\nreturn phy_mii_ioctl(priv->phydev, rq, cmd);\r\n}\r\nstatic int mpc52xx_fec_probe(struct platform_device *op)\r\n{\r\nint rv;\r\nstruct net_device *ndev;\r\nstruct mpc52xx_fec_priv *priv = NULL;\r\nstruct resource mem;\r\nconst u32 *prop;\r\nint prop_size;\r\nstruct device_node *np = op->dev.of_node;\r\nconst char *mac_addr;\r\nphys_addr_t rx_fifo;\r\nphys_addr_t tx_fifo;\r\nndev = alloc_etherdev(sizeof(struct mpc52xx_fec_priv));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\npriv = netdev_priv(ndev);\r\npriv->ndev = ndev;\r\nrv = of_address_to_resource(np, 0, &mem);\r\nif (rv) {\r\npr_err("Error while parsing device node resource\n");\r\ngoto err_netdev;\r\n}\r\nif (resource_size(&mem) < sizeof(struct mpc52xx_fec)) {\r\npr_err("invalid resource size (%lx < %x), check mpc52xx_devices.c\n",\r\n(unsigned long)resource_size(&mem),\r\nsizeof(struct mpc52xx_fec));\r\nrv = -EINVAL;\r\ngoto err_netdev;\r\n}\r\nif (!request_mem_region(mem.start, sizeof(struct mpc52xx_fec),\r\nDRIVER_NAME)) {\r\nrv = -EBUSY;\r\ngoto err_netdev;\r\n}\r\nndev->netdev_ops = &mpc52xx_fec_netdev_ops;\r\nndev->ethtool_ops = &mpc52xx_fec_ethtool_ops;\r\nndev->watchdog_timeo = FEC_WATCHDOG_TIMEOUT;\r\nndev->base_addr = mem.start;\r\nSET_NETDEV_DEV(ndev, &op->dev);\r\nspin_lock_init(&priv->lock);\r\npriv->fec = ioremap(mem.start, sizeof(struct mpc52xx_fec));\r\nif (!priv->fec) {\r\nrv = -ENOMEM;\r\ngoto err_mem_region;\r\n}\r\nrx_fifo = ndev->base_addr + offsetof(struct mpc52xx_fec, rfifo_data);\r\ntx_fifo = ndev->base_addr + offsetof(struct mpc52xx_fec, tfifo_data);\r\npriv->rx_dmatsk = bcom_fec_rx_init(FEC_RX_NUM_BD, rx_fifo, FEC_RX_BUFFER_SIZE);\r\npriv->tx_dmatsk = bcom_fec_tx_init(FEC_TX_NUM_BD, tx_fifo);\r\nif (!priv->rx_dmatsk || !priv->tx_dmatsk) {\r\npr_err("Can not init SDMA tasks\n");\r\nrv = -ENOMEM;\r\ngoto err_rx_tx_dmatsk;\r\n}\r\nndev->irq = irq_of_parse_and_map(np, 0);\r\npriv->r_irq = bcom_get_task_irq(priv->rx_dmatsk);\r\npriv->t_irq = bcom_get_task_irq(priv->tx_dmatsk);\r\nmac_addr = of_get_mac_address(np);\r\nif (mac_addr) {\r\nmemcpy(ndev->dev_addr, mac_addr, ETH_ALEN);\r\n} else {\r\nstruct mpc52xx_fec __iomem *fec = priv->fec;\r\n*(u32 *)(&ndev->dev_addr[0]) = in_be32(&fec->paddr1);\r\n*(u16 *)(&ndev->dev_addr[4]) = in_be32(&fec->paddr2) >> 16;\r\n}\r\nif (!is_valid_ether_addr(ndev->dev_addr)) {\r\neth_hw_addr_random(ndev);\r\ndev_warn(&ndev->dev, "using random MAC address %pM\n",\r\nndev->dev_addr);\r\n}\r\npriv->msg_enable = netif_msg_init(debug, MPC52xx_MESSAGES_DEFAULT);\r\npriv->speed = 100;\r\npriv->duplex = DUPLEX_HALF;\r\npriv->mdio_speed = ((mpc5xxx_get_bus_frequency(np) >> 20) / 5) << 1;\r\nprop = of_get_property(np, "current-speed", &prop_size);\r\nif (prop && (prop_size >= sizeof(u32) * 2)) {\r\npriv->speed = prop[0];\r\npriv->duplex = prop[1] ? DUPLEX_FULL : DUPLEX_HALF;\r\n}\r\npriv->phy_node = of_parse_phandle(np, "phy-handle", 0);\r\nif (of_find_property(np, "fsl,7-wire-mode", NULL)) {\r\npriv->seven_wire_mode = 1;\r\ndev_info(&ndev->dev, "using 7-wire PHY mode\n");\r\n}\r\nmpc52xx_fec_hw_init(ndev);\r\nmpc52xx_fec_reset_stats(ndev);\r\nrv = register_netdev(ndev);\r\nif (rv < 0)\r\ngoto err_node;\r\nplatform_set_drvdata(op, ndev);\r\nnetdev_info(ndev, "%s MAC %pM\n",\r\nop->dev.of_node->full_name, ndev->dev_addr);\r\nreturn 0;\r\nerr_node:\r\nof_node_put(priv->phy_node);\r\nirq_dispose_mapping(ndev->irq);\r\nerr_rx_tx_dmatsk:\r\nif (priv->rx_dmatsk)\r\nbcom_fec_rx_release(priv->rx_dmatsk);\r\nif (priv->tx_dmatsk)\r\nbcom_fec_tx_release(priv->tx_dmatsk);\r\niounmap(priv->fec);\r\nerr_mem_region:\r\nrelease_mem_region(mem.start, sizeof(struct mpc52xx_fec));\r\nerr_netdev:\r\nfree_netdev(ndev);\r\nreturn rv;\r\n}\r\nstatic int\r\nmpc52xx_fec_remove(struct platform_device *op)\r\n{\r\nstruct net_device *ndev;\r\nstruct mpc52xx_fec_priv *priv;\r\nndev = platform_get_drvdata(op);\r\npriv = netdev_priv(ndev);\r\nunregister_netdev(ndev);\r\nif (priv->phy_node)\r\nof_node_put(priv->phy_node);\r\npriv->phy_node = NULL;\r\nirq_dispose_mapping(ndev->irq);\r\nbcom_fec_rx_release(priv->rx_dmatsk);\r\nbcom_fec_tx_release(priv->tx_dmatsk);\r\niounmap(priv->fec);\r\nrelease_mem_region(ndev->base_addr, sizeof(struct mpc52xx_fec));\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_fec_of_suspend(struct platform_device *op, pm_message_t state)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(op);\r\nif (netif_running(dev))\r\nmpc52xx_fec_close(dev);\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_fec_of_resume(struct platform_device *op)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(op);\r\nmpc52xx_fec_hw_init(dev);\r\nmpc52xx_fec_reset_stats(dev);\r\nif (netif_running(dev))\r\nmpc52xx_fec_open(dev);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nmpc52xx_fec_init(void)\r\n{\r\n#ifdef CONFIG_FEC_MPC52xx_MDIO\r\nint ret;\r\nret = platform_driver_register(&mpc52xx_fec_mdio_driver);\r\nif (ret) {\r\npr_err("failed to register mdio driver\n");\r\nreturn ret;\r\n}\r\n#endif\r\nreturn platform_driver_register(&mpc52xx_fec_driver);\r\n}\r\nstatic void __exit\r\nmpc52xx_fec_exit(void)\r\n{\r\nplatform_driver_unregister(&mpc52xx_fec_driver);\r\n#ifdef CONFIG_FEC_MPC52xx_MDIO\r\nplatform_driver_unregister(&mpc52xx_fec_mdio_driver);\r\n#endif\r\n}
