int cx231xx_tuner_callback(void *ptr, int component, int command, int arg)\r\n{\r\nint rc = 0;\r\nstruct cx231xx *dev = ptr;\r\nif (dev->tuner_type == TUNER_XC5000) {\r\nif (command == XC5000_TUNER_RESET) {\r\ncx231xx_info\r\n("Tuner CB: RESET: cmd %d : tuner type %d \n",\r\ncommand, dev->tuner_type);\r\ncx231xx_set_gpio_value(dev, dev->board.tuner_gpio->bit,\r\n1);\r\nmsleep(10);\r\ncx231xx_set_gpio_value(dev, dev->board.tuner_gpio->bit,\r\n0);\r\nmsleep(330);\r\ncx231xx_set_gpio_value(dev, dev->board.tuner_gpio->bit,\r\n1);\r\nmsleep(10);\r\n}\r\n} else if (dev->tuner_type == TUNER_NXP_TDA18271) {\r\nswitch (command) {\r\ncase TDA18271_CALLBACK_CMD_AGC_ENABLE:\r\nif (dev->model == CX231XX_BOARD_PV_PLAYTV_USB_HYBRID)\r\nrc = cx231xx_set_agc_analog_digital_mux_select(dev, arg);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void cx231xx_reset_out(struct cx231xx *dev)\r\n{\r\ncx231xx_set_gpio_value(dev, CX23417_RESET, 1);\r\nmsleep(200);\r\ncx231xx_set_gpio_value(dev, CX23417_RESET, 0);\r\nmsleep(200);\r\ncx231xx_set_gpio_value(dev, CX23417_RESET, 1);\r\n}\r\nstatic void cx231xx_enable_OSC(struct cx231xx *dev)\r\n{\r\ncx231xx_set_gpio_value(dev, CX23417_OSC_EN, 1);\r\n}\r\nstatic void cx231xx_sleep_s5h1432(struct cx231xx *dev)\r\n{\r\ncx231xx_set_gpio_value(dev, SLEEP_S5H1432, 0);\r\n}\r\nstatic inline void cx231xx_set_model(struct cx231xx *dev)\r\n{\r\ndev->board = cx231xx_boards[dev->model];\r\n}\r\nvoid cx231xx_pre_card_setup(struct cx231xx *dev)\r\n{\r\ncx231xx_set_model(dev);\r\ncx231xx_info("Identified as %s (card=%d)\n",\r\ndev->board.name, dev->model);\r\nif (dev->board.tuner_gpio) {\r\ncx231xx_set_gpio_direction(dev, dev->board.tuner_gpio->bit, 1);\r\ncx231xx_set_gpio_value(dev, dev->board.tuner_gpio->bit, 1);\r\n}\r\nif (dev->board.tuner_sif_gpio >= 0)\r\ncx231xx_set_gpio_direction(dev, dev->board.tuner_sif_gpio, 1);\r\ncx231xx_set_mode(dev, CX231XX_ANALOG_MODE);\r\n}\r\nstatic void cx231xx_config_tuner(struct cx231xx *dev)\r\n{\r\nstruct tuner_setup tun_setup;\r\nstruct v4l2_frequency f;\r\nif (dev->tuner_type == TUNER_ABSENT)\r\nreturn;\r\ntun_setup.mode_mask = T_ANALOG_TV | T_RADIO;\r\ntun_setup.type = dev->tuner_type;\r\ntun_setup.addr = dev->tuner_addr;\r\ntun_setup.tuner_callback = cx231xx_tuner_callback;\r\ntuner_call(dev, tuner, s_type_addr, &tun_setup);\r\n#if 0\r\nif (tun_setup.type == TUNER_XC5000) {\r\nstatic struct xc2028_ctrl ctrl = {\r\n.fname = XC5000_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n.demod = 0;\r\n};\r\nstruct v4l2_priv_tun_config cfg = {\r\n.tuner = dev->tuner_type,\r\n.priv = &ctrl,\r\n};\r\ntuner_call(dev, tuner, s_config, &cfg);\r\n}\r\n#endif\r\nf.tuner = 0;\r\nf.type = V4L2_TUNER_ANALOG_TV;\r\nf.frequency = 9076;\r\ndev->ctl_freq = f.frequency;\r\ncall_all(dev, tuner, s_frequency, &f);\r\n}\r\nvoid cx231xx_card_setup(struct cx231xx *dev)\r\n{\r\ncx231xx_set_model(dev);\r\ndev->tuner_type = cx231xx_boards[dev->model].tuner_type;\r\nif (cx231xx_boards[dev->model].tuner_addr)\r\ndev->tuner_addr = cx231xx_boards[dev->model].tuner_addr;\r\nif (dev->board.decoder == CX231XX_AVDECODER) {\r\ndev->sd_cx25840 = v4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_bus[0].i2c_adap,\r\n"cx25840", 0x88 >> 1, NULL);\r\nif (dev->sd_cx25840 == NULL)\r\ncx231xx_info("cx25840 subdev registration failure\n");\r\ncx25840_call(dev, core, load_fw);\r\n}\r\nif (dev->board.tuner_type != TUNER_ABSENT) {\r\ndev->sd_tuner = v4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_bus[dev->board.tuner_i2c_master].i2c_adap,\r\n"tuner",\r\ndev->tuner_addr, NULL);\r\nif (dev->sd_tuner == NULL)\r\ncx231xx_info("tuner subdev registration failure\n");\r\nelse\r\ncx231xx_config_tuner(dev);\r\n}\r\n}\r\nint cx231xx_config(struct cx231xx *dev)\r\n{\r\nreturn 0;\r\n}\r\nvoid cx231xx_config_i2c(struct cx231xx *dev)\r\n{\r\ncall_all(dev, video, s_stream, 1);\r\n}\r\nvoid cx231xx_release_resources(struct cx231xx *dev)\r\n{\r\ncx231xx_release_analog_resources(dev);\r\ncx231xx_remove_from_devlist(dev);\r\ncx231xx_ir_exit(dev);\r\ncx231xx_dev_uninit(dev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nusb_put_dev(dev->udev);\r\nclear_bit(dev->devno, &cx231xx_devused);\r\nkfree(dev->video_mode.alt_max_pkt_size);\r\nkfree(dev->vbi_mode.alt_max_pkt_size);\r\nkfree(dev->sliced_cc_mode.alt_max_pkt_size);\r\nkfree(dev->ts1_mode.alt_max_pkt_size);\r\nkfree(dev);\r\n}\r\nstatic int cx231xx_init_dev(struct cx231xx *dev, struct usb_device *udev,\r\nint minor)\r\n{\r\nint retval = -ENOMEM;\r\nunsigned int maxh, maxw;\r\ndev->udev = udev;\r\nmutex_init(&dev->lock);\r\nmutex_init(&dev->ctrl_urb_lock);\r\nmutex_init(&dev->gpio_i2c_lock);\r\nmutex_init(&dev->i2c_lock);\r\nspin_lock_init(&dev->video_mode.slock);\r\nspin_lock_init(&dev->vbi_mode.slock);\r\nspin_lock_init(&dev->sliced_cc_mode.slock);\r\ninit_waitqueue_head(&dev->open);\r\ninit_waitqueue_head(&dev->wait_frame);\r\ninit_waitqueue_head(&dev->wait_stream);\r\ndev->cx231xx_read_ctrl_reg = cx231xx_read_ctrl_reg;\r\ndev->cx231xx_write_ctrl_reg = cx231xx_write_ctrl_reg;\r\ndev->cx231xx_send_usb_command = cx231xx_send_usb_command;\r\ndev->cx231xx_gpio_i2c_read = cx231xx_gpio_i2c_read;\r\ndev->cx231xx_gpio_i2c_write = cx231xx_gpio_i2c_write;\r\ninitialize_cx231xx(dev);\r\nif (dev->model == CX231XX_BOARD_CNXT_VIDEO_GRABBER ||\r\ndev->model == CX231XX_BOARD_HAUPPAUGE_USBLIVE2) {\r\ncx231xx_set_alt_setting(dev, INDEX_VIDEO, 3);\r\ncx231xx_set_alt_setting(dev, INDEX_VANC, 1);\r\n}\r\ncx231xx_pre_card_setup(dev);\r\nretval = cx231xx_config(dev);\r\nif (retval) {\r\ncx231xx_errdev("error configuring device\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->norm = dev->board.norm;\r\nretval = cx231xx_dev_init(dev);\r\nif (retval) {\r\ncx231xx_errdev("%s: cx231xx_i2c_register - errCode [%d]!\n",\r\n__func__, retval);\r\ngoto err_dev_init;\r\n}\r\ncx231xx_card_setup(dev);\r\ncx231xx_config_i2c(dev);\r\nmaxw = norm_maxw(dev);\r\nmaxh = norm_maxh(dev);\r\ndev->width = maxw;\r\ndev->height = maxh;\r\ndev->interlaced = 0;\r\ndev->video_input = 0;\r\nretval = cx231xx_config(dev);\r\nif (retval) {\r\ncx231xx_errdev("%s: cx231xx_config - errCode [%d]!\n",\r\n__func__, retval);\r\ngoto err_dev_init;\r\n}\r\nINIT_LIST_HEAD(&dev->video_mode.vidq.active);\r\nINIT_LIST_HEAD(&dev->video_mode.vidq.queued);\r\nINIT_LIST_HEAD(&dev->vbi_mode.vidq.active);\r\nINIT_LIST_HEAD(&dev->vbi_mode.vidq.queued);\r\ncx231xx_add_into_devlist(dev);\r\nif (dev->board.has_417) {\r\nprintk(KERN_INFO "attach 417 %d\n", dev->model);\r\nif (cx231xx_417_register(dev) < 0) {\r\nprintk(KERN_ERR\r\n"%s() Failed to register 417 on VID_B\n",\r\n__func__);\r\n}\r\n}\r\nretval = cx231xx_register_analog_devices(dev);\r\nif (retval) {\r\ncx231xx_release_analog_resources(dev);\r\ngoto err_analog;\r\n}\r\ncx231xx_ir_init(dev);\r\ncx231xx_init_extension(dev);\r\nreturn 0;\r\nerr_analog:\r\ncx231xx_remove_from_devlist(dev);\r\nerr_dev_init:\r\ncx231xx_dev_uninit(dev);\r\nreturn retval;\r\n}\r\nstatic void request_module_async(struct work_struct *work)\r\n{\r\nstruct cx231xx *dev = container_of(work,\r\nstruct cx231xx, request_module_wk);\r\nif (dev->has_alsa_audio)\r\nrequest_module("cx231xx-alsa");\r\nif (dev->board.has_dvb)\r\nrequest_module("cx231xx-dvb");\r\n}\r\nstatic void request_modules(struct cx231xx *dev)\r\n{\r\nINIT_WORK(&dev->request_module_wk, request_module_async);\r\nschedule_work(&dev->request_module_wk);\r\n}\r\nstatic void flush_request_modules(struct cx231xx *dev)\r\n{\r\nflush_work(&dev->request_module_wk);\r\n}\r\nstatic int cx231xx_usb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev;\r\nstruct usb_interface *uif;\r\nstruct cx231xx *dev = NULL;\r\nint retval = -ENODEV;\r\nint nr = 0, ifnum;\r\nint i, isoc_pipe = 0;\r\nchar *speed;\r\nstruct usb_interface_assoc_descriptor *assoc_desc;\r\nifnum = interface->altsetting[0].desc.bInterfaceNumber;\r\nif (ifnum != 1)\r\nreturn -ENODEV;\r\ndo {\r\nnr = find_first_zero_bit(&cx231xx_devused, CX231XX_MAXBOARDS);\r\nif (nr >= CX231XX_MAXBOARDS) {\r\ncx231xx_err(DRIVER_NAME ": Supports only %i devices.\n",\r\nCX231XX_MAXBOARDS);\r\nreturn -ENOMEM;\r\n}\r\n} while (test_and_set_bit(nr, &cx231xx_devused));\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ncx231xx_err(DRIVER_NAME ": out of memory!\n");\r\nclear_bit(nr, &cx231xx_devused);\r\nreturn -ENOMEM;\r\n}\r\nudev = usb_get_dev(interface_to_usbdev(interface));\r\nsnprintf(dev->name, 29, "cx231xx #%d", nr);\r\ndev->devno = nr;\r\ndev->model = id->driver_info;\r\ndev->video_mode.alt = -1;\r\ndev->interface_count++;\r\ndev->gpio_dir = 0;\r\ndev->gpio_val = 0;\r\ndev->xc_fw_load_done = 0;\r\ndev->has_alsa_audio = 1;\r\ndev->power_mode = -1;\r\natomic_set(&dev->devlist_count, 0);\r\ndev->vbi_or_sliced_cc_mode = 0;\r\nassoc_desc = udev->actconfig->intf_assoc[0];\r\ndev->max_iad_interface_count = assoc_desc->bInterfaceCount;\r\ndev->mode_tv = 0;\r\ndev->USE_ISO = transfer_mode;\r\nswitch (udev->speed) {\r\ncase USB_SPEED_LOW:\r\nspeed = "1.5";\r\nbreak;\r\ncase USB_SPEED_UNKNOWN:\r\ncase USB_SPEED_FULL:\r\nspeed = "12";\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nspeed = "480";\r\nbreak;\r\ndefault:\r\nspeed = "unknown";\r\n}\r\ncx231xx_info("New device %s %s @ %s Mbps "\r\n"(%04x:%04x) with %d interfaces\n",\r\nudev->manufacturer ? udev->manufacturer : "",\r\nudev->product ? udev->product : "",\r\nspeed,\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct),\r\ndev->max_iad_interface_count);\r\ndev->interface_count++;\r\nnr = dev->devno;\r\nassoc_desc = udev->actconfig->intf_assoc[0];\r\nif (assoc_desc->bFirstInterface != ifnum) {\r\ncx231xx_err(DRIVER_NAME ": Not found "\r\n"matching IAD interface\n");\r\nretval = -ENODEV;\r\ngoto err_if;\r\n}\r\ncx231xx_info("registering interface %d\n", ifnum);\r\nusb_set_intfdata(interface, dev);\r\nretval = v4l2_device_register(&interface->dev, &dev->v4l2_dev);\r\nif (retval) {\r\ncx231xx_errdev("v4l2_device_register failed\n");\r\nretval = -EIO;\r\ngoto err_v4l2;\r\n}\r\nretval = cx231xx_init_dev(dev, udev, nr);\r\nif (retval)\r\ngoto err_init;\r\nuif = udev->actconfig->interface[dev->current_pcb_config.\r\nhs_config_info[0].interface_info.video_index + 1];\r\ndev->video_mode.end_point_addr = uif->altsetting[0].\r\nendpoint[isoc_pipe].desc.bEndpointAddress;\r\ndev->video_mode.num_alt = uif->num_altsetting;\r\ncx231xx_info("EndPoint Addr 0x%x, Alternate settings: %i\n",\r\ndev->video_mode.end_point_addr,\r\ndev->video_mode.num_alt);\r\ndev->video_mode.alt_max_pkt_size =\r\nkmalloc(32 * dev->video_mode.num_alt, GFP_KERNEL);\r\nif (dev->video_mode.alt_max_pkt_size == NULL) {\r\ncx231xx_errdev("out of memory!\n");\r\nretval = -ENOMEM;\r\ngoto err_video_alt;\r\n}\r\nfor (i = 0; i < dev->video_mode.num_alt; i++) {\r\nu16 tmp = le16_to_cpu(uif->altsetting[i].endpoint[isoc_pipe].\r\ndesc.wMaxPacketSize);\r\ndev->video_mode.alt_max_pkt_size[i] =\r\n(tmp & 0x07ff) * (((tmp & 0x1800) >> 11) + 1);\r\ncx231xx_info("Alternate setting %i, max size= %i\n", i,\r\ndev->video_mode.alt_max_pkt_size[i]);\r\n}\r\nuif = udev->actconfig->interface[dev->current_pcb_config.\r\nhs_config_info[0].interface_info.\r\nvanc_index + 1];\r\ndev->vbi_mode.end_point_addr =\r\nuif->altsetting[0].endpoint[isoc_pipe].desc.\r\nbEndpointAddress;\r\ndev->vbi_mode.num_alt = uif->num_altsetting;\r\ncx231xx_info("EndPoint Addr 0x%x, Alternate settings: %i\n",\r\ndev->vbi_mode.end_point_addr,\r\ndev->vbi_mode.num_alt);\r\ndev->vbi_mode.alt_max_pkt_size =\r\nkmalloc(32 * dev->vbi_mode.num_alt, GFP_KERNEL);\r\nif (dev->vbi_mode.alt_max_pkt_size == NULL) {\r\ncx231xx_errdev("out of memory!\n");\r\nretval = -ENOMEM;\r\ngoto err_vbi_alt;\r\n}\r\nfor (i = 0; i < dev->vbi_mode.num_alt; i++) {\r\nu16 tmp =\r\nle16_to_cpu(uif->altsetting[i].endpoint[isoc_pipe].\r\ndesc.wMaxPacketSize);\r\ndev->vbi_mode.alt_max_pkt_size[i] =\r\n(tmp & 0x07ff) * (((tmp & 0x1800) >> 11) + 1);\r\ncx231xx_info("Alternate setting %i, max size= %i\n", i,\r\ndev->vbi_mode.alt_max_pkt_size[i]);\r\n}\r\nuif = udev->actconfig->interface[dev->current_pcb_config.\r\nhs_config_info[0].interface_info.\r\nhanc_index + 1];\r\ndev->sliced_cc_mode.end_point_addr =\r\nuif->altsetting[0].endpoint[isoc_pipe].desc.\r\nbEndpointAddress;\r\ndev->sliced_cc_mode.num_alt = uif->num_altsetting;\r\ncx231xx_info("EndPoint Addr 0x%x, Alternate settings: %i\n",\r\ndev->sliced_cc_mode.end_point_addr,\r\ndev->sliced_cc_mode.num_alt);\r\ndev->sliced_cc_mode.alt_max_pkt_size =\r\nkmalloc(32 * dev->sliced_cc_mode.num_alt, GFP_KERNEL);\r\nif (dev->sliced_cc_mode.alt_max_pkt_size == NULL) {\r\ncx231xx_errdev("out of memory!\n");\r\nretval = -ENOMEM;\r\ngoto err_sliced_cc_alt;\r\n}\r\nfor (i = 0; i < dev->sliced_cc_mode.num_alt; i++) {\r\nu16 tmp = le16_to_cpu(uif->altsetting[i].endpoint[isoc_pipe].\r\ndesc.wMaxPacketSize);\r\ndev->sliced_cc_mode.alt_max_pkt_size[i] =\r\n(tmp & 0x07ff) * (((tmp & 0x1800) >> 11) + 1);\r\ncx231xx_info("Alternate setting %i, max size= %i\n", i,\r\ndev->sliced_cc_mode.alt_max_pkt_size[i]);\r\n}\r\nif (dev->current_pcb_config.ts1_source != 0xff) {\r\nuif = udev->actconfig->interface[dev->current_pcb_config.\r\nhs_config_info[0].\r\ninterface_info.\r\nts1_index + 1];\r\ndev->ts1_mode.end_point_addr =\r\nuif->altsetting[0].endpoint[isoc_pipe].\r\ndesc.bEndpointAddress;\r\ndev->ts1_mode.num_alt = uif->num_altsetting;\r\ncx231xx_info("EndPoint Addr 0x%x, Alternate settings: %i\n",\r\ndev->ts1_mode.end_point_addr,\r\ndev->ts1_mode.num_alt);\r\ndev->ts1_mode.alt_max_pkt_size =\r\nkmalloc(32 * dev->ts1_mode.num_alt, GFP_KERNEL);\r\nif (dev->ts1_mode.alt_max_pkt_size == NULL) {\r\ncx231xx_errdev("out of memory!\n");\r\nretval = -ENOMEM;\r\ngoto err_ts1_alt;\r\n}\r\nfor (i = 0; i < dev->ts1_mode.num_alt; i++) {\r\nu16 tmp = le16_to_cpu(uif->altsetting[i].\r\nendpoint[isoc_pipe].desc.\r\nwMaxPacketSize);\r\ndev->ts1_mode.alt_max_pkt_size[i] =\r\n(tmp & 0x07ff) * (((tmp & 0x1800) >> 11) + 1);\r\ncx231xx_info("Alternate setting %i, max size= %i\n", i,\r\ndev->ts1_mode.alt_max_pkt_size[i]);\r\n}\r\n}\r\nif (dev->model == CX231XX_BOARD_CNXT_VIDEO_GRABBER) {\r\ncx231xx_enable_OSC(dev);\r\ncx231xx_reset_out(dev);\r\ncx231xx_set_alt_setting(dev, INDEX_VIDEO, 3);\r\n}\r\nif (dev->model == CX231XX_BOARD_CNXT_RDE_253S)\r\ncx231xx_sleep_s5h1432(dev);\r\nrequest_modules(dev);\r\nreturn 0;\r\nerr_ts1_alt:\r\nkfree(dev->sliced_cc_mode.alt_max_pkt_size);\r\nerr_sliced_cc_alt:\r\nkfree(dev->vbi_mode.alt_max_pkt_size);\r\nerr_vbi_alt:\r\nkfree(dev->video_mode.alt_max_pkt_size);\r\nerr_video_alt:\r\ncx231xx_close_extension(dev);\r\ncx231xx_ir_exit(dev);\r\ncx231xx_release_analog_resources(dev);\r\ncx231xx_417_unregister(dev);\r\ncx231xx_remove_from_devlist(dev);\r\ncx231xx_dev_uninit(dev);\r\nerr_init:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nerr_v4l2:\r\nusb_set_intfdata(interface, NULL);\r\nerr_if:\r\nusb_put_dev(udev);\r\nclear_bit(dev->devno, &cx231xx_devused);\r\nkfree(dev);\r\nreturn retval;\r\n}\r\nstatic void cx231xx_usb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct cx231xx *dev;\r\ndev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nif (!dev)\r\nreturn;\r\nif (!dev->udev)\r\nreturn;\r\ndev->state |= DEV_DISCONNECTED;\r\nflush_request_modules(dev);\r\nmutex_lock(&dev->lock);\r\nwake_up_interruptible_all(&dev->open);\r\nif (dev->users) {\r\ncx231xx_warn\r\n("device %s is open! Deregistration and memory "\r\n"deallocation are deferred on close.\n",\r\nvideo_device_node_name(dev->vdev));\r\ncx231xx_ir_exit(dev);\r\nif (dev->USE_ISO)\r\ncx231xx_uninit_isoc(dev);\r\nelse\r\ncx231xx_uninit_bulk(dev);\r\nwake_up_interruptible(&dev->wait_frame);\r\nwake_up_interruptible(&dev->wait_stream);\r\n} else {\r\n}\r\ncx231xx_close_extension(dev);\r\nmutex_unlock(&dev->lock);\r\nif (!dev->users)\r\ncx231xx_release_resources(dev);\r\n}
