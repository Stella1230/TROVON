static void __init\r\nnautilus_init_irq(void)\r\n{\r\nif (alpha_using_srm) {\r\nalpha_mv.device_interrupt = srm_device_interrupt;\r\n}\r\ninit_i8259a_irqs();\r\ncommon_init_isa_dma();\r\n}\r\nstatic int __init\r\nnautilus_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nu8 irq;\r\nif (slot == 1 && pin == 2 &&\r\ndev->bus->self && dev->bus->self->device == 0x700f)\r\nreturn 5;\r\npci_read_config_byte(dev, PCI_INTERRUPT_LINE, &irq);\r\nreturn irq;\r\n}\r\nvoid\r\nnautilus_kill_arch(int mode)\r\n{\r\nstruct pci_bus *bus = pci_isa_hose->bus;\r\nu32 pmuport;\r\nint off;\r\nswitch (mode) {\r\ncase LINUX_REBOOT_CMD_RESTART:\r\nif (! alpha_using_srm) {\r\nu8 t8;\r\npci_bus_read_config_byte(bus, 0x38, 0x43, &t8);\r\npci_bus_write_config_byte(bus, 0x38, 0x43, t8 | 0x80);\r\noutb(1, 0x92);\r\noutb(0, 0x92);\r\n}\r\nbreak;\r\ncase LINUX_REBOOT_CMD_POWER_OFF:\r\noff = 0x2000;\r\npci_bus_read_config_dword(bus, 0x88, 0x10, &pmuport);\r\nif (!pmuport) {\r\noff = 0x3400;\r\npci_bus_read_config_dword(bus, 0x88, 0xe0, &pmuport);\r\n}\r\npmuport &= 0xfffe;\r\noutw(0xffff, pmuport);\r\noutw(off, pmuport + 4);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nnaut_sys_machine_check(unsigned long vector, unsigned long la_ptr,\r\nstruct pt_regs *regs)\r\n{\r\nprintk("PC %lx RA %lx\n", regs->pc, regs->r26);\r\nirongate_pci_clr_err();\r\n}\r\nvoid\r\nnautilus_machine_check(unsigned long vector, unsigned long la_ptr)\r\n{\r\nchar *mchk_class;\r\nif (vector == SCB_Q_SYSMCHK\r\n&& ((IRONGATE0->dramms & 0x300) == 0x300)) {\r\nunsigned long nmi_ctl;\r\nnmi_ctl = inb(0x61);\r\nnmi_ctl |= 0x0c;\r\noutb(nmi_ctl, 0x61);\r\nnmi_ctl &= ~0x0c;\r\noutb(nmi_ctl, 0x61);\r\nIRONGATE0->stat_cmd = IRONGATE0->stat_cmd & ~0x100;\r\nmb();\r\nIRONGATE0->stat_cmd;\r\nIRONGATE0->dramms = IRONGATE0->dramms;\r\nmb();\r\nIRONGATE0->dramms;\r\ndraina();\r\nwrmces(0x7);\r\nmb();\r\nreturn;\r\n}\r\nif (vector == SCB_Q_SYSERR)\r\nmchk_class = "Correctable";\r\nelse if (vector == SCB_Q_SYSMCHK)\r\nmchk_class = "Fatal";\r\nelse {\r\nev6_machine_check(vector, la_ptr);\r\nreturn;\r\n}\r\nprintk(KERN_CRIT "NAUTILUS Machine check 0x%lx "\r\n"[%s System Machine Check (NMI)]\n",\r\nvector, mchk_class);\r\nnaut_sys_machine_check(vector, la_ptr, get_irq_regs());\r\ndraina();\r\nwrmces(0x7);\r\nmb();\r\n}\r\nvoid __init\r\nnautilus_init_pci(void)\r\n{\r\nstruct pci_controller *hose = hose_head;\r\nstruct pci_bus *bus;\r\nstruct pci_dev *irongate;\r\nunsigned long bus_align, bus_size, pci_mem;\r\nunsigned long memtop = max_low_pfn << PAGE_SHIFT;\r\nbus = pci_scan_bus(0, alpha_mv.pci_ops, hose);\r\nhose->bus = bus;\r\npcibios_claim_one_bus(bus);\r\nirongate = pci_get_bus_and_slot(0, 0);\r\nbus->self = irongate;\r\nbus->resource[0] = &irongate_io;\r\nbus->resource[1] = &irongate_mem;\r\npci_bus_size_bridges(bus);\r\nbus->resource[0]->start = 0;\r\nbus->resource[0]->end = 0xffff;\r\nbus_align = bus->resource[1]->start;\r\nbus_size = bus->resource[1]->end + 1 - bus_align;\r\nif (bus_align < 0x1000000UL)\r\nbus_align = 0x1000000UL;\r\npci_mem = (0x100000000UL - bus_size) & -bus_align;\r\nbus->resource[1]->start = pci_mem;\r\nbus->resource[1]->end = 0xffffffffUL;\r\nif (request_resource(&iomem_resource, bus->resource[1]) < 0)\r\nprintk(KERN_ERR "Failed to request MEM on hose 0\n");\r\nif (pci_mem < memtop)\r\nmemtop = pci_mem;\r\nif (memtop > alpha_mv.min_mem_address) {\r\nfree_reserved_area(__va(alpha_mv.min_mem_address),\r\n__va(memtop), -1, NULL);\r\nprintk("nautilus_init_pci: %ldk freed\n",\r\n(memtop - alpha_mv.min_mem_address) >> 10);\r\n}\r\nif ((IRONGATE0->dev_vendor >> 16) > 0x7006)\r\nIRONGATE0->pci_mem = pci_mem;\r\npci_bus_assign_resources(bus);\r\nbus->self = NULL;\r\npci_fixup_irqs(alpha_mv.pci_swizzle, alpha_mv.pci_map_irq);\r\n}
