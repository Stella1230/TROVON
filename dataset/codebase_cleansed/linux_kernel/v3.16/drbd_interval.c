static inline\r\nsector_t interval_end(struct rb_node *node)\r\n{\r\nstruct drbd_interval *this = rb_entry(node, struct drbd_interval, rb);\r\nreturn this->end;\r\n}\r\nstatic inline sector_t\r\ncompute_subtree_last(struct drbd_interval *node)\r\n{\r\nsector_t max = node->sector + (node->size >> 9);\r\nif (node->rb.rb_left) {\r\nsector_t left = interval_end(node->rb.rb_left);\r\nif (left > max)\r\nmax = left;\r\n}\r\nif (node->rb.rb_right) {\r\nsector_t right = interval_end(node->rb.rb_right);\r\nif (right > max)\r\nmax = right;\r\n}\r\nreturn max;\r\n}\r\nstatic void augment_propagate(struct rb_node *rb, struct rb_node *stop)\r\n{\r\nwhile (rb != stop) {\r\nstruct drbd_interval *node = rb_entry(rb, struct drbd_interval, rb);\r\nsector_t subtree_last = compute_subtree_last(node);\r\nif (node->end == subtree_last)\r\nbreak;\r\nnode->end = subtree_last;\r\nrb = rb_parent(&node->rb);\r\n}\r\n}\r\nstatic void augment_copy(struct rb_node *rb_old, struct rb_node *rb_new)\r\n{\r\nstruct drbd_interval *old = rb_entry(rb_old, struct drbd_interval, rb);\r\nstruct drbd_interval *new = rb_entry(rb_new, struct drbd_interval, rb);\r\nnew->end = old->end;\r\n}\r\nstatic void augment_rotate(struct rb_node *rb_old, struct rb_node *rb_new)\r\n{\r\nstruct drbd_interval *old = rb_entry(rb_old, struct drbd_interval, rb);\r\nstruct drbd_interval *new = rb_entry(rb_new, struct drbd_interval, rb);\r\nnew->end = old->end;\r\nold->end = compute_subtree_last(old);\r\n}\r\nbool\r\ndrbd_insert_interval(struct rb_root *root, struct drbd_interval *this)\r\n{\r\nstruct rb_node **new = &root->rb_node, *parent = NULL;\r\nBUG_ON(!IS_ALIGNED(this->size, 512));\r\nwhile (*new) {\r\nstruct drbd_interval *here =\r\nrb_entry(*new, struct drbd_interval, rb);\r\nparent = *new;\r\nif (this->sector < here->sector)\r\nnew = &(*new)->rb_left;\r\nelse if (this->sector > here->sector)\r\nnew = &(*new)->rb_right;\r\nelse if (this < here)\r\nnew = &(*new)->rb_left;\r\nelse if (this > here)\r\nnew = &(*new)->rb_right;\r\nelse\r\nreturn false;\r\n}\r\nrb_link_node(&this->rb, parent, new);\r\nrb_insert_augmented(&this->rb, root, &augment_callbacks);\r\nreturn true;\r\n}\r\nbool\r\ndrbd_contains_interval(struct rb_root *root, sector_t sector,\r\nstruct drbd_interval *interval)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nwhile (node) {\r\nstruct drbd_interval *here =\r\nrb_entry(node, struct drbd_interval, rb);\r\nif (sector < here->sector)\r\nnode = node->rb_left;\r\nelse if (sector > here->sector)\r\nnode = node->rb_right;\r\nelse if (interval < here)\r\nnode = node->rb_left;\r\nelse if (interval > here)\r\nnode = node->rb_right;\r\nelse\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid\r\ndrbd_remove_interval(struct rb_root *root, struct drbd_interval *this)\r\n{\r\nrb_erase_augmented(&this->rb, root, &augment_callbacks);\r\n}\r\nstruct drbd_interval *\r\ndrbd_find_overlap(struct rb_root *root, sector_t sector, unsigned int size)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nstruct drbd_interval *overlap = NULL;\r\nsector_t end = sector + (size >> 9);\r\nBUG_ON(!IS_ALIGNED(size, 512));\r\nwhile (node) {\r\nstruct drbd_interval *here =\r\nrb_entry(node, struct drbd_interval, rb);\r\nif (node->rb_left &&\r\nsector < interval_end(node->rb_left)) {\r\nnode = node->rb_left;\r\n} else if (here->sector < end &&\r\nsector < here->sector + (here->size >> 9)) {\r\noverlap = here;\r\nbreak;\r\n} else if (sector >= here->sector) {\r\nnode = node->rb_right;\r\n} else\r\nbreak;\r\n}\r\nreturn overlap;\r\n}\r\nstruct drbd_interval *\r\ndrbd_next_overlap(struct drbd_interval *i, sector_t sector, unsigned int size)\r\n{\r\nsector_t end = sector + (size >> 9);\r\nstruct rb_node *node;\r\nfor (;;) {\r\nnode = rb_next(&i->rb);\r\nif (!node)\r\nreturn NULL;\r\ni = rb_entry(node, struct drbd_interval, rb);\r\nif (i->sector >= end)\r\nreturn NULL;\r\nif (sector < i->sector + (i->size >> 9))\r\nreturn i;\r\n}\r\n}
