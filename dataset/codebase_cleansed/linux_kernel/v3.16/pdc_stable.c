static int\r\npdcspath_fetch(struct pdcspath_entry *entry)\r\n{\r\nstruct device_path *devpath;\r\nif (!entry)\r\nreturn -EINVAL;\r\ndevpath = &entry->devpath;\r\nDPRINTK("%s: fetch: 0x%p, 0x%p, addr: 0x%lx\n", __func__,\r\nentry, devpath, entry->addr);\r\nif (pdc_stable_read(entry->addr, devpath, sizeof(*devpath)) != PDC_OK)\r\nreturn -EIO;\r\nentry->dev = hwpath_to_device((struct hardware_path *)devpath);\r\nentry->ready = 1;\r\nDPRINTK("%s: device: 0x%p\n", __func__, entry->dev);\r\nreturn 0;\r\n}\r\nstatic void\r\npdcspath_store(struct pdcspath_entry *entry)\r\n{\r\nstruct device_path *devpath;\r\nBUG_ON(!entry);\r\ndevpath = &entry->devpath;\r\nif (!entry->ready) {\r\nBUG_ON(!entry->dev);\r\ndevice_to_hwpath(entry->dev, (struct hardware_path *)devpath);\r\n}\r\nDPRINTK("%s: store: 0x%p, 0x%p, addr: 0x%lx\n", __func__,\r\nentry, devpath, entry->addr);\r\nif (pdc_stable_write(entry->addr, devpath, sizeof(*devpath)) != PDC_OK)\r\nWARN(1, KERN_ERR "%s: an error occurred when writing to PDC.\n"\r\n"It is likely that the Stable Storage data has been corrupted.\n"\r\n"Please check it carefully upon next reboot.\n", __func__);\r\nentry->ready = 2;\r\nDPRINTK("%s: device: 0x%p\n", __func__, entry->dev);\r\n}\r\nstatic ssize_t\r\npdcspath_hwpath_read(struct pdcspath_entry *entry, char *buf)\r\n{\r\nchar *out = buf;\r\nstruct device_path *devpath;\r\nshort i;\r\nif (!entry || !buf)\r\nreturn -EINVAL;\r\nread_lock(&entry->rw_lock);\r\ndevpath = &entry->devpath;\r\ni = entry->ready;\r\nread_unlock(&entry->rw_lock);\r\nif (!i)\r\nreturn -ENODATA;\r\nfor (i = 0; i < 6; i++) {\r\nif (devpath->bc[i] >= 128)\r\ncontinue;\r\nout += sprintf(out, "%u/", (unsigned char)devpath->bc[i]);\r\n}\r\nout += sprintf(out, "%u\n", (unsigned char)devpath->mod);\r\nreturn out - buf;\r\n}\r\nstatic ssize_t\r\npdcspath_hwpath_write(struct pdcspath_entry *entry, const char *buf, size_t count)\r\n{\r\nstruct hardware_path hwpath;\r\nunsigned short i;\r\nchar in[count+1], *temp;\r\nstruct device *dev;\r\nint ret;\r\nif (!entry || !buf || !count)\r\nreturn -EINVAL;\r\nmemset(in, 0, count+1);\r\nstrncpy(in, buf, count);\r\nmemset(&hwpath, 0xff, sizeof(hwpath));\r\nif (!(temp = strrchr(in, '/')))\r\nreturn -EINVAL;\r\nhwpath.mod = simple_strtoul(temp+1, NULL, 10);\r\nin[temp-in] = '\0';\r\nDPRINTK("%s: mod: %d\n", __func__, hwpath.mod);\r\nfor (i=5; ((temp = strrchr(in, '/'))) && (temp-in > 0) && (likely(i)); i--) {\r\nhwpath.bc[i] = simple_strtoul(temp+1, NULL, 10);\r\nin[temp-in] = '\0';\r\nDPRINTK("%s: bc[%d]: %d\n", __func__, i, hwpath.bc[i]);\r\n}\r\nhwpath.bc[i] = simple_strtoul(in, NULL, 10);\r\nDPRINTK("%s: bc[%d]: %d\n", __func__, i, hwpath.bc[i]);\r\nif (!(dev = hwpath_to_device((struct hardware_path *)&hwpath))) {\r\nprintk(KERN_WARNING "%s: attempt to set invalid \"%s\" "\r\n"hardware path: %s\n", __func__, entry->name, buf);\r\nreturn -EINVAL;\r\n}\r\nwrite_lock(&entry->rw_lock);\r\nentry->ready = 0;\r\nentry->dev = dev;\r\npdcspath_store(entry);\r\nsysfs_remove_link(&entry->kobj, "device");\r\nret = sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");\r\nWARN_ON(ret);\r\nwrite_unlock(&entry->rw_lock);\r\nprintk(KERN_INFO PDCS_PREFIX ": changed \"%s\" path to \"%s\"\n",\r\nentry->name, buf);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\npdcspath_layer_read(struct pdcspath_entry *entry, char *buf)\r\n{\r\nchar *out = buf;\r\nstruct device_path *devpath;\r\nshort i;\r\nif (!entry || !buf)\r\nreturn -EINVAL;\r\nread_lock(&entry->rw_lock);\r\ndevpath = &entry->devpath;\r\ni = entry->ready;\r\nread_unlock(&entry->rw_lock);\r\nif (!i)\r\nreturn -ENODATA;\r\nfor (i = 0; i < 6 && devpath->layers[i]; i++)\r\nout += sprintf(out, "%u ", devpath->layers[i]);\r\nout += sprintf(out, "\n");\r\nreturn out - buf;\r\n}\r\nstatic ssize_t\r\npdcspath_layer_write(struct pdcspath_entry *entry, const char *buf, size_t count)\r\n{\r\nunsigned int layers[6];\r\nunsigned short i;\r\nchar in[count+1], *temp;\r\nif (!entry || !buf || !count)\r\nreturn -EINVAL;\r\nmemset(in, 0, count+1);\r\nstrncpy(in, buf, count);\r\nmemset(&layers, 0, sizeof(layers));\r\nif (unlikely(!isdigit(*in)))\r\nreturn -EINVAL;\r\nlayers[0] = simple_strtoul(in, NULL, 10);\r\nDPRINTK("%s: layer[0]: %d\n", __func__, layers[0]);\r\ntemp = in;\r\nfor (i=1; ((temp = strchr(temp, '.'))) && (likely(i<6)); i++) {\r\nif (unlikely(!isdigit(*(++temp))))\r\nreturn -EINVAL;\r\nlayers[i] = simple_strtoul(temp, NULL, 10);\r\nDPRINTK("%s: layer[%d]: %d\n", __func__, i, layers[i]);\r\n}\r\nwrite_lock(&entry->rw_lock);\r\nmemcpy(&entry->devpath.layers, &layers, sizeof(layers));\r\npdcspath_store(entry);\r\nwrite_unlock(&entry->rw_lock);\r\nprintk(KERN_INFO PDCS_PREFIX ": changed \"%s\" layers to \"%s\"\n",\r\nentry->name, buf);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\npdcspath_attr_show(struct kobject *kobj, struct attribute *attr, char *buf)\r\n{\r\nstruct pdcspath_entry *entry = to_pdcspath_entry(kobj);\r\nstruct pdcspath_attribute *pdcs_attr = to_pdcspath_attribute(attr);\r\nssize_t ret = 0;\r\nif (pdcs_attr->show)\r\nret = pdcs_attr->show(entry, buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\npdcspath_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct pdcspath_entry *entry = to_pdcspath_entry(kobj);\r\nstruct pdcspath_attribute *pdcs_attr = to_pdcspath_attribute(attr);\r\nssize_t ret = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (pdcs_attr->store)\r\nret = pdcs_attr->store(entry, buf, count);\r\nreturn ret;\r\n}\r\nstatic ssize_t pdcs_size_read(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nchar *out = buf;\r\nif (!buf)\r\nreturn -EINVAL;\r\nout += sprintf(out, "%ld\n", pdcs_size);\r\nreturn out - buf;\r\n}\r\nstatic ssize_t pdcs_auto_read(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf, int knob)\r\n{\r\nchar *out = buf;\r\nstruct pdcspath_entry *pathentry;\r\nif (!buf)\r\nreturn -EINVAL;\r\npathentry = &pdcspath_entry_primary;\r\nread_lock(&pathentry->rw_lock);\r\nout += sprintf(out, "%s\n", (pathentry->devpath.flags & knob) ?\r\n"On" : "Off");\r\nread_unlock(&pathentry->rw_lock);\r\nreturn out - buf;\r\n}\r\nstatic ssize_t pdcs_autoboot_read(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn pdcs_auto_read(kobj, attr, buf, PF_AUTOBOOT);\r\n}\r\nstatic ssize_t pdcs_autosearch_read(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn pdcs_auto_read(kobj, attr, buf, PF_AUTOSEARCH);\r\n}\r\nstatic ssize_t pdcs_timer_read(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nchar *out = buf;\r\nstruct pdcspath_entry *pathentry;\r\nif (!buf)\r\nreturn -EINVAL;\r\npathentry = &pdcspath_entry_primary;\r\nread_lock(&pathentry->rw_lock);\r\nout += sprintf(out, "%u\n", (pathentry->devpath.flags & PF_TIMER) ?\r\n(1 << (pathentry->devpath.flags & PF_TIMER)) : 0);\r\nread_unlock(&pathentry->rw_lock);\r\nreturn out - buf;\r\n}\r\nstatic ssize_t pdcs_osid_read(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nchar *out = buf;\r\nif (!buf)\r\nreturn -EINVAL;\r\nout += sprintf(out, "%s dependent data (0x%.4x)\n",\r\nos_id_to_string(pdcs_osid), pdcs_osid);\r\nreturn out - buf;\r\n}\r\nstatic ssize_t pdcs_osdep1_read(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nchar *out = buf;\r\nu32 result[4];\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (pdc_stable_read(PDCS_ADDR_OSD1, &result, sizeof(result)) != PDC_OK)\r\nreturn -EIO;\r\nout += sprintf(out, "0x%.8x\n", result[0]);\r\nout += sprintf(out, "0x%.8x\n", result[1]);\r\nout += sprintf(out, "0x%.8x\n", result[2]);\r\nout += sprintf(out, "0x%.8x\n", result[3]);\r\nreturn out - buf;\r\n}\r\nstatic ssize_t pdcs_diagnostic_read(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nchar *out = buf;\r\nu32 result;\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (pdc_stable_read(PDCS_ADDR_DIAG, &result, sizeof(result)) != PDC_OK)\r\nreturn -EIO;\r\nout += sprintf(out, "0x%.4x\n", (result >> 16));\r\nreturn out - buf;\r\n}\r\nstatic ssize_t pdcs_fastsize_read(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nchar *out = buf;\r\nu32 result;\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (pdc_stable_read(PDCS_ADDR_FSIZ, &result, sizeof(result)) != PDC_OK)\r\nreturn -EIO;\r\nif ((result & 0x0F) < 0x0E)\r\nout += sprintf(out, "%d kB", (1<<(result & 0x0F))*256);\r\nelse\r\nout += sprintf(out, "All");\r\nout += sprintf(out, "\n");\r\nreturn out - buf;\r\n}\r\nstatic ssize_t pdcs_osdep2_read(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nchar *out = buf;\r\nunsigned long size;\r\nunsigned short i;\r\nu32 result;\r\nif (unlikely(pdcs_size <= 224))\r\nreturn -ENODATA;\r\nsize = pdcs_size - 224;\r\nif (!buf)\r\nreturn -EINVAL;\r\nfor (i=0; i<size; i+=4) {\r\nif (unlikely(pdc_stable_read(PDCS_ADDR_OSD2 + i, &result,\r\nsizeof(result)) != PDC_OK))\r\nreturn -EIO;\r\nout += sprintf(out, "0x%.8x\n", result);\r\n}\r\nreturn out - buf;\r\n}\r\nstatic ssize_t pdcs_auto_write(struct kobject *kobj,\r\nstruct kobj_attribute *attr, const char *buf,\r\nsize_t count, int knob)\r\n{\r\nstruct pdcspath_entry *pathentry;\r\nunsigned char flags;\r\nchar in[count+1], *temp;\r\nchar c;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (!buf || !count)\r\nreturn -EINVAL;\r\nmemset(in, 0, count+1);\r\nstrncpy(in, buf, count);\r\npathentry = &pdcspath_entry_primary;\r\nread_lock(&pathentry->rw_lock);\r\nflags = pathentry->devpath.flags;\r\nread_unlock(&pathentry->rw_lock);\r\nDPRINTK("%s: flags before: 0x%X\n", __func__, flags);\r\ntemp = skip_spaces(in);\r\nc = *temp++ - '0';\r\nif ((c != 0) && (c != 1))\r\ngoto parse_error;\r\nif (c == 0)\r\nflags &= ~knob;\r\nelse\r\nflags |= knob;\r\nDPRINTK("%s: flags after: 0x%X\n", __func__, flags);\r\nwrite_lock(&pathentry->rw_lock);\r\npathentry->devpath.flags = flags;\r\npdcspath_store(pathentry);\r\nwrite_unlock(&pathentry->rw_lock);\r\nprintk(KERN_INFO PDCS_PREFIX ": changed \"%s\" to \"%s\"\n",\r\n(knob & PF_AUTOBOOT) ? "autoboot" : "autosearch",\r\n(flags & knob) ? "On" : "Off");\r\nreturn count;\r\nparse_error:\r\nprintk(KERN_WARNING "%s: Parse error: expect \"n\" (n == 0 or 1)\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t pdcs_autoboot_write(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn pdcs_auto_write(kobj, attr, buf, count, PF_AUTOBOOT);\r\n}\r\nstatic ssize_t pdcs_autosearch_write(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn pdcs_auto_write(kobj, attr, buf, count, PF_AUTOSEARCH);\r\n}\r\nstatic ssize_t pdcs_osdep1_write(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu8 in[16];\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (!buf || !count)\r\nreturn -EINVAL;\r\nif (unlikely(pdcs_osid != OS_ID_LINUX))\r\nreturn -EPERM;\r\nif (count > 16)\r\nreturn -EMSGSIZE;\r\nmemset(in, 0, 16);\r\nmemcpy(in, buf, count);\r\nif (pdc_stable_write(PDCS_ADDR_OSD1, &in, sizeof(in)) != PDC_OK)\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t pdcs_osdep2_write(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long size;\r\nunsigned short i;\r\nu8 in[4];\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (!buf || !count)\r\nreturn -EINVAL;\r\nif (unlikely(pdcs_size <= 224))\r\nreturn -ENOSYS;\r\nif (unlikely(pdcs_osid != OS_ID_LINUX))\r\nreturn -EPERM;\r\nsize = pdcs_size - 224;\r\nif (count > size)\r\nreturn -EMSGSIZE;\r\nfor (i=0; i<count; i+=4) {\r\nmemset(in, 0, 4);\r\nmemcpy(in, buf+i, (count-i < 4) ? count-i : 4);\r\nif (unlikely(pdc_stable_write(PDCS_ADDR_OSD2 + i, &in,\r\nsizeof(in)) != PDC_OK))\r\nreturn -EIO;\r\n}\r\nreturn count;\r\n}\r\nstatic inline int __init\r\npdcs_register_pathentries(void)\r\n{\r\nunsigned short i;\r\nstruct pdcspath_entry *entry;\r\nint err;\r\nfor (i = 0; (entry = pdcspath_entries[i]); i++)\r\nrwlock_init(&entry->rw_lock);\r\nfor (i = 0; (entry = pdcspath_entries[i]); i++) {\r\nwrite_lock(&entry->rw_lock);\r\nerr = pdcspath_fetch(entry);\r\nwrite_unlock(&entry->rw_lock);\r\nif (err < 0)\r\ncontinue;\r\nentry->kobj.kset = paths_kset;\r\nerr = kobject_init_and_add(&entry->kobj, &ktype_pdcspath, NULL,\r\n"%s", entry->name);\r\nif (err)\r\nreturn err;\r\nwrite_lock(&entry->rw_lock);\r\nentry->ready = 2;\r\nif (entry->dev) {\r\nerr = sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");\r\nWARN_ON(err);\r\n}\r\nwrite_unlock(&entry->rw_lock);\r\nkobject_uevent(&entry->kobj, KOBJ_ADD);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\npdcs_unregister_pathentries(void)\r\n{\r\nunsigned short i;\r\nstruct pdcspath_entry *entry;\r\nfor (i = 0; (entry = pdcspath_entries[i]); i++) {\r\nread_lock(&entry->rw_lock);\r\nif (entry->ready >= 2)\r\nkobject_put(&entry->kobj);\r\nread_unlock(&entry->rw_lock);\r\n}\r\n}\r\nstatic int __init\r\npdc_stable_init(void)\r\n{\r\nint rc = 0, error = 0;\r\nu32 result;\r\nif (pdc_stable_get_size(&pdcs_size) != PDC_OK)\r\nreturn -ENODEV;\r\nif (pdcs_size < 96)\r\nreturn -ENODATA;\r\nprintk(KERN_INFO PDCS_PREFIX " facility v%s\n", PDCS_VERSION);\r\nif (pdc_stable_read(PDCS_ADDR_OSID, &result, sizeof(result)) != PDC_OK)\r\nreturn -EIO;\r\npdcs_osid = (u16)(result >> 16);\r\nstable_kobj = kobject_create_and_add("stable", firmware_kobj);\r\nif (!stable_kobj) {\r\nrc = -ENOMEM;\r\ngoto fail_firmreg;\r\n}\r\nerror = sysfs_create_group(stable_kobj, &pdcs_attr_group);\r\npaths_kset = kset_create_and_add("paths", NULL, stable_kobj);\r\nif (!paths_kset) {\r\nrc = -ENOMEM;\r\ngoto fail_ksetreg;\r\n}\r\nif ((rc = pdcs_register_pathentries()))\r\ngoto fail_pdcsreg;\r\nreturn rc;\r\nfail_pdcsreg:\r\npdcs_unregister_pathentries();\r\nkset_unregister(paths_kset);\r\nfail_ksetreg:\r\nkobject_put(stable_kobj);\r\nfail_firmreg:\r\nprintk(KERN_INFO PDCS_PREFIX " bailing out\n");\r\nreturn rc;\r\n}\r\nstatic void __exit\r\npdc_stable_exit(void)\r\n{\r\npdcs_unregister_pathentries();\r\nkset_unregister(paths_kset);\r\nkobject_put(stable_kobj);\r\n}
