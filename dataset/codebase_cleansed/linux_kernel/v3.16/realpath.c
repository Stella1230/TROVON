char *tomoyo_encode2(const char *str, int str_len)\r\n{\r\nint i;\r\nint len = 0;\r\nconst char *p = str;\r\nchar *cp;\r\nchar *cp0;\r\nif (!p)\r\nreturn NULL;\r\nfor (i = 0; i < str_len; i++) {\r\nconst unsigned char c = p[i];\r\nif (c == '\\')\r\nlen += 2;\r\nelse if (c > ' ' && c < 127)\r\nlen++;\r\nelse\r\nlen += 4;\r\n}\r\nlen++;\r\ncp = kzalloc(len + 10, GFP_NOFS);\r\nif (!cp)\r\nreturn NULL;\r\ncp0 = cp;\r\np = str;\r\nfor (i = 0; i < str_len; i++) {\r\nconst unsigned char c = p[i];\r\nif (c == '\\') {\r\n*cp++ = '\\';\r\n*cp++ = '\\';\r\n} else if (c > ' ' && c < 127) {\r\n*cp++ = c;\r\n} else {\r\n*cp++ = '\\';\r\n*cp++ = (c >> 6) + '0';\r\n*cp++ = ((c >> 3) & 7) + '0';\r\n*cp++ = (c & 7) + '0';\r\n}\r\n}\r\nreturn cp0;\r\n}\r\nchar *tomoyo_encode(const char *str)\r\n{\r\nreturn str ? tomoyo_encode2(str, strlen(str)) : NULL;\r\n}\r\nstatic char *tomoyo_get_absolute_path(struct path *path, char * const buffer,\r\nconst int buflen)\r\n{\r\nchar *pos = ERR_PTR(-ENOMEM);\r\nif (buflen >= 256) {\r\npos = d_absolute_path(path, buffer, buflen - 1);\r\nif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\r\nstruct inode *inode = path->dentry->d_inode;\r\nif (inode && S_ISDIR(inode->i_mode)) {\r\nbuffer[buflen - 2] = '/';\r\nbuffer[buflen - 1] = '\0';\r\n}\r\n}\r\n}\r\nreturn pos;\r\n}\r\nstatic char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,\r\nconst int buflen)\r\n{\r\nchar *pos = ERR_PTR(-ENOMEM);\r\nif (buflen >= 256) {\r\npos = dentry_path_raw(dentry, buffer, buflen - 1);\r\nif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\r\nstruct inode *inode = dentry->d_inode;\r\nif (inode && S_ISDIR(inode->i_mode)) {\r\nbuffer[buflen - 2] = '/';\r\nbuffer[buflen - 1] = '\0';\r\n}\r\n}\r\n}\r\nreturn pos;\r\n}\r\nstatic char *tomoyo_get_local_path(struct dentry *dentry, char * const buffer,\r\nconst int buflen)\r\n{\r\nstruct super_block *sb = dentry->d_sb;\r\nchar *pos = tomoyo_get_dentry_path(dentry, buffer, buflen);\r\nif (IS_ERR(pos))\r\nreturn pos;\r\nif (sb->s_magic == PROC_SUPER_MAGIC && *pos == '/') {\r\nchar *ep;\r\nconst pid_t pid = (pid_t) simple_strtoul(pos + 1, &ep, 10);\r\nif (*ep == '/' && pid && pid ==\r\ntask_tgid_nr_ns(current, sb->s_fs_info)) {\r\npos = ep - 5;\r\nif (pos < buffer)\r\ngoto out;\r\nmemmove(pos, "/self", 5);\r\n}\r\ngoto prepend_filesystem_name;\r\n}\r\nif (!MAJOR(sb->s_dev))\r\ngoto prepend_filesystem_name;\r\n{\r\nstruct inode *inode = sb->s_root->d_inode;\r\nif (!inode->i_op->rename)\r\ngoto prepend_filesystem_name;\r\n}\r\n{\r\nchar name[64];\r\nint name_len;\r\nconst dev_t dev = sb->s_dev;\r\nname[sizeof(name) - 1] = '\0';\r\nsnprintf(name, sizeof(name) - 1, "dev(%u,%u):", MAJOR(dev),\r\nMINOR(dev));\r\nname_len = strlen(name);\r\npos -= name_len;\r\nif (pos < buffer)\r\ngoto out;\r\nmemmove(pos, name, name_len);\r\nreturn pos;\r\n}\r\nprepend_filesystem_name:\r\n{\r\nconst char *name = sb->s_type->name;\r\nconst int name_len = strlen(name);\r\npos -= name_len + 1;\r\nif (pos < buffer)\r\ngoto out;\r\nmemmove(pos, name, name_len);\r\npos[name_len] = ':';\r\n}\r\nreturn pos;\r\nout:\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic char *tomoyo_get_socket_name(struct path *path, char * const buffer,\r\nconst int buflen)\r\n{\r\nstruct inode *inode = path->dentry->d_inode;\r\nstruct socket *sock = inode ? SOCKET_I(inode) : NULL;\r\nstruct sock *sk = sock ? sock->sk : NULL;\r\nif (sk) {\r\nsnprintf(buffer, buflen, "socket:[family=%u:type=%u:"\r\n"protocol=%u]", sk->sk_family, sk->sk_type,\r\nsk->sk_protocol);\r\n} else {\r\nsnprintf(buffer, buflen, "socket:[unknown]");\r\n}\r\nreturn buffer;\r\n}\r\nchar *tomoyo_realpath_from_path(struct path *path)\r\n{\r\nchar *buf = NULL;\r\nchar *name = NULL;\r\nunsigned int buf_len = PAGE_SIZE / 2;\r\nstruct dentry *dentry = path->dentry;\r\nstruct super_block *sb;\r\nif (!dentry)\r\nreturn NULL;\r\nsb = dentry->d_sb;\r\nwhile (1) {\r\nchar *pos;\r\nstruct inode *inode;\r\nbuf_len <<= 1;\r\nkfree(buf);\r\nbuf = kmalloc(buf_len, GFP_NOFS);\r\nif (!buf)\r\nbreak;\r\nbuf[buf_len - 1] = '\0';\r\nif (sb->s_magic == SOCKFS_MAGIC) {\r\npos = tomoyo_get_socket_name(path, buf, buf_len - 1);\r\ngoto encode;\r\n}\r\nif (dentry->d_op && dentry->d_op->d_dname) {\r\npos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\r\ngoto encode;\r\n}\r\ninode = sb->s_root->d_inode;\r\nif (!path->mnt || !inode->i_op->rename)\r\npos = tomoyo_get_local_path(path->dentry, buf,\r\nbuf_len - 1);\r\nelse {\r\npos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\r\nif (pos == ERR_PTR(-EINVAL))\r\npos = tomoyo_get_local_path(path->dentry, buf,\r\nbuf_len - 1);\r\n}\r\nencode:\r\nif (IS_ERR(pos))\r\ncontinue;\r\nname = tomoyo_encode(pos);\r\nbreak;\r\n}\r\nkfree(buf);\r\nif (!name)\r\ntomoyo_warn_oom(__func__);\r\nreturn name;\r\n}\r\nchar *tomoyo_realpath_nofollow(const char *pathname)\r\n{\r\nstruct path path;\r\nif (pathname && kern_path(pathname, 0, &path) == 0) {\r\nchar *buf = tomoyo_realpath_from_path(&path);\r\npath_put(&path);\r\nreturn buf;\r\n}\r\nreturn NULL;\r\n}
