static int\r\nbfad_debugfs_open_drvtrc(struct inode *inode, struct file *file)\r\n{\r\nstruct bfad_port_s *port = inode->i_private;\r\nstruct bfad_s *bfad = port->bfad;\r\nstruct bfad_debug_info *debug;\r\ndebug = kzalloc(sizeof(struct bfad_debug_info), GFP_KERNEL);\r\nif (!debug)\r\nreturn -ENOMEM;\r\ndebug->debug_buffer = (void *) bfad->trcmod;\r\ndebug->buffer_len = sizeof(struct bfa_trc_mod_s);\r\nfile->private_data = debug;\r\nreturn 0;\r\n}\r\nstatic int\r\nbfad_debugfs_open_fwtrc(struct inode *inode, struct file *file)\r\n{\r\nstruct bfad_port_s *port = inode->i_private;\r\nstruct bfad_s *bfad = port->bfad;\r\nstruct bfad_debug_info *fw_debug;\r\nunsigned long flags;\r\nint rc;\r\nfw_debug = kzalloc(sizeof(struct bfad_debug_info), GFP_KERNEL);\r\nif (!fw_debug)\r\nreturn -ENOMEM;\r\nfw_debug->buffer_len = sizeof(struct bfa_trc_mod_s);\r\nfw_debug->debug_buffer = vmalloc(fw_debug->buffer_len);\r\nif (!fw_debug->debug_buffer) {\r\nkfree(fw_debug);\r\nprintk(KERN_INFO "bfad[%d]: Failed to allocate fwtrc buffer\n",\r\nbfad->inst_no);\r\nreturn -ENOMEM;\r\n}\r\nmemset(fw_debug->debug_buffer, 0, fw_debug->buffer_len);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nrc = bfa_ioc_debug_fwtrc(&bfad->bfa.ioc,\r\nfw_debug->debug_buffer,\r\n&fw_debug->buffer_len);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (rc != BFA_STATUS_OK) {\r\nvfree(fw_debug->debug_buffer);\r\nfw_debug->debug_buffer = NULL;\r\nkfree(fw_debug);\r\nprintk(KERN_INFO "bfad[%d]: Failed to collect fwtrc\n",\r\nbfad->inst_no);\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = fw_debug;\r\nreturn 0;\r\n}\r\nstatic int\r\nbfad_debugfs_open_fwsave(struct inode *inode, struct file *file)\r\n{\r\nstruct bfad_port_s *port = inode->i_private;\r\nstruct bfad_s *bfad = port->bfad;\r\nstruct bfad_debug_info *fw_debug;\r\nunsigned long flags;\r\nint rc;\r\nfw_debug = kzalloc(sizeof(struct bfad_debug_info), GFP_KERNEL);\r\nif (!fw_debug)\r\nreturn -ENOMEM;\r\nfw_debug->buffer_len = sizeof(struct bfa_trc_mod_s);\r\nfw_debug->debug_buffer = vmalloc(fw_debug->buffer_len);\r\nif (!fw_debug->debug_buffer) {\r\nkfree(fw_debug);\r\nprintk(KERN_INFO "bfad[%d]: Failed to allocate fwsave buffer\n",\r\nbfad->inst_no);\r\nreturn -ENOMEM;\r\n}\r\nmemset(fw_debug->debug_buffer, 0, fw_debug->buffer_len);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nrc = bfa_ioc_debug_fwsave(&bfad->bfa.ioc,\r\nfw_debug->debug_buffer,\r\n&fw_debug->buffer_len);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (rc != BFA_STATUS_OK) {\r\nvfree(fw_debug->debug_buffer);\r\nfw_debug->debug_buffer = NULL;\r\nkfree(fw_debug);\r\nprintk(KERN_INFO "bfad[%d]: Failed to collect fwsave\n",\r\nbfad->inst_no);\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = fw_debug;\r\nreturn 0;\r\n}\r\nstatic int\r\nbfad_debugfs_open_reg(struct inode *inode, struct file *file)\r\n{\r\nstruct bfad_debug_info *reg_debug;\r\nreg_debug = kzalloc(sizeof(struct bfad_debug_info), GFP_KERNEL);\r\nif (!reg_debug)\r\nreturn -ENOMEM;\r\nreg_debug->i_private = inode->i_private;\r\nfile->private_data = reg_debug;\r\nreturn 0;\r\n}\r\nstatic loff_t\r\nbfad_debugfs_lseek(struct file *file, loff_t offset, int orig)\r\n{\r\nstruct bfad_debug_info *debug = file->private_data;\r\nreturn fixed_size_llseek(file, offset, orig,\r\ndebug->buffer_len);\r\n}\r\nstatic ssize_t\r\nbfad_debugfs_read(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *pos)\r\n{\r\nstruct bfad_debug_info *debug = file->private_data;\r\nif (!debug || !debug->debug_buffer)\r\nreturn 0;\r\nreturn simple_read_from_buffer(buf, nbytes, pos,\r\ndebug->debug_buffer, debug->buffer_len);\r\n}\r\nstatic bfa_status_t\r\nbfad_reg_offset_check(struct bfa_s *bfa, u32 offset, u32 len)\r\n{\r\nu8 area;\r\narea = (offset >> 15) & 0x7;\r\nif (area == 0) {\r\nif ((offset + (len<<2)) > 0x8000)\r\nreturn BFA_STATUS_EINVAL;\r\n} else if (area == 0x1) {\r\nif ((offset + (len<<2)) > 0x10000)\r\nreturn BFA_STATUS_EINVAL;\r\n} else {\r\nif ((offset + (len<<2)) > BFA_REG_ADDRMSK(&bfa->ioc))\r\nreturn BFA_STATUS_EINVAL;\r\n}\r\nreturn BFA_STATUS_OK;\r\n}\r\nstatic ssize_t\r\nbfad_debugfs_read_regrd(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *pos)\r\n{\r\nstruct bfad_debug_info *regrd_debug = file->private_data;\r\nstruct bfad_port_s *port = (struct bfad_port_s *)regrd_debug->i_private;\r\nstruct bfad_s *bfad = port->bfad;\r\nssize_t rc;\r\nif (!bfad->regdata)\r\nreturn 0;\r\nrc = simple_read_from_buffer(buf, nbytes, pos,\r\nbfad->regdata, bfad->reglen);\r\nif ((*pos + nbytes) >= bfad->reglen) {\r\nkfree(bfad->regdata);\r\nbfad->regdata = NULL;\r\nbfad->reglen = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\nbfad_debugfs_write_regrd(struct file *file, const char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nstruct bfad_debug_info *regrd_debug = file->private_data;\r\nstruct bfad_port_s *port = (struct bfad_port_s *)regrd_debug->i_private;\r\nstruct bfad_s *bfad = port->bfad;\r\nstruct bfa_s *bfa = &bfad->bfa;\r\nstruct bfa_ioc_s *ioc = &bfa->ioc;\r\nint addr, len, rc, i;\r\nu32 *regbuf;\r\nvoid __iomem *rb, *reg_addr;\r\nunsigned long flags;\r\nvoid *kern_buf;\r\nkern_buf = kzalloc(nbytes, GFP_KERNEL);\r\nif (!kern_buf) {\r\nprintk(KERN_INFO "bfad[%d]: Failed to allocate buffer\n",\r\nbfad->inst_no);\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user(kern_buf, (void __user *)buf, nbytes)) {\r\nkfree(kern_buf);\r\nreturn -ENOMEM;\r\n}\r\nrc = sscanf(kern_buf, "%x:%x", &addr, &len);\r\nif (rc < 2) {\r\nprintk(KERN_INFO\r\n"bfad[%d]: %s failed to read user buf\n",\r\nbfad->inst_no, __func__);\r\nkfree(kern_buf);\r\nreturn -EINVAL;\r\n}\r\nkfree(kern_buf);\r\nkfree(bfad->regdata);\r\nbfad->regdata = NULL;\r\nbfad->reglen = 0;\r\nbfad->regdata = kzalloc(len << 2, GFP_KERNEL);\r\nif (!bfad->regdata) {\r\nprintk(KERN_INFO "bfad[%d]: Failed to allocate regrd buffer\n",\r\nbfad->inst_no);\r\nreturn -ENOMEM;\r\n}\r\nbfad->reglen = len << 2;\r\nrb = bfa_ioc_bar0(ioc);\r\naddr &= BFA_REG_ADDRMSK(ioc);\r\nrc = bfad_reg_offset_check(bfa, addr, len);\r\nif (rc) {\r\nprintk(KERN_INFO "bfad[%d]: Failed reg offset check\n",\r\nbfad->inst_no);\r\nkfree(bfad->regdata);\r\nbfad->regdata = NULL;\r\nbfad->reglen = 0;\r\nreturn -EINVAL;\r\n}\r\nreg_addr = rb + addr;\r\nregbuf = (u32 *)bfad->regdata;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nfor (i = 0; i < len; i++) {\r\n*regbuf = readl(reg_addr);\r\nregbuf++;\r\nreg_addr += sizeof(u32);\r\n}\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nreturn nbytes;\r\n}\r\nstatic ssize_t\r\nbfad_debugfs_write_regwr(struct file *file, const char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nstruct bfad_debug_info *debug = file->private_data;\r\nstruct bfad_port_s *port = (struct bfad_port_s *)debug->i_private;\r\nstruct bfad_s *bfad = port->bfad;\r\nstruct bfa_s *bfa = &bfad->bfa;\r\nstruct bfa_ioc_s *ioc = &bfa->ioc;\r\nint addr, val, rc;\r\nvoid __iomem *reg_addr;\r\nunsigned long flags;\r\nvoid *kern_buf;\r\nkern_buf = kzalloc(nbytes, GFP_KERNEL);\r\nif (!kern_buf) {\r\nprintk(KERN_INFO "bfad[%d]: Failed to allocate buffer\n",\r\nbfad->inst_no);\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user(kern_buf, (void __user *)buf, nbytes)) {\r\nkfree(kern_buf);\r\nreturn -ENOMEM;\r\n}\r\nrc = sscanf(kern_buf, "%x:%x", &addr, &val);\r\nif (rc < 2) {\r\nprintk(KERN_INFO\r\n"bfad[%d]: %s failed to read user buf\n",\r\nbfad->inst_no, __func__);\r\nkfree(kern_buf);\r\nreturn -EINVAL;\r\n}\r\nkfree(kern_buf);\r\naddr &= BFA_REG_ADDRMSK(ioc);\r\nrc = bfad_reg_offset_check(bfa, addr, 1);\r\nif (rc) {\r\nprintk(KERN_INFO\r\n"bfad[%d]: Failed reg offset check\n",\r\nbfad->inst_no);\r\nreturn -EINVAL;\r\n}\r\nreg_addr = (bfa_ioc_bar0(ioc)) + addr;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nwritel(val, reg_addr);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nreturn nbytes;\r\n}\r\nstatic int\r\nbfad_debugfs_release(struct inode *inode, struct file *file)\r\n{\r\nstruct bfad_debug_info *debug = file->private_data;\r\nif (!debug)\r\nreturn 0;\r\nfile->private_data = NULL;\r\nkfree(debug);\r\nreturn 0;\r\n}\r\nstatic int\r\nbfad_debugfs_release_fwtrc(struct inode *inode, struct file *file)\r\n{\r\nstruct bfad_debug_info *fw_debug = file->private_data;\r\nif (!fw_debug)\r\nreturn 0;\r\nif (fw_debug->debug_buffer)\r\nvfree(fw_debug->debug_buffer);\r\nfile->private_data = NULL;\r\nkfree(fw_debug);\r\nreturn 0;\r\n}\r\ninline void\r\nbfad_debugfs_init(struct bfad_port_s *port)\r\n{\r\nstruct bfad_s *bfad = port->bfad;\r\nconst struct bfad_debugfs_entry *file;\r\nchar name[64];\r\nint i;\r\nif (!bfa_debugfs_enable)\r\nreturn;\r\nif (!bfa_debugfs_root) {\r\nbfa_debugfs_root = debugfs_create_dir("bfa", NULL);\r\natomic_set(&bfa_debugfs_port_count, 0);\r\nif (!bfa_debugfs_root) {\r\nprintk(KERN_WARNING\r\n"BFA debugfs root dir creation failed\n");\r\ngoto err;\r\n}\r\n}\r\nsnprintf(name, sizeof(name), "pci_dev:%s", bfad->pci_name);\r\nif (!port->port_debugfs_root) {\r\nport->port_debugfs_root =\r\ndebugfs_create_dir(name, bfa_debugfs_root);\r\nif (!port->port_debugfs_root) {\r\nprintk(KERN_WARNING\r\n"bfa %s: debugfs root creation failed\n",\r\nbfad->pci_name);\r\ngoto err;\r\n}\r\natomic_inc(&bfa_debugfs_port_count);\r\nfor (i = 0; i < ARRAY_SIZE(bfad_debugfs_files); i++) {\r\nfile = &bfad_debugfs_files[i];\r\nbfad->bfad_dentry_files[i] =\r\ndebugfs_create_file(file->name,\r\nfile->mode,\r\nport->port_debugfs_root,\r\nport,\r\nfile->fops);\r\nif (!bfad->bfad_dentry_files[i]) {\r\nprintk(KERN_WARNING\r\n"bfa %s: debugfs %s creation failed\n",\r\nbfad->pci_name, file->name);\r\ngoto err;\r\n}\r\n}\r\n}\r\nerr:\r\nreturn;\r\n}\r\ninline void\r\nbfad_debugfs_exit(struct bfad_port_s *port)\r\n{\r\nstruct bfad_s *bfad = port->bfad;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(bfad_debugfs_files); i++) {\r\nif (bfad->bfad_dentry_files[i]) {\r\ndebugfs_remove(bfad->bfad_dentry_files[i]);\r\nbfad->bfad_dentry_files[i] = NULL;\r\n}\r\n}\r\nif (port->port_debugfs_root) {\r\ndebugfs_remove(port->port_debugfs_root);\r\nport->port_debugfs_root = NULL;\r\natomic_dec(&bfa_debugfs_port_count);\r\n}\r\nif (atomic_read(&bfa_debugfs_port_count) == 0) {\r\ndebugfs_remove(bfa_debugfs_root);\r\nbfa_debugfs_root = NULL;\r\n}\r\n}
