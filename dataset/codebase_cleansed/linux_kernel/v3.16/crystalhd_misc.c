static inline uint32_t crystalhd_dram_rd(struct crystalhd_adp *adp,\r\nuint32_t mem_off)\r\n{\r\ncrystalhd_reg_wr(adp, DCI_DRAM_BASE_ADDR, (mem_off >> 19));\r\nreturn bc_dec_reg_rd(adp, (0x00380000 | (mem_off & 0x0007FFFF)));\r\n}\r\nstatic inline void crystalhd_dram_wr(struct crystalhd_adp *adp,\r\nuint32_t mem_off, uint32_t val)\r\n{\r\ncrystalhd_reg_wr(adp, DCI_DRAM_BASE_ADDR, (mem_off >> 19));\r\nbc_dec_reg_wr(adp, (0x00380000 | (mem_off & 0x0007FFFF)), val);\r\n}\r\nstatic inline enum BC_STATUS bc_chk_dram_range(struct crystalhd_adp *adp,\r\nuint32_t start_off, uint32_t cnt)\r\n{\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic struct crystalhd_dio_req *crystalhd_alloc_dio(struct crystalhd_adp *adp)\r\n{\r\nunsigned long flags = 0;\r\nstruct crystalhd_dio_req *temp = NULL;\r\nif (!adp) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn temp;\r\n}\r\nspin_lock_irqsave(&adp->lock, flags);\r\ntemp = adp->ua_map_free_head;\r\nif (temp)\r\nadp->ua_map_free_head = adp->ua_map_free_head->next;\r\nspin_unlock_irqrestore(&adp->lock, flags);\r\nreturn temp;\r\n}\r\nstatic void crystalhd_free_dio(struct crystalhd_adp *adp,\r\nstruct crystalhd_dio_req *dio)\r\n{\r\nunsigned long flags = 0;\r\nif (!adp || !dio)\r\nreturn;\r\nspin_lock_irqsave(&adp->lock, flags);\r\ndio->sig = crystalhd_dio_inv;\r\ndio->page_cnt = 0;\r\ndio->fb_size = 0;\r\nmemset(&dio->uinfo, 0, sizeof(dio->uinfo));\r\ndio->next = adp->ua_map_free_head;\r\nadp->ua_map_free_head = dio;\r\nspin_unlock_irqrestore(&adp->lock, flags);\r\n}\r\nstatic struct crystalhd_elem *crystalhd_alloc_elem(struct crystalhd_adp *adp)\r\n{\r\nunsigned long flags = 0;\r\nstruct crystalhd_elem *temp = NULL;\r\nif (!adp)\r\nreturn temp;\r\nspin_lock_irqsave(&adp->lock, flags);\r\ntemp = adp->elem_pool_head;\r\nif (temp) {\r\nadp->elem_pool_head = adp->elem_pool_head->flink;\r\nmemset(temp, 0, sizeof(*temp));\r\n}\r\nspin_unlock_irqrestore(&adp->lock, flags);\r\nreturn temp;\r\n}\r\nstatic void crystalhd_free_elem(struct crystalhd_adp *adp,\r\nstruct crystalhd_elem *elem)\r\n{\r\nunsigned long flags = 0;\r\nif (!adp || !elem)\r\nreturn;\r\nspin_lock_irqsave(&adp->lock, flags);\r\nelem->flink = adp->elem_pool_head;\r\nadp->elem_pool_head = elem;\r\nspin_unlock_irqrestore(&adp->lock, flags);\r\n}\r\nstatic inline void crystalhd_set_sg(struct scatterlist *sg, struct page *page,\r\nunsigned int len, unsigned int offset)\r\n{\r\nsg_set_page(sg, page, len, offset);\r\n#ifdef CONFIG_X86_64\r\nsg->dma_length = len;\r\n#endif\r\n}\r\nstatic inline void crystalhd_init_sg(struct scatterlist *sg,\r\nunsigned int entries)\r\n{\r\nsg_init_table(sg, entries);\r\n}\r\nuint32_t bc_dec_reg_rd(struct crystalhd_adp *adp, uint32_t reg_off)\r\n{\r\nif (!adp || (reg_off > adp->pci_mem_len)) {\r\nBCMLOG_ERR("dec_rd_reg_off outof range: 0x%08x\n", reg_off);\r\nreturn 0;\r\n}\r\nreturn readl(adp->addr + reg_off);\r\n}\r\nvoid bc_dec_reg_wr(struct crystalhd_adp *adp, uint32_t reg_off, uint32_t val)\r\n{\r\nif (!adp || (reg_off > adp->pci_mem_len)) {\r\nBCMLOG_ERR("dec_wr_reg_off outof range: 0x%08x\n", reg_off);\r\nreturn;\r\n}\r\nwritel(val, adp->addr + reg_off);\r\nudelay(8);\r\n}\r\nuint32_t crystalhd_reg_rd(struct crystalhd_adp *adp, uint32_t reg_off)\r\n{\r\nif (!adp || (reg_off > adp->pci_i2o_len)) {\r\nBCMLOG_ERR("link_rd_reg_off outof range: 0x%08x\n", reg_off);\r\nreturn 0;\r\n}\r\nreturn readl(adp->i2o_addr + reg_off);\r\n}\r\nvoid crystalhd_reg_wr(struct crystalhd_adp *adp, uint32_t reg_off,\r\nuint32_t val)\r\n{\r\nif (!adp || (reg_off > adp->pci_i2o_len)) {\r\nBCMLOG_ERR("link_wr_reg_off outof range: 0x%08x\n", reg_off);\r\nreturn;\r\n}\r\nwritel(val, adp->i2o_addr + reg_off);\r\n}\r\nenum BC_STATUS crystalhd_mem_rd(struct crystalhd_adp *adp, uint32_t start_off,\r\nuint32_t dw_cnt, uint32_t *rd_buff)\r\n{\r\nuint32_t ix = 0;\r\nif (!adp || !rd_buff ||\r\n(bc_chk_dram_range(adp, start_off, dw_cnt) != BC_STS_SUCCESS)) {\r\nBCMLOG_ERR("Invalid arg\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nfor (ix = 0; ix < dw_cnt; ix++)\r\nrd_buff[ix] = crystalhd_dram_rd(adp, (start_off + (ix * 4)));\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_mem_wr(struct crystalhd_adp *adp, uint32_t start_off,\r\nuint32_t dw_cnt, uint32_t *wr_buff)\r\n{\r\nuint32_t ix = 0;\r\nif (!adp || !wr_buff ||\r\n(bc_chk_dram_range(adp, start_off, dw_cnt) != BC_STS_SUCCESS)) {\r\nBCMLOG_ERR("Invalid arg\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nfor (ix = 0; ix < dw_cnt; ix++)\r\ncrystalhd_dram_wr(adp, (start_off + (ix * 4)), wr_buff[ix]);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_pci_cfg_rd(struct crystalhd_adp *adp, uint32_t off,\r\nuint32_t len, uint32_t *val)\r\n{\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nint rc = 0;\r\nif (!adp || !val) {\r\nBCMLOG_ERR("Invalid arg\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nswitch (len) {\r\ncase 1:\r\nrc = pci_read_config_byte(adp->pdev, off, (u8 *)val);\r\nbreak;\r\ncase 2:\r\nrc = pci_read_config_word(adp->pdev, off, (u16 *)val);\r\nbreak;\r\ncase 4:\r\nrc = pci_read_config_dword(adp->pdev, off, (u32 *)val);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nsts = BC_STS_INV_ARG;\r\nBCMLOG_ERR("Invalid len:%d\n", len);\r\n}\r\nif (rc && (sts == BC_STS_SUCCESS))\r\nsts = BC_STS_ERROR;\r\nreturn sts;\r\n}\r\nenum BC_STATUS crystalhd_pci_cfg_wr(struct crystalhd_adp *adp, uint32_t off,\r\nuint32_t len, uint32_t val)\r\n{\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nint rc = 0;\r\nif (!adp || !val) {\r\nBCMLOG_ERR("Invalid arg\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nswitch (len) {\r\ncase 1:\r\nrc = pci_write_config_byte(adp->pdev, off, (u8)val);\r\nbreak;\r\ncase 2:\r\nrc = pci_write_config_word(adp->pdev, off, (u16)val);\r\nbreak;\r\ncase 4:\r\nrc = pci_write_config_dword(adp->pdev, off, val);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nsts = BC_STS_INV_ARG;\r\nBCMLOG_ERR("Invalid len:%d\n", len);\r\n}\r\nif (rc && (sts == BC_STS_SUCCESS))\r\nsts = BC_STS_ERROR;\r\nreturn sts;\r\n}\r\nvoid *bc_kern_dma_alloc(struct crystalhd_adp *adp, uint32_t sz,\r\ndma_addr_t *phy_addr)\r\n{\r\nvoid *temp = NULL;\r\nif (!adp || !sz || !phy_addr) {\r\nBCMLOG_ERR("Invalid Arg..\n");\r\nreturn temp;\r\n}\r\ntemp = pci_alloc_consistent(adp->pdev, sz, phy_addr);\r\nif (temp)\r\nmemset(temp, 0, sz);\r\nreturn temp;\r\n}\r\nvoid bc_kern_dma_free(struct crystalhd_adp *adp, uint32_t sz, void *ka,\r\ndma_addr_t phy_addr)\r\n{\r\nif (!adp || !ka || !sz || !phy_addr) {\r\nBCMLOG_ERR("Invalid Arg..\n");\r\nreturn;\r\n}\r\npci_free_consistent(adp->pdev, sz, ka, phy_addr);\r\n}\r\nenum BC_STATUS crystalhd_create_dioq(struct crystalhd_adp *adp,\r\nstruct crystalhd_dioq **dioq_hnd,\r\ncrystalhd_data_free_cb cb, void *cbctx)\r\n{\r\nstruct crystalhd_dioq *dioq = NULL;\r\nif (!adp || !dioq_hnd) {\r\nBCMLOG_ERR("Invalid arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ndioq = kzalloc(sizeof(*dioq), GFP_KERNEL);\r\nif (!dioq)\r\nreturn BC_STS_INSUFF_RES;\r\nspin_lock_init(&dioq->lock);\r\ndioq->sig = BC_LINK_DIOQ_SIG;\r\ndioq->head = (struct crystalhd_elem *)&dioq->head;\r\ndioq->tail = (struct crystalhd_elem *)&dioq->head;\r\ncrystalhd_create_event(&dioq->event);\r\ndioq->adp = adp;\r\ndioq->data_rel_cb = cb;\r\ndioq->cb_context = cbctx;\r\n*dioq_hnd = dioq;\r\nreturn BC_STS_SUCCESS;\r\n}\r\nvoid crystalhd_delete_dioq(struct crystalhd_adp *adp,\r\nstruct crystalhd_dioq *dioq)\r\n{\r\nvoid *temp;\r\nif (!dioq || (dioq->sig != BC_LINK_DIOQ_SIG))\r\nreturn;\r\ndo {\r\ntemp = crystalhd_dioq_fetch(dioq);\r\nif (temp && dioq->data_rel_cb)\r\ndioq->data_rel_cb(dioq->cb_context, temp);\r\n} while (temp);\r\ndioq->sig = 0;\r\nkfree(dioq);\r\n}\r\nenum BC_STATUS crystalhd_dioq_add(struct crystalhd_dioq *ioq, void *data,\r\nbool wake, uint32_t tag)\r\n{\r\nunsigned long flags = 0;\r\nstruct crystalhd_elem *tmp;\r\nif (!ioq || (ioq->sig != BC_LINK_DIOQ_SIG) || !data) {\r\nBCMLOG_ERR("Invalid arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ntmp = crystalhd_alloc_elem(ioq->adp);\r\nif (!tmp) {\r\nBCMLOG_ERR("No free elements.\n");\r\nreturn BC_STS_INSUFF_RES;\r\n}\r\ntmp->data = data;\r\ntmp->tag = tag;\r\nspin_lock_irqsave(&ioq->lock, flags);\r\ntmp->flink = (struct crystalhd_elem *)&ioq->head;\r\ntmp->blink = ioq->tail;\r\ntmp->flink->blink = tmp;\r\ntmp->blink->flink = tmp;\r\nioq->count++;\r\nspin_unlock_irqrestore(&ioq->lock, flags);\r\nif (wake)\r\ncrystalhd_set_event(&ioq->event);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nvoid *crystalhd_dioq_fetch(struct crystalhd_dioq *ioq)\r\n{\r\nunsigned long flags = 0;\r\nstruct crystalhd_elem *tmp;\r\nstruct crystalhd_elem *ret = NULL;\r\nvoid *data = NULL;\r\nif (!ioq || (ioq->sig != BC_LINK_DIOQ_SIG)) {\r\nBCMLOG_ERR("Invalid arg!!\n");\r\nreturn data;\r\n}\r\nspin_lock_irqsave(&ioq->lock, flags);\r\ntmp = ioq->head;\r\nif (tmp != (struct crystalhd_elem *)&ioq->head) {\r\nret = tmp;\r\ntmp->flink->blink = tmp->blink;\r\ntmp->blink->flink = tmp->flink;\r\nioq->count--;\r\n}\r\nspin_unlock_irqrestore(&ioq->lock, flags);\r\nif (ret) {\r\ndata = ret->data;\r\ncrystalhd_free_elem(ioq->adp, ret);\r\n}\r\nreturn data;\r\n}\r\nvoid *crystalhd_dioq_find_and_fetch(struct crystalhd_dioq *ioq, uint32_t tag)\r\n{\r\nunsigned long flags = 0;\r\nstruct crystalhd_elem *tmp;\r\nstruct crystalhd_elem *ret = NULL;\r\nvoid *data = NULL;\r\nif (!ioq || (ioq->sig != BC_LINK_DIOQ_SIG)) {\r\nBCMLOG_ERR("Invalid arg!!\n");\r\nreturn data;\r\n}\r\nspin_lock_irqsave(&ioq->lock, flags);\r\ntmp = ioq->head;\r\nwhile (tmp != (struct crystalhd_elem *)&ioq->head) {\r\nif (tmp->tag == tag) {\r\nret = tmp;\r\ntmp->flink->blink = tmp->blink;\r\ntmp->blink->flink = tmp->flink;\r\nioq->count--;\r\nbreak;\r\n}\r\ntmp = tmp->flink;\r\n}\r\nspin_unlock_irqrestore(&ioq->lock, flags);\r\nif (ret) {\r\ndata = ret->data;\r\ncrystalhd_free_elem(ioq->adp, ret);\r\n}\r\nreturn data;\r\n}\r\nvoid *crystalhd_dioq_fetch_wait(struct crystalhd_dioq *ioq, uint32_t to_secs,\r\nuint32_t *sig_pend)\r\n{\r\nunsigned long flags = 0;\r\nint rc = 0, count;\r\nvoid *tmp = NULL;\r\nif (!ioq || (ioq->sig != BC_LINK_DIOQ_SIG) || !to_secs || !sig_pend) {\r\nBCMLOG_ERR("Invalid arg!!\n");\r\nreturn tmp;\r\n}\r\ncount = to_secs;\r\nspin_lock_irqsave(&ioq->lock, flags);\r\nwhile ((ioq->count == 0) && count) {\r\nspin_unlock_irqrestore(&ioq->lock, flags);\r\ncrystalhd_wait_on_event(&ioq->event,\r\n(ioq->count > 0), 1000, rc, 0);\r\nif (rc == 0) {\r\ngoto out;\r\n} else if (rc == -EINTR) {\r\nBCMLOG(BCMLOG_INFO, "Cancelling fetch wait\n");\r\n*sig_pend = 1;\r\nreturn tmp;\r\n}\r\nspin_lock_irqsave(&ioq->lock, flags);\r\ncount--;\r\n}\r\nspin_unlock_irqrestore(&ioq->lock, flags);\r\nout:\r\nreturn crystalhd_dioq_fetch(ioq);\r\n}\r\nenum BC_STATUS crystalhd_map_dio(struct crystalhd_adp *adp, void *ubuff,\r\nuint32_t ubuff_sz, uint32_t uv_offset,\r\nbool en_422mode, bool dir_tx,\r\nstruct crystalhd_dio_req **dio_hnd)\r\n{\r\nstruct crystalhd_dio_req *dio;\r\nunsigned long start = 0, end = 0, uaddr = 0, count = 0;\r\nunsigned long spsz = 0, uv_start = 0;\r\nint i = 0, rw = 0, res = 0, nr_pages = 0, skip_fb_sg = 0;\r\nif (!adp || !ubuff || !ubuff_sz || !dio_hnd) {\r\nBCMLOG_ERR("Invalid arg\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nuaddr = (unsigned long)ubuff;\r\ncount = (unsigned long)ubuff_sz;\r\nend = (uaddr + count + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nstart = uaddr >> PAGE_SHIFT;\r\nnr_pages = end - start;\r\nif (!count || ((uaddr + count) < uaddr)) {\r\nBCMLOG_ERR("User addr overflow!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ndio = crystalhd_alloc_dio(adp);\r\nif (!dio) {\r\nBCMLOG_ERR("dio pool empty..\n");\r\nreturn BC_STS_INSUFF_RES;\r\n}\r\nif (dir_tx) {\r\nrw = WRITE;\r\ndio->direction = DMA_TO_DEVICE;\r\n} else {\r\nrw = READ;\r\ndio->direction = DMA_FROM_DEVICE;\r\n}\r\nif (nr_pages > dio->max_pages) {\r\nBCMLOG_ERR("max_pages(%d) exceeded(%d)!!\n",\r\ndio->max_pages, nr_pages);\r\ncrystalhd_unmap_dio(adp, dio);\r\nreturn BC_STS_INSUFF_RES;\r\n}\r\nif (uv_offset) {\r\nuv_start = (uaddr + (unsigned long)uv_offset) >> PAGE_SHIFT;\r\ndio->uinfo.uv_sg_ix = uv_start - start;\r\ndio->uinfo.uv_sg_off = ((uaddr + (unsigned long)uv_offset) &\r\n~PAGE_MASK);\r\n}\r\ndio->fb_size = ubuff_sz & 0x03;\r\nif (dio->fb_size) {\r\nres = copy_from_user(dio->fb_va,\r\n(void __user *)(uaddr + count - dio->fb_size),\r\ndio->fb_size);\r\nif (res) {\r\nBCMLOG_ERR("failed %d to copy %u fill bytes from %p\n",\r\nres, dio->fb_size,\r\n(void *)(uaddr + count-dio->fb_size));\r\ncrystalhd_unmap_dio(adp, dio);\r\nreturn BC_STS_INSUFF_RES;\r\n}\r\n}\r\ndown_read(&current->mm->mmap_sem);\r\nres = get_user_pages(current, current->mm, uaddr, nr_pages, rw == READ,\r\n0, dio->pages, NULL);\r\nup_read(&current->mm->mmap_sem);\r\ndio->sig = crystalhd_dio_locked;\r\nif (res < nr_pages) {\r\nBCMLOG_ERR("get pages failed: %d-%d\n", nr_pages, res);\r\ndio->page_cnt = res;\r\ncrystalhd_unmap_dio(adp, dio);\r\nreturn BC_STS_ERROR;\r\n}\r\ndio->page_cnt = nr_pages;\r\ncrystalhd_init_sg(dio->sg, dio->page_cnt);\r\ncrystalhd_set_sg(&dio->sg[0], dio->pages[0], 0, uaddr & ~PAGE_MASK);\r\nif (nr_pages > 1) {\r\ndio->sg[0].length = PAGE_SIZE - dio->sg[0].offset;\r\n#ifdef CONFIG_X86_64\r\ndio->sg[0].dma_length = dio->sg[0].length;\r\n#endif\r\ncount -= dio->sg[0].length;\r\nfor (i = 1; i < nr_pages; i++) {\r\nif (count < 4) {\r\nspsz = count;\r\nskip_fb_sg = 1;\r\n} else {\r\nspsz = (count < PAGE_SIZE) ?\r\n(count & ~0x03) : PAGE_SIZE;\r\n}\r\ncrystalhd_set_sg(&dio->sg[i], dio->pages[i], spsz, 0);\r\ncount -= spsz;\r\n}\r\n} else {\r\nif (count < 4) {\r\ndio->sg[0].length = count;\r\nskip_fb_sg = 1;\r\n} else {\r\ndio->sg[0].length = count - dio->fb_size;\r\n}\r\n#ifdef CONFIG_X86_64\r\ndio->sg[0].dma_length = dio->sg[0].length;\r\n#endif\r\n}\r\ndio->sg_cnt = pci_map_sg(adp->pdev, dio->sg,\r\ndio->page_cnt, dio->direction);\r\nif (dio->sg_cnt <= 0) {\r\nBCMLOG_ERR("sg map %d-%d\n", dio->sg_cnt, dio->page_cnt);\r\ncrystalhd_unmap_dio(adp, dio);\r\nreturn BC_STS_ERROR;\r\n}\r\nif (dio->sg_cnt && skip_fb_sg)\r\ndio->sg_cnt -= 1;\r\ndio->sig = crystalhd_dio_sg_mapped;\r\ndio->uinfo.xfr_len = ubuff_sz;\r\ndio->uinfo.xfr_buff = ubuff;\r\ndio->uinfo.uv_offset = uv_offset;\r\ndio->uinfo.b422mode = en_422mode;\r\ndio->uinfo.dir_tx = dir_tx;\r\n*dio_hnd = dio;\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_unmap_dio(struct crystalhd_adp *adp,\r\nstruct crystalhd_dio_req *dio)\r\n{\r\nstruct page *page = NULL;\r\nint j = 0;\r\nif (!adp || !dio) {\r\nBCMLOG_ERR("Invalid arg\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif ((dio->page_cnt > 0) && (dio->sig != crystalhd_dio_inv)) {\r\nfor (j = 0; j < dio->page_cnt; j++) {\r\npage = dio->pages[j];\r\nif (page) {\r\nif (!PageReserved(page) &&\r\n(dio->direction == DMA_FROM_DEVICE))\r\nSetPageDirty(page);\r\npage_cache_release(page);\r\n}\r\n}\r\n}\r\nif (dio->sig == crystalhd_dio_sg_mapped)\r\npci_unmap_sg(adp->pdev, dio->sg, dio->page_cnt,\r\ndio->direction);\r\ncrystalhd_free_dio(adp, dio);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nint crystalhd_create_dio_pool(struct crystalhd_adp *adp, uint32_t max_pages)\r\n{\r\nuint32_t asz = 0, i = 0;\r\nuint8_t *temp;\r\nstruct crystalhd_dio_req *dio;\r\nif (!adp || !max_pages) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn -EINVAL;\r\n}\r\nadp->fill_byte_pool = pci_pool_create("crystalhd_fbyte",\r\nadp->pdev, 8, 8, 0);\r\nif (!adp->fill_byte_pool) {\r\nBCMLOG_ERR("failed to create fill byte pool\n");\r\nreturn -ENOMEM;\r\n}\r\nasz = (sizeof(*dio->pages) * max_pages) +\r\n(sizeof(*dio->sg) * max_pages) + sizeof(*dio);\r\nBCMLOG(BCMLOG_DBG, "Initializing Dio pool %d %d %x %p\n",\r\nBC_LINK_SG_POOL_SZ, max_pages, asz, adp->fill_byte_pool);\r\nfor (i = 0; i < BC_LINK_SG_POOL_SZ; i++) {\r\ntemp = kzalloc(asz, GFP_KERNEL);\r\nif ((temp) == NULL) {\r\nBCMLOG_ERR("Failed to alloc %d mem\n", asz);\r\nreturn -ENOMEM;\r\n}\r\ndio = (struct crystalhd_dio_req *)temp;\r\ntemp += sizeof(*dio);\r\ndio->pages = (struct page **)temp;\r\ntemp += (sizeof(*dio->pages) * max_pages);\r\ndio->sg = (struct scatterlist *)temp;\r\ndio->max_pages = max_pages;\r\ndio->fb_va = pci_pool_alloc(adp->fill_byte_pool, GFP_KERNEL,\r\n&dio->fb_pa);\r\nif (!dio->fb_va) {\r\nBCMLOG_ERR("fill byte alloc failed.\n");\r\nreturn -ENOMEM;\r\n}\r\ncrystalhd_free_dio(adp, dio);\r\n}\r\nreturn 0;\r\n}\r\nvoid crystalhd_destroy_dio_pool(struct crystalhd_adp *adp)\r\n{\r\nstruct crystalhd_dio_req *dio;\r\nint count = 0;\r\nif (!adp) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn;\r\n}\r\ndo {\r\ndio = crystalhd_alloc_dio(adp);\r\nif (dio) {\r\nif (dio->fb_va)\r\npci_pool_free(adp->fill_byte_pool,\r\ndio->fb_va, dio->fb_pa);\r\ncount++;\r\nkfree(dio);\r\n}\r\n} while (dio);\r\nif (adp->fill_byte_pool) {\r\npci_pool_destroy(adp->fill_byte_pool);\r\nadp->fill_byte_pool = NULL;\r\n}\r\nBCMLOG(BCMLOG_DBG, "Released dio pool %d\n", count);\r\n}\r\nint crystalhd_create_elem_pool(struct crystalhd_adp *adp,\r\nuint32_t pool_size)\r\n{\r\nuint32_t i;\r\nstruct crystalhd_elem *temp;\r\nif (!adp || !pool_size)\r\nreturn -EINVAL;\r\nfor (i = 0; i < pool_size; i++) {\r\ntemp = kzalloc(sizeof(*temp), GFP_KERNEL);\r\nif (!temp) {\r\nBCMLOG_ERR("kalloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\ncrystalhd_free_elem(adp, temp);\r\n}\r\nBCMLOG(BCMLOG_DBG, "allocated %d elem\n", pool_size);\r\nreturn 0;\r\n}\r\nvoid crystalhd_delete_elem_pool(struct crystalhd_adp *adp)\r\n{\r\nstruct crystalhd_elem *temp;\r\nint dbg_cnt = 0;\r\nif (!adp)\r\nreturn;\r\ndo {\r\ntemp = crystalhd_alloc_elem(adp);\r\nif (temp) {\r\nkfree(temp);\r\ndbg_cnt++;\r\n}\r\n} while (temp);\r\nBCMLOG(BCMLOG_DBG, "released %d elem\n", dbg_cnt);\r\n}\r\nvoid crystalhd_show_buffer(uint32_t off, uint8_t *buff, uint32_t dwcount)\r\n{\r\nuint32_t i, k = 1;\r\nfor (i = 0; i < dwcount; i++) {\r\nif (k == 1)\r\nBCMLOG(BCMLOG_DATA, "0x%08X : ", off);\r\nBCMLOG(BCMLOG_DATA, " 0x%08X ", *((uint32_t *)buff));\r\nbuff += sizeof(uint32_t);\r\noff += sizeof(uint32_t);\r\nk++;\r\nif ((i == dwcount - 1) || (k > 4)) {\r\nBCMLOG(BCMLOG_DATA, "\n");\r\nk = 1;\r\n}\r\n}\r\n}
