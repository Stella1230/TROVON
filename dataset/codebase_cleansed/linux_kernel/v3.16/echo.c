static inline void lms_adapt_bg(struct oslec_state *ec, int clean, int shift)\r\n{\r\nint i;\r\nint offset1;\r\nint offset2;\r\nint factor;\r\nint exp;\r\nint16_t *phist;\r\nint n;\r\nif (shift > 0)\r\nfactor = clean << shift;\r\nelse\r\nfactor = clean >> -shift;\r\noffset2 = ec->curr_pos;\r\noffset1 = ec->taps - offset2;\r\nphist = &ec->fir_state_bg.history[offset2];\r\nn = ec->taps;\r\nfor (i = 0; i < n; i++) {\r\nexp = *phist++ * factor;\r\nec->fir_taps16[1][i] += (int16_t) ((exp + (1 << 14)) >> 15);\r\n}\r\n}\r\nstatic inline void lms_adapt_bg(struct oslec_state *ec, int clean, int shift)\r\n{\r\nint i;\r\nint offset1;\r\nint offset2;\r\nint factor;\r\nint exp;\r\nif (shift > 0)\r\nfactor = clean << shift;\r\nelse\r\nfactor = clean >> -shift;\r\noffset2 = ec->curr_pos;\r\noffset1 = ec->taps - offset2;\r\nfor (i = ec->taps - 1; i >= offset1; i--) {\r\nexp = (ec->fir_state_bg.history[i - offset1] * factor);\r\nec->fir_taps16[1][i] += (int16_t) ((exp + (1 << 14)) >> 15);\r\n}\r\nfor (; i >= 0; i--) {\r\nexp = (ec->fir_state_bg.history[i + offset2] * factor);\r\nec->fir_taps16[1][i] += (int16_t) ((exp + (1 << 14)) >> 15);\r\n}\r\n}\r\nstatic inline int top_bit(unsigned int bits)\r\n{\r\nif (bits == 0)\r\nreturn -1;\r\nelse\r\nreturn (int)fls((int32_t) bits) - 1;\r\n}\r\nstruct oslec_state *oslec_create(int len, int adaption_mode)\r\n{\r\nstruct oslec_state *ec;\r\nint i;\r\nconst int16_t *history;\r\nec = kzalloc(sizeof(*ec), GFP_KERNEL);\r\nif (!ec)\r\nreturn NULL;\r\nec->taps = len;\r\nec->log2taps = top_bit(len);\r\nec->curr_pos = ec->taps - 1;\r\nec->fir_taps16[0] =\r\nkcalloc(ec->taps, sizeof(int16_t), GFP_KERNEL);\r\nif (!ec->fir_taps16[0])\r\ngoto error_oom_0;\r\nec->fir_taps16[1] =\r\nkcalloc(ec->taps, sizeof(int16_t), GFP_KERNEL);\r\nif (!ec->fir_taps16[1])\r\ngoto error_oom_1;\r\nhistory = fir16_create(&ec->fir_state, ec->fir_taps16[0], ec->taps);\r\nif (!history)\r\ngoto error_state;\r\nhistory = fir16_create(&ec->fir_state_bg, ec->fir_taps16[1], ec->taps);\r\nif (!history)\r\ngoto error_state_bg;\r\nfor (i = 0; i < 5; i++)\r\nec->xvtx[i] = ec->yvtx[i] = ec->xvrx[i] = ec->yvrx[i] = 0;\r\nec->cng_level = 1000;\r\noslec_adaption_mode(ec, adaption_mode);\r\nec->snapshot = kcalloc(ec->taps, sizeof(int16_t), GFP_KERNEL);\r\nif (!ec->snapshot)\r\ngoto error_snap;\r\nec->cond_met = 0;\r\nec->pstates = 0;\r\nec->ltxacc = ec->lrxacc = ec->lcleanacc = ec->lclean_bgacc = 0;\r\nec->ltx = ec->lrx = ec->lclean = ec->lclean_bg = 0;\r\nec->tx_1 = ec->tx_2 = ec->rx_1 = ec->rx_2 = 0;\r\nec->lbgn = ec->lbgn_acc = 0;\r\nec->lbgn_upper = 200;\r\nec->lbgn_upper_acc = ec->lbgn_upper << 13;\r\nreturn ec;\r\nerror_snap:\r\nfir16_free(&ec->fir_state_bg);\r\nerror_state_bg:\r\nfir16_free(&ec->fir_state);\r\nerror_state:\r\nkfree(ec->fir_taps16[1]);\r\nerror_oom_1:\r\nkfree(ec->fir_taps16[0]);\r\nerror_oom_0:\r\nkfree(ec);\r\nreturn NULL;\r\n}\r\nvoid oslec_free(struct oslec_state *ec)\r\n{\r\nint i;\r\nfir16_free(&ec->fir_state);\r\nfir16_free(&ec->fir_state_bg);\r\nfor (i = 0; i < 2; i++)\r\nkfree(ec->fir_taps16[i]);\r\nkfree(ec->snapshot);\r\nkfree(ec);\r\n}\r\nvoid oslec_adaption_mode(struct oslec_state *ec, int adaption_mode)\r\n{\r\nec->adaption_mode = adaption_mode;\r\n}\r\nvoid oslec_flush(struct oslec_state *ec)\r\n{\r\nint i;\r\nec->ltxacc = ec->lrxacc = ec->lcleanacc = ec->lclean_bgacc = 0;\r\nec->ltx = ec->lrx = ec->lclean = ec->lclean_bg = 0;\r\nec->tx_1 = ec->tx_2 = ec->rx_1 = ec->rx_2 = 0;\r\nec->lbgn = ec->lbgn_acc = 0;\r\nec->lbgn_upper = 200;\r\nec->lbgn_upper_acc = ec->lbgn_upper << 13;\r\nec->nonupdate_dwell = 0;\r\nfir16_flush(&ec->fir_state);\r\nfir16_flush(&ec->fir_state_bg);\r\nec->fir_state.curr_pos = ec->taps - 1;\r\nec->fir_state_bg.curr_pos = ec->taps - 1;\r\nfor (i = 0; i < 2; i++)\r\nmemset(ec->fir_taps16[i], 0, ec->taps * sizeof(int16_t));\r\nec->curr_pos = ec->taps - 1;\r\nec->pstates = 0;\r\n}\r\nvoid oslec_snapshot(struct oslec_state *ec)\r\n{\r\nmemcpy(ec->snapshot, ec->fir_taps16[0], ec->taps * sizeof(int16_t));\r\n}\r\nint16_t oslec_update(struct oslec_state *ec, int16_t tx, int16_t rx)\r\n{\r\nint32_t echo_value;\r\nint clean_bg;\r\nint tmp;\r\nint tmp1;\r\nec->tx = tx;\r\nec->rx = rx;\r\ntx >>= 1;\r\nrx >>= 1;\r\nif (ec->adaption_mode & ECHO_CAN_USE_RX_HPF) {\r\ntmp = rx << 15;\r\ntmp -= (tmp >> 4);\r\nec->rx_1 += -(ec->rx_1 >> DC_LOG2BETA) + tmp - ec->rx_2;\r\ntmp1 = ec->rx_1 >> 15;\r\nif (tmp1 > 16383)\r\ntmp1 = 16383;\r\nif (tmp1 < -16383)\r\ntmp1 = -16383;\r\nrx = tmp1;\r\nec->rx_2 = tmp;\r\n}\r\n{\r\nint new, old;\r\nnew = (int)tx * (int)tx;\r\nold = (int)ec->fir_state.history[ec->fir_state.curr_pos] *\r\n(int)ec->fir_state.history[ec->fir_state.curr_pos];\r\nec->pstates +=\r\n((new - old) + (1 << (ec->log2taps - 1))) >> ec->log2taps;\r\nif (ec->pstates < 0)\r\nec->pstates = 0;\r\n}\r\nec->ltxacc += abs(tx) - ec->ltx;\r\nec->ltx = (ec->ltxacc + (1 << 4)) >> 5;\r\nec->lrxacc += abs(rx) - ec->lrx;\r\nec->lrx = (ec->lrxacc + (1 << 4)) >> 5;\r\nec->fir_state.coeffs = ec->fir_taps16[0];\r\necho_value = fir16(&ec->fir_state, tx);\r\nec->clean = rx - echo_value;\r\nec->lcleanacc += abs(ec->clean) - ec->lclean;\r\nec->lclean = (ec->lcleanacc + (1 << 4)) >> 5;\r\necho_value = fir16(&ec->fir_state_bg, tx);\r\nclean_bg = rx - echo_value;\r\nec->lclean_bgacc += abs(clean_bg) - ec->lclean_bg;\r\nec->lclean_bg = (ec->lclean_bgacc + (1 << 4)) >> 5;\r\nec->factor = 0;\r\nec->shift = 0;\r\nif ((ec->nonupdate_dwell == 0)) {\r\nint p, logp, shift;\r\np = MIN_TX_POWER_FOR_ADAPTION + ec->pstates;\r\nlogp = top_bit(p) + ec->log2taps;\r\nshift = 30 - 2 - logp;\r\nec->shift = shift;\r\nlms_adapt_bg(ec, clean_bg, shift);\r\n}\r\nec->adapt = 0;\r\nif ((ec->lrx > MIN_RX_POWER_FOR_ADAPTION) && (ec->lrx > ec->ltx))\r\nec->nonupdate_dwell = DTD_HANGOVER;\r\nif (ec->nonupdate_dwell)\r\nec->nonupdate_dwell--;\r\nif ((ec->adaption_mode & ECHO_CAN_USE_ADAPTION) &&\r\n(ec->nonupdate_dwell == 0) &&\r\n(8 * ec->lclean_bg < 7 * ec->lclean) &&\r\n(8 * ec->lclean_bg < ec->ltx)) {\r\nif (ec->cond_met == 6) {\r\nec->adapt = 1;\r\nmemcpy(ec->fir_taps16[0], ec->fir_taps16[1],\r\nec->taps * sizeof(int16_t));\r\n} else\r\nec->cond_met++;\r\n} else\r\nec->cond_met = 0;\r\nec->clean_nlp = ec->clean;\r\nif (ec->adaption_mode & ECHO_CAN_USE_NLP) {\r\nif ((16 * ec->lclean < ec->ltx)) {\r\nif (ec->adaption_mode & ECHO_CAN_USE_CNG) {\r\nec->cng_level = ec->lbgn;\r\nec->cng_rndnum =\r\n1664525U * ec->cng_rndnum + 1013904223U;\r\nec->cng_filter =\r\n((ec->cng_rndnum & 0xFFFF) - 32768 +\r\n5 * ec->cng_filter) >> 3;\r\nec->clean_nlp =\r\n(ec->cng_filter * ec->cng_level * 8) >> 14;\r\n} else if (ec->adaption_mode & ECHO_CAN_USE_CLIP) {\r\nif (ec->clean_nlp > ec->lbgn)\r\nec->clean_nlp = ec->lbgn;\r\nif (ec->clean_nlp < -ec->lbgn)\r\nec->clean_nlp = -ec->lbgn;\r\n} else {\r\nec->clean_nlp = 0;\r\n}\r\n} else {\r\nif (ec->lclean < 40) {\r\nec->lbgn_acc += abs(ec->clean) - ec->lbgn;\r\nec->lbgn = (ec->lbgn_acc + (1 << 11)) >> 12;\r\n}\r\n}\r\n}\r\nif (ec->curr_pos <= 0)\r\nec->curr_pos = ec->taps;\r\nec->curr_pos--;\r\nif (ec->adaption_mode & ECHO_CAN_DISABLE)\r\nec->clean_nlp = rx;\r\nreturn (int16_t) ec->clean_nlp << 1;\r\n}\r\nint16_t oslec_hpf_tx(struct oslec_state *ec, int16_t tx)\r\n{\r\nint tmp;\r\nint tmp1;\r\nif (ec->adaption_mode & ECHO_CAN_USE_TX_HPF) {\r\ntmp = tx << 15;\r\ntmp -= (tmp >> 4);\r\nec->tx_1 += -(ec->tx_1 >> DC_LOG2BETA) + tmp - ec->tx_2;\r\ntmp1 = ec->tx_1 >> 15;\r\nif (tmp1 > 32767)\r\ntmp1 = 32767;\r\nif (tmp1 < -32767)\r\ntmp1 = -32767;\r\ntx = tmp1;\r\nec->tx_2 = tmp;\r\n}\r\nreturn tx;\r\n}
