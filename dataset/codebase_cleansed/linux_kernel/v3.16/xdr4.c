static inline loff_t\r\ns64_to_loff_t(__s64 offset)\r\n{\r\nreturn (loff_t)offset;\r\n}\r\nstatic inline s64\r\nloff_t_to_s64(loff_t offset)\r\n{\r\ns64 res;\r\nif (offset > NLM4_OFFSET_MAX)\r\nres = NLM4_OFFSET_MAX;\r\nelse if (offset < -NLM4_OFFSET_MAX)\r\nres = -NLM4_OFFSET_MAX;\r\nelse\r\nres = offset;\r\nreturn res;\r\n}\r\nstatic __be32 *\r\nnlm4_decode_cookie(__be32 *p, struct nlm_cookie *c)\r\n{\r\nunsigned int len;\r\nlen = ntohl(*p++);\r\nif(len==0)\r\n{\r\nc->len=4;\r\nmemset(c->data, 0, 4);\r\n}\r\nelse if(len<=NLM_MAXCOOKIELEN)\r\n{\r\nc->len=len;\r\nmemcpy(c->data, p, len);\r\np+=XDR_QUADLEN(len);\r\n}\r\nelse\r\n{\r\ndprintk("lockd: bad cookie size %d (only cookies under "\r\n"%d bytes are supported.)\n",\r\nlen, NLM_MAXCOOKIELEN);\r\nreturn NULL;\r\n}\r\nreturn p;\r\n}\r\nstatic __be32 *\r\nnlm4_encode_cookie(__be32 *p, struct nlm_cookie *c)\r\n{\r\n*p++ = htonl(c->len);\r\nmemcpy(p, c->data, c->len);\r\np+=XDR_QUADLEN(c->len);\r\nreturn p;\r\n}\r\nstatic __be32 *\r\nnlm4_decode_fh(__be32 *p, struct nfs_fh *f)\r\n{\r\nmemset(f->data, 0, sizeof(f->data));\r\nf->size = ntohl(*p++);\r\nif (f->size > NFS_MAXFHSIZE) {\r\ndprintk("lockd: bad fhandle size %d (should be <=%d)\n",\r\nf->size, NFS_MAXFHSIZE);\r\nreturn NULL;\r\n}\r\nmemcpy(f->data, p, f->size);\r\nreturn p + XDR_QUADLEN(f->size);\r\n}\r\nstatic __be32 *\r\nnlm4_decode_oh(__be32 *p, struct xdr_netobj *oh)\r\n{\r\nreturn xdr_decode_netobj(p, oh);\r\n}\r\nstatic __be32 *\r\nnlm4_decode_lock(__be32 *p, struct nlm_lock *lock)\r\n{\r\nstruct file_lock *fl = &lock->fl;\r\n__u64 len, start;\r\n__s64 end;\r\nif (!(p = xdr_decode_string_inplace(p, &lock->caller,\r\n&lock->len, NLM_MAXSTRLEN))\r\n|| !(p = nlm4_decode_fh(p, &lock->fh))\r\n|| !(p = nlm4_decode_oh(p, &lock->oh)))\r\nreturn NULL;\r\nlock->svid = ntohl(*p++);\r\nlocks_init_lock(fl);\r\nfl->fl_owner = current->files;\r\nfl->fl_pid = (pid_t)lock->svid;\r\nfl->fl_flags = FL_POSIX;\r\nfl->fl_type = F_RDLCK;\r\np = xdr_decode_hyper(p, &start);\r\np = xdr_decode_hyper(p, &len);\r\nend = start + len - 1;\r\nfl->fl_start = s64_to_loff_t(start);\r\nif (len == 0 || end < 0)\r\nfl->fl_end = OFFSET_MAX;\r\nelse\r\nfl->fl_end = s64_to_loff_t(end);\r\nreturn p;\r\n}\r\nstatic __be32 *\r\nnlm4_encode_testres(__be32 *p, struct nlm_res *resp)\r\n{\r\ns64 start, len;\r\ndprintk("xdr: before encode_testres (p %p resp %p)\n", p, resp);\r\nif (!(p = nlm4_encode_cookie(p, &resp->cookie)))\r\nreturn NULL;\r\n*p++ = resp->status;\r\nif (resp->status == nlm_lck_denied) {\r\nstruct file_lock *fl = &resp->lock.fl;\r\n*p++ = (fl->fl_type == F_RDLCK)? xdr_zero : xdr_one;\r\n*p++ = htonl(resp->lock.svid);\r\nif (!(p = xdr_encode_netobj(p, &resp->lock.oh)))\r\nreturn NULL;\r\nstart = loff_t_to_s64(fl->fl_start);\r\nif (fl->fl_end == OFFSET_MAX)\r\nlen = 0;\r\nelse\r\nlen = loff_t_to_s64(fl->fl_end - fl->fl_start + 1);\r\np = xdr_encode_hyper(p, start);\r\np = xdr_encode_hyper(p, len);\r\ndprintk("xdr: encode_testres (status %u pid %d type %d start %Ld end %Ld)\n",\r\nresp->status, (int)resp->lock.svid, fl->fl_type,\r\n(long long)fl->fl_start, (long long)fl->fl_end);\r\n}\r\ndprintk("xdr: after encode_testres (p %p resp %p)\n", p, resp);\r\nreturn p;\r\n}\r\nint\r\nnlm4svc_decode_testargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\r\n{\r\nu32 exclusive;\r\nif (!(p = nlm4_decode_cookie(p, &argp->cookie)))\r\nreturn 0;\r\nexclusive = ntohl(*p++);\r\nif (!(p = nlm4_decode_lock(p, &argp->lock)))\r\nreturn 0;\r\nif (exclusive)\r\nargp->lock.fl.fl_type = F_WRLCK;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_encode_testres(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\r\n{\r\nif (!(p = nlm4_encode_testres(p, resp)))\r\nreturn 0;\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_decode_lockargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\r\n{\r\nu32 exclusive;\r\nif (!(p = nlm4_decode_cookie(p, &argp->cookie)))\r\nreturn 0;\r\nargp->block = ntohl(*p++);\r\nexclusive = ntohl(*p++);\r\nif (!(p = nlm4_decode_lock(p, &argp->lock)))\r\nreturn 0;\r\nif (exclusive)\r\nargp->lock.fl.fl_type = F_WRLCK;\r\nargp->reclaim = ntohl(*p++);\r\nargp->state = ntohl(*p++);\r\nargp->monitor = 1;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_decode_cancargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\r\n{\r\nu32 exclusive;\r\nif (!(p = nlm4_decode_cookie(p, &argp->cookie)))\r\nreturn 0;\r\nargp->block = ntohl(*p++);\r\nexclusive = ntohl(*p++);\r\nif (!(p = nlm4_decode_lock(p, &argp->lock)))\r\nreturn 0;\r\nif (exclusive)\r\nargp->lock.fl.fl_type = F_WRLCK;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_decode_unlockargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\r\n{\r\nif (!(p = nlm4_decode_cookie(p, &argp->cookie))\r\n|| !(p = nlm4_decode_lock(p, &argp->lock)))\r\nreturn 0;\r\nargp->lock.fl.fl_type = F_UNLCK;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_decode_shareargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\r\n{\r\nstruct nlm_lock *lock = &argp->lock;\r\nmemset(lock, 0, sizeof(*lock));\r\nlocks_init_lock(&lock->fl);\r\nlock->svid = ~(u32) 0;\r\nlock->fl.fl_pid = (pid_t)lock->svid;\r\nif (!(p = nlm4_decode_cookie(p, &argp->cookie))\r\n|| !(p = xdr_decode_string_inplace(p, &lock->caller,\r\n&lock->len, NLM_MAXSTRLEN))\r\n|| !(p = nlm4_decode_fh(p, &lock->fh))\r\n|| !(p = nlm4_decode_oh(p, &lock->oh)))\r\nreturn 0;\r\nargp->fsm_mode = ntohl(*p++);\r\nargp->fsm_access = ntohl(*p++);\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_encode_shareres(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\r\n{\r\nif (!(p = nlm4_encode_cookie(p, &resp->cookie)))\r\nreturn 0;\r\n*p++ = resp->status;\r\n*p++ = xdr_zero;\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_encode_res(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\r\n{\r\nif (!(p = nlm4_encode_cookie(p, &resp->cookie)))\r\nreturn 0;\r\n*p++ = resp->status;\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_decode_notify(struct svc_rqst *rqstp, __be32 *p, struct nlm_args *argp)\r\n{\r\nstruct nlm_lock *lock = &argp->lock;\r\nif (!(p = xdr_decode_string_inplace(p, &lock->caller,\r\n&lock->len, NLM_MAXSTRLEN)))\r\nreturn 0;\r\nargp->state = ntohl(*p++);\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_decode_reboot(struct svc_rqst *rqstp, __be32 *p, struct nlm_reboot *argp)\r\n{\r\nif (!(p = xdr_decode_string_inplace(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))\r\nreturn 0;\r\nargp->state = ntohl(*p++);\r\nmemcpy(&argp->priv.data, p, sizeof(argp->priv.data));\r\np += XDR_QUADLEN(SM_PRIV_SIZE);\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_decode_res(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\r\n{\r\nif (!(p = nlm4_decode_cookie(p, &resp->cookie)))\r\nreturn 0;\r\nresp->status = *p++;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\r\n{\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnlm4svc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\r\n{\r\nreturn xdr_ressize_check(rqstp, p);\r\n}
