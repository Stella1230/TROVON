static int\r\ndasd_ioctl_api_version(void __user *argp)\r\n{\r\nint ver = DASD_API_VERSION;\r\nreturn put_user(ver, (int __user *)argp);\r\n}\r\nstatic int\r\ndasd_ioctl_enable(struct block_device *bdev)\r\n{\r\nstruct dasd_device *base;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nbase = dasd_device_from_gendisk(bdev->bd_disk);\r\nif (!base)\r\nreturn -ENODEV;\r\ndasd_enable_device(base);\r\nmutex_lock(&bdev->bd_mutex);\r\ni_size_write(bdev->bd_inode,\r\n(loff_t)get_capacity(base->block->gdp) << 9);\r\nmutex_unlock(&bdev->bd_mutex);\r\ndasd_put_device(base);\r\nreturn 0;\r\n}\r\nstatic int\r\ndasd_ioctl_disable(struct block_device *bdev)\r\n{\r\nstruct dasd_device *base;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nbase = dasd_device_from_gendisk(bdev->bd_disk);\r\nif (!base)\r\nreturn -ENODEV;\r\ndasd_set_target_state(base, DASD_STATE_BASIC);\r\nmutex_lock(&bdev->bd_mutex);\r\ni_size_write(bdev->bd_inode, 0);\r\nmutex_unlock(&bdev->bd_mutex);\r\ndasd_put_device(base);\r\nreturn 0;\r\n}\r\nstatic int dasd_ioctl_quiesce(struct dasd_block *block)\r\n{\r\nunsigned long flags;\r\nstruct dasd_device *base;\r\nbase = block->base;\r\nif (!capable (CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\npr_info("%s: The DASD has been put in the quiesce "\r\n"state\n", dev_name(&base->cdev->dev));\r\nspin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);\r\ndasd_device_set_stop_bits(base, DASD_STOPPED_QUIESCE);\r\nspin_unlock_irqrestore(get_ccwdev_lock(base->cdev), flags);\r\nreturn 0;\r\n}\r\nstatic int dasd_ioctl_resume(struct dasd_block *block)\r\n{\r\nunsigned long flags;\r\nstruct dasd_device *base;\r\nbase = block->base;\r\nif (!capable (CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\npr_info("%s: I/O operations have been resumed "\r\n"on the DASD\n", dev_name(&base->cdev->dev));\r\nspin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);\r\ndasd_device_remove_stop_bits(base, DASD_STOPPED_QUIESCE);\r\nspin_unlock_irqrestore(get_ccwdev_lock(base->cdev), flags);\r\ndasd_schedule_block_bh(block);\r\nreturn 0;\r\n}\r\nstatic int dasd_ioctl_abortio(struct dasd_block *block)\r\n{\r\nunsigned long flags;\r\nstruct dasd_device *base;\r\nstruct dasd_ccw_req *cqr, *n;\r\nbase = block->base;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (test_and_set_bit(DASD_FLAG_ABORTALL, &base->flags))\r\nreturn 0;\r\nDBF_DEV_EVENT(DBF_NOTICE, base, "%s", "abortall flag set");\r\nspin_lock_irqsave(&block->request_queue_lock, flags);\r\nspin_lock(&block->queue_lock);\r\nlist_for_each_entry_safe(cqr, n, &block->ccw_queue, blocklist) {\r\nif (test_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&\r\ncqr->callback_data &&\r\ncqr->callback_data != DASD_SLEEPON_START_TAG &&\r\ncqr->callback_data != DASD_SLEEPON_END_TAG) {\r\nspin_unlock(&block->queue_lock);\r\nblk_abort_request(cqr->callback_data);\r\nspin_lock(&block->queue_lock);\r\n}\r\n}\r\nspin_unlock(&block->queue_lock);\r\nspin_unlock_irqrestore(&block->request_queue_lock, flags);\r\ndasd_schedule_block_bh(block);\r\nreturn 0;\r\n}\r\nstatic int dasd_ioctl_allowio(struct dasd_block *block)\r\n{\r\nstruct dasd_device *base;\r\nbase = block->base;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (test_and_clear_bit(DASD_FLAG_ABORTALL, &base->flags))\r\nDBF_DEV_EVENT(DBF_NOTICE, base, "%s", "abortall flag unset");\r\nreturn 0;\r\n}\r\nstatic int\r\ndasd_format(struct dasd_block *block, struct format_data_t *fdata)\r\n{\r\nstruct dasd_device *base;\r\nint rc;\r\nbase = block->base;\r\nif (base->discipline->format_device == NULL)\r\nreturn -EPERM;\r\nif (base->state != DASD_STATE_BASIC) {\r\npr_warn("%s: The DASD cannot be formatted while it is enabled\n",\r\ndev_name(&base->cdev->dev));\r\nreturn -EBUSY;\r\n}\r\nDBF_DEV_EVENT(DBF_NOTICE, base,\r\n"formatting units %u to %u (%u B blocks) flags %u",\r\nfdata->start_unit,\r\nfdata->stop_unit, fdata->blksize, fdata->intensity);\r\nif (fdata->start_unit == 0) {\r\nstruct block_device *bdev = bdget_disk(block->gdp, 0);\r\nbdev->bd_inode->i_blkbits = blksize_bits(fdata->blksize);\r\nbdput(bdev);\r\n}\r\nrc = base->discipline->format_device(base, fdata);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int\r\ndasd_ioctl_format(struct block_device *bdev, void __user *argp)\r\n{\r\nstruct dasd_device *base;\r\nstruct format_data_t fdata;\r\nint rc;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (!argp)\r\nreturn -EINVAL;\r\nbase = dasd_device_from_gendisk(bdev->bd_disk);\r\nif (!base)\r\nreturn -ENODEV;\r\nif (base->features & DASD_FEATURE_READONLY ||\r\ntest_bit(DASD_FLAG_DEVICE_RO, &base->flags)) {\r\ndasd_put_device(base);\r\nreturn -EROFS;\r\n}\r\nif (copy_from_user(&fdata, argp, sizeof(struct format_data_t))) {\r\ndasd_put_device(base);\r\nreturn -EFAULT;\r\n}\r\nif (bdev != bdev->bd_contains) {\r\npr_warning("%s: The specified DASD is a partition and cannot "\r\n"be formatted\n",\r\ndev_name(&base->cdev->dev));\r\ndasd_put_device(base);\r\nreturn -EINVAL;\r\n}\r\nrc = dasd_format(base->block, &fdata);\r\ndasd_put_device(base);\r\nreturn rc;\r\n}\r\nstatic int dasd_ioctl_reset_profile(struct dasd_block *block)\r\n{\r\ndasd_profile_reset(&block->profile);\r\nreturn 0;\r\n}\r\nstatic int dasd_ioctl_read_profile(struct dasd_block *block, void __user *argp)\r\n{\r\nstruct dasd_profile_info_t *data;\r\nint rc = 0;\r\ndata = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspin_lock_bh(&block->profile.lock);\r\nif (block->profile.data) {\r\ndata->dasd_io_reqs = block->profile.data->dasd_io_reqs;\r\ndata->dasd_io_sects = block->profile.data->dasd_io_sects;\r\nmemcpy(data->dasd_io_secs, block->profile.data->dasd_io_secs,\r\nsizeof(data->dasd_io_secs));\r\nmemcpy(data->dasd_io_times, block->profile.data->dasd_io_times,\r\nsizeof(data->dasd_io_times));\r\nmemcpy(data->dasd_io_timps, block->profile.data->dasd_io_timps,\r\nsizeof(data->dasd_io_timps));\r\nmemcpy(data->dasd_io_time1, block->profile.data->dasd_io_time1,\r\nsizeof(data->dasd_io_time1));\r\nmemcpy(data->dasd_io_time2, block->profile.data->dasd_io_time2,\r\nsizeof(data->dasd_io_time2));\r\nmemcpy(data->dasd_io_time2ps,\r\nblock->profile.data->dasd_io_time2ps,\r\nsizeof(data->dasd_io_time2ps));\r\nmemcpy(data->dasd_io_time3, block->profile.data->dasd_io_time3,\r\nsizeof(data->dasd_io_time3));\r\nmemcpy(data->dasd_io_nr_req,\r\nblock->profile.data->dasd_io_nr_req,\r\nsizeof(data->dasd_io_nr_req));\r\nspin_unlock_bh(&block->profile.lock);\r\n} else {\r\nspin_unlock_bh(&block->profile.lock);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nif (copy_to_user(argp, data, sizeof(*data)))\r\nrc = -EFAULT;\r\nout:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic int dasd_ioctl_reset_profile(struct dasd_block *block)\r\n{\r\nreturn -ENOTTY;\r\n}\r\nstatic int dasd_ioctl_read_profile(struct dasd_block *block, void __user *argp)\r\n{\r\nreturn -ENOTTY;\r\n}\r\nstatic int dasd_ioctl_information(struct dasd_block *block,\r\nunsigned int cmd, void __user *argp)\r\n{\r\nstruct dasd_information2_t *dasd_info;\r\nstruct subchannel_id sch_id;\r\nstruct ccw_dev_id dev_id;\r\nstruct dasd_device *base;\r\nstruct ccw_device *cdev;\r\nunsigned long flags;\r\nint rc;\r\nbase = block->base;\r\nif (!base->discipline || !base->discipline->fill_info)\r\nreturn -EINVAL;\r\ndasd_info = kzalloc(sizeof(struct dasd_information2_t), GFP_KERNEL);\r\nif (dasd_info == NULL)\r\nreturn -ENOMEM;\r\nrc = base->discipline->fill_info(base, dasd_info);\r\nif (rc) {\r\nkfree(dasd_info);\r\nreturn rc;\r\n}\r\ncdev = base->cdev;\r\nccw_device_get_id(cdev, &dev_id);\r\nccw_device_get_schid(cdev, &sch_id);\r\ndasd_info->devno = dev_id.devno;\r\ndasd_info->schid = sch_id.sch_no;\r\ndasd_info->cu_type = cdev->id.cu_type;\r\ndasd_info->cu_model = cdev->id.cu_model;\r\ndasd_info->dev_type = cdev->id.dev_type;\r\ndasd_info->dev_model = cdev->id.dev_model;\r\ndasd_info->status = base->state;\r\ndasd_info->open_count = atomic_read(&block->open_count);\r\nif (!block->bdev)\r\ndasd_info->open_count++;\r\nif ((base->state < DASD_STATE_READY) ||\r\n(dasd_check_blocksize(block->bp_block)))\r\ndasd_info->format = DASD_FORMAT_NONE;\r\ndasd_info->features |=\r\n((base->features & DASD_FEATURE_READONLY) != 0);\r\nmemcpy(dasd_info->type, base->discipline->name, 4);\r\nif (block->request_queue->request_fn) {\r\nstruct list_head *l;\r\n#ifdef DASD_EXTENDED_PROFILING\r\n{\r\nstruct list_head *l;\r\nspin_lock_irqsave(&block->lock, flags);\r\nlist_for_each(l, &block->request_queue->queue_head)\r\ndasd_info->req_queue_len++;\r\nspin_unlock_irqrestore(&block->lock, flags);\r\n}\r\n#endif\r\nspin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);\r\nlist_for_each(l, &base->ccw_queue)\r\ndasd_info->chanq_len++;\r\nspin_unlock_irqrestore(get_ccwdev_lock(base->cdev),\r\nflags);\r\n}\r\nrc = 0;\r\nif (copy_to_user(argp, dasd_info,\r\n((cmd == (unsigned int) BIODASDINFO2) ?\r\nsizeof(struct dasd_information2_t) :\r\nsizeof(struct dasd_information_t))))\r\nrc = -EFAULT;\r\nkfree(dasd_info);\r\nreturn rc;\r\n}\r\nstatic int\r\ndasd_ioctl_set_ro(struct block_device *bdev, void __user *argp)\r\n{\r\nstruct dasd_device *base;\r\nint intval, rc;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (bdev != bdev->bd_contains)\r\nreturn -EINVAL;\r\nif (get_user(intval, (int __user *)argp))\r\nreturn -EFAULT;\r\nbase = dasd_device_from_gendisk(bdev->bd_disk);\r\nif (!base)\r\nreturn -ENODEV;\r\nif (!intval && test_bit(DASD_FLAG_DEVICE_RO, &base->flags)) {\r\ndasd_put_device(base);\r\nreturn -EROFS;\r\n}\r\nset_disk_ro(bdev->bd_disk, intval);\r\nrc = dasd_set_feature(base->cdev, DASD_FEATURE_READONLY, intval);\r\ndasd_put_device(base);\r\nreturn rc;\r\n}\r\nstatic int dasd_ioctl_readall_cmb(struct dasd_block *block, unsigned int cmd,\r\nstruct cmbdata __user *argp)\r\n{\r\nsize_t size = _IOC_SIZE(cmd);\r\nstruct cmbdata data;\r\nint ret;\r\nret = cmf_readall(block->base->cdev, &data);\r\nif (!ret && copy_to_user(argp, &data, min(size, sizeof(*argp))))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nint dasd_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct dasd_block *block;\r\nstruct dasd_device *base;\r\nvoid __user *argp;\r\nint rc;\r\nif (is_compat_task())\r\nargp = compat_ptr(arg);\r\nelse\r\nargp = (void __user *)arg;\r\nif ((_IOC_DIR(cmd) != _IOC_NONE) && !arg) {\r\nPRINT_DEBUG("empty data ptr");\r\nreturn -EINVAL;\r\n}\r\nbase = dasd_device_from_gendisk(bdev->bd_disk);\r\nif (!base)\r\nreturn -ENODEV;\r\nblock = base->block;\r\nrc = 0;\r\nswitch (cmd) {\r\ncase BIODASDDISABLE:\r\nrc = dasd_ioctl_disable(bdev);\r\nbreak;\r\ncase BIODASDENABLE:\r\nrc = dasd_ioctl_enable(bdev);\r\nbreak;\r\ncase BIODASDQUIESCE:\r\nrc = dasd_ioctl_quiesce(block);\r\nbreak;\r\ncase BIODASDRESUME:\r\nrc = dasd_ioctl_resume(block);\r\nbreak;\r\ncase BIODASDABORTIO:\r\nrc = dasd_ioctl_abortio(block);\r\nbreak;\r\ncase BIODASDALLOWIO:\r\nrc = dasd_ioctl_allowio(block);\r\nbreak;\r\ncase BIODASDFMT:\r\nrc = dasd_ioctl_format(bdev, argp);\r\nbreak;\r\ncase BIODASDINFO:\r\nrc = dasd_ioctl_information(block, cmd, argp);\r\nbreak;\r\ncase BIODASDINFO2:\r\nrc = dasd_ioctl_information(block, cmd, argp);\r\nbreak;\r\ncase BIODASDPRRD:\r\nrc = dasd_ioctl_read_profile(block, argp);\r\nbreak;\r\ncase BIODASDPRRST:\r\nrc = dasd_ioctl_reset_profile(block);\r\nbreak;\r\ncase BLKROSET:\r\nrc = dasd_ioctl_set_ro(bdev, argp);\r\nbreak;\r\ncase DASDAPIVER:\r\nrc = dasd_ioctl_api_version(argp);\r\nbreak;\r\ncase BIODASDCMFENABLE:\r\nrc = enable_cmf(base->cdev);\r\nbreak;\r\ncase BIODASDCMFDISABLE:\r\nrc = disable_cmf(base->cdev);\r\nbreak;\r\ncase BIODASDREADALLCMB:\r\nrc = dasd_ioctl_readall_cmb(block, cmd, argp);\r\nbreak;\r\ndefault:\r\nrc = -ENOTTY;\r\nif (base->discipline->ioctl)\r\nrc = base->discipline->ioctl(block, cmd, argp);\r\n}\r\ndasd_put_device(base);\r\nreturn rc;\r\n}
