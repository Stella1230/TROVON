static void\r\ntrigger_data_free(struct event_trigger_data *data)\r\n{\r\nif (data->cmd_ops->set_filter)\r\ndata->cmd_ops->set_filter(NULL, data, NULL);\r\nsynchronize_sched();\r\nkfree(data);\r\n}\r\nenum event_trigger_type\r\nevent_triggers_call(struct ftrace_event_file *file, void *rec)\r\n{\r\nstruct event_trigger_data *data;\r\nenum event_trigger_type tt = ETT_NONE;\r\nstruct event_filter *filter;\r\nif (list_empty(&file->triggers))\r\nreturn tt;\r\nlist_for_each_entry_rcu(data, &file->triggers, list) {\r\nif (!rec) {\r\ndata->ops->func(data);\r\ncontinue;\r\n}\r\nfilter = rcu_dereference_sched(data->filter);\r\nif (filter && !filter_match_preds(filter, rec))\r\ncontinue;\r\nif (data->cmd_ops->post_trigger) {\r\ntt |= data->cmd_ops->trigger_type;\r\ncontinue;\r\n}\r\ndata->ops->func(data);\r\n}\r\nreturn tt;\r\n}\r\nvoid\r\nevent_triggers_post_call(struct ftrace_event_file *file,\r\nenum event_trigger_type tt)\r\n{\r\nstruct event_trigger_data *data;\r\nlist_for_each_entry_rcu(data, &file->triggers, list) {\r\nif (data->cmd_ops->trigger_type & tt)\r\ndata->ops->func(data);\r\n}\r\n}\r\nstatic void *trigger_next(struct seq_file *m, void *t, loff_t *pos)\r\n{\r\nstruct ftrace_event_file *event_file = event_file_data(m->private);\r\nif (t == SHOW_AVAILABLE_TRIGGERS)\r\nreturn NULL;\r\nreturn seq_list_next(t, &event_file->triggers, pos);\r\n}\r\nstatic void *trigger_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct ftrace_event_file *event_file;\r\nmutex_lock(&event_mutex);\r\nevent_file = event_file_data(m->private);\r\nif (unlikely(!event_file))\r\nreturn ERR_PTR(-ENODEV);\r\nif (list_empty(&event_file->triggers))\r\nreturn *pos == 0 ? SHOW_AVAILABLE_TRIGGERS : NULL;\r\nreturn seq_list_start(&event_file->triggers, *pos);\r\n}\r\nstatic void trigger_stop(struct seq_file *m, void *t)\r\n{\r\nmutex_unlock(&event_mutex);\r\n}\r\nstatic int trigger_show(struct seq_file *m, void *v)\r\n{\r\nstruct event_trigger_data *data;\r\nstruct event_command *p;\r\nif (v == SHOW_AVAILABLE_TRIGGERS) {\r\nseq_puts(m, "# Available triggers:\n");\r\nseq_putc(m, '#');\r\nmutex_lock(&trigger_cmd_mutex);\r\nlist_for_each_entry_reverse(p, &trigger_commands, list)\r\nseq_printf(m, " %s", p->name);\r\nseq_putc(m, '\n');\r\nmutex_unlock(&trigger_cmd_mutex);\r\nreturn 0;\r\n}\r\ndata = list_entry(v, struct event_trigger_data, list);\r\ndata->ops->print(m, data->ops, data);\r\nreturn 0;\r\n}\r\nstatic int event_trigger_regex_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = 0;\r\nmutex_lock(&event_mutex);\r\nif (unlikely(!event_file_data(file))) {\r\nmutex_unlock(&event_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (file->f_mode & FMODE_READ) {\r\nret = seq_open(file, &event_triggers_seq_ops);\r\nif (!ret) {\r\nstruct seq_file *m = file->private_data;\r\nm->private = file;\r\n}\r\n}\r\nmutex_unlock(&event_mutex);\r\nreturn ret;\r\n}\r\nstatic int trigger_process_regex(struct ftrace_event_file *file, char *buff)\r\n{\r\nchar *command, *next = buff;\r\nstruct event_command *p;\r\nint ret = -EINVAL;\r\ncommand = strsep(&next, ": \t");\r\ncommand = (command[0] != '!') ? command : command + 1;\r\nmutex_lock(&trigger_cmd_mutex);\r\nlist_for_each_entry(p, &trigger_commands, list) {\r\nif (strcmp(p->name, command) == 0) {\r\nret = p->func(p, file, buff, command, next);\r\ngoto out_unlock;\r\n}\r\n}\r\nout_unlock:\r\nmutex_unlock(&trigger_cmd_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t event_trigger_regex_write(struct file *file,\r\nconst char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nstruct ftrace_event_file *event_file;\r\nssize_t ret;\r\nchar *buf;\r\nif (!cnt)\r\nreturn 0;\r\nif (cnt >= PAGE_SIZE)\r\nreturn -EINVAL;\r\nbuf = (char *)__get_free_page(GFP_TEMPORARY);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buf, ubuf, cnt)) {\r\nfree_page((unsigned long)buf);\r\nreturn -EFAULT;\r\n}\r\nbuf[cnt] = '\0';\r\nstrim(buf);\r\nmutex_lock(&event_mutex);\r\nevent_file = event_file_data(file);\r\nif (unlikely(!event_file)) {\r\nmutex_unlock(&event_mutex);\r\nfree_page((unsigned long)buf);\r\nreturn -ENODEV;\r\n}\r\nret = trigger_process_regex(event_file, buf);\r\nmutex_unlock(&event_mutex);\r\nfree_page((unsigned long)buf);\r\nif (ret < 0)\r\ngoto out;\r\n*ppos += cnt;\r\nret = cnt;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int event_trigger_regex_release(struct inode *inode, struct file *file)\r\n{\r\nmutex_lock(&event_mutex);\r\nif (file->f_mode & FMODE_READ)\r\nseq_release(inode, file);\r\nmutex_unlock(&event_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nevent_trigger_write(struct file *filp, const char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nreturn event_trigger_regex_write(filp, ubuf, cnt, ppos);\r\n}\r\nstatic int\r\nevent_trigger_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn event_trigger_regex_open(inode, filp);\r\n}\r\nstatic int\r\nevent_trigger_release(struct inode *inode, struct file *file)\r\n{\r\nreturn event_trigger_regex_release(inode, file);\r\n}\r\nstatic __init int register_event_command(struct event_command *cmd)\r\n{\r\nstruct event_command *p;\r\nint ret = 0;\r\nmutex_lock(&trigger_cmd_mutex);\r\nlist_for_each_entry(p, &trigger_commands, list) {\r\nif (strcmp(cmd->name, p->name) == 0) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\n}\r\nlist_add(&cmd->list, &trigger_commands);\r\nout_unlock:\r\nmutex_unlock(&trigger_cmd_mutex);\r\nreturn ret;\r\n}\r\nstatic __init int unregister_event_command(struct event_command *cmd)\r\n{\r\nstruct event_command *p, *n;\r\nint ret = -ENODEV;\r\nmutex_lock(&trigger_cmd_mutex);\r\nlist_for_each_entry_safe(p, n, &trigger_commands, list) {\r\nif (strcmp(cmd->name, p->name) == 0) {\r\nret = 0;\r\nlist_del_init(&p->list);\r\ngoto out_unlock;\r\n}\r\n}\r\nout_unlock:\r\nmutex_unlock(&trigger_cmd_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nevent_trigger_print(const char *name, struct seq_file *m,\r\nvoid *data, char *filter_str)\r\n{\r\nlong count = (long)data;\r\nseq_printf(m, "%s", name);\r\nif (count == -1)\r\nseq_puts(m, ":unlimited");\r\nelse\r\nseq_printf(m, ":count=%ld", count);\r\nif (filter_str)\r\nseq_printf(m, " if %s\n", filter_str);\r\nelse\r\nseq_puts(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nevent_trigger_init(struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\ndata->ref++;\r\nreturn 0;\r\n}\r\nstatic void\r\nevent_trigger_free(struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nif (WARN_ON_ONCE(data->ref <= 0))\r\nreturn;\r\ndata->ref--;\r\nif (!data->ref)\r\ntrigger_data_free(data);\r\n}\r\nstatic int trace_event_trigger_enable_disable(struct ftrace_event_file *file,\r\nint trigger_enable)\r\n{\r\nint ret = 0;\r\nif (trigger_enable) {\r\nif (atomic_inc_return(&file->tm_ref) > 1)\r\nreturn ret;\r\nset_bit(FTRACE_EVENT_FL_TRIGGER_MODE_BIT, &file->flags);\r\nret = trace_event_enable_disable(file, 1, 1);\r\n} else {\r\nif (atomic_dec_return(&file->tm_ref) > 0)\r\nreturn ret;\r\nclear_bit(FTRACE_EVENT_FL_TRIGGER_MODE_BIT, &file->flags);\r\nret = trace_event_enable_disable(file, 0, 1);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nclear_event_triggers(struct trace_array *tr)\r\n{\r\nstruct ftrace_event_file *file;\r\nlist_for_each_entry(file, &tr->events, list) {\r\nstruct event_trigger_data *data;\r\nlist_for_each_entry_rcu(data, &file->triggers, list) {\r\ntrace_event_trigger_enable_disable(file, 0);\r\nif (data->ops->free)\r\ndata->ops->free(data->ops, data);\r\n}\r\n}\r\n}\r\nstatic void update_cond_flag(struct ftrace_event_file *file)\r\n{\r\nstruct event_trigger_data *data;\r\nbool set_cond = false;\r\nlist_for_each_entry_rcu(data, &file->triggers, list) {\r\nif (data->filter || data->cmd_ops->post_trigger) {\r\nset_cond = true;\r\nbreak;\r\n}\r\n}\r\nif (set_cond)\r\nset_bit(FTRACE_EVENT_FL_TRIGGER_COND_BIT, &file->flags);\r\nelse\r\nclear_bit(FTRACE_EVENT_FL_TRIGGER_COND_BIT, &file->flags);\r\n}\r\nstatic int register_trigger(char *glob, struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data,\r\nstruct ftrace_event_file *file)\r\n{\r\nstruct event_trigger_data *test;\r\nint ret = 0;\r\nlist_for_each_entry_rcu(test, &file->triggers, list) {\r\nif (test->cmd_ops->trigger_type == data->cmd_ops->trigger_type) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nif (data->ops->init) {\r\nret = data->ops->init(data->ops, data);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nlist_add_rcu(&data->list, &file->triggers);\r\nret++;\r\nif (trace_event_trigger_enable_disable(file, 1) < 0) {\r\nlist_del_rcu(&data->list);\r\nret--;\r\n}\r\nupdate_cond_flag(file);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void unregister_trigger(char *glob, struct event_trigger_ops *ops,\r\nstruct event_trigger_data *test,\r\nstruct ftrace_event_file *file)\r\n{\r\nstruct event_trigger_data *data;\r\nbool unregistered = false;\r\nlist_for_each_entry_rcu(data, &file->triggers, list) {\r\nif (data->cmd_ops->trigger_type == test->cmd_ops->trigger_type) {\r\nunregistered = true;\r\nlist_del_rcu(&data->list);\r\nupdate_cond_flag(file);\r\ntrace_event_trigger_enable_disable(file, 0);\r\nbreak;\r\n}\r\n}\r\nif (unregistered && data->ops->free)\r\ndata->ops->free(data->ops, data);\r\n}\r\nstatic int\r\nevent_trigger_callback(struct event_command *cmd_ops,\r\nstruct ftrace_event_file *file,\r\nchar *glob, char *cmd, char *param)\r\n{\r\nstruct event_trigger_data *trigger_data;\r\nstruct event_trigger_ops *trigger_ops;\r\nchar *trigger = NULL;\r\nchar *number;\r\nint ret;\r\nif (param && isdigit(param[0]))\r\ntrigger = strsep(&param, " \t");\r\ntrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\r\nret = -ENOMEM;\r\ntrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\r\nif (!trigger_data)\r\ngoto out;\r\ntrigger_data->count = -1;\r\ntrigger_data->ops = trigger_ops;\r\ntrigger_data->cmd_ops = cmd_ops;\r\nINIT_LIST_HEAD(&trigger_data->list);\r\nif (glob[0] == '!') {\r\ncmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\r\nkfree(trigger_data);\r\nret = 0;\r\ngoto out;\r\n}\r\nif (trigger) {\r\nnumber = strsep(&trigger, ":");\r\nret = -EINVAL;\r\nif (!strlen(number))\r\ngoto out_free;\r\nret = kstrtoul(number, 0, &trigger_data->count);\r\nif (ret)\r\ngoto out_free;\r\n}\r\nif (!param)\r\ngoto out_reg;\r\nif (!cmd_ops->set_filter)\r\ngoto out_reg;\r\nret = cmd_ops->set_filter(param, trigger_data, file);\r\nif (ret < 0)\r\ngoto out_free;\r\nout_reg:\r\nret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\r\nif (!ret) {\r\nret = -ENOENT;\r\ngoto out_free;\r\n} else if (ret < 0)\r\ngoto out_free;\r\nret = 0;\r\nout:\r\nreturn ret;\r\nout_free:\r\nif (cmd_ops->set_filter)\r\ncmd_ops->set_filter(NULL, trigger_data, NULL);\r\nkfree(trigger_data);\r\ngoto out;\r\n}\r\nstatic int set_trigger_filter(char *filter_str,\r\nstruct event_trigger_data *trigger_data,\r\nstruct ftrace_event_file *file)\r\n{\r\nstruct event_trigger_data *data = trigger_data;\r\nstruct event_filter *filter = NULL, *tmp;\r\nint ret = -EINVAL;\r\nchar *s;\r\nif (!filter_str)\r\ngoto assign;\r\ns = strsep(&filter_str, " \t");\r\nif (!strlen(s) || strcmp(s, "if") != 0)\r\ngoto out;\r\nif (!filter_str)\r\ngoto out;\r\nret = create_event_filter(file->event_call, filter_str, false, &filter);\r\nif (ret)\r\ngoto out;\r\nassign:\r\ntmp = rcu_access_pointer(data->filter);\r\nrcu_assign_pointer(data->filter, filter);\r\nif (tmp) {\r\nsynchronize_sched();\r\nfree_event_filter(tmp);\r\n}\r\nkfree(data->filter_str);\r\ndata->filter_str = NULL;\r\nif (filter_str) {\r\ndata->filter_str = kstrdup(filter_str, GFP_KERNEL);\r\nif (!data->filter_str) {\r\nfree_event_filter(rcu_access_pointer(data->filter));\r\ndata->filter = NULL;\r\nret = -ENOMEM;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void\r\ntraceon_trigger(struct event_trigger_data *data)\r\n{\r\nif (tracing_is_on())\r\nreturn;\r\ntracing_on();\r\n}\r\nstatic void\r\ntraceon_count_trigger(struct event_trigger_data *data)\r\n{\r\nif (tracing_is_on())\r\nreturn;\r\nif (!data->count)\r\nreturn;\r\nif (data->count != -1)\r\n(data->count)--;\r\ntracing_on();\r\n}\r\nstatic void\r\ntraceoff_trigger(struct event_trigger_data *data)\r\n{\r\nif (!tracing_is_on())\r\nreturn;\r\ntracing_off();\r\n}\r\nstatic void\r\ntraceoff_count_trigger(struct event_trigger_data *data)\r\n{\r\nif (!tracing_is_on())\r\nreturn;\r\nif (!data->count)\r\nreturn;\r\nif (data->count != -1)\r\n(data->count)--;\r\ntracing_off();\r\n}\r\nstatic int\r\ntraceon_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nreturn event_trigger_print("traceon", m, (void *)data->count,\r\ndata->filter_str);\r\n}\r\nstatic int\r\ntraceoff_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nreturn event_trigger_print("traceoff", m, (void *)data->count,\r\ndata->filter_str);\r\n}\r\nstatic struct event_trigger_ops *\r\nonoff_get_trigger_ops(char *cmd, char *param)\r\n{\r\nstruct event_trigger_ops *ops;\r\nif (strcmp(cmd, "traceon") == 0)\r\nops = param ? &traceon_count_trigger_ops :\r\n&traceon_trigger_ops;\r\nelse\r\nops = param ? &traceoff_count_trigger_ops :\r\n&traceoff_trigger_ops;\r\nreturn ops;\r\n}\r\nstatic void\r\nsnapshot_trigger(struct event_trigger_data *data)\r\n{\r\ntracing_snapshot();\r\n}\r\nstatic void\r\nsnapshot_count_trigger(struct event_trigger_data *data)\r\n{\r\nif (!data->count)\r\nreturn;\r\nif (data->count != -1)\r\n(data->count)--;\r\nsnapshot_trigger(data);\r\n}\r\nstatic int\r\nregister_snapshot_trigger(char *glob, struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data,\r\nstruct ftrace_event_file *file)\r\n{\r\nint ret = register_trigger(glob, ops, data, file);\r\nif (ret > 0 && tracing_alloc_snapshot() != 0) {\r\nunregister_trigger(glob, ops, data, file);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nsnapshot_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nreturn event_trigger_print("snapshot", m, (void *)data->count,\r\ndata->filter_str);\r\n}\r\nstatic struct event_trigger_ops *\r\nsnapshot_get_trigger_ops(char *cmd, char *param)\r\n{\r\nreturn param ? &snapshot_count_trigger_ops : &snapshot_trigger_ops;\r\n}\r\nstatic __init int register_trigger_snapshot_cmd(void)\r\n{\r\nint ret;\r\nret = register_event_command(&trigger_snapshot_cmd);\r\nWARN_ON(ret < 0);\r\nreturn ret;\r\n}\r\nstatic __init int register_trigger_snapshot_cmd(void) { return 0; }\r\nstatic void\r\nstacktrace_trigger(struct event_trigger_data *data)\r\n{\r\ntrace_dump_stack(STACK_SKIP);\r\n}\r\nstatic void\r\nstacktrace_count_trigger(struct event_trigger_data *data)\r\n{\r\nif (!data->count)\r\nreturn;\r\nif (data->count != -1)\r\n(data->count)--;\r\nstacktrace_trigger(data);\r\n}\r\nstatic int\r\nstacktrace_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nreturn event_trigger_print("stacktrace", m, (void *)data->count,\r\ndata->filter_str);\r\n}\r\nstatic struct event_trigger_ops *\r\nstacktrace_get_trigger_ops(char *cmd, char *param)\r\n{\r\nreturn param ? &stacktrace_count_trigger_ops : &stacktrace_trigger_ops;\r\n}\r\nstatic __init int register_trigger_stacktrace_cmd(void)\r\n{\r\nint ret;\r\nret = register_event_command(&trigger_stacktrace_cmd);\r\nWARN_ON(ret < 0);\r\nreturn ret;\r\n}\r\nstatic __init int register_trigger_stacktrace_cmd(void) { return 0; }\r\nstatic __init void unregister_trigger_traceon_traceoff_cmds(void)\r\n{\r\nunregister_event_command(&trigger_traceon_cmd);\r\nunregister_event_command(&trigger_traceoff_cmd);\r\n}\r\nstatic void\r\nevent_enable_trigger(struct event_trigger_data *data)\r\n{\r\nstruct enable_trigger_data *enable_data = data->private_data;\r\nif (enable_data->enable)\r\nclear_bit(FTRACE_EVENT_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\r\nelse\r\nset_bit(FTRACE_EVENT_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\r\n}\r\nstatic void\r\nevent_enable_count_trigger(struct event_trigger_data *data)\r\n{\r\nstruct enable_trigger_data *enable_data = data->private_data;\r\nif (!data->count)\r\nreturn;\r\nif (enable_data->enable == !(enable_data->file->flags & FTRACE_EVENT_FL_SOFT_DISABLED))\r\nreturn;\r\nif (data->count != -1)\r\n(data->count)--;\r\nevent_enable_trigger(data);\r\n}\r\nstatic int\r\nevent_enable_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nstruct enable_trigger_data *enable_data = data->private_data;\r\nseq_printf(m, "%s:%s:%s",\r\nenable_data->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR,\r\nenable_data->file->event_call->class->system,\r\nftrace_event_name(enable_data->file->event_call));\r\nif (data->count == -1)\r\nseq_puts(m, ":unlimited");\r\nelse\r\nseq_printf(m, ":count=%ld", data->count);\r\nif (data->filter_str)\r\nseq_printf(m, " if %s\n", data->filter_str);\r\nelse\r\nseq_puts(m, "\n");\r\nreturn 0;\r\n}\r\nstatic void\r\nevent_enable_trigger_free(struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nstruct enable_trigger_data *enable_data = data->private_data;\r\nif (WARN_ON_ONCE(data->ref <= 0))\r\nreturn;\r\ndata->ref--;\r\nif (!data->ref) {\r\ntrace_event_enable_disable(enable_data->file, 0, 1);\r\nmodule_put(enable_data->file->event_call->mod);\r\ntrigger_data_free(data);\r\nkfree(enable_data);\r\n}\r\n}\r\nstatic int\r\nevent_enable_trigger_func(struct event_command *cmd_ops,\r\nstruct ftrace_event_file *file,\r\nchar *glob, char *cmd, char *param)\r\n{\r\nstruct ftrace_event_file *event_enable_file;\r\nstruct enable_trigger_data *enable_data;\r\nstruct event_trigger_data *trigger_data;\r\nstruct event_trigger_ops *trigger_ops;\r\nstruct trace_array *tr = file->tr;\r\nconst char *system;\r\nconst char *event;\r\nchar *trigger;\r\nchar *number;\r\nbool enable;\r\nint ret;\r\nif (!param)\r\nreturn -EINVAL;\r\ntrigger = strsep(&param, " \t");\r\nif (!trigger)\r\nreturn -EINVAL;\r\nsystem = strsep(&trigger, ":");\r\nif (!trigger)\r\nreturn -EINVAL;\r\nevent = strsep(&trigger, ":");\r\nret = -EINVAL;\r\nevent_enable_file = find_event_file(tr, system, event);\r\nif (!event_enable_file)\r\ngoto out;\r\nenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\r\ntrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\r\nret = -ENOMEM;\r\ntrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\r\nif (!trigger_data)\r\ngoto out;\r\nenable_data = kzalloc(sizeof(*enable_data), GFP_KERNEL);\r\nif (!enable_data) {\r\nkfree(trigger_data);\r\ngoto out;\r\n}\r\ntrigger_data->count = -1;\r\ntrigger_data->ops = trigger_ops;\r\ntrigger_data->cmd_ops = cmd_ops;\r\nINIT_LIST_HEAD(&trigger_data->list);\r\nRCU_INIT_POINTER(trigger_data->filter, NULL);\r\nenable_data->enable = enable;\r\nenable_data->file = event_enable_file;\r\ntrigger_data->private_data = enable_data;\r\nif (glob[0] == '!') {\r\ncmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\r\nkfree(trigger_data);\r\nkfree(enable_data);\r\nret = 0;\r\ngoto out;\r\n}\r\nif (trigger) {\r\nnumber = strsep(&trigger, ":");\r\nret = -EINVAL;\r\nif (!strlen(number))\r\ngoto out_free;\r\nret = kstrtoul(number, 0, &trigger_data->count);\r\nif (ret)\r\ngoto out_free;\r\n}\r\nif (!param)\r\ngoto out_reg;\r\nif (!cmd_ops->set_filter)\r\ngoto out_reg;\r\nret = cmd_ops->set_filter(param, trigger_data, file);\r\nif (ret < 0)\r\ngoto out_free;\r\nout_reg:\r\nret = try_module_get(event_enable_file->event_call->mod);\r\nif (!ret) {\r\nret = -EBUSY;\r\ngoto out_free;\r\n}\r\nret = trace_event_enable_disable(event_enable_file, 1, 1);\r\nif (ret < 0)\r\ngoto out_put;\r\nret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\r\nif (!ret) {\r\nret = -ENOENT;\r\ngoto out_disable;\r\n} else if (ret < 0)\r\ngoto out_disable;\r\nret = 0;\r\nout:\r\nreturn ret;\r\nout_disable:\r\ntrace_event_enable_disable(event_enable_file, 0, 1);\r\nout_put:\r\nmodule_put(event_enable_file->event_call->mod);\r\nout_free:\r\nif (cmd_ops->set_filter)\r\ncmd_ops->set_filter(NULL, trigger_data, NULL);\r\nkfree(trigger_data);\r\nkfree(enable_data);\r\ngoto out;\r\n}\r\nstatic int event_enable_register_trigger(char *glob,\r\nstruct event_trigger_ops *ops,\r\nstruct event_trigger_data *data,\r\nstruct ftrace_event_file *file)\r\n{\r\nstruct enable_trigger_data *enable_data = data->private_data;\r\nstruct enable_trigger_data *test_enable_data;\r\nstruct event_trigger_data *test;\r\nint ret = 0;\r\nlist_for_each_entry_rcu(test, &file->triggers, list) {\r\ntest_enable_data = test->private_data;\r\nif (test_enable_data &&\r\n(test_enable_data->file == enable_data->file)) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nif (data->ops->init) {\r\nret = data->ops->init(data->ops, data);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nlist_add_rcu(&data->list, &file->triggers);\r\nret++;\r\nif (trace_event_trigger_enable_disable(file, 1) < 0) {\r\nlist_del_rcu(&data->list);\r\nret--;\r\n}\r\nupdate_cond_flag(file);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void event_enable_unregister_trigger(char *glob,\r\nstruct event_trigger_ops *ops,\r\nstruct event_trigger_data *test,\r\nstruct ftrace_event_file *file)\r\n{\r\nstruct enable_trigger_data *test_enable_data = test->private_data;\r\nstruct enable_trigger_data *enable_data;\r\nstruct event_trigger_data *data;\r\nbool unregistered = false;\r\nlist_for_each_entry_rcu(data, &file->triggers, list) {\r\nenable_data = data->private_data;\r\nif (enable_data &&\r\n(enable_data->file == test_enable_data->file)) {\r\nunregistered = true;\r\nlist_del_rcu(&data->list);\r\nupdate_cond_flag(file);\r\ntrace_event_trigger_enable_disable(file, 0);\r\nbreak;\r\n}\r\n}\r\nif (unregistered && data->ops->free)\r\ndata->ops->free(data->ops, data);\r\n}\r\nstatic struct event_trigger_ops *\r\nevent_enable_get_trigger_ops(char *cmd, char *param)\r\n{\r\nstruct event_trigger_ops *ops;\r\nbool enable;\r\nenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\r\nif (enable)\r\nops = param ? &event_enable_count_trigger_ops :\r\n&event_enable_trigger_ops;\r\nelse\r\nops = param ? &event_disable_count_trigger_ops :\r\n&event_disable_trigger_ops;\r\nreturn ops;\r\n}\r\nstatic __init void unregister_trigger_enable_disable_cmds(void)\r\n{\r\nunregister_event_command(&trigger_enable_cmd);\r\nunregister_event_command(&trigger_disable_cmd);\r\n}\r\nstatic __init int register_trigger_enable_disable_cmds(void)\r\n{\r\nint ret;\r\nret = register_event_command(&trigger_enable_cmd);\r\nif (WARN_ON(ret < 0))\r\nreturn ret;\r\nret = register_event_command(&trigger_disable_cmd);\r\nif (WARN_ON(ret < 0))\r\nunregister_trigger_enable_disable_cmds();\r\nreturn ret;\r\n}\r\nstatic __init int register_trigger_traceon_traceoff_cmds(void)\r\n{\r\nint ret;\r\nret = register_event_command(&trigger_traceon_cmd);\r\nif (WARN_ON(ret < 0))\r\nreturn ret;\r\nret = register_event_command(&trigger_traceoff_cmd);\r\nif (WARN_ON(ret < 0))\r\nunregister_trigger_traceon_traceoff_cmds();\r\nreturn ret;\r\n}\r\n__init int register_trigger_cmds(void)\r\n{\r\nregister_trigger_traceon_traceoff_cmds();\r\nregister_trigger_snapshot_cmd();\r\nregister_trigger_stacktrace_cmd();\r\nregister_trigger_enable_disable_cmds();\r\nreturn 0;\r\n}
