static struct gen_74x164_chip *gpio_to_74x164_chip(struct gpio_chip *gc)\r\n{\r\nreturn container_of(gc, struct gen_74x164_chip, gpio_chip);\r\n}\r\nstatic int __gen_74x164_write_config(struct gen_74x164_chip *chip)\r\n{\r\nstruct spi_device *spi = to_spi_device(chip->gpio_chip.dev);\r\nstruct spi_message message;\r\nstruct spi_transfer *msg_buf;\r\nint i, ret = 0;\r\nmsg_buf = kzalloc(chip->registers * sizeof(struct spi_transfer),\r\nGFP_KERNEL);\r\nif (!msg_buf)\r\nreturn -ENOMEM;\r\nspi_message_init(&message);\r\nfor (i = chip->registers - 1; i >= 0; i--) {\r\nmsg_buf[i].tx_buf = chip->buffer + i;\r\nmsg_buf[i].len = sizeof(u8);\r\nspi_message_add_tail(msg_buf + i, &message);\r\n}\r\nret = spi_sync(spi, &message);\r\nkfree(msg_buf);\r\nreturn ret;\r\n}\r\nstatic int gen_74x164_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct gen_74x164_chip *chip = gpio_to_74x164_chip(gc);\r\nu8 bank = offset / 8;\r\nu8 pin = offset % 8;\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = (chip->buffer[bank] >> pin) & 0x1;\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic void gen_74x164_set_value(struct gpio_chip *gc,\r\nunsigned offset, int val)\r\n{\r\nstruct gen_74x164_chip *chip = gpio_to_74x164_chip(gc);\r\nu8 bank = offset / 8;\r\nu8 pin = offset % 8;\r\nmutex_lock(&chip->lock);\r\nif (val)\r\nchip->buffer[bank] |= (1 << pin);\r\nelse\r\nchip->buffer[bank] &= ~(1 << pin);\r\n__gen_74x164_write_config(chip);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic int gen_74x164_direction_output(struct gpio_chip *gc,\r\nunsigned offset, int val)\r\n{\r\ngen_74x164_set_value(gc, offset, val);\r\nreturn 0;\r\n}\r\nstatic int gen_74x164_probe(struct spi_device *spi)\r\n{\r\nstruct gen_74x164_chip *chip;\r\nint ret;\r\nspi->bits_per_word = 8;\r\nret = spi_setup(spi);\r\nif (ret < 0)\r\nreturn ret;\r\nchip = devm_kzalloc(&spi->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, chip);\r\nchip->gpio_chip.label = spi->modalias;\r\nchip->gpio_chip.direction_output = gen_74x164_direction_output;\r\nchip->gpio_chip.get = gen_74x164_get_value;\r\nchip->gpio_chip.set = gen_74x164_set_value;\r\nchip->gpio_chip.base = -1;\r\nif (of_property_read_u32(spi->dev.of_node, "registers-number",\r\n&chip->registers)) {\r\ndev_err(&spi->dev,\r\n"Missing registers-number property in the DT.\n");\r\nreturn -EINVAL;\r\n}\r\nchip->gpio_chip.ngpio = GEN_74X164_NUMBER_GPIOS * chip->registers;\r\nchip->buffer = devm_kzalloc(&spi->dev, chip->registers, GFP_KERNEL);\r\nif (!chip->buffer)\r\nreturn -ENOMEM;\r\nchip->gpio_chip.can_sleep = true;\r\nchip->gpio_chip.dev = &spi->dev;\r\nchip->gpio_chip.owner = THIS_MODULE;\r\nmutex_init(&chip->lock);\r\nret = __gen_74x164_write_config(chip);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed writing: %d\n", ret);\r\ngoto exit_destroy;\r\n}\r\nret = gpiochip_add(&chip->gpio_chip);\r\nif (!ret)\r\nreturn 0;\r\nexit_destroy:\r\nmutex_destroy(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int gen_74x164_remove(struct spi_device *spi)\r\n{\r\nstruct gen_74x164_chip *chip = spi_get_drvdata(spi);\r\nint ret;\r\nret = gpiochip_remove(&chip->gpio_chip);\r\nif (!ret)\r\nmutex_destroy(&chip->lock);\r\nreturn ret;\r\n}
