static void reg_r(struct gspca_dev *gspca_dev,\r\n__u16 value)\r\n{\r\nint res;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nres = usb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nvalue,\r\n0,\r\ngspca_dev->usb_buf, 1,\r\n500);\r\nif (res < 0) {\r\ndev_err(gspca_dev->v4l2_dev.dev,\r\n"Error reading register %02x: %d\n", value, res);\r\ngspca_dev->usb_err = res;\r\n}\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\n__u16 value,\r\nconst __u8 *buffer,\r\nint len)\r\n{\r\nint res;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nmemcpy(gspca_dev->usb_buf, buffer, len);\r\nres = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nvalue,\r\n0,\r\ngspca_dev->usb_buf, len,\r\n500);\r\nif (res < 0) {\r\ndev_err(gspca_dev->v4l2_dev.dev,\r\n"Error writing register %02x: %d\n", value, res);\r\ngspca_dev->usb_err = res;\r\n}\r\n}\r\nstatic void i2c_w(struct gspca_dev *gspca_dev, const u8 *buf)\r\n{\r\nint retry = 60;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nreg_w(gspca_dev, 0x08, buf, 8);\r\nwhile (retry--) {\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nmsleep(1);\r\nreg_r(gspca_dev, 0x08);\r\nif (gspca_dev->usb_buf[0] & 0x04) {\r\nif (gspca_dev->usb_buf[0] & 0x08) {\r\ndev_err(gspca_dev->v4l2_dev.dev,\r\n"i2c error writing %8ph\n", buf);\r\ngspca_dev->usb_err = -EIO;\r\n}\r\nreturn;\r\n}\r\n}\r\ndev_err(gspca_dev->v4l2_dev.dev, "i2c write timeout\n");\r\ngspca_dev->usb_err = -EIO;\r\n}\r\nstatic void i2c_w_vector(struct gspca_dev *gspca_dev,\r\nconst __u8 buffer[][8], int len)\r\n{\r\nfor (;;) {\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\ni2c_w(gspca_dev, *buffer);\r\nlen -= 8;\r\nif (len <= 0)\r\nbreak;\r\nbuffer++;\r\n}\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV6650:\r\ncase SENSOR_OV7630: {\r\n__u8 i2cOV[] =\r\n{0xa0, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x10};\r\ni2cOV[1] = sensor_data[sd->sensor].sensor_addr;\r\ni2cOV[3] = sd->brightness->val;\r\ni2c_w(gspca_dev, i2cOV);\r\nbreak;\r\n}\r\ncase SENSOR_PAS106:\r\ncase SENSOR_PAS202: {\r\n__u8 i2cpbright[] =\r\n{0xb0, 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x16};\r\n__u8 i2cpdoit[] =\r\n{0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16};\r\nif (sd->sensor == SENSOR_PAS106) {\r\ni2cpbright[2] = 7;\r\ni2cpdoit[2] = 0x13;\r\n}\r\nif (sd->brightness->val < 127) {\r\ni2cpbright[3] = 0x01;\r\ni2cpbright[4] = 127 - sd->brightness->val;\r\n} else\r\ni2cpbright[4] = sd->brightness->val - 127;\r\ni2c_w(gspca_dev, i2cpbright);\r\ni2c_w(gspca_dev, i2cpdoit);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 gain = gspca_dev->gain->val;\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131D: {\r\n__u8 i2c[] =\r\n{0xc0, 0x11, 0x31, 0x00, 0x00, 0x00, 0x00, 0x17};\r\ni2c[3] = 0x3f - gain;\r\ni2c[4] = 0x3f - gain;\r\ni2c[5] = 0x3f - gain;\r\ni2c_w(gspca_dev, i2c);\r\nbreak;\r\n}\r\ncase SENSOR_TAS5110C:\r\ncase SENSOR_TAS5130CXX: {\r\n__u8 i2c[] =\r\n{0x30, 0x11, 0x02, 0x20, 0x70, 0x00, 0x00, 0x10};\r\ni2c[4] = 255 - gain;\r\ni2c_w(gspca_dev, i2c);\r\nbreak;\r\n}\r\ncase SENSOR_TAS5110D: {\r\n__u8 i2c[] = {\r\n0xb0, 0x61, 0x02, 0x00, 0x10, 0x00, 0x00, 0x17 };\r\ngain = 255 - gain;\r\ni2c[3] |= (gain & 0x80) >> 7;\r\ni2c[3] |= (gain & 0x40) >> 5;\r\ni2c[3] |= (gain & 0x20) >> 3;\r\ni2c[3] |= (gain & 0x10) >> 1;\r\ni2c[3] |= (gain & 0x08) << 1;\r\ni2c[3] |= (gain & 0x04) << 3;\r\ni2c[3] |= (gain & 0x02) << 5;\r\ni2c[3] |= (gain & 0x01) << 7;\r\ni2c_w(gspca_dev, i2c);\r\nbreak;\r\n}\r\ncase SENSOR_OV6650:\r\ncase SENSOR_OV7630: {\r\n__u8 i2c[] = {0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};\r\nif (sd->sensor == SENSOR_OV7630 && gain >= 32)\r\ngain += 16;\r\ni2c[1] = sensor_data[sd->sensor].sensor_addr;\r\ni2c[3] = gain;\r\ni2c_w(gspca_dev, i2c);\r\nbreak;\r\n}\r\ncase SENSOR_PAS106:\r\ncase SENSOR_PAS202: {\r\n__u8 i2cpgain[] =\r\n{0xa0, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x15};\r\n__u8 i2cpcolorgain[] =\r\n{0xc0, 0x40, 0x07, 0x00, 0x00, 0x00, 0x00, 0x15};\r\n__u8 i2cpdoit[] =\r\n{0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16};\r\nif (sd->sensor == SENSOR_PAS106) {\r\ni2cpgain[2] = 0x0e;\r\ni2cpcolorgain[0] = 0xd0;\r\ni2cpcolorgain[2] = 0x09;\r\ni2cpdoit[2] = 0x13;\r\n}\r\ni2cpgain[3] = gain;\r\ni2cpcolorgain[3] = gain >> 1;\r\ni2cpcolorgain[4] = gain >> 1;\r\ni2cpcolorgain[5] = gain >> 1;\r\ni2cpcolorgain[6] = gain >> 1;\r\ni2c_w(gspca_dev, i2cpgain);\r\ni2c_w(gspca_dev, i2cpcolorgain);\r\ni2c_w(gspca_dev, i2cpdoit);\r\nbreak;\r\n}\r\ndefault:\r\nif (sd->bridge == BRIDGE_103) {\r\nu8 buf[3] = { gain, gain, gain };\r\nreg_w(gspca_dev, 0x05, buf, 3);\r\n} else {\r\nu8 buf[2];\r\nbuf[0] = gain << 4 | gain;\r\nbuf[1] = gain;\r\nreg_w(gspca_dev, 0x10, buf, 2);\r\n}\r\n}\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131D: {\r\n__u8 i2c[] = {0xc0, 0x11, 0x25, 0x00, 0x00, 0x00, 0x00, 0x17};\r\nu16 reg = gspca_dev->exposure->val;\r\ni2c[3] = reg >> 8;\r\ni2c[4] = reg & 0xff;\r\ni2c_w(gspca_dev, i2c);\r\nbreak;\r\n}\r\ncase SENSOR_TAS5110C:\r\ncase SENSOR_TAS5110D: {\r\nu8 reg = gspca_dev->exposure->val;\r\nreg = (reg << 4) | 0x0b;\r\nreg_w(gspca_dev, 0x19, &reg, 1);\r\nbreak;\r\n}\r\ncase SENSOR_OV6650:\r\ncase SENSOR_OV7630: {\r\n__u8 i2c[] = {0xb0, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10};\r\nint reg10, reg11, reg10_max;\r\nif (sd->sensor == SENSOR_OV6650) {\r\nreg10_max = 0x4d;\r\ni2c[4] = 0xc0;\r\n} else\r\nreg10_max = 0x41;\r\nreg11 = (15 * gspca_dev->exposure->val + 999) / 1000;\r\nif (reg11 < 1)\r\nreg11 = 1;\r\nelse if (reg11 > 16)\r\nreg11 = 16;\r\nif (gspca_dev->pixfmt.width == 640 && reg11 < 4)\r\nreg11 = 4;\r\nreg10 = (gspca_dev->exposure->val * 15 * reg10_max)\r\n/ (1000 * reg11);\r\nif (gspca_dev->autogain->val && reg10 < 10)\r\nreg10 = 10;\r\nelse if (reg10 > reg10_max)\r\nreg10 = reg10_max;\r\ni2c[1] = sensor_data[sd->sensor].sensor_addr;\r\ni2c[3] = reg10;\r\ni2c[4] |= reg11 - 1;\r\nif (sd->reg11 == reg11)\r\ni2c[0] = 0xa0;\r\ni2c_w(gspca_dev, i2c);\r\nif (gspca_dev->usb_err == 0)\r\nsd->reg11 = reg11;\r\nbreak;\r\n}\r\ncase SENSOR_PAS202: {\r\n__u8 i2cpframerate[] =\r\n{0xb0, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x16};\r\n__u8 i2cpexpo[] =\r\n{0xa0, 0x40, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x16};\r\nconst __u8 i2cpdoit[] =\r\n{0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16};\r\nint framerate_ctrl;\r\nif (gspca_dev->exposure->val < 200) {\r\ni2cpexpo[3] = 255 - (gspca_dev->exposure->val * 255)\r\n/ 200;\r\nframerate_ctrl = 500;\r\n} else {\r\nframerate_ctrl = (gspca_dev->exposure->val - 200)\r\n* 1000 / 229 + 500;\r\n}\r\ni2cpframerate[3] = framerate_ctrl >> 6;\r\ni2cpframerate[4] = framerate_ctrl & 0x3f;\r\ni2c_w(gspca_dev, i2cpframerate);\r\ni2c_w(gspca_dev, i2cpexpo);\r\ni2c_w(gspca_dev, i2cpdoit);\r\nbreak;\r\n}\r\ncase SENSOR_PAS106: {\r\n__u8 i2cpframerate[] =\r\n{0xb1, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x14};\r\n__u8 i2cpexpo[] =\r\n{0xa1, 0x40, 0x05, 0x00, 0x00, 0x00, 0x00, 0x14};\r\nconst __u8 i2cpdoit[] =\r\n{0xa1, 0x40, 0x13, 0x01, 0x00, 0x00, 0x00, 0x14};\r\nint framerate_ctrl;\r\nif (gspca_dev->exposure->val < 150) {\r\ni2cpexpo[3] = 150 - gspca_dev->exposure->val;\r\nframerate_ctrl = 300;\r\n} else {\r\nframerate_ctrl = (gspca_dev->exposure->val - 150)\r\n* 1000 / 230 + 300;\r\n}\r\ni2cpframerate[3] = framerate_ctrl >> 4;\r\ni2cpframerate[4] = framerate_ctrl & 0x0f;\r\ni2c_w(gspca_dev, i2cpframerate);\r\ni2c_w(gspca_dev, i2cpexpo);\r\ni2c_w(gspca_dev, i2cpdoit);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void setfreq(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_OV6650 || sd->sensor == SENSOR_OV7630) {\r\n__u8 i2c[] = {0xa0, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x10};\r\nswitch (sd->plfreq->val) {\r\ndefault:\r\ni2c[3] = 0;\r\nbreak;\r\ncase 1:\r\ni2c[3] = (sd->sensor == SENSOR_OV6650)\r\n? 0x4f : 0x8a;\r\nbreak;\r\n}\r\ni2c[1] = sensor_data[sd->sensor].sensor_addr;\r\ni2c_w(gspca_dev, i2c);\r\n}\r\n}\r\nstatic void do_autogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint deadzone, desired_avg_lum, avg_lum;\r\navg_lum = atomic_read(&sd->avg_lum);\r\nif (avg_lum == -1)\r\nreturn;\r\nif (sd->autogain_ignore_frames > 0) {\r\nsd->autogain_ignore_frames--;\r\nreturn;\r\n}\r\nif (sensor_data[sd->sensor].flags & F_SIF) {\r\ndeadzone = 500;\r\ndesired_avg_lum = 5000;\r\n} else {\r\ndeadzone = 1500;\r\ndesired_avg_lum = 13000;\r\n}\r\nif (sd->brightness)\r\ndesired_avg_lum = sd->brightness->val * desired_avg_lum / 127;\r\nif (gspca_dev->exposure->maximum < 500) {\r\nif (gspca_coarse_grained_expo_autogain(gspca_dev, avg_lum,\r\ndesired_avg_lum, deadzone))\r\nsd->autogain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;\r\n} else {\r\nint gain_knee = gspca_dev->gain->maximum * 9 / 10;\r\nif (gspca_expo_autogain(gspca_dev, avg_lum, desired_avg_lum,\r\ndeadzone, gain_knee, sd->exposure_knee))\r\nsd->autogain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;\r\n}\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\nreg_r(gspca_dev, 0x00);\r\nif (gspca_dev->usb_buf[0] != 0x10)\r\nreturn -ENODEV;\r\nsd->sensor = id->driver_info >> 8;\r\nsd->bridge = id->driver_info & 0xff;\r\ncam = &gspca_dev->cam;\r\nif (!(sensor_data[sd->sensor].flags & F_SIF)) {\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\n} else {\r\ncam->cam_mode = sif_mode;\r\ncam->nmodes = ARRAY_SIZE(sif_mode);\r\n}\r\ncam->npkt = 36;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nconst __u8 stop = 0x09;\r\nreg_w(gspca_dev, 0x01, &stop, 1);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (ctrl->id == V4L2_CID_AUTOGAIN && ctrl->is_new && ctrl->val) {\r\ngspca_dev->gain->val = gspca_dev->gain->default_value;\r\ngspca_dev->exposure->val = gspca_dev->exposure->default_value;\r\nsd->autogain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;\r\n}\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nif (gspca_dev->exposure->is_new || (ctrl->is_new && ctrl->val))\r\nsetexposure(gspca_dev);\r\nif (gspca_dev->gain->is_new || (ctrl->is_new && ctrl->val))\r\nsetgain(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nsetfreq(gspca_dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 5);\r\nif (sd->sensor == SENSOR_OV6650 || sd->sensor == SENSOR_OV7630 ||\r\nsd->sensor == SENSOR_PAS106 || sd->sensor == SENSOR_PAS202)\r\nsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV6650:\r\ncase SENSOR_PAS106:\r\ncase SENSOR_PAS202:\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 31, 1, 15);\r\nbreak;\r\ncase SENSOR_OV7630:\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 47, 1, 31);\r\nbreak;\r\ncase SENSOR_HV7131D:\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 63, 1, 31);\r\nbreak;\r\ncase SENSOR_TAS5110C:\r\ncase SENSOR_TAS5110D:\r\ncase SENSOR_TAS5130CXX:\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 255, 1, 127);\r\nbreak;\r\ndefault:\r\nif (sd->bridge == BRIDGE_103) {\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 127, 1, 63);\r\n} else {\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 15, 1, 7);\r\n}\r\n}\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131D:\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 8191, 1, 482);\r\nsd->exposure_knee = 964;\r\nbreak;\r\ncase SENSOR_OV6650:\r\ncase SENSOR_OV7630:\r\ncase SENSOR_PAS106:\r\ncase SENSOR_PAS202:\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 1023, 1, 66);\r\nsd->exposure_knee = 200;\r\nbreak;\r\ncase SENSOR_TAS5110C:\r\ncase SENSOR_TAS5110D:\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 2, 15, 1, 2);\r\nbreak;\r\n}\r\nif (gspca_dev->exposure) {\r\ngspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\n}\r\nif (sd->sensor == SENSOR_OV6650 || sd->sensor == SENSOR_OV7630)\r\nsd->plfreq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\r\nV4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0,\r\nV4L2_CID_POWER_LINE_FREQUENCY_DISABLED);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nif (gspca_dev->autogain)\r\nv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, false);\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam = &gspca_dev->cam;\r\nint i, mode;\r\n__u8 regs[0x31];\r\nmode = cam->cam_mode[gspca_dev->curr_mode].priv & 0x07;\r\nmemcpy(&regs[0x01], sensor_data[sd->sensor].bridge_init, 0x19);\r\nregs[0x18] |= mode << 4;\r\nif (sd->bridge == BRIDGE_103) {\r\nregs[0x05] = 0x20;\r\nregs[0x06] = 0x20;\r\nregs[0x07] = 0x20;\r\n} else {\r\nregs[0x10] = 0x00;\r\nregs[0x11] = 0x00;\r\n}\r\nif (sensor_data[sd->sensor].flags & F_SIF) {\r\nregs[0x1a] = 0x14;\r\nregs[0x1b] = 0x0a;\r\nregs[0x1c] = 0x02;\r\nregs[0x1d] = 0x02;\r\nregs[0x1e] = 0x09;\r\nregs[0x1f] = 0x07;\r\n} else {\r\nregs[0x1a] = 0x1d;\r\nregs[0x1b] = 0x10;\r\nregs[0x1c] = 0x05;\r\nregs[0x1d] = 0x03;\r\nregs[0x1e] = 0x0f;\r\nregs[0x1f] = 0x0c;\r\n}\r\nfor (i = 0; i < 16; i++)\r\nregs[0x20 + i] = i * 16;\r\nregs[0x20 + i] = 255;\r\nswitch (sd->sensor) {\r\ncase SENSOR_TAS5130CXX:\r\nregs[0x19] = mode ? 0x23 : 0x43;\r\nbreak;\r\ncase SENSOR_OV7630:\r\nif (sd->bridge == BRIDGE_103) {\r\nregs[0x01] = 0x44;\r\nregs[0x12] = 0x02;\r\n}\r\nbreak;\r\ncase SENSOR_PAS202:\r\nif (sd->bridge == BRIDGE_103)\r\nregs[0x12] += 1;\r\nbreak;\r\n}\r\nif (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_RAW)\r\nregs[0x18] &= ~0x80;\r\nif (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_REDUCED_SIF) {\r\nregs[0x12] += 16;\r\nregs[0x13] += 24;\r\nregs[0x15] = 320 / 16;\r\nregs[0x16] = 240 / 16;\r\n}\r\nreg_w(gspca_dev, 0x01, &regs[0x01], 1);\r\nreg_w(gspca_dev, 0x17, &regs[0x17], 1);\r\nreg_w(gspca_dev, 0x01, &regs[0x01],\r\n(sd->bridge == BRIDGE_103) ? 0x30 : 0x1f);\r\ni2c_w_vector(gspca_dev, sensor_data[sd->sensor].sensor_init,\r\nsensor_data[sd->sensor].sensor_init_size);\r\nswitch (sd->sensor) {\r\ncase SENSOR_PAS202: {\r\nconst __u8 i2cpclockdiv[] =\r\n{0xa0, 0x40, 0x02, 0x03, 0x00, 0x00, 0x00, 0x10};\r\nif (mode)\r\ni2c_w(gspca_dev, i2cpclockdiv);\r\nbreak;\r\n}\r\ncase SENSOR_OV7630:\r\nif (sd->bridge == BRIDGE_103) {\r\nconst __u8 i2c[] = { 0xa0, 0x21, 0x13,\r\n0x80, 0x00, 0x00, 0x00, 0x10 };\r\ni2c_w(gspca_dev, i2c);\r\n}\r\nbreak;\r\n}\r\nreg_w(gspca_dev, 0x15, &regs[0x15], 2);\r\nreg_w(gspca_dev, 0x18, &regs[0x18], 1);\r\nreg_w(gspca_dev, 0x12, &regs[0x12], 1);\r\nreg_w(gspca_dev, 0x13, &regs[0x13], 1);\r\nreg_w(gspca_dev, 0x17, &regs[0x17], 1);\r\nreg_w(gspca_dev, 0x19, &regs[0x19], 1);\r\nreg_w(gspca_dev, 0x1c, &regs[0x1c], 4);\r\nreg_w(gspca_dev, 0x01, &regs[0x01], 1);\r\nreg_w(gspca_dev, 0x18, &regs[0x18], 2);\r\nmsleep(20);\r\nsd->reg11 = -1;\r\nsetgain(gspca_dev);\r\nsetbrightness(gspca_dev);\r\nsetexposure(gspca_dev);\r\nsetfreq(gspca_dev);\r\nsd->frames_to_drop = 0;\r\nsd->autogain_ignore_frames = 0;\r\ngspca_dev->exp_too_high_cnt = 0;\r\ngspca_dev->exp_too_low_cnt = 0;\r\natomic_set(&sd->avg_lum, -1);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nsd_init(gspca_dev);\r\n}\r\nstatic u8* find_sof(struct gspca_dev *gspca_dev, u8 *data, int len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, header_size = (sd->bridge == BRIDGE_103) ? 18 : 12;\r\nfor (i = 0; i < len; i++) {\r\nswitch (sd->header_read) {\r\ncase 0:\r\nif (data[i] == 0xff)\r\nsd->header_read++;\r\nbreak;\r\ncase 1:\r\nif (data[i] == 0xff)\r\nsd->header_read++;\r\nelse\r\nsd->header_read = 0;\r\nbreak;\r\ncase 2:\r\nif (data[i] == 0x00)\r\nsd->header_read++;\r\nelse if (data[i] != 0xff)\r\nsd->header_read = 0;\r\nbreak;\r\ncase 3:\r\nif (data[i] == 0xc4)\r\nsd->header_read++;\r\nelse if (data[i] == 0xff)\r\nsd->header_read = 1;\r\nelse\r\nsd->header_read = 0;\r\nbreak;\r\ncase 4:\r\nif (data[i] == 0xc4)\r\nsd->header_read++;\r\nelse if (data[i] == 0xff)\r\nsd->header_read = 1;\r\nelse\r\nsd->header_read = 0;\r\nbreak;\r\ncase 5:\r\nif (data[i] == 0x96)\r\nsd->header_read++;\r\nelse if (data[i] == 0xff)\r\nsd->header_read = 1;\r\nelse\r\nsd->header_read = 0;\r\nbreak;\r\ndefault:\r\nsd->header[sd->header_read - 6] = data[i];\r\nsd->header_read++;\r\nif (sd->header_read == header_size) {\r\nsd->header_read = 0;\r\nreturn data + i + 1;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint fr_h_sz = 0, lum_offset = 0, len_after_sof = 0;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam = &gspca_dev->cam;\r\nu8 *sof;\r\nsof = find_sof(gspca_dev, data, len);\r\nif (sof) {\r\nif (sd->bridge == BRIDGE_103) {\r\nfr_h_sz = 18;\r\nlum_offset = 3;\r\n} else {\r\nfr_h_sz = 12;\r\nlum_offset = 2;\r\n}\r\nlen_after_sof = len - (sof - data);\r\nlen = (sof - data) - fr_h_sz;\r\nif (len < 0)\r\nlen = 0;\r\n}\r\nif (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_RAW) {\r\nint used;\r\nint size = cam->cam_mode[gspca_dev->curr_mode].sizeimage;\r\nused = gspca_dev->image_len;\r\nif (used + len > size)\r\nlen = size - used;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\nif (sof) {\r\nint lum = sd->header[lum_offset] +\r\n(sd->header[lum_offset + 1] << 8);\r\nif (lum == 0 && sd->prev_avg_lum != 0) {\r\nlum = -1;\r\nsd->frames_to_drop = 2;\r\nsd->prev_avg_lum = 0;\r\n} else\r\nsd->prev_avg_lum = lum;\r\natomic_set(&sd->avg_lum, lum);\r\nif (sd->frames_to_drop)\r\nsd->frames_to_drop--;\r\nelse\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, sof, len_after_sof);\r\n}\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint ret = -EINVAL;\r\nif (len == 1 && data[0] == 1) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\r\ninput_sync(gspca_dev->input_dev);\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
