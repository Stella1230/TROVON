static struct metapage *read_index_page(struct inode *inode, s64 blkno)\r\n{\r\nint rc;\r\ns64 xaddr;\r\nint xflag;\r\ns32 xlen;\r\nrc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\r\nif (rc || (xaddr == 0))\r\nreturn NULL;\r\nreturn read_metapage(inode, xaddr, PSIZE, 1);\r\n}\r\nstatic struct metapage *get_index_page(struct inode *inode, s64 blkno)\r\n{\r\nint rc;\r\ns64 xaddr;\r\nint xflag;\r\ns32 xlen;\r\nrc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\r\nif (rc || (xaddr == 0))\r\nreturn NULL;\r\nreturn get_metapage(inode, xaddr, PSIZE, 1);\r\n}\r\nstatic struct dir_table_slot *find_index(struct inode *ip, u32 index,\r\nstruct metapage ** mp, s64 *lblock)\r\n{\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\ns64 blkno;\r\ns64 offset;\r\nint page_offset;\r\nstruct dir_table_slot *slot;\r\nstatic int maxWarnings = 10;\r\nif (index < 2) {\r\nif (maxWarnings) {\r\njfs_warn("find_entry called with index = %d", index);\r\nmaxWarnings--;\r\n}\r\nreturn NULL;\r\n}\r\nif (index >= jfs_ip->next_index) {\r\njfs_warn("find_entry called with index >= next_index");\r\nreturn NULL;\r\n}\r\nif (jfs_dirtable_inline(ip)) {\r\n*mp = NULL;\r\nslot = &jfs_ip->i_dirtable[index - 2];\r\n} else {\r\noffset = (index - 2) * sizeof(struct dir_table_slot);\r\npage_offset = offset & (PSIZE - 1);\r\nblkno = ((offset + 1) >> L2PSIZE) <<\r\nJFS_SBI(ip->i_sb)->l2nbperpage;\r\nif (*mp && (*lblock != blkno)) {\r\nrelease_metapage(*mp);\r\n*mp = NULL;\r\n}\r\nif (!(*mp)) {\r\n*lblock = blkno;\r\n*mp = read_index_page(ip, blkno);\r\n}\r\nif (!(*mp)) {\r\njfs_err("free_index: error reading directory table");\r\nreturn NULL;\r\n}\r\nslot =\r\n(struct dir_table_slot *) ((char *) (*mp)->data +\r\npage_offset);\r\n}\r\nreturn slot;\r\n}\r\nstatic inline void lock_index(tid_t tid, struct inode *ip, struct metapage * mp,\r\nu32 index)\r\n{\r\nstruct tlock *tlck;\r\nstruct linelock *llck;\r\nstruct lv *lv;\r\ntlck = txLock(tid, ip, mp, tlckDATA);\r\nllck = (struct linelock *) tlck->lock;\r\nif (llck->index >= llck->maxcnt)\r\nllck = txLinelock(llck);\r\nlv = &llck->lv[llck->index];\r\nlv->offset = ((index - 2) & 511) >> 1;\r\nlv->length = 1;\r\nllck->index++;\r\n}\r\nstatic u32 add_index(tid_t tid, struct inode *ip, s64 bn, int slot)\r\n{\r\nstruct super_block *sb = ip->i_sb;\r\nstruct jfs_sb_info *sbi = JFS_SBI(sb);\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\nu64 blkno;\r\nstruct dir_table_slot *dirtab_slot;\r\nu32 index;\r\nstruct linelock *llck;\r\nstruct lv *lv;\r\nstruct metapage *mp;\r\ns64 offset;\r\nuint page_offset;\r\nstruct tlock *tlck;\r\ns64 xaddr;\r\nASSERT(DO_INDEX(ip));\r\nif (jfs_ip->next_index < 2) {\r\njfs_warn("add_index: next_index = %d. Resetting!",\r\njfs_ip->next_index);\r\njfs_ip->next_index = 2;\r\n}\r\nindex = jfs_ip->next_index++;\r\nif (index <= MAX_INLINE_DIRTABLE_ENTRY) {\r\nip->i_size = (loff_t) (index - 1) << 3;\r\ndirtab_slot = &jfs_ip->i_dirtable[index-2];\r\ndirtab_slot->flag = DIR_INDEX_VALID;\r\ndirtab_slot->slot = slot;\r\nDTSaddress(dirtab_slot, bn);\r\nset_cflag(COMMIT_Dirtable, ip);\r\nreturn index;\r\n}\r\nif (index == (MAX_INLINE_DIRTABLE_ENTRY + 1)) {\r\nstruct dir_table_slot temp_table[12];\r\nif (dquot_alloc_block(ip, sbi->nbperpage))\r\ngoto clean_up;\r\nif (dbAlloc(ip, 0, sbi->nbperpage, &xaddr)) {\r\ndquot_free_block(ip, sbi->nbperpage);\r\ngoto clean_up;\r\n}\r\nmemcpy(temp_table, &jfs_ip->i_dirtable, sizeof(temp_table));\r\nxtInitRoot(tid, ip);\r\nif (xtInsert(tid, ip, 0, 0, sbi->nbperpage, &xaddr, 0)) {\r\njfs_warn("add_index: xtInsert failed!");\r\nmemcpy(&jfs_ip->i_dirtable, temp_table,\r\nsizeof (temp_table));\r\ndbFree(ip, xaddr, sbi->nbperpage);\r\ndquot_free_block(ip, sbi->nbperpage);\r\ngoto clean_up;\r\n}\r\nip->i_size = PSIZE;\r\nmp = get_index_page(ip, 0);\r\nif (!mp) {\r\njfs_err("add_index: get_metapage failed!");\r\nxtTruncate(tid, ip, 0, COMMIT_PWMAP);\r\nmemcpy(&jfs_ip->i_dirtable, temp_table,\r\nsizeof (temp_table));\r\ngoto clean_up;\r\n}\r\ntlck = txLock(tid, ip, mp, tlckDATA);\r\nllck = (struct linelock *) & tlck->lock;\r\nASSERT(llck->index == 0);\r\nlv = &llck->lv[0];\r\nlv->offset = 0;\r\nlv->length = 6;\r\nllck->index++;\r\nmemcpy(mp->data, temp_table, sizeof(temp_table));\r\nmark_metapage_dirty(mp);\r\nrelease_metapage(mp);\r\nclear_cflag(COMMIT_Dirtable, ip);\r\n}\r\noffset = (index - 2) * sizeof(struct dir_table_slot);\r\npage_offset = offset & (PSIZE - 1);\r\nblkno = ((offset + 1) >> L2PSIZE) << sbi->l2nbperpage;\r\nif (page_offset == 0) {\r\nxaddr = 0;\r\nif (xtInsert(tid, ip, 0, blkno, sbi->nbperpage, &xaddr, 0)) {\r\njfs_warn("add_index: xtInsert failed!");\r\ngoto clean_up;\r\n}\r\nip->i_size += PSIZE;\r\nif ((mp = get_index_page(ip, blkno)))\r\nmemset(mp->data, 0, PSIZE);\r\nelse\r\nxtTruncate(tid, ip, offset, COMMIT_PWMAP);\r\n} else\r\nmp = read_index_page(ip, blkno);\r\nif (!mp) {\r\njfs_err("add_index: get/read_metapage failed!");\r\ngoto clean_up;\r\n}\r\nlock_index(tid, ip, mp, index);\r\ndirtab_slot =\r\n(struct dir_table_slot *) ((char *) mp->data + page_offset);\r\ndirtab_slot->flag = DIR_INDEX_VALID;\r\ndirtab_slot->slot = slot;\r\nDTSaddress(dirtab_slot, bn);\r\nmark_metapage_dirty(mp);\r\nrelease_metapage(mp);\r\nreturn index;\r\nclean_up:\r\njfs_ip->next_index--;\r\nreturn 0;\r\n}\r\nstatic void free_index(tid_t tid, struct inode *ip, u32 index, u32 next)\r\n{\r\nstruct dir_table_slot *dirtab_slot;\r\ns64 lblock;\r\nstruct metapage *mp = NULL;\r\ndirtab_slot = find_index(ip, index, &mp, &lblock);\r\nif (!dirtab_slot)\r\nreturn;\r\ndirtab_slot->flag = DIR_INDEX_FREE;\r\ndirtab_slot->slot = dirtab_slot->addr1 = 0;\r\ndirtab_slot->addr2 = cpu_to_le32(next);\r\nif (mp) {\r\nlock_index(tid, ip, mp, index);\r\nmark_metapage_dirty(mp);\r\nrelease_metapage(mp);\r\n} else\r\nset_cflag(COMMIT_Dirtable, ip);\r\n}\r\nstatic void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\r\nint slot, struct metapage ** mp, s64 *lblock)\r\n{\r\nstruct dir_table_slot *dirtab_slot;\r\ndirtab_slot = find_index(ip, index, mp, lblock);\r\nif (!dirtab_slot)\r\nreturn;\r\nDTSaddress(dirtab_slot, bn);\r\ndirtab_slot->slot = slot;\r\nif (*mp) {\r\nlock_index(tid, ip, *mp, index);\r\nmark_metapage_dirty(*mp);\r\n} else\r\nset_cflag(COMMIT_Dirtable, ip);\r\n}\r\nstatic int read_index(struct inode *ip, u32 index,\r\nstruct dir_table_slot * dirtab_slot)\r\n{\r\ns64 lblock;\r\nstruct metapage *mp = NULL;\r\nstruct dir_table_slot *slot;\r\nslot = find_index(ip, index, &mp, &lblock);\r\nif (!slot) {\r\nreturn -EIO;\r\n}\r\nmemcpy(dirtab_slot, slot, sizeof(struct dir_table_slot));\r\nif (mp)\r\nrelease_metapage(mp);\r\nreturn 0;\r\n}\r\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\r\nstruct btstack * btstack, int flag)\r\n{\r\nint rc = 0;\r\nint cmp = 1;\r\ns64 bn;\r\nstruct metapage *mp;\r\ndtpage_t *p;\r\ns8 *stbl;\r\nint base, index, lim;\r\nstruct btframe *btsp;\r\npxd_t *pxd;\r\nint psize = 288;\r\nino_t inumber;\r\nstruct component_name ciKey;\r\nstruct super_block *sb = ip->i_sb;\r\nciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\r\nif (!ciKey.name) {\r\nrc = -ENOMEM;\r\ngoto dtSearch_Exit2;\r\n}\r\nUniStrcpy(ciKey.name, key->name);\r\nciKey.namlen = key->namlen;\r\nif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\r\nciToUpper(&ciKey);\r\n}\r\nBT_CLR(btstack);\r\nbtstack->nsplit = 1;\r\nfor (bn = 0;;) {\r\nDT_GETPAGE(ip, bn, mp, psize, p, rc);\r\nif (rc)\r\ngoto dtSearch_Exit1;\r\nstbl = DT_GETSTBL(p);\r\nfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\r\nindex = base + (lim >> 1);\r\nif (p->header.flag & BT_LEAF) {\r\ncmp =\r\nciCompare(&ciKey, p, stbl[index],\r\nJFS_SBI(sb)->mntflag);\r\n} else {\r\ncmp = dtCompare(&ciKey, p, stbl[index]);\r\n}\r\nif (cmp == 0) {\r\nif (p->header.flag & BT_LEAF) {\r\ninumber = le32_to_cpu(\r\n((struct ldtentry *) & p->slot[stbl[index]])->inumber);\r\nif (flag == JFS_LOOKUP) {\r\n*data = inumber;\r\nrc = 0;\r\ngoto out;\r\n}\r\nif (flag == JFS_CREATE) {\r\n*data = inumber;\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\nif ((flag == JFS_REMOVE ||\r\nflag == JFS_RENAME) &&\r\n*data != inumber) {\r\nrc = -ESTALE;\r\ngoto out;\r\n}\r\n*data = inumber;\r\nbtsp = btstack->top;\r\nbtsp->bn = bn;\r\nbtsp->index = index;\r\nbtsp->mp = mp;\r\nrc = 0;\r\ngoto dtSearch_Exit1;\r\n}\r\ngoto getChild;\r\n}\r\nif (cmp > 0) {\r\nbase = index + 1;\r\n--lim;\r\n}\r\n}\r\nif (p->header.flag & BT_LEAF) {\r\nif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\r\nflag == JFS_RENAME) {\r\nrc = -ENOENT;\r\ngoto out;\r\n}\r\n*data = 0;\r\nbtsp = btstack->top;\r\nbtsp->bn = bn;\r\nbtsp->index = base;\r\nbtsp->mp = mp;\r\nrc = 0;\r\ngoto dtSearch_Exit1;\r\n}\r\nindex = base ? base - 1 : base;\r\ngetChild:\r\nif (BT_STACK_FULL(btstack)) {\r\njfs_error(sb, "stack overrun!\n");\r\nBT_STACK_DUMP(btstack);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nbtstack->nsplit++;\r\nBT_PUSH(btstack, bn, index);\r\npxd = (pxd_t *) & p->slot[stbl[index]];\r\nbn = addressPXD(pxd);\r\npsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\r\nDT_PUTPAGE(mp);\r\n}\r\nout:\r\nDT_PUTPAGE(mp);\r\ndtSearch_Exit1:\r\nkfree(ciKey.name);\r\ndtSearch_Exit2:\r\nreturn rc;\r\n}\r\nint dtInsert(tid_t tid, struct inode *ip,\r\nstruct component_name * name, ino_t * fsn, struct btstack * btstack)\r\n{\r\nint rc = 0;\r\nstruct metapage *mp;\r\ndtpage_t *p;\r\ns64 bn;\r\nint index;\r\nstruct dtsplit split;\r\nddata_t data;\r\nstruct dt_lock *dtlck;\r\nint n;\r\nstruct tlock *tlck;\r\nstruct lv *lv;\r\nDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\r\nif (DO_INDEX(ip)) {\r\nif (JFS_IP(ip)->next_index == DIREND) {\r\nDT_PUTPAGE(mp);\r\nreturn -EMLINK;\r\n}\r\nn = NDTLEAF(name->namlen);\r\ndata.leaf.tid = tid;\r\ndata.leaf.ip = ip;\r\n} else {\r\nn = NDTLEAF_LEGACY(name->namlen);\r\ndata.leaf.ip = NULL;\r\n}\r\ndata.leaf.ino = *fsn;\r\nif (n > p->header.freecnt) {\r\nsplit.mp = mp;\r\nsplit.index = index;\r\nsplit.nslot = n;\r\nsplit.key = name;\r\nsplit.data = &data;\r\nrc = dtSplitUp(tid, ip, &split, btstack);\r\nreturn rc;\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nASSERT(dtlck->index == 0);\r\nlv = & dtlck->lv[0];\r\nlv->offset = 0;\r\nlv->length = 1;\r\ndtlck->index++;\r\ndtInsertEntry(p, index, name, &data, &dtlck);\r\nif (!(p->header.flag & BT_ROOT)) {\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[dtlck->index];\r\nn = index >> L2DTSLOTSIZE;\r\nlv->offset = p->header.stblindex + n;\r\nlv->length =\r\n((p->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\r\ndtlck->index++;\r\n}\r\nDT_PUTPAGE(mp);\r\nreturn 0;\r\n}\r\nstatic int dtSplitUp(tid_t tid,\r\nstruct inode *ip, struct dtsplit * split, struct btstack * btstack)\r\n{\r\nstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\r\nint rc = 0;\r\nstruct metapage *smp;\r\ndtpage_t *sp;\r\nstruct metapage *rmp;\r\ndtpage_t *rp;\r\npxd_t rpxd;\r\nstruct metapage *lmp;\r\ndtpage_t *lp;\r\nint skip;\r\nstruct btframe *parent;\r\ns64 xaddr, nxaddr;\r\nint xlen, xsize;\r\nstruct pxdlist pxdlist;\r\npxd_t *pxd;\r\nstruct component_name key = { 0, NULL };\r\nddata_t *data = split->data;\r\nint n;\r\nstruct dt_lock *dtlck;\r\nstruct tlock *tlck;\r\nstruct lv *lv;\r\nint quota_allocation = 0;\r\nsmp = split->mp;\r\nsp = DT_PAGE(ip, smp);\r\nkey.name = kmalloc((JFS_NAME_MAX + 2) * sizeof(wchar_t), GFP_NOFS);\r\nif (!key.name) {\r\nDT_PUTPAGE(smp);\r\nrc = -ENOMEM;\r\ngoto dtSplitUp_Exit;\r\n}\r\nif (sp->header.flag & BT_ROOT) {\r\nxlen = 1;\r\nn = sbi->bsize >> L2DTSLOTSIZE;\r\nn -= (n + 31) >> L2DTSLOTSIZE;\r\nn -= DTROOTMAXSLOT - sp->header.freecnt;\r\nif (n <= split->nslot)\r\nxlen++;\r\nif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr))) {\r\nDT_PUTPAGE(smp);\r\ngoto freeKeyName;\r\n}\r\npxdlist.maxnpxd = 1;\r\npxdlist.npxd = 0;\r\npxd = &pxdlist.pxd[0];\r\nPXDaddress(pxd, xaddr);\r\nPXDlength(pxd, xlen);\r\nsplit->pxdlist = &pxdlist;\r\nrc = dtSplitRoot(tid, ip, split, &rmp);\r\nif (rc)\r\ndbFree(ip, xaddr, xlen);\r\nelse\r\nDT_PUTPAGE(rmp);\r\nDT_PUTPAGE(smp);\r\nif (!DO_INDEX(ip))\r\nip->i_size = xlen << sbi->l2bsize;\r\ngoto freeKeyName;\r\n}\r\npxd = &sp->header.self;\r\nxlen = lengthPXD(pxd);\r\nxsize = xlen << sbi->l2bsize;\r\nif (xsize < PSIZE) {\r\nxaddr = addressPXD(pxd);\r\nn = xsize >> L2DTSLOTSIZE;\r\nn -= (n + 31) >> L2DTSLOTSIZE;\r\nif ((n + sp->header.freecnt) <= split->nslot)\r\nn = xlen + (xlen << 1);\r\nelse\r\nn = xlen;\r\nrc = dquot_alloc_block(ip, n);\r\nif (rc)\r\ngoto extendOut;\r\nquota_allocation += n;\r\nif ((rc = dbReAlloc(sbi->ipbmap, xaddr, (s64) xlen,\r\n(s64) n, &nxaddr)))\r\ngoto extendOut;\r\npxdlist.maxnpxd = 1;\r\npxdlist.npxd = 0;\r\npxd = &pxdlist.pxd[0];\r\nPXDaddress(pxd, nxaddr)\r\nPXDlength(pxd, xlen + n);\r\nsplit->pxdlist = &pxdlist;\r\nif ((rc = dtExtendPage(tid, ip, split, btstack))) {\r\nnxaddr = addressPXD(pxd);\r\nif (xaddr != nxaddr) {\r\nxlen = lengthPXD(pxd);\r\ndbFree(ip, nxaddr, (s64) xlen);\r\n} else {\r\nxlen = lengthPXD(pxd) - n;\r\nxaddr = addressPXD(pxd) + xlen;\r\ndbFree(ip, xaddr, (s64) n);\r\n}\r\n} else if (!DO_INDEX(ip))\r\nip->i_size = lengthPXD(pxd) << sbi->l2bsize;\r\nextendOut:\r\nDT_PUTPAGE(smp);\r\ngoto freeKeyName;\r\n}\r\nn = btstack->nsplit;\r\npxdlist.maxnpxd = pxdlist.npxd = 0;\r\nxlen = sbi->nbperpage;\r\nfor (pxd = pxdlist.pxd; n > 0; n--, pxd++) {\r\nif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr)) == 0) {\r\nPXDaddress(pxd, xaddr);\r\nPXDlength(pxd, xlen);\r\npxdlist.maxnpxd++;\r\ncontinue;\r\n}\r\nDT_PUTPAGE(smp);\r\ngoto splitOut;\r\n}\r\nsplit->pxdlist = &pxdlist;\r\nif ((rc = dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd))) {\r\nDT_PUTPAGE(smp);\r\ngoto splitOut;\r\n}\r\nif (!DO_INDEX(ip))\r\nip->i_size += PSIZE;\r\nwhile ((parent = BT_POP(btstack)) != NULL) {\r\nlmp = smp;\r\nlp = sp;\r\nDT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\r\nif (rc) {\r\nDT_PUTPAGE(lmp);\r\nDT_PUTPAGE(rmp);\r\ngoto splitOut;\r\n}\r\nskip = parent->index + 1;\r\nswitch (rp->header.flag & BT_TYPE) {\r\ncase BT_LEAF:\r\nif ((sp->header.flag & BT_ROOT && skip > 1) ||\r\nsp->header.prev != 0 || skip > 1) {\r\nrc = ciGetLeafPrefixKey(lp,\r\nlp->header.nextindex-1,\r\nrp, 0, &key,\r\nsbi->mntflag);\r\nif (rc) {\r\nDT_PUTPAGE(lmp);\r\nDT_PUTPAGE(rmp);\r\nDT_PUTPAGE(smp);\r\ngoto splitOut;\r\n}\r\n} else {\r\ndtGetKey(rp, 0, &key, sbi->mntflag);\r\nkey.name[key.namlen] = 0;\r\nif ((sbi->mntflag & JFS_OS2) == JFS_OS2)\r\nciToUpper(&key);\r\n}\r\nn = NDTINTERNAL(key.namlen);\r\nbreak;\r\ncase BT_INTERNAL:\r\ndtGetKey(rp, 0, &key, sbi->mntflag);\r\nn = NDTINTERNAL(key.namlen);\r\nbreak;\r\ndefault:\r\njfs_err("dtSplitUp(): UFO!");\r\nbreak;\r\n}\r\nDT_PUTPAGE(lmp);\r\ndata->xd = rpxd;\r\nif (n > sp->header.freecnt) {\r\nsplit->mp = smp;\r\nsplit->index = skip;\r\nsplit->nslot = n;\r\nsplit->key = &key;\r\nDT_PUTPAGE(rmp);\r\nrc = (sp->header.flag & BT_ROOT) ?\r\ndtSplitRoot(tid, ip, split, &rmp) :\r\ndtSplitPage(tid, ip, split, &rmp, &rp, &rpxd);\r\nif (rc) {\r\nDT_PUTPAGE(smp);\r\ngoto splitOut;\r\n}\r\n}\r\nelse {\r\nBT_MARK_DIRTY(smp, ip);\r\ntlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nASSERT(dtlck->index == 0);\r\nlv = & dtlck->lv[0];\r\nlv->offset = 0;\r\nlv->length = 1;\r\ndtlck->index++;\r\nif (!(sp->header.flag & BT_ROOT)) {\r\nlv++;\r\nn = skip >> L2DTSLOTSIZE;\r\nlv->offset = sp->header.stblindex + n;\r\nlv->length =\r\n((sp->header.nextindex -\r\n1) >> L2DTSLOTSIZE) - n + 1;\r\ndtlck->index++;\r\n}\r\ndtInsertEntry(sp, skip, &key, data, &dtlck);\r\nbreak;\r\n}\r\n}\r\nDT_PUTPAGE(smp);\r\nDT_PUTPAGE(rmp);\r\nsplitOut:\r\nn = pxdlist.npxd;\r\npxd = &pxdlist.pxd[n];\r\nfor (; n < pxdlist.maxnpxd; n++, pxd++)\r\ndbFree(ip, addressPXD(pxd), (s64) lengthPXD(pxd));\r\nfreeKeyName:\r\nkfree(key.name);\r\nif (rc && quota_allocation)\r\ndquot_free_block(ip, quota_allocation);\r\ndtSplitUp_Exit:\r\nreturn rc;\r\n}\r\nstatic int dtSplitPage(tid_t tid, struct inode *ip, struct dtsplit * split,\r\nstruct metapage ** rmpp, dtpage_t ** rpp, pxd_t * rpxdp)\r\n{\r\nint rc = 0;\r\nstruct metapage *smp;\r\ndtpage_t *sp;\r\nstruct metapage *rmp;\r\ndtpage_t *rp;\r\ns64 rbn;\r\nstruct metapage *mp;\r\ndtpage_t *p;\r\ns64 nextbn;\r\nstruct pxdlist *pxdlist;\r\npxd_t *pxd;\r\nint skip, nextindex, half, left, nxt, off, si;\r\nstruct ldtentry *ldtentry;\r\nstruct idtentry *idtentry;\r\nu8 *stbl;\r\nstruct dtslot *f;\r\nint fsi, stblsize;\r\nint n;\r\nstruct dt_lock *sdtlck, *rdtlck;\r\nstruct tlock *tlck;\r\nstruct dt_lock *dtlck;\r\nstruct lv *slv, *rlv, *lv;\r\nsmp = split->mp;\r\nsp = DT_PAGE(ip, smp);\r\npxdlist = split->pxdlist;\r\npxd = &pxdlist->pxd[pxdlist->npxd];\r\npxdlist->npxd++;\r\nrbn = addressPXD(pxd);\r\nrmp = get_metapage(ip, rbn, PSIZE, 1);\r\nif (rmp == NULL)\r\nreturn -EIO;\r\nrc = dquot_alloc_block(ip, lengthPXD(pxd));\r\nif (rc) {\r\nrelease_metapage(rmp);\r\nreturn rc;\r\n}\r\njfs_info("dtSplitPage: ip:0x%p smp:0x%p rmp:0x%p", ip, smp, rmp);\r\nBT_MARK_DIRTY(rmp, ip);\r\ntlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\r\nrdtlck = (struct dt_lock *) & tlck->lock;\r\nrp = (dtpage_t *) rmp->data;\r\n*rpp = rp;\r\nrp->header.self = *pxd;\r\nBT_MARK_DIRTY(smp, ip);\r\ntlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\r\nsdtlck = (struct dt_lock *) & tlck->lock;\r\nASSERT(sdtlck->index == 0);\r\nslv = & sdtlck->lv[0];\r\nslv->offset = 0;\r\nslv->length = 1;\r\nsdtlck->index++;\r\nnextbn = le64_to_cpu(sp->header.next);\r\nrp->header.next = cpu_to_le64(nextbn);\r\nrp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\r\nsp->header.next = cpu_to_le64(rbn);\r\nrp->header.flag = sp->header.flag;\r\nrp->header.nextindex = 0;\r\nrp->header.stblindex = 1;\r\nn = PSIZE >> L2DTSLOTSIZE;\r\nrp->header.maxslot = n;\r\nstblsize = (n + 31) >> L2DTSLOTSIZE;\r\nfsi = rp->header.stblindex + stblsize;\r\nrp->header.freelist = fsi;\r\nrp->header.freecnt = rp->header.maxslot - fsi;\r\nif (nextbn == 0 && split->index == sp->header.nextindex) {\r\nrlv = & rdtlck->lv[rdtlck->index];\r\nrlv->offset = 0;\r\nrlv->length = 2;\r\nrdtlck->index++;\r\nf = &rp->slot[fsi];\r\nfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\r\nf->next = fsi;\r\nf->next = -1;\r\ndtInsertEntry(rp, 0, split->key, split->data, &rdtlck);\r\ngoto out;\r\n}\r\nif (nextbn != 0) {\r\nDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\r\nif (rc) {\r\ndiscard_metapage(rmp);\r\nreturn rc;\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\r\njfs_info("dtSplitPage: tlck = 0x%p, ip = 0x%p, mp=0x%p",\r\ntlck, ip, mp);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nlv = & dtlck->lv[dtlck->index];\r\nlv->offset = 0;\r\nlv->length = 1;\r\ndtlck->index++;\r\np->header.prev = cpu_to_le64(rbn);\r\nDT_PUTPAGE(mp);\r\n}\r\nskip = split->index;\r\nhalf = (PSIZE >> L2DTSLOTSIZE) >> 1;\r\nleft = 0;\r\nstbl = (u8 *) & sp->slot[sp->header.stblindex];\r\nnextindex = sp->header.nextindex;\r\nfor (nxt = off = 0; nxt < nextindex; ++off) {\r\nif (off == skip)\r\nn = split->nslot;\r\nelse {\r\nsi = stbl[nxt];\r\nswitch (sp->header.flag & BT_TYPE) {\r\ncase BT_LEAF:\r\nldtentry = (struct ldtentry *) & sp->slot[si];\r\nif (DO_INDEX(ip))\r\nn = NDTLEAF(ldtentry->namlen);\r\nelse\r\nn = NDTLEAF_LEGACY(ldtentry->\r\nnamlen);\r\nbreak;\r\ncase BT_INTERNAL:\r\nidtentry = (struct idtentry *) & sp->slot[si];\r\nn = NDTINTERNAL(idtentry->namlen);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n++nxt;\r\n}\r\nleft += n;\r\nif (left >= half)\r\nbreak;\r\n}\r\nrlv = & rdtlck->lv[rdtlck->index];\r\nrlv->offset = 0;\r\nrlv->length = 5;\r\nrdtlck->index++;\r\ndtMoveEntry(sp, nxt, rp, &sdtlck, &rdtlck, DO_INDEX(ip));\r\nsp->header.nextindex = nxt;\r\nfsi = rp->header.freelist;\r\nf = &rp->slot[fsi];\r\nfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\r\nf->next = fsi;\r\nf->next = -1;\r\nif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\r\ns64 lblock;\r\nmp = NULL;\r\nstbl = DT_GETSTBL(rp);\r\nfor (n = 0; n < rp->header.nextindex; n++) {\r\nldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\r\nmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\r\nrbn, n, &mp, &lblock);\r\n}\r\nif (mp)\r\nrelease_metapage(mp);\r\n}\r\nif (skip <= off) {\r\ndtInsertEntry(sp, skip, split->key, split->data, &sdtlck);\r\nif (sdtlck->index >= sdtlck->maxcnt)\r\nsdtlck = (struct dt_lock *) txLinelock(sdtlck);\r\nslv = & sdtlck->lv[sdtlck->index];\r\nn = skip >> L2DTSLOTSIZE;\r\nslv->offset = sp->header.stblindex + n;\r\nslv->length =\r\n((sp->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\r\nsdtlck->index++;\r\n}\r\nelse {\r\nskip -= nxt;\r\ndtInsertEntry(rp, skip, split->key, split->data, &rdtlck);\r\n}\r\nout:\r\n*rmpp = rmp;\r\n*rpxdp = *pxd;\r\nreturn rc;\r\n}\r\nstatic int dtExtendPage(tid_t tid,\r\nstruct inode *ip, struct dtsplit * split, struct btstack * btstack)\r\n{\r\nstruct super_block *sb = ip->i_sb;\r\nint rc;\r\nstruct metapage *smp, *pmp, *mp;\r\ndtpage_t *sp, *pp;\r\nstruct pxdlist *pxdlist;\r\npxd_t *pxd, *tpxd;\r\nint xlen, xsize;\r\nint newstblindex, newstblsize;\r\nint oldstblindex, oldstblsize;\r\nint fsi, last;\r\nstruct dtslot *f;\r\nstruct btframe *parent;\r\nint n;\r\nstruct dt_lock *dtlck;\r\ns64 xaddr, txaddr;\r\nstruct tlock *tlck;\r\nstruct pxd_lock *pxdlock;\r\nstruct lv *lv;\r\nuint type;\r\nstruct ldtentry *ldtentry;\r\nu8 *stbl;\r\nsmp = split->mp;\r\nsp = DT_PAGE(ip, smp);\r\nparent = BT_POP(btstack);\r\nDT_GETPAGE(ip, parent->bn, pmp, PSIZE, pp, rc);\r\nif (rc)\r\nreturn (rc);\r\npxdlist = split->pxdlist;\r\npxd = &pxdlist->pxd[pxdlist->npxd];\r\npxdlist->npxd++;\r\nxaddr = addressPXD(pxd);\r\ntpxd = &sp->header.self;\r\ntxaddr = addressPXD(tpxd);\r\nif (xaddr == txaddr) {\r\ntype = tlckEXTEND;\r\n}\r\nelse {\r\ntype = tlckNEW;\r\ntlck = txMaplock(tid, ip, tlckDTREE | tlckRELOCATE);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\npxdlock->flag = mlckFREEPXD;\r\npxdlock->pxd = sp->header.self;\r\npxdlock->index = 1;\r\nif (DO_INDEX(ip)) {\r\ns64 lblock;\r\nmp = NULL;\r\nstbl = DT_GETSTBL(sp);\r\nfor (n = 0; n < sp->header.nextindex; n++) {\r\nldtentry =\r\n(struct ldtentry *) & sp->slot[stbl[n]];\r\nmodify_index(tid, ip,\r\nle32_to_cpu(ldtentry->index),\r\nxaddr, n, &mp, &lblock);\r\n}\r\nif (mp)\r\nrelease_metapage(mp);\r\n}\r\n}\r\nsp->header.self = *pxd;\r\njfs_info("dtExtendPage: ip:0x%p smp:0x%p sp:0x%p", ip, smp, sp);\r\nBT_MARK_DIRTY(smp, ip);\r\ntlck = txLock(tid, ip, smp, tlckDTREE | type);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nlv = & dtlck->lv[0];\r\nxlen = lengthPXD(pxd);\r\nxsize = xlen << JFS_SBI(sb)->l2bsize;\r\noldstblindex = sp->header.stblindex;\r\noldstblsize = (sp->header.maxslot + 31) >> L2DTSLOTSIZE;\r\nnewstblindex = sp->header.maxslot;\r\nn = xsize >> L2DTSLOTSIZE;\r\nnewstblsize = (n + 31) >> L2DTSLOTSIZE;\r\nmemcpy(&sp->slot[newstblindex], &sp->slot[oldstblindex],\r\nsp->header.nextindex);\r\nif (type == tlckEXTEND) {\r\nlv->offset = 0;\r\nlv->length = 1;\r\ndtlck->index++;\r\nlv++;\r\nlv->offset = newstblindex;\r\nlv->length = newstblsize;\r\n}\r\nelse {\r\nlv->offset = 0;\r\nlv->length = sp->header.maxslot + newstblsize;\r\n}\r\ndtlck->index++;\r\nsp->header.maxslot = n;\r\nsp->header.stblindex = newstblindex;\r\nfsi = oldstblindex;\r\nf = &sp->slot[fsi];\r\nlast = sp->header.freelist;\r\nfor (n = 0; n < oldstblsize; n++, fsi++, f++) {\r\nf->next = last;\r\nlast = fsi;\r\n}\r\nsp->header.freelist = last;\r\nsp->header.freecnt += oldstblsize;\r\nfsi = n = newstblindex + newstblsize;\r\nf = &sp->slot[fsi];\r\nfor (fsi++; fsi < sp->header.maxslot; f++, fsi++)\r\nf->next = fsi;\r\nf->next = -1;\r\nfsi = sp->header.freelist;\r\nif (fsi == -1)\r\nsp->header.freelist = n;\r\nelse {\r\ndo {\r\nf = &sp->slot[fsi];\r\nfsi = f->next;\r\n} while (fsi != -1);\r\nf->next = n;\r\n}\r\nsp->header.freecnt += sp->header.maxslot - n;\r\ndtInsertEntry(sp, split->index, split->key, split->data, &dtlck);\r\nBT_MARK_DIRTY(pmp, ip);\r\nif (type == tlckEXTEND) {\r\nn = sp->header.maxslot >> 2;\r\nif (sp->header.freelist < n)\r\ndtLinelockFreelist(sp, n, &dtlck);\r\n}\r\ntlck = txLock(tid, ip, pmp, tlckDTREE | tlckENTRY);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nlv = & dtlck->lv[dtlck->index];\r\nlv->offset = 1;\r\nlv->length = 1;\r\ndtlck->index++;\r\ntpxd = (pxd_t *) & pp->slot[1];\r\n*tpxd = *pxd;\r\nDT_PUTPAGE(pmp);\r\nreturn 0;\r\n}\r\nstatic int dtSplitRoot(tid_t tid,\r\nstruct inode *ip, struct dtsplit * split, struct metapage ** rmpp)\r\n{\r\nstruct super_block *sb = ip->i_sb;\r\nstruct metapage *smp;\r\ndtroot_t *sp;\r\nstruct metapage *rmp;\r\ndtpage_t *rp;\r\ns64 rbn;\r\nint xlen;\r\nint xsize;\r\nstruct dtslot *f;\r\ns8 *stbl;\r\nint fsi, stblsize, n;\r\nstruct idtentry *s;\r\npxd_t *ppxd;\r\nstruct pxdlist *pxdlist;\r\npxd_t *pxd;\r\nstruct dt_lock *dtlck;\r\nstruct tlock *tlck;\r\nstruct lv *lv;\r\nint rc;\r\nsmp = split->mp;\r\nsp = &JFS_IP(ip)->i_dtroot;\r\npxdlist = split->pxdlist;\r\npxd = &pxdlist->pxd[pxdlist->npxd];\r\npxdlist->npxd++;\r\nrbn = addressPXD(pxd);\r\nxlen = lengthPXD(pxd);\r\nxsize = xlen << JFS_SBI(sb)->l2bsize;\r\nrmp = get_metapage(ip, rbn, xsize, 1);\r\nif (!rmp)\r\nreturn -EIO;\r\nrp = rmp->data;\r\nrc = dquot_alloc_block(ip, lengthPXD(pxd));\r\nif (rc) {\r\nrelease_metapage(rmp);\r\nreturn rc;\r\n}\r\nBT_MARK_DIRTY(rmp, ip);\r\ntlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nrp->header.flag =\r\n(sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\r\nrp->header.self = *pxd;\r\nrp->header.next = 0;\r\nrp->header.prev = 0;\r\nASSERT(dtlck->index == 0);\r\nlv = & dtlck->lv[0];\r\nlv->offset = 0;\r\nlv->length = 10;\r\ndtlck->index++;\r\nn = xsize >> L2DTSLOTSIZE;\r\nrp->header.maxslot = n;\r\nstblsize = (n + 31) >> L2DTSLOTSIZE;\r\nrp->header.stblindex = DTROOTMAXSLOT;\r\nstbl = (s8 *) & rp->slot[DTROOTMAXSLOT];\r\nmemcpy(stbl, sp->header.stbl, sp->header.nextindex);\r\nrp->header.nextindex = sp->header.nextindex;\r\nmemcpy(&rp->slot[1], &sp->slot[1], IDATASIZE);\r\nfsi = n = DTROOTMAXSLOT + stblsize;\r\nf = &rp->slot[fsi];\r\nfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\r\nf->next = fsi;\r\nf->next = -1;\r\nfsi = sp->header.freelist;\r\nif (fsi == -1)\r\nrp->header.freelist = n;\r\nelse {\r\nrp->header.freelist = fsi;\r\ndo {\r\nf = &rp->slot[fsi];\r\nfsi = f->next;\r\n} while (fsi != -1);\r\nf->next = n;\r\n}\r\nrp->header.freecnt = sp->header.freecnt + rp->header.maxslot - n;\r\nif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\r\ns64 lblock;\r\nstruct metapage *mp = NULL;\r\nstruct ldtentry *ldtentry;\r\nstbl = DT_GETSTBL(rp);\r\nfor (n = 0; n < rp->header.nextindex; n++) {\r\nldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\r\nmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\r\nrbn, n, &mp, &lblock);\r\n}\r\nif (mp)\r\nrelease_metapage(mp);\r\n}\r\ndtInsertEntry(rp, split->index, split->key, split->data, &dtlck);\r\nBT_MARK_DIRTY(smp, ip);\r\ntlck = txLock(tid, ip, smp, tlckDTREE | tlckNEW | tlckBTROOT);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nASSERT(dtlck->index == 0);\r\nlv = & dtlck->lv[0];\r\nlv->offset = 0;\r\nlv->length = DTROOTMAXSLOT;\r\ndtlck->index++;\r\nif (sp->header.flag & BT_LEAF) {\r\nsp->header.flag &= ~BT_LEAF;\r\nsp->header.flag |= BT_INTERNAL;\r\n}\r\ns = (struct idtentry *) & sp->slot[DTENTRYSTART];\r\nppxd = (pxd_t *) s;\r\n*ppxd = *pxd;\r\ns->next = -1;\r\ns->namlen = 0;\r\nstbl = sp->header.stbl;\r\nstbl[0] = DTENTRYSTART;\r\nsp->header.nextindex = 1;\r\nfsi = DTENTRYSTART + 1;\r\nf = &sp->slot[fsi];\r\nfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\r\nf->next = fsi;\r\nf->next = -1;\r\nsp->header.freelist = DTENTRYSTART + 1;\r\nsp->header.freecnt = DTROOTMAXSLOT - (DTENTRYSTART + 1);\r\n*rmpp = rmp;\r\nreturn 0;\r\n}\r\nint dtDelete(tid_t tid,\r\nstruct inode *ip, struct component_name * key, ino_t * ino, int flag)\r\n{\r\nint rc = 0;\r\ns64 bn;\r\nstruct metapage *mp, *imp;\r\ndtpage_t *p;\r\nint index;\r\nstruct btstack btstack;\r\nstruct dt_lock *dtlck;\r\nstruct tlock *tlck;\r\nstruct lv *lv;\r\nint i;\r\nstruct ldtentry *ldtentry;\r\nu8 *stbl;\r\nu32 table_index, next_index;\r\nstruct metapage *nmp;\r\ndtpage_t *np;\r\nif ((rc = dtSearch(ip, key, ino, &btstack, flag)))\r\nreturn rc;\r\nDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\nif (DO_INDEX(ip)) {\r\nstbl = DT_GETSTBL(p);\r\nldtentry = (struct ldtentry *) & p->slot[stbl[index]];\r\ntable_index = le32_to_cpu(ldtentry->index);\r\nif (index == (p->header.nextindex - 1)) {\r\nif ((p->header.flag & BT_ROOT)\r\n|| (p->header.next == 0))\r\nnext_index = -1;\r\nelse {\r\nDT_GETPAGE(ip, le64_to_cpu(p->header.next),\r\nnmp, PSIZE, np, rc);\r\nif (rc)\r\nnext_index = -1;\r\nelse {\r\nstbl = DT_GETSTBL(np);\r\nldtentry =\r\n(struct ldtentry *) & np->\r\nslot[stbl[0]];\r\nnext_index =\r\nle32_to_cpu(ldtentry->index);\r\nDT_PUTPAGE(nmp);\r\n}\r\n}\r\n} else {\r\nldtentry =\r\n(struct ldtentry *) & p->slot[stbl[index + 1]];\r\nnext_index = le32_to_cpu(ldtentry->index);\r\n}\r\nfree_index(tid, ip, table_index, next_index);\r\n}\r\nif (p->header.nextindex == 1) {\r\nrc = dtDeleteUp(tid, ip, mp, p, &btstack);\r\n}\r\nelse {\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[dtlck->index];\r\nlv->offset = 0;\r\nlv->length = 1;\r\ndtlck->index++;\r\nif (!(p->header.flag & BT_ROOT)) {\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[dtlck->index];\r\ni = index >> L2DTSLOTSIZE;\r\nlv->offset = p->header.stblindex + i;\r\nlv->length =\r\n((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\r\ni + 1;\r\ndtlck->index++;\r\n}\r\ndtDeleteEntry(p, index, &dtlck);\r\nif (DO_INDEX(ip) && index < p->header.nextindex) {\r\ns64 lblock;\r\nimp = NULL;\r\nstbl = DT_GETSTBL(p);\r\nfor (i = index; i < p->header.nextindex; i++) {\r\nldtentry =\r\n(struct ldtentry *) & p->slot[stbl[i]];\r\nmodify_index(tid, ip,\r\nle32_to_cpu(ldtentry->index),\r\nbn, i, &imp, &lblock);\r\n}\r\nif (imp)\r\nrelease_metapage(imp);\r\n}\r\nDT_PUTPAGE(mp);\r\n}\r\nreturn rc;\r\n}\r\nstatic int dtDeleteUp(tid_t tid, struct inode *ip,\r\nstruct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\r\n{\r\nint rc = 0;\r\nstruct metapage *mp;\r\ndtpage_t *p;\r\nint index, nextindex;\r\nint xlen;\r\nstruct btframe *parent;\r\nstruct dt_lock *dtlck;\r\nstruct tlock *tlck;\r\nstruct lv *lv;\r\nstruct pxd_lock *pxdlock;\r\nint i;\r\nif (BT_IS_ROOT(fmp)) {\r\ndtInitRoot(tid, ip, PARENT(ip));\r\nDT_PUTPAGE(fmp);\r\nreturn 0;\r\n}\r\ntlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\npxdlock->flag = mlckFREEPXD;\r\npxdlock->pxd = fp->header.self;\r\npxdlock->index = 1;\r\nif ((rc = dtRelink(tid, ip, fp))) {\r\nBT_PUTPAGE(fmp);\r\nreturn rc;\r\n}\r\nxlen = lengthPXD(&fp->header.self);\r\ndquot_free_block(ip, xlen);\r\ndiscard_metapage(fmp);\r\nwhile ((parent = BT_POP(btstack)) != NULL) {\r\nDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nindex = parent->index;\r\nnextindex = p->header.nextindex;\r\nif (nextindex == 1) {\r\nif (p->header.flag & BT_ROOT) {\r\ndtInitRoot(tid, ip, PARENT(ip));\r\nDT_PUTPAGE(mp);\r\nreturn 0;\r\n}\r\nelse {\r\ntlck =\r\ntxMaplock(tid, ip,\r\ntlckDTREE | tlckFREE);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\npxdlock->flag = mlckFREEPXD;\r\npxdlock->pxd = p->header.self;\r\npxdlock->index = 1;\r\nif ((rc = dtRelink(tid, ip, p))) {\r\nDT_PUTPAGE(mp);\r\nreturn rc;\r\n}\r\nxlen = lengthPXD(&p->header.self);\r\ndquot_free_block(ip, xlen);\r\ndiscard_metapage(mp);\r\ncontinue;\r\n}\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[dtlck->index];\r\nlv->offset = 0;\r\nlv->length = 1;\r\ndtlck->index++;\r\nif (!(p->header.flag & BT_ROOT)) {\r\nif (dtlck->index < dtlck->maxcnt)\r\nlv++;\r\nelse {\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[0];\r\n}\r\ni = index >> L2DTSLOTSIZE;\r\nlv->offset = p->header.stblindex + i;\r\nlv->length =\r\n((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\r\ni + 1;\r\ndtlck->index++;\r\n}\r\ndtDeleteEntry(p, index, &dtlck);\r\nif (index == 0 &&\r\n((p->header.flag & BT_ROOT) || p->header.prev == 0))\r\ndtTruncateEntry(p, 0, &dtlck);\r\nDT_PUTPAGE(mp);\r\nbreak;\r\n}\r\nif (!DO_INDEX(ip))\r\nip->i_size -= PSIZE;\r\nreturn 0;\r\n}\r\nint dtRelocate(tid_t tid, struct inode *ip, s64 lmxaddr, pxd_t * opxd,\r\ns64 nxaddr)\r\n{\r\nint rc = 0;\r\nstruct metapage *mp, *pmp, *lmp, *rmp;\r\ndtpage_t *p, *pp, *rp = 0, *lp= 0;\r\ns64 bn;\r\nint index;\r\nstruct btstack btstack;\r\npxd_t *pxd;\r\ns64 oxaddr, nextbn, prevbn;\r\nint xlen, xsize;\r\nstruct tlock *tlck;\r\nstruct dt_lock *dtlck;\r\nstruct pxd_lock *pxdlock;\r\ns8 *stbl;\r\nstruct lv *lv;\r\noxaddr = addressPXD(opxd);\r\nxlen = lengthPXD(opxd);\r\njfs_info("dtRelocate: lmxaddr:%Ld xaddr:%Ld:%Ld xlen:%d",\r\n(long long)lmxaddr, (long long)oxaddr, (long long)nxaddr,\r\nxlen);\r\nrc = dtSearchNode(ip, lmxaddr, opxd, &btstack);\r\nif (rc)\r\nreturn rc;\r\nDT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\r\njfs_info("dtRelocate: parent router entry validated.");\r\nDT_GETPAGE(ip, oxaddr, mp, PSIZE, p, rc);\r\nif (rc) {\r\nDT_PUTPAGE(pmp);\r\nreturn rc;\r\n}\r\nrmp = NULL;\r\nif (p->header.next) {\r\nnextbn = le64_to_cpu(p->header.next);\r\nDT_GETPAGE(ip, nextbn, rmp, PSIZE, rp, rc);\r\nif (rc) {\r\nDT_PUTPAGE(mp);\r\nDT_PUTPAGE(pmp);\r\nreturn (rc);\r\n}\r\n}\r\nlmp = NULL;\r\nif (p->header.prev) {\r\nprevbn = le64_to_cpu(p->header.prev);\r\nDT_GETPAGE(ip, prevbn, lmp, PSIZE, lp, rc);\r\nif (rc) {\r\nDT_PUTPAGE(mp);\r\nDT_PUTPAGE(pmp);\r\nif (rmp)\r\nDT_PUTPAGE(rmp);\r\nreturn (rc);\r\n}\r\n}\r\nif (lmp) {\r\ntlck = txLock(tid, ip, lmp, tlckDTREE | tlckRELINK);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nASSERT(dtlck->index == 0);\r\nlv = & dtlck->lv[0];\r\nlv->offset = 0;\r\nlv->length = 1;\r\ndtlck->index++;\r\nlp->header.next = cpu_to_le64(nxaddr);\r\nDT_PUTPAGE(lmp);\r\n}\r\nif (rmp) {\r\ntlck = txLock(tid, ip, rmp, tlckDTREE | tlckRELINK);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nASSERT(dtlck->index == 0);\r\nlv = & dtlck->lv[0];\r\nlv->offset = 0;\r\nlv->length = 1;\r\ndtlck->index++;\r\nrp->header.prev = cpu_to_le64(nxaddr);\r\nDT_PUTPAGE(rmp);\r\n}\r\ntlck = txLock(tid, ip, mp, tlckDTREE | tlckNEW);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nASSERT(dtlck->index == 0);\r\nlv = & dtlck->lv[0];\r\npxd = &p->header.self;\r\nPXDaddress(pxd, nxaddr);\r\nlv->offset = 0;\r\nlv->length = p->header.maxslot;\r\ndtlck->index++;\r\nxsize = xlen << JFS_SBI(ip->i_sb)->l2bsize;\r\nDT_PUTPAGE(mp);\r\njfs_info("dtRelocate: target dtpage relocated.");\r\ntlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\npxdlock->flag = mlckFREEPXD;\r\nPXDaddress(&pxdlock->pxd, oxaddr);\r\nPXDlength(&pxdlock->pxd, xlen);\r\npxdlock->index = 1;\r\njfs_info("dtRelocate: update parent router entry.");\r\ntlck = txLock(tid, ip, pmp, tlckDTREE | tlckENTRY);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nlv = & dtlck->lv[dtlck->index];\r\nstbl = DT_GETSTBL(pp);\r\npxd = (pxd_t *) & pp->slot[stbl[index]];\r\nPXDaddress(pxd, nxaddr);\r\nlv->offset = stbl[index];\r\nlv->length = 1;\r\ndtlck->index++;\r\nDT_PUTPAGE(pmp);\r\nreturn rc;\r\n}\r\nstatic int dtSearchNode(struct inode *ip, s64 lmxaddr, pxd_t * kpxd,\r\nstruct btstack * btstack)\r\n{\r\nint rc = 0;\r\ns64 bn;\r\nstruct metapage *mp;\r\ndtpage_t *p;\r\nint psize = 288;\r\ns8 *stbl;\r\nint i;\r\npxd_t *pxd;\r\nstruct btframe *btsp;\r\nBT_CLR(btstack);\r\nfor (bn = 0;;) {\r\nDT_GETPAGE(ip, bn, mp, psize, p, rc);\r\nif (rc)\r\nreturn rc;\r\nif (p->header.flag & BT_ROOT) {\r\nif (lmxaddr == 0)\r\nbreak;\r\n} else if (addressPXD(&p->header.self) == lmxaddr)\r\nbreak;\r\nif (p->header.flag & BT_LEAF) {\r\nDT_PUTPAGE(mp);\r\nreturn -ESTALE;\r\n}\r\nstbl = DT_GETSTBL(p);\r\npxd = (pxd_t *) & p->slot[stbl[0]];\r\nbn = addressPXD(pxd);\r\npsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\r\nDT_PUTPAGE(mp);\r\n}\r\nloop:\r\nstbl = DT_GETSTBL(p);\r\nfor (i = 0; i < p->header.nextindex; i++) {\r\npxd = (pxd_t *) & p->slot[stbl[i]];\r\nif (addressPXD(pxd) == addressPXD(kpxd) &&\r\nlengthPXD(pxd) == lengthPXD(kpxd)) {\r\nbtsp = btstack->top;\r\nbtsp->bn = bn;\r\nbtsp->index = i;\r\nbtsp->mp = mp;\r\nreturn 0;\r\n}\r\n}\r\nif (p->header.next)\r\nbn = le64_to_cpu(p->header.next);\r\nelse {\r\nDT_PUTPAGE(mp);\r\nreturn -ESTALE;\r\n}\r\nDT_PUTPAGE(mp);\r\nDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\ngoto loop;\r\n}\r\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p)\r\n{\r\nint rc;\r\nstruct metapage *mp;\r\ns64 nextbn, prevbn;\r\nstruct tlock *tlck;\r\nstruct dt_lock *dtlck;\r\nstruct lv *lv;\r\nnextbn = le64_to_cpu(p->header.next);\r\nprevbn = le64_to_cpu(p->header.prev);\r\nif (nextbn != 0) {\r\nDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\r\njfs_info("dtRelink nextbn: tlck = 0x%p, ip = 0x%p, mp=0x%p",\r\ntlck, ip, mp);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[dtlck->index];\r\nlv->offset = 0;\r\nlv->length = 1;\r\ndtlck->index++;\r\np->header.prev = cpu_to_le64(prevbn);\r\nDT_PUTPAGE(mp);\r\n}\r\nif (prevbn != 0) {\r\nDT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\r\njfs_info("dtRelink prevbn: tlck = 0x%p, ip = 0x%p, mp=0x%p",\r\ntlck, ip, mp);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[dtlck->index];\r\nlv->offset = 0;\r\nlv->length = 1;\r\ndtlck->index++;\r\np->header.next = cpu_to_le64(nextbn);\r\nDT_PUTPAGE(mp);\r\n}\r\nreturn 0;\r\n}\r\nvoid dtInitRoot(tid_t tid, struct inode *ip, u32 idotdot)\r\n{\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\ndtroot_t *p;\r\nint fsi;\r\nstruct dtslot *f;\r\nstruct tlock *tlck;\r\nstruct dt_lock *dtlck;\r\nstruct lv *lv;\r\nu16 xflag_save;\r\nif (DO_INDEX(ip)) {\r\nif (!jfs_dirtable_inline(ip)) {\r\nstruct tblock *tblk = tid_to_tblock(tid);\r\nxflag_save = tblk->xflag;\r\ntblk->xflag = 0;\r\nxtTruncate(tid, ip, 0, COMMIT_PWMAP);\r\nset_cflag(COMMIT_Stale, ip);\r\ntblk->xflag = xflag_save;\r\n} else\r\nip->i_size = 1;\r\njfs_ip->next_index = 2;\r\n} else\r\nip->i_size = IDATASIZE;\r\ntlck = txLock(tid, ip, (struct metapage *) & jfs_ip->bxflag,\r\ntlckDTREE | tlckENTRY | tlckBTROOT);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nASSERT(dtlck->index == 0);\r\nlv = & dtlck->lv[0];\r\nlv->offset = 0;\r\nlv->length = DTROOTMAXSLOT;\r\ndtlck->index++;\r\np = &jfs_ip->i_dtroot;\r\np->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\r\np->header.nextindex = 0;\r\nfsi = 1;\r\nf = &p->slot[fsi];\r\nfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\r\nf->next = fsi;\r\nf->next = -1;\r\np->header.freelist = 1;\r\np->header.freecnt = 8;\r\np->header.idotdot = cpu_to_le32(idotdot);\r\nreturn;\r\n}\r\nstatic void add_missing_indices(struct inode *inode, s64 bn)\r\n{\r\nstruct ldtentry *d;\r\nstruct dt_lock *dtlck;\r\nint i;\r\nuint index;\r\nstruct lv *lv;\r\nstruct metapage *mp;\r\ndtpage_t *p;\r\nint rc;\r\ns8 *stbl;\r\ntid_t tid;\r\nstruct tlock *tlck;\r\ntid = txBegin(inode->i_sb, 0);\r\nDT_GETPAGE(inode, bn, mp, PSIZE, p, rc);\r\nif (rc) {\r\nprintk(KERN_ERR "DT_GETPAGE failed!\n");\r\ngoto end;\r\n}\r\nBT_MARK_DIRTY(mp, inode);\r\nASSERT(p->header.flag & BT_LEAF);\r\ntlck = txLock(tid, inode, mp, tlckDTREE | tlckENTRY);\r\nif (BT_IS_ROOT(mp))\r\ntlck->type |= tlckBTROOT;\r\ndtlck = (struct dt_lock *) &tlck->lock;\r\nstbl = DT_GETSTBL(p);\r\nfor (i = 0; i < p->header.nextindex; i++) {\r\nd = (struct ldtentry *) &p->slot[stbl[i]];\r\nindex = le32_to_cpu(d->index);\r\nif ((index < 2) || (index >= JFS_IP(inode)->next_index)) {\r\nd->index = cpu_to_le32(add_index(tid, inode, bn, i));\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = &dtlck->lv[dtlck->index];\r\nlv->offset = stbl[i];\r\nlv->length = 1;\r\ndtlck->index++;\r\n}\r\n}\r\nDT_PUTPAGE(mp);\r\n(void) txCommit(tid, 1, &inode, 0);\r\nend:\r\ntxEnd(tid);\r\n}\r\nstatic inline struct jfs_dirent *next_jfs_dirent(struct jfs_dirent *dirent)\r\n{\r\nreturn (struct jfs_dirent *)\r\n((char *)dirent +\r\n((sizeof (struct jfs_dirent) + dirent->name_len + 1 +\r\nsizeof (loff_t) - 1) &\r\n~(sizeof (loff_t) - 1)));\r\n}\r\nint jfs_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nstruct inode *ip = file_inode(file);\r\nstruct nls_table *codepage = JFS_SBI(ip->i_sb)->nls_tab;\r\nint rc = 0;\r\nloff_t dtpos;\r\nstruct dtoffset {\r\ns16 pn;\r\ns16 index;\r\ns32 unused;\r\n} *dtoffset = (struct dtoffset *) &dtpos;\r\ns64 bn;\r\nstruct metapage *mp;\r\ndtpage_t *p;\r\nint index;\r\ns8 *stbl;\r\nstruct btstack btstack;\r\nint i, next;\r\nstruct ldtentry *d;\r\nstruct dtslot *t;\r\nint d_namleft, len, outlen;\r\nunsigned long dirent_buf;\r\nchar *name_ptr;\r\nu32 dir_index;\r\nint do_index = 0;\r\nuint loop_count = 0;\r\nstruct jfs_dirent *jfs_dirent;\r\nint jfs_dirents;\r\nint overflow, fix_page, page_fixed = 0;\r\nstatic int unique_pos = 2;\r\nif (ctx->pos == DIREND)\r\nreturn 0;\r\nif (DO_INDEX(ip)) {\r\ndo_index = 1;\r\ndir_index = (u32) ctx->pos;\r\nif (dir_index)\r\ndir_index--;\r\nif (dir_index > 1) {\r\nstruct dir_table_slot dirtab_slot;\r\nif (dtEmpty(ip) ||\r\n(dir_index >= JFS_IP(ip)->next_index)) {\r\nctx->pos = DIREND;\r\nreturn 0;\r\n}\r\nrepeat:\r\nrc = read_index(ip, dir_index, &dirtab_slot);\r\nif (rc) {\r\nctx->pos = DIREND;\r\nreturn rc;\r\n}\r\nif (dirtab_slot.flag == DIR_INDEX_FREE) {\r\nif (loop_count++ > JFS_IP(ip)->next_index) {\r\njfs_err("jfs_readdir detected "\r\n"infinite loop!");\r\nctx->pos = DIREND;\r\nreturn 0;\r\n}\r\ndir_index = le32_to_cpu(dirtab_slot.addr2);\r\nif (dir_index == -1) {\r\nctx->pos = DIREND;\r\nreturn 0;\r\n}\r\ngoto repeat;\r\n}\r\nbn = addressDTS(&dirtab_slot);\r\nindex = dirtab_slot.slot;\r\nDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc) {\r\nctx->pos = DIREND;\r\nreturn 0;\r\n}\r\nif (p->header.flag & BT_INTERNAL) {\r\njfs_err("jfs_readdir: bad index table");\r\nDT_PUTPAGE(mp);\r\nctx->pos = DIREND;\r\nreturn 0;\r\n}\r\n} else {\r\nif (dir_index == 0) {\r\nctx->pos = 1;\r\nif (!dir_emit(ctx, ".", 1, ip->i_ino, DT_DIR))\r\nreturn 0;\r\n}\r\nctx->pos = 2;\r\nif (!dir_emit(ctx, "..", 2, PARENT(ip), DT_DIR))\r\nreturn 0;\r\nif (dtEmpty(ip)) {\r\nctx->pos = DIREND;\r\nreturn 0;\r\n}\r\nif ((rc = dtReadFirst(ip, &btstack)))\r\nreturn rc;\r\nDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\n}\r\n} else {\r\ndtpos = ctx->pos;\r\nif (dtpos < 2) {\r\nctx->pos = 1;\r\nif (!dir_emit(ctx, ".", 1, ip->i_ino, DT_DIR))\r\nreturn 0;\r\ndtoffset->index = 2;\r\nctx->pos = dtpos;\r\n}\r\nif (dtoffset->pn == 0) {\r\nif (dtoffset->index == 2) {\r\nif (!dir_emit(ctx, "..", 2, PARENT(ip), DT_DIR))\r\nreturn 0;\r\n} else {\r\njfs_err("jfs_readdir called with "\r\n"invalid offset!");\r\n}\r\ndtoffset->pn = 1;\r\ndtoffset->index = 0;\r\nctx->pos = dtpos;\r\n}\r\nif (dtEmpty(ip)) {\r\nctx->pos = DIREND;\r\nreturn 0;\r\n}\r\nif ((rc = dtReadNext(ip, &ctx->pos, &btstack))) {\r\njfs_err("jfs_readdir: unexpected rc = %d "\r\n"from dtReadNext", rc);\r\nctx->pos = DIREND;\r\nreturn 0;\r\n}\r\nDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\nif (bn < 0) {\r\nctx->pos = DIREND;\r\nreturn 0;\r\n}\r\n}\r\ndirent_buf = __get_free_page(GFP_KERNEL);\r\nif (dirent_buf == 0) {\r\nDT_PUTPAGE(mp);\r\njfs_warn("jfs_readdir: __get_free_page failed!");\r\nctx->pos = DIREND;\r\nreturn -ENOMEM;\r\n}\r\nwhile (1) {\r\njfs_dirent = (struct jfs_dirent *) dirent_buf;\r\njfs_dirents = 0;\r\noverflow = fix_page = 0;\r\nstbl = DT_GETSTBL(p);\r\nfor (i = index; i < p->header.nextindex; i++) {\r\nd = (struct ldtentry *) & p->slot[stbl[i]];\r\nif (((long) jfs_dirent + d->namlen + 1) >\r\n(dirent_buf + PAGE_SIZE)) {\r\nindex = i;\r\noverflow = 1;\r\nbreak;\r\n}\r\nd_namleft = d->namlen;\r\nname_ptr = jfs_dirent->name;\r\njfs_dirent->ino = le32_to_cpu(d->inumber);\r\nif (do_index) {\r\nlen = min(d_namleft, DTLHDRDATALEN);\r\njfs_dirent->position = le32_to_cpu(d->index);\r\nif ((jfs_dirent->position < 2) ||\r\n(jfs_dirent->position >=\r\nJFS_IP(ip)->next_index)) {\r\nif (!page_fixed && !isReadOnly(ip)) {\r\nfix_page = 1;\r\noverflow = 1;\r\nindex = i;\r\nbreak;\r\n}\r\njfs_dirent->position = unique_pos++;\r\n}\r\njfs_dirent->position++;\r\n} else {\r\njfs_dirent->position = dtpos;\r\nlen = min(d_namleft, DTLHDRDATALEN_LEGACY);\r\n}\r\noutlen = jfs_strfromUCS_le(name_ptr, d->name, len,\r\ncodepage);\r\njfs_dirent->name_len = outlen;\r\nnext = d->next;\r\nwhile (next >= 0) {\r\nt = (struct dtslot *) & p->slot[next];\r\nname_ptr += outlen;\r\nd_namleft -= len;\r\nif (d_namleft == 0) {\r\njfs_error(ip->i_sb,\r\n"JFS:Dtree error: ino = %ld, bn=%lld, index = %d\n",\r\n(long)ip->i_ino,\r\n(long long)bn,\r\ni);\r\ngoto skip_one;\r\n}\r\nlen = min(d_namleft, DTSLOTDATALEN);\r\noutlen = jfs_strfromUCS_le(name_ptr, t->name,\r\nlen, codepage);\r\njfs_dirent->name_len += outlen;\r\nnext = t->next;\r\n}\r\njfs_dirents++;\r\njfs_dirent = next_jfs_dirent(jfs_dirent);\r\nskip_one:\r\nif (!do_index)\r\ndtoffset->index++;\r\n}\r\nif (!overflow) {\r\nif (p->header.flag & BT_ROOT)\r\nbn = 0;\r\nelse {\r\nbn = le64_to_cpu(p->header.next);\r\nindex = 0;\r\nif (!do_index) {\r\ndtoffset->pn++;\r\ndtoffset->index = 0;\r\n}\r\n}\r\npage_fixed = 0;\r\n}\r\nDT_PUTPAGE(mp);\r\njfs_dirent = (struct jfs_dirent *) dirent_buf;\r\nwhile (jfs_dirents--) {\r\nctx->pos = jfs_dirent->position;\r\nif (!dir_emit(ctx, jfs_dirent->name,\r\njfs_dirent->name_len,\r\njfs_dirent->ino, DT_UNKNOWN))\r\ngoto out;\r\njfs_dirent = next_jfs_dirent(jfs_dirent);\r\n}\r\nif (fix_page) {\r\nadd_missing_indices(ip, bn);\r\npage_fixed = 1;\r\n}\r\nif (!overflow && (bn == 0)) {\r\nctx->pos = DIREND;\r\nbreak;\r\n}\r\nDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc) {\r\nfree_page(dirent_buf);\r\nreturn rc;\r\n}\r\n}\r\nout:\r\nfree_page(dirent_buf);\r\nreturn rc;\r\n}\r\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack)\r\n{\r\nint rc = 0;\r\ns64 bn;\r\nint psize = 288;\r\nstruct metapage *mp;\r\ndtpage_t *p;\r\ns8 *stbl;\r\nstruct btframe *btsp;\r\npxd_t *xd;\r\nBT_CLR(btstack);\r\nfor (bn = 0;;) {\r\nDT_GETPAGE(ip, bn, mp, psize, p, rc);\r\nif (rc)\r\nreturn rc;\r\nif (p->header.flag & BT_LEAF) {\r\nbtsp = btstack->top;\r\nbtsp->bn = bn;\r\nbtsp->index = 0;\r\nbtsp->mp = mp;\r\nreturn 0;\r\n}\r\nif (BT_STACK_FULL(btstack)) {\r\nDT_PUTPAGE(mp);\r\njfs_error(ip->i_sb, "btstack overrun\n");\r\nBT_STACK_DUMP(btstack);\r\nreturn -EIO;\r\n}\r\nBT_PUSH(btstack, bn, 0);\r\nstbl = DT_GETSTBL(p);\r\nxd = (pxd_t *) & p->slot[stbl[0]];\r\nbn = addressPXD(xd);\r\npsize = lengthPXD(xd) << JFS_SBI(ip->i_sb)->l2bsize;\r\nDT_PUTPAGE(mp);\r\n}\r\n}\r\nstatic int dtReadNext(struct inode *ip, loff_t * offset,\r\nstruct btstack * btstack)\r\n{\r\nint rc = 0;\r\nstruct dtoffset {\r\ns16 pn;\r\ns16 index;\r\ns32 unused;\r\n} *dtoffset = (struct dtoffset *) offset;\r\ns64 bn;\r\nstruct metapage *mp;\r\ndtpage_t *p;\r\nint index;\r\nint pn;\r\ns8 *stbl;\r\nstruct btframe *btsp, *parent;\r\npxd_t *xd;\r\nif ((rc = dtReadFirst(ip, btstack)))\r\nreturn rc;\r\nDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\r\npn = dtoffset->pn - 1;\r\nindex = dtoffset->index;\r\nif (pn == 0) {\r\nif (index < p->header.nextindex)\r\ngoto out;\r\nif (p->header.flag & BT_ROOT) {\r\nbn = -1;\r\ngoto out;\r\n}\r\ndtoffset->pn++;\r\ndtoffset->index = index = 0;\r\ngoto a;\r\n}\r\nif (p->header.flag & BT_ROOT) {\r\nbn = -1;\r\ngoto out;\r\n}\r\nif (pn > 1)\r\ngoto b;\r\na:\r\nbn = le64_to_cpu(p->header.next);\r\nDT_PUTPAGE(mp);\r\nif (bn == 0) {\r\nbn = -1;\r\ngoto out;\r\n}\r\ngoto c;\r\nb:\r\nDT_PUTPAGE(mp);\r\nbtsp = btstack->top;\r\nparent = btsp - 1;\r\nbn = parent->bn;\r\nDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nwhile (pn >= p->header.nextindex) {\r\npn -= p->header.nextindex;\r\nbn = le64_to_cpu(p->header.next);\r\nDT_PUTPAGE(mp);\r\nif (bn == 0) {\r\nbn = -1;\r\ngoto out;\r\n}\r\nDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nparent->bn = bn;\r\n}\r\nstbl = DT_GETSTBL(p);\r\nxd = (pxd_t *) & p->slot[stbl[pn]];\r\nbn = addressPXD(xd);\r\nDT_PUTPAGE(mp);\r\nc:\r\nDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nif (index >= p->header.nextindex) {\r\nbn = le64_to_cpu(p->header.next);\r\nDT_PUTPAGE(mp);\r\nif (bn == 0) {\r\nbn = -1;\r\ngoto out;\r\n}\r\nDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\ndtoffset->pn++;\r\ndtoffset->index = 0;\r\n}\r\nout:\r\nbtsp = btstack->top;\r\nbtsp->bn = bn;\r\nbtsp->index = dtoffset->index;\r\nbtsp->mp = mp;\r\nreturn 0;\r\n}\r\nstatic int dtCompare(struct component_name * key,\r\ndtpage_t * p,\r\nint si)\r\n{\r\nwchar_t *kname;\r\n__le16 *name;\r\nint klen, namlen, len, rc;\r\nstruct idtentry *ih;\r\nstruct dtslot *t;\r\nkname = key->name;\r\nklen = key->namlen;\r\nih = (struct idtentry *) & p->slot[si];\r\nsi = ih->next;\r\nname = ih->name;\r\nnamlen = ih->namlen;\r\nlen = min(namlen, DTIHDRDATALEN);\r\nlen = min(klen, len);\r\nif ((rc = UniStrncmp_le(kname, name, len)))\r\nreturn rc;\r\nklen -= len;\r\nnamlen -= len;\r\nkname += len;\r\nwhile (klen > 0 && namlen > 0) {\r\nt = (struct dtslot *) & p->slot[si];\r\nlen = min(namlen, DTSLOTDATALEN);\r\nlen = min(klen, len);\r\nname = t->name;\r\nif ((rc = UniStrncmp_le(kname, name, len)))\r\nreturn rc;\r\nklen -= len;\r\nnamlen -= len;\r\nkname += len;\r\nsi = t->next;\r\n}\r\nreturn (klen - namlen);\r\n}\r\nstatic int ciCompare(struct component_name * key,\r\ndtpage_t * p,\r\nint si,\r\nint flag)\r\n{\r\nwchar_t *kname, x;\r\n__le16 *name;\r\nint klen, namlen, len, rc;\r\nstruct ldtentry *lh;\r\nstruct idtentry *ih;\r\nstruct dtslot *t;\r\nint i;\r\nkname = key->name;\r\nklen = key->namlen;\r\nif (p->header.flag & BT_LEAF) {\r\nlh = (struct ldtentry *) & p->slot[si];\r\nsi = lh->next;\r\nname = lh->name;\r\nnamlen = lh->namlen;\r\nif (flag & JFS_DIR_INDEX)\r\nlen = min(namlen, DTLHDRDATALEN);\r\nelse\r\nlen = min(namlen, DTLHDRDATALEN_LEGACY);\r\n}\r\nelse {\r\nih = (struct idtentry *) & p->slot[si];\r\nsi = ih->next;\r\nname = ih->name;\r\nnamlen = ih->namlen;\r\nlen = min(namlen, DTIHDRDATALEN);\r\n}\r\nlen = min(klen, len);\r\nfor (i = 0; i < len; i++, kname++, name++) {\r\nif ((flag & JFS_OS2) == JFS_OS2)\r\nx = UniToupper(le16_to_cpu(*name));\r\nelse\r\nx = le16_to_cpu(*name);\r\nif ((rc = *kname - x))\r\nreturn rc;\r\n}\r\nklen -= len;\r\nnamlen -= len;\r\nwhile (klen > 0 && namlen > 0) {\r\nt = (struct dtslot *) & p->slot[si];\r\nlen = min(namlen, DTSLOTDATALEN);\r\nlen = min(klen, len);\r\nname = t->name;\r\nfor (i = 0; i < len; i++, kname++, name++) {\r\nif ((flag & JFS_OS2) == JFS_OS2)\r\nx = UniToupper(le16_to_cpu(*name));\r\nelse\r\nx = le16_to_cpu(*name);\r\nif ((rc = *kname - x))\r\nreturn rc;\r\n}\r\nklen -= len;\r\nnamlen -= len;\r\nsi = t->next;\r\n}\r\nreturn (klen - namlen);\r\n}\r\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\r\nint ri, struct component_name * key, int flag)\r\n{\r\nint klen, namlen;\r\nwchar_t *pl, *pr, *kname;\r\nstruct component_name lkey;\r\nstruct component_name rkey;\r\nlkey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t),\r\nGFP_KERNEL);\r\nif (lkey.name == NULL)\r\nreturn -ENOMEM;\r\nrkey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t),\r\nGFP_KERNEL);\r\nif (rkey.name == NULL) {\r\nkfree(lkey.name);\r\nreturn -ENOMEM;\r\n}\r\ndtGetKey(lp, li, &lkey, flag);\r\nlkey.name[lkey.namlen] = 0;\r\nif ((flag & JFS_OS2) == JFS_OS2)\r\nciToUpper(&lkey);\r\ndtGetKey(rp, ri, &rkey, flag);\r\nrkey.name[rkey.namlen] = 0;\r\nif ((flag & JFS_OS2) == JFS_OS2)\r\nciToUpper(&rkey);\r\nklen = 0;\r\nkname = key->name;\r\nnamlen = min(lkey.namlen, rkey.namlen);\r\nfor (pl = lkey.name, pr = rkey.name;\r\nnamlen; pl++, pr++, namlen--, klen++, kname++) {\r\n*kname = *pr;\r\nif (*pl != *pr) {\r\nkey->namlen = klen + 1;\r\ngoto free_names;\r\n}\r\n}\r\nif (lkey.namlen < rkey.namlen) {\r\n*kname = *pr;\r\nkey->namlen = klen + 1;\r\n} else\r\nkey->namlen = klen;\r\nfree_names:\r\nkfree(lkey.name);\r\nkfree(rkey.name);\r\nreturn 0;\r\n}\r\nstatic void dtGetKey(dtpage_t * p, int i,\r\nstruct component_name * key, int flag)\r\n{\r\nint si;\r\ns8 *stbl;\r\nstruct ldtentry *lh;\r\nstruct idtentry *ih;\r\nstruct dtslot *t;\r\nint namlen, len;\r\nwchar_t *kname;\r\n__le16 *name;\r\nstbl = DT_GETSTBL(p);\r\nsi = stbl[i];\r\nif (p->header.flag & BT_LEAF) {\r\nlh = (struct ldtentry *) & p->slot[si];\r\nsi = lh->next;\r\nnamlen = lh->namlen;\r\nname = lh->name;\r\nif (flag & JFS_DIR_INDEX)\r\nlen = min(namlen, DTLHDRDATALEN);\r\nelse\r\nlen = min(namlen, DTLHDRDATALEN_LEGACY);\r\n} else {\r\nih = (struct idtentry *) & p->slot[si];\r\nsi = ih->next;\r\nnamlen = ih->namlen;\r\nname = ih->name;\r\nlen = min(namlen, DTIHDRDATALEN);\r\n}\r\nkey->namlen = namlen;\r\nkname = key->name;\r\nUniStrncpy_from_le(kname, name, len);\r\nwhile (si >= 0) {\r\nt = &p->slot[si];\r\nkname += len;\r\nnamlen -= len;\r\nlen = min(namlen, DTSLOTDATALEN);\r\nUniStrncpy_from_le(kname, t->name, len);\r\nsi = t->next;\r\n}\r\n}\r\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\r\nddata_t * data, struct dt_lock ** dtlock)\r\n{\r\nstruct dtslot *h, *t;\r\nstruct ldtentry *lh = NULL;\r\nstruct idtentry *ih = NULL;\r\nint hsi, fsi, klen, len, nextindex;\r\nwchar_t *kname;\r\n__le16 *name;\r\ns8 *stbl;\r\npxd_t *xd;\r\nstruct dt_lock *dtlck = *dtlock;\r\nstruct lv *lv;\r\nint xsi, n;\r\ns64 bn = 0;\r\nstruct metapage *mp = NULL;\r\nklen = key->namlen;\r\nkname = key->name;\r\nhsi = fsi = p->header.freelist;\r\nh = &p->slot[fsi];\r\np->header.freelist = h->next;\r\n--p->header.freecnt;\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[dtlck->index];\r\nlv->offset = hsi;\r\nif (p->header.flag & BT_LEAF) {\r\nlh = (struct ldtentry *) h;\r\nlh->next = h->next;\r\nlh->inumber = cpu_to_le32(data->leaf.ino);\r\nlh->namlen = klen;\r\nname = lh->name;\r\nif (data->leaf.ip) {\r\nlen = min(klen, DTLHDRDATALEN);\r\nif (!(p->header.flag & BT_ROOT))\r\nbn = addressPXD(&p->header.self);\r\nlh->index = cpu_to_le32(add_index(data->leaf.tid,\r\ndata->leaf.ip,\r\nbn, index));\r\n} else\r\nlen = min(klen, DTLHDRDATALEN_LEGACY);\r\n} else {\r\nih = (struct idtentry *) h;\r\nih->next = h->next;\r\nxd = (pxd_t *) ih;\r\n*xd = data->xd;\r\nih->namlen = klen;\r\nname = ih->name;\r\nlen = min(klen, DTIHDRDATALEN);\r\n}\r\nUniStrncpy_to_le(name, kname, len);\r\nn = 1;\r\nxsi = hsi;\r\nt = h;\r\nklen -= len;\r\nwhile (klen) {\r\nfsi = p->header.freelist;\r\nt = &p->slot[fsi];\r\np->header.freelist = t->next;\r\n--p->header.freecnt;\r\nif (fsi != xsi + 1) {\r\nlv->length = n;\r\ndtlck->index++;\r\nif (dtlck->index < dtlck->maxcnt)\r\nlv++;\r\nelse {\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[0];\r\n}\r\nlv->offset = fsi;\r\nn = 0;\r\n}\r\nkname += len;\r\nlen = min(klen, DTSLOTDATALEN);\r\nUniStrncpy_to_le(t->name, kname, len);\r\nn++;\r\nxsi = fsi;\r\nklen -= len;\r\n}\r\nlv->length = n;\r\ndtlck->index++;\r\n*dtlock = dtlck;\r\nif (h == t) {\r\nif (p->header.flag & BT_LEAF)\r\nlh->next = -1;\r\nelse\r\nih->next = -1;\r\n} else\r\nt->next = -1;\r\nstbl = DT_GETSTBL(p);\r\nnextindex = p->header.nextindex;\r\nif (index < nextindex) {\r\nmemmove(stbl + index + 1, stbl + index, nextindex - index);\r\nif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\r\ns64 lblock;\r\nmp = NULL;\r\nfor (n = index + 1; n <= nextindex; n++) {\r\nlh = (struct ldtentry *) & (p->slot[stbl[n]]);\r\nmodify_index(data->leaf.tid, data->leaf.ip,\r\nle32_to_cpu(lh->index), bn, n,\r\n&mp, &lblock);\r\n}\r\nif (mp)\r\nrelease_metapage(mp);\r\n}\r\n}\r\nstbl[index] = hsi;\r\n++p->header.nextindex;\r\n}\r\nstatic void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\r\nstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\r\nint do_index)\r\n{\r\nint ssi, next;\r\nint di;\r\nint dsi;\r\ns8 *sstbl, *dstbl;\r\nint snamlen, len;\r\nstruct ldtentry *slh, *dlh = NULL;\r\nstruct idtentry *sih, *dih = NULL;\r\nstruct dtslot *h, *s, *d;\r\nstruct dt_lock *sdtlck = *sdtlock, *ddtlck = *ddtlock;\r\nstruct lv *slv, *dlv;\r\nint xssi, ns, nd;\r\nint sfsi;\r\nsstbl = (s8 *) & sp->slot[sp->header.stblindex];\r\ndstbl = (s8 *) & dp->slot[dp->header.stblindex];\r\ndsi = dp->header.freelist;\r\nsfsi = sp->header.freelist;\r\ndlv = & ddtlck->lv[ddtlck->index];\r\ndlv->offset = dsi;\r\nslv = & sdtlck->lv[sdtlck->index];\r\nslv->offset = sstbl[si];\r\nxssi = slv->offset - 1;\r\nns = nd = 0;\r\nfor (di = 0; si < sp->header.nextindex; si++, di++) {\r\nssi = sstbl[si];\r\ndstbl[di] = dsi;\r\nif (ssi != xssi + 1) {\r\nslv->length = ns;\r\nsdtlck->index++;\r\nif (sdtlck->index < sdtlck->maxcnt)\r\nslv++;\r\nelse {\r\nsdtlck = (struct dt_lock *) txLinelock(sdtlck);\r\nslv = & sdtlck->lv[0];\r\n}\r\nslv->offset = ssi;\r\nns = 0;\r\n}\r\nh = d = &dp->slot[dsi];\r\ns = &sp->slot[ssi];\r\nif (sp->header.flag & BT_LEAF) {\r\nslh = (struct ldtentry *) s;\r\ndlh = (struct ldtentry *) h;\r\nsnamlen = slh->namlen;\r\nif (do_index) {\r\nlen = min(snamlen, DTLHDRDATALEN);\r\ndlh->index = slh->index;\r\n} else\r\nlen = min(snamlen, DTLHDRDATALEN_LEGACY);\r\nmemcpy(dlh, slh, 6 + len * 2);\r\nnext = slh->next;\r\ndsi++;\r\ndlh->next = dsi;\r\n} else {\r\nsih = (struct idtentry *) s;\r\nsnamlen = sih->namlen;\r\nlen = min(snamlen, DTIHDRDATALEN);\r\ndih = (struct idtentry *) h;\r\nmemcpy(dih, sih, 10 + len * 2);\r\nnext = sih->next;\r\ndsi++;\r\ndih->next = dsi;\r\n}\r\ns->next = sfsi;\r\ns->cnt = 1;\r\nsfsi = ssi;\r\nns++;\r\nnd++;\r\nxssi = ssi;\r\nsnamlen -= len;\r\nwhile ((ssi = next) >= 0) {\r\nif (ssi != xssi + 1) {\r\nslv->length = ns;\r\nsdtlck->index++;\r\nif (sdtlck->index < sdtlck->maxcnt)\r\nslv++;\r\nelse {\r\nsdtlck =\r\n(struct dt_lock *)\r\ntxLinelock(sdtlck);\r\nslv = & sdtlck->lv[0];\r\n}\r\nslv->offset = ssi;\r\nns = 0;\r\n}\r\ns = &sp->slot[ssi];\r\nd++;\r\nlen = min(snamlen, DTSLOTDATALEN);\r\nUniStrncpy_le(d->name, s->name, len);\r\nns++;\r\nnd++;\r\nxssi = ssi;\r\ndsi++;\r\nd->next = dsi;\r\nnext = s->next;\r\ns->next = sfsi;\r\ns->cnt = 1;\r\nsfsi = ssi;\r\nsnamlen -= len;\r\n}\r\nif (h == d) {\r\nif (dp->header.flag & BT_LEAF)\r\ndlh->next = -1;\r\nelse\r\ndih->next = -1;\r\n} else\r\nd->next = -1;\r\n}\r\nslv->length = ns;\r\nsdtlck->index++;\r\n*sdtlock = sdtlck;\r\ndlv->length = nd;\r\nddtlck->index++;\r\n*ddtlock = ddtlck;\r\nsp->header.freelist = sfsi;\r\nsp->header.freecnt += nd;\r\ndp->header.nextindex = di;\r\ndp->header.freelist = dsi;\r\ndp->header.freecnt -= nd;\r\n}\r\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock)\r\n{\r\nint fsi;\r\ns8 *stbl;\r\nstruct dtslot *t;\r\nint si, freecnt;\r\nstruct dt_lock *dtlck = *dtlock;\r\nstruct lv *lv;\r\nint xsi, n;\r\nstbl = DT_GETSTBL(p);\r\nfsi = stbl[fi];\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[dtlck->index];\r\nlv->offset = fsi;\r\nt = &p->slot[fsi];\r\nif (p->header.flag & BT_LEAF)\r\nsi = ((struct ldtentry *) t)->next;\r\nelse\r\nsi = ((struct idtentry *) t)->next;\r\nt->next = si;\r\nt->cnt = 1;\r\nn = freecnt = 1;\r\nxsi = fsi;\r\nwhile (si >= 0) {\r\nif (si != xsi + 1) {\r\nlv->length = n;\r\ndtlck->index++;\r\nif (dtlck->index < dtlck->maxcnt)\r\nlv++;\r\nelse {\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[0];\r\n}\r\nlv->offset = si;\r\nn = 0;\r\n}\r\nn++;\r\nxsi = si;\r\nfreecnt++;\r\nt = &p->slot[si];\r\nt->cnt = 1;\r\nsi = t->next;\r\n}\r\nlv->length = n;\r\ndtlck->index++;\r\n*dtlock = dtlck;\r\nt->next = p->header.freelist;\r\np->header.freelist = fsi;\r\np->header.freecnt += freecnt;\r\nsi = p->header.nextindex;\r\nif (fi < si - 1)\r\nmemmove(&stbl[fi], &stbl[fi + 1], si - fi - 1);\r\np->header.nextindex--;\r\n}\r\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock)\r\n{\r\nint tsi;\r\ns8 *stbl;\r\nstruct dtslot *t;\r\nint si, freecnt;\r\nstruct dt_lock *dtlck = *dtlock;\r\nstruct lv *lv;\r\nint fsi, xsi, n;\r\nstbl = DT_GETSTBL(p);\r\ntsi = stbl[ti];\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[dtlck->index];\r\nlv->offset = tsi;\r\nt = &p->slot[tsi];\r\nASSERT(p->header.flag & BT_INTERNAL);\r\n((struct idtentry *) t)->namlen = 0;\r\nsi = ((struct idtentry *) t)->next;\r\n((struct idtentry *) t)->next = -1;\r\nn = 1;\r\nfreecnt = 0;\r\nfsi = si;\r\nxsi = tsi;\r\nwhile (si >= 0) {\r\nif (si != xsi + 1) {\r\nlv->length = n;\r\ndtlck->index++;\r\nif (dtlck->index < dtlck->maxcnt)\r\nlv++;\r\nelse {\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[0];\r\n}\r\nlv->offset = si;\r\nn = 0;\r\n}\r\nn++;\r\nxsi = si;\r\nfreecnt++;\r\nt = &p->slot[si];\r\nt->cnt = 1;\r\nsi = t->next;\r\n}\r\nlv->length = n;\r\ndtlck->index++;\r\n*dtlock = dtlck;\r\nif (freecnt == 0)\r\nreturn;\r\nt->next = p->header.freelist;\r\np->header.freelist = fsi;\r\np->header.freecnt += freecnt;\r\n}\r\nstatic void dtLinelockFreelist(dtpage_t * p,\r\nint m,\r\nstruct dt_lock ** dtlock)\r\n{\r\nint fsi;\r\nstruct dtslot *t;\r\nint si;\r\nstruct dt_lock *dtlck = *dtlock;\r\nstruct lv *lv;\r\nint xsi, n;\r\nfsi = p->header.freelist;\r\nif (dtlck->index >= dtlck->maxcnt)\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[dtlck->index];\r\nlv->offset = fsi;\r\nn = 1;\r\nxsi = fsi;\r\nt = &p->slot[fsi];\r\nsi = t->next;\r\nwhile (si < m && si >= 0) {\r\nif (si != xsi + 1) {\r\nlv->length = n;\r\ndtlck->index++;\r\nif (dtlck->index < dtlck->maxcnt)\r\nlv++;\r\nelse {\r\ndtlck = (struct dt_lock *) txLinelock(dtlck);\r\nlv = & dtlck->lv[0];\r\n}\r\nlv->offset = si;\r\nn = 0;\r\n}\r\nn++;\r\nxsi = si;\r\nt = &p->slot[si];\r\nsi = t->next;\r\n}\r\nlv->length = n;\r\ndtlck->index++;\r\n*dtlock = dtlck;\r\n}\r\nint dtModify(tid_t tid, struct inode *ip,\r\nstruct component_name * key, ino_t * orig_ino, ino_t new_ino, int flag)\r\n{\r\nint rc;\r\ns64 bn;\r\nstruct metapage *mp;\r\ndtpage_t *p;\r\nint index;\r\nstruct btstack btstack;\r\nstruct tlock *tlck;\r\nstruct dt_lock *dtlck;\r\nstruct lv *lv;\r\ns8 *stbl;\r\nint entry_si;\r\nstruct ldtentry *entry;\r\nif ((rc = dtSearch(ip, key, orig_ino, &btstack, flag)))\r\nreturn rc;\r\nDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\r\ndtlck = (struct dt_lock *) & tlck->lock;\r\nstbl = DT_GETSTBL(p);\r\nentry_si = stbl[index];\r\nASSERT(dtlck->index == 0);\r\nlv = & dtlck->lv[0];\r\nlv->offset = entry_si;\r\nlv->length = 1;\r\ndtlck->index++;\r\nentry = (struct ldtentry *) & p->slot[entry_si];\r\nentry->inumber = cpu_to_le32(new_ino);\r\nDT_PUTPAGE(mp);\r\nreturn 0;\r\n}
