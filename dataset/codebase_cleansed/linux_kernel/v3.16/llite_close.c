void vvp_write_pending(struct ccc_object *club, struct ccc_page *page)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(club->cob_inode);\r\nspin_lock(&lli->lli_lock);\r\nlli->lli_flags |= LLIF_SOM_DIRTY;\r\nif (page != NULL && list_empty(&page->cpg_pending_linkage))\r\nlist_add(&page->cpg_pending_linkage,\r\n&club->cob_pending_list);\r\nspin_unlock(&lli->lli_lock);\r\n}\r\nvoid vvp_write_complete(struct ccc_object *club, struct ccc_page *page)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(club->cob_inode);\r\nint rc = 0;\r\nspin_lock(&lli->lli_lock);\r\nif (page != NULL && !list_empty(&page->cpg_pending_linkage)) {\r\nlist_del_init(&page->cpg_pending_linkage);\r\nrc = 1;\r\n}\r\nspin_unlock(&lli->lli_lock);\r\nif (rc)\r\nll_queue_done_writing(club->cob_inode, 0);\r\n}\r\nvoid ll_queue_done_writing(struct inode *inode, unsigned long flags)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct ccc_object *club = cl2ccc(ll_i2info(inode)->lli_clob);\r\nspin_lock(&lli->lli_lock);\r\nlli->lli_flags |= flags;\r\nif ((lli->lli_flags & LLIF_DONE_WRITING) &&\r\nlist_empty(&club->cob_pending_list)) {\r\nstruct ll_close_queue *lcq = ll_i2sbi(inode)->ll_lcq;\r\nif (lli->lli_flags & LLIF_MDS_SIZE_LOCK)\r\nCWARN("ino %lu/%u(flags %u) som valid it just after "\r\n"recovery\n",\r\ninode->i_ino, inode->i_generation,\r\nlli->lli_flags);\r\nspin_lock(&lcq->lcq_lock);\r\nLASSERT(list_empty(&lli->lli_close_list));\r\nCDEBUG(D_INODE, "adding inode %lu/%u to close list\n",\r\ninode->i_ino, inode->i_generation);\r\nlist_add_tail(&lli->lli_close_list, &lcq->lcq_head);\r\nlli->lli_flags &= ~LLIF_DONE_WRITING;\r\nwake_up(&lcq->lcq_waitq);\r\nspin_unlock(&lcq->lcq_lock);\r\n}\r\nspin_unlock(&lli->lli_lock);\r\n}\r\nvoid ll_done_writing_attr(struct inode *inode, struct md_op_data *op_data)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nop_data->op_flags |= MF_SOM_CHANGE;\r\nif (lli->lli_flags & LLIF_MDS_SIZE_LOCK)\r\nCERROR("ino %lu/%u(flags %u) som valid it just after "\r\n"recovery\n", inode->i_ino, inode->i_generation,\r\nlli->lli_flags);\r\nif (!cl_local_size(inode)) {\r\nop_data->op_attr.ia_valid |= ATTR_MTIME_SET | ATTR_CTIME_SET |\r\nATTR_ATIME_SET | ATTR_SIZE | ATTR_BLOCKS;\r\n}\r\n}\r\nvoid ll_ioepoch_close(struct inode *inode, struct md_op_data *op_data,\r\nstruct obd_client_handle **och, unsigned long flags)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct ccc_object *club = cl2ccc(ll_i2info(inode)->lli_clob);\r\nspin_lock(&lli->lli_lock);\r\nif (!(list_empty(&club->cob_pending_list))) {\r\nif (!(lli->lli_flags & LLIF_EPOCH_PENDING)) {\r\nLASSERT(*och != NULL);\r\nLASSERT(lli->lli_pending_och == NULL);\r\nlli->lli_flags |= LLIF_EPOCH_PENDING;\r\nlli->lli_pending_och = *och;\r\nspin_unlock(&lli->lli_lock);\r\ninode = igrab(inode);\r\nLASSERT(inode);\r\nGOTO(out, 0);\r\n}\r\nif (flags & LLIF_DONE_WRITING) {\r\nLASSERT(!(lli->lli_flags & LLIF_DONE_WRITING));\r\nlli->lli_flags |= LLIF_DONE_WRITING;\r\nspin_unlock(&lli->lli_lock);\r\ninode = igrab(inode);\r\nLASSERT(inode);\r\nGOTO(out, 0);\r\n}\r\n}\r\nCDEBUG(D_INODE, "Epoch "LPU64" closed on "DFID"\n",\r\nll_i2info(inode)->lli_ioepoch, PFID(&lli->lli_fid));\r\nop_data->op_flags |= MF_EPOCH_CLOSE;\r\nif (flags & LLIF_DONE_WRITING) {\r\nLASSERT(lli->lli_flags & LLIF_SOM_DIRTY);\r\nLASSERT(!(lli->lli_flags & LLIF_DONE_WRITING));\r\n*och = lli->lli_pending_och;\r\nlli->lli_pending_och = NULL;\r\nlli->lli_flags &= ~LLIF_EPOCH_PENDING;\r\n} else {\r\nif (!(lli->lli_flags & LLIF_SOM_DIRTY)) {\r\nspin_unlock(&lli->lli_lock);\r\nGOTO(out, 0);\r\n}\r\nif (lli->lli_flags & LLIF_EPOCH_PENDING) {\r\nspin_unlock(&lli->lli_lock);\r\nGOTO(out, 0);\r\n}\r\n}\r\nLASSERT(list_empty(&club->cob_pending_list));\r\nlli->lli_flags &= ~LLIF_SOM_DIRTY;\r\nspin_unlock(&lli->lli_lock);\r\nll_done_writing_attr(inode, op_data);\r\nout:\r\nreturn;\r\n}\r\nint ll_som_update(struct inode *inode, struct md_op_data *op_data)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct ptlrpc_request *request = NULL;\r\n__u32 old_flags;\r\nstruct obdo *oa;\r\nint rc;\r\nLASSERT(op_data != NULL);\r\nif (lli->lli_flags & LLIF_MDS_SIZE_LOCK)\r\nCERROR("ino %lu/%u(flags %u) som valid it just after "\r\n"recovery\n", inode->i_ino, inode->i_generation,\r\nlli->lli_flags);\r\nOBDO_ALLOC(oa);\r\nif (!oa) {\r\nCERROR("can't allocate memory for Size-on-MDS update.\n");\r\nreturn -ENOMEM;\r\n}\r\nold_flags = op_data->op_flags;\r\nop_data->op_flags = MF_SOM_CHANGE;\r\nif (lli->lli_ioepoch == op_data->op_ioepoch) {\r\nrc = ll_inode_getattr(inode, oa, op_data->op_ioepoch,\r\nold_flags & MF_GETATTR_LOCK);\r\nif (rc) {\r\noa->o_valid = 0;\r\nif (rc != -ENOENT)\r\nCERROR("inode_getattr failed (%d): unable to "\r\n"send a Size-on-MDS attribute update "\r\n"for inode %lu/%u\n", rc, inode->i_ino,\r\ninode->i_generation);\r\n} else {\r\nCDEBUG(D_INODE, "Size-on-MDS update on "DFID"\n",\r\nPFID(&lli->lli_fid));\r\n}\r\nmd_from_obdo(op_data, oa, oa->o_valid);\r\n}\r\nrc = md_setattr(ll_i2sbi(inode)->ll_md_exp, op_data,\r\nNULL, 0, NULL, 0, &request, NULL);\r\nptlrpc_req_finished(request);\r\nOBDO_FREE(oa);\r\nreturn rc;\r\n}\r\nstatic void ll_prepare_done_writing(struct inode *inode,\r\nstruct md_op_data *op_data,\r\nstruct obd_client_handle **och)\r\n{\r\nll_ioepoch_close(inode, op_data, och, LLIF_DONE_WRITING);\r\nif (*och == NULL)\r\nreturn;\r\nll_pack_inode2opdata(inode, op_data, &(*och)->och_fh);\r\nll_prep_md_op_data(op_data, inode, NULL, NULL,\r\n0, 0, LUSTRE_OPC_ANY, NULL);\r\n}\r\nstatic void ll_done_writing(struct inode *inode)\r\n{\r\nstruct obd_client_handle *och = NULL;\r\nstruct md_op_data *op_data;\r\nint rc;\r\nLASSERT(exp_connect_som(ll_i2mdexp(inode)));\r\nOBD_ALLOC_PTR(op_data);\r\nif (op_data == NULL) {\r\nCERROR("can't allocate op_data\n");\r\nreturn;\r\n}\r\nll_prepare_done_writing(inode, op_data, &och);\r\nif (och == NULL)\r\nGOTO(out, 0);\r\nrc = md_done_writing(ll_i2sbi(inode)->ll_md_exp, op_data, NULL);\r\nif (rc == -EAGAIN) {\r\nrc = ll_som_update(inode, op_data);\r\n} else if (rc) {\r\nCERROR("inode %lu mdc done_writing failed: rc = %d\n",\r\ninode->i_ino, rc);\r\n}\r\nout:\r\nll_finish_md_op_data(op_data);\r\nif (och) {\r\nmd_clear_open_replay_data(ll_i2sbi(inode)->ll_md_exp, och);\r\nOBD_FREE_PTR(och);\r\n}\r\n}\r\nstatic struct ll_inode_info *ll_close_next_lli(struct ll_close_queue *lcq)\r\n{\r\nstruct ll_inode_info *lli = NULL;\r\nspin_lock(&lcq->lcq_lock);\r\nif (!list_empty(&lcq->lcq_head)) {\r\nlli = list_entry(lcq->lcq_head.next, struct ll_inode_info,\r\nlli_close_list);\r\nlist_del_init(&lli->lli_close_list);\r\n} else if (atomic_read(&lcq->lcq_stop))\r\nlli = ERR_PTR(-EALREADY);\r\nspin_unlock(&lcq->lcq_lock);\r\nreturn lli;\r\n}\r\nstatic int ll_close_thread(void *arg)\r\n{\r\nstruct ll_close_queue *lcq = arg;\r\ncomplete(&lcq->lcq_comp);\r\nwhile (1) {\r\nstruct l_wait_info lwi = { 0 };\r\nstruct ll_inode_info *lli;\r\nstruct inode *inode;\r\nl_wait_event_exclusive(lcq->lcq_waitq,\r\n(lli = ll_close_next_lli(lcq)) != NULL,\r\n&lwi);\r\nif (IS_ERR(lli))\r\nbreak;\r\ninode = ll_info2i(lli);\r\nCDEBUG(D_INFO, "done_writing for inode %lu/%u\n",\r\ninode->i_ino, inode->i_generation);\r\nll_done_writing(inode);\r\niput(inode);\r\n}\r\nCDEBUG(D_INFO, "ll_close exiting\n");\r\ncomplete(&lcq->lcq_comp);\r\nreturn 0;\r\n}\r\nint ll_close_thread_start(struct ll_close_queue **lcq_ret)\r\n{\r\nstruct ll_close_queue *lcq;\r\nstruct task_struct *task;\r\nif (OBD_FAIL_CHECK(OBD_FAIL_LDLM_CLOSE_THREAD))\r\nreturn -EINTR;\r\nOBD_ALLOC(lcq, sizeof(*lcq));\r\nif (lcq == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&lcq->lcq_lock);\r\nINIT_LIST_HEAD(&lcq->lcq_head);\r\ninit_waitqueue_head(&lcq->lcq_waitq);\r\ninit_completion(&lcq->lcq_comp);\r\ntask = kthread_run(ll_close_thread, lcq, "ll_close");\r\nif (IS_ERR(task)) {\r\nOBD_FREE(lcq, sizeof(*lcq));\r\nreturn PTR_ERR(task);\r\n}\r\nwait_for_completion(&lcq->lcq_comp);\r\n*lcq_ret = lcq;\r\nreturn 0;\r\n}\r\nvoid ll_close_thread_shutdown(struct ll_close_queue *lcq)\r\n{\r\ninit_completion(&lcq->lcq_comp);\r\natomic_inc(&lcq->lcq_stop);\r\nwake_up(&lcq->lcq_waitq);\r\nwait_for_completion(&lcq->lcq_comp);\r\nOBD_FREE(lcq, sizeof(*lcq));\r\n}
