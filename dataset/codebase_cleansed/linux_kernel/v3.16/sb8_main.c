static int snd_sb8_hw_constraint_rate_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nif (c->min > 1) {\r\nunsigned int num = 0, den = 0;\r\nint err = snd_interval_ratnum(hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE),\r\n2, stereo_clocks, &num, &den);\r\nif (err >= 0 && den) {\r\nparams->rate_num = num;\r\nparams->rate_den = den;\r\n}\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_sb8_hw_constraint_channels_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (r->min > SB8_RATE(22050) || r->max <= SB8_RATE(11025)) {\r\nstruct snd_interval t = { .min = 1, .max = 1 };\r\nreturn snd_interval_refine(hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS), &t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_sb8_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int mixreg, rate, size, count;\r\nunsigned char format;\r\nunsigned char stereo = runtime->channels > 1;\r\nint dma;\r\nrate = runtime->rate;\r\nswitch (chip->hardware) {\r\ncase SB_HW_JAZZ16:\r\nif (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {\r\nif (chip->mode & SB_MODE_CAPTURE_16)\r\nreturn -EBUSY;\r\nelse\r\nchip->mode |= SB_MODE_PLAYBACK_16;\r\n}\r\nchip->playback_format = SB_DSP_LO_OUTPUT_AUTO;\r\nbreak;\r\ncase SB_HW_PRO:\r\nif (runtime->channels > 1) {\r\nif (snd_BUG_ON(rate != SB8_RATE(11025) &&\r\nrate != SB8_RATE(22050)))\r\nreturn -EINVAL;\r\nchip->playback_format = SB_DSP_HI_OUTPUT_AUTO;\r\nbreak;\r\n}\r\ncase SB_HW_201:\r\nif (rate > 23000) {\r\nchip->playback_format = SB_DSP_HI_OUTPUT_AUTO;\r\nbreak;\r\n}\r\ncase SB_HW_20:\r\nchip->playback_format = SB_DSP_LO_OUTPUT_AUTO;\r\nbreak;\r\ncase SB_HW_10:\r\nchip->playback_format = SB_DSP_OUTPUT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (chip->mode & SB_MODE_PLAYBACK_16) {\r\nformat = stereo ? SB_DSP_STEREO_16BIT : SB_DSP_MONO_16BIT;\r\ndma = chip->dma16;\r\n} else {\r\nformat = stereo ? SB_DSP_STEREO_8BIT : SB_DSP_MONO_8BIT;\r\nchip->mode |= SB_MODE_PLAYBACK_8;\r\ndma = chip->dma8;\r\n}\r\nsize = chip->p_dma_size = snd_pcm_lib_buffer_bytes(substream);\r\ncount = chip->p_period_size = snd_pcm_lib_period_bytes(substream);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_sbdsp_command(chip, SB_DSP_SPEAKER_ON);\r\nif (chip->hardware == SB_HW_JAZZ16)\r\nsnd_sbdsp_command(chip, format);\r\nelse if (stereo) {\r\nspin_lock(&chip->mixer_lock);\r\nmixreg = snd_sbmixer_read(chip, SB_DSP_STEREO_SW);\r\nsnd_sbmixer_write(chip, SB_DSP_STEREO_SW, mixreg | 0x02);\r\nspin_unlock(&chip->mixer_lock);\r\nsnd_sbdsp_command(chip, SB_DSP_DMA8_EXIT);\r\nruntime->dma_area[0] = 0x80;\r\nsnd_dma_program(dma, runtime->dma_addr, 1, DMA_MODE_WRITE);\r\nsnd_sbdsp_command(chip, SB_DSP_OUTPUT);\r\nsnd_sbdsp_command(chip, 0);\r\nsnd_sbdsp_command(chip, 0);\r\n}\r\nsnd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE);\r\nif (stereo) {\r\nsnd_sbdsp_command(chip, 256 - runtime->rate_den / 2);\r\nspin_lock(&chip->mixer_lock);\r\nmixreg = snd_sbmixer_read(chip, SB_DSP_PLAYBACK_FILT);\r\nsnd_sbmixer_write(chip, SB_DSP_PLAYBACK_FILT, mixreg | 0x20);\r\nspin_unlock(&chip->mixer_lock);\r\nchip->force_mode16 = mixreg;\r\n} else {\r\nsnd_sbdsp_command(chip, 256 - runtime->rate_den);\r\n}\r\nif (chip->playback_format != SB_DSP_OUTPUT) {\r\nif (chip->mode & SB_MODE_PLAYBACK_16)\r\ncount /= 2;\r\ncount--;\r\nsnd_sbdsp_command(chip, SB_DSP_BLOCK_SIZE);\r\nsnd_sbdsp_command(chip, count & 0xff);\r\nsnd_sbdsp_command(chip, count >> 8);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_dma_program(dma, runtime->dma_addr,\r\nsize, DMA_MODE_WRITE | DMA_AUTOINIT);\r\nreturn 0;\r\n}\r\nstatic int snd_sb8_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nunsigned int count;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_sbdsp_command(chip, chip->playback_format);\r\nif (chip->playback_format == SB_DSP_OUTPUT) {\r\ncount = chip->p_period_size - 1;\r\nsnd_sbdsp_command(chip, count & 0xff);\r\nsnd_sbdsp_command(chip, count >> 8);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (chip->playback_format == SB_DSP_HI_OUTPUT_AUTO) {\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_sbdsp_reset(chip);\r\nif (runtime->channels > 1) {\r\nspin_lock(&chip->mixer_lock);\r\nsnd_sbmixer_write(chip, SB_DSP_STEREO_SW, chip->force_mode16 & ~0x02);\r\nspin_unlock(&chip->mixer_lock);\r\n}\r\n} else {\r\nsnd_sbdsp_command(chip, SB_DSP_DMA8_OFF);\r\n}\r\nsnd_sbdsp_command(chip, SB_DSP_SPEAKER_OFF);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sb8_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_sb8_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_sb8_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int mixreg, rate, size, count;\r\nunsigned char format;\r\nunsigned char stereo = runtime->channels > 1;\r\nint dma;\r\nrate = runtime->rate;\r\nswitch (chip->hardware) {\r\ncase SB_HW_JAZZ16:\r\nif (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {\r\nif (chip->mode & SB_MODE_PLAYBACK_16)\r\nreturn -EBUSY;\r\nelse\r\nchip->mode |= SB_MODE_CAPTURE_16;\r\n}\r\nchip->capture_format = SB_DSP_LO_INPUT_AUTO;\r\nbreak;\r\ncase SB_HW_PRO:\r\nif (runtime->channels > 1) {\r\nif (snd_BUG_ON(rate != SB8_RATE(11025) &&\r\nrate != SB8_RATE(22050)))\r\nreturn -EINVAL;\r\nchip->capture_format = SB_DSP_HI_INPUT_AUTO;\r\nbreak;\r\n}\r\nchip->capture_format = (rate > 23000) ? SB_DSP_HI_INPUT_AUTO : SB_DSP_LO_INPUT_AUTO;\r\nbreak;\r\ncase SB_HW_201:\r\nif (rate > 13000) {\r\nchip->capture_format = SB_DSP_HI_INPUT_AUTO;\r\nbreak;\r\n}\r\ncase SB_HW_20:\r\nchip->capture_format = SB_DSP_LO_INPUT_AUTO;\r\nbreak;\r\ncase SB_HW_10:\r\nchip->capture_format = SB_DSP_INPUT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (chip->mode & SB_MODE_CAPTURE_16) {\r\nformat = stereo ? SB_DSP_STEREO_16BIT : SB_DSP_MONO_16BIT;\r\ndma = chip->dma16;\r\n} else {\r\nformat = stereo ? SB_DSP_STEREO_8BIT : SB_DSP_MONO_8BIT;\r\nchip->mode |= SB_MODE_CAPTURE_8;\r\ndma = chip->dma8;\r\n}\r\nsize = chip->c_dma_size = snd_pcm_lib_buffer_bytes(substream);\r\ncount = chip->c_period_size = snd_pcm_lib_period_bytes(substream);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_sbdsp_command(chip, SB_DSP_SPEAKER_OFF);\r\nif (chip->hardware == SB_HW_JAZZ16)\r\nsnd_sbdsp_command(chip, format);\r\nelse if (stereo)\r\nsnd_sbdsp_command(chip, SB_DSP_STEREO_8BIT);\r\nsnd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE);\r\nif (stereo) {\r\nsnd_sbdsp_command(chip, 256 - runtime->rate_den / 2);\r\nspin_lock(&chip->mixer_lock);\r\nmixreg = snd_sbmixer_read(chip, SB_DSP_CAPTURE_FILT);\r\nsnd_sbmixer_write(chip, SB_DSP_CAPTURE_FILT, mixreg | 0x20);\r\nspin_unlock(&chip->mixer_lock);\r\nchip->force_mode16 = mixreg;\r\n} else {\r\nsnd_sbdsp_command(chip, 256 - runtime->rate_den);\r\n}\r\nif (chip->capture_format != SB_DSP_INPUT) {\r\nif (chip->mode & SB_MODE_PLAYBACK_16)\r\ncount /= 2;\r\ncount--;\r\nsnd_sbdsp_command(chip, SB_DSP_BLOCK_SIZE);\r\nsnd_sbdsp_command(chip, count & 0xff);\r\nsnd_sbdsp_command(chip, count >> 8);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_dma_program(dma, runtime->dma_addr,\r\nsize, DMA_MODE_READ | DMA_AUTOINIT);\r\nreturn 0;\r\n}\r\nstatic int snd_sb8_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nunsigned int count;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_sbdsp_command(chip, chip->capture_format);\r\nif (chip->capture_format == SB_DSP_INPUT) {\r\ncount = chip->c_period_size - 1;\r\nsnd_sbdsp_command(chip, count & 0xff);\r\nsnd_sbdsp_command(chip, count >> 8);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (chip->capture_format == SB_DSP_HI_INPUT_AUTO) {\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_sbdsp_reset(chip);\r\nif (runtime->channels > 1) {\r\nspin_lock(&chip->mixer_lock);\r\nsnd_sbmixer_write(chip, SB_DSP_CAPTURE_FILT, chip->force_mode16);\r\nspin_unlock(&chip->mixer_lock);\r\nsnd_sbdsp_command(chip, SB_DSP_MONO_8BIT);\r\n}\r\n} else {\r\nsnd_sbdsp_command(chip, SB_DSP_DMA8_OFF);\r\n}\r\nsnd_sbdsp_command(chip, SB_DSP_SPEAKER_OFF);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nirqreturn_t snd_sb8dsp_interrupt(struct snd_sb *chip)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nsnd_sb_ack_8bit(chip);\r\nswitch (chip->mode) {\r\ncase SB_MODE_PLAYBACK_16:\r\nif (chip->hardware != SB_HW_JAZZ16)\r\nbreak;\r\ncase SB_MODE_PLAYBACK_8:\r\nsubstream = chip->playback_substream;\r\nruntime = substream->runtime;\r\nif (chip->playback_format == SB_DSP_OUTPUT)\r\nsnd_sb8_playback_trigger(substream, SNDRV_PCM_TRIGGER_START);\r\nsnd_pcm_period_elapsed(substream);\r\nbreak;\r\ncase SB_MODE_CAPTURE_16:\r\nif (chip->hardware != SB_HW_JAZZ16)\r\nbreak;\r\ncase SB_MODE_CAPTURE_8:\r\nsubstream = chip->capture_substream;\r\nruntime = substream->runtime;\r\nif (chip->capture_format == SB_DSP_INPUT)\r\nsnd_sb8_capture_trigger(substream, SNDRV_PCM_TRIGGER_START);\r\nsnd_pcm_period_elapsed(substream);\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic snd_pcm_uframes_t snd_sb8_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nint dma;\r\nif (chip->mode & SB_MODE_PLAYBACK_8)\r\ndma = chip->dma8;\r\nelse if (chip->mode & SB_MODE_PLAYBACK_16)\r\ndma = chip->dma16;\r\nelse\r\nreturn 0;\r\nptr = snd_dma_pointer(dma, chip->p_dma_size);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic snd_pcm_uframes_t snd_sb8_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nint dma;\r\nif (chip->mode & SB_MODE_CAPTURE_8)\r\ndma = chip->dma8;\r\nelse if (chip->mode & SB_MODE_CAPTURE_16)\r\ndma = chip->dma16;\r\nelse\r\nreturn 0;\r\nptr = snd_dma_pointer(dma, chip->c_dma_size);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic int snd_sb8_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->open_lock, flags);\r\nif (chip->open) {\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nchip->open |= SB_OPEN_PCM;\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nchip->playback_substream = substream;\r\nruntime->hw = snd_sb8_playback;\r\n} else {\r\nchip->capture_substream = substream;\r\nruntime->hw = snd_sb8_capture;\r\n}\r\nswitch (chip->hardware) {\r\ncase SB_HW_JAZZ16:\r\nif (chip->dma16 == 5 || chip->dma16 == 7)\r\nruntime->hw.formats |= SNDRV_PCM_FMTBIT_S16_LE;\r\nruntime->hw.rates |= SNDRV_PCM_RATE_8000_48000;\r\nruntime->hw.rate_min = 4000;\r\nruntime->hw.rate_max = 50000;\r\nruntime->hw.channels_max = 2;\r\nbreak;\r\ncase SB_HW_PRO:\r\nruntime->hw.rate_max = 44100;\r\nruntime->hw.channels_max = 2;\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_sb8_hw_constraint_rate_channels, NULL,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_sb8_hw_constraint_channels_rate, NULL,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nbreak;\r\ncase SB_HW_201:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nruntime->hw.rate_max = 44100;\r\n} else {\r\nruntime->hw.rate_max = 15000;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_clock);\r\nif (chip->dma8 > 3 || chip->dma16 >= 0) {\r\nsnd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, 2);\r\nsnd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES, 2);\r\nruntime->hw.buffer_bytes_max = 128 * 1024 * 1024;\r\nruntime->hw.period_bytes_max = 128 * 1024 * 1024;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_sb8_close(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nchip->playback_substream = NULL;\r\nchip->capture_substream = NULL;\r\nspin_lock_irqsave(&chip->open_lock, flags);\r\nchip->open &= ~SB_OPEN_PCM;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nchip->mode &= ~SB_MODE_PLAYBACK;\r\nelse\r\nchip->mode &= ~SB_MODE_CAPTURE;\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nreturn 0;\r\n}\r\nint snd_sb8dsp_pcm(struct snd_sb *chip, int device, struct snd_pcm ** rpcm)\r\n{\r\nstruct snd_card *card = chip->card;\r\nstruct snd_pcm *pcm;\r\nint err;\r\nsize_t max_prealloc = 64 * 1024;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(card, "SB8 DSP", device, 1, 1, &pcm)) < 0)\r\nreturn err;\r\nsprintf(pcm->name, "DSP v%i.%i", chip->version >> 8, chip->version & 0xff);\r\npcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sb8_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sb8_capture_ops);\r\nif (chip->dma8 > 3 || chip->dma16 >= 0)\r\nmax_prealloc = 128 * 1024;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_isa_data(),\r\n64*1024, max_prealloc);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int __init alsa_sb8_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_sb8_exit(void)\r\n{\r\n}
