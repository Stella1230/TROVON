static void smd_tty_notify(void *priv, unsigned event)\r\n{\r\nunsigned char *ptr;\r\nint avail;\r\nstruct smd_tty_info *info = priv;\r\nstruct tty_struct *tty;\r\nif (event != SMD_EVENT_DATA)\r\nreturn;\r\ntty = tty_port_tty_get(&info->port);\r\nif (!tty)\r\nreturn;\r\nfor (;;) {\r\nif (test_bit(TTY_THROTTLED, &tty->flags))\r\nbreak;\r\navail = smd_read_avail(info->ch);\r\nif (avail == 0)\r\nbreak;\r\navail = tty_prepare_flip_string(&info->port, &ptr, avail);\r\nif (smd_read(info->ch, ptr, avail) != avail) {\r\npr_err("OOPS - smd_tty_buffer mismatch?!");\r\n}\r\ntty_flip_buffer_push(&info->port);\r\n}\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic int smd_tty_port_activate(struct tty_port *tport, struct tty_struct *tty)\r\n{\r\nstruct smd_tty_info *info = container_of(tport, struct smd_tty_info,\r\nport);\r\nint i, res = 0;\r\nconst char *name = NULL;\r\nfor (i = 0; i < smd_tty_channels_len; i++) {\r\nif (smd_tty_channels[i].id == tty->index) {\r\nname = smd_tty_channels[i].name;\r\nbreak;\r\n}\r\n}\r\nif (!name)\r\nreturn -ENODEV;\r\nif (info->ch)\r\nsmd_kick(info->ch);\r\nelse\r\nres = smd_open(name, &info->ch, info, smd_tty_notify);\r\nif (!res)\r\ntty->driver_data = info;\r\nreturn res;\r\n}\r\nstatic void smd_tty_port_shutdown(struct tty_port *tport)\r\n{\r\nstruct smd_tty_info *info = container_of(tport, struct smd_tty_info,\r\nport);\r\nif (info->ch) {\r\nsmd_close(info->ch);\r\ninfo->ch = 0;\r\n}\r\n}\r\nstatic int smd_tty_open(struct tty_struct *tty, struct file *f)\r\n{\r\nstruct smd_tty_info *info = smd_tty + tty->index;\r\nreturn tty_port_open(&info->port, tty, f);\r\n}\r\nstatic void smd_tty_close(struct tty_struct *tty, struct file *f)\r\n{\r\nstruct smd_tty_info *info = tty->driver_data;\r\ntty_port_close(&info->port, tty, f);\r\n}\r\nstatic int smd_tty_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int len)\r\n{\r\nstruct smd_tty_info *info = tty->driver_data;\r\nint avail;\r\navail = smd_write_avail(info->ch);\r\nif (len > avail)\r\nlen = avail;\r\nreturn smd_write(info->ch, buf, len);\r\n}\r\nstatic int smd_tty_write_room(struct tty_struct *tty)\r\n{\r\nstruct smd_tty_info *info = tty->driver_data;\r\nreturn smd_write_avail(info->ch);\r\n}\r\nstatic int smd_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct smd_tty_info *info = tty->driver_data;\r\nreturn smd_read_avail(info->ch);\r\n}\r\nstatic void smd_tty_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct smd_tty_info *info = tty->driver_data;\r\nsmd_kick(info->ch);\r\n}\r\nstatic int __init smd_tty_init(void)\r\n{\r\nint ret, i;\r\nsmd_tty_driver = alloc_tty_driver(MAX_SMD_TTYS);\r\nif (smd_tty_driver == 0)\r\nreturn -ENOMEM;\r\nsmd_tty_driver->driver_name = "smd_tty_driver";\r\nsmd_tty_driver->name = "smd";\r\nsmd_tty_driver->major = 0;\r\nsmd_tty_driver->minor_start = 0;\r\nsmd_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nsmd_tty_driver->subtype = SERIAL_TYPE_NORMAL;\r\nsmd_tty_driver->init_termios = tty_std_termios;\r\nsmd_tty_driver->init_termios.c_iflag = 0;\r\nsmd_tty_driver->init_termios.c_oflag = 0;\r\nsmd_tty_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;\r\nsmd_tty_driver->init_termios.c_lflag = 0;\r\nsmd_tty_driver->flags = TTY_DRIVER_RESET_TERMIOS |\r\nTTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ntty_set_operations(smd_tty_driver, &smd_tty_ops);\r\nret = tty_register_driver(smd_tty_driver);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < smd_tty_channels_len; i++) {\r\nstruct tty_port *port = &smd_tty[smd_tty_channels[i].id].port;\r\ntty_port_init(port);\r\nport->ops = &smd_tty_port_ops;\r\ntty_port_register_device(port, smd_tty_driver,\r\nsmd_tty_channels[i].id, NULL);\r\n}\r\nreturn 0;\r\n}
