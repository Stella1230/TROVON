int gxio_mpipe_init(gxio_mpipe_context_t *context, unsigned int mpipe_index)\r\n{\r\nchar file[32];\r\nint fd;\r\nint i;\r\nif (mpipe_index >= GXIO_MPIPE_INSTANCE_MAX)\r\nreturn -EINVAL;\r\nsnprintf(file, sizeof(file), "mpipe/%d/iorpc", mpipe_index);\r\nfd = hv_dev_open((HV_VirtAddr) file, 0);\r\ncontext->fd = fd;\r\nif (fd < 0) {\r\nif (fd >= GXIO_ERR_MIN && fd <= GXIO_ERR_MAX)\r\nreturn fd;\r\nelse\r\nreturn -ENODEV;\r\n}\r\ncontext->mmio_cfg_base = (void __force *)\r\niorpc_ioremap(fd, HV_MPIPE_CONFIG_MMIO_OFFSET,\r\nHV_MPIPE_CONFIG_MMIO_SIZE);\r\nif (context->mmio_cfg_base == NULL)\r\ngoto cfg_failed;\r\ncontext->mmio_fast_base = (void __force *)\r\niorpc_ioremap(fd, HV_MPIPE_FAST_MMIO_OFFSET,\r\nHV_MPIPE_FAST_MMIO_SIZE);\r\nif (context->mmio_fast_base == NULL)\r\ngoto fast_failed;\r\nfor (i = 0; i < 8; i++)\r\ncontext->__stacks.stacks[i] = 255;\r\ncontext->instance = mpipe_index;\r\nreturn 0;\r\nfast_failed:\r\niounmap((void __force __iomem *)(context->mmio_cfg_base));\r\ncfg_failed:\r\nhv_dev_close(context->fd);\r\ncontext->fd = -1;\r\nreturn -ENODEV;\r\n}\r\nint gxio_mpipe_destroy(gxio_mpipe_context_t *context)\r\n{\r\niounmap((void __force __iomem *)(context->mmio_cfg_base));\r\niounmap((void __force __iomem *)(context->mmio_fast_base));\r\nreturn hv_dev_close(context->fd);\r\n}\r\ngxio_mpipe_buffer_size_enum_t gxio_mpipe_buffer_size_to_buffer_size_enum(size_t\r\nsize)\r\n{\r\nint i;\r\nfor (i = 0; i < 7; i++)\r\nif (size <= gxio_mpipe_buffer_sizes[i])\r\nbreak;\r\nreturn i;\r\n}\r\nsize_t gxio_mpipe_buffer_size_enum_to_buffer_size(gxio_mpipe_buffer_size_enum_t\r\nbuffer_size_enum)\r\n{\r\nif (buffer_size_enum > 7)\r\nbuffer_size_enum = 7;\r\nreturn gxio_mpipe_buffer_sizes[buffer_size_enum];\r\n}\r\nsize_t gxio_mpipe_calc_buffer_stack_bytes(unsigned long buffers)\r\n{\r\nconst int BUFFERS_PER_LINE = 12;\r\nunsigned long lines =\r\n(buffers + BUFFERS_PER_LINE - 1) / BUFFERS_PER_LINE;\r\nreturn lines * CHIP_L2_LINE_SIZE();\r\n}\r\nint gxio_mpipe_init_buffer_stack(gxio_mpipe_context_t *context,\r\nunsigned int stack,\r\ngxio_mpipe_buffer_size_enum_t\r\nbuffer_size_enum, void *mem, size_t mem_size,\r\nunsigned int mem_flags)\r\n{\r\nint result;\r\nmemset(mem, 0, mem_size);\r\nresult = gxio_mpipe_init_buffer_stack_aux(context, mem, mem_size,\r\nmem_flags, stack,\r\nbuffer_size_enum);\r\nif (result < 0)\r\nreturn result;\r\ncontext->__stacks.stacks[buffer_size_enum] = stack;\r\nreturn 0;\r\n}\r\nint gxio_mpipe_init_notif_ring(gxio_mpipe_context_t *context,\r\nunsigned int ring,\r\nvoid *mem, size_t mem_size,\r\nunsigned int mem_flags)\r\n{\r\nreturn gxio_mpipe_init_notif_ring_aux(context, mem, mem_size,\r\nmem_flags, ring);\r\n}\r\nint gxio_mpipe_init_notif_group_and_buckets(gxio_mpipe_context_t *context,\r\nunsigned int group,\r\nunsigned int ring,\r\nunsigned int num_rings,\r\nunsigned int bucket,\r\nunsigned int num_buckets,\r\ngxio_mpipe_bucket_mode_t mode)\r\n{\r\nint i;\r\nint result;\r\ngxio_mpipe_bucket_info_t bucket_info = { {\r\n.group = group,\r\n.mode = mode,\r\n}\r\n};\r\ngxio_mpipe_notif_group_bits_t bits = { {0} };\r\nfor (i = 0; i < num_rings; i++)\r\ngxio_mpipe_notif_group_add_ring(&bits, ring + i);\r\nresult = gxio_mpipe_init_notif_group(context, group, bits);\r\nif (result != 0)\r\nreturn result;\r\nfor (i = 0; i < num_buckets; i++) {\r\nbucket_info.notifring = ring + (i % num_rings);\r\nresult = gxio_mpipe_init_bucket(context, bucket + i,\r\nbucket_info);\r\nif (result != 0)\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nint gxio_mpipe_init_edma_ring(gxio_mpipe_context_t *context,\r\nunsigned int ring, unsigned int channel,\r\nvoid *mem, size_t mem_size,\r\nunsigned int mem_flags)\r\n{\r\nmemset(mem, 0, mem_size);\r\nreturn gxio_mpipe_init_edma_ring_aux(context, mem, mem_size, mem_flags,\r\nring, channel);\r\n}\r\nvoid gxio_mpipe_rules_init(gxio_mpipe_rules_t *rules,\r\ngxio_mpipe_context_t *context)\r\n{\r\nrules->context = context;\r\nmemset(&rules->list, 0, sizeof(rules->list));\r\n}\r\nint gxio_mpipe_rules_begin(gxio_mpipe_rules_t *rules,\r\nunsigned int bucket, unsigned int num_buckets,\r\ngxio_mpipe_rules_stacks_t *stacks)\r\n{\r\nint i;\r\nint stack = 255;\r\ngxio_mpipe_rules_list_t *list = &rules->list;\r\ngxio_mpipe_rules_rule_t *rule =\r\n(gxio_mpipe_rules_rule_t *) (list->rules + list->head);\r\nunsigned int head = list->tail;\r\nunsigned int pad = 0;\r\nwhile (((head + pad) % __alignof__(gxio_mpipe_rules_rule_t)) != 0)\r\npad++;\r\nif (head + pad + sizeof(*rule) >= sizeof(list->rules))\r\nreturn GXIO_MPIPE_ERR_RULES_FULL;\r\nif (__builtin_popcount(num_buckets) != 1)\r\nreturn GXIO_MPIPE_ERR_RULES_INVALID;\r\nrule->size += pad;\r\nlist->head = head + pad;\r\nrule = (gxio_mpipe_rules_rule_t *) (list->rules + list->head);\r\nrule->headroom = 2;\r\nrule->tailroom = 0;\r\nrule->capacity = 16384;\r\nrule->bucket_mask = num_buckets - 1;\r\nrule->bucket_first = bucket;\r\nfor (i = 8 - 1; i >= 0; i--) {\r\nint maybe =\r\nstacks ? stacks->stacks[i] : rules->context->__stacks.\r\nstacks[i];\r\nif (maybe != 255)\r\nstack = maybe;\r\nrule->stacks.stacks[i] = stack;\r\n}\r\nif (stack == 255)\r\nreturn GXIO_MPIPE_ERR_RULES_INVALID;\r\nfor (i = 8 - 1; i > 0; i--) {\r\nif (rule->stacks.stacks[i] == 255) {\r\nrule->stacks.stacks[i] = stack;\r\nrule->capacity =\r\ngxio_mpipe_buffer_size_enum_to_buffer_size(i -\r\n1);\r\n}\r\n}\r\nrule->size = sizeof(*rule);\r\nlist->tail = list->head + rule->size;\r\nreturn 0;\r\n}\r\nint gxio_mpipe_rules_add_channel(gxio_mpipe_rules_t *rules,\r\nunsigned int channel)\r\n{\r\ngxio_mpipe_rules_list_t *list = &rules->list;\r\ngxio_mpipe_rules_rule_t *rule =\r\n(gxio_mpipe_rules_rule_t *) (list->rules + list->head);\r\nif (channel >= 32)\r\nreturn GXIO_MPIPE_ERR_RULES_INVALID;\r\nif (list->tail == 0)\r\nreturn GXIO_MPIPE_ERR_RULES_EMPTY;\r\nrule->channel_bits |= (1UL << channel);\r\nreturn 0;\r\n}\r\nint gxio_mpipe_rules_set_headroom(gxio_mpipe_rules_t *rules, uint8_t headroom)\r\n{\r\ngxio_mpipe_rules_list_t *list = &rules->list;\r\ngxio_mpipe_rules_rule_t *rule =\r\n(gxio_mpipe_rules_rule_t *) (list->rules + list->head);\r\nif (list->tail == 0)\r\nreturn GXIO_MPIPE_ERR_RULES_EMPTY;\r\nrule->headroom = headroom;\r\nreturn 0;\r\n}\r\nint gxio_mpipe_rules_commit(gxio_mpipe_rules_t *rules)\r\n{\r\ngxio_mpipe_rules_list_t *list = &rules->list;\r\nunsigned int size =\r\noffsetof(gxio_mpipe_rules_list_t, rules) + list->tail;\r\nreturn gxio_mpipe_commit_rules(rules->context, list, size);\r\n}\r\nint gxio_mpipe_iqueue_init(gxio_mpipe_iqueue_t *iqueue,\r\ngxio_mpipe_context_t *context,\r\nunsigned int ring,\r\nvoid *mem, size_t mem_size, unsigned int mem_flags)\r\n{\r\nunsigned int num_entries = mem_size / sizeof(gxio_mpipe_idesc_t);\r\niqueue->context = context;\r\niqueue->idescs = (gxio_mpipe_idesc_t *)mem;\r\niqueue->ring = ring;\r\niqueue->num_entries = num_entries;\r\niqueue->mask_num_entries = num_entries - 1;\r\niqueue->log2_num_entries = __builtin_ctz(num_entries);\r\niqueue->head = 1;\r\n#ifdef __BIG_ENDIAN__\r\niqueue->swapped = 0;\r\n#endif\r\n__gxio_mmio_write(mem, iqueue->head);\r\nreturn gxio_mpipe_init_notif_ring(context, ring, mem, mem_size,\r\nmem_flags);\r\n}\r\nint gxio_mpipe_equeue_init(gxio_mpipe_equeue_t *equeue,\r\ngxio_mpipe_context_t *context,\r\nunsigned int ering,\r\nunsigned int channel,\r\nvoid *mem, unsigned int mem_size,\r\nunsigned int mem_flags)\r\n{\r\nunsigned int num_entries = mem_size / sizeof(gxio_mpipe_edesc_t);\r\nMPIPE_EDMA_POST_REGION_ADDR_t offset;\r\nint result = gxio_mpipe_init_edma_ring(context, ering, channel,\r\nmem, mem_size, mem_flags);\r\nif (result < 0)\r\nreturn result;\r\nmemset(equeue, 0, sizeof(*equeue));\r\noffset.word = 0;\r\noffset.region =\r\nMPIPE_MMIO_ADDR__REGION_VAL_EDMA -\r\nMPIPE_MMIO_ADDR__REGION_VAL_IDMA;\r\noffset.ring = ering;\r\n__gxio_dma_queue_init(&equeue->dma_queue,\r\ncontext->mmio_fast_base + offset.word,\r\nnum_entries);\r\nequeue->edescs = mem;\r\nequeue->mask_num_entries = num_entries - 1;\r\nequeue->log2_num_entries = __builtin_ctz(num_entries);\r\nequeue->context = context;\r\nequeue->ering = ering;\r\nequeue->channel = channel;\r\nreturn 0;\r\n}\r\nint gxio_mpipe_set_timestamp(gxio_mpipe_context_t *context,\r\nconst struct timespec *ts)\r\n{\r\ncycles_t cycles = get_cycles();\r\nreturn gxio_mpipe_set_timestamp_aux(context, (uint64_t)ts->tv_sec,\r\n(uint64_t)ts->tv_nsec,\r\n(uint64_t)cycles);\r\n}\r\nint gxio_mpipe_get_timestamp(gxio_mpipe_context_t *context,\r\nstruct timespec *ts)\r\n{\r\nint ret;\r\ncycles_t cycles_prev, cycles_now, clock_rate;\r\ncycles_prev = get_cycles();\r\nret = gxio_mpipe_get_timestamp_aux(context, (uint64_t *)&ts->tv_sec,\r\n(uint64_t *)&ts->tv_nsec,\r\n(uint64_t *)&cycles_now);\r\nif (ret < 0) {\r\nreturn ret;\r\n}\r\nclock_rate = get_clock_rate();\r\nts->tv_nsec -= (cycles_now - cycles_prev) * 1000000000LL / clock_rate;\r\nif (ts->tv_nsec < 0) {\r\nts->tv_nsec += 1000000000LL;\r\nts->tv_sec -= 1;\r\n}\r\nreturn ret;\r\n}\r\nint gxio_mpipe_adjust_timestamp(gxio_mpipe_context_t *context, int64_t delta)\r\n{\r\nreturn gxio_mpipe_adjust_timestamp_aux(context, delta);\r\n}\r\nstatic gxio_mpipe_context_t *_gxio_get_link_context(void)\r\n{\r\nstatic gxio_mpipe_context_t context;\r\nstatic gxio_mpipe_context_t *contextp;\r\nstatic int tried_open = 0;\r\nstatic DEFINE_MUTEX(mutex);\r\nmutex_lock(&mutex);\r\nif (!tried_open) {\r\nint i = 0;\r\ntried_open = 1;\r\nfor (i = 0; i < 4; i++) {\r\nchar file[80];\r\nsnprintf(file, sizeof(file), "mpipe/%d/iorpc_info", i);\r\ncontext.fd = hv_dev_open((HV_VirtAddr) file, 0);\r\nif (context.fd < 0)\r\ncontinue;\r\ncontextp = &context;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&mutex);\r\nreturn contextp;\r\n}\r\nint gxio_mpipe_link_instance(const char *link_name)\r\n{\r\n_gxio_mpipe_link_name_t name;\r\ngxio_mpipe_context_t *context = _gxio_get_link_context();\r\nif (!context)\r\nreturn GXIO_ERR_NO_DEVICE;\r\nstrncpy(name.name, link_name, sizeof(name.name));\r\nname.name[GXIO_MPIPE_LINK_NAME_LEN - 1] = '\0';\r\nreturn gxio_mpipe_info_instance_aux(context, name);\r\n}\r\nint gxio_mpipe_link_enumerate_mac(int idx, char *link_name, uint8_t *link_mac)\r\n{\r\nint rv;\r\n_gxio_mpipe_link_name_t name;\r\n_gxio_mpipe_link_mac_t mac;\r\ngxio_mpipe_context_t *context = _gxio_get_link_context();\r\nif (!context)\r\nreturn GXIO_ERR_NO_DEVICE;\r\nrv = gxio_mpipe_info_enumerate_aux(context, idx, &name, &mac);\r\nif (rv >= 0) {\r\nstrncpy(link_name, name.name, sizeof(name.name));\r\nmemcpy(link_mac, mac.mac, sizeof(mac.mac));\r\n}\r\nreturn rv;\r\n}\r\nint gxio_mpipe_link_open(gxio_mpipe_link_t *link,\r\ngxio_mpipe_context_t *context, const char *link_name,\r\nunsigned int flags)\r\n{\r\n_gxio_mpipe_link_name_t name;\r\nint rv;\r\nstrncpy(name.name, link_name, sizeof(name.name));\r\nname.name[GXIO_MPIPE_LINK_NAME_LEN - 1] = '\0';\r\nrv = gxio_mpipe_link_open_aux(context, name, flags);\r\nif (rv < 0)\r\nreturn rv;\r\nlink->context = context;\r\nlink->channel = rv >> 8;\r\nlink->mac = rv & 0xFF;\r\nreturn 0;\r\n}\r\nint gxio_mpipe_link_close(gxio_mpipe_link_t *link)\r\n{\r\nreturn gxio_mpipe_link_close_aux(link->context, link->mac);\r\n}\r\nint gxio_mpipe_link_set_attr(gxio_mpipe_link_t *link, uint32_t attr,\r\nint64_t val)\r\n{\r\nreturn gxio_mpipe_link_set_attr_aux(link->context, link->mac, attr,\r\nval);\r\n}
