static u8 clk_composite_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *mux_ops = composite->mux_ops;\r\nstruct clk_hw *mux_hw = composite->mux_hw;\r\nmux_hw->clk = hw->clk;\r\nreturn mux_ops->get_parent(mux_hw);\r\n}\r\nstatic int clk_composite_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *mux_ops = composite->mux_ops;\r\nstruct clk_hw *mux_hw = composite->mux_hw;\r\nmux_hw->clk = hw->clk;\r\nreturn mux_ops->set_parent(mux_hw, index);\r\n}\r\nstatic unsigned long clk_composite_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *rate_ops = composite->rate_ops;\r\nstruct clk_hw *rate_hw = composite->rate_hw;\r\nrate_hw->clk = hw->clk;\r\nreturn rate_ops->recalc_rate(rate_hw, parent_rate);\r\n}\r\nstatic long clk_composite_determine_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *best_parent_rate,\r\nstruct clk **best_parent_p)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *rate_ops = composite->rate_ops;\r\nconst struct clk_ops *mux_ops = composite->mux_ops;\r\nstruct clk_hw *rate_hw = composite->rate_hw;\r\nstruct clk_hw *mux_hw = composite->mux_hw;\r\nif (rate_hw && rate_ops && rate_ops->determine_rate) {\r\nrate_hw->clk = hw->clk;\r\nreturn rate_ops->determine_rate(rate_hw, rate, best_parent_rate,\r\nbest_parent_p);\r\n} else if (mux_hw && mux_ops && mux_ops->determine_rate) {\r\nmux_hw->clk = hw->clk;\r\nreturn mux_ops->determine_rate(mux_hw, rate, best_parent_rate,\r\nbest_parent_p);\r\n} else {\r\npr_err("clk: clk_composite_determine_rate function called, but no mux or rate callback set!\n");\r\nreturn 0;\r\n}\r\n}\r\nstatic long clk_composite_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *rate_ops = composite->rate_ops;\r\nstruct clk_hw *rate_hw = composite->rate_hw;\r\nrate_hw->clk = hw->clk;\r\nreturn rate_ops->round_rate(rate_hw, rate, prate);\r\n}\r\nstatic int clk_composite_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *rate_ops = composite->rate_ops;\r\nstruct clk_hw *rate_hw = composite->rate_hw;\r\nrate_hw->clk = hw->clk;\r\nreturn rate_ops->set_rate(rate_hw, rate, parent_rate);\r\n}\r\nstatic int clk_composite_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *gate_ops = composite->gate_ops;\r\nstruct clk_hw *gate_hw = composite->gate_hw;\r\ngate_hw->clk = hw->clk;\r\nreturn gate_ops->is_enabled(gate_hw);\r\n}\r\nstatic int clk_composite_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *gate_ops = composite->gate_ops;\r\nstruct clk_hw *gate_hw = composite->gate_hw;\r\ngate_hw->clk = hw->clk;\r\nreturn gate_ops->enable(gate_hw);\r\n}\r\nstatic void clk_composite_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *gate_ops = composite->gate_ops;\r\nstruct clk_hw *gate_hw = composite->gate_hw;\r\ngate_hw->clk = hw->clk;\r\ngate_ops->disable(gate_hw);\r\n}\r\nstruct clk *clk_register_composite(struct device *dev, const char *name,\r\nconst char **parent_names, int num_parents,\r\nstruct clk_hw *mux_hw, const struct clk_ops *mux_ops,\r\nstruct clk_hw *rate_hw, const struct clk_ops *rate_ops,\r\nstruct clk_hw *gate_hw, const struct clk_ops *gate_ops,\r\nunsigned long flags)\r\n{\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nstruct clk_composite *composite;\r\nstruct clk_ops *clk_composite_ops;\r\ncomposite = kzalloc(sizeof(*composite), GFP_KERNEL);\r\nif (!composite) {\r\npr_err("%s: could not allocate composite clk\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\nclk_composite_ops = &composite->ops;\r\nif (mux_hw && mux_ops) {\r\nif (!mux_ops->get_parent || !mux_ops->set_parent) {\r\nclk = ERR_PTR(-EINVAL);\r\ngoto err;\r\n}\r\ncomposite->mux_hw = mux_hw;\r\ncomposite->mux_ops = mux_ops;\r\nclk_composite_ops->get_parent = clk_composite_get_parent;\r\nclk_composite_ops->set_parent = clk_composite_set_parent;\r\nif (mux_ops->determine_rate)\r\nclk_composite_ops->determine_rate = clk_composite_determine_rate;\r\n}\r\nif (rate_hw && rate_ops) {\r\nif (!rate_ops->recalc_rate) {\r\nclk = ERR_PTR(-EINVAL);\r\ngoto err;\r\n}\r\nif (rate_ops->round_rate) {\r\nclk_composite_ops->round_rate = clk_composite_round_rate;\r\nif (rate_ops->set_rate) {\r\nclk_composite_ops->set_rate = clk_composite_set_rate;\r\n}\r\n} else {\r\nWARN(rate_ops->set_rate,\r\n"%s: missing round_rate op is required\n",\r\n__func__);\r\n}\r\ncomposite->rate_hw = rate_hw;\r\ncomposite->rate_ops = rate_ops;\r\nclk_composite_ops->recalc_rate = clk_composite_recalc_rate;\r\nif (rate_ops->determine_rate)\r\nclk_composite_ops->determine_rate = clk_composite_determine_rate;\r\n}\r\nif (gate_hw && gate_ops) {\r\nif (!gate_ops->is_enabled || !gate_ops->enable ||\r\n!gate_ops->disable) {\r\nclk = ERR_PTR(-EINVAL);\r\ngoto err;\r\n}\r\ncomposite->gate_hw = gate_hw;\r\ncomposite->gate_ops = gate_ops;\r\nclk_composite_ops->is_enabled = clk_composite_is_enabled;\r\nclk_composite_ops->enable = clk_composite_enable;\r\nclk_composite_ops->disable = clk_composite_disable;\r\n}\r\ninit.ops = clk_composite_ops;\r\ncomposite->hw.init = &init;\r\nclk = clk_register(dev, &composite->hw);\r\nif (IS_ERR(clk))\r\ngoto err;\r\nif (composite->mux_hw)\r\ncomposite->mux_hw->clk = clk;\r\nif (composite->rate_hw)\r\ncomposite->rate_hw->clk = clk;\r\nif (composite->gate_hw)\r\ncomposite->gate_hw->clk = clk;\r\nreturn clk;\r\nerr:\r\nkfree(composite);\r\nreturn clk;\r\n}
