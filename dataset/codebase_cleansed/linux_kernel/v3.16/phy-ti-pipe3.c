static inline u32 ti_pipe3_readl(void __iomem *addr, unsigned offset)\r\n{\r\nreturn __raw_readl(addr + offset);\r\n}\r\nstatic inline void ti_pipe3_writel(void __iomem *addr, unsigned offset,\r\nu32 data)\r\n{\r\n__raw_writel(data, addr + offset);\r\n}\r\nstatic struct pipe3_dpll_params *ti_pipe3_get_dpll_params(struct ti_pipe3 *phy)\r\n{\r\nunsigned long rate;\r\nstruct pipe3_dpll_map *dpll_map = phy->dpll_map;\r\nrate = clk_get_rate(phy->sys_clk);\r\nfor (; dpll_map->rate; dpll_map++) {\r\nif (rate == dpll_map->rate)\r\nreturn &dpll_map->params;\r\n}\r\ndev_err(phy->dev, "No DPLL configuration for %lu Hz SYS CLK\n", rate);\r\nreturn NULL;\r\n}\r\nstatic int ti_pipe3_power_off(struct phy *x)\r\n{\r\nstruct ti_pipe3 *phy = phy_get_drvdata(x);\r\nomap_control_phy_power(phy->control_dev, 0);\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_power_on(struct phy *x)\r\n{\r\nstruct ti_pipe3 *phy = phy_get_drvdata(x);\r\nomap_control_phy_power(phy->control_dev, 1);\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_dpll_wait_lock(struct ti_pipe3 *phy)\r\n{\r\nu32 val;\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(PLL_LOCK_TIME);\r\ndo {\r\ncpu_relax();\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);\r\nif (val & PLL_LOCK)\r\nbreak;\r\n} while (!time_after(jiffies, timeout));\r\nif (!(val & PLL_LOCK)) {\r\ndev_err(phy->dev, "DPLL failed to lock\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_dpll_program(struct ti_pipe3 *phy)\r\n{\r\nu32 val;\r\nstruct pipe3_dpll_params *dpll_params;\r\ndpll_params = ti_pipe3_get_dpll_params(phy);\r\nif (!dpll_params)\r\nreturn -EINVAL;\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION1);\r\nval &= ~PLL_REGN_MASK;\r\nval |= dpll_params->n << PLL_REGN_SHIFT;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION1, val);\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\r\nval &= ~PLL_SELFREQDCO_MASK;\r\nval |= dpll_params->freq << PLL_SELFREQDCO_SHIFT;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION1);\r\nval &= ~PLL_REGM_MASK;\r\nval |= dpll_params->m << PLL_REGM_SHIFT;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION1, val);\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION4);\r\nval &= ~PLL_REGM_F_MASK;\r\nval |= dpll_params->mf << PLL_REGM_F_SHIFT;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION4, val);\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION3);\r\nval &= ~PLL_SD_MASK;\r\nval |= dpll_params->sd << PLL_SD_SHIFT;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION3, val);\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_GO, SET_PLL_GO);\r\nreturn ti_pipe3_dpll_wait_lock(phy);\r\n}\r\nstatic int ti_pipe3_init(struct phy *x)\r\n{\r\nstruct ti_pipe3 *phy = phy_get_drvdata(x);\r\nu32 val;\r\nint ret = 0;\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\r\nif (val & PLL_IDLE) {\r\nval &= ~PLL_IDLE;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\r\nret = ti_pipe3_dpll_wait_lock(phy);\r\n}\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);\r\nif (!(val & PLL_LOCK))\r\nif (ti_pipe3_dpll_program(phy))\r\nreturn -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int ti_pipe3_exit(struct phy *x)\r\n{\r\nstruct ti_pipe3 *phy = phy_get_drvdata(x);\r\nu32 val;\r\nunsigned long timeout;\r\nif (of_device_is_compatible(phy->dev->of_node, "ti,phy-pipe3-sata"))\r\nreturn 0;\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\r\nval |= PLL_IDLE;\r\nti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\r\ntimeout = jiffies + msecs_to_jiffies(PLL_IDLE_TIME);\r\ndo {\r\ncpu_relax();\r\nval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);\r\nif ((val & PLL_TICOPWDN) && (val & PLL_LDOPWDN))\r\nbreak;\r\n} while (!time_after(jiffies, timeout));\r\nif (!(val & PLL_TICOPWDN) || !(val & PLL_LDOPWDN)) {\r\ndev_err(phy->dev, "Failed to power down: PLL_STATUS 0x%x\n",\r\nval);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_probe(struct platform_device *pdev)\r\n{\r\nstruct ti_pipe3 *phy;\r\nstruct phy *generic_phy;\r\nstruct phy_provider *phy_provider;\r\nstruct resource *res;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *control_node;\r\nstruct platform_device *control_pdev;\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(of_match_ptr(ti_pipe3_id_table), &pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nphy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy) {\r\ndev_err(&pdev->dev, "unable to alloc mem for TI PIPE3 PHY\n");\r\nreturn -ENOMEM;\r\n}\r\nphy->dpll_map = (struct pipe3_dpll_map *)match->data;\r\nif (!phy->dpll_map) {\r\ndev_err(&pdev->dev, "no DPLL data\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pll_ctrl");\r\nphy->pll_ctrl_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(phy->pll_ctrl_base))\r\nreturn PTR_ERR(phy->pll_ctrl_base);\r\nphy->dev = &pdev->dev;\r\nif (!of_device_is_compatible(node, "ti,phy-pipe3-sata")) {\r\nphy->wkupclk = devm_clk_get(phy->dev, "wkupclk");\r\nif (IS_ERR(phy->wkupclk)) {\r\ndev_err(&pdev->dev, "unable to get wkupclk\n");\r\nreturn PTR_ERR(phy->wkupclk);\r\n}\r\nphy->refclk = devm_clk_get(phy->dev, "refclk");\r\nif (IS_ERR(phy->refclk)) {\r\ndev_err(&pdev->dev, "unable to get refclk\n");\r\nreturn PTR_ERR(phy->refclk);\r\n}\r\n} else {\r\nphy->wkupclk = ERR_PTR(-ENODEV);\r\nphy->refclk = ERR_PTR(-ENODEV);\r\n}\r\nphy->sys_clk = devm_clk_get(phy->dev, "sysclk");\r\nif (IS_ERR(phy->sys_clk)) {\r\ndev_err(&pdev->dev, "unable to get sysclk\n");\r\nreturn -EINVAL;\r\n}\r\ncontrol_node = of_parse_phandle(node, "ctrl-module", 0);\r\nif (!control_node) {\r\ndev_err(&pdev->dev, "Failed to get control device phandle\n");\r\nreturn -EINVAL;\r\n}\r\ncontrol_pdev = of_find_device_by_node(control_node);\r\nif (!control_pdev) {\r\ndev_err(&pdev->dev, "Failed to get control device\n");\r\nreturn -EINVAL;\r\n}\r\nphy->control_dev = &control_pdev->dev;\r\nomap_control_phy_power(phy->control_dev, 0);\r\nplatform_set_drvdata(pdev, phy);\r\npm_runtime_enable(phy->dev);\r\ngeneric_phy = devm_phy_create(phy->dev, &ops, NULL);\r\nif (IS_ERR(generic_phy))\r\nreturn PTR_ERR(generic_phy);\r\nphy_set_drvdata(generic_phy, phy);\r\nphy_provider = devm_of_phy_provider_register(phy->dev,\r\nof_phy_simple_xlate);\r\nif (IS_ERR(phy_provider))\r\nreturn PTR_ERR(phy_provider);\r\npm_runtime_get(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_remove(struct platform_device *pdev)\r\n{\r\nif (!pm_runtime_suspended(&pdev->dev))\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_runtime_suspend(struct device *dev)\r\n{\r\nstruct ti_pipe3 *phy = dev_get_drvdata(dev);\r\nif (!IS_ERR(phy->wkupclk))\r\nclk_disable_unprepare(phy->wkupclk);\r\nif (!IS_ERR(phy->refclk))\r\nclk_disable_unprepare(phy->refclk);\r\nreturn 0;\r\n}\r\nstatic int ti_pipe3_runtime_resume(struct device *dev)\r\n{\r\nu32 ret = 0;\r\nstruct ti_pipe3 *phy = dev_get_drvdata(dev);\r\nif (!IS_ERR(phy->refclk)) {\r\nret = clk_prepare_enable(phy->refclk);\r\nif (ret) {\r\ndev_err(phy->dev, "Failed to enable refclk %d\n", ret);\r\ngoto err1;\r\n}\r\n}\r\nif (!IS_ERR(phy->wkupclk)) {\r\nret = clk_prepare_enable(phy->wkupclk);\r\nif (ret) {\r\ndev_err(phy->dev, "Failed to enable wkupclk %d\n", ret);\r\ngoto err2;\r\n}\r\n}\r\nreturn 0;\r\nerr2:\r\nif (!IS_ERR(phy->refclk))\r\nclk_disable_unprepare(phy->refclk);\r\nerr1:\r\nreturn ret;\r\n}
