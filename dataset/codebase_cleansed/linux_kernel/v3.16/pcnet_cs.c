static inline pcnet_dev_t *PRIV(struct net_device *dev)\r\n{\r\nchar *p = netdev_priv(dev);\r\nreturn (pcnet_dev_t *)(p + sizeof(struct ei_device));\r\n}\r\nstatic int pcnet_probe(struct pcmcia_device *link)\r\n{\r\npcnet_dev_t *info;\r\nstruct net_device *dev;\r\ndev_dbg(&link->dev, "pcnet_attach()\n");\r\ndev = __alloc_ei_netdev(sizeof(pcnet_dev_t));\r\nif (!dev) return -ENOMEM;\r\ninfo = PRIV(dev);\r\ninfo->p_dev = link;\r\nlink->priv = dev;\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\ndev->netdev_ops = &pcnet_netdev_ops;\r\nreturn pcnet_config(link);\r\n}\r\nstatic void pcnet_detach(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\ndev_dbg(&link->dev, "pcnet_detach\n");\r\nunregister_netdev(dev);\r\npcnet_release(link);\r\nfree_netdev(dev);\r\n}\r\nstatic hw_info_t *get_hwinfo(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nu_char __iomem *base, *virt;\r\nint i, j;\r\nlink->resource[2]->flags |= WIN_DATA_WIDTH_8|WIN_MEMORY_TYPE_AM|WIN_ENABLE;\r\nlink->resource[2]->start = 0; link->resource[2]->end = 0;\r\ni = pcmcia_request_window(link, link->resource[2], 0);\r\nif (i != 0)\r\nreturn NULL;\r\nvirt = ioremap(link->resource[2]->start,\r\nresource_size(link->resource[2]));\r\nfor (i = 0; i < NR_INFO; i++) {\r\npcmcia_map_mem_page(link, link->resource[2],\r\nhw_info[i].offset & ~(resource_size(link->resource[2])-1));\r\nbase = &virt[hw_info[i].offset & (resource_size(link->resource[2])-1)];\r\nif ((readb(base+0) == hw_info[i].a0) &&\r\n(readb(base+2) == hw_info[i].a1) &&\r\n(readb(base+4) == hw_info[i].a2)) {\r\nfor (j = 0; j < 6; j++)\r\ndev->dev_addr[j] = readb(base + (j<<1));\r\nbreak;\r\n}\r\n}\r\niounmap(virt);\r\nj = pcmcia_release_window(link, link->resource[2]);\r\nreturn (i < NR_INFO) ? hw_info+i : NULL;\r\n}\r\nstatic hw_info_t *get_prom(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nunsigned int ioaddr = dev->base_addr;\r\nu_char prom[32];\r\nint i, j;\r\nstruct {\r\nu_char value, offset;\r\n} program_seq[] = {\r\n{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD},\r\n{0x48, EN0_DCFG},\r\n{0x00, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_IMR},\r\n{0xFF, EN0_ISR},\r\n{E8390_RXOFF, EN0_RXCR},\r\n{E8390_TXOFF, EN0_TXCR},\r\n{32, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_RSARLO},\r\n{0x00, EN0_RSARHI},\r\n{E8390_RREAD+E8390_START, E8390_CMD},\r\n};\r\npcnet_reset_8390(dev);\r\nmdelay(10);\r\nfor (i = 0; i < ARRAY_SIZE(program_seq); i++)\r\noutb_p(program_seq[i].value, ioaddr + program_seq[i].offset);\r\nfor (i = 0; i < 32; i++)\r\nprom[i] = inb(ioaddr + PCNET_DATAPORT);\r\nfor (i = 0; i < NR_INFO; i++) {\r\nif ((prom[0] == hw_info[i].a0) &&\r\n(prom[2] == hw_info[i].a1) &&\r\n(prom[4] == hw_info[i].a2))\r\nbreak;\r\n}\r\nif ((i < NR_INFO) || ((prom[28] == 0x57) && (prom[30] == 0x57))) {\r\nfor (j = 0; j < 6; j++)\r\ndev->dev_addr[j] = prom[j<<1];\r\nreturn (i < NR_INFO) ? hw_info+i : &default_info;\r\n}\r\nreturn NULL;\r\n}\r\nstatic hw_info_t *get_dl10019(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nint i;\r\nu_char sum;\r\nfor (sum = 0, i = 0x14; i < 0x1c; i++)\r\nsum += inb_p(dev->base_addr + i);\r\nif (sum != 0xff)\r\nreturn NULL;\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb_p(dev->base_addr + 0x14 + i);\r\ni = inb(dev->base_addr + 0x1f);\r\nreturn ((i == 0x91)||(i == 0x99)) ? &dl10022_info : &dl10019_info;\r\n}\r\nstatic hw_info_t *get_ax88190(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nunsigned int ioaddr = dev->base_addr;\r\nint i, j;\r\nif (link->config_base != 0x03c0)\r\nreturn NULL;\r\noutb_p(0x01, ioaddr + EN0_DCFG);\r\noutb_p(0x00, ioaddr + EN0_RSARLO);\r\noutb_p(0x04, ioaddr + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, ioaddr + E8390_CMD);\r\nfor (i = 0; i < 6; i += 2) {\r\nj = inw(ioaddr + PCNET_DATAPORT);\r\ndev->dev_addr[i] = j & 0xff;\r\ndev->dev_addr[i+1] = j >> 8;\r\n}\r\nreturn NULL;\r\n}\r\nstatic hw_info_t *get_hwired(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\nif (hw_addr[i] != 0) break;\r\nif (i == 6)\r\nreturn NULL;\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = hw_addr[i];\r\nreturn &default_info;\r\n}\r\nstatic int try_io_port(struct pcmcia_device *link)\r\n{\r\nint j, ret;\r\nlink->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\nlink->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\r\nif (link->resource[0]->end == 32) {\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\nif (link->resource[1]->end > 0) {\r\nlink->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\r\n}\r\n} else {\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\nlink->resource[1]->flags |= IO_DATA_PATH_WIDTH_16;\r\n}\r\nif (link->resource[0]->start == 0) {\r\nfor (j = 0; j < 0x400; j += 0x20) {\r\nlink->resource[0]->start = j ^ 0x300;\r\nlink->resource[1]->start = (j ^ 0x300) + 0x10;\r\nlink->io_lines = 16;\r\nret = pcmcia_request_io(link);\r\nif (ret == 0)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n} else {\r\nreturn pcmcia_request_io(link);\r\n}\r\n}\r\nstatic int pcnet_confcheck(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nint *priv = priv_data;\r\nint try = (*priv & 0x1);\r\n*priv &= (p_dev->resource[2]->end >= 0x4000) ? 0x10 : ~0x10;\r\nif (p_dev->config_index == 0)\r\nreturn -EINVAL;\r\nif (p_dev->resource[0]->end + p_dev->resource[1]->end < 32)\r\nreturn -EINVAL;\r\nif (try)\r\np_dev->io_lines = 16;\r\nreturn try_io_port(p_dev);\r\n}\r\nstatic hw_info_t *pcnet_try_config(struct pcmcia_device *link,\r\nint *has_shmem, int try)\r\n{\r\nstruct net_device *dev = link->priv;\r\nhw_info_t *local_hw_info;\r\npcnet_dev_t *info = PRIV(dev);\r\nint priv = try;\r\nint ret;\r\nret = pcmcia_loop_config(link, pcnet_confcheck, &priv);\r\nif (ret) {\r\ndev_warn(&link->dev, "no useable port range found\n");\r\nreturn NULL;\r\n}\r\n*has_shmem = (priv & 0x10);\r\nif (!link->irq)\r\nreturn NULL;\r\nif (resource_size(link->resource[1]) == 8)\r\nlink->config_flags |= CONF_ENABLE_SPKR;\r\nif ((link->manf_id == MANFID_IBM) &&\r\n(link->card_id == PRODID_IBM_HOME_AND_AWAY))\r\nlink->config_index |= 0x10;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\nreturn NULL;\r\ndev->irq = link->irq;\r\ndev->base_addr = link->resource[0]->start;\r\nif (info->flags & HAS_MISC_REG) {\r\nif ((if_port == 1) || (if_port == 2))\r\ndev->if_port = if_port;\r\nelse\r\ndev_notice(&link->dev, "invalid if_port requested\n");\r\n} else\r\ndev->if_port = 0;\r\nif ((link->config_base == 0x03c0) &&\r\n(link->manf_id == 0x149) && (link->card_id == 0xc1ab)) {\r\ndev_info(&link->dev,\r\n"this is an AX88190 card - use axnet_cs instead.\n");\r\nreturn NULL;\r\n}\r\nlocal_hw_info = get_hwinfo(link);\r\nif (!local_hw_info)\r\nlocal_hw_info = get_prom(link);\r\nif (!local_hw_info)\r\nlocal_hw_info = get_dl10019(link);\r\nif (!local_hw_info)\r\nlocal_hw_info = get_ax88190(link);\r\nif (!local_hw_info)\r\nlocal_hw_info = get_hwired(link);\r\nreturn local_hw_info;\r\n}\r\nstatic int pcnet_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\npcnet_dev_t *info = PRIV(dev);\r\nint start_pg, stop_pg, cm_offset;\r\nint has_shmem = 0;\r\nhw_info_t *local_hw_info;\r\nstruct ei_device *ei_local;\r\ndev_dbg(&link->dev, "pcnet_config\n");\r\nlocal_hw_info = pcnet_try_config(link, &has_shmem, 0);\r\nif (!local_hw_info) {\r\npcmcia_disable_device(link);\r\nlocal_hw_info = pcnet_try_config(link, &has_shmem, 1);\r\nif (local_hw_info == NULL) {\r\ndev_notice(&link->dev, "unable to read hardware net"\r\n" address for io base %#3lx\n", dev->base_addr);\r\ngoto failed;\r\n}\r\n}\r\ninfo->flags = local_hw_info->flags;\r\ninfo->flags |= (delay_output) ? DELAY_OUTPUT : 0;\r\nif ((link->manf_id == MANFID_SOCKET) &&\r\n((link->card_id == PRODID_SOCKET_LPE) ||\r\n(link->card_id == PRODID_SOCKET_LPE_CF) ||\r\n(link->card_id == PRODID_SOCKET_EIO)))\r\ninfo->flags &= ~USE_BIG_BUF;\r\nif (!use_big_buf)\r\ninfo->flags &= ~USE_BIG_BUF;\r\nif (info->flags & USE_BIG_BUF) {\r\nstart_pg = SOCKET_START_PG;\r\nstop_pg = SOCKET_STOP_PG;\r\ncm_offset = 0x10000;\r\n} else {\r\nstart_pg = PCNET_START_PG;\r\nstop_pg = PCNET_STOP_PG;\r\ncm_offset = 0;\r\n}\r\nif ((use_shmem == 0) || (!has_shmem && (use_shmem == -1)) ||\r\n(setup_shmem_window(link, start_pg, stop_pg, cm_offset) != 0))\r\nsetup_dma_config(link, start_pg, stop_pg);\r\nei_status.name = "NE2000";\r\nei_status.word16 = 1;\r\nei_status.reset_8390 = pcnet_reset_8390;\r\nif (info->flags & (IS_DL10019|IS_DL10022))\r\nmii_phy_probe(dev);\r\nSET_NETDEV_DEV(dev, &link->dev);\r\nei_local = netdev_priv(dev);\r\nei_local->msg_enable = pcnet_msg_enable;\r\nif (register_netdev(dev) != 0) {\r\npr_notice("register_netdev() failed\n");\r\ngoto failed;\r\n}\r\nif (info->flags & (IS_DL10019|IS_DL10022)) {\r\nu_char id = inb(dev->base_addr + 0x1a);\r\nnetdev_info(dev, "NE2000 (DL100%d rev %02x): ",\r\n(info->flags & IS_DL10022) ? 22 : 19, id);\r\nif (info->pna_phy)\r\npr_cont("PNA, ");\r\n} else {\r\nnetdev_info(dev, "NE2000 Compatible: ");\r\n}\r\npr_cont("io %#3lx, irq %d,", dev->base_addr, dev->irq);\r\nif (info->flags & USE_SHMEM)\r\npr_cont(" mem %#5lx,", dev->mem_start);\r\nif (info->flags & HAS_MISC_REG)\r\npr_cont(" %s xcvr,", if_names[dev->if_port]);\r\npr_cont(" hw_addr %pM\n", dev->dev_addr);\r\nreturn 0;\r\nfailed:\r\npcnet_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void pcnet_release(struct pcmcia_device *link)\r\n{\r\npcnet_dev_t *info = PRIV(link->priv);\r\ndev_dbg(&link->dev, "pcnet_release\n");\r\nif (info->flags & USE_SHMEM)\r\niounmap(info->base);\r\npcmcia_disable_device(link);\r\n}\r\nstatic int pcnet_suspend(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open)\r\nnetif_device_detach(dev);\r\nreturn 0;\r\n}\r\nstatic int pcnet_resume(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open) {\r\npcnet_reset_8390(dev);\r\nNS8390_init(dev, 1);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mdio_sync(unsigned int addr)\r\n{\r\nint bits, mask = inb(addr) & MDIO_MASK;\r\nfor (bits = 0; bits < 32; bits++) {\r\noutb(mask | MDIO_DATA_WRITE1, addr);\r\noutb(mask | MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);\r\n}\r\n}\r\nstatic int mdio_read(unsigned int addr, int phy_id, int loc)\r\n{\r\nu_int cmd = (0x06<<10)|(phy_id<<5)|loc;\r\nint i, retval = 0, mask = inb(addr) & MDIO_MASK;\r\nmdio_sync(addr);\r\nfor (i = 13; i >= 0; i--) {\r\nint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\r\noutb(mask | dat, addr);\r\noutb(mask | dat | MDIO_SHIFT_CLK, addr);\r\n}\r\nfor (i = 19; i > 0; i--) {\r\noutb(mask, addr);\r\nretval = (retval << 1) | ((inb(addr) & MDIO_DATA_READ) != 0);\r\noutb(mask | MDIO_SHIFT_CLK, addr);\r\n}\r\nreturn (retval>>1) & 0xffff;\r\n}\r\nstatic void mdio_write(unsigned int addr, int phy_id, int loc, int value)\r\n{\r\nu_int cmd = (0x05<<28)|(phy_id<<23)|(loc<<18)|(1<<17)|value;\r\nint i, mask = inb(addr) & MDIO_MASK;\r\nmdio_sync(addr);\r\nfor (i = 31; i >= 0; i--) {\r\nint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\r\noutb(mask | dat, addr);\r\noutb(mask | dat | MDIO_SHIFT_CLK, addr);\r\n}\r\nfor (i = 1; i >= 0; i--) {\r\noutb(mask, addr);\r\noutb(mask | MDIO_SHIFT_CLK, addr);\r\n}\r\n}\r\nstatic int read_eeprom(unsigned int ioaddr, int location)\r\n{\r\nint i, retval = 0;\r\nunsigned int ee_addr = ioaddr + DLINK_EEPROM;\r\nint read_cmd = location | (EE_READ_CMD << 8);\r\noutb(0, ee_addr);\r\noutb(EE_EEP|EE_CS, ee_addr);\r\nfor (i = 10; i >= 0; i--) {\r\nshort dataval = (read_cmd & (1 << i)) ? EE_DO : 0;\r\noutb_p(EE_EEP|EE_CS|dataval, ee_addr);\r\noutb_p(EE_EEP|EE_CS|dataval|EE_CK, ee_addr);\r\n}\r\noutb(EE_EEP|EE_CS, ee_addr);\r\nfor (i = 16; i > 0; i--) {\r\noutb_p(EE_EEP|EE_CS | EE_CK, ee_addr);\r\nretval = (retval << 1) | ((inb(ee_addr) & EE_DI) ? 1 : 0);\r\noutb_p(EE_EEP|EE_CS, ee_addr);\r\n}\r\noutb(0, ee_addr);\r\nreturn retval;\r\n}\r\nstatic void write_asic(unsigned int ioaddr, int location, short asic_data)\r\n{\r\nint i;\r\nunsigned int ee_addr = ioaddr + DLINK_EEPROM;\r\nshort dataval;\r\nint read_cmd = location | (EE_READ_CMD << 8);\r\nasic_data |= read_eeprom(ioaddr, location);\r\noutb(0, ee_addr);\r\noutb(EE_ASIC|EE_CS|EE_DI, ee_addr);\r\nread_cmd = read_cmd >> 1;\r\nfor (i = 9; i >= 0; i--) {\r\ndataval = (read_cmd & (1 << i)) ? EE_DO : 0;\r\noutb_p(EE_ASIC|EE_CS|EE_DI|dataval, ee_addr);\r\noutb_p(EE_ASIC|EE_CS|EE_DI|dataval|EE_CK, ee_addr);\r\noutb_p(EE_ASIC|EE_CS|EE_DI|dataval, ee_addr);\r\n}\r\noutb(EE_ASIC|EE_CS, ee_addr);\r\noutb(EE_ASIC|EE_CS|EE_CK, ee_addr);\r\noutb(EE_ASIC|EE_CS, ee_addr);\r\nfor (i = 15; i >= 0; i--) {\r\ndataval = (asic_data & (1 << i)) ? EE_ADOT : 0;\r\noutb_p(EE_ASIC|EE_CS|dataval, ee_addr);\r\noutb_p(EE_ASIC|EE_CS|dataval|EE_CK, ee_addr);\r\noutb_p(EE_ASIC|EE_CS|dataval, ee_addr);\r\n}\r\noutb(EE_ASIC|EE_DI, ee_addr);\r\noutb(EE_ASIC|EE_DI| EE_CK, ee_addr);\r\noutb(EE_ASIC|EE_DI, ee_addr);\r\noutb(0, ee_addr);\r\n}\r\nstatic void set_misc_reg(struct net_device *dev)\r\n{\r\nunsigned int nic_base = dev->base_addr;\r\npcnet_dev_t *info = PRIV(dev);\r\nu_char tmp;\r\nif (info->flags & HAS_MISC_REG) {\r\ntmp = inb_p(nic_base + PCNET_MISC) & ~3;\r\nif (dev->if_port == 2)\r\ntmp |= 1;\r\nif (info->flags & USE_BIG_BUF)\r\ntmp |= 2;\r\nif (info->flags & HAS_IBM_MISC)\r\ntmp |= 8;\r\noutb_p(tmp, nic_base + PCNET_MISC);\r\n}\r\nif (info->flags & IS_DL10022) {\r\nif (info->flags & HAS_MII) {\r\nmdio_write(nic_base + DLINK_GPIO, info->eth_phy, 4, 0x01e1);\r\nmdio_write(nic_base + DLINK_GPIO, info->eth_phy, 0, 0x0000);\r\nmdio_write(nic_base + DLINK_GPIO, info->eth_phy, 0, 0x1200);\r\ninfo->mii_reset = jiffies;\r\n} else {\r\noutb(full_duplex ? 4 : 0, nic_base + DLINK_DIAG);\r\n}\r\n} else if (info->flags & IS_DL10019) {\r\nmdio_write(nic_base + DLINK_GPIO, info->eth_phy, 4, 0x01e1);\r\nmdio_write(nic_base + DLINK_GPIO, info->eth_phy, 0, 0x0000);\r\nmdio_write(nic_base + DLINK_GPIO, info->eth_phy, 0, 0x1200);\r\n}\r\n}\r\nstatic void mii_phy_probe(struct net_device *dev)\r\n{\r\npcnet_dev_t *info = PRIV(dev);\r\nunsigned int mii_addr = dev->base_addr + DLINK_GPIO;\r\nint i;\r\nu_int tmp, phyid;\r\nfor (i = 31; i >= 0; i--) {\r\ntmp = mdio_read(mii_addr, i, 1);\r\nif ((tmp == 0) || (tmp == 0xffff))\r\ncontinue;\r\ntmp = mdio_read(mii_addr, i, MII_PHYID_REG1);\r\nphyid = tmp << 16;\r\nphyid |= mdio_read(mii_addr, i, MII_PHYID_REG2);\r\nphyid &= MII_PHYID_REV_MASK;\r\nnetdev_dbg(dev, "MII at %d is 0x%08x\n", i, phyid);\r\nif (phyid == AM79C9XX_HOME_PHY) {\r\ninfo->pna_phy = i;\r\n} else if (phyid != AM79C9XX_ETH_PHY) {\r\ninfo->eth_phy = i;\r\n}\r\n}\r\n}\r\nstatic int pcnet_open(struct net_device *dev)\r\n{\r\nint ret;\r\npcnet_dev_t *info = PRIV(dev);\r\nstruct pcmcia_device *link = info->p_dev;\r\nunsigned int nic_base = dev->base_addr;\r\ndev_dbg(&link->dev, "pcnet_open('%s')\n", dev->name);\r\nif (!pcmcia_dev_present(link))\r\nreturn -ENODEV;\r\nset_misc_reg(dev);\r\noutb_p(0xFF, nic_base + EN0_ISR);\r\nret = request_irq(dev->irq, ei_irq_wrapper, IRQF_SHARED, dev->name, dev);\r\nif (ret)\r\nreturn ret;\r\nlink->open++;\r\ninfo->phy_id = info->eth_phy;\r\ninfo->link_status = 0x00;\r\ninit_timer(&info->watchdog);\r\ninfo->watchdog.function = ei_watchdog;\r\ninfo->watchdog.data = (u_long)dev;\r\ninfo->watchdog.expires = jiffies + HZ;\r\nadd_timer(&info->watchdog);\r\nreturn ei_open(dev);\r\n}\r\nstatic int pcnet_close(struct net_device *dev)\r\n{\r\npcnet_dev_t *info = PRIV(dev);\r\nstruct pcmcia_device *link = info->p_dev;\r\ndev_dbg(&link->dev, "pcnet_close('%s')\n", dev->name);\r\nei_close(dev);\r\nfree_irq(dev->irq, dev);\r\nlink->open--;\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&info->watchdog);\r\nreturn 0;\r\n}\r\nstatic void pcnet_reset_8390(struct net_device *dev)\r\n{\r\nunsigned int nic_base = dev->base_addr;\r\nint i;\r\nei_status.txing = ei_status.dmaing = 0;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, nic_base + E8390_CMD);\r\noutb(inb(nic_base + PCNET_RESET), nic_base + PCNET_RESET);\r\nfor (i = 0; i < 100; i++) {\r\nif ((inb_p(nic_base+EN0_ISR) & ENISR_RESET) != 0)\r\nbreak;\r\nudelay(100);\r\n}\r\noutb_p(ENISR_RESET, nic_base + EN0_ISR);\r\nif (i == 100)\r\nnetdev_err(dev, "pcnet_reset_8390() did not complete.\n");\r\nset_misc_reg(dev);\r\n}\r\nstatic int set_config(struct net_device *dev, struct ifmap *map)\r\n{\r\npcnet_dev_t *info = PRIV(dev);\r\nif ((map->port != (u_char)(-1)) && (map->port != dev->if_port)) {\r\nif (!(info->flags & HAS_MISC_REG))\r\nreturn -EOPNOTSUPP;\r\nelse if ((map->port < 1) || (map->port > 2))\r\nreturn -EINVAL;\r\ndev->if_port = map->port;\r\nnetdev_info(dev, "switched to %s port\n", if_names[dev->if_port]);\r\nNS8390_init(dev, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ei_irq_wrapper(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\npcnet_dev_t *info;\r\nirqreturn_t ret = ei_interrupt(irq, dev_id);\r\nif (ret == IRQ_HANDLED) {\r\ninfo = PRIV(dev);\r\ninfo->stale = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ei_watchdog(u_long arg)\r\n{\r\nstruct net_device *dev = (struct net_device *)arg;\r\npcnet_dev_t *info = PRIV(dev);\r\nunsigned int nic_base = dev->base_addr;\r\nunsigned int mii_addr = nic_base + DLINK_GPIO;\r\nu_short link;\r\nif (!netif_device_present(dev)) goto reschedule;\r\nif (info->stale++ && (inb_p(nic_base + EN0_ISR) & ENISR_ALL)) {\r\nif (!info->fast_poll)\r\nnetdev_info(dev, "interrupt(s) dropped!\n");\r\nei_irq_wrapper(dev->irq, dev);\r\ninfo->fast_poll = HZ;\r\n}\r\nif (info->fast_poll) {\r\ninfo->fast_poll--;\r\ninfo->watchdog.expires = jiffies + 1;\r\nadd_timer(&info->watchdog);\r\nreturn;\r\n}\r\nif (!(info->flags & HAS_MII))\r\ngoto reschedule;\r\nmdio_read(mii_addr, info->phy_id, 1);\r\nlink = mdio_read(mii_addr, info->phy_id, 1);\r\nif (!link || (link == 0xffff)) {\r\nif (info->eth_phy) {\r\ninfo->phy_id = info->eth_phy = 0;\r\n} else {\r\nnetdev_info(dev, "MII is missing!\n");\r\ninfo->flags &= ~HAS_MII;\r\n}\r\ngoto reschedule;\r\n}\r\nlink &= 0x0004;\r\nif (link != info->link_status) {\r\nu_short p = mdio_read(mii_addr, info->phy_id, 5);\r\nnetdev_info(dev, "%s link beat\n", link ? "found" : "lost");\r\nif (link && (info->flags & IS_DL10022)) {\r\noutb((p & 0x0140) ? 4 : 0, nic_base + DLINK_DIAG);\r\n} else if (link && (info->flags & IS_DL10019)) {\r\nwrite_asic(dev->base_addr, 4, (p & 0x140) ? DL19FDUPLX : 0);\r\n}\r\nif (link) {\r\nif (info->phy_id == info->eth_phy) {\r\nif (p)\r\nnetdev_info(dev, "autonegotiation complete: "\r\n"%sbaseT-%cD selected\n",\r\n((p & 0x0180) ? "100" : "10"),\r\n((p & 0x0140) ? 'F' : 'H'));\r\nelse\r\nnetdev_info(dev, "link partner did not autonegotiate\n");\r\n}\r\nNS8390_init(dev, 1);\r\n}\r\ninfo->link_status = link;\r\n}\r\nif (info->pna_phy && time_after(jiffies, info->mii_reset + 6*HZ)) {\r\nlink = mdio_read(mii_addr, info->eth_phy, 1) & 0x0004;\r\nif (((info->phy_id == info->pna_phy) && link) ||\r\n((info->phy_id != info->pna_phy) && !link)) {\r\nmdio_write(mii_addr, info->phy_id, 0, 0x0400);\r\ninfo->phy_id ^= info->pna_phy ^ info->eth_phy;\r\nnetdev_info(dev, "switched to %s transceiver\n",\r\n(info->phy_id == info->eth_phy) ? "ethernet" : "PNA");\r\nmdio_write(mii_addr, info->phy_id, 0,\r\n(info->phy_id == info->eth_phy) ? 0x1000 : 0);\r\ninfo->link_status = 0;\r\ninfo->mii_reset = jiffies;\r\n}\r\n}\r\nreschedule:\r\ninfo->watchdog.expires = jiffies + HZ;\r\nadd_timer(&info->watchdog);\r\n}\r\nstatic int ei_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\npcnet_dev_t *info = PRIV(dev);\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nunsigned int mii_addr = dev->base_addr + DLINK_GPIO;\r\nif (!(info->flags & (IS_DL10019|IS_DL10022)))\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = info->phy_id;\r\ncase SIOCGMIIREG:\r\ndata->val_out = mdio_read(mii_addr, data->phy_id, data->reg_num & 0x1f);\r\nreturn 0;\r\ncase SIOCSMIIREG:\r\nmdio_write(mii_addr, data->phy_id, data->reg_num & 0x1f, data->val_in);\r\nreturn 0;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void dma_get_8390_hdr(struct net_device *dev,\r\nstruct e8390_pkt_hdr *hdr,\r\nint ring_page)\r\n{\r\nunsigned int nic_base = dev->base_addr;\r\nif (ei_status.dmaing) {\r\nnetdev_err(dev, "DMAing conflict in dma_block_input."\r\n"[DMAstat:%1x][irqlock:%1x]\n",\r\nei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base + PCNET_CMD);\r\noutb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);\r\noutb_p(0, nic_base + EN0_RCNTHI);\r\noutb_p(0, nic_base + EN0_RSARLO);\r\noutb_p(ring_page, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base + PCNET_CMD);\r\ninsw(nic_base + PCNET_DATAPORT, hdr,\r\nsizeof(struct e8390_pkt_hdr)>>1);\r\nhdr->count = le16_to_cpu(hdr->count);\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void dma_block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nunsigned int nic_base = dev->base_addr;\r\nint xfer_count = count;\r\nchar *buf = skb->data;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nif ((netif_msg_rx_status(ei_local)) && (count != 4))\r\nnetdev_dbg(dev, "[bi=%d]\n", count+4);\r\nif (ei_status.dmaing) {\r\nnetdev_err(dev, "DMAing conflict in dma_block_input."\r\n"[DMAstat:%1x][irqlock:%1x]\n",\r\nei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base + PCNET_CMD);\r\noutb_p(count & 0xff, nic_base + EN0_RCNTLO);\r\noutb_p(count >> 8, nic_base + EN0_RCNTHI);\r\noutb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);\r\noutb_p(ring_offset >> 8, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base + PCNET_CMD);\r\ninsw(nic_base + PCNET_DATAPORT,buf,count>>1);\r\nif (count & 0x01)\r\nbuf[count-1] = inb(nic_base + PCNET_DATAPORT), xfer_count++;\r\n#ifdef PCMCIA_DEBUG\r\nif (netif_msg_rx_status(ei_local)) {\r\nint addr, tries = 20;\r\ndo {\r\nint high = inb_p(nic_base + EN0_RSARHI);\r\nint low = inb_p(nic_base + EN0_RSARLO);\r\naddr = (high << 8) + low;\r\nif (((ring_offset + xfer_count) & 0xff) == (addr & 0xff))\r\nbreak;\r\n} while (--tries > 0);\r\nif (tries <= 0)\r\nnetdev_notice(dev, "RX transfer address mismatch,"\r\n"%#4.4x (expected) vs. %#4.4x (actual).\n",\r\nring_offset + xfer_count, addr);\r\n}\r\n#endif\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void dma_block_output(struct net_device *dev, int count,\r\nconst u_char *buf, const int start_page)\r\n{\r\nunsigned int nic_base = dev->base_addr;\r\npcnet_dev_t *info = PRIV(dev);\r\n#ifdef PCMCIA_DEBUG\r\nint retries = 0;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\n#endif\r\nu_long dma_start;\r\n#ifdef PCMCIA_DEBUG\r\nnetif_dbg(ei_local, tx_queued, dev, "[bo=%d]\n", count);\r\n#endif\r\nif (count & 0x01)\r\ncount++;\r\nif (ei_status.dmaing) {\r\nnetdev_err(dev, "DMAing conflict in dma_block_output."\r\n"[DMAstat:%1x][irqlock:%1x]\n",\r\nei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base+PCNET_CMD);\r\n#ifdef PCMCIA_DEBUG\r\nretry:\r\n#endif\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\noutb_p(count & 0xff, nic_base + EN0_RCNTLO);\r\noutb_p(count >> 8, nic_base + EN0_RCNTHI);\r\noutb_p(0x00, nic_base + EN0_RSARLO);\r\noutb_p(start_page, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RWRITE+E8390_START, nic_base + PCNET_CMD);\r\noutsw(nic_base + PCNET_DATAPORT, buf, count>>1);\r\ndma_start = jiffies;\r\n#ifdef PCMCIA_DEBUG\r\nif (netif_msg_tx_queued(ei_local)) {\r\nint addr, tries = 20;\r\ndo {\r\nint high = inb_p(nic_base + EN0_RSARHI);\r\nint low = inb_p(nic_base + EN0_RSARLO);\r\naddr = (high << 8) + low;\r\nif ((start_page << 8) + count == addr)\r\nbreak;\r\n} while (--tries > 0);\r\nif (tries <= 0) {\r\nnetdev_notice(dev, "Tx packet transfer address mismatch,"\r\n"%#4.4x (expected) vs. %#4.4x (actual).\n",\r\n(start_page << 8) + count, addr);\r\nif (retries++ == 0)\r\ngoto retry;\r\n}\r\n}\r\n#endif\r\nwhile ((inb_p(nic_base + EN0_ISR) & ENISR_RDC) == 0)\r\nif (time_after(jiffies, dma_start + PCNET_RDC_TIMEOUT)) {\r\nnetdev_warn(dev, "timeout waiting for Tx RDC.\n");\r\npcnet_reset_8390(dev);\r\nNS8390_init(dev, 1);\r\nbreak;\r\n}\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\nif (info->flags & DELAY_OUTPUT)\r\nudelay((long)delay_time);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic int setup_dma_config(struct pcmcia_device *link, int start_pg,\r\nint stop_pg)\r\n{\r\nstruct net_device *dev = link->priv;\r\nei_status.tx_start_page = start_pg;\r\nei_status.rx_start_page = start_pg + TX_PAGES;\r\nei_status.stop_page = stop_pg;\r\nei_status.get_8390_hdr = dma_get_8390_hdr;\r\nei_status.block_input = dma_block_input;\r\nei_status.block_output = dma_block_output;\r\nreturn 0;\r\n}\r\nstatic void copyin(void *dest, void __iomem *src, int c)\r\n{\r\nu_short *d = dest;\r\nu_short __iomem *s = src;\r\nint odd;\r\nif (c <= 0)\r\nreturn;\r\nodd = (c & 1); c >>= 1;\r\nif (c) {\r\ndo { *d++ = __raw_readw(s++); } while (--c);\r\n}\r\nif (odd)\r\n*((u_char *)d) = readw(s) & 0xff;\r\n}\r\nstatic void copyout(void __iomem *dest, const void *src, int c)\r\n{\r\nu_short __iomem *d = dest;\r\nconst u_short *s = src;\r\nint odd;\r\nif (c <= 0)\r\nreturn;\r\nodd = (c & 1); c >>= 1;\r\nif (c) {\r\ndo { __raw_writew(*s++, d++); } while (--c);\r\n}\r\nif (odd)\r\nwritew((readw(d) & 0xff00) | *(u_char *)s, d);\r\n}\r\nstatic void shmem_get_8390_hdr(struct net_device *dev,\r\nstruct e8390_pkt_hdr *hdr,\r\nint ring_page)\r\n{\r\nvoid __iomem *xfer_start = ei_status.mem + (TX_PAGES<<8)\r\n+ (ring_page << 8)\r\n- (ei_status.rx_start_page << 8);\r\ncopyin(hdr, xfer_start, sizeof(struct e8390_pkt_hdr));\r\nhdr->count = le16_to_cpu(hdr->count);\r\n}\r\nstatic void shmem_block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nvoid __iomem *base = ei_status.mem;\r\nunsigned long offset = (TX_PAGES<<8) + ring_offset\r\n- (ei_status.rx_start_page << 8);\r\nchar *buf = skb->data;\r\nif (offset + count > ei_status.priv) {\r\nint semi_count = ei_status.priv - offset;\r\ncopyin(buf, base + offset, semi_count);\r\nbuf += semi_count;\r\noffset = TX_PAGES<<8;\r\ncount -= semi_count;\r\n}\r\ncopyin(buf, base + offset, count);\r\n}\r\nstatic void shmem_block_output(struct net_device *dev, int count,\r\nconst u_char *buf, const int start_page)\r\n{\r\nvoid __iomem *shmem = ei_status.mem + (start_page << 8);\r\nshmem -= ei_status.tx_start_page << 8;\r\ncopyout(shmem, buf, count);\r\n}\r\nstatic int setup_shmem_window(struct pcmcia_device *link, int start_pg,\r\nint stop_pg, int cm_offset)\r\n{\r\nstruct net_device *dev = link->priv;\r\npcnet_dev_t *info = PRIV(dev);\r\nint i, window_size, offset, ret;\r\nwindow_size = (stop_pg - start_pg) << 8;\r\nif (window_size > 32 * 1024)\r\nwindow_size = 32 * 1024;\r\nwindow_size = roundup_pow_of_two(window_size);\r\nlink->resource[3]->flags |= WIN_DATA_WIDTH_16|WIN_MEMORY_TYPE_CM|WIN_ENABLE;\r\nlink->resource[3]->flags |= WIN_USE_WAIT;\r\nlink->resource[3]->start = 0; link->resource[3]->end = window_size;\r\nret = pcmcia_request_window(link, link->resource[3], mem_speed);\r\nif (ret)\r\ngoto failed;\r\noffset = (start_pg << 8) + cm_offset;\r\noffset -= offset % window_size;\r\nret = pcmcia_map_mem_page(link, link->resource[3], offset);\r\nif (ret)\r\ngoto failed;\r\ninfo->base = ioremap(link->resource[3]->start,\r\nresource_size(link->resource[3]));\r\nfor (i = 0; i < (TX_PAGES<<8); i += 2)\r\n__raw_writew((i>>1), info->base+offset+i);\r\nudelay(100);\r\nfor (i = 0; i < (TX_PAGES<<8); i += 2)\r\nif (__raw_readw(info->base+offset+i) != (i>>1)) break;\r\npcnet_reset_8390(dev);\r\nif (i != (TX_PAGES<<8)) {\r\niounmap(info->base);\r\npcmcia_release_window(link, link->resource[3]);\r\ninfo->base = NULL;\r\ngoto failed;\r\n}\r\nei_status.mem = info->base + offset;\r\nei_status.priv = resource_size(link->resource[3]);\r\ndev->mem_start = (u_long)ei_status.mem;\r\ndev->mem_end = dev->mem_start + resource_size(link->resource[3]);\r\nei_status.tx_start_page = start_pg;\r\nei_status.rx_start_page = start_pg + TX_PAGES;\r\nei_status.stop_page = start_pg + (\r\n(resource_size(link->resource[3]) - offset) >> 8);\r\nei_status.get_8390_hdr = shmem_get_8390_hdr;\r\nei_status.block_input = shmem_block_input;\r\nei_status.block_output = shmem_block_output;\r\ninfo->flags |= USE_SHMEM;\r\nreturn 0;\r\nfailed:\r\nreturn 1;\r\n}
