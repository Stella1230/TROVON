static inline struct saa7185 *to_saa7185(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct saa7185, sd);\r\n}\r\nstatic inline int saa7185_read(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte(client);\r\n}\r\nstatic int saa7185_write(struct v4l2_subdev *sd, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct saa7185 *encoder = to_saa7185(sd);\r\nv4l2_dbg(1, debug, sd, "%02x set to %02x\n", reg, value);\r\nencoder->reg[reg] = value;\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int saa7185_write_block(struct v4l2_subdev *sd,\r\nconst u8 *data, unsigned int len)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct saa7185 *encoder = to_saa7185(sd);\r\nint ret = -1;\r\nu8 reg;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nu8 block_data[32];\r\nint block_len;\r\nwhile (len >= 2) {\r\nblock_len = 0;\r\nblock_data[block_len++] = reg = data[0];\r\ndo {\r\nblock_data[block_len++] =\r\nencoder->reg[reg++] = data[1];\r\nlen -= 2;\r\ndata += 2;\r\n} while (len >= 2 && data[0] == reg && block_len < 32);\r\nret = i2c_master_send(client, block_data, block_len);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n} else {\r\nwhile (len >= 2) {\r\nreg = *data++;\r\nret = saa7185_write(sd, reg, *data++);\r\nif (ret < 0)\r\nbreak;\r\nlen -= 2;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int saa7185_init(struct v4l2_subdev *sd, u32 val)\r\n{\r\nstruct saa7185 *encoder = to_saa7185(sd);\r\nsaa7185_write_block(sd, init_common, sizeof(init_common));\r\nif (encoder->norm & V4L2_STD_NTSC)\r\nsaa7185_write_block(sd, init_ntsc, sizeof(init_ntsc));\r\nelse\r\nsaa7185_write_block(sd, init_pal, sizeof(init_pal));\r\nreturn 0;\r\n}\r\nstatic int saa7185_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct saa7185 *encoder = to_saa7185(sd);\r\nif (std & V4L2_STD_NTSC)\r\nsaa7185_write_block(sd, init_ntsc, sizeof(init_ntsc));\r\nelse if (std & V4L2_STD_PAL)\r\nsaa7185_write_block(sd, init_pal, sizeof(init_pal));\r\nelse\r\nreturn -EINVAL;\r\nencoder->norm = std;\r\nreturn 0;\r\n}\r\nstatic int saa7185_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct saa7185 *encoder = to_saa7185(sd);\r\nswitch (input) {\r\ncase 0:\r\nsaa7185_write(sd, 0x3a, 0x0f);\r\nsaa7185_write(sd, 0x61, (encoder->reg[0x61] & 0xf7) | 0x08);\r\nsaa7185_write(sd, 0x6e, 0x01);\r\nbreak;\r\ncase 1:\r\nsaa7185_write(sd, 0x3a, 0x0f);\r\nsaa7185_write(sd, 0x61, (encoder->reg[0x61] & 0xf7) | 0x00);\r\nsaa7185_write(sd, 0x6e, 0x00);\r\nbreak;\r\ncase 2:\r\nsaa7185_write(sd, 0x3a, 0x8f);\r\nsaa7185_write(sd, 0x61, (encoder->reg[0x61] & 0xf7) | 0x08);\r\nsaa7185_write(sd, 0x6e, 0x01);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7185_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint i;\r\nstruct saa7185 *encoder;\r\nstruct v4l2_subdev *sd;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nencoder = devm_kzalloc(&client->dev, sizeof(*encoder), GFP_KERNEL);\r\nif (encoder == NULL)\r\nreturn -ENOMEM;\r\nencoder->norm = V4L2_STD_NTSC;\r\nsd = &encoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &saa7185_ops);\r\ni = saa7185_write_block(sd, init_common, sizeof(init_common));\r\nif (i >= 0)\r\ni = saa7185_write_block(sd, init_ntsc, sizeof(init_ntsc));\r\nif (i < 0)\r\nv4l2_dbg(1, debug, sd, "init error %d\n", i);\r\nelse\r\nv4l2_dbg(1, debug, sd, "revision 0x%x\n",\r\nsaa7185_read(sd) >> 5);\r\nreturn 0;\r\n}\r\nstatic int saa7185_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct saa7185 *encoder = to_saa7185(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nsaa7185_write(sd, 0x61, (encoder->reg[0x61]) | 0x40);\r\nreturn 0;\r\n}
