u32 dev_brd_write_fxn(void *arb, u32 dsp_add, void *host_buf,\r\nu32 ul_num_bytes, u32 mem_space)\r\n{\r\nstruct dev_object *dev_obj = (struct dev_object *)arb;\r\nu32 ul_written = 0;\r\nint status;\r\nif (dev_obj) {\r\nstatus = (*dev_obj->bridge_interface.brd_write) (\r\ndev_obj->bridge_context, host_buf,\r\ndsp_add, ul_num_bytes, mem_space);\r\nif (ul_num_bytes == 0)\r\nul_num_bytes = 1;\r\nif (!status)\r\nul_written = ul_num_bytes;\r\n}\r\nreturn ul_written;\r\n}\r\nint dev_create_device(struct dev_object **device_obj,\r\nconst char *driver_file_name,\r\nstruct cfg_devnode *dev_node_obj)\r\n{\r\nstruct cfg_hostres *host_res;\r\nstruct bridge_drv_interface *drv_fxns = NULL;\r\nstruct dev_object *dev_obj = NULL;\r\nstruct chnl_mgrattrs mgr_attrs;\r\nstruct io_attrs io_mgr_attrs;\r\nu32 num_windows;\r\nstruct drv_object *hdrv_obj = NULL;\r\nstruct drv_data *drv_datap = dev_get_drvdata(bridge);\r\nint status = 0;\r\nstatus = drv_request_bridge_res_dsp((void *)&host_res);\r\nif (status) {\r\ndev_dbg(bridge, "%s: Failed to reserve bridge resources\n",\r\n__func__);\r\ngoto leave;\r\n}\r\nbridge_drv_entry(&drv_fxns, driver_file_name);\r\nif (drv_datap && drv_datap->drv_object) {\r\nhdrv_obj = drv_datap->drv_object;\r\n} else {\r\nstatus = -EPERM;\r\npr_err("%s: Failed to retrieve the object handle\n", __func__);\r\n}\r\nif (!status) {\r\ndev_obj = kzalloc(sizeof(struct dev_object), GFP_KERNEL);\r\nif (dev_obj) {\r\ndev_obj->dev_node_obj = dev_node_obj;\r\ndev_obj->cod_mgr = NULL;\r\ndev_obj->chnl_mgr = NULL;\r\ndev_obj->deh_mgr = NULL;\r\ndev_obj->lock_owner = NULL;\r\ndev_obj->word_size = DSPWORDSIZE;\r\ndev_obj->drv_obj = hdrv_obj;\r\ndev_obj->dev_type = DSP_UNIT;\r\nstore_interface_fxns(drv_fxns,\r\n&dev_obj->bridge_interface);\r\nstatus = (dev_obj->bridge_interface.dev_create)\r\n(&dev_obj->bridge_context, dev_obj,\r\nhost_res);\r\n} else {\r\nstatus = -ENOMEM;\r\n}\r\n}\r\nif (!status)\r\nstatus = init_cod_mgr(dev_obj);\r\nif (!status) {\r\nmgr_attrs.max_channels = CHNL_MAXCHANNELS;\r\nio_mgr_attrs.birq = host_res->birq_registers;\r\nio_mgr_attrs.irq_shared =\r\n(host_res->birq_attrib & CFG_IRQSHARED);\r\nio_mgr_attrs.word_size = DSPWORDSIZE;\r\nmgr_attrs.word_size = DSPWORDSIZE;\r\nnum_windows = host_res->num_mem_windows;\r\nif (num_windows) {\r\nio_mgr_attrs.shm_base = host_res->mem_base[1] +\r\nhost_res->offset_for_monitor;\r\nio_mgr_attrs.sm_length =\r\nhost_res->mem_length[1] -\r\nhost_res->offset_for_monitor;\r\n} else {\r\nio_mgr_attrs.shm_base = 0;\r\nio_mgr_attrs.sm_length = 0;\r\npr_err("%s: No memory reserved for shared structures\n",\r\n__func__);\r\n}\r\nstatus = chnl_create(&dev_obj->chnl_mgr, dev_obj, &mgr_attrs);\r\nif (status == -ENOSYS) {\r\nstatus = 0;\r\n}\r\nstatus = cmm_create(&dev_obj->cmm_mgr,\r\n(struct dev_object *)dev_obj, NULL);\r\nif (!status && dev_obj->chnl_mgr) {\r\nstatus = io_create(&dev_obj->iomgr, dev_obj,\r\n&io_mgr_attrs);\r\n}\r\nif (!status) {\r\nstatus = bridge_deh_create(&dev_obj->deh_mgr, dev_obj);\r\n}\r\nstatus = dmm_create(&dev_obj->dmm_mgr,\r\n(struct dev_object *)dev_obj, NULL);\r\n}\r\nif (!status)\r\nstatus = drv_insert_dev_object(hdrv_obj, dev_obj);\r\nif (!status)\r\nINIT_LIST_HEAD(&dev_obj->proc_list);\r\nleave:\r\nif (!status) {\r\n*device_obj = dev_obj;\r\n} else {\r\nif (dev_obj) {\r\nif (dev_obj->cod_mgr)\r\ncod_delete(dev_obj->cod_mgr);\r\nif (dev_obj->dmm_mgr)\r\ndmm_destroy(dev_obj->dmm_mgr);\r\nkfree(dev_obj);\r\n}\r\n*device_obj = NULL;\r\n}\r\nreturn status;\r\n}\r\nint dev_create2(struct dev_object *hdev_obj)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nstatus = node_create_mgr(&dev_obj->node_mgr, hdev_obj);\r\nif (status)\r\ndev_obj->node_mgr = NULL;\r\nreturn status;\r\n}\r\nint dev_destroy2(struct dev_object *hdev_obj)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (dev_obj->node_mgr) {\r\nif (node_delete_mgr(dev_obj->node_mgr))\r\nstatus = -EPERM;\r\nelse\r\ndev_obj->node_mgr = NULL;\r\n}\r\nreturn status;\r\n}\r\nint dev_destroy_device(struct dev_object *hdev_obj)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (hdev_obj) {\r\nif (dev_obj->cod_mgr) {\r\ncod_delete(dev_obj->cod_mgr);\r\ndev_obj->cod_mgr = NULL;\r\n}\r\nif (dev_obj->node_mgr) {\r\nnode_delete_mgr(dev_obj->node_mgr);\r\ndev_obj->node_mgr = NULL;\r\n}\r\nif (dev_obj->iomgr) {\r\nio_destroy(dev_obj->iomgr);\r\ndev_obj->iomgr = NULL;\r\n}\r\nif (dev_obj->chnl_mgr) {\r\nchnl_destroy(dev_obj->chnl_mgr);\r\ndev_obj->chnl_mgr = NULL;\r\n}\r\nif (dev_obj->msg_mgr) {\r\nmsg_delete(dev_obj->msg_mgr);\r\ndev_obj->msg_mgr = NULL;\r\n}\r\nif (dev_obj->deh_mgr) {\r\nbridge_deh_destroy(dev_obj->deh_mgr);\r\ndev_obj->deh_mgr = NULL;\r\n}\r\nif (dev_obj->cmm_mgr) {\r\ncmm_destroy(dev_obj->cmm_mgr, true);\r\ndev_obj->cmm_mgr = NULL;\r\n}\r\nif (dev_obj->dmm_mgr) {\r\ndmm_destroy(dev_obj->dmm_mgr);\r\ndev_obj->dmm_mgr = NULL;\r\n}\r\nif (dev_obj->bridge_context) {\r\nstatus = (*dev_obj->bridge_interface.dev_destroy)\r\n(dev_obj->bridge_context);\r\ndev_obj->bridge_context = NULL;\r\n} else\r\nstatus = -EPERM;\r\nif (!status) {\r\ndrv_remove_dev_object(dev_obj->drv_obj, dev_obj);\r\nkfree(dev_obj);\r\ndev_obj = NULL;\r\n}\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint dev_get_chnl_mgr(struct dev_object *hdev_obj,\r\nstruct chnl_mgr **mgr)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (hdev_obj) {\r\n*mgr = dev_obj->chnl_mgr;\r\n} else {\r\n*mgr = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint dev_get_cmm_mgr(struct dev_object *hdev_obj,\r\nstruct cmm_object **mgr)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (hdev_obj) {\r\n*mgr = dev_obj->cmm_mgr;\r\n} else {\r\n*mgr = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint dev_get_dmm_mgr(struct dev_object *hdev_obj,\r\nstruct dmm_object **mgr)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (hdev_obj) {\r\n*mgr = dev_obj->dmm_mgr;\r\n} else {\r\n*mgr = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint dev_get_cod_mgr(struct dev_object *hdev_obj,\r\nstruct cod_manager **cod_mgr)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (hdev_obj) {\r\n*cod_mgr = dev_obj->cod_mgr;\r\n} else {\r\n*cod_mgr = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint dev_get_deh_mgr(struct dev_object *hdev_obj,\r\nstruct deh_mgr **deh_manager)\r\n{\r\nint status = 0;\r\nif (hdev_obj) {\r\n*deh_manager = hdev_obj->deh_mgr;\r\n} else {\r\n*deh_manager = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint dev_get_dev_node(struct dev_object *hdev_obj,\r\nstruct cfg_devnode **dev_nde)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (hdev_obj) {\r\n*dev_nde = dev_obj->dev_node_obj;\r\n} else {\r\n*dev_nde = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nstruct dev_object *dev_get_first(void)\r\n{\r\nstruct dev_object *dev_obj = NULL;\r\ndev_obj = (struct dev_object *)drv_get_first_dev_object();\r\nreturn dev_obj;\r\n}\r\nint dev_get_intf_fxns(struct dev_object *hdev_obj,\r\nstruct bridge_drv_interface **if_fxns)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (hdev_obj) {\r\n*if_fxns = &dev_obj->bridge_interface;\r\n} else {\r\n*if_fxns = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint dev_get_io_mgr(struct dev_object *hdev_obj,\r\nstruct io_mgr **io_man)\r\n{\r\nint status = 0;\r\nif (hdev_obj) {\r\n*io_man = hdev_obj->iomgr;\r\n} else {\r\n*io_man = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nstruct dev_object *dev_get_next(struct dev_object *hdev_obj)\r\n{\r\nstruct dev_object *next_dev_object = NULL;\r\nif (hdev_obj) {\r\nnext_dev_object = (struct dev_object *)\r\ndrv_get_next_dev_object((u32) hdev_obj);\r\n}\r\nreturn next_dev_object;\r\n}\r\nvoid dev_get_msg_mgr(struct dev_object *hdev_obj, struct msg_mgr **msg_man)\r\n{\r\n*msg_man = hdev_obj->msg_mgr;\r\n}\r\nint dev_get_node_manager(struct dev_object *hdev_obj,\r\nstruct node_mgr **node_man)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (hdev_obj) {\r\n*node_man = dev_obj->node_mgr;\r\n} else {\r\n*node_man = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint dev_get_symbol(struct dev_object *hdev_obj,\r\nconst char *str_sym, u32 *pul_value)\r\n{\r\nint status = 0;\r\nstruct cod_manager *cod_mgr;\r\nif (hdev_obj) {\r\nstatus = dev_get_cod_mgr(hdev_obj, &cod_mgr);\r\nif (cod_mgr)\r\nstatus = cod_get_sym_value(cod_mgr, (char *)str_sym,\r\npul_value);\r\nelse\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint dev_get_bridge_context(struct dev_object *hdev_obj,\r\nstruct bridge_dev_context **phbridge_context)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (hdev_obj) {\r\n*phbridge_context = dev_obj->bridge_context;\r\n} else {\r\n*phbridge_context = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint dev_notify_clients(struct dev_object *dev_obj, u32 ret)\r\n{\r\nstruct list_head *curr;\r\nlist_for_each(curr, &dev_obj->proc_list)\r\nproc_notify_clients((void *)curr, ret);\r\nreturn 0;\r\n}\r\nint dev_remove_device(struct cfg_devnode *dev_node_obj)\r\n{\r\nstruct dev_object *hdev_obj;\r\nint status = 0;\r\nstruct drv_data *drv_datap = dev_get_drvdata(bridge);\r\nif (!drv_datap)\r\nstatus = -ENODATA;\r\nif (!dev_node_obj)\r\nstatus = -EFAULT;\r\nif (!status) {\r\nif (!strcmp((char *)((struct drv_ext *)dev_node_obj)->sz_string,\r\n"TIOMAP1510")) {\r\nhdev_obj = drv_datap->dev_object;\r\nstatus = dev_destroy_device(hdev_obj);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\n}\r\nif (status)\r\npr_err("%s: Failed, status 0x%x\n", __func__, status);\r\nreturn status;\r\n}\r\nint dev_set_chnl_mgr(struct dev_object *hdev_obj,\r\nstruct chnl_mgr *hmgr)\r\n{\r\nint status = 0;\r\nstruct dev_object *dev_obj = hdev_obj;\r\nif (hdev_obj)\r\ndev_obj->chnl_mgr = hmgr;\r\nelse\r\nstatus = -EFAULT;\r\nreturn status;\r\n}\r\nvoid dev_set_msg_mgr(struct dev_object *hdev_obj, struct msg_mgr *hmgr)\r\n{\r\nhdev_obj->msg_mgr = hmgr;\r\n}\r\nint dev_start_device(struct cfg_devnode *dev_node_obj)\r\n{\r\nstruct dev_object *hdev_obj = NULL;\r\nchar *bridge_file_name = "UMA";\r\nint status;\r\nstruct mgr_object *hmgr_obj = NULL;\r\nstruct drv_data *drv_datap = dev_get_drvdata(bridge);\r\nstatus = dev_create_device(&hdev_obj, bridge_file_name,\r\ndev_node_obj);\r\nif (!status) {\r\nif (!drv_datap || !dev_node_obj) {\r\nstatus = -EFAULT;\r\npr_err("%s: Failed, status 0x%x\n", __func__, status);\r\n} else if (!(strcmp((char *)dev_node_obj, "TIOMAP1510"))) {\r\ndrv_datap->dev_object = (void *) hdev_obj;\r\n}\r\nif (!status) {\r\nstatus = mgr_create(&hmgr_obj, dev_node_obj);\r\nif (status && !(strcmp((char *)dev_node_obj,\r\n"TIOMAP1510"))) {\r\ndrv_datap->dev_object = NULL;\r\n}\r\n}\r\nif (status) {\r\ndev_destroy_device(hdev_obj);\r\nhdev_obj = NULL;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int fxn_not_implemented(int arg, ...)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int init_cod_mgr(struct dev_object *dev_obj)\r\n{\r\nint status = 0;\r\nchar *sz_dummy_file = "dummy";\r\nstatus = cod_create(&dev_obj->cod_mgr, sz_dummy_file);\r\nreturn status;\r\n}\r\nint dev_insert_proc_object(struct dev_object *hdev_obj,\r\nu32 proc_obj, bool *already_attached)\r\n{\r\nstruct dev_object *dev_obj = (struct dev_object *)hdev_obj;\r\nif (!list_empty(&dev_obj->proc_list))\r\n*already_attached = true;\r\nlist_add_tail((struct list_head *)proc_obj, &dev_obj->proc_list);\r\nreturn 0;\r\n}\r\nint dev_remove_proc_object(struct dev_object *hdev_obj, u32 proc_obj)\r\n{\r\nint status = -EPERM;\r\nstruct list_head *cur_elem;\r\nstruct dev_object *dev_obj = (struct dev_object *)hdev_obj;\r\nlist_for_each(cur_elem, &dev_obj->proc_list) {\r\nif ((u32) cur_elem == proc_obj) {\r\nlist_del(cur_elem);\r\nstatus = 0;\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nint dev_get_dev_type(struct dev_object *dev_obj, u8 *dev_type)\r\n{\r\n*dev_type = dev_obj->dev_type;\r\nreturn 0;\r\n}\r\nstatic void store_interface_fxns(struct bridge_drv_interface *drv_fxns,\r\nstruct bridge_drv_interface *intf_fxns)\r\n{\r\nu32 bridge_version;\r\n#define STORE_FXN(cast, pfn) \\r\n(intf_fxns->pfn = ((drv_fxns->pfn != NULL) ? drv_fxns->pfn : \\r\n(cast)fxn_not_implemented))\r\nbridge_version = MAKEVERSION(drv_fxns->brd_api_major_version,\r\ndrv_fxns->brd_api_minor_version);\r\nintf_fxns->brd_api_major_version = drv_fxns->brd_api_major_version;\r\nintf_fxns->brd_api_minor_version = drv_fxns->brd_api_minor_version;\r\nif (bridge_version > 0) {\r\nSTORE_FXN(fxn_dev_create, dev_create);\r\nSTORE_FXN(fxn_dev_destroy, dev_destroy);\r\nSTORE_FXN(fxn_dev_ctrl, dev_cntrl);\r\nSTORE_FXN(fxn_brd_monitor, brd_monitor);\r\nSTORE_FXN(fxn_brd_start, brd_start);\r\nSTORE_FXN(fxn_brd_stop, brd_stop);\r\nSTORE_FXN(fxn_brd_status, brd_status);\r\nSTORE_FXN(fxn_brd_read, brd_read);\r\nSTORE_FXN(fxn_brd_write, brd_write);\r\nSTORE_FXN(fxn_brd_setstate, brd_set_state);\r\nSTORE_FXN(fxn_brd_memcopy, brd_mem_copy);\r\nSTORE_FXN(fxn_brd_memwrite, brd_mem_write);\r\nSTORE_FXN(fxn_brd_memmap, brd_mem_map);\r\nSTORE_FXN(fxn_brd_memunmap, brd_mem_un_map);\r\nSTORE_FXN(fxn_chnl_create, chnl_create);\r\nSTORE_FXN(fxn_chnl_destroy, chnl_destroy);\r\nSTORE_FXN(fxn_chnl_open, chnl_open);\r\nSTORE_FXN(fxn_chnl_close, chnl_close);\r\nSTORE_FXN(fxn_chnl_addioreq, chnl_add_io_req);\r\nSTORE_FXN(fxn_chnl_getioc, chnl_get_ioc);\r\nSTORE_FXN(fxn_chnl_cancelio, chnl_cancel_io);\r\nSTORE_FXN(fxn_chnl_flushio, chnl_flush_io);\r\nSTORE_FXN(fxn_chnl_getinfo, chnl_get_info);\r\nSTORE_FXN(fxn_chnl_getmgrinfo, chnl_get_mgr_info);\r\nSTORE_FXN(fxn_chnl_idle, chnl_idle);\r\nSTORE_FXN(fxn_chnl_registernotify, chnl_register_notify);\r\nSTORE_FXN(fxn_io_create, io_create);\r\nSTORE_FXN(fxn_io_destroy, io_destroy);\r\nSTORE_FXN(fxn_io_onloaded, io_on_loaded);\r\nSTORE_FXN(fxn_io_getprocload, io_get_proc_load);\r\nSTORE_FXN(fxn_msg_create, msg_create);\r\nSTORE_FXN(fxn_msg_createqueue, msg_create_queue);\r\nSTORE_FXN(fxn_msg_delete, msg_delete);\r\nSTORE_FXN(fxn_msg_deletequeue, msg_delete_queue);\r\nSTORE_FXN(fxn_msg_get, msg_get);\r\nSTORE_FXN(fxn_msg_put, msg_put);\r\nSTORE_FXN(fxn_msg_registernotify, msg_register_notify);\r\nSTORE_FXN(fxn_msg_setqueueid, msg_set_queue_id);\r\n}\r\n#undef STORE_FXN\r\n}
