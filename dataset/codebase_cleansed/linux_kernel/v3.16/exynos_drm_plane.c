static int exynos_plane_get_size(int start, unsigned length, unsigned last)\r\n{\r\nint end = start + length;\r\nint size = 0;\r\nif (start <= 0) {\r\nif (end > 0)\r\nsize = min_t(unsigned, end, last);\r\n} else if (start <= last) {\r\nsize = min_t(unsigned, last - start, length);\r\n}\r\nreturn size;\r\n}\r\nint exynos_plane_mode_set(struct drm_plane *plane, struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb, int crtc_x, int crtc_y,\r\nunsigned int crtc_w, unsigned int crtc_h,\r\nuint32_t src_x, uint32_t src_y,\r\nuint32_t src_w, uint32_t src_h)\r\n{\r\nstruct exynos_plane *exynos_plane = to_exynos_plane(plane);\r\nstruct exynos_drm_overlay *overlay = &exynos_plane->overlay;\r\nunsigned int actual_w;\r\nunsigned int actual_h;\r\nint nr;\r\nint i;\r\nnr = exynos_drm_fb_get_buf_cnt(fb);\r\nfor (i = 0; i < nr; i++) {\r\nstruct exynos_drm_gem_buf *buffer = exynos_drm_fb_buffer(fb, i);\r\nif (!buffer) {\r\nDRM_DEBUG_KMS("buffer is null\n");\r\nreturn -EFAULT;\r\n}\r\noverlay->dma_addr[i] = buffer->dma_addr;\r\nDRM_DEBUG_KMS("buffer: %d, dma_addr = 0x%lx\n",\r\ni, (unsigned long)overlay->dma_addr[i]);\r\n}\r\nactual_w = exynos_plane_get_size(crtc_x, crtc_w, crtc->mode.hdisplay);\r\nactual_h = exynos_plane_get_size(crtc_y, crtc_h, crtc->mode.vdisplay);\r\nif (crtc_x < 0) {\r\nif (actual_w)\r\nsrc_x -= crtc_x;\r\ncrtc_x = 0;\r\n}\r\nif (crtc_y < 0) {\r\nif (actual_h)\r\nsrc_y -= crtc_y;\r\ncrtc_y = 0;\r\n}\r\noverlay->fb_x = src_x;\r\noverlay->fb_y = src_y;\r\noverlay->fb_width = fb->width;\r\noverlay->fb_height = fb->height;\r\noverlay->src_width = src_w;\r\noverlay->src_height = src_h;\r\noverlay->bpp = fb->bits_per_pixel;\r\noverlay->pitch = fb->pitches[0];\r\noverlay->pixel_format = fb->pixel_format;\r\noverlay->crtc_x = crtc_x;\r\noverlay->crtc_y = crtc_y;\r\noverlay->crtc_width = actual_w;\r\noverlay->crtc_height = actual_h;\r\noverlay->mode_width = crtc->mode.hdisplay;\r\noverlay->mode_height = crtc->mode.vdisplay;\r\noverlay->refresh = crtc->mode.vrefresh;\r\noverlay->scan_flag = crtc->mode.flags;\r\nDRM_DEBUG_KMS("overlay : offset_x/y(%d,%d), width/height(%d,%d)",\r\noverlay->crtc_x, overlay->crtc_y,\r\noverlay->crtc_width, overlay->crtc_height);\r\nexynos_drm_crtc_plane_mode_set(crtc, overlay);\r\nreturn 0;\r\n}\r\nvoid exynos_plane_commit(struct drm_plane *plane)\r\n{\r\nstruct exynos_plane *exynos_plane = to_exynos_plane(plane);\r\nstruct exynos_drm_overlay *overlay = &exynos_plane->overlay;\r\nexynos_drm_crtc_plane_commit(plane->crtc, overlay->zpos);\r\n}\r\nvoid exynos_plane_dpms(struct drm_plane *plane, int mode)\r\n{\r\nstruct exynos_plane *exynos_plane = to_exynos_plane(plane);\r\nstruct exynos_drm_overlay *overlay = &exynos_plane->overlay;\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nif (exynos_plane->enabled)\r\nreturn;\r\nexynos_drm_crtc_plane_enable(plane->crtc, overlay->zpos);\r\nexynos_plane->enabled = true;\r\n} else {\r\nif (!exynos_plane->enabled)\r\nreturn;\r\nexynos_drm_crtc_plane_disable(plane->crtc, overlay->zpos);\r\nexynos_plane->enabled = false;\r\n}\r\n}\r\nstatic int\r\nexynos_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb, int crtc_x, int crtc_y,\r\nunsigned int crtc_w, unsigned int crtc_h,\r\nuint32_t src_x, uint32_t src_y,\r\nuint32_t src_w, uint32_t src_h)\r\n{\r\nint ret;\r\nret = exynos_plane_mode_set(plane, crtc, fb, crtc_x, crtc_y,\r\ncrtc_w, crtc_h, src_x >> 16, src_y >> 16,\r\nsrc_w >> 16, src_h >> 16);\r\nif (ret < 0)\r\nreturn ret;\r\nplane->crtc = crtc;\r\nexynos_plane_commit(plane);\r\nexynos_plane_dpms(plane, DRM_MODE_DPMS_ON);\r\nreturn 0;\r\n}\r\nstatic int exynos_disable_plane(struct drm_plane *plane)\r\n{\r\nexynos_plane_dpms(plane, DRM_MODE_DPMS_OFF);\r\nreturn 0;\r\n}\r\nstatic void exynos_plane_destroy(struct drm_plane *plane)\r\n{\r\nstruct exynos_plane *exynos_plane = to_exynos_plane(plane);\r\nexynos_disable_plane(plane);\r\ndrm_plane_cleanup(plane);\r\nkfree(exynos_plane);\r\n}\r\nstatic int exynos_plane_set_property(struct drm_plane *plane,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_device *dev = plane->dev;\r\nstruct exynos_plane *exynos_plane = to_exynos_plane(plane);\r\nstruct exynos_drm_private *dev_priv = dev->dev_private;\r\nif (property == dev_priv->plane_zpos_property) {\r\nexynos_plane->overlay.zpos = val;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void exynos_plane_attach_zpos_property(struct drm_plane *plane)\r\n{\r\nstruct drm_device *dev = plane->dev;\r\nstruct exynos_drm_private *dev_priv = dev->dev_private;\r\nstruct drm_property *prop;\r\nprop = dev_priv->plane_zpos_property;\r\nif (!prop) {\r\nprop = drm_property_create_range(dev, 0, "zpos", 0,\r\nMAX_PLANE - 1);\r\nif (!prop)\r\nreturn;\r\ndev_priv->plane_zpos_property = prop;\r\n}\r\ndrm_object_attach_property(&plane->base, prop, 0);\r\n}\r\nstruct drm_plane *exynos_plane_init(struct drm_device *dev,\r\nunsigned long possible_crtcs, bool priv)\r\n{\r\nstruct exynos_plane *exynos_plane;\r\nint err;\r\nexynos_plane = kzalloc(sizeof(struct exynos_plane), GFP_KERNEL);\r\nif (!exynos_plane)\r\nreturn NULL;\r\nerr = drm_plane_init(dev, &exynos_plane->base, possible_crtcs,\r\n&exynos_plane_funcs, formats, ARRAY_SIZE(formats),\r\npriv);\r\nif (err) {\r\nDRM_ERROR("failed to initialize plane\n");\r\nkfree(exynos_plane);\r\nreturn NULL;\r\n}\r\nif (priv)\r\nexynos_plane->overlay.zpos = DEFAULT_ZPOS;\r\nelse\r\nexynos_plane_attach_zpos_property(&exynos_plane->base);\r\nreturn &exynos_plane->base;\r\n}
