static inline struct xfrm6_tunnel_net *xfrm6_tunnel_pernet(struct net *net)\r\n{\r\nreturn net_generic(net, xfrm6_tunnel_net_id);\r\n}\r\nstatic inline unsigned int xfrm6_tunnel_spi_hash_byaddr(const xfrm_address_t *addr)\r\n{\r\nunsigned int h;\r\nh = ipv6_addr_hash((const struct in6_addr *)addr);\r\nh ^= h >> 16;\r\nh ^= h >> 8;\r\nh &= XFRM6_TUNNEL_SPI_BYADDR_HSIZE - 1;\r\nreturn h;\r\n}\r\nstatic inline unsigned int xfrm6_tunnel_spi_hash_byspi(u32 spi)\r\n{\r\nreturn spi % XFRM6_TUNNEL_SPI_BYSPI_HSIZE;\r\n}\r\nstatic struct xfrm6_tunnel_spi *__xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr)\r\n{\r\nstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\r\nstruct xfrm6_tunnel_spi *x6spi;\r\nhlist_for_each_entry_rcu(x6spi,\r\n&xfrm6_tn->spi_byaddr[xfrm6_tunnel_spi_hash_byaddr(saddr)],\r\nlist_byaddr) {\r\nif (xfrm6_addr_equal(&x6spi->addr, saddr))\r\nreturn x6spi;\r\n}\r\nreturn NULL;\r\n}\r\n__be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr)\r\n{\r\nstruct xfrm6_tunnel_spi *x6spi;\r\nu32 spi;\r\nrcu_read_lock_bh();\r\nx6spi = __xfrm6_tunnel_spi_lookup(net, saddr);\r\nspi = x6spi ? x6spi->spi : 0;\r\nrcu_read_unlock_bh();\r\nreturn htonl(spi);\r\n}\r\nstatic int __xfrm6_tunnel_spi_check(struct net *net, u32 spi)\r\n{\r\nstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\r\nstruct xfrm6_tunnel_spi *x6spi;\r\nint index = xfrm6_tunnel_spi_hash_byspi(spi);\r\nhlist_for_each_entry(x6spi,\r\n&xfrm6_tn->spi_byspi[index],\r\nlist_byspi) {\r\nif (x6spi->spi == spi)\r\nreturn -1;\r\n}\r\nreturn index;\r\n}\r\nstatic u32 __xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr)\r\n{\r\nstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\r\nu32 spi;\r\nstruct xfrm6_tunnel_spi *x6spi;\r\nint index;\r\nif (xfrm6_tn->spi < XFRM6_TUNNEL_SPI_MIN ||\r\nxfrm6_tn->spi >= XFRM6_TUNNEL_SPI_MAX)\r\nxfrm6_tn->spi = XFRM6_TUNNEL_SPI_MIN;\r\nelse\r\nxfrm6_tn->spi++;\r\nfor (spi = xfrm6_tn->spi; spi <= XFRM6_TUNNEL_SPI_MAX; spi++) {\r\nindex = __xfrm6_tunnel_spi_check(net, spi);\r\nif (index >= 0)\r\ngoto alloc_spi;\r\n}\r\nfor (spi = XFRM6_TUNNEL_SPI_MIN; spi < xfrm6_tn->spi; spi++) {\r\nindex = __xfrm6_tunnel_spi_check(net, spi);\r\nif (index >= 0)\r\ngoto alloc_spi;\r\n}\r\nspi = 0;\r\ngoto out;\r\nalloc_spi:\r\nxfrm6_tn->spi = spi;\r\nx6spi = kmem_cache_alloc(xfrm6_tunnel_spi_kmem, GFP_ATOMIC);\r\nif (!x6spi)\r\ngoto out;\r\nmemcpy(&x6spi->addr, saddr, sizeof(x6spi->addr));\r\nx6spi->spi = spi;\r\natomic_set(&x6spi->refcnt, 1);\r\nhlist_add_head_rcu(&x6spi->list_byspi, &xfrm6_tn->spi_byspi[index]);\r\nindex = xfrm6_tunnel_spi_hash_byaddr(saddr);\r\nhlist_add_head_rcu(&x6spi->list_byaddr, &xfrm6_tn->spi_byaddr[index]);\r\nout:\r\nreturn spi;\r\n}\r\n__be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr)\r\n{\r\nstruct xfrm6_tunnel_spi *x6spi;\r\nu32 spi;\r\nspin_lock_bh(&xfrm6_tunnel_spi_lock);\r\nx6spi = __xfrm6_tunnel_spi_lookup(net, saddr);\r\nif (x6spi) {\r\natomic_inc(&x6spi->refcnt);\r\nspi = x6spi->spi;\r\n} else\r\nspi = __xfrm6_tunnel_alloc_spi(net, saddr);\r\nspin_unlock_bh(&xfrm6_tunnel_spi_lock);\r\nreturn htonl(spi);\r\n}\r\nstatic void x6spi_destroy_rcu(struct rcu_head *head)\r\n{\r\nkmem_cache_free(xfrm6_tunnel_spi_kmem,\r\ncontainer_of(head, struct xfrm6_tunnel_spi, rcu_head));\r\n}\r\nstatic void xfrm6_tunnel_free_spi(struct net *net, xfrm_address_t *saddr)\r\n{\r\nstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\r\nstruct xfrm6_tunnel_spi *x6spi;\r\nstruct hlist_node *n;\r\nspin_lock_bh(&xfrm6_tunnel_spi_lock);\r\nhlist_for_each_entry_safe(x6spi, n,\r\n&xfrm6_tn->spi_byaddr[xfrm6_tunnel_spi_hash_byaddr(saddr)],\r\nlist_byaddr)\r\n{\r\nif (xfrm6_addr_equal(&x6spi->addr, saddr)) {\r\nif (atomic_dec_and_test(&x6spi->refcnt)) {\r\nhlist_del_rcu(&x6spi->list_byaddr);\r\nhlist_del_rcu(&x6spi->list_byspi);\r\ncall_rcu(&x6spi->rcu_head, x6spi_destroy_rcu);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&xfrm6_tunnel_spi_lock);\r\n}\r\nstatic int xfrm6_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nskb_push(skb, -skb_network_offset(skb));\r\nreturn 0;\r\n}\r\nstatic int xfrm6_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nreturn skb_network_header(skb)[IP6CB(skb)->nhoff];\r\n}\r\nstatic int xfrm6_tunnel_rcv(struct sk_buff *skb)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\n__be32 spi;\r\nspi = xfrm6_tunnel_spi_lookup(net, (const xfrm_address_t *)&iph->saddr);\r\nreturn xfrm6_rcv_spi(skb, IPPROTO_IPV6, spi);\r\n}\r\nstatic int xfrm6_tunnel_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\r\nu8 type, u8 code, int offset, __be32 info)\r\n{\r\nswitch (type) {\r\ncase ICMPV6_DEST_UNREACH:\r\nswitch (code) {\r\ncase ICMPV6_NOROUTE:\r\ncase ICMPV6_ADM_PROHIBITED:\r\ncase ICMPV6_NOT_NEIGHBOUR:\r\ncase ICMPV6_ADDR_UNREACH:\r\ncase ICMPV6_PORT_UNREACH:\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase ICMPV6_PKT_TOOBIG:\r\nbreak;\r\ncase ICMPV6_TIME_EXCEED:\r\nswitch (code) {\r\ncase ICMPV6_EXC_HOPLIMIT:\r\nbreak;\r\ncase ICMPV6_EXC_FRAGTIME:\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase ICMPV6_PARAMPROB:\r\nswitch (code) {\r\ncase ICMPV6_HDR_FIELD: break;\r\ncase ICMPV6_UNK_NEXTHDR: break;\r\ncase ICMPV6_UNK_OPTION: break;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xfrm6_tunnel_init_state(struct xfrm_state *x)\r\n{\r\nif (x->props.mode != XFRM_MODE_TUNNEL)\r\nreturn -EINVAL;\r\nif (x->encap)\r\nreturn -EINVAL;\r\nx->props.header_len = sizeof(struct ipv6hdr);\r\nreturn 0;\r\n}\r\nstatic void xfrm6_tunnel_destroy(struct xfrm_state *x)\r\n{\r\nstruct net *net = xs_net(x);\r\nxfrm6_tunnel_free_spi(net, (xfrm_address_t *)&x->props.saddr);\r\n}\r\nstatic int __net_init xfrm6_tunnel_net_init(struct net *net)\r\n{\r\nstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\r\nunsigned int i;\r\nfor (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i++)\r\nINIT_HLIST_HEAD(&xfrm6_tn->spi_byaddr[i]);\r\nfor (i = 0; i < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i++)\r\nINIT_HLIST_HEAD(&xfrm6_tn->spi_byspi[i]);\r\nxfrm6_tn->spi = 0;\r\nreturn 0;\r\n}\r\nstatic void __net_exit xfrm6_tunnel_net_exit(struct net *net)\r\n{\r\n}\r\nstatic int __init xfrm6_tunnel_init(void)\r\n{\r\nint rv;\r\nxfrm6_tunnel_spi_kmem = kmem_cache_create("xfrm6_tunnel_spi",\r\nsizeof(struct xfrm6_tunnel_spi),\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!xfrm6_tunnel_spi_kmem)\r\nreturn -ENOMEM;\r\nrv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\r\nif (rv < 0)\r\ngoto out_pernet;\r\nrv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\r\nif (rv < 0)\r\ngoto out_type;\r\nrv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\r\nif (rv < 0)\r\ngoto out_xfrm6;\r\nrv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\r\nif (rv < 0)\r\ngoto out_xfrm46;\r\nreturn 0;\r\nout_xfrm46:\r\nxfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\r\nout_xfrm6:\r\nxfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\r\nout_type:\r\nunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\r\nout_pernet:\r\nkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\r\nreturn rv;\r\n}\r\nstatic void __exit xfrm6_tunnel_fini(void)\r\n{\r\nxfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\r\nxfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\r\nxfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\r\nunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\r\nkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\r\n}
