static inline struct vmw_shader *\r\nvmw_res_to_shader(struct vmw_resource *res)\r\n{\r\nreturn container_of(res, struct vmw_shader, res);\r\n}\r\nstatic void vmw_hw_shader_destroy(struct vmw_resource *res)\r\n{\r\n(void) vmw_gb_shader_destroy(res);\r\n}\r\nstatic int vmw_gb_shader_init(struct vmw_private *dev_priv,\r\nstruct vmw_resource *res,\r\nuint32_t size,\r\nuint64_t offset,\r\nSVGA3dShaderType type,\r\nstruct vmw_dma_buffer *byte_code,\r\nvoid (*res_free) (struct vmw_resource *res))\r\n{\r\nstruct vmw_shader *shader = vmw_res_to_shader(res);\r\nint ret;\r\nret = vmw_resource_init(dev_priv, res, true,\r\nres_free, &vmw_gb_shader_func);\r\nif (unlikely(ret != 0)) {\r\nif (res_free)\r\nres_free(res);\r\nelse\r\nkfree(res);\r\nreturn ret;\r\n}\r\nres->backup_size = size;\r\nif (byte_code) {\r\nres->backup = vmw_dmabuf_reference(byte_code);\r\nres->backup_offset = offset;\r\n}\r\nshader->size = size;\r\nshader->type = type;\r\nvmw_resource_activate(res, vmw_hw_shader_destroy);\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_shader_create(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_shader *shader = vmw_res_to_shader(res);\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineGBShader body;\r\n} *cmd;\r\nif (likely(res->id != -1))\r\nreturn 0;\r\nret = vmw_resource_alloc_id(res);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a shader id.\n");\r\ngoto out_no_id;\r\n}\r\nif (unlikely(res->id >= VMWGFX_NUM_GB_SHADER)) {\r\nret = -EBUSY;\r\ngoto out_no_fifo;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"creation.\n");\r\nret = -ENOMEM;\r\ngoto out_no_fifo;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DEFINE_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\ncmd->body.type = shader->type;\r\ncmd->body.sizeInBytes = shader->size;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n(void) vmw_3d_resource_inc(dev_priv, false);\r\nreturn 0;\r\nout_no_fifo:\r\nvmw_resource_release_id(res);\r\nout_no_id:\r\nreturn ret;\r\n}\r\nstatic int vmw_gb_shader_bind(struct vmw_resource *res,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBShader body;\r\n} *cmd;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_BIND_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\ncmd->body.mobid = bo->mem.start;\r\ncmd->body.offsetInBytes = 0;\r\nres->backup_dirty = false;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_shader_unbind(struct vmw_resource *res,\r\nbool readback,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBShader body;\r\n} *cmd;\r\nstruct vmw_fence_obj *fence;\r\nBUG_ON(res->backup->base.mem.mem_type != VMW_PL_MOB);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_BIND_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\ncmd->body.mobid = SVGA3D_INVALID_ID;\r\ncmd->body.offsetInBytes = 0;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv,\r\n&fence, NULL);\r\nvmw_fence_single_bo(val_buf->bo, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_shader_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyGBShader body;\r\n} *cmd;\r\nif (likely(res->id == -1))\r\nreturn 0;\r\nmutex_lock(&dev_priv->binding_mutex);\r\nvmw_context_binding_res_list_scrub(&res->binding_head);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"destruction.\n");\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DESTROY_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nvmw_resource_release_id(res);\r\nvmw_3d_resource_dec(dev_priv, false);\r\nreturn 0;\r\n}\r\nstatic struct vmw_resource *\r\nvmw_user_shader_base_to_res(struct ttm_base_object *base)\r\n{\r\nreturn &(container_of(base, struct vmw_user_shader, base)->\r\nshader.res);\r\n}\r\nstatic void vmw_user_shader_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_user_shader *ushader =\r\ncontainer_of(res, struct vmw_user_shader, shader.res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nttm_base_object_kfree(ushader, base);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_shader_size);\r\n}\r\nstatic void vmw_user_shader_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_resource *res = vmw_user_shader_base_to_res(base);\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint vmw_shader_destroy_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_shader_arg *arg = (struct drm_vmw_shader_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nreturn ttm_ref_object_base_unref(tfile, arg->handle,\r\nTTM_REF_USAGE);\r\n}\r\nstatic int vmw_shader_alloc(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buffer,\r\nsize_t shader_size,\r\nsize_t offset,\r\nSVGA3dShaderType shader_type,\r\nstruct ttm_object_file *tfile,\r\nu32 *handle)\r\n{\r\nstruct vmw_user_shader *ushader;\r\nstruct vmw_resource *res, *tmp;\r\nint ret;\r\nif (unlikely(vmw_user_shader_size == 0))\r\nvmw_user_shader_size =\r\nttm_round_pot(sizeof(struct vmw_user_shader)) + 128;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nvmw_user_shader_size,\r\nfalse, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for shader "\r\n"creation.\n");\r\ngoto out;\r\n}\r\nushader = kzalloc(sizeof(*ushader), GFP_KERNEL);\r\nif (unlikely(ushader == NULL)) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_shader_size);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nres = &ushader->shader.res;\r\nushader->base.shareable = false;\r\nushader->base.tfile = NULL;\r\nret = vmw_gb_shader_init(dev_priv, res, shader_size,\r\noffset, shader_type, buffer,\r\nvmw_user_shader_free);\r\nif (unlikely(ret != 0))\r\ngoto out;\r\ntmp = vmw_resource_reference(res);\r\nret = ttm_base_object_init(tfile, &ushader->base, false,\r\nVMW_RES_SHADER,\r\n&vmw_user_shader_base_release, NULL);\r\nif (unlikely(ret != 0)) {\r\nvmw_resource_unreference(&tmp);\r\ngoto out_err;\r\n}\r\nif (handle)\r\n*handle = ushader->base.hash.key;\r\nout_err:\r\nvmw_resource_unreference(&res);\r\nout:\r\nreturn ret;\r\n}\r\nint vmw_shader_define_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_shader_create_arg *arg =\r\n(struct drm_vmw_shader_create_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_dma_buffer *buffer = NULL;\r\nSVGA3dShaderType shader_type;\r\nint ret;\r\nif (arg->buffer_handle != SVGA3D_INVALID_ID) {\r\nret = vmw_user_dmabuf_lookup(tfile, arg->buffer_handle,\r\n&buffer);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Could not find buffer for shader "\r\n"creation.\n");\r\nreturn ret;\r\n}\r\nif ((u64)buffer->base.num_pages * PAGE_SIZE <\r\n(u64)arg->size + (u64)arg->offset) {\r\nDRM_ERROR("Illegal buffer- or shader size.\n");\r\nret = -EINVAL;\r\ngoto out_bad_arg;\r\n}\r\n}\r\nswitch (arg->shader_type) {\r\ncase drm_vmw_shader_type_vs:\r\nshader_type = SVGA3D_SHADERTYPE_VS;\r\nbreak;\r\ncase drm_vmw_shader_type_ps:\r\nshader_type = SVGA3D_SHADERTYPE_PS;\r\nbreak;\r\ncase drm_vmw_shader_type_gs:\r\nshader_type = SVGA3D_SHADERTYPE_GS;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Illegal shader type.\n");\r\nret = -EINVAL;\r\ngoto out_bad_arg;\r\n}\r\nret = ttm_read_lock(&dev_priv->reservation_sem, true);\r\nif (unlikely(ret != 0))\r\ngoto out_bad_arg;\r\nret = vmw_shader_alloc(dev_priv, buffer, arg->size, arg->offset,\r\nshader_type, tfile, &arg->shader_handle);\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\nout_bad_arg:\r\nvmw_dmabuf_unreference(&buffer);\r\nreturn ret;\r\n}\r\nint vmw_compat_shader_lookup(struct vmw_compat_shader_manager *man,\r\nSVGA3dShaderType shader_type,\r\nu32 *user_key)\r\n{\r\nstruct drm_hash_item *hash;\r\nint ret;\r\nunsigned long key = *user_key | (shader_type << 24);\r\nret = drm_ht_find_item(&man->shaders, key, &hash);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\n*user_key = drm_hash_entry(hash, struct vmw_compat_shader,\r\nhash)->handle;\r\nreturn 0;\r\n}\r\nstatic void vmw_compat_shader_free(struct vmw_compat_shader_manager *man,\r\nstruct vmw_compat_shader *entry)\r\n{\r\nlist_del(&entry->head);\r\nWARN_ON(drm_ht_remove_item(&man->shaders, &entry->hash));\r\nWARN_ON(ttm_ref_object_base_unref(entry->tfile, entry->handle,\r\nTTM_REF_USAGE));\r\nkfree(entry);\r\n}\r\nvoid vmw_compat_shaders_commit(struct vmw_compat_shader_manager *man,\r\nstruct list_head *list)\r\n{\r\nstruct vmw_compat_shader *entry, *next;\r\nlist_for_each_entry_safe(entry, next, list, head) {\r\nlist_del(&entry->head);\r\nswitch (entry->state) {\r\ncase VMW_COMPAT_ADD:\r\nentry->state = VMW_COMPAT_COMMITED;\r\nlist_add_tail(&entry->head, &man->list);\r\nbreak;\r\ncase VMW_COMPAT_DEL:\r\nttm_ref_object_base_unref(entry->tfile, entry->handle,\r\nTTM_REF_USAGE);\r\nkfree(entry);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid vmw_compat_shaders_revert(struct vmw_compat_shader_manager *man,\r\nstruct list_head *list)\r\n{\r\nstruct vmw_compat_shader *entry, *next;\r\nint ret;\r\nlist_for_each_entry_safe(entry, next, list, head) {\r\nswitch (entry->state) {\r\ncase VMW_COMPAT_ADD:\r\nvmw_compat_shader_free(man, entry);\r\nbreak;\r\ncase VMW_COMPAT_DEL:\r\nret = drm_ht_insert_item(&man->shaders, &entry->hash);\r\nlist_del(&entry->head);\r\nlist_add_tail(&entry->head, &man->list);\r\nentry->state = VMW_COMPAT_COMMITED;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\n}\r\nint vmw_compat_shader_remove(struct vmw_compat_shader_manager *man,\r\nu32 user_key, SVGA3dShaderType shader_type,\r\nstruct list_head *list)\r\n{\r\nstruct vmw_compat_shader *entry;\r\nstruct drm_hash_item *hash;\r\nint ret;\r\nret = drm_ht_find_item(&man->shaders, user_key | (shader_type << 24),\r\n&hash);\r\nif (likely(ret != 0))\r\nreturn -EINVAL;\r\nentry = drm_hash_entry(hash, struct vmw_compat_shader, hash);\r\nswitch (entry->state) {\r\ncase VMW_COMPAT_ADD:\r\nvmw_compat_shader_free(man, entry);\r\nbreak;\r\ncase VMW_COMPAT_COMMITED:\r\n(void) drm_ht_remove_item(&man->shaders, &entry->hash);\r\nlist_del(&entry->head);\r\nentry->state = VMW_COMPAT_DEL;\r\nlist_add_tail(&entry->head, list);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint vmw_compat_shader_add(struct vmw_compat_shader_manager *man,\r\nu32 user_key, const void *bytecode,\r\nSVGA3dShaderType shader_type,\r\nsize_t size,\r\nstruct ttm_object_file *tfile,\r\nstruct list_head *list)\r\n{\r\nstruct vmw_dma_buffer *buf;\r\nstruct ttm_bo_kmap_obj map;\r\nbool is_iomem;\r\nstruct vmw_compat_shader *compat;\r\nu32 handle;\r\nint ret;\r\nif (user_key > ((1 << 24) - 1) || (unsigned) shader_type > 16)\r\nreturn -EINVAL;\r\nbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (unlikely(buf == NULL))\r\nreturn -ENOMEM;\r\nret = vmw_dmabuf_init(man->dev_priv, buf, size, &vmw_sys_ne_placement,\r\ntrue, vmw_dmabuf_bo_free);\r\nif (unlikely(ret != 0))\r\ngoto out;\r\nret = ttm_bo_reserve(&buf->base, false, true, false, NULL);\r\nif (unlikely(ret != 0))\r\ngoto no_reserve;\r\nret = ttm_bo_kmap(&buf->base, 0, PAGE_ALIGN(size) >> PAGE_SHIFT,\r\n&map);\r\nif (unlikely(ret != 0)) {\r\nttm_bo_unreserve(&buf->base);\r\ngoto no_reserve;\r\n}\r\nmemcpy(ttm_kmap_obj_virtual(&map, &is_iomem), bytecode, size);\r\nWARN_ON(is_iomem);\r\nttm_bo_kunmap(&map);\r\nret = ttm_bo_validate(&buf->base, &vmw_sys_placement, false, true);\r\nWARN_ON(ret != 0);\r\nttm_bo_unreserve(&buf->base);\r\nret = vmw_shader_alloc(man->dev_priv, buf, size, 0, shader_type,\r\ntfile, &handle);\r\nvmw_dmabuf_unreference(&buf);\r\nif (unlikely(ret != 0))\r\ngoto no_reserve;\r\ncompat = kzalloc(sizeof(*compat), GFP_KERNEL);\r\nif (compat == NULL)\r\ngoto no_compat;\r\ncompat->hash.key = user_key | (shader_type << 24);\r\nret = drm_ht_insert_item(&man->shaders, &compat->hash);\r\nif (unlikely(ret != 0))\r\ngoto out_invalid_key;\r\ncompat->state = VMW_COMPAT_ADD;\r\ncompat->handle = handle;\r\ncompat->tfile = tfile;\r\nlist_add_tail(&compat->head, list);\r\nreturn 0;\r\nout_invalid_key:\r\nkfree(compat);\r\nno_compat:\r\nttm_ref_object_base_unref(tfile, handle, TTM_REF_USAGE);\r\nno_reserve:\r\nout:\r\nreturn ret;\r\n}\r\nstruct vmw_compat_shader_manager *\r\nvmw_compat_shader_man_create(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_compat_shader_manager *man;\r\nint ret;\r\nman = kzalloc(sizeof(*man), GFP_KERNEL);\r\nif (man == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nman->dev_priv = dev_priv;\r\nINIT_LIST_HEAD(&man->list);\r\nret = drm_ht_create(&man->shaders, VMW_COMPAT_SHADER_HT_ORDER);\r\nif (ret == 0)\r\nreturn man;\r\nkfree(man);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid vmw_compat_shader_man_destroy(struct vmw_compat_shader_manager *man)\r\n{\r\nstruct vmw_compat_shader *entry, *next;\r\nmutex_lock(&man->dev_priv->cmdbuf_mutex);\r\nlist_for_each_entry_safe(entry, next, &man->list, head)\r\nvmw_compat_shader_free(man, entry);\r\nmutex_unlock(&man->dev_priv->cmdbuf_mutex);\r\nkfree(man);\r\n}
