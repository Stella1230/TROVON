static void crb_addr_transform_setup(void)\r\n{\r\ncrb_addr_transform(XDMA);\r\ncrb_addr_transform(TIMR);\r\ncrb_addr_transform(SRE);\r\ncrb_addr_transform(SQN3);\r\ncrb_addr_transform(SQN2);\r\ncrb_addr_transform(SQN1);\r\ncrb_addr_transform(SQN0);\r\ncrb_addr_transform(SQS3);\r\ncrb_addr_transform(SQS2);\r\ncrb_addr_transform(SQS1);\r\ncrb_addr_transform(SQS0);\r\ncrb_addr_transform(RPMX7);\r\ncrb_addr_transform(RPMX6);\r\ncrb_addr_transform(RPMX5);\r\ncrb_addr_transform(RPMX4);\r\ncrb_addr_transform(RPMX3);\r\ncrb_addr_transform(RPMX2);\r\ncrb_addr_transform(RPMX1);\r\ncrb_addr_transform(RPMX0);\r\ncrb_addr_transform(ROMUSB);\r\ncrb_addr_transform(SN);\r\ncrb_addr_transform(QMN);\r\ncrb_addr_transform(QMS);\r\ncrb_addr_transform(PGNI);\r\ncrb_addr_transform(PGND);\r\ncrb_addr_transform(PGN3);\r\ncrb_addr_transform(PGN2);\r\ncrb_addr_transform(PGN1);\r\ncrb_addr_transform(PGN0);\r\ncrb_addr_transform(PGSI);\r\ncrb_addr_transform(PGSD);\r\ncrb_addr_transform(PGS3);\r\ncrb_addr_transform(PGS2);\r\ncrb_addr_transform(PGS1);\r\ncrb_addr_transform(PGS0);\r\ncrb_addr_transform(PS);\r\ncrb_addr_transform(PH);\r\ncrb_addr_transform(NIU);\r\ncrb_addr_transform(I2Q);\r\ncrb_addr_transform(EG);\r\ncrb_addr_transform(MN);\r\ncrb_addr_transform(MS);\r\ncrb_addr_transform(CAS2);\r\ncrb_addr_transform(CAS1);\r\ncrb_addr_transform(CAS0);\r\ncrb_addr_transform(CAM);\r\ncrb_addr_transform(C2C1);\r\ncrb_addr_transform(C2C0);\r\ncrb_addr_transform(SMB);\r\ncrb_addr_transform(OCM0);\r\ncrb_addr_transform(I2C0);\r\n}\r\nvoid qlcnic_release_rx_buffers(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_rx_buffer *rx_buf;\r\nint i, ring;\r\nrecv_ctx = adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nfor (i = 0; i < rds_ring->num_desc; ++i) {\r\nrx_buf = &(rds_ring->rx_buf_arr[i]);\r\nif (rx_buf->skb == NULL)\r\ncontinue;\r\npci_unmap_single(adapter->pdev,\r\nrx_buf->dma,\r\nrds_ring->dma_size,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb_any(rx_buf->skb);\r\n}\r\n}\r\n}\r\nvoid qlcnic_reset_rx_buffers_list(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_rx_buffer *rx_buf;\r\nint i, ring;\r\nrecv_ctx = adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nINIT_LIST_HEAD(&rds_ring->free_list);\r\nrx_buf = rds_ring->rx_buf_arr;\r\nfor (i = 0; i < rds_ring->num_desc; i++) {\r\nlist_add_tail(&rx_buf->list,\r\n&rds_ring->free_list);\r\nrx_buf++;\r\n}\r\n}\r\n}\r\nvoid qlcnic_release_tx_buffers(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_tx_ring *tx_ring)\r\n{\r\nstruct qlcnic_cmd_buffer *cmd_buf;\r\nstruct qlcnic_skb_frag *buffrag;\r\nint i, j;\r\nspin_lock(&tx_ring->tx_clean_lock);\r\ncmd_buf = tx_ring->cmd_buf_arr;\r\nfor (i = 0; i < tx_ring->num_desc; i++) {\r\nbuffrag = cmd_buf->frag_array;\r\nif (buffrag->dma) {\r\npci_unmap_single(adapter->pdev, buffrag->dma,\r\nbuffrag->length, PCI_DMA_TODEVICE);\r\nbuffrag->dma = 0ULL;\r\n}\r\nfor (j = 1; j < cmd_buf->frag_count; j++) {\r\nbuffrag++;\r\nif (buffrag->dma) {\r\npci_unmap_page(adapter->pdev, buffrag->dma,\r\nbuffrag->length,\r\nPCI_DMA_TODEVICE);\r\nbuffrag->dma = 0ULL;\r\n}\r\n}\r\nif (cmd_buf->skb) {\r\ndev_kfree_skb_any(cmd_buf->skb);\r\ncmd_buf->skb = NULL;\r\n}\r\ncmd_buf++;\r\n}\r\nspin_unlock(&tx_ring->tx_clean_lock);\r\n}\r\nvoid qlcnic_free_sw_resources(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nint ring;\r\nrecv_ctx = adapter->recv_ctx;\r\nif (recv_ctx->rds_rings == NULL)\r\nreturn;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nvfree(rds_ring->rx_buf_arr);\r\nrds_ring->rx_buf_arr = NULL;\r\n}\r\nkfree(recv_ctx->rds_rings);\r\n}\r\nint qlcnic_alloc_sw_resources(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_rx_buffer *rx_buf;\r\nint ring, i;\r\nrecv_ctx = adapter->recv_ctx;\r\nrds_ring = kcalloc(adapter->max_rds_rings,\r\nsizeof(struct qlcnic_host_rds_ring), GFP_KERNEL);\r\nif (rds_ring == NULL)\r\ngoto err_out;\r\nrecv_ctx->rds_rings = rds_ring;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nswitch (ring) {\r\ncase RCV_RING_NORMAL:\r\nrds_ring->num_desc = adapter->num_rxd;\r\nrds_ring->dma_size = QLCNIC_P3P_RX_BUF_MAX_LEN;\r\nrds_ring->skb_size = rds_ring->dma_size + NET_IP_ALIGN;\r\nbreak;\r\ncase RCV_RING_JUMBO:\r\nrds_ring->num_desc = adapter->num_jumbo_rxd;\r\nrds_ring->dma_size =\r\nQLCNIC_P3P_RX_JUMBO_BUF_MAX_LEN;\r\nif (adapter->ahw->capabilities &\r\nQLCNIC_FW_CAPABILITY_HW_LRO)\r\nrds_ring->dma_size += QLCNIC_LRO_BUFFER_EXTRA;\r\nrds_ring->skb_size =\r\nrds_ring->dma_size + NET_IP_ALIGN;\r\nbreak;\r\n}\r\nrds_ring->rx_buf_arr = vzalloc(RCV_BUFF_RINGSIZE(rds_ring));\r\nif (rds_ring->rx_buf_arr == NULL)\r\ngoto err_out;\r\nINIT_LIST_HEAD(&rds_ring->free_list);\r\nrx_buf = rds_ring->rx_buf_arr;\r\nfor (i = 0; i < rds_ring->num_desc; i++) {\r\nlist_add_tail(&rx_buf->list,\r\n&rds_ring->free_list);\r\nrx_buf->ref_handle = i;\r\nrx_buf++;\r\n}\r\nspin_lock_init(&rds_ring->lock);\r\n}\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nsds_ring->irq = adapter->msix_entries[ring].vector;\r\nsds_ring->adapter = adapter;\r\nsds_ring->num_desc = adapter->num_rxd;\r\nif (qlcnic_82xx_check(adapter)) {\r\nif (qlcnic_check_multi_tx(adapter) &&\r\n!adapter->ahw->diag_test)\r\nsds_ring->tx_ring = &adapter->tx_ring[ring];\r\nelse\r\nsds_ring->tx_ring = &adapter->tx_ring[0];\r\n}\r\nfor (i = 0; i < NUM_RCV_DESC_RINGS; i++)\r\nINIT_LIST_HEAD(&sds_ring->free_list[i]);\r\n}\r\nreturn 0;\r\nerr_out:\r\nqlcnic_free_sw_resources(adapter);\r\nreturn -ENOMEM;\r\n}\r\nstatic u32 qlcnic_decode_crb_addr(u32 addr)\r\n{\r\nint i;\r\nu32 base_addr, offset, pci_base;\r\ncrb_addr_transform_setup();\r\npci_base = QLCNIC_ADDR_ERROR;\r\nbase_addr = addr & 0xfff00000;\r\noffset = addr & 0x000fffff;\r\nfor (i = 0; i < QLCNIC_MAX_CRB_XFORM; i++) {\r\nif (crb_addr_xform[i] == base_addr) {\r\npci_base = i << 20;\r\nbreak;\r\n}\r\n}\r\nif (pci_base == QLCNIC_ADDR_ERROR)\r\nreturn pci_base;\r\nelse\r\nreturn pci_base + offset;\r\n}\r\nstatic int qlcnic_wait_rom_done(struct qlcnic_adapter *adapter)\r\n{\r\nlong timeout = 0;\r\nlong done = 0;\r\nint err = 0;\r\ncond_resched();\r\nwhile (done == 0) {\r\ndone = QLCRD32(adapter, QLCNIC_ROMUSB_GLB_STATUS, &err);\r\ndone &= 2;\r\nif (++timeout >= QLCNIC_MAX_ROM_WAIT_USEC) {\r\ndev_err(&adapter->pdev->dev,\r\n"Timeout reached waiting for rom done");\r\nreturn -EIO;\r\n}\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_rom_fast_read(struct qlcnic_adapter *adapter,\r\nu32 addr, u32 *valp)\r\n{\r\nint err = 0;\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_ADDRESS, addr);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_ABYTE_CNT, 3);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_INSTR_OPCODE, 0xb);\r\nif (qlcnic_wait_rom_done(adapter)) {\r\ndev_err(&adapter->pdev->dev, "Error waiting for rom done\n");\r\nreturn -EIO;\r\n}\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_ABYTE_CNT, 0);\r\nudelay(10);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\r\n*valp = QLCRD32(adapter, QLCNIC_ROMUSB_ROM_RDATA, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int do_rom_fast_read_words(struct qlcnic_adapter *adapter, int addr,\r\nu8 *bytes, size_t size)\r\n{\r\nint addridx;\r\nint ret = 0;\r\nfor (addridx = addr; addridx < (addr + size); addridx += 4) {\r\nint v;\r\nret = do_rom_fast_read(adapter, addridx, &v);\r\nif (ret != 0)\r\nbreak;\r\n*(__le32 *)bytes = cpu_to_le32(v);\r\nbytes += 4;\r\n}\r\nreturn ret;\r\n}\r\nint\r\nqlcnic_rom_fast_read_words(struct qlcnic_adapter *adapter, int addr,\r\nu8 *bytes, size_t size)\r\n{\r\nint ret;\r\nret = qlcnic_rom_lock(adapter);\r\nif (ret < 0)\r\nreturn ret;\r\nret = do_rom_fast_read_words(adapter, addr, bytes, size);\r\nqlcnic_rom_unlock(adapter);\r\nreturn ret;\r\n}\r\nint qlcnic_rom_fast_read(struct qlcnic_adapter *adapter, u32 addr, u32 *valp)\r\n{\r\nint ret;\r\nif (qlcnic_rom_lock(adapter) != 0)\r\nreturn -EIO;\r\nret = do_rom_fast_read(adapter, addr, valp);\r\nqlcnic_rom_unlock(adapter);\r\nreturn ret;\r\n}\r\nint qlcnic_pinit_from_rom(struct qlcnic_adapter *adapter)\r\n{\r\nint addr, err = 0;\r\nint i, n, init_delay;\r\nstruct crb_addr_pair *buf;\r\nunsigned offset;\r\nu32 off, val;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CMDPEG_STATE, 0);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_RCVPEG_STATE, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x10, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x14, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x18, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x1c, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x20, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x24, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0x40, 0xff);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0x70000, 0x00);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0x80000, 0x00);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0x90000, 0x00);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0xa0000, 0x00);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0xb0000, 0x00);\r\nval = QLCRD32(adapter, QLCNIC_CRB_SRE + 0x1000, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nQLCWR32(adapter, QLCNIC_CRB_SRE + 0x1000, val & (~(0x1)));\r\nQLCWR32(adapter, QLCNIC_CRB_EPG + 0x1300, 0x1);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x0, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x8, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x10, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x18, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x100, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x200, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x3c, 1);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_1 + 0x3c, 1);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_2 + 0x3c, 1);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_3 + 0x3c, 1);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_4 + 0x3c, 1);\r\nmsleep(20);\r\nqlcnic_rom_unlock(adapter);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_GLB_SW_RESET, 0xfeffffff);\r\nif (qlcnic_rom_fast_read(adapter, 0, &n) != 0 || (n != 0xcafecafe) ||\r\nqlcnic_rom_fast_read(adapter, 4, &n) != 0) {\r\ndev_err(&pdev->dev, "ERROR Reading crb_init area: val:%x\n", n);\r\nreturn -EIO;\r\n}\r\noffset = n & 0xffffU;\r\nn = (n >> 16) & 0xffffU;\r\nif (n >= 1024) {\r\ndev_err(&pdev->dev, "QLOGIC card flash not initialized.\n");\r\nreturn -EIO;\r\n}\r\nbuf = kcalloc(n, sizeof(struct crb_addr_pair), GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < n; i++) {\r\nif (qlcnic_rom_fast_read(adapter, 8*i + 4*offset, &val) != 0 ||\r\nqlcnic_rom_fast_read(adapter, 8*i + 4*offset + 4, &addr) != 0) {\r\nkfree(buf);\r\nreturn -EIO;\r\n}\r\nbuf[i].addr = addr;\r\nbuf[i].data = val;\r\n}\r\nfor (i = 0; i < n; i++) {\r\noff = qlcnic_decode_crb_addr(buf[i].addr);\r\nif (off == QLCNIC_ADDR_ERROR) {\r\ndev_err(&pdev->dev, "CRB init value out of range %x\n",\r\nbuf[i].addr);\r\ncontinue;\r\n}\r\noff += QLCNIC_PCI_CRBSPACE;\r\nif (off & 1)\r\ncontinue;\r\nif (off == QLCNIC_CAM_RAM(0x1fc))\r\ncontinue;\r\nif (off == (QLCNIC_CRB_I2C0 + 0x1c))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xbc))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xa8))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xc8))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0x24))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0x1c))\r\ncontinue;\r\nif ((off & 0x0ff00000) == QLCNIC_CRB_DDR_NET)\r\ncontinue;\r\nif (off == QLCNIC_PCIE_REG(PCIE_SETUP_FUNCTION))\r\ncontinue;\r\nif (off == QLCNIC_PCIE_REG(PCIE_SETUP_FUNCTION2))\r\ncontinue;\r\nif ((off & 0x0ff00000) == QLCNIC_CRB_SMB)\r\ncontinue;\r\ninit_delay = 1;\r\nif (off == QLCNIC_ROMUSB_GLB_SW_RESET)\r\ninit_delay = 1000;\r\nQLCWR32(adapter, off, buf[i].data);\r\nmsleep(init_delay);\r\n}\r\nkfree(buf);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_D + 0xec, 0x1e);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_D + 0x4c, 8);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_I + 0x4c, 8);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x8, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0xc, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_1 + 0x8, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_1 + 0xc, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_2 + 0x8, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_2 + 0xc, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_3 + 0x8, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_3 + 0xc, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_4 + 0x8, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_4 + 0xc, 0);\r\nmsleep(1);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_PEG_HALT_STATUS1, 0);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_PEG_HALT_STATUS2, 0);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_cmd_peg_ready(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nint retries = QLCNIC_CMDPEG_CHECK_RETRY_COUNT;\r\ndo {\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CMDPEG_STATE);\r\nswitch (val) {\r\ncase PHAN_INITIALIZE_COMPLETE:\r\ncase PHAN_INITIALIZE_ACK:\r\nreturn 0;\r\ncase PHAN_INITIALIZE_FAILED:\r\ngoto out_err;\r\ndefault:\r\nbreak;\r\n}\r\nmsleep(QLCNIC_CMDPEG_CHECK_DELAY);\r\n} while (--retries);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CMDPEG_STATE,\r\nPHAN_INITIALIZE_FAILED);\r\nout_err:\r\ndev_err(&adapter->pdev->dev, "Command Peg initialization not "\r\n"complete, state: 0x%x.\n", val);\r\nreturn -EIO;\r\n}\r\nstatic int\r\nqlcnic_receive_peg_ready(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nint retries = QLCNIC_RCVPEG_CHECK_RETRY_COUNT;\r\ndo {\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_RCVPEG_STATE);\r\nif (val == PHAN_PEG_RCV_INITIALIZED)\r\nreturn 0;\r\nmsleep(QLCNIC_RCVPEG_CHECK_DELAY);\r\n} while (--retries);\r\nif (!retries) {\r\ndev_err(&adapter->pdev->dev, "Receive Peg initialization not "\r\n"complete, state: 0x%x.\n", val);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nqlcnic_check_fw_status(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nerr = qlcnic_cmd_peg_ready(adapter);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_receive_peg_ready(adapter);\r\nif (err)\r\nreturn err;\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CMDPEG_STATE, PHAN_INITIALIZE_ACK);\r\nreturn err;\r\n}\r\nint\r\nqlcnic_setup_idc_param(struct qlcnic_adapter *adapter) {\r\nint timeo;\r\nu32 val;\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_PARTITION_INFO);\r\nval = QLC_DEV_GET_DRV(val, adapter->portnum);\r\nif ((val & 0x3) != QLCNIC_TYPE_NIC) {\r\ndev_err(&adapter->pdev->dev,\r\n"Not an Ethernet NIC func=%u\n", val);\r\nreturn -EIO;\r\n}\r\nadapter->ahw->physical_port = (val >> 2);\r\nif (qlcnic_rom_fast_read(adapter, QLCNIC_ROM_DEV_INIT_TIMEOUT, &timeo))\r\ntimeo = QLCNIC_INIT_TIMEOUT_SECS;\r\nadapter->dev_init_timeo = timeo;\r\nif (qlcnic_rom_fast_read(adapter, QLCNIC_ROM_DRV_RESET_TIMEOUT, &timeo))\r\ntimeo = QLCNIC_RESET_TIMEOUT_SECS;\r\nadapter->reset_ack_timeo = timeo;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_get_flt_entry(struct qlcnic_adapter *adapter, u8 region,\r\nstruct qlcnic_flt_entry *region_entry)\r\n{\r\nstruct qlcnic_flt_header flt_hdr;\r\nstruct qlcnic_flt_entry *flt_entry;\r\nint i = 0, ret;\r\nu32 entry_size;\r\nmemset(region_entry, 0, sizeof(struct qlcnic_flt_entry));\r\nret = qlcnic_rom_fast_read_words(adapter, QLCNIC_FLT_LOCATION,\r\n(u8 *)&flt_hdr,\r\nsizeof(struct qlcnic_flt_header));\r\nif (ret) {\r\ndev_warn(&adapter->pdev->dev,\r\n"error reading flash layout header\n");\r\nreturn -EIO;\r\n}\r\nentry_size = flt_hdr.len - sizeof(struct qlcnic_flt_header);\r\nflt_entry = vzalloc(entry_size);\r\nif (flt_entry == NULL)\r\nreturn -EIO;\r\nret = qlcnic_rom_fast_read_words(adapter, QLCNIC_FLT_LOCATION +\r\nsizeof(struct qlcnic_flt_header),\r\n(u8 *)flt_entry, entry_size);\r\nif (ret) {\r\ndev_warn(&adapter->pdev->dev,\r\n"error reading flash layout entries\n");\r\ngoto err_out;\r\n}\r\nwhile (i < (entry_size/sizeof(struct qlcnic_flt_entry))) {\r\nif (flt_entry[i].region == region)\r\nbreak;\r\ni++;\r\n}\r\nif (i >= (entry_size/sizeof(struct qlcnic_flt_entry))) {\r\ndev_warn(&adapter->pdev->dev,\r\n"region=%x not found in %d regions\n", region, i);\r\nret = -EIO;\r\ngoto err_out;\r\n}\r\nmemcpy(region_entry, &flt_entry[i], sizeof(struct qlcnic_flt_entry));\r\nerr_out:\r\nvfree(flt_entry);\r\nreturn ret;\r\n}\r\nint\r\nqlcnic_check_flash_fw_ver(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_flt_entry fw_entry;\r\nu32 ver = -1, min_ver;\r\nint ret;\r\nif (adapter->ahw->revision_id == QLCNIC_P3P_C0)\r\nret = qlcnic_get_flt_entry(adapter, QLCNIC_C0_FW_IMAGE_REGION,\r\n&fw_entry);\r\nelse\r\nret = qlcnic_get_flt_entry(adapter, QLCNIC_B0_FW_IMAGE_REGION,\r\n&fw_entry);\r\nif (!ret)\r\nqlcnic_rom_fast_read(adapter, fw_entry.start_addr + 4,\r\n(int *)&ver);\r\nelse\r\nqlcnic_rom_fast_read(adapter, QLCNIC_FW_VERSION_OFFSET,\r\n(int *)&ver);\r\nver = QLCNIC_DECODE_VERSION(ver);\r\nmin_ver = QLCNIC_MIN_FW_VERSION;\r\nif (ver < min_ver) {\r\ndev_err(&adapter->pdev->dev,\r\n"firmware version %d.%d.%d unsupported."\r\n"Min supported version %d.%d.%d\n",\r\n_major(ver), _minor(ver), _build(ver),\r\n_major(min_ver), _minor(min_ver), _build(min_ver));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_has_mn(struct qlcnic_adapter *adapter)\r\n{\r\nu32 capability = 0;\r\nint err = 0;\r\ncapability = QLCRD32(adapter, QLCNIC_PEG_TUNE_CAPABILITY, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nif (capability & QLCNIC_PEG_TUNE_MN_PRESENT)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic\r\nstruct uni_table_desc *qlcnic_get_table_desc(const u8 *unirom, int section)\r\n{\r\nu32 i, entries;\r\nstruct uni_table_desc *directory = (struct uni_table_desc *) &unirom[0];\r\nentries = le32_to_cpu(directory->num_entries);\r\nfor (i = 0; i < entries; i++) {\r\nu32 offs = le32_to_cpu(directory->findex) +\r\ni * le32_to_cpu(directory->entry_size);\r\nu32 tab_type = le32_to_cpu(*((__le32 *)&unirom[offs] + 8));\r\nif (tab_type == section)\r\nreturn (struct uni_table_desc *) &unirom[offs];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nqlcnic_validate_header(struct qlcnic_adapter *adapter)\r\n{\r\nconst u8 *unirom = adapter->fw->data;\r\nstruct uni_table_desc *directory = (struct uni_table_desc *) &unirom[0];\r\nu32 entries, entry_size, tab_size, fw_file_size;\r\nfw_file_size = adapter->fw->size;\r\nif (fw_file_size < FILEHEADER_SIZE)\r\nreturn -EINVAL;\r\nentries = le32_to_cpu(directory->num_entries);\r\nentry_size = le32_to_cpu(directory->entry_size);\r\ntab_size = le32_to_cpu(directory->findex) + (entries * entry_size);\r\nif (fw_file_size < tab_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_validate_bootld(struct qlcnic_adapter *adapter)\r\n{\r\nstruct uni_table_desc *tab_desc;\r\nstruct uni_data_desc *descr;\r\nu32 offs, tab_size, data_size, idx;\r\nconst u8 *unirom = adapter->fw->data;\r\n__le32 temp;\r\ntemp = *((__le32 *)&unirom[adapter->file_prd_off] +\r\nQLCNIC_UNI_BOOTLD_IDX_OFF);\r\nidx = le32_to_cpu(temp);\r\ntab_desc = qlcnic_get_table_desc(unirom, QLCNIC_UNI_DIR_SECT_BOOTLD);\r\nif (!tab_desc)\r\nreturn -EINVAL;\r\ntab_size = le32_to_cpu(tab_desc->findex) +\r\nle32_to_cpu(tab_desc->entry_size) * (idx + 1);\r\nif (adapter->fw->size < tab_size)\r\nreturn -EINVAL;\r\noffs = le32_to_cpu(tab_desc->findex) +\r\nle32_to_cpu(tab_desc->entry_size) * idx;\r\ndescr = (struct uni_data_desc *)&unirom[offs];\r\ndata_size = le32_to_cpu(descr->findex) + le32_to_cpu(descr->size);\r\nif (adapter->fw->size < data_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_validate_fw(struct qlcnic_adapter *adapter)\r\n{\r\nstruct uni_table_desc *tab_desc;\r\nstruct uni_data_desc *descr;\r\nconst u8 *unirom = adapter->fw->data;\r\nu32 offs, tab_size, data_size, idx;\r\n__le32 temp;\r\ntemp = *((__le32 *)&unirom[adapter->file_prd_off] +\r\nQLCNIC_UNI_FIRMWARE_IDX_OFF);\r\nidx = le32_to_cpu(temp);\r\ntab_desc = qlcnic_get_table_desc(unirom, QLCNIC_UNI_DIR_SECT_FW);\r\nif (!tab_desc)\r\nreturn -EINVAL;\r\ntab_size = le32_to_cpu(tab_desc->findex) +\r\nle32_to_cpu(tab_desc->entry_size) * (idx + 1);\r\nif (adapter->fw->size < tab_size)\r\nreturn -EINVAL;\r\noffs = le32_to_cpu(tab_desc->findex) +\r\nle32_to_cpu(tab_desc->entry_size) * idx;\r\ndescr = (struct uni_data_desc *)&unirom[offs];\r\ndata_size = le32_to_cpu(descr->findex) + le32_to_cpu(descr->size);\r\nif (adapter->fw->size < data_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_validate_product_offs(struct qlcnic_adapter *adapter)\r\n{\r\nstruct uni_table_desc *ptab_descr;\r\nconst u8 *unirom = adapter->fw->data;\r\nint mn_present = qlcnic_has_mn(adapter);\r\nu32 entries, entry_size, tab_size, i;\r\n__le32 temp;\r\nptab_descr = qlcnic_get_table_desc(unirom,\r\nQLCNIC_UNI_DIR_SECT_PRODUCT_TBL);\r\nif (!ptab_descr)\r\nreturn -EINVAL;\r\nentries = le32_to_cpu(ptab_descr->num_entries);\r\nentry_size = le32_to_cpu(ptab_descr->entry_size);\r\ntab_size = le32_to_cpu(ptab_descr->findex) + (entries * entry_size);\r\nif (adapter->fw->size < tab_size)\r\nreturn -EINVAL;\r\nnomn:\r\nfor (i = 0; i < entries; i++) {\r\nu32 flags, file_chiprev, offs;\r\nu8 chiprev = adapter->ahw->revision_id;\r\nu32 flagbit;\r\noffs = le32_to_cpu(ptab_descr->findex) +\r\ni * le32_to_cpu(ptab_descr->entry_size);\r\ntemp = *((__le32 *)&unirom[offs] + QLCNIC_UNI_FLAGS_OFF);\r\nflags = le32_to_cpu(temp);\r\ntemp = *((__le32 *)&unirom[offs] + QLCNIC_UNI_CHIP_REV_OFF);\r\nfile_chiprev = le32_to_cpu(temp);\r\nflagbit = mn_present ? 1 : 2;\r\nif ((chiprev == file_chiprev) &&\r\n((1ULL << flagbit) & flags)) {\r\nadapter->file_prd_off = offs;\r\nreturn 0;\r\n}\r\n}\r\nif (mn_present) {\r\nmn_present = 0;\r\ngoto nomn;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nqlcnic_validate_unified_romimage(struct qlcnic_adapter *adapter)\r\n{\r\nif (qlcnic_validate_header(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: header validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (qlcnic_validate_product_offs(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: product validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (qlcnic_validate_bootld(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: bootld validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (qlcnic_validate_fw(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: firmware validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nstruct uni_data_desc *qlcnic_get_data_desc(struct qlcnic_adapter *adapter,\r\nu32 section, u32 idx_offset)\r\n{\r\nconst u8 *unirom = adapter->fw->data;\r\nstruct uni_table_desc *tab_desc;\r\nu32 offs, idx;\r\n__le32 temp;\r\ntemp = *((__le32 *)&unirom[adapter->file_prd_off] + idx_offset);\r\nidx = le32_to_cpu(temp);\r\ntab_desc = qlcnic_get_table_desc(unirom, section);\r\nif (tab_desc == NULL)\r\nreturn NULL;\r\noffs = le32_to_cpu(tab_desc->findex) +\r\nle32_to_cpu(tab_desc->entry_size) * idx;\r\nreturn (struct uni_data_desc *)&unirom[offs];\r\n}\r\nstatic u8 *\r\nqlcnic_get_bootld_offs(struct qlcnic_adapter *adapter)\r\n{\r\nu32 offs = QLCNIC_BOOTLD_START;\r\nstruct uni_data_desc *data_desc;\r\ndata_desc = qlcnic_get_data_desc(adapter, QLCNIC_UNI_DIR_SECT_BOOTLD,\r\nQLCNIC_UNI_BOOTLD_IDX_OFF);\r\nif (adapter->ahw->fw_type == QLCNIC_UNIFIED_ROMIMAGE)\r\noffs = le32_to_cpu(data_desc->findex);\r\nreturn (u8 *)&adapter->fw->data[offs];\r\n}\r\nstatic u8 *\r\nqlcnic_get_fw_offs(struct qlcnic_adapter *adapter)\r\n{\r\nu32 offs = QLCNIC_IMAGE_START;\r\nstruct uni_data_desc *data_desc;\r\ndata_desc = qlcnic_get_data_desc(adapter, QLCNIC_UNI_DIR_SECT_FW,\r\nQLCNIC_UNI_FIRMWARE_IDX_OFF);\r\nif (adapter->ahw->fw_type == QLCNIC_UNIFIED_ROMIMAGE)\r\noffs = le32_to_cpu(data_desc->findex);\r\nreturn (u8 *)&adapter->fw->data[offs];\r\n}\r\nstatic u32 qlcnic_get_fw_size(struct qlcnic_adapter *adapter)\r\n{\r\nstruct uni_data_desc *data_desc;\r\nconst u8 *unirom = adapter->fw->data;\r\ndata_desc = qlcnic_get_data_desc(adapter, QLCNIC_UNI_DIR_SECT_FW,\r\nQLCNIC_UNI_FIRMWARE_IDX_OFF);\r\nif (adapter->ahw->fw_type == QLCNIC_UNIFIED_ROMIMAGE)\r\nreturn le32_to_cpu(data_desc->size);\r\nelse\r\nreturn le32_to_cpu(*(__le32 *)&unirom[QLCNIC_FW_SIZE_OFFSET]);\r\n}\r\nstatic u32 qlcnic_get_fw_version(struct qlcnic_adapter *adapter)\r\n{\r\nstruct uni_data_desc *fw_data_desc;\r\nconst struct firmware *fw = adapter->fw;\r\nu32 major, minor, sub;\r\n__le32 version_offset;\r\nconst u8 *ver_str;\r\nint i, ret;\r\nif (adapter->ahw->fw_type != QLCNIC_UNIFIED_ROMIMAGE) {\r\nversion_offset = *(__le32 *)&fw->data[QLCNIC_FW_VERSION_OFFSET];\r\nreturn le32_to_cpu(version_offset);\r\n}\r\nfw_data_desc = qlcnic_get_data_desc(adapter, QLCNIC_UNI_DIR_SECT_FW,\r\nQLCNIC_UNI_FIRMWARE_IDX_OFF);\r\nver_str = fw->data + le32_to_cpu(fw_data_desc->findex) +\r\nle32_to_cpu(fw_data_desc->size) - 17;\r\nfor (i = 0; i < 12; i++) {\r\nif (!strncmp(&ver_str[i], "REV=", 4)) {\r\nret = sscanf(&ver_str[i+4], "%u.%u.%u ",\r\n&major, &minor, &sub);\r\nif (ret != 3)\r\nreturn 0;\r\nelse\r\nreturn major + (minor << 8) + (sub << 16);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 qlcnic_get_bios_version(struct qlcnic_adapter *adapter)\r\n{\r\nconst struct firmware *fw = adapter->fw;\r\nu32 bios_ver, prd_off = adapter->file_prd_off;\r\nu8 *version_offset;\r\n__le32 temp;\r\nif (adapter->ahw->fw_type != QLCNIC_UNIFIED_ROMIMAGE) {\r\nversion_offset = (u8 *)&fw->data[QLCNIC_BIOS_VERSION_OFFSET];\r\nreturn le32_to_cpu(*(__le32 *)version_offset);\r\n}\r\ntemp = *((__le32 *)(&fw->data[prd_off]) + QLCNIC_UNI_BIOS_VERSION_OFF);\r\nbios_ver = le32_to_cpu(temp);\r\nreturn (bios_ver << 16) + ((bios_ver >> 8) & 0xff00) + (bios_ver >> 24);\r\n}\r\nstatic void qlcnic_rom_lock_recovery(struct qlcnic_adapter *adapter)\r\n{\r\nif (qlcnic_pcie_sem_lock(adapter, 2, QLCNIC_ROM_LOCK_ID))\r\ndev_info(&adapter->pdev->dev, "Resetting rom_lock\n");\r\nqlcnic_pcie_sem_unlock(adapter, 2);\r\n}\r\nstatic int\r\nqlcnic_check_fw_hearbeat(struct qlcnic_adapter *adapter)\r\n{\r\nu32 heartbeat, ret = -EIO;\r\nint retries = QLCNIC_HEARTBEAT_CHECK_RETRY_COUNT;\r\nadapter->heartbeat = QLC_SHARED_REG_RD32(adapter,\r\nQLCNIC_PEG_ALIVE_COUNTER);\r\ndo {\r\nmsleep(QLCNIC_HEARTBEAT_PERIOD_MSECS);\r\nheartbeat = QLC_SHARED_REG_RD32(adapter,\r\nQLCNIC_PEG_ALIVE_COUNTER);\r\nif (heartbeat != adapter->heartbeat) {\r\nret = QLCNIC_RCODE_SUCCESS;\r\nbreak;\r\n}\r\n} while (--retries);\r\nreturn ret;\r\n}\r\nint\r\nqlcnic_need_fw_reset(struct qlcnic_adapter *adapter)\r\n{\r\nif ((adapter->flags & QLCNIC_FW_HANG) ||\r\nqlcnic_check_fw_hearbeat(adapter)) {\r\nqlcnic_rom_lock_recovery(adapter);\r\nreturn 1;\r\n}\r\nif (adapter->need_fw_reset)\r\nreturn 1;\r\nif (adapter->fw)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint\r\nqlcnic_load_firmware(struct qlcnic_adapter *adapter)\r\n{\r\n__le64 *ptr64;\r\nu32 i, flashaddr, size;\r\nconst struct firmware *fw = adapter->fw;\r\nstruct pci_dev *pdev = adapter->pdev;\r\ndev_info(&pdev->dev, "loading firmware from %s\n",\r\nfw_name[adapter->ahw->fw_type]);\r\nif (fw) {\r\nu64 data;\r\nsize = (QLCNIC_IMAGE_START - QLCNIC_BOOTLD_START) / 8;\r\nptr64 = (__le64 *)qlcnic_get_bootld_offs(adapter);\r\nflashaddr = QLCNIC_BOOTLD_START;\r\nfor (i = 0; i < size; i++) {\r\ndata = le64_to_cpu(ptr64[i]);\r\nif (qlcnic_pci_mem_write_2M(adapter, flashaddr, data))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\nsize = qlcnic_get_fw_size(adapter) / 8;\r\nptr64 = (__le64 *)qlcnic_get_fw_offs(adapter);\r\nflashaddr = QLCNIC_IMAGE_START;\r\nfor (i = 0; i < size; i++) {\r\ndata = le64_to_cpu(ptr64[i]);\r\nif (qlcnic_pci_mem_write_2M(adapter,\r\nflashaddr, data))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\nsize = qlcnic_get_fw_size(adapter) % 8;\r\nif (size) {\r\ndata = le64_to_cpu(ptr64[i]);\r\nif (qlcnic_pci_mem_write_2M(adapter,\r\nflashaddr, data))\r\nreturn -EIO;\r\n}\r\n} else {\r\nu64 data;\r\nu32 hi, lo;\r\nint ret;\r\nstruct qlcnic_flt_entry bootld_entry;\r\nret = qlcnic_get_flt_entry(adapter, QLCNIC_BOOTLD_REGION,\r\n&bootld_entry);\r\nif (!ret) {\r\nsize = bootld_entry.size / 8;\r\nflashaddr = bootld_entry.start_addr;\r\n} else {\r\nsize = (QLCNIC_IMAGE_START - QLCNIC_BOOTLD_START) / 8;\r\nflashaddr = QLCNIC_BOOTLD_START;\r\ndev_info(&pdev->dev,\r\n"using legacy method to get flash fw region");\r\n}\r\nfor (i = 0; i < size; i++) {\r\nif (qlcnic_rom_fast_read(adapter,\r\nflashaddr, (int *)&lo) != 0)\r\nreturn -EIO;\r\nif (qlcnic_rom_fast_read(adapter,\r\nflashaddr + 4, (int *)&hi) != 0)\r\nreturn -EIO;\r\ndata = (((u64)hi << 32) | lo);\r\nif (qlcnic_pci_mem_write_2M(adapter,\r\nflashaddr, data))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\n}\r\nmsleep(1);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x18, 0x1020);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_GLB_SW_RESET, 0x80001e);\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_validate_firmware(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nu32 ver, bios, min_size;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nconst struct firmware *fw = adapter->fw;\r\nu8 fw_type = adapter->ahw->fw_type;\r\nif (fw_type == QLCNIC_UNIFIED_ROMIMAGE) {\r\nif (qlcnic_validate_unified_romimage(adapter))\r\nreturn -EINVAL;\r\nmin_size = QLCNIC_UNI_FW_MIN_SIZE;\r\n} else {\r\nval = le32_to_cpu(*(__le32 *)&fw->data[QLCNIC_FW_MAGIC_OFFSET]);\r\nif (val != QLCNIC_BDINFO_MAGIC)\r\nreturn -EINVAL;\r\nmin_size = QLCNIC_FW_MIN_SIZE;\r\n}\r\nif (fw->size < min_size)\r\nreturn -EINVAL;\r\nval = qlcnic_get_fw_version(adapter);\r\nver = QLCNIC_DECODE_VERSION(val);\r\nif (ver < QLCNIC_MIN_FW_VERSION) {\r\ndev_err(&pdev->dev,\r\n"%s: firmware version %d.%d.%d unsupported\n",\r\nfw_name[fw_type], _major(ver), _minor(ver), _build(ver));\r\nreturn -EINVAL;\r\n}\r\nval = qlcnic_get_bios_version(adapter);\r\nqlcnic_rom_fast_read(adapter, QLCNIC_BIOS_VERSION_OFFSET, (int *)&bios);\r\nif (val != bios) {\r\ndev_err(&pdev->dev, "%s: firmware bios is incompatible\n",\r\nfw_name[fw_type]);\r\nreturn -EINVAL;\r\n}\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_FW_IMG_VALID, QLCNIC_BDINFO_MAGIC);\r\nreturn 0;\r\n}\r\nstatic void\r\nqlcnic_get_next_fwtype(struct qlcnic_adapter *adapter)\r\n{\r\nu8 fw_type;\r\nswitch (adapter->ahw->fw_type) {\r\ncase QLCNIC_UNKNOWN_ROMIMAGE:\r\nfw_type = QLCNIC_UNIFIED_ROMIMAGE;\r\nbreak;\r\ncase QLCNIC_UNIFIED_ROMIMAGE:\r\ndefault:\r\nfw_type = QLCNIC_FLASH_ROMIMAGE;\r\nbreak;\r\n}\r\nadapter->ahw->fw_type = fw_type;\r\n}\r\nvoid qlcnic_request_firmware(struct qlcnic_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint rc;\r\nadapter->ahw->fw_type = QLCNIC_UNKNOWN_ROMIMAGE;\r\nnext:\r\nqlcnic_get_next_fwtype(adapter);\r\nif (adapter->ahw->fw_type == QLCNIC_FLASH_ROMIMAGE) {\r\nadapter->fw = NULL;\r\n} else {\r\nrc = request_firmware(&adapter->fw,\r\nfw_name[adapter->ahw->fw_type],\r\n&pdev->dev);\r\nif (rc != 0)\r\ngoto next;\r\nrc = qlcnic_validate_firmware(adapter);\r\nif (rc != 0) {\r\nrelease_firmware(adapter->fw);\r\nmsleep(1);\r\ngoto next;\r\n}\r\n}\r\n}\r\nvoid\r\nqlcnic_release_firmware(struct qlcnic_adapter *adapter)\r\n{\r\nrelease_firmware(adapter->fw);\r\nadapter->fw = NULL;\r\n}
