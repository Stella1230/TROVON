static inline void ehci_write(void __iomem *base, u32 reg, u32 val)\r\n{\r\n__raw_writel(val, base + reg);\r\n}\r\nstatic inline u32 ehci_read(void __iomem *base, u32 reg)\r\n{\r\nreturn __raw_readl(base + reg);\r\n}\r\nstatic int ehci_hcd_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usbhs_omap_platform_data *pdata = dev_get_platdata(dev);\r\nstruct resource *res;\r\nstruct usb_hcd *hcd;\r\nvoid __iomem *regs;\r\nint ret;\r\nint irq;\r\nint i;\r\nstruct omap_hcd *omap;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (!dev->parent) {\r\ndev_err(dev, "Missing parent device\n");\r\nreturn -ENODEV;\r\n}\r\nif (dev->of_node) {\r\npdata = dev_get_platdata(dev->parent);\r\ndev->platform_data = pdata;\r\n}\r\nif (!pdata) {\r\ndev_err(dev, "Missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "EHCI irq failed\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nret = -ENODEV;\r\nhcd = usb_create_hcd(&ehci_omap_hc_driver, dev,\r\ndev_name(dev));\r\nif (!hcd) {\r\ndev_err(dev, "Failed to create HCD\n");\r\nreturn -ENOMEM;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nhcd->regs = regs;\r\nhcd_to_ehci(hcd)->caps = regs;\r\nomap = (struct omap_hcd *)hcd_to_ehci(hcd)->priv;\r\nomap->nports = pdata->nports;\r\nplatform_set_drvdata(pdev, hcd);\r\nfor (i = 0 ; i < omap->nports ; i++) {\r\nstruct usb_phy *phy;\r\nif (dev->of_node)\r\nphy = devm_usb_get_phy_by_phandle(dev, "phys", i);\r\nelse\r\nphy = devm_usb_get_phy_dev(dev, i);\r\nif (IS_ERR(phy)) {\r\nif (pdata->port_mode[i] != OMAP_EHCI_PORT_MODE_PHY)\r\ncontinue;\r\nret = PTR_ERR(phy);\r\ndev_err(dev, "Can't get PHY device for port %d: %d\n",\r\ni, ret);\r\ngoto err_phy;\r\n}\r\nomap->phy[i] = phy;\r\nif (pdata->port_mode[i] == OMAP_EHCI_PORT_MODE_PHY) {\r\nusb_phy_init(omap->phy[i]);\r\nusb_phy_set_suspend(omap->phy[i], 0);\r\n}\r\n}\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\nehci_write(regs, EHCI_INSNREG04,\r\nEHCI_INSNREG04_DISABLE_UNSUSPEND);\r\nret = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (ret) {\r\ndev_err(dev, "failed to add hcd with err %d\n", ret);\r\ngoto err_pm_runtime;\r\n}\r\ndevice_wakeup_enable(hcd->self.controller);\r\nfor (i = 0; i < omap->nports; i++) {\r\nif (!omap->phy[i] ||\r\npdata->port_mode[i] == OMAP_EHCI_PORT_MODE_PHY)\r\ncontinue;\r\nusb_phy_init(omap->phy[i]);\r\nusb_phy_set_suspend(omap->phy[i], 0);\r\n}\r\nreturn 0;\r\nerr_pm_runtime:\r\npm_runtime_put_sync(dev);\r\nerr_phy:\r\nfor (i = 0; i < omap->nports; i++) {\r\nif (omap->phy[i])\r\nusb_phy_shutdown(omap->phy[i]);\r\n}\r\nusb_put_hcd(hcd);\r\nreturn ret;\r\n}\r\nstatic int ehci_hcd_omap_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct omap_hcd *omap = (struct omap_hcd *)hcd_to_ehci(hcd)->priv;\r\nint i;\r\nusb_remove_hcd(hcd);\r\nfor (i = 0; i < omap->nports; i++) {\r\nif (omap->phy[i])\r\nusb_phy_shutdown(omap->phy[i]);\r\n}\r\nusb_put_hcd(hcd);\r\npm_runtime_put_sync(dev);\r\npm_runtime_disable(dev);\r\nreturn 0;\r\n}\r\nstatic int __init ehci_omap_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nehci_init_driver(&ehci_omap_hc_driver, &ehci_omap_overrides);\r\nreturn platform_driver_register(&ehci_hcd_omap_driver);\r\n}\r\nstatic void __exit ehci_omap_cleanup(void)\r\n{\r\nplatform_driver_unregister(&ehci_hcd_omap_driver);\r\n}
