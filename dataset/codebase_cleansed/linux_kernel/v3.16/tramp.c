static int priv_tramp_sect_tgt_alloc(struct dload_state *dlthis)\r\n{\r\nint ret_val = 0;\r\nstruct ldr_section_info *sect_info;\r\nsect_info = &dlthis->ldr_sections[dlthis->allocated_secn_count];\r\nsect_info->name = dlthis->tramp.final_string_table;\r\nsect_info->size = dlthis->tramp.tramp_sect_next_addr;\r\nsect_info->context = 0;\r\nsect_info->type =\r\n(4 << 8) | DLOAD_TEXT | DS_ALLOCATE_MASK | DS_DOWNLOAD_MASK;\r\nsect_info->page = 0;\r\nsect_info->run_addr = 0;\r\nsect_info->load_addr = 0;\r\nret_val = dlthis->myalloc->dload_allocate(dlthis->myalloc,\r\nsect_info,\r\nds_alignment\r\n(sect_info->type));\r\nif (ret_val == 0)\r\ndload_error(dlthis, "Failed to allocate target memory for"\r\n" trampoline");\r\nreturn ret_val;\r\n}\r\nstatic u8 priv_h2a(u8 value)\r\n{\r\nif (value > 0xF)\r\nreturn 0xFF;\r\nif (value <= 9)\r\nvalue += 0x30;\r\nelse\r\nvalue += 0x37;\r\nreturn value;\r\n}\r\nstatic void priv_tramp_sym_gen_name(u32 value, char *dst)\r\n{\r\nu32 i;\r\nchar *prefix = TRAMP_SYM_PREFIX;\r\nchar *dst_local = dst;\r\nu8 tmp;\r\nfor (i = 0; i < (TRAMP_SYM_PREFIX_LEN + TRAMP_SYM_HEX_ASCII_LEN); i++)\r\n*(dst_local + i) = 0;\r\nfor (i = 0; i < strlen(TRAMP_SYM_PREFIX); i++) {\r\n*dst_local = *(prefix + i);\r\ndst_local++;\r\n}\r\nfor (i = 0; i < sizeof(value); i++) {\r\n#ifndef _BIG_ENDIAN\r\ntmp = *(((u8 *) &value) + (sizeof(value) - 1) - i);\r\n*dst_local = priv_h2a((tmp & 0xF0) >> 4);\r\ndst_local++;\r\n*dst_local = priv_h2a(tmp & 0x0F);\r\ndst_local++;\r\n#else\r\ntmp = *(((u8 *) &value) + i);\r\n*dst_local = priv_h2a((tmp & 0xF0) >> 4);\r\ndst_local++;\r\n*dst_local = priv_h2a(tmp & 0x0F);\r\ndst_local++;\r\n#endif\r\n}\r\n*dst_local = 0;\r\n}\r\nstatic struct tramp_string *priv_tramp_string_create(struct dload_state *dlthis,\r\nu32 str_len, char *str)\r\n{\r\nstruct tramp_string *new_string = NULL;\r\nu32 i;\r\nnew_string =\r\n(struct tramp_string *)dlthis->mysym->dload_allocate(dlthis->mysym,\r\n(sizeof\r\n(struct\r\ntramp_string)\r\n+ str_len +\r\n1));\r\nif (new_string != NULL) {\r\nfor (i = 0; i < (sizeof(struct tramp_string) + str_len + 1);\r\ni++)\r\n*((u8 *) new_string + i) = 0;\r\nnew_string->index = dlthis->tramp.tramp_string_next_index;\r\ndlthis->tramp.tramp_string_next_index++;\r\ndlthis->tramp.tramp_string_size += str_len + 1;\r\nnew_string->next = NULL;\r\nif (dlthis->tramp.string_head == NULL)\r\ndlthis->tramp.string_head = new_string;\r\nelse\r\ndlthis->tramp.string_tail->next = new_string;\r\ndlthis->tramp.string_tail = new_string;\r\nfor (i = 0; i < str_len; i++)\r\nnew_string->str[i] = str[i];\r\n}\r\nreturn new_string;\r\n}\r\nstatic struct tramp_string *priv_tramp_string_find(struct dload_state *dlthis,\r\nchar *str)\r\n{\r\nstruct tramp_string *cur_str = NULL;\r\nstruct tramp_string *ret_val = NULL;\r\nu32 i;\r\nu32 str_len = strlen(str);\r\nfor (cur_str = dlthis->tramp.string_head;\r\n(ret_val == NULL) && (cur_str != NULL); cur_str = cur_str->next) {\r\nif (str_len != strlen(cur_str->str))\r\ncontinue;\r\nfor (i = 0; i < str_len; i++) {\r\nif (str[i] != cur_str->str[i])\r\nbreak;\r\n}\r\nif (i == str_len)\r\nret_val = cur_str;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int priv_string_tbl_finalize(struct dload_state *dlthis)\r\n{\r\nint ret_val = 0;\r\nstruct tramp_string *cur_string;\r\nchar *cur_loc;\r\nchar *tmp;\r\ndlthis->tramp.final_string_table =\r\n(char *)dlthis->mysym->dload_allocate(dlthis->mysym,\r\ndlthis->tramp.\r\ntramp_string_size);\r\nif (dlthis->tramp.final_string_table != NULL) {\r\ncur_loc = dlthis->tramp.final_string_table;\r\ncur_string = dlthis->tramp.string_head;\r\nwhile (cur_string != NULL) {\r\ndlthis->tramp.string_head = cur_string->next;\r\nif (dlthis->tramp.string_tail == cur_string)\r\ndlthis->tramp.string_tail = NULL;\r\nfor (tmp = cur_string->str;\r\n*tmp != '\0'; tmp++, cur_loc++)\r\n*cur_loc = *tmp;\r\n*cur_loc = '\0';\r\ncur_loc++;\r\ndlthis->mysym->dload_deallocate(dlthis->mysym,\r\ncur_string);\r\ncur_string = dlthis->tramp.string_head;\r\n}\r\nret_val = 1;\r\n} else\r\ndload_error(dlthis, "Failed to allocate trampoline "\r\n"string table");\r\nreturn ret_val;\r\n}\r\nstatic u32 priv_tramp_sect_alloc(struct dload_state *dlthis, u32 tramp_size)\r\n{\r\nu32 ret_val;\r\nif (dlthis->tramp.tramp_sect_next_addr == 0) {\r\ndload_syms_error(dlthis->mysym, "*** WARNING *** created "\r\n"dynamic TRAMPOLINE section for module %s",\r\ndlthis->str_head);\r\n}\r\nret_val = dlthis->tramp.tramp_sect_next_addr;\r\ndlthis->tramp.tramp_sect_next_addr += tramp_size;\r\nreturn ret_val;\r\n}\r\nstatic struct tramp_sym *priv_tramp_sym_create(struct dload_state *dlthis,\r\nu32 str_index,\r\nstruct local_symbol *tmp_sym)\r\n{\r\nstruct tramp_sym *new_sym = NULL;\r\nu32 i;\r\nnew_sym =\r\n(struct tramp_sym *)dlthis->mysym->dload_allocate(dlthis->mysym,\r\nsizeof(struct tramp_sym));\r\nif (new_sym != NULL) {\r\nfor (i = 0; i != sizeof(struct tramp_sym); i++)\r\n*((char *)new_sym + i) = 0;\r\nnew_sym->index = dlthis->tramp.tramp_sym_next_index;\r\ndlthis->tramp.tramp_sym_next_index++;\r\nnew_sym->sym_info = *tmp_sym;\r\nnew_sym->str_index = str_index;\r\nnew_sym->next = NULL;\r\nif (dlthis->tramp.symbol_head == NULL)\r\ndlthis->tramp.symbol_head = new_sym;\r\nelse\r\ndlthis->tramp.symbol_tail->next = new_sym;\r\ndlthis->tramp.symbol_tail = new_sym;\r\n}\r\nreturn new_sym;\r\n}\r\nstatic struct tramp_sym *priv_tramp_sym_get(struct dload_state *dlthis,\r\nu32 string_index)\r\n{\r\nstruct tramp_sym *sym_found = NULL;\r\nfor (sym_found = dlthis->tramp.symbol_head;\r\nsym_found != NULL; sym_found = sym_found->next) {\r\nif (sym_found->str_index == string_index)\r\nbreak;\r\n}\r\nreturn sym_found;\r\n}\r\nstatic struct tramp_sym *priv_tramp_sym_find(struct dload_state *dlthis,\r\nchar *string)\r\n{\r\nstruct tramp_sym *sym_found = NULL;\r\nstruct tramp_string *str_found = NULL;\r\nstr_found = priv_tramp_string_find(dlthis, string);\r\nif (str_found != NULL)\r\nsym_found = priv_tramp_sym_get(dlthis, str_found->index);\r\nreturn sym_found;\r\n}\r\nstatic int priv_tramp_sym_finalize(struct dload_state *dlthis)\r\n{\r\nint ret_val = 0;\r\nstruct tramp_sym *cur_sym;\r\nstruct ldr_section_info *tramp_sect =\r\n&dlthis->ldr_sections[dlthis->allocated_secn_count];\r\nstruct local_symbol *new_sym;\r\ndlthis->tramp.final_sym_table =\r\n(struct local_symbol *)dlthis->mysym->dload_allocate(dlthis->mysym,\r\n(sizeof(struct local_symbol) * dlthis->tramp.\r\ntramp_sym_next_index));\r\nif (dlthis->tramp.final_sym_table != NULL) {\r\nnew_sym = dlthis->tramp.final_sym_table;\r\ncur_sym = dlthis->tramp.symbol_head;\r\nwhile (cur_sym != NULL) {\r\ndlthis->tramp.symbol_head = cur_sym->next;\r\nif (cur_sym == dlthis->tramp.symbol_tail)\r\ndlthis->tramp.symbol_tail = NULL;\r\n*new_sym = cur_sym->sym_info;\r\nif (new_sym->secnn < 0) {\r\nnew_sym->value += tramp_sect->load_addr;\r\nnew_sym->delta = new_sym->value;\r\n}\r\ndlthis->mysym->dload_deallocate(dlthis->mysym, cur_sym);\r\ncur_sym = dlthis->tramp.symbol_head;\r\nnew_sym++;\r\n}\r\nret_val = 1;\r\n} else\r\ndload_error(dlthis, "Failed to alloc trampoline sym table");\r\nreturn ret_val;\r\n}\r\nstatic int priv_tgt_img_gen(struct dload_state *dlthis, u32 base,\r\nu32 gen_index, struct tramp_sym *new_ext_sym)\r\n{\r\nstruct tramp_img_pkt *new_img_pkt = NULL;\r\nu32 i;\r\nu32 pkt_size = tramp_img_pkt_size_get();\r\nu8 *gen_tbl_entry;\r\nu8 *pkt_data;\r\nstruct reloc_record_t *cur_relo;\r\nint ret_val = 0;\r\nnew_img_pkt =\r\n(struct tramp_img_pkt *)dlthis->mysym->dload_allocate(dlthis->mysym,\r\npkt_size);\r\nif (new_img_pkt != NULL) {\r\nnew_img_pkt->base = base;\r\npkt_data = (u8 *) &new_img_pkt->hdr;\r\ngen_tbl_entry = (u8 *) &tramp_gen_info[gen_index];\r\nfor (i = 0; i < pkt_size; i++) {\r\n*pkt_data = *gen_tbl_entry;\r\npkt_data++;\r\ngen_tbl_entry++;\r\n}\r\ncur_relo =\r\n(struct reloc_record_t *)((u8 *) &new_img_pkt->hdr +\r\nnew_img_pkt->hdr.relo_offset);\r\nfor (i = 0; i < new_img_pkt->hdr.num_relos; i++)\r\ncur_relo[i].SYMNDX = new_ext_sym->index;\r\nnew_img_pkt->next = dlthis->tramp.tramp_pkts;\r\ndlthis->tramp.tramp_pkts = new_img_pkt;\r\nret_val = 1;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int priv_pkt_relo(struct dload_state *dlthis, tgt_au_t *data,\r\nstruct reloc_record_t *rp[], u32 relo_count)\r\n{\r\nint ret_val = 1;\r\nu32 i;\r\nbool tmp;\r\nfor (i = 0; i < relo_count; i++)\r\ndload_relocate(dlthis, data, rp[i], &tmp, true);\r\nreturn ret_val;\r\n}\r\nstatic int priv_tramp_pkt_finalize(struct dload_state *dlthis)\r\n{\r\nint ret_val = 1;\r\nstruct tramp_img_pkt *cur_pkt = NULL;\r\nstruct reloc_record_t *relos[MAX_RELOS_PER_PASS];\r\nu32 relos_done;\r\nu32 i;\r\nstruct reloc_record_t *cur_relo;\r\nstruct ldr_section_info *sect_info =\r\n&dlthis->ldr_sections[dlthis->allocated_secn_count];\r\ncur_pkt = dlthis->tramp.tramp_pkts;\r\nwhile ((ret_val != 0) && (cur_pkt != NULL)) {\r\ndlthis->tramp.tramp_pkts = cur_pkt->next;\r\ndlthis->image_secn = sect_info;\r\ndlthis->image_offset = cur_pkt->base;\r\ndlthis->delta_runaddr = sect_info->run_addr;\r\nrelos_done = 0;\r\ncur_relo = (struct reloc_record_t *)((u8 *) &cur_pkt->hdr +\r\ncur_pkt->hdr.relo_offset);\r\nwhile (relos_done < cur_pkt->hdr.num_relos) {\r\n#ifdef ENABLE_TRAMP_DEBUG\r\ndload_syms_error(dlthis->mysym,\r\n"===> Trampoline %x branches to %x",\r\nsect_info->run_addr +\r\ndlthis->image_offset,\r\ndlthis->\r\ntramp.final_sym_table[cur_relo->\r\nSYMNDX].value);\r\n#endif\r\nfor (i = 0;\r\n((i < MAX_RELOS_PER_PASS) &&\r\n((i + relos_done) < cur_pkt->hdr.num_relos)); i++)\r\nrelos[i] = cur_relo + i;\r\nret_val = priv_pkt_relo(dlthis,\r\n(tgt_au_t *) &cur_pkt->payload,\r\nrelos, i);\r\nif (ret_val == 0) {\r\ndload_error(dlthis,\r\n"Relocation of trampoline pkt at %x"\r\n" failed", cur_pkt->base +\r\nsect_info->run_addr);\r\nbreak;\r\n}\r\nrelos_done += i;\r\ncur_relo += i;\r\n}\r\nif (ret_val != 0) {\r\nret_val = dlthis->myio->writemem(dlthis->myio,\r\n&cur_pkt->payload,\r\nsect_info->load_addr +\r\ncur_pkt->base,\r\nsect_info,\r\nBYTE_TO_HOST\r\n(cur_pkt->hdr.\r\ntramp_code_size));\r\nif (ret_val == 0) {\r\ndload_error(dlthis,\r\n"Write to " FMT_UI32 " failed",\r\nsect_info->load_addr +\r\ncur_pkt->base);\r\n}\r\ndlthis->mysym->dload_deallocate(dlthis->mysym, cur_pkt);\r\ncur_pkt = dlthis->tramp.tramp_pkts;\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int priv_dup_pkt_finalize(struct dload_state *dlthis)\r\n{\r\nint ret_val = 1;\r\nstruct tramp_img_dup_pkt *cur_pkt;\r\nstruct tramp_img_dup_relo *cur_relo;\r\nstruct reloc_record_t *relos[MAX_RELOS_PER_PASS];\r\nstruct doff_scnhdr_t *sect_hdr = NULL;\r\ns32 i;\r\ncur_pkt = dlthis->tramp.dup_pkts;\r\nwhile ((ret_val != 0) && (cur_pkt != NULL)) {\r\ndlthis->tramp.dup_pkts = cur_pkt->next;\r\ndlthis->image_secn = &dlthis->ldr_sections[cur_pkt->secnn];\r\ndlthis->image_offset = cur_pkt->offset;\r\ni = (s32) (dlthis->image_secn - dlthis->ldr_sections);\r\nsect_hdr = dlthis->sect_hdrs + i;\r\ndlthis->delta_runaddr = sect_hdr->ds_paddr;\r\ncur_relo = cur_pkt->relo_chain;\r\nwhile (cur_relo != NULL) {\r\nfor (i = 0; (i < MAX_RELOS_PER_PASS)\r\n&& (cur_relo != NULL);\r\ni++, cur_relo = cur_relo->next) {\r\nrelos[i] = &cur_relo->relo;\r\ncur_pkt->relo_chain = cur_relo->next;\r\n}\r\nret_val = priv_pkt_relo(dlthis,\r\ncur_pkt->img_pkt.img_data,\r\nrelos, i);\r\nif (ret_val == 0) {\r\ndload_error(dlthis,\r\n"Relocation of dup pkt at %x"\r\n" failed", cur_pkt->offset +\r\ndlthis->image_secn->run_addr);\r\nbreak;\r\n}\r\nwhile (i > 0) {\r\ndlthis->mysym->dload_deallocate(dlthis->mysym,\r\nGET_CONTAINER\r\n(relos[i - 1],\r\nstruct tramp_img_dup_relo,\r\nrelo));\r\ni--;\r\n}\r\n}\r\nif (ret_val != 0) {\r\nret_val = dlthis->myio->writemem(dlthis->myio,\r\ncur_pkt->img_pkt.\r\nimg_data,\r\ndlthis->image_secn->\r\nload_addr +\r\ncur_pkt->offset,\r\ndlthis->image_secn,\r\nBYTE_TO_HOST\r\n(cur_pkt->img_pkt.\r\npacket_size));\r\nif (ret_val == 0) {\r\ndload_error(dlthis,\r\n"Write to " FMT_UI32 " failed",\r\ndlthis->image_secn->load_addr +\r\ncur_pkt->offset);\r\n}\r\ndlthis->mysym->dload_deallocate(dlthis->mysym, cur_pkt);\r\ncur_pkt = dlthis->tramp.dup_pkts;\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic struct tramp_img_dup_pkt *priv_dup_find(struct dload_state *dlthis,\r\ns16 secnn, u32 image_offset)\r\n{\r\nstruct tramp_img_dup_pkt *cur_pkt = NULL;\r\nfor (cur_pkt = dlthis->tramp.dup_pkts;\r\ncur_pkt != NULL; cur_pkt = cur_pkt->next) {\r\nif ((cur_pkt->secnn == secnn) &&\r\n(cur_pkt->offset == image_offset)) {\r\nbreak;\r\n}\r\n}\r\nreturn cur_pkt;\r\n}\r\nstatic int priv_img_pkt_dup(struct dload_state *dlthis,\r\ns16 secnn, u32 image_offset,\r\nstruct image_packet_t *ipacket,\r\nstruct reloc_record_t *rp,\r\nstruct tramp_sym *new_tramp_sym)\r\n{\r\nstruct tramp_img_dup_pkt *dup_pkt = NULL;\r\nu32 new_dup_size;\r\ns32 i;\r\nint ret_val = 0;\r\nstruct tramp_img_dup_relo *dup_relo = NULL;\r\ndup_pkt = priv_dup_find(dlthis, secnn, image_offset);\r\nif (dup_pkt == NULL) {\r\nnew_dup_size = sizeof(struct tramp_img_dup_pkt) +\r\nipacket->packet_size;\r\ndup_pkt = (struct tramp_img_dup_pkt *)\r\ndlthis->mysym->dload_allocate(dlthis->mysym, new_dup_size);\r\nif (dup_pkt != NULL) {\r\ndup_pkt->secnn = secnn;\r\ndup_pkt->offset = image_offset;\r\ndup_pkt->relo_chain = NULL;\r\ndup_pkt->img_pkt = *ipacket;\r\ndup_pkt->img_pkt.img_data = (u8 *) (dup_pkt + 1);\r\nfor (i = 0; i < ipacket->packet_size; i++)\r\n*(dup_pkt->img_pkt.img_data + i) =\r\n*(ipacket->img_data + i);\r\ndup_pkt->next = dlthis->tramp.dup_pkts;\r\ndlthis->tramp.dup_pkts = dup_pkt;\r\n} else\r\ndload_error(dlthis, "Failed to create dup packet!");\r\n} else {\r\nfor (i = 0; i < dup_pkt->img_pkt.packet_size; i++)\r\n*(dup_pkt->img_pkt.img_data + i) =\r\n*(ipacket->img_data + i);\r\n}\r\nif (dup_pkt != NULL) {\r\ndup_relo = dlthis->mysym->dload_allocate(dlthis->mysym,\r\nsizeof(struct tramp_img_dup_relo));\r\nif (dup_relo != NULL) {\r\ndup_relo->relo = *rp;\r\ndup_relo->relo.SYMNDX = new_tramp_sym->index;\r\ndup_relo->next = dup_pkt->relo_chain;\r\ndup_pkt->relo_chain = dup_relo;\r\nret_val = 1;\r\n} else\r\ndload_error(dlthis, "Unable to alloc dup relo");\r\n}\r\nreturn ret_val;\r\n}\r\nbool dload_tramp_avail(struct dload_state *dlthis, struct reloc_record_t *rp)\r\n{\r\nbool ret_val = false;\r\nu16 map_index;\r\nu16 gen_index;\r\nmap_index = HASH_FUNC(rp->TYPE);\r\ngen_index = tramp_map[map_index];\r\nif (gen_index != TRAMP_NO_GEN_AVAIL)\r\nret_val = true;\r\nreturn ret_val;\r\n}\r\nint dload_tramp_generate(struct dload_state *dlthis, s16 secnn,\r\nu32 image_offset, struct image_packet_t *ipacket,\r\nstruct reloc_record_t *rp)\r\n{\r\nu16 map_index;\r\nu16 gen_index;\r\nint ret_val = 1;\r\nchar tramp_sym_str[TRAMP_SYM_PREFIX_LEN + TRAMP_SYM_HEX_ASCII_LEN];\r\nstruct local_symbol *ref_sym;\r\nstruct tramp_sym *new_tramp_sym;\r\nstruct tramp_sym *new_ext_sym;\r\nstruct tramp_string *new_tramp_str;\r\nu32 new_tramp_base;\r\nstruct local_symbol tmp_sym;\r\nstruct local_symbol ext_tmp_sym;\r\nmap_index = HASH_FUNC(rp->TYPE);\r\ngen_index = tramp_map[map_index];\r\nif (gen_index != TRAMP_NO_GEN_AVAIL) {\r\nif (dlthis->tramp.string_head == NULL) {\r\npriv_tramp_string_create(dlthis,\r\nstrlen(TRAMP_SECT_NAME),\r\nTRAMP_SECT_NAME);\r\n}\r\n#ifdef ENABLE_TRAMP_DEBUG\r\ndload_syms_error(dlthis->mysym,\r\n"Trampoline at img loc %x, references %x",\r\ndlthis->ldr_sections[secnn].run_addr +\r\nimage_offset + rp->vaddr,\r\ndlthis->local_symtab[rp->SYMNDX].value);\r\n#endif\r\nif (rp->SYMNDX == -1) {\r\next_tmp_sym.value =\r\ndlthis->ldr_sections[secnn].run_addr;\r\next_tmp_sym.delta = dlthis->sect_hdrs[secnn].ds_paddr;\r\nref_sym = &ext_tmp_sym;\r\n} else\r\nref_sym = &(dlthis->local_symtab[rp->SYMNDX]);\r\npriv_tramp_sym_gen_name(ref_sym->value, tramp_sym_str);\r\nnew_tramp_sym = priv_tramp_sym_find(dlthis, tramp_sym_str);\r\nif (new_tramp_sym == NULL) {\r\nnew_tramp_str = priv_tramp_string_create(dlthis,\r\nstrlen\r\n(tramp_sym_str),\r\ntramp_sym_str);\r\nif (new_tramp_str == NULL) {\r\ndload_error(dlthis, "Failed to create new "\r\n"trampoline string\n");\r\nret_val = 0;\r\n} else {\r\nnew_tramp_base = priv_tramp_sect_alloc(dlthis,\r\ntramp_size_get());\r\ntmp_sym.value = new_tramp_base;\r\ntmp_sym.delta = 0;\r\ntmp_sym.secnn = -1;\r\ntmp_sym.sclass = 0;\r\nnew_tramp_sym = priv_tramp_sym_create(dlthis,\r\nnew_tramp_str->\r\nindex,\r\n&tmp_sym);\r\nnew_ext_sym = priv_tramp_sym_create(dlthis, -1,\r\nref_sym);\r\nif ((new_tramp_sym != NULL) &&\r\n(new_ext_sym != NULL)) {\r\nret_val = priv_tgt_img_gen(dlthis,\r\nnew_tramp_base,\r\ngen_index,\r\nnew_ext_sym);\r\nif (ret_val != 1) {\r\ndload_error(dlthis, "Failed to "\r\n"create img pkt for"\r\n" trampoline\n");\r\n}\r\n} else {\r\ndload_error(dlthis, "Failed to create "\r\n"new tramp syms "\r\n"(%8.8X, %8.8X)\n",\r\nnew_tramp_sym, new_ext_sym);\r\nret_val = 0;\r\n}\r\n}\r\n}\r\nif (ret_val == 1) {\r\nret_val = priv_img_pkt_dup(dlthis, secnn, image_offset,\r\nipacket, rp, new_tramp_sym);\r\nif (ret_val != 1) {\r\ndload_error(dlthis, "Failed to create dup of "\r\n"original img pkt\n");\r\n}\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nint dload_tramp_pkt_udpate(struct dload_state *dlthis, s16 secnn,\r\nu32 image_offset, struct image_packet_t *ipacket)\r\n{\r\nstruct tramp_img_dup_pkt *dup_pkt = NULL;\r\ns32 i;\r\nint ret_val = 0;\r\ndup_pkt = priv_dup_find(dlthis, secnn, image_offset);\r\nif (dup_pkt != NULL) {\r\nfor (i = 0; i < dup_pkt->img_pkt.packet_size; i++)\r\n*(dup_pkt->img_pkt.img_data + i) =\r\n*(ipacket->img_data + i);\r\nret_val = 1;\r\n} else {\r\ndload_error(dlthis,\r\n"Unable to find existing DUP pkt for %x, offset %x",\r\nsecnn, image_offset);\r\n}\r\nreturn ret_val;\r\n}\r\nint dload_tramp_finalize(struct dload_state *dlthis)\r\n{\r\nint ret_val = 1;\r\nif (dlthis->tramp.tramp_sect_next_addr != 0) {\r\nret_val = priv_string_tbl_finalize(dlthis);\r\nif (ret_val != 0)\r\nret_val = priv_tramp_sect_tgt_alloc(dlthis);\r\nif (ret_val != 0)\r\nret_val = priv_tramp_sym_finalize(dlthis);\r\nif (ret_val != 0)\r\nret_val = priv_tramp_pkt_finalize(dlthis);\r\nif (ret_val != 0)\r\nret_val = priv_dup_pkt_finalize(dlthis);\r\n}\r\nreturn ret_val;\r\n}\r\nvoid dload_tramp_cleanup(struct dload_state *dlthis)\r\n{\r\nstruct tramp_info *tramp = &dlthis->tramp;\r\nstruct tramp_sym *cur_sym;\r\nstruct tramp_string *cur_string;\r\nstruct tramp_img_pkt *cur_tramp_pkt;\r\nstruct tramp_img_dup_pkt *cur_dup_pkt;\r\nstruct tramp_img_dup_relo *cur_dup_relo;\r\nif (tramp->tramp_sect_next_addr == 0)\r\nreturn;\r\nfor (cur_sym = tramp->symbol_head;\r\ncur_sym != NULL; cur_sym = tramp->symbol_head) {\r\ntramp->symbol_head = cur_sym->next;\r\nif (tramp->symbol_tail == cur_sym)\r\ntramp->symbol_tail = NULL;\r\ndlthis->mysym->dload_deallocate(dlthis->mysym, cur_sym);\r\n}\r\nif (tramp->final_sym_table != NULL)\r\ndlthis->mysym->dload_deallocate(dlthis->mysym,\r\ntramp->final_sym_table);\r\nfor (cur_string = tramp->string_head;\r\ncur_string != NULL; cur_string = tramp->string_head) {\r\ntramp->string_head = cur_string->next;\r\nif (tramp->string_tail == cur_string)\r\ntramp->string_tail = NULL;\r\ndlthis->mysym->dload_deallocate(dlthis->mysym, cur_string);\r\n}\r\nif (tramp->final_string_table != NULL)\r\ndlthis->mysym->dload_deallocate(dlthis->mysym,\r\ntramp->final_string_table);\r\nfor (cur_tramp_pkt = tramp->tramp_pkts;\r\ncur_tramp_pkt != NULL; cur_tramp_pkt = tramp->tramp_pkts) {\r\ntramp->tramp_pkts = cur_tramp_pkt->next;\r\ndlthis->mysym->dload_deallocate(dlthis->mysym, cur_tramp_pkt);\r\n}\r\nfor (cur_dup_pkt = tramp->dup_pkts;\r\ncur_dup_pkt != NULL; cur_dup_pkt = tramp->dup_pkts) {\r\ntramp->dup_pkts = cur_dup_pkt->next;\r\nfor (cur_dup_relo = cur_dup_pkt->relo_chain;\r\ncur_dup_relo != NULL;\r\ncur_dup_relo = cur_dup_pkt->relo_chain) {\r\ncur_dup_pkt->relo_chain = cur_dup_relo->next;\r\ndlthis->mysym->dload_deallocate(dlthis->mysym,\r\ncur_dup_relo);\r\n}\r\ndlthis->mysym->dload_deallocate(dlthis->mysym, cur_dup_pkt);\r\n}\r\n}
