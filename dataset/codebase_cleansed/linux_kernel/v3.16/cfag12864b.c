unsigned int cfag12864b_getrate(void)\r\n{\r\nreturn cfag12864b_rate;\r\n}\r\nstatic void cfag12864b_set(void)\r\n{\r\nks0108_writecontrol(cfag12864b_state);\r\n}\r\nstatic void cfag12864b_setbit(unsigned char state, unsigned char n)\r\n{\r\nif (state)\r\ncfag12864b_state |= bit(n);\r\nelse\r\ncfag12864b_state &= ~bit(n);\r\n}\r\nstatic void cfag12864b_e(unsigned char state)\r\n{\r\ncfag12864b_setbit(state, CFAG12864B_BIT_E);\r\ncfag12864b_set();\r\n}\r\nstatic void cfag12864b_cs1(unsigned char state)\r\n{\r\ncfag12864b_setbit(state, CFAG12864B_BIT_CS1);\r\n}\r\nstatic void cfag12864b_cs2(unsigned char state)\r\n{\r\ncfag12864b_setbit(state, CFAG12864B_BIT_CS2);\r\n}\r\nstatic void cfag12864b_di(unsigned char state)\r\n{\r\ncfag12864b_setbit(state, CFAG12864B_BIT_DI);\r\n}\r\nstatic void cfag12864b_setcontrollers(unsigned char first,\r\nunsigned char second)\r\n{\r\nif (first)\r\ncfag12864b_cs1(0);\r\nelse\r\ncfag12864b_cs1(1);\r\nif (second)\r\ncfag12864b_cs2(0);\r\nelse\r\ncfag12864b_cs2(1);\r\n}\r\nstatic void cfag12864b_controller(unsigned char which)\r\n{\r\nif (which == 0)\r\ncfag12864b_setcontrollers(1, 0);\r\nelse if (which == 1)\r\ncfag12864b_setcontrollers(0, 1);\r\n}\r\nstatic void cfag12864b_displaystate(unsigned char state)\r\n{\r\ncfag12864b_di(0);\r\ncfag12864b_e(1);\r\nks0108_displaystate(state);\r\ncfag12864b_e(0);\r\n}\r\nstatic void cfag12864b_address(unsigned char address)\r\n{\r\ncfag12864b_di(0);\r\ncfag12864b_e(1);\r\nks0108_address(address);\r\ncfag12864b_e(0);\r\n}\r\nstatic void cfag12864b_page(unsigned char page)\r\n{\r\ncfag12864b_di(0);\r\ncfag12864b_e(1);\r\nks0108_page(page);\r\ncfag12864b_e(0);\r\n}\r\nstatic void cfag12864b_startline(unsigned char startline)\r\n{\r\ncfag12864b_di(0);\r\ncfag12864b_e(1);\r\nks0108_startline(startline);\r\ncfag12864b_e(0);\r\n}\r\nstatic void cfag12864b_writebyte(unsigned char byte)\r\n{\r\ncfag12864b_di(1);\r\ncfag12864b_e(1);\r\nks0108_writedata(byte);\r\ncfag12864b_e(0);\r\n}\r\nstatic void cfag12864b_nop(void)\r\n{\r\ncfag12864b_startline(0);\r\n}\r\nstatic void cfag12864b_on(void)\r\n{\r\ncfag12864b_setcontrollers(1, 1);\r\ncfag12864b_displaystate(1);\r\n}\r\nstatic void cfag12864b_off(void)\r\n{\r\ncfag12864b_setcontrollers(1, 1);\r\ncfag12864b_displaystate(0);\r\n}\r\nstatic void cfag12864b_clear(void)\r\n{\r\nunsigned char i, j;\r\ncfag12864b_setcontrollers(1, 1);\r\nfor (i = 0; i < CFAG12864B_PAGES; i++) {\r\ncfag12864b_page(i);\r\ncfag12864b_address(0);\r\nfor (j = 0; j < CFAG12864B_ADDRESSES; j++)\r\ncfag12864b_writebyte(0);\r\n}\r\n}\r\nstatic void cfag12864b_queue(void)\r\n{\r\nqueue_delayed_work(cfag12864b_workqueue, &cfag12864b_work,\r\nHZ / cfag12864b_rate);\r\n}\r\nunsigned char cfag12864b_enable(void)\r\n{\r\nunsigned char ret;\r\nmutex_lock(&cfag12864b_mutex);\r\nif (!cfag12864b_updating) {\r\ncfag12864b_updating = 1;\r\ncfag12864b_queue();\r\nret = 0;\r\n} else\r\nret = 1;\r\nmutex_unlock(&cfag12864b_mutex);\r\nreturn ret;\r\n}\r\nvoid cfag12864b_disable(void)\r\n{\r\nmutex_lock(&cfag12864b_mutex);\r\nif (cfag12864b_updating) {\r\ncfag12864b_updating = 0;\r\ncancel_delayed_work(&cfag12864b_work);\r\nflush_workqueue(cfag12864b_workqueue);\r\n}\r\nmutex_unlock(&cfag12864b_mutex);\r\n}\r\nunsigned char cfag12864b_isenabled(void)\r\n{\r\nreturn cfag12864b_updating;\r\n}\r\nstatic void cfag12864b_update(struct work_struct *work)\r\n{\r\nunsigned char c;\r\nunsigned short i, j, k, b;\r\nif (memcmp(cfag12864b_cache, cfag12864b_buffer, CFAG12864B_SIZE)) {\r\nfor (i = 0; i < CFAG12864B_CONTROLLERS; i++) {\r\ncfag12864b_controller(i);\r\ncfag12864b_nop();\r\nfor (j = 0; j < CFAG12864B_PAGES; j++) {\r\ncfag12864b_page(j);\r\ncfag12864b_nop();\r\ncfag12864b_address(0);\r\ncfag12864b_nop();\r\nfor (k = 0; k < CFAG12864B_ADDRESSES; k++) {\r\nfor (c = 0, b = 0; b < 8; b++)\r\nif (cfag12864b_buffer\r\n[i * CFAG12864B_ADDRESSES / 8\r\n+ k / 8 + (j * 8 + b) *\r\nCFAG12864B_WIDTH / 8]\r\n& bit(k % 8))\r\nc |= bit(b);\r\ncfag12864b_writebyte(c);\r\n}\r\n}\r\n}\r\nmemcpy(cfag12864b_cache, cfag12864b_buffer, CFAG12864B_SIZE);\r\n}\r\nif (cfag12864b_updating)\r\ncfag12864b_queue();\r\n}\r\nunsigned char cfag12864b_isinited(void)\r\n{\r\nreturn cfag12864b_inited;\r\n}\r\nstatic int __init cfag12864b_init(void)\r\n{\r\nint ret = -EINVAL;\r\nif (!ks0108_isinited()) {\r\nprintk(KERN_ERR CFAG12864B_NAME ": ERROR: "\r\n"ks0108 is not initialized\n");\r\ngoto none;\r\n}\r\nBUILD_BUG_ON(PAGE_SIZE < CFAG12864B_SIZE);\r\ncfag12864b_buffer = (unsigned char *) get_zeroed_page(GFP_KERNEL);\r\nif (cfag12864b_buffer == NULL) {\r\nprintk(KERN_ERR CFAG12864B_NAME ": ERROR: "\r\n"can't get a free page\n");\r\nret = -ENOMEM;\r\ngoto none;\r\n}\r\ncfag12864b_cache = kmalloc(sizeof(unsigned char) *\r\nCFAG12864B_SIZE, GFP_KERNEL);\r\nif (cfag12864b_cache == NULL) {\r\nprintk(KERN_ERR CFAG12864B_NAME ": ERROR: "\r\n"can't alloc cache buffer (%i bytes)\n",\r\nCFAG12864B_SIZE);\r\nret = -ENOMEM;\r\ngoto bufferalloced;\r\n}\r\ncfag12864b_workqueue = create_singlethread_workqueue(CFAG12864B_NAME);\r\nif (cfag12864b_workqueue == NULL)\r\ngoto cachealloced;\r\ncfag12864b_clear();\r\ncfag12864b_on();\r\ncfag12864b_inited = 1;\r\nreturn 0;\r\ncachealloced:\r\nkfree(cfag12864b_cache);\r\nbufferalloced:\r\nfree_page((unsigned long) cfag12864b_buffer);\r\nnone:\r\nreturn ret;\r\n}\r\nstatic void __exit cfag12864b_exit(void)\r\n{\r\ncfag12864b_disable();\r\ncfag12864b_off();\r\ndestroy_workqueue(cfag12864b_workqueue);\r\nkfree(cfag12864b_cache);\r\nfree_page((unsigned long) cfag12864b_buffer);\r\n}
