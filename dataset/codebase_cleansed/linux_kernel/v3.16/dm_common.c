void dm_restorepowerindex(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 index;\r\nfor (index = 0; index < 6; index++)\r\nrtl_write_byte(rtlpriv, power_index_reg[index],\r\nrtlpriv->dm.powerindex_backup[index]);\r\n}\r\nvoid dm_writepowerindex(struct ieee80211_hw *hw, u8 value)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 index;\r\nfor (index = 0; index < 6; index++)\r\nrtl_write_byte(rtlpriv, power_index_reg[index], value);\r\n}\r\nvoid dm_savepowerindex(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 index;\r\nu8 tmp;\r\nfor (index = 0; index < 6; index++) {\r\ntmp = rtl_read_byte(rtlpriv, power_index_reg[index]);\r\nrtlpriv->dm.powerindex_backup[index] = tmp;\r\n}\r\n}\r\nstatic void rtl92c_dm_diginit(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\r\ndm_digtable->dig_enable_flag = true;\r\ndm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;\r\ndm_digtable->cur_igvalue = 0x20;\r\ndm_digtable->pre_igvalue = 0x0;\r\ndm_digtable->cursta_cstate = DIG_STA_DISCONNECT;\r\ndm_digtable->presta_cstate = DIG_STA_DISCONNECT;\r\ndm_digtable->curmultista_cstate = DIG_MULTISTA_DISCONNECT;\r\ndm_digtable->rssi_lowthresh = DM_DIG_THRESH_LOW;\r\ndm_digtable->rssi_highthresh = DM_DIG_THRESH_HIGH;\r\ndm_digtable->fa_lowthresh = DM_FALSEALARM_THRESH_LOW;\r\ndm_digtable->fa_highthresh = DM_FALSEALARM_THRESH_HIGH;\r\ndm_digtable->rx_gain_max = DM_DIG_MAX;\r\ndm_digtable->rx_gain_min = DM_DIG_MIN;\r\ndm_digtable->back_val = DM_DIG_BACKOFF_DEFAULT;\r\ndm_digtable->back_range_max = DM_DIG_BACKOFF_MAX;\r\ndm_digtable->back_range_min = DM_DIG_BACKOFF_MIN;\r\ndm_digtable->pre_cck_pd_state = CCK_PD_STAGE_MAX;\r\ndm_digtable->cur_cck_pd_state = CCK_PD_STAGE_LowRssi;\r\ndm_digtable->forbidden_igi = DM_DIG_MIN;\r\ndm_digtable->large_fa_hit = 0;\r\ndm_digtable->recover_cnt = 0;\r\ndm_digtable->dig_dynamic_min = 0x25;\r\n}\r\nstatic u8 rtl92c_dm_initial_gain_min_pwdb(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\r\nlong rssi_val_min = 0;\r\nif ((dm_digtable->curmultista_cstate == DIG_MULTISTA_CONNECT) &&\r\n(dm_digtable->cursta_cstate == DIG_STA_CONNECT)) {\r\nif (rtlpriv->dm.entry_min_undec_sm_pwdb != 0)\r\nrssi_val_min =\r\n(rtlpriv->dm.entry_min_undec_sm_pwdb >\r\nrtlpriv->dm.undec_sm_pwdb) ?\r\nrtlpriv->dm.undec_sm_pwdb :\r\nrtlpriv->dm.entry_min_undec_sm_pwdb;\r\nelse\r\nrssi_val_min = rtlpriv->dm.undec_sm_pwdb;\r\n} else if (dm_digtable->cursta_cstate == DIG_STA_CONNECT ||\r\ndm_digtable->cursta_cstate == DIG_STA_BEFORE_CONNECT) {\r\nrssi_val_min = rtlpriv->dm.undec_sm_pwdb;\r\n} else if (dm_digtable->curmultista_cstate == DIG_MULTISTA_CONNECT) {\r\nrssi_val_min = rtlpriv->dm.entry_min_undec_sm_pwdb;\r\n}\r\nif (rssi_val_min > 100)\r\nrssi_val_min = 100;\r\nreturn (u8)rssi_val_min;\r\n}\r\nstatic void rtl92c_dm_false_alarm_counter_statistics(struct ieee80211_hw *hw)\r\n{\r\nu32 ret_value;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct false_alarm_statistics *falsealm_cnt = &(rtlpriv->falsealm_cnt);\r\nret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER1, MASKDWORD);\r\nfalsealm_cnt->cnt_parity_fail = ((ret_value & 0xffff0000) >> 16);\r\nret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER2, MASKDWORD);\r\nfalsealm_cnt->cnt_rate_illegal = (ret_value & 0xffff);\r\nfalsealm_cnt->cnt_crc8_fail = ((ret_value & 0xffff0000) >> 16);\r\nret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER3, MASKDWORD);\r\nfalsealm_cnt->cnt_mcs_fail = (ret_value & 0xffff);\r\nret_value = rtl_get_bbreg(hw, ROFDM0_FRAMESYNC, MASKDWORD);\r\nfalsealm_cnt->cnt_fast_fsync_fail = (ret_value & 0xffff);\r\nfalsealm_cnt->cnt_sb_search_fail = ((ret_value & 0xffff0000) >> 16);\r\nfalsealm_cnt->cnt_ofdm_fail = falsealm_cnt->cnt_parity_fail +\r\nfalsealm_cnt->cnt_rate_illegal +\r\nfalsealm_cnt->cnt_crc8_fail +\r\nfalsealm_cnt->cnt_mcs_fail +\r\nfalsealm_cnt->cnt_fast_fsync_fail +\r\nfalsealm_cnt->cnt_sb_search_fail;\r\nrtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, BIT(14), 1);\r\nret_value = rtl_get_bbreg(hw, RCCK0_FACOUNTERLOWER, MASKBYTE0);\r\nfalsealm_cnt->cnt_cck_fail = ret_value;\r\nret_value = rtl_get_bbreg(hw, RCCK0_FACOUNTERUPPER, MASKBYTE3);\r\nfalsealm_cnt->cnt_cck_fail += (ret_value & 0xff) << 8;\r\nfalsealm_cnt->cnt_all = (falsealm_cnt->cnt_parity_fail +\r\nfalsealm_cnt->cnt_rate_illegal +\r\nfalsealm_cnt->cnt_crc8_fail +\r\nfalsealm_cnt->cnt_mcs_fail +\r\nfalsealm_cnt->cnt_cck_fail);\r\nrtl_set_bbreg(hw, ROFDM1_LSTF, 0x08000000, 1);\r\nrtl_set_bbreg(hw, ROFDM1_LSTF, 0x08000000, 0);\r\nrtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, 0x0000c000, 0);\r\nrtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, 0x0000c000, 2);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_TRACE,\r\n"cnt_parity_fail = %d, cnt_rate_illegal = %d, cnt_crc8_fail = %d, cnt_mcs_fail = %d\n",\r\nfalsealm_cnt->cnt_parity_fail,\r\nfalsealm_cnt->cnt_rate_illegal,\r\nfalsealm_cnt->cnt_crc8_fail, falsealm_cnt->cnt_mcs_fail);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_TRACE,\r\n"cnt_ofdm_fail = %x, cnt_cck_fail = %x, cnt_all = %x\n",\r\nfalsealm_cnt->cnt_ofdm_fail,\r\nfalsealm_cnt->cnt_cck_fail, falsealm_cnt->cnt_all);\r\n}\r\nstatic void rtl92c_dm_ctrl_initgain_by_fa(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\r\nu8 value_igi = dm_digtable->cur_igvalue;\r\nif (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH0)\r\nvalue_igi--;\r\nelse if (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH1)\r\nvalue_igi += 0;\r\nelse if (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH2)\r\nvalue_igi++;\r\nelse if (rtlpriv->falsealm_cnt.cnt_all >= DM_DIG_FA_TH2)\r\nvalue_igi += 2;\r\nif (value_igi > DM_DIG_FA_UPPER)\r\nvalue_igi = DM_DIG_FA_UPPER;\r\nelse if (value_igi < DM_DIG_FA_LOWER)\r\nvalue_igi = DM_DIG_FA_LOWER;\r\nif (rtlpriv->falsealm_cnt.cnt_all > 10000)\r\nvalue_igi = DM_DIG_FA_UPPER;\r\ndm_digtable->cur_igvalue = value_igi;\r\nrtl92c_dm_write_dig(hw);\r\n}\r\nstatic void rtl92c_dm_ctrl_initgain_by_rssi(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *digtable = &rtlpriv->dm_digtable;\r\nu32 isbt;\r\nif (rtlpriv->falsealm_cnt.cnt_all > 10000) {\r\ndigtable->large_fa_hit++;\r\nif (digtable->forbidden_igi < digtable->cur_igvalue) {\r\ndigtable->forbidden_igi = digtable->cur_igvalue;\r\ndigtable->large_fa_hit = 1;\r\n}\r\nif (digtable->large_fa_hit >= 3) {\r\nif ((digtable->forbidden_igi + 1) >\r\ndigtable->rx_gain_max)\r\ndigtable->rx_gain_min = digtable->rx_gain_max;\r\nelse\r\ndigtable->rx_gain_min = (digtable->forbidden_igi + 1);\r\ndigtable->recover_cnt = 3600;\r\n}\r\n} else {\r\nif (digtable->recover_cnt != 0) {\r\ndigtable->recover_cnt--;\r\n} else {\r\nif (digtable->large_fa_hit == 0) {\r\nif ((digtable->forbidden_igi-1) < DM_DIG_MIN) {\r\ndigtable->forbidden_igi = DM_DIG_MIN;\r\ndigtable->rx_gain_min = DM_DIG_MIN;\r\n} else {\r\ndigtable->forbidden_igi--;\r\ndigtable->rx_gain_min = digtable->forbidden_igi + 1;\r\n}\r\n} else if (digtable->large_fa_hit == 3) {\r\ndigtable->large_fa_hit = 0;\r\n}\r\n}\r\n}\r\nif (rtlpriv->falsealm_cnt.cnt_all < 250) {\r\nisbt = rtl_read_byte(rtlpriv, 0x4fd) & 0x01;\r\nif (!isbt) {\r\nif (rtlpriv->falsealm_cnt.cnt_all >\r\ndigtable->fa_lowthresh) {\r\nif ((digtable->back_val - 2) <\r\ndigtable->back_range_min)\r\ndigtable->back_val = digtable->back_range_min;\r\nelse\r\ndigtable->back_val -= 2;\r\n} else if (rtlpriv->falsealm_cnt.cnt_all <\r\ndigtable->fa_lowthresh) {\r\nif ((digtable->back_val + 2) >\r\ndigtable->back_range_max)\r\ndigtable->back_val = digtable->back_range_max;\r\nelse\r\ndigtable->back_val += 2;\r\n}\r\n} else {\r\ndigtable->back_val = DM_DIG_BACKOFF_DEFAULT;\r\n}\r\n} else {\r\nif (rtlpriv->falsealm_cnt.cnt_all > 1000)\r\ndigtable->cur_igvalue = digtable->pre_igvalue + 2;\r\nelse if (rtlpriv->falsealm_cnt.cnt_all > 750)\r\ndigtable->cur_igvalue = digtable->pre_igvalue + 1;\r\nelse if (rtlpriv->falsealm_cnt.cnt_all < 500)\r\ndigtable->cur_igvalue = digtable->pre_igvalue - 1;\r\n}\r\nif (digtable->cur_igvalue > digtable->rx_gain_max)\r\ndigtable->cur_igvalue = digtable->rx_gain_max;\r\nif (digtable->cur_igvalue < digtable->rx_gain_min)\r\ndigtable->cur_igvalue = digtable->rx_gain_min;\r\nrtl92c_dm_write_dig(hw);\r\n}\r\nstatic void rtl92c_dm_initial_gain_multi_sta(struct ieee80211_hw *hw)\r\n{\r\nstatic u8 initialized;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nlong rssi_strength = rtlpriv->dm.entry_min_undec_sm_pwdb;\r\nbool multi_sta = false;\r\nif (mac->opmode == NL80211_IFTYPE_ADHOC)\r\nmulti_sta = true;\r\nif (!multi_sta ||\r\ndm_digtable->cursta_cstate == DIG_STA_DISCONNECT) {\r\ninitialized = false;\r\ndm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;\r\nreturn;\r\n} else if (initialized == false) {\r\ninitialized = true;\r\ndm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_0;\r\ndm_digtable->cur_igvalue = 0x20;\r\nrtl92c_dm_write_dig(hw);\r\n}\r\nif (dm_digtable->curmultista_cstate == DIG_MULTISTA_CONNECT) {\r\nif ((rssi_strength < dm_digtable->rssi_lowthresh) &&\r\n(dm_digtable->dig_ext_port_stage != DIG_EXT_PORT_STAGE_1)) {\r\nif (dm_digtable->dig_ext_port_stage ==\r\nDIG_EXT_PORT_STAGE_2) {\r\ndm_digtable->cur_igvalue = 0x20;\r\nrtl92c_dm_write_dig(hw);\r\n}\r\ndm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_1;\r\n} else if (rssi_strength > dm_digtable->rssi_highthresh) {\r\ndm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_2;\r\nrtl92c_dm_ctrl_initgain_by_fa(hw);\r\n}\r\n} else if (dm_digtable->dig_ext_port_stage != DIG_EXT_PORT_STAGE_0) {\r\ndm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_0;\r\ndm_digtable->cur_igvalue = 0x20;\r\nrtl92c_dm_write_dig(hw);\r\n}\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_TRACE,\r\n"curmultista_cstate = %x dig_ext_port_stage %x\n",\r\ndm_digtable->curmultista_cstate,\r\ndm_digtable->dig_ext_port_stage);\r\n}\r\nstatic void rtl92c_dm_initial_gain_sta(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_TRACE,\r\n"presta_cstate = %x, cursta_cstate = %x\n",\r\ndm_digtable->presta_cstate, dm_digtable->cursta_cstate);\r\nif (dm_digtable->presta_cstate == dm_digtable->cursta_cstate ||\r\ndm_digtable->cursta_cstate == DIG_STA_BEFORE_CONNECT ||\r\ndm_digtable->cursta_cstate == DIG_STA_CONNECT) {\r\nif (dm_digtable->cursta_cstate != DIG_STA_DISCONNECT) {\r\ndm_digtable->rssi_val_min =\r\nrtl92c_dm_initial_gain_min_pwdb(hw);\r\nif (dm_digtable->rssi_val_min > 100)\r\ndm_digtable->rssi_val_min = 100;\r\nrtl92c_dm_ctrl_initgain_by_rssi(hw);\r\n}\r\n} else {\r\ndm_digtable->rssi_val_min = 0;\r\ndm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;\r\ndm_digtable->back_val = DM_DIG_BACKOFF_DEFAULT;\r\ndm_digtable->cur_igvalue = 0x20;\r\ndm_digtable->pre_igvalue = 0;\r\nrtl92c_dm_write_dig(hw);\r\n}\r\n}\r\nstatic void rtl92c_dm_cck_packet_detection_thresh(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\r\nif (dm_digtable->cursta_cstate == DIG_STA_CONNECT) {\r\ndm_digtable->rssi_val_min = rtl92c_dm_initial_gain_min_pwdb(hw);\r\nif (dm_digtable->rssi_val_min > 100)\r\ndm_digtable->rssi_val_min = 100;\r\nif (dm_digtable->pre_cck_pd_state == CCK_PD_STAGE_LowRssi) {\r\nif (dm_digtable->rssi_val_min <= 25)\r\ndm_digtable->cur_cck_pd_state =\r\nCCK_PD_STAGE_LowRssi;\r\nelse\r\ndm_digtable->cur_cck_pd_state =\r\nCCK_PD_STAGE_HighRssi;\r\n} else {\r\nif (dm_digtable->rssi_val_min <= 20)\r\ndm_digtable->cur_cck_pd_state =\r\nCCK_PD_STAGE_LowRssi;\r\nelse\r\ndm_digtable->cur_cck_pd_state =\r\nCCK_PD_STAGE_HighRssi;\r\n}\r\n} else {\r\ndm_digtable->cur_cck_pd_state = CCK_PD_STAGE_MAX;\r\n}\r\nif (dm_digtable->pre_cck_pd_state != dm_digtable->cur_cck_pd_state) {\r\nif ((dm_digtable->cur_cck_pd_state == CCK_PD_STAGE_LowRssi) ||\r\n(dm_digtable->cur_cck_pd_state == CCK_PD_STAGE_MAX))\r\nrtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0x83);\r\nelse\r\nrtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0xcd);\r\ndm_digtable->pre_cck_pd_state = dm_digtable->cur_cck_pd_state;\r\n}\r\n}\r\nstatic void rtl92c_dm_ctrl_initgain_by_twoport(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nif (mac->act_scanning)\r\nreturn;\r\nif (mac->link_state >= MAC80211_LINKED)\r\ndm_digtable->cursta_cstate = DIG_STA_CONNECT;\r\nelse\r\ndm_digtable->cursta_cstate = DIG_STA_DISCONNECT;\r\ndm_digtable->curmultista_cstate = DIG_MULTISTA_DISCONNECT;\r\nrtl92c_dm_initial_gain_sta(hw);\r\nrtl92c_dm_initial_gain_multi_sta(hw);\r\nrtl92c_dm_cck_packet_detection_thresh(hw);\r\ndm_digtable->presta_cstate = dm_digtable->cursta_cstate;\r\n}\r\nstatic void rtl92c_dm_dig(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (rtlpriv->dm.dm_initialgain_enable == false)\r\nreturn;\r\nif (!(rtlpriv->dm.dm_flag & DYNAMIC_FUNC_DIG))\r\nreturn;\r\nrtl92c_dm_ctrl_initgain_by_twoport(hw);\r\n}\r\nstatic void rtl92c_dm_init_dynamic_txpower(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (rtlpriv->rtlhal.interface == INTF_USB &&\r\nrtlpriv->rtlhal.board_type & 0x1) {\r\ndm_savepowerindex(hw);\r\nrtlpriv->dm.dynamic_txpower_enable = true;\r\n} else {\r\nrtlpriv->dm.dynamic_txpower_enable = false;\r\n}\r\nrtlpriv->dm.last_dtp_lvl = TXHIGHPWRLEVEL_NORMAL;\r\nrtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\r\n}\r\nvoid rtl92c_dm_write_dig(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"cur_igvalue = 0x%x, pre_igvalue = 0x%x, back_val = %d\n",\r\ndm_digtable->cur_igvalue, dm_digtable->pre_igvalue,\r\ndm_digtable->back_val);\r\nif (rtlpriv->rtlhal.interface == INTF_USB &&\r\n!dm_digtable->dig_enable_flag) {\r\ndm_digtable->pre_igvalue = 0x17;\r\nreturn;\r\n}\r\ndm_digtable->cur_igvalue -= 1;\r\nif (dm_digtable->cur_igvalue < DM_DIG_MIN)\r\ndm_digtable->cur_igvalue = DM_DIG_MIN;\r\nif (dm_digtable->pre_igvalue != dm_digtable->cur_igvalue) {\r\nrtl_set_bbreg(hw, ROFDM0_XAAGCCORE1, 0x7f,\r\ndm_digtable->cur_igvalue);\r\nrtl_set_bbreg(hw, ROFDM0_XBAGCCORE1, 0x7f,\r\ndm_digtable->cur_igvalue);\r\ndm_digtable->pre_igvalue = dm_digtable->cur_igvalue;\r\n}\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_WARNING,\r\n"dig values 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",\r\ndm_digtable->cur_igvalue, dm_digtable->pre_igvalue,\r\ndm_digtable->rssi_val_min, dm_digtable->back_val,\r\ndm_digtable->rx_gain_max, dm_digtable->rx_gain_min,\r\ndm_digtable->large_fa_hit, dm_digtable->forbidden_igi);\r\n}\r\nstatic void rtl92c_dm_pwdb_monitor(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nlong tmpentry_max_pwdb = 0, tmpentry_min_pwdb = 0xff;\r\nif (mac->link_state != MAC80211_LINKED)\r\nreturn;\r\nif (mac->opmode == NL80211_IFTYPE_ADHOC ||\r\nmac->opmode == NL80211_IFTYPE_AP) {\r\n}\r\nif (tmpentry_max_pwdb != 0)\r\nrtlpriv->dm.entry_max_undec_sm_pwdb = tmpentry_max_pwdb;\r\nelse\r\nrtlpriv->dm.entry_max_undec_sm_pwdb = 0;\r\nif (tmpentry_min_pwdb != 0xff)\r\nrtlpriv->dm.entry_min_undec_sm_pwdb = tmpentry_min_pwdb;\r\nelse\r\nrtlpriv->dm.entry_min_undec_sm_pwdb = 0;\r\n}\r\nvoid rtl92c_dm_init_edca_turbo(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpriv->dm.current_turbo_edca = false;\r\nrtlpriv->dm.is_any_nonbepkts = false;\r\nrtlpriv->dm.is_cur_rdlstate = false;\r\n}\r\nstatic void rtl92c_dm_check_edca_turbo(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstatic u64 last_txok_cnt;\r\nstatic u64 last_rxok_cnt;\r\nstatic u32 last_bt_edca_ul;\r\nstatic u32 last_bt_edca_dl;\r\nu64 cur_txok_cnt = 0;\r\nu64 cur_rxok_cnt = 0;\r\nu32 edca_be_ul = 0x5ea42b;\r\nu32 edca_be_dl = 0x5ea42b;\r\nbool bt_change_edca = false;\r\nif ((last_bt_edca_ul != rtlpcipriv->bt_coexist.bt_edca_ul) ||\r\n(last_bt_edca_dl != rtlpcipriv->bt_coexist.bt_edca_dl)) {\r\nrtlpriv->dm.current_turbo_edca = false;\r\nlast_bt_edca_ul = rtlpcipriv->bt_coexist.bt_edca_ul;\r\nlast_bt_edca_dl = rtlpcipriv->bt_coexist.bt_edca_dl;\r\n}\r\nif (rtlpcipriv->bt_coexist.bt_edca_ul != 0) {\r\nedca_be_ul = rtlpcipriv->bt_coexist.bt_edca_ul;\r\nbt_change_edca = true;\r\n}\r\nif (rtlpcipriv->bt_coexist.bt_edca_dl != 0) {\r\nedca_be_ul = rtlpcipriv->bt_coexist.bt_edca_dl;\r\nbt_change_edca = true;\r\n}\r\nif (mac->link_state != MAC80211_LINKED) {\r\nrtlpriv->dm.current_turbo_edca = false;\r\nreturn;\r\n}\r\nif ((!mac->ht_enable) && (!rtlpcipriv->bt_coexist.bt_coexistence)) {\r\nif (!(edca_be_ul & 0xffff0000))\r\nedca_be_ul |= 0x005e0000;\r\nif (!(edca_be_dl & 0xffff0000))\r\nedca_be_dl |= 0x005e0000;\r\n}\r\nif ((bt_change_edca) || ((!rtlpriv->dm.is_any_nonbepkts) &&\r\n(!rtlpriv->dm.disable_framebursting))) {\r\ncur_txok_cnt = rtlpriv->stats.txbytesunicast - last_txok_cnt;\r\ncur_rxok_cnt = rtlpriv->stats.rxbytesunicast - last_rxok_cnt;\r\nif (cur_rxok_cnt > 4 * cur_txok_cnt) {\r\nif (!rtlpriv->dm.is_cur_rdlstate ||\r\n!rtlpriv->dm.current_turbo_edca) {\r\nrtl_write_dword(rtlpriv,\r\nREG_EDCA_BE_PARAM,\r\nedca_be_dl);\r\nrtlpriv->dm.is_cur_rdlstate = true;\r\n}\r\n} else {\r\nif (rtlpriv->dm.is_cur_rdlstate ||\r\n!rtlpriv->dm.current_turbo_edca) {\r\nrtl_write_dword(rtlpriv,\r\nREG_EDCA_BE_PARAM,\r\nedca_be_ul);\r\nrtlpriv->dm.is_cur_rdlstate = false;\r\n}\r\n}\r\nrtlpriv->dm.current_turbo_edca = true;\r\n} else {\r\nif (rtlpriv->dm.current_turbo_edca) {\r\nu8 tmp = AC0_BE;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AC_PARAM,\r\n&tmp);\r\nrtlpriv->dm.current_turbo_edca = false;\r\n}\r\n}\r\nrtlpriv->dm.is_any_nonbepkts = false;\r\nlast_txok_cnt = rtlpriv->stats.txbytesunicast;\r\nlast_rxok_cnt = rtlpriv->stats.rxbytesunicast;\r\n}\r\nstatic void rtl92c_dm_txpower_tracking_callback_thermalmeter(struct ieee80211_hw\r\n*hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nu8 thermalvalue, delta, delta_lck, delta_iqk;\r\nlong ele_a, ele_d, temp_cck, val_x, value32;\r\nlong val_y, ele_c = 0;\r\nu8 ofdm_index[2], ofdm_index_old[2] = {0, 0}, cck_index_old = 0;\r\ns8 cck_index = 0;\r\nint i;\r\nbool is2t = IS_92C_SERIAL(rtlhal->version);\r\ns8 txpwr_level[3] = {0, 0, 0};\r\nu8 ofdm_min_index = 6, rf;\r\nrtlpriv->dm.txpower_trackinginit = true;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"rtl92c_dm_txpower_tracking_callback_thermalmeter\n");\r\nthermalvalue = (u8) rtl_get_rfreg(hw, RF90_PATH_A, RF_T_METER, 0x1f);\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermalmeter 0x%x\n",\r\nthermalvalue, rtlpriv->dm.thermalvalue,\r\nrtlefuse->eeprom_thermalmeter);\r\nrtl92c_phy_ap_calibrate(hw, (thermalvalue -\r\nrtlefuse->eeprom_thermalmeter));\r\nif (is2t)\r\nrf = 2;\r\nelse\r\nrf = 1;\r\nif (thermalvalue) {\r\nele_d = rtl_get_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\r\nMASKDWORD) & MASKOFDM_D;\r\nfor (i = 0; i < OFDM_TABLE_LENGTH; i++) {\r\nif (ele_d == (ofdmswing_table[i] & MASKOFDM_D)) {\r\nofdm_index_old[0] = (u8) i;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Initial pathA ele_d reg0x%x = 0x%lx, ofdm_index=0x%x\n",\r\nROFDM0_XATXIQIMBALANCE,\r\nele_d, ofdm_index_old[0]);\r\nbreak;\r\n}\r\n}\r\nif (is2t) {\r\nele_d = rtl_get_bbreg(hw, ROFDM0_XBTXIQIMBALANCE,\r\nMASKDWORD) & MASKOFDM_D;\r\nfor (i = 0; i < OFDM_TABLE_LENGTH; i++) {\r\nif (ele_d == (ofdmswing_table[i] &\r\nMASKOFDM_D)) {\r\nofdm_index_old[1] = (u8) i;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING,\r\nDBG_LOUD,\r\n"Initial pathB ele_d reg0x%x = 0x%lx, ofdm_index=0x%x\n",\r\nROFDM0_XBTXIQIMBALANCE, ele_d,\r\nofdm_index_old[1]);\r\nbreak;\r\n}\r\n}\r\n}\r\ntemp_cck =\r\nrtl_get_bbreg(hw, RCCK0_TXFILTER2, MASKDWORD) & MASKCCK;\r\nfor (i = 0; i < CCK_TABLE_LENGTH; i++) {\r\nif (rtlpriv->dm.cck_inch14) {\r\nif (memcmp((void *)&temp_cck,\r\n(void *)&cckswing_table_ch14[i][2],\r\n4) == 0) {\r\ncck_index_old = (u8) i;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING,\r\nDBG_LOUD,\r\n"Initial reg0x%x = 0x%lx, cck_index=0x%x, ch 14 %d\n",\r\nRCCK0_TXFILTER2, temp_cck,\r\ncck_index_old,\r\nrtlpriv->dm.cck_inch14);\r\nbreak;\r\n}\r\n} else {\r\nif (memcmp((void *)&temp_cck,\r\n(void *)\r\n&cckswing_table_ch1ch13[i][2],\r\n4) == 0) {\r\ncck_index_old = (u8) i;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING,\r\nDBG_LOUD,\r\n"Initial reg0x%x = 0x%lx, cck_index=0x%x, ch14 %d\n",\r\nRCCK0_TXFILTER2, temp_cck,\r\ncck_index_old,\r\nrtlpriv->dm.cck_inch14);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!rtlpriv->dm.thermalvalue) {\r\nrtlpriv->dm.thermalvalue =\r\nrtlefuse->eeprom_thermalmeter;\r\nrtlpriv->dm.thermalvalue_lck = thermalvalue;\r\nrtlpriv->dm.thermalvalue_iqk = thermalvalue;\r\nfor (i = 0; i < rf; i++)\r\nrtlpriv->dm.ofdm_index[i] = ofdm_index_old[i];\r\nrtlpriv->dm.cck_index = cck_index_old;\r\n}\r\ndelta = (thermalvalue > rtlpriv->dm.thermalvalue) ?\r\n(thermalvalue - rtlpriv->dm.thermalvalue) :\r\n(rtlpriv->dm.thermalvalue - thermalvalue);\r\ndelta_lck = (thermalvalue > rtlpriv->dm.thermalvalue_lck) ?\r\n(thermalvalue - rtlpriv->dm.thermalvalue_lck) :\r\n(rtlpriv->dm.thermalvalue_lck - thermalvalue);\r\ndelta_iqk = (thermalvalue > rtlpriv->dm.thermalvalue_iqk) ?\r\n(thermalvalue - rtlpriv->dm.thermalvalue_iqk) :\r\n(rtlpriv->dm.thermalvalue_iqk - thermalvalue);\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermalmeter 0x%x delta 0x%x delta_lck 0x%x delta_iqk 0x%x\n",\r\nthermalvalue, rtlpriv->dm.thermalvalue,\r\nrtlefuse->eeprom_thermalmeter, delta, delta_lck,\r\ndelta_iqk);\r\nif (delta_lck > 1) {\r\nrtlpriv->dm.thermalvalue_lck = thermalvalue;\r\nrtl92c_phy_lc_calibrate(hw);\r\n}\r\nif (delta > 0 && rtlpriv->dm.txpower_track_control) {\r\nif (thermalvalue > rtlpriv->dm.thermalvalue) {\r\nfor (i = 0; i < rf; i++)\r\nrtlpriv->dm.ofdm_index[i] -= delta;\r\nrtlpriv->dm.cck_index -= delta;\r\n} else {\r\nfor (i = 0; i < rf; i++)\r\nrtlpriv->dm.ofdm_index[i] += delta;\r\nrtlpriv->dm.cck_index += delta;\r\n}\r\nif (is2t) {\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"temp OFDM_A_index=0x%x, OFDM_B_index=0x%x, cck_index=0x%x\n",\r\nrtlpriv->dm.ofdm_index[0],\r\nrtlpriv->dm.ofdm_index[1],\r\nrtlpriv->dm.cck_index);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"temp OFDM_A_index=0x%x, cck_index=0x%x\n",\r\nrtlpriv->dm.ofdm_index[0],\r\nrtlpriv->dm.cck_index);\r\n}\r\nif (thermalvalue > rtlefuse->eeprom_thermalmeter) {\r\nfor (i = 0; i < rf; i++)\r\nofdm_index[i] =\r\nrtlpriv->dm.ofdm_index[i]\r\n+ 1;\r\ncck_index = rtlpriv->dm.cck_index + 1;\r\n} else {\r\nfor (i = 0; i < rf; i++)\r\nofdm_index[i] =\r\nrtlpriv->dm.ofdm_index[i];\r\ncck_index = rtlpriv->dm.cck_index;\r\n}\r\nfor (i = 0; i < rf; i++) {\r\nif (txpwr_level[i] >= 0 &&\r\ntxpwr_level[i] <= 26) {\r\nif (thermalvalue >\r\nrtlefuse->eeprom_thermalmeter) {\r\nif (delta < 5)\r\nofdm_index[i] -= 1;\r\nelse\r\nofdm_index[i] -= 2;\r\n} else if (delta > 5 && thermalvalue <\r\nrtlefuse->\r\neeprom_thermalmeter) {\r\nofdm_index[i] += 1;\r\n}\r\n} else if (txpwr_level[i] >= 27 &&\r\ntxpwr_level[i] <= 32\r\n&& thermalvalue >\r\nrtlefuse->eeprom_thermalmeter) {\r\nif (delta < 5)\r\nofdm_index[i] -= 1;\r\nelse\r\nofdm_index[i] -= 2;\r\n} else if (txpwr_level[i] >= 32 &&\r\ntxpwr_level[i] <= 38 &&\r\nthermalvalue >\r\nrtlefuse->eeprom_thermalmeter\r\n&& delta > 5) {\r\nofdm_index[i] -= 1;\r\n}\r\n}\r\nif (txpwr_level[i] >= 0 && txpwr_level[i] <= 26) {\r\nif (thermalvalue >\r\nrtlefuse->eeprom_thermalmeter) {\r\nif (delta < 5)\r\ncck_index -= 1;\r\nelse\r\ncck_index -= 2;\r\n} else if (delta > 5 && thermalvalue <\r\nrtlefuse->eeprom_thermalmeter) {\r\ncck_index += 1;\r\n}\r\n} else if (txpwr_level[i] >= 27 &&\r\ntxpwr_level[i] <= 32 &&\r\nthermalvalue >\r\nrtlefuse->eeprom_thermalmeter) {\r\nif (delta < 5)\r\ncck_index -= 1;\r\nelse\r\ncck_index -= 2;\r\n} else if (txpwr_level[i] >= 32 &&\r\ntxpwr_level[i] <= 38 &&\r\nthermalvalue > rtlefuse->eeprom_thermalmeter\r\n&& delta > 5) {\r\ncck_index -= 1;\r\n}\r\nfor (i = 0; i < rf; i++) {\r\nif (ofdm_index[i] > OFDM_TABLE_SIZE - 1)\r\nofdm_index[i] = OFDM_TABLE_SIZE - 1;\r\nelse if (ofdm_index[i] < ofdm_min_index)\r\nofdm_index[i] = ofdm_min_index;\r\n}\r\nif (cck_index > CCK_TABLE_SIZE - 1)\r\ncck_index = CCK_TABLE_SIZE - 1;\r\nelse if (cck_index < 0)\r\ncck_index = 0;\r\nif (is2t) {\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"new OFDM_A_index=0x%x, OFDM_B_index=0x%x, cck_index=0x%x\n",\r\nofdm_index[0], ofdm_index[1],\r\ncck_index);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"new OFDM_A_index=0x%x, cck_index=0x%x\n",\r\nofdm_index[0], cck_index);\r\n}\r\n}\r\nif (rtlpriv->dm.txpower_track_control && delta != 0) {\r\nele_d =\r\n(ofdmswing_table[ofdm_index[0]] & 0xFFC00000) >> 22;\r\nval_x = rtlphy->reg_e94;\r\nval_y = rtlphy->reg_e9c;\r\nif (val_x != 0) {\r\nif ((val_x & 0x00000200) != 0)\r\nval_x = val_x | 0xFFFFFC00;\r\nele_a = ((val_x * ele_d) >> 8) & 0x000003FF;\r\nif ((val_y & 0x00000200) != 0)\r\nval_y = val_y | 0xFFFFFC00;\r\nele_c = ((val_y * ele_d) >> 8) & 0x000003FF;\r\nvalue32 = (ele_d << 22) |\r\n((ele_c & 0x3F) << 16) | ele_a;\r\nrtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\r\nMASKDWORD, value32);\r\nvalue32 = (ele_c & 0x000003C0) >> 6;\r\nrtl_set_bbreg(hw, ROFDM0_XCTXAFE, MASKH4BITS,\r\nvalue32);\r\nvalue32 = ((val_x * ele_d) >> 7) & 0x01;\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\r\nBIT(31), value32);\r\nvalue32 = ((val_y * ele_d) >> 7) & 0x01;\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\r\nBIT(29), value32);\r\n} else {\r\nrtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\r\nMASKDWORD,\r\nofdmswing_table[ofdm_index[0]]);\r\nrtl_set_bbreg(hw, ROFDM0_XCTXAFE, MASKH4BITS,\r\n0x00);\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\r\nBIT(31) | BIT(29), 0x00);\r\n}\r\nif (!rtlpriv->dm.cck_inch14) {\r\nrtl_write_byte(rtlpriv, 0xa22,\r\ncckswing_table_ch1ch13[cck_index]\r\n[0]);\r\nrtl_write_byte(rtlpriv, 0xa23,\r\ncckswing_table_ch1ch13[cck_index]\r\n[1]);\r\nrtl_write_byte(rtlpriv, 0xa24,\r\ncckswing_table_ch1ch13[cck_index]\r\n[2]);\r\nrtl_write_byte(rtlpriv, 0xa25,\r\ncckswing_table_ch1ch13[cck_index]\r\n[3]);\r\nrtl_write_byte(rtlpriv, 0xa26,\r\ncckswing_table_ch1ch13[cck_index]\r\n[4]);\r\nrtl_write_byte(rtlpriv, 0xa27,\r\ncckswing_table_ch1ch13[cck_index]\r\n[5]);\r\nrtl_write_byte(rtlpriv, 0xa28,\r\ncckswing_table_ch1ch13[cck_index]\r\n[6]);\r\nrtl_write_byte(rtlpriv, 0xa29,\r\ncckswing_table_ch1ch13[cck_index]\r\n[7]);\r\n} else {\r\nrtl_write_byte(rtlpriv, 0xa22,\r\ncckswing_table_ch14[cck_index]\r\n[0]);\r\nrtl_write_byte(rtlpriv, 0xa23,\r\ncckswing_table_ch14[cck_index]\r\n[1]);\r\nrtl_write_byte(rtlpriv, 0xa24,\r\ncckswing_table_ch14[cck_index]\r\n[2]);\r\nrtl_write_byte(rtlpriv, 0xa25,\r\ncckswing_table_ch14[cck_index]\r\n[3]);\r\nrtl_write_byte(rtlpriv, 0xa26,\r\ncckswing_table_ch14[cck_index]\r\n[4]);\r\nrtl_write_byte(rtlpriv, 0xa27,\r\ncckswing_table_ch14[cck_index]\r\n[5]);\r\nrtl_write_byte(rtlpriv, 0xa28,\r\ncckswing_table_ch14[cck_index]\r\n[6]);\r\nrtl_write_byte(rtlpriv, 0xa29,\r\ncckswing_table_ch14[cck_index]\r\n[7]);\r\n}\r\nif (is2t) {\r\nele_d = (ofdmswing_table[ofdm_index[1]] &\r\n0xFFC00000) >> 22;\r\nval_x = rtlphy->reg_eb4;\r\nval_y = rtlphy->reg_ebc;\r\nif (val_x != 0) {\r\nif ((val_x & 0x00000200) != 0)\r\nval_x = val_x | 0xFFFFFC00;\r\nele_a = ((val_x * ele_d) >> 8) &\r\n0x000003FF;\r\nif ((val_y & 0x00000200) != 0)\r\nval_y = val_y | 0xFFFFFC00;\r\nele_c = ((val_y * ele_d) >> 8) &\r\n0x00003FF;\r\nvalue32 = (ele_d << 22) |\r\n((ele_c & 0x3F) << 16) | ele_a;\r\nrtl_set_bbreg(hw,\r\nROFDM0_XBTXIQIMBALANCE,\r\nMASKDWORD, value32);\r\nvalue32 = (ele_c & 0x000003C0) >> 6;\r\nrtl_set_bbreg(hw, ROFDM0_XDTXAFE,\r\nMASKH4BITS, value32);\r\nvalue32 = ((val_x * ele_d) >> 7) & 0x01;\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\r\nBIT(27), value32);\r\nvalue32 = ((val_y * ele_d) >> 7) & 0x01;\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\r\nBIT(25), value32);\r\n} else {\r\nrtl_set_bbreg(hw,\r\nROFDM0_XBTXIQIMBALANCE,\r\nMASKDWORD,\r\nofdmswing_table[ofdm_index\r\n[1]]);\r\nrtl_set_bbreg(hw, ROFDM0_XDTXAFE,\r\nMASKH4BITS, 0x00);\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\r\nBIT(27) | BIT(25), 0x00);\r\n}\r\n}\r\n}\r\nif (delta_iqk > 3) {\r\nrtlpriv->dm.thermalvalue_iqk = thermalvalue;\r\nrtl92c_phy_iq_calibrate(hw, false);\r\n}\r\nif (rtlpriv->dm.txpower_track_control)\r\nrtlpriv->dm.thermalvalue = thermalvalue;\r\n}\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "<===\n");\r\n}\r\nstatic void rtl92c_dm_initialize_txpower_tracking_thermalmeter(\r\nstruct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpriv->dm.txpower_tracking = true;\r\nrtlpriv->dm.txpower_trackinginit = false;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"pMgntInfo->txpower_tracking = %d\n",\r\nrtlpriv->dm.txpower_tracking);\r\n}\r\nstatic void rtl92c_dm_initialize_txpower_tracking(struct ieee80211_hw *hw)\r\n{\r\nrtl92c_dm_initialize_txpower_tracking_thermalmeter(hw);\r\n}\r\nstatic void rtl92c_dm_txpower_tracking_directcall(struct ieee80211_hw *hw)\r\n{\r\nrtl92c_dm_txpower_tracking_callback_thermalmeter(hw);\r\n}\r\nstatic void rtl92c_dm_check_txpower_tracking_thermal_meter(\r\nstruct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstatic u8 tm_trigger;\r\nif (!rtlpriv->dm.txpower_tracking)\r\nreturn;\r\nif (!tm_trigger) {\r\nrtl_set_rfreg(hw, RF90_PATH_A, RF_T_METER, RFREG_OFFSET_MASK,\r\n0x60);\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Trigger 92S Thermal Meter!!\n");\r\ntm_trigger = 1;\r\nreturn;\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Schedule TxPowerTracking direct call!!\n");\r\nrtl92c_dm_txpower_tracking_directcall(hw);\r\ntm_trigger = 0;\r\n}\r\n}\r\nvoid rtl92c_dm_check_txpower_tracking(struct ieee80211_hw *hw)\r\n{\r\nrtl92c_dm_check_txpower_tracking_thermal_meter(hw);\r\n}\r\nvoid rtl92c_dm_init_rate_adaptive_mask(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rate_adaptive *p_ra = &(rtlpriv->ra);\r\np_ra->ratr_state = DM_RATR_STA_INIT;\r\np_ra->pre_ratr_state = DM_RATR_STA_INIT;\r\nif (rtlpriv->dm.dm_type == DM_TYPE_BYDRIVER)\r\nrtlpriv->dm.useramask = true;\r\nelse\r\nrtlpriv->dm.useramask = false;\r\n}\r\nstatic void rtl92c_dm_init_dynamic_bb_powersaving(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct ps_t *dm_pstable = &rtlpriv->dm_pstable;\r\ndm_pstable->pre_ccastate = CCA_MAX;\r\ndm_pstable->cur_ccasate = CCA_MAX;\r\ndm_pstable->pre_rfstate = RF_MAX;\r\ndm_pstable->cur_rfstate = RF_MAX;\r\ndm_pstable->rssi_val_min = 0;\r\n}\r\nvoid rtl92c_dm_rf_saving(struct ieee80211_hw *hw, u8 bforce_in_normal)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct ps_t *dm_pstable = &rtlpriv->dm_pstable;\r\nif (!rtlpriv->reg_init) {\r\nrtlpriv->reg_874 = (rtl_get_bbreg(hw,\r\nRFPGA0_XCD_RFINTERFACESW,\r\nMASKDWORD) & 0x1CC000) >> 14;\r\nrtlpriv->reg_c70 = (rtl_get_bbreg(hw, ROFDM0_AGCPARAMETER1,\r\nMASKDWORD) & BIT(3)) >> 3;\r\nrtlpriv->reg_85c = (rtl_get_bbreg(hw, RFPGA0_XCD_SWITCHCONTROL,\r\nMASKDWORD) & 0xFF000000) >> 24;\r\nrtlpriv->reg_a74 = (rtl_get_bbreg(hw, 0xa74, MASKDWORD) &\r\n0xF000) >> 12;\r\nrtlpriv->reg_init = true;\r\n}\r\nif (!bforce_in_normal) {\r\nif (dm_pstable->rssi_val_min != 0) {\r\nif (dm_pstable->pre_rfstate == RF_NORMAL) {\r\nif (dm_pstable->rssi_val_min >= 30)\r\ndm_pstable->cur_rfstate = RF_SAVE;\r\nelse\r\ndm_pstable->cur_rfstate = RF_NORMAL;\r\n} else {\r\nif (dm_pstable->rssi_val_min <= 25)\r\ndm_pstable->cur_rfstate = RF_NORMAL;\r\nelse\r\ndm_pstable->cur_rfstate = RF_SAVE;\r\n}\r\n} else {\r\ndm_pstable->cur_rfstate = RF_MAX;\r\n}\r\n} else {\r\ndm_pstable->cur_rfstate = RF_NORMAL;\r\n}\r\nif (dm_pstable->pre_rfstate != dm_pstable->cur_rfstate) {\r\nif (dm_pstable->cur_rfstate == RF_SAVE) {\r\nrtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\r\n0x1C0000, 0x2);\r\nrtl_set_bbreg(hw, ROFDM0_AGCPARAMETER1, BIT(3), 0);\r\nrtl_set_bbreg(hw, RFPGA0_XCD_SWITCHCONTROL,\r\n0xFF000000, 0x63);\r\nrtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\r\n0xC000, 0x2);\r\nrtl_set_bbreg(hw, 0xa74, 0xF000, 0x3);\r\nrtl_set_bbreg(hw, 0x818, BIT(28), 0x0);\r\nrtl_set_bbreg(hw, 0x818, BIT(28), 0x1);\r\n} else {\r\nrtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\r\n0x1CC000, rtlpriv->reg_874);\r\nrtl_set_bbreg(hw, ROFDM0_AGCPARAMETER1, BIT(3),\r\nrtlpriv->reg_c70);\r\nrtl_set_bbreg(hw, RFPGA0_XCD_SWITCHCONTROL, 0xFF000000,\r\nrtlpriv->reg_85c);\r\nrtl_set_bbreg(hw, 0xa74, 0xF000, rtlpriv->reg_a74);\r\nrtl_set_bbreg(hw, 0x818, BIT(28), 0x0);\r\n}\r\ndm_pstable->pre_rfstate = dm_pstable->cur_rfstate;\r\n}\r\n}\r\nstatic void rtl92c_dm_dynamic_bb_powersaving(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct ps_t *dm_pstable = &rtlpriv->dm_pstable;\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nif (((mac->link_state == MAC80211_NOLINK)) &&\r\n(rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {\r\ndm_pstable->rssi_val_min = 0;\r\nRT_TRACE(rtlpriv, DBG_LOUD, DBG_LOUD, "Not connected to any\n");\r\n}\r\nif (mac->link_state == MAC80211_LINKED) {\r\nif (mac->opmode == NL80211_IFTYPE_ADHOC) {\r\ndm_pstable->rssi_val_min =\r\nrtlpriv->dm.entry_min_undec_sm_pwdb;\r\nRT_TRACE(rtlpriv, DBG_LOUD, DBG_LOUD,\r\n"AP Client PWDB = 0x%lx\n",\r\ndm_pstable->rssi_val_min);\r\n} else {\r\ndm_pstable->rssi_val_min = rtlpriv->dm.undec_sm_pwdb;\r\nRT_TRACE(rtlpriv, DBG_LOUD, DBG_LOUD,\r\n"STA Default Port PWDB = 0x%lx\n",\r\ndm_pstable->rssi_val_min);\r\n}\r\n} else {\r\ndm_pstable->rssi_val_min =\r\nrtlpriv->dm.entry_min_undec_sm_pwdb;\r\nRT_TRACE(rtlpriv, DBG_LOUD, DBG_LOUD,\r\n"AP Ext Port PWDB = 0x%lx\n",\r\ndm_pstable->rssi_val_min);\r\n}\r\nif (IS_92C_SERIAL(rtlhal->version))\r\n;\r\nelse\r\nrtl92c_dm_rf_saving(hw, false);\r\n}\r\nvoid rtl92c_dm_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpriv->dm.dm_type = DM_TYPE_BYDRIVER;\r\nrtlpriv->dm.dm_flag = DYNAMIC_FUNC_DISABLE | DYNAMIC_FUNC_DIG;\r\nrtlpriv->dm.undec_sm_pwdb = -1;\r\nrtlpriv->dm.undec_sm_cck = -1;\r\nrtlpriv->dm.dm_initialgain_enable = true;\r\nrtl92c_dm_diginit(hw);\r\nrtlpriv->dm.dm_flag |= HAL_DM_HIPWR_DISABLE;\r\nrtl92c_dm_init_dynamic_txpower(hw);\r\nrtl92c_dm_init_edca_turbo(hw);\r\nrtl92c_dm_init_rate_adaptive_mask(hw);\r\nrtlpriv->dm.dm_flag |= DYNAMIC_FUNC_SS;\r\nrtl92c_dm_initialize_txpower_tracking(hw);\r\nrtl92c_dm_init_dynamic_bb_powersaving(hw);\r\nrtlpriv->dm.ofdm_pkt_cnt = 0;\r\nrtlpriv->dm.dm_rssi_sel = RSSI_DEFAULT;\r\n}\r\nvoid rtl92c_dm_dynamic_txpower(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nlong undec_sm_pwdb;\r\nif (!rtlpriv->dm.dynamic_txpower_enable)\r\nreturn;\r\nif (rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\r\nreturn;\r\n}\r\nif ((mac->link_state < MAC80211_LINKED) &&\r\n(rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,\r\n"Not connected to any\n");\r\nrtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\r\nrtlpriv->dm.last_dtp_lvl = TXHIGHPWRLEVEL_NORMAL;\r\nreturn;\r\n}\r\nif (mac->link_state >= MAC80211_LINKED) {\r\nif (mac->opmode == NL80211_IFTYPE_ADHOC) {\r\nundec_sm_pwdb = rtlpriv->dm.entry_min_undec_sm_pwdb;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"AP Client PWDB = 0x%lx\n",\r\nundec_sm_pwdb);\r\n} else {\r\nundec_sm_pwdb = rtlpriv->dm.undec_sm_pwdb;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"STA Default Port PWDB = 0x%lx\n",\r\nundec_sm_pwdb);\r\n}\r\n} else {\r\nundec_sm_pwdb = rtlpriv->dm.entry_min_undec_sm_pwdb;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"AP Ext Port PWDB = 0x%lx\n",\r\nundec_sm_pwdb);\r\n}\r\nif (undec_sm_pwdb >= TX_POWER_NEAR_FIELD_THRESH_LVL2) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_LEVEL2;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x0)\n");\r\n} else if ((undec_sm_pwdb < (TX_POWER_NEAR_FIELD_THRESH_LVL2 - 3)) &&\r\n(undec_sm_pwdb >= TX_POWER_NEAR_FIELD_THRESH_LVL1)) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_LEVEL1;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x10)\n");\r\n} else if (undec_sm_pwdb < (TX_POWER_NEAR_FIELD_THRESH_LVL1 - 5)) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"TXHIGHPWRLEVEL_NORMAL\n");\r\n}\r\nif ((rtlpriv->dm.dynamic_txhighpower_lvl != rtlpriv->dm.last_dtp_lvl)) {\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"PHY_SetTxPowerLevel8192S() Channel = %d\n",\r\nrtlphy->current_channel);\r\nrtl92c_phy_set_txpower_level(hw, rtlphy->current_channel);\r\nif (rtlpriv->dm.dynamic_txhighpower_lvl ==\r\nTXHIGHPWRLEVEL_NORMAL)\r\ndm_restorepowerindex(hw);\r\nelse if (rtlpriv->dm.dynamic_txhighpower_lvl ==\r\nTXHIGHPWRLEVEL_LEVEL1)\r\ndm_writepowerindex(hw, 0x14);\r\nelse if (rtlpriv->dm.dynamic_txhighpower_lvl ==\r\nTXHIGHPWRLEVEL_LEVEL2)\r\ndm_writepowerindex(hw, 0x10);\r\n}\r\nrtlpriv->dm.last_dtp_lvl = rtlpriv->dm.dynamic_txhighpower_lvl;\r\n}\r\nvoid rtl92c_dm_watchdog(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nbool fw_current_inpsmode = false;\r\nbool fw_ps_awake = true;\r\nrtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\r\n(u8 *) (&fw_current_inpsmode));\r\nrtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FWLPS_RF_ON,\r\n(u8 *) (&fw_ps_awake));\r\nif (ppsc->p2p_ps_info.p2p_ps_mode)\r\nfw_ps_awake = false;\r\nif ((ppsc->rfpwr_state == ERFON) && ((!fw_current_inpsmode) &&\r\nfw_ps_awake)\r\n&& (!ppsc->rfchange_inprogress)) {\r\nrtl92c_dm_pwdb_monitor(hw);\r\nrtl92c_dm_dig(hw);\r\nrtl92c_dm_false_alarm_counter_statistics(hw);\r\nrtl92c_dm_dynamic_bb_powersaving(hw);\r\nrtl92c_dm_dynamic_txpower(hw);\r\nrtl92c_dm_check_txpower_tracking(hw);\r\nrtl92c_dm_bt_coexist(hw);\r\nrtl92c_dm_check_edca_turbo(hw);\r\n}\r\n}\r\nu8 rtl92c_bt_rssi_state_change(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nlong undec_sm_pwdb;\r\nu8 curr_bt_rssi_state = 0x00;\r\nif (rtlpriv->mac80211.link_state == MAC80211_LINKED) {\r\nundec_sm_pwdb = GET_UNDECORATED_AVERAGE_RSSI(rtlpriv);\r\n} else {\r\nif (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)\r\nundec_sm_pwdb = 100;\r\nelse\r\nundec_sm_pwdb = rtlpriv->dm.entry_min_undec_sm_pwdb;\r\n}\r\nif (undec_sm_pwdb >= 67)\r\ncurr_bt_rssi_state &= (~BT_RSSI_STATE_NORMAL_POWER);\r\nelse if (undec_sm_pwdb < 62)\r\ncurr_bt_rssi_state |= BT_RSSI_STATE_NORMAL_POWER;\r\nif (undec_sm_pwdb >= 40)\r\ncurr_bt_rssi_state &= (~BT_RSSI_STATE_AMDPU_OFF);\r\nelse if (undec_sm_pwdb <= 32)\r\ncurr_bt_rssi_state |= BT_RSSI_STATE_AMDPU_OFF;\r\nif (undec_sm_pwdb < 35)\r\ncurr_bt_rssi_state |= BT_RSSI_STATE_SPECIAL_LOW;\r\nelse\r\ncurr_bt_rssi_state &= (~BT_RSSI_STATE_SPECIAL_LOW);\r\nif (undec_sm_pwdb < 15)\r\ncurr_bt_rssi_state |= BT_RSSI_STATE_BG_EDCA_LOW;\r\nelse\r\ncurr_bt_rssi_state &= (~BT_RSSI_STATE_BG_EDCA_LOW);\r\nif (curr_bt_rssi_state != rtlpcipriv->bt_coexist.bt_rssi_state) {\r\nrtlpcipriv->bt_coexist.bt_rssi_state = curr_bt_rssi_state;\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nstatic bool rtl92c_bt_state_change(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nu32 polling, ratio_tx, ratio_pri;\r\nu32 bt_tx, bt_pri;\r\nu8 bt_state;\r\nu8 cur_service_type;\r\nif (rtlpriv->mac80211.link_state < MAC80211_LINKED)\r\nreturn false;\r\nbt_state = rtl_read_byte(rtlpriv, 0x4fd);\r\nbt_tx = rtl_read_dword(rtlpriv, 0x488);\r\nbt_tx = bt_tx & 0x00ffffff;\r\nbt_pri = rtl_read_dword(rtlpriv, 0x48c);\r\nbt_pri = bt_pri & 0x00ffffff;\r\npolling = rtl_read_dword(rtlpriv, 0x490);\r\nif (bt_tx == 0xffffffff && bt_pri == 0xffffffff &&\r\npolling == 0xffffffff && bt_state == 0xff)\r\nreturn false;\r\nbt_state &= BIT_OFFSET_LEN_MASK_32(0, 1);\r\nif (bt_state != rtlpcipriv->bt_coexist.bt_cur_state) {\r\nrtlpcipriv->bt_coexist.bt_cur_state = bt_state;\r\nif (rtlpcipriv->bt_coexist.reg_bt_sco == 3) {\r\nrtlpcipriv->bt_coexist.bt_service = BT_IDLE;\r\nbt_state = bt_state |\r\n((rtlpcipriv->bt_coexist.bt_ant_isolation == 1) ?\r\n0 : BIT_OFFSET_LEN_MASK_32(1, 1)) |\r\nBIT_OFFSET_LEN_MASK_32(2, 1);\r\nrtl_write_byte(rtlpriv, 0x4fd, bt_state);\r\n}\r\nreturn true;\r\n}\r\nratio_tx = bt_tx * 1000 / polling;\r\nratio_pri = bt_pri * 1000 / polling;\r\nrtlpcipriv->bt_coexist.ratio_tx = ratio_tx;\r\nrtlpcipriv->bt_coexist.ratio_pri = ratio_pri;\r\nif (bt_state && rtlpcipriv->bt_coexist.reg_bt_sco == 3) {\r\nif ((ratio_tx < 30) && (ratio_pri < 30))\r\ncur_service_type = BT_IDLE;\r\nelse if ((ratio_pri > 110) && (ratio_pri < 250))\r\ncur_service_type = BT_SCO;\r\nelse if ((ratio_tx >= 200) && (ratio_pri >= 200))\r\ncur_service_type = BT_BUSY;\r\nelse if ((ratio_tx >= 350) && (ratio_tx < 500))\r\ncur_service_type = BT_OTHERBUSY;\r\nelse if (ratio_tx >= 500)\r\ncur_service_type = BT_PAN;\r\nelse\r\ncur_service_type = BT_OTHER_ACTION;\r\nif (cur_service_type != rtlpcipriv->bt_coexist.bt_service) {\r\nrtlpcipriv->bt_coexist.bt_service = cur_service_type;\r\nbt_state = bt_state |\r\n((rtlpcipriv->bt_coexist.bt_ant_isolation == 1) ?\r\n0 : BIT_OFFSET_LEN_MASK_32(1, 1)) |\r\n((rtlpcipriv->bt_coexist.bt_service != BT_IDLE) ?\r\n0 : BIT_OFFSET_LEN_MASK_32(2, 1));\r\nif (rtlpcipriv->bt_coexist.bt_service != BT_IDLE) {\r\nrtl_write_word(rtlpriv, 0x504, 0x0ccc);\r\nrtl_write_byte(rtlpriv, 0x506, 0x54);\r\nrtl_write_byte(rtlpriv, 0x507, 0x54);\r\n} else {\r\nrtl_write_byte(rtlpriv, 0x506, 0x00);\r\nrtl_write_byte(rtlpriv, 0x507, 0x00);\r\n}\r\nrtl_write_byte(rtlpriv, 0x4fd, bt_state);\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool rtl92c_bt_wifi_connect_change(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstatic bool media_connect;\r\nif (rtlpriv->mac80211.link_state < MAC80211_LINKED) {\r\nmedia_connect = false;\r\n} else {\r\nif (!media_connect) {\r\nmedia_connect = true;\r\nreturn true;\r\n}\r\nmedia_connect = true;\r\n}\r\nreturn false;\r\n}\r\nstatic void rtl92c_bt_set_normal(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nif (rtlpcipriv->bt_coexist.bt_service == BT_OTHERBUSY) {\r\nrtlpcipriv->bt_coexist.bt_edca_ul = 0x5ea72b;\r\nrtlpcipriv->bt_coexist.bt_edca_dl = 0x5ea72b;\r\n} else if (rtlpcipriv->bt_coexist.bt_service == BT_BUSY) {\r\nrtlpcipriv->bt_coexist.bt_edca_ul = 0x5eb82f;\r\nrtlpcipriv->bt_coexist.bt_edca_dl = 0x5eb82f;\r\n} else if (rtlpcipriv->bt_coexist.bt_service == BT_SCO) {\r\nif (rtlpcipriv->bt_coexist.ratio_tx > 160) {\r\nrtlpcipriv->bt_coexist.bt_edca_ul = 0x5ea72f;\r\nrtlpcipriv->bt_coexist.bt_edca_dl = 0x5ea72f;\r\n} else {\r\nrtlpcipriv->bt_coexist.bt_edca_ul = 0x5ea32b;\r\nrtlpcipriv->bt_coexist.bt_edca_dl = 0x5ea42b;\r\n}\r\n} else {\r\nrtlpcipriv->bt_coexist.bt_edca_ul = 0;\r\nrtlpcipriv->bt_coexist.bt_edca_dl = 0;\r\n}\r\nif ((rtlpcipriv->bt_coexist.bt_service != BT_IDLE) &&\r\n(rtlpriv->mac80211.mode == WIRELESS_MODE_G ||\r\n(rtlpriv->mac80211.mode == (WIRELESS_MODE_G | WIRELESS_MODE_B))) &&\r\n(rtlpcipriv->bt_coexist.bt_rssi_state &\r\nBT_RSSI_STATE_BG_EDCA_LOW)) {\r\nrtlpcipriv->bt_coexist.bt_edca_ul = 0x5eb82b;\r\nrtlpcipriv->bt_coexist.bt_edca_dl = 0x5eb82b;\r\n}\r\n}\r\nstatic void rtl92c_bt_ant_isolation(struct ieee80211_hw *hw, u8 tmp1byte)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nif (rtlpriv->mac80211.vendor == PEER_CISCO &&\r\nrtlpcipriv->bt_coexist.bt_service == BT_OTHER_ACTION) {\r\nrtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, 0xa0);\r\n} else {\r\nif ((rtlpcipriv->bt_coexist.bt_service == BT_BUSY) &&\r\n(rtlpcipriv->bt_coexist.bt_rssi_state &\r\nBT_RSSI_STATE_NORMAL_POWER)) {\r\nrtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, 0xa0);\r\n} else if ((rtlpcipriv->bt_coexist.bt_service ==\r\nBT_OTHER_ACTION) && (rtlpriv->mac80211.mode <\r\nWIRELESS_MODE_N_24G) &&\r\n(rtlpcipriv->bt_coexist.bt_rssi_state &\r\nBT_RSSI_STATE_SPECIAL_LOW)) {\r\nrtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, 0xa0);\r\n} else if (rtlpcipriv->bt_coexist.bt_service == BT_PAN) {\r\nrtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, tmp1byte);\r\n} else {\r\nrtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, tmp1byte);\r\n}\r\n}\r\nif (rtlpcipriv->bt_coexist.bt_service == BT_PAN)\r\nrtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, 0x10100);\r\nelse\r\nrtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, 0x0);\r\nif (rtlpcipriv->bt_coexist.bt_rssi_state &\r\nBT_RSSI_STATE_NORMAL_POWER) {\r\nrtl92c_bt_set_normal(hw);\r\n} else {\r\nrtlpcipriv->bt_coexist.bt_edca_ul = 0;\r\nrtlpcipriv->bt_coexist.bt_edca_dl = 0;\r\n}\r\nif (rtlpcipriv->bt_coexist.bt_service != BT_IDLE) {\r\nrtlpriv->cfg->ops->set_rfreg(hw,\r\nRF90_PATH_A,\r\n0x1e,\r\n0xf0, 0xf);\r\n} else {\r\nrtlpriv->cfg->ops->set_rfreg(hw,\r\nRF90_PATH_A, 0x1e, 0xf0,\r\nrtlpcipriv->bt_coexist.bt_rfreg_origin_1e);\r\n}\r\nif (!rtlpriv->dm.dynamic_txpower_enable) {\r\nif (rtlpcipriv->bt_coexist.bt_service != BT_IDLE) {\r\nif (rtlpcipriv->bt_coexist.bt_rssi_state &\r\nBT_RSSI_STATE_TXPOWER_LOW) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl =\r\nTXHIGHPWRLEVEL_BT2;\r\n} else {\r\nrtlpriv->dm.dynamic_txhighpower_lvl =\r\nTXHIGHPWRLEVEL_BT1;\r\n}\r\n} else {\r\nrtlpriv->dm.dynamic_txhighpower_lvl =\r\nTXHIGHPWRLEVEL_NORMAL;\r\n}\r\nrtl92c_phy_set_txpower_level(hw,\r\nrtlpriv->phy.current_channel);\r\n}\r\n}\r\nstatic void rtl92c_check_bt_change(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 tmp1byte = 0;\r\nif (IS_81xxC_VENDOR_UMC_B_CUT(rtlhal->version) &&\r\nrtlpcipriv->bt_coexist.bt_coexistence)\r\ntmp1byte |= BIT(5);\r\nif (rtlpcipriv->bt_coexist.bt_cur_state) {\r\nif (rtlpcipriv->bt_coexist.bt_ant_isolation)\r\nrtl92c_bt_ant_isolation(hw, tmp1byte);\r\n} else {\r\nrtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, tmp1byte);\r\nrtlpriv->cfg->ops->set_rfreg(hw, RF90_PATH_A, 0x1e, 0xf0,\r\nrtlpcipriv->bt_coexist.bt_rfreg_origin_1e);\r\nrtlpcipriv->bt_coexist.bt_edca_ul = 0;\r\nrtlpcipriv->bt_coexist.bt_edca_dl = 0;\r\n}\r\n}\r\nvoid rtl92c_dm_bt_coexist(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nbool wifi_connect_change;\r\nbool bt_state_change;\r\nbool rssi_state_change;\r\nif ((rtlpcipriv->bt_coexist.bt_coexistence) &&\r\n(rtlpcipriv->bt_coexist.bt_coexist_type == BT_CSR_BC4)) {\r\nwifi_connect_change = rtl92c_bt_wifi_connect_change(hw);\r\nbt_state_change = rtl92c_bt_state_change(hw);\r\nrssi_state_change = rtl92c_bt_rssi_state_change(hw);\r\nif (wifi_connect_change || bt_state_change || rssi_state_change)\r\nrtl92c_check_bt_change(hw);\r\n}\r\n}
