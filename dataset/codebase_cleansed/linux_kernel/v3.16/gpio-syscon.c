static inline struct syscon_gpio_priv *to_syscon_gpio(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct syscon_gpio_priv, chip);\r\n}\r\nstatic int syscon_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct syscon_gpio_priv *priv = to_syscon_gpio(chip);\r\nunsigned int val, offs = priv->data->dat_bit_offset + offset;\r\nint ret;\r\nret = regmap_read(priv->syscon,\r\n(offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn !!(val & BIT(offs % SYSCON_REG_BITS));\r\n}\r\nstatic void syscon_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct syscon_gpio_priv *priv = to_syscon_gpio(chip);\r\nunsigned int offs = priv->data->dat_bit_offset + offset;\r\nregmap_update_bits(priv->syscon,\r\n(offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\r\nBIT(offs % SYSCON_REG_BITS),\r\nval ? BIT(offs % SYSCON_REG_BITS) : 0);\r\n}\r\nstatic int syscon_gpio_dir_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct syscon_gpio_priv *priv = to_syscon_gpio(chip);\r\nif (priv->data->flags & GPIO_SYSCON_FEAT_DIR) {\r\nunsigned int offs = priv->data->dir_bit_offset + offset;\r\nregmap_update_bits(priv->syscon,\r\n(offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\r\nBIT(offs % SYSCON_REG_BITS), 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int syscon_gpio_dir_out(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct syscon_gpio_priv *priv = to_syscon_gpio(chip);\r\nif (priv->data->flags & GPIO_SYSCON_FEAT_DIR) {\r\nunsigned int offs = priv->data->dir_bit_offset + offset;\r\nregmap_update_bits(priv->syscon,\r\n(offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\r\nBIT(offs % SYSCON_REG_BITS),\r\nBIT(offs % SYSCON_REG_BITS));\r\n}\r\nsyscon_gpio_set(chip, offset, val);\r\nreturn 0;\r\n}\r\nstatic int syscon_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *of_id = of_match_device(syscon_gpio_ids, dev);\r\nstruct syscon_gpio_priv *priv;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->data = of_id->data;\r\npriv->syscon =\r\nsyscon_regmap_lookup_by_compatible(priv->data->compatible);\r\nif (IS_ERR(priv->syscon))\r\nreturn PTR_ERR(priv->syscon);\r\npriv->chip.dev = dev;\r\npriv->chip.owner = THIS_MODULE;\r\npriv->chip.label = dev_name(dev);\r\npriv->chip.base = -1;\r\npriv->chip.ngpio = priv->data->bit_count;\r\npriv->chip.get = syscon_gpio_get;\r\nif (priv->data->flags & GPIO_SYSCON_FEAT_IN)\r\npriv->chip.direction_input = syscon_gpio_dir_in;\r\nif (priv->data->flags & GPIO_SYSCON_FEAT_OUT) {\r\npriv->chip.set = syscon_gpio_set;\r\npriv->chip.direction_output = syscon_gpio_dir_out;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn gpiochip_add(&priv->chip);\r\n}\r\nstatic int syscon_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct syscon_gpio_priv *priv = platform_get_drvdata(pdev);\r\nreturn gpiochip_remove(&priv->chip);\r\n}
