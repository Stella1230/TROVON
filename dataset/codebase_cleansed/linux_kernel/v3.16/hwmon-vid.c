int vid_from_reg(int val, u8 vrm)\r\n{\r\nint vid;\r\nswitch (vrm) {\r\ncase 100:\r\nval &= 0x3f;\r\nif ((val & 0x1f) == 0x1f)\r\nreturn 0;\r\nif ((val & 0x1f) <= 0x09 || val == 0x0a)\r\nvid = 1087500 - (val & 0x1f) * 25000;\r\nelse\r\nvid = 1862500 - (val & 0x1f) * 25000;\r\nif (val & 0x20)\r\nvid -= 12500;\r\nreturn (vid + 500) / 1000;\r\ncase 110:\r\nval &= 0xff;\r\nif (val < 0x02 || val > 0xb2)\r\nreturn 0;\r\nreturn (1600000 - (val - 2) * 6250 + 500) / 1000;\r\ncase 24:\r\nval &= 0x1f;\r\nif (val == 0x1f)\r\nreturn 0;\r\ncase 25:\r\nval &= 0x3f;\r\nreturn (val < 32) ? 1550 - 25 * val\r\n: 775 - (25 * (val - 31)) / 2;\r\ncase 26:\r\nval &= 0x7f;\r\nif (val >= 0x7c)\r\nreturn 0;\r\nreturn DIV_ROUND_CLOSEST(15500 - 125 * val, 10);\r\ncase 91:\r\ncase 90:\r\nval &= 0x1f;\r\nreturn val == 0x1f ? 0 :\r\n1850 - val * 25;\r\ncase 85:\r\nval &= 0x1f;\r\nreturn (val & 0x10 ? 25 : 0) +\r\n((val & 0x0f) > 0x04 ? 2050 : 1250) -\r\n((val & 0x0f) * 50);\r\ncase 84:\r\nval &= 0x0f;\r\ncase 82:\r\nval &= 0x1f;\r\nreturn val == 0x1f ? 0 :\r\nval & 0x10 ? 5100 - (val) * 100 :\r\n2050 - (val) * 50;\r\ncase 17:\r\nval &= 0x1f;\r\nreturn val & 0x10 ? 975 - (val & 0xF) * 25 :\r\n1750 - val * 50;\r\ncase 13:\r\ncase 131:\r\nval &= 0x3f;\r\nif (vrm == 131 && val == 0x3f)\r\nval++;\r\nreturn 1708 - val * 16;\r\ncase 14:\r\nval &= 0x7f;\r\nreturn val > 0x77 ? 0 : (1500000 - (val * 12500) + 500) / 1000;\r\ndefault:\r\nif (vrm)\r\npr_warn("Requested unsupported VRM version (%u)\n",\r\n(unsigned int)vrm);\r\nreturn 0;\r\n}\r\n}\r\nstatic u8 get_via_model_d_vrm(void)\r\n{\r\nunsigned int vid, brand, __maybe_unused dummy;\r\nstatic const char *brands[4] = {\r\n"C7-M", "C7", "Eden", "C7-D"\r\n};\r\nrdmsr(0x198, dummy, vid);\r\nvid &= 0xff;\r\nrdmsr(0x1154, brand, dummy);\r\nbrand = ((brand >> 4) ^ (brand >> 2)) & 0x03;\r\nif (vid > 0x3f) {\r\npr_info("Using %d-bit VID table for VIA %s CPU\n",\r\n7, brands[brand]);\r\nreturn 14;\r\n} else {\r\npr_info("Using %d-bit VID table for VIA %s CPU\n",\r\n6, brands[brand]);\r\nreturn brand == 2 ? 131 : 13;\r\n}\r\n}\r\nstatic u8 find_vrm(u8 family, u8 model, u8 stepping, u8 vendor)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vrm_models); i++) {\r\nif (vendor == vrm_models[i].vendor &&\r\nfamily == vrm_models[i].family &&\r\nmodel >= vrm_models[i].model_from &&\r\nmodel <= vrm_models[i].model_to &&\r\nstepping <= vrm_models[i].stepping_to)\r\nreturn vrm_models[i].vrm_type;\r\n}\r\nreturn 0;\r\n}\r\nu8 vid_which_vrm(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nu8 vrm_ret;\r\nif (c->x86 < 6)\r\nreturn 0;\r\nvrm_ret = find_vrm(c->x86, c->x86_model, c->x86_mask, c->x86_vendor);\r\nif (vrm_ret == 134)\r\nvrm_ret = get_via_model_d_vrm();\r\nif (vrm_ret == 0)\r\npr_info("Unknown VRM version of your x86 CPU\n");\r\nreturn vrm_ret;\r\n}\r\nu8 vid_which_vrm(void)\r\n{\r\npr_info("Unknown VRM version of your CPU\n");\r\nreturn 0;\r\n}
