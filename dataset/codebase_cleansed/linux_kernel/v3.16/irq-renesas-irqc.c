static void irqc_dbg(struct irqc_irq *i, char *str)\r\n{\r\ndev_dbg(&i->p->pdev->dev, "%s (%d:%d:%d)\n",\r\nstr, i->requested_irq, i->hw_irq, i->domain_irq);\r\n}\r\nstatic void irqc_irq_enable(struct irq_data *d)\r\n{\r\nstruct irqc_priv *p = irq_data_get_irq_chip_data(d);\r\nint hw_irq = irqd_to_hwirq(d);\r\nirqc_dbg(&p->irq[hw_irq], "enable");\r\niowrite32(BIT(hw_irq), p->cpu_int_base + IRQC_EN_SET);\r\n}\r\nstatic void irqc_irq_disable(struct irq_data *d)\r\n{\r\nstruct irqc_priv *p = irq_data_get_irq_chip_data(d);\r\nint hw_irq = irqd_to_hwirq(d);\r\nirqc_dbg(&p->irq[hw_irq], "disable");\r\niowrite32(BIT(hw_irq), p->cpu_int_base + IRQC_EN_STS);\r\n}\r\nstatic int irqc_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct irqc_priv *p = irq_data_get_irq_chip_data(d);\r\nint hw_irq = irqd_to_hwirq(d);\r\nunsigned char value = irqc_sense[type & IRQ_TYPE_SENSE_MASK];\r\nunsigned long tmp;\r\nirqc_dbg(&p->irq[hw_irq], "sense");\r\nif (!value)\r\nreturn -EINVAL;\r\ntmp = ioread32(p->iomem + IRQC_CONFIG(hw_irq));\r\ntmp &= ~0x3f;\r\ntmp |= value;\r\niowrite32(tmp, p->iomem + IRQC_CONFIG(hw_irq));\r\nreturn 0;\r\n}\r\nstatic irqreturn_t irqc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct irqc_irq *i = dev_id;\r\nstruct irqc_priv *p = i->p;\r\nunsigned long bit = BIT(i->hw_irq);\r\nirqc_dbg(i, "demux1");\r\nif (ioread32(p->iomem + DETECT_STATUS) & bit) {\r\niowrite32(bit, p->iomem + DETECT_STATUS);\r\nirqc_dbg(i, "demux2");\r\ngeneric_handle_irq(i->domain_irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int irqc_irq_domain_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct irqc_priv *p = h->host_data;\r\np->irq[hw].domain_irq = virq;\r\np->irq[hw].hw_irq = hw;\r\nirqc_dbg(&p->irq[hw], "map");\r\nirq_set_chip_data(virq, h->host_data);\r\nirq_set_chip_and_handler(virq, &p->irq_chip, handle_level_irq);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic int irqc_probe(struct platform_device *pdev)\r\n{\r\nstruct renesas_irqc_config *pdata = pdev->dev.platform_data;\r\nstruct irqc_priv *p;\r\nstruct resource *io;\r\nstruct resource *irq;\r\nstruct irq_chip *irq_chip;\r\nconst char *name = dev_name(&pdev->dev);\r\nint ret;\r\nint k;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\nif (pdata)\r\nmemcpy(&p->config, pdata, sizeof(*pdata));\r\np->pdev = pdev;\r\nplatform_set_drvdata(pdev, p);\r\nio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!io) {\r\ndev_err(&pdev->dev, "not enough IOMEM resources\n");\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\nfor (k = 0; k < IRQC_IRQ_MAX; k++) {\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, k);\r\nif (!irq)\r\nbreak;\r\np->irq[k].p = p;\r\np->irq[k].requested_irq = irq->start;\r\n}\r\np->number_of_irqs = k;\r\nif (p->number_of_irqs < 1) {\r\ndev_err(&pdev->dev, "not enough IRQ resources\n");\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\np->iomem = ioremap_nocache(io->start, resource_size(io));\r\nif (!p->iomem) {\r\ndev_err(&pdev->dev, "failed to remap IOMEM\n");\r\nret = -ENXIO;\r\ngoto err2;\r\n}\r\np->cpu_int_base = p->iomem + IRQC_INT_CPU_BASE(0);\r\nirq_chip = &p->irq_chip;\r\nirq_chip->name = name;\r\nirq_chip->irq_mask = irqc_irq_disable;\r\nirq_chip->irq_unmask = irqc_irq_enable;\r\nirq_chip->irq_set_type = irqc_irq_set_type;\r\nirq_chip->flags = IRQCHIP_SKIP_SET_WAKE | IRQCHIP_MASK_ON_SUSPEND;\r\np->irq_domain = irq_domain_add_simple(pdev->dev.of_node,\r\np->number_of_irqs,\r\np->config.irq_base,\r\n&irqc_irq_domain_ops, p);\r\nif (!p->irq_domain) {\r\nret = -ENXIO;\r\ndev_err(&pdev->dev, "cannot initialize irq domain\n");\r\ngoto err2;\r\n}\r\nfor (k = 0; k < p->number_of_irqs; k++) {\r\nif (request_irq(p->irq[k].requested_irq, irqc_irq_handler,\r\n0, name, &p->irq[k])) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\nret = -ENOENT;\r\ngoto err3;\r\n}\r\n}\r\ndev_info(&pdev->dev, "driving %d irqs\n", p->number_of_irqs);\r\nif (p->config.irq_base) {\r\nif (p->config.irq_base != p->irq[0].domain_irq)\r\ndev_warn(&pdev->dev, "irq base mismatch (%d/%d)\n",\r\np->config.irq_base, p->irq[0].domain_irq);\r\n}\r\nreturn 0;\r\nerr3:\r\nwhile (--k >= 0)\r\nfree_irq(p->irq[k].requested_irq, &p->irq[k]);\r\nirq_domain_remove(p->irq_domain);\r\nerr2:\r\niounmap(p->iomem);\r\nerr1:\r\nkfree(p);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int irqc_remove(struct platform_device *pdev)\r\n{\r\nstruct irqc_priv *p = platform_get_drvdata(pdev);\r\nint k;\r\nfor (k = 0; k < p->number_of_irqs; k++)\r\nfree_irq(p->irq[k].requested_irq, &p->irq[k]);\r\nirq_domain_remove(p->irq_domain);\r\niounmap(p->iomem);\r\nkfree(p);\r\nreturn 0;\r\n}\r\nstatic int __init irqc_init(void)\r\n{\r\nreturn platform_driver_register(&irqc_device_driver);\r\n}\r\nstatic void __exit irqc_exit(void)\r\n{\r\nplatform_driver_unregister(&irqc_device_driver);\r\n}
