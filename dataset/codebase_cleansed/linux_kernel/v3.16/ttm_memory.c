static void ttm_mem_zone_kobj_release(struct kobject *kobj)\r\n{\r\nstruct ttm_mem_zone *zone =\r\ncontainer_of(kobj, struct ttm_mem_zone, kobj);\r\npr_info("Zone %7s: Used memory at exit: %llu kiB\n",\r\nzone->name, (unsigned long long)zone->used_mem >> 10);\r\nkfree(zone);\r\n}\r\nstatic ssize_t ttm_mem_zone_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct ttm_mem_zone *zone =\r\ncontainer_of(kobj, struct ttm_mem_zone, kobj);\r\nuint64_t val = 0;\r\nspin_lock(&zone->glob->lock);\r\nif (attr == &ttm_mem_sys)\r\nval = zone->zone_mem;\r\nelse if (attr == &ttm_mem_emer)\r\nval = zone->emer_mem;\r\nelse if (attr == &ttm_mem_max)\r\nval = zone->max_mem;\r\nelse if (attr == &ttm_mem_swap)\r\nval = zone->swap_limit;\r\nelse if (attr == &ttm_mem_used)\r\nval = zone->used_mem;\r\nspin_unlock(&zone->glob->lock);\r\nreturn snprintf(buffer, PAGE_SIZE, "%llu\n",\r\n(unsigned long long) val >> 10);\r\n}\r\nstatic ssize_t ttm_mem_zone_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t size)\r\n{\r\nstruct ttm_mem_zone *zone =\r\ncontainer_of(kobj, struct ttm_mem_zone, kobj);\r\nint chars;\r\nunsigned long val;\r\nuint64_t val64;\r\nchars = sscanf(buffer, "%lu", &val);\r\nif (chars == 0)\r\nreturn size;\r\nval64 = val;\r\nval64 <<= 10;\r\nspin_lock(&zone->glob->lock);\r\nif (val64 > zone->zone_mem)\r\nval64 = zone->zone_mem;\r\nif (attr == &ttm_mem_emer) {\r\nzone->emer_mem = val64;\r\nif (zone->max_mem > val64)\r\nzone->max_mem = val64;\r\n} else if (attr == &ttm_mem_max) {\r\nzone->max_mem = val64;\r\nif (zone->emer_mem < val64)\r\nzone->emer_mem = val64;\r\n} else if (attr == &ttm_mem_swap)\r\nzone->swap_limit = val64;\r\nspin_unlock(&zone->glob->lock);\r\nttm_check_swapping(zone->glob);\r\nreturn size;\r\n}\r\nstatic void ttm_mem_global_kobj_release(struct kobject *kobj)\r\n{\r\nstruct ttm_mem_global *glob =\r\ncontainer_of(kobj, struct ttm_mem_global, kobj);\r\nkfree(glob);\r\n}\r\nstatic bool ttm_zones_above_swap_target(struct ttm_mem_global *glob,\r\nbool from_wq, uint64_t extra)\r\n{\r\nunsigned int i;\r\nstruct ttm_mem_zone *zone;\r\nuint64_t target;\r\nfor (i = 0; i < glob->num_zones; ++i) {\r\nzone = glob->zones[i];\r\nif (from_wq)\r\ntarget = zone->swap_limit;\r\nelse if (capable(CAP_SYS_ADMIN))\r\ntarget = zone->emer_mem;\r\nelse\r\ntarget = zone->max_mem;\r\ntarget = (extra > target) ? 0ULL : target;\r\nif (zone->used_mem > target)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void ttm_shrink(struct ttm_mem_global *glob, bool from_wq,\r\nuint64_t extra)\r\n{\r\nint ret;\r\nstruct ttm_mem_shrink *shrink;\r\nspin_lock(&glob->lock);\r\nif (glob->shrink == NULL)\r\ngoto out;\r\nwhile (ttm_zones_above_swap_target(glob, from_wq, extra)) {\r\nshrink = glob->shrink;\r\nspin_unlock(&glob->lock);\r\nret = shrink->do_shrink(shrink);\r\nspin_lock(&glob->lock);\r\nif (unlikely(ret != 0))\r\ngoto out;\r\n}\r\nout:\r\nspin_unlock(&glob->lock);\r\n}\r\nstatic void ttm_shrink_work(struct work_struct *work)\r\n{\r\nstruct ttm_mem_global *glob =\r\ncontainer_of(work, struct ttm_mem_global, work);\r\nttm_shrink(glob, true, 0ULL);\r\n}\r\nstatic int ttm_mem_init_kernel_zone(struct ttm_mem_global *glob,\r\nconst struct sysinfo *si)\r\n{\r\nstruct ttm_mem_zone *zone = kzalloc(sizeof(*zone), GFP_KERNEL);\r\nuint64_t mem;\r\nint ret;\r\nif (unlikely(!zone))\r\nreturn -ENOMEM;\r\nmem = si->totalram - si->totalhigh;\r\nmem *= si->mem_unit;\r\nzone->name = "kernel";\r\nzone->zone_mem = mem;\r\nzone->max_mem = mem >> 1;\r\nzone->emer_mem = (mem >> 1) + (mem >> 2);\r\nzone->swap_limit = zone->max_mem - (mem >> 3);\r\nzone->used_mem = 0;\r\nzone->glob = glob;\r\nglob->zone_kernel = zone;\r\nret = kobject_init_and_add(\r\n&zone->kobj, &ttm_mem_zone_kobj_type, &glob->kobj, zone->name);\r\nif (unlikely(ret != 0)) {\r\nkobject_put(&zone->kobj);\r\nreturn ret;\r\n}\r\nglob->zones[glob->num_zones++] = zone;\r\nreturn 0;\r\n}\r\nstatic int ttm_mem_init_highmem_zone(struct ttm_mem_global *glob,\r\nconst struct sysinfo *si)\r\n{\r\nstruct ttm_mem_zone *zone;\r\nuint64_t mem;\r\nint ret;\r\nif (si->totalhigh == 0)\r\nreturn 0;\r\nzone = kzalloc(sizeof(*zone), GFP_KERNEL);\r\nif (unlikely(!zone))\r\nreturn -ENOMEM;\r\nmem = si->totalram;\r\nmem *= si->mem_unit;\r\nzone->name = "highmem";\r\nzone->zone_mem = mem;\r\nzone->max_mem = mem >> 1;\r\nzone->emer_mem = (mem >> 1) + (mem >> 2);\r\nzone->swap_limit = zone->max_mem - (mem >> 3);\r\nzone->used_mem = 0;\r\nzone->glob = glob;\r\nglob->zone_highmem = zone;\r\nret = kobject_init_and_add(\r\n&zone->kobj, &ttm_mem_zone_kobj_type, &glob->kobj, zone->name);\r\nif (unlikely(ret != 0)) {\r\nkobject_put(&zone->kobj);\r\nreturn ret;\r\n}\r\nglob->zones[glob->num_zones++] = zone;\r\nreturn 0;\r\n}\r\nstatic int ttm_mem_init_dma32_zone(struct ttm_mem_global *glob,\r\nconst struct sysinfo *si)\r\n{\r\nstruct ttm_mem_zone *zone = kzalloc(sizeof(*zone), GFP_KERNEL);\r\nuint64_t mem;\r\nint ret;\r\nif (unlikely(!zone))\r\nreturn -ENOMEM;\r\nmem = si->totalram;\r\nmem *= si->mem_unit;\r\nif (mem <= ((uint64_t) 1ULL << 32)) {\r\nkfree(zone);\r\nreturn 0;\r\n}\r\nmem = ((uint64_t) 1ULL << 32);\r\nzone->name = "dma32";\r\nzone->zone_mem = mem;\r\nzone->max_mem = mem >> 1;\r\nzone->emer_mem = (mem >> 1) + (mem >> 2);\r\nzone->swap_limit = zone->max_mem - (mem >> 3);\r\nzone->used_mem = 0;\r\nzone->glob = glob;\r\nglob->zone_dma32 = zone;\r\nret = kobject_init_and_add(\r\n&zone->kobj, &ttm_mem_zone_kobj_type, &glob->kobj, zone->name);\r\nif (unlikely(ret != 0)) {\r\nkobject_put(&zone->kobj);\r\nreturn ret;\r\n}\r\nglob->zones[glob->num_zones++] = zone;\r\nreturn 0;\r\n}\r\nint ttm_mem_global_init(struct ttm_mem_global *glob)\r\n{\r\nstruct sysinfo si;\r\nint ret;\r\nint i;\r\nstruct ttm_mem_zone *zone;\r\nspin_lock_init(&glob->lock);\r\nglob->swap_queue = create_singlethread_workqueue("ttm_swap");\r\nINIT_WORK(&glob->work, ttm_shrink_work);\r\nret = kobject_init_and_add(\r\n&glob->kobj, &ttm_mem_glob_kobj_type, ttm_get_kobj(), "memory_accounting");\r\nif (unlikely(ret != 0)) {\r\nkobject_put(&glob->kobj);\r\nreturn ret;\r\n}\r\nsi_meminfo(&si);\r\nret = ttm_mem_init_kernel_zone(glob, &si);\r\nif (unlikely(ret != 0))\r\ngoto out_no_zone;\r\n#ifdef CONFIG_HIGHMEM\r\nret = ttm_mem_init_highmem_zone(glob, &si);\r\nif (unlikely(ret != 0))\r\ngoto out_no_zone;\r\n#else\r\nret = ttm_mem_init_dma32_zone(glob, &si);\r\nif (unlikely(ret != 0))\r\ngoto out_no_zone;\r\n#endif\r\nfor (i = 0; i < glob->num_zones; ++i) {\r\nzone = glob->zones[i];\r\npr_info("Zone %7s: Available graphics memory: %llu kiB\n",\r\nzone->name, (unsigned long long)zone->max_mem >> 10);\r\n}\r\nttm_page_alloc_init(glob, glob->zone_kernel->max_mem/(2*PAGE_SIZE));\r\nttm_dma_page_alloc_init(glob, glob->zone_kernel->max_mem/(2*PAGE_SIZE));\r\nreturn 0;\r\nout_no_zone:\r\nttm_mem_global_release(glob);\r\nreturn ret;\r\n}\r\nvoid ttm_mem_global_release(struct ttm_mem_global *glob)\r\n{\r\nunsigned int i;\r\nstruct ttm_mem_zone *zone;\r\nttm_page_alloc_fini();\r\nttm_dma_page_alloc_fini();\r\nflush_workqueue(glob->swap_queue);\r\ndestroy_workqueue(glob->swap_queue);\r\nglob->swap_queue = NULL;\r\nfor (i = 0; i < glob->num_zones; ++i) {\r\nzone = glob->zones[i];\r\nkobject_del(&zone->kobj);\r\nkobject_put(&zone->kobj);\r\n}\r\nkobject_del(&glob->kobj);\r\nkobject_put(&glob->kobj);\r\n}\r\nstatic void ttm_check_swapping(struct ttm_mem_global *glob)\r\n{\r\nbool needs_swapping = false;\r\nunsigned int i;\r\nstruct ttm_mem_zone *zone;\r\nspin_lock(&glob->lock);\r\nfor (i = 0; i < glob->num_zones; ++i) {\r\nzone = glob->zones[i];\r\nif (zone->used_mem > zone->swap_limit) {\r\nneeds_swapping = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&glob->lock);\r\nif (unlikely(needs_swapping))\r\n(void)queue_work(glob->swap_queue, &glob->work);\r\n}\r\nstatic void ttm_mem_global_free_zone(struct ttm_mem_global *glob,\r\nstruct ttm_mem_zone *single_zone,\r\nuint64_t amount)\r\n{\r\nunsigned int i;\r\nstruct ttm_mem_zone *zone;\r\nspin_lock(&glob->lock);\r\nfor (i = 0; i < glob->num_zones; ++i) {\r\nzone = glob->zones[i];\r\nif (single_zone && zone != single_zone)\r\ncontinue;\r\nzone->used_mem -= amount;\r\n}\r\nspin_unlock(&glob->lock);\r\n}\r\nvoid ttm_mem_global_free(struct ttm_mem_global *glob,\r\nuint64_t amount)\r\n{\r\nreturn ttm_mem_global_free_zone(glob, NULL, amount);\r\n}\r\nstatic int ttm_mem_global_reserve(struct ttm_mem_global *glob,\r\nstruct ttm_mem_zone *single_zone,\r\nuint64_t amount, bool reserve)\r\n{\r\nuint64_t limit;\r\nint ret = -ENOMEM;\r\nunsigned int i;\r\nstruct ttm_mem_zone *zone;\r\nspin_lock(&glob->lock);\r\nfor (i = 0; i < glob->num_zones; ++i) {\r\nzone = glob->zones[i];\r\nif (single_zone && zone != single_zone)\r\ncontinue;\r\nlimit = (capable(CAP_SYS_ADMIN)) ?\r\nzone->emer_mem : zone->max_mem;\r\nif (zone->used_mem > limit)\r\ngoto out_unlock;\r\n}\r\nif (reserve) {\r\nfor (i = 0; i < glob->num_zones; ++i) {\r\nzone = glob->zones[i];\r\nif (single_zone && zone != single_zone)\r\ncontinue;\r\nzone->used_mem += amount;\r\n}\r\n}\r\nret = 0;\r\nout_unlock:\r\nspin_unlock(&glob->lock);\r\nttm_check_swapping(glob);\r\nreturn ret;\r\n}\r\nstatic int ttm_mem_global_alloc_zone(struct ttm_mem_global *glob,\r\nstruct ttm_mem_zone *single_zone,\r\nuint64_t memory,\r\nbool no_wait, bool interruptible)\r\n{\r\nint count = TTM_MEMORY_ALLOC_RETRIES;\r\nwhile (unlikely(ttm_mem_global_reserve(glob,\r\nsingle_zone,\r\nmemory, true)\r\n!= 0)) {\r\nif (no_wait)\r\nreturn -ENOMEM;\r\nif (unlikely(count-- == 0))\r\nreturn -ENOMEM;\r\nttm_shrink(glob, false, memory + (memory >> 2) + 16);\r\n}\r\nreturn 0;\r\n}\r\nint ttm_mem_global_alloc(struct ttm_mem_global *glob, uint64_t memory,\r\nbool no_wait, bool interruptible)\r\n{\r\nreturn ttm_mem_global_alloc_zone(glob, NULL, memory, no_wait,\r\ninterruptible);\r\n}\r\nint ttm_mem_global_alloc_page(struct ttm_mem_global *glob,\r\nstruct page *page,\r\nbool no_wait, bool interruptible)\r\n{\r\nstruct ttm_mem_zone *zone = NULL;\r\n#ifdef CONFIG_HIGHMEM\r\nif (PageHighMem(page) && glob->zone_highmem != NULL)\r\nzone = glob->zone_highmem;\r\n#else\r\nif (glob->zone_dma32 && page_to_pfn(page) > 0x00100000UL)\r\nzone = glob->zone_kernel;\r\n#endif\r\nreturn ttm_mem_global_alloc_zone(glob, zone, PAGE_SIZE, no_wait,\r\ninterruptible);\r\n}\r\nvoid ttm_mem_global_free_page(struct ttm_mem_global *glob, struct page *page)\r\n{\r\nstruct ttm_mem_zone *zone = NULL;\r\n#ifdef CONFIG_HIGHMEM\r\nif (PageHighMem(page) && glob->zone_highmem != NULL)\r\nzone = glob->zone_highmem;\r\n#else\r\nif (glob->zone_dma32 && page_to_pfn(page) > 0x00100000UL)\r\nzone = glob->zone_kernel;\r\n#endif\r\nttm_mem_global_free_zone(glob, zone, PAGE_SIZE);\r\n}\r\nsize_t ttm_round_pot(size_t size)\r\n{\r\nif ((size & (size - 1)) == 0)\r\nreturn size;\r\nelse if (size > PAGE_SIZE)\r\nreturn PAGE_ALIGN(size);\r\nelse {\r\nsize_t tmp_size = 4;\r\nwhile (tmp_size < size)\r\ntmp_size <<= 1;\r\nreturn tmp_size;\r\n}\r\nreturn 0;\r\n}
