static u32 __init kirkwood_get_tclk_freq(void __iomem *sar)\r\n{\r\nu32 opt = (readl(sar) >> SAR_KIRKWOOD_TCLK_FREQ) &\r\nSAR_KIRKWOOD_TCLK_FREQ_MASK;\r\nreturn (opt) ? 166666667 : 200000000;\r\n}\r\nstatic u32 __init kirkwood_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 opt = SAR_KIRKWOOD_CPU_FREQ(readl(sar));\r\nreturn kirkwood_cpu_freqs[opt];\r\n}\r\nstatic void __init kirkwood_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nswitch (id) {\r\ncase KIRKWOOD_CPU_TO_L2:\r\n{\r\nu32 opt = SAR_KIRKWOOD_L2_RATIO(readl(sar));\r\n*mult = kirkwood_cpu_l2_ratios[opt][0];\r\n*div = kirkwood_cpu_l2_ratios[opt][1];\r\nbreak;\r\n}\r\ncase KIRKWOOD_CPU_TO_DDR:\r\n{\r\nu32 opt = (readl(sar) >> SAR_KIRKWOOD_DDR_RATIO) &\r\nSAR_KIRKWOOD_DDR_RATIO_MASK;\r\n*mult = kirkwood_cpu_ddr_ratios[opt][0];\r\n*div = kirkwood_cpu_ddr_ratios[opt][1];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic u32 __init mv88f6180_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 opt = (readl(sar) >> SAR_MV88F6180_CLK) & SAR_MV88F6180_CLK_MASK;\r\nreturn mv88f6180_cpu_freqs[opt];\r\n}\r\nstatic void __init mv88f6180_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nswitch (id) {\r\ncase KIRKWOOD_CPU_TO_L2:\r\n{\r\n*mult = 1;\r\n*div = 2;\r\nbreak;\r\n}\r\ncase KIRKWOOD_CPU_TO_DDR:\r\n{\r\nu32 opt = (readl(sar) >> SAR_MV88F6180_CLK) &\r\nSAR_MV88F6180_CLK_MASK;\r\n*mult = mv88f6180_cpu_ddr_ratios[opt][0];\r\n*div = mv88f6180_cpu_ddr_ratios[opt][1];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void __init kirkwood_clk_init(struct device_node *np)\r\n{\r\nstruct device_node *cgnp =\r\nof_find_compatible_node(NULL, NULL, "marvell,kirkwood-gating-clock");\r\nif (of_device_is_compatible(np, "marvell,mv88f6180-core-clock"))\r\nmvebu_coreclk_setup(np, &mv88f6180_coreclks);\r\nelse\r\nmvebu_coreclk_setup(np, &kirkwood_coreclks);\r\nif (cgnp)\r\nmvebu_clk_gating_setup(cgnp, kirkwood_gating_desc);\r\n}
