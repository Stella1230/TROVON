static inline bool is_imx6q_phy(struct mxs_phy *mxs_phy)\r\n{\r\nreturn mxs_phy->data == &imx6q_phy_data;\r\n}\r\nstatic inline bool is_imx6sl_phy(struct mxs_phy *mxs_phy)\r\n{\r\nreturn mxs_phy->data == &imx6sl_phy_data;\r\n}\r\nstatic void mxs_phy_clock_switch_delay(void)\r\n{\r\nusleep_range(300, 400);\r\n}\r\nstatic int mxs_phy_hw_init(struct mxs_phy *mxs_phy)\r\n{\r\nint ret;\r\nvoid __iomem *base = mxs_phy->phy.io_priv;\r\nret = stmp_reset_block(base + HW_USBPHY_CTRL);\r\nif (ret)\r\nreturn ret;\r\nwritel(0, base + HW_USBPHY_PWD);\r\nwritel(BM_USBPHY_CTRL_ENAUTOSET_USBCLKS |\r\nBM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE |\r\nBM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD |\r\nBM_USBPHY_CTRL_ENAUTOCLR_CLKGATE |\r\nBM_USBPHY_CTRL_ENAUTO_PWRON_PLL |\r\nBM_USBPHY_CTRL_ENUTMILEVEL2 |\r\nBM_USBPHY_CTRL_ENUTMILEVEL3,\r\nbase + HW_USBPHY_CTRL_SET);\r\nif (mxs_phy->data->flags & MXS_PHY_NEED_IP_FIX)\r\nwritel(BM_USBPHY_IP_FIX, base + HW_USBPHY_IP_SET);\r\nreturn 0;\r\n}\r\nstatic bool mxs_phy_get_vbus_status(struct mxs_phy *mxs_phy)\r\n{\r\nunsigned int vbus_value;\r\nif (mxs_phy->port_id == 0)\r\nregmap_read(mxs_phy->regmap_anatop,\r\nANADIG_USB1_VBUS_DET_STAT,\r\n&vbus_value);\r\nelse if (mxs_phy->port_id == 1)\r\nregmap_read(mxs_phy->regmap_anatop,\r\nANADIG_USB2_VBUS_DET_STAT,\r\n&vbus_value);\r\nif (vbus_value & BM_ANADIG_USB1_VBUS_DET_STAT_VBUS_VALID)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void __mxs_phy_disconnect_line(struct mxs_phy *mxs_phy, bool disconnect)\r\n{\r\nvoid __iomem *base = mxs_phy->phy.io_priv;\r\nu32 reg;\r\nif (disconnect)\r\nwritel_relaxed(BM_USBPHY_DEBUG_CLKGATE,\r\nbase + HW_USBPHY_DEBUG_CLR);\r\nif (mxs_phy->port_id == 0) {\r\nreg = disconnect ? ANADIG_USB1_LOOPBACK_SET\r\n: ANADIG_USB1_LOOPBACK_CLR;\r\nregmap_write(mxs_phy->regmap_anatop, reg,\r\nBM_ANADIG_USB1_LOOPBACK_UTMI_DIG_TST1 |\r\nBM_ANADIG_USB1_LOOPBACK_TSTI_TX_EN);\r\n} else if (mxs_phy->port_id == 1) {\r\nreg = disconnect ? ANADIG_USB2_LOOPBACK_SET\r\n: ANADIG_USB2_LOOPBACK_CLR;\r\nregmap_write(mxs_phy->regmap_anatop, reg,\r\nBM_ANADIG_USB2_LOOPBACK_UTMI_DIG_TST1 |\r\nBM_ANADIG_USB2_LOOPBACK_TSTI_TX_EN);\r\n}\r\nif (!disconnect)\r\nwritel_relaxed(BM_USBPHY_DEBUG_CLKGATE,\r\nbase + HW_USBPHY_DEBUG_SET);\r\nif (disconnect)\r\nusleep_range(500, 1000);\r\n}\r\nstatic void mxs_phy_disconnect_line(struct mxs_phy *mxs_phy, bool on)\r\n{\r\nbool vbus_is_on = false;\r\nif (!(mxs_phy->data->flags & MXS_PHY_DISCONNECT_LINE_WITHOUT_VBUS))\r\nreturn;\r\nif (!mxs_phy->regmap_anatop)\r\nreturn;\r\nvbus_is_on = mxs_phy_get_vbus_status(mxs_phy);\r\nif (on && !vbus_is_on)\r\n__mxs_phy_disconnect_line(mxs_phy, true);\r\nelse\r\n__mxs_phy_disconnect_line(mxs_phy, false);\r\n}\r\nstatic int mxs_phy_init(struct usb_phy *phy)\r\n{\r\nint ret;\r\nstruct mxs_phy *mxs_phy = to_mxs_phy(phy);\r\nmxs_phy_clock_switch_delay();\r\nret = clk_prepare_enable(mxs_phy->clk);\r\nif (ret)\r\nreturn ret;\r\nreturn mxs_phy_hw_init(mxs_phy);\r\n}\r\nstatic void mxs_phy_shutdown(struct usb_phy *phy)\r\n{\r\nstruct mxs_phy *mxs_phy = to_mxs_phy(phy);\r\nwritel(BM_USBPHY_CTRL_CLKGATE,\r\nphy->io_priv + HW_USBPHY_CTRL_SET);\r\nclk_disable_unprepare(mxs_phy->clk);\r\n}\r\nstatic int mxs_phy_suspend(struct usb_phy *x, int suspend)\r\n{\r\nint ret;\r\nstruct mxs_phy *mxs_phy = to_mxs_phy(x);\r\nif (suspend) {\r\nwritel(0xffffffff, x->io_priv + HW_USBPHY_PWD);\r\nwritel(BM_USBPHY_CTRL_CLKGATE,\r\nx->io_priv + HW_USBPHY_CTRL_SET);\r\nclk_disable_unprepare(mxs_phy->clk);\r\n} else {\r\nmxs_phy_clock_switch_delay();\r\nret = clk_prepare_enable(mxs_phy->clk);\r\nif (ret)\r\nreturn ret;\r\nwritel(BM_USBPHY_CTRL_CLKGATE,\r\nx->io_priv + HW_USBPHY_CTRL_CLR);\r\nwritel(0, x->io_priv + HW_USBPHY_PWD);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_phy_set_wakeup(struct usb_phy *x, bool enabled)\r\n{\r\nstruct mxs_phy *mxs_phy = to_mxs_phy(x);\r\nu32 value = BM_USBPHY_CTRL_ENVBUSCHG_WKUP |\r\nBM_USBPHY_CTRL_ENDPDMCHG_WKUP |\r\nBM_USBPHY_CTRL_ENIDCHG_WKUP;\r\nif (enabled) {\r\nmxs_phy_disconnect_line(mxs_phy, true);\r\nwritel_relaxed(value, x->io_priv + HW_USBPHY_CTRL_SET);\r\n} else {\r\nwritel_relaxed(value, x->io_priv + HW_USBPHY_CTRL_CLR);\r\nmxs_phy_disconnect_line(mxs_phy, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_phy_on_connect(struct usb_phy *phy,\r\nenum usb_device_speed speed)\r\n{\r\ndev_dbg(phy->dev, "%s device has connected\n",\r\n(speed == USB_SPEED_HIGH) ? "HS" : "FS/LS");\r\nif (speed == USB_SPEED_HIGH)\r\nwritel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,\r\nphy->io_priv + HW_USBPHY_CTRL_SET);\r\nreturn 0;\r\n}\r\nstatic int mxs_phy_on_disconnect(struct usb_phy *phy,\r\nenum usb_device_speed speed)\r\n{\r\ndev_dbg(phy->dev, "%s device has disconnected\n",\r\n(speed == USB_SPEED_HIGH) ? "HS" : "FS/LS");\r\nif (speed == USB_SPEED_HIGH)\r\nwritel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,\r\nphy->io_priv + HW_USBPHY_CTRL_CLR);\r\nreturn 0;\r\n}\r\nstatic int mxs_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nstruct clk *clk;\r\nstruct mxs_phy *mxs_phy;\r\nint ret;\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxs_phy_dt_ids, &pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev,\r\n"can't get the clock, err=%ld", PTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nmxs_phy = devm_kzalloc(&pdev->dev, sizeof(*mxs_phy), GFP_KERNEL);\r\nif (!mxs_phy) {\r\ndev_err(&pdev->dev, "Failed to allocate USB PHY structure!\n");\r\nreturn -ENOMEM;\r\n}\r\nif (of_get_property(np, "fsl,anatop", NULL)) {\r\nmxs_phy->regmap_anatop = syscon_regmap_lookup_by_phandle\r\n(np, "fsl,anatop");\r\nif (IS_ERR(mxs_phy->regmap_anatop)) {\r\ndev_dbg(&pdev->dev,\r\n"failed to find regmap for anatop\n");\r\nreturn PTR_ERR(mxs_phy->regmap_anatop);\r\n}\r\n}\r\nret = of_alias_get_id(np, "usbphy");\r\nif (ret < 0)\r\ndev_dbg(&pdev->dev, "failed to get alias id, errno %d\n", ret);\r\nmxs_phy->port_id = ret;\r\nmxs_phy->phy.io_priv = base;\r\nmxs_phy->phy.dev = &pdev->dev;\r\nmxs_phy->phy.label = DRIVER_NAME;\r\nmxs_phy->phy.init = mxs_phy_init;\r\nmxs_phy->phy.shutdown = mxs_phy_shutdown;\r\nmxs_phy->phy.set_suspend = mxs_phy_suspend;\r\nmxs_phy->phy.notify_connect = mxs_phy_on_connect;\r\nmxs_phy->phy.notify_disconnect = mxs_phy_on_disconnect;\r\nmxs_phy->phy.type = USB_PHY_TYPE_USB2;\r\nmxs_phy->phy.set_wakeup = mxs_phy_set_wakeup;\r\nmxs_phy->clk = clk;\r\nmxs_phy->data = of_id->data;\r\nplatform_set_drvdata(pdev, mxs_phy);\r\ndevice_set_wakeup_capable(&pdev->dev, true);\r\nret = usb_add_phy_dev(&mxs_phy->phy);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mxs_phy_remove(struct platform_device *pdev)\r\n{\r\nstruct mxs_phy *mxs_phy = platform_get_drvdata(pdev);\r\nusb_remove_phy(&mxs_phy->phy);\r\nreturn 0;\r\n}\r\nstatic void mxs_phy_enable_ldo_in_suspend(struct mxs_phy *mxs_phy, bool on)\r\n{\r\nunsigned int reg = on ? ANADIG_ANA_MISC0_SET : ANADIG_ANA_MISC0_CLR;\r\nif (!mxs_phy->regmap_anatop)\r\nreturn;\r\nif (is_imx6q_phy(mxs_phy))\r\nregmap_write(mxs_phy->regmap_anatop, reg,\r\nBM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG);\r\nelse if (is_imx6sl_phy(mxs_phy))\r\nregmap_write(mxs_phy->regmap_anatop,\r\nreg, BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG_SL);\r\n}\r\nstatic int mxs_phy_system_suspend(struct device *dev)\r\n{\r\nstruct mxs_phy *mxs_phy = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nmxs_phy_enable_ldo_in_suspend(mxs_phy, true);\r\nreturn 0;\r\n}\r\nstatic int mxs_phy_system_resume(struct device *dev)\r\n{\r\nstruct mxs_phy *mxs_phy = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nmxs_phy_enable_ldo_in_suspend(mxs_phy, false);\r\nreturn 0;\r\n}\r\nstatic int __init mxs_phy_module_init(void)\r\n{\r\nreturn platform_driver_register(&mxs_phy_driver);\r\n}\r\nstatic void __exit mxs_phy_module_exit(void)\r\n{\r\nplatform_driver_unregister(&mxs_phy_driver);\r\n}
