static int aes_get_sizes(void)\r\n{\r\nstruct crypto_blkcipher *tfm;\r\ntfm = crypto_alloc_blkcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm)) {\r\npr_err("encrypted_key: failed to alloc_cipher (%ld)\n",\r\nPTR_ERR(tfm));\r\nreturn PTR_ERR(tfm);\r\n}\r\nivsize = crypto_blkcipher_ivsize(tfm);\r\nblksize = crypto_blkcipher_blocksize(tfm);\r\ncrypto_free_blkcipher(tfm);\r\nreturn 0;\r\n}\r\nstatic int valid_ecryptfs_desc(const char *ecryptfs_desc)\r\n{\r\nint i;\r\nif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\r\npr_err("encrypted_key: key description must be %d hexadecimal "\r\n"characters long\n", KEY_ECRYPTFS_DESC_LEN);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\r\nif (!isxdigit(ecryptfs_desc[i])) {\r\npr_err("encrypted_key: key description must contain "\r\n"only hexadecimal characters\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\r\n{\r\nif (!memcmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN)) {\r\nif (strlen(new_desc) == KEY_TRUSTED_PREFIX_LEN)\r\ngoto out;\r\nif (orig_desc)\r\nif (memcmp(new_desc, orig_desc, KEY_TRUSTED_PREFIX_LEN))\r\ngoto out;\r\n} else if (!memcmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN)) {\r\nif (strlen(new_desc) == KEY_USER_PREFIX_LEN)\r\ngoto out;\r\nif (orig_desc)\r\nif (memcmp(new_desc, orig_desc, KEY_USER_PREFIX_LEN))\r\ngoto out;\r\n} else\r\ngoto out;\r\nreturn 0;\r\nout:\r\nreturn -EINVAL;\r\n}\r\nstatic int datablob_parse(char *datablob, const char **format,\r\nchar **master_desc, char **decrypted_datalen,\r\nchar **hex_encoded_iv)\r\n{\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint ret = -EINVAL;\r\nint key_cmd;\r\nint key_format;\r\nchar *p, *keyword;\r\nkeyword = strsep(&datablob, " \t");\r\nif (!keyword) {\r\npr_info("encrypted_key: insufficient parameters specified\n");\r\nreturn ret;\r\n}\r\nkey_cmd = match_token(keyword, key_tokens, args);\r\np = strsep(&datablob, " \t");\r\nif (!p) {\r\npr_err("encrypted_key: insufficient parameters specified\n");\r\nreturn ret;\r\n}\r\nkey_format = match_token(p, key_format_tokens, args);\r\nswitch (key_format) {\r\ncase Opt_ecryptfs:\r\ncase Opt_default:\r\n*format = p;\r\n*master_desc = strsep(&datablob, " \t");\r\nbreak;\r\ncase Opt_error:\r\n*master_desc = p;\r\nbreak;\r\n}\r\nif (!*master_desc) {\r\npr_info("encrypted_key: master key parameter is missing\n");\r\ngoto out;\r\n}\r\nif (valid_master_desc(*master_desc, NULL) < 0) {\r\npr_info("encrypted_key: master key parameter \'%s\' "\r\n"is invalid\n", *master_desc);\r\ngoto out;\r\n}\r\nif (decrypted_datalen) {\r\n*decrypted_datalen = strsep(&datablob, " \t");\r\nif (!*decrypted_datalen) {\r\npr_info("encrypted_key: keylen parameter is missing\n");\r\ngoto out;\r\n}\r\n}\r\nswitch (key_cmd) {\r\ncase Opt_new:\r\nif (!decrypted_datalen) {\r\npr_info("encrypted_key: keyword \'%s\' not allowed "\r\n"when called from .update method\n", keyword);\r\nbreak;\r\n}\r\nret = 0;\r\nbreak;\r\ncase Opt_load:\r\nif (!decrypted_datalen) {\r\npr_info("encrypted_key: keyword \'%s\' not allowed "\r\n"when called from .update method\n", keyword);\r\nbreak;\r\n}\r\n*hex_encoded_iv = strsep(&datablob, " \t");\r\nif (!*hex_encoded_iv) {\r\npr_info("encrypted_key: hex blob is missing\n");\r\nbreak;\r\n}\r\nret = 0;\r\nbreak;\r\ncase Opt_update:\r\nif (decrypted_datalen) {\r\npr_info("encrypted_key: keyword \'%s\' not allowed "\r\n"when called from .instantiate method\n",\r\nkeyword);\r\nbreak;\r\n}\r\nret = 0;\r\nbreak;\r\ncase Opt_err:\r\npr_info("encrypted_key: keyword \'%s\' not recognized\n",\r\nkeyword);\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic char *datablob_format(struct encrypted_key_payload *epayload,\r\nsize_t asciiblob_len)\r\n{\r\nchar *ascii_buf, *bufp;\r\nu8 *iv = epayload->iv;\r\nint len;\r\nint i;\r\nascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\r\nif (!ascii_buf)\r\ngoto out;\r\nascii_buf[asciiblob_len] = '\0';\r\nlen = sprintf(ascii_buf, "%s %s %s ", epayload->format,\r\nepayload->master_desc, epayload->datalen);\r\nbufp = &ascii_buf[len];\r\nfor (i = 0; i < (asciiblob_len - len) / 2; i++)\r\nbufp = hex_byte_pack(bufp, iv[i]);\r\nout:\r\nreturn ascii_buf;\r\n}\r\nstatic struct key *request_user_key(const char *master_desc, u8 **master_key,\r\nsize_t *master_keylen)\r\n{\r\nstruct user_key_payload *upayload;\r\nstruct key *ukey;\r\nukey = request_key(&key_type_user, master_desc, NULL);\r\nif (IS_ERR(ukey))\r\ngoto error;\r\ndown_read(&ukey->sem);\r\nupayload = ukey->payload.data;\r\n*master_key = upayload->data;\r\n*master_keylen = upayload->datalen;\r\nerror:\r\nreturn ukey;\r\n}\r\nstatic struct sdesc *alloc_sdesc(struct crypto_shash *alg)\r\n{\r\nstruct sdesc *sdesc;\r\nint size;\r\nsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\r\nsdesc = kmalloc(size, GFP_KERNEL);\r\nif (!sdesc)\r\nreturn ERR_PTR(-ENOMEM);\r\nsdesc->shash.tfm = alg;\r\nsdesc->shash.flags = 0x0;\r\nreturn sdesc;\r\n}\r\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\r\nconst u8 *buf, unsigned int buflen)\r\n{\r\nstruct sdesc *sdesc;\r\nint ret;\r\nsdesc = alloc_sdesc(hmacalg);\r\nif (IS_ERR(sdesc)) {\r\npr_info("encrypted_key: can't alloc %s\n", hmac_alg);\r\nreturn PTR_ERR(sdesc);\r\n}\r\nret = crypto_shash_setkey(hmacalg, key, keylen);\r\nif (!ret)\r\nret = crypto_shash_digest(&sdesc->shash, buf, buflen, digest);\r\nkfree(sdesc);\r\nreturn ret;\r\n}\r\nstatic int calc_hash(u8 *digest, const u8 *buf, unsigned int buflen)\r\n{\r\nstruct sdesc *sdesc;\r\nint ret;\r\nsdesc = alloc_sdesc(hashalg);\r\nif (IS_ERR(sdesc)) {\r\npr_info("encrypted_key: can't alloc %s\n", hash_alg);\r\nreturn PTR_ERR(sdesc);\r\n}\r\nret = crypto_shash_digest(&sdesc->shash, buf, buflen, digest);\r\nkfree(sdesc);\r\nreturn ret;\r\n}\r\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\r\nconst u8 *master_key, size_t master_keylen)\r\n{\r\nu8 *derived_buf;\r\nunsigned int derived_buf_len;\r\nint ret;\r\nderived_buf_len = strlen("AUTH_KEY") + 1 + master_keylen;\r\nif (derived_buf_len < HASH_SIZE)\r\nderived_buf_len = HASH_SIZE;\r\nderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\r\nif (!derived_buf) {\r\npr_err("encrypted_key: out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nif (key_type)\r\nstrcpy(derived_buf, "AUTH_KEY");\r\nelse\r\nstrcpy(derived_buf, "ENC_KEY");\r\nmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\r\nmaster_keylen);\r\nret = calc_hash(derived_key, derived_buf, derived_buf_len);\r\nkfree(derived_buf);\r\nreturn ret;\r\n}\r\nstatic int init_blkcipher_desc(struct blkcipher_desc *desc, const u8 *key,\r\nunsigned int key_len, const u8 *iv,\r\nunsigned int ivsize)\r\n{\r\nint ret;\r\ndesc->tfm = crypto_alloc_blkcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(desc->tfm)) {\r\npr_err("encrypted_key: failed to load %s transform (%ld)\n",\r\nblkcipher_alg, PTR_ERR(desc->tfm));\r\nreturn PTR_ERR(desc->tfm);\r\n}\r\ndesc->flags = 0;\r\nret = crypto_blkcipher_setkey(desc->tfm, key, key_len);\r\nif (ret < 0) {\r\npr_err("encrypted_key: failed to setkey (%d)\n", ret);\r\ncrypto_free_blkcipher(desc->tfm);\r\nreturn ret;\r\n}\r\ncrypto_blkcipher_set_iv(desc->tfm, iv, ivsize);\r\nreturn 0;\r\n}\r\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\r\nu8 **master_key, size_t *master_keylen)\r\n{\r\nstruct key *mkey = NULL;\r\nif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\r\nKEY_TRUSTED_PREFIX_LEN)) {\r\nmkey = request_trusted_key(epayload->master_desc +\r\nKEY_TRUSTED_PREFIX_LEN,\r\nmaster_key, master_keylen);\r\n} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\r\nKEY_USER_PREFIX_LEN)) {\r\nmkey = request_user_key(epayload->master_desc +\r\nKEY_USER_PREFIX_LEN,\r\nmaster_key, master_keylen);\r\n} else\r\ngoto out;\r\nif (IS_ERR(mkey)) {\r\nint ret = PTR_ERR(mkey);\r\nif (ret == -ENOTSUPP)\r\npr_info("encrypted_key: key %s not supported",\r\nepayload->master_desc);\r\nelse\r\npr_info("encrypted_key: key %s not found",\r\nepayload->master_desc);\r\ngoto out;\r\n}\r\ndump_master_key(*master_key, *master_keylen);\r\nout:\r\nreturn mkey;\r\n}\r\nstatic int derived_key_encrypt(struct encrypted_key_payload *epayload,\r\nconst u8 *derived_key,\r\nunsigned int derived_keylen)\r\n{\r\nstruct scatterlist sg_in[2];\r\nstruct scatterlist sg_out[1];\r\nstruct blkcipher_desc desc;\r\nunsigned int encrypted_datalen;\r\nunsigned int padlen;\r\nchar pad[16];\r\nint ret;\r\nencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\r\npadlen = encrypted_datalen - epayload->decrypted_datalen;\r\nret = init_blkcipher_desc(&desc, derived_key, derived_keylen,\r\nepayload->iv, ivsize);\r\nif (ret < 0)\r\ngoto out;\r\ndump_decrypted_data(epayload);\r\nmemset(pad, 0, sizeof pad);\r\nsg_init_table(sg_in, 2);\r\nsg_set_buf(&sg_in[0], epayload->decrypted_data,\r\nepayload->decrypted_datalen);\r\nsg_set_buf(&sg_in[1], pad, padlen);\r\nsg_init_table(sg_out, 1);\r\nsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\r\nret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in, encrypted_datalen);\r\ncrypto_free_blkcipher(desc.tfm);\r\nif (ret < 0)\r\npr_err("encrypted_key: failed to encrypt (%d)\n", ret);\r\nelse\r\ndump_encrypted_data(epayload, encrypted_datalen);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int datablob_hmac_append(struct encrypted_key_payload *epayload,\r\nconst u8 *master_key, size_t master_keylen)\r\n{\r\nu8 derived_key[HASH_SIZE];\r\nu8 *digest;\r\nint ret;\r\nret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\r\nif (ret < 0)\r\ngoto out;\r\ndigest = epayload->format + epayload->datablob_len;\r\nret = calc_hmac(digest, derived_key, sizeof derived_key,\r\nepayload->format, epayload->datablob_len);\r\nif (!ret)\r\ndump_hmac(NULL, digest, HASH_SIZE);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int datablob_hmac_verify(struct encrypted_key_payload *epayload,\r\nconst u8 *format, const u8 *master_key,\r\nsize_t master_keylen)\r\n{\r\nu8 derived_key[HASH_SIZE];\r\nu8 digest[HASH_SIZE];\r\nint ret;\r\nchar *p;\r\nunsigned short len;\r\nret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\r\nif (ret < 0)\r\ngoto out;\r\nlen = epayload->datablob_len;\r\nif (!format) {\r\np = epayload->master_desc;\r\nlen -= strlen(epayload->format) + 1;\r\n} else\r\np = epayload->format;\r\nret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\r\nif (ret < 0)\r\ngoto out;\r\nret = memcmp(digest, epayload->format + epayload->datablob_len,\r\nsizeof digest);\r\nif (ret) {\r\nret = -EINVAL;\r\ndump_hmac("datablob",\r\nepayload->format + epayload->datablob_len,\r\nHASH_SIZE);\r\ndump_hmac("calc", digest, HASH_SIZE);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int derived_key_decrypt(struct encrypted_key_payload *epayload,\r\nconst u8 *derived_key,\r\nunsigned int derived_keylen)\r\n{\r\nstruct scatterlist sg_in[1];\r\nstruct scatterlist sg_out[2];\r\nstruct blkcipher_desc desc;\r\nunsigned int encrypted_datalen;\r\nchar pad[16];\r\nint ret;\r\nencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\r\nret = init_blkcipher_desc(&desc, derived_key, derived_keylen,\r\nepayload->iv, ivsize);\r\nif (ret < 0)\r\ngoto out;\r\ndump_encrypted_data(epayload, encrypted_datalen);\r\nmemset(pad, 0, sizeof pad);\r\nsg_init_table(sg_in, 1);\r\nsg_init_table(sg_out, 2);\r\nsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\r\nsg_set_buf(&sg_out[0], epayload->decrypted_data,\r\nepayload->decrypted_datalen);\r\nsg_set_buf(&sg_out[1], pad, sizeof pad);\r\nret = crypto_blkcipher_decrypt(&desc, sg_out, sg_in, encrypted_datalen);\r\ncrypto_free_blkcipher(desc.tfm);\r\nif (ret < 0)\r\ngoto out;\r\ndump_decrypted_data(epayload);\r\nout:\r\nreturn ret;\r\n}\r\nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\r\nconst char *format,\r\nconst char *master_desc,\r\nconst char *datalen)\r\n{\r\nstruct encrypted_key_payload *epayload = NULL;\r\nunsigned short datablob_len;\r\nunsigned short decrypted_datalen;\r\nunsigned short payload_datalen;\r\nunsigned int encrypted_datalen;\r\nunsigned int format_len;\r\nlong dlen;\r\nint ret;\r\nret = kstrtol(datalen, 10, &dlen);\r\nif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\r\nreturn ERR_PTR(-EINVAL);\r\nformat_len = (!format) ? strlen(key_format_default) : strlen(format);\r\ndecrypted_datalen = dlen;\r\npayload_datalen = decrypted_datalen;\r\nif (format && !strcmp(format, key_format_ecryptfs)) {\r\nif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\r\npr_err("encrypted_key: keylen for the ecryptfs format "\r\n"must be equal to %d bytes\n",\r\nECRYPTFS_MAX_KEY_BYTES);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ndecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\r\npayload_datalen = sizeof(struct ecryptfs_auth_tok);\r\n}\r\nencrypted_datalen = roundup(decrypted_datalen, blksize);\r\ndatablob_len = format_len + 1 + strlen(master_desc) + 1\r\n+ strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\r\nret = key_payload_reserve(key, payload_datalen + datablob_len\r\n+ HASH_SIZE + 1);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nepayload = kzalloc(sizeof(*epayload) + payload_datalen +\r\ndatablob_len + HASH_SIZE + 1, GFP_KERNEL);\r\nif (!epayload)\r\nreturn ERR_PTR(-ENOMEM);\r\nepayload->payload_datalen = payload_datalen;\r\nepayload->decrypted_datalen = decrypted_datalen;\r\nepayload->datablob_len = datablob_len;\r\nreturn epayload;\r\n}\r\nstatic int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\r\nconst char *format, const char *hex_encoded_iv)\r\n{\r\nstruct key *mkey;\r\nu8 derived_key[HASH_SIZE];\r\nu8 *master_key;\r\nu8 *hmac;\r\nconst char *hex_encoded_data;\r\nunsigned int encrypted_datalen;\r\nsize_t master_keylen;\r\nsize_t asciilen;\r\nint ret;\r\nencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\r\nasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\r\nif (strlen(hex_encoded_iv) != asciilen)\r\nreturn -EINVAL;\r\nhex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\r\nret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nret = hex2bin(epayload->encrypted_data, hex_encoded_data,\r\nencrypted_datalen);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nhmac = epayload->format + epayload->datablob_len;\r\nret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\r\nHASH_SIZE);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nmkey = request_master_key(epayload, &master_key, &master_keylen);\r\nif (IS_ERR(mkey))\r\nreturn PTR_ERR(mkey);\r\nret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\r\nif (ret < 0) {\r\npr_err("encrypted_key: bad hmac (%d)\n", ret);\r\ngoto out;\r\n}\r\nret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\r\nif (ret < 0)\r\ngoto out;\r\nret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\r\nif (ret < 0)\r\npr_err("encrypted_key: failed to decrypt key (%d)\n", ret);\r\nout:\r\nup_read(&mkey->sem);\r\nkey_put(mkey);\r\nreturn ret;\r\n}\r\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\r\nconst char *format, const char *master_desc,\r\nconst char *datalen)\r\n{\r\nunsigned int format_len;\r\nformat_len = (!format) ? strlen(key_format_default) : strlen(format);\r\nepayload->format = epayload->payload_data + epayload->payload_datalen;\r\nepayload->master_desc = epayload->format + format_len + 1;\r\nepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\r\nepayload->iv = epayload->datalen + strlen(datalen) + 1;\r\nepayload->encrypted_data = epayload->iv + ivsize + 1;\r\nepayload->decrypted_data = epayload->payload_data;\r\nif (!format)\r\nmemcpy(epayload->format, key_format_default, format_len);\r\nelse {\r\nif (!strcmp(format, key_format_ecryptfs))\r\nepayload->decrypted_data =\r\necryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\r\nmemcpy(epayload->format, format, format_len);\r\n}\r\nmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\r\nmemcpy(epayload->datalen, datalen, strlen(datalen));\r\n}\r\nstatic int encrypted_init(struct encrypted_key_payload *epayload,\r\nconst char *key_desc, const char *format,\r\nconst char *master_desc, const char *datalen,\r\nconst char *hex_encoded_iv)\r\n{\r\nint ret = 0;\r\nif (format && !strcmp(format, key_format_ecryptfs)) {\r\nret = valid_ecryptfs_desc(key_desc);\r\nif (ret < 0)\r\nreturn ret;\r\necryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\r\nkey_desc);\r\n}\r\n__ekey_init(epayload, format, master_desc, datalen);\r\nif (!hex_encoded_iv) {\r\nget_random_bytes(epayload->iv, ivsize);\r\nget_random_bytes(epayload->decrypted_data,\r\nepayload->decrypted_datalen);\r\n} else\r\nret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\r\nreturn ret;\r\n}\r\nstatic int encrypted_instantiate(struct key *key,\r\nstruct key_preparsed_payload *prep)\r\n{\r\nstruct encrypted_key_payload *epayload = NULL;\r\nchar *datablob = NULL;\r\nconst char *format = NULL;\r\nchar *master_desc = NULL;\r\nchar *decrypted_datalen = NULL;\r\nchar *hex_encoded_iv = NULL;\r\nsize_t datalen = prep->datalen;\r\nint ret;\r\nif (datalen <= 0 || datalen > 32767 || !prep->data)\r\nreturn -EINVAL;\r\ndatablob = kmalloc(datalen + 1, GFP_KERNEL);\r\nif (!datablob)\r\nreturn -ENOMEM;\r\ndatablob[datalen] = 0;\r\nmemcpy(datablob, prep->data, datalen);\r\nret = datablob_parse(datablob, &format, &master_desc,\r\n&decrypted_datalen, &hex_encoded_iv);\r\nif (ret < 0)\r\ngoto out;\r\nepayload = encrypted_key_alloc(key, format, master_desc,\r\ndecrypted_datalen);\r\nif (IS_ERR(epayload)) {\r\nret = PTR_ERR(epayload);\r\ngoto out;\r\n}\r\nret = encrypted_init(epayload, key->description, format, master_desc,\r\ndecrypted_datalen, hex_encoded_iv);\r\nif (ret < 0) {\r\nkfree(epayload);\r\ngoto out;\r\n}\r\nrcu_assign_keypointer(key, epayload);\r\nout:\r\nkfree(datablob);\r\nreturn ret;\r\n}\r\nstatic void encrypted_rcu_free(struct rcu_head *rcu)\r\n{\r\nstruct encrypted_key_payload *epayload;\r\nepayload = container_of(rcu, struct encrypted_key_payload, rcu);\r\nmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\r\nkfree(epayload);\r\n}\r\nstatic int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\r\n{\r\nstruct encrypted_key_payload *epayload = key->payload.data;\r\nstruct encrypted_key_payload *new_epayload;\r\nchar *buf;\r\nchar *new_master_desc = NULL;\r\nconst char *format = NULL;\r\nsize_t datalen = prep->datalen;\r\nint ret = 0;\r\nif (datalen <= 0 || datalen > 32767 || !prep->data)\r\nreturn -EINVAL;\r\nbuf = kmalloc(datalen + 1, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[datalen] = 0;\r\nmemcpy(buf, prep->data, datalen);\r\nret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\r\nif (ret < 0)\r\ngoto out;\r\nret = valid_master_desc(new_master_desc, epayload->master_desc);\r\nif (ret < 0)\r\ngoto out;\r\nnew_epayload = encrypted_key_alloc(key, epayload->format,\r\nnew_master_desc, epayload->datalen);\r\nif (IS_ERR(new_epayload)) {\r\nret = PTR_ERR(new_epayload);\r\ngoto out;\r\n}\r\n__ekey_init(new_epayload, epayload->format, new_master_desc,\r\nepayload->datalen);\r\nmemcpy(new_epayload->iv, epayload->iv, ivsize);\r\nmemcpy(new_epayload->payload_data, epayload->payload_data,\r\nepayload->payload_datalen);\r\nrcu_assign_keypointer(key, new_epayload);\r\ncall_rcu(&epayload->rcu, encrypted_rcu_free);\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic long encrypted_read(const struct key *key, char __user *buffer,\r\nsize_t buflen)\r\n{\r\nstruct encrypted_key_payload *epayload;\r\nstruct key *mkey;\r\nu8 *master_key;\r\nsize_t master_keylen;\r\nchar derived_key[HASH_SIZE];\r\nchar *ascii_buf;\r\nsize_t asciiblob_len;\r\nint ret;\r\nepayload = rcu_dereference_key(key);\r\nasciiblob_len = epayload->datablob_len + ivsize + 1\r\n+ roundup(epayload->decrypted_datalen, blksize)\r\n+ (HASH_SIZE * 2);\r\nif (!buffer || buflen < asciiblob_len)\r\nreturn asciiblob_len;\r\nmkey = request_master_key(epayload, &master_key, &master_keylen);\r\nif (IS_ERR(mkey))\r\nreturn PTR_ERR(mkey);\r\nret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\r\nif (ret < 0)\r\ngoto out;\r\nret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\r\nif (ret < 0)\r\ngoto out;\r\nret = datablob_hmac_append(epayload, master_key, master_keylen);\r\nif (ret < 0)\r\ngoto out;\r\nascii_buf = datablob_format(epayload, asciiblob_len);\r\nif (!ascii_buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nup_read(&mkey->sem);\r\nkey_put(mkey);\r\nif (copy_to_user(buffer, ascii_buf, asciiblob_len) != 0)\r\nret = -EFAULT;\r\nkfree(ascii_buf);\r\nreturn asciiblob_len;\r\nout:\r\nup_read(&mkey->sem);\r\nkey_put(mkey);\r\nreturn ret;\r\n}\r\nstatic void encrypted_destroy(struct key *key)\r\n{\r\nstruct encrypted_key_payload *epayload = key->payload.data;\r\nif (!epayload)\r\nreturn;\r\nmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\r\nkfree(key->payload.data);\r\n}\r\nstatic void encrypted_shash_release(void)\r\n{\r\nif (hashalg)\r\ncrypto_free_shash(hashalg);\r\nif (hmacalg)\r\ncrypto_free_shash(hmacalg);\r\n}\r\nstatic int __init encrypted_shash_alloc(void)\r\n{\r\nint ret;\r\nhmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(hmacalg)) {\r\npr_info("encrypted_key: could not allocate crypto %s\n",\r\nhmac_alg);\r\nreturn PTR_ERR(hmacalg);\r\n}\r\nhashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(hashalg)) {\r\npr_info("encrypted_key: could not allocate crypto %s\n",\r\nhash_alg);\r\nret = PTR_ERR(hashalg);\r\ngoto hashalg_fail;\r\n}\r\nreturn 0;\r\nhashalg_fail:\r\ncrypto_free_shash(hmacalg);\r\nreturn ret;\r\n}\r\nstatic int __init init_encrypted(void)\r\n{\r\nint ret;\r\nret = encrypted_shash_alloc();\r\nif (ret < 0)\r\nreturn ret;\r\nret = register_key_type(&key_type_encrypted);\r\nif (ret < 0)\r\ngoto out;\r\nreturn aes_get_sizes();\r\nout:\r\nencrypted_shash_release();\r\nreturn ret;\r\n}\r\nstatic void __exit cleanup_encrypted(void)\r\n{\r\nencrypted_shash_release();\r\nunregister_key_type(&key_type_encrypted);\r\n}
