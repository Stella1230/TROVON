static void exit_event_get_key(struct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nstruct event_key *key)\r\n{\r\nkey->info = 0;\r\nkey->key = perf_evsel__intval(evsel, sample, "exit_reason");\r\n}\r\nstatic bool kvm_exit_event(struct perf_evsel *evsel)\r\n{\r\nreturn !strcmp(evsel->name, "kvm:kvm_exit");\r\n}\r\nstatic bool exit_event_begin(struct perf_evsel *evsel,\r\nstruct perf_sample *sample, struct event_key *key)\r\n{\r\nif (kvm_exit_event(evsel)) {\r\nexit_event_get_key(evsel, sample, key);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool kvm_entry_event(struct perf_evsel *evsel)\r\n{\r\nreturn !strcmp(evsel->name, "kvm:kvm_entry");\r\n}\r\nstatic bool exit_event_end(struct perf_evsel *evsel,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct event_key *key __maybe_unused)\r\n{\r\nreturn kvm_entry_event(evsel);\r\n}\r\nstatic const char *get_exit_reason(struct perf_kvm_stat *kvm, u64 exit_code)\r\n{\r\nint i = kvm->exit_reasons_size;\r\nstruct exit_reasons_table *tbl = kvm->exit_reasons;\r\nwhile (i--) {\r\nif (tbl->exit_code == exit_code)\r\nreturn tbl->reason;\r\ntbl++;\r\n}\r\npr_err("unknown kvm exit code:%lld on %s\n",\r\n(unsigned long long)exit_code, kvm->exit_reasons_isa);\r\nreturn "UNKNOWN";\r\n}\r\nstatic void exit_event_decode_key(struct perf_kvm_stat *kvm,\r\nstruct event_key *key,\r\nchar decode[20])\r\n{\r\nconst char *exit_reason = get_exit_reason(kvm, key->key);\r\nscnprintf(decode, 20, "%s", exit_reason);\r\n}\r\nstatic void mmio_event_get_key(struct perf_evsel *evsel, struct perf_sample *sample,\r\nstruct event_key *key)\r\n{\r\nkey->key = perf_evsel__intval(evsel, sample, "gpa");\r\nkey->info = perf_evsel__intval(evsel, sample, "type");\r\n}\r\nstatic bool mmio_event_begin(struct perf_evsel *evsel,\r\nstruct perf_sample *sample, struct event_key *key)\r\n{\r\nif (kvm_exit_event(evsel))\r\nreturn true;\r\nif (!strcmp(evsel->name, "kvm:kvm_mmio") &&\r\nperf_evsel__intval(evsel, sample, "type") == KVM_TRACE_MMIO_WRITE) {\r\nmmio_event_get_key(evsel, sample, key);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool mmio_event_end(struct perf_evsel *evsel, struct perf_sample *sample,\r\nstruct event_key *key)\r\n{\r\nif (kvm_entry_event(evsel))\r\nreturn true;\r\nif (!strcmp(evsel->name, "kvm:kvm_mmio") &&\r\nperf_evsel__intval(evsel, sample, "type") == KVM_TRACE_MMIO_READ) {\r\nmmio_event_get_key(evsel, sample, key);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void mmio_event_decode_key(struct perf_kvm_stat *kvm __maybe_unused,\r\nstruct event_key *key,\r\nchar decode[20])\r\n{\r\nscnprintf(decode, 20, "%#lx:%s", (unsigned long)key->key,\r\nkey->info == KVM_TRACE_MMIO_WRITE ? "W" : "R");\r\n}\r\nstatic void ioport_event_get_key(struct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nstruct event_key *key)\r\n{\r\nkey->key = perf_evsel__intval(evsel, sample, "port");\r\nkey->info = perf_evsel__intval(evsel, sample, "rw");\r\n}\r\nstatic bool ioport_event_begin(struct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nstruct event_key *key)\r\n{\r\nif (!strcmp(evsel->name, "kvm:kvm_pio")) {\r\nioport_event_get_key(evsel, sample, key);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool ioport_event_end(struct perf_evsel *evsel,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct event_key *key __maybe_unused)\r\n{\r\nreturn kvm_entry_event(evsel);\r\n}\r\nstatic void ioport_event_decode_key(struct perf_kvm_stat *kvm __maybe_unused,\r\nstruct event_key *key,\r\nchar decode[20])\r\n{\r\nscnprintf(decode, 20, "%#llx:%s", (unsigned long long)key->key,\r\nkey->info ? "POUT" : "PIN");\r\n}\r\nstatic bool register_kvm_events_ops(struct perf_kvm_stat *kvm)\r\n{\r\nbool ret = true;\r\nif (!strcmp(kvm->report_event, "vmexit"))\r\nkvm->events_ops = &exit_events;\r\nelse if (!strcmp(kvm->report_event, "mmio"))\r\nkvm->events_ops = &mmio_events;\r\nelse if (!strcmp(kvm->report_event, "ioport"))\r\nkvm->events_ops = &ioport_events;\r\nelse {\r\npr_err("Unknown report event:%s\n", kvm->report_event);\r\nret = false;\r\n}\r\nreturn ret;\r\n}\r\nstatic void init_kvm_event_record(struct perf_kvm_stat *kvm)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < EVENTS_CACHE_SIZE; i++)\r\nINIT_LIST_HEAD(&kvm->kvm_events_cache[i]);\r\n}\r\nstatic void clear_events_cache_stats(struct list_head *kvm_events_cache)\r\n{\r\nstruct list_head *head;\r\nstruct kvm_event *event;\r\nunsigned int i;\r\nint j;\r\nfor (i = 0; i < EVENTS_CACHE_SIZE; i++) {\r\nhead = &kvm_events_cache[i];\r\nlist_for_each_entry(event, head, hash_entry) {\r\nevent->total.time = 0;\r\ninit_stats(&event->total.stats);\r\nfor (j = 0; j < event->max_vcpu; ++j) {\r\nevent->vcpu[j].time = 0;\r\ninit_stats(&event->vcpu[j].stats);\r\n}\r\n}\r\n}\r\n}\r\nstatic int kvm_events_hash_fn(u64 key)\r\n{\r\nreturn key & (EVENTS_CACHE_SIZE - 1);\r\n}\r\nstatic bool kvm_event_expand(struct kvm_event *event, int vcpu_id)\r\n{\r\nint old_max_vcpu = event->max_vcpu;\r\nvoid *prev;\r\nif (vcpu_id < event->max_vcpu)\r\nreturn true;\r\nwhile (event->max_vcpu <= vcpu_id)\r\nevent->max_vcpu += DEFAULT_VCPU_NUM;\r\nprev = event->vcpu;\r\nevent->vcpu = realloc(event->vcpu,\r\nevent->max_vcpu * sizeof(*event->vcpu));\r\nif (!event->vcpu) {\r\nfree(prev);\r\npr_err("Not enough memory\n");\r\nreturn false;\r\n}\r\nmemset(event->vcpu + old_max_vcpu, 0,\r\n(event->max_vcpu - old_max_vcpu) * sizeof(*event->vcpu));\r\nreturn true;\r\n}\r\nstatic struct kvm_event *kvm_alloc_init_event(struct event_key *key)\r\n{\r\nstruct kvm_event *event;\r\nevent = zalloc(sizeof(*event));\r\nif (!event) {\r\npr_err("Not enough memory\n");\r\nreturn NULL;\r\n}\r\nevent->key = *key;\r\ninit_stats(&event->total.stats);\r\nreturn event;\r\n}\r\nstatic struct kvm_event *find_create_kvm_event(struct perf_kvm_stat *kvm,\r\nstruct event_key *key)\r\n{\r\nstruct kvm_event *event;\r\nstruct list_head *head;\r\nBUG_ON(key->key == INVALID_KEY);\r\nhead = &kvm->kvm_events_cache[kvm_events_hash_fn(key->key)];\r\nlist_for_each_entry(event, head, hash_entry) {\r\nif (event->key.key == key->key && event->key.info == key->info)\r\nreturn event;\r\n}\r\nevent = kvm_alloc_init_event(key);\r\nif (!event)\r\nreturn NULL;\r\nlist_add(&event->hash_entry, head);\r\nreturn event;\r\n}\r\nstatic bool handle_begin_event(struct perf_kvm_stat *kvm,\r\nstruct vcpu_event_record *vcpu_record,\r\nstruct event_key *key, u64 timestamp)\r\n{\r\nstruct kvm_event *event = NULL;\r\nif (key->key != INVALID_KEY)\r\nevent = find_create_kvm_event(kvm, key);\r\nvcpu_record->last_event = event;\r\nvcpu_record->start_time = timestamp;\r\nreturn true;\r\n}\r\nstatic void\r\nkvm_update_event_stats(struct kvm_event_stats *kvm_stats, u64 time_diff)\r\n{\r\nkvm_stats->time += time_diff;\r\nupdate_stats(&kvm_stats->stats, time_diff);\r\n}\r\nstatic double kvm_event_rel_stddev(int vcpu_id, struct kvm_event *event)\r\n{\r\nstruct kvm_event_stats *kvm_stats = &event->total;\r\nif (vcpu_id != -1)\r\nkvm_stats = &event->vcpu[vcpu_id];\r\nreturn rel_stddev_stats(stddev_stats(&kvm_stats->stats),\r\navg_stats(&kvm_stats->stats));\r\n}\r\nstatic bool update_kvm_event(struct kvm_event *event, int vcpu_id,\r\nu64 time_diff)\r\n{\r\nif (vcpu_id == -1) {\r\nkvm_update_event_stats(&event->total, time_diff);\r\nreturn true;\r\n}\r\nif (!kvm_event_expand(event, vcpu_id))\r\nreturn false;\r\nkvm_update_event_stats(&event->vcpu[vcpu_id], time_diff);\r\nreturn true;\r\n}\r\nstatic bool handle_end_event(struct perf_kvm_stat *kvm,\r\nstruct vcpu_event_record *vcpu_record,\r\nstruct event_key *key,\r\nstruct perf_sample *sample)\r\n{\r\nstruct kvm_event *event;\r\nu64 time_begin, time_diff;\r\nint vcpu;\r\nif (kvm->trace_vcpu == -1)\r\nvcpu = -1;\r\nelse\r\nvcpu = vcpu_record->vcpu_id;\r\nevent = vcpu_record->last_event;\r\ntime_begin = vcpu_record->start_time;\r\nif (!time_begin)\r\nreturn true;\r\nif (!event && key->key == INVALID_KEY)\r\nreturn true;\r\nif (!event)\r\nevent = find_create_kvm_event(kvm, key);\r\nif (!event)\r\nreturn false;\r\nvcpu_record->last_event = NULL;\r\nvcpu_record->start_time = 0;\r\nif (sample->time < time_begin) {\r\npr_debug("End time before begin time; skipping event.\n");\r\nreturn true;\r\n}\r\ntime_diff = sample->time - time_begin;\r\nif (kvm->duration && time_diff > kvm->duration) {\r\nchar decode[32];\r\nkvm->events_ops->decode_key(kvm, &event->key, decode);\r\nif (strcmp(decode, "HLT")) {\r\npr_info("%" PRIu64 " VM %d, vcpu %d: %s event took %" PRIu64 "usec\n",\r\nsample->time, sample->pid, vcpu_record->vcpu_id,\r\ndecode, time_diff/1000);\r\n}\r\n}\r\nreturn update_kvm_event(event, vcpu, time_diff);\r\n}\r\nstatic\r\nstruct vcpu_event_record *per_vcpu_record(struct thread *thread,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nif (!thread->priv && kvm_entry_event(evsel)) {\r\nstruct vcpu_event_record *vcpu_record;\r\nvcpu_record = zalloc(sizeof(*vcpu_record));\r\nif (!vcpu_record) {\r\npr_err("%s: Not enough memory\n", __func__);\r\nreturn NULL;\r\n}\r\nvcpu_record->vcpu_id = perf_evsel__intval(evsel, sample, "vcpu_id");\r\nthread->priv = vcpu_record;\r\n}\r\nreturn thread->priv;\r\n}\r\nstatic bool handle_kvm_event(struct perf_kvm_stat *kvm,\r\nstruct thread *thread,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nstruct vcpu_event_record *vcpu_record;\r\nstruct event_key key = {.key = INVALID_KEY};\r\nvcpu_record = per_vcpu_record(thread, evsel, sample);\r\nif (!vcpu_record)\r\nreturn true;\r\nif ((kvm->trace_vcpu != -1) &&\r\n(kvm->trace_vcpu != vcpu_record->vcpu_id))\r\nreturn true;\r\nif (kvm->events_ops->is_begin_event(evsel, sample, &key))\r\nreturn handle_begin_event(kvm, vcpu_record, &key, sample->time);\r\nif (kvm->events_ops->is_end_event(evsel, sample, &key))\r\nreturn handle_end_event(kvm, vcpu_record, &key, sample);\r\nreturn true;\r\n}\r\nstatic bool select_key(struct perf_kvm_stat *kvm)\r\n{\r\nint i;\r\nfor (i = 0; keys[i].name; i++) {\r\nif (!strcmp(keys[i].name, kvm->sort_key)) {\r\nkvm->compare = keys[i].key;\r\nreturn true;\r\n}\r\n}\r\npr_err("Unknown compare key:%s\n", kvm->sort_key);\r\nreturn false;\r\n}\r\nstatic void insert_to_result(struct rb_root *result, struct kvm_event *event,\r\nkey_cmp_fun bigger, int vcpu)\r\n{\r\nstruct rb_node **rb = &result->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct kvm_event *p;\r\nwhile (*rb) {\r\np = container_of(*rb, struct kvm_event, rb);\r\nparent = *rb;\r\nif (bigger(event, p, vcpu))\r\nrb = &(*rb)->rb_left;\r\nelse\r\nrb = &(*rb)->rb_right;\r\n}\r\nrb_link_node(&event->rb, parent, rb);\r\nrb_insert_color(&event->rb, result);\r\n}\r\nstatic void\r\nupdate_total_count(struct perf_kvm_stat *kvm, struct kvm_event *event)\r\n{\r\nint vcpu = kvm->trace_vcpu;\r\nkvm->total_count += get_event_count(event, vcpu);\r\nkvm->total_time += get_event_time(event, vcpu);\r\n}\r\nstatic bool event_is_valid(struct kvm_event *event, int vcpu)\r\n{\r\nreturn !!get_event_count(event, vcpu);\r\n}\r\nstatic void sort_result(struct perf_kvm_stat *kvm)\r\n{\r\nunsigned int i;\r\nint vcpu = kvm->trace_vcpu;\r\nstruct kvm_event *event;\r\nfor (i = 0; i < EVENTS_CACHE_SIZE; i++) {\r\nlist_for_each_entry(event, &kvm->kvm_events_cache[i], hash_entry) {\r\nif (event_is_valid(event, vcpu)) {\r\nupdate_total_count(kvm, event);\r\ninsert_to_result(&kvm->result, event,\r\nkvm->compare, vcpu);\r\n}\r\n}\r\n}\r\n}\r\nstatic struct kvm_event *pop_from_result(struct rb_root *result)\r\n{\r\nstruct rb_node *node = rb_first(result);\r\nif (!node)\r\nreturn NULL;\r\nrb_erase(node, result);\r\nreturn container_of(node, struct kvm_event, rb);\r\n}\r\nstatic void print_vcpu_info(struct perf_kvm_stat *kvm)\r\n{\r\nint vcpu = kvm->trace_vcpu;\r\npr_info("Analyze events for ");\r\nif (kvm->live) {\r\nif (kvm->opts.target.system_wide)\r\npr_info("all VMs, ");\r\nelse if (kvm->opts.target.pid)\r\npr_info("pid(s) %s, ", kvm->opts.target.pid);\r\nelse\r\npr_info("dazed and confused on what is monitored, ");\r\n}\r\nif (vcpu == -1)\r\npr_info("all VCPUs:\n\n");\r\nelse\r\npr_info("VCPU %d:\n\n", vcpu);\r\n}\r\nstatic void show_timeofday(void)\r\n{\r\nchar date[64];\r\nstruct timeval tv;\r\nstruct tm ltime;\r\ngettimeofday(&tv, NULL);\r\nif (localtime_r(&tv.tv_sec, &ltime)) {\r\nstrftime(date, sizeof(date), "%H:%M:%S", &ltime);\r\npr_info("%s.%06ld", date, tv.tv_usec);\r\n} else\r\npr_info("00:00:00.000000");\r\nreturn;\r\n}\r\nstatic void print_result(struct perf_kvm_stat *kvm)\r\n{\r\nchar decode[20];\r\nstruct kvm_event *event;\r\nint vcpu = kvm->trace_vcpu;\r\nif (kvm->live) {\r\nputs(CONSOLE_CLEAR);\r\nshow_timeofday();\r\n}\r\npr_info("\n\n");\r\nprint_vcpu_info(kvm);\r\npr_info("%20s ", kvm->events_ops->name);\r\npr_info("%10s ", "Samples");\r\npr_info("%9s ", "Samples%");\r\npr_info("%9s ", "Time%");\r\npr_info("%10s ", "Min Time");\r\npr_info("%10s ", "Max Time");\r\npr_info("%16s ", "Avg time");\r\npr_info("\n\n");\r\nwhile ((event = pop_from_result(&kvm->result))) {\r\nu64 ecount, etime, max, min;\r\necount = get_event_count(event, vcpu);\r\netime = get_event_time(event, vcpu);\r\nmax = get_event_max(event, vcpu);\r\nmin = get_event_min(event, vcpu);\r\nkvm->events_ops->decode_key(kvm, &event->key, decode);\r\npr_info("%20s ", decode);\r\npr_info("%10llu ", (unsigned long long)ecount);\r\npr_info("%8.2f%% ", (double)ecount / kvm->total_count * 100);\r\npr_info("%8.2f%% ", (double)etime / kvm->total_time * 100);\r\npr_info("%8" PRIu64 "us ", min / 1000);\r\npr_info("%8" PRIu64 "us ", max / 1000);\r\npr_info("%9.2fus ( +-%7.2f%% )", (double)etime / ecount/1e3,\r\nkvm_event_rel_stddev(vcpu, event));\r\npr_info("\n");\r\n}\r\npr_info("\nTotal Samples:%" PRIu64 ", Total events handled time:%.2fus.\n\n",\r\nkvm->total_count, kvm->total_time / 1e3);\r\nif (kvm->lost_events)\r\npr_info("\nLost events: %" PRIu64 "\n\n", kvm->lost_events);\r\n}\r\nstatic int process_lost_event(struct perf_tool *tool,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct perf_kvm_stat *kvm = container_of(tool, struct perf_kvm_stat, tool);\r\nkvm->lost_events++;\r\nreturn 0;\r\n}\r\nstatic bool skip_sample(struct perf_kvm_stat *kvm,\r\nstruct perf_sample *sample)\r\n{\r\nif (kvm->pid_list && intlist__find(kvm->pid_list, sample->pid) == NULL)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int process_sample_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct thread *thread;\r\nstruct perf_kvm_stat *kvm = container_of(tool, struct perf_kvm_stat,\r\ntool);\r\nif (skip_sample(kvm, sample))\r\nreturn 0;\r\nthread = machine__findnew_thread(machine, sample->pid, sample->tid);\r\nif (thread == NULL) {\r\npr_debug("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (!handle_kvm_event(kvm, thread, evsel, sample))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int cpu_isa_config(struct perf_kvm_stat *kvm)\r\n{\r\nchar buf[64], *cpuid;\r\nint err, isa;\r\nif (kvm->live) {\r\nerr = get_cpuid(buf, sizeof(buf));\r\nif (err != 0) {\r\npr_err("Failed to look up CPU type (Intel or AMD)\n");\r\nreturn err;\r\n}\r\ncpuid = buf;\r\n} else\r\ncpuid = kvm->session->header.env.cpuid;\r\nif (strstr(cpuid, "Intel"))\r\nisa = 1;\r\nelse if (strstr(cpuid, "AMD"))\r\nisa = 0;\r\nelse {\r\npr_err("CPU %s is not supported.\n", cpuid);\r\nreturn -ENOTSUP;\r\n}\r\nif (isa == 1) {\r\nkvm->exit_reasons = vmx_exit_reasons;\r\nkvm->exit_reasons_size = ARRAY_SIZE(vmx_exit_reasons);\r\nkvm->exit_reasons_isa = "VMX";\r\n}\r\nreturn 0;\r\n}\r\nstatic bool verify_vcpu(int vcpu)\r\n{\r\nif (vcpu != -1 && vcpu < 0) {\r\npr_err("Invalid vcpu:%d.\n", vcpu);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic s64 perf_kvm__mmap_read_idx(struct perf_kvm_stat *kvm, int idx,\r\nu64 *mmap_time)\r\n{\r\nunion perf_event *event;\r\nstruct perf_sample sample;\r\ns64 n = 0;\r\nint err;\r\n*mmap_time = ULLONG_MAX;\r\nwhile ((event = perf_evlist__mmap_read(kvm->evlist, idx)) != NULL) {\r\nerr = perf_evlist__parse_sample(kvm->evlist, event, &sample);\r\nif (err) {\r\nperf_evlist__mmap_consume(kvm->evlist, idx);\r\npr_err("Failed to parse sample\n");\r\nreturn -1;\r\n}\r\nerr = perf_session_queue_event(kvm->session, event, &sample, 0);\r\nperf_evlist__mmap_consume(kvm->evlist, idx);\r\nif (err) {\r\npr_err("Failed to enqueue sample: %d\n", err);\r\nreturn -1;\r\n}\r\nif (n == 0)\r\n*mmap_time = sample.time;\r\nn++;\r\nif (n == PERF_KVM__MAX_EVENTS_PER_MMAP)\r\nbreak;\r\n}\r\nreturn n;\r\n}\r\nstatic int perf_kvm__mmap_read(struct perf_kvm_stat *kvm)\r\n{\r\nint i, err, throttled = 0;\r\ns64 n, ntotal = 0;\r\nu64 flush_time = ULLONG_MAX, mmap_time;\r\nfor (i = 0; i < kvm->evlist->nr_mmaps; i++) {\r\nn = perf_kvm__mmap_read_idx(kvm, i, &mmap_time);\r\nif (n < 0)\r\nreturn -1;\r\nif (mmap_time < flush_time)\r\nflush_time = mmap_time;\r\nntotal += n;\r\nif (n == PERF_KVM__MAX_EVENTS_PER_MMAP)\r\nthrottled = 1;\r\n}\r\nif (ntotal) {\r\nkvm->session->ordered_samples.next_flush = flush_time;\r\nerr = kvm->tool.finished_round(&kvm->tool, NULL, kvm->session);\r\nif (err) {\r\nif (kvm->lost_events)\r\npr_info("\nLost events: %" PRIu64 "\n\n",\r\nkvm->lost_events);\r\nreturn err;\r\n}\r\n}\r\nreturn throttled;\r\n}\r\nstatic void sig_handler(int sig __maybe_unused)\r\n{\r\ndone = 1;\r\n}\r\nstatic int perf_kvm__timerfd_create(struct perf_kvm_stat *kvm)\r\n{\r\nstruct itimerspec new_value;\r\nint rc = -1;\r\nkvm->timerfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK);\r\nif (kvm->timerfd < 0) {\r\npr_err("timerfd_create failed\n");\r\ngoto out;\r\n}\r\nnew_value.it_value.tv_sec = kvm->display_time;\r\nnew_value.it_value.tv_nsec = 0;\r\nnew_value.it_interval.tv_sec = kvm->display_time;\r\nnew_value.it_interval.tv_nsec = 0;\r\nif (timerfd_settime(kvm->timerfd, 0, &new_value, NULL) != 0) {\r\npr_err("timerfd_settime failed: %d\n", errno);\r\nclose(kvm->timerfd);\r\ngoto out;\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int perf_kvm__handle_timerfd(struct perf_kvm_stat *kvm)\r\n{\r\nuint64_t c;\r\nint rc;\r\nrc = read(kvm->timerfd, &c, sizeof(uint64_t));\r\nif (rc < 0) {\r\nif (errno == EAGAIN)\r\nreturn 0;\r\npr_err("Failed to read timer fd: %d\n", errno);\r\nreturn -1;\r\n}\r\nif (rc != sizeof(uint64_t)) {\r\npr_err("Error reading timer fd - invalid size returned\n");\r\nreturn -1;\r\n}\r\nif (c != 1)\r\npr_debug("Missed timer beats: %" PRIu64 "\n", c-1);\r\nsort_result(kvm);\r\nprint_result(kvm);\r\nclear_events_cache_stats(kvm->kvm_events_cache);\r\nkvm->total_count = 0;\r\nkvm->total_time = 0;\r\nkvm->lost_events = 0;\r\nreturn 0;\r\n}\r\nstatic int fd_set_nonblock(int fd)\r\n{\r\nlong arg = 0;\r\narg = fcntl(fd, F_GETFL);\r\nif (arg < 0) {\r\npr_err("Failed to get current flags for fd %d\n", fd);\r\nreturn -1;\r\n}\r\nif (fcntl(fd, F_SETFL, arg | O_NONBLOCK) < 0) {\r\npr_err("Failed to set non-block option on fd %d\n", fd);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nint perf_kvm__handle_stdin(struct termios *tc_now, struct termios *tc_save)\r\n{\r\nint c;\r\ntcsetattr(0, TCSANOW, tc_now);\r\nc = getc(stdin);\r\ntcsetattr(0, TCSAFLUSH, tc_save);\r\nif (c == 'q')\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int kvm_events_live_report(struct perf_kvm_stat *kvm)\r\n{\r\nstruct pollfd *pollfds = NULL;\r\nint nr_fds, nr_stdin, ret, err = -EINVAL;\r\nstruct termios tc, save;\r\nkvm->live = true;\r\nret = cpu_isa_config(kvm);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!verify_vcpu(kvm->trace_vcpu) ||\r\n!select_key(kvm) ||\r\n!register_kvm_events_ops(kvm)) {\r\ngoto out;\r\n}\r\ninit_kvm_event_record(kvm);\r\ntcgetattr(0, &save);\r\ntc = save;\r\ntc.c_lflag &= ~(ICANON | ECHO);\r\ntc.c_cc[VMIN] = 0;\r\ntc.c_cc[VTIME] = 0;\r\nsignal(SIGINT, sig_handler);\r\nsignal(SIGTERM, sig_handler);\r\nnr_fds = kvm->evlist->nr_fds;\r\npollfds = zalloc(sizeof(struct pollfd) * (nr_fds + 2));\r\nif (!pollfds) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(pollfds, kvm->evlist->pollfd,\r\nsizeof(struct pollfd) * kvm->evlist->nr_fds);\r\nif (perf_kvm__timerfd_create(kvm) < 0) {\r\nerr = -1;\r\ngoto out;\r\n}\r\npollfds[nr_fds].fd = kvm->timerfd;\r\npollfds[nr_fds].events = POLLIN;\r\nnr_fds++;\r\npollfds[nr_fds].fd = fileno(stdin);\r\npollfds[nr_fds].events = POLLIN;\r\nnr_stdin = nr_fds;\r\nnr_fds++;\r\nif (fd_set_nonblock(fileno(stdin)) != 0)\r\ngoto out;\r\nperf_evlist__enable(kvm->evlist);\r\nwhile (!done) {\r\nint rc;\r\nrc = perf_kvm__mmap_read(kvm);\r\nif (rc < 0)\r\nbreak;\r\nerr = perf_kvm__handle_timerfd(kvm);\r\nif (err)\r\ngoto out;\r\nif (pollfds[nr_stdin].revents & POLLIN)\r\ndone = perf_kvm__handle_stdin(&tc, &save);\r\nif (!rc && !done)\r\nerr = poll(pollfds, nr_fds, 100);\r\n}\r\nperf_evlist__disable(kvm->evlist);\r\nif (err == 0) {\r\nsort_result(kvm);\r\nprint_result(kvm);\r\n}\r\nout:\r\nif (kvm->timerfd >= 0)\r\nclose(kvm->timerfd);\r\nfree(pollfds);\r\nreturn err;\r\n}\r\nstatic int kvm_live_open_events(struct perf_kvm_stat *kvm)\r\n{\r\nint err, rc = -1;\r\nstruct perf_evsel *pos;\r\nstruct perf_evlist *evlist = kvm->evlist;\r\nperf_evlist__config(evlist, &kvm->opts);\r\nevlist__for_each(evlist, pos) {\r\nstruct perf_event_attr *attr = &pos->attr;\r\nperf_evsel__set_sample_bit(pos, TID);\r\nperf_evsel__set_sample_bit(pos, TIME);\r\nperf_evsel__set_sample_bit(pos, CPU);\r\nperf_evsel__set_sample_bit(pos, RAW);\r\nperf_evsel__reset_sample_bit(pos, PERIOD);\r\nperf_evsel__reset_sample_bit(pos, IP);\r\nperf_evsel__reset_sample_bit(pos, CALLCHAIN);\r\nperf_evsel__reset_sample_bit(pos, ADDR);\r\nperf_evsel__reset_sample_bit(pos, READ);\r\nattr->mmap = 0;\r\nattr->comm = 0;\r\nattr->task = 0;\r\nattr->sample_period = 1;\r\nattr->watermark = 0;\r\nattr->wakeup_events = 1000;\r\nattr->disabled = 1;\r\n}\r\nerr = perf_evlist__open(evlist);\r\nif (err < 0) {\r\nprintf("Couldn't create the events: %s\n", strerror(errno));\r\ngoto out;\r\n}\r\nif (perf_evlist__mmap(evlist, kvm->opts.mmap_pages, false) < 0) {\r\nui__error("Failed to mmap the events: %s\n", strerror(errno));\r\nperf_evlist__close(evlist);\r\ngoto out;\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int read_events(struct perf_kvm_stat *kvm)\r\n{\r\nint ret;\r\nstruct perf_tool eops = {\r\n.sample = process_sample_event,\r\n.comm = perf_event__process_comm,\r\n.ordered_samples = true,\r\n};\r\nstruct perf_data_file file = {\r\n.path = kvm->file_name,\r\n.mode = PERF_DATA_MODE_READ,\r\n};\r\nkvm->tool = eops;\r\nkvm->session = perf_session__new(&file, false, &kvm->tool);\r\nif (!kvm->session) {\r\npr_err("Initializing perf session failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (!perf_session__has_traces(kvm->session, "kvm record"))\r\nreturn -EINVAL;\r\nret = cpu_isa_config(kvm);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn perf_session__process_events(kvm->session, &kvm->tool);\r\n}\r\nstatic int parse_target_str(struct perf_kvm_stat *kvm)\r\n{\r\nif (kvm->pid_str) {\r\nkvm->pid_list = intlist__new(kvm->pid_str);\r\nif (kvm->pid_list == NULL) {\r\npr_err("Error parsing process id string\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvm_events_report_vcpu(struct perf_kvm_stat *kvm)\r\n{\r\nint ret = -EINVAL;\r\nint vcpu = kvm->trace_vcpu;\r\nif (parse_target_str(kvm) != 0)\r\ngoto exit;\r\nif (!verify_vcpu(vcpu))\r\ngoto exit;\r\nif (!select_key(kvm))\r\ngoto exit;\r\nif (!register_kvm_events_ops(kvm))\r\ngoto exit;\r\ninit_kvm_event_record(kvm);\r\nsetup_pager();\r\nret = read_events(kvm);\r\nif (ret)\r\ngoto exit;\r\nsort_result(kvm);\r\nprint_result(kvm);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int\r\nkvm_events_record(struct perf_kvm_stat *kvm, int argc, const char **argv)\r\n{\r\nunsigned int rec_argc, i, j;\r\nconst char **rec_argv;\r\nconst char * const record_args[] = {\r\n"record",\r\n"-R",\r\n"-m", "1024",\r\n"-c", "1",\r\n};\r\nrec_argc = ARRAY_SIZE(record_args) + argc + 2 +\r\n2 * ARRAY_SIZE(kvm_events_tp);\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nif (rec_argv == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(record_args); i++)\r\nrec_argv[i] = STRDUP_FAIL_EXIT(record_args[i]);\r\nfor (j = 0; j < ARRAY_SIZE(kvm_events_tp); j++) {\r\nrec_argv[i++] = "-e";\r\nrec_argv[i++] = STRDUP_FAIL_EXIT(kvm_events_tp[j]);\r\n}\r\nrec_argv[i++] = STRDUP_FAIL_EXIT("-o");\r\nrec_argv[i++] = STRDUP_FAIL_EXIT(kvm->file_name);\r\nfor (j = 1; j < (unsigned int)argc; j++, i++)\r\nrec_argv[i] = argv[j];\r\nreturn cmd_record(i, rec_argv, NULL);\r\n}\r\nstatic int\r\nkvm_events_report(struct perf_kvm_stat *kvm, int argc, const char **argv)\r\n{\r\nconst struct option kvm_events_report_options[] = {\r\nOPT_STRING(0, "event", &kvm->report_event, "report event",\r\n"event for reporting: vmexit, mmio, ioport"),\r\nOPT_INTEGER(0, "vcpu", &kvm->trace_vcpu,\r\n"vcpu id to report"),\r\nOPT_STRING('k', "key", &kvm->sort_key, "sort-key",\r\n"key for sorting: sample(sort by samples number)"\r\n" time (sort by avg time)"),\r\nOPT_STRING('p', "pid", &kvm->pid_str, "pid",\r\n"analyze events only for given process id(s)"),\r\nOPT_END()\r\n};\r\nconst char * const kvm_events_report_usage[] = {\r\n"perf kvm stat report [<options>]",\r\nNULL\r\n};\r\nsymbol__init();\r\nif (argc) {\r\nargc = parse_options(argc, argv,\r\nkvm_events_report_options,\r\nkvm_events_report_usage, 0);\r\nif (argc)\r\nusage_with_options(kvm_events_report_usage,\r\nkvm_events_report_options);\r\n}\r\nreturn kvm_events_report_vcpu(kvm);\r\n}\r\nstatic struct perf_evlist *kvm_live_event_list(void)\r\n{\r\nstruct perf_evlist *evlist;\r\nchar *tp, *name, *sys;\r\nunsigned int j;\r\nint err = -1;\r\nevlist = perf_evlist__new();\r\nif (evlist == NULL)\r\nreturn NULL;\r\nfor (j = 0; j < ARRAY_SIZE(kvm_events_tp); j++) {\r\ntp = strdup(kvm_events_tp[j]);\r\nif (tp == NULL)\r\ngoto out;\r\nsys = tp;\r\nname = strchr(tp, ':');\r\nif (name == NULL) {\r\npr_err("Error parsing %s tracepoint: subsystem delimiter not found\n",\r\nkvm_events_tp[j]);\r\nfree(tp);\r\ngoto out;\r\n}\r\n*name = '\0';\r\nname++;\r\nif (perf_evlist__add_newtp(evlist, sys, name, NULL)) {\r\npr_err("Failed to add %s tracepoint to the list\n", kvm_events_tp[j]);\r\nfree(tp);\r\ngoto out;\r\n}\r\nfree(tp);\r\n}\r\nerr = 0;\r\nout:\r\nif (err) {\r\nperf_evlist__delete(evlist);\r\nevlist = NULL;\r\n}\r\nreturn evlist;\r\n}\r\nstatic int kvm_events_live(struct perf_kvm_stat *kvm,\r\nint argc, const char **argv)\r\n{\r\nchar errbuf[BUFSIZ];\r\nint err;\r\nconst struct option live_options[] = {\r\nOPT_STRING('p', "pid", &kvm->opts.target.pid, "pid",\r\n"record events on existing process id"),\r\nOPT_CALLBACK('m', "mmap-pages", &kvm->opts.mmap_pages, "pages",\r\n"number of mmap data pages",\r\nperf_evlist__parse_mmap_pages),\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show counter open errors, etc)"),\r\nOPT_BOOLEAN('a', "all-cpus", &kvm->opts.target.system_wide,\r\n"system-wide collection from all CPUs"),\r\nOPT_UINTEGER('d', "display", &kvm->display_time,\r\n"time in seconds between display updates"),\r\nOPT_STRING(0, "event", &kvm->report_event, "report event",\r\n"event for reporting: vmexit, mmio, ioport"),\r\nOPT_INTEGER(0, "vcpu", &kvm->trace_vcpu,\r\n"vcpu id to report"),\r\nOPT_STRING('k', "key", &kvm->sort_key, "sort-key",\r\n"key for sorting: sample(sort by samples number)"\r\n" time (sort by avg time)"),\r\nOPT_U64(0, "duration", &kvm->duration,\r\n"show events other than HALT that take longer than duration usecs"),\r\nOPT_END()\r\n};\r\nconst char * const live_usage[] = {\r\n"perf kvm stat live [<options>]",\r\nNULL\r\n};\r\nstruct perf_data_file file = {\r\n.mode = PERF_DATA_MODE_WRITE,\r\n};\r\nkvm->tool.sample = process_sample_event;\r\nkvm->tool.comm = perf_event__process_comm;\r\nkvm->tool.exit = perf_event__process_exit;\r\nkvm->tool.fork = perf_event__process_fork;\r\nkvm->tool.lost = process_lost_event;\r\nkvm->tool.ordered_samples = true;\r\nperf_tool__fill_defaults(&kvm->tool);\r\nkvm->display_time = 1;\r\nkvm->opts.user_interval = 1;\r\nkvm->opts.mmap_pages = 512;\r\nkvm->opts.target.uses_mmap = false;\r\nkvm->opts.target.uid_str = NULL;\r\nkvm->opts.target.uid = UINT_MAX;\r\nsymbol__init();\r\ndisable_buildid_cache();\r\nuse_browser = 0;\r\nsetup_browser(false);\r\nif (argc) {\r\nargc = parse_options(argc, argv, live_options,\r\nlive_usage, 0);\r\nif (argc)\r\nusage_with_options(live_usage, live_options);\r\n}\r\nkvm->duration *= NSEC_PER_USEC;\r\nerr = target__validate(&kvm->opts.target);\r\nif (err) {\r\ntarget__strerror(&kvm->opts.target, err, errbuf, BUFSIZ);\r\nui__warning("%s", errbuf);\r\n}\r\nif (target__none(&kvm->opts.target))\r\nkvm->opts.target.system_wide = true;\r\nkvm->evlist = kvm_live_event_list();\r\nif (kvm->evlist == NULL) {\r\nerr = -1;\r\ngoto out;\r\n}\r\nsymbol_conf.nr_events = kvm->evlist->nr_entries;\r\nif (perf_evlist__create_maps(kvm->evlist, &kvm->opts.target) < 0)\r\nusage_with_options(live_usage, live_options);\r\nkvm->session = perf_session__new(&file, false, &kvm->tool);\r\nif (kvm->session == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nkvm->session->evlist = kvm->evlist;\r\nperf_session__set_id_hdr_size(kvm->session);\r\nmachine__synthesize_threads(&kvm->session->machines.host, &kvm->opts.target,\r\nkvm->evlist->threads, false);\r\nerr = kvm_live_open_events(kvm);\r\nif (err)\r\ngoto out;\r\nerr = kvm_events_live_report(kvm);\r\nout:\r\nexit_browser(0);\r\nif (kvm->session)\r\nperf_session__delete(kvm->session);\r\nkvm->session = NULL;\r\nif (kvm->evlist)\r\nperf_evlist__delete(kvm->evlist);\r\nreturn err;\r\n}\r\nstatic void print_kvm_stat_usage(void)\r\n{\r\nprintf("Usage: perf kvm stat <command>\n\n");\r\nprintf("# Available commands:\n");\r\nprintf("\trecord: record kvm events\n");\r\nprintf("\treport: report statistical data of kvm events\n");\r\nprintf("\tlive: live reporting of statistical data of kvm events\n");\r\nprintf("\nOtherwise, it is the alias of 'perf stat':\n");\r\n}\r\nstatic int kvm_cmd_stat(const char *file_name, int argc, const char **argv)\r\n{\r\nstruct perf_kvm_stat kvm = {\r\n.file_name = file_name,\r\n.trace_vcpu = -1,\r\n.report_event = "vmexit",\r\n.sort_key = "sample",\r\n.exit_reasons = svm_exit_reasons,\r\n.exit_reasons_size = ARRAY_SIZE(svm_exit_reasons),\r\n.exit_reasons_isa = "SVM",\r\n};\r\nif (argc == 1) {\r\nprint_kvm_stat_usage();\r\ngoto perf_stat;\r\n}\r\nif (!strncmp(argv[1], "rec", 3))\r\nreturn kvm_events_record(&kvm, argc - 1, argv + 1);\r\nif (!strncmp(argv[1], "rep", 3))\r\nreturn kvm_events_report(&kvm, argc - 1 , argv + 1);\r\n#ifdef HAVE_TIMERFD_SUPPORT\r\nif (!strncmp(argv[1], "live", 4))\r\nreturn kvm_events_live(&kvm, argc - 1 , argv + 1);\r\n#endif\r\nperf_stat:\r\nreturn cmd_stat(argc, argv, NULL);\r\n}\r\nstatic int __cmd_record(const char *file_name, int argc, const char **argv)\r\n{\r\nint rec_argc, i = 0, j;\r\nconst char **rec_argv;\r\nrec_argc = argc + 2;\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nrec_argv[i++] = strdup("record");\r\nrec_argv[i++] = strdup("-o");\r\nrec_argv[i++] = strdup(file_name);\r\nfor (j = 1; j < argc; j++, i++)\r\nrec_argv[i] = argv[j];\r\nBUG_ON(i != rec_argc);\r\nreturn cmd_record(i, rec_argv, NULL);\r\n}\r\nstatic int __cmd_report(const char *file_name, int argc, const char **argv)\r\n{\r\nint rec_argc, i = 0, j;\r\nconst char **rec_argv;\r\nrec_argc = argc + 2;\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nrec_argv[i++] = strdup("report");\r\nrec_argv[i++] = strdup("-i");\r\nrec_argv[i++] = strdup(file_name);\r\nfor (j = 1; j < argc; j++, i++)\r\nrec_argv[i] = argv[j];\r\nBUG_ON(i != rec_argc);\r\nreturn cmd_report(i, rec_argv, NULL);\r\n}\r\nstatic int\r\n__cmd_buildid_list(const char *file_name, int argc, const char **argv)\r\n{\r\nint rec_argc, i = 0, j;\r\nconst char **rec_argv;\r\nrec_argc = argc + 2;\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nrec_argv[i++] = strdup("buildid-list");\r\nrec_argv[i++] = strdup("-i");\r\nrec_argv[i++] = strdup(file_name);\r\nfor (j = 1; j < argc; j++, i++)\r\nrec_argv[i] = argv[j];\r\nBUG_ON(i != rec_argc);\r\nreturn cmd_buildid_list(i, rec_argv, NULL);\r\n}\r\nint cmd_kvm(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nconst char *file_name = NULL;\r\nconst struct option kvm_options[] = {\r\nOPT_STRING('i', "input", &file_name, "file",\r\n"Input file name"),\r\nOPT_STRING('o', "output", &file_name, "file",\r\n"Output file name"),\r\nOPT_BOOLEAN(0, "guest", &perf_guest,\r\n"Collect guest os data"),\r\nOPT_BOOLEAN(0, "host", &perf_host,\r\n"Collect host os data"),\r\nOPT_STRING(0, "guestmount", &symbol_conf.guestmount, "directory",\r\n"guest mount directory under which every guest os"\r\n" instance has a subdir"),\r\nOPT_STRING(0, "guestvmlinux", &symbol_conf.default_guest_vmlinux_name,\r\n"file", "file saving guest os vmlinux"),\r\nOPT_STRING(0, "guestkallsyms", &symbol_conf.default_guest_kallsyms,\r\n"file", "file saving guest os /proc/kallsyms"),\r\nOPT_STRING(0, "guestmodules", &symbol_conf.default_guest_modules,\r\n"file", "file saving guest os /proc/modules"),\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show counter open errors, etc)"),\r\nOPT_END()\r\n};\r\nconst char *const kvm_subcommands[] = { "top", "record", "report", "diff",\r\n"buildid-list", "stat", NULL };\r\nconst char *kvm_usage[] = { NULL, NULL };\r\nperf_host = 0;\r\nperf_guest = 1;\r\nargc = parse_options_subcommand(argc, argv, kvm_options, kvm_subcommands, kvm_usage,\r\nPARSE_OPT_STOP_AT_NON_OPTION);\r\nif (!argc)\r\nusage_with_options(kvm_usage, kvm_options);\r\nif (!perf_host)\r\nperf_guest = 1;\r\nif (!file_name) {\r\nfile_name = get_filename_for_perf_kvm();\r\nif (!file_name) {\r\npr_err("Failed to allocate memory for filename\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (!strncmp(argv[0], "rec", 3))\r\nreturn __cmd_record(file_name, argc, argv);\r\nelse if (!strncmp(argv[0], "rep", 3))\r\nreturn __cmd_report(file_name, argc, argv);\r\nelse if (!strncmp(argv[0], "diff", 4))\r\nreturn cmd_diff(argc, argv, NULL);\r\nelse if (!strncmp(argv[0], "top", 3))\r\nreturn cmd_top(argc, argv, NULL);\r\nelse if (!strncmp(argv[0], "buildid-list", 12))\r\nreturn __cmd_buildid_list(file_name, argc, argv);\r\n#if defined(__i386__) || defined(__x86_64__)\r\nelse if (!strncmp(argv[0], "stat", 4))\r\nreturn kvm_cmd_stat(file_name, argc, argv);\r\n#endif\r\nelse\r\nusage_with_options(kvm_usage, kvm_options);\r\nreturn 0;\r\n}
