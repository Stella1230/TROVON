static inline int try_write_address(struct i2c_adapter *i2c_adap,\r\nunsigned char addr, int retries)\r\n{\r\nstruct usb_usbvision *usbvision;\r\nint i, ret = -1;\r\nchar buf[4];\r\nusbvision = (struct usb_usbvision *)i2c_get_adapdata(i2c_adap);\r\nbuf[0] = 0x00;\r\nfor (i = 0; i <= retries; i++) {\r\nret = (usbvision_i2c_write(usbvision, addr, buf, 1));\r\nif (ret == 1)\r\nbreak;\r\nudelay(5);\r\nif (i == retries)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i) {\r\nPDEBUG(DBG_I2C, "Needed %d retries for address %#2x", i, addr);\r\nPDEBUG(DBG_I2C, "Maybe there's no device at this address");\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int try_read_address(struct i2c_adapter *i2c_adap,\r\nunsigned char addr, int retries)\r\n{\r\nstruct usb_usbvision *usbvision;\r\nint i, ret = -1;\r\nchar buf[4];\r\nusbvision = (struct usb_usbvision *)i2c_get_adapdata(i2c_adap);\r\nfor (i = 0; i <= retries; i++) {\r\nret = (usbvision_i2c_read(usbvision, addr, buf, 1));\r\nif (ret == 1)\r\nbreak;\r\nudelay(5);\r\nif (i == retries)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i) {\r\nPDEBUG(DBG_I2C, "Needed %d retries for address %#2x", i, addr);\r\nPDEBUG(DBG_I2C, "Maybe there's no device at this address");\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int usb_find_address(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msg, int retries,\r\nunsigned char *add)\r\n{\r\nunsigned short flags = msg->flags;\r\nunsigned char addr;\r\nint ret;\r\naddr = (msg->addr << 1);\r\nif (flags & I2C_M_RD)\r\naddr |= 1;\r\nadd[0] = addr;\r\nif (flags & I2C_M_RD)\r\nret = try_read_address(i2c_adap, addr, retries);\r\nelse\r\nret = try_write_address(i2c_adap, addr, retries);\r\nif (ret != 1)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nusbvision_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct i2c_msg *pmsg;\r\nstruct usb_usbvision *usbvision;\r\nint i, ret;\r\nunsigned char addr = 0;\r\nusbvision = (struct usb_usbvision *)i2c_get_adapdata(i2c_adap);\r\nfor (i = 0; i < num; i++) {\r\npmsg = &msgs[i];\r\nret = usb_find_address(i2c_adap, pmsg, i2c_adap->retries, &addr);\r\nif (ret != 0) {\r\nPDEBUG(DBG_I2C, "got NAK from device, message #%d", i);\r\nreturn (ret < 0) ? ret : -EREMOTEIO;\r\n}\r\nif (pmsg->flags & I2C_M_RD) {\r\nret = (usbvision_i2c_read(usbvision, addr, pmsg->buf, pmsg->len));\r\nif (ret < pmsg->len)\r\nreturn (ret < 0) ? ret : -EREMOTEIO;\r\n} else {\r\nret = (usbvision_i2c_write(usbvision, addr, pmsg->buf, pmsg->len));\r\nif (ret < pmsg->len)\r\nreturn (ret < 0) ? ret : -EREMOTEIO;\r\n}\r\n}\r\nreturn num;\r\n}\r\nstatic u32 functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nint usbvision_i2c_register(struct usb_usbvision *usbvision)\r\n{\r\nstatic unsigned short saa711x_addrs[] = {\r\n0x4a >> 1, 0x48 >> 1,\r\n0x42 >> 1, 0x40 >> 1,\r\nI2C_CLIENT_END };\r\nif (usbvision->registered_i2c)\r\nreturn 0;\r\nusbvision->i2c_adap = i2c_adap_template;\r\nsprintf(usbvision->i2c_adap.name, "%s-%d-%s", i2c_adap_template.name,\r\nusbvision->dev->bus->busnum, usbvision->dev->devpath);\r\nPDEBUG(DBG_I2C, "Adaptername: %s", usbvision->i2c_adap.name);\r\nusbvision->i2c_adap.dev.parent = &usbvision->dev->dev;\r\ni2c_set_adapdata(&usbvision->i2c_adap, &usbvision->v4l2_dev);\r\nif (usbvision_write_reg(usbvision, USBVISION_SER_MODE, USBVISION_IIC_LRNACK) < 0) {\r\nprintk(KERN_ERR "usbvision_i2c_register: can't write reg\n");\r\nreturn -EBUSY;\r\n}\r\nPDEBUG(DBG_I2C, "I2C debugging is enabled [i2c]");\r\nPDEBUG(DBG_I2C, "ALGO debugging is enabled [i2c]");\r\nusbvision->i2c_adap.algo = &usbvision_algo;\r\nusbvision->i2c_adap.timeout = 100;\r\nusbvision->i2c_adap.retries = 3;\r\ni2c_add_adapter(&usbvision->i2c_adap);\r\nPDEBUG(DBG_I2C, "i2c bus for %s registered", usbvision->i2c_adap.name);\r\nswitch (usbvision_device_data[usbvision->dev_model].codec) {\r\ncase CODEC_SAA7113:\r\ncase CODEC_SAA7111:\r\nmdelay(10);\r\nv4l2_i2c_new_subdev(&usbvision->v4l2_dev,\r\n&usbvision->i2c_adap,\r\n"saa7115_auto", 0, saa711x_addrs);\r\nbreak;\r\n}\r\nif (usbvision_device_data[usbvision->dev_model].tuner == 1) {\r\nstruct v4l2_subdev *sd;\r\nenum v4l2_i2c_tuner_type type;\r\nstruct tuner_setup tun_setup;\r\nsd = v4l2_i2c_new_subdev(&usbvision->v4l2_dev,\r\n&usbvision->i2c_adap,\r\n"tuner", 0, v4l2_i2c_tuner_addrs(ADDRS_DEMOD));\r\ntype = sd ? ADDRS_TV_WITH_DEMOD : ADDRS_TV;\r\nsd = v4l2_i2c_new_subdev(&usbvision->v4l2_dev,\r\n&usbvision->i2c_adap,\r\n"tuner", 0, v4l2_i2c_tuner_addrs(type));\r\nif (sd == NULL)\r\nreturn -ENODEV;\r\nif (usbvision->tuner_type != -1) {\r\ntun_setup.mode_mask = T_ANALOG_TV | T_RADIO;\r\ntun_setup.type = usbvision->tuner_type;\r\ntun_setup.addr = v4l2_i2c_subdev_addr(sd);\r\ncall_all(usbvision, tuner, s_type_addr, &tun_setup);\r\n}\r\n}\r\nusbvision->registered_i2c = 1;\r\nreturn 0;\r\n}\r\nint usbvision_i2c_unregister(struct usb_usbvision *usbvision)\r\n{\r\nif (!usbvision->registered_i2c)\r\nreturn 0;\r\ni2c_del_adapter(&(usbvision->i2c_adap));\r\nusbvision->registered_i2c = 0;\r\nPDEBUG(DBG_I2C, "i2c bus for %s unregistered", usbvision->i2c_adap.name);\r\nreturn 0;\r\n}\r\nstatic int\r\nusbvision_i2c_read_max4(struct usb_usbvision *usbvision, unsigned char addr,\r\nchar *buf, short len)\r\n{\r\nint rc, retries;\r\nfor (retries = 5;;) {\r\nrc = usbvision_write_reg(usbvision, USBVISION_SER_ADRS, addr);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = usbvision_write_reg(usbvision, USBVISION_SER_CONT,\r\n(len & 0x07) | 0x18);\r\nif (rc < 0)\r\nreturn rc;\r\ndo {\r\nrc = usbvision_read_reg(usbvision, USBVISION_SER_CONT);\r\n} while (rc > 0 && ((rc & 0x10) != 0));\r\nif (rc < 0)\r\nreturn rc;\r\nif ((rc & 0x20) == 0)\r\nbreak;\r\nrc = usbvision_write_reg(usbvision, USBVISION_SER_CONT, 0x00);\r\nif (rc < 0)\r\nreturn rc;\r\nif (--retries < 0)\r\nreturn -1;\r\n}\r\nswitch (len) {\r\ncase 4:\r\nbuf[3] = usbvision_read_reg(usbvision, USBVISION_SER_DAT4);\r\ncase 3:\r\nbuf[2] = usbvision_read_reg(usbvision, USBVISION_SER_DAT3);\r\ncase 2:\r\nbuf[1] = usbvision_read_reg(usbvision, USBVISION_SER_DAT2);\r\ncase 1:\r\nbuf[0] = usbvision_read_reg(usbvision, USBVISION_SER_DAT1);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR\r\n"usbvision_i2c_read_max4: buffer length > 4\n");\r\n}\r\nif (i2c_debug & DBG_I2C) {\r\nint idx;\r\nfor (idx = 0; idx < len; idx++)\r\nPDEBUG(DBG_I2C, "read %x from address %x", (unsigned char)buf[idx], addr);\r\n}\r\nreturn len;\r\n}\r\nstatic int usbvision_i2c_write_max4(struct usb_usbvision *usbvision,\r\nunsigned char addr, const char *buf,\r\nshort len)\r\n{\r\nint rc, retries;\r\nint i;\r\nunsigned char value[6];\r\nunsigned char ser_cont;\r\nser_cont = (len & 0x07) | 0x10;\r\nvalue[0] = addr;\r\nvalue[1] = ser_cont;\r\nfor (i = 0; i < len; i++)\r\nvalue[i + 2] = buf[i];\r\nfor (retries = 5;;) {\r\nrc = usb_control_msg(usbvision->dev,\r\nusb_sndctrlpipe(usbvision->dev, 1),\r\nUSBVISION_OP_CODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_ENDPOINT, 0,\r\n(__u16) USBVISION_SER_ADRS, value,\r\nlen + 2, HZ);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = usbvision_write_reg(usbvision, USBVISION_SER_CONT,\r\n(len & 0x07) | 0x10);\r\nif (rc < 0)\r\nreturn rc;\r\ndo {\r\nrc = usbvision_read_reg(usbvision, USBVISION_SER_CONT);\r\n} while (rc > 0 && ((rc & 0x10) != 0));\r\nif (rc < 0)\r\nreturn rc;\r\nif ((rc & 0x20) == 0)\r\nbreak;\r\nusbvision_write_reg(usbvision, USBVISION_SER_CONT, 0x00);\r\nif (--retries < 0)\r\nreturn -1;\r\n}\r\nif (i2c_debug & DBG_I2C) {\r\nint idx;\r\nfor (idx = 0; idx < len; idx++)\r\nPDEBUG(DBG_I2C, "wrote %x at address %x", (unsigned char)buf[idx], addr);\r\n}\r\nreturn len;\r\n}\r\nstatic int usbvision_i2c_write(struct usb_usbvision *usbvision, unsigned char addr, char *buf,\r\nshort len)\r\n{\r\nchar *buf_ptr = buf;\r\nint retval;\r\nint wrcount = 0;\r\nint count;\r\nint max_len = 4;\r\nwhile (len > 0) {\r\ncount = (len > max_len) ? max_len : len;\r\nretval = usbvision_i2c_write_max4(usbvision, addr, buf_ptr, count);\r\nif (retval > 0) {\r\nlen -= count;\r\nbuf_ptr += count;\r\nwrcount += count;\r\n} else\r\nreturn (retval < 0) ? retval : -EFAULT;\r\n}\r\nreturn wrcount;\r\n}\r\nstatic int usbvision_i2c_read(struct usb_usbvision *usbvision, unsigned char addr, char *buf,\r\nshort len)\r\n{\r\nchar temp[4];\r\nint retval, i;\r\nint rdcount = 0;\r\nint count;\r\nwhile (len > 0) {\r\ncount = (len > 3) ? 4 : len;\r\nretval = usbvision_i2c_read_max4(usbvision, addr, temp, count);\r\nif (retval > 0) {\r\nfor (i = 0; i < len; i++)\r\nbuf[rdcount + i] = temp[i];\r\nlen -= count;\r\nrdcount += count;\r\n} else\r\nreturn (retval < 0) ? retval : -EFAULT;\r\n}\r\nreturn rdcount;\r\n}
