static struct mr6_table *ip6mr_get_table(struct net *net, u32 id)\r\n{\r\nstruct mr6_table *mrt;\r\nip6mr_for_each_table(mrt, net) {\r\nif (mrt->id == id)\r\nreturn mrt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\r\nstruct mr6_table **mrt)\r\n{\r\nint err;\r\nstruct ip6mr_result res;\r\nstruct fib_lookup_arg arg = {\r\n.result = &res,\r\n.flags = FIB_LOOKUP_NOREF,\r\n};\r\nerr = fib_rules_lookup(net->ipv6.mr6_rules_ops,\r\nflowi6_to_flowi(flp6), 0, &arg);\r\nif (err < 0)\r\nreturn err;\r\n*mrt = res.mrt;\r\nreturn 0;\r\n}\r\nstatic int ip6mr_rule_action(struct fib_rule *rule, struct flowi *flp,\r\nint flags, struct fib_lookup_arg *arg)\r\n{\r\nstruct ip6mr_result *res = arg->result;\r\nstruct mr6_table *mrt;\r\nswitch (rule->action) {\r\ncase FR_ACT_TO_TBL:\r\nbreak;\r\ncase FR_ACT_UNREACHABLE:\r\nreturn -ENETUNREACH;\r\ncase FR_ACT_PROHIBIT:\r\nreturn -EACCES;\r\ncase FR_ACT_BLACKHOLE:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmrt = ip6mr_get_table(rule->fr_net, rule->table);\r\nif (mrt == NULL)\r\nreturn -EAGAIN;\r\nres->mrt = mrt;\r\nreturn 0;\r\n}\r\nstatic int ip6mr_rule_match(struct fib_rule *rule, struct flowi *flp, int flags)\r\n{\r\nreturn 1;\r\n}\r\nstatic int ip6mr_rule_configure(struct fib_rule *rule, struct sk_buff *skb,\r\nstruct fib_rule_hdr *frh, struct nlattr **tb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ip6mr_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\r\nstruct nlattr **tb)\r\n{\r\nreturn 1;\r\n}\r\nstatic int ip6mr_rule_fill(struct fib_rule *rule, struct sk_buff *skb,\r\nstruct fib_rule_hdr *frh)\r\n{\r\nfrh->dst_len = 0;\r\nfrh->src_len = 0;\r\nfrh->tos = 0;\r\nreturn 0;\r\n}\r\nstatic int __net_init ip6mr_rules_init(struct net *net)\r\n{\r\nstruct fib_rules_ops *ops;\r\nstruct mr6_table *mrt;\r\nint err;\r\nops = fib_rules_register(&ip6mr_rules_ops_template, net);\r\nif (IS_ERR(ops))\r\nreturn PTR_ERR(ops);\r\nINIT_LIST_HEAD(&net->ipv6.mr6_tables);\r\nmrt = ip6mr_new_table(net, RT6_TABLE_DFLT);\r\nif (mrt == NULL) {\r\nerr = -ENOMEM;\r\ngoto err1;\r\n}\r\nerr = fib_default_rule_add(ops, 0x7fff, RT6_TABLE_DFLT, 0);\r\nif (err < 0)\r\ngoto err2;\r\nnet->ipv6.mr6_rules_ops = ops;\r\nreturn 0;\r\nerr2:\r\nkfree(mrt);\r\nerr1:\r\nfib_rules_unregister(ops);\r\nreturn err;\r\n}\r\nstatic void __net_exit ip6mr_rules_exit(struct net *net)\r\n{\r\nstruct mr6_table *mrt, *next;\r\nrtnl_lock();\r\nlist_for_each_entry_safe(mrt, next, &net->ipv6.mr6_tables, list) {\r\nlist_del(&mrt->list);\r\nip6mr_free_table(mrt);\r\n}\r\nrtnl_unlock();\r\nfib_rules_unregister(net->ipv6.mr6_rules_ops);\r\n}\r\nstatic struct mr6_table *ip6mr_get_table(struct net *net, u32 id)\r\n{\r\nreturn net->ipv6.mrt6;\r\n}\r\nstatic int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\r\nstruct mr6_table **mrt)\r\n{\r\n*mrt = net->ipv6.mrt6;\r\nreturn 0;\r\n}\r\nstatic int __net_init ip6mr_rules_init(struct net *net)\r\n{\r\nnet->ipv6.mrt6 = ip6mr_new_table(net, RT6_TABLE_DFLT);\r\nreturn net->ipv6.mrt6 ? 0 : -ENOMEM;\r\n}\r\nstatic void __net_exit ip6mr_rules_exit(struct net *net)\r\n{\r\nrtnl_lock();\r\nip6mr_free_table(net->ipv6.mrt6);\r\nnet->ipv6.mrt6 = NULL;\r\nrtnl_unlock();\r\n}\r\nstatic struct mr6_table *ip6mr_new_table(struct net *net, u32 id)\r\n{\r\nstruct mr6_table *mrt;\r\nunsigned int i;\r\nmrt = ip6mr_get_table(net, id);\r\nif (mrt != NULL)\r\nreturn mrt;\r\nmrt = kzalloc(sizeof(*mrt), GFP_KERNEL);\r\nif (mrt == NULL)\r\nreturn NULL;\r\nmrt->id = id;\r\nwrite_pnet(&mrt->net, net);\r\nfor (i = 0; i < MFC6_LINES; i++)\r\nINIT_LIST_HEAD(&mrt->mfc6_cache_array[i]);\r\nINIT_LIST_HEAD(&mrt->mfc6_unres_queue);\r\nsetup_timer(&mrt->ipmr_expire_timer, ipmr_expire_process,\r\n(unsigned long)mrt);\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\nmrt->mroute_reg_vif_num = -1;\r\n#endif\r\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\r\nlist_add_tail_rcu(&mrt->list, &net->ipv6.mr6_tables);\r\n#endif\r\nreturn mrt;\r\n}\r\nstatic void ip6mr_free_table(struct mr6_table *mrt)\r\n{\r\ndel_timer(&mrt->ipmr_expire_timer);\r\nmroute_clean_tables(mrt);\r\nkfree(mrt);\r\n}\r\nstatic struct mfc6_cache *ipmr_mfc_seq_idx(struct net *net,\r\nstruct ipmr_mfc_iter *it, loff_t pos)\r\n{\r\nstruct mr6_table *mrt = it->mrt;\r\nstruct mfc6_cache *mfc;\r\nread_lock(&mrt_lock);\r\nfor (it->ct = 0; it->ct < MFC6_LINES; it->ct++) {\r\nit->cache = &mrt->mfc6_cache_array[it->ct];\r\nlist_for_each_entry(mfc, it->cache, list)\r\nif (pos-- == 0)\r\nreturn mfc;\r\n}\r\nread_unlock(&mrt_lock);\r\nspin_lock_bh(&mfc_unres_lock);\r\nit->cache = &mrt->mfc6_unres_queue;\r\nlist_for_each_entry(mfc, it->cache, list)\r\nif (pos-- == 0)\r\nreturn mfc;\r\nspin_unlock_bh(&mfc_unres_lock);\r\nit->cache = NULL;\r\nreturn NULL;\r\n}\r\nstatic struct mif_device *ip6mr_vif_seq_idx(struct net *net,\r\nstruct ipmr_vif_iter *iter,\r\nloff_t pos)\r\n{\r\nstruct mr6_table *mrt = iter->mrt;\r\nfor (iter->ct = 0; iter->ct < mrt->maxvif; ++iter->ct) {\r\nif (!MIF_EXISTS(mrt, iter->ct))\r\ncontinue;\r\nif (pos-- == 0)\r\nreturn &mrt->vif6_table[iter->ct];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *ip6mr_vif_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(mrt_lock)\r\n{\r\nstruct ipmr_vif_iter *iter = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nstruct mr6_table *mrt;\r\nmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\r\nif (mrt == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\niter->mrt = mrt;\r\nread_lock(&mrt_lock);\r\nreturn *pos ? ip6mr_vif_seq_idx(net, seq->private, *pos - 1)\r\n: SEQ_START_TOKEN;\r\n}\r\nstatic void *ip6mr_vif_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct ipmr_vif_iter *iter = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nstruct mr6_table *mrt = iter->mrt;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN)\r\nreturn ip6mr_vif_seq_idx(net, iter, 0);\r\nwhile (++iter->ct < mrt->maxvif) {\r\nif (!MIF_EXISTS(mrt, iter->ct))\r\ncontinue;\r\nreturn &mrt->vif6_table[iter->ct];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ip6mr_vif_seq_stop(struct seq_file *seq, void *v)\r\n__releases(mrt_lock)\r\n{\r\nread_unlock(&mrt_lock);\r\n}\r\nstatic int ip6mr_vif_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct ipmr_vif_iter *iter = seq->private;\r\nstruct mr6_table *mrt = iter->mrt;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq,\r\n"Interface BytesIn PktsIn BytesOut PktsOut Flags\n");\r\n} else {\r\nconst struct mif_device *vif = v;\r\nconst char *name = vif->dev ? vif->dev->name : "none";\r\nseq_printf(seq,\r\n"%2td %-10s %8ld %7ld %8ld %7ld %05X\n",\r\nvif - mrt->vif6_table,\r\nname, vif->bytes_in, vif->pkt_in,\r\nvif->bytes_out, vif->pkt_out,\r\nvif->flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ip6mr_vif_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ip6mr_vif_seq_ops,\r\nsizeof(struct ipmr_vif_iter));\r\n}\r\nstatic void *ipmr_mfc_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct ipmr_mfc_iter *it = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nstruct mr6_table *mrt;\r\nmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\r\nif (mrt == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\nit->mrt = mrt;\r\nreturn *pos ? ipmr_mfc_seq_idx(net, seq->private, *pos - 1)\r\n: SEQ_START_TOKEN;\r\n}\r\nstatic void *ipmr_mfc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct mfc6_cache *mfc = v;\r\nstruct ipmr_mfc_iter *it = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nstruct mr6_table *mrt = it->mrt;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN)\r\nreturn ipmr_mfc_seq_idx(net, seq->private, 0);\r\nif (mfc->list.next != it->cache)\r\nreturn list_entry(mfc->list.next, struct mfc6_cache, list);\r\nif (it->cache == &mrt->mfc6_unres_queue)\r\ngoto end_of_list;\r\nBUG_ON(it->cache != &mrt->mfc6_cache_array[it->ct]);\r\nwhile (++it->ct < MFC6_LINES) {\r\nit->cache = &mrt->mfc6_cache_array[it->ct];\r\nif (list_empty(it->cache))\r\ncontinue;\r\nreturn list_first_entry(it->cache, struct mfc6_cache, list);\r\n}\r\nread_unlock(&mrt_lock);\r\nit->cache = &mrt->mfc6_unres_queue;\r\nit->ct = 0;\r\nspin_lock_bh(&mfc_unres_lock);\r\nif (!list_empty(it->cache))\r\nreturn list_first_entry(it->cache, struct mfc6_cache, list);\r\nend_of_list:\r\nspin_unlock_bh(&mfc_unres_lock);\r\nit->cache = NULL;\r\nreturn NULL;\r\n}\r\nstatic void ipmr_mfc_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nstruct ipmr_mfc_iter *it = seq->private;\r\nstruct mr6_table *mrt = it->mrt;\r\nif (it->cache == &mrt->mfc6_unres_queue)\r\nspin_unlock_bh(&mfc_unres_lock);\r\nelse if (it->cache == mrt->mfc6_cache_array)\r\nread_unlock(&mrt_lock);\r\n}\r\nstatic int ipmr_mfc_seq_show(struct seq_file *seq, void *v)\r\n{\r\nint n;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq,\r\n"Group "\r\n"Origin "\r\n"Iif Pkts Bytes Wrong Oifs\n");\r\n} else {\r\nconst struct mfc6_cache *mfc = v;\r\nconst struct ipmr_mfc_iter *it = seq->private;\r\nstruct mr6_table *mrt = it->mrt;\r\nseq_printf(seq, "%pI6 %pI6 %-3hd",\r\n&mfc->mf6c_mcastgrp, &mfc->mf6c_origin,\r\nmfc->mf6c_parent);\r\nif (it->cache != &mrt->mfc6_unres_queue) {\r\nseq_printf(seq, " %8lu %8lu %8lu",\r\nmfc->mfc_un.res.pkt,\r\nmfc->mfc_un.res.bytes,\r\nmfc->mfc_un.res.wrong_if);\r\nfor (n = mfc->mfc_un.res.minvif;\r\nn < mfc->mfc_un.res.maxvif; n++) {\r\nif (MIF_EXISTS(mrt, n) &&\r\nmfc->mfc_un.res.ttls[n] < 255)\r\nseq_printf(seq,\r\n" %2d:%-3d",\r\nn, mfc->mfc_un.res.ttls[n]);\r\n}\r\n} else {\r\nseq_printf(seq, " %8lu %8lu %8lu", 0ul, 0ul, 0ul);\r\n}\r\nseq_putc(seq, '\n');\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipmr_mfc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ipmr_mfc_seq_ops,\r\nsizeof(struct ipmr_mfc_iter));\r\n}\r\nstatic int pim6_rcv(struct sk_buff *skb)\r\n{\r\nstruct pimreghdr *pim;\r\nstruct ipv6hdr *encap;\r\nstruct net_device *reg_dev = NULL;\r\nstruct net *net = dev_net(skb->dev);\r\nstruct mr6_table *mrt;\r\nstruct flowi6 fl6 = {\r\n.flowi6_iif = skb->dev->ifindex,\r\n.flowi6_mark = skb->mark,\r\n};\r\nint reg_vif_num;\r\nif (!pskb_may_pull(skb, sizeof(*pim) + sizeof(*encap)))\r\ngoto drop;\r\npim = (struct pimreghdr *)skb_transport_header(skb);\r\nif (pim->type != ((PIM_VERSION << 4) | PIM_REGISTER) ||\r\n(pim->flags & PIM_NULL_REGISTER) ||\r\n(csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,\r\nsizeof(*pim), IPPROTO_PIM,\r\ncsum_partial((void *)pim, sizeof(*pim), 0)) &&\r\ncsum_fold(skb_checksum(skb, 0, skb->len, 0))))\r\ngoto drop;\r\nencap = (struct ipv6hdr *)(skb_transport_header(skb) +\r\nsizeof(*pim));\r\nif (!ipv6_addr_is_multicast(&encap->daddr) ||\r\nencap->payload_len == 0 ||\r\nntohs(encap->payload_len) + sizeof(*pim) > skb->len)\r\ngoto drop;\r\nif (ip6mr_fib_lookup(net, &fl6, &mrt) < 0)\r\ngoto drop;\r\nreg_vif_num = mrt->mroute_reg_vif_num;\r\nread_lock(&mrt_lock);\r\nif (reg_vif_num >= 0)\r\nreg_dev = mrt->vif6_table[reg_vif_num].dev;\r\nif (reg_dev)\r\ndev_hold(reg_dev);\r\nread_unlock(&mrt_lock);\r\nif (reg_dev == NULL)\r\ngoto drop;\r\nskb->mac_header = skb->network_header;\r\nskb_pull(skb, (u8 *)encap - skb->data);\r\nskb_reset_network_header(skb);\r\nskb->protocol = htons(ETH_P_IPV6);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nskb_tunnel_rx(skb, reg_dev, dev_net(reg_dev));\r\nnetif_rx(skb);\r\ndev_put(reg_dev);\r\nreturn 0;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t reg_vif_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct mr6_table *mrt;\r\nstruct flowi6 fl6 = {\r\n.flowi6_oif = dev->ifindex,\r\n.flowi6_iif = skb->skb_iif ? : LOOPBACK_IFINDEX,\r\n.flowi6_mark = skb->mark,\r\n};\r\nint err;\r\nerr = ip6mr_fib_lookup(net, &fl6, &mrt);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nread_lock(&mrt_lock);\r\ndev->stats.tx_bytes += skb->len;\r\ndev->stats.tx_packets++;\r\nip6mr_cache_report(mrt, skb, mrt->mroute_reg_vif_num, MRT6MSG_WHOLEPKT);\r\nread_unlock(&mrt_lock);\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void reg_vif_setup(struct net_device *dev)\r\n{\r\ndev->type = ARPHRD_PIMREG;\r\ndev->mtu = 1500 - sizeof(struct ipv6hdr) - 8;\r\ndev->flags = IFF_NOARP;\r\ndev->netdev_ops = &reg_vif_netdev_ops;\r\ndev->destructor = free_netdev;\r\ndev->features |= NETIF_F_NETNS_LOCAL;\r\n}\r\nstatic struct net_device *ip6mr_reg_vif(struct net *net, struct mr6_table *mrt)\r\n{\r\nstruct net_device *dev;\r\nchar name[IFNAMSIZ];\r\nif (mrt->id == RT6_TABLE_DFLT)\r\nsprintf(name, "pim6reg");\r\nelse\r\nsprintf(name, "pim6reg%u", mrt->id);\r\ndev = alloc_netdev(0, name, reg_vif_setup);\r\nif (dev == NULL)\r\nreturn NULL;\r\ndev_net_set(dev, net);\r\nif (register_netdevice(dev)) {\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\ndev->iflink = 0;\r\nif (dev_open(dev))\r\ngoto failure;\r\ndev_hold(dev);\r\nreturn dev;\r\nfailure:\r\nrtnl_unlock();\r\nrtnl_lock();\r\nunregister_netdevice(dev);\r\nreturn NULL;\r\n}\r\nstatic int mif6_delete(struct mr6_table *mrt, int vifi, struct list_head *head)\r\n{\r\nstruct mif_device *v;\r\nstruct net_device *dev;\r\nstruct inet6_dev *in6_dev;\r\nif (vifi < 0 || vifi >= mrt->maxvif)\r\nreturn -EADDRNOTAVAIL;\r\nv = &mrt->vif6_table[vifi];\r\nwrite_lock_bh(&mrt_lock);\r\ndev = v->dev;\r\nv->dev = NULL;\r\nif (!dev) {\r\nwrite_unlock_bh(&mrt_lock);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\nif (vifi == mrt->mroute_reg_vif_num)\r\nmrt->mroute_reg_vif_num = -1;\r\n#endif\r\nif (vifi + 1 == mrt->maxvif) {\r\nint tmp;\r\nfor (tmp = vifi - 1; tmp >= 0; tmp--) {\r\nif (MIF_EXISTS(mrt, tmp))\r\nbreak;\r\n}\r\nmrt->maxvif = tmp + 1;\r\n}\r\nwrite_unlock_bh(&mrt_lock);\r\ndev_set_allmulti(dev, -1);\r\nin6_dev = __in6_dev_get(dev);\r\nif (in6_dev) {\r\nin6_dev->cnf.mc_forwarding--;\r\ninet6_netconf_notify_devconf(dev_net(dev),\r\nNETCONFA_MC_FORWARDING,\r\ndev->ifindex, &in6_dev->cnf);\r\n}\r\nif (v->flags & MIFF_REGISTER)\r\nunregister_netdevice_queue(dev, head);\r\ndev_put(dev);\r\nreturn 0;\r\n}\r\nstatic inline void ip6mr_cache_free(struct mfc6_cache *c)\r\n{\r\nkmem_cache_free(mrt_cachep, c);\r\n}\r\nstatic void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)\r\n{\r\nstruct net *net = read_pnet(&mrt->net);\r\nstruct sk_buff *skb;\r\natomic_dec(&mrt->cache_resolve_queue_len);\r\nwhile((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {\r\nif (ipv6_hdr(skb)->version == 0) {\r\nstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));\r\nnlh->nlmsg_type = NLMSG_ERROR;\r\nnlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));\r\nskb_trim(skb, nlh->nlmsg_len);\r\n((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;\r\nrtnl_unicast(skb, net, NETLINK_CB(skb).portid);\r\n} else\r\nkfree_skb(skb);\r\n}\r\nip6mr_cache_free(c);\r\n}\r\nstatic void ipmr_do_expire_process(struct mr6_table *mrt)\r\n{\r\nunsigned long now = jiffies;\r\nunsigned long expires = 10 * HZ;\r\nstruct mfc6_cache *c, *next;\r\nlist_for_each_entry_safe(c, next, &mrt->mfc6_unres_queue, list) {\r\nif (time_after(c->mfc_un.unres.expires, now)) {\r\nunsigned long interval = c->mfc_un.unres.expires - now;\r\nif (interval < expires)\r\nexpires = interval;\r\ncontinue;\r\n}\r\nlist_del(&c->list);\r\nmr6_netlink_event(mrt, c, RTM_DELROUTE);\r\nip6mr_destroy_unres(mrt, c);\r\n}\r\nif (!list_empty(&mrt->mfc6_unres_queue))\r\nmod_timer(&mrt->ipmr_expire_timer, jiffies + expires);\r\n}\r\nstatic void ipmr_expire_process(unsigned long arg)\r\n{\r\nstruct mr6_table *mrt = (struct mr6_table *)arg;\r\nif (!spin_trylock(&mfc_unres_lock)) {\r\nmod_timer(&mrt->ipmr_expire_timer, jiffies + 1);\r\nreturn;\r\n}\r\nif (!list_empty(&mrt->mfc6_unres_queue))\r\nipmr_do_expire_process(mrt);\r\nspin_unlock(&mfc_unres_lock);\r\n}\r\nstatic void ip6mr_update_thresholds(struct mr6_table *mrt, struct mfc6_cache *cache,\r\nunsigned char *ttls)\r\n{\r\nint vifi;\r\ncache->mfc_un.res.minvif = MAXMIFS;\r\ncache->mfc_un.res.maxvif = 0;\r\nmemset(cache->mfc_un.res.ttls, 255, MAXMIFS);\r\nfor (vifi = 0; vifi < mrt->maxvif; vifi++) {\r\nif (MIF_EXISTS(mrt, vifi) &&\r\nttls[vifi] && ttls[vifi] < 255) {\r\ncache->mfc_un.res.ttls[vifi] = ttls[vifi];\r\nif (cache->mfc_un.res.minvif > vifi)\r\ncache->mfc_un.res.minvif = vifi;\r\nif (cache->mfc_un.res.maxvif <= vifi)\r\ncache->mfc_un.res.maxvif = vifi + 1;\r\n}\r\n}\r\n}\r\nstatic int mif6_add(struct net *net, struct mr6_table *mrt,\r\nstruct mif6ctl *vifc, int mrtsock)\r\n{\r\nint vifi = vifc->mif6c_mifi;\r\nstruct mif_device *v = &mrt->vif6_table[vifi];\r\nstruct net_device *dev;\r\nstruct inet6_dev *in6_dev;\r\nint err;\r\nif (MIF_EXISTS(mrt, vifi))\r\nreturn -EADDRINUSE;\r\nswitch (vifc->mif6c_flags) {\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\ncase MIFF_REGISTER:\r\nif (mrt->mroute_reg_vif_num >= 0)\r\nreturn -EADDRINUSE;\r\ndev = ip6mr_reg_vif(net, mrt);\r\nif (!dev)\r\nreturn -ENOBUFS;\r\nerr = dev_set_allmulti(dev, 1);\r\nif (err) {\r\nunregister_netdevice(dev);\r\ndev_put(dev);\r\nreturn err;\r\n}\r\nbreak;\r\n#endif\r\ncase 0:\r\ndev = dev_get_by_index(net, vifc->mif6c_pifi);\r\nif (!dev)\r\nreturn -EADDRNOTAVAIL;\r\nerr = dev_set_allmulti(dev, 1);\r\nif (err) {\r\ndev_put(dev);\r\nreturn err;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nin6_dev = __in6_dev_get(dev);\r\nif (in6_dev) {\r\nin6_dev->cnf.mc_forwarding++;\r\ninet6_netconf_notify_devconf(dev_net(dev),\r\nNETCONFA_MC_FORWARDING,\r\ndev->ifindex, &in6_dev->cnf);\r\n}\r\nv->rate_limit = vifc->vifc_rate_limit;\r\nv->flags = vifc->mif6c_flags;\r\nif (!mrtsock)\r\nv->flags |= VIFF_STATIC;\r\nv->threshold = vifc->vifc_threshold;\r\nv->bytes_in = 0;\r\nv->bytes_out = 0;\r\nv->pkt_in = 0;\r\nv->pkt_out = 0;\r\nv->link = dev->ifindex;\r\nif (v->flags & MIFF_REGISTER)\r\nv->link = dev->iflink;\r\nwrite_lock_bh(&mrt_lock);\r\nv->dev = dev;\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\nif (v->flags & MIFF_REGISTER)\r\nmrt->mroute_reg_vif_num = vifi;\r\n#endif\r\nif (vifi + 1 > mrt->maxvif)\r\nmrt->maxvif = vifi + 1;\r\nwrite_unlock_bh(&mrt_lock);\r\nreturn 0;\r\n}\r\nstatic struct mfc6_cache *ip6mr_cache_find(struct mr6_table *mrt,\r\nconst struct in6_addr *origin,\r\nconst struct in6_addr *mcastgrp)\r\n{\r\nint line = MFC6_HASH(mcastgrp, origin);\r\nstruct mfc6_cache *c;\r\nlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list) {\r\nif (ipv6_addr_equal(&c->mf6c_origin, origin) &&\r\nipv6_addr_equal(&c->mf6c_mcastgrp, mcastgrp))\r\nreturn c;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mfc6_cache *ip6mr_cache_find_any_parent(struct mr6_table *mrt,\r\nmifi_t mifi)\r\n{\r\nint line = MFC6_HASH(&in6addr_any, &in6addr_any);\r\nstruct mfc6_cache *c;\r\nlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list)\r\nif (ipv6_addr_any(&c->mf6c_origin) &&\r\nipv6_addr_any(&c->mf6c_mcastgrp) &&\r\n(c->mfc_un.res.ttls[mifi] < 255))\r\nreturn c;\r\nreturn NULL;\r\n}\r\nstatic struct mfc6_cache *ip6mr_cache_find_any(struct mr6_table *mrt,\r\nstruct in6_addr *mcastgrp,\r\nmifi_t mifi)\r\n{\r\nint line = MFC6_HASH(mcastgrp, &in6addr_any);\r\nstruct mfc6_cache *c, *proxy;\r\nif (ipv6_addr_any(mcastgrp))\r\ngoto skip;\r\nlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list)\r\nif (ipv6_addr_any(&c->mf6c_origin) &&\r\nipv6_addr_equal(&c->mf6c_mcastgrp, mcastgrp)) {\r\nif (c->mfc_un.res.ttls[mifi] < 255)\r\nreturn c;\r\nproxy = ip6mr_cache_find_any_parent(mrt,\r\nc->mf6c_parent);\r\nif (proxy && proxy->mfc_un.res.ttls[mifi] < 255)\r\nreturn c;\r\n}\r\nskip:\r\nreturn ip6mr_cache_find_any_parent(mrt, mifi);\r\n}\r\nstatic struct mfc6_cache *ip6mr_cache_alloc(void)\r\n{\r\nstruct mfc6_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_KERNEL);\r\nif (c == NULL)\r\nreturn NULL;\r\nc->mfc_un.res.minvif = MAXMIFS;\r\nreturn c;\r\n}\r\nstatic struct mfc6_cache *ip6mr_cache_alloc_unres(void)\r\n{\r\nstruct mfc6_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_ATOMIC);\r\nif (c == NULL)\r\nreturn NULL;\r\nskb_queue_head_init(&c->mfc_un.unres.unresolved);\r\nc->mfc_un.unres.expires = jiffies + 10 * HZ;\r\nreturn c;\r\n}\r\nstatic void ip6mr_cache_resolve(struct net *net, struct mr6_table *mrt,\r\nstruct mfc6_cache *uc, struct mfc6_cache *c)\r\n{\r\nstruct sk_buff *skb;\r\nwhile((skb = __skb_dequeue(&uc->mfc_un.unres.unresolved))) {\r\nif (ipv6_hdr(skb)->version == 0) {\r\nstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));\r\nif (__ip6mr_fill_mroute(mrt, skb, c, nlmsg_data(nlh)) > 0) {\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - (u8 *)nlh;\r\n} else {\r\nnlh->nlmsg_type = NLMSG_ERROR;\r\nnlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));\r\nskb_trim(skb, nlh->nlmsg_len);\r\n((struct nlmsgerr *)nlmsg_data(nlh))->error = -EMSGSIZE;\r\n}\r\nrtnl_unicast(skb, net, NETLINK_CB(skb).portid);\r\n} else\r\nip6_mr_forward(net, mrt, skb, c);\r\n}\r\n}\r\nstatic int ip6mr_cache_report(struct mr6_table *mrt, struct sk_buff *pkt,\r\nmifi_t mifi, int assert)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mrt6msg *msg;\r\nint ret;\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\nif (assert == MRT6MSG_WHOLEPKT)\r\nskb = skb_realloc_headroom(pkt, -skb_network_offset(pkt)\r\n+sizeof(*msg));\r\nelse\r\n#endif\r\nskb = alloc_skb(sizeof(struct ipv6hdr) + sizeof(*msg), GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\nif (assert == MRT6MSG_WHOLEPKT) {\r\nskb_push(skb, -skb_network_offset(pkt));\r\nskb_push(skb, sizeof(*msg));\r\nskb_reset_transport_header(skb);\r\nmsg = (struct mrt6msg *)skb_transport_header(skb);\r\nmsg->im6_mbz = 0;\r\nmsg->im6_msgtype = MRT6MSG_WHOLEPKT;\r\nmsg->im6_mif = mrt->mroute_reg_vif_num;\r\nmsg->im6_pad = 0;\r\nmsg->im6_src = ipv6_hdr(pkt)->saddr;\r\nmsg->im6_dst = ipv6_hdr(pkt)->daddr;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n} else\r\n#endif\r\n{\r\nskb_put(skb, sizeof(struct ipv6hdr));\r\nskb_reset_network_header(skb);\r\nskb_copy_to_linear_data(skb, ipv6_hdr(pkt), sizeof(struct ipv6hdr));\r\nskb_put(skb, sizeof(*msg));\r\nskb_reset_transport_header(skb);\r\nmsg = (struct mrt6msg *)skb_transport_header(skb);\r\nmsg->im6_mbz = 0;\r\nmsg->im6_msgtype = assert;\r\nmsg->im6_mif = mifi;\r\nmsg->im6_pad = 0;\r\nmsg->im6_src = ipv6_hdr(pkt)->saddr;\r\nmsg->im6_dst = ipv6_hdr(pkt)->daddr;\r\nskb_dst_set(skb, dst_clone(skb_dst(pkt)));\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nif (mrt->mroute6_sk == NULL) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nret = sock_queue_rcv_skb(mrt->mroute6_sk, skb);\r\nif (ret < 0) {\r\nnet_warn_ratelimited("mroute6: pending queue full, dropping entries\n");\r\nkfree_skb(skb);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nip6mr_cache_unresolved(struct mr6_table *mrt, mifi_t mifi, struct sk_buff *skb)\r\n{\r\nbool found = false;\r\nint err;\r\nstruct mfc6_cache *c;\r\nspin_lock_bh(&mfc_unres_lock);\r\nlist_for_each_entry(c, &mrt->mfc6_unres_queue, list) {\r\nif (ipv6_addr_equal(&c->mf6c_mcastgrp, &ipv6_hdr(skb)->daddr) &&\r\nipv6_addr_equal(&c->mf6c_origin, &ipv6_hdr(skb)->saddr)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nif (atomic_read(&mrt->cache_resolve_queue_len) >= 10 ||\r\n(c = ip6mr_cache_alloc_unres()) == NULL) {\r\nspin_unlock_bh(&mfc_unres_lock);\r\nkfree_skb(skb);\r\nreturn -ENOBUFS;\r\n}\r\nc->mf6c_parent = -1;\r\nc->mf6c_origin = ipv6_hdr(skb)->saddr;\r\nc->mf6c_mcastgrp = ipv6_hdr(skb)->daddr;\r\nerr = ip6mr_cache_report(mrt, skb, mifi, MRT6MSG_NOCACHE);\r\nif (err < 0) {\r\nspin_unlock_bh(&mfc_unres_lock);\r\nip6mr_cache_free(c);\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\natomic_inc(&mrt->cache_resolve_queue_len);\r\nlist_add(&c->list, &mrt->mfc6_unres_queue);\r\nmr6_netlink_event(mrt, c, RTM_NEWROUTE);\r\nipmr_do_expire_process(mrt);\r\n}\r\nif (c->mfc_un.unres.unresolved.qlen > 3) {\r\nkfree_skb(skb);\r\nerr = -ENOBUFS;\r\n} else {\r\nskb_queue_tail(&c->mfc_un.unres.unresolved, skb);\r\nerr = 0;\r\n}\r\nspin_unlock_bh(&mfc_unres_lock);\r\nreturn err;\r\n}\r\nstatic int ip6mr_mfc_delete(struct mr6_table *mrt, struct mf6cctl *mfc,\r\nint parent)\r\n{\r\nint line;\r\nstruct mfc6_cache *c, *next;\r\nline = MFC6_HASH(&mfc->mf6cc_mcastgrp.sin6_addr, &mfc->mf6cc_origin.sin6_addr);\r\nlist_for_each_entry_safe(c, next, &mrt->mfc6_cache_array[line], list) {\r\nif (ipv6_addr_equal(&c->mf6c_origin, &mfc->mf6cc_origin.sin6_addr) &&\r\nipv6_addr_equal(&c->mf6c_mcastgrp,\r\n&mfc->mf6cc_mcastgrp.sin6_addr) &&\r\n(parent == -1 || parent == c->mf6c_parent)) {\r\nwrite_lock_bh(&mrt_lock);\r\nlist_del(&c->list);\r\nwrite_unlock_bh(&mrt_lock);\r\nmr6_netlink_event(mrt, c, RTM_DELROUTE);\r\nip6mr_cache_free(c);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int ip6mr_device_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct net *net = dev_net(dev);\r\nstruct mr6_table *mrt;\r\nstruct mif_device *v;\r\nint ct;\r\nLIST_HEAD(list);\r\nif (event != NETDEV_UNREGISTER)\r\nreturn NOTIFY_DONE;\r\nip6mr_for_each_table(mrt, net) {\r\nv = &mrt->vif6_table[0];\r\nfor (ct = 0; ct < mrt->maxvif; ct++, v++) {\r\nif (v->dev == dev)\r\nmif6_delete(mrt, ct, &list);\r\n}\r\n}\r\nunregister_netdevice_many(&list);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __net_init ip6mr_net_init(struct net *net)\r\n{\r\nint err;\r\nerr = ip6mr_rules_init(net);\r\nif (err < 0)\r\ngoto fail;\r\n#ifdef CONFIG_PROC_FS\r\nerr = -ENOMEM;\r\nif (!proc_create("ip6_mr_vif", 0, net->proc_net, &ip6mr_vif_fops))\r\ngoto proc_vif_fail;\r\nif (!proc_create("ip6_mr_cache", 0, net->proc_net, &ip6mr_mfc_fops))\r\ngoto proc_cache_fail;\r\n#endif\r\nreturn 0;\r\n#ifdef CONFIG_PROC_FS\r\nproc_cache_fail:\r\nremove_proc_entry("ip6_mr_vif", net->proc_net);\r\nproc_vif_fail:\r\nip6mr_rules_exit(net);\r\n#endif\r\nfail:\r\nreturn err;\r\n}\r\nstatic void __net_exit ip6mr_net_exit(struct net *net)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("ip6_mr_cache", net->proc_net);\r\nremove_proc_entry("ip6_mr_vif", net->proc_net);\r\n#endif\r\nip6mr_rules_exit(net);\r\n}\r\nint __init ip6_mr_init(void)\r\n{\r\nint err;\r\nmrt_cachep = kmem_cache_create("ip6_mrt_cache",\r\nsizeof(struct mfc6_cache),\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!mrt_cachep)\r\nreturn -ENOMEM;\r\nerr = register_pernet_subsys(&ip6mr_net_ops);\r\nif (err)\r\ngoto reg_pernet_fail;\r\nerr = register_netdevice_notifier(&ip6_mr_notifier);\r\nif (err)\r\ngoto reg_notif_fail;\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\nif (inet6_add_protocol(&pim6_protocol, IPPROTO_PIM) < 0) {\r\npr_err("%s: can't add PIM protocol\n", __func__);\r\nerr = -EAGAIN;\r\ngoto add_proto_fail;\r\n}\r\n#endif\r\nrtnl_register(RTNL_FAMILY_IP6MR, RTM_GETROUTE, NULL,\r\nip6mr_rtm_dumproute, NULL);\r\nreturn 0;\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\nadd_proto_fail:\r\nunregister_netdevice_notifier(&ip6_mr_notifier);\r\n#endif\r\nreg_notif_fail:\r\nunregister_pernet_subsys(&ip6mr_net_ops);\r\nreg_pernet_fail:\r\nkmem_cache_destroy(mrt_cachep);\r\nreturn err;\r\n}\r\nvoid ip6_mr_cleanup(void)\r\n{\r\nunregister_netdevice_notifier(&ip6_mr_notifier);\r\nunregister_pernet_subsys(&ip6mr_net_ops);\r\nkmem_cache_destroy(mrt_cachep);\r\n}\r\nstatic int ip6mr_mfc_add(struct net *net, struct mr6_table *mrt,\r\nstruct mf6cctl *mfc, int mrtsock, int parent)\r\n{\r\nbool found = false;\r\nint line;\r\nstruct mfc6_cache *uc, *c;\r\nunsigned char ttls[MAXMIFS];\r\nint i;\r\nif (mfc->mf6cc_parent >= MAXMIFS)\r\nreturn -ENFILE;\r\nmemset(ttls, 255, MAXMIFS);\r\nfor (i = 0; i < MAXMIFS; i++) {\r\nif (IF_ISSET(i, &mfc->mf6cc_ifset))\r\nttls[i] = 1;\r\n}\r\nline = MFC6_HASH(&mfc->mf6cc_mcastgrp.sin6_addr, &mfc->mf6cc_origin.sin6_addr);\r\nlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list) {\r\nif (ipv6_addr_equal(&c->mf6c_origin, &mfc->mf6cc_origin.sin6_addr) &&\r\nipv6_addr_equal(&c->mf6c_mcastgrp,\r\n&mfc->mf6cc_mcastgrp.sin6_addr) &&\r\n(parent == -1 || parent == mfc->mf6cc_parent)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nwrite_lock_bh(&mrt_lock);\r\nc->mf6c_parent = mfc->mf6cc_parent;\r\nip6mr_update_thresholds(mrt, c, ttls);\r\nif (!mrtsock)\r\nc->mfc_flags |= MFC_STATIC;\r\nwrite_unlock_bh(&mrt_lock);\r\nmr6_netlink_event(mrt, c, RTM_NEWROUTE);\r\nreturn 0;\r\n}\r\nif (!ipv6_addr_any(&mfc->mf6cc_mcastgrp.sin6_addr) &&\r\n!ipv6_addr_is_multicast(&mfc->mf6cc_mcastgrp.sin6_addr))\r\nreturn -EINVAL;\r\nc = ip6mr_cache_alloc();\r\nif (c == NULL)\r\nreturn -ENOMEM;\r\nc->mf6c_origin = mfc->mf6cc_origin.sin6_addr;\r\nc->mf6c_mcastgrp = mfc->mf6cc_mcastgrp.sin6_addr;\r\nc->mf6c_parent = mfc->mf6cc_parent;\r\nip6mr_update_thresholds(mrt, c, ttls);\r\nif (!mrtsock)\r\nc->mfc_flags |= MFC_STATIC;\r\nwrite_lock_bh(&mrt_lock);\r\nlist_add(&c->list, &mrt->mfc6_cache_array[line]);\r\nwrite_unlock_bh(&mrt_lock);\r\nfound = false;\r\nspin_lock_bh(&mfc_unres_lock);\r\nlist_for_each_entry(uc, &mrt->mfc6_unres_queue, list) {\r\nif (ipv6_addr_equal(&uc->mf6c_origin, &c->mf6c_origin) &&\r\nipv6_addr_equal(&uc->mf6c_mcastgrp, &c->mf6c_mcastgrp)) {\r\nlist_del(&uc->list);\r\natomic_dec(&mrt->cache_resolve_queue_len);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (list_empty(&mrt->mfc6_unres_queue))\r\ndel_timer(&mrt->ipmr_expire_timer);\r\nspin_unlock_bh(&mfc_unres_lock);\r\nif (found) {\r\nip6mr_cache_resolve(net, mrt, uc, c);\r\nip6mr_cache_free(uc);\r\n}\r\nmr6_netlink_event(mrt, c, RTM_NEWROUTE);\r\nreturn 0;\r\n}\r\nstatic void mroute_clean_tables(struct mr6_table *mrt)\r\n{\r\nint i;\r\nLIST_HEAD(list);\r\nstruct mfc6_cache *c, *next;\r\nfor (i = 0; i < mrt->maxvif; i++) {\r\nif (!(mrt->vif6_table[i].flags & VIFF_STATIC))\r\nmif6_delete(mrt, i, &list);\r\n}\r\nunregister_netdevice_many(&list);\r\nfor (i = 0; i < MFC6_LINES; i++) {\r\nlist_for_each_entry_safe(c, next, &mrt->mfc6_cache_array[i], list) {\r\nif (c->mfc_flags & MFC_STATIC)\r\ncontinue;\r\nwrite_lock_bh(&mrt_lock);\r\nlist_del(&c->list);\r\nwrite_unlock_bh(&mrt_lock);\r\nmr6_netlink_event(mrt, c, RTM_DELROUTE);\r\nip6mr_cache_free(c);\r\n}\r\n}\r\nif (atomic_read(&mrt->cache_resolve_queue_len) != 0) {\r\nspin_lock_bh(&mfc_unres_lock);\r\nlist_for_each_entry_safe(c, next, &mrt->mfc6_unres_queue, list) {\r\nlist_del(&c->list);\r\nmr6_netlink_event(mrt, c, RTM_DELROUTE);\r\nip6mr_destroy_unres(mrt, c);\r\n}\r\nspin_unlock_bh(&mfc_unres_lock);\r\n}\r\n}\r\nstatic int ip6mr_sk_init(struct mr6_table *mrt, struct sock *sk)\r\n{\r\nint err = 0;\r\nstruct net *net = sock_net(sk);\r\nrtnl_lock();\r\nwrite_lock_bh(&mrt_lock);\r\nif (likely(mrt->mroute6_sk == NULL)) {\r\nmrt->mroute6_sk = sk;\r\nnet->ipv6.devconf_all->mc_forwarding++;\r\ninet6_netconf_notify_devconf(net, NETCONFA_MC_FORWARDING,\r\nNETCONFA_IFINDEX_ALL,\r\nnet->ipv6.devconf_all);\r\n}\r\nelse\r\nerr = -EADDRINUSE;\r\nwrite_unlock_bh(&mrt_lock);\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nint ip6mr_sk_done(struct sock *sk)\r\n{\r\nint err = -EACCES;\r\nstruct net *net = sock_net(sk);\r\nstruct mr6_table *mrt;\r\nrtnl_lock();\r\nip6mr_for_each_table(mrt, net) {\r\nif (sk == mrt->mroute6_sk) {\r\nwrite_lock_bh(&mrt_lock);\r\nmrt->mroute6_sk = NULL;\r\nnet->ipv6.devconf_all->mc_forwarding--;\r\ninet6_netconf_notify_devconf(net,\r\nNETCONFA_MC_FORWARDING,\r\nNETCONFA_IFINDEX_ALL,\r\nnet->ipv6.devconf_all);\r\nwrite_unlock_bh(&mrt_lock);\r\nmroute_clean_tables(mrt);\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstruct sock *mroute6_socket(struct net *net, struct sk_buff *skb)\r\n{\r\nstruct mr6_table *mrt;\r\nstruct flowi6 fl6 = {\r\n.flowi6_iif = skb->skb_iif ? : LOOPBACK_IFINDEX,\r\n.flowi6_oif = skb->dev->ifindex,\r\n.flowi6_mark = skb->mark,\r\n};\r\nif (ip6mr_fib_lookup(net, &fl6, &mrt) < 0)\r\nreturn NULL;\r\nreturn mrt->mroute6_sk;\r\n}\r\nint ip6_mroute_setsockopt(struct sock *sk, int optname, char __user *optval, unsigned int optlen)\r\n{\r\nint ret, parent = 0;\r\nstruct mif6ctl vif;\r\nstruct mf6cctl mfc;\r\nmifi_t mifi;\r\nstruct net *net = sock_net(sk);\r\nstruct mr6_table *mrt;\r\nmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\r\nif (mrt == NULL)\r\nreturn -ENOENT;\r\nif (optname != MRT6_INIT) {\r\nif (sk != mrt->mroute6_sk && !ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EACCES;\r\n}\r\nswitch (optname) {\r\ncase MRT6_INIT:\r\nif (sk->sk_type != SOCK_RAW ||\r\ninet_sk(sk)->inet_num != IPPROTO_ICMPV6)\r\nreturn -EOPNOTSUPP;\r\nif (optlen < sizeof(int))\r\nreturn -EINVAL;\r\nreturn ip6mr_sk_init(mrt, sk);\r\ncase MRT6_DONE:\r\nreturn ip6mr_sk_done(sk);\r\ncase MRT6_ADD_MIF:\r\nif (optlen < sizeof(vif))\r\nreturn -EINVAL;\r\nif (copy_from_user(&vif, optval, sizeof(vif)))\r\nreturn -EFAULT;\r\nif (vif.mif6c_mifi >= MAXMIFS)\r\nreturn -ENFILE;\r\nrtnl_lock();\r\nret = mif6_add(net, mrt, &vif, sk == mrt->mroute6_sk);\r\nrtnl_unlock();\r\nreturn ret;\r\ncase MRT6_DEL_MIF:\r\nif (optlen < sizeof(mifi_t))\r\nreturn -EINVAL;\r\nif (copy_from_user(&mifi, optval, sizeof(mifi_t)))\r\nreturn -EFAULT;\r\nrtnl_lock();\r\nret = mif6_delete(mrt, mifi, NULL);\r\nrtnl_unlock();\r\nreturn ret;\r\ncase MRT6_ADD_MFC:\r\ncase MRT6_DEL_MFC:\r\nparent = -1;\r\ncase MRT6_ADD_MFC_PROXY:\r\ncase MRT6_DEL_MFC_PROXY:\r\nif (optlen < sizeof(mfc))\r\nreturn -EINVAL;\r\nif (copy_from_user(&mfc, optval, sizeof(mfc)))\r\nreturn -EFAULT;\r\nif (parent == 0)\r\nparent = mfc.mf6cc_parent;\r\nrtnl_lock();\r\nif (optname == MRT6_DEL_MFC || optname == MRT6_DEL_MFC_PROXY)\r\nret = ip6mr_mfc_delete(mrt, &mfc, parent);\r\nelse\r\nret = ip6mr_mfc_add(net, mrt, &mfc,\r\nsk == mrt->mroute6_sk, parent);\r\nrtnl_unlock();\r\nreturn ret;\r\ncase MRT6_ASSERT:\r\n{\r\nint v;\r\nif (optlen != sizeof(v))\r\nreturn -EINVAL;\r\nif (get_user(v, (int __user *)optval))\r\nreturn -EFAULT;\r\nmrt->mroute_do_assert = v;\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\ncase MRT6_PIM:\r\n{\r\nint v;\r\nif (optlen != sizeof(v))\r\nreturn -EINVAL;\r\nif (get_user(v, (int __user *)optval))\r\nreturn -EFAULT;\r\nv = !!v;\r\nrtnl_lock();\r\nret = 0;\r\nif (v != mrt->mroute_do_pim) {\r\nmrt->mroute_do_pim = v;\r\nmrt->mroute_do_assert = v;\r\n}\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\n#endif\r\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\r\ncase MRT6_TABLE:\r\n{\r\nu32 v;\r\nif (optlen != sizeof(u32))\r\nreturn -EINVAL;\r\nif (get_user(v, (u32 __user *)optval))\r\nreturn -EFAULT;\r\nif (v != RT_TABLE_DEFAULT && v >= 100000000)\r\nreturn -EINVAL;\r\nif (sk == mrt->mroute6_sk)\r\nreturn -EBUSY;\r\nrtnl_lock();\r\nret = 0;\r\nif (!ip6mr_new_table(net, v))\r\nret = -ENOMEM;\r\nraw6_sk(sk)->ip6mr_table = v;\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\n#endif\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\n}\r\nint ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,\r\nint __user *optlen)\r\n{\r\nint olr;\r\nint val;\r\nstruct net *net = sock_net(sk);\r\nstruct mr6_table *mrt;\r\nmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\r\nif (mrt == NULL)\r\nreturn -ENOENT;\r\nswitch (optname) {\r\ncase MRT6_VERSION:\r\nval = 0x0305;\r\nbreak;\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\ncase MRT6_PIM:\r\nval = mrt->mroute_do_pim;\r\nbreak;\r\n#endif\r\ncase MRT6_ASSERT:\r\nval = mrt->mroute_do_assert;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nif (get_user(olr, optlen))\r\nreturn -EFAULT;\r\nolr = min_t(int, olr, sizeof(int));\r\nif (olr < 0)\r\nreturn -EINVAL;\r\nif (put_user(olr, optlen))\r\nreturn -EFAULT;\r\nif (copy_to_user(optval, &val, olr))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint ip6mr_ioctl(struct sock *sk, int cmd, void __user *arg)\r\n{\r\nstruct sioc_sg_req6 sr;\r\nstruct sioc_mif_req6 vr;\r\nstruct mif_device *vif;\r\nstruct mfc6_cache *c;\r\nstruct net *net = sock_net(sk);\r\nstruct mr6_table *mrt;\r\nmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\r\nif (mrt == NULL)\r\nreturn -ENOENT;\r\nswitch (cmd) {\r\ncase SIOCGETMIFCNT_IN6:\r\nif (copy_from_user(&vr, arg, sizeof(vr)))\r\nreturn -EFAULT;\r\nif (vr.mifi >= mrt->maxvif)\r\nreturn -EINVAL;\r\nread_lock(&mrt_lock);\r\nvif = &mrt->vif6_table[vr.mifi];\r\nif (MIF_EXISTS(mrt, vr.mifi)) {\r\nvr.icount = vif->pkt_in;\r\nvr.ocount = vif->pkt_out;\r\nvr.ibytes = vif->bytes_in;\r\nvr.obytes = vif->bytes_out;\r\nread_unlock(&mrt_lock);\r\nif (copy_to_user(arg, &vr, sizeof(vr)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nread_unlock(&mrt_lock);\r\nreturn -EADDRNOTAVAIL;\r\ncase SIOCGETSGCNT_IN6:\r\nif (copy_from_user(&sr, arg, sizeof(sr)))\r\nreturn -EFAULT;\r\nread_lock(&mrt_lock);\r\nc = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);\r\nif (c) {\r\nsr.pktcnt = c->mfc_un.res.pkt;\r\nsr.bytecnt = c->mfc_un.res.bytes;\r\nsr.wrong_if = c->mfc_un.res.wrong_if;\r\nread_unlock(&mrt_lock);\r\nif (copy_to_user(arg, &sr, sizeof(sr)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nread_unlock(&mrt_lock);\r\nreturn -EADDRNOTAVAIL;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nint ip6mr_compat_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)\r\n{\r\nstruct compat_sioc_sg_req6 sr;\r\nstruct compat_sioc_mif_req6 vr;\r\nstruct mif_device *vif;\r\nstruct mfc6_cache *c;\r\nstruct net *net = sock_net(sk);\r\nstruct mr6_table *mrt;\r\nmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\r\nif (mrt == NULL)\r\nreturn -ENOENT;\r\nswitch (cmd) {\r\ncase SIOCGETMIFCNT_IN6:\r\nif (copy_from_user(&vr, arg, sizeof(vr)))\r\nreturn -EFAULT;\r\nif (vr.mifi >= mrt->maxvif)\r\nreturn -EINVAL;\r\nread_lock(&mrt_lock);\r\nvif = &mrt->vif6_table[vr.mifi];\r\nif (MIF_EXISTS(mrt, vr.mifi)) {\r\nvr.icount = vif->pkt_in;\r\nvr.ocount = vif->pkt_out;\r\nvr.ibytes = vif->bytes_in;\r\nvr.obytes = vif->bytes_out;\r\nread_unlock(&mrt_lock);\r\nif (copy_to_user(arg, &vr, sizeof(vr)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nread_unlock(&mrt_lock);\r\nreturn -EADDRNOTAVAIL;\r\ncase SIOCGETSGCNT_IN6:\r\nif (copy_from_user(&sr, arg, sizeof(sr)))\r\nreturn -EFAULT;\r\nread_lock(&mrt_lock);\r\nc = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);\r\nif (c) {\r\nsr.pktcnt = c->mfc_un.res.pkt;\r\nsr.bytecnt = c->mfc_un.res.bytes;\r\nsr.wrong_if = c->mfc_un.res.wrong_if;\r\nread_unlock(&mrt_lock);\r\nif (copy_to_user(arg, &sr, sizeof(sr)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nread_unlock(&mrt_lock);\r\nreturn -EADDRNOTAVAIL;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic inline int ip6mr_forward2_finish(struct sk_buff *skb)\r\n{\r\nIP6_INC_STATS_BH(dev_net(skb_dst(skb)->dev), ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_OUTFORWDATAGRAMS);\r\nIP6_ADD_STATS_BH(dev_net(skb_dst(skb)->dev), ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_OUTOCTETS, skb->len);\r\nreturn dst_output(skb);\r\n}\r\nstatic int ip6mr_forward2(struct net *net, struct mr6_table *mrt,\r\nstruct sk_buff *skb, struct mfc6_cache *c, int vifi)\r\n{\r\nstruct ipv6hdr *ipv6h;\r\nstruct mif_device *vif = &mrt->vif6_table[vifi];\r\nstruct net_device *dev;\r\nstruct dst_entry *dst;\r\nstruct flowi6 fl6;\r\nif (vif->dev == NULL)\r\ngoto out_free;\r\n#ifdef CONFIG_IPV6_PIMSM_V2\r\nif (vif->flags & MIFF_REGISTER) {\r\nvif->pkt_out++;\r\nvif->bytes_out += skb->len;\r\nvif->dev->stats.tx_bytes += skb->len;\r\nvif->dev->stats.tx_packets++;\r\nip6mr_cache_report(mrt, skb, vifi, MRT6MSG_WHOLEPKT);\r\ngoto out_free;\r\n}\r\n#endif\r\nipv6h = ipv6_hdr(skb);\r\nfl6 = (struct flowi6) {\r\n.flowi6_oif = vif->link,\r\n.daddr = ipv6h->daddr,\r\n};\r\ndst = ip6_route_output(net, NULL, &fl6);\r\nif (dst->error) {\r\ndst_release(dst);\r\ngoto out_free;\r\n}\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, dst);\r\ndev = vif->dev;\r\nskb->dev = dev;\r\nvif->pkt_out++;\r\nvif->bytes_out += skb->len;\r\nif (skb_cow(skb, sizeof(*ipv6h) + LL_RESERVED_SPACE(dev)))\r\ngoto out_free;\r\nipv6h = ipv6_hdr(skb);\r\nipv6h->hop_limit--;\r\nIP6CB(skb)->flags |= IP6SKB_FORWARDED;\r\nreturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD, skb, skb->dev, dev,\r\nip6mr_forward2_finish);\r\nout_free:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int ip6mr_find_vif(struct mr6_table *mrt, struct net_device *dev)\r\n{\r\nint ct;\r\nfor (ct = mrt->maxvif - 1; ct >= 0; ct--) {\r\nif (mrt->vif6_table[ct].dev == dev)\r\nbreak;\r\n}\r\nreturn ct;\r\n}\r\nstatic void ip6_mr_forward(struct net *net, struct mr6_table *mrt,\r\nstruct sk_buff *skb, struct mfc6_cache *cache)\r\n{\r\nint psend = -1;\r\nint vif, ct;\r\nint true_vifi = ip6mr_find_vif(mrt, skb->dev);\r\nvif = cache->mf6c_parent;\r\ncache->mfc_un.res.pkt++;\r\ncache->mfc_un.res.bytes += skb->len;\r\nif (ipv6_addr_any(&cache->mf6c_origin) && true_vifi >= 0) {\r\nstruct mfc6_cache *cache_proxy;\r\ncache_proxy = ip6mr_cache_find_any_parent(mrt, vif);\r\nif (cache_proxy &&\r\ncache_proxy->mfc_un.res.ttls[true_vifi] < 255)\r\ngoto forward;\r\n}\r\nif (mrt->vif6_table[vif].dev != skb->dev) {\r\ncache->mfc_un.res.wrong_if++;\r\nif (true_vifi >= 0 && mrt->mroute_do_assert &&\r\n(mrt->mroute_do_pim ||\r\ncache->mfc_un.res.ttls[true_vifi] < 255) &&\r\ntime_after(jiffies,\r\ncache->mfc_un.res.last_assert + MFC_ASSERT_THRESH)) {\r\ncache->mfc_un.res.last_assert = jiffies;\r\nip6mr_cache_report(mrt, skb, true_vifi, MRT6MSG_WRONGMIF);\r\n}\r\ngoto dont_forward;\r\n}\r\nforward:\r\nmrt->vif6_table[vif].pkt_in++;\r\nmrt->vif6_table[vif].bytes_in += skb->len;\r\nif (ipv6_addr_any(&cache->mf6c_origin) &&\r\nipv6_addr_any(&cache->mf6c_mcastgrp)) {\r\nif (true_vifi >= 0 &&\r\ntrue_vifi != cache->mf6c_parent &&\r\nipv6_hdr(skb)->hop_limit >\r\ncache->mfc_un.res.ttls[cache->mf6c_parent]) {\r\npsend = cache->mf6c_parent;\r\ngoto last_forward;\r\n}\r\ngoto dont_forward;\r\n}\r\nfor (ct = cache->mfc_un.res.maxvif - 1; ct >= cache->mfc_un.res.minvif; ct--) {\r\nif ((!ipv6_addr_any(&cache->mf6c_origin) || ct != true_vifi) &&\r\nipv6_hdr(skb)->hop_limit > cache->mfc_un.res.ttls[ct]) {\r\nif (psend != -1) {\r\nstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (skb2)\r\nip6mr_forward2(net, mrt, skb2, cache, psend);\r\n}\r\npsend = ct;\r\n}\r\n}\r\nlast_forward:\r\nif (psend != -1) {\r\nip6mr_forward2(net, mrt, skb, cache, psend);\r\nreturn;\r\n}\r\ndont_forward:\r\nkfree_skb(skb);\r\n}\r\nint ip6_mr_input(struct sk_buff *skb)\r\n{\r\nstruct mfc6_cache *cache;\r\nstruct net *net = dev_net(skb->dev);\r\nstruct mr6_table *mrt;\r\nstruct flowi6 fl6 = {\r\n.flowi6_iif = skb->dev->ifindex,\r\n.flowi6_mark = skb->mark,\r\n};\r\nint err;\r\nerr = ip6mr_fib_lookup(net, &fl6, &mrt);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nread_lock(&mrt_lock);\r\ncache = ip6mr_cache_find(mrt,\r\n&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr);\r\nif (cache == NULL) {\r\nint vif = ip6mr_find_vif(mrt, skb->dev);\r\nif (vif >= 0)\r\ncache = ip6mr_cache_find_any(mrt,\r\n&ipv6_hdr(skb)->daddr,\r\nvif);\r\n}\r\nif (cache == NULL) {\r\nint vif;\r\nvif = ip6mr_find_vif(mrt, skb->dev);\r\nif (vif >= 0) {\r\nint err = ip6mr_cache_unresolved(mrt, vif, skb);\r\nread_unlock(&mrt_lock);\r\nreturn err;\r\n}\r\nread_unlock(&mrt_lock);\r\nkfree_skb(skb);\r\nreturn -ENODEV;\r\n}\r\nip6_mr_forward(net, mrt, skb, cache);\r\nread_unlock(&mrt_lock);\r\nreturn 0;\r\n}\r\nstatic int __ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,\r\nstruct mfc6_cache *c, struct rtmsg *rtm)\r\n{\r\nint ct;\r\nstruct rtnexthop *nhp;\r\nstruct nlattr *mp_attr;\r\nstruct rta_mfc_stats mfcs;\r\nif (c->mf6c_parent >= MAXMIFS)\r\nreturn -ENOENT;\r\nif (MIF_EXISTS(mrt, c->mf6c_parent) &&\r\nnla_put_u32(skb, RTA_IIF, mrt->vif6_table[c->mf6c_parent].dev->ifindex) < 0)\r\nreturn -EMSGSIZE;\r\nmp_attr = nla_nest_start(skb, RTA_MULTIPATH);\r\nif (mp_attr == NULL)\r\nreturn -EMSGSIZE;\r\nfor (ct = c->mfc_un.res.minvif; ct < c->mfc_un.res.maxvif; ct++) {\r\nif (MIF_EXISTS(mrt, ct) && c->mfc_un.res.ttls[ct] < 255) {\r\nnhp = nla_reserve_nohdr(skb, sizeof(*nhp));\r\nif (nhp == NULL) {\r\nnla_nest_cancel(skb, mp_attr);\r\nreturn -EMSGSIZE;\r\n}\r\nnhp->rtnh_flags = 0;\r\nnhp->rtnh_hops = c->mfc_un.res.ttls[ct];\r\nnhp->rtnh_ifindex = mrt->vif6_table[ct].dev->ifindex;\r\nnhp->rtnh_len = sizeof(*nhp);\r\n}\r\n}\r\nnla_nest_end(skb, mp_attr);\r\nmfcs.mfcs_packets = c->mfc_un.res.pkt;\r\nmfcs.mfcs_bytes = c->mfc_un.res.bytes;\r\nmfcs.mfcs_wrong_if = c->mfc_un.res.wrong_if;\r\nif (nla_put(skb, RTA_MFC_STATS, sizeof(mfcs), &mfcs) < 0)\r\nreturn -EMSGSIZE;\r\nrtm->rtm_type = RTN_MULTICAST;\r\nreturn 1;\r\n}\r\nint ip6mr_get_route(struct net *net,\r\nstruct sk_buff *skb, struct rtmsg *rtm, int nowait)\r\n{\r\nint err;\r\nstruct mr6_table *mrt;\r\nstruct mfc6_cache *cache;\r\nstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\r\nmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\r\nif (mrt == NULL)\r\nreturn -ENOENT;\r\nread_lock(&mrt_lock);\r\ncache = ip6mr_cache_find(mrt, &rt->rt6i_src.addr, &rt->rt6i_dst.addr);\r\nif (!cache && skb->dev) {\r\nint vif = ip6mr_find_vif(mrt, skb->dev);\r\nif (vif >= 0)\r\ncache = ip6mr_cache_find_any(mrt, &rt->rt6i_dst.addr,\r\nvif);\r\n}\r\nif (!cache) {\r\nstruct sk_buff *skb2;\r\nstruct ipv6hdr *iph;\r\nstruct net_device *dev;\r\nint vif;\r\nif (nowait) {\r\nread_unlock(&mrt_lock);\r\nreturn -EAGAIN;\r\n}\r\ndev = skb->dev;\r\nif (dev == NULL || (vif = ip6mr_find_vif(mrt, dev)) < 0) {\r\nread_unlock(&mrt_lock);\r\nreturn -ENODEV;\r\n}\r\nskb2 = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\r\nif (!skb2) {\r\nread_unlock(&mrt_lock);\r\nreturn -ENOMEM;\r\n}\r\nskb_reset_transport_header(skb2);\r\nskb_put(skb2, sizeof(struct ipv6hdr));\r\nskb_reset_network_header(skb2);\r\niph = ipv6_hdr(skb2);\r\niph->version = 0;\r\niph->priority = 0;\r\niph->flow_lbl[0] = 0;\r\niph->flow_lbl[1] = 0;\r\niph->flow_lbl[2] = 0;\r\niph->payload_len = 0;\r\niph->nexthdr = IPPROTO_NONE;\r\niph->hop_limit = 0;\r\niph->saddr = rt->rt6i_src.addr;\r\niph->daddr = rt->rt6i_dst.addr;\r\nerr = ip6mr_cache_unresolved(mrt, vif, skb2);\r\nread_unlock(&mrt_lock);\r\nreturn err;\r\n}\r\nif (!nowait && (rtm->rtm_flags&RTM_F_NOTIFY))\r\ncache->mfc_flags |= MFC_NOTIFY;\r\nerr = __ip6mr_fill_mroute(mrt, skb, cache, rtm);\r\nread_unlock(&mrt_lock);\r\nreturn err;\r\n}\r\nstatic int ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,\r\nu32 portid, u32 seq, struct mfc6_cache *c, int cmd,\r\nint flags)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct rtmsg *rtm;\r\nint err;\r\nnlh = nlmsg_put(skb, portid, seq, cmd, sizeof(*rtm), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nrtm = nlmsg_data(nlh);\r\nrtm->rtm_family = RTNL_FAMILY_IP6MR;\r\nrtm->rtm_dst_len = 128;\r\nrtm->rtm_src_len = 128;\r\nrtm->rtm_tos = 0;\r\nrtm->rtm_table = mrt->id;\r\nif (nla_put_u32(skb, RTA_TABLE, mrt->id))\r\ngoto nla_put_failure;\r\nrtm->rtm_type = RTN_MULTICAST;\r\nrtm->rtm_scope = RT_SCOPE_UNIVERSE;\r\nif (c->mfc_flags & MFC_STATIC)\r\nrtm->rtm_protocol = RTPROT_STATIC;\r\nelse\r\nrtm->rtm_protocol = RTPROT_MROUTED;\r\nrtm->rtm_flags = 0;\r\nif (nla_put(skb, RTA_SRC, 16, &c->mf6c_origin) ||\r\nnla_put(skb, RTA_DST, 16, &c->mf6c_mcastgrp))\r\ngoto nla_put_failure;\r\nerr = __ip6mr_fill_mroute(mrt, skb, c, rtm);\r\nif (err < 0 && err != -ENOENT)\r\ngoto nla_put_failure;\r\nreturn nlmsg_end(skb, nlh);\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int mr6_msgsize(bool unresolved, int maxvif)\r\n{\r\nsize_t len =\r\nNLMSG_ALIGN(sizeof(struct rtmsg))\r\n+ nla_total_size(4)\r\n+ nla_total_size(sizeof(struct in6_addr))\r\n+ nla_total_size(sizeof(struct in6_addr))\r\n;\r\nif (!unresolved)\r\nlen = len\r\n+ nla_total_size(4)\r\n+ nla_total_size(0)\r\n+ maxvif * NLA_ALIGN(sizeof(struct rtnexthop))\r\n+ nla_total_size(sizeof(struct rta_mfc_stats))\r\n;\r\nreturn len;\r\n}\r\nstatic void mr6_netlink_event(struct mr6_table *mrt, struct mfc6_cache *mfc,\r\nint cmd)\r\n{\r\nstruct net *net = read_pnet(&mrt->net);\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(mr6_msgsize(mfc->mf6c_parent >= MAXMIFS, mrt->maxvif),\r\nGFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = ip6mr_fill_mroute(mrt, skb, 0, 0, mfc, cmd, 0);\r\nif (err < 0)\r\ngoto errout;\r\nrtnl_notify(skb, net, 0, RTNLGRP_IPV6_MROUTE, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nkfree_skb(skb);\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_IPV6_MROUTE, err);\r\n}\r\nstatic int ip6mr_rtm_dumproute(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct mr6_table *mrt;\r\nstruct mfc6_cache *mfc;\r\nunsigned int t = 0, s_t;\r\nunsigned int h = 0, s_h;\r\nunsigned int e = 0, s_e;\r\ns_t = cb->args[0];\r\ns_h = cb->args[1];\r\ns_e = cb->args[2];\r\nread_lock(&mrt_lock);\r\nip6mr_for_each_table(mrt, net) {\r\nif (t < s_t)\r\ngoto next_table;\r\nif (t > s_t)\r\ns_h = 0;\r\nfor (h = s_h; h < MFC6_LINES; h++) {\r\nlist_for_each_entry(mfc, &mrt->mfc6_cache_array[h], list) {\r\nif (e < s_e)\r\ngoto next_entry;\r\nif (ip6mr_fill_mroute(mrt, skb,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nmfc, RTM_NEWROUTE,\r\nNLM_F_MULTI) < 0)\r\ngoto done;\r\nnext_entry:\r\ne++;\r\n}\r\ne = s_e = 0;\r\n}\r\nspin_lock_bh(&mfc_unres_lock);\r\nlist_for_each_entry(mfc, &mrt->mfc6_unres_queue, list) {\r\nif (e < s_e)\r\ngoto next_entry2;\r\nif (ip6mr_fill_mroute(mrt, skb,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nmfc, RTM_NEWROUTE,\r\nNLM_F_MULTI) < 0) {\r\nspin_unlock_bh(&mfc_unres_lock);\r\ngoto done;\r\n}\r\nnext_entry2:\r\ne++;\r\n}\r\nspin_unlock_bh(&mfc_unres_lock);\r\ne = s_e = 0;\r\ns_h = 0;\r\nnext_table:\r\nt++;\r\n}\r\ndone:\r\nread_unlock(&mrt_lock);\r\ncb->args[2] = e;\r\ncb->args[1] = h;\r\ncb->args[0] = t;\r\nreturn skb->len;\r\n}
