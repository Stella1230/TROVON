static inline mbox_msg_t mbox_fifo_read(struct omap_mbox *mbox)\r\n{\r\nreturn mbox->ops->fifo_read(mbox);\r\n}\r\nstatic inline void mbox_fifo_write(struct omap_mbox *mbox, mbox_msg_t msg)\r\n{\r\nmbox->ops->fifo_write(mbox, msg);\r\n}\r\nstatic inline int mbox_fifo_empty(struct omap_mbox *mbox)\r\n{\r\nreturn mbox->ops->fifo_empty(mbox);\r\n}\r\nstatic inline int mbox_fifo_full(struct omap_mbox *mbox)\r\n{\r\nreturn mbox->ops->fifo_full(mbox);\r\n}\r\nstatic inline void ack_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nif (mbox->ops->ack_irq)\r\nmbox->ops->ack_irq(mbox, irq);\r\n}\r\nstatic inline int is_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nreturn mbox->ops->is_irq(mbox, irq);\r\n}\r\nstatic int __mbox_poll_for_space(struct omap_mbox *mbox)\r\n{\r\nint ret = 0, i = 1000;\r\nwhile (mbox_fifo_full(mbox)) {\r\nif (mbox->ops->type == OMAP_MBOX_TYPE2)\r\nreturn -1;\r\nif (--i == 0)\r\nreturn -1;\r\nudelay(1);\r\n}\r\nreturn ret;\r\n}\r\nint omap_mbox_msg_send(struct omap_mbox *mbox, mbox_msg_t msg)\r\n{\r\nstruct omap_mbox_queue *mq = mbox->txq;\r\nint ret = 0, len;\r\nspin_lock_bh(&mq->lock);\r\nif (kfifo_avail(&mq->fifo) < sizeof(msg)) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (kfifo_is_empty(&mq->fifo) && !__mbox_poll_for_space(mbox)) {\r\nmbox_fifo_write(mbox, msg);\r\ngoto out;\r\n}\r\nlen = kfifo_in(&mq->fifo, (unsigned char *)&msg, sizeof(msg));\r\nWARN_ON(len != sizeof(msg));\r\ntasklet_schedule(&mbox->txq->tasklet);\r\nout:\r\nspin_unlock_bh(&mq->lock);\r\nreturn ret;\r\n}\r\nvoid omap_mbox_save_ctx(struct omap_mbox *mbox)\r\n{\r\nif (!mbox->ops->save_ctx) {\r\ndev_err(mbox->dev, "%s:\tno save\n", __func__);\r\nreturn;\r\n}\r\nmbox->ops->save_ctx(mbox);\r\n}\r\nvoid omap_mbox_restore_ctx(struct omap_mbox *mbox)\r\n{\r\nif (!mbox->ops->restore_ctx) {\r\ndev_err(mbox->dev, "%s:\tno restore\n", __func__);\r\nreturn;\r\n}\r\nmbox->ops->restore_ctx(mbox);\r\n}\r\nvoid omap_mbox_enable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nmbox->ops->enable_irq(mbox, irq);\r\n}\r\nvoid omap_mbox_disable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nmbox->ops->disable_irq(mbox, irq);\r\n}\r\nstatic void mbox_tx_tasklet(unsigned long tx_data)\r\n{\r\nstruct omap_mbox *mbox = (struct omap_mbox *)tx_data;\r\nstruct omap_mbox_queue *mq = mbox->txq;\r\nmbox_msg_t msg;\r\nint ret;\r\nwhile (kfifo_len(&mq->fifo)) {\r\nif (__mbox_poll_for_space(mbox)) {\r\nomap_mbox_enable_irq(mbox, IRQ_TX);\r\nbreak;\r\n}\r\nret = kfifo_out(&mq->fifo, (unsigned char *)&msg,\r\nsizeof(msg));\r\nWARN_ON(ret != sizeof(msg));\r\nmbox_fifo_write(mbox, msg);\r\n}\r\n}\r\nstatic void mbox_rx_work(struct work_struct *work)\r\n{\r\nstruct omap_mbox_queue *mq =\r\ncontainer_of(work, struct omap_mbox_queue, work);\r\nmbox_msg_t msg;\r\nint len;\r\nwhile (kfifo_len(&mq->fifo) >= sizeof(msg)) {\r\nlen = kfifo_out(&mq->fifo, (unsigned char *)&msg, sizeof(msg));\r\nWARN_ON(len != sizeof(msg));\r\nblocking_notifier_call_chain(&mq->mbox->notifier, len,\r\n(void *)msg);\r\nspin_lock_irq(&mq->lock);\r\nif (mq->full) {\r\nmq->full = false;\r\nomap_mbox_enable_irq(mq->mbox, IRQ_RX);\r\n}\r\nspin_unlock_irq(&mq->lock);\r\n}\r\n}\r\nstatic void __mbox_tx_interrupt(struct omap_mbox *mbox)\r\n{\r\nomap_mbox_disable_irq(mbox, IRQ_TX);\r\nack_mbox_irq(mbox, IRQ_TX);\r\ntasklet_schedule(&mbox->txq->tasklet);\r\n}\r\nstatic void __mbox_rx_interrupt(struct omap_mbox *mbox)\r\n{\r\nstruct omap_mbox_queue *mq = mbox->rxq;\r\nmbox_msg_t msg;\r\nint len;\r\nwhile (!mbox_fifo_empty(mbox)) {\r\nif (unlikely(kfifo_avail(&mq->fifo) < sizeof(msg))) {\r\nomap_mbox_disable_irq(mbox, IRQ_RX);\r\nmq->full = true;\r\ngoto nomem;\r\n}\r\nmsg = mbox_fifo_read(mbox);\r\nlen = kfifo_in(&mq->fifo, (unsigned char *)&msg, sizeof(msg));\r\nWARN_ON(len != sizeof(msg));\r\nif (mbox->ops->type == OMAP_MBOX_TYPE1)\r\nbreak;\r\n}\r\nack_mbox_irq(mbox, IRQ_RX);\r\nnomem:\r\nschedule_work(&mbox->rxq->work);\r\n}\r\nstatic irqreturn_t mbox_interrupt(int irq, void *p)\r\n{\r\nstruct omap_mbox *mbox = p;\r\nif (is_mbox_irq(mbox, IRQ_TX))\r\n__mbox_tx_interrupt(mbox);\r\nif (is_mbox_irq(mbox, IRQ_RX))\r\n__mbox_rx_interrupt(mbox);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct omap_mbox_queue *mbox_queue_alloc(struct omap_mbox *mbox,\r\nvoid (*work) (struct work_struct *),\r\nvoid (*tasklet)(unsigned long))\r\n{\r\nstruct omap_mbox_queue *mq;\r\nmq = kzalloc(sizeof(struct omap_mbox_queue), GFP_KERNEL);\r\nif (!mq)\r\nreturn NULL;\r\nspin_lock_init(&mq->lock);\r\nif (kfifo_alloc(&mq->fifo, mbox_kfifo_size, GFP_KERNEL))\r\ngoto error;\r\nif (work)\r\nINIT_WORK(&mq->work, work);\r\nif (tasklet)\r\ntasklet_init(&mq->tasklet, tasklet, (unsigned long)mbox);\r\nreturn mq;\r\nerror:\r\nkfree(mq);\r\nreturn NULL;\r\n}\r\nstatic void mbox_queue_free(struct omap_mbox_queue *q)\r\n{\r\nkfifo_free(&q->fifo);\r\nkfree(q);\r\n}\r\nstatic int omap_mbox_startup(struct omap_mbox *mbox)\r\n{\r\nint ret = 0;\r\nstruct omap_mbox_queue *mq;\r\nmutex_lock(&mbox_configured_lock);\r\nif (!mbox_configured++) {\r\nif (likely(mbox->ops->startup)) {\r\nret = mbox->ops->startup(mbox);\r\nif (unlikely(ret))\r\ngoto fail_startup;\r\n} else\r\ngoto fail_startup;\r\n}\r\nif (!mbox->use_count++) {\r\nmq = mbox_queue_alloc(mbox, NULL, mbox_tx_tasklet);\r\nif (!mq) {\r\nret = -ENOMEM;\r\ngoto fail_alloc_txq;\r\n}\r\nmbox->txq = mq;\r\nmq = mbox_queue_alloc(mbox, mbox_rx_work, NULL);\r\nif (!mq) {\r\nret = -ENOMEM;\r\ngoto fail_alloc_rxq;\r\n}\r\nmbox->rxq = mq;\r\nmq->mbox = mbox;\r\nret = request_irq(mbox->irq, mbox_interrupt, IRQF_SHARED,\r\nmbox->name, mbox);\r\nif (unlikely(ret)) {\r\npr_err("failed to register mailbox interrupt:%d\n",\r\nret);\r\ngoto fail_request_irq;\r\n}\r\nomap_mbox_enable_irq(mbox, IRQ_RX);\r\n}\r\nmutex_unlock(&mbox_configured_lock);\r\nreturn 0;\r\nfail_request_irq:\r\nmbox_queue_free(mbox->rxq);\r\nfail_alloc_rxq:\r\nmbox_queue_free(mbox->txq);\r\nfail_alloc_txq:\r\nif (mbox->ops->shutdown)\r\nmbox->ops->shutdown(mbox);\r\nmbox->use_count--;\r\nfail_startup:\r\nmbox_configured--;\r\nmutex_unlock(&mbox_configured_lock);\r\nreturn ret;\r\n}\r\nstatic void omap_mbox_fini(struct omap_mbox *mbox)\r\n{\r\nmutex_lock(&mbox_configured_lock);\r\nif (!--mbox->use_count) {\r\nomap_mbox_disable_irq(mbox, IRQ_RX);\r\nfree_irq(mbox->irq, mbox);\r\ntasklet_kill(&mbox->txq->tasklet);\r\nflush_work(&mbox->rxq->work);\r\nmbox_queue_free(mbox->txq);\r\nmbox_queue_free(mbox->rxq);\r\n}\r\nif (likely(mbox->ops->shutdown)) {\r\nif (!--mbox_configured)\r\nmbox->ops->shutdown(mbox);\r\n}\r\nmutex_unlock(&mbox_configured_lock);\r\n}\r\nstruct omap_mbox *omap_mbox_get(const char *name, struct notifier_block *nb)\r\n{\r\nstruct omap_mbox *_mbox, *mbox = NULL;\r\nint i, ret;\r\nif (!mboxes)\r\nreturn ERR_PTR(-EINVAL);\r\nfor (i = 0; (_mbox = mboxes[i]); i++) {\r\nif (!strcmp(_mbox->name, name)) {\r\nmbox = _mbox;\r\nbreak;\r\n}\r\n}\r\nif (!mbox)\r\nreturn ERR_PTR(-ENOENT);\r\nif (nb)\r\nblocking_notifier_chain_register(&mbox->notifier, nb);\r\nret = omap_mbox_startup(mbox);\r\nif (ret) {\r\nblocking_notifier_chain_unregister(&mbox->notifier, nb);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nreturn mbox;\r\n}\r\nvoid omap_mbox_put(struct omap_mbox *mbox, struct notifier_block *nb)\r\n{\r\nblocking_notifier_chain_unregister(&mbox->notifier, nb);\r\nomap_mbox_fini(mbox);\r\n}\r\nint omap_mbox_register(struct device *parent, struct omap_mbox **list)\r\n{\r\nint ret;\r\nint i;\r\nmboxes = list;\r\nif (!mboxes)\r\nreturn -EINVAL;\r\nfor (i = 0; mboxes[i]; i++) {\r\nstruct omap_mbox *mbox = mboxes[i];\r\nmbox->dev = device_create(&omap_mbox_class,\r\nparent, 0, mbox, "%s", mbox->name);\r\nif (IS_ERR(mbox->dev)) {\r\nret = PTR_ERR(mbox->dev);\r\ngoto err_out;\r\n}\r\nBLOCKING_INIT_NOTIFIER_HEAD(&mbox->notifier);\r\n}\r\nreturn 0;\r\nerr_out:\r\nwhile (i--)\r\ndevice_unregister(mboxes[i]->dev);\r\nreturn ret;\r\n}\r\nint omap_mbox_unregister(void)\r\n{\r\nint i;\r\nif (!mboxes)\r\nreturn -EINVAL;\r\nfor (i = 0; mboxes[i]; i++)\r\ndevice_unregister(mboxes[i]->dev);\r\nmboxes = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init omap_mbox_init(void)\r\n{\r\nint err;\r\nerr = class_register(&omap_mbox_class);\r\nif (err)\r\nreturn err;\r\nmbox_kfifo_size = ALIGN(mbox_kfifo_size, sizeof(mbox_msg_t));\r\nmbox_kfifo_size = max_t(unsigned int, mbox_kfifo_size,\r\nsizeof(mbox_msg_t));\r\nreturn 0;\r\n}\r\nstatic void __exit omap_mbox_exit(void)\r\n{\r\nclass_unregister(&omap_mbox_class);\r\n}
