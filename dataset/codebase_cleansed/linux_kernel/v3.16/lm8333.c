int lm8333_read8(struct lm8333 *lm8333, u8 cmd)\r\n{\r\nint retries = 0, ret;\r\ndo {\r\nret = i2c_smbus_read_byte_data(lm8333->client, cmd);\r\n} while (ret < 0 && retries++ < LM8333_READ_RETRIES);\r\nreturn ret;\r\n}\r\nint lm8333_write8(struct lm8333 *lm8333, u8 cmd, u8 val)\r\n{\r\nint retries = 0, ret;\r\ndo {\r\nret = i2c_smbus_write_byte_data(lm8333->client, cmd, val);\r\n} while (ret < 0 && retries++ < LM8333_READ_RETRIES);\r\nreturn ret;\r\n}\r\nint lm8333_read_block(struct lm8333 *lm8333, u8 cmd, u8 len, u8 *buf)\r\n{\r\nint retries = 0, ret;\r\ndo {\r\nret = i2c_smbus_read_i2c_block_data(lm8333->client,\r\ncmd, len, buf);\r\n} while (ret < 0 && retries++ < LM8333_READ_RETRIES);\r\nreturn ret;\r\n}\r\nstatic void lm8333_key_handler(struct lm8333 *lm8333)\r\n{\r\nstruct input_dev *input = lm8333->input;\r\nu8 keys[LM8333_FIFO_TRANSFER_SIZE];\r\nu8 code, pressed;\r\nint i, ret;\r\nret = lm8333_read_block(lm8333, LM8333_FIFO_READ,\r\nLM8333_FIFO_TRANSFER_SIZE, keys);\r\nif (ret != LM8333_FIFO_TRANSFER_SIZE) {\r\ndev_err(&lm8333->client->dev,\r\n"Error %d while reading FIFO\n", ret);\r\nreturn;\r\n}\r\nfor (i = 0; i < LM8333_FIFO_TRANSFER_SIZE && keys[i]; i++) {\r\npressed = keys[i] & 0x80;\r\ncode = keys[i] & 0x7f;\r\ninput_event(input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input, lm8333->keycodes[code], pressed);\r\n}\r\ninput_sync(input);\r\n}\r\nstatic irqreturn_t lm8333_irq_thread(int irq, void *data)\r\n{\r\nstruct lm8333 *lm8333 = data;\r\nu8 status = lm8333_read8(lm8333, LM8333_READ_INT);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nif (status & LM8333_ERROR_IRQ) {\r\nu8 err = lm8333_read8(lm8333, LM8333_READ_ERROR);\r\nif (err & (LM8333_ERROR_KEYOVR | LM8333_ERROR_FIFOOVR)) {\r\nu8 dummy[LM8333_FIFO_TRANSFER_SIZE];\r\nlm8333_read_block(lm8333, LM8333_FIFO_READ,\r\nLM8333_FIFO_TRANSFER_SIZE, dummy);\r\n}\r\ndev_err(&lm8333->client->dev, "Got error %02x\n", err);\r\n}\r\nif (status & LM8333_KEYPAD_IRQ)\r\nlm8333_key_handler(lm8333);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lm8333_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct lm8333_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct lm8333 *lm8333;\r\nstruct input_dev *input;\r\nint err, active_time;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nactive_time = pdata->active_time ?: 500;\r\nif (active_time / 3 <= pdata->debounce_time / 3) {\r\ndev_err(&client->dev, "Active time not big enough!\n");\r\nreturn -EINVAL;\r\n}\r\nlm8333 = kzalloc(sizeof(*lm8333), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!lm8333 || !input) {\r\nerr = -ENOMEM;\r\ngoto free_mem;\r\n}\r\nlm8333->client = client;\r\nlm8333->input = input;\r\ninput->name = client->name;\r\ninput->dev.parent = &client->dev;\r\ninput->id.bustype = BUS_I2C;\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\nerr = matrix_keypad_build_keymap(pdata->matrix_data, NULL,\r\nLM8333_NUM_ROWS, LM8333_NUM_COLS,\r\nlm8333->keycodes, input);\r\nif (err)\r\ngoto free_mem;\r\nif (pdata->debounce_time) {\r\nerr = lm8333_write8(lm8333, LM8333_DEBOUNCE,\r\npdata->debounce_time / 3);\r\nif (err)\r\ndev_warn(&client->dev, "Unable to set debounce time\n");\r\n}\r\nif (pdata->active_time) {\r\nerr = lm8333_write8(lm8333, LM8333_ACTIVE,\r\npdata->active_time / 3);\r\nif (err)\r\ndev_warn(&client->dev, "Unable to set active time\n");\r\n}\r\nerr = request_threaded_irq(client->irq, NULL, lm8333_irq_thread,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"lm8333", lm8333);\r\nif (err)\r\ngoto free_mem;\r\nerr = input_register_device(input);\r\nif (err)\r\ngoto free_irq;\r\ni2c_set_clientdata(client, lm8333);\r\nreturn 0;\r\nfree_irq:\r\nfree_irq(client->irq, lm8333);\r\nfree_mem:\r\ninput_free_device(input);\r\nkfree(lm8333);\r\nreturn err;\r\n}\r\nstatic int lm8333_remove(struct i2c_client *client)\r\n{\r\nstruct lm8333 *lm8333 = i2c_get_clientdata(client);\r\nfree_irq(client->irq, lm8333);\r\ninput_unregister_device(lm8333->input);\r\nkfree(lm8333);\r\nreturn 0;\r\n}
