static s32 vmci_transport_error_to_vsock_error(s32 vmci_error)\r\n{\r\nint err;\r\nswitch (vmci_error) {\r\ncase VMCI_ERROR_NO_MEM:\r\nerr = ENOMEM;\r\nbreak;\r\ncase VMCI_ERROR_DUPLICATE_ENTRY:\r\ncase VMCI_ERROR_ALREADY_EXISTS:\r\nerr = EADDRINUSE;\r\nbreak;\r\ncase VMCI_ERROR_NO_ACCESS:\r\nerr = EPERM;\r\nbreak;\r\ncase VMCI_ERROR_NO_RESOURCES:\r\nerr = ENOBUFS;\r\nbreak;\r\ncase VMCI_ERROR_INVALID_RESOURCE:\r\nerr = EHOSTUNREACH;\r\nbreak;\r\ncase VMCI_ERROR_INVALID_ARGS:\r\ndefault:\r\nerr = EINVAL;\r\n}\r\nreturn err > 0 ? -err : err;\r\n}\r\nstatic u32 vmci_transport_peer_rid(u32 peer_cid)\r\n{\r\nif (VMADDR_CID_HYPERVISOR == peer_cid)\r\nreturn VMCI_TRANSPORT_HYPERVISOR_PACKET_RID;\r\nreturn VMCI_TRANSPORT_PACKET_RID;\r\n}\r\nstatic inline void\r\nvmci_transport_packet_init(struct vmci_transport_packet *pkt,\r\nstruct sockaddr_vm *src,\r\nstruct sockaddr_vm *dst,\r\nu8 type,\r\nu64 size,\r\nu64 mode,\r\nstruct vmci_transport_waiting_info *wait,\r\nu16 proto,\r\nstruct vmci_handle handle)\r\n{\r\npkt->dg.src = vmci_make_handle(VMADDR_CID_ANY,\r\nVMCI_TRANSPORT_PACKET_RID);\r\npkt->dg.dst = vmci_make_handle(dst->svm_cid,\r\nvmci_transport_peer_rid(dst->svm_cid));\r\npkt->dg.payload_size = sizeof(*pkt) - sizeof(pkt->dg);\r\npkt->version = VMCI_TRANSPORT_PACKET_VERSION;\r\npkt->type = type;\r\npkt->src_port = src->svm_port;\r\npkt->dst_port = dst->svm_port;\r\nmemset(&pkt->proto, 0, sizeof(pkt->proto));\r\nmemset(&pkt->_reserved2, 0, sizeof(pkt->_reserved2));\r\nswitch (pkt->type) {\r\ncase VMCI_TRANSPORT_PACKET_TYPE_INVALID:\r\npkt->u.size = 0;\r\nbreak;\r\ncase VMCI_TRANSPORT_PACKET_TYPE_REQUEST:\r\ncase VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE:\r\npkt->u.size = size;\r\nbreak;\r\ncase VMCI_TRANSPORT_PACKET_TYPE_OFFER:\r\ncase VMCI_TRANSPORT_PACKET_TYPE_ATTACH:\r\npkt->u.handle = handle;\r\nbreak;\r\ncase VMCI_TRANSPORT_PACKET_TYPE_WROTE:\r\ncase VMCI_TRANSPORT_PACKET_TYPE_READ:\r\ncase VMCI_TRANSPORT_PACKET_TYPE_RST:\r\npkt->u.size = 0;\r\nbreak;\r\ncase VMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN:\r\npkt->u.mode = mode;\r\nbreak;\r\ncase VMCI_TRANSPORT_PACKET_TYPE_WAITING_READ:\r\ncase VMCI_TRANSPORT_PACKET_TYPE_WAITING_WRITE:\r\nmemcpy(&pkt->u.wait, wait, sizeof(pkt->u.wait));\r\nbreak;\r\ncase VMCI_TRANSPORT_PACKET_TYPE_REQUEST2:\r\ncase VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2:\r\npkt->u.size = size;\r\npkt->proto = proto;\r\nbreak;\r\n}\r\n}\r\nstatic inline void\r\nvmci_transport_packet_get_addresses(struct vmci_transport_packet *pkt,\r\nstruct sockaddr_vm *local,\r\nstruct sockaddr_vm *remote)\r\n{\r\nvsock_addr_init(local, pkt->dg.dst.context, pkt->dst_port);\r\nvsock_addr_init(remote, pkt->dg.src.context, pkt->src_port);\r\n}\r\nstatic int\r\n__vmci_transport_send_control_pkt(struct vmci_transport_packet *pkt,\r\nstruct sockaddr_vm *src,\r\nstruct sockaddr_vm *dst,\r\nenum vmci_transport_packet_type type,\r\nu64 size,\r\nu64 mode,\r\nstruct vmci_transport_waiting_info *wait,\r\nu16 proto,\r\nstruct vmci_handle handle,\r\nbool convert_error)\r\n{\r\nint err;\r\nvmci_transport_packet_init(pkt, src, dst, type, size, mode, wait,\r\nproto, handle);\r\nerr = vmci_datagram_send(&pkt->dg);\r\nif (convert_error && (err < 0))\r\nreturn vmci_transport_error_to_vsock_error(err);\r\nreturn err;\r\n}\r\nstatic int\r\nvmci_transport_reply_control_pkt_fast(struct vmci_transport_packet *pkt,\r\nenum vmci_transport_packet_type type,\r\nu64 size,\r\nu64 mode,\r\nstruct vmci_transport_waiting_info *wait,\r\nstruct vmci_handle handle)\r\n{\r\nstruct vmci_transport_packet reply;\r\nstruct sockaddr_vm src, dst;\r\nif (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST) {\r\nreturn 0;\r\n} else {\r\nvmci_transport_packet_get_addresses(pkt, &src, &dst);\r\nreturn __vmci_transport_send_control_pkt(&reply, &src, &dst,\r\ntype,\r\nsize, mode, wait,\r\nVSOCK_PROTO_INVALID,\r\nhandle, true);\r\n}\r\n}\r\nstatic int\r\nvmci_transport_send_control_pkt_bh(struct sockaddr_vm *src,\r\nstruct sockaddr_vm *dst,\r\nenum vmci_transport_packet_type type,\r\nu64 size,\r\nu64 mode,\r\nstruct vmci_transport_waiting_info *wait,\r\nstruct vmci_handle handle)\r\n{\r\nstatic struct vmci_transport_packet pkt;\r\nreturn __vmci_transport_send_control_pkt(&pkt, src, dst, type,\r\nsize, mode, wait,\r\nVSOCK_PROTO_INVALID, handle,\r\nfalse);\r\n}\r\nstatic int\r\nvmci_transport_send_control_pkt(struct sock *sk,\r\nenum vmci_transport_packet_type type,\r\nu64 size,\r\nu64 mode,\r\nstruct vmci_transport_waiting_info *wait,\r\nu16 proto,\r\nstruct vmci_handle handle)\r\n{\r\nstruct vmci_transport_packet *pkt;\r\nstruct vsock_sock *vsk;\r\nint err;\r\nvsk = vsock_sk(sk);\r\nif (!vsock_addr_bound(&vsk->local_addr))\r\nreturn -EINVAL;\r\nif (!vsock_addr_bound(&vsk->remote_addr))\r\nreturn -EINVAL;\r\npkt = kmalloc(sizeof(*pkt), GFP_KERNEL);\r\nif (!pkt)\r\nreturn -ENOMEM;\r\nerr = __vmci_transport_send_control_pkt(pkt, &vsk->local_addr,\r\n&vsk->remote_addr, type, size,\r\nmode, wait, proto, handle,\r\ntrue);\r\nkfree(pkt);\r\nreturn err;\r\n}\r\nstatic int vmci_transport_send_reset_bh(struct sockaddr_vm *dst,\r\nstruct sockaddr_vm *src,\r\nstruct vmci_transport_packet *pkt)\r\n{\r\nif (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST)\r\nreturn 0;\r\nreturn vmci_transport_send_control_pkt_bh(\r\ndst, src,\r\nVMCI_TRANSPORT_PACKET_TYPE_RST, 0,\r\n0, NULL, VMCI_INVALID_HANDLE);\r\n}\r\nstatic int vmci_transport_send_reset(struct sock *sk,\r\nstruct vmci_transport_packet *pkt)\r\n{\r\nif (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST)\r\nreturn 0;\r\nreturn vmci_transport_send_control_pkt(sk,\r\nVMCI_TRANSPORT_PACKET_TYPE_RST,\r\n0, 0, NULL, VSOCK_PROTO_INVALID,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nstatic int vmci_transport_send_negotiate(struct sock *sk, size_t size)\r\n{\r\nreturn vmci_transport_send_control_pkt(\r\nsk,\r\nVMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE,\r\nsize, 0, NULL,\r\nVSOCK_PROTO_INVALID,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nstatic int vmci_transport_send_negotiate2(struct sock *sk, size_t size,\r\nu16 version)\r\n{\r\nreturn vmci_transport_send_control_pkt(\r\nsk,\r\nVMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2,\r\nsize, 0, NULL, version,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nstatic int vmci_transport_send_qp_offer(struct sock *sk,\r\nstruct vmci_handle handle)\r\n{\r\nreturn vmci_transport_send_control_pkt(\r\nsk, VMCI_TRANSPORT_PACKET_TYPE_OFFER, 0,\r\n0, NULL,\r\nVSOCK_PROTO_INVALID, handle);\r\n}\r\nstatic int vmci_transport_send_attach(struct sock *sk,\r\nstruct vmci_handle handle)\r\n{\r\nreturn vmci_transport_send_control_pkt(\r\nsk, VMCI_TRANSPORT_PACKET_TYPE_ATTACH,\r\n0, 0, NULL, VSOCK_PROTO_INVALID,\r\nhandle);\r\n}\r\nstatic int vmci_transport_reply_reset(struct vmci_transport_packet *pkt)\r\n{\r\nreturn vmci_transport_reply_control_pkt_fast(\r\npkt,\r\nVMCI_TRANSPORT_PACKET_TYPE_RST,\r\n0, 0, NULL,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nstatic int vmci_transport_send_invalid_bh(struct sockaddr_vm *dst,\r\nstruct sockaddr_vm *src)\r\n{\r\nreturn vmci_transport_send_control_pkt_bh(\r\ndst, src,\r\nVMCI_TRANSPORT_PACKET_TYPE_INVALID,\r\n0, 0, NULL, VMCI_INVALID_HANDLE);\r\n}\r\nint vmci_transport_send_wrote_bh(struct sockaddr_vm *dst,\r\nstruct sockaddr_vm *src)\r\n{\r\nreturn vmci_transport_send_control_pkt_bh(\r\ndst, src,\r\nVMCI_TRANSPORT_PACKET_TYPE_WROTE, 0,\r\n0, NULL, VMCI_INVALID_HANDLE);\r\n}\r\nint vmci_transport_send_read_bh(struct sockaddr_vm *dst,\r\nstruct sockaddr_vm *src)\r\n{\r\nreturn vmci_transport_send_control_pkt_bh(\r\ndst, src,\r\nVMCI_TRANSPORT_PACKET_TYPE_READ, 0,\r\n0, NULL, VMCI_INVALID_HANDLE);\r\n}\r\nint vmci_transport_send_wrote(struct sock *sk)\r\n{\r\nreturn vmci_transport_send_control_pkt(\r\nsk, VMCI_TRANSPORT_PACKET_TYPE_WROTE, 0,\r\n0, NULL, VSOCK_PROTO_INVALID,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nint vmci_transport_send_read(struct sock *sk)\r\n{\r\nreturn vmci_transport_send_control_pkt(\r\nsk, VMCI_TRANSPORT_PACKET_TYPE_READ, 0,\r\n0, NULL, VSOCK_PROTO_INVALID,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nint vmci_transport_send_waiting_write(struct sock *sk,\r\nstruct vmci_transport_waiting_info *wait)\r\n{\r\nreturn vmci_transport_send_control_pkt(\r\nsk, VMCI_TRANSPORT_PACKET_TYPE_WAITING_WRITE,\r\n0, 0, wait, VSOCK_PROTO_INVALID,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nint vmci_transport_send_waiting_read(struct sock *sk,\r\nstruct vmci_transport_waiting_info *wait)\r\n{\r\nreturn vmci_transport_send_control_pkt(\r\nsk, VMCI_TRANSPORT_PACKET_TYPE_WAITING_READ,\r\n0, 0, wait, VSOCK_PROTO_INVALID,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nstatic int vmci_transport_shutdown(struct vsock_sock *vsk, int mode)\r\n{\r\nreturn vmci_transport_send_control_pkt(\r\n&vsk->sk,\r\nVMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN,\r\n0, mode, NULL,\r\nVSOCK_PROTO_INVALID,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nstatic int vmci_transport_send_conn_request(struct sock *sk, size_t size)\r\n{\r\nreturn vmci_transport_send_control_pkt(sk,\r\nVMCI_TRANSPORT_PACKET_TYPE_REQUEST,\r\nsize, 0, NULL,\r\nVSOCK_PROTO_INVALID,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nstatic int vmci_transport_send_conn_request2(struct sock *sk, size_t size,\r\nu16 version)\r\n{\r\nreturn vmci_transport_send_control_pkt(\r\nsk, VMCI_TRANSPORT_PACKET_TYPE_REQUEST2,\r\nsize, 0, NULL, version,\r\nVMCI_INVALID_HANDLE);\r\n}\r\nstatic struct sock *vmci_transport_get_pending(\r\nstruct sock *listener,\r\nstruct vmci_transport_packet *pkt)\r\n{\r\nstruct vsock_sock *vlistener;\r\nstruct vsock_sock *vpending;\r\nstruct sock *pending;\r\nstruct sockaddr_vm src;\r\nvsock_addr_init(&src, pkt->dg.src.context, pkt->src_port);\r\nvlistener = vsock_sk(listener);\r\nlist_for_each_entry(vpending, &vlistener->pending_links,\r\npending_links) {\r\nif (vsock_addr_equals_addr(&src, &vpending->remote_addr) &&\r\npkt->dst_port == vpending->local_addr.svm_port) {\r\npending = sk_vsock(vpending);\r\nsock_hold(pending);\r\ngoto found;\r\n}\r\n}\r\npending = NULL;\r\nfound:\r\nreturn pending;\r\n}\r\nstatic void vmci_transport_release_pending(struct sock *pending)\r\n{\r\nsock_put(pending);\r\n}\r\nstatic bool vmci_transport_is_trusted(struct vsock_sock *vsock, u32 peer_cid)\r\n{\r\nreturn vsock->trusted ||\r\nvmci_is_context_owner(peer_cid, vsock->owner->uid);\r\n}\r\nstatic bool vmci_transport_allow_dgram(struct vsock_sock *vsock, u32 peer_cid)\r\n{\r\nif (VMADDR_CID_HYPERVISOR == peer_cid)\r\nreturn true;\r\nif (vsock->cached_peer != peer_cid) {\r\nvsock->cached_peer = peer_cid;\r\nif (!vmci_transport_is_trusted(vsock, peer_cid) &&\r\n(vmci_context_get_priv_flags(peer_cid) &\r\nVMCI_PRIVILEGE_FLAG_RESTRICTED)) {\r\nvsock->cached_peer_allow_dgram = false;\r\n} else {\r\nvsock->cached_peer_allow_dgram = true;\r\n}\r\n}\r\nreturn vsock->cached_peer_allow_dgram;\r\n}\r\nstatic int\r\nvmci_transport_queue_pair_alloc(struct vmci_qp **qpair,\r\nstruct vmci_handle *handle,\r\nu64 produce_size,\r\nu64 consume_size,\r\nu32 peer, u32 flags, bool trusted)\r\n{\r\nint err = 0;\r\nif (trusted) {\r\nerr = vmci_qpair_alloc(qpair, handle, produce_size,\r\nconsume_size,\r\npeer, flags,\r\nVMCI_PRIVILEGE_FLAG_TRUSTED);\r\nif (err != VMCI_ERROR_NO_ACCESS)\r\ngoto out;\r\n}\r\nerr = vmci_qpair_alloc(qpair, handle, produce_size, consume_size,\r\npeer, flags, VMCI_NO_PRIVILEGE_FLAGS);\r\nout:\r\nif (err < 0) {\r\npr_err("Could not attach to queue pair with %d\n",\r\nerr);\r\nerr = vmci_transport_error_to_vsock_error(err);\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nvmci_transport_datagram_create_hnd(u32 resource_id,\r\nu32 flags,\r\nvmci_datagram_recv_cb recv_cb,\r\nvoid *client_data,\r\nstruct vmci_handle *out_handle)\r\n{\r\nint err = 0;\r\nerr = vmci_datagram_create_handle_priv(resource_id, flags,\r\nVMCI_PRIVILEGE_FLAG_TRUSTED,\r\nrecv_cb,\r\nclient_data, out_handle);\r\nif (err == VMCI_ERROR_NO_ACCESS)\r\nerr = vmci_datagram_create_handle(resource_id, flags,\r\nrecv_cb, client_data,\r\nout_handle);\r\nreturn err;\r\n}\r\nstatic int vmci_transport_recv_dgram_cb(void *data, struct vmci_datagram *dg)\r\n{\r\nstruct sock *sk;\r\nsize_t size;\r\nstruct sk_buff *skb;\r\nstruct vsock_sock *vsk;\r\nsk = (struct sock *)data;\r\nvsk = vsock_sk(sk);\r\nif (!vmci_transport_allow_dgram(vsk, dg->src.context))\r\nreturn VMCI_ERROR_NO_ACCESS;\r\nsize = VMCI_DG_SIZE(dg);\r\nskb = alloc_skb(size, GFP_ATOMIC);\r\nif (!skb)\r\nreturn VMCI_ERROR_NO_MEM;\r\nsock_hold(sk);\r\nskb_put(skb, size);\r\nmemcpy(skb->data, dg, size);\r\nsk_receive_skb(sk, skb, 0);\r\nreturn VMCI_SUCCESS;\r\n}\r\nstatic bool vmci_transport_stream_allow(u32 cid, u32 port)\r\n{\r\nstatic const u32 non_socket_contexts[] = {\r\nVMADDR_CID_RESERVED,\r\n};\r\nint i;\r\nBUILD_BUG_ON(sizeof(cid) != sizeof(*non_socket_contexts));\r\nfor (i = 0; i < ARRAY_SIZE(non_socket_contexts); i++) {\r\nif (cid == non_socket_contexts[i])\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int vmci_transport_recv_stream_cb(void *data, struct vmci_datagram *dg)\r\n{\r\nstruct sock *sk;\r\nstruct sockaddr_vm dst;\r\nstruct sockaddr_vm src;\r\nstruct vmci_transport_packet *pkt;\r\nstruct vsock_sock *vsk;\r\nbool bh_process_pkt;\r\nint err;\r\nsk = NULL;\r\nerr = VMCI_SUCCESS;\r\nbh_process_pkt = false;\r\nif (!vmci_transport_stream_allow(dg->src.context, -1)\r\n|| vmci_transport_peer_rid(dg->src.context) != dg->src.resource)\r\nreturn VMCI_ERROR_NO_ACCESS;\r\nif (VMCI_DG_SIZE(dg) < sizeof(*pkt))\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\npkt = (struct vmci_transport_packet *)dg;\r\nvsock_addr_init(&src, pkt->dg.src.context, pkt->src_port);\r\nvsock_addr_init(&dst, pkt->dg.dst.context, pkt->dst_port);\r\nsk = vsock_find_connected_socket(&src, &dst);\r\nif (!sk) {\r\nsk = vsock_find_bound_socket(&dst);\r\nif (!sk) {\r\nif (vmci_transport_send_reset_bh(&dst, &src, pkt) < 0)\r\npr_err("unable to send reset\n");\r\nerr = VMCI_ERROR_NOT_FOUND;\r\ngoto out;\r\n}\r\n}\r\nif (pkt->type >= VMCI_TRANSPORT_PACKET_TYPE_MAX) {\r\nvmci_transport_send_invalid_bh(&dst, &src);\r\nerr = VMCI_ERROR_INVALID_ARGS;\r\ngoto out;\r\n}\r\nvsk = vsock_sk(sk);\r\nif (!vmci_transport_allow_dgram(vsk, pkt->dg.src.context)) {\r\nerr = VMCI_ERROR_NO_ACCESS;\r\ngoto out;\r\n}\r\nbh_lock_sock(sk);\r\nif (!sock_owned_by_user(sk)) {\r\nvsk->local_addr.svm_cid = dst.svm_cid;\r\nif (sk->sk_state == SS_CONNECTED)\r\nvmci_trans(vsk)->notify_ops->handle_notify_pkt(\r\nsk, pkt, true, &dst, &src,\r\n&bh_process_pkt);\r\n}\r\nbh_unlock_sock(sk);\r\nif (!bh_process_pkt) {\r\nstruct vmci_transport_recv_pkt_info *recv_pkt_info;\r\nrecv_pkt_info = kmalloc(sizeof(*recv_pkt_info), GFP_ATOMIC);\r\nif (!recv_pkt_info) {\r\nif (vmci_transport_send_reset_bh(&dst, &src, pkt) < 0)\r\npr_err("unable to send reset\n");\r\nerr = VMCI_ERROR_NO_MEM;\r\ngoto out;\r\n}\r\nrecv_pkt_info->sk = sk;\r\nmemcpy(&recv_pkt_info->pkt, pkt, sizeof(recv_pkt_info->pkt));\r\nINIT_WORK(&recv_pkt_info->work, vmci_transport_recv_pkt_work);\r\nschedule_work(&recv_pkt_info->work);\r\nsk = NULL;\r\n}\r\nout:\r\nif (sk)\r\nsock_put(sk);\r\nreturn err;\r\n}\r\nstatic void vmci_transport_peer_attach_cb(u32 sub_id,\r\nconst struct vmci_event_data *e_data,\r\nvoid *client_data)\r\n{\r\nstruct sock *sk = client_data;\r\nconst struct vmci_event_payload_qp *e_payload;\r\nstruct vsock_sock *vsk;\r\ne_payload = vmci_event_data_const_payload(e_data);\r\nvsk = vsock_sk(sk);\r\nlocal_bh_disable();\r\nbh_lock_sock(sk);\r\nif (vmci_handle_is_equal(vmci_trans(vsk)->qp_handle,\r\ne_payload->handle)) {\r\ngoto out;\r\n}\r\nout:\r\nbh_unlock_sock(sk);\r\nlocal_bh_enable();\r\n}\r\nstatic void vmci_transport_handle_detach(struct sock *sk)\r\n{\r\nstruct vsock_sock *vsk;\r\nvsk = vsock_sk(sk);\r\nif (!vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle)) {\r\nsock_set_flag(sk, SOCK_DONE);\r\nvsk->peer_shutdown = SHUTDOWN_MASK;\r\nif (vsock_stream_has_data(vsk) <= 0) {\r\nif (sk->sk_state == SS_CONNECTING) {\r\nsk->sk_state = SS_UNCONNECTED;\r\nsk->sk_err = ECONNRESET;\r\nsk->sk_error_report(sk);\r\nreturn;\r\n}\r\nsk->sk_state = SS_UNCONNECTED;\r\n}\r\nsk->sk_state_change(sk);\r\n}\r\n}\r\nstatic void vmci_transport_peer_detach_cb(u32 sub_id,\r\nconst struct vmci_event_data *e_data,\r\nvoid *client_data)\r\n{\r\nstruct sock *sk = client_data;\r\nconst struct vmci_event_payload_qp *e_payload;\r\nstruct vsock_sock *vsk;\r\ne_payload = vmci_event_data_const_payload(e_data);\r\nvsk = vsock_sk(sk);\r\nif (vmci_handle_is_invalid(e_payload->handle))\r\nreturn;\r\nlocal_bh_disable();\r\nbh_lock_sock(sk);\r\nif (vmci_handle_is_equal(vmci_trans(vsk)->qp_handle,\r\ne_payload->handle))\r\nvmci_transport_handle_detach(sk);\r\nbh_unlock_sock(sk);\r\nlocal_bh_enable();\r\n}\r\nstatic void vmci_transport_qp_resumed_cb(u32 sub_id,\r\nconst struct vmci_event_data *e_data,\r\nvoid *client_data)\r\n{\r\nvsock_for_each_connected_socket(vmci_transport_handle_detach);\r\n}\r\nstatic void vmci_transport_recv_pkt_work(struct work_struct *work)\r\n{\r\nstruct vmci_transport_recv_pkt_info *recv_pkt_info;\r\nstruct vmci_transport_packet *pkt;\r\nstruct sock *sk;\r\nrecv_pkt_info =\r\ncontainer_of(work, struct vmci_transport_recv_pkt_info, work);\r\nsk = recv_pkt_info->sk;\r\npkt = &recv_pkt_info->pkt;\r\nlock_sock(sk);\r\nvsock_sk(sk)->local_addr.svm_cid = pkt->dg.dst.context;\r\nswitch (sk->sk_state) {\r\ncase SS_LISTEN:\r\nvmci_transport_recv_listen(sk, pkt);\r\nbreak;\r\ncase SS_CONNECTING:\r\nvmci_transport_recv_connecting_client(sk, pkt);\r\nbreak;\r\ncase SS_CONNECTED:\r\nvmci_transport_recv_connected(sk, pkt);\r\nbreak;\r\ndefault:\r\nvmci_transport_send_reset(sk, pkt);\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nkfree(recv_pkt_info);\r\nsock_put(sk);\r\n}\r\nstatic int vmci_transport_recv_listen(struct sock *sk,\r\nstruct vmci_transport_packet *pkt)\r\n{\r\nstruct sock *pending;\r\nstruct vsock_sock *vpending;\r\nint err;\r\nu64 qp_size;\r\nbool old_request = false;\r\nbool old_pkt_proto = false;\r\nerr = 0;\r\npending = vmci_transport_get_pending(sk, pkt);\r\nif (pending) {\r\nlock_sock(pending);\r\nvsock_sk(pending)->local_addr.svm_cid = pkt->dg.dst.context;\r\nswitch (pending->sk_state) {\r\ncase SS_CONNECTING:\r\nerr = vmci_transport_recv_connecting_server(sk,\r\npending,\r\npkt);\r\nbreak;\r\ndefault:\r\nvmci_transport_send_reset(pending, pkt);\r\nerr = -EINVAL;\r\n}\r\nif (err < 0)\r\nvsock_remove_pending(sk, pending);\r\nrelease_sock(pending);\r\nvmci_transport_release_pending(pending);\r\nreturn err;\r\n}\r\nif (!(pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST ||\r\npkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST2)) {\r\nvmci_transport_reply_reset(pkt);\r\nreturn -EINVAL;\r\n}\r\nif (pkt->u.size == 0) {\r\nvmci_transport_reply_reset(pkt);\r\nreturn -EINVAL;\r\n}\r\nif (sk->sk_ack_backlog >= sk->sk_max_ack_backlog) {\r\nvmci_transport_reply_reset(pkt);\r\nreturn -ECONNREFUSED;\r\n}\r\npending = __vsock_create(sock_net(sk), NULL, sk, GFP_KERNEL,\r\nsk->sk_type);\r\nif (!pending) {\r\nvmci_transport_send_reset(sk, pkt);\r\nreturn -ENOMEM;\r\n}\r\nvpending = vsock_sk(pending);\r\nvsock_addr_init(&vpending->local_addr, pkt->dg.dst.context,\r\npkt->dst_port);\r\nvsock_addr_init(&vpending->remote_addr, pkt->dg.src.context,\r\npkt->src_port);\r\nif (pkt->u.size >= vmci_trans(vpending)->queue_pair_min_size &&\r\npkt->u.size <= vmci_trans(vpending)->queue_pair_max_size) {\r\nqp_size = pkt->u.size;\r\n} else {\r\nqp_size = vmci_trans(vpending)->queue_pair_size;\r\n}\r\nif (vmci_transport_old_proto_override(&old_pkt_proto)) {\r\nold_request = old_pkt_proto;\r\n} else {\r\nif (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST)\r\nold_request = true;\r\nelse if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST2)\r\nold_request = false;\r\n}\r\nif (old_request) {\r\nu16 version = VSOCK_PROTO_INVALID;\r\nif (vmci_transport_proto_to_notify_struct(\r\npending, &version, true))\r\nerr = vmci_transport_send_negotiate(pending, qp_size);\r\nelse\r\nerr = -EINVAL;\r\n} else {\r\nint proto_int = pkt->proto;\r\nint pos;\r\nu16 active_proto_version = 0;\r\nproto_int &= vmci_transport_new_proto_supported_versions();\r\npos = fls(proto_int);\r\nif (pos) {\r\nactive_proto_version = (1 << (pos - 1));\r\nif (vmci_transport_proto_to_notify_struct(\r\npending, &active_proto_version, false))\r\nerr = vmci_transport_send_negotiate2(pending,\r\nqp_size,\r\nactive_proto_version);\r\nelse\r\nerr = -EINVAL;\r\n} else {\r\nerr = -EINVAL;\r\n}\r\n}\r\nif (err < 0) {\r\nvmci_transport_send_reset(sk, pkt);\r\nsock_put(pending);\r\nerr = vmci_transport_error_to_vsock_error(err);\r\ngoto out;\r\n}\r\nvsock_add_pending(sk, pending);\r\nsk->sk_ack_backlog++;\r\npending->sk_state = SS_CONNECTING;\r\nvmci_trans(vpending)->produce_size =\r\nvmci_trans(vpending)->consume_size = qp_size;\r\nvmci_trans(vpending)->queue_pair_size = qp_size;\r\nvmci_trans(vpending)->notify_ops->process_request(pending);\r\nvpending->listener = sk;\r\nsock_hold(sk);\r\nsock_hold(pending);\r\nINIT_DELAYED_WORK(&vpending->dwork, vsock_pending_work);\r\nschedule_delayed_work(&vpending->dwork, HZ);\r\nout:\r\nreturn err;\r\n}\r\nstatic int\r\nvmci_transport_recv_connecting_server(struct sock *listener,\r\nstruct sock *pending,\r\nstruct vmci_transport_packet *pkt)\r\n{\r\nstruct vsock_sock *vpending;\r\nstruct vmci_handle handle;\r\nstruct vmci_qp *qpair;\r\nbool is_local;\r\nu32 flags;\r\nu32 detach_sub_id;\r\nint err;\r\nint skerr;\r\nvpending = vsock_sk(pending);\r\ndetach_sub_id = VMCI_INVALID_ID;\r\nswitch (pkt->type) {\r\ncase VMCI_TRANSPORT_PACKET_TYPE_OFFER:\r\nif (vmci_handle_is_invalid(pkt->u.handle)) {\r\nvmci_transport_send_reset(pending, pkt);\r\nskerr = EPROTO;\r\nerr = -EINVAL;\r\ngoto destroy;\r\n}\r\nbreak;\r\ndefault:\r\nvmci_transport_send_reset(pending, pkt);\r\nskerr = EPROTO;\r\nerr = pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST ? 0 : -EINVAL;\r\ngoto destroy;\r\n}\r\nerr = vmci_event_subscribe(VMCI_EVENT_QP_PEER_DETACH,\r\nvmci_transport_peer_detach_cb,\r\npending, &detach_sub_id);\r\nif (err < VMCI_SUCCESS) {\r\nvmci_transport_send_reset(pending, pkt);\r\nerr = vmci_transport_error_to_vsock_error(err);\r\nskerr = -err;\r\ngoto destroy;\r\n}\r\nvmci_trans(vpending)->detach_sub_id = detach_sub_id;\r\nhandle = pkt->u.handle;\r\nis_local =\r\nvpending->remote_addr.svm_cid == vpending->local_addr.svm_cid;\r\nflags = VMCI_QPFLAG_ATTACH_ONLY;\r\nflags |= is_local ? VMCI_QPFLAG_LOCAL : 0;\r\nerr = vmci_transport_queue_pair_alloc(\r\n&qpair,\r\n&handle,\r\nvmci_trans(vpending)->produce_size,\r\nvmci_trans(vpending)->consume_size,\r\npkt->dg.src.context,\r\nflags,\r\nvmci_transport_is_trusted(\r\nvpending,\r\nvpending->remote_addr.svm_cid));\r\nif (err < 0) {\r\nvmci_transport_send_reset(pending, pkt);\r\nskerr = -err;\r\ngoto destroy;\r\n}\r\nvmci_trans(vpending)->qp_handle = handle;\r\nvmci_trans(vpending)->qpair = qpair;\r\npending->sk_state = SS_CONNECTED;\r\nvsock_insert_connected(vpending);\r\nerr = vmci_transport_send_attach(pending, handle);\r\nif (err < 0) {\r\nvsock_remove_connected(vpending);\r\npr_err("Could not send attach\n");\r\nvmci_transport_send_reset(pending, pkt);\r\nerr = vmci_transport_error_to_vsock_error(err);\r\nskerr = -err;\r\ngoto destroy;\r\n}\r\nvsock_remove_pending(listener, pending);\r\nvsock_enqueue_accept(listener, pending);\r\nlistener->sk_state_change(listener);\r\nreturn 0;\r\ndestroy:\r\npending->sk_err = skerr;\r\npending->sk_state = SS_UNCONNECTED;\r\nsock_put(pending);\r\nreturn err;\r\n}\r\nstatic int\r\nvmci_transport_recv_connecting_client(struct sock *sk,\r\nstruct vmci_transport_packet *pkt)\r\n{\r\nstruct vsock_sock *vsk;\r\nint err;\r\nint skerr;\r\nvsk = vsock_sk(sk);\r\nswitch (pkt->type) {\r\ncase VMCI_TRANSPORT_PACKET_TYPE_ATTACH:\r\nif (vmci_handle_is_invalid(pkt->u.handle) ||\r\n!vmci_handle_is_equal(pkt->u.handle,\r\nvmci_trans(vsk)->qp_handle)) {\r\nskerr = EPROTO;\r\nerr = -EINVAL;\r\ngoto destroy;\r\n}\r\nsk->sk_state = SS_CONNECTED;\r\nsk->sk_socket->state = SS_CONNECTED;\r\nvsock_insert_connected(vsk);\r\nsk->sk_state_change(sk);\r\nbreak;\r\ncase VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE:\r\ncase VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2:\r\nif (pkt->u.size == 0\r\n|| pkt->dg.src.context != vsk->remote_addr.svm_cid\r\n|| pkt->src_port != vsk->remote_addr.svm_port\r\n|| !vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle)\r\n|| vmci_trans(vsk)->qpair\r\n|| vmci_trans(vsk)->produce_size != 0\r\n|| vmci_trans(vsk)->consume_size != 0\r\n|| vmci_trans(vsk)->attach_sub_id != VMCI_INVALID_ID\r\n|| vmci_trans(vsk)->detach_sub_id != VMCI_INVALID_ID) {\r\nskerr = EPROTO;\r\nerr = -EINVAL;\r\ngoto destroy;\r\n}\r\nerr = vmci_transport_recv_connecting_client_negotiate(sk, pkt);\r\nif (err) {\r\nskerr = -err;\r\ngoto destroy;\r\n}\r\nbreak;\r\ncase VMCI_TRANSPORT_PACKET_TYPE_INVALID:\r\nerr = vmci_transport_recv_connecting_client_invalid(sk, pkt);\r\nif (err) {\r\nskerr = -err;\r\ngoto destroy;\r\n}\r\nbreak;\r\ncase VMCI_TRANSPORT_PACKET_TYPE_RST:\r\nif (vsk->ignore_connecting_rst) {\r\nvsk->ignore_connecting_rst = false;\r\n} else {\r\nskerr = ECONNRESET;\r\nerr = 0;\r\ngoto destroy;\r\n}\r\nbreak;\r\ndefault:\r\nskerr = EPROTO;\r\nerr = -EINVAL;\r\ngoto destroy;\r\n}\r\nreturn 0;\r\ndestroy:\r\nvmci_transport_send_reset(sk, pkt);\r\nsk->sk_state = SS_UNCONNECTED;\r\nsk->sk_err = skerr;\r\nsk->sk_error_report(sk);\r\nreturn err;\r\n}\r\nstatic int vmci_transport_recv_connecting_client_negotiate(\r\nstruct sock *sk,\r\nstruct vmci_transport_packet *pkt)\r\n{\r\nint err;\r\nstruct vsock_sock *vsk;\r\nstruct vmci_handle handle;\r\nstruct vmci_qp *qpair;\r\nu32 attach_sub_id;\r\nu32 detach_sub_id;\r\nbool is_local;\r\nu32 flags;\r\nbool old_proto = true;\r\nbool old_pkt_proto;\r\nu16 version;\r\nvsk = vsock_sk(sk);\r\nhandle = VMCI_INVALID_HANDLE;\r\nattach_sub_id = VMCI_INVALID_ID;\r\ndetach_sub_id = VMCI_INVALID_ID;\r\nvsk->sent_request = false;\r\nvsk->ignore_connecting_rst = false;\r\nif (pkt->u.size < vmci_trans(vsk)->queue_pair_min_size ||\r\npkt->u.size > vmci_trans(vsk)->queue_pair_max_size) {\r\nerr = -EINVAL;\r\ngoto destroy;\r\n}\r\nif (vsk->local_addr.svm_cid == VMADDR_CID_ANY)\r\nvsk->local_addr.svm_cid = pkt->dg.dst.context;\r\nif (vmci_transport_old_proto_override(&old_pkt_proto)) {\r\nold_proto = old_pkt_proto;\r\n} else {\r\nif (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE)\r\nold_proto = true;\r\nelse if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2)\r\nold_proto = false;\r\n}\r\nif (old_proto)\r\nversion = VSOCK_PROTO_INVALID;\r\nelse\r\nversion = pkt->proto;\r\nif (!vmci_transport_proto_to_notify_struct(sk, &version, old_proto)) {\r\nerr = -EINVAL;\r\ngoto destroy;\r\n}\r\nerr = vmci_event_subscribe(VMCI_EVENT_QP_PEER_ATTACH,\r\nvmci_transport_peer_attach_cb,\r\nsk, &attach_sub_id);\r\nif (err < VMCI_SUCCESS) {\r\nerr = vmci_transport_error_to_vsock_error(err);\r\ngoto destroy;\r\n}\r\nerr = vmci_event_subscribe(VMCI_EVENT_QP_PEER_DETACH,\r\nvmci_transport_peer_detach_cb,\r\nsk, &detach_sub_id);\r\nif (err < VMCI_SUCCESS) {\r\nerr = vmci_transport_error_to_vsock_error(err);\r\ngoto destroy;\r\n}\r\nhandle = VMCI_INVALID_HANDLE;\r\nis_local = vsk->remote_addr.svm_cid == vsk->local_addr.svm_cid;\r\nflags = is_local ? VMCI_QPFLAG_LOCAL : 0;\r\nerr = vmci_transport_queue_pair_alloc(&qpair,\r\n&handle,\r\npkt->u.size,\r\npkt->u.size,\r\nvsk->remote_addr.svm_cid,\r\nflags,\r\nvmci_transport_is_trusted(\r\nvsk,\r\nvsk->\r\nremote_addr.svm_cid));\r\nif (err < 0)\r\ngoto destroy;\r\nerr = vmci_transport_send_qp_offer(sk, handle);\r\nif (err < 0) {\r\nerr = vmci_transport_error_to_vsock_error(err);\r\ngoto destroy;\r\n}\r\nvmci_trans(vsk)->qp_handle = handle;\r\nvmci_trans(vsk)->qpair = qpair;\r\nvmci_trans(vsk)->produce_size = vmci_trans(vsk)->consume_size =\r\npkt->u.size;\r\nvmci_trans(vsk)->attach_sub_id = attach_sub_id;\r\nvmci_trans(vsk)->detach_sub_id = detach_sub_id;\r\nvmci_trans(vsk)->notify_ops->process_negotiate(sk);\r\nreturn 0;\r\ndestroy:\r\nif (attach_sub_id != VMCI_INVALID_ID)\r\nvmci_event_unsubscribe(attach_sub_id);\r\nif (detach_sub_id != VMCI_INVALID_ID)\r\nvmci_event_unsubscribe(detach_sub_id);\r\nif (!vmci_handle_is_invalid(handle))\r\nvmci_qpair_detach(&qpair);\r\nreturn err;\r\n}\r\nstatic int\r\nvmci_transport_recv_connecting_client_invalid(struct sock *sk,\r\nstruct vmci_transport_packet *pkt)\r\n{\r\nint err = 0;\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\nif (vsk->sent_request) {\r\nvsk->sent_request = false;\r\nvsk->ignore_connecting_rst = true;\r\nerr = vmci_transport_send_conn_request(\r\nsk, vmci_trans(vsk)->queue_pair_size);\r\nif (err < 0)\r\nerr = vmci_transport_error_to_vsock_error(err);\r\nelse\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int vmci_transport_recv_connected(struct sock *sk,\r\nstruct vmci_transport_packet *pkt)\r\n{\r\nstruct vsock_sock *vsk;\r\nbool pkt_processed = false;\r\nswitch (pkt->type) {\r\ncase VMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN:\r\nif (pkt->u.mode) {\r\nvsk = vsock_sk(sk);\r\nvsk->peer_shutdown |= pkt->u.mode;\r\nsk->sk_state_change(sk);\r\n}\r\nbreak;\r\ncase VMCI_TRANSPORT_PACKET_TYPE_RST:\r\nvsk = vsock_sk(sk);\r\nsock_set_flag(sk, SOCK_DONE);\r\nvsk->peer_shutdown = SHUTDOWN_MASK;\r\nif (vsock_stream_has_data(vsk) <= 0)\r\nsk->sk_state = SS_DISCONNECTING;\r\nsk->sk_state_change(sk);\r\nbreak;\r\ndefault:\r\nvsk = vsock_sk(sk);\r\nvmci_trans(vsk)->notify_ops->handle_notify_pkt(\r\nsk, pkt, false, NULL, NULL,\r\n&pkt_processed);\r\nif (!pkt_processed)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmci_transport_socket_init(struct vsock_sock *vsk,\r\nstruct vsock_sock *psk)\r\n{\r\nvsk->trans = kmalloc(sizeof(struct vmci_transport), GFP_KERNEL);\r\nif (!vsk->trans)\r\nreturn -ENOMEM;\r\nvmci_trans(vsk)->dg_handle = VMCI_INVALID_HANDLE;\r\nvmci_trans(vsk)->qp_handle = VMCI_INVALID_HANDLE;\r\nvmci_trans(vsk)->qpair = NULL;\r\nvmci_trans(vsk)->produce_size = vmci_trans(vsk)->consume_size = 0;\r\nvmci_trans(vsk)->attach_sub_id = vmci_trans(vsk)->detach_sub_id =\r\nVMCI_INVALID_ID;\r\nvmci_trans(vsk)->notify_ops = NULL;\r\nif (psk) {\r\nvmci_trans(vsk)->queue_pair_size =\r\nvmci_trans(psk)->queue_pair_size;\r\nvmci_trans(vsk)->queue_pair_min_size =\r\nvmci_trans(psk)->queue_pair_min_size;\r\nvmci_trans(vsk)->queue_pair_max_size =\r\nvmci_trans(psk)->queue_pair_max_size;\r\n} else {\r\nvmci_trans(vsk)->queue_pair_size =\r\nVMCI_TRANSPORT_DEFAULT_QP_SIZE;\r\nvmci_trans(vsk)->queue_pair_min_size =\r\nVMCI_TRANSPORT_DEFAULT_QP_SIZE_MIN;\r\nvmci_trans(vsk)->queue_pair_max_size =\r\nVMCI_TRANSPORT_DEFAULT_QP_SIZE_MAX;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vmci_transport_destruct(struct vsock_sock *vsk)\r\n{\r\nif (vmci_trans(vsk)->attach_sub_id != VMCI_INVALID_ID) {\r\nvmci_event_unsubscribe(vmci_trans(vsk)->attach_sub_id);\r\nvmci_trans(vsk)->attach_sub_id = VMCI_INVALID_ID;\r\n}\r\nif (vmci_trans(vsk)->detach_sub_id != VMCI_INVALID_ID) {\r\nvmci_event_unsubscribe(vmci_trans(vsk)->detach_sub_id);\r\nvmci_trans(vsk)->detach_sub_id = VMCI_INVALID_ID;\r\n}\r\nif (!vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle)) {\r\nvmci_qpair_detach(&vmci_trans(vsk)->qpair);\r\nvmci_trans(vsk)->qp_handle = VMCI_INVALID_HANDLE;\r\nvmci_trans(vsk)->produce_size = 0;\r\nvmci_trans(vsk)->consume_size = 0;\r\n}\r\nif (vmci_trans(vsk)->notify_ops)\r\nvmci_trans(vsk)->notify_ops->socket_destruct(vsk);\r\nkfree(vsk->trans);\r\nvsk->trans = NULL;\r\n}\r\nstatic void vmci_transport_release(struct vsock_sock *vsk)\r\n{\r\nif (!vmci_handle_is_invalid(vmci_trans(vsk)->dg_handle)) {\r\nvmci_datagram_destroy_handle(vmci_trans(vsk)->dg_handle);\r\nvmci_trans(vsk)->dg_handle = VMCI_INVALID_HANDLE;\r\n}\r\n}\r\nstatic int vmci_transport_dgram_bind(struct vsock_sock *vsk,\r\nstruct sockaddr_vm *addr)\r\n{\r\nu32 port;\r\nu32 flags;\r\nint err;\r\nport = addr->svm_port == VMADDR_PORT_ANY ?\r\nVMCI_INVALID_ID : addr->svm_port;\r\nif (port <= LAST_RESERVED_PORT && !capable(CAP_NET_BIND_SERVICE))\r\nreturn -EACCES;\r\nflags = addr->svm_cid == VMADDR_CID_ANY ?\r\nVMCI_FLAG_ANYCID_DG_HND : 0;\r\nerr = vmci_transport_datagram_create_hnd(port, flags,\r\nvmci_transport_recv_dgram_cb,\r\n&vsk->sk,\r\n&vmci_trans(vsk)->dg_handle);\r\nif (err < VMCI_SUCCESS)\r\nreturn vmci_transport_error_to_vsock_error(err);\r\nvsock_addr_init(&vsk->local_addr, addr->svm_cid,\r\nvmci_trans(vsk)->dg_handle.resource);\r\nreturn 0;\r\n}\r\nstatic int vmci_transport_dgram_enqueue(\r\nstruct vsock_sock *vsk,\r\nstruct sockaddr_vm *remote_addr,\r\nstruct iovec *iov,\r\nsize_t len)\r\n{\r\nint err;\r\nstruct vmci_datagram *dg;\r\nif (len > VMCI_MAX_DG_PAYLOAD_SIZE)\r\nreturn -EMSGSIZE;\r\nif (!vmci_transport_allow_dgram(vsk, remote_addr->svm_cid))\r\nreturn -EPERM;\r\ndg = kmalloc(len + sizeof(*dg), GFP_KERNEL);\r\nif (!dg)\r\nreturn -ENOMEM;\r\nmemcpy_fromiovec(VMCI_DG_PAYLOAD(dg), iov, len);\r\ndg->dst = vmci_make_handle(remote_addr->svm_cid,\r\nremote_addr->svm_port);\r\ndg->src = vmci_make_handle(vsk->local_addr.svm_cid,\r\nvsk->local_addr.svm_port);\r\ndg->payload_size = len;\r\nerr = vmci_datagram_send(dg);\r\nkfree(dg);\r\nif (err < 0)\r\nreturn vmci_transport_error_to_vsock_error(err);\r\nreturn err - sizeof(*dg);\r\n}\r\nstatic int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\r\nstruct vsock_sock *vsk,\r\nstruct msghdr *msg, size_t len,\r\nint flags)\r\n{\r\nint err;\r\nint noblock;\r\nstruct vmci_datagram *dg;\r\nsize_t payload_len;\r\nstruct sk_buff *skb;\r\nnoblock = flags & MSG_DONTWAIT;\r\nif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\r\nreturn -EOPNOTSUPP;\r\nerr = 0;\r\nskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\r\nif (err)\r\nreturn err;\r\nif (!skb)\r\nreturn -EAGAIN;\r\ndg = (struct vmci_datagram *)skb->data;\r\nif (!dg)\r\ngoto out;\r\npayload_len = dg->payload_size;\r\nif (payload_len != skb->len - sizeof(*dg)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (payload_len > len) {\r\npayload_len = len;\r\nmsg->msg_flags |= MSG_TRUNC;\r\n}\r\nerr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\r\npayload_len);\r\nif (err)\r\ngoto out;\r\nif (msg->msg_name) {\r\nDECLARE_SOCKADDR(struct sockaddr_vm *, vm_addr, msg->msg_name);\r\nvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\r\nmsg->msg_namelen = sizeof(*vm_addr);\r\n}\r\nerr = payload_len;\r\nout:\r\nskb_free_datagram(&vsk->sk, skb);\r\nreturn err;\r\n}\r\nstatic bool vmci_transport_dgram_allow(u32 cid, u32 port)\r\n{\r\nif (cid == VMADDR_CID_HYPERVISOR) {\r\nreturn port == VMCI_UNITY_PBRPC_REGISTER;\r\n}\r\nreturn true;\r\n}\r\nstatic int vmci_transport_connect(struct vsock_sock *vsk)\r\n{\r\nint err;\r\nbool old_pkt_proto = false;\r\nstruct sock *sk = &vsk->sk;\r\nif (vmci_transport_old_proto_override(&old_pkt_proto) &&\r\nold_pkt_proto) {\r\nerr = vmci_transport_send_conn_request(\r\nsk, vmci_trans(vsk)->queue_pair_size);\r\nif (err < 0) {\r\nsk->sk_state = SS_UNCONNECTED;\r\nreturn err;\r\n}\r\n} else {\r\nint supported_proto_versions =\r\nvmci_transport_new_proto_supported_versions();\r\nerr = vmci_transport_send_conn_request2(\r\nsk, vmci_trans(vsk)->queue_pair_size,\r\nsupported_proto_versions);\r\nif (err < 0) {\r\nsk->sk_state = SS_UNCONNECTED;\r\nreturn err;\r\n}\r\nvsk->sent_request = true;\r\n}\r\nreturn err;\r\n}\r\nstatic ssize_t vmci_transport_stream_dequeue(\r\nstruct vsock_sock *vsk,\r\nstruct iovec *iov,\r\nsize_t len,\r\nint flags)\r\n{\r\nif (flags & MSG_PEEK)\r\nreturn vmci_qpair_peekv(vmci_trans(vsk)->qpair, iov, len, 0);\r\nelse\r\nreturn vmci_qpair_dequev(vmci_trans(vsk)->qpair, iov, len, 0);\r\n}\r\nstatic ssize_t vmci_transport_stream_enqueue(\r\nstruct vsock_sock *vsk,\r\nstruct iovec *iov,\r\nsize_t len)\r\n{\r\nreturn vmci_qpair_enquev(vmci_trans(vsk)->qpair, iov, len, 0);\r\n}\r\nstatic s64 vmci_transport_stream_has_data(struct vsock_sock *vsk)\r\n{\r\nreturn vmci_qpair_consume_buf_ready(vmci_trans(vsk)->qpair);\r\n}\r\nstatic s64 vmci_transport_stream_has_space(struct vsock_sock *vsk)\r\n{\r\nreturn vmci_qpair_produce_free_space(vmci_trans(vsk)->qpair);\r\n}\r\nstatic u64 vmci_transport_stream_rcvhiwat(struct vsock_sock *vsk)\r\n{\r\nreturn vmci_trans(vsk)->consume_size;\r\n}\r\nstatic bool vmci_transport_stream_is_active(struct vsock_sock *vsk)\r\n{\r\nreturn !vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle);\r\n}\r\nstatic u64 vmci_transport_get_buffer_size(struct vsock_sock *vsk)\r\n{\r\nreturn vmci_trans(vsk)->queue_pair_size;\r\n}\r\nstatic u64 vmci_transport_get_min_buffer_size(struct vsock_sock *vsk)\r\n{\r\nreturn vmci_trans(vsk)->queue_pair_min_size;\r\n}\r\nstatic u64 vmci_transport_get_max_buffer_size(struct vsock_sock *vsk)\r\n{\r\nreturn vmci_trans(vsk)->queue_pair_max_size;\r\n}\r\nstatic void vmci_transport_set_buffer_size(struct vsock_sock *vsk, u64 val)\r\n{\r\nif (val < vmci_trans(vsk)->queue_pair_min_size)\r\nvmci_trans(vsk)->queue_pair_min_size = val;\r\nif (val > vmci_trans(vsk)->queue_pair_max_size)\r\nvmci_trans(vsk)->queue_pair_max_size = val;\r\nvmci_trans(vsk)->queue_pair_size = val;\r\n}\r\nstatic void vmci_transport_set_min_buffer_size(struct vsock_sock *vsk,\r\nu64 val)\r\n{\r\nif (val > vmci_trans(vsk)->queue_pair_size)\r\nvmci_trans(vsk)->queue_pair_size = val;\r\nvmci_trans(vsk)->queue_pair_min_size = val;\r\n}\r\nstatic void vmci_transport_set_max_buffer_size(struct vsock_sock *vsk,\r\nu64 val)\r\n{\r\nif (val < vmci_trans(vsk)->queue_pair_size)\r\nvmci_trans(vsk)->queue_pair_size = val;\r\nvmci_trans(vsk)->queue_pair_max_size = val;\r\n}\r\nstatic int vmci_transport_notify_poll_in(\r\nstruct vsock_sock *vsk,\r\nsize_t target,\r\nbool *data_ready_now)\r\n{\r\nreturn vmci_trans(vsk)->notify_ops->poll_in(\r\n&vsk->sk, target, data_ready_now);\r\n}\r\nstatic int vmci_transport_notify_poll_out(\r\nstruct vsock_sock *vsk,\r\nsize_t target,\r\nbool *space_available_now)\r\n{\r\nreturn vmci_trans(vsk)->notify_ops->poll_out(\r\n&vsk->sk, target, space_available_now);\r\n}\r\nstatic int vmci_transport_notify_recv_init(\r\nstruct vsock_sock *vsk,\r\nsize_t target,\r\nstruct vsock_transport_recv_notify_data *data)\r\n{\r\nreturn vmci_trans(vsk)->notify_ops->recv_init(\r\n&vsk->sk, target,\r\n(struct vmci_transport_recv_notify_data *)data);\r\n}\r\nstatic int vmci_transport_notify_recv_pre_block(\r\nstruct vsock_sock *vsk,\r\nsize_t target,\r\nstruct vsock_transport_recv_notify_data *data)\r\n{\r\nreturn vmci_trans(vsk)->notify_ops->recv_pre_block(\r\n&vsk->sk, target,\r\n(struct vmci_transport_recv_notify_data *)data);\r\n}\r\nstatic int vmci_transport_notify_recv_pre_dequeue(\r\nstruct vsock_sock *vsk,\r\nsize_t target,\r\nstruct vsock_transport_recv_notify_data *data)\r\n{\r\nreturn vmci_trans(vsk)->notify_ops->recv_pre_dequeue(\r\n&vsk->sk, target,\r\n(struct vmci_transport_recv_notify_data *)data);\r\n}\r\nstatic int vmci_transport_notify_recv_post_dequeue(\r\nstruct vsock_sock *vsk,\r\nsize_t target,\r\nssize_t copied,\r\nbool data_read,\r\nstruct vsock_transport_recv_notify_data *data)\r\n{\r\nreturn vmci_trans(vsk)->notify_ops->recv_post_dequeue(\r\n&vsk->sk, target, copied, data_read,\r\n(struct vmci_transport_recv_notify_data *)data);\r\n}\r\nstatic int vmci_transport_notify_send_init(\r\nstruct vsock_sock *vsk,\r\nstruct vsock_transport_send_notify_data *data)\r\n{\r\nreturn vmci_trans(vsk)->notify_ops->send_init(\r\n&vsk->sk,\r\n(struct vmci_transport_send_notify_data *)data);\r\n}\r\nstatic int vmci_transport_notify_send_pre_block(\r\nstruct vsock_sock *vsk,\r\nstruct vsock_transport_send_notify_data *data)\r\n{\r\nreturn vmci_trans(vsk)->notify_ops->send_pre_block(\r\n&vsk->sk,\r\n(struct vmci_transport_send_notify_data *)data);\r\n}\r\nstatic int vmci_transport_notify_send_pre_enqueue(\r\nstruct vsock_sock *vsk,\r\nstruct vsock_transport_send_notify_data *data)\r\n{\r\nreturn vmci_trans(vsk)->notify_ops->send_pre_enqueue(\r\n&vsk->sk,\r\n(struct vmci_transport_send_notify_data *)data);\r\n}\r\nstatic int vmci_transport_notify_send_post_enqueue(\r\nstruct vsock_sock *vsk,\r\nssize_t written,\r\nstruct vsock_transport_send_notify_data *data)\r\n{\r\nreturn vmci_trans(vsk)->notify_ops->send_post_enqueue(\r\n&vsk->sk, written,\r\n(struct vmci_transport_send_notify_data *)data);\r\n}\r\nstatic bool vmci_transport_old_proto_override(bool *old_pkt_proto)\r\n{\r\nif (PROTOCOL_OVERRIDE != -1) {\r\nif (PROTOCOL_OVERRIDE == 0)\r\n*old_pkt_proto = true;\r\nelse\r\n*old_pkt_proto = false;\r\npr_info("Proto override in use\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool vmci_transport_proto_to_notify_struct(struct sock *sk,\r\nu16 *proto,\r\nbool old_pkt_proto)\r\n{\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\nif (old_pkt_proto) {\r\nif (*proto != VSOCK_PROTO_INVALID) {\r\npr_err("Can't set both an old and new protocol\n");\r\nreturn false;\r\n}\r\nvmci_trans(vsk)->notify_ops = &vmci_transport_notify_pkt_ops;\r\ngoto exit;\r\n}\r\nswitch (*proto) {\r\ncase VSOCK_PROTO_PKT_ON_NOTIFY:\r\nvmci_trans(vsk)->notify_ops =\r\n&vmci_transport_notify_pkt_q_state_ops;\r\nbreak;\r\ndefault:\r\npr_err("Unknown notify protocol version\n");\r\nreturn false;\r\n}\r\nexit:\r\nvmci_trans(vsk)->notify_ops->socket_init(sk);\r\nreturn true;\r\n}\r\nstatic u16 vmci_transport_new_proto_supported_versions(void)\r\n{\r\nif (PROTOCOL_OVERRIDE != -1)\r\nreturn PROTOCOL_OVERRIDE;\r\nreturn VSOCK_PROTO_ALL_SUPPORTED;\r\n}\r\nstatic u32 vmci_transport_get_local_cid(void)\r\n{\r\nreturn vmci_get_context_id();\r\n}\r\nstatic int __init vmci_transport_init(void)\r\n{\r\nint err;\r\nerr = vmci_transport_datagram_create_hnd(VMCI_TRANSPORT_PACKET_RID,\r\nVMCI_FLAG_ANYCID_DG_HND,\r\nvmci_transport_recv_stream_cb,\r\nNULL,\r\n&vmci_transport_stream_handle);\r\nif (err < VMCI_SUCCESS) {\r\npr_err("Unable to create datagram handle. (%d)\n", err);\r\nreturn vmci_transport_error_to_vsock_error(err);\r\n}\r\nerr = vmci_event_subscribe(VMCI_EVENT_QP_RESUMED,\r\nvmci_transport_qp_resumed_cb,\r\nNULL, &vmci_transport_qp_resumed_sub_id);\r\nif (err < VMCI_SUCCESS) {\r\npr_err("Unable to subscribe to resumed event. (%d)\n", err);\r\nerr = vmci_transport_error_to_vsock_error(err);\r\nvmci_transport_qp_resumed_sub_id = VMCI_INVALID_ID;\r\ngoto err_destroy_stream_handle;\r\n}\r\nerr = vsock_core_init(&vmci_transport);\r\nif (err < 0)\r\ngoto err_unsubscribe;\r\nreturn 0;\r\nerr_unsubscribe:\r\nvmci_event_unsubscribe(vmci_transport_qp_resumed_sub_id);\r\nerr_destroy_stream_handle:\r\nvmci_datagram_destroy_handle(vmci_transport_stream_handle);\r\nreturn err;\r\n}\r\nstatic void __exit vmci_transport_exit(void)\r\n{\r\nif (!vmci_handle_is_invalid(vmci_transport_stream_handle)) {\r\nif (vmci_datagram_destroy_handle(\r\nvmci_transport_stream_handle) != VMCI_SUCCESS)\r\npr_err("Couldn't destroy datagram handle\n");\r\nvmci_transport_stream_handle = VMCI_INVALID_HANDLE;\r\n}\r\nif (vmci_transport_qp_resumed_sub_id != VMCI_INVALID_ID) {\r\nvmci_event_unsubscribe(vmci_transport_qp_resumed_sub_id);\r\nvmci_transport_qp_resumed_sub_id = VMCI_INVALID_ID;\r\n}\r\nvsock_core_exit();\r\n}
