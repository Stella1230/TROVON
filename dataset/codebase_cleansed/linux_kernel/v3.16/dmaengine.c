static struct dma_chan *dev_to_dma_chan(struct device *dev)\r\n{\r\nstruct dma_chan_dev *chan_dev;\r\nchan_dev = container_of(dev, typeof(*chan_dev), device);\r\nreturn chan_dev->chan;\r\n}\r\nstatic ssize_t memcpy_count_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dma_chan *chan;\r\nunsigned long count = 0;\r\nint i;\r\nint err;\r\nmutex_lock(&dma_list_mutex);\r\nchan = dev_to_dma_chan(dev);\r\nif (chan) {\r\nfor_each_possible_cpu(i)\r\ncount += per_cpu_ptr(chan->local, i)->memcpy_count;\r\nerr = sprintf(buf, "%lu\n", count);\r\n} else\r\nerr = -ENODEV;\r\nmutex_unlock(&dma_list_mutex);\r\nreturn err;\r\n}\r\nstatic ssize_t bytes_transferred_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dma_chan *chan;\r\nunsigned long count = 0;\r\nint i;\r\nint err;\r\nmutex_lock(&dma_list_mutex);\r\nchan = dev_to_dma_chan(dev);\r\nif (chan) {\r\nfor_each_possible_cpu(i)\r\ncount += per_cpu_ptr(chan->local, i)->bytes_transferred;\r\nerr = sprintf(buf, "%lu\n", count);\r\n} else\r\nerr = -ENODEV;\r\nmutex_unlock(&dma_list_mutex);\r\nreturn err;\r\n}\r\nstatic ssize_t in_use_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dma_chan *chan;\r\nint err;\r\nmutex_lock(&dma_list_mutex);\r\nchan = dev_to_dma_chan(dev);\r\nif (chan)\r\nerr = sprintf(buf, "%d\n", chan->client_count);\r\nelse\r\nerr = -ENODEV;\r\nmutex_unlock(&dma_list_mutex);\r\nreturn err;\r\n}\r\nstatic void chan_dev_release(struct device *dev)\r\n{\r\nstruct dma_chan_dev *chan_dev;\r\nchan_dev = container_of(dev, typeof(*chan_dev), device);\r\nif (atomic_dec_and_test(chan_dev->idr_ref)) {\r\nmutex_lock(&dma_list_mutex);\r\nidr_remove(&dma_idr, chan_dev->dev_id);\r\nmutex_unlock(&dma_list_mutex);\r\nkfree(chan_dev->idr_ref);\r\n}\r\nkfree(chan_dev);\r\n}\r\nstatic int\r\n__dma_device_satisfies_mask(struct dma_device *device,\r\nconst dma_cap_mask_t *want)\r\n{\r\ndma_cap_mask_t has;\r\nbitmap_and(has.bits, want->bits, device->cap_mask.bits,\r\nDMA_TX_TYPE_END);\r\nreturn bitmap_equal(want->bits, has.bits, DMA_TX_TYPE_END);\r\n}\r\nstatic struct module *dma_chan_to_owner(struct dma_chan *chan)\r\n{\r\nreturn chan->device->dev->driver->owner;\r\n}\r\nstatic void balance_ref_count(struct dma_chan *chan)\r\n{\r\nstruct module *owner = dma_chan_to_owner(chan);\r\nwhile (chan->client_count < dmaengine_ref_count) {\r\n__module_get(owner);\r\nchan->client_count++;\r\n}\r\n}\r\nstatic int dma_chan_get(struct dma_chan *chan)\r\n{\r\nint err = -ENODEV;\r\nstruct module *owner = dma_chan_to_owner(chan);\r\nif (chan->client_count) {\r\n__module_get(owner);\r\nerr = 0;\r\n} else if (try_module_get(owner))\r\nerr = 0;\r\nif (err == 0)\r\nchan->client_count++;\r\nif (chan->client_count == 1 && err == 0) {\r\nint desc_cnt = chan->device->device_alloc_chan_resources(chan);\r\nif (desc_cnt < 0) {\r\nerr = desc_cnt;\r\nchan->client_count = 0;\r\nmodule_put(owner);\r\n} else if (!dma_has_cap(DMA_PRIVATE, chan->device->cap_mask))\r\nbalance_ref_count(chan);\r\n}\r\nreturn err;\r\n}\r\nstatic void dma_chan_put(struct dma_chan *chan)\r\n{\r\nif (!chan->client_count)\r\nreturn;\r\nchan->client_count--;\r\nmodule_put(dma_chan_to_owner(chan));\r\nif (chan->client_count == 0)\r\nchan->device->device_free_chan_resources(chan);\r\n}\r\nenum dma_status dma_sync_wait(struct dma_chan *chan, dma_cookie_t cookie)\r\n{\r\nenum dma_status status;\r\nunsigned long dma_sync_wait_timeout = jiffies + msecs_to_jiffies(5000);\r\ndma_async_issue_pending(chan);\r\ndo {\r\nstatus = dma_async_is_tx_complete(chan, cookie, NULL, NULL);\r\nif (time_after_eq(jiffies, dma_sync_wait_timeout)) {\r\npr_err("%s: timeout!\n", __func__);\r\nreturn DMA_ERROR;\r\n}\r\nif (status != DMA_IN_PROGRESS)\r\nbreak;\r\ncpu_relax();\r\n} while (1);\r\nreturn status;\r\n}\r\nstatic int __init dma_channel_table_init(void)\r\n{\r\nenum dma_transaction_type cap;\r\nint err = 0;\r\nbitmap_fill(dma_cap_mask_all.bits, DMA_TX_TYPE_END);\r\nclear_bit(DMA_INTERRUPT, dma_cap_mask_all.bits);\r\nclear_bit(DMA_PRIVATE, dma_cap_mask_all.bits);\r\nclear_bit(DMA_SLAVE, dma_cap_mask_all.bits);\r\nfor_each_dma_cap_mask(cap, dma_cap_mask_all) {\r\nchannel_table[cap] = alloc_percpu(struct dma_chan_tbl_ent);\r\nif (!channel_table[cap]) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\n}\r\nif (err) {\r\npr_err("initialization failure\n");\r\nfor_each_dma_cap_mask(cap, dma_cap_mask_all)\r\nif (channel_table[cap])\r\nfree_percpu(channel_table[cap]);\r\n}\r\nreturn err;\r\n}\r\nstruct dma_chan *dma_find_channel(enum dma_transaction_type tx_type)\r\n{\r\nreturn this_cpu_read(channel_table[tx_type]->chan);\r\n}\r\nstruct dma_chan *net_dma_find_channel(void)\r\n{\r\nstruct dma_chan *chan = dma_find_channel(DMA_MEMCPY);\r\nif (chan && !is_dma_copy_aligned(chan->device, 1, 1, 1))\r\nreturn NULL;\r\nreturn chan;\r\n}\r\nvoid dma_issue_pending_all(void)\r\n{\r\nstruct dma_device *device;\r\nstruct dma_chan *chan;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(device, &dma_device_list, global_node) {\r\nif (dma_has_cap(DMA_PRIVATE, device->cap_mask))\r\ncontinue;\r\nlist_for_each_entry(chan, &device->channels, device_node)\r\nif (chan->client_count)\r\ndevice->device_issue_pending(chan);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic bool dma_chan_is_local(struct dma_chan *chan, int cpu)\r\n{\r\nint node = dev_to_node(chan->device->dev);\r\nreturn node == -1 || cpumask_test_cpu(cpu, cpumask_of_node(node));\r\n}\r\nstatic struct dma_chan *min_chan(enum dma_transaction_type cap, int cpu)\r\n{\r\nstruct dma_device *device;\r\nstruct dma_chan *chan;\r\nstruct dma_chan *min = NULL;\r\nstruct dma_chan *localmin = NULL;\r\nlist_for_each_entry(device, &dma_device_list, global_node) {\r\nif (!dma_has_cap(cap, device->cap_mask) ||\r\ndma_has_cap(DMA_PRIVATE, device->cap_mask))\r\ncontinue;\r\nlist_for_each_entry(chan, &device->channels, device_node) {\r\nif (!chan->client_count)\r\ncontinue;\r\nif (!min || chan->table_count < min->table_count)\r\nmin = chan;\r\nif (dma_chan_is_local(chan, cpu))\r\nif (!localmin ||\r\nchan->table_count < localmin->table_count)\r\nlocalmin = chan;\r\n}\r\n}\r\nchan = localmin ? localmin : min;\r\nif (chan)\r\nchan->table_count++;\r\nreturn chan;\r\n}\r\nstatic void dma_channel_rebalance(void)\r\n{\r\nstruct dma_chan *chan;\r\nstruct dma_device *device;\r\nint cpu;\r\nint cap;\r\nfor_each_dma_cap_mask(cap, dma_cap_mask_all)\r\nfor_each_possible_cpu(cpu)\r\nper_cpu_ptr(channel_table[cap], cpu)->chan = NULL;\r\nlist_for_each_entry(device, &dma_device_list, global_node) {\r\nif (dma_has_cap(DMA_PRIVATE, device->cap_mask))\r\ncontinue;\r\nlist_for_each_entry(chan, &device->channels, device_node)\r\nchan->table_count = 0;\r\n}\r\nif (!dmaengine_ref_count)\r\nreturn;\r\nfor_each_dma_cap_mask(cap, dma_cap_mask_all)\r\nfor_each_online_cpu(cpu) {\r\nchan = min_chan(cap, cpu);\r\nper_cpu_ptr(channel_table[cap], cpu)->chan = chan;\r\n}\r\n}\r\nstatic struct dma_chan *private_candidate(const dma_cap_mask_t *mask,\r\nstruct dma_device *dev,\r\ndma_filter_fn fn, void *fn_param)\r\n{\r\nstruct dma_chan *chan;\r\nif (!__dma_device_satisfies_mask(dev, mask)) {\r\npr_debug("%s: wrong capabilities\n", __func__);\r\nreturn NULL;\r\n}\r\nif (dev->chancnt > 1 && !dma_has_cap(DMA_PRIVATE, dev->cap_mask))\r\nlist_for_each_entry(chan, &dev->channels, device_node) {\r\nif (chan->client_count)\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(chan, &dev->channels, device_node) {\r\nif (chan->client_count) {\r\npr_debug("%s: %s busy\n",\r\n__func__, dma_chan_name(chan));\r\ncontinue;\r\n}\r\nif (fn && !fn(chan, fn_param)) {\r\npr_debug("%s: %s filter said false\n",\r\n__func__, dma_chan_name(chan));\r\ncontinue;\r\n}\r\nreturn chan;\r\n}\r\nreturn NULL;\r\n}\r\nstruct dma_chan *dma_get_slave_channel(struct dma_chan *chan)\r\n{\r\nint err = -EBUSY;\r\nmutex_lock(&dma_list_mutex);\r\nif (chan->client_count == 0) {\r\nerr = dma_chan_get(chan);\r\nif (err)\r\npr_debug("%s: failed to get %s: (%d)\n",\r\n__func__, dma_chan_name(chan), err);\r\n} else\r\nchan = NULL;\r\nmutex_unlock(&dma_list_mutex);\r\nreturn chan;\r\n}\r\nstruct dma_chan *dma_get_any_slave_channel(struct dma_device *device)\r\n{\r\ndma_cap_mask_t mask;\r\nstruct dma_chan *chan;\r\nint err;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nmutex_lock(&dma_list_mutex);\r\nchan = private_candidate(&mask, device, NULL, NULL);\r\nif (chan) {\r\nerr = dma_chan_get(chan);\r\nif (err) {\r\npr_debug("%s: failed to get %s: (%d)\n",\r\n__func__, dma_chan_name(chan), err);\r\nchan = NULL;\r\n}\r\n}\r\nmutex_unlock(&dma_list_mutex);\r\nreturn chan;\r\n}\r\nstruct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,\r\ndma_filter_fn fn, void *fn_param)\r\n{\r\nstruct dma_device *device, *_d;\r\nstruct dma_chan *chan = NULL;\r\nint err;\r\nmutex_lock(&dma_list_mutex);\r\nlist_for_each_entry_safe(device, _d, &dma_device_list, global_node) {\r\nchan = private_candidate(mask, device, fn, fn_param);\r\nif (chan) {\r\ndma_cap_set(DMA_PRIVATE, device->cap_mask);\r\ndevice->privatecnt++;\r\nerr = dma_chan_get(chan);\r\nif (err == -ENODEV) {\r\npr_debug("%s: %s module removed\n",\r\n__func__, dma_chan_name(chan));\r\nlist_del_rcu(&device->global_node);\r\n} else if (err)\r\npr_debug("%s: failed to get %s: (%d)\n",\r\n__func__, dma_chan_name(chan), err);\r\nelse\r\nbreak;\r\nif (--device->privatecnt == 0)\r\ndma_cap_clear(DMA_PRIVATE, device->cap_mask);\r\nchan = NULL;\r\n}\r\n}\r\nmutex_unlock(&dma_list_mutex);\r\npr_debug("%s: %s (%s)\n",\r\n__func__,\r\nchan ? "success" : "fail",\r\nchan ? dma_chan_name(chan) : NULL);\r\nreturn chan;\r\n}\r\nstruct dma_chan *dma_request_slave_channel_reason(struct device *dev,\r\nconst char *name)\r\n{\r\nif (dev->of_node)\r\nreturn of_dma_request_slave_channel(dev->of_node, name);\r\nif (ACPI_HANDLE(dev))\r\nreturn acpi_dma_request_slave_chan_by_name(dev, name);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstruct dma_chan *dma_request_slave_channel(struct device *dev,\r\nconst char *name)\r\n{\r\nstruct dma_chan *ch = dma_request_slave_channel_reason(dev, name);\r\nif (IS_ERR(ch))\r\nreturn NULL;\r\nreturn ch;\r\n}\r\nvoid dma_release_channel(struct dma_chan *chan)\r\n{\r\nmutex_lock(&dma_list_mutex);\r\nWARN_ONCE(chan->client_count != 1,\r\n"chan reference count %d != 1\n", chan->client_count);\r\ndma_chan_put(chan);\r\nif (--chan->device->privatecnt == 0)\r\ndma_cap_clear(DMA_PRIVATE, chan->device->cap_mask);\r\nmutex_unlock(&dma_list_mutex);\r\n}\r\nvoid dmaengine_get(void)\r\n{\r\nstruct dma_device *device, *_d;\r\nstruct dma_chan *chan;\r\nint err;\r\nmutex_lock(&dma_list_mutex);\r\ndmaengine_ref_count++;\r\nlist_for_each_entry_safe(device, _d, &dma_device_list, global_node) {\r\nif (dma_has_cap(DMA_PRIVATE, device->cap_mask))\r\ncontinue;\r\nlist_for_each_entry(chan, &device->channels, device_node) {\r\nerr = dma_chan_get(chan);\r\nif (err == -ENODEV) {\r\nlist_del_rcu(&device->global_node);\r\nbreak;\r\n} else if (err)\r\npr_debug("%s: failed to get %s: (%d)\n",\r\n__func__, dma_chan_name(chan), err);\r\n}\r\n}\r\nif (dmaengine_ref_count == 1)\r\ndma_channel_rebalance();\r\nmutex_unlock(&dma_list_mutex);\r\n}\r\nvoid dmaengine_put(void)\r\n{\r\nstruct dma_device *device;\r\nstruct dma_chan *chan;\r\nmutex_lock(&dma_list_mutex);\r\ndmaengine_ref_count--;\r\nBUG_ON(dmaengine_ref_count < 0);\r\nlist_for_each_entry(device, &dma_device_list, global_node) {\r\nif (dma_has_cap(DMA_PRIVATE, device->cap_mask))\r\ncontinue;\r\nlist_for_each_entry(chan, &device->channels, device_node)\r\ndma_chan_put(chan);\r\n}\r\nmutex_unlock(&dma_list_mutex);\r\n}\r\nstatic bool device_has_all_tx_types(struct dma_device *device)\r\n{\r\n#ifdef CONFIG_ASYNC_TX_DMA\r\nif (!dma_has_cap(DMA_INTERRUPT, device->cap_mask))\r\nreturn false;\r\n#endif\r\n#if defined(CONFIG_ASYNC_MEMCPY) || defined(CONFIG_ASYNC_MEMCPY_MODULE)\r\nif (!dma_has_cap(DMA_MEMCPY, device->cap_mask))\r\nreturn false;\r\n#endif\r\n#if defined(CONFIG_ASYNC_XOR) || defined(CONFIG_ASYNC_XOR_MODULE)\r\nif (!dma_has_cap(DMA_XOR, device->cap_mask))\r\nreturn false;\r\n#ifndef CONFIG_ASYNC_TX_DISABLE_XOR_VAL_DMA\r\nif (!dma_has_cap(DMA_XOR_VAL, device->cap_mask))\r\nreturn false;\r\n#endif\r\n#endif\r\n#if defined(CONFIG_ASYNC_PQ) || defined(CONFIG_ASYNC_PQ_MODULE)\r\nif (!dma_has_cap(DMA_PQ, device->cap_mask))\r\nreturn false;\r\n#ifndef CONFIG_ASYNC_TX_DISABLE_PQ_VAL_DMA\r\nif (!dma_has_cap(DMA_PQ_VAL, device->cap_mask))\r\nreturn false;\r\n#endif\r\n#endif\r\nreturn true;\r\n}\r\nstatic int get_dma_id(struct dma_device *device)\r\n{\r\nint rc;\r\nmutex_lock(&dma_list_mutex);\r\nrc = idr_alloc(&dma_idr, NULL, 0, 0, GFP_KERNEL);\r\nif (rc >= 0)\r\ndevice->dev_id = rc;\r\nmutex_unlock(&dma_list_mutex);\r\nreturn rc < 0 ? rc : 0;\r\n}\r\nint dma_async_device_register(struct dma_device *device)\r\n{\r\nint chancnt = 0, rc;\r\nstruct dma_chan* chan;\r\natomic_t *idr_ref;\r\nif (!device)\r\nreturn -ENODEV;\r\nBUG_ON(dma_has_cap(DMA_MEMCPY, device->cap_mask) &&\r\n!device->device_prep_dma_memcpy);\r\nBUG_ON(dma_has_cap(DMA_XOR, device->cap_mask) &&\r\n!device->device_prep_dma_xor);\r\nBUG_ON(dma_has_cap(DMA_XOR_VAL, device->cap_mask) &&\r\n!device->device_prep_dma_xor_val);\r\nBUG_ON(dma_has_cap(DMA_PQ, device->cap_mask) &&\r\n!device->device_prep_dma_pq);\r\nBUG_ON(dma_has_cap(DMA_PQ_VAL, device->cap_mask) &&\r\n!device->device_prep_dma_pq_val);\r\nBUG_ON(dma_has_cap(DMA_INTERRUPT, device->cap_mask) &&\r\n!device->device_prep_dma_interrupt);\r\nBUG_ON(dma_has_cap(DMA_SG, device->cap_mask) &&\r\n!device->device_prep_dma_sg);\r\nBUG_ON(dma_has_cap(DMA_CYCLIC, device->cap_mask) &&\r\n!device->device_prep_dma_cyclic);\r\nBUG_ON(dma_has_cap(DMA_SLAVE, device->cap_mask) &&\r\n!device->device_control);\r\nBUG_ON(dma_has_cap(DMA_INTERLEAVE, device->cap_mask) &&\r\n!device->device_prep_interleaved_dma);\r\nBUG_ON(!device->device_alloc_chan_resources);\r\nBUG_ON(!device->device_free_chan_resources);\r\nBUG_ON(!device->device_tx_status);\r\nBUG_ON(!device->device_issue_pending);\r\nBUG_ON(!device->dev);\r\nif (device_has_all_tx_types(device))\r\ndma_cap_set(DMA_ASYNC_TX, device->cap_mask);\r\nidr_ref = kmalloc(sizeof(*idr_ref), GFP_KERNEL);\r\nif (!idr_ref)\r\nreturn -ENOMEM;\r\nrc = get_dma_id(device);\r\nif (rc != 0) {\r\nkfree(idr_ref);\r\nreturn rc;\r\n}\r\natomic_set(idr_ref, 0);\r\nlist_for_each_entry(chan, &device->channels, device_node) {\r\nrc = -ENOMEM;\r\nchan->local = alloc_percpu(typeof(*chan->local));\r\nif (chan->local == NULL)\r\ngoto err_out;\r\nchan->dev = kzalloc(sizeof(*chan->dev), GFP_KERNEL);\r\nif (chan->dev == NULL) {\r\nfree_percpu(chan->local);\r\nchan->local = NULL;\r\ngoto err_out;\r\n}\r\nchan->chan_id = chancnt++;\r\nchan->dev->device.class = &dma_devclass;\r\nchan->dev->device.parent = device->dev;\r\nchan->dev->chan = chan;\r\nchan->dev->idr_ref = idr_ref;\r\nchan->dev->dev_id = device->dev_id;\r\natomic_inc(idr_ref);\r\ndev_set_name(&chan->dev->device, "dma%dchan%d",\r\ndevice->dev_id, chan->chan_id);\r\nrc = device_register(&chan->dev->device);\r\nif (rc) {\r\nfree_percpu(chan->local);\r\nchan->local = NULL;\r\nkfree(chan->dev);\r\natomic_dec(idr_ref);\r\ngoto err_out;\r\n}\r\nchan->client_count = 0;\r\n}\r\ndevice->chancnt = chancnt;\r\nmutex_lock(&dma_list_mutex);\r\nif (dmaengine_ref_count && !dma_has_cap(DMA_PRIVATE, device->cap_mask))\r\nlist_for_each_entry(chan, &device->channels, device_node) {\r\nif (dma_chan_get(chan) == -ENODEV) {\r\nrc = -ENODEV;\r\nmutex_unlock(&dma_list_mutex);\r\ngoto err_out;\r\n}\r\n}\r\nlist_add_tail_rcu(&device->global_node, &dma_device_list);\r\nif (dma_has_cap(DMA_PRIVATE, device->cap_mask))\r\ndevice->privatecnt++;\r\ndma_channel_rebalance();\r\nmutex_unlock(&dma_list_mutex);\r\nreturn 0;\r\nerr_out:\r\nif (atomic_read(idr_ref) == 0) {\r\nmutex_lock(&dma_list_mutex);\r\nidr_remove(&dma_idr, device->dev_id);\r\nmutex_unlock(&dma_list_mutex);\r\nkfree(idr_ref);\r\nreturn rc;\r\n}\r\nlist_for_each_entry(chan, &device->channels, device_node) {\r\nif (chan->local == NULL)\r\ncontinue;\r\nmutex_lock(&dma_list_mutex);\r\nchan->dev->chan = NULL;\r\nmutex_unlock(&dma_list_mutex);\r\ndevice_unregister(&chan->dev->device);\r\nfree_percpu(chan->local);\r\n}\r\nreturn rc;\r\n}\r\nvoid dma_async_device_unregister(struct dma_device *device)\r\n{\r\nstruct dma_chan *chan;\r\nmutex_lock(&dma_list_mutex);\r\nlist_del_rcu(&device->global_node);\r\ndma_channel_rebalance();\r\nmutex_unlock(&dma_list_mutex);\r\nlist_for_each_entry(chan, &device->channels, device_node) {\r\nWARN_ONCE(chan->client_count,\r\n"%s called while %d clients hold a reference\n",\r\n__func__, chan->client_count);\r\nmutex_lock(&dma_list_mutex);\r\nchan->dev->chan = NULL;\r\nmutex_unlock(&dma_list_mutex);\r\ndevice_unregister(&chan->dev->device);\r\nfree_percpu(chan->local);\r\n}\r\n}\r\nstatic struct dmaengine_unmap_pool *__get_unmap_pool(int nr)\r\n{\r\nint order = get_count_order(nr);\r\nswitch (order) {\r\ncase 0 ... 1:\r\nreturn &unmap_pool[0];\r\ncase 2 ... 4:\r\nreturn &unmap_pool[1];\r\ncase 5 ... 7:\r\nreturn &unmap_pool[2];\r\ncase 8:\r\nreturn &unmap_pool[3];\r\ndefault:\r\nBUG();\r\nreturn NULL;\r\n}\r\n}\r\nstatic void dmaengine_unmap(struct kref *kref)\r\n{\r\nstruct dmaengine_unmap_data *unmap = container_of(kref, typeof(*unmap), kref);\r\nstruct device *dev = unmap->dev;\r\nint cnt, i;\r\ncnt = unmap->to_cnt;\r\nfor (i = 0; i < cnt; i++)\r\ndma_unmap_page(dev, unmap->addr[i], unmap->len,\r\nDMA_TO_DEVICE);\r\ncnt += unmap->from_cnt;\r\nfor (; i < cnt; i++)\r\ndma_unmap_page(dev, unmap->addr[i], unmap->len,\r\nDMA_FROM_DEVICE);\r\ncnt += unmap->bidi_cnt;\r\nfor (; i < cnt; i++) {\r\nif (unmap->addr[i] == 0)\r\ncontinue;\r\ndma_unmap_page(dev, unmap->addr[i], unmap->len,\r\nDMA_BIDIRECTIONAL);\r\n}\r\ncnt = unmap->map_cnt;\r\nmempool_free(unmap, __get_unmap_pool(cnt)->pool);\r\n}\r\nvoid dmaengine_unmap_put(struct dmaengine_unmap_data *unmap)\r\n{\r\nif (unmap)\r\nkref_put(&unmap->kref, dmaengine_unmap);\r\n}\r\nstatic void dmaengine_destroy_unmap_pool(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(unmap_pool); i++) {\r\nstruct dmaengine_unmap_pool *p = &unmap_pool[i];\r\nif (p->pool)\r\nmempool_destroy(p->pool);\r\np->pool = NULL;\r\nif (p->cache)\r\nkmem_cache_destroy(p->cache);\r\np->cache = NULL;\r\n}\r\n}\r\nstatic int __init dmaengine_init_unmap_pool(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(unmap_pool); i++) {\r\nstruct dmaengine_unmap_pool *p = &unmap_pool[i];\r\nsize_t size;\r\nsize = sizeof(struct dmaengine_unmap_data) +\r\nsizeof(dma_addr_t) * p->size;\r\np->cache = kmem_cache_create(p->name, size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!p->cache)\r\nbreak;\r\np->pool = mempool_create_slab_pool(1, p->cache);\r\nif (!p->pool)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(unmap_pool))\r\nreturn 0;\r\ndmaengine_destroy_unmap_pool();\r\nreturn -ENOMEM;\r\n}\r\nstruct dmaengine_unmap_data *\r\ndmaengine_get_unmap_data(struct device *dev, int nr, gfp_t flags)\r\n{\r\nstruct dmaengine_unmap_data *unmap;\r\nunmap = mempool_alloc(__get_unmap_pool(nr)->pool, flags);\r\nif (!unmap)\r\nreturn NULL;\r\nmemset(unmap, 0, sizeof(*unmap));\r\nkref_init(&unmap->kref);\r\nunmap->dev = dev;\r\nunmap->map_cnt = nr;\r\nreturn unmap;\r\n}\r\ndma_cookie_t\r\ndma_async_memcpy_pg_to_pg(struct dma_chan *chan, struct page *dest_pg,\r\nunsigned int dest_off, struct page *src_pg, unsigned int src_off,\r\nsize_t len)\r\n{\r\nstruct dma_device *dev = chan->device;\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct dmaengine_unmap_data *unmap;\r\ndma_cookie_t cookie;\r\nunsigned long flags;\r\nunmap = dmaengine_get_unmap_data(dev->dev, 2, GFP_NOWAIT);\r\nif (!unmap)\r\nreturn -ENOMEM;\r\nunmap->to_cnt = 1;\r\nunmap->from_cnt = 1;\r\nunmap->addr[0] = dma_map_page(dev->dev, src_pg, src_off, len,\r\nDMA_TO_DEVICE);\r\nunmap->addr[1] = dma_map_page(dev->dev, dest_pg, dest_off, len,\r\nDMA_FROM_DEVICE);\r\nunmap->len = len;\r\nflags = DMA_CTRL_ACK;\r\ntx = dev->device_prep_dma_memcpy(chan, unmap->addr[1], unmap->addr[0],\r\nlen, flags);\r\nif (!tx) {\r\ndmaengine_unmap_put(unmap);\r\nreturn -ENOMEM;\r\n}\r\ndma_set_unmap(tx, unmap);\r\ncookie = tx->tx_submit(tx);\r\ndmaengine_unmap_put(unmap);\r\npreempt_disable();\r\n__this_cpu_add(chan->local->bytes_transferred, len);\r\n__this_cpu_inc(chan->local->memcpy_count);\r\npreempt_enable();\r\nreturn cookie;\r\n}\r\ndma_cookie_t\r\ndma_async_memcpy_buf_to_buf(struct dma_chan *chan, void *dest,\r\nvoid *src, size_t len)\r\n{\r\nreturn dma_async_memcpy_pg_to_pg(chan, virt_to_page(dest),\r\n(unsigned long) dest & ~PAGE_MASK,\r\nvirt_to_page(src),\r\n(unsigned long) src & ~PAGE_MASK, len);\r\n}\r\ndma_cookie_t\r\ndma_async_memcpy_buf_to_pg(struct dma_chan *chan, struct page *page,\r\nunsigned int offset, void *kdata, size_t len)\r\n{\r\nreturn dma_async_memcpy_pg_to_pg(chan, page, offset,\r\nvirt_to_page(kdata),\r\n(unsigned long) kdata & ~PAGE_MASK, len);\r\n}\r\nvoid dma_async_tx_descriptor_init(struct dma_async_tx_descriptor *tx,\r\nstruct dma_chan *chan)\r\n{\r\ntx->chan = chan;\r\n#ifdef CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH\r\nspin_lock_init(&tx->lock);\r\n#endif\r\n}\r\nenum dma_status\r\ndma_wait_for_async_tx(struct dma_async_tx_descriptor *tx)\r\n{\r\nunsigned long dma_sync_wait_timeout = jiffies + msecs_to_jiffies(5000);\r\nif (!tx)\r\nreturn DMA_COMPLETE;\r\nwhile (tx->cookie == -EBUSY) {\r\nif (time_after_eq(jiffies, dma_sync_wait_timeout)) {\r\npr_err("%s timeout waiting for descriptor submission\n",\r\n__func__);\r\nreturn DMA_ERROR;\r\n}\r\ncpu_relax();\r\n}\r\nreturn dma_sync_wait(tx->chan, tx->cookie);\r\n}\r\nvoid dma_run_dependencies(struct dma_async_tx_descriptor *tx)\r\n{\r\nstruct dma_async_tx_descriptor *dep = txd_next(tx);\r\nstruct dma_async_tx_descriptor *dep_next;\r\nstruct dma_chan *chan;\r\nif (!dep)\r\nreturn;\r\ntxd_clear_next(tx);\r\nchan = dep->chan;\r\nfor (; dep; dep = dep_next) {\r\ntxd_lock(dep);\r\ntxd_clear_parent(dep);\r\ndep_next = txd_next(dep);\r\nif (dep_next && dep_next->chan == chan)\r\ntxd_clear_next(dep);\r\nelse\r\ndep_next = NULL;\r\ntxd_unlock(dep);\r\ndep->tx_submit(dep);\r\n}\r\nchan->device->device_issue_pending(chan);\r\n}\r\nstatic int __init dma_bus_init(void)\r\n{\r\nint err = dmaengine_init_unmap_pool();\r\nif (err)\r\nreturn err;\r\nreturn class_register(&dma_devclass);\r\n}
