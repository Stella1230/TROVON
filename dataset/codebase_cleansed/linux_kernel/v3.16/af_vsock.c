int vm_sockets_get_local_cid(void)\r\n{\r\nreturn transport->get_local_cid();\r\n}\r\nstatic int vsock_auto_bind(struct vsock_sock *vsk)\r\n{\r\nstruct sock *sk = sk_vsock(vsk);\r\nstruct sockaddr_vm local_addr;\r\nif (vsock_addr_bound(&vsk->local_addr))\r\nreturn 0;\r\nvsock_addr_init(&local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\r\nreturn __vsock_bind(sk, &local_addr);\r\n}\r\nstatic void vsock_init_tables(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vsock_bind_table); i++)\r\nINIT_LIST_HEAD(&vsock_bind_table[i]);\r\nfor (i = 0; i < ARRAY_SIZE(vsock_connected_table); i++)\r\nINIT_LIST_HEAD(&vsock_connected_table[i]);\r\n}\r\nstatic void __vsock_insert_bound(struct list_head *list,\r\nstruct vsock_sock *vsk)\r\n{\r\nsock_hold(&vsk->sk);\r\nlist_add(&vsk->bound_table, list);\r\n}\r\nstatic void __vsock_insert_connected(struct list_head *list,\r\nstruct vsock_sock *vsk)\r\n{\r\nsock_hold(&vsk->sk);\r\nlist_add(&vsk->connected_table, list);\r\n}\r\nstatic void __vsock_remove_bound(struct vsock_sock *vsk)\r\n{\r\nlist_del_init(&vsk->bound_table);\r\nsock_put(&vsk->sk);\r\n}\r\nstatic void __vsock_remove_connected(struct vsock_sock *vsk)\r\n{\r\nlist_del_init(&vsk->connected_table);\r\nsock_put(&vsk->sk);\r\n}\r\nstatic struct sock *__vsock_find_bound_socket(struct sockaddr_vm *addr)\r\n{\r\nstruct vsock_sock *vsk;\r\nlist_for_each_entry(vsk, vsock_bound_sockets(addr), bound_table)\r\nif (addr->svm_port == vsk->local_addr.svm_port)\r\nreturn sk_vsock(vsk);\r\nreturn NULL;\r\n}\r\nstatic struct sock *__vsock_find_connected_socket(struct sockaddr_vm *src,\r\nstruct sockaddr_vm *dst)\r\n{\r\nstruct vsock_sock *vsk;\r\nlist_for_each_entry(vsk, vsock_connected_sockets(src, dst),\r\nconnected_table) {\r\nif (vsock_addr_equals_addr(src, &vsk->remote_addr) &&\r\ndst->svm_port == vsk->local_addr.svm_port) {\r\nreturn sk_vsock(vsk);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool __vsock_in_bound_table(struct vsock_sock *vsk)\r\n{\r\nreturn !list_empty(&vsk->bound_table);\r\n}\r\nstatic bool __vsock_in_connected_table(struct vsock_sock *vsk)\r\n{\r\nreturn !list_empty(&vsk->connected_table);\r\n}\r\nstatic void vsock_insert_unbound(struct vsock_sock *vsk)\r\n{\r\nspin_lock_bh(&vsock_table_lock);\r\n__vsock_insert_bound(vsock_unbound_sockets, vsk);\r\nspin_unlock_bh(&vsock_table_lock);\r\n}\r\nvoid vsock_insert_connected(struct vsock_sock *vsk)\r\n{\r\nstruct list_head *list = vsock_connected_sockets(\r\n&vsk->remote_addr, &vsk->local_addr);\r\nspin_lock_bh(&vsock_table_lock);\r\n__vsock_insert_connected(list, vsk);\r\nspin_unlock_bh(&vsock_table_lock);\r\n}\r\nvoid vsock_remove_bound(struct vsock_sock *vsk)\r\n{\r\nspin_lock_bh(&vsock_table_lock);\r\n__vsock_remove_bound(vsk);\r\nspin_unlock_bh(&vsock_table_lock);\r\n}\r\nvoid vsock_remove_connected(struct vsock_sock *vsk)\r\n{\r\nspin_lock_bh(&vsock_table_lock);\r\n__vsock_remove_connected(vsk);\r\nspin_unlock_bh(&vsock_table_lock);\r\n}\r\nstruct sock *vsock_find_bound_socket(struct sockaddr_vm *addr)\r\n{\r\nstruct sock *sk;\r\nspin_lock_bh(&vsock_table_lock);\r\nsk = __vsock_find_bound_socket(addr);\r\nif (sk)\r\nsock_hold(sk);\r\nspin_unlock_bh(&vsock_table_lock);\r\nreturn sk;\r\n}\r\nstruct sock *vsock_find_connected_socket(struct sockaddr_vm *src,\r\nstruct sockaddr_vm *dst)\r\n{\r\nstruct sock *sk;\r\nspin_lock_bh(&vsock_table_lock);\r\nsk = __vsock_find_connected_socket(src, dst);\r\nif (sk)\r\nsock_hold(sk);\r\nspin_unlock_bh(&vsock_table_lock);\r\nreturn sk;\r\n}\r\nstatic bool vsock_in_bound_table(struct vsock_sock *vsk)\r\n{\r\nbool ret;\r\nspin_lock_bh(&vsock_table_lock);\r\nret = __vsock_in_bound_table(vsk);\r\nspin_unlock_bh(&vsock_table_lock);\r\nreturn ret;\r\n}\r\nstatic bool vsock_in_connected_table(struct vsock_sock *vsk)\r\n{\r\nbool ret;\r\nspin_lock_bh(&vsock_table_lock);\r\nret = __vsock_in_connected_table(vsk);\r\nspin_unlock_bh(&vsock_table_lock);\r\nreturn ret;\r\n}\r\nvoid vsock_for_each_connected_socket(void (*fn)(struct sock *sk))\r\n{\r\nint i;\r\nspin_lock_bh(&vsock_table_lock);\r\nfor (i = 0; i < ARRAY_SIZE(vsock_connected_table); i++) {\r\nstruct vsock_sock *vsk;\r\nlist_for_each_entry(vsk, &vsock_connected_table[i],\r\nconnected_table)\r\nfn(sk_vsock(vsk));\r\n}\r\nspin_unlock_bh(&vsock_table_lock);\r\n}\r\nvoid vsock_add_pending(struct sock *listener, struct sock *pending)\r\n{\r\nstruct vsock_sock *vlistener;\r\nstruct vsock_sock *vpending;\r\nvlistener = vsock_sk(listener);\r\nvpending = vsock_sk(pending);\r\nsock_hold(pending);\r\nsock_hold(listener);\r\nlist_add_tail(&vpending->pending_links, &vlistener->pending_links);\r\n}\r\nvoid vsock_remove_pending(struct sock *listener, struct sock *pending)\r\n{\r\nstruct vsock_sock *vpending = vsock_sk(pending);\r\nlist_del_init(&vpending->pending_links);\r\nsock_put(listener);\r\nsock_put(pending);\r\n}\r\nvoid vsock_enqueue_accept(struct sock *listener, struct sock *connected)\r\n{\r\nstruct vsock_sock *vlistener;\r\nstruct vsock_sock *vconnected;\r\nvlistener = vsock_sk(listener);\r\nvconnected = vsock_sk(connected);\r\nsock_hold(connected);\r\nsock_hold(listener);\r\nlist_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);\r\n}\r\nstatic struct sock *vsock_dequeue_accept(struct sock *listener)\r\n{\r\nstruct vsock_sock *vlistener;\r\nstruct vsock_sock *vconnected;\r\nvlistener = vsock_sk(listener);\r\nif (list_empty(&vlistener->accept_queue))\r\nreturn NULL;\r\nvconnected = list_entry(vlistener->accept_queue.next,\r\nstruct vsock_sock, accept_queue);\r\nlist_del_init(&vconnected->accept_queue);\r\nsock_put(listener);\r\nreturn sk_vsock(vconnected);\r\n}\r\nstatic bool vsock_is_accept_queue_empty(struct sock *sk)\r\n{\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\nreturn list_empty(&vsk->accept_queue);\r\n}\r\nstatic bool vsock_is_pending(struct sock *sk)\r\n{\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\nreturn !list_empty(&vsk->pending_links);\r\n}\r\nstatic int vsock_send_shutdown(struct sock *sk, int mode)\r\n{\r\nreturn transport->shutdown(vsock_sk(sk), mode);\r\n}\r\nvoid vsock_pending_work(struct work_struct *work)\r\n{\r\nstruct sock *sk;\r\nstruct sock *listener;\r\nstruct vsock_sock *vsk;\r\nbool cleanup;\r\nvsk = container_of(work, struct vsock_sock, dwork.work);\r\nsk = sk_vsock(vsk);\r\nlistener = vsk->listener;\r\ncleanup = true;\r\nlock_sock(listener);\r\nlock_sock(sk);\r\nif (vsock_is_pending(sk)) {\r\nvsock_remove_pending(listener, sk);\r\n} else if (!vsk->rejected) {\r\ncleanup = false;\r\ngoto out;\r\n}\r\nlistener->sk_ack_backlog--;\r\nif (vsock_in_connected_table(vsk))\r\nvsock_remove_connected(vsk);\r\nsk->sk_state = SS_FREE;\r\nout:\r\nrelease_sock(sk);\r\nrelease_sock(listener);\r\nif (cleanup)\r\nsock_put(sk);\r\nsock_put(sk);\r\nsock_put(listener);\r\n}\r\nstatic int __vsock_bind_stream(struct vsock_sock *vsk,\r\nstruct sockaddr_vm *addr)\r\n{\r\nstatic u32 port = LAST_RESERVED_PORT + 1;\r\nstruct sockaddr_vm new_addr;\r\nvsock_addr_init(&new_addr, addr->svm_cid, addr->svm_port);\r\nif (addr->svm_port == VMADDR_PORT_ANY) {\r\nbool found = false;\r\nunsigned int i;\r\nfor (i = 0; i < MAX_PORT_RETRIES; i++) {\r\nif (port <= LAST_RESERVED_PORT)\r\nport = LAST_RESERVED_PORT + 1;\r\nnew_addr.svm_port = port++;\r\nif (!__vsock_find_bound_socket(&new_addr)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn -EADDRNOTAVAIL;\r\n} else {\r\nif (addr->svm_port <= LAST_RESERVED_PORT &&\r\n!capable(CAP_NET_BIND_SERVICE)) {\r\nreturn -EACCES;\r\n}\r\nif (__vsock_find_bound_socket(&new_addr))\r\nreturn -EADDRINUSE;\r\n}\r\nvsock_addr_init(&vsk->local_addr, new_addr.svm_cid, new_addr.svm_port);\r\n__vsock_remove_bound(vsk);\r\n__vsock_insert_bound(vsock_bound_sockets(&vsk->local_addr), vsk);\r\nreturn 0;\r\n}\r\nstatic int __vsock_bind_dgram(struct vsock_sock *vsk,\r\nstruct sockaddr_vm *addr)\r\n{\r\nreturn transport->dgram_bind(vsk, addr);\r\n}\r\nstatic int __vsock_bind(struct sock *sk, struct sockaddr_vm *addr)\r\n{\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\nu32 cid;\r\nint retval;\r\nif (vsock_addr_bound(&vsk->local_addr))\r\nreturn -EINVAL;\r\ncid = transport->get_local_cid();\r\nif (addr->svm_cid != cid && addr->svm_cid != VMADDR_CID_ANY)\r\nreturn -EADDRNOTAVAIL;\r\nswitch (sk->sk_socket->type) {\r\ncase SOCK_STREAM:\r\nspin_lock_bh(&vsock_table_lock);\r\nretval = __vsock_bind_stream(vsk, addr);\r\nspin_unlock_bh(&vsock_table_lock);\r\nbreak;\r\ncase SOCK_DGRAM:\r\nretval = __vsock_bind_dgram(vsk, addr);\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstruct sock *__vsock_create(struct net *net,\r\nstruct socket *sock,\r\nstruct sock *parent,\r\ngfp_t priority,\r\nunsigned short type)\r\n{\r\nstruct sock *sk;\r\nstruct vsock_sock *psk;\r\nstruct vsock_sock *vsk;\r\nsk = sk_alloc(net, AF_VSOCK, priority, &vsock_proto);\r\nif (!sk)\r\nreturn NULL;\r\nsock_init_data(sock, sk);\r\nif (!sock)\r\nsk->sk_type = type;\r\nvsk = vsock_sk(sk);\r\nvsock_addr_init(&vsk->local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\r\nvsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\r\nsk->sk_destruct = vsock_sk_destruct;\r\nsk->sk_backlog_rcv = vsock_queue_rcv_skb;\r\nsk->sk_state = 0;\r\nsock_reset_flag(sk, SOCK_DONE);\r\nINIT_LIST_HEAD(&vsk->bound_table);\r\nINIT_LIST_HEAD(&vsk->connected_table);\r\nvsk->listener = NULL;\r\nINIT_LIST_HEAD(&vsk->pending_links);\r\nINIT_LIST_HEAD(&vsk->accept_queue);\r\nvsk->rejected = false;\r\nvsk->sent_request = false;\r\nvsk->ignore_connecting_rst = false;\r\nvsk->peer_shutdown = 0;\r\npsk = parent ? vsock_sk(parent) : NULL;\r\nif (parent) {\r\nvsk->trusted = psk->trusted;\r\nvsk->owner = get_cred(psk->owner);\r\nvsk->connect_timeout = psk->connect_timeout;\r\n} else {\r\nvsk->trusted = capable(CAP_NET_ADMIN);\r\nvsk->owner = get_current_cred();\r\nvsk->connect_timeout = VSOCK_DEFAULT_CONNECT_TIMEOUT;\r\n}\r\nif (transport->init(vsk, psk) < 0) {\r\nsk_free(sk);\r\nreturn NULL;\r\n}\r\nif (sock)\r\nvsock_insert_unbound(vsk);\r\nreturn sk;\r\n}\r\nstatic void __vsock_release(struct sock *sk)\r\n{\r\nif (sk) {\r\nstruct sk_buff *skb;\r\nstruct sock *pending;\r\nstruct vsock_sock *vsk;\r\nvsk = vsock_sk(sk);\r\npending = NULL;\r\nif (vsock_in_bound_table(vsk))\r\nvsock_remove_bound(vsk);\r\nif (vsock_in_connected_table(vsk))\r\nvsock_remove_connected(vsk);\r\ntransport->release(vsk);\r\nlock_sock(sk);\r\nsock_orphan(sk);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nwhile ((skb = skb_dequeue(&sk->sk_receive_queue)))\r\nkfree_skb(skb);\r\nwhile ((pending = vsock_dequeue_accept(sk)) != NULL) {\r\n__vsock_release(pending);\r\nsock_put(pending);\r\n}\r\nrelease_sock(sk);\r\nsock_put(sk);\r\n}\r\n}\r\nstatic void vsock_sk_destruct(struct sock *sk)\r\n{\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\ntransport->destruct(vsk);\r\nvsock_addr_init(&vsk->local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\r\nvsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\r\nput_cred(vsk->owner);\r\n}\r\nstatic int vsock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\r\n{\r\nint err;\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (err)\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\ns64 vsock_stream_has_data(struct vsock_sock *vsk)\r\n{\r\nreturn transport->stream_has_data(vsk);\r\n}\r\ns64 vsock_stream_has_space(struct vsock_sock *vsk)\r\n{\r\nreturn transport->stream_has_space(vsk);\r\n}\r\nstatic int vsock_release(struct socket *sock)\r\n{\r\n__vsock_release(sock->sk);\r\nsock->sk = NULL;\r\nsock->state = SS_FREE;\r\nreturn 0;\r\n}\r\nstatic int\r\nvsock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\r\n{\r\nint err;\r\nstruct sock *sk;\r\nstruct sockaddr_vm *vm_addr;\r\nsk = sock->sk;\r\nif (vsock_addr_cast(addr, addr_len, &vm_addr) != 0)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nerr = __vsock_bind(sk, vm_addr);\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int vsock_getname(struct socket *sock,\r\nstruct sockaddr *addr, int *addr_len, int peer)\r\n{\r\nint err;\r\nstruct sock *sk;\r\nstruct vsock_sock *vsk;\r\nstruct sockaddr_vm *vm_addr;\r\nsk = sock->sk;\r\nvsk = vsock_sk(sk);\r\nerr = 0;\r\nlock_sock(sk);\r\nif (peer) {\r\nif (sock->state != SS_CONNECTED) {\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nvm_addr = &vsk->remote_addr;\r\n} else {\r\nvm_addr = &vsk->local_addr;\r\n}\r\nif (!vm_addr) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nBUILD_BUG_ON(sizeof(*vm_addr) > 128);\r\nmemcpy(addr, vm_addr, sizeof(*vm_addr));\r\n*addr_len = sizeof(*vm_addr);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int vsock_shutdown(struct socket *sock, int mode)\r\n{\r\nint err;\r\nstruct sock *sk;\r\nmode++;\r\nif ((mode & ~SHUTDOWN_MASK) || !mode)\r\nreturn -EINVAL;\r\nsk = sock->sk;\r\nif (sock->state == SS_UNCONNECTED) {\r\nerr = -ENOTCONN;\r\nif (sk->sk_type == SOCK_STREAM)\r\nreturn err;\r\n} else {\r\nsock->state = SS_DISCONNECTING;\r\nerr = 0;\r\n}\r\nmode = mode & (RCV_SHUTDOWN | SEND_SHUTDOWN);\r\nif (mode) {\r\nlock_sock(sk);\r\nsk->sk_shutdown |= mode;\r\nsk->sk_state_change(sk);\r\nrelease_sock(sk);\r\nif (sk->sk_type == SOCK_STREAM) {\r\nsock_reset_flag(sk, SOCK_DONE);\r\nvsock_send_shutdown(sk, mode);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic unsigned int vsock_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk;\r\nunsigned int mask;\r\nstruct vsock_sock *vsk;\r\nsk = sock->sk;\r\nvsk = vsock_sk(sk);\r\npoll_wait(file, sk_sleep(sk), wait);\r\nmask = 0;\r\nif (sk->sk_err)\r\nmask |= POLLERR;\r\nif ((sk->sk_shutdown == SHUTDOWN_MASK) ||\r\n((sk->sk_shutdown & SEND_SHUTDOWN) &&\r\n(vsk->peer_shutdown & SEND_SHUTDOWN))) {\r\nmask |= POLLHUP;\r\n}\r\nif (sk->sk_shutdown & RCV_SHUTDOWN ||\r\nvsk->peer_shutdown & SEND_SHUTDOWN) {\r\nmask |= POLLRDHUP;\r\n}\r\nif (sock->type == SOCK_DGRAM) {\r\nif (!skb_queue_empty(&sk->sk_receive_queue) ||\r\n(sk->sk_shutdown & RCV_SHUTDOWN)) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nif (!(sk->sk_shutdown & SEND_SHUTDOWN))\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\n} else if (sock->type == SOCK_STREAM) {\r\nlock_sock(sk);\r\nif (sk->sk_state == SS_LISTEN\r\n&& !vsock_is_accept_queue_empty(sk))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (transport->stream_is_active(vsk) &&\r\n!(sk->sk_shutdown & RCV_SHUTDOWN)) {\r\nbool data_ready_now = false;\r\nint ret = transport->notify_poll_in(\r\nvsk, 1, &data_ready_now);\r\nif (ret < 0) {\r\nmask |= POLLERR;\r\n} else {\r\nif (data_ready_now)\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\n}\r\nif (sk->sk_shutdown & RCV_SHUTDOWN ||\r\nvsk->peer_shutdown & SEND_SHUTDOWN) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nif (sk->sk_state == SS_CONNECTED) {\r\nif (!(sk->sk_shutdown & SEND_SHUTDOWN)) {\r\nbool space_avail_now = false;\r\nint ret = transport->notify_poll_out(\r\nvsk, 1, &space_avail_now);\r\nif (ret < 0) {\r\nmask |= POLLERR;\r\n} else {\r\nif (space_avail_now)\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\n}\r\n}\r\nif (sk->sk_state == SS_UNCONNECTED) {\r\nif (!(sk->sk_shutdown & SEND_SHUTDOWN))\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\nrelease_sock(sk);\r\n}\r\nreturn mask;\r\n}\r\nstatic int vsock_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nint err;\r\nstruct sock *sk;\r\nstruct vsock_sock *vsk;\r\nstruct sockaddr_vm *remote_addr;\r\nif (msg->msg_flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nerr = 0;\r\nsk = sock->sk;\r\nvsk = vsock_sk(sk);\r\nlock_sock(sk);\r\nerr = vsock_auto_bind(vsk);\r\nif (err)\r\ngoto out;\r\nif (msg->msg_name &&\r\nvsock_addr_cast(msg->msg_name, msg->msg_namelen,\r\n&remote_addr) == 0) {\r\nif (remote_addr->svm_cid == VMADDR_CID_ANY)\r\nremote_addr->svm_cid = transport->get_local_cid();\r\nif (!vsock_addr_bound(remote_addr)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n} else if (sock->state == SS_CONNECTED) {\r\nremote_addr = &vsk->remote_addr;\r\nif (remote_addr->svm_cid == VMADDR_CID_ANY)\r\nremote_addr->svm_cid = transport->get_local_cid();\r\nif (!vsock_addr_bound(&vsk->remote_addr)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n} else {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (!transport->dgram_allow(remote_addr->svm_cid,\r\nremote_addr->svm_port)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = transport->dgram_enqueue(vsk, remote_addr, msg->msg_iov, len);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int vsock_dgram_connect(struct socket *sock,\r\nstruct sockaddr *addr, int addr_len, int flags)\r\n{\r\nint err;\r\nstruct sock *sk;\r\nstruct vsock_sock *vsk;\r\nstruct sockaddr_vm *remote_addr;\r\nsk = sock->sk;\r\nvsk = vsock_sk(sk);\r\nerr = vsock_addr_cast(addr, addr_len, &remote_addr);\r\nif (err == -EAFNOSUPPORT && remote_addr->svm_family == AF_UNSPEC) {\r\nlock_sock(sk);\r\nvsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY,\r\nVMADDR_PORT_ANY);\r\nsock->state = SS_UNCONNECTED;\r\nrelease_sock(sk);\r\nreturn 0;\r\n} else if (err != 0)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nerr = vsock_auto_bind(vsk);\r\nif (err)\r\ngoto out;\r\nif (!transport->dgram_allow(remote_addr->svm_cid,\r\nremote_addr->svm_port)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(&vsk->remote_addr, remote_addr, sizeof(vsk->remote_addr));\r\nsock->state = SS_CONNECTED;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int vsock_dgram_recvmsg(struct kiocb *kiocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len, int flags)\r\n{\r\nreturn transport->dgram_dequeue(kiocb, vsock_sk(sock->sk), msg, len,\r\nflags);\r\n}\r\nstatic void vsock_connect_timeout(struct work_struct *work)\r\n{\r\nstruct sock *sk;\r\nstruct vsock_sock *vsk;\r\nvsk = container_of(work, struct vsock_sock, dwork.work);\r\nsk = sk_vsock(vsk);\r\nlock_sock(sk);\r\nif (sk->sk_state == SS_CONNECTING &&\r\n(sk->sk_shutdown != SHUTDOWN_MASK)) {\r\nsk->sk_state = SS_UNCONNECTED;\r\nsk->sk_err = ETIMEDOUT;\r\nsk->sk_error_report(sk);\r\n}\r\nrelease_sock(sk);\r\nsock_put(sk);\r\n}\r\nstatic int vsock_stream_connect(struct socket *sock, struct sockaddr *addr,\r\nint addr_len, int flags)\r\n{\r\nint err;\r\nstruct sock *sk;\r\nstruct vsock_sock *vsk;\r\nstruct sockaddr_vm *remote_addr;\r\nlong timeout;\r\nDEFINE_WAIT(wait);\r\nerr = 0;\r\nsk = sock->sk;\r\nvsk = vsock_sk(sk);\r\nlock_sock(sk);\r\nswitch (sock->state) {\r\ncase SS_CONNECTED:\r\nerr = -EISCONN;\r\ngoto out;\r\ncase SS_DISCONNECTING:\r\nerr = -EINVAL;\r\ngoto out;\r\ncase SS_CONNECTING:\r\nerr = -EALREADY;\r\nbreak;\r\ndefault:\r\nif ((sk->sk_state == SS_LISTEN) ||\r\nvsock_addr_cast(addr, addr_len, &remote_addr) != 0) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (!transport->stream_allow(remote_addr->svm_cid,\r\nremote_addr->svm_port)) {\r\nerr = -ENETUNREACH;\r\ngoto out;\r\n}\r\nmemcpy(&vsk->remote_addr, remote_addr,\r\nsizeof(vsk->remote_addr));\r\nerr = vsock_auto_bind(vsk);\r\nif (err)\r\ngoto out;\r\nsk->sk_state = SS_CONNECTING;\r\nerr = transport->connect(vsk);\r\nif (err < 0)\r\ngoto out;\r\nsock->state = SS_CONNECTING;\r\nerr = -EINPROGRESS;\r\n}\r\ntimeout = vsk->connect_timeout;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nwhile (sk->sk_state != SS_CONNECTED && sk->sk_err == 0) {\r\nif (flags & O_NONBLOCK) {\r\nsock_hold(sk);\r\nINIT_DELAYED_WORK(&vsk->dwork,\r\nvsock_connect_timeout);\r\nschedule_delayed_work(&vsk->dwork, timeout);\r\ngoto out_wait;\r\n}\r\nrelease_sock(sk);\r\ntimeout = schedule_timeout(timeout);\r\nlock_sock(sk);\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeout);\r\ngoto out_wait_error;\r\n} else if (timeout == 0) {\r\nerr = -ETIMEDOUT;\r\ngoto out_wait_error;\r\n}\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\n}\r\nif (sk->sk_err) {\r\nerr = -sk->sk_err;\r\ngoto out_wait_error;\r\n} else\r\nerr = 0;\r\nout_wait:\r\nfinish_wait(sk_sleep(sk), &wait);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\nout_wait_error:\r\nsk->sk_state = SS_UNCONNECTED;\r\nsock->state = SS_UNCONNECTED;\r\ngoto out_wait;\r\n}\r\nstatic int vsock_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nstruct sock *listener;\r\nint err;\r\nstruct sock *connected;\r\nstruct vsock_sock *vconnected;\r\nlong timeout;\r\nDEFINE_WAIT(wait);\r\nerr = 0;\r\nlistener = sock->sk;\r\nlock_sock(listener);\r\nif (sock->type != SOCK_STREAM) {\r\nerr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (listener->sk_state != SS_LISTEN) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ntimeout = sock_sndtimeo(listener, flags & O_NONBLOCK);\r\nprepare_to_wait(sk_sleep(listener), &wait, TASK_INTERRUPTIBLE);\r\nwhile ((connected = vsock_dequeue_accept(listener)) == NULL &&\r\nlistener->sk_err == 0) {\r\nrelease_sock(listener);\r\ntimeout = schedule_timeout(timeout);\r\nlock_sock(listener);\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeout);\r\ngoto out_wait;\r\n} else if (timeout == 0) {\r\nerr = -EAGAIN;\r\ngoto out_wait;\r\n}\r\nprepare_to_wait(sk_sleep(listener), &wait, TASK_INTERRUPTIBLE);\r\n}\r\nif (listener->sk_err)\r\nerr = -listener->sk_err;\r\nif (connected) {\r\nlistener->sk_ack_backlog--;\r\nlock_sock(connected);\r\nvconnected = vsock_sk(connected);\r\nif (err) {\r\nvconnected->rejected = true;\r\nrelease_sock(connected);\r\nsock_put(connected);\r\ngoto out_wait;\r\n}\r\nnewsock->state = SS_CONNECTED;\r\nsock_graft(connected, newsock);\r\nrelease_sock(connected);\r\nsock_put(connected);\r\n}\r\nout_wait:\r\nfinish_wait(sk_sleep(listener), &wait);\r\nout:\r\nrelease_sock(listener);\r\nreturn err;\r\n}\r\nstatic int vsock_listen(struct socket *sock, int backlog)\r\n{\r\nint err;\r\nstruct sock *sk;\r\nstruct vsock_sock *vsk;\r\nsk = sock->sk;\r\nlock_sock(sk);\r\nif (sock->type != SOCK_STREAM) {\r\nerr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (sock->state != SS_UNCONNECTED) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nvsk = vsock_sk(sk);\r\nif (!vsock_addr_bound(&vsk->local_addr)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_state = SS_LISTEN;\r\nerr = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int vsock_stream_setsockopt(struct socket *sock,\r\nint level,\r\nint optname,\r\nchar __user *optval,\r\nunsigned int optlen)\r\n{\r\nint err;\r\nstruct sock *sk;\r\nstruct vsock_sock *vsk;\r\nu64 val;\r\nif (level != AF_VSOCK)\r\nreturn -ENOPROTOOPT;\r\n#define COPY_IN(_v) \\r\ndo { \\r\nif (optlen < sizeof(_v)) { \\r\nerr = -EINVAL; \\r\ngoto exit; \\r\n} \\r\nif (copy_from_user(&_v, optval, sizeof(_v)) != 0) { \\r\nerr = -EFAULT; \\r\ngoto exit; \\r\n} \\r\n} while (0)\r\nerr = 0;\r\nsk = sock->sk;\r\nvsk = vsock_sk(sk);\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase SO_VM_SOCKETS_BUFFER_SIZE:\r\nCOPY_IN(val);\r\ntransport->set_buffer_size(vsk, val);\r\nbreak;\r\ncase SO_VM_SOCKETS_BUFFER_MAX_SIZE:\r\nCOPY_IN(val);\r\ntransport->set_max_buffer_size(vsk, val);\r\nbreak;\r\ncase SO_VM_SOCKETS_BUFFER_MIN_SIZE:\r\nCOPY_IN(val);\r\ntransport->set_min_buffer_size(vsk, val);\r\nbreak;\r\ncase SO_VM_SOCKETS_CONNECT_TIMEOUT: {\r\nstruct timeval tv;\r\nCOPY_IN(tv);\r\nif (tv.tv_sec >= 0 && tv.tv_usec < USEC_PER_SEC &&\r\ntv.tv_sec < (MAX_SCHEDULE_TIMEOUT / HZ - 1)) {\r\nvsk->connect_timeout = tv.tv_sec * HZ +\r\nDIV_ROUND_UP(tv.tv_usec, (1000000 / HZ));\r\nif (vsk->connect_timeout == 0)\r\nvsk->connect_timeout =\r\nVSOCK_DEFAULT_CONNECT_TIMEOUT;\r\n} else {\r\nerr = -ERANGE;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\n#undef COPY_IN\r\nexit:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int vsock_stream_getsockopt(struct socket *sock,\r\nint level, int optname,\r\nchar __user *optval,\r\nint __user *optlen)\r\n{\r\nint err;\r\nint len;\r\nstruct sock *sk;\r\nstruct vsock_sock *vsk;\r\nu64 val;\r\nif (level != AF_VSOCK)\r\nreturn -ENOPROTOOPT;\r\nerr = get_user(len, optlen);\r\nif (err != 0)\r\nreturn err;\r\n#define COPY_OUT(_v) \\r\ndo { \\r\nif (len < sizeof(_v)) \\r\nreturn -EINVAL; \\r\n\\r\nlen = sizeof(_v); \\r\nif (copy_to_user(optval, &_v, len) != 0) \\r\nreturn -EFAULT; \\r\n\\r\n} while (0)\r\nerr = 0;\r\nsk = sock->sk;\r\nvsk = vsock_sk(sk);\r\nswitch (optname) {\r\ncase SO_VM_SOCKETS_BUFFER_SIZE:\r\nval = transport->get_buffer_size(vsk);\r\nCOPY_OUT(val);\r\nbreak;\r\ncase SO_VM_SOCKETS_BUFFER_MAX_SIZE:\r\nval = transport->get_max_buffer_size(vsk);\r\nCOPY_OUT(val);\r\nbreak;\r\ncase SO_VM_SOCKETS_BUFFER_MIN_SIZE:\r\nval = transport->get_min_buffer_size(vsk);\r\nCOPY_OUT(val);\r\nbreak;\r\ncase SO_VM_SOCKETS_CONNECT_TIMEOUT: {\r\nstruct timeval tv;\r\ntv.tv_sec = vsk->connect_timeout / HZ;\r\ntv.tv_usec =\r\n(vsk->connect_timeout -\r\ntv.tv_sec * HZ) * (1000000 / HZ);\r\nCOPY_OUT(tv);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nerr = put_user(len, optlen);\r\nif (err != 0)\r\nreturn -EFAULT;\r\n#undef COPY_OUT\r\nreturn 0;\r\n}\r\nstatic int vsock_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk;\r\nstruct vsock_sock *vsk;\r\nssize_t total_written;\r\nlong timeout;\r\nint err;\r\nstruct vsock_transport_send_notify_data send_data;\r\nDEFINE_WAIT(wait);\r\nsk = sock->sk;\r\nvsk = vsock_sk(sk);\r\ntotal_written = 0;\r\nerr = 0;\r\nif (msg->msg_flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nlock_sock(sk);\r\nif (msg->msg_namelen) {\r\nerr = sk->sk_state == SS_CONNECTED ? -EISCONN : -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (sk->sk_shutdown & SEND_SHUTDOWN ||\r\nvsk->peer_shutdown & RCV_SHUTDOWN) {\r\nerr = -EPIPE;\r\ngoto out;\r\n}\r\nif (sk->sk_state != SS_CONNECTED ||\r\n!vsock_addr_bound(&vsk->local_addr)) {\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nif (!vsock_addr_bound(&vsk->remote_addr)) {\r\nerr = -EDESTADDRREQ;\r\ngoto out;\r\n}\r\ntimeout = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\r\nerr = transport->notify_send_init(vsk, &send_data);\r\nif (err < 0)\r\ngoto out;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nwhile (total_written < len) {\r\nssize_t written;\r\nwhile (vsock_stream_has_space(vsk) == 0 &&\r\nsk->sk_err == 0 &&\r\n!(sk->sk_shutdown & SEND_SHUTDOWN) &&\r\n!(vsk->peer_shutdown & RCV_SHUTDOWN)) {\r\nif (timeout == 0) {\r\nerr = -EAGAIN;\r\ngoto out_wait;\r\n}\r\nerr = transport->notify_send_pre_block(vsk, &send_data);\r\nif (err < 0)\r\ngoto out_wait;\r\nrelease_sock(sk);\r\ntimeout = schedule_timeout(timeout);\r\nlock_sock(sk);\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeout);\r\ngoto out_wait;\r\n} else if (timeout == 0) {\r\nerr = -EAGAIN;\r\ngoto out_wait;\r\n}\r\nprepare_to_wait(sk_sleep(sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\n}\r\nif (sk->sk_err) {\r\nerr = -sk->sk_err;\r\ngoto out_wait;\r\n} else if ((sk->sk_shutdown & SEND_SHUTDOWN) ||\r\n(vsk->peer_shutdown & RCV_SHUTDOWN)) {\r\nerr = -EPIPE;\r\ngoto out_wait;\r\n}\r\nerr = transport->notify_send_pre_enqueue(vsk, &send_data);\r\nif (err < 0)\r\ngoto out_wait;\r\nwritten = transport->stream_enqueue(\r\nvsk, msg->msg_iov,\r\nlen - total_written);\r\nif (written < 0) {\r\nerr = -ENOMEM;\r\ngoto out_wait;\r\n}\r\ntotal_written += written;\r\nerr = transport->notify_send_post_enqueue(\r\nvsk, written, &send_data);\r\nif (err < 0)\r\ngoto out_wait;\r\n}\r\nout_wait:\r\nif (total_written > 0)\r\nerr = total_written;\r\nfinish_wait(sk_sleep(sk), &wait);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int\r\nvsock_stream_recvmsg(struct kiocb *kiocb,\r\nstruct socket *sock,\r\nstruct msghdr *msg, size_t len, int flags)\r\n{\r\nstruct sock *sk;\r\nstruct vsock_sock *vsk;\r\nint err;\r\nsize_t target;\r\nssize_t copied;\r\nlong timeout;\r\nstruct vsock_transport_recv_notify_data recv_data;\r\nDEFINE_WAIT(wait);\r\nsk = sock->sk;\r\nvsk = vsock_sk(sk);\r\nerr = 0;\r\nlock_sock(sk);\r\nif (sk->sk_state != SS_CONNECTED) {\r\nif (sock_flag(sk, SOCK_DONE))\r\nerr = 0;\r\nelse\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nif (flags & MSG_OOB) {\r\nerr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (sk->sk_shutdown & RCV_SHUTDOWN) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (!len) {\r\nerr = 0;\r\ngoto out;\r\n}\r\ntarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\r\nif (target >= transport->stream_rcvhiwat(vsk)) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ntimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\r\ncopied = 0;\r\nerr = transport->notify_recv_init(vsk, target, &recv_data);\r\nif (err < 0)\r\ngoto out;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nwhile (1) {\r\ns64 ready = vsock_stream_has_data(vsk);\r\nif (ready < 0) {\r\nerr = -ENOMEM;\r\ngoto out_wait;\r\n} else if (ready > 0) {\r\nssize_t read;\r\nerr = transport->notify_recv_pre_dequeue(\r\nvsk, target, &recv_data);\r\nif (err < 0)\r\nbreak;\r\nread = transport->stream_dequeue(\r\nvsk, msg->msg_iov,\r\nlen - copied, flags);\r\nif (read < 0) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\ncopied += read;\r\nerr = transport->notify_recv_post_dequeue(\r\nvsk, target, read,\r\n!(flags & MSG_PEEK), &recv_data);\r\nif (err < 0)\r\ngoto out_wait;\r\nif (read >= target || flags & MSG_PEEK)\r\nbreak;\r\ntarget -= read;\r\n} else {\r\nif (sk->sk_err != 0 || (sk->sk_shutdown & RCV_SHUTDOWN)\r\n|| (vsk->peer_shutdown & SEND_SHUTDOWN)) {\r\nbreak;\r\n}\r\nif (timeout == 0) {\r\nerr = -EAGAIN;\r\nbreak;\r\n}\r\nerr = transport->notify_recv_pre_block(\r\nvsk, target, &recv_data);\r\nif (err < 0)\r\nbreak;\r\nrelease_sock(sk);\r\ntimeout = schedule_timeout(timeout);\r\nlock_sock(sk);\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeout);\r\nbreak;\r\n} else if (timeout == 0) {\r\nerr = -EAGAIN;\r\nbreak;\r\n}\r\nprepare_to_wait(sk_sleep(sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\n}\r\n}\r\nif (sk->sk_err)\r\nerr = -sk->sk_err;\r\nelse if (sk->sk_shutdown & RCV_SHUTDOWN)\r\nerr = 0;\r\nif (copied > 0) {\r\nif (!(flags & MSG_PEEK)) {\r\nif (vsk->peer_shutdown & SEND_SHUTDOWN) {\r\nif (vsock_stream_has_data(vsk) <= 0) {\r\nsk->sk_state = SS_UNCONNECTED;\r\nsock_set_flag(sk, SOCK_DONE);\r\nsk->sk_state_change(sk);\r\n}\r\n}\r\n}\r\nerr = copied;\r\n}\r\nout_wait:\r\nfinish_wait(sk_sleep(sk), &wait);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int vsock_create(struct net *net, struct socket *sock,\r\nint protocol, int kern)\r\n{\r\nif (!sock)\r\nreturn -EINVAL;\r\nif (protocol && protocol != PF_VSOCK)\r\nreturn -EPROTONOSUPPORT;\r\nswitch (sock->type) {\r\ncase SOCK_DGRAM:\r\nsock->ops = &vsock_dgram_ops;\r\nbreak;\r\ncase SOCK_STREAM:\r\nsock->ops = &vsock_stream_ops;\r\nbreak;\r\ndefault:\r\nreturn -ESOCKTNOSUPPORT;\r\n}\r\nsock->state = SS_UNCONNECTED;\r\nreturn __vsock_create(net, sock, NULL, GFP_KERNEL, 0) ? 0 : -ENOMEM;\r\n}\r\nstatic long vsock_dev_do_ioctl(struct file *filp,\r\nunsigned int cmd, void __user *ptr)\r\n{\r\nu32 __user *p = ptr;\r\nint retval = 0;\r\nswitch (cmd) {\r\ncase IOCTL_VM_SOCKETS_GET_LOCAL_CID:\r\nif (put_user(transport->get_local_cid(), p) != 0)\r\nretval = -EFAULT;\r\nbreak;\r\ndefault:\r\npr_err("Unknown ioctl %d\n", cmd);\r\nretval = -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic long vsock_dev_ioctl(struct file *filp,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn vsock_dev_do_ioctl(filp, cmd, (void __user *)arg);\r\n}\r\nstatic long vsock_dev_compat_ioctl(struct file *filp,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn vsock_dev_do_ioctl(filp, cmd, compat_ptr(arg));\r\n}\r\nint __vsock_core_init(const struct vsock_transport *t, struct module *owner)\r\n{\r\nint err = mutex_lock_interruptible(&vsock_register_mutex);\r\nif (err)\r\nreturn err;\r\nif (transport) {\r\nerr = -EBUSY;\r\ngoto err_busy;\r\n}\r\nvsock_proto.owner = owner;\r\ntransport = t;\r\nvsock_init_tables();\r\nvsock_device.minor = MISC_DYNAMIC_MINOR;\r\nerr = misc_register(&vsock_device);\r\nif (err) {\r\npr_err("Failed to register misc device\n");\r\nreturn -ENOENT;\r\n}\r\nerr = proto_register(&vsock_proto, 1);\r\nif (err) {\r\npr_err("Cannot register vsock protocol\n");\r\ngoto err_misc_deregister;\r\n}\r\nerr = sock_register(&vsock_family_ops);\r\nif (err) {\r\npr_err("could not register af_vsock (%d) address family: %d\n",\r\nAF_VSOCK, err);\r\ngoto err_unregister_proto;\r\n}\r\nmutex_unlock(&vsock_register_mutex);\r\nreturn 0;\r\nerr_unregister_proto:\r\nproto_unregister(&vsock_proto);\r\nerr_misc_deregister:\r\nmisc_deregister(&vsock_device);\r\ntransport = NULL;\r\nerr_busy:\r\nmutex_unlock(&vsock_register_mutex);\r\nreturn err;\r\n}\r\nvoid vsock_core_exit(void)\r\n{\r\nmutex_lock(&vsock_register_mutex);\r\nmisc_deregister(&vsock_device);\r\nsock_unregister(AF_VSOCK);\r\nproto_unregister(&vsock_proto);\r\nmb();\r\ntransport = NULL;\r\nmutex_unlock(&vsock_register_mutex);\r\n}
