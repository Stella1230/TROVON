static int __init\r\nforce_gpt_fn(char *str)\r\n{\r\nforce_gpt = 1;\r\nreturn 1;\r\n}\r\nstatic inline u32\r\nefi_crc32(const void *buf, unsigned long len)\r\n{\r\nreturn (crc32(~0L, buf, len) ^ ~0L);\r\n}\r\nstatic u64 last_lba(struct block_device *bdev)\r\n{\r\nif (!bdev || !bdev->bd_inode)\r\nreturn 0;\r\nreturn div_u64(bdev->bd_inode->i_size,\r\nbdev_logical_block_size(bdev)) - 1ULL;\r\n}\r\nstatic inline int pmbr_part_valid(gpt_mbr_record *part)\r\n{\r\nif (part->os_type != EFI_PMBR_OSTYPE_EFI_GPT)\r\ngoto invalid;\r\nif (le32_to_cpu(part->starting_lba) != GPT_PRIMARY_PARTITION_TABLE_LBA)\r\ngoto invalid;\r\nreturn GPT_MBR_PROTECTIVE;\r\ninvalid:\r\nreturn 0;\r\n}\r\nstatic int is_pmbr_valid(legacy_mbr *mbr, sector_t total_sectors)\r\n{\r\nuint32_t sz = 0;\r\nint i, part = 0, ret = 0;\r\nif (!mbr || le16_to_cpu(mbr->signature) != MSDOS_MBR_SIGNATURE)\r\ngoto done;\r\nfor (i = 0; i < 4; i++) {\r\nret = pmbr_part_valid(&mbr->partition_record[i]);\r\nif (ret == GPT_MBR_PROTECTIVE) {\r\npart = i;\r\ngoto check_hybrid;\r\n}\r\n}\r\nif (ret != GPT_MBR_PROTECTIVE)\r\ngoto done;\r\ncheck_hybrid:\r\nfor (i = 0; i < 4; i++)\r\nif ((mbr->partition_record[i].os_type !=\r\nEFI_PMBR_OSTYPE_EFI_GPT) &&\r\n(mbr->partition_record[i].os_type != 0x00))\r\nret = GPT_MBR_HYBRID;\r\nif (ret == GPT_MBR_PROTECTIVE) {\r\nsz = le32_to_cpu(mbr->partition_record[part].size_in_lba);\r\nif (sz != (uint32_t) total_sectors - 1 && sz != 0xFFFFFFFF)\r\npr_debug("GPT: mbr size in lba (%u) different than whole disk (%u).\n",\r\nsz, min_t(uint32_t,\r\ntotal_sectors - 1, 0xFFFFFFFF));\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic size_t read_lba(struct parsed_partitions *state,\r\nu64 lba, u8 *buffer, size_t count)\r\n{\r\nsize_t totalreadcount = 0;\r\nstruct block_device *bdev = state->bdev;\r\nsector_t n = lba * (bdev_logical_block_size(bdev) / 512);\r\nif (!buffer || lba > last_lba(bdev))\r\nreturn 0;\r\nwhile (count) {\r\nint copied = 512;\r\nSector sect;\r\nunsigned char *data = read_part_sector(state, n++, &sect);\r\nif (!data)\r\nbreak;\r\nif (copied > count)\r\ncopied = count;\r\nmemcpy(buffer, data, copied);\r\nput_dev_sector(sect);\r\nbuffer += copied;\r\ntotalreadcount +=copied;\r\ncount -= copied;\r\n}\r\nreturn totalreadcount;\r\n}\r\nstatic gpt_entry *alloc_read_gpt_entries(struct parsed_partitions *state,\r\ngpt_header *gpt)\r\n{\r\nsize_t count;\r\ngpt_entry *pte;\r\nif (!gpt)\r\nreturn NULL;\r\ncount = le32_to_cpu(gpt->num_partition_entries) *\r\nle32_to_cpu(gpt->sizeof_partition_entry);\r\nif (!count)\r\nreturn NULL;\r\npte = kmalloc(count, GFP_KERNEL);\r\nif (!pte)\r\nreturn NULL;\r\nif (read_lba(state, le64_to_cpu(gpt->partition_entry_lba),\r\n(u8 *) pte, count) < count) {\r\nkfree(pte);\r\npte=NULL;\r\nreturn NULL;\r\n}\r\nreturn pte;\r\n}\r\nstatic gpt_header *alloc_read_gpt_header(struct parsed_partitions *state,\r\nu64 lba)\r\n{\r\ngpt_header *gpt;\r\nunsigned ssz = bdev_logical_block_size(state->bdev);\r\ngpt = kmalloc(ssz, GFP_KERNEL);\r\nif (!gpt)\r\nreturn NULL;\r\nif (read_lba(state, lba, (u8 *) gpt, ssz) < ssz) {\r\nkfree(gpt);\r\ngpt=NULL;\r\nreturn NULL;\r\n}\r\nreturn gpt;\r\n}\r\nstatic int is_gpt_valid(struct parsed_partitions *state, u64 lba,\r\ngpt_header **gpt, gpt_entry **ptes)\r\n{\r\nu32 crc, origcrc;\r\nu64 lastlba;\r\nif (!ptes)\r\nreturn 0;\r\nif (!(*gpt = alloc_read_gpt_header(state, lba)))\r\nreturn 0;\r\nif (le64_to_cpu((*gpt)->signature) != GPT_HEADER_SIGNATURE) {\r\npr_debug("GUID Partition Table Header signature is wrong:"\r\n"%lld != %lld\n",\r\n(unsigned long long)le64_to_cpu((*gpt)->signature),\r\n(unsigned long long)GPT_HEADER_SIGNATURE);\r\ngoto fail;\r\n}\r\nif (le32_to_cpu((*gpt)->header_size) >\r\nbdev_logical_block_size(state->bdev)) {\r\npr_debug("GUID Partition Table Header size is too large: %u > %u\n",\r\nle32_to_cpu((*gpt)->header_size),\r\nbdev_logical_block_size(state->bdev));\r\ngoto fail;\r\n}\r\nif (le32_to_cpu((*gpt)->header_size) < sizeof(gpt_header)) {\r\npr_debug("GUID Partition Table Header size is too small: %u < %zu\n",\r\nle32_to_cpu((*gpt)->header_size),\r\nsizeof(gpt_header));\r\ngoto fail;\r\n}\r\norigcrc = le32_to_cpu((*gpt)->header_crc32);\r\n(*gpt)->header_crc32 = 0;\r\ncrc = efi_crc32((const unsigned char *) (*gpt), le32_to_cpu((*gpt)->header_size));\r\nif (crc != origcrc) {\r\npr_debug("GUID Partition Table Header CRC is wrong: %x != %x\n",\r\ncrc, origcrc);\r\ngoto fail;\r\n}\r\n(*gpt)->header_crc32 = cpu_to_le32(origcrc);\r\nif (le64_to_cpu((*gpt)->my_lba) != lba) {\r\npr_debug("GPT my_lba incorrect: %lld != %lld\n",\r\n(unsigned long long)le64_to_cpu((*gpt)->my_lba),\r\n(unsigned long long)lba);\r\ngoto fail;\r\n}\r\nlastlba = last_lba(state->bdev);\r\nif (le64_to_cpu((*gpt)->first_usable_lba) > lastlba) {\r\npr_debug("GPT: first_usable_lba incorrect: %lld > %lld\n",\r\n(unsigned long long)le64_to_cpu((*gpt)->first_usable_lba),\r\n(unsigned long long)lastlba);\r\ngoto fail;\r\n}\r\nif (le64_to_cpu((*gpt)->last_usable_lba) > lastlba) {\r\npr_debug("GPT: last_usable_lba incorrect: %lld > %lld\n",\r\n(unsigned long long)le64_to_cpu((*gpt)->last_usable_lba),\r\n(unsigned long long)lastlba);\r\ngoto fail;\r\n}\r\nif (le64_to_cpu((*gpt)->last_usable_lba) < le64_to_cpu((*gpt)->first_usable_lba)) {\r\npr_debug("GPT: last_usable_lba incorrect: %lld > %lld\n",\r\n(unsigned long long)le64_to_cpu((*gpt)->last_usable_lba),\r\n(unsigned long long)le64_to_cpu((*gpt)->first_usable_lba));\r\ngoto fail;\r\n}\r\nif (le32_to_cpu((*gpt)->sizeof_partition_entry) != sizeof(gpt_entry)) {\r\npr_debug("GUID Partitition Entry Size check failed.\n");\r\ngoto fail;\r\n}\r\nif (!(*ptes = alloc_read_gpt_entries(state, *gpt)))\r\ngoto fail;\r\ncrc = efi_crc32((const unsigned char *) (*ptes),\r\nle32_to_cpu((*gpt)->num_partition_entries) *\r\nle32_to_cpu((*gpt)->sizeof_partition_entry));\r\nif (crc != le32_to_cpu((*gpt)->partition_entry_array_crc32)) {\r\npr_debug("GUID Partitition Entry Array CRC check failed.\n");\r\ngoto fail_ptes;\r\n}\r\nreturn 1;\r\nfail_ptes:\r\nkfree(*ptes);\r\n*ptes = NULL;\r\nfail:\r\nkfree(*gpt);\r\n*gpt = NULL;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nis_pte_valid(const gpt_entry *pte, const u64 lastlba)\r\n{\r\nif ((!efi_guidcmp(pte->partition_type_guid, NULL_GUID)) ||\r\nle64_to_cpu(pte->starting_lba) > lastlba ||\r\nle64_to_cpu(pte->ending_lba) > lastlba)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void\r\ncompare_gpts(gpt_header *pgpt, gpt_header *agpt, u64 lastlba)\r\n{\r\nint error_found = 0;\r\nif (!pgpt || !agpt)\r\nreturn;\r\nif (le64_to_cpu(pgpt->my_lba) != le64_to_cpu(agpt->alternate_lba)) {\r\npr_warn("GPT:Primary header LBA != Alt. header alternate_lba\n");\r\npr_warn("GPT:%lld != %lld\n",\r\n(unsigned long long)le64_to_cpu(pgpt->my_lba),\r\n(unsigned long long)le64_to_cpu(agpt->alternate_lba));\r\nerror_found++;\r\n}\r\nif (le64_to_cpu(pgpt->alternate_lba) != le64_to_cpu(agpt->my_lba)) {\r\npr_warn("GPT:Primary header alternate_lba != Alt. header my_lba\n");\r\npr_warn("GPT:%lld != %lld\n",\r\n(unsigned long long)le64_to_cpu(pgpt->alternate_lba),\r\n(unsigned long long)le64_to_cpu(agpt->my_lba));\r\nerror_found++;\r\n}\r\nif (le64_to_cpu(pgpt->first_usable_lba) !=\r\nle64_to_cpu(agpt->first_usable_lba)) {\r\npr_warn("GPT:first_usable_lbas don't match.\n");\r\npr_warn("GPT:%lld != %lld\n",\r\n(unsigned long long)le64_to_cpu(pgpt->first_usable_lba),\r\n(unsigned long long)le64_to_cpu(agpt->first_usable_lba));\r\nerror_found++;\r\n}\r\nif (le64_to_cpu(pgpt->last_usable_lba) !=\r\nle64_to_cpu(agpt->last_usable_lba)) {\r\npr_warn("GPT:last_usable_lbas don't match.\n");\r\npr_warn("GPT:%lld != %lld\n",\r\n(unsigned long long)le64_to_cpu(pgpt->last_usable_lba),\r\n(unsigned long long)le64_to_cpu(agpt->last_usable_lba));\r\nerror_found++;\r\n}\r\nif (efi_guidcmp(pgpt->disk_guid, agpt->disk_guid)) {\r\npr_warn("GPT:disk_guids don't match.\n");\r\nerror_found++;\r\n}\r\nif (le32_to_cpu(pgpt->num_partition_entries) !=\r\nle32_to_cpu(agpt->num_partition_entries)) {\r\npr_warn("GPT:num_partition_entries don't match: "\r\n"0x%x != 0x%x\n",\r\nle32_to_cpu(pgpt->num_partition_entries),\r\nle32_to_cpu(agpt->num_partition_entries));\r\nerror_found++;\r\n}\r\nif (le32_to_cpu(pgpt->sizeof_partition_entry) !=\r\nle32_to_cpu(agpt->sizeof_partition_entry)) {\r\npr_warn("GPT:sizeof_partition_entry values don't match: "\r\n"0x%x != 0x%x\n",\r\nle32_to_cpu(pgpt->sizeof_partition_entry),\r\nle32_to_cpu(agpt->sizeof_partition_entry));\r\nerror_found++;\r\n}\r\nif (le32_to_cpu(pgpt->partition_entry_array_crc32) !=\r\nle32_to_cpu(agpt->partition_entry_array_crc32)) {\r\npr_warn("GPT:partition_entry_array_crc32 values don't match: "\r\n"0x%x != 0x%x\n",\r\nle32_to_cpu(pgpt->partition_entry_array_crc32),\r\nle32_to_cpu(agpt->partition_entry_array_crc32));\r\nerror_found++;\r\n}\r\nif (le64_to_cpu(pgpt->alternate_lba) != lastlba) {\r\npr_warn("GPT:Primary header thinks Alt. header is not at the end of the disk.\n");\r\npr_warn("GPT:%lld != %lld\n",\r\n(unsigned long long)le64_to_cpu(pgpt->alternate_lba),\r\n(unsigned long long)lastlba);\r\nerror_found++;\r\n}\r\nif (le64_to_cpu(agpt->my_lba) != lastlba) {\r\npr_warn("GPT:Alternate GPT header not at the end of the disk.\n");\r\npr_warn("GPT:%lld != %lld\n",\r\n(unsigned long long)le64_to_cpu(agpt->my_lba),\r\n(unsigned long long)lastlba);\r\nerror_found++;\r\n}\r\nif (error_found)\r\npr_warn("GPT: Use GNU Parted to correct GPT errors.\n");\r\nreturn;\r\n}\r\nstatic int find_valid_gpt(struct parsed_partitions *state, gpt_header **gpt,\r\ngpt_entry **ptes)\r\n{\r\nint good_pgpt = 0, good_agpt = 0, good_pmbr = 0;\r\ngpt_header *pgpt = NULL, *agpt = NULL;\r\ngpt_entry *pptes = NULL, *aptes = NULL;\r\nlegacy_mbr *legacymbr;\r\nsector_t total_sectors = i_size_read(state->bdev->bd_inode) >> 9;\r\nu64 lastlba;\r\nif (!ptes)\r\nreturn 0;\r\nlastlba = last_lba(state->bdev);\r\nif (!force_gpt) {\r\nlegacymbr = kzalloc(sizeof(*legacymbr), GFP_KERNEL);\r\nif (!legacymbr)\r\ngoto fail;\r\nread_lba(state, 0, (u8 *)legacymbr, sizeof(*legacymbr));\r\ngood_pmbr = is_pmbr_valid(legacymbr, total_sectors);\r\nkfree(legacymbr);\r\nif (!good_pmbr)\r\ngoto fail;\r\npr_debug("Device has a %s MBR\n",\r\ngood_pmbr == GPT_MBR_PROTECTIVE ?\r\n"protective" : "hybrid");\r\n}\r\ngood_pgpt = is_gpt_valid(state, GPT_PRIMARY_PARTITION_TABLE_LBA,\r\n&pgpt, &pptes);\r\nif (good_pgpt)\r\ngood_agpt = is_gpt_valid(state,\r\nle64_to_cpu(pgpt->alternate_lba),\r\n&agpt, &aptes);\r\nif (!good_agpt && force_gpt)\r\ngood_agpt = is_gpt_valid(state, lastlba, &agpt, &aptes);\r\nif (!good_pgpt && !good_agpt)\r\ngoto fail;\r\ncompare_gpts(pgpt, agpt, lastlba);\r\nif (good_pgpt) {\r\n*gpt = pgpt;\r\n*ptes = pptes;\r\nkfree(agpt);\r\nkfree(aptes);\r\nif (!good_agpt)\r\npr_warn("Alternate GPT is invalid, using primary GPT.\n");\r\nreturn 1;\r\n}\r\nelse if (good_agpt) {\r\n*gpt = agpt;\r\n*ptes = aptes;\r\nkfree(pgpt);\r\nkfree(pptes);\r\npr_warn("Primary GPT is invalid, using alternate GPT.\n");\r\nreturn 1;\r\n}\r\nfail:\r\nkfree(pgpt);\r\nkfree(agpt);\r\nkfree(pptes);\r\nkfree(aptes);\r\n*gpt = NULL;\r\n*ptes = NULL;\r\nreturn 0;\r\n}\r\nint efi_partition(struct parsed_partitions *state)\r\n{\r\ngpt_header *gpt = NULL;\r\ngpt_entry *ptes = NULL;\r\nu32 i;\r\nunsigned ssz = bdev_logical_block_size(state->bdev) / 512;\r\nif (!find_valid_gpt(state, &gpt, &ptes) || !gpt || !ptes) {\r\nkfree(gpt);\r\nkfree(ptes);\r\nreturn 0;\r\n}\r\npr_debug("GUID Partition Table is valid! Yea!\n");\r\nfor (i = 0; i < le32_to_cpu(gpt->num_partition_entries) && i < state->limit-1; i++) {\r\nstruct partition_meta_info *info;\r\nunsigned label_count = 0;\r\nunsigned label_max;\r\nu64 start = le64_to_cpu(ptes[i].starting_lba);\r\nu64 size = le64_to_cpu(ptes[i].ending_lba) -\r\nle64_to_cpu(ptes[i].starting_lba) + 1ULL;\r\nif (!is_pte_valid(&ptes[i], last_lba(state->bdev)))\r\ncontinue;\r\nput_partition(state, i+1, start * ssz, size * ssz);\r\nif (!efi_guidcmp(ptes[i].partition_type_guid, PARTITION_LINUX_RAID_GUID))\r\nstate->parts[i + 1].flags = ADDPART_FLAG_RAID;\r\ninfo = &state->parts[i + 1].info;\r\nefi_guid_unparse(&ptes[i].unique_partition_guid, info->uuid);\r\nlabel_max = min(ARRAY_SIZE(info->volname) - 1,\r\nARRAY_SIZE(ptes[i].partition_name));\r\ninfo->volname[label_max] = 0;\r\nwhile (label_count < label_max) {\r\nu8 c = ptes[i].partition_name[label_count] & 0xff;\r\nif (c && !isprint(c))\r\nc = '!';\r\ninfo->volname[label_count] = c;\r\nlabel_count++;\r\n}\r\nstate->parts[i + 1].has_info = true;\r\n}\r\nkfree(ptes);\r\nkfree(gpt);\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nreturn 1;\r\n}
