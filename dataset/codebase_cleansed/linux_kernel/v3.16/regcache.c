static int regcache_hw_init(struct regmap *map)\r\n{\r\nint i, j;\r\nint ret;\r\nint count;\r\nunsigned int val;\r\nvoid *tmp_buf;\r\nif (!map->num_reg_defaults_raw)\r\nreturn -EINVAL;\r\nif (!map->reg_defaults_raw) {\r\nu32 cache_bypass = map->cache_bypass;\r\ndev_warn(map->dev, "No cache defaults, reading back from HW\n");\r\nmap->cache_bypass = 1;\r\ntmp_buf = kmalloc(map->cache_size_raw, GFP_KERNEL);\r\nif (!tmp_buf)\r\nreturn -EINVAL;\r\nret = regmap_raw_read(map, 0, tmp_buf,\r\nmap->num_reg_defaults_raw);\r\nmap->cache_bypass = cache_bypass;\r\nif (ret < 0) {\r\nkfree(tmp_buf);\r\nreturn ret;\r\n}\r\nmap->reg_defaults_raw = tmp_buf;\r\nmap->cache_free = 1;\r\n}\r\nfor (count = 0, i = 0; i < map->num_reg_defaults_raw; i++) {\r\nval = regcache_get_val(map, map->reg_defaults_raw, i);\r\nif (regmap_volatile(map, i * map->reg_stride))\r\ncontinue;\r\ncount++;\r\n}\r\nmap->reg_defaults = kmalloc(count * sizeof(struct reg_default),\r\nGFP_KERNEL);\r\nif (!map->reg_defaults) {\r\nret = -ENOMEM;\r\ngoto err_free;\r\n}\r\nmap->num_reg_defaults = count;\r\nfor (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {\r\nval = regcache_get_val(map, map->reg_defaults_raw, i);\r\nif (regmap_volatile(map, i * map->reg_stride))\r\ncontinue;\r\nmap->reg_defaults[j].reg = i * map->reg_stride;\r\nmap->reg_defaults[j].def = val;\r\nj++;\r\n}\r\nreturn 0;\r\nerr_free:\r\nif (map->cache_free)\r\nkfree(map->reg_defaults_raw);\r\nreturn ret;\r\n}\r\nint regcache_init(struct regmap *map, const struct regmap_config *config)\r\n{\r\nint ret;\r\nint i;\r\nvoid *tmp_buf;\r\nfor (i = 0; i < config->num_reg_defaults; i++)\r\nif (config->reg_defaults[i].reg % map->reg_stride)\r\nreturn -EINVAL;\r\nif (map->cache_type == REGCACHE_NONE) {\r\nmap->cache_bypass = true;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cache_types); i++)\r\nif (cache_types[i]->type == map->cache_type)\r\nbreak;\r\nif (i == ARRAY_SIZE(cache_types)) {\r\ndev_err(map->dev, "Could not match compress type: %d\n",\r\nmap->cache_type);\r\nreturn -EINVAL;\r\n}\r\nmap->num_reg_defaults = config->num_reg_defaults;\r\nmap->num_reg_defaults_raw = config->num_reg_defaults_raw;\r\nmap->reg_defaults_raw = config->reg_defaults_raw;\r\nmap->cache_word_size = DIV_ROUND_UP(config->val_bits, 8);\r\nmap->cache_size_raw = map->cache_word_size * config->num_reg_defaults_raw;\r\nmap->cache = NULL;\r\nmap->cache_ops = cache_types[i];\r\nif (!map->cache_ops->read ||\r\n!map->cache_ops->write ||\r\n!map->cache_ops->name)\r\nreturn -EINVAL;\r\nif (config->reg_defaults) {\r\nif (!map->num_reg_defaults)\r\nreturn -EINVAL;\r\ntmp_buf = kmemdup(config->reg_defaults, map->num_reg_defaults *\r\nsizeof(struct reg_default), GFP_KERNEL);\r\nif (!tmp_buf)\r\nreturn -ENOMEM;\r\nmap->reg_defaults = tmp_buf;\r\n} else if (map->num_reg_defaults_raw) {\r\nret = regcache_hw_init(map);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!map->max_register)\r\nmap->max_register = map->num_reg_defaults_raw;\r\nif (map->cache_ops->init) {\r\ndev_dbg(map->dev, "Initializing %s cache\n",\r\nmap->cache_ops->name);\r\nret = map->cache_ops->init(map);\r\nif (ret)\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\nkfree(map->reg_defaults);\r\nif (map->cache_free)\r\nkfree(map->reg_defaults_raw);\r\nreturn ret;\r\n}\r\nvoid regcache_exit(struct regmap *map)\r\n{\r\nif (map->cache_type == REGCACHE_NONE)\r\nreturn;\r\nBUG_ON(!map->cache_ops);\r\nkfree(map->reg_defaults);\r\nif (map->cache_free)\r\nkfree(map->reg_defaults_raw);\r\nif (map->cache_ops->exit) {\r\ndev_dbg(map->dev, "Destroying %s cache\n",\r\nmap->cache_ops->name);\r\nmap->cache_ops->exit(map);\r\n}\r\n}\r\nint regcache_read(struct regmap *map,\r\nunsigned int reg, unsigned int *value)\r\n{\r\nint ret;\r\nif (map->cache_type == REGCACHE_NONE)\r\nreturn -ENOSYS;\r\nBUG_ON(!map->cache_ops);\r\nif (!regmap_volatile(map, reg)) {\r\nret = map->cache_ops->read(map, reg, value);\r\nif (ret == 0)\r\ntrace_regmap_reg_read_cache(map->dev, reg, *value);\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint regcache_write(struct regmap *map,\r\nunsigned int reg, unsigned int value)\r\n{\r\nif (map->cache_type == REGCACHE_NONE)\r\nreturn 0;\r\nBUG_ON(!map->cache_ops);\r\nif (!regmap_volatile(map, reg))\r\nreturn map->cache_ops->write(map, reg, value);\r\nreturn 0;\r\n}\r\nstatic int regcache_default_sync(struct regmap *map, unsigned int min,\r\nunsigned int max)\r\n{\r\nunsigned int reg;\r\nfor (reg = min; reg <= max; reg += map->reg_stride) {\r\nunsigned int val;\r\nint ret;\r\nif (regmap_volatile(map, reg) ||\r\n!regmap_writeable(map, reg))\r\ncontinue;\r\nret = regcache_read(map, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nret = regcache_lookup_reg(map, reg);\r\nif (ret >= 0 && val == map->reg_defaults[ret].def)\r\ncontinue;\r\nmap->cache_bypass = 1;\r\nret = _regmap_write(map, reg, val);\r\nmap->cache_bypass = 0;\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(map->dev, "Synced register %#x, value %#x\n", reg, val);\r\n}\r\nreturn 0;\r\n}\r\nint regcache_sync(struct regmap *map)\r\n{\r\nint ret = 0;\r\nunsigned int i;\r\nconst char *name;\r\nunsigned int bypass;\r\nBUG_ON(!map->cache_ops);\r\nmap->lock(map->lock_arg);\r\nbypass = map->cache_bypass;\r\ndev_dbg(map->dev, "Syncing %s cache\n",\r\nmap->cache_ops->name);\r\nname = map->cache_ops->name;\r\ntrace_regcache_sync(map->dev, name, "start");\r\nif (!map->cache_dirty)\r\ngoto out;\r\nmap->async = true;\r\nmap->cache_bypass = 1;\r\nfor (i = 0; i < map->patch_regs; i++) {\r\nret = _regmap_write(map, map->patch[i].reg, map->patch[i].def);\r\nif (ret != 0) {\r\ndev_err(map->dev, "Failed to write %x = %x: %d\n",\r\nmap->patch[i].reg, map->patch[i].def, ret);\r\ngoto out;\r\n}\r\n}\r\nmap->cache_bypass = 0;\r\nif (map->cache_ops->sync)\r\nret = map->cache_ops->sync(map, 0, map->max_register);\r\nelse\r\nret = regcache_default_sync(map, 0, map->max_register);\r\nif (ret == 0)\r\nmap->cache_dirty = false;\r\nout:\r\nmap->async = false;\r\nmap->cache_bypass = bypass;\r\nmap->unlock(map->lock_arg);\r\nregmap_async_complete(map);\r\ntrace_regcache_sync(map->dev, name, "stop");\r\nreturn ret;\r\n}\r\nint regcache_sync_region(struct regmap *map, unsigned int min,\r\nunsigned int max)\r\n{\r\nint ret = 0;\r\nconst char *name;\r\nunsigned int bypass;\r\nBUG_ON(!map->cache_ops);\r\nmap->lock(map->lock_arg);\r\nbypass = map->cache_bypass;\r\nname = map->cache_ops->name;\r\ndev_dbg(map->dev, "Syncing %s cache from %d-%d\n", name, min, max);\r\ntrace_regcache_sync(map->dev, name, "start region");\r\nif (!map->cache_dirty)\r\ngoto out;\r\nmap->async = true;\r\nif (map->cache_ops->sync)\r\nret = map->cache_ops->sync(map, min, max);\r\nelse\r\nret = regcache_default_sync(map, min, max);\r\nout:\r\nmap->cache_bypass = bypass;\r\nmap->async = false;\r\nmap->unlock(map->lock_arg);\r\nregmap_async_complete(map);\r\ntrace_regcache_sync(map->dev, name, "stop region");\r\nreturn ret;\r\n}\r\nint regcache_drop_region(struct regmap *map, unsigned int min,\r\nunsigned int max)\r\n{\r\nint ret = 0;\r\nif (!map->cache_ops || !map->cache_ops->drop)\r\nreturn -EINVAL;\r\nmap->lock(map->lock_arg);\r\ntrace_regcache_drop_region(map->dev, min, max);\r\nret = map->cache_ops->drop(map, min, max);\r\nmap->unlock(map->lock_arg);\r\nreturn ret;\r\n}\r\nvoid regcache_cache_only(struct regmap *map, bool enable)\r\n{\r\nmap->lock(map->lock_arg);\r\nWARN_ON(map->cache_bypass && enable);\r\nmap->cache_only = enable;\r\ntrace_regmap_cache_only(map->dev, enable);\r\nmap->unlock(map->lock_arg);\r\n}\r\nvoid regcache_mark_dirty(struct regmap *map)\r\n{\r\nmap->lock(map->lock_arg);\r\nmap->cache_dirty = true;\r\nmap->unlock(map->lock_arg);\r\n}\r\nvoid regcache_cache_bypass(struct regmap *map, bool enable)\r\n{\r\nmap->lock(map->lock_arg);\r\nWARN_ON(map->cache_only && enable);\r\nmap->cache_bypass = enable;\r\ntrace_regmap_cache_bypass(map->dev, enable);\r\nmap->unlock(map->lock_arg);\r\n}\r\nbool regcache_set_val(struct regmap *map, void *base, unsigned int idx,\r\nunsigned int val)\r\n{\r\nif (regcache_get_val(map, base, idx) == val)\r\nreturn true;\r\nif (map->format.format_val) {\r\nmap->format.format_val(base + (map->cache_word_size * idx),\r\nval, 0);\r\nreturn false;\r\n}\r\nswitch (map->cache_word_size) {\r\ncase 1: {\r\nu8 *cache = base;\r\ncache[idx] = val;\r\nbreak;\r\n}\r\ncase 2: {\r\nu16 *cache = base;\r\ncache[idx] = val;\r\nbreak;\r\n}\r\ncase 4: {\r\nu32 *cache = base;\r\ncache[idx] = val;\r\nbreak;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn false;\r\n}\r\nunsigned int regcache_get_val(struct regmap *map, const void *base,\r\nunsigned int idx)\r\n{\r\nif (!base)\r\nreturn -EINVAL;\r\nif (map->format.parse_val)\r\nreturn map->format.parse_val(regcache_get_val_addr(map, base,\r\nidx));\r\nswitch (map->cache_word_size) {\r\ncase 1: {\r\nconst u8 *cache = base;\r\nreturn cache[idx];\r\n}\r\ncase 2: {\r\nconst u16 *cache = base;\r\nreturn cache[idx];\r\n}\r\ncase 4: {\r\nconst u32 *cache = base;\r\nreturn cache[idx];\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn -1;\r\n}\r\nstatic int regcache_default_cmp(const void *a, const void *b)\r\n{\r\nconst struct reg_default *_a = a;\r\nconst struct reg_default *_b = b;\r\nreturn _a->reg - _b->reg;\r\n}\r\nint regcache_lookup_reg(struct regmap *map, unsigned int reg)\r\n{\r\nstruct reg_default key;\r\nstruct reg_default *r;\r\nkey.reg = reg;\r\nkey.def = 0;\r\nr = bsearch(&key, map->reg_defaults, map->num_reg_defaults,\r\nsizeof(struct reg_default), regcache_default_cmp);\r\nif (r)\r\nreturn r - map->reg_defaults;\r\nelse\r\nreturn -ENOENT;\r\n}\r\nstatic bool regcache_reg_present(unsigned long *cache_present, unsigned int idx)\r\n{\r\nif (!cache_present)\r\nreturn true;\r\nreturn test_bit(idx, cache_present);\r\n}\r\nstatic int regcache_sync_block_single(struct regmap *map, void *block,\r\nunsigned long *cache_present,\r\nunsigned int block_base,\r\nunsigned int start, unsigned int end)\r\n{\r\nunsigned int i, regtmp, val;\r\nint ret;\r\nfor (i = start; i < end; i++) {\r\nregtmp = block_base + (i * map->reg_stride);\r\nif (!regcache_reg_present(cache_present, i))\r\ncontinue;\r\nval = regcache_get_val(map, block, i);\r\nret = regcache_lookup_reg(map, regtmp);\r\nif (ret >= 0 && val == map->reg_defaults[ret].def)\r\ncontinue;\r\nmap->cache_bypass = 1;\r\nret = _regmap_write(map, regtmp, val);\r\nmap->cache_bypass = 0;\r\nif (ret != 0)\r\nreturn ret;\r\ndev_dbg(map->dev, "Synced register %#x, value %#x\n",\r\nregtmp, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int regcache_sync_block_raw_flush(struct regmap *map, const void **data,\r\nunsigned int base, unsigned int cur)\r\n{\r\nsize_t val_bytes = map->format.val_bytes;\r\nint ret, count;\r\nif (*data == NULL)\r\nreturn 0;\r\ncount = (cur - base) / map->reg_stride;\r\ndev_dbg(map->dev, "Writing %zu bytes for %d registers from 0x%x-0x%x\n",\r\ncount * val_bytes, count, base, cur - map->reg_stride);\r\nmap->cache_bypass = 1;\r\nret = _regmap_raw_write(map, base, *data, count * val_bytes);\r\nmap->cache_bypass = 0;\r\n*data = NULL;\r\nreturn ret;\r\n}\r\nstatic int regcache_sync_block_raw(struct regmap *map, void *block,\r\nunsigned long *cache_present,\r\nunsigned int block_base, unsigned int start,\r\nunsigned int end)\r\n{\r\nunsigned int i, val;\r\nunsigned int regtmp = 0;\r\nunsigned int base = 0;\r\nconst void *data = NULL;\r\nint ret;\r\nfor (i = start; i < end; i++) {\r\nregtmp = block_base + (i * map->reg_stride);\r\nif (!regcache_reg_present(cache_present, i)) {\r\nret = regcache_sync_block_raw_flush(map, &data,\r\nbase, regtmp);\r\nif (ret != 0)\r\nreturn ret;\r\ncontinue;\r\n}\r\nval = regcache_get_val(map, block, i);\r\nret = regcache_lookup_reg(map, regtmp);\r\nif (ret >= 0 && val == map->reg_defaults[ret].def) {\r\nret = regcache_sync_block_raw_flush(map, &data,\r\nbase, regtmp);\r\nif (ret != 0)\r\nreturn ret;\r\ncontinue;\r\n}\r\nif (!data) {\r\ndata = regcache_get_val_addr(map, block, i);\r\nbase = regtmp;\r\n}\r\n}\r\nreturn regcache_sync_block_raw_flush(map, &data, base, regtmp +\r\nmap->reg_stride);\r\n}\r\nint regcache_sync_block(struct regmap *map, void *block,\r\nunsigned long *cache_present,\r\nunsigned int block_base, unsigned int start,\r\nunsigned int end)\r\n{\r\nif (regmap_can_raw_write(map))\r\nreturn regcache_sync_block_raw(map, block, cache_present,\r\nblock_base, start, end);\r\nelse\r\nreturn regcache_sync_block_single(map, block, cache_present,\r\nblock_base, start, end);\r\n}
