u32 prandom_u32_state(struct rnd_state *state)\r\n{\r\n#define TAUSWORTHE(s,a,b,c,d) ((s&c)<<d) ^ (((s <<a) ^ s)>>b)\r\nstate->s1 = TAUSWORTHE(state->s1, 6U, 13U, 4294967294U, 18U);\r\nstate->s2 = TAUSWORTHE(state->s2, 2U, 27U, 4294967288U, 2U);\r\nstate->s3 = TAUSWORTHE(state->s3, 13U, 21U, 4294967280U, 7U);\r\nstate->s4 = TAUSWORTHE(state->s4, 3U, 12U, 4294967168U, 13U);\r\nreturn (state->s1 ^ state->s2 ^ state->s3 ^ state->s4);\r\n}\r\nu32 prandom_u32(void)\r\n{\r\nstruct rnd_state *state = &get_cpu_var(net_rand_state);\r\nu32 res;\r\nres = prandom_u32_state(state);\r\nput_cpu_var(state);\r\nreturn res;\r\n}\r\nvoid prandom_bytes_state(struct rnd_state *state, void *buf, int bytes)\r\n{\r\nunsigned char *p = buf;\r\nint i;\r\nfor (i = 0; i < round_down(bytes, sizeof(u32)); i += sizeof(u32)) {\r\nu32 random = prandom_u32_state(state);\r\nint j;\r\nfor (j = 0; j < sizeof(u32); j++) {\r\np[i + j] = random;\r\nrandom >>= BITS_PER_BYTE;\r\n}\r\n}\r\nif (i < bytes) {\r\nu32 random = prandom_u32_state(state);\r\nfor (; i < bytes; i++) {\r\np[i] = random;\r\nrandom >>= BITS_PER_BYTE;\r\n}\r\n}\r\n}\r\nvoid prandom_bytes(void *buf, int bytes)\r\n{\r\nstruct rnd_state *state = &get_cpu_var(net_rand_state);\r\nprandom_bytes_state(state, buf, bytes);\r\nput_cpu_var(state);\r\n}\r\nstatic void prandom_warmup(struct rnd_state *state)\r\n{\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\n}\r\nstatic void prandom_seed_very_weak(struct rnd_state *state, u32 seed)\r\n{\r\n#define LCG(x) ((x) * 69069U)\r\nstate->s1 = __seed(LCG(seed), 2U);\r\nstate->s2 = __seed(LCG(state->s1), 8U);\r\nstate->s3 = __seed(LCG(state->s2), 16U);\r\nstate->s4 = __seed(LCG(state->s3), 128U);\r\n}\r\nvoid prandom_seed(u32 entropy)\r\n{\r\nint i;\r\nfor_each_possible_cpu (i) {\r\nstruct rnd_state *state = &per_cpu(net_rand_state, i);\r\nstate->s1 = __seed(state->s1 ^ entropy, 2U);\r\nprandom_warmup(state);\r\n}\r\n}\r\nstatic int __init prandom_init(void)\r\n{\r\nint i;\r\n#ifdef CONFIG_RANDOM32_SELFTEST\r\nprandom_state_selftest();\r\n#endif\r\nfor_each_possible_cpu(i) {\r\nstruct rnd_state *state = &per_cpu(net_rand_state,i);\r\nprandom_seed_very_weak(state, (i + jiffies) ^ random_get_entropy());\r\nprandom_warmup(state);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __prandom_timer(unsigned long dontcare)\r\n{\r\nu32 entropy;\r\nunsigned long expires;\r\nget_random_bytes(&entropy, sizeof(entropy));\r\nprandom_seed(entropy);\r\nexpires = 40 + (prandom_u32() % 40);\r\nseed_timer.expires = jiffies + msecs_to_jiffies(expires * MSEC_PER_SEC);\r\nadd_timer(&seed_timer);\r\n}\r\nstatic void __init __prandom_start_seed_timer(void)\r\n{\r\nset_timer_slack(&seed_timer, HZ);\r\nseed_timer.expires = jiffies + msecs_to_jiffies(40 * MSEC_PER_SEC);\r\nadd_timer(&seed_timer);\r\n}\r\nstatic void __prandom_reseed(bool late)\r\n{\r\nint i;\r\nunsigned long flags;\r\nstatic bool latch = false;\r\nstatic DEFINE_SPINLOCK(lock);\r\nif (!spin_trylock_irqsave(&lock, flags))\r\nreturn;\r\nif (latch && !late)\r\ngoto out;\r\nlatch = true;\r\nfor_each_possible_cpu(i) {\r\nstruct rnd_state *state = &per_cpu(net_rand_state,i);\r\nu32 seeds[4];\r\nget_random_bytes(&seeds, sizeof(seeds));\r\nstate->s1 = __seed(seeds[0], 2U);\r\nstate->s2 = __seed(seeds[1], 8U);\r\nstate->s3 = __seed(seeds[2], 16U);\r\nstate->s4 = __seed(seeds[3], 128U);\r\nprandom_warmup(state);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&lock, flags);\r\n}\r\nvoid prandom_reseed_late(void)\r\n{\r\n__prandom_reseed(true);\r\n}\r\nstatic int __init prandom_reseed(void)\r\n{\r\n__prandom_reseed(false);\r\n__prandom_start_seed_timer();\r\nreturn 0;\r\n}\r\nstatic void __init prandom_state_selftest(void)\r\n{\r\nint i, j, errors = 0, runs = 0;\r\nbool error = false;\r\nfor (i = 0; i < ARRAY_SIZE(test1); i++) {\r\nstruct rnd_state state;\r\nprandom_seed_very_weak(&state, test1[i].seed);\r\nprandom_warmup(&state);\r\nif (test1[i].result != prandom_u32_state(&state))\r\nerror = true;\r\n}\r\nif (error)\r\npr_warn("prandom: seed boundary self test failed\n");\r\nelse\r\npr_info("prandom: seed boundary self test passed\n");\r\nfor (i = 0; i < ARRAY_SIZE(test2); i++) {\r\nstruct rnd_state state;\r\nprandom_seed_very_weak(&state, test2[i].seed);\r\nprandom_warmup(&state);\r\nfor (j = 0; j < test2[i].iteration - 1; j++)\r\nprandom_u32_state(&state);\r\nif (test2[i].result != prandom_u32_state(&state))\r\nerrors++;\r\nruns++;\r\ncond_resched();\r\n}\r\nif (errors)\r\npr_warn("prandom: %d/%d self tests failed\n", errors, runs);\r\nelse\r\npr_info("prandom: %d self tests passed\n", runs);\r\n}
