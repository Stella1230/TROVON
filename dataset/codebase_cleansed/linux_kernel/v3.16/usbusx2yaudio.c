static int usX2Y_urb_capt_retire(struct snd_usX2Y_substream *subs)\r\n{\r\nstruct urb *urb = subs->completed_urb;\r\nstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\r\nunsigned char *cp;\r\nint i, len, lens = 0, hwptr_done = subs->hwptr_done;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nfor (i = 0; i < nr_of_packs(); i++) {\r\ncp = (unsigned char*)urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nif (urb->iso_frame_desc[i].status) {\r\nsnd_printk(KERN_ERR "active frame status %i. "\r\n"Most probably some hardware problem.\n",\r\nurb->iso_frame_desc[i].status);\r\nreturn urb->iso_frame_desc[i].status;\r\n}\r\nlen = urb->iso_frame_desc[i].actual_length / usX2Y->stride;\r\nif (! len) {\r\nsnd_printd("0 == len ERROR!\n");\r\ncontinue;\r\n}\r\nif ((hwptr_done + len) > runtime->buffer_size) {\r\nint cnt = runtime->buffer_size - hwptr_done;\r\nint blen = cnt * usX2Y->stride;\r\nmemcpy(runtime->dma_area + hwptr_done * usX2Y->stride, cp, blen);\r\nmemcpy(runtime->dma_area, cp + blen, len * usX2Y->stride - blen);\r\n} else {\r\nmemcpy(runtime->dma_area + hwptr_done * usX2Y->stride, cp,\r\nlen * usX2Y->stride);\r\n}\r\nlens += len;\r\nif ((hwptr_done += len) >= runtime->buffer_size)\r\nhwptr_done -= runtime->buffer_size;\r\n}\r\nsubs->hwptr_done = hwptr_done;\r\nsubs->transfer_done += lens;\r\nif (subs->transfer_done >= runtime->period_size) {\r\nsubs->transfer_done -= runtime->period_size;\r\nsnd_pcm_period_elapsed(subs->pcm_substream);\r\n}\r\nreturn 0;\r\n}\r\nstatic int usX2Y_urb_play_prepare(struct snd_usX2Y_substream *subs,\r\nstruct urb *cap_urb,\r\nstruct urb *urb)\r\n{\r\nint count, counts, pack;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\r\ncount = 0;\r\nfor (pack = 0; pack < nr_of_packs(); pack++) {\r\ncounts = cap_urb->iso_frame_desc[pack].actual_length / usX2Y->stride;\r\ncount += counts;\r\nif (counts < 43 || counts > 50) {\r\nsnd_printk(KERN_ERR "should not be here with counts=%i\n", counts);\r\nreturn -EPIPE;\r\n}\r\nurb->iso_frame_desc[pack].offset = pack ?\r\nurb->iso_frame_desc[pack - 1].offset +\r\nurb->iso_frame_desc[pack - 1].length :\r\n0;\r\nurb->iso_frame_desc[pack].length = cap_urb->iso_frame_desc[pack].actual_length;\r\n}\r\nif (atomic_read(&subs->state) >= state_PRERUNNING)\r\nif (subs->hwptr + count > runtime->buffer_size) {\r\nint len;\r\nlen = runtime->buffer_size - subs->hwptr;\r\nurb->transfer_buffer = subs->tmpbuf;\r\nmemcpy(subs->tmpbuf, runtime->dma_area +\r\nsubs->hwptr * usX2Y->stride, len * usX2Y->stride);\r\nmemcpy(subs->tmpbuf + len * usX2Y->stride,\r\nruntime->dma_area, (count - len) * usX2Y->stride);\r\nsubs->hwptr += count;\r\nsubs->hwptr -= runtime->buffer_size;\r\n} else {\r\nurb->transfer_buffer = runtime->dma_area + subs->hwptr * usX2Y->stride;\r\nif ((subs->hwptr += count) >= runtime->buffer_size)\r\nsubs->hwptr -= runtime->buffer_size;\r\n}\r\nelse\r\nurb->transfer_buffer = subs->tmpbuf;\r\nurb->transfer_buffer_length = count * usX2Y->stride;\r\nreturn 0;\r\n}\r\nstatic void usX2Y_urb_play_retire(struct snd_usX2Y_substream *subs, struct urb *urb)\r\n{\r\nstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\r\nint len = urb->actual_length / subs->usX2Y->stride;\r\nsubs->transfer_done += len;\r\nsubs->hwptr_done += len;\r\nif (subs->hwptr_done >= runtime->buffer_size)\r\nsubs->hwptr_done -= runtime->buffer_size;\r\nif (subs->transfer_done >= runtime->period_size) {\r\nsubs->transfer_done -= runtime->period_size;\r\nsnd_pcm_period_elapsed(subs->pcm_substream);\r\n}\r\n}\r\nstatic int usX2Y_urb_submit(struct snd_usX2Y_substream *subs, struct urb *urb, int frame)\r\n{\r\nint err;\r\nif (!urb)\r\nreturn -ENODEV;\r\nurb->start_frame = (frame + NRURBS * nr_of_packs());\r\nurb->hcpriv = NULL;\r\nurb->dev = subs->usX2Y->dev;\r\nif ((err = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\r\nsnd_printk(KERN_ERR "usb_submit_urb() returned %i\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int usX2Y_usbframe_complete(struct snd_usX2Y_substream *capsubs,\r\nstruct snd_usX2Y_substream *playbacksubs,\r\nint frame)\r\n{\r\nint err, state;\r\nstruct urb *urb = playbacksubs->completed_urb;\r\nstate = atomic_read(&playbacksubs->state);\r\nif (NULL != urb) {\r\nif (state == state_RUNNING)\r\nusX2Y_urb_play_retire(playbacksubs, urb);\r\nelse if (state >= state_PRERUNNING)\r\natomic_inc(&playbacksubs->state);\r\n} else {\r\nswitch (state) {\r\ncase state_STARTING1:\r\nurb = playbacksubs->urb[0];\r\natomic_inc(&playbacksubs->state);\r\nbreak;\r\ncase state_STARTING2:\r\nurb = playbacksubs->urb[1];\r\natomic_inc(&playbacksubs->state);\r\nbreak;\r\n}\r\n}\r\nif (urb) {\r\nif ((err = usX2Y_urb_play_prepare(playbacksubs, capsubs->completed_urb, urb)) ||\r\n(err = usX2Y_urb_submit(playbacksubs, urb, frame))) {\r\nreturn err;\r\n}\r\n}\r\nplaybacksubs->completed_urb = NULL;\r\nstate = atomic_read(&capsubs->state);\r\nif (state >= state_PREPARED) {\r\nif (state == state_RUNNING) {\r\nif ((err = usX2Y_urb_capt_retire(capsubs)))\r\nreturn err;\r\n} else if (state >= state_PRERUNNING)\r\natomic_inc(&capsubs->state);\r\nif ((err = usX2Y_urb_submit(capsubs, capsubs->completed_urb, frame)))\r\nreturn err;\r\n}\r\ncapsubs->completed_urb = NULL;\r\nreturn 0;\r\n}\r\nstatic void usX2Y_clients_stop(struct usX2Ydev *usX2Y)\r\n{\r\nint s, u;\r\nfor (s = 0; s < 4; s++) {\r\nstruct snd_usX2Y_substream *subs = usX2Y->subs[s];\r\nif (subs) {\r\nsnd_printdd("%i %p state=%i\n", s, subs, atomic_read(&subs->state));\r\natomic_set(&subs->state, state_STOPPED);\r\n}\r\n}\r\nfor (s = 0; s < 4; s++) {\r\nstruct snd_usX2Y_substream *subs = usX2Y->subs[s];\r\nif (subs) {\r\nif (atomic_read(&subs->state) >= state_PRERUNNING) {\r\nunsigned long flags;\r\nsnd_pcm_stream_lock_irqsave(subs->pcm_substream, flags);\r\nsnd_pcm_stop(subs->pcm_substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irqrestore(subs->pcm_substream, flags);\r\n}\r\nfor (u = 0; u < NRURBS; u++) {\r\nstruct urb *urb = subs->urb[u];\r\nif (NULL != urb)\r\nsnd_printdd("%i status=%i start_frame=%i\n",\r\nu, urb->status, urb->start_frame);\r\n}\r\n}\r\n}\r\nusX2Y->prepare_subs = NULL;\r\nwake_up(&usX2Y->prepare_wait_queue);\r\n}\r\nstatic void usX2Y_error_urb_status(struct usX2Ydev *usX2Y,\r\nstruct snd_usX2Y_substream *subs, struct urb *urb)\r\n{\r\nsnd_printk(KERN_ERR "ep=%i stalled with status=%i\n", subs->endpoint, urb->status);\r\nurb->status = 0;\r\nusX2Y_clients_stop(usX2Y);\r\n}\r\nstatic void i_usX2Y_urb_complete(struct urb *urb)\r\n{\r\nstruct snd_usX2Y_substream *subs = urb->context;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nif (unlikely(atomic_read(&subs->state) < state_PREPARED)) {\r\nsnd_printdd("hcd_frame=%i ep=%i%s status=%i start_frame=%i\n",\r\nusb_get_current_frame_number(usX2Y->dev),\r\nsubs->endpoint, usb_pipein(urb->pipe) ? "in" : "out",\r\nurb->status, urb->start_frame);\r\nreturn;\r\n}\r\nif (unlikely(urb->status)) {\r\nusX2Y_error_urb_status(usX2Y, subs, urb);\r\nreturn;\r\n}\r\nsubs->completed_urb = urb;\r\n{\r\nstruct snd_usX2Y_substream *capsubs = usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE],\r\n*playbacksubs = usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (capsubs->completed_urb &&\r\natomic_read(&capsubs->state) >= state_PREPARED &&\r\n(playbacksubs->completed_urb ||\r\natomic_read(&playbacksubs->state) < state_PREPARED)) {\r\nif (!usX2Y_usbframe_complete(capsubs, playbacksubs, urb->start_frame))\r\nusX2Y->wait_iso_frame += nr_of_packs();\r\nelse {\r\nsnd_printdd("\n");\r\nusX2Y_clients_stop(usX2Y);\r\n}\r\n}\r\n}\r\n}\r\nstatic void usX2Y_urbs_set_complete(struct usX2Ydev * usX2Y,\r\nvoid (*complete)(struct urb *))\r\n{\r\nint s, u;\r\nfor (s = 0; s < 4; s++) {\r\nstruct snd_usX2Y_substream *subs = usX2Y->subs[s];\r\nif (NULL != subs)\r\nfor (u = 0; u < NRURBS; u++) {\r\nstruct urb * urb = subs->urb[u];\r\nif (NULL != urb)\r\nurb->complete = complete;\r\n}\r\n}\r\n}\r\nstatic void usX2Y_subs_startup_finish(struct usX2Ydev * usX2Y)\r\n{\r\nusX2Y_urbs_set_complete(usX2Y, i_usX2Y_urb_complete);\r\nusX2Y->prepare_subs = NULL;\r\n}\r\nstatic void i_usX2Y_subs_startup(struct urb *urb)\r\n{\r\nstruct snd_usX2Y_substream *subs = urb->context;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nstruct snd_usX2Y_substream *prepare_subs = usX2Y->prepare_subs;\r\nif (NULL != prepare_subs)\r\nif (urb->start_frame == prepare_subs->urb[0]->start_frame) {\r\nusX2Y_subs_startup_finish(usX2Y);\r\natomic_inc(&prepare_subs->state);\r\nwake_up(&usX2Y->prepare_wait_queue);\r\n}\r\ni_usX2Y_urb_complete(urb);\r\n}\r\nstatic void usX2Y_subs_prepare(struct snd_usX2Y_substream *subs)\r\n{\r\nsnd_printdd("usX2Y_substream_prepare(%p) ep=%i urb0=%p urb1=%p\n",\r\nsubs, subs->endpoint, subs->urb[0], subs->urb[1]);\r\nsubs->hwptr = 0;\r\nsubs->hwptr_done = 0;\r\nsubs->transfer_done = 0;\r\n}\r\nstatic void usX2Y_urb_release(struct urb **urb, int free_tb)\r\n{\r\nif (*urb) {\r\nusb_kill_urb(*urb);\r\nif (free_tb)\r\nkfree((*urb)->transfer_buffer);\r\nusb_free_urb(*urb);\r\n*urb = NULL;\r\n}\r\n}\r\nstatic void usX2Y_urbs_release(struct snd_usX2Y_substream *subs)\r\n{\r\nint i;\r\nsnd_printdd("usX2Y_urbs_release() %i\n", subs->endpoint);\r\nfor (i = 0; i < NRURBS; i++)\r\nusX2Y_urb_release(subs->urb + i,\r\nsubs != subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK]);\r\nkfree(subs->tmpbuf);\r\nsubs->tmpbuf = NULL;\r\n}\r\nstatic int usX2Y_urbs_allocate(struct snd_usX2Y_substream *subs)\r\n{\r\nint i;\r\nunsigned int pipe;\r\nint is_playback = subs == subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];\r\nstruct usb_device *dev = subs->usX2Y->dev;\r\npipe = is_playback ? usb_sndisocpipe(dev, subs->endpoint) :\r\nusb_rcvisocpipe(dev, subs->endpoint);\r\nsubs->maxpacksize = usb_maxpacket(dev, pipe, is_playback);\r\nif (!subs->maxpacksize)\r\nreturn -EINVAL;\r\nif (is_playback && NULL == subs->tmpbuf) {\r\nsubs->tmpbuf = kcalloc(nr_of_packs(), subs->maxpacksize, GFP_KERNEL);\r\nif (NULL == subs->tmpbuf) {\r\nsnd_printk(KERN_ERR "cannot malloc tmpbuf\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (i = 0; i < NRURBS; i++) {\r\nstruct urb **purb = subs->urb + i;\r\nif (*purb) {\r\nusb_kill_urb(*purb);\r\ncontinue;\r\n}\r\n*purb = usb_alloc_urb(nr_of_packs(), GFP_KERNEL);\r\nif (NULL == *purb) {\r\nusX2Y_urbs_release(subs);\r\nreturn -ENOMEM;\r\n}\r\nif (!is_playback && !(*purb)->transfer_buffer) {\r\n(*purb)->transfer_buffer = kmalloc(subs->maxpacksize * nr_of_packs(), GFP_KERNEL);\r\nif (NULL == (*purb)->transfer_buffer) {\r\nusX2Y_urbs_release(subs);\r\nreturn -ENOMEM;\r\n}\r\n}\r\n(*purb)->dev = dev;\r\n(*purb)->pipe = pipe;\r\n(*purb)->number_of_packets = nr_of_packs();\r\n(*purb)->context = subs;\r\n(*purb)->interval = 1;\r\n(*purb)->complete = i_usX2Y_subs_startup;\r\n}\r\nreturn 0;\r\n}\r\nstatic void usX2Y_subs_startup(struct snd_usX2Y_substream *subs)\r\n{\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nusX2Y->prepare_subs = subs;\r\nsubs->urb[0]->start_frame = -1;\r\nwmb();\r\nusX2Y_urbs_set_complete(usX2Y, i_usX2Y_subs_startup);\r\n}\r\nstatic int usX2Y_urbs_start(struct snd_usX2Y_substream *subs)\r\n{\r\nint i, err;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nif ((err = usX2Y_urbs_allocate(subs)) < 0)\r\nreturn err;\r\nsubs->completed_urb = NULL;\r\nfor (i = 0; i < 4; i++) {\r\nstruct snd_usX2Y_substream *subs = usX2Y->subs[i];\r\nif (subs != NULL && atomic_read(&subs->state) >= state_PREPARED)\r\ngoto start;\r\n}\r\nstart:\r\nusX2Y_subs_startup(subs);\r\nfor (i = 0; i < NRURBS; i++) {\r\nstruct urb *urb = subs->urb[i];\r\nif (usb_pipein(urb->pipe)) {\r\nunsigned long pack;\r\nif (0 == i)\r\natomic_set(&subs->state, state_STARTING3);\r\nurb->dev = usX2Y->dev;\r\nfor (pack = 0; pack < nr_of_packs(); pack++) {\r\nurb->iso_frame_desc[pack].offset = subs->maxpacksize * pack;\r\nurb->iso_frame_desc[pack].length = subs->maxpacksize;\r\n}\r\nurb->transfer_buffer_length = subs->maxpacksize * nr_of_packs();\r\nif ((err = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\r\nsnd_printk (KERN_ERR "cannot submit datapipe for urb %d, err = %d\n", i, err);\r\nerr = -EPIPE;\r\ngoto cleanup;\r\n} else\r\nif (i == 0)\r\nusX2Y->wait_iso_frame = urb->start_frame;\r\nurb->transfer_flags = 0;\r\n} else {\r\natomic_set(&subs->state, state_STARTING1);\r\nbreak;\r\n}\r\n}\r\nerr = 0;\r\nwait_event(usX2Y->prepare_wait_queue, NULL == usX2Y->prepare_subs);\r\nif (atomic_read(&subs->state) != state_PREPARED)\r\nerr = -EPIPE;\r\ncleanup:\r\nif (err) {\r\nusX2Y_subs_startup_finish(usX2Y);\r\nusX2Y_clients_stop(usX2Y);\r\n}\r\nreturn err;\r\n}\r\nstatic snd_pcm_uframes_t snd_usX2Y_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_usX2Y_substream *subs = substream->runtime->private_data;\r\nreturn subs->hwptr_done;\r\n}\r\nstatic int snd_usX2Y_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_usX2Y_substream *subs = substream->runtime->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_printdd("snd_usX2Y_pcm_trigger(START)\n");\r\nif (atomic_read(&subs->state) == state_PREPARED &&\r\natomic_read(&subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE]->state) >= state_PREPARED) {\r\natomic_set(&subs->state, state_PRERUNNING);\r\n} else {\r\nsnd_printdd("\n");\r\nreturn -EPIPE;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nsnd_printdd("snd_usX2Y_pcm_trigger(STOP)\n");\r\nif (atomic_read(&subs->state) >= state_PRERUNNING)\r\natomic_set(&subs->state, state_PREPARED);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void i_usX2Y_04Int(struct urb *urb)\r\n{\r\nstruct usX2Ydev *usX2Y = urb->context;\r\nif (urb->status)\r\nsnd_printk(KERN_ERR "snd_usX2Y_04Int() urb->status=%i\n", urb->status);\r\nif (0 == --usX2Y->US04->len)\r\nwake_up(&usX2Y->In04WaitQueue);\r\n}\r\nstatic int usX2Y_rate_set(struct usX2Ydev *usX2Y, int rate)\r\n{\r\nint err = 0, i;\r\nstruct snd_usX2Y_urbSeq *us = NULL;\r\nint *usbdata = NULL;\r\nstruct s_c2 *ra = rate == 48000 ? SetRate48000 : SetRate44100;\r\nif (usX2Y->rate != rate) {\r\nus = kzalloc(sizeof(*us) + sizeof(struct urb*) * NOOF_SETRATE_URBS, GFP_KERNEL);\r\nif (NULL == us) {\r\nerr = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nusbdata = kmalloc(sizeof(int) * NOOF_SETRATE_URBS, GFP_KERNEL);\r\nif (NULL == usbdata) {\r\nerr = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nfor (i = 0; i < NOOF_SETRATE_URBS; ++i) {\r\nif (NULL == (us->urb[i] = usb_alloc_urb(0, GFP_KERNEL))) {\r\nerr = -ENOMEM;\r\ngoto cleanup;\r\n}\r\n((char*)(usbdata + i))[0] = ra[i].c1;\r\n((char*)(usbdata + i))[1] = ra[i].c2;\r\nusb_fill_bulk_urb(us->urb[i], usX2Y->dev, usb_sndbulkpipe(usX2Y->dev, 4),\r\nusbdata + i, 2, i_usX2Y_04Int, usX2Y);\r\n}\r\nus->submitted = 0;\r\nus->len = NOOF_SETRATE_URBS;\r\nusX2Y->US04 = us;\r\nwait_event_timeout(usX2Y->In04WaitQueue, 0 == us->len, HZ);\r\nusX2Y->US04 = NULL;\r\nif (us->len)\r\nerr = -ENODEV;\r\ncleanup:\r\nif (us) {\r\nus->submitted = 2*NOOF_SETRATE_URBS;\r\nfor (i = 0; i < NOOF_SETRATE_URBS; ++i) {\r\nstruct urb *urb = us->urb[i];\r\nif (urb->status) {\r\nif (!err)\r\nerr = -ENODEV;\r\nusb_kill_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\n}\r\nusX2Y->US04 = NULL;\r\nkfree(usbdata);\r\nkfree(us);\r\nif (!err)\r\nusX2Y->rate = rate;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int usX2Y_format_set(struct usX2Ydev *usX2Y, snd_pcm_format_t format)\r\n{\r\nint alternate, err;\r\nstruct list_head* p;\r\nif (format == SNDRV_PCM_FORMAT_S24_3LE) {\r\nalternate = 2;\r\nusX2Y->stride = 6;\r\n} else {\r\nalternate = 1;\r\nusX2Y->stride = 4;\r\n}\r\nlist_for_each(p, &usX2Y->midi_list) {\r\nsnd_usbmidi_input_stop(p);\r\n}\r\nusb_kill_urb(usX2Y->In04urb);\r\nif ((err = usb_set_interface(usX2Y->dev, 0, alternate))) {\r\nsnd_printk(KERN_ERR "usb_set_interface error \n");\r\nreturn err;\r\n}\r\nusX2Y->In04urb->dev = usX2Y->dev;\r\nerr = usb_submit_urb(usX2Y->In04urb, GFP_KERNEL);\r\nlist_for_each(p, &usX2Y->midi_list) {\r\nsnd_usbmidi_input_start(p);\r\n}\r\nusX2Y->format = format;\r\nusX2Y->rate = 0;\r\nreturn err;\r\n}\r\nstatic int snd_usX2Y_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint err = 0;\r\nunsigned int rate = params_rate(hw_params);\r\nsnd_pcm_format_t format = params_format(hw_params);\r\nstruct snd_card *card = substream->pstr->pcm->card;\r\nstruct usX2Ydev *dev = usX2Y(card);\r\nint i;\r\nmutex_lock(&usX2Y(card)->pcm_mutex);\r\nsnd_printdd("snd_usX2Y_hw_params(%p, %p)\n", substream, hw_params);\r\nfor (i = 0; i < dev->pcm_devs * 2; i++) {\r\nstruct snd_usX2Y_substream *subs = dev->subs[i];\r\nstruct snd_pcm_substream *test_substream;\r\nif (!subs)\r\ncontinue;\r\ntest_substream = subs->pcm_substream;\r\nif (!test_substream || test_substream == substream ||\r\n!test_substream->runtime)\r\ncontinue;\r\nif ((test_substream->runtime->format &&\r\ntest_substream->runtime->format != format) ||\r\n(test_substream->runtime->rate &&\r\ntest_substream->runtime->rate != rate)) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\n}\r\nerr = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "snd_pcm_lib_malloc_pages(%p, %i) returned %i\n",\r\nsubstream, params_buffer_bytes(hw_params), err);\r\ngoto error;\r\n}\r\nerror:\r\nmutex_unlock(&usX2Y(card)->pcm_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_usX2Y_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_usX2Y_substream *subs = runtime->private_data;\r\nmutex_lock(&subs->usX2Y->pcm_mutex);\r\nsnd_printdd("snd_usX2Y_hw_free(%p)\n", substream);\r\nif (SNDRV_PCM_STREAM_PLAYBACK == substream->stream) {\r\nstruct snd_usX2Y_substream *cap_subs = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];\r\natomic_set(&subs->state, state_STOPPED);\r\nusX2Y_urbs_release(subs);\r\nif (!cap_subs->pcm_substream ||\r\n!cap_subs->pcm_substream->runtime ||\r\n!cap_subs->pcm_substream->runtime->status ||\r\ncap_subs->pcm_substream->runtime->status->state < SNDRV_PCM_STATE_PREPARED) {\r\natomic_set(&cap_subs->state, state_STOPPED);\r\nusX2Y_urbs_release(cap_subs);\r\n}\r\n} else {\r\nstruct snd_usX2Y_substream *playback_subs = subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (atomic_read(&playback_subs->state) < state_PREPARED) {\r\natomic_set(&subs->state, state_STOPPED);\r\nusX2Y_urbs_release(subs);\r\n}\r\n}\r\nmutex_unlock(&subs->usX2Y->pcm_mutex);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_usX2Y_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_usX2Y_substream *subs = runtime->private_data;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nstruct snd_usX2Y_substream *capsubs = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];\r\nint err = 0;\r\nsnd_printdd("snd_usX2Y_pcm_prepare(%p)\n", substream);\r\nmutex_lock(&usX2Y->pcm_mutex);\r\nusX2Y_subs_prepare(subs);\r\nif (atomic_read(&capsubs->state) < state_PREPARED) {\r\nif (usX2Y->format != runtime->format)\r\nif ((err = usX2Y_format_set(usX2Y, runtime->format)) < 0)\r\ngoto up_prepare_mutex;\r\nif (usX2Y->rate != runtime->rate)\r\nif ((err = usX2Y_rate_set(usX2Y, runtime->rate)) < 0)\r\ngoto up_prepare_mutex;\r\nsnd_printdd("starting capture pipe for %s\n", subs == capsubs ? "self" : "playpipe");\r\nif (0 > (err = usX2Y_urbs_start(capsubs)))\r\ngoto up_prepare_mutex;\r\n}\r\nif (subs != capsubs && atomic_read(&subs->state) < state_PREPARED)\r\nerr = usX2Y_urbs_start(subs);\r\nup_prepare_mutex:\r\nmutex_unlock(&usX2Y->pcm_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_usX2Y_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_usX2Y_substream *subs = ((struct snd_usX2Y_substream **)\r\nsnd_pcm_substream_chip(substream))[substream->stream];\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (subs->usX2Y->chip_status & USX2Y_STAT_CHIP_MMAP_PCM_URBS)\r\nreturn -EBUSY;\r\nruntime->hw = snd_usX2Y_2c;\r\nruntime->private_data = subs;\r\nsubs->pcm_substream = substream;\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_TIME, 1000, 200000);\r\nreturn 0;\r\n}\r\nstatic int snd_usX2Y_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_usX2Y_substream *subs = runtime->private_data;\r\nsubs->pcm_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic void usX2Y_audio_stream_free(struct snd_usX2Y_substream **usX2Y_substream)\r\n{\r\nkfree(usX2Y_substream[SNDRV_PCM_STREAM_PLAYBACK]);\r\nusX2Y_substream[SNDRV_PCM_STREAM_PLAYBACK] = NULL;\r\nkfree(usX2Y_substream[SNDRV_PCM_STREAM_CAPTURE]);\r\nusX2Y_substream[SNDRV_PCM_STREAM_CAPTURE] = NULL;\r\n}\r\nstatic void snd_usX2Y_pcm_private_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_usX2Y_substream **usX2Y_stream = pcm->private_data;\r\nif (usX2Y_stream)\r\nusX2Y_audio_stream_free(usX2Y_stream);\r\n}\r\nstatic int usX2Y_audio_stream_new(struct snd_card *card, int playback_endpoint, int capture_endpoint)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err, i;\r\nstruct snd_usX2Y_substream **usX2Y_substream =\r\nusX2Y(card)->subs + 2 * usX2Y(card)->pcm_devs;\r\nfor (i = playback_endpoint ? SNDRV_PCM_STREAM_PLAYBACK : SNDRV_PCM_STREAM_CAPTURE;\r\ni <= SNDRV_PCM_STREAM_CAPTURE; ++i) {\r\nusX2Y_substream[i] = kzalloc(sizeof(struct snd_usX2Y_substream), GFP_KERNEL);\r\nif (NULL == usX2Y_substream[i]) {\r\nsnd_printk(KERN_ERR "cannot malloc\n");\r\nreturn -ENOMEM;\r\n}\r\nusX2Y_substream[i]->usX2Y = usX2Y(card);\r\n}\r\nif (playback_endpoint)\r\nusX2Y_substream[SNDRV_PCM_STREAM_PLAYBACK]->endpoint = playback_endpoint;\r\nusX2Y_substream[SNDRV_PCM_STREAM_CAPTURE]->endpoint = capture_endpoint;\r\nerr = snd_pcm_new(card, NAME_ALLCAPS" Audio", usX2Y(card)->pcm_devs,\r\nplayback_endpoint ? 1 : 0, 1,\r\n&pcm);\r\nif (err < 0) {\r\nusX2Y_audio_stream_free(usX2Y_substream);\r\nreturn err;\r\n}\r\nif (playback_endpoint)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_usX2Y_pcm_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_usX2Y_pcm_ops);\r\npcm->private_data = usX2Y_substream;\r\npcm->private_free = snd_usX2Y_pcm_private_free;\r\npcm->info_flags = 0;\r\nsprintf(pcm->name, NAME_ALLCAPS" Audio #%d", usX2Y(card)->pcm_devs);\r\nif ((playback_endpoint &&\r\n0 > (err = snd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n64*1024, 128*1024))) ||\r\n0 > (err = snd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n64*1024, 128*1024))) {\r\nsnd_usX2Y_pcm_private_free(pcm);\r\nreturn err;\r\n}\r\nusX2Y(card)->pcm_devs++;\r\nreturn 0;\r\n}\r\nint usX2Y_audio_create(struct snd_card *card)\r\n{\r\nint err = 0;\r\nINIT_LIST_HEAD(&usX2Y(card)->pcm_list);\r\nif (0 > (err = usX2Y_audio_stream_new(card, 0xA, 0x8)))\r\nreturn err;\r\nif (le16_to_cpu(usX2Y(card)->dev->descriptor.idProduct) == USB_ID_US428)\r\nif (0 > (err = usX2Y_audio_stream_new(card, 0, 0xA)))\r\nreturn err;\r\nif (le16_to_cpu(usX2Y(card)->dev->descriptor.idProduct) != USB_ID_US122)\r\nerr = usX2Y_rate_set(usX2Y(card), 44100);\r\nreturn err;\r\n}
