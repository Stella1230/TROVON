static int\r\npwm_info(struct nouveau_therm *therm, int line)\r\n{\r\nu32 gpio = nv_rd32(therm, 0x00d610 + (line * 0x04));\r\nswitch (gpio & 0x000000c0) {\r\ncase 0x00000000:\r\ncase 0x00000040:\r\nswitch (gpio & 0x0000001f) {\r\ncase 0x00: return 2;\r\ncase 0x19: return 1;\r\ncase 0x1c: return 0;\r\ncase 0x1e: return 2;\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nnv_error(therm, "GPIO %d unknown PWM: 0x%08x\n", line, gpio);\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nnvd0_fan_pwm_ctrl(struct nouveau_therm *therm, int line, bool enable)\r\n{\r\nu32 data = enable ? 0x00000040 : 0x00000000;\r\nint indx = pwm_info(therm, line);\r\nif (indx < 0)\r\nreturn indx;\r\nelse if (indx < 2)\r\nnv_mask(therm, 0x00d610 + (line * 0x04), 0x000000c0, data);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvd0_fan_pwm_get(struct nouveau_therm *therm, int line, u32 *divs, u32 *duty)\r\n{\r\nint indx = pwm_info(therm, line);\r\nif (indx < 0)\r\nreturn indx;\r\nelse if (indx < 2) {\r\nif (nv_rd32(therm, 0x00d610 + (line * 0x04)) & 0x00000040) {\r\n*divs = nv_rd32(therm, 0x00e114 + (indx * 8));\r\n*duty = nv_rd32(therm, 0x00e118 + (indx * 8));\r\nreturn 0;\r\n}\r\n} else if (indx == 2) {\r\n*divs = nv_rd32(therm, 0x0200d8) & 0x1fff;\r\n*duty = nv_rd32(therm, 0x0200dc) & 0x1fff;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnvd0_fan_pwm_set(struct nouveau_therm *therm, int line, u32 divs, u32 duty)\r\n{\r\nint indx = pwm_info(therm, line);\r\nif (indx < 0)\r\nreturn indx;\r\nelse if (indx < 2) {\r\nnv_wr32(therm, 0x00e114 + (indx * 8), divs);\r\nnv_wr32(therm, 0x00e118 + (indx * 8), duty | 0x80000000);\r\n} else if (indx == 2) {\r\nnv_mask(therm, 0x0200d8, 0x1fff, divs);\r\nnv_wr32(therm, 0x0200dc, duty | 0x40000000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnvd0_fan_pwm_clock(struct nouveau_therm *therm, int line)\r\n{\r\nint indx = pwm_info(therm, line);\r\nif (indx < 0)\r\nreturn 0;\r\nelse if (indx < 2)\r\nreturn (nv_device(therm)->crystal * 1000) / 20;\r\nelse\r\nreturn nv_device(therm)->crystal * 1000 / 10;\r\n}\r\nstatic int\r\nnvd0_therm_init(struct nouveau_object *object)\r\n{\r\nstruct nvd0_therm_priv *priv = (void *)object;\r\nint ret;\r\nret = nouveau_therm_init(&priv->base.base);\r\nif (ret)\r\nreturn ret;\r\nnv_mask(priv, 0x00e720, 0x00000003, 0x00000002);\r\nif (priv->base.fan->tach.func != DCB_GPIO_UNUSED) {\r\nnv_mask(priv, 0x00d79c, 0x000000ff, priv->base.fan->tach.line);\r\nnv_wr32(priv, 0x00e724, nv_device(priv)->crystal * 1000);\r\nnv_mask(priv, 0x00e720, 0x00000001, 0x00000001);\r\n}\r\nnv_mask(priv, 0x00e720, 0x00000002, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvd0_therm_ctor(struct nouveau_object *parent,\r\nstruct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nvd0_therm_priv *priv;\r\nint ret;\r\nret = nouveau_therm_create(parent, engine, oclass, &priv);\r\n*pobject = nv_object(priv);\r\nif (ret)\r\nreturn ret;\r\npriv->base.base.pwm_ctrl = nvd0_fan_pwm_ctrl;\r\npriv->base.base.pwm_get = nvd0_fan_pwm_get;\r\npriv->base.base.pwm_set = nvd0_fan_pwm_set;\r\npriv->base.base.pwm_clock = nvd0_fan_pwm_clock;\r\npriv->base.base.temp_get = nv84_temp_get;\r\npriv->base.base.fan_sense = nva3_therm_fan_sense;\r\npriv->base.sensor.program_alarms = nouveau_therm_program_alarms_polling;\r\nreturn nouveau_therm_preinit(&priv->base.base);\r\n}
