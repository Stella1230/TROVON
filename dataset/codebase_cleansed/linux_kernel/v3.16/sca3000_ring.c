static int sca3000_read_data(struct sca3000_state *st,\r\nuint8_t reg_address_high,\r\nu8 **rx_p,\r\nint len)\r\n{\r\nint ret;\r\nstruct spi_transfer xfer[2] = {\r\n{\r\n.len = 1,\r\n.tx_buf = st->tx,\r\n}, {\r\n.len = len,\r\n}\r\n};\r\n*rx_p = kmalloc(len, GFP_KERNEL);\r\nif (*rx_p == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nxfer[1].rx_buf = *rx_p;\r\nst->tx[0] = SCA3000_READ_REG(reg_address_high);\r\nret = spi_sync_transfer(st->us, xfer, ARRAY_SIZE(xfer));\r\nif (ret) {\r\ndev_err(get_device(&st->us->dev), "problem reading register");\r\ngoto error_free_rx;\r\n}\r\nreturn 0;\r\nerror_free_rx:\r\nkfree(*rx_p);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int sca3000_read_first_n_hw_rb(struct iio_buffer *r,\r\nsize_t count, char __user *buf)\r\n{\r\nstruct iio_hw_buffer *hw_ring = iio_to_hw_buf(r);\r\nstruct iio_dev *indio_dev = hw_ring->private;\r\nstruct sca3000_state *st = iio_priv(indio_dev);\r\nu8 *rx;\r\nint ret, i, num_available, num_read = 0;\r\nint bytes_per_sample = 1;\r\nif (st->bpse == 11)\r\nbytes_per_sample = 2;\r\nmutex_lock(&st->lock);\r\nif (count % bytes_per_sample) {\r\nret = -EINVAL;\r\ngoto error_ret;\r\n}\r\nret = sca3000_read_data_short(st, SCA3000_REG_ADDR_BUF_COUNT, 1);\r\nif (ret)\r\ngoto error_ret;\r\nelse\r\nnum_available = st->rx[0];\r\nif (count > num_available * bytes_per_sample)\r\nnum_read = num_available*bytes_per_sample;\r\nelse\r\nnum_read = count;\r\nret = sca3000_read_data(st,\r\nSCA3000_REG_ADDR_RING_OUT,\r\n&rx, num_read);\r\nif (ret)\r\ngoto error_ret;\r\nfor (i = 0; i < num_read; i++)\r\n*(((u16 *)rx) + i) = be16_to_cpup((u16 *)rx + i);\r\nif (copy_to_user(buf, rx, num_read))\r\nret = -EFAULT;\r\nkfree(rx);\r\nr->stufftoread = 0;\r\nerror_ret:\r\nmutex_unlock(&st->lock);\r\nreturn ret ? ret : num_read;\r\n}\r\nstatic int sca3000_ring_get_length(struct iio_buffer *r)\r\n{\r\nreturn 64;\r\n}\r\nstatic int sca3000_ring_get_bytes_per_datum(struct iio_buffer *r)\r\n{\r\nreturn 6;\r\n}\r\nstatic ssize_t sca3000_query_ring_int(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint ret, val;\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct sca3000_state *st = iio_priv(indio_dev);\r\nmutex_lock(&st->lock);\r\nret = sca3000_read_data_short(st, SCA3000_REG_ADDR_INT_MASK, 1);\r\nval = st->rx[0];\r\nmutex_unlock(&st->lock);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", !!(val & this_attr->address));\r\n}\r\nstatic ssize_t sca3000_set_ring_int(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct sca3000_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nu8 val;\r\nint ret;\r\nmutex_lock(&st->lock);\r\nret = kstrtou8(buf, 10, &val);\r\nif (ret)\r\ngoto error_ret;\r\nret = sca3000_read_data_short(st, SCA3000_REG_ADDR_INT_MASK, 1);\r\nif (ret)\r\ngoto error_ret;\r\nif (val)\r\nret = sca3000_write_reg(st,\r\nSCA3000_REG_ADDR_INT_MASK,\r\nst->rx[0] | this_attr->address);\r\nelse\r\nret = sca3000_write_reg(st,\r\nSCA3000_REG_ADDR_INT_MASK,\r\nst->rx[0] & ~this_attr->address);\r\nerror_ret:\r\nmutex_unlock(&st->lock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t sca3000_show_buffer_scale(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct sca3000_state *st = iio_priv(indio_dev);\r\nreturn sprintf(buf, "0.%06d\n", 4*st->info->scale);\r\n}\r\nstatic struct iio_buffer *sca3000_rb_allocate(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_buffer *buf;\r\nstruct iio_hw_buffer *ring;\r\nring = kzalloc(sizeof(*ring), GFP_KERNEL);\r\nif (!ring)\r\nreturn NULL;\r\nring->private = indio_dev;\r\nbuf = &ring->buf;\r\nbuf->stufftoread = 0;\r\nbuf->attrs = &sca3000_ring_attr;\r\niio_buffer_init(buf);\r\nreturn buf;\r\n}\r\nstatic void sca3000_ring_release(struct iio_buffer *r)\r\n{\r\nkfree(iio_to_hw_buf(r));\r\n}\r\nint sca3000_configure_ring(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_buffer *buffer;\r\nbuffer = sca3000_rb_allocate(indio_dev);\r\nif (buffer == NULL)\r\nreturn -ENOMEM;\r\nindio_dev->modes |= INDIO_BUFFER_HARDWARE;\r\nindio_dev->buffer->access = &sca3000_ring_access_funcs;\r\niio_device_attach_buffer(indio_dev, buffer);\r\nreturn 0;\r\n}\r\nvoid sca3000_unconfigure_ring(struct iio_dev *indio_dev)\r\n{\r\niio_buffer_put(indio_dev->buffer);\r\n}\r\nstatic inline\r\nint __sca3000_hw_ring_state_set(struct iio_dev *indio_dev, bool state)\r\n{\r\nstruct sca3000_state *st = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&st->lock);\r\nret = sca3000_read_data_short(st, SCA3000_REG_ADDR_MODE, 1);\r\nif (ret)\r\ngoto error_ret;\r\nif (state) {\r\ndev_info(&indio_dev->dev, "supposedly enabling ring buffer\n");\r\nret = sca3000_write_reg(st,\r\nSCA3000_REG_ADDR_MODE,\r\n(st->rx[0] | SCA3000_RING_BUF_ENABLE));\r\n} else\r\nret = sca3000_write_reg(st,\r\nSCA3000_REG_ADDR_MODE,\r\n(st->rx[0] & ~SCA3000_RING_BUF_ENABLE));\r\nerror_ret:\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nstatic int sca3000_hw_ring_preenable(struct iio_dev *indio_dev)\r\n{\r\nreturn __sca3000_hw_ring_state_set(indio_dev, 1);\r\n}\r\nstatic int sca3000_hw_ring_postdisable(struct iio_dev *indio_dev)\r\n{\r\nreturn __sca3000_hw_ring_state_set(indio_dev, 0);\r\n}\r\nvoid sca3000_register_ring_funcs(struct iio_dev *indio_dev)\r\n{\r\nindio_dev->setup_ops = &sca3000_ring_setup_ops;\r\n}\r\nvoid sca3000_ring_int_process(u8 val, struct iio_buffer *ring)\r\n{\r\nif (val & (SCA3000_INT_STATUS_THREE_QUARTERS |\r\nSCA3000_INT_STATUS_HALF)) {\r\nring->stufftoread = true;\r\nwake_up_interruptible(&ring->pollq);\r\n}\r\n}
