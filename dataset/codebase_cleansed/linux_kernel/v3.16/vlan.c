static int vlan_group_prealloc_vid(struct vlan_group *vg,\r\n__be16 vlan_proto, u16 vlan_id)\r\n{\r\nstruct net_device **array;\r\nunsigned int pidx, vidx;\r\nunsigned int size;\r\nASSERT_RTNL();\r\npidx = vlan_proto_idx(vlan_proto);\r\nvidx = vlan_id / VLAN_GROUP_ARRAY_PART_LEN;\r\narray = vg->vlan_devices_arrays[pidx][vidx];\r\nif (array != NULL)\r\nreturn 0;\r\nsize = sizeof(struct net_device *) * VLAN_GROUP_ARRAY_PART_LEN;\r\narray = kzalloc(size, GFP_KERNEL);\r\nif (array == NULL)\r\nreturn -ENOBUFS;\r\nvg->vlan_devices_arrays[pidx][vidx] = array;\r\nreturn 0;\r\n}\r\nvoid unregister_vlan_dev(struct net_device *dev, struct list_head *head)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nstruct net_device *real_dev = vlan->real_dev;\r\nstruct vlan_info *vlan_info;\r\nstruct vlan_group *grp;\r\nu16 vlan_id = vlan->vlan_id;\r\nASSERT_RTNL();\r\nvlan_info = rtnl_dereference(real_dev->vlan_info);\r\nBUG_ON(!vlan_info);\r\ngrp = &vlan_info->grp;\r\ngrp->nr_vlan_devs--;\r\nif (vlan->flags & VLAN_FLAG_MVRP)\r\nvlan_mvrp_request_leave(dev);\r\nif (vlan->flags & VLAN_FLAG_GVRP)\r\nvlan_gvrp_request_leave(dev);\r\nvlan_group_set_device(grp, vlan->vlan_proto, vlan_id, NULL);\r\nnetdev_upper_dev_unlink(real_dev, dev);\r\nunregister_netdevice_queue(dev, head);\r\nif (grp->nr_vlan_devs == 0) {\r\nvlan_mvrp_uninit_applicant(real_dev);\r\nvlan_gvrp_uninit_applicant(real_dev);\r\n}\r\nif (vlan_id)\r\nvlan_vid_del(real_dev, vlan->vlan_proto, vlan_id);\r\ndev_put(real_dev);\r\n}\r\nint vlan_check_real_dev(struct net_device *real_dev,\r\n__be16 protocol, u16 vlan_id)\r\n{\r\nconst char *name = real_dev->name;\r\nif (real_dev->features & NETIF_F_VLAN_CHALLENGED) {\r\npr_info("VLANs not supported on %s\n", name);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (vlan_find_dev(real_dev, protocol, vlan_id) != NULL)\r\nreturn -EEXIST;\r\nreturn 0;\r\n}\r\nint register_vlan_dev(struct net_device *dev)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nstruct net_device *real_dev = vlan->real_dev;\r\nu16 vlan_id = vlan->vlan_id;\r\nstruct vlan_info *vlan_info;\r\nstruct vlan_group *grp;\r\nint err;\r\nerr = vlan_vid_add(real_dev, vlan->vlan_proto, vlan_id);\r\nif (err)\r\nreturn err;\r\nvlan_info = rtnl_dereference(real_dev->vlan_info);\r\nBUG_ON(!vlan_info);\r\ngrp = &vlan_info->grp;\r\nif (grp->nr_vlan_devs == 0) {\r\nerr = vlan_gvrp_init_applicant(real_dev);\r\nif (err < 0)\r\ngoto out_vid_del;\r\nerr = vlan_mvrp_init_applicant(real_dev);\r\nif (err < 0)\r\ngoto out_uninit_gvrp;\r\n}\r\nerr = vlan_group_prealloc_vid(grp, vlan->vlan_proto, vlan_id);\r\nif (err < 0)\r\ngoto out_uninit_mvrp;\r\nvlan->nest_level = dev_get_nest_level(real_dev, is_vlan_dev) + 1;\r\nerr = register_netdevice(dev);\r\nif (err < 0)\r\ngoto out_uninit_mvrp;\r\nerr = netdev_upper_dev_link(real_dev, dev);\r\nif (err)\r\ngoto out_unregister_netdev;\r\ndev_hold(real_dev);\r\nnetif_stacked_transfer_operstate(real_dev, dev);\r\nlinkwatch_fire_event(dev);\r\nvlan_group_set_device(grp, vlan->vlan_proto, vlan_id, dev);\r\ngrp->nr_vlan_devs++;\r\nreturn 0;\r\nout_unregister_netdev:\r\nunregister_netdevice(dev);\r\nout_uninit_mvrp:\r\nif (grp->nr_vlan_devs == 0)\r\nvlan_mvrp_uninit_applicant(real_dev);\r\nout_uninit_gvrp:\r\nif (grp->nr_vlan_devs == 0)\r\nvlan_gvrp_uninit_applicant(real_dev);\r\nout_vid_del:\r\nvlan_vid_del(real_dev, vlan->vlan_proto, vlan_id);\r\nreturn err;\r\n}\r\nstatic int register_vlan_device(struct net_device *real_dev, u16 vlan_id)\r\n{\r\nstruct net_device *new_dev;\r\nstruct vlan_dev_priv *vlan;\r\nstruct net *net = dev_net(real_dev);\r\nstruct vlan_net *vn = net_generic(net, vlan_net_id);\r\nchar name[IFNAMSIZ];\r\nint err;\r\nif (vlan_id >= VLAN_VID_MASK)\r\nreturn -ERANGE;\r\nerr = vlan_check_real_dev(real_dev, htons(ETH_P_8021Q), vlan_id);\r\nif (err < 0)\r\nreturn err;\r\nswitch (vn->name_type) {\r\ncase VLAN_NAME_TYPE_RAW_PLUS_VID:\r\nsnprintf(name, IFNAMSIZ, "%s.%.4i", real_dev->name, vlan_id);\r\nbreak;\r\ncase VLAN_NAME_TYPE_PLUS_VID_NO_PAD:\r\nsnprintf(name, IFNAMSIZ, "vlan%i", vlan_id);\r\nbreak;\r\ncase VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD:\r\nsnprintf(name, IFNAMSIZ, "%s.%i", real_dev->name, vlan_id);\r\nbreak;\r\ncase VLAN_NAME_TYPE_PLUS_VID:\r\ndefault:\r\nsnprintf(name, IFNAMSIZ, "vlan%.4i", vlan_id);\r\n}\r\nnew_dev = alloc_netdev(sizeof(struct vlan_dev_priv), name, vlan_setup);\r\nif (new_dev == NULL)\r\nreturn -ENOBUFS;\r\ndev_net_set(new_dev, net);\r\nnew_dev->mtu = real_dev->mtu;\r\nnew_dev->priv_flags |= (real_dev->priv_flags & IFF_UNICAST_FLT);\r\nvlan = vlan_dev_priv(new_dev);\r\nvlan->vlan_proto = htons(ETH_P_8021Q);\r\nvlan->vlan_id = vlan_id;\r\nvlan->real_dev = real_dev;\r\nvlan->dent = NULL;\r\nvlan->flags = VLAN_FLAG_REORDER_HDR;\r\nnew_dev->rtnl_link_ops = &vlan_link_ops;\r\nerr = register_vlan_dev(new_dev);\r\nif (err < 0)\r\ngoto out_free_newdev;\r\nreturn 0;\r\nout_free_newdev:\r\nfree_netdev(new_dev);\r\nreturn err;\r\n}\r\nstatic void vlan_sync_address(struct net_device *dev,\r\nstruct net_device *vlandev)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(vlandev);\r\nif (ether_addr_equal(vlan->real_dev_addr, dev->dev_addr))\r\nreturn;\r\nif (!ether_addr_equal(vlandev->dev_addr, vlan->real_dev_addr) &&\r\nether_addr_equal(vlandev->dev_addr, dev->dev_addr))\r\ndev_uc_del(dev, vlandev->dev_addr);\r\nif (ether_addr_equal(vlandev->dev_addr, vlan->real_dev_addr) &&\r\n!ether_addr_equal(vlandev->dev_addr, dev->dev_addr))\r\ndev_uc_add(dev, vlandev->dev_addr);\r\nether_addr_copy(vlan->real_dev_addr, dev->dev_addr);\r\n}\r\nstatic void vlan_transfer_features(struct net_device *dev,\r\nstruct net_device *vlandev)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(vlandev);\r\nvlandev->gso_max_size = dev->gso_max_size;\r\nif (vlan_hw_offload_capable(dev->features, vlan->vlan_proto))\r\nvlandev->hard_header_len = dev->hard_header_len;\r\nelse\r\nvlandev->hard_header_len = dev->hard_header_len + VLAN_HLEN;\r\n#if IS_ENABLED(CONFIG_FCOE)\r\nvlandev->fcoe_ddp_xid = dev->fcoe_ddp_xid;\r\n#endif\r\nnetdev_update_features(vlandev);\r\n}\r\nstatic void __vlan_device_event(struct net_device *dev, unsigned long event)\r\n{\r\nswitch (event) {\r\ncase NETDEV_CHANGENAME:\r\nvlan_proc_rem_dev(dev);\r\nif (vlan_proc_add_dev(dev) < 0)\r\npr_warn("failed to change proc name for %s\n",\r\ndev->name);\r\nbreak;\r\ncase NETDEV_REGISTER:\r\nif (vlan_proc_add_dev(dev) < 0)\r\npr_warn("failed to add proc entry for %s\n", dev->name);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nvlan_proc_rem_dev(dev);\r\nbreak;\r\n}\r\n}\r\nstatic int vlan_device_event(struct notifier_block *unused, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct vlan_group *grp;\r\nstruct vlan_info *vlan_info;\r\nint i, flgs;\r\nstruct net_device *vlandev;\r\nstruct vlan_dev_priv *vlan;\r\nbool last = false;\r\nLIST_HEAD(list);\r\nif (is_vlan_dev(dev))\r\n__vlan_device_event(dev, event);\r\nif ((event == NETDEV_UP) &&\r\n(dev->features & NETIF_F_HW_VLAN_CTAG_FILTER)) {\r\npr_info("adding VLAN 0 to HW filter on device %s\n",\r\ndev->name);\r\nvlan_vid_add(dev, htons(ETH_P_8021Q), 0);\r\n}\r\nvlan_info = rtnl_dereference(dev->vlan_info);\r\nif (!vlan_info)\r\ngoto out;\r\ngrp = &vlan_info->grp;\r\nswitch (event) {\r\ncase NETDEV_CHANGE:\r\nvlan_group_for_each_dev(grp, i, vlandev)\r\nnetif_stacked_transfer_operstate(dev, vlandev);\r\nbreak;\r\ncase NETDEV_CHANGEADDR:\r\nvlan_group_for_each_dev(grp, i, vlandev) {\r\nflgs = vlandev->flags;\r\nif (!(flgs & IFF_UP))\r\ncontinue;\r\nvlan_sync_address(dev, vlandev);\r\n}\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nvlan_group_for_each_dev(grp, i, vlandev) {\r\nif (vlandev->mtu <= dev->mtu)\r\ncontinue;\r\ndev_set_mtu(vlandev, dev->mtu);\r\n}\r\nbreak;\r\ncase NETDEV_FEAT_CHANGE:\r\nvlan_group_for_each_dev(grp, i, vlandev)\r\nvlan_transfer_features(dev, vlandev);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nif (dev->features & NETIF_F_HW_VLAN_CTAG_FILTER)\r\nvlan_vid_del(dev, htons(ETH_P_8021Q), 0);\r\nvlan_group_for_each_dev(grp, i, vlandev) {\r\nflgs = vlandev->flags;\r\nif (!(flgs & IFF_UP))\r\ncontinue;\r\nvlan = vlan_dev_priv(vlandev);\r\nif (!(vlan->flags & VLAN_FLAG_LOOSE_BINDING))\r\ndev_change_flags(vlandev, flgs & ~IFF_UP);\r\nnetif_stacked_transfer_operstate(dev, vlandev);\r\n}\r\nbreak;\r\ncase NETDEV_UP:\r\nvlan_group_for_each_dev(grp, i, vlandev) {\r\nflgs = vlandev->flags;\r\nif (flgs & IFF_UP)\r\ncontinue;\r\nvlan = vlan_dev_priv(vlandev);\r\nif (!(vlan->flags & VLAN_FLAG_LOOSE_BINDING))\r\ndev_change_flags(vlandev, flgs | IFF_UP);\r\nnetif_stacked_transfer_operstate(dev, vlandev);\r\n}\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nif (dev->reg_state != NETREG_UNREGISTERING)\r\nbreak;\r\nvlan_group_for_each_dev(grp, i, vlandev) {\r\nif (vlan_info->nr_vids == 1)\r\nlast = true;\r\nunregister_vlan_dev(vlandev, &list);\r\nif (last)\r\nbreak;\r\n}\r\nunregister_netdevice_many(&list);\r\nbreak;\r\ncase NETDEV_PRE_TYPE_CHANGE:\r\nif (vlan_uses_dev(dev))\r\nreturn NOTIFY_BAD;\r\nbreak;\r\ncase NETDEV_NOTIFY_PEERS:\r\ncase NETDEV_BONDING_FAILOVER:\r\ncase NETDEV_RESEND_IGMP:\r\nvlan_group_for_each_dev(grp, i, vlandev)\r\ncall_netdevice_notifiers(event, vlandev);\r\nbreak;\r\n}\r\nout:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int vlan_ioctl_handler(struct net *net, void __user *arg)\r\n{\r\nint err;\r\nstruct vlan_ioctl_args args;\r\nstruct net_device *dev = NULL;\r\nif (copy_from_user(&args, arg, sizeof(struct vlan_ioctl_args)))\r\nreturn -EFAULT;\r\nargs.device1[23] = 0;\r\nargs.u.device2[23] = 0;\r\nrtnl_lock();\r\nswitch (args.cmd) {\r\ncase SET_VLAN_INGRESS_PRIORITY_CMD:\r\ncase SET_VLAN_EGRESS_PRIORITY_CMD:\r\ncase SET_VLAN_FLAG_CMD:\r\ncase ADD_VLAN_CMD:\r\ncase DEL_VLAN_CMD:\r\ncase GET_VLAN_REALDEV_NAME_CMD:\r\ncase GET_VLAN_VID_CMD:\r\nerr = -ENODEV;\r\ndev = __dev_get_by_name(net, args.device1);\r\nif (!dev)\r\ngoto out;\r\nerr = -EINVAL;\r\nif (args.cmd != ADD_VLAN_CMD && !is_vlan_dev(dev))\r\ngoto out;\r\n}\r\nswitch (args.cmd) {\r\ncase SET_VLAN_INGRESS_PRIORITY_CMD:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nbreak;\r\nvlan_dev_set_ingress_priority(dev,\r\nargs.u.skb_priority,\r\nargs.vlan_qos);\r\nerr = 0;\r\nbreak;\r\ncase SET_VLAN_EGRESS_PRIORITY_CMD:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nbreak;\r\nerr = vlan_dev_set_egress_priority(dev,\r\nargs.u.skb_priority,\r\nargs.vlan_qos);\r\nbreak;\r\ncase SET_VLAN_FLAG_CMD:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nbreak;\r\nerr = vlan_dev_change_flags(dev,\r\nargs.vlan_qos ? args.u.flag : 0,\r\nargs.u.flag);\r\nbreak;\r\ncase SET_VLAN_NAME_TYPE_CMD:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nbreak;\r\nif ((args.u.name_type >= 0) &&\r\n(args.u.name_type < VLAN_NAME_TYPE_HIGHEST)) {\r\nstruct vlan_net *vn;\r\nvn = net_generic(net, vlan_net_id);\r\nvn->name_type = args.u.name_type;\r\nerr = 0;\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nbreak;\r\ncase ADD_VLAN_CMD:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nbreak;\r\nerr = register_vlan_device(dev, args.u.VID);\r\nbreak;\r\ncase DEL_VLAN_CMD:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nbreak;\r\nunregister_vlan_dev(dev, NULL);\r\nerr = 0;\r\nbreak;\r\ncase GET_VLAN_REALDEV_NAME_CMD:\r\nerr = 0;\r\nvlan_dev_get_realdev_name(dev, args.u.device2);\r\nif (copy_to_user(arg, &args,\r\nsizeof(struct vlan_ioctl_args)))\r\nerr = -EFAULT;\r\nbreak;\r\ncase GET_VLAN_VID_CMD:\r\nerr = 0;\r\nargs.u.VID = vlan_dev_vlan_id(dev);\r\nif (copy_to_user(arg, &args,\r\nsizeof(struct vlan_ioctl_args)))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nout:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic int __net_init vlan_init_net(struct net *net)\r\n{\r\nstruct vlan_net *vn = net_generic(net, vlan_net_id);\r\nint err;\r\nvn->name_type = VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD;\r\nerr = vlan_proc_init(net);\r\nreturn err;\r\n}\r\nstatic void __net_exit vlan_exit_net(struct net *net)\r\n{\r\nvlan_proc_cleanup(net);\r\n}\r\nstatic int __init vlan_proto_init(void)\r\n{\r\nint err;\r\npr_info("%s v%s\n", vlan_fullname, vlan_version);\r\nerr = register_pernet_subsys(&vlan_net_ops);\r\nif (err < 0)\r\ngoto err0;\r\nerr = register_netdevice_notifier(&vlan_notifier_block);\r\nif (err < 0)\r\ngoto err2;\r\nerr = vlan_gvrp_init();\r\nif (err < 0)\r\ngoto err3;\r\nerr = vlan_mvrp_init();\r\nif (err < 0)\r\ngoto err4;\r\nerr = vlan_netlink_init();\r\nif (err < 0)\r\ngoto err5;\r\nvlan_ioctl_set(vlan_ioctl_handler);\r\nreturn 0;\r\nerr5:\r\nvlan_mvrp_uninit();\r\nerr4:\r\nvlan_gvrp_uninit();\r\nerr3:\r\nunregister_netdevice_notifier(&vlan_notifier_block);\r\nerr2:\r\nunregister_pernet_subsys(&vlan_net_ops);\r\nerr0:\r\nreturn err;\r\n}\r\nstatic void __exit vlan_cleanup_module(void)\r\n{\r\nvlan_ioctl_set(NULL);\r\nvlan_netlink_fini();\r\nunregister_netdevice_notifier(&vlan_notifier_block);\r\nunregister_pernet_subsys(&vlan_net_ops);\r\nrcu_barrier();\r\nvlan_mvrp_uninit();\r\nvlan_gvrp_uninit();\r\n}
