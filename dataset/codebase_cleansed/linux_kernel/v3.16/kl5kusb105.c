static int klsi_105_chg_port_settings(struct usb_serial_port *port,\r\nstruct klsi_105_port_settings *settings)\r\n{\r\nint rc;\r\nrc = usb_control_msg(port->serial->dev,\r\nusb_sndctrlpipe(port->serial->dev, 0),\r\nKL5KUSB105A_SIO_SET_DATA,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_INTERFACE,\r\n0,\r\n0,\r\nsettings,\r\nsizeof(struct klsi_105_port_settings),\r\nKLSI_TIMEOUT);\r\nif (rc < 0)\r\ndev_err(&port->dev,\r\n"Change port settings failed (error = %d)\n", rc);\r\ndev_info(&port->serial->dev->dev,\r\n"%d byte block, baudrate %x, databits %d, u1 %d, u2 %d\n",\r\nsettings->pktlen, settings->baudrate, settings->databits,\r\nsettings->unknown1, settings->unknown2);\r\nreturn rc;\r\n}\r\nstatic unsigned long klsi_105_status2linestate(const __u16 status)\r\n{\r\nunsigned long res = 0;\r\nres = ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)\r\n| ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)\r\n;\r\nreturn res;\r\n}\r\nstatic int klsi_105_get_line_state(struct usb_serial_port *port,\r\nunsigned long *line_state_p)\r\n{\r\nint rc;\r\nu8 *status_buf;\r\n__u16 status;\r\ndev_info(&port->serial->dev->dev, "sending SIO Poll request\n");\r\nstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\r\nif (!status_buf)\r\nreturn -ENOMEM;\r\nstatus_buf[0] = 0xff;\r\nstatus_buf[1] = 0xff;\r\nrc = usb_control_msg(port->serial->dev,\r\nusb_rcvctrlpipe(port->serial->dev, 0),\r\nKL5KUSB105A_SIO_POLL,\r\nUSB_TYPE_VENDOR | USB_DIR_IN,\r\n0,\r\n0,\r\nstatus_buf, KLSI_STATUSBUF_LEN,\r\n10000\r\n);\r\nif (rc < 0)\r\ndev_err(&port->dev, "Reading line status failed (error = %d)\n",\r\nrc);\r\nelse {\r\nstatus = get_unaligned_le16(status_buf);\r\ndev_info(&port->serial->dev->dev, "read status %x %x\n",\r\nstatus_buf[0], status_buf[1]);\r\n*line_state_p = klsi_105_status2linestate(status);\r\n}\r\nkfree(status_buf);\r\nreturn rc;\r\n}\r\nstatic int klsi_105_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct klsi_105_private *priv;\r\npriv = kmalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->cfg.pktlen = 5;\r\npriv->cfg.baudrate = kl5kusb105a_sio_b9600;\r\npriv->cfg.databits = kl5kusb105a_dtb_8;\r\npriv->cfg.unknown1 = 0;\r\npriv->cfg.unknown2 = 1;\r\npriv->line_state = 0;\r\nspin_lock_init(&priv->lock);\r\nusb_set_serial_port_data(port, priv);\r\nreturn 0;\r\n}\r\nstatic int klsi_105_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct klsi_105_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct klsi_105_private *priv = usb_get_serial_port_data(port);\r\nint retval = 0;\r\nint rc;\r\nint i;\r\nunsigned long line_state;\r\nstruct klsi_105_port_settings *cfg;\r\nunsigned long flags;\r\ncfg = kmalloc(sizeof(*cfg), GFP_KERNEL);\r\nif (!cfg)\r\nreturn -ENOMEM;\r\ncfg->pktlen = 5;\r\ncfg->baudrate = kl5kusb105a_sio_b9600;\r\ncfg->databits = kl5kusb105a_dtb_8;\r\ncfg->unknown1 = 0;\r\ncfg->unknown2 = 1;\r\nklsi_105_chg_port_settings(port, cfg);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->termios.c_iflag = tty->termios.c_iflag;\r\npriv->termios.c_oflag = tty->termios.c_oflag;\r\npriv->termios.c_cflag = tty->termios.c_cflag;\r\npriv->termios.c_lflag = tty->termios.c_lflag;\r\nfor (i = 0; i < NCCS; i++)\r\npriv->termios.c_cc[i] = tty->termios.c_cc[i];\r\npriv->cfg.pktlen = cfg->pktlen;\r\npriv->cfg.baudrate = cfg->baudrate;\r\npriv->cfg.databits = cfg->databits;\r\npriv->cfg.unknown1 = cfg->unknown1;\r\npriv->cfg.unknown2 = cfg->unknown2;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nrc = usb_serial_generic_open(tty, port);\r\nif (rc) {\r\nretval = rc;\r\ngoto exit;\r\n}\r\nrc = usb_control_msg(port->serial->dev,\r\nusb_sndctrlpipe(port->serial->dev, 0),\r\nKL5KUSB105A_SIO_CONFIGURE,\r\nUSB_TYPE_VENDOR|USB_DIR_OUT|USB_RECIP_INTERFACE,\r\nKL5KUSB105A_SIO_CONFIGURE_READ_ON,\r\n0,\r\nNULL,\r\n0,\r\nKLSI_TIMEOUT);\r\nif (rc < 0) {\r\ndev_err(&port->dev, "Enabling read failed (error = %d)\n", rc);\r\nretval = rc;\r\n} else\r\ndev_dbg(&port->dev, "%s - enabled reading\n", __func__);\r\nrc = klsi_105_get_line_state(port, &line_state);\r\nif (rc >= 0) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->line_state = line_state;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(&port->dev, "%s - read line state 0x%lx\n", __func__, line_state);\r\nretval = 0;\r\n} else\r\nretval = rc;\r\nexit:\r\nkfree(cfg);\r\nreturn retval;\r\n}\r\nstatic void klsi_105_close(struct usb_serial_port *port)\r\n{\r\nint rc;\r\nrc = usb_control_msg(port->serial->dev,\r\nusb_sndctrlpipe(port->serial->dev, 0),\r\nKL5KUSB105A_SIO_CONFIGURE,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\nKL5KUSB105A_SIO_CONFIGURE_READ_OFF,\r\n0,\r\nNULL, 0,\r\nKLSI_TIMEOUT);\r\nif (rc < 0)\r\ndev_err(&port->dev, "failed to disable read: %d\n", rc);\r\nusb_serial_generic_close(port);\r\n}\r\nstatic int klsi_105_prepare_write_buffer(struct usb_serial_port *port,\r\nvoid *dest, size_t size)\r\n{\r\nunsigned char *buf = dest;\r\nint count;\r\ncount = kfifo_out_locked(&port->write_fifo, buf + KLSI_HDR_LEN, size,\r\n&port->lock);\r\nput_unaligned_le16(count, buf);\r\nreturn count + KLSI_HDR_LEN;\r\n}\r\nstatic void klsi_105_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned len;\r\nif (!urb->actual_length)\r\nreturn;\r\nif (urb->actual_length <= KLSI_HDR_LEN) {\r\ndev_dbg(&port->dev, "%s - malformed packet\n", __func__);\r\nreturn;\r\n}\r\nlen = get_unaligned_le16(data);\r\nif (len > urb->actual_length - KLSI_HDR_LEN) {\r\ndev_dbg(&port->dev, "%s - packet length mismatch\n", __func__);\r\nlen = urb->actual_length - KLSI_HDR_LEN;\r\n}\r\ntty_insert_flip_string(&port->port, data + KLSI_HDR_LEN, len);\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic void klsi_105_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct klsi_105_private *priv = usb_get_serial_port_data(port);\r\nstruct device *dev = &port->dev;\r\nunsigned int iflag = tty->termios.c_iflag;\r\nunsigned int old_iflag = old_termios->c_iflag;\r\nunsigned int cflag = tty->termios.c_cflag;\r\nunsigned int old_cflag = old_termios->c_cflag;\r\nstruct klsi_105_port_settings *cfg;\r\nunsigned long flags;\r\nspeed_t baud;\r\ncfg = kmalloc(sizeof(*cfg), GFP_KERNEL);\r\nif (!cfg)\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nbaud = tty_get_baud_rate(tty);\r\nif ((cflag & CBAUD) != (old_cflag & CBAUD)) {\r\nif ((old_cflag & CBAUD) == B0) {\r\ndev_dbg(dev, "%s: baud was B0\n", __func__);\r\n#if 0\r\npriv->control_state |= TIOCM_DTR;\r\nif (!(old_cflag & CRTSCTS))\r\npriv->control_state |= TIOCM_RTS;\r\nmct_u232_set_modem_ctrl(serial, priv->control_state);\r\n#endif\r\n}\r\n}\r\nswitch (baud) {\r\ncase 0:\r\nbreak;\r\ncase 1200:\r\npriv->cfg.baudrate = kl5kusb105a_sio_b1200;\r\nbreak;\r\ncase 2400:\r\npriv->cfg.baudrate = kl5kusb105a_sio_b2400;\r\nbreak;\r\ncase 4800:\r\npriv->cfg.baudrate = kl5kusb105a_sio_b4800;\r\nbreak;\r\ncase 9600:\r\npriv->cfg.baudrate = kl5kusb105a_sio_b9600;\r\nbreak;\r\ncase 19200:\r\npriv->cfg.baudrate = kl5kusb105a_sio_b19200;\r\nbreak;\r\ncase 38400:\r\npriv->cfg.baudrate = kl5kusb105a_sio_b38400;\r\nbreak;\r\ncase 57600:\r\npriv->cfg.baudrate = kl5kusb105a_sio_b57600;\r\nbreak;\r\ncase 115200:\r\npriv->cfg.baudrate = kl5kusb105a_sio_b115200;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "unsupported baudrate, using 9600\n");\r\npriv->cfg.baudrate = kl5kusb105a_sio_b9600;\r\nbaud = 9600;\r\nbreak;\r\n}\r\nif ((cflag & CBAUD) == B0) {\r\ndev_dbg(dev, "%s: baud is B0\n", __func__);\r\n;\r\n#if 0\r\npriv->control_state &= ~(TIOCM_DTR | TIOCM_RTS);\r\nmct_u232_set_modem_ctrl(serial, priv->control_state);\r\n#endif\r\n}\r\ntty_encode_baud_rate(tty, baud, baud);\r\nif ((cflag & CSIZE) != (old_cflag & CSIZE)) {\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\ndev_dbg(dev, "%s - 5 bits/byte not supported\n", __func__);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ngoto err;\r\ncase CS6:\r\ndev_dbg(dev, "%s - 6 bits/byte not supported\n", __func__);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ngoto err;\r\ncase CS7:\r\npriv->cfg.databits = kl5kusb105a_dtb_7;\r\nbreak;\r\ncase CS8:\r\npriv->cfg.databits = kl5kusb105a_dtb_8;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "CSIZE was not CS5-CS8, using default of 8\n");\r\npriv->cfg.databits = kl5kusb105a_dtb_8;\r\nbreak;\r\n}\r\n}\r\nif ((cflag & (PARENB|PARODD)) != (old_cflag & (PARENB|PARODD))\r\n|| (cflag & CSTOPB) != (old_cflag & CSTOPB)) {\r\ntty->termios.c_cflag &= ~(PARENB|PARODD|CSTOPB);\r\n#if 0\r\npriv->last_lcr = 0;\r\nif (cflag & PARENB)\r\npriv->last_lcr |= (cflag & PARODD) ?\r\nMCT_U232_PARITY_ODD : MCT_U232_PARITY_EVEN;\r\nelse\r\npriv->last_lcr |= MCT_U232_PARITY_NONE;\r\npriv->last_lcr |= (cflag & CSTOPB) ?\r\nMCT_U232_STOP_BITS_2 : MCT_U232_STOP_BITS_1;\r\nmct_u232_set_line_ctrl(serial, priv->last_lcr);\r\n#endif\r\n;\r\n}\r\nif ((iflag & IXOFF) != (old_iflag & IXOFF)\r\n|| (iflag & IXON) != (old_iflag & IXON)\r\n|| (cflag & CRTSCTS) != (old_cflag & CRTSCTS)) {\r\ntty->termios.c_cflag &= ~CRTSCTS;\r\n#if 0\r\nif ((iflag & IXOFF) || (iflag & IXON) || (cflag & CRTSCTS))\r\npriv->control_state |= TIOCM_DTR | TIOCM_RTS;\r\nelse\r\npriv->control_state &= ~(TIOCM_DTR | TIOCM_RTS);\r\nmct_u232_set_modem_ctrl(serial, priv->control_state);\r\n#endif\r\n;\r\n}\r\nmemcpy(cfg, &priv->cfg, sizeof(*cfg));\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nklsi_105_chg_port_settings(port, cfg);\r\nerr:\r\nkfree(cfg);\r\n}\r\nstatic int klsi_105_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct klsi_105_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nint rc;\r\nunsigned long line_state;\r\nrc = klsi_105_get_line_state(port, &line_state);\r\nif (rc < 0) {\r\ndev_err(&port->dev,\r\n"Reading line control failed (error = %d)\n", rc);\r\nreturn rc;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->line_state = line_state;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(&port->dev, "%s - read line state 0x%lx\n", __func__, line_state);\r\nreturn (int)line_state;\r\n}\r\nstatic int klsi_105_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nint retval = -EINVAL;\r\nreturn retval;\r\n}
