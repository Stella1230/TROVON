static enum hrtimer_restart hrtimer_event(struct hrtimer *timer)\r\n{\r\nstruct timespec expire_time, ts1, ts2, ts3, dts;\r\nstruct pps_generator_pp *dev;\r\nstruct parport *port;\r\nlong lim, delta;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ngetnstimeofday(&ts1);\r\nexpire_time = ktime_to_timespec(hrtimer_get_softexpires(timer));\r\ndev = container_of(timer, struct pps_generator_pp, timer);\r\nlim = NSEC_PER_SEC - send_delay - dev->port_write_time;\r\nif (expire_time.tv_sec != ts1.tv_sec || ts1.tv_nsec > lim) {\r\nlocal_irq_restore(flags);\r\npr_err("we are late this time %ld.%09ld\n",\r\nts1.tv_sec, ts1.tv_nsec);\r\ngoto done;\r\n}\r\ndo {\r\ngetnstimeofday(&ts2);\r\n} while (expire_time.tv_sec == ts2.tv_sec && ts2.tv_nsec < lim);\r\nport = dev->pardev->port;\r\nport->ops->write_control(port, SIGNAL);\r\nlim = NSEC_PER_SEC - dev->port_write_time;\r\ndo {\r\ngetnstimeofday(&ts2);\r\n} while (expire_time.tv_sec == ts2.tv_sec && ts2.tv_nsec < lim);\r\nport->ops->write_control(port, NO_SIGNAL);\r\ngetnstimeofday(&ts3);\r\nlocal_irq_restore(flags);\r\ndts = timespec_sub(ts3, ts2);\r\ndev->port_write_time =\r\n(dev->port_write_time + timespec_to_ns(&dts)) >> 1;\r\ndone:\r\ndts = timespec_sub(ts1, expire_time);\r\ndelta = timespec_to_ns(&dts);\r\nif (delta >= hrtimer_error)\r\nhrtimer_error = delta;\r\nelse\r\nhrtimer_error = (3 * hrtimer_error + delta) >> 2;\r\nhrtimer_set_expires(timer,\r\nktime_set(expire_time.tv_sec + 1,\r\nNSEC_PER_SEC - (send_delay +\r\ndev->port_write_time + SAFETY_INTERVAL +\r\n2 * hrtimer_error)));\r\nreturn HRTIMER_RESTART;\r\n}\r\nstatic void calibrate_port(struct pps_generator_pp *dev)\r\n{\r\nstruct parport *port = dev->pardev->port;\r\nint i;\r\nlong acc = 0;\r\nfor (i = 0; i < (1 << PORT_NTESTS_SHIFT); i++) {\r\nstruct timespec a, b;\r\nunsigned long irq_flags;\r\nlocal_irq_save(irq_flags);\r\ngetnstimeofday(&a);\r\nport->ops->write_control(port, NO_SIGNAL);\r\ngetnstimeofday(&b);\r\nlocal_irq_restore(irq_flags);\r\nb = timespec_sub(b, a);\r\nacc += timespec_to_ns(&b);\r\n}\r\ndev->port_write_time = acc >> PORT_NTESTS_SHIFT;\r\npr_info("port write takes %ldns\n", dev->port_write_time);\r\n}\r\nstatic inline ktime_t next_intr_time(struct pps_generator_pp *dev)\r\n{\r\nstruct timespec ts;\r\ngetnstimeofday(&ts);\r\nreturn ktime_set(ts.tv_sec +\r\n((ts.tv_nsec > 990 * NSEC_PER_MSEC) ? 1 : 0),\r\nNSEC_PER_SEC - (send_delay +\r\ndev->port_write_time + 3 * SAFETY_INTERVAL));\r\n}\r\nstatic void parport_attach(struct parport *port)\r\n{\r\nif (attached) {\r\nreturn;\r\n}\r\ndevice.pardev = parport_register_device(port, KBUILD_MODNAME,\r\nNULL, NULL, NULL, PARPORT_FLAG_EXCL, &device);\r\nif (!device.pardev) {\r\npr_err("couldn't register with %s\n", port->name);\r\nreturn;\r\n}\r\nif (parport_claim_or_block(device.pardev) < 0) {\r\npr_err("couldn't claim %s\n", port->name);\r\ngoto err_unregister_dev;\r\n}\r\npr_info("attached to %s\n", port->name);\r\nattached = 1;\r\ncalibrate_port(&device);\r\nhrtimer_init(&device.timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);\r\ndevice.timer.function = hrtimer_event;\r\nhrtimer_start(&device.timer, next_intr_time(&device), HRTIMER_MODE_ABS);\r\nreturn;\r\nerr_unregister_dev:\r\nparport_unregister_device(device.pardev);\r\n}\r\nstatic void parport_detach(struct parport *port)\r\n{\r\nif (port->cad != device.pardev)\r\nreturn;\r\nhrtimer_cancel(&device.timer);\r\nparport_release(device.pardev);\r\nparport_unregister_device(device.pardev);\r\n}\r\nstatic int __init pps_gen_parport_init(void)\r\n{\r\nint ret;\r\npr_info(DRVDESC "\n");\r\nif (send_delay > SEND_DELAY_MAX) {\r\npr_err("delay value should be not greater"\r\n" then %d\n", SEND_DELAY_MAX);\r\nreturn -EINVAL;\r\n}\r\nret = parport_register_driver(&pps_gen_parport_driver);\r\nif (ret) {\r\npr_err("unable to register with parport\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit pps_gen_parport_exit(void)\r\n{\r\nparport_unregister_driver(&pps_gen_parport_driver);\r\npr_info("hrtimer avg error is %ldns\n", hrtimer_error);\r\n}
