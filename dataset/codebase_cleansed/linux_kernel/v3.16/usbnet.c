int usbnet_get_endpoints(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint tmp;\r\nstruct usb_host_interface *alt = NULL;\r\nstruct usb_host_endpoint *in = NULL, *out = NULL;\r\nstruct usb_host_endpoint *status = NULL;\r\nfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\r\nunsigned ep;\r\nin = out = status = NULL;\r\nalt = intf->altsetting + tmp;\r\nfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\r\nstruct usb_host_endpoint *e;\r\nint intr = 0;\r\ne = alt->endpoint + ep;\r\nswitch (e->desc.bmAttributes) {\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (!usb_endpoint_dir_in(&e->desc))\r\ncontinue;\r\nintr = 1;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (usb_endpoint_dir_in(&e->desc)) {\r\nif (!intr && !in)\r\nin = e;\r\nelse if (intr && !status)\r\nstatus = e;\r\n} else {\r\nif (!out)\r\nout = e;\r\n}\r\n}\r\nif (in && out)\r\nbreak;\r\n}\r\nif (!alt || !in || !out)\r\nreturn -EINVAL;\r\nif (alt->desc.bAlternateSetting != 0 ||\r\n!(dev->driver_info->flags & FLAG_NO_SETINT)) {\r\ntmp = usb_set_interface (dev->udev, alt->desc.bInterfaceNumber,\r\nalt->desc.bAlternateSetting);\r\nif (tmp < 0)\r\nreturn tmp;\r\n}\r\ndev->in = usb_rcvbulkpipe (dev->udev,\r\nin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\ndev->out = usb_sndbulkpipe (dev->udev,\r\nout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\ndev->status = status;\r\nreturn 0;\r\n}\r\nint usbnet_get_ethernet_addr(struct usbnet *dev, int iMACAddress)\r\n{\r\nint tmp, i;\r\nunsigned char buf [13];\r\ntmp = usb_string(dev->udev, iMACAddress, buf, sizeof buf);\r\nif (tmp != 12) {\r\ndev_dbg(&dev->udev->dev,\r\n"bad MAC string %d fetch, %d\n", iMACAddress, tmp);\r\nif (tmp >= 0)\r\ntmp = -EINVAL;\r\nreturn tmp;\r\n}\r\nfor (i = tmp = 0; i < 6; i++, tmp += 2)\r\ndev->net->dev_addr [i] =\r\n(hex_to_bin(buf[tmp]) << 4) + hex_to_bin(buf[tmp + 1]);\r\nreturn 0;\r\n}\r\nstatic void intr_complete (struct urb *urb)\r\n{\r\nstruct usbnet *dev = urb->context;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\ndev->driver_info->status(dev, urb);\r\nbreak;\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nnetif_dbg(dev, ifdown, dev->net,\r\n"intr shutdown, code %d\n", status);\r\nreturn;\r\ndefault:\r\nnetdev_dbg(dev->net, "intr status %d\n", status);\r\nbreak;\r\n}\r\nstatus = usb_submit_urb (urb, GFP_ATOMIC);\r\nif (status != 0)\r\nnetif_err(dev, timer, dev->net,\r\n"intr resubmit --> %d\n", status);\r\n}\r\nstatic int init_status (struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nchar *buf = NULL;\r\nunsigned pipe = 0;\r\nunsigned maxp;\r\nunsigned period;\r\nif (!dev->driver_info->status)\r\nreturn 0;\r\npipe = usb_rcvintpipe (dev->udev,\r\ndev->status->desc.bEndpointAddress\r\n& USB_ENDPOINT_NUMBER_MASK);\r\nmaxp = usb_maxpacket (dev->udev, pipe, 0);\r\nperiod = max ((int) dev->status->desc.bInterval,\r\n(dev->udev->speed == USB_SPEED_HIGH) ? 7 : 3);\r\nbuf = kmalloc (maxp, GFP_KERNEL);\r\nif (buf) {\r\ndev->interrupt = usb_alloc_urb (0, GFP_KERNEL);\r\nif (!dev->interrupt) {\r\nkfree (buf);\r\nreturn -ENOMEM;\r\n} else {\r\nusb_fill_int_urb(dev->interrupt, dev->udev, pipe,\r\nbuf, maxp, intr_complete, dev, period);\r\ndev->interrupt->transfer_flags |= URB_FREE_BUFFER;\r\ndev_dbg(&intf->dev,\r\n"status ep%din, %d bytes period %d\n",\r\nusb_pipeendpoint(pipe), maxp, period);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint usbnet_status_start(struct usbnet *dev, gfp_t mem_flags)\r\n{\r\nint ret = 0;\r\nWARN_ON_ONCE(dev->interrupt == NULL);\r\nif (dev->interrupt) {\r\nmutex_lock(&dev->interrupt_mutex);\r\nif (++dev->interrupt_count == 1)\r\nret = usb_submit_urb(dev->interrupt, mem_flags);\r\ndev_dbg(&dev->udev->dev, "incremented interrupt URB count to %d\n",\r\ndev->interrupt_count);\r\nmutex_unlock(&dev->interrupt_mutex);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __usbnet_status_start_force(struct usbnet *dev, gfp_t mem_flags)\r\n{\r\nint ret = 0;\r\nmutex_lock(&dev->interrupt_mutex);\r\nif (dev->interrupt_count) {\r\nret = usb_submit_urb(dev->interrupt, mem_flags);\r\ndev_dbg(&dev->udev->dev,\r\n"submitted interrupt URB for resume\n");\r\n}\r\nmutex_unlock(&dev->interrupt_mutex);\r\nreturn ret;\r\n}\r\nvoid usbnet_status_stop(struct usbnet *dev)\r\n{\r\nif (dev->interrupt) {\r\nmutex_lock(&dev->interrupt_mutex);\r\nWARN_ON(dev->interrupt_count == 0);\r\nif (dev->interrupt_count && --dev->interrupt_count == 0)\r\nusb_kill_urb(dev->interrupt);\r\ndev_dbg(&dev->udev->dev,\r\n"decremented interrupt URB count to %d\n",\r\ndev->interrupt_count);\r\nmutex_unlock(&dev->interrupt_mutex);\r\n}\r\n}\r\nstatic void __usbnet_status_stop_force(struct usbnet *dev)\r\n{\r\nif (dev->interrupt) {\r\nmutex_lock(&dev->interrupt_mutex);\r\nusb_kill_urb(dev->interrupt);\r\ndev_dbg(&dev->udev->dev, "killed interrupt URB for suspend\n");\r\nmutex_unlock(&dev->interrupt_mutex);\r\n}\r\n}\r\nvoid usbnet_skb_return (struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nint status;\r\nif (test_bit(EVENT_RX_PAUSED, &dev->flags)) {\r\nskb_queue_tail(&dev->rxq_pause, skb);\r\nreturn;\r\n}\r\nskb->protocol = eth_type_trans (skb, dev->net);\r\ndev->net->stats.rx_packets++;\r\ndev->net->stats.rx_bytes += skb->len;\r\nnetif_dbg(dev, rx_status, dev->net, "< rx, len %zu, type 0x%x\n",\r\nskb->len + sizeof (struct ethhdr), skb->protocol);\r\nmemset (skb->cb, 0, sizeof (struct skb_data));\r\nif (skb_defer_rx_timestamp(skb))\r\nreturn;\r\nstatus = netif_rx (skb);\r\nif (status != NET_RX_SUCCESS)\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"netif_rx status %d\n", status);\r\n}\r\nvoid usbnet_update_max_qlen(struct usbnet *dev)\r\n{\r\nenum usb_device_speed speed = dev->udev->speed;\r\nswitch (speed) {\r\ncase USB_SPEED_HIGH:\r\ndev->rx_qlen = MAX_QUEUE_MEMORY / dev->rx_urb_size;\r\ndev->tx_qlen = MAX_QUEUE_MEMORY / dev->hard_mtu;\r\nbreak;\r\ncase USB_SPEED_SUPER:\r\ndev->rx_qlen = 5 * MAX_QUEUE_MEMORY / dev->rx_urb_size;\r\ndev->tx_qlen = 5 * MAX_QUEUE_MEMORY / dev->hard_mtu;\r\nbreak;\r\ndefault:\r\ndev->rx_qlen = dev->tx_qlen = 4;\r\n}\r\n}\r\nint usbnet_change_mtu (struct net_device *net, int new_mtu)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nint ll_mtu = new_mtu + net->hard_header_len;\r\nint old_hard_mtu = dev->hard_mtu;\r\nint old_rx_urb_size = dev->rx_urb_size;\r\nif (new_mtu <= 0)\r\nreturn -EINVAL;\r\nif ((ll_mtu % dev->maxpacket) == 0)\r\nreturn -EDOM;\r\nnet->mtu = new_mtu;\r\ndev->hard_mtu = net->mtu + net->hard_header_len;\r\nif (dev->rx_urb_size == old_hard_mtu) {\r\ndev->rx_urb_size = dev->hard_mtu;\r\nif (dev->rx_urb_size > old_rx_urb_size)\r\nusbnet_unlink_rx_urbs(dev);\r\n}\r\nusbnet_update_max_qlen(dev);\r\nreturn 0;\r\n}\r\nstatic void __usbnet_queue_skb(struct sk_buff_head *list,\r\nstruct sk_buff *newsk, enum skb_state state)\r\n{\r\nstruct skb_data *entry = (struct skb_data *) newsk->cb;\r\n__skb_queue_tail(list, newsk);\r\nentry->state = state;\r\n}\r\nstatic enum skb_state defer_bh(struct usbnet *dev, struct sk_buff *skb,\r\nstruct sk_buff_head *list, enum skb_state state)\r\n{\r\nunsigned long flags;\r\nenum skb_state old_state;\r\nstruct skb_data *entry = (struct skb_data *) skb->cb;\r\nspin_lock_irqsave(&list->lock, flags);\r\nold_state = entry->state;\r\nentry->state = state;\r\n__skb_unlink(skb, list);\r\nspin_unlock(&list->lock);\r\nspin_lock(&dev->done.lock);\r\n__skb_queue_tail(&dev->done, skb);\r\nif (dev->done.qlen == 1)\r\ntasklet_schedule(&dev->bh);\r\nspin_unlock_irqrestore(&dev->done.lock, flags);\r\nreturn old_state;\r\n}\r\nvoid usbnet_defer_kevent (struct usbnet *dev, int work)\r\n{\r\nset_bit (work, &dev->flags);\r\nif (!schedule_work (&dev->kevent)) {\r\nif (net_ratelimit())\r\nnetdev_err(dev->net, "kevent %d may have been dropped\n", work);\r\n} else {\r\nnetdev_dbg(dev->net, "kevent %d scheduled\n", work);\r\n}\r\n}\r\nstatic int rx_submit (struct usbnet *dev, struct urb *urb, gfp_t flags)\r\n{\r\nstruct sk_buff *skb;\r\nstruct skb_data *entry;\r\nint retval = 0;\r\nunsigned long lockflags;\r\nsize_t size = dev->rx_urb_size;\r\nif (test_bit(EVENT_RX_KILL, &dev->flags)) {\r\nusb_free_urb(urb);\r\nreturn -ENOLINK;\r\n}\r\nskb = __netdev_alloc_skb_ip_align(dev->net, size, flags);\r\nif (!skb) {\r\nnetif_dbg(dev, rx_err, dev->net, "no rx skb\n");\r\nusbnet_defer_kevent (dev, EVENT_RX_MEMORY);\r\nusb_free_urb (urb);\r\nreturn -ENOMEM;\r\n}\r\nentry = (struct skb_data *) skb->cb;\r\nentry->urb = urb;\r\nentry->dev = dev;\r\nentry->length = 0;\r\nusb_fill_bulk_urb (urb, dev->udev, dev->in,\r\nskb->data, size, rx_complete, skb);\r\nspin_lock_irqsave (&dev->rxq.lock, lockflags);\r\nif (netif_running (dev->net) &&\r\nnetif_device_present (dev->net) &&\r\n!test_bit (EVENT_RX_HALT, &dev->flags) &&\r\n!test_bit (EVENT_DEV_ASLEEP, &dev->flags)) {\r\nswitch (retval = usb_submit_urb (urb, GFP_ATOMIC)) {\r\ncase -EPIPE:\r\nusbnet_defer_kevent (dev, EVENT_RX_HALT);\r\nbreak;\r\ncase -ENOMEM:\r\nusbnet_defer_kevent (dev, EVENT_RX_MEMORY);\r\nbreak;\r\ncase -ENODEV:\r\nnetif_dbg(dev, ifdown, dev->net, "device gone\n");\r\nnetif_device_detach (dev->net);\r\nbreak;\r\ncase -EHOSTUNREACH:\r\nretval = -ENOLINK;\r\nbreak;\r\ndefault:\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"rx submit, %d\n", retval);\r\ntasklet_schedule (&dev->bh);\r\nbreak;\r\ncase 0:\r\n__usbnet_queue_skb(&dev->rxq, skb, rx_start);\r\n}\r\n} else {\r\nnetif_dbg(dev, ifdown, dev->net, "rx: stopped\n");\r\nretval = -ENOLINK;\r\n}\r\nspin_unlock_irqrestore (&dev->rxq.lock, lockflags);\r\nif (retval) {\r\ndev_kfree_skb_any (skb);\r\nusb_free_urb (urb);\r\n}\r\nreturn retval;\r\n}\r\nstatic inline void rx_process (struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nif (dev->driver_info->rx_fixup &&\r\n!dev->driver_info->rx_fixup (dev, skb)) {\r\nif (!(dev->driver_info->flags & FLAG_RX_ASSEMBLE))\r\ndev->net->stats.rx_errors++;\r\ngoto done;\r\n}\r\nif (dev->driver_info->flags & FLAG_MULTI_PACKET)\r\ngoto done;\r\nif (skb->len < ETH_HLEN) {\r\ndev->net->stats.rx_errors++;\r\ndev->net->stats.rx_length_errors++;\r\nnetif_dbg(dev, rx_err, dev->net, "rx length %d\n", skb->len);\r\n} else {\r\nusbnet_skb_return(dev, skb);\r\nreturn;\r\n}\r\ndone:\r\nskb_queue_tail(&dev->done, skb);\r\n}\r\nstatic void rx_complete (struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct skb_data *entry = (struct skb_data *) skb->cb;\r\nstruct usbnet *dev = entry->dev;\r\nint urb_status = urb->status;\r\nenum skb_state state;\r\nskb_put (skb, urb->actual_length);\r\nstate = rx_done;\r\nentry->urb = NULL;\r\nswitch (urb_status) {\r\ncase 0:\r\nbreak;\r\ncase -EPIPE:\r\ndev->net->stats.rx_errors++;\r\nusbnet_defer_kevent (dev, EVENT_RX_HALT);\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nnetif_dbg(dev, ifdown, dev->net,\r\n"rx shutdown, code %d\n", urb_status);\r\ngoto block;\r\ncase -EPROTO:\r\ncase -ETIME:\r\ncase -EILSEQ:\r\ndev->net->stats.rx_errors++;\r\nif (!timer_pending (&dev->delay)) {\r\nmod_timer (&dev->delay, jiffies + THROTTLE_JIFFIES);\r\nnetif_dbg(dev, link, dev->net,\r\n"rx throttle %d\n", urb_status);\r\n}\r\nblock:\r\nstate = rx_cleanup;\r\nentry->urb = urb;\r\nurb = NULL;\r\nbreak;\r\ncase -EOVERFLOW:\r\ndev->net->stats.rx_over_errors++;\r\ndefault:\r\nstate = rx_cleanup;\r\ndev->net->stats.rx_errors++;\r\nnetif_dbg(dev, rx_err, dev->net, "rx status %d\n", urb_status);\r\nbreak;\r\n}\r\nif (++dev->pkt_cnt > 30) {\r\ndev->pkt_cnt = 0;\r\ndev->pkt_err = 0;\r\n} else {\r\nif (state == rx_cleanup)\r\ndev->pkt_err++;\r\nif (dev->pkt_err > 20)\r\nset_bit(EVENT_RX_KILL, &dev->flags);\r\n}\r\nstate = defer_bh(dev, skb, &dev->rxq, state);\r\nif (urb) {\r\nif (netif_running (dev->net) &&\r\n!test_bit (EVENT_RX_HALT, &dev->flags) &&\r\nstate != unlink_start) {\r\nrx_submit (dev, urb, GFP_ATOMIC);\r\nusb_mark_last_busy(dev->udev);\r\nreturn;\r\n}\r\nusb_free_urb (urb);\r\n}\r\nnetif_dbg(dev, rx_err, dev->net, "no read resubmitted\n");\r\n}\r\nvoid usbnet_pause_rx(struct usbnet *dev)\r\n{\r\nset_bit(EVENT_RX_PAUSED, &dev->flags);\r\nnetif_dbg(dev, rx_status, dev->net, "paused rx queue enabled\n");\r\n}\r\nvoid usbnet_resume_rx(struct usbnet *dev)\r\n{\r\nstruct sk_buff *skb;\r\nint num = 0;\r\nclear_bit(EVENT_RX_PAUSED, &dev->flags);\r\nwhile ((skb = skb_dequeue(&dev->rxq_pause)) != NULL) {\r\nusbnet_skb_return(dev, skb);\r\nnum++;\r\n}\r\ntasklet_schedule(&dev->bh);\r\nnetif_dbg(dev, rx_status, dev->net,\r\n"paused rx queue disabled, %d skbs requeued\n", num);\r\n}\r\nvoid usbnet_purge_paused_rxq(struct usbnet *dev)\r\n{\r\nskb_queue_purge(&dev->rxq_pause);\r\n}\r\nstatic int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)\r\n{\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nint count = 0;\r\nspin_lock_irqsave (&q->lock, flags);\r\nwhile (!skb_queue_empty(q)) {\r\nstruct skb_data *entry;\r\nstruct urb *urb;\r\nint retval;\r\nskb_queue_walk(q, skb) {\r\nentry = (struct skb_data *) skb->cb;\r\nif (entry->state != unlink_start)\r\ngoto found;\r\n}\r\nbreak;\r\nfound:\r\nentry->state = unlink_start;\r\nurb = entry->urb;\r\nusb_get_urb(urb);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\nretval = usb_unlink_urb (urb);\r\nif (retval != -EINPROGRESS && retval != 0)\r\nnetdev_dbg(dev->net, "unlink urb err, %d\n", retval);\r\nelse\r\ncount++;\r\nusb_put_urb(urb);\r\nspin_lock_irqsave(&q->lock, flags);\r\n}\r\nspin_unlock_irqrestore (&q->lock, flags);\r\nreturn count;\r\n}\r\nvoid usbnet_unlink_rx_urbs(struct usbnet *dev)\r\n{\r\nif (netif_running(dev->net)) {\r\n(void) unlink_urbs (dev, &dev->rxq);\r\ntasklet_schedule(&dev->bh);\r\n}\r\n}\r\nstatic void usbnet_terminate_urbs(struct usbnet *dev)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nint temp;\r\nadd_wait_queue(&dev->wait, &wait);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\ntemp = unlink_urbs(dev, &dev->txq) +\r\nunlink_urbs(dev, &dev->rxq);\r\nwhile (!skb_queue_empty(&dev->rxq)\r\n&& !skb_queue_empty(&dev->txq)\r\n&& !skb_queue_empty(&dev->done)) {\r\nschedule_timeout(msecs_to_jiffies(UNLINK_TIMEOUT_MS));\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nnetif_dbg(dev, ifdown, dev->net,\r\n"waited for %d urb completions\n", temp);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&dev->wait, &wait);\r\n}\r\nint usbnet_stop (struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct driver_info *info = dev->driver_info;\r\nint retval, pm;\r\nclear_bit(EVENT_DEV_OPEN, &dev->flags);\r\nnetif_stop_queue (net);\r\nnetif_info(dev, ifdown, dev->net,\r\n"stop stats: rx/tx %lu/%lu, errs %lu/%lu\n",\r\nnet->stats.rx_packets, net->stats.tx_packets,\r\nnet->stats.rx_errors, net->stats.tx_errors);\r\npm = usb_autopm_get_interface(dev->intf);\r\nif (info->stop) {\r\nretval = info->stop(dev);\r\nif (retval < 0)\r\nnetif_info(dev, ifdown, dev->net,\r\n"stop fail (%d) usbnet usb-%s-%s, %s\n",\r\nretval,\r\ndev->udev->bus->bus_name, dev->udev->devpath,\r\ninfo->description);\r\n}\r\nif (!(info->flags & FLAG_AVOID_UNLINK_URBS))\r\nusbnet_terminate_urbs(dev);\r\nusbnet_status_stop(dev);\r\nusbnet_purge_paused_rxq(dev);\r\ndev->flags = 0;\r\ndel_timer_sync (&dev->delay);\r\ntasklet_kill (&dev->bh);\r\nif (!pm)\r\nusb_autopm_put_interface(dev->intf);\r\nif (info->manage_power &&\r\n!test_and_clear_bit(EVENT_NO_RUNTIME_PM, &dev->flags))\r\ninfo->manage_power(dev, 0);\r\nelse\r\nusb_autopm_put_interface(dev->intf);\r\nreturn 0;\r\n}\r\nint usbnet_open (struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nint retval;\r\nstruct driver_info *info = dev->driver_info;\r\nif ((retval = usb_autopm_get_interface(dev->intf)) < 0) {\r\nnetif_info(dev, ifup, dev->net,\r\n"resumption fail (%d) usbnet usb-%s-%s, %s\n",\r\nretval,\r\ndev->udev->bus->bus_name,\r\ndev->udev->devpath,\r\ninfo->description);\r\ngoto done_nopm;\r\n}\r\nif (info->reset && (retval = info->reset (dev)) < 0) {\r\nnetif_info(dev, ifup, dev->net,\r\n"open reset fail (%d) usbnet usb-%s-%s, %s\n",\r\nretval,\r\ndev->udev->bus->bus_name,\r\ndev->udev->devpath,\r\ninfo->description);\r\ngoto done;\r\n}\r\nusbnet_update_max_qlen(dev);\r\nif (info->check_connect && (retval = info->check_connect (dev)) < 0) {\r\nnetif_dbg(dev, ifup, dev->net, "can't open; %d\n", retval);\r\ngoto done;\r\n}\r\nif (dev->interrupt) {\r\nretval = usbnet_status_start(dev, GFP_KERNEL);\r\nif (retval < 0) {\r\nnetif_err(dev, ifup, dev->net,\r\n"intr submit %d\n", retval);\r\ngoto done;\r\n}\r\n}\r\nset_bit(EVENT_DEV_OPEN, &dev->flags);\r\nnetif_start_queue (net);\r\nnetif_info(dev, ifup, dev->net,\r\n"open: enable queueing (rx %d, tx %d) mtu %d %s framing\n",\r\n(int)RX_QLEN(dev), (int)TX_QLEN(dev),\r\ndev->net->mtu,\r\n(dev->driver_info->flags & FLAG_FRAMING_NC) ? "NetChip" :\r\n(dev->driver_info->flags & FLAG_FRAMING_GL) ? "GeneSys" :\r\n(dev->driver_info->flags & FLAG_FRAMING_Z) ? "Zaurus" :\r\n(dev->driver_info->flags & FLAG_FRAMING_RN) ? "RNDIS" :\r\n(dev->driver_info->flags & FLAG_FRAMING_AX) ? "ASIX" :\r\n"simple");\r\ndev->pkt_cnt = 0;\r\ndev->pkt_err = 0;\r\nclear_bit(EVENT_RX_KILL, &dev->flags);\r\ntasklet_schedule (&dev->bh);\r\nif (info->manage_power) {\r\nretval = info->manage_power(dev, 1);\r\nif (retval < 0) {\r\nretval = 0;\r\nset_bit(EVENT_NO_RUNTIME_PM, &dev->flags);\r\n} else {\r\nusb_autopm_put_interface(dev->intf);\r\n}\r\n}\r\nreturn retval;\r\ndone:\r\nusb_autopm_put_interface(dev->intf);\r\ndone_nopm:\r\nreturn retval;\r\n}\r\nint usbnet_get_settings (struct net_device *net, struct ethtool_cmd *cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nif (!dev->mii.mdio_read)\r\nreturn -EOPNOTSUPP;\r\nreturn mii_ethtool_gset(&dev->mii, cmd);\r\n}\r\nint usbnet_set_settings (struct net_device *net, struct ethtool_cmd *cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nint retval;\r\nif (!dev->mii.mdio_write)\r\nreturn -EOPNOTSUPP;\r\nretval = mii_ethtool_sset(&dev->mii, cmd);\r\nif (dev->driver_info->link_reset)\r\ndev->driver_info->link_reset(dev);\r\nusbnet_update_max_qlen(dev);\r\nreturn retval;\r\n}\r\nu32 usbnet_get_link (struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nif (dev->driver_info->check_connect)\r\nreturn dev->driver_info->check_connect (dev) == 0;\r\nif (dev->mii.mdio_read)\r\nreturn mii_link_ok(&dev->mii);\r\nreturn ethtool_op_get_link(net);\r\n}\r\nint usbnet_nway_reset(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nif (!dev->mii.mdio_write)\r\nreturn -EOPNOTSUPP;\r\nreturn mii_nway_restart(&dev->mii);\r\n}\r\nvoid usbnet_get_drvinfo (struct net_device *net, struct ethtool_drvinfo *info)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstrlcpy (info->driver, dev->driver_name, sizeof info->driver);\r\nstrlcpy (info->version, DRIVER_VERSION, sizeof info->version);\r\nstrlcpy (info->fw_version, dev->driver_info->description,\r\nsizeof info->fw_version);\r\nusb_make_path (dev->udev, info->bus_info, sizeof info->bus_info);\r\n}\r\nu32 usbnet_get_msglevel (struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn dev->msg_enable;\r\n}\r\nvoid usbnet_set_msglevel (struct net_device *net, u32 level)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\ndev->msg_enable = level;\r\n}\r\nstatic void __handle_link_change(struct usbnet *dev)\r\n{\r\nif (!test_bit(EVENT_DEV_OPEN, &dev->flags))\r\nreturn;\r\nif (!netif_carrier_ok(dev->net)) {\r\nunlink_urbs(dev, &dev->rxq);\r\n} else {\r\ntasklet_schedule(&dev->bh);\r\n}\r\nusbnet_update_max_qlen(dev);\r\nclear_bit(EVENT_LINK_CHANGE, &dev->flags);\r\n}\r\nstatic void\r\nkevent (struct work_struct *work)\r\n{\r\nstruct usbnet *dev =\r\ncontainer_of(work, struct usbnet, kevent);\r\nint status;\r\nif (test_bit (EVENT_TX_HALT, &dev->flags)) {\r\nunlink_urbs (dev, &dev->txq);\r\nstatus = usb_autopm_get_interface(dev->intf);\r\nif (status < 0)\r\ngoto fail_pipe;\r\nstatus = usb_clear_halt (dev->udev, dev->out);\r\nusb_autopm_put_interface(dev->intf);\r\nif (status < 0 &&\r\nstatus != -EPIPE &&\r\nstatus != -ESHUTDOWN) {\r\nif (netif_msg_tx_err (dev))\r\nfail_pipe:\r\nnetdev_err(dev->net, "can't clear tx halt, status %d\n",\r\nstatus);\r\n} else {\r\nclear_bit (EVENT_TX_HALT, &dev->flags);\r\nif (status != -ESHUTDOWN)\r\nnetif_wake_queue (dev->net);\r\n}\r\n}\r\nif (test_bit (EVENT_RX_HALT, &dev->flags)) {\r\nunlink_urbs (dev, &dev->rxq);\r\nstatus = usb_autopm_get_interface(dev->intf);\r\nif (status < 0)\r\ngoto fail_halt;\r\nstatus = usb_clear_halt (dev->udev, dev->in);\r\nusb_autopm_put_interface(dev->intf);\r\nif (status < 0 &&\r\nstatus != -EPIPE &&\r\nstatus != -ESHUTDOWN) {\r\nif (netif_msg_rx_err (dev))\r\nfail_halt:\r\nnetdev_err(dev->net, "can't clear rx halt, status %d\n",\r\nstatus);\r\n} else {\r\nclear_bit (EVENT_RX_HALT, &dev->flags);\r\ntasklet_schedule (&dev->bh);\r\n}\r\n}\r\nif (test_bit (EVENT_RX_MEMORY, &dev->flags)) {\r\nstruct urb *urb = NULL;\r\nint resched = 1;\r\nif (netif_running (dev->net))\r\nurb = usb_alloc_urb (0, GFP_KERNEL);\r\nelse\r\nclear_bit (EVENT_RX_MEMORY, &dev->flags);\r\nif (urb != NULL) {\r\nclear_bit (EVENT_RX_MEMORY, &dev->flags);\r\nstatus = usb_autopm_get_interface(dev->intf);\r\nif (status < 0) {\r\nusb_free_urb(urb);\r\ngoto fail_lowmem;\r\n}\r\nif (rx_submit (dev, urb, GFP_KERNEL) == -ENOLINK)\r\nresched = 0;\r\nusb_autopm_put_interface(dev->intf);\r\nfail_lowmem:\r\nif (resched)\r\ntasklet_schedule (&dev->bh);\r\n}\r\n}\r\nif (test_bit (EVENT_LINK_RESET, &dev->flags)) {\r\nstruct driver_info *info = dev->driver_info;\r\nint retval = 0;\r\nclear_bit (EVENT_LINK_RESET, &dev->flags);\r\nstatus = usb_autopm_get_interface(dev->intf);\r\nif (status < 0)\r\ngoto skip_reset;\r\nif(info->link_reset && (retval = info->link_reset(dev)) < 0) {\r\nusb_autopm_put_interface(dev->intf);\r\nskip_reset:\r\nnetdev_info(dev->net, "link reset failed (%d) usbnet usb-%s-%s, %s\n",\r\nretval,\r\ndev->udev->bus->bus_name,\r\ndev->udev->devpath,\r\ninfo->description);\r\n} else {\r\nusb_autopm_put_interface(dev->intf);\r\n}\r\n__handle_link_change(dev);\r\n}\r\nif (test_bit (EVENT_LINK_CHANGE, &dev->flags))\r\n__handle_link_change(dev);\r\nif (dev->flags)\r\nnetdev_dbg(dev->net, "kevent done, flags = 0x%lx\n", dev->flags);\r\n}\r\nstatic void tx_complete (struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct skb_data *entry = (struct skb_data *) skb->cb;\r\nstruct usbnet *dev = entry->dev;\r\nif (urb->status == 0) {\r\nif (!(dev->driver_info->flags & FLAG_MULTI_PACKET))\r\ndev->net->stats.tx_packets++;\r\ndev->net->stats.tx_bytes += entry->length;\r\n} else {\r\ndev->net->stats.tx_errors++;\r\nswitch (urb->status) {\r\ncase -EPIPE:\r\nusbnet_defer_kevent (dev, EVENT_TX_HALT);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nbreak;\r\ncase -EPROTO:\r\ncase -ETIME:\r\ncase -EILSEQ:\r\nusb_mark_last_busy(dev->udev);\r\nif (!timer_pending (&dev->delay)) {\r\nmod_timer (&dev->delay,\r\njiffies + THROTTLE_JIFFIES);\r\nnetif_dbg(dev, link, dev->net,\r\n"tx throttle %d\n", urb->status);\r\n}\r\nnetif_stop_queue (dev->net);\r\nbreak;\r\ndefault:\r\nnetif_dbg(dev, tx_err, dev->net,\r\n"tx err %d\n", entry->urb->status);\r\nbreak;\r\n}\r\n}\r\nusb_autopm_put_interface_async(dev->intf);\r\n(void) defer_bh(dev, skb, &dev->txq, tx_done);\r\n}\r\nvoid usbnet_tx_timeout (struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nunlink_urbs (dev, &dev->txq);\r\ntasklet_schedule (&dev->bh);\r\n}\r\nstatic int build_dma_sg(const struct sk_buff *skb, struct urb *urb)\r\n{\r\nunsigned num_sgs, total_len = 0;\r\nint i, s = 0;\r\nnum_sgs = skb_shinfo(skb)->nr_frags + 1;\r\nif (num_sgs == 1)\r\nreturn 0;\r\nurb->sg = kmalloc((num_sgs + 1) * sizeof(struct scatterlist),\r\nGFP_ATOMIC);\r\nif (!urb->sg)\r\nreturn -ENOMEM;\r\nurb->num_sgs = num_sgs;\r\nsg_init_table(urb->sg, urb->num_sgs + 1);\r\nsg_set_buf(&urb->sg[s++], skb->data, skb_headlen(skb));\r\ntotal_len += skb_headlen(skb);\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nstruct skb_frag_struct *f = &skb_shinfo(skb)->frags[i];\r\ntotal_len += skb_frag_size(f);\r\nsg_set_page(&urb->sg[i + s], f->page.p, f->size,\r\nf->page_offset);\r\n}\r\nurb->transfer_buffer_length = total_len;\r\nreturn 1;\r\n}\r\nnetdev_tx_t usbnet_start_xmit (struct sk_buff *skb,\r\nstruct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nint length;\r\nstruct urb *urb = NULL;\r\nstruct skb_data *entry;\r\nstruct driver_info *info = dev->driver_info;\r\nunsigned long flags;\r\nint retval;\r\nif (skb)\r\nskb_tx_timestamp(skb);\r\nif (info->tx_fixup) {\r\nskb = info->tx_fixup (dev, skb, GFP_ATOMIC);\r\nif (!skb) {\r\nif (info->flags & FLAG_MULTI_PACKET)\r\ngoto not_drop;\r\nnetif_dbg(dev, tx_err, dev->net, "can't tx_fixup skb\n");\r\ngoto drop;\r\n}\r\n}\r\nif (!(urb = usb_alloc_urb (0, GFP_ATOMIC))) {\r\nnetif_dbg(dev, tx_err, dev->net, "no urb\n");\r\ngoto drop;\r\n}\r\nentry = (struct skb_data *) skb->cb;\r\nentry->urb = urb;\r\nentry->dev = dev;\r\nusb_fill_bulk_urb (urb, dev->udev, dev->out,\r\nskb->data, skb->len, tx_complete, skb);\r\nif (dev->can_dma_sg) {\r\nif (build_dma_sg(skb, urb) < 0)\r\ngoto drop;\r\n}\r\nlength = urb->transfer_buffer_length;\r\nif (length % dev->maxpacket == 0) {\r\nif (!(info->flags & FLAG_SEND_ZLP)) {\r\nif (!(info->flags & FLAG_MULTI_PACKET)) {\r\nlength++;\r\nif (skb_tailroom(skb) && !urb->num_sgs) {\r\nskb->data[skb->len] = 0;\r\n__skb_put(skb, 1);\r\n} else if (urb->num_sgs)\r\nsg_set_buf(&urb->sg[urb->num_sgs++],\r\ndev->padding_pkt, 1);\r\n}\r\n} else\r\nurb->transfer_flags |= URB_ZERO_PACKET;\r\n}\r\nentry->length = urb->transfer_buffer_length = length;\r\nspin_lock_irqsave(&dev->txq.lock, flags);\r\nretval = usb_autopm_get_interface_async(dev->intf);\r\nif (retval < 0) {\r\nspin_unlock_irqrestore(&dev->txq.lock, flags);\r\ngoto drop;\r\n}\r\n#ifdef CONFIG_PM\r\nif (test_bit(EVENT_DEV_ASLEEP, &dev->flags)) {\r\nusb_anchor_urb(urb, &dev->deferred);\r\nnetif_stop_queue(net);\r\nusb_put_urb(urb);\r\nspin_unlock_irqrestore(&dev->txq.lock, flags);\r\nnetdev_dbg(dev->net, "Delaying transmission for resumption\n");\r\ngoto deferred;\r\n}\r\n#endif\r\nswitch ((retval = usb_submit_urb (urb, GFP_ATOMIC))) {\r\ncase -EPIPE:\r\nnetif_stop_queue (net);\r\nusbnet_defer_kevent (dev, EVENT_TX_HALT);\r\nusb_autopm_put_interface_async(dev->intf);\r\nbreak;\r\ndefault:\r\nusb_autopm_put_interface_async(dev->intf);\r\nnetif_dbg(dev, tx_err, dev->net,\r\n"tx: submit urb err %d\n", retval);\r\nbreak;\r\ncase 0:\r\nnet->trans_start = jiffies;\r\n__usbnet_queue_skb(&dev->txq, skb, tx_start);\r\nif (dev->txq.qlen >= TX_QLEN (dev))\r\nnetif_stop_queue (net);\r\n}\r\nspin_unlock_irqrestore (&dev->txq.lock, flags);\r\nif (retval) {\r\nnetif_dbg(dev, tx_err, dev->net, "drop, code %d\n", retval);\r\ndrop:\r\ndev->net->stats.tx_dropped++;\r\nnot_drop:\r\nif (skb)\r\ndev_kfree_skb_any (skb);\r\nif (urb) {\r\nkfree(urb->sg);\r\nusb_free_urb(urb);\r\n}\r\n} else\r\nnetif_dbg(dev, tx_queued, dev->net,\r\n"> tx, len %d, type 0x%x\n", length, skb->protocol);\r\n#ifdef CONFIG_PM\r\ndeferred:\r\n#endif\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int rx_alloc_submit(struct usbnet *dev, gfp_t flags)\r\n{\r\nstruct urb *urb;\r\nint i;\r\nint ret = 0;\r\nfor (i = 0; i < 10 && dev->rxq.qlen < RX_QLEN(dev); i++) {\r\nurb = usb_alloc_urb(0, flags);\r\nif (urb != NULL) {\r\nret = rx_submit(dev, urb, flags);\r\nif (ret)\r\ngoto err;\r\n} else {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void usbnet_bh (unsigned long param)\r\n{\r\nstruct usbnet *dev = (struct usbnet *) param;\r\nstruct sk_buff *skb;\r\nstruct skb_data *entry;\r\nwhile ((skb = skb_dequeue (&dev->done))) {\r\nentry = (struct skb_data *) skb->cb;\r\nswitch (entry->state) {\r\ncase rx_done:\r\nentry->state = rx_cleanup;\r\nrx_process (dev, skb);\r\ncontinue;\r\ncase tx_done:\r\nkfree(entry->urb->sg);\r\ncase rx_cleanup:\r\nusb_free_urb (entry->urb);\r\ndev_kfree_skb (skb);\r\ncontinue;\r\ndefault:\r\nnetdev_dbg(dev->net, "bogus skb state %d\n", entry->state);\r\n}\r\n}\r\nclear_bit(EVENT_RX_KILL, &dev->flags);\r\nif (waitqueue_active(&dev->wait)) {\r\nif (dev->txq.qlen + dev->rxq.qlen + dev->done.qlen == 0)\r\nwake_up_all(&dev->wait);\r\n} else if (netif_running (dev->net) &&\r\nnetif_device_present (dev->net) &&\r\nnetif_carrier_ok(dev->net) &&\r\n!timer_pending (&dev->delay) &&\r\n!test_bit (EVENT_RX_HALT, &dev->flags)) {\r\nint temp = dev->rxq.qlen;\r\nif (temp < RX_QLEN(dev)) {\r\nif (rx_alloc_submit(dev, GFP_ATOMIC) == -ENOLINK)\r\nreturn;\r\nif (temp != dev->rxq.qlen)\r\nnetif_dbg(dev, link, dev->net,\r\n"rxqlen %d --> %d\n",\r\ntemp, dev->rxq.qlen);\r\nif (dev->rxq.qlen < RX_QLEN(dev))\r\ntasklet_schedule (&dev->bh);\r\n}\r\nif (dev->txq.qlen < TX_QLEN (dev))\r\nnetif_wake_queue (dev->net);\r\n}\r\n}\r\nvoid usbnet_disconnect (struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev;\r\nstruct usb_device *xdev;\r\nstruct net_device *net;\r\ndev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (!dev)\r\nreturn;\r\nxdev = interface_to_usbdev (intf);\r\nnetif_info(dev, probe, dev->net, "unregister '%s' usb-%s-%s, %s\n",\r\nintf->dev.driver->name,\r\nxdev->bus->bus_name, xdev->devpath,\r\ndev->driver_info->description);\r\nnet = dev->net;\r\nunregister_netdev (net);\r\ncancel_work_sync(&dev->kevent);\r\nusb_scuttle_anchored_urbs(&dev->deferred);\r\nif (dev->driver_info->unbind)\r\ndev->driver_info->unbind (dev, intf);\r\nusb_kill_urb(dev->interrupt);\r\nusb_free_urb(dev->interrupt);\r\nkfree(dev->padding_pkt);\r\nfree_netdev(net);\r\n}\r\nint\r\nusbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod)\r\n{\r\nstruct usbnet *dev;\r\nstruct net_device *net;\r\nstruct usb_host_interface *interface;\r\nstruct driver_info *info;\r\nstruct usb_device *xdev;\r\nint status;\r\nconst char *name;\r\nstruct usb_driver *driver = to_usb_driver(udev->dev.driver);\r\nif (!driver->supports_autosuspend) {\r\ndriver->supports_autosuspend = 1;\r\npm_runtime_enable(&udev->dev);\r\n}\r\nname = udev->dev.driver->name;\r\ninfo = (struct driver_info *) prod->driver_info;\r\nif (!info) {\r\ndev_dbg (&udev->dev, "blacklisted by %s\n", name);\r\nreturn -ENODEV;\r\n}\r\nxdev = interface_to_usbdev (udev);\r\ninterface = udev->cur_altsetting;\r\nstatus = -ENOMEM;\r\nnet = alloc_etherdev(sizeof(*dev));\r\nif (!net)\r\ngoto out;\r\nSET_NETDEV_DEV(net, &udev->dev);\r\ndev = netdev_priv(net);\r\ndev->udev = xdev;\r\ndev->intf = udev;\r\ndev->driver_info = info;\r\ndev->driver_name = name;\r\ndev->msg_enable = netif_msg_init (msg_level, NETIF_MSG_DRV\r\n| NETIF_MSG_PROBE | NETIF_MSG_LINK);\r\ninit_waitqueue_head(&dev->wait);\r\nskb_queue_head_init (&dev->rxq);\r\nskb_queue_head_init (&dev->txq);\r\nskb_queue_head_init (&dev->done);\r\nskb_queue_head_init(&dev->rxq_pause);\r\ndev->bh.func = usbnet_bh;\r\ndev->bh.data = (unsigned long) dev;\r\nINIT_WORK (&dev->kevent, kevent);\r\ninit_usb_anchor(&dev->deferred);\r\ndev->delay.function = usbnet_bh;\r\ndev->delay.data = (unsigned long) dev;\r\ninit_timer (&dev->delay);\r\nmutex_init (&dev->phy_mutex);\r\nmutex_init(&dev->interrupt_mutex);\r\ndev->interrupt_count = 0;\r\ndev->net = net;\r\nstrcpy (net->name, "usb%d");\r\nmemcpy (net->dev_addr, node_id, sizeof node_id);\r\ndev->hard_mtu = net->mtu + net->hard_header_len;\r\n#if 0\r\nif (dma_supported (&udev->dev, DMA_BIT_MASK(64)))\r\nnet->features |= NETIF_F_HIGHDMA;\r\n#endif\r\nnet->netdev_ops = &usbnet_netdev_ops;\r\nnet->watchdog_timeo = TX_TIMEOUT_JIFFIES;\r\nnet->ethtool_ops = &usbnet_ethtool_ops;\r\nif (info->bind) {\r\nstatus = info->bind (dev, udev);\r\nif (status < 0)\r\ngoto out1;\r\nif ((dev->driver_info->flags & FLAG_ETHER) != 0 &&\r\n((dev->driver_info->flags & FLAG_POINTTOPOINT) == 0 ||\r\n(net->dev_addr [0] & 0x02) == 0))\r\nstrcpy (net->name, "eth%d");\r\nif ((dev->driver_info->flags & FLAG_WLAN) != 0)\r\nstrcpy(net->name, "wlan%d");\r\nif ((dev->driver_info->flags & FLAG_WWAN) != 0)\r\nstrcpy(net->name, "wwan%d");\r\nif ((dev->driver_info->flags & FLAG_NOARP) != 0)\r\nnet->flags |= IFF_NOARP;\r\nif (net->mtu > (dev->hard_mtu - net->hard_header_len))\r\nnet->mtu = dev->hard_mtu - net->hard_header_len;\r\n} else if (!info->in || !info->out)\r\nstatus = usbnet_get_endpoints (dev, udev);\r\nelse {\r\ndev->in = usb_rcvbulkpipe (xdev, info->in);\r\ndev->out = usb_sndbulkpipe (xdev, info->out);\r\nif (!(info->flags & FLAG_NO_SETINT))\r\nstatus = usb_set_interface (xdev,\r\ninterface->desc.bInterfaceNumber,\r\ninterface->desc.bAlternateSetting);\r\nelse\r\nstatus = 0;\r\n}\r\nif (status >= 0 && dev->status)\r\nstatus = init_status (dev, udev);\r\nif (status < 0)\r\ngoto out3;\r\nif (!dev->rx_urb_size)\r\ndev->rx_urb_size = dev->hard_mtu;\r\ndev->maxpacket = usb_maxpacket (dev->udev, dev->out, 1);\r\nif (ether_addr_equal(net->dev_addr, node_id))\r\nnet->addr_assign_type = NET_ADDR_RANDOM;\r\nif ((dev->driver_info->flags & FLAG_WLAN) != 0)\r\nSET_NETDEV_DEVTYPE(net, &wlan_type);\r\nif ((dev->driver_info->flags & FLAG_WWAN) != 0)\r\nSET_NETDEV_DEVTYPE(net, &wwan_type);\r\nusbnet_update_max_qlen(dev);\r\nif (dev->can_dma_sg && !(info->flags & FLAG_SEND_ZLP) &&\r\n!(info->flags & FLAG_MULTI_PACKET)) {\r\ndev->padding_pkt = kzalloc(1, GFP_KERNEL);\r\nif (!dev->padding_pkt) {\r\nstatus = -ENOMEM;\r\ngoto out4;\r\n}\r\n}\r\nstatus = register_netdev (net);\r\nif (status)\r\ngoto out5;\r\nnetif_info(dev, probe, dev->net,\r\n"register '%s' at usb-%s-%s, %s, %pM\n",\r\nudev->dev.driver->name,\r\nxdev->bus->bus_name, xdev->devpath,\r\ndev->driver_info->description,\r\nnet->dev_addr);\r\nusb_set_intfdata (udev, dev);\r\nnetif_device_attach (net);\r\nif (dev->driver_info->flags & FLAG_LINK_INTR)\r\nusbnet_link_change(dev, 0, 0);\r\nreturn 0;\r\nout5:\r\nkfree(dev->padding_pkt);\r\nout4:\r\nusb_free_urb(dev->interrupt);\r\nout3:\r\nif (info->unbind)\r\ninfo->unbind (dev, udev);\r\nout1:\r\nfree_netdev(net);\r\nout:\r\nreturn status;\r\n}\r\nint usbnet_suspend (struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nif (!dev->suspend_count++) {\r\nspin_lock_irq(&dev->txq.lock);\r\nif (dev->txq.qlen && PMSG_IS_AUTO(message)) {\r\ndev->suspend_count--;\r\nspin_unlock_irq(&dev->txq.lock);\r\nreturn -EBUSY;\r\n} else {\r\nset_bit(EVENT_DEV_ASLEEP, &dev->flags);\r\nspin_unlock_irq(&dev->txq.lock);\r\n}\r\nnetif_device_detach (dev->net);\r\nusbnet_terminate_urbs(dev);\r\n__usbnet_status_stop_force(dev);\r\nnetif_device_attach (dev->net);\r\n}\r\nreturn 0;\r\n}\r\nint usbnet_resume (struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct sk_buff *skb;\r\nstruct urb *res;\r\nint retval;\r\nif (!--dev->suspend_count) {\r\n__usbnet_status_start_force(dev, GFP_NOIO);\r\nspin_lock_irq(&dev->txq.lock);\r\nwhile ((res = usb_get_from_anchor(&dev->deferred))) {\r\nskb = (struct sk_buff *)res->context;\r\nretval = usb_submit_urb(res, GFP_ATOMIC);\r\nif (retval < 0) {\r\ndev_kfree_skb_any(skb);\r\nkfree(res->sg);\r\nusb_free_urb(res);\r\nusb_autopm_put_interface_async(dev->intf);\r\n} else {\r\ndev->net->trans_start = jiffies;\r\n__skb_queue_tail(&dev->txq, skb);\r\n}\r\n}\r\nsmp_mb();\r\nclear_bit(EVENT_DEV_ASLEEP, &dev->flags);\r\nspin_unlock_irq(&dev->txq.lock);\r\nif (test_bit(EVENT_DEV_OPEN, &dev->flags)) {\r\nif (netif_device_present(dev->net) &&\r\n!timer_pending(&dev->delay) &&\r\n!test_bit(EVENT_RX_HALT, &dev->flags))\r\nrx_alloc_submit(dev, GFP_NOIO);\r\nif (!(dev->txq.qlen >= TX_QLEN(dev)))\r\nnetif_tx_wake_all_queues(dev->net);\r\ntasklet_schedule (&dev->bh);\r\n}\r\n}\r\nif (test_and_clear_bit(EVENT_DEVICE_REPORT_IDLE, &dev->flags))\r\nusb_autopm_get_interface_no_resume(intf);\r\nreturn 0;\r\n}\r\nvoid usbnet_device_suggests_idle(struct usbnet *dev)\r\n{\r\nif (!test_and_set_bit(EVENT_DEVICE_REPORT_IDLE, &dev->flags)) {\r\ndev->intf->needs_remote_wakeup = 1;\r\nusb_autopm_put_interface_async(dev->intf);\r\n}\r\n}\r\nint usbnet_manage_power(struct usbnet *dev, int on)\r\n{\r\ndev->intf->needs_remote_wakeup = on;\r\nreturn 0;\r\n}\r\nvoid usbnet_link_change(struct usbnet *dev, bool link, bool need_reset)\r\n{\r\nif (link && !need_reset)\r\nnetif_carrier_on(dev->net);\r\nelse\r\nnetif_carrier_off(dev->net);\r\nif (need_reset && link)\r\nusbnet_defer_kevent(dev, EVENT_LINK_RESET);\r\nelse\r\nusbnet_defer_kevent(dev, EVENT_LINK_CHANGE);\r\n}\r\nstatic int __usbnet_read_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,\r\nu16 value, u16 index, void *data, u16 size)\r\n{\r\nvoid *buf = NULL;\r\nint err = -ENOMEM;\r\nnetdev_dbg(dev->net, "usbnet_read_cmd cmd=0x%02x reqtype=%02x"\r\n" value=0x%04x index=0x%04x size=%d\n",\r\ncmd, reqtype, value, index, size);\r\nif (data) {\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf)\r\ngoto out;\r\n}\r\nerr = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\r\ncmd, reqtype, value, index, buf, size,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (err > 0 && err <= size)\r\nmemcpy(data, buf, err);\r\nkfree(buf);\r\nout:\r\nreturn err;\r\n}\r\nstatic int __usbnet_write_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,\r\nu16 value, u16 index, const void *data,\r\nu16 size)\r\n{\r\nvoid *buf = NULL;\r\nint err = -ENOMEM;\r\nnetdev_dbg(dev->net, "usbnet_write_cmd cmd=0x%02x reqtype=%02x"\r\n" value=0x%04x index=0x%04x size=%d\n",\r\ncmd, reqtype, value, index, size);\r\nif (data) {\r\nbuf = kmemdup(data, size, GFP_KERNEL);\r\nif (!buf)\r\ngoto out;\r\n}\r\nerr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\r\ncmd, reqtype, value, index, buf, size,\r\nUSB_CTRL_SET_TIMEOUT);\r\nkfree(buf);\r\nout:\r\nreturn err;\r\n}\r\nint usbnet_read_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,\r\nu16 value, u16 index, void *data, u16 size)\r\n{\r\nint ret;\r\nif (usb_autopm_get_interface(dev->intf) < 0)\r\nreturn -ENODEV;\r\nret = __usbnet_read_cmd(dev, cmd, reqtype, value, index,\r\ndata, size);\r\nusb_autopm_put_interface(dev->intf);\r\nreturn ret;\r\n}\r\nint usbnet_write_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,\r\nu16 value, u16 index, const void *data, u16 size)\r\n{\r\nint ret;\r\nif (usb_autopm_get_interface(dev->intf) < 0)\r\nreturn -ENODEV;\r\nret = __usbnet_write_cmd(dev, cmd, reqtype, value, index,\r\ndata, size);\r\nusb_autopm_put_interface(dev->intf);\r\nreturn ret;\r\n}\r\nint usbnet_read_cmd_nopm(struct usbnet *dev, u8 cmd, u8 reqtype,\r\nu16 value, u16 index, void *data, u16 size)\r\n{\r\nreturn __usbnet_read_cmd(dev, cmd, reqtype, value, index,\r\ndata, size);\r\n}\r\nint usbnet_write_cmd_nopm(struct usbnet *dev, u8 cmd, u8 reqtype,\r\nu16 value, u16 index, const void *data,\r\nu16 size)\r\n{\r\nreturn __usbnet_write_cmd(dev, cmd, reqtype, value, index,\r\ndata, size);\r\n}\r\nstatic void usbnet_async_cmd_cb(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req = (struct usb_ctrlrequest *)urb->context;\r\nint status = urb->status;\r\nif (status < 0)\r\ndev_dbg(&urb->dev->dev, "%s failed with %d",\r\n__func__, status);\r\nkfree(req);\r\nusb_free_urb(urb);\r\n}\r\nint usbnet_write_cmd_async(struct usbnet *dev, u8 cmd, u8 reqtype,\r\nu16 value, u16 index, const void *data, u16 size)\r\n{\r\nstruct usb_ctrlrequest *req = NULL;\r\nstruct urb *urb;\r\nint err = -ENOMEM;\r\nvoid *buf = NULL;\r\nnetdev_dbg(dev->net, "usbnet_write_cmd cmd=0x%02x reqtype=%02x"\r\n" value=0x%04x index=0x%04x size=%d\n",\r\ncmd, reqtype, value, index, size);\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nnetdev_err(dev->net, "Error allocating URB in"\r\n" %s!\n", __func__);\r\ngoto fail;\r\n}\r\nif (data) {\r\nbuf = kmemdup(data, size, GFP_ATOMIC);\r\nif (!buf) {\r\nnetdev_err(dev->net, "Error allocating buffer"\r\n" in %s!\n", __func__);\r\ngoto fail_free;\r\n}\r\n}\r\nreq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);\r\nif (!req)\r\ngoto fail_free_buf;\r\nreq->bRequestType = reqtype;\r\nreq->bRequest = cmd;\r\nreq->wValue = cpu_to_le16(value);\r\nreq->wIndex = cpu_to_le16(index);\r\nreq->wLength = cpu_to_le16(size);\r\nusb_fill_control_urb(urb, dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\n(void *)req, buf, size,\r\nusbnet_async_cmd_cb, req);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nnetdev_err(dev->net, "Error submitting the control"\r\n" message: status=%d\n", err);\r\ngoto fail_free;\r\n}\r\nreturn 0;\r\nfail_free_buf:\r\nkfree(buf);\r\nfail_free:\r\nkfree(req);\r\nusb_free_urb(urb);\r\nfail:\r\nreturn err;\r\n}\r\nstatic int __init usbnet_init(void)\r\n{\r\nBUILD_BUG_ON(\r\nFIELD_SIZEOF(struct sk_buff, cb) < sizeof(struct skb_data));\r\neth_random_addr(node_id);\r\nreturn 0;\r\n}\r\nstatic void __exit usbnet_exit(void)\r\n{\r\n}
