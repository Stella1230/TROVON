static int request_mac_address(struct lte_udev *udev)\r\n{\r\nu8 buf[16] = {0,};\r\nstruct hci_packet *hci = (struct hci_packet *)buf;\r\nstruct usb_device *usbdev = udev->usbdev;\r\nint actual;\r\nint ret = -1;\r\nhci->cmd_evt = gdm_cpu_to_dev16(&udev->gdm_ed, LTE_GET_INFORMATION);\r\nhci->len = gdm_cpu_to_dev16(&udev->gdm_ed, 1);\r\nhci->data[0] = MAC_ADDRESS;\r\nret = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, 2), buf, 5,\r\n&actual, 1000);\r\nudev->request_mac_addr = 1;\r\nreturn ret;\r\n}\r\nstatic struct usb_tx *alloc_tx_struct(int len)\r\n{\r\nstruct usb_tx *t = NULL;\r\nint ret = 0;\r\nt = kzalloc(sizeof(struct usb_tx), GFP_ATOMIC);\r\nif (!t) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nt->urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!(len % 512))\r\nlen++;\r\nt->buf = kmalloc(len, GFP_ATOMIC);\r\nif (!t->urb || !t->buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nout:\r\nif (ret < 0) {\r\nif (t) {\r\nusb_free_urb(t->urb);\r\nkfree(t->buf);\r\nkfree(t);\r\n}\r\nreturn NULL;\r\n}\r\nreturn t;\r\n}\r\nstatic struct usb_tx_sdu *alloc_tx_sdu_struct(void)\r\n{\r\nstruct usb_tx_sdu *t_sdu;\r\nt_sdu = kzalloc(sizeof(struct usb_tx_sdu), GFP_ATOMIC);\r\nif (!t_sdu)\r\nreturn NULL;\r\nt_sdu->buf = kmalloc(SDU_BUF_SIZE, GFP_ATOMIC);\r\nif (!t_sdu->buf) {\r\nkfree(t_sdu);\r\nreturn NULL;\r\n}\r\nreturn t_sdu;\r\n}\r\nstatic void free_tx_struct(struct usb_tx *t)\r\n{\r\nif (t) {\r\nusb_free_urb(t->urb);\r\nkfree(t->buf);\r\nkfree(t);\r\n}\r\n}\r\nstatic void free_tx_sdu_struct(struct usb_tx_sdu *t_sdu)\r\n{\r\nif (t_sdu) {\r\nkfree(t_sdu->buf);\r\nkfree(t_sdu);\r\n}\r\n}\r\nstatic struct usb_tx_sdu *get_tx_sdu_struct(struct tx_cxt *tx, int *no_spc)\r\n{\r\nstruct usb_tx_sdu *t_sdu;\r\nif (list_empty(&tx->free_list))\r\nreturn NULL;\r\nt_sdu = list_entry(tx->free_list.next, struct usb_tx_sdu, list);\r\nlist_del(&t_sdu->list);\r\ntx->avail_count--;\r\n*no_spc = list_empty(&tx->free_list) ? 1 : 0;\r\nreturn t_sdu;\r\n}\r\nstatic void put_tx_struct(struct tx_cxt *tx, struct usb_tx_sdu *t_sdu)\r\n{\r\nlist_add_tail(&t_sdu->list, &tx->free_list);\r\ntx->avail_count++;\r\n}\r\nstatic struct usb_rx *alloc_rx_struct(void)\r\n{\r\nstruct usb_rx *r = NULL;\r\nint ret = 0;\r\nr = kmalloc(sizeof(struct usb_rx), GFP_ATOMIC);\r\nif (!r) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nr->urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nr->buf = kmalloc(RX_BUF_SIZE, GFP_ATOMIC);\r\nif (!r->urb || !r->buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nout:\r\nif (ret < 0) {\r\nif (r) {\r\nusb_free_urb(r->urb);\r\nkfree(r->buf);\r\nkfree(r);\r\n}\r\nreturn NULL;\r\n}\r\nreturn r;\r\n}\r\nstatic void free_rx_struct(struct usb_rx *r)\r\n{\r\nif (r) {\r\nusb_free_urb(r->urb);\r\nkfree(r->buf);\r\nkfree(r);\r\n}\r\n}\r\nstatic struct usb_rx *get_rx_struct(struct rx_cxt *rx, int *no_spc)\r\n{\r\nstruct usb_rx *r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rx->rx_lock, flags);\r\nif (list_empty(&rx->free_list)) {\r\nspin_unlock_irqrestore(&rx->rx_lock, flags);\r\nreturn NULL;\r\n}\r\nr = list_entry(rx->free_list.next, struct usb_rx, free_list);\r\nlist_del(&r->free_list);\r\nrx->avail_count--;\r\n*no_spc = list_empty(&rx->free_list) ? 1 : 0;\r\nspin_unlock_irqrestore(&rx->rx_lock, flags);\r\nreturn r;\r\n}\r\nstatic void put_rx_struct(struct rx_cxt *rx, struct usb_rx *r)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&rx->rx_lock, flags);\r\nlist_add_tail(&r->free_list, &rx->free_list);\r\nrx->avail_count++;\r\nspin_unlock_irqrestore(&rx->rx_lock, flags);\r\n}\r\nstatic void release_usb(struct lte_udev *udev)\r\n{\r\nstruct rx_cxt *rx = &udev->rx;\r\nstruct tx_cxt *tx = &udev->tx;\r\nstruct usb_tx *t, *t_next;\r\nstruct usb_rx *r, *r_next;\r\nstruct usb_tx_sdu *t_sdu, *t_sdu_next;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tx->lock, flags);\r\nlist_for_each_entry_safe(t_sdu, t_sdu_next, &tx->sdu_list, list)\r\n{\r\nlist_del(&t_sdu->list);\r\nfree_tx_sdu_struct(t_sdu);\r\n}\r\nlist_for_each_entry_safe(t, t_next, &tx->hci_list, list)\r\n{\r\nlist_del(&t->list);\r\nfree_tx_struct(t);\r\n}\r\nlist_for_each_entry_safe(t_sdu, t_sdu_next, &tx->free_list, list)\r\n{\r\nlist_del(&t_sdu->list);\r\nfree_tx_sdu_struct(t_sdu);\r\n}\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nspin_lock_irqsave(&rx->submit_lock, flags);\r\nlist_for_each_entry_safe(r, r_next, &rx->rx_submit_list, rx_submit_list)\r\n{\r\nspin_unlock_irqrestore(&rx->submit_lock, flags);\r\nusb_kill_urb(r->urb);\r\nspin_lock_irqsave(&rx->submit_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&rx->submit_lock, flags);\r\nspin_lock_irqsave(&rx->rx_lock, flags);\r\nlist_for_each_entry_safe(r, r_next, &rx->free_list, free_list)\r\n{\r\nlist_del(&r->free_list);\r\nfree_rx_struct(r);\r\n}\r\nspin_unlock_irqrestore(&rx->rx_lock, flags);\r\nspin_lock_irqsave(&rx->to_host_lock, flags);\r\nlist_for_each_entry_safe(r, r_next, &rx->to_host_list, to_host_list)\r\n{\r\nif (r->index == (void *)udev) {\r\nlist_del(&r->to_host_list);\r\nfree_rx_struct(r);\r\n}\r\n}\r\nspin_unlock_irqrestore(&rx->to_host_lock, flags);\r\n}\r\nstatic int init_usb(struct lte_udev *udev)\r\n{\r\nint ret = 0;\r\nint i;\r\nstruct tx_cxt *tx = &udev->tx;\r\nstruct rx_cxt *rx = &udev->rx;\r\nstruct usb_tx_sdu *t_sdu = NULL;\r\nstruct usb_rx *r = NULL;\r\nudev->send_complete = 1;\r\nudev->tx_stop = 0;\r\nudev->request_mac_addr = 0;\r\nudev->usb_state = PM_NORMAL;\r\nINIT_LIST_HEAD(&tx->sdu_list);\r\nINIT_LIST_HEAD(&tx->hci_list);\r\nINIT_LIST_HEAD(&tx->free_list);\r\nINIT_LIST_HEAD(&rx->rx_submit_list);\r\nINIT_LIST_HEAD(&rx->free_list);\r\nINIT_LIST_HEAD(&rx->to_host_list);\r\nspin_lock_init(&tx->lock);\r\nspin_lock_init(&rx->rx_lock);\r\nspin_lock_init(&rx->submit_lock);\r\nspin_lock_init(&rx->to_host_lock);\r\ntx->avail_count = 0;\r\nrx->avail_count = 0;\r\nudev->rx_cb = NULL;\r\nfor (i = 0; i < MAX_NUM_SDU_BUF; i++) {\r\nt_sdu = alloc_tx_sdu_struct();\r\nif (t_sdu == NULL) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nlist_add(&t_sdu->list, &tx->free_list);\r\ntx->avail_count++;\r\n}\r\nfor (i = 0; i < MAX_RX_SUBMIT_COUNT*2; i++) {\r\nr = alloc_rx_struct();\r\nif (r == NULL) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nlist_add(&r->free_list, &rx->free_list);\r\nrx->avail_count++;\r\n}\r\nINIT_DELAYED_WORK(&udev->work_tx, do_tx);\r\nINIT_DELAYED_WORK(&udev->work_rx, do_rx);\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int set_mac_address(u8 *data, void *arg)\r\n{\r\nstruct phy_dev *phy_dev = (struct phy_dev *)arg;\r\nstruct lte_udev *udev = phy_dev->priv_dev;\r\nstruct tlv *tlv = (struct tlv *)data;\r\nu8 mac_address[ETH_ALEN] = {0, };\r\nif (tlv->type == MAC_ADDRESS && udev->request_mac_addr) {\r\nmemcpy(mac_address, tlv->data, tlv->len);\r\nif (register_lte_device(phy_dev,\r\n&udev->intf->dev, mac_address) < 0)\r\npr_err("register lte device failed\n");\r\nudev->request_mac_addr = 0;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_rx(struct work_struct *work)\r\n{\r\nstruct lte_udev *udev =\r\ncontainer_of(work, struct lte_udev, work_rx.work);\r\nstruct rx_cxt *rx = &udev->rx;\r\nstruct usb_rx *r;\r\nstruct hci_packet *hci;\r\nstruct phy_dev *phy_dev;\r\nu16 cmd_evt;\r\nint ret;\r\nunsigned long flags;\r\nwhile (1) {\r\nspin_lock_irqsave(&rx->to_host_lock, flags);\r\nif (list_empty(&rx->to_host_list)) {\r\nspin_unlock_irqrestore(&rx->to_host_lock, flags);\r\nbreak;\r\n}\r\nr = list_entry(rx->to_host_list.next,\r\nstruct usb_rx, to_host_list);\r\nlist_del(&r->to_host_list);\r\nspin_unlock_irqrestore(&rx->to_host_lock, flags);\r\nphy_dev = (struct phy_dev *)r->cb_data;\r\nudev = (struct lte_udev *)phy_dev->priv_dev;\r\nhci = (struct hci_packet *)r->buf;\r\ncmd_evt = gdm_dev16_to_cpu(&udev->gdm_ed, hci->cmd_evt);\r\nswitch (cmd_evt) {\r\ncase LTE_GET_INFORMATION_RESULT:\r\nif (set_mac_address(hci->data, r->cb_data) == 0) {\r\nret = r->callback(r->cb_data,\r\nr->buf,\r\nr->urb->actual_length,\r\nKERNEL_THREAD);\r\n}\r\nbreak;\r\ndefault:\r\nif (r->callback) {\r\nret = r->callback(r->cb_data,\r\nr->buf,\r\nr->urb->actual_length,\r\nKERNEL_THREAD);\r\nif (ret == -EAGAIN)\r\npr_err("failed to send received data\n");\r\n}\r\nbreak;\r\n}\r\nput_rx_struct(rx, r);\r\ngdm_usb_recv(udev,\r\nr->callback,\r\nr->cb_data,\r\nUSB_COMPLETE);\r\n}\r\n}\r\nstatic void remove_rx_submit_list(struct usb_rx *r, struct rx_cxt *rx)\r\n{\r\nunsigned long flags;\r\nstruct usb_rx *r_remove, *r_remove_next;\r\nspin_lock_irqsave(&rx->submit_lock, flags);\r\nlist_for_each_entry_safe(r_remove,\r\nr_remove_next, &rx->rx_submit_list, rx_submit_list)\r\n{\r\nif (r == r_remove) {\r\nlist_del(&r->rx_submit_list);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&rx->submit_lock, flags);\r\n}\r\nstatic void gdm_usb_rcv_complete(struct urb *urb)\r\n{\r\nstruct usb_rx *r = urb->context;\r\nstruct rx_cxt *rx = r->rx;\r\nunsigned long flags;\r\nstruct lte_udev *udev = container_of(r->rx, struct lte_udev, rx);\r\nstruct usb_device *usbdev = udev->usbdev;\r\nremove_rx_submit_list(r, rx);\r\nif (!urb->status && r->callback) {\r\nspin_lock_irqsave(&rx->to_host_lock, flags);\r\nlist_add_tail(&r->to_host_list, &rx->to_host_list);\r\nqueue_work(usb_rx_wq, &udev->work_rx.work);\r\nspin_unlock_irqrestore(&rx->to_host_lock, flags);\r\n} else {\r\nif (urb->status && udev->usb_state == PM_NORMAL)\r\npr_err("%s: urb status error %d\n",\r\n__func__, urb->status);\r\nput_rx_struct(rx, r);\r\n}\r\nusb_mark_last_busy(usbdev);\r\n}\r\nstatic int gdm_usb_recv(void *priv_dev,\r\nint (*cb)(void *cb_data,\r\nvoid *data, int len, int context),\r\nvoid *cb_data,\r\nint context)\r\n{\r\nstruct lte_udev *udev = priv_dev;\r\nstruct usb_device *usbdev = udev->usbdev;\r\nstruct rx_cxt *rx = &udev->rx;\r\nstruct usb_rx *r;\r\nint no_spc;\r\nint ret;\r\nunsigned long flags;\r\nif (!udev->usbdev) {\r\npr_err("invalid device\n");\r\nreturn -ENODEV;\r\n}\r\nr = get_rx_struct(rx, &no_spc);\r\nif (!r) {\r\npr_err("Out of Memory\n");\r\nreturn -ENOMEM;\r\n}\r\nudev->rx_cb = cb;\r\nr->callback = cb;\r\nr->cb_data = cb_data;\r\nr->index = (void *)udev;\r\nr->rx = rx;\r\nusb_fill_bulk_urb(r->urb,\r\nusbdev,\r\nusb_rcvbulkpipe(usbdev, 0x83),\r\nr->buf,\r\nRX_BUF_SIZE,\r\ngdm_usb_rcv_complete,\r\nr);\r\nspin_lock_irqsave(&rx->submit_lock, flags);\r\nlist_add_tail(&r->rx_submit_list, &rx->rx_submit_list);\r\nspin_unlock_irqrestore(&rx->submit_lock, flags);\r\nif (context == KERNEL_THREAD)\r\nret = usb_submit_urb(r->urb, GFP_KERNEL);\r\nelse\r\nret = usb_submit_urb(r->urb, GFP_ATOMIC);\r\nif (ret) {\r\nspin_lock_irqsave(&rx->submit_lock, flags);\r\nlist_del(&r->rx_submit_list);\r\nspin_unlock_irqrestore(&rx->submit_lock, flags);\r\npr_err("usb_submit_urb failed (%p)\n", r);\r\nput_rx_struct(rx, r);\r\n}\r\nreturn ret;\r\n}\r\nstatic void gdm_usb_send_complete(struct urb *urb)\r\n{\r\nstruct usb_tx *t = urb->context;\r\nstruct tx_cxt *tx = t->tx;\r\nstruct lte_udev *udev = container_of(tx, struct lte_udev, tx);\r\nunsigned long flags;\r\nif (urb->status == -ECONNRESET) {\r\npr_info("CONNRESET\n");\r\nreturn;\r\n}\r\nif (t->callback)\r\nt->callback(t->cb_data);\r\nfree_tx_struct(t);\r\nspin_lock_irqsave(&tx->lock, flags);\r\nudev->send_complete = 1;\r\nqueue_work(usb_tx_wq, &udev->work_tx.work);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n}\r\nstatic int send_tx_packet(struct usb_device *usbdev, struct usb_tx *t, u32 len)\r\n{\r\nint ret = 0;\r\nif (!(len%512))\r\nlen++;\r\nusb_fill_bulk_urb(t->urb,\r\nusbdev,\r\nusb_sndbulkpipe(usbdev, 2),\r\nt->buf,\r\nlen,\r\ngdm_usb_send_complete,\r\nt);\r\nret = usb_submit_urb(t->urb, GFP_ATOMIC);\r\nif (ret)\r\npr_err("usb_submit_urb failed: %d\n", ret);\r\nusb_mark_last_busy(usbdev);\r\nreturn ret;\r\n}\r\nstatic u32 packet_aggregation(struct lte_udev *udev, u8 *send_buf)\r\n{\r\nstruct tx_cxt *tx = &udev->tx;\r\nstruct usb_tx_sdu *t_sdu = NULL;\r\nstruct multi_sdu *multi_sdu = (struct multi_sdu *)send_buf;\r\nu16 send_len = 0;\r\nu16 num_packet = 0;\r\nunsigned long flags;\r\nmulti_sdu->cmd_evt = gdm_cpu_to_dev16(&udev->gdm_ed, LTE_TX_MULTI_SDU);\r\nwhile (num_packet < MAX_PACKET_IN_MULTI_SDU) {\r\nspin_lock_irqsave(&tx->lock, flags);\r\nif (list_empty(&tx->sdu_list)) {\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nbreak;\r\n}\r\nt_sdu = list_entry(tx->sdu_list.next, struct usb_tx_sdu, list);\r\nif (send_len + t_sdu->len > MAX_SDU_SIZE) {\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nbreak;\r\n}\r\nlist_del(&t_sdu->list);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nmemcpy(multi_sdu->data + send_len, t_sdu->buf, t_sdu->len);\r\nsend_len += (t_sdu->len + 3) & 0xfffc;\r\nnum_packet++;\r\nif (tx->avail_count > 10)\r\nt_sdu->callback(t_sdu->cb_data);\r\nspin_lock_irqsave(&tx->lock, flags);\r\nput_tx_struct(tx, t_sdu);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n}\r\nmulti_sdu->len = gdm_cpu_to_dev16(&udev->gdm_ed, send_len);\r\nmulti_sdu->num_packet = gdm_cpu_to_dev16(&udev->gdm_ed, num_packet);\r\nreturn send_len + offsetof(struct multi_sdu, data);\r\n}\r\nstatic void do_tx(struct work_struct *work)\r\n{\r\nstruct lte_udev *udev =\r\ncontainer_of(work, struct lte_udev, work_tx.work);\r\nstruct usb_device *usbdev = udev->usbdev;\r\nstruct tx_cxt *tx = &udev->tx;\r\nstruct usb_tx *t = NULL;\r\nint is_send = 0;\r\nu32 len = 0;\r\nunsigned long flags;\r\nif (!usb_autopm_get_interface(udev->intf))\r\nusb_autopm_put_interface(udev->intf);\r\nif (udev->usb_state == PM_SUSPEND)\r\nreturn;\r\nspin_lock_irqsave(&tx->lock, flags);\r\nif (!udev->send_complete) {\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn;\r\n} else {\r\nudev->send_complete = 0;\r\n}\r\nif (!list_empty(&tx->hci_list)) {\r\nt = list_entry(tx->hci_list.next, struct usb_tx, list);\r\nlist_del(&t->list);\r\nlen = t->len;\r\nt->is_sdu = 0;\r\nis_send = 1;\r\n} else if (!list_empty(&tx->sdu_list)) {\r\nif (udev->tx_stop) {\r\nudev->send_complete = 1;\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn;\r\n}\r\nt = alloc_tx_struct(TX_BUF_SIZE);\r\nt->callback = NULL;\r\nt->tx = tx;\r\nt->is_sdu = 1;\r\nis_send = 1;\r\n}\r\nif (!is_send) {\r\nudev->send_complete = 1;\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nif (t->is_sdu)\r\nlen = packet_aggregation(udev, t->buf);\r\nif (send_tx_packet(usbdev, t, len)) {\r\npr_err("send_tx_packet failed\n");\r\nt->callback = NULL;\r\ngdm_usb_send_complete(t->urb);\r\n}\r\n}\r\nstatic int gdm_usb_sdu_send(void *priv_dev, void *data, int len,\r\nunsigned int dftEpsId, unsigned int epsId,\r\nvoid (*cb)(void *data), void *cb_data,\r\nint dev_idx, int nic_type)\r\n{\r\nstruct lte_udev *udev = priv_dev;\r\nstruct tx_cxt *tx = &udev->tx;\r\nstruct usb_tx_sdu *t_sdu;\r\nstruct sdu *sdu = NULL;\r\nunsigned long flags;\r\nint no_spc = 0;\r\nu16 send_len;\r\nif (!udev->usbdev) {\r\npr_err("sdu send - invalid device\n");\r\nreturn TX_NO_DEV;\r\n}\r\nspin_lock_irqsave(&tx->lock, flags);\r\nt_sdu = get_tx_sdu_struct(tx, &no_spc);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nif (t_sdu == NULL) {\r\npr_err("sdu send - free list empty\n");\r\nreturn TX_NO_SPC;\r\n}\r\nsdu = (struct sdu *)t_sdu->buf;\r\nsdu->cmd_evt = gdm_cpu_to_dev16(&udev->gdm_ed, LTE_TX_SDU);\r\nif (nic_type == NIC_TYPE_ARP) {\r\nsend_len = len + SDU_PARAM_LEN;\r\nmemcpy(sdu->data, data, len);\r\n} else {\r\nsend_len = len - ETH_HLEN;\r\nsend_len += SDU_PARAM_LEN;\r\nmemcpy(sdu->data, data+ETH_HLEN, len-ETH_HLEN);\r\n}\r\nsdu->len = gdm_cpu_to_dev16(&udev->gdm_ed, send_len);\r\nsdu->dftEpsId = gdm_cpu_to_dev32(&udev->gdm_ed, dftEpsId);\r\nsdu->bearer_ID = gdm_cpu_to_dev32(&udev->gdm_ed, epsId);\r\nsdu->nic_type = gdm_cpu_to_dev32(&udev->gdm_ed, nic_type);\r\nt_sdu->len = send_len + HCI_HEADER_SIZE;\r\nt_sdu->callback = cb;\r\nt_sdu->cb_data = cb_data;\r\nspin_lock_irqsave(&tx->lock, flags);\r\nlist_add_tail(&t_sdu->list, &tx->sdu_list);\r\nqueue_work(usb_tx_wq, &udev->work_tx.work);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nif (no_spc)\r\nreturn TX_NO_BUFFER;\r\nreturn 0;\r\n}\r\nstatic int gdm_usb_hci_send(void *priv_dev, void *data, int len,\r\nvoid (*cb)(void *data), void *cb_data)\r\n{\r\nstruct lte_udev *udev = priv_dev;\r\nstruct tx_cxt *tx = &udev->tx;\r\nstruct usb_tx *t;\r\nunsigned long flags;\r\nif (!udev->usbdev) {\r\npr_err("hci send - invalid device\n");\r\nreturn -ENODEV;\r\n}\r\nt = alloc_tx_struct(len);\r\nif (t == NULL) {\r\npr_err("hci_send - out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(t->buf, data, len);\r\nt->callback = cb;\r\nt->cb_data = cb_data;\r\nt->len = len;\r\nt->tx = tx;\r\nt->is_sdu = 0;\r\nspin_lock_irqsave(&tx->lock, flags);\r\nlist_add_tail(&t->list, &tx->hci_list);\r\nqueue_work(usb_tx_wq, &udev->work_tx.work);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct gdm_endian *gdm_usb_get_endian(void *priv_dev)\r\n{\r\nstruct lte_udev *udev = priv_dev;\r\nreturn &udev->gdm_ed;\r\n}\r\nstatic int gdm_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint ret = 0;\r\nstruct phy_dev *phy_dev = NULL;\r\nstruct lte_udev *udev = NULL;\r\nu16 idVendor, idProduct;\r\nint bInterfaceNumber;\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nbInterfaceNumber = intf->cur_altsetting->desc.bInterfaceNumber;\r\nidVendor = __le16_to_cpu(usbdev->descriptor.idVendor);\r\nidProduct = __le16_to_cpu(usbdev->descriptor.idProduct);\r\npr_info("net vid = 0x%04x pid = 0x%04x\n", idVendor, idProduct);\r\nif (bInterfaceNumber > NETWORK_INTERFACE) {\r\npr_info("not a network device\n");\r\nreturn -ENODEV;\r\n}\r\nphy_dev = kzalloc(sizeof(struct phy_dev), GFP_KERNEL);\r\nif (!phy_dev)\r\nreturn -ENOMEM;\r\nudev = kzalloc(sizeof(struct lte_udev), GFP_KERNEL);\r\nif (!udev) {\r\nret = -ENOMEM;\r\ngoto err_udev;\r\n}\r\nphy_dev->priv_dev = (void *)udev;\r\nphy_dev->send_hci_func = gdm_usb_hci_send;\r\nphy_dev->send_sdu_func = gdm_usb_sdu_send;\r\nphy_dev->rcv_func = gdm_usb_recv;\r\nphy_dev->get_endian = gdm_usb_get_endian;\r\nudev->usbdev = usbdev;\r\nret = init_usb(udev);\r\nif (ret < 0) {\r\npr_err("init_usb func failed\n");\r\ngoto err_init_usb;\r\n}\r\nudev->intf = intf;\r\nintf->needs_remote_wakeup = 1;\r\nusb_enable_autosuspend(usbdev);\r\npm_runtime_set_autosuspend_delay(&usbdev->dev, AUTO_SUSPEND_TIMER);\r\nif (idProduct == PID_GDM7243)\r\ngdm_set_endian(&udev->gdm_ed, ENDIANNESS_BIG);\r\nelse\r\ngdm_set_endian(&udev->gdm_ed, ENDIANNESS_LITTLE);\r\nret = request_mac_address(udev);\r\nif (ret < 0) {\r\npr_err("request Mac address failed\n");\r\ngoto err_mac_address;\r\n}\r\nstart_rx_proc(phy_dev);\r\nusb_get_dev(usbdev);\r\nusb_set_intfdata(intf, phy_dev);\r\nreturn 0;\r\nerr_mac_address:\r\nrelease_usb(udev);\r\nerr_init_usb:\r\nkfree(udev);\r\nerr_udev:\r\nkfree(phy_dev);\r\nreturn ret;\r\n}\r\nstatic void gdm_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct phy_dev *phy_dev;\r\nstruct lte_udev *udev;\r\nu16 idVendor, idProduct;\r\nstruct usb_device *usbdev;\r\nusbdev = interface_to_usbdev(intf);\r\nidVendor = __le16_to_cpu(usbdev->descriptor.idVendor);\r\nidProduct = __le16_to_cpu(usbdev->descriptor.idProduct);\r\nphy_dev = usb_get_intfdata(intf);\r\nudev = phy_dev->priv_dev;\r\nunregister_lte_device(phy_dev);\r\nrelease_usb(udev);\r\nkfree(udev);\r\nudev = NULL;\r\nkfree(phy_dev);\r\nphy_dev = NULL;\r\nusb_put_dev(usbdev);\r\n}\r\nstatic int gdm_usb_suspend(struct usb_interface *intf, pm_message_t pm_msg)\r\n{\r\nstruct phy_dev *phy_dev;\r\nstruct lte_udev *udev;\r\nstruct rx_cxt *rx;\r\nstruct usb_rx *r;\r\nstruct usb_rx *r_next;\r\nunsigned long flags;\r\nphy_dev = usb_get_intfdata(intf);\r\nudev = phy_dev->priv_dev;\r\nrx = &udev->rx;\r\nif (udev->usb_state != PM_NORMAL) {\r\npr_err("usb suspend - invalid state\n");\r\nreturn -1;\r\n}\r\nudev->usb_state = PM_SUSPEND;\r\nspin_lock_irqsave(&rx->submit_lock, flags);\r\nlist_for_each_entry_safe(r, r_next, &rx->rx_submit_list, rx_submit_list)\r\n{\r\nspin_unlock_irqrestore(&rx->submit_lock, flags);\r\nusb_kill_urb(r->urb);\r\nspin_lock_irqsave(&rx->submit_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&rx->submit_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gdm_usb_resume(struct usb_interface *intf)\r\n{\r\nstruct phy_dev *phy_dev;\r\nstruct lte_udev *udev;\r\nstruct tx_cxt *tx;\r\nstruct rx_cxt *rx;\r\nunsigned long flags;\r\nint issue_count;\r\nint i;\r\nphy_dev = usb_get_intfdata(intf);\r\nudev = phy_dev->priv_dev;\r\nrx = &udev->rx;\r\nif (udev->usb_state != PM_SUSPEND) {\r\npr_err("usb resume - invalid state\n");\r\nreturn -1;\r\n}\r\nudev->usb_state = PM_NORMAL;\r\nspin_lock_irqsave(&rx->rx_lock, flags);\r\nissue_count = rx->avail_count - MAX_RX_SUBMIT_COUNT;\r\nspin_unlock_irqrestore(&rx->rx_lock, flags);\r\nif (issue_count >= 0) {\r\nfor (i = 0; i < issue_count; i++)\r\ngdm_usb_recv(phy_dev->priv_dev,\r\nudev->rx_cb,\r\nphy_dev,\r\nUSB_COMPLETE);\r\n}\r\ntx = &udev->tx;\r\nspin_lock_irqsave(&tx->lock, flags);\r\nqueue_work(usb_tx_wq, &udev->work_tx.work);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init gdm_usb_lte_init(void)\r\n{\r\nif (gdm_lte_event_init() < 0) {\r\npr_err("error creating event\n");\r\nreturn -1;\r\n}\r\nusb_tx_wq = create_workqueue("usb_tx_wq");\r\nif (usb_tx_wq == NULL)\r\nreturn -1;\r\nusb_rx_wq = create_workqueue("usb_rx_wq");\r\nif (usb_rx_wq == NULL)\r\nreturn -1;\r\nreturn usb_register(&gdm_usb_lte_driver);\r\n}\r\nstatic void __exit gdm_usb_lte_exit(void)\r\n{\r\ngdm_lte_event_exit();\r\nusb_deregister(&gdm_usb_lte_driver);\r\nif (usb_tx_wq) {\r\nflush_workqueue(usb_tx_wq);\r\ndestroy_workqueue(usb_tx_wq);\r\n}\r\nif (usb_rx_wq) {\r\nflush_workqueue(usb_rx_wq);\r\ndestroy_workqueue(usb_rx_wq);\r\n}\r\n}
