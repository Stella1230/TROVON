int omapdss_output_set_device(struct omap_dss_device *out,\r\nstruct omap_dss_device *dssdev)\r\n{\r\nint r;\r\nmutex_lock(&output_lock);\r\nif (out->dst) {\r\nDSSERR("output already has device %s connected to it\n",\r\nout->dst->name);\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nif (out->output_type != dssdev->type) {\r\nDSSERR("output type and display type don't match\n");\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nout->dst = dssdev;\r\ndssdev->src = out;\r\nmutex_unlock(&output_lock);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&output_lock);\r\nreturn r;\r\n}\r\nint omapdss_output_unset_device(struct omap_dss_device *out)\r\n{\r\nint r;\r\nmutex_lock(&output_lock);\r\nif (!out->dst) {\r\nDSSERR("output doesn't have a device connected to it\n");\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nif (out->dst->state != OMAP_DSS_DISPLAY_DISABLED) {\r\nDSSERR("device %s is not disabled, cannot unset device\n",\r\nout->dst->name);\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nout->dst->src = NULL;\r\nout->dst = NULL;\r\nmutex_unlock(&output_lock);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&output_lock);\r\nreturn r;\r\n}\r\nint omapdss_register_output(struct omap_dss_device *out)\r\n{\r\nlist_add_tail(&out->list, &output_list);\r\nreturn 0;\r\n}\r\nvoid omapdss_unregister_output(struct omap_dss_device *out)\r\n{\r\nlist_del(&out->list);\r\n}\r\nstruct omap_dss_device *omap_dss_get_output(enum omap_dss_output_id id)\r\n{\r\nstruct omap_dss_device *out;\r\nlist_for_each_entry(out, &output_list, list) {\r\nif (out->id == id)\r\nreturn out;\r\n}\r\nreturn NULL;\r\n}\r\nstruct omap_dss_device *omap_dss_find_output(const char *name)\r\n{\r\nstruct omap_dss_device *out;\r\nlist_for_each_entry(out, &output_list, list) {\r\nif (strcmp(out->name, name) == 0)\r\nreturn omap_dss_get_device(out);\r\n}\r\nreturn NULL;\r\n}\r\nstruct omap_dss_device *omap_dss_find_output_by_node(struct device_node *node)\r\n{\r\nstruct omap_dss_device *out;\r\nlist_for_each_entry(out, &output_list, list) {\r\nif (out->dev->of_node == node)\r\nreturn omap_dss_get_device(out);\r\n}\r\nreturn NULL;\r\n}\r\nstruct omap_dss_device *omapdss_find_output_from_display(struct omap_dss_device *dssdev)\r\n{\r\nwhile (dssdev->src)\r\ndssdev = dssdev->src;\r\nif (dssdev->id != 0)\r\nreturn omap_dss_get_device(dssdev);\r\nreturn NULL;\r\n}\r\nstruct omap_overlay_manager *omapdss_find_mgr_from_display(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_dss_device *out;\r\nstruct omap_overlay_manager *mgr;\r\nout = omapdss_find_output_from_display(dssdev);\r\nif (out == NULL)\r\nreturn NULL;\r\nmgr = out->manager;\r\nomap_dss_put_device(out);\r\nreturn mgr;\r\n}\r\nint dss_install_mgr_ops(const struct dss_mgr_ops *mgr_ops)\r\n{\r\nif (dss_mgr_ops)\r\nreturn -EBUSY;\r\ndss_mgr_ops = mgr_ops;\r\nreturn 0;\r\n}\r\nvoid dss_uninstall_mgr_ops(void)\r\n{\r\ndss_mgr_ops = NULL;\r\n}\r\nint dss_mgr_connect(struct omap_overlay_manager *mgr,\r\nstruct omap_dss_device *dst)\r\n{\r\nreturn dss_mgr_ops->connect(mgr, dst);\r\n}\r\nvoid dss_mgr_disconnect(struct omap_overlay_manager *mgr,\r\nstruct omap_dss_device *dst)\r\n{\r\ndss_mgr_ops->disconnect(mgr, dst);\r\n}\r\nvoid dss_mgr_set_timings(struct omap_overlay_manager *mgr,\r\nconst struct omap_video_timings *timings)\r\n{\r\ndss_mgr_ops->set_timings(mgr, timings);\r\n}\r\nvoid dss_mgr_set_lcd_config(struct omap_overlay_manager *mgr,\r\nconst struct dss_lcd_mgr_config *config)\r\n{\r\ndss_mgr_ops->set_lcd_config(mgr, config);\r\n}\r\nint dss_mgr_enable(struct omap_overlay_manager *mgr)\r\n{\r\nreturn dss_mgr_ops->enable(mgr);\r\n}\r\nvoid dss_mgr_disable(struct omap_overlay_manager *mgr)\r\n{\r\ndss_mgr_ops->disable(mgr);\r\n}\r\nvoid dss_mgr_start_update(struct omap_overlay_manager *mgr)\r\n{\r\ndss_mgr_ops->start_update(mgr);\r\n}\r\nint dss_mgr_register_framedone_handler(struct omap_overlay_manager *mgr,\r\nvoid (*handler)(void *), void *data)\r\n{\r\nreturn dss_mgr_ops->register_framedone_handler(mgr, handler, data);\r\n}\r\nvoid dss_mgr_unregister_framedone_handler(struct omap_overlay_manager *mgr,\r\nvoid (*handler)(void *), void *data)\r\n{\r\ndss_mgr_ops->unregister_framedone_handler(mgr, handler, data);\r\n}
