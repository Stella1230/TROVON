static inline unsigned char linear2alaw(short int linear)\r\n{\r\nint mask;\r\nint seg;\r\nint pcm_val;\r\nstatic int seg_end[8] = {\r\n0xFF, 0x1FF, 0x3FF, 0x7FF, 0xFFF, 0x1FFF, 0x3FFF, 0x7FFF\r\n};\r\npcm_val = linear;\r\nif (pcm_val >= 0) {\r\nmask = AMI_MASK | 0x80;\r\n} else {\r\nmask = AMI_MASK;\r\npcm_val = -pcm_val;\r\n}\r\nfor (seg = 0; seg < 8; seg++) {\r\nif (pcm_val <= seg_end[seg])\r\nbreak;\r\n}\r\nreturn ((seg << 4) |\r\n((pcm_val >> ((seg) ? (seg + 3) : 4)) & 0x0F)) ^ mask;\r\n}\r\nstatic inline short int alaw2linear(unsigned char alaw)\r\n{\r\nint i;\r\nint seg;\r\nalaw ^= AMI_MASK;\r\ni = ((alaw & 0x0F) << 4) + 8 ;\r\nseg = (((int) alaw & 0x70) >> 4);\r\nif (seg)\r\ni = (i + 0x100) << (seg - 1);\r\nreturn (short int) ((alaw & 0x80) ? i : -i);\r\n}\r\nstatic inline short int ulaw2linear(unsigned char ulaw)\r\n{\r\nshort mu, e, f, y;\r\nstatic short etab[] = {0, 132, 396, 924, 1980, 4092, 8316, 16764};\r\nmu = 255 - ulaw;\r\ne = (mu & 0x70) / 16;\r\nf = mu & 0x0f;\r\ny = f * (1 << (e + 3));\r\ny += etab[e];\r\nif (mu & 0x80)\r\ny = -y;\r\nreturn y;\r\n}\r\nstatic unsigned char linear2ulaw(short sample)\r\n{\r\nstatic int exp_lut[256] = {\r\n0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,\r\n4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\r\n5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\r\n5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\r\n6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\r\n6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\r\n6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\r\n6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};\r\nint sign, exponent, mantissa;\r\nunsigned char ulawbyte;\r\nsign = (sample >> 8) & 0x80;\r\nif (sign != 0)\r\nsample = -sample;\r\nsample = sample + BIAS;\r\nexponent = exp_lut[(sample >> 7) & 0xFF];\r\nmantissa = (sample >> (exponent + 3)) & 0x0F;\r\nulawbyte = ~(sign | (exponent << 4) | mantissa);\r\nreturn ulawbyte;\r\n}\r\nstatic int reverse_bits(int i)\r\n{\r\nint z, j;\r\nz = 0;\r\nfor (j = 0; j < 8; j++) {\r\nif ((i & (1 << j)) != 0)\r\nz |= 1 << (7 - j);\r\n}\r\nreturn z;\r\n}\r\nvoid dsp_audio_generate_law_tables(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 256; i++)\r\ndsp_audio_alaw_to_s32[i] = alaw2linear(reverse_bits(i));\r\nfor (i = 0; i < 256; i++)\r\ndsp_audio_ulaw_to_s32[i] = ulaw2linear(reverse_bits(i));\r\nfor (i = 0; i < 256; i++) {\r\ndsp_audio_alaw_to_ulaw[i] =\r\nlinear2ulaw(dsp_audio_alaw_to_s32[i]);\r\ndsp_audio_ulaw_to_alaw[i] =\r\nlinear2alaw(dsp_audio_ulaw_to_s32[i]);\r\n}\r\n}\r\nvoid\r\ndsp_audio_generate_s2law_table(void)\r\n{\r\nint i;\r\nif (dsp_options & DSP_OPT_ULAW) {\r\nfor (i = -32768; i < 32768; i++) {\r\ndsp_audio_s16_to_law[i & 0xffff] =\r\nreverse_bits(linear2ulaw(i));\r\n}\r\n} else {\r\nfor (i = -32768; i < 32768; i++) {\r\ndsp_audio_s16_to_law[i & 0xffff] =\r\nreverse_bits(linear2alaw(i));\r\n}\r\n}\r\n}\r\nvoid\r\ndsp_audio_generate_seven(void)\r\n{\r\nint i, j, k;\r\nu8 spl;\r\nu8 sorted_alaw[256];\r\nfor (i = 0; i < 256; i++) {\r\nj = 0;\r\nfor (k = 0; k < 256; k++) {\r\nif (dsp_audio_alaw_to_s32[k]\r\n< dsp_audio_alaw_to_s32[i])\r\nj++;\r\n}\r\nsorted_alaw[j] = i;\r\n}\r\nfor (i = 0; i < 256; i++) {\r\nspl = i;\r\nif (dsp_options & DSP_OPT_ULAW)\r\nspl = dsp_audio_ulaw_to_alaw[i];\r\nfor (j = 0; j < 256; j++) {\r\nif (sorted_alaw[j] == spl)\r\nbreak;\r\n}\r\ndsp_audio_law2seven[i] = j >> 1;\r\n}\r\nfor (i = 0; i < 128; i++) {\r\nspl = sorted_alaw[i << 1];\r\nif (dsp_options & DSP_OPT_ULAW)\r\nspl = dsp_audio_alaw_to_ulaw[spl];\r\ndsp_audio_seven2law[i] = spl;\r\n}\r\n}\r\nvoid\r\ndsp_audio_generate_mix_table(void)\r\n{\r\nint i, j;\r\ns32 sample;\r\ni = 0;\r\nwhile (i < 256) {\r\nj = 0;\r\nwhile (j < 256) {\r\nsample = dsp_audio_law_to_s32[i];\r\nsample += dsp_audio_law_to_s32[j];\r\nif (sample > 32767)\r\nsample = 32767;\r\nif (sample < -32768)\r\nsample = -32768;\r\ndsp_audio_mix_law[(i << 8) | j] =\r\ndsp_audio_s16_to_law[sample & 0xffff];\r\nj++;\r\n}\r\ni++;\r\n}\r\n}\r\nvoid\r\ndsp_audio_generate_volume_changes(void)\r\n{\r\nregister s32 sample;\r\nint i;\r\nint num[] = { 110, 125, 150, 175, 200, 300, 400, 500 };\r\nint denum[] = { 100, 100, 100, 100, 100, 100, 100, 100 };\r\ni = 0;\r\nwhile (i < 256) {\r\ndsp_audio_reduce8[i] = dsp_audio_s16_to_law[\r\n(dsp_audio_law_to_s32[i] * denum[7] / num[7]) & 0xffff];\r\ndsp_audio_reduce7[i] = dsp_audio_s16_to_law[\r\n(dsp_audio_law_to_s32[i] * denum[6] / num[6]) & 0xffff];\r\ndsp_audio_reduce6[i] = dsp_audio_s16_to_law[\r\n(dsp_audio_law_to_s32[i] * denum[5] / num[5]) & 0xffff];\r\ndsp_audio_reduce5[i] = dsp_audio_s16_to_law[\r\n(dsp_audio_law_to_s32[i] * denum[4] / num[4]) & 0xffff];\r\ndsp_audio_reduce4[i] = dsp_audio_s16_to_law[\r\n(dsp_audio_law_to_s32[i] * denum[3] / num[3]) & 0xffff];\r\ndsp_audio_reduce3[i] = dsp_audio_s16_to_law[\r\n(dsp_audio_law_to_s32[i] * denum[2] / num[2]) & 0xffff];\r\ndsp_audio_reduce2[i] = dsp_audio_s16_to_law[\r\n(dsp_audio_law_to_s32[i] * denum[1] / num[1]) & 0xffff];\r\ndsp_audio_reduce1[i] = dsp_audio_s16_to_law[\r\n(dsp_audio_law_to_s32[i] * denum[0] / num[0]) & 0xffff];\r\nsample = dsp_audio_law_to_s32[i] * num[0] / denum[0];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\ndsp_audio_increase1[i] = dsp_audio_s16_to_law[sample & 0xffff];\r\nsample = dsp_audio_law_to_s32[i] * num[1] / denum[1];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\ndsp_audio_increase2[i] = dsp_audio_s16_to_law[sample & 0xffff];\r\nsample = dsp_audio_law_to_s32[i] * num[2] / denum[2];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\ndsp_audio_increase3[i] = dsp_audio_s16_to_law[sample & 0xffff];\r\nsample = dsp_audio_law_to_s32[i] * num[3] / denum[3];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\ndsp_audio_increase4[i] = dsp_audio_s16_to_law[sample & 0xffff];\r\nsample = dsp_audio_law_to_s32[i] * num[4] / denum[4];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\ndsp_audio_increase5[i] = dsp_audio_s16_to_law[sample & 0xffff];\r\nsample = dsp_audio_law_to_s32[i] * num[5] / denum[5];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\ndsp_audio_increase6[i] = dsp_audio_s16_to_law[sample & 0xffff];\r\nsample = dsp_audio_law_to_s32[i] * num[6] / denum[6];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\ndsp_audio_increase7[i] = dsp_audio_s16_to_law[sample & 0xffff];\r\nsample = dsp_audio_law_to_s32[i] * num[7] / denum[7];\r\nif (sample < -32768)\r\nsample = -32768;\r\nelse if (sample > 32767)\r\nsample = 32767;\r\ndsp_audio_increase8[i] = dsp_audio_s16_to_law[sample & 0xffff];\r\ni++;\r\n}\r\n}\r\nvoid\r\ndsp_change_volume(struct sk_buff *skb, int volume)\r\n{\r\nu8 *volume_change;\r\nint i, ii;\r\nu8 *p;\r\nint shift;\r\nif (volume == 0)\r\nreturn;\r\nif (volume < 0) {\r\nshift = volume + 8;\r\nif (shift < 0)\r\nshift = 0;\r\n} else {\r\nshift = volume + 7;\r\nif (shift > 15)\r\nshift = 15;\r\n}\r\nvolume_change = dsp_audio_volume_change[shift];\r\ni = 0;\r\nii = skb->len;\r\np = skb->data;\r\nwhile (i < ii) {\r\n*p = volume_change[*p];\r\np++;\r\ni++;\r\n}\r\n}
