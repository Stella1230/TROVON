struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,\r\nenum dma_data_direction data_dir,\r\ngfp_t gfp_mask)\r\n{\r\nint write = (data_dir == DMA_TO_DEVICE);\r\nstruct request *rq;\r\nstruct scsi_cmnd *cmd;\r\nstruct scsi_tgt_cmd *tcmd;\r\nif (!get_device(&shost->shost_gendev))\r\nreturn NULL;\r\ntcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);\r\nif (!tcmd)\r\ngoto put_dev;\r\nrq = blk_get_request(shost->uspace_req_q, !write, gfp_mask);\r\nif (!rq)\r\ngoto free_tcmd;\r\ncmd = __scsi_get_command(shost, gfp_mask);\r\nif (!cmd)\r\ngoto release_rq;\r\ncmd->sc_data_direction = data_dir;\r\ncmd->jiffies_at_alloc = jiffies;\r\ncmd->request = rq;\r\ncmd->cmnd = rq->cmd;\r\nrq->special = cmd;\r\nrq->cmd_type = REQ_TYPE_SPECIAL;\r\nrq->cmd_flags |= REQ_TYPE_BLOCK_PC;\r\nrq->end_io_data = tcmd;\r\ntcmd->rq = rq;\r\nreturn cmd;\r\nrelease_rq:\r\nblk_put_request(rq);\r\nfree_tcmd:\r\nkmem_cache_free(scsi_tgt_cmd_cache, tcmd);\r\nput_dev:\r\nput_device(&shost->shost_gendev);\r\nreturn NULL;\r\n}\r\nvoid scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\r\n{\r\nstruct request_queue *q = shost->uspace_req_q;\r\nstruct request *rq = cmd->request;\r\nstruct scsi_tgt_cmd *tcmd = rq->end_io_data;\r\nunsigned long flags;\r\nkmem_cache_free(scsi_tgt_cmd_cache, tcmd);\r\nspin_lock_irqsave(q->queue_lock, flags);\r\n__blk_put_request(q, rq);\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\n__scsi_put_command(shost, cmd);\r\nput_device(&shost->shost_gendev);\r\n}\r\nstatic void cmd_hashlist_del(struct scsi_cmnd *cmd)\r\n{\r\nstruct request_queue *q = cmd->request->q;\r\nstruct scsi_tgt_queuedata *qdata = q->queuedata;\r\nunsigned long flags;\r\nstruct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;\r\nspin_lock_irqsave(&qdata->cmd_hash_lock, flags);\r\nlist_del(&tcmd->hash_list);\r\nspin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);\r\n}\r\nstatic void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)\r\n{\r\nblk_rq_unmap_user(tcmd->bio);\r\n}\r\nstatic void scsi_tgt_cmd_destroy(struct work_struct *work)\r\n{\r\nstruct scsi_tgt_cmd *tcmd =\r\ncontainer_of(work, struct scsi_tgt_cmd, work);\r\nstruct scsi_cmnd *cmd = tcmd->rq->special;\r\ndprintk("cmd %p %d %u\n", cmd, cmd->sc_data_direction,\r\nrq_data_dir(cmd->request));\r\nscsi_unmap_user_pages(tcmd);\r\ntcmd->rq->bio = NULL;\r\nscsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);\r\n}\r\nstatic void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd,\r\nu64 itn_id, u64 tag)\r\n{\r\nstruct scsi_tgt_queuedata *qdata = rq->q->queuedata;\r\nunsigned long flags;\r\nstruct list_head *head;\r\ntcmd->itn_id = itn_id;\r\ntcmd->tag = tag;\r\ntcmd->bio = NULL;\r\nINIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy);\r\nspin_lock_irqsave(&qdata->cmd_hash_lock, flags);\r\nhead = &qdata->cmd_hash[cmd_hashfn(tag)];\r\nlist_add(&tcmd->hash_list, head);\r\nspin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);\r\n}\r\nint scsi_tgt_alloc_queue(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_tgt_queuedata *queuedata;\r\nstruct request_queue *q;\r\nint err, i;\r\nq = __scsi_alloc_queue(shost, NULL);\r\nif (!q)\r\nreturn -ENOMEM;\r\nqueuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);\r\nif (!queuedata) {\r\nerr = -ENOMEM;\r\ngoto cleanup_queue;\r\n}\r\nqueuedata->shost = shost;\r\nq->queuedata = queuedata;\r\nq->nr_requests = shost->can_queue;\r\nblk_queue_dma_alignment(q, 0);\r\nshost->uspace_req_q = q;\r\nfor (i = 0; i < ARRAY_SIZE(queuedata->cmd_hash); i++)\r\nINIT_LIST_HEAD(&queuedata->cmd_hash[i]);\r\nspin_lock_init(&queuedata->cmd_hash_lock);\r\nreturn 0;\r\ncleanup_queue:\r\nblk_cleanup_queue(q);\r\nreturn err;\r\n}\r\nvoid scsi_tgt_free_queue(struct Scsi_Host *shost)\r\n{\r\nint i;\r\nunsigned long flags;\r\nstruct request_queue *q = shost->uspace_req_q;\r\nstruct scsi_cmnd *cmd;\r\nstruct scsi_tgt_queuedata *qdata = q->queuedata;\r\nstruct scsi_tgt_cmd *tcmd, *n;\r\nLIST_HEAD(cmds);\r\nspin_lock_irqsave(&qdata->cmd_hash_lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(qdata->cmd_hash); i++) {\r\nlist_for_each_entry_safe(tcmd, n, &qdata->cmd_hash[i],\r\nhash_list)\r\nlist_move(&tcmd->hash_list, &cmds);\r\n}\r\nspin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);\r\nwhile (!list_empty(&cmds)) {\r\ntcmd = list_entry(cmds.next, struct scsi_tgt_cmd, hash_list);\r\nlist_del(&tcmd->hash_list);\r\ncmd = tcmd->rq->special;\r\nshost->hostt->eh_abort_handler(cmd);\r\nscsi_tgt_cmd_destroy(&tcmd->work);\r\n}\r\n}\r\nstruct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;\r\nreturn queue->shost;\r\n}\r\nint scsi_tgt_queue_command(struct scsi_cmnd *cmd, u64 itn_id,\r\nstruct scsi_lun *scsilun, u64 tag)\r\n{\r\nstruct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;\r\nint err;\r\ninit_scsi_tgt_cmd(cmd->request, tcmd, itn_id, tag);\r\nerr = scsi_tgt_uspace_send_cmd(cmd, itn_id, scsilun, tag);\r\nif (err)\r\ncmd_hashlist_del(cmd);\r\nreturn err;\r\n}\r\nstatic void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;\r\ndprintk("cmd %p %u\n", cmd, rq_data_dir(cmd->request));\r\nscsi_tgt_uspace_send_status(cmd, tcmd->itn_id, tcmd->tag);\r\nscsi_release_buffers(cmd);\r\nqueue_work(scsi_tgtd, &tcmd->work);\r\n}\r\nstatic int scsi_tgt_transfer_response(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);\r\nint err;\r\ndprintk("cmd %p %u\n", cmd, rq_data_dir(cmd->request));\r\nerr = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);\r\nswitch (err) {\r\ncase SCSI_MLQUEUE_HOST_BUSY:\r\ncase SCSI_MLQUEUE_DEVICE_BUSY:\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,\r\nunsigned long uaddr, unsigned int len, int rw)\r\n{\r\nstruct request_queue *q = cmd->request->q;\r\nstruct request *rq = cmd->request;\r\nint err;\r\ndprintk("%lx %u\n", uaddr, len);\r\nerr = blk_rq_map_user(q, rq, NULL, (void *)uaddr, len, GFP_KERNEL);\r\nif (err) {\r\neprintk("Could not handle request of size %u.\n", len);\r\nreturn err;\r\n}\r\ntcmd->bio = rq->bio;\r\nerr = scsi_init_io(cmd, GFP_KERNEL);\r\nif (err) {\r\nscsi_release_buffers(cmd);\r\ngoto unmap_rq;\r\n}\r\ncmd->sdb.length = blk_rq_bytes(rq);\r\nreturn 0;\r\nunmap_rq:\r\nscsi_unmap_user_pages(tcmd);\r\nreturn err;\r\n}\r\nstatic int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,\r\nunsigned len)\r\n{\r\nchar __user *p = (char __user *) uaddr;\r\nif (copy_from_user(cmd->sense_buffer, p,\r\nmin_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {\r\nprintk(KERN_ERR "Could not copy the sense buffer\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scsi_tgt_abort_cmd(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_tgt_cmd *tcmd;\r\nint err;\r\nerr = shost->hostt->eh_abort_handler(cmd);\r\nif (err)\r\neprintk("fail to abort %p\n", cmd);\r\ntcmd = cmd->request->end_io_data;\r\nscsi_tgt_cmd_destroy(&tcmd->work);\r\nreturn err;\r\n}\r\nstatic struct request *tgt_cmd_hash_lookup(struct request_queue *q, u64 tag)\r\n{\r\nstruct scsi_tgt_queuedata *qdata = q->queuedata;\r\nstruct request *rq = NULL;\r\nstruct list_head *head;\r\nstruct scsi_tgt_cmd *tcmd;\r\nunsigned long flags;\r\nhead = &qdata->cmd_hash[cmd_hashfn(tag)];\r\nspin_lock_irqsave(&qdata->cmd_hash_lock, flags);\r\nlist_for_each_entry(tcmd, head, hash_list) {\r\nif (tcmd->tag == tag) {\r\nrq = tcmd->rq;\r\nlist_del(&tcmd->hash_list);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);\r\nreturn rq;\r\n}\r\nint scsi_tgt_kspace_exec(int host_no, u64 itn_id, int result, u64 tag,\r\nunsigned long uaddr, u32 len, unsigned long sense_uaddr,\r\nu32 sense_len, u8 rw)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct scsi_cmnd *cmd;\r\nstruct request *rq;\r\nstruct scsi_tgt_cmd *tcmd;\r\nint err = 0;\r\ndprintk("%d %llu %d %u %lx %u\n", host_no, (unsigned long long) tag,\r\nresult, len, uaddr, rw);\r\nshost = scsi_host_lookup(host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "Could not find host no %d\n", host_no);\r\nreturn -EINVAL;\r\n}\r\nif (!shost->uspace_req_q) {\r\nprintk(KERN_ERR "Not target scsi host %d\n", host_no);\r\ngoto done;\r\n}\r\nrq = tgt_cmd_hash_lookup(shost->uspace_req_q, tag);\r\nif (!rq) {\r\nprintk(KERN_ERR "Could not find tag %llu\n",\r\n(unsigned long long) tag);\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\ncmd = rq->special;\r\ndprintk("cmd %p scb %x result %d len %d bufflen %u %u %x\n",\r\ncmd, cmd->cmnd[0], result, len, scsi_bufflen(cmd),\r\nrq_data_dir(rq), cmd->cmnd[0]);\r\nif (result == TASK_ABORTED) {\r\nscsi_tgt_abort_cmd(shost, cmd);\r\ngoto done;\r\n}\r\ntcmd = cmd->request->end_io_data;\r\ncmd->result = result;\r\nif (cmd->result == SAM_STAT_CHECK_CONDITION)\r\nscsi_tgt_copy_sense(cmd, sense_uaddr, sense_len);\r\nif (len) {\r\nerr = scsi_map_user_pages(rq->end_io_data, cmd, uaddr, len, rw);\r\nif (err) {\r\nstruct scsi_tgt_queuedata *qdata;\r\nstruct list_head *head;\r\nunsigned long flags;\r\neprintk("cmd %p ret %d uaddr %lx len %d rw %d\n",\r\ncmd, err, uaddr, len, rw);\r\nqdata = shost->uspace_req_q->queuedata;\r\nhead = &qdata->cmd_hash[cmd_hashfn(tcmd->tag)];\r\nspin_lock_irqsave(&qdata->cmd_hash_lock, flags);\r\nlist_add(&tcmd->hash_list, head);\r\nspin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);\r\ngoto done;\r\n}\r\n}\r\nerr = scsi_tgt_transfer_response(cmd);\r\ndone:\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nint scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, u64 itn_id,\r\nint function, u64 tag, struct scsi_lun *scsilun,\r\nvoid *data)\r\n{\r\nint err;\r\nerr = scsi_tgt_uspace_send_tsk_mgmt(shost->host_no, itn_id,\r\nfunction, tag, scsilun, data);\r\nif (err < 0)\r\neprintk("The task management request lost!\n");\r\nreturn err;\r\n}\r\nint scsi_tgt_kspace_tsk_mgmt(int host_no, u64 itn_id, u64 mid, int result)\r\n{\r\nstruct Scsi_Host *shost;\r\nint err = -EINVAL;\r\ndprintk("%d %d %llx\n", host_no, result, (unsigned long long) mid);\r\nshost = scsi_host_lookup(host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "Could not find host no %d\n", host_no);\r\nreturn err;\r\n}\r\nif (!shost->uspace_req_q) {\r\nprintk(KERN_ERR "Not target scsi host %d\n", host_no);\r\ngoto done;\r\n}\r\nerr = shost->transportt->tsk_mgmt_response(shost, itn_id, mid, result);\r\ndone:\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nint scsi_tgt_it_nexus_create(struct Scsi_Host *shost, u64 itn_id,\r\nchar *initiator)\r\n{\r\nint err;\r\nerr = scsi_tgt_uspace_send_it_nexus_request(shost->host_no, itn_id, 0,\r\ninitiator);\r\nif (err < 0)\r\neprintk("The i_t_neuxs request lost, %d %llx!\n",\r\nshost->host_no, (unsigned long long)itn_id);\r\nreturn err;\r\n}\r\nint scsi_tgt_it_nexus_destroy(struct Scsi_Host *shost, u64 itn_id)\r\n{\r\nint err;\r\nerr = scsi_tgt_uspace_send_it_nexus_request(shost->host_no,\r\nitn_id, 1, NULL);\r\nif (err < 0)\r\neprintk("The i_t_neuxs request lost, %d %llx!\n",\r\nshost->host_no, (unsigned long long)itn_id);\r\nreturn err;\r\n}\r\nint scsi_tgt_kspace_it_nexus_rsp(int host_no, u64 itn_id, int result)\r\n{\r\nstruct Scsi_Host *shost;\r\nint err = -EINVAL;\r\ndprintk("%d %d%llx\n", host_no, result, (unsigned long long)itn_id);\r\nshost = scsi_host_lookup(host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "Could not find host no %d\n", host_no);\r\nreturn err;\r\n}\r\nif (!shost->uspace_req_q) {\r\nprintk(KERN_ERR "Not target scsi host %d\n", host_no);\r\ngoto done;\r\n}\r\nerr = shost->transportt->it_nexus_response(shost, itn_id, result);\r\ndone:\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic int __init scsi_tgt_init(void)\r\n{\r\nint err;\r\nscsi_tgt_cmd_cache = KMEM_CACHE(scsi_tgt_cmd, 0);\r\nif (!scsi_tgt_cmd_cache)\r\nreturn -ENOMEM;\r\nscsi_tgtd = alloc_workqueue("scsi_tgtd", 0, 1);\r\nif (!scsi_tgtd) {\r\nerr = -ENOMEM;\r\ngoto free_kmemcache;\r\n}\r\nerr = scsi_tgt_if_init();\r\nif (err)\r\ngoto destroy_wq;\r\nreturn 0;\r\ndestroy_wq:\r\ndestroy_workqueue(scsi_tgtd);\r\nfree_kmemcache:\r\nkmem_cache_destroy(scsi_tgt_cmd_cache);\r\nreturn err;\r\n}\r\nstatic void __exit scsi_tgt_exit(void)\r\n{\r\ndestroy_workqueue(scsi_tgtd);\r\nscsi_tgt_if_exit();\r\nkmem_cache_destroy(scsi_tgt_cmd_cache);\r\n}
