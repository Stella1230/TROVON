static inline u32 bcm2835_gpio_rd(struct bcm2835_pinctrl *pc, unsigned reg)\r\n{\r\nreturn readl(pc->base + reg);\r\n}\r\nstatic inline void bcm2835_gpio_wr(struct bcm2835_pinctrl *pc, unsigned reg,\r\nu32 val)\r\n{\r\nwritel(val, pc->base + reg);\r\n}\r\nstatic inline int bcm2835_gpio_get_bit(struct bcm2835_pinctrl *pc, unsigned reg,\r\nunsigned bit)\r\n{\r\nreg += GPIO_REG_OFFSET(bit) * 4;\r\nreturn (bcm2835_gpio_rd(pc, reg) >> GPIO_REG_SHIFT(bit)) & 1;\r\n}\r\nstatic inline void bcm2835_gpio_set_bit(struct bcm2835_pinctrl *pc,\r\nunsigned reg, unsigned bit)\r\n{\r\nreg += GPIO_REG_OFFSET(bit) * 4;\r\nbcm2835_gpio_wr(pc, reg, BIT(GPIO_REG_SHIFT(bit)));\r\n}\r\nstatic inline enum bcm2835_fsel bcm2835_pinctrl_fsel_get(\r\nstruct bcm2835_pinctrl *pc, unsigned pin)\r\n{\r\nu32 val = bcm2835_gpio_rd(pc, FSEL_REG(pin));\r\nenum bcm2835_fsel status = (val >> FSEL_SHIFT(pin)) & BCM2835_FSEL_MASK;\r\ndev_dbg(pc->dev, "get %08x (%u => %s)\n", val, pin,\r\nbcm2835_functions[status]);\r\nreturn status;\r\n}\r\nstatic inline void bcm2835_pinctrl_fsel_set(\r\nstruct bcm2835_pinctrl *pc, unsigned pin,\r\nenum bcm2835_fsel fsel)\r\n{\r\nu32 val = bcm2835_gpio_rd(pc, FSEL_REG(pin));\r\nenum bcm2835_fsel cur = (val >> FSEL_SHIFT(pin)) & BCM2835_FSEL_MASK;\r\ndev_dbg(pc->dev, "read %08x (%u => %s)\n", val, pin,\r\nbcm2835_functions[cur]);\r\nif (cur == fsel)\r\nreturn;\r\nif (cur != BCM2835_FSEL_GPIO_IN && fsel != BCM2835_FSEL_GPIO_IN) {\r\nval &= ~(BCM2835_FSEL_MASK << FSEL_SHIFT(pin));\r\nval |= BCM2835_FSEL_GPIO_IN << FSEL_SHIFT(pin);\r\ndev_dbg(pc->dev, "trans %08x (%u <= %s)\n", val, pin,\r\nbcm2835_functions[BCM2835_FSEL_GPIO_IN]);\r\nbcm2835_gpio_wr(pc, FSEL_REG(pin), val);\r\n}\r\nval &= ~(BCM2835_FSEL_MASK << FSEL_SHIFT(pin));\r\nval |= fsel << FSEL_SHIFT(pin);\r\ndev_dbg(pc->dev, "write %08x (%u <= %s)\n", val, pin,\r\nbcm2835_functions[fsel]);\r\nbcm2835_gpio_wr(pc, FSEL_REG(pin), val);\r\n}\r\nstatic int bcm2835_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_request_gpio(chip->base + offset);\r\n}\r\nstatic void bcm2835_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\npinctrl_free_gpio(chip->base + offset);\r\n}\r\nstatic int bcm2835_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(chip->base + offset);\r\n}\r\nstatic int bcm2835_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct bcm2835_pinctrl *pc = dev_get_drvdata(chip->dev);\r\nreturn bcm2835_gpio_get_bit(pc, GPLEV0, offset);\r\n}\r\nstatic int bcm2835_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nreturn pinctrl_gpio_direction_output(chip->base + offset);\r\n}\r\nstatic void bcm2835_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct bcm2835_pinctrl *pc = dev_get_drvdata(chip->dev);\r\nbcm2835_gpio_set_bit(pc, value ? GPSET0 : GPCLR0, offset);\r\n}\r\nstatic int bcm2835_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct bcm2835_pinctrl *pc = dev_get_drvdata(chip->dev);\r\nreturn irq_linear_revmap(pc->irq_domain, offset);\r\n}\r\nstatic irqreturn_t bcm2835_gpio_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct bcm2835_gpio_irqdata *irqdata = dev_id;\r\nstruct bcm2835_pinctrl *pc = irqdata->pc;\r\nint bank = irqdata->bank;\r\nunsigned long events;\r\nunsigned offset;\r\nunsigned gpio;\r\nunsigned int type;\r\nevents = bcm2835_gpio_rd(pc, GPEDS0 + bank * 4);\r\nevents &= pc->enabled_irq_map[bank];\r\nfor_each_set_bit(offset, &events, 32) {\r\ngpio = (32 * bank) + offset;\r\ntype = pc->irq_type[gpio];\r\nif (!(type & IRQ_TYPE_LEVEL_MASK))\r\nbcm2835_gpio_set_bit(pc, GPEDS0, gpio);\r\ngeneric_handle_irq(irq_linear_revmap(pc->irq_domain, gpio));\r\nif (type & IRQ_TYPE_LEVEL_MASK)\r\nbcm2835_gpio_set_bit(pc, GPEDS0, gpio);\r\n}\r\nreturn events ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic inline void __bcm2835_gpio_irq_config(struct bcm2835_pinctrl *pc,\r\nunsigned reg, unsigned offset, bool enable)\r\n{\r\nu32 value;\r\nreg += GPIO_REG_OFFSET(offset) * 4;\r\nvalue = bcm2835_gpio_rd(pc, reg);\r\nif (enable)\r\nvalue |= BIT(GPIO_REG_SHIFT(offset));\r\nelse\r\nvalue &= ~(BIT(GPIO_REG_SHIFT(offset)));\r\nbcm2835_gpio_wr(pc, reg, value);\r\n}\r\nstatic void bcm2835_gpio_irq_config(struct bcm2835_pinctrl *pc,\r\nunsigned offset, bool enable)\r\n{\r\nswitch (pc->irq_type[offset]) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\n__bcm2835_gpio_irq_config(pc, GPREN0, offset, enable);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\n__bcm2835_gpio_irq_config(pc, GPFEN0, offset, enable);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\n__bcm2835_gpio_irq_config(pc, GPREN0, offset, enable);\r\n__bcm2835_gpio_irq_config(pc, GPFEN0, offset, enable);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\n__bcm2835_gpio_irq_config(pc, GPHEN0, offset, enable);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\n__bcm2835_gpio_irq_config(pc, GPLEN0, offset, enable);\r\nbreak;\r\n}\r\n}\r\nstatic void bcm2835_gpio_irq_enable(struct irq_data *data)\r\n{\r\nstruct bcm2835_pinctrl *pc = irq_data_get_irq_chip_data(data);\r\nunsigned gpio = irqd_to_hwirq(data);\r\nunsigned offset = GPIO_REG_SHIFT(gpio);\r\nunsigned bank = GPIO_REG_OFFSET(gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pc->irq_lock[bank], flags);\r\nset_bit(offset, &pc->enabled_irq_map[bank]);\r\nbcm2835_gpio_irq_config(pc, gpio, true);\r\nspin_unlock_irqrestore(&pc->irq_lock[bank], flags);\r\n}\r\nstatic void bcm2835_gpio_irq_disable(struct irq_data *data)\r\n{\r\nstruct bcm2835_pinctrl *pc = irq_data_get_irq_chip_data(data);\r\nunsigned gpio = irqd_to_hwirq(data);\r\nunsigned offset = GPIO_REG_SHIFT(gpio);\r\nunsigned bank = GPIO_REG_OFFSET(gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pc->irq_lock[bank], flags);\r\nbcm2835_gpio_irq_config(pc, gpio, false);\r\nclear_bit(offset, &pc->enabled_irq_map[bank]);\r\nspin_unlock_irqrestore(&pc->irq_lock[bank], flags);\r\n}\r\nstatic int __bcm2835_gpio_irq_set_type_disabled(struct bcm2835_pinctrl *pc,\r\nunsigned offset, unsigned int type)\r\n{\r\nswitch (type) {\r\ncase IRQ_TYPE_NONE:\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ncase IRQ_TYPE_LEVEL_LOW:\r\npc->irq_type[offset] = type;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __bcm2835_gpio_irq_set_type_enabled(struct bcm2835_pinctrl *pc,\r\nunsigned offset, unsigned int type)\r\n{\r\nswitch (type) {\r\ncase IRQ_TYPE_NONE:\r\nif (pc->irq_type[offset] != type) {\r\nbcm2835_gpio_irq_config(pc, offset, false);\r\npc->irq_type[offset] = type;\r\n}\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nif (pc->irq_type[offset] == IRQ_TYPE_EDGE_BOTH) {\r\npc->irq_type[offset] = IRQ_TYPE_EDGE_FALLING;\r\nbcm2835_gpio_irq_config(pc, offset, false);\r\npc->irq_type[offset] = type;\r\n} else if (pc->irq_type[offset] != type) {\r\nbcm2835_gpio_irq_config(pc, offset, false);\r\npc->irq_type[offset] = type;\r\nbcm2835_gpio_irq_config(pc, offset, true);\r\n}\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nif (pc->irq_type[offset] == IRQ_TYPE_EDGE_BOTH) {\r\npc->irq_type[offset] = IRQ_TYPE_EDGE_RISING;\r\nbcm2835_gpio_irq_config(pc, offset, false);\r\npc->irq_type[offset] = type;\r\n} else if (pc->irq_type[offset] != type) {\r\nbcm2835_gpio_irq_config(pc, offset, false);\r\npc->irq_type[offset] = type;\r\nbcm2835_gpio_irq_config(pc, offset, true);\r\n}\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nif (pc->irq_type[offset] == IRQ_TYPE_EDGE_RISING) {\r\npc->irq_type[offset] = IRQ_TYPE_EDGE_FALLING;\r\nbcm2835_gpio_irq_config(pc, offset, true);\r\npc->irq_type[offset] = type;\r\n} else if (pc->irq_type[offset] == IRQ_TYPE_EDGE_FALLING) {\r\npc->irq_type[offset] = IRQ_TYPE_EDGE_RISING;\r\nbcm2835_gpio_irq_config(pc, offset, true);\r\npc->irq_type[offset] = type;\r\n} else if (pc->irq_type[offset] != type) {\r\nbcm2835_gpio_irq_config(pc, offset, false);\r\npc->irq_type[offset] = type;\r\nbcm2835_gpio_irq_config(pc, offset, true);\r\n}\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nif (pc->irq_type[offset] != type) {\r\nbcm2835_gpio_irq_config(pc, offset, false);\r\npc->irq_type[offset] = type;\r\nbcm2835_gpio_irq_config(pc, offset, true);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm2835_gpio_irq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nstruct bcm2835_pinctrl *pc = irq_data_get_irq_chip_data(data);\r\nunsigned gpio = irqd_to_hwirq(data);\r\nunsigned offset = GPIO_REG_SHIFT(gpio);\r\nunsigned bank = GPIO_REG_OFFSET(gpio);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&pc->irq_lock[bank], flags);\r\nif (test_bit(offset, &pc->enabled_irq_map[bank]))\r\nret = __bcm2835_gpio_irq_set_type_enabled(pc, gpio, type);\r\nelse\r\nret = __bcm2835_gpio_irq_set_type_disabled(pc, gpio, type);\r\nspin_unlock_irqrestore(&pc->irq_lock[bank], flags);\r\nreturn ret;\r\n}\r\nstatic int bcm2835_pctl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(bcm2835_gpio_groups);\r\n}\r\nstatic const char *bcm2835_pctl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn bcm2835_gpio_groups[selector];\r\n}\r\nstatic int bcm2835_pctl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\n*pins = &bcm2835_gpio_pins[selector].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic void bcm2835_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned offset)\r\n{\r\nstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\r\nenum bcm2835_fsel fsel = bcm2835_pinctrl_fsel_get(pc, offset);\r\nconst char *fname = bcm2835_functions[fsel];\r\nint value = bcm2835_gpio_get_bit(pc, GPLEV0, offset);\r\nint irq = irq_find_mapping(pc->irq_domain, offset);\r\nseq_printf(s, "function %s in %s; irq %d (%s)",\r\nfname, value ? "hi" : "lo",\r\nirq, irq_type_names[pc->irq_type[offset]]);\r\n}\r\nstatic void bcm2835_pctl_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *maps, unsigned num_maps)\r\n{\r\nint i;\r\nfor (i = 0; i < num_maps; i++)\r\nif (maps[i].type == PIN_MAP_TYPE_CONFIGS_PIN)\r\nkfree(maps[i].data.configs.configs);\r\nkfree(maps);\r\n}\r\nstatic int bcm2835_pctl_dt_node_to_map_func(struct bcm2835_pinctrl *pc,\r\nstruct device_node *np, u32 pin, u32 fnum,\r\nstruct pinctrl_map **maps)\r\n{\r\nstruct pinctrl_map *map = *maps;\r\nif (fnum >= ARRAY_SIZE(bcm2835_functions)) {\r\ndev_err(pc->dev, "%s: invalid brcm,function %d\n",\r\nof_node_full_name(np), fnum);\r\nreturn -EINVAL;\r\n}\r\nmap->type = PIN_MAP_TYPE_MUX_GROUP;\r\nmap->data.mux.group = bcm2835_gpio_groups[pin];\r\nmap->data.mux.function = bcm2835_functions[fnum];\r\n(*maps)++;\r\nreturn 0;\r\n}\r\nstatic int bcm2835_pctl_dt_node_to_map_pull(struct bcm2835_pinctrl *pc,\r\nstruct device_node *np, u32 pin, u32 pull,\r\nstruct pinctrl_map **maps)\r\n{\r\nstruct pinctrl_map *map = *maps;\r\nunsigned long *configs;\r\nif (pull > 2) {\r\ndev_err(pc->dev, "%s: invalid brcm,pull %d\n",\r\nof_node_full_name(np), pull);\r\nreturn -EINVAL;\r\n}\r\nconfigs = kzalloc(sizeof(*configs), GFP_KERNEL);\r\nif (!configs)\r\nreturn -ENOMEM;\r\nconfigs[0] = BCM2835_PINCONF_PACK(BCM2835_PINCONF_PARAM_PULL, pull);\r\nmap->type = PIN_MAP_TYPE_CONFIGS_PIN;\r\nmap->data.configs.group_or_pin = bcm2835_gpio_pins[pin].name;\r\nmap->data.configs.configs = configs;\r\nmap->data.configs.num_configs = 1;\r\n(*maps)++;\r\nreturn 0;\r\n}\r\nstatic int bcm2835_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\r\nstruct property *pins, *funcs, *pulls;\r\nint num_pins, num_funcs, num_pulls, maps_per_pin;\r\nstruct pinctrl_map *maps, *cur_map;\r\nint i, err;\r\nu32 pin, func, pull;\r\npins = of_find_property(np, "brcm,pins", NULL);\r\nif (!pins) {\r\ndev_err(pc->dev, "%s: missing brcm,pins property\n",\r\nof_node_full_name(np));\r\nreturn -EINVAL;\r\n}\r\nfuncs = of_find_property(np, "brcm,function", NULL);\r\npulls = of_find_property(np, "brcm,pull", NULL);\r\nif (!funcs && !pulls) {\r\ndev_err(pc->dev,\r\n"%s: neither brcm,function nor brcm,pull specified\n",\r\nof_node_full_name(np));\r\nreturn -EINVAL;\r\n}\r\nnum_pins = pins->length / 4;\r\nnum_funcs = funcs ? (funcs->length / 4) : 0;\r\nnum_pulls = pulls ? (pulls->length / 4) : 0;\r\nif (num_funcs > 1 && num_funcs != num_pins) {\r\ndev_err(pc->dev,\r\n"%s: brcm,function must have 1 or %d entries\n",\r\nof_node_full_name(np), num_pins);\r\nreturn -EINVAL;\r\n}\r\nif (num_pulls > 1 && num_pulls != num_pins) {\r\ndev_err(pc->dev,\r\n"%s: brcm,pull must have 1 or %d entries\n",\r\nof_node_full_name(np), num_pins);\r\nreturn -EINVAL;\r\n}\r\nmaps_per_pin = 0;\r\nif (num_funcs)\r\nmaps_per_pin++;\r\nif (num_pulls)\r\nmaps_per_pin++;\r\ncur_map = maps = kzalloc(num_pins * maps_per_pin * sizeof(*maps),\r\nGFP_KERNEL);\r\nif (!maps)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_pins; i++) {\r\nerr = of_property_read_u32_index(np, "brcm,pins", i, &pin);\r\nif (err)\r\ngoto out;\r\nif (pin >= ARRAY_SIZE(bcm2835_gpio_pins)) {\r\ndev_err(pc->dev, "%s: invalid brcm,pins value %d\n",\r\nof_node_full_name(np), pin);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (num_funcs) {\r\nerr = of_property_read_u32_index(np, "brcm,function",\r\n(num_funcs > 1) ? i : 0, &func);\r\nif (err)\r\ngoto out;\r\nerr = bcm2835_pctl_dt_node_to_map_func(pc, np, pin,\r\nfunc, &cur_map);\r\nif (err)\r\ngoto out;\r\n}\r\nif (num_pulls) {\r\nerr = of_property_read_u32_index(np, "brcm,pull",\r\n(num_funcs > 1) ? i : 0, &pull);\r\nif (err)\r\ngoto out;\r\nerr = bcm2835_pctl_dt_node_to_map_pull(pc, np, pin,\r\npull, &cur_map);\r\nif (err)\r\ngoto out;\r\n}\r\n}\r\n*map = maps;\r\n*num_maps = num_pins * maps_per_pin;\r\nreturn 0;\r\nout:\r\nkfree(maps);\r\nreturn err;\r\n}\r\nstatic int bcm2835_pmx_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn BCM2835_FSEL_COUNT;\r\n}\r\nstatic const char *bcm2835_pmx_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn bcm2835_functions[selector];\r\n}\r\nstatic int bcm2835_pmx_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\n*groups = bcm2835_gpio_groups;\r\n*num_groups = ARRAY_SIZE(bcm2835_gpio_groups);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_pmx_enable(struct pinctrl_dev *pctldev,\r\nunsigned func_selector,\r\nunsigned group_selector)\r\n{\r\nstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\r\nbcm2835_pinctrl_fsel_set(pc, group_selector, func_selector);\r\nreturn 0;\r\n}\r\nstatic void bcm2835_pmx_disable(struct pinctrl_dev *pctldev,\r\nunsigned func_selector,\r\nunsigned group_selector)\r\n{\r\nstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\r\nbcm2835_pinctrl_fsel_set(pc, group_selector, BCM2835_FSEL_GPIO_IN);\r\n}\r\nstatic void bcm2835_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\r\nbcm2835_pinctrl_fsel_set(pc, offset, BCM2835_FSEL_GPIO_IN);\r\n}\r\nstatic int bcm2835_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset,\r\nbool input)\r\n{\r\nstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\r\nenum bcm2835_fsel fsel = input ?\r\nBCM2835_FSEL_GPIO_IN : BCM2835_FSEL_GPIO_OUT;\r\nbcm2835_pinctrl_fsel_set(pc, offset, fsel);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *config)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int bcm2835_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\r\nenum bcm2835_pinconf_param param;\r\nu16 arg;\r\nu32 off, bit;\r\nint i;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = BCM2835_PINCONF_UNPACK_PARAM(configs[i]);\r\narg = BCM2835_PINCONF_UNPACK_ARG(configs[i]);\r\nif (param != BCM2835_PINCONF_PARAM_PULL)\r\nreturn -EINVAL;\r\noff = GPIO_REG_OFFSET(pin);\r\nbit = GPIO_REG_SHIFT(pin);\r\nbcm2835_gpio_wr(pc, GPPUD, arg & 3);\r\nudelay(150);\r\nbcm2835_gpio_wr(pc, GPPUDCLK0 + (off * 4), BIT(bit));\r\nudelay(150);\r\nbcm2835_gpio_wr(pc, GPPUDCLK0 + (off * 4), 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm2835_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct bcm2835_pinctrl *pc;\r\nstruct resource iomem;\r\nint err, i;\r\nBUILD_BUG_ON(ARRAY_SIZE(bcm2835_gpio_pins) != BCM2835_NUM_GPIOS);\r\nBUILD_BUG_ON(ARRAY_SIZE(bcm2835_gpio_groups) != BCM2835_NUM_GPIOS);\r\npc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);\r\nif (!pc)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, pc);\r\npc->dev = dev;\r\nerr = of_address_to_resource(np, 0, &iomem);\r\nif (err) {\r\ndev_err(dev, "could not get IO memory\n");\r\nreturn err;\r\n}\r\npc->base = devm_ioremap_resource(dev, &iomem);\r\nif (IS_ERR(pc->base))\r\nreturn PTR_ERR(pc->base);\r\npc->gpio_chip = bcm2835_gpio_chip;\r\npc->gpio_chip.dev = dev;\r\npc->gpio_chip.of_node = np;\r\npc->irq_domain = irq_domain_add_linear(np, BCM2835_NUM_GPIOS,\r\n&irq_domain_simple_ops, NULL);\r\nif (!pc->irq_domain) {\r\ndev_err(dev, "could not create IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < BCM2835_NUM_GPIOS; i++) {\r\nint irq = irq_create_mapping(pc->irq_domain, i);\r\nirq_set_lockdep_class(irq, &gpio_lock_class);\r\nirq_set_chip_and_handler(irq, &bcm2835_gpio_irq_chip,\r\nhandle_simple_irq);\r\nirq_set_chip_data(irq, pc);\r\nset_irq_flags(irq, IRQF_VALID);\r\n}\r\nfor (i = 0; i < BCM2835_NUM_BANKS; i++) {\r\nunsigned long events;\r\nunsigned offset;\r\nint len;\r\nchar *name;\r\nbcm2835_gpio_wr(pc, GPREN0 + i * 4, 0);\r\nbcm2835_gpio_wr(pc, GPFEN0 + i * 4, 0);\r\nbcm2835_gpio_wr(pc, GPHEN0 + i * 4, 0);\r\nbcm2835_gpio_wr(pc, GPLEN0 + i * 4, 0);\r\nbcm2835_gpio_wr(pc, GPAREN0 + i * 4, 0);\r\nbcm2835_gpio_wr(pc, GPAFEN0 + i * 4, 0);\r\nevents = bcm2835_gpio_rd(pc, GPEDS0 + i * 4);\r\nfor_each_set_bit(offset, &events, 32)\r\nbcm2835_gpio_wr(pc, GPEDS0 + i * 4, BIT(offset));\r\npc->irq[i] = irq_of_parse_and_map(np, i);\r\npc->irq_data[i].pc = pc;\r\npc->irq_data[i].bank = i;\r\nspin_lock_init(&pc->irq_lock[i]);\r\nlen = strlen(dev_name(pc->dev)) + 16;\r\nname = devm_kzalloc(pc->dev, len, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nsnprintf(name, len, "%s:bank%d", dev_name(pc->dev), i);\r\nerr = devm_request_irq(dev, pc->irq[i],\r\nbcm2835_gpio_irq_handler, IRQF_SHARED,\r\nname, &pc->irq_data[i]);\r\nif (err) {\r\ndev_err(dev, "unable to request IRQ %d\n", pc->irq[i]);\r\nreturn err;\r\n}\r\n}\r\nerr = gpiochip_add(&pc->gpio_chip);\r\nif (err) {\r\ndev_err(dev, "could not add GPIO chip\n");\r\nreturn err;\r\n}\r\npc->pctl_dev = pinctrl_register(&bcm2835_pinctrl_desc, dev, pc);\r\nif (!pc->pctl_dev) {\r\ngpiochip_remove(&pc->gpio_chip);\r\nreturn -EINVAL;\r\n}\r\npc->gpio_range = bcm2835_pinctrl_gpio_range;\r\npc->gpio_range.base = pc->gpio_chip.base;\r\npc->gpio_range.gc = &pc->gpio_chip;\r\npinctrl_add_gpio_range(pc->pctl_dev, &pc->gpio_range);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm2835_pinctrl *pc = platform_get_drvdata(pdev);\r\npinctrl_unregister(pc->pctl_dev);\r\ngpiochip_remove(&pc->gpio_chip);\r\nreturn 0;\r\n}
