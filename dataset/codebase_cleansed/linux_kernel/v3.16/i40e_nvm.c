i40e_status i40e_init_nvm(struct i40e_hw *hw)\r\n{\r\nstruct i40e_nvm_info *nvm = &hw->nvm;\r\ni40e_status ret_code = 0;\r\nu32 fla, gens;\r\nu8 sr_size;\r\ngens = rd32(hw, I40E_GLNVM_GENS);\r\nsr_size = ((gens & I40E_GLNVM_GENS_SR_SIZE_MASK) >>\r\nI40E_GLNVM_GENS_SR_SIZE_SHIFT);\r\nnvm->sr_size = (1 << sr_size) * I40E_SR_WORDS_IN_1KB;\r\nfla = rd32(hw, I40E_GLNVM_FLA);\r\nif (fla & I40E_GLNVM_FLA_LOCKED_MASK) {\r\nnvm->timeout = I40E_MAX_NVM_TIMEOUT;\r\nnvm->blank_nvm_mode = false;\r\n} else {\r\nnvm->blank_nvm_mode = true;\r\nret_code = I40E_ERR_NVM_BLANK_MODE;\r\nhw_dbg(hw, "NVM init error: unsupported blank mode.\n");\r\n}\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_acquire_nvm(struct i40e_hw *hw,\r\nenum i40e_aq_resource_access_type access)\r\n{\r\ni40e_status ret_code = 0;\r\nu64 gtime, timeout;\r\nu64 time = 0;\r\nif (hw->nvm.blank_nvm_mode)\r\ngoto i40e_i40e_acquire_nvm_exit;\r\nret_code = i40e_aq_request_resource(hw, I40E_NVM_RESOURCE_ID, access,\r\n0, &time, NULL);\r\ngtime = rd32(hw, I40E_GLVFGEN_TIMER);\r\nhw->nvm.hw_semaphore_timeout = I40E_MS_TO_GTIME(time) + gtime;\r\nif (ret_code) {\r\nif (time > I40E_MAX_NVM_TIMEOUT)\r\ntimeout = I40E_MS_TO_GTIME(I40E_MAX_NVM_TIMEOUT)\r\n+ gtime;\r\nelse\r\ntimeout = hw->nvm.hw_semaphore_timeout;\r\nwhile (gtime < timeout) {\r\nusleep_range(10000, 20000);\r\nret_code = i40e_aq_request_resource(hw,\r\nI40E_NVM_RESOURCE_ID,\r\naccess, 0, &time,\r\nNULL);\r\nif (!ret_code) {\r\nhw->nvm.hw_semaphore_timeout =\r\nI40E_MS_TO_GTIME(time) + gtime;\r\nbreak;\r\n}\r\ngtime = rd32(hw, I40E_GLVFGEN_TIMER);\r\n}\r\nif (ret_code) {\r\nhw->nvm.hw_semaphore_timeout = 0;\r\nhw->nvm.hw_semaphore_wait =\r\nI40E_MS_TO_GTIME(time) + gtime;\r\nhw_dbg(hw, "NVM acquire timed out, wait %llu ms before trying again.\n",\r\ntime);\r\n}\r\n}\r\ni40e_i40e_acquire_nvm_exit:\r\nreturn ret_code;\r\n}\r\nvoid i40e_release_nvm(struct i40e_hw *hw)\r\n{\r\nif (!hw->nvm.blank_nvm_mode)\r\ni40e_aq_release_resource(hw, I40E_NVM_RESOURCE_ID, 0, NULL);\r\n}\r\nstatic i40e_status i40e_poll_sr_srctl_done_bit(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = I40E_ERR_TIMEOUT;\r\nu32 srctl, wait_cnt;\r\nfor (wait_cnt = 0; wait_cnt < I40E_SRRD_SRCTL_ATTEMPTS; wait_cnt++) {\r\nsrctl = rd32(hw, I40E_GLNVM_SRCTL);\r\nif (srctl & I40E_GLNVM_SRCTL_DONE_MASK) {\r\nret_code = 0;\r\nbreak;\r\n}\r\nudelay(5);\r\n}\r\nif (ret_code == I40E_ERR_TIMEOUT)\r\nhw_dbg(hw, "Done bit in GLNVM_SRCTL not set\n");\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_read_nvm_word(struct i40e_hw *hw, u16 offset,\r\nu16 *data)\r\n{\r\ni40e_status ret_code = I40E_ERR_TIMEOUT;\r\nu32 sr_reg;\r\nif (offset >= hw->nvm.sr_size) {\r\nhw_dbg(hw, "NVM read error: Offset beyond Shadow RAM limit.\n");\r\nret_code = I40E_ERR_PARAM;\r\ngoto read_nvm_exit;\r\n}\r\nret_code = i40e_poll_sr_srctl_done_bit(hw);\r\nif (!ret_code) {\r\nsr_reg = (u32)(offset << I40E_GLNVM_SRCTL_ADDR_SHIFT) |\r\n(1 << I40E_GLNVM_SRCTL_START_SHIFT);\r\nwr32(hw, I40E_GLNVM_SRCTL, sr_reg);\r\nret_code = i40e_poll_sr_srctl_done_bit(hw);\r\nif (!ret_code) {\r\nsr_reg = rd32(hw, I40E_GLNVM_SRDATA);\r\n*data = (u16)((sr_reg &\r\nI40E_GLNVM_SRDATA_RDDATA_MASK)\r\n>> I40E_GLNVM_SRDATA_RDDATA_SHIFT);\r\n}\r\n}\r\nif (ret_code)\r\nhw_dbg(hw, "NVM read error: Couldn't access Shadow RAM address: 0x%x\n",\r\noffset);\r\nread_nvm_exit:\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_read_nvm_buffer(struct i40e_hw *hw, u16 offset,\r\nu16 *words, u16 *data)\r\n{\r\ni40e_status ret_code = 0;\r\nu16 index, word;\r\nfor (word = 0; word < *words; word++) {\r\nindex = offset + word;\r\nret_code = i40e_read_nvm_word(hw, index, &data[word]);\r\nif (ret_code)\r\nbreak;\r\n}\r\n*words = word;\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_calc_nvm_checksum(struct i40e_hw *hw,\r\nu16 *checksum)\r\n{\r\ni40e_status ret_code = 0;\r\nu16 pcie_alt_module = 0;\r\nu16 checksum_local = 0;\r\nu16 vpd_module = 0;\r\nu16 word = 0;\r\nu32 i = 0;\r\nret_code = i40e_read_nvm_word(hw, I40E_SR_VPD_PTR, &vpd_module);\r\nif (ret_code) {\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\ngoto i40e_calc_nvm_checksum_exit;\r\n}\r\nret_code = i40e_read_nvm_word(hw, I40E_SR_PCIE_ALT_AUTO_LOAD_PTR,\r\n&pcie_alt_module);\r\nif (ret_code) {\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\ngoto i40e_calc_nvm_checksum_exit;\r\n}\r\nfor (i = 0; i < hw->nvm.sr_size; i++) {\r\nif (i == I40E_SR_SW_CHECKSUM_WORD)\r\ni++;\r\nif (i == (u32)vpd_module) {\r\ni += (I40E_SR_VPD_MODULE_MAX_SIZE / 2);\r\nif (i >= hw->nvm.sr_size)\r\nbreak;\r\n}\r\nif (i == (u32)pcie_alt_module) {\r\ni += (I40E_SR_PCIE_ALT_MODULE_MAX_SIZE / 2);\r\nif (i >= hw->nvm.sr_size)\r\nbreak;\r\n}\r\nret_code = i40e_read_nvm_word(hw, (u16)i, &word);\r\nif (ret_code) {\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\ngoto i40e_calc_nvm_checksum_exit;\r\n}\r\nchecksum_local += word;\r\n}\r\n*checksum = (u16)I40E_SR_SW_CHECKSUM_BASE - checksum_local;\r\ni40e_calc_nvm_checksum_exit:\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_validate_nvm_checksum(struct i40e_hw *hw,\r\nu16 *checksum)\r\n{\r\ni40e_status ret_code = 0;\r\nu16 checksum_sr = 0;\r\nu16 checksum_local = 0;\r\nret_code = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\r\nif (ret_code)\r\ngoto i40e_validate_nvm_checksum_exit;\r\nret_code = i40e_calc_nvm_checksum(hw, &checksum_local);\r\nif (ret_code)\r\ngoto i40e_validate_nvm_checksum_free;\r\ni40e_read_nvm_word(hw, I40E_SR_SW_CHECKSUM_WORD, &checksum_sr);\r\nif (checksum_local != checksum_sr)\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\nif (checksum)\r\n*checksum = checksum_local;\r\ni40e_validate_nvm_checksum_free:\r\ni40e_release_nvm(hw);\r\ni40e_validate_nvm_checksum_exit:\r\nreturn ret_code;\r\n}
