struct mtd_info *__mtd_next_device(int i)\r\n{\r\nreturn idr_get_next(&mtd_idr, &i);\r\n}\r\nstatic void mtd_release(struct device *dev)\r\n{\r\nstruct mtd_info __maybe_unused *mtd = dev_get_drvdata(dev);\r\ndev_t index = MTD_DEVT(mtd->index);\r\nif (index)\r\ndevice_destroy(&mtd_class, index + 1);\r\n}\r\nstatic int mtd_cls_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn mtd ? mtd_suspend(mtd) : 0;\r\n}\r\nstatic int mtd_cls_resume(struct device *dev)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nif (mtd)\r\nmtd_resume(mtd);\r\nreturn 0;\r\n}\r\nstatic ssize_t mtd_type_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nchar *type;\r\nswitch (mtd->type) {\r\ncase MTD_ABSENT:\r\ntype = "absent";\r\nbreak;\r\ncase MTD_RAM:\r\ntype = "ram";\r\nbreak;\r\ncase MTD_ROM:\r\ntype = "rom";\r\nbreak;\r\ncase MTD_NORFLASH:\r\ntype = "nor";\r\nbreak;\r\ncase MTD_NANDFLASH:\r\ntype = "nand";\r\nbreak;\r\ncase MTD_DATAFLASH:\r\ntype = "dataflash";\r\nbreak;\r\ncase MTD_UBIVOLUME:\r\ntype = "ubi";\r\nbreak;\r\ncase MTD_MLCNANDFLASH:\r\ntype = "mlc-nand";\r\nbreak;\r\ndefault:\r\ntype = "unknown";\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", type);\r\n}\r\nstatic ssize_t mtd_flags_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%lx\n", (unsigned long)mtd->flags);\r\n}\r\nstatic ssize_t mtd_size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%llu\n",\r\n(unsigned long long)mtd->size);\r\n}\r\nstatic ssize_t mtd_erasesize_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->erasesize);\r\n}\r\nstatic ssize_t mtd_writesize_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->writesize);\r\n}\r\nstatic ssize_t mtd_subpagesize_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nunsigned int subpagesize = mtd->writesize >> mtd->subpage_sft;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", subpagesize);\r\n}\r\nstatic ssize_t mtd_oobsize_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->oobsize);\r\n}\r\nstatic ssize_t mtd_numeraseregions_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", mtd->numeraseregions);\r\n}\r\nstatic ssize_t mtd_name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", mtd->name);\r\n}\r\nstatic ssize_t mtd_ecc_strength_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", mtd->ecc_strength);\r\n}\r\nstatic ssize_t mtd_bitflip_threshold_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", mtd->bitflip_threshold);\r\n}\r\nstatic ssize_t mtd_bitflip_threshold_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nunsigned int bitflip_threshold;\r\nint retval;\r\nretval = kstrtouint(buf, 0, &bitflip_threshold);\r\nif (retval)\r\nreturn retval;\r\nmtd->bitflip_threshold = bitflip_threshold;\r\nreturn count;\r\n}\r\nstatic ssize_t mtd_ecc_step_size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", mtd->ecc_step_size);\r\n}\r\nint add_mtd_device(struct mtd_info *mtd)\r\n{\r\nstruct mtd_notifier *not;\r\nint i, error;\r\nif (!mtd->backing_dev_info) {\r\nswitch (mtd->type) {\r\ncase MTD_RAM:\r\nmtd->backing_dev_info = &mtd_bdi_rw_mappable;\r\nbreak;\r\ncase MTD_ROM:\r\nmtd->backing_dev_info = &mtd_bdi_ro_mappable;\r\nbreak;\r\ndefault:\r\nmtd->backing_dev_info = &mtd_bdi_unmappable;\r\nbreak;\r\n}\r\n}\r\nBUG_ON(mtd->writesize == 0);\r\nmutex_lock(&mtd_table_mutex);\r\ni = idr_alloc(&mtd_idr, mtd, 0, 0, GFP_KERNEL);\r\nif (i < 0)\r\ngoto fail_locked;\r\nmtd->index = i;\r\nmtd->usecount = 0;\r\nif (mtd->bitflip_threshold == 0)\r\nmtd->bitflip_threshold = mtd->ecc_strength;\r\nif (is_power_of_2(mtd->erasesize))\r\nmtd->erasesize_shift = ffs(mtd->erasesize) - 1;\r\nelse\r\nmtd->erasesize_shift = 0;\r\nif (is_power_of_2(mtd->writesize))\r\nmtd->writesize_shift = ffs(mtd->writesize) - 1;\r\nelse\r\nmtd->writesize_shift = 0;\r\nmtd->erasesize_mask = (1 << mtd->erasesize_shift) - 1;\r\nmtd->writesize_mask = (1 << mtd->writesize_shift) - 1;\r\nif ((mtd->flags & MTD_WRITEABLE) && (mtd->flags & MTD_POWERUP_LOCK)) {\r\nerror = mtd_unlock(mtd, 0, mtd->size);\r\nif (error && error != -EOPNOTSUPP)\r\nprintk(KERN_WARNING\r\n"%s: unlock failed, writes may not work\n",\r\nmtd->name);\r\n}\r\nmtd->dev.type = &mtd_devtype;\r\nmtd->dev.class = &mtd_class;\r\nmtd->dev.devt = MTD_DEVT(i);\r\ndev_set_name(&mtd->dev, "mtd%d", i);\r\ndev_set_drvdata(&mtd->dev, mtd);\r\nif (device_register(&mtd->dev) != 0)\r\ngoto fail_added;\r\nif (MTD_DEVT(i))\r\ndevice_create(&mtd_class, mtd->dev.parent,\r\nMTD_DEVT(i) + 1,\r\nNULL, "mtd%dro", i);\r\npr_debug("mtd: Giving out device %d to %s\n", i, mtd->name);\r\nlist_for_each_entry(not, &mtd_notifiers, list)\r\nnot->add(mtd);\r\nmutex_unlock(&mtd_table_mutex);\r\n__module_get(THIS_MODULE);\r\nreturn 0;\r\nfail_added:\r\nidr_remove(&mtd_idr, i);\r\nfail_locked:\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn 1;\r\n}\r\nint del_mtd_device(struct mtd_info *mtd)\r\n{\r\nint ret;\r\nstruct mtd_notifier *not;\r\nmutex_lock(&mtd_table_mutex);\r\nif (idr_find(&mtd_idr, mtd->index) != mtd) {\r\nret = -ENODEV;\r\ngoto out_error;\r\n}\r\nlist_for_each_entry(not, &mtd_notifiers, list)\r\nnot->remove(mtd);\r\nif (mtd->usecount) {\r\nprintk(KERN_NOTICE "Removing MTD device #%d (%s) with use count %d\n",\r\nmtd->index, mtd->name, mtd->usecount);\r\nret = -EBUSY;\r\n} else {\r\ndevice_unregister(&mtd->dev);\r\nidr_remove(&mtd_idr, mtd->index);\r\nmodule_put(THIS_MODULE);\r\nret = 0;\r\n}\r\nout_error:\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn ret;\r\n}\r\nint mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,\r\nstruct mtd_part_parser_data *parser_data,\r\nconst struct mtd_partition *parts,\r\nint nr_parts)\r\n{\r\nint err;\r\nstruct mtd_partition *real_parts;\r\nerr = parse_mtd_partitions(mtd, types, &real_parts, parser_data);\r\nif (err <= 0 && nr_parts && parts) {\r\nreal_parts = kmemdup(parts, sizeof(*parts) * nr_parts,\r\nGFP_KERNEL);\r\nif (!real_parts)\r\nerr = -ENOMEM;\r\nelse\r\nerr = nr_parts;\r\n}\r\nif (err > 0) {\r\nerr = add_mtd_partitions(mtd, real_parts, err);\r\nkfree(real_parts);\r\n} else if (err == 0) {\r\nerr = add_mtd_device(mtd);\r\nif (err == 1)\r\nerr = -ENODEV;\r\n}\r\nreturn err;\r\n}\r\nint mtd_device_unregister(struct mtd_info *master)\r\n{\r\nint err;\r\nerr = del_mtd_partitions(master);\r\nif (err)\r\nreturn err;\r\nif (!device_is_registered(&master->dev))\r\nreturn 0;\r\nreturn del_mtd_device(master);\r\n}\r\nvoid register_mtd_user (struct mtd_notifier *new)\r\n{\r\nstruct mtd_info *mtd;\r\nmutex_lock(&mtd_table_mutex);\r\nlist_add(&new->list, &mtd_notifiers);\r\n__module_get(THIS_MODULE);\r\nmtd_for_each_device(mtd)\r\nnew->add(mtd);\r\nmutex_unlock(&mtd_table_mutex);\r\n}\r\nint unregister_mtd_user (struct mtd_notifier *old)\r\n{\r\nstruct mtd_info *mtd;\r\nmutex_lock(&mtd_table_mutex);\r\nmodule_put(THIS_MODULE);\r\nmtd_for_each_device(mtd)\r\nold->remove(mtd);\r\nlist_del(&old->list);\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn 0;\r\n}\r\nstruct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)\r\n{\r\nstruct mtd_info *ret = NULL, *other;\r\nint err = -ENODEV;\r\nmutex_lock(&mtd_table_mutex);\r\nif (num == -1) {\r\nmtd_for_each_device(other) {\r\nif (other == mtd) {\r\nret = mtd;\r\nbreak;\r\n}\r\n}\r\n} else if (num >= 0) {\r\nret = idr_find(&mtd_idr, num);\r\nif (mtd && mtd != ret)\r\nret = NULL;\r\n}\r\nif (!ret) {\r\nret = ERR_PTR(err);\r\ngoto out;\r\n}\r\nerr = __get_mtd_device(ret);\r\nif (err)\r\nret = ERR_PTR(err);\r\nout:\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn ret;\r\n}\r\nint __get_mtd_device(struct mtd_info *mtd)\r\n{\r\nint err;\r\nif (!try_module_get(mtd->owner))\r\nreturn -ENODEV;\r\nif (mtd->_get_device) {\r\nerr = mtd->_get_device(mtd);\r\nif (err) {\r\nmodule_put(mtd->owner);\r\nreturn err;\r\n}\r\n}\r\nmtd->usecount++;\r\nreturn 0;\r\n}\r\nstruct mtd_info *get_mtd_device_nm(const char *name)\r\n{\r\nint err = -ENODEV;\r\nstruct mtd_info *mtd = NULL, *other;\r\nmutex_lock(&mtd_table_mutex);\r\nmtd_for_each_device(other) {\r\nif (!strcmp(name, other->name)) {\r\nmtd = other;\r\nbreak;\r\n}\r\n}\r\nif (!mtd)\r\ngoto out_unlock;\r\nerr = __get_mtd_device(mtd);\r\nif (err)\r\ngoto out_unlock;\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn mtd;\r\nout_unlock:\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid put_mtd_device(struct mtd_info *mtd)\r\n{\r\nmutex_lock(&mtd_table_mutex);\r\n__put_mtd_device(mtd);\r\nmutex_unlock(&mtd_table_mutex);\r\n}\r\nvoid __put_mtd_device(struct mtd_info *mtd)\r\n{\r\n--mtd->usecount;\r\nBUG_ON(mtd->usecount < 0);\r\nif (mtd->_put_device)\r\nmtd->_put_device(mtd);\r\nmodule_put(mtd->owner);\r\n}\r\nint mtd_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nif (instr->addr > mtd->size || instr->len > mtd->size - instr->addr)\r\nreturn -EINVAL;\r\nif (!(mtd->flags & MTD_WRITEABLE))\r\nreturn -EROFS;\r\ninstr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;\r\nif (!instr->len) {\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nreturn mtd->_erase(mtd, instr);\r\n}\r\nint mtd_point(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,\r\nvoid **virt, resource_size_t *phys)\r\n{\r\n*retlen = 0;\r\n*virt = NULL;\r\nif (phys)\r\n*phys = 0;\r\nif (!mtd->_point)\r\nreturn -EOPNOTSUPP;\r\nif (from < 0 || from > mtd->size || len > mtd->size - from)\r\nreturn -EINVAL;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_point(mtd, from, len, retlen, virt, phys);\r\n}\r\nint mtd_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\r\n{\r\nif (!mtd->_point)\r\nreturn -EOPNOTSUPP;\r\nif (from < 0 || from > mtd->size || len > mtd->size - from)\r\nreturn -EINVAL;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_unpoint(mtd, from, len);\r\n}\r\nunsigned long mtd_get_unmapped_area(struct mtd_info *mtd, unsigned long len,\r\nunsigned long offset, unsigned long flags)\r\n{\r\nif (!mtd->_get_unmapped_area)\r\nreturn -EOPNOTSUPP;\r\nif (offset > mtd->size || len > mtd->size - offset)\r\nreturn -EINVAL;\r\nreturn mtd->_get_unmapped_area(mtd, len, offset, flags);\r\n}\r\nint mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,\r\nu_char *buf)\r\n{\r\nint ret_code;\r\n*retlen = 0;\r\nif (from < 0 || from > mtd->size || len > mtd->size - from)\r\nreturn -EINVAL;\r\nif (!len)\r\nreturn 0;\r\nret_code = mtd->_read(mtd, from, len, retlen, buf);\r\nif (unlikely(ret_code < 0))\r\nreturn ret_code;\r\nif (mtd->ecc_strength == 0)\r\nreturn 0;\r\nreturn ret_code >= mtd->bitflip_threshold ? -EUCLEAN : 0;\r\n}\r\nint mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,\r\nconst u_char *buf)\r\n{\r\n*retlen = 0;\r\nif (to < 0 || to > mtd->size || len > mtd->size - to)\r\nreturn -EINVAL;\r\nif (!mtd->_write || !(mtd->flags & MTD_WRITEABLE))\r\nreturn -EROFS;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_write(mtd, to, len, retlen, buf);\r\n}\r\nint mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,\r\nconst u_char *buf)\r\n{\r\n*retlen = 0;\r\nif (!mtd->_panic_write)\r\nreturn -EOPNOTSUPP;\r\nif (to < 0 || to > mtd->size || len > mtd->size - to)\r\nreturn -EINVAL;\r\nif (!(mtd->flags & MTD_WRITEABLE))\r\nreturn -EROFS;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_panic_write(mtd, to, len, retlen, buf);\r\n}\r\nint mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)\r\n{\r\nint ret_code;\r\nops->retlen = ops->oobretlen = 0;\r\nif (!mtd->_read_oob)\r\nreturn -EOPNOTSUPP;\r\nret_code = mtd->_read_oob(mtd, from, ops);\r\nif (unlikely(ret_code < 0))\r\nreturn ret_code;\r\nif (mtd->ecc_strength == 0)\r\nreturn 0;\r\nreturn ret_code >= mtd->bitflip_threshold ? -EUCLEAN : 0;\r\n}\r\nint mtd_get_fact_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,\r\nstruct otp_info *buf)\r\n{\r\nif (!mtd->_get_fact_prot_info)\r\nreturn -EOPNOTSUPP;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_get_fact_prot_info(mtd, len, retlen, buf);\r\n}\r\nint mtd_read_fact_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\n*retlen = 0;\r\nif (!mtd->_read_fact_prot_reg)\r\nreturn -EOPNOTSUPP;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_read_fact_prot_reg(mtd, from, len, retlen, buf);\r\n}\r\nint mtd_get_user_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,\r\nstruct otp_info *buf)\r\n{\r\nif (!mtd->_get_user_prot_info)\r\nreturn -EOPNOTSUPP;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_get_user_prot_info(mtd, len, retlen, buf);\r\n}\r\nint mtd_read_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\n*retlen = 0;\r\nif (!mtd->_read_user_prot_reg)\r\nreturn -EOPNOTSUPP;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_read_user_prot_reg(mtd, from, len, retlen, buf);\r\n}\r\nint mtd_write_user_prot_reg(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nint ret;\r\n*retlen = 0;\r\nif (!mtd->_write_user_prot_reg)\r\nreturn -EOPNOTSUPP;\r\nif (!len)\r\nreturn 0;\r\nret = mtd->_write_user_prot_reg(mtd, to, len, retlen, buf);\r\nif (ret)\r\nreturn ret;\r\nreturn (*retlen) ? 0 : -ENOSPC;\r\n}\r\nint mtd_lock_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len)\r\n{\r\nif (!mtd->_lock_user_prot_reg)\r\nreturn -EOPNOTSUPP;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_lock_user_prot_reg(mtd, from, len);\r\n}\r\nint mtd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nif (!mtd->_lock)\r\nreturn -EOPNOTSUPP;\r\nif (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)\r\nreturn -EINVAL;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_lock(mtd, ofs, len);\r\n}\r\nint mtd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nif (!mtd->_unlock)\r\nreturn -EOPNOTSUPP;\r\nif (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)\r\nreturn -EINVAL;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_unlock(mtd, ofs, len);\r\n}\r\nint mtd_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nif (!mtd->_is_locked)\r\nreturn -EOPNOTSUPP;\r\nif (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)\r\nreturn -EINVAL;\r\nif (!len)\r\nreturn 0;\r\nreturn mtd->_is_locked(mtd, ofs, len);\r\n}\r\nint mtd_block_isbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nif (!mtd->_block_isbad)\r\nreturn 0;\r\nif (ofs < 0 || ofs > mtd->size)\r\nreturn -EINVAL;\r\nreturn mtd->_block_isbad(mtd, ofs);\r\n}\r\nint mtd_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nif (!mtd->_block_markbad)\r\nreturn -EOPNOTSUPP;\r\nif (ofs < 0 || ofs > mtd->size)\r\nreturn -EINVAL;\r\nif (!(mtd->flags & MTD_WRITEABLE))\r\nreturn -EROFS;\r\nreturn mtd->_block_markbad(mtd, ofs);\r\n}\r\nstatic int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,\r\nunsigned long count, loff_t to, size_t *retlen)\r\n{\r\nunsigned long i;\r\nsize_t totlen = 0, thislen;\r\nint ret = 0;\r\nfor (i = 0; i < count; i++) {\r\nif (!vecs[i].iov_len)\r\ncontinue;\r\nret = mtd_write(mtd, to, vecs[i].iov_len, &thislen,\r\nvecs[i].iov_base);\r\ntotlen += thislen;\r\nif (ret || thislen != vecs[i].iov_len)\r\nbreak;\r\nto += vecs[i].iov_len;\r\n}\r\n*retlen = totlen;\r\nreturn ret;\r\n}\r\nint mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,\r\nunsigned long count, loff_t to, size_t *retlen)\r\n{\r\n*retlen = 0;\r\nif (!(mtd->flags & MTD_WRITEABLE))\r\nreturn -EROFS;\r\nif (!mtd->_writev)\r\nreturn default_mtd_writev(mtd, vecs, count, to, retlen);\r\nreturn mtd->_writev(mtd, vecs, count, to, retlen);\r\n}\r\nvoid *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)\r\n{\r\ngfp_t flags = __GFP_NOWARN | __GFP_WAIT |\r\n__GFP_NORETRY | __GFP_NO_KSWAPD;\r\nsize_t min_alloc = max_t(size_t, mtd->writesize, PAGE_SIZE);\r\nvoid *kbuf;\r\n*size = min_t(size_t, *size, KMALLOC_MAX_SIZE);\r\nwhile (*size > min_alloc) {\r\nkbuf = kmalloc(*size, flags);\r\nif (kbuf)\r\nreturn kbuf;\r\n*size >>= 1;\r\n*size = ALIGN(*size, mtd->writesize);\r\n}\r\nreturn kmalloc(*size, GFP_KERNEL);\r\n}\r\nstatic int mtd_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct mtd_info *mtd;\r\nseq_puts(m, "dev: size erasesize name\n");\r\nmutex_lock(&mtd_table_mutex);\r\nmtd_for_each_device(mtd) {\r\nseq_printf(m, "mtd%d: %8.8llx %8.8x \"%s\"\n",\r\nmtd->index, (unsigned long long)mtd->size,\r\nmtd->erasesize, mtd->name);\r\n}\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn 0;\r\n}\r\nstatic int mtd_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mtd_proc_show, NULL);\r\n}\r\nstatic int __init mtd_bdi_init(struct backing_dev_info *bdi, const char *name)\r\n{\r\nint ret;\r\nret = bdi_init(bdi);\r\nif (!ret)\r\nret = bdi_register(bdi, NULL, "%s", name);\r\nif (ret)\r\nbdi_destroy(bdi);\r\nreturn ret;\r\n}\r\nstatic int __init init_mtd(void)\r\n{\r\nint ret;\r\nret = class_register(&mtd_class);\r\nif (ret)\r\ngoto err_reg;\r\nret = mtd_bdi_init(&mtd_bdi_unmappable, "mtd-unmap");\r\nif (ret)\r\ngoto err_bdi1;\r\nret = mtd_bdi_init(&mtd_bdi_ro_mappable, "mtd-romap");\r\nif (ret)\r\ngoto err_bdi2;\r\nret = mtd_bdi_init(&mtd_bdi_rw_mappable, "mtd-rwmap");\r\nif (ret)\r\ngoto err_bdi3;\r\nproc_mtd = proc_create("mtd", 0, NULL, &mtd_proc_ops);\r\nret = init_mtdchar();\r\nif (ret)\r\ngoto out_procfs;\r\nreturn 0;\r\nout_procfs:\r\nif (proc_mtd)\r\nremove_proc_entry("mtd", NULL);\r\nerr_bdi3:\r\nbdi_destroy(&mtd_bdi_ro_mappable);\r\nerr_bdi2:\r\nbdi_destroy(&mtd_bdi_unmappable);\r\nerr_bdi1:\r\nclass_unregister(&mtd_class);\r\nerr_reg:\r\npr_err("Error registering mtd class or bdi: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit cleanup_mtd(void)\r\n{\r\ncleanup_mtdchar();\r\nif (proc_mtd)\r\nremove_proc_entry("mtd", NULL);\r\nclass_unregister(&mtd_class);\r\nbdi_destroy(&mtd_bdi_unmappable);\r\nbdi_destroy(&mtd_bdi_ro_mappable);\r\nbdi_destroy(&mtd_bdi_rw_mappable);\r\n}
