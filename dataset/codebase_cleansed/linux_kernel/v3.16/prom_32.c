void * __init prom_early_alloc(unsigned long size)\r\n{\r\nvoid *ret;\r\nret = __alloc_bootmem(size, SMP_CACHE_BYTES, 0UL);\r\nif (ret != NULL)\r\nmemset(ret, 0, size);\r\nprom_early_allocated += size;\r\nreturn ret;\r\n}\r\nstatic void __init sparc32_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct linux_prom_registers *regs;\r\nstruct property *rprop;\r\nrprop = of_find_property(dp, "reg", NULL);\r\nif (!rprop)\r\nreturn;\r\nregs = rprop->value;\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\nregs->which_io, regs->phys_addr);\r\n}\r\nstatic void __init sbus_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct linux_prom_registers *regs;\r\nstruct property *prop;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\nregs->which_io,\r\nregs->phys_addr);\r\n}\r\nstatic void __init pci_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct linux_prom_pci_registers *regs;\r\nstruct property *prop;\r\nunsigned int devfn;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\ndevfn = (regs->phys_hi >> 8) & 0xff;\r\nif (devfn & 0x07) {\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\ndevfn >> 3,\r\ndevfn & 0x07);\r\n} else {\r\nsprintf(tmp_buf, "%s@%x",\r\ndp->name,\r\ndevfn >> 3);\r\n}\r\n}\r\nstatic void __init ebus_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct linux_prom_registers *regs;\r\nstruct property *prop;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\nregs->which_io, regs->phys_addr);\r\n}\r\nstatic void __init ambapp_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct amba_prom_registers *regs;\r\nunsigned int *intr, *device, *vendor, reg0;\r\nstruct property *prop;\r\nint interrupt = 0;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop) {\r\nreg0 = (unsigned int)dp->phandle;\r\n} else {\r\nregs = prop->value;\r\nreg0 = regs->phys_addr;\r\n}\r\nprop = of_find_property(dp, "interrupts", NULL);\r\nif (!prop)\r\nintr = &interrupt;\r\nelse\r\nintr = prop->value;\r\nprop = of_find_property(dp, "vendor", NULL);\r\nif (!prop)\r\nreturn;\r\nvendor = prop->value;\r\nprop = of_find_property(dp, "device", NULL);\r\nif (!prop)\r\nreturn;\r\ndevice = prop->value;\r\nsprintf(tmp_buf, "%s:%d:%d@%x,%x",\r\ndp->name, *vendor, *device,\r\n*intr, reg0);\r\n}\r\nstatic void __init __build_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct device_node *parent = dp->parent;\r\nif (parent != NULL) {\r\nif (!strcmp(parent->type, "pci") ||\r\n!strcmp(parent->type, "pciex"))\r\nreturn pci_path_component(dp, tmp_buf);\r\nif (!strcmp(parent->type, "sbus"))\r\nreturn sbus_path_component(dp, tmp_buf);\r\nif (!strcmp(parent->type, "ebus"))\r\nreturn ebus_path_component(dp, tmp_buf);\r\nif (!strcmp(parent->type, "ambapp"))\r\nreturn ambapp_path_component(dp, tmp_buf);\r\n}\r\nreturn sparc32_path_component(dp, tmp_buf);\r\n}\r\nchar * __init build_path_component(struct device_node *dp)\r\n{\r\nchar tmp_buf[64], *n;\r\ntmp_buf[0] = '\0';\r\n__build_path_component(dp, tmp_buf);\r\nif (tmp_buf[0] == '\0')\r\nstrcpy(tmp_buf, dp->name);\r\nn = prom_early_alloc(strlen(tmp_buf) + 1);\r\nstrcpy(n, tmp_buf);\r\nreturn n;\r\n}\r\nvoid __init of_console_init(void)\r\n{\r\nchar *msg = "OF stdout device is: %s\n";\r\nstruct device_node *dp;\r\nunsigned long flags;\r\nconst char *type;\r\nphandle node;\r\nint skip, tmp, fd;\r\nof_console_path = prom_early_alloc(256);\r\nswitch (prom_vers) {\r\ncase PROM_V0:\r\nskip = 0;\r\nswitch (*romvec->pv_stdout) {\r\ncase PROMDEV_SCREEN:\r\ntype = "display";\r\nbreak;\r\ncase PROMDEV_TTYB:\r\nskip = 1;\r\ncase PROMDEV_TTYA:\r\ntype = "serial";\r\nbreak;\r\ndefault:\r\nprom_printf("Invalid PROM_V0 stdout value %u\n",\r\n*romvec->pv_stdout);\r\nprom_halt();\r\n}\r\ntmp = skip;\r\nfor_each_node_by_type(dp, type) {\r\nif (!tmp--)\r\nbreak;\r\n}\r\nif (!dp) {\r\nprom_printf("Cannot find PROM_V0 console node.\n");\r\nprom_halt();\r\n}\r\nof_console_device = dp;\r\nstrcpy(of_console_path, dp->full_name);\r\nif (!strcmp(type, "serial")) {\r\nstrcat(of_console_path,\r\n(skip ? ":b" : ":a"));\r\n}\r\nbreak;\r\ndefault:\r\ncase PROM_V2:\r\ncase PROM_V3:\r\nfd = *romvec->pv_v2bootargs.fd_stdout;\r\nspin_lock_irqsave(&prom_lock, flags);\r\nnode = (*romvec->pv_v2devops.v2_inst2pkg)(fd);\r\nrestore_current();\r\nspin_unlock_irqrestore(&prom_lock, flags);\r\nif (!node) {\r\nprom_printf("Cannot resolve stdout node from "\r\n"instance %08x.\n", fd);\r\nprom_halt();\r\n}\r\ndp = of_find_node_by_phandle(node);\r\ntype = of_get_property(dp, "device_type", NULL);\r\nif (!type) {\r\nprom_printf("Console stdout lacks "\r\n"device_type property.\n");\r\nprom_halt();\r\n}\r\nif (strcmp(type, "display") && strcmp(type, "serial")) {\r\nprom_printf("Console device_type is neither display "\r\n"nor serial.\n");\r\nprom_halt();\r\n}\r\nof_console_device = dp;\r\nif (prom_vers == PROM_V2) {\r\nstrcpy(of_console_path, dp->full_name);\r\nswitch (*romvec->pv_stdout) {\r\ncase PROMDEV_TTYA:\r\nstrcat(of_console_path, ":a");\r\nbreak;\r\ncase PROMDEV_TTYB:\r\nstrcat(of_console_path, ":b");\r\nbreak;\r\n}\r\n} else {\r\nconst char *path;\r\ndp = of_find_node_by_path("/");\r\npath = of_get_property(dp, "stdout-path", NULL);\r\nif (!path) {\r\nprom_printf("No stdout-path in root node.\n");\r\nprom_halt();\r\n}\r\nstrcpy(of_console_path, path);\r\n}\r\nbreak;\r\n}\r\nof_console_options = strrchr(of_console_path, ':');\r\nif (of_console_options) {\r\nof_console_options++;\r\nif (*of_console_options == '\0')\r\nof_console_options = NULL;\r\n}\r\nprintk(msg, of_console_path);\r\n}\r\nvoid __init of_fill_in_cpu_data(void)\r\n{\r\n}\r\nvoid __init irq_trans_init(struct device_node *dp)\r\n{\r\n}
