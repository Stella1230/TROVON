static enum led_brightness ttusbir_brightness_get(struct led_classdev *led_dev)\r\n{\r\nstruct ttusbir *tt = container_of(led_dev, struct ttusbir, led);\r\nreturn tt->led_on ? LED_FULL : LED_OFF;\r\n}\r\nstatic void ttusbir_set_led(struct ttusbir *tt)\r\n{\r\nint ret;\r\nsmp_mb();\r\nif (tt->led_on != tt->is_led_on && tt->udev &&\r\natomic_add_unless(&tt->led_complete, 1, 1)) {\r\ntt->bulk_buffer[4] = tt->is_led_on = tt->led_on;\r\nret = usb_submit_urb(tt->bulk_urb, GFP_ATOMIC);\r\nif (ret) {\r\ndev_warn(tt->dev, "failed to submit bulk urb: %d\n",\r\nret);\r\natomic_dec(&tt->led_complete);\r\n}\r\n}\r\n}\r\nstatic void ttusbir_brightness_set(struct led_classdev *led_dev, enum\r\nled_brightness brightness)\r\n{\r\nstruct ttusbir *tt = container_of(led_dev, struct ttusbir, led);\r\ntt->led_on = brightness != LED_OFF;\r\nttusbir_set_led(tt);\r\n}\r\nstatic void ttusbir_bulk_complete(struct urb *urb)\r\n{\r\nstruct ttusbir *tt = urb->context;\r\natomic_dec(&tt->led_complete);\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nusb_unlink_urb(urb);\r\nreturn;\r\ncase -EPIPE:\r\ndefault:\r\ndev_dbg(tt->dev, "Error: urb status = %d\n", urb->status);\r\nbreak;\r\n}\r\nttusbir_set_led(tt);\r\n}\r\nstatic void ttusbir_process_ir_data(struct ttusbir *tt, uint8_t *buf)\r\n{\r\nstruct ir_raw_event rawir;\r\nunsigned i, v, b;\r\nbool event = false;\r\ninit_ir_raw_event(&rawir);\r\nfor (i = 0; i < 128; i++) {\r\nv = buf[i] & 0xfe;\r\nswitch (v) {\r\ncase 0xfe:\r\nrawir.pulse = false;\r\nrawir.duration = NS_PER_BYTE;\r\nif (ir_raw_event_store_with_filter(tt->rc, &rawir))\r\nevent = true;\r\nbreak;\r\ncase 0:\r\nrawir.pulse = true;\r\nrawir.duration = NS_PER_BYTE;\r\nif (ir_raw_event_store_with_filter(tt->rc, &rawir))\r\nevent = true;\r\nbreak;\r\ndefault:\r\nif (v & 2) {\r\nb = ffz(v | 1);\r\nrawir.pulse = true;\r\n} else {\r\nb = ffs(v) - 1;\r\nrawir.pulse = false;\r\n}\r\nrawir.duration = NS_PER_BIT * (8 - b);\r\nif (ir_raw_event_store_with_filter(tt->rc, &rawir))\r\nevent = true;\r\nrawir.pulse = !rawir.pulse;\r\nrawir.duration = NS_PER_BIT * b;\r\nif (ir_raw_event_store_with_filter(tt->rc, &rawir))\r\nevent = true;\r\nbreak;\r\n}\r\n}\r\nif (event)\r\nir_raw_event_handle(tt->rc);\r\n}\r\nstatic void ttusbir_urb_complete(struct urb *urb)\r\n{\r\nstruct ttusbir *tt = urb->context;\r\nint rc;\r\nswitch (urb->status) {\r\ncase 0:\r\nttusbir_process_ir_data(tt, urb->transfer_buffer);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nusb_unlink_urb(urb);\r\nreturn;\r\ncase -EPIPE:\r\ndefault:\r\ndev_dbg(tt->dev, "Error: urb status = %d\n", urb->status);\r\nbreak;\r\n}\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (rc && rc != -ENODEV)\r\ndev_warn(tt->dev, "failed to resubmit urb: %d\n", rc);\r\n}\r\nstatic int ttusbir_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct ttusbir *tt;\r\nstruct usb_interface_descriptor *idesc;\r\nstruct usb_endpoint_descriptor *desc;\r\nstruct rc_dev *rc;\r\nint i, j, ret;\r\nint altsetting = -1;\r\ntt = kzalloc(sizeof(*tt), GFP_KERNEL);\r\nrc = rc_allocate_device();\r\nif (!tt || !rc) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < intf->num_altsetting && altsetting == -1; i++) {\r\nint max_packet, bulk_out_endp = -1, iso_in_endp = -1;\r\nidesc = &intf->altsetting[i].desc;\r\nfor (j = 0; j < idesc->bNumEndpoints; j++) {\r\ndesc = &intf->altsetting[i].endpoint[j].desc;\r\nmax_packet = le16_to_cpu(desc->wMaxPacketSize);\r\nif (usb_endpoint_dir_in(desc) &&\r\nusb_endpoint_xfer_isoc(desc) &&\r\nmax_packet == 0x10)\r\niso_in_endp = j;\r\nelse if (usb_endpoint_dir_out(desc) &&\r\nusb_endpoint_xfer_bulk(desc) &&\r\nmax_packet == 0x20)\r\nbulk_out_endp = j;\r\nif (bulk_out_endp != -1 && iso_in_endp != -1) {\r\ntt->bulk_out_endp = bulk_out_endp;\r\ntt->iso_in_endp = iso_in_endp;\r\naltsetting = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (altsetting == -1) {\r\ndev_err(&intf->dev, "cannot find expected altsetting\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ntt->dev = &intf->dev;\r\ntt->udev = interface_to_usbdev(intf);\r\ntt->rc = rc;\r\nret = usb_set_interface(tt->udev, 0, altsetting);\r\nif (ret)\r\ngoto out;\r\nfor (i = 0; i < NUM_URBS; i++) {\r\nstruct urb *urb = usb_alloc_urb(8, GFP_KERNEL);\r\nvoid *buffer;\r\nif (!urb) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nurb->dev = tt->udev;\r\nurb->context = tt;\r\nurb->pipe = usb_rcvisocpipe(tt->udev, tt->iso_in_endp);\r\nurb->interval = 1;\r\nbuffer = usb_alloc_coherent(tt->udev, 128, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buffer) {\r\nusb_free_urb(urb);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nurb->transfer_flags = URB_NO_TRANSFER_DMA_MAP | URB_ISO_ASAP;\r\nurb->transfer_buffer = buffer;\r\nurb->complete = ttusbir_urb_complete;\r\nurb->number_of_packets = 8;\r\nurb->transfer_buffer_length = 128;\r\nfor (j = 0; j < 8; j++) {\r\nurb->iso_frame_desc[j].offset = j * 16;\r\nurb->iso_frame_desc[j].length = 16;\r\n}\r\ntt->urb[i] = urb;\r\n}\r\ntt->bulk_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!tt->bulk_urb) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ntt->bulk_buffer[0] = 0xaa;\r\ntt->bulk_buffer[1] = 0x01;\r\ntt->bulk_buffer[2] = 0x05;\r\ntt->bulk_buffer[3] = 0x01;\r\nusb_fill_bulk_urb(tt->bulk_urb, tt->udev, usb_sndbulkpipe(tt->udev,\r\ntt->bulk_out_endp), tt->bulk_buffer, sizeof(tt->bulk_buffer),\r\nttusbir_bulk_complete, tt);\r\ntt->led.name = "ttusbir:green:power";\r\ntt->led.default_trigger = "rc-feedback";\r\ntt->led.brightness_set = ttusbir_brightness_set;\r\ntt->led.brightness_get = ttusbir_brightness_get;\r\ntt->is_led_on = tt->led_on = true;\r\natomic_set(&tt->led_complete, 0);\r\nret = led_classdev_register(&intf->dev, &tt->led);\r\nif (ret)\r\ngoto out;\r\nusb_make_path(tt->udev, tt->phys, sizeof(tt->phys));\r\nrc->input_name = DRIVER_DESC;\r\nrc->input_phys = tt->phys;\r\nusb_to_input_id(tt->udev, &rc->input_id);\r\nrc->dev.parent = &intf->dev;\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc_set_allowed_protocols(rc, RC_BIT_ALL);\r\nrc->priv = tt;\r\nrc->driver_name = DRIVER_NAME;\r\nrc->map_name = RC_MAP_TT_1500;\r\nrc->timeout = MS_TO_NS(100);\r\nrc->rx_resolution = NS_PER_BIT;\r\nret = rc_register_device(rc);\r\nif (ret) {\r\ndev_err(&intf->dev, "failed to register rc device %d\n", ret);\r\ngoto out2;\r\n}\r\nusb_set_intfdata(intf, tt);\r\nfor (i = 0; i < NUM_URBS; i++) {\r\nret = usb_submit_urb(tt->urb[i], GFP_KERNEL);\r\nif (ret) {\r\ndev_err(tt->dev, "failed to submit urb %d\n", ret);\r\ngoto out3;\r\n}\r\n}\r\nreturn 0;\r\nout3:\r\nrc_unregister_device(rc);\r\nrc = NULL;\r\nout2:\r\nled_classdev_unregister(&tt->led);\r\nout:\r\nif (tt) {\r\nfor (i = 0; i < NUM_URBS && tt->urb[i]; i++) {\r\nstruct urb *urb = tt->urb[i];\r\nusb_kill_urb(urb);\r\nusb_free_coherent(tt->udev, 128, urb->transfer_buffer,\r\nurb->transfer_dma);\r\nusb_free_urb(urb);\r\n}\r\nusb_kill_urb(tt->bulk_urb);\r\nusb_free_urb(tt->bulk_urb);\r\nkfree(tt);\r\n}\r\nrc_free_device(rc);\r\nreturn ret;\r\n}\r\nstatic void ttusbir_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ttusbir *tt = usb_get_intfdata(intf);\r\nstruct usb_device *udev = tt->udev;\r\nint i;\r\ntt->udev = NULL;\r\nrc_unregister_device(tt->rc);\r\nled_classdev_unregister(&tt->led);\r\nfor (i = 0; i < NUM_URBS; i++) {\r\nusb_kill_urb(tt->urb[i]);\r\nusb_free_coherent(udev, 128, tt->urb[i]->transfer_buffer,\r\ntt->urb[i]->transfer_dma);\r\nusb_free_urb(tt->urb[i]);\r\n}\r\nusb_kill_urb(tt->bulk_urb);\r\nusb_free_urb(tt->bulk_urb);\r\nusb_set_intfdata(intf, NULL);\r\nkfree(tt);\r\n}\r\nstatic int ttusbir_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct ttusbir *tt = usb_get_intfdata(intf);\r\nint i;\r\nfor (i = 0; i < NUM_URBS; i++)\r\nusb_kill_urb(tt->urb[i]);\r\nled_classdev_suspend(&tt->led);\r\nusb_kill_urb(tt->bulk_urb);\r\nreturn 0;\r\n}\r\nstatic int ttusbir_resume(struct usb_interface *intf)\r\n{\r\nstruct ttusbir *tt = usb_get_intfdata(intf);\r\nint i, rc;\r\ntt->is_led_on = true;\r\nled_classdev_resume(&tt->led);\r\nfor (i = 0; i < NUM_URBS; i++) {\r\nrc = usb_submit_urb(tt->urb[i], GFP_KERNEL);\r\nif (rc) {\r\ndev_warn(tt->dev, "failed to submit urb: %d\n", rc);\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}
