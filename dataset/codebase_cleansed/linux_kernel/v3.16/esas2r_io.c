void esas2r_start_request(struct esas2r_adapter *a, struct esas2r_request *rq)\r\n{\r\nstruct esas2r_target *t = NULL;\r\nstruct esas2r_request *startrq = rq;\r\nunsigned long flags;\r\nif (unlikely(test_bit(AF_DEGRADED_MODE, &a->flags) ||\r\ntest_bit(AF_POWER_DOWN, &a->flags))) {\r\nif (rq->vrq->scsi.function == VDA_FUNC_SCSI)\r\nrq->req_stat = RS_SEL2;\r\nelse\r\nrq->req_stat = RS_DEGRADED;\r\n} else if (likely(rq->vrq->scsi.function == VDA_FUNC_SCSI)) {\r\nt = a->targetdb + rq->target_id;\r\nif (unlikely(t >= a->targetdb_end\r\n|| !(t->flags & TF_USED))) {\r\nrq->req_stat = RS_SEL;\r\n} else {\r\nrq->vrq->scsi.target_id = cpu_to_le16(t->virt_targ_id);\r\nif (unlikely(t->target_state != TS_PRESENT &&\r\n!test_bit(AF_DISC_PENDING, &a->flags)))\r\nrq->req_stat = RS_SEL;\r\n}\r\n}\r\nif (unlikely(rq->req_stat != RS_PENDING)) {\r\nesas2r_complete_request(a, rq);\r\nreturn;\r\n}\r\nesas2r_trace("rq=%p", rq);\r\nesas2r_trace("rq->vrq->scsi.handle=%x", rq->vrq->scsi.handle);\r\nif (rq->vrq->scsi.function == VDA_FUNC_SCSI) {\r\nesas2r_trace("rq->target_id=%d", rq->target_id);\r\nesas2r_trace("rq->vrq->scsi.flags=%x", rq->vrq->scsi.flags);\r\n}\r\nspin_lock_irqsave(&a->queue_lock, flags);\r\nif (likely(list_empty(&a->defer_list) &&\r\n!test_bit(AF_CHPRST_PENDING, &a->flags) &&\r\n!test_bit(AF_FLASHING, &a->flags) &&\r\n!test_bit(AF_DISC_PENDING, &a->flags)))\r\nesas2r_local_start_request(a, startrq);\r\nelse\r\nlist_add_tail(&startrq->req_list, &a->defer_list);\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\n}\r\nvoid esas2r_local_start_request(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nesas2r_trace_enter();\r\nesas2r_trace("rq=%p", rq);\r\nesas2r_trace("rq->vrq:%p", rq->vrq);\r\nesas2r_trace("rq->vrq_md->phys_addr:%x", rq->vrq_md->phys_addr);\r\nif (unlikely(rq->vrq->scsi.function == VDA_FUNC_FLASH\r\n&& rq->vrq->flash.sub_func == VDA_FLASH_COMMIT))\r\nset_bit(AF_FLASHING, &a->flags);\r\nlist_add_tail(&rq->req_list, &a->active_list);\r\nesas2r_start_vda_request(a, rq);\r\nesas2r_trace_exit();\r\nreturn;\r\n}\r\nvoid esas2r_start_vda_request(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_inbound_list_source_entry *element;\r\nu32 dw;\r\nrq->req_stat = RS_STARTED;\r\na->last_write++;\r\nif (a->last_write >= a->list_size) {\r\na->last_write = 0;\r\nif (test_bit(AF_COMM_LIST_TOGGLE, &a->flags))\r\nclear_bit(AF_COMM_LIST_TOGGLE, &a->flags);\r\nelse\r\nset_bit(AF_COMM_LIST_TOGGLE, &a->flags);\r\n}\r\nelement =\r\n(struct esas2r_inbound_list_source_entry *)a->inbound_list_md.\r\nvirt_addr\r\n+ a->last_write;\r\nif (rq->vda_req_sz == RQ_SIZE_DEFAULT)\r\nrq->vda_req_sz = (u16)(a->max_vdareq_size / sizeof(u32));\r\nelement->address = cpu_to_le64(rq->vrq_md->phys_addr);\r\nelement->length = cpu_to_le32(rq->vda_req_sz);\r\ndw = a->last_write;\r\nif (test_bit(AF_COMM_LIST_TOGGLE, &a->flags))\r\ndw |= MU_ILW_TOGGLE;\r\nesas2r_trace("rq->vrq->scsi.handle:%x", rq->vrq->scsi.handle);\r\nesas2r_trace("dw:%x", dw);\r\nesas2r_trace("rq->vda_req_sz:%x", rq->vda_req_sz);\r\nesas2r_write_register_dword(a, MU_IN_LIST_WRITE, dw);\r\n}\r\nbool esas2r_build_sg_list_sge(struct esas2r_adapter *a,\r\nstruct esas2r_sg_context *sgc)\r\n{\r\nstruct esas2r_request *rq = sgc->first_req;\r\nunion atto_vda_req *vrq = rq->vrq;\r\nwhile (sgc->length) {\r\nu32 rem = 0;\r\nu64 addr;\r\nu32 len;\r\nlen = (*sgc->get_phys_addr)(sgc, &addr);\r\nif (unlikely(len == 0))\r\nreturn false;\r\nif (unlikely(len > sgc->length))\r\nlen = sgc->length;\r\nanother_entry:\r\nif (len > SGE_LEN_MAX) {\r\nrem = len - SGE_LEN_MAX;\r\nlen = SGE_LEN_MAX;\r\n}\r\nif (unlikely(sgc->sge.a64.curr > sgc->sge.a64.limit)) {\r\nu8 sgelen;\r\nstruct esas2r_mem_desc *sgl;\r\nsgl = esas2r_alloc_sgl(a);\r\nif (unlikely(sgl == NULL))\r\nreturn false;\r\nsgelen = (u8)((u8 *)sgc->sge.a64.curr\r\n- (u8 *)sgc->sge.a64.last);\r\nmemcpy(sgl->virt_addr, sgc->sge.a64.last, sgelen);\r\nsgc->sge.a64.curr =\r\n(struct atto_vda_sge *)((u8 *)sgl->virt_addr +\r\nsgelen);\r\nsgc->sge.a64.limit =\r\n(struct atto_vda_sge *)((u8 *)sgl->virt_addr\r\n+ sgl_page_size\r\n- sizeof(struct\r\natto_vda_sge));\r\nsgc->sge.a64.last->length = cpu_to_le32(\r\nSGE_CHAIN | SGE_ADDR_64);\r\nsgc->sge.a64.last->address =\r\ncpu_to_le64(sgl->phys_addr);\r\nif (sgc->sge.a64.chain) {\r\nsgc->sge.a64.chain->length |=\r\ncpu_to_le32(\r\n((u8 *)(sgc->sge.a64.\r\nlast + 1)\r\n- (u8 *)rq->sg_table->\r\nvirt_addr)\r\n+ sizeof(struct atto_vda_sge) *\r\nLOBIT(SGE_CHAIN_SZ));\r\n} else {\r\nvrq->scsi.chain_offset = (u8)\r\n((u8 *)sgc->\r\nsge.a64.last -\r\n(u8 *)vrq);\r\nrq->vda_req_sz =\r\n(vrq->scsi.chain_offset +\r\nsizeof(struct atto_vda_sge) +\r\n3)\r\n/ sizeof(u32);\r\n}\r\nsgc->sge.a64.chain = sgc->sge.a64.last;\r\nlist_add(&sgl->next_desc, &rq->sg_table_head);\r\n}\r\nsgc->sge.a64.last = sgc->sge.a64.curr;\r\nsgc->sge.a64.curr->length = cpu_to_le32(SGE_ADDR_64 | len);\r\nsgc->sge.a64.curr->address = cpu_to_le32(addr);\r\nsgc->sge.a64.curr++;\r\nsgc->cur_offset += len;\r\nsgc->length -= len;\r\nif (rem) {\r\naddr += len;\r\nlen = rem;\r\nrem = 0;\r\ngoto another_entry;\r\n}\r\n}\r\nsgc->sge.a64.last->length |= cpu_to_le32(SGE_LAST);\r\nif (sgc->sge.a64.chain) {\r\nsgc->sge.a64.chain->length |= cpu_to_le32(\r\n((u8 *)(sgc->sge.a64.curr) -\r\n(u8 *)rq->sg_table->virt_addr));\r\n} else {\r\nu16 reqsize;\r\nreqsize =\r\n((u16)((u8 *)sgc->sge.a64.last - (u8 *)vrq)\r\n+ sizeof(struct atto_vda_sge) + 3) / sizeof(u32);\r\nif (reqsize > rq->vda_req_sz)\r\nrq->vda_req_sz = reqsize;\r\n}\r\nreturn true;\r\n}\r\nstatic bool esas2r_build_prd_iblk(struct esas2r_adapter *a,\r\nstruct esas2r_sg_context *sgc)\r\n{\r\nstruct esas2r_request *rq = sgc->first_req;\r\nu64 addr;\r\nu32 len;\r\nstruct esas2r_mem_desc *sgl;\r\nu32 numchain = 1;\r\nu32 rem = 0;\r\nwhile (sgc->length) {\r\nlen = (*sgc->get_phys_addr)(sgc, &addr);\r\nif (unlikely(len == 0))\r\nreturn false;\r\nif (unlikely(len > sgc->length))\r\nlen = sgc->length;\r\nanother_entry:\r\nif (len > PRD_LEN_MAX) {\r\nrem = len - PRD_LEN_MAX;\r\nlen = PRD_LEN_MAX;\r\n}\r\nif (sgc->sge.prd.sge_cnt == 0) {\r\nif (len == sgc->length) {\r\nsgc->sge.prd.curr->ctl_len = cpu_to_le32(\r\nPRD_DATA | len);\r\nsgc->sge.prd.curr->address = cpu_to_le64(addr);\r\nsgc->cur_offset += len;\r\nsgc->length -= len;\r\nnumchain = 0;\r\nbreak;\r\n}\r\nif (sgc->sge.prd.chain) {\r\nsgc->sge.prd.chain->ctl_len |= cpu_to_le32(\r\nsgc->sge.prd.sgl_max_cnt);\r\n}\r\nsgl = esas2r_alloc_sgl(a);\r\nif (unlikely(sgl == NULL))\r\nreturn false;\r\nlist_add(&sgl->next_desc, &rq->sg_table_head);\r\nsgc->sge.prd.chain = sgc->sge.prd.curr;\r\nsgc->sge.prd.chain->ctl_len = cpu_to_le32(PRD_CHAIN);\r\nsgc->sge.prd.chain->address =\r\ncpu_to_le64(sgl->phys_addr);\r\nsgc->sge.prd.curr =\r\n(struct atto_physical_region_description *)sgl\r\n->\r\nvirt_addr;\r\nsgc->sge.prd.sge_cnt = sgc->sge.prd.sgl_max_cnt - 1;\r\n}\r\nsgc->sge.prd.sge_cnt--;\r\nsgc->sge.prd.curr->ctl_len = cpu_to_le32(PRD_DATA | len);\r\nsgc->sge.prd.curr->address = cpu_to_le64(addr);\r\nsgc->sge.prd.curr++;\r\nsgc->cur_offset += len;\r\nsgc->length -= len;\r\nif (rem) {\r\naddr += len;\r\nlen = rem;\r\nrem = 0;\r\ngoto another_entry;\r\n}\r\n}\r\nif (!list_empty(&rq->sg_table_head)) {\r\nif (sgc->sge.prd.chain) {\r\nsgc->sge.prd.chain->ctl_len |=\r\ncpu_to_le32(sgc->sge.prd.sgl_max_cnt\r\n- sgc->sge.prd.sge_cnt\r\n- numchain);\r\n}\r\n}\r\nreturn true;\r\n}\r\nbool esas2r_build_sg_list_prd(struct esas2r_adapter *a,\r\nstruct esas2r_sg_context *sgc)\r\n{\r\nstruct esas2r_request *rq = sgc->first_req;\r\nu32 len = sgc->length;\r\nstruct esas2r_target *t = a->targetdb + rq->target_id;\r\nu8 is_i_o = 0;\r\nu16 reqsize;\r\nstruct atto_physical_region_description *curr_iblk_chn;\r\nu8 *cdb = (u8 *)&rq->vrq->scsi.cdb[0];\r\nif (rq->vrq->scsi.function == VDA_FUNC_SCSI\r\n&& t->target_state == TS_PRESENT\r\n&& !(t->flags & TF_PASS_THRU)) {\r\nu32 lbalo = 0;\r\nswitch (rq->vrq->scsi.cdb[0]) {\r\ncase READ_16:\r\ncase WRITE_16:\r\n{\r\nlbalo =\r\nMAKEDWORD(MAKEWORD(cdb[9],\r\ncdb[8]),\r\nMAKEWORD(cdb[7],\r\ncdb[6]));\r\nis_i_o = 1;\r\nbreak;\r\n}\r\ncase READ_12:\r\ncase WRITE_12:\r\ncase READ_10:\r\ncase WRITE_10:\r\n{\r\nlbalo =\r\nMAKEDWORD(MAKEWORD(cdb[5],\r\ncdb[4]),\r\nMAKEWORD(cdb[3],\r\ncdb[2]));\r\nis_i_o = 1;\r\nbreak;\r\n}\r\ncase READ_6:\r\ncase WRITE_6:\r\n{\r\nlbalo =\r\nMAKEDWORD(MAKEWORD(cdb[3],\r\ncdb[2]),\r\nMAKEWORD(cdb[1] & 0x1F,\r\n0));\r\nis_i_o = 1;\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nif (is_i_o) {\r\nu32 startlba;\r\nrq->vrq->scsi.iblk_cnt_prd = 0;\r\nstartlba = t->inter_block - (lbalo & (t->inter_block -\r\n1));\r\nsgc->length = startlba * t->block_size;\r\nif ((lbalo & (t->inter_block - 1)) == 0)\r\nrq->flags |= RF_1ST_IBLK_BASE;\r\nif (sgc->length > len)\r\nsgc->length = len;\r\n} else {\r\nsgc->length = len;\r\n}\r\n} else {\r\nsgc->length = len;\r\n}\r\ncurr_iblk_chn =\r\n(struct atto_physical_region_description *)sgc->sge.a64.curr;\r\nsgc->sge.prd.sgl_max_cnt = sgl_page_size /\r\nsizeof(struct\r\natto_physical_region_description);\r\nwhile (len) {\r\nsgc->sge.prd.sge_cnt = 0;\r\nsgc->sge.prd.chain = NULL;\r\nsgc->sge.prd.curr = curr_iblk_chn;\r\nlen -= sgc->length;\r\nif (unlikely(!esas2r_build_prd_iblk(a, sgc)))\r\nreturn false;\r\ncurr_iblk_chn++;\r\nif (is_i_o) {\r\nrq->vrq->scsi.iblk_cnt_prd++;\r\nif (len > t->inter_byte)\r\nsgc->length = t->inter_byte;\r\nelse\r\nsgc->length = len;\r\n}\r\n}\r\nreqsize = ((u16)((u8 *)curr_iblk_chn - (u8 *)rq->vrq))\r\n/ sizeof(u32);\r\nif (reqsize > rq->vda_req_sz)\r\nrq->vda_req_sz = reqsize;\r\nreturn true;\r\n}\r\nstatic void esas2r_handle_pending_reset(struct esas2r_adapter *a, u32 currtime)\r\n{\r\nu32 delta = currtime - a->chip_init_time;\r\nif (delta <= ESAS2R_CHPRST_WAIT_TIME) {\r\n} else if (delta >= ESAS2R_CHPRST_TIME) {\r\nesas2r_local_reset_adapter(a);\r\n} else {\r\nu32 doorbell;\r\ndoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\r\nif (doorbell == 0xFFFFFFFF || !(doorbell & DRBL_FORCE_INT)) {\r\nesas2r_force_interrupt(a);\r\n} else {\r\nu32 ver = (doorbell & DRBL_FW_VER_MSK);\r\nesas2r_write_register_dword(a, MU_DOORBELL_OUT,\r\ndoorbell);\r\nif (ver == DRBL_FW_VER_0) {\r\nset_bit(AF_CHPRST_DETECTED, &a->flags);\r\nset_bit(AF_LEGACY_SGE_MODE, &a->flags);\r\na->max_vdareq_size = 128;\r\na->build_sgl = esas2r_build_sg_list_sge;\r\n} else if (ver == DRBL_FW_VER_1) {\r\nset_bit(AF_CHPRST_DETECTED, &a->flags);\r\nclear_bit(AF_LEGACY_SGE_MODE, &a->flags);\r\na->max_vdareq_size = 1024;\r\na->build_sgl = esas2r_build_sg_list_prd;\r\n} else {\r\nesas2r_local_reset_adapter(a);\r\n}\r\n}\r\n}\r\n}\r\nvoid esas2r_timer_tick(struct esas2r_adapter *a)\r\n{\r\nu32 currtime = jiffies_to_msecs(jiffies);\r\nu32 deltatime = currtime - a->last_tick_time;\r\na->last_tick_time = currtime;\r\nif (a->chip_uptime &&\r\n!test_bit(AF_CHPRST_PENDING, &a->flags) &&\r\n!test_bit(AF_DISC_PENDING, &a->flags)) {\r\nif (deltatime >= a->chip_uptime)\r\na->chip_uptime = 0;\r\nelse\r\na->chip_uptime -= deltatime;\r\n}\r\nif (test_bit(AF_CHPRST_PENDING, &a->flags)) {\r\nif (!test_bit(AF_CHPRST_NEEDED, &a->flags) &&\r\n!test_bit(AF_CHPRST_DETECTED, &a->flags))\r\nesas2r_handle_pending_reset(a, currtime);\r\n} else {\r\nif (test_bit(AF_DISC_PENDING, &a->flags))\r\nesas2r_disc_check_complete(a);\r\nif (test_bit(AF_HEARTBEAT_ENB, &a->flags)) {\r\nif (test_bit(AF_HEARTBEAT, &a->flags)) {\r\nif ((currtime - a->heartbeat_time) >=\r\nESAS2R_HEARTBEAT_TIME) {\r\nclear_bit(AF_HEARTBEAT, &a->flags);\r\nesas2r_hdebug("heartbeat failed");\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"heartbeat failed");\r\nesas2r_bugon();\r\nesas2r_local_reset_adapter(a);\r\n}\r\n} else {\r\nset_bit(AF_HEARTBEAT, &a->flags);\r\na->heartbeat_time = currtime;\r\nesas2r_force_interrupt(a);\r\n}\r\n}\r\n}\r\nif (atomic_read(&a->disable_cnt) == 0)\r\nesas2r_do_deferred_processes(a);\r\n}\r\nbool esas2r_send_task_mgmt(struct esas2r_adapter *a,\r\nstruct esas2r_request *rqaux, u8 task_mgt_func)\r\n{\r\nu16 targetid = rqaux->target_id;\r\nu8 lun = (u8)le32_to_cpu(rqaux->vrq->scsi.flags);\r\nbool ret = false;\r\nstruct esas2r_request *rq;\r\nstruct list_head *next, *element;\r\nunsigned long flags;\r\nLIST_HEAD(comp_list);\r\nesas2r_trace_enter();\r\nesas2r_trace("rqaux:%p", rqaux);\r\nesas2r_trace("task_mgt_func:%x", task_mgt_func);\r\nspin_lock_irqsave(&a->queue_lock, flags);\r\nlist_for_each_safe(element, next, &a->defer_list) {\r\nrq = list_entry(element, struct esas2r_request, req_list);\r\nif (rq->vrq->scsi.function == VDA_FUNC_SCSI\r\n&& rq->target_id == targetid\r\n&& (((u8)le32_to_cpu(rq->vrq->scsi.flags)) == lun\r\n|| task_mgt_func == 0x20)) {\r\nif (rq->req_stat == RS_PENDING) {\r\nif (esas2r_ioreq_aborted(a, rq, RS_ABORTED))\r\nlist_add_tail(&rq->comp_list,\r\n&comp_list);\r\n}\r\n}\r\n}\r\nrqaux->sense_len = 0;\r\nrqaux->vrq->scsi.length = 0;\r\nrqaux->target_id = targetid;\r\nrqaux->vrq->scsi.flags |= cpu_to_le32(lun);\r\nmemset(rqaux->vrq->scsi.cdb, 0, sizeof(rqaux->vrq->scsi.cdb));\r\nrqaux->vrq->scsi.flags |=\r\ncpu_to_le16(task_mgt_func * LOBIT(FCP_CMND_TM_MASK));\r\nif (test_bit(AF_FLASHING, &a->flags)) {\r\nrqaux->req_stat = RS_SUCCESS;\r\nlist_for_each_safe(element, next, &a->active_list) {\r\nrq = list_entry(element, struct esas2r_request,\r\nreq_list);\r\nif (rq->vrq->scsi.function == VDA_FUNC_SCSI\r\n&& rq->target_id == targetid\r\n&& (((u8)le32_to_cpu(rq->vrq->scsi.flags)) == lun\r\n|| task_mgt_func == 0x20))\r\nrqaux->req_stat = RS_BUSY;\r\n}\r\nret = true;\r\n}\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nif (!test_bit(AF_FLASHING, &a->flags))\r\nesas2r_start_request(a, rqaux);\r\nesas2r_comp_list_drain(a, &comp_list);\r\nif (atomic_read(&a->disable_cnt) == 0)\r\nesas2r_do_deferred_processes(a);\r\nesas2r_trace_exit();\r\nreturn ret;\r\n}\r\nvoid esas2r_reset_bus(struct esas2r_adapter *a)\r\n{\r\nesas2r_log(ESAS2R_LOG_INFO, "performing a bus reset");\r\nif (!test_bit(AF_DEGRADED_MODE, &a->flags) &&\r\n!test_bit(AF_CHPRST_PENDING, &a->flags) &&\r\n!test_bit(AF_DISC_PENDING, &a->flags)) {\r\nset_bit(AF_BUSRST_NEEDED, &a->flags);\r\nset_bit(AF_BUSRST_PENDING, &a->flags);\r\nset_bit(AF_OS_RESET, &a->flags);\r\nesas2r_schedule_tasklet(a);\r\n}\r\n}\r\nbool esas2r_ioreq_aborted(struct esas2r_adapter *a, struct esas2r_request *rq,\r\nu8 status)\r\n{\r\nesas2r_trace_enter();\r\nesas2r_trace("rq:%p", rq);\r\nlist_del_init(&rq->req_list);\r\nif (rq->timeout > RQ_MAX_TIMEOUT) {\r\nrq->req_stat = RS_BUSY;\r\nesas2r_trace_exit();\r\nreturn true;\r\n}\r\nrq->req_stat = status;\r\nesas2r_trace_exit();\r\nreturn true;\r\n}
