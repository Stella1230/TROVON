void psb_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct gtt_range *gtt = container_of(obj, struct gtt_range, gem);\r\ndrm_gem_free_mmap_offset(obj);\r\ndrm_gem_object_release(obj);\r\npsb_gtt_free_range(obj->dev, gtt);\r\n}\r\nint psb_gem_get_aperture(struct drm_device *dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint psb_gem_dumb_map_gtt(struct drm_file *file, struct drm_device *dev,\r\nuint32_t handle, uint64_t *offset)\r\n{\r\nint ret = 0;\r\nstruct drm_gem_object *obj;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file, handle);\r\nif (obj == NULL) {\r\nret = -ENOENT;\r\ngoto unlock;\r\n}\r\nret = drm_gem_create_mmap_offset(obj);\r\nif (ret)\r\ngoto out;\r\n*offset = drm_vma_node_offset_addr(&obj->vma_node);\r\nout:\r\ndrm_gem_object_unreference(obj);\r\nunlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nint psb_gem_create(struct drm_file *file, struct drm_device *dev, u64 size,\r\nu32 *handlep, int stolen, u32 align)\r\n{\r\nstruct gtt_range *r;\r\nint ret;\r\nu32 handle;\r\nsize = roundup(size, PAGE_SIZE);\r\nr = psb_gtt_alloc_range(dev, size, "gem", 0, PAGE_SIZE);\r\nif (r == NULL) {\r\ndev_err(dev->dev, "no memory for %lld byte GEM object\n", size);\r\nreturn -ENOSPC;\r\n}\r\nif (drm_gem_object_init(dev, &r->gem, size) != 0) {\r\npsb_gtt_free_range(dev, r);\r\ndev_err(dev->dev, "GEM init failed for %lld\n", size);\r\nreturn -ENOMEM;\r\n}\r\nmapping_set_gfp_mask(r->gem.filp->f_mapping, GFP_KERNEL | __GFP_DMA32);\r\nret = drm_gem_handle_create(file, &r->gem, &handle);\r\nif (ret) {\r\ndev_err(dev->dev, "GEM handle failed for %p, %lld\n",\r\n&r->gem, size);\r\ndrm_gem_object_release(&r->gem);\r\npsb_gtt_free_range(dev, r);\r\nreturn ret;\r\n}\r\ndrm_gem_object_unreference(&r->gem);\r\n*handlep = handle;\r\nreturn 0;\r\n}\r\nint psb_gem_dumb_create(struct drm_file *file, struct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nargs->pitch = ALIGN(args->width * ((args->bpp + 7) / 8), 64);\r\nargs->size = args->pitch * args->height;\r\nreturn psb_gem_create(file, dev, args->size, &args->handle, 0,\r\nPAGE_SIZE);\r\n}\r\nint psb_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct gtt_range *r;\r\nint ret;\r\nunsigned long pfn;\r\npgoff_t page_offset;\r\nstruct drm_device *dev;\r\nstruct drm_psb_private *dev_priv;\r\nobj = vma->vm_private_data;\r\ndev = obj->dev;\r\ndev_priv = dev->dev_private;\r\nr = container_of(obj, struct gtt_range, gem);\r\nmutex_lock(&dev->struct_mutex);\r\nif (r->mmapping == 0) {\r\nret = psb_gtt_pin(r);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "gma500: pin failed: %d\n", ret);\r\ngoto fail;\r\n}\r\nr->mmapping = 1;\r\n}\r\npage_offset = ((unsigned long) vmf->virtual_address - vma->vm_start)\r\n>> PAGE_SHIFT;\r\nif (r->stolen)\r\npfn = (dev_priv->stolen_base + r->offset) >> PAGE_SHIFT;\r\nelse\r\npfn = page_to_pfn(r->pages[page_offset]);\r\nret = vm_insert_pfn(vma, (unsigned long)vmf->virtual_address, pfn);\r\nfail:\r\nmutex_unlock(&dev->struct_mutex);\r\nswitch (ret) {\r\ncase 0:\r\ncase -ERESTARTSYS:\r\ncase -EINTR:\r\nreturn VM_FAULT_NOPAGE;\r\ncase -ENOMEM:\r\nreturn VM_FAULT_OOM;\r\ndefault:\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\n}
