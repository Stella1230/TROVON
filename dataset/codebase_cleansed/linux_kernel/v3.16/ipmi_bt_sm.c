static char *state2txt(unsigned char state)\r\n{\r\nswitch (state) {\r\ncase BT_STATE_IDLE: return("IDLE");\r\ncase BT_STATE_XACTION_START: return("XACTION");\r\ncase BT_STATE_WRITE_BYTES: return("WR_BYTES");\r\ncase BT_STATE_WRITE_CONSUME: return("WR_CONSUME");\r\ncase BT_STATE_READ_WAIT: return("RD_WAIT");\r\ncase BT_STATE_CLEAR_B2H: return("CLEAR_B2H");\r\ncase BT_STATE_READ_BYTES: return("RD_BYTES");\r\ncase BT_STATE_RESET1: return("RESET1");\r\ncase BT_STATE_RESET2: return("RESET2");\r\ncase BT_STATE_RESET3: return("RESET3");\r\ncase BT_STATE_RESTART: return("RESTART");\r\ncase BT_STATE_LONG_BUSY: return("LONG_BUSY");\r\ncase BT_STATE_CAPABILITIES_BEGIN: return("CAP_BEGIN");\r\ncase BT_STATE_CAPABILITIES_END: return("CAP_END");\r\n}\r\nreturn("BAD STATE");\r\n}\r\nstatic char *status2txt(unsigned char status)\r\n{\r\nstatic char buf[40];\r\nstrcpy(buf, "[ ");\r\nif (status & BT_B_BUSY)\r\nstrcat(buf, "B_BUSY ");\r\nif (status & BT_H_BUSY)\r\nstrcat(buf, "H_BUSY ");\r\nif (status & BT_OEM0)\r\nstrcat(buf, "OEM0 ");\r\nif (status & BT_SMS_ATN)\r\nstrcat(buf, "SMS ");\r\nif (status & BT_B2H_ATN)\r\nstrcat(buf, "B2H ");\r\nif (status & BT_H2B_ATN)\r\nstrcat(buf, "H2B ");\r\nstrcat(buf, "]");\r\nreturn buf;\r\n}\r\nstatic unsigned int bt_init_data(struct si_sm_data *bt, struct si_sm_io *io)\r\n{\r\nmemset(bt, 0, sizeof(struct si_sm_data));\r\nif (bt->io != io) {\r\nbt->io = io;\r\nbt->seq = 0;\r\n}\r\nbt->state = BT_STATE_IDLE;\r\nbt->complete = BT_STATE_IDLE;\r\nbt->BT_CAP_req2rsp = BT_NORMAL_TIMEOUT * USEC_PER_SEC;\r\nbt->BT_CAP_retries = BT_NORMAL_RETRY_LIMIT;\r\nreturn 3;\r\n}\r\nstatic void force_result(struct si_sm_data *bt, unsigned char completion_code)\r\n{\r\nbt->read_data[0] = 4;\r\nbt->read_data[1] = bt->write_data[1] | 4;\r\nbt->read_data[2] = bt->write_data[2];\r\nbt->read_data[3] = bt->write_data[3];\r\nbt->read_data[4] = completion_code;\r\nbt->read_count = 5;\r\n}\r\nstatic int bt_start_transaction(struct si_sm_data *bt,\r\nunsigned char *data,\r\nunsigned int size)\r\n{\r\nunsigned int i;\r\nif (size < 2)\r\nreturn IPMI_REQ_LEN_INVALID_ERR;\r\nif (size > IPMI_MAX_MSG_LENGTH)\r\nreturn IPMI_REQ_LEN_EXCEEDED_ERR;\r\nif (bt->state == BT_STATE_LONG_BUSY)\r\nreturn IPMI_NODE_BUSY_ERR;\r\nif (bt->state != BT_STATE_IDLE)\r\nreturn IPMI_NOT_IN_MY_STATE_ERR;\r\nif (bt_debug & BT_DEBUG_MSG) {\r\nprintk(KERN_WARNING "BT: +++++++++++++++++ New command\n");\r\nprintk(KERN_WARNING "BT: NetFn/LUN CMD [%d data]:", size - 2);\r\nfor (i = 0; i < size; i ++)\r\nprintk(" %02x", data[i]);\r\nprintk("\n");\r\n}\r\nbt->write_data[0] = size + 1;\r\nbt->write_data[1] = *data;\r\nbt->write_data[2] = bt->seq++;\r\nmemcpy(bt->write_data + 3, data + 1, size - 1);\r\nbt->write_count = size + 2;\r\nbt->error_retries = 0;\r\nbt->nonzero_status = 0;\r\nbt->truncated = 0;\r\nbt->state = BT_STATE_XACTION_START;\r\nbt->timeout = bt->BT_CAP_req2rsp;\r\nforce_result(bt, IPMI_ERR_UNSPECIFIED);\r\nreturn 0;\r\n}\r\nstatic int bt_get_result(struct si_sm_data *bt,\r\nunsigned char *data,\r\nunsigned int length)\r\n{\r\nint i, msg_len;\r\nmsg_len = bt->read_count - 2;\r\nif (msg_len < 3 || msg_len > IPMI_MAX_MSG_LENGTH) {\r\nforce_result(bt, IPMI_ERR_UNSPECIFIED);\r\nmsg_len = 3;\r\n}\r\ndata[0] = bt->read_data[1];\r\ndata[1] = bt->read_data[3];\r\nif (length < msg_len || bt->truncated) {\r\ndata[2] = IPMI_ERR_MSG_TRUNCATED;\r\nmsg_len = 3;\r\n} else\r\nmemcpy(data + 2, bt->read_data + 4, msg_len - 2);\r\nif (bt_debug & BT_DEBUG_MSG) {\r\nprintk(KERN_WARNING "BT: result %d bytes:", msg_len);\r\nfor (i = 0; i < msg_len; i++)\r\nprintk(" %02x", data[i]);\r\nprintk("\n");\r\n}\r\nreturn msg_len;\r\n}\r\nstatic void reset_flags(struct si_sm_data *bt)\r\n{\r\nif (bt_debug)\r\nprintk(KERN_WARNING "IPMI BT: flag reset %s\n",\r\nstatus2txt(BT_STATUS));\r\nif (BT_STATUS & BT_H_BUSY)\r\nBT_CONTROL(BT_H_BUSY);\r\nBT_CONTROL(BT_CLR_WR_PTR);\r\nBT_CONTROL(BT_SMS_ATN);\r\nBT_INTMASK_W(BT_BMC_HWRST);\r\n}\r\nstatic void drain_BMC2HOST(struct si_sm_data *bt)\r\n{\r\nint i, size;\r\nif (!(BT_STATUS & BT_B2H_ATN))\r\nreturn;\r\nBT_CONTROL(BT_H_BUSY);\r\nBT_CONTROL(BT_B2H_ATN);\r\nBT_STATUS;\r\nBT_CONTROL(BT_B2H_ATN);\r\nBT_CONTROL(BT_CLR_RD_PTR);\r\nif (bt_debug)\r\nprintk(KERN_WARNING "IPMI BT: stale response %s; ",\r\nstatus2txt(BT_STATUS));\r\nsize = BMC2HOST;\r\nfor (i = 0; i < size ; i++)\r\nBMC2HOST;\r\nBT_CONTROL(BT_H_BUSY);\r\nif (bt_debug)\r\nprintk("drained %d bytes\n", size + 1);\r\n}\r\nstatic inline void write_all_bytes(struct si_sm_data *bt)\r\n{\r\nint i;\r\nif (bt_debug & BT_DEBUG_MSG) {\r\nprintk(KERN_WARNING "BT: write %d bytes seq=0x%02X",\r\nbt->write_count, bt->seq);\r\nfor (i = 0; i < bt->write_count; i++)\r\nprintk(" %02x", bt->write_data[i]);\r\nprintk("\n");\r\n}\r\nfor (i = 0; i < bt->write_count; i++)\r\nHOST2BMC(bt->write_data[i]);\r\n}\r\nstatic inline int read_all_bytes(struct si_sm_data *bt)\r\n{\r\nunsigned int i;\r\nbt->read_data[0] = BMC2HOST;\r\nbt->read_count = bt->read_data[0];\r\nif (bt->read_count < 4 || bt->read_count >= IPMI_MAX_MSG_LENGTH) {\r\nif (bt_debug & BT_DEBUG_MSG)\r\nprintk(KERN_WARNING "BT: bad raw rsp len=%d\n",\r\nbt->read_count);\r\nbt->truncated = 1;\r\nreturn 1;\r\n}\r\nfor (i = 1; i <= bt->read_count; i++)\r\nbt->read_data[i] = BMC2HOST;\r\nbt->read_count++;\r\nif (bt_debug & BT_DEBUG_MSG) {\r\nint max = bt->read_count;\r\nprintk(KERN_WARNING "BT: got %d bytes seq=0x%02X",\r\nmax, bt->read_data[2]);\r\nif (max > 16)\r\nmax = 16;\r\nfor (i = 0; i < max; i++)\r\nprintk(KERN_CONT " %02x", bt->read_data[i]);\r\nprintk(KERN_CONT "%s\n", bt->read_count == max ? "" : " ...");\r\n}\r\nif ((bt->read_data[3] == bt->write_data[3]) &&\r\n(bt->read_data[2] == bt->write_data[2]) &&\r\n((bt->read_data[1] & 0xF8) == (bt->write_data[1] & 0xF8)))\r\nreturn 1;\r\nif (bt_debug & BT_DEBUG_MSG)\r\nprintk(KERN_WARNING "IPMI BT: bad packet: "\r\n"want 0x(%02X, %02X, %02X) got (%02X, %02X, %02X)\n",\r\nbt->write_data[1] | 0x04, bt->write_data[2], bt->write_data[3],\r\nbt->read_data[1], bt->read_data[2], bt->read_data[3]);\r\nreturn 0;\r\n}\r\nstatic enum si_sm_result error_recovery(struct si_sm_data *bt,\r\nunsigned char status,\r\nunsigned char cCode)\r\n{\r\nchar *reason;\r\nbt->timeout = bt->BT_CAP_req2rsp;\r\nswitch (cCode) {\r\ncase IPMI_TIMEOUT_ERR:\r\nreason = "timeout";\r\nbreak;\r\ndefault:\r\nreason = "internal error";\r\nbreak;\r\n}\r\nprintk(KERN_WARNING "IPMI BT: %s in %s %s ",\r\nreason, STATE2TXT, STATUS2TXT);\r\n(bt->error_retries)++;\r\nif (bt->error_retries < bt->BT_CAP_retries) {\r\nprintk("%d retries left\n",\r\nbt->BT_CAP_retries - bt->error_retries);\r\nbt->state = BT_STATE_RESTART;\r\nreturn SI_SM_CALL_WITHOUT_DELAY;\r\n}\r\nprintk(KERN_WARNING "failed %d retries, sending error response\n",\r\nbt->BT_CAP_retries);\r\nif (!bt->nonzero_status)\r\nprintk(KERN_ERR "IPMI BT: stuck, try power cycle\n");\r\nelse if (bt->seq <= (unsigned char)(bt->BT_CAP_retries & 0xFF)) {\r\nprintk(KERN_WARNING "IPMI: BT reset (takes 5 secs)\n");\r\nbt->state = BT_STATE_RESET1;\r\nreturn SI_SM_CALL_WITHOUT_DELAY;\r\n}\r\nbt->state = BT_STATE_IDLE;\r\nswitch (cCode) {\r\ncase IPMI_TIMEOUT_ERR:\r\nif (status & BT_B_BUSY) {\r\ncCode = IPMI_NODE_BUSY_ERR;\r\nbt->state = BT_STATE_LONG_BUSY;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nforce_result(bt, cCode);\r\nreturn SI_SM_TRANSACTION_COMPLETE;\r\n}\r\nstatic enum si_sm_result bt_event(struct si_sm_data *bt, long time)\r\n{\r\nunsigned char status, BT_CAP[8];\r\nstatic enum bt_states last_printed = BT_STATE_PRINTME;\r\nint i;\r\nstatus = BT_STATUS;\r\nbt->nonzero_status |= status;\r\nif ((bt_debug & BT_DEBUG_STATES) && (bt->state != last_printed)) {\r\nprintk(KERN_WARNING "BT: %s %s TO=%ld - %ld \n",\r\nSTATE2TXT,\r\nSTATUS2TXT,\r\nbt->timeout,\r\ntime);\r\nlast_printed = bt->state;\r\n}\r\nif ((bt->state < BT_STATE_WRITE_BYTES) && (status & BT_B2H_ATN)) {\r\ndrain_BMC2HOST(bt);\r\nBT_SI_SM_RETURN(SI_SM_CALL_WITH_DELAY);\r\n}\r\nif ((bt->state != BT_STATE_IDLE) &&\r\n(bt->state < BT_STATE_PRINTME)) {\r\nbt->timeout -= time;\r\nif ((bt->timeout < 0) && (bt->state < BT_STATE_RESET1))\r\nreturn error_recovery(bt,\r\nstatus,\r\nIPMI_TIMEOUT_ERR);\r\n}\r\nswitch (bt->state) {\r\ncase BT_STATE_IDLE:\r\nif (status & BT_SMS_ATN) {\r\nBT_CONTROL(BT_SMS_ATN);\r\nreturn SI_SM_ATTN;\r\n}\r\nif (status & BT_H_BUSY)\r\nBT_CONTROL(BT_H_BUSY);\r\nif (!bt->BT_CAP_outreqs)\r\nBT_STATE_CHANGE(BT_STATE_CAPABILITIES_BEGIN,\r\nSI_SM_CALL_WITHOUT_DELAY);\r\nbt->timeout = bt->BT_CAP_req2rsp;\r\nBT_SI_SM_RETURN(SI_SM_IDLE);\r\ncase BT_STATE_XACTION_START:\r\nif (status & (BT_B_BUSY | BT_H2B_ATN))\r\nBT_SI_SM_RETURN(SI_SM_CALL_WITH_DELAY);\r\nif (BT_STATUS & BT_H_BUSY)\r\nBT_CONTROL(BT_H_BUSY);\r\nBT_STATE_CHANGE(BT_STATE_WRITE_BYTES,\r\nSI_SM_CALL_WITHOUT_DELAY);\r\ncase BT_STATE_WRITE_BYTES:\r\nif (status & BT_H_BUSY)\r\nBT_CONTROL(BT_H_BUSY);\r\nBT_CONTROL(BT_CLR_WR_PTR);\r\nwrite_all_bytes(bt);\r\nBT_CONTROL(BT_H2B_ATN);\r\nBT_STATE_CHANGE(BT_STATE_WRITE_CONSUME,\r\nSI_SM_CALL_WITHOUT_DELAY);\r\ncase BT_STATE_WRITE_CONSUME:\r\nif (status & (BT_B_BUSY | BT_H2B_ATN))\r\nBT_SI_SM_RETURN(SI_SM_CALL_WITH_DELAY);\r\nBT_STATE_CHANGE(BT_STATE_READ_WAIT,\r\nSI_SM_CALL_WITHOUT_DELAY);\r\ncase BT_STATE_READ_WAIT:\r\nif (!(status & BT_B2H_ATN))\r\nBT_SI_SM_RETURN(SI_SM_CALL_WITH_DELAY);\r\nBT_CONTROL(BT_H_BUSY);\r\nBT_CONTROL(BT_B2H_ATN);\r\nBT_STATE_CHANGE(BT_STATE_CLEAR_B2H,\r\nSI_SM_CALL_WITHOUT_DELAY);\r\ncase BT_STATE_CLEAR_B2H:\r\nif (status & BT_B2H_ATN) {\r\nBT_CONTROL(BT_B2H_ATN);\r\nBT_SI_SM_RETURN(SI_SM_CALL_WITH_DELAY);\r\n}\r\nBT_STATE_CHANGE(BT_STATE_READ_BYTES,\r\nSI_SM_CALL_WITHOUT_DELAY);\r\ncase BT_STATE_READ_BYTES:\r\nif (!(status & BT_H_BUSY))\r\nBT_CONTROL(BT_H_BUSY);\r\nBT_CONTROL(BT_CLR_RD_PTR);\r\ni = read_all_bytes(bt);\r\nBT_CONTROL(BT_H_BUSY);\r\nif (!i)\r\nBT_STATE_CHANGE(BT_STATE_READ_WAIT,\r\nSI_SM_CALL_WITHOUT_DELAY);\r\nbt->state = bt->complete;\r\nreturn bt->state == BT_STATE_IDLE ?\r\nSI_SM_TRANSACTION_COMPLETE :\r\nSI_SM_CALL_WITHOUT_DELAY;\r\ncase BT_STATE_LONG_BUSY:\r\nif (!(status & BT_B_BUSY)) {\r\nreset_flags(bt);\r\nbt_init_data(bt, bt->io);\r\n}\r\nreturn SI_SM_CALL_WITH_DELAY;\r\ncase BT_STATE_RESET1:\r\nreset_flags(bt);\r\ndrain_BMC2HOST(bt);\r\nBT_STATE_CHANGE(BT_STATE_RESET2,\r\nSI_SM_CALL_WITH_DELAY);\r\ncase BT_STATE_RESET2:\r\nBT_CONTROL(BT_CLR_WR_PTR);\r\nHOST2BMC(3);\r\nHOST2BMC(0x18);\r\nHOST2BMC(42);\r\nHOST2BMC(3);\r\nBT_CONTROL(BT_H2B_ATN);\r\nbt->timeout = BT_RESET_DELAY * USEC_PER_SEC;\r\nBT_STATE_CHANGE(BT_STATE_RESET3,\r\nSI_SM_CALL_WITH_DELAY);\r\ncase BT_STATE_RESET3:\r\nif (bt->timeout > 0)\r\nreturn SI_SM_CALL_WITH_DELAY;\r\ndrain_BMC2HOST(bt);\r\nBT_STATE_CHANGE(BT_STATE_RESTART,\r\nSI_SM_CALL_WITH_DELAY);\r\ncase BT_STATE_RESTART:\r\nbt->read_count = 0;\r\nbt->nonzero_status = 0;\r\nbt->timeout = bt->BT_CAP_req2rsp;\r\nBT_STATE_CHANGE(BT_STATE_XACTION_START,\r\nSI_SM_CALL_WITH_DELAY);\r\ncase BT_STATE_CAPABILITIES_BEGIN:\r\nbt->BT_CAP_outreqs = 1;\r\n{\r\nunsigned char GetBT_CAP[] = { 0x18, 0x36 };\r\nbt->state = BT_STATE_IDLE;\r\nbt_start_transaction(bt, GetBT_CAP, sizeof(GetBT_CAP));\r\n}\r\nbt->complete = BT_STATE_CAPABILITIES_END;\r\nBT_STATE_CHANGE(BT_STATE_XACTION_START,\r\nSI_SM_CALL_WITH_DELAY);\r\ncase BT_STATE_CAPABILITIES_END:\r\ni = bt_get_result(bt, BT_CAP, sizeof(BT_CAP));\r\nbt_init_data(bt, bt->io);\r\nif ((i == 8) && !BT_CAP[2]) {\r\nbt->BT_CAP_outreqs = BT_CAP[3];\r\nbt->BT_CAP_req2rsp = BT_CAP[6] * USEC_PER_SEC;\r\nbt->BT_CAP_retries = BT_CAP[7];\r\n} else\r\nprintk(KERN_WARNING "IPMI BT: using default values\n");\r\nif (!bt->BT_CAP_outreqs)\r\nbt->BT_CAP_outreqs = 1;\r\nprintk(KERN_WARNING "IPMI BT: req2rsp=%ld secs retries=%d\n",\r\nbt->BT_CAP_req2rsp / USEC_PER_SEC, bt->BT_CAP_retries);\r\nbt->timeout = bt->BT_CAP_req2rsp;\r\nreturn SI_SM_CALL_WITHOUT_DELAY;\r\ndefault:\r\nreturn error_recovery(bt,\r\nstatus,\r\nIPMI_ERR_UNSPECIFIED);\r\n}\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n}\r\nstatic int bt_detect(struct si_sm_data *bt)\r\n{\r\nif ((BT_STATUS == 0xFF) && (BT_INTMASK_R == 0xFF))\r\nreturn 1;\r\nreset_flags(bt);\r\nreturn 0;\r\n}\r\nstatic void bt_cleanup(struct si_sm_data *bt)\r\n{\r\n}\r\nstatic int bt_size(void)\r\n{\r\nreturn sizeof(struct si_sm_data);\r\n}
