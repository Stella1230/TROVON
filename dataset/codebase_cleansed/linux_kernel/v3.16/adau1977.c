static int adau1977_reset(struct adau1977 *adau1977)\r\n{\r\nint ret;\r\nregcache_cache_bypass(adau1977->regmap, true);\r\nret = regmap_write(adau1977->regmap, ADAU1977_REG_POWER,\r\nADAU1977_POWER_RESET);\r\nregcache_cache_bypass(adau1977->regmap, false);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int adau1977_lookup_fs(unsigned int rate)\r\n{\r\nif (rate >= 8000 && rate <= 12000)\r\nreturn ADAU1977_SAI_CTRL0_FS_8000_12000;\r\nelse if (rate >= 16000 && rate <= 24000)\r\nreturn ADAU1977_SAI_CTRL0_FS_16000_24000;\r\nelse if (rate >= 32000 && rate <= 48000)\r\nreturn ADAU1977_SAI_CTRL0_FS_32000_48000;\r\nelse if (rate >= 64000 && rate <= 96000)\r\nreturn ADAU1977_SAI_CTRL0_FS_64000_96000;\r\nelse if (rate >= 128000 && rate <= 192000)\r\nreturn ADAU1977_SAI_CTRL0_FS_128000_192000;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int adau1977_lookup_mcs(struct adau1977 *adau1977, unsigned int rate,\r\nunsigned int fs)\r\n{\r\nunsigned int mcs;\r\nrate *= 512 >> fs;\r\nif (adau1977->sysclk % rate != 0)\r\nreturn -EINVAL;\r\nmcs = adau1977->sysclk / rate;\r\nif (mcs < 1 || mcs > 6 || mcs == 5)\r\nreturn -EINVAL;\r\nmcs = mcs - 1;\r\nif (mcs == 5)\r\nmcs = 4;\r\nreturn mcs;\r\n}\r\nstatic int adau1977_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adau1977 *adau1977 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int rate = params_rate(params);\r\nunsigned int slot_width;\r\nunsigned int ctrl0, ctrl0_mask;\r\nunsigned int ctrl1;\r\nint mcs, fs;\r\nint ret;\r\nfs = adau1977_lookup_fs(rate);\r\nif (fs < 0)\r\nreturn fs;\r\nif (adau1977->sysclk_src == ADAU1977_SYSCLK_SRC_MCLK) {\r\nmcs = adau1977_lookup_mcs(adau1977, rate, fs);\r\nif (mcs < 0)\r\nreturn mcs;\r\n} else {\r\nmcs = 0;\r\n}\r\nctrl0_mask = ADAU1977_SAI_CTRL0_FS_MASK;\r\nctrl0 = fs;\r\nif (adau1977->right_j) {\r\nswitch (params_width(params)) {\r\ncase 16:\r\nctrl0 |= ADAU1977_SAI_CTRL0_FMT_RJ_16BIT;\r\nbreak;\r\ncase 24:\r\nctrl0 |= ADAU1977_SAI_CTRL0_FMT_RJ_24BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctrl0_mask |= ADAU1977_SAI_CTRL0_FMT_MASK;\r\n}\r\nif (adau1977->master) {\r\nswitch (params_width(params)) {\r\ncase 16:\r\nctrl1 = ADAU1977_SAI_CTRL1_DATA_WIDTH_16BIT;\r\nslot_width = 16;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nctrl1 = ADAU1977_SAI_CTRL1_DATA_WIDTH_24BIT;\r\nslot_width = 32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (adau1977->slot_width)\r\nslot_width = adau1977->slot_width;\r\nif (slot_width == 16)\r\nctrl1 |= ADAU1977_SAI_CTRL1_BCLKRATE_16;\r\nelse\r\nctrl1 |= ADAU1977_SAI_CTRL1_BCLKRATE_32;\r\nret = regmap_update_bits(adau1977->regmap,\r\nADAU1977_REG_SAI_CTRL1,\r\nADAU1977_SAI_CTRL1_DATA_WIDTH_MASK |\r\nADAU1977_SAI_CTRL1_BCLKRATE_MASK,\r\nctrl1);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_CTRL0,\r\nctrl0_mask, ctrl0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_update_bits(adau1977->regmap, ADAU1977_REG_PLL,\r\nADAU1977_PLL_MCS_MASK, mcs);\r\n}\r\nstatic int adau1977_power_disable(struct adau1977 *adau1977)\r\n{\r\nint ret = 0;\r\nif (!adau1977->enabled)\r\nreturn 0;\r\nret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_POWER,\r\nADAU1977_POWER_PWUP, 0);\r\nif (ret)\r\nreturn ret;\r\nregcache_mark_dirty(adau1977->regmap);\r\nif (adau1977->reset_gpio)\r\ngpiod_set_value_cansleep(adau1977->reset_gpio, 0);\r\nregcache_cache_only(adau1977->regmap, true);\r\nregulator_disable(adau1977->avdd_reg);\r\nif (adau1977->dvdd_reg)\r\nregulator_disable(adau1977->dvdd_reg);\r\nadau1977->enabled = false;\r\nreturn 0;\r\n}\r\nstatic int adau1977_power_enable(struct adau1977 *adau1977)\r\n{\r\nunsigned int val;\r\nint ret = 0;\r\nif (adau1977->enabled)\r\nreturn 0;\r\nret = regulator_enable(adau1977->avdd_reg);\r\nif (ret)\r\nreturn ret;\r\nif (adau1977->dvdd_reg) {\r\nret = regulator_enable(adau1977->dvdd_reg);\r\nif (ret)\r\ngoto err_disable_avdd;\r\n}\r\nif (adau1977->reset_gpio)\r\ngpiod_set_value_cansleep(adau1977->reset_gpio, 1);\r\nregcache_cache_only(adau1977->regmap, false);\r\nif (adau1977->switch_mode)\r\nadau1977->switch_mode(adau1977->dev);\r\nret = adau1977_reset(adau1977);\r\nif (ret)\r\ngoto err_disable_dvdd;\r\nret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_POWER,\r\nADAU1977_POWER_PWUP, ADAU1977_POWER_PWUP);\r\nif (ret)\r\ngoto err_disable_dvdd;\r\nret = regcache_sync(adau1977->regmap);\r\nif (ret)\r\ngoto err_disable_dvdd;\r\nret = regmap_read(adau1977->regmap, ADAU1977_REG_PLL, &val);\r\nif (ret)\r\ngoto err_disable_dvdd;\r\nif (val == 0x41) {\r\nregcache_cache_bypass(adau1977->regmap, true);\r\nret = regmap_write(adau1977->regmap, ADAU1977_REG_PLL,\r\n0x41);\r\nif (ret)\r\ngoto err_disable_dvdd;\r\nregcache_cache_bypass(adau1977->regmap, false);\r\n}\r\nadau1977->enabled = true;\r\nreturn ret;\r\nerr_disable_dvdd:\r\nif (adau1977->dvdd_reg)\r\nregulator_disable(adau1977->dvdd_reg);\r\nerr_disable_avdd:\r\nregulator_disable(adau1977->avdd_reg);\r\nreturn ret;\r\n}\r\nstatic int adau1977_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct adau1977 *adau1977 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF)\r\nret = adau1977_power_enable(adau1977);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nret = adau1977_power_disable(adau1977);\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int adau1977_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int width)\r\n{\r\nstruct adau1977 *adau1977 = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int ctrl0, ctrl1, drv;\r\nunsigned int slot[4];\r\nunsigned int i;\r\nint ret;\r\nif (slots == 0) {\r\nadau1977->slot_width = 0;\r\nadau1977->max_master_fs = 192000;\r\nreturn regmap_update_bits(adau1977->regmap,\r\nADAU1977_REG_SAI_CTRL0, ADAU1977_SAI_CTRL0_SAI_MASK,\r\nADAU1977_SAI_CTRL0_SAI_I2S);\r\n}\r\nif (rx_mask == 0 || tx_mask != 0)\r\nreturn -EINVAL;\r\ndrv = 0;\r\nfor (i = 0; i < 4; i++) {\r\nslot[i] = __ffs(rx_mask);\r\ndrv |= ADAU1977_SAI_OVERTEMP_DRV_C(i);\r\nrx_mask &= ~(1 << slot[i]);\r\nif (slot[i] >= slots)\r\nreturn -EINVAL;\r\nif (rx_mask == 0)\r\nbreak;\r\n}\r\nif (rx_mask != 0)\r\nreturn -EINVAL;\r\nswitch (width) {\r\ncase 16:\r\nctrl1 = ADAU1977_SAI_CTRL1_SLOT_WIDTH_16;\r\nbreak;\r\ncase 24:\r\nif (adau1977->master)\r\nreturn -EINVAL;\r\nctrl1 = ADAU1977_SAI_CTRL1_SLOT_WIDTH_24;\r\nbreak;\r\ncase 32:\r\nctrl1 = ADAU1977_SAI_CTRL1_SLOT_WIDTH_32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (slots) {\r\ncase 2:\r\nctrl0 = ADAU1977_SAI_CTRL0_SAI_TDM_2;\r\nbreak;\r\ncase 4:\r\nctrl0 = ADAU1977_SAI_CTRL0_SAI_TDM_4;\r\nbreak;\r\ncase 8:\r\nctrl0 = ADAU1977_SAI_CTRL0_SAI_TDM_8;\r\nbreak;\r\ncase 16:\r\nctrl0 = ADAU1977_SAI_CTRL0_SAI_TDM_16;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_OVERTEMP,\r\nADAU1977_SAI_OVERTEMP_DRV_C(0) |\r\nADAU1977_SAI_OVERTEMP_DRV_C(1) |\r\nADAU1977_SAI_OVERTEMP_DRV_C(2) |\r\nADAU1977_SAI_OVERTEMP_DRV_C(3), drv);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(adau1977->regmap, ADAU1977_REG_CMAP12,\r\n(slot[1] << ADAU1977_CHAN_MAP_SECOND_SLOT_OFFSET) |\r\n(slot[0] << ADAU1977_CHAN_MAP_FIRST_SLOT_OFFSET));\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(adau1977->regmap, ADAU1977_REG_CMAP34,\r\n(slot[3] << ADAU1977_CHAN_MAP_SECOND_SLOT_OFFSET) |\r\n(slot[2] << ADAU1977_CHAN_MAP_FIRST_SLOT_OFFSET));\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_CTRL0,\r\nADAU1977_SAI_CTRL0_SAI_MASK, ctrl0);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_CTRL1,\r\nADAU1977_SAI_CTRL1_SLOT_WIDTH_MASK, ctrl1);\r\nif (ret)\r\nreturn ret;\r\nadau1977->slot_width = width;\r\nadau1977->max_master_fs = min(192000, 24576000 / width / slots);\r\nreturn 0;\r\n}\r\nstatic int adau1977_mute(struct snd_soc_dai *dai, int mute, int stream)\r\n{\r\nstruct adau1977 *adau1977 = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int val;\r\nif (mute)\r\nval = ADAU1977_MISC_CONTROL_MMUTE;\r\nelse\r\nval = 0;\r\nreturn regmap_update_bits(adau1977->regmap, ADAU1977_REG_MISC_CONTROL,\r\nADAU1977_MISC_CONTROL_MMUTE, val);\r\n}\r\nstatic int adau1977_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct adau1977 *adau1977 = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int ctrl0 = 0, ctrl1 = 0, block_power = 0;\r\nbool invert_lrclk;\r\nint ret;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nadau1977->master = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nctrl1 |= ADAU1977_SAI_CTRL1_MASTER;\r\nadau1977->master = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ninvert_lrclk = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nblock_power |= ADAU1977_BLOCK_POWER_SAI_BCLK_EDGE;\r\ninvert_lrclk = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ninvert_lrclk = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nblock_power |= ADAU1977_BLOCK_POWER_SAI_BCLK_EDGE;\r\ninvert_lrclk = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadau1977->right_j = false;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nctrl0 |= ADAU1977_SAI_CTRL0_FMT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nctrl0 |= ADAU1977_SAI_CTRL0_FMT_LJ;\r\ninvert_lrclk = !invert_lrclk;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nctrl0 |= ADAU1977_SAI_CTRL0_FMT_RJ_24BIT;\r\nadau1977->right_j = true;\r\ninvert_lrclk = !invert_lrclk;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nctrl1 |= ADAU1977_SAI_CTRL1_LRCLK_PULSE;\r\nctrl0 |= ADAU1977_SAI_CTRL0_FMT_I2S;\r\ninvert_lrclk = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nctrl1 |= ADAU1977_SAI_CTRL1_LRCLK_PULSE;\r\nctrl0 |= ADAU1977_SAI_CTRL0_FMT_LJ;\r\ninvert_lrclk = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (invert_lrclk)\r\nblock_power |= ADAU1977_BLOCK_POWER_SAI_LR_POL;\r\nret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_BLOCK_POWER_SAI,\r\nADAU1977_BLOCK_POWER_SAI_LR_POL |\r\nADAU1977_BLOCK_POWER_SAI_BCLK_EDGE, block_power);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_CTRL0,\r\nADAU1977_SAI_CTRL0_FMT_MASK,\r\nctrl0);\r\nif (ret)\r\nreturn ret;\r\nreturn regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_CTRL1,\r\nADAU1977_SAI_CTRL1_MASTER | ADAU1977_SAI_CTRL1_LRCLK_PULSE,\r\nctrl1);\r\n}\r\nstatic int adau1977_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct adau1977 *adau1977 = snd_soc_codec_get_drvdata(dai->codec);\r\nu64 formats = 0;\r\nif (adau1977->slot_width == 16)\r\nformats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE;\r\nelse if (adau1977->right_j || adau1977->slot_width == 24)\r\nformats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE |\r\nSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_BE;\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &adau1977->constraints);\r\nif (adau1977->master)\r\nsnd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE, 8000, adau1977->max_master_fs);\r\nif (formats != 0)\r\nsnd_pcm_hw_constraint_mask64(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_FORMAT, formats);\r\nreturn 0;\r\n}\r\nstatic int adau1977_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct adau1977 *adau1977 = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int val;\r\nif (tristate)\r\nval = ADAU1977_SAI_OVERTEMP_DRV_HIZ;\r\nelse\r\nval = 0;\r\nreturn regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_OVERTEMP,\r\nADAU1977_SAI_OVERTEMP_DRV_HIZ, val);\r\n}\r\nstatic bool adau1977_check_sysclk(unsigned int mclk, unsigned int base_freq)\r\n{\r\nunsigned int mcs;\r\nif (mclk % (base_freq * 128) != 0)\r\nreturn false;\r\nmcs = mclk / (128 * base_freq);\r\nif (mcs < 1 || mcs > 6 || mcs == 5)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int adau1977_set_sysclk(struct snd_soc_codec *codec,\r\nint clk_id, int source, unsigned int freq, int dir)\r\n{\r\nstruct adau1977 *adau1977 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int mask = 0;\r\nunsigned int clk_src;\r\nunsigned int ret;\r\nif (dir != SND_SOC_CLOCK_IN)\r\nreturn -EINVAL;\r\nif (clk_id != ADAU1977_SYSCLK)\r\nreturn -EINVAL;\r\nswitch (source) {\r\ncase ADAU1977_SYSCLK_SRC_MCLK:\r\nclk_src = 0;\r\nbreak;\r\ncase ADAU1977_SYSCLK_SRC_LRCLK:\r\nclk_src = ADAU1977_PLL_CLK_S;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (freq != 0 && source == ADAU1977_SYSCLK_SRC_MCLK) {\r\nif (freq < 4000000 || freq > 36864000)\r\nreturn -EINVAL;\r\nif (adau1977_check_sysclk(freq, 32000))\r\nmask |= ADAU1977_RATE_CONSTRAINT_MASK_32000;\r\nif (adau1977_check_sysclk(freq, 44100))\r\nmask |= ADAU1977_RATE_CONSTRAINT_MASK_44100;\r\nif (adau1977_check_sysclk(freq, 48000))\r\nmask |= ADAU1977_RATE_CONSTRAINT_MASK_48000;\r\nif (mask == 0)\r\nreturn -EINVAL;\r\n} else if (source == ADAU1977_SYSCLK_SRC_LRCLK) {\r\nmask = ADAU1977_RATE_CONSTRAINT_MASK_LRCLK;\r\n}\r\nret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_PLL,\r\nADAU1977_PLL_CLK_S, clk_src);\r\nif (ret)\r\nreturn ret;\r\nadau1977->constraints.mask = mask;\r\nadau1977->sysclk_src = source;\r\nadau1977->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int adau1977_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct adau1977 *adau1977 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (adau1977->type) {\r\ncase ADAU1977:\r\nret = snd_soc_dapm_new_controls(&codec->dapm,\r\nadau1977_micbias_dapm_widgets,\r\nARRAY_SIZE(adau1977_micbias_dapm_widgets));\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adau1977_setup_micbias(struct adau1977 *adau1977)\r\n{\r\nstruct adau1977_platform_data *pdata = adau1977->dev->platform_data;\r\nunsigned int micbias;\r\nif (pdata) {\r\nmicbias = pdata->micbias;\r\nif (micbias > ADAU1977_MICBIAS_9V0)\r\nreturn -EINVAL;\r\n} else {\r\nmicbias = ADAU1977_MICBIAS_8V5;\r\n}\r\nreturn regmap_update_bits(adau1977->regmap, ADAU1977_REG_MICBIAS,\r\nADAU1977_MICBIAS_MB_VOLTS_MASK,\r\nmicbias << ADAU1977_MICBIAS_MB_VOLTS_OFFSET);\r\n}\r\nint adau1977_probe(struct device *dev, struct regmap *regmap,\r\nenum adau1977_type type, void (*switch_mode)(struct device *dev))\r\n{\r\nunsigned int power_off_mask;\r\nstruct adau1977 *adau1977;\r\nint ret;\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nadau1977 = devm_kzalloc(dev, sizeof(*adau1977), GFP_KERNEL);\r\nif (adau1977 == NULL)\r\nreturn -ENOMEM;\r\nadau1977->dev = dev;\r\nadau1977->type = type;\r\nadau1977->regmap = regmap;\r\nadau1977->switch_mode = switch_mode;\r\nadau1977->max_master_fs = 192000;\r\nadau1977->constraints.list = adau1977_rates;\r\nadau1977->constraints.count = ARRAY_SIZE(adau1977_rates);\r\nadau1977->avdd_reg = devm_regulator_get(dev, "AVDD");\r\nif (IS_ERR(adau1977->avdd_reg))\r\nreturn PTR_ERR(adau1977->avdd_reg);\r\nadau1977->dvdd_reg = devm_regulator_get_optional(dev, "DVDD");\r\nif (IS_ERR(adau1977->dvdd_reg)) {\r\nif (PTR_ERR(adau1977->dvdd_reg) != -ENODEV)\r\nreturn PTR_ERR(adau1977->dvdd_reg);\r\nadau1977->dvdd_reg = NULL;\r\n}\r\nadau1977->reset_gpio = devm_gpiod_get(dev, "reset");\r\nif (IS_ERR(adau1977->reset_gpio)) {\r\nret = PTR_ERR(adau1977->reset_gpio);\r\nif (ret != -ENOENT && ret != -ENOSYS)\r\nreturn PTR_ERR(adau1977->reset_gpio);\r\nadau1977->reset_gpio = NULL;\r\n}\r\ndev_set_drvdata(dev, adau1977);\r\nif (adau1977->reset_gpio) {\r\nret = gpiod_direction_output(adau1977->reset_gpio, 0);\r\nif (ret)\r\nreturn ret;\r\nndelay(100);\r\n}\r\nret = adau1977_power_enable(adau1977);\r\nif (ret)\r\nreturn ret;\r\nif (type == ADAU1977) {\r\nret = adau1977_setup_micbias(adau1977);\r\nif (ret)\r\ngoto err_poweroff;\r\n}\r\nif (adau1977->dvdd_reg)\r\npower_off_mask = ~0;\r\nelse\r\npower_off_mask = ~ADAU1977_BLOCK_POWER_SAI_LDO_EN;\r\nret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_BLOCK_POWER_SAI,\r\npower_off_mask, 0x00);\r\nif (ret)\r\ngoto err_poweroff;\r\nret = adau1977_power_disable(adau1977);\r\nif (ret)\r\nreturn ret;\r\nreturn snd_soc_register_codec(dev, &adau1977_codec_driver,\r\n&adau1977_dai, 1);\r\nerr_poweroff:\r\nadau1977_power_disable(adau1977);\r\nreturn ret;\r\n}\r\nstatic bool adau1977_register_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ADAU1977_REG_STATUS(0):\r\ncase ADAU1977_REG_STATUS(1):\r\ncase ADAU1977_REG_STATUS(2):\r\ncase ADAU1977_REG_STATUS(3):\r\ncase ADAU1977_REG_ADC_CLIP:\r\nreturn true;\r\n}\r\nreturn false;\r\n}
