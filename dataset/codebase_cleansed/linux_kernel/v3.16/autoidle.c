static void ti_allow_autoidle(struct clk_ti_autoidle *clk)\r\n{\r\nu32 val;\r\nval = ti_clk_ll_ops->clk_readl(clk->reg);\r\nif (clk->flags & AUTOIDLE_LOW)\r\nval &= ~(1 << clk->shift);\r\nelse\r\nval |= (1 << clk->shift);\r\nti_clk_ll_ops->clk_writel(val, clk->reg);\r\n}\r\nstatic void ti_deny_autoidle(struct clk_ti_autoidle *clk)\r\n{\r\nu32 val;\r\nval = ti_clk_ll_ops->clk_readl(clk->reg);\r\nif (clk->flags & AUTOIDLE_LOW)\r\nval |= (1 << clk->shift);\r\nelse\r\nval &= ~(1 << clk->shift);\r\nti_clk_ll_ops->clk_writel(val, clk->reg);\r\n}\r\nvoid of_ti_clk_allow_autoidle_all(void)\r\n{\r\nstruct clk_ti_autoidle *c;\r\nlist_for_each_entry(c, &autoidle_clks, node)\r\nti_allow_autoidle(c);\r\n}\r\nvoid of_ti_clk_deny_autoidle_all(void)\r\n{\r\nstruct clk_ti_autoidle *c;\r\nlist_for_each_entry(c, &autoidle_clks, node)\r\nti_deny_autoidle(c);\r\n}\r\nint __init of_ti_clk_autoidle_setup(struct device_node *node)\r\n{\r\nu32 shift;\r\nstruct clk_ti_autoidle *clk;\r\nif (of_property_read_u32(node, "ti,autoidle-shift", &shift))\r\nreturn 0;\r\nclk = kzalloc(sizeof(*clk), GFP_KERNEL);\r\nif (!clk)\r\nreturn -ENOMEM;\r\nclk->shift = shift;\r\nclk->name = node->name;\r\nclk->reg = ti_clk_get_reg_addr(node, 0);\r\nif (!clk->reg) {\r\nkfree(clk);\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_bool(node, "ti,invert-autoidle-bit"))\r\nclk->flags |= AUTOIDLE_LOW;\r\nlist_add(&clk->node, &autoidle_clks);\r\nreturn 0;\r\n}
