static int send_hcill_cmd(u8 cmd, struct hci_uart *hu)\r\n{\r\nint err = 0;\r\nstruct sk_buff *skb = NULL;\r\nstruct ll_struct *ll = hu->priv;\r\nstruct hcill_cmd *hcill_packet;\r\nBT_DBG("hu %p cmd 0x%x", hu, cmd);\r\nskb = bt_skb_alloc(1, GFP_ATOMIC);\r\nif (!skb) {\r\nBT_ERR("cannot allocate memory for HCILL packet");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nhcill_packet = (struct hcill_cmd *) skb_put(skb, 1);\r\nhcill_packet->cmd = cmd;\r\nskb_queue_tail(&ll->txq, skb);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ll_open(struct hci_uart *hu)\r\n{\r\nstruct ll_struct *ll;\r\nBT_DBG("hu %p", hu);\r\nll = kzalloc(sizeof(*ll), GFP_KERNEL);\r\nif (!ll)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&ll->txq);\r\nskb_queue_head_init(&ll->tx_wait_q);\r\nspin_lock_init(&ll->hcill_lock);\r\nll->hcill_state = HCILL_AWAKE;\r\nhu->priv = ll;\r\nreturn 0;\r\n}\r\nstatic int ll_flush(struct hci_uart *hu)\r\n{\r\nstruct ll_struct *ll = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&ll->tx_wait_q);\r\nskb_queue_purge(&ll->txq);\r\nreturn 0;\r\n}\r\nstatic int ll_close(struct hci_uart *hu)\r\n{\r\nstruct ll_struct *ll = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&ll->tx_wait_q);\r\nskb_queue_purge(&ll->txq);\r\nkfree_skb(ll->rx_skb);\r\nhu->priv = NULL;\r\nkfree(ll);\r\nreturn 0;\r\n}\r\nstatic void __ll_do_awake(struct ll_struct *ll)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nwhile ((skb = skb_dequeue(&ll->tx_wait_q)))\r\nskb_queue_tail(&ll->txq, skb);\r\nll->hcill_state = HCILL_AWAKE;\r\n}\r\nstatic void ll_device_want_to_wakeup(struct hci_uart *hu)\r\n{\r\nunsigned long flags;\r\nstruct ll_struct *ll = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nspin_lock_irqsave(&ll->hcill_lock, flags);\r\nswitch (ll->hcill_state) {\r\ncase HCILL_ASLEEP_TO_AWAKE:\r\nBT_DBG("dual wake-up-indication");\r\ncase HCILL_ASLEEP:\r\nif (send_hcill_cmd(HCILL_WAKE_UP_ACK, hu) < 0) {\r\nBT_ERR("cannot acknowledge device wake up");\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\nBT_ERR("received HCILL_WAKE_UP_IND in state %ld", ll->hcill_state);\r\nbreak;\r\n}\r\n__ll_do_awake(ll);\r\nout:\r\nspin_unlock_irqrestore(&ll->hcill_lock, flags);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic void ll_device_want_to_sleep(struct hci_uart *hu)\r\n{\r\nunsigned long flags;\r\nstruct ll_struct *ll = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nspin_lock_irqsave(&ll->hcill_lock, flags);\r\nif (ll->hcill_state != HCILL_AWAKE)\r\nBT_ERR("ERR: HCILL_GO_TO_SLEEP_IND in state %ld", ll->hcill_state);\r\nif (send_hcill_cmd(HCILL_GO_TO_SLEEP_ACK, hu) < 0) {\r\nBT_ERR("cannot acknowledge device sleep");\r\ngoto out;\r\n}\r\nll->hcill_state = HCILL_ASLEEP;\r\nout:\r\nspin_unlock_irqrestore(&ll->hcill_lock, flags);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic void ll_device_woke_up(struct hci_uart *hu)\r\n{\r\nunsigned long flags;\r\nstruct ll_struct *ll = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nspin_lock_irqsave(&ll->hcill_lock, flags);\r\nif (ll->hcill_state != HCILL_ASLEEP_TO_AWAKE)\r\nBT_ERR("received HCILL_WAKE_UP_ACK in state %ld", ll->hcill_state);\r\n__ll_do_awake(ll);\r\nspin_unlock_irqrestore(&ll->hcill_lock, flags);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic int ll_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nunsigned long flags = 0;\r\nstruct ll_struct *ll = hu->priv;\r\nBT_DBG("hu %p skb %p", hu, skb);\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\nspin_lock_irqsave(&ll->hcill_lock, flags);\r\nswitch (ll->hcill_state) {\r\ncase HCILL_AWAKE:\r\nBT_DBG("device awake, sending normally");\r\nskb_queue_tail(&ll->txq, skb);\r\nbreak;\r\ncase HCILL_ASLEEP:\r\nBT_DBG("device asleep, waking up and queueing packet");\r\nskb_queue_tail(&ll->tx_wait_q, skb);\r\nif (send_hcill_cmd(HCILL_WAKE_UP_IND, hu) < 0) {\r\nBT_ERR("cannot wake up device");\r\nbreak;\r\n}\r\nll->hcill_state = HCILL_ASLEEP_TO_AWAKE;\r\nbreak;\r\ncase HCILL_ASLEEP_TO_AWAKE:\r\nBT_DBG("device waking up, queueing packet");\r\nskb_queue_tail(&ll->tx_wait_q, skb);\r\nbreak;\r\ndefault:\r\nBT_ERR("illegal hcill state: %ld (losing packet)", ll->hcill_state);\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ll->hcill_lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline int ll_check_data_len(struct hci_dev *hdev, struct ll_struct *ll, int len)\r\n{\r\nint room = skb_tailroom(ll->rx_skb);\r\nBT_DBG("len %d room %d", len, room);\r\nif (!len) {\r\nhci_recv_frame(hdev, ll->rx_skb);\r\n} else if (len > room) {\r\nBT_ERR("Data length is too large");\r\nkfree_skb(ll->rx_skb);\r\n} else {\r\nll->rx_state = HCILL_W4_DATA;\r\nll->rx_count = len;\r\nreturn len;\r\n}\r\nll->rx_state = HCILL_W4_PACKET_TYPE;\r\nll->rx_skb = NULL;\r\nll->rx_count = 0;\r\nreturn 0;\r\n}\r\nstatic int ll_recv(struct hci_uart *hu, void *data, int count)\r\n{\r\nstruct ll_struct *ll = hu->priv;\r\nchar *ptr;\r\nstruct hci_event_hdr *eh;\r\nstruct hci_acl_hdr *ah;\r\nstruct hci_sco_hdr *sh;\r\nint len, type, dlen;\r\nBT_DBG("hu %p count %d rx_state %ld rx_count %ld", hu, count, ll->rx_state, ll->rx_count);\r\nptr = data;\r\nwhile (count) {\r\nif (ll->rx_count) {\r\nlen = min_t(unsigned int, ll->rx_count, count);\r\nmemcpy(skb_put(ll->rx_skb, len), ptr, len);\r\nll->rx_count -= len; count -= len; ptr += len;\r\nif (ll->rx_count)\r\ncontinue;\r\nswitch (ll->rx_state) {\r\ncase HCILL_W4_DATA:\r\nBT_DBG("Complete data");\r\nhci_recv_frame(hu->hdev, ll->rx_skb);\r\nll->rx_state = HCILL_W4_PACKET_TYPE;\r\nll->rx_skb = NULL;\r\ncontinue;\r\ncase HCILL_W4_EVENT_HDR:\r\neh = hci_event_hdr(ll->rx_skb);\r\nBT_DBG("Event header: evt 0x%2.2x plen %d", eh->evt, eh->plen);\r\nll_check_data_len(hu->hdev, ll, eh->plen);\r\ncontinue;\r\ncase HCILL_W4_ACL_HDR:\r\nah = hci_acl_hdr(ll->rx_skb);\r\ndlen = __le16_to_cpu(ah->dlen);\r\nBT_DBG("ACL header: dlen %d", dlen);\r\nll_check_data_len(hu->hdev, ll, dlen);\r\ncontinue;\r\ncase HCILL_W4_SCO_HDR:\r\nsh = hci_sco_hdr(ll->rx_skb);\r\nBT_DBG("SCO header: dlen %d", sh->dlen);\r\nll_check_data_len(hu->hdev, ll, sh->dlen);\r\ncontinue;\r\n}\r\n}\r\nswitch (*ptr) {\r\ncase HCI_EVENT_PKT:\r\nBT_DBG("Event packet");\r\nll->rx_state = HCILL_W4_EVENT_HDR;\r\nll->rx_count = HCI_EVENT_HDR_SIZE;\r\ntype = HCI_EVENT_PKT;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nBT_DBG("ACL packet");\r\nll->rx_state = HCILL_W4_ACL_HDR;\r\nll->rx_count = HCI_ACL_HDR_SIZE;\r\ntype = HCI_ACLDATA_PKT;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nBT_DBG("SCO packet");\r\nll->rx_state = HCILL_W4_SCO_HDR;\r\nll->rx_count = HCI_SCO_HDR_SIZE;\r\ntype = HCI_SCODATA_PKT;\r\nbreak;\r\ncase HCILL_GO_TO_SLEEP_IND:\r\nBT_DBG("HCILL_GO_TO_SLEEP_IND packet");\r\nll_device_want_to_sleep(hu);\r\nptr++; count--;\r\ncontinue;\r\ncase HCILL_GO_TO_SLEEP_ACK:\r\nBT_ERR("received HCILL_GO_TO_SLEEP_ACK (in state %ld)", ll->hcill_state);\r\nptr++; count--;\r\ncontinue;\r\ncase HCILL_WAKE_UP_IND:\r\nBT_DBG("HCILL_WAKE_UP_IND packet");\r\nll_device_want_to_wakeup(hu);\r\nptr++; count--;\r\ncontinue;\r\ncase HCILL_WAKE_UP_ACK:\r\nBT_DBG("HCILL_WAKE_UP_ACK packet");\r\nll_device_woke_up(hu);\r\nptr++; count--;\r\ncontinue;\r\ndefault:\r\nBT_ERR("Unknown HCI packet type %2.2x", (__u8)*ptr);\r\nhu->hdev->stat.err_rx++;\r\nptr++; count--;\r\ncontinue;\r\n}\r\nptr++; count--;\r\nll->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);\r\nif (!ll->rx_skb) {\r\nBT_ERR("Can't allocate mem for new packet");\r\nll->rx_state = HCILL_W4_PACKET_TYPE;\r\nll->rx_count = 0;\r\nreturn -ENOMEM;\r\n}\r\nbt_cb(ll->rx_skb)->pkt_type = type;\r\n}\r\nreturn count;\r\n}\r\nstatic struct sk_buff *ll_dequeue(struct hci_uart *hu)\r\n{\r\nstruct ll_struct *ll = hu->priv;\r\nreturn skb_dequeue(&ll->txq);\r\n}\r\nint __init ll_init(void)\r\n{\r\nint err = hci_uart_register_proto(&llp);\r\nif (!err)\r\nBT_INFO("HCILL protocol initialized");\r\nelse\r\nBT_ERR("HCILL protocol registration failed");\r\nreturn err;\r\n}\r\nint __exit ll_deinit(void)\r\n{\r\nreturn hci_uart_unregister_proto(&llp);\r\n}
