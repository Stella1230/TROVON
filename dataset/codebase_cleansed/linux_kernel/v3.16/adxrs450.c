static int adxrs450_spi_read_reg_16(struct iio_dev *indio_dev,\r\nu8 reg_address,\r\nu16 *val)\r\n{\r\nstruct adxrs450_state *st = iio_priv(indio_dev);\r\nu32 tx;\r\nint ret;\r\nstruct spi_transfer xfers[] = {\r\n{\r\n.tx_buf = &st->tx,\r\n.bits_per_word = 8,\r\n.len = sizeof(st->tx),\r\n.cs_change = 1,\r\n}, {\r\n.rx_buf = &st->rx,\r\n.bits_per_word = 8,\r\n.len = sizeof(st->rx),\r\n},\r\n};\r\nmutex_lock(&st->buf_lock);\r\ntx = ADXRS450_READ_DATA | (reg_address << 17);\r\nif (!(hweight32(tx) & 1))\r\ntx |= ADXRS450_P;\r\nst->tx = cpu_to_be32(tx);\r\nret = spi_sync_transfer(st->us, xfers, ARRAY_SIZE(xfers));\r\nif (ret) {\r\ndev_err(&st->us->dev, "problem while reading 16 bit register 0x%02x\n",\r\nreg_address);\r\ngoto error_ret;\r\n}\r\n*val = (be32_to_cpu(st->rx) >> 5) & 0xFFFF;\r\nerror_ret:\r\nmutex_unlock(&st->buf_lock);\r\nreturn ret;\r\n}\r\nstatic int adxrs450_spi_write_reg_16(struct iio_dev *indio_dev,\r\nu8 reg_address,\r\nu16 val)\r\n{\r\nstruct adxrs450_state *st = iio_priv(indio_dev);\r\nu32 tx;\r\nint ret;\r\nmutex_lock(&st->buf_lock);\r\ntx = ADXRS450_WRITE_DATA | (reg_address << 17) | (val << 1);\r\nif (!(hweight32(tx) & 1))\r\ntx |= ADXRS450_P;\r\nst->tx = cpu_to_be32(tx);\r\nret = spi_write(st->us, &st->tx, sizeof(st->tx));\r\nif (ret)\r\ndev_err(&st->us->dev, "problem while writing 16 bit register 0x%02x\n",\r\nreg_address);\r\nusleep_range(100, 1000);\r\nmutex_unlock(&st->buf_lock);\r\nreturn ret;\r\n}\r\nstatic int adxrs450_spi_sensor_data(struct iio_dev *indio_dev, s16 *val)\r\n{\r\nstruct adxrs450_state *st = iio_priv(indio_dev);\r\nint ret;\r\nstruct spi_transfer xfers[] = {\r\n{\r\n.tx_buf = &st->tx,\r\n.bits_per_word = 8,\r\n.len = sizeof(st->tx),\r\n.cs_change = 1,\r\n}, {\r\n.rx_buf = &st->rx,\r\n.bits_per_word = 8,\r\n.len = sizeof(st->rx),\r\n},\r\n};\r\nmutex_lock(&st->buf_lock);\r\nst->tx = cpu_to_be32(ADXRS450_SENSOR_DATA);\r\nret = spi_sync_transfer(st->us, xfers, ARRAY_SIZE(xfers));\r\nif (ret) {\r\ndev_err(&st->us->dev, "Problem while reading sensor data\n");\r\ngoto error_ret;\r\n}\r\n*val = (be32_to_cpu(st->rx) >> 10) & 0xFFFF;\r\nerror_ret:\r\nmutex_unlock(&st->buf_lock);\r\nreturn ret;\r\n}\r\nstatic int adxrs450_spi_initial(struct adxrs450_state *st,\r\nu32 *val, char chk)\r\n{\r\nint ret;\r\nu32 tx;\r\nstruct spi_transfer xfers = {\r\n.tx_buf = &st->tx,\r\n.rx_buf = &st->rx,\r\n.bits_per_word = 8,\r\n.len = sizeof(st->tx),\r\n};\r\nmutex_lock(&st->buf_lock);\r\ntx = ADXRS450_SENSOR_DATA;\r\nif (chk)\r\ntx |= (ADXRS450_CHK | ADXRS450_P);\r\nst->tx = cpu_to_be32(tx);\r\nret = spi_sync_transfer(st->us, &xfers, 1);\r\nif (ret) {\r\ndev_err(&st->us->dev, "Problem while reading initializing data\n");\r\ngoto error_ret;\r\n}\r\n*val = be32_to_cpu(st->rx);\r\nerror_ret:\r\nmutex_unlock(&st->buf_lock);\r\nreturn ret;\r\n}\r\nstatic int adxrs450_initial_setup(struct iio_dev *indio_dev)\r\n{\r\nu32 t;\r\nu16 data;\r\nint ret;\r\nstruct adxrs450_state *st = iio_priv(indio_dev);\r\nmsleep(ADXRS450_STARTUP_DELAY*2);\r\nret = adxrs450_spi_initial(st, &t, 1);\r\nif (ret)\r\nreturn ret;\r\nif (t != 0x01)\r\ndev_warn(&st->us->dev, "The initial power on response is not correct! Restart without reset?\n");\r\nmsleep(ADXRS450_STARTUP_DELAY);\r\nret = adxrs450_spi_initial(st, &t, 0);\r\nif (ret)\r\nreturn ret;\r\nmsleep(ADXRS450_STARTUP_DELAY);\r\nret = adxrs450_spi_initial(st, &t, 0);\r\nif (ret)\r\nreturn ret;\r\nif (((t & 0xff) | 0x01) != 0xff || ADXRS450_GET_ST(t) != 2) {\r\ndev_err(&st->us->dev, "The second response is not correct!\n");\r\nreturn -EIO;\r\n}\r\nret = adxrs450_spi_initial(st, &t, 0);\r\nif (ret)\r\nreturn ret;\r\nif (((t & 0xff) | 0x01) != 0xff || ADXRS450_GET_ST(t) != 2) {\r\ndev_err(&st->us->dev, "The third response is not correct!\n");\r\nreturn -EIO;\r\n}\r\nret = adxrs450_spi_read_reg_16(indio_dev, ADXRS450_FAULT1, &data);\r\nif (ret)\r\nreturn ret;\r\nif (data & 0x0fff) {\r\ndev_err(&st->us->dev, "The device is not in normal status!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adxrs450_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nif (val < -0x400 || val >= 0x400)\r\nreturn -EINVAL;\r\nret = adxrs450_spi_write_reg_16(indio_dev,\r\nADXRS450_DNC1, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int adxrs450_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nint ret;\r\ns16 t;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\nret = adxrs450_spi_sensor_data(indio_dev, &t);\r\nif (ret)\r\nbreak;\r\n*val = t;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_TEMP:\r\nret = adxrs450_spi_read_reg_16(indio_dev,\r\nADXRS450_TEMP1, &t);\r\nif (ret)\r\nbreak;\r\n*val = (t >> 6) + 225;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\n*val = 0;\r\n*val2 = 218166;\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_TEMP:\r\n*val = 200;\r\n*val2 = 0;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW:\r\nret = adxrs450_spi_read_reg_16(indio_dev, ADXRS450_QUAD1, &t);\r\nif (ret)\r\nbreak;\r\n*val = t;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nret = adxrs450_spi_read_reg_16(indio_dev, ADXRS450_DNC1, &t);\r\nif (ret)\r\nbreak;\r\n*val = sign_extend32(t, 9);\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int adxrs450_probe(struct spi_device *spi)\r\n{\r\nint ret;\r\nstruct adxrs450_state *st;\r\nstruct iio_dev *indio_dev;\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nst->us = spi;\r\nmutex_init(&st->buf_lock);\r\nspi_set_drvdata(spi, indio_dev);\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->info = &adxrs450_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels =\r\nadxrs450_channels[spi_get_device_id(spi)->driver_data];\r\nindio_dev->num_channels = ARRAY_SIZE(adxrs450_channels);\r\nindio_dev->name = spi->dev.driver->name;\r\nret = devm_iio_device_register(&spi->dev, indio_dev);\r\nif (ret)\r\nreturn ret;\r\nret = adxrs450_initial_setup(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
