static int power5p_get_constraint(u64 event, unsigned long *maskp,\r\nunsigned long *valp)\r\n{\r\nint pmc, byte, unit, sh;\r\nint bit, fmask;\r\nunsigned long mask = 0, value = 0;\r\npmc = (event >> PM_PMC_SH) & PM_PMC_MSK;\r\nif (pmc) {\r\nif (pmc > 6)\r\nreturn -1;\r\nsh = (pmc - 1) * 2;\r\nmask |= 2 << sh;\r\nvalue |= 1 << sh;\r\nif (pmc >= 5 && !(event == 0x500009 || event == 0x600005))\r\nreturn -1;\r\n}\r\nif (event & PM_BUSEVENT_MSK) {\r\nunit = (event >> PM_UNIT_SH) & PM_UNIT_MSK;\r\nif (unit > PM_LASTUNIT)\r\nreturn -1;\r\nif (unit == PM_ISU0_ALT)\r\nunit = PM_ISU0;\r\nmask |= unit_cons[unit][0];\r\nvalue |= unit_cons[unit][1];\r\nbyte = (event >> PM_BYTE_SH) & PM_BYTE_MSK;\r\nif (byte >= 4) {\r\nif (unit != PM_LSU1)\r\nreturn -1;\r\n++unit;\r\nbyte &= 3;\r\n}\r\nif (unit == PM_GRS) {\r\nbit = event & 7;\r\nfmask = (bit == 6)? 7: 3;\r\nsh = grsel_shift[bit];\r\nmask |= (unsigned long)fmask << sh;\r\nvalue |= (unsigned long)((event >> PM_GRS_SH) & fmask)\r\n<< sh;\r\n}\r\nmask |= 0xfUL << (24 - 4 * byte);\r\nvalue |= (unsigned long)unit << (24 - 4 * byte);\r\n}\r\nif (pmc < 5) {\r\nmask |= 0x8000000000000ul;\r\nvalue |= 0x1000000000000ul;\r\n}\r\n*maskp = mask;\r\n*valp = value;\r\nreturn 0;\r\n}\r\nstatic int power5p_limited_pmc_event(u64 event)\r\n{\r\nint pmc = (event >> PM_PMC_SH) & PM_PMC_MSK;\r\nreturn pmc == 5 || pmc == 6;\r\n}\r\nstatic int find_alternative(unsigned int event)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ARRAY_SIZE(event_alternatives); ++i) {\r\nif (event < event_alternatives[i][0])\r\nbreak;\r\nfor (j = 0; j < MAX_ALT && event_alternatives[i][j]; ++j)\r\nif (event == event_alternatives[i][j])\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic s64 find_alternative_bdecode(u64 event)\r\n{\r\nint pmc, altpmc, pp, j;\r\npmc = (event >> PM_PMC_SH) & PM_PMC_MSK;\r\nif (pmc == 0 || pmc > 4)\r\nreturn -1;\r\naltpmc = 5 - pmc;\r\npp = event & PM_PMCSEL_MSK;\r\nfor (j = 0; j < 4; ++j) {\r\nif (bytedecode_alternatives[pmc - 1][j] == pp) {\r\nreturn (event & ~(PM_PMC_MSKS | PM_PMCSEL_MSK)) |\r\n(altpmc << PM_PMC_SH) |\r\nbytedecode_alternatives[altpmc - 1][j];\r\n}\r\n}\r\nif (pmc == 1 && (pp == 0x0d || pp == 0x0e))\r\nreturn event + (2 << PM_PMC_SH) + (0x2e - 0x0d);\r\nif (pmc == 3 && (pp == 0x2e || pp == 0x2f))\r\nreturn event - (2 << PM_PMC_SH) - (0x2e - 0x0d);\r\nif (pp == 0x10 || pp == 0x28)\r\nreturn ((event ^ (0x10 ^ 0x28)) & ~PM_PMC_MSKS) |\r\n(altpmc << PM_PMC_SH);\r\nreturn -1;\r\n}\r\nstatic int power5p_get_alternatives(u64 event, unsigned int flags, u64 alt[])\r\n{\r\nint i, j, nalt = 1;\r\nint nlim;\r\ns64 ae;\r\nalt[0] = event;\r\nnalt = 1;\r\nnlim = power5p_limited_pmc_event(event);\r\ni = find_alternative(event);\r\nif (i >= 0) {\r\nfor (j = 0; j < MAX_ALT; ++j) {\r\nae = event_alternatives[i][j];\r\nif (ae && ae != event)\r\nalt[nalt++] = ae;\r\nnlim += power5p_limited_pmc_event(ae);\r\n}\r\n} else {\r\nae = find_alternative_bdecode(event);\r\nif (ae > 0)\r\nalt[nalt++] = ae;\r\n}\r\nif (flags & PPMU_ONLY_COUNT_RUN) {\r\nj = nalt;\r\nfor (i = 0; i < nalt; ++i) {\r\nswitch (alt[i]) {\r\ncase 0xf:\r\nalt[j++] = 0x600005;\r\n++nlim;\r\nbreak;\r\ncase 0x600005:\r\nalt[j++] = 0xf;\r\nbreak;\r\ncase 0x100009:\r\nalt[j++] = 0x500009;\r\n++nlim;\r\nbreak;\r\ncase 0x500009:\r\nalt[j++] = 0x100009;\r\nalt[j++] = 0x200009;\r\nbreak;\r\n}\r\n}\r\nnalt = j;\r\n}\r\nif (!(flags & PPMU_LIMITED_PMC_OK) && nlim) {\r\nj = 0;\r\nfor (i = 0; i < nalt; ++i) {\r\nif (!power5p_limited_pmc_event(alt[i])) {\r\nalt[j] = alt[i];\r\n++j;\r\n}\r\n}\r\nnalt = j;\r\n} else if ((flags & PPMU_LIMITED_PMC_REQD) && nlim < nalt) {\r\nj = 0;\r\nfor (i = 0; i < nalt; ++i) {\r\nif (power5p_limited_pmc_event(alt[i])) {\r\nalt[j] = alt[i];\r\n++j;\r\n}\r\n}\r\nnalt = j;\r\n}\r\nreturn nalt;\r\n}\r\nstatic int power5p_marked_instr_event(u64 event)\r\n{\r\nint pmc, psel;\r\nint bit, byte, unit;\r\nu32 mask;\r\npmc = (event >> PM_PMC_SH) & PM_PMC_MSK;\r\npsel = event & PM_PMCSEL_MSK;\r\nif (pmc >= 5)\r\nreturn 0;\r\nbit = -1;\r\nif (psel < sizeof(direct_event_is_marked)) {\r\nif (direct_event_is_marked[psel] & (1 << pmc))\r\nreturn 1;\r\nif (direct_event_is_marked[psel] & 0x80)\r\nbit = 4;\r\nelse if (psel == 0x08)\r\nbit = pmc - 1;\r\nelse if (psel == 0x10)\r\nbit = 4 - pmc;\r\nelse if (psel == 0x1b && (pmc == 1 || pmc == 3))\r\nbit = 4;\r\n} else if ((psel & 0x48) == 0x40) {\r\nbit = psel & 7;\r\n} else if (psel == 0x28) {\r\nbit = pmc - 1;\r\n} else if (pmc == 3 && (psel == 0x2e || psel == 0x2f)) {\r\nbit = 4;\r\n}\r\nif (!(event & PM_BUSEVENT_MSK) || bit == -1)\r\nreturn 0;\r\nbyte = (event >> PM_BYTE_SH) & PM_BYTE_MSK;\r\nunit = (event >> PM_UNIT_SH) & PM_UNIT_MSK;\r\nif (unit == PM_LSU0) {\r\nmask = 0x5dff00;\r\n} else if (unit == PM_LSU1 && byte >= 4) {\r\nbyte -= 4;\r\nmask = 0x5f11c000;\r\n} else\r\nreturn 0;\r\nreturn (mask >> (byte * 8 + bit)) & 1;\r\n}\r\nstatic int power5p_compute_mmcr(u64 event[], int n_ev,\r\nunsigned int hwc[], unsigned long mmcr[])\r\n{\r\nunsigned long mmcr1 = 0;\r\nunsigned long mmcra = 0;\r\nunsigned int pmc, unit, byte, psel;\r\nunsigned int ttm;\r\nint i, isbus, bit, grsel;\r\nunsigned int pmc_inuse = 0;\r\nunsigned char busbyte[4];\r\nunsigned char unituse[16];\r\nint ttmuse;\r\nif (n_ev > 6)\r\nreturn -1;\r\nmemset(busbyte, 0, sizeof(busbyte));\r\nmemset(unituse, 0, sizeof(unituse));\r\nfor (i = 0; i < n_ev; ++i) {\r\npmc = (event[i] >> PM_PMC_SH) & PM_PMC_MSK;\r\nif (pmc) {\r\nif (pmc > 6)\r\nreturn -1;\r\nif (pmc_inuse & (1 << (pmc - 1)))\r\nreturn -1;\r\npmc_inuse |= 1 << (pmc - 1);\r\n}\r\nif (event[i] & PM_BUSEVENT_MSK) {\r\nunit = (event[i] >> PM_UNIT_SH) & PM_UNIT_MSK;\r\nbyte = (event[i] >> PM_BYTE_SH) & PM_BYTE_MSK;\r\nif (unit > PM_LASTUNIT)\r\nreturn -1;\r\nif (unit == PM_ISU0_ALT)\r\nunit = PM_ISU0;\r\nif (byte >= 4) {\r\nif (unit != PM_LSU1)\r\nreturn -1;\r\n++unit;\r\nbyte &= 3;\r\n}\r\nif (busbyte[byte] && busbyte[byte] != unit)\r\nreturn -1;\r\nbusbyte[byte] = unit;\r\nunituse[unit] = 1;\r\n}\r\n}\r\nif (unituse[PM_ISU0] &\r\n(unituse[PM_FPU] | unituse[PM_IFU] | unituse[PM_ISU1])) {\r\nunituse[PM_ISU0_ALT] = 1;\r\nunituse[PM_ISU0] = 0;\r\n}\r\nttmuse = 0;\r\nfor (i = PM_FPU; i <= PM_ISU1; ++i) {\r\nif (!unituse[i])\r\ncontinue;\r\nif (ttmuse++)\r\nreturn -1;\r\nmmcr1 |= (unsigned long)i << MMCR1_TTM0SEL_SH;\r\n}\r\nttmuse = 0;\r\nfor (; i <= PM_GRS; ++i) {\r\nif (!unituse[i])\r\ncontinue;\r\nif (ttmuse++)\r\nreturn -1;\r\nmmcr1 |= (unsigned long)(i & 3) << MMCR1_TTM1SEL_SH;\r\n}\r\nif (ttmuse > 1)\r\nreturn -1;\r\nfor (byte = 0; byte < 4; ++byte) {\r\nunit = busbyte[byte];\r\nif (!unit)\r\ncontinue;\r\nif (unit == PM_ISU0 && unituse[PM_ISU0_ALT]) {\r\nunit = PM_ISU0_ALT;\r\n} else if (unit == PM_LSU1 + 1) {\r\nmmcr1 |= 1ul << (MMCR1_TTM3SEL_SH + 3 - byte);\r\n}\r\nttm = unit >> 2;\r\nmmcr1 |= (unsigned long)ttm\r\n<< (MMCR1_TD_CP_DBG0SEL_SH - 2 * byte);\r\n}\r\nfor (i = 0; i < n_ev; ++i) {\r\npmc = (event[i] >> PM_PMC_SH) & PM_PMC_MSK;\r\nunit = (event[i] >> PM_UNIT_SH) & PM_UNIT_MSK;\r\nbyte = (event[i] >> PM_BYTE_SH) & PM_BYTE_MSK;\r\npsel = event[i] & PM_PMCSEL_MSK;\r\nisbus = event[i] & PM_BUSEVENT_MSK;\r\nif (!pmc) {\r\nfor (pmc = 0; pmc < 4; ++pmc) {\r\nif (!(pmc_inuse & (1 << pmc)))\r\nbreak;\r\n}\r\nif (pmc >= 4)\r\nreturn -1;\r\npmc_inuse |= 1 << pmc;\r\n} else if (pmc <= 4) {\r\n--pmc;\r\nif (isbus && (byte & 2) &&\r\n(psel == 8 || psel == 0x10 || psel == 0x28))\r\nmmcr1 |= 1ul << (MMCR1_PMC1_ADDER_SEL_SH - pmc);\r\n} else {\r\n--pmc;\r\n}\r\nif (isbus && unit == PM_GRS) {\r\nbit = psel & 7;\r\ngrsel = (event[i] >> PM_GRS_SH) & PM_GRS_MSK;\r\nmmcr1 |= (unsigned long)grsel << grsel_shift[bit];\r\n}\r\nif (power5p_marked_instr_event(event[i]))\r\nmmcra |= MMCRA_SAMPLE_ENABLE;\r\nif ((psel & 0x58) == 0x40 && (byte & 1) != ((pmc >> 1) & 1))\r\npsel |= 0x10;\r\nif (pmc <= 3)\r\nmmcr1 |= psel << MMCR1_PMCSEL_SH(pmc);\r\nhwc[i] = pmc;\r\n}\r\nmmcr[0] = 0;\r\nif (pmc_inuse & 1)\r\nmmcr[0] = MMCR0_PMC1CE;\r\nif (pmc_inuse & 0x3e)\r\nmmcr[0] |= MMCR0_PMCjCE;\r\nmmcr[1] = mmcr1;\r\nmmcr[2] = mmcra;\r\nreturn 0;\r\n}\r\nstatic void power5p_disable_pmc(unsigned int pmc, unsigned long mmcr[])\r\n{\r\nif (pmc <= 3)\r\nmmcr[1] &= ~(0x7fUL << MMCR1_PMCSEL_SH(pmc));\r\n}\r\nstatic int __init init_power5p_pmu(void)\r\n{\r\nif (!cur_cpu_spec->oprofile_cpu_type ||\r\n(strcmp(cur_cpu_spec->oprofile_cpu_type, "ppc64/power5+")\r\n&& strcmp(cur_cpu_spec->oprofile_cpu_type, "ppc64/power5++")))\r\nreturn -ENODEV;\r\nreturn register_power_pmu(&power5p_pmu);\r\n}
