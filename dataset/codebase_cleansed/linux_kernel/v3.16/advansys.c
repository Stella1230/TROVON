static void asc_prt_asc_dvc_var(ASC_DVC_VAR *h)\r\n{\r\nprintk("ASC_DVC_VAR at addr 0x%lx\n", (ulong)h);\r\nprintk(" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl "\r\n"%d,\n", h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);\r\nprintk(" bus_type %d, init_sdtr 0x%x,\n", h->bus_type,\r\n(unsigned)h->init_sdtr);\r\nprintk(" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, "\r\n"chip_no 0x%x,\n", (unsigned)h->sdtr_done,\r\n(unsigned)h->use_tagged_qng, (unsigned)h->unit_not_ready,\r\n(unsigned)h->chip_no);\r\nprintk(" queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait "\r\n"%u,\n", (unsigned)h->queue_full_or_busy,\r\n(unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);\r\nprintk(" is_in_int %u, max_total_qng %u, cur_total_qng %u, "\r\n"in_critical_cnt %u,\n", (unsigned)h->is_in_int,\r\n(unsigned)h->max_total_qng, (unsigned)h->cur_total_qng,\r\n(unsigned)h->in_critical_cnt);\r\nprintk(" last_q_shortage %u, init_state 0x%x, no_scam 0x%x, "\r\n"pci_fix_asyn_xfer 0x%x,\n", (unsigned)h->last_q_shortage,\r\n(unsigned)h->init_state, (unsigned)h->no_scam,\r\n(unsigned)h->pci_fix_asyn_xfer);\r\nprintk(" cfg 0x%lx\n", (ulong)h->cfg);\r\n}\r\nstatic void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)\r\n{\r\nprintk("ASC_DVC_CFG at addr 0x%lx\n", (ulong)h);\r\nprintk(" can_tagged_qng 0x%x, cmd_qng_enabled 0x%x,\n",\r\nh->can_tagged_qng, h->cmd_qng_enabled);\r\nprintk(" disc_enable 0x%x, sdtr_enable 0x%x,\n",\r\nh->disc_enable, h->sdtr_enable);\r\nprintk(" chip_scsi_id %d, isa_dma_speed %d, isa_dma_channel %d, "\r\n"chip_version %d,\n", h->chip_scsi_id, h->isa_dma_speed,\r\nh->isa_dma_channel, h->chip_version);\r\nprintk(" mcode_date 0x%x, mcode_version %d\n",\r\nh->mcode_date, h->mcode_version);\r\n}\r\nstatic void asc_prt_adv_dvc_var(ADV_DVC_VAR *h)\r\n{\r\nprintk(" ADV_DVC_VAR at addr 0x%lx\n", (ulong)h);\r\nprintk(" iop_base 0x%lx, err_code 0x%x, ultra_able 0x%x\n",\r\n(ulong)h->iop_base, h->err_code, (unsigned)h->ultra_able);\r\nprintk(" sdtr_able 0x%x, wdtr_able 0x%x\n",\r\n(unsigned)h->sdtr_able, (unsigned)h->wdtr_able);\r\nprintk(" start_motor 0x%x, scsi_reset_wait 0x%x\n",\r\n(unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);\r\nprintk(" max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%lxn\n",\r\n(unsigned)h->max_host_qng, (unsigned)h->max_dvc_qng,\r\n(ulong)h->carr_freelist);\r\nprintk(" icq_sp 0x%lx, irq_sp 0x%lx\n",\r\n(ulong)h->icq_sp, (ulong)h->irq_sp);\r\nprintk(" no_scam 0x%x, tagqng_able 0x%x\n",\r\n(unsigned)h->no_scam, (unsigned)h->tagqng_able);\r\nprintk(" chip_scsi_id 0x%x, cfg 0x%lx\n",\r\n(unsigned)h->chip_scsi_id, (ulong)h->cfg);\r\n}\r\nstatic void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)\r\n{\r\nprintk(" ADV_DVC_CFG at addr 0x%lx\n", (ulong)h);\r\nprintk(" disc_enable 0x%x, termination 0x%x\n",\r\nh->disc_enable, h->termination);\r\nprintk(" chip_version 0x%x, mcode_date 0x%x\n",\r\nh->chip_version, h->mcode_date);\r\nprintk(" mcode_version 0x%x, control_flag 0x%x\n",\r\nh->mcode_version, h->control_flag);\r\n}\r\nstatic void asc_prt_scsi_host(struct Scsi_Host *s)\r\n{\r\nstruct asc_board *boardp = shost_priv(s);\r\nprintk("Scsi_Host at addr 0x%p, device %s\n", s, dev_name(boardp->dev));\r\nprintk(" host_busy %u, host_no %d,\n",\r\ns->host_busy, s->host_no);\r\nprintk(" base 0x%lx, io_port 0x%lx, irq %d,\n",\r\n(ulong)s->base, (ulong)s->io_port, boardp->irq);\r\nprintk(" dma_channel %d, this_id %d, can_queue %d,\n",\r\ns->dma_channel, s->this_id, s->can_queue);\r\nprintk(" cmd_per_lun %d, sg_tablesize %d, unchecked_isa_dma %d\n",\r\ns->cmd_per_lun, s->sg_tablesize, s->unchecked_isa_dma);\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nasc_prt_asc_dvc_var(&boardp->dvc_var.asc_dvc_var);\r\nasc_prt_asc_dvc_cfg(&boardp->dvc_cfg.asc_dvc_cfg);\r\n} else {\r\nasc_prt_adv_dvc_var(&boardp->dvc_var.adv_dvc_var);\r\nasc_prt_adv_dvc_cfg(&boardp->dvc_cfg.adv_dvc_cfg);\r\n}\r\n}\r\nstatic void asc_prt_hex(char *f, uchar *s, int l)\r\n{\r\nint i;\r\nint j;\r\nint k;\r\nint m;\r\nprintk("%s: (%d bytes)\n", f, l);\r\nfor (i = 0; i < l; i += 32) {\r\nif ((k = (l - i) / 4) >= 8) {\r\nk = 8;\r\nm = 0;\r\n} else {\r\nm = (l - i) % 4;\r\n}\r\nfor (j = 0; j < k; j++) {\r\nprintk(" %2.2X%2.2X%2.2X%2.2X",\r\n(unsigned)s[i + (j * 4)],\r\n(unsigned)s[i + (j * 4) + 1],\r\n(unsigned)s[i + (j * 4) + 2],\r\n(unsigned)s[i + (j * 4) + 3]);\r\n}\r\nswitch (m) {\r\ncase 0:\r\ndefault:\r\nbreak;\r\ncase 1:\r\nprintk(" %2.2X", (unsigned)s[i + (j * 4)]);\r\nbreak;\r\ncase 2:\r\nprintk(" %2.2X%2.2X",\r\n(unsigned)s[i + (j * 4)],\r\n(unsigned)s[i + (j * 4) + 1]);\r\nbreak;\r\ncase 3:\r\nprintk(" %2.2X%2.2X%2.2X",\r\n(unsigned)s[i + (j * 4) + 1],\r\n(unsigned)s[i + (j * 4) + 2],\r\n(unsigned)s[i + (j * 4) + 3]);\r\nbreak;\r\n}\r\nprintk("\n");\r\n}\r\n}\r\nstatic void asc_prt_asc_scsi_q(ASC_SCSI_Q *q)\r\n{\r\nASC_SG_HEAD *sgp;\r\nint i;\r\nprintk("ASC_SCSI_Q at addr 0x%lx\n", (ulong)q);\r\nprintk\r\n(" target_ix 0x%x, target_lun %u, srb_ptr 0x%lx, tag_code 0x%x,\n",\r\nq->q2.target_ix, q->q1.target_lun, (ulong)q->q2.srb_ptr,\r\nq->q2.tag_code);\r\nprintk\r\n(" data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",\r\n(ulong)le32_to_cpu(q->q1.data_addr),\r\n(ulong)le32_to_cpu(q->q1.data_cnt),\r\n(ulong)le32_to_cpu(q->q1.sense_addr), q->q1.sense_len);\r\nprintk(" cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u\n",\r\n(ulong)q->cdbptr, q->q2.cdb_len,\r\n(ulong)q->sg_head, q->q1.sg_queue_cnt);\r\nif (q->sg_head) {\r\nsgp = q->sg_head;\r\nprintk("ASC_SG_HEAD at addr 0x%lx\n", (ulong)sgp);\r\nprintk(" entry_cnt %u, queue_cnt %u\n", sgp->entry_cnt,\r\nsgp->queue_cnt);\r\nfor (i = 0; i < sgp->entry_cnt; i++) {\r\nprintk(" [%u]: addr 0x%lx, bytes %lu\n",\r\ni, (ulong)le32_to_cpu(sgp->sg_list[i].addr),\r\n(ulong)le32_to_cpu(sgp->sg_list[i].bytes));\r\n}\r\n}\r\n}\r\nstatic void asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)\r\n{\r\nprintk("ASC_QDONE_INFO at addr 0x%lx\n", (ulong)q);\r\nprintk(" srb_ptr 0x%lx, target_ix %u, cdb_len %u, tag_code %u,\n",\r\n(ulong)q->d2.srb_ptr, q->d2.target_ix, q->d2.cdb_len,\r\nq->d2.tag_code);\r\nprintk\r\n(" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\n",\r\nq->d3.done_stat, q->d3.host_stat, q->d3.scsi_stat, q->d3.scsi_msg);\r\n}\r\nstatic void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)\r\n{\r\nint i;\r\nprintk(" ASC_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",\r\n(ulong)b, sgblockno);\r\nprintk(" sg_cnt %u, sg_ptr 0x%lx\n",\r\nb->sg_cnt, (ulong)le32_to_cpu(b->sg_ptr));\r\nBUG_ON(b->sg_cnt > NO_OF_SG_PER_BLOCK);\r\nif (b->sg_ptr != 0)\r\nBUG_ON(b->sg_cnt != NO_OF_SG_PER_BLOCK);\r\nfor (i = 0; i < b->sg_cnt; i++) {\r\nprintk(" [%u]: sg_addr 0x%lx, sg_count 0x%lx\n",\r\ni, (ulong)b->sg_list[i].sg_addr,\r\n(ulong)b->sg_list[i].sg_count);\r\n}\r\n}\r\nstatic void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)\r\n{\r\nint sg_blk_cnt;\r\nstruct asc_sg_block *sg_ptr;\r\nprintk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong)q);\r\nprintk(" target_id %u, target_lun %u, srb_ptr 0x%lx, a_flag 0x%x\n",\r\nq->target_id, q->target_lun, (ulong)q->srb_ptr, q->a_flag);\r\nprintk(" cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx\n",\r\nq->cntl, (ulong)le32_to_cpu(q->data_addr), (ulong)q->vdata_addr);\r\nprintk(" data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",\r\n(ulong)le32_to_cpu(q->data_cnt),\r\n(ulong)le32_to_cpu(q->sense_addr), q->sense_len);\r\nprintk\r\n(" cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x\n",\r\nq->cdb_len, q->done_status, q->host_status, q->scsi_status);\r\nprintk(" sg_working_ix 0x%x, target_cmd %u\n",\r\nq->sg_working_ix, q->target_cmd);\r\nprintk(" scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx\n",\r\n(ulong)le32_to_cpu(q->scsiq_rptr),\r\n(ulong)le32_to_cpu(q->sg_real_addr), (ulong)q->sg_list_ptr);\r\nif (q->sg_list_ptr != NULL) {\r\nsg_blk_cnt = 0;\r\nwhile (1) {\r\nsg_ptr =\r\n&(((ADV_SG_BLOCK *)(q->sg_list_ptr))[sg_blk_cnt]);\r\nasc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);\r\nif (sg_ptr->sg_ptr == 0) {\r\nbreak;\r\n}\r\nsg_blk_cnt++;\r\n}\r\n}\r\n}\r\nstatic u32 advansys_ptr_to_srb(struct asc_dvc_var *asc_dvc, void *ptr)\r\n{\r\nint i;\r\nvoid **new_ptr;\r\nfor (i = 0; i < asc_dvc->ptr_map_count; i++) {\r\nif (!asc_dvc->ptr_map[i])\r\ngoto out;\r\n}\r\nif (asc_dvc->ptr_map_count == 0)\r\nasc_dvc->ptr_map_count = 1;\r\nelse\r\nasc_dvc->ptr_map_count *= 2;\r\nnew_ptr = krealloc(asc_dvc->ptr_map,\r\nasc_dvc->ptr_map_count * sizeof(void *), GFP_ATOMIC);\r\nif (!new_ptr)\r\nreturn BAD_SRB;\r\nasc_dvc->ptr_map = new_ptr;\r\nout:\r\nASC_DBG(3, "Putting ptr %p into array offset %d\n", ptr, i);\r\nasc_dvc->ptr_map[i] = ptr;\r\nreturn i + 1;\r\n}\r\nstatic void * advansys_srb_to_ptr(struct asc_dvc_var *asc_dvc, u32 srb)\r\n{\r\nvoid *ptr;\r\nsrb--;\r\nif (srb >= asc_dvc->ptr_map_count) {\r\nprintk("advansys: bad SRB %u, max %u\n", srb,\r\nasc_dvc->ptr_map_count);\r\nreturn NULL;\r\n}\r\nptr = asc_dvc->ptr_map[srb];\r\nasc_dvc->ptr_map[srb] = NULL;\r\nASC_DBG(3, "Returning ptr %p from array offset %d\n", ptr, srb);\r\nreturn ptr;\r\n}\r\nstatic const char *advansys_info(struct Scsi_Host *shost)\r\n{\r\nstatic char info[ASC_INFO_SIZE];\r\nstruct asc_board *boardp = shost_priv(shost);\r\nASC_DVC_VAR *asc_dvc_varp;\r\nADV_DVC_VAR *adv_dvc_varp;\r\nchar *busname;\r\nchar *widename = NULL;\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nasc_dvc_varp = &boardp->dvc_var.asc_dvc_var;\r\nASC_DBG(1, "begin\n");\r\nif (asc_dvc_varp->bus_type & ASC_IS_ISA) {\r\nif ((asc_dvc_varp->bus_type & ASC_IS_ISAPNP) ==\r\nASC_IS_ISAPNP) {\r\nbusname = "ISA PnP";\r\n} else {\r\nbusname = "ISA";\r\n}\r\nsprintf(info,\r\n"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X, DMA 0x%X",\r\nASC_VERSION, busname,\r\n(ulong)shost->io_port,\r\n(ulong)shost->io_port + ASC_IOADR_GAP - 1,\r\nboardp->irq, shost->dma_channel);\r\n} else {\r\nif (asc_dvc_varp->bus_type & ASC_IS_VL) {\r\nbusname = "VL";\r\n} else if (asc_dvc_varp->bus_type & ASC_IS_EISA) {\r\nbusname = "EISA";\r\n} else if (asc_dvc_varp->bus_type & ASC_IS_PCI) {\r\nif ((asc_dvc_varp->bus_type & ASC_IS_PCI_ULTRA)\r\n== ASC_IS_PCI_ULTRA) {\r\nbusname = "PCI Ultra";\r\n} else {\r\nbusname = "PCI";\r\n}\r\n} else {\r\nbusname = "?";\r\nshost_printk(KERN_ERR, shost, "unknown bus "\r\n"type %d\n", asc_dvc_varp->bus_type);\r\n}\r\nsprintf(info,\r\n"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X",\r\nASC_VERSION, busname, (ulong)shost->io_port,\r\n(ulong)shost->io_port + ASC_IOADR_GAP - 1,\r\nboardp->irq);\r\n}\r\n} else {\r\nadv_dvc_varp = &boardp->dvc_var.adv_dvc_var;\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nwidename = "Ultra-Wide";\r\n} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\r\nwidename = "Ultra2-Wide";\r\n} else {\r\nwidename = "Ultra3-Wide";\r\n}\r\nsprintf(info,\r\n"AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X",\r\nASC_VERSION, widename, (ulong)adv_dvc_varp->iop_base,\r\n(ulong)adv_dvc_varp->iop_base + boardp->asc_n_io_port - 1, boardp->irq);\r\n}\r\nBUG_ON(strlen(info) >= ASC_INFO_SIZE);\r\nASC_DBG(1, "end\n");\r\nreturn info;\r\n}\r\nstatic void asc_prt_board_devices(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *boardp = shost_priv(shost);\r\nint chip_scsi_id;\r\nint i;\r\nseq_printf(m,\r\n"\nDevice Information for AdvanSys SCSI Host %d:\n",\r\nshost->host_no);\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nchip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;\r\n} else {\r\nchip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;\r\n}\r\nseq_printf(m, "Target IDs Detected:");\r\nfor (i = 0; i <= ADV_MAX_TID; i++) {\r\nif (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i))\r\nseq_printf(m, " %X,", i);\r\n}\r\nseq_printf(m, " (%X=Host Adapter)\n", chip_scsi_id);\r\n}\r\nstatic void asc_prt_adv_bios(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *boardp = shost_priv(shost);\r\nushort major, minor, letter;\r\nseq_printf(m, "\nROM BIOS Version: ");\r\nif (boardp->bios_signature != 0x55AA) {\r\nseq_printf(m, "Disabled or Pre-3.1\n");\r\nseq_printf(m,\r\n"BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");\r\nseq_printf(m,\r\n"can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");\r\n} else {\r\nmajor = (boardp->bios_version >> 12) & 0xF;\r\nminor = (boardp->bios_version >> 8) & 0xF;\r\nletter = (boardp->bios_version & 0xFF);\r\nseq_printf(m, "%d.%d%c\n",\r\nmajor, minor,\r\nletter >= 26 ? '?' : letter + 'A');\r\nif (major < 3 || (major <= 3 && minor < 1) ||\r\n(major <= 3 && minor <= 1 && letter < ('I' - 'A'))) {\r\nseq_printf(m,\r\n"Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");\r\nseq_printf(m,\r\n"ftp://ftp.connectcom.net/pub\n");\r\n}\r\n}\r\n}\r\nstatic int asc_get_eeprom_string(ushort *serialnum, uchar *cp)\r\n{\r\nushort w, num;\r\nif ((serialnum[1] & 0xFE00) != ((ushort)0xAA << 8)) {\r\nreturn ASC_FALSE;\r\n} else {\r\nw = serialnum[0];\r\nif ((*cp = 'A' + ((w & 0xE000) >> 13)) == 'H') {\r\n*cp += 0x8;\r\n}\r\ncp++;\r\n*cp++ = 'A' + ((w & 0x1C00) >> 10);\r\nnum = w & 0x3FF;\r\n*cp++ = '0' + (num / 100);\r\nnum %= 100;\r\n*cp++ = '0' + (num / 10);\r\n*cp++ = 'A' + (num % 10);\r\nw = serialnum[1];\r\nif (serialnum[2] & 0x8000) {\r\n*cp++ = '8' + ((w & 0x1C0) >> 6);\r\n} else {\r\n*cp++ = '0' + ((w & 0x1C0) >> 6);\r\n}\r\nnum = w & 0x003F;\r\n*cp++ = '0' + num / 10;\r\nnum %= 10;\r\n*cp++ = '0' + num;\r\nw = serialnum[2] & 0x7FFF;\r\n*cp++ = 'A' + (w / 1000);\r\nnum = w % 1000;\r\n*cp++ = '0' + num / 100;\r\nnum %= 100;\r\n*cp++ = '0' + num / 10;\r\nnum %= 10;\r\n*cp++ = '0' + num;\r\n*cp = '\0';\r\nreturn ASC_TRUE;\r\n}\r\n}\r\nstatic void asc_prt_asc_board_eeprom(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *boardp = shost_priv(shost);\r\nASC_DVC_VAR *asc_dvc_varp;\r\nASCEEP_CONFIG *ep;\r\nint i;\r\n#ifdef CONFIG_ISA\r\nint isa_dma_speed[] = { 10, 8, 7, 6, 5, 4, 3, 2 };\r\n#endif\r\nuchar serialstr[13];\r\nasc_dvc_varp = &boardp->dvc_var.asc_dvc_var;\r\nep = &boardp->eep_config.asc_eep;\r\nseq_printf(m,\r\n"\nEEPROM Settings for AdvanSys SCSI Host %d:\n",\r\nshost->host_no);\r\nif (asc_get_eeprom_string((ushort *)&ep->adapter_info[0], serialstr)\r\n== ASC_TRUE)\r\nseq_printf(m, " Serial Number: %s\n", serialstr);\r\nelse if (ep->adapter_info[5] == 0xBB)\r\nseq_printf(m,\r\n" Default Settings Used for EEPROM-less Adapter.\n");\r\nelse\r\nseq_printf(m,\r\n" Serial Number Signature Not Present.\n");\r\nseq_printf(m,\r\n" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",\r\nASC_EEP_GET_CHIP_ID(ep), ep->max_total_qng,\r\nep->max_tag_qng);\r\nseq_printf(m,\r\n" cntl 0x%x, no_scam 0x%x\n", ep->cntl, ep->no_scam);\r\nseq_printf(m, " Target ID: ");\r\nfor (i = 0; i <= ASC_MAX_TID; i++)\r\nseq_printf(m, " %d", i);\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Disconnects: ");\r\nfor (i = 0; i <= ASC_MAX_TID; i++)\r\nseq_printf(m, " %c",\r\n(ep->disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Command Queuing: ");\r\nfor (i = 0; i <= ASC_MAX_TID; i++)\r\nseq_printf(m, " %c",\r\n(ep->use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Start Motor: ");\r\nfor (i = 0; i <= ASC_MAX_TID; i++)\r\nseq_printf(m, " %c",\r\n(ep->start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Synchronous Transfer:");\r\nfor (i = 0; i <= ASC_MAX_TID; i++)\r\nseq_printf(m, " %c",\r\n(ep->init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\nseq_printf(m, "\n");\r\n#ifdef CONFIG_ISA\r\nif (asc_dvc_varp->bus_type & ASC_IS_ISA) {\r\nseq_printf(m,\r\n" Host ISA DMA speed: %d MB/S\n",\r\nisa_dma_speed[ASC_EEP_GET_DMA_SPD(ep)]);\r\n}\r\n#endif\r\n}\r\nstatic void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *boardp = shost_priv(shost);\r\nADV_DVC_VAR *adv_dvc_varp;\r\nint i;\r\nchar *termstr;\r\nuchar serialstr[13];\r\nADVEEP_3550_CONFIG *ep_3550 = NULL;\r\nADVEEP_38C0800_CONFIG *ep_38C0800 = NULL;\r\nADVEEP_38C1600_CONFIG *ep_38C1600 = NULL;\r\nushort word;\r\nushort *wordp;\r\nushort sdtr_speed = 0;\r\nadv_dvc_varp = &boardp->dvc_var.adv_dvc_var;\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nep_3550 = &boardp->eep_config.adv_3550_eep;\r\n} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\r\nep_38C0800 = &boardp->eep_config.adv_38C0800_eep;\r\n} else {\r\nep_38C1600 = &boardp->eep_config.adv_38C1600_eep;\r\n}\r\nseq_printf(m,\r\n"\nEEPROM Settings for AdvanSys SCSI Host %d:\n",\r\nshost->host_no);\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nwordp = &ep_3550->serial_number_word1;\r\n} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\r\nwordp = &ep_38C0800->serial_number_word1;\r\n} else {\r\nwordp = &ep_38C1600->serial_number_word1;\r\n}\r\nif (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE)\r\nseq_printf(m, " Serial Number: %s\n", serialstr);\r\nelse\r\nseq_printf(m, " Serial Number Signature Not Present.\n");\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)\r\nseq_printf(m,\r\n" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",\r\nep_3550->adapter_scsi_id,\r\nep_3550->max_host_qng, ep_3550->max_dvc_qng);\r\nelse if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)\r\nseq_printf(m,\r\n" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",\r\nep_38C0800->adapter_scsi_id,\r\nep_38C0800->max_host_qng,\r\nep_38C0800->max_dvc_qng);\r\nelse\r\nseq_printf(m,\r\n" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",\r\nep_38C1600->adapter_scsi_id,\r\nep_38C1600->max_host_qng,\r\nep_38C1600->max_dvc_qng);\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nword = ep_3550->termination;\r\n} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\r\nword = ep_38C0800->termination_lvd;\r\n} else {\r\nword = ep_38C1600->termination_lvd;\r\n}\r\nswitch (word) {\r\ncase 1:\r\ntermstr = "Low Off/High Off";\r\nbreak;\r\ncase 2:\r\ntermstr = "Low Off/High On";\r\nbreak;\r\ncase 3:\r\ntermstr = "Low On/High On";\r\nbreak;\r\ndefault:\r\ncase 0:\r\ntermstr = "Automatic";\r\nbreak;\r\n}\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)\r\nseq_printf(m,\r\n" termination: %u (%s), bios_ctrl: 0x%x\n",\r\nep_3550->termination, termstr,\r\nep_3550->bios_ctrl);\r\nelse if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)\r\nseq_printf(m,\r\n" termination: %u (%s), bios_ctrl: 0x%x\n",\r\nep_38C0800->termination_lvd, termstr,\r\nep_38C0800->bios_ctrl);\r\nelse\r\nseq_printf(m,\r\n" termination: %u (%s), bios_ctrl: 0x%x\n",\r\nep_38C1600->termination_lvd, termstr,\r\nep_38C1600->bios_ctrl);\r\nseq_printf(m, " Target ID: ");\r\nfor (i = 0; i <= ADV_MAX_TID; i++)\r\nseq_printf(m, " %X", i);\r\nseq_printf(m, "\n");\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nword = ep_3550->disc_enable;\r\n} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\r\nword = ep_38C0800->disc_enable;\r\n} else {\r\nword = ep_38C1600->disc_enable;\r\n}\r\nseq_printf(m, " Disconnects: ");\r\nfor (i = 0; i <= ADV_MAX_TID; i++)\r\nseq_printf(m, " %c",\r\n(word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\nseq_printf(m, "\n");\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nword = ep_3550->tagqng_able;\r\n} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\r\nword = ep_38C0800->tagqng_able;\r\n} else {\r\nword = ep_38C1600->tagqng_able;\r\n}\r\nseq_printf(m, " Command Queuing: ");\r\nfor (i = 0; i <= ADV_MAX_TID; i++)\r\nseq_printf(m, " %c",\r\n(word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\nseq_printf(m, "\n");\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nword = ep_3550->start_motor;\r\n} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\r\nword = ep_38C0800->start_motor;\r\n} else {\r\nword = ep_38C1600->start_motor;\r\n}\r\nseq_printf(m, " Start Motor: ");\r\nfor (i = 0; i <= ADV_MAX_TID; i++)\r\nseq_printf(m, " %c",\r\n(word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\nseq_printf(m, "\n");\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nseq_printf(m, " Synchronous Transfer:");\r\nfor (i = 0; i <= ADV_MAX_TID; i++)\r\nseq_printf(m, " %c",\r\n(ep_3550->sdtr_able & ADV_TID_TO_TIDMASK(i)) ?\r\n'Y' : 'N');\r\nseq_printf(m, "\n");\r\n}\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nseq_printf(m, " Ultra Transfer: ");\r\nfor (i = 0; i <= ADV_MAX_TID; i++)\r\nseq_printf(m, " %c",\r\n(ep_3550->ultra_able & ADV_TID_TO_TIDMASK(i))\r\n? 'Y' : 'N');\r\nseq_printf(m, "\n");\r\n}\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nword = ep_3550->wdtr_able;\r\n} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\r\nword = ep_38C0800->wdtr_able;\r\n} else {\r\nword = ep_38C1600->wdtr_able;\r\n}\r\nseq_printf(m, " Wide Transfer: ");\r\nfor (i = 0; i <= ADV_MAX_TID; i++)\r\nseq_printf(m, " %c",\r\n(word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\nseq_printf(m, "\n");\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||\r\nadv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600) {\r\nseq_printf(m,\r\n" Synchronous Transfer Speed (Mhz):\n ");\r\nfor (i = 0; i <= ADV_MAX_TID; i++) {\r\nchar *speed_str;\r\nif (i == 0) {\r\nsdtr_speed = adv_dvc_varp->sdtr_speed1;\r\n} else if (i == 4) {\r\nsdtr_speed = adv_dvc_varp->sdtr_speed2;\r\n} else if (i == 8) {\r\nsdtr_speed = adv_dvc_varp->sdtr_speed3;\r\n} else if (i == 12) {\r\nsdtr_speed = adv_dvc_varp->sdtr_speed4;\r\n}\r\nswitch (sdtr_speed & ADV_MAX_TID) {\r\ncase 0:\r\nspeed_str = "Off";\r\nbreak;\r\ncase 1:\r\nspeed_str = " 5";\r\nbreak;\r\ncase 2:\r\nspeed_str = " 10";\r\nbreak;\r\ncase 3:\r\nspeed_str = " 20";\r\nbreak;\r\ncase 4:\r\nspeed_str = " 40";\r\nbreak;\r\ncase 5:\r\nspeed_str = " 80";\r\nbreak;\r\ndefault:\r\nspeed_str = "Unk";\r\nbreak;\r\n}\r\nseq_printf(m, "%X:%s ", i, speed_str);\r\nif (i == 7)\r\nseq_printf(m, "\n ");\r\nsdtr_speed >>= 4;\r\n}\r\nseq_printf(m, "\n");\r\n}\r\n}\r\nstatic void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *boardp = shost_priv(shost);\r\nint chip_scsi_id;\r\nseq_printf(m,\r\n"\nLinux Driver Configuration and Information for AdvanSys SCSI Host %d:\n",\r\nshost->host_no);\r\nseq_printf(m,\r\n" host_busy %u, max_id %u, max_lun %u, max_channel %u\n",\r\nshost->host_busy, shost->max_id,\r\nshost->max_lun, shost->max_channel);\r\nseq_printf(m,\r\n" unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u\n",\r\nshost->unique_id, shost->can_queue, shost->this_id,\r\nshost->sg_tablesize, shost->cmd_per_lun);\r\nseq_printf(m,\r\n" unchecked_isa_dma %d, use_clustering %d\n",\r\nshost->unchecked_isa_dma, shost->use_clustering);\r\nseq_printf(m,\r\n" flags 0x%x, last_reset 0x%lx, jiffies 0x%lx, asc_n_io_port 0x%x\n",\r\nboardp->flags, boardp->last_reset, jiffies,\r\nboardp->asc_n_io_port);\r\nseq_printf(m, " io_port 0x%lx\n", shost->io_port);\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nchip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;\r\n} else {\r\nchip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;\r\n}\r\n}\r\nstatic void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *boardp = shost_priv(shost);\r\nint chip_scsi_id;\r\nASC_DVC_VAR *v;\r\nASC_DVC_CFG *c;\r\nint i;\r\nint renegotiate = 0;\r\nv = &boardp->dvc_var.asc_dvc_var;\r\nc = &boardp->dvc_cfg.asc_dvc_cfg;\r\nchip_scsi_id = c->chip_scsi_id;\r\nseq_printf(m,\r\n"\nAsc Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",\r\nshost->host_no);\r\nseq_printf(m, " chip_version %u, mcode_date 0x%x, "\r\n"mcode_version 0x%x, err_code %u\n",\r\nc->chip_version, c->mcode_date, c->mcode_version,\r\nv->err_code);\r\nseq_printf(m,\r\n" Total Command Pending: %d\n", v->cur_total_qng);\r\nseq_printf(m, " Command Queuing:");\r\nfor (i = 0; i <= ASC_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nseq_printf(m, " %X:%c",\r\ni,\r\n(v->use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Command Queue Pending:");\r\nfor (i = 0; i <= ASC_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nseq_printf(m, " %X:%u", i, v->cur_dvc_qng[i]);\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Command Queue Limit:");\r\nfor (i = 0; i <= ASC_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nseq_printf(m, " %X:%u", i, v->max_dvc_qng[i]);\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Command Queue Full:");\r\nfor (i = 0; i <= ASC_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nif (boardp->queue_full & ADV_TID_TO_TIDMASK(i))\r\nseq_printf(m, " %X:Y-%d",\r\ni, boardp->queue_full_cnt[i]);\r\nelse\r\nseq_printf(m, " %X:N", i);\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Synchronous Transfer:");\r\nfor (i = 0; i <= ASC_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nseq_printf(m, " %X:%c",\r\ni,\r\n(v->sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\n}\r\nseq_printf(m, "\n");\r\nfor (i = 0; i <= ASC_MAX_TID; i++) {\r\nuchar syn_period_ix;\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||\r\n((v->init_sdtr & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nseq_printf(m, " %X:", i);\r\nif ((boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET) == 0) {\r\nseq_printf(m, " Asynchronous");\r\n} else {\r\nsyn_period_ix =\r\n(boardp->sdtr_data[i] >> 4) & (v->max_sdtr_index -\r\n1);\r\nseq_printf(m,\r\n" Transfer Period Factor: %d (%d.%d Mhz),",\r\nv->sdtr_period_tbl[syn_period_ix],\r\n250 / v->sdtr_period_tbl[syn_period_ix],\r\nASC_TENTHS(250,\r\nv->sdtr_period_tbl[syn_period_ix]));\r\nseq_printf(m, " REQ/ACK Offset: %d",\r\nboardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET);\r\n}\r\nif ((v->sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {\r\nseq_printf(m, "*\n");\r\nrenegotiate = 1;\r\n} else {\r\nseq_printf(m, "\n");\r\n}\r\n}\r\nif (renegotiate) {\r\nseq_printf(m,\r\n" * = Re-negotiation pending before next command.\n");\r\n}\r\n}\r\nstatic void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *boardp = shost_priv(shost);\r\nint i;\r\nADV_DVC_VAR *v;\r\nADV_DVC_CFG *c;\r\nAdvPortAddr iop_base;\r\nushort chip_scsi_id;\r\nushort lramword;\r\nuchar lrambyte;\r\nushort tagqng_able;\r\nushort sdtr_able, wdtr_able;\r\nushort wdtr_done, sdtr_done;\r\nushort period = 0;\r\nint renegotiate = 0;\r\nv = &boardp->dvc_var.adv_dvc_var;\r\nc = &boardp->dvc_cfg.adv_dvc_cfg;\r\niop_base = v->iop_base;\r\nchip_scsi_id = v->chip_scsi_id;\r\nseq_printf(m,\r\n"\nAdv Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",\r\nshost->host_no);\r\nseq_printf(m,\r\n" iop_base 0x%lx, cable_detect: %X, err_code %u\n",\r\n(unsigned long)v->iop_base,\r\nAdvReadWordRegister(iop_base,IOPW_SCSI_CFG1) & CABLE_DETECT,\r\nv->err_code);\r\nseq_printf(m, " chip_version %u, mcode_date 0x%x, "\r\n"mcode_version 0x%x\n", c->chip_version,\r\nc->mcode_date, c->mcode_version);\r\nAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\r\nseq_printf(m, " Queuing Enabled:");\r\nfor (i = 0; i <= ADV_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nseq_printf(m, " %X:%c",\r\ni,\r\n(tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Queue Limit:");\r\nfor (i = 0; i <= ADV_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + i,\r\nlrambyte);\r\nseq_printf(m, " %X:%d", i, lrambyte);\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Command Pending:");\r\nfor (i = 0; i <= ADV_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_QUEUED_CMD + i,\r\nlrambyte);\r\nseq_printf(m, " %X:%d", i, lrambyte);\r\n}\r\nseq_printf(m, "\n");\r\nAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\r\nseq_printf(m, " Wide Enabled:");\r\nfor (i = 0; i <= ADV_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nseq_printf(m, " %X:%c",\r\ni,\r\n(wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\n}\r\nseq_printf(m, "\n");\r\nAdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);\r\nseq_printf(m, " Transfer Bit Width:");\r\nfor (i = 0; i <= ADV_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nAdvReadWordLram(iop_base,\r\nASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),\r\nlramword);\r\nseq_printf(m, " %X:%d",\r\ni, (lramword & 0x8000) ? 16 : 8);\r\nif ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&\r\n(wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {\r\nseq_printf(m, "*");\r\nrenegotiate = 1;\r\n}\r\n}\r\nseq_printf(m, "\n");\r\nAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\r\nseq_printf(m, " Synchronous Enabled:");\r\nfor (i = 0; i <= ADV_MAX_TID; i++) {\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nseq_printf(m, " %X:%c",\r\ni,\r\n(sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\r\n}\r\nseq_printf(m, "\n");\r\nAdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);\r\nfor (i = 0; i <= ADV_MAX_TID; i++) {\r\nAdvReadWordLram(iop_base,\r\nASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),\r\nlramword);\r\nlramword &= ~0x8000;\r\nif ((chip_scsi_id == i) ||\r\n((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||\r\n((sdtr_able & ADV_TID_TO_TIDMASK(i)) == 0)) {\r\ncontinue;\r\n}\r\nseq_printf(m, " %X:", i);\r\nif ((lramword & 0x1F) == 0) {\r\nseq_printf(m, " Asynchronous");\r\n} else {\r\nseq_printf(m, " Transfer Period Factor: ");\r\nif ((lramword & 0x1F00) == 0x1100) {\r\nseq_printf(m, "9 (80.0 Mhz),");\r\n} else if ((lramword & 0x1F00) == 0x1000) {\r\nseq_printf(m, "10 (40.0 Mhz),");\r\n} else {\r\nperiod = (((lramword >> 8) * 25) + 50) / 4;\r\nif (period == 0) {\r\nseq_printf(m, "%d (? Mhz), ", period);\r\n} else {\r\nseq_printf(m,\r\n"%d (%d.%d Mhz),",\r\nperiod, 250 / period,\r\nASC_TENTHS(250, period));\r\n}\r\n}\r\nseq_printf(m, " REQ/ACK Offset: %d",\r\nlramword & 0x1F);\r\n}\r\nif ((sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {\r\nseq_printf(m, "*\n");\r\nrenegotiate = 1;\r\n} else {\r\nseq_printf(m, "\n");\r\n}\r\n}\r\nif (renegotiate) {\r\nseq_printf(m,\r\n" * = Re-negotiation pending before next command.\n");\r\n}\r\n}\r\nstatic void asc_prt_board_stats(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *boardp = shost_priv(shost);\r\nstruct asc_stats *s = &boardp->asc_stats;\r\nseq_printf(m,\r\n"\nLinux Driver Statistics for AdvanSys SCSI Host %d:\n",\r\nshost->host_no);\r\nseq_printf(m,\r\n" queuecommand %u, reset %u, biosparam %u, interrupt %u\n",\r\ns->queuecommand, s->reset, s->biosparam,\r\ns->interrupt);\r\nseq_printf(m,\r\n" callback %u, done %u, build_error %u, build_noreq %u, build_nosg %u\n",\r\ns->callback, s->done, s->build_error,\r\ns->adv_build_noreq, s->adv_build_nosg);\r\nseq_printf(m,\r\n" exe_noerror %u, exe_busy %u, exe_error %u, exe_unknown %u\n",\r\ns->exe_noerror, s->exe_busy, s->exe_error,\r\ns->exe_unknown);\r\nif (s->xfer_cnt > 0) {\r\nseq_printf(m, " xfer_cnt %u, xfer_elem %u, ",\r\ns->xfer_cnt, s->xfer_elem);\r\nseq_printf(m, "xfer_bytes %u.%01u kb\n",\r\ns->xfer_sect / 2, ASC_TENTHS(s->xfer_sect, 2));\r\nseq_printf(m, " avg_num_elem %u.%01u, ",\r\ns->xfer_elem / s->xfer_cnt,\r\nASC_TENTHS(s->xfer_elem, s->xfer_cnt));\r\nseq_printf(m, "avg_elem_size %u.%01u kb, ",\r\n(s->xfer_sect / 2) / s->xfer_elem,\r\nASC_TENTHS((s->xfer_sect / 2), s->xfer_elem));\r\nseq_printf(m, "avg_xfer_size %u.%01u kb\n",\r\n(s->xfer_sect / 2) / s->xfer_cnt,\r\nASC_TENTHS((s->xfer_sect / 2), s->xfer_cnt));\r\n}\r\n}\r\nstatic int\r\nadvansys_show_info(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *boardp = shost_priv(shost);\r\nASC_DBG(1, "begin\n");\r\nseq_printf(m, "%s\n", (char *)advansys_info(shost));\r\nif (!ASC_NARROW_BOARD(boardp))\r\nasc_prt_adv_bios(m, shost);\r\nasc_prt_board_devices(m, shost);\r\nif (ASC_NARROW_BOARD(boardp))\r\nasc_prt_asc_board_eeprom(m, shost);\r\nelse\r\nasc_prt_adv_board_eeprom(m, shost);\r\nasc_prt_driver_conf(m, shost);\r\n#ifdef ADVANSYS_STATS\r\nasc_prt_board_stats(m, shost);\r\n#endif\r\nif (ASC_NARROW_BOARD(boardp))\r\nasc_prt_asc_board_info(m, shost);\r\nelse\r\nasc_prt_adv_board_info(m, shost);\r\nreturn 0;\r\n}\r\nstatic void asc_scsi_done(struct scsi_cmnd *scp)\r\n{\r\nscsi_dma_unmap(scp);\r\nASC_STATS(scp->device->host, done);\r\nscp->scsi_done(scp);\r\n}\r\nstatic void AscSetBank(PortAddr iop_base, uchar bank)\r\n{\r\nuchar val;\r\nval = AscGetChipControl(iop_base) &\r\n(~\r\n(CC_SINGLE_STEP | CC_TEST | CC_DIAG | CC_SCSI_RESET |\r\nCC_CHIP_RESET));\r\nif (bank == 1) {\r\nval |= CC_BANK_ONE;\r\n} else if (bank == 2) {\r\nval |= CC_DIAG | CC_BANK_ONE;\r\n} else {\r\nval &= ~CC_BANK_ONE;\r\n}\r\nAscSetChipControl(iop_base, val);\r\n}\r\nstatic void AscSetChipIH(PortAddr iop_base, ushort ins_code)\r\n{\r\nAscSetBank(iop_base, 1);\r\nAscWriteChipIH(iop_base, ins_code);\r\nAscSetBank(iop_base, 0);\r\n}\r\nstatic int AscStartChip(PortAddr iop_base)\r\n{\r\nAscSetChipControl(iop_base, 0);\r\nif ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nstatic int AscStopChip(PortAddr iop_base)\r\n{\r\nuchar cc_val;\r\ncc_val =\r\nAscGetChipControl(iop_base) &\r\n(~(CC_SINGLE_STEP | CC_TEST | CC_DIAG));\r\nAscSetChipControl(iop_base, (uchar)(cc_val | CC_HALT));\r\nAscSetChipIH(iop_base, INS_HALT);\r\nAscSetChipIH(iop_base, INS_RFLAG_WTM);\r\nif ((AscGetChipStatus(iop_base) & CSW_HALTED) == 0) {\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nstatic int AscIsChipHalted(PortAddr iop_base)\r\n{\r\nif ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {\r\nif ((AscGetChipControl(iop_base) & CC_HALT) != 0) {\r\nreturn (1);\r\n}\r\n}\r\nreturn (0);\r\n}\r\nstatic int AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)\r\n{\r\nPortAddr iop_base;\r\nint i = 10;\r\niop_base = asc_dvc->iop_base;\r\nwhile ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE)\r\n&& (i-- > 0)) {\r\nmdelay(100);\r\n}\r\nAscStopChip(iop_base);\r\nAscSetChipControl(iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT);\r\nudelay(60);\r\nAscSetChipIH(iop_base, INS_RFLAG_WTM);\r\nAscSetChipIH(iop_base, INS_HALT);\r\nAscSetChipControl(iop_base, CC_CHIP_RESET | CC_HALT);\r\nAscSetChipControl(iop_base, CC_HALT);\r\nmdelay(200);\r\nAscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);\r\nAscSetChipStatus(iop_base, 0);\r\nreturn (AscIsChipHalted(iop_base));\r\n}\r\nstatic int AscFindSignature(PortAddr iop_base)\r\n{\r\nushort sig_word;\r\nASC_DBG(1, "AscGetChipSignatureByte(0x%x) 0x%x\n",\r\niop_base, AscGetChipSignatureByte(iop_base));\r\nif (AscGetChipSignatureByte(iop_base) == (uchar)ASC_1000_ID1B) {\r\nASC_DBG(1, "AscGetChipSignatureWord(0x%x) 0x%x\n",\r\niop_base, AscGetChipSignatureWord(iop_base));\r\nsig_word = AscGetChipSignatureWord(iop_base);\r\nif ((sig_word == (ushort)ASC_1000_ID0W) ||\r\n(sig_word == (ushort)ASC_1000_ID0W_FIX)) {\r\nreturn (1);\r\n}\r\n}\r\nreturn (0);\r\n}\r\nstatic void AscEnableInterrupt(PortAddr iop_base)\r\n{\r\nushort cfg;\r\ncfg = AscGetChipCfgLsw(iop_base);\r\nAscSetChipCfgLsw(iop_base, cfg | ASC_CFG0_HOST_INT_ON);\r\n}\r\nstatic void AscDisableInterrupt(PortAddr iop_base)\r\n{\r\nushort cfg;\r\ncfg = AscGetChipCfgLsw(iop_base);\r\nAscSetChipCfgLsw(iop_base, cfg & (~ASC_CFG0_HOST_INT_ON));\r\n}\r\nstatic uchar AscReadLramByte(PortAddr iop_base, ushort addr)\r\n{\r\nunsigned char byte_data;\r\nunsigned short word_data;\r\nif (isodd_word(addr)) {\r\nAscSetChipLramAddr(iop_base, addr - 1);\r\nword_data = AscGetChipLramData(iop_base);\r\nbyte_data = (word_data >> 8) & 0xFF;\r\n} else {\r\nAscSetChipLramAddr(iop_base, addr);\r\nword_data = AscGetChipLramData(iop_base);\r\nbyte_data = word_data & 0xFF;\r\n}\r\nreturn byte_data;\r\n}\r\nstatic ushort AscReadLramWord(PortAddr iop_base, ushort addr)\r\n{\r\nushort word_data;\r\nAscSetChipLramAddr(iop_base, addr);\r\nword_data = AscGetChipLramData(iop_base);\r\nreturn (word_data);\r\n}\r\nstatic ASC_DCNT AscReadLramDWord(PortAddr iop_base, ushort addr)\r\n{\r\nushort val_low, val_high;\r\nASC_DCNT dword_data;\r\nAscSetChipLramAddr(iop_base, addr);\r\nval_low = AscGetChipLramData(iop_base);\r\nval_high = AscGetChipLramData(iop_base);\r\ndword_data = ((ASC_DCNT) val_high << 16) | (ASC_DCNT) val_low;\r\nreturn (dword_data);\r\n}\r\nstatic void\r\nAscMemWordSetLram(PortAddr iop_base, ushort s_addr, ushort set_wval, int words)\r\n{\r\nint i;\r\nAscSetChipLramAddr(iop_base, s_addr);\r\nfor (i = 0; i < words; i++) {\r\nAscSetChipLramData(iop_base, set_wval);\r\n}\r\n}\r\nstatic void AscWriteLramWord(PortAddr iop_base, ushort addr, ushort word_val)\r\n{\r\nAscSetChipLramAddr(iop_base, addr);\r\nAscSetChipLramData(iop_base, word_val);\r\n}\r\nstatic void AscWriteLramByte(PortAddr iop_base, ushort addr, uchar byte_val)\r\n{\r\nushort word_data;\r\nif (isodd_word(addr)) {\r\naddr--;\r\nword_data = AscReadLramWord(iop_base, addr);\r\nword_data &= 0x00FF;\r\nword_data |= (((ushort)byte_val << 8) & 0xFF00);\r\n} else {\r\nword_data = AscReadLramWord(iop_base, addr);\r\nword_data &= 0xFF00;\r\nword_data |= ((ushort)byte_val & 0x00FF);\r\n}\r\nAscWriteLramWord(iop_base, addr, word_data);\r\n}\r\nstatic void\r\nAscMemWordCopyPtrToLram(PortAddr iop_base, ushort s_addr,\r\nconst uchar *s_buffer, int words)\r\n{\r\nint i;\r\nAscSetChipLramAddr(iop_base, s_addr);\r\nfor (i = 0; i < 2 * words; i += 2) {\r\noutpw(iop_base + IOP_RAM_DATA,\r\n((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);\r\n}\r\n}\r\nstatic void\r\nAscMemDWordCopyPtrToLram(PortAddr iop_base,\r\nushort s_addr, uchar *s_buffer, int dwords)\r\n{\r\nint i;\r\nAscSetChipLramAddr(iop_base, s_addr);\r\nfor (i = 0; i < 4 * dwords; i += 4) {\r\noutpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);\r\noutpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 3] << 8) | s_buffer[i + 2]);\r\n}\r\n}\r\nstatic void\r\nAscMemWordCopyPtrFromLram(PortAddr iop_base,\r\nushort s_addr, uchar *d_buffer, int words)\r\n{\r\nint i;\r\nushort word;\r\nAscSetChipLramAddr(iop_base, s_addr);\r\nfor (i = 0; i < 2 * words; i += 2) {\r\nword = inpw(iop_base + IOP_RAM_DATA);\r\nd_buffer[i] = word & 0xff;\r\nd_buffer[i + 1] = (word >> 8) & 0xff;\r\n}\r\n}\r\nstatic ASC_DCNT AscMemSumLramWord(PortAddr iop_base, ushort s_addr, int words)\r\n{\r\nASC_DCNT sum;\r\nint i;\r\nsum = 0L;\r\nfor (i = 0; i < words; i++, s_addr += 2) {\r\nsum += AscReadLramWord(iop_base, s_addr);\r\n}\r\nreturn (sum);\r\n}\r\nstatic ushort AscInitLram(ASC_DVC_VAR *asc_dvc)\r\n{\r\nuchar i;\r\nushort s_addr;\r\nPortAddr iop_base;\r\nushort warn_code;\r\niop_base = asc_dvc->iop_base;\r\nwarn_code = 0;\r\nAscMemWordSetLram(iop_base, ASC_QADR_BEG, 0,\r\n(ushort)(((int)(asc_dvc->max_total_qng + 2 + 1) *\r\n64) >> 1));\r\ni = ASC_MIN_ACTIVE_QNO;\r\ns_addr = ASC_QADR_BEG + ASC_QBLK_SIZE;\r\nAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),\r\n(uchar)(i + 1));\r\nAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),\r\n(uchar)(asc_dvc->max_total_qng));\r\nAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),\r\n(uchar)i);\r\ni++;\r\ns_addr += ASC_QBLK_SIZE;\r\nfor (; i < asc_dvc->max_total_qng; i++, s_addr += ASC_QBLK_SIZE) {\r\nAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),\r\n(uchar)(i + 1));\r\nAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),\r\n(uchar)(i - 1));\r\nAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),\r\n(uchar)i);\r\n}\r\nAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),\r\n(uchar)ASC_QLINK_END);\r\nAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),\r\n(uchar)(asc_dvc->max_total_qng - 1));\r\nAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),\r\n(uchar)asc_dvc->max_total_qng);\r\ni++;\r\ns_addr += ASC_QBLK_SIZE;\r\nfor (; i <= (uchar)(asc_dvc->max_total_qng + 3);\r\ni++, s_addr += ASC_QBLK_SIZE) {\r\nAscWriteLramByte(iop_base,\r\n(ushort)(s_addr + (ushort)ASC_SCSIQ_B_FWD), i);\r\nAscWriteLramByte(iop_base,\r\n(ushort)(s_addr + (ushort)ASC_SCSIQ_B_BWD), i);\r\nAscWriteLramByte(iop_base,\r\n(ushort)(s_addr + (ushort)ASC_SCSIQ_B_QNO), i);\r\n}\r\nreturn warn_code;\r\n}\r\nstatic ASC_DCNT\r\nAscLoadMicroCode(PortAddr iop_base, ushort s_addr,\r\nconst uchar *mcode_buf, ushort mcode_size)\r\n{\r\nASC_DCNT chksum;\r\nushort mcode_word_size;\r\nushort mcode_chksum;\r\nmcode_word_size = (ushort)(mcode_size >> 1);\r\nAscMemWordSetLram(iop_base, s_addr, 0, mcode_word_size);\r\nAscMemWordCopyPtrToLram(iop_base, s_addr, mcode_buf, mcode_word_size);\r\nchksum = AscMemSumLramWord(iop_base, s_addr, mcode_word_size);\r\nASC_DBG(1, "chksum 0x%lx\n", (ulong)chksum);\r\nmcode_chksum = (ushort)AscMemSumLramWord(iop_base,\r\n(ushort)ASC_CODE_SEC_BEG,\r\n(ushort)((mcode_size -\r\ns_addr - (ushort)\r\nASC_CODE_SEC_BEG) /\r\n2));\r\nASC_DBG(1, "mcode_chksum 0x%lx\n", (ulong)mcode_chksum);\r\nAscWriteLramWord(iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum);\r\nAscWriteLramWord(iop_base, ASCV_MCODE_SIZE_W, mcode_size);\r\nreturn chksum;\r\n}\r\nstatic void AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)\r\n{\r\nPortAddr iop_base;\r\nint i;\r\nushort lram_addr;\r\niop_base = asc_dvc->iop_base;\r\nAscPutRiscVarFreeQHead(iop_base, 1);\r\nAscPutRiscVarDoneQTail(iop_base, asc_dvc->max_total_qng);\r\nAscPutVarFreeQHead(iop_base, 1);\r\nAscPutVarDoneQTail(iop_base, asc_dvc->max_total_qng);\r\nAscWriteLramByte(iop_base, ASCV_BUSY_QHEAD_B,\r\n(uchar)((int)asc_dvc->max_total_qng + 1));\r\nAscWriteLramByte(iop_base, ASCV_DISC1_QHEAD_B,\r\n(uchar)((int)asc_dvc->max_total_qng + 2));\r\nAscWriteLramByte(iop_base, (ushort)ASCV_TOTAL_READY_Q_B,\r\nasc_dvc->max_total_qng);\r\nAscWriteLramWord(iop_base, ASCV_ASCDVC_ERR_CODE_W, 0);\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\r\nAscWriteLramByte(iop_base, ASCV_STOP_CODE_B, 0);\r\nAscWriteLramByte(iop_base, ASCV_SCSIBUSY_B, 0);\r\nAscWriteLramByte(iop_base, ASCV_WTM_FLAG_B, 0);\r\nAscPutQDoneInProgress(iop_base, 0);\r\nlram_addr = ASC_QADR_BEG;\r\nfor (i = 0; i < 32; i++, lram_addr += 2) {\r\nAscWriteLramWord(iop_base, lram_addr, 0);\r\n}\r\n}\r\nstatic ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)\r\n{\r\nint i;\r\nushort warn_code;\r\nPortAddr iop_base;\r\nASC_PADDR phy_addr;\r\nASC_DCNT phy_size;\r\nstruct asc_board *board = asc_dvc_to_board(asc_dvc);\r\niop_base = asc_dvc->iop_base;\r\nwarn_code = 0;\r\nfor (i = 0; i <= ASC_MAX_TID; i++) {\r\nAscPutMCodeInitSDTRAtID(iop_base, i,\r\nasc_dvc->cfg->sdtr_period_offset[i]);\r\n}\r\nAscInitQLinkVar(asc_dvc);\r\nAscWriteLramByte(iop_base, ASCV_DISC_ENABLE_B,\r\nasc_dvc->cfg->disc_enable);\r\nAscWriteLramByte(iop_base, ASCV_HOSTSCSI_ID_B,\r\nASC_TID_TO_TARGET_ID(asc_dvc->cfg->chip_scsi_id));\r\nBUG_ON((unsigned long)asc_dvc->overrun_buf & 7);\r\nasc_dvc->overrun_dma = dma_map_single(board->dev, asc_dvc->overrun_buf,\r\nASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(board->dev, asc_dvc->overrun_dma)) {\r\nwarn_code = -ENOMEM;\r\ngoto err_dma_map;\r\n}\r\nphy_addr = cpu_to_le32(asc_dvc->overrun_dma);\r\nAscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_PADDR_D,\r\n(uchar *)&phy_addr, 1);\r\nphy_size = cpu_to_le32(ASC_OVERRUN_BSIZE);\r\nAscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_BSIZE_D,\r\n(uchar *)&phy_size, 1);\r\nasc_dvc->cfg->mcode_date =\r\nAscReadLramWord(iop_base, (ushort)ASCV_MC_DATE_W);\r\nasc_dvc->cfg->mcode_version =\r\nAscReadLramWord(iop_base, (ushort)ASCV_MC_VER_W);\r\nAscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);\r\nif (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {\r\nasc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;\r\nwarn_code = UW_ERR;\r\ngoto err_mcode_start;\r\n}\r\nif (AscStartChip(iop_base) != 1) {\r\nasc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;\r\nwarn_code = UW_ERR;\r\ngoto err_mcode_start;\r\n}\r\nreturn warn_code;\r\nerr_mcode_start:\r\ndma_unmap_single(board->dev, asc_dvc->overrun_dma,\r\nASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\r\nerr_dma_map:\r\nasc_dvc->overrun_dma = 0;\r\nreturn warn_code;\r\n}\r\nstatic ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)\r\n{\r\nconst struct firmware *fw;\r\nconst char fwname[] = "advansys/mcode.bin";\r\nint err;\r\nunsigned long chksum;\r\nushort warn_code;\r\nPortAddr iop_base;\r\niop_base = asc_dvc->iop_base;\r\nwarn_code = 0;\r\nif ((asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI) &&\r\n!(asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE)) {\r\nAscResetChipAndScsiBus(asc_dvc);\r\nmdelay(asc_dvc->scsi_reset_wait * 1000);\r\n}\r\nasc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;\r\nif (asc_dvc->err_code != 0)\r\nreturn UW_ERR;\r\nif (!AscFindSignature(asc_dvc->iop_base)) {\r\nasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\r\nreturn warn_code;\r\n}\r\nAscDisableInterrupt(iop_base);\r\nwarn_code |= AscInitLram(asc_dvc);\r\nif (asc_dvc->err_code != 0)\r\nreturn UW_ERR;\r\nerr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to load image \"%s\" err %d\n",\r\nfwname, err);\r\nasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\r\nreturn err;\r\n}\r\nif (fw->size < 4) {\r\nprintk(KERN_ERR "Bogus length %zu in image \"%s\"\n",\r\nfw->size, fwname);\r\nrelease_firmware(fw);\r\nasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\r\nreturn -EINVAL;\r\n}\r\nchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\r\n(fw->data[1] << 8) | fw->data[0];\r\nASC_DBG(1, "_asc_mcode_chksum 0x%lx\n", (ulong)chksum);\r\nif (AscLoadMicroCode(iop_base, 0, &fw->data[4],\r\nfw->size - 4) != chksum) {\r\nasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\r\nrelease_firmware(fw);\r\nreturn warn_code;\r\n}\r\nrelease_firmware(fw);\r\nwarn_code |= AscInitMicroCodeVar(asc_dvc);\r\nif (!asc_dvc->overrun_dma)\r\nreturn warn_code;\r\nasc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC;\r\nAscEnableInterrupt(iop_base);\r\nreturn warn_code;\r\n}\r\nstatic int AdvLoadMicrocode(AdvPortAddr iop_base, const unsigned char *buf,\r\nint size, int memsize, int chksum)\r\n{\r\nint i, j, end, len = 0;\r\nADV_DCNT sum;\r\nAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);\r\nfor (i = 253 * 2; i < size; i++) {\r\nif (buf[i] == 0xff) {\r\nunsigned short word = (buf[i + 3] << 8) | buf[i + 2];\r\nfor (j = 0; j < buf[i + 1]; j++) {\r\nAdvWriteWordAutoIncLram(iop_base, word);\r\nlen += 2;\r\n}\r\ni += 3;\r\n} else if (buf[i] == 0xfe) {\r\nunsigned short word = (buf[i + 2] << 8) | buf[i + 1];\r\nAdvWriteWordAutoIncLram(iop_base, word);\r\ni += 2;\r\nlen += 2;\r\n} else {\r\nunsigned int off = buf[i] * 2;\r\nunsigned short word = (buf[off + 1] << 8) | buf[off];\r\nAdvWriteWordAutoIncLram(iop_base, word);\r\nlen += 2;\r\n}\r\n}\r\nend = len;\r\nwhile (len < memsize) {\r\nAdvWriteWordAutoIncLram(iop_base, 0);\r\nlen += 2;\r\n}\r\nsum = 0;\r\nAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);\r\nfor (len = 0; len < end; len += 2) {\r\nsum += AdvReadWordAutoIncLram(iop_base);\r\n}\r\nif (sum != chksum)\r\nreturn ASC_IERR_MCODE_CHKSUM;\r\nreturn 0;\r\n}\r\nstatic void AdvBuildCarrierFreelist(struct adv_dvc_var *asc_dvc)\r\n{\r\nADV_CARR_T *carrp;\r\nADV_SDCNT buf_size;\r\nADV_PADDR carr_paddr;\r\ncarrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);\r\nasc_dvc->carr_freelist = NULL;\r\nif (carrp == asc_dvc->carrier_buf) {\r\nbuf_size = ADV_CARRIER_BUFSIZE;\r\n} else {\r\nbuf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);\r\n}\r\ndo {\r\ncarr_paddr = cpu_to_le32(virt_to_bus(carrp));\r\nbuf_size -= sizeof(ADV_CARR_T);\r\ncarrp->carr_pa = carr_paddr;\r\ncarrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));\r\ncarrp->next_vpa =\r\ncpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));\r\nasc_dvc->carr_freelist = carrp;\r\ncarrp++;\r\n} while (buf_size > 0);\r\n}\r\nstatic int\r\nAdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,\r\nushort idle_cmd, ADV_DCNT idle_cmd_parameter)\r\n{\r\nint result;\r\nADV_DCNT i, j;\r\nAdvPortAddr iop_base;\r\niop_base = asc_dvc->iop_base;\r\nAdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, (ushort)0);\r\nAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IDLE_CMD_PARAMETER,\r\ncpu_to_le32(idle_cmd_parameter));\r\nAdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD, idle_cmd);\r\nAdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_B);\r\nif (asc_dvc->chip_type == ADV_CHIP_ASC3550) {\r\nAdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);\r\n}\r\nfor (i = 0; i < SCSI_WAIT_100_MSEC; i++) {\r\nfor (j = 0; j < SCSI_US_PER_MSEC; j++) {\r\nAdvReadWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS,\r\nresult);\r\nif (result != 0)\r\nreturn result;\r\nudelay(1);\r\n}\r\n}\r\nBUG();\r\nreturn ADV_ERROR;\r\n}\r\nstatic int AdvResetSB(ADV_DVC_VAR *asc_dvc)\r\n{\r\nint status;\r\nstatus = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_START, 0L);\r\nif (status != ADV_TRUE) {\r\nreturn status;\r\n}\r\nudelay(ASC_SCSI_RESET_HOLD_TIME_US);\r\nstatus = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_END, 0L);\r\nif (status != ADV_TRUE) {\r\nreturn status;\r\n}\r\nmdelay(asc_dvc->scsi_reset_wait * 1000);\r\nreturn status;\r\n}\r\nstatic int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)\r\n{\r\nconst struct firmware *fw;\r\nconst char fwname[] = "advansys/3550.bin";\r\nAdvPortAddr iop_base;\r\nushort warn_code;\r\nint begin_addr;\r\nint end_addr;\r\nushort code_sum;\r\nint word;\r\nint i;\r\nint err;\r\nunsigned long chksum;\r\nushort scsi_cfg1;\r\nuchar tid;\r\nushort bios_mem[ASC_MC_BIOSLEN / 2];\r\nushort wdtr_able = 0, sdtr_able, tagqng_able;\r\nuchar max_cmd[ADV_MAX_TID + 1];\r\nif (asc_dvc->err_code != 0)\r\nreturn ADV_ERROR;\r\nif (asc_dvc->chip_type != ADV_CHIP_ASC3550) {\r\nasc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;\r\nreturn ADV_ERROR;\r\n}\r\nwarn_code = 0;\r\niop_base = asc_dvc->iop_base;\r\nfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\r\nAdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\r\nbios_mem[i]);\r\n}\r\nif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] == 0x55AA) {\r\nushort bios_version, major, minor;\r\nbios_version =\r\nbios_mem[(ASC_MC_BIOS_VERSION - ASC_MC_BIOSMEM) / 2];\r\nmajor = (bios_version >> 12) & 0xF;\r\nminor = (bios_version >> 8) & 0xF;\r\nif (major < 3 || (major == 3 && minor == 1)) {\r\nAdvReadWordLram(iop_base, 0x120, wdtr_able);\r\n} else {\r\nAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\r\n}\r\n}\r\nAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\r\nAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\r\nfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\r\nAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\r\nmax_cmd[tid]);\r\n}\r\nerr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to load image \"%s\" err %d\n",\r\nfwname, err);\r\nasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\r\nreturn err;\r\n}\r\nif (fw->size < 4) {\r\nprintk(KERN_ERR "Bogus length %zu in image \"%s\"\n",\r\nfw->size, fwname);\r\nrelease_firmware(fw);\r\nasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\r\nreturn -EINVAL;\r\n}\r\nchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\r\n(fw->data[1] << 8) | fw->data[0];\r\nasc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],\r\nfw->size - 4, ADV_3550_MEMSIZE,\r\nchksum);\r\nrelease_firmware(fw);\r\nif (asc_dvc->err_code)\r\nreturn ADV_ERROR;\r\nfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\r\nAdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\r\nbios_mem[i]);\r\n}\r\nAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\r\nAdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);\r\ncode_sum = 0;\r\nAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);\r\nfor (word = begin_addr; word < end_addr; word += 2) {\r\ncode_sum += AdvReadWordAutoIncLram(iop_base);\r\n}\r\nAdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);\r\nAdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,\r\nasc_dvc->cfg->mcode_date);\r\nAdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,\r\nasc_dvc->cfg->mcode_version);\r\nAdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);\r\nif (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {\r\nAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\r\nword |= CONTROL_FLAG_IGNORE_PERR;\r\nAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\r\n}\r\nAdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,\r\nSTART_CTL_EMFU | READ_CMD_MRM);\r\nif ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\r\nAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,\r\nasc_dvc->wdtr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,\r\nasc_dvc->sdtr_able);\r\n}\r\nword = 0;\r\nfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\r\nif (ADV_TID_TO_TIDMASK(tid) & asc_dvc->ultra_able) {\r\nword |= (0x3 << (4 * (tid % 4)));\r\n} else {\r\nword |= (0x2 << (4 * (tid % 4)));\r\n}\r\nif (tid == 3) {\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, word);\r\nword = 0;\r\n} else if (tid == 7) {\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, word);\r\nword = 0;\r\n} else if (tid == 11) {\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, word);\r\nword = 0;\r\n} else if (tid == 15) {\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, word);\r\n}\r\n}\r\nAdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,\r\nasc_dvc->cfg->disc_enable);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,\r\nPARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |\r\nasc_dvc->chip_scsi_id);\r\nscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\r\nif ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||\r\n(scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {\r\nasc_dvc->err_code |= ASC_IERR_ILLEGAL_CONNECTION;\r\nreturn ADV_ERROR;\r\n}\r\nif ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {\r\nasc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;\r\nreturn ADV_ERROR;\r\n}\r\nif ((scsi_cfg1 & DIFF_MODE) && (scsi_cfg1 & DIFF_SENSE) == 0) {\r\nasc_dvc->err_code |= ASC_IERR_SINGLE_END_DEVICE;\r\nreturn ADV_ERROR;\r\n}\r\nif (asc_dvc->cfg->termination == 0) {\r\nasc_dvc->cfg->termination |= TERM_CTL_SEL;\r\nswitch (scsi_cfg1 & CABLE_DETECT) {\r\ncase 0x3:\r\ncase 0x7:\r\ncase 0xB:\r\ncase 0xD:\r\ncase 0xE:\r\ncase 0xF:\r\nasc_dvc->cfg->termination |= (TERM_CTL_H | TERM_CTL_L);\r\nbreak;\r\ncase 0x1:\r\ncase 0x5:\r\ncase 0x9:\r\ncase 0xA:\r\ncase 0xC:\r\nasc_dvc->cfg->termination |= TERM_CTL_H;\r\nbreak;\r\ncase 0x2:\r\ncase 0x6:\r\nbreak;\r\n}\r\n}\r\nscsi_cfg1 &= ~TERM_CTL;\r\nscsi_cfg1 |= (TERM_CTL_SEL | (~asc_dvc->cfg->termination & TERM_CTL));\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1,\r\nFLTR_DISABLE | scsi_cfg1);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,\r\nBIOS_EN | RAM_SZ_8KB);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,\r\nADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));\r\nAdvBuildCarrierFreelist(asc_dvc);\r\nif ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {\r\nasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\r\nreturn ADV_ERROR;\r\n}\r\nasc_dvc->carr_freelist = (ADV_CARR_T *)\r\nADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));\r\nasc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);\r\nAdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);\r\nif ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {\r\nasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\r\nreturn ADV_ERROR;\r\n}\r\nasc_dvc->carr_freelist = (ADV_CARR_T *)\r\nADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));\r\nasc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);\r\nAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);\r\nasc_dvc->carr_pending_cnt = 0;\r\nAdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,\r\n(ADV_INTR_ENABLE_HOST_INTR |\r\nADV_INTR_ENABLE_GLOBAL_INTR));\r\nAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);\r\nAdvWriteWordRegister(iop_base, IOPW_PC, word);\r\nAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);\r\nif (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\r\nif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==\r\n0x55AA) {\r\nAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\r\ntagqng_able);\r\nfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\r\nAdvWriteByteLram(iop_base,\r\nASC_MC_NUMBER_OF_MAX_CMD + tid,\r\nmax_cmd[tid]);\r\n}\r\n} else {\r\nif (AdvResetSB(asc_dvc) != ADV_TRUE) {\r\nwarn_code = ASC_WARN_BUSRESET_ERROR;\r\n}\r\n}\r\n}\r\nreturn warn_code;\r\n}\r\nstatic int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)\r\n{\r\nconst struct firmware *fw;\r\nconst char fwname[] = "advansys/38C0800.bin";\r\nAdvPortAddr iop_base;\r\nushort warn_code;\r\nint begin_addr;\r\nint end_addr;\r\nushort code_sum;\r\nint word;\r\nint i;\r\nint err;\r\nunsigned long chksum;\r\nushort scsi_cfg1;\r\nuchar byte;\r\nuchar tid;\r\nushort bios_mem[ASC_MC_BIOSLEN / 2];\r\nushort wdtr_able, sdtr_able, tagqng_able;\r\nuchar max_cmd[ADV_MAX_TID + 1];\r\nif (asc_dvc->err_code != 0)\r\nreturn ADV_ERROR;\r\nif (asc_dvc->chip_type != ADV_CHIP_ASC38C0800) {\r\nasc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;\r\nreturn ADV_ERROR;\r\n}\r\nwarn_code = 0;\r\niop_base = asc_dvc->iop_base;\r\nfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\r\nAdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\r\nbios_mem[i]);\r\n}\r\nAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\r\nAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\r\nAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\r\nfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\r\nAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\r\nmax_cmd[tid]);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);\r\nmdelay(10);\r\nbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\r\nif ((byte & RAM_TEST_DONE) == 0\r\n|| (byte & 0x0F) != PRE_TEST_VALUE) {\r\nasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\r\nreturn ADV_ERROR;\r\n}\r\nAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\r\nmdelay(10);\r\nif (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)\r\n!= NORMAL_VALUE) {\r\nasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\r\nreturn ADV_ERROR;\r\n}\r\n}\r\nAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);\r\nmdelay(10);\r\nbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\r\nif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\r\nasc_dvc->bist_err_code = byte;\r\nasc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;\r\nreturn ADV_ERROR;\r\n}\r\nAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\r\nerr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to load image \"%s\" err %d\n",\r\nfwname, err);\r\nasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\r\nreturn err;\r\n}\r\nif (fw->size < 4) {\r\nprintk(KERN_ERR "Bogus length %zu in image \"%s\"\n",\r\nfw->size, fwname);\r\nrelease_firmware(fw);\r\nasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\r\nreturn -EINVAL;\r\n}\r\nchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\r\n(fw->data[1] << 8) | fw->data[0];\r\nasc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],\r\nfw->size - 4, ADV_38C0800_MEMSIZE,\r\nchksum);\r\nrelease_firmware(fw);\r\nif (asc_dvc->err_code)\r\nreturn ADV_ERROR;\r\nfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\r\nAdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\r\nbios_mem[i]);\r\n}\r\nAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\r\nAdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);\r\ncode_sum = 0;\r\nAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);\r\nfor (word = begin_addr; word < end_addr; word += 2) {\r\ncode_sum += AdvReadWordAutoIncLram(iop_base);\r\n}\r\nAdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);\r\nAdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,\r\nasc_dvc->cfg->mcode_date);\r\nAdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,\r\nasc_dvc->cfg->mcode_version);\r\nAdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);\r\nscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\r\nAdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,\r\nscsi_cfg1 | DIS_TERM_DRV);\r\nif (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {\r\nAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\r\nword |= CONTROL_FLAG_IGNORE_PERR;\r\nAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\r\n}\r\nAdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,\r\nBC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH |\r\nREAD_CMD_MRM);\r\nif ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\r\nAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,\r\nasc_dvc->wdtr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,\r\nasc_dvc->sdtr_able);\r\n}\r\nAdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,\r\nasc_dvc->cfg->disc_enable);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,\r\nPARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |\r\nasc_dvc->chip_scsi_id);\r\nscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\r\nif ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {\r\nasc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;\r\nreturn ADV_ERROR;\r\n}\r\nif (scsi_cfg1 & HVD) {\r\nasc_dvc->err_code = ASC_IERR_HVD_DEVICE;\r\nreturn ADV_ERROR;\r\n}\r\nif ((asc_dvc->cfg->termination & TERM_SE) == 0) {\r\nswitch (scsi_cfg1 & C_DET_SE) {\r\ncase 0x1:\r\ncase 0x2:\r\ncase 0x3:\r\nasc_dvc->cfg->termination |= TERM_SE;\r\nbreak;\r\ncase 0x0:\r\nasc_dvc->cfg->termination |= TERM_SE_HI;\r\nbreak;\r\n}\r\n}\r\nif ((asc_dvc->cfg->termination & TERM_LVD) == 0) {\r\nswitch (scsi_cfg1 & C_DET_LVD) {\r\ncase 0x4:\r\ncase 0x8:\r\ncase 0xC:\r\nasc_dvc->cfg->termination |= TERM_LVD;\r\nbreak;\r\ncase 0x0:\r\nbreak;\r\n}\r\n}\r\nscsi_cfg1 &= (~TERM_SE & ~TERM_LVD);\r\nscsi_cfg1 |= (~asc_dvc->cfg->termination & 0xF0);\r\nscsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL & ~HVD_LVD_SE);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,\r\nBIOS_EN | RAM_SZ_16KB);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,\r\nADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));\r\nAdvBuildCarrierFreelist(asc_dvc);\r\nif ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {\r\nasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\r\nreturn ADV_ERROR;\r\n}\r\nasc_dvc->carr_freelist = (ADV_CARR_T *)\r\nADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));\r\nasc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);\r\nAdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);\r\nif ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {\r\nasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\r\nreturn ADV_ERROR;\r\n}\r\nasc_dvc->carr_freelist = (ADV_CARR_T *)\r\nADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));\r\nasc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);\r\nAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);\r\nasc_dvc->carr_pending_cnt = 0;\r\nAdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,\r\n(ADV_INTR_ENABLE_HOST_INTR |\r\nADV_INTR_ENABLE_GLOBAL_INTR));\r\nAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);\r\nAdvWriteWordRegister(iop_base, IOPW_PC, word);\r\nAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);\r\nif (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\r\nif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==\r\n0x55AA) {\r\nAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\r\ntagqng_able);\r\nfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\r\nAdvWriteByteLram(iop_base,\r\nASC_MC_NUMBER_OF_MAX_CMD + tid,\r\nmax_cmd[tid]);\r\n}\r\n} else {\r\nif (AdvResetSB(asc_dvc) != ADV_TRUE) {\r\nwarn_code = ASC_WARN_BUSRESET_ERROR;\r\n}\r\n}\r\n}\r\nreturn warn_code;\r\n}\r\nstatic int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)\r\n{\r\nconst struct firmware *fw;\r\nconst char fwname[] = "advansys/38C1600.bin";\r\nAdvPortAddr iop_base;\r\nushort warn_code;\r\nint begin_addr;\r\nint end_addr;\r\nushort code_sum;\r\nlong word;\r\nint i;\r\nint err;\r\nunsigned long chksum;\r\nushort scsi_cfg1;\r\nuchar byte;\r\nuchar tid;\r\nushort bios_mem[ASC_MC_BIOSLEN / 2];\r\nushort wdtr_able, sdtr_able, ppr_able, tagqng_able;\r\nuchar max_cmd[ASC_MAX_TID + 1];\r\nif (asc_dvc->err_code != 0) {\r\nreturn ADV_ERROR;\r\n}\r\nif (asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {\r\nasc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;\r\nreturn ADV_ERROR;\r\n}\r\nwarn_code = 0;\r\niop_base = asc_dvc->iop_base;\r\nfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\r\nAdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\r\nbios_mem[i]);\r\n}\r\nAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\r\nAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\r\nAdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\r\nAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\r\nfor (tid = 0; tid <= ASC_MAX_TID; tid++) {\r\nAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\r\nmax_cmd[tid]);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);\r\nmdelay(10);\r\nbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\r\nif ((byte & RAM_TEST_DONE) == 0\r\n|| (byte & 0x0F) != PRE_TEST_VALUE) {\r\nasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\r\nreturn ADV_ERROR;\r\n}\r\nAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\r\nmdelay(10);\r\nif (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)\r\n!= NORMAL_VALUE) {\r\nasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\r\nreturn ADV_ERROR;\r\n}\r\n}\r\nAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);\r\nmdelay(10);\r\nbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\r\nif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\r\nasc_dvc->bist_err_code = byte;\r\nasc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;\r\nreturn ADV_ERROR;\r\n}\r\nAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\r\nerr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to load image \"%s\" err %d\n",\r\nfwname, err);\r\nasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\r\nreturn err;\r\n}\r\nif (fw->size < 4) {\r\nprintk(KERN_ERR "Bogus length %zu in image \"%s\"\n",\r\nfw->size, fwname);\r\nrelease_firmware(fw);\r\nasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\r\nreturn -EINVAL;\r\n}\r\nchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\r\n(fw->data[1] << 8) | fw->data[0];\r\nasc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],\r\nfw->size - 4, ADV_38C1600_MEMSIZE,\r\nchksum);\r\nrelease_firmware(fw);\r\nif (asc_dvc->err_code)\r\nreturn ADV_ERROR;\r\nfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\r\nAdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\r\nbios_mem[i]);\r\n}\r\nAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\r\nAdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);\r\ncode_sum = 0;\r\nAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);\r\nfor (word = begin_addr; word < end_addr; word += 2) {\r\ncode_sum += AdvReadWordAutoIncLram(iop_base);\r\n}\r\nAdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);\r\nAdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,\r\nasc_dvc->cfg->mcode_date);\r\nAdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,\r\nasc_dvc->cfg->mcode_version);\r\nAdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C1600);\r\nscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\r\nAdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,\r\nscsi_cfg1 | DIS_TERM_DRV);\r\nif (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {\r\nAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\r\nword |= CONTROL_FLAG_IGNORE_PERR;\r\nAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\r\n}\r\nif ((asc_dvc->bios_ctrl & BIOS_CTRL_AIPP_DIS) == 0) {\r\nAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\r\nword |= CONTROL_FLAG_ENABLE_AIPP;\r\nAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\r\n}\r\nAdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,\r\nFIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);\r\nif ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\r\nAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,\r\nasc_dvc->wdtr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,\r\nasc_dvc->sdtr_able);\r\n}\r\nAdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,\r\nasc_dvc->cfg->disc_enable);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,\r\nPARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |\r\nasc_dvc->chip_scsi_id);\r\nscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\r\nif ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {\r\nasc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;\r\nreturn ADV_ERROR;\r\n}\r\nif (scsi_cfg1 & HVD) {\r\nasc_dvc->err_code |= ASC_IERR_HVD_DEVICE;\r\nreturn ADV_ERROR;\r\n}\r\nif ((asc_dvc->cfg->termination & TERM_SE) == 0) {\r\nstruct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);\r\nswitch (scsi_cfg1 & C_DET_SE) {\r\ncase 0x1:\r\ncase 0x2:\r\ncase 0x3:\r\nasc_dvc->cfg->termination |= TERM_SE;\r\nbreak;\r\ncase 0x0:\r\nif (PCI_FUNC(pdev->devfn) == 0) {\r\n} else {\r\nasc_dvc->cfg->termination |= TERM_SE_HI;\r\n}\r\nbreak;\r\n}\r\n}\r\nscsi_cfg1 &= ~TERM_SE;\r\nscsi_cfg1 |= (~asc_dvc->cfg->termination & TERM_SE);\r\nscsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,\r\nBIOS_EN | RAM_SZ_16KB);\r\nAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,\r\nADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));\r\nAdvBuildCarrierFreelist(asc_dvc);\r\nif ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {\r\nasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\r\nreturn ADV_ERROR;\r\n}\r\nasc_dvc->carr_freelist = (ADV_CARR_T *)\r\nADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));\r\nasc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);\r\nAdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);\r\nAdvWriteDWordRegister(iop_base, IOPDW_COMMA,\r\nle32_to_cpu(asc_dvc->icq_sp->carr_pa));\r\nif ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {\r\nasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\r\nreturn ADV_ERROR;\r\n}\r\nasc_dvc->carr_freelist = (ADV_CARR_T *)\r\nADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));\r\nasc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);\r\nAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);\r\nasc_dvc->carr_pending_cnt = 0;\r\nAdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,\r\n(ADV_INTR_ENABLE_HOST_INTR |\r\nADV_INTR_ENABLE_GLOBAL_INTR));\r\nAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);\r\nAdvWriteWordRegister(iop_base, IOPW_PC, word);\r\nAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);\r\nif (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\r\nif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==\r\n0x55AA) {\r\nAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\r\ntagqng_able);\r\nfor (tid = 0; tid <= ASC_MAX_TID; tid++) {\r\nAdvWriteByteLram(iop_base,\r\nASC_MC_NUMBER_OF_MAX_CMD + tid,\r\nmax_cmd[tid]);\r\n}\r\n} else {\r\nif (AdvResetSB(asc_dvc) != ADV_TRUE) {\r\nwarn_code = ASC_WARN_BUSRESET_ERROR;\r\n}\r\n}\r\n}\r\nreturn warn_code;\r\n}\r\nstatic int AdvResetChipAndSB(ADV_DVC_VAR *asc_dvc)\r\n{\r\nint status;\r\nushort wdtr_able, sdtr_able, tagqng_able;\r\nushort ppr_able = 0;\r\nuchar tid, max_cmd[ADV_MAX_TID + 1];\r\nAdvPortAddr iop_base;\r\nushort bios_sig;\r\niop_base = asc_dvc->iop_base;\r\nAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\r\nAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\r\nif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\r\nAdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\r\n}\r\nAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\r\nfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\r\nAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\r\nmax_cmd[tid]);\r\n}\r\nAdvReadWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);\r\nAdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, 0);\r\nAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_STOP);\r\nAdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);\r\nmdelay(100);\r\nAdvWriteWordRegister(iop_base, IOPW_CTRL_REG,\r\nADV_CTRL_REG_CMD_WR_IO_REG);\r\nasc_dvc->err_code = 0;\r\nif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\r\nstatus = AdvInitAsc38C1600Driver(asc_dvc);\r\n} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\r\nstatus = AdvInitAsc38C0800Driver(asc_dvc);\r\n} else {\r\nstatus = AdvInitAsc3550Driver(asc_dvc);\r\n}\r\nif (status == 0) {\r\nstatus = ADV_TRUE;\r\n} else {\r\nstatus = ADV_FALSE;\r\n}\r\nAdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);\r\nAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\r\nif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\r\nAdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\r\n}\r\nAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\r\nfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\r\nAdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\r\nmax_cmd[tid]);\r\n}\r\nreturn status;\r\n}\r\nstatic void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)\r\n{\r\nswitch (code) {\r\ncase ADV_ASYNC_SCSI_BUS_RESET_DET:\r\nASC_DBG(0, "ADV_ASYNC_SCSI_BUS_RESET_DET\n");\r\nbreak;\r\ncase ADV_ASYNC_RDMA_FAILURE:\r\nASC_DBG(0, "ADV_ASYNC_RDMA_FAILURE\n");\r\nAdvResetChipAndSB(adv_dvc_varp);\r\nbreak;\r\ncase ADV_HOST_SCSI_BUS_RESET:\r\nASC_DBG(0, "ADV_HOST_SCSI_BUS_RESET\n");\r\nbreak;\r\ndefault:\r\nASC_DBG(0, "unknown code 0x%x\n", code);\r\nbreak;\r\n}\r\n}\r\nstatic void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)\r\n{\r\nstruct asc_board *boardp;\r\nadv_req_t *reqp;\r\nadv_sgblk_t *sgblkp;\r\nstruct scsi_cmnd *scp;\r\nstruct Scsi_Host *shost;\r\nADV_DCNT resid_cnt;\r\nASC_DBG(1, "adv_dvc_varp 0x%lx, scsiqp 0x%lx\n",\r\n(ulong)adv_dvc_varp, (ulong)scsiqp);\r\nASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);\r\nreqp = (adv_req_t *)ADV_U32_TO_VADDR(scsiqp->srb_ptr);\r\nASC_DBG(1, "reqp 0x%lx\n", (ulong)reqp);\r\nif (reqp == NULL) {\r\nASC_PRINT("adv_isr_callback: reqp is NULL\n");\r\nreturn;\r\n}\r\nscp = reqp->cmndp;\r\nASC_DBG(1, "scp 0x%p\n", scp);\r\nif (scp == NULL) {\r\nASC_PRINT\r\n("adv_isr_callback: scp is NULL; adv_req_t dropped.\n");\r\nreturn;\r\n}\r\nASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);\r\nshost = scp->device->host;\r\nASC_STATS(shost, callback);\r\nASC_DBG(1, "shost 0x%p\n", shost);\r\nboardp = shost_priv(shost);\r\nBUG_ON(adv_dvc_varp != &boardp->dvc_var.adv_dvc_var);\r\nswitch (scsiqp->done_status) {\r\ncase QD_NO_ERROR:\r\nASC_DBG(2, "QD_NO_ERROR\n");\r\nscp->result = 0;\r\nresid_cnt = le32_to_cpu(scsiqp->data_cnt);\r\nif (scsi_bufflen(scp) != 0 && resid_cnt != 0 &&\r\nresid_cnt <= scsi_bufflen(scp)) {\r\nASC_DBG(1, "underrun condition %lu bytes\n",\r\n(ulong)resid_cnt);\r\nscsi_set_resid(scp, resid_cnt);\r\n}\r\nbreak;\r\ncase QD_WITH_ERROR:\r\nASC_DBG(2, "QD_WITH_ERROR\n");\r\nswitch (scsiqp->host_status) {\r\ncase QHSTA_NO_ERROR:\r\nif (scsiqp->scsi_status == SAM_STAT_CHECK_CONDITION) {\r\nASC_DBG(2, "SAM_STAT_CHECK_CONDITION\n");\r\nASC_DBG_PRT_SENSE(2, scp->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE);\r\nscp->result = DRIVER_BYTE(DRIVER_SENSE) |\r\nSTATUS_BYTE(scsiqp->scsi_status);\r\n} else {\r\nscp->result = STATUS_BYTE(scsiqp->scsi_status);\r\n}\r\nbreak;\r\ndefault:\r\nASC_DBG(1, "host_status 0x%x\n", scsiqp->host_status);\r\nscp->result = HOST_BYTE(DID_BAD_TARGET);\r\nbreak;\r\n}\r\nbreak;\r\ncase QD_ABORTED_BY_HOST:\r\nASC_DBG(1, "QD_ABORTED_BY_HOST\n");\r\nscp->result =\r\nHOST_BYTE(DID_ABORT) | STATUS_BYTE(scsiqp->scsi_status);\r\nbreak;\r\ndefault:\r\nASC_DBG(1, "done_status 0x%x\n", scsiqp->done_status);\r\nscp->result =\r\nHOST_BYTE(DID_ERROR) | STATUS_BYTE(scsiqp->scsi_status);\r\nbreak;\r\n}\r\nif ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&\r\nscsiqp->done_status == QD_NO_ERROR &&\r\nscsiqp->host_status == QHSTA_NO_ERROR) {\r\nboardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);\r\n}\r\nasc_scsi_done(scp);\r\nwhile ((sgblkp = reqp->sgblkp) != NULL) {\r\nreqp->sgblkp = sgblkp->next_sgblkp;\r\nsgblkp->next_sgblkp = boardp->adv_sgblkp;\r\nboardp->adv_sgblkp = sgblkp;\r\n}\r\nreqp->next_reqp = boardp->adv_reqp;\r\nboardp->adv_reqp = reqp;\r\nASC_DBG(1, "done\n");\r\n}\r\nstatic int AdvISR(ADV_DVC_VAR *asc_dvc)\r\n{\r\nAdvPortAddr iop_base;\r\nuchar int_stat;\r\nushort target_bit;\r\nADV_CARR_T *free_carrp;\r\nADV_VADDR irq_next_vpa;\r\nADV_SCSI_REQ_Q *scsiq;\r\niop_base = asc_dvc->iop_base;\r\nint_stat = AdvReadByteRegister(iop_base, IOPB_INTR_STATUS_REG);\r\nif ((int_stat & (ADV_INTR_STATUS_INTRA | ADV_INTR_STATUS_INTRB |\r\nADV_INTR_STATUS_INTRC)) == 0) {\r\nreturn ADV_FALSE;\r\n}\r\nif (int_stat & ADV_INTR_STATUS_INTRB) {\r\nuchar intrb_code;\r\nAdvReadByteLram(iop_base, ASC_MC_INTRB_CODE, intrb_code);\r\nif (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||\r\nasc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\r\nif (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&\r\nasc_dvc->carr_pending_cnt != 0) {\r\nAdvWriteByteRegister(iop_base, IOPB_TICKLE,\r\nADV_TICKLE_A);\r\nif (asc_dvc->chip_type == ADV_CHIP_ASC3550) {\r\nAdvWriteByteRegister(iop_base,\r\nIOPB_TICKLE,\r\nADV_TICKLE_NOP);\r\n}\r\n}\r\n}\r\nadv_async_callback(asc_dvc, intrb_code);\r\n}\r\nwhile (((irq_next_vpa =\r\nle32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ASC_RQ_DONE) != 0) {\r\nscsiq = (ADV_SCSI_REQ_Q *)\r\nADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->areq_vpa));\r\nif ((irq_next_vpa & ASC_RQ_GOOD) != 0) {\r\nscsiq->done_status = QD_NO_ERROR;\r\nscsiq->host_status = scsiq->scsi_status = 0;\r\nscsiq->data_cnt = 0L;\r\n}\r\nfree_carrp = asc_dvc->irq_sp;\r\nasc_dvc->irq_sp = (ADV_CARR_T *)\r\nADV_U32_TO_VADDR(ASC_GET_CARRP(irq_next_vpa));\r\nfree_carrp->next_vpa =\r\ncpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));\r\nasc_dvc->carr_freelist = free_carrp;\r\nasc_dvc->carr_pending_cnt--;\r\ntarget_bit = ADV_TID_TO_TIDMASK(scsiq->target_id);\r\nscsiq->cntl = 0;\r\nscsiq->a_flag |= ADV_SCSIQ_DONE;\r\nadv_isr_callback(asc_dvc, scsiq);\r\n}\r\nreturn ADV_TRUE;\r\n}\r\nstatic int AscSetLibErrorCode(ASC_DVC_VAR *asc_dvc, ushort err_code)\r\n{\r\nif (asc_dvc->err_code == 0) {\r\nasc_dvc->err_code = err_code;\r\nAscWriteLramWord(asc_dvc->iop_base, ASCV_ASCDVC_ERR_CODE_W,\r\nerr_code);\r\n}\r\nreturn err_code;\r\n}\r\nstatic void AscAckInterrupt(PortAddr iop_base)\r\n{\r\nuchar host_flag;\r\nuchar risc_flag;\r\nushort loop;\r\nloop = 0;\r\ndo {\r\nrisc_flag = AscReadLramByte(iop_base, ASCV_RISC_FLAG_B);\r\nif (loop++ > 0x7FFF) {\r\nbreak;\r\n}\r\n} while ((risc_flag & ASC_RISC_FLAG_GEN_INT) != 0);\r\nhost_flag =\r\nAscReadLramByte(iop_base,\r\nASCV_HOST_FLAG_B) & (~ASC_HOST_FLAG_ACK_INT);\r\nAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,\r\n(uchar)(host_flag | ASC_HOST_FLAG_ACK_INT));\r\nAscSetChipStatus(iop_base, CIW_INT_ACK);\r\nloop = 0;\r\nwhile (AscGetChipStatus(iop_base) & CSW_INT_PENDING) {\r\nAscSetChipStatus(iop_base, CIW_INT_ACK);\r\nif (loop++ > 3) {\r\nbreak;\r\n}\r\n}\r\nAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);\r\n}\r\nstatic uchar AscGetSynPeriodIndex(ASC_DVC_VAR *asc_dvc, uchar syn_time)\r\n{\r\nconst uchar *period_table;\r\nint max_index;\r\nint min_index;\r\nint i;\r\nperiod_table = asc_dvc->sdtr_period_tbl;\r\nmax_index = (int)asc_dvc->max_sdtr_index;\r\nmin_index = (int)asc_dvc->min_sdtr_index;\r\nif ((syn_time <= period_table[max_index])) {\r\nfor (i = min_index; i < (max_index - 1); i++) {\r\nif (syn_time <= period_table[i]) {\r\nreturn (uchar)i;\r\n}\r\n}\r\nreturn (uchar)max_index;\r\n} else {\r\nreturn (uchar)(max_index + 1);\r\n}\r\n}\r\nstatic uchar\r\nAscMsgOutSDTR(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar sdtr_offset)\r\n{\r\nEXT_MSG sdtr_buf;\r\nuchar sdtr_period_index;\r\nPortAddr iop_base;\r\niop_base = asc_dvc->iop_base;\r\nsdtr_buf.msg_type = EXTENDED_MESSAGE;\r\nsdtr_buf.msg_len = MS_SDTR_LEN;\r\nsdtr_buf.msg_req = EXTENDED_SDTR;\r\nsdtr_buf.xfer_period = sdtr_period;\r\nsdtr_offset &= ASC_SYN_MAX_OFFSET;\r\nsdtr_buf.req_ack_offset = sdtr_offset;\r\nsdtr_period_index = AscGetSynPeriodIndex(asc_dvc, sdtr_period);\r\nif (sdtr_period_index <= asc_dvc->max_sdtr_index) {\r\nAscMemWordCopyPtrToLram(iop_base, ASCV_MSGOUT_BEG,\r\n(uchar *)&sdtr_buf,\r\nsizeof(EXT_MSG) >> 1);\r\nreturn ((sdtr_period_index << 4) | sdtr_offset);\r\n} else {\r\nsdtr_buf.req_ack_offset = 0;\r\nAscMemWordCopyPtrToLram(iop_base, ASCV_MSGOUT_BEG,\r\n(uchar *)&sdtr_buf,\r\nsizeof(EXT_MSG) >> 1);\r\nreturn 0;\r\n}\r\n}\r\nstatic uchar\r\nAscCalSDTRData(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar syn_offset)\r\n{\r\nuchar byte;\r\nuchar sdtr_period_ix;\r\nsdtr_period_ix = AscGetSynPeriodIndex(asc_dvc, sdtr_period);\r\nif (sdtr_period_ix > asc_dvc->max_sdtr_index)\r\nreturn 0xFF;\r\nbyte = (sdtr_period_ix << 4) | (syn_offset & ASC_SYN_MAX_OFFSET);\r\nreturn byte;\r\n}\r\nstatic int AscSetChipSynRegAtID(PortAddr iop_base, uchar id, uchar sdtr_data)\r\n{\r\nASC_SCSI_BIT_ID_TYPE org_id;\r\nint i;\r\nint sta = TRUE;\r\nAscSetBank(iop_base, 1);\r\norg_id = AscReadChipDvcID(iop_base);\r\nfor (i = 0; i <= ASC_MAX_TID; i++) {\r\nif (org_id == (0x01 << i))\r\nbreak;\r\n}\r\norg_id = (ASC_SCSI_BIT_ID_TYPE) i;\r\nAscWriteChipDvcID(iop_base, id);\r\nif (AscReadChipDvcID(iop_base) == (0x01 << id)) {\r\nAscSetBank(iop_base, 0);\r\nAscSetChipSyn(iop_base, sdtr_data);\r\nif (AscGetChipSyn(iop_base) != sdtr_data) {\r\nsta = FALSE;\r\n}\r\n} else {\r\nsta = FALSE;\r\n}\r\nAscSetBank(iop_base, 1);\r\nAscWriteChipDvcID(iop_base, org_id);\r\nAscSetBank(iop_base, 0);\r\nreturn (sta);\r\n}\r\nstatic void AscSetChipSDTR(PortAddr iop_base, uchar sdtr_data, uchar tid_no)\r\n{\r\nAscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);\r\nAscPutMCodeSDTRDoneAtID(iop_base, tid_no, sdtr_data);\r\n}\r\nstatic int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)\r\n{\r\nEXT_MSG ext_msg;\r\nEXT_MSG out_msg;\r\nushort halt_q_addr;\r\nint sdtr_accept;\r\nushort int_halt_code;\r\nASC_SCSI_BIT_ID_TYPE scsi_busy;\r\nASC_SCSI_BIT_ID_TYPE target_id;\r\nPortAddr iop_base;\r\nuchar tag_code;\r\nuchar q_status;\r\nuchar halt_qp;\r\nuchar sdtr_data;\r\nuchar target_ix;\r\nuchar q_cntl, tid_no;\r\nuchar cur_dvc_qng;\r\nuchar asyn_sdtr;\r\nuchar scsi_status;\r\nstruct asc_board *boardp;\r\nBUG_ON(!asc_dvc->drv_ptr);\r\nboardp = asc_dvc->drv_ptr;\r\niop_base = asc_dvc->iop_base;\r\nint_halt_code = AscReadLramWord(iop_base, ASCV_HALTCODE_W);\r\nhalt_qp = AscReadLramByte(iop_base, ASCV_CURCDB_B);\r\nhalt_q_addr = ASC_QNO_TO_QADDR(halt_qp);\r\ntarget_ix = AscReadLramByte(iop_base,\r\n(ushort)(halt_q_addr +\r\n(ushort)ASC_SCSIQ_B_TARGET_IX));\r\nq_cntl = AscReadLramByte(iop_base,\r\n(ushort)(halt_q_addr + (ushort)ASC_SCSIQ_B_CNTL));\r\ntid_no = ASC_TIX_TO_TID(target_ix);\r\ntarget_id = (uchar)ASC_TID_TO_TARGET_ID(tid_no);\r\nif (asc_dvc->pci_fix_asyn_xfer & target_id) {\r\nasyn_sdtr = ASYN_SDTR_DATA_FIX_PCI_REV_AB;\r\n} else {\r\nasyn_sdtr = 0;\r\n}\r\nif (int_halt_code == ASC_HALT_DISABLE_ASYN_USE_SYN_FIX) {\r\nif (asc_dvc->pci_fix_asyn_xfer & target_id) {\r\nAscSetChipSDTR(iop_base, 0, tid_no);\r\nboardp->sdtr_data[tid_no] = 0;\r\n}\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\r\nreturn (0);\r\n} else if (int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX) {\r\nif (asc_dvc->pci_fix_asyn_xfer & target_id) {\r\nAscSetChipSDTR(iop_base, asyn_sdtr, tid_no);\r\nboardp->sdtr_data[tid_no] = asyn_sdtr;\r\n}\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\r\nreturn (0);\r\n} else if (int_halt_code == ASC_HALT_EXTMSG_IN) {\r\nAscMemWordCopyPtrFromLram(iop_base,\r\nASCV_MSGIN_BEG,\r\n(uchar *)&ext_msg,\r\nsizeof(EXT_MSG) >> 1);\r\nif (ext_msg.msg_type == EXTENDED_MESSAGE &&\r\next_msg.msg_req == EXTENDED_SDTR &&\r\next_msg.msg_len == MS_SDTR_LEN) {\r\nsdtr_accept = TRUE;\r\nif ((ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET)) {\r\nsdtr_accept = FALSE;\r\next_msg.req_ack_offset = ASC_SYN_MAX_OFFSET;\r\n}\r\nif ((ext_msg.xfer_period <\r\nasc_dvc->sdtr_period_tbl[asc_dvc->min_sdtr_index])\r\n|| (ext_msg.xfer_period >\r\nasc_dvc->sdtr_period_tbl[asc_dvc->\r\nmax_sdtr_index])) {\r\nsdtr_accept = FALSE;\r\next_msg.xfer_period =\r\nasc_dvc->sdtr_period_tbl[asc_dvc->\r\nmin_sdtr_index];\r\n}\r\nif (sdtr_accept) {\r\nsdtr_data =\r\nAscCalSDTRData(asc_dvc, ext_msg.xfer_period,\r\next_msg.req_ack_offset);\r\nif ((sdtr_data == 0xFF)) {\r\nq_cntl |= QC_MSG_OUT;\r\nasc_dvc->init_sdtr &= ~target_id;\r\nasc_dvc->sdtr_done &= ~target_id;\r\nAscSetChipSDTR(iop_base, asyn_sdtr,\r\ntid_no);\r\nboardp->sdtr_data[tid_no] = asyn_sdtr;\r\n}\r\n}\r\nif (ext_msg.req_ack_offset == 0) {\r\nq_cntl &= ~QC_MSG_OUT;\r\nasc_dvc->init_sdtr &= ~target_id;\r\nasc_dvc->sdtr_done &= ~target_id;\r\nAscSetChipSDTR(iop_base, asyn_sdtr, tid_no);\r\n} else {\r\nif (sdtr_accept && (q_cntl & QC_MSG_OUT)) {\r\nq_cntl &= ~QC_MSG_OUT;\r\nasc_dvc->sdtr_done |= target_id;\r\nasc_dvc->init_sdtr |= target_id;\r\nasc_dvc->pci_fix_asyn_xfer &=\r\n~target_id;\r\nsdtr_data =\r\nAscCalSDTRData(asc_dvc,\r\next_msg.xfer_period,\r\next_msg.\r\nreq_ack_offset);\r\nAscSetChipSDTR(iop_base, sdtr_data,\r\ntid_no);\r\nboardp->sdtr_data[tid_no] = sdtr_data;\r\n} else {\r\nq_cntl |= QC_MSG_OUT;\r\nAscMsgOutSDTR(asc_dvc,\r\next_msg.xfer_period,\r\next_msg.req_ack_offset);\r\nasc_dvc->pci_fix_asyn_xfer &=\r\n~target_id;\r\nsdtr_data =\r\nAscCalSDTRData(asc_dvc,\r\next_msg.xfer_period,\r\next_msg.\r\nreq_ack_offset);\r\nAscSetChipSDTR(iop_base, sdtr_data,\r\ntid_no);\r\nboardp->sdtr_data[tid_no] = sdtr_data;\r\nasc_dvc->sdtr_done |= target_id;\r\nasc_dvc->init_sdtr |= target_id;\r\n}\r\n}\r\nAscWriteLramByte(iop_base,\r\n(ushort)(halt_q_addr +\r\n(ushort)ASC_SCSIQ_B_CNTL),\r\nq_cntl);\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\r\nreturn (0);\r\n} else if (ext_msg.msg_type == EXTENDED_MESSAGE &&\r\next_msg.msg_req == EXTENDED_WDTR &&\r\next_msg.msg_len == MS_WDTR_LEN) {\r\next_msg.wdtr_width = 0;\r\nAscMemWordCopyPtrToLram(iop_base,\r\nASCV_MSGOUT_BEG,\r\n(uchar *)&ext_msg,\r\nsizeof(EXT_MSG) >> 1);\r\nq_cntl |= QC_MSG_OUT;\r\nAscWriteLramByte(iop_base,\r\n(ushort)(halt_q_addr +\r\n(ushort)ASC_SCSIQ_B_CNTL),\r\nq_cntl);\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\r\nreturn (0);\r\n} else {\r\next_msg.msg_type = MESSAGE_REJECT;\r\nAscMemWordCopyPtrToLram(iop_base,\r\nASCV_MSGOUT_BEG,\r\n(uchar *)&ext_msg,\r\nsizeof(EXT_MSG) >> 1);\r\nq_cntl |= QC_MSG_OUT;\r\nAscWriteLramByte(iop_base,\r\n(ushort)(halt_q_addr +\r\n(ushort)ASC_SCSIQ_B_CNTL),\r\nq_cntl);\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\r\nreturn (0);\r\n}\r\n} else if (int_halt_code == ASC_HALT_CHK_CONDITION) {\r\nq_cntl |= QC_REQ_SENSE;\r\nif ((asc_dvc->init_sdtr & target_id) != 0) {\r\nasc_dvc->sdtr_done &= ~target_id;\r\nsdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);\r\nq_cntl |= QC_MSG_OUT;\r\nAscMsgOutSDTR(asc_dvc,\r\nasc_dvc->\r\nsdtr_period_tbl[(sdtr_data >> 4) &\r\n(uchar)(asc_dvc->\r\nmax_sdtr_index -\r\n1)],\r\n(uchar)(sdtr_data & (uchar)\r\nASC_SYN_MAX_OFFSET));\r\n}\r\nAscWriteLramByte(iop_base,\r\n(ushort)(halt_q_addr +\r\n(ushort)ASC_SCSIQ_B_CNTL), q_cntl);\r\ntag_code = AscReadLramByte(iop_base,\r\n(ushort)(halt_q_addr + (ushort)\r\nASC_SCSIQ_B_TAG_CODE));\r\ntag_code &= 0xDC;\r\nif ((asc_dvc->pci_fix_asyn_xfer & target_id)\r\n&& !(asc_dvc->pci_fix_asyn_xfer_always & target_id)\r\n) {\r\ntag_code |= (ASC_TAG_FLAG_DISABLE_DISCONNECT\r\n| ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX);\r\n}\r\nAscWriteLramByte(iop_base,\r\n(ushort)(halt_q_addr +\r\n(ushort)ASC_SCSIQ_B_TAG_CODE),\r\ntag_code);\r\nq_status = AscReadLramByte(iop_base,\r\n(ushort)(halt_q_addr + (ushort)\r\nASC_SCSIQ_B_STATUS));\r\nq_status |= (QS_READY | QS_BUSY);\r\nAscWriteLramByte(iop_base,\r\n(ushort)(halt_q_addr +\r\n(ushort)ASC_SCSIQ_B_STATUS),\r\nq_status);\r\nscsi_busy = AscReadLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B);\r\nscsi_busy &= ~target_id;\r\nAscWriteLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B, scsi_busy);\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\r\nreturn (0);\r\n} else if (int_halt_code == ASC_HALT_SDTR_REJECTED) {\r\nAscMemWordCopyPtrFromLram(iop_base,\r\nASCV_MSGOUT_BEG,\r\n(uchar *)&out_msg,\r\nsizeof(EXT_MSG) >> 1);\r\nif ((out_msg.msg_type == EXTENDED_MESSAGE) &&\r\n(out_msg.msg_len == MS_SDTR_LEN) &&\r\n(out_msg.msg_req == EXTENDED_SDTR)) {\r\nasc_dvc->init_sdtr &= ~target_id;\r\nasc_dvc->sdtr_done &= ~target_id;\r\nAscSetChipSDTR(iop_base, asyn_sdtr, tid_no);\r\nboardp->sdtr_data[tid_no] = asyn_sdtr;\r\n}\r\nq_cntl &= ~QC_MSG_OUT;\r\nAscWriteLramByte(iop_base,\r\n(ushort)(halt_q_addr +\r\n(ushort)ASC_SCSIQ_B_CNTL), q_cntl);\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\r\nreturn (0);\r\n} else if (int_halt_code == ASC_HALT_SS_QUEUE_FULL) {\r\nscsi_status = AscReadLramByte(iop_base,\r\n(ushort)((ushort)halt_q_addr +\r\n(ushort)\r\nASC_SCSIQ_SCSI_STATUS));\r\ncur_dvc_qng =\r\nAscReadLramByte(iop_base,\r\n(ushort)((ushort)ASC_QADR_BEG +\r\n(ushort)target_ix));\r\nif ((cur_dvc_qng > 0) && (asc_dvc->cur_dvc_qng[tid_no] > 0)) {\r\nscsi_busy = AscReadLramByte(iop_base,\r\n(ushort)ASCV_SCSIBUSY_B);\r\nscsi_busy |= target_id;\r\nAscWriteLramByte(iop_base,\r\n(ushort)ASCV_SCSIBUSY_B, scsi_busy);\r\nasc_dvc->queue_full_or_busy |= target_id;\r\nif (scsi_status == SAM_STAT_TASK_SET_FULL) {\r\nif (cur_dvc_qng > ASC_MIN_TAGGED_CMD) {\r\ncur_dvc_qng -= 1;\r\nasc_dvc->max_dvc_qng[tid_no] =\r\ncur_dvc_qng;\r\nAscWriteLramByte(iop_base,\r\n(ushort)((ushort)\r\nASCV_MAX_DVC_QNG_BEG\r\n+ (ushort)\r\ntid_no),\r\ncur_dvc_qng);\r\nboardp->queue_full |= target_id;\r\nboardp->queue_full_cnt[tid_no] =\r\ncur_dvc_qng;\r\n}\r\n}\r\n}\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\r\nreturn (0);\r\n}\r\n#if CC_VERY_LONG_SG_LIST\r\nelse if (int_halt_code == ASC_HALT_HOST_COPY_SG_LIST_TO_RISC) {\r\nuchar q_no;\r\nushort q_addr;\r\nuchar sg_wk_q_no;\r\nuchar first_sg_wk_q_no;\r\nASC_SCSI_Q *scsiq;\r\nASC_SG_HEAD *sg_head;\r\nASC_SG_LIST_Q scsi_sg_q;\r\nushort sg_list_dwords;\r\nushort sg_entry_cnt;\r\nuchar next_qp;\r\nint i;\r\nq_no = AscReadLramByte(iop_base, (ushort)ASCV_REQ_SG_LIST_QP);\r\nif (q_no == ASC_QLINK_END)\r\nreturn 0;\r\nq_addr = ASC_QNO_TO_QADDR(q_no);\r\nscsiq = (ASC_SCSI_Q *)\r\nASC_SRB2SCSIQ(ASC_U32_TO_VADDR(AscReadLramDWord(iop_base,\r\n(ushort)\r\n(q_addr +\r\nASC_SCSIQ_D_SRBPTR))));\r\nsg_wk_q_no = AscReadLramByte(iop_base,\r\n(ushort)(q_addr +\r\nASC_SCSIQ_B_SG_WK_QP));\r\nfirst_sg_wk_q_no = AscReadLramByte(iop_base,\r\n(ushort)(q_addr +\r\nASC_SCSIQ_B_FIRST_SG_WK_QP));\r\nAscWriteLramByte(iop_base,\r\n(ushort)(q_addr +\r\n(ushort)ASC_SCSIQ_B_SG_WK_QP),\r\nfirst_sg_wk_q_no);\r\nsg_head = scsiq->sg_head;\r\nif (scsiq->remain_sg_entry_cnt > (ASC_MAX_SG_LIST - 1)) {\r\nsg_entry_cnt = ASC_MAX_SG_LIST - 1;\r\nscsiq->remain_sg_entry_cnt -= (ASC_MAX_SG_LIST - 1);\r\n} else {\r\nsg_entry_cnt = scsiq->remain_sg_entry_cnt;\r\nscsiq->remain_sg_entry_cnt = 0;\r\n}\r\nnext_qp = first_sg_wk_q_no;\r\nq_addr = ASC_QNO_TO_QADDR(next_qp);\r\nscsi_sg_q.sg_head_qp = q_no;\r\nscsi_sg_q.cntl = QCSG_SG_XFER_LIST;\r\nfor (i = 0; i < sg_head->queue_cnt; i++) {\r\nscsi_sg_q.seq_no = i + 1;\r\nif (sg_entry_cnt > ASC_SG_LIST_PER_Q) {\r\nsg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);\r\nsg_entry_cnt -= ASC_SG_LIST_PER_Q;\r\nscsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1;\r\nscsi_sg_q.sg_cur_list_cnt =\r\nASC_SG_LIST_PER_Q - 1;\r\n} else {\r\nif (scsiq->remain_sg_entry_cnt != 0) {\r\nscsi_sg_q.cntl |= QCSG_SG_XFER_MORE;\r\n} else {\r\nscsi_sg_q.cntl |= QCSG_SG_XFER_END;\r\n}\r\nsg_list_dwords = sg_entry_cnt << 1;\r\nscsi_sg_q.sg_list_cnt = sg_entry_cnt - 1;\r\nscsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1;\r\nsg_entry_cnt = 0;\r\n}\r\nscsi_sg_q.q_no = next_qp;\r\nAscMemWordCopyPtrToLram(iop_base,\r\nq_addr + ASC_SCSIQ_SGHD_CPY_BEG,\r\n(uchar *)&scsi_sg_q,\r\nsizeof(ASC_SG_LIST_Q) >> 1);\r\nAscMemDWordCopyPtrToLram(iop_base,\r\nq_addr + ASC_SGQ_LIST_BEG,\r\n(uchar *)&sg_head->\r\nsg_list[scsiq->next_sg_index],\r\nsg_list_dwords);\r\nscsiq->next_sg_index += ASC_SG_LIST_PER_Q;\r\nif (scsi_sg_q.cntl & QCSG_SG_XFER_END) {\r\nbreak;\r\n}\r\nnext_qp = AscReadLramByte(iop_base,\r\n(ushort)(q_addr +\r\nASC_SCSIQ_B_FWD));\r\nq_addr = ASC_QNO_TO_QADDR(next_qp);\r\n}\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\r\nreturn (0);\r\n}\r\n#endif\r\nreturn (0);\r\n}\r\nstatic void\r\nDvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)\r\n{\r\nint i;\r\nushort word;\r\nAscSetChipLramAddr(iop_base, s_addr);\r\nfor (i = 0; i < 2 * words; i += 2) {\r\nif (i == 10) {\r\ncontinue;\r\n}\r\nword = inpw(iop_base + IOP_RAM_DATA);\r\ninbuf[i] = word & 0xff;\r\ninbuf[i + 1] = (word >> 8) & 0xff;\r\n}\r\nASC_DBG_PRT_HEX(2, "DvcGetQinfo", inbuf, 2 * words);\r\n}\r\nstatic uchar\r\n_AscCopyLramScsiDoneQ(PortAddr iop_base,\r\nushort q_addr,\r\nASC_QDONE_INFO *scsiq, ASC_DCNT max_dma_count)\r\n{\r\nushort _val;\r\nuchar sg_queue_cnt;\r\nDvcGetQinfo(iop_base,\r\nq_addr + ASC_SCSIQ_DONE_INFO_BEG,\r\n(uchar *)scsiq,\r\n(sizeof(ASC_SCSIQ_2) + sizeof(ASC_SCSIQ_3)) / 2);\r\n_val = AscReadLramWord(iop_base,\r\n(ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS));\r\nscsiq->q_status = (uchar)_val;\r\nscsiq->q_no = (uchar)(_val >> 8);\r\n_val = AscReadLramWord(iop_base,\r\n(ushort)(q_addr + (ushort)ASC_SCSIQ_B_CNTL));\r\nscsiq->cntl = (uchar)_val;\r\nsg_queue_cnt = (uchar)(_val >> 8);\r\n_val = AscReadLramWord(iop_base,\r\n(ushort)(q_addr +\r\n(ushort)ASC_SCSIQ_B_SENSE_LEN));\r\nscsiq->sense_len = (uchar)_val;\r\nscsiq->extra_bytes = (uchar)(_val >> 8);\r\nscsiq->remain_bytes = (((ADV_DCNT)AscReadLramWord(iop_base,\r\n(ushort)(q_addr +\r\n(ushort)\r\nASC_SCSIQ_W_ALT_DC1)))\r\n<< 16);\r\nscsiq->remain_bytes += AscReadLramWord(iop_base,\r\n(ushort)(q_addr + (ushort)\r\nASC_SCSIQ_DW_REMAIN_XFER_CNT));\r\nscsiq->remain_bytes &= max_dma_count;\r\nreturn sg_queue_cnt;\r\n}\r\nstatic void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)\r\n{\r\nstruct asc_board *boardp;\r\nstruct scsi_cmnd *scp;\r\nstruct Scsi_Host *shost;\r\nASC_DBG(1, "asc_dvc_varp 0x%p, qdonep 0x%p\n", asc_dvc_varp, qdonep);\r\nASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);\r\nscp = advansys_srb_to_ptr(asc_dvc_varp, qdonep->d2.srb_ptr);\r\nif (!scp)\r\nreturn;\r\nASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);\r\nshost = scp->device->host;\r\nASC_STATS(shost, callback);\r\nASC_DBG(1, "shost 0x%p\n", shost);\r\nboardp = shost_priv(shost);\r\nBUG_ON(asc_dvc_varp != &boardp->dvc_var.asc_dvc_var);\r\ndma_unmap_single(boardp->dev, scp->SCp.dma_handle,\r\nSCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\r\nswitch (qdonep->d3.done_stat) {\r\ncase QD_NO_ERROR:\r\nASC_DBG(2, "QD_NO_ERROR\n");\r\nscp->result = 0;\r\nif (scsi_bufflen(scp) != 0 && qdonep->remain_bytes != 0 &&\r\nqdonep->remain_bytes <= scsi_bufflen(scp)) {\r\nASC_DBG(1, "underrun condition %u bytes\n",\r\n(unsigned)qdonep->remain_bytes);\r\nscsi_set_resid(scp, qdonep->remain_bytes);\r\n}\r\nbreak;\r\ncase QD_WITH_ERROR:\r\nASC_DBG(2, "QD_WITH_ERROR\n");\r\nswitch (qdonep->d3.host_stat) {\r\ncase QHSTA_NO_ERROR:\r\nif (qdonep->d3.scsi_stat == SAM_STAT_CHECK_CONDITION) {\r\nASC_DBG(2, "SAM_STAT_CHECK_CONDITION\n");\r\nASC_DBG_PRT_SENSE(2, scp->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE);\r\nscp->result = DRIVER_BYTE(DRIVER_SENSE) |\r\nSTATUS_BYTE(qdonep->d3.scsi_stat);\r\n} else {\r\nscp->result = STATUS_BYTE(qdonep->d3.scsi_stat);\r\n}\r\nbreak;\r\ndefault:\r\nASC_DBG(1, "host_stat 0x%x\n", qdonep->d3.host_stat);\r\nscp->result = HOST_BYTE(DID_BAD_TARGET);\r\nbreak;\r\n}\r\nbreak;\r\ncase QD_ABORTED_BY_HOST:\r\nASC_DBG(1, "QD_ABORTED_BY_HOST\n");\r\nscp->result =\r\nHOST_BYTE(DID_ABORT) | MSG_BYTE(qdonep->d3.\r\nscsi_msg) |\r\nSTATUS_BYTE(qdonep->d3.scsi_stat);\r\nbreak;\r\ndefault:\r\nASC_DBG(1, "done_stat 0x%x\n", qdonep->d3.done_stat);\r\nscp->result =\r\nHOST_BYTE(DID_ERROR) | MSG_BYTE(qdonep->d3.\r\nscsi_msg) |\r\nSTATUS_BYTE(qdonep->d3.scsi_stat);\r\nbreak;\r\n}\r\nif ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&\r\nqdonep->d3.done_stat == QD_NO_ERROR &&\r\nqdonep->d3.host_stat == QHSTA_NO_ERROR) {\r\nboardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);\r\n}\r\nasc_scsi_done(scp);\r\n}\r\nstatic int AscIsrQDone(ASC_DVC_VAR *asc_dvc)\r\n{\r\nuchar next_qp;\r\nuchar n_q_used;\r\nuchar sg_list_qp;\r\nuchar sg_queue_cnt;\r\nuchar q_cnt;\r\nuchar done_q_tail;\r\nuchar tid_no;\r\nASC_SCSI_BIT_ID_TYPE scsi_busy;\r\nASC_SCSI_BIT_ID_TYPE target_id;\r\nPortAddr iop_base;\r\nushort q_addr;\r\nushort sg_q_addr;\r\nuchar cur_target_qng;\r\nASC_QDONE_INFO scsiq_buf;\r\nASC_QDONE_INFO *scsiq;\r\nint false_overrun;\r\niop_base = asc_dvc->iop_base;\r\nn_q_used = 1;\r\nscsiq = (ASC_QDONE_INFO *)&scsiq_buf;\r\ndone_q_tail = (uchar)AscGetVarDoneQTail(iop_base);\r\nq_addr = ASC_QNO_TO_QADDR(done_q_tail);\r\nnext_qp = AscReadLramByte(iop_base,\r\n(ushort)(q_addr + (ushort)ASC_SCSIQ_B_FWD));\r\nif (next_qp != ASC_QLINK_END) {\r\nAscPutVarDoneQTail(iop_base, next_qp);\r\nq_addr = ASC_QNO_TO_QADDR(next_qp);\r\nsg_queue_cnt = _AscCopyLramScsiDoneQ(iop_base, q_addr, scsiq,\r\nasc_dvc->max_dma_count);\r\nAscWriteLramByte(iop_base,\r\n(ushort)(q_addr +\r\n(ushort)ASC_SCSIQ_B_STATUS),\r\n(uchar)(scsiq->\r\nq_status & (uchar)~(QS_READY |\r\nQS_ABORTED)));\r\ntid_no = ASC_TIX_TO_TID(scsiq->d2.target_ix);\r\ntarget_id = ASC_TIX_TO_TARGET_ID(scsiq->d2.target_ix);\r\nif ((scsiq->cntl & QC_SG_HEAD) != 0) {\r\nsg_q_addr = q_addr;\r\nsg_list_qp = next_qp;\r\nfor (q_cnt = 0; q_cnt < sg_queue_cnt; q_cnt++) {\r\nsg_list_qp = AscReadLramByte(iop_base,\r\n(ushort)(sg_q_addr\r\n+ (ushort)\r\nASC_SCSIQ_B_FWD));\r\nsg_q_addr = ASC_QNO_TO_QADDR(sg_list_qp);\r\nif (sg_list_qp == ASC_QLINK_END) {\r\nAscSetLibErrorCode(asc_dvc,\r\nASCQ_ERR_SG_Q_LINKS);\r\nscsiq->d3.done_stat = QD_WITH_ERROR;\r\nscsiq->d3.host_stat =\r\nQHSTA_D_QDONE_SG_LIST_CORRUPTED;\r\ngoto FATAL_ERR_QDONE;\r\n}\r\nAscWriteLramByte(iop_base,\r\n(ushort)(sg_q_addr + (ushort)\r\nASC_SCSIQ_B_STATUS),\r\nQS_FREE);\r\n}\r\nn_q_used = sg_queue_cnt + 1;\r\nAscPutVarDoneQTail(iop_base, sg_list_qp);\r\n}\r\nif (asc_dvc->queue_full_or_busy & target_id) {\r\ncur_target_qng = AscReadLramByte(iop_base,\r\n(ushort)((ushort)\r\nASC_QADR_BEG\r\n+ (ushort)\r\nscsiq->d2.\r\ntarget_ix));\r\nif (cur_target_qng < asc_dvc->max_dvc_qng[tid_no]) {\r\nscsi_busy = AscReadLramByte(iop_base, (ushort)\r\nASCV_SCSIBUSY_B);\r\nscsi_busy &= ~target_id;\r\nAscWriteLramByte(iop_base,\r\n(ushort)ASCV_SCSIBUSY_B,\r\nscsi_busy);\r\nasc_dvc->queue_full_or_busy &= ~target_id;\r\n}\r\n}\r\nif (asc_dvc->cur_total_qng >= n_q_used) {\r\nasc_dvc->cur_total_qng -= n_q_used;\r\nif (asc_dvc->cur_dvc_qng[tid_no] != 0) {\r\nasc_dvc->cur_dvc_qng[tid_no]--;\r\n}\r\n} else {\r\nAscSetLibErrorCode(asc_dvc, ASCQ_ERR_CUR_QNG);\r\nscsiq->d3.done_stat = QD_WITH_ERROR;\r\ngoto FATAL_ERR_QDONE;\r\n}\r\nif ((scsiq->d2.srb_ptr == 0UL) ||\r\n((scsiq->q_status & QS_ABORTED) != 0)) {\r\nreturn (0x11);\r\n} else if (scsiq->q_status == QS_DONE) {\r\nfalse_overrun = FALSE;\r\nif (scsiq->extra_bytes != 0) {\r\nscsiq->remain_bytes +=\r\n(ADV_DCNT)scsiq->extra_bytes;\r\n}\r\nif (scsiq->d3.done_stat == QD_WITH_ERROR) {\r\nif (scsiq->d3.host_stat ==\r\nQHSTA_M_DATA_OVER_RUN) {\r\nif ((scsiq->\r\ncntl & (QC_DATA_IN | QC_DATA_OUT))\r\n== 0) {\r\nscsiq->d3.done_stat =\r\nQD_NO_ERROR;\r\nscsiq->d3.host_stat =\r\nQHSTA_NO_ERROR;\r\n} else if (false_overrun) {\r\nscsiq->d3.done_stat =\r\nQD_NO_ERROR;\r\nscsiq->d3.host_stat =\r\nQHSTA_NO_ERROR;\r\n}\r\n} else if (scsiq->d3.host_stat ==\r\nQHSTA_M_HUNG_REQ_SCSI_BUS_RESET) {\r\nAscStopChip(iop_base);\r\nAscSetChipControl(iop_base,\r\n(uchar)(CC_SCSI_RESET\r\n| CC_HALT));\r\nudelay(60);\r\nAscSetChipControl(iop_base, CC_HALT);\r\nAscSetChipStatus(iop_base,\r\nCIW_CLR_SCSI_RESET_INT);\r\nAscSetChipStatus(iop_base, 0);\r\nAscSetChipControl(iop_base, 0);\r\n}\r\n}\r\nif ((scsiq->cntl & QC_NO_CALLBACK) == 0) {\r\nasc_isr_callback(asc_dvc, scsiq);\r\n} else {\r\nif ((AscReadLramByte(iop_base,\r\n(ushort)(q_addr + (ushort)\r\nASC_SCSIQ_CDB_BEG))\r\n== START_STOP)) {\r\nasc_dvc->unit_not_ready &= ~target_id;\r\nif (scsiq->d3.done_stat != QD_NO_ERROR) {\r\nasc_dvc->start_motor &=\r\n~target_id;\r\n}\r\n}\r\n}\r\nreturn (1);\r\n} else {\r\nAscSetLibErrorCode(asc_dvc, ASCQ_ERR_Q_STATUS);\r\nFATAL_ERR_QDONE:\r\nif ((scsiq->cntl & QC_NO_CALLBACK) == 0) {\r\nasc_isr_callback(asc_dvc, scsiq);\r\n}\r\nreturn (0x80);\r\n}\r\n}\r\nreturn (0);\r\n}\r\nstatic int AscISR(ASC_DVC_VAR *asc_dvc)\r\n{\r\nASC_CS_TYPE chipstat;\r\nPortAddr iop_base;\r\nushort saved_ram_addr;\r\nuchar ctrl_reg;\r\nuchar saved_ctrl_reg;\r\nint int_pending;\r\nint status;\r\nuchar host_flag;\r\niop_base = asc_dvc->iop_base;\r\nint_pending = FALSE;\r\nif (AscIsIntPending(iop_base) == 0)\r\nreturn int_pending;\r\nif ((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0) {\r\nreturn ERR;\r\n}\r\nif (asc_dvc->in_critical_cnt != 0) {\r\nAscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL);\r\nreturn ERR;\r\n}\r\nif (asc_dvc->is_in_int) {\r\nAscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_RE_ENTRY);\r\nreturn ERR;\r\n}\r\nasc_dvc->is_in_int = TRUE;\r\nctrl_reg = AscGetChipControl(iop_base);\r\nsaved_ctrl_reg = ctrl_reg & (~(CC_SCSI_RESET | CC_CHIP_RESET |\r\nCC_SINGLE_STEP | CC_DIAG | CC_TEST));\r\nchipstat = AscGetChipStatus(iop_base);\r\nif (chipstat & CSW_SCSI_RESET_LATCH) {\r\nif (!(asc_dvc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {\r\nint i = 10;\r\nint_pending = TRUE;\r\nasc_dvc->sdtr_done = 0;\r\nsaved_ctrl_reg &= (uchar)(~CC_HALT);\r\nwhile ((AscGetChipStatus(iop_base) &\r\nCSW_SCSI_RESET_ACTIVE) && (i-- > 0)) {\r\nmdelay(100);\r\n}\r\nAscSetChipControl(iop_base, (CC_CHIP_RESET | CC_HALT));\r\nAscSetChipControl(iop_base, CC_HALT);\r\nAscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);\r\nAscSetChipStatus(iop_base, 0);\r\nchipstat = AscGetChipStatus(iop_base);\r\n}\r\n}\r\nsaved_ram_addr = AscGetChipLramAddr(iop_base);\r\nhost_flag = AscReadLramByte(iop_base,\r\nASCV_HOST_FLAG_B) &\r\n(uchar)(~ASC_HOST_FLAG_IN_ISR);\r\nAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,\r\n(uchar)(host_flag | (uchar)ASC_HOST_FLAG_IN_ISR));\r\nif ((chipstat & CSW_INT_PENDING) || (int_pending)) {\r\nAscAckInterrupt(iop_base);\r\nint_pending = TRUE;\r\nif ((chipstat & CSW_HALTED) && (ctrl_reg & CC_SINGLE_STEP)) {\r\nif (AscIsrChipHalted(asc_dvc) == ERR) {\r\ngoto ISR_REPORT_QDONE_FATAL_ERROR;\r\n} else {\r\nsaved_ctrl_reg &= (uchar)(~CC_HALT);\r\n}\r\n} else {\r\nISR_REPORT_QDONE_FATAL_ERROR:\r\nif ((asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) != 0) {\r\nwhile (((status =\r\nAscIsrQDone(asc_dvc)) & 0x01) != 0) {\r\n}\r\n} else {\r\ndo {\r\nif ((status =\r\nAscIsrQDone(asc_dvc)) == 1) {\r\nbreak;\r\n}\r\n} while (status == 0x11);\r\n}\r\nif ((status & 0x80) != 0)\r\nint_pending = ERR;\r\n}\r\n}\r\nAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);\r\nAscSetChipLramAddr(iop_base, saved_ram_addr);\r\nAscSetChipControl(iop_base, saved_ctrl_reg);\r\nasc_dvc->is_in_int = FALSE;\r\nreturn int_pending;\r\n}\r\nstatic int advansys_reset(struct scsi_cmnd *scp)\r\n{\r\nstruct Scsi_Host *shost = scp->device->host;\r\nstruct asc_board *boardp = shost_priv(shost);\r\nunsigned long flags;\r\nint status;\r\nint ret = SUCCESS;\r\nASC_DBG(1, "0x%p\n", scp);\r\nASC_STATS(shost, reset);\r\nscmd_printk(KERN_INFO, scp, "SCSI bus reset started...\n");\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;\r\nASC_DBG(1, "before AscInitAsc1000Driver()\n");\r\nstatus = AscInitAsc1000Driver(asc_dvc);\r\nif (asc_dvc->err_code || !asc_dvc->overrun_dma) {\r\nscmd_printk(KERN_INFO, scp, "SCSI bus reset error: "\r\n"0x%x, status: 0x%x\n", asc_dvc->err_code,\r\nstatus);\r\nret = FAILED;\r\n} else if (status) {\r\nscmd_printk(KERN_INFO, scp, "SCSI bus reset warning: "\r\n"0x%x\n", status);\r\n} else {\r\nscmd_printk(KERN_INFO, scp, "SCSI bus reset "\r\n"successful\n");\r\n}\r\nASC_DBG(1, "after AscInitAsc1000Driver()\n");\r\nspin_lock_irqsave(shost->host_lock, flags);\r\n} else {\r\nADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;\r\nASC_DBG(1, "before AdvResetChipAndSB()\n");\r\nswitch (AdvResetChipAndSB(adv_dvc)) {\r\ncase ASC_TRUE:\r\nscmd_printk(KERN_INFO, scp, "SCSI bus reset "\r\n"successful\n");\r\nbreak;\r\ncase ASC_FALSE:\r\ndefault:\r\nscmd_printk(KERN_INFO, scp, "SCSI bus reset error\n");\r\nret = FAILED;\r\nbreak;\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nAdvISR(adv_dvc);\r\n}\r\nboardp->last_reset = jiffies;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nASC_DBG(1, "ret %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nadvansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int ip[])\r\n{\r\nstruct asc_board *boardp = shost_priv(sdev->host);\r\nASC_DBG(1, "begin\n");\r\nASC_STATS(sdev->host, biosparam);\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nif ((boardp->dvc_var.asc_dvc_var.dvc_cntl &\r\nASC_CNTL_BIOS_GT_1GB) && capacity > 0x200000) {\r\nip[0] = 255;\r\nip[1] = 63;\r\n} else {\r\nip[0] = 64;\r\nip[1] = 32;\r\n}\r\n} else {\r\nif ((boardp->dvc_var.adv_dvc_var.bios_ctrl &\r\nBIOS_CTRL_EXTENDED_XLAT) && capacity > 0x200000) {\r\nip[0] = 255;\r\nip[1] = 63;\r\n} else {\r\nip[0] = 64;\r\nip[1] = 32;\r\n}\r\n}\r\nip[2] = (unsigned long)capacity / (ip[0] * ip[1]);\r\nASC_DBG(1, "end\n");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t advansys_interrupt(int irq, void *dev_id)\r\n{\r\nstruct Scsi_Host *shost = dev_id;\r\nstruct asc_board *boardp = shost_priv(shost);\r\nirqreturn_t result = IRQ_NONE;\r\nASC_DBG(2, "boardp 0x%p\n", boardp);\r\nspin_lock(shost->host_lock);\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nif (AscIsIntPending(shost->io_port)) {\r\nresult = IRQ_HANDLED;\r\nASC_STATS(shost, interrupt);\r\nASC_DBG(1, "before AscISR()\n");\r\nAscISR(&boardp->dvc_var.asc_dvc_var);\r\n}\r\n} else {\r\nASC_DBG(1, "before AdvISR()\n");\r\nif (AdvISR(&boardp->dvc_var.adv_dvc_var)) {\r\nresult = IRQ_HANDLED;\r\nASC_STATS(shost, interrupt);\r\n}\r\n}\r\nspin_unlock(shost->host_lock);\r\nASC_DBG(1, "end\n");\r\nreturn result;\r\n}\r\nstatic int AscHostReqRiscHalt(PortAddr iop_base)\r\n{\r\nint count = 0;\r\nint sta = 0;\r\nuchar saved_stop_code;\r\nif (AscIsChipHalted(iop_base))\r\nreturn (1);\r\nsaved_stop_code = AscReadLramByte(iop_base, ASCV_STOP_CODE_B);\r\nAscWriteLramByte(iop_base, ASCV_STOP_CODE_B,\r\nASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP);\r\ndo {\r\nif (AscIsChipHalted(iop_base)) {\r\nsta = 1;\r\nbreak;\r\n}\r\nmdelay(100);\r\n} while (count++ < 20);\r\nAscWriteLramByte(iop_base, ASCV_STOP_CODE_B, saved_stop_code);\r\nreturn (sta);\r\n}\r\nstatic int\r\nAscSetRunChipSynRegAtID(PortAddr iop_base, uchar tid_no, uchar sdtr_data)\r\n{\r\nint sta = FALSE;\r\nif (AscHostReqRiscHalt(iop_base)) {\r\nsta = AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);\r\nAscStartChip(iop_base);\r\n}\r\nreturn sta;\r\n}\r\nstatic void AscAsyncFix(ASC_DVC_VAR *asc_dvc, struct scsi_device *sdev)\r\n{\r\nchar type = sdev->type;\r\nASC_SCSI_BIT_ID_TYPE tid_bits = 1 << sdev->id;\r\nif (!(asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN))\r\nreturn;\r\nif (asc_dvc->init_sdtr & tid_bits)\r\nreturn;\r\nif ((type == TYPE_ROM) && (strncmp(sdev->vendor, "HP ", 3) == 0))\r\nasc_dvc->pci_fix_asyn_xfer_always |= tid_bits;\r\nasc_dvc->pci_fix_asyn_xfer |= tid_bits;\r\nif ((type == TYPE_PROCESSOR) || (type == TYPE_SCANNER) ||\r\n(type == TYPE_ROM) || (type == TYPE_TAPE))\r\nasc_dvc->pci_fix_asyn_xfer &= ~tid_bits;\r\nif (asc_dvc->pci_fix_asyn_xfer & tid_bits)\r\nAscSetRunChipSynRegAtID(asc_dvc->iop_base, sdev->id,\r\nASYN_SDTR_DATA_FIX_PCI_REV_AB);\r\n}\r\nstatic void\r\nadvansys_narrow_slave_configure(struct scsi_device *sdev, ASC_DVC_VAR *asc_dvc)\r\n{\r\nASC_SCSI_BIT_ID_TYPE tid_bit = 1 << sdev->id;\r\nASC_SCSI_BIT_ID_TYPE orig_use_tagged_qng = asc_dvc->use_tagged_qng;\r\nif (sdev->lun == 0) {\r\nASC_SCSI_BIT_ID_TYPE orig_init_sdtr = asc_dvc->init_sdtr;\r\nif ((asc_dvc->cfg->sdtr_enable & tid_bit) && sdev->sdtr) {\r\nasc_dvc->init_sdtr |= tid_bit;\r\n} else {\r\nasc_dvc->init_sdtr &= ~tid_bit;\r\n}\r\nif (orig_init_sdtr != asc_dvc->init_sdtr)\r\nAscAsyncFix(asc_dvc, sdev);\r\n}\r\nif (sdev->tagged_supported) {\r\nif (asc_dvc->cfg->cmd_qng_enabled & tid_bit) {\r\nif (sdev->lun == 0) {\r\nasc_dvc->cfg->can_tagged_qng |= tid_bit;\r\nasc_dvc->use_tagged_qng |= tid_bit;\r\n}\r\nscsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG,\r\nasc_dvc->max_dvc_qng[sdev->id]);\r\n}\r\n} else {\r\nif (sdev->lun == 0) {\r\nasc_dvc->cfg->can_tagged_qng &= ~tid_bit;\r\nasc_dvc->use_tagged_qng &= ~tid_bit;\r\n}\r\nscsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);\r\n}\r\nif ((sdev->lun == 0) &&\r\n(orig_use_tagged_qng != asc_dvc->use_tagged_qng)) {\r\nAscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,\r\nasc_dvc->cfg->disc_enable);\r\nAscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,\r\nasc_dvc->use_tagged_qng);\r\nAscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,\r\nasc_dvc->cfg->can_tagged_qng);\r\nasc_dvc->max_dvc_qng[sdev->id] =\r\nasc_dvc->cfg->max_tag_qng[sdev->id];\r\nAscWriteLramByte(asc_dvc->iop_base,\r\n(ushort)(ASCV_MAX_DVC_QNG_BEG + sdev->id),\r\nasc_dvc->max_dvc_qng[sdev->id]);\r\n}\r\n}\r\nstatic void\r\nadvansys_wide_enable_wdtr(AdvPortAddr iop_base, unsigned short tidmask)\r\n{\r\nunsigned short cfg_word;\r\nAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);\r\nif ((cfg_word & tidmask) != 0)\r\nreturn;\r\ncfg_word |= tidmask;\r\nAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);\r\nAdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\r\ncfg_word &= ~tidmask;\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\r\nAdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);\r\ncfg_word &= ~tidmask;\r\nAdvWriteWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);\r\n}\r\nstatic void\r\nadvansys_wide_enable_sdtr(AdvPortAddr iop_base, unsigned short tidmask)\r\n{\r\nunsigned short cfg_word;\r\nAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);\r\nif ((cfg_word & tidmask) != 0)\r\nreturn;\r\ncfg_word |= tidmask;\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);\r\nAdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\r\ncfg_word &= ~tidmask;\r\nAdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\r\n}\r\nstatic void advansys_wide_enable_ppr(ADV_DVC_VAR *adv_dvc,\r\nAdvPortAddr iop_base, unsigned short tidmask)\r\n{\r\nAdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);\r\nadv_dvc->ppr_able |= tidmask;\r\nAdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);\r\n}\r\nstatic void\r\nadvansys_wide_slave_configure(struct scsi_device *sdev, ADV_DVC_VAR *adv_dvc)\r\n{\r\nAdvPortAddr iop_base = adv_dvc->iop_base;\r\nunsigned short tidmask = 1 << sdev->id;\r\nif (sdev->lun == 0) {\r\nif ((adv_dvc->wdtr_able & tidmask) && sdev->wdtr)\r\nadvansys_wide_enable_wdtr(iop_base, tidmask);\r\nif ((adv_dvc->sdtr_able & tidmask) && sdev->sdtr)\r\nadvansys_wide_enable_sdtr(iop_base, tidmask);\r\nif (adv_dvc->chip_type == ADV_CHIP_ASC38C1600 && sdev->ppr)\r\nadvansys_wide_enable_ppr(adv_dvc, iop_base, tidmask);\r\nif ((adv_dvc->tagqng_able & tidmask) &&\r\nsdev->tagged_supported) {\r\nunsigned short cfg_word;\r\nAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);\r\ncfg_word |= tidmask;\r\nAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\r\ncfg_word);\r\nAdvWriteByteLram(iop_base,\r\nASC_MC_NUMBER_OF_MAX_CMD + sdev->id,\r\nadv_dvc->max_dvc_qng);\r\n}\r\n}\r\nif ((adv_dvc->tagqng_able & tidmask) && sdev->tagged_supported) {\r\nscsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG,\r\nadv_dvc->max_dvc_qng);\r\n} else {\r\nscsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);\r\n}\r\n}\r\nstatic int advansys_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct asc_board *boardp = shost_priv(sdev->host);\r\nif (ASC_NARROW_BOARD(boardp))\r\nadvansys_narrow_slave_configure(sdev,\r\n&boardp->dvc_var.asc_dvc_var);\r\nelse\r\nadvansys_wide_slave_configure(sdev,\r\n&boardp->dvc_var.adv_dvc_var);\r\nreturn 0;\r\n}\r\nstatic __le32 advansys_get_sense_buffer_dma(struct scsi_cmnd *scp)\r\n{\r\nstruct asc_board *board = shost_priv(scp->device->host);\r\nscp->SCp.dma_handle = dma_map_single(board->dev, scp->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\r\ndma_cache_sync(board->dev, scp->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\r\nreturn cpu_to_le32(scp->SCp.dma_handle);\r\n}\r\nstatic int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,\r\nstruct asc_scsi_q *asc_scsi_q)\r\n{\r\nstruct asc_dvc_var *asc_dvc = &boardp->dvc_var.asc_dvc_var;\r\nint use_sg;\r\nmemset(asc_scsi_q, 0, sizeof(*asc_scsi_q));\r\nasc_scsi_q->q2.srb_ptr = advansys_ptr_to_srb(asc_dvc, scp);\r\nif (asc_scsi_q->q2.srb_ptr == BAD_SRB) {\r\nscp->result = HOST_BYTE(DID_SOFT_ERROR);\r\nreturn ASC_ERROR;\r\n}\r\nasc_scsi_q->cdbptr = &scp->cmnd[0];\r\nasc_scsi_q->q2.cdb_len = scp->cmd_len;\r\nasc_scsi_q->q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);\r\nasc_scsi_q->q1.target_lun = scp->device->lun;\r\nasc_scsi_q->q2.target_ix =\r\nASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);\r\nasc_scsi_q->q1.sense_addr = advansys_get_sense_buffer_dma(scp);\r\nasc_scsi_q->q1.sense_len = SCSI_SENSE_BUFFERSIZE;\r\nif ((asc_dvc->cur_dvc_qng[scp->device->id] > 0) &&\r\n(boardp->reqcnt[scp->device->id] % 255) == 0) {\r\nasc_scsi_q->q2.tag_code = MSG_ORDERED_TAG;\r\n} else {\r\nasc_scsi_q->q2.tag_code = MSG_SIMPLE_TAG;\r\n}\r\nuse_sg = scsi_dma_map(scp);\r\nif (use_sg != 0) {\r\nint sgcnt;\r\nstruct scatterlist *slp;\r\nstruct asc_sg_head *asc_sg_head;\r\nif (use_sg > scp->device->host->sg_tablesize) {\r\nscmd_printk(KERN_ERR, scp, "use_sg %d > "\r\n"sg_tablesize %d\n", use_sg,\r\nscp->device->host->sg_tablesize);\r\nscsi_dma_unmap(scp);\r\nscp->result = HOST_BYTE(DID_ERROR);\r\nreturn ASC_ERROR;\r\n}\r\nasc_sg_head = kzalloc(sizeof(asc_scsi_q->sg_head) +\r\nuse_sg * sizeof(struct asc_sg_list), GFP_ATOMIC);\r\nif (!asc_sg_head) {\r\nscsi_dma_unmap(scp);\r\nscp->result = HOST_BYTE(DID_SOFT_ERROR);\r\nreturn ASC_ERROR;\r\n}\r\nasc_scsi_q->q1.cntl |= QC_SG_HEAD;\r\nasc_scsi_q->sg_head = asc_sg_head;\r\nasc_scsi_q->q1.data_cnt = 0;\r\nasc_scsi_q->q1.data_addr = 0;\r\nasc_sg_head->entry_cnt = asc_scsi_q->q1.sg_queue_cnt = use_sg;\r\nASC_STATS_ADD(scp->device->host, xfer_elem,\r\nasc_sg_head->entry_cnt);\r\nscsi_for_each_sg(scp, slp, use_sg, sgcnt) {\r\nasc_sg_head->sg_list[sgcnt].addr =\r\ncpu_to_le32(sg_dma_address(slp));\r\nasc_sg_head->sg_list[sgcnt].bytes =\r\ncpu_to_le32(sg_dma_len(slp));\r\nASC_STATS_ADD(scp->device->host, xfer_sect,\r\nDIV_ROUND_UP(sg_dma_len(slp), 512));\r\n}\r\n}\r\nASC_STATS(scp->device->host, xfer_cnt);\r\nASC_DBG_PRT_ASC_SCSI_Q(2, asc_scsi_q);\r\nASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);\r\nreturn ASC_NOERROR;\r\n}\r\nstatic int\r\nadv_get_sglist(struct asc_board *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,\r\nint use_sg)\r\n{\r\nadv_sgblk_t *sgblkp;\r\nADV_SCSI_REQ_Q *scsiqp;\r\nstruct scatterlist *slp;\r\nint sg_elem_cnt;\r\nADV_SG_BLOCK *sg_block, *prev_sg_block;\r\nADV_PADDR sg_block_paddr;\r\nint i;\r\nscsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);\r\nslp = scsi_sglist(scp);\r\nsg_elem_cnt = use_sg;\r\nprev_sg_block = NULL;\r\nreqp->sgblkp = NULL;\r\nfor (;;) {\r\nif ((sgblkp = boardp->adv_sgblkp) == NULL) {\r\nASC_DBG(1, "no free adv_sgblk_t\n");\r\nASC_STATS(scp->device->host, adv_build_nosg);\r\nwhile ((sgblkp = reqp->sgblkp) != NULL) {\r\nreqp->sgblkp = sgblkp->next_sgblkp;\r\nsgblkp->next_sgblkp = boardp->adv_sgblkp;\r\nboardp->adv_sgblkp = sgblkp;\r\n}\r\nreturn ASC_BUSY;\r\n}\r\nboardp->adv_sgblkp = sgblkp->next_sgblkp;\r\nsgblkp->next_sgblkp = NULL;\r\nsg_block = (ADV_SG_BLOCK *)ADV_8BALIGN(&sgblkp->sg_block);\r\nsg_block_paddr = virt_to_bus(sg_block);\r\nif (reqp->sgblkp == NULL) {\r\nreqp->sgblkp = sgblkp;\r\nscsiqp->sg_list_ptr = sg_block;\r\nscsiqp->sg_real_addr = cpu_to_le32(sg_block_paddr);\r\n} else {\r\nsgblkp->next_sgblkp = reqp->sgblkp;\r\nreqp->sgblkp = sgblkp;\r\nprev_sg_block->sg_ptr = cpu_to_le32(sg_block_paddr);\r\n}\r\nfor (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {\r\nsg_block->sg_list[i].sg_addr =\r\ncpu_to_le32(sg_dma_address(slp));\r\nsg_block->sg_list[i].sg_count =\r\ncpu_to_le32(sg_dma_len(slp));\r\nASC_STATS_ADD(scp->device->host, xfer_sect,\r\nDIV_ROUND_UP(sg_dma_len(slp), 512));\r\nif (--sg_elem_cnt == 0) {\r\nsg_block->sg_cnt = i + 1;\r\nsg_block->sg_ptr = 0L;\r\nreturn ADV_SUCCESS;\r\n}\r\nslp++;\r\n}\r\nsg_block->sg_cnt = NO_OF_SG_PER_BLOCK;\r\nprev_sg_block = sg_block;\r\n}\r\n}\r\nstatic int\r\nadv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,\r\nADV_SCSI_REQ_Q **adv_scsiqpp)\r\n{\r\nadv_req_t *reqp;\r\nADV_SCSI_REQ_Q *scsiqp;\r\nint i;\r\nint ret;\r\nint use_sg;\r\nif (boardp->adv_reqp == NULL) {\r\nASC_DBG(1, "no free adv_req_t\n");\r\nASC_STATS(scp->device->host, adv_build_noreq);\r\nreturn ASC_BUSY;\r\n} else {\r\nreqp = boardp->adv_reqp;\r\nboardp->adv_reqp = reqp->next_reqp;\r\nreqp->next_reqp = NULL;\r\n}\r\nscsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);\r\nscsiqp->cntl = scsiqp->scsi_cntl = scsiqp->done_status = 0;\r\nscsiqp->srb_ptr = ADV_VADDR_TO_U32(reqp);\r\nreqp->cmndp = scp;\r\nscsiqp->cdb_len = scp->cmd_len;\r\nfor (i = 0; i < scp->cmd_len && i < 12; i++) {\r\nscsiqp->cdb[i] = scp->cmnd[i];\r\n}\r\nfor (; i < scp->cmd_len; i++) {\r\nscsiqp->cdb16[i - 12] = scp->cmnd[i];\r\n}\r\nscsiqp->target_id = scp->device->id;\r\nscsiqp->target_lun = scp->device->lun;\r\nscsiqp->sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));\r\nscsiqp->sense_len = SCSI_SENSE_BUFFERSIZE;\r\nuse_sg = scsi_dma_map(scp);\r\nif (use_sg == 0) {\r\nreqp->sgblkp = NULL;\r\nscsiqp->data_cnt = 0;\r\nscsiqp->vdata_addr = NULL;\r\nscsiqp->data_addr = 0;\r\nscsiqp->sg_list_ptr = NULL;\r\nscsiqp->sg_real_addr = 0;\r\n} else {\r\nif (use_sg > ADV_MAX_SG_LIST) {\r\nscmd_printk(KERN_ERR, scp, "use_sg %d > "\r\n"ADV_MAX_SG_LIST %d\n", use_sg,\r\nscp->device->host->sg_tablesize);\r\nscsi_dma_unmap(scp);\r\nscp->result = HOST_BYTE(DID_ERROR);\r\nreqp->next_reqp = boardp->adv_reqp;\r\nboardp->adv_reqp = reqp;\r\nreturn ASC_ERROR;\r\n}\r\nscsiqp->data_cnt = cpu_to_le32(scsi_bufflen(scp));\r\nret = adv_get_sglist(boardp, reqp, scp, use_sg);\r\nif (ret != ADV_SUCCESS) {\r\nreqp->next_reqp = boardp->adv_reqp;\r\nboardp->adv_reqp = reqp;\r\nreturn ret;\r\n}\r\nASC_STATS_ADD(scp->device->host, xfer_elem, use_sg);\r\n}\r\nASC_STATS(scp->device->host, xfer_cnt);\r\nASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);\r\nASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);\r\n*adv_scsiqpp = scsiqp;\r\nreturn ASC_NOERROR;\r\n}\r\nstatic int AscSgListToQueue(int sg_list)\r\n{\r\nint n_sg_list_qs;\r\nn_sg_list_qs = ((sg_list - 1) / ASC_SG_LIST_PER_Q);\r\nif (((sg_list - 1) % ASC_SG_LIST_PER_Q) != 0)\r\nn_sg_list_qs++;\r\nreturn n_sg_list_qs + 1;\r\n}\r\nstatic uint\r\nAscGetNumOfFreeQueue(ASC_DVC_VAR *asc_dvc, uchar target_ix, uchar n_qs)\r\n{\r\nuint cur_used_qs;\r\nuint cur_free_qs;\r\nASC_SCSI_BIT_ID_TYPE target_id;\r\nuchar tid_no;\r\ntarget_id = ASC_TIX_TO_TARGET_ID(target_ix);\r\ntid_no = ASC_TIX_TO_TID(target_ix);\r\nif ((asc_dvc->unit_not_ready & target_id) ||\r\n(asc_dvc->queue_full_or_busy & target_id)) {\r\nreturn 0;\r\n}\r\nif (n_qs == 1) {\r\ncur_used_qs = (uint) asc_dvc->cur_total_qng +\r\n(uint) asc_dvc->last_q_shortage + (uint) ASC_MIN_FREE_Q;\r\n} else {\r\ncur_used_qs = (uint) asc_dvc->cur_total_qng +\r\n(uint) ASC_MIN_FREE_Q;\r\n}\r\nif ((uint) (cur_used_qs + n_qs) <= (uint) asc_dvc->max_total_qng) {\r\ncur_free_qs = (uint) asc_dvc->max_total_qng - cur_used_qs;\r\nif (asc_dvc->cur_dvc_qng[tid_no] >=\r\nasc_dvc->max_dvc_qng[tid_no]) {\r\nreturn 0;\r\n}\r\nreturn cur_free_qs;\r\n}\r\nif (n_qs > 1) {\r\nif ((n_qs > asc_dvc->last_q_shortage)\r\n&& (n_qs <= (asc_dvc->max_total_qng - ASC_MIN_FREE_Q))) {\r\nasc_dvc->last_q_shortage = n_qs;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic uchar AscAllocFreeQueue(PortAddr iop_base, uchar free_q_head)\r\n{\r\nushort q_addr;\r\nuchar next_qp;\r\nuchar q_status;\r\nq_addr = ASC_QNO_TO_QADDR(free_q_head);\r\nq_status = (uchar)AscReadLramByte(iop_base,\r\n(ushort)(q_addr +\r\nASC_SCSIQ_B_STATUS));\r\nnext_qp = AscReadLramByte(iop_base, (ushort)(q_addr + ASC_SCSIQ_B_FWD));\r\nif (((q_status & QS_READY) == 0) && (next_qp != ASC_QLINK_END))\r\nreturn next_qp;\r\nreturn ASC_QLINK_END;\r\n}\r\nstatic uchar\r\nAscAllocMultipleFreeQueue(PortAddr iop_base, uchar free_q_head, uchar n_free_q)\r\n{\r\nuchar i;\r\nfor (i = 0; i < n_free_q; i++) {\r\nfree_q_head = AscAllocFreeQueue(iop_base, free_q_head);\r\nif (free_q_head == ASC_QLINK_END)\r\nbreak;\r\n}\r\nreturn free_q_head;\r\n}\r\nstatic void\r\nDvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)\r\n{\r\nint i;\r\nASC_DBG_PRT_HEX(2, "DvcPutScsiQ", outbuf, 2 * words);\r\nAscSetChipLramAddr(iop_base, s_addr);\r\nfor (i = 0; i < 2 * words; i += 2) {\r\nif (i == 4 || i == 20) {\r\ncontinue;\r\n}\r\noutpw(iop_base + IOP_RAM_DATA,\r\n((ushort)outbuf[i + 1] << 8) | outbuf[i]);\r\n}\r\n}\r\nstatic int AscPutReadyQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)\r\n{\r\nushort q_addr;\r\nuchar tid_no;\r\nuchar sdtr_data;\r\nuchar syn_period_ix;\r\nuchar syn_offset;\r\nPortAddr iop_base;\r\niop_base = asc_dvc->iop_base;\r\nif (((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) &&\r\n((asc_dvc->sdtr_done & scsiq->q1.target_id) == 0)) {\r\ntid_no = ASC_TIX_TO_TID(scsiq->q2.target_ix);\r\nsdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);\r\nsyn_period_ix =\r\n(sdtr_data >> 4) & (asc_dvc->max_sdtr_index - 1);\r\nsyn_offset = sdtr_data & ASC_SYN_MAX_OFFSET;\r\nAscMsgOutSDTR(asc_dvc,\r\nasc_dvc->sdtr_period_tbl[syn_period_ix],\r\nsyn_offset);\r\nscsiq->q1.cntl |= QC_MSG_OUT;\r\n}\r\nq_addr = ASC_QNO_TO_QADDR(q_no);\r\nif ((scsiq->q1.target_id & asc_dvc->use_tagged_qng) == 0) {\r\nscsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;\r\n}\r\nscsiq->q1.status = QS_FREE;\r\nAscMemWordCopyPtrToLram(iop_base,\r\nq_addr + ASC_SCSIQ_CDB_BEG,\r\n(uchar *)scsiq->cdbptr, scsiq->q2.cdb_len >> 1);\r\nDvcPutScsiQ(iop_base,\r\nq_addr + ASC_SCSIQ_CPY_BEG,\r\n(uchar *)&scsiq->q1.cntl,\r\n((sizeof(ASC_SCSIQ_1) + sizeof(ASC_SCSIQ_2)) / 2) - 1);\r\nAscWriteLramWord(iop_base,\r\n(ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS),\r\n(ushort)(((ushort)scsiq->q1.\r\nq_no << 8) | (ushort)QS_READY));\r\nreturn 1;\r\n}\r\nstatic int\r\nAscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)\r\n{\r\nint sta;\r\nint i;\r\nASC_SG_HEAD *sg_head;\r\nASC_SG_LIST_Q scsi_sg_q;\r\nASC_DCNT saved_data_addr;\r\nASC_DCNT saved_data_cnt;\r\nPortAddr iop_base;\r\nushort sg_list_dwords;\r\nushort sg_index;\r\nushort sg_entry_cnt;\r\nushort q_addr;\r\nuchar next_qp;\r\niop_base = asc_dvc->iop_base;\r\nsg_head = scsiq->sg_head;\r\nsaved_data_addr = scsiq->q1.data_addr;\r\nsaved_data_cnt = scsiq->q1.data_cnt;\r\nscsiq->q1.data_addr = (ASC_PADDR) sg_head->sg_list[0].addr;\r\nscsiq->q1.data_cnt = (ASC_DCNT) sg_head->sg_list[0].bytes;\r\n#if CC_VERY_LONG_SG_LIST\r\nif (sg_head->entry_cnt > ASC_MAX_SG_LIST) {\r\nsg_entry_cnt = ASC_MAX_SG_LIST - 1;\r\nscsiq->remain_sg_entry_cnt =\r\nsg_head->entry_cnt - ASC_MAX_SG_LIST;\r\n} else {\r\n#endif\r\nsg_entry_cnt = sg_head->entry_cnt - 1;\r\n#if CC_VERY_LONG_SG_LIST\r\n}\r\n#endif\r\nif (sg_entry_cnt != 0) {\r\nscsiq->q1.cntl |= QC_SG_HEAD;\r\nq_addr = ASC_QNO_TO_QADDR(q_no);\r\nsg_index = 1;\r\nscsiq->q1.sg_queue_cnt = sg_head->queue_cnt;\r\nscsi_sg_q.sg_head_qp = q_no;\r\nscsi_sg_q.cntl = QCSG_SG_XFER_LIST;\r\nfor (i = 0; i < sg_head->queue_cnt; i++) {\r\nscsi_sg_q.seq_no = i + 1;\r\nif (sg_entry_cnt > ASC_SG_LIST_PER_Q) {\r\nsg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);\r\nsg_entry_cnt -= ASC_SG_LIST_PER_Q;\r\nif (i == 0) {\r\nscsi_sg_q.sg_list_cnt =\r\nASC_SG_LIST_PER_Q;\r\nscsi_sg_q.sg_cur_list_cnt =\r\nASC_SG_LIST_PER_Q;\r\n} else {\r\nscsi_sg_q.sg_list_cnt =\r\nASC_SG_LIST_PER_Q - 1;\r\nscsi_sg_q.sg_cur_list_cnt =\r\nASC_SG_LIST_PER_Q - 1;\r\n}\r\n} else {\r\n#if CC_VERY_LONG_SG_LIST\r\nif (sg_head->entry_cnt > ASC_MAX_SG_LIST) {\r\nscsi_sg_q.cntl |= QCSG_SG_XFER_MORE;\r\n} else {\r\n#endif\r\nscsi_sg_q.cntl |= QCSG_SG_XFER_END;\r\n#if CC_VERY_LONG_SG_LIST\r\n}\r\n#endif\r\nsg_list_dwords = sg_entry_cnt << 1;\r\nif (i == 0) {\r\nscsi_sg_q.sg_list_cnt = sg_entry_cnt;\r\nscsi_sg_q.sg_cur_list_cnt =\r\nsg_entry_cnt;\r\n} else {\r\nscsi_sg_q.sg_list_cnt =\r\nsg_entry_cnt - 1;\r\nscsi_sg_q.sg_cur_list_cnt =\r\nsg_entry_cnt - 1;\r\n}\r\nsg_entry_cnt = 0;\r\n}\r\nnext_qp = AscReadLramByte(iop_base,\r\n(ushort)(q_addr +\r\nASC_SCSIQ_B_FWD));\r\nscsi_sg_q.q_no = next_qp;\r\nq_addr = ASC_QNO_TO_QADDR(next_qp);\r\nAscMemWordCopyPtrToLram(iop_base,\r\nq_addr + ASC_SCSIQ_SGHD_CPY_BEG,\r\n(uchar *)&scsi_sg_q,\r\nsizeof(ASC_SG_LIST_Q) >> 1);\r\nAscMemDWordCopyPtrToLram(iop_base,\r\nq_addr + ASC_SGQ_LIST_BEG,\r\n(uchar *)&sg_head->\r\nsg_list[sg_index],\r\nsg_list_dwords);\r\nsg_index += ASC_SG_LIST_PER_Q;\r\nscsiq->next_sg_index = sg_index;\r\n}\r\n} else {\r\nscsiq->q1.cntl &= ~QC_SG_HEAD;\r\n}\r\nsta = AscPutReadyQueue(asc_dvc, scsiq, q_no);\r\nscsiq->q1.data_addr = saved_data_addr;\r\nscsiq->q1.data_cnt = saved_data_cnt;\r\nreturn (sta);\r\n}\r\nstatic int\r\nAscSendScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar n_q_required)\r\n{\r\nPortAddr iop_base;\r\nuchar free_q_head;\r\nuchar next_qp;\r\nuchar tid_no;\r\nuchar target_ix;\r\nint sta;\r\niop_base = asc_dvc->iop_base;\r\ntarget_ix = scsiq->q2.target_ix;\r\ntid_no = ASC_TIX_TO_TID(target_ix);\r\nsta = 0;\r\nfree_q_head = (uchar)AscGetVarFreeQHead(iop_base);\r\nif (n_q_required > 1) {\r\nnext_qp = AscAllocMultipleFreeQueue(iop_base, free_q_head,\r\n(uchar)n_q_required);\r\nif (next_qp != ASC_QLINK_END) {\r\nasc_dvc->last_q_shortage = 0;\r\nscsiq->sg_head->queue_cnt = n_q_required - 1;\r\nscsiq->q1.q_no = free_q_head;\r\nsta = AscPutReadySgListQueue(asc_dvc, scsiq,\r\nfree_q_head);\r\n}\r\n} else if (n_q_required == 1) {\r\nnext_qp = AscAllocFreeQueue(iop_base, free_q_head);\r\nif (next_qp != ASC_QLINK_END) {\r\nscsiq->q1.q_no = free_q_head;\r\nsta = AscPutReadyQueue(asc_dvc, scsiq, free_q_head);\r\n}\r\n}\r\nif (sta == 1) {\r\nAscPutVarFreeQHead(iop_base, next_qp);\r\nasc_dvc->cur_total_qng += n_q_required;\r\nasc_dvc->cur_dvc_qng[tid_no]++;\r\n}\r\nreturn sta;\r\n}\r\nstatic int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)\r\n{\r\nPortAddr iop_base;\r\nint sta;\r\nint n_q_required;\r\nint disable_syn_offset_one_fix;\r\nint i;\r\nASC_PADDR addr;\r\nushort sg_entry_cnt = 0;\r\nushort sg_entry_cnt_minus_one = 0;\r\nuchar target_ix;\r\nuchar tid_no;\r\nuchar sdtr_data;\r\nuchar extra_bytes;\r\nuchar scsi_cmd;\r\nuchar disable_cmd;\r\nASC_SG_HEAD *sg_head;\r\nASC_DCNT data_cnt;\r\niop_base = asc_dvc->iop_base;\r\nsg_head = scsiq->sg_head;\r\nif (asc_dvc->err_code != 0)\r\nreturn (ERR);\r\nscsiq->q1.q_no = 0;\r\nif ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0) {\r\nscsiq->q1.extra_bytes = 0;\r\n}\r\nsta = 0;\r\ntarget_ix = scsiq->q2.target_ix;\r\ntid_no = ASC_TIX_TO_TID(target_ix);\r\nn_q_required = 1;\r\nif (scsiq->cdbptr[0] == REQUEST_SENSE) {\r\nif ((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) {\r\nasc_dvc->sdtr_done &= ~scsiq->q1.target_id;\r\nsdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);\r\nAscMsgOutSDTR(asc_dvc,\r\nasc_dvc->\r\nsdtr_period_tbl[(sdtr_data >> 4) &\r\n(uchar)(asc_dvc->\r\nmax_sdtr_index -\r\n1)],\r\n(uchar)(sdtr_data & (uchar)\r\nASC_SYN_MAX_OFFSET));\r\nscsiq->q1.cntl |= (QC_MSG_OUT | QC_URGENT);\r\n}\r\n}\r\nif (asc_dvc->in_critical_cnt != 0) {\r\nAscSetLibErrorCode(asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY);\r\nreturn (ERR);\r\n}\r\nasc_dvc->in_critical_cnt++;\r\nif ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {\r\nif ((sg_entry_cnt = sg_head->entry_cnt) == 0) {\r\nasc_dvc->in_critical_cnt--;\r\nreturn (ERR);\r\n}\r\n#if !CC_VERY_LONG_SG_LIST\r\nif (sg_entry_cnt > ASC_MAX_SG_LIST) {\r\nasc_dvc->in_critical_cnt--;\r\nreturn (ERR);\r\n}\r\n#endif\r\nif (sg_entry_cnt == 1) {\r\nscsiq->q1.data_addr =\r\n(ADV_PADDR)sg_head->sg_list[0].addr;\r\nscsiq->q1.data_cnt =\r\n(ADV_DCNT)sg_head->sg_list[0].bytes;\r\nscsiq->q1.cntl &= ~(QC_SG_HEAD | QC_SG_SWAP_QUEUE);\r\n}\r\nsg_entry_cnt_minus_one = sg_entry_cnt - 1;\r\n}\r\nscsi_cmd = scsiq->cdbptr[0];\r\ndisable_syn_offset_one_fix = FALSE;\r\nif ((asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&\r\n!(asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {\r\nif (scsiq->q1.cntl & QC_SG_HEAD) {\r\ndata_cnt = 0;\r\nfor (i = 0; i < sg_entry_cnt; i++) {\r\ndata_cnt +=\r\n(ADV_DCNT)le32_to_cpu(sg_head->sg_list[i].\r\nbytes);\r\n}\r\n} else {\r\ndata_cnt = le32_to_cpu(scsiq->q1.data_cnt);\r\n}\r\nif (data_cnt != 0UL) {\r\nif (data_cnt < 512UL) {\r\ndisable_syn_offset_one_fix = TRUE;\r\n} else {\r\nfor (i = 0; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST;\r\ni++) {\r\ndisable_cmd =\r\n_syn_offset_one_disable_cmd[i];\r\nif (disable_cmd == 0xFF) {\r\nbreak;\r\n}\r\nif (scsi_cmd == disable_cmd) {\r\ndisable_syn_offset_one_fix =\r\nTRUE;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (disable_syn_offset_one_fix) {\r\nscsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;\r\nscsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |\r\nASC_TAG_FLAG_DISABLE_DISCONNECT);\r\n} else {\r\nscsiq->q2.tag_code &= 0x27;\r\n}\r\nif ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {\r\nif (asc_dvc->bug_fix_cntl) {\r\nif (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {\r\nif ((scsi_cmd == READ_6) ||\r\n(scsi_cmd == READ_10)) {\r\naddr =\r\n(ADV_PADDR)le32_to_cpu(sg_head->\r\nsg_list\r\n[sg_entry_cnt_minus_one].\r\naddr) +\r\n(ADV_DCNT)le32_to_cpu(sg_head->\r\nsg_list\r\n[sg_entry_cnt_minus_one].\r\nbytes);\r\nextra_bytes =\r\n(uchar)((ushort)addr & 0x0003);\r\nif ((extra_bytes != 0)\r\n&&\r\n((scsiq->q2.\r\ntag_code &\r\nASC_TAG_FLAG_EXTRA_BYTES)\r\n== 0)) {\r\nscsiq->q2.tag_code |=\r\nASC_TAG_FLAG_EXTRA_BYTES;\r\nscsiq->q1.extra_bytes =\r\nextra_bytes;\r\ndata_cnt =\r\nle32_to_cpu(sg_head->\r\nsg_list\r\n[sg_entry_cnt_minus_one].\r\nbytes);\r\ndata_cnt -=\r\n(ASC_DCNT) extra_bytes;\r\nsg_head->\r\nsg_list\r\n[sg_entry_cnt_minus_one].\r\nbytes =\r\ncpu_to_le32(data_cnt);\r\n}\r\n}\r\n}\r\n}\r\nsg_head->entry_to_copy = sg_head->entry_cnt;\r\n#if CC_VERY_LONG_SG_LIST\r\nif (sg_entry_cnt > ASC_MAX_SG_LIST) {\r\nsg_entry_cnt = ASC_MAX_SG_LIST;\r\n}\r\n#endif\r\nn_q_required = AscSgListToQueue(sg_entry_cnt);\r\nif ((AscGetNumOfFreeQueue(asc_dvc, target_ix, n_q_required) >=\r\n(uint) n_q_required)\r\n|| ((scsiq->q1.cntl & QC_URGENT) != 0)) {\r\nif ((sta =\r\nAscSendScsiQueue(asc_dvc, scsiq,\r\nn_q_required)) == 1) {\r\nasc_dvc->in_critical_cnt--;\r\nreturn (sta);\r\n}\r\n}\r\n} else {\r\nif (asc_dvc->bug_fix_cntl) {\r\nif (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {\r\nif ((scsi_cmd == READ_6) ||\r\n(scsi_cmd == READ_10)) {\r\naddr =\r\nle32_to_cpu(scsiq->q1.data_addr) +\r\nle32_to_cpu(scsiq->q1.data_cnt);\r\nextra_bytes =\r\n(uchar)((ushort)addr & 0x0003);\r\nif ((extra_bytes != 0)\r\n&&\r\n((scsiq->q2.\r\ntag_code &\r\nASC_TAG_FLAG_EXTRA_BYTES)\r\n== 0)) {\r\ndata_cnt =\r\nle32_to_cpu(scsiq->q1.\r\ndata_cnt);\r\nif (((ushort)data_cnt & 0x01FF)\r\n== 0) {\r\nscsiq->q2.tag_code |=\r\nASC_TAG_FLAG_EXTRA_BYTES;\r\ndata_cnt -= (ASC_DCNT)\r\nextra_bytes;\r\nscsiq->q1.data_cnt =\r\ncpu_to_le32\r\n(data_cnt);\r\nscsiq->q1.extra_bytes =\r\nextra_bytes;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nn_q_required = 1;\r\nif ((AscGetNumOfFreeQueue(asc_dvc, target_ix, 1) >= 1) ||\r\n((scsiq->q1.cntl & QC_URGENT) != 0)) {\r\nif ((sta = AscSendScsiQueue(asc_dvc, scsiq,\r\nn_q_required)) == 1) {\r\nasc_dvc->in_critical_cnt--;\r\nreturn (sta);\r\n}\r\n}\r\n}\r\nasc_dvc->in_critical_cnt--;\r\nreturn (sta);\r\n}\r\nstatic int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)\r\n{\r\nAdvPortAddr iop_base;\r\nADV_PADDR req_paddr;\r\nADV_CARR_T *new_carrp;\r\nif (scsiq->target_id > ADV_MAX_TID) {\r\nscsiq->host_status = QHSTA_M_INVALID_DEVICE;\r\nscsiq->done_status = QD_WITH_ERROR;\r\nreturn ADV_ERROR;\r\n}\r\niop_base = asc_dvc->iop_base;\r\nif ((new_carrp = asc_dvc->carr_freelist) == NULL) {\r\nreturn ADV_BUSY;\r\n}\r\nasc_dvc->carr_freelist = (ADV_CARR_T *)\r\nADV_U32_TO_VADDR(le32_to_cpu(new_carrp->next_vpa));\r\nasc_dvc->carr_pending_cnt++;\r\nnew_carrp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);\r\nscsiq->a_flag &= ~ADV_SCSIQ_DONE;\r\nreq_paddr = virt_to_bus(scsiq);\r\nBUG_ON(req_paddr & 31);\r\nreq_paddr = cpu_to_le32(req_paddr);\r\nscsiq->scsiq_ptr = cpu_to_le32(ADV_VADDR_TO_U32(scsiq));\r\nscsiq->scsiq_rptr = req_paddr;\r\nscsiq->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->icq_sp));\r\nscsiq->carr_pa = asc_dvc->icq_sp->carr_pa;\r\nasc_dvc->icq_sp->areq_vpa = req_paddr;\r\nasc_dvc->icq_sp->next_vpa = new_carrp->carr_pa;\r\nasc_dvc->icq_sp = new_carrp;\r\nif (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||\r\nasc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\r\nAdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_A);\r\nif (asc_dvc->chip_type == ADV_CHIP_ASC3550) {\r\nAdvWriteByteRegister(iop_base, IOPB_TICKLE,\r\nADV_TICKLE_NOP);\r\n}\r\n} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\r\nAdvWriteDWordRegister(iop_base, IOPDW_COMMA,\r\nle32_to_cpu(new_carrp->carr_pa));\r\n}\r\nreturn ADV_SUCCESS;\r\n}\r\nstatic int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)\r\n{\r\nint ret, err_code;\r\nstruct asc_board *boardp = shost_priv(scp->device->host);\r\nASC_DBG(1, "scp 0x%p\n", scp);\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;\r\nstruct asc_scsi_q asc_scsi_q;\r\nret = asc_build_req(boardp, scp, &asc_scsi_q);\r\nif (ret == ASC_ERROR) {\r\nASC_STATS(scp->device->host, build_error);\r\nreturn ASC_ERROR;\r\n}\r\nret = AscExeScsiQueue(asc_dvc, &asc_scsi_q);\r\nkfree(asc_scsi_q.sg_head);\r\nerr_code = asc_dvc->err_code;\r\n} else {\r\nADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;\r\nADV_SCSI_REQ_Q *adv_scsiqp;\r\nswitch (adv_build_req(boardp, scp, &adv_scsiqp)) {\r\ncase ASC_NOERROR:\r\nASC_DBG(3, "adv_build_req ASC_NOERROR\n");\r\nbreak;\r\ncase ASC_BUSY:\r\nASC_DBG(1, "adv_build_req ASC_BUSY\n");\r\nreturn ASC_BUSY;\r\ncase ASC_ERROR:\r\ndefault:\r\nASC_DBG(1, "adv_build_req ASC_ERROR\n");\r\nASC_STATS(scp->device->host, build_error);\r\nreturn ASC_ERROR;\r\n}\r\nret = AdvExeScsiQueue(adv_dvc, adv_scsiqp);\r\nerr_code = adv_dvc->err_code;\r\n}\r\nswitch (ret) {\r\ncase ASC_NOERROR:\r\nASC_STATS(scp->device->host, exe_noerror);\r\nboardp->reqcnt[scp->device->id]++;\r\nASC_DBG(1, "ExeScsiQueue() ASC_NOERROR\n");\r\nbreak;\r\ncase ASC_BUSY:\r\nASC_STATS(scp->device->host, exe_busy);\r\nbreak;\r\ncase ASC_ERROR:\r\nscmd_printk(KERN_ERR, scp, "ExeScsiQueue() ASC_ERROR, "\r\n"err_code 0x%x\n", err_code);\r\nASC_STATS(scp->device->host, exe_error);\r\nscp->result = HOST_BYTE(DID_ERROR);\r\nbreak;\r\ndefault:\r\nscmd_printk(KERN_ERR, scp, "ExeScsiQueue() unknown, "\r\n"err_code 0x%x\n", err_code);\r\nASC_STATS(scp->device->host, exe_unknown);\r\nscp->result = HOST_BYTE(DID_ERROR);\r\nbreak;\r\n}\r\nASC_DBG(1, "end\n");\r\nreturn ret;\r\n}\r\nstatic int\r\nadvansys_queuecommand_lck(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))\r\n{\r\nstruct Scsi_Host *shost = scp->device->host;\r\nint asc_res, result = 0;\r\nASC_STATS(shost, queuecommand);\r\nscp->scsi_done = done;\r\nasc_res = asc_execute_scsi_cmnd(scp);\r\nswitch (asc_res) {\r\ncase ASC_NOERROR:\r\nbreak;\r\ncase ASC_BUSY:\r\nresult = SCSI_MLQUEUE_HOST_BUSY;\r\nbreak;\r\ncase ASC_ERROR:\r\ndefault:\r\nasc_scsi_done(scp);\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic unsigned short AscGetChipBiosAddress(PortAddr iop_base,\r\nunsigned short bus_type)\r\n{\r\nunsigned short cfg_lsw;\r\nunsigned short bios_addr;\r\nif (bus_type & ASC_IS_PCI)\r\nreturn 0;\r\nif ((bus_type & ASC_IS_EISA) != 0) {\r\ncfg_lsw = AscGetEisaChipCfg(iop_base);\r\ncfg_lsw &= 0x000F;\r\nbios_addr = ASC_BIOS_MIN_ADDR + cfg_lsw * ASC_BIOS_BANK_SIZE;\r\nreturn bios_addr;\r\n}\r\ncfg_lsw = AscGetChipCfgLsw(iop_base);\r\nif (bus_type == ASC_IS_ISAPNP)\r\ncfg_lsw &= 0x7FFF;\r\nbios_addr = ASC_BIOS_MIN_ADDR + (cfg_lsw >> 12) * ASC_BIOS_BANK_SIZE;\r\nreturn bios_addr;\r\n}\r\nstatic uchar AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)\r\n{\r\nushort cfg_lsw;\r\nif (AscGetChipScsiID(iop_base) == new_host_id) {\r\nreturn (new_host_id);\r\n}\r\ncfg_lsw = AscGetChipCfgLsw(iop_base);\r\ncfg_lsw &= 0xF8FF;\r\ncfg_lsw |= (ushort)((new_host_id & ASC_MAX_TID) << 8);\r\nAscSetChipCfgLsw(iop_base, cfg_lsw);\r\nreturn (AscGetChipScsiID(iop_base));\r\n}\r\nstatic unsigned char AscGetChipScsiCtrl(PortAddr iop_base)\r\n{\r\nunsigned char sc;\r\nAscSetBank(iop_base, 1);\r\nsc = inp(iop_base + IOP_REG_SC);\r\nAscSetBank(iop_base, 0);\r\nreturn sc;\r\n}\r\nstatic unsigned char AscGetChipVersion(PortAddr iop_base,\r\nunsigned short bus_type)\r\n{\r\nif (bus_type & ASC_IS_EISA) {\r\nPortAddr eisa_iop;\r\nunsigned char revision;\r\neisa_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |\r\n(PortAddr) ASC_EISA_REV_IOP_MASK;\r\nrevision = inp(eisa_iop);\r\nreturn ASC_CHIP_MIN_VER_EISA - 1 + revision;\r\n}\r\nreturn AscGetChipVerNo(iop_base);\r\n}\r\nstatic void AscEnableIsaDma(uchar dma_channel)\r\n{\r\nif (dma_channel < 4) {\r\noutp(0x000B, (ushort)(0xC0 | dma_channel));\r\noutp(0x000A, dma_channel);\r\n} else if (dma_channel < 8) {\r\noutp(0x00D6, (ushort)(0xC0 | (dma_channel - 4)));\r\noutp(0x00D4, (ushort)(dma_channel - 4));\r\n}\r\n}\r\nstatic int AscStopQueueExe(PortAddr iop_base)\r\n{\r\nint count = 0;\r\nif (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) == 0) {\r\nAscWriteLramByte(iop_base, ASCV_STOP_CODE_B,\r\nASC_STOP_REQ_RISC_STOP);\r\ndo {\r\nif (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) &\r\nASC_STOP_ACK_RISC_STOP) {\r\nreturn (1);\r\n}\r\nmdelay(100);\r\n} while (count++ < 20);\r\n}\r\nreturn (0);\r\n}\r\nstatic ASC_DCNT AscGetMaxDmaCount(ushort bus_type)\r\n{\r\nif (bus_type & ASC_IS_ISA)\r\nreturn ASC_MAX_ISA_DMA_COUNT;\r\nelse if (bus_type & (ASC_IS_EISA | ASC_IS_VL))\r\nreturn ASC_MAX_VL_DMA_COUNT;\r\nreturn ASC_MAX_PCI_DMA_COUNT;\r\n}\r\nstatic ushort AscGetIsaDmaChannel(PortAddr iop_base)\r\n{\r\nushort channel;\r\nchannel = AscGetChipCfgLsw(iop_base) & 0x0003;\r\nif (channel == 0x03)\r\nreturn (0);\r\nelse if (channel == 0x00)\r\nreturn (7);\r\nreturn (channel + 4);\r\n}\r\nstatic ushort AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channel)\r\n{\r\nushort cfg_lsw;\r\nuchar value;\r\nif ((dma_channel >= 5) && (dma_channel <= 7)) {\r\nif (dma_channel == 7)\r\nvalue = 0x00;\r\nelse\r\nvalue = dma_channel - 4;\r\ncfg_lsw = AscGetChipCfgLsw(iop_base) & 0xFFFC;\r\ncfg_lsw |= value;\r\nAscSetChipCfgLsw(iop_base, cfg_lsw);\r\nreturn (AscGetIsaDmaChannel(iop_base));\r\n}\r\nreturn 0;\r\n}\r\nstatic uchar AscGetIsaDmaSpeed(PortAddr iop_base)\r\n{\r\nuchar speed_value;\r\nAscSetBank(iop_base, 1);\r\nspeed_value = AscReadChipDmaSpeed(iop_base);\r\nspeed_value &= 0x07;\r\nAscSetBank(iop_base, 0);\r\nreturn speed_value;\r\n}\r\nstatic uchar AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)\r\n{\r\nspeed_value &= 0x07;\r\nAscSetBank(iop_base, 1);\r\nAscWriteChipDmaSpeed(iop_base, speed_value);\r\nAscSetBank(iop_base, 0);\r\nreturn AscGetIsaDmaSpeed(iop_base);\r\n}\r\nstatic ushort AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)\r\n{\r\nint i;\r\nPortAddr iop_base;\r\nushort warn_code;\r\nuchar chip_version;\r\niop_base = asc_dvc->iop_base;\r\nwarn_code = 0;\r\nasc_dvc->err_code = 0;\r\nif ((asc_dvc->bus_type &\r\n(ASC_IS_ISA | ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL)) == 0) {\r\nasc_dvc->err_code |= ASC_IERR_NO_BUS_TYPE;\r\n}\r\nAscSetChipControl(iop_base, CC_HALT);\r\nAscSetChipStatus(iop_base, 0);\r\nasc_dvc->bug_fix_cntl = 0;\r\nasc_dvc->pci_fix_asyn_xfer = 0;\r\nasc_dvc->pci_fix_asyn_xfer_always = 0;\r\nasc_dvc->sdtr_done = 0;\r\nasc_dvc->cur_total_qng = 0;\r\nasc_dvc->is_in_int = 0;\r\nasc_dvc->in_critical_cnt = 0;\r\nasc_dvc->last_q_shortage = 0;\r\nasc_dvc->use_tagged_qng = 0;\r\nasc_dvc->no_scam = 0;\r\nasc_dvc->unit_not_ready = 0;\r\nasc_dvc->queue_full_or_busy = 0;\r\nasc_dvc->redo_scam = 0;\r\nasc_dvc->res2 = 0;\r\nasc_dvc->min_sdtr_index = 0;\r\nasc_dvc->cfg->can_tagged_qng = 0;\r\nasc_dvc->cfg->cmd_qng_enabled = 0;\r\nasc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL;\r\nasc_dvc->init_sdtr = 0;\r\nasc_dvc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG;\r\nasc_dvc->scsi_reset_wait = 3;\r\nasc_dvc->start_motor = ASC_SCSI_WIDTH_BIT_SET;\r\nasc_dvc->max_dma_count = AscGetMaxDmaCount(asc_dvc->bus_type);\r\nasc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;\r\nasc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET;\r\nasc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;\r\nchip_version = AscGetChipVersion(iop_base, asc_dvc->bus_type);\r\nasc_dvc->cfg->chip_version = chip_version;\r\nasc_dvc->sdtr_period_tbl = asc_syn_xfer_period;\r\nasc_dvc->max_sdtr_index = 7;\r\nif ((asc_dvc->bus_type & ASC_IS_PCI) &&\r\n(chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {\r\nasc_dvc->bus_type = ASC_IS_PCI_ULTRA;\r\nasc_dvc->sdtr_period_tbl = asc_syn_ultra_xfer_period;\r\nasc_dvc->max_sdtr_index = 15;\r\nif (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150) {\r\nAscSetExtraControl(iop_base,\r\n(SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));\r\n} else if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050) {\r\nAscSetExtraControl(iop_base,\r\n(SEC_ACTIVE_NEGATE |\r\nSEC_ENABLE_FILTER));\r\n}\r\n}\r\nif (asc_dvc->bus_type == ASC_IS_PCI) {\r\nAscSetExtraControl(iop_base,\r\n(SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));\r\n}\r\nasc_dvc->cfg->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED;\r\n#ifdef CONFIG_ISA\r\nif ((asc_dvc->bus_type & ASC_IS_ISA) != 0) {\r\nif (chip_version >= ASC_CHIP_MIN_VER_ISA_PNP) {\r\nAscSetChipIFC(iop_base, IFC_INIT_DEFAULT);\r\nasc_dvc->bus_type = ASC_IS_ISAPNP;\r\n}\r\nasc_dvc->cfg->isa_dma_channel =\r\n(uchar)AscGetIsaDmaChannel(iop_base);\r\n}\r\n#endif\r\nfor (i = 0; i <= ASC_MAX_TID; i++) {\r\nasc_dvc->cur_dvc_qng[i] = 0;\r\nasc_dvc->max_dvc_qng[i] = ASC_MAX_SCSI1_QNG;\r\nasc_dvc->scsiq_busy_head[i] = (ASC_SCSI_Q *)0L;\r\nasc_dvc->scsiq_busy_tail[i] = (ASC_SCSI_Q *)0L;\r\nasc_dvc->cfg->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;\r\n}\r\nreturn warn_code;\r\n}\r\nstatic int AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)\r\n{\r\nint retry;\r\nfor (retry = 0; retry < ASC_EEP_MAX_RETRY; retry++) {\r\nunsigned char read_back;\r\nAscSetChipEEPCmd(iop_base, cmd_reg);\r\nmdelay(1);\r\nread_back = AscGetChipEEPCmd(iop_base);\r\nif (read_back == cmd_reg)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void AscWaitEEPRead(void)\r\n{\r\nmdelay(1);\r\n}\r\nstatic ushort AscReadEEPWord(PortAddr iop_base, uchar addr)\r\n{\r\nushort read_wval;\r\nuchar cmd_reg;\r\nAscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);\r\nAscWaitEEPRead();\r\ncmd_reg = addr | ASC_EEP_CMD_READ;\r\nAscWriteEEPCmdReg(iop_base, cmd_reg);\r\nAscWaitEEPRead();\r\nread_wval = AscGetChipEEPData(iop_base);\r\nAscWaitEEPRead();\r\nreturn read_wval;\r\n}\r\nstatic ushort AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,\r\nushort bus_type)\r\n{\r\nushort wval;\r\nushort sum;\r\nushort *wbuf;\r\nint cfg_beg;\r\nint cfg_end;\r\nint uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;\r\nint s_addr;\r\nwbuf = (ushort *)cfg_buf;\r\nsum = 0;\r\nfor (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {\r\n*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);\r\nsum += *wbuf;\r\n}\r\nif (bus_type & ASC_IS_VL) {\r\ncfg_beg = ASC_EEP_DVC_CFG_BEG_VL;\r\ncfg_end = ASC_EEP_MAX_DVC_ADDR_VL;\r\n} else {\r\ncfg_beg = ASC_EEP_DVC_CFG_BEG;\r\ncfg_end = ASC_EEP_MAX_DVC_ADDR;\r\n}\r\nfor (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {\r\nwval = AscReadEEPWord(iop_base, (uchar)s_addr);\r\nif (s_addr <= uchar_end_in_config) {\r\n*wbuf = le16_to_cpu(wval);\r\n} else {\r\n*wbuf = wval;\r\n}\r\nsum += wval;\r\n}\r\n*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);\r\nreturn sum;\r\n}\r\nstatic int AscTestExternalLram(ASC_DVC_VAR *asc_dvc)\r\n{\r\nPortAddr iop_base;\r\nushort q_addr;\r\nushort saved_word;\r\nint sta;\r\niop_base = asc_dvc->iop_base;\r\nsta = 0;\r\nq_addr = ASC_QNO_TO_QADDR(241);\r\nsaved_word = AscReadLramWord(iop_base, q_addr);\r\nAscSetChipLramAddr(iop_base, q_addr);\r\nAscSetChipLramData(iop_base, 0x55AA);\r\nmdelay(10);\r\nAscSetChipLramAddr(iop_base, q_addr);\r\nif (AscGetChipLramData(iop_base) == 0x55AA) {\r\nsta = 1;\r\nAscWriteLramWord(iop_base, q_addr, saved_word);\r\n}\r\nreturn (sta);\r\n}\r\nstatic void AscWaitEEPWrite(void)\r\n{\r\nmdelay(20);\r\n}\r\nstatic int AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)\r\n{\r\nushort read_back;\r\nint retry;\r\nretry = 0;\r\nwhile (TRUE) {\r\nAscSetChipEEPData(iop_base, data_reg);\r\nmdelay(1);\r\nread_back = AscGetChipEEPData(iop_base);\r\nif (read_back == data_reg) {\r\nreturn (1);\r\n}\r\nif (retry++ > ASC_EEP_MAX_RETRY) {\r\nreturn (0);\r\n}\r\n}\r\n}\r\nstatic ushort AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)\r\n{\r\nushort read_wval;\r\nread_wval = AscReadEEPWord(iop_base, addr);\r\nif (read_wval != word_val) {\r\nAscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_ABLE);\r\nAscWaitEEPRead();\r\nAscWriteEEPDataReg(iop_base, word_val);\r\nAscWaitEEPRead();\r\nAscWriteEEPCmdReg(iop_base,\r\n(uchar)((uchar)ASC_EEP_CMD_WRITE | addr));\r\nAscWaitEEPWrite();\r\nAscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);\r\nAscWaitEEPRead();\r\nreturn (AscReadEEPWord(iop_base, addr));\r\n}\r\nreturn (read_wval);\r\n}\r\nstatic int AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,\r\nushort bus_type)\r\n{\r\nint n_error;\r\nushort *wbuf;\r\nushort word;\r\nushort sum;\r\nint s_addr;\r\nint cfg_beg;\r\nint cfg_end;\r\nint uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;\r\nwbuf = (ushort *)cfg_buf;\r\nn_error = 0;\r\nsum = 0;\r\nfor (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {\r\nsum += *wbuf;\r\nif (*wbuf != AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {\r\nn_error++;\r\n}\r\n}\r\nif (bus_type & ASC_IS_VL) {\r\ncfg_beg = ASC_EEP_DVC_CFG_BEG_VL;\r\ncfg_end = ASC_EEP_MAX_DVC_ADDR_VL;\r\n} else {\r\ncfg_beg = ASC_EEP_DVC_CFG_BEG;\r\ncfg_end = ASC_EEP_MAX_DVC_ADDR;\r\n}\r\nfor (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {\r\nif (s_addr <= uchar_end_in_config) {\r\nword = cpu_to_le16(*wbuf);\r\nif (word !=\r\nAscWriteEEPWord(iop_base, (uchar)s_addr, word)) {\r\nn_error++;\r\n}\r\n} else {\r\nif (*wbuf !=\r\nAscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {\r\nn_error++;\r\n}\r\n}\r\nsum += *wbuf;\r\n}\r\n*wbuf = sum;\r\nif (sum != AscWriteEEPWord(iop_base, (uchar)s_addr, sum)) {\r\nn_error++;\r\n}\r\nwbuf = (ushort *)cfg_buf;\r\nfor (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {\r\nif (*wbuf != AscReadEEPWord(iop_base, (uchar)s_addr)) {\r\nn_error++;\r\n}\r\n}\r\nif (bus_type & ASC_IS_VL) {\r\ncfg_beg = ASC_EEP_DVC_CFG_BEG_VL;\r\ncfg_end = ASC_EEP_MAX_DVC_ADDR_VL;\r\n} else {\r\ncfg_beg = ASC_EEP_DVC_CFG_BEG;\r\ncfg_end = ASC_EEP_MAX_DVC_ADDR;\r\n}\r\nfor (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {\r\nif (s_addr <= uchar_end_in_config) {\r\nword =\r\nle16_to_cpu(AscReadEEPWord\r\n(iop_base, (uchar)s_addr));\r\n} else {\r\nword = AscReadEEPWord(iop_base, (uchar)s_addr);\r\n}\r\nif (*wbuf != word) {\r\nn_error++;\r\n}\r\n}\r\nif (AscReadEEPWord(iop_base, (uchar)s_addr) != sum) {\r\nn_error++;\r\n}\r\nreturn n_error;\r\n}\r\nstatic int AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,\r\nushort bus_type)\r\n{\r\nint retry;\r\nint n_error;\r\nretry = 0;\r\nwhile (TRUE) {\r\nif ((n_error = AscSetEEPConfigOnce(iop_base, cfg_buf,\r\nbus_type)) == 0) {\r\nbreak;\r\n}\r\nif (++retry > ASC_EEP_MAX_RETRY) {\r\nbreak;\r\n}\r\n}\r\nreturn n_error;\r\n}\r\nstatic ushort AscInitFromEEP(ASC_DVC_VAR *asc_dvc)\r\n{\r\nASCEEP_CONFIG eep_config_buf;\r\nASCEEP_CONFIG *eep_config;\r\nPortAddr iop_base;\r\nushort chksum;\r\nushort warn_code;\r\nushort cfg_msw, cfg_lsw;\r\nint i;\r\nint write_eep = 0;\r\niop_base = asc_dvc->iop_base;\r\nwarn_code = 0;\r\nAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0x00FE);\r\nAscStopQueueExe(iop_base);\r\nif ((AscStopChip(iop_base) == FALSE) ||\r\n(AscGetChipScsiCtrl(iop_base) != 0)) {\r\nasc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE;\r\nAscResetChipAndScsiBus(asc_dvc);\r\nmdelay(asc_dvc->scsi_reset_wait * 1000);\r\n}\r\nif (AscIsChipHalted(iop_base) == FALSE) {\r\nasc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;\r\nreturn (warn_code);\r\n}\r\nAscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);\r\nif (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {\r\nasc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;\r\nreturn (warn_code);\r\n}\r\neep_config = (ASCEEP_CONFIG *)&eep_config_buf;\r\ncfg_msw = AscGetChipCfgMsw(iop_base);\r\ncfg_lsw = AscGetChipCfgLsw(iop_base);\r\nif ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {\r\ncfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\r\nwarn_code |= ASC_WARN_CFG_MSW_RECOVER;\r\nAscSetChipCfgMsw(iop_base, cfg_msw);\r\n}\r\nchksum = AscGetEEPConfig(iop_base, eep_config, asc_dvc->bus_type);\r\nASC_DBG(1, "chksum 0x%x\n", chksum);\r\nif (chksum == 0) {\r\nchksum = 0xaa55;\r\n}\r\nif (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {\r\nwarn_code |= ASC_WARN_AUTO_CONFIG;\r\nif (asc_dvc->cfg->chip_version == 3) {\r\nif (eep_config->cfg_lsw != cfg_lsw) {\r\nwarn_code |= ASC_WARN_EEPROM_RECOVER;\r\neep_config->cfg_lsw =\r\nAscGetChipCfgLsw(iop_base);\r\n}\r\nif (eep_config->cfg_msw != cfg_msw) {\r\nwarn_code |= ASC_WARN_EEPROM_RECOVER;\r\neep_config->cfg_msw =\r\nAscGetChipCfgMsw(iop_base);\r\n}\r\n}\r\n}\r\neep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\r\neep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;\r\nASC_DBG(1, "eep_config->chksum 0x%x\n", eep_config->chksum);\r\nif (chksum != eep_config->chksum) {\r\nif (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==\r\nASC_CHIP_VER_PCI_ULTRA_3050) {\r\nASC_DBG(1, "chksum error ignored; EEPROM-less board\n");\r\neep_config->init_sdtr = 0xFF;\r\neep_config->disc_enable = 0xFF;\r\neep_config->start_motor = 0xFF;\r\neep_config->use_cmd_qng = 0;\r\neep_config->max_total_qng = 0xF0;\r\neep_config->max_tag_qng = 0x20;\r\neep_config->cntl = 0xBFFF;\r\nASC_EEP_SET_CHIP_ID(eep_config, 7);\r\neep_config->no_scam = 0;\r\neep_config->adapter_info[0] = 0;\r\neep_config->adapter_info[1] = 0;\r\neep_config->adapter_info[2] = 0;\r\neep_config->adapter_info[3] = 0;\r\neep_config->adapter_info[4] = 0;\r\neep_config->adapter_info[5] = 0xBB;\r\n} else {\r\nASC_PRINT\r\n("AscInitFromEEP: EEPROM checksum error; Will try to re-write EEPROM.\n");\r\nwrite_eep = 1;\r\nwarn_code |= ASC_WARN_EEPROM_CHKSUM;\r\n}\r\n}\r\nasc_dvc->cfg->sdtr_enable = eep_config->init_sdtr;\r\nasc_dvc->cfg->disc_enable = eep_config->disc_enable;\r\nasc_dvc->cfg->cmd_qng_enabled = eep_config->use_cmd_qng;\r\nasc_dvc->cfg->isa_dma_speed = ASC_EEP_GET_DMA_SPD(eep_config);\r\nasc_dvc->start_motor = eep_config->start_motor;\r\nasc_dvc->dvc_cntl = eep_config->cntl;\r\nasc_dvc->no_scam = eep_config->no_scam;\r\nasc_dvc->cfg->adapter_info[0] = eep_config->adapter_info[0];\r\nasc_dvc->cfg->adapter_info[1] = eep_config->adapter_info[1];\r\nasc_dvc->cfg->adapter_info[2] = eep_config->adapter_info[2];\r\nasc_dvc->cfg->adapter_info[3] = eep_config->adapter_info[3];\r\nasc_dvc->cfg->adapter_info[4] = eep_config->adapter_info[4];\r\nasc_dvc->cfg->adapter_info[5] = eep_config->adapter_info[5];\r\nif (!AscTestExternalLram(asc_dvc)) {\r\nif (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) ==\r\nASC_IS_PCI_ULTRA)) {\r\neep_config->max_total_qng =\r\nASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG;\r\neep_config->max_tag_qng =\r\nASC_MAX_PCI_ULTRA_INRAM_TAG_QNG;\r\n} else {\r\neep_config->cfg_msw |= 0x0800;\r\ncfg_msw |= 0x0800;\r\nAscSetChipCfgMsw(iop_base, cfg_msw);\r\neep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG;\r\neep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG;\r\n}\r\n} else {\r\n}\r\nif (eep_config->max_total_qng < ASC_MIN_TOTAL_QNG) {\r\neep_config->max_total_qng = ASC_MIN_TOTAL_QNG;\r\n}\r\nif (eep_config->max_total_qng > ASC_MAX_TOTAL_QNG) {\r\neep_config->max_total_qng = ASC_MAX_TOTAL_QNG;\r\n}\r\nif (eep_config->max_tag_qng > eep_config->max_total_qng) {\r\neep_config->max_tag_qng = eep_config->max_total_qng;\r\n}\r\nif (eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC) {\r\neep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC;\r\n}\r\nasc_dvc->max_total_qng = eep_config->max_total_qng;\r\nif ((eep_config->use_cmd_qng & eep_config->disc_enable) !=\r\neep_config->use_cmd_qng) {\r\neep_config->disc_enable = eep_config->use_cmd_qng;\r\nwarn_code |= ASC_WARN_CMD_QNG_CONFLICT;\r\n}\r\nASC_EEP_SET_CHIP_ID(eep_config,\r\nASC_EEP_GET_CHIP_ID(eep_config) & ASC_MAX_TID);\r\nasc_dvc->cfg->chip_scsi_id = ASC_EEP_GET_CHIP_ID(eep_config);\r\nif (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&\r\n!(asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {\r\nasc_dvc->min_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;\r\n}\r\nfor (i = 0; i <= ASC_MAX_TID; i++) {\r\nasc_dvc->dos_int13_table[i] = eep_config->dos_int13_table[i];\r\nasc_dvc->cfg->max_tag_qng[i] = eep_config->max_tag_qng;\r\nasc_dvc->cfg->sdtr_period_offset[i] =\r\n(uchar)(ASC_DEF_SDTR_OFFSET |\r\n(asc_dvc->min_sdtr_index << 4));\r\n}\r\neep_config->cfg_msw = AscGetChipCfgMsw(iop_base);\r\nif (write_eep) {\r\nif ((i = AscSetEEPConfig(iop_base, eep_config,\r\nasc_dvc->bus_type)) != 0) {\r\nASC_PRINT1\r\n("AscInitFromEEP: Failed to re-write EEPROM with %d errors.\n",\r\ni);\r\n} else {\r\nASC_PRINT\r\n("AscInitFromEEP: Successfully re-wrote EEPROM.\n");\r\n}\r\n}\r\nreturn (warn_code);\r\n}\r\nstatic int AscInitGetConfig(struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *board = shost_priv(shost);\r\nASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;\r\nunsigned short warn_code = 0;\r\nasc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;\r\nif (asc_dvc->err_code != 0)\r\nreturn asc_dvc->err_code;\r\nif (AscFindSignature(asc_dvc->iop_base)) {\r\nwarn_code |= AscInitAscDvcVar(asc_dvc);\r\nwarn_code |= AscInitFromEEP(asc_dvc);\r\nasc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;\r\nif (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)\r\nasc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;\r\n} else {\r\nasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\r\n}\r\nswitch (warn_code) {\r\ncase 0:\r\nbreak;\r\ncase ASC_WARN_IO_PORT_ROTATE:\r\nshost_printk(KERN_WARNING, shost, "I/O port address "\r\n"modified\n");\r\nbreak;\r\ncase ASC_WARN_AUTO_CONFIG:\r\nshost_printk(KERN_WARNING, shost, "I/O port increment switch "\r\n"enabled\n");\r\nbreak;\r\ncase ASC_WARN_EEPROM_CHKSUM:\r\nshost_printk(KERN_WARNING, shost, "EEPROM checksum error\n");\r\nbreak;\r\ncase ASC_WARN_IRQ_MODIFIED:\r\nshost_printk(KERN_WARNING, shost, "IRQ modified\n");\r\nbreak;\r\ncase ASC_WARN_CMD_QNG_CONFLICT:\r\nshost_printk(KERN_WARNING, shost, "tag queuing enabled w/o "\r\n"disconnects\n");\r\nbreak;\r\ndefault:\r\nshost_printk(KERN_WARNING, shost, "unknown warning: 0x%x\n",\r\nwarn_code);\r\nbreak;\r\n}\r\nif (asc_dvc->err_code != 0)\r\nshost_printk(KERN_ERR, shost, "error 0x%x at init_state "\r\n"0x%x\n", asc_dvc->err_code, asc_dvc->init_state);\r\nreturn asc_dvc->err_code;\r\n}\r\nstatic int AscInitSetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *board = shost_priv(shost);\r\nASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;\r\nPortAddr iop_base = asc_dvc->iop_base;\r\nunsigned short cfg_msw;\r\nunsigned short warn_code = 0;\r\nasc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG;\r\nif (asc_dvc->err_code != 0)\r\nreturn asc_dvc->err_code;\r\nif (!AscFindSignature(asc_dvc->iop_base)) {\r\nasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\r\nreturn asc_dvc->err_code;\r\n}\r\ncfg_msw = AscGetChipCfgMsw(iop_base);\r\nif ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {\r\ncfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\r\nwarn_code |= ASC_WARN_CFG_MSW_RECOVER;\r\nAscSetChipCfgMsw(iop_base, cfg_msw);\r\n}\r\nif ((asc_dvc->cfg->cmd_qng_enabled & asc_dvc->cfg->disc_enable) !=\r\nasc_dvc->cfg->cmd_qng_enabled) {\r\nasc_dvc->cfg->disc_enable = asc_dvc->cfg->cmd_qng_enabled;\r\nwarn_code |= ASC_WARN_CMD_QNG_CONFLICT;\r\n}\r\nif (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {\r\nwarn_code |= ASC_WARN_AUTO_CONFIG;\r\n}\r\n#ifdef CONFIG_PCI\r\nif (asc_dvc->bus_type & ASC_IS_PCI) {\r\ncfg_msw &= 0xFFC0;\r\nAscSetChipCfgMsw(iop_base, cfg_msw);\r\nif ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {\r\n} else {\r\nif ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||\r\n(pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {\r\nasc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;\r\nasc_dvc->bug_fix_cntl |=\r\nASC_BUG_FIX_ASYN_USE_SYN;\r\n}\r\n}\r\n} else\r\n#endif\r\nif (asc_dvc->bus_type == ASC_IS_ISAPNP) {\r\nif (AscGetChipVersion(iop_base, asc_dvc->bus_type)\r\n== ASC_CHIP_VER_ASYN_BUG) {\r\nasc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;\r\n}\r\n}\r\nif (AscSetChipScsiID(iop_base, asc_dvc->cfg->chip_scsi_id) !=\r\nasc_dvc->cfg->chip_scsi_id) {\r\nasc_dvc->err_code |= ASC_IERR_SET_SCSI_ID;\r\n}\r\n#ifdef CONFIG_ISA\r\nif (asc_dvc->bus_type & ASC_IS_ISA) {\r\nAscSetIsaDmaChannel(iop_base, asc_dvc->cfg->isa_dma_channel);\r\nAscSetIsaDmaSpeed(iop_base, asc_dvc->cfg->isa_dma_speed);\r\n}\r\n#endif\r\nasc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;\r\nswitch (warn_code) {\r\ncase 0:\r\nbreak;\r\ncase ASC_WARN_IO_PORT_ROTATE:\r\nshost_printk(KERN_WARNING, shost, "I/O port address "\r\n"modified\n");\r\nbreak;\r\ncase ASC_WARN_AUTO_CONFIG:\r\nshost_printk(KERN_WARNING, shost, "I/O port increment switch "\r\n"enabled\n");\r\nbreak;\r\ncase ASC_WARN_EEPROM_CHKSUM:\r\nshost_printk(KERN_WARNING, shost, "EEPROM checksum error\n");\r\nbreak;\r\ncase ASC_WARN_IRQ_MODIFIED:\r\nshost_printk(KERN_WARNING, shost, "IRQ modified\n");\r\nbreak;\r\ncase ASC_WARN_CMD_QNG_CONFLICT:\r\nshost_printk(KERN_WARNING, shost, "tag queuing w/o "\r\n"disconnects\n");\r\nbreak;\r\ndefault:\r\nshost_printk(KERN_WARNING, shost, "unknown warning: 0x%x\n",\r\nwarn_code);\r\nbreak;\r\n}\r\nif (asc_dvc->err_code != 0)\r\nshost_printk(KERN_ERR, shost, "error 0x%x at init_state "\r\n"0x%x\n", asc_dvc->err_code, asc_dvc->init_state);\r\nreturn asc_dvc->err_code;\r\n}\r\nstatic void AdvWaitEEPCmd(AdvPortAddr iop_base)\r\n{\r\nint eep_delay_ms;\r\nfor (eep_delay_ms = 0; eep_delay_ms < ADV_EEP_DELAY_MS; eep_delay_ms++) {\r\nif (AdvReadWordRegister(iop_base, IOPW_EE_CMD) &\r\nASC_EEP_CMD_DONE) {\r\nbreak;\r\n}\r\nmdelay(1);\r\n}\r\nif ((AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) ==\r\n0)\r\nBUG();\r\n}\r\nstatic ushort AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)\r\n{\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\r\nASC_EEP_CMD_READ | eep_word_addr);\r\nAdvWaitEEPCmd(iop_base);\r\nreturn AdvReadWordRegister(iop_base, IOPW_EE_DATA);\r\n}\r\nstatic void AdvSet3550EEPConfig(AdvPortAddr iop_base,\r\nADVEEP_3550_CONFIG *cfg_buf)\r\n{\r\nushort *wbuf;\r\nushort addr, chksum;\r\nushort *charfields;\r\nwbuf = (ushort *)cfg_buf;\r\ncharfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;\r\nchksum = 0;\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\r\nAdvWaitEEPCmd(iop_base);\r\nfor (addr = ADV_EEP_DVC_CFG_BEGIN;\r\naddr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {\r\nushort word;\r\nif (*charfields++) {\r\nword = cpu_to_le16(*wbuf);\r\n} else {\r\nword = *wbuf;\r\n}\r\nchksum += *wbuf;\r\nAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\r\nASC_EEP_CMD_WRITE | addr);\r\nAdvWaitEEPCmd(iop_base);\r\nmdelay(ADV_EEP_DELAY_MS);\r\n}\r\nAdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);\r\nAdvWaitEEPCmd(iop_base);\r\nwbuf++;\r\ncharfields++;\r\nfor (addr = ADV_EEP_DVC_CTL_BEGIN;\r\naddr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\r\nushort word;\r\nif (*charfields++) {\r\nword = cpu_to_le16(*wbuf);\r\n} else {\r\nword = *wbuf;\r\n}\r\nAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\r\nASC_EEP_CMD_WRITE | addr);\r\nAdvWaitEEPCmd(iop_base);\r\n}\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);\r\nAdvWaitEEPCmd(iop_base);\r\n}\r\nstatic void AdvSet38C0800EEPConfig(AdvPortAddr iop_base,\r\nADVEEP_38C0800_CONFIG *cfg_buf)\r\n{\r\nushort *wbuf;\r\nushort *charfields;\r\nushort addr, chksum;\r\nwbuf = (ushort *)cfg_buf;\r\ncharfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;\r\nchksum = 0;\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\r\nAdvWaitEEPCmd(iop_base);\r\nfor (addr = ADV_EEP_DVC_CFG_BEGIN;\r\naddr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {\r\nushort word;\r\nif (*charfields++) {\r\nword = cpu_to_le16(*wbuf);\r\n} else {\r\nword = *wbuf;\r\n}\r\nchksum += *wbuf;\r\nAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\r\nASC_EEP_CMD_WRITE | addr);\r\nAdvWaitEEPCmd(iop_base);\r\nmdelay(ADV_EEP_DELAY_MS);\r\n}\r\nAdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);\r\nAdvWaitEEPCmd(iop_base);\r\nwbuf++;\r\ncharfields++;\r\nfor (addr = ADV_EEP_DVC_CTL_BEGIN;\r\naddr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\r\nushort word;\r\nif (*charfields++) {\r\nword = cpu_to_le16(*wbuf);\r\n} else {\r\nword = *wbuf;\r\n}\r\nAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\r\nASC_EEP_CMD_WRITE | addr);\r\nAdvWaitEEPCmd(iop_base);\r\n}\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);\r\nAdvWaitEEPCmd(iop_base);\r\n}\r\nstatic void AdvSet38C1600EEPConfig(AdvPortAddr iop_base,\r\nADVEEP_38C1600_CONFIG *cfg_buf)\r\n{\r\nushort *wbuf;\r\nushort *charfields;\r\nushort addr, chksum;\r\nwbuf = (ushort *)cfg_buf;\r\ncharfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;\r\nchksum = 0;\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\r\nAdvWaitEEPCmd(iop_base);\r\nfor (addr = ADV_EEP_DVC_CFG_BEGIN;\r\naddr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {\r\nushort word;\r\nif (*charfields++) {\r\nword = cpu_to_le16(*wbuf);\r\n} else {\r\nword = *wbuf;\r\n}\r\nchksum += *wbuf;\r\nAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\r\nASC_EEP_CMD_WRITE | addr);\r\nAdvWaitEEPCmd(iop_base);\r\nmdelay(ADV_EEP_DELAY_MS);\r\n}\r\nAdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);\r\nAdvWaitEEPCmd(iop_base);\r\nwbuf++;\r\ncharfields++;\r\nfor (addr = ADV_EEP_DVC_CTL_BEGIN;\r\naddr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\r\nushort word;\r\nif (*charfields++) {\r\nword = cpu_to_le16(*wbuf);\r\n} else {\r\nword = *wbuf;\r\n}\r\nAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\r\nASC_EEP_CMD_WRITE | addr);\r\nAdvWaitEEPCmd(iop_base);\r\n}\r\nAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);\r\nAdvWaitEEPCmd(iop_base);\r\n}\r\nstatic ushort AdvGet3550EEPConfig(AdvPortAddr iop_base,\r\nADVEEP_3550_CONFIG *cfg_buf)\r\n{\r\nushort wval, chksum;\r\nushort *wbuf;\r\nint eep_addr;\r\nushort *charfields;\r\ncharfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;\r\nwbuf = (ushort *)cfg_buf;\r\nchksum = 0;\r\nfor (eep_addr = ADV_EEP_DVC_CFG_BEGIN;\r\neep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {\r\nwval = AdvReadEEPWord(iop_base, eep_addr);\r\nchksum += wval;\r\nif (*charfields++) {\r\n*wbuf = le16_to_cpu(wval);\r\n} else {\r\n*wbuf = wval;\r\n}\r\n}\r\n*wbuf = AdvReadEEPWord(iop_base, eep_addr);\r\nwbuf++;\r\ncharfields++;\r\nfor (eep_addr = ADV_EEP_DVC_CTL_BEGIN;\r\neep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {\r\n*wbuf = AdvReadEEPWord(iop_base, eep_addr);\r\nif (*charfields++) {\r\n*wbuf = le16_to_cpu(*wbuf);\r\n}\r\n}\r\nreturn chksum;\r\n}\r\nstatic ushort AdvGet38C0800EEPConfig(AdvPortAddr iop_base,\r\nADVEEP_38C0800_CONFIG *cfg_buf)\r\n{\r\nushort wval, chksum;\r\nushort *wbuf;\r\nint eep_addr;\r\nushort *charfields;\r\ncharfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;\r\nwbuf = (ushort *)cfg_buf;\r\nchksum = 0;\r\nfor (eep_addr = ADV_EEP_DVC_CFG_BEGIN;\r\neep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {\r\nwval = AdvReadEEPWord(iop_base, eep_addr);\r\nchksum += wval;\r\nif (*charfields++) {\r\n*wbuf = le16_to_cpu(wval);\r\n} else {\r\n*wbuf = wval;\r\n}\r\n}\r\n*wbuf = AdvReadEEPWord(iop_base, eep_addr);\r\nwbuf++;\r\ncharfields++;\r\nfor (eep_addr = ADV_EEP_DVC_CTL_BEGIN;\r\neep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {\r\n*wbuf = AdvReadEEPWord(iop_base, eep_addr);\r\nif (*charfields++) {\r\n*wbuf = le16_to_cpu(*wbuf);\r\n}\r\n}\r\nreturn chksum;\r\n}\r\nstatic ushort AdvGet38C1600EEPConfig(AdvPortAddr iop_base,\r\nADVEEP_38C1600_CONFIG *cfg_buf)\r\n{\r\nushort wval, chksum;\r\nushort *wbuf;\r\nint eep_addr;\r\nushort *charfields;\r\ncharfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;\r\nwbuf = (ushort *)cfg_buf;\r\nchksum = 0;\r\nfor (eep_addr = ADV_EEP_DVC_CFG_BEGIN;\r\neep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {\r\nwval = AdvReadEEPWord(iop_base, eep_addr);\r\nchksum += wval;\r\nif (*charfields++) {\r\n*wbuf = le16_to_cpu(wval);\r\n} else {\r\n*wbuf = wval;\r\n}\r\n}\r\n*wbuf = AdvReadEEPWord(iop_base, eep_addr);\r\nwbuf++;\r\ncharfields++;\r\nfor (eep_addr = ADV_EEP_DVC_CTL_BEGIN;\r\neep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {\r\n*wbuf = AdvReadEEPWord(iop_base, eep_addr);\r\nif (*charfields++) {\r\n*wbuf = le16_to_cpu(*wbuf);\r\n}\r\n}\r\nreturn chksum;\r\n}\r\nstatic int AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)\r\n{\r\nAdvPortAddr iop_base;\r\nushort warn_code;\r\nADVEEP_3550_CONFIG eep_config;\r\niop_base = asc_dvc->iop_base;\r\nwarn_code = 0;\r\nif (AdvGet3550EEPConfig(iop_base, &eep_config) != eep_config.check_sum) {\r\nwarn_code |= ASC_WARN_EEPROM_CHKSUM;\r\nmemcpy(&eep_config, &Default_3550_EEPROM_Config,\r\nsizeof(ADVEEP_3550_CONFIG));\r\neep_config.serial_number_word3 =\r\nAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);\r\neep_config.serial_number_word2 =\r\nAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);\r\neep_config.serial_number_word1 =\r\nAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);\r\nAdvSet3550EEPConfig(iop_base, &eep_config);\r\n}\r\nasc_dvc->wdtr_able = eep_config.wdtr_able;\r\nasc_dvc->sdtr_able = eep_config.sdtr_able;\r\nasc_dvc->ultra_able = eep_config.ultra_able;\r\nasc_dvc->tagqng_able = eep_config.tagqng_able;\r\nasc_dvc->cfg->disc_enable = eep_config.disc_enable;\r\nasc_dvc->max_host_qng = eep_config.max_host_qng;\r\nasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\r\nasc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);\r\nasc_dvc->start_motor = eep_config.start_motor;\r\nasc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;\r\nasc_dvc->bios_ctrl = eep_config.bios_ctrl;\r\nasc_dvc->no_scam = eep_config.scam_tolerant;\r\nasc_dvc->cfg->serial1 = eep_config.serial_number_word1;\r\nasc_dvc->cfg->serial2 = eep_config.serial_number_word2;\r\nasc_dvc->cfg->serial3 = eep_config.serial_number_word3;\r\nif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\r\neep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\r\n} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\r\nif (eep_config.max_host_qng == 0) {\r\neep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\r\n} else {\r\neep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\r\n}\r\n}\r\nif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\r\neep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\r\n} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\r\nif (eep_config.max_dvc_qng == 0) {\r\neep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\r\n} else {\r\neep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\r\n}\r\n}\r\nif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\r\neep_config.max_dvc_qng = eep_config.max_host_qng;\r\n}\r\nasc_dvc->max_host_qng = eep_config.max_host_qng;\r\nasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\r\nif (eep_config.termination == 0) {\r\nasc_dvc->cfg->termination = 0;\r\n} else {\r\nif (eep_config.termination == 1) {\r\nasc_dvc->cfg->termination = TERM_CTL_SEL;\r\n} else if (eep_config.termination == 2) {\r\nasc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H;\r\n} else if (eep_config.termination == 3) {\r\nasc_dvc->cfg->termination =\r\nTERM_CTL_SEL | TERM_CTL_H | TERM_CTL_L;\r\n} else {\r\nasc_dvc->cfg->termination = 0;\r\nwarn_code |= ASC_WARN_EEPROM_TERMINATION;\r\n}\r\n}\r\nreturn warn_code;\r\n}\r\nstatic int AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)\r\n{\r\nAdvPortAddr iop_base;\r\nushort warn_code;\r\nADVEEP_38C0800_CONFIG eep_config;\r\nuchar tid, termination;\r\nushort sdtr_speed = 0;\r\niop_base = asc_dvc->iop_base;\r\nwarn_code = 0;\r\nif (AdvGet38C0800EEPConfig(iop_base, &eep_config) !=\r\neep_config.check_sum) {\r\nwarn_code |= ASC_WARN_EEPROM_CHKSUM;\r\nmemcpy(&eep_config, &Default_38C0800_EEPROM_Config,\r\nsizeof(ADVEEP_38C0800_CONFIG));\r\neep_config.serial_number_word3 =\r\nAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);\r\neep_config.serial_number_word2 =\r\nAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);\r\neep_config.serial_number_word1 =\r\nAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);\r\nAdvSet38C0800EEPConfig(iop_base, &eep_config);\r\n}\r\nasc_dvc->wdtr_able = eep_config.wdtr_able;\r\nasc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;\r\nasc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;\r\nasc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;\r\nasc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;\r\nasc_dvc->tagqng_able = eep_config.tagqng_able;\r\nasc_dvc->cfg->disc_enable = eep_config.disc_enable;\r\nasc_dvc->max_host_qng = eep_config.max_host_qng;\r\nasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\r\nasc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);\r\nasc_dvc->start_motor = eep_config.start_motor;\r\nasc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;\r\nasc_dvc->bios_ctrl = eep_config.bios_ctrl;\r\nasc_dvc->no_scam = eep_config.scam_tolerant;\r\nasc_dvc->cfg->serial1 = eep_config.serial_number_word1;\r\nasc_dvc->cfg->serial2 = eep_config.serial_number_word2;\r\nasc_dvc->cfg->serial3 = eep_config.serial_number_word3;\r\nasc_dvc->sdtr_able = 0;\r\nfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\r\nif (tid == 0) {\r\nsdtr_speed = asc_dvc->sdtr_speed1;\r\n} else if (tid == 4) {\r\nsdtr_speed = asc_dvc->sdtr_speed2;\r\n} else if (tid == 8) {\r\nsdtr_speed = asc_dvc->sdtr_speed3;\r\n} else if (tid == 12) {\r\nsdtr_speed = asc_dvc->sdtr_speed4;\r\n}\r\nif (sdtr_speed & ADV_MAX_TID) {\r\nasc_dvc->sdtr_able |= (1 << tid);\r\n}\r\nsdtr_speed >>= 4;\r\n}\r\nif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\r\neep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\r\n} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\r\nif (eep_config.max_host_qng == 0) {\r\neep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\r\n} else {\r\neep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\r\n}\r\n}\r\nif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\r\neep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\r\n} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\r\nif (eep_config.max_dvc_qng == 0) {\r\neep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\r\n} else {\r\neep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\r\n}\r\n}\r\nif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\r\neep_config.max_dvc_qng = eep_config.max_host_qng;\r\n}\r\nasc_dvc->max_host_qng = eep_config.max_host_qng;\r\nasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\r\nif (eep_config.termination_se == 0) {\r\ntermination = 0;\r\n} else {\r\nif (eep_config.termination_se == 1) {\r\ntermination = 0;\r\n} else if (eep_config.termination_se == 2) {\r\ntermination = TERM_SE_HI;\r\n} else if (eep_config.termination_se == 3) {\r\ntermination = TERM_SE;\r\n} else {\r\ntermination = 0;\r\nwarn_code |= ASC_WARN_EEPROM_TERMINATION;\r\n}\r\n}\r\nif (eep_config.termination_lvd == 0) {\r\nasc_dvc->cfg->termination = termination;\r\n} else {\r\nif (eep_config.termination_lvd == 1) {\r\nasc_dvc->cfg->termination = termination;\r\n} else if (eep_config.termination_lvd == 2) {\r\nasc_dvc->cfg->termination = termination | TERM_LVD_HI;\r\n} else if (eep_config.termination_lvd == 3) {\r\nasc_dvc->cfg->termination = termination | TERM_LVD;\r\n} else {\r\nasc_dvc->cfg->termination = termination;\r\nwarn_code |= ASC_WARN_EEPROM_TERMINATION;\r\n}\r\n}\r\nreturn warn_code;\r\n}\r\nstatic int AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)\r\n{\r\nAdvPortAddr iop_base;\r\nushort warn_code;\r\nADVEEP_38C1600_CONFIG eep_config;\r\nuchar tid, termination;\r\nushort sdtr_speed = 0;\r\niop_base = asc_dvc->iop_base;\r\nwarn_code = 0;\r\nif (AdvGet38C1600EEPConfig(iop_base, &eep_config) !=\r\neep_config.check_sum) {\r\nstruct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);\r\nwarn_code |= ASC_WARN_EEPROM_CHKSUM;\r\nmemcpy(&eep_config, &Default_38C1600_EEPROM_Config,\r\nsizeof(ADVEEP_38C1600_CONFIG));\r\nif (PCI_FUNC(pdev->devfn) != 0) {\r\nu8 ints;\r\neep_config.cfg_lsw &= ~ADV_EEPROM_BIOS_ENABLE;\r\nAdvWriteByteRegister(iop_base, IOPB_GPIO_CNTL, 0);\r\nints = AdvReadByteRegister(iop_base, IOPB_GPIO_DATA);\r\nif ((ints & 0x01) == 0)\r\neep_config.cfg_lsw &= ~ADV_EEPROM_INTAB;\r\n}\r\neep_config.serial_number_word3 =\r\nAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);\r\neep_config.serial_number_word2 =\r\nAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);\r\neep_config.serial_number_word1 =\r\nAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);\r\nAdvSet38C1600EEPConfig(iop_base, &eep_config);\r\n}\r\nasc_dvc->wdtr_able = eep_config.wdtr_able;\r\nasc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;\r\nasc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;\r\nasc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;\r\nasc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;\r\nasc_dvc->ppr_able = 0;\r\nasc_dvc->tagqng_able = eep_config.tagqng_able;\r\nasc_dvc->cfg->disc_enable = eep_config.disc_enable;\r\nasc_dvc->max_host_qng = eep_config.max_host_qng;\r\nasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\r\nasc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ASC_MAX_TID);\r\nasc_dvc->start_motor = eep_config.start_motor;\r\nasc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;\r\nasc_dvc->bios_ctrl = eep_config.bios_ctrl;\r\nasc_dvc->no_scam = eep_config.scam_tolerant;\r\nasc_dvc->sdtr_able = 0;\r\nfor (tid = 0; tid <= ASC_MAX_TID; tid++) {\r\nif (tid == 0) {\r\nsdtr_speed = asc_dvc->sdtr_speed1;\r\n} else if (tid == 4) {\r\nsdtr_speed = asc_dvc->sdtr_speed2;\r\n} else if (tid == 8) {\r\nsdtr_speed = asc_dvc->sdtr_speed3;\r\n} else if (tid == 12) {\r\nsdtr_speed = asc_dvc->sdtr_speed4;\r\n}\r\nif (sdtr_speed & ASC_MAX_TID) {\r\nasc_dvc->sdtr_able |= (1 << tid);\r\n}\r\nsdtr_speed >>= 4;\r\n}\r\nif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\r\neep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\r\n} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\r\nif (eep_config.max_host_qng == 0) {\r\neep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\r\n} else {\r\neep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\r\n}\r\n}\r\nif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\r\neep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\r\n} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\r\nif (eep_config.max_dvc_qng == 0) {\r\neep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\r\n} else {\r\neep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\r\n}\r\n}\r\nif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\r\neep_config.max_dvc_qng = eep_config.max_host_qng;\r\n}\r\nasc_dvc->max_host_qng = eep_config.max_host_qng;\r\nasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\r\nif (eep_config.termination_se == 0) {\r\ntermination = 0;\r\n} else {\r\nif (eep_config.termination_se == 1) {\r\ntermination = 0;\r\n} else if (eep_config.termination_se == 2) {\r\ntermination = TERM_SE_HI;\r\n} else if (eep_config.termination_se == 3) {\r\ntermination = TERM_SE;\r\n} else {\r\ntermination = 0;\r\nwarn_code |= ASC_WARN_EEPROM_TERMINATION;\r\n}\r\n}\r\nif (eep_config.termination_lvd == 0) {\r\nasc_dvc->cfg->termination = termination;\r\n} else {\r\nif (eep_config.termination_lvd == 1) {\r\nasc_dvc->cfg->termination = termination;\r\n} else if (eep_config.termination_lvd == 2) {\r\nasc_dvc->cfg->termination = termination | TERM_LVD_HI;\r\n} else if (eep_config.termination_lvd == 3) {\r\nasc_dvc->cfg->termination = termination | TERM_LVD;\r\n} else {\r\nasc_dvc->cfg->termination = termination;\r\nwarn_code |= ASC_WARN_EEPROM_TERMINATION;\r\n}\r\n}\r\nreturn warn_code;\r\n}\r\nstatic int AdvInitGetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *board = shost_priv(shost);\r\nADV_DVC_VAR *asc_dvc = &board->dvc_var.adv_dvc_var;\r\nunsigned short warn_code = 0;\r\nAdvPortAddr iop_base = asc_dvc->iop_base;\r\nu16 cmd;\r\nint status;\r\nasc_dvc->err_code = 0;\r\nasc_dvc->cfg->control_flag = 0;\r\npci_read_config_word(pdev, PCI_COMMAND, &cmd);\r\nif ((cmd & PCI_COMMAND_PARITY) == 0)\r\nasc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;\r\nasc_dvc->cfg->chip_version =\r\nAdvGetChipVersion(iop_base, asc_dvc->bus_type);\r\nASC_DBG(1, "iopb_chip_id_1: 0x%x 0x%x\n",\r\n(ushort)AdvReadByteRegister(iop_base, IOPB_CHIP_ID_1),\r\n(ushort)ADV_CHIP_ID_BYTE);\r\nASC_DBG(1, "iopw_chip_id_0: 0x%x 0x%x\n",\r\n(ushort)AdvReadWordRegister(iop_base, IOPW_CHIP_ID_0),\r\n(ushort)ADV_CHIP_ID_WORD);\r\nif (AdvFindSignature(iop_base) == 0) {\r\nasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\r\nreturn ADV_ERROR;\r\n} else {\r\nif (asc_dvc->chip_type != ADV_CHIP_ASC3550 &&\r\nasc_dvc->chip_type != ADV_CHIP_ASC38C0800 &&\r\nasc_dvc->chip_type != ADV_CHIP_ASC38C1600) {\r\nasc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;\r\nreturn ADV_ERROR;\r\n}\r\nAdvWriteWordRegister(iop_base, IOPW_CTRL_REG,\r\nADV_CTRL_REG_CMD_RESET);\r\nmdelay(100);\r\nAdvWriteWordRegister(iop_base, IOPW_CTRL_REG,\r\nADV_CTRL_REG_CMD_WR_IO_REG);\r\nif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\r\nstatus = AdvInitFrom38C1600EEP(asc_dvc);\r\n} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\r\nstatus = AdvInitFrom38C0800EEP(asc_dvc);\r\n} else {\r\nstatus = AdvInitFrom3550EEP(asc_dvc);\r\n}\r\nwarn_code |= status;\r\n}\r\nif (warn_code != 0)\r\nshost_printk(KERN_WARNING, shost, "warning: 0x%x\n", warn_code);\r\nif (asc_dvc->err_code)\r\nshost_printk(KERN_ERR, shost, "error code 0x%x\n",\r\nasc_dvc->err_code);\r\nreturn asc_dvc->err_code;\r\n}\r\nstatic int advansys_wide_init_chip(struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *board = shost_priv(shost);\r\nstruct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;\r\nint req_cnt = 0;\r\nadv_req_t *reqp = NULL;\r\nint sg_cnt = 0;\r\nadv_sgblk_t *sgp;\r\nint warn_code, err_code;\r\nadv_dvc->carrier_buf = kmalloc(ADV_CARRIER_BUFSIZE, GFP_KERNEL);\r\nASC_DBG(1, "carrier_buf 0x%p\n", adv_dvc->carrier_buf);\r\nif (!adv_dvc->carrier_buf)\r\ngoto kmalloc_failed;\r\nfor (req_cnt = adv_dvc->max_host_qng; req_cnt > 0; req_cnt--) {\r\nreqp = kmalloc(sizeof(adv_req_t) * req_cnt, GFP_KERNEL);\r\nASC_DBG(1, "reqp 0x%p, req_cnt %d, bytes %lu\n", reqp, req_cnt,\r\n(ulong)sizeof(adv_req_t) * req_cnt);\r\nif (reqp)\r\nbreak;\r\n}\r\nif (!reqp)\r\ngoto kmalloc_failed;\r\nadv_dvc->orig_reqp = reqp;\r\nboard->adv_sgblkp = NULL;\r\nfor (sg_cnt = 0; sg_cnt < ADV_TOT_SG_BLOCK; sg_cnt++) {\r\nsgp = kmalloc(sizeof(adv_sgblk_t), GFP_KERNEL);\r\nif (!sgp)\r\nbreak;\r\nsgp->next_sgblkp = board->adv_sgblkp;\r\nboard->adv_sgblkp = sgp;\r\n}\r\nASC_DBG(1, "sg_cnt %d * %lu = %lu bytes\n", sg_cnt, sizeof(adv_sgblk_t),\r\nsizeof(adv_sgblk_t) * sg_cnt);\r\nif (!board->adv_sgblkp)\r\ngoto kmalloc_failed;\r\nreq_cnt--;\r\nreqp[req_cnt].next_reqp = NULL;\r\nfor (; req_cnt > 0; req_cnt--) {\r\nreqp[req_cnt - 1].next_reqp = &reqp[req_cnt];\r\n}\r\nboard->adv_reqp = &reqp[0];\r\nif (adv_dvc->chip_type == ADV_CHIP_ASC3550) {\r\nASC_DBG(2, "AdvInitAsc3550Driver()\n");\r\nwarn_code = AdvInitAsc3550Driver(adv_dvc);\r\n} else if (adv_dvc->chip_type == ADV_CHIP_ASC38C0800) {\r\nASC_DBG(2, "AdvInitAsc38C0800Driver()\n");\r\nwarn_code = AdvInitAsc38C0800Driver(adv_dvc);\r\n} else {\r\nASC_DBG(2, "AdvInitAsc38C1600Driver()\n");\r\nwarn_code = AdvInitAsc38C1600Driver(adv_dvc);\r\n}\r\nerr_code = adv_dvc->err_code;\r\nif (warn_code || err_code) {\r\nshost_printk(KERN_WARNING, shost, "error: warn 0x%x, error "\r\n"0x%x\n", warn_code, err_code);\r\n}\r\ngoto exit;\r\nkmalloc_failed:\r\nshost_printk(KERN_ERR, shost, "error: kmalloc() failed\n");\r\nerr_code = ADV_ERROR;\r\nexit:\r\nreturn err_code;\r\n}\r\nstatic void advansys_wide_free_mem(struct asc_board *board)\r\n{\r\nstruct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;\r\nkfree(adv_dvc->carrier_buf);\r\nadv_dvc->carrier_buf = NULL;\r\nkfree(adv_dvc->orig_reqp);\r\nadv_dvc->orig_reqp = board->adv_reqp = NULL;\r\nwhile (board->adv_sgblkp) {\r\nadv_sgblk_t *sgp = board->adv_sgblkp;\r\nboard->adv_sgblkp = sgp->next_sgblkp;\r\nkfree(sgp);\r\n}\r\n}\r\nstatic int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,\r\nint bus_type)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct asc_board *boardp = shost_priv(shost);\r\nASC_DVC_VAR *asc_dvc_varp = NULL;\r\nADV_DVC_VAR *adv_dvc_varp = NULL;\r\nint share_irq, warn_code, ret;\r\npdev = (bus_type == ASC_IS_PCI) ? to_pci_dev(boardp->dev) : NULL;\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nASC_DBG(1, "narrow board\n");\r\nasc_dvc_varp = &boardp->dvc_var.asc_dvc_var;\r\nasc_dvc_varp->bus_type = bus_type;\r\nasc_dvc_varp->drv_ptr = boardp;\r\nasc_dvc_varp->cfg = &boardp->dvc_cfg.asc_dvc_cfg;\r\nasc_dvc_varp->iop_base = iop;\r\n} else {\r\n#ifdef CONFIG_PCI\r\nadv_dvc_varp = &boardp->dvc_var.adv_dvc_var;\r\nadv_dvc_varp->drv_ptr = boardp;\r\nadv_dvc_varp->cfg = &boardp->dvc_cfg.adv_dvc_cfg;\r\nif (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW) {\r\nASC_DBG(1, "wide board ASC-3550\n");\r\nadv_dvc_varp->chip_type = ADV_CHIP_ASC3550;\r\n} else if (pdev->device == PCI_DEVICE_ID_38C0800_REV1) {\r\nASC_DBG(1, "wide board ASC-38C0800\n");\r\nadv_dvc_varp->chip_type = ADV_CHIP_ASC38C0800;\r\n} else {\r\nASC_DBG(1, "wide board ASC-38C1600\n");\r\nadv_dvc_varp->chip_type = ADV_CHIP_ASC38C1600;\r\n}\r\nboardp->asc_n_io_port = pci_resource_len(pdev, 1);\r\nboardp->ioremap_addr = pci_ioremap_bar(pdev, 1);\r\nif (!boardp->ioremap_addr) {\r\nshost_printk(KERN_ERR, shost, "ioremap(%lx, %d) "\r\n"returned NULL\n",\r\n(long)pci_resource_start(pdev, 1),\r\nboardp->asc_n_io_port);\r\nret = -ENODEV;\r\ngoto err_shost;\r\n}\r\nadv_dvc_varp->iop_base = (AdvPortAddr)boardp->ioremap_addr;\r\nASC_DBG(1, "iop_base: 0x%p\n", adv_dvc_varp->iop_base);\r\nboardp->ioport = iop;\r\nASC_DBG(1, "iopb_chip_id_1 0x%x, iopw_chip_id_0 0x%x\n",\r\n(ushort)inp(iop + 1), (ushort)inpw(iop));\r\n#endif\r\n}\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nswitch (asc_dvc_varp->bus_type) {\r\n#ifdef CONFIG_ISA\r\ncase ASC_IS_ISA:\r\nshost->unchecked_isa_dma = TRUE;\r\nshare_irq = 0;\r\nbreak;\r\ncase ASC_IS_VL:\r\nshost->unchecked_isa_dma = FALSE;\r\nshare_irq = 0;\r\nbreak;\r\ncase ASC_IS_EISA:\r\nshost->unchecked_isa_dma = FALSE;\r\nshare_irq = IRQF_SHARED;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_PCI\r\ncase ASC_IS_PCI:\r\nshost->unchecked_isa_dma = FALSE;\r\nshare_irq = IRQF_SHARED;\r\nbreak;\r\n#endif\r\ndefault:\r\nshost_printk(KERN_ERR, shost, "unknown adapter type: "\r\n"%d\n", asc_dvc_varp->bus_type);\r\nshost->unchecked_isa_dma = TRUE;\r\nshare_irq = 0;\r\nbreak;\r\n}\r\nASC_DBG(2, "AscInitGetConfig()\n");\r\nret = AscInitGetConfig(shost) ? -ENODEV : 0;\r\n} else {\r\n#ifdef CONFIG_PCI\r\nshost->unchecked_isa_dma = FALSE;\r\nshare_irq = IRQF_SHARED;\r\nASC_DBG(2, "AdvInitGetConfig()\n");\r\nret = AdvInitGetConfig(pdev, shost) ? -ENODEV : 0;\r\n#endif\r\n}\r\nif (ret)\r\ngoto err_unmap;\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nASCEEP_CONFIG *ep;\r\nboardp->init_tidmask |=\r\nADV_TID_TO_TIDMASK(asc_dvc_varp->cfg->chip_scsi_id);\r\nep = &boardp->eep_config.asc_eep;\r\nep->init_sdtr = asc_dvc_varp->cfg->sdtr_enable;\r\nep->disc_enable = asc_dvc_varp->cfg->disc_enable;\r\nep->use_cmd_qng = asc_dvc_varp->cfg->cmd_qng_enabled;\r\nASC_EEP_SET_DMA_SPD(ep, asc_dvc_varp->cfg->isa_dma_speed);\r\nep->start_motor = asc_dvc_varp->start_motor;\r\nep->cntl = asc_dvc_varp->dvc_cntl;\r\nep->no_scam = asc_dvc_varp->no_scam;\r\nep->max_total_qng = asc_dvc_varp->max_total_qng;\r\nASC_EEP_SET_CHIP_ID(ep, asc_dvc_varp->cfg->chip_scsi_id);\r\nep->max_tag_qng = asc_dvc_varp->cfg->max_tag_qng[0];\r\nep->adapter_info[0] = asc_dvc_varp->cfg->adapter_info[0];\r\nep->adapter_info[1] = asc_dvc_varp->cfg->adapter_info[1];\r\nep->adapter_info[2] = asc_dvc_varp->cfg->adapter_info[2];\r\nep->adapter_info[3] = asc_dvc_varp->cfg->adapter_info[3];\r\nep->adapter_info[4] = asc_dvc_varp->cfg->adapter_info[4];\r\nep->adapter_info[5] = asc_dvc_varp->cfg->adapter_info[5];\r\nASC_DBG(2, "AscInitSetConfig()\n");\r\nret = AscInitSetConfig(pdev, shost) ? -ENODEV : 0;\r\nif (ret)\r\ngoto err_unmap;\r\n} else {\r\nADVEEP_3550_CONFIG *ep_3550;\r\nADVEEP_38C0800_CONFIG *ep_38C0800;\r\nADVEEP_38C1600_CONFIG *ep_38C1600;\r\nif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\r\nep_3550 = &boardp->eep_config.adv_3550_eep;\r\nep_3550->adapter_scsi_id = adv_dvc_varp->chip_scsi_id;\r\nep_3550->max_host_qng = adv_dvc_varp->max_host_qng;\r\nep_3550->max_dvc_qng = adv_dvc_varp->max_dvc_qng;\r\nep_3550->termination = adv_dvc_varp->cfg->termination;\r\nep_3550->disc_enable = adv_dvc_varp->cfg->disc_enable;\r\nep_3550->bios_ctrl = adv_dvc_varp->bios_ctrl;\r\nep_3550->wdtr_able = adv_dvc_varp->wdtr_able;\r\nep_3550->sdtr_able = adv_dvc_varp->sdtr_able;\r\nep_3550->ultra_able = adv_dvc_varp->ultra_able;\r\nep_3550->tagqng_able = adv_dvc_varp->tagqng_able;\r\nep_3550->start_motor = adv_dvc_varp->start_motor;\r\nep_3550->scsi_reset_delay =\r\nadv_dvc_varp->scsi_reset_wait;\r\nep_3550->serial_number_word1 =\r\nadv_dvc_varp->cfg->serial1;\r\nep_3550->serial_number_word2 =\r\nadv_dvc_varp->cfg->serial2;\r\nep_3550->serial_number_word3 =\r\nadv_dvc_varp->cfg->serial3;\r\n} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\r\nep_38C0800 = &boardp->eep_config.adv_38C0800_eep;\r\nep_38C0800->adapter_scsi_id =\r\nadv_dvc_varp->chip_scsi_id;\r\nep_38C0800->max_host_qng = adv_dvc_varp->max_host_qng;\r\nep_38C0800->max_dvc_qng = adv_dvc_varp->max_dvc_qng;\r\nep_38C0800->termination_lvd =\r\nadv_dvc_varp->cfg->termination;\r\nep_38C0800->disc_enable =\r\nadv_dvc_varp->cfg->disc_enable;\r\nep_38C0800->bios_ctrl = adv_dvc_varp->bios_ctrl;\r\nep_38C0800->wdtr_able = adv_dvc_varp->wdtr_able;\r\nep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;\r\nep_38C0800->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;\r\nep_38C0800->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;\r\nep_38C0800->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;\r\nep_38C0800->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;\r\nep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;\r\nep_38C0800->start_motor = adv_dvc_varp->start_motor;\r\nep_38C0800->scsi_reset_delay =\r\nadv_dvc_varp->scsi_reset_wait;\r\nep_38C0800->serial_number_word1 =\r\nadv_dvc_varp->cfg->serial1;\r\nep_38C0800->serial_number_word2 =\r\nadv_dvc_varp->cfg->serial2;\r\nep_38C0800->serial_number_word3 =\r\nadv_dvc_varp->cfg->serial3;\r\n} else {\r\nep_38C1600 = &boardp->eep_config.adv_38C1600_eep;\r\nep_38C1600->adapter_scsi_id =\r\nadv_dvc_varp->chip_scsi_id;\r\nep_38C1600->max_host_qng = adv_dvc_varp->max_host_qng;\r\nep_38C1600->max_dvc_qng = adv_dvc_varp->max_dvc_qng;\r\nep_38C1600->termination_lvd =\r\nadv_dvc_varp->cfg->termination;\r\nep_38C1600->disc_enable =\r\nadv_dvc_varp->cfg->disc_enable;\r\nep_38C1600->bios_ctrl = adv_dvc_varp->bios_ctrl;\r\nep_38C1600->wdtr_able = adv_dvc_varp->wdtr_able;\r\nep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;\r\nep_38C1600->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;\r\nep_38C1600->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;\r\nep_38C1600->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;\r\nep_38C1600->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;\r\nep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;\r\nep_38C1600->start_motor = adv_dvc_varp->start_motor;\r\nep_38C1600->scsi_reset_delay =\r\nadv_dvc_varp->scsi_reset_wait;\r\nep_38C1600->serial_number_word1 =\r\nadv_dvc_varp->cfg->serial1;\r\nep_38C1600->serial_number_word2 =\r\nadv_dvc_varp->cfg->serial2;\r\nep_38C1600->serial_number_word3 =\r\nadv_dvc_varp->cfg->serial3;\r\n}\r\nboardp->init_tidmask |=\r\nADV_TID_TO_TIDMASK(adv_dvc_varp->chip_scsi_id);\r\n}\r\nshost->max_channel = 0;\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nshost->max_id = ASC_MAX_TID + 1;\r\nshost->max_lun = ASC_MAX_LUN + 1;\r\nshost->max_cmd_len = ASC_MAX_CDB_LEN;\r\nshost->io_port = asc_dvc_varp->iop_base;\r\nboardp->asc_n_io_port = ASC_IOADR_GAP;\r\nshost->this_id = asc_dvc_varp->cfg->chip_scsi_id;\r\nshost->can_queue = asc_dvc_varp->max_total_qng;\r\n} else {\r\nshost->max_id = ADV_MAX_TID + 1;\r\nshost->max_lun = ADV_MAX_LUN + 1;\r\nshost->max_cmd_len = ADV_MAX_CDB_LEN;\r\nshost->io_port = iop;\r\nshost->this_id = adv_dvc_varp->chip_scsi_id;\r\nshost->can_queue = adv_dvc_varp->max_host_qng;\r\n}\r\nshost->cmd_per_lun = 1;\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nshost->sg_tablesize =\r\n(((asc_dvc_varp->max_total_qng - 2) / 2) *\r\nASC_SG_LIST_PER_Q) + 1;\r\n} else {\r\nshost->sg_tablesize = ADV_MAX_SG_LIST;\r\n}\r\nif (shost->sg_tablesize > SG_ALL) {\r\nshost->sg_tablesize = SG_ALL;\r\n}\r\nASC_DBG(1, "sg_tablesize: %d\n", shost->sg_tablesize);\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nshost->base = AscGetChipBiosAddress(asc_dvc_varp->iop_base,\r\nasc_dvc_varp->bus_type);\r\n} else {\r\nAdvReadWordLram(adv_dvc_varp->iop_base,\r\nBIOS_SIGNATURE, boardp->bios_signature);\r\nAdvReadWordLram(adv_dvc_varp->iop_base,\r\nBIOS_VERSION, boardp->bios_version);\r\nAdvReadWordLram(adv_dvc_varp->iop_base,\r\nBIOS_CODESEG, boardp->bios_codeseg);\r\nAdvReadWordLram(adv_dvc_varp->iop_base,\r\nBIOS_CODELEN, boardp->bios_codelen);\r\nASC_DBG(1, "bios_signature 0x%x, bios_version 0x%x\n",\r\nboardp->bios_signature, boardp->bios_version);\r\nASC_DBG(1, "bios_codeseg 0x%x, bios_codelen 0x%x\n",\r\nboardp->bios_codeseg, boardp->bios_codelen);\r\nif (boardp->bios_signature == 0x55AA) {\r\nshost->base = ((ulong)boardp->bios_codeseg << 4);\r\n} else {\r\nshost->base = 0;\r\n}\r\n}\r\nshost->dma_channel = NO_ISA_DMA;\r\n#ifdef CONFIG_ISA\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nif (asc_dvc_varp->bus_type & ASC_IS_ISA) {\r\nshost->dma_channel = asc_dvc_varp->cfg->isa_dma_channel;\r\nret = request_dma(shost->dma_channel, DRV_NAME);\r\nif (ret) {\r\nshost_printk(KERN_ERR, shost, "request_dma() "\r\n"%d failed %d\n",\r\nshost->dma_channel, ret);\r\ngoto err_unmap;\r\n}\r\nAscEnableIsaDma(shost->dma_channel);\r\n}\r\n}\r\n#endif\r\nASC_DBG(2, "request_irq(%d, %p)\n", boardp->irq, shost);\r\nret = request_irq(boardp->irq, advansys_interrupt, share_irq,\r\nDRV_NAME, shost);\r\nif (ret) {\r\nif (ret == -EBUSY) {\r\nshost_printk(KERN_ERR, shost, "request_irq(): IRQ 0x%x "\r\n"already in use\n", boardp->irq);\r\n} else if (ret == -EINVAL) {\r\nshost_printk(KERN_ERR, shost, "request_irq(): IRQ 0x%x "\r\n"not valid\n", boardp->irq);\r\n} else {\r\nshost_printk(KERN_ERR, shost, "request_irq(): IRQ 0x%x "\r\n"failed with %d\n", boardp->irq, ret);\r\n}\r\ngoto err_free_dma;\r\n}\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nASC_DBG(2, "AscInitAsc1000Driver()\n");\r\nasc_dvc_varp->overrun_buf = kzalloc(ASC_OVERRUN_BSIZE, GFP_KERNEL);\r\nif (!asc_dvc_varp->overrun_buf) {\r\nret = -ENOMEM;\r\ngoto err_free_irq;\r\n}\r\nwarn_code = AscInitAsc1000Driver(asc_dvc_varp);\r\nif (warn_code || asc_dvc_varp->err_code) {\r\nshost_printk(KERN_ERR, shost, "error: init_state 0x%x, "\r\n"warn 0x%x, error 0x%x\n",\r\nasc_dvc_varp->init_state, warn_code,\r\nasc_dvc_varp->err_code);\r\nif (!asc_dvc_varp->overrun_dma) {\r\nret = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\n}\r\n} else {\r\nif (advansys_wide_init_chip(shost)) {\r\nret = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\n}\r\nASC_DBG_PRT_SCSI_HOST(2, shost);\r\nret = scsi_add_host(shost, boardp->dev);\r\nif (ret)\r\ngoto err_free_mem;\r\nscsi_scan_host(shost);\r\nreturn 0;\r\nerr_free_mem:\r\nif (ASC_NARROW_BOARD(boardp)) {\r\nif (asc_dvc_varp->overrun_dma)\r\ndma_unmap_single(boardp->dev, asc_dvc_varp->overrun_dma,\r\nASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\r\nkfree(asc_dvc_varp->overrun_buf);\r\n} else\r\nadvansys_wide_free_mem(boardp);\r\nerr_free_irq:\r\nfree_irq(boardp->irq, shost);\r\nerr_free_dma:\r\n#ifdef CONFIG_ISA\r\nif (shost->dma_channel != NO_ISA_DMA)\r\nfree_dma(shost->dma_channel);\r\n#endif\r\nerr_unmap:\r\nif (boardp->ioremap_addr)\r\niounmap(boardp->ioremap_addr);\r\nerr_shost:\r\nreturn ret;\r\n}\r\nstatic int advansys_release(struct Scsi_Host *shost)\r\n{\r\nstruct asc_board *board = shost_priv(shost);\r\nASC_DBG(1, "begin\n");\r\nscsi_remove_host(shost);\r\nfree_irq(board->irq, shost);\r\n#ifdef CONFIG_ISA\r\nif (shost->dma_channel != NO_ISA_DMA) {\r\nASC_DBG(1, "free_dma()\n");\r\nfree_dma(shost->dma_channel);\r\n}\r\n#endif\r\nif (ASC_NARROW_BOARD(board)) {\r\ndma_unmap_single(board->dev,\r\nboard->dvc_var.asc_dvc_var.overrun_dma,\r\nASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\r\nkfree(board->dvc_var.asc_dvc_var.overrun_buf);\r\n} else {\r\niounmap(board->ioremap_addr);\r\nadvansys_wide_free_mem(board);\r\n}\r\nscsi_host_put(shost);\r\nASC_DBG(1, "end\n");\r\nreturn 0;\r\n}\r\nstatic unsigned int advansys_isa_irq_no(PortAddr iop_base)\r\n{\r\nunsigned short cfg_lsw = AscGetChipCfgLsw(iop_base);\r\nunsigned int chip_irq = ((cfg_lsw >> 2) & 0x03) + 10;\r\nif (chip_irq == 13)\r\nchip_irq = 15;\r\nreturn chip_irq;\r\n}\r\nstatic int advansys_isa_probe(struct device *dev, unsigned int id)\r\n{\r\nint err = -ENODEV;\r\nPortAddr iop_base = _asc_def_iop_base[id];\r\nstruct Scsi_Host *shost;\r\nstruct asc_board *board;\r\nif (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {\r\nASC_DBG(1, "I/O port 0x%x busy\n", iop_base);\r\nreturn -ENODEV;\r\n}\r\nASC_DBG(1, "probing I/O port 0x%x\n", iop_base);\r\nif (!AscFindSignature(iop_base))\r\ngoto release_region;\r\nif (!(AscGetChipVersion(iop_base, ASC_IS_ISA) & ASC_CHIP_VER_ISA_BIT))\r\ngoto release_region;\r\nerr = -ENOMEM;\r\nshost = scsi_host_alloc(&advansys_template, sizeof(*board));\r\nif (!shost)\r\ngoto release_region;\r\nboard = shost_priv(shost);\r\nboard->irq = advansys_isa_irq_no(iop_base);\r\nboard->dev = dev;\r\nerr = advansys_board_found(shost, iop_base, ASC_IS_ISA);\r\nif (err)\r\ngoto free_host;\r\ndev_set_drvdata(dev, shost);\r\nreturn 0;\r\nfree_host:\r\nscsi_host_put(shost);\r\nrelease_region:\r\nrelease_region(iop_base, ASC_IOADR_GAP);\r\nreturn err;\r\n}\r\nstatic int advansys_isa_remove(struct device *dev, unsigned int id)\r\n{\r\nint ioport = _asc_def_iop_base[id];\r\nadvansys_release(dev_get_drvdata(dev));\r\nrelease_region(ioport, ASC_IOADR_GAP);\r\nreturn 0;\r\n}\r\nstatic unsigned int advansys_vlb_irq_no(PortAddr iop_base)\r\n{\r\nunsigned short cfg_lsw = AscGetChipCfgLsw(iop_base);\r\nunsigned int chip_irq = ((cfg_lsw >> 2) & 0x07) + 9;\r\nif ((chip_irq < 10) || (chip_irq == 13) || (chip_irq > 15))\r\nreturn 0;\r\nreturn chip_irq;\r\n}\r\nstatic int advansys_vlb_probe(struct device *dev, unsigned int id)\r\n{\r\nint err = -ENODEV;\r\nPortAddr iop_base = _asc_def_iop_base[id];\r\nstruct Scsi_Host *shost;\r\nstruct asc_board *board;\r\nif (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {\r\nASC_DBG(1, "I/O port 0x%x busy\n", iop_base);\r\nreturn -ENODEV;\r\n}\r\nASC_DBG(1, "probing I/O port 0x%x\n", iop_base);\r\nif (!AscFindSignature(iop_base))\r\ngoto release_region;\r\nif (AscGetChipVersion(iop_base, ASC_IS_VL) > ASC_CHIP_MAX_VER_VL)\r\ngoto release_region;\r\nerr = -ENOMEM;\r\nshost = scsi_host_alloc(&advansys_template, sizeof(*board));\r\nif (!shost)\r\ngoto release_region;\r\nboard = shost_priv(shost);\r\nboard->irq = advansys_vlb_irq_no(iop_base);\r\nboard->dev = dev;\r\nerr = advansys_board_found(shost, iop_base, ASC_IS_VL);\r\nif (err)\r\ngoto free_host;\r\ndev_set_drvdata(dev, shost);\r\nreturn 0;\r\nfree_host:\r\nscsi_host_put(shost);\r\nrelease_region:\r\nrelease_region(iop_base, ASC_IOADR_GAP);\r\nreturn -ENODEV;\r\n}\r\nstatic unsigned int advansys_eisa_irq_no(struct eisa_device *edev)\r\n{\r\nunsigned short cfg_lsw = inw(edev->base_addr + 0xc86);\r\nunsigned int chip_irq = ((cfg_lsw >> 8) & 0x07) + 10;\r\nif ((chip_irq == 13) || (chip_irq > 15))\r\nreturn 0;\r\nreturn chip_irq;\r\n}\r\nstatic int advansys_eisa_probe(struct device *dev)\r\n{\r\nint i, ioport, irq = 0;\r\nint err;\r\nstruct eisa_device *edev = to_eisa_device(dev);\r\nstruct eisa_scsi_data *data;\r\nerr = -ENOMEM;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\ngoto fail;\r\nioport = edev->base_addr + 0xc30;\r\nerr = -ENODEV;\r\nfor (i = 0; i < 2; i++, ioport += 0x20) {\r\nstruct asc_board *board;\r\nstruct Scsi_Host *shost;\r\nif (!request_region(ioport, ASC_IOADR_GAP, DRV_NAME)) {\r\nprintk(KERN_WARNING "Region %x-%x busy\n", ioport,\r\nioport + ASC_IOADR_GAP - 1);\r\ncontinue;\r\n}\r\nif (!AscFindSignature(ioport)) {\r\nrelease_region(ioport, ASC_IOADR_GAP);\r\ncontinue;\r\n}\r\ninw(ioport + 4);\r\nif (!irq)\r\nirq = advansys_eisa_irq_no(edev);\r\nerr = -ENOMEM;\r\nshost = scsi_host_alloc(&advansys_template, sizeof(*board));\r\nif (!shost)\r\ngoto release_region;\r\nboard = shost_priv(shost);\r\nboard->irq = irq;\r\nboard->dev = dev;\r\nerr = advansys_board_found(shost, ioport, ASC_IS_EISA);\r\nif (!err) {\r\ndata->host[i] = shost;\r\ncontinue;\r\n}\r\nscsi_host_put(shost);\r\nrelease_region:\r\nrelease_region(ioport, ASC_IOADR_GAP);\r\nbreak;\r\n}\r\nif (err)\r\ngoto free_data;\r\ndev_set_drvdata(dev, data);\r\nreturn 0;\r\nfree_data:\r\nkfree(data->host[0]);\r\nkfree(data->host[1]);\r\nkfree(data);\r\nfail:\r\nreturn err;\r\n}\r\nstatic int advansys_eisa_remove(struct device *dev)\r\n{\r\nint i;\r\nstruct eisa_scsi_data *data = dev_get_drvdata(dev);\r\nfor (i = 0; i < 2; i++) {\r\nint ioport;\r\nstruct Scsi_Host *shost = data->host[i];\r\nif (!shost)\r\ncontinue;\r\nioport = shost->io_port;\r\nadvansys_release(shost);\r\nrelease_region(ioport, ASC_IOADR_GAP);\r\n}\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic void advansys_set_latency(struct pci_dev *pdev)\r\n{\r\nif ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||\r\n(pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0);\r\n} else {\r\nu8 latency;\r\npci_read_config_byte(pdev, PCI_LATENCY_TIMER, &latency);\r\nif (latency < 0x20)\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x20);\r\n}\r\n}\r\nstatic int advansys_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint err, ioport;\r\nstruct Scsi_Host *shost;\r\nstruct asc_board *board;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\ngoto fail;\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err)\r\ngoto disable_device;\r\npci_set_master(pdev);\r\nadvansys_set_latency(pdev);\r\nerr = -ENODEV;\r\nif (pci_resource_len(pdev, 0) == 0)\r\ngoto release_region;\r\nioport = pci_resource_start(pdev, 0);\r\nerr = -ENOMEM;\r\nshost = scsi_host_alloc(&advansys_template, sizeof(*board));\r\nif (!shost)\r\ngoto release_region;\r\nboard = shost_priv(shost);\r\nboard->irq = pdev->irq;\r\nboard->dev = &pdev->dev;\r\nif (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW ||\r\npdev->device == PCI_DEVICE_ID_38C0800_REV1 ||\r\npdev->device == PCI_DEVICE_ID_38C1600_REV1) {\r\nboard->flags |= ASC_IS_WIDE_BOARD;\r\n}\r\nerr = advansys_board_found(shost, ioport, ASC_IS_PCI);\r\nif (err)\r\ngoto free_host;\r\npci_set_drvdata(pdev, shost);\r\nreturn 0;\r\nfree_host:\r\nscsi_host_put(shost);\r\nrelease_region:\r\npci_release_regions(pdev);\r\ndisable_device:\r\npci_disable_device(pdev);\r\nfail:\r\nreturn err;\r\n}\r\nstatic void advansys_pci_remove(struct pci_dev *pdev)\r\n{\r\nadvansys_release(pci_get_drvdata(pdev));\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init advansys_init(void)\r\n{\r\nint error;\r\nerror = isa_register_driver(&advansys_isa_driver,\r\nASC_IOADR_TABLE_MAX_IX);\r\nif (error)\r\ngoto fail;\r\nerror = isa_register_driver(&advansys_vlb_driver,\r\nASC_IOADR_TABLE_MAX_IX);\r\nif (error)\r\ngoto unregister_isa;\r\nerror = eisa_driver_register(&advansys_eisa_driver);\r\nif (error)\r\ngoto unregister_vlb;\r\nerror = pci_register_driver(&advansys_pci_driver);\r\nif (error)\r\ngoto unregister_eisa;\r\nreturn 0;\r\nunregister_eisa:\r\neisa_driver_unregister(&advansys_eisa_driver);\r\nunregister_vlb:\r\nisa_unregister_driver(&advansys_vlb_driver);\r\nunregister_isa:\r\nisa_unregister_driver(&advansys_isa_driver);\r\nfail:\r\nreturn error;\r\n}\r\nstatic void __exit advansys_exit(void)\r\n{\r\npci_unregister_driver(&advansys_pci_driver);\r\neisa_driver_unregister(&advansys_eisa_driver);\r\nisa_unregister_driver(&advansys_vlb_driver);\r\nisa_unregister_driver(&advansys_isa_driver);\r\n}
