static struct mt9v032 *to_mt9v032(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct mt9v032, subdev);\r\n}\r\nstatic int mt9v032_read(struct i2c_client *client, const u8 reg)\r\n{\r\ns32 data = i2c_smbus_read_word_swapped(client, reg);\r\ndev_dbg(&client->dev, "%s: read 0x%04x from 0x%02x\n", __func__,\r\ndata, reg);\r\nreturn data;\r\n}\r\nstatic int mt9v032_write(struct i2c_client *client, const u8 reg,\r\nconst u16 data)\r\n{\r\ndev_dbg(&client->dev, "%s: writing 0x%04x to 0x%02x\n", __func__,\r\ndata, reg);\r\nreturn i2c_smbus_write_word_swapped(client, reg, data);\r\n}\r\nstatic int mt9v032_set_chip_control(struct mt9v032 *mt9v032, u16 clear, u16 set)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);\r\nu16 value = (mt9v032->chip_control & ~clear) | set;\r\nint ret;\r\nret = mt9v032_write(client, MT9V032_CHIP_CONTROL, value);\r\nif (ret < 0)\r\nreturn ret;\r\nmt9v032->chip_control = value;\r\nreturn 0;\r\n}\r\nstatic int\r\nmt9v032_update_aec_agc(struct mt9v032 *mt9v032, u16 which, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);\r\nu16 value = mt9v032->aec_agc;\r\nint ret;\r\nif (enable)\r\nvalue |= which;\r\nelse\r\nvalue &= ~which;\r\nret = mt9v032_write(client, MT9V032_AEC_AGC_ENABLE, value);\r\nif (ret < 0)\r\nreturn ret;\r\nmt9v032->aec_agc = value;\r\nreturn 0;\r\n}\r\nstatic int\r\nmt9v032_update_hblank(struct mt9v032 *mt9v032)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);\r\nstruct v4l2_rect *crop = &mt9v032->crop;\r\nunsigned int min_hblank = mt9v032->model->data->min_hblank;\r\nunsigned int hblank;\r\nif (mt9v032->version->version == MT9V034_CHIP_ID_REV1)\r\nmin_hblank += (mt9v032->hratio - 1) * 10;\r\nmin_hblank = max_t(unsigned int, (int)mt9v032->model->data->min_row_time - crop->width,\r\n(int)min_hblank);\r\nhblank = max_t(unsigned int, mt9v032->hblank, min_hblank);\r\nreturn mt9v032_write(client, MT9V032_HORIZONTAL_BLANKING, hblank);\r\n}\r\nstatic int mt9v032_power_on(struct mt9v032 *mt9v032)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);\r\nint ret;\r\nret = clk_set_rate(mt9v032->clk, mt9v032->sysclk);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_prepare_enable(mt9v032->clk);\r\nif (ret)\r\nreturn ret;\r\nudelay(1);\r\nret = mt9v032_write(client, MT9V032_RESET, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9v032_write(client, MT9V032_RESET, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9v032_write(client, MT9V032_CHIP_CONTROL, 0);\r\n}\r\nstatic void mt9v032_power_off(struct mt9v032 *mt9v032)\r\n{\r\nclk_disable_unprepare(mt9v032->clk);\r\n}\r\nstatic int __mt9v032_set_power(struct mt9v032 *mt9v032, bool on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);\r\nint ret;\r\nif (!on) {\r\nmt9v032_power_off(mt9v032);\r\nreturn 0;\r\n}\r\nret = mt9v032_power_on(mt9v032);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mt9v032->pdata && mt9v032->pdata->clk_pol) {\r\nret = mt9v032_write(client, mt9v032->model->data->pclk_reg,\r\nMT9V032_PIXEL_CLOCK_INV_PXL_CLK);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = mt9v032_write(client, MT9V032_ROW_NOISE_CORR_CONTROL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn v4l2_ctrl_handler_setup(&mt9v032->ctrls);\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__mt9v032_get_pad_format(struct mt9v032 *mt9v032, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_format(fh, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &mt9v032->format;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic struct v4l2_rect *\r\n__mt9v032_get_pad_crop(struct mt9v032 *mt9v032, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_crop(fh, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &mt9v032->crop;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int mt9v032_s_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nconst u16 mode = MT9V032_CHIP_CONTROL_MASTER_MODE\r\n| MT9V032_CHIP_CONTROL_DOUT_ENABLE\r\n| MT9V032_CHIP_CONTROL_SEQUENTIAL;\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nstruct v4l2_rect *crop = &mt9v032->crop;\r\nunsigned int hbin;\r\nunsigned int vbin;\r\nint ret;\r\nif (!enable)\r\nreturn mt9v032_set_chip_control(mt9v032, mode, 0);\r\nhbin = fls(mt9v032->hratio) - 1;\r\nvbin = fls(mt9v032->vratio) - 1;\r\nret = mt9v032_write(client, MT9V032_READ_MODE,\r\nhbin << MT9V032_READ_MODE_COLUMN_BIN_SHIFT |\r\nvbin << MT9V032_READ_MODE_ROW_BIN_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9v032_write(client, MT9V032_COLUMN_START, crop->left);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9v032_write(client, MT9V032_ROW_START, crop->top);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9v032_write(client, MT9V032_WINDOW_WIDTH, crop->width);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9v032_write(client, MT9V032_WINDOW_HEIGHT, crop->height);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9v032_update_hblank(mt9v032);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9v032_set_chip_control(mt9v032, 0, mode);\r\n}\r\nstatic int mt9v032_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index > 0)\r\nreturn -EINVAL;\r\ncode->code = V4L2_MBUS_FMT_SGRBG10_1X10;\r\nreturn 0;\r\n}\r\nstatic int mt9v032_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nif (fse->index >= 3 || fse->code != V4L2_MBUS_FMT_SGRBG10_1X10)\r\nreturn -EINVAL;\r\nfse->min_width = MT9V032_WINDOW_WIDTH_DEF / (1 << fse->index);\r\nfse->max_width = fse->min_width;\r\nfse->min_height = MT9V032_WINDOW_HEIGHT_DEF / (1 << fse->index);\r\nfse->max_height = fse->min_height;\r\nreturn 0;\r\n}\r\nstatic int mt9v032_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nformat->format = *__mt9v032_get_pad_format(mt9v032, fh, format->pad,\r\nformat->which);\r\nreturn 0;\r\n}\r\nstatic void mt9v032_configure_pixel_rate(struct mt9v032 *mt9v032)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);\r\nint ret;\r\nret = v4l2_ctrl_s_ctrl_int64(mt9v032->pixel_rate,\r\nmt9v032->sysclk / mt9v032->hratio);\r\nif (ret < 0)\r\ndev_warn(&client->dev, "failed to set pixel rate (%d)\n", ret);\r\n}\r\nstatic unsigned int mt9v032_calc_ratio(unsigned int input, unsigned int output)\r\n{\r\nif (output * 3 > input * 2)\r\nreturn 1;\r\nif (output * 3 > input)\r\nreturn 2;\r\nreturn 4;\r\n}\r\nstatic int mt9v032_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nstruct v4l2_mbus_framefmt *__format;\r\nstruct v4l2_rect *__crop;\r\nunsigned int width;\r\nunsigned int height;\r\nunsigned int hratio;\r\nunsigned int vratio;\r\n__crop = __mt9v032_get_pad_crop(mt9v032, fh, format->pad,\r\nformat->which);\r\nwidth = clamp(ALIGN(format->format.width, 2),\r\nmax_t(unsigned int, __crop->width / 4,\r\nMT9V032_WINDOW_WIDTH_MIN),\r\n__crop->width);\r\nheight = clamp(ALIGN(format->format.height, 2),\r\nmax_t(unsigned int, __crop->height / 4,\r\nMT9V032_WINDOW_HEIGHT_MIN),\r\n__crop->height);\r\nhratio = mt9v032_calc_ratio(__crop->width, width);\r\nvratio = mt9v032_calc_ratio(__crop->height, height);\r\n__format = __mt9v032_get_pad_format(mt9v032, fh, format->pad,\r\nformat->which);\r\n__format->width = __crop->width / hratio;\r\n__format->height = __crop->height / vratio;\r\nif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nmt9v032->hratio = hratio;\r\nmt9v032->vratio = vratio;\r\nmt9v032_configure_pixel_rate(mt9v032);\r\n}\r\nformat->format = *__format;\r\nreturn 0;\r\n}\r\nstatic int mt9v032_get_crop(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\ncrop->rect = *__mt9v032_get_pad_crop(mt9v032, fh, crop->pad,\r\ncrop->which);\r\nreturn 0;\r\n}\r\nstatic int mt9v032_set_crop(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nstruct v4l2_mbus_framefmt *__format;\r\nstruct v4l2_rect *__crop;\r\nstruct v4l2_rect rect;\r\nrect.left = clamp(ALIGN(crop->rect.left + 1, 2) - 1,\r\nMT9V032_COLUMN_START_MIN,\r\nMT9V032_COLUMN_START_MAX);\r\nrect.top = clamp(ALIGN(crop->rect.top + 1, 2) - 1,\r\nMT9V032_ROW_START_MIN,\r\nMT9V032_ROW_START_MAX);\r\nrect.width = clamp_t(unsigned int, ALIGN(crop->rect.width, 2),\r\nMT9V032_WINDOW_WIDTH_MIN,\r\nMT9V032_WINDOW_WIDTH_MAX);\r\nrect.height = clamp_t(unsigned int, ALIGN(crop->rect.height, 2),\r\nMT9V032_WINDOW_HEIGHT_MIN,\r\nMT9V032_WINDOW_HEIGHT_MAX);\r\nrect.width = min_t(unsigned int,\r\nrect.width, MT9V032_PIXEL_ARRAY_WIDTH - rect.left);\r\nrect.height = min_t(unsigned int,\r\nrect.height, MT9V032_PIXEL_ARRAY_HEIGHT - rect.top);\r\n__crop = __mt9v032_get_pad_crop(mt9v032, fh, crop->pad, crop->which);\r\nif (rect.width != __crop->width || rect.height != __crop->height) {\r\n__format = __mt9v032_get_pad_format(mt9v032, fh, crop->pad,\r\ncrop->which);\r\n__format->width = rect.width;\r\n__format->height = rect.height;\r\nif (crop->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nmt9v032->hratio = 1;\r\nmt9v032->vratio = 1;\r\nmt9v032_configure_pixel_rate(mt9v032);\r\n}\r\n}\r\n*__crop = rect;\r\ncrop->rect = rect;\r\nreturn 0;\r\n}\r\nstatic int mt9v032_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9v032 *mt9v032 =\r\ncontainer_of(ctrl->handler, struct mt9v032, ctrls);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);\r\nu32 freq;\r\nu16 data;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\nreturn mt9v032_update_aec_agc(mt9v032, MT9V032_AGC_ENABLE,\r\nctrl->val);\r\ncase V4L2_CID_GAIN:\r\nreturn mt9v032_write(client, MT9V032_ANALOG_GAIN, ctrl->val);\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nreturn mt9v032_update_aec_agc(mt9v032, MT9V032_AEC_ENABLE,\r\n!ctrl->val);\r\ncase V4L2_CID_EXPOSURE:\r\nreturn mt9v032_write(client, MT9V032_TOTAL_SHUTTER_WIDTH,\r\nctrl->val);\r\ncase V4L2_CID_HBLANK:\r\nmt9v032->hblank = ctrl->val;\r\nreturn mt9v032_update_hblank(mt9v032);\r\ncase V4L2_CID_VBLANK:\r\nreturn mt9v032_write(client, MT9V032_VERTICAL_BLANKING,\r\nctrl->val);\r\ncase V4L2_CID_PIXEL_RATE:\r\ncase V4L2_CID_LINK_FREQ:\r\nif (mt9v032->link_freq == NULL)\r\nbreak;\r\nfreq = mt9v032->pdata->link_freqs[mt9v032->link_freq->val];\r\nmt9v032->pixel_rate->val64 = freq;\r\nmt9v032->sysclk = freq;\r\nbreak;\r\ncase V4L2_CID_TEST_PATTERN:\r\nswitch (mt9v032->test_pattern->val) {\r\ncase 0:\r\ndata = 0;\r\nbreak;\r\ncase 1:\r\ndata = MT9V032_TEST_PATTERN_GRAY_VERTICAL\r\n| MT9V032_TEST_PATTERN_ENABLE;\r\nbreak;\r\ncase 2:\r\ndata = MT9V032_TEST_PATTERN_GRAY_HORIZONTAL\r\n| MT9V032_TEST_PATTERN_ENABLE;\r\nbreak;\r\ncase 3:\r\ndata = MT9V032_TEST_PATTERN_GRAY_DIAGONAL\r\n| MT9V032_TEST_PATTERN_ENABLE;\r\nbreak;\r\ndefault:\r\ndata = (mt9v032->test_pattern_color->val <<\r\nMT9V032_TEST_PATTERN_DATA_SHIFT)\r\n| MT9V032_TEST_PATTERN_USE_DATA\r\n| MT9V032_TEST_PATTERN_ENABLE\r\n| MT9V032_TEST_PATTERN_FLIP;\r\nbreak;\r\n}\r\nreturn mt9v032_write(client, MT9V032_TEST_PATTERN, data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt9v032_set_power(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nint ret = 0;\r\nmutex_lock(&mt9v032->power_lock);\r\nif (mt9v032->power_count == !on) {\r\nret = __mt9v032_set_power(mt9v032, !!on);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nmt9v032->power_count += on ? 1 : -1;\r\nWARN_ON(mt9v032->power_count < 0);\r\ndone:\r\nmutex_unlock(&mt9v032->power_lock);\r\nreturn ret;\r\n}\r\nstatic int mt9v032_registered(struct v4l2_subdev *subdev)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nunsigned int i;\r\ns32 version;\r\nint ret;\r\ndev_info(&client->dev, "Probing MT9V032 at address 0x%02x\n",\r\nclient->addr);\r\nret = mt9v032_power_on(mt9v032);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "MT9V032 power up failed\n");\r\nreturn ret;\r\n}\r\nversion = mt9v032_read(client, MT9V032_CHIP_VERSION);\r\nif (version < 0) {\r\ndev_err(&client->dev, "Failed reading chip version\n");\r\nreturn version;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mt9v032_versions); ++i) {\r\nif (mt9v032_versions[i].version == version) {\r\nmt9v032->version = &mt9v032_versions[i];\r\nbreak;\r\n}\r\n}\r\nif (mt9v032->version == NULL) {\r\ndev_err(&client->dev, "Unsupported chip version 0x%04x\n",\r\nversion);\r\nreturn -ENODEV;\r\n}\r\nmt9v032_power_off(mt9v032);\r\ndev_info(&client->dev, "%s detected at address 0x%02x\n",\r\nmt9v032->version->name, client->addr);\r\nmt9v032_configure_pixel_rate(mt9v032);\r\nreturn ret;\r\n}\r\nstatic int mt9v032_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *crop;\r\ncrop = v4l2_subdev_get_try_crop(fh, 0);\r\ncrop->left = MT9V032_COLUMN_START_DEF;\r\ncrop->top = MT9V032_ROW_START_DEF;\r\ncrop->width = MT9V032_WINDOW_WIDTH_DEF;\r\ncrop->height = MT9V032_WINDOW_HEIGHT_DEF;\r\nformat = v4l2_subdev_get_try_format(fh, 0);\r\nif (mt9v032->model->color)\r\nformat->code = V4L2_MBUS_FMT_SGRBG10_1X10;\r\nelse\r\nformat->code = V4L2_MBUS_FMT_Y10_1X10;\r\nformat->width = MT9V032_WINDOW_WIDTH_DEF;\r\nformat->height = MT9V032_WINDOW_HEIGHT_DEF;\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn mt9v032_set_power(subdev, 1);\r\n}\r\nstatic int mt9v032_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn mt9v032_set_power(subdev, 0);\r\n}\r\nstatic int mt9v032_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct mt9v032_platform_data *pdata = client->dev.platform_data;\r\nstruct mt9v032 *mt9v032;\r\nunsigned int i;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_warn(&client->adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");\r\nreturn -EIO;\r\n}\r\nmt9v032 = devm_kzalloc(&client->dev, sizeof(*mt9v032), GFP_KERNEL);\r\nif (!mt9v032)\r\nreturn -ENOMEM;\r\nmt9v032->clk = devm_clk_get(&client->dev, NULL);\r\nif (IS_ERR(mt9v032->clk))\r\nreturn PTR_ERR(mt9v032->clk);\r\nmutex_init(&mt9v032->power_lock);\r\nmt9v032->pdata = pdata;\r\nmt9v032->model = (const void *)did->driver_data;\r\nv4l2_ctrl_handler_init(&mt9v032->ctrls, 10);\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_GAIN, MT9V032_ANALOG_GAIN_MIN,\r\nMT9V032_ANALOG_GAIN_MAX, 1, MT9V032_ANALOG_GAIN_DEF);\r\nv4l2_ctrl_new_std_menu(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_EXPOSURE_AUTO, V4L2_EXPOSURE_MANUAL, 0,\r\nV4L2_EXPOSURE_AUTO);\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_EXPOSURE, mt9v032->model->data->min_shutter,\r\nmt9v032->model->data->max_shutter, 1,\r\nMT9V032_TOTAL_SHUTTER_WIDTH_DEF);\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_HBLANK, mt9v032->model->data->min_hblank,\r\nMT9V032_HORIZONTAL_BLANKING_MAX, 1,\r\nMT9V032_HORIZONTAL_BLANKING_DEF);\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_VBLANK, mt9v032->model->data->min_vblank,\r\nmt9v032->model->data->max_vblank, 1,\r\nMT9V032_VERTICAL_BLANKING_DEF);\r\nmt9v032->test_pattern = v4l2_ctrl_new_std_menu_items(&mt9v032->ctrls,\r\n&mt9v032_ctrl_ops, V4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(mt9v032_test_pattern_menu) - 1, 0, 0,\r\nmt9v032_test_pattern_menu);\r\nmt9v032->test_pattern_color = v4l2_ctrl_new_custom(&mt9v032->ctrls,\r\n&mt9v032_test_pattern_color, NULL);\r\nv4l2_ctrl_cluster(2, &mt9v032->test_pattern);\r\nmt9v032->pixel_rate =\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE, 0, 0, 1, 0);\r\nif (pdata && pdata->link_freqs) {\r\nunsigned int def = 0;\r\nfor (i = 0; pdata->link_freqs[i]; ++i) {\r\nif (pdata->link_freqs[i] == pdata->link_def_freq)\r\ndef = i;\r\n}\r\nmt9v032->link_freq =\r\nv4l2_ctrl_new_int_menu(&mt9v032->ctrls,\r\n&mt9v032_ctrl_ops,\r\nV4L2_CID_LINK_FREQ, i - 1, def,\r\npdata->link_freqs);\r\nv4l2_ctrl_cluster(2, &mt9v032->link_freq);\r\n}\r\nmt9v032->subdev.ctrl_handler = &mt9v032->ctrls;\r\nif (mt9v032->ctrls.error)\r\nprintk(KERN_INFO "%s: control initialization error %d\n",\r\n__func__, mt9v032->ctrls.error);\r\nmt9v032->crop.left = MT9V032_COLUMN_START_DEF;\r\nmt9v032->crop.top = MT9V032_ROW_START_DEF;\r\nmt9v032->crop.width = MT9V032_WINDOW_WIDTH_DEF;\r\nmt9v032->crop.height = MT9V032_WINDOW_HEIGHT_DEF;\r\nif (mt9v032->model->color)\r\nmt9v032->format.code = V4L2_MBUS_FMT_SGRBG10_1X10;\r\nelse\r\nmt9v032->format.code = V4L2_MBUS_FMT_Y10_1X10;\r\nmt9v032->format.width = MT9V032_WINDOW_WIDTH_DEF;\r\nmt9v032->format.height = MT9V032_WINDOW_HEIGHT_DEF;\r\nmt9v032->format.field = V4L2_FIELD_NONE;\r\nmt9v032->format.colorspace = V4L2_COLORSPACE_SRGB;\r\nmt9v032->hratio = 1;\r\nmt9v032->vratio = 1;\r\nmt9v032->aec_agc = MT9V032_AEC_ENABLE | MT9V032_AGC_ENABLE;\r\nmt9v032->hblank = MT9V032_HORIZONTAL_BLANKING_DEF;\r\nmt9v032->sysclk = MT9V032_SYSCLK_FREQ_DEF;\r\nv4l2_i2c_subdev_init(&mt9v032->subdev, client, &mt9v032_subdev_ops);\r\nmt9v032->subdev.internal_ops = &mt9v032_subdev_internal_ops;\r\nmt9v032->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nmt9v032->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&mt9v032->subdev.entity, 1, &mt9v032->pad, 0);\r\nif (ret < 0)\r\nv4l2_ctrl_handler_free(&mt9v032->ctrls);\r\nreturn ret;\r\n}\r\nstatic int mt9v032_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nv4l2_ctrl_handler_free(&mt9v032->ctrls);\r\nv4l2_device_unregister_subdev(subdev);\r\nmedia_entity_cleanup(&subdev->entity);\r\nreturn 0;\r\n}
