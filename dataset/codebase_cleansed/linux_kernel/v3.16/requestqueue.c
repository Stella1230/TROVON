void dlm_add_requestqueue(struct dlm_ls *ls, int nodeid, struct dlm_message *ms)\r\n{\r\nstruct rq_entry *e;\r\nint length = ms->m_header.h_length - sizeof(struct dlm_message);\r\ne = kmalloc(sizeof(struct rq_entry) + length, GFP_NOFS);\r\nif (!e) {\r\nlog_print("dlm_add_requestqueue: out of memory len %d", length);\r\nreturn;\r\n}\r\ne->recover_seq = ls->ls_recover_seq & 0xFFFFFFFF;\r\ne->nodeid = nodeid;\r\nmemcpy(&e->request, ms, ms->m_header.h_length);\r\nmutex_lock(&ls->ls_requestqueue_mutex);\r\nlist_add_tail(&e->list, &ls->ls_requestqueue);\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\n}\r\nint dlm_process_requestqueue(struct dlm_ls *ls)\r\n{\r\nstruct rq_entry *e;\r\nstruct dlm_message *ms;\r\nint error = 0;\r\nmutex_lock(&ls->ls_requestqueue_mutex);\r\nfor (;;) {\r\nif (list_empty(&ls->ls_requestqueue)) {\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\nerror = 0;\r\nbreak;\r\n}\r\ne = list_entry(ls->ls_requestqueue.next, struct rq_entry, list);\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\nms = &e->request;\r\nlog_limit(ls, "dlm_process_requestqueue msg %d from %d "\r\n"lkid %x remid %x result %d seq %u",\r\nms->m_type, ms->m_header.h_nodeid,\r\nms->m_lkid, ms->m_remid, ms->m_result,\r\ne->recover_seq);\r\ndlm_receive_message_saved(ls, &e->request, e->recover_seq);\r\nmutex_lock(&ls->ls_requestqueue_mutex);\r\nlist_del(&e->list);\r\nkfree(e);\r\nif (dlm_locking_stopped(ls)) {\r\nlog_debug(ls, "process_requestqueue abort running");\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\nerror = -EINTR;\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nreturn error;\r\n}\r\nvoid dlm_wait_requestqueue(struct dlm_ls *ls)\r\n{\r\nfor (;;) {\r\nmutex_lock(&ls->ls_requestqueue_mutex);\r\nif (list_empty(&ls->ls_requestqueue))\r\nbreak;\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\nschedule();\r\n}\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\n}\r\nstatic int purge_request(struct dlm_ls *ls, struct dlm_message *ms, int nodeid)\r\n{\r\nuint32_t type = ms->m_type;\r\nif (!ls->ls_count)\r\nreturn 1;\r\nif (dlm_is_removed(ls, nodeid))\r\nreturn 1;\r\nif (type == DLM_MSG_REMOVE ||\r\ntype == DLM_MSG_LOOKUP ||\r\ntype == DLM_MSG_LOOKUP_REPLY)\r\nreturn 1;\r\nif (!dlm_no_directory(ls))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid dlm_purge_requestqueue(struct dlm_ls *ls)\r\n{\r\nstruct dlm_message *ms;\r\nstruct rq_entry *e, *safe;\r\nmutex_lock(&ls->ls_requestqueue_mutex);\r\nlist_for_each_entry_safe(e, safe, &ls->ls_requestqueue, list) {\r\nms = &e->request;\r\nif (purge_request(ls, ms, e->nodeid)) {\r\nlist_del(&e->list);\r\nkfree(e);\r\n}\r\n}\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\n}
