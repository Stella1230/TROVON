static int retrieve_msg_frame(struct mixart_mgr *mgr, u32 *msg_frame)\r\n{\r\nu32 headptr, tailptr;\r\ntailptr = readl_be(MIXART_MEM(mgr, MSG_OUTBOUND_POST_TAIL));\r\nheadptr = readl_be(MIXART_MEM(mgr, MSG_OUTBOUND_POST_HEAD));\r\nif (tailptr == headptr)\r\nreturn 0;\r\nif (tailptr < MSG_OUTBOUND_POST_STACK)\r\nreturn 0;\r\nif (tailptr >= MSG_OUTBOUND_POST_STACK + MSG_BOUND_STACK_SIZE)\r\nreturn 0;\r\n*msg_frame = readl_be(MIXART_MEM(mgr, tailptr));\r\ntailptr += 4;\r\nif( tailptr >= (MSG_OUTBOUND_POST_STACK+MSG_BOUND_STACK_SIZE) )\r\ntailptr = MSG_OUTBOUND_POST_STACK;\r\nwritel_be(tailptr, MIXART_MEM(mgr, MSG_OUTBOUND_POST_TAIL));\r\nreturn 1;\r\n}\r\nstatic int get_msg(struct mixart_mgr *mgr, struct mixart_msg *resp,\r\nu32 msg_frame_address )\r\n{\r\nunsigned long flags;\r\nu32 headptr;\r\nu32 size;\r\nint err;\r\n#ifndef __BIG_ENDIAN\r\nunsigned int i;\r\n#endif\r\nspin_lock_irqsave(&mgr->msg_lock, flags);\r\nerr = 0;\r\nsize = readl_be(MIXART_MEM(mgr, msg_frame_address));\r\nresp->message_id = readl_be(MIXART_MEM(mgr, msg_frame_address + 4));\r\nresp->uid.object_id = readl_be(MIXART_MEM(mgr, msg_frame_address + 8));\r\nresp->uid.desc = readl_be(MIXART_MEM(mgr, msg_frame_address + 12));\r\nif( (size < MSG_DESCRIPTOR_SIZE) || (resp->size < (size - MSG_DESCRIPTOR_SIZE))) {\r\nerr = -EINVAL;\r\ndev_err(&mgr->pci->dev,\r\n"problem with response size = %d\n", size);\r\ngoto _clean_exit;\r\n}\r\nsize -= MSG_DESCRIPTOR_SIZE;\r\nmemcpy_fromio(resp->data, MIXART_MEM(mgr, msg_frame_address + MSG_HEADER_SIZE ), size);\r\nresp->size = size;\r\n#ifndef __BIG_ENDIAN\r\nsize /= 4;\r\nfor(i=0; i < size; i++) {\r\n((u32*)resp->data)[i] = be32_to_cpu(((u32*)resp->data)[i]);\r\n}\r\n#endif\r\nheadptr = readl_be(MIXART_MEM(mgr, MSG_OUTBOUND_FREE_HEAD));\r\nif( (headptr < MSG_OUTBOUND_FREE_STACK) || ( headptr >= (MSG_OUTBOUND_FREE_STACK+MSG_BOUND_STACK_SIZE))) {\r\nerr = -EINVAL;\r\ngoto _clean_exit;\r\n}\r\nwritel_be(msg_frame_address, MIXART_MEM(mgr, headptr));\r\nheadptr += 4;\r\nif( headptr >= (MSG_OUTBOUND_FREE_STACK+MSG_BOUND_STACK_SIZE) )\r\nheadptr = MSG_OUTBOUND_FREE_STACK;\r\nwritel_be(headptr, MIXART_MEM(mgr, MSG_OUTBOUND_FREE_HEAD));\r\n_clean_exit:\r\nspin_unlock_irqrestore(&mgr->msg_lock, flags);\r\nreturn err;\r\n}\r\nstatic int send_msg( struct mixart_mgr *mgr,\r\nstruct mixart_msg *msg,\r\nint max_answersize,\r\nint mark_pending,\r\nu32 *msg_event)\r\n{\r\nu32 headptr, tailptr;\r\nu32 msg_frame_address;\r\nint err, i;\r\nif (snd_BUG_ON(msg->size % 4))\r\nreturn -EINVAL;\r\nerr = 0;\r\ntailptr = readl_be(MIXART_MEM(mgr, MSG_INBOUND_FREE_TAIL));\r\nheadptr = readl_be(MIXART_MEM(mgr, MSG_INBOUND_FREE_HEAD));\r\nif (tailptr == headptr) {\r\ndev_err(&mgr->pci->dev, "error: no message frame available\n");\r\nreturn -EBUSY;\r\n}\r\nif( (tailptr < MSG_INBOUND_FREE_STACK) || (tailptr >= (MSG_INBOUND_FREE_STACK+MSG_BOUND_STACK_SIZE))) {\r\nreturn -EINVAL;\r\n}\r\nmsg_frame_address = readl_be(MIXART_MEM(mgr, tailptr));\r\nwritel(0, MIXART_MEM(mgr, tailptr));\r\ntailptr += 4;\r\nif( tailptr >= (MSG_INBOUND_FREE_STACK+MSG_BOUND_STACK_SIZE) )\r\ntailptr = MSG_INBOUND_FREE_STACK;\r\nwritel_be(tailptr, MIXART_MEM(mgr, MSG_INBOUND_FREE_TAIL));\r\nwritel_be( msg->size + MSG_DESCRIPTOR_SIZE, MIXART_MEM(mgr, msg_frame_address) );\r\nwritel_be( msg->message_id , MIXART_MEM(mgr, msg_frame_address + 4) );\r\nwritel_be( msg->uid.object_id, MIXART_MEM(mgr, msg_frame_address + 8) );\r\nwritel_be( msg->uid.desc, MIXART_MEM(mgr, msg_frame_address + 12) );\r\nwritel_be( MSG_DESCRIPTOR_SIZE, MIXART_MEM(mgr, msg_frame_address + 16) );\r\nwritel_be( MSG_DESCRIPTOR_SIZE, MIXART_MEM(mgr, msg_frame_address + 20) );\r\nwritel_be( msg->size, MIXART_MEM(mgr, msg_frame_address + 24) );\r\nwritel_be( MSG_DESCRIPTOR_SIZE, MIXART_MEM(mgr, msg_frame_address + 28) );\r\nwritel_be( 0, MIXART_MEM(mgr, msg_frame_address + 32) );\r\nwritel_be( MSG_DESCRIPTOR_SIZE + max_answersize, MIXART_MEM(mgr, msg_frame_address + 36) );\r\nfor( i=0; i < msg->size; i+=4 ) {\r\nwritel_be( *(u32*)(msg->data + i), MIXART_MEM(mgr, MSG_HEADER_SIZE + msg_frame_address + i) );\r\n}\r\nif( mark_pending ) {\r\nif( *msg_event ) {\r\nmgr->pending_event = *msg_event;\r\n}\r\nelse {\r\nmgr->pending_event = msg_frame_address;\r\n*msg_event = msg_frame_address;\r\n}\r\n}\r\nmsg_frame_address |= MSG_TYPE_REQUEST;\r\nheadptr = readl_be(MIXART_MEM(mgr, MSG_INBOUND_POST_HEAD));\r\nif( (headptr < MSG_INBOUND_POST_STACK) || (headptr >= (MSG_INBOUND_POST_STACK+MSG_BOUND_STACK_SIZE))) {\r\nreturn -EINVAL;\r\n}\r\nwritel_be(msg_frame_address, MIXART_MEM(mgr, headptr));\r\nheadptr += 4;\r\nif( headptr >= (MSG_INBOUND_POST_STACK+MSG_BOUND_STACK_SIZE) )\r\nheadptr = MSG_INBOUND_POST_STACK;\r\nwritel_be(headptr, MIXART_MEM(mgr, MSG_INBOUND_POST_HEAD));\r\nreturn 0;\r\n}\r\nint snd_mixart_send_msg(struct mixart_mgr *mgr, struct mixart_msg *request, int max_resp_size, void *resp_data)\r\n{\r\nstruct mixart_msg resp;\r\nu32 msg_frame = 0;\r\nint err;\r\nwait_queue_t wait;\r\nlong timeout;\r\nmutex_lock(&mgr->msg_mutex);\r\ninit_waitqueue_entry(&wait, current);\r\nspin_lock_irq(&mgr->msg_lock);\r\nerr = send_msg(mgr, request, max_resp_size, 1, &msg_frame);\r\nif (err) {\r\nspin_unlock_irq(&mgr->msg_lock);\r\nmutex_unlock(&mgr->msg_mutex);\r\nreturn err;\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&mgr->msg_sleep, &wait);\r\nspin_unlock_irq(&mgr->msg_lock);\r\ntimeout = schedule_timeout(MSG_TIMEOUT_JIFFIES);\r\nremove_wait_queue(&mgr->msg_sleep, &wait);\r\nif (! timeout) {\r\nmutex_unlock(&mgr->msg_mutex);\r\ndev_err(&mgr->pci->dev,\r\n"error: no response on msg %x\n", msg_frame);\r\nreturn -EIO;\r\n}\r\nresp.message_id = 0;\r\nresp.uid = (struct mixart_uid){0,0};\r\nresp.data = resp_data;\r\nresp.size = max_resp_size;\r\nerr = get_msg(mgr, &resp, msg_frame);\r\nif( request->message_id != resp.message_id )\r\ndev_err(&mgr->pci->dev, "RESPONSE ERROR!\n");\r\nmutex_unlock(&mgr->msg_mutex);\r\nreturn err;\r\n}\r\nint snd_mixart_send_msg_wait_notif(struct mixart_mgr *mgr,\r\nstruct mixart_msg *request, u32 notif_event)\r\n{\r\nint err;\r\nwait_queue_t wait;\r\nlong timeout;\r\nif (snd_BUG_ON(!notif_event))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON((notif_event & MSG_TYPE_MASK) != MSG_TYPE_NOTIFY))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(notif_event & MSG_CANCEL_NOTIFY_MASK))\r\nreturn -EINVAL;\r\nmutex_lock(&mgr->msg_mutex);\r\ninit_waitqueue_entry(&wait, current);\r\nspin_lock_irq(&mgr->msg_lock);\r\nerr = send_msg(mgr, request, MSG_DEFAULT_SIZE, 1, &notif_event);\r\nif(err) {\r\nspin_unlock_irq(&mgr->msg_lock);\r\nmutex_unlock(&mgr->msg_mutex);\r\nreturn err;\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&mgr->msg_sleep, &wait);\r\nspin_unlock_irq(&mgr->msg_lock);\r\ntimeout = schedule_timeout(MSG_TIMEOUT_JIFFIES);\r\nremove_wait_queue(&mgr->msg_sleep, &wait);\r\nif (! timeout) {\r\nmutex_unlock(&mgr->msg_mutex);\r\ndev_err(&mgr->pci->dev,\r\n"error: notification %x not received\n", notif_event);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&mgr->msg_mutex);\r\nreturn 0;\r\n}\r\nint snd_mixart_send_msg_nonblock(struct mixart_mgr *mgr, struct mixart_msg *request)\r\n{\r\nu32 message_frame;\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&mgr->msg_lock, flags);\r\nerr = send_msg(mgr, request, MSG_DEFAULT_SIZE, 0, &message_frame);\r\nspin_unlock_irqrestore(&mgr->msg_lock, flags);\r\natomic_inc(&mgr->msg_processed);\r\nreturn err;\r\n}\r\nvoid snd_mixart_msg_tasklet(unsigned long arg)\r\n{\r\nstruct mixart_mgr *mgr = ( struct mixart_mgr*)(arg);\r\nstruct mixart_msg resp;\r\nu32 msg, addr, type;\r\nint err;\r\nspin_lock(&mgr->lock);\r\nwhile (mgr->msg_fifo_readptr != mgr->msg_fifo_writeptr) {\r\nmsg = mgr->msg_fifo[mgr->msg_fifo_readptr];\r\nmgr->msg_fifo_readptr++;\r\nmgr->msg_fifo_readptr %= MSG_FIFO_SIZE;\r\naddr = msg & ~MSG_TYPE_MASK;\r\ntype = msg & MSG_TYPE_MASK;\r\nswitch (type) {\r\ncase MSG_TYPE_ANSWER:\r\nresp.message_id = 0;\r\nresp.data = mixart_msg_data;\r\nresp.size = sizeof(mixart_msg_data);\r\nerr = get_msg(mgr, &resp, addr);\r\nif( err < 0 ) {\r\ndev_err(&mgr->pci->dev,\r\n"tasklet: error(%d) reading mf %x\n",\r\nerr, msg);\r\nbreak;\r\n}\r\nswitch(resp.message_id) {\r\ncase MSG_STREAM_START_INPUT_STAGE_PACKET:\r\ncase MSG_STREAM_START_OUTPUT_STAGE_PACKET:\r\ncase MSG_STREAM_STOP_INPUT_STAGE_PACKET:\r\ncase MSG_STREAM_STOP_OUTPUT_STAGE_PACKET:\r\nif(mixart_msg_data[0])\r\ndev_err(&mgr->pci->dev,\r\n"tasklet : error MSG_STREAM_ST***_***PUT_STAGE_PACKET status=%x\n",\r\nmixart_msg_data[0]);\r\nbreak;\r\ndefault:\r\ndev_dbg(&mgr->pci->dev,\r\n"tasklet received mf(%x) : msg_id(%x) uid(%x, %x) size(%zd)\n",\r\nmsg, resp.message_id, resp.uid.object_id, resp.uid.desc, resp.size);\r\nbreak;\r\n}\r\nbreak;\r\ncase MSG_TYPE_NOTIFY:\r\ncase MSG_TYPE_COMMAND:\r\ndefault:\r\ndev_err(&mgr->pci->dev,\r\n"tasklet doesn't know what to do with message %x\n",\r\nmsg);\r\n}\r\natomic_dec(&mgr->msg_processed);\r\n}\r\nspin_unlock(&mgr->lock);\r\n}\r\nirqreturn_t snd_mixart_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mixart_mgr *mgr = dev_id;\r\nint err;\r\nstruct mixart_msg resp;\r\nu32 msg;\r\nu32 it_reg;\r\nspin_lock(&mgr->lock);\r\nit_reg = readl_le(MIXART_REG(mgr, MIXART_PCI_OMISR_OFFSET));\r\nif( !(it_reg & MIXART_OIDI) ) {\r\nspin_unlock(&mgr->lock);\r\nreturn IRQ_NONE;\r\n}\r\nwritel_le(MIXART_HOST_ALL_INTERRUPT_MASKED, MIXART_REG(mgr, MIXART_PCI_OMIMR_OFFSET));\r\nit_reg = readl(MIXART_REG(mgr, MIXART_PCI_ODBR_OFFSET));\r\nwritel(it_reg, MIXART_REG(mgr, MIXART_PCI_ODBR_OFFSET));\r\nwritel_le( MIXART_OIDI, MIXART_REG(mgr, MIXART_PCI_OMISR_OFFSET) );\r\nwhile (retrieve_msg_frame(mgr, &msg)) {\r\nswitch (msg & MSG_TYPE_MASK) {\r\ncase MSG_TYPE_COMMAND:\r\nresp.message_id = 0;\r\nresp.data = mixart_msg_data;\r\nresp.size = sizeof(mixart_msg_data);\r\nerr = get_msg(mgr, &resp, msg & ~MSG_TYPE_MASK);\r\nif( err < 0 ) {\r\ndev_err(&mgr->pci->dev,\r\n"interrupt: error(%d) reading mf %x\n",\r\nerr, msg);\r\nbreak;\r\n}\r\nif(resp.message_id == MSG_SERVICES_TIMER_NOTIFY) {\r\nint i;\r\nstruct mixart_timer_notify *notify;\r\nnotify = (struct mixart_timer_notify *)mixart_msg_data;\r\nfor(i=0; i<notify->stream_count; i++) {\r\nu32 buffer_id = notify->streams[i].buffer_id;\r\nunsigned int chip_number = (buffer_id & MIXART_NOTIFY_CARD_MASK) >> MIXART_NOTIFY_CARD_OFFSET;\r\nunsigned int pcm_number = (buffer_id & MIXART_NOTIFY_PCM_MASK ) >> MIXART_NOTIFY_PCM_OFFSET;\r\nunsigned int sub_number = buffer_id & MIXART_NOTIFY_SUBS_MASK;\r\nunsigned int is_capture = ((buffer_id & MIXART_NOTIFY_CAPT_MASK) != 0);\r\nstruct snd_mixart *chip = mgr->chip[chip_number];\r\nstruct mixart_stream *stream;\r\nif ((chip_number >= mgr->num_cards) || (pcm_number >= MIXART_PCM_TOTAL) || (sub_number >= MIXART_PLAYBACK_STREAMS)) {\r\ndev_err(&mgr->pci->dev,\r\n"error MSG_SERVICES_TIMER_NOTIFY buffer_id (%x) pos(%d)\n",\r\nbuffer_id, notify->streams[i].sample_pos_low_part);\r\nbreak;\r\n}\r\nif (is_capture)\r\nstream = &chip->capture_stream[pcm_number];\r\nelse\r\nstream = &chip->playback_stream[pcm_number][sub_number];\r\nif (stream->substream && (stream->status == MIXART_STREAM_STATUS_RUNNING)) {\r\nstruct snd_pcm_runtime *runtime = stream->substream->runtime;\r\nint elapsed = 0;\r\nu64 sample_count = ((u64)notify->streams[i].sample_pos_high_part) << 32;\r\nsample_count |= notify->streams[i].sample_pos_low_part;\r\nwhile (1) {\r\nu64 new_elapse_pos = stream->abs_period_elapsed + runtime->period_size;\r\nif (new_elapse_pos > sample_count) {\r\nbreak;\r\n}\r\nelse {\r\nelapsed = 1;\r\nstream->buf_periods++;\r\nif (stream->buf_periods >= runtime->periods)\r\nstream->buf_periods = 0;\r\nstream->abs_period_elapsed = new_elapse_pos;\r\n}\r\n}\r\nstream->buf_period_frag = (u32)( sample_count - stream->abs_period_elapsed );\r\nif(elapsed) {\r\nspin_unlock(&mgr->lock);\r\nsnd_pcm_period_elapsed(stream->substream);\r\nspin_lock(&mgr->lock);\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\nif(resp.message_id == MSG_SERVICES_REPORT_TRACES) {\r\nif(resp.size > 1) {\r\n#ifndef __BIG_ENDIAN\r\nint i;\r\nfor(i=0; i<(resp.size/4); i++) {\r\n(mixart_msg_data)[i] = cpu_to_be32((mixart_msg_data)[i]);\r\n}\r\n#endif\r\n((char*)mixart_msg_data)[resp.size - 1] = 0;\r\ndev_dbg(&mgr->pci->dev,\r\n"MIXART TRACE : %s\n",\r\n(char *)mixart_msg_data);\r\n}\r\nbreak;\r\n}\r\ndev_dbg(&mgr->pci->dev, "command %x not handled\n",\r\nresp.message_id);\r\nbreak;\r\ncase MSG_TYPE_NOTIFY:\r\nif(msg & MSG_CANCEL_NOTIFY_MASK) {\r\nmsg &= ~MSG_CANCEL_NOTIFY_MASK;\r\ndev_err(&mgr->pci->dev,\r\n"canceled notification %x !\n", msg);\r\n}\r\ncase MSG_TYPE_ANSWER:\r\nspin_lock(&mgr->msg_lock);\r\nif( (msg & ~MSG_TYPE_MASK) == mgr->pending_event ) {\r\nwake_up(&mgr->msg_sleep);\r\nmgr->pending_event = 0;\r\n}\r\nelse {\r\nmgr->msg_fifo[mgr->msg_fifo_writeptr] = msg;\r\nmgr->msg_fifo_writeptr++;\r\nmgr->msg_fifo_writeptr %= MSG_FIFO_SIZE;\r\ntasklet_schedule(&mgr->msg_taskq);\r\n}\r\nspin_unlock(&mgr->msg_lock);\r\nbreak;\r\ncase MSG_TYPE_REQUEST:\r\ndefault:\r\ndev_dbg(&mgr->pci->dev,\r\n"interrupt received request %x\n", msg);\r\nbreak;\r\n}\r\n}\r\nwritel_le( MIXART_ALLOW_OUTBOUND_DOORBELL, MIXART_REG( mgr, MIXART_PCI_OMIMR_OFFSET));\r\nspin_unlock(&mgr->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid snd_mixart_init_mailbox(struct mixart_mgr *mgr)\r\n{\r\nwritel( 0, MIXART_MEM( mgr, MSG_HOST_RSC_PROTECTION ) );\r\nwritel( 0, MIXART_MEM( mgr, MSG_AGENT_RSC_PROTECTION ) );\r\nif(mgr->irq >= 0) {\r\nwritel_le( MIXART_ALLOW_OUTBOUND_DOORBELL, MIXART_REG( mgr, MIXART_PCI_OMIMR_OFFSET));\r\n}\r\nreturn;\r\n}\r\nvoid snd_mixart_exit_mailbox(struct mixart_mgr *mgr)\r\n{\r\nwritel_le( MIXART_HOST_ALL_INTERRUPT_MASKED, MIXART_REG( mgr, MIXART_PCI_OMIMR_OFFSET));\r\nreturn;\r\n}\r\nvoid snd_mixart_reset_board(struct mixart_mgr *mgr)\r\n{\r\nwritel_be( 1, MIXART_REG(mgr, MIXART_BA1_BRUTAL_RESET_OFFSET) );\r\nreturn;\r\n}
