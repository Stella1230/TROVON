static irqreturn_t ctrl_handle_irq(int irq, void *dev_id)\r\n{\r\nstruct mmphw_ctrl *ctrl = (struct mmphw_ctrl *)dev_id;\r\nu32 isr, imask, tmp;\r\nisr = readl_relaxed(ctrl->reg_base + SPU_IRQ_ISR);\r\nimask = readl_relaxed(ctrl->reg_base + SPU_IRQ_ENA);\r\ndo {\r\ntmp = readl_relaxed(ctrl->reg_base + SPU_IRQ_ISR);\r\nif (tmp & isr)\r\nwritel_relaxed(~isr, ctrl->reg_base + SPU_IRQ_ISR);\r\n} while ((isr = readl_relaxed(ctrl->reg_base + SPU_IRQ_ISR)) & imask);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u32 fmt_to_reg(struct mmp_overlay *overlay, int pix_fmt)\r\n{\r\nu32 rbswap = 0, uvswap = 0, yuvswap = 0,\r\ncsc_en = 0, val = 0,\r\nvid = overlay_is_vid(overlay);\r\nswitch (pix_fmt) {\r\ncase PIXFMT_RGB565:\r\ncase PIXFMT_RGB1555:\r\ncase PIXFMT_RGB888PACK:\r\ncase PIXFMT_RGB888UNPACK:\r\ncase PIXFMT_RGBA888:\r\nrbswap = 1;\r\nbreak;\r\ncase PIXFMT_VYUY:\r\ncase PIXFMT_YVU422P:\r\ncase PIXFMT_YVU420P:\r\nuvswap = 1;\r\nbreak;\r\ncase PIXFMT_YUYV:\r\nyuvswap = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (pix_fmt) {\r\ncase PIXFMT_RGB565:\r\ncase PIXFMT_BGR565:\r\nbreak;\r\ncase PIXFMT_RGB1555:\r\ncase PIXFMT_BGR1555:\r\nval = 0x1;\r\nbreak;\r\ncase PIXFMT_RGB888PACK:\r\ncase PIXFMT_BGR888PACK:\r\nval = 0x2;\r\nbreak;\r\ncase PIXFMT_RGB888UNPACK:\r\ncase PIXFMT_BGR888UNPACK:\r\nval = 0x3;\r\nbreak;\r\ncase PIXFMT_RGBA888:\r\ncase PIXFMT_BGRA888:\r\nval = 0x4;\r\nbreak;\r\ncase PIXFMT_UYVY:\r\ncase PIXFMT_VYUY:\r\ncase PIXFMT_YUYV:\r\nval = 0x5;\r\ncsc_en = 1;\r\nbreak;\r\ncase PIXFMT_YUV422P:\r\ncase PIXFMT_YVU422P:\r\nval = 0x6;\r\ncsc_en = 1;\r\nbreak;\r\ncase PIXFMT_YUV420P:\r\ncase PIXFMT_YVU420P:\r\nval = 0x7;\r\ncsc_en = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn (dma_palette(0) | dma_fmt(vid, val) |\r\ndma_swaprb(vid, rbswap) | dma_swapuv(vid, uvswap) |\r\ndma_swapyuv(vid, yuvswap) | dma_csc(vid, csc_en));\r\n}\r\nstatic void dmafetch_set_fmt(struct mmp_overlay *overlay)\r\n{\r\nu32 tmp;\r\nstruct mmp_path *path = overlay->path;\r\ntmp = readl_relaxed(ctrl_regs(path) + dma_ctrl(0, path->id));\r\ntmp &= ~dma_mask(overlay_is_vid(overlay));\r\ntmp |= fmt_to_reg(overlay, overlay->win.pix_fmt);\r\nwritel_relaxed(tmp, ctrl_regs(path) + dma_ctrl(0, path->id));\r\n}\r\nstatic void overlay_set_win(struct mmp_overlay *overlay, struct mmp_win *win)\r\n{\r\nstruct lcd_regs *regs = path_regs(overlay->path);\r\nmemcpy(&overlay->win, win, sizeof(struct mmp_win));\r\nmutex_lock(&overlay->access_ok);\r\nif (overlay_is_vid(overlay)) {\r\nwritel_relaxed(win->pitch[0], &regs->v_pitch_yc);\r\nwritel_relaxed(win->pitch[2] << 16 |\r\nwin->pitch[1], &regs->v_pitch_uv);\r\nwritel_relaxed((win->ysrc << 16) | win->xsrc, &regs->v_size);\r\nwritel_relaxed((win->ydst << 16) | win->xdst, &regs->v_size_z);\r\nwritel_relaxed(win->ypos << 16 | win->xpos, &regs->v_start);\r\n} else {\r\nwritel_relaxed(win->pitch[0], &regs->g_pitch);\r\nwritel_relaxed((win->ysrc << 16) | win->xsrc, &regs->g_size);\r\nwritel_relaxed((win->ydst << 16) | win->xdst, &regs->g_size_z);\r\nwritel_relaxed(win->ypos << 16 | win->xpos, &regs->g_start);\r\n}\r\ndmafetch_set_fmt(overlay);\r\nmutex_unlock(&overlay->access_ok);\r\n}\r\nstatic void dmafetch_onoff(struct mmp_overlay *overlay, int on)\r\n{\r\nu32 mask = overlay_is_vid(overlay) ? CFG_DMA_ENA_MASK :\r\nCFG_GRA_ENA_MASK;\r\nu32 enable = overlay_is_vid(overlay) ? CFG_DMA_ENA(1) : CFG_GRA_ENA(1);\r\nu32 tmp;\r\nstruct mmp_path *path = overlay->path;\r\nmutex_lock(&overlay->access_ok);\r\ntmp = readl_relaxed(ctrl_regs(path) + dma_ctrl(0, path->id));\r\ntmp &= ~mask;\r\ntmp |= (on ? enable : 0);\r\nwritel(tmp, ctrl_regs(path) + dma_ctrl(0, path->id));\r\nmutex_unlock(&overlay->access_ok);\r\n}\r\nstatic void path_enabledisable(struct mmp_path *path, int on)\r\n{\r\nu32 tmp;\r\nmutex_lock(&path->access_ok);\r\ntmp = readl_relaxed(ctrl_regs(path) + LCD_SCLK(path));\r\nif (on)\r\ntmp &= ~SCLK_DISABLE;\r\nelse\r\ntmp |= SCLK_DISABLE;\r\nwritel_relaxed(tmp, ctrl_regs(path) + LCD_SCLK(path));\r\nmutex_unlock(&path->access_ok);\r\n}\r\nstatic void path_onoff(struct mmp_path *path, int on)\r\n{\r\nif (path->status == on) {\r\ndev_info(path->dev, "path %s is already %s\n",\r\npath->name, stat_name(path->status));\r\nreturn;\r\n}\r\nif (on) {\r\npath_enabledisable(path, 1);\r\nif (path->panel && path->panel->set_onoff)\r\npath->panel->set_onoff(path->panel, 1);\r\n} else {\r\nif (path->panel && path->panel->set_onoff)\r\npath->panel->set_onoff(path->panel, 0);\r\npath_enabledisable(path, 0);\r\n}\r\npath->status = on;\r\n}\r\nstatic void overlay_set_onoff(struct mmp_overlay *overlay, int on)\r\n{\r\nif (overlay->status == on) {\r\ndev_info(overlay_to_ctrl(overlay)->dev, "overlay %s is already %s\n",\r\noverlay->path->name, stat_name(overlay->status));\r\nreturn;\r\n}\r\noverlay->status = on;\r\ndmafetch_onoff(overlay, on);\r\nif (overlay->path->ops.check_status(overlay->path)\r\n!= overlay->path->status)\r\npath_onoff(overlay->path, on);\r\n}\r\nstatic void overlay_set_fetch(struct mmp_overlay *overlay, int fetch_id)\r\n{\r\noverlay->dmafetch_id = fetch_id;\r\n}\r\nstatic int overlay_set_addr(struct mmp_overlay *overlay, struct mmp_addr *addr)\r\n{\r\nstruct lcd_regs *regs = path_regs(overlay->path);\r\nmemcpy(&overlay->addr, addr, sizeof(struct mmp_addr));\r\nif (overlay_is_vid(overlay)) {\r\nwritel_relaxed(addr->phys[0], &regs->v_y0);\r\nwritel_relaxed(addr->phys[1], &regs->v_u0);\r\nwritel_relaxed(addr->phys[2], &regs->v_v0);\r\n} else\r\nwritel_relaxed(addr->phys[0], &regs->g_0);\r\nreturn overlay->addr.phys[0];\r\n}\r\nstatic void path_set_mode(struct mmp_path *path, struct mmp_mode *mode)\r\n{\r\nstruct lcd_regs *regs = path_regs(path);\r\nu32 total_x, total_y, vsync_ctrl, tmp, sclk_src, sclk_div,\r\nlink_config = path_to_path_plat(path)->link_config,\r\ndsi_rbswap = path_to_path_plat(path)->link_config;\r\nmemcpy(&path->mode, mode, sizeof(struct mmp_mode));\r\nmutex_lock(&path->access_ok);\r\ntmp = readl_relaxed(ctrl_regs(path) + intf_ctrl(path->id)) & 0x1;\r\ntmp |= mode->vsync_invert ? 0 : 0x8;\r\ntmp |= mode->hsync_invert ? 0 : 0x4;\r\ntmp |= link_config & CFG_DUMBMODE_MASK;\r\ntmp |= CFG_DUMB_ENA(1);\r\nwritel_relaxed(tmp, ctrl_regs(path) + intf_ctrl(path->id));\r\ntmp = readl_relaxed(ctrl_regs(path) + intf_rbswap_ctrl(path->id)) &\r\n(~(CFG_INTFRBSWAP_MASK));\r\ntmp |= dsi_rbswap & CFG_INTFRBSWAP_MASK;\r\nwritel_relaxed(tmp, ctrl_regs(path) + intf_rbswap_ctrl(path->id));\r\nwritel_relaxed((mode->yres << 16) | mode->xres, &regs->screen_active);\r\nwritel_relaxed((mode->left_margin << 16) | mode->right_margin,\r\n&regs->screen_h_porch);\r\nwritel_relaxed((mode->upper_margin << 16) | mode->lower_margin,\r\n&regs->screen_v_porch);\r\ntotal_x = mode->xres + mode->left_margin + mode->right_margin +\r\nmode->hsync_len;\r\ntotal_y = mode->yres + mode->upper_margin + mode->lower_margin +\r\nmode->vsync_len;\r\nwritel_relaxed((total_y << 16) | total_x, &regs->screen_size);\r\nif (path->output_type == PATH_OUT_DSI)\r\nvsync_ctrl = 0x01330133;\r\nelse\r\nvsync_ctrl = ((mode->xres + mode->right_margin) << 16)\r\n| (mode->xres + mode->right_margin);\r\nwritel_relaxed(vsync_ctrl, &regs->vsync_ctrl);\r\nsclk_src = clk_get_rate(path_to_ctrl(path)->clk);\r\nsclk_div = sclk_src / mode->pixclock_freq;\r\nif (sclk_div * mode->pixclock_freq < sclk_src)\r\nsclk_div++;\r\ndev_info(path->dev, "%s sclk_src %d sclk_div 0x%x pclk %d\n",\r\n__func__, sclk_src, sclk_div, mode->pixclock_freq);\r\ntmp = readl_relaxed(ctrl_regs(path) + LCD_SCLK(path));\r\ntmp &= ~CLK_INT_DIV_MASK;\r\ntmp |= sclk_div;\r\nwritel_relaxed(tmp, ctrl_regs(path) + LCD_SCLK(path));\r\nmutex_unlock(&path->access_ok);\r\n}\r\nstatic void ctrl_set_default(struct mmphw_ctrl *ctrl)\r\n{\r\nu32 tmp, irq_mask;\r\ntmp = readl_relaxed(ctrl->reg_base + LCD_TOP_CTRL);\r\ntmp |= 0xfff0;\r\nwritel_relaxed(tmp, ctrl->reg_base + LCD_TOP_CTRL);\r\nirq_mask = path_imasks(0) | err_imask(0) |\r\npath_imasks(1) | err_imask(1);\r\ntmp = readl_relaxed(ctrl->reg_base + SPU_IRQ_ENA);\r\ntmp &= ~irq_mask;\r\ntmp |= irq_mask;\r\nwritel_relaxed(tmp, ctrl->reg_base + SPU_IRQ_ENA);\r\n}\r\nstatic void path_set_default(struct mmp_path *path)\r\n{\r\nstruct lcd_regs *regs = path_regs(path);\r\nu32 dma_ctrl1, mask, tmp, path_config;\r\npath_config = path_to_path_plat(path)->path_config;\r\nif (PATH_OUT_PARALLEL == path->output_type) {\r\nmask = CFG_IOPADMODE_MASK | CFG_BURST_MASK | CFG_BOUNDARY_MASK;\r\ntmp = readl_relaxed(ctrl_regs(path) + SPU_IOPAD_CONTROL);\r\ntmp &= ~mask;\r\ntmp |= path_config;\r\nwritel_relaxed(tmp, ctrl_regs(path) + SPU_IOPAD_CONTROL);\r\n}\r\ntmp = readl_relaxed(ctrl_regs(path) + LCD_SCLK(path));\r\ntmp &= ~SCLK_SRC_SEL_MASK;\r\ntmp |= path_config;\r\nwritel_relaxed(tmp, ctrl_regs(path) + LCD_SCLK(path));\r\ndma_ctrl1 = 0x2032ff81;\r\ndma_ctrl1 |= CFG_VSYNC_INV_MASK;\r\nwritel_relaxed(dma_ctrl1, ctrl_regs(path) + dma_ctrl(1, path->id));\r\nwritel_relaxed(0x00000000, &regs->blank_color);\r\nwritel_relaxed(0x00000000, &regs->g_1);\r\nwritel_relaxed(0x00000000, &regs->g_start);\r\nmask = CFG_GRA_HSMOOTH_MASK | CFG_DMA_HSMOOTH_MASK | CFG_ARBFAST_ENA(1);\r\ntmp = readl_relaxed(ctrl_regs(path) + dma_ctrl(0, path->id));\r\ntmp |= mask;\r\nif (PATH_TV == path->id)\r\ntmp &= ~CFG_ARBFAST_ENA(1);\r\nwritel_relaxed(tmp, ctrl_regs(path) + dma_ctrl(0, path->id));\r\n}\r\nstatic int path_init(struct mmphw_path_plat *path_plat,\r\nstruct mmp_mach_path_config *config)\r\n{\r\nstruct mmphw_ctrl *ctrl = path_plat->ctrl;\r\nstruct mmp_path_info *path_info;\r\nstruct mmp_path *path = NULL;\r\ndev_info(ctrl->dev, "%s: %s\n", __func__, config->name);\r\npath_info = kzalloc(sizeof(struct mmp_path_info), GFP_KERNEL);\r\nif (!path_info) {\r\ndev_err(ctrl->dev, "%s: unable to alloc path_info for %s\n",\r\n__func__, config->name);\r\nreturn 0;\r\n}\r\npath_info->name = config->name;\r\npath_info->id = path_plat->id;\r\npath_info->dev = ctrl->dev;\r\npath_info->overlay_num = config->overlay_num;\r\npath_info->overlay_ops = &mmphw_overlay_ops;\r\npath_info->set_mode = path_set_mode;\r\npath_info->plat_data = path_plat;\r\npath = mmp_register_path(path_info);\r\nif (!path) {\r\nkfree(path_info);\r\nreturn 0;\r\n}\r\npath_plat->path = path;\r\npath_plat->path_config = config->path_config;\r\npath_plat->link_config = config->link_config;\r\npath_plat->dsi_rbswap = config->dsi_rbswap;\r\npath_set_default(path);\r\nkfree(path_info);\r\nreturn 1;\r\n}\r\nstatic void path_deinit(struct mmphw_path_plat *path_plat)\r\n{\r\nif (!path_plat)\r\nreturn;\r\nif (path_plat->path)\r\nmmp_unregister_path(path_plat->path);\r\n}\r\nstatic int mmphw_probe(struct platform_device *pdev)\r\n{\r\nstruct mmp_mach_plat_info *mi;\r\nstruct resource *res;\r\nint ret, i, size, irq;\r\nstruct mmphw_path_plat *path_plat;\r\nstruct mmphw_ctrl *ctrl = NULL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "%s: no IO memory defined\n", __func__);\r\nret = -ENOENT;\r\ngoto failed;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "%s: no IRQ defined\n", __func__);\r\nret = -ENOENT;\r\ngoto failed;\r\n}\r\nmi = pdev->dev.platform_data;\r\nif (mi == NULL || !mi->path_num || !mi->paths) {\r\ndev_err(&pdev->dev, "%s: no platform data defined\n", __func__);\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nsize = sizeof(struct mmphw_ctrl) + sizeof(struct mmphw_path_plat) *\r\nmi->path_num;\r\nctrl = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\r\nif (!ctrl) {\r\nret = -ENOMEM;\r\ngoto failed;\r\n}\r\nctrl->name = mi->name;\r\nctrl->path_num = mi->path_num;\r\nctrl->dev = &pdev->dev;\r\nctrl->irq = irq;\r\nplatform_set_drvdata(pdev, ctrl);\r\nmutex_init(&ctrl->access_ok);\r\nif (!devm_request_mem_region(ctrl->dev, res->start,\r\nresource_size(res), ctrl->name)) {\r\ndev_err(ctrl->dev,\r\n"can't request region for resource %pR\n", res);\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nctrl->reg_base = devm_ioremap_nocache(ctrl->dev,\r\nres->start, resource_size(res));\r\nif (ctrl->reg_base == NULL) {\r\ndev_err(ctrl->dev, "%s: res %x - %x map failed\n", __func__,\r\nres->start, res->end);\r\nret = -ENOMEM;\r\ngoto failed;\r\n}\r\nret = devm_request_irq(ctrl->dev, ctrl->irq, ctrl_handle_irq,\r\nIRQF_SHARED, "lcd_controller", ctrl);\r\nif (ret < 0) {\r\ndev_err(ctrl->dev, "%s unable to request IRQ %d\n",\r\n__func__, ctrl->irq);\r\nret = -ENXIO;\r\ngoto failed;\r\n}\r\nctrl->clk = devm_clk_get(ctrl->dev, mi->clk_name);\r\nif (IS_ERR(ctrl->clk)) {\r\ndev_err(ctrl->dev, "unable to get clk %s\n", mi->clk_name);\r\nret = -ENOENT;\r\ngoto failed;\r\n}\r\nclk_prepare_enable(ctrl->clk);\r\nctrl_set_default(ctrl);\r\nfor (i = 0; i < ctrl->path_num; i++) {\r\npath_plat = &ctrl->path_plats[i];\r\npath_plat->id = i;\r\npath_plat->ctrl = ctrl;\r\nif (!path_init(path_plat, &mi->paths[i])) {\r\nret = -EINVAL;\r\ngoto failed_path_init;\r\n}\r\n}\r\n#ifdef CONFIG_MMP_DISP_SPI\r\nret = lcd_spi_register(ctrl);\r\nif (ret < 0)\r\ngoto failed_path_init;\r\n#endif\r\ndev_info(ctrl->dev, "device init done\n");\r\nreturn 0;\r\nfailed_path_init:\r\nfor (i = 0; i < ctrl->path_num; i++) {\r\npath_plat = &ctrl->path_plats[i];\r\npath_deinit(path_plat);\r\n}\r\nclk_disable_unprepare(ctrl->clk);\r\nfailed:\r\ndev_err(&pdev->dev, "device init failed\n");\r\nreturn ret;\r\n}\r\nstatic int mmphw_init(void)\r\n{\r\nreturn platform_driver_register(&mmphw_driver);\r\n}
