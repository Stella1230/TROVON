static inline bool is_unavailable(struct ip_vs_dest *dest)\r\n{\r\nreturn atomic_read(&dest->weight) <= 0 ||\r\ndest->flags & IP_VS_DEST_F_OVERLOAD;\r\n}\r\nstatic inline unsigned int\r\nip_vs_sh_hashkey(int af, const union nf_inet_addr *addr,\r\n__be16 port, unsigned int offset)\r\n{\r\n__be32 addr_fold = addr->ip;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\naddr_fold = addr->ip6[0]^addr->ip6[1]^\r\naddr->ip6[2]^addr->ip6[3];\r\n#endif\r\nreturn (offset + (ntohs(port) + ntohl(addr_fold))*2654435761UL) &\r\nIP_VS_SH_TAB_MASK;\r\n}\r\nstatic inline struct ip_vs_dest *\r\nip_vs_sh_get(struct ip_vs_service *svc, struct ip_vs_sh_state *s,\r\nconst union nf_inet_addr *addr, __be16 port)\r\n{\r\nunsigned int hash = ip_vs_sh_hashkey(svc->af, addr, port, 0);\r\nstruct ip_vs_dest *dest = rcu_dereference(s->buckets[hash].dest);\r\nreturn (!dest || is_unavailable(dest)) ? NULL : dest;\r\n}\r\nstatic inline struct ip_vs_dest *\r\nip_vs_sh_get_fallback(struct ip_vs_service *svc, struct ip_vs_sh_state *s,\r\nconst union nf_inet_addr *addr, __be16 port)\r\n{\r\nunsigned int offset, roffset;\r\nunsigned int hash, ihash;\r\nstruct ip_vs_dest *dest;\r\nihash = ip_vs_sh_hashkey(svc->af, addr, port, 0);\r\ndest = rcu_dereference(s->buckets[ihash].dest);\r\nif (!dest)\r\nreturn NULL;\r\nif (!is_unavailable(dest))\r\nreturn dest;\r\nIP_VS_DBG_BUF(6, "SH: selected unavailable server %s:%d, reselecting",\r\nIP_VS_DBG_ADDR(svc->af, &dest->addr), ntohs(dest->port));\r\nfor (offset = 0; offset < IP_VS_SH_TAB_SIZE; offset++) {\r\nroffset = (offset + ihash) % IP_VS_SH_TAB_SIZE;\r\nhash = ip_vs_sh_hashkey(svc->af, addr, port, roffset);\r\ndest = rcu_dereference(s->buckets[hash].dest);\r\nif (!dest)\r\nbreak;\r\nif (!is_unavailable(dest))\r\nreturn dest;\r\nIP_VS_DBG_BUF(6, "SH: selected unavailable "\r\n"server %s:%d (offset %d), reselecting",\r\nIP_VS_DBG_ADDR(svc->af, &dest->addr),\r\nntohs(dest->port), roffset);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nip_vs_sh_reassign(struct ip_vs_sh_state *s, struct ip_vs_service *svc)\r\n{\r\nint i;\r\nstruct ip_vs_sh_bucket *b;\r\nstruct list_head *p;\r\nstruct ip_vs_dest *dest;\r\nint d_count;\r\nbool empty;\r\nb = &s->buckets[0];\r\np = &svc->destinations;\r\nempty = list_empty(p);\r\nd_count = 0;\r\nfor (i=0; i<IP_VS_SH_TAB_SIZE; i++) {\r\ndest = rcu_dereference_protected(b->dest, 1);\r\nif (dest)\r\nip_vs_dest_put(dest);\r\nif (empty)\r\nRCU_INIT_POINTER(b->dest, NULL);\r\nelse {\r\nif (p == &svc->destinations)\r\np = p->next;\r\ndest = list_entry(p, struct ip_vs_dest, n_list);\r\nip_vs_dest_hold(dest);\r\nRCU_INIT_POINTER(b->dest, dest);\r\nIP_VS_DBG_BUF(6, "assigned i: %d dest: %s weight: %d\n",\r\ni, IP_VS_DBG_ADDR(svc->af, &dest->addr),\r\natomic_read(&dest->weight));\r\nif (++d_count >= atomic_read(&dest->weight)) {\r\np = p->next;\r\nd_count = 0;\r\n}\r\n}\r\nb++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ip_vs_sh_flush(struct ip_vs_sh_state *s)\r\n{\r\nint i;\r\nstruct ip_vs_sh_bucket *b;\r\nstruct ip_vs_dest *dest;\r\nb = &s->buckets[0];\r\nfor (i=0; i<IP_VS_SH_TAB_SIZE; i++) {\r\ndest = rcu_dereference_protected(b->dest, 1);\r\nif (dest) {\r\nip_vs_dest_put(dest);\r\nRCU_INIT_POINTER(b->dest, NULL);\r\n}\r\nb++;\r\n}\r\n}\r\nstatic int ip_vs_sh_init_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_sh_state *s;\r\ns = kzalloc(sizeof(struct ip_vs_sh_state), GFP_KERNEL);\r\nif (s == NULL)\r\nreturn -ENOMEM;\r\nsvc->sched_data = s;\r\nIP_VS_DBG(6, "SH hash table (memory=%Zdbytes) allocated for "\r\n"current service\n",\r\nsizeof(struct ip_vs_sh_bucket)*IP_VS_SH_TAB_SIZE);\r\nip_vs_sh_reassign(s, svc);\r\nreturn 0;\r\n}\r\nstatic void ip_vs_sh_done_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_sh_state *s = svc->sched_data;\r\nip_vs_sh_flush(s);\r\nkfree_rcu(s, rcu_head);\r\nIP_VS_DBG(6, "SH hash table (memory=%Zdbytes) released\n",\r\nsizeof(struct ip_vs_sh_bucket)*IP_VS_SH_TAB_SIZE);\r\n}\r\nstatic int ip_vs_sh_dest_changed(struct ip_vs_service *svc,\r\nstruct ip_vs_dest *dest)\r\n{\r\nstruct ip_vs_sh_state *s = svc->sched_data;\r\nip_vs_sh_reassign(s, svc);\r\nreturn 0;\r\n}\r\nstatic inline __be16\r\nip_vs_sh_get_port(const struct sk_buff *skb, struct ip_vs_iphdr *iph)\r\n{\r\n__be16 port;\r\nstruct tcphdr _tcph, *th;\r\nstruct udphdr _udph, *uh;\r\nsctp_sctphdr_t _sctph, *sh;\r\nswitch (iph->protocol) {\r\ncase IPPROTO_TCP:\r\nth = skb_header_pointer(skb, iph->len, sizeof(_tcph), &_tcph);\r\nif (unlikely(th == NULL))\r\nreturn 0;\r\nport = th->source;\r\nbreak;\r\ncase IPPROTO_UDP:\r\nuh = skb_header_pointer(skb, iph->len, sizeof(_udph), &_udph);\r\nif (unlikely(uh == NULL))\r\nreturn 0;\r\nport = uh->source;\r\nbreak;\r\ncase IPPROTO_SCTP:\r\nsh = skb_header_pointer(skb, iph->len, sizeof(_sctph), &_sctph);\r\nif (unlikely(sh == NULL))\r\nreturn 0;\r\nport = sh->source;\r\nbreak;\r\ndefault:\r\nport = 0;\r\n}\r\nreturn port;\r\n}\r\nstatic struct ip_vs_dest *\r\nip_vs_sh_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_dest *dest;\r\nstruct ip_vs_sh_state *s;\r\n__be16 port = 0;\r\nIP_VS_DBG(6, "ip_vs_sh_schedule(): Scheduling...\n");\r\nif (svc->flags & IP_VS_SVC_F_SCHED_SH_PORT)\r\nport = ip_vs_sh_get_port(skb, iph);\r\ns = (struct ip_vs_sh_state *) svc->sched_data;\r\nif (svc->flags & IP_VS_SVC_F_SCHED_SH_FALLBACK)\r\ndest = ip_vs_sh_get_fallback(svc, s, &iph->saddr, port);\r\nelse\r\ndest = ip_vs_sh_get(svc, s, &iph->saddr, port);\r\nif (!dest) {\r\nip_vs_scheduler_err(svc, "no destination available");\r\nreturn NULL;\r\n}\r\nIP_VS_DBG_BUF(6, "SH: source IP address %s --> server %s:%d\n",\r\nIP_VS_DBG_ADDR(svc->af, &iph->saddr),\r\nIP_VS_DBG_ADDR(svc->af, &dest->addr),\r\nntohs(dest->port));\r\nreturn dest;\r\n}\r\nstatic int __init ip_vs_sh_init(void)\r\n{\r\nreturn register_ip_vs_scheduler(&ip_vs_sh_scheduler);\r\n}\r\nstatic void __exit ip_vs_sh_cleanup(void)\r\n{\r\nunregister_ip_vs_scheduler(&ip_vs_sh_scheduler);\r\nsynchronize_rcu();\r\n}
