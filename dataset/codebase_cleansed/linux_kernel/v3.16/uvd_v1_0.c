uint32_t uvd_v1_0_get_rptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nreturn RREG32(UVD_RBC_RB_RPTR);\r\n}\r\nuint32_t uvd_v1_0_get_wptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nreturn RREG32(UVD_RBC_RB_WPTR);\r\n}\r\nvoid uvd_v1_0_set_wptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nWREG32(UVD_RBC_RB_WPTR, ring->wptr);\r\n}\r\nint uvd_v1_0_init(struct radeon_device *rdev)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\r\nuint32_t tmp;\r\nint r;\r\nif (rdev->family < CHIP_RV740)\r\nradeon_set_uvd_clocks(rdev, 10000, 10000);\r\nelse\r\nradeon_set_uvd_clocks(rdev, 53300, 40000);\r\nr = uvd_v1_0_start(rdev);\r\nif (r)\r\ngoto done;\r\nring->ready = true;\r\nr = radeon_ring_test(rdev, R600_RING_TYPE_UVD_INDEX, ring);\r\nif (r) {\r\nring->ready = false;\r\ngoto done;\r\n}\r\nr = radeon_ring_lock(rdev, ring, 10);\r\nif (r) {\r\nDRM_ERROR("radeon: ring failed to lock UVD ring (%d).\n", r);\r\ngoto done;\r\n}\r\ntmp = PACKET0(UVD_SEMA_WAIT_FAULT_TIMEOUT_CNTL, 0);\r\nradeon_ring_write(ring, tmp);\r\nradeon_ring_write(ring, 0xFFFFF);\r\ntmp = PACKET0(UVD_SEMA_WAIT_INCOMPLETE_TIMEOUT_CNTL, 0);\r\nradeon_ring_write(ring, tmp);\r\nradeon_ring_write(ring, 0xFFFFF);\r\ntmp = PACKET0(UVD_SEMA_SIGNAL_INCOMPLETE_TIMEOUT_CNTL, 0);\r\nradeon_ring_write(ring, tmp);\r\nradeon_ring_write(ring, 0xFFFFF);\r\nradeon_ring_write(ring, PACKET0(UVD_SEMA_TIMEOUT_STATUS, 0));\r\nradeon_ring_write(ring, 0x8);\r\nradeon_ring_write(ring, PACKET0(UVD_SEMA_CNTL, 0));\r\nradeon_ring_write(ring, 3);\r\nradeon_ring_unlock_commit(rdev, ring);\r\ndone:\r\nradeon_set_uvd_clocks(rdev, 0, 0);\r\nif (!r)\r\nDRM_INFO("UVD initialized successfully.\n");\r\nreturn r;\r\n}\r\nvoid uvd_v1_0_fini(struct radeon_device *rdev)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\r\nuvd_v1_0_stop(rdev);\r\nring->ready = false;\r\n}\r\nint uvd_v1_0_start(struct radeon_device *rdev)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\r\nuint32_t rb_bufsz;\r\nint i, j, r;\r\nu32 lmi_swap_cntl = 0;\r\nu32 mp_swap_cntl = 0;\r\nWREG32(UVD_CGC_GATE, 0);\r\nWREG32_P(UVD_MASTINT_EN, 0, ~(1 << 1));\r\nWREG32_P(UVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\r\nWREG32_P(UVD_RB_ARB_CTRL, 1 << 3, ~(1 << 3));\r\nmdelay(1);\r\nWREG32(UVD_SOFT_RESET, LMI_SOFT_RESET | VCPU_SOFT_RESET |\r\nLBSI_SOFT_RESET | RBC_SOFT_RESET | CSM_SOFT_RESET |\r\nCXW_SOFT_RESET | TAP_SOFT_RESET | LMI_UMC_SOFT_RESET);\r\nmdelay(5);\r\nWREG32_P(SRBM_SOFT_RESET, 0, ~SOFT_RESET_UVD);\r\nmdelay(5);\r\nWREG32(UVD_LMI_CTRL, 0x40 | (1 << 8) | (1 << 13) |\r\n(1 << 21) | (1 << 9) | (1 << 20));\r\n#ifdef __BIG_ENDIAN\r\nlmi_swap_cntl = 0xa;\r\nmp_swap_cntl = 0;\r\n#endif\r\nWREG32(UVD_LMI_SWAP_CNTL, lmi_swap_cntl);\r\nWREG32(UVD_MP_SWAP_CNTL, mp_swap_cntl);\r\nWREG32(UVD_MPC_SET_MUXA0, 0x40c2040);\r\nWREG32(UVD_MPC_SET_MUXA1, 0x0);\r\nWREG32(UVD_MPC_SET_MUXB0, 0x40c2040);\r\nWREG32(UVD_MPC_SET_MUXB1, 0x0);\r\nWREG32(UVD_MPC_SET_ALU, 0);\r\nWREG32(UVD_MPC_SET_MUX, 0x88);\r\nWREG32(UVD_SOFT_RESET, VCPU_SOFT_RESET);\r\nmdelay(5);\r\nWREG32(UVD_VCPU_CNTL, 1 << 9);\r\nWREG32_P(UVD_LMI_CTRL2, 0, ~(1 << 8));\r\nWREG32(UVD_SOFT_RESET, 0);\r\nmdelay(10);\r\nWREG32_P(UVD_RB_ARB_CTRL, 0, ~(1 << 3));\r\nfor (i = 0; i < 10; ++i) {\r\nuint32_t status;\r\nfor (j = 0; j < 100; ++j) {\r\nstatus = RREG32(UVD_STATUS);\r\nif (status & 2)\r\nbreak;\r\nmdelay(10);\r\n}\r\nr = 0;\r\nif (status & 2)\r\nbreak;\r\nDRM_ERROR("UVD not responding, trying to reset the VCPU!!!\n");\r\nWREG32_P(UVD_SOFT_RESET, VCPU_SOFT_RESET, ~VCPU_SOFT_RESET);\r\nmdelay(10);\r\nWREG32_P(UVD_SOFT_RESET, 0, ~VCPU_SOFT_RESET);\r\nmdelay(10);\r\nr = -1;\r\n}\r\nif (r) {\r\nDRM_ERROR("UVD not responding, giving up!!!\n");\r\nreturn r;\r\n}\r\nWREG32_P(UVD_MASTINT_EN, 3<<1, ~(3 << 1));\r\nWREG32(UVD_RBC_RB_CNTL, 0x11010101);\r\nWREG32(UVD_RBC_RB_WPTR_CNTL, 0);\r\nWREG32(UVD_LMI_EXT40_ADDR, upper_32_bits(ring->gpu_addr) |\r\n(0x7 << 16) | (0x1 << 31));\r\nWREG32(UVD_RBC_RB_RPTR, 0x0);\r\nring->wptr = RREG32(UVD_RBC_RB_RPTR);\r\nWREG32(UVD_RBC_RB_WPTR, ring->wptr);\r\nWREG32(UVD_RBC_RB_BASE, ring->gpu_addr);\r\nrb_bufsz = order_base_2(ring->ring_size);\r\nrb_bufsz = (0x1 << 8) | rb_bufsz;\r\nWREG32_P(UVD_RBC_RB_CNTL, rb_bufsz, ~0x11f1f);\r\nreturn 0;\r\n}\r\nvoid uvd_v1_0_stop(struct radeon_device *rdev)\r\n{\r\nWREG32(UVD_RBC_RB_CNTL, 0x11010101);\r\nWREG32_P(UVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\r\nWREG32_P(UVD_RB_ARB_CTRL, 1 << 3, ~(1 << 3));\r\nmdelay(1);\r\nWREG32(UVD_SOFT_RESET, VCPU_SOFT_RESET);\r\nmdelay(5);\r\nWREG32(UVD_VCPU_CNTL, 0x0);\r\nWREG32_P(UVD_LMI_CTRL2, 0, ~(1 << 8));\r\nWREG32_P(UVD_RB_ARB_CTRL, 0, ~(1 << 3));\r\n}\r\nint uvd_v1_0_ring_test(struct radeon_device *rdev, struct radeon_ring *ring)\r\n{\r\nuint32_t tmp = 0;\r\nunsigned i;\r\nint r;\r\nWREG32(UVD_CONTEXT_ID, 0xCAFEDEAD);\r\nr = radeon_ring_lock(rdev, ring, 3);\r\nif (r) {\r\nDRM_ERROR("radeon: cp failed to lock ring %d (%d).\n",\r\nring->idx, r);\r\nreturn r;\r\n}\r\nradeon_ring_write(ring, PACKET0(UVD_CONTEXT_ID, 0));\r\nradeon_ring_write(ring, 0xDEADBEEF);\r\nradeon_ring_unlock_commit(rdev, ring);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = RREG32(UVD_CONTEXT_ID);\r\nif (tmp == 0xDEADBEEF)\r\nbreak;\r\nDRM_UDELAY(1);\r\n}\r\nif (i < rdev->usec_timeout) {\r\nDRM_INFO("ring test on %d succeeded in %d usecs\n",\r\nring->idx, i);\r\n} else {\r\nDRM_ERROR("radeon: ring %d test failed (0x%08X)\n",\r\nring->idx, tmp);\r\nr = -EINVAL;\r\n}\r\nreturn r;\r\n}\r\nbool uvd_v1_0_semaphore_emit(struct radeon_device *rdev,\r\nstruct radeon_ring *ring,\r\nstruct radeon_semaphore *semaphore,\r\nbool emit_wait)\r\n{\r\nuint64_t addr = semaphore->gpu_addr;\r\nradeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_LOW, 0));\r\nradeon_ring_write(ring, (addr >> 3) & 0x000FFFFF);\r\nradeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_HIGH, 0));\r\nradeon_ring_write(ring, (addr >> 23) & 0x000FFFFF);\r\nradeon_ring_write(ring, PACKET0(UVD_SEMA_CMD, 0));\r\nradeon_ring_write(ring, emit_wait ? 1 : 0);\r\nreturn true;\r\n}\r\nvoid uvd_v1_0_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[ib->ring];\r\nradeon_ring_write(ring, PACKET0(UVD_RBC_IB_BASE, 0));\r\nradeon_ring_write(ring, ib->gpu_addr);\r\nradeon_ring_write(ring, PACKET0(UVD_RBC_IB_SIZE, 0));\r\nradeon_ring_write(ring, ib->length_dw);\r\n}\r\nint uvd_v1_0_ib_test(struct radeon_device *rdev, struct radeon_ring *ring)\r\n{\r\nstruct radeon_fence *fence = NULL;\r\nint r;\r\nif (rdev->family < CHIP_RV740)\r\nr = radeon_set_uvd_clocks(rdev, 10000, 10000);\r\nelse\r\nr = radeon_set_uvd_clocks(rdev, 53300, 40000);\r\nif (r) {\r\nDRM_ERROR("radeon: failed to raise UVD clocks (%d).\n", r);\r\nreturn r;\r\n}\r\nr = radeon_uvd_get_create_msg(rdev, ring->idx, 1, NULL);\r\nif (r) {\r\nDRM_ERROR("radeon: failed to get create msg (%d).\n", r);\r\ngoto error;\r\n}\r\nr = radeon_uvd_get_destroy_msg(rdev, ring->idx, 1, &fence);\r\nif (r) {\r\nDRM_ERROR("radeon: failed to get destroy ib (%d).\n", r);\r\ngoto error;\r\n}\r\nr = radeon_fence_wait(fence, false);\r\nif (r) {\r\nDRM_ERROR("radeon: fence wait failed (%d).\n", r);\r\ngoto error;\r\n}\r\nDRM_INFO("ib test on ring %d succeeded\n", ring->idx);\r\nerror:\r\nradeon_fence_unref(&fence);\r\nradeon_set_uvd_clocks(rdev, 0, 0);\r\nreturn r;\r\n}
