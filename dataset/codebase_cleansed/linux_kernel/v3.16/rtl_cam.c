void CamResetAllEntry(struct net_device *dev)\r\n{\r\nu32 ulcommand = 0;\r\nulcommand |= BIT31|BIT30;\r\nwrite_nic_dword(dev, RWCAM, ulcommand);\r\n}\r\nvoid write_cam(struct net_device *dev, u8 addr, u32 data)\r\n{\r\nwrite_nic_dword(dev, WCAMI, data);\r\nwrite_nic_dword(dev, RWCAM, BIT31|BIT16|(addr&0xff));\r\n}\r\nu32 read_cam(struct net_device *dev, u8 addr)\r\n{\r\nwrite_nic_dword(dev, RWCAM, 0x80000000|(addr&0xff));\r\nreturn read_nic_dword(dev, 0xa8);\r\n}\r\nvoid EnableHWSecurityConfig8192(struct net_device *dev)\r\n{\r\nu8 SECR_value = 0x0;\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nSECR_value = SCR_TxEncEnable | SCR_RxDecEnable;\r\nif (((KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||\r\n(KEY_TYPE_WEP104 == ieee->pairwise_key_type)) &&\r\n(priv->rtllib->auth_mode != 2)) {\r\nSECR_value |= SCR_RxUseDK;\r\nSECR_value |= SCR_TxUseDK;\r\n} else if ((ieee->iw_mode == IW_MODE_ADHOC) &&\r\n(ieee->pairwise_key_type & (KEY_TYPE_CCMP |\r\nKEY_TYPE_TKIP))) {\r\nSECR_value |= SCR_RxUseDK;\r\nSECR_value |= SCR_TxUseDK;\r\n}\r\nieee->hwsec_active = 1;\r\nif ((ieee->pHTInfo->IOTAction&HT_IOT_ACT_PURE_N_MODE) || !hwwep) {\r\nieee->hwsec_active = 0;\r\nSECR_value &= ~SCR_RxDecEnable;\r\n}\r\nRT_TRACE(COMP_SEC, "%s:, hwsec:%d, pairwise_key:%d, SECR_value:%x\n",\r\n__func__, ieee->hwsec_active, ieee->pairwise_key_type,\r\nSECR_value);\r\nwrite_nic_byte(dev, SECR, SECR_value);\r\n}\r\nvoid set_swcam(struct net_device *dev, u8 EntryNo, u8 KeyIndex, u16 KeyType,\r\nu8 *MacAddr, u8 DefaultKey, u32 *KeyContent, u8 is_mesh)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nRT_TRACE(COMP_DBG, "===========>%s():EntryNo is %d,KeyIndex is "\r\n"%d,KeyType is %d,is_mesh is %d\n", __func__, EntryNo,\r\nKeyIndex, KeyType, is_mesh);\r\nif (!is_mesh) {\r\nieee->swcamtable[EntryNo].bused = true;\r\nieee->swcamtable[EntryNo].key_index = KeyIndex;\r\nieee->swcamtable[EntryNo].key_type = KeyType;\r\nmemcpy(ieee->swcamtable[EntryNo].macaddr, MacAddr, 6);\r\nieee->swcamtable[EntryNo].useDK = DefaultKey;\r\nmemcpy(ieee->swcamtable[EntryNo].key_buf, (u8 *)KeyContent, 16);\r\n}\r\n}\r\nvoid setKey(struct net_device *dev, u8 EntryNo, u8 KeyIndex, u16 KeyType,\r\nu8 *MacAddr, u8 DefaultKey, u32 *KeyContent)\r\n{\r\nu32 TargetCommand = 0;\r\nu32 TargetContent = 0;\r\nu16 usConfig = 0;\r\nu8 i;\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nenum rt_rf_power_state rtState;\r\nrtState = priv->rtllib->eRFPowerState;\r\nif (priv->rtllib->PowerSaveControl.bInactivePs) {\r\nif (rtState == eRfOff) {\r\nif (priv->rtllib->RfOffReason > RF_CHANGE_BY_IPS) {\r\nRT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",\r\n__func__);\r\nreturn ;\r\n} else {\r\ndown(&priv->rtllib->ips_sem);\r\nIPSLeave(dev);\r\nup(&priv->rtllib->ips_sem);\r\n}\r\n}\r\n}\r\npriv->rtllib->is_set_key = true;\r\nif (EntryNo >= TOTAL_CAM_ENTRY)\r\nRT_TRACE(COMP_ERR, "cam entry exceeds in setKey()\n");\r\nRT_TRACE(COMP_SEC, "====>to setKey(), dev:%p, EntryNo:%d, KeyIndex:%d,"\r\n"KeyType:%d, MacAddr %pM\n", dev, EntryNo, KeyIndex,\r\nKeyType, MacAddr);\r\nif (DefaultKey)\r\nusConfig |= BIT15 | (KeyType<<2);\r\nelse\r\nusConfig |= BIT15 | (KeyType<<2) | KeyIndex;\r\nfor (i = 0; i < CAM_CONTENT_COUNT; i++) {\r\nTargetCommand = i + CAM_CONTENT_COUNT * EntryNo;\r\nTargetCommand |= BIT31|BIT16;\r\nif (i == 0) {\r\nTargetContent = (u32)(*(MacAddr+0)) << 16 |\r\n(u32)(*(MacAddr+1)) << 24 |\r\n(u32)usConfig;\r\nwrite_nic_dword(dev, WCAMI, TargetContent);\r\nwrite_nic_dword(dev, RWCAM, TargetCommand);\r\n} else if (i == 1) {\r\nTargetContent = (u32)(*(MacAddr+2)) |\r\n(u32)(*(MacAddr+3)) << 8 |\r\n(u32)(*(MacAddr+4)) << 16 |\r\n(u32)(*(MacAddr+5)) << 24;\r\nwrite_nic_dword(dev, WCAMI, TargetContent);\r\nwrite_nic_dword(dev, RWCAM, TargetCommand);\r\n} else {\r\nif (KeyContent != NULL) {\r\nwrite_nic_dword(dev, WCAMI,\r\n(u32)(*(KeyContent+i-2)));\r\nwrite_nic_dword(dev, RWCAM, TargetCommand);\r\nudelay(100);\r\n}\r\n}\r\n}\r\nRT_TRACE(COMP_SEC, "=========>after set key, usconfig:%x\n", usConfig);\r\n}\r\nvoid CAM_read_entry(struct net_device *dev, u32 iIndex)\r\n{\r\nu32 target_command = 0;\r\nu32 target_content = 0;\r\nu8 entry_i = 0;\r\nu32 ulStatus;\r\ns32 i = 100;\r\nfor (entry_i = 0; entry_i < CAM_CONTENT_COUNT; entry_i++) {\r\ntarget_command = entry_i+CAM_CONTENT_COUNT*iIndex;\r\ntarget_command = target_command | BIT31;\r\nwhile ((i--) >= 0) {\r\nulStatus = read_nic_dword(dev, RWCAM);\r\nif (ulStatus & BIT31)\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\nwrite_nic_dword(dev, RWCAM, target_command);\r\nRT_TRACE(COMP_SEC, "CAM_read_entry(): WRITE A0: %x\n",\r\ntarget_command);\r\ntarget_content = read_nic_dword(dev, RCAMO);\r\nRT_TRACE(COMP_SEC, "CAM_read_entry(): WRITE A8: %x\n",\r\ntarget_content);\r\n}\r\nprintk(KERN_INFO "\n");\r\n}\r\nvoid CamRestoreAllEntry(struct net_device *dev)\r\n{\r\nu8 EntryId = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 *MacAddr = priv->rtllib->current_network.bssid;\r\nstatic u8 CAM_CONST_ADDR[4][6] = {\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}\r\n};\r\nstatic u8 CAM_CONST_BROAD[] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\nRT_TRACE(COMP_SEC, "CamRestoreAllEntry:\n");\r\nif ((priv->rtllib->pairwise_key_type == KEY_TYPE_WEP40) ||\r\n(priv->rtllib->pairwise_key_type == KEY_TYPE_WEP104)) {\r\nfor (EntryId = 0; EntryId < 4; EntryId++) {\r\nMacAddr = CAM_CONST_ADDR[EntryId];\r\nif (priv->rtllib->swcamtable[EntryId].bused) {\r\nsetKey(dev, EntryId , EntryId,\r\npriv->rtllib->pairwise_key_type, MacAddr,\r\n0, (u32 *)(&priv->rtllib->swcamtable\r\n[EntryId].key_buf[0]));\r\n}\r\n}\r\n} else if (priv->rtllib->pairwise_key_type == KEY_TYPE_TKIP) {\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\r\nsetKey(dev, 4, 0, priv->rtllib->pairwise_key_type,\r\n(u8 *)dev->dev_addr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable[4].key_buf[0]));\r\n} else {\r\nsetKey(dev, 4, 0, priv->rtllib->pairwise_key_type,\r\nMacAddr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable[4].key_buf[0]));\r\n}\r\n} else if (priv->rtllib->pairwise_key_type == KEY_TYPE_CCMP) {\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\r\nsetKey(dev, 4, 0,\r\npriv->rtllib->pairwise_key_type,\r\n(u8 *)dev->dev_addr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable[4].\r\nkey_buf[0]));\r\n} else {\r\nsetKey(dev, 4, 0,\r\npriv->rtllib->pairwise_key_type, MacAddr,\r\n0, (u32 *)(&priv->rtllib->swcamtable[4].\r\nkey_buf[0]));\r\n}\r\n}\r\nif (priv->rtllib->group_key_type == KEY_TYPE_TKIP) {\r\nMacAddr = CAM_CONST_BROAD;\r\nfor (EntryId = 1; EntryId < 4; EntryId++) {\r\nif (priv->rtllib->swcamtable[EntryId].bused) {\r\nsetKey(dev, EntryId, EntryId,\r\npriv->rtllib->group_key_type,\r\nMacAddr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable[EntryId].key_buf[0])\r\n);\r\n}\r\n}\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\r\nif (priv->rtllib->swcamtable[0].bused) {\r\nsetKey(dev, 0, 0,\r\npriv->rtllib->group_key_type,\r\nCAM_CONST_ADDR[0], 0,\r\n(u32 *)(&priv->rtllib->swcamtable[0].key_buf[0])\r\n);\r\n} else {\r\nRT_TRACE(COMP_ERR, "===>%s():ERR!! ADHOC TKIP "\r\n",but 0 entry is have no data\n",\r\n__func__);\r\nreturn;\r\n}\r\n}\r\n} else if (priv->rtllib->group_key_type == KEY_TYPE_CCMP) {\r\nMacAddr = CAM_CONST_BROAD;\r\nfor (EntryId = 1; EntryId < 4; EntryId++) {\r\nif (priv->rtllib->swcamtable[EntryId].bused) {\r\nsetKey(dev, EntryId , EntryId,\r\npriv->rtllib->group_key_type,\r\nMacAddr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable[EntryId].key_buf[0]));\r\n}\r\n}\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\r\nif (priv->rtllib->swcamtable[0].bused) {\r\nsetKey(dev, 0 , 0,\r\npriv->rtllib->group_key_type,\r\nCAM_CONST_ADDR[0], 0,\r\n(u32 *)(&priv->rtllib->swcamtable[0].key_buf[0]));\r\n} else {\r\nRT_TRACE(COMP_ERR, "===>%s():ERR!! ADHOC CCMP ,"\r\n"but 0 entry is have no data\n",\r\n__func__);\r\nreturn;\r\n}\r\n}\r\n}\r\n}
