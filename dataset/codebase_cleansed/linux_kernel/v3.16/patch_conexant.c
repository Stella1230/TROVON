static inline void set_beep_amp(struct conexant_spec *spec, hda_nid_t nid,\r\nint idx, int dir)\r\n{\r\nspec->gen.beep_nid = nid;\r\nspec->beep_amp = HDA_COMPOSE_AMP_VAL(nid, 1, idx, dir);\r\n}\r\nstatic int add_beep_ctls(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nint err;\r\nif (spec->beep_amp) {\r\nconst struct snd_kcontrol_new *knew;\r\nfor (knew = cxt_beep_mixer; knew->name; knew++) {\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(knew, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->private_value = spec->beep_amp;\r\nerr = snd_hda_ctl_add(codec, 0, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int conexant_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_open(codec, &spec->multiout, substream,\r\nhinfo);\r\n}\r\nstatic int conexant_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_prepare(codec, &spec->multiout,\r\nstream_tag,\r\nformat, substream);\r\n}\r\nstatic int conexant_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_cleanup(codec, &spec->multiout);\r\n}\r\nstatic int conexant_dig_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_open(codec, &spec->multiout);\r\n}\r\nstatic int conexant_dig_playback_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\r\n}\r\nstatic int conexant_dig_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_prepare(codec, &spec->multiout,\r\nstream_tag,\r\nformat, substream);\r\n}\r\nstatic int conexant_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nsnd_hda_codec_setup_stream(codec, spec->adc_nids[substream->number],\r\nstream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int conexant_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nsnd_hda_codec_cleanup_stream(codec, spec->adc_nids[substream->number]);\r\nreturn 0;\r\n}\r\nstatic int cx5051_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nspec->cur_adc = spec->adc_nids[spec->cur_adc_idx];\r\nspec->cur_adc_stream_tag = stream_tag;\r\nspec->cur_adc_format = format;\r\nsnd_hda_codec_setup_stream(codec, spec->cur_adc, stream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int cx5051_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nsnd_hda_codec_cleanup_stream(codec, spec->cur_adc);\r\nspec->cur_adc = 0;\r\nreturn 0;\r\n}\r\nstatic int conexant_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nstruct hda_pcm *info = spec->pcm_rec;\r\ncodec->num_pcms = 1;\r\ncodec->pcm_info = info;\r\ninfo->name = "CONEXANT Analog";\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] = conexant_pcm_analog_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =\r\nspec->multiout.max_channels;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid =\r\nspec->multiout.dac_nids[0];\r\nif (spec->capture_stream)\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] = *spec->capture_stream;\r\nelse {\r\nif (codec->vendor_id == 0x14f15051)\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] =\r\ncx5051_pcm_analog_capture;\r\nelse {\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] =\r\nconexant_pcm_analog_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams =\r\nspec->num_adc_nids;\r\n}\r\n}\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adc_nids[0];\r\nif (spec->multiout.dig_out_nid) {\r\ninfo++;\r\ncodec->num_pcms++;\r\ninfo->name = "Conexant Digital";\r\ninfo->pcm_type = HDA_PCM_TYPE_SPDIF;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] =\r\nconexant_pcm_digital_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid =\r\nspec->multiout.dig_out_nid;\r\nif (spec->dig_in_nid) {\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] =\r\nconexant_pcm_digital_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid =\r\nspec->dig_in_nid;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int conexant_mux_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nreturn snd_hda_input_mux_info(spec->input_mux, uinfo);\r\n}\r\nstatic int conexant_mux_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nucontrol->value.enumerated.item[0] = spec->cur_mux[adc_idx];\r\nreturn 0;\r\n}\r\nstatic int conexant_mux_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nreturn snd_hda_input_mux_put(codec, spec->input_mux, ucontrol,\r\nspec->capsrc_nids[adc_idx],\r\n&spec->cur_mux[adc_idx]);\r\n}\r\nstatic void conexant_set_power(struct hda_codec *codec, hda_nid_t fg,\r\nunsigned int power_state)\r\n{\r\nif (power_state == AC_PWRST_D3)\r\nmsleep(100);\r\nsnd_hda_codec_read(codec, fg, 0, AC_VERB_SET_POWER_STATE,\r\npower_state);\r\nif (power_state == AC_PWRST_D0)\r\nmsleep(10);\r\nsnd_hda_codec_set_power_to_all(codec, fg, power_state);\r\n}\r\nstatic int conexant_init(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < spec->num_init_verbs; i++)\r\nsnd_hda_sequence_write(codec, spec->init_verbs[i]);\r\nreturn 0;\r\n}\r\nstatic void conexant_free(struct hda_codec *codec)\r\n{\r\nkfree(codec->spec);\r\n}\r\nstatic int conexant_build_controls(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int i;\r\nint err;\r\nfor (i = 0; i < spec->num_mixers; i++) {\r\nerr = snd_hda_add_new_ctls(codec, spec->mixers[i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->multiout.dig_out_nid) {\r\nerr = snd_hda_create_spdif_out_ctls(codec,\r\nspec->multiout.dig_out_nid,\r\nspec->multiout.dig_out_nid);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_create_spdif_share_sw(codec,\r\n&spec->multiout);\r\nif (err < 0)\r\nreturn err;\r\nspec->multiout.share_spdif = 1;\r\n}\r\nif (spec->dig_in_nid) {\r\nerr = snd_hda_create_spdif_in_ctls(codec,spec->dig_in_nid);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->vmaster_nid &&\r\n!snd_hda_find_mixer_ctl(codec, "Master Playback Volume")) {\r\nunsigned int vmaster_tlv[4];\r\nsnd_hda_set_vmaster_tlv(codec, spec->vmaster_nid,\r\nHDA_OUTPUT, vmaster_tlv);\r\nerr = snd_hda_add_vmaster(codec, "Master Playback Volume",\r\nvmaster_tlv, slave_pfxs,\r\n"Playback Volume");\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->vmaster_nid &&\r\n!snd_hda_find_mixer_ctl(codec, "Master Playback Switch")) {\r\nerr = snd_hda_add_vmaster(codec, "Master Playback Switch",\r\nNULL, slave_pfxs,\r\n"Playback Switch");\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->input_mux) {\r\nerr = snd_hda_add_new_ctls(codec, cxt_capture_mixers);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = add_beep_ctls(codec);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int cxt_eapd_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nint invert = (kcontrol->private_value >> 8) & 1;\r\nif (invert)\r\nucontrol->value.integer.value[0] = !spec->cur_eapd;\r\nelse\r\nucontrol->value.integer.value[0] = spec->cur_eapd;\r\nreturn 0;\r\n}\r\nstatic int cxt_eapd_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nint invert = (kcontrol->private_value >> 8) & 1;\r\nhda_nid_t nid = kcontrol->private_value & 0xff;\r\nunsigned int eapd;\r\neapd = !!ucontrol->value.integer.value[0];\r\nif (invert)\r\neapd = !eapd;\r\nif (eapd == spec->cur_eapd)\r\nreturn 0;\r\nspec->cur_eapd = eapd;\r\nsnd_hda_codec_write_cache(codec, nid,\r\n0, AC_VERB_SET_EAPD_BTLENABLE,\r\neapd ? 0x02 : 0x00);\r\nreturn 1;\r\n}\r\nstatic int conexant_ch_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nreturn snd_hda_ch_mode_info(codec, uinfo, spec->channel_mode,\r\nspec->num_channel_mode);\r\n}\r\nstatic int conexant_ch_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nreturn snd_hda_ch_mode_get(codec, ucontrol, spec->channel_mode,\r\nspec->num_channel_mode,\r\nspec->multiout.max_channels);\r\n}\r\nstatic int conexant_ch_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nint err = snd_hda_ch_mode_put(codec, ucontrol, spec->channel_mode,\r\nspec->num_channel_mode,\r\n&spec->multiout.max_channels);\r\nreturn err;\r\n}\r\nstatic int cxt5045_hp_master_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int bits;\r\nif (!cxt_eapd_put(kcontrol, ucontrol))\r\nreturn 0;\r\nbits = (!spec->hp_present && spec->cur_eapd) ? 0 : HDA_AMP_MUTE;\r\nsnd_hda_codec_amp_stereo(codec, 0x10, HDA_OUTPUT, 0,\r\nHDA_AMP_MUTE, bits);\r\nbits = spec->cur_eapd ? 0 : HDA_AMP_MUTE;\r\nsnd_hda_codec_amp_stereo(codec, 0x11, HDA_OUTPUT, 0,\r\nHDA_AMP_MUTE, bits);\r\nreturn 1;\r\n}\r\nstatic void cxt5045_hp_automic(struct hda_codec *codec)\r\n{\r\nstatic const struct hda_verb mic_jack_on[] = {\r\n{0x14, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080},\r\n{0x12, AC_VERB_SET_AMP_GAIN_MUTE, 0xb000},\r\n{}\r\n};\r\nstatic const struct hda_verb mic_jack_off[] = {\r\n{0x12, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080},\r\n{0x14, AC_VERB_SET_AMP_GAIN_MUTE, 0xb000},\r\n{}\r\n};\r\nunsigned int present;\r\npresent = snd_hda_jack_detect(codec, 0x12);\r\nif (present)\r\nsnd_hda_sequence_write(codec, mic_jack_on);\r\nelse\r\nsnd_hda_sequence_write(codec, mic_jack_off);\r\n}\r\nstatic void cxt5045_hp_automute(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int bits;\r\nspec->hp_present = snd_hda_jack_detect(codec, 0x11);\r\nbits = (spec->hp_present || !spec->cur_eapd) ? HDA_AMP_MUTE : 0;\r\nsnd_hda_codec_amp_stereo(codec, 0x10, HDA_OUTPUT, 0,\r\nHDA_AMP_MUTE, bits);\r\n}\r\nstatic void cxt5045_hp_unsol_event(struct hda_codec *codec,\r\nunsigned int res)\r\n{\r\nres >>= 26;\r\nswitch (res) {\r\ncase CONEXANT_HP_EVENT:\r\ncxt5045_hp_automute(codec);\r\nbreak;\r\ncase CONEXANT_MIC_EVENT:\r\ncxt5045_hp_automic(codec);\r\nbreak;\r\n}\r\n}\r\nstatic int cxt5045_init(struct hda_codec *codec)\r\n{\r\nconexant_init(codec);\r\ncxt5045_hp_automute(codec);\r\nreturn 0;\r\n}\r\nstatic int patch_cxt5045(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec;\r\nint board_config;\r\nboard_config = snd_hda_check_board_config(codec, CXT5045_MODELS,\r\ncxt5045_models,\r\ncxt5045_cfg_tbl);\r\nif (board_config < 0)\r\nboard_config = CXT5045_AUTO;\r\nif (board_config == CXT5045_AUTO)\r\nreturn patch_conexant_auto(codec);\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\ncodec->single_adc_amp = 1;\r\nspec->multiout.max_channels = 2;\r\nspec->multiout.num_dacs = ARRAY_SIZE(cxt5045_dac_nids);\r\nspec->multiout.dac_nids = cxt5045_dac_nids;\r\nspec->multiout.dig_out_nid = CXT5045_SPDIF_OUT;\r\nspec->num_adc_nids = 1;\r\nspec->adc_nids = cxt5045_adc_nids;\r\nspec->capsrc_nids = cxt5045_capsrc_nids;\r\nspec->input_mux = &cxt5045_capture_source;\r\nspec->num_mixers = 1;\r\nspec->mixers[0] = cxt5045_mixers;\r\nspec->num_init_verbs = 1;\r\nspec->init_verbs[0] = cxt5045_init_verbs;\r\nspec->spdif_route = 0;\r\nspec->num_channel_mode = ARRAY_SIZE(cxt5045_modes);\r\nspec->channel_mode = cxt5045_modes;\r\nset_beep_amp(spec, 0x16, 0, 1);\r\ncodec->patch_ops = conexant_patch_ops;\r\nswitch (board_config) {\r\ncase CXT5045_LAPTOP_HPSENSE:\r\ncodec->patch_ops.unsol_event = cxt5045_hp_unsol_event;\r\nspec->input_mux = &cxt5045_capture_source;\r\nspec->num_init_verbs = 2;\r\nspec->init_verbs[1] = cxt5045_hp_sense_init_verbs;\r\nspec->mixers[0] = cxt5045_mixers;\r\ncodec->patch_ops.init = cxt5045_init;\r\nbreak;\r\ncase CXT5045_LAPTOP_MICSENSE:\r\ncodec->patch_ops.unsol_event = cxt5045_hp_unsol_event;\r\nspec->input_mux = &cxt5045_capture_source;\r\nspec->num_init_verbs = 2;\r\nspec->init_verbs[1] = cxt5045_mic_sense_init_verbs;\r\nspec->mixers[0] = cxt5045_mixers;\r\ncodec->patch_ops.init = cxt5045_init;\r\nbreak;\r\ndefault:\r\ncase CXT5045_LAPTOP_HPMICSENSE:\r\ncodec->patch_ops.unsol_event = cxt5045_hp_unsol_event;\r\nspec->input_mux = &cxt5045_capture_source;\r\nspec->num_init_verbs = 3;\r\nspec->init_verbs[1] = cxt5045_hp_sense_init_verbs;\r\nspec->init_verbs[2] = cxt5045_mic_sense_init_verbs;\r\nspec->mixers[0] = cxt5045_mixers;\r\ncodec->patch_ops.init = cxt5045_init;\r\nbreak;\r\ncase CXT5045_BENQ:\r\ncodec->patch_ops.unsol_event = cxt5045_hp_unsol_event;\r\nspec->input_mux = &cxt5045_capture_source_benq;\r\nspec->num_init_verbs = 1;\r\nspec->init_verbs[0] = cxt5045_benq_init_verbs;\r\nspec->mixers[0] = cxt5045_mixers;\r\nspec->mixers[1] = cxt5045_benq_mixers;\r\nspec->num_mixers = 2;\r\ncodec->patch_ops.init = cxt5045_init;\r\nbreak;\r\n#ifdef CONFIG_SND_DEBUG\r\ncase CXT5045_TEST:\r\nspec->input_mux = &cxt5045_test_capture_source;\r\nspec->mixers[0] = cxt5045_test_mixer;\r\nspec->init_verbs[0] = cxt5045_test_init_verbs;\r\nbreak;\r\n#endif\r\n}\r\nswitch (codec->subsystem_id >> 16) {\r\ncase 0x103c:\r\ncase 0x1631:\r\ncase 0x1734:\r\ncase 0x17aa:\r\nsnd_hda_override_amp_caps(codec, 0x17, HDA_INPUT,\r\n(0x14 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x14 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(1 << AC_AMPCAP_MUTE_SHIFT));\r\nbreak;\r\n}\r\nif (spec->beep_amp)\r\nsnd_hda_attach_beep_device(codec, get_amp_nid_(spec->beep_amp));\r\nreturn 0;\r\n}\r\nstatic int cxt5047_hp_master_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int bits;\r\nif (!cxt_eapd_put(kcontrol, ucontrol))\r\nreturn 0;\r\nbits = (!spec->hp_present && spec->cur_eapd) ? 0 : HDA_AMP_MUTE;\r\nsnd_hda_codec_amp_stereo(codec, 0x1d, HDA_OUTPUT, 0x01,\r\nHDA_AMP_MUTE, bits);\r\nbits = spec->cur_eapd ? 0 : HDA_AMP_MUTE;\r\nsnd_hda_codec_amp_stereo(codec, 0x13, HDA_OUTPUT, 0,\r\nHDA_AMP_MUTE, bits);\r\nreturn 1;\r\n}\r\nstatic void cxt5047_hp_automute(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int bits;\r\nspec->hp_present = snd_hda_jack_detect(codec, 0x13);\r\nbits = (spec->hp_present || !spec->cur_eapd) ? HDA_AMP_MUTE : 0;\r\nsnd_hda_codec_amp_stereo(codec, 0x1d, HDA_OUTPUT, 0x01,\r\nHDA_AMP_MUTE, bits);\r\n}\r\nstatic void cxt5047_hp_automic(struct hda_codec *codec)\r\n{\r\nstatic const struct hda_verb mic_jack_on[] = {\r\n{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},\r\n{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},\r\n{}\r\n};\r\nstatic const struct hda_verb mic_jack_off[] = {\r\n{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},\r\n{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},\r\n{}\r\n};\r\nunsigned int present;\r\npresent = snd_hda_jack_detect(codec, 0x15);\r\nif (present)\r\nsnd_hda_sequence_write(codec, mic_jack_on);\r\nelse\r\nsnd_hda_sequence_write(codec, mic_jack_off);\r\n}\r\nstatic void cxt5047_hp_unsol_event(struct hda_codec *codec,\r\nunsigned int res)\r\n{\r\nswitch (res >> 26) {\r\ncase CONEXANT_HP_EVENT:\r\ncxt5047_hp_automute(codec);\r\nbreak;\r\ncase CONEXANT_MIC_EVENT:\r\ncxt5047_hp_automic(codec);\r\nbreak;\r\n}\r\n}\r\nstatic int cxt5047_hp_init(struct hda_codec *codec)\r\n{\r\nconexant_init(codec);\r\ncxt5047_hp_automute(codec);\r\nreturn 0;\r\n}\r\nstatic int patch_cxt5047(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec;\r\nint board_config;\r\nboard_config = snd_hda_check_board_config(codec, CXT5047_MODELS,\r\ncxt5047_models,\r\ncxt5047_cfg_tbl);\r\nif (board_config < 0)\r\nboard_config = CXT5047_AUTO;\r\nif (board_config == CXT5047_AUTO)\r\nreturn patch_conexant_auto(codec);\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\ncodec->pin_amp_workaround = 1;\r\nspec->multiout.max_channels = 2;\r\nspec->multiout.num_dacs = ARRAY_SIZE(cxt5047_dac_nids);\r\nspec->multiout.dac_nids = cxt5047_dac_nids;\r\nspec->multiout.dig_out_nid = CXT5047_SPDIF_OUT;\r\nspec->num_adc_nids = 1;\r\nspec->adc_nids = cxt5047_adc_nids;\r\nspec->capsrc_nids = cxt5047_capsrc_nids;\r\nspec->num_mixers = 1;\r\nspec->mixers[0] = cxt5047_base_mixers;\r\nspec->num_init_verbs = 1;\r\nspec->init_verbs[0] = cxt5047_init_verbs;\r\nspec->spdif_route = 0;\r\nspec->num_channel_mode = ARRAY_SIZE(cxt5047_modes),\r\nspec->channel_mode = cxt5047_modes,\r\ncodec->patch_ops = conexant_patch_ops;\r\nswitch (board_config) {\r\ncase CXT5047_LAPTOP:\r\nspec->num_mixers = 2;\r\nspec->mixers[1] = cxt5047_hp_spk_mixers;\r\ncodec->patch_ops.unsol_event = cxt5047_hp_unsol_event;\r\nbreak;\r\ncase CXT5047_LAPTOP_HP:\r\nspec->num_mixers = 2;\r\nspec->mixers[1] = cxt5047_hp_only_mixers;\r\ncodec->patch_ops.unsol_event = cxt5047_hp_unsol_event;\r\ncodec->patch_ops.init = cxt5047_hp_init;\r\nbreak;\r\ncase CXT5047_LAPTOP_EAPD:\r\nspec->input_mux = &cxt5047_toshiba_capture_source;\r\nspec->num_mixers = 2;\r\nspec->mixers[1] = cxt5047_hp_spk_mixers;\r\nspec->num_init_verbs = 2;\r\nspec->init_verbs[1] = cxt5047_toshiba_init_verbs;\r\ncodec->patch_ops.unsol_event = cxt5047_hp_unsol_event;\r\nbreak;\r\n#ifdef CONFIG_SND_DEBUG\r\ncase CXT5047_TEST:\r\nspec->input_mux = &cxt5047_test_capture_source;\r\nspec->mixers[0] = cxt5047_test_mixer;\r\nspec->init_verbs[0] = cxt5047_test_init_verbs;\r\ncodec->patch_ops.unsol_event = cxt5047_hp_unsol_event;\r\n#endif\r\n}\r\nspec->vmaster_nid = 0x13;\r\nswitch (codec->subsystem_id >> 16) {\r\ncase 0x103c:\r\nsnd_hda_override_amp_caps(codec, 0x10, HDA_INPUT,\r\n(0x17 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(1 << AC_AMPCAP_MUTE_SHIFT));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cxt5051_update_speaker(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int pinctl;\r\npinctl = (spec->hp_present && spec->cur_eapd) ? PIN_HP : 0;\r\nsnd_hda_set_pin_ctl(codec, 0x16, pinctl);\r\npinctl = (!spec->hp_present && spec->cur_eapd) ? PIN_OUT : 0;\r\nsnd_hda_set_pin_ctl(codec, 0x1a, pinctl);\r\nif (spec->ideapad)\r\nsnd_hda_set_pin_ctl(codec, 0x1b, pinctl);\r\n}\r\nstatic int cxt5051_hp_master_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nif (!cxt_eapd_put(kcontrol, ucontrol))\r\nreturn 0;\r\ncxt5051_update_speaker(codec);\r\nreturn 1;\r\n}\r\nstatic void cxt5051_portb_automic(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int present;\r\nif (!(spec->auto_mic & AUTO_MIC_PORTB))\r\nreturn;\r\npresent = snd_hda_jack_detect(codec, 0x17);\r\nsnd_hda_codec_write(codec, 0x14, 0,\r\nAC_VERB_SET_CONNECT_SEL,\r\npresent ? 0x01 : 0x00);\r\n}\r\nstatic void cxt5051_portc_automic(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int present;\r\nhda_nid_t new_adc;\r\nif (!(spec->auto_mic & AUTO_MIC_PORTC))\r\nreturn;\r\npresent = snd_hda_jack_detect(codec, 0x18);\r\nif (present)\r\nspec->cur_adc_idx = 1;\r\nelse\r\nspec->cur_adc_idx = 0;\r\nnew_adc = spec->adc_nids[spec->cur_adc_idx];\r\nif (spec->cur_adc && spec->cur_adc != new_adc) {\r\n__snd_hda_codec_cleanup_stream(codec, spec->cur_adc, 1);\r\nspec->cur_adc = new_adc;\r\nsnd_hda_codec_setup_stream(codec, new_adc,\r\nspec->cur_adc_stream_tag, 0,\r\nspec->cur_adc_format);\r\n}\r\n}\r\nstatic void cxt5051_hp_automute(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nspec->hp_present = snd_hda_jack_detect(codec, 0x16);\r\ncxt5051_update_speaker(codec);\r\n}\r\nstatic void cxt5051_hp_unsol_event(struct hda_codec *codec,\r\nunsigned int res)\r\n{\r\nswitch (res >> 26) {\r\ncase CONEXANT_HP_EVENT:\r\ncxt5051_hp_automute(codec);\r\nbreak;\r\ncase CXT5051_PORTB_EVENT:\r\ncxt5051_portb_automic(codec);\r\nbreak;\r\ncase CXT5051_PORTC_EVENT:\r\ncxt5051_portc_automic(codec);\r\nbreak;\r\n}\r\n}\r\nstatic void cxt5051_init_mic_port(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int event)\r\n{\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_UNSOLICITED_ENABLE,\r\nAC_USRSP_EN | event);\r\n}\r\nstatic int cxt5051_init(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nconexant_init(codec);\r\nif (spec->auto_mic & AUTO_MIC_PORTB)\r\ncxt5051_init_mic_port(codec, 0x17, CXT5051_PORTB_EVENT);\r\nif (spec->auto_mic & AUTO_MIC_PORTC)\r\ncxt5051_init_mic_port(codec, 0x18, CXT5051_PORTC_EVENT);\r\nif (codec->patch_ops.unsol_event) {\r\ncxt5051_hp_automute(codec);\r\ncxt5051_portb_automic(codec);\r\ncxt5051_portc_automic(codec);\r\n}\r\nreturn 0;\r\n}\r\nstatic int patch_cxt5051(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec;\r\nint board_config;\r\nboard_config = snd_hda_check_board_config(codec, CXT5051_MODELS,\r\ncxt5051_models,\r\ncxt5051_cfg_tbl);\r\nif (board_config < 0)\r\nboard_config = CXT5051_AUTO;\r\nif (board_config == CXT5051_AUTO)\r\nreturn patch_conexant_auto(codec);\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\ncodec->pin_amp_workaround = 1;\r\ncodec->patch_ops = conexant_patch_ops;\r\ncodec->patch_ops.init = cxt5051_init;\r\nspec->multiout.max_channels = 2;\r\nspec->multiout.num_dacs = ARRAY_SIZE(cxt5051_dac_nids);\r\nspec->multiout.dac_nids = cxt5051_dac_nids;\r\nspec->multiout.dig_out_nid = CXT5051_SPDIF_OUT;\r\nspec->num_adc_nids = 1;\r\nspec->adc_nids = cxt5051_adc_nids;\r\nspec->num_mixers = 2;\r\nspec->mixers[0] = cxt5051_capture_mixers;\r\nspec->mixers[1] = cxt5051_playback_mixers;\r\nspec->num_init_verbs = 1;\r\nspec->init_verbs[0] = cxt5051_init_verbs;\r\nspec->spdif_route = 0;\r\nspec->num_channel_mode = ARRAY_SIZE(cxt5051_modes);\r\nspec->channel_mode = cxt5051_modes;\r\nspec->cur_adc = 0;\r\nspec->cur_adc_idx = 0;\r\nset_beep_amp(spec, 0x13, 0, HDA_OUTPUT);\r\ncodec->patch_ops.unsol_event = cxt5051_hp_unsol_event;\r\nspec->auto_mic = AUTO_MIC_PORTB | AUTO_MIC_PORTC;\r\nswitch (board_config) {\r\ncase CXT5051_HP:\r\nspec->mixers[0] = cxt5051_hp_mixers;\r\nbreak;\r\ncase CXT5051_HP_DV6736:\r\nspec->init_verbs[0] = cxt5051_hp_dv6736_init_verbs;\r\nspec->mixers[0] = cxt5051_hp_dv6736_mixers;\r\nspec->auto_mic = 0;\r\nbreak;\r\ncase CXT5051_F700:\r\nspec->init_verbs[0] = cxt5051_f700_init_verbs;\r\nspec->mixers[0] = cxt5051_f700_mixers;\r\nspec->auto_mic = 0;\r\nbreak;\r\ncase CXT5051_TOSHIBA:\r\nspec->mixers[0] = cxt5051_toshiba_mixers;\r\nspec->auto_mic = AUTO_MIC_PORTB;\r\nbreak;\r\ncase CXT5051_IDEAPAD:\r\nspec->init_verbs[spec->num_init_verbs++] =\r\ncxt5051_ideapad_init_verbs;\r\nspec->ideapad = 1;\r\nbreak;\r\n}\r\nif (spec->beep_amp)\r\nsnd_hda_attach_beep_device(codec, get_amp_nid_(spec->beep_amp));\r\nreturn 0;\r\n}\r\nstatic void cxt5066_update_speaker(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int pinctl;\r\ncodec_dbg(codec,\r\n"CXT5066: update speaker, hp_present=%d, cur_eapd=%d\n",\r\nspec->hp_present, spec->cur_eapd);\r\npinctl = (hp_port_a_present(spec) && spec->cur_eapd) ? PIN_HP : 0;\r\nsnd_hda_set_pin_ctl(codec, 0x19, pinctl);\r\npinctl = spec->cur_eapd ? spec->port_d_mode : 0;\r\nif (spec->dell_automute || spec->thinkpad) {\r\nif (hp_port_a_present(spec))\r\npinctl = 0;\r\n} else {\r\nif (!hp_port_d_present(spec))\r\npinctl = 0;\r\n}\r\nsnd_hda_set_pin_ctl(codec, 0x1c, pinctl);\r\npinctl = (!spec->hp_present && spec->cur_eapd) ? PIN_OUT : 0;\r\nsnd_hda_set_pin_ctl(codec, 0x1f, pinctl);\r\n}\r\nstatic int cxt5066_hp_master_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nif (!cxt_eapd_put(kcontrol, ucontrol))\r\nreturn 0;\r\ncxt5066_update_speaker(codec);\r\nreturn 1;\r\n}\r\nstatic void cxt5066_vostro_automic(struct hda_codec *codec)\r\n{\r\nunsigned int present;\r\nstruct hda_verb ext_mic_present[] = {\r\n{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},\r\n{0x17, AC_VERB_SET_CONNECT_SEL, 0},\r\n{0x14, AC_VERB_SET_CONNECT_SEL, 0},\r\n{0x23, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},\r\n{}\r\n};\r\nstatic const struct hda_verb ext_mic_absent[] = {\r\n{0x23, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},\r\n{0x14, AC_VERB_SET_CONNECT_SEL, 2},\r\n{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},\r\n{}\r\n};\r\npresent = snd_hda_jack_detect(codec, 0x1a);\r\nif (present) {\r\ncodec_dbg(codec, "CXT5066: external microphone detected\n");\r\nsnd_hda_sequence_write(codec, ext_mic_present);\r\n} else {\r\ncodec_dbg(codec, "CXT5066: external microphone absent\n");\r\nsnd_hda_sequence_write(codec, ext_mic_absent);\r\n}\r\n}\r\nstatic void cxt5066_ideapad_automic(struct hda_codec *codec)\r\n{\r\nunsigned int present;\r\nstruct hda_verb ext_mic_present[] = {\r\n{0x14, AC_VERB_SET_CONNECT_SEL, 0},\r\n{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},\r\n{0x23, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},\r\n{}\r\n};\r\nstatic const struct hda_verb ext_mic_absent[] = {\r\n{0x14, AC_VERB_SET_CONNECT_SEL, 2},\r\n{0x23, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},\r\n{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},\r\n{}\r\n};\r\npresent = snd_hda_jack_detect(codec, 0x1b);\r\nif (present) {\r\ncodec_dbg(codec, "CXT5066: external microphone detected\n");\r\nsnd_hda_sequence_write(codec, ext_mic_present);\r\n} else {\r\ncodec_dbg(codec, "CXT5066: external microphone absent\n");\r\nsnd_hda_sequence_write(codec, ext_mic_absent);\r\n}\r\n}\r\nstatic void cxt5066_asus_automic(struct hda_codec *codec)\r\n{\r\nunsigned int present;\r\npresent = snd_hda_jack_detect(codec, 0x1b);\r\ncodec_dbg(codec, "CXT5066: external microphone present=%d\n", present);\r\nsnd_hda_codec_write(codec, 0x17, 0, AC_VERB_SET_CONNECT_SEL,\r\npresent ? 1 : 0);\r\n}\r\nstatic void cxt5066_hp_laptop_automic(struct hda_codec *codec)\r\n{\r\nunsigned int present;\r\npresent = snd_hda_jack_detect(codec, 0x1b);\r\ncodec_dbg(codec, "CXT5066: external microphone present=%d\n", present);\r\nsnd_hda_codec_write(codec, 0x17, 0, AC_VERB_SET_CONNECT_SEL,\r\npresent ? 1 : 3);\r\n}\r\nstatic void cxt5066_thinkpad_automic(struct hda_codec *codec)\r\n{\r\nunsigned int ext_present, dock_present;\r\nstatic const struct hda_verb ext_mic_present[] = {\r\n{0x14, AC_VERB_SET_CONNECT_SEL, 0},\r\n{0x17, AC_VERB_SET_CONNECT_SEL, 1},\r\n{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},\r\n{0x23, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},\r\n{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},\r\n{}\r\n};\r\nstatic const struct hda_verb dock_mic_present[] = {\r\n{0x14, AC_VERB_SET_CONNECT_SEL, 0},\r\n{0x17, AC_VERB_SET_CONNECT_SEL, 0},\r\n{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},\r\n{0x23, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},\r\n{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},\r\n{}\r\n};\r\nstatic const struct hda_verb ext_mic_absent[] = {\r\n{0x14, AC_VERB_SET_CONNECT_SEL, 2},\r\n{0x23, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},\r\n{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},\r\n{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},\r\n{}\r\n};\r\next_present = snd_hda_jack_detect(codec, 0x1b);\r\ndock_present = snd_hda_jack_detect(codec, 0x1a);\r\nif (ext_present) {\r\ncodec_dbg(codec, "CXT5066: external microphone detected\n");\r\nsnd_hda_sequence_write(codec, ext_mic_present);\r\n} else if (dock_present) {\r\ncodec_dbg(codec, "CXT5066: dock microphone detected\n");\r\nsnd_hda_sequence_write(codec, dock_mic_present);\r\n} else {\r\ncodec_dbg(codec, "CXT5066: external microphone absent\n");\r\nsnd_hda_sequence_write(codec, ext_mic_absent);\r\n}\r\n}\r\nstatic void cxt5066_hp_automute(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nunsigned int portA, portD;\r\nportA = snd_hda_jack_detect(codec, 0x19);\r\nportD = snd_hda_jack_detect(codec, 0x1c);\r\nspec->hp_present = portA ? HP_PRESENT_PORT_A : 0;\r\nspec->hp_present |= portD ? HP_PRESENT_PORT_D : 0;\r\ncodec_dbg(codec, "CXT5066: hp automute portA=%x portD=%x present=%d\n",\r\nportA, portD, spec->hp_present);\r\ncxt5066_update_speaker(codec);\r\n}\r\nstatic void cxt5066_automic(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nif (spec->dell_vostro)\r\ncxt5066_vostro_automic(codec);\r\nelse if (spec->ideapad)\r\ncxt5066_ideapad_automic(codec);\r\nelse if (spec->thinkpad)\r\ncxt5066_thinkpad_automic(codec);\r\nelse if (spec->hp_laptop)\r\ncxt5066_hp_laptop_automic(codec);\r\nelse if (spec->asus)\r\ncxt5066_asus_automic(codec);\r\n}\r\nstatic void cxt5066_unsol_event(struct hda_codec *codec, unsigned int res)\r\n{\r\ncodec_dbg(codec, "CXT5066: unsol event %x (%x)\n", res, res >> 26);\r\nswitch (res >> 26) {\r\ncase CONEXANT_HP_EVENT:\r\ncxt5066_hp_automute(codec);\r\nbreak;\r\ncase CONEXANT_MIC_EVENT:\r\ncxt5066_automic(codec);\r\nbreak;\r\n}\r\n}\r\nstatic void cxt5066_set_mic_boost(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nsnd_hda_codec_write_cache(codec, 0x17, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE,\r\nAC_AMP_SET_RIGHT | AC_AMP_SET_LEFT | AC_AMP_SET_OUTPUT |\r\ncxt5066_analog_mic_boost.items[spec->mic_boost].index);\r\nif (spec->ideapad || spec->thinkpad) {\r\nsnd_hda_codec_write_cache(codec, 0x23, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE,\r\nAC_AMP_SET_RIGHT | AC_AMP_SET_LEFT | AC_AMP_SET_INPUT |\r\ncxt5066_analog_mic_boost.\r\nitems[spec->mic_boost].index);\r\n}\r\n}\r\nstatic int cxt5066_mic_boost_mux_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nreturn snd_hda_input_mux_info(&cxt5066_analog_mic_boost, uinfo);\r\n}\r\nstatic int cxt5066_mic_boost_mux_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->mic_boost;\r\nreturn 0;\r\n}\r\nstatic int cxt5066_mic_boost_mux_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nconst struct hda_input_mux *imux = &cxt5066_analog_mic_boost;\r\nunsigned int idx;\r\nidx = ucontrol->value.enumerated.item[0];\r\nif (idx >= imux->num_items)\r\nidx = imux->num_items - 1;\r\nspec->mic_boost = idx;\r\ncxt5066_set_mic_boost(codec);\r\nreturn 1;\r\n}\r\nstatic void conexant_check_dig_outs(struct hda_codec *codec,\r\nconst hda_nid_t *dig_pins,\r\nint num_pins)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nhda_nid_t *nid_loc = &spec->multiout.dig_out_nid;\r\nint i;\r\nfor (i = 0; i < num_pins; i++, dig_pins++) {\r\nunsigned int cfg = snd_hda_codec_get_pincfg(codec, *dig_pins);\r\nif (get_defcfg_connect(cfg) == AC_JACK_PORT_NONE)\r\ncontinue;\r\nif (snd_hda_get_connections(codec, *dig_pins, nid_loc, 1) != 1)\r\ncontinue;\r\n}\r\n}\r\nstatic int cxt5066_init(struct hda_codec *codec)\r\n{\r\ncodec_dbg(codec, "CXT5066: init\n");\r\nconexant_init(codec);\r\nif (codec->patch_ops.unsol_event) {\r\ncxt5066_hp_automute(codec);\r\ncxt5066_automic(codec);\r\n}\r\ncxt5066_set_mic_boost(codec);\r\nreturn 0;\r\n}\r\nstatic int patch_cxt5066(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec;\r\nint board_config;\r\nboard_config = snd_hda_check_board_config(codec, CXT5066_MODELS,\r\ncxt5066_models, cxt5066_cfg_tbl);\r\nif (board_config < 0)\r\nboard_config = CXT5066_AUTO;\r\nif (board_config == CXT5066_AUTO)\r\nreturn patch_conexant_auto(codec);\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\ncodec->patch_ops = conexant_patch_ops;\r\ncodec->patch_ops.init = conexant_init;\r\nspec->dell_automute = 0;\r\nspec->multiout.max_channels = 2;\r\nspec->multiout.num_dacs = ARRAY_SIZE(cxt5066_dac_nids);\r\nspec->multiout.dac_nids = cxt5066_dac_nids;\r\nconexant_check_dig_outs(codec, cxt5066_digout_pin_nids,\r\nARRAY_SIZE(cxt5066_digout_pin_nids));\r\nspec->num_adc_nids = 1;\r\nspec->adc_nids = cxt5066_adc_nids;\r\nspec->capsrc_nids = cxt5066_capsrc_nids;\r\nspec->input_mux = &cxt5066_capture_source;\r\nspec->port_d_mode = PIN_HP;\r\nspec->num_init_verbs = 1;\r\nspec->init_verbs[0] = cxt5066_init_verbs;\r\nspec->num_channel_mode = ARRAY_SIZE(cxt5066_modes);\r\nspec->channel_mode = cxt5066_modes;\r\nspec->cur_adc = 0;\r\nspec->cur_adc_idx = 0;\r\nset_beep_amp(spec, 0x13, 0, HDA_OUTPUT);\r\nswitch (board_config) {\r\ndefault:\r\ncase CXT5066_LAPTOP:\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixer_master;\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixers;\r\nbreak;\r\ncase CXT5066_DELL_LAPTOP:\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixer_master;\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixers;\r\nspec->port_d_mode = PIN_OUT;\r\nspec->init_verbs[spec->num_init_verbs] = cxt5066_init_verbs_portd_lo;\r\nspec->num_init_verbs++;\r\nspec->dell_automute = 1;\r\nbreak;\r\ncase CXT5066_ASUS:\r\ncase CXT5066_HP_LAPTOP:\r\ncodec->patch_ops.init = cxt5066_init;\r\ncodec->patch_ops.unsol_event = cxt5066_unsol_event;\r\nspec->init_verbs[spec->num_init_verbs] =\r\ncxt5066_init_verbs_hp_laptop;\r\nspec->num_init_verbs++;\r\nspec->hp_laptop = board_config == CXT5066_HP_LAPTOP;\r\nspec->asus = board_config == CXT5066_ASUS;\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixer_master;\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixers;\r\nif (board_config == CXT5066_HP_LAPTOP)\r\nspec->multiout.dig_out_nid = 0;\r\nspec->input_mux = NULL;\r\nspec->port_d_mode = 0;\r\nspec->mic_boost = 3;\r\nbreak;\r\ncase CXT5066_DELL_VOSTRO:\r\ncodec->patch_ops.init = cxt5066_init;\r\ncodec->patch_ops.unsol_event = cxt5066_unsol_event;\r\nspec->init_verbs[0] = cxt5066_init_verbs_vostro;\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixer_master;\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixers;\r\nspec->mixers[spec->num_mixers++] = cxt5066_vostro_mixers;\r\nspec->port_d_mode = 0;\r\nspec->dell_vostro = 1;\r\nspec->mic_boost = 3;\r\nspec->multiout.dig_out_nid = 0;\r\nspec->input_mux = NULL;\r\nbreak;\r\ncase CXT5066_IDEAPAD:\r\ncodec->patch_ops.init = cxt5066_init;\r\ncodec->patch_ops.unsol_event = cxt5066_unsol_event;\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixer_master;\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixers;\r\nspec->init_verbs[0] = cxt5066_init_verbs_ideapad;\r\nspec->port_d_mode = 0;\r\nspec->ideapad = 1;\r\nspec->mic_boost = 2;\r\nspec->multiout.dig_out_nid = 0;\r\nspec->input_mux = NULL;\r\nbreak;\r\ncase CXT5066_THINKPAD:\r\ncodec->patch_ops.init = cxt5066_init;\r\ncodec->patch_ops.unsol_event = cxt5066_unsol_event;\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixer_master;\r\nspec->mixers[spec->num_mixers++] = cxt5066_mixers;\r\nspec->init_verbs[0] = cxt5066_init_verbs_thinkpad;\r\nspec->thinkpad = 1;\r\nspec->port_d_mode = PIN_OUT;\r\nspec->mic_boost = 2;\r\nspec->multiout.dig_out_nid = 0;\r\nspec->input_mux = NULL;\r\nbreak;\r\n}\r\nif (spec->beep_amp)\r\nsnd_hda_attach_beep_device(codec, get_amp_nid_(spec->beep_amp));\r\nreturn 0;\r\n}\r\nstatic void cx_auto_parse_beep(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nhda_nid_t nid, end_nid;\r\nend_nid = codec->start_nid + codec->num_nodes;\r\nfor (nid = codec->start_nid; nid < end_nid; nid++)\r\nif (get_wcaps_type(get_wcaps(codec, nid)) == AC_WID_BEEP) {\r\nset_beep_amp(spec, nid, 0, HDA_OUTPUT);\r\nbreak;\r\n}\r\n}\r\nstatic void cx_auto_parse_eapd(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nhda_nid_t nid, end_nid;\r\nend_nid = codec->start_nid + codec->num_nodes;\r\nfor (nid = codec->start_nid; nid < end_nid; nid++) {\r\nif (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_PIN)\r\ncontinue;\r\nif (!(snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_EAPD))\r\ncontinue;\r\nspec->eapds[spec->num_eapds++] = nid;\r\nif (spec->num_eapds >= ARRAY_SIZE(spec->eapds))\r\nbreak;\r\n}\r\nif (spec->num_eapds > 2)\r\nspec->dynamic_eapd = 1;\r\n}\r\nstatic void cx_auto_turn_eapd(struct hda_codec *codec, int num_pins,\r\nhda_nid_t *pins, bool on)\r\n{\r\nint i;\r\nfor (i = 0; i < num_pins; i++) {\r\nif (snd_hda_query_pin_caps(codec, pins[i]) & AC_PINCAP_EAPD)\r\nsnd_hda_codec_write(codec, pins[i], 0,\r\nAC_VERB_SET_EAPD_BTLENABLE,\r\non ? 0x02 : 0);\r\n}\r\n}\r\nstatic void cx_auto_vmaster_hook(void *private_data, int enabled)\r\n{\r\nstruct hda_codec *codec = private_data;\r\nstruct conexant_spec *spec = codec->spec;\r\ncx_auto_turn_eapd(codec, spec->num_eapds, spec->eapds, enabled);\r\n}\r\nstatic int cx_auto_build_controls(struct hda_codec *codec)\r\n{\r\nint err;\r\nerr = snd_hda_gen_build_controls(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_beep_ctls(codec);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int cx_auto_init(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nsnd_hda_gen_init(codec);\r\nif (!spec->dynamic_eapd)\r\ncx_auto_turn_eapd(codec, spec->num_eapds, spec->eapds, true);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_INIT);\r\nreturn 0;\r\n}\r\nstatic void cxt_fixup_stereo_dmic(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nspec->gen.inv_dmic_split = 1;\r\n}\r\nstatic void cxt5066_increase_mic_boost(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nsnd_hda_override_amp_caps(codec, 0x17, HDA_OUTPUT,\r\n(0x3 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x4 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x27 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(0 << AC_AMPCAP_MUTE_SHIFT));\r\n}\r\nstatic void cxt_update_headset_mode(struct hda_codec *codec)\r\n{\r\nint i;\r\nbool mic_mode = false;\r\nstruct conexant_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->gen.autocfg;\r\nhda_nid_t mux_pin = spec->gen.imux_pins[spec->gen.cur_mux[0]];\r\nfor (i = 0; i < cfg->num_inputs; i++)\r\nif (cfg->inputs[i].pin == mux_pin) {\r\nmic_mode = !!cfg->inputs[i].is_headphone_mic;\r\nbreak;\r\n}\r\nif (mic_mode) {\r\nsnd_hda_codec_write_cache(codec, 0x1c, 0, 0x410, 0x7c);\r\nspec->gen.hp_jack_present = false;\r\n} else {\r\nsnd_hda_codec_write_cache(codec, 0x1c, 0, 0x410, 0x54);\r\nspec->gen.hp_jack_present = snd_hda_jack_detect(codec, spec->gen.autocfg.hp_pins[0]);\r\n}\r\nsnd_hda_gen_update_outputs(codec);\r\n}\r\nstatic void cxt_update_headset_mode_hook(struct hda_codec *codec,\r\nstruct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\ncxt_update_headset_mode(codec);\r\n}\r\nstatic void cxt_fixup_headphone_mic(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nswitch (action) {\r\ncase HDA_FIXUP_ACT_PRE_PROBE:\r\nspec->parse_flags |= HDA_PINCFG_HEADPHONE_MIC;\r\nbreak;\r\ncase HDA_FIXUP_ACT_PROBE:\r\nspec->gen.cap_sync_hook = cxt_update_headset_mode_hook;\r\nspec->gen.automute_hook = cxt_update_headset_mode;\r\nbreak;\r\ncase HDA_FIXUP_ACT_INIT:\r\ncxt_update_headset_mode(codec);\r\nbreak;\r\n}\r\n}\r\nstatic void olpc_xo_update_mic_boost(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nint ch, val;\r\nfor (ch = 0; ch < 2; ch++) {\r\nval = AC_AMP_SET_OUTPUT |\r\n(ch ? AC_AMP_SET_RIGHT : AC_AMP_SET_LEFT);\r\nif (!spec->dc_enable)\r\nval |= snd_hda_codec_amp_read(codec, 0x17, ch, HDA_OUTPUT, 0);\r\nsnd_hda_codec_write(codec, 0x17, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE, val);\r\n}\r\n}\r\nstatic void olpc_xo_update_mic_pins(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nint cur_input, val;\r\nstruct nid_path *path;\r\ncur_input = spec->gen.input_paths[0][spec->gen.cur_mux[0]];\r\nif (!spec->dc_enable) {\r\nupdate_mic_pin(codec, 0x1e, 0);\r\nsnd_hda_activate_path(codec, spec->dc_mode_path, false, false);\r\nupdate_mic_pin(codec, 0x1a, spec->recording ?\r\nsnd_hda_codec_get_pin_target(codec, 0x1a) : 0);\r\nupdate_mic_pin(codec, 0x1b, spec->recording ?\r\nsnd_hda_codec_get_pin_target(codec, 0x1b) : 0);\r\npath = snd_hda_get_path_from_idx(codec, cur_input);\r\nif (path)\r\nsnd_hda_activate_path(codec, path, true, false);\r\n} else {\r\npath = snd_hda_get_path_from_idx(codec, cur_input);\r\nif (path)\r\nsnd_hda_activate_path(codec, path, false, false);\r\nif (spec->recording)\r\nval = olpc_xo_dc_bias.items[spec->dc_input_bias].index;\r\nelse\r\nval = 0;\r\nupdate_mic_pin(codec, 0x1a, val);\r\nupdate_mic_pin(codec, 0x1b, 0);\r\nupdate_mic_pin(codec, 0x1e, spec->recording ? PIN_IN : 0);\r\nsnd_hda_activate_path(codec, spec->dc_mode_path, true, false);\r\n}\r\n}\r\nstatic void olpc_xo_automic(struct hda_codec *codec, struct hda_jack_tbl *jack)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nint saved_cached_write = codec->cached_write;\r\ncodec->cached_write = 1;\r\nif (!spec->dc_enable)\r\nsnd_hda_gen_mic_autoswitch(codec, jack);\r\nolpc_xo_update_mic_pins(codec);\r\nsnd_hda_codec_flush_cache(codec);\r\ncodec->cached_write = saved_cached_write;\r\nif (spec->dc_enable)\r\nolpc_xo_update_mic_boost(codec);\r\n}\r\nstatic void olpc_xo_capture_hook(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream,\r\nint action)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nswitch (action) {\r\ncase HDA_GEN_PCM_ACT_PREPARE:\r\nspec->recording = 1;\r\nolpc_xo_update_mic_pins(codec);\r\nbreak;\r\ncase HDA_GEN_PCM_ACT_CLEANUP:\r\nspec->recording = 0;\r\nolpc_xo_update_mic_pins(codec);\r\nbreak;\r\n}\r\n}\r\nstatic int olpc_xo_dc_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nucontrol->value.integer.value[0] = spec->dc_enable;\r\nreturn 0;\r\n}\r\nstatic int olpc_xo_dc_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nint dc_enable = !!ucontrol->value.integer.value[0];\r\nif (dc_enable == spec->dc_enable)\r\nreturn 0;\r\nspec->dc_enable = dc_enable;\r\nolpc_xo_update_mic_pins(codec);\r\nolpc_xo_update_mic_boost(codec);\r\nreturn 1;\r\n}\r\nstatic int olpc_xo_dc_bias_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->dc_input_bias;\r\nreturn 0;\r\n}\r\nstatic int olpc_xo_dc_bias_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nreturn snd_hda_input_mux_info(&olpc_xo_dc_bias, uinfo);\r\n}\r\nstatic int olpc_xo_dc_bias_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nconst struct hda_input_mux *imux = &olpc_xo_dc_bias;\r\nunsigned int idx;\r\nidx = ucontrol->value.enumerated.item[0];\r\nif (idx >= imux->num_items)\r\nidx = imux->num_items - 1;\r\nif (spec->dc_input_bias == idx)\r\nreturn 0;\r\nspec->dc_input_bias = idx;\r\nif (spec->dc_enable)\r\nolpc_xo_update_mic_pins(codec);\r\nreturn 1;\r\n}\r\nstatic int olpc_xo_mic_boost_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nint ret = snd_hda_mixer_amp_volume_put(kcontrol, ucontrol);\r\nif (ret > 0 && spec->dc_enable)\r\nolpc_xo_update_mic_boost(codec);\r\nreturn ret;\r\n}\r\nstatic void cxt_fixup_olpc_xo(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nint i;\r\nif (action != HDA_FIXUP_ACT_PROBE)\r\nreturn;\r\nspec->gen.mic_autoswitch_hook = olpc_xo_automic;\r\nspec->gen.pcm_capture_hook = olpc_xo_capture_hook;\r\nspec->dc_mode_path = snd_hda_add_new_path(codec, 0x1e, 0x14, 0);\r\nsnd_hda_add_new_ctls(codec, olpc_xo_mixers);\r\nsnd_hda_codec_set_pin_target(codec, 0x1a, PIN_VREF50);\r\nfor (i = 0; i < spec->gen.kctls.used; i++) {\r\nstruct snd_kcontrol_new *kctl =\r\nsnd_array_elem(&spec->gen.kctls, i);\r\nif (!strcmp(kctl->name, "Mic Boost Volume")) {\r\nkctl->put = olpc_xo_mic_boost_put;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void cxt_fixup_cap_mix_amp(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nsnd_hda_override_amp_caps(codec, 0x17, HDA_INPUT,\r\n(0x14 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x14 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(1 << AC_AMPCAP_MUTE_SHIFT));\r\n}\r\nstatic void cxt_fixup_cap_mix_amp_5047(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nsnd_hda_override_amp_caps(codec, 0x10, HDA_INPUT,\r\n(0x17 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(1 << AC_AMPCAP_MUTE_SHIFT));\r\n}\r\nstatic void add_cx5051_fake_mutes(struct hda_codec *codec)\r\n{\r\nstatic hda_nid_t out_nids[] = {\r\n0x10, 0x11, 0\r\n};\r\nhda_nid_t *p;\r\nfor (p = out_nids; *p; p++)\r\nsnd_hda_override_amp_caps(codec, *p, HDA_OUTPUT,\r\nAC_AMPCAP_MIN_MUTE |\r\nquery_amp_caps(codec, *p, HDA_OUTPUT));\r\n}\r\nstatic int patch_conexant_auto(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec;\r\nint err;\r\ncodec_info(codec, "%s: BIOS auto-probing.\n", codec->chip_name);\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nsnd_hda_gen_spec_init(&spec->gen);\r\ncodec->spec = spec;\r\ncx_auto_parse_beep(codec);\r\ncx_auto_parse_eapd(codec);\r\nspec->gen.own_eapd_ctl = 1;\r\nif (spec->dynamic_eapd)\r\nspec->gen.vmaster_mute.hook = cx_auto_vmaster_hook;\r\nswitch (codec->vendor_id) {\r\ncase 0x14f15045:\r\ncodec->single_adc_amp = 1;\r\nspec->gen.mixer_nid = 0x17;\r\nspec->gen.add_stereo_mix_input = 1;\r\nsnd_hda_pick_fixup(codec, cxt5045_fixup_models,\r\ncxt5045_fixups, cxt_fixups);\r\nbreak;\r\ncase 0x14f15047:\r\ncodec->pin_amp_workaround = 1;\r\nspec->gen.mixer_nid = 0x19;\r\nspec->gen.add_stereo_mix_input = 1;\r\nsnd_hda_pick_fixup(codec, cxt5047_fixup_models,\r\ncxt5047_fixups, cxt_fixups);\r\nbreak;\r\ncase 0x14f15051:\r\nadd_cx5051_fake_mutes(codec);\r\ncodec->pin_amp_workaround = 1;\r\nsnd_hda_pick_fixup(codec, cxt5051_fixup_models,\r\ncxt5051_fixups, cxt_fixups);\r\nbreak;\r\ndefault:\r\ncodec->pin_amp_workaround = 1;\r\nsnd_hda_pick_fixup(codec, cxt5066_fixup_models,\r\ncxt5066_fixups, cxt_fixups);\r\nbreak;\r\n}\r\nswitch (codec->subsystem_id >> 16) {\r\ncase 0x103c:\r\nspec->gen.vmaster_mute_enum = 1;\r\nbreak;\r\n}\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL,\r\nspec->parse_flags);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\r\nif (err < 0)\r\ngoto error;\r\ncodec->patch_ops = cx_auto_patch_ops;\r\nif (!codec->bus->sync_write) {\r\ncodec_info(codec,\r\n"Enable sync_write for stable communication\n");\r\ncodec->bus->sync_write = 1;\r\ncodec->bus->allow_bus_reset = 1;\r\n}\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\nerror:\r\ncx_auto_free(codec);\r\nreturn err;\r\n}\r\nstatic int __init patch_conexant_init(void)\r\n{\r\nreturn snd_hda_add_codec_preset(&conexant_list);\r\n}\r\nstatic void __exit patch_conexant_exit(void)\r\n{\r\nsnd_hda_delete_codec_preset(&conexant_list);\r\n}
