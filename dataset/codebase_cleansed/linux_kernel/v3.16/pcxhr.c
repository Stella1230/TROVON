static int pcxhr_pll_freq_register(unsigned int freq, unsigned int* pllreg,\r\nunsigned int* realfreq)\r\n{\r\nunsigned int reg;\r\nif (freq < 6900 || freq > 110000)\r\nreturn -EINVAL;\r\nreg = (28224000 * 2) / freq;\r\nreg = (reg - 1) / 2;\r\nif (reg < 0x200)\r\n*pllreg = reg + 0x800;\r\nelse if (reg < 0x400)\r\n*pllreg = reg & 0x1ff;\r\nelse if (reg < 0x800) {\r\n*pllreg = ((reg >> 1) & 0x1ff) + 0x200;\r\nreg &= ~1;\r\n} else {\r\n*pllreg = ((reg >> 2) & 0x1ff) + 0x400;\r\nreg &= ~3;\r\n}\r\nif (realfreq)\r\n*realfreq = (28224000 / (reg + 1));\r\nreturn 0;\r\n}\r\nstatic int pcxhr_get_clock_reg(struct pcxhr_mgr *mgr, unsigned int rate,\r\nunsigned int *reg, unsigned int *freq)\r\n{\r\nunsigned int val, realfreq, pllreg;\r\nstruct pcxhr_rmh rmh;\r\nint err;\r\nrealfreq = rate;\r\nswitch (mgr->use_clock_type) {\r\ncase PCXHR_CLOCK_TYPE_INTERNAL :\r\nswitch (rate) {\r\ncase 48000 : val = PCXHR_FREQ_QUARTZ_48000; break;\r\ncase 24000 : val = PCXHR_FREQ_QUARTZ_24000; break;\r\ncase 12000 : val = PCXHR_FREQ_QUARTZ_12000; break;\r\ncase 32000 : val = PCXHR_FREQ_QUARTZ_32000; break;\r\ncase 16000 : val = PCXHR_FREQ_QUARTZ_16000; break;\r\ncase 8000 : val = PCXHR_FREQ_QUARTZ_8000; break;\r\ncase 44100 : val = PCXHR_FREQ_QUARTZ_44100; break;\r\ncase 22050 : val = PCXHR_FREQ_QUARTZ_22050; break;\r\ncase 11025 : val = PCXHR_FREQ_QUARTZ_11025; break;\r\ncase 192000 : val = PCXHR_FREQ_QUARTZ_192000; break;\r\ncase 96000 : val = PCXHR_FREQ_QUARTZ_96000; break;\r\ncase 176400 : val = PCXHR_FREQ_QUARTZ_176400; break;\r\ncase 88200 : val = PCXHR_FREQ_QUARTZ_88200; break;\r\ncase 128000 : val = PCXHR_FREQ_QUARTZ_128000; break;\r\ncase 64000 : val = PCXHR_FREQ_QUARTZ_64000; break;\r\ndefault :\r\nval = PCXHR_FREQ_PLL;\r\nerr = pcxhr_pll_freq_register(rate, &pllreg, &realfreq);\r\nif (err)\r\nreturn err;\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\r\nrmh.cmd[0] |= IO_NUM_REG_GENCLK;\r\nrmh.cmd[1] = pllreg & MASK_DSP_WORD;\r\nrmh.cmd[2] = pllreg >> 24;\r\nrmh.cmd_len = 3;\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err < 0) {\r\ndev_err(&mgr->pci->dev,\r\n"error CMD_ACCESS_IO_WRITE "\r\n"for PLL register : %x!\n", err);\r\nreturn err;\r\n}\r\n}\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_WORD_CLOCK:\r\nval = PCXHR_FREQ_WORD_CLOCK;\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_AES_SYNC:\r\nval = PCXHR_FREQ_SYNC_AES;\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_AES_1:\r\nval = PCXHR_FREQ_AES_1;\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_AES_2:\r\nval = PCXHR_FREQ_AES_2;\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_AES_3:\r\nval = PCXHR_FREQ_AES_3;\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_AES_4:\r\nval = PCXHR_FREQ_AES_4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*reg = val;\r\n*freq = realfreq;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_sub_set_clock(struct pcxhr_mgr *mgr,\r\nunsigned int rate,\r\nint *changed)\r\n{\r\nunsigned int val, realfreq, speed;\r\nstruct pcxhr_rmh rmh;\r\nint err;\r\nerr = pcxhr_get_clock_reg(mgr, rate, &val, &realfreq);\r\nif (err)\r\nreturn err;\r\nif (rate < 55000)\r\nspeed = 0;\r\nelse if (rate < 100000)\r\nspeed = 1;\r\nelse\r\nspeed = 2;\r\nif (mgr->codec_speed != speed) {\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\r\nrmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;\r\nif (DSP_EXT_CMD_SET(mgr)) {\r\nrmh.cmd[1] = 1;\r\nrmh.cmd_len = 2;\r\n}\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err)\r\nreturn err;\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\r\nrmh.cmd[0] |= IO_NUM_SPEED_RATIO;\r\nrmh.cmd[1] = speed;\r\nrmh.cmd_len = 2;\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err)\r\nreturn err;\r\n}\r\ndev_dbg(&mgr->pci->dev, "clock register : set %x\n", val);\r\nerr = pcxhr_write_io_num_reg_cont(mgr, PCXHR_FREQ_REG_MASK,\r\nval, changed);\r\nif (err)\r\nreturn err;\r\nmgr->sample_rate_real = realfreq;\r\nmgr->cur_clock_type = mgr->use_clock_type;\r\nif (mgr->codec_speed != speed) {\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);\r\nrmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;\r\nif (DSP_EXT_CMD_SET(mgr)) {\r\nrmh.cmd[1] = 1;\r\nrmh.cmd_len = 2;\r\n}\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err)\r\nreturn err;\r\nmgr->codec_speed = speed;\r\n}\r\ndev_dbg(&mgr->pci->dev, "pcxhr_sub_set_clock to %dHz (realfreq=%d)\n",\r\nrate, realfreq);\r\nreturn 0;\r\n}\r\nint pcxhr_set_clock(struct pcxhr_mgr *mgr, unsigned int rate)\r\n{\r\nstruct pcxhr_rmh rmh;\r\nint err, changed;\r\nif (rate == 0)\r\nreturn 0;\r\nif (mgr->is_hr_stereo)\r\nerr = hr222_sub_set_clock(mgr, rate, &changed);\r\nelse\r\nerr = pcxhr_sub_set_clock(mgr, rate, &changed);\r\nif (err)\r\nreturn err;\r\nif (changed) {\r\npcxhr_init_rmh(&rmh, CMD_MODIFY_CLOCK);\r\nrmh.cmd[0] |= PCXHR_MODIFY_CLOCK_S_BIT;\r\nif (rate < PCXHR_IRQ_TIMER_FREQ)\r\nrmh.cmd[1] = PCXHR_IRQ_TIMER_PERIOD;\r\nelse\r\nrmh.cmd[1] = PCXHR_IRQ_TIMER_PERIOD * 2;\r\nrmh.cmd[2] = rate;\r\nrmh.cmd_len = 3;\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcxhr_sub_get_external_clock(struct pcxhr_mgr *mgr,\r\nenum pcxhr_clock_type clock_type,\r\nint *sample_rate)\r\n{\r\nstruct pcxhr_rmh rmh;\r\nunsigned char reg;\r\nint err, rate;\r\nswitch (clock_type) {\r\ncase PCXHR_CLOCK_TYPE_WORD_CLOCK:\r\nreg = REG_STATUS_WORD_CLOCK;\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_AES_SYNC:\r\nreg = REG_STATUS_AES_SYNC;\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_AES_1:\r\nreg = REG_STATUS_AES_1;\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_AES_2:\r\nreg = REG_STATUS_AES_2;\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_AES_3:\r\nreg = REG_STATUS_AES_3;\r\nbreak;\r\ncase PCXHR_CLOCK_TYPE_AES_4:\r\nreg = REG_STATUS_AES_4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);\r\nrmh.cmd_len = 2;\r\nrmh.cmd[0] |= IO_NUM_REG_STATUS;\r\nif (mgr->last_reg_stat != reg) {\r\nrmh.cmd[1] = reg;\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err)\r\nreturn err;\r\nudelay(100);\r\nmgr->last_reg_stat = reg;\r\n}\r\nrmh.cmd[1] = REG_STATUS_CURRENT;\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err)\r\nreturn err;\r\nswitch (rmh.stat[1] & 0x0f) {\r\ncase REG_STATUS_SYNC_32000 : rate = 32000; break;\r\ncase REG_STATUS_SYNC_44100 : rate = 44100; break;\r\ncase REG_STATUS_SYNC_48000 : rate = 48000; break;\r\ncase REG_STATUS_SYNC_64000 : rate = 64000; break;\r\ncase REG_STATUS_SYNC_88200 : rate = 88200; break;\r\ncase REG_STATUS_SYNC_96000 : rate = 96000; break;\r\ncase REG_STATUS_SYNC_128000 : rate = 128000; break;\r\ncase REG_STATUS_SYNC_176400 : rate = 176400; break;\r\ncase REG_STATUS_SYNC_192000 : rate = 192000; break;\r\ndefault: rate = 0;\r\n}\r\ndev_dbg(&mgr->pci->dev, "External clock is at %d Hz\n", rate);\r\n*sample_rate = rate;\r\nreturn 0;\r\n}\r\nint pcxhr_get_external_clock(struct pcxhr_mgr *mgr,\r\nenum pcxhr_clock_type clock_type,\r\nint *sample_rate)\r\n{\r\nif (mgr->is_hr_stereo)\r\nreturn hr222_get_external_clock(mgr, clock_type,\r\nsample_rate);\r\nelse\r\nreturn pcxhr_sub_get_external_clock(mgr, clock_type,\r\nsample_rate);\r\n}\r\nstatic int pcxhr_set_stream_state(struct pcxhr_stream *stream)\r\n{\r\nint err;\r\nstruct snd_pcxhr *chip;\r\nstruct pcxhr_rmh rmh;\r\nint stream_mask, start;\r\nif (stream->status == PCXHR_STREAM_STATUS_SCHEDULE_RUN)\r\nstart = 1;\r\nelse {\r\nif (stream->status != PCXHR_STREAM_STATUS_SCHEDULE_STOP) {\r\nsnd_printk(KERN_ERR "ERROR pcxhr_set_stream_state "\r\n"CANNOT be stopped\n");\r\nreturn -EINVAL;\r\n}\r\nstart = 0;\r\n}\r\nif (!stream->substream)\r\nreturn -EINVAL;\r\nstream->timer_abs_periods = 0;\r\nstream->timer_period_frag = 0;\r\nstream->timer_buf_periods = 0;\r\nstream->timer_is_synced = 0;\r\nstream_mask =\r\nstream->pipe->is_capture ? 1 : 1<<stream->substream->number;\r\npcxhr_init_rmh(&rmh, start ? CMD_START_STREAM : CMD_STOP_STREAM);\r\npcxhr_set_pipe_cmd_params(&rmh, stream->pipe->is_capture,\r\nstream->pipe->first_audio, 0, stream_mask);\r\nchip = snd_pcm_substream_chip(stream->substream);\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\nif (err)\r\ndev_err(chip->card->dev,\r\n"ERROR pcxhr_set_stream_state err=%x;\n", err);\r\nstream->status =\r\nstart ? PCXHR_STREAM_STATUS_STARTED : PCXHR_STREAM_STATUS_STOPPED;\r\nreturn err;\r\n}\r\nstatic int pcxhr_set_format(struct pcxhr_stream *stream)\r\n{\r\nint err, is_capture, sample_rate, stream_num;\r\nstruct snd_pcxhr *chip;\r\nstruct pcxhr_rmh rmh;\r\nunsigned int header;\r\nswitch (stream->format) {\r\ncase SNDRV_PCM_FORMAT_U8:\r\nheader = HEADER_FMT_BASE_LIN;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nheader = HEADER_FMT_BASE_LIN |\r\nHEADER_FMT_16BITS | HEADER_FMT_INTEL;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\nheader = HEADER_FMT_BASE_LIN | HEADER_FMT_16BITS;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_3LE:\r\nheader = HEADER_FMT_BASE_LIN |\r\nHEADER_FMT_24BITS | HEADER_FMT_INTEL;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_3BE:\r\nheader = HEADER_FMT_BASE_LIN | HEADER_FMT_24BITS;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_FLOAT_LE:\r\nheader = HEADER_FMT_BASE_FLOAT | HEADER_FMT_INTEL;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR\r\n"error pcxhr_set_format() : unknown format\n");\r\nreturn -EINVAL;\r\n}\r\nchip = snd_pcm_substream_chip(stream->substream);\r\nsample_rate = chip->mgr->sample_rate;\r\nif (sample_rate <= 32000 && sample_rate !=0) {\r\nif (sample_rate <= 11025)\r\nheader |= HEADER_FMT_UPTO11;\r\nelse\r\nheader |= HEADER_FMT_UPTO32;\r\n}\r\nif (stream->channels == 1)\r\nheader |= HEADER_FMT_MONO;\r\nis_capture = stream->pipe->is_capture;\r\nstream_num = is_capture ? 0 : stream->substream->number;\r\npcxhr_init_rmh(&rmh, is_capture ?\r\nCMD_FORMAT_STREAM_IN : CMD_FORMAT_STREAM_OUT);\r\npcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio,\r\nstream_num, 0);\r\nif (is_capture) {\r\nif (DSP_EXT_CMD_SET(chip->mgr))\r\nrmh.cmd[0] |= 1<<10;\r\nelse\r\nrmh.cmd[0] |= 1<<12;\r\n}\r\nrmh.cmd[1] = 0;\r\nrmh.cmd_len = 2;\r\nif (DSP_EXT_CMD_SET(chip->mgr)) {\r\nrmh.cmd[1] = stream->channels;\r\nif (!is_capture) {\r\nrmh.cmd[2] = (stream->channels == 1) ? 0x01 : 0x03;\r\nrmh.cmd_len = 3;\r\n}\r\n}\r\nrmh.cmd[rmh.cmd_len++] = header >> 8;\r\nrmh.cmd[rmh.cmd_len++] = (header & 0xff) << 16;\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\nif (err)\r\ndev_err(chip->card->dev,\r\n"ERROR pcxhr_set_format err=%x;\n", err);\r\nreturn err;\r\n}\r\nstatic int pcxhr_update_r_buffer(struct pcxhr_stream *stream)\r\n{\r\nint err, is_capture, stream_num;\r\nstruct pcxhr_rmh rmh;\r\nstruct snd_pcm_substream *subs = stream->substream;\r\nstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\r\nis_capture = (subs->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nstream_num = is_capture ? 0 : subs->number;\r\nsnd_printdd("pcxhr_update_r_buffer(pcm%c%d) : "\r\n"addr(%p) bytes(%zx) subs(%d)\n",\r\nis_capture ? 'c' : 'p',\r\nchip->chip_idx, (void *)(long)subs->runtime->dma_addr,\r\nsubs->runtime->dma_bytes, subs->number);\r\npcxhr_init_rmh(&rmh, CMD_UPDATE_R_BUFFERS);\r\npcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio,\r\nstream_num, 0);\r\nsnd_BUG_ON(subs->runtime->dma_bytes >= 0x200000);\r\nrmh.cmd[1] = subs->runtime->dma_bytes * 8;\r\nrmh.cmd[2] = subs->runtime->dma_addr >> 24;\r\nrmh.cmd[2] |= 1<<19;\r\nrmh.cmd[3] = subs->runtime->dma_addr & MASK_DSP_WORD;\r\nrmh.cmd_len = 4;\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\nif (err)\r\ndev_err(chip->card->dev,\r\n"ERROR CMD_UPDATE_R_BUFFERS err=%x;\n", err);\r\nreturn err;\r\n}\r\nstatic inline int pcxhr_stream_scheduled_get_pipe(struct pcxhr_stream *stream,\r\nstruct pcxhr_pipe **pipe)\r\n{\r\nif (stream->status == PCXHR_STREAM_STATUS_SCHEDULE_RUN) {\r\n*pipe = stream->pipe;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcxhr_trigger_tasklet(unsigned long arg)\r\n{\r\nunsigned long flags;\r\nint i, j, err;\r\nstruct pcxhr_pipe *pipe;\r\nstruct snd_pcxhr *chip;\r\nstruct pcxhr_mgr *mgr = (struct pcxhr_mgr*)(arg);\r\nint capture_mask = 0;\r\nint playback_mask = 0;\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nstruct timeval my_tv1, my_tv2;\r\ndo_gettimeofday(&my_tv1);\r\n#endif\r\nmutex_lock(&mgr->setup_mutex);\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nchip = mgr->chip[i];\r\nfor (j = 0; j < chip->nb_streams_capt; j++) {\r\nif (pcxhr_stream_scheduled_get_pipe(&chip->capture_stream[j], &pipe))\r\ncapture_mask |= (1 << pipe->first_audio);\r\n}\r\nfor (j = 0; j < chip->nb_streams_play; j++) {\r\nif (pcxhr_stream_scheduled_get_pipe(&chip->playback_stream[j], &pipe)) {\r\nplayback_mask |= (1 << pipe->first_audio);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (capture_mask == 0 && playback_mask == 0) {\r\nmutex_unlock(&mgr->setup_mutex);\r\ndev_err(&mgr->pci->dev, "pcxhr_trigger_tasklet : no pipes\n");\r\nreturn;\r\n}\r\ndev_dbg(&mgr->pci->dev, "pcxhr_trigger_tasklet : "\r\n"playback_mask=%x capture_mask=%x\n",\r\nplayback_mask, capture_mask);\r\nerr = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 0);\r\nif (err) {\r\nmutex_unlock(&mgr->setup_mutex);\r\ndev_err(&mgr->pci->dev, "pcxhr_trigger_tasklet : "\r\n"error stop pipes (P%x C%x)\n",\r\nplayback_mask, capture_mask);\r\nreturn;\r\n}\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nstruct pcxhr_stream *stream;\r\nchip = mgr->chip[i];\r\nfor (j = 0; j < chip->nb_streams_capt; j++) {\r\nstream = &chip->capture_stream[j];\r\nif (pcxhr_stream_scheduled_get_pipe(stream, &pipe)) {\r\nerr = pcxhr_set_format(stream);\r\nerr = pcxhr_update_r_buffer(stream);\r\n}\r\n}\r\nfor (j = 0; j < chip->nb_streams_play; j++) {\r\nstream = &chip->playback_stream[j];\r\nif (pcxhr_stream_scheduled_get_pipe(stream, &pipe)) {\r\nerr = pcxhr_set_format(stream);\r\nerr = pcxhr_update_r_buffer(stream);\r\n}\r\n}\r\n}\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nstruct pcxhr_stream *stream;\r\nchip = mgr->chip[i];\r\nfor (j = 0; j < chip->nb_streams_capt; j++) {\r\nstream = &chip->capture_stream[j];\r\nif (pcxhr_stream_scheduled_get_pipe(stream, &pipe))\r\nerr = pcxhr_set_stream_state(stream);\r\n}\r\nfor (j = 0; j < chip->nb_streams_play; j++) {\r\nstream = &chip->playback_stream[j];\r\nif (pcxhr_stream_scheduled_get_pipe(stream, &pipe))\r\nerr = pcxhr_set_stream_state(stream);\r\n}\r\n}\r\nerr = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);\r\nif (err) {\r\nmutex_unlock(&mgr->setup_mutex);\r\ndev_err(&mgr->pci->dev, "pcxhr_trigger_tasklet : "\r\n"error start pipes (P%x C%x)\n",\r\nplayback_mask, capture_mask);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&mgr->lock, flags);\r\nfor ( i =0; i < mgr->num_cards; i++) {\r\nstruct pcxhr_stream *stream;\r\nchip = mgr->chip[i];\r\nfor(j = 0; j < chip->nb_streams_capt; j++) {\r\nstream = &chip->capture_stream[j];\r\nif(stream->status == PCXHR_STREAM_STATUS_STARTED)\r\nstream->status = PCXHR_STREAM_STATUS_RUNNING;\r\n}\r\nfor (j = 0; j < chip->nb_streams_play; j++) {\r\nstream = &chip->playback_stream[j];\r\nif (stream->status == PCXHR_STREAM_STATUS_STARTED) {\r\nstream->timer_period_frag += mgr->granularity;\r\nstream->status = PCXHR_STREAM_STATUS_RUNNING;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&mgr->lock, flags);\r\nmutex_unlock(&mgr->setup_mutex);\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\ndo_gettimeofday(&my_tv2);\r\ndev_dbg(&mgr->pci->dev, "***TRIGGER TASKLET*** TIME = %ld (err = %x)\n",\r\n(long)(my_tv2.tv_usec - my_tv1.tv_usec), err);\r\n#endif\r\n}\r\nstatic int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)\r\n{\r\nstruct pcxhr_stream *stream;\r\nstruct snd_pcm_substream *s;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_printdd("SNDRV_PCM_TRIGGER_START\n");\r\nif (snd_pcm_stream_linked(subs)) {\r\nstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\r\nsnd_pcm_group_for_each_entry(s, subs) {\r\nif (snd_pcm_substream_chip(s) != chip)\r\ncontinue;\r\nstream = s->runtime->private_data;\r\nstream->status =\r\nPCXHR_STREAM_STATUS_SCHEDULE_RUN;\r\nsnd_pcm_trigger_done(s, subs);\r\n}\r\ntasklet_schedule(&chip->mgr->trigger_taskq);\r\n} else {\r\nstream = subs->runtime->private_data;\r\nsnd_printdd("Only one Substream %c %d\n",\r\nstream->pipe->is_capture ? 'C' : 'P',\r\nstream->pipe->first_audio);\r\nif (pcxhr_set_format(stream))\r\nreturn -EINVAL;\r\nif (pcxhr_update_r_buffer(stream))\r\nreturn -EINVAL;\r\nstream->status = PCXHR_STREAM_STATUS_SCHEDULE_RUN;\r\nif (pcxhr_set_stream_state(stream))\r\nreturn -EINVAL;\r\nstream->status = PCXHR_STREAM_STATUS_RUNNING;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nsnd_printdd("SNDRV_PCM_TRIGGER_STOP\n");\r\nsnd_pcm_group_for_each_entry(s, subs) {\r\nstream = s->runtime->private_data;\r\nstream->status = PCXHR_STREAM_STATUS_SCHEDULE_STOP;\r\nif (pcxhr_set_stream_state(stream))\r\nreturn -EINVAL;\r\nsnd_pcm_trigger_done(s, subs);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcxhr_hardware_timer(struct pcxhr_mgr *mgr, int start)\r\n{\r\nstruct pcxhr_rmh rmh;\r\nint err;\r\npcxhr_init_rmh(&rmh, CMD_SET_TIMER_INTERRUPT);\r\nif (start) {\r\nmgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;\r\nrmh.cmd[0] |= mgr->granularity;\r\n}\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err < 0)\r\ndev_err(&mgr->pci->dev, "error pcxhr_hardware_timer err(%x)\n",\r\nerr);\r\nreturn err;\r\n}\r\nstatic int pcxhr_prepare(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\r\nstruct pcxhr_mgr *mgr = chip->mgr;\r\nint err = 0;\r\ndev_dbg(chip->card->dev,\r\n"pcxhr_prepare : period_size(%lx) periods(%x) buffer_size(%lx)\n",\r\nsubs->runtime->period_size, subs->runtime->periods,\r\nsubs->runtime->buffer_size);\r\nmutex_lock(&mgr->setup_mutex);\r\ndo {\r\nif (mgr->sample_rate != subs->runtime->rate) {\r\nerr = pcxhr_set_clock(mgr, subs->runtime->rate);\r\nif (err)\r\nbreak;\r\nif (mgr->sample_rate == 0)\r\nerr = pcxhr_hardware_timer(mgr, 1);\r\nmgr->sample_rate = subs->runtime->rate;\r\n}\r\n} while(0);\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn err;\r\n}\r\nstatic int pcxhr_hw_params(struct snd_pcm_substream *subs,\r\nstruct snd_pcm_hw_params *hw)\r\n{\r\nstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\r\nstruct pcxhr_mgr *mgr = chip->mgr;\r\nstruct pcxhr_stream *stream = subs->runtime->private_data;\r\nsnd_pcm_format_t format;\r\nint err;\r\nint channels;\r\nchannels = params_channels(hw);\r\nformat = params_format(hw);\r\nmutex_lock(&mgr->setup_mutex);\r\nstream->channels = channels;\r\nstream->format = format;\r\nerr = snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw));\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn err;\r\n}\r\nstatic int pcxhr_hw_free(struct snd_pcm_substream *subs)\r\n{\r\nsnd_pcm_lib_free_pages(subs);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_open(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\r\nstruct pcxhr_mgr *mgr = chip->mgr;\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct pcxhr_stream *stream;\r\nint err;\r\nmutex_lock(&mgr->setup_mutex);\r\nruntime->hw = pcxhr_caps;\r\nif( subs->stream == SNDRV_PCM_STREAM_PLAYBACK ) {\r\ndev_dbg(chip->card->dev, "pcxhr_open playback chip%d subs%d\n",\r\nchip->chip_idx, subs->number);\r\nstream = &chip->playback_stream[subs->number];\r\n} else {\r\ndev_dbg(chip->card->dev, "pcxhr_open capture chip%d subs%d\n",\r\nchip->chip_idx, subs->number);\r\nif (mgr->mono_capture)\r\nruntime->hw.channels_max = 1;\r\nelse\r\nruntime->hw.channels_min = 2;\r\nstream = &chip->capture_stream[subs->number];\r\n}\r\nif (stream->status != PCXHR_STREAM_STATUS_FREE){\r\ndev_err(chip->card->dev, "pcxhr_open chip%d subs%d in use\n",\r\nchip->chip_idx, subs->number);\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn -EBUSY;\r\n}\r\nif (mgr->is_hr_stereo)\r\nruntime->hw.formats &= ~SNDRV_PCM_FMTBIT_FLOAT_LE;\r\nerr = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0) {\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn err;\r\n}\r\nif (mgr->sample_rate)\r\nruntime->hw.rate_min = runtime->hw.rate_max = mgr->sample_rate;\r\nelse {\r\nif (mgr->use_clock_type != PCXHR_CLOCK_TYPE_INTERNAL) {\r\nint external_rate;\r\nif (pcxhr_get_external_clock(mgr, mgr->use_clock_type,\r\n&external_rate) ||\r\nexternal_rate == 0) {\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn -EBUSY;\r\n}\r\nruntime->hw.rate_min = external_rate;\r\nruntime->hw.rate_max = external_rate;\r\n}\r\n}\r\nstream->status = PCXHR_STREAM_STATUS_OPEN;\r\nstream->substream = subs;\r\nstream->channels = 0;\r\nruntime->private_data = stream;\r\nsnd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE, 32);\r\nsnd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE, 32);\r\nsnd_pcm_set_sync(subs);\r\nmgr->ref_count_rate++;\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_close(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\r\nstruct pcxhr_mgr *mgr = chip->mgr;\r\nstruct pcxhr_stream *stream = subs->runtime->private_data;\r\nmutex_lock(&mgr->setup_mutex);\r\ndev_dbg(chip->card->dev, "pcxhr_close chip%d subs%d\n",\r\nchip->chip_idx, subs->number);\r\nif (--mgr->ref_count_rate == 0) {\r\nmgr->sample_rate = 0;\r\npcxhr_hardware_timer(mgr, 0);\r\n}\r\nstream->status = PCXHR_STREAM_STATUS_FREE;\r\nstream->substream = NULL;\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t pcxhr_stream_pointer(struct snd_pcm_substream *subs)\r\n{\r\nunsigned long flags;\r\nu_int32_t timer_period_frag;\r\nint timer_buf_periods;\r\nstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct pcxhr_stream *stream = runtime->private_data;\r\nspin_lock_irqsave(&chip->mgr->lock, flags);\r\ntimer_period_frag = stream->timer_period_frag;\r\ntimer_buf_periods = stream->timer_buf_periods;\r\nspin_unlock_irqrestore(&chip->mgr->lock, flags);\r\nreturn (snd_pcm_uframes_t)((timer_buf_periods * runtime->period_size) +\r\ntimer_period_frag);\r\n}\r\nint pcxhr_create_pcm(struct snd_pcxhr *chip)\r\n{\r\nint err;\r\nstruct snd_pcm *pcm;\r\nchar name[32];\r\nsprintf(name, "pcxhr %d", chip->chip_idx);\r\nif ((err = snd_pcm_new(chip->card, name, 0,\r\nchip->nb_streams_play,\r\nchip->nb_streams_capt, &pcm)) < 0) {\r\ndev_err(chip->card->dev, "cannot create pcm %s\n", name);\r\nreturn err;\r\n}\r\npcm->private_data = chip;\r\nif (chip->nb_streams_play)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &pcxhr_ops);\r\nif (chip->nb_streams_capt)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &pcxhr_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, name);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->mgr->pci),\r\n32*1024, 32*1024);\r\nchip->pcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_chip_free(struct snd_pcxhr *chip)\r\n{\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_chip_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_pcxhr *chip = device->device_data;\r\nreturn pcxhr_chip_free(chip);\r\n}\r\nstatic int pcxhr_create(struct pcxhr_mgr *mgr,\r\nstruct snd_card *card, int idx)\r\n{\r\nint err;\r\nstruct snd_pcxhr *chip;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = pcxhr_chip_dev_free,\r\n};\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (! chip) {\r\ndev_err(card->dev, "cannot allocate chip\n");\r\nreturn -ENOMEM;\r\n}\r\nchip->card = card;\r\nchip->chip_idx = idx;\r\nchip->mgr = mgr;\r\nif (idx < mgr->playback_chips)\r\nchip->nb_streams_play = PCXHR_PLAYBACK_STREAMS;\r\nif (idx < mgr->capture_chips) {\r\nif (mgr->mono_capture)\r\nchip->nb_streams_capt = 2;\r\nelse\r\nchip->nb_streams_capt = 1;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\npcxhr_chip_free(chip);\r\nreturn err;\r\n}\r\nmgr->chip[idx] = chip;\r\nreturn 0;\r\n}\r\nstatic void pcxhr_proc_info(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_pcxhr *chip = entry->private_data;\r\nstruct pcxhr_mgr *mgr = chip->mgr;\r\nsnd_iprintf(buffer, "\n%s\n", mgr->longname);\r\nif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {\r\nstruct pcxhr_rmh rmh;\r\nshort ver_maj = (mgr->dsp_version >> 16) & 0xff;\r\nshort ver_min = (mgr->dsp_version >> 8) & 0xff;\r\nshort ver_build = mgr->dsp_version & 0xff;\r\nsnd_iprintf(buffer, "module version %s\n",\r\nPCXHR_DRIVER_VERSION_STRING);\r\nsnd_iprintf(buffer, "dsp version %d.%d.%d\n",\r\nver_maj, ver_min, ver_build);\r\nif (mgr->board_has_analog)\r\nsnd_iprintf(buffer, "analog io available\n");\r\nelse\r\nsnd_iprintf(buffer, "digital only board\n");\r\npcxhr_init_rmh(&rmh, CMD_GET_DSP_RESOURCES);\r\nif( ! pcxhr_send_msg(mgr, &rmh) ) {\r\nint cur = rmh.stat[0];\r\nint ref = rmh.stat[1];\r\nif (ref > 0) {\r\nif (mgr->sample_rate_real != 0 &&\r\nmgr->sample_rate_real != 48000) {\r\nref = (ref * 48000) /\r\nmgr->sample_rate_real;\r\nif (mgr->sample_rate_real >=\r\nPCXHR_IRQ_TIMER_FREQ)\r\nref *= 2;\r\n}\r\ncur = 100 - (100 * cur) / ref;\r\nsnd_iprintf(buffer, "cpu load %d%%\n", cur);\r\nsnd_iprintf(buffer, "buffer pool %d/%d\n",\r\nrmh.stat[2], rmh.stat[3]);\r\n}\r\n}\r\nsnd_iprintf(buffer, "dma granularity : %d\n",\r\nmgr->granularity);\r\nsnd_iprintf(buffer, "dsp time errors : %d\n",\r\nmgr->dsp_time_err);\r\nsnd_iprintf(buffer, "dsp async pipe xrun errors : %d\n",\r\nmgr->async_err_pipe_xrun);\r\nsnd_iprintf(buffer, "dsp async stream xrun errors : %d\n",\r\nmgr->async_err_stream_xrun);\r\nsnd_iprintf(buffer, "dsp async last other error : %x\n",\r\nmgr->async_err_other_last);\r\nrmh.cmd[0] = 0x4200 + PCXHR_SIZE_MAX_STATUS;\r\nrmh.cmd_len = 1;\r\nrmh.stat_len = PCXHR_SIZE_MAX_STATUS;\r\nrmh.dsp_stat = 0;\r\nrmh.cmd_idx = CMD_LAST_INDEX;\r\nif( ! pcxhr_send_msg(mgr, &rmh) ) {\r\nint i;\r\nif (rmh.stat_len > 8)\r\nrmh.stat_len = 8;\r\nfor (i = 0; i < rmh.stat_len; i++)\r\nsnd_iprintf(buffer, "debug[%02d] = %06x\n",\r\ni, rmh.stat[i]);\r\n}\r\n} else\r\nsnd_iprintf(buffer, "no firmware loaded\n");\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void pcxhr_proc_sync(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_pcxhr *chip = entry->private_data;\r\nstruct pcxhr_mgr *mgr = chip->mgr;\r\nstatic const char *textsHR22[3] = {\r\n"Internal", "AES Sync", "AES 1"\r\n};\r\nstatic const char *textsPCXHR[7] = {\r\n"Internal", "Word", "AES Sync",\r\n"AES 1", "AES 2", "AES 3", "AES 4"\r\n};\r\nconst char **texts;\r\nint max_clock;\r\nif (mgr->is_hr_stereo) {\r\ntexts = textsHR22;\r\nmax_clock = HR22_CLOCK_TYPE_MAX;\r\n} else {\r\ntexts = textsPCXHR;\r\nmax_clock = PCXHR_CLOCK_TYPE_MAX;\r\n}\r\nsnd_iprintf(buffer, "\n%s\n", mgr->longname);\r\nsnd_iprintf(buffer, "Current Sample Clock\t: %s\n",\r\ntexts[mgr->cur_clock_type]);\r\nsnd_iprintf(buffer, "Current Sample Rate\t= %d\n",\r\nmgr->sample_rate_real);\r\nif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {\r\nint i, err, sample_rate;\r\nfor (i = 1; i <= max_clock; i++) {\r\nerr = pcxhr_get_external_clock(mgr, i, &sample_rate);\r\nif (err)\r\nbreak;\r\nsnd_iprintf(buffer, "%s Clock\t\t= %d\n",\r\ntexts[i], sample_rate);\r\n}\r\n} else\r\nsnd_iprintf(buffer, "no firmware loaded\n");\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void pcxhr_proc_gpio_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_pcxhr *chip = entry->private_data;\r\nstruct pcxhr_mgr *mgr = chip->mgr;\r\nif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {\r\nint value = 0;\r\nhr222_read_gpio(mgr, 1, &value);\r\nsnd_iprintf(buffer, "GPI: 0x%x\n", value);\r\nhr222_read_gpio(mgr, 0, &value);\r\nsnd_iprintf(buffer, "GPO: 0x%x\n", value);\r\n} else\r\nsnd_iprintf(buffer, "no firmware loaded\n");\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void pcxhr_proc_gpo_write(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_pcxhr *chip = entry->private_data;\r\nstruct pcxhr_mgr *mgr = chip->mgr;\r\nchar line[64];\r\nint value;\r\nif (!(mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)))\r\nreturn;\r\nwhile (!snd_info_get_line(buffer, line, sizeof(line))) {\r\nif (sscanf(line, "GPO: 0x%x", &value) != 1)\r\ncontinue;\r\nhr222_write_gpo(mgr, value);\r\n}\r\n}\r\nstatic void pcxhr_proc_ltc(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_pcxhr *chip = entry->private_data;\r\nstruct pcxhr_mgr *mgr = chip->mgr;\r\nstruct pcxhr_rmh rmh;\r\nunsigned int ltcHrs, ltcMin, ltcSec, ltcFrm;\r\nint err;\r\nif (!(mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX))) {\r\nsnd_iprintf(buffer, "no firmware loaded\n");\r\nreturn;\r\n}\r\nif (!mgr->capture_ltc) {\r\npcxhr_init_rmh(&rmh, CMD_MANAGE_SIGNAL);\r\nrmh.cmd[0] |= MANAGE_SIGNAL_TIME_CODE;\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err) {\r\nsnd_iprintf(buffer, "ltc not activated (%d)\n", err);\r\nreturn;\r\n}\r\nif (mgr->is_hr_stereo)\r\nhr222_manage_timecode(mgr, 1);\r\nelse\r\npcxhr_write_io_num_reg_cont(mgr, REG_CONT_VALSMPTE,\r\nREG_CONT_VALSMPTE, NULL);\r\nmgr->capture_ltc = 1;\r\n}\r\npcxhr_init_rmh(&rmh, CMD_GET_TIME_CODE);\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err) {\r\nsnd_iprintf(buffer, "ltc read error (err=%d)\n", err);\r\nreturn ;\r\n}\r\nltcHrs = 10*((rmh.stat[0] >> 8) & 0x3) + (rmh.stat[0] & 0xf);\r\nltcMin = 10*((rmh.stat[1] >> 16) & 0x7) + ((rmh.stat[1] >> 8) & 0xf);\r\nltcSec = 10*(rmh.stat[1] & 0x7) + ((rmh.stat[2] >> 16) & 0xf);\r\nltcFrm = 10*((rmh.stat[2] >> 8) & 0x3) + (rmh.stat[2] & 0xf);\r\nsnd_iprintf(buffer, "timecode: %02u:%02u:%02u-%02u\n",\r\nltcHrs, ltcMin, ltcSec, ltcFrm);\r\nsnd_iprintf(buffer, "raw: 0x%04x%06x%06x\n", rmh.stat[0] & 0x00ffff,\r\nrmh.stat[1] & 0xffffff, rmh.stat[2] & 0xffffff);\r\nif (!(rmh.stat[0] & TIME_CODE_VALID_MASK)) {\r\nsnd_iprintf(buffer, "warning: linear timecode not valid\n");\r\n}\r\n}\r\nstatic void pcxhr_proc_init(struct snd_pcxhr *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(chip->card, "info", &entry))\r\nsnd_info_set_text_ops(entry, chip, pcxhr_proc_info);\r\nif (! snd_card_proc_new(chip->card, "sync", &entry))\r\nsnd_info_set_text_ops(entry, chip, pcxhr_proc_sync);\r\nif (chip->mgr->is_hr_stereo &&\r\n!snd_card_proc_new(chip->card, "gpio", &entry)) {\r\nsnd_info_set_text_ops(entry, chip, pcxhr_proc_gpio_read);\r\nentry->c.text.write = pcxhr_proc_gpo_write;\r\nentry->mode |= S_IWUSR;\r\n}\r\nif (!snd_card_proc_new(chip->card, "ltc", &entry))\r\nsnd_info_set_text_ops(entry, chip, pcxhr_proc_ltc);\r\n}\r\nstatic int pcxhr_free(struct pcxhr_mgr *mgr)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nif (mgr->chip[i])\r\nsnd_card_free(mgr->chip[i]->card);\r\n}\r\nif(mgr->dsp_loaded) {\r\npcxhr_reset_board(mgr);\r\ndev_dbg(&mgr->pci->dev, "reset pcxhr !\n");\r\n}\r\nif (mgr->irq >= 0)\r\nfree_irq(mgr->irq, mgr);\r\npci_release_regions(mgr->pci);\r\nif (mgr->hostport.area) {\r\nsnd_dma_free_pages(&mgr->hostport);\r\nmgr->hostport.area = NULL;\r\n}\r\nkfree(mgr->prmh);\r\npci_disable_device(mgr->pci);\r\nkfree(mgr);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct pcxhr_mgr *mgr;\r\nunsigned int i;\r\nint err;\r\nsize_t size;\r\nchar *card_name;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (! enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\npci_set_master(pci);\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(32)) < 0) {\r\ndev_err(&pci->dev,\r\n"architecture does not support 32bit PCI busmaster DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nmgr = kzalloc(sizeof(*mgr), GFP_KERNEL);\r\nif (! mgr) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nif (snd_BUG_ON(pci_id->driver_data >= PCI_ID_LAST)) {\r\nkfree(mgr);\r\npci_disable_device(pci);\r\nreturn -ENODEV;\r\n}\r\ncard_name =\r\npcxhr_board_params[pci_id->driver_data].board_name;\r\nmgr->playback_chips =\r\npcxhr_board_params[pci_id->driver_data].playback_chips;\r\nmgr->capture_chips =\r\npcxhr_board_params[pci_id->driver_data].capture_chips;\r\nmgr->fw_file_set =\r\npcxhr_board_params[pci_id->driver_data].fw_file_set;\r\nmgr->firmware_num =\r\npcxhr_board_params[pci_id->driver_data].firmware_num;\r\nmgr->mono_capture = mono[dev];\r\nmgr->is_hr_stereo = (mgr->playback_chips == 1);\r\nmgr->board_has_aes1 = PCXHR_BOARD_HAS_AES1(mgr);\r\nmgr->board_aes_in_192k = !PCXHR_BOARD_AESIN_NO_192K(mgr);\r\nif (mgr->is_hr_stereo)\r\nmgr->granularity = PCXHR_GRANULARITY_HR22;\r\nelse\r\nmgr->granularity = PCXHR_GRANULARITY;\r\nif ((err = pci_request_regions(pci, card_name)) < 0) {\r\nkfree(mgr);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nfor (i = 0; i < 3; i++)\r\nmgr->port[i] = pci_resource_start(pci, i);\r\nmgr->pci = pci;\r\nmgr->irq = -1;\r\nif (request_irq(pci->irq, pcxhr_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, mgr)) {\r\ndev_err(&pci->dev, "unable to grab IRQ %d\n", pci->irq);\r\npcxhr_free(mgr);\r\nreturn -EBUSY;\r\n}\r\nmgr->irq = pci->irq;\r\nsprintf(mgr->shortname, "Digigram %s", card_name);\r\nsprintf(mgr->longname, "%s at 0x%lx & 0x%lx, 0x%lx irq %i",\r\nmgr->shortname,\r\nmgr->port[0], mgr->port[1], mgr->port[2], mgr->irq);\r\nspin_lock_init(&mgr->lock);\r\nspin_lock_init(&mgr->msg_lock);\r\nmutex_init(&mgr->setup_mutex);\r\ntasklet_init(&mgr->msg_taskq, pcxhr_msg_tasklet,\r\n(unsigned long) mgr);\r\ntasklet_init(&mgr->trigger_taskq, pcxhr_trigger_tasklet,\r\n(unsigned long) mgr);\r\nmgr->prmh = kmalloc(sizeof(*mgr->prmh) +\r\nsizeof(u32) * (PCXHR_SIZE_MAX_LONG_STATUS -\r\nPCXHR_SIZE_MAX_STATUS),\r\nGFP_KERNEL);\r\nif (! mgr->prmh) {\r\npcxhr_free(mgr);\r\nreturn -ENOMEM;\r\n}\r\nfor (i=0; i < PCXHR_MAX_CARDS; i++) {\r\nstruct snd_card *card;\r\nchar tmpid[16];\r\nint idx;\r\nif (i >= max(mgr->playback_chips, mgr->capture_chips))\r\nbreak;\r\nmgr->num_cards++;\r\nif (index[dev] < 0)\r\nidx = index[dev];\r\nelse\r\nidx = index[dev] + i;\r\nsnprintf(tmpid, sizeof(tmpid), "%s-%d",\r\nid[dev] ? id[dev] : card_name, i);\r\nerr = snd_card_new(&pci->dev, idx, tmpid, THIS_MODULE,\r\n0, &card);\r\nif (err < 0) {\r\ndev_err(card->dev, "cannot allocate the card %d\n", i);\r\npcxhr_free(mgr);\r\nreturn err;\r\n}\r\nstrcpy(card->driver, DRIVER_NAME);\r\nsprintf(card->shortname, "%s [PCM #%d]", mgr->shortname, i);\r\nsprintf(card->longname, "%s [PCM #%d]", mgr->longname, i);\r\nif ((err = pcxhr_create(mgr, card, i)) < 0) {\r\nsnd_card_free(card);\r\npcxhr_free(mgr);\r\nreturn err;\r\n}\r\nif (i == 0)\r\npcxhr_proc_init(mgr->chip[i]);\r\nif ((err = snd_card_register(card)) < 0) {\r\npcxhr_free(mgr);\r\nreturn err;\r\n}\r\n}\r\nsize = PAGE_ALIGN(sizeof(struct pcxhr_hostport));\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\r\nsize, &mgr->hostport) < 0) {\r\npcxhr_free(mgr);\r\nreturn -ENOMEM;\r\n}\r\nmemset(mgr->hostport.area, 0, size);\r\nerr = pcxhr_setup_firmware(mgr);\r\nif (err < 0) {\r\npcxhr_free(mgr);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, mgr);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void pcxhr_remove(struct pci_dev *pci)\r\n{\r\npcxhr_free(pci_get_drvdata(pci));\r\n}
