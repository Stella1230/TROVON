static int uio_pdrv_genirq_open(struct uio_info *info, struct inode *inode)\r\n{\r\nstruct uio_pdrv_genirq_platdata *priv = info->priv;\r\npm_runtime_get_sync(&priv->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int uio_pdrv_genirq_release(struct uio_info *info, struct inode *inode)\r\n{\r\nstruct uio_pdrv_genirq_platdata *priv = info->priv;\r\npm_runtime_put_sync(&priv->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t uio_pdrv_genirq_handler(int irq, struct uio_info *dev_info)\r\n{\r\nstruct uio_pdrv_genirq_platdata *priv = dev_info->priv;\r\nspin_lock(&priv->lock);\r\nif (!__test_and_set_bit(UIO_IRQ_DISABLED, &priv->flags))\r\ndisable_irq_nosync(irq);\r\nspin_unlock(&priv->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int uio_pdrv_genirq_irqcontrol(struct uio_info *dev_info, s32 irq_on)\r\n{\r\nstruct uio_pdrv_genirq_platdata *priv = dev_info->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (irq_on) {\r\nif (__test_and_clear_bit(UIO_IRQ_DISABLED, &priv->flags))\r\nenable_irq(dev_info->irq);\r\n} else {\r\nif (!__test_and_set_bit(UIO_IRQ_DISABLED, &priv->flags))\r\ndisable_irq_nosync(dev_info->irq);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int uio_pdrv_genirq_probe(struct platform_device *pdev)\r\n{\r\nstruct uio_info *uioinfo = dev_get_platdata(&pdev->dev);\r\nstruct uio_pdrv_genirq_platdata *priv;\r\nstruct uio_mem *uiomem;\r\nint ret = -EINVAL;\r\nint i;\r\nif (pdev->dev.of_node) {\r\nuioinfo = devm_kzalloc(&pdev->dev, sizeof(*uioinfo),\r\nGFP_KERNEL);\r\nif (!uioinfo) {\r\ndev_err(&pdev->dev, "unable to kmalloc\n");\r\nreturn -ENOMEM;\r\n}\r\nuioinfo->name = pdev->dev.of_node->name;\r\nuioinfo->version = "devicetree";\r\n}\r\nif (!uioinfo || !uioinfo->name || !uioinfo->version) {\r\ndev_err(&pdev->dev, "missing platform_data\n");\r\nreturn ret;\r\n}\r\nif (uioinfo->handler || uioinfo->irqcontrol ||\r\nuioinfo->irq_flags & IRQF_SHARED) {\r\ndev_err(&pdev->dev, "interrupt configuration error\n");\r\nreturn ret;\r\n}\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "unable to kmalloc\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->uioinfo = uioinfo;\r\nspin_lock_init(&priv->lock);\r\npriv->flags = 0;\r\npriv->pdev = pdev;\r\nif (!uioinfo->irq) {\r\nret = platform_get_irq(pdev, 0);\r\nuioinfo->irq = ret;\r\nif (ret == -ENXIO && pdev->dev.of_node)\r\nuioinfo->irq = UIO_IRQ_NONE;\r\nelse if (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ\n");\r\nreturn ret;\r\n}\r\n}\r\nuiomem = &uioinfo->mem[0];\r\nfor (i = 0; i < pdev->num_resources; ++i) {\r\nstruct resource *r = &pdev->resource[i];\r\nif (r->flags != IORESOURCE_MEM)\r\ncontinue;\r\nif (uiomem >= &uioinfo->mem[MAX_UIO_MAPS]) {\r\ndev_warn(&pdev->dev, "device has more than "\r\n__stringify(MAX_UIO_MAPS)\r\n" I/O memory resources.\n");\r\nbreak;\r\n}\r\nuiomem->memtype = UIO_MEM_PHYS;\r\nuiomem->addr = r->start;\r\nuiomem->size = resource_size(r);\r\nuiomem->name = r->name;\r\n++uiomem;\r\n}\r\nwhile (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {\r\nuiomem->size = 0;\r\n++uiomem;\r\n}\r\nuioinfo->handler = uio_pdrv_genirq_handler;\r\nuioinfo->irqcontrol = uio_pdrv_genirq_irqcontrol;\r\nuioinfo->open = uio_pdrv_genirq_open;\r\nuioinfo->release = uio_pdrv_genirq_release;\r\nuioinfo->priv = priv;\r\npm_runtime_enable(&pdev->dev);\r\nret = uio_register_device(&pdev->dev, priv->uioinfo);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to register uio device\n");\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nstatic int uio_pdrv_genirq_remove(struct platform_device *pdev)\r\n{\r\nstruct uio_pdrv_genirq_platdata *priv = platform_get_drvdata(pdev);\r\nuio_unregister_device(priv->uioinfo);\r\npm_runtime_disable(&pdev->dev);\r\npriv->uioinfo->handler = NULL;\r\npriv->uioinfo->irqcontrol = NULL;\r\nreturn 0;\r\n}\r\nstatic int uio_pdrv_genirq_runtime_nop(struct device *dev)\r\n{\r\nreturn 0;\r\n}
