int tipc_ref_table_init(u32 requested_size, u32 start)\r\n{\r\nstruct reference *table;\r\nu32 actual_size;\r\nrequested_size++;\r\nfor (actual_size = 16; actual_size < requested_size; actual_size <<= 1)\r\n;\r\ntable = vzalloc(actual_size * sizeof(struct reference));\r\nif (table == NULL)\r\nreturn -ENOMEM;\r\ntipc_ref_table.entries = table;\r\ntipc_ref_table.capacity = requested_size;\r\ntipc_ref_table.init_point = 1;\r\ntipc_ref_table.first_free = 0;\r\ntipc_ref_table.last_free = 0;\r\ntipc_ref_table.index_mask = actual_size - 1;\r\ntipc_ref_table.start_mask = start & ~tipc_ref_table.index_mask;\r\nreturn 0;\r\n}\r\nvoid tipc_ref_table_stop(void)\r\n{\r\nvfree(tipc_ref_table.entries);\r\ntipc_ref_table.entries = NULL;\r\n}\r\nu32 tipc_ref_acquire(void *object, spinlock_t **lock)\r\n{\r\nu32 index;\r\nu32 index_mask;\r\nu32 next_plus_upper;\r\nu32 ref;\r\nstruct reference *entry = NULL;\r\nif (!object) {\r\npr_err("Attempt to acquire ref. to non-existent obj\n");\r\nreturn 0;\r\n}\r\nif (!tipc_ref_table.entries) {\r\npr_err("Ref. table not found in acquisition attempt\n");\r\nreturn 0;\r\n}\r\nspin_lock_bh(&ref_table_lock);\r\nif (tipc_ref_table.first_free) {\r\nindex = tipc_ref_table.first_free;\r\nentry = &(tipc_ref_table.entries[index]);\r\nindex_mask = tipc_ref_table.index_mask;\r\nnext_plus_upper = entry->ref;\r\ntipc_ref_table.first_free = next_plus_upper & index_mask;\r\nref = (next_plus_upper & ~index_mask) + index;\r\n} else if (tipc_ref_table.init_point < tipc_ref_table.capacity) {\r\nindex = tipc_ref_table.init_point++;\r\nentry = &(tipc_ref_table.entries[index]);\r\nspin_lock_init(&entry->lock);\r\nref = tipc_ref_table.start_mask + index;\r\n} else {\r\nref = 0;\r\n}\r\nspin_unlock_bh(&ref_table_lock);\r\nif (entry) {\r\nspin_lock_bh(&entry->lock);\r\nentry->ref = ref;\r\nentry->object = object;\r\n*lock = &entry->lock;\r\n}\r\nreturn ref;\r\n}\r\nvoid tipc_ref_discard(u32 ref)\r\n{\r\nstruct reference *entry;\r\nu32 index;\r\nu32 index_mask;\r\nif (!tipc_ref_table.entries) {\r\npr_err("Ref. table not found during discard attempt\n");\r\nreturn;\r\n}\r\nindex_mask = tipc_ref_table.index_mask;\r\nindex = ref & index_mask;\r\nentry = &(tipc_ref_table.entries[index]);\r\nspin_lock_bh(&ref_table_lock);\r\nif (!entry->object) {\r\npr_err("Attempt to discard ref. to non-existent obj\n");\r\ngoto exit;\r\n}\r\nif (entry->ref != ref) {\r\npr_err("Attempt to discard non-existent reference\n");\r\ngoto exit;\r\n}\r\nentry->object = NULL;\r\nentry->ref = (ref & ~index_mask) + (index_mask + 1);\r\nif (tipc_ref_table.first_free == 0)\r\ntipc_ref_table.first_free = index;\r\nelse\r\ntipc_ref_table.entries[tipc_ref_table.last_free].ref |= index;\r\ntipc_ref_table.last_free = index;\r\nexit:\r\nspin_unlock_bh(&ref_table_lock);\r\n}\r\nvoid *tipc_ref_lock(u32 ref)\r\n{\r\nif (likely(tipc_ref_table.entries)) {\r\nstruct reference *entry;\r\nentry = &tipc_ref_table.entries[ref &\r\ntipc_ref_table.index_mask];\r\nif (likely(entry->ref != 0)) {\r\nspin_lock_bh(&entry->lock);\r\nif (likely((entry->ref == ref) && (entry->object)))\r\nreturn entry->object;\r\nspin_unlock_bh(&entry->lock);\r\n}\r\n}\r\nreturn NULL;\r\n}
