static void ondemand_powersave_bias_init_cpu(int cpu)\r\n{\r\nstruct od_cpu_dbs_info_s *dbs_info = &per_cpu(od_cpu_dbs_info, cpu);\r\ndbs_info->freq_table = cpufreq_frequency_get_table(cpu);\r\ndbs_info->freq_lo = 0;\r\n}\r\nstatic int should_io_be_busy(void)\r\n{\r\n#if defined(CONFIG_X86)\r\nif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\r\nboot_cpu_data.x86 == 6 &&\r\nboot_cpu_data.x86_model >= 15)\r\nreturn 1;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic unsigned int generic_powersave_bias_target(struct cpufreq_policy *policy,\r\nunsigned int freq_next, unsigned int relation)\r\n{\r\nunsigned int freq_req, freq_reduc, freq_avg;\r\nunsigned int freq_hi, freq_lo;\r\nunsigned int index = 0;\r\nunsigned int jiffies_total, jiffies_hi, jiffies_lo;\r\nstruct od_cpu_dbs_info_s *dbs_info = &per_cpu(od_cpu_dbs_info,\r\npolicy->cpu);\r\nstruct dbs_data *dbs_data = policy->governor_data;\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nif (!dbs_info->freq_table) {\r\ndbs_info->freq_lo = 0;\r\ndbs_info->freq_lo_jiffies = 0;\r\nreturn freq_next;\r\n}\r\ncpufreq_frequency_table_target(policy, dbs_info->freq_table, freq_next,\r\nrelation, &index);\r\nfreq_req = dbs_info->freq_table[index].frequency;\r\nfreq_reduc = freq_req * od_tuners->powersave_bias / 1000;\r\nfreq_avg = freq_req - freq_reduc;\r\nindex = 0;\r\ncpufreq_frequency_table_target(policy, dbs_info->freq_table, freq_avg,\r\nCPUFREQ_RELATION_H, &index);\r\nfreq_lo = dbs_info->freq_table[index].frequency;\r\nindex = 0;\r\ncpufreq_frequency_table_target(policy, dbs_info->freq_table, freq_avg,\r\nCPUFREQ_RELATION_L, &index);\r\nfreq_hi = dbs_info->freq_table[index].frequency;\r\nif (freq_hi == freq_lo) {\r\ndbs_info->freq_lo = 0;\r\ndbs_info->freq_lo_jiffies = 0;\r\nreturn freq_lo;\r\n}\r\njiffies_total = usecs_to_jiffies(od_tuners->sampling_rate);\r\njiffies_hi = (freq_avg - freq_lo) * jiffies_total;\r\njiffies_hi += ((freq_hi - freq_lo) / 2);\r\njiffies_hi /= (freq_hi - freq_lo);\r\njiffies_lo = jiffies_total - jiffies_hi;\r\ndbs_info->freq_lo = freq_lo;\r\ndbs_info->freq_lo_jiffies = jiffies_lo;\r\ndbs_info->freq_hi_jiffies = jiffies_hi;\r\nreturn freq_hi;\r\n}\r\nstatic void ondemand_powersave_bias_init(void)\r\n{\r\nint i;\r\nfor_each_online_cpu(i) {\r\nondemand_powersave_bias_init_cpu(i);\r\n}\r\n}\r\nstatic void dbs_freq_increase(struct cpufreq_policy *policy, unsigned int freq)\r\n{\r\nstruct dbs_data *dbs_data = policy->governor_data;\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nif (od_tuners->powersave_bias)\r\nfreq = od_ops.powersave_bias_target(policy, freq,\r\nCPUFREQ_RELATION_H);\r\nelse if (policy->cur == policy->max)\r\nreturn;\r\n__cpufreq_driver_target(policy, freq, od_tuners->powersave_bias ?\r\nCPUFREQ_RELATION_L : CPUFREQ_RELATION_H);\r\n}\r\nstatic void od_check_cpu(int cpu, unsigned int load)\r\n{\r\nstruct od_cpu_dbs_info_s *dbs_info = &per_cpu(od_cpu_dbs_info, cpu);\r\nstruct cpufreq_policy *policy = dbs_info->cdbs.cur_policy;\r\nstruct dbs_data *dbs_data = policy->governor_data;\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\ndbs_info->freq_lo = 0;\r\nif (load > od_tuners->up_threshold) {\r\nif (policy->cur < policy->max)\r\ndbs_info->rate_mult =\r\nod_tuners->sampling_down_factor;\r\ndbs_freq_increase(policy, policy->max);\r\n} else {\r\nunsigned int freq_next;\r\nfreq_next = load * policy->cpuinfo.max_freq / 100;\r\ndbs_info->rate_mult = 1;\r\nif (!od_tuners->powersave_bias) {\r\n__cpufreq_driver_target(policy, freq_next,\r\nCPUFREQ_RELATION_L);\r\nreturn;\r\n}\r\nfreq_next = od_ops.powersave_bias_target(policy, freq_next,\r\nCPUFREQ_RELATION_L);\r\n__cpufreq_driver_target(policy, freq_next, CPUFREQ_RELATION_L);\r\n}\r\n}\r\nstatic void od_dbs_timer(struct work_struct *work)\r\n{\r\nstruct od_cpu_dbs_info_s *dbs_info =\r\ncontainer_of(work, struct od_cpu_dbs_info_s, cdbs.work.work);\r\nunsigned int cpu = dbs_info->cdbs.cur_policy->cpu;\r\nstruct od_cpu_dbs_info_s *core_dbs_info = &per_cpu(od_cpu_dbs_info,\r\ncpu);\r\nstruct dbs_data *dbs_data = dbs_info->cdbs.cur_policy->governor_data;\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nint delay = 0, sample_type = core_dbs_info->sample_type;\r\nbool modify_all = true;\r\nmutex_lock(&core_dbs_info->cdbs.timer_mutex);\r\nif (!need_load_eval(&core_dbs_info->cdbs, od_tuners->sampling_rate)) {\r\nmodify_all = false;\r\ngoto max_delay;\r\n}\r\ncore_dbs_info->sample_type = OD_NORMAL_SAMPLE;\r\nif (sample_type == OD_SUB_SAMPLE) {\r\ndelay = core_dbs_info->freq_lo_jiffies;\r\n__cpufreq_driver_target(core_dbs_info->cdbs.cur_policy,\r\ncore_dbs_info->freq_lo, CPUFREQ_RELATION_H);\r\n} else {\r\ndbs_check_cpu(dbs_data, cpu);\r\nif (core_dbs_info->freq_lo) {\r\ncore_dbs_info->sample_type = OD_SUB_SAMPLE;\r\ndelay = core_dbs_info->freq_hi_jiffies;\r\n}\r\n}\r\nmax_delay:\r\nif (!delay)\r\ndelay = delay_for_sampling_rate(od_tuners->sampling_rate\r\n* core_dbs_info->rate_mult);\r\ngov_queue_work(dbs_data, dbs_info->cdbs.cur_policy, delay, modify_all);\r\nmutex_unlock(&core_dbs_info->cdbs.timer_mutex);\r\n}\r\nstatic void update_sampling_rate(struct dbs_data *dbs_data,\r\nunsigned int new_rate)\r\n{\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nint cpu;\r\nod_tuners->sampling_rate = new_rate = max(new_rate,\r\ndbs_data->min_sampling_rate);\r\nfor_each_online_cpu(cpu) {\r\nstruct cpufreq_policy *policy;\r\nstruct od_cpu_dbs_info_s *dbs_info;\r\nunsigned long next_sampling, appointed_at;\r\npolicy = cpufreq_cpu_get(cpu);\r\nif (!policy)\r\ncontinue;\r\nif (policy->governor != &cpufreq_gov_ondemand) {\r\ncpufreq_cpu_put(policy);\r\ncontinue;\r\n}\r\ndbs_info = &per_cpu(od_cpu_dbs_info, cpu);\r\ncpufreq_cpu_put(policy);\r\nmutex_lock(&dbs_info->cdbs.timer_mutex);\r\nif (!delayed_work_pending(&dbs_info->cdbs.work)) {\r\nmutex_unlock(&dbs_info->cdbs.timer_mutex);\r\ncontinue;\r\n}\r\nnext_sampling = jiffies + usecs_to_jiffies(new_rate);\r\nappointed_at = dbs_info->cdbs.work.timer.expires;\r\nif (time_before(next_sampling, appointed_at)) {\r\nmutex_unlock(&dbs_info->cdbs.timer_mutex);\r\ncancel_delayed_work_sync(&dbs_info->cdbs.work);\r\nmutex_lock(&dbs_info->cdbs.timer_mutex);\r\ngov_queue_work(dbs_data, dbs_info->cdbs.cur_policy,\r\nusecs_to_jiffies(new_rate), true);\r\n}\r\nmutex_unlock(&dbs_info->cdbs.timer_mutex);\r\n}\r\n}\r\nstatic ssize_t store_sampling_rate(struct dbs_data *dbs_data, const char *buf,\r\nsize_t count)\r\n{\r\nunsigned int input;\r\nint ret;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nupdate_sampling_rate(dbs_data, input);\r\nreturn count;\r\n}\r\nstatic ssize_t store_io_is_busy(struct dbs_data *dbs_data, const char *buf,\r\nsize_t count)\r\n{\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nunsigned int input;\r\nint ret;\r\nunsigned int j;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nod_tuners->io_is_busy = !!input;\r\nfor_each_online_cpu(j) {\r\nstruct od_cpu_dbs_info_s *dbs_info = &per_cpu(od_cpu_dbs_info,\r\nj);\r\ndbs_info->cdbs.prev_cpu_idle = get_cpu_idle_time(j,\r\n&dbs_info->cdbs.prev_cpu_wall, od_tuners->io_is_busy);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t store_up_threshold(struct dbs_data *dbs_data, const char *buf,\r\nsize_t count)\r\n{\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nunsigned int input;\r\nint ret;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1 || input > MAX_FREQUENCY_UP_THRESHOLD ||\r\ninput < MIN_FREQUENCY_UP_THRESHOLD) {\r\nreturn -EINVAL;\r\n}\r\nod_tuners->up_threshold = input;\r\nreturn count;\r\n}\r\nstatic ssize_t store_sampling_down_factor(struct dbs_data *dbs_data,\r\nconst char *buf, size_t count)\r\n{\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nunsigned int input, j;\r\nint ret;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1 || input > MAX_SAMPLING_DOWN_FACTOR || input < 1)\r\nreturn -EINVAL;\r\nod_tuners->sampling_down_factor = input;\r\nfor_each_online_cpu(j) {\r\nstruct od_cpu_dbs_info_s *dbs_info = &per_cpu(od_cpu_dbs_info,\r\nj);\r\ndbs_info->rate_mult = 1;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t store_ignore_nice_load(struct dbs_data *dbs_data,\r\nconst char *buf, size_t count)\r\n{\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nunsigned int input;\r\nint ret;\r\nunsigned int j;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nif (input > 1)\r\ninput = 1;\r\nif (input == od_tuners->ignore_nice_load) {\r\nreturn count;\r\n}\r\nod_tuners->ignore_nice_load = input;\r\nfor_each_online_cpu(j) {\r\nstruct od_cpu_dbs_info_s *dbs_info;\r\ndbs_info = &per_cpu(od_cpu_dbs_info, j);\r\ndbs_info->cdbs.prev_cpu_idle = get_cpu_idle_time(j,\r\n&dbs_info->cdbs.prev_cpu_wall, od_tuners->io_is_busy);\r\nif (od_tuners->ignore_nice_load)\r\ndbs_info->cdbs.prev_cpu_nice =\r\nkcpustat_cpu(j).cpustat[CPUTIME_NICE];\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t store_powersave_bias(struct dbs_data *dbs_data, const char *buf,\r\nsize_t count)\r\n{\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nunsigned int input;\r\nint ret;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nif (input > 1000)\r\ninput = 1000;\r\nod_tuners->powersave_bias = input;\r\nondemand_powersave_bias_init();\r\nreturn count;\r\n}\r\nstatic int od_init(struct dbs_data *dbs_data)\r\n{\r\nstruct od_dbs_tuners *tuners;\r\nu64 idle_time;\r\nint cpu;\r\ntuners = kzalloc(sizeof(*tuners), GFP_KERNEL);\r\nif (!tuners) {\r\npr_err("%s: kzalloc failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ncpu = get_cpu();\r\nidle_time = get_cpu_idle_time_us(cpu, NULL);\r\nput_cpu();\r\nif (idle_time != -1ULL) {\r\ntuners->up_threshold = MICRO_FREQUENCY_UP_THRESHOLD;\r\ndbs_data->min_sampling_rate = MICRO_FREQUENCY_MIN_SAMPLE_RATE;\r\n} else {\r\ntuners->up_threshold = DEF_FREQUENCY_UP_THRESHOLD;\r\ndbs_data->min_sampling_rate = MIN_SAMPLING_RATE_RATIO *\r\njiffies_to_usecs(10);\r\n}\r\ntuners->sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR;\r\ntuners->ignore_nice_load = 0;\r\ntuners->powersave_bias = default_powersave_bias;\r\ntuners->io_is_busy = should_io_be_busy();\r\ndbs_data->tuners = tuners;\r\nmutex_init(&dbs_data->mutex);\r\nreturn 0;\r\n}\r\nstatic void od_exit(struct dbs_data *dbs_data)\r\n{\r\nkfree(dbs_data->tuners);\r\n}\r\nstatic void od_set_powersave_bias(unsigned int powersave_bias)\r\n{\r\nstruct cpufreq_policy *policy;\r\nstruct dbs_data *dbs_data;\r\nstruct od_dbs_tuners *od_tuners;\r\nunsigned int cpu;\r\ncpumask_t done;\r\ndefault_powersave_bias = powersave_bias;\r\ncpumask_clear(&done);\r\nget_online_cpus();\r\nfor_each_online_cpu(cpu) {\r\nif (cpumask_test_cpu(cpu, &done))\r\ncontinue;\r\npolicy = per_cpu(od_cpu_dbs_info, cpu).cdbs.cur_policy;\r\nif (!policy)\r\ncontinue;\r\ncpumask_or(&done, &done, policy->cpus);\r\nif (policy->governor != &cpufreq_gov_ondemand)\r\ncontinue;\r\ndbs_data = policy->governor_data;\r\nod_tuners = dbs_data->tuners;\r\nod_tuners->powersave_bias = default_powersave_bias;\r\n}\r\nput_online_cpus();\r\n}\r\nvoid od_unregister_powersave_bias_handler(void)\r\n{\r\nod_ops.powersave_bias_target = generic_powersave_bias_target;\r\nod_set_powersave_bias(0);\r\n}\r\nstatic int od_cpufreq_governor_dbs(struct cpufreq_policy *policy,\r\nunsigned int event)\r\n{\r\nreturn cpufreq_governor_dbs(policy, &od_dbs_cdata, event);\r\n}\r\nstatic int __init cpufreq_gov_dbs_init(void)\r\n{\r\nreturn cpufreq_register_governor(&cpufreq_gov_ondemand);\r\n}\r\nstatic void __exit cpufreq_gov_dbs_exit(void)\r\n{\r\ncpufreq_unregister_governor(&cpufreq_gov_ondemand);\r\n}
