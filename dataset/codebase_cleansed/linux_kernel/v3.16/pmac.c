static int snd_pmac_dbdma_alloc(struct snd_pmac *chip, struct pmac_dbdma *rec, int size)\r\n{\r\nunsigned int rsize = sizeof(struct dbdma_cmd) * (size + 1);\r\nrec->space = dma_alloc_coherent(&chip->pdev->dev, rsize,\r\n&rec->dma_base, GFP_KERNEL);\r\nif (rec->space == NULL)\r\nreturn -ENOMEM;\r\nrec->size = size;\r\nmemset(rec->space, 0, rsize);\r\nrec->cmds = (void __iomem *)DBDMA_ALIGN(rec->space);\r\nrec->addr = rec->dma_base + (unsigned long)((char *)rec->cmds - (char *)rec->space);\r\nreturn 0;\r\n}\r\nstatic void snd_pmac_dbdma_free(struct snd_pmac *chip, struct pmac_dbdma *rec)\r\n{\r\nif (rec->space) {\r\nunsigned int rsize = sizeof(struct dbdma_cmd) * (rec->size + 1);\r\ndma_free_coherent(&chip->pdev->dev, rsize, rec->space, rec->dma_base);\r\n}\r\n}\r\nunsigned int snd_pmac_rate_index(struct snd_pmac *chip, struct pmac_stream *rec, unsigned int rate)\r\n{\r\nint i, ok, found;\r\nok = rec->cur_freqs;\r\nif (rate > chip->freq_table[0])\r\nreturn 0;\r\nfound = 0;\r\nfor (i = 0; i < chip->num_freqs; i++, ok >>= 1) {\r\nif (! (ok & 1)) continue;\r\nfound = i;\r\nif (rate >= chip->freq_table[i])\r\nbreak;\r\n}\r\nreturn found;\r\n}\r\nstatic inline int another_stream(int stream)\r\n{\r\nreturn (stream == SNDRV_PCM_STREAM_PLAYBACK) ?\r\nSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\r\n}\r\nstatic int snd_pmac_pcm_hw_params(struct snd_pcm_substream *subs,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_pmac_pcm_hw_free(struct snd_pcm_substream *subs)\r\n{\r\nsnd_pcm_lib_free_pages(subs);\r\nreturn 0;\r\n}\r\nstatic struct pmac_stream *snd_pmac_get_stream(struct snd_pmac *chip, int stream)\r\n{\r\nswitch (stream) {\r\ncase SNDRV_PCM_STREAM_PLAYBACK:\r\nreturn &chip->playback;\r\ncase SNDRV_PCM_STREAM_CAPTURE:\r\nreturn &chip->capture;\r\ndefault:\r\nsnd_BUG();\r\nreturn NULL;\r\n}\r\n}\r\nstatic inline void\r\nsnd_pmac_wait_ack(struct pmac_stream *rec)\r\n{\r\nint timeout = 50000;\r\nwhile ((in_le32(&rec->dma->status) & RUN) && timeout-- > 0)\r\nudelay(1);\r\n}\r\nstatic void snd_pmac_pcm_set_format(struct snd_pmac *chip)\r\n{\r\nout_le32(&chip->awacs->control, chip->control_mask | (chip->rate_index << 8));\r\nout_le32(&chip->awacs->byteswap, chip->format == SNDRV_PCM_FORMAT_S16_LE ? 1 : 0);\r\nif (chip->set_format)\r\nchip->set_format(chip);\r\n}\r\nstatic inline void snd_pmac_dma_stop(struct pmac_stream *rec)\r\n{\r\nout_le32(&rec->dma->control, (RUN|WAKE|FLUSH|PAUSE) << 16);\r\nsnd_pmac_wait_ack(rec);\r\n}\r\nstatic inline void snd_pmac_dma_set_command(struct pmac_stream *rec, struct pmac_dbdma *cmd)\r\n{\r\nout_le32(&rec->dma->cmdptr, cmd->addr);\r\n}\r\nstatic inline void snd_pmac_dma_run(struct pmac_stream *rec, int status)\r\n{\r\nout_le32(&rec->dma->control, status | (status << 16));\r\n}\r\nstatic int snd_pmac_pcm_prepare(struct snd_pmac *chip, struct pmac_stream *rec, struct snd_pcm_substream *subs)\r\n{\r\nint i;\r\nvolatile struct dbdma_cmd __iomem *cp;\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nint rate_index;\r\nlong offset;\r\nstruct pmac_stream *astr;\r\nrec->dma_size = snd_pcm_lib_buffer_bytes(subs);\r\nrec->period_size = snd_pcm_lib_period_bytes(subs);\r\nrec->nperiods = rec->dma_size / rec->period_size;\r\nrec->cur_period = 0;\r\nrate_index = snd_pmac_rate_index(chip, rec, runtime->rate);\r\nastr = snd_pmac_get_stream(chip, another_stream(rec->stream));\r\nif (! astr)\r\nreturn -EINVAL;\r\nastr->cur_freqs = 1 << rate_index;\r\nastr->cur_formats = 1 << runtime->format;\r\nchip->rate_index = rate_index;\r\nchip->format = runtime->format;\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_pmac_dma_stop(rec);\r\nst_le16(&chip->extra_dma.cmds->command, DBDMA_STOP);\r\nsnd_pmac_dma_set_command(rec, &chip->extra_dma);\r\nsnd_pmac_dma_run(rec, RUN);\r\nspin_unlock_irq(&chip->reg_lock);\r\nmdelay(5);\r\nspin_lock_irq(&chip->reg_lock);\r\noffset = runtime->dma_addr;\r\nfor (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++) {\r\nst_le32(&cp->phy_addr, offset);\r\nst_le16(&cp->req_count, rec->period_size);\r\nst_le16(&cp->xfer_status, 0);\r\noffset += rec->period_size;\r\n}\r\nst_le16(&cp->command, DBDMA_NOP + BR_ALWAYS);\r\nst_le32(&cp->cmd_dep, rec->cmd.addr);\r\nsnd_pmac_dma_stop(rec);\r\nsnd_pmac_dma_set_command(rec, &rec->cmd);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_pcm_trigger(struct snd_pmac *chip, struct pmac_stream *rec,\r\nstruct snd_pcm_substream *subs, int cmd)\r\n{\r\nvolatile struct dbdma_cmd __iomem *cp;\r\nint i, command;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (rec->running)\r\nreturn -EBUSY;\r\ncommand = (subs->stream == SNDRV_PCM_STREAM_PLAYBACK ?\r\nOUTPUT_MORE : INPUT_MORE) + INTR_ALWAYS;\r\nspin_lock(&chip->reg_lock);\r\nsnd_pmac_beep_stop(chip);\r\nsnd_pmac_pcm_set_format(chip);\r\nfor (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++)\r\nout_le16(&cp->command, command);\r\nsnd_pmac_dma_set_command(rec, &rec->cmd);\r\n(void)in_le32(&rec->dma->status);\r\nsnd_pmac_dma_run(rec, RUN|WAKE);\r\nrec->running = 1;\r\nspin_unlock(&chip->reg_lock);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nspin_lock(&chip->reg_lock);\r\nrec->running = 0;\r\nsnd_pmac_dma_stop(rec);\r\nfor (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++)\r\nout_le16(&cp->command, DBDMA_STOP);\r\nspin_unlock(&chip->reg_lock);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\ninline\r\nstatic snd_pcm_uframes_t snd_pmac_pcm_pointer(struct snd_pmac *chip,\r\nstruct pmac_stream *rec,\r\nstruct snd_pcm_substream *subs)\r\n{\r\nint count = 0;\r\n#if 1\r\nint stat;\r\nvolatile struct dbdma_cmd __iomem *cp = &rec->cmd.cmds[rec->cur_period];\r\nstat = ld_le16(&cp->xfer_status);\r\nif (stat & (ACTIVE|DEAD)) {\r\ncount = in_le16(&cp->res_count);\r\nif (count)\r\ncount = rec->period_size - count;\r\n}\r\n#endif\r\ncount += rec->cur_period * rec->period_size;\r\nreturn bytes_to_frames(subs->runtime, count);\r\n}\r\nstatic int snd_pmac_playback_prepare(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\r\nreturn snd_pmac_pcm_prepare(chip, &chip->playback, subs);\r\n}\r\nstatic int snd_pmac_playback_trigger(struct snd_pcm_substream *subs,\r\nint cmd)\r\n{\r\nstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\r\nreturn snd_pmac_pcm_trigger(chip, &chip->playback, subs, cmd);\r\n}\r\nstatic snd_pcm_uframes_t snd_pmac_playback_pointer(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\r\nreturn snd_pmac_pcm_pointer(chip, &chip->playback, subs);\r\n}\r\nstatic int snd_pmac_capture_prepare(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\r\nreturn snd_pmac_pcm_prepare(chip, &chip->capture, subs);\r\n}\r\nstatic int snd_pmac_capture_trigger(struct snd_pcm_substream *subs,\r\nint cmd)\r\n{\r\nstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\r\nreturn snd_pmac_pcm_trigger(chip, &chip->capture, subs, cmd);\r\n}\r\nstatic snd_pcm_uframes_t snd_pmac_capture_pointer(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\r\nreturn snd_pmac_pcm_pointer(chip, &chip->capture, subs);\r\n}\r\nstatic inline void snd_pmac_pcm_dead_xfer(struct pmac_stream *rec,\r\nvolatile struct dbdma_cmd __iomem *cp)\r\n{\r\nunsigned short req, res ;\r\nunsigned int phy ;\r\n(void)in_le32(&rec->dma->status);\r\nout_le32(&rec->dma->control, (RUN|PAUSE|FLUSH|WAKE) << 16);\r\nif (!emergency_in_use) {\r\nmemcpy((void *)emergency_dbdma.cmds, (void *)cp,\r\nsizeof(struct dbdma_cmd));\r\nemergency_in_use = 1;\r\nst_le16(&cp->xfer_status, 0);\r\nst_le16(&cp->req_count, rec->period_size);\r\ncp = emergency_dbdma.cmds;\r\n}\r\nreq = ld_le16(&cp->req_count);\r\nres = ld_le16(&cp->res_count);\r\nphy = ld_le32(&cp->phy_addr);\r\nphy += (req - res);\r\nst_le16(&cp->req_count, res);\r\nst_le16(&cp->res_count, 0);\r\nst_le16(&cp->xfer_status, 0);\r\nst_le32(&cp->phy_addr, phy);\r\nst_le32(&cp->cmd_dep, rec->cmd.addr\r\n+ sizeof(struct dbdma_cmd)*((rec->cur_period+1)%rec->nperiods));\r\nst_le16(&cp->command, OUTPUT_MORE | BR_ALWAYS | INTR_ALWAYS);\r\nout_le32(&rec->dma->cmdptr, emergency_dbdma.addr);\r\n(void)in_le32(&rec->dma->status);\r\nout_le32(&rec->dma->control, ((RUN|WAKE) << 16) + (RUN|WAKE));\r\n}\r\nstatic void snd_pmac_pcm_update(struct snd_pmac *chip, struct pmac_stream *rec)\r\n{\r\nvolatile struct dbdma_cmd __iomem *cp;\r\nint c;\r\nint stat;\r\nspin_lock(&chip->reg_lock);\r\nif (rec->running) {\r\nfor (c = 0; c < rec->nperiods; c++) {\r\nif (emergency_in_use)\r\ncp = emergency_dbdma.cmds;\r\nelse\r\ncp = &rec->cmd.cmds[rec->cur_period];\r\nstat = ld_le16(&cp->xfer_status);\r\nif (stat & DEAD) {\r\nsnd_pmac_pcm_dead_xfer(rec, cp);\r\nbreak;\r\n}\r\nif (emergency_in_use)\r\nemergency_in_use = 0 ;\r\nif (! (stat & ACTIVE))\r\nbreak;\r\nst_le16(&cp->xfer_status, 0);\r\nst_le16(&cp->req_count, rec->period_size);\r\nrec->cur_period++;\r\nif (rec->cur_period >= rec->nperiods) {\r\nrec->cur_period = 0;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(rec->substream);\r\nspin_lock(&chip->reg_lock);\r\n}\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n}\r\nstatic int snd_pmac_pcm_open(struct snd_pmac *chip, struct pmac_stream *rec,\r\nstruct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nint i;\r\nruntime->hw.rates = 0;\r\nfor (i = 0; i < chip->num_freqs; i++)\r\nif (chip->freqs_ok & (1 << i))\r\nruntime->hw.rates |=\r\nsnd_pcm_rate_to_rate_bit(chip->freq_table[i]);\r\nfor (i = 0; i < chip->num_freqs; i++) {\r\nif (chip->freqs_ok & (1 << i)) {\r\nruntime->hw.rate_max = chip->freq_table[i];\r\nbreak;\r\n}\r\n}\r\nfor (i = chip->num_freqs - 1; i >= 0; i--) {\r\nif (chip->freqs_ok & (1 << i)) {\r\nruntime->hw.rate_min = chip->freq_table[i];\r\nbreak;\r\n}\r\n}\r\nruntime->hw.formats = chip->formats_ok;\r\nif (chip->can_capture) {\r\nif (! chip->can_duplex)\r\nruntime->hw.info |= SNDRV_PCM_INFO_HALF_DUPLEX;\r\nruntime->hw.info |= SNDRV_PCM_INFO_JOINT_DUPLEX;\r\n}\r\nruntime->private_data = rec;\r\nrec->substream = subs;\r\n#if 0\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_pmac_hw_rule_rate, chip, rec->stream, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,\r\nsnd_pmac_hw_rule_format, chip, rec->stream, -1);\r\n#endif\r\nruntime->hw.periods_max = rec->cmd.size - 1;\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_pcm_close(struct snd_pmac *chip, struct pmac_stream *rec,\r\nstruct snd_pcm_substream *subs)\r\n{\r\nstruct pmac_stream *astr;\r\nsnd_pmac_dma_stop(rec);\r\nastr = snd_pmac_get_stream(chip, another_stream(rec->stream));\r\nif (! astr)\r\nreturn -EINVAL;\r\nastr->cur_freqs = chip->freqs_ok;\r\nastr->cur_formats = chip->formats_ok;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_playback_open(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\r\nsubs->runtime->hw = snd_pmac_playback;\r\nreturn snd_pmac_pcm_open(chip, &chip->playback, subs);\r\n}\r\nstatic int snd_pmac_capture_open(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\r\nsubs->runtime->hw = snd_pmac_capture;\r\nreturn snd_pmac_pcm_open(chip, &chip->capture, subs);\r\n}\r\nstatic int snd_pmac_playback_close(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\r\nreturn snd_pmac_pcm_close(chip, &chip->playback, subs);\r\n}\r\nstatic int snd_pmac_capture_close(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\r\nreturn snd_pmac_pcm_close(chip, &chip->capture, subs);\r\n}\r\nint snd_pmac_pcm_new(struct snd_pmac *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nint num_captures = 1;\r\nif (! chip->can_capture)\r\nnum_captures = 0;\r\nerr = snd_pcm_new(chip->card, chip->card->driver, 0, 1, num_captures, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_pmac_playback_ops);\r\nif (chip->can_capture)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_pmac_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcm = pcm;\r\nchip->formats_ok = SNDRV_PCM_FMTBIT_S16_BE;\r\nif (chip->can_byte_swap)\r\nchip->formats_ok |= SNDRV_PCM_FMTBIT_S16_LE;\r\nchip->playback.cur_formats = chip->formats_ok;\r\nchip->capture.cur_formats = chip->formats_ok;\r\nchip->playback.cur_freqs = chip->freqs_ok;\r\nchip->capture.cur_freqs = chip->freqs_ok;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\n&chip->pdev->dev,\r\n64 * 1024, 64 * 1024);\r\nreturn 0;\r\n}\r\nstatic void snd_pmac_dbdma_reset(struct snd_pmac *chip)\r\n{\r\nout_le32(&chip->playback.dma->control, (RUN|PAUSE|FLUSH|WAKE|DEAD) << 16);\r\nsnd_pmac_wait_ack(&chip->playback);\r\nout_le32(&chip->capture.dma->control, (RUN|PAUSE|FLUSH|WAKE|DEAD) << 16);\r\nsnd_pmac_wait_ack(&chip->capture);\r\n}\r\nvoid snd_pmac_beep_dma_start(struct snd_pmac *chip, int bytes, unsigned long addr, int speed)\r\n{\r\nstruct pmac_stream *rec = &chip->playback;\r\nsnd_pmac_dma_stop(rec);\r\nst_le16(&chip->extra_dma.cmds->req_count, bytes);\r\nst_le16(&chip->extra_dma.cmds->xfer_status, 0);\r\nst_le32(&chip->extra_dma.cmds->cmd_dep, chip->extra_dma.addr);\r\nst_le32(&chip->extra_dma.cmds->phy_addr, addr);\r\nst_le16(&chip->extra_dma.cmds->command, OUTPUT_MORE + BR_ALWAYS);\r\nout_le32(&chip->awacs->control,\r\n(in_le32(&chip->awacs->control) & ~0x1f00)\r\n| (speed << 8));\r\nout_le32(&chip->awacs->byteswap, 0);\r\nsnd_pmac_dma_set_command(rec, &chip->extra_dma);\r\nsnd_pmac_dma_run(rec, RUN);\r\n}\r\nvoid snd_pmac_beep_dma_stop(struct snd_pmac *chip)\r\n{\r\nsnd_pmac_dma_stop(&chip->playback);\r\nst_le16(&chip->extra_dma.cmds->command, DBDMA_STOP);\r\nsnd_pmac_pcm_set_format(chip);\r\n}\r\nstatic irqreturn_t\r\nsnd_pmac_tx_intr(int irq, void *devid)\r\n{\r\nstruct snd_pmac *chip = devid;\r\nsnd_pmac_pcm_update(chip, &chip->playback);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nsnd_pmac_rx_intr(int irq, void *devid)\r\n{\r\nstruct snd_pmac *chip = devid;\r\nsnd_pmac_pcm_update(chip, &chip->capture);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nsnd_pmac_ctrl_intr(int irq, void *devid)\r\n{\r\nstruct snd_pmac *chip = devid;\r\nint ctrl = in_le32(&chip->awacs->control);\r\nif (ctrl & MASK_PORTCHG) {\r\nif (chip->update_automute)\r\nchip->update_automute(chip, 1);\r\n}\r\nif (ctrl & MASK_CNTLERR) {\r\nint err = (in_le32(&chip->awacs->codec_stat) & MASK_ERRCODE) >> 16;\r\nif (err && chip->model <= PMAC_SCREAMER)\r\nsnd_printk(KERN_DEBUG "error %x\n", err);\r\n}\r\nout_le32(&chip->awacs->control, ctrl);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void snd_pmac_sound_feature(struct snd_pmac *chip, int enable)\r\n{\r\nif (ppc_md.feature_call)\r\nppc_md.feature_call(PMAC_FTR_SOUND_CHIP_ENABLE, chip->node, 0, enable);\r\n}\r\nstatic int snd_pmac_free(struct snd_pmac *chip)\r\n{\r\nif (chip->initialized) {\r\nsnd_pmac_dbdma_reset(chip);\r\nout_le32(&chip->awacs->control, in_le32(&chip->awacs->control) & 0xfff);\r\n}\r\nif (chip->node)\r\nsnd_pmac_sound_feature(chip, 0);\r\nif (chip->mixer_free)\r\nchip->mixer_free(chip);\r\nsnd_pmac_detach_beep(chip);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, (void*)chip);\r\nif (chip->tx_irq >= 0)\r\nfree_irq(chip->tx_irq, (void*)chip);\r\nif (chip->rx_irq >= 0)\r\nfree_irq(chip->rx_irq, (void*)chip);\r\nsnd_pmac_dbdma_free(chip, &chip->playback.cmd);\r\nsnd_pmac_dbdma_free(chip, &chip->capture.cmd);\r\nsnd_pmac_dbdma_free(chip, &chip->extra_dma);\r\nsnd_pmac_dbdma_free(chip, &emergency_dbdma);\r\nif (chip->macio_base)\r\niounmap(chip->macio_base);\r\nif (chip->latch_base)\r\niounmap(chip->latch_base);\r\nif (chip->awacs)\r\niounmap(chip->awacs);\r\nif (chip->playback.dma)\r\niounmap(chip->playback.dma);\r\nif (chip->capture.dma)\r\niounmap(chip->capture.dma);\r\nif (chip->node) {\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nif (chip->requested & (1 << i))\r\nrelease_mem_region(chip->rsrc[i].start,\r\nresource_size(&chip->rsrc[i]));\r\n}\r\n}\r\nif (chip->pdev)\r\npci_dev_put(chip->pdev);\r\nof_node_put(chip->node);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_pmac *chip = device->device_data;\r\nreturn snd_pmac_free(chip);\r\n}\r\nstatic void detect_byte_swap(struct snd_pmac *chip)\r\n{\r\nstruct device_node *mio;\r\nfor (mio = chip->node->parent; mio; mio = mio->parent) {\r\nif (strcmp(mio->name, "mac-io") == 0) {\r\nif (of_device_is_compatible(mio, "Keylargo"))\r\nchip->can_byte_swap = 0;\r\nbreak;\r\n}\r\n}\r\nif (of_machine_is_compatible("PowerBook3,1") ||\r\nof_machine_is_compatible("PowerBook2,1"))\r\nchip->can_byte_swap = 0 ;\r\nif (of_machine_is_compatible("PowerBook2,1"))\r\nchip->can_duplex = 0;\r\n}\r\nstatic int snd_pmac_detect(struct snd_pmac *chip)\r\n{\r\nstruct device_node *sound;\r\nstruct device_node *dn;\r\nconst unsigned int *prop;\r\nunsigned int l;\r\nstruct macio_chip* macio;\r\nif (!machine_is(powermac))\r\nreturn -ENODEV;\r\nchip->subframe = 0;\r\nchip->revision = 0;\r\nchip->freqs_ok = 0xff;\r\nchip->model = PMAC_AWACS;\r\nchip->can_byte_swap = 1;\r\nchip->can_duplex = 1;\r\nchip->can_capture = 1;\r\nchip->num_freqs = ARRAY_SIZE(awacs_freqs);\r\nchip->freq_table = awacs_freqs;\r\nchip->pdev = NULL;\r\nchip->control_mask = MASK_IEPC | MASK_IEE | 0x11;\r\nif (of_machine_is_compatible("AAPL,3400/2400")\r\n|| of_machine_is_compatible("AAPL,3500"))\r\nchip->is_pbook_3400 = 1;\r\nelse if (of_machine_is_compatible("PowerBook1,1")\r\n|| of_machine_is_compatible("AAPL,PowerBook1998"))\r\nchip->is_pbook_G3 = 1;\r\nchip->node = of_find_node_by_name(NULL, "awacs");\r\nsound = of_node_get(chip->node);\r\nif (!chip->node)\r\nchip->node = of_find_node_by_name(NULL, "davbus");\r\nif (! chip->node) {\r\nchip->node = of_find_node_by_name(NULL, "i2s-a");\r\nif (chip->node && chip->node->parent &&\r\nchip->node->parent->parent) {\r\nif (of_device_is_compatible(chip->node->parent->parent,\r\n"K2-Keylargo"))\r\nchip->is_k2 = 1;\r\n}\r\n}\r\nif (! chip->node)\r\nreturn -ENODEV;\r\nif (!sound) {\r\nsound = of_find_node_by_name(NULL, "sound");\r\nwhile (sound && sound->parent != chip->node)\r\nsound = of_find_node_by_name(sound, "sound");\r\n}\r\nif (! sound) {\r\nof_node_put(chip->node);\r\nchip->node = NULL;\r\nreturn -ENODEV;\r\n}\r\nprop = of_get_property(sound, "sub-frame", NULL);\r\nif (prop && *prop < 16)\r\nchip->subframe = *prop;\r\nprop = of_get_property(sound, "layout-id", NULL);\r\nif (prop) {\r\nprintk(KERN_INFO "snd-powermac no longer handles any "\r\n"machines with a layout-id property "\r\n"in the device-tree, use snd-aoa.\n");\r\nof_node_put(sound);\r\nof_node_put(chip->node);\r\nchip->node = NULL;\r\nreturn -ENODEV;\r\n}\r\nif (of_device_is_compatible(sound, "screamer")) {\r\nchip->model = PMAC_SCREAMER;\r\n}\r\nif (of_device_is_compatible(sound, "burgundy")) {\r\nchip->model = PMAC_BURGUNDY;\r\nchip->control_mask = MASK_IEPC | 0x11;\r\n}\r\nif (of_device_is_compatible(sound, "daca")) {\r\nchip->model = PMAC_DACA;\r\nchip->can_capture = 0;\r\nchip->can_duplex = 0;\r\nchip->control_mask = MASK_IEPC | 0x11;\r\n}\r\nif (of_device_is_compatible(sound, "tumbler")) {\r\nchip->model = PMAC_TUMBLER;\r\nchip->can_capture = of_machine_is_compatible("PowerMac4,2")\r\n|| of_machine_is_compatible("PowerBook3,2")\r\n|| of_machine_is_compatible("PowerBook3,3")\r\n|| of_machine_is_compatible("PowerBook4,1")\r\n|| of_machine_is_compatible("PowerBook4,2")\r\n|| of_machine_is_compatible("PowerBook4,3");\r\nchip->can_duplex = 0;\r\nchip->num_freqs = ARRAY_SIZE(tumbler_freqs);\r\nchip->freq_table = tumbler_freqs;\r\nchip->control_mask = MASK_IEPC | 0x11;\r\n}\r\nif (of_device_is_compatible(sound, "snapper")) {\r\nchip->model = PMAC_SNAPPER;\r\nchip->num_freqs = ARRAY_SIZE(tumbler_freqs);\r\nchip->freq_table = tumbler_freqs;\r\nchip->control_mask = MASK_IEPC | 0x11;\r\n}\r\nprop = of_get_property(sound, "device-id", NULL);\r\nif (prop)\r\nchip->device_id = *prop;\r\ndn = of_find_node_by_name(NULL, "perch");\r\nchip->has_iic = (dn != NULL);\r\nof_node_put(dn);\r\nmacio = macio_find(chip->node, macio_unknown);\r\nif (macio == NULL)\r\nprintk(KERN_WARNING "snd-powermac: can't locate macio !\n");\r\nelse {\r\nstruct pci_dev *pdev = NULL;\r\nfor_each_pci_dev(pdev) {\r\nstruct device_node *np = pci_device_to_OF_node(pdev);\r\nif (np && np == macio->of_node) {\r\nchip->pdev = pdev;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (chip->pdev == NULL)\r\nprintk(KERN_WARNING "snd-powermac: can't locate macio PCI"\r\n" device !\n");\r\ndetect_byte_swap(chip);\r\nprop = of_get_property(sound, "sample-rates", &l);\r\nif (! prop)\r\nprop = of_get_property(sound, "output-frame-rates", &l);\r\nif (prop) {\r\nint i;\r\nchip->freqs_ok = 0;\r\nfor (l /= sizeof(int); l > 0; --l) {\r\nunsigned int r = *prop++;\r\nif (r >= 0x10000)\r\nr >>= 16;\r\nfor (i = 0; i < chip->num_freqs; ++i) {\r\nif (r == chip->freq_table[i]) {\r\nchip->freqs_ok |= (1 << i);\r\nbreak;\r\n}\r\n}\r\n}\r\n} else {\r\nchip->freqs_ok = 1;\r\n}\r\nof_node_put(sound);\r\nreturn 0;\r\n}\r\nstatic int pmac_auto_mute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = chip->auto_mute;\r\nreturn 0;\r\n}\r\nstatic int pmac_auto_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.integer.value[0] != chip->auto_mute) {\r\nchip->auto_mute = !!ucontrol->value.integer.value[0];\r\nif (chip->update_automute)\r\nchip->update_automute(chip, 1);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmac_hp_detect_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nif (chip->detect_headphone)\r\nucontrol->value.integer.value[0] = chip->detect_headphone(chip);\r\nelse\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nint snd_pmac_add_automute(struct snd_pmac *chip)\r\n{\r\nint err;\r\nchip->auto_mute = 1;\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&auto_mute_controls[0], chip));\r\nif (err < 0) {\r\nprintk(KERN_ERR "snd-powermac: Failed to add automute control\n");\r\nreturn err;\r\n}\r\nchip->hp_detect_ctl = snd_ctl_new1(&auto_mute_controls[1], chip);\r\nreturn snd_ctl_add(chip->card, chip->hp_detect_ctl);\r\n}\r\nint snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)\r\n{\r\nstruct snd_pmac *chip;\r\nstruct device_node *np;\r\nint i, err;\r\nunsigned int irq;\r\nunsigned long ctrl_addr, txdma_addr, rxdma_addr;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_pmac_dev_free,\r\n};\r\n*chip_return = NULL;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->card = card;\r\nspin_lock_init(&chip->reg_lock);\r\nchip->irq = chip->tx_irq = chip->rx_irq = -1;\r\nchip->playback.stream = SNDRV_PCM_STREAM_PLAYBACK;\r\nchip->capture.stream = SNDRV_PCM_STREAM_CAPTURE;\r\nif ((err = snd_pmac_detect(chip)) < 0)\r\ngoto __error;\r\nif (snd_pmac_dbdma_alloc(chip, &chip->playback.cmd, PMAC_MAX_FRAGS + 1) < 0 ||\r\nsnd_pmac_dbdma_alloc(chip, &chip->capture.cmd, PMAC_MAX_FRAGS + 1) < 0 ||\r\nsnd_pmac_dbdma_alloc(chip, &chip->extra_dma, 2) < 0 ||\r\nsnd_pmac_dbdma_alloc(chip, &emergency_dbdma, 2) < 0) {\r\nerr = -ENOMEM;\r\ngoto __error;\r\n}\r\nnp = chip->node;\r\nchip->requested = 0;\r\nif (chip->is_k2) {\r\nstatic char *rnames[] = {\r\n"Sound Control", "Sound DMA" };\r\nfor (i = 0; i < 2; i ++) {\r\nif (of_address_to_resource(np->parent, i,\r\n&chip->rsrc[i])) {\r\nprintk(KERN_ERR "snd: can't translate rsrc "\r\n" %d (%s)\n", i, rnames[i]);\r\nerr = -ENODEV;\r\ngoto __error;\r\n}\r\nif (request_mem_region(chip->rsrc[i].start,\r\nresource_size(&chip->rsrc[i]),\r\nrnames[i]) == NULL) {\r\nprintk(KERN_ERR "snd: can't request rsrc "\r\n" %d (%s: %pR)\n",\r\ni, rnames[i], &chip->rsrc[i]);\r\nerr = -ENODEV;\r\ngoto __error;\r\n}\r\nchip->requested |= (1 << i);\r\n}\r\nctrl_addr = chip->rsrc[0].start;\r\ntxdma_addr = chip->rsrc[1].start;\r\nrxdma_addr = txdma_addr + 0x100;\r\n} else {\r\nstatic char *rnames[] = {\r\n"Sound Control", "Sound Tx DMA", "Sound Rx DMA" };\r\nfor (i = 0; i < 3; i ++) {\r\nif (of_address_to_resource(np, i,\r\n&chip->rsrc[i])) {\r\nprintk(KERN_ERR "snd: can't translate rsrc "\r\n" %d (%s)\n", i, rnames[i]);\r\nerr = -ENODEV;\r\ngoto __error;\r\n}\r\nif (request_mem_region(chip->rsrc[i].start,\r\nresource_size(&chip->rsrc[i]),\r\nrnames[i]) == NULL) {\r\nprintk(KERN_ERR "snd: can't request rsrc "\r\n" %d (%s: %pR)\n",\r\ni, rnames[i], &chip->rsrc[i]);\r\nerr = -ENODEV;\r\ngoto __error;\r\n}\r\nchip->requested |= (1 << i);\r\n}\r\nctrl_addr = chip->rsrc[0].start;\r\ntxdma_addr = chip->rsrc[1].start;\r\nrxdma_addr = chip->rsrc[2].start;\r\n}\r\nchip->awacs = ioremap(ctrl_addr, 0x1000);\r\nchip->playback.dma = ioremap(txdma_addr, 0x100);\r\nchip->capture.dma = ioremap(rxdma_addr, 0x100);\r\nif (chip->model <= PMAC_BURGUNDY) {\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (request_irq(irq, snd_pmac_ctrl_intr, 0,\r\n"PMac", (void*)chip)) {\r\nsnd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n",\r\nirq);\r\nerr = -EBUSY;\r\ngoto __error;\r\n}\r\nchip->irq = irq;\r\n}\r\nirq = irq_of_parse_and_map(np, 1);\r\nif (request_irq(irq, snd_pmac_tx_intr, 0, "PMac Output", (void*)chip)){\r\nsnd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", irq);\r\nerr = -EBUSY;\r\ngoto __error;\r\n}\r\nchip->tx_irq = irq;\r\nirq = irq_of_parse_and_map(np, 2);\r\nif (request_irq(irq, snd_pmac_rx_intr, 0, "PMac Input", (void*)chip)) {\r\nsnd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", irq);\r\nerr = -EBUSY;\r\ngoto __error;\r\n}\r\nchip->rx_irq = irq;\r\nsnd_pmac_sound_feature(chip, 1);\r\nif (chip->model <= PMAC_BURGUNDY)\r\nout_le32(&chip->awacs->control, chip->control_mask);\r\nif (chip->is_pbook_3400) {\r\nchip->latch_base = ioremap (0xf301a000, 0x1000);\r\nin_8(chip->latch_base + 0x190);\r\n} else if (chip->is_pbook_G3) {\r\nstruct device_node* mio;\r\nfor (mio = chip->node->parent; mio; mio = mio->parent) {\r\nif (strcmp(mio->name, "mac-io") == 0) {\r\nstruct resource r;\r\nif (of_address_to_resource(mio, 0, &r) == 0)\r\nchip->macio_base =\r\nioremap(r.start, 0x40);\r\nbreak;\r\n}\r\n}\r\nif (chip->macio_base)\r\nout_8(chip->macio_base + 0x37, 3);\r\n}\r\nsnd_pmac_dbdma_reset(chip);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)\r\ngoto __error;\r\n*chip_return = chip;\r\nreturn 0;\r\n__error:\r\nsnd_pmac_free(chip);\r\nreturn err;\r\n}\r\nvoid snd_pmac_suspend(struct snd_pmac *chip)\r\n{\r\nunsigned long flags;\r\nsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);\r\nif (chip->suspend)\r\nchip->suspend(chip);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_pmac_beep_stop(chip);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (chip->irq >= 0)\r\ndisable_irq(chip->irq);\r\nif (chip->tx_irq >= 0)\r\ndisable_irq(chip->tx_irq);\r\nif (chip->rx_irq >= 0)\r\ndisable_irq(chip->rx_irq);\r\nsnd_pmac_sound_feature(chip, 0);\r\n}\r\nvoid snd_pmac_resume(struct snd_pmac *chip)\r\n{\r\nsnd_pmac_sound_feature(chip, 1);\r\nif (chip->resume)\r\nchip->resume(chip);\r\nif (chip->macio_base && chip->is_pbook_G3)\r\nout_8(chip->macio_base + 0x37, 3);\r\nelse if (chip->is_pbook_3400)\r\nin_8(chip->latch_base + 0x190);\r\nsnd_pmac_pcm_set_format(chip);\r\nif (chip->irq >= 0)\r\nenable_irq(chip->irq);\r\nif (chip->tx_irq >= 0)\r\nenable_irq(chip->tx_irq);\r\nif (chip->rx_irq >= 0)\r\nenable_irq(chip->rx_irq);\r\nsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);\r\n}
