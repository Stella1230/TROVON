static void enable_tx_interrupt(struct ehv_bc_data *bc)\r\n{\r\nif (!bc->tx_irq_enabled) {\r\nenable_irq(bc->tx_irq);\r\nbc->tx_irq_enabled = 1;\r\n}\r\n}\r\nstatic void disable_tx_interrupt(struct ehv_bc_data *bc)\r\n{\r\nif (bc->tx_irq_enabled) {\r\ndisable_irq_nosync(bc->tx_irq);\r\nbc->tx_irq_enabled = 0;\r\n}\r\n}\r\nstatic int find_console_handle(void)\r\n{\r\nstruct device_node *np, *np2;\r\nconst char *sprop = NULL;\r\nconst uint32_t *iprop;\r\nnp = of_find_node_by_path("/chosen");\r\nif (np)\r\nsprop = of_get_property(np, "stdout-path", NULL);\r\nif (!np || !sprop) {\r\nof_node_put(np);\r\nnp = of_find_node_by_name(NULL, "aliases");\r\nif (np)\r\nsprop = of_get_property(np, "stdout", NULL);\r\n}\r\nif (!sprop) {\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nnp2 = of_find_node_by_path(sprop);\r\nof_node_put(np);\r\nnp = np2;\r\nif (!np) {\r\npr_warning("ehv-bc: stdout node '%s' does not exist\n", sprop);\r\nreturn 0;\r\n}\r\nif (!of_device_is_compatible(np, "epapr,hv-byte-channel")) {\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstdout_irq = irq_of_parse_and_map(np, 0);\r\nif (stdout_irq == NO_IRQ) {\r\npr_err("ehv-bc: no 'interrupts' property in %s node\n", sprop);\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\niprop = of_get_property(np, "hv-handle", NULL);\r\nif (!iprop) {\r\npr_err("ehv-bc: no 'hv-handle' property in %s node\n",\r\nnp->name);\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstdout_bc = be32_to_cpu(*iprop);\r\nof_node_put(np);\r\nreturn 1;\r\n}\r\nstatic void byte_channel_spin_send(const char data)\r\n{\r\nint ret, count;\r\ndo {\r\ncount = 1;\r\nret = ev_byte_channel_send(CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE,\r\n&count, &data);\r\n} while (ret == EV_EAGAIN);\r\n}\r\nstatic void ehv_bc_udbg_putc(char c)\r\n{\r\nif (c == '\n')\r\nbyte_channel_spin_send('\r');\r\nbyte_channel_spin_send(c);\r\n}\r\nvoid __init udbg_init_ehv_bc(void)\r\n{\r\nunsigned int rx_count, tx_count;\r\nunsigned int ret;\r\nret = ev_byte_channel_poll(CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE,\r\n&rx_count, &tx_count);\r\nif (ret)\r\nreturn;\r\nudbg_putc = ehv_bc_udbg_putc;\r\nregister_early_udbg_console();\r\nudbg_printf("ehv-bc: early console using byte channel handle %u\n",\r\nCONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE);\r\n}\r\nstatic int ehv_bc_console_byte_channel_send(unsigned int handle, const char *s,\r\nunsigned int count)\r\n{\r\nunsigned int len;\r\nint ret = 0;\r\nwhile (count) {\r\nlen = min_t(unsigned int, count, EV_BYTE_CHANNEL_MAX_BYTES);\r\ndo {\r\nret = ev_byte_channel_send(handle, &len, s);\r\n} while (ret == EV_EAGAIN);\r\ncount -= len;\r\ns += len;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ehv_bc_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nchar s2[EV_BYTE_CHANNEL_MAX_BYTES];\r\nunsigned int i, j = 0;\r\nchar c;\r\nfor (i = 0; i < count; i++) {\r\nc = *s++;\r\nif (c == '\n')\r\ns2[j++] = '\r';\r\ns2[j++] = c;\r\nif (j >= (EV_BYTE_CHANNEL_MAX_BYTES - 1)) {\r\nif (ehv_bc_console_byte_channel_send(stdout_bc, s2, j))\r\nreturn;\r\nj = 0;\r\n}\r\n}\r\nif (j)\r\nehv_bc_console_byte_channel_send(stdout_bc, s2, j);\r\n}\r\nstatic struct tty_driver *ehv_bc_console_device(struct console *co, int *index)\r\n{\r\n*index = co->index;\r\nreturn ehv_bc_driver;\r\n}\r\nstatic int __init ehv_bc_console_init(void)\r\n{\r\nif (!find_console_handle()) {\r\npr_debug("ehv-bc: stdout is not a byte channel\n");\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_PPC_EARLY_DEBUG_EHV_BC\r\nif (stdout_bc != CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE)\r\npr_warning("ehv-bc: udbg handle %u is not the stdout handle\n",\r\nCONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE);\r\n#endif\r\nadd_preferred_console(ehv_bc_console.name, ehv_bc_console.index, NULL);\r\nregister_console(&ehv_bc_console);\r\npr_info("ehv-bc: registered console driver for byte channel %u\n",\r\nstdout_bc);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ehv_bc_tty_rx_isr(int irq, void *data)\r\n{\r\nstruct ehv_bc_data *bc = data;\r\nunsigned int rx_count, tx_count, len;\r\nint count;\r\nchar buffer[EV_BYTE_CHANNEL_MAX_BYTES];\r\nint ret;\r\nev_byte_channel_poll(bc->handle, &rx_count, &tx_count);\r\ncount = tty_buffer_request_room(&bc->port, rx_count);\r\nwhile (count > 0) {\r\nlen = min_t(unsigned int, count, sizeof(buffer));\r\nev_byte_channel_receive(bc->handle, &len, buffer);\r\nret = tty_insert_flip_string(&bc->port, buffer, len);\r\nif (ret != len)\r\nbreak;\r\ncount -= len;\r\n}\r\ntty_flip_buffer_push(&bc->port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ehv_bc_tx_dequeue(struct ehv_bc_data *bc)\r\n{\r\nunsigned int count;\r\nunsigned int len, ret;\r\nunsigned long flags;\r\ndo {\r\nspin_lock_irqsave(&bc->lock, flags);\r\nlen = min_t(unsigned int,\r\nCIRC_CNT_TO_END(bc->head, bc->tail, BUF_SIZE),\r\nEV_BYTE_CHANNEL_MAX_BYTES);\r\nret = ev_byte_channel_send(bc->handle, &len, bc->buf + bc->tail);\r\nif (!ret || (ret == EV_EAGAIN))\r\nbc->tail = (bc->tail + len) & (BUF_SIZE - 1);\r\ncount = CIRC_CNT(bc->head, bc->tail, BUF_SIZE);\r\nspin_unlock_irqrestore(&bc->lock, flags);\r\n} while (count && !ret);\r\nspin_lock_irqsave(&bc->lock, flags);\r\nif (CIRC_CNT(bc->head, bc->tail, BUF_SIZE))\r\nenable_tx_interrupt(bc);\r\nelse\r\ndisable_tx_interrupt(bc);\r\nspin_unlock_irqrestore(&bc->lock, flags);\r\n}\r\nstatic irqreturn_t ehv_bc_tty_tx_isr(int irq, void *data)\r\n{\r\nstruct ehv_bc_data *bc = data;\r\nehv_bc_tx_dequeue(bc);\r\ntty_port_tty_wakeup(&bc->port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ehv_bc_tty_write(struct tty_struct *ttys, const unsigned char *s,\r\nint count)\r\n{\r\nstruct ehv_bc_data *bc = ttys->driver_data;\r\nunsigned long flags;\r\nunsigned int len;\r\nunsigned int written = 0;\r\nwhile (1) {\r\nspin_lock_irqsave(&bc->lock, flags);\r\nlen = CIRC_SPACE_TO_END(bc->head, bc->tail, BUF_SIZE);\r\nif (count < len)\r\nlen = count;\r\nif (len) {\r\nmemcpy(bc->buf + bc->head, s, len);\r\nbc->head = (bc->head + len) & (BUF_SIZE - 1);\r\n}\r\nspin_unlock_irqrestore(&bc->lock, flags);\r\nif (!len)\r\nbreak;\r\ns += len;\r\ncount -= len;\r\nwritten += len;\r\n}\r\nehv_bc_tx_dequeue(bc);\r\nreturn written;\r\n}\r\nstatic int ehv_bc_tty_open(struct tty_struct *ttys, struct file *filp)\r\n{\r\nstruct ehv_bc_data *bc = &bcs[ttys->index];\r\nif (!bc->dev)\r\nreturn -ENODEV;\r\nreturn tty_port_open(&bc->port, ttys, filp);\r\n}\r\nstatic void ehv_bc_tty_close(struct tty_struct *ttys, struct file *filp)\r\n{\r\nstruct ehv_bc_data *bc = &bcs[ttys->index];\r\nif (bc->dev)\r\ntty_port_close(&bc->port, ttys, filp);\r\n}\r\nstatic int ehv_bc_tty_write_room(struct tty_struct *ttys)\r\n{\r\nstruct ehv_bc_data *bc = ttys->driver_data;\r\nunsigned long flags;\r\nint count;\r\nspin_lock_irqsave(&bc->lock, flags);\r\ncount = CIRC_SPACE(bc->head, bc->tail, BUF_SIZE);\r\nspin_unlock_irqrestore(&bc->lock, flags);\r\nreturn count;\r\n}\r\nstatic void ehv_bc_tty_throttle(struct tty_struct *ttys)\r\n{\r\nstruct ehv_bc_data *bc = ttys->driver_data;\r\ndisable_irq(bc->rx_irq);\r\n}\r\nstatic void ehv_bc_tty_unthrottle(struct tty_struct *ttys)\r\n{\r\nstruct ehv_bc_data *bc = ttys->driver_data;\r\nenable_irq(bc->rx_irq);\r\n}\r\nstatic void ehv_bc_tty_hangup(struct tty_struct *ttys)\r\n{\r\nstruct ehv_bc_data *bc = ttys->driver_data;\r\nehv_bc_tx_dequeue(bc);\r\ntty_port_hangup(&bc->port);\r\n}\r\nstatic int ehv_bc_tty_port_activate(struct tty_port *port,\r\nstruct tty_struct *ttys)\r\n{\r\nstruct ehv_bc_data *bc = container_of(port, struct ehv_bc_data, port);\r\nint ret;\r\nttys->driver_data = bc;\r\nret = request_irq(bc->rx_irq, ehv_bc_tty_rx_isr, 0, "ehv-bc", bc);\r\nif (ret < 0) {\r\ndev_err(bc->dev, "could not request rx irq %u (ret=%i)\n",\r\nbc->rx_irq, ret);\r\nreturn ret;\r\n}\r\nbc->tx_irq_enabled = 1;\r\nret = request_irq(bc->tx_irq, ehv_bc_tty_tx_isr, 0, "ehv-bc", bc);\r\nif (ret < 0) {\r\ndev_err(bc->dev, "could not request tx irq %u (ret=%i)\n",\r\nbc->tx_irq, ret);\r\nfree_irq(bc->rx_irq, bc);\r\nreturn ret;\r\n}\r\ndisable_tx_interrupt(bc);\r\nreturn 0;\r\n}\r\nstatic void ehv_bc_tty_port_shutdown(struct tty_port *port)\r\n{\r\nstruct ehv_bc_data *bc = container_of(port, struct ehv_bc_data, port);\r\nfree_irq(bc->tx_irq, bc);\r\nfree_irq(bc->rx_irq, bc);\r\n}\r\nstatic int ehv_bc_tty_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct ehv_bc_data *bc;\r\nconst uint32_t *iprop;\r\nunsigned int handle;\r\nint ret;\r\nstatic unsigned int index = 1;\r\nunsigned int i;\r\niprop = of_get_property(np, "hv-handle", NULL);\r\nif (!iprop) {\r\ndev_err(&pdev->dev, "no 'hv-handle' property in %s node\n",\r\nnp->name);\r\nreturn -ENODEV;\r\n}\r\nhandle = be32_to_cpu(*iprop);\r\ni = (handle == stdout_bc) ? 0 : index++;\r\nbc = &bcs[i];\r\nbc->handle = handle;\r\nbc->head = 0;\r\nbc->tail = 0;\r\nspin_lock_init(&bc->lock);\r\nbc->rx_irq = irq_of_parse_and_map(np, 0);\r\nbc->tx_irq = irq_of_parse_and_map(np, 1);\r\nif ((bc->rx_irq == NO_IRQ) || (bc->tx_irq == NO_IRQ)) {\r\ndev_err(&pdev->dev, "no 'interrupts' property in %s node\n",\r\nnp->name);\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\ntty_port_init(&bc->port);\r\nbc->port.ops = &ehv_bc_tty_port_ops;\r\nbc->dev = tty_port_register_device(&bc->port, ehv_bc_driver, i,\r\n&pdev->dev);\r\nif (IS_ERR(bc->dev)) {\r\nret = PTR_ERR(bc->dev);\r\ndev_err(&pdev->dev, "could not register tty (ret=%i)\n", ret);\r\ngoto error;\r\n}\r\ndev_set_drvdata(&pdev->dev, bc);\r\ndev_info(&pdev->dev, "registered /dev/%s%u for byte channel %u\n",\r\nehv_bc_driver->name, i, bc->handle);\r\nreturn 0;\r\nerror:\r\ntty_port_destroy(&bc->port);\r\nirq_dispose_mapping(bc->tx_irq);\r\nirq_dispose_mapping(bc->rx_irq);\r\nmemset(bc, 0, sizeof(struct ehv_bc_data));\r\nreturn ret;\r\n}\r\nstatic int ehv_bc_tty_remove(struct platform_device *pdev)\r\n{\r\nstruct ehv_bc_data *bc = dev_get_drvdata(&pdev->dev);\r\ntty_unregister_device(ehv_bc_driver, bc - bcs);\r\ntty_port_destroy(&bc->port);\r\nirq_dispose_mapping(bc->tx_irq);\r\nirq_dispose_mapping(bc->rx_irq);\r\nreturn 0;\r\n}\r\nstatic int __init ehv_bc_init(void)\r\n{\r\nstruct device_node *np;\r\nunsigned int count = 0;\r\nint ret;\r\npr_info("ePAPR hypervisor byte channel driver\n");\r\nfor_each_compatible_node(np, NULL, "epapr,hv-byte-channel")\r\ncount++;\r\nif (!count)\r\nreturn -ENODEV;\r\nbcs = kzalloc(count * sizeof(struct ehv_bc_data), GFP_KERNEL);\r\nif (!bcs)\r\nreturn -ENOMEM;\r\nehv_bc_driver = alloc_tty_driver(count);\r\nif (!ehv_bc_driver) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nehv_bc_driver->driver_name = "ehv-bc";\r\nehv_bc_driver->name = ehv_bc_console.name;\r\nehv_bc_driver->type = TTY_DRIVER_TYPE_CONSOLE;\r\nehv_bc_driver->subtype = SYSTEM_TYPE_CONSOLE;\r\nehv_bc_driver->init_termios = tty_std_termios;\r\nehv_bc_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ntty_set_operations(ehv_bc_driver, &ehv_bc_ops);\r\nret = tty_register_driver(ehv_bc_driver);\r\nif (ret) {\r\npr_err("ehv-bc: could not register tty driver (ret=%i)\n", ret);\r\ngoto error;\r\n}\r\nret = platform_driver_register(&ehv_bc_tty_driver);\r\nif (ret) {\r\npr_err("ehv-bc: could not register platform driver (ret=%i)\n",\r\nret);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nif (ehv_bc_driver) {\r\ntty_unregister_driver(ehv_bc_driver);\r\nput_tty_driver(ehv_bc_driver);\r\n}\r\nkfree(bcs);\r\nreturn ret;\r\n}\r\nstatic void __exit ehv_bc_exit(void)\r\n{\r\nplatform_driver_unregister(&ehv_bc_tty_driver);\r\ntty_unregister_driver(ehv_bc_driver);\r\nput_tty_driver(ehv_bc_driver);\r\nkfree(bcs);\r\n}
