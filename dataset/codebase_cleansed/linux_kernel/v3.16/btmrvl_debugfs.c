static ssize_t btmrvl_hscfgcmd_write(struct file *file,\r\nconst char __user *ubuf, size_t count, loff_t *ppos)\r\n{\r\nstruct btmrvl_private *priv = file->private_data;\r\nchar buf[16];\r\nlong result, ret;\r\nmemset(buf, 0, sizeof(buf));\r\nif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\r\nreturn -EFAULT;\r\nret = kstrtol(buf, 10, &result);\r\nif (ret)\r\nreturn ret;\r\npriv->btmrvl_dev.hscfgcmd = result;\r\nif (priv->btmrvl_dev.hscfgcmd) {\r\nbtmrvl_prepare_command(priv);\r\nwake_up_interruptible(&priv->main_thread.wait_q);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t btmrvl_hscfgcmd_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct btmrvl_private *priv = file->private_data;\r\nchar buf[16];\r\nint ret;\r\nret = snprintf(buf, sizeof(buf) - 1, "%d\n",\r\npriv->btmrvl_dev.hscfgcmd);\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, ret);\r\n}\r\nstatic ssize_t btmrvl_pscmd_write(struct file *file, const char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct btmrvl_private *priv = file->private_data;\r\nchar buf[16];\r\nlong result, ret;\r\nmemset(buf, 0, sizeof(buf));\r\nif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\r\nreturn -EFAULT;\r\nret = kstrtol(buf, 10, &result);\r\nif (ret)\r\nreturn ret;\r\npriv->btmrvl_dev.pscmd = result;\r\nif (priv->btmrvl_dev.pscmd) {\r\nbtmrvl_prepare_command(priv);\r\nwake_up_interruptible(&priv->main_thread.wait_q);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t btmrvl_pscmd_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct btmrvl_private *priv = file->private_data;\r\nchar buf[16];\r\nint ret;\r\nret = snprintf(buf, sizeof(buf) - 1, "%d\n", priv->btmrvl_dev.pscmd);\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, ret);\r\n}\r\nstatic ssize_t btmrvl_hscmd_write(struct file *file, const char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct btmrvl_private *priv = file->private_data;\r\nchar buf[16];\r\nlong result, ret;\r\nmemset(buf, 0, sizeof(buf));\r\nif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\r\nreturn -EFAULT;\r\nret = kstrtol(buf, 10, &result);\r\nif (ret)\r\nreturn ret;\r\npriv->btmrvl_dev.hscmd = result;\r\nif (priv->btmrvl_dev.hscmd) {\r\nbtmrvl_prepare_command(priv);\r\nwake_up_interruptible(&priv->main_thread.wait_q);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t btmrvl_hscmd_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct btmrvl_private *priv = file->private_data;\r\nchar buf[16];\r\nint ret;\r\nret = snprintf(buf, sizeof(buf) - 1, "%d\n", priv->btmrvl_dev.hscmd);\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, ret);\r\n}\r\nvoid btmrvl_debugfs_init(struct hci_dev *hdev)\r\n{\r\nstruct btmrvl_private *priv = hci_get_drvdata(hdev);\r\nstruct btmrvl_debugfs_data *dbg;\r\nif (!hdev->debugfs)\r\nreturn;\r\ndbg = kzalloc(sizeof(*dbg), GFP_KERNEL);\r\npriv->debugfs_data = dbg;\r\nif (!dbg) {\r\nBT_ERR("Can not allocate memory for btmrvl_debugfs_data.");\r\nreturn;\r\n}\r\ndbg->config_dir = debugfs_create_dir("config", hdev->debugfs);\r\ndebugfs_create_u8("psmode", 0644, dbg->config_dir,\r\n&priv->btmrvl_dev.psmode);\r\ndebugfs_create_file("pscmd", 0644, dbg->config_dir,\r\npriv, &btmrvl_pscmd_fops);\r\ndebugfs_create_x16("gpiogap", 0644, dbg->config_dir,\r\n&priv->btmrvl_dev.gpio_gap);\r\ndebugfs_create_u8("hsmode", 0644, dbg->config_dir,\r\n&priv->btmrvl_dev.hsmode);\r\ndebugfs_create_file("hscmd", 0644, dbg->config_dir,\r\npriv, &btmrvl_hscmd_fops);\r\ndebugfs_create_file("hscfgcmd", 0644, dbg->config_dir,\r\npriv, &btmrvl_hscfgcmd_fops);\r\ndbg->status_dir = debugfs_create_dir("status", hdev->debugfs);\r\ndebugfs_create_u8("curpsmode", 0444, dbg->status_dir,\r\n&priv->adapter->psmode);\r\ndebugfs_create_u8("psstate", 0444, dbg->status_dir,\r\n&priv->adapter->ps_state);\r\ndebugfs_create_u8("hsstate", 0444, dbg->status_dir,\r\n&priv->adapter->hs_state);\r\ndebugfs_create_u8("txdnldready", 0444, dbg->status_dir,\r\n&priv->btmrvl_dev.tx_dnld_rdy);\r\n}\r\nvoid btmrvl_debugfs_remove(struct hci_dev *hdev)\r\n{\r\nstruct btmrvl_private *priv = hci_get_drvdata(hdev);\r\nstruct btmrvl_debugfs_data *dbg = priv->debugfs_data;\r\nif (!dbg)\r\nreturn;\r\ndebugfs_remove_recursive(dbg->config_dir);\r\ndebugfs_remove_recursive(dbg->status_dir);\r\nkfree(dbg);\r\n}
