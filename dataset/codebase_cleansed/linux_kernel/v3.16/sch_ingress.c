static struct Qdisc *ingress_leaf(struct Qdisc *sch, unsigned long arg)\r\n{\r\nreturn NULL;\r\n}\r\nstatic unsigned long ingress_get(struct Qdisc *sch, u32 classid)\r\n{\r\nreturn TC_H_MIN(classid) + 1;\r\n}\r\nstatic unsigned long ingress_bind_filter(struct Qdisc *sch,\r\nunsigned long parent, u32 classid)\r\n{\r\nreturn ingress_get(sch, classid);\r\n}\r\nstatic void ingress_put(struct Qdisc *sch, unsigned long cl)\r\n{\r\n}\r\nstatic void ingress_walk(struct Qdisc *sch, struct qdisc_walker *walker)\r\n{\r\n}\r\nstatic struct tcf_proto **ingress_find_tcf(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct ingress_qdisc_data *p = qdisc_priv(sch);\r\nreturn &p->filter_list;\r\n}\r\nstatic int ingress_enqueue(struct sk_buff *skb, struct Qdisc *sch)\r\n{\r\nstruct ingress_qdisc_data *p = qdisc_priv(sch);\r\nstruct tcf_result res;\r\nint result;\r\nresult = tc_classify(skb, p->filter_list, &res);\r\nqdisc_bstats_update(sch, skb);\r\nswitch (result) {\r\ncase TC_ACT_SHOT:\r\nresult = TC_ACT_SHOT;\r\nsch->qstats.drops++;\r\nbreak;\r\ncase TC_ACT_STOLEN:\r\ncase TC_ACT_QUEUED:\r\nresult = TC_ACT_STOLEN;\r\nbreak;\r\ncase TC_ACT_RECLASSIFY:\r\ncase TC_ACT_OK:\r\nskb->tc_index = TC_H_MIN(res.classid);\r\ndefault:\r\nresult = TC_ACT_OK;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic void ingress_destroy(struct Qdisc *sch)\r\n{\r\nstruct ingress_qdisc_data *p = qdisc_priv(sch);\r\ntcf_destroy_chain(&p->filter_list);\r\n}\r\nstatic int ingress_dump(struct Qdisc *sch, struct sk_buff *skb)\r\n{\r\nstruct nlattr *nest;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nreturn nla_nest_end(skb, nest);\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n}\r\nstatic int __init ingress_module_init(void)\r\n{\r\nreturn register_qdisc(&ingress_qdisc_ops);\r\n}\r\nstatic void __exit ingress_module_exit(void)\r\n{\r\nunregister_qdisc(&ingress_qdisc_ops);\r\n}
