static int\r\nextract_icmp4_fields(const struct sk_buff *skb,\r\nu8 *protocol,\r\n__be32 *raddr,\r\n__be32 *laddr,\r\n__be16 *rport,\r\n__be16 *lport)\r\n{\r\nunsigned int outside_hdrlen = ip_hdrlen(skb);\r\nstruct iphdr *inside_iph, _inside_iph;\r\nstruct icmphdr *icmph, _icmph;\r\n__be16 *ports, _ports[2];\r\nicmph = skb_header_pointer(skb, outside_hdrlen,\r\nsizeof(_icmph), &_icmph);\r\nif (icmph == NULL)\r\nreturn 1;\r\nswitch (icmph->type) {\r\ncase ICMP_DEST_UNREACH:\r\ncase ICMP_SOURCE_QUENCH:\r\ncase ICMP_REDIRECT:\r\ncase ICMP_TIME_EXCEEDED:\r\ncase ICMP_PARAMETERPROB:\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\ninside_iph = skb_header_pointer(skb, outside_hdrlen +\r\nsizeof(struct icmphdr),\r\nsizeof(_inside_iph), &_inside_iph);\r\nif (inside_iph == NULL)\r\nreturn 1;\r\nif (inside_iph->protocol != IPPROTO_TCP &&\r\ninside_iph->protocol != IPPROTO_UDP)\r\nreturn 1;\r\nports = skb_header_pointer(skb, outside_hdrlen +\r\nsizeof(struct icmphdr) +\r\n(inside_iph->ihl << 2),\r\nsizeof(_ports), &_ports);\r\nif (ports == NULL)\r\nreturn 1;\r\n*protocol = inside_iph->protocol;\r\n*laddr = inside_iph->saddr;\r\n*lport = ports[0];\r\n*raddr = inside_iph->daddr;\r\n*rport = ports[1];\r\nreturn 0;\r\n}\r\nstatic struct sock *\r\nxt_socket_get_sock_v4(struct net *net, const u8 protocol,\r\nconst __be32 saddr, const __be32 daddr,\r\nconst __be16 sport, const __be16 dport,\r\nconst struct net_device *in)\r\n{\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\nreturn __inet_lookup(net, &tcp_hashinfo,\r\nsaddr, sport, daddr, dport,\r\nin->ifindex);\r\ncase IPPROTO_UDP:\r\nreturn udp4_lib_lookup(net, saddr, sport, daddr, dport,\r\nin->ifindex);\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool\r\nsocket_match(const struct sk_buff *skb, struct xt_action_param *par,\r\nconst struct xt_socket_mtinfo1 *info)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct udphdr _hdr, *hp = NULL;\r\nstruct sock *sk = skb->sk;\r\n__be32 uninitialized_var(daddr), uninitialized_var(saddr);\r\n__be16 uninitialized_var(dport), uninitialized_var(sport);\r\nu8 uninitialized_var(protocol);\r\n#ifdef XT_SOCKET_HAVE_CONNTRACK\r\nstruct nf_conn const *ct;\r\nenum ip_conntrack_info ctinfo;\r\n#endif\r\nif (iph->protocol == IPPROTO_UDP || iph->protocol == IPPROTO_TCP) {\r\nhp = skb_header_pointer(skb, ip_hdrlen(skb),\r\nsizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\nprotocol = iph->protocol;\r\nsaddr = iph->saddr;\r\nsport = hp->source;\r\ndaddr = iph->daddr;\r\ndport = hp->dest;\r\n} else if (iph->protocol == IPPROTO_ICMP) {\r\nif (extract_icmp4_fields(skb, &protocol, &saddr, &daddr,\r\n&sport, &dport))\r\nreturn false;\r\n} else {\r\nreturn false;\r\n}\r\n#ifdef XT_SOCKET_HAVE_CONNTRACK\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct && !nf_ct_is_untracked(ct) &&\r\n((iph->protocol != IPPROTO_ICMP &&\r\nctinfo == IP_CT_ESTABLISHED_REPLY) ||\r\n(iph->protocol == IPPROTO_ICMP &&\r\nctinfo == IP_CT_RELATED_REPLY)) &&\r\n(ct->status & IPS_SRC_NAT_DONE)) {\r\ndaddr = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;\r\ndport = (iph->protocol == IPPROTO_TCP) ?\r\nct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port :\r\nct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;\r\n}\r\n#endif\r\nif (!sk)\r\nsk = xt_socket_get_sock_v4(dev_net(skb->dev), protocol,\r\nsaddr, daddr, sport, dport,\r\npar->in);\r\nif (sk) {\r\nbool wildcard;\r\nbool transparent = true;\r\nwildcard = (!(info->flags & XT_SOCKET_NOWILDCARD) &&\r\nsk->sk_state != TCP_TIME_WAIT &&\r\ninet_sk(sk)->inet_rcv_saddr == 0);\r\nif (info->flags & XT_SOCKET_TRANSPARENT)\r\ntransparent = ((sk->sk_state != TCP_TIME_WAIT &&\r\ninet_sk(sk)->transparent) ||\r\n(sk->sk_state == TCP_TIME_WAIT &&\r\ninet_twsk(sk)->tw_transparent));\r\nif (sk != skb->sk)\r\nsock_gen_put(sk);\r\nif (wildcard || !transparent)\r\nsk = NULL;\r\n}\r\npr_debug("proto %hhu %pI4:%hu -> %pI4:%hu (orig %pI4:%hu) sock %p\n",\r\nprotocol, &saddr, ntohs(sport),\r\n&daddr, ntohs(dport),\r\n&iph->daddr, hp ? ntohs(hp->dest) : 0, sk);\r\nreturn (sk != NULL);\r\n}\r\nstatic bool\r\nsocket_mt4_v0(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstatic struct xt_socket_mtinfo1 xt_info_v0 = {\r\n.flags = 0,\r\n};\r\nreturn socket_match(skb, par, &xt_info_v0);\r\n}\r\nstatic bool\r\nsocket_mt4_v1_v2(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nreturn socket_match(skb, par, par->matchinfo);\r\n}\r\nstatic int\r\nextract_icmp6_fields(const struct sk_buff *skb,\r\nunsigned int outside_hdrlen,\r\nint *protocol,\r\nstruct in6_addr **raddr,\r\nstruct in6_addr **laddr,\r\n__be16 *rport,\r\n__be16 *lport)\r\n{\r\nstruct ipv6hdr *inside_iph, _inside_iph;\r\nstruct icmp6hdr *icmph, _icmph;\r\n__be16 *ports, _ports[2];\r\nu8 inside_nexthdr;\r\n__be16 inside_fragoff;\r\nint inside_hdrlen;\r\nicmph = skb_header_pointer(skb, outside_hdrlen,\r\nsizeof(_icmph), &_icmph);\r\nif (icmph == NULL)\r\nreturn 1;\r\nif (icmph->icmp6_type & ICMPV6_INFOMSG_MASK)\r\nreturn 1;\r\ninside_iph = skb_header_pointer(skb, outside_hdrlen + sizeof(_icmph), sizeof(_inside_iph), &_inside_iph);\r\nif (inside_iph == NULL)\r\nreturn 1;\r\ninside_nexthdr = inside_iph->nexthdr;\r\ninside_hdrlen = ipv6_skip_exthdr(skb, outside_hdrlen + sizeof(_icmph) + sizeof(_inside_iph),\r\n&inside_nexthdr, &inside_fragoff);\r\nif (inside_hdrlen < 0)\r\nreturn 1;\r\nif (inside_nexthdr != IPPROTO_TCP &&\r\ninside_nexthdr != IPPROTO_UDP)\r\nreturn 1;\r\nports = skb_header_pointer(skb, inside_hdrlen,\r\nsizeof(_ports), &_ports);\r\nif (ports == NULL)\r\nreturn 1;\r\n*protocol = inside_nexthdr;\r\n*laddr = &inside_iph->saddr;\r\n*lport = ports[0];\r\n*raddr = &inside_iph->daddr;\r\n*rport = ports[1];\r\nreturn 0;\r\n}\r\nstatic struct sock *\r\nxt_socket_get_sock_v6(struct net *net, const u8 protocol,\r\nconst struct in6_addr *saddr, const struct in6_addr *daddr,\r\nconst __be16 sport, const __be16 dport,\r\nconst struct net_device *in)\r\n{\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\nreturn inet6_lookup(net, &tcp_hashinfo,\r\nsaddr, sport, daddr, dport,\r\nin->ifindex);\r\ncase IPPROTO_UDP:\r\nreturn udp6_lib_lookup(net, saddr, sport, daddr, dport,\r\nin->ifindex);\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool\r\nsocket_mt6_v1_v2(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\nstruct udphdr _hdr, *hp = NULL;\r\nstruct sock *sk = skb->sk;\r\nstruct in6_addr *daddr = NULL, *saddr = NULL;\r\n__be16 uninitialized_var(dport), uninitialized_var(sport);\r\nint thoff = 0, uninitialized_var(tproto);\r\nconst struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;\r\ntproto = ipv6_find_hdr(skb, &thoff, -1, NULL, NULL);\r\nif (tproto < 0) {\r\npr_debug("unable to find transport header in IPv6 packet, dropping\n");\r\nreturn NF_DROP;\r\n}\r\nif (tproto == IPPROTO_UDP || tproto == IPPROTO_TCP) {\r\nhp = skb_header_pointer(skb, thoff,\r\nsizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\nsaddr = &iph->saddr;\r\nsport = hp->source;\r\ndaddr = &iph->daddr;\r\ndport = hp->dest;\r\n} else if (tproto == IPPROTO_ICMPV6) {\r\nif (extract_icmp6_fields(skb, thoff, &tproto, &saddr, &daddr,\r\n&sport, &dport))\r\nreturn false;\r\n} else {\r\nreturn false;\r\n}\r\nif (!sk)\r\nsk = xt_socket_get_sock_v6(dev_net(skb->dev), tproto,\r\nsaddr, daddr, sport, dport,\r\npar->in);\r\nif (sk) {\r\nbool wildcard;\r\nbool transparent = true;\r\nwildcard = (!(info->flags & XT_SOCKET_NOWILDCARD) &&\r\nsk->sk_state != TCP_TIME_WAIT &&\r\nipv6_addr_any(&sk->sk_v6_rcv_saddr));\r\nif (info->flags & XT_SOCKET_TRANSPARENT)\r\ntransparent = ((sk->sk_state != TCP_TIME_WAIT &&\r\ninet_sk(sk)->transparent) ||\r\n(sk->sk_state == TCP_TIME_WAIT &&\r\ninet_twsk(sk)->tw_transparent));\r\nif (sk != skb->sk)\r\nsock_gen_put(sk);\r\nif (wildcard || !transparent)\r\nsk = NULL;\r\n}\r\npr_debug("proto %hhd %pI6:%hu -> %pI6:%hu "\r\n"(orig %pI6:%hu) sock %p\n",\r\ntproto, saddr, ntohs(sport),\r\ndaddr, ntohs(dport),\r\n&iph->daddr, hp ? ntohs(hp->dest) : 0, sk);\r\nreturn (sk != NULL);\r\n}\r\nstatic int socket_mt_v1_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;\r\nif (info->flags & ~XT_SOCKET_FLAGS_V1) {\r\npr_info("unknown flags 0x%x\n", info->flags & ~XT_SOCKET_FLAGS_V1);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int socket_mt_v2_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_socket_mtinfo2 *info = (struct xt_socket_mtinfo2 *) par->matchinfo;\r\nif (info->flags & ~XT_SOCKET_FLAGS_V2) {\r\npr_info("unknown flags 0x%x\n", info->flags & ~XT_SOCKET_FLAGS_V2);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init socket_mt_init(void)\r\n{\r\nnf_defrag_ipv4_enable();\r\n#ifdef XT_SOCKET_HAVE_IPV6\r\nnf_defrag_ipv6_enable();\r\n#endif\r\nreturn xt_register_matches(socket_mt_reg, ARRAY_SIZE(socket_mt_reg));\r\n}\r\nstatic void __exit socket_mt_exit(void)\r\n{\r\nxt_unregister_matches(socket_mt_reg, ARRAY_SIZE(socket_mt_reg));\r\n}
