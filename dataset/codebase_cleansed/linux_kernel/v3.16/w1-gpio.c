static u8 w1_gpio_set_pullup(void *data, int delay)\r\n{\r\nstruct w1_gpio_platform_data *pdata = data;\r\nif (delay) {\r\npdata->pullup_duration = delay;\r\n} else {\r\nif (pdata->pullup_duration) {\r\ngpio_direction_output(pdata->pin, 1);\r\nmsleep(pdata->pullup_duration);\r\ngpio_direction_input(pdata->pin);\r\n}\r\npdata->pullup_duration = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void w1_gpio_write_bit_dir(void *data, u8 bit)\r\n{\r\nstruct w1_gpio_platform_data *pdata = data;\r\nif (bit)\r\ngpio_direction_input(pdata->pin);\r\nelse\r\ngpio_direction_output(pdata->pin, 0);\r\n}\r\nstatic void w1_gpio_write_bit_val(void *data, u8 bit)\r\n{\r\nstruct w1_gpio_platform_data *pdata = data;\r\ngpio_set_value(pdata->pin, bit);\r\n}\r\nstatic u8 w1_gpio_read_bit(void *data)\r\n{\r\nstruct w1_gpio_platform_data *pdata = data;\r\nreturn gpio_get_value(pdata->pin) ? 1 : 0;\r\n}\r\nstatic int w1_gpio_probe_dt(struct platform_device *pdev)\r\n{\r\nstruct w1_gpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nint gpio;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nif (of_get_property(np, "linux,open-drain", NULL))\r\npdata->is_open_drain = 1;\r\ngpio = of_get_gpio(np, 0);\r\nif (gpio < 0) {\r\nif (gpio != -EPROBE_DEFER)\r\ndev_err(&pdev->dev,\r\n"Failed to parse gpio property for data pin (%d)\n",\r\ngpio);\r\nreturn gpio;\r\n}\r\npdata->pin = gpio;\r\ngpio = of_get_gpio(np, 1);\r\nif (gpio == -EPROBE_DEFER)\r\nreturn gpio;\r\npdata->ext_pullup_enable_pin = gpio;\r\npdev->dev.platform_data = pdata;\r\nreturn 0;\r\n}\r\nstatic int w1_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct w1_bus_master *master;\r\nstruct w1_gpio_platform_data *pdata;\r\nint err;\r\nif (of_have_populated_dt()) {\r\nerr = w1_gpio_probe_dt(pdev);\r\nif (err < 0)\r\nreturn err;\r\n}\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No configuration data\n");\r\nreturn -ENXIO;\r\n}\r\nmaster = devm_kzalloc(&pdev->dev, sizeof(struct w1_bus_master),\r\nGFP_KERNEL);\r\nif (!master) {\r\ndev_err(&pdev->dev, "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = devm_gpio_request(&pdev->dev, pdata->pin, "w1");\r\nif (err) {\r\ndev_err(&pdev->dev, "gpio_request (pin) failed\n");\r\nreturn err;\r\n}\r\nif (gpio_is_valid(pdata->ext_pullup_enable_pin)) {\r\nerr = devm_gpio_request_one(&pdev->dev,\r\npdata->ext_pullup_enable_pin, GPIOF_INIT_LOW,\r\n"w1 pullup");\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "gpio_request_one "\r\n"(ext_pullup_enable_pin) failed\n");\r\nreturn err;\r\n}\r\n}\r\nmaster->data = pdata;\r\nmaster->read_bit = w1_gpio_read_bit;\r\nif (pdata->is_open_drain) {\r\ngpio_direction_output(pdata->pin, 1);\r\nmaster->write_bit = w1_gpio_write_bit_val;\r\n} else {\r\ngpio_direction_input(pdata->pin);\r\nmaster->write_bit = w1_gpio_write_bit_dir;\r\nmaster->set_pullup = w1_gpio_set_pullup;\r\n}\r\nerr = w1_add_master_device(master);\r\nif (err) {\r\ndev_err(&pdev->dev, "w1_add_master device failed\n");\r\nreturn err;\r\n}\r\nif (pdata->enable_external_pullup)\r\npdata->enable_external_pullup(1);\r\nif (gpio_is_valid(pdata->ext_pullup_enable_pin))\r\ngpio_set_value(pdata->ext_pullup_enable_pin, 1);\r\nplatform_set_drvdata(pdev, master);\r\nreturn 0;\r\n}\r\nstatic int w1_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct w1_bus_master *master = platform_get_drvdata(pdev);\r\nstruct w1_gpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nif (pdata->enable_external_pullup)\r\npdata->enable_external_pullup(0);\r\nif (gpio_is_valid(pdata->ext_pullup_enable_pin))\r\ngpio_set_value(pdata->ext_pullup_enable_pin, 0);\r\nw1_remove_master_device(master);\r\nreturn 0;\r\n}\r\nstatic int w1_gpio_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct w1_gpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nif (pdata->enable_external_pullup)\r\npdata->enable_external_pullup(0);\r\nreturn 0;\r\n}\r\nstatic int w1_gpio_resume(struct platform_device *pdev)\r\n{\r\nstruct w1_gpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nif (pdata->enable_external_pullup)\r\npdata->enable_external_pullup(1);\r\nreturn 0;\r\n}
