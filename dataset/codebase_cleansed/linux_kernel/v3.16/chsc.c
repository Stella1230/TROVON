int chsc_error_from_response(int response)\r\n{\r\nswitch (response) {\r\ncase 0x0001:\r\nreturn 0;\r\ncase 0x0002:\r\ncase 0x0003:\r\ncase 0x0006:\r\ncase 0x0007:\r\ncase 0x0008:\r\ncase 0x000a:\r\ncase 0x0104:\r\nreturn -EINVAL;\r\ncase 0x0004:\r\nreturn -EOPNOTSUPP;\r\ncase 0x000b:\r\ncase 0x0107:\r\nreturn -EBUSY;\r\ncase 0x0100:\r\ncase 0x0102:\r\nreturn -ENOMEM;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nint chsc_get_ssd_info(struct subchannel_id schid, struct chsc_ssd_info *ssd)\r\n{\r\nstruct chsc_ssd_area *ssd_area;\r\nint ccode;\r\nint ret;\r\nint i;\r\nint mask;\r\nspin_lock_irq(&chsc_page_lock);\r\nmemset(chsc_page, 0, PAGE_SIZE);\r\nssd_area = chsc_page;\r\nssd_area->request.length = 0x0010;\r\nssd_area->request.code = 0x0004;\r\nssd_area->ssid = schid.ssid;\r\nssd_area->f_sch = schid.sch_no;\r\nssd_area->l_sch = schid.sch_no;\r\nccode = chsc(ssd_area);\r\nif (ccode > 0) {\r\nret = (ccode == 3) ? -ENODEV : -EBUSY;\r\ngoto out;\r\n}\r\nret = chsc_error_from_response(ssd_area->response.code);\r\nif (ret != 0) {\r\nCIO_MSG_EVENT(2, "chsc: ssd failed for 0.%x.%04x (rc=%04x)\n",\r\nschid.ssid, schid.sch_no,\r\nssd_area->response.code);\r\ngoto out;\r\n}\r\nif (!ssd_area->sch_valid) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = 0;\r\nmemset(ssd, 0, sizeof(struct chsc_ssd_info));\r\nif ((ssd_area->st != SUBCHANNEL_TYPE_IO) &&\r\n(ssd_area->st != SUBCHANNEL_TYPE_MSG))\r\ngoto out;\r\nssd->path_mask = ssd_area->path_mask;\r\nssd->fla_valid_mask = ssd_area->fla_valid_mask;\r\nfor (i = 0; i < 8; i++) {\r\nmask = 0x80 >> i;\r\nif (ssd_area->path_mask & mask) {\r\nchp_id_init(&ssd->chpid[i]);\r\nssd->chpid[i].id = ssd_area->chpid[i];\r\n}\r\nif (ssd_area->fla_valid_mask & mask)\r\nssd->fla[i] = ssd_area->fla[i];\r\n}\r\nout:\r\nspin_unlock_irq(&chsc_page_lock);\r\nreturn ret;\r\n}\r\nint chsc_ssqd(struct subchannel_id schid, struct chsc_ssqd_area *ssqd)\r\n{\r\nmemset(ssqd, 0, sizeof(*ssqd));\r\nssqd->request.length = 0x0010;\r\nssqd->request.code = 0x0024;\r\nssqd->first_sch = schid.sch_no;\r\nssqd->last_sch = schid.sch_no;\r\nssqd->ssid = schid.ssid;\r\nif (chsc(ssqd))\r\nreturn -EIO;\r\nreturn chsc_error_from_response(ssqd->response.code);\r\n}\r\nint chsc_sadc(struct subchannel_id schid, struct chsc_scssc_area *scssc,\r\nu64 summary_indicator_addr, u64 subchannel_indicator_addr)\r\n{\r\nmemset(scssc, 0, sizeof(*scssc));\r\nscssc->request.length = 0x0fe0;\r\nscssc->request.code = 0x0021;\r\nscssc->operation_code = 0;\r\nscssc->summary_indicator_addr = summary_indicator_addr;\r\nscssc->subchannel_indicator_addr = subchannel_indicator_addr;\r\nscssc->ks = PAGE_DEFAULT_KEY >> 4;\r\nscssc->kc = PAGE_DEFAULT_KEY >> 4;\r\nscssc->isc = QDIO_AIRQ_ISC;\r\nscssc->schid = schid;\r\nif (css_general_characteristics.aif_tdd)\r\nscssc->word_with_d_bit = 0x10000000;\r\nif (chsc(scssc))\r\nreturn -EIO;\r\nreturn chsc_error_from_response(scssc->response.code);\r\n}\r\nstatic int s390_subchannel_remove_chpid(struct subchannel *sch, void *data)\r\n{\r\nspin_lock_irq(sch->lock);\r\nif (sch->driver && sch->driver->chp_event)\r\nif (sch->driver->chp_event(sch, data, CHP_OFFLINE) != 0)\r\ngoto out_unreg;\r\nspin_unlock_irq(sch->lock);\r\nreturn 0;\r\nout_unreg:\r\nsch->lpm = 0;\r\nspin_unlock_irq(sch->lock);\r\ncss_schedule_eval(sch->schid);\r\nreturn 0;\r\n}\r\nvoid chsc_chp_offline(struct chp_id chpid)\r\n{\r\nchar dbf_txt[15];\r\nstruct chp_link link;\r\nsprintf(dbf_txt, "chpr%x.%02x", chpid.cssid, chpid.id);\r\nCIO_TRACE_EVENT(2, dbf_txt);\r\nif (chp_get_status(chpid) <= 0)\r\nreturn;\r\nmemset(&link, 0, sizeof(struct chp_link));\r\nlink.chpid = chpid;\r\ncss_wait_for_slow_path();\r\nfor_each_subchannel_staged(s390_subchannel_remove_chpid, NULL, &link);\r\n}\r\nstatic int __s390_process_res_acc(struct subchannel *sch, void *data)\r\n{\r\nspin_lock_irq(sch->lock);\r\nif (sch->driver && sch->driver->chp_event)\r\nsch->driver->chp_event(sch, data, CHP_ONLINE);\r\nspin_unlock_irq(sch->lock);\r\nreturn 0;\r\n}\r\nstatic void s390_process_res_acc(struct chp_link *link)\r\n{\r\nchar dbf_txt[15];\r\nsprintf(dbf_txt, "accpr%x.%02x", link->chpid.cssid,\r\nlink->chpid.id);\r\nCIO_TRACE_EVENT( 2, dbf_txt);\r\nif (link->fla != 0) {\r\nsprintf(dbf_txt, "fla%x", link->fla);\r\nCIO_TRACE_EVENT( 2, dbf_txt);\r\n}\r\ncss_wait_for_slow_path();\r\nfor_each_subchannel_staged(__s390_process_res_acc, NULL, link);\r\ncss_schedule_reprobe();\r\n}\r\nstatic int\r\n__get_chpid_from_lir(void *data)\r\n{\r\nstruct lir {\r\nu8 iq;\r\nu8 ic;\r\nu16 sci;\r\nu32 indesc[28];\r\nu32 andesc[28];\r\nu32 isinfo[28];\r\n} __attribute__ ((packed)) *lir;\r\nlir = data;\r\nif (!(lir->iq&0x80))\r\nreturn -EINVAL;\r\nif (!(lir->indesc[0]&0xc0000000))\r\nreturn -EINVAL;\r\nif (!(lir->indesc[0]&0x10000000))\r\nreturn -EINVAL;\r\nreturn (u16) (lir->indesc[0]&0x000000ff);\r\n}\r\nstatic void chsc_process_sei_link_incident(struct chsc_sei_nt0_area *sei_area)\r\n{\r\nstruct chp_id chpid;\r\nint id;\r\nCIO_CRW_EVENT(4, "chsc: link incident (rs=%02x, rs_id=%04x)\n",\r\nsei_area->rs, sei_area->rsid);\r\nif (sei_area->rs != 4)\r\nreturn;\r\nid = __get_chpid_from_lir(sei_area->ccdf);\r\nif (id < 0)\r\nCIO_CRW_EVENT(4, "chsc: link incident - invalid LIR\n");\r\nelse {\r\nchp_id_init(&chpid);\r\nchpid.id = id;\r\nchsc_chp_offline(chpid);\r\n}\r\n}\r\nstatic void chsc_process_sei_res_acc(struct chsc_sei_nt0_area *sei_area)\r\n{\r\nstruct chp_link link;\r\nstruct chp_id chpid;\r\nint status;\r\nCIO_CRW_EVENT(4, "chsc: resource accessibility event (rs=%02x, "\r\n"rs_id=%04x)\n", sei_area->rs, sei_area->rsid);\r\nif (sei_area->rs != 4)\r\nreturn;\r\nchp_id_init(&chpid);\r\nchpid.id = sei_area->rsid;\r\nstatus = chp_get_status(chpid);\r\nif (status < 0)\r\nchp_new(chpid);\r\nelse if (!status)\r\nreturn;\r\nmemset(&link, 0, sizeof(struct chp_link));\r\nlink.chpid = chpid;\r\nif ((sei_area->vf & 0xc0) != 0) {\r\nlink.fla = sei_area->fla;\r\nif ((sei_area->vf & 0xc0) == 0xc0)\r\nlink.fla_mask = 0xffff;\r\nelse\r\nlink.fla_mask = 0xff00;\r\n}\r\ns390_process_res_acc(&link);\r\n}\r\nstatic void chsc_process_sei_chp_avail(struct chsc_sei_nt0_area *sei_area)\r\n{\r\nstruct channel_path *chp;\r\nstruct chp_id chpid;\r\nu8 *data;\r\nint num;\r\nCIO_CRW_EVENT(4, "chsc: channel path availability information\n");\r\nif (sei_area->rs != 0)\r\nreturn;\r\ndata = sei_area->ccdf;\r\nchp_id_init(&chpid);\r\nfor (num = 0; num <= __MAX_CHPID; num++) {\r\nif (!chp_test_bit(data, num))\r\ncontinue;\r\nchpid.id = num;\r\nCIO_CRW_EVENT(4, "Update information for channel path "\r\n"%x.%02x\n", chpid.cssid, chpid.id);\r\nchp = chpid_to_chp(chpid);\r\nif (!chp) {\r\nchp_new(chpid);\r\ncontinue;\r\n}\r\nmutex_lock(&chp->lock);\r\nchp_update_desc(chp);\r\nmutex_unlock(&chp->lock);\r\n}\r\n}\r\nstatic void chsc_process_sei_chp_config(struct chsc_sei_nt0_area *sei_area)\r\n{\r\nstruct chp_config_data *data;\r\nstruct chp_id chpid;\r\nint num;\r\nchar *events[3] = {"configure", "deconfigure", "cancel deconfigure"};\r\nCIO_CRW_EVENT(4, "chsc: channel-path-configuration notification\n");\r\nif (sei_area->rs != 0)\r\nreturn;\r\ndata = (struct chp_config_data *) &(sei_area->ccdf);\r\nchp_id_init(&chpid);\r\nfor (num = 0; num <= __MAX_CHPID; num++) {\r\nif (!chp_test_bit(data->map, num))\r\ncontinue;\r\nchpid.id = num;\r\npr_notice("Processing %s for channel path %x.%02x\n",\r\nevents[data->op], chpid.cssid, chpid.id);\r\nswitch (data->op) {\r\ncase 0:\r\nchp_cfg_schedule(chpid, 1);\r\nbreak;\r\ncase 1:\r\nchp_cfg_schedule(chpid, 0);\r\nbreak;\r\ncase 2:\r\nchp_cfg_cancel_deconfigure(chpid);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void chsc_process_sei_scm_change(struct chsc_sei_nt0_area *sei_area)\r\n{\r\nint ret;\r\nCIO_CRW_EVENT(4, "chsc: scm change notification\n");\r\nif (sei_area->rs != 7)\r\nreturn;\r\nret = scm_update_information();\r\nif (ret)\r\nCIO_CRW_EVENT(0, "chsc: updating change notification"\r\n" failed (rc=%d).\n", ret);\r\n}\r\nstatic void chsc_process_sei_scm_avail(struct chsc_sei_nt0_area *sei_area)\r\n{\r\nint ret;\r\nCIO_CRW_EVENT(4, "chsc: scm available information\n");\r\nif (sei_area->rs != 7)\r\nreturn;\r\nret = scm_process_availability_information();\r\nif (ret)\r\nCIO_CRW_EVENT(0, "chsc: process availability information"\r\n" failed (rc=%d).\n", ret);\r\n}\r\nstatic void chsc_process_sei_nt2(struct chsc_sei_nt2_area *sei_area)\r\n{\r\nswitch (sei_area->cc) {\r\ncase 1:\r\nzpci_event_error(sei_area->ccdf);\r\nbreak;\r\ncase 2:\r\nzpci_event_availability(sei_area->ccdf);\r\nbreak;\r\ndefault:\r\nCIO_CRW_EVENT(2, "chsc: sei nt2 unhandled cc=%d\n",\r\nsei_area->cc);\r\nbreak;\r\n}\r\n}\r\nstatic void chsc_process_sei_nt0(struct chsc_sei_nt0_area *sei_area)\r\n{\r\nswitch (sei_area->cc) {\r\ncase 1:\r\nchsc_process_sei_link_incident(sei_area);\r\nbreak;\r\ncase 2:\r\nchsc_process_sei_res_acc(sei_area);\r\nbreak;\r\ncase 7:\r\nchsc_process_sei_chp_avail(sei_area);\r\nbreak;\r\ncase 8:\r\nchsc_process_sei_chp_config(sei_area);\r\nbreak;\r\ncase 12:\r\nchsc_process_sei_scm_change(sei_area);\r\nbreak;\r\ncase 14:\r\nchsc_process_sei_scm_avail(sei_area);\r\nbreak;\r\ndefault:\r\nCIO_CRW_EVENT(2, "chsc: sei nt0 unhandled cc=%d\n",\r\nsei_area->cc);\r\nbreak;\r\n}\r\nif (sei_area->flags & 0x40) {\r\nCIO_CRW_EVENT(2, "chsc: event overflow\n");\r\ncss_schedule_eval_all();\r\n}\r\n}\r\nstatic void chsc_process_event_information(struct chsc_sei *sei, u64 ntsm)\r\n{\r\nstatic int ntsm_unsupported;\r\nwhile (true) {\r\nmemset(sei, 0, sizeof(*sei));\r\nsei->request.length = 0x0010;\r\nsei->request.code = 0x000e;\r\nif (!ntsm_unsupported)\r\nsei->ntsm = ntsm;\r\nif (chsc(sei))\r\nbreak;\r\nif (sei->response.code != 0x0001) {\r\nCIO_CRW_EVENT(2, "chsc: sei failed (rc=%04x, ntsm=%llx)\n",\r\nsei->response.code, sei->ntsm);\r\nif (sei->response.code == 3 && sei->ntsm) {\r\nntsm_unsupported = 1;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nCIO_CRW_EVENT(2, "chsc: sei successful (nt=%d)\n", sei->nt);\r\nswitch (sei->nt) {\r\ncase 0:\r\nchsc_process_sei_nt0(&sei->u.nt0_area);\r\nbreak;\r\ncase 2:\r\nchsc_process_sei_nt2(&sei->u.nt2_area);\r\nbreak;\r\ndefault:\r\nCIO_CRW_EVENT(2, "chsc: unhandled nt: %d\n", sei->nt);\r\nbreak;\r\n}\r\nif (!(sei->u.nt0_area.flags & 0x80))\r\nbreak;\r\n}\r\n}\r\nstatic void chsc_process_crw(struct crw *crw0, struct crw *crw1, int overflow)\r\n{\r\nstruct chsc_sei *sei = sei_page;\r\nif (overflow) {\r\ncss_schedule_eval_all();\r\nreturn;\r\n}\r\nCIO_CRW_EVENT(2, "CRW reports slct=%d, oflw=%d, "\r\n"chn=%d, rsc=%X, anc=%d, erc=%X, rsid=%X\n",\r\ncrw0->slct, crw0->oflw, crw0->chn, crw0->rsc, crw0->anc,\r\ncrw0->erc, crw0->rsid);\r\nCIO_TRACE_EVENT(2, "prcss");\r\nchsc_process_event_information(sei, CHSC_SEI_NT0 | CHSC_SEI_NT2);\r\n}\r\nvoid chsc_chp_online(struct chp_id chpid)\r\n{\r\nchar dbf_txt[15];\r\nstruct chp_link link;\r\nsprintf(dbf_txt, "cadd%x.%02x", chpid.cssid, chpid.id);\r\nCIO_TRACE_EVENT(2, dbf_txt);\r\nif (chp_get_status(chpid) != 0) {\r\nmemset(&link, 0, sizeof(struct chp_link));\r\nlink.chpid = chpid;\r\ncss_wait_for_slow_path();\r\nfor_each_subchannel_staged(__s390_process_res_acc, NULL,\r\n&link);\r\ncss_schedule_reprobe();\r\n}\r\n}\r\nstatic void __s390_subchannel_vary_chpid(struct subchannel *sch,\r\nstruct chp_id chpid, int on)\r\n{\r\nunsigned long flags;\r\nstruct chp_link link;\r\nmemset(&link, 0, sizeof(struct chp_link));\r\nlink.chpid = chpid;\r\nspin_lock_irqsave(sch->lock, flags);\r\nif (sch->driver && sch->driver->chp_event)\r\nsch->driver->chp_event(sch, &link,\r\non ? CHP_VARY_ON : CHP_VARY_OFF);\r\nspin_unlock_irqrestore(sch->lock, flags);\r\n}\r\nstatic int s390_subchannel_vary_chpid_off(struct subchannel *sch, void *data)\r\n{\r\nstruct chp_id *chpid = data;\r\n__s390_subchannel_vary_chpid(sch, *chpid, 0);\r\nreturn 0;\r\n}\r\nstatic int s390_subchannel_vary_chpid_on(struct subchannel *sch, void *data)\r\n{\r\nstruct chp_id *chpid = data;\r\n__s390_subchannel_vary_chpid(sch, *chpid, 1);\r\nreturn 0;\r\n}\r\nint chsc_chp_vary(struct chp_id chpid, int on)\r\n{\r\nstruct channel_path *chp = chpid_to_chp(chpid);\r\ncss_wait_for_slow_path();\r\nif (on) {\r\nchp_update_desc(chp);\r\nfor_each_subchannel_staged(s390_subchannel_vary_chpid_on,\r\nNULL, &chpid);\r\ncss_schedule_reprobe();\r\n} else\r\nfor_each_subchannel_staged(s390_subchannel_vary_chpid_off,\r\nNULL, &chpid);\r\nreturn 0;\r\n}\r\nstatic void\r\nchsc_remove_cmg_attr(struct channel_subsystem *css)\r\n{\r\nint i;\r\nfor (i = 0; i <= __MAX_CHPID; i++) {\r\nif (!css->chps[i])\r\ncontinue;\r\nchp_remove_cmg_attr(css->chps[i]);\r\n}\r\n}\r\nstatic int\r\nchsc_add_cmg_attr(struct channel_subsystem *css)\r\n{\r\nint i, ret;\r\nret = 0;\r\nfor (i = 0; i <= __MAX_CHPID; i++) {\r\nif (!css->chps[i])\r\ncontinue;\r\nret = chp_add_cmg_attr(css->chps[i]);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\nreturn ret;\r\ncleanup:\r\nfor (--i; i >= 0; i--) {\r\nif (!css->chps[i])\r\ncontinue;\r\nchp_remove_cmg_attr(css->chps[i]);\r\n}\r\nreturn ret;\r\n}\r\nint __chsc_do_secm(struct channel_subsystem *css, int enable)\r\n{\r\nstruct {\r\nstruct chsc_header request;\r\nu32 operation_code : 2;\r\nu32 : 30;\r\nu32 key : 4;\r\nu32 : 28;\r\nu32 zeroes1;\r\nu32 cub_addr1;\r\nu32 zeroes2;\r\nu32 cub_addr2;\r\nu32 reserved[13];\r\nstruct chsc_header response;\r\nu32 status : 8;\r\nu32 : 4;\r\nu32 fmt : 4;\r\nu32 : 16;\r\n} __attribute__ ((packed)) *secm_area;\r\nint ret, ccode;\r\nspin_lock_irq(&chsc_page_lock);\r\nmemset(chsc_page, 0, PAGE_SIZE);\r\nsecm_area = chsc_page;\r\nsecm_area->request.length = 0x0050;\r\nsecm_area->request.code = 0x0016;\r\nsecm_area->key = PAGE_DEFAULT_KEY >> 4;\r\nsecm_area->cub_addr1 = (u64)(unsigned long)css->cub_addr1;\r\nsecm_area->cub_addr2 = (u64)(unsigned long)css->cub_addr2;\r\nsecm_area->operation_code = enable ? 0 : 1;\r\nccode = chsc(secm_area);\r\nif (ccode > 0) {\r\nret = (ccode == 3) ? -ENODEV : -EBUSY;\r\ngoto out;\r\n}\r\nswitch (secm_area->response.code) {\r\ncase 0x0102:\r\ncase 0x0103:\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = chsc_error_from_response(secm_area->response.code);\r\n}\r\nif (ret != 0)\r\nCIO_CRW_EVENT(2, "chsc: secm failed (rc=%04x)\n",\r\nsecm_area->response.code);\r\nout:\r\nspin_unlock_irq(&chsc_page_lock);\r\nreturn ret;\r\n}\r\nint\r\nchsc_secm(struct channel_subsystem *css, int enable)\r\n{\r\nint ret;\r\nif (enable && !css->cm_enabled) {\r\ncss->cub_addr1 = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\ncss->cub_addr2 = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!css->cub_addr1 || !css->cub_addr2) {\r\nfree_page((unsigned long)css->cub_addr1);\r\nfree_page((unsigned long)css->cub_addr2);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nret = __chsc_do_secm(css, enable);\r\nif (!ret) {\r\ncss->cm_enabled = enable;\r\nif (css->cm_enabled) {\r\nret = chsc_add_cmg_attr(css);\r\nif (ret) {\r\n__chsc_do_secm(css, 0);\r\ncss->cm_enabled = 0;\r\n}\r\n} else\r\nchsc_remove_cmg_attr(css);\r\n}\r\nif (!css->cm_enabled) {\r\nfree_page((unsigned long)css->cub_addr1);\r\nfree_page((unsigned long)css->cub_addr2);\r\n}\r\nreturn ret;\r\n}\r\nint chsc_determine_channel_path_desc(struct chp_id chpid, int fmt, int rfmt,\r\nint c, int m, void *page)\r\n{\r\nstruct chsc_scpd *scpd_area;\r\nint ccode, ret;\r\nif ((rfmt == 1) && !css_general_characteristics.fcs)\r\nreturn -EINVAL;\r\nif ((rfmt == 2) && !css_general_characteristics.cib)\r\nreturn -EINVAL;\r\nmemset(page, 0, PAGE_SIZE);\r\nscpd_area = page;\r\nscpd_area->request.length = 0x0010;\r\nscpd_area->request.code = 0x0002;\r\nscpd_area->cssid = chpid.cssid;\r\nscpd_area->first_chpid = chpid.id;\r\nscpd_area->last_chpid = chpid.id;\r\nscpd_area->m = m;\r\nscpd_area->c = c;\r\nscpd_area->fmt = fmt;\r\nscpd_area->rfmt = rfmt;\r\nccode = chsc(scpd_area);\r\nif (ccode > 0)\r\nreturn (ccode == 3) ? -ENODEV : -EBUSY;\r\nret = chsc_error_from_response(scpd_area->response.code);\r\nif (ret)\r\nCIO_CRW_EVENT(2, "chsc: scpd failed (rc=%04x)\n",\r\nscpd_area->response.code);\r\nreturn ret;\r\n}\r\nint chsc_determine_base_channel_path_desc(struct chp_id chpid,\r\nstruct channel_path_desc *desc)\r\n{\r\nstruct chsc_response_struct *chsc_resp;\r\nstruct chsc_scpd *scpd_area;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&chsc_page_lock, flags);\r\nscpd_area = chsc_page;\r\nret = chsc_determine_channel_path_desc(chpid, 0, 0, 0, 0, scpd_area);\r\nif (ret)\r\ngoto out;\r\nchsc_resp = (void *)&scpd_area->response;\r\nmemcpy(desc, &chsc_resp->data, sizeof(*desc));\r\nout:\r\nspin_unlock_irqrestore(&chsc_page_lock, flags);\r\nreturn ret;\r\n}\r\nint chsc_determine_fmt1_channel_path_desc(struct chp_id chpid,\r\nstruct channel_path_desc_fmt1 *desc)\r\n{\r\nstruct chsc_response_struct *chsc_resp;\r\nstruct chsc_scpd *scpd_area;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&chsc_page_lock, flags);\r\nscpd_area = chsc_page;\r\nret = chsc_determine_channel_path_desc(chpid, 0, 0, 1, 0, scpd_area);\r\nif (ret)\r\ngoto out;\r\nchsc_resp = (void *)&scpd_area->response;\r\nmemcpy(desc, &chsc_resp->data, sizeof(*desc));\r\nout:\r\nspin_unlock_irqrestore(&chsc_page_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void\r\nchsc_initialize_cmg_chars(struct channel_path *chp, u8 cmcv,\r\nstruct cmg_chars *chars)\r\n{\r\nstruct cmg_chars *cmg_chars;\r\nint i, mask;\r\ncmg_chars = chp->cmg_chars;\r\nfor (i = 0; i < NR_MEASUREMENT_CHARS; i++) {\r\nmask = 0x80 >> (i + 3);\r\nif (cmcv & mask)\r\ncmg_chars->values[i] = chars->values[i];\r\nelse\r\ncmg_chars->values[i] = 0;\r\n}\r\n}\r\nint chsc_get_channel_measurement_chars(struct channel_path *chp)\r\n{\r\nstruct cmg_chars *cmg_chars;\r\nint ccode, ret;\r\nstruct {\r\nstruct chsc_header request;\r\nu32 : 24;\r\nu32 first_chpid : 8;\r\nu32 : 24;\r\nu32 last_chpid : 8;\r\nu32 zeroes1;\r\nstruct chsc_header response;\r\nu32 zeroes2;\r\nu32 not_valid : 1;\r\nu32 shared : 1;\r\nu32 : 22;\r\nu32 chpid : 8;\r\nu32 cmcv : 5;\r\nu32 : 11;\r\nu32 cmgq : 8;\r\nu32 cmg : 8;\r\nu32 zeroes3;\r\nu32 data[NR_MEASUREMENT_CHARS];\r\n} __attribute__ ((packed)) *scmc_area;\r\nchp->cmg_chars = NULL;\r\ncmg_chars = kmalloc(sizeof(*cmg_chars), GFP_KERNEL);\r\nif (!cmg_chars)\r\nreturn -ENOMEM;\r\nspin_lock_irq(&chsc_page_lock);\r\nmemset(chsc_page, 0, PAGE_SIZE);\r\nscmc_area = chsc_page;\r\nscmc_area->request.length = 0x0010;\r\nscmc_area->request.code = 0x0022;\r\nscmc_area->first_chpid = chp->chpid.id;\r\nscmc_area->last_chpid = chp->chpid.id;\r\nccode = chsc(scmc_area);\r\nif (ccode > 0) {\r\nret = (ccode == 3) ? -ENODEV : -EBUSY;\r\ngoto out;\r\n}\r\nret = chsc_error_from_response(scmc_area->response.code);\r\nif (ret) {\r\nCIO_CRW_EVENT(2, "chsc: scmc failed (rc=%04x)\n",\r\nscmc_area->response.code);\r\ngoto out;\r\n}\r\nif (scmc_area->not_valid) {\r\nchp->cmg = -1;\r\nchp->shared = -1;\r\ngoto out;\r\n}\r\nchp->cmg = scmc_area->cmg;\r\nchp->shared = scmc_area->shared;\r\nif (chp->cmg != 2 && chp->cmg != 3) {\r\ngoto out;\r\n}\r\nchp->cmg_chars = cmg_chars;\r\nchsc_initialize_cmg_chars(chp, scmc_area->cmcv,\r\n(struct cmg_chars *) &scmc_area->data);\r\nout:\r\nspin_unlock_irq(&chsc_page_lock);\r\nif (!chp->cmg_chars)\r\nkfree(cmg_chars);\r\nreturn ret;\r\n}\r\nint __init chsc_init(void)\r\n{\r\nint ret;\r\nsei_page = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nchsc_page = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sei_page || !chsc_page) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nret = crw_register_handler(CRW_RSC_CSS, chsc_process_crw);\r\nif (ret)\r\ngoto out_err;\r\nreturn ret;\r\nout_err:\r\nfree_page((unsigned long)chsc_page);\r\nfree_page((unsigned long)sei_page);\r\nreturn ret;\r\n}\r\nvoid __init chsc_init_cleanup(void)\r\n{\r\ncrw_unregister_handler(CRW_RSC_CSS);\r\nfree_page((unsigned long)chsc_page);\r\nfree_page((unsigned long)sei_page);\r\n}\r\nint chsc_enable_facility(int operation_code)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nstruct {\r\nstruct chsc_header request;\r\nu8 reserved1:4;\r\nu8 format:4;\r\nu8 reserved2;\r\nu16 operation_code;\r\nu32 reserved3;\r\nu32 reserved4;\r\nu32 operation_data_area[252];\r\nstruct chsc_header response;\r\nu32 reserved5:4;\r\nu32 format2:4;\r\nu32 reserved6:24;\r\n} __attribute__ ((packed)) *sda_area;\r\nspin_lock_irqsave(&chsc_page_lock, flags);\r\nmemset(chsc_page, 0, PAGE_SIZE);\r\nsda_area = chsc_page;\r\nsda_area->request.length = 0x0400;\r\nsda_area->request.code = 0x0031;\r\nsda_area->operation_code = operation_code;\r\nret = chsc(sda_area);\r\nif (ret > 0) {\r\nret = (ret == 3) ? -ENODEV : -EBUSY;\r\ngoto out;\r\n}\r\nswitch (sda_area->response.code) {\r\ncase 0x0101:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nret = chsc_error_from_response(sda_area->response.code);\r\n}\r\nif (ret != 0)\r\nCIO_CRW_EVENT(2, "chsc: sda (oc=%x) failed (rc=%04x)\n",\r\noperation_code, sda_area->response.code);\r\nout:\r\nspin_unlock_irqrestore(&chsc_page_lock, flags);\r\nreturn ret;\r\n}\r\nint __init\r\nchsc_determine_css_characteristics(void)\r\n{\r\nint result;\r\nstruct {\r\nstruct chsc_header request;\r\nu32 reserved1;\r\nu32 reserved2;\r\nu32 reserved3;\r\nstruct chsc_header response;\r\nu32 reserved4;\r\nu32 general_char[510];\r\nu32 chsc_char[508];\r\n} __attribute__ ((packed)) *scsc_area;\r\nspin_lock_irq(&chsc_page_lock);\r\nmemset(chsc_page, 0, PAGE_SIZE);\r\nscsc_area = chsc_page;\r\nscsc_area->request.length = 0x0010;\r\nscsc_area->request.code = 0x0010;\r\nresult = chsc(scsc_area);\r\nif (result) {\r\nresult = (result == 3) ? -ENODEV : -EBUSY;\r\ngoto exit;\r\n}\r\nresult = chsc_error_from_response(scsc_area->response.code);\r\nif (result == 0) {\r\nmemcpy(&css_general_characteristics, scsc_area->general_char,\r\nsizeof(css_general_characteristics));\r\nmemcpy(&css_chsc_characteristics, scsc_area->chsc_char,\r\nsizeof(css_chsc_characteristics));\r\n} else\r\nCIO_CRW_EVENT(2, "chsc: scsc failed (rc=%04x)\n",\r\nscsc_area->response.code);\r\nexit:\r\nspin_unlock_irq(&chsc_page_lock);\r\nreturn result;\r\n}\r\nint chsc_sstpc(void *page, unsigned int op, u16 ctrl)\r\n{\r\nstruct {\r\nstruct chsc_header request;\r\nunsigned int rsvd0;\r\nunsigned int op : 8;\r\nunsigned int rsvd1 : 8;\r\nunsigned int ctrl : 16;\r\nunsigned int rsvd2[5];\r\nstruct chsc_header response;\r\nunsigned int rsvd3[7];\r\n} __attribute__ ((packed)) *rr;\r\nint rc;\r\nmemset(page, 0, PAGE_SIZE);\r\nrr = page;\r\nrr->request.length = 0x0020;\r\nrr->request.code = 0x0033;\r\nrr->op = op;\r\nrr->ctrl = ctrl;\r\nrc = chsc(rr);\r\nif (rc)\r\nreturn -EIO;\r\nrc = (rr->response.code == 0x0001) ? 0 : -EIO;\r\nreturn rc;\r\n}\r\nint chsc_sstpi(void *page, void *result, size_t size)\r\n{\r\nstruct {\r\nstruct chsc_header request;\r\nunsigned int rsvd0[3];\r\nstruct chsc_header response;\r\nchar data[size];\r\n} __attribute__ ((packed)) *rr;\r\nint rc;\r\nmemset(page, 0, PAGE_SIZE);\r\nrr = page;\r\nrr->request.length = 0x0010;\r\nrr->request.code = 0x0038;\r\nrc = chsc(rr);\r\nif (rc)\r\nreturn -EIO;\r\nmemcpy(result, &rr->data, size);\r\nreturn (rr->response.code == 0x0001) ? 0 : -EIO;\r\n}\r\nint chsc_siosl(struct subchannel_id schid)\r\n{\r\nstruct {\r\nstruct chsc_header request;\r\nu32 word1;\r\nstruct subchannel_id sid;\r\nu32 word3;\r\nstruct chsc_header response;\r\nu32 word[11];\r\n} __attribute__ ((packed)) *siosl_area;\r\nunsigned long flags;\r\nint ccode;\r\nint rc;\r\nspin_lock_irqsave(&chsc_page_lock, flags);\r\nmemset(chsc_page, 0, PAGE_SIZE);\r\nsiosl_area = chsc_page;\r\nsiosl_area->request.length = 0x0010;\r\nsiosl_area->request.code = 0x0046;\r\nsiosl_area->word1 = 0x80000000;\r\nsiosl_area->sid = schid;\r\nccode = chsc(siosl_area);\r\nif (ccode > 0) {\r\nif (ccode == 3)\r\nrc = -ENODEV;\r\nelse\r\nrc = -EBUSY;\r\nCIO_MSG_EVENT(2, "chsc: chsc failed for 0.%x.%04x (ccode=%d)\n",\r\nschid.ssid, schid.sch_no, ccode);\r\ngoto out;\r\n}\r\nrc = chsc_error_from_response(siosl_area->response.code);\r\nif (rc)\r\nCIO_MSG_EVENT(2, "chsc: siosl failed for 0.%x.%04x (rc=%04x)\n",\r\nschid.ssid, schid.sch_no,\r\nsiosl_area->response.code);\r\nelse\r\nCIO_MSG_EVENT(4, "chsc: siosl succeeded for 0.%x.%04x\n",\r\nschid.ssid, schid.sch_no);\r\nout:\r\nspin_unlock_irqrestore(&chsc_page_lock, flags);\r\nreturn rc;\r\n}\r\nint chsc_scm_info(struct chsc_scm_info *scm_area, u64 token)\r\n{\r\nint ccode, ret;\r\nmemset(scm_area, 0, sizeof(*scm_area));\r\nscm_area->request.length = 0x0020;\r\nscm_area->request.code = 0x004C;\r\nscm_area->reqtok = token;\r\nccode = chsc(scm_area);\r\nif (ccode > 0) {\r\nret = (ccode == 3) ? -ENODEV : -EBUSY;\r\ngoto out;\r\n}\r\nret = chsc_error_from_response(scm_area->response.code);\r\nif (ret != 0)\r\nCIO_MSG_EVENT(2, "chsc: scm info failed (rc=%04x)\n",\r\nscm_area->response.code);\r\nout:\r\nreturn ret;\r\n}\r\nint chsc_pnso_brinfo(struct subchannel_id schid,\r\nstruct chsc_pnso_area *brinfo_area,\r\nstruct chsc_brinfo_resume_token resume_token,\r\nint cnc)\r\n{\r\nmemset(brinfo_area, 0, sizeof(*brinfo_area));\r\nbrinfo_area->request.length = 0x0030;\r\nbrinfo_area->request.code = 0x003d;\r\nbrinfo_area->m = schid.m;\r\nbrinfo_area->ssid = schid.ssid;\r\nbrinfo_area->sch = schid.sch_no;\r\nbrinfo_area->cssid = schid.cssid;\r\nbrinfo_area->oc = 0;\r\nbrinfo_area->resume_token = resume_token;\r\nbrinfo_area->n = (cnc != 0);\r\nif (chsc(brinfo_area))\r\nreturn -EIO;\r\nreturn chsc_error_from_response(brinfo_area->response.code);\r\n}
