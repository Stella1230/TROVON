static void udlfb_dpy_deferred_io(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct page *cur;\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nstruct udl_fbdev *ufbdev = info->par;\r\nstruct drm_device *dev = ufbdev->ufb.base.dev;\r\nstruct udl_device *udl = dev->dev_private;\r\nstruct urb *urb;\r\nchar *cmd;\r\ncycles_t start_cycles, end_cycles;\r\nint bytes_sent = 0;\r\nint bytes_identical = 0;\r\nint bytes_rendered = 0;\r\nif (!fb_defio)\r\nreturn;\r\nstart_cycles = get_cycles();\r\nurb = udl_get_urb(dev);\r\nif (!urb)\r\nreturn;\r\ncmd = urb->transfer_buffer;\r\nlist_for_each_entry(cur, &fbdefio->pagelist, lru) {\r\nif (udl_render_hline(dev, (ufbdev->ufb.base.bits_per_pixel / 8),\r\n&urb, (char *) info->fix.smem_start,\r\n&cmd, cur->index << PAGE_SHIFT,\r\ncur->index << PAGE_SHIFT,\r\nPAGE_SIZE, &bytes_identical, &bytes_sent))\r\ngoto error;\r\nbytes_rendered += PAGE_SIZE;\r\n}\r\nif (cmd > (char *) urb->transfer_buffer) {\r\nint len = cmd - (char *) urb->transfer_buffer;\r\nudl_submit_urb(dev, urb, len);\r\nbytes_sent += len;\r\n} else\r\nudl_urb_completion(urb);\r\nerror:\r\natomic_add(bytes_sent, &udl->bytes_sent);\r\natomic_add(bytes_identical, &udl->bytes_identical);\r\natomic_add(bytes_rendered, &udl->bytes_rendered);\r\nend_cycles = get_cycles();\r\natomic_add(((unsigned int) ((end_cycles - start_cycles)\r\n>> 10)),\r\n&udl->cpu_kcycles_used);\r\n}\r\nint udl_handle_damage(struct udl_framebuffer *fb, int x, int y,\r\nint width, int height)\r\n{\r\nstruct drm_device *dev = fb->base.dev;\r\nstruct udl_device *udl = dev->dev_private;\r\nint i, ret;\r\nchar *cmd;\r\ncycles_t start_cycles, end_cycles;\r\nint bytes_sent = 0;\r\nint bytes_identical = 0;\r\nstruct urb *urb;\r\nint aligned_x;\r\nint bpp = (fb->base.bits_per_pixel / 8);\r\nint x2, y2;\r\nbool store_for_later = false;\r\nunsigned long flags;\r\nif (!fb->active_16)\r\nreturn 0;\r\nif (!fb->obj->vmapping) {\r\nret = udl_gem_vmap(fb->obj);\r\nif (ret == -ENOMEM) {\r\nDRM_ERROR("failed to vmap fb\n");\r\nreturn 0;\r\n}\r\nif (!fb->obj->vmapping) {\r\nDRM_ERROR("failed to vmapping\n");\r\nreturn 0;\r\n}\r\n}\r\naligned_x = DL_ALIGN_DOWN(x, sizeof(unsigned long));\r\nwidth = DL_ALIGN_UP(width + (x-aligned_x), sizeof(unsigned long));\r\nx = aligned_x;\r\nif ((width <= 0) ||\r\n(x + width > fb->base.width) ||\r\n(y + height > fb->base.height))\r\nreturn -EINVAL;\r\nif (in_atomic())\r\nstore_for_later = true;\r\nx2 = x + width - 1;\r\ny2 = y + height - 1;\r\nspin_lock_irqsave(&fb->dirty_lock, flags);\r\nif (fb->y1 < y)\r\ny = fb->y1;\r\nif (fb->y2 > y2)\r\ny2 = fb->y2;\r\nif (fb->x1 < x)\r\nx = fb->x1;\r\nif (fb->x2 > x2)\r\nx2 = fb->x2;\r\nif (store_for_later) {\r\nfb->x1 = x;\r\nfb->x2 = x2;\r\nfb->y1 = y;\r\nfb->y2 = y2;\r\nspin_unlock_irqrestore(&fb->dirty_lock, flags);\r\nreturn 0;\r\n}\r\nfb->x1 = fb->y1 = INT_MAX;\r\nfb->x2 = fb->y2 = 0;\r\nspin_unlock_irqrestore(&fb->dirty_lock, flags);\r\nstart_cycles = get_cycles();\r\nurb = udl_get_urb(dev);\r\nif (!urb)\r\nreturn 0;\r\ncmd = urb->transfer_buffer;\r\nfor (i = y; i <= y2 ; i++) {\r\nconst int line_offset = fb->base.pitches[0] * i;\r\nconst int byte_offset = line_offset + (x * bpp);\r\nconst int dev_byte_offset = (fb->base.width * bpp * i) + (x * bpp);\r\nif (udl_render_hline(dev, bpp, &urb,\r\n(char *) fb->obj->vmapping,\r\n&cmd, byte_offset, dev_byte_offset,\r\n(x2 - x + 1) * bpp,\r\n&bytes_identical, &bytes_sent))\r\ngoto error;\r\n}\r\nif (cmd > (char *) urb->transfer_buffer) {\r\nint len = cmd - (char *) urb->transfer_buffer;\r\nret = udl_submit_urb(dev, urb, len);\r\nbytes_sent += len;\r\n} else\r\nudl_urb_completion(urb);\r\nerror:\r\natomic_add(bytes_sent, &udl->bytes_sent);\r\natomic_add(bytes_identical, &udl->bytes_identical);\r\natomic_add(width*height*bpp, &udl->bytes_rendered);\r\nend_cycles = get_cycles();\r\natomic_add(((unsigned int) ((end_cycles - start_cycles)\r\n>> 10)),\r\n&udl->cpu_kcycles_used);\r\nreturn 0;\r\n}\r\nstatic int udl_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nunsigned long start = vma->vm_start;\r\nunsigned long size = vma->vm_end - vma->vm_start;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nunsigned long page, pos;\r\nif (offset + size > info->fix.smem_len)\r\nreturn -EINVAL;\r\npos = (unsigned long)info->fix.smem_start + offset;\r\npr_notice("mmap() framebuffer addr:%lu size:%lu\n",\r\npos, size);\r\nwhile (size > 0) {\r\npage = vmalloc_to_pfn((void *)pos);\r\nif (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))\r\nreturn -EAGAIN;\r\nstart += PAGE_SIZE;\r\npos += PAGE_SIZE;\r\nif (size > PAGE_SIZE)\r\nsize -= PAGE_SIZE;\r\nelse\r\nsize = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void udl_fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct udl_fbdev *ufbdev = info->par;\r\nsys_fillrect(info, rect);\r\nudl_handle_damage(&ufbdev->ufb, rect->dx, rect->dy, rect->width,\r\nrect->height);\r\n}\r\nstatic void udl_fb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\r\n{\r\nstruct udl_fbdev *ufbdev = info->par;\r\nsys_copyarea(info, region);\r\nudl_handle_damage(&ufbdev->ufb, region->dx, region->dy, region->width,\r\nregion->height);\r\n}\r\nstatic void udl_fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct udl_fbdev *ufbdev = info->par;\r\nsys_imageblit(info, image);\r\nudl_handle_damage(&ufbdev->ufb, image->dx, image->dy, image->width,\r\nimage->height);\r\n}\r\nstatic int udl_fb_open(struct fb_info *info, int user)\r\n{\r\nstruct udl_fbdev *ufbdev = info->par;\r\nstruct drm_device *dev = ufbdev->ufb.base.dev;\r\nstruct udl_device *udl = dev->dev_private;\r\nif (drm_device_is_unplugged(udl->ddev))\r\nreturn -ENODEV;\r\nufbdev->fb_count++;\r\nif (fb_defio && (info->fbdefio == NULL)) {\r\nstruct fb_deferred_io *fbdefio;\r\nfbdefio = kmalloc(sizeof(struct fb_deferred_io), GFP_KERNEL);\r\nif (fbdefio) {\r\nfbdefio->delay = DL_DEFIO_WRITE_DELAY;\r\nfbdefio->deferred_io = udlfb_dpy_deferred_io;\r\n}\r\ninfo->fbdefio = fbdefio;\r\nfb_deferred_io_init(info);\r\n}\r\npr_notice("open /dev/fb%d user=%d fb_info=%p count=%d\n",\r\ninfo->node, user, info, ufbdev->fb_count);\r\nreturn 0;\r\n}\r\nstatic int udl_fb_release(struct fb_info *info, int user)\r\n{\r\nstruct udl_fbdev *ufbdev = info->par;\r\nufbdev->fb_count--;\r\nif ((ufbdev->fb_count == 0) && (info->fbdefio)) {\r\nfb_deferred_io_cleanup(info);\r\nkfree(info->fbdefio);\r\ninfo->fbdefio = NULL;\r\ninfo->fbops->fb_mmap = udl_fb_mmap;\r\n}\r\npr_warn("released /dev/fb%d user=%d count=%d\n",\r\ninfo->node, user, ufbdev->fb_count);\r\nreturn 0;\r\n}\r\nstatic int udl_user_framebuffer_dirty(struct drm_framebuffer *fb,\r\nstruct drm_file *file,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips)\r\n{\r\nstruct udl_framebuffer *ufb = to_udl_fb(fb);\r\nint i;\r\nint ret = 0;\r\ndrm_modeset_lock_all(fb->dev);\r\nif (!ufb->active_16)\r\ngoto unlock;\r\nif (ufb->obj->base.import_attach) {\r\nret = dma_buf_begin_cpu_access(ufb->obj->base.import_attach->dmabuf,\r\n0, ufb->obj->base.size,\r\nDMA_FROM_DEVICE);\r\nif (ret)\r\ngoto unlock;\r\n}\r\nfor (i = 0; i < num_clips; i++) {\r\nret = udl_handle_damage(ufb, clips[i].x1, clips[i].y1,\r\nclips[i].x2 - clips[i].x1,\r\nclips[i].y2 - clips[i].y1);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ufb->obj->base.import_attach) {\r\ndma_buf_end_cpu_access(ufb->obj->base.import_attach->dmabuf,\r\n0, ufb->obj->base.size,\r\nDMA_FROM_DEVICE);\r\n}\r\nunlock:\r\ndrm_modeset_unlock_all(fb->dev);\r\nreturn ret;\r\n}\r\nstatic void udl_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct udl_framebuffer *ufb = to_udl_fb(fb);\r\nif (ufb->obj)\r\ndrm_gem_object_unreference_unlocked(&ufb->obj->base);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(ufb);\r\n}\r\nstatic int\r\nudl_framebuffer_init(struct drm_device *dev,\r\nstruct udl_framebuffer *ufb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct udl_gem_object *obj)\r\n{\r\nint ret;\r\nspin_lock_init(&ufb->dirty_lock);\r\nufb->obj = obj;\r\ndrm_helper_mode_fill_fb_struct(&ufb->base, mode_cmd);\r\nret = drm_framebuffer_init(dev, &ufb->base, &udlfb_funcs);\r\nreturn ret;\r\n}\r\nstatic int udlfb_create(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct udl_fbdev *ufbdev = (struct udl_fbdev *)helper;\r\nstruct drm_device *dev = ufbdev->helper.dev;\r\nstruct fb_info *info;\r\nstruct device *device = dev->dev;\r\nstruct drm_framebuffer *fb;\r\nstruct drm_mode_fb_cmd2 mode_cmd;\r\nstruct udl_gem_object *obj;\r\nuint32_t size;\r\nint ret = 0;\r\nif (sizes->surface_bpp == 24)\r\nsizes->surface_bpp = 32;\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] = mode_cmd.width * ((sizes->surface_bpp + 7) / 8);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\nsize = ALIGN(size, PAGE_SIZE);\r\nobj = udl_gem_alloc_object(dev, size);\r\nif (!obj)\r\ngoto out;\r\nret = udl_gem_vmap(obj);\r\nif (ret) {\r\nDRM_ERROR("failed to vmap fb\n");\r\ngoto out_gfree;\r\n}\r\ninfo = framebuffer_alloc(0, device);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto out_gfree;\r\n}\r\ninfo->par = ufbdev;\r\nret = udl_framebuffer_init(dev, &ufbdev->ufb, &mode_cmd, obj);\r\nif (ret)\r\ngoto out_gfree;\r\nfb = &ufbdev->ufb.base;\r\nufbdev->helper.fb = fb;\r\nufbdev->helper.fbdev = info;\r\nstrcpy(info->fix.id, "udldrmfb");\r\ninfo->screen_base = ufbdev->ufb.obj->vmapping;\r\ninfo->fix.smem_len = size;\r\ninfo->fix.smem_start = (unsigned long)ufbdev->ufb.obj->vmapping;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_CAN_FORCE_OUTPUT;\r\ninfo->fbops = &udlfb_ops;\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(info, &ufbdev->helper, sizes->fb_width, sizes->fb_height);\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret) {\r\nret = -ENOMEM;\r\ngoto out_gfree;\r\n}\r\nDRM_DEBUG_KMS("allocated %dx%d vmal %p\n",\r\nfb->width, fb->height,\r\nufbdev->ufb.obj->vmapping);\r\nreturn ret;\r\nout_gfree:\r\ndrm_gem_object_unreference(&ufbdev->ufb.obj->base);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void udl_fbdev_destroy(struct drm_device *dev,\r\nstruct udl_fbdev *ufbdev)\r\n{\r\nstruct fb_info *info;\r\nif (ufbdev->helper.fbdev) {\r\ninfo = ufbdev->helper.fbdev;\r\nunregister_framebuffer(info);\r\nif (info->cmap.len)\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\ndrm_fb_helper_fini(&ufbdev->helper);\r\ndrm_framebuffer_unregister_private(&ufbdev->ufb.base);\r\ndrm_framebuffer_cleanup(&ufbdev->ufb.base);\r\ndrm_gem_object_unreference_unlocked(&ufbdev->ufb.obj->base);\r\n}\r\nint udl_fbdev_init(struct drm_device *dev)\r\n{\r\nstruct udl_device *udl = dev->dev_private;\r\nint bpp_sel = fb_bpp;\r\nstruct udl_fbdev *ufbdev;\r\nint ret;\r\nufbdev = kzalloc(sizeof(struct udl_fbdev), GFP_KERNEL);\r\nif (!ufbdev)\r\nreturn -ENOMEM;\r\nudl->fbdev = ufbdev;\r\nufbdev->helper.funcs = &udl_fb_helper_funcs;\r\nret = drm_fb_helper_init(dev, &ufbdev->helper,\r\n1, 1);\r\nif (ret) {\r\nkfree(ufbdev);\r\nreturn ret;\r\n}\r\ndrm_fb_helper_single_add_all_connectors(&ufbdev->helper);\r\ndrm_helper_disable_unused_functions(dev);\r\ndrm_fb_helper_initial_config(&ufbdev->helper, bpp_sel);\r\nreturn 0;\r\n}\r\nvoid udl_fbdev_cleanup(struct drm_device *dev)\r\n{\r\nstruct udl_device *udl = dev->dev_private;\r\nif (!udl->fbdev)\r\nreturn;\r\nudl_fbdev_destroy(dev, udl->fbdev);\r\nkfree(udl->fbdev);\r\nudl->fbdev = NULL;\r\n}\r\nvoid udl_fbdev_unplug(struct drm_device *dev)\r\n{\r\nstruct udl_device *udl = dev->dev_private;\r\nstruct udl_fbdev *ufbdev;\r\nif (!udl->fbdev)\r\nreturn;\r\nufbdev = udl->fbdev;\r\nif (ufbdev->helper.fbdev) {\r\nstruct fb_info *info;\r\ninfo = ufbdev->helper.fbdev;\r\nunlink_framebuffer(info);\r\n}\r\n}\r\nstruct drm_framebuffer *\r\nudl_fb_user_fb_create(struct drm_device *dev,\r\nstruct drm_file *file,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct udl_framebuffer *ufb;\r\nint ret;\r\nuint32_t size;\r\nobj = drm_gem_object_lookup(dev, file, mode_cmd->handles[0]);\r\nif (obj == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\nsize = mode_cmd->pitches[0] * mode_cmd->height;\r\nsize = ALIGN(size, PAGE_SIZE);\r\nif (size > obj->size) {\r\nDRM_ERROR("object size not sufficient for fb %d %zu %d %d\n", size, obj->size, mode_cmd->pitches[0], mode_cmd->height);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nufb = kzalloc(sizeof(*ufb), GFP_KERNEL);\r\nif (ufb == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = udl_framebuffer_init(dev, ufb, mode_cmd, to_udl_bo(obj));\r\nif (ret) {\r\nkfree(ufb);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn &ufb->base;\r\n}
