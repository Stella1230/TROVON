static int arizona_spk_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct arizona *arizona = dev_get_drvdata(codec->dev->parent);\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nbool manual_ena = false;\r\nint val;\r\nswitch (arizona->type) {\r\ncase WM5102:\r\nswitch (arizona->rev) {\r\ncase 0:\r\nbreak;\r\ndefault:\r\nmanual_ena = true;\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nif (!priv->spk_ena && manual_ena) {\r\nregmap_write_async(arizona->regmap, 0x4f5, 0x25a);\r\npriv->spk_ena_pending = true;\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nval = snd_soc_read(codec, ARIZONA_INTERRUPT_RAW_STATUS_3);\r\nif (val & ARIZONA_SPK_SHUTDOWN_STS) {\r\ndev_crit(arizona->dev,\r\n"Speaker not enabled due to temperature\n");\r\nreturn -EBUSY;\r\n}\r\nregmap_update_bits_async(arizona->regmap,\r\nARIZONA_OUTPUT_ENABLES_1,\r\n1 << w->shift, 1 << w->shift);\r\nif (priv->spk_ena_pending) {\r\nmsleep(75);\r\nregmap_write_async(arizona->regmap, 0x4f5, 0xda);\r\npriv->spk_ena_pending = false;\r\npriv->spk_ena++;\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nif (manual_ena) {\r\npriv->spk_ena--;\r\nif (!priv->spk_ena)\r\nregmap_write_async(arizona->regmap,\r\n0x4f5, 0x25a);\r\n}\r\nregmap_update_bits_async(arizona->regmap,\r\nARIZONA_OUTPUT_ENABLES_1,\r\n1 << w->shift, 0);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nif (manual_ena) {\r\nif (!priv->spk_ena)\r\nregmap_write_async(arizona->regmap,\r\n0x4f5, 0x0da);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t arizona_thermal_warn(int irq, void *data)\r\n{\r\nstruct arizona *arizona = data;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_3,\r\n&val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read thermal status: %d\n",\r\nret);\r\n} else if (val & ARIZONA_SPK_SHUTDOWN_WARN_STS) {\r\ndev_crit(arizona->dev, "Thermal warning\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t arizona_thermal_shutdown(int irq, void *data)\r\n{\r\nstruct arizona *arizona = data;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_3,\r\n&val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read thermal status: %d\n",\r\nret);\r\n} else if (val & ARIZONA_SPK_SHUTDOWN_STS) {\r\ndev_crit(arizona->dev, "Thermal shutdown\n");\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_OUTPUT_ENABLES_1,\r\nARIZONA_OUT4L_ENA |\r\nARIZONA_OUT4R_ENA, 0);\r\nif (ret != 0)\r\ndev_crit(arizona->dev,\r\n"Failed to disable speaker outputs: %d\n",\r\nret);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint arizona_init_spk(struct snd_soc_codec *codec)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint ret;\r\nret = snd_soc_dapm_new_controls(&codec->dapm, &arizona_spkl, 1);\r\nif (ret != 0)\r\nreturn ret;\r\nswitch (arizona->type) {\r\ncase WM8997:\r\nbreak;\r\ndefault:\r\nret = snd_soc_dapm_new_controls(&codec->dapm,\r\n&arizona_spkr, 1);\r\nif (ret != 0)\r\nreturn ret;\r\nbreak;\r\n}\r\nret = arizona_request_irq(arizona, ARIZONA_IRQ_SPK_SHUTDOWN_WARN,\r\n"Thermal warning", arizona_thermal_warn,\r\narizona);\r\nif (ret != 0)\r\ndev_err(arizona->dev,\r\n"Failed to get thermal warning IRQ: %d\n",\r\nret);\r\nret = arizona_request_irq(arizona, ARIZONA_IRQ_SPK_SHUTDOWN,\r\n"Thermal shutdown", arizona_thermal_shutdown,\r\narizona);\r\nif (ret != 0)\r\ndev_err(arizona->dev,\r\n"Failed to get thermal shutdown IRQ: %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nint arizona_init_gpio(struct snd_soc_codec *codec)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint i;\r\nswitch (arizona->type) {\r\ncase WM5110:\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "DRC2 Signal Activity");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "DRC1 Signal Activity");\r\nfor (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {\r\nswitch (arizona->pdata.gpio_defaults[i] & ARIZONA_GPN_FN_MASK) {\r\ncase ARIZONA_GP_FN_DRC1_SIGNAL_DETECT:\r\nsnd_soc_dapm_enable_pin(&codec->dapm,\r\n"DRC1 Signal Activity");\r\nbreak;\r\ncase ARIZONA_GP_FN_DRC2_SIGNAL_DETECT:\r\nsnd_soc_dapm_enable_pin(&codec->dapm,\r\n"DRC2 Signal Activity");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void arizona_in_set_vu(struct snd_soc_codec *codec, int ena)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nint i;\r\nif (ena)\r\nval = ARIZONA_IN_VU;\r\nelse\r\nval = 0;\r\nfor (i = 0; i < priv->num_inputs; i++)\r\nsnd_soc_update_bits(codec,\r\nARIZONA_ADC_DIGITAL_VOLUME_1L + (i * 4),\r\nARIZONA_IN_VU, val);\r\n}\r\nint arizona_in_ev(struct snd_soc_dapm_widget *w, struct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(w->codec);\r\nunsigned int reg;\r\nif (w->shift % 2)\r\nreg = ARIZONA_ADC_DIGITAL_VOLUME_1L + ((w->shift / 2) * 8);\r\nelse\r\nreg = ARIZONA_ADC_DIGITAL_VOLUME_1R + ((w->shift / 2) * 8);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\npriv->in_pending++;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(w->codec, reg, ARIZONA_IN1L_MUTE, 0);\r\npriv->in_pending--;\r\nif (priv->in_pending == 0) {\r\nmsleep(1);\r\narizona_in_set_vu(w->codec, 1);\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(w->codec, reg,\r\nARIZONA_IN1L_MUTE | ARIZONA_IN_VU,\r\nARIZONA_IN1L_MUTE | ARIZONA_IN_VU);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nreg = snd_soc_read(w->codec, ARIZONA_INPUT_ENABLES);\r\nif (reg == 0)\r\narizona_in_set_vu(w->codec, 0);\r\n}\r\nreturn 0;\r\n}\r\nint arizona_out_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nswitch (w->shift) {\r\ncase ARIZONA_OUT1L_ENA_SHIFT:\r\ncase ARIZONA_OUT1R_ENA_SHIFT:\r\ncase ARIZONA_OUT2L_ENA_SHIFT:\r\ncase ARIZONA_OUT2R_ENA_SHIFT:\r\ncase ARIZONA_OUT3L_ENA_SHIFT:\r\ncase ARIZONA_OUT3R_ENA_SHIFT:\r\nmsleep(17);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint arizona_hp_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(w->codec);\r\nstruct arizona *arizona = priv->arizona;\r\nunsigned int mask = 1 << w->shift;\r\nunsigned int val;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nval = mask;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nval = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npriv->arizona->hp_ena &= ~mask;\r\npriv->arizona->hp_ena |= val;\r\nif (priv->arizona->hpdet_magic)\r\nval = 0;\r\nregmap_update_bits_async(arizona->regmap, ARIZONA_OUTPUT_ENABLES_1,\r\nmask, val);\r\nreturn arizona_out_ev(w, kcontrol, event);\r\n}\r\nstatic int arizona_set_opclk(struct snd_soc_codec *codec, unsigned int clk,\r\nunsigned int freq)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg;\r\nunsigned int *rates;\r\nint ref, div, refclk;\r\nswitch (clk) {\r\ncase ARIZONA_CLK_OPCLK:\r\nreg = ARIZONA_OUTPUT_SYSTEM_CLOCK;\r\nrefclk = priv->sysclk;\r\nbreak;\r\ncase ARIZONA_CLK_ASYNC_OPCLK:\r\nreg = ARIZONA_OUTPUT_ASYNC_CLOCK;\r\nrefclk = priv->asyncclk;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (refclk % 8000)\r\nrates = arizona_sysclk_44k1_rates;\r\nelse\r\nrates = arizona_sysclk_48k_rates;\r\nfor (ref = 0; ref < ARRAY_SIZE(arizona_sysclk_48k_rates) &&\r\nrates[ref] <= refclk; ref++) {\r\ndiv = 1;\r\nwhile (rates[ref] / div >= freq && div < 32) {\r\nif (rates[ref] / div == freq) {\r\ndev_dbg(codec->dev, "Configured %dHz OPCLK\n",\r\nfreq);\r\nsnd_soc_update_bits(codec, reg,\r\nARIZONA_OPCLK_DIV_MASK |\r\nARIZONA_OPCLK_SEL_MASK,\r\n(div <<\r\nARIZONA_OPCLK_DIV_SHIFT) |\r\nref);\r\nreturn 0;\r\n}\r\ndiv++;\r\n}\r\n}\r\ndev_err(codec->dev, "Unable to generate %dHz OPCLK\n", freq);\r\nreturn -EINVAL;\r\n}\r\nint arizona_set_sysclk(struct snd_soc_codec *codec, int clk_id,\r\nint source, unsigned int freq, int dir)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nchar *name;\r\nunsigned int reg;\r\nunsigned int mask = ARIZONA_SYSCLK_FREQ_MASK | ARIZONA_SYSCLK_SRC_MASK;\r\nunsigned int val = source << ARIZONA_SYSCLK_SRC_SHIFT;\r\nunsigned int *clk;\r\nswitch (clk_id) {\r\ncase ARIZONA_CLK_SYSCLK:\r\nname = "SYSCLK";\r\nreg = ARIZONA_SYSTEM_CLOCK_1;\r\nclk = &priv->sysclk;\r\nmask |= ARIZONA_SYSCLK_FRAC;\r\nbreak;\r\ncase ARIZONA_CLK_ASYNCCLK:\r\nname = "ASYNCCLK";\r\nreg = ARIZONA_ASYNC_CLOCK_1;\r\nclk = &priv->asyncclk;\r\nbreak;\r\ncase ARIZONA_CLK_OPCLK:\r\ncase ARIZONA_CLK_ASYNC_OPCLK:\r\nreturn arizona_set_opclk(codec, clk_id, freq);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (freq) {\r\ncase 5644800:\r\ncase 6144000:\r\nbreak;\r\ncase 11289600:\r\ncase 12288000:\r\nval |= ARIZONA_CLK_12MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 22579200:\r\ncase 24576000:\r\nval |= ARIZONA_CLK_24MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 45158400:\r\ncase 49152000:\r\nval |= ARIZONA_CLK_49MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 67737600:\r\ncase 73728000:\r\nval |= ARIZONA_CLK_73MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 90316800:\r\ncase 98304000:\r\nval |= ARIZONA_CLK_98MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 135475200:\r\ncase 147456000:\r\nval |= ARIZONA_CLK_147MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 0:\r\ndev_dbg(arizona->dev, "%s cleared\n", name);\r\n*clk = freq;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*clk = freq;\r\nif (freq % 6144000)\r\nval |= ARIZONA_SYSCLK_FRAC;\r\ndev_dbg(arizona->dev, "%s set to %uHz", name, freq);\r\nreturn regmap_update_bits(arizona->regmap, reg, mask, val);\r\n}\r\nstatic int arizona_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint lrclk, bclk, mode, base;\r\nbase = dai->driver->base;\r\nlrclk = 0;\r\nbclk = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nmode = 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nmode = 2;\r\nbreak;\r\ndefault:\r\narizona_aif_err(dai, "Unsupported DAI format %d\n",\r\nfmt & SND_SOC_DAIFMT_FORMAT_MASK);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nlrclk |= ARIZONA_AIF1TX_LRCLK_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nbclk |= ARIZONA_AIF1_BCLK_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbclk |= ARIZONA_AIF1_BCLK_MSTR;\r\nlrclk |= ARIZONA_AIF1TX_LRCLK_MSTR;\r\nbreak;\r\ndefault:\r\narizona_aif_err(dai, "Unsupported master mode %d\n",\r\nfmt & SND_SOC_DAIFMT_MASTER_MASK);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbclk |= ARIZONA_AIF1_BCLK_INV;\r\nlrclk |= ARIZONA_AIF1TX_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbclk |= ARIZONA_AIF1_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nlrclk |= ARIZONA_AIF1TX_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits_async(arizona->regmap, base + ARIZONA_AIF_BCLK_CTRL,\r\nARIZONA_AIF1_BCLK_INV |\r\nARIZONA_AIF1_BCLK_MSTR,\r\nbclk);\r\nregmap_update_bits_async(arizona->regmap, base + ARIZONA_AIF_TX_PIN_CTRL,\r\nARIZONA_AIF1TX_LRCLK_INV |\r\nARIZONA_AIF1TX_LRCLK_MSTR, lrclk);\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_RX_PIN_CTRL,\r\nARIZONA_AIF1RX_LRCLK_INV |\r\nARIZONA_AIF1RX_LRCLK_MSTR, lrclk);\r\nregmap_update_bits(arizona->regmap, base + ARIZONA_AIF_FORMAT,\r\nARIZONA_AIF1_FMT_MASK, mode);\r\nreturn 0;\r\n}\r\nstatic int arizona_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona_dai_priv *dai_priv = &priv->dai[dai->id - 1];\r\nconst struct snd_pcm_hw_constraint_list *constraint;\r\nunsigned int base_rate;\r\nswitch (dai_priv->clk) {\r\ncase ARIZONA_CLK_SYSCLK:\r\nbase_rate = priv->sysclk;\r\nbreak;\r\ncase ARIZONA_CLK_ASYNCCLK:\r\nbase_rate = priv->asyncclk;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (base_rate == 0)\r\nreturn 0;\r\nif (base_rate % 8000)\r\nconstraint = &arizona_44k1_constraint;\r\nelse\r\nconstraint = &arizona_48k_constraint;\r\nreturn snd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nconstraint);\r\n}\r\nstatic int arizona_hw_params_rate(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona_dai_priv *dai_priv = &priv->dai[dai->id - 1];\r\nint base = dai->driver->base;\r\nint i, sr_val;\r\nfor (i = 0; i < ARRAY_SIZE(arizona_sr_vals); i++)\r\nif (arizona_sr_vals[i] == params_rate(params))\r\nbreak;\r\nif (i == ARRAY_SIZE(arizona_sr_vals)) {\r\narizona_aif_err(dai, "Unsupported sample rate %dHz\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nsr_val = i;\r\nswitch (dai_priv->clk) {\r\ncase ARIZONA_CLK_SYSCLK:\r\nsnd_soc_update_bits(codec, ARIZONA_SAMPLE_RATE_1,\r\nARIZONA_SAMPLE_RATE_1_MASK, sr_val);\r\nif (base)\r\nsnd_soc_update_bits(codec, base + ARIZONA_AIF_RATE_CTRL,\r\nARIZONA_AIF1_RATE_MASK, 0);\r\nbreak;\r\ncase ARIZONA_CLK_ASYNCCLK:\r\nsnd_soc_update_bits(codec, ARIZONA_ASYNC_SAMPLE_RATE_1,\r\nARIZONA_ASYNC_SAMPLE_RATE_MASK, sr_val);\r\nif (base)\r\nsnd_soc_update_bits(codec, base + ARIZONA_AIF_RATE_CTRL,\r\nARIZONA_AIF1_RATE_MASK,\r\n8 << ARIZONA_AIF1_RATE_SHIFT);\r\nbreak;\r\ndefault:\r\narizona_aif_err(dai, "Invalid clock %d\n", dai_priv->clk);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int arizona_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint base = dai->driver->base;\r\nconst int *rates;\r\nint i, ret, val;\r\nint chan_limit = arizona->pdata.max_channels_clocked[dai->id - 1];\r\nint bclk, lrclk, wl, frame, bclk_target;\r\nif (params_rate(params) % 8000)\r\nrates = &arizona_44k1_bclk_rates[0];\r\nelse\r\nrates = &arizona_48k_bclk_rates[0];\r\nbclk_target = snd_soc_params_to_bclk(params);\r\nif (chan_limit && chan_limit < params_channels(params)) {\r\narizona_aif_dbg(dai, "Limiting to %d channels\n", chan_limit);\r\nbclk_target /= params_channels(params);\r\nbclk_target *= chan_limit;\r\n}\r\nval = snd_soc_read(codec, base + ARIZONA_AIF_FORMAT);\r\nif (params_channels(params) == 1 && (val & ARIZONA_AIF1_FMT_MASK)) {\r\narizona_aif_dbg(dai, "Forcing stereo mode\n");\r\nbclk_target *= 2;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(arizona_44k1_bclk_rates); i++) {\r\nif (rates[i] >= bclk_target &&\r\nrates[i] % params_rate(params) == 0) {\r\nbclk = i;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(arizona_44k1_bclk_rates)) {\r\narizona_aif_err(dai, "Unsupported sample rate %dHz\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nlrclk = rates[bclk] / params_rate(params);\r\narizona_aif_dbg(dai, "BCLK %dHz LRCLK %dHz\n",\r\nrates[bclk], rates[bclk] / lrclk);\r\nwl = snd_pcm_format_width(params_format(params));\r\nframe = wl << ARIZONA_AIF1TX_WL_SHIFT | wl;\r\nret = arizona_hw_params_rate(substream, params, dai);\r\nif (ret != 0)\r\nreturn ret;\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_BCLK_CTRL,\r\nARIZONA_AIF1_BCLK_FREQ_MASK, bclk);\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_TX_BCLK_RATE,\r\nARIZONA_AIF1TX_BCPF_MASK, lrclk);\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_RX_BCLK_RATE,\r\nARIZONA_AIF1RX_BCPF_MASK, lrclk);\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_FRAME_CTRL_1,\r\nARIZONA_AIF1TX_WL_MASK |\r\nARIZONA_AIF1TX_SLOT_LEN_MASK, frame);\r\nregmap_update_bits(arizona->regmap, base + ARIZONA_AIF_FRAME_CTRL_2,\r\nARIZONA_AIF1RX_WL_MASK |\r\nARIZONA_AIF1RX_SLOT_LEN_MASK, frame);\r\nreturn 0;\r\n}\r\nstatic const char *arizona_dai_clk_str(int clk_id)\r\n{\r\nswitch (clk_id) {\r\ncase ARIZONA_CLK_SYSCLK:\r\nreturn "SYSCLK";\r\ncase ARIZONA_CLK_ASYNCCLK:\r\nreturn "ASYNCCLK";\r\ndefault:\r\nreturn "Unknown clock";\r\n}\r\n}\r\nstatic int arizona_dai_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona_dai_priv *dai_priv = &priv->dai[dai->id - 1];\r\nstruct snd_soc_dapm_route routes[2];\r\nswitch (clk_id) {\r\ncase ARIZONA_CLK_SYSCLK:\r\ncase ARIZONA_CLK_ASYNCCLK:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (clk_id == dai_priv->clk)\r\nreturn 0;\r\nif (dai->active) {\r\ndev_err(codec->dev, "Can't change clock on active DAI %d\n",\r\ndai->id);\r\nreturn -EBUSY;\r\n}\r\ndev_dbg(codec->dev, "Setting AIF%d to %s\n", dai->id + 1,\r\narizona_dai_clk_str(clk_id));\r\nmemset(&routes, 0, sizeof(routes));\r\nroutes[0].sink = dai->driver->capture.stream_name;\r\nroutes[1].sink = dai->driver->playback.stream_name;\r\nroutes[0].source = arizona_dai_clk_str(dai_priv->clk);\r\nroutes[1].source = arizona_dai_clk_str(dai_priv->clk);\r\nsnd_soc_dapm_del_routes(&codec->dapm, routes, ARRAY_SIZE(routes));\r\nroutes[0].source = arizona_dai_clk_str(clk_id);\r\nroutes[1].source = arizona_dai_clk_str(clk_id);\r\nsnd_soc_dapm_add_routes(&codec->dapm, routes, ARRAY_SIZE(routes));\r\ndai_priv->clk = clk_id;\r\nreturn snd_soc_dapm_sync(&codec->dapm);\r\n}\r\nstatic int arizona_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint base = dai->driver->base;\r\nunsigned int reg;\r\nif (tristate)\r\nreg = ARIZONA_AIF1_TRI;\r\nelse\r\nreg = 0;\r\nreturn snd_soc_update_bits(codec, base + ARIZONA_AIF_RATE_CTRL,\r\nARIZONA_AIF1_TRI, reg);\r\n}\r\nint arizona_init_dai(struct arizona_priv *priv, int id)\r\n{\r\nstruct arizona_dai_priv *dai_priv = &priv->dai[id];\r\ndai_priv->clk = ARIZONA_CLK_SYSCLK;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t arizona_fll_clock_ok(int irq, void *data)\r\n{\r\nstruct arizona_fll *fll = data;\r\narizona_fll_dbg(fll, "clock OK\n");\r\ncomplete(&fll->ok);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int arizona_validate_fll(struct arizona_fll *fll,\r\nunsigned int Fref,\r\nunsigned int Fout)\r\n{\r\nunsigned int Fvco_min;\r\nif (Fref / ARIZONA_FLL_MAX_REFDIV > ARIZONA_FLL_MAX_FREF) {\r\narizona_fll_err(fll,\r\n"Can't scale %dMHz in to <=13.5MHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\nFvco_min = ARIZONA_FLL_MIN_FVCO * fll->vco_mult;\r\nif (Fout * ARIZONA_FLL_MAX_OUTDIV < Fvco_min) {\r\narizona_fll_err(fll, "No FLL_OUTDIV for Fout=%uHz\n",\r\nFout);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int arizona_find_fratio(unsigned int Fref, int *fratio)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\r\nif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\r\nif (fratio)\r\n*fratio = fll_fratios[i].fratio;\r\nreturn fll_fratios[i].ratio;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int arizona_calc_fratio(struct arizona_fll *fll,\r\nstruct arizona_fll_cfg *cfg,\r\nunsigned int target,\r\nunsigned int Fref, bool sync)\r\n{\r\nint init_ratio, ratio;\r\nint refdiv, div;\r\ndiv = 1;\r\ncfg->refdiv = 0;\r\nwhile (Fref > ARIZONA_FLL_MAX_FREF) {\r\ndiv *= 2;\r\nFref /= 2;\r\ncfg->refdiv++;\r\nif (div > ARIZONA_FLL_MAX_REFDIV)\r\nreturn -EINVAL;\r\n}\r\ninit_ratio = arizona_find_fratio(Fref, &cfg->fratio);\r\nif (init_ratio < 0) {\r\narizona_fll_err(fll, "Unable to find FRATIO for Fref=%uHz\n",\r\nFref);\r\nreturn init_ratio;\r\n}\r\nswitch (fll->arizona->type) {\r\ncase WM5110:\r\nif (fll->arizona->rev < 3 || sync)\r\nreturn init_ratio;\r\nbreak;\r\ndefault:\r\nreturn init_ratio;\r\n}\r\ncfg->fratio = init_ratio - 1;\r\nrefdiv = cfg->refdiv;\r\nwhile (div <= ARIZONA_FLL_MAX_REFDIV) {\r\nfor (ratio = init_ratio; ratio <= ARIZONA_FLL_MAX_FRATIO;\r\nratio++) {\r\nif (target % (ratio * Fref)) {\r\ncfg->refdiv = refdiv;\r\ncfg->fratio = ratio - 1;\r\nreturn ratio;\r\n}\r\n}\r\nfor (ratio = init_ratio - 1; ratio >= 0; ratio--) {\r\nif (ARIZONA_FLL_VCO_CORNER / (fll->vco_mult * ratio) <\r\nFref)\r\nbreak;\r\nif (target % (ratio * Fref)) {\r\ncfg->refdiv = refdiv;\r\ncfg->fratio = ratio - 1;\r\nreturn ratio;\r\n}\r\n}\r\ndiv *= 2;\r\nFref /= 2;\r\nrefdiv++;\r\ninit_ratio = arizona_find_fratio(Fref, NULL);\r\n}\r\narizona_fll_warn(fll, "Falling back to integer mode operation\n");\r\nreturn cfg->fratio + 1;\r\n}\r\nstatic int arizona_calc_fll(struct arizona_fll *fll,\r\nstruct arizona_fll_cfg *cfg,\r\nunsigned int Fref, bool sync)\r\n{\r\nunsigned int target, div, gcd_fll;\r\nint i, ratio;\r\narizona_fll_dbg(fll, "Fref=%u Fout=%u\n", Fref, fll->fout);\r\ndiv = ARIZONA_FLL_MIN_OUTDIV;\r\nwhile (fll->fout * div < ARIZONA_FLL_MIN_FVCO * fll->vco_mult) {\r\ndiv++;\r\nif (div > ARIZONA_FLL_MAX_OUTDIV)\r\nreturn -EINVAL;\r\n}\r\ntarget = fll->fout * div / fll->vco_mult;\r\ncfg->outdiv = div;\r\narizona_fll_dbg(fll, "Fvco=%dHz\n", target);\r\nratio = arizona_calc_fratio(fll, cfg, target, Fref, sync);\r\nif (ratio < 0)\r\nreturn ratio;\r\nFref = Fref / (1 << cfg->refdiv);\r\ncfg->n = target / (ratio * Fref);\r\nif (target % (ratio * Fref)) {\r\ngcd_fll = gcd(target, ratio * Fref);\r\narizona_fll_dbg(fll, "GCD=%u\n", gcd_fll);\r\ncfg->theta = (target - (cfg->n * ratio * Fref))\r\n/ gcd_fll;\r\ncfg->lambda = (ratio * Fref) / gcd_fll;\r\n} else {\r\ncfg->theta = 0;\r\ncfg->lambda = 0;\r\n}\r\nwhile (cfg->lambda >= (1 << 16)) {\r\ncfg->theta >>= 1;\r\ncfg->lambda >>= 1;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(fll_gains); i++) {\r\nif (fll_gains[i].min <= Fref && Fref <= fll_gains[i].max) {\r\ncfg->gain = fll_gains[i].gain;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(fll_gains)) {\r\narizona_fll_err(fll, "Unable to find gain for Fref=%uHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\narizona_fll_dbg(fll, "N=%x THETA=%x LAMBDA=%x\n",\r\ncfg->n, cfg->theta, cfg->lambda);\r\narizona_fll_dbg(fll, "FRATIO=%x(%d) OUTDIV=%x REFCLK_DIV=%x\n",\r\ncfg->fratio, cfg->fratio, cfg->outdiv, cfg->refdiv);\r\narizona_fll_dbg(fll, "GAIN=%d\n", cfg->gain);\r\nreturn 0;\r\n}\r\nstatic void arizona_apply_fll(struct arizona *arizona, unsigned int base,\r\nstruct arizona_fll_cfg *cfg, int source,\r\nbool sync)\r\n{\r\nregmap_update_bits_async(arizona->regmap, base + 3,\r\nARIZONA_FLL1_THETA_MASK, cfg->theta);\r\nregmap_update_bits_async(arizona->regmap, base + 4,\r\nARIZONA_FLL1_LAMBDA_MASK, cfg->lambda);\r\nregmap_update_bits_async(arizona->regmap, base + 5,\r\nARIZONA_FLL1_FRATIO_MASK,\r\ncfg->fratio << ARIZONA_FLL1_FRATIO_SHIFT);\r\nregmap_update_bits_async(arizona->regmap, base + 6,\r\nARIZONA_FLL1_CLK_REF_DIV_MASK |\r\nARIZONA_FLL1_CLK_REF_SRC_MASK,\r\ncfg->refdiv << ARIZONA_FLL1_CLK_REF_DIV_SHIFT |\r\nsource << ARIZONA_FLL1_CLK_REF_SRC_SHIFT);\r\nif (sync) {\r\nregmap_update_bits(arizona->regmap, base + 0x7,\r\nARIZONA_FLL1_GAIN_MASK,\r\ncfg->gain << ARIZONA_FLL1_GAIN_SHIFT);\r\n} else {\r\nregmap_update_bits(arizona->regmap, base + 0x5,\r\nARIZONA_FLL1_OUTDIV_MASK,\r\ncfg->outdiv << ARIZONA_FLL1_OUTDIV_SHIFT);\r\nregmap_update_bits(arizona->regmap, base + 0x9,\r\nARIZONA_FLL1_GAIN_MASK,\r\ncfg->gain << ARIZONA_FLL1_GAIN_SHIFT);\r\n}\r\nregmap_update_bits_async(arizona->regmap, base + 2,\r\nARIZONA_FLL1_CTRL_UPD | ARIZONA_FLL1_N_MASK,\r\nARIZONA_FLL1_CTRL_UPD | cfg->n);\r\n}\r\nstatic bool arizona_is_enabled_fll(struct arizona_fll *fll)\r\n{\r\nstruct arizona *arizona = fll->arizona;\r\nunsigned int reg;\r\nint ret;\r\nret = regmap_read(arizona->regmap, fll->base + 1, &reg);\r\nif (ret != 0) {\r\narizona_fll_err(fll, "Failed to read current state: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn reg & ARIZONA_FLL1_ENA;\r\n}\r\nstatic void arizona_enable_fll(struct arizona_fll *fll)\r\n{\r\nstruct arizona *arizona = fll->arizona;\r\nint ret;\r\nbool use_sync = false;\r\nstruct arizona_fll_cfg cfg;\r\nif (fll->ref_src >= 0 && fll->ref_freq &&\r\nfll->ref_src != fll->sync_src) {\r\narizona_calc_fll(fll, &cfg, fll->ref_freq, false);\r\narizona_apply_fll(arizona, fll->base, &cfg, fll->ref_src,\r\nfalse);\r\nif (fll->sync_src >= 0) {\r\narizona_calc_fll(fll, &cfg, fll->sync_freq, true);\r\narizona_apply_fll(arizona, fll->base + 0x10, &cfg,\r\nfll->sync_src, true);\r\nuse_sync = true;\r\n}\r\n} else if (fll->sync_src >= 0) {\r\narizona_calc_fll(fll, &cfg, fll->sync_freq, false);\r\narizona_apply_fll(arizona, fll->base, &cfg,\r\nfll->sync_src, false);\r\nregmap_update_bits_async(arizona->regmap, fll->base + 0x11,\r\nARIZONA_FLL1_SYNC_ENA, 0);\r\n} else {\r\narizona_fll_err(fll, "No clocks provided\n");\r\nreturn;\r\n}\r\nif (use_sync && fll->sync_freq > 100000)\r\nregmap_update_bits_async(arizona->regmap, fll->base + 0x17,\r\nARIZONA_FLL1_SYNC_BW, 0);\r\nelse\r\nregmap_update_bits_async(arizona->regmap, fll->base + 0x17,\r\nARIZONA_FLL1_SYNC_BW,\r\nARIZONA_FLL1_SYNC_BW);\r\nif (!arizona_is_enabled_fll(fll))\r\npm_runtime_get(arizona->dev);\r\ntry_wait_for_completion(&fll->ok);\r\nregmap_update_bits_async(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_FREERUN, 0);\r\nregmap_update_bits_async(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_ENA, ARIZONA_FLL1_ENA);\r\nif (use_sync)\r\nregmap_update_bits_async(arizona->regmap, fll->base + 0x11,\r\nARIZONA_FLL1_SYNC_ENA,\r\nARIZONA_FLL1_SYNC_ENA);\r\nret = wait_for_completion_timeout(&fll->ok,\r\nmsecs_to_jiffies(250));\r\nif (ret == 0)\r\narizona_fll_warn(fll, "Timed out waiting for lock\n");\r\n}\r\nstatic void arizona_disable_fll(struct arizona_fll *fll)\r\n{\r\nstruct arizona *arizona = fll->arizona;\r\nbool change;\r\nregmap_update_bits_async(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_FREERUN, ARIZONA_FLL1_FREERUN);\r\nregmap_update_bits_check(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_ENA, 0, &change);\r\nregmap_update_bits(arizona->regmap, fll->base + 0x11,\r\nARIZONA_FLL1_SYNC_ENA, 0);\r\nif (change)\r\npm_runtime_put_autosuspend(arizona->dev);\r\n}\r\nint arizona_set_fll_refclk(struct arizona_fll *fll, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nint ret;\r\nif (fll->ref_src == source && fll->ref_freq == Fref)\r\nreturn 0;\r\nif (fll->fout && Fref > 0) {\r\nret = arizona_validate_fll(fll, Fref, fll->fout);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nfll->ref_src = source;\r\nfll->ref_freq = Fref;\r\nif (fll->fout && Fref > 0) {\r\narizona_enable_fll(fll);\r\n}\r\nreturn 0;\r\n}\r\nint arizona_set_fll(struct arizona_fll *fll, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nint ret;\r\nif (fll->sync_src == source &&\r\nfll->sync_freq == Fref && fll->fout == Fout)\r\nreturn 0;\r\nif (Fout) {\r\nif (fll->ref_src >= 0) {\r\nret = arizona_validate_fll(fll, fll->ref_freq, Fout);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nret = arizona_validate_fll(fll, Fref, Fout);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nfll->sync_src = source;\r\nfll->sync_freq = Fref;\r\nfll->fout = Fout;\r\nif (Fout) {\r\narizona_enable_fll(fll);\r\n} else {\r\narizona_disable_fll(fll);\r\n}\r\nreturn 0;\r\n}\r\nint arizona_init_fll(struct arizona *arizona, int id, int base, int lock_irq,\r\nint ok_irq, struct arizona_fll *fll)\r\n{\r\nint ret;\r\nunsigned int val;\r\ninit_completion(&fll->ok);\r\nfll->id = id;\r\nfll->base = base;\r\nfll->arizona = arizona;\r\nfll->sync_src = ARIZONA_FLL_SRC_NONE;\r\nregmap_read(arizona->regmap, ARIZONA_CLOCK_32K_1, &val);\r\nswitch (val & ARIZONA_CLK_32K_SRC_MASK) {\r\ncase ARIZONA_CLK_SRC_MCLK1:\r\ncase ARIZONA_CLK_SRC_MCLK2:\r\nfll->ref_src = val & ARIZONA_CLK_32K_SRC_MASK;\r\nbreak;\r\ndefault:\r\nfll->ref_src = ARIZONA_FLL_SRC_NONE;\r\n}\r\nfll->ref_freq = 32768;\r\nsnprintf(fll->lock_name, sizeof(fll->lock_name), "FLL%d lock", id);\r\nsnprintf(fll->clock_ok_name, sizeof(fll->clock_ok_name),\r\n"FLL%d clock OK", id);\r\nret = arizona_request_irq(arizona, ok_irq, fll->clock_ok_name,\r\narizona_fll_clock_ok, fll);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to get FLL%d clock OK IRQ: %d\n",\r\nid, ret);\r\n}\r\nregmap_update_bits(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_FREERUN, 0);\r\nreturn 0;\r\n}\r\nint arizona_set_output_mode(struct snd_soc_codec *codec, int output, bool diff)\r\n{\r\nunsigned int reg, val;\r\nif (output < 1 || output > 6)\r\nreturn -EINVAL;\r\nreg = ARIZONA_OUTPUT_PATH_CONFIG_1L + (output - 1) * 8;\r\nif (diff)\r\nval = ARIZONA_OUT1_MONO;\r\nelse\r\nval = 0;\r\nreturn snd_soc_update_bits(codec, reg, ARIZONA_OUT1_MONO, val);\r\n}
