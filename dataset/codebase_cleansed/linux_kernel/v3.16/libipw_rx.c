static void libipw_monitor_rx(struct libipw_device *ieee,\r\nstruct sk_buff *skb,\r\nstruct libipw_rx_stats *rx_stats)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nu16 fc = le16_to_cpu(hdr->frame_control);\r\nskb->dev = ieee->dev;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, libipw_get_hdrlen(fc));\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_80211_RAW);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\n}\r\nstatic struct libipw_frag_entry *libipw_frag_cache_find(struct\r\nlibipw_device\r\n*ieee,\r\nunsigned int seq,\r\nunsigned int frag,\r\nu8 * src,\r\nu8 * dst)\r\n{\r\nstruct libipw_frag_entry *entry;\r\nint i;\r\nfor (i = 0; i < LIBIPW_FRAG_CACHE_LEN; i++) {\r\nentry = &ieee->frag_cache[i];\r\nif (entry->skb != NULL &&\r\ntime_after(jiffies, entry->first_frag_time + 2 * HZ)) {\r\nLIBIPW_DEBUG_FRAG("expiring fragment cache entry "\r\n"seq=%u last_frag=%u\n",\r\nentry->seq, entry->last_frag);\r\ndev_kfree_skb_any(entry->skb);\r\nentry->skb = NULL;\r\n}\r\nif (entry->skb != NULL && entry->seq == seq &&\r\n(entry->last_frag + 1 == frag || frag == -1) &&\r\nether_addr_equal(entry->src_addr, src) &&\r\nether_addr_equal(entry->dst_addr, dst))\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *libipw_frag_cache_get(struct libipw_device *ieee,\r\nstruct libipw_hdr_4addr *hdr)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nu16 sc;\r\nunsigned int frag, seq;\r\nstruct libipw_frag_entry *entry;\r\nsc = le16_to_cpu(hdr->seq_ctl);\r\nfrag = WLAN_GET_SEQ_FRAG(sc);\r\nseq = WLAN_GET_SEQ_SEQ(sc);\r\nif (frag == 0) {\r\nskb = dev_alloc_skb(ieee->dev->mtu +\r\nsizeof(struct libipw_hdr_4addr) +\r\n8 +\r\n2 +\r\n8 + ETH_ALEN );\r\nif (skb == NULL)\r\nreturn NULL;\r\nentry = &ieee->frag_cache[ieee->frag_next_idx];\r\nieee->frag_next_idx++;\r\nif (ieee->frag_next_idx >= LIBIPW_FRAG_CACHE_LEN)\r\nieee->frag_next_idx = 0;\r\nif (entry->skb != NULL)\r\ndev_kfree_skb_any(entry->skb);\r\nentry->first_frag_time = jiffies;\r\nentry->seq = seq;\r\nentry->last_frag = frag;\r\nentry->skb = skb;\r\nmemcpy(entry->src_addr, hdr->addr2, ETH_ALEN);\r\nmemcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);\r\n} else {\r\nentry = libipw_frag_cache_find(ieee, seq, frag, hdr->addr2,\r\nhdr->addr1);\r\nif (entry != NULL) {\r\nentry->last_frag = frag;\r\nskb = entry->skb;\r\n}\r\n}\r\nreturn skb;\r\n}\r\nstatic int libipw_frag_cache_invalidate(struct libipw_device *ieee,\r\nstruct libipw_hdr_4addr *hdr)\r\n{\r\nu16 sc;\r\nunsigned int seq;\r\nstruct libipw_frag_entry *entry;\r\nsc = le16_to_cpu(hdr->seq_ctl);\r\nseq = WLAN_GET_SEQ_SEQ(sc);\r\nentry = libipw_frag_cache_find(ieee, seq, -1, hdr->addr2,\r\nhdr->addr1);\r\nif (entry == NULL) {\r\nLIBIPW_DEBUG_FRAG("could not invalidate fragment cache "\r\n"entry (seq=%u)\n", seq);\r\nreturn -1;\r\n}\r\nentry->skb = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nlibipw_rx_frame_mgmt(struct libipw_device *ieee, struct sk_buff *skb,\r\nstruct libipw_rx_stats *rx_stats, u16 type,\r\nu16 stype)\r\n{\r\nif (ieee->iw_mode == IW_MODE_MASTER) {\r\nprintk(KERN_DEBUG "%s: Master mode not yet supported.\n",\r\nieee->dev->name);\r\nreturn 0;\r\n}\r\nif (ieee->hostapd && type == WLAN_FC_TYPE_MGMT) {\r\nif (stype == WLAN_FC_STYPE_BEACON &&\r\nieee->iw_mode == IW_MODE_MASTER) {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (skb2)\r\nhostap_rx(skb2->dev, skb2, rx_stats);\r\n}\r\nieee->apdevstats.rx_packets++;\r\nieee->apdevstats.rx_bytes += skb->len;\r\nprism2_rx_80211(ieee->apdev, skb, rx_stats, PRISM2_RX_MGMT);\r\nreturn 0;\r\n}\r\nif (ieee->iw_mode == IW_MODE_MASTER) {\r\nif (type != WLAN_FC_TYPE_MGMT && type != WLAN_FC_TYPE_CTRL) {\r\nprintk(KERN_DEBUG "%s: unknown management frame "\r\n"(type=0x%02x, stype=0x%02x) dropped\n",\r\nskb->dev->name, type, stype);\r\nreturn -1;\r\n}\r\nhostap_rx(skb->dev, skb, rx_stats);\r\nreturn 0;\r\n}\r\nprintk(KERN_DEBUG "%s: hostap_rx_frame_mgmt: management frame "\r\n"received in non-Host AP mode\n", skb->dev->name);\r\nreturn -1;\r\n}\r\nstatic int libipw_is_eapol_frame(struct libipw_device *ieee,\r\nstruct sk_buff *skb)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nu16 fc, ethertype;\r\nstruct libipw_hdr_3addr *hdr;\r\nu8 *pos;\r\nif (skb->len < 24)\r\nreturn 0;\r\nhdr = (struct libipw_hdr_3addr *)skb->data;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\nif ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_TODS &&\r\nether_addr_equal(hdr->addr1, dev->dev_addr) &&\r\nether_addr_equal(hdr->addr3, dev->dev_addr)) {\r\n} else if ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_FROMDS &&\r\nether_addr_equal(hdr->addr1, dev->dev_addr)) {\r\n} else\r\nreturn 0;\r\nif (skb->len < 24 + 8)\r\nreturn 0;\r\npos = skb->data + 24;\r\nethertype = (pos[6] << 8) | pos[7];\r\nif (ethertype == ETH_P_PAE)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nlibipw_rx_frame_decrypt(struct libipw_device *ieee, struct sk_buff *skb,\r\nstruct lib80211_crypt_data *crypt)\r\n{\r\nstruct libipw_hdr_3addr *hdr;\r\nint res, hdrlen;\r\nif (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)\r\nreturn 0;\r\nhdr = (struct libipw_hdr_3addr *)skb->data;\r\nhdrlen = libipw_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\r\natomic_inc(&crypt->refcnt);\r\nres = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nLIBIPW_DEBUG_DROP("decryption failed (SA=%pM) res=%d\n",\r\nhdr->addr2, res);\r\nif (res == -2)\r\nLIBIPW_DEBUG_DROP("Decryption failed ICV "\r\n"mismatch (key %d)\n",\r\nskb->data[hdrlen + 3] >> 6);\r\nieee->ieee_stats.rx_discards_undecryptable++;\r\nreturn -1;\r\n}\r\nreturn res;\r\n}\r\nstatic int\r\nlibipw_rx_frame_decrypt_msdu(struct libipw_device *ieee,\r\nstruct sk_buff *skb, int keyidx,\r\nstruct lib80211_crypt_data *crypt)\r\n{\r\nstruct libipw_hdr_3addr *hdr;\r\nint res, hdrlen;\r\nif (crypt == NULL || crypt->ops->decrypt_msdu == NULL)\r\nreturn 0;\r\nhdr = (struct libipw_hdr_3addr *)skb->data;\r\nhdrlen = libipw_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\r\natomic_inc(&crypt->refcnt);\r\nres = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nprintk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed"\r\n" (SA=%pM keyidx=%d)\n", ieee->dev->name, hdr->addr2,\r\nkeyidx);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint libipw_rx(struct libipw_device *ieee, struct sk_buff *skb,\r\nstruct libipw_rx_stats *rx_stats)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nstruct libipw_hdr_4addr *hdr;\r\nsize_t hdrlen;\r\nu16 fc, type, stype, sc;\r\nunsigned int frag;\r\nu8 *payload;\r\nu16 ethertype;\r\n#ifdef NOT_YET\r\nstruct net_device *wds = NULL;\r\nstruct sk_buff *skb2 = NULL;\r\nstruct net_device *wds = NULL;\r\nint frame_authorized = 0;\r\nint from_assoc_ap = 0;\r\nvoid *sta = NULL;\r\n#endif\r\nu8 dst[ETH_ALEN];\r\nu8 src[ETH_ALEN];\r\nstruct lib80211_crypt_data *crypt = NULL;\r\nint keyidx = 0;\r\nint can_be_decrypted = 0;\r\nhdr = (struct libipw_hdr_4addr *)skb->data;\r\nif (skb->len < 10) {\r\nprintk(KERN_INFO "%s: SKB length < 10\n", dev->name);\r\ngoto rx_dropped;\r\n}\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nstype = WLAN_FC_GET_STYPE(fc);\r\nsc = le16_to_cpu(hdr->seq_ctl);\r\nfrag = WLAN_GET_SEQ_FRAG(sc);\r\nhdrlen = libipw_get_hdrlen(fc);\r\nif (skb->len < hdrlen) {\r\nprintk(KERN_INFO "%s: invalid SKB length %d\n",\r\ndev->name, skb->len);\r\ngoto rx_dropped;\r\n}\r\n#ifdef CONFIG_WIRELESS_EXT\r\n#ifdef IW_WIRELESS_SPY\r\nif (ieee->spy_data.spy_number > 0) {\r\nstruct iw_quality wstats;\r\nwstats.updated = 0;\r\nif (rx_stats->mask & LIBIPW_STATMASK_RSSI) {\r\nwstats.level = rx_stats->signal;\r\nwstats.updated |= IW_QUAL_LEVEL_UPDATED;\r\n} else\r\nwstats.updated |= IW_QUAL_LEVEL_INVALID;\r\nif (rx_stats->mask & LIBIPW_STATMASK_NOISE) {\r\nwstats.noise = rx_stats->noise;\r\nwstats.updated |= IW_QUAL_NOISE_UPDATED;\r\n} else\r\nwstats.updated |= IW_QUAL_NOISE_INVALID;\r\nif (rx_stats->mask & LIBIPW_STATMASK_SIGNAL) {\r\nwstats.qual = rx_stats->signal;\r\nwstats.updated |= IW_QUAL_QUAL_UPDATED;\r\n} else\r\nwstats.updated |= IW_QUAL_QUAL_INVALID;\r\nwireless_spy_update(ieee->dev, hdr->addr2, &wstats);\r\n}\r\n#endif\r\n#endif\r\n#ifdef NOT_YET\r\nhostap_update_rx_stats(local->ap, hdr, rx_stats);\r\n#endif\r\nif (ieee->iw_mode == IW_MODE_MONITOR) {\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nlibipw_monitor_rx(ieee, skb, rx_stats);\r\nreturn 1;\r\n}\r\ncan_be_decrypted = (is_multicast_ether_addr(hdr->addr1) ||\r\nis_broadcast_ether_addr(hdr->addr2)) ?\r\nieee->host_mc_decrypt : ieee->host_decrypt;\r\nif (can_be_decrypted) {\r\nif (skb->len >= hdrlen + 3) {\r\nkeyidx = skb->data[hdrlen + 3] >> 6;\r\n}\r\ncrypt = ieee->crypt_info.crypt[keyidx];\r\n#ifdef NOT_YET\r\nsta = NULL;\r\nif (is_unicast_ether_addr(hdr->addr1) || local->bcrx_sta_key)\r\n(void)hostap_handle_sta_crypto(local, hdr, &crypt,\r\n&sta);\r\n#endif\r\nif (crypt && (crypt->ops == NULL ||\r\ncrypt->ops->decrypt_mpdu == NULL))\r\ncrypt = NULL;\r\nif (!crypt && (fc & IEEE80211_FCTL_PROTECTED)) {\r\nLIBIPW_DEBUG_DROP("Decryption failed (not set)"\r\n" (SA=%pM)\n", hdr->addr2);\r\nieee->ieee_stats.rx_discards_undecryptable++;\r\ngoto rx_dropped;\r\n}\r\n}\r\n#ifdef NOT_YET\r\nif (type != WLAN_FC_TYPE_DATA) {\r\nif (type == WLAN_FC_TYPE_MGMT && stype == WLAN_FC_STYPE_AUTH &&\r\nfc & IEEE80211_FCTL_PROTECTED && ieee->host_decrypt &&\r\n(keyidx = hostap_rx_frame_decrypt(ieee, skb, crypt)) < 0) {\r\nprintk(KERN_DEBUG "%s: failed to decrypt mgmt::auth "\r\n"from %pM\n", dev->name, hdr->addr2);\r\ngoto rx_dropped;\r\n}\r\nif (libipw_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\r\ngoto rx_dropped;\r\nelse\r\ngoto rx_exit;\r\n}\r\n#endif\r\nif (sc == ieee->prev_seq_ctl)\r\ngoto rx_dropped;\r\nelse\r\nieee->prev_seq_ctl = sc;\r\nif (skb->len < LIBIPW_3ADDR_LEN)\r\ngoto rx_dropped;\r\nswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\r\ncase IEEE80211_FCTL_FROMDS:\r\nmemcpy(dst, hdr->addr1, ETH_ALEN);\r\nmemcpy(src, hdr->addr3, ETH_ALEN);\r\nbreak;\r\ncase IEEE80211_FCTL_TODS:\r\nmemcpy(dst, hdr->addr3, ETH_ALEN);\r\nmemcpy(src, hdr->addr2, ETH_ALEN);\r\nbreak;\r\ncase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\r\nif (skb->len < LIBIPW_4ADDR_LEN)\r\ngoto rx_dropped;\r\nmemcpy(dst, hdr->addr3, ETH_ALEN);\r\nmemcpy(src, hdr->addr4, ETH_ALEN);\r\nbreak;\r\ncase 0:\r\nmemcpy(dst, hdr->addr1, ETH_ALEN);\r\nmemcpy(src, hdr->addr2, ETH_ALEN);\r\nbreak;\r\n}\r\n#ifdef NOT_YET\r\nif (hostap_rx_frame_wds(ieee, hdr, fc, &wds))\r\ngoto rx_dropped;\r\nif (wds) {\r\nskb->dev = dev = wds;\r\nstats = hostap_get_stats(dev);\r\n}\r\nif (ieee->iw_mode == IW_MODE_MASTER && !wds &&\r\n(fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_FROMDS && ieee->stadev &&\r\nether_addr_equal(hdr->addr2, ieee->assoc_ap_addr)) {\r\nskb->dev = dev = ieee->stadev;\r\nstats = hostap_get_stats(dev);\r\nfrom_assoc_ap = 1;\r\n}\r\n#endif\r\n#ifdef NOT_YET\r\nif ((ieee->iw_mode == IW_MODE_MASTER ||\r\nieee->iw_mode == IW_MODE_REPEAT) && !from_assoc_ap) {\r\nswitch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,\r\nwds != NULL)) {\r\ncase AP_RX_CONTINUE_NOT_AUTHORIZED:\r\nframe_authorized = 0;\r\nbreak;\r\ncase AP_RX_CONTINUE:\r\nframe_authorized = 1;\r\nbreak;\r\ncase AP_RX_DROP:\r\ngoto rx_dropped;\r\ncase AP_RX_EXIT:\r\ngoto rx_exit;\r\n}\r\n}\r\n#endif\r\nstype &= ~IEEE80211_STYPE_QOS_DATA;\r\nif (stype != IEEE80211_STYPE_DATA &&\r\nstype != IEEE80211_STYPE_DATA_CFACK &&\r\nstype != IEEE80211_STYPE_DATA_CFPOLL &&\r\nstype != IEEE80211_STYPE_DATA_CFACKPOLL) {\r\nif (stype != IEEE80211_STYPE_NULLFUNC)\r\nLIBIPW_DEBUG_DROP("RX: dropped data frame "\r\n"with no data (type=0x%02x, "\r\n"subtype=0x%02x, len=%d)\n",\r\ntype, stype, skb->len);\r\ngoto rx_dropped;\r\n}\r\nif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\r\n(keyidx = libipw_rx_frame_decrypt(ieee, skb, crypt)) < 0)\r\ngoto rx_dropped;\r\nhdr = (struct libipw_hdr_4addr *)skb->data;\r\nif ((frag != 0) || (fc & IEEE80211_FCTL_MOREFRAGS)) {\r\nint flen;\r\nstruct sk_buff *frag_skb = libipw_frag_cache_get(ieee, hdr);\r\nLIBIPW_DEBUG_FRAG("Rx Fragment received (%u)\n", frag);\r\nif (!frag_skb) {\r\nLIBIPW_DEBUG(LIBIPW_DL_RX | LIBIPW_DL_FRAG,\r\n"Rx cannot get skb from fragment "\r\n"cache (morefrag=%d seq=%u frag=%u)\n",\r\n(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\r\nWLAN_GET_SEQ_SEQ(sc), frag);\r\ngoto rx_dropped;\r\n}\r\nflen = skb->len;\r\nif (frag != 0)\r\nflen -= hdrlen;\r\nif (frag_skb->tail + flen > frag_skb->end) {\r\nprintk(KERN_WARNING "%s: host decrypted and "\r\n"reassembled frame did not fit skb\n",\r\ndev->name);\r\nlibipw_frag_cache_invalidate(ieee, hdr);\r\ngoto rx_dropped;\r\n}\r\nif (frag == 0) {\r\nskb_copy_from_linear_data(skb, skb_put(frag_skb, flen), flen);\r\n} else {\r\nskb_copy_from_linear_data_offset(skb, hdrlen,\r\nskb_put(frag_skb, flen), flen);\r\n}\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nif (fc & IEEE80211_FCTL_MOREFRAGS) {\r\ngoto rx_exit;\r\n}\r\nskb = frag_skb;\r\nhdr = (struct libipw_hdr_4addr *)skb->data;\r\nlibipw_frag_cache_invalidate(ieee, hdr);\r\n}\r\nif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\r\nlibipw_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))\r\ngoto rx_dropped;\r\nhdr = (struct libipw_hdr_4addr *)skb->data;\r\nif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep) {\r\nif (\r\nlibipw_is_eapol_frame(ieee, skb)) {\r\n} else {\r\nLIBIPW_DEBUG_DROP("encryption configured, but RX "\r\n"frame not encrypted (SA=%pM)\n",\r\nhdr->addr2);\r\ngoto rx_dropped;\r\n}\r\n}\r\nif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep &&\r\n!libipw_is_eapol_frame(ieee, skb)) {\r\nLIBIPW_DEBUG_DROP("dropped unencrypted RX data "\r\n"frame from %pM (drop_unencrypted=1)\n",\r\nhdr->addr2);\r\ngoto rx_dropped;\r\n}\r\nif (!can_be_decrypted && (fc & IEEE80211_FCTL_PROTECTED) &&\r\nieee->host_strip_iv_icv) {\r\nint trimlen = 0;\r\nif (skb->len >= hdrlen + 3)\r\nkeyidx = skb->data[hdrlen + 3] >> 6;\r\nswitch (ieee->sec.encode_alg[keyidx]) {\r\ncase SEC_ALG_WEP:\r\nhdrlen += 4;\r\ntrimlen = 4;\r\nbreak;\r\ncase SEC_ALG_TKIP:\r\nhdrlen += 8;\r\ntrimlen = 12;\r\nbreak;\r\ncase SEC_ALG_CCMP:\r\nhdrlen += 8;\r\ntrimlen = 8;\r\nbreak;\r\n}\r\nif (skb->len < trimlen)\r\ngoto rx_dropped;\r\n__skb_trim(skb, skb->len - trimlen);\r\nif (skb->len < hdrlen)\r\ngoto rx_dropped;\r\n}\r\npayload = skb->data + hdrlen;\r\nethertype = (payload[6] << 8) | payload[7];\r\n#ifdef NOT_YET\r\nif (ieee->ieee802_1x && ieee->iw_mode == IW_MODE_MASTER) {\r\nif (ethertype == ETH_P_PAE) {\r\nprintk(KERN_DEBUG "%s: RX: IEEE 802.1X frame\n",\r\ndev->name);\r\nif (ieee->hostapd && ieee->apdev) {\r\nprism2_rx_80211(ieee->apdev, skb, rx_stats,\r\nPRISM2_RX_MGMT);\r\nieee->apdevstats.rx_packets++;\r\nieee->apdevstats.rx_bytes += skb->len;\r\ngoto rx_exit;\r\n}\r\n} else if (!frame_authorized) {\r\nprintk(KERN_DEBUG "%s: dropped frame from "\r\n"unauthorized port (IEEE 802.1X): "\r\n"ethertype=0x%04x\n", dev->name, ethertype);\r\ngoto rx_dropped;\r\n}\r\n}\r\n#endif\r\nif (skb->len - hdrlen >= 8 &&\r\n((memcmp(payload, libipw_rfc1042_header, SNAP_SIZE) == 0 &&\r\nethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\r\nmemcmp(payload, libipw_bridge_tunnel_header, SNAP_SIZE) == 0)) {\r\nskb_pull(skb, hdrlen + SNAP_SIZE);\r\nmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\r\nmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\r\n} else {\r\n__be16 len;\r\nskb_pull(skb, hdrlen);\r\nlen = htons(skb->len);\r\nmemcpy(skb_push(skb, 2), &len, 2);\r\nmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\r\nmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\r\n}\r\n#ifdef NOT_YET\r\nif (wds && ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_TODS) && skb->len >= ETH_HLEN + ETH_ALEN) {\r\nskb_copy_to_linear_data_offset(skb, ETH_ALEN,\r\nskb->data + skb->len - ETH_ALEN,\r\nETH_ALEN);\r\nskb_trim(skb, skb->len - ETH_ALEN);\r\n}\r\n#endif\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\n#ifdef NOT_YET\r\nif (ieee->iw_mode == IW_MODE_MASTER && !wds && ieee->ap->bridge_packets) {\r\nif (is_multicast_ether_addr(dst)) {\r\nieee->ap->bridged_multicast++;\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (skb2 == NULL)\r\nprintk(KERN_DEBUG "%s: skb_clone failed for "\r\n"multicast frame\n", dev->name);\r\n} else if (hostap_is_sta_assoc(ieee->ap, dst)) {\r\nieee->ap->bridged_unicast++;\r\nskb2 = skb;\r\nskb = NULL;\r\n}\r\n}\r\nif (skb2 != NULL) {\r\nskb2->dev = dev;\r\nskb2->protocol = htons(ETH_P_802_3);\r\nskb_reset_mac_header(skb2);\r\nskb_reset_network_header(skb2);\r\ndev_queue_xmit(skb2);\r\n}\r\n#endif\r\nif (skb) {\r\nskb->protocol = eth_type_trans(skb, dev);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nskb->ip_summed = CHECKSUM_NONE;\r\nif (netif_rx(skb) == NET_RX_DROP) {\r\nLIBIPW_DEBUG_DROP\r\n("RX: netif_rx dropped the packet\n");\r\ndev->stats.rx_dropped++;\r\n}\r\n}\r\nrx_exit:\r\n#ifdef NOT_YET\r\nif (sta)\r\nhostap_handle_sta_release(sta);\r\n#endif\r\nreturn 1;\r\nrx_dropped:\r\ndev->stats.rx_dropped++;\r\nreturn 0;\r\n}\r\nvoid libipw_rx_any(struct libipw_device *ieee,\r\nstruct sk_buff *skb, struct libipw_rx_stats *stats)\r\n{\r\nstruct libipw_hdr_4addr *hdr;\r\nint is_packet_for_us;\r\nu16 fc;\r\nif (ieee->iw_mode == IW_MODE_MONITOR) {\r\nif (!libipw_rx(ieee, skb, stats))\r\ndev_kfree_skb_irq(skb);\r\nreturn;\r\n}\r\nif (skb->len < sizeof(struct ieee80211_hdr))\r\ngoto drop_free;\r\nhdr = (struct libipw_hdr_4addr *)skb->data;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\nif ((fc & IEEE80211_FCTL_VERS) != 0)\r\ngoto drop_free;\r\nswitch (fc & IEEE80211_FCTL_FTYPE) {\r\ncase IEEE80211_FTYPE_MGMT:\r\nif (skb->len < sizeof(struct libipw_hdr_3addr))\r\ngoto drop_free;\r\nlibipw_rx_mgt(ieee, hdr, stats);\r\ndev_kfree_skb_irq(skb);\r\nreturn;\r\ncase IEEE80211_FTYPE_DATA:\r\nbreak;\r\ncase IEEE80211_FTYPE_CTL:\r\nreturn;\r\ndefault:\r\nreturn;\r\n}\r\nis_packet_for_us = 0;\r\nswitch (ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\nif (ether_addr_equal(hdr->addr3, ieee->bssid))\r\nif ((fc & (IEEE80211_FCTL_TODS+IEEE80211_FCTL_FROMDS)) == 0) {\r\nif (ieee->dev->flags & IFF_PROMISC)\r\nis_packet_for_us = 1;\r\nelse if (ether_addr_equal(hdr->addr1, ieee->dev->dev_addr))\r\nis_packet_for_us = 1;\r\nelse if (is_multicast_ether_addr(hdr->addr1))\r\nis_packet_for_us = 1;\r\n}\r\nbreak;\r\ncase IW_MODE_INFRA:\r\nif (ether_addr_equal(hdr->addr2, ieee->bssid))\r\nif ((fc & (IEEE80211_FCTL_TODS+IEEE80211_FCTL_FROMDS)) == IEEE80211_FCTL_FROMDS) {\r\nif (ieee->dev->flags & IFF_PROMISC)\r\nis_packet_for_us = 1;\r\nelse if (ether_addr_equal(hdr->addr1, ieee->dev->dev_addr))\r\nis_packet_for_us = 1;\r\nelse if (is_multicast_ether_addr(hdr->addr1)) {\r\nif (!ether_addr_equal(hdr->addr3, ieee->dev->dev_addr))\r\nis_packet_for_us = 1;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (is_packet_for_us)\r\nif (!libipw_rx(ieee, skb, stats))\r\ndev_kfree_skb_irq(skb);\r\nreturn;\r\ndrop_free:\r\ndev_kfree_skb_irq(skb);\r\nieee->dev->stats.rx_dropped++;\r\n}\r\nstatic int libipw_verify_qos_info(struct libipw_qos_information_element\r\n*info_element, int sub_type)\r\n{\r\nif (info_element->qui_subtype != sub_type)\r\nreturn -1;\r\nif (memcmp(info_element->qui, qos_oui, QOS_OUI_LEN))\r\nreturn -1;\r\nif (info_element->qui_type != QOS_OUI_TYPE)\r\nreturn -1;\r\nif (info_element->version != QOS_VERSION_1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int libipw_read_qos_param_element(struct libipw_qos_parameter_info\r\n*element_param, struct libipw_info_element\r\n*info_element)\r\n{\r\nint ret = 0;\r\nu16 size = sizeof(struct libipw_qos_parameter_info) - 2;\r\nif ((info_element == NULL) || (element_param == NULL))\r\nreturn -1;\r\nif (info_element->id == QOS_ELEMENT_ID && info_element->len == size) {\r\nmemcpy(element_param->info_element.qui, info_element->data,\r\ninfo_element->len);\r\nelement_param->info_element.elementID = info_element->id;\r\nelement_param->info_element.length = info_element->len;\r\n} else\r\nret = -1;\r\nif (ret == 0)\r\nret = libipw_verify_qos_info(&element_param->info_element,\r\nQOS_OUI_PARAM_SUB_TYPE);\r\nreturn ret;\r\n}\r\nstatic int libipw_read_qos_info_element(struct\r\nlibipw_qos_information_element\r\n*element_info, struct libipw_info_element\r\n*info_element)\r\n{\r\nint ret = 0;\r\nu16 size = sizeof(struct libipw_qos_information_element) - 2;\r\nif (element_info == NULL)\r\nreturn -1;\r\nif (info_element == NULL)\r\nreturn -1;\r\nif ((info_element->id == QOS_ELEMENT_ID) && (info_element->len == size)) {\r\nmemcpy(element_info->qui, info_element->data,\r\ninfo_element->len);\r\nelement_info->elementID = info_element->id;\r\nelement_info->length = info_element->len;\r\n} else\r\nret = -1;\r\nif (ret == 0)\r\nret = libipw_verify_qos_info(element_info,\r\nQOS_OUI_INFO_SUB_TYPE);\r\nreturn ret;\r\n}\r\nstatic int libipw_qos_convert_ac_to_parameters(struct\r\nlibipw_qos_parameter_info\r\n*param_elm, struct\r\nlibipw_qos_parameters\r\n*qos_param)\r\n{\r\nint rc = 0;\r\nint i;\r\nstruct libipw_qos_ac_parameter *ac_params;\r\nu32 txop;\r\nu8 cw_min;\r\nu8 cw_max;\r\nfor (i = 0; i < QOS_QUEUE_NUM; i++) {\r\nac_params = &(param_elm->ac_params_record[i]);\r\nqos_param->aifs[i] = (ac_params->aci_aifsn) & 0x0F;\r\nqos_param->aifs[i] -= (qos_param->aifs[i] < 2) ? 0 : 2;\r\ncw_min = ac_params->ecw_min_max & 0x0F;\r\nqos_param->cw_min[i] = cpu_to_le16((1 << cw_min) - 1);\r\ncw_max = (ac_params->ecw_min_max & 0xF0) >> 4;\r\nqos_param->cw_max[i] = cpu_to_le16((1 << cw_max) - 1);\r\nqos_param->flag[i] =\r\n(ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;\r\ntxop = le16_to_cpu(ac_params->tx_op_limit) * 32;\r\nqos_param->tx_op_limit[i] = cpu_to_le16(txop);\r\n}\r\nreturn rc;\r\n}\r\nstatic int libipw_parse_qos_info_param_IE(struct libipw_info_element\r\n*info_element,\r\nstruct libipw_network *network)\r\n{\r\nint rc = 0;\r\nstruct libipw_qos_parameters *qos_param = NULL;\r\nstruct libipw_qos_information_element qos_info_element;\r\nrc = libipw_read_qos_info_element(&qos_info_element, info_element);\r\nif (rc == 0) {\r\nnetwork->qos_data.param_count = qos_info_element.ac_info & 0x0F;\r\nnetwork->flags |= NETWORK_HAS_QOS_INFORMATION;\r\n} else {\r\nstruct libipw_qos_parameter_info param_element;\r\nrc = libipw_read_qos_param_element(&param_element,\r\ninfo_element);\r\nif (rc == 0) {\r\nqos_param = &(network->qos_data.parameters);\r\nlibipw_qos_convert_ac_to_parameters(&param_element,\r\nqos_param);\r\nnetwork->flags |= NETWORK_HAS_QOS_PARAMETERS;\r\nnetwork->qos_data.param_count =\r\nparam_element.info_element.ac_info & 0x0F;\r\n}\r\n}\r\nif (rc == 0) {\r\nLIBIPW_DEBUG_QOS("QoS is supported\n");\r\nnetwork->qos_data.supported = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic const char *get_info_element_string(u16 id)\r\n{\r\nswitch (id) {\r\nMFIE_STRING(SSID);\r\nMFIE_STRING(SUPP_RATES);\r\nMFIE_STRING(FH_PARAMS);\r\nMFIE_STRING(DS_PARAMS);\r\nMFIE_STRING(CF_PARAMS);\r\nMFIE_STRING(TIM);\r\nMFIE_STRING(IBSS_PARAMS);\r\nMFIE_STRING(COUNTRY);\r\nMFIE_STRING(HP_PARAMS);\r\nMFIE_STRING(HP_TABLE);\r\nMFIE_STRING(REQUEST);\r\nMFIE_STRING(CHALLENGE);\r\nMFIE_STRING(PWR_CONSTRAINT);\r\nMFIE_STRING(PWR_CAPABILITY);\r\nMFIE_STRING(TPC_REQUEST);\r\nMFIE_STRING(TPC_REPORT);\r\nMFIE_STRING(SUPPORTED_CHANNELS);\r\nMFIE_STRING(CHANNEL_SWITCH);\r\nMFIE_STRING(MEASURE_REQUEST);\r\nMFIE_STRING(MEASURE_REPORT);\r\nMFIE_STRING(QUIET);\r\nMFIE_STRING(IBSS_DFS);\r\nMFIE_STRING(ERP_INFO);\r\nMFIE_STRING(RSN);\r\nMFIE_STRING(EXT_SUPP_RATES);\r\nMFIE_STRING(VENDOR_SPECIFIC);\r\nMFIE_STRING(QOS_PARAMETER);\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic int libipw_parse_info_param(struct libipw_info_element\r\n*info_element, u16 length,\r\nstruct libipw_network *network)\r\n{\r\nDECLARE_SSID_BUF(ssid);\r\nu8 i;\r\n#ifdef CONFIG_LIBIPW_DEBUG\r\nchar rates_str[64];\r\nchar *p;\r\n#endif\r\nwhile (length >= sizeof(*info_element)) {\r\nif (sizeof(*info_element) + info_element->len > length) {\r\nLIBIPW_DEBUG_MGMT("Info elem: parse failed: "\r\n"info_element->len + 2 > left : "\r\n"info_element->len+2=%zd left=%d, id=%d.\n",\r\ninfo_element->len +\r\nsizeof(*info_element),\r\nlength, info_element->id);\r\nbreak;\r\n}\r\nswitch (info_element->id) {\r\ncase WLAN_EID_SSID:\r\nnetwork->ssid_len = min(info_element->len,\r\n(u8) IW_ESSID_MAX_SIZE);\r\nmemcpy(network->ssid, info_element->data,\r\nnetwork->ssid_len);\r\nif (network->ssid_len < IW_ESSID_MAX_SIZE)\r\nmemset(network->ssid + network->ssid_len, 0,\r\nIW_ESSID_MAX_SIZE - network->ssid_len);\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_SSID: '%s' len=%d.\n",\r\nprint_ssid(ssid, network->ssid,\r\nnetwork->ssid_len),\r\nnetwork->ssid_len);\r\nbreak;\r\ncase WLAN_EID_SUPP_RATES:\r\n#ifdef CONFIG_LIBIPW_DEBUG\r\np = rates_str;\r\n#endif\r\nnetwork->rates_len = min(info_element->len,\r\nMAX_RATES_LENGTH);\r\nfor (i = 0; i < network->rates_len; i++) {\r\nnetwork->rates[i] = info_element->data[i];\r\n#ifdef CONFIG_LIBIPW_DEBUG\r\np += snprintf(p, sizeof(rates_str) -\r\n(p - rates_str), "%02X ",\r\nnetwork->rates[i]);\r\n#endif\r\nif (libipw_is_ofdm_rate\r\n(info_element->data[i])) {\r\nnetwork->flags |= NETWORK_HAS_OFDM;\r\nif (info_element->data[i] &\r\nLIBIPW_BASIC_RATE_MASK)\r\nnetwork->flags &=\r\n~NETWORK_HAS_CCK;\r\n}\r\n}\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_SUPP_RATES: '%s' (%d)\n",\r\nrates_str, network->rates_len);\r\nbreak;\r\ncase WLAN_EID_EXT_SUPP_RATES:\r\n#ifdef CONFIG_LIBIPW_DEBUG\r\np = rates_str;\r\n#endif\r\nnetwork->rates_ex_len = min(info_element->len,\r\nMAX_RATES_EX_LENGTH);\r\nfor (i = 0; i < network->rates_ex_len; i++) {\r\nnetwork->rates_ex[i] = info_element->data[i];\r\n#ifdef CONFIG_LIBIPW_DEBUG\r\np += snprintf(p, sizeof(rates_str) -\r\n(p - rates_str), "%02X ",\r\nnetwork->rates_ex[i]);\r\n#endif\r\nif (libipw_is_ofdm_rate\r\n(info_element->data[i])) {\r\nnetwork->flags |= NETWORK_HAS_OFDM;\r\nif (info_element->data[i] &\r\nLIBIPW_BASIC_RATE_MASK)\r\nnetwork->flags &=\r\n~NETWORK_HAS_CCK;\r\n}\r\n}\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_EXT_SUPP_RATES: '%s' (%d)\n",\r\nrates_str, network->rates_ex_len);\r\nbreak;\r\ncase WLAN_EID_DS_PARAMS:\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_DS_PARAMS: %d\n",\r\ninfo_element->data[0]);\r\nnetwork->channel = info_element->data[0];\r\nbreak;\r\ncase WLAN_EID_FH_PARAMS:\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_FH_PARAMS: ignored\n");\r\nbreak;\r\ncase WLAN_EID_CF_PARAMS:\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_CF_PARAMS: ignored\n");\r\nbreak;\r\ncase WLAN_EID_TIM:\r\nnetwork->tim.tim_count = info_element->data[0];\r\nnetwork->tim.tim_period = info_element->data[1];\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_TIM: partially ignored\n");\r\nbreak;\r\ncase WLAN_EID_ERP_INFO:\r\nnetwork->erp_value = info_element->data[0];\r\nnetwork->flags |= NETWORK_HAS_ERP_VALUE;\r\nLIBIPW_DEBUG_MGMT("MFIE_TYPE_ERP_SET: %d\n",\r\nnetwork->erp_value);\r\nbreak;\r\ncase WLAN_EID_IBSS_PARAMS:\r\nnetwork->atim_window = info_element->data[0];\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_IBSS_PARAMS: %d\n",\r\nnetwork->atim_window);\r\nbreak;\r\ncase WLAN_EID_CHALLENGE:\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_CHALLENGE: ignored\n");\r\nbreak;\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_VENDOR_SPECIFIC: %d bytes\n",\r\ninfo_element->len);\r\nif (!libipw_parse_qos_info_param_IE(info_element,\r\nnetwork))\r\nbreak;\r\nif (info_element->len >= 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x50 &&\r\ninfo_element->data[2] == 0xf2 &&\r\ninfo_element->data[3] == 0x01) {\r\nnetwork->wpa_ie_len = min(info_element->len + 2,\r\nMAX_WPA_IE_LEN);\r\nmemcpy(network->wpa_ie, info_element,\r\nnetwork->wpa_ie_len);\r\n}\r\nbreak;\r\ncase WLAN_EID_RSN:\r\nLIBIPW_DEBUG_MGMT("WLAN_EID_RSN: %d bytes\n",\r\ninfo_element->len);\r\nnetwork->rsn_ie_len = min(info_element->len + 2,\r\nMAX_WPA_IE_LEN);\r\nmemcpy(network->rsn_ie, info_element,\r\nnetwork->rsn_ie_len);\r\nbreak;\r\ncase WLAN_EID_QOS_PARAMETER:\r\nprintk(KERN_ERR\r\n"QoS Error need to parse QOS_PARAMETER IE\n");\r\nbreak;\r\ncase WLAN_EID_PWR_CONSTRAINT:\r\nnetwork->power_constraint = info_element->data[0];\r\nnetwork->flags |= NETWORK_HAS_POWER_CONSTRAINT;\r\nbreak;\r\ncase WLAN_EID_CHANNEL_SWITCH:\r\nnetwork->power_constraint = info_element->data[0];\r\nnetwork->flags |= NETWORK_HAS_CSA;\r\nbreak;\r\ncase WLAN_EID_QUIET:\r\nnetwork->quiet.count = info_element->data[0];\r\nnetwork->quiet.period = info_element->data[1];\r\nnetwork->quiet.duration = info_element->data[2];\r\nnetwork->quiet.offset = info_element->data[3];\r\nnetwork->flags |= NETWORK_HAS_QUIET;\r\nbreak;\r\ncase WLAN_EID_IBSS_DFS:\r\nif (network->ibss_dfs)\r\nbreak;\r\nnetwork->ibss_dfs = kmemdup(info_element->data,\r\ninfo_element->len,\r\nGFP_ATOMIC);\r\nif (!network->ibss_dfs)\r\nreturn 1;\r\nnetwork->flags |= NETWORK_HAS_IBSS_DFS;\r\nbreak;\r\ncase WLAN_EID_TPC_REPORT:\r\nnetwork->tpc_report.transmit_power =\r\ninfo_element->data[0];\r\nnetwork->tpc_report.link_margin = info_element->data[1];\r\nnetwork->flags |= NETWORK_HAS_TPC_REPORT;\r\nbreak;\r\ndefault:\r\nLIBIPW_DEBUG_MGMT\r\n("Unsupported info element: %s (%d)\n",\r\nget_info_element_string(info_element->id),\r\ninfo_element->id);\r\nbreak;\r\n}\r\nlength -= sizeof(*info_element) + info_element->len;\r\ninfo_element =\r\n(struct libipw_info_element *)&info_element->\r\ndata[info_element->len];\r\n}\r\nreturn 0;\r\n}\r\nstatic int libipw_handle_assoc_resp(struct libipw_device *ieee, struct libipw_assoc_response\r\n*frame, struct libipw_rx_stats *stats)\r\n{\r\nstruct libipw_network network_resp = {\r\n.ibss_dfs = NULL,\r\n};\r\nstruct libipw_network *network = &network_resp;\r\nstruct net_device *dev = ieee->dev;\r\nnetwork->flags = 0;\r\nnetwork->qos_data.active = 0;\r\nnetwork->qos_data.supported = 0;\r\nnetwork->qos_data.param_count = 0;\r\nnetwork->qos_data.old_param_count = 0;\r\nnetwork->atim_window = le16_to_cpu(frame->aid);\r\nnetwork->listen_interval = le16_to_cpu(frame->status);\r\nmemcpy(network->bssid, frame->header.addr3, ETH_ALEN);\r\nnetwork->capability = le16_to_cpu(frame->capability);\r\nnetwork->last_scanned = jiffies;\r\nnetwork->rates_len = network->rates_ex_len = 0;\r\nnetwork->last_associate = 0;\r\nnetwork->ssid_len = 0;\r\nnetwork->erp_value =\r\n(network->capability & WLAN_CAPABILITY_IBSS) ? 0x3 : 0x0;\r\nif (stats->freq == LIBIPW_52GHZ_BAND) {\r\nnetwork->channel = stats->received_channel;\r\n} else\r\nnetwork->flags |= NETWORK_HAS_CCK;\r\nnetwork->wpa_ie_len = 0;\r\nnetwork->rsn_ie_len = 0;\r\nif (libipw_parse_info_param\r\n(frame->info_element, stats->len - sizeof(*frame), network))\r\nreturn 1;\r\nnetwork->mode = 0;\r\nif (stats->freq == LIBIPW_52GHZ_BAND)\r\nnetwork->mode = IEEE_A;\r\nelse {\r\nif (network->flags & NETWORK_HAS_OFDM)\r\nnetwork->mode |= IEEE_G;\r\nif (network->flags & NETWORK_HAS_CCK)\r\nnetwork->mode |= IEEE_B;\r\n}\r\nmemcpy(&network->stats, stats, sizeof(network->stats));\r\nif (ieee->handle_assoc_response != NULL)\r\nieee->handle_assoc_response(dev, frame, network);\r\nreturn 0;\r\n}\r\nstatic int libipw_network_init(struct libipw_device *ieee, struct libipw_probe_response\r\n*beacon,\r\nstruct libipw_network *network,\r\nstruct libipw_rx_stats *stats)\r\n{\r\nDECLARE_SSID_BUF(ssid);\r\nnetwork->qos_data.active = 0;\r\nnetwork->qos_data.supported = 0;\r\nnetwork->qos_data.param_count = 0;\r\nnetwork->qos_data.old_param_count = 0;\r\nmemcpy(network->bssid, beacon->header.addr3, ETH_ALEN);\r\nnetwork->capability = le16_to_cpu(beacon->capability);\r\nnetwork->last_scanned = jiffies;\r\nnetwork->time_stamp[0] = le32_to_cpu(beacon->time_stamp[0]);\r\nnetwork->time_stamp[1] = le32_to_cpu(beacon->time_stamp[1]);\r\nnetwork->beacon_interval = le16_to_cpu(beacon->beacon_interval);\r\nnetwork->listen_interval = 0x0A;\r\nnetwork->rates_len = network->rates_ex_len = 0;\r\nnetwork->last_associate = 0;\r\nnetwork->ssid_len = 0;\r\nnetwork->flags = 0;\r\nnetwork->atim_window = 0;\r\nnetwork->erp_value = (network->capability & WLAN_CAPABILITY_IBSS) ?\r\n0x3 : 0x0;\r\nif (stats->freq == LIBIPW_52GHZ_BAND) {\r\nnetwork->channel = stats->received_channel;\r\n} else\r\nnetwork->flags |= NETWORK_HAS_CCK;\r\nnetwork->wpa_ie_len = 0;\r\nnetwork->rsn_ie_len = 0;\r\nif (libipw_parse_info_param\r\n(beacon->info_element, stats->len - sizeof(*beacon), network))\r\nreturn 1;\r\nnetwork->mode = 0;\r\nif (stats->freq == LIBIPW_52GHZ_BAND)\r\nnetwork->mode = IEEE_A;\r\nelse {\r\nif (network->flags & NETWORK_HAS_OFDM)\r\nnetwork->mode |= IEEE_G;\r\nif (network->flags & NETWORK_HAS_CCK)\r\nnetwork->mode |= IEEE_B;\r\n}\r\nif (network->mode == 0) {\r\nLIBIPW_DEBUG_SCAN("Filtered out '%s (%pM)' "\r\n"network.\n",\r\nprint_ssid(ssid, network->ssid,\r\nnetwork->ssid_len),\r\nnetwork->bssid);\r\nreturn 1;\r\n}\r\nmemcpy(&network->stats, stats, sizeof(network->stats));\r\nreturn 0;\r\n}\r\nstatic inline int is_same_network(struct libipw_network *src,\r\nstruct libipw_network *dst)\r\n{\r\nreturn ((src->ssid_len == dst->ssid_len) &&\r\n(src->channel == dst->channel) &&\r\nether_addr_equal_64bits(src->bssid, dst->bssid) &&\r\n!memcmp(src->ssid, dst->ssid, src->ssid_len));\r\n}\r\nstatic void update_network(struct libipw_network *dst,\r\nstruct libipw_network *src)\r\n{\r\nint qos_active;\r\nu8 old_param;\r\nlibipw_network_reset(dst);\r\ndst->ibss_dfs = src->ibss_dfs;\r\nif (dst->channel == src->stats.received_channel)\r\nmemcpy(&dst->stats, &src->stats,\r\nsizeof(struct libipw_rx_stats));\r\nelse\r\nLIBIPW_DEBUG_SCAN("Network %pM info received "\r\n"off channel (%d vs. %d)\n", src->bssid,\r\ndst->channel, src->stats.received_channel);\r\ndst->capability = src->capability;\r\nmemcpy(dst->rates, src->rates, src->rates_len);\r\ndst->rates_len = src->rates_len;\r\nmemcpy(dst->rates_ex, src->rates_ex, src->rates_ex_len);\r\ndst->rates_ex_len = src->rates_ex_len;\r\ndst->mode = src->mode;\r\ndst->flags = src->flags;\r\ndst->time_stamp[0] = src->time_stamp[0];\r\ndst->time_stamp[1] = src->time_stamp[1];\r\ndst->beacon_interval = src->beacon_interval;\r\ndst->listen_interval = src->listen_interval;\r\ndst->atim_window = src->atim_window;\r\ndst->erp_value = src->erp_value;\r\ndst->tim = src->tim;\r\nmemcpy(dst->wpa_ie, src->wpa_ie, src->wpa_ie_len);\r\ndst->wpa_ie_len = src->wpa_ie_len;\r\nmemcpy(dst->rsn_ie, src->rsn_ie, src->rsn_ie_len);\r\ndst->rsn_ie_len = src->rsn_ie_len;\r\ndst->last_scanned = jiffies;\r\nqos_active = src->qos_data.active;\r\nold_param = dst->qos_data.old_param_count;\r\nif (dst->flags & NETWORK_HAS_QOS_MASK)\r\nmemcpy(&dst->qos_data, &src->qos_data,\r\nsizeof(struct libipw_qos_data));\r\nelse {\r\ndst->qos_data.supported = src->qos_data.supported;\r\ndst->qos_data.param_count = src->qos_data.param_count;\r\n}\r\nif (dst->qos_data.supported == 1) {\r\nif (dst->ssid_len)\r\nLIBIPW_DEBUG_QOS\r\n("QoS the network %s is QoS supported\n",\r\ndst->ssid);\r\nelse\r\nLIBIPW_DEBUG_QOS\r\n("QoS the network is QoS supported\n");\r\n}\r\ndst->qos_data.active = qos_active;\r\ndst->qos_data.old_param_count = old_param;\r\n}\r\nstatic inline int is_beacon(__le16 fc)\r\n{\r\nreturn (WLAN_FC_GET_STYPE(le16_to_cpu(fc)) == IEEE80211_STYPE_BEACON);\r\n}\r\nstatic void libipw_process_probe_response(struct libipw_device\r\n*ieee, struct\r\nlibipw_probe_response\r\n*beacon, struct libipw_rx_stats\r\n*stats)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nstruct libipw_network network = {\r\n.ibss_dfs = NULL,\r\n};\r\nstruct libipw_network *target;\r\nstruct libipw_network *oldest = NULL;\r\n#ifdef CONFIG_LIBIPW_DEBUG\r\nstruct libipw_info_element *info_element = beacon->info_element;\r\n#endif\r\nunsigned long flags;\r\nDECLARE_SSID_BUF(ssid);\r\nLIBIPW_DEBUG_SCAN("'%s' (%pM"\r\n"): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",\r\nprint_ssid(ssid, info_element->data, info_element->len),\r\nbeacon->header.addr3,\r\n(beacon->capability & cpu_to_le16(1 << 0xf)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0xe)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0xd)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0xc)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0xb)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0xa)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0x9)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0x8)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0x7)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0x6)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0x5)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0x4)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0x3)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0x2)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0x1)) ? '1' : '0',\r\n(beacon->capability & cpu_to_le16(1 << 0x0)) ? '1' : '0');\r\nif (libipw_network_init(ieee, beacon, &network, stats)) {\r\nLIBIPW_DEBUG_SCAN("Dropped '%s' (%pM) via %s.\n",\r\nprint_ssid(ssid, info_element->data,\r\ninfo_element->len),\r\nbeacon->header.addr3,\r\nis_beacon(beacon->header.frame_ctl) ?\r\n"BEACON" : "PROBE RESPONSE");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nlist_for_each_entry(target, &ieee->network_list, list) {\r\nif (is_same_network(target, &network))\r\nbreak;\r\nif ((oldest == NULL) ||\r\ntime_before(target->last_scanned, oldest->last_scanned))\r\noldest = target;\r\n}\r\nif (&target->list == &ieee->network_list) {\r\nif (list_empty(&ieee->network_free_list)) {\r\nlist_del(&oldest->list);\r\ntarget = oldest;\r\nLIBIPW_DEBUG_SCAN("Expired '%s' (%pM) from "\r\n"network list.\n",\r\nprint_ssid(ssid, target->ssid,\r\ntarget->ssid_len),\r\ntarget->bssid);\r\nlibipw_network_reset(target);\r\n} else {\r\ntarget = list_entry(ieee->network_free_list.next,\r\nstruct libipw_network, list);\r\nlist_del(ieee->network_free_list.next);\r\n}\r\n#ifdef CONFIG_LIBIPW_DEBUG\r\nLIBIPW_DEBUG_SCAN("Adding '%s' (%pM) via %s.\n",\r\nprint_ssid(ssid, network.ssid,\r\nnetwork.ssid_len),\r\nnetwork.bssid,\r\nis_beacon(beacon->header.frame_ctl) ?\r\n"BEACON" : "PROBE RESPONSE");\r\n#endif\r\nmemcpy(target, &network, sizeof(*target));\r\nnetwork.ibss_dfs = NULL;\r\nlist_add_tail(&target->list, &ieee->network_list);\r\n} else {\r\nLIBIPW_DEBUG_SCAN("Updating '%s' (%pM) via %s.\n",\r\nprint_ssid(ssid, target->ssid,\r\ntarget->ssid_len),\r\ntarget->bssid,\r\nis_beacon(beacon->header.frame_ctl) ?\r\n"BEACON" : "PROBE RESPONSE");\r\nupdate_network(target, &network);\r\nnetwork.ibss_dfs = NULL;\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nif (is_beacon(beacon->header.frame_ctl)) {\r\nif (ieee->handle_beacon != NULL)\r\nieee->handle_beacon(dev, beacon, target);\r\n} else {\r\nif (ieee->handle_probe_response != NULL)\r\nieee->handle_probe_response(dev, beacon, target);\r\n}\r\n}\r\nvoid libipw_rx_mgt(struct libipw_device *ieee,\r\nstruct libipw_hdr_4addr *header,\r\nstruct libipw_rx_stats *stats)\r\n{\r\nswitch (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl))) {\r\ncase IEEE80211_STYPE_ASSOC_RESP:\r\nLIBIPW_DEBUG_MGMT("received ASSOCIATION RESPONSE (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu\r\n(header->frame_ctl)));\r\nlibipw_handle_assoc_resp(ieee,\r\n(struct libipw_assoc_response *)\r\nheader, stats);\r\nbreak;\r\ncase IEEE80211_STYPE_REASSOC_RESP:\r\nLIBIPW_DEBUG_MGMT("received REASSOCIATION RESPONSE (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu\r\n(header->frame_ctl)));\r\nbreak;\r\ncase IEEE80211_STYPE_PROBE_REQ:\r\nLIBIPW_DEBUG_MGMT("received auth (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu\r\n(header->frame_ctl)));\r\nif (ieee->handle_probe_request != NULL)\r\nieee->handle_probe_request(ieee->dev,\r\n(struct\r\nlibipw_probe_request *)\r\nheader, stats);\r\nbreak;\r\ncase IEEE80211_STYPE_PROBE_RESP:\r\nLIBIPW_DEBUG_MGMT("received PROBE RESPONSE (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu\r\n(header->frame_ctl)));\r\nLIBIPW_DEBUG_SCAN("Probe response\n");\r\nlibipw_process_probe_response(ieee,\r\n(struct\r\nlibipw_probe_response *)\r\nheader, stats);\r\nbreak;\r\ncase IEEE80211_STYPE_BEACON:\r\nLIBIPW_DEBUG_MGMT("received BEACON (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu\r\n(header->frame_ctl)));\r\nLIBIPW_DEBUG_SCAN("Beacon\n");\r\nlibipw_process_probe_response(ieee,\r\n(struct\r\nlibipw_probe_response *)\r\nheader, stats);\r\nbreak;\r\ncase IEEE80211_STYPE_AUTH:\r\nLIBIPW_DEBUG_MGMT("received auth (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu\r\n(header->frame_ctl)));\r\nif (ieee->handle_auth != NULL)\r\nieee->handle_auth(ieee->dev,\r\n(struct libipw_auth *)header);\r\nbreak;\r\ncase IEEE80211_STYPE_DISASSOC:\r\nif (ieee->handle_disassoc != NULL)\r\nieee->handle_disassoc(ieee->dev,\r\n(struct libipw_disassoc *)\r\nheader);\r\nbreak;\r\ncase IEEE80211_STYPE_ACTION:\r\nLIBIPW_DEBUG_MGMT("ACTION\n");\r\nif (ieee->handle_action)\r\nieee->handle_action(ieee->dev,\r\n(struct libipw_action *)\r\nheader, stats);\r\nbreak;\r\ncase IEEE80211_STYPE_REASSOC_REQ:\r\nLIBIPW_DEBUG_MGMT("received reassoc (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu\r\n(header->frame_ctl)));\r\nLIBIPW_DEBUG_MGMT("%s: LIBIPW_REASSOC_REQ received\n",\r\nieee->dev->name);\r\nif (ieee->handle_reassoc_request != NULL)\r\nieee->handle_reassoc_request(ieee->dev,\r\n(struct libipw_reassoc_request *)\r\nheader);\r\nbreak;\r\ncase IEEE80211_STYPE_ASSOC_REQ:\r\nLIBIPW_DEBUG_MGMT("received assoc (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu\r\n(header->frame_ctl)));\r\nLIBIPW_DEBUG_MGMT("%s: LIBIPW_ASSOC_REQ received\n",\r\nieee->dev->name);\r\nif (ieee->handle_assoc_request != NULL)\r\nieee->handle_assoc_request(ieee->dev);\r\nbreak;\r\ncase IEEE80211_STYPE_DEAUTH:\r\nLIBIPW_DEBUG_MGMT("DEAUTH\n");\r\nif (ieee->handle_deauth != NULL)\r\nieee->handle_deauth(ieee->dev,\r\n(struct libipw_deauth *)\r\nheader);\r\nbreak;\r\ndefault:\r\nLIBIPW_DEBUG_MGMT("received UNKNOWN (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu\r\n(header->frame_ctl)));\r\nLIBIPW_DEBUG_MGMT("%s: Unknown management packet: %d\n",\r\nieee->dev->name,\r\nWLAN_FC_GET_STYPE(le16_to_cpu\r\n(header->frame_ctl)));\r\nbreak;\r\n}\r\n}
