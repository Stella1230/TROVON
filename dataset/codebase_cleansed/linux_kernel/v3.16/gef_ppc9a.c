static void __init gef_ppc9a_init_irq(void)\r\n{\r\nstruct device_node *cascade_node = NULL;\r\nmpc86xx_init_irq();\r\ncascade_node = of_find_compatible_node(NULL, NULL, "gef,fpga-pic-1.00");\r\nif (!cascade_node) {\r\nprintk(KERN_WARNING "PPC9A: No FPGA PIC\n");\r\nreturn;\r\n}\r\ngef_pic_init(cascade_node);\r\nof_node_put(cascade_node);\r\n}\r\nstatic void __init gef_ppc9a_setup_arch(void)\r\n{\r\nstruct device_node *regs;\r\nprintk(KERN_INFO "GE Intelligent Platforms PPC9A 6U VME SBC\n");\r\n#ifdef CONFIG_SMP\r\nmpc86xx_smp_init();\r\n#endif\r\nfsl_pci_assign_primary();\r\nregs = of_find_compatible_node(NULL, NULL, "gef,ppc9a-fpga-regs");\r\nif (regs) {\r\nppc9a_regs = of_iomap(regs, 0);\r\nif (ppc9a_regs == NULL)\r\nprintk(KERN_WARNING "Unable to map board registers\n");\r\nof_node_put(regs);\r\n}\r\n#if defined(CONFIG_MMIO_NVRAM)\r\nmmio_nvram_init();\r\n#endif\r\n}\r\nstatic unsigned int gef_ppc9a_get_pcb_rev(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread32be(ppc9a_regs);\r\nreturn (reg >> 16) & 0xff;\r\n}\r\nstatic unsigned int gef_ppc9a_get_board_rev(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread32be(ppc9a_regs);\r\nreturn (reg >> 8) & 0xff;\r\n}\r\nstatic unsigned int gef_ppc9a_get_fpga_rev(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread32be(ppc9a_regs);\r\nreturn reg & 0xf;\r\n}\r\nstatic unsigned int gef_ppc9a_get_vme_geo_addr(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread32be(ppc9a_regs + 0x4);\r\nreturn reg & 0x1f;\r\n}\r\nstatic unsigned int gef_ppc9a_get_vme_is_syscon(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread32be(ppc9a_regs + 0x4);\r\nreturn (reg >> 9) & 0x1;\r\n}\r\nstatic void gef_ppc9a_show_cpuinfo(struct seq_file *m)\r\n{\r\nuint svid = mfspr(SPRN_SVR);\r\nseq_printf(m, "Vendor\t\t: GE Intelligent Platforms\n");\r\nseq_printf(m, "Revision\t: %u%c\n", gef_ppc9a_get_pcb_rev(),\r\n('A' + gef_ppc9a_get_board_rev()));\r\nseq_printf(m, "FPGA Revision\t: %u\n", gef_ppc9a_get_fpga_rev());\r\nseq_printf(m, "SVR\t\t: 0x%x\n", svid);\r\nseq_printf(m, "VME geo. addr\t: %u\n", gef_ppc9a_get_vme_geo_addr());\r\nseq_printf(m, "VME syscon\t: %s\n",\r\ngef_ppc9a_get_vme_is_syscon() ? "yes" : "no");\r\n}\r\nstatic void gef_ppc9a_nec_fixup(struct pci_dev *pdev)\r\n{\r\nunsigned int val;\r\nif (!machine_is(gef_ppc9a))\r\nreturn;\r\nprintk(KERN_INFO "Running NEC uPD720101 Fixup\n");\r\npci_read_config_dword(pdev, 0xe0, &val);\r\npci_write_config_dword(pdev, 0xe0, (val & ~7) | 0x5);\r\npci_write_config_dword(pdev, 0xe4, 1 << 5);\r\n}\r\nstatic int __init gef_ppc9a_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "gef,ppc9a"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic long __init mpc86xx_time_init(void)\r\n{\r\nunsigned int temp;\r\nmtspr(SPRN_TBWL, 0);\r\nmtspr(SPRN_TBWU, 0);\r\ntemp = mfspr(SPRN_HID0);\r\ntemp |= HID0_TBEN;\r\nmtspr(SPRN_HID0, temp);\r\nasm volatile("isync");\r\nreturn 0;\r\n}\r\nstatic int __init declare_of_platform_devices(void)\r\n{\r\nprintk(KERN_DEBUG "Probe platform devices\n");\r\nof_platform_bus_probe(NULL, of_bus_ids, NULL);\r\nreturn 0;\r\n}
