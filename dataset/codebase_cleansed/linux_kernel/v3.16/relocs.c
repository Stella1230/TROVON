static int is_reloc(enum symtype type, const char *sym_name)\r\n{\r\nreturn sym_regex[type] &&\r\n!regexec(&sym_regex_c[type], sym_name, 0, NULL, 0);\r\n}\r\nstatic void regex_init(int use_real_mode)\r\n{\r\nchar errbuf[128];\r\nint err;\r\nint i;\r\nif (use_real_mode)\r\nsym_regex = sym_regex_realmode;\r\nelse\r\nsym_regex = sym_regex_kernel;\r\nfor (i = 0; i < S_NSYMTYPES; i++) {\r\nif (!sym_regex[i])\r\ncontinue;\r\nerr = regcomp(&sym_regex_c[i], sym_regex[i],\r\nREG_EXTENDED|REG_NOSUB);\r\nif (err) {\r\nregerror(err, &sym_regex_c[i], errbuf, sizeof errbuf);\r\ndie("%s", errbuf);\r\n}\r\n}\r\n}\r\nstatic const char *sym_type(unsigned type)\r\n{\r\nstatic const char *type_name[] = {\r\n#define SYM_TYPE(X) [X] = #X\r\nSYM_TYPE(STT_NOTYPE),\r\nSYM_TYPE(STT_OBJECT),\r\nSYM_TYPE(STT_FUNC),\r\nSYM_TYPE(STT_SECTION),\r\nSYM_TYPE(STT_FILE),\r\nSYM_TYPE(STT_COMMON),\r\nSYM_TYPE(STT_TLS),\r\n#undef SYM_TYPE\r\n};\r\nconst char *name = "unknown sym type name";\r\nif (type < ARRAY_SIZE(type_name)) {\r\nname = type_name[type];\r\n}\r\nreturn name;\r\n}\r\nstatic const char *sym_bind(unsigned bind)\r\n{\r\nstatic const char *bind_name[] = {\r\n#define SYM_BIND(X) [X] = #X\r\nSYM_BIND(STB_LOCAL),\r\nSYM_BIND(STB_GLOBAL),\r\nSYM_BIND(STB_WEAK),\r\n#undef SYM_BIND\r\n};\r\nconst char *name = "unknown sym bind name";\r\nif (bind < ARRAY_SIZE(bind_name)) {\r\nname = bind_name[bind];\r\n}\r\nreturn name;\r\n}\r\nstatic const char *sym_visibility(unsigned visibility)\r\n{\r\nstatic const char *visibility_name[] = {\r\n#define SYM_VISIBILITY(X) [X] = #X\r\nSYM_VISIBILITY(STV_DEFAULT),\r\nSYM_VISIBILITY(STV_INTERNAL),\r\nSYM_VISIBILITY(STV_HIDDEN),\r\nSYM_VISIBILITY(STV_PROTECTED),\r\n#undef SYM_VISIBILITY\r\n};\r\nconst char *name = "unknown sym visibility name";\r\nif (visibility < ARRAY_SIZE(visibility_name)) {\r\nname = visibility_name[visibility];\r\n}\r\nreturn name;\r\n}\r\nstatic const char *rel_type(unsigned type)\r\n{\r\nstatic const char *type_name[] = {\r\n#define REL_TYPE(X) [X] = #X\r\n#if ELF_BITS == 64\r\nREL_TYPE(R_X86_64_NONE),\r\nREL_TYPE(R_X86_64_64),\r\nREL_TYPE(R_X86_64_PC32),\r\nREL_TYPE(R_X86_64_GOT32),\r\nREL_TYPE(R_X86_64_PLT32),\r\nREL_TYPE(R_X86_64_COPY),\r\nREL_TYPE(R_X86_64_GLOB_DAT),\r\nREL_TYPE(R_X86_64_JUMP_SLOT),\r\nREL_TYPE(R_X86_64_RELATIVE),\r\nREL_TYPE(R_X86_64_GOTPCREL),\r\nREL_TYPE(R_X86_64_32),\r\nREL_TYPE(R_X86_64_32S),\r\nREL_TYPE(R_X86_64_16),\r\nREL_TYPE(R_X86_64_PC16),\r\nREL_TYPE(R_X86_64_8),\r\nREL_TYPE(R_X86_64_PC8),\r\n#else\r\nREL_TYPE(R_386_NONE),\r\nREL_TYPE(R_386_32),\r\nREL_TYPE(R_386_PC32),\r\nREL_TYPE(R_386_GOT32),\r\nREL_TYPE(R_386_PLT32),\r\nREL_TYPE(R_386_COPY),\r\nREL_TYPE(R_386_GLOB_DAT),\r\nREL_TYPE(R_386_JMP_SLOT),\r\nREL_TYPE(R_386_RELATIVE),\r\nREL_TYPE(R_386_GOTOFF),\r\nREL_TYPE(R_386_GOTPC),\r\nREL_TYPE(R_386_8),\r\nREL_TYPE(R_386_PC8),\r\nREL_TYPE(R_386_16),\r\nREL_TYPE(R_386_PC16),\r\n#endif\r\n#undef REL_TYPE\r\n};\r\nconst char *name = "unknown type rel type name";\r\nif (type < ARRAY_SIZE(type_name) && type_name[type]) {\r\nname = type_name[type];\r\n}\r\nreturn name;\r\n}\r\nstatic const char *sec_name(unsigned shndx)\r\n{\r\nconst char *sec_strtab;\r\nconst char *name;\r\nsec_strtab = secs[ehdr.e_shstrndx].strtab;\r\nname = "<noname>";\r\nif (shndx < ehdr.e_shnum) {\r\nname = sec_strtab + secs[shndx].shdr.sh_name;\r\n}\r\nelse if (shndx == SHN_ABS) {\r\nname = "ABSOLUTE";\r\n}\r\nelse if (shndx == SHN_COMMON) {\r\nname = "COMMON";\r\n}\r\nreturn name;\r\n}\r\nstatic const char *sym_name(const char *sym_strtab, Elf_Sym *sym)\r\n{\r\nconst char *name;\r\nname = "<noname>";\r\nif (sym->st_name) {\r\nname = sym_strtab + sym->st_name;\r\n}\r\nelse {\r\nname = sec_name(sym->st_shndx);\r\n}\r\nreturn name;\r\n}\r\nstatic Elf_Sym *sym_lookup(const char *symname)\r\n{\r\nint i;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nlong nsyms;\r\nchar *strtab;\r\nElf_Sym *symtab;\r\nElf_Sym *sym;\r\nif (sec->shdr.sh_type != SHT_SYMTAB)\r\ncontinue;\r\nnsyms = sec->shdr.sh_size/sizeof(Elf_Sym);\r\nsymtab = sec->symtab;\r\nstrtab = sec->link->strtab;\r\nfor (sym = symtab; --nsyms >= 0; sym++) {\r\nif (!sym->st_name)\r\ncontinue;\r\nif (strcmp(symname, strtab + sym->st_name) == 0)\r\nreturn sym;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic uint16_t elf16_to_cpu(uint16_t val)\r\n{\r\nreturn le16_to_cpu(val);\r\n}\r\nstatic uint32_t elf32_to_cpu(uint32_t val)\r\n{\r\nreturn le32_to_cpu(val);\r\n}\r\nstatic uint64_t elf64_to_cpu(uint64_t val)\r\n{\r\nreturn le64_to_cpu(val);\r\n}\r\nstatic void read_ehdr(FILE *fp)\r\n{\r\nif (fread(&ehdr, sizeof(ehdr), 1, fp) != 1) {\r\ndie("Cannot read ELF header: %s\n",\r\nstrerror(errno));\r\n}\r\nif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0) {\r\ndie("No ELF magic\n");\r\n}\r\nif (ehdr.e_ident[EI_CLASS] != ELF_CLASS) {\r\ndie("Not a %d bit executable\n", ELF_BITS);\r\n}\r\nif (ehdr.e_ident[EI_DATA] != ELFDATA2LSB) {\r\ndie("Not a LSB ELF executable\n");\r\n}\r\nif (ehdr.e_ident[EI_VERSION] != EV_CURRENT) {\r\ndie("Unknown ELF version\n");\r\n}\r\nehdr.e_type = elf_half_to_cpu(ehdr.e_type);\r\nehdr.e_machine = elf_half_to_cpu(ehdr.e_machine);\r\nehdr.e_version = elf_word_to_cpu(ehdr.e_version);\r\nehdr.e_entry = elf_addr_to_cpu(ehdr.e_entry);\r\nehdr.e_phoff = elf_off_to_cpu(ehdr.e_phoff);\r\nehdr.e_shoff = elf_off_to_cpu(ehdr.e_shoff);\r\nehdr.e_flags = elf_word_to_cpu(ehdr.e_flags);\r\nehdr.e_ehsize = elf_half_to_cpu(ehdr.e_ehsize);\r\nehdr.e_phentsize = elf_half_to_cpu(ehdr.e_phentsize);\r\nehdr.e_phnum = elf_half_to_cpu(ehdr.e_phnum);\r\nehdr.e_shentsize = elf_half_to_cpu(ehdr.e_shentsize);\r\nehdr.e_shnum = elf_half_to_cpu(ehdr.e_shnum);\r\nehdr.e_shstrndx = elf_half_to_cpu(ehdr.e_shstrndx);\r\nif ((ehdr.e_type != ET_EXEC) && (ehdr.e_type != ET_DYN)) {\r\ndie("Unsupported ELF header type\n");\r\n}\r\nif (ehdr.e_machine != ELF_MACHINE) {\r\ndie("Not for %s\n", ELF_MACHINE_NAME);\r\n}\r\nif (ehdr.e_version != EV_CURRENT) {\r\ndie("Unknown ELF version\n");\r\n}\r\nif (ehdr.e_ehsize != sizeof(Elf_Ehdr)) {\r\ndie("Bad Elf header size\n");\r\n}\r\nif (ehdr.e_phentsize != sizeof(Elf_Phdr)) {\r\ndie("Bad program header entry\n");\r\n}\r\nif (ehdr.e_shentsize != sizeof(Elf_Shdr)) {\r\ndie("Bad section header entry\n");\r\n}\r\nif (ehdr.e_shstrndx >= ehdr.e_shnum) {\r\ndie("String table index out of bounds\n");\r\n}\r\n}\r\nstatic void read_shdrs(FILE *fp)\r\n{\r\nint i;\r\nElf_Shdr shdr;\r\nsecs = calloc(ehdr.e_shnum, sizeof(struct section));\r\nif (!secs) {\r\ndie("Unable to allocate %d section headers\n",\r\nehdr.e_shnum);\r\n}\r\nif (fseek(fp, ehdr.e_shoff, SEEK_SET) < 0) {\r\ndie("Seek to %d failed: %s\n",\r\nehdr.e_shoff, strerror(errno));\r\n}\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (fread(&shdr, sizeof shdr, 1, fp) != 1)\r\ndie("Cannot read ELF section headers %d/%d: %s\n",\r\ni, ehdr.e_shnum, strerror(errno));\r\nsec->shdr.sh_name = elf_word_to_cpu(shdr.sh_name);\r\nsec->shdr.sh_type = elf_word_to_cpu(shdr.sh_type);\r\nsec->shdr.sh_flags = elf_xword_to_cpu(shdr.sh_flags);\r\nsec->shdr.sh_addr = elf_addr_to_cpu(shdr.sh_addr);\r\nsec->shdr.sh_offset = elf_off_to_cpu(shdr.sh_offset);\r\nsec->shdr.sh_size = elf_xword_to_cpu(shdr.sh_size);\r\nsec->shdr.sh_link = elf_word_to_cpu(shdr.sh_link);\r\nsec->shdr.sh_info = elf_word_to_cpu(shdr.sh_info);\r\nsec->shdr.sh_addralign = elf_xword_to_cpu(shdr.sh_addralign);\r\nsec->shdr.sh_entsize = elf_xword_to_cpu(shdr.sh_entsize);\r\nif (sec->shdr.sh_link < ehdr.e_shnum)\r\nsec->link = &secs[sec->shdr.sh_link];\r\n}\r\n}\r\nstatic void read_strtabs(FILE *fp)\r\n{\r\nint i;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_STRTAB) {\r\ncontinue;\r\n}\r\nsec->strtab = malloc(sec->shdr.sh_size);\r\nif (!sec->strtab) {\r\ndie("malloc of %d bytes for strtab failed\n",\r\nsec->shdr.sh_size);\r\n}\r\nif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr.sh_offset, strerror(errno));\r\n}\r\nif (fread(sec->strtab, 1, sec->shdr.sh_size, fp)\r\n!= sec->shdr.sh_size) {\r\ndie("Cannot read symbol table: %s\n",\r\nstrerror(errno));\r\n}\r\n}\r\n}\r\nstatic void read_symtabs(FILE *fp)\r\n{\r\nint i,j;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_SYMTAB) {\r\ncontinue;\r\n}\r\nsec->symtab = malloc(sec->shdr.sh_size);\r\nif (!sec->symtab) {\r\ndie("malloc of %d bytes for symtab failed\n",\r\nsec->shdr.sh_size);\r\n}\r\nif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr.sh_offset, strerror(errno));\r\n}\r\nif (fread(sec->symtab, 1, sec->shdr.sh_size, fp)\r\n!= sec->shdr.sh_size) {\r\ndie("Cannot read symbol table: %s\n",\r\nstrerror(errno));\r\n}\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Sym); j++) {\r\nElf_Sym *sym = &sec->symtab[j];\r\nsym->st_name = elf_word_to_cpu(sym->st_name);\r\nsym->st_value = elf_addr_to_cpu(sym->st_value);\r\nsym->st_size = elf_xword_to_cpu(sym->st_size);\r\nsym->st_shndx = elf_half_to_cpu(sym->st_shndx);\r\n}\r\n}\r\n}\r\nstatic void read_relocs(FILE *fp)\r\n{\r\nint i,j;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_REL_TYPE) {\r\ncontinue;\r\n}\r\nsec->reltab = malloc(sec->shdr.sh_size);\r\nif (!sec->reltab) {\r\ndie("malloc of %d bytes for relocs failed\n",\r\nsec->shdr.sh_size);\r\n}\r\nif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr.sh_offset, strerror(errno));\r\n}\r\nif (fread(sec->reltab, 1, sec->shdr.sh_size, fp)\r\n!= sec->shdr.sh_size) {\r\ndie("Cannot read symbol table: %s\n",\r\nstrerror(errno));\r\n}\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Rel); j++) {\r\nElf_Rel *rel = &sec->reltab[j];\r\nrel->r_offset = elf_addr_to_cpu(rel->r_offset);\r\nrel->r_info = elf_xword_to_cpu(rel->r_info);\r\n#if (SHT_REL_TYPE == SHT_RELA)\r\nrel->r_addend = elf_xword_to_cpu(rel->r_addend);\r\n#endif\r\n}\r\n}\r\n}\r\nstatic void print_absolute_symbols(void)\r\n{\r\nint i;\r\nconst char *format;\r\nif (ELF_BITS == 64)\r\nformat = "%5d %016"PRIx64" %5"PRId64" %10s %10s %12s %s\n";\r\nelse\r\nformat = "%5d %08"PRIx32" %5"PRId32" %10s %10s %12s %s\n";\r\nprintf("Absolute symbols\n");\r\nprintf(" Num: Value Size Type Bind Visibility Name\n");\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nchar *sym_strtab;\r\nint j;\r\nif (sec->shdr.sh_type != SHT_SYMTAB) {\r\ncontinue;\r\n}\r\nsym_strtab = sec->link->strtab;\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Sym); j++) {\r\nElf_Sym *sym;\r\nconst char *name;\r\nsym = &sec->symtab[j];\r\nname = sym_name(sym_strtab, sym);\r\nif (sym->st_shndx != SHN_ABS) {\r\ncontinue;\r\n}\r\nprintf(format,\r\nj, sym->st_value, sym->st_size,\r\nsym_type(ELF_ST_TYPE(sym->st_info)),\r\nsym_bind(ELF_ST_BIND(sym->st_info)),\r\nsym_visibility(ELF_ST_VISIBILITY(sym->st_other)),\r\nname);\r\n}\r\n}\r\nprintf("\n");\r\n}\r\nstatic void print_absolute_relocs(void)\r\n{\r\nint i, printed = 0;\r\nconst char *format;\r\nif (ELF_BITS == 64)\r\nformat = "%016"PRIx64" %016"PRIx64" %10s %016"PRIx64" %s\n";\r\nelse\r\nformat = "%08"PRIx32" %08"PRIx32" %10s %08"PRIx32" %s\n";\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nstruct section *sec_applies, *sec_symtab;\r\nchar *sym_strtab;\r\nElf_Sym *sh_symtab;\r\nint j;\r\nif (sec->shdr.sh_type != SHT_REL_TYPE) {\r\ncontinue;\r\n}\r\nsec_symtab = sec->link;\r\nsec_applies = &secs[sec->shdr.sh_info];\r\nif (!(sec_applies->shdr.sh_flags & SHF_ALLOC)) {\r\ncontinue;\r\n}\r\nsh_symtab = sec_symtab->symtab;\r\nsym_strtab = sec_symtab->link->strtab;\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Rel); j++) {\r\nElf_Rel *rel;\r\nElf_Sym *sym;\r\nconst char *name;\r\nrel = &sec->reltab[j];\r\nsym = &sh_symtab[ELF_R_SYM(rel->r_info)];\r\nname = sym_name(sym_strtab, sym);\r\nif (sym->st_shndx != SHN_ABS) {\r\ncontinue;\r\n}\r\nif (is_reloc(S_ABS, name) || is_reloc(S_REL, name))\r\ncontinue;\r\nif (!printed) {\r\nprintf("WARNING: Absolute relocations"\r\n" present\n");\r\nprintf("Offset Info Type Sym.Value "\r\n"Sym.Name\n");\r\nprinted = 1;\r\n}\r\nprintf(format,\r\nrel->r_offset,\r\nrel->r_info,\r\nrel_type(ELF_R_TYPE(rel->r_info)),\r\nsym->st_value,\r\nname);\r\n}\r\n}\r\nif (printed)\r\nprintf("\n");\r\n}\r\nstatic void add_reloc(struct relocs *r, uint32_t offset)\r\n{\r\nif (r->count == r->size) {\r\nunsigned long newsize = r->size + 50000;\r\nvoid *mem = realloc(r->offset, newsize * sizeof(r->offset[0]));\r\nif (!mem)\r\ndie("realloc of %ld entries for relocs failed\n",\r\nnewsize);\r\nr->offset = mem;\r\nr->size = newsize;\r\n}\r\nr->offset[r->count++] = offset;\r\n}\r\nstatic void walk_relocs(int (*process)(struct section *sec, Elf_Rel *rel,\r\nElf_Sym *sym, const char *symname))\r\n{\r\nint i;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nchar *sym_strtab;\r\nElf_Sym *sh_symtab;\r\nstruct section *sec_applies, *sec_symtab;\r\nint j;\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_REL_TYPE) {\r\ncontinue;\r\n}\r\nsec_symtab = sec->link;\r\nsec_applies = &secs[sec->shdr.sh_info];\r\nif (!(sec_applies->shdr.sh_flags & SHF_ALLOC)) {\r\ncontinue;\r\n}\r\nsh_symtab = sec_symtab->symtab;\r\nsym_strtab = sec_symtab->link->strtab;\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Rel); j++) {\r\nElf_Rel *rel = &sec->reltab[j];\r\nElf_Sym *sym = &sh_symtab[ELF_R_SYM(rel->r_info)];\r\nconst char *symname = sym_name(sym_strtab, sym);\r\nprocess(sec, rel, sym, symname);\r\n}\r\n}\r\n}\r\nstatic void percpu_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nElfW(Sym) *sym;\r\nif (strcmp(sec_name(i), ".data..percpu"))\r\ncontinue;\r\nif (secs[i].shdr.sh_addr != 0)\r\nreturn;\r\nsym = sym_lookup("__per_cpu_load");\r\nif (!sym)\r\ndie("can't find __per_cpu_load\n");\r\nper_cpu_shndx = i;\r\nper_cpu_load_addr = sym->st_value;\r\nreturn;\r\n}\r\n}\r\nstatic int do_reloc32(struct section *sec, Elf_Rel *rel, Elf_Sym *sym,\r\nconst char *symname)\r\n{\r\nunsigned r_type = ELF32_R_TYPE(rel->r_info);\r\nint shn_abs = (sym->st_shndx == SHN_ABS) && !is_reloc(S_REL, symname);\r\nswitch (r_type) {\r\ncase R_386_NONE:\r\ncase R_386_PC32:\r\ncase R_386_PC16:\r\ncase R_386_PC8:\r\nbreak;\r\ncase R_386_32:\r\nif (shn_abs) {\r\nif (is_reloc(S_ABS, symname))\r\nbreak;\r\ndie("Invalid absolute %s relocation: %s\n",\r\nrel_type(r_type), symname);\r\nbreak;\r\n}\r\nadd_reloc(&relocs32, rel->r_offset);\r\nbreak;\r\ndefault:\r\ndie("Unsupported relocation type: %s (%d)\n",\r\nrel_type(r_type), r_type);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_reloc_real(struct section *sec, Elf_Rel *rel, Elf_Sym *sym,\r\nconst char *symname)\r\n{\r\nunsigned r_type = ELF32_R_TYPE(rel->r_info);\r\nint shn_abs = (sym->st_shndx == SHN_ABS) && !is_reloc(S_REL, symname);\r\nswitch (r_type) {\r\ncase R_386_NONE:\r\ncase R_386_PC32:\r\ncase R_386_PC16:\r\ncase R_386_PC8:\r\nbreak;\r\ncase R_386_16:\r\nif (shn_abs) {\r\nif (is_reloc(S_ABS, symname))\r\nbreak;\r\nif (is_reloc(S_SEG, symname)) {\r\nadd_reloc(&relocs16, rel->r_offset);\r\nbreak;\r\n}\r\n} else {\r\nif (!is_reloc(S_LIN, symname))\r\nbreak;\r\n}\r\ndie("Invalid %s %s relocation: %s\n",\r\nshn_abs ? "absolute" : "relative",\r\nrel_type(r_type), symname);\r\nbreak;\r\ncase R_386_32:\r\nif (shn_abs) {\r\nif (is_reloc(S_ABS, symname))\r\nbreak;\r\nif (is_reloc(S_REL, symname)) {\r\nadd_reloc(&relocs32, rel->r_offset);\r\nbreak;\r\n}\r\n} else {\r\nif (is_reloc(S_LIN, symname))\r\nadd_reloc(&relocs32, rel->r_offset);\r\nbreak;\r\n}\r\ndie("Invalid %s %s relocation: %s\n",\r\nshn_abs ? "absolute" : "relative",\r\nrel_type(r_type), symname);\r\nbreak;\r\ndefault:\r\ndie("Unsupported relocation type: %s (%d)\n",\r\nrel_type(r_type), r_type);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cmp_relocs(const void *va, const void *vb)\r\n{\r\nconst uint32_t *a, *b;\r\na = va; b = vb;\r\nreturn (*a == *b)? 0 : (*a > *b)? 1 : -1;\r\n}\r\nstatic void sort_relocs(struct relocs *r)\r\n{\r\nqsort(r->offset, r->count, sizeof(r->offset[0]), cmp_relocs);\r\n}\r\nstatic int write32(uint32_t v, FILE *f)\r\n{\r\nunsigned char buf[4];\r\nput_unaligned_le32(v, buf);\r\nreturn fwrite(buf, 1, 4, f) == 4 ? 0 : -1;\r\n}\r\nstatic int write32_as_text(uint32_t v, FILE *f)\r\n{\r\nreturn fprintf(f, "\t.long 0x%08"PRIx32"\n", v) > 0 ? 0 : -1;\r\n}\r\nstatic void emit_relocs(int as_text, int use_real_mode)\r\n{\r\nint i;\r\nint (*write_reloc)(uint32_t, FILE *) = write32;\r\nint (*do_reloc)(struct section *sec, Elf_Rel *rel, Elf_Sym *sym,\r\nconst char *symname);\r\n#if ELF_BITS == 64\r\nif (!use_real_mode)\r\ndo_reloc = do_reloc64;\r\nelse\r\ndie("--realmode not valid for a 64-bit ELF file");\r\n#else\r\nif (!use_real_mode)\r\ndo_reloc = do_reloc32;\r\nelse\r\ndo_reloc = do_reloc_real;\r\n#endif\r\nwalk_relocs(do_reloc);\r\nif (relocs16.count && !use_real_mode)\r\ndie("Segment relocations found but --realmode not specified\n");\r\nsort_relocs(&relocs16);\r\nsort_relocs(&relocs32);\r\nsort_relocs(&relocs64);\r\nif (as_text) {\r\nprintf(".section \".data.reloc\",\"a\"\n");\r\nprintf(".balign 4\n");\r\nwrite_reloc = write32_as_text;\r\n}\r\nif (use_real_mode) {\r\nwrite_reloc(relocs16.count, stdout);\r\nfor (i = 0; i < relocs16.count; i++)\r\nwrite_reloc(relocs16.offset[i], stdout);\r\nwrite_reloc(relocs32.count, stdout);\r\nfor (i = 0; i < relocs32.count; i++)\r\nwrite_reloc(relocs32.offset[i], stdout);\r\n} else {\r\nif (ELF_BITS == 64) {\r\nwrite_reloc(0, stdout);\r\nfor (i = 0; i < relocs64.count; i++)\r\nwrite_reloc(relocs64.offset[i], stdout);\r\n}\r\nwrite_reloc(0, stdout);\r\nfor (i = 0; i < relocs32.count; i++)\r\nwrite_reloc(relocs32.offset[i], stdout);\r\n}\r\n}\r\nstatic void print_reloc_info(void)\r\n{\r\nprintf("reloc section\treloc type\tsymbol\tsymbol section\n");\r\nwalk_relocs(do_reloc_info);\r\n}\r\nvoid process(FILE *fp, int use_real_mode, int as_text,\r\nint show_absolute_syms, int show_absolute_relocs,\r\nint show_reloc_info)\r\n{\r\nregex_init(use_real_mode);\r\nread_ehdr(fp);\r\nread_shdrs(fp);\r\nread_strtabs(fp);\r\nread_symtabs(fp);\r\nread_relocs(fp);\r\nif (ELF_BITS == 64)\r\npercpu_init();\r\nif (show_absolute_syms) {\r\nprint_absolute_symbols();\r\nreturn;\r\n}\r\nif (show_absolute_relocs) {\r\nprint_absolute_relocs();\r\nreturn;\r\n}\r\nif (show_reloc_info) {\r\nprint_reloc_info();\r\nreturn;\r\n}\r\nemit_relocs(as_text, use_real_mode);\r\n}
