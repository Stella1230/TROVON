static void ps2mult_select_port(struct ps2mult *psm, struct ps2mult_port *port)\r\n{\r\nstruct serio *mx_serio = psm->mx_serio;\r\nserio_write(mx_serio, port->sel);\r\npsm->out_port = port;\r\ndev_dbg(&mx_serio->dev, "switched to sel %02x\n", port->sel);\r\n}\r\nstatic int ps2mult_serio_write(struct serio *serio, unsigned char data)\r\n{\r\nstruct serio *mx_port = serio->parent;\r\nstruct ps2mult *psm = serio_get_drvdata(mx_port);\r\nstruct ps2mult_port *port = serio->port_data;\r\nbool need_escape;\r\nunsigned long flags;\r\nspin_lock_irqsave(&psm->lock, flags);\r\nif (psm->out_port != port)\r\nps2mult_select_port(psm, port);\r\nneed_escape = memchr(ps2mult_controls, data, sizeof(ps2mult_controls));\r\ndev_dbg(&serio->dev,\r\n"write: %s%02x\n", need_escape ? "ESC " : "", data);\r\nif (need_escape)\r\nserio_write(mx_port, PS2MULT_ESCAPE);\r\nserio_write(mx_port, data);\r\nspin_unlock_irqrestore(&psm->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ps2mult_serio_start(struct serio *serio)\r\n{\r\nstruct ps2mult *psm = serio_get_drvdata(serio->parent);\r\nstruct ps2mult_port *port = serio->port_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&psm->lock, flags);\r\nport->registered = true;\r\nspin_unlock_irqrestore(&psm->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ps2mult_serio_stop(struct serio *serio)\r\n{\r\nstruct ps2mult *psm = serio_get_drvdata(serio->parent);\r\nstruct ps2mult_port *port = serio->port_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&psm->lock, flags);\r\nport->registered = false;\r\nspin_unlock_irqrestore(&psm->lock, flags);\r\n}\r\nstatic int ps2mult_create_port(struct ps2mult *psm, int i)\r\n{\r\nstruct serio *mx_serio = psm->mx_serio;\r\nstruct serio *serio;\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!serio)\r\nreturn -ENOMEM;\r\nstrlcpy(serio->name, "TQC PS/2 Multiplexer", sizeof(serio->name));\r\nsnprintf(serio->phys, sizeof(serio->phys),\r\n"%s/port%d", mx_serio->phys, i);\r\nserio->id.type = SERIO_8042;\r\nserio->write = ps2mult_serio_write;\r\nserio->start = ps2mult_serio_start;\r\nserio->stop = ps2mult_serio_stop;\r\nserio->parent = psm->mx_serio;\r\nserio->port_data = &psm->ports[i];\r\npsm->ports[i].serio = serio;\r\nreturn 0;\r\n}\r\nstatic void ps2mult_reset(struct ps2mult *psm)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&psm->lock, flags);\r\nserio_write(psm->mx_serio, PS2MULT_SESSION_END);\r\nserio_write(psm->mx_serio, PS2MULT_SESSION_START);\r\nps2mult_select_port(psm, &psm->ports[PS2MULT_KBD_PORT]);\r\nspin_unlock_irqrestore(&psm->lock, flags);\r\n}\r\nstatic int ps2mult_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct ps2mult *psm;\r\nint i;\r\nint error;\r\nif (!serio->write)\r\nreturn -EINVAL;\r\npsm = kzalloc(sizeof(*psm), GFP_KERNEL);\r\nif (!psm)\r\nreturn -ENOMEM;\r\nspin_lock_init(&psm->lock);\r\npsm->mx_serio = serio;\r\nfor (i = 0; i < PS2MULT_NUM_PORTS; i++) {\r\npsm->ports[i].sel = ps2mult_controls[i];\r\nerror = ps2mult_create_port(psm, i);\r\nif (error)\r\ngoto err_out;\r\n}\r\npsm->in_port = psm->out_port = &psm->ports[PS2MULT_KBD_PORT];\r\nserio_set_drvdata(serio, psm);\r\nerror = serio_open(serio, drv);\r\nif (error)\r\ngoto err_out;\r\nps2mult_reset(psm);\r\nfor (i = 0; i < PS2MULT_NUM_PORTS; i++) {\r\nstruct serio *s = psm->ports[i].serio;\r\ndev_info(&serio->dev, "%s port at %s\n", s->name, serio->phys);\r\nserio_register_port(s);\r\n}\r\nreturn 0;\r\nerr_out:\r\nwhile (--i >= 0)\r\nkfree(psm->ports[i].serio);\r\nkfree(psm);\r\nreturn error;\r\n}\r\nstatic void ps2mult_disconnect(struct serio *serio)\r\n{\r\nstruct ps2mult *psm = serio_get_drvdata(serio);\r\nserio_write(serio, PS2MULT_SESSION_END);\r\nserio_close(serio);\r\nkfree(psm);\r\nserio_set_drvdata(serio, NULL);\r\n}\r\nstatic int ps2mult_reconnect(struct serio *serio)\r\n{\r\nstruct ps2mult *psm = serio_get_drvdata(serio);\r\nps2mult_reset(psm);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ps2mult_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int dfl)\r\n{\r\nstruct ps2mult *psm = serio_get_drvdata(serio);\r\nstruct ps2mult_port *in_port;\r\nunsigned long flags;\r\ndev_dbg(&serio->dev, "Received %02x flags %02x\n", data, dfl);\r\nspin_lock_irqsave(&psm->lock, flags);\r\nif (psm->escape) {\r\npsm->escape = false;\r\nin_port = psm->in_port;\r\nif (in_port->registered)\r\nserio_interrupt(in_port->serio, data, dfl);\r\ngoto out;\r\n}\r\nswitch (data) {\r\ncase PS2MULT_ESCAPE:\r\ndev_dbg(&serio->dev, "ESCAPE\n");\r\npsm->escape = true;\r\nbreak;\r\ncase PS2MULT_BSYNC:\r\ndev_dbg(&serio->dev, "BSYNC\n");\r\npsm->in_port = psm->out_port;\r\nbreak;\r\ncase PS2MULT_SESSION_START:\r\ndev_dbg(&serio->dev, "SS\n");\r\nbreak;\r\ncase PS2MULT_SESSION_END:\r\ndev_dbg(&serio->dev, "SE\n");\r\nbreak;\r\ncase PS2MULT_KB_SELECTOR:\r\ndev_dbg(&serio->dev, "KB\n");\r\npsm->in_port = &psm->ports[PS2MULT_KBD_PORT];\r\nbreak;\r\ncase PS2MULT_MS_SELECTOR:\r\ndev_dbg(&serio->dev, "MS\n");\r\npsm->in_port = &psm->ports[PS2MULT_MOUSE_PORT];\r\nbreak;\r\ndefault:\r\nin_port = psm->in_port;\r\nif (in_port->registered)\r\nserio_interrupt(in_port->serio, data, dfl);\r\nbreak;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&psm->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}
