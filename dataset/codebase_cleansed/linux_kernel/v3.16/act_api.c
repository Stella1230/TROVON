void tcf_hash_destroy(struct tc_action *a)\r\n{\r\nstruct tcf_common *p = a->priv;\r\nstruct tcf_hashinfo *hinfo = a->ops->hinfo;\r\nspin_lock_bh(&hinfo->lock);\r\nhlist_del(&p->tcfc_head);\r\nspin_unlock_bh(&hinfo->lock);\r\ngen_kill_estimator(&p->tcfc_bstats,\r\n&p->tcfc_rate_est);\r\nkfree_rcu(p, tcfc_rcu);\r\n}\r\nint tcf_hash_release(struct tc_action *a, int bind)\r\n{\r\nstruct tcf_common *p = a->priv;\r\nint ret = 0;\r\nif (p) {\r\nif (bind)\r\np->tcfc_bindcnt--;\r\nelse if (p->tcfc_bindcnt > 0)\r\nreturn -EPERM;\r\np->tcfc_refcnt--;\r\nif (p->tcfc_bindcnt <= 0 && p->tcfc_refcnt <= 0) {\r\nif (a->ops->cleanup)\r\na->ops->cleanup(a, bind);\r\ntcf_hash_destroy(a);\r\nret = 1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int tcf_dump_walker(struct sk_buff *skb, struct netlink_callback *cb,\r\nstruct tc_action *a)\r\n{\r\nstruct tcf_hashinfo *hinfo = a->ops->hinfo;\r\nstruct hlist_head *head;\r\nstruct tcf_common *p;\r\nint err = 0, index = -1, i = 0, s_i = 0, n_i = 0;\r\nstruct nlattr *nest;\r\nspin_lock_bh(&hinfo->lock);\r\ns_i = cb->args[0];\r\nfor (i = 0; i < (hinfo->hmask + 1); i++) {\r\nhead = &hinfo->htab[tcf_hash(i, hinfo->hmask)];\r\nhlist_for_each_entry_rcu(p, head, tcfc_head) {\r\nindex++;\r\nif (index < s_i)\r\ncontinue;\r\na->priv = p;\r\na->order = n_i;\r\nnest = nla_nest_start(skb, a->order);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nerr = tcf_action_dump_1(skb, a, 0, 0);\r\nif (err < 0) {\r\nindex--;\r\nnlmsg_trim(skb, nest);\r\ngoto done;\r\n}\r\nnla_nest_end(skb, nest);\r\nn_i++;\r\nif (n_i >= TCA_ACT_MAX_PRIO)\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nspin_unlock_bh(&hinfo->lock);\r\nif (n_i)\r\ncb->args[0] += n_i;\r\nreturn n_i;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\ngoto done;\r\n}\r\nstatic int tcf_del_walker(struct sk_buff *skb, struct tc_action *a)\r\n{\r\nstruct tcf_hashinfo *hinfo = a->ops->hinfo;\r\nstruct hlist_head *head;\r\nstruct hlist_node *n;\r\nstruct tcf_common *p;\r\nstruct nlattr *nest;\r\nint i = 0, n_i = 0;\r\nint ret = -EINVAL;\r\nnest = nla_nest_start(skb, a->order);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, TCA_KIND, a->ops->kind))\r\ngoto nla_put_failure;\r\nfor (i = 0; i < (hinfo->hmask + 1); i++) {\r\nhead = &hinfo->htab[tcf_hash(i, hinfo->hmask)];\r\nhlist_for_each_entry_safe(p, n, head, tcfc_head) {\r\na->priv = p;\r\nret = tcf_hash_release(a, 0);\r\nif (ret == ACT_P_DELETED) {\r\nmodule_put(a->ops->owner);\r\nn_i++;\r\n} else if (ret < 0)\r\ngoto nla_put_failure;\r\n}\r\n}\r\nif (nla_put_u32(skb, TCA_FCNT, n_i))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nreturn n_i;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn ret;\r\n}\r\nstatic int tcf_generic_walker(struct sk_buff *skb, struct netlink_callback *cb,\r\nint type, struct tc_action *a)\r\n{\r\nif (type == RTM_DELACTION) {\r\nreturn tcf_del_walker(skb, a);\r\n} else if (type == RTM_GETACTION) {\r\nreturn tcf_dump_walker(skb, cb, a);\r\n} else {\r\nWARN(1, "tcf_generic_walker: unknown action %d\n", type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic struct tcf_common *tcf_hash_lookup(u32 index, struct tcf_hashinfo *hinfo)\r\n{\r\nstruct tcf_common *p = NULL;\r\nstruct hlist_head *head;\r\nspin_lock_bh(&hinfo->lock);\r\nhead = &hinfo->htab[tcf_hash(index, hinfo->hmask)];\r\nhlist_for_each_entry_rcu(p, head, tcfc_head)\r\nif (p->tcfc_index == index)\r\nbreak;\r\nspin_unlock_bh(&hinfo->lock);\r\nreturn p;\r\n}\r\nu32 tcf_hash_new_index(struct tcf_hashinfo *hinfo)\r\n{\r\nu32 val = hinfo->index;\r\ndo {\r\nif (++val == 0)\r\nval = 1;\r\n} while (tcf_hash_lookup(val, hinfo));\r\nhinfo->index = val;\r\nreturn val;\r\n}\r\nint tcf_hash_search(struct tc_action *a, u32 index)\r\n{\r\nstruct tcf_hashinfo *hinfo = a->ops->hinfo;\r\nstruct tcf_common *p = tcf_hash_lookup(index, hinfo);\r\nif (p) {\r\na->priv = p;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint tcf_hash_check(u32 index, struct tc_action *a, int bind)\r\n{\r\nstruct tcf_hashinfo *hinfo = a->ops->hinfo;\r\nstruct tcf_common *p = NULL;\r\nif (index && (p = tcf_hash_lookup(index, hinfo)) != NULL) {\r\nif (bind)\r\np->tcfc_bindcnt++;\r\np->tcfc_refcnt++;\r\na->priv = p;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid tcf_hash_cleanup(struct tc_action *a, struct nlattr *est)\r\n{\r\nstruct tcf_common *pc = a->priv;\r\nif (est)\r\ngen_kill_estimator(&pc->tcfc_bstats,\r\n&pc->tcfc_rate_est);\r\nkfree_rcu(pc, tcfc_rcu);\r\n}\r\nint tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,\r\nint size, int bind)\r\n{\r\nstruct tcf_hashinfo *hinfo = a->ops->hinfo;\r\nstruct tcf_common *p = kzalloc(size, GFP_KERNEL);\r\nif (unlikely(!p))\r\nreturn -ENOMEM;\r\np->tcfc_refcnt = 1;\r\nif (bind)\r\np->tcfc_bindcnt = 1;\r\nspin_lock_init(&p->tcfc_lock);\r\nINIT_HLIST_NODE(&p->tcfc_head);\r\np->tcfc_index = index ? index : tcf_hash_new_index(hinfo);\r\np->tcfc_tm.install = jiffies;\r\np->tcfc_tm.lastuse = jiffies;\r\nif (est) {\r\nint err = gen_new_estimator(&p->tcfc_bstats, &p->tcfc_rate_est,\r\n&p->tcfc_lock, est);\r\nif (err) {\r\nkfree(p);\r\nreturn err;\r\n}\r\n}\r\na->priv = (void *) p;\r\nreturn 0;\r\n}\r\nvoid tcf_hash_insert(struct tc_action *a)\r\n{\r\nstruct tcf_common *p = a->priv;\r\nstruct tcf_hashinfo *hinfo = a->ops->hinfo;\r\nunsigned int h = tcf_hash(p->tcfc_index, hinfo->hmask);\r\nspin_lock_bh(&hinfo->lock);\r\nhlist_add_head(&p->tcfc_head, &hinfo->htab[h]);\r\nspin_unlock_bh(&hinfo->lock);\r\n}\r\nint tcf_register_action(struct tc_action_ops *act, unsigned int mask)\r\n{\r\nstruct tc_action_ops *a;\r\nint err;\r\nif (!act->act || !act->dump || !act->init)\r\nreturn -EINVAL;\r\nif (!act->lookup)\r\nact->lookup = tcf_hash_search;\r\nif (!act->walk)\r\nact->walk = tcf_generic_walker;\r\nact->hinfo = kmalloc(sizeof(struct tcf_hashinfo), GFP_KERNEL);\r\nif (!act->hinfo)\r\nreturn -ENOMEM;\r\nerr = tcf_hashinfo_init(act->hinfo, mask);\r\nif (err) {\r\nkfree(act->hinfo);\r\nreturn err;\r\n}\r\nwrite_lock(&act_mod_lock);\r\nlist_for_each_entry(a, &act_base, head) {\r\nif (act->type == a->type || (strcmp(act->kind, a->kind) == 0)) {\r\nwrite_unlock(&act_mod_lock);\r\ntcf_hashinfo_destroy(act->hinfo);\r\nkfree(act->hinfo);\r\nreturn -EEXIST;\r\n}\r\n}\r\nlist_add_tail(&act->head, &act_base);\r\nwrite_unlock(&act_mod_lock);\r\nreturn 0;\r\n}\r\nint tcf_unregister_action(struct tc_action_ops *act)\r\n{\r\nstruct tc_action_ops *a;\r\nint err = -ENOENT;\r\nwrite_lock(&act_mod_lock);\r\nlist_for_each_entry(a, &act_base, head) {\r\nif (a == act) {\r\nlist_del(&act->head);\r\ntcf_hashinfo_destroy(act->hinfo);\r\nkfree(act->hinfo);\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nwrite_unlock(&act_mod_lock);\r\nreturn err;\r\n}\r\nstatic struct tc_action_ops *tc_lookup_action_n(char *kind)\r\n{\r\nstruct tc_action_ops *a, *res = NULL;\r\nif (kind) {\r\nread_lock(&act_mod_lock);\r\nlist_for_each_entry(a, &act_base, head) {\r\nif (strcmp(kind, a->kind) == 0) {\r\nif (try_module_get(a->owner))\r\nres = a;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&act_mod_lock);\r\n}\r\nreturn res;\r\n}\r\nstatic struct tc_action_ops *tc_lookup_action(struct nlattr *kind)\r\n{\r\nstruct tc_action_ops *a, *res = NULL;\r\nif (kind) {\r\nread_lock(&act_mod_lock);\r\nlist_for_each_entry(a, &act_base, head) {\r\nif (nla_strcmp(kind, a->kind) == 0) {\r\nif (try_module_get(a->owner))\r\nres = a;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&act_mod_lock);\r\n}\r\nreturn res;\r\n}\r\nint tcf_action_exec(struct sk_buff *skb, const struct list_head *actions,\r\nstruct tcf_result *res)\r\n{\r\nconst struct tc_action *a;\r\nint ret = -1;\r\nif (skb->tc_verd & TC_NCLS) {\r\nskb->tc_verd = CLR_TC_NCLS(skb->tc_verd);\r\nret = TC_ACT_OK;\r\ngoto exec_done;\r\n}\r\nlist_for_each_entry(a, actions, list) {\r\nrepeat:\r\nret = a->ops->act(skb, a, res);\r\nif (TC_MUNGED & skb->tc_verd) {\r\nskb->tc_verd = SET_TC_OK2MUNGE(skb->tc_verd);\r\nskb->tc_verd = CLR_TC_MUNGED(skb->tc_verd);\r\n}\r\nif (ret == TC_ACT_REPEAT)\r\ngoto repeat;\r\nif (ret != TC_ACT_PIPE)\r\ngoto exec_done;\r\n}\r\nexec_done:\r\nreturn ret;\r\n}\r\nint tcf_action_destroy(struct list_head *actions, int bind)\r\n{\r\nstruct tc_action *a, *tmp;\r\nint ret = 0;\r\nlist_for_each_entry_safe(a, tmp, actions, list) {\r\nret = tcf_hash_release(a, bind);\r\nif (ret == ACT_P_DELETED)\r\nmodule_put(a->ops->owner);\r\nelse if (ret < 0)\r\nreturn ret;\r\nlist_del(&a->list);\r\nkfree(a);\r\n}\r\nreturn ret;\r\n}\r\nint\r\ntcf_action_dump_old(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\r\n{\r\nreturn a->ops->dump(skb, a, bind, ref);\r\n}\r\nint\r\ntcf_action_dump_1(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\r\n{\r\nint err = -EINVAL;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\nif (nla_put_string(skb, TCA_KIND, a->ops->kind))\r\ngoto nla_put_failure;\r\nif (tcf_action_copy_stats(skb, a, 0))\r\ngoto nla_put_failure;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nerr = tcf_action_dump_old(skb, a, bind, ref);\r\nif (err > 0) {\r\nnla_nest_end(skb, nest);\r\nreturn err;\r\n}\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nint\r\ntcf_action_dump(struct sk_buff *skb, struct list_head *actions, int bind, int ref)\r\n{\r\nstruct tc_action *a;\r\nint err = -EINVAL;\r\nstruct nlattr *nest;\r\nlist_for_each_entry(a, actions, list) {\r\nnest = nla_nest_start(skb, a->order);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nerr = tcf_action_dump_1(skb, a, bind, ref);\r\nif (err < 0)\r\ngoto errout;\r\nnla_nest_end(skb, nest);\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nerr = -EINVAL;\r\nerrout:\r\nnla_nest_cancel(skb, nest);\r\nreturn err;\r\n}\r\nstruct tc_action *tcf_action_init_1(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, char *name, int ovr,\r\nint bind)\r\n{\r\nstruct tc_action *a;\r\nstruct tc_action_ops *a_o;\r\nchar act_name[IFNAMSIZ];\r\nstruct nlattr *tb[TCA_ACT_MAX + 1];\r\nstruct nlattr *kind;\r\nint err;\r\nif (name == NULL) {\r\nerr = nla_parse_nested(tb, TCA_ACT_MAX, nla, NULL);\r\nif (err < 0)\r\ngoto err_out;\r\nerr = -EINVAL;\r\nkind = tb[TCA_ACT_KIND];\r\nif (kind == NULL)\r\ngoto err_out;\r\nif (nla_strlcpy(act_name, kind, IFNAMSIZ) >= IFNAMSIZ)\r\ngoto err_out;\r\n} else {\r\nerr = -EINVAL;\r\nif (strlcpy(act_name, name, IFNAMSIZ) >= IFNAMSIZ)\r\ngoto err_out;\r\n}\r\na_o = tc_lookup_action_n(act_name);\r\nif (a_o == NULL) {\r\n#ifdef CONFIG_MODULES\r\nrtnl_unlock();\r\nrequest_module("act_%s", act_name);\r\nrtnl_lock();\r\na_o = tc_lookup_action_n(act_name);\r\nif (a_o != NULL) {\r\nerr = -EAGAIN;\r\ngoto err_mod;\r\n}\r\n#endif\r\nerr = -ENOENT;\r\ngoto err_out;\r\n}\r\nerr = -ENOMEM;\r\na = kzalloc(sizeof(*a), GFP_KERNEL);\r\nif (a == NULL)\r\ngoto err_mod;\r\na->ops = a_o;\r\nINIT_LIST_HEAD(&a->list);\r\nif (name == NULL)\r\nerr = a_o->init(net, tb[TCA_ACT_OPTIONS], est, a, ovr, bind);\r\nelse\r\nerr = a_o->init(net, nla, est, a, ovr, bind);\r\nif (err < 0)\r\ngoto err_free;\r\nif (err != ACT_P_CREATED)\r\nmodule_put(a_o->owner);\r\nreturn a;\r\nerr_free:\r\nkfree(a);\r\nerr_mod:\r\nmodule_put(a_o->owner);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\n}\r\nint tcf_action_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, char *name, int ovr,\r\nint bind, struct list_head *actions)\r\n{\r\nstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];\r\nstruct tc_action *act;\r\nint err;\r\nint i;\r\nerr = nla_parse_nested(tb, TCA_ACT_MAX_PRIO, nla, NULL);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {\r\nact = tcf_action_init_1(net, tb[i], est, name, ovr, bind);\r\nif (IS_ERR(act)) {\r\nerr = PTR_ERR(act);\r\ngoto err;\r\n}\r\nact->order = i;\r\nlist_add_tail(&act->list, actions);\r\n}\r\nreturn 0;\r\nerr:\r\ntcf_action_destroy(actions, bind);\r\nreturn err;\r\n}\r\nint tcf_action_copy_stats(struct sk_buff *skb, struct tc_action *a,\r\nint compat_mode)\r\n{\r\nint err = 0;\r\nstruct gnet_dump d;\r\nstruct tcf_common *p = a->priv;\r\nif (p == NULL)\r\ngoto errout;\r\nif (compat_mode) {\r\nif (a->type == TCA_OLD_COMPAT)\r\nerr = gnet_stats_start_copy_compat(skb, 0,\r\nTCA_STATS, TCA_XSTATS, &p->tcfc_lock, &d);\r\nelse\r\nreturn 0;\r\n} else\r\nerr = gnet_stats_start_copy(skb, TCA_ACT_STATS,\r\n&p->tcfc_lock, &d);\r\nif (err < 0)\r\ngoto errout;\r\nif (gnet_stats_copy_basic(&d, &p->tcfc_bstats) < 0 ||\r\ngnet_stats_copy_rate_est(&d, &p->tcfc_bstats,\r\n&p->tcfc_rate_est) < 0 ||\r\ngnet_stats_copy_queue(&d, &p->tcfc_qstats) < 0)\r\ngoto errout;\r\nif (gnet_stats_finish_copy(&d) < 0)\r\ngoto errout;\r\nreturn 0;\r\nerrout:\r\nreturn -1;\r\n}\r\nstatic int\r\ntca_get_fill(struct sk_buff *skb, struct list_head *actions, u32 portid, u32 seq,\r\nu16 flags, int event, int bind, int ref)\r\n{\r\nstruct tcamsg *t;\r\nstruct nlmsghdr *nlh;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*t), flags);\r\nif (!nlh)\r\ngoto out_nlmsg_trim;\r\nt = nlmsg_data(nlh);\r\nt->tca_family = AF_UNSPEC;\r\nt->tca__pad1 = 0;\r\nt->tca__pad2 = 0;\r\nnest = nla_nest_start(skb, TCA_ACT_TAB);\r\nif (nest == NULL)\r\ngoto out_nlmsg_trim;\r\nif (tcf_action_dump(skb, actions, bind, ref) < 0)\r\ngoto out_nlmsg_trim;\r\nnla_nest_end(skb, nest);\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - b;\r\nreturn skb->len;\r\nout_nlmsg_trim:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int\r\nact_get_notify(struct net *net, u32 portid, struct nlmsghdr *n,\r\nstruct list_head *actions, int event)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nif (tca_get_fill(skb, actions, portid, n->nlmsg_seq, 0, event, 0, 0) <= 0) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nreturn rtnl_unicast(skb, net, portid);\r\n}\r\nstatic struct tc_action *create_a(int i)\r\n{\r\nstruct tc_action *act;\r\nact = kzalloc(sizeof(*act), GFP_KERNEL);\r\nif (act == NULL) {\r\npr_debug("create_a: failed to alloc!\n");\r\nreturn NULL;\r\n}\r\nact->order = i;\r\nINIT_LIST_HEAD(&act->list);\r\nreturn act;\r\n}\r\nstatic struct tc_action *\r\ntcf_action_get_1(struct nlattr *nla, struct nlmsghdr *n, u32 portid)\r\n{\r\nstruct nlattr *tb[TCA_ACT_MAX + 1];\r\nstruct tc_action *a;\r\nint index;\r\nint err;\r\nerr = nla_parse_nested(tb, TCA_ACT_MAX, nla, NULL);\r\nif (err < 0)\r\ngoto err_out;\r\nerr = -EINVAL;\r\nif (tb[TCA_ACT_INDEX] == NULL ||\r\nnla_len(tb[TCA_ACT_INDEX]) < sizeof(index))\r\ngoto err_out;\r\nindex = nla_get_u32(tb[TCA_ACT_INDEX]);\r\nerr = -ENOMEM;\r\na = create_a(0);\r\nif (a == NULL)\r\ngoto err_out;\r\nerr = -EINVAL;\r\na->ops = tc_lookup_action(tb[TCA_ACT_KIND]);\r\nif (a->ops == NULL)\r\ngoto err_free;\r\nerr = -ENOENT;\r\nif (a->ops->lookup(a, index) == 0)\r\ngoto err_mod;\r\nmodule_put(a->ops->owner);\r\nreturn a;\r\nerr_mod:\r\nmodule_put(a->ops->owner);\r\nerr_free:\r\nkfree(a);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void cleanup_a(struct list_head *actions)\r\n{\r\nstruct tc_action *a, *tmp;\r\nlist_for_each_entry_safe(a, tmp, actions, list) {\r\nlist_del(&a->list);\r\nkfree(a);\r\n}\r\n}\r\nstatic int tca_action_flush(struct net *net, struct nlattr *nla,\r\nstruct nlmsghdr *n, u32 portid)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *b;\r\nstruct nlmsghdr *nlh;\r\nstruct tcamsg *t;\r\nstruct netlink_callback dcb;\r\nstruct nlattr *nest;\r\nstruct nlattr *tb[TCA_ACT_MAX + 1];\r\nstruct nlattr *kind;\r\nstruct tc_action a;\r\nint err = -ENOMEM;\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb) {\r\npr_debug("tca_action_flush: failed skb alloc\n");\r\nreturn err;\r\n}\r\nb = skb_tail_pointer(skb);\r\nerr = nla_parse_nested(tb, TCA_ACT_MAX, nla, NULL);\r\nif (err < 0)\r\ngoto err_out;\r\nerr = -EINVAL;\r\nkind = tb[TCA_ACT_KIND];\r\nmemset(&a, 0, sizeof(struct tc_action));\r\nINIT_LIST_HEAD(&a.list);\r\na.ops = tc_lookup_action(kind);\r\nif (a.ops == NULL)\r\ngoto err_out;\r\nnlh = nlmsg_put(skb, portid, n->nlmsg_seq, RTM_DELACTION, sizeof(*t), 0);\r\nif (!nlh)\r\ngoto out_module_put;\r\nt = nlmsg_data(nlh);\r\nt->tca_family = AF_UNSPEC;\r\nt->tca__pad1 = 0;\r\nt->tca__pad2 = 0;\r\nnest = nla_nest_start(skb, TCA_ACT_TAB);\r\nif (nest == NULL)\r\ngoto out_module_put;\r\nerr = a.ops->walk(skb, &dcb, RTM_DELACTION, &a);\r\nif (err < 0)\r\ngoto out_module_put;\r\nif (err == 0)\r\ngoto noflush_out;\r\nnla_nest_end(skb, nest);\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - b;\r\nnlh->nlmsg_flags |= NLM_F_ROOT;\r\nmodule_put(a.ops->owner);\r\nerr = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\r\nn->nlmsg_flags & NLM_F_ECHO);\r\nif (err > 0)\r\nreturn 0;\r\nreturn err;\r\nout_module_put:\r\nmodule_put(a.ops->owner);\r\nerr_out:\r\nnoflush_out:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int\r\ntcf_del_notify(struct net *net, struct nlmsghdr *n, struct list_head *actions,\r\nu32 portid)\r\n{\r\nint ret;\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nif (tca_get_fill(skb, actions, portid, n->nlmsg_seq, 0, RTM_DELACTION,\r\n0, 1) <= 0) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nret = tcf_action_destroy(actions, 0);\r\nif (ret < 0) {\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nret = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\r\nn->nlmsg_flags & NLM_F_ECHO);\r\nif (ret > 0)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nstatic int\r\ntca_action_gd(struct net *net, struct nlattr *nla, struct nlmsghdr *n,\r\nu32 portid, int event)\r\n{\r\nint i, ret;\r\nstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];\r\nstruct tc_action *act;\r\nLIST_HEAD(actions);\r\nret = nla_parse_nested(tb, TCA_ACT_MAX_PRIO, nla, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nif (event == RTM_DELACTION && n->nlmsg_flags & NLM_F_ROOT) {\r\nif (tb[1] != NULL)\r\nreturn tca_action_flush(net, tb[1], n, portid);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nfor (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {\r\nact = tcf_action_get_1(tb[i], n, portid);\r\nif (IS_ERR(act)) {\r\nret = PTR_ERR(act);\r\ngoto err;\r\n}\r\nact->order = i;\r\nlist_add_tail(&act->list, &actions);\r\n}\r\nif (event == RTM_GETACTION)\r\nret = act_get_notify(net, portid, n, &actions, event);\r\nelse {\r\nret = tcf_del_notify(net, n, &actions, portid);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\n}\r\nerr:\r\ncleanup_a(&actions);\r\nreturn ret;\r\n}\r\nstatic int\r\ntcf_add_notify(struct net *net, struct nlmsghdr *n, struct list_head *actions,\r\nu32 portid)\r\n{\r\nstruct sk_buff *skb;\r\nint err = 0;\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nif (tca_get_fill(skb, actions, portid, n->nlmsg_seq, n->nlmsg_flags,\r\nRTM_NEWACTION, 0, 0) <= 0) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nerr = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\r\nn->nlmsg_flags & NLM_F_ECHO);\r\nif (err > 0)\r\nerr = 0;\r\nreturn err;\r\n}\r\nstatic int\r\ntcf_action_add(struct net *net, struct nlattr *nla, struct nlmsghdr *n,\r\nu32 portid, int ovr)\r\n{\r\nint ret = 0;\r\nLIST_HEAD(actions);\r\nret = tcf_action_init(net, nla, NULL, NULL, ovr, 0, &actions);\r\nif (ret)\r\ngoto done;\r\nret = tcf_add_notify(net, n, &actions, portid);\r\ncleanup_a(&actions);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int tc_ctl_action(struct sk_buff *skb, struct nlmsghdr *n)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlattr *tca[TCA_ACT_MAX + 1];\r\nu32 portid = skb ? NETLINK_CB(skb).portid : 0;\r\nint ret = 0, ovr = 0;\r\nif ((n->nlmsg_type != RTM_GETACTION) && !netlink_capable(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nret = nlmsg_parse(n, sizeof(struct tcamsg), tca, TCA_ACT_MAX, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nif (tca[TCA_ACT_TAB] == NULL) {\r\npr_notice("tc_ctl_action: received NO action attribs\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (n->nlmsg_type) {\r\ncase RTM_NEWACTION:\r\nif (n->nlmsg_flags & NLM_F_REPLACE)\r\novr = 1;\r\nreplay:\r\nret = tcf_action_add(net, tca[TCA_ACT_TAB], n, portid, ovr);\r\nif (ret == -EAGAIN)\r\ngoto replay;\r\nbreak;\r\ncase RTM_DELACTION:\r\nret = tca_action_gd(net, tca[TCA_ACT_TAB], n,\r\nportid, RTM_DELACTION);\r\nbreak;\r\ncase RTM_GETACTION:\r\nret = tca_action_gd(net, tca[TCA_ACT_TAB], n,\r\nportid, RTM_GETACTION);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn ret;\r\n}\r\nstatic struct nlattr *\r\nfind_dump_kind(const struct nlmsghdr *n)\r\n{\r\nstruct nlattr *tb1, *tb2[TCA_ACT_MAX + 1];\r\nstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];\r\nstruct nlattr *nla[TCAA_MAX + 1];\r\nstruct nlattr *kind;\r\nif (nlmsg_parse(n, sizeof(struct tcamsg), nla, TCAA_MAX, NULL) < 0)\r\nreturn NULL;\r\ntb1 = nla[TCA_ACT_TAB];\r\nif (tb1 == NULL)\r\nreturn NULL;\r\nif (nla_parse(tb, TCA_ACT_MAX_PRIO, nla_data(tb1),\r\nNLMSG_ALIGN(nla_len(tb1)), NULL) < 0)\r\nreturn NULL;\r\nif (tb[1] == NULL)\r\nreturn NULL;\r\nif (nla_parse(tb2, TCA_ACT_MAX, nla_data(tb[1]),\r\nnla_len(tb[1]), NULL) < 0)\r\nreturn NULL;\r\nkind = tb2[TCA_ACT_KIND];\r\nreturn kind;\r\n}\r\nstatic int\r\ntc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct nlmsghdr *nlh;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\nstruct tc_action_ops *a_o;\r\nstruct tc_action a;\r\nint ret = 0;\r\nstruct tcamsg *t = (struct tcamsg *) nlmsg_data(cb->nlh);\r\nstruct nlattr *kind = find_dump_kind(cb->nlh);\r\nif (kind == NULL) {\r\npr_info("tc_dump_action: action bad kind\n");\r\nreturn 0;\r\n}\r\na_o = tc_lookup_action(kind);\r\nif (a_o == NULL)\r\nreturn 0;\r\nmemset(&a, 0, sizeof(struct tc_action));\r\na.ops = a_o;\r\nnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\r\ncb->nlh->nlmsg_type, sizeof(*t), 0);\r\nif (!nlh)\r\ngoto out_module_put;\r\nt = nlmsg_data(nlh);\r\nt->tca_family = AF_UNSPEC;\r\nt->tca__pad1 = 0;\r\nt->tca__pad2 = 0;\r\nnest = nla_nest_start(skb, TCA_ACT_TAB);\r\nif (nest == NULL)\r\ngoto out_module_put;\r\nret = a_o->walk(skb, cb, RTM_GETACTION, &a);\r\nif (ret < 0)\r\ngoto out_module_put;\r\nif (ret > 0) {\r\nnla_nest_end(skb, nest);\r\nret = skb->len;\r\n} else\r\nnla_nest_cancel(skb, nest);\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - b;\r\nif (NETLINK_CB(cb->skb).portid && ret)\r\nnlh->nlmsg_flags |= NLM_F_MULTI;\r\nmodule_put(a_o->owner);\r\nreturn skb->len;\r\nout_module_put:\r\nmodule_put(a_o->owner);\r\nnlmsg_trim(skb, b);\r\nreturn skb->len;\r\n}\r\nstatic int __init tc_action_init(void)\r\n{\r\nrtnl_register(PF_UNSPEC, RTM_NEWACTION, tc_ctl_action, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_DELACTION, tc_ctl_action, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_GETACTION, tc_ctl_action, tc_dump_action,\r\nNULL);\r\nreturn 0;\r\n}
