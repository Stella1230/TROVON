static void dgrp_dump(u8 *mem, int len)\r\n{\r\nint i;\r\npr_debug("dgrp dump length = %d, data = ", len);\r\nfor (i = 0; i < len; ++i)\r\npr_debug("%.2x ", mem[i]);\r\npr_debug("\n");\r\n}\r\nstatic void dgrp_read_data_block(struct ch_struct *ch, u8 *flipbuf,\r\nint flipbuf_size)\r\n{\r\nint t;\r\nint n;\r\nif (flipbuf_size <= 0)\r\nreturn;\r\nt = RBUF_MAX - ch->ch_rout;\r\nn = flipbuf_size;\r\nif (n >= t) {\r\nmemcpy(flipbuf, ch->ch_rbuf + ch->ch_rout, t);\r\nflipbuf += t;\r\nn -= t;\r\nch->ch_rout = 0;\r\n}\r\nmemcpy(flipbuf, ch->ch_rbuf + ch->ch_rout, n);\r\nflipbuf += n;\r\nch->ch_rout += n;\r\n}\r\nstatic void dgrp_input(struct ch_struct *ch)\r\n{\r\nstruct nd_struct *nd;\r\nstruct tty_struct *tty;\r\nint data_len;\r\nint len;\r\nint tty_count;\r\nulong lock_flags;\r\nu8 *myflipbuf;\r\nu8 *myflipflagbuf;\r\nif (!ch)\r\nreturn;\r\nnd = ch->ch_nd;\r\nif (!nd)\r\nreturn;\r\nspin_lock_irqsave(&nd->nd_lock, lock_flags);\r\nmyflipbuf = nd->nd_inputbuf;\r\nmyflipflagbuf = nd->nd_inputflagbuf;\r\nif (!ch->ch_open_count) {\r\nch->ch_rout = ch->ch_rin;\r\ngoto out;\r\n}\r\nif (ch->ch_tun.un_flag & UN_CLOSING) {\r\nch->ch_rout = ch->ch_rin;\r\ngoto out;\r\n}\r\ntty = (ch->ch_tun).un_tty;\r\nif (!tty || tty->magic != TTY_MAGIC) {\r\nch->ch_rout = ch->ch_rin;\r\ngoto out;\r\n}\r\ntty_count = tty->count;\r\nif (!tty_count) {\r\nch->ch_rout = ch->ch_rin;\r\ngoto out;\r\n}\r\nif (tty->closing || test_bit(TTY_CLOSING, &tty->flags)) {\r\nch->ch_rout = ch->ch_rin;\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&nd->nd_lock, lock_flags);\r\ndata_len = (ch->ch_rin - ch->ch_rout) & RBUF_MASK;\r\nlen = tty_buffer_request_room(&ch->port, data_len);\r\nif ((nd->nd_dpa_debug) &&\r\n(nd->nd_dpa_flag & DPA_WAIT_SPACE) &&\r\n(nd->nd_dpa_port == MINOR(tty_devnum(ch->ch_tun.un_tty))))\r\nlen = 0;\r\nif ((len) && !(ch->ch_flag & CH_RXSTOP)) {\r\ndgrp_read_data_block(ch, myflipbuf, len);\r\nif (I_PARMRK(tty) || I_BRKINT(tty) || I_INPCK(tty))\r\nparity_scan(ch, myflipbuf, myflipflagbuf, &len);\r\nelse\r\nmemset(myflipflagbuf, TTY_NORMAL, len);\r\nif ((nd->nd_dpa_debug) &&\r\n(nd->nd_dpa_port == PORT_NUM(MINOR(tty_devnum(tty)))))\r\ndgrp_dpa_data(nd, 1, myflipbuf, len);\r\ntty_insert_flip_string_flags(&ch->port, myflipbuf,\r\nmyflipflagbuf, len);\r\ntty_flip_buffer_push(&ch->port);\r\nch->ch_rxcount += len;\r\n}\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\nreturn;\r\nout:\r\nspin_unlock_irqrestore(&nd->nd_lock, lock_flags);\r\n}\r\nstatic void parity_scan(struct ch_struct *ch, unsigned char *cbuf,\r\nunsigned char *fbuf, int *len)\r\n{\r\nint l = *len;\r\nint count = 0;\r\nint DOS = ((ch->ch_iflag & IF_DOSMODE) == 0 ? 0 : 1);\r\nunsigned char *cout;\r\nunsigned char *fout;\r\nunsigned char *in;\r\nunsigned char c;\r\nin = cbuf;\r\ncout = cbuf;\r\nfout = fbuf;\r\nwhile (l--) {\r\nc = *in;\r\nin++;\r\nswitch (ch->ch_pscan_state) {\r\ndefault:\r\nch->ch_pscan_state = 0;\r\ncase 0:\r\nif (c == 0xff)\r\nch->ch_pscan_state = 1;\r\nelse {\r\n*cout++ = c;\r\n*fout++ = TTY_NORMAL;\r\ncount += 1;\r\n}\r\nbreak;\r\ncase 1:\r\nif (c == 0xff) {\r\n*cout++ = c;\r\n*fout++ = TTY_NORMAL;\r\ncount += 1;\r\nch->ch_pscan_state = 0;\r\n} else {\r\nch->ch_pscan_savechar = c;\r\nch->ch_pscan_state = 2;\r\n}\r\nbreak;\r\ncase 2:\r\n*cout++ = c;\r\nif (DOS) {\r\nif (ch->ch_pscan_savechar & 0x10)\r\n*fout++ = TTY_BREAK;\r\nelse if (ch->ch_pscan_savechar & 0x08)\r\n*fout++ = TTY_FRAME;\r\nelse\r\n*fout++ = TTY_PARITY;\r\n} else {\r\nif (ch->ch_pscan_savechar & 0xff) {\r\npr_info("%s: parity_scan: error unexpected byte\n",\r\n__func__);\r\n*fout++ = TTY_PARITY;\r\n}\r\nelse if (c == 0xff)\r\n*fout++ = TTY_PARITY;\r\nelse\r\n*fout++ = TTY_BREAK;\r\n}\r\ncount += 1;\r\nch->ch_pscan_state = 0;\r\n}\r\n}\r\n*len = count;\r\n}\r\nstatic void dgrp_net_idle(struct nd_struct *nd)\r\n{\r\nstruct ch_struct *ch;\r\nint i;\r\nnd->nd_tx_work = 1;\r\nnd->nd_state = NS_IDLE;\r\nnd->nd_flag = 0;\r\nfor (i = nd->nd_seq_out; ; i = (i + 1) & SEQ_MASK) {\r\nif (!nd->nd_seq_wait[i]) {\r\nnd->nd_seq_wait[i] = 0;\r\nwake_up_interruptible(&nd->nd_seq_wque[i]);\r\n}\r\nif (i == nd->nd_seq_in)\r\nbreak;\r\n}\r\nnd->nd_seq_out = nd->nd_seq_in;\r\nnd->nd_unack = 0;\r\nnd->nd_remain = 0;\r\nnd->nd_tx_module = 0x10;\r\nnd->nd_rx_module = 0x00;\r\nfor (i = 0, ch = nd->nd_chan; i < CHAN_MAX; i++, ch++) {\r\nch->ch_state = CS_IDLE;\r\nch->ch_otype = 0;\r\nch->ch_otype_waiting = 0;\r\n}\r\n}\r\nstatic void increase_channel_count(struct nd_struct *nd, int n)\r\n{\r\nstruct ch_struct *ch;\r\nstruct device *classp;\r\nchar name[DEVICE_NAME_SIZE];\r\nint ret;\r\nu8 *buf;\r\nint i;\r\nfor (i = nd->nd_chan_count; i < n; ++i) {\r\nch = nd->nd_chan + i;\r\nbuf = kmalloc(TBUF_MAX, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nif (ch->ch_tbuf)\r\npr_info_ratelimited("%s - ch_tbuf was not NULL\n",\r\n__func__);\r\nch->ch_tbuf = buf;\r\nbuf = kmalloc(RBUF_MAX, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nif (ch->ch_rbuf)\r\npr_info("%s - ch_rbuf was not NULL\n",\r\n__func__);\r\nch->ch_rbuf = buf;\r\nclassp = tty_port_register_device(&ch->port,\r\nnd->nd_serial_ttdriver, i,\r\nNULL);\r\nch->ch_tun.un_sysfs = classp;\r\nsnprintf(name, DEVICE_NAME_SIZE, "tty_%d", i);\r\ndgrp_create_tty_sysfs(&ch->ch_tun, classp);\r\nret = sysfs_create_link(&nd->nd_class_dev->kobj,\r\n&classp->kobj, name);\r\nif (dgrp_register_prdevices) {\r\nclassp = tty_register_device(nd->nd_xprint_ttdriver,\r\ni, NULL);\r\nch->ch_pun.un_sysfs = classp;\r\nsnprintf(name, DEVICE_NAME_SIZE, "pr_%d", i);\r\ndgrp_create_tty_sysfs(&ch->ch_pun, classp);\r\nret = sysfs_create_link(&nd->nd_class_dev->kobj,\r\n&classp->kobj, name);\r\n}\r\nnd->nd_chan_count = i + 1;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\n}\r\nstatic void decrease_channel_count(struct nd_struct *nd, int n)\r\n{\r\nstruct ch_struct *ch;\r\nchar name[DEVICE_NAME_SIZE];\r\nint i;\r\nfor (i = nd->nd_chan_count - 1; i >= n; --i) {\r\nch = nd->nd_chan + i;\r\nch->ch_state = CS_IDLE;\r\nch->ch_otype = 0;\r\nch->ch_otype_waiting = 0;\r\nif (ch->ch_open_count != 0) {\r\nch->ch_flag |= CH_HANGUP;\r\ndgrp_carrier(ch);\r\n}\r\nif (ch->ch_open_count != 0)\r\nch->ch_flag |= CH_PORT_GONE;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\nnd->nd_chan_count = i;\r\nkfree(ch->ch_tbuf);\r\nch->ch_tbuf = NULL;\r\nkfree(ch->ch_rbuf);\r\nch->ch_rbuf = NULL;\r\nnd->nd_chan_count = i;\r\ndgrp_remove_tty_sysfs(ch->ch_tun.un_sysfs);\r\nsnprintf(name, DEVICE_NAME_SIZE, "tty_%d", i);\r\nsysfs_remove_link(&nd->nd_class_dev->kobj, name);\r\ntty_unregister_device(nd->nd_serial_ttdriver, i);\r\nif (dgrp_register_prdevices) {\r\ndgrp_remove_tty_sysfs(ch->ch_pun.un_sysfs);\r\nsnprintf(name, DEVICE_NAME_SIZE, "pr_%d", i);\r\nsysfs_remove_link(&nd->nd_class_dev->kobj, name);\r\ntty_unregister_device(nd->nd_xprint_ttdriver, i);\r\n}\r\n}\r\n}\r\nstatic void dgrp_chan_count(struct nd_struct *nd, int n)\r\n{\r\nif (n == nd->nd_chan_count)\r\nreturn;\r\nif (n > nd->nd_chan_count)\r\nincrease_channel_count(nd, n);\r\nif (n < nd->nd_chan_count)\r\ndecrease_channel_count(nd, n);\r\n}\r\nstatic void dgrp_monitor(struct nd_struct *nd, u8 *buf, int len)\r\n{\r\nint n;\r\nint r;\r\nint rtn;\r\ndown(&nd->nd_mon_semaphore);\r\nwhile ((len > 0) && (nd->nd_mon_buf)) {\r\nn = (nd->nd_mon_out - nd->nd_mon_in - 1) & MON_MASK;\r\nif (!n) {\r\nnd->nd_mon_flag |= MON_WAIT_SPACE;\r\nup(&nd->nd_mon_semaphore);\r\nrtn = wait_event_interruptible(nd->nd_mon_wqueue,\r\n((nd->nd_mon_flag & MON_WAIT_SPACE) == 0));\r\ndown(&nd->nd_mon_semaphore);\r\ncontinue;\r\n}\r\nif (n > len)\r\nn = len;\r\nr = MON_MAX - nd->nd_mon_in;\r\nif (r <= n) {\r\nmemcpy(nd->nd_mon_buf + nd->nd_mon_in, buf, r);\r\nn -= r;\r\nnd->nd_mon_in = 0;\r\nbuf += r;\r\nlen -= r;\r\n}\r\nmemcpy(nd->nd_mon_buf + nd->nd_mon_in, buf, n);\r\nnd->nd_mon_in += n;\r\nbuf += n;\r\nlen -= n;\r\nif (nd->nd_mon_in >= MON_MAX)\r\npr_info_ratelimited("%s - nd_mon_in (%i) >= MON_MAX\n",\r\n__func__, nd->nd_mon_in);\r\nif (nd->nd_mon_flag & MON_WAIT_DATA) {\r\nnd->nd_mon_flag &= ~MON_WAIT_DATA;\r\nwake_up_interruptible(&nd->nd_mon_wqueue);\r\n}\r\n}\r\nup(&nd->nd_mon_semaphore);\r\n}\r\nstatic void dgrp_encode_time(struct nd_struct *nd, u8 *buf)\r\n{\r\nulong t;\r\nt = jiffies - nd->nd_mon_lbolt;\r\nt = 1000 * (t / HZ) + 1000 * (t % HZ) / HZ;\r\nput_unaligned_be32((uint)(t & 0xffffffff), buf);\r\n}\r\nstatic void dgrp_monitor_message(struct nd_struct *nd, char *message)\r\n{\r\nu8 header[7];\r\nint n;\r\nheader[0] = RPDUMP_MESSAGE;\r\ndgrp_encode_time(nd, header + 1);\r\nn = strlen(message);\r\nput_unaligned_be16(n, header + 5);\r\ndgrp_monitor(nd, header, sizeof(header));\r\ndgrp_monitor(nd, (u8 *) message, n);\r\n}\r\nstatic void dgrp_monitor_reset(struct nd_struct *nd)\r\n{\r\nu8 header[5];\r\nheader[0] = RPDUMP_RESET;\r\ndgrp_encode_time(nd, header + 1);\r\ndgrp_monitor(nd, header, sizeof(header));\r\n}\r\nstatic void dgrp_monitor_data(struct nd_struct *nd, u8 type, u8 *buf, int size)\r\n{\r\nu8 header[7];\r\nheader[0] = type;\r\ndgrp_encode_time(nd, header + 1);\r\nput_unaligned_be16(size, header + 5);\r\ndgrp_monitor(nd, header, sizeof(header));\r\ndgrp_monitor(nd, buf, size);\r\n}\r\nstatic int alloc_nd_buffers(struct nd_struct *nd)\r\n{\r\nnd->nd_iobuf = NULL;\r\nnd->nd_writebuf = NULL;\r\nnd->nd_inputbuf = NULL;\r\nnd->nd_inputflagbuf = NULL;\r\nnd->nd_iobuf = kzalloc(UIO_MAX + 10, GFP_KERNEL);\r\nif (!nd->nd_iobuf)\r\ngoto out_err;\r\nnd->nd_writebuf = kzalloc(WRITEBUFLEN, GFP_KERNEL);\r\nif (!nd->nd_writebuf)\r\ngoto out_err;\r\nnd->nd_inputbuf = kzalloc(MYFLIPLEN, GFP_KERNEL);\r\nif (!nd->nd_inputbuf)\r\ngoto out_err;\r\nnd->nd_inputflagbuf = kzalloc(MYFLIPLEN, GFP_KERNEL);\r\nif (!nd->nd_inputflagbuf)\r\ngoto out_err;\r\nreturn 0;\r\nout_err:\r\nkfree(nd->nd_iobuf);\r\nkfree(nd->nd_writebuf);\r\nkfree(nd->nd_inputbuf);\r\nkfree(nd->nd_inputflagbuf);\r\nreturn -ENOMEM;\r\n}\r\nstatic int dgrp_net_open(struct inode *inode, struct file *file)\r\n{\r\nstruct nd_struct *nd;\r\nulong lock_flags;\r\nint rtn;\r\nrtn = try_module_get(THIS_MODULE);\r\nif (!rtn)\r\nreturn -EAGAIN;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nrtn = -EPERM;\r\ngoto done;\r\n}\r\nif (file->private_data) {\r\nrtn = -EINVAL;\r\ngoto done;\r\n}\r\nnd = PDE_DATA(inode);\r\nif (!nd) {\r\nrtn = -ENXIO;\r\ngoto done;\r\n}\r\nfile->private_data = (void *) nd;\r\ndown(&nd->nd_net_semaphore);\r\nif (nd->nd_state != NS_CLOSED) {\r\nrtn = -EBUSY;\r\ngoto unlock;\r\n}\r\nnd->nd_link.lk_fast_rate = UIO_MAX;\r\nnd->nd_link.lk_slow_rate = UIO_MAX;\r\nnd->nd_link.lk_fast_delay = 1000;\r\nnd->nd_link.lk_slow_delay = 1000;\r\nnd->nd_link.lk_header_size = 46;\r\nrtn = alloc_nd_buffers(nd);\r\nif (rtn)\r\ngoto unlock;\r\ndgrp_net_idle(nd);\r\nnd->nd_tx_time = jiffies;\r\nspin_lock_irqsave(&dgrp_poll_data.poll_lock, lock_flags);\r\nif (!dgrp_poll_data.node_active_count) {\r\ndgrp_poll_data.node_active_count = 2;\r\ndgrp_poll_data.timer.expires = jiffies +\r\ndgrp_poll_tick * HZ / 1000;\r\nadd_timer(&dgrp_poll_data.timer);\r\n}\r\nspin_unlock_irqrestore(&dgrp_poll_data.poll_lock, lock_flags);\r\ndgrp_monitor_message(nd, "Net Open");\r\nunlock:\r\nup(&nd->nd_net_semaphore);\r\ndone:\r\nif (rtn)\r\nmodule_put(THIS_MODULE);\r\nreturn rtn;\r\n}\r\nstatic int dgrp_net_release(struct inode *inode, struct file *file)\r\n{\r\nstruct nd_struct *nd;\r\nulong lock_flags;\r\nnd = (struct nd_struct *)(file->private_data);\r\nif (!nd)\r\ngoto done;\r\ndown(&nd->nd_net_semaphore);\r\ndgrp_net_idle(nd);\r\nnd->nd_state = NS_CLOSED;\r\nnd->nd_flag = 0;\r\nif (waitqueue_active(&nd->nd_tx_waitq))\r\npr_info("%s - expected waitqueue_active to be false\n",\r\n__func__);\r\nnd->nd_send = 0;\r\nkfree(nd->nd_iobuf);\r\nnd->nd_iobuf = NULL;\r\nkfree(nd->nd_writebuf);\r\nnd->nd_writebuf = NULL;\r\nkfree(nd->nd_inputbuf);\r\nnd->nd_inputbuf = NULL;\r\nkfree(nd->nd_inputflagbuf);\r\nnd->nd_inputflagbuf = NULL;\r\ndgrp_chan_count(nd, 0);\r\nup(&nd->nd_net_semaphore);\r\nspin_lock_irqsave(&dgrp_poll_data.poll_lock, lock_flags);\r\nif (dgrp_poll_data.node_active_count == 2) {\r\ndel_timer(&dgrp_poll_data.timer);\r\ndgrp_poll_data.node_active_count = 0;\r\n}\r\nspin_unlock_irqrestore(&dgrp_poll_data.poll_lock, lock_flags);\r\ndown(&nd->nd_net_semaphore);\r\ndgrp_monitor_message(nd, "Net Close");\r\nup(&nd->nd_net_semaphore);\r\ndone:\r\nmodule_put(THIS_MODULE);\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic inline u8 *set_cmd_header(u8 *b, u8 port, u8 cmd)\r\n{\r\n*b++ = 0xb0 + (port & 0x0f);\r\n*b++ = cmd;\r\nreturn b;\r\n}\r\nstatic int dgrp_send(struct nd_struct *nd, long tmax)\r\n{\r\nstruct ch_struct *ch = nd->nd_chan;\r\nu8 *b;\r\nu8 *buf;\r\nu8 *mbuf;\r\nu8 port;\r\nint mod;\r\nlong send;\r\nint maxport;\r\nlong lastport = -1;\r\nushort rwin;\r\nlong in;\r\nushort n;\r\nlong t;\r\nlong ttotal;\r\nlong tchan;\r\nlong tsend;\r\nushort tsafe;\r\nlong work;\r\nlong send_sync;\r\nlong wanted_sync_port = -1;\r\nushort tdata[CHAN_MAX];\r\nlong used_buffer;\r\nmbuf = nd->nd_iobuf + UIO_BASE;\r\nbuf = b = mbuf;\r\nsend_sync = nd->nd_link.lk_slow_rate < UIO_MAX;\r\nttotal = 0;\r\ntchan = 0;\r\nmemset(tdata, 0, sizeof(tdata));\r\nif (nd->nd_send & NR_PASSWORD) {\r\nb[0] = 0xfc;\r\nb[1] = 0x20;\r\nput_unaligned_be16(strlen(nd->password), b + 2);\r\nb += 4;\r\nb += strlen(nd->password);\r\nnd->nd_send &= ~(NR_PASSWORD);\r\n}\r\nfor (mod = 0, port = 0; port < nd->nd_chan_count; mod++) {\r\nif (mod != nd->nd_tx_module)\r\nmbuf = ++b;\r\nmaxport = port + 16;\r\nif (maxport > nd->nd_chan_count)\r\nmaxport = nd->nd_chan_count;\r\nfor (; port < maxport; port++, ch++) {\r\nswitch (ch->ch_state) {\r\ncase CS_IDLE:\r\nif (ch->ch_open_error) {\r\nif (ch->ch_wait_count[ch->ch_otype]) {\r\nwork = 1;\r\nbreak;\r\n}\r\nch->ch_open_error = 0;\r\n}\r\nif ((ch->ch_flag & CH_HANGUP) != 0)\r\nbreak;\r\nif ((ch->ch_flag & CH_PORT_GONE) ||\r\nch->ch_wait_count[OTYPE_IMMEDIATE] != 0) {\r\nb = set_cmd_header(b, port, 10);\r\n*b++ = 0;\r\nch->ch_state = CS_WAIT_OPEN;\r\nch->ch_otype = OTYPE_IMMEDIATE;\r\nbreak;\r\n}\r\nif (ch->ch_otype_waiting == 0) {\r\nif (ch->ch_wait_count[OTYPE_PERSISTENT] != 0) {\r\nb = set_cmd_header(b, port, 10);\r\n*b++ = 1;\r\nch->ch_state = CS_WAIT_OPEN;\r\nch->ch_otype = OTYPE_PERSISTENT;\r\n} else if (ch->ch_wait_count[OTYPE_INCOMING] != 0) {\r\nb = set_cmd_header(b, port, 10);\r\n*b++ = 2;\r\nch->ch_state = CS_WAIT_OPEN;\r\nch->ch_otype = OTYPE_INCOMING;\r\n}\r\nbreak;\r\n}\r\nif (ch->ch_wait_count[ch->ch_otype_waiting] == 0) {\r\nb = set_cmd_header(b, port, 10);\r\n*b++ = 4;\r\nch->ch_state = CS_WAIT_CANCEL;\r\nch->ch_otype = ch->ch_otype_waiting;\r\n}\r\nbreak;\r\ncase CS_SEND_QUERY:\r\nch->ch_flag |= CH_PARAM;\r\nch->ch_flag &= ~CH_RX_FLUSH;\r\nch->ch_expect = 0;\r\nch->ch_s_tin = 0;\r\nch->ch_s_tpos = 0;\r\nch->ch_s_tsize = 0;\r\nch->ch_s_treq = 0;\r\nch->ch_s_elast = 0;\r\nch->ch_s_rin = 0;\r\nch->ch_s_rwin = 0;\r\nch->ch_s_rsize = 0;\r\nch->ch_s_tmax = 0;\r\nch->ch_s_ttime = 0;\r\nch->ch_s_rmax = 0;\r\nch->ch_s_rtime = 0;\r\nch->ch_s_rlow = 0;\r\nch->ch_s_rhigh = 0;\r\nch->ch_s_brate = 0;\r\nch->ch_s_iflag = 0;\r\nch->ch_s_cflag = 0;\r\nch->ch_s_oflag = 0;\r\nch->ch_s_xflag = 0;\r\nch->ch_s_mout = 0;\r\nch->ch_s_mflow = 0;\r\nch->ch_s_mctrl = 0;\r\nch->ch_s_xon = 0;\r\nch->ch_s_xoff = 0;\r\nch->ch_s_lnext = 0;\r\nch->ch_s_xxon = 0;\r\nch->ch_s_xxoff = 0;\r\nb = set_cmd_header(b, port, 14);\r\nb = set_cmd_header(b, port, 42);\r\nput_unaligned_be16(0x02c0, b);\r\nb += 2;\r\n*b++ = (DM_DTR | DM_RTS | DM_CTS |\r\nDM_DSR | DM_RI | DM_CD);\r\nb = set_cmd_header(b, port, 16);\r\nb = set_cmd_header(b, port, 20);\r\nb = set_cmd_header(b, port, 22);\r\nch->ch_expect = (RR_SEQUENCE |\r\nRR_STATUS |\r\nRR_BUFFER |\r\nRR_CAPABILITY);\r\nch->ch_state = CS_WAIT_QUERY;\r\nb = set_cmd_header(b, port, 44);\r\nif (ch->ch_flag & CH_PORT_GONE)\r\nch->ch_s_mout = ch->ch_mout;\r\nelse\r\nch->ch_s_mout = ch->ch_mout = DM_DTR | DM_RTS;\r\n*b++ = ch->ch_mout;\r\n*b++ = ch->ch_s_mflow = 0;\r\n*b++ = ch->ch_s_mctrl = ch->ch_mctrl = 0;\r\nif (ch->ch_flag & CH_PORT_GONE)\r\nch->ch_flag &= ~CH_PORT_GONE;\r\nbreak;\r\ncase CS_READY:\r\nif (ch->ch_open_count == 0 &&\r\nch->ch_wait_count[ch->ch_otype] == 0) {\r\ngoto send_close;\r\n}\r\nif (ch->ch_rin != ch->ch_rout) {\r\nif (ch->ch_tun.un_open_count == 0 ||\r\n(ch->ch_tun.un_flag & UN_CLOSING) ||\r\n(ch->ch_cflag & CF_CREAD) == 0) {\r\nch->ch_rout = ch->ch_rin;\r\n} else if ((ch->ch_flag & CH_FAST_READ) == 0 ||\r\nch->ch_inwait != 0) {\r\ndgrp_input(ch);\r\nif (ch->ch_rin != ch->ch_rout)\r\nwork = 1;\r\n}\r\n}\r\nif (ch->ch_flag & (CH_RX_FLUSH | CH_PARAM)) {\r\nif (ch->ch_flag & CH_RX_FLUSH) {\r\nif (((ch->ch_flush_seq - nd->nd_seq_out) & SEQ_MASK) >\r\n((nd->nd_seq_in - nd->nd_seq_out) & SEQ_MASK))\r\nch->ch_flag &= ~CH_RX_FLUSH;\r\nelse\r\nwork = 1;\r\n}\r\nif (ch->ch_s_tmax != ch->ch_tmax ||\r\nch->ch_s_ttime != ch->ch_ttime) {\r\nb = set_cmd_header(b, port, 48);\r\nch->ch_s_tmax = ch->ch_tmax;\r\nch->ch_s_ttime = ch->ch_ttime;\r\nput_unaligned_be16(ch->ch_s_tmax,\r\nb);\r\nb += 2;\r\nput_unaligned_be16(ch->ch_s_ttime,\r\nb);\r\nb += 2;\r\n}\r\nif (ch->ch_s_rlow != ch->ch_rlow ||\r\nch->ch_s_rhigh != ch->ch_rhigh) {\r\nb = set_cmd_header(b, port, 45);\r\nch->ch_s_rlow = ch->ch_rlow;\r\nch->ch_s_rhigh = ch->ch_rhigh;\r\nput_unaligned_be16(ch->ch_s_rlow,\r\nb);\r\nb += 2;\r\nput_unaligned_be16(ch->ch_s_rhigh,\r\nb);\r\nb += 2;\r\n}\r\nif (ch->ch_s_brate != ch->ch_brate ||\r\nch->ch_s_cflag != ch->ch_cflag ||\r\nch->ch_s_iflag != ch->ch_iflag ||\r\nch->ch_s_oflag != ch->ch_oflag ||\r\nch->ch_s_xflag != ch->ch_xflag) {\r\nb = set_cmd_header(b, port, 40);\r\nch->ch_s_brate = ch->ch_brate;\r\nch->ch_s_cflag = ch->ch_cflag;\r\nch->ch_s_iflag = ch->ch_iflag;\r\nch->ch_s_oflag = ch->ch_oflag;\r\nch->ch_s_xflag = ch->ch_xflag;\r\nput_unaligned_be16(ch->ch_s_brate,\r\nb);\r\nb += 2;\r\nput_unaligned_be16(ch->ch_s_cflag,\r\nb);\r\nb += 2;\r\nput_unaligned_be16(ch->ch_s_iflag,\r\nb);\r\nb += 2;\r\nput_unaligned_be16(ch->ch_s_oflag,\r\nb);\r\nb += 2;\r\nput_unaligned_be16(ch->ch_s_xflag,\r\nb);\r\nb += 2;\r\n}\r\nif (ch->ch_s_mout != ch->ch_mout ||\r\nch->ch_s_mflow != ch->ch_mflow ||\r\nch->ch_s_mctrl != ch->ch_mctrl) {\r\nb = set_cmd_header(b, port, 44);\r\n*b++ = ch->ch_s_mout = ch->ch_mout;\r\n*b++ = ch->ch_s_mflow = ch->ch_mflow;\r\n*b++ = ch->ch_s_mctrl = ch->ch_mctrl;\r\n}\r\nif (ch->ch_s_xon != ch->ch_xon ||\r\nch->ch_s_xoff != ch->ch_xoff ||\r\nch->ch_s_lnext != ch->ch_lnext ||\r\nch->ch_s_xxon != ch->ch_xxon ||\r\nch->ch_s_xxoff != ch->ch_xxoff) {\r\nb = set_cmd_header(b, port, 46);\r\n*b++ = ch->ch_s_xon = ch->ch_xon;\r\n*b++ = ch->ch_s_xoff = ch->ch_xoff;\r\n*b++ = ch->ch_s_lnext = ch->ch_lnext;\r\n*b++ = ch->ch_s_xxon = ch->ch_xxon;\r\n*b++ = ch->ch_s_xxoff = ch->ch_xxoff;\r\n}\r\nif (ch->ch_s_rmax != ch->ch_rmax ||\r\nch->ch_s_rtime != ch->ch_rtime) {\r\nb = set_cmd_header(b, port, 47);\r\nch->ch_s_rmax = ch->ch_rmax;\r\nch->ch_s_rtime = ch->ch_rtime;\r\nput_unaligned_be16(ch->ch_s_rmax,\r\nb);\r\nb += 2;\r\nput_unaligned_be16(ch->ch_s_rtime,\r\nb);\r\nb += 2;\r\n}\r\nch->ch_flag &= ~CH_PARAM;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\nif (ch->ch_send != 0) {\r\nsend = ch->ch_send & ~ch->ch_expect;\r\nif ((send & RR_TX_ICHAR) != 0) {\r\nb = set_cmd_header(b, port, 60);\r\n*b++ = ch->ch_xon;\r\nch->ch_expect |= RR_TX_ICHAR;\r\n}\r\nif ((send & RR_TX_BREAK) != 0) {\r\nif (ch->ch_break_time != 0) {\r\nb = set_cmd_header(b, port, 61);\r\nput_unaligned_be16(ch->ch_break_time,\r\nb);\r\nb += 2;\r\nch->ch_expect |= RR_TX_BREAK;\r\nch->ch_break_time = 0;\r\n} else {\r\nch->ch_send &= ~RR_TX_BREAK;\r\nch->ch_flag &= ~CH_TX_BREAK;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\n}\r\nif ((send & (RR_RX_FLUSH | RR_TX_FLUSH)) != 0) {\r\nb = set_cmd_header(b, port, 62);\r\n*b++ = ((send & RR_TX_FLUSH) == 0 ? 1 :\r\n(send & RR_RX_FLUSH) == 0 ? 2 : 3);\r\nif (send & RR_RX_FLUSH) {\r\nch->ch_flush_seq = nd->nd_seq_in;\r\nch->ch_flag |= CH_RX_FLUSH;\r\nwork = 1;\r\nsend_sync = 1;\r\nwanted_sync_port = port;\r\n}\r\nch->ch_send &= ~(RR_RX_FLUSH | RR_TX_FLUSH);\r\n}\r\nif ((send & (RR_RX_STOP | RR_TX_STOP)) != 0) {\r\nb = set_cmd_header(b, port, 63);\r\n*b = 0;\r\nif ((send & RR_TX_STOP) != 0)\r\n*b |= EV_OPU;\r\nif ((send & RR_RX_STOP) != 0)\r\n*b |= EV_IPU;\r\nb++;\r\nch->ch_send &= ~(RR_RX_STOP | RR_TX_STOP);\r\n}\r\nif ((send & (RR_RX_START | RR_TX_START)) != 0) {\r\nb = set_cmd_header(b, port, 64);\r\n*b = 0;\r\nif ((send & RR_TX_START) != 0)\r\n*b |= EV_OPU | EV_OPS | EV_OPX;\r\nif ((send & RR_RX_START) != 0)\r\n*b |= EV_IPU | EV_IPS;\r\nb++;\r\nch->ch_send &= ~(RR_RX_START | RR_TX_START);\r\n}\r\n}\r\nrwin = (ch->ch_s_rin +\r\n((ch->ch_rout - ch->ch_rin - 1) & RBUF_MASK));\r\nn = (rwin - ch->ch_s_rwin) & 0xffff;\r\nif (n >= RBUF_MAX / 4) {\r\nb[0] = 0xa0 + (port & 0xf);\r\nch->ch_s_rwin = rwin;\r\nput_unaligned_be16(rwin, b + 1);\r\nb += 3;\r\n}\r\nn = (ch->ch_tin - ch->ch_tout) & TBUF_MASK;\r\nif ((ch->ch_tun.un_flag & (UN_EMPTY|UN_LOW)) != 0) {\r\nif ((ch->ch_tun.un_flag & UN_LOW) != 0 ?\r\n(n <= TBUF_LOW) :\r\n(n == 0 && ch->ch_s_tpos == ch->ch_s_tin)) {\r\nch->ch_tun.un_flag &= ~(UN_EMPTY|UN_LOW);\r\nif (waitqueue_active(&((ch->ch_tun.un_tty)->write_wait)))\r\nwake_up_interruptible(&((ch->ch_tun.un_tty)->write_wait));\r\ntty_wakeup(ch->ch_tun.un_tty);\r\nn = (ch->ch_tin - ch->ch_tout) & TBUF_MASK;\r\n}\r\n}\r\nif (ch->ch_pun.un_open_count &&\r\n(ch->ch_pun.un_flag &\r\n(UN_EMPTY|UN_TIME|UN_LOW|UN_PWAIT)) != 0) {\r\nif ((ch->ch_pun.un_flag & UN_LOW) != 0 ?\r\n(n <= TBUF_LOW) :\r\n(ch->ch_pun.un_flag & UN_TIME) != 0 ?\r\ntime_is_before_jiffies(ch->ch_waketime) :\r\n(n == 0 && ch->ch_s_tpos == ch->ch_s_tin) &&\r\n((ch->ch_pun.un_flag & UN_EMPTY) != 0 ||\r\n((ch->ch_tun.un_open_count &&\r\nch->ch_tun.un_tty->ops->chars_in_buffer) ?\r\n(ch->ch_tun.un_tty->ops->chars_in_buffer)(ch->ch_tun.un_tty) == 0\r\n: 1\r\n)\r\n)) {\r\nch->ch_pun.un_flag &= ~(UN_EMPTY | UN_TIME | UN_LOW | UN_PWAIT);\r\nif (waitqueue_active(&((ch->ch_pun.un_tty)->write_wait)))\r\nwake_up_interruptible(&((ch->ch_pun.un_tty)->write_wait));\r\ntty_wakeup(ch->ch_pun.un_tty);\r\nn = (ch->ch_tin - ch->ch_tout) & TBUF_MASK;\r\n} else if ((ch->ch_pun.un_flag & UN_TIME) != 0) {\r\nwork = 1;\r\n}\r\n}\r\nt = ((ch->ch_s_tsize + ch->ch_s_tpos - ch->ch_s_tin) & 0xffff);\r\nif (n > t)\r\nn = t;\r\nif (n != 0) {\r\nn += (n <= 8 ? 1 : n <= 255 ? 2 : 3);\r\ntdata[tchan++] = n;\r\nttotal += n;\r\n}\r\nbreak;\r\nsend_close:\r\ncase CS_SEND_CLOSE:\r\nb = set_cmd_header(b, port, 10);\r\nif (ch->ch_otype == OTYPE_IMMEDIATE)\r\n*b++ = 3;\r\nelse\r\n*b++ = 4;\r\nch->ch_state = CS_WAIT_CLOSE;\r\nbreak;\r\ncase CS_WAIT_OPEN:\r\ncase CS_WAIT_CANCEL:\r\ncase CS_WAIT_FAIL:\r\ncase CS_WAIT_QUERY:\r\ncase CS_WAIT_CLOSE:\r\nbreak;\r\ndefault:\r\npr_info("%s - unexpected channel state (%i)\n",\r\n__func__, ch->ch_state);\r\n}\r\n}\r\nif (mod != nd->nd_tx_module) {\r\nif (b != mbuf) {\r\nmbuf[-1] = 0xf0 | mod;\r\nnd->nd_tx_module = mod;\r\n} else {\r\nb--;\r\n}\r\n}\r\n}\r\nn = UIO_MAX - UIO_BASE;\r\nif (tmax > n)\r\ntmax = n;\r\ntmax -= 64;\r\ntsafe = tmax;\r\ntmax -= 5 + 3 + 4 * nd->nd_chan_count;\r\nn = nd->nd_tx_deposit - nd->nd_tx_charge - nd->nd_link.lk_header_size;\r\nif (tmax > n)\r\ntmax = n;\r\ntmax -= b - buf;\r\nif (tmax < 2 * nd->nd_chan_count) {\r\ntsend = 1;\r\n} else if (tchan > 1 && ttotal > tmax) {\r\nlong tm = tmax;\r\nint tc = tchan;\r\nint try;\r\ntsend = tm / tc;\r\nfor (try = 0; try < 3; try++) {\r\nint i;\r\nint c = 0;\r\nfor (i = 0; i < tc; i++) {\r\nif (tsend < tdata[i])\r\ntdata[c++] = tdata[i];\r\nelse\r\ntm -= tdata[i];\r\n}\r\nif (c == tc)\r\nbreak;\r\ntsend = tm / c;\r\nif (c == 1)\r\nbreak;\r\ntc = c;\r\n}\r\ntsend = tm / nd->nd_chan_count;\r\nif (tsend < 2)\r\ntsend = 1;\r\n} else {\r\ntsend = tmax;\r\n}\r\ntsend -= (tsend <= 9) ? 1 : (tsend <= 257) ? 2 : 3;\r\nport = 0;\r\nch = nd->nd_chan;\r\nused_buffer = tmax;\r\nfor (mod = 0; port < nd->nd_chan_count; mod++) {\r\nif (mod != nd->nd_tx_module)\r\nmbuf = ++b;\r\nmaxport = port + 16;\r\nif (maxport > nd->nd_chan_count)\r\nmaxport = nd->nd_chan_count;\r\nfor (; port < maxport; port++, ch++) {\r\nif (ch->ch_state != CS_READY)\r\ncontinue;\r\nlastport = port;\r\nn = (ch->ch_tin - ch->ch_tout) & TBUF_MASK;\r\nif (n != 0 && used_buffer > 0) {\r\nt = (ch->ch_s_tsize + ch->ch_s_tpos - ch->ch_s_tin) & 0xffff;\r\nif (n > t)\r\nn = t;\r\nif (n > tsend) {\r\nwork = 1;\r\nn = tsend;\r\n}\r\nif (n > used_buffer) {\r\nwork = 1;\r\nn = used_buffer;\r\n}\r\nif (n <= 0)\r\ncontinue;\r\nif (n <= 8) {\r\nb[0] = ((n - 1) << 4) + (port & 0xf);\r\nb += 1;\r\n} else if (n <= 255) {\r\nb[0] = 0x80 + (port & 0xf);\r\nb[1] = n;\r\nb += 2;\r\n} else {\r\nb[0] = 0x90 + (port & 0xf);\r\nput_unaligned_be16(n, b + 1);\r\nb += 3;\r\n}\r\nch->ch_s_tin = (ch->ch_s_tin + n) & 0xffff;\r\nt = TBUF_MAX - ch->ch_tout;\r\nif (n >= t) {\r\nmemcpy(b, ch->ch_tbuf + ch->ch_tout, t);\r\nb += t;\r\nn -= t;\r\nused_buffer -= t;\r\nch->ch_tout = 0;\r\n}\r\nmemcpy(b, ch->ch_tbuf + ch->ch_tout, n);\r\nb += n;\r\nused_buffer -= n;\r\nch->ch_tout += n;\r\nn = (ch->ch_tin - ch->ch_tout) & TBUF_MASK;\r\n}\r\nif (n > TBUF_LOW)\r\ncontinue;\r\nif ((ch->ch_flag & CH_LOW) != 0) {\r\nch->ch_flag &= ~CH_LOW;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\nif (ch->ch_tun.un_open_count) {\r\nstruct tty_struct *tty = (ch->ch_tun.un_tty);\r\nif (waitqueue_active(&tty->write_wait))\r\nwake_up_interruptible(&tty->write_wait);\r\ntty_wakeup(tty);\r\n}\r\nif (ch->ch_pun.un_open_count) {\r\nstruct tty_struct *tty = (ch->ch_pun.un_tty);\r\nif (waitqueue_active(&tty->write_wait))\r\nwake_up_interruptible(&tty->write_wait);\r\ntty_wakeup(tty);\r\n}\r\nif (n != 0)\r\ncontinue;\r\nif ((ch->ch_flag & (CH_EMPTY | CH_DRAIN)) != 0 ||\r\n(ch->ch_pun.un_flag & UN_EMPTY) != 0) {\r\nif (ch->ch_s_treq != ch->ch_s_tin) {\r\nb = set_cmd_header(b, port, 43);\r\nch->ch_s_treq = ch->ch_s_tin;\r\nput_unaligned_be16(ch->ch_s_treq,\r\nb);\r\nb += 2;\r\n}\r\nelse if ((ch->ch_flag & CH_EMPTY) != 0 &&\r\n(ch->ch_send & RR_TX_BREAK) == 0) {\r\nch->ch_flag &= ~CH_EMPTY;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\n}\r\n}\r\nif (mod != nd->nd_tx_module) {\r\nif (b != mbuf) {\r\nmbuf[-1] = 0xf0 | mod;\r\nnd->nd_tx_module = mod;\r\n} else {\r\nb--;\r\n}\r\n}\r\n}\r\nin = nd->nd_seq_in;\r\nif ((send_sync || nd->nd_seq_wait[in] != 0) && lastport >= 0) {\r\nu8 *bb = b;\r\nif (wanted_sync_port >= 0)\r\nlastport = wanted_sync_port;\r\nch = nd->nd_chan + lastport;\r\nch->ch_flag |= CH_WAITING_SYNC;\r\nmod = lastport >> 4;\r\nif (mod != nd->nd_tx_module) {\r\nbb[0] = 0xf0 + mod;\r\nbb += 1;\r\nnd->nd_tx_module = mod;\r\n}\r\nbb = set_cmd_header(bb, lastport, 12);\r\n*bb++ = in;\r\nnd->nd_seq_size[in] = bb - buf;\r\nnd->nd_seq_time[in] = jiffies;\r\nif (++in >= SEQ_MAX)\r\nin = 0;\r\nif (in != nd->nd_seq_out) {\r\nb = bb;\r\nnd->nd_seq_in = in;\r\nnd->nd_unack += b - buf;\r\n}\r\n}\r\nelse if (nd->nd_seq_wait[in] != 0) {\r\nnd->nd_seq_wait[in] = 0;\r\nwake_up_interruptible(&nd->nd_seq_wque[in]);\r\n}\r\nif (b != buf) {\r\nnd->nd_tx_time = jiffies;\r\n} else if ((ulong)(jiffies - nd->nd_tx_time) >= IDLE_MAX) {\r\n*b++ = 0xf0 | nd->nd_tx_module;\r\nnd->nd_tx_time = jiffies;\r\n}\r\nn = b - buf;\r\nif (n >= tsafe)\r\npr_info("%s - n(%i) >= tsafe(%i)\n",\r\n__func__, n, tsafe);\r\nif (tsend < 0)\r\ndgrp_dump(buf, n);\r\nnd->nd_tx_work = work;\r\nreturn n;\r\n}\r\nstatic ssize_t dgrp_net_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct nd_struct *nd;\r\nlong n;\r\nu8 *local_buf;\r\nu8 *b;\r\nssize_t rtn;\r\nnd = (struct nd_struct *)(file->private_data);\r\nif (!nd)\r\nreturn -ENXIO;\r\nif (count < UIO_MIN)\r\nreturn -EINVAL;\r\ndown(&nd->nd_net_semaphore);\r\nnd->nd_read_count++;\r\nnd->nd_tx_ready = 0;\r\nif (nd->nd_remain > UIO_BASE)\r\npr_info_ratelimited("%s - nd_remain(%i) > UIO_BASE\n",\r\n__func__, nd->nd_remain);\r\nb = local_buf = nd->nd_iobuf + UIO_BASE;\r\nswitch (nd->nd_state) {\r\ncase NS_IDLE:\r\nif (nd->nd_mon_buf)\r\ndgrp_monitor_reset(nd);\r\nb[0] = 0xfb;\r\nb[1] = 0x01;\r\nb += 2;\r\nnd->nd_expect |= NR_IDENT;\r\nb[0] = 0xfb;\r\nb[1] = 0x02;\r\nb += 2;\r\nnd->nd_expect |= NR_CAPABILITY;\r\nb[0] = 0xfb;\r\nb[1] = 0x18;\r\nb += 2;\r\nnd->nd_expect |= NR_VPD;\r\nnd->nd_state = NS_WAIT_QUERY;\r\nbreak;\r\ncase NS_READY:\r\nb = dgrp_send(nd, count) + local_buf;\r\nbreak;\r\ncase NS_SEND_ERROR:\r\nn = strlen(nd->nd_error);\r\nb[0] = 0xff;\r\nb[1] = n;\r\nmemcpy(b + 2, nd->nd_error, n);\r\nb += 2 + n;\r\ndgrp_net_idle(nd);\r\ndgrp_chan_count(nd, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nn = b - local_buf;\r\nif (n != 0) {\r\nnd->nd_send_count++;\r\nnd->nd_tx_byte += n + nd->nd_link.lk_header_size;\r\nnd->nd_tx_charge += n + nd->nd_link.lk_header_size;\r\n}\r\nrtn = copy_to_user((void __user *)buf, local_buf, n);\r\nif (rtn) {\r\nrtn = -EFAULT;\r\ngoto done;\r\n}\r\n*ppos += n;\r\nrtn = n;\r\nif (nd->nd_mon_buf)\r\ndgrp_monitor_data(nd, RPDUMP_CLIENT, local_buf, n);\r\ndone:\r\nup(&nd->nd_net_semaphore);\r\nreturn rtn;\r\n}\r\nstatic void dgrp_receive(struct nd_struct *nd)\r\n{\r\nstruct ch_struct *ch;\r\nu8 *buf;\r\nu8 *b;\r\nu8 *dbuf;\r\nchar *error;\r\nlong port;\r\nlong dlen;\r\nlong plen;\r\nlong remain;\r\nlong n;\r\nlong mlast;\r\nlong elast;\r\nlong mstat;\r\nlong estat;\r\nchar ID[3];\r\nnd->nd_tx_time = jiffies;\r\nID_TO_CHAR(nd->nd_ID, ID);\r\nb = buf = nd->nd_iobuf;\r\nremain = nd->nd_remain;\r\nwhile (remain > 0) {\r\nint n0 = b[0] >> 4;\r\nint n1 = b[0] & 0x0f;\r\nif (n0 <= 12) {\r\nport = (nd->nd_rx_module << 4) + n1;\r\nif (port >= nd->nd_chan_count) {\r\nerror = "Improper Port Number";\r\ngoto prot_error;\r\n}\r\nch = nd->nd_chan + port;\r\n} else {\r\nport = -1;\r\nch = NULL;\r\n}\r\nswitch (n0) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\ndlen = n0 + 1;\r\nplen = dlen + 1;\r\ndbuf = b + 1;\r\ngoto data;\r\ncase 8:\r\nif (remain < 3)\r\ngoto done;\r\ndlen = b[1];\r\nplen = dlen + 2;\r\ndbuf = b + 2;\r\ngoto data;\r\ncase 9:\r\nif (remain < 4)\r\ngoto done;\r\ndlen = get_unaligned_be16(b + 1);\r\nplen = dlen + 3;\r\ndbuf = b + 3;\r\ndata:\r\nnd->nd_tx_work = 1;\r\nif (ch->ch_state < CS_READY) {\r\nerror = "Data received before RWIN established";\r\ngoto prot_error;\r\n}\r\nn = (ch->ch_s_rwin - ch->ch_s_rin) & 0xffff;\r\nif (dlen > n) {\r\nerror = "Receive data overrun";\r\ngoto prot_error;\r\n}\r\nif (ch->ch_edelay != DGRP_RTIME) {\r\nif (ch->ch_rtime != ch->ch_edelay) {\r\nch->ch_rtime = ch->ch_edelay;\r\nch->ch_flag |= CH_PARAM;\r\n}\r\n} else if (dlen <= 3) {\r\nif (ch->ch_rtime != 10) {\r\nch->ch_rtime = 10;\r\nch->ch_flag |= CH_PARAM;\r\n}\r\n} else {\r\nif (ch->ch_rtime != DGRP_RTIME) {\r\nch->ch_rtime = DGRP_RTIME;\r\nch->ch_flag |= CH_PARAM;\r\n}\r\n}\r\nif (remain < plen)\r\ndlen -= plen - remain;\r\nif ((ch->ch_flag & CH_RX_FLUSH) != 0 &&\r\n((ch->ch_flush_seq - nd->nd_seq_out) & SEQ_MASK) >=\r\n((nd->nd_seq_in - nd->nd_seq_out) & SEQ_MASK)) {\r\nch->ch_flag &= ~CH_RX_FLUSH;\r\n}\r\nch->ch_s_rin = (ch->ch_s_rin + dlen) & 0xffff;\r\nif (ch->ch_state == CS_READY &&\r\n(ch->ch_tun.un_open_count != 0) &&\r\n(ch->ch_tun.un_flag & UN_CLOSING) == 0 &&\r\n(ch->ch_cflag & CF_CREAD) != 0 &&\r\n(ch->ch_flag & (CH_BAUD0 | CH_RX_FLUSH)) == 0 &&\r\n(ch->ch_send & RR_RX_FLUSH) == 0) {\r\nif (ch->ch_rin + dlen >= RBUF_MAX) {\r\nn = RBUF_MAX - ch->ch_rin;\r\nmemcpy(ch->ch_rbuf + ch->ch_rin, dbuf, n);\r\nch->ch_rin = 0;\r\ndbuf += n;\r\ndlen -= n;\r\n}\r\nmemcpy(ch->ch_rbuf + ch->ch_rin, dbuf, dlen);\r\nch->ch_rin += dlen;\r\nif ((ch->ch_flag & CH_FAST_READ) == 0 ||\r\nch->ch_inwait != 0) {\r\ndgrp_input(ch);\r\n}\r\nif (waitqueue_active(&ch->ch_tun.un_tty->read_wait) &&\r\n(ch->ch_flag & CH_FAST_READ) != 0)\r\nwake_up_interruptible(&ch->ch_tun.un_tty->read_wait);\r\nif ((ch->ch_flag & CH_INPUT) != 0) {\r\nch->ch_flag &= ~CH_INPUT;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\n}\r\nif (remain < plen) {\r\ndlen = plen - remain;\r\nb = buf;\r\nb[0] = 0x90 + n1;\r\nput_unaligned_be16(dlen, b + 1);\r\nremain = 3;\r\ngoto done;\r\n}\r\nbreak;\r\ncase 10:\r\nplen = 3;\r\nif (remain < plen)\r\ngoto done;\r\nnd->nd_tx_work = 1;\r\n{\r\nushort tpos = get_unaligned_be16(b + 1);\r\nushort ack = (tpos - ch->ch_s_tpos) & 0xffff;\r\nushort unack = (ch->ch_s_tin - ch->ch_s_tpos) & 0xffff;\r\nushort notify = (ch->ch_s_treq - ch->ch_s_tpos) & 0xffff;\r\nif (ch->ch_state < CS_READY || ack > unack) {\r\nerror = "Improper Window Sequence";\r\ngoto prot_error;\r\n}\r\nch->ch_s_tpos = tpos;\r\nif (notify <= ack)\r\nch->ch_s_treq = tpos;\r\n}\r\nbreak;\r\ncase 11:\r\nif (remain < 2)\r\ngoto done;\r\nswitch (b[1]) {\r\ncase 11:\r\nplen = 6;\r\nif (remain < plen)\r\ngoto done;\r\nnd->nd_tx_work = 1;\r\n{\r\nint req = b[2];\r\nint resp = b[3];\r\nport = get_unaligned_be16(b + 4);\r\nif (port >= nd->nd_chan_count) {\r\nerror = "Open channel number out of range";\r\ngoto prot_error;\r\n}\r\nch = nd->nd_chan + port;\r\nswitch (ch->ch_state) {\r\ncase CS_IDLE:\r\nif (ch->ch_otype_waiting != 0 &&\r\nreq == ch->ch_otype_waiting &&\r\nresp == 0) {\r\nch->ch_otype = req;\r\nch->ch_otype_waiting = 0;\r\nch->ch_state = CS_SEND_QUERY;\r\nbreak;\r\n}\r\ngoto open_error;\r\ncase CS_WAIT_OPEN:\r\nif (req == ch->ch_otype) {\r\nswitch (resp) {\r\ncase 0:\r\nch->ch_state = CS_SEND_QUERY;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nif (req != OTYPE_IMMEDIATE) {\r\nch->ch_otype_waiting = req;\r\nch->ch_state = CS_IDLE;\r\nbreak;\r\n}\r\ndefault:\r\nif (ch->ch_open_count != 0) {\r\nch->ch_flag |= CH_HANGUP;\r\ndgrp_carrier(ch);\r\nch->ch_state = CS_IDLE;\r\nbreak;\r\n}\r\nch->ch_open_error = resp;\r\nch->ch_state = CS_IDLE;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\nbreak;\r\n}\r\nif (ch->ch_otype_waiting != 0 &&\r\nreq == ch->ch_otype_waiting &&\r\nresp == 0) {\r\nch->ch_otype = ch->ch_otype_waiting;\r\nch->ch_otype_waiting = 0;\r\nch->ch_state = CS_WAIT_FAIL;\r\nbreak;\r\n}\r\ngoto open_error;\r\ncase CS_WAIT_FAIL:\r\nif (req == OTYPE_IMMEDIATE) {\r\nch->ch_state = CS_SEND_QUERY;\r\nbreak;\r\n}\r\ngoto open_error;\r\ncase CS_WAIT_CANCEL:\r\nif (req == ch->ch_otype_waiting &&\r\nresp == 0) {\r\nch->ch_otype_waiting = 0;\r\nbreak;\r\n}\r\nif (req == 4 && resp == 0) {\r\nch->ch_otype_waiting = 0;\r\nch->ch_state = CS_IDLE;\r\nbreak;\r\n}\r\ngoto open_error;\r\ncase CS_WAIT_CLOSE:\r\nif (req >= 3) {\r\nch->ch_state = CS_IDLE;\r\nbreak;\r\n}\r\ngoto open_error;\r\nopen_error:\r\ndefault:\r\n{\r\nerror = "Improper Open Response";\r\ngoto prot_error;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase 13:\r\nplen = 3;\r\nif (remain < plen)\r\ngoto done;\r\n{\r\nint seq = b[2];\r\nint s;\r\nif (ch->ch_flag & CH_WAITING_SYNC) {\r\nch->ch_flag &= ~(CH_WAITING_SYNC);\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\nif (((seq - nd->nd_seq_out) & SEQ_MASK) >=\r\n((nd->nd_seq_in - nd->nd_seq_out) & SEQ_MASK)) {\r\nbreak;\r\n}\r\nfor (s = nd->nd_seq_out;; s = (s + 1) & SEQ_MASK) {\r\nif (nd->nd_seq_wait[s] != 0) {\r\nnd->nd_seq_wait[s] = 0;\r\nwake_up_interruptible(&nd->nd_seq_wque[s]);\r\n}\r\nnd->nd_unack -= nd->nd_seq_size[s];\r\nif (s == seq)\r\nbreak;\r\n}\r\nnd->nd_seq_out = (seq + 1) & SEQ_MASK;\r\n}\r\nbreak;\r\ncase 15:\r\nplen = 6;\r\nif (remain < plen)\r\ngoto done;\r\n{\r\nch->ch_send &= ~RR_SEQUENCE;\r\nch->ch_expect &= ~RR_SEQUENCE;\r\n}\r\ngoto check_query;\r\ncase 17:\r\nplen = 5;\r\nif (remain < plen)\r\ngoto done;\r\n{\r\nch->ch_s_elast = get_unaligned_be16(b + 2);\r\nch->ch_s_mlast = b[4];\r\nch->ch_expect &= ~RR_STATUS;\r\nch->ch_send &= ~RR_STATUS;\r\nch->ch_flag &= ~CH_PHYS_CD;\r\ndgrp_carrier(ch);\r\n}\r\ngoto check_query;\r\ncase 19:\r\nplen = 14;\r\nif (remain < plen)\r\ngoto done;\r\nbreak;\r\ncase 21:\r\nplen = 6;\r\nif (remain < plen)\r\ngoto done;\r\n{\r\nch->ch_s_rsize = get_unaligned_be16(b + 2);\r\nch->ch_s_tsize = get_unaligned_be16(b + 4);\r\nch->ch_send &= ~RR_BUFFER;\r\nch->ch_expect &= ~RR_BUFFER;\r\n}\r\ngoto check_query;\r\ncase 23:\r\nplen = 32;\r\nif (remain < plen)\r\ngoto done;\r\n{\r\nch->ch_send &= ~RR_CAPABILITY;\r\nch->ch_expect &= ~RR_CAPABILITY;\r\n}\r\ncheck_query:\r\nif (ch->ch_state == CS_WAIT_QUERY &&\r\n(ch->ch_expect & (RR_SEQUENCE |\r\nRR_STATUS |\r\nRR_BUFFER |\r\nRR_CAPABILITY)) == 0) {\r\nch->ch_tmax = ch->ch_s_tsize / 4;\r\nif (ch->ch_edelay == DGRP_TTIME)\r\nch->ch_ttime = DGRP_TTIME;\r\nelse\r\nch->ch_ttime = ch->ch_edelay;\r\nch->ch_rmax = ch->ch_s_rsize / 4;\r\nif (ch->ch_edelay == DGRP_RTIME)\r\nch->ch_rtime = DGRP_RTIME;\r\nelse\r\nch->ch_rtime = ch->ch_edelay;\r\nch->ch_rlow = 2 * ch->ch_s_rsize / 8;\r\nch->ch_rhigh = 6 * ch->ch_s_rsize / 8;\r\nch->ch_state = CS_READY;\r\nnd->nd_tx_work = 1;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\nbreak;\r\ndefault:\r\ngoto decode_error;\r\n}\r\nbreak;\r\ncase 12:\r\nplen = 4;\r\nif (remain < plen)\r\ngoto done;\r\nmlast = ch->ch_s_mlast;\r\nelast = ch->ch_s_elast;\r\nmstat = ch->ch_s_mlast = b[1];\r\nestat = ch->ch_s_elast = get_unaligned_be16(b + 2);\r\nif (((mstat ^ mlast) & DM_CD) != 0)\r\ndgrp_carrier(ch);\r\nif ((estat & ~elast & EV_RXB) != 0 &&\r\n(ch->ch_tun.un_open_count != 0) &&\r\nI_BRKINT(ch->ch_tun.un_tty) &&\r\n!(I_IGNBRK(ch->ch_tun.un_tty))) {\r\ntty_buffer_request_room(&ch->port, 1);\r\ntty_insert_flip_char(&ch->port, 0, TTY_BREAK);\r\ntty_flip_buffer_push(&ch->port);\r\n}\r\nif ((~estat & elast & EV_TXB) != 0 &&\r\n(ch->ch_expect & RR_TX_BREAK) != 0) {\r\nnd->nd_tx_work = 1;\r\nch->ch_expect &= ~RR_TX_BREAK;\r\nif (ch->ch_break_time != 0) {\r\nch->ch_send |= RR_TX_BREAK;\r\n} else {\r\nch->ch_send &= ~RR_TX_BREAK;\r\nch->ch_flag &= ~CH_TX_BREAK;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\n}\r\nbreak;\r\ncase 13:\r\ncase 14:\r\nerror = "Unrecognized command";\r\ngoto prot_error;\r\ncase 15:\r\nswitch (n1) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\nplen = 1;\r\nnd->nd_rx_module = n1;\r\nbreak;\r\ncase 8:\r\nplen = 2;\r\nif (remain < plen)\r\ngoto done;\r\nnd->nd_rx_module = b[1];\r\nbreak;\r\ncase 11:\r\nif (remain < 4)\r\ngoto done;\r\nplen = get_unaligned_be16(b + 2);\r\nif (plen < 12 || plen > 1000) {\r\nerror = "Response Packet length error";\r\ngoto prot_error;\r\n}\r\nnd->nd_tx_work = 1;\r\nswitch (b[1]) {\r\ncase 0:\r\nnd->nd_send |= NR_ECHO;\r\nbreak;\r\ncase 1:\r\nnd->nd_send |= NR_IDENT;\r\nbreak;\r\ncase 32:\r\nnd->nd_send |= NR_PASSWORD;\r\nbreak;\r\n}\r\nbreak;\r\ncase 12:\r\nif (remain < 4)\r\ngoto done;\r\nplen = get_unaligned_be16(b + 2);\r\nif (plen < 4 || plen > 1000) {\r\nerror = "Response Packet length error";\r\ngoto prot_error;\r\n}\r\nnd->nd_tx_work = 1;\r\nswitch (b[1]) {\r\ncase 0:\r\nnd->nd_expect &= ~NR_ECHO;\r\nbreak;\r\ncase 1:\r\n{\r\nint desclen;\r\nnd->nd_hw_ver = (b[8] << 8) | b[9];\r\nnd->nd_sw_ver = (b[10] << 8) | b[11];\r\nnd->nd_hw_id = b[6];\r\ndesclen = (plen - 12 > MAX_DESC_LEN - 1) ? MAX_DESC_LEN - 1 :\r\nplen - 12;\r\nif (desclen <= 0) {\r\nerror = "Response Packet desclen error";\r\ngoto prot_error;\r\n}\r\nstrncpy(nd->nd_ps_desc, b + 12, desclen);\r\nnd->nd_ps_desc[desclen] = 0;\r\n}\r\nnd->nd_expect &= ~NR_IDENT;\r\nbreak;\r\ncase 2:\r\n{\r\nint nn = get_unaligned_be16(b + 4);\r\nif (nn > CHAN_MAX)\r\nnn = CHAN_MAX;\r\ndgrp_chan_count(nd, nn);\r\n}\r\nnd->nd_expect &= ~NR_CAPABILITY;\r\nbreak;\r\ncase 15:\r\ncase 24:\r\nif (plen > 4) {\r\nmemcpy(nd->nd_vpd, b + 4, min(plen - 4, (long) VPDSIZE));\r\nnd->nd_vpd_len = min(plen - 4, (long) VPDSIZE);\r\n}\r\nnd->nd_expect &= ~NR_VPD;\r\nbreak;\r\ndefault:\r\ngoto decode_error;\r\n}\r\nif (nd->nd_expect == 0 &&\r\nnd->nd_state == NS_WAIT_QUERY) {\r\nnd->nd_state = NS_READY;\r\n}\r\nbreak;\r\ncase 14:\r\nif (remain < 4)\r\ngoto done;\r\nplen = get_unaligned_be16(b + 2) + 4;\r\nif (plen > 1000) {\r\nerror = "Debug Packet too large";\r\ngoto prot_error;\r\n}\r\nif (remain < plen)\r\ngoto done;\r\nbreak;\r\ncase 15:\r\nif (remain < 2)\r\ngoto done;\r\nplen = 2 + b[1];\r\nif (remain < plen)\r\ngoto done;\r\nnd->nd_tx_work = 1;\r\nn = b[plen];\r\nb[plen] = 0;\r\nb[plen] = n;\r\nerror = "Client Reset Acknowledge";\r\ngoto prot_error;\r\ndefault:\r\ngoto decode_error;\r\n}\r\nbreak;\r\ndefault:\r\ngoto decode_error;\r\n}\r\nb += plen;\r\nremain -= plen;\r\n}\r\ndone:\r\nif (remain > 0 && b != buf)\r\nmemcpy(buf, b, remain);\r\nnd->nd_remain = remain;\r\nreturn;\r\ndecode_error:\r\nerror = "Protocol decode error";\r\nprot_error:\r\nnd->nd_remain = 0;\r\nnd->nd_state = NS_SEND_ERROR;\r\nnd->nd_error = error;\r\n}\r\nstatic ssize_t dgrp_net_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct nd_struct *nd;\r\nssize_t rtn = 0;\r\nlong n;\r\nlong total = 0;\r\nnd = (struct nd_struct *)(file->private_data);\r\nif (!nd)\r\nreturn -ENXIO;\r\ndown(&nd->nd_net_semaphore);\r\nnd->nd_write_count++;\r\nif (count == 0) {\r\ndgrp_net_idle(nd);\r\ndgrp_chan_count(nd, 0);\r\ngoto unlock;\r\n}\r\nwhile (count > 0) {\r\nn = UIO_MAX - nd->nd_remain;\r\nif (n > count)\r\nn = count;\r\nnd->nd_rx_byte += n + nd->nd_link.lk_header_size;\r\nrtn = copy_from_user(nd->nd_iobuf + nd->nd_remain,\r\n(void __user *) buf + total, n);\r\nif (rtn) {\r\nrtn = -EFAULT;\r\ngoto unlock;\r\n}\r\n*ppos += n;\r\ntotal += n;\r\ncount -= n;\r\nif (nd->nd_mon_buf)\r\ndgrp_monitor_data(nd, RPDUMP_SERVER,\r\nnd->nd_iobuf + nd->nd_remain, n);\r\nnd->nd_remain += n;\r\ndgrp_receive(nd);\r\n}\r\nrtn = total;\r\nunlock:\r\nup(&nd->nd_net_semaphore);\r\nreturn rtn;\r\n}\r\nstatic unsigned int dgrp_net_select(struct file *file,\r\nstruct poll_table_struct *table)\r\n{\r\nunsigned int retval = 0;\r\nstruct nd_struct *nd = file->private_data;\r\npoll_wait(file, &nd->nd_tx_waitq, table);\r\nif (nd->nd_tx_ready)\r\nretval |= POLLIN | POLLRDNORM;\r\nretval |= POLLOUT | POLLWRNORM;\r\nreturn retval;\r\n}\r\nstatic long dgrp_net_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct nd_struct *nd;\r\nint rtn = 0;\r\nlong size = _IOC_SIZE(cmd);\r\nstruct link_struct link;\r\nnd = file->private_data;\r\nif (_IOC_DIR(cmd) & _IOC_READ)\r\nrtn = access_ok(VERIFY_WRITE, (void __user *) arg, size);\r\nelse if (_IOC_DIR(cmd) & _IOC_WRITE)\r\nrtn = access_ok(VERIFY_READ, (void __user *) arg, size);\r\nif (!rtn)\r\nreturn rtn;\r\nswitch (cmd) {\r\ncase DIGI_SETLINK:\r\nif (size != sizeof(struct link_struct))\r\nreturn -EINVAL;\r\nif (copy_from_user(&link, (void __user *)arg, size))\r\nreturn -EFAULT;\r\nif (link.lk_fast_rate < 9600)\r\nlink.lk_fast_rate = 9600;\r\nif (link.lk_slow_rate < 2400)\r\nlink.lk_slow_rate = 2400;\r\nif (link.lk_fast_rate > 10000000)\r\nlink.lk_fast_rate = 10000000;\r\nif (link.lk_slow_rate > link.lk_fast_rate)\r\nlink.lk_slow_rate = link.lk_fast_rate;\r\nif (link.lk_fast_delay > 2000)\r\nlink.lk_fast_delay = 2000;\r\nif (link.lk_slow_delay > 10000)\r\nlink.lk_slow_delay = 10000;\r\nif (link.lk_fast_delay < 60)\r\nlink.lk_fast_delay = 60;\r\nif (link.lk_slow_delay < link.lk_fast_delay)\r\nlink.lk_slow_delay = link.lk_fast_delay;\r\nif (link.lk_header_size < 2)\r\nlink.lk_header_size = 2;\r\nif (link.lk_header_size > 128)\r\nlink.lk_header_size = 128;\r\nlink.lk_fast_rate /= 8 * 1000 / dgrp_poll_tick;\r\nlink.lk_slow_rate /= 8 * 1000 / dgrp_poll_tick;\r\nlink.lk_fast_delay /= dgrp_poll_tick;\r\nlink.lk_slow_delay /= dgrp_poll_tick;\r\nnd->nd_link = link;\r\nbreak;\r\ncase DIGI_GETLINK:\r\nif (size != sizeof(struct link_struct))\r\nreturn -EINVAL;\r\nif (copy_to_user((void __user *)arg, (void *)(&nd->nd_link),\r\nsize))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid dgrp_poll_handler(unsigned long arg)\r\n{\r\nstruct dgrp_poll_data *poll_data;\r\nstruct nd_struct *nd;\r\nstruct link_struct *lk;\r\nulong time;\r\nulong poll_time;\r\nulong freq;\r\nulong lock_flags;\r\npoll_data = (struct dgrp_poll_data *) arg;\r\nfreq = 1000 / poll_data->poll_tick;\r\npoll_data->poll_round += 17;\r\nif (poll_data->poll_round >= freq)\r\npoll_data->poll_round -= freq;\r\nlist_for_each_entry(nd, &nd_struct_list, list) {\r\nlk = &nd->nd_link;\r\nnd->nd_read_count -= (nd->nd_read_count +\r\npoll_data->poll_round) / freq;\r\nnd->nd_write_count -= (nd->nd_write_count +\r\npoll_data->poll_round) / freq;\r\nnd->nd_send_count -= (nd->nd_send_count +\r\npoll_data->poll_round) / freq;\r\nnd->nd_tx_byte -= (nd->nd_tx_byte +\r\npoll_data->poll_round) / freq;\r\nnd->nd_rx_byte -= (nd->nd_rx_byte +\r\npoll_data->poll_round) / freq;\r\nif (lk->lk_slow_rate >= UIO_MAX) {\r\nnd->nd_delay = 0;\r\nnd->nd_rate = UIO_MAX;\r\nnd->nd_tx_deposit = nd->nd_tx_charge + 3 * UIO_MAX;\r\nnd->nd_tx_credit = 3 * UIO_MAX;\r\n} else {\r\nlong rate;\r\nlong delay;\r\nlong deposit;\r\nlong charge;\r\nlong size;\r\nlong excess;\r\nlong seq_in = nd->nd_seq_in;\r\nlong seq_out = nd->nd_seq_out;\r\nif (seq_in == seq_out) {\r\ndelay = 0;\r\nrate = lk->lk_fast_rate;\r\n}\r\nelse {\r\ndelay = ((jiffies - nd->nd_seq_time[seq_out])\r\n- (nd->nd_seq_size[seq_out] /\r\nlk->lk_fast_rate));\r\nrate =\r\n(delay <= lk->lk_fast_delay ?\r\nlk->lk_fast_rate :\r\ndelay >= lk->lk_slow_delay ?\r\nlk->lk_slow_rate :\r\n(lk->lk_slow_rate +\r\n(lk->lk_slow_delay - delay) *\r\n(lk->lk_fast_rate - lk->lk_slow_rate) /\r\n(lk->lk_slow_delay - lk->lk_fast_delay)\r\n)\r\n);\r\n}\r\nnd->nd_delay = delay;\r\nnd->nd_rate = rate;\r\ndeposit = nd->nd_tx_deposit;\r\ncharge = nd->nd_tx_charge;\r\ndeposit += rate;\r\nsize = 2 * nd->nd_link.lk_header_size;\r\nif (size < rate)\r\nsize = rate;\r\nsize *= 3;\r\nexcess = deposit - charge - size;\r\nif (excess > 0)\r\ndeposit -= excess;\r\nnd->nd_tx_deposit = deposit;\r\nnd->nd_tx_credit = deposit - charge;\r\nsize = 3 * lk->lk_header_size;\r\nif (nd->nd_tx_credit < size)\r\ncontinue;\r\n}\r\nif (waitqueue_active(&nd->nd_tx_waitq) &&\r\n(nd->nd_tx_work != 0 ||\r\n(ulong)(jiffies - nd->nd_tx_time) >= IDLE_MAX)) {\r\nnd->nd_tx_ready = 1;\r\nwake_up_interruptible(&nd->nd_tx_waitq);\r\n}\r\n}\r\nspin_lock_irqsave(&poll_data->poll_lock, lock_flags);\r\npoll_data->node_active_count--;\r\nif (poll_data->node_active_count > 0) {\r\npoll_data->node_active_count++;\r\npoll_time = poll_data->timer.expires +\r\npoll_data->poll_tick * HZ / 1000;\r\ntime = poll_time - jiffies;\r\nif (time >= 2 * poll_data->poll_tick)\r\npoll_time = jiffies + dgrp_poll_tick * HZ / 1000;\r\npoll_data->timer.expires = poll_time;\r\nadd_timer(&poll_data->timer);\r\n}\r\nspin_unlock_irqrestore(&poll_data->poll_lock, lock_flags);\r\n}
