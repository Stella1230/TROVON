static void hci_h4p_set_clk(struct hci_h4p_info *info, int *clock, int enable)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->clocks_lock, flags);\r\nif (enable && !*clock) {\r\nBT_DBG("Enabling %p", clock);\r\nclk_prepare_enable(info->uart_fclk);\r\nclk_prepare_enable(info->uart_iclk);\r\nif (atomic_read(&info->clk_users) == 0)\r\nhci_h4p_restore_regs(info);\r\natomic_inc(&info->clk_users);\r\n}\r\nif (!enable && *clock) {\r\nBT_DBG("Disabling %p", clock);\r\nif (atomic_dec_and_test(&info->clk_users))\r\nhci_h4p_store_regs(info);\r\nclk_disable_unprepare(info->uart_fclk);\r\nclk_disable_unprepare(info->uart_iclk);\r\n}\r\n*clock = enable;\r\nspin_unlock_irqrestore(&info->clocks_lock, flags);\r\n}\r\nstatic void hci_h4p_lazy_clock_release(unsigned long data)\r\n{\r\nstruct hci_h4p_info *info = (struct hci_h4p_info *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (!info->tx_enabled)\r\nhci_h4p_set_clk(info, &info->tx_clocks_en, 0);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nvoid hci_h4p_smart_idle(struct hci_h4p_info *info, bool enable)\r\n{\r\nu8 v;\r\nv = hci_h4p_inb(info, UART_OMAP_SYSC);\r\nv &= ~(UART_OMAP_SYSC_IDLEMASK);\r\nif (enable)\r\nv |= UART_OMAP_SYSC_SMART_IDLE;\r\nelse\r\nv |= UART_OMAP_SYSC_NO_IDLE;\r\nhci_h4p_outb(info, UART_OMAP_SYSC, v);\r\n}\r\nstatic inline void h4p_schedule_pm(struct hci_h4p_info *info)\r\n{\r\n}\r\nstatic void hci_h4p_disable_tx(struct hci_h4p_info *info)\r\n{\r\nif (!info->pm_enabled)\r\nreturn;\r\nhci_h4p_smart_idle(info, 1);\r\ngpio_set_value(info->bt_wakeup_gpio, 0);\r\nmod_timer(&info->lazy_release, jiffies + msecs_to_jiffies(100));\r\ninfo->tx_enabled = 0;\r\n}\r\nvoid hci_h4p_enable_tx(struct hci_h4p_info *info)\r\n{\r\nunsigned long flags;\r\nif (!info->pm_enabled)\r\nreturn;\r\nh4p_schedule_pm(info);\r\nspin_lock_irqsave(&info->lock, flags);\r\ndel_timer(&info->lazy_release);\r\nhci_h4p_set_clk(info, &info->tx_clocks_en, 1);\r\ninfo->tx_enabled = 1;\r\ngpio_set_value(info->bt_wakeup_gpio, 1);\r\nhci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |\r\nUART_IER_THRI);\r\nhci_h4p_smart_idle(info, 0);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nstatic void hci_h4p_disable_rx(struct hci_h4p_info *info)\r\n{\r\nif (!info->pm_enabled)\r\nreturn;\r\ninfo->rx_enabled = 0;\r\nif (hci_h4p_inb(info, UART_LSR) & UART_LSR_DR)\r\nreturn;\r\nif (!(hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT))\r\nreturn;\r\n__hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_RTS);\r\ninfo->autorts = 0;\r\nhci_h4p_set_clk(info, &info->rx_clocks_en, 0);\r\n}\r\nstatic void hci_h4p_enable_rx(struct hci_h4p_info *info)\r\n{\r\nif (!info->pm_enabled)\r\nreturn;\r\nh4p_schedule_pm(info);\r\nhci_h4p_set_clk(info, &info->rx_clocks_en, 1);\r\ninfo->rx_enabled = 1;\r\nif (!(hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT))\r\nreturn;\r\n__hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_RTS);\r\ninfo->autorts = 1;\r\n}\r\nint hci_h4p_send_alive_packet(struct hci_h4p_info *info)\r\n{\r\nstruct hci_h4p_alive_hdr *hdr;\r\nstruct hci_h4p_alive_pkt *pkt;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nint len;\r\nBT_DBG("Sending alive packet");\r\nlen = H4_TYPE_SIZE + sizeof(*hdr) + sizeof(*pkt);\r\nskb = bt_skb_alloc(len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nmemset(skb->data, 0x00, len);\r\n*skb_put(skb, 1) = H4_ALIVE_PKT;\r\nhdr = (struct hci_h4p_alive_hdr *)skb_put(skb, sizeof(*hdr));\r\nhdr->dlen = sizeof(*pkt);\r\npkt = (struct hci_h4p_alive_pkt *)skb_put(skb, sizeof(*pkt));\r\npkt->mid = H4P_ALIVE_REQ;\r\nskb_queue_tail(&info->txq, skb);\r\nspin_lock_irqsave(&info->lock, flags);\r\nhci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |\r\nUART_IER_THRI);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nBT_DBG("Alive packet sent");\r\nreturn 0;\r\n}\r\nstatic void hci_h4p_alive_packet(struct hci_h4p_info *info,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_h4p_alive_hdr *hdr;\r\nstruct hci_h4p_alive_pkt *pkt;\r\nBT_DBG("Received alive packet");\r\nhdr = (struct hci_h4p_alive_hdr *)skb->data;\r\nif (hdr->dlen != sizeof(*pkt)) {\r\ndev_err(info->dev, "Corrupted alive message\n");\r\ninfo->init_error = -EIO;\r\ngoto finish_alive;\r\n}\r\npkt = (struct hci_h4p_alive_pkt *)skb_pull(skb, sizeof(*hdr));\r\nif (pkt->mid != H4P_ALIVE_RESP) {\r\ndev_err(info->dev, "Could not negotiate hci_h4p settings\n");\r\ninfo->init_error = -EINVAL;\r\n}\r\nfinish_alive:\r\ncomplete(&info->init_completion);\r\nkfree_skb(skb);\r\n}\r\nstatic int hci_h4p_send_negotiation(struct hci_h4p_info *info)\r\n{\r\nstruct hci_h4p_neg_cmd *neg_cmd;\r\nstruct hci_h4p_neg_hdr *neg_hdr;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nint err, len;\r\nu16 sysclk;\r\nBT_DBG("Sending negotiation..");\r\nswitch (info->bt_sysclk) {\r\ncase 1:\r\nsysclk = 12000;\r\nbreak;\r\ncase 2:\r\nsysclk = 38400;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nlen = sizeof(*neg_cmd) + sizeof(*neg_hdr) + H4_TYPE_SIZE;\r\nskb = bt_skb_alloc(len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nmemset(skb->data, 0x00, len);\r\n*skb_put(skb, 1) = H4_NEG_PKT;\r\nneg_hdr = (struct hci_h4p_neg_hdr *)skb_put(skb, sizeof(*neg_hdr));\r\nneg_cmd = (struct hci_h4p_neg_cmd *)skb_put(skb, sizeof(*neg_cmd));\r\nneg_hdr->dlen = sizeof(*neg_cmd);\r\nneg_cmd->ack = H4P_NEG_REQ;\r\nneg_cmd->baud = cpu_to_le16(BT_BAUDRATE_DIVIDER/MAX_BAUD_RATE);\r\nneg_cmd->proto = H4P_PROTO_BYTE;\r\nneg_cmd->sys_clk = cpu_to_le16(sysclk);\r\nhci_h4p_change_speed(info, INIT_SPEED);\r\nhci_h4p_set_rts(info, 1);\r\ninfo->init_error = 0;\r\ninit_completion(&info->init_completion);\r\nskb_queue_tail(&info->txq, skb);\r\nspin_lock_irqsave(&info->lock, flags);\r\nhci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |\r\nUART_IER_THRI);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nif (!wait_for_completion_interruptible_timeout(&info->init_completion,\r\nmsecs_to_jiffies(1000)))\r\nreturn -ETIMEDOUT;\r\nif (info->init_error < 0)\r\nreturn info->init_error;\r\nhci_h4p_set_auto_ctsrts(info, 0, UART_EFR_RTS);\r\nhci_h4p_set_rts(info, 0);\r\nhci_h4p_change_speed(info, MAX_BAUD_RATE);\r\nerr = hci_h4p_wait_for_cts(info, 1, 100);\r\nif (err < 0)\r\nreturn err;\r\nhci_h4p_set_auto_ctsrts(info, 1, UART_EFR_RTS);\r\ninit_completion(&info->init_completion);\r\nerr = hci_h4p_send_alive_packet(info);\r\nif (err < 0)\r\nreturn err;\r\nif (!wait_for_completion_interruptible_timeout(&info->init_completion,\r\nmsecs_to_jiffies(1000)))\r\nreturn -ETIMEDOUT;\r\nif (info->init_error < 0)\r\nreturn info->init_error;\r\nBT_DBG("Negotiation successful");\r\nreturn 0;\r\n}\r\nstatic void hci_h4p_negotiation_packet(struct hci_h4p_info *info,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_h4p_neg_hdr *hdr;\r\nstruct hci_h4p_neg_evt *evt;\r\nhdr = (struct hci_h4p_neg_hdr *)skb->data;\r\nif (hdr->dlen != sizeof(*evt)) {\r\ninfo->init_error = -EIO;\r\ngoto finish_neg;\r\n}\r\nevt = (struct hci_h4p_neg_evt *)skb_pull(skb, sizeof(*hdr));\r\nif (evt->ack != H4P_NEG_ACK) {\r\ndev_err(info->dev, "Could not negotiate hci_h4p settings\n");\r\ninfo->init_error = -EINVAL;\r\n}\r\ninfo->man_id = evt->man_id;\r\ninfo->ver_id = evt->ver_id;\r\nfinish_neg:\r\ncomplete(&info->init_completion);\r\nkfree_skb(skb);\r\n}\r\nstatic int hci_h4p_get_hdr_len(struct hci_h4p_info *info, u8 pkt_type)\r\n{\r\nlong retval;\r\nswitch (pkt_type) {\r\ncase H4_EVT_PKT:\r\nretval = HCI_EVENT_HDR_SIZE;\r\nbreak;\r\ncase H4_ACL_PKT:\r\nretval = HCI_ACL_HDR_SIZE;\r\nbreak;\r\ncase H4_SCO_PKT:\r\nretval = HCI_SCO_HDR_SIZE;\r\nbreak;\r\ncase H4_NEG_PKT:\r\nretval = H4P_NEG_HDR_SIZE;\r\nbreak;\r\ncase H4_ALIVE_PKT:\r\nretval = H4P_ALIVE_HDR_SIZE;\r\nbreak;\r\ncase H4_RADIO_PKT:\r\nretval = H4_RADIO_HDR_SIZE;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "Unknown H4 packet type 0x%.2x\n", pkt_type);\r\nretval = -1;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic unsigned int hci_h4p_get_data_len(struct hci_h4p_info *info,\r\nstruct sk_buff *skb)\r\n{\r\nlong retval = -1;\r\nstruct hci_acl_hdr *acl_hdr;\r\nstruct hci_sco_hdr *sco_hdr;\r\nstruct hci_event_hdr *evt_hdr;\r\nstruct hci_h4p_neg_hdr *neg_hdr;\r\nstruct hci_h4p_alive_hdr *alive_hdr;\r\nstruct hci_h4p_radio_hdr *radio_hdr;\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase H4_EVT_PKT:\r\nevt_hdr = (struct hci_event_hdr *)skb->data;\r\nretval = evt_hdr->plen;\r\nbreak;\r\ncase H4_ACL_PKT:\r\nacl_hdr = (struct hci_acl_hdr *)skb->data;\r\nretval = le16_to_cpu(acl_hdr->dlen);\r\nbreak;\r\ncase H4_SCO_PKT:\r\nsco_hdr = (struct hci_sco_hdr *)skb->data;\r\nretval = sco_hdr->dlen;\r\nbreak;\r\ncase H4_RADIO_PKT:\r\nradio_hdr = (struct hci_h4p_radio_hdr *)skb->data;\r\nretval = radio_hdr->dlen;\r\nbreak;\r\ncase H4_NEG_PKT:\r\nneg_hdr = (struct hci_h4p_neg_hdr *)skb->data;\r\nretval = neg_hdr->dlen;\r\nbreak;\r\ncase H4_ALIVE_PKT:\r\nalive_hdr = (struct hci_h4p_alive_hdr *)skb->data;\r\nretval = alive_hdr->dlen;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic inline void hci_h4p_recv_frame(struct hci_h4p_info *info,\r\nstruct sk_buff *skb)\r\n{\r\nif (unlikely(!test_bit(HCI_RUNNING, &info->hdev->flags))) {\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase H4_NEG_PKT:\r\nhci_h4p_negotiation_packet(info, skb);\r\ninfo->rx_state = WAIT_FOR_PKT_TYPE;\r\nreturn;\r\ncase H4_ALIVE_PKT:\r\nhci_h4p_alive_packet(info, skb);\r\ninfo->rx_state = WAIT_FOR_PKT_TYPE;\r\nreturn;\r\n}\r\nif (!test_bit(HCI_UP, &info->hdev->flags)) {\r\nBT_DBG("fw_event");\r\nhci_h4p_parse_fw_event(info, skb);\r\nreturn;\r\n}\r\n}\r\nhci_recv_frame(info->hdev, skb);\r\nBT_DBG("Frame sent to upper layer");\r\n}\r\nstatic inline void hci_h4p_handle_byte(struct hci_h4p_info *info, u8 byte)\r\n{\r\nswitch (info->rx_state) {\r\ncase WAIT_FOR_PKT_TYPE:\r\nbt_cb(info->rx_skb)->pkt_type = byte;\r\ninfo->rx_count = hci_h4p_get_hdr_len(info, byte);\r\nif (info->rx_count < 0) {\r\ninfo->hdev->stat.err_rx++;\r\nkfree_skb(info->rx_skb);\r\ninfo->rx_skb = NULL;\r\n} else {\r\ninfo->rx_state = WAIT_FOR_HEADER;\r\n}\r\nbreak;\r\ncase WAIT_FOR_HEADER:\r\ninfo->rx_count--;\r\n*skb_put(info->rx_skb, 1) = byte;\r\nif (info->rx_count != 0)\r\nbreak;\r\ninfo->rx_count = hci_h4p_get_data_len(info, info->rx_skb);\r\nif (info->rx_count > skb_tailroom(info->rx_skb)) {\r\ndev_err(info->dev, "frame too long\n");\r\ninfo->garbage_bytes = info->rx_count\r\n- skb_tailroom(info->rx_skb);\r\nkfree_skb(info->rx_skb);\r\ninfo->rx_skb = NULL;\r\nbreak;\r\n}\r\ninfo->rx_state = WAIT_FOR_DATA;\r\nbreak;\r\ncase WAIT_FOR_DATA:\r\ninfo->rx_count--;\r\n*skb_put(info->rx_skb, 1) = byte;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nif (info->rx_count == 0) {\r\nif (!(info->rx_skb->len % 2))\r\ninfo->garbage_bytes++;\r\nhci_h4p_recv_frame(info, info->rx_skb);\r\ninfo->rx_skb = NULL;\r\n}\r\n}\r\nstatic void hci_h4p_rx_tasklet(unsigned long data)\r\n{\r\nu8 byte;\r\nstruct hci_h4p_info *info = (struct hci_h4p_info *)data;\r\nBT_DBG("tasklet woke up");\r\nBT_DBG("rx_tasklet woke up");\r\nwhile (hci_h4p_inb(info, UART_LSR) & UART_LSR_DR) {\r\nbyte = hci_h4p_inb(info, UART_RX);\r\nif (info->garbage_bytes) {\r\ninfo->garbage_bytes--;\r\ncontinue;\r\n}\r\nif (info->rx_skb == NULL) {\r\ninfo->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE,\r\nGFP_ATOMIC | GFP_DMA);\r\nif (!info->rx_skb) {\r\ndev_err(info->dev,\r\n"No memory for new packet\n");\r\ngoto finish_rx;\r\n}\r\ninfo->rx_state = WAIT_FOR_PKT_TYPE;\r\ninfo->rx_skb->dev = (void *)info->hdev;\r\n}\r\ninfo->hdev->stat.byte_rx++;\r\nhci_h4p_handle_byte(info, byte);\r\n}\r\nif (!info->rx_enabled) {\r\nif (hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT &&\r\ninfo->autorts) {\r\n__hci_h4p_set_auto_ctsrts(info, 0 , UART_EFR_RTS);\r\ninfo->autorts = 0;\r\n}\r\nhci_h4p_inb(info, UART_OMAP_SCR);\r\nhci_h4p_set_clk(info, &info->rx_clocks_en, 0);\r\n}\r\nfinish_rx:\r\nBT_DBG("rx_ended");\r\n}\r\nstatic void hci_h4p_tx_tasklet(unsigned long data)\r\n{\r\nunsigned int sent = 0;\r\nstruct sk_buff *skb;\r\nstruct hci_h4p_info *info = (struct hci_h4p_info *)data;\r\nBT_DBG("tasklet woke up");\r\nBT_DBG("tx_tasklet woke up");\r\nif (info->autorts != info->rx_enabled) {\r\nif (hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT) {\r\nif (info->autorts && !info->rx_enabled) {\r\n__hci_h4p_set_auto_ctsrts(info, 0,\r\nUART_EFR_RTS);\r\ninfo->autorts = 0;\r\n}\r\nif (!info->autorts && info->rx_enabled) {\r\n__hci_h4p_set_auto_ctsrts(info, 1,\r\nUART_EFR_RTS);\r\ninfo->autorts = 1;\r\n}\r\n} else {\r\nhci_h4p_outb(info, UART_OMAP_SCR,\r\nhci_h4p_inb(info, UART_OMAP_SCR) |\r\nUART_OMAP_SCR_EMPTY_THR);\r\ngoto finish_tx;\r\n}\r\n}\r\nskb = skb_dequeue(&info->txq);\r\nif (!skb) {\r\nBT_DBG("skb ready");\r\nif (hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT) {\r\nhci_h4p_outb(info, UART_IER,\r\nhci_h4p_inb(info, UART_IER) &\r\n~UART_IER_THRI);\r\nhci_h4p_inb(info, UART_OMAP_SCR);\r\nhci_h4p_disable_tx(info);\r\nreturn;\r\n}\r\nhci_h4p_outb(info, UART_OMAP_SCR,\r\nhci_h4p_inb(info, UART_OMAP_SCR) |\r\nUART_OMAP_SCR_EMPTY_THR);\r\ngoto finish_tx;\r\n}\r\nwhile (!(hci_h4p_inb(info, UART_OMAP_SSR) & UART_OMAP_SSR_TXFULL) &&\r\n(sent < skb->len)) {\r\nhci_h4p_outb(info, UART_TX, skb->data[sent]);\r\nsent++;\r\n}\r\ninfo->hdev->stat.byte_tx += sent;\r\nif (skb->len == sent) {\r\nkfree_skb(skb);\r\n} else {\r\nskb_pull(skb, sent);\r\nskb_queue_head(&info->txq, skb);\r\n}\r\nhci_h4p_outb(info, UART_OMAP_SCR, hci_h4p_inb(info, UART_OMAP_SCR) &\r\n~UART_OMAP_SCR_EMPTY_THR);\r\nhci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |\r\nUART_IER_THRI);\r\nfinish_tx:\r\nhci_h4p_inb(info, UART_OMAP_SCR);\r\n}\r\nstatic irqreturn_t hci_h4p_interrupt(int irq, void *data)\r\n{\r\nstruct hci_h4p_info *info = (struct hci_h4p_info *)data;\r\nu8 iir, msr;\r\nint ret;\r\nret = IRQ_NONE;\r\niir = hci_h4p_inb(info, UART_IIR);\r\nif (iir & UART_IIR_NO_INT)\r\nreturn IRQ_HANDLED;\r\nBT_DBG("In interrupt handler iir 0x%.2x", iir);\r\niir &= UART_IIR_ID;\r\nif (iir == UART_IIR_MSI) {\r\nmsr = hci_h4p_inb(info, UART_MSR);\r\nret = IRQ_HANDLED;\r\n}\r\nif (iir == UART_IIR_RLSI) {\r\nhci_h4p_inb(info, UART_RX);\r\nhci_h4p_inb(info, UART_LSR);\r\nret = IRQ_HANDLED;\r\n}\r\nif (iir == UART_IIR_RDI) {\r\nhci_h4p_rx_tasklet((unsigned long)data);\r\nret = IRQ_HANDLED;\r\n}\r\nif (iir == UART_IIR_THRI) {\r\nhci_h4p_tx_tasklet((unsigned long)data);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t hci_h4p_wakeup_interrupt(int irq, void *dev_inst)\r\n{\r\nstruct hci_h4p_info *info = dev_inst;\r\nint should_wakeup;\r\nstruct hci_dev *hdev;\r\nif (!info->hdev)\r\nreturn IRQ_HANDLED;\r\nshould_wakeup = gpio_get_value(info->host_wakeup_gpio);\r\nhdev = info->hdev;\r\nif (!test_bit(HCI_RUNNING, &hdev->flags)) {\r\nif (should_wakeup == 1)\r\ncomplete_all(&info->test_completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nBT_DBG("gpio interrupt %d", should_wakeup);\r\nif (info->rx_enabled == should_wakeup)\r\nreturn IRQ_HANDLED;\r\nif (should_wakeup)\r\nhci_h4p_enable_rx(info);\r\nelse\r\nhci_h4p_disable_rx(info);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void hci_h4p_set_pm_limits(struct hci_h4p_info *info, bool set)\r\n{\r\nstruct hci_h4p_platform_data *bt_plat_data = info->dev->platform_data;\r\nconst char *sset = set ? "set" : "clear";\r\nif (unlikely(!bt_plat_data || !bt_plat_data->set_pm_limits))\r\nreturn;\r\nif (set != !!test_bit(H4P_ACTIVE_MODE, &info->pm_flags)) {\r\nbt_plat_data->set_pm_limits(info->dev, set);\r\nif (set)\r\nset_bit(H4P_ACTIVE_MODE, &info->pm_flags);\r\nelse\r\nclear_bit(H4P_ACTIVE_MODE, &info->pm_flags);\r\nBT_DBG("Change pm constraints to: %s", sset);\r\nreturn;\r\n}\r\nBT_DBG("pm constraints remains: %s", sset);\r\n}\r\nstatic int hci_h4p_reset(struct hci_h4p_info *info)\r\n{\r\nint err;\r\nerr = hci_h4p_reset_uart(info);\r\nif (err < 0) {\r\ndev_err(info->dev, "Uart reset failed\n");\r\nreturn err;\r\n}\r\nhci_h4p_init_uart(info);\r\nhci_h4p_set_rts(info, 0);\r\ngpio_set_value(info->reset_gpio, 0);\r\ngpio_set_value(info->bt_wakeup_gpio, 1);\r\nmsleep(10);\r\nif (gpio_get_value(info->host_wakeup_gpio) == 1) {\r\ndev_err(info->dev, "host_wakeup_gpio not low\n");\r\nreturn -EPROTO;\r\n}\r\ninit_completion(&info->test_completion);\r\ngpio_set_value(info->reset_gpio, 1);\r\nif (!wait_for_completion_interruptible_timeout(&info->test_completion,\r\nmsecs_to_jiffies(100))) {\r\ndev_err(info->dev, "wakeup test timed out\n");\r\ncomplete_all(&info->test_completion);\r\nreturn -EPROTO;\r\n}\r\nerr = hci_h4p_wait_for_cts(info, 1, 100);\r\nif (err < 0) {\r\ndev_err(info->dev, "No cts from bt chip\n");\r\nreturn err;\r\n}\r\nhci_h4p_set_rts(info, 1);\r\nreturn 0;\r\n}\r\nstatic int hci_h4p_hci_flush(struct hci_dev *hdev)\r\n{\r\nstruct hci_h4p_info *info = hci_get_drvdata(hdev);\r\nskb_queue_purge(&info->txq);\r\nreturn 0;\r\n}\r\nstatic int hci_h4p_bt_wakeup_test(struct hci_h4p_info *info)\r\n{\r\nint err;\r\nint ret = -ECOMM;\r\nif (!info)\r\nreturn -EINVAL;\r\ndisable_irq(gpio_to_irq(info->host_wakeup_gpio));\r\ngpio_set_value(info->bt_wakeup_gpio, 0);\r\nerr = hci_h4p_wait_for_cts(info, 0, 100);\r\nif (err) {\r\ndev_warn(info->dev,\r\n"bt_wakeup_test: fail: CTS low timed out: %d\n",\r\nerr);\r\ngoto out;\r\n}\r\ngpio_set_value(info->bt_wakeup_gpio, 1);\r\nerr = hci_h4p_wait_for_cts(info, 1, 100);\r\nif (err) {\r\ndev_warn(info->dev,\r\n"bt_wakeup_test: fail: CTS high timed out: %d\n",\r\nerr);\r\ngoto out;\r\n}\r\ngpio_set_value(info->bt_wakeup_gpio, 0);\r\nerr = hci_h4p_wait_for_cts(info, 0, 100);\r\nif (err) {\r\ndev_warn(info->dev,\r\n"bt_wakeup_test: fail: CTS re-low timed out: %d\n",\r\nerr);\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nenable_irq(gpio_to_irq(info->host_wakeup_gpio));\r\nreturn ret;\r\n}\r\nstatic int hci_h4p_hci_open(struct hci_dev *hdev)\r\n{\r\nstruct hci_h4p_info *info;\r\nint err, retries = 0;\r\nstruct sk_buff_head fw_queue;\r\nunsigned long flags;\r\ninfo = hci_get_drvdata(hdev);\r\nif (test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nagain:\r\ninfo->rx_enabled = 1;\r\ninfo->rx_state = WAIT_FOR_PKT_TYPE;\r\ninfo->rx_count = 0;\r\ninfo->garbage_bytes = 0;\r\ninfo->rx_skb = NULL;\r\ninfo->pm_enabled = 0;\r\ninit_completion(&info->fw_completion);\r\nhci_h4p_set_clk(info, &info->tx_clocks_en, 1);\r\nhci_h4p_set_clk(info, &info->rx_clocks_en, 1);\r\nskb_queue_head_init(&fw_queue);\r\nerr = hci_h4p_reset(info);\r\nif (err < 0)\r\ngoto err_clean;\r\nhci_h4p_set_auto_ctsrts(info, 1, UART_EFR_CTS | UART_EFR_RTS);\r\ninfo->autorts = 1;\r\nerr = hci_h4p_send_negotiation(info);\r\nerr = hci_h4p_read_fw(info, &fw_queue);\r\nif (err < 0) {\r\ndev_err(info->dev, "Cannot read firmware\n");\r\ngoto err_clean;\r\n}\r\nerr = hci_h4p_send_fw(info, &fw_queue);\r\nif (err < 0) {\r\ndev_err(info->dev, "Sending firmware failed.\n");\r\ngoto err_clean;\r\n}\r\ninfo->pm_enabled = 1;\r\nerr = hci_h4p_bt_wakeup_test(info);\r\nif (err < 0) {\r\ndev_err(info->dev, "BT wakeup test failed.\n");\r\ngoto err_clean;\r\n}\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->rx_enabled = gpio_get_value(info->host_wakeup_gpio);\r\nhci_h4p_set_clk(info, &info->rx_clocks_en, info->rx_enabled);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nhci_h4p_set_clk(info, &info->tx_clocks_en, 0);\r\nkfree_skb(info->alive_cmd_skb);\r\ninfo->alive_cmd_skb = NULL;\r\nset_bit(HCI_RUNNING, &hdev->flags);\r\nBT_DBG("hci up and running");\r\nreturn 0;\r\nerr_clean:\r\nhci_h4p_hci_flush(hdev);\r\nhci_h4p_reset_uart(info);\r\ndel_timer_sync(&info->lazy_release);\r\nhci_h4p_set_clk(info, &info->tx_clocks_en, 0);\r\nhci_h4p_set_clk(info, &info->rx_clocks_en, 0);\r\ngpio_set_value(info->reset_gpio, 0);\r\ngpio_set_value(info->bt_wakeup_gpio, 0);\r\nskb_queue_purge(&fw_queue);\r\nkfree_skb(info->alive_cmd_skb);\r\ninfo->alive_cmd_skb = NULL;\r\nkfree_skb(info->rx_skb);\r\ninfo->rx_skb = NULL;\r\nif (retries++ < 3) {\r\ndev_err(info->dev, "FW loading try %d fail. Retry.\n", retries);\r\ngoto again;\r\n}\r\nreturn err;\r\n}\r\nstatic int hci_h4p_hci_close(struct hci_dev *hdev)\r\n{\r\nstruct hci_h4p_info *info = hci_get_drvdata(hdev);\r\nif (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nhci_h4p_hci_flush(hdev);\r\nhci_h4p_set_clk(info, &info->tx_clocks_en, 1);\r\nhci_h4p_set_clk(info, &info->rx_clocks_en, 1);\r\nhci_h4p_reset_uart(info);\r\ndel_timer_sync(&info->lazy_release);\r\nhci_h4p_set_clk(info, &info->tx_clocks_en, 0);\r\nhci_h4p_set_clk(info, &info->rx_clocks_en, 0);\r\ngpio_set_value(info->reset_gpio, 0);\r\ngpio_set_value(info->bt_wakeup_gpio, 0);\r\nkfree_skb(info->rx_skb);\r\nreturn 0;\r\n}\r\nstatic int hci_h4p_hci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_h4p_info *info;\r\nint err = 0;\r\nBT_DBG("dev %p, skb %p", hdev, skb);\r\ninfo = hci_get_drvdata(hdev);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags)) {\r\ndev_warn(info->dev, "Frame for non-running device\n");\r\nreturn -EIO;\r\n}\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\n}\r\n*skb_push(skb, 1) = (bt_cb(skb)->pkt_type);\r\nif (skb->len % 2) {\r\nerr = skb_pad(skb, 1);\r\nif (!err)\r\n*skb_put(skb, 1) = 0x00;\r\n}\r\nif (err)\r\nreturn err;\r\nskb_queue_tail(&info->txq, skb);\r\nhci_h4p_enable_tx(info);\r\nreturn 0;\r\n}\r\nstatic ssize_t hci_h4p_store_bdaddr(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hci_h4p_info *info = dev_get_drvdata(dev);\r\nunsigned int bdaddr[6];\r\nint ret, i;\r\nret = sscanf(buf, "%2x:%2x:%2x:%2x:%2x:%2x\n",\r\n&bdaddr[0], &bdaddr[1], &bdaddr[2],\r\n&bdaddr[3], &bdaddr[4], &bdaddr[5]);\r\nif (ret != 6)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 6; i++) {\r\nif (bdaddr[i] > 0xff)\r\nreturn -EINVAL;\r\ninfo->bd_addr[i] = bdaddr[i] & 0xff;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t hci_h4p_show_bdaddr(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_h4p_info *info = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%pMR\n", info->bd_addr);\r\n}\r\nstatic int hci_h4p_sysfs_create_files(struct device *dev)\r\n{\r\nreturn device_create_file(dev, &dev_attr_bdaddr);\r\n}\r\nstatic void hci_h4p_sysfs_remove_files(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_bdaddr);\r\n}\r\nstatic int hci_h4p_register_hdev(struct hci_h4p_info *info)\r\n{\r\nstruct hci_dev *hdev;\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\ndev_err(info->dev, "Can't allocate memory for device\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->hdev = hdev;\r\nhdev->bus = HCI_UART;\r\nhci_set_drvdata(hdev, info);\r\nhdev->open = hci_h4p_hci_open;\r\nhdev->close = hci_h4p_hci_close;\r\nhdev->flush = hci_h4p_hci_flush;\r\nhdev->send = hci_h4p_hci_send_frame;\r\nset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\r\nSET_HCIDEV_DEV(hdev, info->dev);\r\nif (hci_h4p_sysfs_create_files(info->dev) < 0) {\r\ndev_err(info->dev, "failed to create sysfs files\n");\r\ngoto free;\r\n}\r\nif (hci_register_dev(hdev) >= 0)\r\nreturn 0;\r\ndev_err(info->dev, "hci_register failed %s.\n", hdev->name);\r\nhci_h4p_sysfs_remove_files(info->dev);\r\nfree:\r\nhci_free_dev(info->hdev);\r\nreturn -ENODEV;\r\n}\r\nstatic int hci_h4p_probe(struct platform_device *pdev)\r\n{\r\nstruct hci_h4p_platform_data *bt_plat_data;\r\nstruct hci_h4p_info *info;\r\nint err;\r\ndev_info(&pdev->dev, "Registering HCI H4P device\n");\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(struct hci_h4p_info),\r\nGFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->dev = &pdev->dev;\r\ninfo->tx_enabled = 1;\r\ninfo->rx_enabled = 1;\r\nspin_lock_init(&info->lock);\r\nspin_lock_init(&info->clocks_lock);\r\nskb_queue_head_init(&info->txq);\r\nif (pdev->dev.platform_data == NULL) {\r\ndev_err(&pdev->dev, "Could not get Bluetooth config data\n");\r\nreturn -ENODATA;\r\n}\r\nbt_plat_data = pdev->dev.platform_data;\r\ninfo->chip_type = bt_plat_data->chip_type;\r\ninfo->bt_wakeup_gpio = bt_plat_data->bt_wakeup_gpio;\r\ninfo->host_wakeup_gpio = bt_plat_data->host_wakeup_gpio;\r\ninfo->reset_gpio = bt_plat_data->reset_gpio;\r\ninfo->reset_gpio_shared = bt_plat_data->reset_gpio_shared;\r\ninfo->bt_sysclk = bt_plat_data->bt_sysclk;\r\nBT_DBG("RESET gpio: %d", info->reset_gpio);\r\nBT_DBG("BTWU gpio: %d", info->bt_wakeup_gpio);\r\nBT_DBG("HOSTWU gpio: %d", info->host_wakeup_gpio);\r\nBT_DBG("sysclk: %d", info->bt_sysclk);\r\ninit_completion(&info->test_completion);\r\ncomplete_all(&info->test_completion);\r\nif (!info->reset_gpio_shared) {\r\nerr = devm_gpio_request_one(&pdev->dev, info->reset_gpio,\r\nGPIOF_OUT_INIT_LOW, "bt_reset");\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "Cannot get GPIO line %d\n",\r\ninfo->reset_gpio);\r\nreturn err;\r\n}\r\n}\r\nerr = devm_gpio_request_one(&pdev->dev, info->bt_wakeup_gpio,\r\nGPIOF_OUT_INIT_LOW, "bt_wakeup");\r\nif (err < 0) {\r\ndev_err(info->dev, "Cannot get GPIO line 0x%d",\r\ninfo->bt_wakeup_gpio);\r\nreturn err;\r\n}\r\nerr = devm_gpio_request_one(&pdev->dev, info->host_wakeup_gpio,\r\nGPIOF_DIR_IN, "host_wakeup");\r\nif (err < 0) {\r\ndev_err(info->dev, "Cannot get GPIO line %d",\r\ninfo->host_wakeup_gpio);\r\nreturn err;\r\n}\r\ninfo->irq = bt_plat_data->uart_irq;\r\ninfo->uart_base = devm_ioremap(&pdev->dev, bt_plat_data->uart_base,\r\nSZ_2K);\r\ninfo->uart_iclk = devm_clk_get(&pdev->dev, bt_plat_data->uart_iclk);\r\ninfo->uart_fclk = devm_clk_get(&pdev->dev, bt_plat_data->uart_fclk);\r\nerr = devm_request_irq(&pdev->dev, info->irq, hci_h4p_interrupt,\r\nIRQF_DISABLED, "hci_h4p", info);\r\nif (err < 0) {\r\ndev_err(info->dev, "hci_h4p: unable to get IRQ %d\n",\r\ninfo->irq);\r\nreturn err;\r\n}\r\nerr = devm_request_irq(&pdev->dev, gpio_to_irq(info->host_wakeup_gpio),\r\nhci_h4p_wakeup_interrupt, IRQF_TRIGGER_FALLING |\r\nIRQF_TRIGGER_RISING | IRQF_DISABLED,\r\n"hci_h4p_wkup", info);\r\nif (err < 0) {\r\ndev_err(info->dev, "hci_h4p: unable to get wakeup IRQ %d\n",\r\ngpio_to_irq(info->host_wakeup_gpio));\r\nreturn err;\r\n}\r\nerr = irq_set_irq_wake(gpio_to_irq(info->host_wakeup_gpio), 1);\r\nif (err < 0) {\r\ndev_err(info->dev, "hci_h4p: unable to set wakeup for IRQ %d\n",\r\ngpio_to_irq(info->host_wakeup_gpio));\r\nreturn err;\r\n}\r\ninit_timer_deferrable(&info->lazy_release);\r\ninfo->lazy_release.function = hci_h4p_lazy_clock_release;\r\ninfo->lazy_release.data = (unsigned long)info;\r\nhci_h4p_set_clk(info, &info->tx_clocks_en, 1);\r\nerr = hci_h4p_reset_uart(info);\r\nif (err < 0)\r\nreturn err;\r\ngpio_set_value(info->reset_gpio, 0);\r\nhci_h4p_set_clk(info, &info->tx_clocks_en, 0);\r\nplatform_set_drvdata(pdev, info);\r\nif (hci_h4p_register_hdev(info) < 0) {\r\ndev_err(info->dev, "failed to register hci_h4p hci device\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hci_h4p_remove(struct platform_device *pdev)\r\n{\r\nstruct hci_h4p_info *info;\r\ninfo = platform_get_drvdata(pdev);\r\nhci_h4p_sysfs_remove_files(info->dev);\r\nhci_h4p_hci_close(info->hdev);\r\nhci_unregister_dev(info->hdev);\r\nhci_free_dev(info->hdev);\r\nreturn 0;\r\n}
