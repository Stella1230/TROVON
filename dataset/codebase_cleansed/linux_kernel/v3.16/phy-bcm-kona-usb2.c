static void bcm_kona_usb_phy_power(struct bcm_kona_usb *phy, int on)\r\n{\r\nu32 val;\r\nval = readl(phy->regs + OTGCTL);\r\nif (on) {\r\nval &= ~(OTGCTL_OTGSTAT2 | OTGCTL_OTGSTAT1 |\r\nOTGCTL_UTMI_LINE_STATE1 | OTGCTL_UTMI_LINE_STATE0);\r\nval |= OTGCTL_PRST_N_SW | OTGCTL_HRESET_N;\r\n} else {\r\nval &= ~(OTGCTL_PRST_N_SW | OTGCTL_HRESET_N);\r\n}\r\nwritel(val, phy->regs + OTGCTL);\r\n}\r\nstatic int bcm_kona_usb_phy_init(struct phy *gphy)\r\n{\r\nstruct bcm_kona_usb *phy = phy_get_drvdata(gphy);\r\nu32 val;\r\nval = readl(phy->regs + P1CTL);\r\nval &= ~P1CTL_NON_DRIVING;\r\nval |= P1CTL_SOFT_RESET;\r\nwritel(val, phy->regs + P1CTL);\r\nwritel(val & ~P1CTL_SOFT_RESET, phy->regs + P1CTL);\r\nmdelay(2);\r\nwritel(val | P1CTL_SOFT_RESET, phy->regs + P1CTL);\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_usb_phy_power_on(struct phy *gphy)\r\n{\r\nstruct bcm_kona_usb *phy = phy_get_drvdata(gphy);\r\nbcm_kona_usb_phy_power(phy, 1);\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_usb_phy_power_off(struct phy *gphy)\r\n{\r\nstruct bcm_kona_usb *phy = phy_get_drvdata(gphy);\r\nbcm_kona_usb_phy_power(phy, 0);\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_usb2_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct bcm_kona_usb *phy;\r\nstruct resource *res;\r\nstruct phy *gphy;\r\nstruct phy_provider *phy_provider;\r\nphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nphy->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(phy->regs))\r\nreturn PTR_ERR(phy->regs);\r\nplatform_set_drvdata(pdev, phy);\r\ngphy = devm_phy_create(dev, &ops, NULL);\r\nif (IS_ERR(gphy))\r\nreturn PTR_ERR(gphy);\r\nphy_set_bus_width(gphy, 8);\r\nphy_set_drvdata(gphy, phy);\r\nphy_provider = devm_of_phy_provider_register(dev,\r\nof_phy_simple_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
