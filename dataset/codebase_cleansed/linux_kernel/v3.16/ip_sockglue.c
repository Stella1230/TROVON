static void ip_cmsg_recv_pktinfo(struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nstruct in_pktinfo info = *PKTINFO_SKB_CB(skb);\r\ninfo.ipi_addr.s_addr = ip_hdr(skb)->daddr;\r\nput_cmsg(msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\r\n}\r\nstatic void ip_cmsg_recv_ttl(struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nint ttl = ip_hdr(skb)->ttl;\r\nput_cmsg(msg, SOL_IP, IP_TTL, sizeof(int), &ttl);\r\n}\r\nstatic void ip_cmsg_recv_tos(struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nput_cmsg(msg, SOL_IP, IP_TOS, 1, &ip_hdr(skb)->tos);\r\n}\r\nstatic void ip_cmsg_recv_opts(struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nif (IPCB(skb)->opt.optlen == 0)\r\nreturn;\r\nput_cmsg(msg, SOL_IP, IP_RECVOPTS, IPCB(skb)->opt.optlen,\r\nip_hdr(skb) + 1);\r\n}\r\nstatic void ip_cmsg_recv_retopts(struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nunsigned char optbuf[sizeof(struct ip_options) + 40];\r\nstruct ip_options *opt = (struct ip_options *)optbuf;\r\nif (IPCB(skb)->opt.optlen == 0)\r\nreturn;\r\nif (ip_options_echo(opt, skb)) {\r\nmsg->msg_flags |= MSG_CTRUNC;\r\nreturn;\r\n}\r\nip_options_undo(opt);\r\nput_cmsg(msg, SOL_IP, IP_RETOPTS, opt->optlen, opt->__data);\r\n}\r\nstatic void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nchar *secdata;\r\nu32 seclen, secid;\r\nint err;\r\nerr = security_socket_getpeersec_dgram(NULL, skb, &secid);\r\nif (err)\r\nreturn;\r\nerr = security_secid_to_secctx(secid, &secdata, &seclen);\r\nif (err)\r\nreturn;\r\nput_cmsg(msg, SOL_IP, SCM_SECURITY, seclen, secdata);\r\nsecurity_release_secctx(secdata, seclen);\r\n}\r\nstatic void ip_cmsg_recv_dstaddr(struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nstruct sockaddr_in sin;\r\nconst struct iphdr *iph = ip_hdr(skb);\r\n__be16 *ports = (__be16 *)skb_transport_header(skb);\r\nif (skb_transport_offset(skb) + 4 > skb->len)\r\nreturn;\r\nsin.sin_family = AF_INET;\r\nsin.sin_addr.s_addr = iph->daddr;\r\nsin.sin_port = ports[1];\r\nmemset(sin.sin_zero, 0, sizeof(sin.sin_zero));\r\nput_cmsg(msg, SOL_IP, IP_ORIGDSTADDR, sizeof(sin), &sin);\r\n}\r\nvoid ip_cmsg_recv(struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nstruct inet_sock *inet = inet_sk(skb->sk);\r\nunsigned int flags = inet->cmsg_flags;\r\nif (flags & 1)\r\nip_cmsg_recv_pktinfo(msg, skb);\r\nif ((flags >>= 1) == 0)\r\nreturn;\r\nif (flags & 1)\r\nip_cmsg_recv_ttl(msg, skb);\r\nif ((flags >>= 1) == 0)\r\nreturn;\r\nif (flags & 1)\r\nip_cmsg_recv_tos(msg, skb);\r\nif ((flags >>= 1) == 0)\r\nreturn;\r\nif (flags & 1)\r\nip_cmsg_recv_opts(msg, skb);\r\nif ((flags >>= 1) == 0)\r\nreturn;\r\nif (flags & 1)\r\nip_cmsg_recv_retopts(msg, skb);\r\nif ((flags >>= 1) == 0)\r\nreturn;\r\nif (flags & 1)\r\nip_cmsg_recv_security(msg, skb);\r\nif ((flags >>= 1) == 0)\r\nreturn;\r\nif (flags & 1)\r\nip_cmsg_recv_dstaddr(msg, skb);\r\n}\r\nint ip_cmsg_send(struct net *net, struct msghdr *msg, struct ipcm_cookie *ipc,\r\nbool allow_ipv6)\r\n{\r\nint err, val;\r\nstruct cmsghdr *cmsg;\r\nfor (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {\r\nif (!CMSG_OK(msg, cmsg))\r\nreturn -EINVAL;\r\n#if defined(CONFIG_IPV6)\r\nif (allow_ipv6 &&\r\ncmsg->cmsg_level == SOL_IPV6 &&\r\ncmsg->cmsg_type == IPV6_PKTINFO) {\r\nstruct in6_pktinfo *src_info;\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(*src_info)))\r\nreturn -EINVAL;\r\nsrc_info = (struct in6_pktinfo *)CMSG_DATA(cmsg);\r\nif (!ipv6_addr_v4mapped(&src_info->ipi6_addr))\r\nreturn -EINVAL;\r\nipc->oif = src_info->ipi6_ifindex;\r\nipc->addr = src_info->ipi6_addr.s6_addr32[3];\r\ncontinue;\r\n}\r\n#endif\r\nif (cmsg->cmsg_level != SOL_IP)\r\ncontinue;\r\nswitch (cmsg->cmsg_type) {\r\ncase IP_RETOPTS:\r\nerr = cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr));\r\nerr = ip_options_get(net, &ipc->opt, CMSG_DATA(cmsg),\r\nerr < 40 ? err : 40);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase IP_PKTINFO:\r\n{\r\nstruct in_pktinfo *info;\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct in_pktinfo)))\r\nreturn -EINVAL;\r\ninfo = (struct in_pktinfo *)CMSG_DATA(cmsg);\r\nipc->oif = info->ipi_ifindex;\r\nipc->addr = info->ipi_spec_dst.s_addr;\r\nbreak;\r\n}\r\ncase IP_TTL:\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\r\nreturn -EINVAL;\r\nval = *(int *)CMSG_DATA(cmsg);\r\nif (val < 1 || val > 255)\r\nreturn -EINVAL;\r\nipc->ttl = val;\r\nbreak;\r\ncase IP_TOS:\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\r\nreturn -EINVAL;\r\nval = *(int *)CMSG_DATA(cmsg);\r\nif (val < 0 || val > 255)\r\nreturn -EINVAL;\r\nipc->tos = val;\r\nipc->priority = rt_tos2priority(ipc->tos);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ip_ra_destroy_rcu(struct rcu_head *head)\r\n{\r\nstruct ip_ra_chain *ra = container_of(head, struct ip_ra_chain, rcu);\r\nsock_put(ra->saved_sk);\r\nkfree(ra);\r\n}\r\nint ip_ra_control(struct sock *sk, unsigned char on,\r\nvoid (*destructor)(struct sock *))\r\n{\r\nstruct ip_ra_chain *ra, *new_ra;\r\nstruct ip_ra_chain __rcu **rap;\r\nif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num == IPPROTO_RAW)\r\nreturn -EINVAL;\r\nnew_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\r\nspin_lock_bh(&ip_ra_lock);\r\nfor (rap = &ip_ra_chain;\r\n(ra = rcu_dereference_protected(*rap,\r\nlockdep_is_held(&ip_ra_lock))) != NULL;\r\nrap = &ra->next) {\r\nif (ra->sk == sk) {\r\nif (on) {\r\nspin_unlock_bh(&ip_ra_lock);\r\nkfree(new_ra);\r\nreturn -EADDRINUSE;\r\n}\r\nra->sk = NULL;\r\nrcu_assign_pointer(*rap, ra->next);\r\nspin_unlock_bh(&ip_ra_lock);\r\nif (ra->destructor)\r\nra->destructor(sk);\r\nra->saved_sk = sk;\r\ncall_rcu(&ra->rcu, ip_ra_destroy_rcu);\r\nreturn 0;\r\n}\r\n}\r\nif (new_ra == NULL) {\r\nspin_unlock_bh(&ip_ra_lock);\r\nreturn -ENOBUFS;\r\n}\r\nnew_ra->sk = sk;\r\nnew_ra->destructor = destructor;\r\nnew_ra->next = ra;\r\nrcu_assign_pointer(*rap, new_ra);\r\nsock_hold(sk);\r\nspin_unlock_bh(&ip_ra_lock);\r\nreturn 0;\r\n}\r\nvoid ip_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\r\n__be16 port, u32 info, u8 *payload)\r\n{\r\nstruct sock_exterr_skb *serr;\r\nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nserr = SKB_EXT_ERR(skb);\r\nserr->ee.ee_errno = err;\r\nserr->ee.ee_origin = SO_EE_ORIGIN_ICMP;\r\nserr->ee.ee_type = icmp_hdr(skb)->type;\r\nserr->ee.ee_code = icmp_hdr(skb)->code;\r\nserr->ee.ee_pad = 0;\r\nserr->ee.ee_info = info;\r\nserr->ee.ee_data = 0;\r\nserr->addr_offset = (u8 *)&(((struct iphdr *)(icmp_hdr(skb) + 1))->daddr) -\r\nskb_network_header(skb);\r\nserr->port = port;\r\nif (skb_pull(skb, payload - skb->data) != NULL) {\r\nskb_reset_transport_header(skb);\r\nif (sock_queue_err_skb(sk, skb) == 0)\r\nreturn;\r\n}\r\nkfree_skb(skb);\r\n}\r\nvoid ip_local_error(struct sock *sk, int err, __be32 daddr, __be16 port, u32 info)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct sock_exterr_skb *serr;\r\nstruct iphdr *iph;\r\nstruct sk_buff *skb;\r\nif (!inet->recverr)\r\nreturn;\r\nskb = alloc_skb(sizeof(struct iphdr), GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_put(skb, sizeof(struct iphdr));\r\nskb_reset_network_header(skb);\r\niph = ip_hdr(skb);\r\niph->daddr = daddr;\r\nserr = SKB_EXT_ERR(skb);\r\nserr->ee.ee_errno = err;\r\nserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\r\nserr->ee.ee_type = 0;\r\nserr->ee.ee_code = 0;\r\nserr->ee.ee_pad = 0;\r\nserr->ee.ee_info = info;\r\nserr->ee.ee_data = 0;\r\nserr->addr_offset = (u8 *)&iph->daddr - skb_network_header(skb);\r\nserr->port = port;\r\n__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\r\nskb_reset_transport_header(skb);\r\nif (sock_queue_err_skb(sk, skb))\r\nkfree_skb(skb);\r\n}\r\nint ip_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\r\n{\r\nstruct sock_exterr_skb *serr;\r\nstruct sk_buff *skb, *skb2;\r\nDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\r\nstruct {\r\nstruct sock_extended_err ee;\r\nstruct sockaddr_in offender;\r\n} errhdr;\r\nint err;\r\nint copied;\r\nerr = -EAGAIN;\r\nskb = skb_dequeue(&sk->sk_error_queue);\r\nif (skb == NULL)\r\ngoto out;\r\ncopied = skb->len;\r\nif (copied > len) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nif (err)\r\ngoto out_free_skb;\r\nsock_recv_timestamp(msg, sk, skb);\r\nserr = SKB_EXT_ERR(skb);\r\nif (sin) {\r\nsin->sin_family = AF_INET;\r\nsin->sin_addr.s_addr = *(__be32 *)(skb_network_header(skb) +\r\nserr->addr_offset);\r\nsin->sin_port = serr->port;\r\nmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\r\n*addr_len = sizeof(*sin);\r\n}\r\nmemcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));\r\nsin = &errhdr.offender;\r\nsin->sin_family = AF_UNSPEC;\r\nif (serr->ee.ee_origin == SO_EE_ORIGIN_ICMP) {\r\nstruct inet_sock *inet = inet_sk(sk);\r\nsin->sin_family = AF_INET;\r\nsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\r\nsin->sin_port = 0;\r\nmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\r\nif (inet->cmsg_flags)\r\nip_cmsg_recv(msg, skb);\r\n}\r\nput_cmsg(msg, SOL_IP, IP_RECVERR, sizeof(errhdr), &errhdr);\r\nmsg->msg_flags |= MSG_ERRQUEUE;\r\nerr = copied;\r\nspin_lock_bh(&sk->sk_error_queue.lock);\r\nsk->sk_err = 0;\r\nskb2 = skb_peek(&sk->sk_error_queue);\r\nif (skb2 != NULL) {\r\nsk->sk_err = SKB_EXT_ERR(skb2)->ee.ee_errno;\r\nspin_unlock_bh(&sk->sk_error_queue.lock);\r\nsk->sk_error_report(sk);\r\n} else\r\nspin_unlock_bh(&sk->sk_error_queue.lock);\r\nout_free_skb:\r\nkfree_skb(skb);\r\nout:\r\nreturn err;\r\n}\r\nstatic int do_ip_setsockopt(struct sock *sk, int level,\r\nint optname, char __user *optval, unsigned int optlen)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nint val = 0, err;\r\nswitch (optname) {\r\ncase IP_PKTINFO:\r\ncase IP_RECVTTL:\r\ncase IP_RECVOPTS:\r\ncase IP_RECVTOS:\r\ncase IP_RETOPTS:\r\ncase IP_TOS:\r\ncase IP_TTL:\r\ncase IP_HDRINCL:\r\ncase IP_MTU_DISCOVER:\r\ncase IP_RECVERR:\r\ncase IP_ROUTER_ALERT:\r\ncase IP_FREEBIND:\r\ncase IP_PASSSEC:\r\ncase IP_TRANSPARENT:\r\ncase IP_MINTTL:\r\ncase IP_NODEFRAG:\r\ncase IP_UNICAST_IF:\r\ncase IP_MULTICAST_TTL:\r\ncase IP_MULTICAST_ALL:\r\ncase IP_MULTICAST_LOOP:\r\ncase IP_RECVORIGDSTADDR:\r\nif (optlen >= sizeof(int)) {\r\nif (get_user(val, (int __user *) optval))\r\nreturn -EFAULT;\r\n} else if (optlen >= sizeof(char)) {\r\nunsigned char ucval;\r\nif (get_user(ucval, (unsigned char __user *) optval))\r\nreturn -EFAULT;\r\nval = (int) ucval;\r\n}\r\n}\r\nif (ip_mroute_opt(optname))\r\nreturn ip_mroute_setsockopt(sk, optname, optval, optlen);\r\nerr = 0;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase IP_OPTIONS:\r\n{\r\nstruct ip_options_rcu *old, *opt = NULL;\r\nif (optlen > 40)\r\ngoto e_inval;\r\nerr = ip_options_get_from_user(sock_net(sk), &opt,\r\noptval, optlen);\r\nif (err)\r\nbreak;\r\nold = rcu_dereference_protected(inet->inet_opt,\r\nsock_owned_by_user(sk));\r\nif (inet->is_icsk) {\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == PF_INET ||\r\n(!((1 << sk->sk_state) &\r\n(TCPF_LISTEN | TCPF_CLOSE)) &&\r\ninet->inet_daddr != LOOPBACK4_IPV6)) {\r\n#endif\r\nif (old)\r\nicsk->icsk_ext_hdr_len -= old->opt.optlen;\r\nif (opt)\r\nicsk->icsk_ext_hdr_len += opt->opt.optlen;\r\nicsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n}\r\n#endif\r\n}\r\nrcu_assign_pointer(inet->inet_opt, opt);\r\nif (old)\r\nkfree_rcu(old, rcu);\r\nbreak;\r\n}\r\ncase IP_PKTINFO:\r\nif (val)\r\ninet->cmsg_flags |= IP_CMSG_PKTINFO;\r\nelse\r\ninet->cmsg_flags &= ~IP_CMSG_PKTINFO;\r\nbreak;\r\ncase IP_RECVTTL:\r\nif (val)\r\ninet->cmsg_flags |= IP_CMSG_TTL;\r\nelse\r\ninet->cmsg_flags &= ~IP_CMSG_TTL;\r\nbreak;\r\ncase IP_RECVTOS:\r\nif (val)\r\ninet->cmsg_flags |= IP_CMSG_TOS;\r\nelse\r\ninet->cmsg_flags &= ~IP_CMSG_TOS;\r\nbreak;\r\ncase IP_RECVOPTS:\r\nif (val)\r\ninet->cmsg_flags |= IP_CMSG_RECVOPTS;\r\nelse\r\ninet->cmsg_flags &= ~IP_CMSG_RECVOPTS;\r\nbreak;\r\ncase IP_RETOPTS:\r\nif (val)\r\ninet->cmsg_flags |= IP_CMSG_RETOPTS;\r\nelse\r\ninet->cmsg_flags &= ~IP_CMSG_RETOPTS;\r\nbreak;\r\ncase IP_PASSSEC:\r\nif (val)\r\ninet->cmsg_flags |= IP_CMSG_PASSSEC;\r\nelse\r\ninet->cmsg_flags &= ~IP_CMSG_PASSSEC;\r\nbreak;\r\ncase IP_RECVORIGDSTADDR:\r\nif (val)\r\ninet->cmsg_flags |= IP_CMSG_ORIGDSTADDR;\r\nelse\r\ninet->cmsg_flags &= ~IP_CMSG_ORIGDSTADDR;\r\nbreak;\r\ncase IP_TOS:\r\nif (sk->sk_type == SOCK_STREAM) {\r\nval &= ~INET_ECN_MASK;\r\nval |= inet->tos & INET_ECN_MASK;\r\n}\r\nif (inet->tos != val) {\r\ninet->tos = val;\r\nsk->sk_priority = rt_tos2priority(val);\r\nsk_dst_reset(sk);\r\n}\r\nbreak;\r\ncase IP_TTL:\r\nif (optlen < 1)\r\ngoto e_inval;\r\nif (val != -1 && (val < 1 || val > 255))\r\ngoto e_inval;\r\ninet->uc_ttl = val;\r\nbreak;\r\ncase IP_HDRINCL:\r\nif (sk->sk_type != SOCK_RAW) {\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\ninet->hdrincl = val ? 1 : 0;\r\nbreak;\r\ncase IP_NODEFRAG:\r\nif (sk->sk_type != SOCK_RAW) {\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\ninet->nodefrag = val ? 1 : 0;\r\nbreak;\r\ncase IP_MTU_DISCOVER:\r\nif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_OMIT)\r\ngoto e_inval;\r\ninet->pmtudisc = val;\r\nbreak;\r\ncase IP_RECVERR:\r\ninet->recverr = !!val;\r\nif (!val)\r\nskb_queue_purge(&sk->sk_error_queue);\r\nbreak;\r\ncase IP_MULTICAST_TTL:\r\nif (sk->sk_type == SOCK_STREAM)\r\ngoto e_inval;\r\nif (optlen < 1)\r\ngoto e_inval;\r\nif (val == -1)\r\nval = 1;\r\nif (val < 0 || val > 255)\r\ngoto e_inval;\r\ninet->mc_ttl = val;\r\nbreak;\r\ncase IP_MULTICAST_LOOP:\r\nif (optlen < 1)\r\ngoto e_inval;\r\ninet->mc_loop = !!val;\r\nbreak;\r\ncase IP_UNICAST_IF:\r\n{\r\nstruct net_device *dev = NULL;\r\nint ifindex;\r\nif (optlen != sizeof(int))\r\ngoto e_inval;\r\nifindex = (__force int)ntohl((__force __be32)val);\r\nif (ifindex == 0) {\r\ninet->uc_index = 0;\r\nerr = 0;\r\nbreak;\r\n}\r\ndev = dev_get_by_index(sock_net(sk), ifindex);\r\nerr = -EADDRNOTAVAIL;\r\nif (!dev)\r\nbreak;\r\ndev_put(dev);\r\nerr = -EINVAL;\r\nif (sk->sk_bound_dev_if)\r\nbreak;\r\ninet->uc_index = ifindex;\r\nerr = 0;\r\nbreak;\r\n}\r\ncase IP_MULTICAST_IF:\r\n{\r\nstruct ip_mreqn mreq;\r\nstruct net_device *dev = NULL;\r\nif (sk->sk_type == SOCK_STREAM)\r\ngoto e_inval;\r\nif (optlen < sizeof(struct in_addr))\r\ngoto e_inval;\r\nerr = -EFAULT;\r\nif (optlen >= sizeof(struct ip_mreqn)) {\r\nif (copy_from_user(&mreq, optval, sizeof(mreq)))\r\nbreak;\r\n} else {\r\nmemset(&mreq, 0, sizeof(mreq));\r\nif (optlen >= sizeof(struct ip_mreq)) {\r\nif (copy_from_user(&mreq, optval,\r\nsizeof(struct ip_mreq)))\r\nbreak;\r\n} else if (optlen >= sizeof(struct in_addr)) {\r\nif (copy_from_user(&mreq.imr_address, optval,\r\nsizeof(struct in_addr)))\r\nbreak;\r\n}\r\n}\r\nif (!mreq.imr_ifindex) {\r\nif (mreq.imr_address.s_addr == htonl(INADDR_ANY)) {\r\ninet->mc_index = 0;\r\ninet->mc_addr = 0;\r\nerr = 0;\r\nbreak;\r\n}\r\ndev = ip_dev_find(sock_net(sk), mreq.imr_address.s_addr);\r\nif (dev)\r\nmreq.imr_ifindex = dev->ifindex;\r\n} else\r\ndev = dev_get_by_index(sock_net(sk), mreq.imr_ifindex);\r\nerr = -EADDRNOTAVAIL;\r\nif (!dev)\r\nbreak;\r\ndev_put(dev);\r\nerr = -EINVAL;\r\nif (sk->sk_bound_dev_if &&\r\nmreq.imr_ifindex != sk->sk_bound_dev_if)\r\nbreak;\r\ninet->mc_index = mreq.imr_ifindex;\r\ninet->mc_addr = mreq.imr_address.s_addr;\r\nerr = 0;\r\nbreak;\r\n}\r\ncase IP_ADD_MEMBERSHIP:\r\ncase IP_DROP_MEMBERSHIP:\r\n{\r\nstruct ip_mreqn mreq;\r\nerr = -EPROTO;\r\nif (inet_sk(sk)->is_icsk)\r\nbreak;\r\nif (optlen < sizeof(struct ip_mreq))\r\ngoto e_inval;\r\nerr = -EFAULT;\r\nif (optlen >= sizeof(struct ip_mreqn)) {\r\nif (copy_from_user(&mreq, optval, sizeof(mreq)))\r\nbreak;\r\n} else {\r\nmemset(&mreq, 0, sizeof(mreq));\r\nif (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))\r\nbreak;\r\n}\r\nif (optname == IP_ADD_MEMBERSHIP)\r\nerr = ip_mc_join_group(sk, &mreq);\r\nelse\r\nerr = ip_mc_leave_group(sk, &mreq);\r\nbreak;\r\n}\r\ncase IP_MSFILTER:\r\n{\r\nstruct ip_msfilter *msf;\r\nif (optlen < IP_MSFILTER_SIZE(0))\r\ngoto e_inval;\r\nif (optlen > sysctl_optmem_max) {\r\nerr = -ENOBUFS;\r\nbreak;\r\n}\r\nmsf = kmalloc(optlen, GFP_KERNEL);\r\nif (!msf) {\r\nerr = -ENOBUFS;\r\nbreak;\r\n}\r\nerr = -EFAULT;\r\nif (copy_from_user(msf, optval, optlen)) {\r\nkfree(msf);\r\nbreak;\r\n}\r\nif (msf->imsf_numsrc >= 0x3ffffffcU ||\r\nmsf->imsf_numsrc > sysctl_igmp_max_msf) {\r\nkfree(msf);\r\nerr = -ENOBUFS;\r\nbreak;\r\n}\r\nif (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {\r\nkfree(msf);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nerr = ip_mc_msfilter(sk, msf, 0);\r\nkfree(msf);\r\nbreak;\r\n}\r\ncase IP_BLOCK_SOURCE:\r\ncase IP_UNBLOCK_SOURCE:\r\ncase IP_ADD_SOURCE_MEMBERSHIP:\r\ncase IP_DROP_SOURCE_MEMBERSHIP:\r\n{\r\nstruct ip_mreq_source mreqs;\r\nint omode, add;\r\nif (optlen != sizeof(struct ip_mreq_source))\r\ngoto e_inval;\r\nif (copy_from_user(&mreqs, optval, sizeof(mreqs))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (optname == IP_BLOCK_SOURCE) {\r\nomode = MCAST_EXCLUDE;\r\nadd = 1;\r\n} else if (optname == IP_UNBLOCK_SOURCE) {\r\nomode = MCAST_EXCLUDE;\r\nadd = 0;\r\n} else if (optname == IP_ADD_SOURCE_MEMBERSHIP) {\r\nstruct ip_mreqn mreq;\r\nmreq.imr_multiaddr.s_addr = mreqs.imr_multiaddr;\r\nmreq.imr_address.s_addr = mreqs.imr_interface;\r\nmreq.imr_ifindex = 0;\r\nerr = ip_mc_join_group(sk, &mreq);\r\nif (err && err != -EADDRINUSE)\r\nbreak;\r\nomode = MCAST_INCLUDE;\r\nadd = 1;\r\n} else {\r\nomode = MCAST_INCLUDE;\r\nadd = 0;\r\n}\r\nerr = ip_mc_source(add, omode, sk, &mreqs, 0);\r\nbreak;\r\n}\r\ncase MCAST_JOIN_GROUP:\r\ncase MCAST_LEAVE_GROUP:\r\n{\r\nstruct group_req greq;\r\nstruct sockaddr_in *psin;\r\nstruct ip_mreqn mreq;\r\nif (optlen < sizeof(struct group_req))\r\ngoto e_inval;\r\nerr = -EFAULT;\r\nif (copy_from_user(&greq, optval, sizeof(greq)))\r\nbreak;\r\npsin = (struct sockaddr_in *)&greq.gr_group;\r\nif (psin->sin_family != AF_INET)\r\ngoto e_inval;\r\nmemset(&mreq, 0, sizeof(mreq));\r\nmreq.imr_multiaddr = psin->sin_addr;\r\nmreq.imr_ifindex = greq.gr_interface;\r\nif (optname == MCAST_JOIN_GROUP)\r\nerr = ip_mc_join_group(sk, &mreq);\r\nelse\r\nerr = ip_mc_leave_group(sk, &mreq);\r\nbreak;\r\n}\r\ncase MCAST_JOIN_SOURCE_GROUP:\r\ncase MCAST_LEAVE_SOURCE_GROUP:\r\ncase MCAST_BLOCK_SOURCE:\r\ncase MCAST_UNBLOCK_SOURCE:\r\n{\r\nstruct group_source_req greqs;\r\nstruct ip_mreq_source mreqs;\r\nstruct sockaddr_in *psin;\r\nint omode, add;\r\nif (optlen != sizeof(struct group_source_req))\r\ngoto e_inval;\r\nif (copy_from_user(&greqs, optval, sizeof(greqs))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (greqs.gsr_group.ss_family != AF_INET ||\r\ngreqs.gsr_source.ss_family != AF_INET) {\r\nerr = -EADDRNOTAVAIL;\r\nbreak;\r\n}\r\npsin = (struct sockaddr_in *)&greqs.gsr_group;\r\nmreqs.imr_multiaddr = psin->sin_addr.s_addr;\r\npsin = (struct sockaddr_in *)&greqs.gsr_source;\r\nmreqs.imr_sourceaddr = psin->sin_addr.s_addr;\r\nmreqs.imr_interface = 0;\r\nif (optname == MCAST_BLOCK_SOURCE) {\r\nomode = MCAST_EXCLUDE;\r\nadd = 1;\r\n} else if (optname == MCAST_UNBLOCK_SOURCE) {\r\nomode = MCAST_EXCLUDE;\r\nadd = 0;\r\n} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\r\nstruct ip_mreqn mreq;\r\npsin = (struct sockaddr_in *)&greqs.gsr_group;\r\nmreq.imr_multiaddr = psin->sin_addr;\r\nmreq.imr_address.s_addr = 0;\r\nmreq.imr_ifindex = greqs.gsr_interface;\r\nerr = ip_mc_join_group(sk, &mreq);\r\nif (err && err != -EADDRINUSE)\r\nbreak;\r\ngreqs.gsr_interface = mreq.imr_ifindex;\r\nomode = MCAST_INCLUDE;\r\nadd = 1;\r\n} else {\r\nomode = MCAST_INCLUDE;\r\nadd = 0;\r\n}\r\nerr = ip_mc_source(add, omode, sk, &mreqs,\r\ngreqs.gsr_interface);\r\nbreak;\r\n}\r\ncase MCAST_MSFILTER:\r\n{\r\nstruct sockaddr_in *psin;\r\nstruct ip_msfilter *msf = NULL;\r\nstruct group_filter *gsf = NULL;\r\nint msize, i, ifindex;\r\nif (optlen < GROUP_FILTER_SIZE(0))\r\ngoto e_inval;\r\nif (optlen > sysctl_optmem_max) {\r\nerr = -ENOBUFS;\r\nbreak;\r\n}\r\ngsf = kmalloc(optlen, GFP_KERNEL);\r\nif (!gsf) {\r\nerr = -ENOBUFS;\r\nbreak;\r\n}\r\nerr = -EFAULT;\r\nif (copy_from_user(gsf, optval, optlen))\r\ngoto mc_msf_out;\r\nif (gsf->gf_numsrc >= 0x1ffffff ||\r\ngsf->gf_numsrc > sysctl_igmp_max_msf) {\r\nerr = -ENOBUFS;\r\ngoto mc_msf_out;\r\n}\r\nif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\r\nerr = -EINVAL;\r\ngoto mc_msf_out;\r\n}\r\nmsize = IP_MSFILTER_SIZE(gsf->gf_numsrc);\r\nmsf = kmalloc(msize, GFP_KERNEL);\r\nif (!msf) {\r\nerr = -ENOBUFS;\r\ngoto mc_msf_out;\r\n}\r\nifindex = gsf->gf_interface;\r\npsin = (struct sockaddr_in *)&gsf->gf_group;\r\nif (psin->sin_family != AF_INET) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto mc_msf_out;\r\n}\r\nmsf->imsf_multiaddr = psin->sin_addr.s_addr;\r\nmsf->imsf_interface = 0;\r\nmsf->imsf_fmode = gsf->gf_fmode;\r\nmsf->imsf_numsrc = gsf->gf_numsrc;\r\nerr = -EADDRNOTAVAIL;\r\nfor (i = 0; i < gsf->gf_numsrc; ++i) {\r\npsin = (struct sockaddr_in *)&gsf->gf_slist[i];\r\nif (psin->sin_family != AF_INET)\r\ngoto mc_msf_out;\r\nmsf->imsf_slist[i] = psin->sin_addr.s_addr;\r\n}\r\nkfree(gsf);\r\ngsf = NULL;\r\nerr = ip_mc_msfilter(sk, msf, ifindex);\r\nmc_msf_out:\r\nkfree(msf);\r\nkfree(gsf);\r\nbreak;\r\n}\r\ncase IP_MULTICAST_ALL:\r\nif (optlen < 1)\r\ngoto e_inval;\r\nif (val != 0 && val != 1)\r\ngoto e_inval;\r\ninet->mc_all = val;\r\nbreak;\r\ncase IP_ROUTER_ALERT:\r\nerr = ip_ra_control(sk, val ? 1 : 0, NULL);\r\nbreak;\r\ncase IP_FREEBIND:\r\nif (optlen < 1)\r\ngoto e_inval;\r\ninet->freebind = !!val;\r\nbreak;\r\ncase IP_IPSEC_POLICY:\r\ncase IP_XFRM_POLICY:\r\nerr = -EPERM;\r\nif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\r\nbreak;\r\nerr = xfrm_user_policy(sk, optname, optval, optlen);\r\nbreak;\r\ncase IP_TRANSPARENT:\r\nif (!!val && !ns_capable(sock_net(sk)->user_ns, CAP_NET_RAW) &&\r\n!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)) {\r\nerr = -EPERM;\r\nbreak;\r\n}\r\nif (optlen < 1)\r\ngoto e_inval;\r\ninet->transparent = !!val;\r\nbreak;\r\ncase IP_MINTTL:\r\nif (optlen < 1)\r\ngoto e_inval;\r\nif (val < 0 || val > 255)\r\ngoto e_inval;\r\ninet->min_ttl = val;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\ne_inval:\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nvoid ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\r\nbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\r\nipv6_sk_rxinfo(sk);\r\nif (prepare && skb_rtable(skb)) {\r\npktinfo->ipi_ifindex = inet_iif(skb);\r\npktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\r\n} else {\r\npktinfo->ipi_ifindex = 0;\r\npktinfo->ipi_spec_dst.s_addr = 0;\r\n}\r\nskb_dst_drop(skb);\r\n}\r\nint ip_setsockopt(struct sock *sk, int level,\r\nint optname, char __user *optval, unsigned int optlen)\r\n{\r\nint err;\r\nif (level != SOL_IP)\r\nreturn -ENOPROTOOPT;\r\nerr = do_ip_setsockopt(sk, level, optname, optval, optlen);\r\n#ifdef CONFIG_NETFILTER\r\nif (err == -ENOPROTOOPT && optname != IP_HDRINCL &&\r\noptname != IP_IPSEC_POLICY &&\r\noptname != IP_XFRM_POLICY &&\r\n!ip_mroute_opt(optname)) {\r\nlock_sock(sk);\r\nerr = nf_setsockopt(sk, PF_INET, optname, optval, optlen);\r\nrelease_sock(sk);\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nint compat_ip_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nint err;\r\nif (level != SOL_IP)\r\nreturn -ENOPROTOOPT;\r\nif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\r\nreturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\r\nip_setsockopt);\r\nerr = do_ip_setsockopt(sk, level, optname, optval, optlen);\r\n#ifdef CONFIG_NETFILTER\r\nif (err == -ENOPROTOOPT && optname != IP_HDRINCL &&\r\noptname != IP_IPSEC_POLICY &&\r\noptname != IP_XFRM_POLICY &&\r\n!ip_mroute_opt(optname)) {\r\nlock_sock(sk);\r\nerr = compat_nf_setsockopt(sk, PF_INET, optname,\r\noptval, optlen);\r\nrelease_sock(sk);\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nstatic int do_ip_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen, unsigned int flags)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nint val;\r\nint len;\r\nif (level != SOL_IP)\r\nreturn -EOPNOTSUPP;\r\nif (ip_mroute_opt(optname))\r\nreturn ip_mroute_getsockopt(sk, optname, optval, optlen);\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nif (len < 0)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase IP_OPTIONS:\r\n{\r\nunsigned char optbuf[sizeof(struct ip_options)+40];\r\nstruct ip_options *opt = (struct ip_options *)optbuf;\r\nstruct ip_options_rcu *inet_opt;\r\ninet_opt = rcu_dereference_protected(inet->inet_opt,\r\nsock_owned_by_user(sk));\r\nopt->optlen = 0;\r\nif (inet_opt)\r\nmemcpy(optbuf, &inet_opt->opt,\r\nsizeof(struct ip_options) +\r\ninet_opt->opt.optlen);\r\nrelease_sock(sk);\r\nif (opt->optlen == 0)\r\nreturn put_user(0, optlen);\r\nip_options_undo(opt);\r\nlen = min_t(unsigned int, len, opt->optlen);\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nif (copy_to_user(optval, opt->__data, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase IP_PKTINFO:\r\nval = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0;\r\nbreak;\r\ncase IP_RECVTTL:\r\nval = (inet->cmsg_flags & IP_CMSG_TTL) != 0;\r\nbreak;\r\ncase IP_RECVTOS:\r\nval = (inet->cmsg_flags & IP_CMSG_TOS) != 0;\r\nbreak;\r\ncase IP_RECVOPTS:\r\nval = (inet->cmsg_flags & IP_CMSG_RECVOPTS) != 0;\r\nbreak;\r\ncase IP_RETOPTS:\r\nval = (inet->cmsg_flags & IP_CMSG_RETOPTS) != 0;\r\nbreak;\r\ncase IP_PASSSEC:\r\nval = (inet->cmsg_flags & IP_CMSG_PASSSEC) != 0;\r\nbreak;\r\ncase IP_RECVORIGDSTADDR:\r\nval = (inet->cmsg_flags & IP_CMSG_ORIGDSTADDR) != 0;\r\nbreak;\r\ncase IP_TOS:\r\nval = inet->tos;\r\nbreak;\r\ncase IP_TTL:\r\nval = (inet->uc_ttl == -1 ?\r\nsysctl_ip_default_ttl :\r\ninet->uc_ttl);\r\nbreak;\r\ncase IP_HDRINCL:\r\nval = inet->hdrincl;\r\nbreak;\r\ncase IP_NODEFRAG:\r\nval = inet->nodefrag;\r\nbreak;\r\ncase IP_MTU_DISCOVER:\r\nval = inet->pmtudisc;\r\nbreak;\r\ncase IP_MTU:\r\n{\r\nstruct dst_entry *dst;\r\nval = 0;\r\ndst = sk_dst_get(sk);\r\nif (dst) {\r\nval = dst_mtu(dst);\r\ndst_release(dst);\r\n}\r\nif (!val) {\r\nrelease_sock(sk);\r\nreturn -ENOTCONN;\r\n}\r\nbreak;\r\n}\r\ncase IP_RECVERR:\r\nval = inet->recverr;\r\nbreak;\r\ncase IP_MULTICAST_TTL:\r\nval = inet->mc_ttl;\r\nbreak;\r\ncase IP_MULTICAST_LOOP:\r\nval = inet->mc_loop;\r\nbreak;\r\ncase IP_UNICAST_IF:\r\nval = (__force int)htonl((__u32) inet->uc_index);\r\nbreak;\r\ncase IP_MULTICAST_IF:\r\n{\r\nstruct in_addr addr;\r\nlen = min_t(unsigned int, len, sizeof(struct in_addr));\r\naddr.s_addr = inet->mc_addr;\r\nrelease_sock(sk);\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nif (copy_to_user(optval, &addr, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase IP_MSFILTER:\r\n{\r\nstruct ip_msfilter msf;\r\nint err;\r\nif (len < IP_MSFILTER_SIZE(0)) {\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&msf, optval, IP_MSFILTER_SIZE(0))) {\r\nrelease_sock(sk);\r\nreturn -EFAULT;\r\n}\r\nerr = ip_mc_msfget(sk, &msf,\r\n(struct ip_msfilter __user *)optval, optlen);\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\ncase MCAST_MSFILTER:\r\n{\r\nstruct group_filter gsf;\r\nint err;\r\nif (len < GROUP_FILTER_SIZE(0)) {\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0))) {\r\nrelease_sock(sk);\r\nreturn -EFAULT;\r\n}\r\nerr = ip_mc_gsfget(sk, &gsf,\r\n(struct group_filter __user *)optval,\r\noptlen);\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\ncase IP_MULTICAST_ALL:\r\nval = inet->mc_all;\r\nbreak;\r\ncase IP_PKTOPTIONS:\r\n{\r\nstruct msghdr msg;\r\nrelease_sock(sk);\r\nif (sk->sk_type != SOCK_STREAM)\r\nreturn -ENOPROTOOPT;\r\nmsg.msg_control = optval;\r\nmsg.msg_controllen = len;\r\nmsg.msg_flags = flags;\r\nif (inet->cmsg_flags & IP_CMSG_PKTINFO) {\r\nstruct in_pktinfo info;\r\ninfo.ipi_addr.s_addr = inet->inet_rcv_saddr;\r\ninfo.ipi_spec_dst.s_addr = inet->inet_rcv_saddr;\r\ninfo.ipi_ifindex = inet->mc_index;\r\nput_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\r\n}\r\nif (inet->cmsg_flags & IP_CMSG_TTL) {\r\nint hlim = inet->mc_ttl;\r\nput_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim);\r\n}\r\nif (inet->cmsg_flags & IP_CMSG_TOS) {\r\nint tos = inet->rcv_tos;\r\nput_cmsg(&msg, SOL_IP, IP_TOS, sizeof(tos), &tos);\r\n}\r\nlen -= msg.msg_controllen;\r\nreturn put_user(len, optlen);\r\n}\r\ncase IP_FREEBIND:\r\nval = inet->freebind;\r\nbreak;\r\ncase IP_TRANSPARENT:\r\nval = inet->transparent;\r\nbreak;\r\ncase IP_MINTTL:\r\nval = inet->min_ttl;\r\nbreak;\r\ndefault:\r\nrelease_sock(sk);\r\nreturn -ENOPROTOOPT;\r\n}\r\nrelease_sock(sk);\r\nif (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) {\r\nunsigned char ucval = (unsigned char)val;\r\nlen = 1;\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nif (copy_to_user(optval, &ucval, 1))\r\nreturn -EFAULT;\r\n} else {\r\nlen = min_t(unsigned int, sizeof(int), len);\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nif (copy_to_user(optval, &val, len))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint ip_getsockopt(struct sock *sk, int level,\r\nint optname, char __user *optval, int __user *optlen)\r\n{\r\nint err;\r\nerr = do_ip_getsockopt(sk, level, optname, optval, optlen, 0);\r\n#ifdef CONFIG_NETFILTER\r\nif (err == -ENOPROTOOPT && optname != IP_PKTOPTIONS &&\r\n!ip_mroute_opt(optname)) {\r\nint len;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nerr = nf_getsockopt(sk, PF_INET, optname, optval,\r\n&len);\r\nrelease_sock(sk);\r\nif (err >= 0)\r\nerr = put_user(len, optlen);\r\nreturn err;\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nint compat_ip_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nint err;\r\nif (optname == MCAST_MSFILTER)\r\nreturn compat_mc_getsockopt(sk, level, optname, optval, optlen,\r\nip_getsockopt);\r\nerr = do_ip_getsockopt(sk, level, optname, optval, optlen,\r\nMSG_CMSG_COMPAT);\r\n#ifdef CONFIG_NETFILTER\r\nif (err == -ENOPROTOOPT && optname != IP_PKTOPTIONS &&\r\n!ip_mroute_opt(optname)) {\r\nint len;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nerr = compat_nf_getsockopt(sk, PF_INET, optname, optval, &len);\r\nrelease_sock(sk);\r\nif (err >= 0)\r\nerr = put_user(len, optlen);\r\nreturn err;\r\n}\r\n#endif\r\nreturn err;\r\n}
