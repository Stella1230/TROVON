static int\r\nprocess_line(struct conf_writedata *cnf)\r\n{\r\nunsigned char *cp = cnf->conf_line;\r\nint i;\r\nif (cnf->card->debug_flags & LOG_CNF_LINE)\r\nhysdn_addlog(cnf->card, "conf line: %s", cp);\r\nif (*cp == '-') {\r\ncp++;\r\nif (*cp++ != 'c')\r\nreturn (0);\r\ni = 0;\r\nwhile ((*cp <= '9') && (*cp >= '0'))\r\ni = i * 10 + *cp++ - '0';\r\nif (i > 65535) {\r\nif (cnf->card->debug_flags & LOG_CNF_MISC)\r\nhysdn_addlog(cnf->card, "conf channel invalid %d", i);\r\nreturn (-ERR_INV_CHAN);\r\n}\r\ncnf->channel = i & 0xFFFF;\r\nreturn (0);\r\n}\r\nif (*cp == '*') {\r\nif (cnf->card->debug_flags & LOG_CNF_DATA)\r\nhysdn_addlog(cnf->card, "conf chan=%d %s", cnf->channel, cp);\r\nreturn (hysdn_tx_cfgline(cnf->card, cnf->conf_line + 1,\r\ncnf->channel));\r\n}\r\nreturn (0);\r\n}\r\nstatic ssize_t\r\nhysdn_conf_write(struct file *file, const char __user *buf, size_t count, loff_t *off)\r\n{\r\nstruct conf_writedata *cnf;\r\nint i;\r\nunsigned char ch, *cp;\r\nif (!count)\r\nreturn (0);\r\nif (!(cnf = file->private_data))\r\nreturn (-EFAULT);\r\nif (cnf->state == CONF_STATE_DETECT) {\r\nif (copy_from_user(&ch, buf, 1))\r\nreturn (-EFAULT);\r\nif (ch == 0x1A) {\r\nif ((cnf->needed_size = pof_write_open(cnf->card, &cnf->pof_buffer)) <= 0)\r\nreturn (cnf->needed_size);\r\ncnf->buf_size = 0;\r\ncnf->state = CONF_STATE_POF;\r\n} else {\r\ncnf->buf_size = 0;\r\ncnf->state = CONF_STATE_CONF;\r\nif (cnf->card->state != CARD_STATE_RUN)\r\nreturn (-ERR_NOT_BOOTED);\r\ncnf->conf_line[CONF_LINE_LEN - 1] = 0;\r\ncnf->channel = 4098;\r\n}\r\n}\r\nif (cnf->state == CONF_STATE_POF) {\r\ni = cnf->needed_size - cnf->buf_size;\r\nif (i <= 0)\r\nreturn (-EINVAL);\r\nif (i < count)\r\ncount = i;\r\nif (copy_from_user(cnf->pof_buffer + cnf->buf_size, buf, count))\r\nreturn (-EFAULT);\r\ncnf->buf_size += count;\r\nif (cnf->needed_size == cnf->buf_size) {\r\ncnf->needed_size = pof_write_buffer(cnf->card, cnf->buf_size);\r\nif (cnf->needed_size <= 0) {\r\ncnf->card->state = CARD_STATE_BOOTERR;\r\nreturn (cnf->needed_size);\r\n}\r\ncnf->buf_size = 0;\r\n}\r\n}\r\nelse {\r\nif (cnf->card->state != CARD_STATE_RUN) {\r\nif (cnf->card->debug_flags & LOG_CNF_MISC)\r\nhysdn_addlog(cnf->card, "cnf write denied -> not booted");\r\nreturn (-ERR_NOT_BOOTED);\r\n}\r\ni = (CONF_LINE_LEN - 1) - cnf->buf_size;\r\nif (i > 0) {\r\nif (count > i)\r\ncount = i;\r\nif (copy_from_user(cnf->conf_line + cnf->buf_size, buf, count))\r\nreturn (-EFAULT);\r\ni = count;\r\ncp = cnf->conf_line + cnf->buf_size;\r\nwhile (i) {\r\nif ((*cp < ' ') && (*cp != 9))\r\nbreak;\r\ncp++;\r\ni--;\r\n}\r\nif (i) {\r\n*cp++ = 0;\r\ncount -= (i - 1);\r\nwhile ((i) && (*cp < ' ') && (*cp != 9)) {\r\ni--;\r\ncount++;\r\ncp++;\r\n}\r\ncnf->buf_size = 0;\r\nif ((i = process_line(cnf)) < 0)\r\ncount = i;\r\n}\r\nelse {\r\ncnf->buf_size += count;\r\nif (cnf->buf_size >= CONF_LINE_LEN - 1) {\r\nif (cnf->card->debug_flags & LOG_CNF_MISC)\r\nhysdn_addlog(cnf->card, "cnf line too long %d chars pos %d", cnf->buf_size, count);\r\nreturn (-ERR_CONF_LONG);\r\n}\r\n}\r\n}\r\nelse {\r\nif (cnf->card->debug_flags & LOG_CNF_MISC)\r\nhysdn_addlog(cnf->card, "cnf line too long");\r\nreturn (-ERR_CONF_LONG);\r\n}\r\n}\r\nreturn (count);\r\n}\r\nstatic ssize_t\r\nhysdn_conf_read(struct file *file, char __user *buf, size_t count, loff_t *off)\r\n{\r\nchar *cp;\r\nif (!(file->f_mode & FMODE_READ))\r\nreturn -EPERM;\r\nif (!(cp = file->private_data))\r\nreturn -EFAULT;\r\nreturn simple_read_from_buffer(buf, count, off, cp, strlen(cp));\r\n}\r\nstatic int\r\nhysdn_conf_open(struct inode *ino, struct file *filep)\r\n{\r\nhysdn_card *card;\r\nstruct conf_writedata *cnf;\r\nchar *cp, *tmp;\r\nmutex_lock(&hysdn_conf_mutex);\r\ncard = PDE_DATA(ino);\r\nif (card->debug_flags & (LOG_PROC_OPEN | LOG_PROC_ALL))\r\nhysdn_addlog(card, "config open for uid=%d gid=%d mode=0x%x",\r\nfilep->f_cred->fsuid, filep->f_cred->fsgid,\r\nfilep->f_mode);\r\nif ((filep->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_WRITE) {\r\nif (!(cnf = kmalloc(sizeof(struct conf_writedata), GFP_KERNEL))) {\r\nmutex_unlock(&hysdn_conf_mutex);\r\nreturn (-EFAULT);\r\n}\r\ncnf->card = card;\r\ncnf->buf_size = 0;\r\ncnf->state = CONF_STATE_DETECT;\r\nfilep->private_data = cnf;\r\n} else if ((filep->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ) {\r\nif (!(tmp = kmalloc(INFO_OUT_LEN * 2 + 2, GFP_KERNEL))) {\r\nmutex_unlock(&hysdn_conf_mutex);\r\nreturn (-EFAULT);\r\n}\r\nfilep->private_data = tmp;\r\nsprintf(tmp, "id bus slot type irq iobase dp-mem b-chans fax-chans state device");\r\ncp = tmp;\r\nwhile (*cp)\r\ncp++;\r\nwhile (((cp - tmp) % (INFO_OUT_LEN + 1)) != INFO_OUT_LEN)\r\n*cp++ = ' ';\r\n*cp++ = '\n';\r\nsprintf(cp, "%d %3d %4d %4d %3d 0x%04x 0x%08lx %7d %9d %3d %s",\r\ncard->myid,\r\ncard->bus,\r\nPCI_SLOT(card->devfn),\r\ncard->brdtype,\r\ncard->irq,\r\ncard->iobase,\r\ncard->membase,\r\ncard->bchans,\r\ncard->faxchans,\r\ncard->state,\r\nhysdn_net_getname(card));\r\nwhile (*cp)\r\ncp++;\r\nwhile (((cp - tmp) % (INFO_OUT_LEN + 1)) != INFO_OUT_LEN)\r\n*cp++ = ' ';\r\n*cp++ = '\n';\r\n*cp = 0;\r\n} else {\r\nmutex_unlock(&hysdn_conf_mutex);\r\nreturn (-EPERM);\r\n}\r\nmutex_unlock(&hysdn_conf_mutex);\r\nreturn nonseekable_open(ino, filep);\r\n}\r\nstatic int\r\nhysdn_conf_close(struct inode *ino, struct file *filep)\r\n{\r\nhysdn_card *card;\r\nstruct conf_writedata *cnf;\r\nint retval = 0;\r\nmutex_lock(&hysdn_conf_mutex);\r\ncard = PDE_DATA(ino);\r\nif (card->debug_flags & (LOG_PROC_OPEN | LOG_PROC_ALL))\r\nhysdn_addlog(card, "config close for uid=%d gid=%d mode=0x%x",\r\nfilep->f_cred->fsuid, filep->f_cred->fsgid,\r\nfilep->f_mode);\r\nif ((filep->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_WRITE) {\r\nif (filep->private_data) {\r\ncnf = filep->private_data;\r\nif (cnf->state == CONF_STATE_POF)\r\nretval = pof_write_close(cnf->card);\r\nkfree(filep->private_data);\r\n}\r\n} else if ((filep->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ) {\r\nkfree(filep->private_data);\r\n}\r\nmutex_unlock(&hysdn_conf_mutex);\r\nreturn (retval);\r\n}\r\nint\r\nhysdn_procconf_init(void)\r\n{\r\nhysdn_card *card;\r\nunsigned char conf_name[20];\r\nhysdn_proc_entry = proc_mkdir(PROC_SUBDIR_NAME, init_net.proc_net);\r\nif (!hysdn_proc_entry) {\r\nprintk(KERN_ERR "HYSDN: unable to create hysdn subdir\n");\r\nreturn (-1);\r\n}\r\ncard = card_root;\r\nwhile (card) {\r\nsprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);\r\nif ((card->procconf = (void *) proc_create_data(conf_name,\r\nS_IFREG | S_IRUGO | S_IWUSR,\r\nhysdn_proc_entry,\r\n&conf_fops,\r\ncard)) != NULL) {\r\nhysdn_proclog_init(card);\r\n}\r\ncard = card->next;\r\n}\r\nprintk(KERN_NOTICE "HYSDN: procfs initialised\n");\r\nreturn (0);\r\n}\r\nvoid\r\nhysdn_procconf_release(void)\r\n{\r\nhysdn_card *card;\r\nunsigned char conf_name[20];\r\ncard = card_root;\r\nwhile (card) {\r\nsprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);\r\nif (card->procconf)\r\nremove_proc_entry(conf_name, hysdn_proc_entry);\r\nhysdn_proclog_release(card);\r\ncard = card->next;\r\n}\r\nremove_proc_entry(PROC_SUBDIR_NAME, init_net.proc_net);\r\n}
