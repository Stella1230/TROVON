static inline int bq27x00_read(struct bq27x00_device_info *di, u8 reg,\r\nbool single)\r\n{\r\nif (di->chip == BQ27425)\r\nreturn di->bus.read(di, reg - BQ27425_REG_OFFSET, single);\r\nreturn di->bus.read(di, reg, single);\r\n}\r\nstatic bool bq27xxx_is_chip_version_higher(struct bq27x00_device_info *di)\r\n{\r\nif (di->chip == BQ27425 || di->chip == BQ27500)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int bq27x00_battery_read_rsoc(struct bq27x00_device_info *di)\r\n{\r\nint rsoc;\r\nif (di->chip == BQ27500)\r\nrsoc = bq27x00_read(di, BQ27500_REG_SOC, false);\r\nelse if (di->chip == BQ27425)\r\nrsoc = bq27x00_read(di, BQ27425_REG_SOC, false);\r\nelse\r\nrsoc = bq27x00_read(di, BQ27000_REG_RSOC, true);\r\nif (rsoc < 0)\r\ndev_dbg(di->dev, "error reading relative State-of-Charge\n");\r\nreturn rsoc;\r\n}\r\nstatic int bq27x00_battery_read_charge(struct bq27x00_device_info *di, u8 reg)\r\n{\r\nint charge;\r\ncharge = bq27x00_read(di, reg, false);\r\nif (charge < 0) {\r\ndev_dbg(di->dev, "error reading charge register %02x: %d\n",\r\nreg, charge);\r\nreturn charge;\r\n}\r\nif (bq27xxx_is_chip_version_higher(di))\r\ncharge *= 1000;\r\nelse\r\ncharge = charge * 3570 / BQ27000_RS;\r\nreturn charge;\r\n}\r\nstatic inline int bq27x00_battery_read_nac(struct bq27x00_device_info *di)\r\n{\r\nint flags;\r\nbool is_bq27500 = di->chip == BQ27500;\r\nbool is_higher = bq27xxx_is_chip_version_higher(di);\r\nflags = bq27x00_read(di, BQ27x00_REG_FLAGS, !is_bq27500);\r\nif (flags >= 0 && !is_higher && (flags & BQ27000_FLAG_CI))\r\nreturn -ENODATA;\r\nreturn bq27x00_battery_read_charge(di, BQ27x00_REG_NAC);\r\n}\r\nstatic inline int bq27x00_battery_read_lmd(struct bq27x00_device_info *di)\r\n{\r\nreturn bq27x00_battery_read_charge(di, BQ27x00_REG_LMD);\r\n}\r\nstatic int bq27x00_battery_read_ilmd(struct bq27x00_device_info *di)\r\n{\r\nint ilmd;\r\nif (bq27xxx_is_chip_version_higher(di))\r\nilmd = bq27x00_read(di, BQ27500_REG_DCAP, false);\r\nelse\r\nilmd = bq27x00_read(di, BQ27000_REG_ILMD, true);\r\nif (ilmd < 0) {\r\ndev_dbg(di->dev, "error reading initial last measured discharge\n");\r\nreturn ilmd;\r\n}\r\nif (bq27xxx_is_chip_version_higher(di))\r\nilmd *= 1000;\r\nelse\r\nilmd = ilmd * 256 * 3570 / BQ27000_RS;\r\nreturn ilmd;\r\n}\r\nstatic int bq27x00_battery_read_energy(struct bq27x00_device_info *di)\r\n{\r\nint ae;\r\nae = bq27x00_read(di, BQ27x00_REG_AE, false);\r\nif (ae < 0) {\r\ndev_dbg(di->dev, "error reading available energy\n");\r\nreturn ae;\r\n}\r\nif (di->chip == BQ27500)\r\nae *= 1000;\r\nelse\r\nae = ae * 29200 / BQ27000_RS;\r\nreturn ae;\r\n}\r\nstatic int bq27x00_battery_read_temperature(struct bq27x00_device_info *di)\r\n{\r\nint temp;\r\ntemp = bq27x00_read(di, BQ27x00_REG_TEMP, false);\r\nif (temp < 0) {\r\ndev_err(di->dev, "error reading temperature\n");\r\nreturn temp;\r\n}\r\nif (!bq27xxx_is_chip_version_higher(di))\r\ntemp = 5 * temp / 2;\r\nreturn temp;\r\n}\r\nstatic int bq27x00_battery_read_cyct(struct bq27x00_device_info *di)\r\n{\r\nint cyct;\r\ncyct = bq27x00_read(di, BQ27x00_REG_CYCT, false);\r\nif (cyct < 0)\r\ndev_err(di->dev, "error reading cycle count total\n");\r\nreturn cyct;\r\n}\r\nstatic int bq27x00_battery_read_time(struct bq27x00_device_info *di, u8 reg)\r\n{\r\nint tval;\r\ntval = bq27x00_read(di, reg, false);\r\nif (tval < 0) {\r\ndev_dbg(di->dev, "error reading time register %02x: %d\n",\r\nreg, tval);\r\nreturn tval;\r\n}\r\nif (tval == 65535)\r\nreturn -ENODATA;\r\nreturn tval * 60;\r\n}\r\nstatic int bq27x00_battery_read_pwr_avg(struct bq27x00_device_info *di, u8 reg)\r\n{\r\nint tval;\r\ntval = bq27x00_read(di, reg, false);\r\nif (tval < 0) {\r\ndev_err(di->dev, "error reading power avg rgister %02x: %d\n",\r\nreg, tval);\r\nreturn tval;\r\n}\r\nif (di->chip == BQ27500)\r\nreturn tval;\r\nelse\r\nreturn (tval * BQ27x00_POWER_CONSTANT) / BQ27000_RS;\r\n}\r\nstatic int bq27x00_battery_read_health(struct bq27x00_device_info *di)\r\n{\r\nint tval;\r\ntval = bq27x00_read(di, BQ27x00_REG_FLAGS, false);\r\nif (tval < 0) {\r\ndev_err(di->dev, "error reading flag register:%d\n", tval);\r\nreturn tval;\r\n}\r\nif ((di->chip == BQ27500)) {\r\nif (tval & BQ27500_FLAG_SOCF)\r\ntval = POWER_SUPPLY_HEALTH_DEAD;\r\nelse if (tval & BQ27500_FLAG_OTC)\r\ntval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse\r\ntval = POWER_SUPPLY_HEALTH_GOOD;\r\nreturn tval;\r\n} else {\r\nif (tval & BQ27000_FLAG_EDV1)\r\ntval = POWER_SUPPLY_HEALTH_DEAD;\r\nelse\r\ntval = POWER_SUPPLY_HEALTH_GOOD;\r\nreturn tval;\r\n}\r\nreturn -1;\r\n}\r\nstatic void bq27x00_update(struct bq27x00_device_info *di)\r\n{\r\nstruct bq27x00_reg_cache cache = {0, };\r\nbool is_bq27500 = di->chip == BQ27500;\r\nbool is_bq27425 = di->chip == BQ27425;\r\ncache.flags = bq27x00_read(di, BQ27x00_REG_FLAGS, !is_bq27500);\r\nif (cache.flags >= 0) {\r\nif (!is_bq27500 && !is_bq27425\r\n&& (cache.flags & BQ27000_FLAG_CI)) {\r\ndev_info(di->dev, "battery is not calibrated! ignoring capacity values\n");\r\ncache.capacity = -ENODATA;\r\ncache.energy = -ENODATA;\r\ncache.time_to_empty = -ENODATA;\r\ncache.time_to_empty_avg = -ENODATA;\r\ncache.time_to_full = -ENODATA;\r\ncache.charge_full = -ENODATA;\r\ncache.health = -ENODATA;\r\n} else {\r\ncache.capacity = bq27x00_battery_read_rsoc(di);\r\nif (!is_bq27425) {\r\ncache.energy = bq27x00_battery_read_energy(di);\r\ncache.time_to_empty =\r\nbq27x00_battery_read_time(di,\r\nBQ27x00_REG_TTE);\r\ncache.time_to_empty_avg =\r\nbq27x00_battery_read_time(di,\r\nBQ27x00_REG_TTECP);\r\ncache.time_to_full =\r\nbq27x00_battery_read_time(di,\r\nBQ27x00_REG_TTF);\r\n}\r\ncache.charge_full = bq27x00_battery_read_lmd(di);\r\ncache.health = bq27x00_battery_read_health(di);\r\n}\r\ncache.temperature = bq27x00_battery_read_temperature(di);\r\nif (!is_bq27425)\r\ncache.cycle_count = bq27x00_battery_read_cyct(di);\r\ncache.power_avg =\r\nbq27x00_battery_read_pwr_avg(di, BQ27x00_POWER_AVG);\r\nif (di->charge_design_full <= 0)\r\ndi->charge_design_full = bq27x00_battery_read_ilmd(di);\r\n}\r\nif (memcmp(&di->cache, &cache, sizeof(cache)) != 0) {\r\ndi->cache = cache;\r\npower_supply_changed(&di->bat);\r\n}\r\ndi->last_update = jiffies;\r\n}\r\nstatic void bq27x00_battery_poll(struct work_struct *work)\r\n{\r\nstruct bq27x00_device_info *di =\r\ncontainer_of(work, struct bq27x00_device_info, work.work);\r\nbq27x00_update(di);\r\nif (poll_interval > 0) {\r\nset_timer_slack(&di->work.timer, poll_interval * HZ / 4);\r\nschedule_delayed_work(&di->work, poll_interval * HZ);\r\n}\r\n}\r\nstatic int bq27x00_battery_current(struct bq27x00_device_info *di,\r\nunion power_supply_propval *val)\r\n{\r\nint curr;\r\nint flags;\r\ncurr = bq27x00_read(di, BQ27x00_REG_AI, false);\r\nif (curr < 0) {\r\ndev_err(di->dev, "error reading current\n");\r\nreturn curr;\r\n}\r\nif (bq27xxx_is_chip_version_higher(di)) {\r\nval->intval = (int)((s16)curr) * 1000;\r\n} else {\r\nflags = bq27x00_read(di, BQ27x00_REG_FLAGS, false);\r\nif (flags & BQ27000_FLAG_CHGS) {\r\ndev_dbg(di->dev, "negative current!\n");\r\ncurr = -curr;\r\n}\r\nval->intval = curr * 3570 / BQ27000_RS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq27x00_battery_status(struct bq27x00_device_info *di,\r\nunion power_supply_propval *val)\r\n{\r\nint status;\r\nif (bq27xxx_is_chip_version_higher(di)) {\r\nif (di->cache.flags & BQ27500_FLAG_FC)\r\nstatus = POWER_SUPPLY_STATUS_FULL;\r\nelse if (di->cache.flags & BQ27500_FLAG_DSC)\r\nstatus = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse\r\nstatus = POWER_SUPPLY_STATUS_CHARGING;\r\n} else {\r\nif (di->cache.flags & BQ27000_FLAG_FC)\r\nstatus = POWER_SUPPLY_STATUS_FULL;\r\nelse if (di->cache.flags & BQ27000_FLAG_CHGS)\r\nstatus = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (power_supply_am_i_supplied(&di->bat))\r\nstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse\r\nstatus = POWER_SUPPLY_STATUS_DISCHARGING;\r\n}\r\nval->intval = status;\r\nreturn 0;\r\n}\r\nstatic int bq27x00_battery_capacity_level(struct bq27x00_device_info *di,\r\nunion power_supply_propval *val)\r\n{\r\nint level;\r\nif (bq27xxx_is_chip_version_higher(di)) {\r\nif (di->cache.flags & BQ27500_FLAG_FC)\r\nlevel = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\r\nelse if (di->cache.flags & BQ27500_FLAG_SOC1)\r\nlevel = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\r\nelse if (di->cache.flags & BQ27500_FLAG_SOCF)\r\nlevel = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\r\nelse\r\nlevel = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\r\n} else {\r\nif (di->cache.flags & BQ27000_FLAG_FC)\r\nlevel = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\r\nelse if (di->cache.flags & BQ27000_FLAG_EDV1)\r\nlevel = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\r\nelse if (di->cache.flags & BQ27000_FLAG_EDVF)\r\nlevel = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\r\nelse\r\nlevel = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\r\n}\r\nval->intval = level;\r\nreturn 0;\r\n}\r\nstatic int bq27x00_battery_voltage(struct bq27x00_device_info *di,\r\nunion power_supply_propval *val)\r\n{\r\nint volt;\r\nvolt = bq27x00_read(di, BQ27x00_REG_VOLT, false);\r\nif (volt < 0) {\r\ndev_err(di->dev, "error reading voltage\n");\r\nreturn volt;\r\n}\r\nval->intval = volt * 1000;\r\nreturn 0;\r\n}\r\nstatic int bq27x00_simple_value(int value,\r\nunion power_supply_propval *val)\r\n{\r\nif (value < 0)\r\nreturn value;\r\nval->intval = value;\r\nreturn 0;\r\n}\r\nstatic int bq27x00_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nint ret = 0;\r\nstruct bq27x00_device_info *di = to_bq27x00_device_info(psy);\r\nmutex_lock(&di->lock);\r\nif (time_is_before_jiffies(di->last_update + 5 * HZ)) {\r\ncancel_delayed_work_sync(&di->work);\r\nbq27x00_battery_poll(&di->work.work);\r\n}\r\nmutex_unlock(&di->lock);\r\nif (psp != POWER_SUPPLY_PROP_PRESENT && di->cache.flags < 0)\r\nreturn -ENODEV;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nret = bq27x00_battery_status(di, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = bq27x00_battery_voltage(di, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = di->cache.flags < 0 ? 0 : 1;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nret = bq27x00_battery_current(di, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = bq27x00_simple_value(di->cache.capacity, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\r\nret = bq27x00_battery_capacity_level(di, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nret = bq27x00_simple_value(di->cache.temperature, val);\r\nif (ret == 0)\r\nval->intval -= 2731;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\r\nret = bq27x00_simple_value(di->cache.time_to_empty, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\r\nret = bq27x00_simple_value(di->cache.time_to_empty_avg, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:\r\nret = bq27x00_simple_value(di->cache.time_to_full, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nret = bq27x00_simple_value(bq27x00_battery_read_nac(di), val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nret = bq27x00_simple_value(di->cache.charge_full, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nret = bq27x00_simple_value(di->charge_design_full, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CYCLE_COUNT:\r\nret = bq27x00_simple_value(di->cache.cycle_count, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\nret = bq27x00_simple_value(di->cache.energy, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_POWER_AVG:\r\nret = bq27x00_simple_value(di->cache.power_avg, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nret = bq27x00_simple_value(di->cache.health, val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void bq27x00_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct bq27x00_device_info *di = to_bq27x00_device_info(psy);\r\ncancel_delayed_work_sync(&di->work);\r\nschedule_delayed_work(&di->work, 0);\r\n}\r\nstatic int bq27x00_powersupply_init(struct bq27x00_device_info *di)\r\n{\r\nint ret;\r\ndi->bat.type = POWER_SUPPLY_TYPE_BATTERY;\r\nif (di->chip == BQ27425) {\r\ndi->bat.properties = bq27425_battery_props;\r\ndi->bat.num_properties = ARRAY_SIZE(bq27425_battery_props);\r\n} else {\r\ndi->bat.properties = bq27x00_battery_props;\r\ndi->bat.num_properties = ARRAY_SIZE(bq27x00_battery_props);\r\n}\r\ndi->bat.get_property = bq27x00_battery_get_property;\r\ndi->bat.external_power_changed = bq27x00_external_power_changed;\r\nINIT_DELAYED_WORK(&di->work, bq27x00_battery_poll);\r\nmutex_init(&di->lock);\r\nret = power_supply_register(di->dev, &di->bat);\r\nif (ret) {\r\ndev_err(di->dev, "failed to register battery: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_info(di->dev, "support ver. %s enabled\n", DRIVER_VERSION);\r\nbq27x00_update(di);\r\nreturn 0;\r\n}\r\nstatic void bq27x00_powersupply_unregister(struct bq27x00_device_info *di)\r\n{\r\npoll_interval = 0;\r\ncancel_delayed_work_sync(&di->work);\r\npower_supply_unregister(&di->bat);\r\nmutex_destroy(&di->lock);\r\n}\r\nstatic int bq27x00_read_i2c(struct bq27x00_device_info *di, u8 reg, bool single)\r\n{\r\nstruct i2c_client *client = to_i2c_client(di->dev);\r\nstruct i2c_msg msg[2];\r\nunsigned char data[2];\r\nint ret;\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].buf = &reg;\r\nmsg[0].len = sizeof(reg);\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = data;\r\nif (single)\r\nmsg[1].len = 1;\r\nelse\r\nmsg[1].len = 2;\r\nret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\r\nif (ret < 0)\r\nreturn ret;\r\nif (!single)\r\nret = get_unaligned_le16(data);\r\nelse\r\nret = data[0];\r\nreturn ret;\r\n}\r\nstatic int bq27x00_battery_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nchar *name;\r\nstruct bq27x00_device_info *di;\r\nint num;\r\nint retval = 0;\r\nmutex_lock(&battery_mutex);\r\nnum = idr_alloc(&battery_id, client, 0, 0, GFP_KERNEL);\r\nmutex_unlock(&battery_mutex);\r\nif (num < 0)\r\nreturn num;\r\nname = kasprintf(GFP_KERNEL, "%s-%d", id->name, num);\r\nif (!name) {\r\ndev_err(&client->dev, "failed to allocate device name\n");\r\nretval = -ENOMEM;\r\ngoto batt_failed_1;\r\n}\r\ndi = kzalloc(sizeof(*di), GFP_KERNEL);\r\nif (!di) {\r\ndev_err(&client->dev, "failed to allocate device info data\n");\r\nretval = -ENOMEM;\r\ngoto batt_failed_2;\r\n}\r\ndi->id = num;\r\ndi->dev = &client->dev;\r\ndi->chip = id->driver_data;\r\ndi->bat.name = name;\r\ndi->bus.read = &bq27x00_read_i2c;\r\nretval = bq27x00_powersupply_init(di);\r\nif (retval)\r\ngoto batt_failed_3;\r\ni2c_set_clientdata(client, di);\r\nreturn 0;\r\nbatt_failed_3:\r\nkfree(di);\r\nbatt_failed_2:\r\nkfree(name);\r\nbatt_failed_1:\r\nmutex_lock(&battery_mutex);\r\nidr_remove(&battery_id, num);\r\nmutex_unlock(&battery_mutex);\r\nreturn retval;\r\n}\r\nstatic int bq27x00_battery_remove(struct i2c_client *client)\r\n{\r\nstruct bq27x00_device_info *di = i2c_get_clientdata(client);\r\nbq27x00_powersupply_unregister(di);\r\nkfree(di->bat.name);\r\nmutex_lock(&battery_mutex);\r\nidr_remove(&battery_id, di->id);\r\nmutex_unlock(&battery_mutex);\r\nkfree(di);\r\nreturn 0;\r\n}\r\nstatic inline int bq27x00_battery_i2c_init(void)\r\n{\r\nint ret = i2c_add_driver(&bq27x00_battery_driver);\r\nif (ret)\r\nprintk(KERN_ERR "Unable to register BQ27x00 i2c driver\n");\r\nreturn ret;\r\n}\r\nstatic inline void bq27x00_battery_i2c_exit(void)\r\n{\r\ni2c_del_driver(&bq27x00_battery_driver);\r\n}\r\nstatic inline int bq27x00_battery_i2c_init(void) { return 0; }\r\nstatic inline void bq27x00_battery_i2c_exit(void) {}\r\nstatic int bq27000_read_platform(struct bq27x00_device_info *di, u8 reg,\r\nbool single)\r\n{\r\nstruct device *dev = di->dev;\r\nstruct bq27000_platform_data *pdata = dev->platform_data;\r\nunsigned int timeout = 3;\r\nint upper, lower;\r\nint temp;\r\nif (!single) {\r\nupper = pdata->read(dev, reg + 1);\r\ndo {\r\ntemp = upper;\r\nif (upper < 0)\r\nreturn upper;\r\nlower = pdata->read(dev, reg);\r\nif (lower < 0)\r\nreturn lower;\r\nupper = pdata->read(dev, reg + 1);\r\n} while (temp != upper && --timeout);\r\nif (timeout == 0)\r\nreturn -EIO;\r\nreturn (upper << 8) | lower;\r\n}\r\nreturn pdata->read(dev, reg);\r\n}\r\nstatic int bq27000_battery_probe(struct platform_device *pdev)\r\n{\r\nstruct bq27x00_device_info *di;\r\nstruct bq27000_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform_data supplied\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->read) {\r\ndev_err(&pdev->dev, "no hdq read callback supplied\n");\r\nreturn -EINVAL;\r\n}\r\ndi = kzalloc(sizeof(*di), GFP_KERNEL);\r\nif (!di) {\r\ndev_err(&pdev->dev, "failed to allocate device info data\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, di);\r\ndi->dev = &pdev->dev;\r\ndi->chip = BQ27000;\r\ndi->bat.name = pdata->name ?: dev_name(&pdev->dev);\r\ndi->bus.read = &bq27000_read_platform;\r\nret = bq27x00_powersupply_init(di);\r\nif (ret)\r\ngoto err_free;\r\nreturn 0;\r\nerr_free:\r\nkfree(di);\r\nreturn ret;\r\n}\r\nstatic int bq27000_battery_remove(struct platform_device *pdev)\r\n{\r\nstruct bq27x00_device_info *di = platform_get_drvdata(pdev);\r\nbq27x00_powersupply_unregister(di);\r\nkfree(di);\r\nreturn 0;\r\n}\r\nstatic inline int bq27x00_battery_platform_init(void)\r\n{\r\nint ret = platform_driver_register(&bq27000_battery_driver);\r\nif (ret)\r\nprintk(KERN_ERR "Unable to register BQ27000 platform driver\n");\r\nreturn ret;\r\n}\r\nstatic inline void bq27x00_battery_platform_exit(void)\r\n{\r\nplatform_driver_unregister(&bq27000_battery_driver);\r\n}\r\nstatic inline int bq27x00_battery_platform_init(void) { return 0; }\r\nstatic inline void bq27x00_battery_platform_exit(void) {}\r\nstatic int __init bq27x00_battery_init(void)\r\n{\r\nint ret;\r\nret = bq27x00_battery_i2c_init();\r\nif (ret)\r\nreturn ret;\r\nret = bq27x00_battery_platform_init();\r\nif (ret)\r\nbq27x00_battery_i2c_exit();\r\nreturn ret;\r\n}\r\nstatic void __exit bq27x00_battery_exit(void)\r\n{\r\nbq27x00_battery_platform_exit();\r\nbq27x00_battery_i2c_exit();\r\n}
