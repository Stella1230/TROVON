static void sm_disk_destroy(struct dm_space_map *sm)\r\n{\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\nkfree(smd);\r\n}\r\nstatic int sm_disk_extend(struct dm_space_map *sm, dm_block_t extra_blocks)\r\n{\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\nreturn sm_ll_extend(&smd->ll, extra_blocks);\r\n}\r\nstatic int sm_disk_get_nr_blocks(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\n*count = smd->old_ll.nr_blocks;\r\nreturn 0;\r\n}\r\nstatic int sm_disk_get_nr_free(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\n*count = (smd->old_ll.nr_blocks - smd->old_ll.nr_allocated) - smd->nr_allocated_this_transaction;\r\nreturn 0;\r\n}\r\nstatic int sm_disk_get_count(struct dm_space_map *sm, dm_block_t b,\r\nuint32_t *result)\r\n{\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\nreturn sm_ll_lookup(&smd->ll, b, result);\r\n}\r\nstatic int sm_disk_count_is_more_than_one(struct dm_space_map *sm, dm_block_t b,\r\nint *result)\r\n{\r\nint r;\r\nuint32_t count;\r\nr = sm_disk_get_count(sm, b, &count);\r\nif (r)\r\nreturn r;\r\nreturn count > 1;\r\n}\r\nstatic int sm_disk_set_count(struct dm_space_map *sm, dm_block_t b,\r\nuint32_t count)\r\n{\r\nint r;\r\nuint32_t old_count;\r\nenum allocation_event ev;\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\nr = sm_ll_insert(&smd->ll, b, count, &ev);\r\nif (!r) {\r\nswitch (ev) {\r\ncase SM_NONE:\r\nbreak;\r\ncase SM_ALLOC:\r\nsmd->nr_allocated_this_transaction++;\r\nbreak;\r\ncase SM_FREE:\r\nr = sm_ll_lookup(&smd->old_ll, b, &old_count);\r\nif (r)\r\nreturn r;\r\nif (!old_count)\r\nsmd->nr_allocated_this_transaction--;\r\nbreak;\r\n}\r\n}\r\nreturn r;\r\n}\r\nstatic int sm_disk_inc_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nint r;\r\nenum allocation_event ev;\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\nr = sm_ll_inc(&smd->ll, b, &ev);\r\nif (!r && (ev == SM_ALLOC))\r\nsmd->nr_allocated_this_transaction++;\r\nreturn r;\r\n}\r\nstatic int sm_disk_dec_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nenum allocation_event ev;\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\nreturn sm_ll_dec(&smd->ll, b, &ev);\r\n}\r\nstatic int sm_disk_new_block(struct dm_space_map *sm, dm_block_t *b)\r\n{\r\nint r;\r\nenum allocation_event ev;\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\nr = sm_ll_find_free_block(&smd->old_ll, smd->begin, smd->old_ll.nr_blocks, b);\r\nif (r)\r\nreturn r;\r\nsmd->begin = *b + 1;\r\nr = sm_ll_inc(&smd->ll, *b, &ev);\r\nif (!r) {\r\nBUG_ON(ev != SM_ALLOC);\r\nsmd->nr_allocated_this_transaction++;\r\n}\r\nreturn r;\r\n}\r\nstatic int sm_disk_commit(struct dm_space_map *sm)\r\n{\r\nint r;\r\ndm_block_t nr_free;\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\nr = sm_disk_get_nr_free(sm, &nr_free);\r\nif (r)\r\nreturn r;\r\nr = sm_ll_commit(&smd->ll);\r\nif (r)\r\nreturn r;\r\nmemcpy(&smd->old_ll, &smd->ll, sizeof(smd->old_ll));\r\nsmd->begin = 0;\r\nsmd->nr_allocated_this_transaction = 0;\r\nr = sm_disk_get_nr_free(sm, &nr_free);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int sm_disk_root_size(struct dm_space_map *sm, size_t *result)\r\n{\r\n*result = sizeof(struct disk_sm_root);\r\nreturn 0;\r\n}\r\nstatic int sm_disk_copy_root(struct dm_space_map *sm, void *where_le, size_t max)\r\n{\r\nstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\r\nstruct disk_sm_root root_le;\r\nroot_le.nr_blocks = cpu_to_le64(smd->ll.nr_blocks);\r\nroot_le.nr_allocated = cpu_to_le64(smd->ll.nr_allocated);\r\nroot_le.bitmap_root = cpu_to_le64(smd->ll.bitmap_root);\r\nroot_le.ref_count_root = cpu_to_le64(smd->ll.ref_count_root);\r\nif (max < sizeof(root_le))\r\nreturn -ENOSPC;\r\nmemcpy(where_le, &root_le, sizeof(root_le));\r\nreturn 0;\r\n}\r\nstruct dm_space_map *dm_sm_disk_create(struct dm_transaction_manager *tm,\r\ndm_block_t nr_blocks)\r\n{\r\nint r;\r\nstruct sm_disk *smd;\r\nsmd = kmalloc(sizeof(*smd), GFP_KERNEL);\r\nif (!smd)\r\nreturn ERR_PTR(-ENOMEM);\r\nsmd->begin = 0;\r\nsmd->nr_allocated_this_transaction = 0;\r\nmemcpy(&smd->sm, &ops, sizeof(smd->sm));\r\nr = sm_ll_new_disk(&smd->ll, tm);\r\nif (r)\r\ngoto bad;\r\nr = sm_ll_extend(&smd->ll, nr_blocks);\r\nif (r)\r\ngoto bad;\r\nr = sm_disk_commit(&smd->sm);\r\nif (r)\r\ngoto bad;\r\nreturn &smd->sm;\r\nbad:\r\nkfree(smd);\r\nreturn ERR_PTR(r);\r\n}\r\nstruct dm_space_map *dm_sm_disk_open(struct dm_transaction_manager *tm,\r\nvoid *root_le, size_t len)\r\n{\r\nint r;\r\nstruct sm_disk *smd;\r\nsmd = kmalloc(sizeof(*smd), GFP_KERNEL);\r\nif (!smd)\r\nreturn ERR_PTR(-ENOMEM);\r\nsmd->begin = 0;\r\nsmd->nr_allocated_this_transaction = 0;\r\nmemcpy(&smd->sm, &ops, sizeof(smd->sm));\r\nr = sm_ll_open_disk(&smd->ll, tm, root_le, len);\r\nif (r)\r\ngoto bad;\r\nr = sm_disk_commit(&smd->sm);\r\nif (r)\r\ngoto bad;\r\nreturn &smd->sm;\r\nbad:\r\nkfree(smd);\r\nreturn ERR_PTR(r);\r\n}
