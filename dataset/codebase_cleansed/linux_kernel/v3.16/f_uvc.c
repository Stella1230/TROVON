static void\r\nuvc_function_ep0_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct uvc_device *uvc = req->context;\r\nstruct v4l2_event v4l2_event;\r\nstruct uvc_event *uvc_event = (void *)&v4l2_event.u.data;\r\nif (uvc->event_setup_out) {\r\nuvc->event_setup_out = 0;\r\nmemset(&v4l2_event, 0, sizeof(v4l2_event));\r\nv4l2_event.type = UVC_EVENT_DATA;\r\nuvc_event->data.length = req->actual;\r\nmemcpy(&uvc_event->data.data, req->buf, req->actual);\r\nv4l2_event_queue(uvc->vdev, &v4l2_event);\r\n}\r\n}\r\nstatic int\r\nuvc_function_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct uvc_device *uvc = to_uvc(f);\r\nstruct v4l2_event v4l2_event;\r\nstruct uvc_event *uvc_event = (void *)&v4l2_event.u.data;\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_CLASS) {\r\nINFO(f->config->cdev, "invalid request type\n");\r\nreturn -EINVAL;\r\n}\r\nif (le16_to_cpu(ctrl->wLength) > UVC_MAX_REQUEST_SIZE)\r\nreturn -EINVAL;\r\nmemset(&v4l2_event, 0, sizeof(v4l2_event));\r\nv4l2_event.type = UVC_EVENT_SETUP;\r\nmemcpy(&uvc_event->req, ctrl, sizeof(uvc_event->req));\r\nv4l2_event_queue(uvc->vdev, &v4l2_event);\r\nreturn 0;\r\n}\r\nvoid uvc_function_setup_continue(struct uvc_device *uvc)\r\n{\r\nstruct usb_composite_dev *cdev = uvc->func.config->cdev;\r\nusb_composite_setup_continue(cdev);\r\n}\r\nstatic int\r\nuvc_function_get_alt(struct usb_function *f, unsigned interface)\r\n{\r\nstruct uvc_device *uvc = to_uvc(f);\r\nINFO(f->config->cdev, "uvc_function_get_alt(%u)\n", interface);\r\nif (interface == uvc->control_intf)\r\nreturn 0;\r\nelse if (interface != uvc->streaming_intf)\r\nreturn -EINVAL;\r\nelse\r\nreturn uvc->state == UVC_STATE_STREAMING ? 1 : 0;\r\n}\r\nstatic int\r\nuvc_function_set_alt(struct usb_function *f, unsigned interface, unsigned alt)\r\n{\r\nstruct uvc_device *uvc = to_uvc(f);\r\nstruct v4l2_event v4l2_event;\r\nstruct uvc_event *uvc_event = (void *)&v4l2_event.u.data;\r\nint ret;\r\nINFO(f->config->cdev, "uvc_function_set_alt(%u, %u)\n", interface, alt);\r\nif (interface == uvc->control_intf) {\r\nif (alt)\r\nreturn -EINVAL;\r\nif (uvc->state == UVC_STATE_DISCONNECTED) {\r\nmemset(&v4l2_event, 0, sizeof(v4l2_event));\r\nv4l2_event.type = UVC_EVENT_CONNECT;\r\nuvc_event->speed = f->config->cdev->gadget->speed;\r\nv4l2_event_queue(uvc->vdev, &v4l2_event);\r\nuvc->state = UVC_STATE_CONNECTED;\r\n}\r\nreturn 0;\r\n}\r\nif (interface != uvc->streaming_intf)\r\nreturn -EINVAL;\r\nswitch (alt) {\r\ncase 0:\r\nif (uvc->state != UVC_STATE_STREAMING)\r\nreturn 0;\r\nif (uvc->video.ep)\r\nusb_ep_disable(uvc->video.ep);\r\nmemset(&v4l2_event, 0, sizeof(v4l2_event));\r\nv4l2_event.type = UVC_EVENT_STREAMOFF;\r\nv4l2_event_queue(uvc->vdev, &v4l2_event);\r\nuvc->state = UVC_STATE_CONNECTED;\r\nreturn 0;\r\ncase 1:\r\nif (uvc->state != UVC_STATE_CONNECTED)\r\nreturn 0;\r\nif (uvc->video.ep) {\r\nret = config_ep_by_speed(f->config->cdev->gadget,\r\n&(uvc->func), uvc->video.ep);\r\nif (ret)\r\nreturn ret;\r\nusb_ep_enable(uvc->video.ep);\r\n}\r\nmemset(&v4l2_event, 0, sizeof(v4l2_event));\r\nv4l2_event.type = UVC_EVENT_STREAMON;\r\nv4l2_event_queue(uvc->vdev, &v4l2_event);\r\nreturn USB_GADGET_DELAYED_STATUS;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void\r\nuvc_function_disable(struct usb_function *f)\r\n{\r\nstruct uvc_device *uvc = to_uvc(f);\r\nstruct v4l2_event v4l2_event;\r\nINFO(f->config->cdev, "uvc_function_disable\n");\r\nmemset(&v4l2_event, 0, sizeof(v4l2_event));\r\nv4l2_event.type = UVC_EVENT_DISCONNECT;\r\nv4l2_event_queue(uvc->vdev, &v4l2_event);\r\nuvc->state = UVC_STATE_DISCONNECTED;\r\n}\r\nvoid\r\nuvc_function_connect(struct uvc_device *uvc)\r\n{\r\nstruct usb_composite_dev *cdev = uvc->func.config->cdev;\r\nint ret;\r\nif ((ret = usb_function_activate(&uvc->func)) < 0)\r\nINFO(cdev, "UVC connect failed with %d\n", ret);\r\n}\r\nvoid\r\nuvc_function_disconnect(struct uvc_device *uvc)\r\n{\r\nstruct usb_composite_dev *cdev = uvc->func.config->cdev;\r\nint ret;\r\nif ((ret = usb_function_deactivate(&uvc->func)) < 0)\r\nINFO(cdev, "UVC disconnect failed with %d\n", ret);\r\n}\r\nstatic int\r\nuvc_register_video(struct uvc_device *uvc)\r\n{\r\nstruct usb_composite_dev *cdev = uvc->func.config->cdev;\r\nstruct video_device *video;\r\nvideo = video_device_alloc();\r\nif (video == NULL)\r\nreturn -ENOMEM;\r\nvideo->v4l2_dev = &uvc->v4l2_dev;\r\nvideo->fops = &uvc_v4l2_fops;\r\nvideo->release = video_device_release;\r\nstrlcpy(video->name, cdev->gadget->name, sizeof(video->name));\r\nuvc->vdev = video;\r\nvideo_set_drvdata(video, uvc);\r\nreturn video_register_device(video, VFL_TYPE_GRABBER, -1);\r\n}\r\nstatic struct usb_descriptor_header ** __init\r\nuvc_copy_descriptors(struct uvc_device *uvc, enum usb_device_speed speed)\r\n{\r\nstruct uvc_input_header_descriptor *uvc_streaming_header;\r\nstruct uvc_header_descriptor *uvc_control_header;\r\nconst struct uvc_descriptor_header * const *uvc_control_desc;\r\nconst struct uvc_descriptor_header * const *uvc_streaming_cls;\r\nconst struct usb_descriptor_header * const *uvc_streaming_std;\r\nconst struct usb_descriptor_header * const *src;\r\nstruct usb_descriptor_header **dst;\r\nstruct usb_descriptor_header **hdr;\r\nunsigned int control_size;\r\nunsigned int streaming_size;\r\nunsigned int n_desc;\r\nunsigned int bytes;\r\nvoid *mem;\r\nswitch (speed) {\r\ncase USB_SPEED_SUPER:\r\nuvc_control_desc = uvc->desc.ss_control;\r\nuvc_streaming_cls = uvc->desc.ss_streaming;\r\nuvc_streaming_std = uvc_ss_streaming;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nuvc_control_desc = uvc->desc.fs_control;\r\nuvc_streaming_cls = uvc->desc.hs_streaming;\r\nuvc_streaming_std = uvc_hs_streaming;\r\nbreak;\r\ncase USB_SPEED_FULL:\r\ndefault:\r\nuvc_control_desc = uvc->desc.fs_control;\r\nuvc_streaming_cls = uvc->desc.fs_streaming;\r\nuvc_streaming_std = uvc_fs_streaming;\r\nbreak;\r\n}\r\ncontrol_size = 0;\r\nstreaming_size = 0;\r\nbytes = uvc_iad.bLength + uvc_control_intf.bLength\r\n+ uvc_control_ep.bLength + uvc_control_cs_ep.bLength\r\n+ uvc_streaming_intf_alt0.bLength;\r\nif (speed == USB_SPEED_SUPER) {\r\nbytes += uvc_ss_control_comp.bLength;\r\nn_desc = 6;\r\n} else {\r\nn_desc = 5;\r\n}\r\nfor (src = (const struct usb_descriptor_header **)uvc_control_desc;\r\n*src; ++src) {\r\ncontrol_size += (*src)->bLength;\r\nbytes += (*src)->bLength;\r\nn_desc++;\r\n}\r\nfor (src = (const struct usb_descriptor_header **)uvc_streaming_cls;\r\n*src; ++src) {\r\nstreaming_size += (*src)->bLength;\r\nbytes += (*src)->bLength;\r\nn_desc++;\r\n}\r\nfor (src = uvc_streaming_std; *src; ++src) {\r\nbytes += (*src)->bLength;\r\nn_desc++;\r\n}\r\nmem = kmalloc((n_desc + 1) * sizeof(*src) + bytes, GFP_KERNEL);\r\nif (mem == NULL)\r\nreturn NULL;\r\nhdr = mem;\r\ndst = mem;\r\nmem += (n_desc + 1) * sizeof(*src);\r\nUVC_COPY_DESCRIPTOR(mem, dst, &uvc_iad);\r\nUVC_COPY_DESCRIPTOR(mem, dst, &uvc_control_intf);\r\nuvc_control_header = mem;\r\nUVC_COPY_DESCRIPTORS(mem, dst,\r\n(const struct usb_descriptor_header **)uvc_control_desc);\r\nuvc_control_header->wTotalLength = cpu_to_le16(control_size);\r\nuvc_control_header->bInCollection = 1;\r\nuvc_control_header->baInterfaceNr[0] = uvc->streaming_intf;\r\nUVC_COPY_DESCRIPTOR(mem, dst, &uvc_control_ep);\r\nif (speed == USB_SPEED_SUPER)\r\nUVC_COPY_DESCRIPTOR(mem, dst, &uvc_ss_control_comp);\r\nUVC_COPY_DESCRIPTOR(mem, dst, &uvc_control_cs_ep);\r\nUVC_COPY_DESCRIPTOR(mem, dst, &uvc_streaming_intf_alt0);\r\nuvc_streaming_header = mem;\r\nUVC_COPY_DESCRIPTORS(mem, dst,\r\n(const struct usb_descriptor_header**)uvc_streaming_cls);\r\nuvc_streaming_header->wTotalLength = cpu_to_le16(streaming_size);\r\nuvc_streaming_header->bEndpointAddress = uvc->video.ep->address;\r\nUVC_COPY_DESCRIPTORS(mem, dst, uvc_streaming_std);\r\n*dst = NULL;\r\nreturn hdr;\r\n}\r\nstatic void\r\nuvc_function_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct uvc_device *uvc = to_uvc(f);\r\nINFO(cdev, "uvc_function_unbind\n");\r\nvideo_unregister_device(uvc->vdev);\r\nv4l2_device_unregister(&uvc->v4l2_dev);\r\nuvc->control_ep->driver_data = NULL;\r\nuvc->video.ep->driver_data = NULL;\r\nuvc_en_us_strings[UVC_STRING_CONTROL_IDX].id = 0;\r\nusb_ep_free_request(cdev->gadget->ep0, uvc->control_req);\r\nkfree(uvc->control_buf);\r\nusb_free_all_descriptors(f);\r\nkfree(uvc);\r\n}\r\nstatic int __init\r\nuvc_function_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct uvc_device *uvc = to_uvc(f);\r\nunsigned int max_packet_mult;\r\nunsigned int max_packet_size;\r\nstruct usb_ep *ep;\r\nint ret = -EINVAL;\r\nINFO(cdev, "uvc_function_bind\n");\r\nstreaming_interval = clamp(streaming_interval, 1U, 16U);\r\nstreaming_maxpacket = clamp(streaming_maxpacket, 1U, 3072U);\r\nstreaming_maxburst = min(streaming_maxburst, 15U);\r\nif (streaming_maxpacket <= 1024) {\r\nmax_packet_mult = 1;\r\nmax_packet_size = streaming_maxpacket;\r\n} else if (streaming_maxpacket <= 2048) {\r\nmax_packet_mult = 2;\r\nmax_packet_size = streaming_maxpacket / 2;\r\n} else {\r\nmax_packet_mult = 3;\r\nmax_packet_size = streaming_maxpacket / 3;\r\n}\r\nuvc_fs_streaming_ep.wMaxPacketSize = min(streaming_maxpacket, 1023U);\r\nuvc_fs_streaming_ep.bInterval = streaming_interval;\r\nuvc_hs_streaming_ep.wMaxPacketSize = max_packet_size;\r\nuvc_hs_streaming_ep.wMaxPacketSize |= ((max_packet_mult - 1) << 11);\r\nuvc_hs_streaming_ep.bInterval = streaming_interval;\r\nuvc_ss_streaming_ep.wMaxPacketSize = max_packet_size;\r\nuvc_ss_streaming_ep.bInterval = streaming_interval;\r\nuvc_ss_streaming_comp.bmAttributes = max_packet_mult - 1;\r\nuvc_ss_streaming_comp.bMaxBurst = streaming_maxburst;\r\nuvc_ss_streaming_comp.wBytesPerInterval =\r\nmax_packet_size * max_packet_mult * streaming_maxburst;\r\nep = usb_ep_autoconfig(cdev->gadget, &uvc_control_ep);\r\nif (!ep) {\r\nINFO(cdev, "Unable to allocate control EP\n");\r\ngoto error;\r\n}\r\nuvc->control_ep = ep;\r\nep->driver_data = uvc;\r\nif (gadget_is_superspeed(c->cdev->gadget))\r\nep = usb_ep_autoconfig_ss(cdev->gadget, &uvc_ss_streaming_ep,\r\n&uvc_ss_streaming_comp);\r\nelse if (gadget_is_dualspeed(cdev->gadget))\r\nep = usb_ep_autoconfig(cdev->gadget, &uvc_hs_streaming_ep);\r\nelse\r\nep = usb_ep_autoconfig(cdev->gadget, &uvc_fs_streaming_ep);\r\nif (!ep) {\r\nINFO(cdev, "Unable to allocate streaming EP\n");\r\ngoto error;\r\n}\r\nuvc->video.ep = ep;\r\nep->driver_data = uvc;\r\nuvc_fs_streaming_ep.bEndpointAddress = uvc->video.ep->address;\r\nuvc_hs_streaming_ep.bEndpointAddress = uvc->video.ep->address;\r\nuvc_ss_streaming_ep.bEndpointAddress = uvc->video.ep->address;\r\nif ((ret = usb_interface_id(c, f)) < 0)\r\ngoto error;\r\nuvc_iad.bFirstInterface = ret;\r\nuvc_control_intf.bInterfaceNumber = ret;\r\nuvc->control_intf = ret;\r\nif ((ret = usb_interface_id(c, f)) < 0)\r\ngoto error;\r\nuvc_streaming_intf_alt0.bInterfaceNumber = ret;\r\nuvc_streaming_intf_alt1.bInterfaceNumber = ret;\r\nuvc->streaming_intf = ret;\r\nf->fs_descriptors = uvc_copy_descriptors(uvc, USB_SPEED_FULL);\r\nif (gadget_is_dualspeed(cdev->gadget))\r\nf->hs_descriptors = uvc_copy_descriptors(uvc, USB_SPEED_HIGH);\r\nif (gadget_is_superspeed(c->cdev->gadget))\r\nf->ss_descriptors = uvc_copy_descriptors(uvc, USB_SPEED_SUPER);\r\nuvc->control_req = usb_ep_alloc_request(cdev->gadget->ep0, GFP_KERNEL);\r\nuvc->control_buf = kmalloc(UVC_MAX_REQUEST_SIZE, GFP_KERNEL);\r\nif (uvc->control_req == NULL || uvc->control_buf == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nuvc->control_req->buf = uvc->control_buf;\r\nuvc->control_req->complete = uvc_function_ep0_complete;\r\nuvc->control_req->context = uvc;\r\nif ((ret = usb_function_deactivate(f)) < 0)\r\ngoto error;\r\nif (v4l2_device_register(&cdev->gadget->dev, &uvc->v4l2_dev)) {\r\nprintk(KERN_INFO "v4l2_device_register failed\n");\r\ngoto error;\r\n}\r\nret = uvc_video_init(&uvc->video);\r\nif (ret < 0)\r\ngoto error;\r\nret = uvc_register_video(uvc);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "Unable to register video device\n");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nv4l2_device_unregister(&uvc->v4l2_dev);\r\nif (uvc->vdev)\r\nvideo_device_release(uvc->vdev);\r\nif (uvc->control_ep)\r\nuvc->control_ep->driver_data = NULL;\r\nif (uvc->video.ep)\r\nuvc->video.ep->driver_data = NULL;\r\nif (uvc->control_req) {\r\nusb_ep_free_request(cdev->gadget->ep0, uvc->control_req);\r\nkfree(uvc->control_buf);\r\n}\r\nusb_free_all_descriptors(f);\r\nreturn ret;\r\n}\r\nint __init\r\nuvc_bind_config(struct usb_configuration *c,\r\nconst struct uvc_descriptor_header * const *fs_control,\r\nconst struct uvc_descriptor_header * const *ss_control,\r\nconst struct uvc_descriptor_header * const *fs_streaming,\r\nconst struct uvc_descriptor_header * const *hs_streaming,\r\nconst struct uvc_descriptor_header * const *ss_streaming)\r\n{\r\nstruct uvc_device *uvc;\r\nint ret = 0;\r\nif (!gadget_is_dualspeed(c->cdev->gadget))\r\nreturn -EINVAL;\r\nuvc = kzalloc(sizeof(*uvc), GFP_KERNEL);\r\nif (uvc == NULL)\r\nreturn -ENOMEM;\r\nuvc->state = UVC_STATE_DISCONNECTED;\r\nif (fs_control == NULL || fs_control[0] == NULL ||\r\nfs_control[0]->bDescriptorSubType != UVC_VC_HEADER)\r\ngoto error;\r\nif (ss_control == NULL || ss_control[0] == NULL ||\r\nss_control[0]->bDescriptorSubType != UVC_VC_HEADER)\r\ngoto error;\r\nif (fs_streaming == NULL || fs_streaming[0] == NULL ||\r\nfs_streaming[0]->bDescriptorSubType != UVC_VS_INPUT_HEADER)\r\ngoto error;\r\nif (hs_streaming == NULL || hs_streaming[0] == NULL ||\r\nhs_streaming[0]->bDescriptorSubType != UVC_VS_INPUT_HEADER)\r\ngoto error;\r\nif (ss_streaming == NULL || ss_streaming[0] == NULL ||\r\nss_streaming[0]->bDescriptorSubType != UVC_VS_INPUT_HEADER)\r\ngoto error;\r\nuvc->desc.fs_control = fs_control;\r\nuvc->desc.ss_control = ss_control;\r\nuvc->desc.fs_streaming = fs_streaming;\r\nuvc->desc.hs_streaming = hs_streaming;\r\nuvc->desc.ss_streaming = ss_streaming;\r\nif (uvc_en_us_strings[UVC_STRING_CONTROL_IDX].id == 0) {\r\nret = usb_string_ids_tab(c->cdev, uvc_en_us_strings);\r\nif (ret)\r\ngoto error;\r\nuvc_iad.iFunction =\r\nuvc_en_us_strings[UVC_STRING_CONTROL_IDX].id;\r\nuvc_control_intf.iInterface =\r\nuvc_en_us_strings[UVC_STRING_CONTROL_IDX].id;\r\nret = uvc_en_us_strings[UVC_STRING_STREAMING_IDX].id;\r\nuvc_streaming_intf_alt0.iInterface = ret;\r\nuvc_streaming_intf_alt1.iInterface = ret;\r\n}\r\nuvc->func.name = "uvc";\r\nuvc->func.strings = uvc_function_strings;\r\nuvc->func.bind = uvc_function_bind;\r\nuvc->func.unbind = uvc_function_unbind;\r\nuvc->func.get_alt = uvc_function_get_alt;\r\nuvc->func.set_alt = uvc_function_set_alt;\r\nuvc->func.disable = uvc_function_disable;\r\nuvc->func.setup = uvc_function_setup;\r\nret = usb_add_function(c, &uvc->func);\r\nif (ret)\r\nkfree(uvc);\r\nreturn ret;\r\nerror:\r\nkfree(uvc);\r\nreturn ret;\r\n}
