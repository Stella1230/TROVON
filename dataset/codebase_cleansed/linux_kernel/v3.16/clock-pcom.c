static inline struct clk_pcom *to_clk_pcom(struct clk_hw *hw)\r\n{\r\nreturn container_of(to_msm_clk(hw), struct clk_pcom, msm_clk);\r\n}\r\nstatic int pc_clk_enable(struct clk_hw *hw)\r\n{\r\nunsigned id = to_clk_pcom(hw)->id;\r\nint rc = msm_proc_comm(PCOM_CLKCTL_RPC_ENABLE, &id, NULL);\r\nif (rc < 0)\r\nreturn rc;\r\nelse\r\nreturn (int)id < 0 ? -EINVAL : 0;\r\n}\r\nstatic void pc_clk_disable(struct clk_hw *hw)\r\n{\r\nunsigned id = to_clk_pcom(hw)->id;\r\nmsm_proc_comm(PCOM_CLKCTL_RPC_DISABLE, &id, NULL);\r\n}\r\nstatic int pc_clk_reset(struct clk_hw *hw, enum clk_reset_action action)\r\n{\r\nint rc;\r\nunsigned id = to_clk_pcom(hw)->id;\r\nif (action == CLK_RESET_ASSERT)\r\nrc = msm_proc_comm(PCOM_CLKCTL_RPC_RESET_ASSERT, &id, NULL);\r\nelse\r\nrc = msm_proc_comm(PCOM_CLKCTL_RPC_RESET_DEASSERT, &id, NULL);\r\nif (rc < 0)\r\nreturn rc;\r\nelse\r\nreturn (int)id < 0 ? -EINVAL : 0;\r\n}\r\nstatic int pc_clk_set_rate(struct clk_hw *hw, unsigned long new_rate,\r\nunsigned long p_rate)\r\n{\r\nstruct clk_pcom *p = to_clk_pcom(hw);\r\nunsigned id = p->id, rate = new_rate;\r\nint rc;\r\nif (p->flags & CLKFLAG_MIN)\r\nrc = msm_proc_comm(PCOM_CLKCTL_RPC_MIN_RATE, &id, &rate);\r\nelse\r\nrc = msm_proc_comm(PCOM_CLKCTL_RPC_SET_RATE, &id, &rate);\r\nif (rc < 0)\r\nreturn rc;\r\nelse\r\nreturn (int)id < 0 ? -EINVAL : 0;\r\n}\r\nstatic unsigned long pc_clk_recalc_rate(struct clk_hw *hw, unsigned long p_rate)\r\n{\r\nunsigned id = to_clk_pcom(hw)->id;\r\nif (msm_proc_comm(PCOM_CLKCTL_RPC_RATE, &id, NULL))\r\nreturn 0;\r\nelse\r\nreturn id;\r\n}\r\nstatic int pc_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nunsigned id = to_clk_pcom(hw)->id;\r\nif (msm_proc_comm(PCOM_CLKCTL_RPC_ENABLED, &id, NULL))\r\nreturn 0;\r\nelse\r\nreturn id;\r\n}\r\nstatic long pc_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *p_rate)\r\n{\r\nreturn rate;\r\n}\r\nstatic int msm_clock_pcom_probe(struct platform_device *pdev)\r\n{\r\nconst struct pcom_clk_pdata *pdata = pdev->dev.platform_data;\r\nint i, ret;\r\nfor (i = 0; i < pdata->num_lookups; i++) {\r\nconst struct clk_pcom_desc *desc = &pdata->lookup[i];\r\nstruct clk *c;\r\nstruct clk_pcom *p;\r\nstruct clk_hw *hw;\r\nstruct clk_init_data init;\r\np = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->id = desc->id;\r\np->flags = desc->flags;\r\np->msm_clk.reset = pc_clk_reset;\r\nhw = &p->msm_clk.hw;\r\nhw->init = &init;\r\ninit.name = desc->name;\r\ninit.ops = &clk_ops_pcom;\r\ninit.num_parents = 0;\r\ninit.flags = CLK_IS_ROOT;\r\nif (!(p->flags & CLKFLAG_AUTO_OFF))\r\ninit.flags |= CLK_IGNORE_UNUSED;\r\nc = devm_clk_register(&pdev->dev, hw);\r\nret = clk_register_clkdev(c, desc->con, desc->dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
