static inline void\r\nclusterip_config_get(struct clusterip_config *c)\r\n{\r\natomic_inc(&c->refcount);\r\n}\r\nstatic void clusterip_config_rcu_free(struct rcu_head *head)\r\n{\r\nkfree(container_of(head, struct clusterip_config, rcu));\r\n}\r\nstatic inline void\r\nclusterip_config_put(struct clusterip_config *c)\r\n{\r\nif (atomic_dec_and_test(&c->refcount))\r\ncall_rcu_bh(&c->rcu, clusterip_config_rcu_free);\r\n}\r\nstatic inline void\r\nclusterip_config_entry_put(struct clusterip_config *c)\r\n{\r\nstruct net *net = dev_net(c->dev);\r\nstruct clusterip_net *cn = net_generic(net, clusterip_net_id);\r\nlocal_bh_disable();\r\nif (atomic_dec_and_lock(&c->entries, &cn->lock)) {\r\nlist_del_rcu(&c->list);\r\nspin_unlock(&cn->lock);\r\nlocal_bh_enable();\r\ndev_mc_del(c->dev, c->clustermac);\r\ndev_put(c->dev);\r\n#ifdef CONFIG_PROC_FS\r\nproc_remove(c->pde);\r\n#endif\r\nreturn;\r\n}\r\nlocal_bh_enable();\r\n}\r\nstatic struct clusterip_config *\r\n__clusterip_config_find(struct net *net, __be32 clusterip)\r\n{\r\nstruct clusterip_config *c;\r\nstruct clusterip_net *cn = net_generic(net, clusterip_net_id);\r\nlist_for_each_entry_rcu(c, &cn->configs, list) {\r\nif (c->clusterip == clusterip)\r\nreturn c;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct clusterip_config *\r\nclusterip_config_find_get(struct net *net, __be32 clusterip, int entry)\r\n{\r\nstruct clusterip_config *c;\r\nrcu_read_lock_bh();\r\nc = __clusterip_config_find(net, clusterip);\r\nif (c) {\r\nif (unlikely(!atomic_inc_not_zero(&c->refcount)))\r\nc = NULL;\r\nelse if (entry)\r\natomic_inc(&c->entries);\r\n}\r\nrcu_read_unlock_bh();\r\nreturn c;\r\n}\r\nstatic void\r\nclusterip_config_init_nodelist(struct clusterip_config *c,\r\nconst struct ipt_clusterip_tgt_info *i)\r\n{\r\nint n;\r\nfor (n = 0; n < i->num_local_nodes; n++)\r\nset_bit(i->local_nodes[n] - 1, &c->local_nodes);\r\n}\r\nstatic struct clusterip_config *\r\nclusterip_config_init(const struct ipt_clusterip_tgt_info *i, __be32 ip,\r\nstruct net_device *dev)\r\n{\r\nstruct clusterip_config *c;\r\nstruct clusterip_net *cn = net_generic(dev_net(dev), clusterip_net_id);\r\nc = kzalloc(sizeof(*c), GFP_ATOMIC);\r\nif (!c)\r\nreturn NULL;\r\nc->dev = dev;\r\nc->clusterip = ip;\r\nmemcpy(&c->clustermac, &i->clustermac, ETH_ALEN);\r\nc->num_total_nodes = i->num_total_nodes;\r\nclusterip_config_init_nodelist(c, i);\r\nc->hash_mode = i->hash_mode;\r\nc->hash_initval = i->hash_initval;\r\natomic_set(&c->refcount, 1);\r\natomic_set(&c->entries, 1);\r\n#ifdef CONFIG_PROC_FS\r\n{\r\nchar buffer[16];\r\nsprintf(buffer, "%pI4", &ip);\r\nc->pde = proc_create_data(buffer, S_IWUSR|S_IRUSR,\r\ncn->procdir,\r\n&clusterip_proc_fops, c);\r\nif (!c->pde) {\r\nkfree(c);\r\nreturn NULL;\r\n}\r\n}\r\n#endif\r\nspin_lock_bh(&cn->lock);\r\nlist_add_rcu(&c->list, &cn->configs);\r\nspin_unlock_bh(&cn->lock);\r\nreturn c;\r\n}\r\nstatic int\r\nclusterip_add_node(struct clusterip_config *c, u_int16_t nodenum)\r\n{\r\nif (nodenum == 0 ||\r\nnodenum > c->num_total_nodes)\r\nreturn 1;\r\nif (test_and_set_bit(nodenum - 1, &c->local_nodes))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic bool\r\nclusterip_del_node(struct clusterip_config *c, u_int16_t nodenum)\r\n{\r\nif (nodenum == 0 ||\r\nnodenum > c->num_total_nodes)\r\nreturn true;\r\nif (test_and_clear_bit(nodenum - 1, &c->local_nodes))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline u_int32_t\r\nclusterip_hashfn(const struct sk_buff *skb,\r\nconst struct clusterip_config *config)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nunsigned long hashval;\r\nu_int16_t sport = 0, dport = 0;\r\nint poff;\r\npoff = proto_ports_offset(iph->protocol);\r\nif (poff >= 0) {\r\nconst u_int16_t *ports;\r\nu16 _ports[2];\r\nports = skb_header_pointer(skb, iph->ihl * 4 + poff, 4, _ports);\r\nif (ports) {\r\nsport = ports[0];\r\ndport = ports[1];\r\n}\r\n} else {\r\nnet_info_ratelimited("unknown protocol %u\n", iph->protocol);\r\n}\r\nswitch (config->hash_mode) {\r\ncase CLUSTERIP_HASHMODE_SIP:\r\nhashval = jhash_1word(ntohl(iph->saddr),\r\nconfig->hash_initval);\r\nbreak;\r\ncase CLUSTERIP_HASHMODE_SIP_SPT:\r\nhashval = jhash_2words(ntohl(iph->saddr), sport,\r\nconfig->hash_initval);\r\nbreak;\r\ncase CLUSTERIP_HASHMODE_SIP_SPT_DPT:\r\nhashval = jhash_3words(ntohl(iph->saddr), sport, dport,\r\nconfig->hash_initval);\r\nbreak;\r\ndefault:\r\nhashval = 0;\r\npr_info("unknown mode %u\n", config->hash_mode);\r\nBUG();\r\nbreak;\r\n}\r\nreturn (((u64)hashval * config->num_total_nodes) >> 32) + 1;\r\n}\r\nstatic inline int\r\nclusterip_responsible(const struct clusterip_config *config, u_int32_t hash)\r\n{\r\nreturn test_bit(hash - 1, &config->local_nodes);\r\n}\r\nstatic unsigned int\r\nclusterip_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ipt_clusterip_tgt_info *cipinfo = par->targinfo;\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nu_int32_t hash;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct == NULL)\r\nreturn NF_DROP;\r\nif (ip_hdr(skb)->protocol == IPPROTO_ICMP &&\r\n(ctinfo == IP_CT_RELATED ||\r\nctinfo == IP_CT_RELATED_REPLY))\r\nreturn XT_CONTINUE;\r\nhash = clusterip_hashfn(skb, cipinfo->config);\r\nswitch (ctinfo) {\r\ncase IP_CT_NEW:\r\nct->mark = hash;\r\nbreak;\r\ncase IP_CT_RELATED:\r\ncase IP_CT_RELATED_REPLY:\r\ncase IP_CT_ESTABLISHED:\r\ncase IP_CT_ESTABLISHED_REPLY:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#ifdef DEBUG\r\nnf_ct_dump_tuple_ip(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);\r\n#endif\r\npr_debug("hash=%u ct_hash=%u ", hash, ct->mark);\r\nif (!clusterip_responsible(cipinfo->config, hash)) {\r\npr_debug("not responsible\n");\r\nreturn NF_DROP;\r\n}\r\npr_debug("responsible\n");\r\nskb->pkt_type = PACKET_HOST;\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int clusterip_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nstruct ipt_clusterip_tgt_info *cipinfo = par->targinfo;\r\nconst struct ipt_entry *e = par->entryinfo;\r\nstruct clusterip_config *config;\r\nint ret;\r\nif (cipinfo->hash_mode != CLUSTERIP_HASHMODE_SIP &&\r\ncipinfo->hash_mode != CLUSTERIP_HASHMODE_SIP_SPT &&\r\ncipinfo->hash_mode != CLUSTERIP_HASHMODE_SIP_SPT_DPT) {\r\npr_info("unknown mode %u\n", cipinfo->hash_mode);\r\nreturn -EINVAL;\r\n}\r\nif (e->ip.dmsk.s_addr != htonl(0xffffffff) ||\r\ne->ip.dst.s_addr == 0) {\r\npr_info("Please specify destination IP\n");\r\nreturn -EINVAL;\r\n}\r\nconfig = clusterip_config_find_get(par->net, e->ip.dst.s_addr, 1);\r\nif (!config) {\r\nif (!(cipinfo->flags & CLUSTERIP_FLAG_NEW)) {\r\npr_info("no config found for %pI4, need 'new'\n",\r\n&e->ip.dst.s_addr);\r\nreturn -EINVAL;\r\n} else {\r\nstruct net_device *dev;\r\nif (e->ip.iniface[0] == '\0') {\r\npr_info("Please specify an interface name\n");\r\nreturn -EINVAL;\r\n}\r\ndev = dev_get_by_name(par->net, e->ip.iniface);\r\nif (!dev) {\r\npr_info("no such interface %s\n",\r\ne->ip.iniface);\r\nreturn -ENOENT;\r\n}\r\nconfig = clusterip_config_init(cipinfo,\r\ne->ip.dst.s_addr, dev);\r\nif (!config) {\r\ndev_put(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev_mc_add(config->dev, config->clustermac);\r\n}\r\n}\r\ncipinfo->config = config;\r\nret = nf_ct_l3proto_try_module_get(par->family);\r\nif (ret < 0)\r\npr_info("cannot load conntrack support for proto=%u\n",\r\npar->family);\r\nreturn ret;\r\n}\r\nstatic void clusterip_tg_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nconst struct ipt_clusterip_tgt_info *cipinfo = par->targinfo;\r\nclusterip_config_entry_put(cipinfo->config);\r\nclusterip_config_put(cipinfo->config);\r\nnf_ct_l3proto_module_put(par->family);\r\n}\r\nstatic void arp_print(struct arp_payload *payload)\r\n{\r\n#define HBUFFERLEN 30\r\nchar hbuffer[HBUFFERLEN];\r\nint j,k;\r\nfor (k=0, j=0; k < HBUFFERLEN-3 && j < ETH_ALEN; j++) {\r\nhbuffer[k++] = hex_asc_hi(payload->src_hw[j]);\r\nhbuffer[k++] = hex_asc_lo(payload->src_hw[j]);\r\nhbuffer[k++]=':';\r\n}\r\nhbuffer[--k]='\0';\r\npr_debug("src %pI4@%s, dst %pI4\n",\r\n&payload->src_ip, hbuffer, &payload->dst_ip);\r\n}\r\nstatic unsigned int\r\narp_mangle(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct arphdr *arp = arp_hdr(skb);\r\nstruct arp_payload *payload;\r\nstruct clusterip_config *c;\r\nstruct net *net = dev_net(in ? in : out);\r\nif (arp->ar_hrd != htons(ARPHRD_ETHER) ||\r\narp->ar_pro != htons(ETH_P_IP) ||\r\narp->ar_pln != 4 || arp->ar_hln != ETH_ALEN)\r\nreturn NF_ACCEPT;\r\nif (arp->ar_op != htons(ARPOP_REPLY) &&\r\narp->ar_op != htons(ARPOP_REQUEST))\r\nreturn NF_ACCEPT;\r\npayload = (void *)(arp+1);\r\nc = clusterip_config_find_get(net, payload->src_ip, 0);\r\nif (!c)\r\nreturn NF_ACCEPT;\r\nif (c->dev != out) {\r\npr_debug("not mangling arp reply on different "\r\n"interface: cip'%s'-skb'%s'\n",\r\nc->dev->name, out->name);\r\nclusterip_config_put(c);\r\nreturn NF_ACCEPT;\r\n}\r\nmemcpy(payload->src_hw, c->clustermac, arp->ar_hln);\r\n#ifdef DEBUG\r\npr_debug("mangled arp reply: ");\r\narp_print(payload);\r\n#endif\r\nclusterip_config_put(c);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic void *clusterip_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct clusterip_config *c = s->private;\r\nunsigned int weight;\r\nu_int32_t local_nodes;\r\nstruct clusterip_seq_position *idx;\r\nlocal_nodes = c->local_nodes;\r\nweight = hweight32(local_nodes);\r\nif (*pos >= weight)\r\nreturn NULL;\r\nidx = kmalloc(sizeof(struct clusterip_seq_position), GFP_KERNEL);\r\nif (!idx)\r\nreturn ERR_PTR(-ENOMEM);\r\nidx->pos = *pos;\r\nidx->weight = weight;\r\nidx->bit = ffs(local_nodes);\r\nidx->val = local_nodes;\r\nclear_bit(idx->bit - 1, &idx->val);\r\nreturn idx;\r\n}\r\nstatic void *clusterip_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct clusterip_seq_position *idx = v;\r\n*pos = ++idx->pos;\r\nif (*pos >= idx->weight) {\r\nkfree(v);\r\nreturn NULL;\r\n}\r\nidx->bit = ffs(idx->val);\r\nclear_bit(idx->bit - 1, &idx->val);\r\nreturn idx;\r\n}\r\nstatic void clusterip_seq_stop(struct seq_file *s, void *v)\r\n{\r\nif (!IS_ERR(v))\r\nkfree(v);\r\n}\r\nstatic int clusterip_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct clusterip_seq_position *idx = v;\r\nif (idx->pos != 0)\r\nseq_putc(s, ',');\r\nseq_printf(s, "%u", idx->bit);\r\nif (idx->pos == idx->weight - 1)\r\nseq_putc(s, '\n');\r\nreturn 0;\r\n}\r\nstatic int clusterip_proc_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open(file, &clusterip_seq_ops);\r\nif (!ret) {\r\nstruct seq_file *sf = file->private_data;\r\nstruct clusterip_config *c = PDE_DATA(inode);\r\nsf->private = c;\r\nclusterip_config_get(c);\r\n}\r\nreturn ret;\r\n}\r\nstatic int clusterip_proc_release(struct inode *inode, struct file *file)\r\n{\r\nstruct clusterip_config *c = PDE_DATA(inode);\r\nint ret;\r\nret = seq_release(inode, file);\r\nif (!ret)\r\nclusterip_config_put(c);\r\nreturn ret;\r\n}\r\nstatic ssize_t clusterip_proc_write(struct file *file, const char __user *input,\r\nsize_t size, loff_t *ofs)\r\n{\r\nstruct clusterip_config *c = PDE_DATA(file_inode(file));\r\n#define PROC_WRITELEN 10\r\nchar buffer[PROC_WRITELEN+1];\r\nunsigned long nodenum;\r\nint rc;\r\nif (size > PROC_WRITELEN)\r\nreturn -EIO;\r\nif (copy_from_user(buffer, input, size))\r\nreturn -EFAULT;\r\nbuffer[size] = 0;\r\nif (*buffer == '+') {\r\nrc = kstrtoul(buffer+1, 10, &nodenum);\r\nif (rc)\r\nreturn rc;\r\nif (clusterip_add_node(c, nodenum))\r\nreturn -ENOMEM;\r\n} else if (*buffer == '-') {\r\nrc = kstrtoul(buffer+1, 10, &nodenum);\r\nif (rc)\r\nreturn rc;\r\nif (clusterip_del_node(c, nodenum))\r\nreturn -ENOENT;\r\n} else\r\nreturn -EIO;\r\nreturn size;\r\n}\r\nstatic int clusterip_net_init(struct net *net)\r\n{\r\nstruct clusterip_net *cn = net_generic(net, clusterip_net_id);\r\nINIT_LIST_HEAD(&cn->configs);\r\nspin_lock_init(&cn->lock);\r\n#ifdef CONFIG_PROC_FS\r\ncn->procdir = proc_mkdir("ipt_CLUSTERIP", net->proc_net);\r\nif (!cn->procdir) {\r\npr_err("Unable to proc dir entry\n");\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void clusterip_net_exit(struct net *net)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nstruct clusterip_net *cn = net_generic(net, clusterip_net_id);\r\nproc_remove(cn->procdir);\r\n#endif\r\n}\r\nstatic int __init clusterip_tg_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&clusterip_net_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nret = xt_register_target(&clusterip_tg_reg);\r\nif (ret < 0)\r\ngoto cleanup_subsys;\r\nret = nf_register_hook(&cip_arp_ops);\r\nif (ret < 0)\r\ngoto cleanup_target;\r\npr_info("ClusterIP Version %s loaded successfully\n",\r\nCLUSTERIP_VERSION);\r\nreturn 0;\r\ncleanup_target:\r\nxt_unregister_target(&clusterip_tg_reg);\r\ncleanup_subsys:\r\nunregister_pernet_subsys(&clusterip_net_ops);\r\nreturn ret;\r\n}\r\nstatic void __exit clusterip_tg_exit(void)\r\n{\r\npr_info("ClusterIP Version %s unloading\n", CLUSTERIP_VERSION);\r\nnf_unregister_hook(&cip_arp_ops);\r\nxt_unregister_target(&clusterip_tg_reg);\r\nunregister_pernet_subsys(&clusterip_net_ops);\r\nrcu_barrier_bh();\r\n}
