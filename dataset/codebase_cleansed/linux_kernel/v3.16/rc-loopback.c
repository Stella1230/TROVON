static int loop_set_tx_mask(struct rc_dev *dev, u32 mask)\r\n{\r\nstruct loopback_dev *lodev = dev->priv;\r\nif ((mask & (RXMASK_REGULAR | RXMASK_LEARNING)) != mask) {\r\ndprintk("invalid tx mask: %u\n", mask);\r\nreturn -EINVAL;\r\n}\r\ndprintk("setting tx mask: %u\n", mask);\r\nlodev->txmask = mask;\r\nreturn 0;\r\n}\r\nstatic int loop_set_tx_carrier(struct rc_dev *dev, u32 carrier)\r\n{\r\nstruct loopback_dev *lodev = dev->priv;\r\ndprintk("setting tx carrier: %u\n", carrier);\r\nlodev->txcarrier = carrier;\r\nreturn 0;\r\n}\r\nstatic int loop_set_tx_duty_cycle(struct rc_dev *dev, u32 duty_cycle)\r\n{\r\nstruct loopback_dev *lodev = dev->priv;\r\nif (duty_cycle < 1 || duty_cycle > 99) {\r\ndprintk("invalid duty cycle: %u\n", duty_cycle);\r\nreturn -EINVAL;\r\n}\r\ndprintk("setting duty cycle: %u\n", duty_cycle);\r\nlodev->txduty = duty_cycle;\r\nreturn 0;\r\n}\r\nstatic int loop_set_rx_carrier_range(struct rc_dev *dev, u32 min, u32 max)\r\n{\r\nstruct loopback_dev *lodev = dev->priv;\r\nif (min < 1 || min > max) {\r\ndprintk("invalid rx carrier range %u to %u\n", min, max);\r\nreturn -EINVAL;\r\n}\r\ndprintk("setting rx carrier range %u to %u\n", min, max);\r\nlodev->rxcarriermin = min;\r\nlodev->rxcarriermax = max;\r\nreturn 0;\r\n}\r\nstatic int loop_tx_ir(struct rc_dev *dev, unsigned *txbuf, unsigned count)\r\n{\r\nstruct loopback_dev *lodev = dev->priv;\r\nu32 rxmask;\r\nunsigned i;\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nif (lodev->txcarrier < lodev->rxcarriermin ||\r\nlodev->txcarrier > lodev->rxcarriermax) {\r\ndprintk("ignoring tx, carrier out of range\n");\r\ngoto out;\r\n}\r\nif (lodev->learning)\r\nrxmask = RXMASK_LEARNING;\r\nelse\r\nrxmask = RXMASK_REGULAR;\r\nif (!(rxmask & lodev->txmask)) {\r\ndprintk("ignoring tx, rx mask mismatch\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nrawir.pulse = i % 2 ? false : true;\r\nrawir.duration = txbuf[i] * 1000;\r\nif (rawir.duration)\r\nir_raw_event_store_with_filter(dev, &rawir);\r\n}\r\nrawir.pulse = false;\r\nrawir.duration = dev->timeout;\r\nir_raw_event_store_with_filter(dev, &rawir);\r\nir_raw_event_handle(dev);\r\nout:\r\nreturn count;\r\n}\r\nstatic void loop_set_idle(struct rc_dev *dev, bool enable)\r\n{\r\nstruct loopback_dev *lodev = dev->priv;\r\nif (lodev->idle != enable) {\r\ndprintk("%sing idle mode\n", enable ? "enter" : "exit");\r\nlodev->idle = enable;\r\n}\r\n}\r\nstatic int loop_set_learning_mode(struct rc_dev *dev, int enable)\r\n{\r\nstruct loopback_dev *lodev = dev->priv;\r\nif (lodev->learning != enable) {\r\ndprintk("%sing learning mode\n", enable ? "enter" : "exit");\r\nlodev->learning = !!enable;\r\n}\r\nreturn 0;\r\n}\r\nstatic int loop_set_carrier_report(struct rc_dev *dev, int enable)\r\n{\r\nstruct loopback_dev *lodev = dev->priv;\r\nif (lodev->carrierreport != enable) {\r\ndprintk("%sabling carrier reports\n", enable ? "en" : "dis");\r\nlodev->carrierreport = !!enable;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init loop_init(void)\r\n{\r\nstruct rc_dev *rc;\r\nint ret;\r\nrc = rc_allocate_device();\r\nif (!rc) {\r\nprintk(KERN_ERR DRIVER_NAME ": rc_dev allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nrc->input_name = "rc-core loopback device";\r\nrc->input_phys = "rc-core/virtual";\r\nrc->input_id.bustype = BUS_VIRTUAL;\r\nrc->input_id.version = 1;\r\nrc->driver_name = DRIVER_NAME;\r\nrc->map_name = RC_MAP_EMPTY;\r\nrc->priv = &loopdev;\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc_set_allowed_protocols(rc, RC_BIT_ALL);\r\nrc->timeout = 100 * 1000 * 1000;\r\nrc->min_timeout = 1;\r\nrc->max_timeout = UINT_MAX;\r\nrc->rx_resolution = 1000;\r\nrc->tx_resolution = 1000;\r\nrc->s_tx_mask = loop_set_tx_mask;\r\nrc->s_tx_carrier = loop_set_tx_carrier;\r\nrc->s_tx_duty_cycle = loop_set_tx_duty_cycle;\r\nrc->s_rx_carrier_range = loop_set_rx_carrier_range;\r\nrc->tx_ir = loop_tx_ir;\r\nrc->s_idle = loop_set_idle;\r\nrc->s_learning_mode = loop_set_learning_mode;\r\nrc->s_carrier_report = loop_set_carrier_report;\r\nloopdev.txmask = RXMASK_REGULAR;\r\nloopdev.txcarrier = 36000;\r\nloopdev.txduty = 50;\r\nloopdev.rxcarriermin = 1;\r\nloopdev.rxcarriermax = ~0;\r\nloopdev.idle = true;\r\nloopdev.learning = false;\r\nloopdev.carrierreport = false;\r\nret = rc_register_device(rc);\r\nif (ret < 0) {\r\nprintk(KERN_ERR DRIVER_NAME ": rc_dev registration failed\n");\r\nrc_free_device(rc);\r\nreturn ret;\r\n}\r\nloopdev.dev = rc;\r\nreturn 0;\r\n}\r\nstatic void __exit loop_exit(void)\r\n{\r\nrc_unregister_device(loopdev.dev);\r\n}
