static struct sk_buff *dcbnl_newmsg(int type, u8 cmd, u32 port, u32 seq,\r\nu32 flags, struct nlmsghdr **nlhp)\r\n{\r\nstruct sk_buff *skb;\r\nstruct dcbmsg *dcb;\r\nstruct nlmsghdr *nlh;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn NULL;\r\nnlh = nlmsg_put(skb, port, seq, type, sizeof(*dcb), flags);\r\nBUG_ON(!nlh);\r\ndcb = nlmsg_data(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = cmd;\r\ndcb->dcb_pad = 0;\r\nif (nlhp)\r\n*nlhp = nlh;\r\nreturn skb;\r\n}\r\nstatic int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nif (!netdev->dcbnl_ops->getstate)\r\nreturn -EOPNOTSUPP;\r\nreturn nla_put_u8(skb, DCB_ATTR_STATE,\r\nnetdev->dcbnl_ops->getstate(netdev));\r\n}\r\nstatic int dcbnl_getpfccfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nstruct nlattr *data[DCB_PFC_UP_ATTR_MAX + 1], *nest;\r\nu8 value;\r\nint ret;\r\nint i;\r\nint getall = 0;\r\nif (!tb[DCB_ATTR_PFC_CFG])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->getpfccfg)\r\nreturn -EOPNOTSUPP;\r\nret = nla_parse_nested(data, DCB_PFC_UP_ATTR_MAX,\r\ntb[DCB_ATTR_PFC_CFG],\r\ndcbnl_pfc_up_nest);\r\nif (ret)\r\nreturn ret;\r\nnest = nla_nest_start(skb, DCB_ATTR_PFC_CFG);\r\nif (!nest)\r\nreturn -EMSGSIZE;\r\nif (data[DCB_PFC_UP_ATTR_ALL])\r\ngetall = 1;\r\nfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\r\nif (!getall && !data[i])\r\ncontinue;\r\nnetdev->dcbnl_ops->getpfccfg(netdev, i - DCB_PFC_UP_ATTR_0,\r\n&value);\r\nret = nla_put_u8(skb, i, value);\r\nif (ret) {\r\nnla_nest_cancel(skb, nest);\r\nreturn ret;\r\n}\r\n}\r\nnla_nest_end(skb, nest);\r\nreturn 0;\r\n}\r\nstatic int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nu8 perm_addr[MAX_ADDR_LEN];\r\nif (!netdev->dcbnl_ops->getpermhwaddr)\r\nreturn -EOPNOTSUPP;\r\nmemset(perm_addr, 0, sizeof(perm_addr));\r\nnetdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);\r\nreturn nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);\r\n}\r\nstatic int dcbnl_getcap(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nstruct nlattr *data[DCB_CAP_ATTR_MAX + 1], *nest;\r\nu8 value;\r\nint ret;\r\nint i;\r\nint getall = 0;\r\nif (!tb[DCB_ATTR_CAP])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->getcap)\r\nreturn -EOPNOTSUPP;\r\nret = nla_parse_nested(data, DCB_CAP_ATTR_MAX, tb[DCB_ATTR_CAP],\r\ndcbnl_cap_nest);\r\nif (ret)\r\nreturn ret;\r\nnest = nla_nest_start(skb, DCB_ATTR_CAP);\r\nif (!nest)\r\nreturn -EMSGSIZE;\r\nif (data[DCB_CAP_ATTR_ALL])\r\ngetall = 1;\r\nfor (i = DCB_CAP_ATTR_ALL+1; i <= DCB_CAP_ATTR_MAX; i++) {\r\nif (!getall && !data[i])\r\ncontinue;\r\nif (!netdev->dcbnl_ops->getcap(netdev, i, &value)) {\r\nret = nla_put_u8(skb, i, value);\r\nif (ret) {\r\nnla_nest_cancel(skb, nest);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nnla_nest_end(skb, nest);\r\nreturn 0;\r\n}\r\nstatic int dcbnl_getnumtcs(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nstruct nlattr *data[DCB_NUMTCS_ATTR_MAX + 1], *nest;\r\nu8 value;\r\nint ret;\r\nint i;\r\nint getall = 0;\r\nif (!tb[DCB_ATTR_NUMTCS])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->getnumtcs)\r\nreturn -EOPNOTSUPP;\r\nret = nla_parse_nested(data, DCB_NUMTCS_ATTR_MAX, tb[DCB_ATTR_NUMTCS],\r\ndcbnl_numtcs_nest);\r\nif (ret)\r\nreturn ret;\r\nnest = nla_nest_start(skb, DCB_ATTR_NUMTCS);\r\nif (!nest)\r\nreturn -EMSGSIZE;\r\nif (data[DCB_NUMTCS_ATTR_ALL])\r\ngetall = 1;\r\nfor (i = DCB_NUMTCS_ATTR_ALL+1; i <= DCB_NUMTCS_ATTR_MAX; i++) {\r\nif (!getall && !data[i])\r\ncontinue;\r\nret = netdev->dcbnl_ops->getnumtcs(netdev, i, &value);\r\nif (!ret) {\r\nret = nla_put_u8(skb, i, value);\r\nif (ret) {\r\nnla_nest_cancel(skb, nest);\r\nreturn ret;\r\n}\r\n} else\r\nreturn -EINVAL;\r\n}\r\nnla_nest_end(skb, nest);\r\nreturn 0;\r\n}\r\nstatic int dcbnl_setnumtcs(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nstruct nlattr *data[DCB_NUMTCS_ATTR_MAX + 1];\r\nint ret;\r\nu8 value;\r\nint i;\r\nif (!tb[DCB_ATTR_NUMTCS])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->setnumtcs)\r\nreturn -EOPNOTSUPP;\r\nret = nla_parse_nested(data, DCB_NUMTCS_ATTR_MAX, tb[DCB_ATTR_NUMTCS],\r\ndcbnl_numtcs_nest);\r\nif (ret)\r\nreturn ret;\r\nfor (i = DCB_NUMTCS_ATTR_ALL+1; i <= DCB_NUMTCS_ATTR_MAX; i++) {\r\nif (data[i] == NULL)\r\ncontinue;\r\nvalue = nla_get_u8(data[i]);\r\nret = netdev->dcbnl_ops->setnumtcs(netdev, i, value);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn nla_put_u8(skb, DCB_ATTR_NUMTCS, !!ret);\r\n}\r\nstatic int dcbnl_getpfcstate(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nif (!netdev->dcbnl_ops->getpfcstate)\r\nreturn -EOPNOTSUPP;\r\nreturn nla_put_u8(skb, DCB_ATTR_PFC_STATE,\r\nnetdev->dcbnl_ops->getpfcstate(netdev));\r\n}\r\nstatic int dcbnl_setpfcstate(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nu8 value;\r\nif (!tb[DCB_ATTR_PFC_STATE])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->setpfcstate)\r\nreturn -EOPNOTSUPP;\r\nvalue = nla_get_u8(tb[DCB_ATTR_PFC_STATE]);\r\nnetdev->dcbnl_ops->setpfcstate(netdev, value);\r\nreturn nla_put_u8(skb, DCB_ATTR_PFC_STATE, 0);\r\n}\r\nstatic int dcbnl_getapp(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nstruct nlattr *app_nest;\r\nstruct nlattr *app_tb[DCB_APP_ATTR_MAX + 1];\r\nu16 id;\r\nu8 up, idtype;\r\nint ret;\r\nif (!tb[DCB_ATTR_APP])\r\nreturn -EINVAL;\r\nret = nla_parse_nested(app_tb, DCB_APP_ATTR_MAX, tb[DCB_ATTR_APP],\r\ndcbnl_app_nest);\r\nif (ret)\r\nreturn ret;\r\nif ((!app_tb[DCB_APP_ATTR_IDTYPE]) ||\r\n(!app_tb[DCB_APP_ATTR_ID]))\r\nreturn -EINVAL;\r\nidtype = nla_get_u8(app_tb[DCB_APP_ATTR_IDTYPE]);\r\nif ((idtype != DCB_APP_IDTYPE_ETHTYPE) &&\r\n(idtype != DCB_APP_IDTYPE_PORTNUM))\r\nreturn -EINVAL;\r\nid = nla_get_u16(app_tb[DCB_APP_ATTR_ID]);\r\nif (netdev->dcbnl_ops->getapp) {\r\nup = netdev->dcbnl_ops->getapp(netdev, idtype, id);\r\n} else {\r\nstruct dcb_app app = {\r\n.selector = idtype,\r\n.protocol = id,\r\n};\r\nup = dcb_getapp(netdev, &app);\r\n}\r\napp_nest = nla_nest_start(skb, DCB_ATTR_APP);\r\nif (!app_nest)\r\nreturn -EMSGSIZE;\r\nret = nla_put_u8(skb, DCB_APP_ATTR_IDTYPE, idtype);\r\nif (ret)\r\ngoto out_cancel;\r\nret = nla_put_u16(skb, DCB_APP_ATTR_ID, id);\r\nif (ret)\r\ngoto out_cancel;\r\nret = nla_put_u8(skb, DCB_APP_ATTR_PRIORITY, up);\r\nif (ret)\r\ngoto out_cancel;\r\nnla_nest_end(skb, app_nest);\r\nreturn 0;\r\nout_cancel:\r\nnla_nest_cancel(skb, app_nest);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_setapp(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nint ret;\r\nu16 id;\r\nu8 up, idtype;\r\nstruct nlattr *app_tb[DCB_APP_ATTR_MAX + 1];\r\nif (!tb[DCB_ATTR_APP])\r\nreturn -EINVAL;\r\nret = nla_parse_nested(app_tb, DCB_APP_ATTR_MAX, tb[DCB_ATTR_APP],\r\ndcbnl_app_nest);\r\nif (ret)\r\nreturn ret;\r\nif ((!app_tb[DCB_APP_ATTR_IDTYPE]) ||\r\n(!app_tb[DCB_APP_ATTR_ID]) ||\r\n(!app_tb[DCB_APP_ATTR_PRIORITY]))\r\nreturn -EINVAL;\r\nidtype = nla_get_u8(app_tb[DCB_APP_ATTR_IDTYPE]);\r\nif ((idtype != DCB_APP_IDTYPE_ETHTYPE) &&\r\n(idtype != DCB_APP_IDTYPE_PORTNUM))\r\nreturn -EINVAL;\r\nid = nla_get_u16(app_tb[DCB_APP_ATTR_ID]);\r\nup = nla_get_u8(app_tb[DCB_APP_ATTR_PRIORITY]);\r\nif (netdev->dcbnl_ops->setapp) {\r\nret = netdev->dcbnl_ops->setapp(netdev, idtype, id, up);\r\n} else {\r\nstruct dcb_app app;\r\napp.selector = idtype;\r\napp.protocol = id;\r\napp.priority = up;\r\nret = dcb_setapp(netdev, &app);\r\n}\r\nret = nla_put_u8(skb, DCB_ATTR_APP, ret);\r\ndcbnl_cee_notify(netdev, RTM_SETDCB, DCB_CMD_SAPP, seq, 0);\r\nreturn ret;\r\n}\r\nstatic int __dcbnl_pg_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nstruct nlattr **tb, struct sk_buff *skb, int dir)\r\n{\r\nstruct nlattr *pg_nest, *param_nest, *data;\r\nstruct nlattr *pg_tb[DCB_PG_ATTR_MAX + 1];\r\nstruct nlattr *param_tb[DCB_TC_ATTR_PARAM_MAX + 1];\r\nu8 prio, pgid, tc_pct, up_map;\r\nint ret;\r\nint getall = 0;\r\nint i;\r\nif (!tb[DCB_ATTR_PG_CFG])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->getpgtccfgtx ||\r\n!netdev->dcbnl_ops->getpgtccfgrx ||\r\n!netdev->dcbnl_ops->getpgbwgcfgtx ||\r\n!netdev->dcbnl_ops->getpgbwgcfgrx)\r\nreturn -EOPNOTSUPP;\r\nret = nla_parse_nested(pg_tb, DCB_PG_ATTR_MAX,\r\ntb[DCB_ATTR_PG_CFG], dcbnl_pg_nest);\r\nif (ret)\r\nreturn ret;\r\npg_nest = nla_nest_start(skb, DCB_ATTR_PG_CFG);\r\nif (!pg_nest)\r\nreturn -EMSGSIZE;\r\nif (pg_tb[DCB_PG_ATTR_TC_ALL])\r\ngetall = 1;\r\nfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\r\nif (!getall && !pg_tb[i])\r\ncontinue;\r\nif (pg_tb[DCB_PG_ATTR_TC_ALL])\r\ndata = pg_tb[DCB_PG_ATTR_TC_ALL];\r\nelse\r\ndata = pg_tb[i];\r\nret = nla_parse_nested(param_tb, DCB_TC_ATTR_PARAM_MAX,\r\ndata, dcbnl_tc_param_nest);\r\nif (ret)\r\ngoto err_pg;\r\nparam_nest = nla_nest_start(skb, i);\r\nif (!param_nest)\r\ngoto err_pg;\r\npgid = DCB_ATTR_VALUE_UNDEFINED;\r\nprio = DCB_ATTR_VALUE_UNDEFINED;\r\ntc_pct = DCB_ATTR_VALUE_UNDEFINED;\r\nup_map = DCB_ATTR_VALUE_UNDEFINED;\r\nif (dir) {\r\nnetdev->dcbnl_ops->getpgtccfgrx(netdev,\r\ni - DCB_PG_ATTR_TC_0, &prio,\r\n&pgid, &tc_pct, &up_map);\r\n} else {\r\nnetdev->dcbnl_ops->getpgtccfgtx(netdev,\r\ni - DCB_PG_ATTR_TC_0, &prio,\r\n&pgid, &tc_pct, &up_map);\r\n}\r\nif (param_tb[DCB_TC_ATTR_PARAM_PGID] ||\r\nparam_tb[DCB_TC_ATTR_PARAM_ALL]) {\r\nret = nla_put_u8(skb,\r\nDCB_TC_ATTR_PARAM_PGID, pgid);\r\nif (ret)\r\ngoto err_param;\r\n}\r\nif (param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING] ||\r\nparam_tb[DCB_TC_ATTR_PARAM_ALL]) {\r\nret = nla_put_u8(skb,\r\nDCB_TC_ATTR_PARAM_UP_MAPPING, up_map);\r\nif (ret)\r\ngoto err_param;\r\n}\r\nif (param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO] ||\r\nparam_tb[DCB_TC_ATTR_PARAM_ALL]) {\r\nret = nla_put_u8(skb,\r\nDCB_TC_ATTR_PARAM_STRICT_PRIO, prio);\r\nif (ret)\r\ngoto err_param;\r\n}\r\nif (param_tb[DCB_TC_ATTR_PARAM_BW_PCT] ||\r\nparam_tb[DCB_TC_ATTR_PARAM_ALL]) {\r\nret = nla_put_u8(skb, DCB_TC_ATTR_PARAM_BW_PCT,\r\ntc_pct);\r\nif (ret)\r\ngoto err_param;\r\n}\r\nnla_nest_end(skb, param_nest);\r\n}\r\nif (pg_tb[DCB_PG_ATTR_BW_ID_ALL])\r\ngetall = 1;\r\nelse\r\ngetall = 0;\r\nfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\r\nif (!getall && !pg_tb[i])\r\ncontinue;\r\ntc_pct = DCB_ATTR_VALUE_UNDEFINED;\r\nif (dir) {\r\nnetdev->dcbnl_ops->getpgbwgcfgrx(netdev,\r\ni - DCB_PG_ATTR_BW_ID_0, &tc_pct);\r\n} else {\r\nnetdev->dcbnl_ops->getpgbwgcfgtx(netdev,\r\ni - DCB_PG_ATTR_BW_ID_0, &tc_pct);\r\n}\r\nret = nla_put_u8(skb, i, tc_pct);\r\nif (ret)\r\ngoto err_pg;\r\n}\r\nnla_nest_end(skb, pg_nest);\r\nreturn 0;\r\nerr_param:\r\nnla_nest_cancel(skb, param_nest);\r\nerr_pg:\r\nnla_nest_cancel(skb, pg_nest);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int dcbnl_pgtx_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nreturn __dcbnl_pg_getcfg(netdev, nlh, tb, skb, 0);\r\n}\r\nstatic int dcbnl_pgrx_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nreturn __dcbnl_pg_getcfg(netdev, nlh, tb, skb, 1);\r\n}\r\nstatic int dcbnl_setstate(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nu8 value;\r\nif (!tb[DCB_ATTR_STATE])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->setstate)\r\nreturn -EOPNOTSUPP;\r\nvalue = nla_get_u8(tb[DCB_ATTR_STATE]);\r\nreturn nla_put_u8(skb, DCB_ATTR_STATE,\r\nnetdev->dcbnl_ops->setstate(netdev, value));\r\n}\r\nstatic int dcbnl_setpfccfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nstruct nlattr *data[DCB_PFC_UP_ATTR_MAX + 1];\r\nint i;\r\nint ret;\r\nu8 value;\r\nif (!tb[DCB_ATTR_PFC_CFG])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->setpfccfg)\r\nreturn -EOPNOTSUPP;\r\nret = nla_parse_nested(data, DCB_PFC_UP_ATTR_MAX,\r\ntb[DCB_ATTR_PFC_CFG],\r\ndcbnl_pfc_up_nest);\r\nif (ret)\r\nreturn ret;\r\nfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\r\nif (data[i] == NULL)\r\ncontinue;\r\nvalue = nla_get_u8(data[i]);\r\nnetdev->dcbnl_ops->setpfccfg(netdev,\r\ndata[i]->nla_type - DCB_PFC_UP_ATTR_0, value);\r\n}\r\nreturn nla_put_u8(skb, DCB_ATTR_PFC_CFG, 0);\r\n}\r\nstatic int dcbnl_setall(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nint ret;\r\nif (!tb[DCB_ATTR_SET_ALL])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->setall)\r\nreturn -EOPNOTSUPP;\r\nret = nla_put_u8(skb, DCB_ATTR_SET_ALL,\r\nnetdev->dcbnl_ops->setall(netdev));\r\ndcbnl_cee_notify(netdev, RTM_SETDCB, DCB_CMD_SET_ALL, seq, 0);\r\nreturn ret;\r\n}\r\nstatic int __dcbnl_pg_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb,\r\nint dir)\r\n{\r\nstruct nlattr *pg_tb[DCB_PG_ATTR_MAX + 1];\r\nstruct nlattr *param_tb[DCB_TC_ATTR_PARAM_MAX + 1];\r\nint ret;\r\nint i;\r\nu8 pgid;\r\nu8 up_map;\r\nu8 prio;\r\nu8 tc_pct;\r\nif (!tb[DCB_ATTR_PG_CFG])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->setpgtccfgtx ||\r\n!netdev->dcbnl_ops->setpgtccfgrx ||\r\n!netdev->dcbnl_ops->setpgbwgcfgtx ||\r\n!netdev->dcbnl_ops->setpgbwgcfgrx)\r\nreturn -EOPNOTSUPP;\r\nret = nla_parse_nested(pg_tb, DCB_PG_ATTR_MAX,\r\ntb[DCB_ATTR_PG_CFG], dcbnl_pg_nest);\r\nif (ret)\r\nreturn ret;\r\nfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\r\nif (!pg_tb[i])\r\ncontinue;\r\nret = nla_parse_nested(param_tb, DCB_TC_ATTR_PARAM_MAX,\r\npg_tb[i], dcbnl_tc_param_nest);\r\nif (ret)\r\nreturn ret;\r\npgid = DCB_ATTR_VALUE_UNDEFINED;\r\nprio = DCB_ATTR_VALUE_UNDEFINED;\r\ntc_pct = DCB_ATTR_VALUE_UNDEFINED;\r\nup_map = DCB_ATTR_VALUE_UNDEFINED;\r\nif (param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO])\r\nprio =\r\nnla_get_u8(param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO]);\r\nif (param_tb[DCB_TC_ATTR_PARAM_PGID])\r\npgid = nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_PGID]);\r\nif (param_tb[DCB_TC_ATTR_PARAM_BW_PCT])\r\ntc_pct = nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_BW_PCT]);\r\nif (param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING])\r\nup_map =\r\nnla_get_u8(param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING]);\r\nif (dir) {\r\nnetdev->dcbnl_ops->setpgtccfgrx(netdev,\r\ni - DCB_PG_ATTR_TC_0,\r\nprio, pgid, tc_pct, up_map);\r\n} else {\r\nnetdev->dcbnl_ops->setpgtccfgtx(netdev,\r\ni - DCB_PG_ATTR_TC_0,\r\nprio, pgid, tc_pct, up_map);\r\n}\r\n}\r\nfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\r\nif (!pg_tb[i])\r\ncontinue;\r\ntc_pct = nla_get_u8(pg_tb[i]);\r\nif (dir) {\r\nnetdev->dcbnl_ops->setpgbwgcfgrx(netdev,\r\ni - DCB_PG_ATTR_BW_ID_0, tc_pct);\r\n} else {\r\nnetdev->dcbnl_ops->setpgbwgcfgtx(netdev,\r\ni - DCB_PG_ATTR_BW_ID_0, tc_pct);\r\n}\r\n}\r\nreturn nla_put_u8(skb, DCB_ATTR_PG_CFG, 0);\r\n}\r\nstatic int dcbnl_pgtx_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nreturn __dcbnl_pg_setcfg(netdev, nlh, seq, tb, skb, 0);\r\n}\r\nstatic int dcbnl_pgrx_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nreturn __dcbnl_pg_setcfg(netdev, nlh, seq, tb, skb, 1);\r\n}\r\nstatic int dcbnl_bcn_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nstruct nlattr *bcn_nest;\r\nstruct nlattr *bcn_tb[DCB_BCN_ATTR_MAX + 1];\r\nu8 value_byte;\r\nu32 value_integer;\r\nint ret;\r\nbool getall = false;\r\nint i;\r\nif (!tb[DCB_ATTR_BCN])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->getbcnrp ||\r\n!netdev->dcbnl_ops->getbcncfg)\r\nreturn -EOPNOTSUPP;\r\nret = nla_parse_nested(bcn_tb, DCB_BCN_ATTR_MAX,\r\ntb[DCB_ATTR_BCN], dcbnl_bcn_nest);\r\nif (ret)\r\nreturn ret;\r\nbcn_nest = nla_nest_start(skb, DCB_ATTR_BCN);\r\nif (!bcn_nest)\r\nreturn -EMSGSIZE;\r\nif (bcn_tb[DCB_BCN_ATTR_ALL])\r\ngetall = true;\r\nfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\r\nif (!getall && !bcn_tb[i])\r\ncontinue;\r\nnetdev->dcbnl_ops->getbcnrp(netdev, i - DCB_BCN_ATTR_RP_0,\r\n&value_byte);\r\nret = nla_put_u8(skb, i, value_byte);\r\nif (ret)\r\ngoto err_bcn;\r\n}\r\nfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\r\nif (!getall && !bcn_tb[i])\r\ncontinue;\r\nnetdev->dcbnl_ops->getbcncfg(netdev, i,\r\n&value_integer);\r\nret = nla_put_u32(skb, i, value_integer);\r\nif (ret)\r\ngoto err_bcn;\r\n}\r\nnla_nest_end(skb, bcn_nest);\r\nreturn 0;\r\nerr_bcn:\r\nnla_nest_cancel(skb, bcn_nest);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_bcn_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nstruct nlattr *data[DCB_BCN_ATTR_MAX + 1];\r\nint i;\r\nint ret;\r\nu8 value_byte;\r\nu32 value_int;\r\nif (!tb[DCB_ATTR_BCN])\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops->setbcncfg ||\r\n!netdev->dcbnl_ops->setbcnrp)\r\nreturn -EOPNOTSUPP;\r\nret = nla_parse_nested(data, DCB_BCN_ATTR_MAX,\r\ntb[DCB_ATTR_BCN],\r\ndcbnl_pfc_up_nest);\r\nif (ret)\r\nreturn ret;\r\nfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\r\nif (data[i] == NULL)\r\ncontinue;\r\nvalue_byte = nla_get_u8(data[i]);\r\nnetdev->dcbnl_ops->setbcnrp(netdev,\r\ndata[i]->nla_type - DCB_BCN_ATTR_RP_0, value_byte);\r\n}\r\nfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\r\nif (data[i] == NULL)\r\ncontinue;\r\nvalue_int = nla_get_u32(data[i]);\r\nnetdev->dcbnl_ops->setbcncfg(netdev,\r\ni, value_int);\r\n}\r\nreturn nla_put_u8(skb, DCB_ATTR_BCN, 0);\r\n}\r\nstatic int dcbnl_build_peer_app(struct net_device *netdev, struct sk_buff* skb,\r\nint app_nested_type, int app_info_type,\r\nint app_entry_type)\r\n{\r\nstruct dcb_peer_app_info info;\r\nstruct dcb_app *table = NULL;\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nu16 app_count;\r\nint err;\r\nerr = ops->peer_getappinfo(netdev, &info, &app_count);\r\nif (!err && app_count) {\r\ntable = kmalloc(sizeof(struct dcb_app) * app_count, GFP_KERNEL);\r\nif (!table)\r\nreturn -ENOMEM;\r\nerr = ops->peer_getapptable(netdev, table);\r\n}\r\nif (!err) {\r\nu16 i;\r\nstruct nlattr *app;\r\nerr = -EMSGSIZE;\r\napp = nla_nest_start(skb, app_nested_type);\r\nif (!app)\r\ngoto nla_put_failure;\r\nif (app_info_type &&\r\nnla_put(skb, app_info_type, sizeof(info), &info))\r\ngoto nla_put_failure;\r\nfor (i = 0; i < app_count; i++) {\r\nif (nla_put(skb, app_entry_type, sizeof(struct dcb_app),\r\n&table[i]))\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, app);\r\n}\r\nerr = 0;\r\nnla_put_failure:\r\nkfree(table);\r\nreturn err;\r\n}\r\nstatic int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct nlattr *ieee, *app;\r\nstruct dcb_app_type *itr;\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nint dcbx;\r\nint err;\r\nif (nla_put_string(skb, DCB_ATTR_IFNAME, netdev->name))\r\nreturn -EMSGSIZE;\r\nieee = nla_nest_start(skb, DCB_ATTR_IEEE);\r\nif (!ieee)\r\nreturn -EMSGSIZE;\r\nif (ops->ieee_getets) {\r\nstruct ieee_ets ets;\r\nmemset(&ets, 0, sizeof(ets));\r\nerr = ops->ieee_getets(netdev, &ets);\r\nif (!err &&\r\nnla_put(skb, DCB_ATTR_IEEE_ETS, sizeof(ets), &ets))\r\nreturn -EMSGSIZE;\r\n}\r\nif (ops->ieee_getmaxrate) {\r\nstruct ieee_maxrate maxrate;\r\nmemset(&maxrate, 0, sizeof(maxrate));\r\nerr = ops->ieee_getmaxrate(netdev, &maxrate);\r\nif (!err) {\r\nerr = nla_put(skb, DCB_ATTR_IEEE_MAXRATE,\r\nsizeof(maxrate), &maxrate);\r\nif (err)\r\nreturn -EMSGSIZE;\r\n}\r\n}\r\nif (ops->ieee_getpfc) {\r\nstruct ieee_pfc pfc;\r\nmemset(&pfc, 0, sizeof(pfc));\r\nerr = ops->ieee_getpfc(netdev, &pfc);\r\nif (!err &&\r\nnla_put(skb, DCB_ATTR_IEEE_PFC, sizeof(pfc), &pfc))\r\nreturn -EMSGSIZE;\r\n}\r\napp = nla_nest_start(skb, DCB_ATTR_IEEE_APP_TABLE);\r\nif (!app)\r\nreturn -EMSGSIZE;\r\nspin_lock(&dcb_lock);\r\nlist_for_each_entry(itr, &dcb_app_list, list) {\r\nif (itr->ifindex == netdev->ifindex) {\r\nerr = nla_put(skb, DCB_ATTR_IEEE_APP, sizeof(itr->app),\r\n&itr->app);\r\nif (err) {\r\nspin_unlock(&dcb_lock);\r\nreturn -EMSGSIZE;\r\n}\r\n}\r\n}\r\nif (netdev->dcbnl_ops->getdcbx)\r\ndcbx = netdev->dcbnl_ops->getdcbx(netdev);\r\nelse\r\ndcbx = -EOPNOTSUPP;\r\nspin_unlock(&dcb_lock);\r\nnla_nest_end(skb, app);\r\nif (ops->ieee_peer_getets) {\r\nstruct ieee_ets ets;\r\nmemset(&ets, 0, sizeof(ets));\r\nerr = ops->ieee_peer_getets(netdev, &ets);\r\nif (!err &&\r\nnla_put(skb, DCB_ATTR_IEEE_PEER_ETS, sizeof(ets), &ets))\r\nreturn -EMSGSIZE;\r\n}\r\nif (ops->ieee_peer_getpfc) {\r\nstruct ieee_pfc pfc;\r\nmemset(&pfc, 0, sizeof(pfc));\r\nerr = ops->ieee_peer_getpfc(netdev, &pfc);\r\nif (!err &&\r\nnla_put(skb, DCB_ATTR_IEEE_PEER_PFC, sizeof(pfc), &pfc))\r\nreturn -EMSGSIZE;\r\n}\r\nif (ops->peer_getappinfo && ops->peer_getapptable) {\r\nerr = dcbnl_build_peer_app(netdev, skb,\r\nDCB_ATTR_IEEE_PEER_APP,\r\nDCB_ATTR_IEEE_APP_UNSPEC,\r\nDCB_ATTR_IEEE_APP);\r\nif (err)\r\nreturn -EMSGSIZE;\r\n}\r\nnla_nest_end(skb, ieee);\r\nif (dcbx >= 0) {\r\nerr = nla_put_u8(skb, DCB_ATTR_DCBX, dcbx);\r\nif (err)\r\nreturn -EMSGSIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dcbnl_cee_pg_fill(struct sk_buff *skb, struct net_device *dev,\r\nint dir)\r\n{\r\nu8 pgid, up_map, prio, tc_pct;\r\nconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\r\nint i = dir ? DCB_ATTR_CEE_TX_PG : DCB_ATTR_CEE_RX_PG;\r\nstruct nlattr *pg = nla_nest_start(skb, i);\r\nif (!pg)\r\nreturn -EMSGSIZE;\r\nfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\r\nstruct nlattr *tc_nest = nla_nest_start(skb, i);\r\nif (!tc_nest)\r\nreturn -EMSGSIZE;\r\npgid = DCB_ATTR_VALUE_UNDEFINED;\r\nprio = DCB_ATTR_VALUE_UNDEFINED;\r\ntc_pct = DCB_ATTR_VALUE_UNDEFINED;\r\nup_map = DCB_ATTR_VALUE_UNDEFINED;\r\nif (!dir)\r\nops->getpgtccfgrx(dev, i - DCB_PG_ATTR_TC_0,\r\n&prio, &pgid, &tc_pct, &up_map);\r\nelse\r\nops->getpgtccfgtx(dev, i - DCB_PG_ATTR_TC_0,\r\n&prio, &pgid, &tc_pct, &up_map);\r\nif (nla_put_u8(skb, DCB_TC_ATTR_PARAM_PGID, pgid) ||\r\nnla_put_u8(skb, DCB_TC_ATTR_PARAM_UP_MAPPING, up_map) ||\r\nnla_put_u8(skb, DCB_TC_ATTR_PARAM_STRICT_PRIO, prio) ||\r\nnla_put_u8(skb, DCB_TC_ATTR_PARAM_BW_PCT, tc_pct))\r\nreturn -EMSGSIZE;\r\nnla_nest_end(skb, tc_nest);\r\n}\r\nfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\r\ntc_pct = DCB_ATTR_VALUE_UNDEFINED;\r\nif (!dir)\r\nops->getpgbwgcfgrx(dev, i - DCB_PG_ATTR_BW_ID_0,\r\n&tc_pct);\r\nelse\r\nops->getpgbwgcfgtx(dev, i - DCB_PG_ATTR_BW_ID_0,\r\n&tc_pct);\r\nif (nla_put_u8(skb, i, tc_pct))\r\nreturn -EMSGSIZE;\r\n}\r\nnla_nest_end(skb, pg);\r\nreturn 0;\r\n}\r\nstatic int dcbnl_cee_fill(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct nlattr *cee, *app;\r\nstruct dcb_app_type *itr;\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nint dcbx, i, err = -EMSGSIZE;\r\nu8 value;\r\nif (nla_put_string(skb, DCB_ATTR_IFNAME, netdev->name))\r\ngoto nla_put_failure;\r\ncee = nla_nest_start(skb, DCB_ATTR_CEE);\r\nif (!cee)\r\ngoto nla_put_failure;\r\nif (ops->getpgtccfgtx && ops->getpgbwgcfgtx) {\r\nerr = dcbnl_cee_pg_fill(skb, netdev, 1);\r\nif (err)\r\ngoto nla_put_failure;\r\n}\r\nif (ops->getpgtccfgrx && ops->getpgbwgcfgrx) {\r\nerr = dcbnl_cee_pg_fill(skb, netdev, 0);\r\nif (err)\r\ngoto nla_put_failure;\r\n}\r\nif (ops->getpfccfg) {\r\nstruct nlattr *pfc_nest = nla_nest_start(skb, DCB_ATTR_CEE_PFC);\r\nif (!pfc_nest)\r\ngoto nla_put_failure;\r\nfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\r\nops->getpfccfg(netdev, i - DCB_PFC_UP_ATTR_0, &value);\r\nif (nla_put_u8(skb, i, value))\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, pfc_nest);\r\n}\r\nspin_lock(&dcb_lock);\r\napp = nla_nest_start(skb, DCB_ATTR_CEE_APP_TABLE);\r\nif (!app)\r\ngoto dcb_unlock;\r\nlist_for_each_entry(itr, &dcb_app_list, list) {\r\nif (itr->ifindex == netdev->ifindex) {\r\nstruct nlattr *app_nest = nla_nest_start(skb,\r\nDCB_ATTR_APP);\r\nif (!app_nest)\r\ngoto dcb_unlock;\r\nerr = nla_put_u8(skb, DCB_APP_ATTR_IDTYPE,\r\nitr->app.selector);\r\nif (err)\r\ngoto dcb_unlock;\r\nerr = nla_put_u16(skb, DCB_APP_ATTR_ID,\r\nitr->app.protocol);\r\nif (err)\r\ngoto dcb_unlock;\r\nerr = nla_put_u8(skb, DCB_APP_ATTR_PRIORITY,\r\nitr->app.priority);\r\nif (err)\r\ngoto dcb_unlock;\r\nnla_nest_end(skb, app_nest);\r\n}\r\n}\r\nnla_nest_end(skb, app);\r\nif (netdev->dcbnl_ops->getdcbx)\r\ndcbx = netdev->dcbnl_ops->getdcbx(netdev);\r\nelse\r\ndcbx = -EOPNOTSUPP;\r\nspin_unlock(&dcb_lock);\r\nif (ops->getfeatcfg) {\r\nstruct nlattr *feat = nla_nest_start(skb, DCB_ATTR_CEE_FEAT);\r\nif (!feat)\r\ngoto nla_put_failure;\r\nfor (i = DCB_FEATCFG_ATTR_ALL + 1; i <= DCB_FEATCFG_ATTR_MAX;\r\ni++)\r\nif (!ops->getfeatcfg(netdev, i, &value) &&\r\nnla_put_u8(skb, i, value))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, feat);\r\n}\r\nif (ops->cee_peer_getpg) {\r\nstruct cee_pg pg;\r\nmemset(&pg, 0, sizeof(pg));\r\nerr = ops->cee_peer_getpg(netdev, &pg);\r\nif (!err &&\r\nnla_put(skb, DCB_ATTR_CEE_PEER_PG, sizeof(pg), &pg))\r\ngoto nla_put_failure;\r\n}\r\nif (ops->cee_peer_getpfc) {\r\nstruct cee_pfc pfc;\r\nmemset(&pfc, 0, sizeof(pfc));\r\nerr = ops->cee_peer_getpfc(netdev, &pfc);\r\nif (!err &&\r\nnla_put(skb, DCB_ATTR_CEE_PEER_PFC, sizeof(pfc), &pfc))\r\ngoto nla_put_failure;\r\n}\r\nif (ops->peer_getappinfo && ops->peer_getapptable) {\r\nerr = dcbnl_build_peer_app(netdev, skb,\r\nDCB_ATTR_CEE_PEER_APP_TABLE,\r\nDCB_ATTR_CEE_PEER_APP_INFO,\r\nDCB_ATTR_CEE_PEER_APP);\r\nif (err)\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, cee);\r\nif (dcbx >= 0) {\r\nerr = nla_put_u8(skb, DCB_ATTR_DCBX, dcbx);\r\nif (err)\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\ndcb_unlock:\r\nspin_unlock(&dcb_lock);\r\nnla_put_failure:\r\nreturn err;\r\n}\r\nstatic int dcbnl_notify(struct net_device *dev, int event, int cmd,\r\nu32 seq, u32 portid, int dcbx_ver)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\r\nint err;\r\nif (!ops)\r\nreturn -EOPNOTSUPP;\r\nskb = dcbnl_newmsg(event, cmd, portid, seq, 0, &nlh);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nif (dcbx_ver == DCB_CAP_DCBX_VER_IEEE)\r\nerr = dcbnl_ieee_fill(skb, dev);\r\nelse\r\nerr = dcbnl_cee_fill(skb, dev);\r\nif (err < 0) {\r\nnlmsg_free(skb);\r\nrtnl_set_sk_err(net, RTNLGRP_DCB, err);\r\n} else {\r\nnlmsg_end(skb, nlh);\r\nrtnl_notify(skb, net, 0, RTNLGRP_DCB, NULL, GFP_KERNEL);\r\n}\r\nreturn err;\r\n}\r\nint dcbnl_ieee_notify(struct net_device *dev, int event, int cmd,\r\nu32 seq, u32 portid)\r\n{\r\nreturn dcbnl_notify(dev, event, cmd, seq, portid, DCB_CAP_DCBX_VER_IEEE);\r\n}\r\nint dcbnl_cee_notify(struct net_device *dev, int event, int cmd,\r\nu32 seq, u32 portid)\r\n{\r\nreturn dcbnl_notify(dev, event, cmd, seq, portid, DCB_CAP_DCBX_VER_CEE);\r\n}\r\nstatic int dcbnl_ieee_set(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nstruct nlattr *ieee[DCB_ATTR_IEEE_MAX + 1];\r\nint err;\r\nif (!ops)\r\nreturn -EOPNOTSUPP;\r\nif (!tb[DCB_ATTR_IEEE])\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(ieee, DCB_ATTR_IEEE_MAX,\r\ntb[DCB_ATTR_IEEE], dcbnl_ieee_policy);\r\nif (err)\r\nreturn err;\r\nif (ieee[DCB_ATTR_IEEE_ETS] && ops->ieee_setets) {\r\nstruct ieee_ets *ets = nla_data(ieee[DCB_ATTR_IEEE_ETS]);\r\nerr = ops->ieee_setets(netdev, ets);\r\nif (err)\r\ngoto err;\r\n}\r\nif (ieee[DCB_ATTR_IEEE_MAXRATE] && ops->ieee_setmaxrate) {\r\nstruct ieee_maxrate *maxrate =\r\nnla_data(ieee[DCB_ATTR_IEEE_MAXRATE]);\r\nerr = ops->ieee_setmaxrate(netdev, maxrate);\r\nif (err)\r\ngoto err;\r\n}\r\nif (ieee[DCB_ATTR_IEEE_PFC] && ops->ieee_setpfc) {\r\nstruct ieee_pfc *pfc = nla_data(ieee[DCB_ATTR_IEEE_PFC]);\r\nerr = ops->ieee_setpfc(netdev, pfc);\r\nif (err)\r\ngoto err;\r\n}\r\nif (ieee[DCB_ATTR_IEEE_APP_TABLE]) {\r\nstruct nlattr *attr;\r\nint rem;\r\nnla_for_each_nested(attr, ieee[DCB_ATTR_IEEE_APP_TABLE], rem) {\r\nstruct dcb_app *app_data;\r\nif (nla_type(attr) != DCB_ATTR_IEEE_APP)\r\ncontinue;\r\napp_data = nla_data(attr);\r\nif (ops->ieee_setapp)\r\nerr = ops->ieee_setapp(netdev, app_data);\r\nelse\r\nerr = dcb_ieee_setapp(netdev, app_data);\r\nif (err)\r\ngoto err;\r\n}\r\n}\r\nerr:\r\nerr = nla_put_u8(skb, DCB_ATTR_IEEE, err);\r\ndcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_SET, seq, 0);\r\nreturn err;\r\n}\r\nstatic int dcbnl_ieee_get(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nif (!ops)\r\nreturn -EOPNOTSUPP;\r\nreturn dcbnl_ieee_fill(skb, netdev);\r\n}\r\nstatic int dcbnl_ieee_del(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nstruct nlattr *ieee[DCB_ATTR_IEEE_MAX + 1];\r\nint err;\r\nif (!ops)\r\nreturn -EOPNOTSUPP;\r\nif (!tb[DCB_ATTR_IEEE])\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(ieee, DCB_ATTR_IEEE_MAX,\r\ntb[DCB_ATTR_IEEE], dcbnl_ieee_policy);\r\nif (err)\r\nreturn err;\r\nif (ieee[DCB_ATTR_IEEE_APP_TABLE]) {\r\nstruct nlattr *attr;\r\nint rem;\r\nnla_for_each_nested(attr, ieee[DCB_ATTR_IEEE_APP_TABLE], rem) {\r\nstruct dcb_app *app_data;\r\nif (nla_type(attr) != DCB_ATTR_IEEE_APP)\r\ncontinue;\r\napp_data = nla_data(attr);\r\nif (ops->ieee_delapp)\r\nerr = ops->ieee_delapp(netdev, app_data);\r\nelse\r\nerr = dcb_ieee_delapp(netdev, app_data);\r\nif (err)\r\ngoto err;\r\n}\r\n}\r\nerr:\r\nerr = nla_put_u8(skb, DCB_ATTR_IEEE, err);\r\ndcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_DEL, seq, 0);\r\nreturn err;\r\n}\r\nstatic int dcbnl_getdcbx(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nif (!netdev->dcbnl_ops->getdcbx)\r\nreturn -EOPNOTSUPP;\r\nreturn nla_put_u8(skb, DCB_ATTR_DCBX,\r\nnetdev->dcbnl_ops->getdcbx(netdev));\r\n}\r\nstatic int dcbnl_setdcbx(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nu8 value;\r\nif (!netdev->dcbnl_ops->setdcbx)\r\nreturn -EOPNOTSUPP;\r\nif (!tb[DCB_ATTR_DCBX])\r\nreturn -EINVAL;\r\nvalue = nla_get_u8(tb[DCB_ATTR_DCBX]);\r\nreturn nla_put_u8(skb, DCB_ATTR_DCBX,\r\nnetdev->dcbnl_ops->setdcbx(netdev, value));\r\n}\r\nstatic int dcbnl_getfeatcfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nstruct nlattr *data[DCB_FEATCFG_ATTR_MAX + 1], *nest;\r\nu8 value;\r\nint ret, i;\r\nint getall = 0;\r\nif (!netdev->dcbnl_ops->getfeatcfg)\r\nreturn -EOPNOTSUPP;\r\nif (!tb[DCB_ATTR_FEATCFG])\r\nreturn -EINVAL;\r\nret = nla_parse_nested(data, DCB_FEATCFG_ATTR_MAX, tb[DCB_ATTR_FEATCFG],\r\ndcbnl_featcfg_nest);\r\nif (ret)\r\nreturn ret;\r\nnest = nla_nest_start(skb, DCB_ATTR_FEATCFG);\r\nif (!nest)\r\nreturn -EMSGSIZE;\r\nif (data[DCB_FEATCFG_ATTR_ALL])\r\ngetall = 1;\r\nfor (i = DCB_FEATCFG_ATTR_ALL+1; i <= DCB_FEATCFG_ATTR_MAX; i++) {\r\nif (!getall && !data[i])\r\ncontinue;\r\nret = netdev->dcbnl_ops->getfeatcfg(netdev, i, &value);\r\nif (!ret)\r\nret = nla_put_u8(skb, i, value);\r\nif (ret) {\r\nnla_nest_cancel(skb, nest);\r\ngoto nla_put_failure;\r\n}\r\n}\r\nnla_nest_end(skb, nest);\r\nnla_put_failure:\r\nreturn ret;\r\n}\r\nstatic int dcbnl_setfeatcfg(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nstruct nlattr *data[DCB_FEATCFG_ATTR_MAX + 1];\r\nint ret, i;\r\nu8 value;\r\nif (!netdev->dcbnl_ops->setfeatcfg)\r\nreturn -ENOTSUPP;\r\nif (!tb[DCB_ATTR_FEATCFG])\r\nreturn -EINVAL;\r\nret = nla_parse_nested(data, DCB_FEATCFG_ATTR_MAX, tb[DCB_ATTR_FEATCFG],\r\ndcbnl_featcfg_nest);\r\nif (ret)\r\ngoto err;\r\nfor (i = DCB_FEATCFG_ATTR_ALL+1; i <= DCB_FEATCFG_ATTR_MAX; i++) {\r\nif (data[i] == NULL)\r\ncontinue;\r\nvalue = nla_get_u8(data[i]);\r\nret = netdev->dcbnl_ops->setfeatcfg(netdev, i, value);\r\nif (ret)\r\ngoto err;\r\n}\r\nerr:\r\nret = nla_put_u8(skb, DCB_ATTR_FEATCFG, ret);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_cee_get(struct net_device *netdev, struct nlmsghdr *nlh,\r\nu32 seq, struct nlattr **tb, struct sk_buff *skb)\r\n{\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nif (!ops)\r\nreturn -EOPNOTSUPP;\r\nreturn dcbnl_cee_fill(skb, netdev);\r\n}\r\nstatic int dcb_doit(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct net_device *netdev;\r\nstruct dcbmsg *dcb = nlmsg_data(nlh);\r\nstruct nlattr *tb[DCB_ATTR_MAX + 1];\r\nu32 portid = skb ? NETLINK_CB(skb).portid : 0;\r\nint ret = -EINVAL;\r\nstruct sk_buff *reply_skb;\r\nstruct nlmsghdr *reply_nlh = NULL;\r\nconst struct reply_func *fn;\r\nif ((nlh->nlmsg_type == RTM_SETDCB) && !netlink_capable(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nret = nlmsg_parse(nlh, sizeof(*dcb), tb, DCB_ATTR_MAX,\r\ndcbnl_rtnl_policy);\r\nif (ret < 0)\r\nreturn ret;\r\nif (dcb->cmd > DCB_CMD_MAX)\r\nreturn -EINVAL;\r\nfn = &reply_funcs[dcb->cmd];\r\nif (!fn->cb)\r\nreturn -EOPNOTSUPP;\r\nif (!tb[DCB_ATTR_IFNAME])\r\nreturn -EINVAL;\r\nnetdev = __dev_get_by_name(net, nla_data(tb[DCB_ATTR_IFNAME]));\r\nif (!netdev)\r\nreturn -ENODEV;\r\nif (!netdev->dcbnl_ops)\r\nreturn -EOPNOTSUPP;\r\nreply_skb = dcbnl_newmsg(fn->type, dcb->cmd, portid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags, &reply_nlh);\r\nif (!reply_skb)\r\nreturn -ENOBUFS;\r\nret = fn->cb(netdev, nlh, nlh->nlmsg_seq, tb, reply_skb);\r\nif (ret < 0) {\r\nnlmsg_free(reply_skb);\r\ngoto out;\r\n}\r\nnlmsg_end(reply_skb, reply_nlh);\r\nret = rtnl_unicast(reply_skb, net, portid);\r\nout:\r\nreturn ret;\r\n}\r\nstatic struct dcb_app_type *dcb_app_lookup(const struct dcb_app *app,\r\nint ifindex, int prio)\r\n{\r\nstruct dcb_app_type *itr;\r\nlist_for_each_entry(itr, &dcb_app_list, list) {\r\nif (itr->app.selector == app->selector &&\r\nitr->app.protocol == app->protocol &&\r\nitr->ifindex == ifindex &&\r\n(!prio || itr->app.priority == prio))\r\nreturn itr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int dcb_app_add(const struct dcb_app *app, int ifindex)\r\n{\r\nstruct dcb_app_type *entry;\r\nentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nmemcpy(&entry->app, app, sizeof(*app));\r\nentry->ifindex = ifindex;\r\nlist_add(&entry->list, &dcb_app_list);\r\nreturn 0;\r\n}\r\nu8 dcb_getapp(struct net_device *dev, struct dcb_app *app)\r\n{\r\nstruct dcb_app_type *itr;\r\nu8 prio = 0;\r\nspin_lock(&dcb_lock);\r\nif ((itr = dcb_app_lookup(app, dev->ifindex, 0)))\r\nprio = itr->app.priority;\r\nspin_unlock(&dcb_lock);\r\nreturn prio;\r\n}\r\nint dcb_setapp(struct net_device *dev, struct dcb_app *new)\r\n{\r\nstruct dcb_app_type *itr;\r\nstruct dcb_app_type event;\r\nint err = 0;\r\nevent.ifindex = dev->ifindex;\r\nmemcpy(&event.app, new, sizeof(event.app));\r\nif (dev->dcbnl_ops->getdcbx)\r\nevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\r\nspin_lock(&dcb_lock);\r\nif ((itr = dcb_app_lookup(new, dev->ifindex, 0))) {\r\nif (new->priority)\r\nitr->app.priority = new->priority;\r\nelse {\r\nlist_del(&itr->list);\r\nkfree(itr);\r\n}\r\ngoto out;\r\n}\r\nif (new->priority)\r\nerr = dcb_app_add(new, dev->ifindex);\r\nout:\r\nspin_unlock(&dcb_lock);\r\nif (!err)\r\ncall_dcbevent_notifiers(DCB_APP_EVENT, &event);\r\nreturn err;\r\n}\r\nu8 dcb_ieee_getapp_mask(struct net_device *dev, struct dcb_app *app)\r\n{\r\nstruct dcb_app_type *itr;\r\nu8 prio = 0;\r\nspin_lock(&dcb_lock);\r\nif ((itr = dcb_app_lookup(app, dev->ifindex, 0)))\r\nprio |= 1 << itr->app.priority;\r\nspin_unlock(&dcb_lock);\r\nreturn prio;\r\n}\r\nint dcb_ieee_setapp(struct net_device *dev, struct dcb_app *new)\r\n{\r\nstruct dcb_app_type event;\r\nint err = 0;\r\nevent.ifindex = dev->ifindex;\r\nmemcpy(&event.app, new, sizeof(event.app));\r\nif (dev->dcbnl_ops->getdcbx)\r\nevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\r\nspin_lock(&dcb_lock);\r\nif (dcb_app_lookup(new, dev->ifindex, new->priority)) {\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\nerr = dcb_app_add(new, dev->ifindex);\r\nout:\r\nspin_unlock(&dcb_lock);\r\nif (!err)\r\ncall_dcbevent_notifiers(DCB_APP_EVENT, &event);\r\nreturn err;\r\n}\r\nint dcb_ieee_delapp(struct net_device *dev, struct dcb_app *del)\r\n{\r\nstruct dcb_app_type *itr;\r\nstruct dcb_app_type event;\r\nint err = -ENOENT;\r\nevent.ifindex = dev->ifindex;\r\nmemcpy(&event.app, del, sizeof(event.app));\r\nif (dev->dcbnl_ops->getdcbx)\r\nevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\r\nspin_lock(&dcb_lock);\r\nif ((itr = dcb_app_lookup(del, dev->ifindex, del->priority))) {\r\nlist_del(&itr->list);\r\nkfree(itr);\r\nerr = 0;\r\n}\r\nspin_unlock(&dcb_lock);\r\nif (!err)\r\ncall_dcbevent_notifiers(DCB_APP_EVENT, &event);\r\nreturn err;\r\n}\r\nstatic void dcb_flushapp(void)\r\n{\r\nstruct dcb_app_type *app;\r\nstruct dcb_app_type *tmp;\r\nspin_lock(&dcb_lock);\r\nlist_for_each_entry_safe(app, tmp, &dcb_app_list, list) {\r\nlist_del(&app->list);\r\nkfree(app);\r\n}\r\nspin_unlock(&dcb_lock);\r\n}\r\nstatic int __init dcbnl_init(void)\r\n{\r\nINIT_LIST_HEAD(&dcb_app_list);\r\nrtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic void __exit dcbnl_exit(void)\r\n{\r\nrtnl_unregister(PF_UNSPEC, RTM_GETDCB);\r\nrtnl_unregister(PF_UNSPEC, RTM_SETDCB);\r\ndcb_flushapp();\r\n}
