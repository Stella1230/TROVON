static unsigned long kvm_get_itc(struct kvm_vcpu *vcpu)\r\n{\r\n#if defined(CONFIG_IA64_SGI_SN2) || defined(CONFIG_IA64_GENERIC)\r\nif (vcpu->kvm->arch.is_sn2)\r\nreturn rtc_time();\r\nelse\r\n#endif\r\nreturn ia64_getreg(_IA64_REG_AR_ITC);\r\n}\r\nstatic void kvm_flush_icache(unsigned long start, unsigned long len)\r\n{\r\nint l;\r\nfor (l = 0; l < (len + 32); l += 32)\r\nia64_fc((void *)(start + l));\r\nia64_sync_i();\r\nia64_srlz_i();\r\n}\r\nstatic void kvm_flush_tlb_all(void)\r\n{\r\nunsigned long i, j, count0, count1, stride0, stride1, addr;\r\nlong flags;\r\naddr = local_cpu_data->ptce_base;\r\ncount0 = local_cpu_data->ptce_count[0];\r\ncount1 = local_cpu_data->ptce_count[1];\r\nstride0 = local_cpu_data->ptce_stride[0];\r\nstride1 = local_cpu_data->ptce_stride[1];\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < count0; ++i) {\r\nfor (j = 0; j < count1; ++j) {\r\nia64_ptce(addr);\r\naddr += stride1;\r\n}\r\naddr += stride0;\r\n}\r\nlocal_irq_restore(flags);\r\nia64_srlz_i();\r\n}\r\nlong ia64_pal_vp_create(u64 *vpd, u64 *host_iva, u64 *opt_handler)\r\n{\r\nstruct ia64_pal_retval iprv;\r\nPAL_CALL_STK(iprv, PAL_VP_CREATE, (u64)vpd, (u64)host_iva,\r\n(u64)opt_handler);\r\nreturn iprv.status;\r\n}\r\nint kvm_arch_hardware_enable(void *garbage)\r\n{\r\nlong status;\r\nlong tmp_base;\r\nunsigned long pte;\r\nunsigned long saved_psr;\r\nint slot;\r\npte = pte_val(mk_pte_phys(__pa(kvm_vmm_base), PAGE_KERNEL));\r\nlocal_irq_save(saved_psr);\r\nslot = ia64_itr_entry(0x3, KVM_VMM_BASE, pte, KVM_VMM_SHIFT);\r\nlocal_irq_restore(saved_psr);\r\nif (slot < 0)\r\nreturn -EINVAL;\r\nspin_lock(&vp_lock);\r\nstatus = ia64_pal_vp_init_env(kvm_vsa_base ?\r\nVP_INIT_ENV : VP_INIT_ENV_INITALIZE,\r\n__pa(kvm_vm_buffer), KVM_VM_BUFFER_BASE, &tmp_base);\r\nif (status != 0) {\r\nspin_unlock(&vp_lock);\r\nprintk(KERN_WARNING"kvm: Failed to Enable VT Support!!!!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!kvm_vsa_base) {\r\nkvm_vsa_base = tmp_base;\r\nprintk(KERN_INFO"kvm: kvm_vsa_base:0x%lx\n", kvm_vsa_base);\r\n}\r\nspin_unlock(&vp_lock);\r\nia64_ptr_entry(0x3, slot);\r\nreturn 0;\r\n}\r\nvoid kvm_arch_hardware_disable(void *garbage)\r\n{\r\nlong status;\r\nint slot;\r\nunsigned long pte;\r\nunsigned long saved_psr;\r\nunsigned long host_iva = ia64_getreg(_IA64_REG_CR_IVA);\r\npte = pte_val(mk_pte_phys(__pa(kvm_vmm_base),\r\nPAGE_KERNEL));\r\nlocal_irq_save(saved_psr);\r\nslot = ia64_itr_entry(0x3, KVM_VMM_BASE, pte, KVM_VMM_SHIFT);\r\nlocal_irq_restore(saved_psr);\r\nif (slot < 0)\r\nreturn;\r\nstatus = ia64_pal_vp_exit_env(host_iva);\r\nif (status)\r\nprintk(KERN_DEBUG"kvm: Failed to disable VT support! :%ld\n",\r\nstatus);\r\nia64_ptr_entry(0x3, slot);\r\n}\r\nvoid kvm_arch_check_processor_compat(void *rtn)\r\n{\r\n*(int *)rtn = 0;\r\n}\r\nint kvm_dev_ioctl_check_extension(long ext)\r\n{\r\nint r;\r\nswitch (ext) {\r\ncase KVM_CAP_IRQCHIP:\r\ncase KVM_CAP_MP_STATE:\r\ncase KVM_CAP_IRQ_INJECT_STATUS:\r\ncase KVM_CAP_IOAPIC_POLARITY_IGNORED:\r\nr = 1;\r\nbreak;\r\ncase KVM_CAP_COALESCED_MMIO:\r\nr = KVM_COALESCED_MMIO_PAGE_OFFSET;\r\nbreak;\r\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\r\ncase KVM_CAP_IOMMU:\r\nr = iommu_present(&pci_bus_type);\r\nbreak;\r\n#endif\r\ndefault:\r\nr = 0;\r\n}\r\nreturn r;\r\n}\r\nstatic int handle_vm_error(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\r\n{\r\nkvm_run->exit_reason = KVM_EXIT_UNKNOWN;\r\nkvm_run->hw.hardware_exit_reason = 1;\r\nreturn 0;\r\n}\r\nstatic int handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\r\n{\r\nstruct kvm_mmio_req *p;\r\nstruct kvm_io_device *mmio_dev;\r\nint r;\r\np = kvm_get_vcpu_ioreq(vcpu);\r\nif ((p->addr & PAGE_MASK) == IOAPIC_DEFAULT_BASE_ADDRESS)\r\ngoto mmio;\r\nvcpu->mmio_needed = 1;\r\nvcpu->mmio_fragments[0].gpa = kvm_run->mmio.phys_addr = p->addr;\r\nvcpu->mmio_fragments[0].len = kvm_run->mmio.len = p->size;\r\nvcpu->mmio_is_write = kvm_run->mmio.is_write = !p->dir;\r\nif (vcpu->mmio_is_write)\r\nmemcpy(vcpu->arch.mmio_data, &p->data, p->size);\r\nmemcpy(kvm_run->mmio.data, &p->data, p->size);\r\nkvm_run->exit_reason = KVM_EXIT_MMIO;\r\nreturn 0;\r\nmmio:\r\nif (p->dir)\r\nr = kvm_io_bus_read(vcpu->kvm, KVM_MMIO_BUS, p->addr,\r\np->size, &p->data);\r\nelse\r\nr = kvm_io_bus_write(vcpu->kvm, KVM_MMIO_BUS, p->addr,\r\np->size, &p->data);\r\nif (r)\r\nprintk(KERN_ERR"kvm: No iodevice found! addr:%lx\n", p->addr);\r\np->state = STATE_IORESP_READY;\r\nreturn 1;\r\n}\r\nstatic int handle_pal_call(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\r\n{\r\nstruct exit_ctl_data *p;\r\np = kvm_get_exit_data(vcpu);\r\nif (p->exit_reason == EXIT_REASON_PAL_CALL)\r\nreturn kvm_pal_emul(vcpu, kvm_run);\r\nelse {\r\nkvm_run->exit_reason = KVM_EXIT_UNKNOWN;\r\nkvm_run->hw.hardware_exit_reason = 2;\r\nreturn 0;\r\n}\r\n}\r\nstatic int handle_sal_call(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\r\n{\r\nstruct exit_ctl_data *p;\r\np = kvm_get_exit_data(vcpu);\r\nif (p->exit_reason == EXIT_REASON_SAL_CALL) {\r\nkvm_sal_emul(vcpu);\r\nreturn 1;\r\n} else {\r\nkvm_run->exit_reason = KVM_EXIT_UNKNOWN;\r\nkvm_run->hw.hardware_exit_reason = 3;\r\nreturn 0;\r\n}\r\n}\r\nstatic int __apic_accept_irq(struct kvm_vcpu *vcpu, uint64_t vector)\r\n{\r\nstruct vpd *vpd = to_host(vcpu->kvm, vcpu->arch.vpd);\r\nif (!test_and_set_bit(vector, &vpd->irr[0])) {\r\nvcpu->arch.irq_new_pending = 1;\r\nkvm_vcpu_kick(vcpu);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vcpu_deliver_ipi(struct kvm_vcpu *vcpu, uint64_t dm,\r\nuint64_t vector)\r\n{\r\nswitch (dm) {\r\ncase SAPIC_FIXED:\r\nbreak;\r\ncase SAPIC_NMI:\r\nvector = 2;\r\nbreak;\r\ncase SAPIC_EXTINT:\r\nvector = 0;\r\nbreak;\r\ncase SAPIC_INIT:\r\ncase SAPIC_PMI:\r\ndefault:\r\nprintk(KERN_ERR"kvm: Unimplemented Deliver reserved IPI!\n");\r\nreturn;\r\n}\r\n__apic_accept_irq(vcpu, vector);\r\n}\r\nstatic struct kvm_vcpu *lid_to_vcpu(struct kvm *kvm, unsigned long id,\r\nunsigned long eid)\r\n{\r\nunion ia64_lid lid;\r\nint i;\r\nstruct kvm_vcpu *vcpu;\r\nkvm_for_each_vcpu(i, vcpu, kvm) {\r\nlid.val = VCPU_LID(vcpu);\r\nif (lid.id == id && lid.eid == eid)\r\nreturn vcpu;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int handle_ipi(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\r\n{\r\nstruct exit_ctl_data *p = kvm_get_exit_data(vcpu);\r\nstruct kvm_vcpu *target_vcpu;\r\nstruct kvm_pt_regs *regs;\r\nunion ia64_ipi_a addr = p->u.ipi_data.addr;\r\nunion ia64_ipi_d data = p->u.ipi_data.data;\r\ntarget_vcpu = lid_to_vcpu(vcpu->kvm, addr.id, addr.eid);\r\nif (!target_vcpu)\r\nreturn handle_vm_error(vcpu, kvm_run);\r\nif (!target_vcpu->arch.launched) {\r\nregs = vcpu_regs(target_vcpu);\r\nregs->cr_iip = vcpu->kvm->arch.rdv_sal_data.boot_ip;\r\nregs->r1 = vcpu->kvm->arch.rdv_sal_data.boot_gp;\r\ntarget_vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\r\nif (waitqueue_active(&target_vcpu->wq))\r\nwake_up_interruptible(&target_vcpu->wq);\r\n} else {\r\nvcpu_deliver_ipi(target_vcpu, data.dm, data.vector);\r\nif (target_vcpu != vcpu)\r\nkvm_vcpu_kick(target_vcpu);\r\n}\r\nreturn 1;\r\n}\r\nstatic void vcpu_global_purge(void *info)\r\n{\r\nstruct call_data *p = (struct call_data *)info;\r\nstruct kvm_vcpu *vcpu = p->vcpu;\r\nif (test_bit(KVM_REQ_TLB_FLUSH, &vcpu->requests))\r\nreturn;\r\nset_bit(KVM_REQ_PTC_G, &vcpu->requests);\r\nif (vcpu->arch.ptc_g_count < MAX_PTC_G_NUM) {\r\nvcpu->arch.ptc_g_data[vcpu->arch.ptc_g_count++] =\r\np->ptc_g_data;\r\n} else {\r\nclear_bit(KVM_REQ_PTC_G, &vcpu->requests);\r\nvcpu->arch.ptc_g_count = 0;\r\nset_bit(KVM_REQ_TLB_FLUSH, &vcpu->requests);\r\n}\r\n}\r\nstatic int handle_global_purge(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\r\n{\r\nstruct exit_ctl_data *p = kvm_get_exit_data(vcpu);\r\nstruct kvm *kvm = vcpu->kvm;\r\nstruct call_data call_data;\r\nint i;\r\nstruct kvm_vcpu *vcpui;\r\ncall_data.ptc_g_data = p->u.ptc_g_data;\r\nkvm_for_each_vcpu(i, vcpui, kvm) {\r\nif (vcpui->arch.mp_state == KVM_MP_STATE_UNINITIALIZED ||\r\nvcpu == vcpui)\r\ncontinue;\r\nif (waitqueue_active(&vcpui->wq))\r\nwake_up_interruptible(&vcpui->wq);\r\nif (vcpui->cpu != -1) {\r\ncall_data.vcpu = vcpui;\r\nsmp_call_function_single(vcpui->cpu,\r\nvcpu_global_purge, &call_data, 1);\r\n} else\r\nprintk(KERN_WARNING"kvm: Uninit vcpu received ipi!\n");\r\n}\r\nreturn 1;\r\n}\r\nstatic int handle_switch_rr6(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\r\n{\r\nreturn 1;\r\n}\r\nstatic int kvm_sn2_setup_mappings(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long pte, rtc_phys_addr, map_addr;\r\nint slot;\r\nmap_addr = KVM_VMM_BASE + (1UL << KVM_VMM_SHIFT);\r\nrtc_phys_addr = LOCAL_MMR_OFFSET | SH_RTC;\r\npte = pte_val(mk_pte_phys(rtc_phys_addr, PAGE_KERNEL_UC));\r\nslot = ia64_itr_entry(0x3, map_addr, pte, PAGE_SHIFT);\r\nvcpu->arch.sn_rtc_tr_slot = slot;\r\nif (slot < 0) {\r\nprintk(KERN_ERR "Mayday mayday! RTC mapping failed!\n");\r\nslot = 0;\r\n}\r\nreturn slot;\r\n}\r\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\r\n{\r\nktime_t kt;\r\nlong itc_diff;\r\nunsigned long vcpu_now_itc;\r\nunsigned long expires;\r\nstruct hrtimer *p_ht = &vcpu->arch.hlt_timer;\r\nunsigned long cyc_per_usec = local_cpu_data->cyc_per_usec;\r\nstruct vpd *vpd = to_host(vcpu->kvm, vcpu->arch.vpd);\r\nif (irqchip_in_kernel(vcpu->kvm)) {\r\nvcpu_now_itc = kvm_get_itc(vcpu) + vcpu->arch.itc_offset;\r\nif (time_after(vcpu_now_itc, vpd->itm)) {\r\nvcpu->arch.timer_check = 1;\r\nreturn 1;\r\n}\r\nitc_diff = vpd->itm - vcpu_now_itc;\r\nif (itc_diff < 0)\r\nitc_diff = -itc_diff;\r\nexpires = div64_u64(itc_diff, cyc_per_usec);\r\nkt = ktime_set(0, 1000 * expires);\r\nvcpu->arch.ht_active = 1;\r\nhrtimer_start(p_ht, kt, HRTIMER_MODE_ABS);\r\nvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\r\nkvm_vcpu_block(vcpu);\r\nhrtimer_cancel(p_ht);\r\nvcpu->arch.ht_active = 0;\r\nif (test_and_clear_bit(KVM_REQ_UNHALT, &vcpu->requests) ||\r\nkvm_cpu_has_pending_timer(vcpu))\r\nif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED)\r\nvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\r\nif (vcpu->arch.mp_state != KVM_MP_STATE_RUNNABLE)\r\nreturn -EINTR;\r\nreturn 1;\r\n} else {\r\nprintk(KERN_ERR"kvm: Unsupported userspace halt!");\r\nreturn 0;\r\n}\r\n}\r\nstatic int handle_vm_shutdown(struct kvm_vcpu *vcpu,\r\nstruct kvm_run *kvm_run)\r\n{\r\nkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\r\nreturn 0;\r\n}\r\nstatic int handle_external_interrupt(struct kvm_vcpu *vcpu,\r\nstruct kvm_run *kvm_run)\r\n{\r\nreturn 1;\r\n}\r\nstatic int handle_vcpu_debug(struct kvm_vcpu *vcpu,\r\nstruct kvm_run *kvm_run)\r\n{\r\nprintk("VMM: %s", vcpu->arch.log_buf);\r\nreturn 1;\r\n}\r\nstatic uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)\r\n{\r\nstruct exit_ctl_data *p_exit_data;\r\np_exit_data = kvm_get_exit_data(vcpu);\r\nreturn p_exit_data->exit_reason;\r\n}\r\nstatic int kvm_handle_exit(struct kvm_run *kvm_run, struct kvm_vcpu *vcpu)\r\n{\r\nu32 exit_reason = kvm_get_exit_reason(vcpu);\r\nvcpu->arch.last_exit = exit_reason;\r\nif (exit_reason < kvm_vti_max_exit_handlers\r\n&& kvm_vti_exit_handlers[exit_reason])\r\nreturn kvm_vti_exit_handlers[exit_reason](vcpu, kvm_run);\r\nelse {\r\nkvm_run->exit_reason = KVM_EXIT_UNKNOWN;\r\nkvm_run->hw.hardware_exit_reason = exit_reason;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void vti_set_rr6(unsigned long rr6)\r\n{\r\nia64_set_rr(RR6, rr6);\r\nia64_srlz_i();\r\n}\r\nstatic int kvm_insert_vmm_mapping(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long pte;\r\nstruct kvm *kvm = vcpu->kvm;\r\nint r;\r\npte = pte_val(mk_pte_phys(__pa(kvm_vmm_base), PAGE_KERNEL));\r\nr = ia64_itr_entry(0x3, KVM_VMM_BASE, pte, KVM_VMM_SHIFT);\r\nif (r < 0)\r\ngoto out;\r\nvcpu->arch.vmm_tr_slot = r;\r\npte = pte_val(mk_pte_phys(__pa(kvm->arch.vm_base), PAGE_KERNEL));\r\nr = ia64_itr_entry(0x3, KVM_VM_DATA_BASE,\r\npte, KVM_VM_DATA_SHIFT);\r\nif (r < 0)\r\ngoto out;\r\nvcpu->arch.vm_tr_slot = r;\r\n#if defined(CONFIG_IA64_SGI_SN2) || defined(CONFIG_IA64_GENERIC)\r\nif (kvm->arch.is_sn2) {\r\nr = kvm_sn2_setup_mappings(vcpu);\r\nif (r < 0)\r\ngoto out;\r\n}\r\n#endif\r\nr = 0;\r\nout:\r\nreturn r;\r\n}\r\nstatic void kvm_purge_vmm_mapping(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm *kvm = vcpu->kvm;\r\nia64_ptr_entry(0x3, vcpu->arch.vmm_tr_slot);\r\nia64_ptr_entry(0x3, vcpu->arch.vm_tr_slot);\r\n#if defined(CONFIG_IA64_SGI_SN2) || defined(CONFIG_IA64_GENERIC)\r\nif (kvm->arch.is_sn2)\r\nia64_ptr_entry(0x3, vcpu->arch.sn_rtc_tr_slot);\r\n#endif\r\n}\r\nstatic int kvm_vcpu_pre_transition(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long psr;\r\nint r;\r\nint cpu = smp_processor_id();\r\nif (vcpu->arch.last_run_cpu != cpu ||\r\nper_cpu(last_vcpu, cpu) != vcpu) {\r\nper_cpu(last_vcpu, cpu) = vcpu;\r\nvcpu->arch.last_run_cpu = cpu;\r\nkvm_flush_tlb_all();\r\n}\r\nvcpu->arch.host_rr6 = ia64_get_rr(RR6);\r\nvti_set_rr6(vcpu->arch.vmm_rr);\r\nlocal_irq_save(psr);\r\nr = kvm_insert_vmm_mapping(vcpu);\r\nlocal_irq_restore(psr);\r\nreturn r;\r\n}\r\nstatic void kvm_vcpu_post_transition(struct kvm_vcpu *vcpu)\r\n{\r\nkvm_purge_vmm_mapping(vcpu);\r\nvti_set_rr6(vcpu->arch.host_rr6);\r\n}\r\nstatic int __vcpu_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\r\n{\r\nunion context *host_ctx, *guest_ctx;\r\nint r, idx;\r\nidx = srcu_read_lock(&vcpu->kvm->srcu);\r\nagain:\r\nif (signal_pending(current)) {\r\nr = -EINTR;\r\nkvm_run->exit_reason = KVM_EXIT_INTR;\r\ngoto out;\r\n}\r\npreempt_disable();\r\nlocal_irq_disable();\r\nhost_ctx = kvm_get_host_context(vcpu);\r\nguest_ctx = kvm_get_guest_context(vcpu);\r\nclear_bit(KVM_REQ_KICK, &vcpu->requests);\r\nr = kvm_vcpu_pre_transition(vcpu);\r\nif (r < 0)\r\ngoto vcpu_run_fail;\r\nsrcu_read_unlock(&vcpu->kvm->srcu, idx);\r\nvcpu->mode = IN_GUEST_MODE;\r\nkvm_guest_enter();\r\nkvm_vmm_info->tramp_entry(host_ctx, guest_ctx);\r\nkvm_vcpu_post_transition(vcpu);\r\nvcpu->arch.launched = 1;\r\nset_bit(KVM_REQ_KICK, &vcpu->requests);\r\nlocal_irq_enable();\r\nbarrier();\r\nkvm_guest_exit();\r\nvcpu->mode = OUTSIDE_GUEST_MODE;\r\npreempt_enable();\r\nidx = srcu_read_lock(&vcpu->kvm->srcu);\r\nr = kvm_handle_exit(kvm_run, vcpu);\r\nif (r > 0) {\r\nif (!need_resched())\r\ngoto again;\r\n}\r\nout:\r\nsrcu_read_unlock(&vcpu->kvm->srcu, idx);\r\nif (r > 0) {\r\ncond_resched();\r\nidx = srcu_read_lock(&vcpu->kvm->srcu);\r\ngoto again;\r\n}\r\nreturn r;\r\nvcpu_run_fail:\r\nlocal_irq_enable();\r\npreempt_enable();\r\nkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\r\ngoto out;\r\n}\r\nstatic void kvm_set_mmio_data(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);\r\nif (!vcpu->mmio_is_write)\r\nmemcpy(&p->data, vcpu->arch.mmio_data, 8);\r\np->state = STATE_IORESP_READY;\r\n}\r\nint kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\r\n{\r\nint r;\r\nsigset_t sigsaved;\r\nif (vcpu->sigset_active)\r\nsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\r\nif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\r\nkvm_vcpu_block(vcpu);\r\nclear_bit(KVM_REQ_UNHALT, &vcpu->requests);\r\nr = -EAGAIN;\r\ngoto out;\r\n}\r\nif (vcpu->mmio_needed) {\r\nmemcpy(vcpu->arch.mmio_data, kvm_run->mmio.data, 8);\r\nkvm_set_mmio_data(vcpu);\r\nvcpu->mmio_read_completed = 1;\r\nvcpu->mmio_needed = 0;\r\n}\r\nr = __vcpu_run(vcpu, kvm_run);\r\nout:\r\nif (vcpu->sigset_active)\r\nsigprocmask(SIG_SETMASK, &sigsaved, NULL);\r\nreturn r;\r\n}\r\nstruct kvm *kvm_arch_alloc_vm(void)\r\n{\r\nstruct kvm *kvm;\r\nuint64_t vm_base;\r\nBUG_ON(sizeof(struct kvm) > KVM_VM_STRUCT_SIZE);\r\nvm_base = __get_free_pages(GFP_KERNEL, get_order(KVM_VM_DATA_SIZE));\r\nif (!vm_base)\r\nreturn NULL;\r\nmemset((void *)vm_base, 0, KVM_VM_DATA_SIZE);\r\nkvm = (struct kvm *)(vm_base +\r\noffsetof(struct kvm_vm_data, kvm_vm_struct));\r\nkvm->arch.vm_base = vm_base;\r\nprintk(KERN_DEBUG"kvm: vm's data area:0x%lx\n", vm_base);\r\nreturn kvm;\r\n}\r\nstatic void kvm_build_io_pmt(struct kvm *kvm)\r\n{\r\nunsigned long i, j;\r\nfor (i = 0; i < (sizeof(io_ranges) / sizeof(struct kvm_io_range));\r\ni++) {\r\nfor (j = io_ranges[i].start;\r\nj < io_ranges[i].start + io_ranges[i].size;\r\nj += PAGE_SIZE)\r\nkvm_set_pmt_entry(kvm, j >> PAGE_SHIFT,\r\nio_ranges[i].type, 0);\r\n}\r\n}\r\nint kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\r\n{\r\nBUG_ON(!kvm);\r\nif (type)\r\nreturn -EINVAL;\r\nkvm->arch.is_sn2 = ia64_platform_is("sn2");\r\nkvm->arch.metaphysical_rr0 = GUEST_PHYSICAL_RR0;\r\nkvm->arch.metaphysical_rr4 = GUEST_PHYSICAL_RR4;\r\nkvm->arch.vmm_init_rr = VMM_INIT_RR;\r\nkvm_build_io_pmt(kvm);\r\nINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\r\nset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\r\nreturn 0;\r\n}\r\nstatic int kvm_vm_ioctl_get_irqchip(struct kvm *kvm,\r\nstruct kvm_irqchip *chip)\r\n{\r\nint r;\r\nr = 0;\r\nswitch (chip->chip_id) {\r\ncase KVM_IRQCHIP_IOAPIC:\r\nr = kvm_get_ioapic(kvm, &chip->chip.ioapic);\r\nbreak;\r\ndefault:\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\r\n{\r\nint r;\r\nr = 0;\r\nswitch (chip->chip_id) {\r\ncase KVM_IRQCHIP_IOAPIC:\r\nr = kvm_set_ioapic(kvm, &chip->chip.ioapic);\r\nbreak;\r\ndefault:\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nint kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\r\n{\r\nstruct vpd *vpd = to_host(vcpu->kvm, vcpu->arch.vpd);\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\nvpd->vgr[i] = regs->vpd.vgr[i];\r\nvpd->vbgr[i] = regs->vpd.vbgr[i];\r\n}\r\nfor (i = 0; i < 128; i++)\r\nvpd->vcr[i] = regs->vpd.vcr[i];\r\nvpd->vhpi = regs->vpd.vhpi;\r\nvpd->vnat = regs->vpd.vnat;\r\nvpd->vbnat = regs->vpd.vbnat;\r\nvpd->vpsr = regs->vpd.vpsr;\r\nvpd->vpr = regs->vpd.vpr;\r\nmemcpy(&vcpu->arch.guest, &regs->saved_guest, sizeof(union context));\r\nRESTORE_REGS(mp_state);\r\nRESTORE_REGS(vmm_rr);\r\nmemcpy(vcpu->arch.itrs, regs->itrs, sizeof(struct thash_data) * NITRS);\r\nmemcpy(vcpu->arch.dtrs, regs->dtrs, sizeof(struct thash_data) * NDTRS);\r\nRESTORE_REGS(itr_regions);\r\nRESTORE_REGS(dtr_regions);\r\nRESTORE_REGS(tc_regions);\r\nRESTORE_REGS(irq_check);\r\nRESTORE_REGS(itc_check);\r\nRESTORE_REGS(timer_check);\r\nRESTORE_REGS(timer_pending);\r\nRESTORE_REGS(last_itc);\r\nfor (i = 0; i < 8; i++) {\r\nvcpu->arch.vrr[i] = regs->vrr[i];\r\nvcpu->arch.ibr[i] = regs->ibr[i];\r\nvcpu->arch.dbr[i] = regs->dbr[i];\r\n}\r\nfor (i = 0; i < 4; i++)\r\nvcpu->arch.insvc[i] = regs->insvc[i];\r\nRESTORE_REGS(xtp);\r\nRESTORE_REGS(metaphysical_rr0);\r\nRESTORE_REGS(metaphysical_rr4);\r\nRESTORE_REGS(metaphysical_saved_rr0);\r\nRESTORE_REGS(metaphysical_saved_rr4);\r\nRESTORE_REGS(fp_psr);\r\nRESTORE_REGS(saved_gp);\r\nvcpu->arch.irq_new_pending = 1;\r\nvcpu->arch.itc_offset = regs->saved_itc - kvm_get_itc(vcpu);\r\nset_bit(KVM_REQ_RESUME, &vcpu->requests);\r\nreturn 0;\r\n}\r\nint kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,\r\nbool line_status)\r\n{\r\nif (!irqchip_in_kernel(kvm))\r\nreturn -ENXIO;\r\nirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\r\nirq_event->irq, irq_event->level,\r\nline_status);\r\nreturn 0;\r\n}\r\nlong kvm_arch_vm_ioctl(struct file *filp,\r\nunsigned int ioctl, unsigned long arg)\r\n{\r\nstruct kvm *kvm = filp->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint r = -ENOTTY;\r\nswitch (ioctl) {\r\ncase KVM_CREATE_IRQCHIP:\r\nr = -EFAULT;\r\nr = kvm_ioapic_init(kvm);\r\nif (r)\r\ngoto out;\r\nr = kvm_setup_default_irq_routing(kvm);\r\nif (r) {\r\nmutex_lock(&kvm->slots_lock);\r\nkvm_ioapic_destroy(kvm);\r\nmutex_unlock(&kvm->slots_lock);\r\ngoto out;\r\n}\r\nbreak;\r\ncase KVM_GET_IRQCHIP: {\r\nstruct kvm_irqchip chip;\r\nr = -EFAULT;\r\nif (copy_from_user(&chip, argp, sizeof chip))\r\ngoto out;\r\nr = -ENXIO;\r\nif (!irqchip_in_kernel(kvm))\r\ngoto out;\r\nr = kvm_vm_ioctl_get_irqchip(kvm, &chip);\r\nif (r)\r\ngoto out;\r\nr = -EFAULT;\r\nif (copy_to_user(argp, &chip, sizeof chip))\r\ngoto out;\r\nr = 0;\r\nbreak;\r\n}\r\ncase KVM_SET_IRQCHIP: {\r\nstruct kvm_irqchip chip;\r\nr = -EFAULT;\r\nif (copy_from_user(&chip, argp, sizeof chip))\r\ngoto out;\r\nr = -ENXIO;\r\nif (!irqchip_in_kernel(kvm))\r\ngoto out;\r\nr = kvm_vm_ioctl_set_irqchip(kvm, &chip);\r\nif (r)\r\ngoto out;\r\nr = 0;\r\nbreak;\r\n}\r\ndefault:\r\n;\r\n}\r\nout:\r\nreturn r;\r\n}\r\nint kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\r\nstruct kvm_sregs *sregs)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\r\nstruct kvm_sregs *sregs)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\r\nstruct kvm_translation *tr)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int kvm_alloc_vmm_area(void)\r\n{\r\nif (!kvm_vmm_base && (kvm_vm_buffer_size < KVM_VM_BUFFER_SIZE)) {\r\nkvm_vmm_base = __get_free_pages(GFP_KERNEL,\r\nget_order(KVM_VMM_SIZE));\r\nif (!kvm_vmm_base)\r\nreturn -ENOMEM;\r\nmemset((void *)kvm_vmm_base, 0, KVM_VMM_SIZE);\r\nkvm_vm_buffer = kvm_vmm_base + VMM_SIZE;\r\nprintk(KERN_DEBUG"kvm:VMM's Base Addr:0x%lx, vm_buffer:0x%lx\n",\r\nkvm_vmm_base, kvm_vm_buffer);\r\n}\r\nreturn 0;\r\n}\r\nstatic void kvm_free_vmm_area(void)\r\n{\r\nif (kvm_vmm_base) {\r\nmemset((void *)kvm_vmm_base, 0, KVM_VMM_SIZE);\r\nfree_pages(kvm_vmm_base, get_order(KVM_VMM_SIZE));\r\nkvm_vmm_base = 0;\r\nkvm_vm_buffer = 0;\r\nkvm_vsa_base = 0;\r\n}\r\n}\r\nstatic int vti_init_vpd(struct kvm_vcpu *vcpu)\r\n{\r\nint i;\r\nunion cpuid3_t cpuid3;\r\nstruct vpd *vpd = to_host(vcpu->kvm, vcpu->arch.vpd);\r\nif (IS_ERR(vpd))\r\nreturn PTR_ERR(vpd);\r\nfor (i = 0; i < 5; i++)\r\nvpd->vcpuid[i] = ia64_get_cpuid(i);\r\ncpuid3.value = vpd->vcpuid[3];\r\ncpuid3.number = 4;\r\nvpd->vcpuid[3] = cpuid3.value;\r\nvpd->vac.a_from_int_cr = 1;\r\nvpd->vac.a_to_int_cr = 1;\r\nvpd->vac.a_from_psr = 1;\r\nvpd->vac.a_from_cpuid = 1;\r\nvpd->vac.a_cover = 1;\r\nvpd->vac.a_bsw = 1;\r\nvpd->vac.a_int = 1;\r\nvpd->vdc.d_vmsw = 1;\r\nvpd->virt_env_vaddr = KVM_VM_BUFFER_BASE;\r\nreturn 0;\r\n}\r\nstatic int vti_create_vp(struct kvm_vcpu *vcpu)\r\n{\r\nlong ret;\r\nstruct vpd *vpd = vcpu->arch.vpd;\r\nunsigned long vmm_ivt;\r\nvmm_ivt = kvm_vmm_info->vmm_ivt;\r\nprintk(KERN_DEBUG "kvm: vcpu:%p,ivt: 0x%lx\n", vcpu, vmm_ivt);\r\nret = ia64_pal_vp_create((u64 *)vpd, (u64 *)vmm_ivt, 0);\r\nif (ret) {\r\nprintk(KERN_ERR"kvm: ia64_pal_vp_create failed!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void init_ptce_info(struct kvm_vcpu *vcpu)\r\n{\r\nia64_ptce_info_t ptce = {0};\r\nia64_get_ptce(&ptce);\r\nvcpu->arch.ptce_base = ptce.base;\r\nvcpu->arch.ptce_count[0] = ptce.count[0];\r\nvcpu->arch.ptce_count[1] = ptce.count[1];\r\nvcpu->arch.ptce_stride[0] = ptce.stride[0];\r\nvcpu->arch.ptce_stride[1] = ptce.stride[1];\r\n}\r\nstatic void kvm_migrate_hlt_timer(struct kvm_vcpu *vcpu)\r\n{\r\nstruct hrtimer *p_ht = &vcpu->arch.hlt_timer;\r\nif (hrtimer_cancel(p_ht))\r\nhrtimer_start_expires(p_ht, HRTIMER_MODE_ABS);\r\n}\r\nstatic enum hrtimer_restart hlt_timer_fn(struct hrtimer *data)\r\n{\r\nstruct kvm_vcpu *vcpu;\r\nwait_queue_head_t *q;\r\nvcpu = container_of(data, struct kvm_vcpu, arch.hlt_timer);\r\nq = &vcpu->wq;\r\nif (vcpu->arch.mp_state != KVM_MP_STATE_HALTED)\r\ngoto out;\r\nif (waitqueue_active(q))\r\nwake_up_interruptible(q);\r\nout:\r\nvcpu->arch.timer_fired = 1;\r\nvcpu->arch.timer_check = 1;\r\nreturn HRTIMER_NORESTART;\r\n}\r\nbool kvm_vcpu_compatible(struct kvm_vcpu *vcpu)\r\n{\r\nreturn irqchip_in_kernel(vcpu->kvm) == (vcpu->arch.apic != NULL);\r\n}\r\nint kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_vcpu *v;\r\nint r;\r\nint i;\r\nlong itc_offset;\r\nstruct kvm *kvm = vcpu->kvm;\r\nstruct kvm_pt_regs *regs = vcpu_regs(vcpu);\r\nunion context *p_ctx = &vcpu->arch.guest;\r\nstruct kvm_vcpu *vmm_vcpu = to_guest(vcpu->kvm, vcpu);\r\nif (IS_ERR(vmm_vcpu))\r\nreturn PTR_ERR(vmm_vcpu);\r\nif (kvm_vcpu_is_bsp(vcpu)) {\r\nvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\r\nregs->cr_iip = PALE_RESET_ENTRY;\r\nitc_offset = 0UL - kvm_get_itc(vcpu);\r\nfor (i = 0; i < KVM_MAX_VCPUS; i++) {\r\nv = (struct kvm_vcpu *)((char *)vcpu +\r\nsizeof(struct kvm_vcpu_data) * i);\r\nv->arch.itc_offset = itc_offset;\r\nv->arch.last_itc = 0;\r\n}\r\n} else\r\nvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\r\nr = -ENOMEM;\r\nvcpu->arch.apic = kzalloc(sizeof(struct kvm_lapic), GFP_KERNEL);\r\nif (!vcpu->arch.apic)\r\ngoto out;\r\nvcpu->arch.apic->vcpu = vcpu;\r\np_ctx->gr[1] = 0;\r\np_ctx->gr[12] = (unsigned long)((char *)vmm_vcpu + KVM_STK_OFFSET);\r\np_ctx->gr[13] = (unsigned long)vmm_vcpu;\r\np_ctx->psr = 0x1008522000UL;\r\np_ctx->ar[40] = FPSR_DEFAULT;\r\np_ctx->caller_unat = 0;\r\np_ctx->pr = 0x0;\r\np_ctx->ar[36] = 0x0;\r\np_ctx->ar[19] = 0x0;\r\np_ctx->ar[18] = (unsigned long)vmm_vcpu +\r\n((sizeof(struct kvm_vcpu)+15) & ~15);\r\np_ctx->ar[64] = 0x0;\r\np_ctx->cr[0] = 0x7e04UL;\r\np_ctx->cr[2] = (unsigned long)kvm_vmm_info->vmm_ivt;\r\np_ctx->cr[8] = 0x3c;\r\np_ctx->rr[0] = 0x30;\r\np_ctx->rr[1] = 0x30;\r\np_ctx->rr[2] = 0x30;\r\np_ctx->rr[3] = 0x30;\r\np_ctx->rr[4] = 0x30;\r\np_ctx->rr[5] = 0x30;\r\np_ctx->rr[7] = 0x30;\r\np_ctx->br[0] = *(unsigned long *)kvm_vmm_info->vmm_entry;\r\nvcpu->arch.vmm_rr = kvm->arch.vmm_init_rr;\r\nvcpu->arch.metaphysical_rr0 = kvm->arch.metaphysical_rr0;\r\nvcpu->arch.metaphysical_rr4 = kvm->arch.metaphysical_rr4;\r\nhrtimer_init(&vcpu->arch.hlt_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nvcpu->arch.hlt_timer.function = hlt_timer_fn;\r\nvcpu->arch.last_run_cpu = -1;\r\nvcpu->arch.vpd = (struct vpd *)VPD_BASE(vcpu->vcpu_id);\r\nvcpu->arch.vsa_base = kvm_vsa_base;\r\nvcpu->arch.__gp = kvm_vmm_gp;\r\nvcpu->arch.dirty_log_lock_pa = __pa(&kvm->arch.dirty_log_lock);\r\nvcpu->arch.vhpt.hash = (struct thash_data *)VHPT_BASE(vcpu->vcpu_id);\r\nvcpu->arch.vtlb.hash = (struct thash_data *)VTLB_BASE(vcpu->vcpu_id);\r\ninit_ptce_info(vcpu);\r\nr = 0;\r\nout:\r\nreturn r;\r\n}\r\nstatic int vti_vcpu_setup(struct kvm_vcpu *vcpu, int id)\r\n{\r\nunsigned long psr;\r\nint r;\r\nlocal_irq_save(psr);\r\nr = kvm_insert_vmm_mapping(vcpu);\r\nlocal_irq_restore(psr);\r\nif (r)\r\ngoto fail;\r\nr = kvm_vcpu_init(vcpu, vcpu->kvm, id);\r\nif (r)\r\ngoto fail;\r\nr = vti_init_vpd(vcpu);\r\nif (r) {\r\nprintk(KERN_DEBUG"kvm: vpd init error!!\n");\r\ngoto uninit;\r\n}\r\nr = vti_create_vp(vcpu);\r\nif (r)\r\ngoto uninit;\r\nkvm_purge_vmm_mapping(vcpu);\r\nreturn 0;\r\nuninit:\r\nkvm_vcpu_uninit(vcpu);\r\nfail:\r\nreturn r;\r\n}\r\nstruct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,\r\nunsigned int id)\r\n{\r\nstruct kvm_vcpu *vcpu;\r\nunsigned long vm_base = kvm->arch.vm_base;\r\nint r;\r\nint cpu;\r\nBUG_ON(sizeof(struct kvm_vcpu) > VCPU_STRUCT_SIZE/2);\r\nr = -EINVAL;\r\nif (id >= KVM_MAX_VCPUS) {\r\nprintk(KERN_ERR"kvm: Can't configure vcpus > %ld",\r\nKVM_MAX_VCPUS);\r\ngoto fail;\r\n}\r\nr = -ENOMEM;\r\nif (!vm_base) {\r\nprintk(KERN_ERR"kvm: Create vcpu[%d] error!\n", id);\r\ngoto fail;\r\n}\r\nvcpu = (struct kvm_vcpu *)(vm_base + offsetof(struct kvm_vm_data,\r\nvcpu_data[id].vcpu_struct));\r\nvcpu->kvm = kvm;\r\ncpu = get_cpu();\r\nr = vti_vcpu_setup(vcpu, id);\r\nput_cpu();\r\nif (r) {\r\nprintk(KERN_DEBUG"kvm: vcpu_setup error!!\n");\r\ngoto fail;\r\n}\r\nreturn vcpu;\r\nfail:\r\nreturn ERR_PTR(r);\r\n}\r\nint kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\r\n{\r\nreturn 0;\r\n}\r\nint kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)\r\n{\r\nreturn 0;\r\n}\r\nint kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,\r\nstruct kvm_guest_debug *dbg)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid kvm_arch_free_vm(struct kvm *kvm)\r\n{\r\nunsigned long vm_base = kvm->arch.vm_base;\r\nif (vm_base) {\r\nmemset((void *)vm_base, 0, KVM_VM_DATA_SIZE);\r\nfree_pages(vm_base, get_order(KVM_VM_DATA_SIZE));\r\n}\r\n}\r\nstatic void kvm_release_vm_pages(struct kvm *kvm)\r\n{\r\nstruct kvm_memslots *slots;\r\nstruct kvm_memory_slot *memslot;\r\nint j;\r\nslots = kvm_memslots(kvm);\r\nkvm_for_each_memslot(memslot, slots) {\r\nfor (j = 0; j < memslot->npages; j++) {\r\nif (memslot->rmap[j])\r\nput_page((struct page *)memslot->rmap[j]);\r\n}\r\n}\r\n}\r\nvoid kvm_arch_sync_events(struct kvm *kvm)\r\n{\r\n}\r\nvoid kvm_arch_destroy_vm(struct kvm *kvm)\r\n{\r\nkvm_iommu_unmap_guest(kvm);\r\nkvm_free_all_assigned_devices(kvm);\r\nkfree(kvm->arch.vioapic);\r\nkvm_release_vm_pages(kvm);\r\n}\r\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\r\n{\r\n}\r\nvoid kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\r\n{\r\nif (cpu != vcpu->cpu) {\r\nvcpu->cpu = cpu;\r\nif (vcpu->arch.ht_active)\r\nkvm_migrate_hlt_timer(vcpu);\r\n}\r\n}\r\nint kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\r\n{\r\nstruct vpd *vpd = to_host(vcpu->kvm, vcpu->arch.vpd);\r\nint i;\r\nvcpu_load(vcpu);\r\nfor (i = 0; i < 16; i++) {\r\nregs->vpd.vgr[i] = vpd->vgr[i];\r\nregs->vpd.vbgr[i] = vpd->vbgr[i];\r\n}\r\nfor (i = 0; i < 128; i++)\r\nregs->vpd.vcr[i] = vpd->vcr[i];\r\nregs->vpd.vhpi = vpd->vhpi;\r\nregs->vpd.vnat = vpd->vnat;\r\nregs->vpd.vbnat = vpd->vbnat;\r\nregs->vpd.vpsr = vpd->vpsr;\r\nregs->vpd.vpr = vpd->vpr;\r\nmemcpy(&regs->saved_guest, &vcpu->arch.guest, sizeof(union context));\r\nSAVE_REGS(mp_state);\r\nSAVE_REGS(vmm_rr);\r\nmemcpy(regs->itrs, vcpu->arch.itrs, sizeof(struct thash_data) * NITRS);\r\nmemcpy(regs->dtrs, vcpu->arch.dtrs, sizeof(struct thash_data) * NDTRS);\r\nSAVE_REGS(itr_regions);\r\nSAVE_REGS(dtr_regions);\r\nSAVE_REGS(tc_regions);\r\nSAVE_REGS(irq_check);\r\nSAVE_REGS(itc_check);\r\nSAVE_REGS(timer_check);\r\nSAVE_REGS(timer_pending);\r\nSAVE_REGS(last_itc);\r\nfor (i = 0; i < 8; i++) {\r\nregs->vrr[i] = vcpu->arch.vrr[i];\r\nregs->ibr[i] = vcpu->arch.ibr[i];\r\nregs->dbr[i] = vcpu->arch.dbr[i];\r\n}\r\nfor (i = 0; i < 4; i++)\r\nregs->insvc[i] = vcpu->arch.insvc[i];\r\nregs->saved_itc = vcpu->arch.itc_offset + kvm_get_itc(vcpu);\r\nSAVE_REGS(xtp);\r\nSAVE_REGS(metaphysical_rr0);\r\nSAVE_REGS(metaphysical_rr4);\r\nSAVE_REGS(metaphysical_saved_rr0);\r\nSAVE_REGS(metaphysical_saved_rr4);\r\nSAVE_REGS(fp_psr);\r\nSAVE_REGS(saved_gp);\r\nvcpu_put(vcpu);\r\nreturn 0;\r\n}\r\nint kvm_arch_vcpu_ioctl_get_stack(struct kvm_vcpu *vcpu,\r\nstruct kvm_ia64_vcpu_stack *stack)\r\n{\r\nmemcpy(stack, vcpu, sizeof(struct kvm_ia64_vcpu_stack));\r\nreturn 0;\r\n}\r\nint kvm_arch_vcpu_ioctl_set_stack(struct kvm_vcpu *vcpu,\r\nstruct kvm_ia64_vcpu_stack *stack)\r\n{\r\nmemcpy(vcpu + 1, &stack->stack[0] + sizeof(struct kvm_vcpu),\r\nsizeof(struct kvm_ia64_vcpu_stack) - sizeof(struct kvm_vcpu));\r\nvcpu->arch.exit_data = ((struct kvm_vcpu *)stack)->arch.exit_data;\r\nreturn 0;\r\n}\r\nvoid kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\r\n{\r\nhrtimer_cancel(&vcpu->arch.hlt_timer);\r\nkfree(vcpu->arch.apic);\r\n}\r\nlong kvm_arch_vcpu_ioctl(struct file *filp,\r\nunsigned int ioctl, unsigned long arg)\r\n{\r\nstruct kvm_vcpu *vcpu = filp->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nstruct kvm_ia64_vcpu_stack *stack = NULL;\r\nlong r;\r\nswitch (ioctl) {\r\ncase KVM_IA64_VCPU_GET_STACK: {\r\nstruct kvm_ia64_vcpu_stack __user *user_stack;\r\nvoid __user *first_p = argp;\r\nr = -EFAULT;\r\nif (copy_from_user(&user_stack, first_p, sizeof(void *)))\r\ngoto out;\r\nif (!access_ok(VERIFY_WRITE, user_stack,\r\nsizeof(struct kvm_ia64_vcpu_stack))) {\r\nprintk(KERN_INFO "KVM_IA64_VCPU_GET_STACK: "\r\n"Illegal user destination address for stack\n");\r\ngoto out;\r\n}\r\nstack = kzalloc(sizeof(struct kvm_ia64_vcpu_stack), GFP_KERNEL);\r\nif (!stack) {\r\nr = -ENOMEM;\r\ngoto out;\r\n}\r\nr = kvm_arch_vcpu_ioctl_get_stack(vcpu, stack);\r\nif (r)\r\ngoto out;\r\nif (copy_to_user(user_stack, stack,\r\nsizeof(struct kvm_ia64_vcpu_stack))) {\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\ncase KVM_IA64_VCPU_SET_STACK: {\r\nstruct kvm_ia64_vcpu_stack __user *user_stack;\r\nvoid __user *first_p = argp;\r\nr = -EFAULT;\r\nif (copy_from_user(&user_stack, first_p, sizeof(void *)))\r\ngoto out;\r\nif (!access_ok(VERIFY_READ, user_stack,\r\nsizeof(struct kvm_ia64_vcpu_stack))) {\r\nprintk(KERN_INFO "KVM_IA64_VCPU_SET_STACK: "\r\n"Illegal user address for stack\n");\r\ngoto out;\r\n}\r\nstack = kmalloc(sizeof(struct kvm_ia64_vcpu_stack), GFP_KERNEL);\r\nif (!stack) {\r\nr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(stack, user_stack,\r\nsizeof(struct kvm_ia64_vcpu_stack)))\r\ngoto out;\r\nr = kvm_arch_vcpu_ioctl_set_stack(vcpu, stack);\r\nbreak;\r\n}\r\ndefault:\r\nr = -EINVAL;\r\n}\r\nout:\r\nkfree(stack);\r\nreturn r;\r\n}\r\nint kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)\r\n{\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nvoid kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,\r\nstruct kvm_memory_slot *dont)\r\n{\r\n}\r\nint kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,\r\nunsigned long npages)\r\n{\r\nreturn 0;\r\n}\r\nvoid kvm_arch_memslots_updated(struct kvm *kvm)\r\n{\r\n}\r\nint kvm_arch_prepare_memory_region(struct kvm *kvm,\r\nstruct kvm_memory_slot *memslot,\r\nstruct kvm_userspace_memory_region *mem,\r\nenum kvm_mr_change change)\r\n{\r\nunsigned long i;\r\nunsigned long pfn;\r\nint npages = memslot->npages;\r\nunsigned long base_gfn = memslot->base_gfn;\r\nif (base_gfn + npages > (KVM_MAX_MEM_SIZE >> PAGE_SHIFT))\r\nreturn -ENOMEM;\r\nfor (i = 0; i < npages; i++) {\r\npfn = gfn_to_pfn(kvm, base_gfn + i);\r\nif (!kvm_is_mmio_pfn(pfn)) {\r\nkvm_set_pmt_entry(kvm, base_gfn + i,\r\npfn << PAGE_SHIFT,\r\n_PAGE_AR_RWX | _PAGE_MA_WB);\r\nmemslot->rmap[i] = (unsigned long)pfn_to_page(pfn);\r\n} else {\r\nkvm_set_pmt_entry(kvm, base_gfn + i,\r\nGPFN_PHYS_MMIO | (pfn << PAGE_SHIFT),\r\n_PAGE_MA_UC);\r\nmemslot->rmap[i] = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid kvm_arch_commit_memory_region(struct kvm *kvm,\r\nstruct kvm_userspace_memory_region *mem,\r\nconst struct kvm_memory_slot *old,\r\nenum kvm_mr_change change)\r\n{\r\nreturn;\r\n}\r\nvoid kvm_arch_flush_shadow_all(struct kvm *kvm)\r\n{\r\nkvm_flush_remote_tlbs(kvm);\r\n}\r\nvoid kvm_arch_flush_shadow_memslot(struct kvm *kvm,\r\nstruct kvm_memory_slot *slot)\r\n{\r\nkvm_arch_flush_shadow_all();\r\n}\r\nlong kvm_arch_dev_ioctl(struct file *filp,\r\nunsigned int ioctl, unsigned long arg)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)\r\n{\r\nkvm_vcpu_uninit(vcpu);\r\n}\r\nstatic int vti_cpu_has_kvm_support(void)\r\n{\r\nlong avail = 1, status = 1, control = 1;\r\nlong ret;\r\nret = ia64_pal_proc_get_features(&avail, &status, &control, 0);\r\nif (ret)\r\ngoto out;\r\nif (!(avail & PAL_PROC_VM_BIT))\r\ngoto out;\r\nprintk(KERN_DEBUG"kvm: Hardware Supports VT\n");\r\nret = ia64_pal_vp_env_info(&kvm_vm_buffer_size, &vp_env_info);\r\nif (ret)\r\ngoto out;\r\nprintk(KERN_DEBUG"kvm: VM Buffer Size:0x%lx\n", kvm_vm_buffer_size);\r\nif (!(vp_env_info & VP_OPCODE)) {\r\nprintk(KERN_WARNING"kvm: No opcode ability on hardware, "\r\n"vm_env_info:0x%lx\n", vp_env_info);\r\n}\r\nreturn 1;\r\nout:\r\nreturn 0;\r\n}\r\nstatic void kvm_patch_vmm(struct kvm_vmm_info *vmm_info,\r\nstruct module *module)\r\n{\r\nunsigned long new_ar, new_ar_sn2;\r\nunsigned long module_base;\r\nif (!ia64_platform_is("sn2"))\r\nreturn;\r\nmodule_base = (unsigned long)module->module_core;\r\nnew_ar = kvm_vmm_base + vmm_info->patch_mov_ar - module_base;\r\nnew_ar_sn2 = kvm_vmm_base + vmm_info->patch_mov_ar_sn2 - module_base;\r\nprintk(KERN_INFO "kvm: Patching ITC emulation to use SGI SN2 RTC "\r\n"as source\n");\r\nmemcpy((void *)new_ar, (void *)new_ar_sn2, 0x60);\r\n}\r\nstatic int kvm_relocate_vmm(struct kvm_vmm_info *vmm_info,\r\nstruct module *module)\r\n{\r\nunsigned long module_base;\r\nunsigned long vmm_size;\r\nunsigned long vmm_offset, func_offset, fdesc_offset;\r\nstruct fdesc *p_fdesc;\r\nBUG_ON(!module);\r\nif (!kvm_vmm_base) {\r\nprintk("kvm: kvm area hasn't been initialized yet!!\n");\r\nreturn -EFAULT;\r\n}\r\nmodule_base = (unsigned long)module->module_core;\r\nvmm_size = module->core_size;\r\nif (unlikely(vmm_size > KVM_VMM_SIZE))\r\nreturn -EFAULT;\r\nmemcpy((void *)kvm_vmm_base, (void *)module_base, vmm_size);\r\nkvm_patch_vmm(vmm_info, module);\r\nkvm_flush_icache(kvm_vmm_base, vmm_size);\r\nvmm_offset = vmm_info->vmm_ivt - module_base;\r\nkvm_vmm_info->vmm_ivt = KVM_VMM_BASE + vmm_offset;\r\nprintk(KERN_DEBUG"kvm: Relocated VMM's IVT Base Addr:%lx\n",\r\nkvm_vmm_info->vmm_ivt);\r\nfdesc_offset = (unsigned long)vmm_info->vmm_entry - module_base;\r\nkvm_vmm_info->vmm_entry = (kvm_vmm_entry *)(KVM_VMM_BASE +\r\nfdesc_offset);\r\nfunc_offset = *(unsigned long *)vmm_info->vmm_entry - module_base;\r\np_fdesc = (struct fdesc *)(kvm_vmm_base + fdesc_offset);\r\np_fdesc->ip = KVM_VMM_BASE + func_offset;\r\np_fdesc->gp = KVM_VMM_BASE+(p_fdesc->gp - module_base);\r\nprintk(KERN_DEBUG"kvm: Relocated VMM's Init Entry Addr:%lx\n",\r\nKVM_VMM_BASE+func_offset);\r\nfdesc_offset = (unsigned long)vmm_info->tramp_entry - module_base;\r\nkvm_vmm_info->tramp_entry = (kvm_tramp_entry *)(KVM_VMM_BASE +\r\nfdesc_offset);\r\nfunc_offset = *(unsigned long *)vmm_info->tramp_entry - module_base;\r\np_fdesc = (struct fdesc *)(kvm_vmm_base + fdesc_offset);\r\np_fdesc->ip = KVM_VMM_BASE + func_offset;\r\np_fdesc->gp = KVM_VMM_BASE + (p_fdesc->gp - module_base);\r\nkvm_vmm_gp = p_fdesc->gp;\r\nprintk(KERN_DEBUG"kvm: Relocated VMM's Entry IP:%p\n",\r\nkvm_vmm_info->vmm_entry);\r\nprintk(KERN_DEBUG"kvm: Relocated VMM's Trampoline Entry IP:0x%lx\n",\r\nKVM_VMM_BASE + func_offset);\r\nreturn 0;\r\n}\r\nint kvm_arch_init(void *opaque)\r\n{\r\nint r;\r\nstruct kvm_vmm_info *vmm_info = (struct kvm_vmm_info *)opaque;\r\nif (!vti_cpu_has_kvm_support()) {\r\nprintk(KERN_ERR "kvm: No Hardware Virtualization Support!\n");\r\nr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (kvm_vmm_info) {\r\nprintk(KERN_ERR "kvm: Already loaded VMM module!\n");\r\nr = -EEXIST;\r\ngoto out;\r\n}\r\nr = -ENOMEM;\r\nkvm_vmm_info = kzalloc(sizeof(struct kvm_vmm_info), GFP_KERNEL);\r\nif (!kvm_vmm_info)\r\ngoto out;\r\nif (kvm_alloc_vmm_area())\r\ngoto out_free0;\r\nr = kvm_relocate_vmm(vmm_info, vmm_info->module);\r\nif (r)\r\ngoto out_free1;\r\nreturn 0;\r\nout_free1:\r\nkvm_free_vmm_area();\r\nout_free0:\r\nkfree(kvm_vmm_info);\r\nout:\r\nreturn r;\r\n}\r\nvoid kvm_arch_exit(void)\r\n{\r\nkvm_free_vmm_area();\r\nkfree(kvm_vmm_info);\r\nkvm_vmm_info = NULL;\r\n}\r\nstatic void kvm_ia64_sync_dirty_log(struct kvm *kvm,\r\nstruct kvm_memory_slot *memslot)\r\n{\r\nint i;\r\nlong base;\r\nunsigned long n;\r\nunsigned long *dirty_bitmap = (unsigned long *)(kvm->arch.vm_base +\r\noffsetof(struct kvm_vm_data, kvm_mem_dirty_log));\r\nn = kvm_dirty_bitmap_bytes(memslot);\r\nbase = memslot->base_gfn / BITS_PER_LONG;\r\nspin_lock(&kvm->arch.dirty_log_lock);\r\nfor (i = 0; i < n/sizeof(long); ++i) {\r\nmemslot->dirty_bitmap[i] = dirty_bitmap[base + i];\r\ndirty_bitmap[base + i] = 0;\r\n}\r\nspin_unlock(&kvm->arch.dirty_log_lock);\r\n}\r\nint kvm_vm_ioctl_get_dirty_log(struct kvm *kvm,\r\nstruct kvm_dirty_log *log)\r\n{\r\nint r;\r\nunsigned long n;\r\nstruct kvm_memory_slot *memslot;\r\nint is_dirty = 0;\r\nmutex_lock(&kvm->slots_lock);\r\nr = -EINVAL;\r\nif (log->slot >= KVM_USER_MEM_SLOTS)\r\ngoto out;\r\nmemslot = id_to_memslot(kvm->memslots, log->slot);\r\nr = -ENOENT;\r\nif (!memslot->dirty_bitmap)\r\ngoto out;\r\nkvm_ia64_sync_dirty_log(kvm, memslot);\r\nr = kvm_get_dirty_log(kvm, log, &is_dirty);\r\nif (r)\r\ngoto out;\r\nif (is_dirty) {\r\nkvm_flush_remote_tlbs(kvm);\r\nn = kvm_dirty_bitmap_bytes(memslot);\r\nmemset(memslot->dirty_bitmap, 0, n);\r\n}\r\nr = 0;\r\nout:\r\nmutex_unlock(&kvm->slots_lock);\r\nreturn r;\r\n}\r\nint kvm_arch_hardware_setup(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid kvm_arch_hardware_unsetup(void)\r\n{\r\n}\r\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq)\r\n{\r\nreturn __apic_accept_irq(vcpu, irq->vector);\r\n}\r\nint kvm_apic_match_physical_addr(struct kvm_lapic *apic, u16 dest)\r\n{\r\nreturn apic->vcpu->vcpu_id == dest;\r\n}\r\nint kvm_apic_match_logical_addr(struct kvm_lapic *apic, u8 mda)\r\n{\r\nreturn 0;\r\n}\r\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\r\n{\r\nreturn vcpu1->arch.xtp - vcpu2->arch.xtp;\r\n}\r\nint kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\r\nint short_hand, int dest, int dest_mode)\r\n{\r\nstruct kvm_lapic *target = vcpu->arch.apic;\r\nreturn (dest_mode == 0) ?\r\nkvm_apic_match_physical_addr(target, dest) :\r\nkvm_apic_match_logical_addr(target, dest);\r\n}\r\nstatic int find_highest_bits(int *dat)\r\n{\r\nu32 bits, bitnum;\r\nint i;\r\nfor (i = 7; i >= 0 ; i--) {\r\nbits = dat[i];\r\nif (bits) {\r\nbitnum = fls(bits);\r\nreturn i * 32 + bitnum - 1;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nint kvm_highest_pending_irq(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vpd *vpd = to_host(vcpu->kvm, vcpu->arch.vpd);\r\nif (vpd->irr[0] & (1UL << NMI_VECTOR))\r\nreturn NMI_VECTOR;\r\nif (vpd->irr[0] & (1UL << ExtINT_VECTOR))\r\nreturn ExtINT_VECTOR;\r\nreturn find_highest_bits((int *)&vpd->irr[0]);\r\n}\r\nint kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)\r\n{\r\nreturn vcpu->arch.timer_fired;\r\n}\r\nint kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\r\n{\r\nreturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE) ||\r\n(kvm_highest_pending_irq(vcpu) != -1);\r\n}\r\nint kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)\r\n{\r\nreturn (!test_and_set_bit(KVM_REQ_KICK, &vcpu->requests));\r\n}\r\nint kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,\r\nstruct kvm_mp_state *mp_state)\r\n{\r\nmp_state->mp_state = vcpu->arch.mp_state;\r\nreturn 0;\r\n}\r\nstatic int vcpu_reset(struct kvm_vcpu *vcpu)\r\n{\r\nint r;\r\nlong psr;\r\nlocal_irq_save(psr);\r\nr = kvm_insert_vmm_mapping(vcpu);\r\nlocal_irq_restore(psr);\r\nif (r)\r\ngoto fail;\r\nvcpu->arch.launched = 0;\r\nkvm_arch_vcpu_uninit(vcpu);\r\nr = kvm_arch_vcpu_init(vcpu);\r\nif (r)\r\ngoto fail;\r\nkvm_purge_vmm_mapping(vcpu);\r\nr = 0;\r\nfail:\r\nreturn r;\r\n}\r\nint kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,\r\nstruct kvm_mp_state *mp_state)\r\n{\r\nint r = 0;\r\nvcpu->arch.mp_state = mp_state->mp_state;\r\nif (vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)\r\nr = vcpu_reset(vcpu);\r\nreturn r;\r\n}
