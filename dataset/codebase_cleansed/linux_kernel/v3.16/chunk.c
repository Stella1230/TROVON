static void sctp_datamsg_init(struct sctp_datamsg *msg)\r\n{\r\natomic_set(&msg->refcnt, 1);\r\nmsg->send_failed = 0;\r\nmsg->send_error = 0;\r\nmsg->can_abandon = 0;\r\nmsg->can_delay = 1;\r\nmsg->expires_at = 0;\r\nINIT_LIST_HEAD(&msg->chunks);\r\n}\r\nstatic struct sctp_datamsg *sctp_datamsg_new(gfp_t gfp)\r\n{\r\nstruct sctp_datamsg *msg;\r\nmsg = kmalloc(sizeof(struct sctp_datamsg), gfp);\r\nif (msg) {\r\nsctp_datamsg_init(msg);\r\nSCTP_DBG_OBJCNT_INC(datamsg);\r\n}\r\nreturn msg;\r\n}\r\nvoid sctp_datamsg_free(struct sctp_datamsg *msg)\r\n{\r\nstruct sctp_chunk *chunk;\r\nlist_for_each_entry(chunk, &msg->chunks, frag_list)\r\nsctp_chunk_free(chunk);\r\nsctp_datamsg_put(msg);\r\n}\r\nstatic void sctp_datamsg_destroy(struct sctp_datamsg *msg)\r\n{\r\nstruct list_head *pos, *temp;\r\nstruct sctp_chunk *chunk;\r\nstruct sctp_sock *sp;\r\nstruct sctp_ulpevent *ev;\r\nstruct sctp_association *asoc = NULL;\r\nint error = 0, notify;\r\nnotify = msg->send_failed ? -1 : 0;\r\nlist_for_each_safe(pos, temp, &msg->chunks) {\r\nlist_del_init(pos);\r\nchunk = list_entry(pos, struct sctp_chunk, frag_list);\r\nif (notify < 0) {\r\nasoc = chunk->asoc;\r\nif (msg->send_error)\r\nerror = msg->send_error;\r\nelse\r\nerror = asoc->outqueue.error;\r\nsp = sctp_sk(asoc->base.sk);\r\nnotify = sctp_ulpevent_type_enabled(SCTP_SEND_FAILED,\r\n&sp->subscribe);\r\n}\r\nif (notify > 0) {\r\nint sent;\r\nif (chunk->has_tsn)\r\nsent = SCTP_DATA_SENT;\r\nelse\r\nsent = SCTP_DATA_UNSENT;\r\nev = sctp_ulpevent_make_send_failed(asoc, chunk, sent,\r\nerror, GFP_ATOMIC);\r\nif (ev)\r\nsctp_ulpq_tail_event(&asoc->ulpq, ev);\r\n}\r\nsctp_chunk_put(chunk);\r\n}\r\nSCTP_DBG_OBJCNT_DEC(datamsg);\r\nkfree(msg);\r\n}\r\nstatic void sctp_datamsg_hold(struct sctp_datamsg *msg)\r\n{\r\natomic_inc(&msg->refcnt);\r\n}\r\nvoid sctp_datamsg_put(struct sctp_datamsg *msg)\r\n{\r\nif (atomic_dec_and_test(&msg->refcnt))\r\nsctp_datamsg_destroy(msg);\r\n}\r\nstatic void sctp_datamsg_assign(struct sctp_datamsg *msg, struct sctp_chunk *chunk)\r\n{\r\nsctp_datamsg_hold(msg);\r\nchunk->msg = msg;\r\n}\r\nstruct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *asoc,\r\nstruct sctp_sndrcvinfo *sinfo,\r\nstruct msghdr *msgh, int msg_len)\r\n{\r\nint max, whole, i, offset, over, err;\r\nint len, first_len;\r\nint max_data;\r\nstruct sctp_chunk *chunk;\r\nstruct sctp_datamsg *msg;\r\nstruct list_head *pos, *temp;\r\n__u8 frag;\r\nmsg = sctp_datamsg_new(GFP_KERNEL);\r\nif (!msg)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (sinfo->sinfo_timetolive) {\r\nmsg->expires_at = jiffies +\r\nmsecs_to_jiffies(sinfo->sinfo_timetolive);\r\nmsg->can_abandon = 1;\r\npr_debug("%s: msg:%p expires_at:%ld jiffies:%ld\n", __func__,\r\nmsg, msg->expires_at, jiffies);\r\n}\r\nmax_data = (asoc->pathmtu -\r\nsctp_sk(asoc->base.sk)->pf->af->net_header_len -\r\nsizeof(struct sctphdr) - sizeof(struct sctp_data_chunk)) & ~3;\r\nmax = asoc->frag_point;\r\nif (sctp_auth_send_cid(SCTP_CID_DATA, asoc)) {\r\nstruct sctp_hmac *hmac_desc = sctp_auth_asoc_get_hmac(asoc);\r\nif (hmac_desc)\r\nmax_data -= WORD_ROUND(sizeof(sctp_auth_chunk_t) +\r\nhmac_desc->hmac_len);\r\n}\r\nif (max > max_data)\r\nmax = max_data;\r\nwhole = 0;\r\nfirst_len = max;\r\nif (timer_pending(&asoc->timers[SCTP_EVENT_TIMEOUT_SACK]) &&\r\nasoc->outqueue.out_qlen == 0 &&\r\nlist_empty(&asoc->outqueue.retransmit) &&\r\nmsg_len > max)\r\nmax_data -= WORD_ROUND(sizeof(sctp_sack_chunk_t));\r\nif (asoc->state < SCTP_STATE_COOKIE_ECHOED)\r\nmax_data -= SCTP_ARBITRARY_COOKIE_ECHO_LEN;\r\nif (first_len > max_data)\r\nfirst_len = max_data;\r\nif (msg_len >= first_len) {\r\nmsg_len -= first_len;\r\nwhole = 1;\r\nmsg->can_delay = 0;\r\n}\r\nwhole += msg_len / max;\r\nover = msg_len % max;\r\noffset = 0;\r\nif ((whole > 1) || (whole && over))\r\nSCTP_INC_STATS_USER(sock_net(asoc->base.sk), SCTP_MIB_FRAGUSRMSGS);\r\nfor (i = 0, len = first_len; i < whole; i++) {\r\nfrag = SCTP_DATA_MIDDLE_FRAG;\r\nif (0 == i)\r\nfrag |= SCTP_DATA_FIRST_FRAG;\r\nif ((i == (whole - 1)) && !over) {\r\nfrag |= SCTP_DATA_LAST_FRAG;\r\nif ((sinfo->sinfo_flags & SCTP_EOF) ||\r\n(sinfo->sinfo_flags & SCTP_SACK_IMMEDIATELY))\r\nfrag |= SCTP_DATA_SACK_IMM;\r\n}\r\nchunk = sctp_make_datafrag_empty(asoc, sinfo, len, frag, 0);\r\nif (!chunk) {\r\nerr = -ENOMEM;\r\ngoto errout;\r\n}\r\nerr = sctp_user_addto_chunk(chunk, offset, len, msgh->msg_iov);\r\nif (err < 0)\r\ngoto errout_chunk_free;\r\noffset += len;\r\n__skb_pull(chunk->skb, (__u8 *)chunk->chunk_hdr\r\n- (__u8 *)chunk->skb->data);\r\nsctp_datamsg_assign(msg, chunk);\r\nlist_add_tail(&chunk->frag_list, &msg->chunks);\r\nif (0 == i)\r\nlen = max;\r\n}\r\nif (over) {\r\nif (!whole)\r\nfrag = SCTP_DATA_NOT_FRAG;\r\nelse\r\nfrag = SCTP_DATA_LAST_FRAG;\r\nif ((sinfo->sinfo_flags & SCTP_EOF) ||\r\n(sinfo->sinfo_flags & SCTP_SACK_IMMEDIATELY))\r\nfrag |= SCTP_DATA_SACK_IMM;\r\nchunk = sctp_make_datafrag_empty(asoc, sinfo, over, frag, 0);\r\nif (!chunk) {\r\nerr = -ENOMEM;\r\ngoto errout;\r\n}\r\nerr = sctp_user_addto_chunk(chunk, offset, over, msgh->msg_iov);\r\n__skb_pull(chunk->skb, (__u8 *)chunk->chunk_hdr\r\n- (__u8 *)chunk->skb->data);\r\nif (err < 0)\r\ngoto errout_chunk_free;\r\nsctp_datamsg_assign(msg, chunk);\r\nlist_add_tail(&chunk->frag_list, &msg->chunks);\r\n}\r\nreturn msg;\r\nerrout_chunk_free:\r\nsctp_chunk_free(chunk);\r\nerrout:\r\nlist_for_each_safe(pos, temp, &msg->chunks) {\r\nlist_del_init(pos);\r\nchunk = list_entry(pos, struct sctp_chunk, frag_list);\r\nsctp_chunk_free(chunk);\r\n}\r\nsctp_datamsg_put(msg);\r\nreturn ERR_PTR(err);\r\n}\r\nint sctp_chunk_abandoned(struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_datamsg *msg = chunk->msg;\r\nif (!msg->can_abandon)\r\nreturn 0;\r\nif (time_after(jiffies, msg->expires_at))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid sctp_chunk_fail(struct sctp_chunk *chunk, int error)\r\n{\r\nchunk->msg->send_failed = 1;\r\nchunk->msg->send_error = error;\r\n}
