static inline struct drm_device *\r\ndrm_device(struct device *d)\r\n{\r\nreturn dev_get_drvdata(d);\r\n}\r\nstatic ssize_t\r\nnouveau_sysfs_pstate_get(struct device *d, struct device_attribute *a, char *b)\r\n{\r\nstruct nouveau_sysfs *sysfs = nouveau_sysfs(drm_device(d));\r\nstruct nv_control_pstate_info info;\r\nsize_t cnt = PAGE_SIZE;\r\nchar *buf = b;\r\nint ret, i;\r\nret = nv_exec(sysfs->ctrl, NV_CONTROL_PSTATE_INFO, &info, sizeof(info));\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < info.count + 1; i++) {\r\nconst s32 state = i < info.count ? i :\r\nNV_CONTROL_PSTATE_ATTR_STATE_CURRENT;\r\nstruct nv_control_pstate_attr attr = {\r\n.state = state,\r\n.index = 0,\r\n};\r\nret = nv_exec(sysfs->ctrl, NV_CONTROL_PSTATE_ATTR,\r\n&attr, sizeof(attr));\r\nif (ret)\r\nreturn ret;\r\nif (i < info.count)\r\nsnappendf(buf, cnt, "%02x:", attr.state);\r\nelse\r\nsnappendf(buf, cnt, "--:");\r\nattr.index = 0;\r\ndo {\r\nattr.state = state;\r\nret = nv_exec(sysfs->ctrl, NV_CONTROL_PSTATE_ATTR,\r\n&attr, sizeof(attr));\r\nif (ret)\r\nreturn ret;\r\nsnappendf(buf, cnt, " %s %d", attr.name, attr.min);\r\nif (attr.min != attr.max)\r\nsnappendf(buf, cnt, "-%d", attr.max);\r\nsnappendf(buf, cnt, " %s", attr.unit);\r\n} while (attr.index);\r\nif ((state >= 0 && info.pstate == state) ||\r\n(state < 0 && info.ustate < 0))\r\nsnappendf(buf, cnt, " *");\r\nsnappendf(buf, cnt, "\n");\r\n}\r\nreturn strlen(b);\r\n}\r\nstatic ssize_t\r\nnouveau_sysfs_pstate_set(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nouveau_sysfs *sysfs = nouveau_sysfs(drm_device(d));\r\nstruct nv_control_pstate_user args;\r\nlong value, ret;\r\nchar *tmp;\r\nif ((tmp = strchr(buf, '\n')))\r\n*tmp = '\0';\r\nif (!strcasecmp(buf, "none"))\r\nargs.state = NV_CONTROL_PSTATE_USER_STATE_UNKNOWN;\r\nelse\r\nif (!strcasecmp(buf, "auto"))\r\nargs.state = NV_CONTROL_PSTATE_USER_STATE_PERFMON;\r\nelse {\r\nret = kstrtol(buf, 16, &value);\r\nif (ret)\r\nreturn ret;\r\nargs.state = value;\r\n}\r\nret = nv_exec(sysfs->ctrl, NV_CONTROL_PSTATE_USER, &args, sizeof(args));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nvoid\r\nnouveau_sysfs_fini(struct drm_device *dev)\r\n{\r\nstruct nouveau_sysfs *sysfs = nouveau_sysfs(dev);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nif (sysfs->ctrl) {\r\ndevice_remove_file(nv_device_base(device), &dev_attr_pstate);\r\nnouveau_object_del(nv_object(drm), NVDRM_DEVICE, NVDRM_CONTROL);\r\n}\r\ndrm->sysfs = NULL;\r\nkfree(sysfs);\r\n}\r\nint\r\nnouveau_sysfs_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct nouveau_sysfs *sysfs;\r\nint ret;\r\nsysfs = drm->sysfs = kzalloc(sizeof(*sysfs), GFP_KERNEL);\r\nif (!sysfs)\r\nreturn -ENOMEM;\r\nret = nouveau_object_new(nv_object(drm), NVDRM_DEVICE, NVDRM_CONTROL,\r\nNV_CONTROL_CLASS, NULL, 0, &sysfs->ctrl);\r\nif (ret == 0)\r\ndevice_create_file(nv_device_base(device), &dev_attr_pstate);\r\nreturn 0;\r\n}
