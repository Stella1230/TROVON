static struct max77686_clk *to_max77686_clk(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct max77686_clk, hw);\r\n}\r\nstatic int max77686_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct max77686_clk *max77686 = to_max77686_clk(hw);\r\nreturn regmap_update_bits(max77686->iodev->regmap,\r\nMAX77686_REG_32KHZ, max77686->mask,\r\nmax77686->mask);\r\n}\r\nstatic void max77686_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct max77686_clk *max77686 = to_max77686_clk(hw);\r\nregmap_update_bits(max77686->iodev->regmap,\r\nMAX77686_REG_32KHZ, max77686->mask, ~max77686->mask);\r\n}\r\nstatic int max77686_clk_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct max77686_clk *max77686 = to_max77686_clk(hw);\r\nint ret;\r\nu32 val;\r\nret = regmap_read(max77686->iodev->regmap,\r\nMAX77686_REG_32KHZ, &val);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nreturn val & max77686->mask;\r\n}\r\nstatic unsigned long max77686_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 32768;\r\n}\r\nstatic struct clk *max77686_clk_register(struct device *dev,\r\nstruct max77686_clk *max77686)\r\n{\r\nstruct clk *clk;\r\nstruct clk_hw *hw = &max77686->hw;\r\nclk = clk_register(dev, hw);\r\nif (IS_ERR(clk))\r\nreturn clk;\r\nmax77686->lookup = kzalloc(sizeof(struct clk_lookup), GFP_KERNEL);\r\nif (!max77686->lookup)\r\nreturn ERR_PTR(-ENOMEM);\r\nmax77686->lookup->con_id = hw->init->name;\r\nmax77686->lookup->clk = clk;\r\nclkdev_add(max77686->lookup);\r\nreturn clk;\r\n}\r\nstatic int max77686_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct max77686_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct max77686_clk *max77686_clks[MAX77686_CLKS_NUM];\r\nstruct clk **clocks;\r\nint i, ret;\r\nclocks = devm_kzalloc(&pdev->dev, sizeof(struct clk *)\r\n* MAX77686_CLKS_NUM, GFP_KERNEL);\r\nif (!clocks)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < MAX77686_CLKS_NUM; i++) {\r\nmax77686_clks[i] = devm_kzalloc(&pdev->dev,\r\nsizeof(struct max77686_clk), GFP_KERNEL);\r\nif (!max77686_clks[i])\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < MAX77686_CLKS_NUM; i++) {\r\nmax77686_clks[i]->iodev = iodev;\r\nmax77686_clks[i]->mask = 1 << i;\r\nmax77686_clks[i]->hw.init = &max77686_clks_init[i];\r\nclocks[i] = max77686_clk_register(&pdev->dev, max77686_clks[i]);\r\nif (IS_ERR(clocks[i])) {\r\nret = PTR_ERR(clocks[i]);\r\ndev_err(&pdev->dev, "failed to register %s\n",\r\nmax77686_clks[i]->hw.init->name);\r\ngoto err_clocks;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, clocks);\r\nif (iodev->dev->of_node) {\r\nstruct clk_onecell_data *of_data;\r\nof_data = devm_kzalloc(&pdev->dev,\r\nsizeof(*of_data), GFP_KERNEL);\r\nif (!of_data) {\r\nret = -ENOMEM;\r\ngoto err_clocks;\r\n}\r\nof_data->clks = clocks;\r\nof_data->clk_num = MAX77686_CLKS_NUM;\r\nret = of_clk_add_provider(iodev->dev->of_node,\r\nof_clk_src_onecell_get, of_data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register OF clock provider\n");\r\ngoto err_clocks;\r\n}\r\n}\r\nreturn 0;\r\nerr_clocks:\r\nfor (--i; i >= 0; --i) {\r\nclkdev_drop(max77686_clks[i]->lookup);\r\nclk_unregister(max77686_clks[i]->hw.clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int max77686_clk_remove(struct platform_device *pdev)\r\n{\r\nstruct max77686_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct clk **clocks = platform_get_drvdata(pdev);\r\nint i;\r\nif (iodev->dev->of_node)\r\nof_clk_del_provider(iodev->dev->of_node);\r\nfor (i = 0; i < MAX77686_CLKS_NUM; i++) {\r\nstruct clk_hw *hw = __clk_get_hw(clocks[i]);\r\nstruct max77686_clk *max77686 = to_max77686_clk(hw);\r\nclkdev_drop(max77686->lookup);\r\nclk_unregister(clocks[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init max77686_clk_init(void)\r\n{\r\nreturn platform_driver_register(&max77686_clk_driver);\r\n}\r\nstatic void __init max77686_clk_cleanup(void)\r\n{\r\nplatform_driver_unregister(&max77686_clk_driver);\r\n}
