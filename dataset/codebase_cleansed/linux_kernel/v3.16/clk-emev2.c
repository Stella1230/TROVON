static void __init emev2_smu_write(unsigned long value, int offs)\r\n{\r\nBUG_ON(!smu_base || (offs >= PAGE_SIZE));\r\nwritel_relaxed(value, smu_base + offs);\r\n}\r\nstatic void __init emev2_smu_init(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_matching_node(NULL, smu_id);\r\nBUG_ON(!np);\r\nsmu_base = of_iomap(np, 0);\r\nBUG_ON(!smu_base);\r\nof_node_put(np);\r\nemev2_smu_write(0, STI_CLKSEL);\r\nemev2_smu_write(1, STI_RSTCTRL);\r\nemev2_smu_write(2, USIAU0_RSTCTRL);\r\nemev2_smu_write(2, USIBU1_RSTCTRL);\r\nemev2_smu_write(2, USIBU2_RSTCTRL);\r\nemev2_smu_write(2, USIBU3_RSTCTRL);\r\n}\r\nstatic void __init emev2_smu_clkdiv_init(struct device_node *np)\r\n{\r\nu32 reg[2];\r\nstruct clk *clk;\r\nconst char *parent_name = of_clk_get_parent_name(np, 0);\r\nif (WARN_ON(of_property_read_u32_array(np, "reg", reg, 2)))\r\nreturn;\r\nif (!smu_base)\r\nemev2_smu_init();\r\nclk = clk_register_divider(NULL, np->name, parent_name, 0,\r\nsmu_base + reg[0], reg[1], 8, 0, &lock);\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nclk_register_clkdev(clk, np->name, NULL);\r\npr_debug("## %s %s %p\n", __func__, np->name, clk);\r\n}\r\nstatic void __init emev2_smu_gclk_init(struct device_node *np)\r\n{\r\nu32 reg[2];\r\nstruct clk *clk;\r\nconst char *parent_name = of_clk_get_parent_name(np, 0);\r\nif (WARN_ON(of_property_read_u32_array(np, "reg", reg, 2)))\r\nreturn;\r\nif (!smu_base)\r\nemev2_smu_init();\r\nclk = clk_register_gate(NULL, np->name, parent_name, 0,\r\nsmu_base + reg[0], reg[1], 0, &lock);\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nclk_register_clkdev(clk, np->name, NULL);\r\npr_debug("## %s %s %p\n", __func__, np->name, clk);\r\n}
